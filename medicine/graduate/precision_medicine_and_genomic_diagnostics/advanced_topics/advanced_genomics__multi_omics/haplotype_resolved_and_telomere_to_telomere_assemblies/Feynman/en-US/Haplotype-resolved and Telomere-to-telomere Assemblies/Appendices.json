{
    "hands_on_practices": [
        {
            "introduction": "The ultimate goal of a T2T assembly is a sequence that is not only complete but also highly accurate at the base level, a prerequisite for reliable variant calling in precision medicine. This exercise guides you through the derivation of the Phred-like quality value ($QV$), the gold standard for communicating base-level error probabilities in genomics. By building the $QV$ scale from first principles, you will gain a robust understanding of how we quantify and benchmark the near-perfect accuracy required for clinical applications .",
            "id": "4348221",
            "problem": "A telomere-to-telomere (T2T) haplotype-resolved assembly intended for precision oncology reporting must be benchmarked by its base-level consensus accuracy. The assembly accuracy is communicated on the Phred-like quality value (QV) scale that is widely used in genomic diagnostics. In this scale, a smaller consensus error probability per base, denoted by $e \\in (0,1)$, maps to a larger $QV$. The Phred-like mapping is defined by two fundamental properties of logarithmic decibel-like representations used for probabilities:\n1) Multiplicative changes in error probability correspond to additive changes on the scale: for any $e_{1}, e_{2} \\in (0,1)$, the difference $QV(e_{2}) - QV(e_{1})$ depends only on the ratio $e_{2}/e_{1}$ and is proportional to $\\log_{10}(e_{1}/e_{2})$ with proportionality constant $10$.\n2) The scale is anchored so that the worst possible consensus, $e=1$, has $QV(1)=0$.\n\nStarting only from these two properties and standard probability rules, derive an explicit expression for $QV$ as a function of $e$. Then, modeling the number of consensus base errors in an independently and identically distributed $1$ megabase segment as having expected value equal to $N e$ with $N=10^{6}$ bases, determine the minimal $QV$ threshold required to achieve fewer than one expected error per megabase. Express the final $QV$ as a single unitless number; no rounding is required.",
            "solution": "The problem is evaluated as valid, as it is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. The concepts of Phred-like quality scores (QV) and error probability are central to genomics, and the problem asks for a rigorous derivation and application of these principles.\n\nThe solution proceeds in two parts. First, we derive the explicit functional form of $QV(e)$ from the two given properties. Second, we use this function to determine the minimal quality score that satisfies the specified accuracy requirement.\n\nPart 1: Derivation of $QV(e)$\n\nThe problem defines the Phred-like quality value, $QV$, as a function of the consensus error probability per base, $e \\in (0,1)$. The function is defined by two properties.\n\nProperty 1 states that for any two error probabilities $e_1, e_2 \\in (0,1)$, the difference in their quality scores is proportional to the logarithm of their ratio:\n$$QV(e_{2}) - QV(e_{1}) = 10 \\log_{10}\\left(\\frac{e_{1}}{e_{2}}\\right)$$\nUsing the property of logarithms $\\log(a/b) = \\log(a) - \\log(b)$, we can rewrite the expression as:\n$$QV(e_{2}) - QV(e_{1}) = 10 \\left( \\log_{10}(e_{1}) - \\log_{10}(e_{2}) \\right)$$\nRearranging the terms of this equation to group variables of the same index gives:\n$$QV(e_{2}) + 10 \\log_{10}(e_{2}) = QV(e_{1}) + 10 \\log_{10}(e_{1})$$\nThis equation demonstrates that the quantity $QV(e) + 10 \\log_{10}(e)$ has the same value regardless of the specific error probability $e$ chosen. Therefore, this quantity must be a constant, which we will denote by $C$.\n$$QV(e) + 10 \\log_{10}(e) = C$$\nFrom this, we can express $QV(e)$ as:\n$$QV(e) = C - 10 \\log_{10}(e)$$\nTo determine the constant $C$, we use Property 2, which provides an anchor point for the scale. Property 2 states that for the worst possible consensus, where the error probability is $e=1$, the quality score is $QV(1)=0$. Substituting $e=1$ into our expression for $QV(e)$:\n$$QV(1) = C - 10 \\log_{10}(1)$$\nSince $\\log_{10}(1) = 0$, the equation simplifies to:\n$$0 = C - 10(0)$$\n$$C = 0$$\nHaving found that the constant of integration is $0$, we can write the final, explicit expression for the quality score as a function of error probability:\n$$QV(e) = -10 \\log_{10}(e)$$\nThis is the standard definition of the Phred quality score.\n\nPart 2: Determination of the Minimal $QV$ Threshold\n\nThe problem requires determining the minimal $QV$ threshold to ensure fewer than one expected error per megabase. A megabase corresponds to a segment of $N = 10^6$ bases. The problem states that the errors are independently and identically distributed, and the expected number of consensus base errors, denoted $E[\\text{errors}]$, in this segment is given by $N e$.\n\nThe condition is \"fewer than one expected error per megabase\", which translates to the strict inequality:\n$$E[\\text{errors}] < 1$$\nSubstituting the expression for the expected value, we get:\n$$N e < 1$$\nGiven $N = 10^6$, the inequality for the error probability $e$ becomes:\n$$10^6 e < 1$$\n$$e < \\frac{1}{10^6}$$\n$$e < 10^{-6}$$\nThe function $QV(e) = -10 \\log_{10}(e)$ is a monotonically decreasing function of $e$. This means that a smaller value of $e$ corresponds to a larger value of $QV$. Therefore, the inequality for $e$ can be transformed into an inequality for $QV$:\n$$QV(e) > QV(10^{-6})$$\nThe minimal $QV$ threshold is the value of $QV$ at the boundary of this condition, where $e = 10^{-6}$. We calculate this threshold value:\n$$QV_{\\text{threshold}} = -10 \\log_{10}(10^{-6})$$\nUsing the logarithm power rule, $\\log_{b}(x^y) = y \\log_{b}(x)$:\n$$QV_{\\text{threshold}} = -10 \\times (-6) \\log_{10}(10)$$\nSince $\\log_{10}(10) = 1$:\n$$QV_{\\text{threshold}} = -10 \\times (-6) \\times 1 = 60$$\nThus, to achieve an expected error rate of less than one base per million, the Phred-like quality score of the assembly must be greater than $60$. The minimal threshold is therefore $60$.",
            "answer": "$$\\boxed{60}$$"
        },
        {
            "introduction": "Beyond single-base accuracy, a T2T assembly must be structurally correct, with all parts of the genome in the right order and orientation. This practice challenges you to act as a genome detective, using a combination of long-read, paired-end, and High-throughput Chromosome Conformation Capture (Hi-C) data to diagnose common but critical misassemblies. By learning to recognize the tell-tale signatures of inversions and translocations, you develop an essential skill for validating the structural integrity of any genome assembly .",
            "id": "4348197",
            "problem": "A telomere-to-telomere (T2T) haplotype-resolved assembly of a human genome is being evaluated for misassemblies using long-read alignments, paired-end short-read mappings, and High-throughput Chromosome Conformation Capture (Hi-C) contact maps that are phased by single-nucleotide polymorphisms to separate haplotype contacts. Consider one contig from haplotype H$1$ that contains two suspicious adjacencies (junctions) J$A$ and J$B$. The following observations are made:\n\n- Long-read alignments across J$A$ show split reads whose first segment maps to chromosome $1$ on the forward strand and whose second segment maps to a more proximal locus on chromosome $1$ on the reverse strand; the segments are immediately adjacent in the contig but align to reference loci in an order that is reversed with respect to the reference coordinate system. Paired-end short reads spanning J$A$ are enriched for away-facing orientations (for example, $\\mathrm{R}\\mathrm{F}$) and have apparent insert sizes exceeding the library mean by a large margin. The haplotype-resolved Hi-C map for H$1$ exhibits mirror-symmetric off-diagonal stripes centered on the two breakpoints flanking J$A$, superimposed on the expected decay of contact probability $P(s)$ with genomic separation $s$ along chromosome $1$.\n\n- Long-read alignments across J$B$ show split reads whose segments map to adjacent positions in the contig but to nonhomologous chromosomes in the reference, namely one segment to chromosome $1$ and the other to chromosome $8$. The haplotype-resolved Hi-C map for H$1$ shows a discrete interchromosomal contact block linking the chromosome $1$ locus to the chromosome $8$ locus; this block is absent in the haplotype H$2$ map, which shows only background noise between these loci.\n\nAssume the following well-tested facts as the fundamental base: in a correctly assembled linear chromosome, adjacent bases in the assembly correspond to adjacent loci in the true genome, so that long reads map contiguously without splits; paired-end reads have library-specific orientation and insert-size constraints; and in Hi-C data, contact probability $P(s)$ decays with increasing genomic distance $s$ and is enriched for cis contacts within the same chromosome and within the same haplotype phase, while structural rearrangements create characteristic off-diagonal or interchromosomal contact enrichments.\n\nWhich assignment of misassembly types to J$A$ and J$B$ best fits these data?\n\nA. J$A$ is a relocation (intrachromosomal transposition without orientation flip), and J$B$ is an inversion.\n\nB. J$A$ is an inversion (orientation flip within the same chromosome), and J$B$ is a translocation (interchromosomal adjacency).\n\nC. J$A$ is a relocation (intrachromosomal transposition), and J$B$ is a translocation, because symmetric stripes in Hi-C arise from any intrachromosomal adjacency.\n\nD. J$A$ is a translocation and J$B$ is a relocation, because interchromosomal Hi-C blocks can reflect repetitive sequence bleed-through rather than adjacency.\n\nE. Both J$A$ and J$B$ are relocations, because off-diagonal Hi-C enrichments indicate physical proximity irrespective of chromosome identity.",
            "solution": "The problem statement must first be validated for scientific soundness, clarity, and completeness.\n\n**Step 1: Extract Givens**\n\n-   **System**: A telomere-to-telomere (T2T) haplotype-resolved assembly of a human genome.\n-   **Data Types**: Long-read alignments, paired-end short-read mappings, and haplotype-resolved High-throughput Chromosome Conformation Capture (Hi-C) contact maps.\n-   **Contig**: A single contig from haplotype H$1$.\n-   **Junction J$A$ Observations**:\n    1.  **Long-reads**: Split reads across J$A$. First segment maps to chromosome $1$ (forward strand). Second segment maps to a more proximal locus on chromosome $1$ (reverse strand). Segments are adjacent in the contig, but the reference loci order is reversed.\n    2.  **Paired-end reads**: Enriched for away-facing orientations (e.g., $\\mathrm{R}\\mathrm{F}$). Apparent insert sizes are much larger than the library mean.\n    3.  **Hi-C (H$1$)**: Mirror-symmetric off-diagonal stripes centered on breakpoints, superimposed on the typical $P(s)$ vs. $s$ decay on chromosome $1$.\n-   **Junction J$B$ Observations**:\n    1.  **Long-reads**: Split reads across J$B$. Segments are adjacent in the contig but map to nonhomologous chromosomes: one to chromosome $1$, the other to chromosome $8$.\n    2.  **Hi-C (H$1$)**: A discrete interchromosomal contact block linking the chromosome $1$ locus and the chromosome $8$ locus.\n    3.  **Hi-C (H$2$)**: The interchromosomal block is absent; only background noise is observed.\n-   **Fundamental Principles**:\n    1.  Correct assemblies have contiguous long-read mappings.\n    2.  Correct assemblies adhere to paired-end library constraints (orientation, insert size).\n    3.  Hi-C contact probability $P(s)$ decays with genomic distance $s$, is enriched for cis-contacts, and shows characteristic patterns for structural rearrangements.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, well-posed, and objective.\n-   **Scientific Grounding**: The problem uses standard terminology, data types (long-reads, short-reads, Hi-C), and concepts from the field of genome assembly and structural variation analysis. The described data signatures for different types of rearrangements are canonical and factually correct.\n-   **Well-Posedness**: The problem provides a set of specific observations and asks for the best-fitting explanation (misassembly types) from a given set of options. The information is sufficient and self-contained to arrive at a logical conclusion.\n-   **Objectivity**: The problem describes data patterns using precise, technical language (e.g., \"away-facing orientations\", \"interchromosomal contact block\") without subjective or ambiguous phrasing.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is valid. A solution can be derived.\n\n**Derivation of the Solution**\n\nThe nature of the misassemblies at junctions J$A$ and J$B$ can be deduced by interpreting the provided multi-modal genomic data.\n\n**Analysis of Junction J$A$**\n\n1.  **Long-Read Evidence**: The long reads are split. One segment maps to a locus on chromosome $1$ on the forward strand, while the adjacent segment in the contig maps to a different locus on chromosome $1$ but on the *reverse* strand. The fact that the order of the mapped loci in the reference is reversed relative to their order in the contig, combined with the change in strand orientation (forward to reverse), is the classic signature of an **inversion**. The assembler has erroneously joined the sequence flanking one side of an inverted segment to the sequence flanking the other side.\n\n2.  **Paired-End Short-Read Evidence**: Reads spanning an inversion breakpoint will often map in an abnormal orientation. The standard orientation for paired-end reads is inward-facing (`F-R`, or `--> <--`). An inversion boundary causes one of the flanking sequences to be inverted, leading to read pairs mapping in an outward-facing or away-facing orientation (e.g., `R-F` or `<-- -->`). The reported enrichment for `R-F` orientation confirms the presence of an inversion. The large apparent insert size is also expected, as the reads span the junction in the assembled contig but map to what are now distant loci in the linear reference genome coordinate system. This evidence strongly supports an **inversion**.\n\n3.  **Hi-C Evidence**: Hi-C measures 3D proximity. An inversion folds a chromosome segment back on itself, bringing the ends of the inverted region into close spatial proximity. When plotted against the linear reference genome, this creates characteristic off-diagonal interaction signals. The description of \"mirror-symmetric off-diagonal stripes centered on the two breakpoints\" is consistent with the \"bow-tie\" or \"X-shape\" pattern that is a hallmark of a chromosomal **inversion** in a Hi-C map.\n\n*Conclusion for J$A$*: All three sources of evidence—long-reads, paired-end reads, and Hi-C—converge on the conclusion that J$A$ represents an **inversion**.\n\n**Analysis of Junction J$B$**\n\n1.  **Long-Read Evidence**: The split reads at J$B$ have segments mapping to two different chromosomes: chromosome $1$ and chromosome $8$. An adjacency in a contig that corresponds to an adjacency between two different chromosomes in the true genome is the definition of an interchromosomal **translocation**.\n\n2.  **Hi-C Evidence**: In a genome-wide Hi-C contact map, interactions between different chromosomes (interchromosomal) appear in off-diagonal blocks. These are typically sparse, representing a low background of random contacts. A translocation brings a region from one chromosome into permanent physical adjacency with a region of another chromosome. This results in a new, strong, localized enrichment of contacts between the two chromosomes, which appears as a \"discrete interchromosomal contact block\". This is the canonical Hi-C signature for a **translocation**.\n\n3.  **Haplotype-Resolved Evidence**: The fact that this contact block is present in the H$1$ haplotype map but absent in the H$2$ map indicates that the translocation is a real, heterozygous structural variant present on the chromosome copy corresponding to H$1$. This rules out a global assembly or mapping artifact and reinforces the conclusion that J$B$ represents a **translocation**.\n\n*Conclusion for J$B$*: The long-read and haplotype-resolved Hi-C data unequivocally identify J$B$ as a **translocation**.\n\n**Summary**: J$A$ is an inversion. J$B$ is a translocation.\n\n**Evaluation of Options**\n\n-   **A. J$A$ is a relocation (intrachromosomal transposition without orientation flip), and J$B$ is an inversion.**\n    -   This is incorrect. J$A$ is an inversion due to the orientation flip signature. J$B$ is a translocation, not an inversion. **Incorrect**.\n\n-   **B. J$A$ is an inversion (orientation flip within the same chromosome), and J$B$ is a translocation (interchromosomal adjacency).**\n    -   This assignment aligns perfectly with the analysis. J$A$'s characteristics (split reads with orientation flip, `R-F` pairs, symmetric Hi-C stripes) point to an inversion. J$B$'s characteristics (split reads across chromosomes, interchromosomal Hi-C block) point to a translocation. **Correct**.\n\n-   **C. J$A$ is a relocation (intrachromosomal transposition), and J$B$ is a translocation, because symmetric stripes in Hi-C arise from any intrachromosomal adjacency.**\n    -   J$A$ is misidentified; the evidence points to an inversion, not a simple relocation. The reasoning provided is also flawed; the specific pattern of \"mirror-symmetric stripes\" is characteristic of inversions, not all intrachromosomal rearrangements. **Incorrect**.\n\n-   **D. J$A$ is a translocation and J$B$ is a relocation, because interchromosomal Hi-C blocks can reflect repetitive sequence bleed-through rather than adjacency.**\n    -   The entire assignment is incorrect. J$A$ is an intrachromosomal event (inversion). J$B$ is an interchromosomal event (translocation). While the caveat about repetitive sequences is a valid concern in Hi-C analysis, it is contradicted here by the converging evidence from long reads and the haplotype-specific nature of the signal. **Incorrect**.\n\n-   **E. Both J$A$ and J$B$ are relocations, because off-diagonal Hi-C enrichments indicate physical proximity irrespective of chromosome identity.**\n    -   This option uses a vague term (\"relocations\") and misinterprets the data. J$A$ is specifically an inversion. J$B$ is a translocation. The reasoning is overly simplistic, as the *pattern* of Hi-C enrichment, not just its presence, is diagnostic of the rearrangement type. **Incorrect**.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Achieving a true telomere-to-telomere assembly requires definitive proof that the assembled contigs represent complete chromosomes, terminating in proper telomeric caps. This hands-on challenge puts you in the role of a bioinformatics tool developer, tasked with designing an algorithm to automatically validate telomeric ends. You will integrate evidence from sequence motifs, read coverage depth, and mapping orientations to create a robust method for confirming that the 'T2T' promise has been met .",
            "id": "4348159",
            "problem": "You are given the task of designing a computational method to identify and validate telomeric ends in contigs within haplotype-resolved Telomere-to-Telomere (T2T) assemblies for Precision Medicine and Genomic Diagnostics. The method must integrate motif enrichment, coverage signal behavior, and mapping orientation consistency, grounded in foundational biological and statistical principles. Specifically, the following definitions and assumptions serve as the fundamental base:\n\n- Deoxyribonucleic Acid (DNA) is a polymer sequence over the alphabet $\\{\\text{A,C,G,T}\\}$ that encodes hereditary information, consistent with the Central Dogma of Molecular Biology.\n- Telomeric repeats in vertebrates consist of the motif $\\text{TTAGGG}$ and its reverse complement $\\text{CCCTAA}$ appearing tandemly near chromosomal ends.\n- Whole-genome sequencing coverage for a locus can be approximated by sampling from a Poisson process with rate $\\lambda$, implying expected coverage values proportional to $\\lambda$ and per-position variation near $\\lambda$ under stable sampling.\n- Read mapping orientations near true terminal regions of contigs are expected to exhibit directionally consistent alignment relative to contig boundaries (for example, \"outward-facing\" on one end), which can be modeled via a Bernoulli process with the null expectation of balanced orientations of $0.5$ when no directional structure exists.\n\nYour algorithm must compute, for each contig end (left and right), the following three metrics:\n\n1. Motif enrichment score: For a window of size $L$ bases at the end, compute a log-odds enrichment score $S_{\\mathrm{m}}$ comparing the observed frequency of either $\\text{TTAGGG}$ or $\\text{CCCTAA}$ (choose the orientation with the higher enrichment in that window) to the expected probability derived from the contig-wide base composition. The expected probability of a motif is the product of marginal base frequencies across the contig. The observed frequency is the number of motif occurrences divided by the number of possible motif starting positions in the window. You must avoid division-by-zero by applying a negligible smoothing constant where appropriate.\n2. Coverage drop criterion: Compute the ratio $R_{\\mathrm{c}}$ of the mean coverage in the end-window to the mean coverage across the entire contig. A validated end is expected to show $R_{\\mathrm{c}}$ less than a specified threshold in $(0,1)$.\n3. Orientation consistency score: In the end-window, compute the read orientation fraction $\\hat{p}$ of \"outward-facing\" alignments and evaluate a normal-approximation $z$-score $S_{\\mathrm{o}} = \\dfrac{\\hat{p} - 0.5}{\\sqrt{0.25/n}}$, where $n$ is the number of reads sampled near the end. A validated end must satisfy a lower bound on $S_{\\mathrm{o}}$ and have $\\hat{p} > 0.5$.\n\nAn end is validated if and only if all three criteria are simultaneously satisfied:\n- $S_{\\mathrm{m}} \\ge \\tau_{\\mathrm{m}}$\n- $R_{\\mathrm{c}} \\le \\theta_{\\mathrm{c}}$\n- $S_{\\mathrm{o}} \\ge \\tau_{\\mathrm{o}}$ and $\\hat{p} > 0.5$\n\nUse the following constants:\n- Motif log-odds threshold $\\tau_{\\mathrm{m}} = 2.0$\n- Coverage ratio threshold $\\theta_{\\mathrm{c}} = 0.6$\n- Orientation $z$-score threshold $\\tau_{\\mathrm{o}} = 2.0$\n- Smoothing constant $\\epsilon = 10^{-9}$\n\nThe window length $L$ is specified per test case. Treat both ends independently and report the total number of validated ends per contig, which must be an integer in $\\{0,1,2\\}$.\n\nInput to your program is implicit (hard-coded within the program as specified below). Your program must apply the method to the following test suite. Each test case defines a contig sequence, its coverage array, end-window length $L$, and end-specific read orientation lists. All angles are irrelevant and not present; no physical units are required. Express all numerical outputs as integers.\n\nTest Suite:\n- Case $1$ (haplotype $\\text{H1}$):\n  - Contig length $= 400$. Sequence $=$ $\\text{TTAGGG}$ repeated $18$ times followed by $\\text{ACGT}$ repeated $73$ times.\n  - Coverage array: first $120$ positions coverage $= 8$, remaining $280$ positions coverage $= 32$.\n  - Window length $L = 120$.\n  - Left-end orientations: $30$ reads with $25$ outward-facing and $5$ inward-facing.\n  - Right-end orientations: $30$ reads with $16$ outward-facing and $14$ inward-facing.\n- Case $2$ (haplotype $\\text{H2}$):\n  - Contig length $= 500$. Sequence $=$ $\\text{TTAGGG}$ repeated $20$ times, then $\\text{GACT}$ repeated $65$ times, then $\\text{CCCTAA}$ repeated $20$ times.\n  - Coverage array: first $120$ positions coverage $= 10$, middle $260$ positions coverage $= 35$, last $120$ positions coverage $= 10$.\n  - Window length $L = 120$.\n  - Left-end orientations: $40$ reads with $35$ outward-facing and $5$ inward-facing.\n  - Right-end orientations: $40$ reads with $32$ outward-facing and $8$ inward-facing.\n- Case $3$ (control contig without telomeres):\n  - Contig length $= 450$. Sequence $=$ $\\text{GACT}$ repeated $112$ times followed by $\\text{GA}$.\n  - Coverage array: all $450$ positions coverage $= 30$.\n  - Window length $L = 120$.\n  - Left-end orientations: $40$ reads with $20$ outward-facing and $20$ inward-facing.\n  - Right-end orientations: $40$ reads with $22$ outward-facing and $18$ inward-facing.\n- Case $4$ (motif present but insufficient coverage drop):\n  - Contig length $= 420$. Sequence $=$ $\\text{TTAGGG}$ repeated $15$ times followed by $\\text{ATGC}$ repeated $82$ times followed by $\\text{AT}$.\n  - Coverage array: first $120$ positions coverage $= 26$, remaining $300$ positions coverage $= 31$.\n  - Window length $L = 120$.\n  - Left-end orientations: $30$ reads with $26$ outward-facing and $4$ inward-facing.\n  - Right-end orientations: $30$ reads with $15$ outward-facing and $15$ inward-facing.\n- Case $5$ (boundary case with large window):\n  - Contig length $= 200$. Sequence $=$ $\\text{ATGC}$ repeated $50$ times.\n  - Coverage array: first $150$ positions coverage $= 25$, last $50$ positions coverage $= 30$.\n  - Window length $L = 150$.\n  - Left-end orientations: $20$ reads with $11$ outward-facing and $9$ inward-facing.\n  - Right-end orientations: $20$ reads with $9$ outward-facing and $11$ inward-facing.\n\nOutput specification:\n- For each test case, compute the integer number of validated telomeric ends among the two contig ends.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the five cases in order (e.g., $[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4,\\text{r}_5]$). The entries must be integers.\n\nYour algorithm must be implemented in a single, complete, runnable Python program. No user interaction or external files are permitted. The program must compute all quantities exactly as specified and output the final results in the required format.",
            "solution": "The problem requires the design and implementation of a computational method to validate telomeric ends in contigs from haplotype-resolved, telomere-to-telomere (T2T) assemblies. The validation must be based on a synthesis of three distinct lines of evidence: telomeric motif enrichment, sequencing coverage patterns, and read mapping orientation bias. The problem statement is scientifically grounded, well-posed, and objective, referencing established principles in molecular biology and biostatistics. It is therefore deemed valid and a solution can be formulated.\n\nThe core principle of the algorithm is to quantify evidence for each of the three biological signatures of a telomere and to declare a contig end as a validated telomere only if all three signatures are present a-priori defined statistical thresholds. We will analyze the left and right ends of each contig independently. For each end, a window of size $L$ is defined, which constitutes the region of analysis.\n\nLet us dissect the algorithm by its three primary components.\n\n**1. Motif Enrichment Score ($S_{\\mathrm{m}}$)**\n\nThis metric quantifies the over-representation of the canonical vertebrate telomeric repeat.\n\n*   **Principle**: True telomeres are composed of long tandem arrays of a specific DNA motif. In vertebrates, this is the $6$-base-pair motif $\\text{TTAGGG}$ on one strand and its reverse complement, $\\text{CCCTAA}$, on the other. A genomic region that is a true telomere should exhibit a significantly higher frequency of these motifs than would be expected by random chance based on the overall nucleotide composition of the contig.\n*   **Formulation**: We compute a log-odds enrichment score, $S_{\\mathrm{m}}$. First, we determine the expected probability, $P_{\\text{exp}}$, of a specific $6$-mer motif occurring at any given position. Under a simple nucleotide independence model, this is the product of the marginal frequencies of its constituent bases across the entire contig. Let $f(B)$ be the frequency of base $B \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ in the contig.\n    $$P_{\\text{exp, TTAGGG}} = f(\\text{T}) \\cdot f(\\text{T}) \\cdot f(\\text{A}) \\cdot f(\\text{G}) \\cdot f(\\text{G}) \\cdot f(\\text{G})$$\n    $$P_{\\text{exp, CCCTAA}} = f(\\text{C}) \\cdot f(\\text{C}) \\cdot f(\\text{C}) \\cdot f(\\text{T}) \\cdot f(\\text{A}) \\cdot f(\\text{A})$$\n    Next, we calculate the observed frequency, $P_{\\text{obs}}$, of the motif within the analysis window of length $L$. This is the number of times the motif is found, $N_{\\text{obs}}$, divided by the number of possible starting positions for a $6$-mer, which is $L - 6 + 1$.\n    $$P_{\\text{obs}} = \\frac{N_{\\text{obs}}}{L-5}$$\n    The enrichment score for a given motif is the natural logarithm of the ratio of observed to expected probability. A smoothing constant $\\epsilon = 10^{-9}$ is added to the denominator to prevent division by zero in the unlikely event of a non-existent base in the contig leading to $P_{\\text{exp}} = 0$.\n    $$S_{\\mathrm{m}} = \\ln\\left(\\frac{P_{\\text{obs}}}{P_{\\text{exp}} + \\epsilon}\\right)$$\n    Since either DNA strand could be represented in the contig sequence, we calculate $S_{\\mathrm{m}}$ for both $\\text{TTAGGG}$ and $\\text{CCCTAA}$ and take the maximum of the two as the score for the window. The end is considered to have significant motif enrichment if $S_{\\mathrm{m}} \\ge \\tau_{\\mathrm{m}}$, where the threshold is given as $\\tau_{\\mathrm{m}} = 2.0$. If $P_{\\text{obs}}=0$, the score is $\\ln(0) = -\\infty$, which will correctly fail the validation check.\n\n**2. Coverage Drop Criterion ($R_{\\mathrm{c}}$)**\n\nThis metric identifies the characteristic drop in sequencing coverage at the very end of a chromosome.\n\n*   **Principle**: In whole-genome shotgun sequencing, reads are generated from random fragments of the genome. For a region to be sequenced, it must be flanked by genomic DNA on both sides to be captured in a fragment. The very ends of linear chromosomes are exceptions; they are only flanked on one side. This results in a progressive decline in sequencing coverage, which should approach approximately half the genome-wide average coverage right at the terminus. The problem models this as a discrete drop for simplicity.\n*   **Formulation**: We compute the ratio $R_{\\mathrm{c}}$ of the mean sequencing coverage within the end-window, $\\bar{c}_{\\text{win}}$, to the mean coverage across the entire contig, $\\bar{c}_{\\text{ctg}}$.\n    $$R_{\\mathrm{c}} = \\frac{\\bar{c}_{\\text{win}}}{\\bar{c}_{\\text{ctg}}}$$\n    A true telomeric end is expected to have substantially lower coverage. The criterion for validation is $R_{\\mathrm{c}} \\le \\theta_{\\mathrm{c}}$, with the threshold given as $\\theta_{\\mathrm{c}} = 0.6$.\n\n**3. Orientation Consistency Score ($S_{\\mathrm{o}}$)**\n\nThis metric assesses the directional bias of read pairs mapping near a contig end.\n\n*   **Principle**: Paired-end sequencing reads have a known orientation (e.g., forward-reverse) and are separated by a certain insert size. At a true chromosomal end, all read pairs that span the junction between the chromosome and the sequencing vector (or simply the physical end of the DNA) will have one read mapping to the chromosome and its mate either unmapped or mapped to an adapter sequence. This creates a strong directional bias where all valid alignments point \"inward\" from the end of the molecule. The problem abstracts this as \"outward-facing\" relative to the contig boundary, which serves the same purpose of identifying a directional signal. Under a null hypothesis of a non-terminal region, read orientations should be approximately balanced ($50\\%$ in each direction). We can test for a significant deviation from this $50\\%$ null expectation.\n*   **Formulation**: The orientation of reads is modeled as a Bernoulli process. For a sample of $n$ reads near the contig end, let $k$ be the count of \"outward-facing\" reads. The proportion is $\\hat{p} = k/n$. We test the null hypothesis $H_0: p = 0.5$ against the alternative $H_1: p > 0.5$. We use a normal-approximation $z$-score for this one-tailed test:\n    $$S_{\\mathrm{o}} = \\frac{\\hat{p} - p_0}{\\sqrt{p_0(1-p_0)/n}} = \\frac{\\hat{p} - 0.5}{\\sqrt{0.25/n}}$$\n    A high positive score indicates a significant bias towards the \"outward-facing\" orientation, consistent with a true terminus. The validation criterion is two-fold: the statistical significance must exceed a threshold, $S_{\\mathrm{o}} \\ge \\tau_{\\mathrm{o}}$ (with $\\tau_{\\mathrm{o}} = 2.0$), and the direction of the bias must be correct, $\\hat{p} > 0.5$.\n\n**Integrated Validation Algorithm**\n\nThe final step is to combine these three metrics into a single validation decision for each end of a contig.\n\nFor a given contig and its associated data:\n1.  Calculate contig-wide base frequencies and mean coverage.\n2.  For the left end (window from index $0$ to $L-1$):\n    a. Calculate $S_{\\mathrm{m, left}}$.\n    b. Calculate $R_{\\mathrm{c, left}}$.\n    c. Calculate $S_{\\mathrm{o, left}}$ and $\\hat{p}_{\\text{left}}$.\n    d. The left end is validated if and only if ($S_{\\mathrm{m, left}} \\ge \\tau_{\\mathrm{m}}$) AND ($R_{\\mathrm{c, left}} \\le \\theta_{\\mathrm{c}}$) AND ($S_{\\mathrm{o, left}} \\ge \\tau_{\\mathrm{o}}$ AND $\\hat{p}_{\\text{left}} > 0.5$).\n3.  For the right end (window from index $-L$ to end):\n    a. Calculate $S_{\\mathrm{m, right}}$.\n    b. Calculate $R_{\\mathrm{c, right}}$.\n    c. Calculate $S_{\\mathrm{o, right}}$ and $\\hat{p}_{\\text{right}}$.\n    d. The right end is validated if and only if ($S_{\\mathrm{m, right}} \\ge \\tau_{\\mathrm{m}}$) AND ($R_{\\mathrm{c, right}} \\le \\theta_{\\mathrm{c}}$) AND ($S_{\\mathrm{o, right}} \\ge \\tau_{\\mathrm{o}}$ AND $\\hat{p}_{\\text{right}} > 0.5$).\n4.  The total number of validated ends for the contig is the sum of the validation results (1 for validated, 0 for not) for the left and right ends.\n\nThis procedure is applied to each test case to generate the final results.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the telomere validation algorithm on all test cases.\n    \"\"\"\n    \n    # --- Constants and Thresholds ---\n    TAU_M = 2.0  # Motif log-odds threshold\n    THETA_C = 0.6  # Coverage ratio threshold\n    TAU_O = 2.0  # Orientation z-score threshold\n    EPSILON = 1e-9  # Smoothing constant\n    MOTIF_LEN = 6\n    MOTIF_FWD = \"TTAGGG\"\n    MOTIF_REV = \"CCCTAA\"\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Case 1 (haplotype H1)\n        {\n            \"seq\": \"TTAGGG\" * 18 + \"ACGT\" * 73,\n            \"cov\": np.concatenate([np.full(120, 8), np.full(280, 32)]),\n            \"L\": 120,\n            \"left_orient\": (30, 25),  # (total_reads, outward_reads)\n            \"right_orient\": (30, 16),\n        },\n        # Case 2 (haplotype H2)\n        {\n            \"seq\": \"TTAGGG\" * 20 + \"GACT\" * 65 + \"CCCTAA\" * 20,\n            \"cov\": np.concatenate([np.full(120, 10), np.full(260, 35), np.full(120, 10)]),\n            \"L\": 120,\n            \"left_orient\": (40, 35),\n            \"right_orient\": (40, 32),\n        },\n        # Case 3 (control contig)\n        {\n            \"seq\": \"GACT\" * 112 + \"GA\",\n            \"cov\": np.full(450, 30),\n            \"L\": 120,\n            \"left_orient\": (40, 20),\n            \"right_orient\": (40, 22),\n        },\n        # Case 4 (motif present but insufficient coverage drop)\n        {\n            \"seq\": \"TTAGGG\" * 15 + \"ATGC\" * 82 + \"AT\",\n            \"cov\": np.concatenate([np.full(120, 26), np.full(300, 31)]),\n            \"L\": 120,\n            \"left_orient\": (30, 26),\n            \"right_orient\": (30, 15),\n        },\n        # Case 5 (boundary case with large window)\n        {\n            \"seq\": \"ATGC\" * 50,\n            \"cov\": np.concatenate([np.full(150, 25), np.full(50, 30)]),\n            \"L\": 150,\n            \"left_orient\": (20, 11),\n            \"right_orient\": (20, 9),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(analyze_contig(case, TAU_M, THETA_C, TAU_O, EPSILON, MOTIF_FWD, MOTIF_REV, MOTIF_LEN))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef validate_end(window_seq, window_cov, mean_contig_cov, p_exps, orient_data, L, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n    \"\"\"\n    Applies the three validation criteria to a single contig end.\n    \n    Returns:\n        bool: True if the end is validated, False otherwise.\n    \"\"\"\n    \n    # 1. Motif Enrichment Score (S_m)\n    num_possible_starts = L - motif_len + 1\n    if num_possible_starts = 0:\n        s_m = -np.inf\n    else:\n        count_fwd = window_seq.count(motif_fwd)\n        count_rev = window_seq.count(motif_rev)\n        \n        p_obs_fwd = count_fwd / num_possible_starts\n        p_obs_rev = count_rev / num_possible_starts\n        \n        p_exp_fwd, p_exp_rev = p_exps\n        \n        s_m_fwd = np.log(p_obs_fwd / (p_exp_fwd + epsilon)) if p_obs_fwd > 0 else -np.inf\n        s_m_rev = np.log(p_obs_rev / (p_exp_rev + epsilon)) if p_obs_rev > 0 else -np.inf\n        \n        s_m = max(s_m_fwd, s_m_rev)\n\n    metric1_ok = s_m >= tau_m\n\n    # 2. Coverage Drop Criterion (R_c)\n    mean_window_cov = np.mean(window_cov)\n    if mean_contig_cov == 0: # Avoid division by zero\n        r_c = np.inf\n    else:\n        r_c = mean_window_cov / mean_contig_cov\n    \n    metric2_ok = r_c = theta_c\n\n    # 3. Orientation Consistency Score (S_o)\n    n, outward_count = orient_data\n    if n == 0:\n        p_hat = 0.5\n        s_o = 0.0\n    else:\n        p_hat = outward_count / n\n        s_o = (p_hat - 0.5) / np.sqrt(0.25 / n)\n        \n    metric3_ok = (s_o >= tau_o) and (p_hat > 0.5)\n    \n    return metric1_ok and metric2_ok and metric3_ok\n\n\ndef analyze_contig(case, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n    \"\"\"\n    Analyzes a single contig and returns the number of validated telomeric ends.\n    \"\"\"\n    seq = case[\"seq\"]\n    cov = case[\"cov\"]\n    L = case[\"L\"]\n    contig_len = len(seq)\n    \n    # --- Contig-wide metrics ---\n    base_counts = {base: seq.count(base) for base in 'ACGT'}\n    base_freqs = {base: count / contig_len for base, count in base_counts.items()}\n    \n    p_exp_fwd = (base_freqs.get('T', 0)**2 * base_freqs.get('A', 0) * base_freqs.get('G', 0)**3)\n    p_exp_rev = (base_freqs.get('C', 0)**3 * base_freqs.get('T', 0) * base_freqs.get('A', 0)**2)\n    p_exps = (p_exp_fwd, p_exp_rev)\n    \n    mean_contig_cov = np.mean(cov)\n\n    # --- End-specific validation ---\n    validated_ends = 0\n    \n    # Left end\n    left_window_seq = seq[:L]\n    left_window_cov = cov[:L]\n    if validate_end(left_window_seq, left_window_cov, mean_contig_cov, p_exps, case[\"left_orient\"], L, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n        validated_ends += 1\n        \n    # Right end\n    right_window_seq = seq[-L:]\n    right_window_cov = cov[-L:]\n    if validate_end(right_window_seq, right_window_cov, mean_contig_cov, p_exps, case[\"right_orient\"], L, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n        validated_ends += 1\n        \n    return validated_ends\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}