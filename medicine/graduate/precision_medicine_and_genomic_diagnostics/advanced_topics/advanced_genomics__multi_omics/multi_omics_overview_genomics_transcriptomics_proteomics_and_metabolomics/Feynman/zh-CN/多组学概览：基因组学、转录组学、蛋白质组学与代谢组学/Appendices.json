{
    "hands_on_practices": [
        {
            "introduction": "基因组学的一项核心任务是区分真实的基因变异与测序错误。本练习应用了对数似然比检验这一基本统计方法，来评估亚克隆变异的证据强度。通过这个实践，您将学习如何构建一个包含肿瘤纯度、测序错误率等关键生物学因素的变异检测定量模型 。",
            "id": "4362814",
            "problem": "在精准肿瘤学背景下，一个多组学工作流程整合了来自基因组学、转录组学、蛋白质组学和代谢组学的信息，以优化变异检测和解读。考虑一个通过高深度靶向DNA测序进行分析的肿瘤样本中的二倍体位点。给定以下信息：\n- 该位点的DNA读数计数：参考等位基因读数 $r$ 和备择等位基因读数 $a$。\n- 根据经验估计的每碱基测序错误率 $\\epsilon$，该错误率来源于使用对照DNA进行的质量控制，并由对易错背景进行的正交液相色谱-质谱（LC–MS）蛋白质组学校准所证实。\n- 通过整合蛋白质基因组学反卷积方法估计的肿瘤纯度 $\\pi$，该方法结合了RNA测序（RNA-seq）的细胞类型反卷积与蛋白质丰度特征。\n- 携带该变异的亚克隆癌细胞比例 $c$，该比例通过单细胞RNA测序和考虑拷贝数的克隆重建推断得出。\n\n假设以下模型原则为基本基础：\n- 分子生物学中心法则：脱氧核糖核酸（DNA）编码核糖核酸（RNA），RNA编码蛋白质。编码DNA变异的存在是相应蛋白质改变的必要（但非充分）条件。\n- 测序读数的生成被建模为以真实等位基因频率为条件的独立伯努利试验。\n- 在基因型为 $G=\\text{参考}$ 的情况下，任何观察到的备择读数都源于测序错误，每个读数发生错误的概率为 $\\epsilon$。\n- 在基因型为 $G=\\text{变异}$ 的情况下，该变异是杂合的，且仅存在于一个亚克隆中，该亚克隆在肿瘤纯度为 $\\pi$ 的混合物中占肿瘤细胞的比例为 $c$，总拷贝数为二倍体且无等位基因偏向。因此，在该模型下，预期的备择等位基因频率为 $f=\\frac{1}{2}\\pi c$。\n\n给定观察到的计数 $r=178$ 和 $a=22$（因此总读数数量为 $n=r+a$），$\\epsilon=1.5\\times 10^{-3}$，$\\pi=0.64$ 和 $c=0.35$，计算自然对数似然比\n$$\n\\ln\\left(\\frac{P(D\\mid G=\\text{variant})}{P(D\\mid G=\\text{reference})}\\right)\n$$\n其中 $D$ 表示观察到的读数，在每个假设下使用二项似然来计算 $P(D\\mid G)$，正如上述假设所暗示的。\n\n将你的最终分数以纯数字形式报告（无单位），并四舍五入到四位有效数字。此外，在你的推理过程中，解释在先验概率相等的情况下，这个分数如何根据变异模型的证据强度进行校准，但不要将此解释包含在最终的数值答案中。",
            "solution": "在尝试求解之前，对问题陈述进行了严格验证。\n\n### 步骤1：提取给定信息\n问题陈述中提供的数据、变量和假设如下：\n- DNA读数计数：参考等位基因读数 $r=178$，备择等位基因读数 $a=22$。\n- 总读数数量：$n = r + a$。\n- 每碱基测序错误率：$\\epsilon = 1.5 \\times 10^{-3}$。\n- 肿瘤纯度：$\\pi = 0.64$。\n- 携带变异的亚克隆癌细胞比例：$c = 0.35$。\n- 测序读数模型：独立的伯努利试验，导致计数的二项分布。\n- 假设 $G=\\text{参考}$：观察到备择读数的概率是测序错误率 $\\epsilon$。\n- 假设 $G=\\text{变异}$：该变异是杂合的，存在于一个亚克隆中，该亚克隆占纯度为 $\\pi$ 的肿瘤细胞群体的比例为 $c$。预期的备择等位基因频率被明确定义为 $f = \\frac{1}{2}\\pi c$。\n- 任务：计算自然对数似然比 $\\ln\\frac{P(D\\mid G=\\text{variant})}{P(D\\mid G=\\text{reference})}$，其中 $D$ 代表观察到的读数计数 $(r, a)$。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估：\n- **科学基础**：该问题设置在精准肿瘤学和多组学的背景下，使用了肿瘤纯度、克隆性、测序错误和等位基因频率等标准概念。所用模型（读数计数的二项似然）和统计方法（似然比检验）是计算生物学和生物信息学的基础。该场景是现实且科学合理的。\n- **问题定义明确**：该问题提供了所有必要的数据，并清晰地定义了两种假设的模型。目标是计算一个特定的、明确定义的量。存在一个唯一的、稳定的、有意义的解。\n- **客观性**：该问题使用精确的定量语言陈述。模型和参数都已明确定义，没有主观解释的余地。\n- **完整性**：该问题是自包含的。计算所需的所有值（$r, a, \\epsilon, \\pi, c$）和模型定义都已提供。\n- **一致性**：给定的信息和假设在内部是一致的。公式 $f=\\frac{1}{2}\\pi c$ 是一个标准的、正确的模型，用于描述混合样本中亚克隆群体内的杂合二倍体变异，前提是假设没有拷贝数变异。\n\n### 步骤3：结论与行动\n该问题被认为是有效的，因为它具有科学基础、定义明确、客观且自包含。因此，将提供一个完整的解答。\n\n### 解答\n目标是根据观察到的DNA测序数据，计算关于特定基因组位点基因型的两个竞争假设的自然对数似然比。数据包括 $a=22$ 个备择等位基因读数和 $r=178$ 个参考等位基因读数，总计 $n = a+r = 22+178 = 200$ 个读数。\n\n在 $n$ 个总读数中观察到 $a$ 个备择读数的现象，可以用二项分布来建模。在 $n$ 次试验中，成功概率为 $p$，观察到 $a$ 次成功的概率质量函数是：\n$$\nP(a \\mid n, p) = \\binom{n}{a} p^a (1-p)^{n-a}\n$$\n在这里，“成功”指的是观察到一个备择等位基因读数。数据 $D$ 对应于观察到的计数 $(a, r)$。\n\n**假设1：$G=\\text{参考}$（零假设）**\n在此假设下，真实的基因型是纯合参考型。任何观察到的备择读数都是测序错误的结果。问题陈述指出，观察到备择读数的概率是错误率 $\\epsilon$。\n设 $p_0$ 为参考模型下出现备择读数的概率。\n$$\np_0 = \\epsilon = 1.5 \\times 10^{-3}\n$$\n在参考假设下，数据的似然为：\n$$\nP(D \\mid G=\\text{reference}) = \\binom{n}{a} p_0^a (1-p_0)^{n-a} = \\binom{200}{22} \\epsilon^{22} (1-\\epsilon)^{178}\n$$\n\n**假设2：$G=\\text{变异}$（备择假设）**\n在此假设下，一个杂合变异存在于一部分肿瘤细胞中，这部分细胞占总样本中肿瘤细胞的比例为 $c$，而肿瘤细胞本身在总样本中的比例为 $\\pi$。对于一个没有拷贝数变化或等位基因偏向的二倍体位点，两个等位基因中有一个是变异型。问题将整个DNA样本中预期的备择等位基因频率 $f$ 定义为：\n$$\nf = \\frac{1}{2} \\pi c\n$$\n这个值 $f$ 代表从测序池中抽到一个带有备择等位基因的DNA分子的概率。问题暗示我们应该直接将此值用作变异假设下二项模型的概率参数。\n设 $p_1$ 为变异模型下出现备择读数的概率。\n$$\np_1 = f = \\frac{1}{2} \\pi c\n$$\n代入给定的 $\\pi$ 和 $c$ 值：\n$$\np_1 = \\frac{1}{2} (0.64) (0.35) = 0.32 \\times 0.35 = 0.112\n$$\n在变异假设下，数据的似然为：\n$$\nP(D \\mid G=\\text{variant}) = \\binom{n}{a} p_1^a (1-p_1)^{n-a} = \\binom{200}{22} f^{22} (1-f)^{178}\n$$\n\n**似然比计算**\n似然比是两种假设下似然函数的比值：\n$$\n\\frac{P(D \\mid G=\\text{variant})}{P(D \\mid G=\\text{reference})} = \\frac{\\binom{200}{22} f^{22} (1-f)^{178}}{\\binom{200}{22} \\epsilon^{22} (1-\\epsilon)^{178}}\n$$\n二项式系数 $\\binom{200}{22}$ 被消掉：\n$$\n\\frac{P(D \\mid G=\\text{variant})}{P(D \\mid G=\\text{reference})} = \\frac{f^{22} (1-f)^{178}}{\\epsilon^{22} (1-\\epsilon)^{178}} = \\left(\\frac{f}{\\epsilon}\\right)^{22} \\left(\\frac{1-f}{1-\\epsilon}\\right)^{178}\n$$\n问题要求计算自然对数似然比，我们将其表示为 $\\mathcal{L}$：\n$$\n\\mathcal{L} = \\ln\\left( \\frac{P(D \\mid G=\\text{variant})}{P(D \\mid G=\\text{reference})} \\right) = \\ln\\left[ \\left(\\frac{f}{\\epsilon}\\right)^{a} \\left(\\frac{1-f}{1-\\epsilon}\\right)^{n-a} \\right]\n$$\n利用对数的性质，上式变为：\n$$\n\\mathcal{L} = a \\ln\\left(\\frac{f}{\\epsilon}\\right) + (n-a) \\ln\\left(\\frac{1-f}{1-\\epsilon}\\right)\n$$\n$$\n\\mathcal{L} = a (\\ln(f) - \\ln(\\epsilon)) + (n-a) (\\ln(1-f) - \\ln(1-\\epsilon))\n$$\n现在，我们代入数值：\n- $a = 22$\n- $n-a = r = 178$\n- $f = 0.112$\n- $\\epsilon = 0.0015$\n\n各项为：\n- $1-f = 1 - 0.112 = 0.888$\n- $1-\\epsilon = 1 - 0.0015 = 0.9985$\n\n将这些值代入 $\\mathcal{L}$ 的表达式中：\n$$\n\\mathcal{L} = 22 \\ln\\left(\\frac{0.112}{0.0015}\\right) + 178 \\ln\\left(\\frac{0.888}{0.9985}\\right)\n$$\n我们先计算比率的值：\n$$\n\\frac{0.112}{0.0015} \\approx 74.6666...\n$$\n$$\n\\frac{0.888}{0.9985} \\approx 0.889334...\n$$\n现在，计算自然对数：\n$$\n\\ln(74.6666...) \\approx 4.3129517\n$$\n$$\n\\ln(0.889334...) \\approx -0.1172803\n$$\n最后，计算 $\\mathcal{L}$：\n$$\n\\mathcal{L} \\approx 22 \\times (4.3129517) + 178 \\times (-0.1172803)\n$$\n$$\n\\mathcal{L} \\approx 94.8849374 - 20.8759040\n$$\n$$\n\\mathcal{L} \\approx 74.0090334\n$$\n将结果四舍五入到四位有效数字，得到 $74.01$。\n\n**证据强度的解读**\n计算出的值 $\\mathcal{L} = 74.01$ 是似然比的自然对数。假设模型没有需要积分掉的自由参数，这个量也被称为对数贝叶斯因子。在两种假设的先验概率相等（$P(G=\\text{variant}) = P(G=\\text{reference})$）的情况下，后验优势比等于似然比（或贝叶斯因子）。\n$$\n\\frac{P(G=\\text{variant} \\mid D)}{P(G=\\text{reference} \\mid D)} = \\frac{P(D \\mid G=\\text{variant})}{P(D \\mid G=\\text{reference})} \\times \\frac{P(G=\\text{variant})}{P(G=\\text{reference})} = \\exp(\\mathcal{L}) \\times 1\n$$\n支持变异模型的后验优势比是 $\\exp(74.01)$，这是一个天文数字（约 $1.16 \\times 10^{32}$）。这表明，在变异模型下观察到这些数据的可能性，要远远大于在参考（仅错误）模型下的可能性。用于解释贝叶斯因子的既定标准，例如Kass-Raftery量表，将大于5的对数贝叶斯因子归类为“非常强”的证据。一个74.01的值提供了极其有力的证据，支持存在一个真实的亚克隆变异的假设，而不是认为这些读数仅仅是由测序假象引起的。",
            "answer": "$$\\boxed{74.01}$$"
        },
        {
            "introduction": "在组学研究中，分子鉴定之后的下一步通常是定量。在蛋白质组学中，一种常见的方法是谱图计数。本练习探讨了归一化谱图丰度因子（NSAF）的概念，该方法通过蛋白质长度对谱图计数进行归一化，以估算相对丰度。通过推导和应用NSAF公式，您将深入理解无标记蛋白质定量的原理及其固有的假设和偏差 。",
            "id": "4362816",
            "problem": "在一次使用液相色谱-串联质谱（LC-MS/MS）和数据依赖性采集（DDA）的无标记鸟枪法蛋白质组学实验中，为某个蛋白质分配的肽段串联质谱数量，即其谱图计数（spectral count），通常被用作蛋白质丰度的替代指标。根据分子生物学的中心法则以及串联质谱的采样特性，我们假设以下基本模型：蛋白质 $i$ 的期望谱图计数（表示为 $SpC_i$）与其摩尔丰度 $A_i$ 和其氨基酸长度 $L_i$ 的乘积成正比，因为较长的蛋白质会产生更多可以被采样的、不同的胰蛋白酶切肽段。也就是说，存在一个比例常数 $k$，使得对于给定样品和运行中的所有蛋白质 $i$，$SpC_i \\approx k\\,A_i\\,L_i$。为了估计相对丰度，你决定对于一个感兴趣的蛋白质 $i$，计算其长度归一化谱图计数相对于该次运行中所有检测到的蛋白质的长度归一化谱图计数总和的分数。这个分数通常被称为归一化谱图丰度因子（NSAF），但你应该从给定的假设出发推导该表达式，而不是引用任何预先记忆的公式。\n\n给定一次肿瘤活检运行，其中包含以下蛋白质、其长度 $L_i$（单位为氨基酸）和谱图计数 $SpC_i$：\n- 蛋白质1：$L_1 = 450$， $SpC_1 = 120$。\n- 蛋白质2：$L_2 = 1100$， $SpC_2 = 150$。\n- 蛋白质3：$L_3 = 300$， $SpC_3 = 80$。\n- 蛋白质4：$L_4 = 800$， $SpC_4 = 60$。\n- 蛋白质5：$L_5 = 1600$， $SpC_5 = 200$。\n\n任务：\n1. 仅从假设 $SpC_i \\approx k\\,A_i\\,L_i$ 出发，推导一个闭式表达式，用于表示特定蛋白质 $i$ 的上述分数。该表达式应以所有蛋白质 $j$ 的可观测量 $SpC_j$ 和 $L_j$ 来表示。\n2. 使用你推导的表达式，计算蛋白质2的这个分数。将最终结果表示为小数，并四舍五入到四位有效数字。\n3. 简要讨论（不超过三句话）与蛋白质组学中基于一级质谱（MS1）前体离子强度的定量方法相比，影响这种长度归一化谱图计数方法的两种机制性偏差来源，并将每种偏差与其潜在的物理或生化原因联系起来。\n\n只需报告任务2中要求的数值作为最终答案。该量是无量纲的；请将其表示为四舍五入到四位有效数字的小数。",
            "solution": "问题陈述已通过验证，被认为是有效的。它在蛋白质组学原理上具有科学依据，问题提出得当且客观。它包含了进行求解所需的所有必要数据和定义。\n\n### 任务1：表达式推导\n\n问题要求一个关于“其长度归一化谱图计数相对于所有检测到的蛋白质的长度归一化谱图计数总和的分数”的表达式。让我们将这个陈述形式化。\n\n设实验中检测到的所有 $N$ 个蛋白质的集合由 $j=1, 2, \\dots, N$ 索引。对于该集合中的任何给定蛋白质 $i$，我们已知其谱图计数 $SpC_i$ 和其氨基酸长度 $L_i$。\n\n蛋白质 $i$ 的“长度归一化谱图计数”定义为其谱图计数与其长度之比。我们用 $q_i$ 表示这个量：\n$$q_i = \\frac{SpC_i}{L_i}$$\n\n“所有检测到的蛋白质的长度归一化谱图计数总和”是 $q_j$ 对所有蛋白质 $j=1, \\dots, N$ 的总和：\n$$\\sum_{j=1}^{N} q_j = \\sum_{j=1}^{N} \\frac{SpC_j}{L_j}$$\n\n蛋白质 $i$ 所求的分数，我们称之为归一化谱图丰度因子（$NSAF_i$），是其长度归一化谱图计数与此总和的比值：\n$$NSAF_i = \\frac{q_i}{\\sum_{j=1}^{N} q_j} = \\frac{\\frac{SpC_i}{L_i}}{\\sum_{j=1}^{N} \\frac{SpC_j}{L_j}}$$\n这是直接从问题定义中推导出的闭式表达式。\n\n将此与提供的基本模型 $SpC_i \\approx k\\,A_i\\,L_i$ 联系起来是很有启发性的。通过重新整理这个近似式，我们可以用可观测量来表示摩尔丰度 $A_i$：\n$$A_i \\approx \\frac{1}{k} \\frac{SpC_i}{L_i} = \\frac{1}{k} q_i$$\n所有蛋白质的总摩尔丰度为 $\\sum_{j=1}^{N} A_j \\approx \\sum_{j=1}^{N} \\frac{1}{k} q_j = \\frac{1}{k} \\sum_{j=1}^{N} q_j$。\n蛋白质 $i$ 的相对摩尔丰度是其丰度占总丰度的分数：\n$$\\frac{A_i}{\\sum_{j=1}^{N} A_j} \\approx \\frac{\\frac{1}{k} q_i}{\\frac{1}{k} \\sum_{j=1}^{N} q_j} = \\frac{q_i}{\\sum_{j=1}^{N} q_j} = NSAF_i$$\n因此，推导出的表达式代表了对蛋白质 $i$ 相对摩尔丰度的估计。\n\n### 任务2：计算蛋白质2\n\n我们被要求为 $N=5$ 个蛋白质的数据集计算 $NSAF_2$。表达式为：\n$$NSAF_2 = \\frac{\\frac{SpC_2}{L_2}}{\\sum_{j=1}^{5} \\frac{SpC_j}{L_j}}$$\n首先，我们为5个蛋白质中的每一个计算长度归一化谱图计数 $q_j = \\frac{SpC_j}{L_j}$：\n$q_1 = \\frac{SpC_1}{L_1} = \\frac{120}{450} = \\frac{12}{45} = \\frac{4}{15}$\n$q_2 = \\frac{SpC_2}{L_2} = \\frac{150}{1100} = \\frac{15}{110} = \\frac{3}{22}$\n$q_3 = \\frac{SpC_3}{L_3} = \\frac{80}{300} = \\frac{8}{30} = \\frac{4}{15}$\n$q_4 = \\frac{SpC_4}{L_4} = \\frac{60}{800} = \\frac{6}{80} = \\frac{3}{40}$\n$q_5 = \\frac{SpC_5}{L_5} = \\frac{200}{1600} = \\frac{2}{16} = \\frac{1}{8}$\n\n接下来，我们计算分母中这些值的总和：\n$$\\sum_{j=1}^{5} q_j = q_1 + q_2 + q_3 + q_4 + q_5 = \\frac{4}{15} + \\frac{3}{22} + \\frac{4}{15} + \\frac{3}{40} + \\frac{1}{8}$$\n为了对这些分数求和，我们找到 $15$、$22$、$40$ 和 $8$ 的一个公分母。质因数分解为 $15 = 3 \\times 5$，$22 = 2 \\times 11$，$40 = 2^3 \\times 5$，$8 = 2^3$。最小公倍数是 $2^3 \\times 3 \\times 5 \\times 11 = 8 \\times 3 \\times 5 \\times 11 = 1320$。\n$$\\sum_{j=1}^{5} q_j = \\frac{4 \\times 88}{1320} + \\frac{3 \\times 60}{1320} + \\frac{4 \\times 88}{1320} + \\frac{3 \\times 33}{1320} + \\frac{1 \\times 165}{1320}$$\n$$\\sum_{j=1}^{5} q_j = \\frac{352 + 180 + 352 + 99 + 165}{1320} = \\frac{1148}{1320}$$\n\n现在我们可以计算 $NSAF_2$：\n$$NSAF_2 = \\frac{q_2}{\\sum_{j=1}^{5} q_j} = \\frac{\\frac{3}{22}}{\\frac{1148}{1320}} = \\frac{3}{22} \\times \\frac{1320}{1148}$$\n因为 $1320 = 22 \\times 60$，我们可以化简：\n$$NSAF_2 = \\frac{3}{22} \\times \\frac{22 \\times 60}{1148} = \\frac{3 \\times 60}{1148} = \\frac{180}{1148}$$\n将分子和分母同除以4来化简分数：\n$$NSAF_2 = \\frac{45}{287}$$\n最后，我们计算小数值并四舍五入到四位有效数字：\n$$NSAF_2 = \\frac{45}{287} \\approx 0.156794425...$$\n四舍五入到四位有效数字得到 $0.1568$。\n\n### 任务3：偏差讨论\n\n与基于MS1前体离子强度的方法相比，影响长度归一化谱图计数的两个主要偏差。首先，用于MS/MS的数据依赖性采集（DDA）对前体的随机采样导致对丰度较低的肽段采样不足，这引入了在全面的MS1扫描中不会出现的采样偏差和方差。其次，该方法错误地假设所有肽段具有均一的电离效率和可检测性，忽略了主要的物理化学差异，而MS1方法可以通过追踪特定的、表现良好的蛋白质代表性肽段来减轻这些差异的影响。",
            "answer": "$$\n\\boxed{0.1568}\n$$"
        },
        {
            "introduction": "多组学的最终目标是整合不同层面的数据，以获得系统层面的理解。本练习将实现一种网络传播算法，即带重启的随机游走（Random Walk with Restart），将组学信号在蛋白质相互作用网络上传播。这个编程挑战提供了一个具体的例子，说明了基于网络的方法如何综合不同类型的数据，优先排序关键生物实体，并揭示单一组学层面无法显现的特定背景下的生物学见解 。",
            "id": "4362874",
            "problem": "给定一个精准医疗场景，您需要将来自基因组学、转录组学、蛋白质组学和代谢组学的多组学证据整合到一个蛋白质-蛋白质相互作用（PPI）图上，以根据节点的网络语境化相关性对其进行优先级排序。其基本原理是分子生物学中心法则（脱氧核糖核酸（DNA）到核糖核酸（RNA）到蛋白质）、基于图的扩散模型来模拟分子相互作用流，以及马尔可夫链动力学来描述网络上的随机游走。请在PPI图上构建一个网络传播算法，该算法将多组学节点级证据作为初始分布进行整合，并给定重启概率，计算带重启的随机游走（RWR）的稳态扩散分数。该算法必须遵循概率守恒和马尔可夫链动力学的基本原理。\n\n算法设置：\n- 设PPI图由一个邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其条目为非负值，其中 $A_{ij} > 0$ 表示节点 $i$ 和节点 $j$ 之间存在无向相互作用。使用无向图表示，其中 $A$ 是对称的，并且对于所有 $i$，除非另有说明，$A_{ii} = 0$。\n- 定义一个由 $A$ 构建的列随机转移矩阵 $W \\in \\mathbb{R}^{n \\times n}$，其中每一列 $j$ 通过其列和进行归一化。对于列和为零的列，通过设置 $W_{jj} = 1$ 和对于所有 $i \\neq j$ 设置 $W_{ij} = 0$ 来创建一个自环。这编码了随机游走者在节点 $j$ 移动到节点 $i$ 的概率。\n- 设有 $L = 4$ 个组学层：基因组学、转录组学、蛋白质组学和代谢组学。对于每一层 $l \\in \\{1,2,3,4\\}$，您会得到一个原始的节点级证据向量 $x^{(l)} \\in \\mathbb{R}^{n}$。使用修正和 $\\ell_1$-归一化将每个 $x^{(l)}$ 预处理成一个非负概率分布 $p^{(l)}$：\n  1. 修正负值：对于所有 $i$，$u^{(l)}_i = \\max(0, x^{(l)}_i)$。\n  2. 如果 $\\|u^{(l)}\\|_{1} > 0$，则设置 $p^{(l)} = u^{(l)} / \\|u^{(l)}\\|_{1}$；否则，将 $p^{(l)}$ 设置为长度为 $n$ 的全零向量。\n- 给定非负的层权重 $\\alpha_{l}$，形成聚合种子 $s' = \\sum_{l=1}^{L} \\alpha_{l} p^{(l)}$。如果 $\\|s'\\|_{1} > 0$，则设置 $s = s' / \\|s'\\|_{1}$；否则，设置均匀分布 $s_i = 1/n$ 对于所有 $i$。\n- 设重启概率为 $r \\in (0,1)$，并定义RWR迭代为 $f_{t+1} = (1 - r) W f_{t} + r s$，其中 $f_0 = s$。迭代直到在 $\\ell_1$ 范数下收敛，即在第一个满足 $\\|f_{t+1} - f_t\\|_{1}  \\varepsilon$ 的 $t$ 处停止，并返回稳态向量 $f^{*}$。\n\n您的任务是实现一个完整的、可运行的程序，该程序根据给定的多组学输入和权重从 $A$ 构建 $W$，构造 $s$，并使用上述迭代方案为指定的测试套件计算 $f^{*}$。所有数值输出必须是四舍五入到 $6$ 位小数的浮点数。\n\n测试套件：\n- 案例 $1$（理想情况，连通图）：\n  - $n = 5$，\n  - $$ A = \\begin{bmatrix} 0  1  1  0  0 \\\\ 1  0  1  1  0 \\\\ 1  1  0  1  0 \\\\ 0  1  1  0  1 \\\\ 0  0  0  1  0 \\end{bmatrix} $$\n  - 基因组学 $x^{(g)} = [2,0,1,0,0.5]$，\n  - 转录组学 $x^{(t)} = [0.1,4,0,0,0]$，\n  - 蛋白质组学 $x^{(p)} = [0,0,3,0,1]$，\n  - 代谢组学 $x^{(m)} = [0,0,0.5,2,0]$，\n  - 权重 $(\\alpha_{g},\\alpha_{t},\\alpha_{p},\\alpha_{m}) = (0.25,0.25,0.25,0.25)$，\n  - 重启概率 $r = 0.3$，\n  - 收敛容差 $\\varepsilon = 10^{-12}$。\n- 案例 $2$（边界情况：小重启概率）：\n  - 与案例 $1$ 相同的 $A$, $x^{(g)}$, $x^{(t)}$, $x^{(p)}$, $x^{(m)}$ 和权重，\n  - 重启概率 $r = 0.01$，\n  - 收敛容差 $\\varepsilon = 10^{-12}$。\n- 案例 $3$（边界情况：大重启概率）：\n  - 与案例 $1$ 相同的 $A$, $x^{(g)}$, $x^{(t)}$, $x^{(p)}$, $x^{(m)}$ 和权重，\n  - 重启概率 $r = 0.99$，\n  - 收敛容差 $\\varepsilon = 10^{-12}$。\n- 案例 $4$（边缘案例：带有孤立节点的非连通图）：\n  - $n = 4$，\n  - $$ A = \\begin{bmatrix} 0  1  0  0 \\\\ 1  0  1  0 \\\\ 0  1  0  0 \\\\ 0  0  0  0 \\end{bmatrix} $$\n  - 基因组学 $x^{(g)} = [0,5,0,0]$，\n  - 转录组学 $x^{(t)} = [0,0,0,0]$，\n  - 蛋白质组学 $x^{(p)} = [0,0,1,0]$，\n  - 代谢组学 $x^{(m)} = [0,0,0,0]$，\n  - 权重 $(\\alpha_{g},\\alpha_{t},\\alpha_{p},\\alpha_{m}) = (0.5,0,0.5,0)$，\n  - 重启概率 $r = 0.5$，\n  - 收敛容差 $\\varepsilon = 10^{-12}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个包含 $n$ 个浮点数的列表，四舍五入到 $6$ 位小数，没有空格。例如，一个有效的格式是 $[[0.123456,0.234567],[0.111111,0.222222]]$。\n\n约束和说明：\n- 仅使用指定的运行时环境和库。\n- 算法必须在每次迭代中保持概率质量，并且必须使用 $\\ell_1$ 范数评估收敛性。\n- 如果聚合种子 $s'$ 是零向量，则使用均匀分布 $s_i = 1/n$。\n- 对于 $A$ 中列和为零的列，设置自环 $W_{jj} = 1$。\n- 计算结果必须以四舍五入到 $6$ 位小数的浮点数形式执行和返回。",
            "solution": "所提出的问题是有效的。它概述了一项科学上合理且数学上适定的任务：实现带重启的随机游走（RWR）算法，以整合蛋白质-蛋白质相互作用（PPI）网络上的多组学数据。该问题提供了所有必要的定义、数据和参数，没有内部矛盾或歧义。该方法是网络生物学中用于节点优先级排序的标准方法。\n\n解决方案将通过实现以下一系列步骤来开发，这些步骤直接对应于问题陈述中提供的形式化规范。\n\n**1. 列随机转移矩阵（$W$）的构建**\n\nPPI网络由一个对称邻接矩阵 $A$ 给出，其中 $A_{ij} > 0$ 表示节点 $i$ 和 $j$ 之间的相互作用。第一步是将此结构信息转换为信息流的概率模型。这是通过构建一个列随机转移矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 来实现的。每个条目 $W_{ij}$ 代表随机游走者从节点 $j$ 转移到相邻节点 $i$ 的概率。\n\n对于一个节点 $j$，其度（或加权度）是其连接的总和，$d_j = \\sum_{k=1}^{n} A_{kj}$，也就是 $A$ 的第 $j$ 列的和。如果 $d_j > 0$，则 $W$ 的第 $j$ 列中的转移概率通过对 $A$ 的相应列进行归一化来获得：\n$$W_{ij} = \\frac{A_{ij}}{d_j} = \\frac{A_{ij}}{\\sum_{k=1}^{n} A_{kj}}$$\n这确保了 $\\sum_{i=1}^{n} W_{ij} = 1$，意味着游走者从节点 $j$ 移动到任何其他节点的概率是守恒的。\n\n对于孤立节点，即 $d_j = 0$ 时，会出现一种特殊情况。对于这样的节点，游走者无处可去。问题规定在这种情况下，会创建一个自环。这通过将对角线条目 $W_{jj} = 1$ 以及该列中的所有其他条目 $W_{ij}$（对于 $i \\neq j$）设置为 $0$ 来建模。这为所有列 $j$ 保持了列随机属性 $\\sum_{i=1}^{n} W_{ij} = 1$。\n\n**2. 多组学证据整合与种子向量（$s$）构建**\n\nRWR算法需要一个起始概率分布，或一个“种子”向量 $s \\in \\mathbb{R}^{n}$，它指定了初始感兴趣的节点。这个向量是通过整合来自 $L=4$ 个不同组学层的证据来构建的。\n\n对于每个组学层 $l \\in \\{g, t, p, m\\}$（基因组学、转录组学、蛋白质组学、代谢组学），我们给出了一个原始证据向量 $x^{(l)} \\in \\mathbb{R}^{n}$。这些原始向量必须被处理成归一化的概率分布 $p^{(l)}$。这是一个两步过程：\n\na. **修正**：原始证据可能包含负值，这些值作为概率没有意义。我们通过取每个元素与零的最大值来修正向量：\n$$u^{(l)}_i = \\max(0, x^{(l)}_i)$$\n\nb. **$\\ell_1$-归一化**：修正后的向量 $u^{(l)}$ 被归一化使其和为 1，从而将其转换为概率分布 $p^{(l)}$。如果 $\\ell_1$-范数 $\\|u^{(l)}\\|_1 = \\sum_{i=1}^n u^{(l)}_i$ 大于零，则归一化为：\n$$p^{(l)} = \\frac{u^{(l)}}{\\|u^{(l)}\\|_1}$$\n如果 $\\|u^{(l)}\\|_1 = 0$，则意味着该层没有证据，因此 $p^{(l)}$ 是全零向量。\n\n在处理每个组学层之后，得到的概率向量 $p^{(l)}$ 被组合成一个单一的聚合种子向量 $s$。这是通过使用提供的层权重 $\\alpha_l$ 进行加权求和来完成的：\n$$s' = \\sum_{l=1}^{L} \\alpha_{l} p^{(l)}$$\n权重 $\\alpha_l$ 决定了每个组学层对最终种子的相对贡献。然后对得到的向量 $s'$ 进行归一化，以确保它本身是一个有效的概率分布：\n$$s = \\frac{s'}{\\|s'\\|_1}$$\n如果 $\\|s'\\|_1  0$，则执行此归一化。如果 $\\|s'\\|_1 = 0$（当所有 $p^{(l)}$ 都为零或权重为零时发生），算法将退回到一个无信息先验，将 $s$ 设置为均匀分布，$s_i = 1/n$ 对所有 $i=1, \\dots, n$。\n\n**3. 稳态分布（$f^*$）的迭代计算：带重启的随机游走**\n\n算法的核心是RWR稳态分布（表示为 $f^*$）的迭代计算。该向量代表了在考虑网络结构和初始种子分布的情况下，在每个节点上找到随机游走者的长期概率。\n\n该过程从初始分布 $f_0 = s$ 开始。然后在每个步骤 $t$ 根据递归关系更新分布：\n$$f_{t+1} = (1 - r) W f_{t} + r s$$\n这个方程有两个组成部分：\n- **“游走”部分**，$(1 - r) W f_t$：以概率 $(1-r)$，游走者从其当前位置在图上迈出一步，遵循 $W$ 中的转移概率。\n- **“重启”部分**，$rs$：以概率 $r$，游走者传送回从种子分布 $s$ 中选择的一个节点。这种重启机制确保最终分数受到初始证据的影响，防止游走者从种子节点无限扩散出去。\n\n迭代持续进行，直到过程收敛到一个稳态。当连续概率分布之间的变化小到可以忽略不计时，即达到收敛。这是通过测量连续向量之间差异的 $\\ell_1$-范数来评估的：\n$$\\|f_{t+1} - f_{t}\\|_{1} = \\sum_{i=1}^{n} |(f_{t+1})_i - (f_t)_i|$$\n当此差异首次低于预定义的容差 $\\varepsilon$ 时，迭代停止：\n$$\\|f_{t+1} - f_{t}\\|_{1}  \\varepsilon$$\n得到的向量 $f_{t+1}$ 就是所需的稳态分布 $f^*$，其元素为每个节点提供了网络语境下的相关性得分。根据 Banach 不动点定理，对于 $r \\in (0,1)$ 和一个随机矩阵 $W$，这个迭代过程保证会收敛到一个唯一的定点。这完成了算法过程。然后将最终分数按要求四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef run_rwr(A, omics_data, weights, r, epsilon, n):\n    \"\"\"\n    Computes the Random Walk with Restart steady-state distribution.\n\n    Args:\n        A (np.ndarray): The adjacency matrix of the graph.\n        omics_data (list): A list of raw node-level evidence vectors [x_g, x_t, x_p, x_m].\n        weights (tuple): A tuple of weights (alpha_g, alpha_t, alpha_p, alpha_m).\n        r (float): The restart probability.\n        epsilon (float): The convergence tolerance.\n        n (int): The number of nodes in the graph.\n\n    Returns:\n        list: The steady-state vector f*, with elements rounded to 6 decimal places.\n    \"\"\"\n    # Step 1: Construct the column-stochastic transition matrix W\n    W = np.zeros((n, n), dtype=float)\n    col_sums = A.sum(axis=0)\n    \n    for j in range(n):\n        if col_sums[j] > 0:\n            W[:, j] = A[:, j] / col_sums[j]\n        else:\n            # Handle isolated nodes with a self-loop\n            W[j, j] = 1.0\n\n    # Step 2: Preprocess omics data and construct the seed vector s\n    p_vectors = []\n    for x_l in omics_data:\n        u_l = np.maximum(0, x_l)\n        norm_u = np.sum(u_l)\n        if norm_u > 0:\n            p_l = u_l / norm_u\n        else:\n            p_l = np.zeros(n, dtype=float)\n        p_vectors.append(p_l)\n\n    s_prime = np.zeros(n, dtype=float)\n    for i in range(len(weights)):\n        s_prime += weights[i] * p_vectors[i]\n\n    norm_s_prime = np.sum(s_prime)\n    if norm_s_prime > 0:\n        s = s_prime / norm_s_prime\n    else:\n        # Fallback to uniform distribution if aggregated seed is zero vector\n        s = np.full(n, 1.0 / n, dtype=float)\n\n    # Step 3: Iterative RWR computation\n    f_t = s.copy()\n    \n    while True:\n        # f_{t+1} = (1 - r) * W * f_t + r * s\n        f_t_plus_1 = (1 - r) * (W @ f_t) + r * s\n        \n        # Check for convergence using the l1 norm\n        diff = np.sum(np.abs(f_t_plus_1 - f_t))\n        \n        f_t = f_t_plus_1\n        \n        if diff  epsilon:\n            break\n            \n    # Round the final result to 6 decimal places\n    return [round(val, 6) for val in f_t.tolist()]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for the RWR algorithm.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"A\": np.array([\n                [0, 1, 1, 0, 0],\n                [1, 0, 1, 1, 0],\n                [1, 1, 0, 1, 0],\n                [0, 1, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ], dtype=float),\n            \"omics_data\": [\n                np.array([2, 0, 1, 0, 0.5]),    # Genomics\n                np.array([0.1, 4, 0, 0, 0]),    # Transcriptomics\n                np.array([0, 0, 3, 0, 1]),      # Proteomics\n                np.array([0, 0, 0.5, 2, 0])     # Metabolomics\n            ],\n            \"weights\": (0.25, 0.25, 0.25, 0.25),\n            \"r\": 0.3,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"n\": 5,\n            \"A\": np.array([\n                [0, 1, 1, 0, 0],\n                [1, 0, 1, 1, 0],\n                [1, 1, 0, 1, 0],\n                [0, 1, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ], dtype=float),\n            \"omics_data\": [\n                np.array([2, 0, 1, 0, 0.5]),\n                np.array([0.1, 4, 0, 0, 0]),\n                np.array([0, 0, 3, 0, 1]),\n                np.array([0, 0, 0.5, 2, 0])\n            ],\n            \"weights\": (0.25, 0.25, 0.25, 0.25),\n            \"r\": 0.01,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"n\": 5,\n            \"A\": np.array([\n                [0, 1, 1, 0, 0],\n                [1, 0, 1, 1, 0],\n                [1, 1, 0, 1, 0],\n                [0, 1, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ], dtype=float),\n            \"omics_data\": [\n                np.array([2, 0, 1, 0, 0.5]),\n                np.array([0.1, 4, 0, 0, 0]),\n                np.array([0, 0, 3, 0, 1]),\n                np.array([0, 0, 0.5, 2, 0])\n            ],\n            \"weights\": (0.25, 0.25, 0.25, 0.25),\n            \"r\": 0.99,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"n\": 4,\n            \"A\": np.array([\n                [0, 1, 0, 0],\n                [1, 0, 1, 0],\n                [0, 1, 0, 0],\n                [0, 0, 0, 0]\n            ], dtype=float),\n            \"omics_data\": [\n                np.array([0, 5, 0, 0]),\n                np.array([0, 0, 0, 0]),\n                np.array([0, 0, 1, 0]),\n                np.array([0, 0, 0, 0])\n            ],\n            \"weights\": (0.5, 0, 0.5, 0),\n            \"r\": 0.5,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_rwr(\n            case[\"A\"],\n            case[\"omics_data\"],\n            case[\"weights\"],\n            case[\"r\"],\n            case[\"epsilon\"],\n            case[\"n\"]\n        )\n        results.append(result)\n\n    # Format output as a list of lists, without spaces.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}