{
    "hands_on_practices": [
        {
            "introduction": "在我们构建模型来预测剪接之前，我们必须首先了解如何从实验数据中量化剪接。本练习将指导您从RNA测序的读数（read counts）中推导出“剪接包含百分比”（Percent Spliced-In, $\\Psi$）这一剪接分析的基石 ()。通过将这个常用指标建立在最大似然估计的原则之上，您将对剪接量化的统计假设有更深刻的理解。",
            "id": "4330953",
            "problem": "在一项旨在为精准医疗优先处理剪接变异的基因组诊断研究中，训练了一个深度学习模型，用于根据序列上下文预测盒式外显子的包含概率。对于训练队列中的每个外显子，短读长核糖核酸测序（RNA-seq）提供了明确跨越定义包含事件的连接点和定义跳跃事件的连接点的reads计数。对于一个给定的盒式外显子，记$I$为支持包含的reads数，$S$为支持跳跃的reads数。假设模糊的reads已被过滤，并且该外显子的行为是一个具有两种互斥异构体的简单盒式事件。\n\n从概率论的第一性原理和一个与标准RNA-seq抽样和比对假设一致的生成式计数模型出发，根据观测到的计数$(I,S)$推导出真实包含概率$\\psi$的最大似然估计量。你的推导必须从两种异构体混合物中独立抽样跨连接点的reads所蕴含的似然函数开始，并应清楚地说明为使估计量在期望上无偏所需的所有建模假设。然后，使用你推导出的估计量，计算观测计数$I = 152$和$S = 48$的估计包含概率。将你的最终答案表示为$[0,1]$范围内的一个小数，并四舍五入到四位有效数字。",
            "solution": "该问题要求推导盒式外显子包含概率（记为$\\psi$）的最大似然估计量，该推导基于RNA-seq实验中观测到的read计数。此外，它还要求说明使该估计量无偏的假设，并针对一组特定的计数进行计算。\n\n### 第一部分：最大似然估计量（$\\hat{\\psi}$）的推导\n\n问题陈述，对于一个给定的盒式外显子，我们观测到$I$个支持包含异构体的reads和$S$个支持跳跃异构体的reads。我们被告知，这是仅有的两种结果，这是简单盒式事件假设的结果。提供信息的跨连接点reads总数为$N = I + S$。\n\n让我们对从潜在的RNA分子群体中抽样这些reads的过程进行建模。我们将感兴趣的参数$\\psi$定义为生物样本中两种可能性中包含异构体的真实比例。因此，$\\psi \\in [0, 1]$。相应地，跳跃异构体的比例是$1-\\psi$。\n\n在对分子进行测序时采用均匀和独立抽样的标准假设下，观测单个跨连接点read的事件可以建模为伯努利试验。令$X_i$（其中$i \\in \\{1, 2, \\dots, N\\}$）为一个随机变量，表示第$i$个read的结果。如果read支持包含，我们可以指定$X_i = 1$；如果它支持跳跃，则指定$X_i = 0$。成功（观测到一个包含read）的概率是$P(X_i=1) = \\psi$，失败的概率是$P(X_i=0) = 1-\\psi$。\n\n观测数据包括包含reads的总数$I$和跳跃reads的总数$S$。包含reads的总数是这些伯努利试验的总和：$I = \\sum_{i=1}^N X_i$。试验次数$N$由数据固定，$N=I+S$。因此，随机变量$I$服从参数为$N$和$\\psi$的二项分布，记为$I \\sim \\text{Binomial}(N, \\psi)$。\n\n二项分布的概率质量函数给出了在$N$次试验中观测到恰好$I$次成功的概率。当将此函数视为固定观测数据$(I, S)$下参数$\\psi$的函数时，它就是似然函数$L(\\psi | I, S)$。\n\n$$L(\\psi | I, S) = P(I \\text{ successes in } N \\text{ trials}) = \\binom{N}{I} \\psi^I (1-\\psi)^{N-I}$$\n代入$N = I+S$，我们得到：\n$$L(\\psi | I, S) = \\binom{I+S}{I} \\psi^I (1-\\psi)^S$$\n\n为了找到$\\psi$的最大似然估计量（MLE），记为$\\hat{\\psi}$，我们必须找到使$L(\\psi | I, S)$最大化的$\\psi$值。在计算上，最大化似然函数的自然对数，即对数似然函数$\\ell(\\psi) = \\ln(L(\\psi))$更为简单。由于对数是单调递增函数，最大化$\\ell(\\psi)$等同于最大化$L(\\psi)$。\n\n对数似然函数是：\n$$\\ell(\\psi) = \\ln \\left( \\binom{I+S}{I} \\psi^I (1-\\psi)^S \\right)$$\n$$\\ell(\\psi) = \\ln\\left(\\binom{I+S}{I}\\right) + I \\ln(\\psi) + S \\ln(1-\\psi)$$\n\n为了找到最大值，我们计算$\\ell(\\psi)$关于$\\psi$的导数，并将其设为零。\n$$\\frac{d\\ell}{d\\psi} = \\frac{d}{d\\psi} \\left[ \\ln\\left(\\binom{I+S}{I}\\right) + I \\ln(\\psi) + S \\ln(1-\\psi) \\right]$$\n$$\\frac{d\\ell}{d\\psi} = 0 + \\frac{I}{\\psi} + \\frac{S}{1-\\psi} \\cdot (-1) = \\frac{I}{\\psi} - \\frac{S}{1-\\psi}$$\n\n将导数设为零以找到临界点：\n$$\\frac{I}{\\hat{\\psi}} - \\frac{S}{1-\\hat{\\psi}} = 0$$\n$$\\frac{I}{\\hat{\\psi}} = \\frac{S}{1-\\hat{\\psi}}$$\n$$I(1-\\hat{\\psi}) = S\\hat{\\psi}$$\n$$I - I\\hat{\\psi} = S\\hat{\\psi}$$\n$$I = (I+S)\\hat{\\psi}$$\n\n求解$\\hat{\\psi}$，我们得到最大似然估计量：\n$$\\hat{\\psi} = \\frac{I}{I+S}$$\n\n为了确认这一点对应于最大值，我们检查对数似然的二阶导数：\n$$\\frac{d^2\\ell}{d\\psi^2} = \\frac{d}{d\\psi} \\left( \\frac{I}{\\psi} - \\frac{S}{1-\\psi} \\right) = -\\frac{I}{\\psi^2} - \\frac{S}{(1-\\psi)^2}(-1)^2 = -\\frac{I}{\\psi^2} - \\frac{S}{(1-\\psi)^2}$$\n对于$I > 0$和$S > 0$的非平凡情况，并且由于$\\psi \\in (0,1)$，两项均为负。因此，$\\frac{d^2\\ell}{d\\psi^2}  0$，这证实了$\\hat{\\psi}$确实是一个最大值。\n\n### 第二部分：无偏性的假设\n\n如果一个参数$\\theta$的估计量$\\hat{\\theta}$的期望值等于该参数的真实值，即$E[\\hat{\\theta}] = \\theta$，则该估计量是无偏的。这里，我们检验$E[\\hat{\\psi}]$。\n\n估计量为$\\hat{\\psi} = \\frac{I}{I+S} = \\frac{I}{N}$。对于期望值的计算，可以将reads的总数$N$视为一个固定量，这是以该事件的总测序深度为条件的。包含reads的数量$I$是一个随机变量，服从分布$I \\sim \\text{Binomial}(N, \\psi)$。\n\n二项随机变量的期望值为$E[I] = N\\psi$。\n我们估计量的期望是：\n$$E[\\hat{\\psi}] = E\\left[\\frac{I}{N}\\right] = \\frac{1}{N}E[I] = \\frac{1}{N}(N\\psi) = \\psi$$\n因此，估计量$\\hat{\\psi}$是无偏的。\n\n然而，这一结果依赖于一个关键假设，即基础的生成模型$\\text{Binomial}(N, \\psi)$是对物理过程的正确表示。要使$E[\\hat{\\psi}]$等于真实的生物学比例$\\psi$，必须满足以下假设：\n1.  **Reads的独立同分布**：每个跨连接点的read都是从相同的底层异构体分布中进行的独立抽样。这是伯努利试验模型的核心。\n2.  **无系统性偏差**：观测到支持某一异构体的read的概率必须等于该异构体的真实相对丰度。这意味着RNA-seq工作流程中没有技术偏差。任何系统性地偏好于生成、测序或比对来自某一异构体的reads的过程都将违反此假设并引入偏差。潜在偏差的具体来源包括：\n    -   **序列特异性偏差**：GC含量或二级结构的差异可能导致PCR或逆转录过程中的扩增效率不同。\n    -   **比对偏差**：连接点序列的复杂性或唯一性的差异可能导致来自一个异构体的reads的比对置信度高于或低于另一个。例如，如果一个连接点的序列唯一性较低，源自它的reads可能会因多重比对而被丢弃，从而使计数产生偏差。\n    -   **读长和位置偏差**：生成一个跨连接点的read的效率可能取决于读长和剪接位点的具体位置，这可能为抽样包含与跳跃连接点创造不同的“有效长度”。\n\n总之，要使估计量$\\hat{\\psi} = I/(I+S)$无偏，我们必须假设实验和计算流程提供了对两种剪接异构体相对分子计数的无偏读出。\n\n### 第三部分：数值计算\n\n给定观测计数$I = 152$和$S = 48$。\n跨连接点的reads总数为$N = I + S = 152 + 48 = 200$。\n\n使用推导出的最大似然估计量：\n$$\\hat{\\psi} = \\frac{I}{I+S} = \\frac{152}{200}$$\n$$\\hat{\\psi} = \\frac{76}{100} = 0.76$$\n\n题目要求答案以小数形式表示，并四舍五入到四位有效数字。为了将$0.76$表示为四位有效数字，我们添加尾随的零。\n$$\\hat{\\psi} = 0.7600$$\n该值代表基于提供的read证据估计的盒式外显子被包含的概率。",
            "answer": "$$\\boxed{0.7600}$$"
        },
        {
            "introduction": "剪接调控的核心是引导细胞机器的特定序列基序（motif）。本练习将介绍位置权重矩阵（Position Weight Matrix, PWM），这是一种经典的生物信息学工具，用于为这些基序建模并为潜在的剪接位点打分 ()。通过计算候选位点的对数优势比（log-odds）分数，您将学习概率序列建模的原理，并对计算机如何在浩瀚的基因组DNA中识别生物信号建立直观理解。",
            "id": "4330903",
            "problem": "您正在为精准医疗开发一个可解释的筛选流程，用于分析影响信使核糖核酸（mRNA）剪接的内含子变体。一个用于预测正链剪接结果的深度神经网络（DNN）已围绕一个参考序列进行线性化，以产生位置权重矩阵（PWM）。这些PWM在一个以双核苷酸为中心的窗口模型下，近似了网络对于经典剪接受体和供体基序的局部对数后验几率。字母表是脱氧核糖核酸（DNA）的核苷酸 $\\{A,C,G,T\\}$。给定您一个正链上的短内含子-外显子-内含子序列片段（确切的连接坐标未知），以及三个候选的受体位点窗口和三个候选的供体位点窗口。在一个生成模型下，核苷酸在给定类别的情况下是独立的，且背景分布是均匀的。下面的PWM条目指定了每个位置的类别条件概率。\n\n序列（索引仅供参考）：设序列为\n$$\nS=\\text{CACACAAGACGTCAGTCGATCA}\n$$\n其长度 $|S|=22$，索引 $1,2,\\dots,22$ 对应于\n$$\n1{:}C,\\ 2{:}A,\\ 3{:}C,\\ 4{:}A,\\ 5{:}C,\\ 6{:}A,\\ 7{:}A,\\ 8{:}G,\\ 9{:}A,\\ 10{:}C,\\ 11{:}G,\\ 12{:}T,\\ 13{:}C,\\ 14{:}A,\\ 15{:}G,\\ 16{:}T,\\ 17{:}C,\\ 18{:}G,\\ 19{:}A,\\ 20{:}T,\\ 21{:}C,\\ 22{:}A.\n$$\n\n背景碱基概率（非位点）是均匀的：对于每个碱基 $b\\in\\{A,C,G,T\\}$，$p_{\\text{bg}}(b)=\\frac{1}{4}$。\n\n受体PWM（窗口长度为 $6$；按列 $k=1,\\dots,6$，依次列出 $A,C,G,T$ 的概率）：\n- $k=1$: $(0.25,\\,0.50,\\,0.125,\\,0.125)$\n- $k=2$: $(0.50,\\,0.125,\\,0.25,\\,0.125)$\n- $k=3$: $(0.50,\\,0.125,\\,0.25,\\,0.125)$\n- $k=4$: $(0.125,\\,0.125,\\,0.50,\\,0.25)$\n- $k=5$: $(0.25,\\,0.25,\\,0.25,\\,0.25)$\n- $k=6$: $(0.125,\\,0.125,\\,0.25,\\,0.50)$\n\n供体PWM（窗口长度为 $6$；按列 $k=1,\\dots,6$，依次列出 $A,C,G,T$ 的概率）：\n- $k=1$: $(0.50,\\,0.125,\\,0.25,\\,0.125)$\n- $k=2$: $(0.25,\\,0.125,\\,0.50,\\,0.125)$\n- $k=3$: $(0.125,\\,0.125,\\,0.50,\\,0.25)$\n- $k=4$: $(0.125,\\,0.125,\\,0.25,\\,0.50)$\n- $k=5$: $(0.25,\\,0.50,\\,0.125,\\,0.125)$\n- $k=6$: $(0.25,\\,0.125,\\,0.50,\\,0.125)$\n\n经典的双核苷酸位于每个窗口的第 $k=3$ 和 $k=4$ 位置：对于受体，这对应于位置 $k=3{:}A$ 和 $k=4{:}G$ 处的 $\\text{AG}$；对于供体，这对应于位置 $k=3{:}G$ 和 $k=4{:}T$ 处的 $\\text{GT}$。\n\n待评估的候选窗口起始索引如下：\n- 受体：$s_{a}\\in\\{3,5,6\\}$，表示评估子串 $S[s_{a}:s_{a}+5]$。\n- 供体：$s_{d}\\in\\{12,13,14\\}$，表示评估子串 $S[s_{d}:s_{d}+5]$。\n\n假设位点与非位点的类别先验概率相等，并使用以2为底的对数计算对数似然比。仅使用独立性假设和 Bayes 法则作为基本出发点，推导出适用于这些PWM的特定位置对数似然比评分函数，并计算每个候选窗口的总对数几率得分。然后，选择最可能的受体和供体窗口，并以定义剪接的双核苷酸在 $S$ 中的第一个碱基的序列索引来报告预测的剪接位置（即，对于起始索引为 $s$ 的窗口，索引为 $s+2$）。将您的最终答案表示为行向量 $\\bigl[\\text{acceptor},\\ \\text{donor}\\bigr]$。无需四舍五入，答案无单位。",
            "solution": "问题要求我们基于由位置权重矩阵（PWMs）表示的概率模型，从给定脱氧核糖核酸（DNA）序列内的一组候选中，识别出最可能的剪接受体和供体位点。解决方案包括推导一个基于对数似然比的评分函数，并将其应用于候选序列。\n\n首先，我们推导评分函数。设 $W$ 是一个长度为 $L$ 的候选序列窗口。我们想计算对数几率得分，它比较的是窗口是一个功能性位点（模型 $M_{\\text{site}}$）与作为背景的一部分（模型 $M_{\\text{bg}}$）的后验概率。后验几率由 Bayes 法则给出：\n$$\n\\frac{P(M_{\\text{site}} | W)}{P(M_{\\text{bg}} | W)} = \\frac{P(W | M_{\\text{site}})}{P(W | M_{\\text{bg}})} \\frac{P(M_{\\text{site}})}{P(M_{\\text{bg}})}\n$$\n问题陈述假设类别先验概率相等，这意味着 $P(M_{\\text{site}}) = P(M_{\\text{bg}})$。因此，先验比率 $\\frac{P(M_{\\text{site}})}{P(M_{\\text{bg}})} = 1$，后验几率等于似然比。对数几率得分是该比率以2为底的对数：\n$$\n\\text{Score}(W) = \\log_2 \\left( \\frac{P(W | M_{\\text{site}})}{P(W | M_{\\text{bg}})} \\right)\n$$\n问题指定了一个模型，其中核苷酸在给定类别的情况下是独立的。对于一个窗口 $W = w_1w_2\\dots w_L$，似然为：\n$$\nP(W | M_{\\text{site}}) = \\prod_{k=1}^{L} P_{\\text{pwm}}(w_k, k)\n$$\n其中 $P_{\\text{pwm}}(w_k, k)$ 是根据位点的PWM，在窗口中位置 $k$ 处观察到核苷酸 $w_k$ 的概率。\n$$\nP(W | M_{\\text{bg}}) = \\prod_{k=1}^{L} p_{\\text{bg}}(w_k)\n$$\n其中 $p_{\\text{bg}}(w_k)$ 是核苷酸 $w_k$ 的背景概率。问题陈述了一个均匀的背景分布，因此对于任何碱基 $b \\in \\{A,C,G,T\\}$，$p_{\\text{bg}}(b) = \\frac{1}{4}$。\n\n将这些代入得分方程并利用对数的性质，我们发现总分是各位置特定得分的总和：\n$$\n\\text{Score}(W) = \\log_2 \\left( \\frac{\\prod_{k=1}^{L} P_{\\text{pwm}}(w_k, k)}{\\prod_{k=1}^{L} p_{\\text{bg}}(w_k)} \\right) = \\sum_{k=1}^{L} \\log_2 \\left( \\frac{P_{\\text{pwm}}(w_k, k)}{p_{\\text{bg}}(w_k)} \\right)\n$$\n由于 $p_{\\text{bg}}(w_k) = \\frac{1}{4}$，在位置 $k$ 处核苷酸 $b$ 的得分为 $L(b, k) = \\log_2(4 \\cdot P_{\\text{pwm}}(b, k))$。\n\n我们可以为受体和供体位点预先计算对数似然比矩阵。\n\n对于受体PWM ($P_A$)，对数得分矩阵 $L_A(b, k) = \\log_2(4 \\cdot P_A(b, k))$ 为：\n\\begin{itemize}\n    \\item $k=1$: $L_A(A) = \\log_2(1)=0$, $L_A(C) = \\log_2(2)=1$, $L_A(G) = \\log_2(0.5)=-1$, $L_A(T) = \\log_2(0.5)=-1$\n    \\item $k=2$: $L_A(A) = \\log_2(2)=1$, $L_A(C) = \\log_2(0.5)=-1$, $L_A(G) = \\log_2(1)=0$, $L_A(T) = \\log_2(0.5)=-1$\n    \\item $k=3$: $L_A(A) = \\log_2(2)=1$, $L_A(C) = \\log_2(0.5)=-1$, $L_A(G) = \\log_2(1)=0$, $L_A(T) = \\log_2(0.5)=-1$\n    \\item $k=4$: $L_A(A) = \\log_2(0.5)=-1$, $L_A(C) = \\log_2(0.5)=-1$, $L_A(G) = \\log_2(2)=1$, $L_A(T) = \\log_2(1)=0$\n    \\item $k=5$: $L_A(A,C,G,T) = \\log_2(1)=0$\n    \\item $k=6$: $L_A(A) = \\log_2(0.5)=-1$, $L_A(C) = \\log_2(0.5)=-1$, $L_A(G) = \\log_2(1)=0$, $L_A(T) = \\log_2(2)=1$\n\\end{itemize}\n\n对于供体PWM ($P_D$)，对数得分矩阵 $L_D(b, k) = \\log_2(4 \\cdot P_D(b, k))$ 为：\n\\begin{itemize}\n    \\item $k=1$: $L_D(A) = \\log_2(2)=1$, $L_D(C) = \\log_2(0.5)=-1$, $L_D(G) = \\log_2(1)=0$, $L_D(T) = \\log_2(0.5)=-1$\n    \\item $k=2$: $L_D(A) = \\log_2(1)=0$, $L_D(C) = \\log_2(0.5)=-1$, $L_D(G) = \\log_2(2)=1$, $L_D(T) = \\log_2(0.5)=-1$\n    \\item $k=3$: $L_D(A) = \\log_2(0.5)=-1$, $L_D(C) = \\log_2(0.5)=-1$, $L_D(G) = \\log_2(2)=1$, $L_D(T) = \\log_2(1)=0$\n    \\item $k=4$: $L_D(A) = \\log_2(0.5)=-1$, $L_D(C) = \\log_2(0.5)=-1$, $L_D(G) = \\log_2(1)=0$, $L_D(T) = \\log_2(2)=1$\n    \\item $k=5$: $L_D(A) = \\log_2(1)=0$, $L_D(C) = \\log_2(2)=1$, $L_D(G) = \\log_2(0.5)=-1$, $L_D(T) = \\log_2(0.5)=-1$\n    \\item $k=6$: $L_D(A) = \\log_2(1)=0$, $L_D(C) = \\log_2(0.5)=-1$, $L_D(G) = \\log_2(2)=1$, $L_D(T) = \\log_2(0.5)=-1$\n\\end{itemize}\n\n现在，我们为序列 $S=\\text{CACACAAGACGTCAGTCGATCA}$ 的候选窗口评分。\n\n受体位点候选 ($s_a \\in \\{3,5,6\\}$)：\n\\begin{enumerate}\n    \\item 对于 $s_a=3$，窗口为 $S[3:8] = \\text{CACAAG}$。得分通过对每个碱基的对数得分求和来计算：\n    $$ \\text{Score}_A(s_a=3) = L_A('C', 1) + L_A('A', 2) + L_A('C', 3) + L_A('A', 4) + L_A('A', 5) + L_A('G', 6) $$\n    $$ = 1 + 1 + (-1) + (-1) + 0 + 0 = 0 $$\n    \\item 对于 $s_a=5$，窗口为 $S[5:10] = \\text{CAAGAC}$。得分为：\n    $$ \\text{Score}_A(s_a=5) = L_A('C', 1) + L_A('A', 2) + L_A('A', 3) + L_A('G', 4) + L_A('A', 5) + L_A('C', 6) $$\n    $$ = 1 + 1 + 1 + 1 + 0 + (-1) = 3 $$\n    \\item 对于 $s_a=6$，窗口为 $S[6:11] = \\text{AAGACG}$。得分为：\n    $$ \\text{Score}_A(s_a=6) = L_A('A', 1) + L_A('A', 2) + L_A('G', 3) + L_A('A', 4) + L_A('C', 5) + L_A('G', 6) $$\n    $$ = 0 + 1 + 0 + (-1) + 0 + 0 = 0 $$\n\\end{enumerate}\n最大受体得分为 $3$，对应于起始索引为 $s_a=5$ 的窗口。\n\n供体位点候选 ($s_d \\in \\{12,13,14\\}$)：\n\\begin{enumerate}\n    \\item 对于 $s_d=12$，窗口为 $S[12:17] = \\text{TCAGTC}$。得分为：\n    $$ \\text{Score}_D(s_d=12) = L_D('T', 1) + L_D('C', 2) + L_D('A', 3) + L_D('G', 4) + L_D('T', 5) + L_D('C', 6) $$\n    $$ = (-1) + (-1) + (-1) + 0 + (-1) + (-1) = -5 $$\n    \\item 对于 $s_d=13$，窗口为 $S[13:18] = \\text{CAGTCG}$。得分为：\n    $$ \\text{Score}_D(s_d=13) = L_D('C', 1) + L_D('A', 2) + L_D('G', 3) + L_D('T', 4) + L_D('C', 5) + L_D('G', 6) $$\n    $$ = (-1) + 0 + 1 + 1 + 1 + 1 = 3 $$\n    \\item 对于 $s_d=14$，窗口为 $S[14:19] = \\text{AGTCGA}$。得分为：\n    $$ \\text{Score}_D(s_d=14) = L_D('A', 1) + L_D('G', 2) + L_D('T', 3) + L_D('C', 4) + L_D('G', 5) + L_D('A', 6) $$\n    $$ = 1 + 1 + 0 + (-1) + (-1) + 0 = 0 $$\n\\end{enumerate}\n最大供体得分为 $3$，对应于起始索引为 $s_d=13$ 的窗口。\n\n问题要求报告定义剪接的双核苷酸的第一个碱基的序列索引。指定双核苷酸位于窗口的第 $k=3$ 和 $k=4$ 位置。对于起始序列索引为 $s$ 的窗口，双核苷酸的第一个碱基位于索引 $s + (3-1) = s+2$。\n\n对于选择的起始于 $s_a=5$ 的受体窗口，预测的剪接位置是 $5 + 2 = 7$。\n对于选择的起始于 $s_d=13$ 的供体窗口，预测的剪接位置是 $13 + 2 = 15$。\n\n预测的剪接位置，受体为 $7$，供体为 $15$。",
            "answer": "$$\n\\boxed{\n\\begin{bmatrix}\n7  15\n\\end{bmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然PWM很强大，但其位置独立性的假设限制了它捕捉复杂序列模式的能力。本练习将一个PWM与一个简单的卷积神经网络（CNN）进行直接比较，以预测遗传变异对剪接位点强度的影响 ()。通过实现和比较这两种模型，您将亲身体验CNN如何学习依赖于上下文的特征，从而揭示为什么深度学习在基因组诊断等任务中通常能提供更精细、更准确的预测。",
            "id": "4330978",
            "problem": "您将执行一项正式的比较任务，比较精准医疗和基因组诊断中使用的两种基于序列的剪接供体强度模型：位置权重矩阵 (PWM) 和卷积神经网络 (CNN)。任务目标是计算单个核苷酸变异在指定供体位置的预测影响，并通过显式计算来调和两种模型之间的分歧。所有计算都必须从第一性原理出发，并实现为一个完整的、可运行的程序。\n\n供体位点窗口被定义为一个长度为 $9$ 的核苷酸序列，覆盖相对于外显子-内含子边界的 $-3,-2,-1,+1,+2,+3,+4,+5,+6$ 位置，其中 $+1$ 是第一个内含子碱基，$+2$ 是第二个内含子碱基。在人类基因组中，典型的供体双核苷酸 $+1,+2$ 通常是 $G,T$，但在提供的测试用例中可能会出现任意碱基。设字母表为 $\\{A,C,G,T\\}$，采用独热编码将每个碱基映射到 $\\mathbb{R}^4$ 中的一个向量，基序为 $(A,C,G,T)$。\n\n需要实现的模型定义：\n\n1. 位置权重矩阵 (PWM) 模型。\n   - 假设：各位置之间条件独立。\n   - 分数定义：对于一个长度为 $9$ 的序列 $s$，PWM 对数优势比分数为\n     $$S_{\\text{PWM}}(s) = \\sum_{p=0}^{8} W_{p, b(s,p)} + b_0,$$\n     其中 $p$ 是窗口位置 $0,\\dots,8$ 的索引，分别对应于 $-3,-2,-1,+1,+2,+3,+4,+5,+6$，$b(s,p)\\in\\{0,1,2,3\\}$ 是在 $(A,C,G,T)$ 顺序下位置 $p$ 处碱基的索引，$W \\in \\mathbb{R}^{9\\times 4}$ 是对数优势比贡献的位置权重矩阵，$b_0\\in\\mathbb{R}$ 是一个偏置项。变异的预测影响是分数的改变量 $\\Delta_{\\text{PWM}} = S_{\\text{PWM}}(s_{\\text{alt}}) - S_{\\text{PWM}}(s_{\\text{ref}})$。\n   - 使用的参数：\n     - 偏置：$b_0 = 0$。\n     - 矩阵 $W$ 由行 $W_{p,:}$ 给出，顺序为 $(A,C,G,T)$：\n       - $W_{0,:} = [0.2,0.0,0.0,0.0]$\n       - $W_{1,:} = [0.0,0.0,0.2,0.0]$\n       - $W_{2,:} = [0.0,0.0,0.5,0.0]$\n       - $W_{3,:} = [0.0,0.0,2.5,0.0]$\n       - $W_{4,:} = [0.0,0.0,0.0,2.5]$\n       - $W_{5,:} = [0.3,0.0,0.0,0.0]$\n       - $W_{6,:} = [0.0,0.0,0.2,0.0]$\n       - $W_{7,:} = [-0.1,-0.2,0.4,-0.2]$\n       - $W_{8,:} = [0.1,0.0,0.0,0.1]$\n\n2. 卷积神经网络 (CNN) 模型。\n   - 架构：独热编码输入 $X\\in\\{0,1\\}^{9\\times 4}$，两个宽度为 $6$ 且带偏置的一维卷积滤波器，修正线性单元 (ReLU)，对所有有效起始位置进行全局最大池化，然后通过一个线性头产生一个 logit。令 $\\phi(x)=\\max(0,x)$ 为修正线性单元。\n   - 卷积：对于滤波器 $j\\in\\{0,1\\}$，其权重为 $F^{(j)}\\in \\mathbb{R}^{6\\times 4}$，偏置为 $c_j\\in \\mathbb{R}$，在起始索引 $k\\in\\{0,1,2,3\\}$（覆盖位置 $k$ 到 $k+5$）处的有效卷积为\n     $$z^{(j)}_k = c_j + \\sum_{o=0}^{5} \\sum_{n=0}^{3} F^{(j)}_{o,n} \\, X_{k+o, n}.$$\n     滤波器 $j$ 的激活值为\n     $$a_j = \\max_{k\\in\\{0,1,2,3\\}} \\phi\\!\\left(z^{(j)}_k\\right).$$\n     最终的 CNN 剪接强度 logit 为\n     $$Y_{\\text{CNN}}(s) = v_0 a_0 + v_1 a_1 + c,$$\n     其中 $v\\in\\mathbb{R}^2$ 和 $c\\in\\mathbb{R}$ 是线性头的参数。预测的影响为 $\\Delta_{\\text{CNN}} = Y_{\\text{CNN}}(s_{\\text{alt}}) - Y_{\\text{CNN}}(s_{\\text{ref}})$。\n   - 使用的参数：\n     - 滤波器 $0$ 的权重和偏置 $c_0$：\n       - 非零权重：在偏移量 $0$ 处的 $G$ 为 $+2.0$；在偏移量 $1$ 处的 $T$ 为 $+2.0$；在偏移量 $4$ 处的 $G$ 为 $+1.0$。所有其他项均为 $0$。\n       - 偏置：$c_0 = -2.0$。\n     - 滤波器 $1$ 的权重和偏置 $c_1$：\n       - 非零权重：在偏移量 $2$ 处的 $A$ 为 $+1.0$；在偏移量 $3$ 处的 $A$ 为 $+1.0$；在偏移量 $4$ 处的 $A$ 为 $+1.5$。所有其他项均为 $0$。\n       - 偏置：$c_1 = -2.0$。\n     - 线性头：$v = [1.0, 1.0]$, $c = 0.0$。\n\n变异定义和坐标映射：\n- 该变异是位置 $+5$ 处从 $G$ 到 $A$ 的单核苷酸改变，对应于窗口索引 $p=7$。如果索引 $p=7$ 处的参考碱基不是 $G$，那么根据定义，该变异不会改变序列，预测影响为 $\\Delta_{\\text{PWM}} = 0$ 和 $\\Delta_{\\text{CNN}} = 0$。\n\n任务：\n- 对于下面的每个测试序列，计算两种模型下的参考分数和变异分数，并报告上面定义的改变量 $\\Delta_{\\text{PWM}}$ 和 $\\Delta_{\\text{CNN}}$。然后，通过比较这两个改变量的符号来报告两种模型在效应方向上是否一致，其中符号函数对于负数取 $-1$，对于零取 $0$，对于正数取 $+1$。一致性被定义为这些符号值相等。\n- 将所有浮点输出四舍五入到三位小数。\n\n测试套件（三个长度为 $9$ 的供体窗口，在索引 $7$ 处应用变异；碱基为来自 $\\{A,C,G,T\\}$ 的大写字母）：\n1. 案例 $1$：$s_{\\text{ref}} =$ \"AGGGTCAGA\"。通过将索引 $7$ 处的 $G$ 更改为 $A$ 来获得备选序列 $s_{\\text{alt}}$。\n2. 案例 $2$：$s_{\\text{ref}} =$ \"TAGGTAAGT\"。通过将索引 $7$ 处的 $G$ 更改为 $A$ 来获得备选序列 $s_{\\text{alt}}$。\n3. 案例 $3$：$s_{\\text{ref}} =$ \"CAGGTGCAT\"。尝试将索引 $7$ 处的 $G$ 更改为 $A$ 来获得备选序列 $s_{\\text{alt}}$，但如果该碱基不是 $G$，则 $s_{\\text{alt}} = s_{\\text{ref}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下\n  $$[\\Delta_{\\text{PWM}}^{(1)}, \\Delta_{\\text{CNN}}^{(1)}, \\text{agree}^{(1)}, \\Delta_{\\text{PWM}}^{(2)}, \\Delta_{\\text{CNN}}^{(2)}, \\text{agree}^{(2)}, \\Delta_{\\text{PWM}}^{(3)}, \\Delta_{\\text{CNN}}^{(3)}, \\text{agree}^{(3)}],$$\n  其中，如果符号匹配，则 $\\text{agree}^{(i)}$ 为 $1$，否则为 $0$。所有 $\\Delta$ 值必须四舍五入到三位小数，一致性值必须是整数。不应打印任何额外文本。",
            "solution": "用户提供了一个适定的计算问题，用于比较两种剪接供体强度模型：位置权重矩阵 (PWM) 和一个简单的卷积神经网络 (CNN)。任务是为两种模型计算单个核苷酸变异对给定 DNA 序列的预测影响，并确定它们的预测在方向上是否一致。该问题具有科学依据，定义明确，并提供了所有必要的参数。\n\n首先，我们建立通用框架。DNA 字母表为 $\\{A, C, G, T\\}$。我们将这些碱基分别映射到整数索引 $\\{0, 1, 2, 3\\}$。一个长度为 $L=9$ 的序列表示为一个独热编码矩阵 $X \\in \\{0, 1\\}^{9 \\times 4}$。问题定义了一个特定的单核苷酸变异：在位置 $+5$ 处，碱基从 $G$ 变为 $A$，这对应于数组索引 $p=7$。如果此位置的参考碱基不是 $G$，则该变异不适用，并且两种模型的分数变化都定义为 $0$。\n\nPWM 模型分析\n\n序列 $s$ 的 PWM 分数由位置特异性对数优势比的总和加上一个偏置项给出：\n$$S_{\\text{PWM}}(s) = \\sum_{p=0}^{8} W_{p, b(s,p)} + b_0$$\n其中 $W \\in \\mathbb{R}^{9 \\times 4}$ 是权重矩阵，$p$ 是从 $0$ 到 $8$ 的位置索引，$b(s,p)$ 是序列 $s$ 在位置 $p$ 处碱基的索引，偏置 $b_0=0$。\n\n变异的预测影响 $\\Delta_{\\text{PWM}}$ 是备选序列 ($s_{\\text{alt}}$) 和参考序列 ($s_{\\text{ref}}$) 之间的分数差：\n$$\\Delta_{\\text{PWM}} = S_{\\text{PWM}}(s_{\\text{alt}}) - S_{\\text{PWM}}(s_{\\text{ref}})$$\n由于该变异只改变单个位置 $p=7$ 处的碱基，因此所有其他位置的贡献都相互抵消：\n$$\\Delta_{\\text{PWM}} = \\left(W_{7, b(s_{\\text{alt}}, 7)} + \\sum_{p \\neq 7} W_{p, b(s,p)}\\right) - \\left(W_{7, b(s_{\\text{ref}}, 7)} + \\sum_{p \\neq 7} W_{p, b(s,p)}\\right)$$\n$$\\Delta_{\\text{PWM}} = W_{7, b(s_{\\text{alt}}, 7)} - W_{7, b(s_{\\text{ref}}, 7)}$$\n变异是 $G \\to A$，所以 $b(s_{\\text{ref}}, 7)=2$ 且 $b(s_{\\text{alt}}, 7)=0$。位置 $p=7$ 的权重为 $W_{7,:} = [-0.1, -0.2, 0.4, -0.2]$。\n因此，对于任何应用该变异的序列：\n$$\\Delta_{\\text{PWM}} = W_{7,0} - W_{7,2} = -0.1 - 0.4 = -0.6$$\n\nCNN 模型分析\n\nCNN 架构更复杂。它由一个包含两个滤波器的卷积层、一个 ReLU 激活函数、一个全局最大池化层和一个最终的线性层组成。\n对于每个宽度为 $6$ 的滤波器 $j \\in \\{0, 1\\}$，我们为输入序列 $X$ 的每个有效起始位置 $k \\in \\{0, 1, 2, 3\\}$ 计算其预激活值 $z_k^{(j)}$：\n$$z^{(j)}_k = c_j + \\sum_{o=0}^{5} \\sum_{n=0}^{3} F^{(j)}_{o,n} \\, X_{k+o, n}$$\n其中 $F^{(j)} \\in \\mathbb{R}^{6 \\times 4}$ 是滤波器权重矩阵，$c_j$ 是其偏置。\n后激活特征图通过一个 ReLU 函数，$a_k^{(j)} = \\phi(z_k^{(j)}) = \\max(0, z_k^{(j)})$。\n全局最大池化为每个滤波器取所有起始位置上的最大值：$a_j = \\max_{k} a_k^{(j)}$。\n最后，CNN logit 是这些池化激活值的线性组合：\n$$Y_{\\text{CNN}}(s) = v_0 a_0 + v_1 a_1 + c$$\n参数给定为 $v = [1.0, 1.0]$ 和 $c=0.0$。影响为 $\\Delta_{\\text{CNN}} = Y_{\\text{CNN}}(s_{\\text{alt}}) - Y_{\\text{CNN}}(s_{\\text{ref}})$。\n\n我们必须计算 $s_{\\text{ref}}$ 和 $s_{\\text{alt}}$ 的完整分数来求得 $\\Delta_{\\text{CNN}}$。\n\n案例 1：$s_{\\text{ref}} = \\text{\"AGGGTCAGA\"}$\n索引 $7$ 处的碱基是 $G$，因此变异适用。$s_{\\text{alt}} = \\text{\"AGGTCAAGA\"}$。\n$\\Delta_{\\text{PWM}}^{(1)} = -0.6$。\n\n对于 CNN，我们评估 $s_{\\text{ref}}$ 和 $s_{\\text{alt}}$。\n对于 $s_{\\text{ref}}$：\n滤波器 0（偏移量 0 处 G、偏移量 1 处 T、偏移量 4 处 G 的权重；偏置 $c_0=-2.0$）：\n- $k \\in \\{0,1,2,3\\}$：预激活值为 $z^{(0)} = [-2.0, 0.0, 0.0, 3.0]$。\n- ReLU 输出：$[0.0, 0.0, 0.0, 3.0]$。最大池化激活值 $a_{0, \\text{ref}} = 3.0$。\n滤波器 1（偏移量 2,3,4 处 A 的权重；偏置 $c_1=-2.0$）：\n- $k \\in \\{0,1,2,3\\}$：预激活值为 $z^{(1)} = [-2.0, -2.0, -0.5, -1.0]$。\n- ReLU 输出：$[0.0, 0.0, 0.0, 0.0]$。最大池化激活值 $a_{1, \\text{ref}} = 0.0$。\n$Y_{\\text{CNN}}(s_{\\text{ref}}) = 1.0 \\times 3.0 + 1.0 \\times 0.0 + 0.0 = 3.0$。\n\n对于 $s_{\\text{alt}} = \\text{\"AGGTCAAGA\"}$，索引 $7$ 处的改变影响从 $k=2,3$ 开始的窗口。\n滤波器 0：在 $k=3$ 窗口中偏移量为 4 的 $G$ 丢失了。$z^{(0)}_{3,\\text{alt}}=2.0$。新的预激活值为 $z^{(0)} = [-2.0, 0.0, 0.0, 2.0]$。$a_{0, \\text{alt}} = 2.0$。\n滤波器 1：在 $k=3$ 窗口中偏移量为 4 的新 $A$ 被匹配。$z^{(1)}_{3,\\text{alt}}=0.5$。新的预激活值为 $z^{(1)} = [-2.0, -2.0, -0.5, 0.5]$。$a_{1, \\text{alt}} = 0.5$。\n$Y_{\\text{CNN}}(s_{\\text{alt}}) = 1.0 \\times 2.0 + 1.0 \\times 0.5 + 0.0 = 2.5$。\n$\\Delta_{\\text{CNN}}^{(1)} = 2.5 - 3.0 = -0.5$。\n一致性：$\\text{sign}(-0.6) = -1$ 且 $\\text{sign}(-0.5) = -1$。符号匹配，因此一致性为 $1$。\n\n案例 2：$s_{\\text{ref}} = \\text{\"TAGGTAAGT\"}$\n索引 $7$ 处的碱基是 $G$，因此变异适用。$s_{\\text{alt}} = \\text{\"TAGGTAAAT\"}$。\n$\\Delta_{\\text{PWM}}^{(2)} = -0.6$。\n\n对于 CNN，我们评估 $s_{\\text{ref}}$ 和 $s_{\\text{alt}}$。\n对于 $s_{\\text{ref}}$：\n滤波器 0：$z^{(0)} = [-2.0, -2.0, 0.0, 3.0]$。$a_{0, \\text{ref}} = 3.0$。\n滤波器 1：$z^{(1)} = [-2.0, -0.5, 0.5, -1.0]$。$a_{1, \\text{ref}} = 0.5$。\n$Y_{\\text{CNN}}(s_{\\text{ref}}) = 1.0 \\times 3.0 + 1.0 \\times 0.5 + 0.0 = 3.5$。\n\n对于 $s_{\\text{alt}} = \\text{\"TAGGTAAAT\"}$：\n滤波器 0：在 $k=3$ 窗口中偏移量为 4 的 $G$ 丢失了。$z^{(0)}_{3,\\text{alt}} = 2.0$。$a_{0, \\text{alt}} = 2.0$。\n滤波器 1：在 $k=3$ 窗口中偏移量为 4 的新 $A$ 被匹配。该滤波器的预激活值变为 $z^{(1)} = [-2.0, -0.5, 0.5, 1.5]$。$a_{1, \\text{alt}} = 1.5$。\n$Y_{\\text{CNN}}(s_{\\text{alt}}) = 1.0 \\times 2.0 + 1.0 \\times 1.5 + 0.0 = 3.5$。\n$\\Delta_{\\text{CNN}}^{(2)} = 3.5 - 3.5 = 0.0$。\n一致性：$\\text{sign}(-0.6) = -1$ 且 $\\text{sign}(0.0) = 0$。符号不匹配，因此一致性为 $0$。\n\n案例 3：$s_{\\text{ref}} = \\text{\"CAGGTGCAT\"}$\n索引 $7$ 处的碱基是 $A$。根据问题定义，该变异不适用。\n因此，$\\Delta_{\\text{PWM}}^{(3)} = 0.0$ 且 $\\Delta_{\\text{CNN}}^{(3)} = 0.0$。\n一致性：两者均为 $\\text{sign}(0.0) = 0$。符号匹配，因此一致性为 $1$。\n\n结果摘要：\n- 案例 $1$：$\\Delta_{\\text{PWM}} = -0.600$，$\\Delta_{\\text{CNN}} = -0.500$，一致性 = $1$。\n- 案例 $2$：$\\Delta_{\\text{PWM}} = -0.600$，$\\Delta_{\\text{CNN}} = 0.000$，一致性 = $0$。\n- 案例 $3$：$\\Delta_{\\text{PWM}} = 0.000$，$\\Delta_{\\text{CNN}} = 0.000$，一致性 = $1$。\n最终输出是这些值的扁平化列表，并按要求进行了四舍五入。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the model comparison problem for splice site variants.\n    \"\"\"\n    # Define problem parameters\n    BASE_TO_IDX = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    \n    # PWM model parameters\n    W_PWM = np.array([\n        [0.2, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.2, 0.0],\n        [0.0, 0.0, 0.5, 0.0],\n        [0.0, 0.0, 2.5, 0.0],\n        [0.0, 0.0, 0.0, 2.5],\n        [0.3, 0.0, 0.0, 0.0],\n        [0.0, 0.0, 0.2, 0.0],\n        [-0.1, -0.2, 0.4, -0.2],\n        [0.1, 0.0, 0.0, 0.1]\n    ])\n\n    # CNN model parameters\n    # Filter 0\n    F0_CNN = np.zeros((6, 4))\n    F0_CNN[0, BASE_TO_IDX['G']] = 2.0\n    F0_CNN[1, BASE_TO_IDX['T']] = 2.0\n    F0_CNN[4, BASE_TO_IDX['G']] = 1.0\n    C0_CNN = -2.0\n\n    # Filter 1\n    F1_CNN = np.zeros((6, 4))\n    F1_CNN[2, BASE_TO_IDX['A']] = 1.0\n    F1_CNN[3, BASE_TO_IDX['A']] = 1.0\n    F1_CNN[4, BASE_TO_IDX['A']] = 1.5\n    C1_CNN = -2.0\n\n    # Linear Head\n    V_CNN = np.array([1.0, 1.0])\n    C_HEAD_CNN = 0.0\n\n    def one_hot_encode(seq: str) - np.ndarray:\n        \"\"\"Converts a DNA sequence to its one-hot encoded representation.\"\"\"\n        encoding = np.zeros((len(seq), 4), dtype=np.int8)\n        for i, base in enumerate(seq):\n            if base in BASE_TO_IDX:\n                encoding[i, BASE_TO_IDX[base]] = 1\n        return encoding\n\n    def get_cnn_score(seq_one_hot: np.ndarray) - float:\n        \"\"\"Calculates the CNN logit for a given one-hot encoded sequence.\"\"\"\n        num_positions = seq_one_hot.shape[0]\n        filter_width = 6\n        num_windows = num_positions - filter_width + 1\n\n        # Filter 0 convolution, ReLU, and max-pooling\n        z0 = np.zeros(num_windows)\n        for k in range(num_windows):\n            window = seq_one_hot[k:k+filter_width, :]\n            z0[k] = C0_CNN + np.sum(F0_CNN * window)\n        a0 = np.max(np.maximum(0, z0))\n\n        # Filter 1 convolution, ReLU, and max-pooling\n        z1 = np.zeros(num_windows)\n        for k in range(num_windows):\n            window = seq_one_hot[k:k+filter_width, :]\n            z1[k] = C1_CNN + np.sum(F1_CNN * window)\n        a1 = np.max(np.maximum(0, z1))\n\n        # Linear head\n        logit = V_CNN[0] * a0 + V_CNN[1] * a1 + C_HEAD_CNN\n        return logit\n\n    test_cases = [\n        \"AGGGTCAGA\",\n        \"TAGGTAAGT\",\n        \"CAGGTGCAT\",\n    ]\n\n    results = []\n    for s_ref_str in test_cases:\n        variant_pos = 7\n        ref_base = 'G'\n        alt_base = 'A'\n\n        if s_ref_str[variant_pos] != ref_base:\n            delta_pwm = 0.0\n            delta_cnn = 0.0\n        else:\n            s_alt_str = s_ref_str[:variant_pos] + alt_base + s_ref_str[variant_pos+1:]\n\n            # PWM delta calculation\n            delta_pwm = W_PWM[variant_pos, BASE_TO_IDX[alt_base]] - W_PWM[variant_pos, BASE_TO_IDX[ref_base]]\n            \n            # CNN delta calculation\n            s_ref_one_hot = one_hot_encode(s_ref_str)\n            s_alt_one_hot = one_hot_encode(s_alt_str)\n            \n            score_ref = get_cnn_score(s_ref_one_hot)\n            score_alt = get_cnn_score(s_alt_one_hot)\n            delta_cnn = score_alt - score_ref\n        \n        # Agreement calculation\n        sign_pwm = np.sign(delta_pwm)\n        sign_cnn = np.sign(delta_cnn)\n        agreement = 1 if sign_pwm == sign_cnn else 0\n\n        # Append formatted results\n        results.append(f\"{delta_pwm:.3f}\")\n        results.append(f\"{delta_cnn:.3f}\")\n        results.append(str(agreement))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}