{
    "hands_on_practices": [
        {
            "introduction": "在对组织样本数据进行细胞解卷积之前，我们需要一个可靠的参考基准：细胞类型特征矩阵（$S$）。本练习将指导您完成从单细胞RNA测序原始计数数据构建该矩阵的核心生物信息学流程。您将实施关键的预处理步骤，包括文库大小归一化和方差稳定化，从而将充满噪声的原始计数数据转换为可用于解卷积的稳健特征矩阵。",
            "id": "4321251",
            "problem": "给定单细胞 RNA 测序 (scRNA-seq) 计数数据和 $K$ 种细胞类型的整数标签。您的任务是构建一个参考特征矩阵 $S \\in \\mathbb{R}^{G \\times K}$，其条目 $S_{g,t}$ 表示基因 $g$ 在经过适当预处理后，在特定细胞类型中的线性尺度平均表达量。该构建过程必须基于科学合理的步骤，这些步骤植根于块状组织表达的混合模型。在该模型中，基因 $g$ 的块状组织表达被建模为细胞类型特异性表达的线性组合：$$Y_g \\approx \\sum_{t=1}^{K} S_{g,t} \\, w_t,$$ 其中 $Y_g$ 是线性单位下的块状组织表达量，$w_t$ 是总和为一的非负混合权重。为了确保在具有不同捕获效率和测序深度的细胞之间具有可比性，您必须通过库大小对 scRNA-seq 计数进行归一化并稳定方差，然后返回到与混合模型一致的线性尺度。\n\n从以下核心事实和定义开始：\n- 单细胞 RNA 测序 (scRNA-seq) 计数数据是非负整数，由于技术因素（捕获效率、测序深度），每个细胞的库大小是可变的。\n- 细胞 $i$ 的库大小定义为 $$L_i = \\sum_{g=1}^{G} C_{g,i},$$ 其中 $C_{g,i}$ 是细胞 $i$ 中基因 $g$ 的原始计数。\n- 计数可以通过以下公式缩放为百万分之几计数 (CPM)，这是一个线性单位：$$X_{g,i} = \\begin{cases} \\dfrac{C_{g,i}}{L_i} \\times M,  L_i > 0, \\\\ 0,  L_i = 0, \\end{cases}$$ 其中 $M = 10^6$（一百万）代表目标库大小。\n- 对数变换通常用于稳定计数衍生度量的方差；然而，混合模型要求 $S$ 处于线性尺度。\n\n您必须实现以下步骤：\n1. 计算所有细胞的库大小 $L_i$。\n2. 使用上述规则将计数归一化为 CPM，其中 $M = 10^6$。\n3. 通过计算 $$Z_{g,i} = \\log\\!\\big(1 + X_{g,i}\\big)$$ 来应用方差稳定化，使用自然对数。\n4. 对于每种细胞类型 $t \\in \\{1, \\dots, K\\}$，计算类型为 $t$ 的细胞的 $Z_{g,i}$ 的平均值：$$\\mu_{g,t} = \\frac{1}{n_t} \\sum_{i \\in I_t} Z_{g,i},$$ 其中 $I_t$ 是标签为 $t$ 的细胞索引集合，$n_t = |I_t|$。\n5. 反变换回线性 CPM 尺度：$$S_{g,t} = \\exp(\\mu_{g,t}) - 1.$$\n\n按如下方式处理边界情况：\n- 如果一个细胞的 $L_i = 0$，则定义所有基因 $g$ 的 $X_{g,i} = 0$，以避免除以零，并且因为没有计数意味着该细胞没有表达的证据。\n- 如果某种细胞类型 $t$ 没有细胞（即 $n_t = 0$），则定义所有基因 $g$ 的 $S_{g,t} = 0$。\n\n单位：$S$ 的所有输出必须以百万分之几计数 (CPM) 表示，作为实值浮点数。对数是无单位的。不涉及角度。百分比（如果概念上出现）必须表示为小数，但您的程序不应计算混合权重。\n\n您的程序必须实现上述流程并为下面的每个测试用例计算 $S$。对于每个用例，返回一个按行主序展开的 $G \\times K$ 浮点数列表，四舍五入到六位小数。\n\n测试套件：\n- 案例 A（一般情况，$G = 4$, $N = 6$, $K = 3$）：\n  $$C = \\begin{bmatrix}\n  100  200  0  50  400  300 \\\\\n  0  100  50  0  200  100 \\\\\n  500  0  0  300  100  0 \\\\\n  0  0  100  200  0  0\n  \\end{bmatrix}, \\quad \\text{labels} = [1, 1, 2, 2, 3, 3], \\quad M = 10^6.$$\n- 案例 B（边界：库大小为零的细胞，基因完全为零，$G = 3$, $N = 4$, $K = 2$）：\n  $$C = \\begin{bmatrix}\n  0  0  100  0 \\\\\n  0  0  0  0 \\\\\n  0  50  0  50\n  \\end{bmatrix}, \\quad \\text{labels} = [1, 1, 2, 2], \\quad M = 10^6.$$\n- 案例 C（边界：含单个细胞的类型，偏态计数，$G = 2$, $N = 3$, $K = 2$）：\n  $$C = \\begin{bmatrix}\n  1000  2000  3000 \\\\\n  5000  0  0\n  \\end{bmatrix}, \\quad \\text{labels} = [1, 2, 2], \\quad M = 10^6.$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身也是一个方括号括起来的、按行主序排列的 $S$ 扁平化值的逗号分隔列表，四舍五入到六位小数。例如：\n$$[ [s^{(A)}_1,\\dots,s^{(A)}_{G\\cdot K}], [s^{(B)}_1,\\dots,s^{(B)}_{G\\cdot K}], [s^{(C)}_1,\\dots,s^{(C)}_{G\\cdot K}] ].$$",
            "solution": "用户提供了一个明确定义的计算生物学问题，即从单细胞 RNA 测序 (scRNA-seq) 计数数据构建细胞类型特征矩阵 $S$。该问题在科学上是合理的，在数学上是精确的，并且在算法上是明确的。它被验证为一个合理的问题。\n\n目标是计算一个特征矩阵 $S \\in \\mathbb{R}^{G \\times K}$，其中 $S_{g,t}$ 代表基因 $g$ 在细胞类型 $t$ 中的平均表达量。该矩阵对于细胞解卷积至关重要，细胞解卷积旨在使用线性混合模型 $Y_g \\approx \\sum_{t=1}^{K} S_{g,t} \\, w_t$ 从块状组织表达数据中估计细胞类型比例。所提供的方法是生物信息学中一个标准且稳健的流程。解决方案通过实施指定的步骤进行，每一步都基于既定的科学原理。\n\n**步骤 1：按库大小归一化**\n\n原始数据包含一个计数矩阵 $C \\in \\mathbb{Z}_{\\ge 0}^{G \\times N}$，其中 $C_{g,i}$ 是在细胞 $i$ 中检测到的基因 $g$ 的 RNA 转录本数量。scRNA-seq 中技术变异的一个主要来源是不同细胞间的测序深度和捕获效率的差异。细胞 $i$ 的库大小定义为转录本的总计数 $L_i = \\sum_{g=1}^{G} C_{g,i}$，可作为这些技术因素的代表。为了使不同细胞间的表达水平具有可比性，必须对原始计数进行归一化。\n\n问题指定了归一化为百万分之几计数 (CPM)，这是一种广泛使用的方法。细胞 $i$ 中基因 $g$ 的 CPM 值，记为 $X_{g,i}$，计算如下：\n$$\nX_{g,i} = \\begin{cases} \\dfrac{C_{g,i}}{L_i} \\times M,  L_i > 0, \\\\ 0,  L_i = 0. \\end{cases}\n$$\n这里，$M = 10^6$ 是一个缩放因子，它为所有细胞设定了一个共同的库大小（一百万）。这种转换将表达数据置于一个线性的、可比较的尺度上，同时正确处理了总计数为零的细胞（$L_i = 0$）的边界情况，对于这些细胞，其表达量在逻辑上为零。\n\n**步骤 2：方差稳定化**\n\n基因表达计数数据，即使在归一化之后，也常常表现出异方差性，即表达的方差随均值的增加而增加。这一特性可能导致在下游分析中给予高表达基因过大的权重。对数变换是一种标准的统计技术，用于稳定方差，使其在整个表达值范围内更加均匀。\n\n指定的变换是：\n$$\nZ_{g,i} = \\log\\!\\big(1 + X_{g,i}\\big)\n$$\n其中 $\\log$ 表示自然对数。加上一个伪计数 $1$ 有两个目的：它避免了对零取对数（因为 $X_{g,i} \\ge 0$），并且它减弱了对数对小计数值的影响，防止了低表达基因之间比率的过度膨胀。\n\n**步骤 3：按细胞类型聚合**\n\n为了给每种细胞类型创建一个典型的表达特征，我们必须聚合属于该类型的所有细胞的表达谱。问题指定细胞类型标签是从 $1$ 到 $K$ 的整数。对于每个基因 $g$ 和细胞类型 $t$，其特征是通过对数变换后的值的平均值得出的。\n\n设 $I_t$ 是对应于类型 $t$ 的细胞索引集合，$n_t = |I_t|$ 是这类细胞的数量。平均对数表达量 $\\mu_{g,t}$ 计算如下：\n$$\n\\mu_{g,t} = \\frac{1}{n_t} \\sum_{i \\in I_t} Z_{g,i}\n$$\n在对数空间中求平均值比在线性 CPM 尺度上求平均值对异常值更具鲁棒性。单个细胞中的极端表达值对平均值的影响会小得多。如果数据集中没有某种细胞类型 $t$（$n_t = 0$），则其特征谱 $S_{g,t}$ 对所有基因 $g$ 都定义为 $0$，这是一个合乎逻辑的默认值。\n\n**步骤 4：反变换回线性尺度**\n\n最终的特征矩阵 $S$ 旨在用于线性混合模型。因此，聚合的表达值必须是线性尺度，而不是对数尺度。平均对数表达值 $\\mu_{g,t}$ 必须被转换回原始的 CPM 尺度。\n\n变换 $z = \\log(1+x)$ 的逆变换是 $x = \\exp(z) - 1$。将此应用于 $\\mu_{g,t}$ 即可得到最终的特征矩阵条目：\n$$\nS_{g,t} = \\exp(\\mu_{g,t}) - 1\n$$\n这个值 $S_{g,t}$ 可以被解释为基因 $g$ 在细胞类型 $t$ 中表达的中心趋势的稳健度量。它等价于类型 $t$ 的所有细胞的 $(1+X_{g,i})$ 值的几何平均数减去 $1$。这提供了一个在线性 CPM 尺度上的代表性表达值，适用于解卷积算法。\n\n完整的流程构成了一种从 scRNA-seq 数据构建高质量特征矩阵的、有原则且科学合理的方法。",
            "answer": "```python\nimport numpy as np\n\ndef build_signature_matrix(C, labels, M=1e6):\n    \"\"\"\n    Constructs a reference signature matrix S from scRNA-seq count data.\n\n    Args:\n        C (np.ndarray): A GxN matrix of raw counts (G aenes, N cells).\n        labels (np.ndarray): A 1D array of N integer cell-type labels (1-based).\n        M (float): The scaling factor for CPM normalization (e.g., 10^6).\n\n    Returns:\n        np.ndarray: The GxK signature matrix S.\n    \"\"\"\n    # Defensive copy to avoid modifying original inputs\n    C = C.astype(np.float64)\n    labels = np.array(labels, dtype=int)\n\n    G, N = C.shape\n    if N == 0:\n        # Handle case with no cells\n        K = np.max(labels) if labels.size > 0 else 0\n        return np.zeros((G, K))\n    \n    # Step 1: Compute library sizes\n    L = C.sum(axis=0)\n\n    # Step 2: Normalize to counts per million (CPM)\n    X = np.zeros_like(C, dtype=np.float64)\n    valid_cells_mask = L > 0\n    # Use np.divide with a 'where' clause for safe division\n    X[:, valid_cells_mask] = np.divide(C[:, valid_cells_mask], L[valid_cells_mask], where=L[valid_cells_mask] > 0) * M\n    \n    # Step 3: Apply variance stabilization\n    Z = np.log(1.0 + X)\n\n    # Determine K, the number of cell types\n    # The problem implies labels are 1...K, so max(labels) defines K.\n    K = np.max(labels) if labels.size > 0 else 0\n    S = np.zeros((G, K), dtype=np.float64)\n    \n    # Iterate through cell types 1 to K\n    for t in range(1, K + 1):\n        # Find indices for cells of the current type t\n        cell_indices = np.where(labels == t)[0]\n        n_t = len(cell_indices)\n\n        # Step 4  5: Aggregate and Back-transform\n        if n_t > 0:\n            # Select columns from Z for the current cell type\n            Z_t = Z[:, cell_indices]\n            \n            # Compute the mean of log-transformed values\n            mu_gt = np.mean(Z_t, axis=1)\n            \n            # Back-transform to the linear scale and assign to S\n            # S columns are 0-indexed, so we use t-1\n            S[:, t - 1] = np.exp(mu_gt) - 1.0\n        else:\n            # Per the problem, if a cell type has no cells, its signature is all zeros.\n            # S is initialized to zeros, so no action is needed.\n            pass\n            \n    return S\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [100, 200, 0, 50, 400, 300],\n                [0, 100, 50, 0, 200, 100],\n                [500, 0, 0, 300, 100, 0],\n                [0, 0, 100, 200, 0, 0]\n            ]),\n            np.array([1, 1, 2, 2, 3, 3])\n        ),\n        (\n            np.array([\n                [0, 0, 100, 0],\n                [0, 0, 0, 0],\n                [0, 50, 0, 50]\n            ]),\n            np.array([1, 1, 2, 2])\n        ),\n        (\n            np.array([\n                [1000, 2000, 3000],\n                [5000, 0, 0]\n            ]),\n            np.array([1, 2, 2])\n        )\n    ]\n\n    all_results_str = []\n    for C, labels in test_cases:\n        S = build_signature_matrix(C, labels)\n        \n        # Flatten the matrix in row-major ('C') order\n        flat_S = S.flatten(order='C')\n        \n        # Format each number to six decimal places\n        formatted_S = [f\"{val:.6f}\" for val in flat_S]\n        \n        # Create the string for the current case's result list\n        case_result_str = f\"[{','.join(formatted_S)}]\"\n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "有了特征矩阵后，我们就可以从一个整体组织样本中估计细胞比例。本练习将解决一个常见的现实挑战：基因表达数据不完整或存在噪声 。您将推导并应用加权最小二乘（WLS）估计器，这是一种强大的方法，它为每个基因赋予不同的权重，从而使您能够稳健地处理缺失的测量值。",
            "id": "4321266",
            "problem": "一个组织块信使核糖核酸 (mRNA) 表达测量值可以建模为细胞类型特异性表达谱的线性叠加，并由其未知比例加权。具体来说，设 $G$ 个基因的组织块表达由一个向量 $y \\in \\mathbb{R}^{G}$ 表示，该向量来自 $K$ 种组成细胞类型，具有一个已知的参考（特征）矩阵 $X \\in \\mathbb{R}^{G \\times K}$ 和一个未知的组分向量 $p \\in \\mathbb{R}^{K}$。假设每个基因存在异方差的加性噪声，这与关于测序计数变异性的经过充分检验的事实一致，并通过为缺失基因的条目分配零权重来将其视为无信息。从线性混合模型 $y = X p + \\varepsilon$ 开始，其中 $\\varepsilon$ 是零均值，推导 $p$ 的加权最小二乘 (WLS) 估计量，使用一个对角权重矩阵 $W \\in \\mathbb{R}^{G \\times G}$，其对角元素为 $w_{g} \\geq 0$，且对于缺失的基因，$w_{g} = 0$。然后，在以下具有 $G=5$ 个基因和 $K=3$ 种细胞类型的科学上合理的解卷积实例上计算该估计量，其中 $20\\%$ 的基因被屏蔽（一个基因缺失，因此权重为零）：\n\n$$\nX \\;=\\;\n\\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1 \\\\\n1  1  1 \\\\\n2  0  1\n\\end{pmatrix},\n\\qquad\ny \\;=\\;\n\\begin{pmatrix}\n1.25 \\\\\n1.00 \\\\\n1.00 \\\\\n0.25 \\\\\n2.00\n\\end{pmatrix},\n\\qquad\nW \\;=\\; \\mathrm{diag}(1,\\,1,\\,1,\\,1,\\,0).\n$$\n\n使用 WLS 公式，并为缺失条目设置所述的零权重，来估计组分向量 $p$。假设比例不受不等式约束，但以通常的组分意义解释结果。将最终估计的组分的每个条目四舍五入到四位有效数字，并将最终答案表示为在 $\\mathrm{pmatrix}$ 环境中的单个十进制分数的行向量。",
            "solution": "该问题要求推导线性模型的加权最小二乘 (WLS) 估计量，并将其应用于基因组学中的细胞解卷积问题。\n\n首先，我们推导 WLS 估计量的一般公式。模型给定为 $y = X p + \\varepsilon$，其中 $y \\in \\mathbb{R}^{G}$ 是组织块基因表达向量，$X \\in \\mathbb{R}^{G \\times K}$ 是已知的细胞类型特异性特征矩阵，$p \\in \\mathbb{R}^{K}$ 是未知的细胞类型比例向量，$\\varepsilon \\in \\mathbb{R}^{G}$ 是均值为零的随机误差向量，$E[\\varepsilon] = 0$。假设误差不相关但具有异方差性，这可以通过使用一个对角线上具有非负元素 $w_g$ 的对角权重矩阵 $W \\in \\mathbb{R}^{G \\times G}$ 来解决。权重 $w_g$ 通常选择为与第 $g$ 个基因的误差方差成反比。\n\nWLS 估计量 $\\hat{p}$ 是使加权残差平方和 $S(p)$ 最小化的向量 $p$：\n$$S(p) = \\sum_{g=1}^{G} w_g (y_g - (Xp)_g)^2$$\n用矩阵形式，这个目标函数写为：\n$$S(p) = (y - Xp)^T W (y - Xp)$$\n为了找到最小值，我们展开这个表达式：\n$$S(p) = (y^T - (Xp)^T) W (y - Xp)$$\n$$S(p) = (y^T - p^T X^T) (Wy - WXp)$$\n$$S(p) = y^T W y - y^T W X p - p^T X^T W y + p^T X^T W X p$$\n由于 $y^T W X p$ 是一个标量（$1 \\times 1$ 矩阵），它等于其转置：$(y^T W X p)^T = p^T X^T W^T y$。鉴于 $W$ 是一个对角矩阵，它是对称的（$W^T = W$），因此 $p^T X^T W^T y = p^T X^T W y$。因此，中间两项是相同的。\n$$S(p) = y^T W y - 2 p^T X^T W y + p^T X^T W X p$$\n为了找到使 $S(p)$ 最小化的 $p$ 值，我们计算 $S(p)$ 关于 $p$ 的梯度并将其设为零。使用矩阵微积分的标准法则：\n$$\\nabla_p S(p) = \\frac{\\partial S}{\\partial p} = \\frac{\\partial}{\\partial p} (y^T W y - 2 p^T X^T W y + p^T X^T W X p)$$\n$$\\nabla_p S(p) = 0 - 2 X^T W y + 2 (X^T W X) p$$\n将梯度设为零，得到 WLS 问题的正规方程：\n$$2 (X^T W X) p = 2 X^T W y$$\n$$(X^T W X) p = X^T W y$$\n假设矩阵 $X^T W X$ 是可逆的（如果 $W^{1/2}X$ 的列是线性无关的，则此假设成立），我们可以解出 $p$。WLS 估计量，记为 $\\hat{p}_{WLS}$，是：\n$$\\hat{p}_{WLS} = (X^T W X)^{-1} X^T W y$$\n推导到此完成。\n\n接下来，我们将此估计量应用于给定的数据：\n$$\nX \\;=\\;\n\\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1 \\\\\n1  1  1 \\\\\n2  0  1\n\\end{pmatrix},\n\\qquad\ny \\;=\\;\n\\begin{pmatrix}\n1.25 \\\\\n1.00 \\\\\n1.00 \\\\\n0.25 \\\\\n2.00\n\\end{pmatrix},\n\\qquad\nW \\;=\\; \\mathrm{diag}(1,\\,1,\\,1,\\,1,\\,0)\n$$\n权重矩阵 $W$ 对第五个基因的权重为零，从而有效地将其从回归中移除。这是因为任何涉及第五个基因的项都将乘以 $w_5 = 0$。\n\n让我们计算估计量公式的各个组成部分。首先是 $X^T W X$：\n$$X^T W = \\begin{pmatrix} 1  0  0  1  2 \\\\ 0  1  0  1  0 \\\\ 0  0  1  1  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0  0  0 \\\\ 0  1  0  0  0 \\\\ 0  0  1  0  0 \\\\ 0  0  0  1  0 \\\\ 0  0  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 1  0  0  1  0 \\\\ 0  1  0  1  0 \\\\ 0  0  1  1  0 \\end{pmatrix}$$\n$$X^T W X = \\begin{pmatrix} 1  0  0  1  0 \\\\ 0  1  0  1  0 \\\\ 0  0  1  1  0 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\\\ 1  1  1 \\\\ 2  0  1 \\end{pmatrix} = \\begin{pmatrix} (1 \\cdot 1 + 1 \\cdot 1)  (1 \\cdot 0 + 1 \\cdot 1)  (1 \\cdot 0 + 1 \\cdot 1) \\\\ (1 \\cdot 0 + 1 \\cdot 1)  (1 \\cdot 1 + 1 \\cdot 1)  (1 \\cdot 0 + 1 \\cdot 1) \\\\ (1 \\cdot 0 + 1 \\cdot 1)  (1 \\cdot 0 + 1 \\cdot 1)  (1 \\cdot 1 + 1 \\cdot 1) \\end{pmatrix} = \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}$$\n这就是我们必须求逆的矩阵。我们称之为 $A = X^T W X$。\n\n接下来，我们计算 $X^T W y$：\n$$W y = \\begin{pmatrix} 1  0  0  0  0 \\\\ 0  1  0  0  0 \\\\ 0  0  1  0  0 \\\\ 0  0  0  1  0 \\\\ 0  0  0  0  0 \\end{pmatrix} \\begin{pmatrix} 1.25 \\\\ 1.00 \\\\ 1.00 \\\\ 0.25 \\\\ 2.00 \\end{pmatrix} = \\begin{pmatrix} 1.25 \\\\ 1.00 \\\\ 1.00 \\\\ 0.25 \\\\ 0 \\end{pmatrix}$$\n$$X^T W y = \\begin{pmatrix} 1  0  0  1  2 \\\\ 0  1  0  1  0 \\\\ 0  0  1  1  1 \\end{pmatrix} \\begin{pmatrix} 1.25 \\\\ 1.00 \\\\ 1.00 \\\\ 0.25 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1(1.25) + 1(0.25) \\\\ 1(1.00) + 1(0.25) \\\\ 1(1.00) + 1(0.25) \\end{pmatrix} = \\begin{pmatrix} 1.50 \\\\ 1.25 \\\\ 1.25 \\end{pmatrix}$$\n现在，我们求 $A = \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}$ 的逆矩阵。行列式是：\n$$\\det(A) = 2(2 \\cdot 2 - 1 \\cdot 1) - 1(1 \\cdot 2 - 1 \\cdot 1) + 1(1 \\cdot 1 - 2 \\cdot 1) = 2(3) - 1(1) + 1(-1) = 6 - 1 - 1 = 4$$\n代数余子式矩阵是：\n$$C = \\begin{pmatrix} (4-1)  -(2-1)  (1-2) \\\\ -(2-1)  (4-1)  -(2-1) \\\\ (1-2)  -(2-1)  (4-1) \\end{pmatrix} = \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}$$\n伴随矩阵是代数余子式矩阵的转置，$\\mathrm{adj}(A) = C^T$。由于 $C$ 是对称的，所以 $\\mathrm{adj}(A) = C$。\n逆矩阵是 $A^{-1} = \\frac{1}{\\det(A)} \\mathrm{adj}(A)$：\n$$A^{-1} = \\frac{1}{4} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}$$\n最后，我们计算 $\\hat{p}_{WLS}$：\n$$\\hat{p}_{WLS} = A^{-1} (X^T W y) = \\frac{1}{4} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix} \\begin{pmatrix} 1.50 \\\\ 1.25 \\\\ 1.25 \\end{pmatrix}$$\n$$\\hat{p}_{WLS} = \\frac{1}{4} \\begin{pmatrix} 3(1.50) - 1(1.25) - 1(1.25) \\\\ -1(1.50) + 3(1.25) - 1(1.25) \\\\ -1(1.50) - 1(1.25) + 3(1.25) \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} 4.50 - 2.50 \\\\ -1.50 + 3.75 - 1.25 \\\\ -1.50 - 1.25 + 3.75 \\end{pmatrix}$$\n$$\\hat{p}_{WLS} = \\frac{1}{4} \\begin{pmatrix} 2.00 \\\\ 1.00 \\\\ 1.00 \\end{pmatrix} = \\begin{pmatrix} 0.50 \\\\ 0.25 \\\\ 0.25 \\end{pmatrix}$$\n估计的组分向量是 $\\hat{p} = (0.50, 0.25, 0.25)^T$。这些值是非负的，并且总和为 $1$，这与将 $p$ 解释为比例向量是一致的。\n问题要求将结果四舍五入到四位有效数字，并表示为行向量。\n$0.50$ 变为 $0.5000$。\n$0.25$ 变为 $0.2500$。\n$0.25$ 变为 $0.2500$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.5000  0.2500  0.2500 \\end{pmatrix} } $$"
        },
        {
            "introduction": "在临床研究中，我们常常拥有先验知识，例如某些免疫细胞的预期稀有度。最后一个练习将介绍一个贝叶斯框架，通过使用狄利克雷（Dirichlet）先验，将这类信息正式整合到您的模型中 。通过探索改变先验参数如何影响后验估计，您将对贝叶斯推断如何提高解卷积的准确性和可靠性（尤其是在数据稀疏的情况下）建立起直观的理解。",
            "id": "4321280",
            "problem": "您正在为精准医疗和基因组诊断建立整体组织表达数据中的细胞组分比例模型。假设基础的细胞类型比例向量为 $p = (p_1, \\dots, p_K)$，其中 $p_j \\ge 0$ 且 $\\sum_{j=1}^K p_j = 1$。您对 $p$ 设置一个非对称狄利克雷先验以编码关于稀有细胞类型的先验知识：$p \\sim \\text{Dirichlet}(\\alpha_1, \\dots, \\alpha_K)$，其中稀有细胞类型具有较小的集中度参数 $ \\alpha_j $。然后，您观测到总共 $N = \\sum_{j=1}^K x_j$ 次分配中聚合的细胞类型特异性计数 $x = (x_1, \\dots, x_K)$，这些计数通过以 $p$ 为参数的多项式似然进行建模。\n\n从多项式似然和狄利克雷先验的基本定义及其贝叶斯共轭性出发，推导在给定 $x$ 的条件下 $p$ 的后验分布。根据该后验分布，推导后验均值 $\\mathbb{E}[p_j \\mid x]$ 和后验方差 $\\mathrm{Var}(p_j \\mid x)$ 关于后验集中度参数的一般表达式。使用这些表达式，通过改变单个集中度参数 $ \\alpha_j $ 同时保持所有其他集中度参数不变，来编码关于稀有细胞类型的先验知识。通过计算精确值，模拟在几种场景下改变该单一参数如何影响相应 $p_j$ 的后验均值和方差（不要使用百分号；所有比例均表示为小数）。\n\n实现一个程序，对于下方的每个测试用例，该程序接受：\n- 一个非对称先验集中度向量 $(\\alpha_1, \\dots, \\alpha_K)$，\n- 一个索引 $j$，指定要改变其单个集中度参数的稀有细胞类型，\n- 一个用于替换 $\\alpha_j$ 的值列表，\n- 一个观测到的计数向量 $(x_1, \\dots, x_K)$，\n\n并针对 $\\alpha_j$ 的每个替换值，输出在相应后验分布下 $p_j$ 的后验均值和方差。一个测试用例的输出应该是一个浮点数列表，顺序为 $[\\text{mean}_1,\\text{var}_1,\\text{mean}_2,\\text{var}_2,\\dots]$，其中每一对对应于 $\\alpha_j$ 的一个替换值。\n\n使用以下旨在探测不同情景的测试套件：\n\n- 测试用例1（一般情况，稀有细胞计数较少）：\n  - $K = 5$\n  - 先验集中度: $(\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4, \\alpha_5) = (0.5, 2.0, 2.0, 1.0, 0.1)$\n  - 稀有细胞类型索引: $j = 5$\n  - $\\alpha_j$的替换值: $[0.05, 0.1, 1.0]$\n  - 观测计数: $(x_1, x_2, x_3, x_4, x_5) = (60, 180, 140, 15, 5)$\n\n- 测试用例2（边界情况，稀有细胞的观测计数为零）：\n  - $K = 4$\n  - 先验集中度: $(\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4) = (1.5, 1.5, 1.5, 0.05)$\n  - 稀有细胞类型索引: $j = 4$\n  - $\\alpha_j$的替换值: $[0.01, 0.05, 5.0]$\n  - 观测计数: $(x_1, x_2, x_3, x_4) = (120, 80, 50, 0)$\n\n- 测试用例3（相对于数据，稀有细胞的先验较大）：\n  - $K = 3$\n  - 先验集中度: $(\\alpha_1, \\alpha_2, \\alpha_3) = (0.5, 0.5, 100.0)$\n  - 稀有细胞类型索引: $j = 3$\n  - $\\alpha_j$的替换值: $[10.0, 100.0, 1000.0]$\n  - 观测计数: $(x_1, x_2, x_3) = (30, 20, 10)$\n\n- 测试用例4（小样本量，多种稀有类型，对先验的敏感性）：\n  - $K = 6$\n  - 先验集中度: $(\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4, \\alpha_5, \\alpha_6) = (0.2, 0.2, 0.2, 0.2, 0.2, 0.2)$\n  - 稀有细胞类型索引: $j = 3$\n  - $\\alpha_j$的替换值: $[0.01, 0.2, 2.0]$\n  - 观测计数: $(x_1, x_2, x_3, x_4, x_5, x_6) = (2, 1, 0, 0, 1, 0)$\n\n您的程序应生成单行输出，其中包含所有四个测试用例的聚合结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例贡献一个如上所述格式的内部列表。所有数值输出都应是四舍五入到小数点后六位的小数。最终输出必须为 $[[\\text{mean}_1,\\text{var}_1,\\text{mean}_2,\\text{var}_2,\\dots],[\\dots],[\\dots],[\\dots]]$ 的形式，并精确地作为单行打印，不含任何额外文本。",
            "solution": "我们首先对整体组织表达数据的细胞解卷积的概率模型进行形式化。令 $p = (p_1, \\dots, p_K)$ 表示细胞类型比例的向量，其中 $p_j \\ge 0$ 且 $\\sum_{j=1}^K p_j = 1$。为了编码先验知识，我们对 $p$ 设置一个非对称狄利克雷先验，\n$$\np \\sim \\text{Dirichlet}(\\alpha_1, \\dots, \\alpha_K),\n$$\n其中集中度参数 $\\alpha_j > 0$ 控制了组分上的先验质量。对于一个稀有细胞类型，较小的 $\\alpha_j$ 表示我们先验地认为 $p_j$ 通常很小。\n\n假设我们观测到由以 $p$ 为条件的多项分布生成的计数 $x = (x_1, \\dots, x_K)$，总数为 $N = \\sum_{j=1}^K x_j$：\n$$\nx \\mid p \\sim \\text{Multinomial}(N, p).\n$$\n在多项分布下，似然函数在忽略多项式系数常数的情况下为，\n$$\nL(p; x) \\propto \\prod_{j=1}^K p_j^{x_j}.\n$$\n狄利克雷先验的密度为\n$$\n\\pi(p; \\alpha) = \\frac{1}{B(\\alpha)} \\prod_{j=1}^K p_j^{\\alpha_j - 1},\n$$\n其中 $B(\\alpha)$ 是多元贝塔函数 $B(\\alpha) = \\frac{\\prod_{j=1}^K \\Gamma(\\alpha_j)}{\\Gamma(\\alpha_0)}$ 且 $\\alpha_0 = \\sum_{j=1}^K \\alpha_j$。\n\n根据贝叶斯定理，后验分布正比于似然与先验的乘积：\n$$\n\\pi(p \\mid x) \\propto L(p; x) \\cdot \\pi(p; \\alpha) \\propto \\prod_{j=1}^K p_j^{x_j} \\cdot \\prod_{j=1}^K p_j^{\\alpha_j - 1} = \\prod_{j=1}^K p_j^{(\\alpha_j + x_j) - 1}.\n$$\n识别出狄利克雷核，我们得出结论，后验分布也是一个狄利克雷分布，其更新后的集中度参数为\n$$\n\\alpha'_j = \\alpha_j + x_j, \\quad \\text{for } j = 1, \\dots, K,\n$$\n总集中度为\n$$\n\\alpha'_0 = \\sum_{j=1}^K \\alpha'_j = \\sum_{j=1}^K \\alpha_j + \\sum_{j=1}^K x_j = \\alpha_0 + N.\n$$\n\n我们现在推导在狄利克雷分布下 $p_j$ 的后验均值和方差。对于 $p \\sim \\text{Dirichlet}(\\alpha')$，可以使用伽马函数的性质以及将狄利克雷分布表示为归一化的伽马随机变量的方法，来推导其标准矩的结果。具体来说，令 $Y_j \\sim \\text{Gamma}(\\alpha'_j, 1)$ 相互独立，并定义 $S = \\sum_{k=1}^K Y_k$。那么 $p_j = Y_j / S$。使用此表示法，可以得到\n$$\n\\mathbb{E}[p_j] = \\frac{\\alpha'_j}{\\alpha'_0},\n$$\n以及二阶矩\n$$\n\\mathbb{E}[p_j^2] = \\frac{\\alpha'_j(\\alpha'_j + 1)}{\\alpha'_0(\\alpha'_0 + 1)}.\n$$\n因此，方差为\n$$\n\\mathrm{Var}(p_j) = \\mathbb{E}[p_j^2] - (\\mathbb{E}[p_j])^2 = \\frac{\\alpha'_j(\\alpha'_0 - \\alpha'_j)}{\\alpha'^2_0(\\alpha'_0 + 1)}.\n$$\n这些表达式可以从已知的狄利克雷矩得到，或者通过使用狄利克雷密度和贝塔/伽马恒等式进行积分推导得出。\n\n为了在贝叶斯解卷积设定中编码关于稀有细胞类型的先验知识，我们考虑改变单个先验集中度参数 $\\alpha_j$，同时保持所有其他 $\\alpha_k$（$k \\ne j$）固定不变。在给定观测计数 $x$ 的情况下，这一改变会产生一个后验分布，其更新后的参数为 $\\alpha'_j = \\alpha_j^{(\\text{new})} + x_j$ 和 $\\alpha'_0 = (\\alpha_0^{(\\text{new})}) + N$，其中 $\\alpha_0^{(\\text{new})}$ 反映了被修改的单个分量。$p_j$ 的后验均值和方差会通过上述公式对这一变化作出响应。\n\n为每个测试用例计算所需输出的算法步骤如下：\n1. 解析 $K$、先验集中度向量 $(\\alpha_1, \\dots, \\alpha_K)$、稀有细胞类型索引 $j$、$\\alpha_j$ 的替换值列表以及观测计数 $(x_1, \\dots, x_K)$。\n2. 对于列表中的每个替换值 $v$：\n   - 形成一个新的先验向量 $\\tilde{\\alpha}$，它与给定的先验向量相同，除了 $\\tilde{\\alpha}_j = v$。\n   - 对所有 $k$ 计算后验参数 $\\alpha'_k = \\tilde{\\alpha}_k + x_k$，以及 $\\alpha'_0 = \\sum_{k=1}^K \\alpha'_k$。\n   - 计算后验均值 $\\mu_j = \\alpha'_j / \\alpha'_0$ 和方差 $\\sigma_j^2 = \\alpha'_j(\\alpha'_0 - \\alpha'_j)/(\\alpha'^2_0(\\alpha'_0 + 1))$。\n   - 将 $\\mu_j$ 和 $\\sigma_j^2$ 追加到该测试用例的结果列表中。\n3. 将所有数值输出四舍五入到小数点后六位。\n4. 将所有测试用例的结果聚合到一个外部列表中，并按指定格式单行打印。\n\n该过程确定性地量化了，在一个共轭狄利克雷-多项式模型下，改变稀有细胞类型的单个狄利克雷集中度参数如何影响其比例估计的后验均值和方差。测试套件涵盖了一般情况、观测计数为零的边界条件、先验占主导地位的情景，以及一个用于探测对先验设定敏感度的小样本场景。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef posterior_mean_variance(alpha_vec, counts_vec, j_index):\n    \"\"\"\n    Compute posterior mean and variance for p_j under a Dirichlet posterior\n    given prior alpha_vec and observed counts counts_vec, for index j_index.\n    \"\"\"\n    alpha_vec = np.asarray(alpha_vec, dtype=float)\n    counts_vec = np.asarray(counts_vec, dtype=float)\n    alpha_post = alpha_vec + counts_vec\n    alpha0_post = float(np.sum(alpha_post))\n    aj_post = float(alpha_post[j_index])\n    mean_j = aj_post / alpha0_post\n    var_j = aj_post * (alpha0_post - aj_post) / (alpha0_post**2 * (alpha0_post + 1.0))\n    return mean_j, var_j\n\ndef format_results_nested(nested_lists):\n    \"\"\"\n    Format nested list of floats into a single-line string with required structure,\n    rounding to six decimals.\n    \"\"\"\n    def fmt_float(x):\n        # Round to six decimal places\n        return f\"{x:.6f}\"\n    inner_strs = []\n    for inner in nested_lists:\n        inner_fmt = \",\".join(fmt_float(val) for val in inner)\n        inner_strs.append(f\"[{inner_fmt}]\")\n    return f\"[{','.join(inner_strs)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (K, prior_alpha, j_index, alpha_j_variants, counts)\n    test_cases = [\n        # Test Case 1\n        (5, [0.5, 2.0, 2.0, 1.0, 0.1], 4, [0.05, 0.1, 1.0], [60, 180, 140, 15, 5]),\n        # Test Case 2\n        (4, [1.5, 1.5, 1.5, 0.05], 3, [0.01, 0.05, 5.0], [120, 80, 50, 0]),\n        # Test Case 3\n        (3, [0.5, 0.5, 100.0], 2, [10.0, 100.0, 1000.0], [30, 20, 10]),\n        # Test Case 4\n        (6, [0.2, 0.2, 0.2, 0.2, 0.2, 0.2], 2, [0.01, 0.2, 2.0], [2, 1, 0, 0, 1, 0]),\n    ]\n\n    results = []\n    for K, prior_alpha, j_index, variants, counts in test_cases:\n        # Sanity checks\n        assert len(prior_alpha) == K\n        assert len(counts) == K\n        assert j_index >= 0 and j_index < K\n        inner_results = []\n        for v in variants:\n            # Replace only the single concentration parameter for the rare cell type.\n            alpha_new = list(prior_alpha)\n            # Ensure positivity of Dirichlet parameters\n            if v <= 0:\n                raise ValueError(\"Dirichlet concentration parameters must be strictly positive.\")\n            alpha_new[j_index] = v\n            mean_j, var_j = posterior_mean_variance(alpha_new, counts, j_index)\n            inner_results.extend([mean_j, var_j])\n        results.append(inner_results)\n\n    # Final print statement in the exact required format.\n    print(format_results_nested(results))\n\nsolve()\n```"
        }
    ]
}