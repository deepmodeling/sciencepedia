{
    "hands_on_practices": [
        {
            "introduction": "The ability to uniquely map a sequencing read is not just a property of the read itself, but is fundamentally constrained by the repetitiveness of the reference genome. This exercise introduces the concept of mappability, a critical measure of the uniqueness of genomic regions. By building a mappability profile from first principles, you will gain hands-on experience in identifying regions that are likely to cause ambiguous alignments, a crucial skill for interpreting mapping results and designing genomic assays .",
            "id": "4375143",
            "problem": "You are given the task of constructing a mappability profile for a deoxyribonucleic acid (DNA) reference string and relating this profile to the expected multi-mapping rate under an exact seeding model used in high-throughput sequencing alignment. The setting and definitions rely on first principles in computational genomics and probability.\n\nDefinitions and assumptions:\n- A reference genome is represented as a finite string over the alphabet $\\{A, C, G, T, N\\}$. The character $N$ denotes an unknown base and is not treated as a valid match for seeding.\n- A $k$-mer is a contiguous substring of length $k$ of the reference string. Only $k$-mers containing characters in $\\{A, C, G, T\\}$ are considered valid seeds.\n- The reverse complement operation for a string over $\\{A, C, G, T\\}$ is defined by complementing $A \\leftrightarrow T$ and $C \\leftrightarrow G$, then reversing the complemented string.\n- A $k$-mer $s$ at a forward-strand position is said to be unique across both strands if the total number of genomic coordinates on the forward strand where either $s$ or its reverse complement $\\mathrm{rc}(s)$ appears is exactly $1$. If $s$ equals $\\mathrm{rc}(s)$, the total count is the number of coordinates where $s$ appears (no double counting).\n- The mappability profile is the vector obtained by sliding a window of size $k$ along the forward strand and marking each valid $k$-mer position with $1$ if it is unique across both strands and $0$ otherwise. Positions where the window contains $N$ are considered invalid and excluded from the mappability profile.\n- Reads are assumed to start at uniformly random positions along the forward strand of the reference that yield valid $k$-mer seeds, and to be attempted with a single exact seed consisting of the leftmost $k$ bases of the read. Each base of the read independently incurs a substitution error with probability $\\epsilon$, identically distributed across positions. Under this model, the probability that a $k$-length seed is error-free is $(1 - \\epsilon)^k$.\n- A read is considered multi-mapping if its exact seed matches at least two distinct genomic coordinates (across both strands).\n\nObjective:\n- For each provided test case, compute the expected multi-mapping rate as a decimal number defined by the fraction of valid forward-strand $k$-mer positions whose seeds are non-unique across both strands, multiplied by the probability that the $k$-length seed is error-free, i.e.,\n$$\n\\text{Expected multi-mapping rate} \\;=\\; \\left(\\frac{\\text{number of valid non-unique }k\\text{-mer positions}}{\\text{number of valid }k\\text{-mer positions}}\\right)\\cdot (1 - \\epsilon)^k,\n$$\nwith the convention that the value is $0$ if there are no valid $k$-mer positions.\n\nFundamental base:\n- Strings and substrings over a finite alphabet.\n- Reverse complement of a DNA string.\n- Independent Bernoulli error per base with parameter $\\epsilon$, yielding the exact-seed success probability $(1 - \\epsilon)^k$ by independence and multiplicativity.\n- Uniform sampling of read start positions across valid seedable positions on the forward strand.\n\nYour program must:\n- Construct the mappability profile by counting occurrences of each valid $k$-mer on the forward strand and occurrences of its reverse complement on the forward strand, and determine uniqueness for each valid position as defined above.\n- Use the mappability profile to compute the expected multi-mapping rate under the exact seeding and error model described.\n\nTest suite:\nCompute the expected multi-mapping rate for the following parameter sets, where each tuple is $(\\text{reference}, k, \\epsilon)$:\n- Case $1$: $\\left(\\text{\"ACGTACGTAC\"},\\, 3,\\, 0.0\\right)$.\n- Case $2$: $\\left(\\text{\"ACGTTGCATGTCGCATGATGCATGAGAGCT\"},\\, 4,\\, 0.05\\right)$.\n- Case $3$: $\\left(\\text{\"AAAACAAAAG\"},\\, 2,\\, 0.0\\right)$.\n- Case $4$: $\\left(\\text{\"ACNNTGACN\"},\\, 3,\\, 0.0\\right)$.\n- Case $5$: $\\left(\\text{\"ACGT\"},\\, 5,\\, 0.0\\right)$.\n\nAnswer specification:\n- The answer for each test case is a single float representing the expected multi-mapping rate as defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\text{result}_1,\\text{result}_2,\\dots]$.",
            "solution": "The problem requires the computation of an expected multi-mapping rate for DNA sequence reads under a simplified exact-seeding model. The solution necessitates a careful implementation of a multi-step process: identifying valid seed locations, determining the uniqueness of each seed, and applying a probabilistic error model. The solution proceeds by systematically adhering to the definitions provided.\n\nFirst, let the reference genome be denoted by a string $S$ of length $L$ over the alphabet $\\{A, C, G, T, N\\}$. A seed is a $k$-mer, a substring of length $k$. A position $i$ (from $0$ to $L-k$) is a valid starting point for a seed if the substring $S[i:i+k]$ contains no 'N' characters.\n\nThe core of the problem lies in the definition of seed uniqueness. A seed $s$ originating from a specific position is unique if the total number of occurrences of $s$ and its reverse complement, $\\mathrm{rc}(s)$, across the entire forward strand of $S$ is exactly $1$. If $s$ is a palindrome, i.e., $s = \\mathrm{rc}(s)$, its uniqueness is determined solely by its own count. This principle of considering both strands is fundamental in genomics, as sequencing reads can originate from either the forward or reverse strand of the DNA double helix.\n\nThe overall algorithm is designed as follows:\n\n1.  **Enumeration of Valid Seeds and Frequency Analysis**: The first step is to establish the population of valid seeds. We iterate through the reference string $S$ from position $i=0$ to $L-k$. At each position, we extract the $k$-mer $s = S[i:i+k]$. If $s$ contains any 'N' characters, it is discarded. Otherwise, it is a valid seed, and its starting position $i$ is a valid seed position. Let $N_{valid}$ be the total count of such positions. To facilitate the uniqueness check, we perform a frequency analysis by iterating through all valid positions and populating a hash map (dictionary) that stores the counts of each distinct valid $k$-mer sequence found in $S$. This pre-computation avoids redundant scanning of the reference string.\n\n2.  **Uniqueness Determination per Position**: With the k-mer frequencies computed, we can now determine the uniqueness for the seed at each valid starting position. We iterate again through the valid positions $i=0, \\dots, L-k$. For each valid position $i$, we retrieve the corresponding k-mer $s = S[i:i+k]$. Using the pre-computed frequency map, we find the number of occurrences of $s$, let's call it $c(s)$, and the number of occurrences of its reverse complement $\\mathrm{rc}(s)$, let's call it $c(\\mathrm{rc}(s))$.\n    - If $s$ is a palindrome ($s = \\mathrm{rc}(s)$), the total count is simply $C_{total} = c(s)$.\n    - If $s$ is not a palindrome, the total count is $C_{total} = c(s) + c(\\mathrm{rc}(s))$.\n    The seed at position $i$ is non-unique if $C_{total}  1$. We sum the number of positions that result in a non-unique seed, yielding the count $N_{non\\_unique}$.\n\n3.  **Calculation of the Expected Rate**: The problem defines the expected multi-mapping rate with a specific formula. It is the product of two probabilities under the given model:\n    a. The probability that a randomly chosen valid seed is non-unique. Assuming uniform sampling over the valid start positions, this probability is the fraction $\\frac{N_{non\\_unique}}{N_{valid}}$. If $N_{valid}=0$, this fraction is taken to be $0$.\n    b. The probability that the $k$-length seed is error-free. With an independent base error probability of $\\epsilon$, this is $(1 - \\epsilon)^k$.\n\nThe final expected multi-mapping rate is therefore calculated as:\n$$\n\\text{Rate} = \\left(\\frac{N_{non\\_unique}}{N_{valid}}\\right) \\cdot (1 - \\epsilon)^k\n$$\nThis structured approach correctly translates the problem's definitions into a concrete, verifiable computational procedure. Edge cases, such as when $k  L$ or when no valid $k$-mers exist, are naturally handled, resulting in $N_{valid}=0$ and thus a rate of $0.0$ as stipulated.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def reverse_complement(dna_string: str) - str:\n        \"\"\"\n        Computes the reverse complement of a DNA string.\n        Assumes the input string contains only 'A', 'C', 'G', 'T'.\n        \"\"\"\n        complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        complemented = ''.join([complement_map[base] for base in dna_string])\n        return complemented[::-1]\n\n    def calculate_rate(reference: str, k: int, epsilon: float) - float:\n        \"\"\"\n        Calculates the expected multi-mapping rate based on the problem definition.\n        \"\"\"\n        ref_len = len(reference)\n        \n        # Step 1: Identify all valid k-mer positions.\n        valid_positions = []\n        if k = ref_len:\n            for i in range(ref_len - k + 1):\n                kmer = reference[i:i+k]\n                if 'N' not in kmer:\n                    valid_positions.append(i)\n        \n        num_valid_positions = len(valid_positions)\n        if num_valid_positions == 0:\n            return 0.0\n            \n        # Step 2: Pre-compute the frequency of each distinct valid k-mer.\n        kmer_occurrence_counts = {}\n        for i in valid_positions:\n            kmer = reference[i:i+k]\n            kmer_occurrence_counts[kmer] = kmer_occurrence_counts.get(kmer, 0) + 1\n\n        # Step 3: Count the number of positions that yield a non-unique seed.\n        non_unique_positions_count = 0\n        for i in valid_positions:\n            s = reference[i:i+k]\n            rc_s = reverse_complement(s)\n            \n            total_count = 0\n            if s == rc_s: # Palindromic k-mer\n                total_count = kmer_occurrence_counts.get(s, 0)\n            else: # Non-palindromic k-mer\n                count_s = kmer_occurrence_counts.get(s, 0)\n                count_rc_s = kmer_occurrence_counts.get(rc_s, 0)\n                total_count = count_s + count_rc_s\n            \n            if total_count  1:\n                non_unique_positions_count += 1\n                \n        # Step 4: Calculate the final expected rate.\n        fraction_non_unique = non_unique_positions_count / num_valid_positions\n        seed_success_prob = np.power(1 - epsilon, k)\n        \n        expected_rate = fraction_non_unique * seed_success_prob\n        \n        return expected_rate\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        (\"ACGTACGTAC\", 3, 0.0),\n        (\"ACGTTGCATGTCGCATGATGCATGAGAGCT\", 4, 0.05),\n        (\"AAAACAAAAG\", 2, 0.0),\n        (\"ACNNTGACN\", 3, 0.0),\n        (\"ACGT\", 5, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        reference_str, k_val, epsilon_val = case\n        result = calculate_rate(reference_str, k_val, epsilon_val)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A central task in read alignment is to distinguish a true alignment from plausible alternatives, which requires a scoring system that can differentiate between high-confidence mismatches (potential variants) and low-confidence discrepancies (likely sequencing errors). This practice demonstrates how to leverage the Phred quality score, a standard metric of base-calling accuracy, within a rigorous log-likelihood framework to quantitatively evaluate the evidence supporting an alignment. This approach is fundamental to how modern aligners weigh evidence to find the most probable placement for a read .",
            "id": "4375120",
            "problem": "A precision oncology pipeline uses Next-Generation Sequencing (NGS) reads and quality-aware alignment scoring to discriminate between a correct alignment of a read to a reference genome and an alternative alignment that implies base mismatches at certain positions. Consider a generative model for base observation in which, conditioned on the true reference base at a position, a sequencer emits the correct base with probability $1 - p$ and, if it errs, distributes the error uniformly over the three incorrect bases, assigning probability $p/3$ to each incorrect base. The Phred quality scale is defined such that the Phred quality score $Q$ is minus ten times the base-10 logarithm of the base-calling error probability $p$. Using this foundation and assuming independence across positions, derive the conversion from a baseâ€™s quality score $Q$ to its error probability $p$, and then compute the per-read natural-logarithm log-likelihood ratio in favor of a correct alignment versus a specific incorrect alignment that mismatches the read at two positions, when the read agrees with the reference at those two positions and the observed quality scores are $Q_{1} = 30$ and $Q_{2} = 25$. Explicitly, compute\n$$\nS \\;=\\; \\sum_{i=1}^{2} \\ln\\!\\left(\\frac{P(\\text{observed base} \\mid \\text{match at position } i)}{P(\\text{observed base} \\mid \\text{mismatch at position } i)}\\right),\n$$\nusing the model above and the Phred definition. Express the final score in nats and round your answer to four significant figures.",
            "solution": "The solution proceeds in several steps. First, we derive the relationship between the error probability $p$ and the Phred quality score $Q$. Second, we formulate the probabilities for the numerator and denominator of the likelihood ratio. Third, we assemble the log-likelihood ratio expression. Finally, we substitute the given numerical values and compute the score $S$.\n\n_1. Conversion from Phred Quality Score ($Q$) to Error Probability ($p$)_\n\nThe Phred quality score $Q$ is defined as:\n$$Q = -10 \\log_{10}(p)$$\nTo find the error probability $p$ as a function of $Q$, we solve this equation for $p$:\n$$-\\frac{Q}{10} = \\log_{10}(p)$$\n$$p(Q) = 10^{-Q/10}$$\nThis is the required conversion formula.\n\n_2. Formulation of Probabilities for the Likelihood Ratio_\n\nThe score $S$ is a sum of log-likelihood ratios over two positions, $i=1, 2$. Let's analyze the term for a single position $i$:\n$$S_i = \\ln\\left(\\frac{P(\\text{observed base} \\mid \\text{match at position } i)}{P(\\text{observed base} \\mid \\text{mismatch at position } i)}\\right)$$\n\nThe numerator, $P(\\text{observed base} \\mid \\text{match at position } i)$, is the probability of observing a specific base from the sequencer, given that the alignment is correct at this position. A correct alignment implies that the true reference base is identical to the observed read base. The probability of the sequencer correctly identifying a base is given by the model as $1 - p_i$, where $p_i$ is the error probability at position $i$.\n$$P(\\text{observed base} \\mid \\text{match at position } i) = 1 - p_i$$\n\nThe denominator, $P(\\text{observed base} \\mid \\text{mismatch at position } i)$, is the probability of observing a specific base, given that the alignment is incorrect at this position. An incorrect alignment implies that the true reference base is different from the observed read base. For the observed base to be recorded, the sequencer must have made an error. The model specifies that when an error occurs, it is uniformly distributed over the three incorrect bases. Thus, the probability of observing any single, specific incorrect base is $p_i/3$.\n$$P(\\text{observed base} \\mid \\text{mismatch at position } i) = \\frac{p_i}{3}$$\n\n_3. Log-Likelihood Ratio Calculation_\n\nSubstituting these probabilities into the expression for $S_i$, we get:\n$$S_i = \\ln\\left(\\frac{1 - p_i}{p_i/3}\\right)$$\nThe total score $S$ is the sum over the two positions:\n$$S = S_1 + S_2 = \\ln\\left(\\frac{1 - p_1}{p_1/3}\\right) + \\ln\\left(\\frac{1 - p_2}{p_2/3}\\right)$$\n\n_4. Numerical Computation_\n\nWe are given the quality scores $Q_1 = 30$ and $Q_2 = 25$. We use the derived formula $p(Q) = 10^{-Q/10}$ to find the corresponding error probabilities.\n\nFor position $1$:\n$$p_1 = 10^{-Q_1/10} = 10^{-30/10} = 10^{-3} = 0.001$$\n\nFor position $2$:\n$$p_2 = 10^{-Q_2/10} = 10^{-25/10} = 10^{-2.5}$$\n\nNow, we substitute these values into the expression for $S$:\n$$S = \\ln\\left(\\frac{1 - 10^{-3}}{10^{-3}/3}\\right) + \\ln\\left(\\frac{1 - 10^{-2.5}}{10^{-2.5}/3}\\right)$$\nLet's simplify the terms:\n$$S = \\ln\\left(3 \\times \\frac{1 - 10^{-3}}{10^{-3}}\\right) + \\ln\\left(3 \\times \\frac{1 - 10^{-2.5}}{10^{-2.5}}\\right)$$\n$$S = \\ln\\left(3 \\times (10^3 - 1)\\right) + \\ln\\left(3 \\times (10^{2.5} - 1)\\right)$$\n$$S = \\ln(3 \\times 999) + \\ln(3 \\times (10^{2.5} - 1))$$\n$$S = \\ln(2997) + \\ln(3 \\times (10^{2.5} - 1))$$\n\nWe now compute the numerical values. The natural logarithm means the result is in nats.\n$$S_1 = \\ln(2997) \\approx 8.00536709$$\nFor the second term:\n$$10^{2.5} = 10^2 \\times 10^{0.5} = 100\\sqrt{10} \\approx 100 \\times 3.16227766 = 316.227766$$\n$$S_2 = \\ln(3 \\times (316.227766 - 1)) = \\ln(3 \\times 315.227766) = \\ln(945.683298) \\approx 6.85195000$$\n\nThe total score $S$ is the sum:\n$$S = S_1 + S_2 \\approx 8.00536709 + 6.85195000 = 14.85731709$$\n\nThe problem requires the answer to be rounded to four significant figures.\n$$S \\approx 14.86$$\nThis score represents the total evidence, in nats, in favor of the correct alignment over the specified incorrect one, based on the observations at these two positions.",
            "answer": "$$\\boxed{14.86}$$"
        },
        {
            "introduction": "Once an alignment is determined, its location must be communicated accurately, a task complicated by the co-existence of different coordinate systems in standard bioinformatics file formats. This exercise delves into the critical, real-world challenge of correctly handling 0-based and 1-based genomic coordinates, which are used by formats like BED and VCF. By analyzing the downstream consequences of \"off-by-one\" conversion errors, you will understand how seemingly minor implementation details can lead to significant misinterpretations of genomic variants .",
            "id": "4375062",
            "problem": "In genome informatics, interval coordinates are represented using two widely adopted systems grounded in standard definitions of indexing over sequences. In a $0$-based inclusive-exclusive (half-open) system, an interval $[s,e)$ represents the elements at offsets $s, s+1, \\dots, e-1$; in a $1$-based inclusive (closed) system, an interval $[S,E]$ represents the elements at positions $S, S+1, \\dots, E$. A mathematically consistent interconversion between these systems requires $S = s + 1$ and $E = e$ for intervals that describe the same run of elements. In human genome analysis, Browser Extensible Data (BED) uses $0$-based half-open coordinates, Variant Call Format (VCF) uses $1$-based inclusive single-position sites for single-nucleotide variants, Sequence Alignment/Map (SAM) and Binary Alignment/Map (BAM) use $1$-based inclusive leftmost positions and the Concise Idiosyncratic Gapped Alignment Report (CIGAR) string to encode alignment spans, and General Feature Format/Gene Transfer Format (GFF/GTF) use $1$-based inclusive intervals. Human Genome Variation Society (HGVS) nomenclature expresses transcript-relative coordinates as $1$-based inclusive indices along complementary DNA (cDNA).\n\nConsider a plus-strand exon on chromosome $7$ that spans the $0$-based half-open interval $[55049999, 55050003)$, which corresponds to the $1$-based inclusive interval $[55050000, 55050003]$ and thus contains $4$ bases. A single-nucleotide variant is reported in VCF at chromosome $7$, position $55050003$ (that is, the last base of the exon) with reference allele $\\text{C}$ and alternate allele $\\text{T}$.\n\nA downstream pipeline attempts to perform interval overlap queries between variants and BED exons by converting each VCF single-nucleotide variant at $1$-based position $p$ into a $0$-based half-open interval but mistakenly maps it to $[p, p+1)$, rather than the mathematically correct $[p-1, p)$. The same mistaken mapping is also used internally to assign transcript-relative HGVS cDNA positions. Separately, a different team exports BED exon intervals to GFF without applying any coordinate transformation.\n\nBased only on the core definitions above and the scenario described, which of the following statements are correct? Select all that apply.\n\nA. Under the mistaken mapping $[p, p+1)$, the single-nucleotide variant at chromosome $7$ position $55050003$ will be classified as intronic (i.e., outside the exon) by the overlap query, even though it truly lies within the exon.\n\nB. Under the mistaken mapping $[p, p+1)$, a single-nucleotide variant at the first base of a plus-strand exon of length at least $2$ bases will still be classified as exonic by the overlap query.\n\nC. If the same mistaken mapping $[p, p+1)$ is used to compute Human Genome Variation Society (HGVS) cDNA indices, then for single-nucleotide variants within exons (not at transcript starts), the reported cDNA coordinate will be shifted upward by $+1$ relative to the true coordinate.\n\nD. When computing per-base coverage from Sequence Alignment/Map (SAM) or Binary Alignment/Map (BAM) alignments, treating $1$-based inclusive leftmost positions as if they were $0$-based half-open starts will increase the per-base depth globally by $1$ at every genomic position.\n\nE. For plus-strand exons, failing to convert Browser Extensible Data (BED) intervals $[s,e)$ to General Feature Format (GFF) $[S,E]$ by setting $S = s+1$ and $E = e$ will shift the reported $5'$ exon boundary downstream by $+1$ base while leaving the $3'$ boundary unchanged.\n\nF. For deletions in Variant Call Format (VCF) with reference allele length $L  1$ at genomic position $p$, the mathematically correct $0$-based half-open interval to test for overlap is $[p-1, p-1+L)$; under the mistaken mapping $[p, p+L)$, the deletion window is shifted right by $+1$ base, which can alter normalization and left-alignment in repetitive sequence contexts.",
            "solution": "### Option-by-Option Analysis\n\n**A. Under the mistaken mapping $[p, p+1)$, the single-nucleotide variant at chromosome $7$ position $55050003$ will be classified as intronic (i.e., outside the exon) by the overlap query, even though it truly lies within the exon.**\n\n*   **Exon Interval:** The exon is given in BED format, which is $0$-based half-open. The interval is $I_{exon} = [55049999, 55050003)$. This interval includes all genomic indices $x$ such that $55049999 \\leq x  55050003$.\n*   **SNV Position:** The SNV is at the $1$-based position $p = 55050003$.\n*   **Truth Check:** The correct $0$-based interval for this single-nucleotide position is $[p-1, p) = [55050003-1, 55050003) = [55050002, 55050003)$. The index $55050002$ satisfies $55049999 \\leq 55050002  55050003$, so the variant truly lies within the exon.\n*   **Mistaken Mapping:** The variant is mistakenly mapped to the $0$-based interval $I_{SNV, mistaken} = [p, p+1) = [55050003, 55050004)$.\n*   **Overlap Query:** We test if $I_{exon}$ and $I_{SNV, mistaken}$ overlap. An overlap exists if their intersection is non-empty. The interval $I_{exon}$ contains indices up to, but not including, $55050003$. The interval $I_{SNV, mistaken}$ contains indices starting from $55050003$. They are adjacent but do not share any common indices. Their intersection is the empty set.\n*   **Conclusion:** Because there is no overlap, the pipeline will classify the variant as being outside the exon. If the region adjacent to the exon is an intron, it would be classified as intronic. The statement is therefore correct.\n\n**Verdict: Correct**\n\n**B. Under the mistaken mapping $[p, p+1)$, a single-nucleotide variant at the first base of a plus-strand exon of length at least $2$ bases will still be classified as exonic by the overlap query.**\n\n*   **Exon Interval:** Let the exon be described by the $0$-based interval $[s, e)$, with length $L = e-s \\geq 2$.\n*   **SNV Position:** The first base of the exon is at $0$-based index $s$. Its corresponding $1$-based position is $p = s+1$.\n*   **Mistaken Mapping:** The SNV at $p = s+1$ is mistakenly mapped to the $0$-based interval $I_{SNV, mistaken} = [p, p+1) = [s+1, s+2)$. This interval represents the base at index $s+1$.\n*   **Overlap Query:** We test if $I_{exon} = [s, e)$ overlaps with $I_{SNV, mistaken} = [s+1, s+2)$. The exon interval contains indices $s, s+1, \\dots, e-1$. Since the length $L=e-s \\geq 2$, we know that $e \\geq s+2$. This guarantees that the index $s+1$ is within the exon interval $[s,e)$. The interval $[s+1, s+2)$ representing the mistaken SNV location is a sub-interval of $[s,e)$ (since $s  s+1$ and $s+2 \\leq e$). Thus, the intersection is non-empty (it is $[s+1, s+2)$), and an overlap will be detected.\n*   **Conclusion:** The variant will be correctly classified as exonic. The statement is correct.\n\n**Verdict: Correct**\n\n**C. If the same mistaken mapping $[p, p+1)$ is used to compute Human Genome Variation Society (HGVS) cDNA indices, then for single-nucleotide variants within exons (not at transcript starts), the reported cDNA coordinate will be shifted upward by `+1` relative to the true coordinate.**\n\n*   **HGVS cDNA Position:** The `c.` coordinate is a $1$-based index into the spliced transcript sequence. It is calculated by summing the lengths of preceding exons and adding the $1$-based offset of the variant within its own exon.\n*   **Correct Calculation:** For a variant at $1$-based genomic position $p$, the correct $0$-based index is $p-1$. If this falls into an exon starting at $0$-based index $s_{exon}$, the $0$-based offset within the exon is $(p-1) - s_{exon}$. The $1$-based offset is $((p-1) - s_{exon}) + 1$.\n*   **Mistaken Calculation:** The mistaken mapping uses the interval $[p, p+1)$, effectively treating the $1$-based position $p$ as a $0$-based index. The mistaken $0$-based offset within the exon would be $p - s_{exon}$. The mistaken $1$-based offset is $(p - s_{exon}) + 1$.\n*   **Comparison:**\n    *   True coordinate contribution: `... + ((p-1) - s_exon + 1)`\n    *   Mistaken coordinate contribution: `... + (p - s_exon + 1)`\n    The difference is `(p - s_{exon} + 1) - ((p-1) - s_{exon} + 1) = p - (p-1) = 1$.\n*   **Conclusion:** The mistaken calculation introduces an error of $+1$. The reported cDNA coordinate will be shifted upward by $+1$ relative to the true coordinate. The statement is correct.\n\n**Verdict: Correct**\n\n**D. When computing per-base coverage from Sequence Alignment/Map (SAM) or Binary Alignment/Map (BAM) alignments, treating $1$-based inclusive leftmost positions as if they were $0$-based half-open starts will increase the per-base depth globally by $1$ at every genomic position.**\n\n*   **SAM/BAM Alignment:** An alignment starting at $1$-based position `POS` with read length `L` correctly covers the $1$-based interval $[POS, POS+L-1]$. This corresponds to the $0$-based interval $[POS-1, POS+L-1)$.\n*   **Mistaken Assumption:** The position `POS` is treated as a $0$-based start. This implies the alignment covers the $0$-based interval $[POS, POS+L)$.\n*   **Analysis:** Comparing the correct interval $[POS-1, POS+L-1)$ with the mistaken interval $[POS, POS+L)$, we see the mistaken interval is shifted one base to the right (downstream). For each read, the coverage contribution is shifted. The base at position $POS-1$ loses a count, while the base at position $POS+L-1$ gains a count. The total coverage integrated over the genome remains constant. This is a redistribution of coverage, not a uniform increase. The coverage at a specific position `x` might increase, decrease, or stay the same, depending on the number of reads starting at `x` and `x+1`.\n*   **Conclusion:** The statement that per-base depth increases globally by $1$ is incorrect.\n\n**Verdict: Incorrect**\n\n**E. For plus-strand exons, failing to convert Browser Extensible Data (BED) intervals $[s,e)$ to General Feature Format (GFF) $[S,E]$ by setting $S = s+1$ and $E = e$ will shift the reported $5'$ exon boundary downstream by `+1` base while leaving the $3'$ boundary unchanged.**\n\n*   **Correct Conversion:** A BED ($0$-based) interval $[s,e)$ should be converted to a GFF ($1$-based) interval $[S,E]$ where $S = s+1$ and $E = e$.\n*   **Mistaken Conversion:** The BED interval $[s,e)$ is directly written as a GFF interval `[s,e]`.\n*   **Boundary Analysis (Plus Strand):**\n    *   **5' Boundary:** The true 5' boundary is at the start of the interval. In $1$-based coordinates, this is position $S = s+1$. The mistaken GFF reports the 5' boundary as position $s$. The difference is $s - (s+1) = -1$. A shift from $s+1$ to $s$ is an upstream shift (towards smaller coordinates), not a downstream shift.\n    *   **3' Boundary:** The true 3' boundary is at the end of the interval. In $1$-based coordinates, this is position $E=e$. The mistaken GFF reports the 3' boundary as position $e$. This boundary is unchanged.\n*   **Conclusion:** While the 3' boundary is indeed unchanged, the 5' boundary is shifted upstream by $1$, not downstream by $1$. The statement is therefore incorrect.\n\n**Verdict: Incorrect**\n\n**F. For deletions in Variant Call Format (VCF) with reference allele length $L  1$ at genomic position $p$, the mathematically correct $0$-based half-open interval to test for overlap is $[p-1, p-1+L)$; under the mistaken mapping $[p, p+L)$, the deletion window is shifted right by `+1` base, which can alter normalization and left-alignment in repetitive sequence contexts.**\n\n*   **VCF Deletion Span:** A variant at $1$-based position $p$ with a reference allele of length $L$ affects the genomic region corresponding to that allele. This region is the $1$-based, inclusive interval $[p, p+L-1]$.\n*   **Correct 0-based Interval:** Using the conversion rule ($s = S-1, e = E$), the $1$-based interval $[S,E] = [p, p+L-1]$ converts to the $0$-based half-open interval $[s,e) = [p-1, p+L-1)$. The statement gives the interval as $[p-1, p-1+L)$, which is algebraically identical to $[p-1, p+L-1)$. The first part of the statement is correct.\n*   **Mistaken Mapping:** The problem proposes a mistaken mapping analogy for deletions, `[p, p+L)`.\n*   **Shift Analysis:** Comparing the start of the correct interval, $p-1$, with the start of the mistaken interval, $p$, we see a shift of $p - (p-1) = +1$. Comparing the ends, $(p+L-1)$ and $(p+L)$, we see the exclusive end of the mistaken interval is also shifted by $+1$. Thus, the entire window is shifted right (downstream) by $1$ base. The second part of the statement is correct.\n*   **Consequence Analysis:** Variant normalization (including left-alignment) is a critical process to ensure canonical, unambiguous representation of indels, especially in repetitive sequences. This process relies on the precise genomic coordinates of the variant. An incorrect coordinate system that shifts the variant's apparent location by even one base will disrupt normalization algorithms, potentially leading to redundant variant calls or incorrect comparisons between datasets. The described consequence is accurate and significant.\n*   **Conclusion:** All parts of the statement are correct.\n\n**Verdict: Correct**",
            "answer": "$$\\boxed{ABCF}$$"
        }
    ]
}