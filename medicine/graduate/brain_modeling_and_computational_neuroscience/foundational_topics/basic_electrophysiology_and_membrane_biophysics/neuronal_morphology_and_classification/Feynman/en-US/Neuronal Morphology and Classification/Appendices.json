{
    "hands_on_practices": [
        {
            "introduction": "The intricate paths of axons and dendrites can be described using fundamental geometric measures. Tortuosity, a dimensionless and scale-invariant ratio, quantifies how much a neuronal process deviates from a straight line. This exercise provides direct practice in applying this core metric to a hypothetical dataset of axonal segments, classifying them and performing a weighted analysis of their geometry .",
            "id": "4004783",
            "problem": "A core morphometric for axonal geometry is tortuosity, defined from first principles of curve geometry and the triangle inequality. Consider an axon segment represented by a spatial curve with total path length $\\ell$ and end-to-end Euclidean distance $d$. The tortuosity is defined as the dimensionless ratio $\\tau=\\ell/d$. Because any curve length between two points is at least as large as the straight-line distance between them, the triangle inequality implies $\\ell \\ge d$, hence $\\tau \\ge 1$. This dimensionless property is invariant under uniform spatial scaling, making it appropriate for comparing axons of different sizes.\n\nYou are given measurements for $N=7$ axonal segments, each with total path length $\\ell$ and end-to-end distance $d$ in micrometers ($\\mu\\mathrm{m}$):\n- Segment $1$: $\\ell=820\\,\\mu\\mathrm{m}$, $d=800\\,\\mu\\mathrm{m}$.\n- Segment $2$: $\\ell=1200\\,\\mu\\mathrm{m}$, $d=900\\,\\mu\\mathrm{m}$.\n- Segment $3$: $\\ell=450\\,\\mu\\mathrm{m}$, $d=440\\,\\mu\\mathrm{m}$.\n- Segment $4$: $\\ell=2000\\,\\mu\\mathrm{m}$, $d=1500\\,\\mu\\mathrm{m}$.\n- Segment $5$: $\\ell=600\\,\\mu\\mathrm{m}$, $d=590\\,\\mu\\mathrm{m}$.\n- Segment $6$: $\\ell=1300\\,\\mu\\mathrm{m}$, $d=1000\\,\\mu\\mathrm{m}$.\n- Segment $7$: $\\ell=950\\,\\mu\\mathrm{m}$, $d=900\\,\\mu\\mathrm{m}$.\n\nUsing the tortuosity definition $\\tau=\\ell/d$, compute $\\tau$ for each segment and classify each segment as meandering if $\\tau > \\tau_{\\mathrm{th}}$ and straight otherwise, where the threshold is $\\tau_{\\mathrm{th}}=1.2$. From these classifications, compute the length-weighted fraction of total axonal path length that is meandering, defined as the ratio of the total $\\ell$ contributed by segments classified as meandering to the total $\\ell$ across all segments. Express your final result as a decimal (no units) and round to $4$ significant figures.",
            "solution": "The problem requires the computation of the length-weighted fraction of total axonal path length classified as meandering. The analysis proceeds in three stages: first, calculating the tortuosity for each axonal segment; second, classifying each segment based on a given threshold; and third, computing the required fraction from the classified segments.\n\nThe tortuosity, $\\tau$, is defined as the ratio of the total path length, $\\ell$, to the end-to-end Euclidean distance, $d$:\n$$\n\\tau = \\frac{\\ell}{d}\n$$\nWe are given data for $N=7$ axonal segments, indexed by $i \\in \\{1, 2, 3, 4, 5, 6, 7\\}$. For each segment $i$, we have a pair of measurements $(\\ell_i, d_i)$.\n\nThe data provided are:\n- Segment $1$: $\\ell_1=820\\,\\mu\\mathrm{m}$, $d_1=800\\,\\mu\\mathrm{m}$\n- Segment $2$: $\\ell_2=1200\\,\\mu\\mathrm{m}$, $d_2=900\\,\\mu\\mathrm{m}$\n- Segment $3$: $\\ell_3=450\\,\\mu\\mathrm{m}$, $d_3=440\\,\\mu\\mathrm{m}$\n- Segment $4$: $\\ell_4=2000\\,\\mu\\mathrm{m}$, $d_4=1500\\,\\mu\\mathrm{m}$\n- Segment $5$: $\\ell_5=600\\,\\mu\\mathrm{m}$, $d_5=590\\,\\mu\\mathrm{m}$\n- Segment $6$: $\\ell_6=1300\\,\\mu\\mathrm{m}$, $d_6=1000\\,\\mu\\mathrm{m}$\n- Segment $7$: $\\ell_7=950\\,\\mu\\mathrm{m}$, $d_7=900\\,\\mu\\mathrm{m}$\n\nFirst, we compute the tortuosity $\\tau_i$ for each segment $i$:\n$$\n\\tau_1 = \\frac{\\ell_1}{d_1} = \\frac{820}{800} = 1.025\n$$\n$$\n\\tau_2 = \\frac{\\ell_2}{d_2} = \\frac{1200}{900} = \\frac{4}{3} \\approx 1.333...\n$$\n$$\n\\tau_3 = \\frac{\\ell_3}{d_3} = \\frac{450}{440} = \\frac{45}{44} \\approx 1.0227...\n$$\n$$\n\\tau_4 = \\frac{\\ell_4}{d_4} = \\frac{2000}{1500} = \\frac{4}{3} \\approx 1.333...\n$$\n$$\n\\tau_5 = \\frac{\\ell_5}{d_5} = \\frac{600}{590} = \\frac{60}{59} \\approx 1.0169...\n$$\n$$\n\\tau_6 = \\frac{\\ell_6}{d_6} = \\frac{1300}{1000} = 1.3\n$$\n$$\n\\tau_7 = \\frac{\\ell_7}{d_7} = \\frac{950}{900} = \\frac{19}{18} \\approx 1.055...\n$$\n\nNext, we classify each segment as 'meandering' if its tortuosity $\\tau_i$ is greater than the threshold $\\tau_{\\mathrm{th}} = 1.2$, and 'straight' otherwise.\n- Segment $1$: $\\tau_1 = 1.025 \\le 1.2 \\implies$ Straight\n- Segment $2$: $\\tau_2 \\approx 1.333... > 1.2 \\implies$ Meandering\n- Segment $3$: $\\tau_3 \\approx 1.0227... \\le 1.2 \\implies$ Straight\n- Segment $4$: $\\tau_4 \\approx 1.333... > 1.2 \\implies$ Meandering\n- Segment $5$: $\\tau_5 \\approx 1.0169... \\le 1.2 \\implies$ Straight\n- Segment $6$: $\\tau_6 = 1.3 > 1.2 \\implies$ Meandering\n- Segment $7$: $\\tau_7 \\approx 1.055... \\le 1.2 \\implies$ Straight\n\nThe set of indices corresponding to meandering segments is $M = \\{2, 4, 6\\}$.\n\nWe are asked to compute the length-weighted fraction of total axonal path length that is meandering, which we denote as $F$. This fraction is the ratio of the sum of the lengths of the meandering segments to the sum of the lengths of all segments.\n$$\nF = \\frac{\\sum_{i \\in M} \\ell_i}{\\sum_{i=1}^{7} \\ell_i}\n$$\n\nFirst, we calculate the total path length of the meandering segments, $L_{\\mathrm{meander}}$:\n$$\nL_{\\mathrm{meander}} = \\ell_2 + \\ell_4 + \\ell_6 = 1200 + 2000 + 1300 = 4500\\,\\mu\\mathrm{m}\n$$\n\nNext, we calculate the total path length across all segments, $L_{\\mathrm{total}}$:\n$$\nL_{\\mathrm{total}} = \\sum_{i=1}^{7} \\ell_i = 820 + 1200 + 450 + 2000 + 600 + 1300 + 950 = 7320\\,\\mu\\mathrm{m}\n$$\n\nFinally, we compute the fraction $F$:\n$$\nF = \\frac{L_{\\mathrm{meander}}}{L_{\\mathrm{total}}} = \\frac{4500}{7320} = \\frac{450}{732} = \\frac{225}{366} = \\frac{75}{122}\n$$\n\nTo express this as a decimal, we perform the division:\n$$\nF \\approx 0.614754098...\n$$\n\nThe problem requires the result to be rounded to $4$ significant figures. The fifth significant digit is $5$, so we round up the fourth digit.\n$$\nF \\approx 0.6148\n$$",
            "answer": "$$\n\\boxed{0.6148}\n$$"
        },
        {
            "introduction": "Moving beyond pure geometry, we now explore the deep connection between a neuron's shape and its electrical function. The branching of dendrites is constrained by biophysical principles that ensure the efficient propagation of signals without reflection. This practice delves into Rall's celebrated $d^{3/2}$ power rule, challenging you to derive it from cable theory and then use it to quantify how well a dendritic bifurcation meets the ideal for impedance matching .",
            "id": "4508610",
            "problem": "In a passive dendritic tree modeled by cable theory with spatially homogeneous specific membrane resistivity $R_{m}$ and intracellular (axial) resistivity $R_{i}$, morphometric constraints at a bifurcation can be derived from the requirement that the branch point is impedance matched so that no reflections occur and electrotonic length is preserved across the junction. Starting from fundamental cable definitions for axial resistance per unit length and membrane resistance per unit length, derive the diameter relationship that enforces impedance matching at a dendritic bifurcation between a parent branch of diameter $d_{0}$ and two daughter branches of diameters $d_{1}$ and $d_{2}$, under the assumption that each branch can be treated locally as semi-infinite around the junction and membrane properties are uniform.\n\nYou are given a specific bifurcation measured in a cortical pyramidal neuron apical dendrite with parent diameter $d_{0} = 3.0\\,\\mu\\text{m}$ and daughter diameters $d_{1} = 2.5\\,\\mu\\text{m}$ and $d_{2} = 1.2\\,\\mu\\text{m}$. Using your derived relationship, compute the absolute fractional deviation from the exact impedance-matching condition, defined as\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})},$$\nwhere $f(\\cdot)$ is the diameter-dependent quantity implied by the impedance-matching condition you derived. Report $\\varepsilon$ as a decimal fraction (for example, report $0.05$ for a five percent deviation). Round your answer to four significant figures. Do not include any units or a percent sign in your final reported value.",
            "solution": "The problem requires the derivation of a diameter relationship for impedance matching at a dendritic bifurcation and the calculation of a fractional deviation for a specific case.\n\n### Part 1: Derivation of the Diameter Relationship\n\nThe problem is framed within the context of passive cable theory applied to a dendritic tree. We are given that the specific membrane resistivity, $R_m$ (units of $\\Omega \\cdot \\text{m}^2$), and the specific intracellular (axial) resistivity, $R_i$ (units of $\\Omega \\cdot \\text{m}$), are spatially homogeneous.\n\nFirst, we must define the relevant electrical properties for a cylindrical dendrite of diameter $d$.\nThe axial resistance per unit length, $r_a$, is the intracellular resistivity $R_i$ divided by the cross-sectional area $A = \\pi (d/2)^2$.\n$$r_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}$$\nThe membrane resistance for a unit length of the cylinder, $r_m$, is the specific membrane resistivity $R_m$ divided by the circumference of the cylinder, which is $\\pi d$.\n$$r_m = \\frac{R_m}{\\pi d}$$\nThe problem states that each branch at the bifurcation can be treated locally as a semi-infinite cable. For a semi-infinite passive cable, the DC or steady-state input resistance, $R_{in}$, is given by the characteristic resistance of the cable:\n$$R_{in} = \\sqrt{r_a r_m}$$\nSubstituting the expressions for $r_a$ and $r_m$ in terms of the diameter $d$:\n$$R_{in}(d) = \\sqrt{\\left(\\frac{4 R_i}{\\pi d^2}\\right) \\left(\\frac{R_m}{\\pi d}\\right)} = \\sqrt{\\frac{4 R_i R_m}{\\pi^2 d^3}} = \\frac{2}{\\pi} \\sqrt{\\frac{R_i R_m}{d^3}}$$\nThe condition for impedance matching at the bifurcation point is that there are no reflections. This is achieved when the input conductance of the parent branch is equal to the sum of the input conductances of the daughter branches. The input conductance, $G_{in}$, is the reciprocal of the input resistance, $G_{in} = 1/R_{in}$.\n$$G_{in}(d) = \\frac{1}{R_{in}(d)} = \\frac{\\pi}{2} \\sqrt{\\frac{d^3}{R_i R_m}}$$\nLet the parent branch have diameter $d_0$ and the two daughter branches have diameters $d_1$ and $d_2$. The impedance matching condition is:\n$$G_{in}(d_0) = G_{in}(d_1) + G_{in}(d_2)$$\nSubstituting the expression for $G_{in}(d)$:\n$$\\frac{\\pi}{2} \\sqrt{\\frac{d_0^3}{R_i R_m}} = \\frac{\\pi}{2} \\sqrt{\\frac{d_1^3}{R_i R_m}} + \\frac{\\pi}{2} \\sqrt{\\frac{d_2^3}{R_i R_m}}$$\nSince the problem states that membrane and intracellular properties ($R_m$ and $R_i$) are uniform across the tree, the constant term $\\frac{\\pi}{2\\sqrt{R_i R_m}}$ is common to all terms and can be cancelled. This yields the desired diameter relationship:\n$$\\sqrt{d_0^3} = \\sqrt{d_1^3} + \\sqrt{d_2^3}$$\nThis is commonly known as Rall's $3/2$ power rule, which can also be written as:\n$$d_0^{3/2} = d_1^{3/2} + d_2^{3/2}$$\n\n### Part 2: Calculation of the Fractional Deviation\n\nThe problem defines the absolute fractional deviation from the exact impedance-matching condition as:\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})}$$\nFrom our derivation, the diameter-dependent quantity $f(\\cdot)$ that determines the conductance is $d^{3/2}$. Therefore, $f(d_0) = d_0^{3/2}$ and the combined contribution from the daughters is $f(d_1, d_2) = d_1^{3/2} + d_2^{3/2}$. The formula for $\\varepsilon$ becomes:\n$$\\varepsilon = \\frac{\\left| (d_1^{3/2} + d_2^{3/2}) - d_0^{3/2} \\right|}{d_0^{3/2}} = \\left| \\frac{d_1^{3/2} + d_2^{3/2}}{d_0^{3/2}} - 1 \\right|$$\nWe are given the following diameters for a specific bifurcation:\n$d_0 = 3.0\\,\\mu\\text{m}$\n$d_1 = 2.5\\,\\mu\\text{m}$\n$d_2 = 1.2\\,\\mu\\text{m}$\n\nThe units of micrometers ($\\mu\\text{m}$) will cancel in the ratio, so we can use the numerical values directly.\nFirst, we compute the required terms:\nThe term for the parent branch is:\n$$f(d_0) = d_0^{3/2} = (3.0)^{3/2} \\approx 5.196152$$\nThe terms for the daughter branches are:\n$$d_1^{3/2} = (2.5)^{3/2} \\approx 3.952847$$\n$$d_2^{3/2} = (1.2)^{3/2} \\approx 1.314534$$\nThe sum for the daughter branches is:\n$$f(d_1, d_2) = d_1^{3/2} + d_2^{3/2} \\approx 3.952847 + 1.314534 = 5.267381$$\nNow, we substitute these values into the expression for $\\varepsilon$:\n$$\\varepsilon = \\frac{\\left| 5.267381 - 5.196152 \\right|}{5.196152} = \\frac{0.071229}{5.196152} \\approx 0.01370798$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\\varepsilon \\approx 0.01371$$\nThis value represents an absolute fractional deviation of approximately $1.371\\%$ from the ideal impedance-matching condition for the given dendritic bifurcation.",
            "answer": "$$\\boxed{0.01371}$$"
        },
        {
            "introduction": "To classify the vast diversity of neurons, we must create a quantitative \"fingerprint\" from their complex three-dimensional structures. This capstone practice scales up from single metrics to a comprehensive computational workflow, a cornerstone of modern neuroinformatics. You will implement an algorithm to extract a rich feature vector from a neuron's reconstruction, integrating concepts like path length, branching angles, and tapering into a format suitable for machine learning .",
            "id": "4004748",
            "problem": "You are provided with the three-dimensional coordinates of nodes from a neuron reconstruction, together with a parent pointer for each node and a radius at each node. The reconstruction defines a rooted tree in three-dimensional space, where each node $i$ has position $(x_i, y_i, z_i)$ in micrometers ($\\mu\\text{m}$), a radius $r_i$ in micrometers ($\\mu\\text{m}$), and a parent index $p_i$, with $p_i = -1$ indicating the root. The tree is assumed to be anatomically plausible: it is a directed acyclic graph with a single root, and each node other than the root has exactly one parent.\n\nYour task is to derive and implement from first principles the computation of a morphological feature vector suitable for downstream classification. Starting from basic Euclidean geometry and definitions for curves discretized by polylines, you must construct the following features:\n\n1. Branch angle histogram:\n- For any node $b$ that has at least two children, define the outgoing segment vector for a child $c$ as $\\mathbf{v}_c = \\mathbf{x}_c - \\mathbf{x}_b$, where $\\mathbf{x}_j = (x_j, y_j, z_j)$ is the Cartesian coordinate of node $j$.\n- For each unordered pair of children $(c_1, c_2)$, define the branch angle\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\, \\|\\mathbf{v}_{c_2}\\|}\\right),\n$$\nwith $\\theta$ measured in radians.\n- Accumulate all such angles across the entire tree and compute a normalized histogram with bin edges\n$$\nB_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi],\n$$\ninterpreted as half-open intervals $[b_k, b_{k+1})$ except for the last bin, which is $[b_6, b_7]$. The histogram must be normalized to sum to $1$. If there are no bifurcation angles, the histogram must be a vector of zeros of length $6$.\n\n2. Root-to-leaf path length distribution:\n- Define a leaf as any node with zero children.\n- For each leaf $t$, define the unique path $P(t)$ from the root to $t$ and its length\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|,\n$$\nwith $\\|\\cdot\\|$ the Euclidean norm and lengths measured in micrometers ($\\mu\\text{m}$).\n- Compute a normalized histogram over the set $\\{L(t)\\}$ using bin edges\n$$\nB_L = [0, 20, 40, 60, 80, 100],\n$$\nwith the same half-open interpretation $[b_k, b_{k+1})$ except the last bin $[b_5, b_6]$. The histogram must sum to $1$. If there are no leaves, the histogram must be a vector of zeros of length $5$.\n\n3. Curvature estimates:\n- For each root-to-leaf path with ordered points $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$, approximate the curvature at interior points $k = 1, \\dots, n-1$ by the discrete formula\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)},\n$$\nwith $\\kappa_k$ in radians per micrometer. Aggregate all curvature samples across all paths into a set $\\{\\kappa_k\\}$. Define the mean curvature\n$$\n\\bar{\\kappa} = \\frac{1}{M}\\sum_{m=1}^{M} \\kappa_m\n$$\nand the population standard deviation\n$$\n\\sigma_{\\kappa} = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} (\\kappa_m - \\bar{\\kappa})^2},\n$$\nwhere $M$ is the total number of curvature samples across all paths. If there are no interior points, set both $\\bar{\\kappa}$ and $\\sigma_{\\kappa}$ to $0$.\n\n4. Tapering profiles:\n- For each root-to-leaf path, let $s_k$ be the cumulative path length at node $k$ measured from the root along the path (in micrometers), and $r_k$ the radius at node $k$ (in micrometers).\n- For each path with at least $2$ points, compute the ordinary least squares slope $m$ of $r$ versus $s$ given by\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2},\n$$\nwhere $\\bar{s}$ and $\\bar{r}$ are the means of $\\{s_k\\}$ and $\\{r_k\\}$, respectively. If the denominator is zero or the path has fewer than $2$ points, define $m = 0$. Aggregate the slopes from all paths into a set $\\{m\\}$ and define the mean slope\n$$\n\\bar{m} = \\frac{1}{P}\\sum_{p=1}^{P} m_p\n$$\nand the population standard deviation\n$$\n\\sigma_m = \\sqrt{\\frac{1}{P}\\sum_{p=1}^{P} (m_p - \\bar{m})^2},\n$$\nwhere $P$ is the number of paths.\n\nConstruct the feature vector by concatenating, in order, the branch angle histogram (length $6$), the path length histogram (length $5$), the curvature mean and standard deviation (length $2$), and the taper slope mean and standard deviation (length $2$). The total feature vector length is $15$. All lengths must be in micrometers ($\\mu\\text{m}$); all angles must be in radians; curvature must be in radians per micrometer; taper slopes must be in micrometers per micrometer.\n\nTest Suite:\nUse the following four test cases, each defined by a list of nodes $(i, x_i, y_i, z_i, r_i, p_i)$, where all coordinates and radii are in micrometers ($\\mu\\text{m}$) and indices are integers. The parent index $p_i = -1$ denotes the root.\n\n- Test case $1$ (straight cable):\n  - $(0, 0, 0, 0, 2, -1)$\n  - $(1, 0, 0, 10, 2, 0)$\n  - $(2, 0, 0, 20, 2, 1)$\n  - $(3, 0, 0, 30, 2, 2)$\n\n- Test case $2$ (symmetric Y-shape):\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 0, 10, 2.5, 0)$\n  - $(2, 10, 0, 20, 2, 1)$\n  - $(3, -10, 0, 20, 2, 1)$\n\n- Test case $3$ (curved path with bifurcation):\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 5, 5, 2.8, 0)$\n  - $(2, 0, 10, 10, 2.6, 1)$\n  - $(3, 0, 15, 10, 2.4, 2)$\n  - $(4, 4, 22, 10, 2.2, 3)$\n  - $(5, -2, 22, 10, 2.2, 3)$\n\n- Test case $4$ (long branches):\n  - $(0, 0, 0, 0, 4, -1)$\n  - $(1, 0, 0, 20, 3.5, 0)$\n  - $(2, 0, 0, 40, 3.0, 1)$\n  - $(3, 10, 0, 55, 2.5, 2)$\n  - $(4, 20, 0, 70, 2.0, 3)$\n  - $(5, -10, 0, 55, 2.5, 2)$\n  - $(6, -20, 0, 70, 2.0, 5)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the feature vector (a list of $15$ floats) for one test case, aggregated into a single top-level list. For example: `[[f1,f2,...,f15],[g1,g2,...,g15],[h1,h2,...,h15],[k1,k2,...,k15]]`. Angles must be in radians; lengths must be in micrometers ($\\mu\\text{m}$); curvature must be in radians per micrometer; taper slopes must be in micrometers per micrometer. No additional text should be printed.\n\nThe implementation must be a complete, runnable program that uses only the specified runtime environment. All numerical answers must be floats. The algorithm must be robust to boundary cases including nodes with no bifurcations, paths with constant radius, and paths too short to define curvature or slope.",
            "solution": "The problem proposed is valid. It is scientifically grounded in the field of computational neuroscience, specifically in the morphometric analysis of neuron reconstructions. All provided definitions, formulas, and conditions are mathematically and algorithmically sound, well-posed, and free from ambiguity or contradiction. The task is to implement a feature extraction pipeline from first principles, which is a standard and verifiable procedure.\n\nThe solution is developed through a systematic, multi-step process. First, the input data, a list of node properties, is parsed into a graph data structure representing the neuron's tree-like morphology. Subsequently, four distinct sets of morphological features are computed based on this structure: the branch angle histogram, the root-to-leaf path length distribution, statistics of local curvature, and statistics of dendritic tapering. Finally, these features are concatenated into a single feature vector of dimension $15$.\n\n**1. Data Structuring**\n\nThe initial input is a list of nodes, each defined by its index $i$, Cartesian coordinates $\\mathbf{x}_i = (x_i, y_i, z_i)$, radius $r_i$, and parent index $p_i$. To facilitate traversal and neighborhood queries, we first transform this flat list into a more structured representation. A dictionary mapping each node index to its properties (coordinates, radius, parent) provides efficient lookups. A second dictionary, representing an adjacency list, is constructed to map each parent node index to a list of its children indices. This is achieved by iterating through all nodes and, for each node $i$ with parent $p_i \\neq -1$, appending $i$ to the list of children for $p_i$. The single node with $p_i = -1$ is identified as the root of the tree.\n\n**2. Feature Derivation and Computation**\n\nThe computation of the four feature groups proceeds as follows, adhering strictly to the provided definitions.\n\n**2.1. Branch Angle Histogram**\n\nThis feature quantifies the geometry of dendritic bifurcations.\n- A branch point, or bifurcation node $b$, is defined as any node with two or more children. We identify all such nodes by inspecting the previously constructed children-map.\n- For each bifurcation node $b$, we consider every unordered pair of its children, $(c_1, c_2)$.\n- The direction of the initial segment of each child branch is given by the vector from the parent to the child: $\\mathbf{v}_{c_1} = \\mathbf{x}_{c_1} - \\mathbf{x}_b$ and $\\mathbf{v}_{c_2} = \\mathbf{x}_{c_2} - \\mathbf{x}_b$.\n- The angle $\\theta$ between these two vectors is a measure of how widely the branches splay. It is computed from the definition of the dot product:\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\|\\mathbf{v}_{c_2}\\|}\\right)\n$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm. The argument of the $\\arccos$ function is clipped to the range $[-1, 1]$ to prevent numerical errors from floating-point inaccuracies.\n- All such angles from all bifurcation points in the tree are collected into a single list.\n- A histogram of these angles is computed using the specified bin edges $B_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$. This results in a $6$-dimensional vector of counts.\n- To make the feature independent of the neuron's size (i.e., the total number of bifurcations), the histogram is normalized by dividing each bin count by the total number of angles, ensuring the components sum to $1$. If no bifurcation points exist, a zero vector of length $6$ is returned, as per the problem specification.\n\n**2.2. Root-to-Leaf Path Length Distribution**\n\nThis feature captures the distribution of electrotonic distances from the soma (root) to the terminal tips of the dendrites.\n- A leaf node $t$ is defined as any node with zero children. We identify all such nodes.\n- For each leaf node $t$, we trace its unique path back to the root using the parent pointers. This yields the sequence of nodes $P(t) = (\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n=t)$ comprising the path.\n- The total length of this path, $L(t)$, is the sum of the Euclidean lengths of its constituent segments:\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|\n$$\n- The lengths of all such root-to-leaf paths are collected.\n- A normalized histogram is computed over these path lengths using the specified bin edges $B_L = [0, 20, 40, 60, 80, 100]$, resulting in a $5$-dimensional vector. Normalization is performed by dividing by the total number of leaves. If there are no leaves, a zero vector of length $5$ is returned.\n\n**2.3. Curvature Estimates**\n\nThis feature measures the tortuosity of dendritic paths.\n- We reuse the root-to-leaf paths identified in the previous step.\n- For each path with at least $3$ nodes, $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$, we can estimate curvature at the interior nodes $k = 1, \\dots, n-1$.\n- The discrete curvature $\\kappa_k$ at node $\\mathbf{x}_k$ is defined as the turning angle per unit of path length. The turning angle is the angle between the incoming vector $(\\mathbf{x}_k - \\mathbf{x}_{k-1})$ and the outgoing vector $(\\mathbf{x}_{k+1} - \\mathbf{x}_k)$. The path length unit is approximated by the average length of these two segments. This gives the formula:\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)}\n$$\n- A check is performed to ensure segment lengths are non-zero to avoid division by zero.\n- All valid curvature samples $\\kappa_k$ from all paths are aggregated.\n- From this collection of samples, we compute two summary statistics: the mean curvature $\\bar{\\kappa}$ and the population standard deviation $\\sigma_{\\kappa}$. If no interior points exist in the entire tree (i.e., all paths have fewer than $3$ nodes), both statistics are set to $0$.\n\n**2.4. Tapering Profiles**\n\nThis feature describes how the radius of dendritic branches changes with distance from the root, which is related to Rall's power law.\n- For each root-to-leaf path with at least $2$ nodes, we analyze the relationship between radius $r$ and cumulative path distance from the root $s$.\n- For a path with nodes $(_0, _1, ..., _n)$, the cumulative distance at node $k$ is $s_k = \\sum_{i=0}^{k-1} \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|$, with $s_0=0$. The corresponding radii are $\\{r_0, r_1, \\dots, r_n\\}$.\n- For each path, we compute the slope $m$ of the ordinary least squares linear regression of radius $r$ on distance $s$. The formula is given by the ratio of the covariance of $s$ and $r$ to the variance of $s$:\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2}\n$$\n- As specified, if the path has fewer than $2$ points or if the denominator is zero (i.e., all cumulative distances are the same, which implies zero-length segments), the slope $m$ is defined as $0$.\n- The slopes from all valid paths are collected.\n- The mean slope $\\bar{m}$ and the population standard deviation of slopes $\\sigma_m$ are computed. If there are no paths for which a slope can be computed, both statistics are set to $0$.\n\n**3. Feature Vector Assembly**\n\nThe final $15$-dimensional feature vector is constructed by concatenating the results of the above computations in the specified order:\n1.  Branch Angle Histogram (6 floats)\n2.  Path Length Histogram (5 floats)\n3.  Mean and Standard Deviation of Curvature (2 floats)\n4.  Mean and Standard Deviation of Taper Slope (2 floats)\n\nThis procedure provides a comprehensive, quantitative description of the neuron's morphology, suitable for use in machine learning models for cell type classification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef compute_features(nodes_data):\n    \"\"\"\n    Computes morphological features for a single neuron reconstruction.\n    \"\"\"\n    if not nodes_data:\n        return [0.0] * 15\n\n    # 1. Data Structuring\n    num_nodes = len(nodes_data)\n    nodes = {}\n    children = {i: [] for i in range(num_nodes)}\n    root_id = -1\n\n    node_list = sorted(nodes_data, key=lambda n: n[0])\n\n    for (node_id, x, y, z, r, p) in node_list:\n        nodes[node_id] = {\n            'pos': np.array([x, y, z], dtype=float),\n            'radius': float(r),\n            'parent': int(p)\n        }\n        if p != -1:\n            if p in children:\n                children[p].append(node_id)\n        else:\n            root_id = node_id\n\n    # 2. Feature Calculation\n\n    # 2.1. Branch Angle Histogram\n    branch_angles = []\n    bifurcation_node_ids = [i for i, c in children.items() if len(c) >= 2]\n    for b_id in bifurcation_node_ids:\n        b_pos = nodes[b_id]['pos']\n        for c1_id, c2_id in itertools.combinations(children[b_id], 2):\n            v1 = nodes[c1_id]['pos'] - b_pos\n            v2 = nodes[c2_id]['pos'] - b_pos\n            norm_v1 = np.linalg.norm(v1)\n            norm_v2 = np.linalg.norm(v2)\n            if norm_v1 > 0 and norm_v2 > 0:\n                cos_theta = np.dot(v1, v2) / (norm_v1 * norm_v2)\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                branch_angles.append(angle)\n\n    angle_bins = [0, np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi]\n    if branch_angles:\n        hist_angles, _ = np.histogram(branch_angles, bins=angle_bins)\n        hist_angles = hist_angles.astype(float) / len(branch_angles)\n    else:\n        hist_angles = np.zeros(len(angle_bins) - 1, dtype=float)\n\n    # 2.2, 2.3, 2.4: Path-based features\n    leaf_ids = [i for i in range(num_nodes) if not children[i]]\n    \n    path_lengths = []\n    curvatures = []\n    taper_slopes = []\n\n    for leaf_id in leaf_ids:\n        path = []\n        curr_id = leaf_id\n        while curr_id != -1:\n            path.append(curr_id)\n            curr_id = nodes[curr_id]['parent']\n        path.reverse()\n        \n        if not path:\n            continue\n        \n        # Path length and cumulative length calculation\n        total_length = 0.0\n        segment_lengths = []\n        if len(path) > 1:\n            for i in range(len(path) - 1):\n                p1_pos = nodes[path[i]]['pos']\n                p2_pos = nodes[path[i+1]]['pos']\n                length = np.linalg.norm(p2_pos - p1_pos)\n                segment_lengths.append(length)\n            total_length = sum(segment_lengths)\n        path_lengths.append(total_length)\n        \n        # Curvature calculation\n        if len(path) >= 3:\n            for i in range(1, len(path) - 1):\n                p_prev_pos = nodes[path[i-1]]['pos']\n                p_curr_pos = nodes[path[i]]['pos']\n                p_next_pos = nodes[path[i+1]]['pos']\n                \n                v_in = p_curr_pos - p_prev_pos\n                v_out = p_next_pos - p_curr_pos\n                \n                norm_in = np.linalg.norm(v_in)\n                norm_out = np.linalg.norm(v_out)\n                \n                if norm_in > 0 and norm_out > 0:\n                    cos_theta = np.dot(v_in, v_out) / (norm_in * norm_out)\n                    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                    angle = np.arccos(cos_theta)\n                    avg_len = (norm_in + norm_out) / 2.0\n                    curvatures.append(angle / avg_len)\n\n        # Tapering calculation\n        if len(path) >= 2:\n            s = np.concatenate(([0.0], np.cumsum(segment_lengths)))\n            r = np.array([nodes[node_id]['radius'] for node_id in path])\n            \n            s_mean = np.mean(s)\n            denominator = np.sum((s - s_mean)**2)\n            \n            if denominator > 0:\n                r_mean = np.mean(r)\n                numerator = np.sum((s - s_mean) * (r - r_mean))\n                slope = numerator / denominator\n                taper_slopes.append(slope)\n            else:\n                taper_slopes.append(0.0)\n        elif len(path) > 0:\n             # Path has only 1 node, so less than 2 points.\n             taper_slopes.append(0.0)\n\n    # Post-processing path features\n    length_bins = [0, 20, 40, 60, 80, 100]\n    if path_lengths:\n        hist_lengths, _ = np.histogram(path_lengths, bins=length_bins)\n        hist_lengths = hist_lengths.astype(float) / len(path_lengths)\n    else:\n        hist_lengths = np.zeros(len(length_bins) - 1, dtype=float)\n\n    if curvatures:\n        mean_kappa = np.mean(curvatures)\n        std_kappa = np.std(curvatures)\n    else:\n        mean_kappa, std_kappa = 0.0, 0.0\n\n    if taper_slopes:\n        mean_m = np.mean(taper_slopes)\n        std_m = np.std(taper_slopes)\n    else:\n        mean_m, std_m = 0.0, 0.0\n    \n    # 3. Assemble Feature Vector\n    feature_vector = np.concatenate([\n        hist_angles,\n        hist_lengths,\n        [mean_kappa, std_kappa],\n        [mean_m, std_m]\n    ])\n    \n    return feature_vector.tolist()\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (straight cable)\n        [\n            (0, 0, 0, 0, 2, -1),\n            (1, 0, 0, 10, 2, 0),\n            (2, 0, 0, 20, 2, 1),\n            (3, 0, 0, 30, 2, 2)\n        ],\n        # Test case 2 (symmetric Y-shape)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 0, 10, 2.5, 0),\n            (2, 10, 0, 20, 2, 1),\n            (3, -10, 0, 20, 2, 1)\n        ],\n        # Test case 3 (curved path with bifurcation)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 5, 5, 2.8, 0),\n            (2, 0, 10, 10, 2.6, 1),\n            (3, 0, 15, 10, 2.4, 2),\n            (4, 4, 22, 10, 2.2, 3),\n            (5, -2, 22, 10, 2.2, 3)\n        ],\n        # Test case 4 (long branches)\n        [\n            (0, 0, 0, 0, 4, -1),\n            (1, 0, 0, 20, 3.5, 0),\n            (2, 0, 0, 40, 3.0, 1),\n            (3, 10, 0, 55, 2.5, 2),\n            (4, 20, 0, 70, 2.0, 3),\n            (5, -10, 0, 55, 2.5, 2),\n            (6, -20, 0, 70, 2.0, 5)\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_features(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}