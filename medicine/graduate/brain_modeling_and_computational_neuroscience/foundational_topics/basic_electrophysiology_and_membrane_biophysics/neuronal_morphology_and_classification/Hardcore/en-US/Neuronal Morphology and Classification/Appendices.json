{
    "hands_on_practices": [
        {
            "introduction": "To meaningfully compare neurons based on their shape, we must first understand how that shape influences their electrical function. This foundational exercise guides you through a derivation from the first principles of passive cable theory to establish the concept of electrotonic distance, $L$. By expressing a physical length $\\ell$ in terms of the dendritic length constant $\\lambda$, you will see how this dimensionless coordinate provides a universal scale for analyzing signal propagation, regardless of a neuron's absolute physical size .",
            "id": "4004739",
            "problem": "A central task in dendritic cable theory is to compare neuronal morphologies across cells of different sizes by casting physical distances into a dimensionless, scale-invariant coordinate called electrotonic distance. Consider a single passive, linear dendritic branch modeled as a uniform, right circular cylinder of constant radius $a$, with specific membrane resistance $R_{m}$ measured in $\\Omega \\cdot \\mathrm{m}^{2}$ and intracellular (axial) resistivity $R_{i}$ measured in $\\Omega \\cdot \\mathrm{m}$. Assume the following physical and modeling conditions: the membrane properties $R_{m}$ and $R_{i}$ are spatially uniform along the branch, the membrane current is purely resistive under steady Direct Current (DC) conditions so capacitive currents are negligible, and the branch diameter does not taper. Let the physical path length along the branch be $\\ell$.\n\nStarting from first principles of current conservation and the geometric definitions of axial resistance and membrane conductance tied to the cylindrical morphology, derive a closed-form analytical expression for the electrotonic distance $L$ associated with the path length $\\ell$. Your derivation should make explicit how $L$ depends on $a$, $R_{m}$, $R_{i}$, and $\\ell$, and should state clearly the geometric assumption about whether $a$ denotes the radius (use $a$ as the radius for the final expression). Express the final answer as a single symbolic expression involving $a$, $R_{m}$, $R_{i}$, and $\\ell$. No rounding is required, and no units should be included in the final expression.",
            "solution": "Electrotonic distance is a dimensionless coordinate that rescales physical position along a cable to account for the balance between axial current flow and transmembrane current leak set by the cable’s geometry and material properties. We begin from current conservation and the definition of distributed axial resistance and membrane conductance for a cylindrical cable.\n\nLet $V(x)$ be the transmembrane potential along axial position $x$. Under steady Direct Current (DC) (i.e., no capacitive current), the membrane current per unit length is purely resistive and is given by\n$$\nI_{m}(x) \\;=\\; g_{m}^{*} \\, V(x),\n$$\nwhere $g_{m}^{*}$ is the membrane conductance per unit length. The intracellular axial current $I_{i}(x)$ relates to the axial gradient of voltage by Ohm’s law for a continuous medium,\n$$\nI_{i}(x) \\;=\\; -\\frac{1}{r_{i}^{*}} \\, \\frac{dV}{dx},\n$$\nwhere $r_{i}^{*}$ is the axial resistance per unit length.\n\nCurrent conservation (Kirchhoff’s current law in distributed form) imposes that the decrease of axial current along $x$ equals the membrane current leak,\n$$\n\\frac{d I_{i}}{dx} \\;+\\; I_{m} \\;=\\; 0.\n$$\nSubstituting the expressions for $I_{i}$ and $I_{m}$ yields\n$$\n\\frac{d}{dx}\\!\\left(-\\frac{1}{r_{i}^{*}} \\frac{dV}{dx}\\right) + g_{m}^{*} \\, V \\;=\\; 0.\n$$\nAssuming spatially uniform $r_{i}^{*}$ and $g_{m}^{*}$ along the branch, we obtain the steady-state cable equation\n$$\n\\frac{d^{2}V}{dx^{2}} \\;=\\; r_{i}^{*} \\, g_{m}^{*} \\, V.\n$$\nIt is standard to define the length constant $\\lambda$ by\n$$\n\\frac{1}{\\lambda^{2}} \\;=\\; r_{i}^{*} \\, g_{m}^{*}.\n$$\nWith this definition, the electrotonic coordinate $X$ is $X \\equiv x/\\lambda$, and the electrotonic distance $L$ associated with a physical path length $\\ell$ is $L = \\ell/\\lambda$. To obtain $L$ in terms of morphology and material parameters, we compute $r_{i}^{*}$ and $g_{m}^{*}$ from the cylinder geometry and the specific parameters.\n\nFor a right circular cylinder of radius $a$, the cross-sectional area is $\\pi a^{2}$ and the circumference is $2\\pi a$. The axial resistance of a segment of length $\\Delta x$ is $R_{i} \\, \\Delta x / (\\pi a^{2})$, so the axial resistance per unit length is\n$$\nr_{i}^{*} \\;=\\; \\frac{R_{i}}{\\pi a^{2}}.\n$$\nThe membrane conductance per unit area is $1/R_{m}$, and the membrane area per unit length is $2\\pi a$, hence the membrane conductance per unit length is\n$$\ng_{m}^{*} \\;=\\; \\frac{2\\pi a}{R_{m}}.\n$$\nTherefore,\n$$\nr_{i}^{*} \\, g_{m}^{*} \\;=\\; \\frac{R_{i}}{\\pi a^{2}} \\cdot \\frac{2\\pi a}{R_{m}} \\;=\\; \\frac{2 R_{i}}{a R_{m}}.\n$$\nThis yields the length constant\n$$\n\\lambda \\;=\\; \\sqrt{\\frac{1}{r_{i}^{*} g_{m}^{*}}} \\;=\\; \\sqrt{\\frac{a R_{m}}{2 R_{i}}}.\n$$\nFinally, the electrotonic distance associated with physical path length $\\ell$ is\n$$\nL \\;=\\; \\frac{\\ell}{\\lambda} \\;=\\; \\ell \\, \\sqrt{\\frac{2 R_{i}}{a R_{m}}}.\n$$\n\nWe have explicitly assumed that $a$ denotes the radius of the cylinder. If instead one defines $d$ as the diameter, then $a = d/2$ and the result for $L$ would be $L = \\ell \\, \\sqrt{ \\frac{4 R_{i}}{d R_{m}} }$. Adopting $a$ as the radius, the closed-form expression for the electrotonic distance is the expression above.",
            "answer": "$$\\boxed{\\ell \\sqrt{\\frac{2 R_{i}}{a R_{m}}}}$$"
        },
        {
            "introduction": "Neuronal branching patterns are not arbitrary; they often adhere to principles that optimize the flow of electrical signals. This practice delves into one of the most classic examples of this principle: Rall's $3/2$ power rule for dendritic bifurcations . By deriving this rule from the biophysical requirement of impedance matching, you will gain direct insight into how functional constraints shape neuronal architecture at a fundamental level.",
            "id": "4508610",
            "problem": "In a passive dendritic tree modeled by cable theory with spatially homogeneous specific membrane resistivity $R_{m}$ and intracellular (axial) resistivity $R_{i}$, morphometric constraints at a bifurcation can be derived from the requirement that the branch point is impedance matched so that no reflections occur and electrotonic length is preserved across the junction. Starting from fundamental cable definitions for axial resistance per unit length and membrane resistance per unit length, derive the diameter relationship that enforces impedance matching at a dendritic bifurcation between a parent branch of diameter $d_{0}$ and two daughter branches of diameters $d_{1}$ and $d_{2}$, under the assumption that each branch can be treated locally as semi-infinite around the junction and membrane properties are uniform.\n\nYou are given a specific bifurcation measured in a cortical pyramidal neuron apical dendrite with parent diameter $d_{0} = 3.0\\,\\mu\\text{m}$ and daughter diameters $d_{1} = 2.5\\,\\mu\\text{m}$ and $d_{2} = 1.2\\,\\mu\\text{m}$. Using your derived relationship, compute the absolute fractional deviation from the exact impedance-matching condition, defined as\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})},$$\nwhere $f(\\cdot)$ is the diameter-dependent quantity implied by the impedance-matching condition you derived. Report $\\varepsilon$ as a decimal fraction (for example, report $0.05$ for a five percent deviation). Round your answer to four significant figures. Do not include any units or a percent sign in your final reported value.",
            "solution": "The problem requires the derivation of a diameter relationship for impedance matching at a dendritic bifurcation and the calculation of a fractional deviation for a specific case.\n\n### Part 1: Derivation of the Diameter Relationship\n\nThe problem is framed within the context of passive cable theory applied to a dendritic tree. We are given that the specific membrane resistivity, $R_m$ (units of $\\Omega \\cdot \\text{m}^2$), and the specific intracellular (axial) resistivity, $R_i$ (units of $\\Omega \\cdot \\text{m}$), are spatially homogeneous.\n\nFirst, we must define the relevant electrical properties for a cylindrical dendrite of diameter $d$.\nThe axial resistance per unit length, $r_a$, is the intracellular resistivity $R_i$ divided by the cross-sectional area $A = \\pi (d/2)^2$.\n$$r_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}$$\nThe membrane resistance for a unit length of the cylinder, $r_m$, is the specific membrane resistivity $R_m$ divided by the circumference of the cylinder, which is $\\pi d$.\n$$r_m = \\frac{R_m}{\\pi d}$$\nThe problem states that each branch at the bifurcation can be treated locally as a semi-infinite cable. For a semi-infinite passive cable, the DC or steady-state input resistance, $R_{in}$, is given by the characteristic resistance of the cable:\n$$R_{in} = \\sqrt{r_a r_m}$$\nSubstituting the expressions for $r_a$ and $r_m$ in terms of the diameter $d$:\n$$R_{in}(d) = \\sqrt{\\left(\\frac{4 R_i}{\\pi d^2}\\right) \\left(\\frac{R_m}{\\pi d}\\right)} = \\sqrt{\\frac{4 R_i R_m}{\\pi^2 d^3}} = \\frac{2}{\\pi} \\sqrt{\\frac{R_i R_m}{d^3}}$$\nThe condition for impedance matching at the bifurcation point is that there are no reflections. This is achieved when the input conductance of the parent branch is equal to the sum of the input conductances of the daughter branches. The input conductance, $G_{in}$, is the reciprocal of the input resistance, $G_{in} = 1/R_{in}$.\n$$G_{in}(d) = \\frac{1}{R_{in}(d)} = \\frac{\\pi}{2} \\sqrt{\\frac{d^3}{R_i R_m}}$$\nLet the parent branch have diameter $d_0$ and the two daughter branches have diameters $d_1$ and $d_2$. The impedance matching condition is:\n$$G_{in}(d_0) = G_{in}(d_1) + G_{in}(d_2)$$\nSubstituting the expression for $G_{in}(d)$:\n$$\\frac{\\pi}{2} \\sqrt{\\frac{d_0^3}{R_i R_m}} = \\frac{\\pi}{2} \\sqrt{\\frac{d_1^3}{R_i R_m}} + \\frac{\\pi}{2} \\sqrt{\\frac{d_2^3}{R_i R_m}}$$\nSince the problem states that membrane and intracellular properties ($R_m$ and $R_i$) are uniform across the tree, the constant term $\\frac{\\pi}{2\\sqrt{R_i R_m}}$ is common to all terms and can be cancelled. This yields the desired diameter relationship:\n$$\\sqrt{d_0^3} = \\sqrt{d_1^3} + \\sqrt{d_2^3}$$\nThis is commonly known as Rall's $3/2$ power rule, which can also be written as:\n$$d_0^{3/2} = d_1^{3/2} + d_2^{3/2}$$\n\n### Part 2: Calculation of the Fractional Deviation\n\nThe problem defines the absolute fractional deviation from the exact impedance-matching condition as:\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})}$$\nFrom our derivation, the diameter-dependent quantity $f(\\cdot)$ that determines the conductance is $d^{3/2}$. Therefore, $f(d_0) = d_0^{3/2}$ and the combined contribution from the daughters is $f(d_1, d_2) = d_1^{3/2} + d_2^{3/2}$. The formula for $\\varepsilon$ becomes:\n$$\\varepsilon = \\frac{\\left| (d_1^{3/2} + d_2^{3/2}) - d_0^{3/2} \\right|}{d_0^{3/2}} = \\left| \\frac{d_1^{3/2} + d_2^{3/2}}{d_0^{3/2}} - 1 \\right|$$\nWe are given the following diameters for a specific bifurcation:\n$d_0 = 3.0\\,\\mu\\text{m}$\n$d_1 = 2.5\\,\\mu\\text{m}$\n$d_2 = 1.2\\,\\mu\\text{m}$\n\nThe units of micrometers ($\\mu\\text{m}$) will cancel in the ratio, so we can use the numerical values directly.\nFirst, we compute the required terms:\nThe term for the parent branch is:\n$$f(d_0) = d_0^{3/2} = (3.0)^{3/2} \\approx 5.196152$$\nThe terms for the daughter branches are:\n$$d_1^{3/2} = (2.5)^{3/2} \\approx 3.952847$$\n$$d_2^{3/2} = (1.2)^{3/2} \\approx 1.314534$$\nThe sum for the daughter branches is:\n$$f(d_1, d_2) = d_1^{3/2} + d_2^{3/2} \\approx 3.952847 + 1.314534 = 5.267381$$\nNow, we substitute these values into the expression for $\\varepsilon$:\n$$\\varepsilon = \\frac{\\left| 5.267381 - 5.196152 \\right|}{5.196152} = \\frac{0.071229}{5.196152} \\approx 0.01370798$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\\varepsilon \\approx 0.01371$$\nThis value represents an absolute fractional deviation of approximately $1.371\\%$ from the ideal impedance-matching condition for the given dendritic bifurcation.",
            "answer": "$$\\boxed{0.01371}$$"
        },
        {
            "introduction": "Modern neuroscience increasingly relies on computational methods to classify the vast diversity of neuronal cell types. This exercise transitions from theoretical principles to practical application by tasking you with building a comprehensive morphological feature vector from a neuron's 3D digital reconstruction . By implementing algorithms to quantify a range of geometric and structural properties, you will create a quantitative \"fingerprint\" of a neuron's shape, a crucial first step in any data-driven classification pipeline.",
            "id": "4004748",
            "problem": "You are provided with the three-dimensional coordinates of nodes from a neuron reconstruction, together with a parent pointer for each node and a radius at each node. The reconstruction defines a rooted tree in three-dimensional space, where each node $i$ has position $(x_i, y_i, z_i)$ in micrometers ($\\mu\\mathrm{m}$), a radius $r_i$ in micrometers ($\\mu\\mathrm{m}$), and a parent index $p_i$, with $p_i = -1$ indicating the root. The tree is assumed to be anatomically plausible: it is a directed acyclic graph with a single root, and each node other than the root has exactly one parent.\n\nYour task is to derive and implement from first principles the computation of a morphological feature vector suitable for downstream classification. Starting from basic Euclidean geometry and definitions for curves discretized by polylines, you must construct the following features:\n\n1. Branch angle histogram:\n- For any node $b$ that has at least two children, define the outgoing segment vector for a child $c$ as $\\mathbf{v}_c = \\mathbf{x}_c - \\mathbf{x}_b$, where $\\mathbf{x}_j = (x_j, y_j, z_j)$ is the Cartesian coordinate of node $j$.\n- For each unordered pair of children $(c_1, c_2)$, define the branch angle\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\, \\|\\mathbf{v}_{c_2}\\|}\\right),\n$$\nwith $\\theta$ measured in radians.\n- Accumulate all such angles across the entire tree and compute a normalized histogram with bin edges\n$$\nB_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi],\n$$\ninterpreted as half-open intervals $[b_k, b_{k+1})$ except for the last bin, which is $[b_6, b_7]$. The histogram must be normalized to sum to $1$. If there are no bifurcation angles, the histogram must be a vector of zeros of length $6$.\n\n2. Root-to-leaf path length distribution:\n- Define a leaf as any node with zero children.\n- For each leaf $t$, define the unique path $P(t)$ from the root to $t$ and its length\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|,\n$$\nwith $\\|\\cdot\\|$ the Euclidean norm and lengths measured in micrometers ($\\mu\\mathrm{m}$).\n- Compute a normalized histogram over the set $\\{L(t)\\}$ using bin edges\n$$\nB_L = [0, 20, 40, 60, 80, 100],\n$$\nwith the same half-open interpretation $[b_k, b_{k+1})$ except the last bin $[b_5, b_6]$. The histogram must sum to $1$. If there are no leaves, the histogram must be a vector of zeros of length $5$.\n\n3. Curvature estimates:\n- For each root-to-leaf path with ordered points $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$, approximate the curvature at interior points $k = 1, \\dots, n-1$ by the discrete formula\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)},\n$$\nwith $\\kappa_k$ in radians per micrometer. Aggregate all curvature samples across all paths into a set $\\{\\kappa_k\\}$. Define the mean curvature\n$$\n\\bar{\\kappa} = \\frac{1}{M}\\sum_{m=1}^{M} \\kappa_m\n$$\nand the population standard deviation\n$$\n\\sigma_{\\kappa} = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} (\\kappa_m - \\bar{\\kappa})^2},\n$$\nwhere $M$ is the total number of curvature samples across all paths. If there are no interior points, set both $\\bar{\\kappa}$ and $\\sigma_{\\kappa}$ to $0$.\n\n4. Tapering profiles:\n- For each root-to-leaf path, let $s_k$ be the cumulative path length at node $k$ measured from the root along the path (in micrometers), and $r_k$ the radius at node $k$ (in micrometers).\n- For each path with at least $2$ points, compute the ordinary least squares slope $m$ of $r$ versus $s$ given by\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2},\n$$\nwhere $\\bar{s}$ and $\\bar{r}$ are the means of $\\{s_k\\}$ and $\\{r_k\\}$, respectively. If the denominator is zero or the path has fewer than $2$ points, define $m = 0$. Aggregate the slopes from all paths into a set $\\{m\\}$ and define the mean slope\n$$\n\\bar{m} = \\frac{1}{P}\\sum_{p=1}^{P} m_p\n$$\nand the population standard deviation\n$$\n\\sigma_m = \\sqrt{\\frac{1}{P}\\sum_{p=1}^{P} (m_p - \\bar{m})^2},\n$$\nwhere $P$ is the number of paths.\n\nConstruct the feature vector by concatenating, in order, the branch angle histogram (length $6$), the path length histogram (length $5$), the curvature mean and standard deviation (length $2$), and the taper slope mean and standard deviation (length $2$). The total feature vector length is $15$. All lengths must be in micrometers ($\\mu\\mathrm{m}$); all angles must be in radians; curvature must be in radians per micrometer; taper slopes must be in micrometers per micrometer.\n\nTest Suite:\nUse the following four test cases, each defined by a list of nodes $(i, x_i, y_i, z_i, r_i, p_i)$, where all coordinates and radii are in micrometers ($\\mu\\mathrm{m}$) and indices are integers. The parent index $p_i = -1$ denotes the root.\n\n- Test case $1$ (straight cable):\n  - $(0, 0, 0, 0, 2, -1)$\n  - $(1, 0, 0, 10, 2, 0)$\n  - $(2, 0, 0, 20, 2, 1)$\n  - $(3, 0, 0, 30, 2, 2)$\n\n- Test case $2$ (symmetric Y-shape):\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 0, 10, 2.5, 0)$\n  - $(2, 10, 0, 20, 2, 1)$\n  - $(3, -10, 0, 20, 2, 1)$\n\n- Test case $3$ (curved path with bifurcation):\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 5, 5, 2.8, 0)$\n  - $(2, 0, 10, 10, 2.6, 1)$\n  - $(3, 0, 15, 10, 2.4, 2)$\n  - $(4, 4, 22, 10, 2.2, 3)$\n  - $(5, -2, 22, 10, 2.2, 3)$\n\n- Test case $4$ (long branches):\n  - $(0, 0, 0, 0, 4, -1)$\n  - $(1, 0, 0, 20, 3.5, 0)$\n  - $(2, 0, 0, 40, 3.0, 1)$\n  - $(3, 10, 0, 55, 2.5, 2)$\n  - $(4, 20, 0, 70, 2.0, 3)$\n  - $(5, -10, 0, 55, 2.5, 2)$\n  - $(6, -20, 0, 70, 2.0, 5)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the feature vector (a list of $15$ floats) for one test case, aggregated into a single top-level list. For example: \"[[f1,f2,...,f15],[g1,g2,...,g15],[h1,h2,...,h15],[k1,k2,...,k15]]\". Angles must be in radians; lengths must be in micrometers ($\\mu\\mathrm{m}$); curvature must be in radians per micrometer; taper slopes must be in micrometers per micrometer. No additional text should be printed.\n\nThe implementation must be a complete, runnable program that uses only the specified runtime environment. All numerical answers must be floats. The algorithm must be robust to boundary cases including nodes with no bifurcations, paths with constant radius, and paths too short to define curvature or slope.",
            "solution": "The problem proposed is valid. It is scientifically grounded in the field of computational neuroscience, specifically in the morphometric analysis of neuron reconstructions. All provided definitions, formulas, and conditions are mathematically and algorithmically sound, well-posed, and free from ambiguity or contradiction. The task is to implement a feature extraction pipeline from first principles, which is a standard and verifiable procedure.\n\nThe solution is developed through a systematic, multi-step process. First, the input data, a list of node properties, is parsed into a graph data structure representing the neuron's tree-like morphology. Subsequently, four distinct sets of morphological features are computed based on this structure: the branch angle histogram, the root-to-leaf path length distribution, statistics of local curvature, and statistics of dendritic tapering. Finally, these features are concatenated into a single feature vector of dimension $15$.\n\n**1. Data Structuring**\n\nThe initial input is a list of nodes, each defined by its index $i$, Cartesian coordinates $\\mathbf{x}_i = (x_i, y_i, z_i)$, radius $r_i$, and parent index $p_i$. To facilitate traversal and neighborhood queries, we first transform this flat list into a more structured representation. A dictionary mapping each node index to its properties (coordinates, radius, parent) provides efficient lookups. A second dictionary, representing an adjacency list, is constructed to map each parent node index to a list of its children indices. This is achieved by iterating through all nodes and, for each node $i$ with parent $p_i \\neq -1$, appending $i$ to the list of children for $p_i$. The single node with $p_i = -1$ is identified as the root of the tree.\n\n**2. Feature Derivation and Computation**\n\nThe computation of the four feature groups proceeds as follows, adhering strictly to the provided definitions.\n\n**2.1. Branch Angle Histogram**\n\nThis feature quantifies the geometry of dendritic bifurcations.\n- A branch point, or bifurcation node $b$, is defined as any node with two or more children. We identify all such nodes by inspecting the previously constructed children-map.\n- For each bifurcation node $b$, we consider every unordered pair of its children, $(c_1, c_2)$.\n- The direction of the initial segment of each child branch is given by the vector from the parent to the child: $\\mathbf{v}_{c_1} = \\mathbf{x}_{c_1} - \\mathbf{x}_b$ and $\\mathbf{v}_{c_2} = \\mathbf{x}_{c_2} - \\mathbf{x}_b$.\n- The angle $\\theta$ between these two vectors is a measure of how widely the branches splay. It is computed from the definition of the dot product:\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\|\\mathbf{v}_{c_2}\\|}\\right)\n$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm. The argument of the $\\arccos$ function is clipped to the range $[-1, 1]$ to prevent numerical errors from floating-point inaccuracies.\n- All such angles from all bifurcation points in the tree are collected into a single list.\n- A histogram of these angles is computed using the specified bin edges $B_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$. This results in a $6$-dimensional vector of counts.\n- To make the feature independent of the neuron's size (i.e., the total number of bifurcations), the histogram is normalized by dividing each bin count by the total number of angles, ensuring the components sum to $1$. If no bifurcation points exist, a zero vector of length $6$ is returned, as per the problem specification.\n\n**2.2. Root-to-Leaf Path Length Distribution**\n\nThis feature captures the distribution of electrotonic distances from the soma (root) to the terminal tips of the dendrites.\n- A leaf node $t$ is defined as any node with zero children. We identify all such nodes.\n- For each leaf node $t$, we trace its unique path back to the root using the parent pointers. This yields the sequence of nodes $P(t) = (\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n=t)$ comprising the path.\n- The total length of this path, $L(t)$, is the sum of the Euclidean lengths of its constituent segments:\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|\n$$\n- The lengths of all such root-to-leaf paths are collected.\n- A normalized histogram is computed over these path lengths using the specified bin edges $B_L = [0, 20, 40, 60, 80, 100]$, resulting in a $5$-dimensional vector. Normalization is performed by dividing by the total number of leaves. If there are no leaves, a zero vector of length $5$ is returned.\n\n**2.3. Curvature Estimates**\n\nThis feature measures the tortuosity of dendritic paths.\n- We reuse the root-to-leaf paths identified in the previous step.\n- For each path with at least $3$ nodes, $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$, we can estimate curvature at the interior nodes $k = 1, \\dots, n-1$.\n- The discrete curvature $\\kappa_k$ at node $\\mathbf{x}_k$ is defined as the turning angle per unit of path length. The turning angle is the angle between the incoming vector $(\\mathbf{x}_k - \\mathbf{x}_{k-1})$ and the outgoing vector $(\\mathbf{x}_{k+1} - \\mathbf{x}_k)$. The path length unit is approximated by the average length of these two segments. This gives the formula:\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)}\n$$\n- A check is performed to ensure segment lengths are non-zero to avoid division by zero.\n- All valid curvature samples $\\kappa_k$ from all paths are aggregated.\n- From this collection of samples, we compute two summary statistics: the mean curvature $\\bar{\\kappa}$ and the population standard deviation $\\sigma_{\\kappa}$. If no interior points exist in the entire tree (i.e., all paths have fewer than $3$ nodes), both statistics are set to $0$.\n\n**2.4. Tapering Profiles**\n\nThis feature describes how the radius of dendritic branches changes with distance from the root, which is related to Rall's power law.\n- For each root-to-leaf path with at least $2$ nodes, we analyze the relationship between radius $r$ and cumulative path distance from the root $s$.\n- For a path with nodes $(_0, _1, ..., _n)$, the cumulative distance at node $k$ is $s_k = \\sum_{i=0}^{k-1} \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|$, with $s_0=0$. The corresponding radii are $\\{r_0, r_1, \\dots, r_n\\}$.\n- For each path, we compute the slope $m$ of the ordinary least squares linear regression of radius $r$ on distance $s$. The formula is given by the ratio of the covariance of $s$ and $r$ to the variance of $s$:\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2}\n$$\n- As specified, if the path has fewer than $2$ points or if the denominator is zero (i.e., all cumulative distances are the same, which implies zero-length segments), the slope $m$ is defined as $0$.\n- The slopes from all valid paths are collected.\n- The mean slope $\\bar{m}$ and the population standard deviation of slopes $\\sigma_m$ are computed. If there are no paths for which a slope can be computed, both statistics are set to $0$.\n\n**3. Feature Vector Assembly**\n\nThe final $15$-dimensional feature vector is constructed by concatenating the results of the above computations in the specified order:\n1.  Branch Angle Histogram (6 floats)\n2.  Path Length Histogram (5 floats)\n3.  Mean and Standard Deviation of Curvature (2 floats)\n4.  Mean and Standard Deviation of Taper Slope (2 floats)\n\nThis procedure provides a comprehensive, quantitative description of the neuron's morphology, suitable for use in machine learning models for cell type classification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef compute_features(nodes_data):\n    \"\"\"\n    Computes morphological features for a single neuron reconstruction.\n    \"\"\"\n    if not nodes_data:\n        return [0.0] * 15\n\n    # 1. Data Structuring\n    num_nodes = len(nodes_data)\n    nodes = {}\n    children = {i: [] for i in range(num_nodes)}\n    root_id = -1\n\n    node_list = sorted(nodes_data, key=lambda n: n[0])\n\n    for (node_id, x, y, z, r, p) in node_list:\n        nodes[node_id] = {\n            'pos': np.array([x, y, z], dtype=float),\n            'radius': float(r),\n            'parent': int(p)\n        }\n        if p != -1:\n            if p in children:\n                children[p].append(node_id)\n        else:\n            root_id = node_id\n\n    # 2. Feature Calculation\n\n    # 2.1. Branch Angle Histogram\n    branch_angles = []\n    bifurcation_node_ids = [i for i, c in children.items() if len(c) >= 2]\n    for b_id in bifurcation_node_ids:\n        b_pos = nodes[b_id]['pos']\n        for c1_id, c2_id in itertools.combinations(children[b_id], 2):\n            v1 = nodes[c1_id]['pos'] - b_pos\n            v2 = nodes[c2_id]['pos'] - b_pos\n            norm_v1 = np.linalg.norm(v1)\n            norm_v2 = np.linalg.norm(v2)\n            if norm_v1 > 0 and norm_v2 > 0:\n                cos_theta = np.dot(v1, v2) / (norm_v1 * norm_v2)\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                branch_angles.append(angle)\n\n    angle_bins = [0, np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi]\n    if branch_angles:\n        hist_angles, _ = np.histogram(branch_angles, bins=angle_bins)\n        hist_angles = hist_angles.astype(float) / len(branch_angles)\n    else:\n        hist_angles = np.zeros(len(angle_bins) - 1, dtype=float)\n\n    # 2.2, 2.3, 2.4: Path-based features\n    leaf_ids = [i for i in range(num_nodes) if not children[i]]\n    \n    path_lengths = []\n    curvatures = []\n    taper_slopes = []\n\n    for leaf_id in leaf_ids:\n        path = []\n        curr_id = leaf_id\n        while curr_id != -1:\n            path.append(curr_id)\n            curr_id = nodes[curr_id]['parent']\n        path.reverse()\n        \n        if not path:\n            continue\n        \n        # Path length and cumulative length calculation\n        total_length = 0.0\n        segment_lengths = []\n        if len(path) > 1:\n            for i in range(len(path) - 1):\n                p1_pos = nodes[path[i]]['pos']\n                p2_pos = nodes[path[i+1]]['pos']\n                length = np.linalg.norm(p2_pos - p1_pos)\n                segment_lengths.append(length)\n            total_length = sum(segment_lengths)\n        path_lengths.append(total_length)\n        \n        # Curvature calculation\n        if len(path) >= 3:\n            for i in range(1, len(path) - 1):\n                p_prev_pos = nodes[path[i-1]]['pos']\n                p_curr_pos = nodes[path[i]]['pos']\n                p_next_pos = nodes[path[i+1]]['pos']\n                \n                v_in = p_curr_pos - p_prev_pos\n                v_out = p_next_pos - p_curr_pos\n                \n                norm_in = np.linalg.norm(v_in)\n                norm_out = np.linalg.norm(v_out)\n                \n                if norm_in > 0 and norm_out > 0:\n                    cos_theta = np.dot(v_in, v_out) / (norm_in * norm_out)\n                    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                    angle = np.arccos(cos_theta)\n                    avg_len = (norm_in + norm_out) / 2.0\n                    curvatures.append(angle / avg_len)\n\n        # Tapering calculation\n        if len(path) >= 2:\n            s = np.concatenate(([0.0], np.cumsum(segment_lengths)))\n            r = np.array([nodes[node_id]['radius'] for node_id in path])\n            \n            s_mean = np.mean(s)\n            denominator = np.sum((s - s_mean)**2)\n            \n            if denominator > 0:\n                r_mean = np.mean(r)\n                numerator = np.sum((s - s_mean) * (r - r_mean))\n                slope = numerator / denominator\n                taper_slopes.append(slope)\n            else:\n                taper_slopes.append(0.0)\n        elif len(path) > 0:\n             # Path has only 1 node, so less than 2 points.\n             taper_slopes.append(0.0)\n\n    # Post-processing path features\n    length_bins = [0, 20, 40, 60, 80, 100]\n    if path_lengths:\n        hist_lengths, _ = np.histogram(path_lengths, bins=length_bins)\n        hist_lengths = hist_lengths.astype(float) / len(path_lengths)\n    else:\n        hist_lengths = np.zeros(len(length_bins) - 1, dtype=float)\n\n    if curvatures:\n        mean_kappa = np.mean(curvatures)\n        std_kappa = np.std(curvatures)\n    else:\n        mean_kappa, std_kappa = 0.0, 0.0\n\n    if taper_slopes:\n        mean_m = np.mean(taper_slopes)\n        std_m = np.std(taper_slopes)\n    else:\n        mean_m, std_m = 0.0, 0.0\n    \n    # 3. Assemble Feature Vector\n    feature_vector = np.concatenate([\n        hist_angles,\n        hist_lengths,\n        [mean_kappa, std_kappa],\n        [mean_m, std_m]\n    ])\n    \n    return feature_vector.tolist()\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (straight cable)\n        [\n            (0, 0, 0, 0, 2, -1),\n            (1, 0, 0, 10, 2, 0),\n            (2, 0, 0, 20, 2, 1),\n            (3, 0, 0, 30, 2, 2)\n        ],\n        # Test case 2 (symmetric Y-shape)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 0, 10, 2.5, 0),\n            (2, 10, 0, 20, 2, 1),\n            (3, -10, 0, 20, 2, 1)\n        ],\n        # Test case 3 (curved path with bifurcation)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 5, 5, 2.8, 0),\n            (2, 0, 10, 10, 2.6, 1),\n            (3, 0, 15, 10, 2.4, 2),\n            (4, 4, 22, 10, 2.2, 3),\n            (5, -2, 22, 10, 2.2, 3)\n        ],\n        # Test case 4 (long branches)\n        [\n            (0, 0, 0, 0, 4, -1),\n            (1, 0, 0, 20, 3.5, 0),\n            (2, 0, 0, 40, 3.0, 1),\n            (3, 10, 0, 55, 2.5, 2),\n            (4, 20, 0, 70, 2.0, 3),\n            (5, -10, 0, 55, 2.5, 2),\n            (6, -20, 0, 70, 2.0, 5)\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_features(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}