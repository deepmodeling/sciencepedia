{
    "hands_on_practices": [
        {
            "introduction": "神经元在放电之前，其状态由亚阈值动力学控制。阈值电流（rheobase current）是推动神经元从静息状态转为放电所需的最小输入。本练习通过寻找静息态在数学上消失的点来探索这一转变，这个点在动力系统中对应于鞍结分岔（saddle-node bifurcation）。这是一项关于神经元兴奋性的基础分析，它将模型的数学结构与关键的生理学概念联系起来。",
            "id": "4029523",
            "problem": "考虑Izhikevich神经元模型，该模型使用以下常微分方程组描述膜电位动力学和一个恢复变量：\n$$\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I,$$\n$$\\frac{du}{dt} = a\\,(b\\,v - u),$$\n其尖峰发放和重置由尖峰后条件定义：当$v$达到阈值时，膜电位和恢复变量会发生重置 $v \\leftarrow c$ 和 $u \\leftarrow u + d$。假设注入电流 $I$ 为常数，并关注在任何尖峰重置之前连续动力学不动点的存在与消失。\n\n展现 I 型兴奋性（通过不变圆上的鞍节点（SNIC）分岔产生）的一组参数由下式给出：\n$$a = 0.02,\\quad b = 0.2,\\quad c = -65,\\quad d = 8.$$\n使用自治动力学系统中不动点的定义以及鞍节点分岔的必要条件（平衡点合并，伴随着简化平衡条件的判别式为零），计算基电流 $I_{\\text{rh}}$。此处基电流定义为使阈下动力学的静息不动点消失的最小恒定电流 $I$。以模型的归一化电流单位报告 $I_{\\text{rh}}$ 的精确值（无需单位转换）。无需四舍五入；请提供精确结果。",
            "solution": "该问题要求计算在特定参数集下Izhikevich神经元模型的基电流 $I_{\\text{rh}}$。基电流定义为使阈下动力学的不动点消失的最小恒定输入电流 $I$。这种消失是通过鞍节点分岔发生的。\n\nIzhikevich模型的动力学由以下常微分方程组描述：\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a\\,(b\\,v - u)\n$$\n与阈下动力学相关的参数为 $a = 0.02$ 和 $b = 0.2$。重置参数 $c = -65$ 和 $d = 8$ 不参与不动点的分析。\n\n系统的一个不动点或平衡点 $(v^*, u^*)$ 是一个时间导数为零的点。因此，我们必须求解以下代数方程组：\n$$\n\\frac{dv}{dt} = 0 \\implies 0.04\\,(v^*)^{2} + 5\\,v^* + 140 - u^* + I = 0\n$$\n$$\n\\frac{du}{dt} = 0 \\implies a\\,(b\\,v^* - u^*) = 0\n$$\n\n由第二个方程，因为参数 $a = 0.02 \\neq 0$，我们必然有：\n$$\nb\\,v^* - u^* = 0\n$$\n这意味着在任何不动点上，恢复变量 $u^*$ 是膜电位 $v^*$ 的线性函数：\n$$\nu^* = b\\,v^*\n$$\n该方程定义了系统的 $u$-零斜线。\n\n为了找到不动点处的 $v^*$ 值，我们将 $u^*$ 的表达式代入第一个方程（$v$-零斜线）：\n$$\n0.04\\,(v^*)^{2} + 5\\,v^* + 140 - (b\\,v^*) + I = 0\n$$\n合并包含 $v^*$ 的项，我们得到一个关于 $v^*$ 的一元二次方程：\n$$\n0.04\\,(v^*)^{2} + (5 - b)\\,v^* + (140 + I) = 0\n$$\n该二次方程的根对应于系统不动点的膜电位值。实根的数量，即不动点的数量，由该二次方程的判别式决定。一个标准形式为 $Ax^2+Bx+C=0$ 的二次方程，其判别式为 $\\Delta = B^2-4AC$。在我们的例子中，系数为：\n$$\nA = 0.04\n$$\n$$\nB = 5 - b\n$$\n$$\nC = 140 + I\n$$\n当 $\\Delta  0$ 时，系统有两个不同的不动点；当 $\\Delta = 0$ 时，有一个不动点；当 $\\Delta  0$ 时，没有实不动点。不动点的消失对应于从 $\\Delta  0$ 到 $\\Delta  0$ 的转变。定义鞍节点分岔的边界情况恰好在判别式为零时发生。\n$$\n\\Delta = (5 - b)^2 - 4(0.04)(140 + I) = 0\n$$\n我们需要找到满足此湮灭条件的基电流 $I_{\\text{rh}}$，即 $I$ 的值。现在我们可以代入给定的参数值 $b = 0.2$：\n$$\n(5 - 0.2)^2 - 4(0.04)(140 + I_{\\text{rh}}) = 0\n$$\n$$\n(4.8)^2 - 0.16(140 + I_{\\text{rh}}) = 0\n$$\n现在，我们计算平方并进行化简：\n$$\n23.04 - 0.16(140 + I_{\\text{rh}}) = 0\n$$\n重新整理方程以求解 $I_{\\text{rh}}$：\n$$\n23.04 = 0.16(140 + I_{\\text{rh}})\n$$\n两边同除以 $0.16$：\n$$\n\\frac{23.04}{0.16} = 140 + I_{\\text{rh}}\n$$\n除法结果为：\n$$\n144 = 140 + I_{\\text{rh}}\n$$\n最后，求解 $I_{\\text{rh}}$：\n$$\nI_{\\text{rh}} = 144 - 140 = 4\n$$\n因此，静息不动点通过鞍节点分岔消失时的基电流在模型的归一化电流单位下为 $4$。当 $I  4$ 时，系统有两个不动点（一个代表静息状态的稳定节点和一个鞍点）。当 $I  4$ 时，系统没有不动点，膜电位将（在阈下动力学的背景下）无界增长，从而导致尖峰的发放。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "Izhikevich模型的一个关键特点是它能够再现多样的放电模式。本练习要求您编写一个程序，模拟其中一种模式：具有适应性的规则放电（regular spiking）。通过实现一个数值积分器并计算脉冲间期（inter-spike intervals），我们可以直接观察和量化模型如何捕捉到这一重要的生物学现象。这个实践将静态的数学分析与神经元动态的、鲜活的行为联系起来。",
            "id": "4064812",
            "problem": "设计并实现一个程序，模拟处于规则脉冲（RS）状态下的 Izhikevich 脉冲神经元，并计算脉冲间间隔（ISI）和适应性比率。使用以下定义，这些是 Izhikevich 模型的基础。膜电位由 $v$ 表示（单位为 $\\mathrm{mV}$），恢复变量由 $u$ 表示（无量纲），外部施加的电流由 $I$ 表示（使用与模型一致的电流单位，使得 $v$ 的单位为 $\\mathrm{mV}$，时间单位为 $\\mathrm{ms}$）。Izhikevich 模型由以下常微分方程组（ODE）控制：\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I, \\quad \\frac{du}{dt} = a(bv - u),\n$$\n当膜电位达到脉冲阈值时，应用脉冲后重置条件：\n$$\n\\text{如果 } v \\ge 30 \\text{ mV}, \\text{ 则设置 } v \\leftarrow c \\text{ 且 } u \\leftarrow u + d.\n$$\n假设初始条件为 $v(0)=c$ 和 $u(0)=bv(0)$。使用时间步长为 $\\Delta t$（单位为 $\\mathrm{ms}$）的固定步长显式欧拉法进行模拟，并在每个时间步内通过线性插值实现脉冲事件检测：如果在一个步长内，$v$ 从下方穿过脉冲阈值，则通过对步长前后的 $v$ 值进行线性插值来估计脉冲时间 $t_{\\text{spike}}$（单位为 $\\mathrm{ms}$）。使用每个步长内的首次穿越，并立即在该步应用重置规则。\n\n将脉冲间间隔（ISI）定义为连续脉冲时间之间的差值，单位为毫秒。适应性比率定义为比值 $\\text{ISI}_1/\\text{ISI}_5$，其中 $\\text{ISI}_k$ 表示第 $k$ 个 ISI（按出现顺序）。如果在模拟窗口内发生的脉冲少于 6 个，则将适应性比率定义为 $\\mathrm{nan}$（非数字）。\n\n所有时间必须以 $\\mathrm{ms}$ 表示，电压以 $\\mathrm{mV}$ 表示，适应性比率为无量纲。您的程序必须计算以下测试套件的结果，并生成单行输出，其中包含每个测试用例的适应性比率，形式为用方括号括起来的逗号分隔列表，例如 `[ratio_1,ratio_2,ratio_3]`。将每个比率四舍五入到 $6$ 位小数。如果比率未定义，则在其位置输出 $\\mathrm{nan}$。\n\n测试套件（所有用例均使用 RS 参数）：\n- 规则脉冲（RS）参数：$(a,b,c,d) = (0.02,0.2,-65,8)$。\n- 脉冲阈值：$30 \\,\\mathrm{mV}$。\n\n用例：\n- 用例 A（正常路径）：恒定电流 $I=14$，总模拟时间 $T=1000 \\,\\mathrm{ms}$，时间步长 $\\Delta t = 0.1 \\,\\mathrm{ms}$。\n- 用例 B（低电流边界）：恒定电流 $I=5$，总模拟时间 $T=1000 \\,\\mathrm{ms}$，时间步长 $\\Delta t = 0.1 \\,\\mathrm{ms}$。\n- 用例 C（高电流与更小步长）：恒定电流 $I=30$，总模拟时间 $T=500 \\,\\mathrm{ms}$，时间步长 $\\Delta t = 0.05 \\,\\mathrm{ms}$。\n\n对于每个用例，计算前五个脉冲间间隔（单位为 $\\mathrm{ms}$），然后计算适应性比率 $\\text{ISI}_1/\\text{ISI}_5$。最终所需的输出格式为单行：\n`[ratio_A,ratio_B,ratio_C]`\n每个数值四舍五入到 6 位小数，并且在窗口内发生脉冲少于 6 次的情况下使用 `nan`。不应打印任何其他文本。",
            "solution": "该问题的解决方案需要编写一个程序来对Izhikevich模型的常微分方程组进行数值积分，同时处理脉冲事件。核心算法如下：\n\n1.  **初始化**：根据指定用例设置模型参数 $(a, b, c, d)$、输入电流 $I$、总模拟时间 $T$ 和时间步长 $\\Delta t$。设置初始条件 $v(0) = c$ 和 $u(0) = b \\cdot c$。创建一个空列表 `spike_times` 来存储所有脉冲发生的时间。\n\n2.  **数值积分循环**：使用显式前向欧拉法，在每个时间步 $\\Delta t$ 内更新状态变量 $(v, u)$。首先，保存步长开始时的电压 $v_{\\text{old}}$。然后，根据当前状态 $(v, u)$ 计算导数，并计算步长结束时的暂定新状态 $v_{\\text{next}} = v + \\Delta t \\cdot \\frac{dv}{dt}$ 和 $u_{\\text{next}} = u + \\Delta t \\cdot \\frac{du}{dt}$。\n\n3.  **脉冲检测与处理**：检查是否发生脉冲，即膜电位是否跨越阈值 $30 \\text{ mV}$（$v_{\\text{old}}  30$ 且 $v_{\\text{next}} \\ge 30$）。如果检测到脉冲，通过线性插值计算精确的脉冲时间 $t_{\\text{spike}}$并记录。然后，根据脉冲后重置规则更新状态：$v \\leftarrow c$ 和 $u \\leftarrow u_{\\text{next}} + d$。如果没有脉冲，则状态更新为暂定新状态。\n\n4.  **计算适应性比率**：模拟结束后，如果记录的脉冲数少于6个（即无法计算5个脉冲间期），则适应性比率为 'nan'。否则，计算所有脉冲间期（ISI）作为连续脉冲时间的差值，并最终计算适应性比率 $\\text{ISI}_1 / \\text{ISI}_5$。\n\n该算法将针对测试套件中的每个用例执行，并将结果格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_neuron(params):\n    \"\"\"\n    Simulates the Izhikevich neuron model for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (a, b, c, d, I, T, dt).\n\n    Returns:\n        float: The computed adaptation ratio, or np.nan if undefined.\n    \"\"\"\n    # Unpack parameters\n    a, b, c, d, I, T, dt = params\n    v_thresh = 30.0\n\n    # Initial conditions\n    v = c\n    u = b * c\n    \n    spike_times = []\n    \n    # Use a precise number of steps to avoid floating point issues with the loop range\n    num_steps = int(round(T / dt))\n\n    for i in range(num_steps):\n        current_t = i * dt\n        v_old = v\n        \n        # Explicit Euler step: calculate derivatives at the current state (v, u)\n        dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n        du_dt = a * (b * v - u)\n        \n        # Calculate tentative state for the next time step\n        v_next = v + dv_dt * dt\n        u_next = u + du_dt * dt\n        \n        # Spike detection: check for threshold crossing from below\n        if v_old  v_thresh and v_next = v_thresh:\n            # Estimate spike time using linear interpolation\n            if v_next - v_old  0: # Avoid division by zero\n                t_spike = current_t + dt * (v_thresh - v_old) / (v_next - v_old)\n                spike_times.append(t_spike)\n            else: # Should not happen on upstroke, but as a safeguard\n                spike_times.append(current_t + dt)\n\n            # Apply reset rule for the state at the beginning of the next step.\n            # This is the standard way to handle resets in fixed-step methods.\n            v = c\n            u = u_next + d\n        else:\n            # No spike, so the state for the next step is the Euler-updated state\n            v = v_next\n            u = u_next\n            \n    # Calculate adaptation ratio after the simulation is complete\n    # At least 6 spikes are needed to compute 5 ISIs.\n    if len(spike_times)  6:\n        return np.nan\n        \n    isis = np.diff(spike_times)\n    \n    # The length of isis is len(spike_times) - 1. We need at least 5 ISIs.\n    if len(isis)  5:\n        return np.nan\n        \n    adaptation_ratio = isis[0] / isis[4]\n    \n    return adaptation_ratio\n\ndef solve():\n    \"\"\"\n    Runs the Izhikevich neuron simulation for all test cases and prints the result.\n    \"\"\"\n    # Define the regular spiking (RS) parameters\n    # (a, b, c, d)\n    rs_params = (0.02, 0.2, -65.0, 8.0)\n    \n    # Define the test cases from the problem statement\n    # Each case is a tuple: (*rs_params, I, T, dt)\n    test_cases = [\n        # Case A: happy path\n        (*rs_params, 14.0, 1000.0, 0.1),\n        # Case B: low-current boundary\n        (*rs_params, 5.0, 1000.0, 0.1),\n        # Case C: high-current and smaller step\n        (*rs_params, 30.0, 500.0, 0.05)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = simulate_neuron(case)\n        if np.isnan(ratio):\n            results.append(\"nan\")\n        else:\n            # Round the result to 6 decimal places as required\n            results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "计算模型的结果和其数值实现一样可靠。这个高级练习处理一个关键问题：如何区分模型的真实行为与数值方法（如欧拉法）引入的计算伪影。通过测试放电率如何随着时间步长 $ \\Delta t $ 的减小而收敛，我们可以建立对模拟结果的信心。对于任何计算建模者来说，这都是一项确保科学严谨性的必备技能。",
            "id": "4029521",
            "problem": "考虑 Izhikevich 神经元模型，该模型通过常微分方程 (ODE) 描述膜电位和恢复变量的动力学。该模型由以下系统定义：\n$$\n\\frac{dv}{dt} = 0.04 v^2 + 5 v + 140 - u + I,\\quad \\frac{du}{dt} = a\\,(b\\,v - u),\n$$\n以及在膜电位穿过脉冲阈值时应用的脉冲后重置规则：\n$$\n\\text{if } v \\ge 30 \\text{ then } v \\leftarrow c,\\quad u \\leftarrow u + d.\n$$\n使用标准的“常规脉冲发放 (regular spiking)”参数 $a=0.02$, $b=0.2$, $c=-65$, $d=8$，并将状态初始化为 $v(0)=c$, $u(0)=b\\,c$。假设动力学采用固定的时间步长 $ \\Delta t $（单位为毫秒）的显式一阶前向 Euler 方法进行积分，并且在每次 Euler 更新后检查脉冲阈值。膜电位 $v$ 和恢复变量 $u$ 采用模型单位（无量纲）。输入电流 $I$ 是恒定的（无量纲模型单位）。\n\n作为输入电流函数的发放频率（$f$–$I$ 曲线）通过在有限的模拟时长 $T$ 内对脉冲进行计数，然后除以时长（以秒为单位）来估计。具体来说，如果在 $T$ 毫秒内发生了 $N_{\\text{spike}}$ 次脉冲，则发放频率 $f$ 必须以赫兹 (Hz) 为单位报告，计算公式为\n$$\nf = \\frac{N_{\\text{spike}}}{T/1000}.\n$$\n\n您的任务是计算数值离散化对 $f$–$I$ 曲线估计的影响，并设计一个收敛性诊断方法，以区分数值伪影和真实模型行为。请从数值积分和 ODE 误差分析的基本原理出发，除了 Izhikevich 模型本身和显式 Euler 方法的基本性质外，不使用任何专门的快捷公式。\n\n实现一个程序，该程序：\n- 使用时间步长 $\\Delta t \\in \\{1.0, 0.5, 0.25, 0.125\\}$ 毫秒的显式 Euler 方法模拟 Izhikevich 模型。\n- 对于每个指定的测试用例，在模拟时长 $T$ 毫秒内，为一组恒定电流 $I$ 计算在所有指定 $\\Delta t$ 值下的发放频率，然后为每个 $I$ 评估一个收敛性诊断：\n  1. 定义发放频率序列 $f_{\\Delta t}$, $f_{\\Delta t/2}$, $f_{\\Delta t/4}$, $f_{\\Delta t/8}$。\n  2. 定义连续绝对差 $D_1 = |f_{\\Delta t} - f_{\\Delta t/2}|$, $D_2 = |f_{\\Delta t/2} - f_{\\Delta t/4}|$, $D_3 = |f_{\\Delta t/4} - f_{\\Delta t/8}|$。\n  3. 定义收敛比率\n     $$\n     R = \\frac{D_1}{D_2},\n     $$\n     当解在相关意义上是光滑的时，对于一阶方法，该比率预期接近 $2$。\n  4. 如果满足以下所有条件，则声明对电流 $I$ 的诊断通过：\n     - 差分的单调细化：$D_1 \\ge D_2 \\ge D_3$。\n     - 渐进行为比率一致性：当 $D_2  0$ 时，$R$ 位于区间 $[1.25, 3.0]$ 内；如果 $D_2 = 0$ 且 $D_1 = 0$，则视为满足此条件。\n     - 细尺度稳定性：$D_3 \\le \\epsilon$，其中 $\\epsilon = 1.0$ Hz。\n     此外，如果对于给定的 $I$，所有四个发放频率都恰好为零（在所有离散化下均未发放脉冲），则视为该 $I$ 的诊断平凡满足。\n  5. 测试用例的结果是一个布尔值，指示该用例中的所有电流是否都通过了诊断。\n\n科学真实性要求：\n- 所有模拟均使用 $T = 2000$ 毫秒，并发放频率以赫兹 (Hz) 为单位报告。\n- 必须使用显式 Euler 方法来近似 ODE，并且必须在每次 Euler 更新后通过对 $v$ 进行阈值判断（阈值为 $30$）来检测脉冲，在检测到脉冲时立即应用重置。此事件处理在所有 $\\Delta t$ 值中应完全相同。\n\n测试套件：\n- 用例 1（常规“理想路径”）：$I \\in \\{10, 14, 20, 30\\}$，$T = 2000$ ms，基础步长 $\\Delta t_0 = 1.0$ ms。\n- 用例 2（接近基电流边界）：$I \\in \\{6, 8, 10\\}$，$T = 2000$ ms，基础步长 $\\Delta t_0 = 1.0$ ms。\n- 用例 3（高输入区域）：$I \\in \\{40, 60\\}$，$T = 2000$ ms，基础步长 $\\Delta t_0 = 1.0$ ms。\n- 用例 4（阈下边缘）：$I \\in \\{0, 2\\}$，$T = 2000$ ms，基础步长 $\\Delta t_0 = 1.0$ ms。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的布尔值列表（每个测试用例一个），并用方括号括起来，例如 `[True,False,True,True]`。每个布尔值指示相应测试用例中的所有电流是否都通过了收敛性诊断。此行必须是程序产生的唯一输出。",
            "solution": "该问题要求实现和分析 Izhikevich 神经元模型，这是一个带有不连续重置条件的常微分方程 (ODE) 系统，旨在评估数值离散化对计算出的发放频率的影响。该分析使用基于显式一阶前向 Euler 方法的数值误差分析基本原理的自定义收敛性诊断方法。\n\nIzhikevich 模型由以下关于膜电位 $v(t)$ 和恢复变量 $u(t)$ 的系统定义：\n$$\n\\frac{dv}{dt} = 0.04 v^2 + 5 v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a(b v - u)\n$$\n其中 $I$ 是一个恒定的输入电流。当 $v$ 达到 $30$ 的阈值时，会记录一个脉冲并重置状态变量：\n$$\n\\text{if } v \\ge 30, \\text{ then } v \\leftarrow c \\text{ and } u \\leftarrow u + d.\n$$\n问题指定使用“常规脉冲发放 (regular spiking)”神经元的参数：$a = 0.02$，$b = 0.2$，$c = -65$ 和 $d = 8$。初始条件设置为静息状态，$v(0) = c = -65$ 和 $u(0) = b \\cdot c = 0.2 \\cdot (-65) = -13$。\n\n该 ODE 系统的解使用显式一阶前向 Euler 方法进行近似。在每个 Euler 步之后，会检查新的电位 $v_{n+1}$ 是否达到脉冲阈值。如果 $v_{n+1} \\ge 30$，则计数一个脉冲，并立即对刚计算出的状态应用重置条件。\n\n问题的核心是评估发放频率 $f$ 的收敛性诊断，该频率是解轨迹的一个泛函。发放频率计算为 $f = N_{\\text{spike}} / (T/1000)$，其中 $N_{\\text{spike}}$ 是在模拟时长 $T = 2000$ 毫秒内的总脉冲数。此计算将频率转换为赫兹 (Hz)。诊断评估计算出的频率 $f$ 如何随着时间步长 $\\Delta t$ 的细化而变化。模拟针对一系列时间步长 $\\Delta t \\in \\{1.0, 0.5, 0.25, 0.125\\}$ ms 运行。\n\n该诊断包括三个基于数值积分理论的条件：\n\n1.  **差分的单调细化**：$D_1 \\ge D_2 \\ge D_3$，其中 $D_k$ 是连续细化步骤之间的频率绝对差。此条件检查随着 $\\Delta t$ 减小，解是否稳定地收敛。\n\n2.  **渐进行为比率一致性**：对于一阶方法，连续差分的比率 $R = D_1 / D_2$ 预期接近 $2$。诊断允许该比率在一个合理的区间 $[1.25, 3.0]$ 内，以适应系统的不连续性。\n\n3.  **细尺度稳定性**：最细尺度上的绝对差 $D_3$ 必须低于容差 $\\epsilon = 1.0$ Hz，以确保解已足够接近其收敛值。\n\n如果一个电流值在所有分辨率下都未产生脉冲，则诊断平凡通过。对于一个测试用例，只有当该用例中的每个输入电流 $I$ 都通过此诊断时，最终结果才为 `True`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    # Model parameters for regular spiking (RS)\n    a = 0.02\n    b = 0.2\n    c = -65.0\n    d = 8.0\n\n    # Simulation and diagnostic parameters\n    T = 2000.0  # ms\n    time_steps = [1.0, 0.5, 0.25, 0.125] # ms\n    epsilon = 1.0 # Hz\n\n    # Test suite\n    test_cases = [\n        # Case 1: general \"happy path\"\n        {'I_values': [10.0, 14.0, 20.0, 30.0]},\n        # Case 2: near rheobase boundary\n        {'I_values': [6.0, 8.0, 10.0]},\n        # Case 3: high-input regime\n        {'I_values': [40.0, 60.0]},\n        # Case 4: subthreshold edge\n        {'I_values': [0.0, 2.0]},\n    ]\n\n    def simulate_izhikevich(I_val, dt):\n        \"\"\"\n        Simulates the Izhikevich neuron model using forward Euler.\n        \n        Args:\n            I_val (float): Input current.\n            dt (float): Time step in ms.\n        \n        Returns:\n            int: Number of spikes.\n        \"\"\"\n        v = c\n        u = b * c\n        spike_count = 0\n        \n        num_steps = int(T / dt)\n        \n        for _ in range(num_steps):\n            # Forward Euler update\n            v_old = v\n            u_old = u\n            \n            dv = (0.04 * v_old**2 + 5.0 * v_old + 140.0 - u_old + I_val)\n            du = a * (b * v_old - u_old)\n            \n            v = v_old + dt * dv\n            u = u_old + dt * du\n            \n            # Spike detection and reset\n            if v = 30.0:\n                spike_count += 1\n                v = c\n                u = u + d\n                \n        return spike_count\n\n    def evaluate_diagnostic(I_val):\n        \"\"\"\n        Calculates firing rates and evaluates the convergence diagnostic for a given current.\n        \n        Args:\n            I_val (float): Input current.\n            \n        Returns:\n            bool: True if the diagnostic passes, False otherwise.\n        \"\"\"\n        firing_rates = []\n        for dt in time_steps:\n            n_spikes = simulate_izhikevich(I_val, dt)\n            rate = n_spikes / (T / 1000.0)\n            firing_rates.append(rate)\n\n        # Trivial pass condition: no spikes at any resolution\n        if all(rate == 0 for rate in firing_rates):\n            return True\n\n        # Define successive absolute differences\n        D1 = abs(firing_rates[0] - firing_rates[1])\n        D2 = abs(firing_rates[1] - firing_rates[2])\n        D3 = abs(firing_rates[2] - firing_rates[3])\n\n        # 1. Monotone refinement of differences\n        cond_monotonicity = (D1 = D2) and (D2 = D3)\n\n        # 2. Asymptotic ratio consistency\n        cond_ratio = False\n        if D2 > 0:\n            R = D1 / D2\n            if 1.25 = R = 3.0:\n                cond_ratio = True\n        elif D1 == 0:  # and D2 is implicitly 0\n            cond_ratio = True\n        \n        # 3. Fine-scale stability\n        cond_stability = (D3 = epsilon)\n\n        return cond_monotonicity and cond_ratio and cond_stability\n\n    results = []\n    for case in test_cases:\n        case_passed = True\n        for I in case['I_values']:\n            if not evaluate_diagnostic(I):\n                case_passed = False\n                break\n        results.append(case_passed)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res).lower() for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}