{
    "hands_on_practices": [
        {
            "introduction": "我们的动手实践始于最基本的尖峰序列模型：齐次泊松过程，该模型假设神经元的发放率恒定。这个练习是理解点过程似然估计的基础性一步 。通过为这个简单模型推导最大似然估计量，您将直观地理解似然框架如何将观测数据（尖峰数量）与模型参数（发放率）联系起来，为后续更复杂的模型做好准备。",
            "id": "4010017",
            "problem": "您观察一个在区间 $\\left[0, T\\right]$ 内的单神经元脉冲序列，其中 $T0$ 以秒为单位，记录的脉冲时间为 $\\{t_i\\}_{i=1}^{N}$，满足 $0  t_1  t_2  \\cdots  t_N \\leq T$，其中 $N \\in \\mathbb{N}$ 是观测到的脉冲总数。假设该脉冲序列由一个简单点过程生成，该过程具有一个明确定义的条件强度函数 $\\lambda(t \\mid \\mathcal{H}_t)$，其中 $\\mathcal{H}_t$ 表示截至时间 $t$ 的过程历史。考虑这样一类模型，其条件强度不随时间变化且独立于历史，即对于所有 $t \\in [0, T]$，有 $\\lambda(t \\mid \\mathcal{H}_t) = \\lambda_0$，其中 $\\lambda_0  0$ 的单位为 $\\text{s}^{-1}$。\n\n从条件强度函数的核心定义出发——即对于足够小的 $\\Delta t0$，在给定 $\\mathcal{H}_t$ 的条件下，区间 $\\left[t, t + \\Delta t\\right)$ 内发生一个事件的概率满足 $\\mathbb{P}\\{\\text{在 } [t, t+\\Delta t) \\text{ 内有事件} \\mid \\mathcal{H}_t\\} = \\lambda(t \\mid \\mathcal{H}_t)\\,\\Delta t + o(\\Delta t)$，而该区间内不发生事件的概率为 $1 - \\lambda(t \\mid \\mathcal{H}_t)\\,\\Delta t + o(\\Delta t)$——推导在恒定强度模型下观测到的脉冲序列的精确对数似然。然后，利用此对数似然，解析地推导出 $\\lambda_0$ 的最大似然估计量 (MLE)。\n\n将您的最终答案表示为 MLE 的单个闭式解析表达式。如果需要单位，请以 $\\text{s}^{-1}$ 表示。无需四舍五入。",
            "solution": "该问题要求推导在恒定强度点过程模型下观测到的脉冲序列的对数似然，并随后推导模型单一参数——恒定强度 $\\lambda_0$ 的最大似然估计量 (MLE)。\n\n该问题是有效的，因为它在科学上基于点过程理论和统计估计，这些是计算神经科学的基础。问题阐述清晰、客观，并包含得出唯一且有意义解所需的所有信息。\n\n设观测到的脉冲序列为区间 $[0, T]$ 内的脉冲时间集合 $\\{t_i\\}_{i=1}^{N}$，其中 $N$ 是观测到的脉冲总数。该模型假设脉冲序列由一个条件强度函数不随时间变化且独立于历史 $\\mathcal{H}_t$ 的过程生成：\n$$ \\lambda(t \\mid \\mathcal{H}_t) = \\lambda_0 $$\n其中 $\\lambda_0$ 是一个正常数，单位为 $\\text{s}^{-1}$。该模型也被称为齐次泊松过程。\n\n观测到点过程的特定实现（由区间 $[0, T]$ 内的事件时间集合 $\\{t_i\\}_{i=1}^{N}$ 指定）的似然由点过程似然密度通用公式给出：\n$$ L(\\theta; \\{t_i\\}_{i=1}^N) = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}; \\theta) \\right) \\exp\\left( -\\int_{0}^{T} \\lambda(s \\mid \\mathcal{H}_s; \\theta) \\, ds \\right) $$\n其中 $\\theta$ 代表模型参数集。\n\n在我们的特定情况下，参数集仅包含 $\\lambda_0$，因此 $\\theta = \\{\\lambda_0\\}$。条件强度函数就是 $\\lambda(t \\mid \\mathcal{H}_t; \\lambda_0) = \\lambda_0$。我们将此代入通用的似然公式。\n\n连乘项变为：\n$$ \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}; \\lambda_0) = \\prod_{i=1}^{N} \\lambda_0 = \\lambda_0^N $$\n\n指数中的积分项变为：\n$$ \\int_{0}^{T} \\lambda(s \\mid \\mathcal{H}_s; \\lambda_0) \\, ds = \\int_{0}^{T} \\lambda_0 \\, ds = \\lambda_0 [s]_0^T = \\lambda_0 T $$\n\n将这两个部分代回似然公式，得到在恒定强度模型下观测数据的似然函数：\n$$ L(\\lambda_0; \\{t_i\\}_{i=1}^N, T) = \\lambda_0^N \\exp(-\\lambda_0 T) $$\n这个表达式代表了在区间 $[0, T]$ 内于特定时间 $\\{t_i\\}$ 观测到 $N$ 个脉冲且无其他脉冲的联合概率密度。请注意，似然仅通过充分统计量 $N$ 和 $T$ 依赖于数据。\n\n任务的第一部分是推导对数似然。它是似然函数的自然对数，记为 $\\ell(\\lambda_0)$：\n$$ \\ell(\\lambda_0) = \\ln\\left( L(\\lambda_0) \\right) = \\ln\\left( \\lambda_0^N \\exp(-\\lambda_0 T) \\right) $$\n利用对数的性质 $\\ln(ab) = \\ln(a) + \\ln(b)$ 和 $\\ln(x^y) = y\\ln(x)$，我们得到：\n$$ \\ell(\\lambda_0) = \\ln(\\lambda_0^N) + \\ln(\\exp(-\\lambda_0 T)) $$\n$$ \\ell(\\lambda_0) = N \\ln(\\lambda_0) - \\lambda_0 T $$\n这就是在恒定强度模型下观测到的脉冲序列的精确对数似然。\n\n任务的第二部分是求 $\\lambda_0$ 的最大似然估计量 (MLE)。MLE，我们记为 $\\hat{\\lambda}_0$，是使对数似然函数 $\\ell(\\lambda_0)$ 最大化的 $\\lambda_0$ 的值。为求此值，我们对 $\\ell(\\lambda_0)$ 关于 $\\lambda_0$ 求导并令其为零。\n$$ \\frac{d\\ell(\\lambda_0)}{d\\lambda_0} = \\frac{d}{d\\lambda_0} \\left( N \\ln(\\lambda_0) - \\lambda_0 T \\right) $$\n应用微分法则：\n$$ \\frac{d\\ell(\\lambda_0)}{d\\lambda_0} = N \\left(\\frac{1}{\\lambda_0}\\right) - T = \\frac{N}{\\lambda_0} - T $$\n将此导数设为零以找到临界点：\n$$ \\frac{N}{\\hat{\\lambda}_0} - T = 0 $$\n$$ \\frac{N}{\\hat{\\lambda}_0} = T $$\n解出 $\\hat{\\lambda}_0$ 得到 MLE：\n$$ \\hat{\\lambda}_0 = \\frac{N}{T} $$\n\n为确认此值对应于一个最大值，我们必须检查对数似然函数的二阶导数：\n$$ \\frac{d^2\\ell(\\lambda_0)}{d\\lambda_0^2} = \\frac{d}{d\\lambda_0} \\left( \\frac{N}{\\lambda_0} - T \\right) = - \\frac{N}{\\lambda_0^2} $$\n问题陈述 $N \\in \\mathbb{N}$，并且通常会观测到脉冲，因此我们可以假设 $N > 0$。由于根据定义 $\\lambda_0 > 0$，所以 $\\lambda_0^2$ 是正的。因此，二阶导数对于所有有效的 $\\lambda_0$ 值都是负的：\n$$ \\frac{d^2\\ell(\\lambda_0)}{d\\lambda_0^2} = - \\frac{N}{\\lambda_0^2}  0 $$\n负的二阶导数证实了对数似然函数是凹函数，我们找到的临界点确实是一个最大值。在 $N=0$ 的情况下，对数似然为 $\\ell(\\lambda_0) = -\\lambda_0 T$，当 $\\lambda_0 \\rightarrow 0$ 时该函数最大化。公式 $\\hat{\\lambda}_0 = N/T = 0/T = 0$ 与此极限情况一致。\n\n因此，恒定强度 $\\lambda_0$ 的最大似然估计量是脉冲总数 $N$ 除以观测区间的时长 $T$。这个结果在直观上是令人满意的：事件发生率的最佳估计就是观测到的事件平均发生率。$\\hat{\\lambda}_0$ 的单位是单位时间内的脉冲数，即 $\\text{s}^{-1}$，符合要求。",
            "answer": "$$\\boxed{\\frac{N}{T}}$$"
        },
        {
            "introduction": "真实的神经元活动很少是恒定的；它会受到刺激、自身的发放历史以及其他神经元输入的影响而动态变化。本实践将引导您进入功能强大的广义线性模型（GLM）框架，这是模拟这些复杂依赖关系的主力工具 。您将推导该模型的对数似然函数及其梯度，这构成了使用数值优化方法拟合模型参数（如耦合滤波器）的数学核心。",
            "id": "4009974",
            "problem": "考虑在一个固定的时间窗口 $[0,T]$ 内观测到的单个神经元，其脉冲时间为 $0  t_{1}  t_{2}  \\cdots  t_{N} \\leq T$。其条件强度函数 $\\lambda(t \\mid \\mathcal{H}_{t})$ 由一个广义线性模型 (GLM) 建模，其中广义线性模型 (GLM) 指的是一类模型，在这类模型中，一个连接函数将线性预测器映射到响应的均值。具体来说，假设\n$$\n\\lambda(t \\mid \\mathcal{H}_{t}) \\;=\\; \\exp\\!\\big\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t)\\big\\},\n$$\n其中 $\\beta_{0} \\in \\mathbb{R}$ 是一个基线参数，$\\mathbf{w} \\in \\mathbb{R}^{p}$ 是耦合权重，$\\mathbf{x}(t) \\in \\mathbb{R}^{p}$ 是连续时间协变量，可能包括刺激驱动项、通过将神经元自身的脉冲序列与自身历史滤波器进行卷积而构建的脉冲历史项，以及通过将其他神经元的脉冲序列与耦合滤波器进行卷积而构建的耦合项。假设 $\\mathbf{x}(t)$ 在 $[0,T]$ 上是分段连续且可积的，并且 $\\lambda(t \\mid \\mathcal{H}_{t})$ 对所有 $t \\in [0,T]$ 都是良定义且有限的。\n\n从点过程的第一性原理出发，推导在该模型下观测到的脉冲序列的对数似然 $\\ell(\\beta_{0},\\mathbf{w})$ 的显式表达式，然后推导对数似然关于 $\\mathbf{w}$ 的梯度。你的推导必须从点过程的条件强度和生存的基本定义开始，而不是从任何预先给出的闭合形式的似然或梯度表达式开始。将你的最终结果表示为以 $\\beta_{0}$、$\\mathbf{w}$、$\\mathbf{x}(t)$、脉冲时间 $\\{t_{i}\\}_{i=1}^{N}$ 和观测窗口 $[0,T]$ 表示的闭合形式的解析表达式。最终答案必须是以精确解析表达式形式的计算。不要引入任何正则化项。如果遇到中间的向量或矩阵导数，你必须通过解析计算来得出所要求的最终表达式。",
            "solution": "该问题要求为一个由具有指数连接函数的广义线性模型 (GLM) 建模的神经脉冲序列推导对数似然函数及其梯度。推导必须从点过程理论的第一性原理开始。\n\n### 第1部分：对数似然函数 $\\ell(\\beta_0, \\mathbf{w})$ 的推导\n\n区间 $[0, T]$ 上的一个时间点过程由其条件强度函数 $\\lambda(t \\mid \\mathcal{H}_{t})$ 来表征，该函数表示在给定先前事件历史 $\\mathcal{H}_{t}$ 的情况下，在时间 $t$ 发生一个事件（一个脉冲）的瞬时概率。\n\n从第一性原理出发，观测到特定脉冲时间序列 $0  t_1  t_2  \\dots  t_N \\leq T$ 的似然可以通过考虑这些事件的联合概率密度来构建。这可以表示为每个脉冲的条件密度的乘积，再乘以在脉冲之间以及最后一个脉冲之后的区间内没有脉冲发生的概率。\n\n令 $t_0 = 0$。观测到第一个脉冲在 $t_1$ 发生的概率密度由 $t_1$ 处的瞬时率与在区间 $(0, t_1]$ 内*没有*脉冲发生的概率的乘积给出。这个“生存”概率由 $S(t_1 \\mid 0)$ 给出。因此，密度为 $p(t_1) = \\lambda(t_1 \\mid \\mathcal{H}_{t_1}) S(t_1 \\mid 0)$。\n\n更一般地，给定第 $(i-1)$ 个脉冲发生在 $t_{i-1}$，第 $i$ 个脉冲发生在 $t_i$ 的条件概率密度为：\n$$\np(t_i \\mid t_{i-1}, \\mathcal{H}_{t_{i-1}}) = \\lambda(t_i \\mid \\mathcal{H}_{t_i}) S(t_i \\mid t_{i-1})\n$$\n其中 $S(t_i \\mid t_{i-1})$ 是在区间 $(t_{i-1}, t_i]$ 内生存（即不产生脉冲）的概率。生存函数与积分的条件强度相关：\n$$\nS(t_b \\mid t_a) = \\exp \\left( - \\int_{t_a}^{t_b} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n\n在窗口 $[0, T]$ 内观测到脉冲序列 $\\{t_1, \\dots, t_N\\}$ 的全似然 $L$ 是每个脉冲的条件密度的乘积，再乘以从最后一个脉冲 $t_N$ 到观测窗口结束 $T$ 的生存概率：\n$$\nL = \\left( \\prod_{i=1}^{N} p(t_i \\mid t_{i-1}, \\mathcal{H}_{t_{i-1}}) \\right) S(T \\mid t_N)\n$$\n代入条件密度的表达式：\n$$\nL = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}) S(t_i \\mid t_{i-1}) \\right) S(T \\mid t_N)\n$$\n我们可以将各项分组：\n$$\nL = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}) \\right) \\left( \\prod_{i=1}^{N} S(t_i \\mid t_{i-1}) \\right) S(T \\mid t_N)\n$$\n生存项的乘积是：\n$$\n\\left( \\prod_{i=1}^{N} \\exp \\left( - \\int_{t_{i-1}}^{t_i} \\lambda(u \\mid \\mathcal{H}_u) du \\right) \\right) \\exp \\left( - \\int_{t_N}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n$$\n= \\exp \\left( - \\sum_{i=1}^{N} \\int_{t_{i-1}}^{t_i} \\lambda(u \\mid \\mathcal{H}_u) du - \\int_{t_N}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n根据积分的可加性，指数中的和就是整个观测窗口 $[0, T]$ 上的积分：\n$$\n= \\exp \\left( - \\int_{0}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n因此，似然函数为：\n$$\nL(\\beta_0, \\mathbf{w}) = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}) \\right) \\exp \\left( - \\int_{0}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n那么，对数似然 $\\ell = \\ln(L)$ 为：\n$$\n\\ell(\\beta_0, \\mathbf{w}) = \\sum_{i=1}^{N} \\ln(\\lambda(t_i \\mid \\mathcal{H}_{t_i})) - \\int_{0}^{T} \\lambda(u \\mid \\mathcal{H}_u) du\n$$\n现在，我们代入给定的条件强度的 GLM 形式：$\\lambda(t \\mid \\mathcal{H}_t) = \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t)\\}$。\n在每个脉冲时间 $t_i$ 处强度的对数为：\n$$\n\\ln(\\lambda(t_i \\mid \\mathcal{H}_{t_i})) = \\ln \\left( \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)\\} \\right) = \\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)\n$$\n将此式和 $\\lambda(u)$ 的表达式代入对数似然方程，我们得到对数似然的最终表达式：\n$$\n\\ell(\\beta_0, \\mathbf{w}) = \\sum_{i=1}^{N} \\left( \\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i) \\right) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} du\n$$\n\n### 第2部分：梯度 $\\nabla_{\\mathbf{w}} \\ell(\\beta_0, \\mathbf{w})$ 的推导\n\n为了求得对数似然关于权重向量 $\\mathbf{w}$ 的梯度，我们对 $\\ell(\\beta_0, \\mathbf{w})$ 关于 $\\mathbf{w}$ 求导。\n$$\n\\nabla_{\\mathbf{w}} \\ell(\\beta_0, \\mathbf{w}) = \\nabla_{\\mathbf{w}} \\left( \\sum_{i=1}^{N} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} du \\right)\n$$\n我们逐项求导。首先，是求和项：\n$$\n\\nabla_{\\mathbf{w}} \\left( \\sum_{i=1}^{N} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)) \\right) = \\sum_{i=1}^{N} \\nabla_{\\mathbf{w}} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i))\n$$\n由于 $\\beta_0$不依赖于 $\\mathbf{w}$，并使用向量微积分恒等式 $\\nabla_{\\mathbf{z}} (\\mathbf{z}^{\\top} \\mathbf{a}) = \\mathbf{a}$，我们有：\n$$\n= \\sum_{i=1}^{N} \\mathbf{x}(t_i)\n$$\n接下来，我们对积分项求导。由于积分限 $0$ 和 $T$ 不是 $\\mathbf{w}$ 的函数，我们可以使用莱布尼茨积分法则（在积分号下求导）：\n$$\n\\nabla_{\\mathbf{w}} \\left( \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} du \\right) = \\int_{0}^{T} \\nabla_{\\mathbf{w}} \\left( \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\right) du\n$$\n我们对被积函数应用链式法则。令 $f(\\mathbf{w}) = \\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)$。外部指数函数的梯度是 $\\nabla_{\\mathbf{w}} \\exp(f(\\mathbf{w})) = \\exp(f(\\mathbf{w})) \\nabla_{\\mathbf{w}} f(\\mathbf{w})$。\n指数的梯度为：\n$$\n\\nabla_{\\mathbf{w}} f(\\mathbf{w}) = \\nabla_{\\mathbf{w}} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)) = \\mathbf{x}(u)\n$$\n因此，被积函数的梯度为：\n$$\n\\nabla_{\\mathbf{w}} \\left( \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\right) = \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) = \\lambda(u \\mid \\mathcal{H}_u) \\mathbf{x}(u)\n$$\n将此代回积分中，积分项的梯度为：\n$$\n\\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) du\n$$\n结合两部分的梯度，我们得到对数似然关于 $\\mathbf{w}$ 的梯度：\n$$\n\\nabla_{\\mathbf{w}} \\ell(\\beta_0, \\mathbf{w}) = \\sum_{i=1}^{N} \\mathbf{x}(t_i) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) du\n$$\n这个表达式表示在观测到的脉冲时间点上协变量向量的总和与它们在整个观测窗口上由模型的预测发放率加权的期望积分之间的差值。",
            "answer": "$$\n\\boxed{\n\\sum_{i=1}^{N} \\mathbf{x}(t_i) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) du\n}\n$$"
        },
        {
            "introduction": "构建和拟合模型只是工作的一半，我们还必须检验模型是否充分地描述了数据。这最后一个实践聚焦于模型评估这一关键步骤，即拟合优度检验 。您将学习如何使用标准化残差来检查模型未能捕捉到的、数据中仍然存在的模式，这是确保科学结论稳健可靠的关键诊断步骤。",
            "id": "4010013",
            "problem": "考虑一个神经元点过程的离散时间近似，其中时间被划分为宽度为 $\\Delta$ 秒的均匀时间窗。令 $n_t$ 表示时间窗 $t$ 内的脉冲计数，令 $\\lambda_t$ 表示从一个先前估计的模型中拟合出的条件强度（单位：脉冲/秒），该模型可能包含刺激驱动和历史耦合。假设以下基本事实：(i) 在一个正确设定的条件强度广义线性模型下，以过去历史为条件，分箱后的计数具有独立增量；(ii) 对于足够小的 $\\Delta$，时间窗 $t$ 内的期望计数为 $\\mu_t \\approx \\lambda_t \\Delta$；(iii) 在分箱计数服从泊松分布的假设下，$n_t$ 相对于 $\\mu_t$ 的偏差可以通过适当的方差缩放进行标准化。从这些基础出发，从第一性原理推导时间分箱的皮尔逊残差，推导序列在固定延迟下的样本自相关函数，并推导一个综合统计量，该统计量聚合了跨延迟的自相关，以检验残差无自相关的原假设。\n\n你的程序必须：\n- 实现所推导的皮尔逊残差，用于处理分箱计数序列 $\\{n_t\\}_{t=1}^T$ 和拟合强度序列 $\\{\\lambda_t\\}_{t=1}^T$，给定固定的时间窗宽度 $\\Delta$。如果任何时间窗的 $\\mu_t = \\lambda_t \\Delta = 0$，你必须引入一个极小的正常数 $\\varepsilon$ 来避免除以零，以科学合理的方式进行数值处理。\n- 计算皮尔逊残差序列在延迟 $1$ 到 $L$ 上的样本自相关，然后计算一个综合统计量，聚合这些自相关以在原假设下检验残差自相关。使用固定的显著性水平 $\\alpha$ 进行检验，并返回一个布尔值，指示是否拒绝原假设（即，残差中是否存在统计上显著的自相关）。\n\n你必须使用以下具有科学合理参数的测试套件。所有随机性必须通过使用指定的伪随机种子来保证可复现。不涉及角度；时间单位为秒，强度单位为脉冲/秒。\n\n测试用例 1（模型设定良好，独立增量）：\n- 时间窗宽度 $\\Delta = 0.01$。\n- 时间窗数量 $T = 10000$。\n- 拟合强度为常数 $\\lambda_t = 20$，对所有 $t$ 成立。\n- 使用伪随机种子 $12345$，从均值为 $\\mu_t = \\lambda_t \\Delta$ 的独立泊松分布中生成计数 $n_t$。\n- 最大延迟 $L = 1$，显著性水平 $\\alpha = 0.05$，数值稳定器 $\\varepsilon = 10^{-12}$。\n\n测试用例 2（模型不匹配，具有正一阶依赖性）：\n- 时间窗宽度 $\\Delta = 0.01$。\n- 时间窗数量 $T = 4000$。\n- 拟合强度为常数 $\\lambda_t = 20$，对所有 $t$ 成立。\n- 使用一个二元一阶马尔可夫过程生成计数 $n_t \\in \\{0,1\\}$，其转移概率为 $P(n_t=1 \\mid n_{t-1}=0) = p_0$ 和 $P(n_t=1 \\mid n_{t-1}=1) = p_1$，其中 $p_0 = 0.1$ 且 $p_1 = 0.5$。初始化 $n_1 = 0$，并使用伪随机种子 $54321$ 进行后续抽样。\n- 最大延迟 $L = 1$，显著性水平 $\\alpha = 0.05$，数值稳定器 $\\varepsilon = 10^{-12}$。\n\n测试用例 3（边缘情况，包含结构性发放和零预测强度段）：\n- 时间窗宽度 $\\Delta = 0.01$。\n- 时间窗数量 $T = 800$。\n- 拟合强度为 $\\lambda_t = 0$（当 $t \\in \\{1,\\dots,100\\}$）和 $\\lambda_t = 5$（当 $t \\in \\{101,\\dots,800\\}$）。\n- 确定性计数：当 $t \\in \\{1,\\dots,100\\}$ 时 $n_t = 0$；当 $t \\in \\{101,\\dots,800\\}$ 时，设置 $n_t$ 遵循一个四个1后跟四个0的重复模式（即，$1,1,1,1,0,0,0,0$ 无随机性地重复），以表示拟合强度未能捕捉到的阵发性结构。\n- 最大延迟 $L = 1$，显著性水平 $\\alpha = 0.05$，数值稳定器 $\\varepsilon = 10^{-12}$。\n\n算法要求：\n- 根据基本假设推导皮尔逊残差，并实现它以获得每个测试用例的残差序列 $\\{r_t\\}_{t=1}^T$。\n- 推导样本自相关估计量，并实现计算延迟 $1$ 到 $L$ 的自相关。\n- 推导并实现一个综合统计量，在无自相关的原假设下，该统计量服从一个适当的参考分布，并用它来计算在显著性水平 $\\alpha$ 下的决策规则，以输出一个指示是否拒绝原假设的布尔值。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3]$），其中每个条目都是一个布尔值，指示对于相应的测试用例，是否使用综合检验在指定的延迟下在皮尔逊残差中检测到统计上显著的自相关。",
            "solution": "我们从一个在离散时间中观察到的点过程模型开始。令 $\\Delta$ 表示以秒为单位的时间窗宽度，令 $n_t$ 表示时间窗 $t$ 内的脉冲计数，令 $\\lambda(t \\mid \\mathcal{H}_t)$ 表示在给定历史 $\\mathcal{H}_t$ 的情况下，时间 $t$ 的条件强度。在一个强度近似恒定的时间窗内，我们记为 $\\lambda_t \\approx \\lambda(t \\mid \\mathcal{H}_t)$，并使用一个经过充分检验的近似，即时间窗 $t$ 内的期望计数为 $\\mu_t = \\mathbb{E}[n_t \\mid \\mathcal{H}_t] \\approx \\lambda_t \\Delta$。在小时间窗内计数服从泊松模型的假设下，我们有 $\\operatorname{Var}(n_t \\mid \\mathcal{H}_t) \\approx \\mu_t$，并且当模型设定正确时，以历史为条件，增量是独立的。\n\n在这些基础上，一个用于比较观测计数 $n_t$ 与其期望计数 $\\mu_t$ 的标准化残差是皮尔逊残差。为推导它，定义偏差 $d_t = n_t - \\mu_t$，并注意在泊松假设下，每个时间窗的适当方差尺度为 $\\sigma_t^2 \\approx \\mu_t$。因此，标准化偏差为\n$$\nr_t = \\frac{d_t}{\\sqrt{\\sigma_t^2}} \\approx \\frac{n_t - \\mu_t}{\\sqrt{\\mu_t}}.\n$$\n在一个设定良好的模型下，这个序列 $\\{r_t\\}$ 应近似不相关且均值为零。在数值上，为避免在 $\\mu_t = 0$ 的时间窗中出现除以零的情况，我们引入一个极小的稳定器 $\\varepsilon  0$ 并使用\n$$\nr_t = \\frac{n_t - \\mu_t}{\\sqrt{\\mu_t + \\varepsilon}},\n$$\n当 $\\mu_t  0$ 时，该式恢复为标准定义；当 $n_t = \\mu_t = 0$ 时，该式得出 $r_t \\approx 0$。\n\n为了评估剩余的结构，我们测量残差中的自相关。对于一个样本均值为 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^T r_t$ 的有限序列 $\\{r_t\\}_{t=1}^T$，延迟 $k$ 的样本自协方差为\n$$\n\\hat{\\gamma}_k = \\frac{1}{T} \\sum_{t=k+1}^T (r_t - \\bar{r})(r_{t-k} - \\bar{r}),\n$$\n样本方差为\n$$\n\\hat{\\gamma}_0 = \\frac{1}{T} \\sum_{t=1}^T (r_t - \\bar{r})^2.\n$$\n那么延迟 $k$ 的样本自相关为\n$$\n\\hat{\\rho}_k = \\frac{\\hat{\\gamma}_k}{\\hat{\\gamma}_0}.\n$$\n在残差是白噪声的原假设下，对于所有小的延迟，$\\hat{\\rho}_k$ 都应接近于 $0$。\n\n对于跨多个延迟的联合检验，我们使用一个通过聚合自相关得到的综合统计量。一个广泛使用的选择是 Box–Ljung 统计量，对于最大延迟 $L$ 定义为\n$$\nQ = T(T+2)\\sum_{k=1}^L \\frac{\\hat{\\rho}_k^2}{T-k}.\n$$\n在无自相关的原假设下，对于大的 $T$，$Q$ 近似服从自由度为 $L$ 的卡方（chi-square）随机变量。因此，在显著性水平 $\\alpha$ 下的一个有原则的决策规则是，当\n$$\nQ  \\chi^2_{1-\\alpha}(L),\n$$\n时拒绝原假设，其中 $\\chi^2_{1-\\alpha}(L)$ 是自由度为 $L$ 的卡方分布的 $(1-\\alpha)$ 分位数。等价地，我们通过生存函数计算 $p$ 值，并在 $p  \\alpha$ 时拒绝原假设。\n\n算法设计：\n- 对于每个测试用例，计算所有 $t$ 的 $\\mu_t = \\lambda_t \\Delta$。\n- 通过 $r_t = \\frac{n_t - \\mu_t}{\\sqrt{\\mu_t + \\varepsilon}}$ 计算皮尔逊残差。\n- 计算样本均值 $\\bar{r}$，然后按上述定义计算 $k \\in \\{1,\\dots,L\\}$ 的 $\\hat{\\rho}_k$。\n- 通过对缩放后的自相关平方求和来计算 Box–Ljung $Q$ 统计量。\n- 使用自由度为 $L$ 的卡方参考分布，计算 $p$ 值并返回一个指示是否 $p  \\alpha$ 的布尔值。\n\n测试套件解读与科学真实性：\n- 在测试用例1中，计数是从一个泊松模型生成的，其期望计数与拟合强度相同，因此残差应近似为白噪声，检验通常不应拒绝原假设。\n- 在测试用例2中，计数由一个具有正依赖性的二元马尔可夫过程生成，而拟合强度是恒定的且未包含耦合，因此残差应显示出正的延迟1自相关，导致拒绝原假设。\n- 在测试用例3中，计数具有确定性的阵发性结构，包含连续的1和0，而拟合强度未能捕捉到这种结构（包括一个 $\\lambda_t = 0$ 的段）。残差将在阵发内部表现出正自相关，综合检验应拒绝原假设，而 $\\varepsilon$ 确保了在零强度时间窗内的数值稳定性。\n\n该程序为指定参数实现了这些步骤，并以 $[result1,result2,result3]$ 的格式打印单行输出，其中每个条目是一个布尔值，指示是否使用最大延迟为 $L$ 的 Box–Ljung 统计量在 $\\alpha$ 水平上检测到残差自相关。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef pearson_residuals(counts, lambdas, delta, epsilon=1e-12):\n    \"\"\"\n    Compute Pearson residuals r_t = (n_t - mu_t) / sqrt(mu_t + epsilon),\n    where mu_t = lambda_t * delta.\n    \"\"\"\n    mu = lambdas * delta\n    # Residuals with numerical stabilizer for zero expected counts\n    resid = (counts - mu) / np.sqrt(mu + epsilon)\n    return resid\n\ndef sample_autocorrelations(x, max_lag):\n    \"\"\"\n    Compute sample autocorrelations rho_k for k=1..max_lag.\n    Uses mean-centered sequence and variance normalization.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    T = x.shape[0]\n    m = x.mean()\n    x_centered = x - m\n    var = np.sum(x_centered ** 2) / T\n    # If variance is numerically zero, return zeros to avoid division by zero\n    if var == 0.0:\n        return np.zeros(max_lag, dtype=float)\n    rhos = []\n    for k in range(1, max_lag + 1):\n        cov = np.sum(x_centered[k:] * x_centered[:-k]) / T\n        rhos.append(cov / var)\n    return np.array(rhos, dtype=float)\n\ndef box_ljung_q(rhos, T):\n    \"\"\"\n    Compute the Box-Ljung Q statistic for given autocorrelations rhos (lags 1..L)\n    and series length T.\n    Q = T(T+2) sum_{k=1}^L rhos_k^2 / (T - k)\n    \"\"\"\n    L = len(rhos)\n    denom = np.array([T - k for k in range(1, L + 1)], dtype=float)\n    Q = T * (T + 2) * np.sum((rhos ** 2) / denom)\n    return Q\n\ndef test_case_1():\n    # Well-specified model: Poisson counts matching fitted intensity\n    delta = 0.01\n    T = 10000\n    lam = 20.0\n    lambdas = np.full(T, lam, dtype=float)\n    rng = np.random.default_rng(12345)\n    mu = lam * delta\n    counts = rng.poisson(mu, size=T)\n    L = 1\n    alpha = 0.05\n    eps = 1e-12\n    resid = pearson_residuals(counts, lambdas, delta, eps)\n    rhos = sample_autocorrelations(resid, L)\n    Q = box_ljung_q(rhos, T)\n    pval = chi2.sf(Q, df=L)\n    return pval  alpha\n\ndef test_case_2():\n    # Model misfit: binary Markov counts with positive dependence; fitted intensity constant\n    delta = 0.01\n    T = 4000\n    lam = 20.0\n    lambdas = np.full(T, lam, dtype=float)\n    p0 = 0.1\n    p1 = 0.5\n    rng = np.random.default_rng(54321)\n    counts = np.zeros(T, dtype=int)\n    # Initialize state\n    state = 0\n    counts[0] = state\n    for t in range(1, T):\n        if state == 0:\n            state = 1 if rng.random()  p0 else 0\n        else:\n            state = 1 if rng.random()  p1 else 0\n        counts[t] = state\n    L = 1\n    alpha = 0.05\n    eps = 1e-12\n    resid = pearson_residuals(counts, lambdas, delta, eps)\n    rhos = sample_autocorrelations(resid, L)\n    Q = box_ljung_q(rhos, T)\n    pval = chi2.sf(Q, df=L)\n    return pval  alpha\n\ndef test_case_3():\n    # Edge case: zero predicted intensity segment and deterministic bursts\n    delta = 0.01\n    T = 800\n    lambdas = np.zeros(T, dtype=float)\n    lambdas[100:] = 5.0\n    counts = np.zeros(T, dtype=int)\n    # Bursty pattern: for t >= 101, repeat [1,1,1,1,0,0,0,0]\n    pattern = [1, 1, 1, 1, 0, 0, 0, 0]\n    idx = 100\n    while idx  T:\n        for v in pattern:\n            if idx >= T:\n                break\n            counts[idx] = v\n            idx += 1\n    L = 1\n    alpha = 0.05\n    eps = 1e-12\n    resid = pearson_residuals(counts, lambdas, delta, eps)\n    rhos = sample_autocorrelations(resid, L)\n    Q = box_ljung_q(rhos, T)\n    pval = chi2.sf(Q, df=L)\n    return pval  alpha\n\ndef solve():\n    results = []\n    results.append(test_case_1())\n    results.append(test_case_2())\n    results.append(test_case_3())\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}