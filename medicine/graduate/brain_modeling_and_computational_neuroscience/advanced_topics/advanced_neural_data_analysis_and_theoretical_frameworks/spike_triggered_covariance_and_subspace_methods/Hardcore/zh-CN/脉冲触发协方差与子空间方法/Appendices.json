{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究高级算法的复杂性之前，一个有启发性的第一步是直面神经科学数据的庞大规模所带来的实际挑战。这项练习  作为一个重要的“纸上谈兵”计算，揭示了“维度灾难”在分析时空刺激时的具体体现。通过量化存储原始脉冲触发样本和完整协方差矩阵所需的巨大内存，您将亲身体会到为什么寻找低维结构的子空间方法（如脉冲触发协方差）不仅是理论上的优雅，更是计算上的必需。",
            "id": "4021279",
            "problem": "一个单神经元编码模型受到一个高维时空刺激的探测，其中每个刺激帧由一个大小为 $128 \\times 128$ 的二维像素网格组成，且该神经元对过去 $20$ 个帧敏感。每个时空刺激样本被向量化为一个维度为 $D$ 的列向量，其中 $D$ 等于时空像素的总数。在实验过程中，记录了 $S = 100{,}000$ 个脉冲，并将脉冲触发的样本集收集为一个脉冲触发样本矩阵，每行对应一个脉冲。所有数组都以双精度存储，每个浮点数为 $64$ 位。使用 $1 \\ \\text{gigabyte (GB)} = 10^{9}$ 字节。\n\n你将分析脉冲触发平均（STA）和脉冲触发协方差（STC）估计的内存需求，然后提出一种低秩子空间压缩方法。\n\n基于以下标准定义进行推导：\n- STA 是脉冲触发样本的经验均值，是 $\\mathbb{R}^{D}$ 中的一个向量。\n- STC 是脉冲触发样本的经验协方差，是 $\\mathbb{R}^{D \\times D}$ 中的一个对称矩阵。\n- 要显式存储脉冲触发样本矩阵，需要存储 $S$ 个样本，每个样本的维度为 $D$。\n\n首先，计算刺激维度 $D$，然后计算存储以下内容所需的内存：\n1. 脉冲触发样本矩阵。\n2. 完整的 STC 矩阵。\n\n接下来，提出一种低秩 STC 表示法，该表示法仅存储 STA、STC 的前 $r$ 个特征向量（这些特征向量作为 $\\mathbb{R}^{D \\times r}$ 矩阵的列）以及它们对应的 $r$ 个特征值（存储在一个向量中）。假设 STC 特征值谱按几何级数衰减，即 $\\lambda_{i} = \\lambda_{1} \\alpha^{i-1}$，其中公比 $\\alpha = 0.9$，$i = 1, 2, \\dots, D$，并且 $D$ 足够大，以至于几何级数近似有效。确定最小的整数 $r$，使得前 $r$ 个特征值解释的方差比例至少为 $0.95$。然后，计算这种压缩表示（STA、前 $r$ 个特征向量和前 $r$ 个特征值）所需的总内存。\n\n以 GB 为单位表示压缩表示的最终内存需求。将最终答案四舍五入到四位有效数字。",
            "solution": "用户提供了一个有效的问题陈述。任务是分析脉冲触发平均（STA）和脉冲触发协方差（STC）分析的内存需求，并确定 STC 的压缩低秩表示所需的内存。\n\n首先，我们确定时空刺激向量的维度 $D$。每个刺激样本覆盖一个 $128 \\times 128$ 像素的空间网格，时间窗口为 $20$ 帧。定义维度 $D$ 的时空像素总数是这些值的乘积。\n$$D = (\\text{空间像素数}) \\times (\\text{时间帧数}) = (128 \\times 128) \\times 20 = 16{,}384 \\times 20 = 327{,}680$$\n\n接下来，我们计算存储完整的脉冲触发数据集和完整的 STC 矩阵所需的内存。问题陈述中说明所有数字都以双精度存储，即每个数字 $64$ 位或 $8$ 字节。\n\n1.  **脉冲触发样本矩阵的内存：**\n    脉冲触发样本矩阵有 $S = 100{,}000$ 行，每行对应一个脉冲；有 $D = 327{,}680$ 列，每列对应一个刺激维度。该矩阵中的元素总数为 $S \\times D$。\n    所需的内存 $M_{\\text{samples}}$ 为：\n    $$M_{\\text{samples}} = S \\times D \\times (\\text{每个数字的字节数})$$\n    $$M_{\\text{samples}} = 100{,}000 \\times 327{,}680 \\times 8 \\ \\text{字节} = 262{,}144{,}000{,}000 \\ \\text{字节}$$\n    使用换算关系 $1 \\ \\text{GB} = 10^9 \\ \\text{字节}$，这相当于 $262.144 \\ \\text{GB}$。\n\n2.  **完整 STC 矩阵的内存：**\n    STC 矩阵是 $\\mathbb{R}^{D \\times D}$ 中的一个对称矩阵。在不利用其对称性的情况下存储完整矩阵需要存储 $D^2$ 个元素。\n    所需的内存 $M_{\\text{STC}}$ 为：\n    $$M_{\\text{STC}} = D^2 \\times (\\text{每个数字的字节数})$$\n    $$M_{\\text{STC}} = (327{,}680)^2 \\times 8 \\ \\text{字节} = 107{,}374{,}182{,}400 \\times 8 \\ \\text{字节} = 858{,}993{,}459{,}200 \\ \\text{字节}$$\n    这大约相当于 $859 \\ \\text{GB}$。原始数据和完整协方差矩阵的巨大内存占用促使我们使用压缩表示。\n\n接下来，我们确定低秩近似的秩 $r$。由前 $r$ 个特征向量解释的方差比例 $F(r)$ 是前 $r$ 个特征值之和与所有特征值之和的比率。\n$$F(r) = \\frac{\\sum_{i=1}^{r} \\lambda_i}{\\sum_{i=1}^{D} \\lambda_i}$$\n特征值由公比为 $\\alpha = 0.9$ 的几何级数 $\\lambda_i = \\lambda_1 \\alpha^{i-1}$ 建模。前 $r$ 个特征值之和是一个部分几何级数：\n$$\\sum_{i=1}^{r} \\lambda_i = \\sum_{i=1}^{r} \\lambda_1 \\alpha^{i-1} = \\lambda_1 \\sum_{j=0}^{r-1} \\alpha^j = \\lambda_1 \\frac{1-\\alpha^r}{1-\\alpha}$$\n问题陈述中说明 $D$ 足够大，可以将总和近似为无穷几何级数：\n$$\\sum_{i=1}^{D} \\lambda_i \\approx \\sum_{i=1}^{\\infty} \\lambda_i = \\lambda_1 \\sum_{j=0}^{\\infty} \\alpha^j = \\frac{\\lambda_1}{1-\\alpha}$$\n因此，解释的方差比例为：\n$$F(r) \\approx \\frac{\\lambda_1 (1-\\alpha^r)/(1-\\alpha)}{\\lambda_1/(1-\\alpha)} = 1 - \\alpha^r$$\n我们需要找到最小的整数 $r$，使得解释的方差比例至少为 $0.95$：\n$$1 - \\alpha^r \\ge 0.95$$\n代入 $\\alpha = 0.9$：\n$$1 - (0.9)^r \\ge 0.95$$\n$$(0.9)^r \\le 0.05$$\n为了解出 $r$，我们对两边取自然对数。由于 $\\ln(0.9)$ 是负数，我们必须反转不等号：\n$$r \\ln(0.9) \\le \\ln(0.05)$$\n$$r \\ge \\frac{\\ln(0.05)}{\\ln(0.9)}$$\n使用数值：\n$$r \\ge \\frac{-2.99573...}{-0.10536...} \\approx 28.433$$\n由于 $r$ 必须是整数，满足此条件的最小值为 $r = 29$。\n\n最后，我们计算压缩表示所需的总内存。该表示存储：\n1.  STA 向量，有 $D$ 个元素。\n2.  前 $r$ 个特征向量，存储为一个 $D \\times r$ 矩阵，有 $D \\times r$ 个元素。\n3.  前 $r$ 个特征值，有 $r$ 个元素。\n\n需要存储的浮点值总数 $N_{\\text{comp}}$ 为：\n$$N_{\\text{comp}} = D + (D \\times r) + r = D(1+r) + r$$\n代入 $D = 327{,}680$ 和 $r = 29$：\n$$N_{\\text{comp}} = 327{,}680 \\times (1+29) + 29 = 327{,}680 \\times 30 + 29$$\n$$N_{\\text{comp}} = 9{,}830{,}400 + 29 = 9{,}830{,}429$$\n压缩表示所需的总内存 $M_{\\text{comp}}$ 是值的数量乘以每个值的大小（$8$ 字节）：\n$$M_{\\text{comp}} = 9{,}830{,}429 \\times 8 \\ \\text{字节} = 78{,}643{,}432 \\ \\text{字节}$$\n为了以千兆字节（GB）表示，我们除以 $10^9$：\n$$M_{\\text{comp}} = \\frac{78{,}643{,}432}{10^9} \\ \\text{GB} = 0.078643432 \\ \\text{GB}$$\n四舍五入到四位有效数字，我们得到 $0.07864 \\ \\text{GB}$。",
            "answer": "$$\\boxed{0.07864}$$"
        },
        {
            "introduction": "在确定了降维的必要性之后，下一步是确保我们的分析不会被神经元内在的动力学所污染。这项练习  解决了脉冲触发分析中一个常见的陷阱：脉冲历史效应（如不应期或爆发性发放）可能与外部刺激产生混淆。您将推导出一个数学框架，通过将刺激投影到与历史预测因子正交的补空间上，来“净化”刺激数据，从而学习到在执行任何协方差分析之前进行数据预处理的关键一步，以确保结果的可解释性。",
            "id": "4021328",
            "problem": "考虑一个实验，其中一个神经元由高维刺激驱动并表现出脉冲历史效应。在时间索引 $t$ 处的刺激是一个 $3$ 维向量 $s_t \\in \\mathbb{R}^3$，脉冲历史特征向量 $h_t \\in \\mathbb{R}^2$ 包含两个编码近期脉冲发放的预测变量 $h_{1,t}$ 和 $h_{2,t}$。假设 $(s_t, h_t)$ 是联合零均值和二阶平稳的，具有明确定义的协方差。\n\n令 $C_{ss} \\in \\mathbb{R}^{3 \\times 3}$、$C_{hh} \\in \\mathbb{R}^{2 \\times 2}$ 和 $C_{sh} \\in \\mathbb{R}^{3 \\times 2}$ 分别表示无条件刺激协方差、历史协方差和刺激-历史互协方差。刺激的脉冲触发协方差 (Spike-Triggered Covariance, STC) 定义为 $C_{ss|\\text{spike}} - C_{ss}$，即脉冲前刺激的协方差与无条件刺激协方差之差。\n\n为了减轻来自脉冲历史的混淆，可以在计算 STC 之前，通过将刺激投影到历史预测变量的正交补上，来回归去除 $s_t$ 中可从历史线性预测的分量。在二阶平稳性下的总体（无限样本）极限中，去除历史线性可预测性的正交投影等价于通过从 $s_t$ 中减去其基于 $h_t$ 的最佳线性预测来对 $s_t$ 进行残差化。将残差化刺激表示为 $s_t^{\\perp} = s_t - B h_t$，其中选择 $B \\in \\mathbb{R}^{3 \\times 2}$ 以最小化期望平方预测误差。\n\n假设真实的协方差为\n$$\nC_{ss} = \\begin{pmatrix}\n2.0  & 0.5  & 0.3 \\\\\n0.5  & 1.5  & 0.2 \\\\\n0.3  & 0.2  & 1.0\n\\end{pmatrix}, \\quad\nC_{hh} = \\begin{pmatrix}\n1.0  & 0.3 \\\\\n0.3  & 0.8\n\\end{pmatrix}, \\quad\nC_{sh} = \\begin{pmatrix}\n0.4  & 0.2 \\\\\n0.1  & 0.3 \\\\\n0.2  & 0.1\n\\end{pmatrix}.\n$$\n\n现在考虑一个错误设定的回归，在残差化时仅包含第一个历史预测变量 $h_{1,t}$。令 $u_t = h_{1,t}$ 且 $v_t = h_{2,t}$。在这种情况下，残差化变换仅使用 $u_t$，得到 $s_t^{\\perp u} = s_t - B_u u_t$，其中 $B_u \\in \\mathbb{R}^{3 \\times 1}$ 仅使用 $u_t$ 来最小化期望平方误差。关于被忽略的预测变量 $v_t$ 的残余混淆，可以通过残余刺激-历史与 $v_t$ 的互协方差的范数与原始与 $v_t$ 的互协方差的范数之比来量化：\n$$\n\\gamma \\equiv \\frac{\\|C_{s^{\\perp u} v}\\|_{2}}{\\|C_{s v}\\|_{2}},\n$$\n其中 $C_{s v} \\in \\mathbb{R}^{3 \\times 1}$ 是 $C_{sh}$ 的第二列，而 $C_{s^{\\perp u} v}$ 是 $s_t^{\\perp u}$ 和 $v_t$ 之间的互协方差。\n\n从协方差、正交投影和最小二乘回归的核心定义出发，推导总体最优残差化变换 $s_t^{\\perp} = s_t - B h_t$ 作为到历史预测变量正交补上的投影，解释这如何与在残差化刺激上计算 STC 相关联，然后，对于使用 $u_t$ 的错误设定的单预测变量残差化，使用给定的协方差计算标量残余混淆指数 $\\gamma$。\n\n将最终的标量表示为一个无量纲数，并将答案四舍五入到四位有效数字。",
            "solution": "我们从基本定义开始。刺激 $s_t \\in \\mathbb{R}^3$ 和历史 $h_t \\in \\mathbb{R}^2$ 是联合零均值的，其无条件二阶矩由 $C_{ss}$、$C_{hh}$ 和 $C_{sh}$ 表示。脉冲触发协方差 (STC) 定义为差值 $C_{ss|\\text{spike}} - C_{ss}$，它捕捉与脉冲发放相关的二阶刺激特征。当 $s_t$ 和 $h_t$ 相关时，会出现脉冲历史混淆，导致 STC 反映的是可归因于历史而非刺激选择性的方差结构。\n\n为了回归去除历史的影响，我们使用正交投影原理：对于给定的预测变量矩阵（此处为历史特征），最小二乘残差与预测变量子空间正交。在总体极限中，可以通过使用二阶矩来陈述这种等价性，而无需参考有限样本的设计矩阵。\n\n考虑一个形式为 $B h_t$（其中 $B \\in \\mathbb{R}^{3 \\times 2}$）的、基于 $h_t$ 对 $s_t$ 的线性预测器。均方意义下的最佳线性预测器最小化期望平方误差\n$$\n\\mathbb{E}\\big[ \\| s_t - B h_t \\|_2^2 \\big].\n$$\n对 $B$ 求导并将梯度设为零，得到正规方程\n$$\n\\frac{\\partial}{\\partial B} \\mathbb{E}\\big[ \\| s_t - B h_t \\|_2^2 \\big] = -2 \\, \\mathbb{E}\\big[ s_t h_t^{\\top} \\big] + 2 \\, B \\, \\mathbb{E}\\big[ h_t h_t^{\\top} \\big] = -2 C_{sh} + 2 B C_{hh} = 0,\n$$\n这意味着\n$$\nB C_{hh} = C_{sh} \\quad \\Longrightarrow \\quad B = C_{sh} C_{hh}^{-1}.\n$$\n因此，在最小二乘意义下与历史预测变量子空间正交的残差化刺激是\n$$\ns_t^{\\perp} = s_t - C_{sh} C_{hh}^{-1} h_t.\n$$\n根据构造，该残差满足\n$$\n\\mathbb{E}\\big[ s_t^{\\perp} h_t^{\\top} \\big] = \\mathbb{E}\\big[ s_t h_t^{\\top} \\big] - C_{sh} C_{hh}^{-1} \\mathbb{E}\\big[ h_t h_t^{\\top} \\big] = C_{sh} - C_{sh} C_{hh}^{-1} C_{hh} = 0,\n$$\n因此 $s_t^{\\perp}$ 在二阶意义上与 $h_t$ 正交。因此，在 $s_t^{\\perp}$ 上计算 STC 会移除 $s_t$ 中可从 $h_t$ 线性预测的方差分量，这与旨在分离不受历史污染的刺激信息维度的子空间方法相一致。\n\n我们现在分析一个错误设定的残差化，它仅使用第一个历史分量 $u_t = h_{1,t}$。单预测变量的最小二乘解为\n$$\nB_u = \\arg\\min_{b \\in \\mathbb{R}^{3 \\times 1}} \\mathbb{E}\\big[ \\| s_t - b \\, u_t \\|_2^2 \\big].\n$$\n正规方程简化为\n$$\nb \\, \\mathbb{E}\\big[ u_t^2 \\big] = \\mathbb{E}\\big[ s_t u_t \\big] \\quad \\Longrightarrow \\quad B_u = C_{s u} C_{u u}^{-1},\n$$\n其中 $C_{s u} \\in \\mathbb{R}^{3 \\times 1}$ 是 $C_{sh}$ 的第一列，$C_{u u} \\in \\mathbb{R}$ 是 $C_{hh}$ 的 $(1,1)$ 项。残差化刺激为\n$$\ns_t^{\\perp u} = s_t - C_{s u} C_{u u}^{-1} u_t.\n$$\n$s_t^{\\perp u}$ 与被忽略的预测变量 $v_t = h_{2,t}$ 之间的互协方差则为\n$$\nC_{s^{\\perp u} v} = \\mathbb{E}\\big[ s_t^{\\perp u} v_t \\big] = \\mathbb{E}\\big[ s_t v_t \\big] - C_{s u} C_{u u}^{-1} \\mathbb{E}\\big[ u_t v_t \\big] = C_{s v} - C_{s u} C_{u u}^{-1} C_{u v},\n$$\n其中 $C_{s v} \\in \\mathbb{R}^{3 \\times 1}$ 是 $C_{sh}$ 的第二列，$C_{u v}$ 是 $C_{hh}$ 的 $(1,2)$ 项。该表达式量化了由于忽略历史预测变量而产生的残余混淆。\n\n我们定义残余混淆指数\n$$\n\\gamma \\equiv \\frac{\\|C_{s^{\\perp u} v}\\|_{2}}{\\|C_{s v}\\|_{2}},\n$$\n当残差化减少了与 $v_t$ 的相关性时，该指数是无量纲的，且值在 $[0,1]$ 区间内。\n\n使用给定的协方差，\n$$\nC_{s u} = \\begin{pmatrix} 0.4 \\\\ 0.1 \\\\ 0.2 \\end{pmatrix}, \\quad\nC_{s v} = \\begin{pmatrix} 0.2 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}, \\quad\nC_{u u} = 1.0, \\quad\nC_{u v} = 0.3.\n$$\n因此\n$$\nC_{s^{\\perp u} v} = C_{s v} - C_{s u} C_{u u}^{-1} C_{u v} = \\begin{pmatrix} 0.2 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix} - 0.3 \\begin{pmatrix} 0.4 \\\\ 0.1 \\\\ 0.2 \\end{pmatrix} = \\begin{pmatrix} 0.08 \\\\ 0.27 \\\\ 0.04 \\end{pmatrix}.\n$$\n计算平方范数：\n$$\n\\|C_{s v}\\|_2^2 = 0.2^2 + 0.3^2 + 0.1^2 = 0.14, \\quad\n\\|C_{s^{\\perp u} v}\\|_2^2 = 0.08^2 + 0.27^2 + 0.04^2 = 0.0809.\n$$\n因此，\n$$\n\\gamma = \\frac{\\|C_{s^{\\perp u} v}\\|_{2}}{\\|C_{s v}\\|_{2}} = \\sqrt{\\frac{0.0809}{0.14}} = \\sqrt{\\frac{809}{1400}} \\approx 0.760169733\\ldots\n$$\n四舍五入到四位有效数字，残余混淆指数为 $0.7602$。",
            "answer": "$$\\boxed{0.7602}$$"
        },
        {
            "introduction": "在掌握了处理大规模数据和校正伪影的策略后，我们现在可以将这些技能付诸实践，进行一次完整的、具有统计学严谨性的脉冲触发协方差（STC）分析。这项编码练习  是一个综合性的实践，它将引导您完成从模拟数据到识别显著刺激维度的整个流程。您不仅将计算STC矩阵的特征值，更重要的是，您将实施一个置换检验来评估这些特征值的统计显著性，同时通过控制族群错误率（FWER）来解决多重比较问题，从而确保您发现的子空间是真实的神经编码特征，而不仅仅是随机噪声。",
            "id": "4021308",
            "problem": "你需要实现、分析并测试一个基于置换的推断程序，用于处理脉冲触发协方差。该程序将使用具有明确定义生成模型的合成数据。目标是估计脉冲触发协方差之差的特征值的零分布，并控制多个特征值的族系误差率（FWER）。\n\n考虑一个刺激时间序列，由 $T$ 个独立抽样 $\\{\\mathbf{x}_t\\}_{t=1}^T$ 组成，其中每个 $\\mathbf{x}_t \\in \\mathbb{R}^d$ 均从一个零均值和单位协方差的 $d$ 维标准高斯分布中抽取。一个二元脉冲序列 $\\{s_t\\}_{t=1}^T$（其中 $s_t \\in \\{0,1\\}$）由一个神经元生成，其每个时间区间的脉冲发放概率取决于刺激在两个潜在轴上的二次投影。具体来说，设 $\\mathbf{v}_1, \\mathbf{v}_2 \\in \\mathbb{R}^d$ 为标准正交单位向量。脉冲概率由以下逻辑斯谛模型给出：\n$$\np_t \\equiv \\mathbb{P}(s_t = 1 \\mid \\mathbf{x}_t) = \\sigma\\!\\left(c_0 + \\theta_1\\, (\\mathbf{v}_1^\\top \\mathbf{x}_t)^2 + \\theta_2\\, (\\mathbf{v}_2^\\top \\mathbf{x}_t)^2\\right),\n$$\n其中 $\\sigma(z) = \\frac{1}{1 + e^{-z}}$，$c_0 \\in \\mathbb{R}$ 是一个基线logit，$\\theta_1, \\theta_2 \\in \\mathbb{R}$ 是控制沿 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 轴敏感度的二次权重。脉冲 $s_t$ 作为独立的伯努利随机变量进行抽样，其成功概率为 $p_t$。\n\n将所有时间区间的经验刺激协方差定义为\n$$\n\\mathbf{C} \\equiv \\frac{1}{T} \\sum_{t=1}^{T} \\left(\\mathbf{x}_t - \\overline{\\mathbf{x}}\\right)\\left(\\mathbf{x}_t - \\overline{\\mathbf{x}}\\right)^\\top,\n$$\n其中 $\\overline{\\mathbf{x}} = \\frac{1}{T} \\sum_{t=1}^{T} \\mathbf{x}_t$ 是经验均值。将脉冲触发协方差定义为\n$$\n\\mathbf{C}_{\\text{spike}} \\equiv \\frac{1}{N_s} \\sum_{t: s_t = 1} \\left(\\mathbf{x}_t - \\overline{\\mathbf{x}}_{\\text{spike}}\\right)\\left(\\mathbf{x}_t - \\overline{\\mathbf{x}}_{\\text{spike}}\\right)^\\top,\n$$\n其中 $N_s = \\sum_{t=1}^T s_t$ 是总脉冲数，$\\overline{\\mathbf{x}}_{\\text{spike}} = \\frac{1}{N_s} \\sum_{t: s_t = 1} \\mathbf{x}_t$ 是脉冲发放期间的平均刺激。脉冲触发协方差之差为\n$$\n\\Delta \\mathbf{C} \\equiv \\mathbf{C}_{\\text{spike}} - \\mathbf{C}.\n$$\n令 $\\lambda_1(\\Delta \\mathbf{C}), \\ldots, \\lambda_d(\\Delta \\mathbf{C})$ 表示 $\\Delta \\mathbf{C}$ 的特征值，按绝对值降序排列，即 $|\\lambda_1| \\geq |\\lambda_2| \\geq \\cdots \\geq |\\lambda_d|$。\n\n在脉冲时间与刺激无关的零假设下，$\\Delta \\mathbf{C}$ 的分布以零为中心，因此其特征值反映的是随机波动。为估计零分布，应用一个置换检验，该检验通过重排脉冲时间，同时保持总脉冲数不变。对于每次置换，计算置换后的 $\\Delta \\mathbf{C}$，提取其特征值，并记录前 $k$ 个特征值中的最大绝对特征值统计量。使用这个最大值类型统计量的经验零分布，来将对 $k$ 个被测特征值的族系误差率（FWER）控制在水平 $\\alpha_{\\mathrm{FWER}}$。\n\n你的程序必须：\n\n- 对每个测试用例，使用指定的参数模拟刺激和脉冲序列。\n- 为观测到的脉冲序列计算 $\\Delta \\mathbf{C}$ 及其特征值。\n- 通过随机置换脉冲序列 $\\{s_t\\}$（即随机重排脉冲指示符）执行 $B$ 次置换，每次置换都重新计算 $\\Delta \\mathbf{C}$ 及前 $k$ 个特征值中的最大绝对特征值。\n- 构建最大值类型统计量的经验零分布，并使用置换分布的 $(1-\\alpha_{\\mathrm{FWER}})$ 分位数确定在水平 $\\alpha_{\\mathrm{FWER}}$ 控制FWER的阈值。\n- 如果前 $k$ 个观测特征值中某个的绝对值超过该阈值，则宣布其为显著。返回前 $k$ 个特征值中显著特征值的总数。\n\n实现细节和科学基础：\n\n- 数学基础包括零假设下的独立性和可交换性、协方差和特征分解的性质，以及置换检验的基本原理。\n- 族系误差率（FWER）通过最大值类型检验进行控制：将每个检验统计量与最大统计量的零分布的 $(1-\\alpha_{\\mathrm{FWER}})$ 分位数进行比较，可确保对 $k$ 个假设中的任何一个都有强有力的控制。\n\n测试套件：\n\n提供以下四个测试用例，每个用例由元组 $(r, d, T, c_0, \\theta_1, \\theta_2, B, k, \\alpha_{\\mathrm{FWER}})$ 指定，其中 $r$ 是用于确保可复现性的随机种子。\n\n1. 基线理想情况，具有两个信息丰富的二次轴：\n   - $(2025, 12, 40000, -5.5, 1.5, 1.0, 100, 4, 0.05)$\n\n2. 零依赖情况（无刺激敏感度）：\n   - $(77, 12, 40000, -4.0, 0.0, 0.0, 100, 4, 0.05)$\n\n3. 低脉冲数边缘情况（稀疏脉冲）：\n   - $(310, 8, 30000, -7.0, 1.5, 1.0, 100, 4, 0.05)$\n\n4. 更高维度，中等敏感度：\n   - $(88, 20, 50000, -5.0, 0.8, 0.6, 100, 6, 0.05)$\n\n最终输出规格：\n\n- 对于每个测试用例，你的程序必须输出一个整数，等于在使用最大值类型置换阈值进行FWER控制后，前 $k$ 个特征值中显著的特征值数量。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[2,0,0,1]”）。\n\n此问题不涉及物理单位。不出现角度。输出中的任何分数或概率必须通过整数计数隐式表示；不允许使用百分号。",
            "solution": "该问题提出了计算神经科学领域一个有效且适定的挑战，要求实现脉冲触发协方差（STC）分析，并结合基于置换的假设检验来控制族系误差率（FWER）。该问题具有科学依据，采用了标准模型（带有二次项的广义线性模型）和统计技术（置换检验、用于FWER控制的最大值类型检验）。所有参数和程序都定义清晰，从而能够得出唯一且可验证的解。\n\n### 数学和程序框架\n\n**1. 生成模型**\n\n生成一个合成数据集以模拟真实的神经科学实验。在每个时间点 $t \\in \\{1, \\dots, T\\}$ 的刺激 $\\mathbf{x}_t \\in \\mathbb{R}^d$ 是从一个 $d$ 维各向同性高斯分布 $\\mathbf{x}_t \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})$ 中独立抽取的。神经元的脉冲概率 $p_t$ 通过刺激在两个标准正交向量 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 上的投影，经由逻辑斯谛模型进行调制：\n\n$$\np_t = \\sigma\\!(c_0 + \\theta_1 (\\mathbf{v}_1^\\top \\mathbf{x}_t)^2 + \\theta_2 (\\mathbf{v}_2^\\top \\mathbf{x}_t)^2)\n$$\n\n其中 $\\sigma(z) = (1 + e^{-z})^{-1}$ 是逻辑斯谛函数，$c_0$ 是基线发放参数，$\\theta_1$ 和 $\\theta_2$ 分别控制对沿 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 轴的刺激方差的敏感度。脉冲 $s_t=1$ 是通过成功概率为 $p_t$ 的伯努利试验生成的。由于刺激分布是各向同性的，标准正交对 $(\\mathbf{v}_1, \\mathbf{v}_2)$ 的具体选择不会改变问题的统计特性。我们可以在不失一般性的情况下，将它们与前两个标准基向量 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 对齐。\n\n**2. 脉冲触发协方差（STC）分析**\n\nSTC旨在寻找那些能引发脉冲的刺激的方差与背景刺激方差有差异的刺激维度。我们计算两个协方差矩阵：\n\n- 总体刺激协方差, $\\mathbf{C}$:\n$$\n\\mathbf{C} = \\frac{1}{T} \\sum_{t=1}^{T} (\\mathbf{x}_t - \\overline{\\mathbf{x}})(\\mathbf{x}_t - \\overline{\\mathbf{x}})^\\top\n$$\n- 脉冲触发协方差, $\\mathbf{C}_{\\text{spike}}$:\n$$\n\\mathbf{C}_{\\text{spike}} = \\frac{1}{N_s} \\sum_{t: s_t = 1} (\\mathbf{x}_t - \\overline{\\mathbf{x}}_{\\text{spike}})(\\mathbf{x}_t - \\overline{\\mathbf{x}}_{\\text{spike}})^\\top\n$$\n其中 $N_s$ 是总脉冲数，$\\overline{\\mathbf{x}}$ 是平均刺激，$\\overline{\\mathbf{x}}_{\\text{spike}}$ 是脉冲触发的平均刺激。\n\n差值 $\\Delta \\mathbf{C} = \\mathbf{C}_{\\text{spike}} - \\mathbf{C}$ 分离出了协方差的变化。$\\Delta \\mathbf{C}$ 对应于大绝对值特征值的特征向量标识了我们感兴趣的刺激维度。在我们的模型中，正的 $\\theta_1$ 和 $\\theta_2$ 意味着在 $\\mathbf{v}_1$ 和 $\\mathbf{v}_2$ 上有较大投影的刺激更有可能引发脉冲。这会增加脉冲触发集合沿这些方向的方差，导致 $\\Delta \\mathbf{C}$ 的特征向量与 $\\mathbf{v}_1, \\mathbf{v}_2$ 对齐，并具有正的特征值。\n\n**3. 用于统计显著性检验的置换检验**\n\n为评估观测到的 $\\Delta \\mathbf{C}$ 特征值是否具有统计显著性，或仅仅是随机抽样所致，我们采用置换检验。\n\n- **零假设 ($H_0$)**：脉冲时间独立于刺激。在 $H_0$ 下，$\\Delta \\mathbf C$ 的期望是零矩阵，任何观测到的非零特征值都是噪声。\n- **置换原理**：通过随机置换脉冲序列 $\\{s_t\\}$，我们打破了刺激 $\\mathbf{x}_t$ 和脉冲 $s_t$ 之间的时间关联，从而有效地创建了符合零假设的代理数据。此过程保留了总脉冲数和刺激的边际统计量，为估计我们的检验统计量的零分布提供了一种强大的非参数方法。\n\n**4. 族系误差率（FWER）控制**\n\n我们同时检验 $k$ 个假设，每个假设对应前 $k$ 个（按绝对值排序的）特征值之一。为避免假阳性率膨胀，我们必须控制FWER——即犯至少一次第一类错误的概率。我们使用单步最大值类型程序：\n\n- **检验统计量**：观测到的检验统计量是观测到的 $\\Delta \\mathbf{C}$ 的前 $k$ 个特征值的绝对值，记为 $\\{|\\lambda_i|\\}_{i=1}^k$。\n- **最大值的零分布**：对于 $B$ 次置换中的每一次，我们计算一个置换后的协方差差值 $\\Delta \\mathbf{C}^*$ 及其特征值。然后我们记录最大绝对特征值 $m^* = \\max_{j=1,\\ldots,d} |\\lambda_j^*|$。这等价于从按绝对值大小排序的置换特征值中找到 $|\\lambda_1^*|$。这 $B$ 个值的集合 $\\{m^*_1, \\dots, m^*_B\\}$，为可能的最极端特征值构成了一个经验零分布。\n- **阈值设定**：我们将单个显著性阈值 $c_{\\text{crit}}$ 设为此最大值经验分布的 $(1-\\alpha_{\\mathrm{FWER}})$ 分位数。\n- **决策规则**：如果观测到的特征值 $\\lambda_i$ 的绝对值 $|\\lambda_i|$ 超过这个通用且严格的阈值 $c_{\\text{crit}}$，我们就宣布其为显著。此过程可在水平 $\\alpha_{\\mathrm{FWER}}$ 上对FWER提供强有力的控制。\n\n### 算法实现步骤\n\n1.  **初始化**：对每个测试用例，设置随机种子 $r$ 和参数 $(d, T, c_0, \\theta_1, \\theta_2, B, k, \\alpha_{\\mathrm{FWER}})$。\n2.  **生成数据**：\n    -   从 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I})$ 生成 $T \\times d$ 的刺激矩阵 $\\mathbf{X}$。\n    -   选择 $\\mathbf{v}_1 = \\mathbf{e}_1$ 和 $\\mathbf{v}_2 = \\mathbf{e}_2$。\n    -   根据生成模型计算脉冲概率 $p_t$。\n    -   生成长度为 $T$ 的二元脉冲序列 $s_t$。\n3.  **计算观测统计量**：\n    -   计算观测到的 $\\Delta \\mathbf{C} = \\mathbf{C}_{\\text{spike}} - \\mathbf{C}$。\n    -   计算 $\\Delta \\mathbf{C}$ 的特征值，并按绝对值降序排序。\n    -   提取前 $k$ 个绝对特征值，$\\{l\\lambda_i|\\}_{i=1}^k$。\n4.  **生成零分布**：\n    -   为零分布统计量初始化一个空列表。\n    -   循环 $B$ 次：\n        -   通过打乱 $s_t$ 创建一个置换后的脉冲序列 $s_t^*$。\n        -   计算置换后的协方差差值 $\\Delta \\mathbf{C}^*$。\n        -   找到 $\\Delta \\mathbf{C}^*$ 的最大绝对特征值并将其附加到列表中。\n5.  **确定显著性**：\n    -   计算阈值 $c_{\\text{crit}}$，即所生成零分布的 $(1-\\alpha_{\\mathrm{FWER}})$ 百分位数。\n    -   计算 $k$ 个观测绝对特征值 $|\\lambda_i|$ 中有多少个大于 $c_{\\text{crit}}$。\n    -   返回此计数。\n对问题陈述中提供的每个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import expit\n\ndef run_stc_permutation_test(r, d, T, c0, theta1, theta2, B, k, alpha_fwer):\n    \"\"\"\n    Simulates a neuron's spike train, performs spike-triggered covariance (STC)\n    analysis, and uses a permutation test to find significant eigenvalues\n    while controlling the Family-Wise Error Rate (FWER).\n\n    Args:\n        r (int): Random seed for reproducibility.\n        d (int): Dimensionality of the stimulus space.\n        T (int): Number of time bins.\n        c0 (float): Baseline logit for spiking.\n        theta1 (float): Weight for the first quadratic feature.\n        theta2 (float): Weight for the second quadratic feature.\n        B (int): Number of permutations for the null distribution.\n        k (int): Number of top eigenvalues to test for significance.\n        alpha_fwer (float): Target Family-Wise Error Rate.\n\n    Returns:\n        int: The number of significant eigenvalues among the top k.\n    \"\"\"\n    rng = np.random.default_rng(r)\n\n    # Step 1: Simulate stimuli and spike train\n    # Due to the isotropic stimulus distribution N(0, I), we can choose v1 and v2\n    # to be the first two standard basis vectors without loss of generality.\n    v1 = np.zeros(d)\n    v1[0] = 1.0\n    v2 = np.zeros(d)\n    v2[1] = 1.0\n\n    X = rng.standard_normal(size=(T, d))\n    \n    proj1_sq = (X @ v1)**2\n    proj2_sq = (X @ v2)**2\n\n    logits = c0 + theta1 * proj1_sq + theta2 * proj2_sq\n    p_spike = expit(logits)  # Numerically stable logistic function\n    s = rng.binomial(1, p_spike)\n\n    spike_indices = np.where(s == 1)[0]\n    Ns = len(spike_indices)\n\n    # If Ns  2, covariance is undefined. No significant dimensions can be found.\n    # This is extremely unlikely with the given test cases.\n    if Ns  2:\n        return 0\n\n    # Step 2: Compute observed Delta_C and its eigenvalues\n    X_spike = X[spike_indices]\n    \n    # Use np.cov with ddof=0 to divide by N, as per the problem's formulas.\n    # rowvar=False because our variables are columns of X.\n    C = np.cov(X, rowvar=False, ddof=0)\n    C_spike = np.cov(X_spike, rowvar=False, ddof=0)\n    delta_C = C_spike - C\n\n    # eigh is for symmetric matrices and returns eigenvalues in ascending order.\n    eigvals_obs = np.linalg.eigh(delta_C)[0]\n    \n    # Sort eigenvalues by decreasing absolute magnitude\n    sorted_indices_obs = np.argsort(np.abs(eigvals_obs))[::-1]\n    sorted_eigvals_obs = eigvals_obs[sorted_indices_obs]\n    \n    # These are the k test statistics we will evaluate\n    abs_eigvals_obs_k = np.abs(sorted_eigvals_obs[:k])\n\n    # Step 3: Build null distribution via permutations\n    max_perm_eigvals = np.zeros(B)\n    \n    for i in range(B):\n        # Permute the spike train to break stimulus-spike relationship\n        s_perm = rng.permutation(s)\n        spike_indices_perm = np.where(s_perm == 1)[0]\n        \n        X_spike_perm = X[spike_indices_perm]\n        \n        C_spike_perm = np.cov(X_spike_perm, rowvar=False, ddof=0)\n        delta_C_perm = C_spike_perm - C\n\n        eigvals_perm = np.linalg.eigh(delta_C_perm)[0]\n        \n        # For the max-T FWER control, we need the maximum of the test statistics\n        # under permutation. This is the largest absolute eigenvalue.\n        max_perm_eigvals[i] = np.max(np.abs(eigvals_perm))\n        \n    # Step 4: Determine threshold and count significant eigenvalues\n    # The threshold is the (1 - alpha) quantile of the null distribution of the max statistic.\n    threshold = np.quantile(max_perm_eigvals, 1 - alpha_fwer)\n    \n    # An observed eigenvalue is significant if its absolute value exceeds the FWER-controlling threshold.\n    significant_count = np.sum(abs_eigvals_obs_k > threshold)\n    \n    return int(significant_count)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (r, d, T, c0, theta1, theta2, B, k, alpha_fwer)\n        (2025, 12, 40000, -5.5, 1.5, 1.0, 100, 4, 0.05),\n        (77, 12, 40000, -4.0, 0.0, 0.0, 100, 4, 0.05),\n        (310, 8, 30000, -7.0, 1.5, 1.0, 100, 4, 0.05),\n        (88, 20, 50000, -5.0, 0.8, 0.6, 100, 6, 0.05)\n    ]\n\n    results = []\n    for case in test_cases:\n        count = run_stc_permutation_test(*case)\n        results.append(count)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}