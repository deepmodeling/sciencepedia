{
    "hands_on_practices": [
        {
            "introduction": "本节的实践练习旨在巩固您对阿尔茨海默病网络退化模型的理解。我们将从求解基本方程开始，然后转向分析模型行为，最后通过将模型与数据拟合来结束。这些练习将逐步引导您将理论知识应用于实际的计算问题中。\n\n这个练习  提供了一个具体的、分步的指南，用于在一个小型的示例网络上求解模型的主控方程。掌握这种基于特征分解的技术，对于理解初始的病理模式如何随着时间的推移，通过大脑的结构进行演变和扩散至关重要。",
            "id": "3962308",
            "problem": "考虑一个阿尔茨海默病（AD）病理的线性网络退化模型，其中浓度向量 $x(t) \\in \\mathbb{R}^{3}$ 在一个三区域结构网络上演化，受以下常微分方程控制\n$$\n\\frac{d}{dt}x(t) = -\\left( \\kappa L + \\lambda I \\right) x(t),\n$$\n其中扩散强度 $\\kappa > 0$，均匀清除率 $\\lambda > 0$，图拉普拉斯算子 $L \\in \\mathbb{R}^{3 \\times 3}$，以及单位矩阵 $I \\in \\mathbb{R}^{3 \\times 3}$。这三个节点分别对应内嗅皮层、海马体和后扣带回。假设拉普拉斯算子是对称路径图拉普拉斯算子\n$$\nL = \\begin{pmatrix}\n1  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  1\n\\end{pmatrix},\n$$\n且时间 $t=0$ 时的初始AD病理浓度为\n$$\nx(0) = \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n$$\n单位为标准化摄取值比（SUVR）。设生物物理参数为 $\\kappa = 0.5$ $\\text{year}^{-1}$，$\\lambda = 0.2$ $\\text{year}^{-1}$，并评估时间 $t = 3$ 年时的状态。\n\n从对称矩阵和线性时不变系统的基本性质出发，通过拉普拉斯算子的特征分解推导出解析解，并计算 $t=3$ 年时的状态 $x(t)$。将最终状态的每个分量以SUVR单位表示，并将每个分量四舍五入到四位有效数字。你的最终答案必须是单个行向量。",
            "solution": "该模型是一个线性时不变系统：\n$$\n\\frac{d}{dt}x(t) = -\\left( \\kappa L + \\lambda I \\right) x(t),\n$$\n其中 $L$ 是对称的。对于对称矩阵，存在一个标准正交特征基 $U \\in \\mathbb{R}^{3 \\times 3}$ 使得\n$$\nL = U \\Lambda U^{\\top},\n$$\n其中 $\\Lambda = \\operatorname{diag}(\\lambda_{0}, \\lambda_{1}, \\lambda_{2})$ 包含 $L$ 的特征值，且 $U^{\\top}U = I$。\n\n定义模态坐标 $y(t) = U^{\\top} x(t)$。将 $x(t) = U y(t)$ 代入微分方程得到\n$$\n\\frac{d}{dt}(U y(t)) = -\\left( \\kappa U \\Lambda U^{\\top} + \\lambda I \\right) U y(t).\n$$\n使用 $U^{\\top}U = I$ 并左乘 $U^{\\top}$，\n$$\n\\frac{d}{dt} y(t) = -\\left( \\kappa \\Lambda + \\lambda I \\right) y(t),\n$$\n这可以解耦为三个标量常微分方程\n$$\n\\frac{d}{dt} y_{i}(t) = -\\left( \\kappa \\lambda_{i} + \\lambda \\right) y_{i}(t), \\quad i = 0,1,2.\n$$\n这些方程的解为\n$$\ny_{i}(t) = \\exp\\!\\left( -(\\kappa \\lambda_{i} + \\lambda) t \\right) y_{i}(0).\n$$\n变换回原始坐标，\n$$\nx(t) = U y(t) = U \\exp\\!\\left( -(\\kappa \\Lambda + \\lambda I) t \\right) y(0) = U \\exp\\!\\left( -(\\kappa \\Lambda + \\lambda I) t \\right) U^{\\top} x(0),\n$$\n这是矩阵指数解的谱形式。\n\n我们现在计算给定的路径图拉普拉斯算子的特征分解\n$$\nL = \\begin{pmatrix}\n1  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  1\n\\end{pmatrix}.\n$$\n对于三节点的路径图，其特征值是已知的，或者可以通过求解 $\\det(L - \\mu I) = 0$ 得到\n$$\n\\lambda_{0} = 0, \\quad \\lambda_{1} = 1, \\quad \\lambda_{2} = 3.\n$$\n一组相应的标准正交特征向量是\n$$\nv_{0} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nv_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}, \\quad\nv_{2} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ -2 \\\\ 1 \\end{pmatrix}.\n$$\n将这些作为 $U = [v_{0}\\; v_{1}\\; v_{2}]$ 的列向量。\n\n将初始条件投影到模态坐标：\n$$\ny(0) = U^{\\top} x(0) = \\begin{pmatrix}\nv_{0}^{\\top} x(0) \\\\\nv_{1}^{\\top} x(0) \\\\\nv_{2}^{\\top} x(0)\n\\end{pmatrix}.\n$$\n计算每个分量：\n- 对于 $v_{0}$，\n$$\ny_{0}(0) = v_{0}^{\\top} x(0) = \\frac{1}{\\sqrt{3}} (1.0 + 0.3 + 0.1) = \\frac{1.4}{\\sqrt{3}}.\n$$\n- 对于 $v_{1}$，\n$$\ny_{1}(0) = v_{1}^{\\top} x(0) = \\frac{1}{\\sqrt{2}} (1.0 - 0.1) = \\frac{0.9}{\\sqrt{2}}.\n$$\n- 对于 $v_{2}$，\n$$\ny_{2}(0) = v_{2}^{\\top} x(0) = \\frac{1}{\\sqrt{6}} (1.0 - 2 \\cdot 0.3 + 0.1) = \\frac{0.5}{\\sqrt{6}}.\n$$\n\n当 $\\kappa = 0.5$ $\\text{year}^{-1}$，$\\lambda = 0.2$ $\\text{year}^{-1}$，以及 $t = 3$ 年时，模态衰减因子为\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{0} + \\lambda) t \\right) = \\exp(-0.2 \\cdot 3) = \\exp(-0.6),\n$$\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{1} + \\lambda) t \\right) = \\exp(-(0.5 \\cdot 1 + 0.2) \\cdot 3) = \\exp(-2.1),\n$$\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{2} + \\lambda) t \\right) = \\exp(-(0.5 \\cdot 3 + 0.2) \\cdot 3) = \\exp(-5.1).\n$$\n因此\n$$\ny(t) = \\begin{pmatrix}\n\\exp(-0.6)\\, \\frac{1.4}{\\sqrt{3}} \\\\\n\\exp(-2.1)\\, \\frac{0.9}{\\sqrt{2}} \\\\\n\\exp(-5.1)\\, \\frac{0.5}{\\sqrt{6}}\n\\end{pmatrix}.\n$$\n重构 $x(t)$ 为\n$$\nx(t) = U y(t) = \\sum_{i=0}^{2} \\left[ \\exp\\!\\left( -(\\kappa \\lambda_{i} + \\lambda) t \\right) \\, y_{i}(0) \\, v_{i} \\right].\n$$\n为了进行数值计算，使用作用于 $x(0)$ 的投影矩阵 $v_{i} v_{i}^{\\top}$ 会很方便。各部分的贡献如下：\n- 对于 $v_{0}$，\n$$\nv_{0} v_{0}^{\\top} x(0) = \\frac{1}{3} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{3} \\begin{pmatrix} 1.4 \\\\ 1.4 \\\\ 1.4 \\end{pmatrix}\n= \\begin{pmatrix} \\frac{1.4}{3} \\\\ \\frac{1.4}{3} \\\\ \\frac{1.4}{3} \\end{pmatrix}.\n$$\n乘以 $\\exp(-0.6)$ 得到对每个分量的 $v_{0}$ 贡献：\n$$\n\\exp(-0.6) \\cdot \\frac{1.4}{3} \\approx 0.5488116360940264 \\cdot 0.4666666666666667 \\approx 0.256112096843879.\n$$\n- 对于 $v_{1}$，\n$$\nv_{1} v_{1}^{\\top} x(0) = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\\\ 0  0  0 \\\\ -1  0  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{2} \\begin{pmatrix} 0.9 \\\\ 0 \\\\ -0.9 \\end{pmatrix}\n= \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}.\n$$\n乘以 $\\exp(-2.1)$ 得到\n$$\n\\exp(-2.1) \\cdot \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}\n\\approx 0.1224564282529819 \\cdot \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}\n= \\begin{pmatrix} 0.055105392713841 \\\\ 0 \\\\ -0.055105392713841 \\end{pmatrix}.\n$$\n- 对于 $v_{2}$，\n$$\nv_{2} v_{2}^{\\top} x(0) = \\frac{1}{6} \\begin{pmatrix} 1  -2  1 \\\\ -2  4  -2 \\\\ 1  -2  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{6} \\begin{pmatrix} 0.5 \\\\ -1.0 \\\\ 0.5 \\end{pmatrix}\n= \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}.\n$$\n乘以 $\\exp(-5.1)$ 得到\n$$\n\\exp(-5.1) \\cdot \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}\n\\approx 0.00609678 \\cdot \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}\n= \\begin{pmatrix} \\frac{0.00609678}{12} \\\\ -\\frac{0.00609678}{6} \\\\ \\frac{0.00609678}{12} \\end{pmatrix}\n\\approx \\begin{pmatrix} 0.000508065 \\\\ -0.001016130 \\\\ 0.000508065 \\end{pmatrix}.\n$$\n\n按分量将三部分的贡献相加得到\n$$\nx_{1}(3) \\approx 0.256112096843879 + 0.055105392713841 + 0.000508065 \\approx 0.3117255547,\n$$\n$$\nx_{2}(3) \\approx 0.256112096843879 + 0 - 0.001016130 \\approx 0.2550959668,\n$$\n$$\nx_{3}(3) \\approx 0.256112096843879 - 0.055105392713841 + 0.000508065 \\approx 0.2015147692.\n$$\n\n四舍五入到四位有效数字，并以标准化摄取值比（SUVR）单位表示，在时间 $t = 3$ 年时的最终状态向量为\n$$\n\\begin{pmatrix}\n0.3117  0.2551  0.2015\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.3117  0.2551  0.2015 \\end{pmatrix}}$$"
        },
        {
            "introduction": "最后的这个练习  连接了理论建模和经验数据，这是计算神经科学中的一项核心活动。你将实现一个参数优化工作流程，以找到最佳的扩散和清除率，从而使网络模型能够最好地复现已知的阿尔茨海默病病理分期顺序。这项实践展示了这些模型如何不仅用于模拟，还可用于检验假设和量化生物学参数。",
            "id": "3962311",
            "problem": "给定一个用于阿尔茨海默病的线性网络退化模型族，该模型族将沿大脑结构网络的扩散传播与局部清除相结合。状态向量为 $x(t) \\in \\mathbb{R}^n$，其中 $x_i(t)$ 表示在时间 $t$ 区域 $i$ 的预测局部病理负荷。结构网络由一个对称邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 编码，其元素非负且对角线为零，相应的组合图拉普拉斯算子为 $L = D - A$，其中 $D$ 是对角度矩阵，其元素为 $D_{ii} = \\sum_{j=1}^n A_{ij}$。动力学由以下线性常微分方程定义\n$$\n\\frac{d x(t)}{dt} = -\\lambda x(t) - \\kappa L x(t),\n$$\n初始条件为 $x(0) = e_s$，其中 $e_s$ 是在种子索引 $s$ 处为 $1$、其他位置为 $0$ 的单位向量。此处 $\\kappa \\ge 0$ 量化了沿网络的扩散传播强度，$\\lambda \\ge 0$ 量化了局部清除率。对于每个区域 $i$，预测的阈值穿越时间 $T_i(\\kappa,\\lambda)$ 定义为满足 $x_i(t) \\ge \\theta$ 的最小 $t \\ge 0$，其中 $\\theta > 0$ 是一个指定的阈值。如果在所有 $t \\in [0, T_{\\max}]$ 内都有 $x_i(t)  \\theta$，则设置 $T_i(\\kappa,\\lambda) = T_{\\max} + \\Delta t$ 以强制施加最大有限秩。阿尔茨海默病的进展顺序可以用一个整数值的 Braak 分期顺序向量 $b \\in \\{1,2,\\dots,n\\}^n$ 来表示，其中 $b_i$ 是区域 $i$ 的标称分期索引。\n\n对于每个测试用例，目标是在一个离散的 κ 和 λ 值网格上进行搜索，找到能够最大化预测阈值穿越时间 $\\{T_i(\\kappa,\\lambda)\\}_{i=1}^n$ 与 Braak 分期顺序 $\\{b_i\\}_{i=1}^n$ 之间 Kendall’s τ 等级相关性（使用对结具有鲁棒性的 Kendall’s τ_b）的那对参数。如果目标值出现平局，选择 $\\lambda$ 最小的解；如果仍然存在平局，则选择 $\\kappa$ 最小的解。\n\n使用的基本原理：\n- 用于网络扩散的图拉普拉斯算子 $L = D - A$。\n- 时不变系统的线性常微分方程解：如果 $\\frac{dx}{dt} = B x$，则 $x(t) = e^{Bt} x(0)$，其中 $e^{Bt}$ 是矩阵指数。\n- 两个实值列表之间的 Kendall’s $\\tau$ 等级相关性 $\\tau_b$。\n\n通过在均匀时间网格 $\\{0, \\Delta t, 2 \\Delta t, \\dots, T_{\\max}\\}$ 上评估 $x(t)$ 并记录 $x_i(t)$ 首次超过阈值的时间来计算阈值穿越时间。使用闭式解\n$$\nx(t) = e^{-(\\lambda I + \\kappa L)t} x(0),\n$$\n以及特征分解 $L = V \\,\\mathrm{diag}(\\alpha_1,\\dots,\\alpha_n)\\, V^\\top$（其中 $V^\\top V = I$）来高效地计算 $x(t)$：\n$$\nx(t) = V \\,\\mathrm{diag}\\left(e^{-(\\lambda + \\kappa \\alpha_j) t}\\right) V^\\top x(0).\n$$\n\n物理单位：将 $t$ 解释为以年为单位的时间，$\\lambda$ 和 $\\kappa$ 解释为以 $1/\\text{year}$ 为单位的速率，$\\theta$ 解释为无量纲阈值。报告最终的最佳拟合参数时，将 $\\kappa$ 和 $\\lambda$ 表示为单位为 $1/\\text{year}$、保留六位小数的小数浮点数。输出中不要包含单位字符串。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件：\n- 测试用例 1（链式网络，“理想路径”）：\n  - 区域数量：$n = 6$。\n  - 邻接矩阵：\n    $$\n    A^{(1)} =\n    \\begin{pmatrix}\n    0  1  0  0  0  0 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  1  0  0 \\\\\n    0  0  1  0  1  0 \\\\\n    0  0  0  1  0  1 \\\\\n    0  0  0  0  1  0\n    \\end{pmatrix}.\n    $$\n  - 种子索引：$s = 0$（在实现中为零基索引）。\n  - 阈值：$\\theta = 0.02$。\n  - 时间范围：$T_{\\max} = 30$ 年。\n  - 时间步长：$\\Delta t = 0.1$ 年。\n  - Braak 分期顺序：$b^{(1)} = [1, 2, 3, 4, 5, 6]$。\n\n- 测试用例 2（星形网络，从中心节点快速扩散）：\n  - 区域数量：$n = 6$。\n  - 邻接矩阵：\n    $$\n    A^{(2)} =\n    \\begin{pmatrix}\n    0  1  1  1  1  1 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0\n    \\end{pmatrix}.\n    $$\n  - 种子索引：$s = 0$。\n  - 阈值：$\\theta = 0.02$。\n  - 时间范围：$T_{\\max} = 30$ 年。\n  - 时间步长：$\\Delta t = 0.1$ 年。\n  - Braak 分期顺序：$b^{(2)} = [1, 2, 3, 4, 5, 6]$。\n\n- 测试用例 3（部分断开的网络，存在不穿越可能性的边缘情况）：\n  - 区域数量：$n = 6$。\n  - 邻接矩阵：\n    $$\n    A^{(3)} =\n    \\begin{pmatrix}\n    0  1  0  0  0  0 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  0  0  0 \\\\\n    0  0  0  0  1  0 \\\\\n    0  0  0  1  0  0 \\\\\n    0  0  0  0  0  0\n    \\end{pmatrix}.\n    $$\n  - 种子索引：$s = 0$。\n  - 阈值：$\\theta = 0.02$。\n  - 时间范围：$T_{\\max} = 30$ 年。\n  - 时间步长：$\\Delta t = 0.1$ 年。\n  - Braak 分期顺序：$b^{(3)} = [1, 2, 3, 4, 5, 6]$。\n\n参数搜索网格（离散的，在所有测试用例中相同使用）：\n- 扩散强度：$\\kappa \\in \\{0.05, 0.10, 0.20, 0.35, 0.50, 0.80, 1.20\\}$。\n- 清除率：$\\lambda \\in \\{0.02, 0.05, 0.10, 0.15, 0.25, 0.40, 0.80\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个包含三个浮点数 $[\\kappa^\\ast,\\lambda^\\ast,\\tau^\\ast]$ 的列表，分别代表最佳拟合扩散强度（单位 $1/\\text{year}$）、最佳拟合清除率（单位 $1/\\text{year}$）和最大化的 Kendall’s τ 值。所有三个浮点数都必须四舍五入到六位小数。例如，一个有效的输出可能看起来像\n$$\n[[0.500000, 0.100000, 0.733333], [0.800000, 0.050000, 0.600000], [0.350000, 0.150000, 0.466667]]\n$$\n但其值需根据指定的测试用例计算得出。",
            "solution": "该问题已经过验证，被认为是合理的。它在科学上基于计算神经科学中已建立的网络扩散模型，问题设定良好，具有明确的目标和约束，并以客观、无歧义的语言表述。所有必要的数据和参数均已提供。\n\n该问题要求找到一个基于网络的阿尔茨海默病进展模型的最佳参数 $(\\kappa, \\lambda)$，以最佳地重现给定的病理分期顺序。该模型描述了病理（由浓度向量 $x(t) \\in \\mathbb{R}^n$ 表示）在结构性大脑网络上的传播。动力学由一个线性常微分方程（ODE）控制：\n$$\n\\frac{d x(t)}{dt} = -\\lambda x(t) - \\kappa L x(t) = -(\\lambda I + \\kappa L) x(t)\n$$\n此处，$n$ 是大脑区域的数量。参数 $\\kappa \\ge 0$ 代表沿网络连接的扩散传播速率，$\\lambda \\ge 0$ 代表病理的局部清除或衰减速率。网络结构被编码在图拉普拉斯算子 $L = D - A$ 中，其中 $A$ 是邻接矩阵，$D$ 是对角度矩阵。系统从单个区域 $s$ 的病理种子开始，对应于初始条件 $x(0) = e_s$，其中 $e_s$ 是在索引 $s$ 处为 1、其他位置为 0 的标准基向量。\n\n这是一个时不变线性系统，其解由矩阵指数给出：\n$$\nx(t) = e^{-(\\lambda I + \\kappa L)t} x(0)\n$$\n为了高效计算，我们使用对称图拉普拉斯算子 $L$ 的谱特性。设 $L$ 的特征分解为 $L = V \\Lambda V^\\top$，其中 $\\Lambda = \\mathrm{diag}(\\alpha_1, \\dots, \\alpha_n)$ 是特征值的对角矩阵，$V$ 是相应特征向量的正交矩阵（$V^\\top V = I$）。解可以表示为：\n$$\nx(t) = V \\,\\mathrm{diag}\\left(e^{-(\\lambda + \\kappa \\alpha_j) t}\\right)_{j=1}^n V^\\top x(0)\n$$\n一旦 $L$ 的特征分解已知，这个公式就允许在任何时间 $t$ 快速计算状态向量 $x(t)$。\n\n模型的输出是一组预测的阈值穿越时间 $\\{T_i(\\kappa, \\lambda)\\}_{i=1}^n$。对于每个区域 $i$，$T_i$ 是其病理水平 $x_i(t)$ 达到或超过给定阈值 $\\theta$ 的最早时间 $t \\ge 0$。在计算上，我们在离散时间网格 $t_k = k \\cdot \\Delta t$（其中 $k=0, 1, \\dots, T_{\\max}/\\Delta t$）上评估 $x(t)$。$x_i(t_k) \\ge \\theta$ 的第一个时间点 $t_k$ 被记录为 $T_i$。如果在时间范围 $[0, T_{\\max}]$ 内从未达到阈值，则分配一个惩罚值 $T_i = T_{\\max} + \\Delta t$，以确保有限的秩，并将这些区域与那些穿越较晚但在时间范围内的区域区分开。\n\n目标是从指定的离散网格中找到参数对 $(\\kappa, \\lambda)$，该参数对能最大化模型预测的进展顺序（由 $T_i$ 值的排序给出）与经验性病理进展顺序（由 Braak 分期向量 $b$ 表示）之间的一致性。这种一致性使用 Kendall's $\\tau_b$ 等级相关系数来衡量，该系数适用于存在相同秩次（结）的数据。穿越时间的结是可能出现的，特别是对于对称区域或不连通的组件。\n\n优化过程是网格搜索。对于每个测试用例，我们将执行以下步骤：\n1.  构建邻接矩阵 $A$ 和相应的图拉普拉斯算子 $L$。\n2.  计算 $L$ 的特征值 $\\alpha_j$ 和特征向量 $V$。\n3.  初始化最佳参数集 $(\\kappa^\\ast, \\lambda^\\ast)$ 和最大相关性 $\\tau^\\ast = -2$（一个小于任何可能 $\\tau$ 值的数）。\n4.  遍历各自搜索网格中的每一对 $(\\kappa, \\lambda)$。\n5.  对于每一对 $(\\kappa, \\lambda)$：\n    a.  为所有区域 $i$ 和网格 $[0, \\Delta t, \\dots, T_{\\max}]$ 中的所有时间步 $t_k$ 计算状态向量演化 $x_i(t_k)$。\n    b.  通过为每个区域找到第一个 $t_k \\ge \\theta$ 来确定阈值穿越时间向量 $T(\\kappa, \\lambda)$。\n    c.  计算穿越时间向量 $T(\\kappa, \\lambda)$ 与给定的 Braak 分期向量 $b$ 之间的 Kendall's $\\tau_b$ 相关性。\n6.  根据计算出的 $\\tau_b$ 值更新最优参数。如果当前的 $\\tau_b$ 大于 $\\tau^\\ast$，则更新 $(\\kappa^\\ast, \\lambda^\\ast, \\tau^\\ast)$。如果 $\\tau_b$ 等于 $\\tau^\\ast$，则应用指定的决胜规则：选择 $\\lambda$ 较小的解；如果 $\\lambda$ 也相同，则选择 $\\kappa$ 较小的解。\n\n这个完整的过程被独立地应用于所提供的三个测试用例中的每一个，每个测试用例都有其独特的网络结构和 Braak 分期。每个测试用例的最终结果是一个三元组 $[\\kappa^\\ast, \\lambda^\\ast, \\tau^\\ast]$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.stats import kendalltau\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Parameter search grids (identical for all test cases)\n    kappa_grid = [0.05, 0.10, 0.20, 0.35, 0.50, 0.80, 1.20]\n    lambda_grid = [0.02, 0.05, 0.10, 0.15, 0.25, 0.40, 0.80]\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 0, 1, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        },\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        },\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        A = case[\"A\"]\n        s = case[\"s\"]\n        theta = case[\"theta\"]\n        T_max = case[\"T_max\"]\n        dt = case[\"dt\"]\n        b = case[\"b\"]\n\n        # 1. Construct Graph Laplacian L = D - A\n        D = np.diag(np.sum(A, axis=1))\n        L = D - A\n\n        # 2. Compute eigendecomposition of L\n        # eigh is used for symmetric matrices\n        eigenvalues, eigenvectors = eigh(L)\n        V = eigenvectors\n        V_T = V.T\n\n        # 3. Prepare initial condition and time grid\n        x0 = np.zeros(n)\n        x0[s] = 1.0\n        time_grid = np.arange(0, T_max + dt, dt)\n        \n        # Pre-compute part of the solution for efficiency\n        V_T_x0 = V_T @ x0\n\n        best_kappa = -1.0\n        best_lambda = -1.0\n        max_tau = -2.0  # Kendall's tau is in [-1, 1]\n\n        # 4. Grid search over kappa and lambda\n        for lambda_val in lambda_grid:\n            for kappa_val in kappa_grid:\n                \n                # 5a. Compute state vector evolution x(t)\n                exponent_diagonals = -(lambda_val + kappa_val * eigenvalues)\n                \n                # Create a matrix of x(t) values: rows are regions, columns are time steps\n                # x(t) = V @ diag(exp(exponent_diagonals*t)) @ V.T @ x0\n                # Efficient computation:\n                exp_term = np.exp(np.outer(exponent_diagonals, time_grid))\n                x_t = V @ (exp_term * V_T_x0[:, np.newaxis])\n\n                # 5b. Determine threshold-crossing times\n                crossing_times = np.full(n, T_max + dt)\n                # Find where pathology exceeds threshold\n                pathology_over_threshold = (x_t >= theta)\n                \n                for i in range(n):\n                    # Find the first time index where the threshold is crossed\n                    indices = np.where(pathology_over_threshold[i, :])[0]\n                    if len(indices) > 0:\n                        first_idx = indices[0]\n                        crossing_times[i] = time_grid[first_idx]\n                \n                # 5c. Calculate Kendall's tau\n                tau_result = kendalltau(crossing_times, b, variant='b')\n                current_tau = tau_result.correlation\n\n                # 6. Update best parameters based on tie-breaking rules\n                if current_tau > max_tau:\n                    max_tau = current_tau\n                    best_lambda = lambda_val\n                    best_kappa = kappa_val\n                elif current_tau == max_tau:\n                    if lambda_val  best_lambda:\n                        max_tau = current_tau\n                        best_lambda = lambda_val\n                        best_kappa = kappa_val\n                    elif lambda_val == best_lambda:\n                        if kappa_val  best_kappa:\n                            max_tau = current_tau\n                            best_lambda = lambda_val\n                            best_kappa = kappa_val\n\n        all_results.append([best_kappa, best_lambda, max_tau])\n\n    # Format the final output string as specified.\n    def format_result(res_list):\n        formatted_nums = [f\"{x:.6f}\" for x in res_list]\n        return f\"[{','.join(formatted_nums)}]\"\n\n    results_str = [format_result(r) for r in all_results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}