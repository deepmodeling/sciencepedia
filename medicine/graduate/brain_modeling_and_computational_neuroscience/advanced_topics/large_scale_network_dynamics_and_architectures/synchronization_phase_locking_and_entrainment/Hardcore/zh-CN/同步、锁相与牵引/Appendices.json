{
    "hands_on_practices": [
        {
            "introduction": "在深入复杂的模拟之前，掌握夹带现象背后的基础数学至关重要。本练习将指导您通过解析推导，得出一个受正弦输入驱动的单个振荡器的锁相条件，这是被称为Adler方程的基石模型。通过将系统转换到旋转坐标系并进行稳定性分析，您将揭示频率失谐、驱动强度和稳定锁定相位之间的精确关系 。",
            "id": "4026095",
            "problem": "考虑一个受弱正弦驱动的单相位简化神经振荡器，其模型由受迫相位方程 $ \\dot{\\phi}(t) = \\omega + F \\sin\\!\\big(\\Omega t - \\phi(t)\\big) $ 给出，其中 $ \\phi(t) $ 是振荡器相位，$ \\omega $ 是无驱动振荡器的自然频率，$ F \\ge 0 $ 是驱动振幅，$ \\Omega $ 是驱动频率。夹带现象指的是长时间演化过程中，振荡器频率与驱动频率相匹配，且振荡器与驱动之间的相位差趋于一个不依赖于时间的常数。假设发生 $ 1\\!:\\!1 $ 夹带（频率锁定，平均相位漂移为零），并定义相位差为 $ \\delta(t) = \\phi(t) - \\Omega t $。仅使用标准的相位简化假设和一维自治系统不动点的线性稳定性分析，推导决定锁定相位差的不动点条件，并确定锁定状态的线性稳定性。作为最终答案，提供一个关于 $ \\omega $、$ \\Omega $ 和 $ F $ 的稳定锁定相位差 $ \\delta^{\\ast} $ 的单一闭式解析表达式。最终答案以弧度表示。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n- **模型方程**：$ \\dot{\\phi}(t) = \\omega + F \\sin\\!\\big(\\Omega t - \\phi(t)\\big) $\n- **变量**：\n    - $ \\phi(t) $：时间 $t$ 时的振荡器相位\n    - $ \\omega $：无驱动振荡器的自然频率\n    - $ F $：驱动振幅，$F \\ge 0$\n    - $ \\Omega $：驱动频率\n- **定义**：\n    - **夹带**：长时间演化过程中，振荡器频率与驱动频率相匹配，且相位差趋于一个不依赖于时间的常数。\n    - **相位差**：$ \\delta(t) = \\phi(t) - \\Omega t $\n- **假设**：发生 $ 1\\!:\\!1 $ 夹带。\n- **任务**：\n    1. 推导锁定相位差的不动点条件。\n    2. 确定锁定状态的线性稳定性。\n    3. 提供稳定锁定相位差 $ \\delta^{\\ast} $ 的闭式解析表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题的有效性进行评估：\n- **科学依据**：所提供的模型 $ \\dot{\\phi} = \\omega + F \\sin(\\Omega t - \\phi) $ 是 Adler 方程的规范形式。它是物理学、工程学和计算神经科学中一个基础且广泛使用的模型，用于研究弱驱动或耦合振荡器中的同步、相位锁定和夹带现象。该问题基于已建立的科学原理。\n- **适定性**：问题陈述清晰。它要求在夹带的假设下，从给定的微分方程中推导一个特定量（$ \\delta^{\\ast} $）。其数学结构是一个一阶非自治常微分方程，可以转化为一个自治方程，从而适用标准的分析方法（不动点和稳定性分析）。在所述条件下，预计存在唯一的稳定解。\n- **客观性**：语言精确且量化，没有任何主观或模棱两可的术语。\n- **完整性与一致性**：问题提供了所有必要信息：控制方程、所有变量和参数的定义，以及夹带的关键假设。没有矛盾之处。\n- **现实性**：该模型是该领域使用的标准理想化模型。参数是通用的，不代表物理上不可能的数值。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它具有科学合理性、适定性、客观性和自洽性。可以进行求解过程。\n\n### 求解推导\n振荡器相位的动力学由以下方程给出：\n$$ \\dot{\\phi}(t) = \\omega + F \\sin(\\Omega t - \\phi(t)) $$\n问题将相位差定义为 $ \\delta(t) = \\phi(t) - \\Omega t $。我们旨在寻找控制 $ \\delta(t) $ 的动力学。为此，我们将 $ \\delta(t) $ 对时间 $ t $ 求导：\n$$ \\dot{\\delta}(t) = \\frac{d}{dt} \\big( \\phi(t) - \\Omega t \\big) = \\dot{\\phi}(t) - \\Omega $$\n将 $ \\dot{\\phi}(t) $ 的表达式代入此方程得到：\n$$ \\dot{\\delta}(t) = \\big( \\omega + F \\sin(\\Omega t - \\phi(t)) \\big) - \\Omega $$\n正弦函数内部的项可以用 $ \\delta(t) $ 表示：\n$$ \\Omega t - \\phi(t) = -(\\phi(t) - \\Omega t) = -\\delta(t) $$\n利用正弦函数的性质 $ \\sin(-x) = -\\sin(x) $，$ \\dot{\\delta}(t) $ 的方程变为：\n$$ \\dot{\\delta}(t) = \\omega - \\Omega - F \\sin(\\delta(t)) $$\n这是一个关于相位差 $ \\delta(t) $ 的一阶自治常微分方程。\n\n夹带或相位锁定的条件是相位差趋于一个不依赖于时间的常数值，我们记为 $ \\delta^{\\ast} $。这对应于 $ \\delta(t) $ 动力学的一个不动点。当 $ \\dot{\\delta}(t) = 0 $ 时，出现不动点。\n令 $ \\dot{\\delta}(t) = 0 $ 得到不动点条件：\n$$ 0 = \\omega - \\Omega - F \\sin(\\delta^{\\ast}) $$\n整理此方程得到决定锁定相位差的条件：\n$$ F \\sin(\\delta^{\\ast}) = \\omega - \\Omega $$\n$$ \\sin(\\delta^{\\ast}) = \\frac{\\omega - \\Omega}{F} $$\n为了使 $ \\delta^{\\ast} $ 存在实数解，右侧的值必须在正弦函数的值域 $ [-1, 1] $ 内。这导出了频率锁定的条件：\n$$ \\left| \\frac{\\omega - \\Omega}{F} \\right| \\le 1 \\quad \\implies \\quad |\\omega - \\Omega| \\le F $$\n问题陈述假设夹带发生，因此我们在此条件满足的假设下继续进行。\n\n为确定不动点 $ \\delta^{\\ast} $ 的稳定性，我们进行线性稳定性分析。令关于 $ \\delta $ 的自治常微分方程的右侧为 $g(\\delta)$：\n$$ g(\\delta) = \\omega - \\Omega - F \\sin(\\delta) $$\n如果 $ g(\\delta) $ 在不动点处的导数小于零，即 $ g'(\\delta^{\\ast})  0 $，则不动点 $ \\delta^{\\ast} $ 是线性稳定的。如果 $ g'(\\delta^{\\ast})  0 $，则它是不稳定的。\n$ g(\\delta) $ 的导数是：\n$$ g'(\\delta) = \\frac{d}{d\\delta} \\big( \\omega - \\Omega - F \\sin(\\delta) \\big) = -F \\cos(\\delta) $$\n因此，对于一个稳定的不动点，我们必须有：\n$$ g'(\\delta^{\\ast}) = -F \\cos(\\delta^{\\ast})  0 $$\n由于驱动振幅 $ F $ 给定为 $ F \\ge 0 $，且 $ F=0 $ 的情况是平凡的（无驱动），我们考虑 $ F  0 $。稳定性条件简化为：\n$$ \\cos(\\delta^{\\ast})  0 $$\n在任何长度为 $ 2\\pi $ 的区间内，只要 $ |\\omega - \\Omega|  F $，方程 $ \\sin(\\delta^{\\ast}) = \\frac{\\omega - \\Omega}{F} $ 通常有两个不同的解 $ \\delta^{\\ast} $。令 $ C = \\frac{\\omega - \\Omega}{F} $。\n\n第一个解是主值，由反正弦函数给出：\n$$ \\delta_1^{\\ast} = \\arcsin(C) = \\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right) $$\n根据定义，$ \\arcsin $ 函数的值域是 $ [-\\frac{\\pi}{2}, \\frac{\\pi}{2}] $。对于任何值 $ \\theta \\in [-\\frac{\\pi}{2}, \\frac{\\pi}{2}] $，其余弦值 $ \\cos(\\theta) $ 是非负的（$ \\cos(\\theta) \\ge 0 $）。具体来说，如果 $ |\\omega - \\Omega|  F $，那么 $ |C|  1 $ 且 $ \\delta_1^{\\ast} \\in (-\\frac{\\pi}{2}, \\frac{\\pi}{2}) $，这意味着 $ \\cos(\\delta_1^{\\ast})  0 $。因此，不动点 $ \\delta_1^{\\ast} $ 是稳定的。\n\n在区间 $ [-\\frac{\\pi}{2}, \\frac{3\\pi}{2}) $ 内的第二个解是：\n$$ \\delta_2^{\\ast} = \\pi - \\delta_1^{\\ast} = \\pi - \\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right) $$\n该解位于值域 $ [\\frac{\\pi}{2}, \\frac{3\\pi}{2}] $ 内。对于任何值 $ \\theta \\in [\\frac{\\pi}{2}, \\frac{3\\pi}{2}] $，其余弦值 $ \\cos(\\theta) $ 是非正的（$ \\cos(\\theta) \\le 0 $）。具体来说，如果 $ |\\omega - \\Omega|  F $，那么 $ \\delta_2^{\\ast} \\in (\\frac{\\pi}{2}, \\frac{3\\pi}{2}) $，这意味着 $ \\cos(\\delta_2^{\\ast})  0 $。对于这个不动点，稳定性判据变为 $ g'(\\delta_2^{\\ast}) = -F \\cos(\\delta_2^{\\ast})  0 $。因此，不动点 $ \\delta_2^{\\ast} $ 是不稳定的。\n\n问题要求的是稳定的锁定相位差。根据线性稳定性分析，这就是解 $ \\delta_1^{\\ast} $。\n\n因此，稳定的锁定相位差为：\n$$ \\delta^{\\ast} = \\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right) $$\n该表达式给出了当振荡器被夹带时，其相对于外部驱动所保持的恒定相位差（以弧度为单位）。",
            "answer": "$$ \\boxed{\\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right)} $$"
        },
        {
            "introduction": "同步通常是一种由许多个体单元相互作用而产生的集体现象。本实践将我们的焦点从单个振荡器转移到一个大型网络，使用著名的Kuramoto模型来探索向同步的转变。您将通过编写一个数值模拟，找到一个临界耦合强度，在该强度下，一群具有不同自然频率的振荡器会自发地组织其节律，这是理解全脑振荡的基础过程 。",
            "id": "4026154",
            "problem": "要求您编写一个完整的、可运行的程序，该程序基于动力系统理论中经过充分检验的定义，使用一种有原则的数值方法，来估算 Kuramoto 模型中相位振子网络的部分同步起始点。考虑一个由 $N$ 个相位振子组成的群体，其相位为 $\\theta_{i}(t)$，自然频率 $\\omega_{i}$ 从一个以 $\\omega_{0} = 0$ 为中心、半高半宽为 $\\Delta  0$ 的洛伦兹（柯西）分布中独立抽取，即其概率密度为\n$$\ng(\\omega) = \\frac{\\Delta}{\\pi}\\,\\frac{1}{\\omega^{2} + \\Delta^{2}}.\n$$\n其动力学由 Kuramoto 相位振子方程描述\n$$\n\\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\frac{K}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{j} - \\theta_{i}\\big),\n$$\n其中 $K \\ge 0$ 是全局耦合强度，角度以弧度为单位。定义复序参量为\n$$\nre^{i\\psi} = \\frac{1}{N}\\sum_{j=1}^{N} e^{i\\theta_{j}},\n$$\n其中 $r \\in [0,1]$ 衡量相位相干性，$\\psi$ 是平均相位。您的任务是在以下规范下，数值估算系统从非相干态（对于大的 $N$，$r \\approx 0$）过渡到部分同步态（$r  0$）的临界耦合强度 $K_{c}$。\n\n从上述定义和定律出发，实现振子动力学的直接时域模拟，以获得给定 $K$ 值下的时间平均序参量 $\\langle r \\rangle_{t}$，其中时间平均不包括初始暂态。全程使用弧度作为角度单位，并将 $\\theta_{i}(0)$ 在 $[0,2\\pi)$ 上进行均匀随机初始化。为确保检测同步起始点的科学真实性，定义一个与有限尺寸涨落成比例的数值检测阈值；设定阈值为\n$$\nr_{\\mathrm{th}} = \\frac{c}{\\sqrt{N}},\n$$\n其中 $c$ 是一个固定常数。将 $K_{c}$ 数值上定义为使得时间平均序参量 $\\langle r \\rangle_{t}$ 严格超过 $r_{\\mathrm{th}}$ 的最小 $K$ 值。使用一种自适应搜索策略，该策略首先在粗网格上包围临界点，然后通过对 $K$ 进行二分法来精确估算。\n\n您的程序必须遵循以下数值选择：\n- 使用显式欧拉时间步进，时间步长 $dt = 0.02$，总积分时间 $T = 25.0$，在计算平均值 $\\langle r \\rangle_{t}$ 前舍弃暂态时间 $T_{\\mathrm{trans}} = 10.0$。\n- 在阈值 $r_{\\mathrm{th}}$ 中使用 $c = 3.5$。\n- 为从洛伦兹分布中采样 $\\omega_{i}$，使用逆变换采样法：\n$$\n\\omega_{i} = \\Delta \\tan\\!\\big(\\pi(u_{i} - \\tfrac{1}{2})\\big),\n$$\n其中 $u_{i}$ 在 $[0,1]$ 内独立且均匀分布。所有测试中，中心频率 $\\omega_{0} = 0$。\n- 对于 $K$ 的自适应搜索，使用一个在 $[0, K_{\\max}]$（其中 $K_{\\max} = 6\\Delta$）上包含 $M = 24$ 个均匀间隔点的粗网格来包围临界点；如果成功包围，则执行 $J = 12$ 次二分法迭代来精确估算 $K_{c}$。\n- 在扫描 $K$ 时，每个测试用例中的所有 $K$ 值都使用相同的随机种子，以保持网络实现固定。程序应根据下面测试套件中的规定，在内部固定这些种子。\n\n请严格按照上述定义实现序参量和动力学，并确保角度以弧度处理。在此模型中，除了角度的弧度单位外，没有其他物理单位；时间和耦合是无量纲的。所有数学计算必须直接遵循所提供的定义，不得调用任何未提供的简化表达式。\n\n测试套件：\n针对以下由 $(N,\\Delta,\\text{seed})$ 指定的测试用例，估算 $K_{c}$：\n- 用例 1：$(N,\\Delta,\\text{seed}) = (256, 0.5, 1337)$。\n- 用例 2：$(N,\\Delta,\\text{seed}) = (512, 1.0, 2021)$。\n- 用例 3：$(N,\\Delta,\\text{seed}) = (1024, 2.0, 7)$。\n- 边缘用例 4：$(N,\\Delta,\\text{seed}) = (64, 0.2, 99)$。\n\n答案规格：\n- 对每个测试用例，返回估算的临界耦合强度 $K_{c}$，形式为浮点数，四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，例如 $\\,[K_{c}^{(1)}, K_{c}^{(2)}, K_{c}^{(3)}, K_{c}^{(4)}]\\,.$。\n- 输出必须是且仅是一行，只包含该方括号列表，无任何附加文本。\n\n您的程序必须是自包含的，不需要任何输入，并且在给定上述固定种子的情况下确定性地运行。角度必须以弧度为单位；报告的浮点数应保留三位小数且不带单位。",
            "solution": "问题陈述已经过分析并确定有效。它具有科学依据，问题定义明确，客观，并为数值实验提供了一套完整且一致的规范。任务是估算 Kuramoto 振子网络中同步起始的临界耦合强度 $K_c$。这将通过直接时域模拟和系统性搜索算法来实现。\n\n该解决方案基于以下原则构建：\n\n1.  **Kuramoto 模型与同步**\n    系统由 $N$ 个相位振子组成，其中每个振子 $i$ 的状态由其相位角 $\\theta_i(t)$ 描述。每个相位的时间演化遵循 Kuramoto 方程：\n    $$\n    \\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\frac{K}{N}\\sum_{j=1}^{N}\\sin(\\theta_{j} - \\theta_{i})\n    $$\n    这里，$\\omega_i$ 是振子 $i$ 的固有自然频率，从一个以 $\\omega_0=0$ 为中心、半高宽为 $\\Delta$ 的洛伦兹分布 $g(\\omega)$ 中抽取。项 $\\frac{K}{N}\\sum\\limits_{j=1}^{N}\\sin(\\theta_{j} - \\theta_{i})$ 代表所有其他振子对振子 $i$ 的影响，其中 $K \\ge 0$ 是均匀耦合强度。\n    网络的集体行为由复序参量 $z(t) = r(t)e^{i\\psi(t)}$ 来量化，定义为：\n    $$\n    re^{i\\psi} = \\frac{1}{N}\\sum_{j=1}^{N} e^{i\\theta_{j}}\n    $$\n    其模 $r \\in [0,1]$ 衡量相位相干的程度。对于非相干态，相位随机分布，当 $N$ 较大时 $r \\approx 0$。对于部分同步态，宏观比例的振子会一起旋转，导致 $r  0$。临界耦合强度 $K_c$ 是系统从非相干态过渡到部分同步态的 $K$ 值。\n\n2.  **高效的数值积分**\n    该微分方程组使用显式欧拉方法进行数值求解。对每个振子的动力学方程中的求和项直接求值，每个时间步的计算复杂度为 $O(N^2)$，效率低下。该求和项可以用序参量来表示，从而将复杂度降低到 $O(N)$。耦合项可重写为：\n    $$\n    \\frac{K}{N}\\sum_{j=1}^{N}\\sin(\\theta_{j} - \\theta_{i}) = \\frac{K}{N} \\text{Im}\\left( \\sum_{j=1}^{N} e^{i(\\theta_{j}-\\theta_{i})} \\right) = \\frac{K}{N} \\text{Im}\\left( e^{-i\\theta_{i}} \\sum_{j=1}^{N} e^{i\\theta_{j}} \\right)\n    $$\n    代入序参量的定义，上式变为：\n    $$\n    \\frac{K}{N} \\text{Im}\\left( e^{-i\\theta_{i}} (Nre^{i\\psi}) \\right) = K \\text{Im}\\left( r e^{i(\\psi - \\theta_{i})} \\right) = K r \\sin(\\psi - \\theta_{i})\n    $$\n    运动方程简化为一种高效的形式：\n    $$\n    \\frac{d\\theta_{i}}{dt} = \\omega_{i} + K r(t) \\sin(\\psi(t) - \\theta_{i}(t))\n    $$\n    因此，使用时间步长 $dt$ 的显式欧拉离散化形式为：\n    $$\n    \\theta_i(t+\\Delta t) = \\theta_i(t) + dt \\left( \\omega_{i} + K r(t) \\sin(\\psi(t) - \\theta_{i}(t)) \\right)\n    $$\n    对于给定的 $K$ 值，模拟将以时间步长 $dt=0.02$ 运行总时间 $T = 25.0$。\n\n3.  **同步起始的检测**\n    对于大小为 $N$ 的有限系统，统计涨落会导致序参量 $r$ 即使在非相干态下也不为零，通常其尺度为 $r \\sim O(1/\\sqrt{N})$。为了区分真实的部​​分同步与这些有限尺寸效应，建立了一个数值阈值：\n    $$\n    r_{\\mathrm{th}} = \\frac{c}{\\sqrt{N}}\n    $$\n    使用指定的常数 $c=3.5$，该阈值为同步起始提供了一个鲁棒的判据。临界耦合强度 $K_c$ 随后被定义为使时间平均序参量 $\\langle r \\rangle_t$ 严格超过此阈值的最小 $K$ 值。时间平均是在模拟的后半部分（从 $T_{\\mathrm{trans}} = 10.0$ 到 $T = 25.0$）计算的，以排除初始暂态行为。\n\n4.  **临界耦合 $K_c$ 的自适应搜索**\n    采用一种高效的两阶段自适应搜索策略来寻找 $K_c$。\n    - **区间包围：** $K$ 的搜索范围设定为 $[0, K_{\\max}]$，其中 $K_{\\max} = 6\\Delta$。该范围被划分为一个包含 $M=24$ 个点的粗网格。对网格上的每个点 $K$，运行一次完整模拟以计算 $\\langle r \\rangle_t$。然后，算法识别出第一对包围转变点的相邻网格点 $(K_{low}, K_{high})$，即满足 $\\langle r \\rangle_t(K_{low}) \\le r_{\\mathrm{th}}$ 和 $\\langle r \\rangle_t(K_{high})  r_{\\mathrm{th}}$。\n    - **二分法：** 一旦找到区间 $[K_{low}, K_{high}]$，便使用二分法来精确估算 $K_c$。这个迭代过程重复 $J=12$ 步。在每一步中，测试中点 $K_{mid} = (K_{low} + K_{high})/2$。如果 $\\langle r \\rangle_t(K_{mid})  r_{\\mathrm{th}}$，则新的上界变为 $K_{mid}$；否则，新的下界变为 $K_{mid}$。经过 $J$ 次迭代后，搜索区间的最终上界被视为 $K_c$ 的估算值。\n\n5.  **可复现性与实现**\n    为确保结果的确定性和可复现性，对每个测试用例的随机数生成器都设置了种子。通过逆变换采样生成的自然频率 $\\omega_i$ 和初始相位 $\\theta_i(0)$ 在每个测试用例中只生成一次，并在该用例的 $K$ 值扫描中重复使用。此过程确保了观察到的 $\\langle r \\rangle_t$ 变化仅由 $K$ 的变化引起，而非网络实现的随机变动。使用 `numpy` 库的矢量化操作来高效地实现模拟。",
            "answer": "```python\nimport numpy as np\n\ndef simulate_kuramoto(K, N, omega, theta_0, dt, T, T_trans):\n    \"\"\"\n    Simulates the Kuramoto model for a given coupling strength K and\n    returns the time-averaged order parameter magnitude.\n    \"\"\"\n    theta = np.copy(theta_0)\n    num_steps = int(round(T / dt))\n    trans_steps = int(round(T_trans / dt))\n    \n    order_param_magnitudes = []\n\n    for step in range(num_steps):\n        # Calculate order parameter r and mean phase psi\n        z = np.mean(np.exp(1j * theta))\n        r = np.abs(z)\n        psi = np.angle(z)\n\n        # Record for averaging after transient period\n        if step = trans_steps:\n            order_param_magnitudes.append(r)\n\n        # Update phases using Euler method with mean-field simplification\n        d_theta = omega + K * r * np.sin(psi - theta)\n        theta += d_theta * dt\n\n    return np.mean(order_param_magnitudes) if order_param_magnitudes else 0.0\n\ndef find_kc(N, delta, seed, dt, T, T_trans, c, K_max_factor, M, J):\n    \"\"\"\n    Finds the critical coupling strength Kc for a given test case\n    using a two-stage adaptive search.\n    \"\"\"\n    # Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Generate fixed network properties (omega and theta_0) for this test case\n    u = rng.uniform(0, 1, N)\n    omega = delta * np.tan(np.pi * (u - 0.5))\n    theta_0 = rng.uniform(0, 2 * np.pi, N)\n\n    # Calculate detection threshold\n    r_th = c / np.sqrt(N)\n    \n    # Stage 1: Coarse Grid Search to Bracket Kc\n    K_max = K_max_factor * delta\n    K_grid = np.linspace(0, K_max, M)\n    \n    k_low, k_high = -1.0, -1.0\n\n    # Check the first point to handle cases where it's already synchronized\n    r_at_k_prev = simulate_kuramoto(K_grid[0], N, omega, theta_0, dt, T, T_trans)\n    \n    if r_at_k_prev  r_th:\n        # If synchronized at K=0 (or very low K), set interval at the bottom\n        k_low = K_grid[0]\n        k_high = K_grid[1] if M  1 else K_max\n    else:\n        for i in range(1, M):\n            K = K_grid[i]\n            r_at_k_curr = simulate_kuramoto(K, N, omega, theta_0, dt, T, T_trans)\n            if r_at_k_curr  r_th:\n                k_low = K_grid[i-1]\n                k_high = K\n                break\n            r_at_k_prev = r_at_k_curr\n            \n    if k_low == -1.0:\n        # If transition was not found, return the max search value\n        return K_max\n\n    # Stage 2: Bisection Method to Refine Kc\n    for _ in range(J):\n        k_mid = (k_low + k_high) / 2.0\n        r_mid = simulate_kuramoto(k_mid, N, omega, theta_0, dt, T, T_trans)\n        if r_mid  r_th:\n            k_high = k_mid\n        else:\n            k_low = k_mid\n            \n    # As per convention, the upper bound of the final interval is the estimate\n    return k_high\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the Kuramoto problem and print results.\n    \"\"\"\n    # Parameters from the problem description\n    DT = 0.02\n    T_TOTAL = 25.0\n    T_TRANS = 10.0\n    C_CONST = 3.5\n    K_MAX_FACTOR = 6.0\n    M_POINTS = 24\n    J_ITERATIONS = 12\n\n    test_cases = [\n        (256, 0.5, 1337),\n        (512, 1.0, 2021),\n        (1024, 2.0, 7),\n        (64, 0.2, 99),\n    ]\n\n    results = []\n    for N, delta, seed in test_cases:\n        kc_est = find_kc(N, delta, seed, DT, T_TOTAL, T_TRANS, C_CONST, K_MAX_FACTOR, M_POINTS, J_ITERATIONS)\n        results.append(kc_est)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# The problem requires a self-contained, runnable program that produces the output.\nsolve()\n```"
        },
        {
            "introduction": "完美的锁相是一种理想情况；真实的生物系统不可避免地存在噪声。本练习将随机性引入我们的模型，以探索不完美夹带的动力学以及相位滑动（phase slips）现象。通过模拟一个在噪声影响下的受驱振荡器，您将学会如何量化随机波动如何导致系统暂时脱离锁定状态，这是解读神经数据的一个关键概念 。",
            "id": "4026105",
            "problem": "给定一个在加性高斯白噪声（GWN）下弱驱动神经振荡器的随机相位模型。在弱耦合和近共振区域，振荡器与驱动之间的相位差 $\\,\\phi(t)\\,$ 可以通过带噪声的 Adler 方程很好地近似，这是一个一阶随机微分方程（SDE）：\n$$\n\\mathrm{d}\\phi(t) \\;=\\; \\big(\\Delta\\omega \\;-\\; K \\,\\sin\\phi(t)\\big)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t,\n$$\n其中 $\\,\\Delta\\omega\\,$ 是失谐，单位为弧度/秒；$\\,K\\,$ 是耦合强度，单位为弧度/秒；$\\,\\sigma\\,$ 是噪声幅度，单位为弧度/平方根秒；$\\,W_t\\,$ 是一个标准维纳过程。角度单位必须是弧度，时间单位必须是秒。\n\n您的任务是实现一个程序，对下方测试套件中的每一组参数，使用 Euler–Maruyama 方法模拟上述 SDE，并量化近锁定区域及其边缘情况下的相位滑动统计数据。一次相位滑动定义为展开的相位差 $\\,\\phi(t)\\,$ 发生 $\\,\\pm 2\\pi\\,$ 的环绕。为可靠地检测滑动，请使用环绕数\n$$\nN(t) \\;=\\; \\left\\lfloor \\frac{\\phi(t) + \\pi}{2\\pi} \\right\\rfloor,\n$$\n并将此指数随时间的正增量 $\\,\\Delta N  0\\,$ 计数为前向滑动，负增量 $\\,\\Delta N  0\\,$ 计数为后向滑动。使用一个预烧期区间，以便在开始计数前让瞬态衰减。\n\n对于每组参数，您必须计算在预烧期后区间内的以下三个统计数据：\n- 每秒总滑动率，定义为 $\\,\\big(N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}\\big)/T_{\\mathrm{eff}}\\,$，其中 $\\,N_{\\mathrm{fwd}}\\,$ 和 $\\,N_{\\mathrm{bwd}}\\,$ 分别是前向和后向滑动计数，$\\,T_{\\mathrm{eff}}\\,$ 是预烧期后的有效时间，单位为秒。\n- 前向滑动分数，定义为 $\\,N_{\\mathrm{fwd}}/\\big(N_{\\mathrm{fwd}}+N_{\\mathrm{bwd}}\\big)\\,$，并约定当 $\\,N_{\\mathrm{fwd}}+N_{\\mathrm{bwd}}=0\\,$ 时，其值为 $\\,0\\,$。\n- 每秒净环绕率，定义为 $\\,\\big(N_{\\mathrm{fwd}} - N_{\\mathrm{bwd}}\\big)/T_{\\mathrm{eff}}\\,$。\n\n模拟要求：\n- 使用 Euler–Maruyama 更新规则离散化时间\n$$\n\\phi_{n+1} \\;=\\; \\phi_{n} \\;+\\; \\big(\\Delta\\omega \\;-\\; K\\sin\\phi_n\\big)\\,\\Delta t \\;+\\; \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n,\n$$\n其中 $\\,\\Delta t\\,$ 是时间步长，单位为秒，$\\,\\xi_n \\sim \\mathcal{N}(0,1)\\,$ 是独立的标准正态随机变量。\n- 如果 $\\,|\\Delta\\omega|  K\\,$，将 $\\,\\phi(0)\\,$ 初始化为稳定不动点 $\\,\\phi^\\star = \\arcsin(\\Delta\\omega/K)\\,$，否则初始化为 $\\,0\\,$。\n- 使用指定的随机种子以保证可复现性。\n- 角度单位必须是弧度，时间单位必须是秒。\n- 滑动率以秒的倒数表示，前向滑动分数以小数表示。\n- 将报告的每个浮点数四舍五入到恰好三位小数。\n\n测试套件：\n- 情况 $\\,1\\,$: $\\Delta\\omega = 0.1$ rad/s, $K = 0.12$ rad/s, $\\sigma = 0.04$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 预烧期 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 1$。\n- 情况 $\\,2\\,$: $\\Delta\\omega = 0.1$ rad/s, $K = 0.1$ rad/s, $\\sigma = 0.02$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 预烧期 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 2$。\n- 情况 $\\,3\\,$: $\\Delta\\omega = 0.1$ rad/s, $K = 0.2$ rad/s, $\\sigma = 0.04$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 预烧期 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 3$。\n- 情况 $\\,4\\,$: $\\Delta\\omega = 0.1$ rad/s, $K = 0.15$ rad/s, $\\sigma = 0.0$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 600$ s, 预烧期 $T_{\\mathrm{burn}} = 100$ s, 种子 $= 4$。\n- 情况 $\\,5\\,$: $\\Delta\\omega = 0.1$ rad/s, $K = 0.05$ rad/s, $\\sigma = 0.0$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 600$ s, 预烧期 $T_{\\mathrm{burn}} = 100$ s, 种子 $= 5$。\n- 情况 $\\,6\\,$: $\\Delta\\omega = 0.1$ rad/s, $K = 0.05$ rad/s, $\\sigma = 0.04$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 预烧期 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 6$。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含一个由子列表组成的逗号分隔列表，每个子列表按 $[$总滑动率 (s$^{-1}$), 前向滑动分数, 净环绕率 (s$^{-1}$)$]$ 的顺序排列，并四舍五入到三位小数。总输出必须是单个列表，其顺序与测试套件相同。例如，包含两个假设情况的输出应如下所示：$[[0.012,0.600,0.004],[0.000,0.000,0.000]]$。",
            "solution": "该问题要求模拟一个带噪声的神经振荡器的随机 Adler 方程，并随后计算相位滑动的统计数据。该解决方案可以根据随机微积分、数值方法和时间序列分析的原理，分解为以下几个步骤。\n\n### 1. 问题建模与模型\n系统的动力学由相位差 $\\phi(t)$ 的一阶随机微分方程（SDE）描述：\n$$\n\\mathrm{d}\\phi(t) = \\big(\\Delta\\omega - K \\sin\\phi(t)\\big)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}W_t\n$$\n在这里，$\\phi(t)$ 是以弧度为单位的相位差，$\\Delta\\omega$ 是频率失谐（rad/s），$K$ 是耦合强度（rad/s），$\\sigma$ 是高斯白噪声的幅度（rad/s$^{1/2}$）。项 $\\mathrm{d}W_t$ 表示标准维纳过程的增量。\n\n### 2. 数值模拟：Euler-Maruyama 方法\n为了模拟 SDE，我们以步长 $\\Delta t$ 离散化时间。问题指定使用 Euler-Maruyama 方法，这是 SDE 的一种标准数值格式。相位 $\\phi$ 从时间步 $n$到 $n+1$ 的更新规则由下式给出：\n$$\n\\phi_{n+1} = \\phi_{n} + \\big(\\Delta\\omega - K\\sin\\phi_n\\big)\\,\\Delta t + \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n\n$$\n其中 $\\phi_n$ 是在时间 $t_n = n\\Delta t$ 时的相位，$\\xi_n$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。此更新规则在一个循环中实现，该循环迭代的总步数对应于总模拟时长 $T$。为了保证可复现性，随机数序列 $\\xi_n$ 是通过一个伪随机数生成器生成的，该生成器使用每个测试用例的特定种子进行初始化。\n\n### 3. 初始条件\n模拟从初始相位 $\\phi_0 = \\phi(0)$ 开始。$\\phi_0$ 的选择取决于系统的确定性动力学（即 $\\sigma=0$ 的情况）。\n- 如果 $|\\Delta\\omega|  K$，系统存在一个稳定不动点，代表一个锁相状态。我们将系统初始化于此稳定点：$\\phi_0 = \\arcsin(\\Delta\\omega/K)$。\n- 如果 $|\\Delta\\omega| \\geq K$，系统没有稳定不动点，相位发生漂移。在此区域使用一个中性初始条件 $\\phi_0 = 0$。\n\n### 4. 相位滑动的检测与计数\n一次相位滑动对应于展开相位 $\\phi(t)$ 变化了 $\\pm 2\\pi$ 的倍数。为了可靠地检测这些事件，我们在每个时间步 $t_n$ 计算环绕数：\n$$\nN_n = \\left\\lfloor \\frac{\\phi_n + \\pi}{2\\pi} \\right\\rfloor\n$$\n连续时间步之间环绕数的变化 $\\Delta N = N_{n+1} - N_n$ 表明发生了一次或多次滑动。\n- 前向滑动对应于 $\\Delta N  0$。\n- 后向滑动对应于 $\\Delta N  0$。\n\n在整个模拟过程中累积前向滑动（$N_{\\mathrm{fwd}}$）和后向滑动（$N_{\\mathrm{bwd}}$）的计数。然而，计数仅在指定的预烧期 $T_{\\mathrm{burn}}$ 结束后才开始。这确保了在收集统计数据之前，任何初始瞬态都已衰减，系统已进入其稳态或准稳态行为。\n\n### 5. 统计数据计算\n模拟完成后，使用收集到的滑动计数来计算在有效模拟时间 $T_{\\mathrm{eff}} = T - T_{\\mathrm{burn}}$ 内的三个关键统计数据：\n1.  **总滑动率**：此指标衡量滑动事件的总频率，不分方向。其计算公式为：\n    $$ \\text{Rate}_{\\text{total}} = \\frac{N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}}{T_{\\mathrm{eff}}} $$\n2.  **前向滑动分数**：此指标量化了滑动的方向偏差。它是前向滑动与总滑动次数的比率：\n    $$ F_{\\text{fwd}} = \\begin{cases} \\frac{N_{\\mathrm{fwd}}}{N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}}  \\text{if } N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}  0 \\\\ 0  \\text{if } N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}} = 0 \\end{cases} $$\n3.  **净环绕率**：此指标衡量平均相位漂移率，单位为滑动次数/秒。其计算公式为：\n    $$ \\text{Rate}_{\\text{net}} = \\frac{N_{\\mathrm{fwd}} - N_{\\mathrm{bwd}}}{T_{\\mathrm{eff}}} $$\n\n### 6. 实现\n整个算法在一个 Python 函数中实现。该函数遍历测试套件中提供的每个参数集。对于每组参数，它都如上所述运行模拟，执行滑动分析，并计算所需的三个统计数据。最终结果被收集并格式化为问题指定的单个字符串，每个数值都四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_slip_statistics(params):\n    \"\"\"\n    Simulates the stochastic Adler equation and computes phase slip statistics.\n\n    Args:\n        params (tuple): A tuple containing the simulation parameters:\n            (delta_omega, K, sigma, dt, T, T_burn, seed).\n\n    Returns:\n        list: A list containing three float values:\n              [total_slip_rate, forward_slip_fraction, net_winding_rate].\n    \"\"\"\n    delta_omega, K, sigma, dt, T, T_burn, seed = params\n\n    # --- Setup ---\n    num_steps = int(round(T / dt))\n    burn_in_steps = int(round(T_burn / dt))\n    rng = np.random.default_rng(seed)\n\n    # --- Initial Condition ---\n    if np.abs(delta_omega)  K and K  0:\n        phi = np.arcsin(delta_omega / K)\n    else:\n        phi = 0.0\n\n    # --- Simulation and Slip Counting ---\n    N_fwd = 0\n    N_bwd = 0\n    pi_const = np.pi\n    two_pi_const = 2.0 * np.pi\n    \n    prev_winding_index = np.floor((phi + pi_const) / two_pi_const)\n\n    for n in range(num_steps):\n        # Euler-Maruyama step\n        xi = rng.standard_normal()\n        drift_term = (delta_omega - K * np.sin(phi)) * dt\n        noise_term = sigma * np.sqrt(dt) * xi\n        phi += drift_term + noise_term\n\n        # Check for slips after the burn-in period\n        if n + 1  burn_in_steps:\n            new_winding_index = np.floor((phi + pi_const) / two_pi_const)\n            delta_N = new_winding_index - prev_winding_index\n            \n            if delta_N  0:\n                N_fwd += delta_N\n            elif delta_N  0:\n                N_bwd += -delta_N\n        \n        prev_winding_index = np.floor((phi + pi_const) / two_pi_const)\n\n\n    # --- Calculate Final Statistics ---\n    T_eff = T - T_burn\n    \n    if T_eff = 0:\n        return [0.0, 0.0, 0.0]\n\n    total_slips = N_fwd + N_bwd\n\n    total_slip_rate = total_slips / T_eff\n    net_winding_rate = (N_fwd - N_bwd) / T_eff\n\n    if total_slips  0:\n        fwd_slip_fraction = N_fwd / total_slips\n    else:\n        fwd_slip_fraction = 0.0\n\n    return [total_slip_rate, fwd_slip_fraction, net_winding_rate]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # (Δω, K, σ, Δt, T, T_burn, seed)\n        (0.1, 0.12, 0.04, 0.01, 1200, 200, 1),\n        (0.1, 0.1,  0.02, 0.01, 1200, 200, 2),\n        (0.1, 0.2,  0.04, 0.01, 1200, 200, 3),\n        (0.1, 0.15, 0.0,  0.01, 600,  100, 4),\n        (0.1, 0.05, 0.0,  0.01, 600,  100, 5),\n        (0.1, 0.05, 0.04, 0.01, 1200, 200, 6),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        stats = calculate_slip_statistics(case)\n        all_results.append(stats)\n\n    # --- Format Output ---\n    formatted_sublists = []\n    for sublist in all_results:\n        formatted_nums = [f\"{num:.3f}\" for num in sublist]\n        formatted_sublists.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_sublists)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}