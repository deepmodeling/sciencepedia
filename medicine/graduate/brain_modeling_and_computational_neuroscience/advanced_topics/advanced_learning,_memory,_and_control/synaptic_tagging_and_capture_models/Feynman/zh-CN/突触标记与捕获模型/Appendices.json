{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握突触标记与捕获（STC）模型，第一步是将其生物学假设转化为一个精确的数学框架。这个练习将引导你从基本原理出发，构建一个描述突触标记、可塑性相关蛋白（PRPs）和突触权重动态变化的微分方程组。通过实现一个数值模拟，你将亲手探索标记和蛋白的寿命（由时间常数 $\\tau_T$ 和 $\\tau_P$ 体现）如何共同决定了学习和记忆巩固的时间窗口，这是理解STC模型预测能力的核心实践。",
            "id": "4025821",
            "problem": "考虑突触标记与捕获 (Synaptic Tagging and Capture, STC) 的最小形式化模型，其中突触标记和可塑性相关产物由刺激产生并根据一级动力学进行衰减，而突触权重的长期巩固则源于它们在时间上的巧合。任务是从第一性原理构建演化方程，并为“先弱后强”的刺激方案实现一个模拟，然后在一系列时间常数上对巩固结果进行分类。\n\n假设以下基本规则源自经过充分检验的生物化学和生物物理学原理：在线性泄漏下浓度的指数松弛为一级，线性产生与刺激输入成正比，以及巩固的突触权重在线性泄漏下存在依赖于巧合的累积。具体来说，每个量都表现出以下特性：\n\n- 突触标记 $T(t)$ 以时间常数 $\\tau_{T}$ 进行一级衰减，并由有限持续时间的弱刺激输入驱动。\n- 可塑性相关产物 $P(t)$ 以时间常数 $\\tau_{P}$ 进行一级衰减，并由有限持续时间的强刺激输入驱动。\n- 巩固的突触权重 $W(t)$ 与 $T(t)$ 和 $P(t)$ 的瞬时巧合成比例增加，并表现出线性泄漏。\n\n刺激方案和输入被定义为方波脉冲：\n- 弱刺激在区间 $t \\in [0,\\delta)$ 上发生，幅度为 $A_{w}$。\n- 强刺激在区间 $t \\in [d,d+\\delta)$ 上发生，幅度为 $A_{s}$。\n- 在这些区间之外，不施加任何刺激。\n\n您的程序必须：\n1. 推导与上述假设一致的最小常微分方程 (ODE) 系统，用于描述分别由弱输入和强输入驱动的 $T(t)$、$P(t)$ 和 $W(t)$。使用与上下文相符的构造：带时间常数的一级衰减，与输入幅度成正比且带产生增益的线性产生，以及用于 $W(t)$ 的带线性泄漏的巧合驱动累积。\n2. 使用显式前向欧拉法和固定时间步长 $dt$ 实现一个数值求解器，模拟系统从 $t=0$ 到 $t=t_{\\mathrm{end}}$ 的行为，初始条件为 $T(0)=0$，$P(0)=0$ 和 $W(0)=0$。\n3. 通过对最终突触权重设置阈值来对巩固进行分类：输出一个布尔值，表示 $W(t_{\\mathrm{end}}) \\ge \\theta$ 是否成立。\n\n使用以下参数值和单位：\n- 弱脉冲幅度 $A_{w} = 1.0$ (无量纲)。\n- 强脉冲幅度 $A_{s} = 3.0$ (无量纲)。\n- 产生增益 $k_{T} = 0.05\\,\\mathrm{s}^{-1}$ 和 $k_{P} = 0.05\\,\\mathrm{s}^{-1}$。\n- 巧合增益 $\\gamma = 1\\times 10^{-5}\\,\\mathrm{s}^{-1}$ 和泄漏率 $\\lambda = 1\\times 10^{-5}\\,\\mathrm{s}^{-1}$。\n- 先弱后强延迟 $d = 600\\,\\mathrm{s}$ 和脉冲持续时间 $\\delta = 30\\,\\mathrm{s}$。\n- 模拟时间步长 $dt = 0.5\\,\\mathrm{s}$ 和结束时间 $t_{\\mathrm{end}} = 7200\\,\\mathrm{s}$。\n- 巩固阈值 $\\theta = 0.05$ (无量纲)。\n\n您的程序应评估以下针对 $(\\tau_{T},\\tau_{P})$ 的时间常数（单位：秒）测试套件：\n- 情况 $1$：$(1200,1800)$。\n- 情况 $2$：$(180,1800)$。\n- 情况 $3$：$(1800,180)$。\n- 情况 $4$：$(2400,2400)$。\n- 情况 $5$：$(60,60)$。\n- 情况 $6$：$(600,600)$。\n\n对于每种情况，模拟“先弱后强”方案，计算 $W(t_{\\mathrm{end}})$，并如前述对巩固进行分类。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\texttt{[result1,result2,\\dots]}$），列表中的每个元素是对应情况下巩固结果的布尔值。所有时间量必须以秒为单位处理和计算，最终分类必须是无单位的布尔值。",
            "solution": "该问题要求为突触标记与捕获 (STC) 构建并模拟一个最小数学模型。解决方案涉及从给定的第一性原理推导一个常微分方程 (ODE) 系统，实现一个数值求解器，并用它来对一组参数的巩固结果进行分类。\n\n### 1. 模型方程的推导\n\n该模型基于三个量的时间动态：突触标记浓度 $T(t)$、可塑性相关产物浓度 $P(t)$ 和巩固的突触权重 $W(t)$。这些动态是从生物化学动力学的基本原理推导出来的。\n\n**刺激输入函数：**\n该系统由弱刺激和强刺激驱动，它们被建模为方波脉冲。弱刺激函数 $S_w(t)$ 和强刺激函数 $S_s(t)$ 定义如下：\n$$ S_w(t) = \\begin{cases} A_w  \\text{if } 0 \\le t  \\delta \\\\ 0  \\text{otherwise} \\end{cases} $$\n$$ S_s(t) = \\begin{cases} A_s  \\text{if } d \\le t  d+\\delta \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $A_w$ 和 $A_s$ 分别是各自的幅度，$\\delta$ 是脉冲持续时间，$d$ 是弱刺激和强刺激开始之间的延迟。\n\n**突触标记 $T(t)$ 的方程：**\n描述指出，突触标记 $T(t)$ 是为响应弱刺激而产生的，并经历一级衰减。这个过程由一个一阶线性常微分方程捕获。代表线性泄漏的衰减项与当前浓度成正比，记为 $-\\frac{T(t)}{\\tau_T}$，其中 $\\tau_T$ 是标记的特征时间常数。产生项与弱刺激输入成线性比例，即 $k_T S_w(t)$，其中 $k_T$ 是产生增益。结合这些项，$T(t)$ 的演化由以下方程决定：\n$$ \\frac{dT}{dt} = k_T S_w(t) - \\frac{T(t)}{\\tau_T} $$\n\n**可塑性相关产物 $P(t)$ 的方程：**\n类似地，可塑性相关产物（PRP）的浓度 $P(t)$ 由强刺激产生，并且也经历一级衰减。衰减项为 $-\\frac{P(t)}{\\tau_P}$，其中 $\\tau_P$ 是产物的时间常数。产生由强刺激驱动，由项 $k_P S_s(t)$ 表示，其中 $k_P$ 是产生增益。对应的 $P(t)$ 的常微分方程是：\n$$ \\frac{dP}{dt} = k_P S_s(t) - \\frac{P(t)}{\\tau_P} $$\n\n**巩固的突触权重 $W(t)$ 的方程：**\n突触权重 $W(t)$ 的巩固取决于标记 $T(t)$ 和产物 $P(t)$ 在时间上的巧合。这种依赖于巧合的增长被建模为与它们浓度的乘积成正比，即 $\\gamma T(t)P(t)$，其中 $\\gamma$ 是巧合增益。突触权重也表现出线性泄漏，由衰减项 $-\\lambda W(t)$ 建模，其中 $\\lambda$ 是泄漏率。因此，$W(t)$ 的常微分方程是：\n$$ \\frac{dW}{dt} = \\gamma T(t)P(t) - \\lambda W(t) $$\n\n**完整的 ODE 系统：**\n完整的 STC 模型由以下耦合常微分方程系统描述，其初始条件为静息状态下的突触：\n$$\n\\begin{align*}\n\\frac{dT}{dt} = k_T S_w(t) - \\frac{T(t)}{\\tau_T}, \\quad T(0) = 0 \\\\\n\\frac{dP}{dt} = k_P S_s(t) - \\frac{P(t)}{\\tau_P}, \\quad P(0) = 0 \\\\\n\\frac{dW}{dt} = \\gamma T(t)P(t) - \\lambda W(t), \\quad W(0) = 0\n\\end{align*}\n$$\n\n### 2. 数值模拟\n\n问题指定使用显式前向欧拉法对该系统进行数值求解。对于形式为 $\\frac{dy}{dt} = f(y, t)$ 的通用常微分方程，下一个时间步的值 $y_{i+1} = y(t_{i+1})$ 是根据当前步的值 $y_i = y(t_i)$ 使用固定时间步长 $dt$ 来近似的：\n$$ y_{i+1} \\approx y_i + dt \\cdot f(y_i, t_i) $$\n将此离散化方案应用于我们的方程系统，得到以下迭代更新规则：\n$$ T_{i+1} = T_i + dt \\left( k_T S_w(t_i) - \\frac{T_i}{\\tau_T} \\right) $$\n$$ P_{i+1} = P_i + dt \\left( k_P S_s(t_i) - \\frac{P_i}{\\tau_P} \\right) $$\n$$ W_{i+1} = W_i + dt \\left( \\gamma T_i P_i - \\lambda W_i \\right) $$\n使用给定的参数值：$A_w=1.0$、$A_s=3.0$、$k_T=0.05\\,\\mathrm{s}^{-1}$、$k_P=0.05\\,\\mathrm{s}^{-1}$、$\\gamma=1\\times 10^{-5}\\,\\mathrm{s}^{-1}$、$\\lambda=1\\times 10^{-5}\\,\\mathrm{s}^{-1}$、$d=600\\,\\mathrm{s}$ 和 $\\delta=30\\,\\mathrm{s}$，以 $dt=0.5\\,\\mathrm{s}$ 的时间步长，从 $t=0$ 到 $t=t_{\\text{end}}$ 执行模拟。\n\n### 3. 巩固准则\n\n最后一步是为每次模拟运行的结果进行分类。如果在模拟期结束时 $t_{\\text{end}}=7200\\,\\mathrm{s}$，最终的突触权重 $W(t_{\\text{end}})$ 大于或等于预设阈值 $\\theta=0.05$，则认为巩固成功。对于每个参数集 $(\\tau_T, \\tau_P)$ 的输出是代表此比较结果的布尔值：\n$$ \\text{巩固} = \\left( W(t_{\\text{end}}) \\ge \\theta \\right) $$\n对六个指定的测试用例中的每一个都执行此过程，并将结果汇总到一个最终列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_stc(tau_T, tau_P):\n    \"\"\"\n    Simulates the Synaptic Tagging and Capture (STC) model for a given set\n    of time constants using the forward Euler method.\n\n    Args:\n        tau_T (float): Time constant for the synaptic tag in seconds.\n        tau_P (float): Time constant for the plasticity proteins in seconds.\n\n    Returns:\n        float: The final consolidated synaptic weight W(t_end).\n    \"\"\"\n    # Fixed parameters as specified in the problem\n    A_w = 1.0       # Weak pulse amplitude (dimensionless)\n    A_s = 3.0       # Strong pulse amplitude (dimensionless)\n    k_T = 0.05      # Tag production gain (s^-1)\n    k_P = 0.05      # Protein production gain (s^-1)\n    gamma = 1.0e-5  # Coincidence gain (s^-1)\n    lmbda = 1.0e-5  # Weight leakage rate (s^-1)\n    d = 600.0       # Weak-then-strong delay (s)\n    delta = 30.0    # Pulse duration (s)\n    dt = 0.5        # Simulation time step (s)\n    t_end = 7200.0  # Final time (s)\n    \n    # Simulation time setup\n    num_steps = int(t_end / dt)\n    \n    # Initialize state variable arrays\n    # T, P, and W start at 0, which np.zeros handles\n    T = np.zeros(num_steps + 1)\n    P = np.zeros(num_steps + 1)\n    W = np.zeros(num_steps + 1)\n    \n    # Pre-calculate stimulus pulse indices for efficiency and robustness\n    weak_stim_start_idx = int(0 / dt)\n    weak_stim_end_idx = int(delta / dt)\n    strong_stim_start_idx = int(d / dt)\n    strong_stim_end_idx = int((d + delta) / dt)\n\n    # Main simulation loop to iterate through time steps\n    for i in range(num_steps):\n        # Determine stimulus input values at the current time step\n        S_w = A_w if weak_stim_start_idx = i  weak_stim_end_idx else 0.0\n        S_s = A_s if strong_stim_start_idx = i  strong_stim_end_idx else 0.0\n            \n        # Apply the forward Euler update rules\n        # Update synaptic tag T\n        dT_dt = k_T * S_w - T[i] / tau_T\n        T[i+1] = T[i] + dt * dT_dt\n        \n        # Update plasticity proteins P\n        dP_dt = k_P * S_s - P[i] / tau_P\n        P[i+1] = P[i] + dt * dP_dt\n        \n        # Update consolidated weight W\n        dW_dt = gamma * T[i] * P[i] - lmbda * W[i]\n        W[i+1] = W[i] + dt * dW_dt\n        \n    return W[-1]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the STC simulation for all test cases and print results.\n    \"\"\"\n    # Define the consolidation threshold\n    theta = 0.05\n    \n    # Define the test suite of time constants (tau_T, tau_P) in seconds\n    test_cases = [\n        (1200.0, 1800.0), # Case 1\n        (180.0, 1800.0),  # Case 2\n        (1800.0, 180.0),  # Case 3\n        (2400.0, 2400.0), # Case 4\n        (60.0, 60.0),     # Case 5\n        (600.0, 600.0),   # Case 6\n    ]\n\n    results = []\n    # Iterate through each case, run the simulation, and classify the outcome\n    for tau_T, tau_P in test_cases:\n        final_weight = simulate_stc(tau_T, tau_P)\n        consolidation_occurs = final_weight >= theta\n        results.append(consolidation_occurs)\n\n    # Format and print the final output as a single-line string\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "在真实的神经回路中，突触并非孤立存在，它们常常需要竞争有限的细胞资源。这个练习将我们的视角从单个突触扩展到一个更符合生物学现实的场景：两个突触竞争一个共享的可塑性相关蛋白（PRP）池。通过解析推导，你将发现一个优雅的分配原则，即PRPs的捕获量如何仅由各突触的“标记”强度按比例决定，而无需知道PRP浓度的具体动态过程。这项实践揭示了突触间竞争与合作的基本机制，这是理解记忆痕迹如何在众多突触中选择性加强的关键。",
            "id": "4025805",
            "problem": "考虑一个突触标记与捕获 (synaptic tagging and capture, STC) 模型，其中一个短暂的诱导刺激会产生一个可塑性相关产物 (plasticity-related products, PRPs) 池，其浓度为 $R(t)$，在一段树突段内空间上是均匀的。两个突触，索引为 $i \\in \\{1,2\\}$，在捕获窗口期内具有不随时间变化的标记强度 $T_{1}$ 和 $T_{2}$。PRP池受合成和损耗过程的控制：PRP由刺激驱动的通量 $S(t) \\ge 0$ 合成，以速率常数 $\\kappa  0$ 进行一级衰变，并通过标记-PRP结合被突触不可逆地捕获。假设以下基于化学动力学和生物物理模型的基本原则：\n- 质量作用定律控制着突触 $i$ 处不可逆的标记-PRP捕获过程，其捕获速率常数为 $\\eta  0$，除了 $R(t)$ 的耗尽外没有其他饱和效应。\n- 突触 $i$ 处的捕获通量 $c_{i}(t)$ 与 $T_{i}$ 和 $R(t)$ 的瞬时乘积成正比。\n- PRP池 $R(t)$ 在捕获窗口期内是充分混合的，并且对两个突触是共有的。\n- 捕获的总PRP等于时间积分和 $\\int_{0}^{\\infty} \\big(c_{1}(t) + c_{2}(t)\\big)\\,\\mathrm{d}t$。\n\n将分配到突触1的预期比例定义为\n$$\nA_{1} \\equiv \\frac{\\int_{0}^{\\infty} c_{1}(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\big(c_{1}(t) + c_{2}(t)\\big)\\,\\mathrm{d}t}.\n$$\n推导一个仅用标记强度 $T_{1}$ 和 $T_{2}$ 表示的 $A_{1}$ 的封闭形式表达式，无需解出 $R(t)$ 或指定 $S(t)$，然后确定当 $T_{1} \\gg T_{2}$ 时 $A_{1}$ 的优势极限值。\n\n使用LaTeX的 $\\mathrm{pmatrix}$ 环境，将你的最终答案表示为一个双元素行矩阵，其中第一个元素等于 $A_{1}(T_{1},T_{2})$ 的通用表达式，第二个元素等于 $T_{1} \\gg T_{2}$ 条件下 $A_{1}$ 的极限值。无需四舍五入。无需单位。",
            "solution": "该问题要求我们推导分配给突触1的可塑性相关产物（PRPs）的比例 $A_1$。这个比例定义为突触1在无限时间内捕获的总PRP量与两个突触捕获的总PRP量之比。\n\n根据问题陈述，突触 $i$ 的捕获通量 $c_{i}(t)$ 遵循质量作用定律，与标记强度 $T_i$ 和共享的PRP浓度 $R(t)$ 的乘积成正比。我们可以用一个速率常数 $\\eta > 0$ 来表示这个关系：\n$$\nc_{i}(t) = \\eta T_{i} R(t), \\quad \\text{其中 } i \\in \\{1,2\\}\n$$\n这里，常数 $\\eta$ 代表了标记对PRP的内在捕获效率，而 $T_i$ 是突触 $i$ 的标记强度，在捕获窗口期内被假定为常数。\n\n我们将此表达式代入 $A_1$ 的定义中：\n$$\nA_{1} \\equiv \\frac{\\int_{0}^{\\infty} c_{1}(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\left(c_{1}(t) + c_{2}(t)\\right)\\,\\mathrm{d}t} = \\frac{\\int_{0}^{\\infty} \\eta T_{1} R(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\left(\\eta T_{1} R(t) + \\eta T_{2} R(t)\\right)\\,\\mathrm{d}t}\n$$\n在分母的被积函数中，我们可以提取出公因子 $\\eta R(t)$:\n$$\nA_{1} = \\frac{\\int_{0}^{\\infty} \\eta T_{1} R(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\eta (T_{1} + T_{2}) R(t)\\,\\mathrm{d}t}\n$$\n由于 $T_1$、$T_2$ 和 $\\eta$ 都是常数，我们可以根据积分的线性性质将它们从积分号中提出来：\n$$\nA_{1} = \\frac{\\eta T_{1} \\int_{0}^{\\infty} R(t)\\,\\mathrm{d}t}{\\eta (T_{1} + T_{2}) \\int_{0}^{\\infty} R(t)\\,\\mathrm{d}t}\n$$\n这个表达式的关键在于，公共项 $\\eta \\int_{0}^{\\infty} R(t)\\,\\mathrm{d}t$ 出现在分子和分母中。只要这个积分不为零（即PRP池不总是空的），我们就可以将其约去。这一步使得最终结果独立于PRP浓度 $R(t)$ 的具体时间演化过程、其合成速率 $S(t)$ 以及其自身的衰变速率 $\\kappa$。\n\n约去公共项后，我们得到了一个仅依赖于标记强度 $T_1$ 和 $T_2$ 的简洁表达式：\n$$\nA_{1} = \\frac{T_{1}}{T_{1} + T_{2}}\n$$\n这就是问题要求的第一部分。这个结果揭示了一个基本的竞争性分配原则：在一个竞争共享资源的环境中，任何一个参与者所获得的资源份额，等于其自身的“捕获能力”（在这里是标记强度）占所有参与者总能力的比例。\n\n接下来，我们需要确定当 $T_{1} \\gg T_{2}$ 时 $A_{1}$ 的极限值。这个条件意味着比率 $\\frac{T_{2}}{T_{1}}$ 趋近于0。为了计算这个极限，我们将 $A_1$ 表达式的分子和分母同除以 $T_1$：\n$$\nA_{1} = \\frac{T_{1}/T_{1}}{(T_{1} + T_{2})/T_{1}} = \\frac{1}{1 + \\frac{T_{2}}{T_{1}}}\n$$\n现在，取 $\\frac{T_{2}}{T_{1}} \\to 0$ 的极限：\n$$\n\\lim_{\\frac{T_{2}}{T_{1}} \\to 0} A_{1} = \\lim_{\\frac{T_{2}}{T_{1}} \\to 0} \\frac{1}{1 + \\frac{T_{2}}{T_{1}}} = \\frac{1}{1 + 0} = 1\n$$\n这个结果符合直觉：如果突触1的标记强度远大于突触2，它将捕获几乎所有可用的PRP，因此其分配比例趋近于1。\n\n综上，我们得到了 $A_1$ 的通用表达式及其在 $T_1 \\gg T_2$ 条件下的极限值。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{T_{1}}{T_{1} + T_{2}}  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "这项最终实践将理论与实验联系起来，构成了计算建模的完整闭环。你将首先推导STC模型对于“弱刺激-强刺激”时间间隔（$\\Delta t$）与巩固效率之间关系的定量预测，然后利用这个模型来拟合模拟的实验数据。这个任务让你扮演计算神经科学家的角色，通过数据分析从可观测的行为中提取出无法直接测量的生物学参数（如 $\\tau_T$ 和 $\\tau_P$），从而验证并量化理论模型。",
            "id": "4025852",
            "problem": "您的任务是在突触标记与捕获 (STC) 模型的背景下，对一个时间扫描实验进行形式化和计算分析。该实验改变了一个弱突触事件（设置一个瞬时标记）和一个强突触事件（诱导一个可塑性相关产物池）之间的时间差 $\\,\\Delta t\\,$，并测量巩固率作为 $\\,\\Delta t\\,$ 的函数。您的目标是，从适用于STC的第一性原理出发，推导出一个由衰减动力学驱动的、基于重叠的巩固曲线，并将模型参数与给定数据进行拟合，以提取标记和产物池的特征衰减时间常数，分别表示为 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$。\n\n请使用以下基本原理进行推导：\n- 弱事件设置一个幅值为 $\\,T_{0}\\,$ 的突触标记，该标记以时间常数 $\\,\\tau_{T}\\,$ 指数衰减，因此在时间 $\\,t\\,$ 的标记幅值为 $\\,T(t) = T_{0}\\,e^{-t/\\tau_{T}}$，对于 $\\,t \\ge 0\\,$。\n- 强事件在时间 $\\,t = \\Delta t\\,$ 开始产生一个幅值为 $\\,P_{0}\\,$ 的可塑性相关产物池，该产物池以时间常数 $\\,\\tau_{P}\\,$ 指数衰减，因此 $\\,P(t) = P_{0}\\,e^{-(t-\\Delta t)/\\tau_{P}}$ 对于 $\\,t \\ge \\Delta t\\,$，且 $\\,P(t) = 0\\,$ 对于 $\\,t  \\Delta t\\,$。\n- 巩固是由重叠捕获驱动的，即一个有效的巩固驱动力，其大小与乘积 $\\,T(t)P(t)\\,$ 对 $\\,t\\,$ 的时间积分成正比，再乘以一个恒定的捕获效率 $\\,k  0\\,$。\n\n您必须：\n1. 纯粹基于上述原理推导依赖于 $\\Delta t$ 的巩固曲线，不引入任何未被这些定义所蕴含的额外目标公式。\n2. 实现一个非线性曲线拟合程序，根据所提供的作为 $\\,\\Delta t\\,$ 函数的巩固率数据来估计 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$。假设存在一个未知的振幅参数 $\\,A  0\\,$，它吸收了诸如 $\\,T_{0}\\,$、$\\,P_{0}\\,$ 和 $\\,k\\,$ 等常数以及任何比例因子，因此待拟合的模型参数为 $\\,(\\tau_{T}, \\tau_{P}, A)\\,$。将 $\\,\\tau_{T}\\,$、$\\,\\tau_{P}\\,$ 和 $\\,A\\,$ 约束为严格为正。\n3. 将所有时间常数 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$ 以秒为单位表示，并以四舍五入到三位小数的浮点数形式返回。\n4. 您的程序应生成单行输出，其中包含一个列表的列表，格式为 $\\,[[\\tau_{T}^{(1)},\\tau_{P}^{(1)}],[\\tau_{T}^{(2)},\\tau_{P}^{(2)}],\\ldots]\\,$，其中包含以逗号分隔的结果。\n\n测试套件和数据：\n您将把模型拟合到三个独立的数据集上，每个数据集都指定了一系列 $\\,\\Delta t\\,$ 值（单位：秒）和相应的测量巩固率（在 $[0,1]$ 范围内的无量纲浮点数）。对于每个数据集，计算并返回估计的 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$。\n\n- 数据集 $\\,1\\,$：\n  - $\\,\\Delta t\\,$ 值：$\\,[-200, -100, -50, -25, 0, 25, 50, 100, 200]\\,$ (秒)。\n  - 巩固率：$\\,[0.158158,\\,0.308050,\\,0.429919,\\,0.507889,\\,0.600000,\\,0.321157,\\,0.171903,\\,0.049251,\\,0.004043]\\,$。\n\n- 数据集 $\\,2\\,$：\n  - $\\,\\Delta t\\,$ 值：$\\,[-400, -200, -100, -50, 0, 50, 100, 200, 400]\\,$ (秒)。\n  - 巩固率：$\\,[0.012820,\\,0.094735,\\,0.257515,\\,0.424572,\\,0.700000,\\,0.424572,\\,0.257515,\\,0.094735,\\,0.012820]\\,$。\n\n- 数据集 $\\,3\\,$：\n  - $\\,\\Delta t\\,$ 值：$\\,[-60, -30, -10, 0, 10, 30, 60]\\,$ (秒)。\n  - 巩固率：$\\,[0.039830,\\,0.178504,\\,0.485225,\\,0.800000,\\,0.294303,\\,0.039830,\\,0.001983]\\,$。\n\n设计曲线拟合以测试不同方面：\n- 具有非对称时间常数的一般识别（数据集 $\\,1\\,$）。\n- 具有相等时间常数的边界条件（数据集 $\\,2\\,$）。\n- 具有窄巩固窗口和快速衰减的边缘情况（数据集 $\\,3\\,$）。\n\n您的程序必须是自包含的，不得读取任何外部输入，并且必须精确打印一行包含列表的列表，其中包含以秒为单位、四舍五入到三位小数的估计时间常数，如上所述。不涉及角度单位。不涉及百分比；所有输出必须是浮点数。给定上述数据，计算过程应完全可复现。",
            "solution": "该问题要求在突触标记与捕获 (STC) 模型的背景下，推导并计算拟合一条巩固率曲线。此过程包括两个主要步骤：首先，推导巩固率作为弱刺激和强刺激之间时间延迟 $\\Delta t$ 函数的解析形式；其次，实现一个数值程序，将此模型与提供的实验数据进行拟合，以估计一组生物物理参数。\n\n### 步骤 1：巩固曲线 $C(\\Delta t)$ 的推导\n\n模型的基础原理已经给出。在时间 $t=0$ 的弱刺激建立一个突触标记 $T(t)$，在时间 $t=\\Delta t$ 的强刺激生成一个可塑性相关产物池 $P(t)$。\n\n标记幅值定义为：\n$$ T(t) = \\begin{cases} T_0 e^{-t/\\tau_T}  \\text{for } t \\ge 0 \\\\ 0  \\text{for } t  0 \\end{cases} $$\n其中 $T_0$ 是初始标记幅值，$\\tau_T$ 是标记的衰减时间常数。\n\n可塑性产物池浓度定义为：\n$$ P(t) = \\begin{cases} P_0 e^{-(t-\\Delta t)/\\tau_P}  \\text{for } t \\ge \\Delta t \\\\ 0  \\text{for } t  \\Delta t \\end{cases} $$\n其中 $P_0$ 是初始产物幅值，$\\tau_P$ 是产物的衰减时间常数。\n\n假设巩固与标记和产物信号的重叠积分成正比。因此，我们记为 $C(\\Delta t)$ 的巩固率与乘积 $T(t)P(t)$ 的时间积分成正比：\n$$ C(\\Delta t) = k \\int_{-\\infty}^{\\infty} T(t)P(t) dt $$\n其中 $k>0$ 是表示捕获效率的常数。\n\n为了计算该积分，我们首先注意到被积函数 $T(t)P(t)$ 仅在 $T(t)$ 和 $P(t)$ 均非零时才非零。这要求 $t \\ge 0$ 且 $t \\ge \\Delta t$。因此，积分下限必须是 $\\max(0, \\Delta t)$。\n\n我们记为 $I(\\Delta t)$ 的积分是：\n$$ I(\\Delta t) = \\int_{\\max(0, \\Delta t)}^{\\infty} \\left( T_0 e^{-t/\\tau_T} \\right) \\left( P_0 e^{-(t-\\Delta t)/\\tau_P} \\right) dt $$\n我们可以从被积函数中分离出与时间无关的部分：\n$$ I(\\Delta t) = T_0 P_0 e^{\\Delta t/\\tau_P} \\int_{\\max(0, \\Delta t)}^{\\infty} e^{-t/\\tau_T} e^{-t/\\tau_P} dt $$\n$$ I(\\Delta t) = T_0 P_0 e^{\\Delta t/\\tau_P} \\int_{\\max(0, \\Delta t)}^{\\infty} e^{-t(1/\\tau_T + 1/\\tau_P)} dt $$\n让我们为组合衰减定义一个有效时间常数 $\\tau_{eff}$：\n$$ \\frac{1}{\\tau_{eff}} = \\frac{1}{\\tau_T} + \\frac{1}{\\tau_P} = \\frac{\\tau_T + \\tau_P}{\\tau_T \\tau_P} \\implies \\tau_{eff} = \\frac{\\tau_T \\tau_P}{\\tau_T + \\tau_P} $$\n该积分的计算结果为：\n$$ \\int_{\\max(0, \\Delta t)}^{\\infty} e^{-t/\\tau_{eff}} dt = \\left[ -\\tau_{eff} e^{-t/\\tau_{eff}} \\right]_{\\max(0, \\Delta t)}^{\\infty} = 0 - (-\\tau_{eff} e^{-\\max(0, \\Delta t)/\\tau_{eff}}) = \\tau_{eff} e^{-\\max(0, \\Delta t)/\\tau_{eff}} $$\n将此结果代回 $I(\\Delta t)$ 的表达式中：\n$$ I(\\Delta t) = T_0 P_0 e^{\\Delta t/\\tau_P} \\tau_{eff} e^{-\\max(0, \\Delta t)/\\tau_{eff}} $$\n我们现在分析这个表达式在正和负时间延迟 $\\Delta t$ 下的情况。\n\n**情况 1：$\\Delta t \\ge 0$（弱刺激先于或同时于强刺激）**\n在这种情况下，$\\max(0, \\Delta t) = \\Delta t$。表达式变为：\n$$ I(\\Delta t) = T_0 P_0 \\tau_{eff} e^{\\Delta t/\\tau_P} e^{-\\Delta t/\\tau_{eff}} = T_0 P_0 \\tau_{eff} e^{\\Delta t(1/\\tau_P - 1/\\tau_{eff})} $$\n代入 $1/\\tau_{eff}$ 的定义：\n$$ \\frac{1}{\\tau_P} - \\frac{1}{\\tau_{eff}} = \\frac{1}{\\tau_P} - \\left(\\frac{1}{\\tau_T} + \\frac{1}{\\tau_P}\\right) = -\\frac{1}{\\tau_T} $$\n因此，对于 $\\Delta t \\ge 0$：\n$$ I(\\Delta t) = T_0 P_0 \\tau_{eff} e^{-\\Delta t/\\tau_T} $$\n\n**情况 2：$\\Delta t  0$（强刺激先于弱刺激）**\n在这种情况下，$\\max(0, \\Delta t) = 0$。表达式变为：\n$$ I(\\Delta t) = T_0 P_0 \\tau_{eff} e^{\\Delta t/\\tau_P} e^{-0/\\tau_{eff}} = T_0 P_0 \\tau_{eff} e^{\\Delta t/\\tau_P} $$\n\n结合这两种情况，并引入一个单一的未知振幅参数 $A$ 来吸收所有常数和比例因子（$A$ 正比于 $k T_0 P_0 \\tau_{eff}$），用于拟合数据的最终模型函数是：\n$$ f(\\Delta t; A, \\tau_T, \\tau_P) = \\begin{cases} A e^{\\Delta t/\\tau_P}  \\text{if } \\Delta t  0 \\\\ A e^{-\\Delta t/\\tau_T}  \\text{if } \\Delta t \\ge 0 \\end{cases} $$\n该函数表示一个双边指数衰减，在 $\\Delta t=0$ 处达到峰值，振幅为 $A$，对于正 $\\Delta t$ 和负 $\\Delta t$ 分别具有可能不同的衰减常数 $\\tau_T$ 和 $\\tau_P$。\n\n### 步骤 2：参数估计的计算策略\n\n任务是找到最能拟合所提供数据集的参数 $(A, \\tau_T, \\tau_P)$。这是一个非线性最小二乘回归问题。我们将使用 `scipy.optimize` 模块中的 `curve_fit` 函数。\n\n对每个数据集的程序如下：\n1.  **定义模型函数**：创建一个实现 $f(\\Delta t; A, \\tau_T, \\tau_P)$ 的 Python 函数。该函数将以自变量 $\\Delta t$ 和三个待拟合参数作为输入。\n2.  **提供初始猜测值 ($p_0$)**：`curve_fit` 算法需要参数的初始猜测值。我们可以从数据中估计这些值：\n    *   $A_{guess}$：观测到的最大巩固率是 $A$ 的一个良好估计。\n    *   $\\tau_{T,guess}$：对于一个 $\\Delta t_i > 0$ 的数据点 $(\\Delta t_i, y_i)$，我们有 $y_i \\approx A e^{-\\Delta t_i / \\tau_T}$。可以将其反转以估计 $\\tau_T \\approx -\\Delta t_i / \\ln(y_i/A)$。我们将使用具有最大正 $\\Delta t_i$ 的点来进行稳定估计。\n    *   $\\tau_{P,guess}$：类似地，对于一个 $\\Delta t_j  0$ 的点 $(\\Delta t_j, y_j)$，我们有 $y_j \\approx A e^{\\Delta t_j / \\tau_P}$，从而得到估计值 $\\tau_P \\approx \\Delta t_j / \\ln(y_j/A)$。我们将使用具有最负 $\\Delta t_j$ 的点。\n3.  **设置参数边界**：问题说明 $A, \\tau_T$ 和 $\\tau_P$ 必须严格为正。这通过使用 `curve_fit` 的 `bounds` 参数来强制执行。所有三个参数的下界将设置为一个小的正数（例如，$10^{-9}$）以确保正性和数值稳定性，而上界将是无穷大。\n4.  **执行拟合**：使用实验数据（$\\Delta t$ 值和巩固率）、模型函数、初始猜测值和边界调用 `curve_fit`。该函数返回使残差平方和最小化的最优参数值。\n5.  **提取并格式化结果**：从拟合的参数中，我们提取 $\\tau_T$ 和 $\\tau_P$ 的值，按要求将它们四舍五入到三位小数并存储。对所有三个数据集重复此过程。最后，将收集到的参数对格式化为指定的字符串格式。\n\n这种方法提供了一条从第一性原理推导到模型关键参数定量估计的稳健路径，并遵守了问题的所有约束和要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Derives and fits a synaptic tagging and capture model to three datasets.\n\n    The model function for the consolidation rate C as a function of the\n    time difference dt is a double exponential:\n    C(dt) = A * exp(dt / tau_P) for dt  0\n    C(dt) = A * exp(-dt / tau_T) for dt >= 0\n\n    The function fits parameters A, tau_T, and tau_P for each dataset\n    using nonlinear least squares and returns the estimated time constants.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"delta_t\": np.array([-200, -100, -50, -25, 0, 25, 50, 100, 200]),\n            \"rates\": np.array([0.158158, 0.308050, 0.429919, 0.507889, 0.600000, 0.321157, 0.171903, 0.049251, 0.004043])\n        },\n        {\n            \"delta_t\": np.array([-400, -200, -100, -50, 0, 50, 100, 200, 400]),\n            \"rates\": np.array([0.012820, 0.094735, 0.257515, 0.424572, 0.700000, 0.424572, 0.257515, 0.094735, 0.012820])\n        },\n        {\n            \"delta_t\": np.array([-60, -30, -10, 0, 10, 30, 60]),\n            \"rates\": np.array([0.039830, 0.178504, 0.485225, 0.800000, 0.294303, 0.039830, 0.001983])\n        }\n    ]\n\n    def stc_model(delta_t, A, tau_T, tau_P):\n        \"\"\"\n        Synaptic Tagging and Capture consolidation model function.\n\n        Args:\n            delta_t (np.ndarray): Time difference(s) between weak and strong stimuli.\n            A (float): Amplitude parameter.\n            tau_T (float): Decay time constant for the synaptic tag (for delta_t >= 0).\n            tau_P (float): Decay time constant for the plasticity product (for delta_t  0).\n\n        Returns:\n            np.ndarray: The predicted consolidation rates.\n        \"\"\"\n        # np.where selects between the two exponential decay forms based on the sign of delta_t.\n        # This creates the asymmetric double-exponential curve.\n        return A * np.exp(np.where(delta_t  0, delta_t / tau_P, -delta_t / tau_T))\n\n    results = []\n    \n    for case in test_cases:\n        x_data = case[\"delta_t\"]\n        y_data = case[\"rates\"]\n\n        # 1. Generate initial guesses (p0) for the fitting parameters.\n        A_guess = np.max(y_data)\n        \n        # Estimate tau_T from the last positive-time data point.\n        pos_time_mask = x_data > 0\n        if np.any(pos_time_mask):\n            last_pos_x = x_data[pos_time_mask][-1]\n            last_pos_y = y_data[pos_time_mask][-1]\n            # tau_T = -t / ln(y/A)\n            tau_T_guess = -last_pos_x / np.log(np.clip(last_pos_y / A_guess, 1e-9, 1-1e-9))\n        else: # Fallback if no positive time points\n            tau_T_guess = 100.0\n\n        # Estimate tau_P from the first negative-time data point.\n        neg_time_mask = x_data  0\n        if np.any(neg_time_mask):\n            first_neg_x = x_data[neg_time_mask][0]\n            first_neg_y = y_data[neg_time_mask][0]\n            # tau_P = t / ln(y/A)\n            tau_P_guess = first_neg_x / np.log(np.clip(first_neg_y / A_guess, 1e-9, 1-1e-9))\n        else: # Fallback if no negative time points\n            tau_P_guess = 100.0\n            \n        p0 = [A_guess, tau_T_guess, tau_P_guess]\n\n        # 2. Define bounds for the parameters (must be strictly positive).\n        # We use a small positive number instead of 0 for numerical stability.\n        lower_bounds = [1e-9, 1e-9, 1e-9]\n        upper_bounds = [np.inf, np.inf, np.inf]\n        bounds = (lower_bounds, upper_bounds)\n\n        # 3. Perform the nonlinear least-squares fit.\n        try:\n            popt, _ = curve_fit(stc_model, x_data, y_data, p0=p0, bounds=bounds, method='trf', max_nfev=5000)\n            A_fit, tau_T_fit, tau_P_fit = popt\n        except RuntimeError:\n            # Fallback in case the fit fails, though unlikely with these data\n            tau_T_fit, tau_P_fit = -1.0, -1.0\n\n        # 4. Store the rounded results.\n        results.append([round(tau_T_fit, 3), round(tau_P_fit, 3)])\n\n    # Final print statement in the exact required format.\n    string_results = [f\"[{res_pair[0]},{res_pair[1]}]\" for res_pair in results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}