{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究具体的神经模型之前，首先通过一个基础练习来掌握竞争模型的核心统计原理。 该练习将探讨当多个独立的随机过程竞争完成一个任务时，获胜者（即最先完成的过程）的完成时间是如何分布的。通过这个推导，你将亲自验证竞争模型的一个基本预测——“冗余增益”（redundancy gain），即多个并行过程会导致更快的整体响应，为理解更复杂的模型奠定数学基础。",
            "id": "4012846",
            "problem": "在一个受阈值遍历率线性方法 (LATER) 框架启发的眼跳启动竞争模型中，假设有 $n$ 个独立的并行通道，每个通道代表一个竞争达到某一准则的随机决策单元。在这个简化设定中，假设通道 $i$ 的完成时间是一个指数随机变量 $T_i \\sim \\mathrm{Exp}(\\lambda)$，其率参数为 $\\lambda$ (单位为 $\\mathrm{s}^{-1}$)，并且所有通道的 $T_i$ 是独立同分布的。令 $T_{\\min} = \\min\\{T_1,\\dots,T_n\\}$ 表示竞争中观测到的决策时间，对应于最早完成的通道。\n\n仅使用独立性、生存函数和指数分布的无记忆性等基本性质（或基于独立泊松过程叠加的等效论证），推导 $T_{\\min}$ 的概率密度函数，然后计算其均值 $\\mathbb{E}[T_{\\min}]$ 和方差 $\\operatorname{Var}(T_{\\min})$，表示为 $n$ 和 $\\lambda$ 的显式函数。时间以秒表示，率以 $\\mathrm{s}^{-1}$ 表示，但最终的方框答案中不包含单位。\n\n以包含 $\\mathbb{E}[T_{\\min}]$ 和 $\\operatorname{Var}(T_{\\min})$（用 $n$ 和 $\\lambda$ 表示）的行向量形式提供你的最终答案。无需四舍五入。",
            "solution": "首先验证问题陈述的正确性和可解性。\n\n### 第1步：提取已知条件\n- 有 $n$ 个独立的并行通道。\n- 通道 $i$ 的完成时间是一个随机变量 $T_i$。\n- 每个 $T_i$ 的分布是率参数为 $\\lambda$ 的指数分布：$T_i \\sim \\mathrm{Exp}(\\lambda)$。\n- 率参数 $\\lambda$ 的单位是 $\\mathrm{s}^{-1}$。\n- 随机变量 $T_i$（对于 $i=1, \\dots, n$）是独立同分布的（i.i.d.）。\n- 观测到的决策时间是 $T_{\\min} = \\min\\{T_1,\\dots,T_n\\}$。\n- 任务是推导 $T_{\\min}$ 的概率密度函数（PDF），然后计算其均值 $\\mathbb{E}[T_{\\min}]$ 和方差 $\\operatorname{Var}(T_{\\min})$，作为 $n$ 和 $\\lambda$ 的函数。\n- 推导必须使用独立性、生存函数和无记忆性的基本性质，或基于泊松过程叠加的等效论证。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：** 该问题坚实地植根于概率论及其在计算神经科学中的应用。竞争模型，特别是使用指数分布的模型，是研究决策过程（如眼跳运动）的标准且成熟的框架（如 LATER 模型）。该问题是关于独立同分布随机变量的顺序统计量统计学中的一个经典练习。\n- **适定性：** 该问题是适定的。目标是找出一组独立同分布指数随机变量最小值的分布、均值和方差。这是概率论中的一个标准问题，具有唯一、稳定且有意义的解。\n- **客观性：** 问题使用精确、客观的数学语言陈述。\n- **缺陷：** 问题陈述没有任何无效性缺陷。它在科学上是合理的、可形式化的、完整的、在建模背景下是现实的、适定的，也是非平凡的。\n\n### 第3步：结论与行动\n该问题有效。将提供完整解答。\n\n### 推导与解答\n令 $T_i$（对于 $i=1, \\dots, n$）为代表 $n$ 个通道完成时间的独立同分布随机变量。每个 $T_i$ 服从率参数为 $\\lambda > 0$ 的指数分布，记作 $T_i \\sim \\mathrm{Exp}(\\lambda)$。\n\n每个 $T_i$ 的概率密度函数（PDF）由下式给出：\n$$f_{T_i}(t) = \\begin{cases} \\lambda \\exp(-\\lambda t)  \\text{ if } t \\ge 0 \\\\ 0  \\text{ if } t  0 \\end{cases}$$\n每个 $T_i$ 的累积分布函数（CDF）为 $F_{T_i}(t) = P(T_i \\le t) = 1 - \\exp(-\\lambda t)$，当 $t \\ge 0$ 时。\n每个 $T_i$ 的生存函数为 $S_{T_i}(t) = P(T_i > t) = 1 - F_{T_i}(t) = \\exp(-\\lambda t)$，当 $t \\ge 0$ 时。\n\n我们关心随机变量 $T_{\\min} = \\min\\{T_1, \\dots, T_n\\}$ 的分布。找到 $T_{\\min}$ 分布最直接的方法是先找到其生存函数 $S_{T_{\\min}}(t) = P(T_{\\min} > t)$。\n\n事件 $\\{T_{\\min} > t\\}$ 发生当且仅当*每个*通道的完成时间都大于 $t$。在数学上，这是事件 $\\{T_1 > t\\}, \\{T_2 > t\\}, \\dots, \\{T_n > t\\}$ 的交集。\n$$P(T_{\\min} > t) = P(T_1 > t \\text{ and } T_2 > t \\text{ and } \\dots \\text{ and } T_n > t)$$\n由于随机变量 $T_i$ 是独立的，这些事件交集的概率是它们各自概率的乘积：\n$$P(T_{\\min} > t) = P(T_1 > t) P(T_2 > t) \\cdots P(T_n > t) = \\prod_{i=1}^{n} P(T_i > t)$$\n因为 $T_i$ 也是同分布的，所以对所有 $i$ 都有 $P(T_i > t) = S_{T_i}(t) = \\exp(-\\lambda t)$。将此代入乘积中得到：\n$$S_{T_{\\min}}(t) = \\prod_{i=1}^{n} \\exp(-\\lambda t) = (\\exp(-\\lambda t))^n = \\exp(-n\\lambda t)$$\n这个表达式 $S_{T_{\\min}}(t) = \\exp(-(n\\lambda)t)$ 是一个率参数为 $n\\lambda$ 的指数分布的生存函数。\n\n为了确认并找到 PDF，我们首先找到 $T_{\\min}$ 的 CDF：\n$$F_{T_{\\min}}(t) = P(T_{\\min} \\le t) = 1 - S_{T_{\\min}}(t) = 1 - \\exp(-n\\lambda t) \\quad \\text{for } t \\ge 0$$\n$T_{\\min}$ 的 PDF 是其 CDF 关于 $t$ 的导数：\n$$f_{T_{\\min}}(t) = \\frac{d}{dt} F_{T_{\\min}}(t) = \\frac{d}{dt} (1 - \\exp(-n\\lambda t)) = -(-n\\lambda)\\exp(-n\\lambda t) = n\\lambda \\exp(-n\\lambda t) \\quad \\text{for } t \\ge 0$$\n这恰好是率参数为 $n\\lambda$ 的指数分布的 PDF。因此，我们证明了 $T_{\\min} \\sim \\mathrm{Exp}(n\\lambda)$。\n\n另外，如题干所建议，可以考虑 $n$ 个独立泊松过程的叠加，每个过程的率为 $\\lambda$。每个过程中第一个事件发生的时间是指数随机变量 $T_i \\sim \\mathrm{Exp}(\\lambda)$。这 $n$ 个过程的叠加形成一个总率为 $\\Lambda = \\sum_{i=1}^n \\lambda = n\\lambda$ 的单一泊松过程。变量 $T_{\\min}$ 代表这个组合过程中第一个事件发生的时间。在一个率为 $\\Lambda$ 的泊松过程中，等待第一个事件发生的时间服从率相同的指数分布。因此，$T_{\\min} \\sim \\mathrm{Exp}(n\\lambda)$，这证实了之前的结果。\n\n现在，我们计算 $T_{\\min}$ 的均值和方差。对于一个一般的随机变量 $X \\sim \\mathrm{Exp}(\\mu)$，其均值（期望值）和方差由以下公式给出：\n$$\\mathbb{E}[X] = \\frac{1}{\\mu}$$\n$$\\operatorname{Var}(X) = \\frac{1}{\\mu^2}$$\n在我们的情况下，随机变量是 $T_{\\min}$，其率参数为 $\\mu = n\\lambda$。应用这些公式，我们得到：\n$T_{\\min}$ 的均值是：\n$$\\mathbb{E}[T_{\\min}] = \\frac{1}{n\\lambda}$$\n$T_{\\min}$ 的方差是：\n$$\\operatorname{Var}(T_{\\min}) = \\frac{1}{(n\\lambda)^2} = \\frac{1}{n^2\\lambda^2}$$\n这些就是问题所要求的 $n$ 和 $\\lambda$ 的显式函数。最终答案将以包含这两个结果的行向量形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{n\\lambda}  \\frac{1}{n^{2}\\lambda^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了竞争模型的基本统计特性后，我们现在聚焦于一个在决策神经科学中极具影响力的具体模型——LATER模型。 这个练习将引导你推导该模型的一个关键特性，并向你介绍一种强大的数据分析工具——倒数累积概率图（reciprobit plot）。你将发现，模型中的一个核心理论参数——决策阈值，与图上的斜率有着直接的数学关系，这揭示了我们如何通过分析反应时数据来推断认知策略（如速度-准确率权衡）的变化。",
            "id": "4012834",
            "problem": "考虑反应时间的阈值线性趋近遍历速率 (Linear Approach to Threshold with Ergodic Rate, LATER) 模型。在该模型中，决策信号从一个初始水平 $S_{0}$ 开始，以随机速率 $r$ 线性上升至决策阈值 $S$。假设 $r$ 在每次试验中独立地从均值为 $\\mu$、标准差为 $\\sigma$ 的正态 (高斯) 分布中抽取，并且测量的反应时间 (RT) 由 $T = (S - S_{0})/r$ 给出，不包含附加的非决策部分。倒数概率单位图 (reciprobit) 表示法在水平轴上考虑反应时间的倒数 $x = 1/T$，在垂直轴上考虑累积概率的概率单位 (probit，即正态累积分布的反函数)。在这种表示法中，$x$ 的累积分布被映射为一条直线。\n\n从这些定义出发，推导倒数概率单位图斜率关于 $S$、$S_{0}$ 和 $\\sigma$ 的一般表达式。然后，假设 $S$ 加倍为 $2S$，而 $S_{0}$、$\\mu$ 和 $\\sigma$ 保持不变。计算倒数概率单位图斜率的乘法变化（即新斜率与原斜率之比），并根据 LATER 模型所蕴含的速度-准确率权衡来解释这一结果。\n\n请以单个闭式解析表达式的形式提供最终答案。所求的比值为无量纲，因此不需要单位。无需四舍五入。",
            "solution": "用户希望我解决一个与计算神经科学中的LATER模型相关的问题。\n\n**问题验证**\n\n**第 1 步：提取已知条件**\n-   模型：反应时间的阈值线性趋近遍历速率 (LATER) 模型。\n-   决策信号从初始水平 $S_{0}$ 开始。\n-   信号线性上升至决策阈值 $S$。\n-   上升速率 $r$ 是一个随机变量。\n-   $r$ 的分布是正态 (高斯) 分布，均值为 $\\mu$，标准差为 $\\sigma$，即 $r \\sim N(\\mu, \\sigma^2)$。\n-   反应时间 (RT) 由公式 $T = (S - S_{0})/r$ 给出。\n-   非决策时间为零。\n-   倒数概率单位图表示法：一个 $z$ 对 $x$ 的图，其中：\n    -   水平轴：反应时间的倒数，$x = 1/T$。\n    -   垂直轴：累积概率的概率单位，$z = \\Phi^{-1}(P(X \\le x))$，其中 $\\Phi$ 是标准正态累积分布函数 (CDF)。\n-   前提：在这种表示法中，$x$ 的累积分布被映射为一条直线。\n-   任务 1：推导倒数概率单位图斜率关于 $S$、$S_{0}$ 和 $\\sigma$ 的一般表达式。\n-   任务 2：假设 $S$ 加倍为 $2S$，而 $S_{0}$、$\\mu$ 和 $\\sigma$ 保持不变。计算倒数概率单位图斜率的乘法变化（比率）。\n-   任务 3：根据速度-准确率权衡解释这一结果。\n\n**第 2 步：使用提取的已知条件进行验证**\n-   **科学依据**：LATER 模型是计算神经科学中用于分析反应时间的一个标准且成熟的模型。模型组件（阈值、速率）和倒数概率单位图的定义在该领域内是标准的。该问题具有科学依据。\n-   **适定性**：该问题要求基于所提供的模型定义进行推导和计算。正如将在解答中展示的，倒数概率单位图是一条直线的前提是模型假设的直接数学结果。这证实了问题的内部一致性。目标清晰，并能导向唯一解。该问题是适定的。\n-   **客观性**：该问题以精确、客观的数学语言陈述，没有主观论断。\n-   **完整性与一致性**：所有必要的定义和参数（$S_0, S, r, \\mu, \\sigma, T, x, z$）均已提供。没有矛盾之处。速率 $r$ 服从正态分布的假设理论上可能导致非物理的负速率，但这是模型中的一个标准理想化处理，在 $\\mu \\gg \\sigma$ 的假设下有效，这使得 $r \\le 0$ 的概率可以忽略不计。这种理想化并不会使问题无效，因为它是被考察模型的核心特征。\n-   **其他缺陷**：该问题并非无关紧要、隐喻性或超出科学验证范围。它是竞赛模型主题下的一个标准推导。\n\n**第 3 步：结论与行动**\n问题有效。我将继续进行解答。\n\n**解**\n\n该问题要求推导 LATER 模型的倒数概率单位图斜率，并分析当决策阈值改变时该斜率如何变化。\n\n首先，我们定义关键量。达到阈值所需的决策信号变化量是 $\\Delta S = S - S_{0}$。反应时间 $T$ 由下式给出：\n$$T = \\frac{\\Delta S}{r} = \\frac{S - S_{0}}{r}$$\n分析在倒数概率单位图空间中进行，该空间在水平轴上使用反应时间的倒数 $x$。\n$$x = \\frac{1}{T} = \\frac{r}{S - S_{0}}$$\n上升速率 $r$ 是一个随机变量，从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布中抽取：\n$$r \\sim N(\\mu, \\sigma^2)$$\n由于 $x$ 是正态分布随机变量 $r$ 的线性变换（即 $x = a \\cdot r$，其中 $a = 1/(S-S_0)$ 对于任何给定的试验都是一个常数），$x$ 也是一个服从正态分布的随机变量。我们可以如下求出其均值 $\\mu_x$ 和标准差 $\\sigma_x$：\n$x$ 的均值为：\n$$\\mu_x = E[x] = E\\left[\\frac{r}{S - S_{0}}\\right] = \\frac{E[r]}{S - S_{0}} = \\frac{\\mu}{S - S_{0}}$$\n$x$ 的方差为：\n$$\\sigma_x^2 = \\text{Var}(x) = \\text{Var}\\left(\\frac{r}{S - S_{0}}\\right) = \\frac{\\text{Var}(r)}{(S - S_{0})^2} = \\frac{\\sigma^2}{(S - S_{0})^2}$$\n因此，$x$ 的标准差为：\n$$\\sigma_x = \\sqrt{\\frac{\\sigma^2}{(S - S_{0})^2}} = \\frac{\\sigma}{|S - S_{0}|}$$\n由于决策信号向阈值上升，我们必须有 $S > S_{0}$，所以 $|S - S_{0}| = S - S_{0}$。因此：\n$$\\sigma_x = \\frac{\\sigma}{S - S_{0}}$$\n所以，反应时间倒数的分布为 $x \\sim N(\\mu_x, \\sigma_x^2)$。\n\n倒数概率单位图在纵轴上显示累积概率的概率单位 $z = \\Phi^{-1}(P(X \\le x))$，在水平轴上显示反应时间的倒数 $x$。这里，$\\Phi^{-1}$ 是标准正态累积分布函数 (CDF) 的反函数，也称为概率单位函数。\n\n对于一个服从 $x \\sim N(\\mu_x, \\sigma_x^2)$ 的正态分布变量，其累积概率由下式给出：\n$$P(X \\le x) = \\Phi\\left(\\frac{x - \\mu_x}{\\sigma_x}\\right)$$\n将此代入纵轴变量 $z$ 的定义中：\n$$z = \\Phi^{-1}\\left( \\Phi\\left(\\frac{x - \\mu_x}{\\sigma_x}\\right) \\right) = \\frac{x - \\mu_x}{\\sigma_x}$$\n这个方程可以重排为直线标准形式 $z = mx + c$：\n$$z = \\left(\\frac{1}{\\sigma_x}\\right) x - \\frac{\\mu_x}{\\sigma_x}$$\n这证实了问题的前提，即倒数概率单位图是一条直线。这条线的斜率，我们称之为 $m_{\\text{recip}}$，是 $x$ 的系数。\n\n**第 1 部分：倒数概率单位图斜率的一般表达式**\n斜率由下式给出：\n$$m_{\\text{recip}} = \\frac{1}{\\sigma_x}$$\n代入我们为 $\\sigma_x$ 推导出的表达式：\n$$m_{\\text{recip}} = \\frac{1}{\\frac{\\sigma}{S - S_{0}}} = \\frac{S - S_{0}}{\\sigma}$$\n这是倒数概率单位图斜率关于阈值 $S$、起始水平 $S_{0}$ 和速率标准差 $\\sigma$ 的一般表达式。\n\n**第 2 部分：斜率的乘法变化**\n原始斜率，决策阈值为 $S$，是：\n$$m_{orig} = \\frac{S - S_{0}}{\\sigma}$$\n现在，阈值加倍为 $S' = 2S$，而所有其他参数（$S_{0}$、$\\mu$、$\\sigma$）保持不变。新斜率 $m_{new}$ 是：\n$$m_{new} = \\frac{S' - S_{0}}{\\sigma} = \\frac{2S - S_{0}}{\\sigma}$$\n问题要求计算乘法变化，即新斜率与原始斜率之比：\n$$\\text{Ratio} = \\frac{m_{new}}{m_{orig}} = \\frac{\\frac{2S - S_{0}}{\\sigma}}{\\frac{S - S_{0}}{\\sigma}}$$\n因子 $\\sigma$ 被消去，剩下：\n$$\\text{Ratio} = \\frac{2S - S_{0}}{S - S_{0}}$$\n\n**第 3 部分：解释**\n在 LATER 这类决策模型中，速度-准确率权衡描述了这样一种现象：更快的决策通常更容易出错，而更准确的决策需要更长的时间。在 LATER 模型内部，这种权衡是通过调整决策阈值 $S$ 来实现的。更高的阈值 $S$ 意味着在做出决策之前必须积累更多的证据。这会导致更长的平均反应时间（$E[T] \\approx (S - S_0)/\\mu$），但通过减少基于噪声证据做出过早决策的机会来提高准确性。\n\n推导表明，将阈值从 $S$ 增加到 $2S$（向准确性倾斜）会使倒数概率单位图的斜率增加一个因子 $(2S - S_0)/(S - S_0)$。由于决策的发生要求 $S > S_0$，这个比率总是大于 1。例如，在决策过程从零开始（$S_0 = 0$）的常见情况下，该比率为 $(2S - 0)/(S - 0) = 2$，意味着斜率加倍。\n\n这一结果为 LATER 模型提供了一个直接的、定量的预测：当受试者为了更准确而进行策略性调整（即提高其内部阈值 $S$）时，这在实验数据中将表现为倒数概率单位图陡峭程度的特定、可预测的增加。该图的斜率是一个可观测量，可以从一组反应时间中估算出来。因此，所推导出的比率将一个理论上的认知参数 ($S$) 与行为数据的可测量特征联系起来，为检验该模型关于速度-准确率调整的神经实现方式的假设提供了一种强有力的方法。",
            "answer": "$$\\boxed{\\frac{2S - S_{0}}{S - S_{0}}}$$"
        },
        {
            "introduction": "理论推导和模型分析最终需要在数据面前接受检验。这个实践将理论与应用相结合，要求你设计一个统计程序来测试竞争模型的一个基本预测——米勒不等式（Miller's inequality）。 在这个综合性的计算练习中，你将不仅仅是应用一个公式，而是要亲自编写代码，通过自举法（bootstrap）来构建一个假设检验，用以判断实验数据是否支持一个纯粹的独立竞争过程，还是暗示了更复杂的神经机制（如协同激活）。这项练习旨在培养你作为计算神经科学研究者，利用数据对认知理论进行严格验证的核心能力。",
            "id": "4012824",
            "problem": "给定在冗余信号范式中三种条件下的反应时独立样本：单独刺激 $A$、单独刺激 $B$ 以及冗余刺激 $AB$。假设反应时为严格正数，并以秒为单位。阈值遍历率线性趋近 (LATER) 模型假定决策时间 $T$ 可表示为 $T = S / R$，其中 $S$ 是一个固定的决策阈限，$R$ 是一个随机速率变量；在实践中，将直接使用 $A$ 和 $B$ 的经验分布。\n\n定义这三种条件下反应时的累积分布函数 $F_A(t)$、$F_B(t)$ 和 $F_{AB}(t)$。经典竞争不等式 (Miller界) 指出，在没有协同激活的情况下，冗余条件 $AB$ 必须满足以下逐点界\n$$\nF_{AB}(t) \\le \\min\\big(F_A(t) + F_B(t), \\, 1\\big) \\quad \\text{for all } t \\in \\mathbb{R}_{\\ge 0}.\n$$\n您必须设计并实现一个统计程序，用于基于有限样本检验对此界的违反情况，该程序使用经验累积分布函数和在最不利零模型下校准的bootstrap方法。\n\n将假设表述如下：\n- 零假设 $H_0$：对于所有 $t \\in \\mathbb{R}_{\\ge 0}$，$F_{AB}(t) \\le \\min\\big(F_A(t) + F_B(t), \\, 1\\big)$。\n- 备择假设 $H_1$：存在 $t \\in \\mathbb{R}_{\\ge 0}$ 使得 $F_{AB}(t) > \\min\\big(F_A(t) + F_B(t), \\, 1\\big)$。\n\n您的检验必须使用以下要素：\n- 从样本中计算得出的经验累积分布函数 $\\hat F_A(t)$、$\\hat F_B(t)$ 和 $\\hat F_{AB}(t)$。\n- 一个检验统计量，定义为经验冗余累积分布超出经验Miller界的逐点量的上确界：\n$$\nT_n \\equiv \\sup_{t \\in \\mathcal{T}} \\left\\{ \\hat F_{AB}(t) - \\min\\big(\\hat F_A(t) + \\hat F_B(t), \\, 1\\big) \\right\\},\n$$\n其中 $\\mathcal{T}$ 是一个有限网格，由所有三个条件中观测到的所有样本时间组成。\n- 一个通过在根据经验边际分布构建的最不利零模型下模拟bootstrap数据集来近似 $T_n$ 的零分布的bootstrap程序。具体来说，对于每次bootstrap重复：\n  1. 从仅含 $A$ 的样本中有放回地重抽样 $n_A$ 次以形成bootstrap样本 $A^\\ast$，并从仅含 $B$ 的样本中有放回地重抽样 $n_B$ 次以形成bootstrap样本 $B^\\ast$。\n  2. 在 $A^\\ast \\cup B^\\ast$ 中观测到的唯一时间点网格上，计算bootstrap经验界 $G^\\ast(t) = \\min\\big(\\hat F_{A^\\ast}(t) + \\hat F_{B^\\ast}(t), \\, 1\\big)$。\n  3. 从累积分布函数为 $G^\\ast(t)$ 的离散分布中抽样 $n_{AB}$ 个冗余时间 $AB^\\ast$，这通过在该网格上进行逆变换实现。\n  4. 使用 $A^\\ast$、$B^\\ast$ 和 $AB^\\ast$ 计算bootstrap统计量 $T_n^\\ast$，其计算方式与 $T_n$ 完全相同。\n- bootstrap p值的估计如下\n$$\n\\hat p = \\frac{1 + \\sum_{b=1}^B \\mathbf{1}\\{T_{n,b}^\\ast \\ge T_n\\}}{1 + B},\n$$\n如果 $\\hat p \\le \\alpha$，则检验在水平 $\\alpha$ 上拒绝 $H_0$。使用 $\\alpha = 0.05$。\n\n实现此检验并将其应用于以下合成数据集的测试套件，每个数据集均由 $A$ 和 $B$ 的LATER模型以及 $AB$ 的两个LATER过程的竞争生成，并带有一个可选的乘性协同激活因子 $\\gamma$：\n- 对于每个条件 $X \\in \\{A, B\\}$，生成速率 $R_X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$ 并截断至 $R_X > 0$，设置 $S = 1$，并计算 $T_X = S / R_X$。对于冗余条件，以相同方式生成独立抽样 $T_A'$ 和 $T_B'$，并设置 $T_{AB} = \\gamma \\cdot \\min(T_A', T_B')$。所有时间都必须以秒为单位。\n- 该测试套件包含以下参数集，每个参数集都有一个固定的随机种子以确保可复现性：\n  1. 案例1 (竞争，大样本): $n_A = n_B = n_{AB} = 600$，$\\mu_A = 3.0$，$\\sigma_A = 0.4$，$\\mu_B = 3.0$，$\\sigma_B = 0.4$，$\\gamma = 1.0$。\n  2. 案例2 (协同激活，违反): $n_A = n_B = n_{AB} = 400$，$\\mu_A = 3.0$，$\\sigma_A = 0.4$，$\\mu_B = 3.0$，$\\sigma_B = 0.4$，$\\gamma = 0.8$。\n  3. 案例3 (竞争，小样本): $n_A = n_B = n_{AB} = 120$，$\\mu_A = 3.0$，$\\sigma_A = 0.5$，$\\mu_B = 3.0$，$\\sigma_B = 0.5$，$\\gamma = 1.0$。\n  4. 案例4 (非对称，近边界): $n_A = n_B = n_{AB} = 400$，$\\mu_A = 2.5$，$\\sigma_A = 0.5$，$\\mu_B = 4.0$，$\\sigma_B = 0.5$，$\\gamma = 0.95$。\n- 每个案例使用 $B = 1000$ 次bootstrap重复，并且所有案例使用同一个固定的种子，以便结果可以精确复现。\n\n您的程序必须：\n- 根据上述规范生成以秒为单位的合成数据集。\n- 计算每个案例的检验统计量和bootstrap p值。\n- 为每个案例决定是否在水平 $\\alpha = 0.05$ 上拒绝 $H_0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例1到4的顺序排列结果，每个条目都是一个布尔值，表示该案例是否拒绝H0。例如：'[True,False,False,True]'。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上植根于认知建模和计算统计学的原理，问题阐述清晰，并为一项非平凡的统计检验提供了一套完整且一致的要求。\n\n任务是实现一个针对反应时数据的竞争模型不等式（也称为Miller界）的bootstrap假设检验。该不等式是平行竞争模型的一个基本预测，该模型假设对于冗余刺激 $A$ 和 $B$，响应是由两个独立处理通道中首先完成的那个触发的。\n\n设 $F_A(t)$、$F_B(t)$ 和 $F_{AB}(t)$ 分别是单独刺激 $A$、单独刺激 $B$ 和冗余刺激 $AB$ 的反应时累积分布函数 (CDF)。竞争模型不等式指出，对于所有非负时间 $t \\ge 0$，\n$$F_{AB}(t) \\le \\min\\big(F_A(t) + F_B(t), 1\\big)$$\n对该不等式的违反，特别是 $F_{AB}(t) > F_A(t) + F_B(t)$，表明存在协同激活机制，即两个刺激的存在导致处理速度比独立过程之间的简单竞争所预测的要快。\n\n该假设检验表述为：\n- 零假设 $H_0$：对于所有 $t \\ge 0$，$F_{AB}(t) \\le \\min(F_A(t) + F_B(t), 1)$。观测数据与竞争模型一致。\n- 备择假设 $H_1$：存在一个 $t \\ge 0$ 使得 $F_{AB}(t) > \\min(F_A(t) + F_B(t), 1)$。数据与竞争模型不一致，表明存在协同激活。\n\n由于真实的CDF是未知的，我们使用它们的经验对应物，即经验累积分布函数 (ECDF)，记为 $\\hat{F}_A(t)$、$\\hat{F}_B(t)$ 和 $\\hat{F}_{AB}(t)$，它们是从大小为 $n_A$、$n_B$ 和 $n_{AB}$ 的有限样本中计算出来的。\n\n解决方案的核心包括以下步骤：\n\n1.  **检验统计量计算**：观测数据中对不等式的违反程度由检验统计量 $T_n$ 来量化。它被定义为冗余ECDF与经验Miller界之间的最大观测差异，该差异取自数据中所有唯一的时间点。设 $\\mathcal{T}$ 是三个实验条件中所有唯一反应时的集合。该统计量为：\n    $$T_n = \\sup_{t \\in \\mathcal{T}} \\left\\{ \\hat{F}_{AB}(t) - \\min\\big(\\hat{F}_A(t) + \\hat{F}_B(t), 1\\big) \\right\\}$$\n    $T_n$ 的正值越大，提供反对零假设 $H_0$ 的证据就越强。\n\n2.  **零分布的Bootstrap估计**：在 $H_0$ 下，$T_n$ 的抽样分布通常是难解的。因此，我们使用bootstrap程序来近似它。此程序的关键在于生成符合零假设的bootstrap样本。我们从一个位于不等式边界的“最不利”零模型进行模拟，即 $F_{AB}(t) = \\min(F_A(t) + F_B(t), 1)$。这种选择使得检验对任何违反情况都很敏感。对于 $B=1000$ 次bootstrap重复中的每一次，其过程如下：\n    a. 分别从条件 $A$ 和 $B$ 的原始单刺激样本中有放回地重抽样，生成bootstrap样本 $A^\\ast$ 和 $B^\\ast$。\n    b. 为bootstrap边际分布构建ECDF，即 $\\hat{F}_{A^\\ast}(t)$ 和 $\\hat{F}_{B^\\ast}(t)$。\n    c. 定义一个bootstrap零CDF，$G^\\ast(t) = \\min\\big(\\hat{F}_{A^\\ast}(t) + \\hat{F}_{B^\\ast}(t), 1\\big)$。这在 $A^\\ast \\cup B^\\ast$ 中观测到的时间点上定义了一个离散概率分布。该分布代表了在基于bootstrap边际分布的竞争模型下仍然一致的最快可能冗余反应时。\n    d. 使用逆变换采样方法，从由 $G^\\ast(t)$ 定义的离散分布中抽样，生成一个大小为 $n_{AB}$ 的bootstrap冗余样本 $AB^\\ast$。根据构造，样本三元组 $(A^\\ast, B^\\ast, AB^\\ast)$ 满足零假设。\n    e. 对这个bootstrap三元组计算bootstrap检验统计量 $T_n^\\ast$，计算方式与观测统计量 $T_n$ 相同。\n\n3.  **P值计算与决策**：生成 $B$ 个bootstrap统计量 $\\{T_{n,1}^\\ast, \\dots, T_{n,B}^\\ast\\}$ 后，我们就得到了 $T_n$ 的零分布的一个经验近似。单侧p值被估计为大于或等于原始观测统计量 $T_n$ 的bootstrap统计量的比例：\n    $$\\hat{p} = \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\{T_{n,b}^\\ast \\ge T_n\\}}{1 + B}$$\n    在分子和分母上加1是防止p值为0的标准惯例，并能确保保守的行为。如果 $\\hat{p} \\le \\alpha$，则在显著性水平 $\\alpha=0.05$ 上拒绝零假设 $H_0$。\n\n4.  **数据生成**：测试案例的合成数据集是使用LATER模型生成的。对于每个单刺激条件 $X \\in \\{A, B\\}$，反应时 $T_X$ 计算为 $T_X=S/R_X$，其中决策阈限 $S$ 固定为1，速率 $R_X$ 从满足约束 $R_X > 0$ 的截断正态分布 $\\mathcal{N}(\\mu_X, \\sigma_X^2)$ 中抽取。对于冗余条件，生成两个独立的反应时 $T_A'$ 和 $T_B'$，并将冗余反应时取为 $T_{AB} = \\gamma \\cdot \\min(T_A', T_B')$。协同激活因子 $\\gamma  1$ 会导致比纯竞争模型 ($\\gamma = 1$) 更快的响应，这预计将导致对Miller界的违反。\n\n该实现将把此统计程序应用于四个不同的测试案例，为每个案例确定是否拒绝竞争模型的零假设。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import truncnorm\n\n# Define global parameters as specified in the problem\nB = 1000\nALPHA = 0.05\n# A single fixed seed for reproducibility across all cases\nRANDOM_SEED = 42\n\ndef generate_LATER_RTs(rng, n, mu, sigma, S=1.0):\n    \"\"\"\n    Generates reaction times from the LATER model S/R, where R is from a\n    truncated normal distribution.\n    \"\"\"\n    # The lower bound is 0. In standard-normal units for truncnorm, this is (0 - mu) / sigma.\n    a = -mu / sigma\n    b = np.inf\n    rates = truncnorm.rvs(a, b, loc=mu, scale=sigma, size=n, random_state=rng)\n    # Ensure rates are strictly positive to avoid division by zero\n    rates[rates == 0] = 1e-9  # A small positive floor\n    return S / rates\n\ndef generate_dataset(rng, n_a, n_b, n_ab, mu_a, sigma_a, mu_b, sigma_b, gamma):\n    \"\"\"\n    Generates a full dataset for conditions A, B, and AB based on LATER model parameters.\n    \"\"\"\n    sample_a = generate_LATER_RTs(rng, n_a, mu_a, sigma_a)\n    sample_b = generate_LATER_RTs(rng, n_b, mu_b, sigma_b)\n\n    # For the redundant condition, generate two sets of latent RTs for the race\n    t_a_prime = generate_LATER_RTs(rng, n_ab, mu_a, sigma_a)\n    t_b_prime = generate_LATER_RTs(rng, n_ab, mu_b, sigma_b)\n    \n    # The redundant RT is the coactivated minimum of the two latent RTs\n    sample_ab = gamma * np.minimum(t_a_prime, t_b_prime)\n\n    return sample_a, sample_b, sample_ab\n\ndef ecdf(sample, t_grid):\n    \"\"\"\n    Computes the Empirical Cumulative Distribution Function values for a sample\n    at specified time points.\n    \"\"\"\n    if len(sample) == 0:\n        return np.zeros_like(t_grid, dtype=float)\n    # Using np.searchsorted is efficient for this task\n    sample_sorted = np.sort(sample)\n    return np.searchsorted(sample_sorted, t_grid, side='right') / len(sample)\n\ndef compute_test_statistic(sample_a, sample_b, sample_ab):\n    \"\"\"\n    Computes the test statistic T_n, the supremum of the violation of the Miller bound.\n    The supremum is taken over the grid of all observed time points.\n    \"\"\"\n    # Create the grid of all unique observed time points\n    t_grid = np.unique(np.concatenate((sample_a, sample_b, sample_ab)))\n\n    # Compute ECDFs for all three conditions on the common grid\n    ecdf_a = ecdf(sample_a, t_grid)\n    ecdf_b = ecdf(sample_b, t_grid)\n    ecdf_ab = ecdf(sample_ab, t_grid)\n\n    # Calculate the Miller bound\n    miller_bound = np.minimum(ecdf_a + ecdf_b, 1.0)\n    \n    # The test statistic is the maximum positive deviation from the bound\n    test_statistic = np.max(ecdf_ab - miller_bound)\n    \n    return test_statistic\n\ndef perform_bootstrap_test(rng, sample_a, sample_b, sample_ab):\n    \"\"\"\n    Performs the full bootstrap hypothesis test.\n    \"\"\"\n    n_a, n_b, n_ab = len(sample_a), len(sample_b), len(sample_ab)\n\n    # 1. Compute the observed test statistic\n    T_n_obs = compute_test_statistic(sample_a, sample_b, sample_ab)\n\n    bootstrap_stats = []\n    for _ in range(B):\n        # 2a. Resample A and B\n        A_star = rng.choice(sample_a, size=n_a, replace=True)\n        B_star = rng.choice(sample_b, size=n_b, replace=True)\n        \n        # 2b. Construct the least-favorable null CDF, G*(t)\n        t_grid_star_gen = np.unique(np.concatenate((A_star, B_star)))\n        ecdf_a_star_gen = ecdf(A_star, t_grid_star_gen)\n        ecdf_b_star_gen = ecdf(B_star, t_grid_star_gen)\n        g_star_cdf = np.minimum(ecdf_a_star_gen + ecdf_b_star_gen, 1.0)\n\n        # 2c. Sample AB* from G*(t) via inverse transform sampling\n        # First, get the PMF from the CDF\n        g_star_pmf = np.diff(g_star_cdf, prepend=0)\n        # Normalize to correct for potential floating-point inaccuracies\n        g_star_pmf /= np.sum(g_star_pmf)\n        \n        AB_star = rng.choice(t_grid_star_gen, size=n_ab, replace=True, p=g_star_pmf)\n        \n        # 2d. Compute the bootstrap statistic T_n*\n        T_n_star = compute_test_statistic(A_star, B_star, AB_star)\n        bootstrap_stats.append(T_n_star)\n\n    # 3. Calculate the p-value\n    bootstrap_stats = np.array(bootstrap_stats)\n    num_exceed = np.sum(bootstrap_stats >= T_n_obs)\n    p_value = (1 + num_exceed) / (1 + B)\n\n    # 4. Make a decision based on the significance level\n    return p_value = ALPHA\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print the results.\n    \"\"\"\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    test_cases = [\n        # Case 1 (race, large sample)\n        {'n_a': 600, 'n_b': 600, 'n_ab': 600, 'mu_a': 3.0, 'sigma_a': 0.4, 'mu_b': 3.0, 'sigma_b': 0.4, 'gamma': 1.0},\n        # Case 2 (coactivation, violation)\n        {'n_a': 400, 'n_b': 400, 'n_ab': 400, 'mu_a': 3.0, 'sigma_a': 0.4, 'mu_b': 3.0, 'sigma_b': 0.4, 'gamma': 0.8},\n        # Case 3 (race, small sample)\n        {'n_a': 120, 'n_b': 120, 'n_ab': 120, 'mu_a': 3.0, 'sigma_a': 0.5, 'mu_b': 3.0, 'sigma_b': 0.5, 'gamma': 1.0},\n        # Case 4 (asymmetric, near-boundary)\n        {'n_a': 400, 'n_b': 400, 'n_ab': 400, 'mu_a': 2.5, 'sigma_a': 0.5, 'mu_b': 4.0, 'sigma_b': 0.5, 'gamma': 0.95},\n    ]\n\n    results = []\n    for params in test_cases:\n        sample_a, sample_b, sample_ab = generate_dataset(rng, **params)\n        reject_h0 = perform_bootstrap_test(rng, sample_a, sample_b, sample_ab)\n        results.append(reject_h0)\n\n    # Print the final result in the exact specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}