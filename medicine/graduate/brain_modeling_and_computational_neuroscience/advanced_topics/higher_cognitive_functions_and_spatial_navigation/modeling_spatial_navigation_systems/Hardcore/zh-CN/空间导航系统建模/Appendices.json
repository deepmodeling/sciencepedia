{
    "hands_on_practices": [
        {
            "introduction": "路径积分是动物和机器人在没有外部参照物时追踪自身位置的一种基本策略。然而，这个过程天生就容易出错，因为来自本体感受和前庭系统的运动信号总是带有噪声。这个实践练习将引导你分析在一个简化的二维导航模型中，速度和朝向的微小测量噪声是如何随着时间累积，并最终导致巨大的定位误差。通过推导误差增长的时间标度律 ，你将深刻理解纯路径积分的内在局限性，并认识到为何大脑需要更复杂的策略来维持长期空间定位的准确性。",
            "id": "3998099",
            "problem": "考虑一个在平面上导航的智能体的二维路径积分模型。该智能体的真实运动是沿 $x$ 轴以恒定的前进速度 $v_{0}$ 运动，其真实航向角 $\\theta_{\\mathrm{true}}(t) = 0$ 对所有 $t \\in [0, T]$ 成立。该智能体通过对带有噪声的前进速度和偏航率的测量值进行积分来估计其位置。设测得的前进速度为 $v_{m}(t) = v_{0} + n_{v}(t)$，其中 $n_{v}(t)$ 是零均值、平稳的高斯白噪声，其自相关函数为 $\\mathbb{E}[n_{v}(t)n_{v}(s)] = S_{v}\\,\\delta(t-s)$，其中 $S_{v} > 0$ 表示噪声强度（等效于双边功率谱密度 (PSD) 水平），$\\delta(\\cdot)$ 表示狄拉克δ分布。设测得的偏航率为 $\\omega_{m}(t) = n_{\\omega}(t)$，其中 $n_{\\omega}(t)$ 是零均值、平稳的高斯白噪声，其自相关函数为 $\\mathbb{E}[n_{\\omega}(t)n_{\\omega}(s)] = S_{\\omega}\\,\\delta(t-s)$，且 $S_{\\omega} > 0$ 是其噪声强度。假设 $n_{v}$ 和 $n_{\\omega}$ 是独立的。\n\n智能体通过对偏航率进行积分来形成其航向估计：$\\theta_{m}(t) = \\int_{0}^{t} \\omega_{m}(\\tau)\\,d\\tau$，初始条件为 $\\theta_{m}(0) = 0$。位置估计由下式给出\n$$\n\\mathbf{r}_{\\mathrm{est}}(T) = \\int_{0}^{T} v_{m}(t)\\,\\begin{pmatrix}\\cos\\theta_{m}(t) \\\\ \\sin\\theta_{m}(t) \\end{pmatrix}dt,\n$$\n真实位置为 $\\mathbf{r}_{\\mathrm{true}}(T) = \\begin{pmatrix}v_{0}T \\\\ 0\\end{pmatrix}$。定义位置误差向量 $\\Delta\\mathbf{r}(T) = \\mathbf{r}_{\\mathrm{est}}(T) - \\mathbf{r}_{\\mathrm{true}}(T)$ 和径向均方位置误差\n$$\n\\mathcal{E}(T) = \\mathbb{E}\\left[\\|\\Delta\\mathbf{r}(T)\\|^{2}\\right] = \\mathbb{E}\\left[\\Delta x(T)^{2} + \\Delta y(T)^{2}\\right].\n$$\n\n在小角度近似下，仅保留 $\\theta_{m}(t)$ 的一阶项（即，使用 $\\cos\\theta_{m}(t) \\approx 1$ 和 $\\sin\\theta_{m}(t) \\approx \\theta_{m}(t)$，并忽略 $\\theta_{m}(t)$ 与 $n_{v}(t)$ 的所有乘积以及 $k \\geq 2$ 的任何 $\\theta_{m}(t)^{k}$ 次幂）。从这些假设和上述定义出发，推导 $\\mathbb{E}\\left[\\Delta x(T)^{2}\\right]$ 和 $\\mathbb{E}\\left[\\Delta y(T)^{2}\\right]$ 的时间依赖性的主阶项，从而得到 $\\mathcal{E}(T)$ 的一个闭式表达式，该表达式能识别出由速度噪声和航向噪声引起的关于 $T$ 的主导标度项。\n\n将最终的均方位置误差 $\\mathcal{E}(T)$ 以平方米为单位表示。最终答案必须是关于 $T$、$v_{0}$、$S_{v}$ 和 $S_{\\omega}$ 的单个闭式解析表达式。",
            "solution": "问题陈述经评估有效。这是一个在计算神经科学和随机过程理论领域中提得很好的问题，其基础是路径积分的既定建模原则。给定的条件是自洽、一致和客观的，允许进行严格的数学推导。\n\n目标是计算径向均方位置误差 $\\mathcal{E}(T) = \\mathbb{E}\\left[\\|\\Delta\\mathbf{r}(T)\\|^{2}\\right]$，其中 $\\Delta\\mathbf{r}(T) = \\mathbf{r}_{\\mathrm{est}}(T) - \\mathbf{r}_{\\mathrm{true}}(T)$。误差向量的分量是 $\\Delta x(T)$ 和 $\\Delta y(T)$。总均方误差是各分量均方误差之和：$\\mathcal{E}(T) = \\mathbb{E}[\\Delta x(T)^2] + \\mathbb{E}[\\Delta y(T)^2]$，因为交叉项 $\\mathbb{E}[\\Delta x(T) \\Delta y(T)]$ 将被证明为零。\n\n首先，我们使用提供的定义和近似来表示估计的位置向量 $\\mathbf{r}_{\\mathrm{est}}(T)$。\n估计的速度向量是 $v_{m}(t)\\,\\begin{pmatrix}\\cos\\theta_{m}(t) \\\\ \\sin\\theta_{m}(t) \\end{pmatrix}$。\n使用小角度近似 $\\cos\\theta_{m}(t) \\approx 1$ 和 $\\sin\\theta_{m}(t) \\approx \\theta_{m}(t)$，这变为：\n$$\n(v_0 + n_v(t)) \\begin{pmatrix} 1 \\\\ \\theta_m(t) \\end{pmatrix} = \\begin{pmatrix} v_0 + n_v(t) \\\\ v_0 \\theta_m(t) + n_v(t)\\theta_m(t) \\end{pmatrix}\n$$\n问题指明我们忽略 $\\theta_m(t)$ 与 $n_v(t)$ 的乘积。因此，近似的速度向量是 $\\begin{pmatrix} v_0 + n_v(t) \\\\ v_0 \\theta_m(t) \\end{pmatrix}$。\n\n估计的位置是该速度向量的积分：\n$$\n\\mathbf{r}_{\\mathrm{est}}(T) = \\int_{0}^{T} \\begin{pmatrix} v_0 + n_v(t) \\\\ v_0 \\theta_m(t) \\end{pmatrix} dt = \\begin{pmatrix} v_0 T + \\int_0^T n_v(t) dt \\\\ v_0 \\int_0^T \\theta_m(t) dt \\end{pmatrix}\n$$\n真实位置由 $\\mathbf{r}_{\\mathrm{true}}(T) = \\begin{pmatrix}v_{0}T \\\\ 0\\end{pmatrix}$ 给出。\n因此，位置误差向量 $\\Delta \\mathbf{r}(T) = \\begin{pmatrix}\\Delta x(T) \\\\ \\Delta y(T) \\end{pmatrix}$ 为：\n$$\n\\Delta x(T) = \\left(v_0 T + \\int_0^T n_v(t) dt\\right) - v_0 T = \\int_0^T n_v(t) dt\n$$\n$$\n\\Delta y(T) = \\left(v_0 \\int_0^T \\theta_m(t) dt\\right) - 0 = v_0 \\int_0^T \\theta_m(t) dt\n$$\n现在，我们计算每个分量的均方误差。\n\n对于 $x$ 分量误差，$\\Delta x(T)$ 仅取决于速度噪声 $n_v(t)$。\n$$\n\\mathbb{E}\\left[\\Delta x(T)^2\\right] = \\mathbb{E}\\left[\\left(\\int_0^T n_v(t) dt\\right) \\left(\\int_0^T n_v(s) ds\\right)\\right] = \\mathbb{E}\\left[\\int_0^T \\int_0^T n_v(t) n_v(s) dt ds\\right]\n$$\n根据期望的线性性质，我们可以将期望算子移到积分内部：\n$$\n\\mathbb{E}\\left[\\Delta x(T)^2\\right] = \\int_0^T \\int_0^T \\mathbb{E}\\left[n_v(t) n_v(s)\\right] dt ds\n$$\n使用给定的白噪声 $n_v$ 的自相关函数 $\\mathbb{E}[n_v(t)n_v(s)] = S_v \\delta(t-s)$:\n$$\n\\mathbb{E}\\left[\\Delta x(T)^2\\right] = \\int_0^T \\int_0^T S_v \\delta(t-s) dt ds = S_v \\int_0^T \\left(\\int_0^T \\delta(t-s) dt\\right) ds\n$$\n对于任何 $s \\in [0, T]$，关于 $t$ 的内层积分等于 $1$。\n$$\n\\mathbb{E}\\left[\\Delta x(T)^2\\right] = S_v \\int_0^T 1 \\, ds = S_v T\n$$\n该项表示由于前进速度测量中的噪声所导致的误差累积，该过程遵循随机游走（维纳过程），其方差随时间线性增长。\n\n对于 $y$ 分量误差，$\\Delta y(T)$ 取决于估计的航向 $\\theta_m(t)$，而后者又取决于偏航率噪声 $n_\\omega(t)$。\n$$\n\\mathbb{E}\\left[\\Delta y(T)^2\\right] = \\mathbb{E}\\left[\\left(v_0 \\int_0^T \\theta_m(t) dt\\right)^2\\right] = v_0^2 \\mathbb{E}\\left[\\int_0^T \\int_0^T \\theta_m(t) \\theta_m(s) dt ds\\right]\n$$\n$$\n\\mathbb{E}\\left[\\Delta y(T)^2\\right] = v_0^2 \\int_0^T \\int_0^T \\mathbb{E}\\left[\\theta_m(t) \\theta_m(s)\\right] dt ds\n$$\n我们必须首先找到估计航向角的协方差函数 $\\mathbb{E}[\\theta_m(t)\\theta_m(s)]$。航向 $\\theta_m(t)$ 是偏航率噪声 $n_\\omega(t)$ 的时间积分：\n$$\n\\theta_m(t) = \\int_0^t n_\\omega(\\tau) d\\tau\n$$\n协方差为：\n$$\n\\mathbb{E}[\\theta_m(t)\\theta_m(s)] = \\mathbb{E}\\left[\\left(\\int_0^t n_\\omega(\\tau_1) d\\tau_1\\right) \\left(\\int_0^s n_\\omega(\\tau_2) d\\tau_2\\right)\\right] = \\int_0^t \\int_0^s \\mathbb{E}[n_\\omega(\\tau_1) n_\\omega(\\tau_2)] d\\tau_1 d\\tau_2\n$$\n使用自相关函数 $\\mathbb{E}[n_\\omega(\\tau_1)n_\\omega(\\tau_2)] = S_\\omega \\delta(\\tau_1-\\tau_2)$:\n$$\n\\mathbb{E}[\\theta_m(t)\\theta_m(s)] = \\int_0^s \\left(\\int_0^t S_\\omega \\delta(\\tau_1-\\tau_2) d\\tau_1\\right) d\\tau_2\n$$\n不失一般性地假设 $s \\le t$，内层积分对于 $\\tau_2 \\in [0,s]$ 的值为 $S_\\omega$，否则为 $0$。\n$$\n\\mathbb{E}[\\theta_m(t)\\theta_m(s)] = \\int_0^s S_\\omega d\\tau_2 = S_\\omega s\n$$\n通常，$\\mathbb{E}[\\theta_m(t)\\theta_m(s)] = S_\\omega \\min(t,s)$。这表明 $\\theta_m(t)$ 是一个维纳过程。将此代回 $\\mathbb{E}[\\Delta y(T)^2]$ 的表达式中：\n$$\n\\mathbb{E}\\left[\\Delta y(T)^2\\right] = v_0^2 S_\\omega \\int_0^T \\int_0^T \\min(t,s) dt ds\n$$\n该二重积分可以通过划分积分域来计算：\n$$\n\\int_0^T \\int_0^T \\min(t,s) dt ds = \\int_0^T \\left( \\int_0^t \\min(t,s) ds + \\int_t^T \\min(t,s) ds \\right) dt\n$$\n在第一个内层积分中，$s \\le t$，所以 $\\min(t,s) = s$。在第二个中，$s \\ge t$，所以 $\\min(t,s) = t$。\n$$\n\\int_0^T \\left( \\int_0^t s\\,ds + \\int_t^T t\\,ds \\right) dt = \\int_0^T \\left( \\left[\\frac{s^2}{2}\\right]_0^t + \\left[ts\\right]_t^T \\right) dt\n$$\n$$\n= \\int_0^T \\left( \\frac{t^2}{2} + t(T-t) \\right) dt = \\int_0^T \\left( \\frac{t^2}{2} + tT - t^2 \\right) dt = \\int_0^T \\left( tT - \\frac{t^2}{2} \\right) dt\n$$\n$$\n= \\left[ \\frac{t^2T}{2} - \\frac{t^3}{6} \\right]_0^T = \\frac{T^3}{2} - \\frac{T^3}{6} = \\frac{3T^3 - T^3}{6} = \\frac{2T^3}{6} = \\frac{T^3}{3}\n$$\n因此，$y$ 分量的均方误差为：\n$$\n\\mathbb{E}\\left[\\Delta y(T)^2\\right] = \\frac{1}{3} v_0^2 S_\\omega T^3\n$$\n该项表示由航向误差积分产生的误差，航向误差本身像随机游走一样增长。由此产生的位置误差方差随时间的三次方增长。\n\n由于 $n_v$ 和 $n_\\omega$ 是独立的，$\\Delta x(T)$（$n_v$ 的一个泛函）和 $\\Delta y(T)$（$n_\\omega$ 的一个泛函）也是独立的。由于噪声是零均值的，两者均值为零。因此，协方差项 $\\mathbb{E}[\\Delta x(T) \\Delta y(T)] = \\mathbb{E}[\\Delta x(T)]\\mathbb{E}[\\Delta y(T)] = 0 \\cdot 0 = 0$。\n\n总径向均方位置误差 $\\mathcal{E}(T)$ 是方差之和：\n$$\n\\mathcal{E}(T) = \\mathbb{E}\\left[\\Delta x(T)^2\\right] + \\mathbb{E}\\left[\\Delta y(T)^2\\right] = S_v T + \\frac{1}{3} v_0^2 S_\\omega T^3\n$$\n该表达式揭示了来自两个噪声源的不同的时间标度贡献。速度噪声导致的误差方差随时间线性增长，而偏航率（航向）噪声导致的误差方差则呈快得多的三次方增长。对于长的导航时间 $T$，误差将主要由航向积分噪声主导。",
            "answer": "$$\n\\boxed{S_v T + \\frac{1}{3} v_0^2 S_\\omega T^3}\n$$"
        },
        {
            "introduction": "上一个练习揭示了朝向误差对定位精度的巨大影响。本次实践将深入到神经层面，探讨大脑如何通过神经元群体来表征朝向。我们将构建一个头部方向细胞群体的计算模型，并使用群体向量解码器来读取其编码的方向信息 。这个练习的核心任务是分析解码器的性能，特别是理解神经元群体中不均匀的调谐偏好或增益异质性等生物学特性，是如何导致系统性的解码偏差并影响神经编码的整体精度的。",
            "id": "3998140",
            "problem": "您的任务是构建和分析一个用于头部方向细胞神经元群体的头部方向的线性群体向量解码器。假设一个由 $N$ 个神经元组成的群体，其优先方向 $\\phi \\in [-\\pi,\\pi)$ 从单位圆上的概率密度 $p(\\phi)$ 中抽取。每个神经元在一个持续时间为 $T$ 秒的观察窗口内，作为一个独立的非齐次泊松过程发放神经冲动。在固定的头部方向刺激 $\\theta_0 \\in [-\\pi,\\pi)$ 条件下，一个优先方向为 $\\phi$ 的神经元的期望发放率（单位：脉冲/秒）由一个带有基线和乘性异质性的 von Mises 调谐曲线给出：\n- 平均发放率为 $\\lambda(\\phi \\mid \\theta_0) = b + m(\\phi)\\, \\exp\\!\\big(\\kappa \\cos(\\theta_0 - \\phi)\\big)$，其中 $b \\ge 0$ 是基线发放率，$m(\\phi) \\ge 0$ 是峰值调制，$\\kappa \\ge 0$ 是调谐集中度。\n- 调制为 $m(\\phi) = m \\big[1 + \\varepsilon \\cos(\\phi - \\mu_g)\\big]$，其中 $m \\ge 0$ 是全局调制，$\\varepsilon \\in [0,1)$ 控制异质性强度，$\\mu_g \\in [-\\pi,\\pi)$ 是异质性轴。\n\n线性群体向量解码器形成复数和\n$$\nS \\;=\\; \\sum_{i=1}^{N} r_i \\, e^{\\mathrm{i}\\,\\phi_i},\n$$\n其中 $r_i$ 是神经元 $i$ 在 $T$ 秒内的脉冲计数，$\\phi_i$ 是其优先方向。解码后的头部方向估计值为\n$$\n\\hat{\\theta} \\;=\\; \\mathrm{arg}\\, S \\;\\in\\; [-\\pi,\\pi),\n$$\n其中 $\\mathrm{arg}$ 返回复数的主辐角，并且环绕约定将角度映射到 $[-\\pi,\\pi)$。\n\n需要使用的基本原理（不超出此范围）：\n- 独立的泊松脉冲发放，其脉冲计数的均值等于方差，$r_i \\sim \\mathrm{Poisson}\\big(\\Lambda(\\phi_i \\mid \\theta_0)\\big)$，其中 $\\Lambda(\\phi \\mid \\theta_0) = T\\, \\lambda(\\phi \\mid \\theta_0)$。\n- 大数定律，用于大型群体求和，以 $p(\\phi)$ 下的期望代替经验平均值。\n- 一阶微扰（delta 方法），用于随机向量在其均值附近的扰动角度，使用小角度近似来处理 $\\hat{\\theta}$ 围绕平均合向量方向的波动。\n\n您的任务：\n1. 基于这些基本原理，推导出表征解码器偏差和方差所需的大 $N$ 表达式：\n   - 定义平均复数群体向量\n     $$\n     \\mu \\;=\\; \\mathbb{E}[S] \\;=\\; N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0)\\, e^{\\mathrm{i}\\,\\phi}\\, p(\\phi)\\, d\\phi.\n     $$\n     定义渐近平均解码角度 $\\theta_\\star = \\mathrm{arg}\\,\\mu$，以及带符号的偏差 $b_{\\mathrm{asym}} = \\mathrm{wrap}(\\theta_\\star - \\theta_0)$（单位为弧度），并环绕到 $[-\\pi,\\pi)$ 区间。\n   - 使用围绕 $\\theta_\\star$ 的一阶小角度近似，推导出解码器的渐近方差可以表示为\n     $$\n     \\mathrm{Var}(\\hat{\\theta}) \\;\\approx\\; \\frac{N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0)\\, \\sin^2(\\phi - \\theta_\\star)\\, p(\\phi)\\, d\\phi}{\\lvert \\mu \\rvert^2}.\n     $$\n     分子来源于独立的泊松变异性投影到与 $\\mu$ 正交的方向上，分母是平均向量的模的平方。\n   - 您不得对这些积分使用任何闭合形式的特殊函数快捷方式；相反，应将它们表述为待数值计算的积分。\n\n2. 实现一个程序，对于下面测试套件中的每一组参数，通过在 $\\phi \\in [-\\pi,\\pi)$ 上使用足够精细的数值积分来計算上述积分，从而数值计算渐近带符号偏差 $b_{\\mathrm{asym}}$ 和渐近方差 $\\mathrm{Var}(\\hat{\\theta})$。使用双精度算术和在 $[-\\pi,\\pi)$ 上至少有 $4096$ 个点的均匀网格。\n\n3. 角度单位：所有角度，包括 $\\theta_0$、$\\mu_d$ 和 $\\mu_g$，都必须以弧度为单位进行解释和返回。输出偏差以弧度表示。方差是无单位的，因为它涉及弧度的平方。\n\n4. 优先方向的群体密度：\n   - 均匀分布：$p(\\phi) = \\frac{1}{2\\pi}$。\n   - 非均匀 von Mises 分布：$p(\\phi) = \\dfrac{\\exp\\!\\big(\\kappa_d \\cos(\\phi - \\mu_d)\\big)}{2\\pi I_0(\\kappa_d)}$，其中 $I_0$ 是第一类零阶修正贝塞尔函数。您必须在网格上对 $p(\\phi)$ 进行数值归一化；不要使用 $I_0$ 的闭合形式。\n\n5. 测试套件。对于以下每种情况，计算并返回序对 $[b_{\\mathrm{asym}}, \\mathrm{Var}(\\hat{\\theta})]$：\n   - 情况 A（理想情况，均匀优先方向）：\n     - $N = 60$，$\\theta_0 = 0.7$，$\\kappa = 2.0$，$b = 5.0$，$m = 15.0$，$\\varepsilon = 0.0$，$\\mu_g = 0.0$，$T = 0.25$，$p(\\phi)$ 均匀分布。\n   - 情况 B（非均匀优先方向，聚集在 $0$ 附近）：\n     - $N = 100$，$\\theta_0 = 1.2$，$\\kappa = 2.0$，$b = 5.0$，$m = 10.0$，$\\varepsilon = 0.0$，$\\mu_g = 0.0$，$T = 0.5$，$p(\\phi)$ 为 von Mises 分布，其中 $\\kappa_d = 1.5$，$\\mu_d = 0.0$。\n   - 情况 C（均匀优先方向但增益异质）：\n     - $N = 80$，$\\theta_0 = -1.4$，$\\kappa = 1.2$，$b = 8.0$，$m = 12.0$，$\\varepsilon = 0.3$，$\\mu_g = 0.5$，$T = 0.4$，$p(\\phi)$ 均匀分布。\n   - 情况 D（靠近环绕点的边界情况，聚集在 $\\pi$ 附近）：\n     - $N = 120$，$\\theta_0 = 3.05$，$\\kappa = 3.0$，$b = 3.0$，$m = 9.0$，$\\varepsilon = 0.2$，$\\mu_g = 3.0$，$T = 0.3$，$p(\\phi)$ 为 von Mises 分布，其中 $\\kappa_d = 2.0$，$\\mu_d = 3.0$。\n\n6. 最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，内含上述四种情况的 8 个浮点数结果，按以下顺序展平并四舍五入到六位小数：\n$$\n\\big[ b_A,\\; v_A,\\; b_B,\\; v_B,\\; b_C,\\; v_C,\\; b_D,\\; v_D \\big],\n$$\n其中 $b_\\cdot$ 表示指定情况的带符号偏差 $b_{\\mathrm{asym}}$，$v_\\cdot$ 表示指定情况的方差 $\\mathrm{Var}(\\hat{\\theta})$，偏差单位为弧度，方差单位为弧度的平方。打印的行必须与方括号格式完全匹配，值之间用逗号分隔，且无任何附加文本。",
            "solution": "该问题具有科学依据，提法明確，客观，并包含足够的信息以获得唯一解。它描述了计算神经科学中用于分析群体编码性能的典型模型。任务涉及从第一性原理进行的标准但详细的推导，然后是数值实现。因此，该问题被认为是有效的。我们着手进行求解。\n\n### 理论推导\n\n**1. 模型说明**\n我们考虑一个由 $N$ 个头部方向神经元组成的群体。第 $i$ 个神经元的优先方向是 $\\phi_i \\in [-\\pi, \\pi)$，从概率密度 $p(\\phi)$ 中抽取。对于真实的头部方向 $\\theta_0$，神经元 $i$ 以一个独立泊松过程发放脉冲，其发放率（单位：脉冲/秒）由以下调谐曲线给出：\n$$\n\\lambda(\\phi_i \\mid \\theta_0) = b + m(\\phi_i)\\, \\exp\\!\\big(\\kappa \\cos(\\theta_0 - \\phi_i)\\big)\n$$\n峰值调制 $m(\\phi_i)$ 可能是异质的：\n$$\nm(\\phi_i) = m \\big[1 + \\varepsilon \\cos(\\phi_i - \\mu_g)\\big]\n$$\n在持续时间为 $T$ 的观察间隔内，神经元 $i$ 的脉冲计数 $r_i$ 服从泊松分布，$r_i \\sim \\mathrm{Poisson}(\\Lambda(\\phi_i \\mid \\theta_0))$，其中平均脉冲计数为 $\\Lambda(\\phi \\mid \\theta_0) = T\\,\\lambda(\\phi \\mid \\theta_0)$。\n\n群体向量解码器根据复数向量 $S$ 的角度来估计头部方向 $\\hat{\\theta}$：\n$$\nS = \\sum_{i=1}^{N} r_i \\, e^{\\mathrm{i}\\,\\phi_i}, \\quad \\hat{\\theta} = \\mathrm{arg}\\,S\n$$\n\n**2. 渐近偏差**\n估计器的偏差是其期望值与真实值 $\\theta_0$ 之间的差。对于像 $\\hat{\\theta} = \\mathrm{arg}\\,S$ 这样的非线性估计器，标准做法是用期望向量的角度 $\\mathrm{arg}\\,\\mathbb{E}[S]$ 来近似估计的期望值 $\\mathbb{E}[\\hat{\\theta}]$。这是在 $S$ 围绕其均值的波动变得很小的大 $N$ 极限下的情况。\n\n我们定义平均复数群体向量 $\\mu = \\mathbb{E}[S]$。利用期望的线性和神经元的独立性：\n$$\n\\mu = \\mathbb{E}\\left[\\sum_{i=1}^{N} r_i \\, e^{\\mathrm{i}\\,\\phi_i}\\right] = \\sum_{i=1}^{N} \\mathbb{E}[r_i] \\, e^{\\mathrm{i}\\,\\phi_i}\n$$\n神经元 $i$ 的期望脉冲计数是 $\\mathbb{E}[r_i] = \\Lambda(\\phi_i \\mid \\theta_0)$。\n$$\n\\mu = \\sum_{i=1}^{N} \\Lambda(\\phi_i \\mid \\theta_0) \\, e^{\\mathrm{i}\\,\\phi_i}\n$$\n在大群体 $N$ 的极限下，大数定律允许我们用优先方向分布 $p(\\phi)$ 上的期望来代替神经元经验样本上的和。这将和转换为积分：\n$$\n\\mu = N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0)\\, e^{\\mathrm{i}\\,\\phi}\\, p(\\phi)\\, d\\phi\n$$\n这是一个需要进行数值计算的积分。\n渐近解码角度被定义为这个平均向量的角度：\n$$\n\\theta_\\star = \\mathrm{arg}\\,\\mu\n$$\n渐近带符号偏差 $b_{\\mathrm{asym}}$ 是这个渐近角度与真实刺激角度之间的环绕差值，确保结果在 $[-\\pi, \\pi)$ 内：\n$$\nb_{\\mathrm{asym}} = \\mathrm{wrap}(\\theta_\\star - \\theta_0) \\equiv (\\theta_\\star - \\theta_0 + \\pi) \\pmod{2\\pi} - \\pi\n$$\n\n**3. 渐近方差**\n估计器的方差 $\\mathrm{Var}(\\hat{\\theta})$，使用一阶微扰近似（也称为 delta 方法）进行分析。我们考虑群体向量在其均值附近的小波动 $\\delta S = S - \\mu$。解码角度为 $\\hat{\\theta} = \\arg(\\mu + \\delta S)$。\n\n对于小的 $\\delta S$，角度的变化 $\\delta\\hat{\\theta} = \\hat{\\theta} - \\theta_\\star$ 主要由 $\\delta S$ 垂直于平均向量 $\\mu$ 的分量引起。记 $\\mu = |\\mu| e^{\\mathrm{i}\\theta_\\star}$，我们可以将角度波动近似为波动向量 $\\delta S$ 在垂直于 $\\mu$ 的方向上的投影，再除以 $\\mu$ 的模。设 $\\delta S = \\delta S_x + \\mathrm{i}\\delta S_y$。$\\mu$ 的方向向量是 $(\\cos\\theta_\\star, \\sin\\theta_\\star)$，正交方向是 $(-\\sin\\theta_\\star, \\cos\\theta_\\star)$。角度的波动是：\n$$\n\\delta\\hat{\\theta} \\approx \\frac{\\delta S_y \\cos\\theta_\\star - \\delta S_x \\sin\\theta_\\star}{|\\mu|}\n$$\n方差是 $\\mathrm{Var}(\\hat{\\theta}) = \\mathbb{E}[(\\delta\\hat{\\theta})^2]$（因为一阶近似下 $\\mathbb{E}[\\delta\\hat{\\theta}] \\approx 0$）。\n$$\n\\mathrm{Var}(\\hat{\\theta}) \\approx \\frac{1}{|\\mu|^2} \\mathrm{Var}\\left( S_y \\cos\\theta_\\star - S_x \\sin\\theta_\\star \\right)\n$$\n其中 $S_x = \\sum_i r_i \\cos\\phi_i$ 且 $S_y = \\sum_i r_i \\sin\\phi_i$。该线性组合的方差为：\n$$\n\\mathrm{Var}\\left( S_y \\cos\\theta_\\star - S_x \\sin\\theta_\\star \\right) = \\cos^2\\theta_\\star \\mathrm{Var}(S_y) + \\sin^2\\theta_\\star \\mathrm{Var}(S_x) - 2\\sin\\theta_\\star\\cos\\theta_\\star \\mathrm{Cov}(S_x, S_y)\n$$\n由于神经元是独立的， $S_x$ 和 $S_y$ 的方差和协方差是单个神经元贡献的总和：\n$$\n\\mathrm{Var}(S_x) = \\sum_{i=1}^N \\mathrm{Var}(r_i \\cos\\phi_i) = \\sum_{i=1}^N \\cos^2\\phi_i \\mathrm{Var}(r_i)\n$$\n$$\n\\mathrm{Var}(S_y) = \\sum_{i=1}^N \\mathrm{Var}(r_i \\sin\\phi_i) = \\sum_{i=1}^N \\sin^2\\phi_i \\mathrm{Var}(r_i)\n$$\n$$\n\\mathrm{Cov}(S_x, S_y) = \\sum_{i=1}^N \\mathrm{Cov}(r_i \\cos\\phi_i, r_i \\sin\\phi_i) = \\sum_{i=1}^N \\cos\\phi_i \\sin\\phi_i \\mathrm{Var}(r_i)\n$$\n泊松分布的一个关键特性是方差等于均值：$\\mathrm{Var}(r_i) = \\mathbb{E}[r_i] = \\Lambda(\\phi_i \\mid \\theta_0)$。代入此式并将和转换为积分以取大 $N$ 极限：\n$$\n\\mathrm{Var}(S_x) \\approx N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0) \\cos^2\\phi \\, p(\\phi) \\, d\\phi\n$$\n$$\n\\mathrm{Var}(S_y) \\approx N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0) \\sin^2\\phi \\, p(\\phi) \\, d\\phi\n$$\n$$\n\\mathrm{Cov}(S_x, S_y) \\approx N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0) \\cos\\phi \\sin\\phi \\, p(\\phi) \\, d\\phi\n$$\n将这些代回到 $\\mathrm{Var}(S_y \\cos\\theta_\\star - S_x \\sin\\theta_\\star)$ 的表达式中：\n\\begin{align*}\n\\text{分子} &= N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0) p(\\phi) \\left[ \\cos^2\\theta_\\star \\sin^2\\phi + \\sin^2\\theta_\\star \\cos^2\\phi - 2\\sin\\theta_\\star\\cos\\theta_\\star\\cos\\phi\\sin\\phi \\right] d\\phi \\\\\n&= N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0) p(\\phi) \\left( \\sin\\phi\\cos\\theta_\\star - \\cos\\phi\\sin\\theta_\\star \\right)^2 d\\phi \\\\\n&= N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0) p(\\phi) \\sin^2(\\phi - \\theta_\\star) d\\phi\n\\end{align*}\n最后，渐近方差是这个分子与平均向量模的平方 $|\\mu|^2$ 的比值：\n$$\n\\mathrm{Var}(\\hat{\\theta}) \\approx \\frac{N \\int_{-\\pi}^{\\pi} \\Lambda(\\phi \\mid \\theta_0)\\, \\sin^2(\\phi - \\theta_\\star)\\, p(\\phi)\\, d\\phi}{\\lvert \\mu \\rvert^2}\n$$\n至此完成了所需表达式的推导。它们现在已准备好进行数值实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the asymptotic bias and variance of a population vector decoder\n    for head direction cells based on a set of test cases.\n    \"\"\"\n\n    def compute_decoder_performance(params, num_points=4097):\n        \"\"\"\n        Calculates the bias and variance for a single parameter set.\n\n        Args:\n            params (dict): A dictionary containing all model parameters.\n            num_points (int): The number of points for the numerical integration grid.\n\n        Returns:\n            tuple: A tuple containing the asymptotic bias (radians) and variance.\n        \"\"\"\n        # Unpack parameters\n        N = params['N']\n        theta_0 = params['theta_0']\n        kappa = params['kappa']\n        b = params['b']\n        m = params['m']\n        epsilon = params['epsilon']\n        mu_g = params['mu_g']\n        T = params['T']\n        p_phi_type = params['p_phi_type']\n        kappa_d = params.get('kappa_d')\n        mu_d = params.get('mu_d')\n        \n        # Set up the integration grid for phi\n        phi = np.linspace(-np.pi, np.pi, num_points)\n\n        # 1. Define the probability density of preferred directions, p(phi)\n        if p_phi_type == 'uniform':\n            p_phi = np.full_like(phi, 1.0 / (2 * np.pi))\n        else:  # 'von_mises'\n            # Numerically normalize p(phi) as required by the problem statement\n            unnormalized_p_phi = np.exp(kappa_d * np.cos(phi - mu_d))\n            norm_const = np.trapz(unnormalized_p_phi, phi)\n            p_phi = unnormalized_p_phi / norm_const\n\n        # 2. Define the heterogeneous modulation term, m(phi)\n        m_phi = m * (1 + epsilon * np.cos(phi - mu_g))\n\n        # 3. Define the mean total spike count, Lambda(phi|theta_0)\n        Lambda_phi = T * (b + m_phi * np.exp(kappa * np.cos(theta_0 - phi)))\n\n        # 4. Compute the mean complex population vector, mu\n        integrand_mu = Lambda_phi * np.exp(1j * phi) * p_phi\n        mu_per_neuron = np.trapz(integrand_mu, phi)\n        mu = N * mu_per_neuron\n\n        # 5. Compute the asymptotic bias\n        theta_star = np.angle(mu)\n        bias = theta_star - theta_0\n        # Wrap the bias to the interval [-pi, pi)\n        bias = (bias + np.pi) % (2 * np.pi) - np.pi\n\n        # 6. Compute the asymptotic variance\n        mu_magnitude_sq = np.abs(mu)**2\n        \n        # Numerator of the variance expression\n        integrand_var = Lambda_phi * (np.sin(phi - theta_star))**2 * p_phi\n        numerator_integral = np.trapz(integrand_var, phi)\n        numerator = N * numerator_integral\n\n        if mu_magnitude_sq == 0:\n            # This case is unlikely with the given parameters\n            variance = np.inf\n        else:\n            variance = numerator / mu_magnitude_sq\n            \n        return bias, variance\n\n    # Test cases as defined in the problem description\n    test_cases = [\n        # Case A: Uniform p(phi), no heterogeneity\n        {\n            'N': 60, 'theta_0': 0.7, 'kappa': 2.0, 'b': 5.0, 'm': 15.0, \n            'epsilon': 0.0, 'mu_g': 0.0, 'T': 0.25, 'p_phi_type': 'uniform'\n        },\n        # Case B: Non-uniform p(phi)\n        {\n            'N': 100, 'theta_0': 1.2, 'kappa': 2.0, 'b': 5.0, 'm': 10.0, \n            'epsilon': 0.0, 'mu_g': 0.0, 'T': 0.5, 'p_phi_type': 'von_mises', \n            'kappa_d': 1.5, 'mu_d': 0.0\n        },\n        # Case C: Uniform p(phi), heterogeneous gain\n        {\n            'N': 80, 'theta_0': -1.4, 'kappa': 1.2, 'b': 8.0, 'm': 12.0, \n            'epsilon': 0.3, 'mu_g': 0.5, 'T': 0.4, 'p_phi_type': 'uniform'\n        },\n        # Case D: Non-uniform p(phi) and heterogeneous gain\n        {\n            'N': 120, 'theta_0': 3.05, 'kappa': 3.0, 'b': 3.0, 'm': 9.0, \n            'epsilon': 0.2, 'mu_g': 3.0, 'T': 0.3, 'p_phi_type': 'von_mises',\n            'kappa_d': 2.0, 'mu_d': 3.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        bias, variance = compute_decoder_performance(params)\n        results.extend([bias, variance])\n\n    # Print the final output in the required format\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经看到，单独的路径积分会因误差无界累积而失效。这个最终的实践练习将模拟大脑解决这一问题的关键机制：融合外部地标信息来周期性地重置和校正累积的误差。你将通过一个离散时间模型，定量地比较有地标校正和无地标校正两种情况下定位误差的动态演化过程 。通过这个对比，你将清晰地看到，外部线索的整合如何将一个不稳定的估计过程转变为一个长期稳定且精确的导航系统，这正是大脑空间导航系统鲁棒性的核心所在。",
            "id": "3998165",
            "problem": "考虑一个用于空间导航的二维平面路径积分估计器，这在海马体和内嗅皮层系统的模型中是标准配置。在离散时间步 $k \\in \\{1,\\dots,T\\}$，该估计器根据以下规则通过对速度和航向进行积分来更新其位置\n$$\n\\widehat{\\boldsymbol{x}}_{k} = \\widehat{\\boldsymbol{x}}_{k-1} + v_k \\, \\Delta t \\, \\begin{bmatrix}\\cos \\theta_k \\\\ \\sin \\theta_k \\end{bmatrix},\n$$\n其中 $\\Delta t$ 是以秒为单位的固定步长时间， $v_k$ 是以米/秒为单位的测量速度， $\\theta_k$ 是以弧度为单位的测量航向角。真实运动是一个速度为 $v_0$ 、航向为 $\\theta_0$ 的恒速、恒定航向轨迹，因此每一步的真实位移是\n$$\n\\boldsymbol{d}_0 = v_0 \\, \\Delta t \\, \\begin{bmatrix}\\cos \\theta_0 \\\\ \\sin \\theta_0 \\end{bmatrix}.\n$$\n测量值受到零均值高斯噪声的干扰，该噪声在时间上以及在速度和航向之间是独立的：\n$$\nv_k = v_0 + \\varepsilon_{v,k}, \\quad \\varepsilon_{v,k} \\sim \\mathcal{N}(0, \\sigma_v^2),\n$$\n$$\n\\theta_k = \\theta_0 + \\varepsilon_{\\theta,k}, \\quad \\varepsilon_{\\theta,k} \\sim \\mathcal{N}(0, \\sigma_\\theta^2),\n$$\n其中 $(\\varepsilon_{v,k})$ 和 $(\\varepsilon_{\\theta,k})$ 是相互独立的独立序列。在没有任何地标校正的情况下，第 $T$ 步的估计误差为\n$$\n\\boldsymbol{e}_T^{\\mathrm{nc}} = \\widehat{\\boldsymbol{x}}_{T} - \\boldsymbol{x}_{T},\n$$\n其中 $\\boldsymbol{x}_{T} = \\boldsymbol{x}_{0} + T \\boldsymbol{d}_0$ 是真实位置。\n\n现在考虑每 $M$ 步进行一次间歇性地标校正。在校正时刻 $k \\in \\{M, 2M, 3M, \\dots\\}$，估计器会接收一个基于地标的位置测量值，并将位置估计重置为\n$$\n\\widehat{\\boldsymbol{x}}_{k} \\leftarrow \\boldsymbol{x}_{k} + \\boldsymbol{\\eta}_{k},\n$$\n其中 $\\boldsymbol{\\eta}_{k} \\sim \\mathcal{N}\\!\\left(\\boldsymbol{0}, \\sigma_L^2 \\boldsymbol{I}_2\\right)$ 是以米为单位的各向同性零均值高斯校正噪声，它与所有其他噪声独立，且在各次校正之间也独立，而 $\\boldsymbol{I}_2$ 是 $2 \\times 2$ 单位矩阵。在两次校正之间，估计器继续如上所述对 $v_k$ 和 $\\theta_k$ 进行积分。在有校正的情况下，第 $T$ 步的估计误差表示为\n$$\n\\boldsymbol{e}_T^{\\mathrm{wc}} = \\widehat{\\boldsymbol{x}}_{T} - \\boldsymbol{x}_{T}.\n$$\n\n你的任务：\n1. 从离散时间路径积分规则、高斯噪声的独立性以及高斯变量的三角函数的标准期望出发，推导偏差向量 $\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}]$ 和协方差矩阵 $\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{nc}})$ 关于 $T$, $\\Delta t$, $v_0$, $\\theta_0$, $\\sigma_v$ 和 $\\sigma_\\theta$ 的精确表达式。然后，在周期为 $M$、校正噪声方差为 $\\sigma_L^2$ 的间歇性地标校正下，推导 $\\boldsymbol{e}_T^{\\mathrm{wc}}$ 对应的偏差向量和协方差矩阵。\n2. 基于你的推导，实现一个程序，为每个测试用例计算偏差向量的欧几里得范数 $\\|\\mathbb{E}[\\boldsymbol{e}_T]\\|$（单位：米）和协方差矩阵的迹 $\\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T))$（单位：平方米），包括无校正和有校正两种情况。所有角度必须以弧度为单位。速度以米/秒表示，时间以秒表示，位置以米表示，协方差的迹以平方米表示。不要四舍五入；输出原始浮点数。\n3. 比较缩放定律：使用你的公式来描述在无校正和有间歇性校正（完美的和带噪声的）的情况下，偏差范数和协方差的迹如何随 $T$ 变化，并确保程序为给定的测试套件在数值上反映这些定律。\n\n测试套件（每个用例是一个元组 $(v_0, \\theta_0, \\Delta t, T, \\sigma_v, \\sigma_\\theta, M, \\sigma_L)$，其中 $v_0$ 单位为米/秒，$\\theta_0$ 单位为弧度，$\\Delta t$ 单位为秒，$T$ 单位为步，$\\sigma_v$ 单位为米/秒，$\\sigma_\\theta$ 单位为弧度，$M$ 单位为步，$\\sigma_L$ 单位为米）：\n- 用例1（一般情况）：$(1.2, 0.5, 0.1, 100, 0.15, 0.05, 20, 0.0)$。\n- 用例2（航向噪声为零的边界情况）：$(0.8, 1.0, 0.05, 200, 0.2, 0.0, 25, 0.0)$。\n- 用例3（带噪声校正的较强航向噪声）：$\\left(1.0, \\frac{\\pi}{3}, 0.2, 300, 0.05, 0.2, 30, 0.02\\right)$。\n\n你的程序应该生成单行输出，其中包含一个方括号内的逗号分隔列表形式的结果，每个用例的结果按以下顺序排列：$[\\|\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}]\\|,\\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{nc}})),\\|\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{wc}}]\\|,\\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{wc}}))]$。按顺序连接所有三个用例的结果，最终得到一个包含 12 个浮点数的列表。例如，输出格式必须为：\n$$\n[\\text{case1\\_bias\\_nc},\\text{case1\\_trace\\_nc},\\text{case1\\_bias\\_wc},\\text{case1\\_trace\\_wc},\\text{case2\\_bias\\_nc},\\dots,\\text{case3\\_trace\\_wc}].\n$$",
            "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n- 路径积分更新规则：$\\widehat{\\boldsymbol{x}}_{k} = \\widehat{\\boldsymbol{x}}_{k-1} + v_k \\, \\Delta t \\, \\begin{bmatrix}\\cos \\theta_k \\\\ \\sin \\theta_k \\end{bmatrix}$\n- 时间步：$k \\in \\{1,\\dots,T\\}$，时长 $\\Delta t$（秒）\n- 真实运动：速度 $v_0$，航向 $\\theta_0$（均为常数）\n- 每步的真实位移：$\\boldsymbol{d}_0 = v_0 \\, \\Delta t \\, \\begin{bmatrix}\\cos \\theta_0 \\\\ \\sin \\theta_0 \\end{bmatrix}$\n- 测量的速度：$v_k = v_0 + \\varepsilon_{v,k}$，噪声 $\\varepsilon_{v,k} \\sim \\mathcal{N}(0, \\sigma_v^2)$\n- 测量的航向：$\\theta_k = \\theta_0 + \\varepsilon_{\\theta,k}$，噪声 $\\varepsilon_{\\theta,k} \\sim \\mathcal{N}(0, \\sigma_\\theta^2)$\n- 噪声属性：$(\\varepsilon_{v,k})$ 和 $(\\varepsilon_{\\theta,k})$ 是相互独立的独立序列。\n- 无校正误差 (nc)：$\\boldsymbol{e}_T^{\\mathrm{nc}} = \\widehat{\\boldsymbol{x}}_{T} - \\boldsymbol{x}_{T}$，其中 $\\boldsymbol{x}_{T} = \\boldsymbol{x}_{0} + T \\boldsymbol{d}_0$。假设初始条件 $\\widehat{\\boldsymbol{x}}_{0} = \\boldsymbol{x}_0$。\n- 地标校正：每 $M$ 步发生一次，在 $k \\in \\{M, 2M, 3M, \\dots\\}$。\n- 校正规则：$\\widehat{\\boldsymbol{x}}_{k} \\leftarrow \\boldsymbol{x}_{k} + \\boldsymbol{\\eta}_{k}$\n- 校正噪声：$\\boldsymbol{\\eta}_{k} \\sim \\mathcal{N}\\!\\left(\\boldsymbol{0}, \\sigma_L^2 \\boldsymbol{I}_2\\right)$，与所有其他噪声独立，且在时间上独立。\n- 有校正误差 (wc)：$\\boldsymbol{e}_T^{\\mathrm{wc}} = \\widehat{\\boldsymbol{x}}_{T} - \\boldsymbol{x}_{T}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了计算神经科学中路径积分的标准模型，这一过程被认为是由头朝向细胞、网格细胞和位置细胞实现的。使用高斯噪声来模拟感官不确定性是该领域中一个普遍且有效的假设。该模型虽是简化模型，但它牢固地植根于已建立的理论框架。\n- **良构性**：该问题要求计算估计误差的前两阶矩（均值和协方差），这是一个定义明确的统计量。输入被清晰地指定，模型动力学是明确的，从而导向一个唯一解。\n- **客观性**：该问题以精确的数学和统计语言陈述，没有主观或模糊的术语。\n- **完整性**：所有必要的参数（$v_0, \\theta_0, \\Delta t, T, \\sigma_v, \\sigma_\\theta, M, \\sigma_L$）和模型方程均已提供。\n- **一致性**：问题陈述中没有矛盾之处。\n\n**步骤 3：结论与行动**\n该问题有效。它是理论神经科学中一个良构的、有科学依据的问题。有必要进行完整的推导和求解。\n\n### 偏差和协方差的推导\n\n我们的任务是找出估计误差的偏差向量 $\\mathbb{E}[\\boldsymbol{e}_T]$ 和协方差矩阵 $\\mathrm{Cov}(\\boldsymbol{e}_T)$，包括无地标校正和有地标校正两种情况。\n\n#### 1. 无校正 (nc) 分析\n\n假设初始估计是完美的，即 $\\widehat{\\boldsymbol{x}}_0 = \\boldsymbol{x}_0$，则第 $T$ 步的误差是所有单步误差之和：\n$$\n\\boldsymbol{e}_T^{\\mathrm{nc}} = \\widehat{\\boldsymbol{x}}_T - \\boldsymbol{x}_T = \\sum_{k=1}^T \\left( \\widehat{\\boldsymbol{d}}_k - \\boldsymbol{d}_0 \\right)\n$$\n其中 $\\widehat{\\boldsymbol{d}}_k = v_k \\Delta t \\begin{bmatrix} \\cos\\theta_k \\\\ \\sin\\theta_k \\end{bmatrix}$ 是估计位移， $\\boldsymbol{d}_0 = v_0 \\Delta t \\begin{bmatrix} \\cos\\theta_0 \\\\ \\sin\\theta_0 \\end{bmatrix}$ 是真实位移。令 $\\boldsymbol{\\delta}_k = \\widehat{\\boldsymbol{d}}_k - \\boldsymbol{d}_0$ 为单步误差。由于噪声项 $(\\varepsilon_{v,k}, \\varepsilon_{\\theta,k})$ 随时间独立同分布 (i.i.d.)，因此单步误差 $\\boldsymbol{\\delta}_k$ 也是独立同分布的。\n\n**偏差向量 $\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}]$**\n根据期望的线性性质， $\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}] = \\sum_{k=1}^T \\mathbb{E}[\\boldsymbol{\\delta}_k] = T \\mathbb{E}[\\boldsymbol{\\delta}_1]$。我们计算 $\\mathbb{E}[\\boldsymbol{\\delta}_1] = \\mathbb{E}[\\widehat{\\boldsymbol{d}}_1] - \\boldsymbol{d}_0$。\n$$\n\\mathbb{E}[\\widehat{\\boldsymbol{d}}_1] = \\Delta t \\, \\mathbb{E}\\left[ v_1 \\begin{bmatrix} \\cos\\theta_1 \\\\ \\sin\\theta_1 \\end{bmatrix} \\right] = \\Delta t \\begin{bmatrix} \\mathbb{E}[v_1 \\cos\\theta_1] \\\\ \\mathbb{E}[v_1 \\sin\\theta_1] \\end{bmatrix}\n$$\n由于 $v_1$ 和 $\\theta_1$ 是独立的，所以 $\\mathbb{E}[v_1 \\cos\\theta_1] = \\mathbb{E}[v_1]\\mathbb{E}[\\cos\\theta_1]$。我们有 $\\mathbb{E}[v_1] = \\mathbb{E}[v_0 + \\varepsilon_{v,1}] = v_0$。\n对于高斯变量 $\\theta_1 \\sim \\mathcal{N}(\\theta_0, \\sigma_\\theta^2)$，我们使用标准结果： $\\mathbb{E}[\\cos\\theta_1] = \\cos(\\theta_0) e^{-\\sigma_\\theta^2/2}$ 和 $\\mathbb{E}[\\sin\\theta_1] = \\sin(\\theta_0) e^{-\\sigma_\\theta^2/2}$。\n$$\n\\mathbb{E}[\\widehat{\\boldsymbol{d}}_1] = \\Delta t \\, v_0 e^{-\\sigma_\\theta^2/2} \\begin{bmatrix} \\cos\\theta_0 \\\\ \\sin\\theta_0 \\end{bmatrix} = e^{-\\sigma_\\theta^2/2} \\boldsymbol{d}_0\n$$\n每一步的偏差是 $\\mathbb{E}[\\boldsymbol{\\delta}_1] = (e^{-\\sigma_\\theta^2/2} - 1)\\boldsymbol{d}_0$。总偏差是：\n$$\n\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}] = T(e^{-\\sigma_\\theta^2/2} - 1)\\boldsymbol{d}_0 = T v_0 \\Delta t (e^{-\\sigma_\\theta^2/2} - 1) \\begin{bmatrix} \\cos\\theta_0 \\\\ \\sin\\theta_0 \\end{bmatrix}\n$$\n偏差向量的欧几里得范数是：\n$$\n\\|\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}]\\| = |T v_0 \\Delta t (e^{-\\sigma_\\theta^2/2} - 1)| = T v_0 \\Delta t (1 - e^{-\\sigma_\\theta^2/2})\n$$\n\n**协方差矩阵 $\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{nc}})$**\n由于步长误差 $\\boldsymbol{\\delta}_k$ 是独立同分布的，$\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{nc}}) = \\sum_{k=1}^T \\mathrm{Cov}(\\boldsymbol{\\delta}_k) = T \\mathrm{Cov}(\\boldsymbol{\\delta}_1)$。同时 $\\mathrm{Cov}(\\boldsymbol{\\delta}_1) = \\mathrm{Cov}(\\widehat{\\boldsymbol{d}}_1)$。迹是旋转不变的，这简化了计算。\n$$\n\\mathrm{tr}(\\mathrm{Cov}(\\widehat{\\boldsymbol{d}}_1)) = \\mathrm{tr}(\\mathbb{E}[\\widehat{\\boldsymbol{d}}_1 \\widehat{\\boldsymbol{d}}_1^T] - \\mathbb{E}[\\widehat{\\boldsymbol{d}}_1]\\mathbb{E}[\\widehat{\\boldsymbol{d}}_1]^T) = \\mathbb{E}[\\|\\widehat{\\boldsymbol{d}}_1\\|^2] - \\|\\mathbb{E}[\\widehat{\\boldsymbol{d}}_1]\\|^2\n$$\n我们有 $\\|\\widehat{\\boldsymbol{d}}_1\\|^2 = (v_1 \\Delta t)^2$。所以，$\\mathbb{E}[\\|\\widehat{\\boldsymbol{d}}_1\\|^2] = (\\Delta t)^2 \\mathbb{E}[v_1^2] = (\\Delta t)^2(v_0^2 + \\sigma_v^2)$。\n我们也有 $\\|\\mathbb{E}[\\widehat{\\boldsymbol{d}}_1]\\|^2 = \\|e^{-\\sigma_\\theta^2/2} \\boldsymbol{d}_0\\|^2 = (e^{-\\sigma_\\theta^2/2})^2 \\|v_0 \\Delta t \\begin{bmatrix}\\cos\\theta_0 \\\\ \\sin\\theta_0\\end{bmatrix}\\|^2 = e^{-\\sigma_\\theta^2} (v_0 \\Delta t)^2$。\n因此，单步协方差的迹为：\n$$\n\\mathrm{tr}(\\mathrm{Cov}(\\widehat{\\boldsymbol{d}}_1)) = (\\Delta t)^2(v_0^2 + \\sigma_v^2) - e^{-\\sigma_\\theta^2}(v_0\\Delta t)^2 = (\\Delta t)^2 [v_0^2(1 - e^{-\\sigma_\\theta^2}) + \\sigma_v^2]\n$$\n总误差协方差的迹为：\n$$\n\\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{nc}})) = T (\\Delta t)^2 [v_0^2(1 - e^{-\\sigma_\\theta^2}) + \\sigma_v^2]\n$$\n\n#### 2. 有校正 (wc) 分析\n\n地标校正每 $M$ 步重置一次估计值。时刻 $T$ 的误差取决于自上次校正以来的步数。\n令 $k_{last} = M \\lfloor T/M \\rfloor$ 为 $T$ 时刻或之前最后一次校正的时刻。如果 $T  M$，则没有发生过校正，$k_{last}=0$。自上次重置以来的步数为 $T_{rem} = T - k_{last}$。\n\n情况 1：$T  M$。没有发生过校正。误差与无校正情况相同。\n$$\n\\|\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{wc}}]\\| = \\|\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{nc}}]\\| \\quad \\text{和} \\quad \\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{wc}})) = \\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{nc}}))\n$$\n\n情况 2：$T \\ge M$。时刻 $T$ 的误差源于上一次校正时刻 $k_{last}$ 的误差以及从 $k_{last}+1$ 到 $T$ 的路径积分。\n$$\n\\boldsymbol{e}_T^{\\mathrm{wc}} = (\\widehat{\\boldsymbol{x}}_{k_{last}} - \\boldsymbol{x}_{k_{last}}) + \\sum_{j=1}^{T_{rem}} (\\widehat{\\boldsymbol{d}}_{k_{last}+j} - \\boldsymbol{d}_0)\n$$\n第一项是校正后瞬间的误差。如果 $k_{last} > 0$，这一项是 $\\boldsymbol{\\eta}_{k_{last}}$。如果 $k_{last}=0$ （即 $T  M$，但我们已处理该情况），则为零。我们假设 $T \\ge M$，所以 $k_{last} \\ge M$。\n$$\n\\boldsymbol{e}_T^{\\mathrm{wc}} = \\boldsymbol{\\eta}_{k_{last}} + \\sum_{j=1}^{T_{rem}} \\boldsymbol{\\delta}_{k_{last}+j}\n$$\n**偏差向量 $\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{wc}}]$**\n由于 $\\boldsymbol{\\eta}_{k_{last}}$ 和 $\\boldsymbol{\\delta}_j$ 都是零均值（或更准确地说，$\\mathbb{E}[\\boldsymbol{\\eta}_{k_{last}}]=\\boldsymbol{0}$），误差的期望为\n$$\n\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{wc}}] = \\mathbb{E}[\\boldsymbol{\\eta}_{k_{last}}] + \\sum_{j=1}^{T_{rem}} \\mathbb{E}[\\boldsymbol{\\delta}_{k_{last}+j}] = \\boldsymbol{0} + T_{rem} \\mathbb{E}[\\boldsymbol{\\delta}_1] = T_{rem}(e^{-\\sigma_\\theta^2/2} - 1)\\boldsymbol{d}_0\n$$\n范数为：\n$$\n\\|\\mathbb{E}[\\boldsymbol{e}_T^{\\mathrm{wc}}]\\| = T_{rem} v_0 \\Delta t (1 - e^{-\\sigma_\\theta^2/2})\n$$\n\n**协方差矩阵 $\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{wc}})$**\n由于所有噪声项都是独立的，协方差是各项协方差之和：\n$$\n\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{wc}}) = \\mathrm{Cov}(\\boldsymbol{\\eta}_{k_{last}}) + \\sum_{j=1}^{T_{rem}} \\mathrm{Cov}(\\boldsymbol{\\delta}_j) = \\sigma_L^2 \\boldsymbol{I}_2 + T_{rem}\\mathrm{Cov}(\\boldsymbol{\\delta}_1)\n$$\n迹为：\n$$\n\\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{e}_T^{\\mathrm{wc}})) = \\mathrm{tr}(\\sigma_L^2 \\boldsymbol{I}_2) + T_{rem}\\mathrm{tr}(\\mathrm{Cov}(\\boldsymbol{\\delta}_1)) = 2\\sigma_L^2 + T_{rem} (\\Delta t)^2 [v_0^2(1 - e^{-\\sigma_\\theta^2}) + \\sigma_v^2]\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spatial navigation estimator problem for the given test suite.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (general case)\n        (1.2, 0.5, 0.1, 100, 0.15, 0.05, 20, 0.0),\n        # Case 2 (boundary case with zero heading noise)\n        (0.8, 1.0, 0.05, 200, 0.2, 0.0, 25, 0.0),\n        # Case 3 (stronger heading noise with noisy corrections)\n        (1.0, np.pi/3, 0.2, 300, 0.05, 0.2, 30, 0.02),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        v0, theta0, delta_t, T, sigma_v, sigma_theta, M, sigma_L = case\n\n        # Helper functions for base path integration error (no corrections)\n        def path_integ_bias_norm(k, v0, delta_t, sigma_theta):\n            if k == 0:\n                return 0.0\n            sigma_theta_sq = sigma_theta**2\n            # Formula: k * v0 * delta_t * (1 - exp(-sigma_theta^2 / 2))\n            return k * v0 * delta_t * (1.0 - np.exp(-sigma_theta_sq / 2.0))\n\n        def path_integ_trace(k, v0, delta_t, sigma_v, sigma_theta):\n            if k == 0:\n                return 0.0\n            sigma_v_sq = sigma_v**2\n            sigma_theta_sq = sigma_theta**2\n            v0_sq = v0**2\n            delta_t_sq = delta_t**2\n            # Formula: k * delta_t^2 * [v0^2 * (1 - exp(-sigma_theta^2)) + sigma_v^2]\n            return k * delta_t_sq * (v0_sq * (1.0 - np.exp(-sigma_theta_sq)) + sigma_v_sq)\n\n        # --- NO CORRECTIONS (nc) ---\n        bias_nc_norm = path_integ_bias_norm(T, v0, delta_t, sigma_theta)\n        trace_nc = path_integ_trace(T, v0, delta_t, sigma_v, sigma_theta)\n        \n        # --- WITH CORRECTIONS (wc) ---\n        bias_wc_norm = 0.0\n        trace_wc = 0.0\n        \n        if T  M:\n            # No corrections have occurred yet, so error is the same as the 'nc' case.\n            bias_wc_norm = bias_nc_norm\n            trace_wc = trace_nc\n        else:\n            # At least one correction period has passed.\n            t_rem = T % M\n            \n            # The landmark error contribution to variance is always present\n            # after the first correction at step M.\n            landmark_var_contrib = 2.0 * sigma_L**2\n            \n            # Bias and variance from path integration accumulate since the last reset.\n            # If t_rem is 0, the process is exactly at a correction step, so no\n            # path integration error has accumulated since the reset.\n            pi_bias_contrib = path_integ_bias_norm(t_rem, v0, delta_t, sigma_theta)\n            pi_trace_contrib = path_integ_trace(t_rem, v0, delta_t, sigma_v, sigma_theta)\n            \n            bias_wc_norm = pi_bias_contrib\n            trace_wc = landmark_var_contrib + pi_trace_contrib\n            \n        results.extend([bias_nc_norm, trace_nc, bias_wc_norm, trace_wc])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}