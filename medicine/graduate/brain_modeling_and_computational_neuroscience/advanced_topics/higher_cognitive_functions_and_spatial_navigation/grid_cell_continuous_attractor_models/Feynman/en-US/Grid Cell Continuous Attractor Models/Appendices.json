{
    "hands_on_practices": [
        {
            "introduction": "The most striking feature of a grid cell is its periodic, hexagonal firing pattern. Continuous attractor models propose that this pattern emerges spontaneously from the interactions within a sheet of neurons, a process known as Turing pattern formation. This exercise () provides a fundamental calculation, guiding you to derive the direct relationship between the real-space grid spacing, $a$, and the dominant Fourier mode's wavenumber, $k$. Mastering this connection is the first step to understanding how network architecture dictates the geometric properties of the neural representation.",
            "id": "3985850",
            "problem": "A two-dimensional Continuous Attractor Neural Network (CANN) with translation-invariant, radially symmetric connectivity undergoes a Turing-type instability at a nonzero wavenumber magnitude, causing the fastest-growing Fourier modes to lie on a ring in wavevector space. Suppose the network saturates into a stationary pattern constructed from a triad of cosine modes with equal wavenumber magnitude $k$ and unit-direction vectors separated by $60^\\circ$, yielding a hexagonal (triangular) grid of activity peaks. Let the real-space grid be a triangular Bravais lattice with nearest-neighbor spacing $a$, and let the primitive lattice vectors be chosen as $\\mathbf{a}_{1} = a\\,(1,0)$ and $\\mathbf{a}_{2} = a\\,\\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)$.\n\nStarting from the definitions of the reciprocal lattice and Fourier periodicity of a Bravais lattice, derive the wavenumber magnitude $k$ of the triad of cosine modes required to produce a triangular lattice of spacing $a$. Then verify that the three wavevectors can be selected along directions separated by $60^\\circ$ with this $k$ so that translations by $\\mathbf{a}_{1}$ and $\\mathbf{a}_{2}$ yield phase advances of integer multiples of $2\\pi$ for each mode, ensuring consistency of the grid pattern. Express your final $k$ in $\\mathrm{m}^{-1}$. The final answer must be a single closed-form analytic expression.",
            "solution": "The problem requires the derivation of the wavenumber magnitude $k$ for a triad of cosine modes that form a stationary hexagonal activity pattern on a two-dimensional triangular Bravais lattice. The real-space lattice is defined by a nearest-neighbor spacing $a$ and a specific choice of primitive lattice vectors. The derivation must start from the fundamental definition of the reciprocal lattice.\n\nA stationary pattern $A(\\mathbf{r})$ that possesses the periodicity of a Bravais lattice can be represented by a Fourier series over the reciprocal lattice vectors of that Bravais lattice. The general form is:\n$$A(\\mathbf{r}) = \\sum_{\\mathbf{G}} c_{\\mathbf{G}} \\exp(i\\mathbf{G} \\cdot \\mathbf{r})$$\nwhere the sum is over all reciprocal lattice vectors $\\mathbf{G}$, and $c_{\\mathbf{G}}$ are the Fourier coefficients. A periodic pattern requires that for any real-space lattice vector $\\mathbf{R} = n_1\\mathbf{a}_1 + n_2\\mathbf{a}_2$ (with $n_1, n_2$ being integers), the condition $A(\\mathbf{r}+\\mathbf{R}) = A(\\mathbf{r})$ must hold. This imposes a condition on the allowed wavevectors $\\mathbf{G}$:\n$$\\exp(i\\mathbf{G} \\cdot \\mathbf{R}) = 1 \\quad \\implies \\quad \\mathbf{G} \\cdot \\mathbf{R} = 2\\pi m$$\nfor some integer $m$. This condition must hold for the primitive vectors $\\mathbf{a}_1$ and $\\mathbf{a}_2$.\n\nThe problem states that the pattern emerges from a Turing-type instability where the fastest-growing Fourier modes have a non-zero wavenumber magnitude $k$. This corresponds to the magnitude of the shortest non-zero reciprocal lattice vectors. Our first step is to determine these vectors.\n\nThe real-space primitive lattice vectors are given as:\n$$\\mathbf{a}_{1} = a(1,0)$$\n$$\\mathbf{a}_{2} = a\\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)$$\nThese vectors have equal length $|\\mathbf{a}_1| = |\\mathbf{a}_2| = a$ and are separated by an angle of $60^\\circ$, correctly defining a triangular lattice with nearest-neighbor spacing $a$.\n\nThe primitive vectors of the reciprocal lattice, $\\mathbf{b}_1$ and $\\mathbf{b}_2$, are defined by the duality condition:\n$$\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$$\nwhere $\\delta_{ij}$ is the Kronecker delta. We can solve for the components of $\\mathbf{b}_1 = (b_{1x}, b_{1y})$ and $\\mathbf{b}_2 = (b_{2x}, b_{2y})$ using this definition.\n\nFor $\\mathbf{b}_1$:\n$1.$ $\\mathbf{a}_1 \\cdot \\mathbf{b}_1 = a(1)b_{1x} + a(0)b_{1y} = ab_{1x} = 2\\pi \\implies b_{1x} = \\frac{2\\pi}{a}$\n$2.$ $\\mathbf{a}_2 \\cdot \\mathbf{b}_1 = a(\\frac{1}{2})b_{1x} + a(\\frac{\\sqrt{3}}{2})b_{1y} = 0 \\implies \\frac{1}{2}\\left(\\frac{2\\pi}{a}\\right) + \\frac{\\sqrt{3}}{2}b_{1y} = 0 \\implies b_{1y} = -\\frac{2\\pi}{a\\sqrt{3}}$\nSo, $\\mathbf{b}_1 = \\frac{2\\pi}{a}\\left(1, -\\frac{1}{\\sqrt{3}}\\right)$.\n\nFor $\\mathbf{b}_2$:\n$1.$ $\\mathbf{a}_1 \\cdot \\mathbf{b}_2 = a(1)b_{2x} + a(0)b_{2y} = ab_{2x} = 0 \\implies b_{2x} = 0$\n$2.$ $\\mathbf{a}_2 \\cdot \\mathbf{b}_2 = a(\\frac{1}{2})b_{2x} + a(\\frac{\\sqrt{3}}{2})b_{2y} = a\\frac{\\sqrt{3}}{2}b_{2y} = 2\\pi \\implies b_{2y} = \\frac{4\\pi}{a\\sqrt{3}}$\nSo, $\\mathbf{b}_2 = \\frac{2\\pi}{a}\\left(0, \\frac{2}{\\sqrt{3}}\\right)$.\n\nThe wavenumber $k$ of the fundamental modes is the magnitude of the shortest non-zero reciprocal lattice vectors. The reciprocal lattice consists of all vectors $\\mathbf{G} = m_1\\mathbf{b}_1 + m_2\\mathbf{b}_2$ for integer $m_1, m_2$. We must find the vectors with the smallest non-zero magnitude. Let's calculate the squared magnitudes of $\\mathbf{b}_1$ and $\\mathbf{b}_2$:\n$$|\\mathbf{b}_1|^2 = \\left(\\frac{2\\pi}{a}\\right)^2 \\left(1^2 + \\left(-\\frac{1}{\\sqrt{3}}\\right)^2\\right) = \\left(\\frac{2\\pi}{a}\\right)^2 \\left(1 + \\frac{1}{3}\\right) = \\frac{4\\pi^2}{a^2} \\frac{4}{3} = \\frac{16\\pi^2}{3a^2}$$\n$$|\\mathbf{b}_2|^2 = \\left(\\frac{2\\pi}{a}\\right)^2 \\left(0^2 + \\left(\\frac{2}{\\sqrt{3}}\\right)^2\\right) = \\left(\\frac{2\\pi}{a}\\right)^2 \\left(\\frac{4}{3}\\right) = \\frac{16\\pi^2}{3a^2}$$\nBoth primitive vectors have the same magnitude. The set of shortest reciprocal lattice vectors for a triangular lattice forms a hexagon, consisting of the six vectors $\\pm\\mathbf{b}_1$, $\\pm\\mathbf{b}_2$, and $\\pm(\\mathbf{b}_1+\\mathbf{b}_2)$ if the angle between $\\mathbf{b}_1, \\mathbf{b}_2$ is $120^\\circ$, or $\\pm(\\mathbf{b}_1-\\mathbf{b}_2)$ if the angle is $60^\\circ$. Let's check the angle $\\phi$ between $\\mathbf{b}_1$ and $\\mathbf{b}_2$:\n$$\\cos\\phi = \\frac{\\mathbf{b}_1 \\cdot \\mathbf{b}_2}{|\\mathbf{b}_1||\\mathbf{b}_2|} = \\frac{\\left(\\frac{2\\pi}{a}\\right)^2\\left(1 \\cdot 0 + (-\\frac{1}{\\sqrt{3}})\\cdot\\frac{2}{\\sqrt{3}}\\right)}{\\frac{16\\pi^2}{3a^2}} = \\frac{\\frac{4\\pi^2}{a^2}(-\\frac{2}{3})}{\\frac{16\\pi^2}{3a^2}} = -\\frac{8/3}{16/3} = -\\frac{1}{2}$$\nThe angle is $\\phi=120^\\circ$. For vectors with an angle of $120^\\circ$, the length of their sum is equal to their individual lengths: $|\\mathbf{b}_1+\\mathbf{b}_2| = |\\mathbf{b}_1|$. Therefore, the shortest non-zero reciprocal lattice vectors include $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_1+\\mathbf{b}_2$ and their negatives.\n\nThe wavenumber magnitude $k$ is the common magnitude of these vectors:\n$$k = |\\mathbf{b}_1| = \\sqrt{\\frac{16\\pi^2}{3a^2}} = \\frac{4\\pi}{a\\sqrt{3}}$$\nTo rationalize the denominator, we multiply the numerator and denominator by $\\sqrt{3}$:\n$$k = \\frac{4\\pi\\sqrt{3}}{3a}$$\nAssuming $a$ is in meters ($\\mathrm{m}$), $k$ will have units of inverse meters ($\\mathrm{m}^{-1}$).\n\nNext, we verify the consistency of this result. The problem states the pattern is formed from a triad of modes with wavevectors along directions separated by $60^\\circ$. This refers to the set of the six shortest reciprocal lattice vectors: $\\{\\mathbf{k}_A, \\mathbf{k}_B, \\mathbf{k}_C, \\mathbf{k}_D, \\mathbf{k}_E, \\mathbf{k}_F\\}$. The directions of these six vectors are indeed separated by $60^\\circ$. A stationary hexagonal pattern is formed by superposing three of these modes whose wavevectors are separated by $120^\\circ$ and sum to zero (e.g., $\\mathbf{k}_A + \\mathbf{k}_C + \\mathbf{k}_E = 0$).\n\nThe second part of the verification is to show that for any of these wavevectors, say $\\mathbf{k}_i$, the phase advance upon translation by a real-space primitive vector is an integer multiple of $2\\pi$. That is, $\\mathbf{k}_i \\cdot \\mathbf{a}_j = 2\\pi n_{ij}$ for some integers $n_{ij}$.\n\nAny wavevector $\\mathbf{k}_i$ used to construct the pattern must be a reciprocal lattice vector. By definition, any reciprocal lattice vector $\\mathbf{G}$ can be written as an integer linear combination of the primitive reciprocal vectors:\n$$\\mathbf{G} = m_1\\mathbf{b}_1 + m_2\\mathbf{b}_2$$\nwhere $m_1, m_2$ are integers.\nLet's compute the dot product of $\\mathbf{G}$ with the real-space primitive vectors $\\mathbf{a}_1$ and $\\mathbf{a}_2$:\n$$\\mathbf{G} \\cdot \\mathbf{a}_1 = (m_1\\mathbf{b}_1 + m_2\\mathbf{b}_2) \\cdot \\mathbf{a}_1 = m_1(\\mathbf{b}_1 \\cdot \\mathbf{a}_1) + m_2(\\mathbf{b}_2 \\cdot \\mathbf{a}_1)$$\nUsing the definition $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi \\delta_{ij}$, this becomes:\n$$\\mathbf{G} \\cdot \\mathbf{a}_1 = m_1(2\\pi) + m_2(0) = 2\\pi m_1$$\nSimilarly, for $\\mathbf{a}_2$:\n$$\\mathbf{G} \\cdot \\mathbf{a}_2 = (m_1\\mathbf{b}_1 + m_2\\mathbf{b}_2) \\cdot \\mathbf{a}_2 = m_1(\\mathbf{b}_1 \\cdot \\mathbf{a}_2) + m_2(\\mathbf{b}_2 \\cdot \\mathbf{a}_2) = m_1(0) + m_2(2\\pi) = 2\\pi m_2$$\nSince $m_1$ and $m_2$ are integers, the phase advances $\\mathbf{G} \\cdot \\mathbf{a}_1$ and $\\mathbf{G} \\cdot \\mathbf{a}_2$ are indeed integer multiples of $2\\pi$. This holds for all wavevectors in the triad, as they are all shortest non-zero reciprocal lattice vectors. This confirms the consistency of the pattern with the underlying Bravais lattice.\n\nThe derived wavenumber magnitude is thus correct and consistent with all stated conditions.",
            "answer": "$$\\boxed{\\frac{4\\pi\\sqrt{3}}{3a}}$$"
        },
        {
            "introduction": "Having established how a static pattern can emerge, we must now understand what makes it a stable \"attractor.\" The network must be able to maintain the grid pattern against noise while allowing its position, or phase, to be updated by inputs. This practice () has you perform a linear stability analysis on a simplified model to reveal the mathematical signature of a continuous attractor: a stable amplitude and neutrally stable phase modes. By calculating the Jacobian and its eigenvalues, you will uncover the \"Goldstone\" modes that are essential for the network's computational function.",
            "id": "3985883",
            "problem": "Consider a two-dimensional, translation-invariant neural field model for medial entorhinal cortex grid cells that supports a stationary hexagonal firing-rate pattern. Let the firing-rate field be denoted by $u(\\mathbf{x}, t)$ with $\\mathbf{x} \\in \\mathbb{R}^{2}$. The coarse-grained dynamics near the onset of pattern formation can be reduced, under standard symmetry and weakly nonlinear assumptions, to a low-dimensional system describing the global pattern amplitude and phase (lattice shift). Specifically, assume that the slow dynamics of the pattern amplitude $A(t) \\in \\mathbb{R}$ and the global phase (lattice shift) $\\boldsymbol{\\phi}(t) = (\\phi_{x}(t), \\phi_{y}(t)) \\in \\mathbb{R}^{2}$ are governed by the truncated normal form\n$$\n\\frac{dA}{dt} = \\mu A - \\gamma A^{3}, \\qquad \\frac{d\\phi_{x}}{dt} = 0, \\qquad \\frac{d\\phi_{y}}{dt} = 0,\n$$\nwhere $\\mu > 0$ is the linear growth parameter (set by spectral properties of the synaptic kernel and neural gain at criticality) and $\\gamma > 0$ is the leading-order nonlinear saturation coefficient (set by higher-order terms in the neural transfer function and recurrent interactions). The stationary hexagonal pattern with nonzero amplitude corresponds to $A^{\\ast} > 0$ and an arbitrary constant $\\boldsymbol{\\phi}^{\\ast} \\in \\mathbb{R}^{2}$, reflecting continuous translational symmetry.\n\nCompute the Jacobian of the vector field of this $(A, \\phi_{x}, \\phi_{y})$ system at the stationary point with $A^{\\ast} > 0$ and arbitrary $\\boldsymbol{\\phi}^{\\ast}$, and determine its eigenvalues. Use these eigenvalues to assess the linear stability of the stationary pattern against perturbations in amplitude and phase. Provide the ordered triple $(\\lambda_{A}, \\lambda_{\\phi_{x}}, \\lambda_{\\phi_{y}})$ of eigenvalues evaluated at the nontrivial stationary amplitude. Express your final answer as a single row matrix in terms of $\\mu$ only. No numerical approximation is required, and no units are needed. The final answer must be a single analytic expression.",
            "solution": "The problem requires a linear stability analysis of a simplified dynamical system describing the amplitude and phase of a hexagonal pattern in a continuous attractor network. The state variables are the amplitude $A(t)$ and the two-dimensional phase vector $\\boldsymbol{\\phi}(t) = (\\phi_x(t), \\phi_y(t))$.\n\nThe system of ordinary differential equations is given by:\n$$ \\frac{dA}{dt} = f_A(A) = \\mu A - \\gamma A^3 $$\n$$ \\frac{d\\phi_x}{dt} = f_{\\phi_x} = 0 $$\n$$ \\frac{d\\phi_y}{dt} = f_{\\phi_y} = 0 $$\n\nFirst, we find the stationary points (fixed points) of the system by setting all time derivatives to zero. The phase equations are trivially satisfied for any constant $\\boldsymbol{\\phi}$. For the amplitude, we have:\n$$ \\mu A - \\gamma A^3 = A(\\mu - \\gamma A^2) = 0 $$\nThis gives two solutions for the amplitude: the trivial solution $A=0$, and the non-trivial solution derived from $\\mu - \\gamma A^2 = 0$. The problem asks for the analysis of the stationary pattern with a non-zero amplitude, $A^* > 0$. Given that $\\mu > 0$ and $\\gamma > 0$, we find the stationary amplitude:\n$$ A^* = \\sqrt{\\frac{\\mu}{\\gamma}} $$\nThe stationary point is thus a continuous manifold of points $(A^*, \\phi_x^*, \\phi_y^*) = (\\sqrt{\\mu/\\gamma}, c_x, c_y)$, where $c_x$ and $c_y$ are arbitrary constants.\n\nNext, we compute the Jacobian matrix $J$ of the vector field $\\mathbf{F} = (f_A, f_{\\phi_x}, f_{\\phi_y})$ with respect to the state variables $(A, \\phi_x, \\phi_y)$:\n$$ J = \\begin{pmatrix}\n\\frac{\\partial f_A}{\\partial A} & \\frac{\\partial f_A}{\\partial \\phi_x} & \\frac{\\partial f_A}{\\partial \\phi_y} \\\\\n\\frac{\\partial f_{\\phi_x}}{\\partial A} & \\frac{\\partial f_{\\phi_x}}{\\partial \\phi_x} & \\frac{\\partial f_{\\phi_x}}{\\partial \\phi_y} \\\\\n\\frac{\\partial f_{\\phi_y}}{\\partial A} & \\frac{\\partial f_{\\phi_y}}{\\partial \\phi_x} & \\frac{\\partial f_{\\phi_y}}{\\partial \\phi_y}\n\\end{pmatrix} $$\nWe calculate the necessary partial derivatives:\n$$ \\frac{\\partial f_A}{\\partial A} = \\mu - 3\\gamma A^2 $$\nAll other partial derivatives are zero, as $f_A$ is independent of phase, and the phase dynamics are identically zero. This yields a diagonal Jacobian matrix:\n$$ J = \\begin{pmatrix}\n\\mu - 3\\gamma A^2 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix} $$\nNow, we evaluate this Jacobian at the stationary amplitude $A = A^* = \\sqrt{\\mu/\\gamma}$:\n$$ \\frac{\\partial f_A}{\\partial A}\\bigg|_{A=A^*} = \\mu - 3\\gamma \\left(\\sqrt{\\frac{\\mu}{\\gamma}}\\right)^2 = \\mu - 3\\gamma \\left(\\frac{\\mu}{\\gamma}\\right) = \\mu - 3\\mu = -2\\mu $$\nThe Jacobian matrix evaluated at the stationary point is:\n$$ J^* = \\begin{pmatrix}\n-2\\mu & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix} $$\nThe eigenvalues of a diagonal matrix are its diagonal entries. Therefore, the eigenvalues are:\n$$ \\lambda_A = -2\\mu $$\n$$ \\lambda_{\\phi_x} = 0 $$\n$$ \\lambda_{\\phi_y} = 0 $$\nThe ordered triple of eigenvalues is $(\\lambda_A, \\lambda_{\\phi_x}, \\lambda_{\\phi_y}) = (-2\\mu, 0, 0)$.\n\nSince $\\mu > 0$, the eigenvalue $\\lambda_A = -2\\mu$ is negative. This indicates that the amplitude of the pattern is linearly stable. Perturbations to the amplitude will decay, returning the system to its stationary amplitude $A^*$.\n\nThe two zero eigenvalues, $\\lambda_{\\phi_x}$ and $\\lambda_{\\phi_y}$, correspond to the phase directions. A zero eigenvalue indicates neutral stability. Perturbations to the phase will neither grow nor decay, but will result in a permanent shift. These zero-eigenvalue modes are the \"Goldstone modes\" that arise from the spontaneous breaking of the system's continuous translational symmetry. Their existence is the mathematical signature of a continuous attractor, enabling path integration by allowing the phase to be shifted by small inputs without energy cost.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-2\\mu & 0 & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The existence of neutrally stable phase modes is the very feature that enables the network to perform path integration, allowing the grid pattern to move smoothly across the neural sheet to track an animal's position. This is achieved by coupling velocity inputs to the neutral modes, effectively \"pushing\" the activity bump across the network at a speed proportional to the animal's own velocity. In this final exercise (), you will implement this core function by simulating the model's response to velocity input, gaining a practical understanding of how attractor dynamics translate into a powerful navigational computation.",
            "id": "3985930",
            "problem": "You are given a velocity time series and a translationally symmetric neural field that implements a two-dimensional path integration mechanism typical of grid cell continuous attractor models. Your task is to derive a reduced dynamical description for the bump phase on the torus and implement a simulation that quantifies the discrepancy between the simulated phase trajectory and the phase predicted by direct integration of the physical displacement. Use the following foundational base: translation invariance in a two-dimensional neural field implies a continuous family of bump solutions, and the corresponding Goldstone modes yield low-dimensional neutral dynamics of the bump center driven by input. Start from the continuous attractor neural network (CANN) formulation and derive the low-dimensional phase dynamics driven by velocity input. The comparison must be made on the two-dimensional torus with angles expressed in radians.\n\nDefinitions and setup:\n- Consider a two-dimensional continuous attractor neural field for activity $u(\\mathbf{x}, t)$, where $\\mathbf{x} \\in \\mathbb{R}^2$, with spatially translation-invariant recurrent connectivity and an external input encoding velocity. Periodic boundary conditions identify the activity bump’s center as a phase point on a torus $\\mathbb{T}^2$.\n- The physical velocity is $\\mathbf{v}(t) = (v_x(t), v_y(t))$ with units $\\mathrm{m/s}$, and the physical displacement is $\\mathbf{s}(t) = \\int_0^t \\mathbf{v}(\\tau)\\, d\\tau$ with units $\\mathrm{m}$.\n- The torus coordinates are angles $\\boldsymbol{\\phi}(t) = (\\phi_x(t), \\phi_y(t))$ with units radians, each defined modulo $2\\pi$. The spatial periods along the two axes are $\\boldsymbol{\\lambda} = (\\lambda_x, \\lambda_y)$ with units $\\mathrm{m}$, so that a displacement by $\\lambda_i$ along axis $i$ corresponds to a $2\\pi$ phase advance in $\\phi_i$.\n- The reduced low-dimensional dynamics should be derived from the CANN by projecting onto the neutral shift modes and expressing the phase evolution $\\boldsymbol{\\phi}(t)$ in terms of $\\mathbf{v}(t)$ and a coupling matrix consistent with the spatial periods $\\boldsymbol{\\lambda}$. Angles must be wrapped to the interval $[0, 2\\pi)$.\n\nError metric:\n- Given a simulated phase trajectory $\\boldsymbol{\\phi}_{\\mathrm{model}}(t)$ and a “true” phase trajectory $\\boldsymbol{\\phi}_{\\mathrm{true}}(t)$ obtained by mapping physical displacement $\\mathbf{s}(t)$ to torus angles using the spatial periods $\\boldsymbol{\\lambda}$, define the component-wise wrapped phase difference $\\Delta_i(t) = \\mathrm{wrap}\\big(\\phi_{\\mathrm{model}, i}(t) - \\phi_{\\mathrm{true}, i}(t)\\big)$, where $\\mathrm{wrap}(\\cdot)$ maps angles to $(-\\pi, \\pi]$. The instantaneous geodesic error on $\\mathbb{T}^2$ is $e(t) = \\sqrt{\\Delta_x(t)^2 + \\Delta_y(t)^2}$. The required scalar metric is the root-mean-square error $E = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} e(t_n)^2}$, where $t_n$ are the discrete time samples and $N$ is the total number of samples. Report $E$ as a float rounded to six decimal places.\n\nAngle unit is radians. Physical units for velocity and spatial period are meters and meters per second as specified; the final error $E$ is a dimensionless float (radians).\n\nSimulation requirements:\n- Use discrete-time integration with a fixed time step $dt$ to compute $\\mathbf{s}(t)$ by summing $\\mathbf{v}(t) dt$ and to advance the model’s phase $\\boldsymbol{\\phi}_{\\mathrm{model}}(t)$ using the reduced phase dynamics derived from the continuous attractor neural field. At each step, wrap $\\boldsymbol{\\phi}_{\\mathrm{model}}(t)$ to $[0, 2\\pi)$ component-wise.\n- Compute $\\boldsymbol{\\phi}_{\\mathrm{true}}(t)$ by mapping $\\mathbf{s}(t)$ to angles using the spatial periods $\\boldsymbol{\\lambda}$: each component $\\phi_{\\mathrm{true}, i}(t)$ is the physical displacement $s_i(t)$ scaled to radians according to the period $\\lambda_i$, then wrapped to $[0, 2\\pi)$.\n- Implement the wrapped difference and the root-mean-square error $E$ as defined above.\n\nTest suite:\nImplement your program to run the following five cases, each fully specified by a discrete-time duration $T$, time step $dt$, spatial periods $\\boldsymbol{\\lambda}$, a velocity time series specification, and a model coupling matrix to be used in the reduced phase dynamics obtained from the derivation. All angles are in radians; velocities are in $\\mathrm{m/s}$; spatial periods are in $\\mathrm{m}$.\n\n- Case $1$ (general “happy path”):\n  - $T = 10.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.5, 0.5)$.\n  - Velocity: constant $\\mathbf{v}(t) = (0.1, 0.05)$ for all $t \\in [0, T]$.\n  - Model coupling matrix equals the true mapping from velocity to phase rate consistent with $\\boldsymbol{\\lambda}$.\n- Case $2$ (boundary wrapping with high velocity):\n  - $T = 2.0$, $dt = 0.005$, $\\boldsymbol{\\lambda} = (0.25, 0.30)$.\n  - Velocity: constant $\\mathbf{v}(t) = (1.2, -0.8)$ for all $t \\in [0, T]$.\n  - Model coupling matrix equals the true mapping from velocity to phase rate consistent with $\\boldsymbol{\\lambda}$.\n- Case $3$ (gain mismatch):\n  - $T = 10.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.5, 0.5)$.\n  - Velocity: constant $\\mathbf{v}(t) = (0.09, 0.07)$ for all $t \\in [0, T]$.\n  - Model coupling matrix is a scaled version of the true mapping with component-wise scale factors $1.02$ on $x$ and $0.97$ on $y$.\n- Case $4$ (zero velocity edge case):\n  - $T = 3.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.5, 0.5)$.\n  - Velocity: constant $\\mathbf{v}(t) = (0.0, 0.0)$ for all $t \\in [0, T]$.\n  - Model coupling matrix equals the true mapping from velocity to phase rate consistent with $\\boldsymbol{\\lambda}$.\n- Case $5$ (rotational mismatch and sinusoidal velocity):\n  - $T = 8.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.45, 0.60)$.\n  - Velocity: $\\mathbf{v}(t) = \\big(0.4 \\sin(2\\pi \\cdot 0.5 \\, t),\\; 0.3 \\cos(2\\pi \\cdot 0.75 \\, t)\\big)$ for all $t \\in [0, T]$.\n  - Model coupling matrix is a rotated version of the true mapping by angle $\\theta = \\pi/12$ in the output (phase) space.\n\nYour program must:\n- For each case, generate the velocity time series, simulate the phase dynamics on $\\mathbb{T}^2$ using the derived reduced model, compute the “true” phase from displacement and spatial periods, and then compute the root-mean-square geodesic error $E$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places, and no spaces. For example, the output should look like $[\\text{case1},\\text{case2},\\text{case3},\\text{case4},\\text{case5}]$, where each entry is the scalar $E$ for the corresponding case.",
            "solution": "We begin from the continuous attractor neural network (CANN) neural field equation for activity $u(\\mathbf{x}, t)$ defined on $\\mathbb{R}^2$ with spatially translation-invariant recurrent connectivity, a static nonlinearity, and an external input:\n$$\n\\tau \\frac{\\partial u(\\mathbf{x}, t)}{\\partial t} = -u(\\mathbf{x}, t) + \\int_{\\mathbb{R}^2} w(\\mathbf{x} - \\mathbf{x}') \\, \\phi\\big(u(\\mathbf{x}', t)\\big)\\, d\\mathbf{x}' + I(\\mathbf{x}, t),\n$$\nwhere $\\tau$ is a time constant, $w(\\mathbf{x} - \\mathbf{x}')$ is a translation-invariant kernel, $\\phi(\\cdot)$ is a static gain function, and $I(\\mathbf{x}, t)$ is an external input. Under standard assumptions for a grid-cell-like continuous attractor, there exists a stationary bump solution $u_0(\\mathbf{x} - \\boldsymbol{\\theta})$ parameterized by a continuous shift $\\boldsymbol{\\theta} \\in \\mathbb{R}^2$ due to translational symmetry. The presence of a continuous family of solutions implies a pair of neutral (Goldstone) modes associated with infinitesimal translations, given by the spatial derivatives $\\partial u_0 / \\partial x$ and $\\partial u_0 / \\partial y$.\n\nTo obtain the low-dimensional dynamics of the bump center (phase on the torus), we project the full dynamics onto the subspace spanned by these neutral modes. Let the adjoint eigenfunctions associated with the zero eigenvalue be denoted by $\\psi_x(\\mathbf{x})$ and $\\psi_y(\\mathbf{x})$, and consider a perturbation that shifts the bump center. Multiplying the neural field equation by $\\psi_i(\\mathbf{x})$ and integrating over space isolates the contribution that moves the bump:\n$$\n\\frac{d\\theta_i}{dt} = \\kappa_i \\int_{\\mathbb{R}^2} I(\\mathbf{x}, t)\\, \\frac{\\partial u_0(\\mathbf{x} - \\boldsymbol{\\theta})}{\\partial x_i}\\, d\\mathbf{x}, \\quad i \\in \\{x, y\\},\n$$\nwhere $\\kappa_i$ are normalization constants determined by the inner products of the adjoint modes and the derivatives of $u_0$. If the external input encodes physical velocity by coupling to the spatial derivatives of the bump, a widely used formulation is\n$$\nI(\\mathbf{x}, t) = a_x v_x(t)\\, \\frac{\\partial u_0(\\mathbf{x} - \\boldsymbol{\\theta})}{\\partial x} + a_y v_y(t)\\, \\frac{\\partial u_0(\\mathbf{x} - \\boldsymbol{\\theta})}{\\partial y},\n$$\nwhere $a_x$ and $a_y$ are gains along each axis and $\\mathbf{v}(t) = (v_x(t), v_y(t))$ is the physical velocity. Substituting this input and using orthogonality of the modes yields a linear relation between the bump center velocity and the physical velocity:\n$$\n\\frac{d\\boldsymbol{\\theta}}{dt} = \\mathbf{B}\\, \\mathbf{v}(t),\n$$\nwhere $\\mathbf{B} \\in \\mathbb{R}^{2 \\times 2}$ is a coupling matrix determined by the neural field, the choice of gains, and the shape of the bump. Periodic boundary conditions identify the bump position modulo the spatial periods along each axis, yielding a torus $\\mathbb{T}^2$. Each component of displacement $\\theta_i$ is related to a phase $\\phi_i$ by scaling so that a physical displacement by the spatial period $\\lambda_i$ corresponds to a phase advance of $2\\pi$:\n$$\n\\phi_i = \\frac{2\\pi}{\\lambda_i} \\theta_i \\quad \\Rightarrow \\quad \\frac{d\\phi_i}{dt} = \\frac{2\\pi}{\\lambda_i} \\frac{d\\theta_i}{dt} = \\sum_{j \\in \\{x,y\\}} K_{ij}\\, v_j(t),\n$$\nwith\n$$\n\\mathbf{K} = \\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)\\, \\mathbf{B}.\n$$\nFor an ideal integrator that faithfully converts velocity to phase rate consistent with the spatial periods, the “true” mapping between displacement and phase is\n$$\n\\boldsymbol{\\phi}_{\\mathrm{true}}(t) = \\operatorname{wrap}_{2\\pi}\\left(\\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right) \\, \\mathbf{s}(t)\\right),\n$$\nwhere $\\mathbf{s}(t) = \\int_0^t \\mathbf{v}(\\tau)\\, d\\tau$ is the physical displacement and $\\operatorname{wrap}_{2\\pi}(\\cdot)$ wraps each angular component to $[0, 2\\pi)$. The simulated model phase evolves according to\n$$\n\\boldsymbol{\\phi}_{\\mathrm{model}}(t+\\Delta t) = \\operatorname{wrap}_{2\\pi}\\left(\\boldsymbol{\\phi}_{\\mathrm{model}}(t) + \\Delta t \\, \\mathbf{K}_{\\mathrm{model}} \\, \\mathbf{v}(t)\\right),\n$$\nwhere $\\mathbf{K}_{\\mathrm{model}}$ is the coupling matrix obtained from the reduced dynamics (which may differ from the true mapping due to gain or orientation mismatch). Note that the derivation from the CANN establishes the existence of such a linear relation by symmetry and mode projection; the specific values used in the test suite instantiate different regimes (perfect mapping, gain mismatch, rotation mismatch).\n\nTo compare the simulated phase to the “true” phase, we compute the wrapped difference component-wise\n$$\n\\Delta_i(t) = \\operatorname{wrap}_{\\pi}\\left(\\phi_{\\mathrm{model}, i}(t) - \\phi_{\\mathrm{true}, i}(t)\\right),\n$$\nwhere $\\operatorname{wrap}_{\\pi}(\\alpha) = ((\\alpha + \\pi) \\bmod 2\\pi) - \\pi$ maps to $(-\\pi, \\pi]$. The instantaneous geodesic error is\n$$\ne(t) = \\sqrt{\\Delta_x(t)^2 + \\Delta_y(t)^2},\n$$\nand the root-mean-square error is\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} e(t_n)^2},\n$$\nwhich we report as a float rounded to six decimal places.\n\nAlgorithmic design:\n- Discretize time into $N = \\lfloor T / dt \\rfloor$ steps with samples $t_n = n \\cdot dt$ for $n = 0, 1, \\ldots, N-1$.\n- Generate the velocity time series $\\mathbf{v}(t_n)$ according to each case specification.\n- Initialize $\\boldsymbol{\\phi}_{\\mathrm{model}}(0) = (0, 0)$ and $\\mathbf{s}(0) = (0, 0)$.\n- At each time step, update displacement $\\mathbf{s}(t_{n+1}) = \\mathbf{s}(t_n) + dt \\cdot \\mathbf{v}(t_n)$.\n- Compute $\\boldsymbol{\\phi}_{\\mathrm{true}}(t_{n+1})$ by scaling $\\mathbf{s}(t_{n+1})$ to radians with $\\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)$ and wrapping to $[0, 2\\pi)$.\n- Update $\\boldsymbol{\\phi}_{\\mathrm{model}}(t_{n+1})$ by adding $dt \\cdot \\mathbf{K}_{\\mathrm{model}}\\mathbf{v}(t_n)$ to $\\boldsymbol{\\phi}_{\\mathrm{model}}(t_n)$ and wrapping to $[0, 2\\pi)$.\n- Compute wrapped differences $\\Delta_i(t_n)$, instantaneous error $e(t_n)$, and finally $E$ as the root-mean-square over all samples.\n- Repeat for each case using the specified $\\boldsymbol{\\lambda}$ and $\\mathbf{K}_{\\mathrm{model}}$:\n  - For cases with ideal mapping, use $\\mathbf{K}_{\\mathrm{model}} = \\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)$.\n  - For gain mismatch, scale components by the specified factors.\n  - For rotational mismatch, pre-multiply by a rotation matrix\n    $$\n    \\mathbf{R}(\\theta) = \\begin{bmatrix}\n    \\cos \\theta & -\\sin \\theta \\\\\n    \\sin \\theta & \\cos \\theta\n    \\end{bmatrix}\n    $$\n    to obtain $\\mathbf{K}_{\\mathrm{model}} = \\mathbf{R}(\\theta) \\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)$.\n\nNumerical aspects:\n- Wrapping is performed component-wise using modular arithmetic for $[0, 2\\pi)$ and $(-\\pi, \\pi]$.\n- The discretization error is minimized by choosing sufficiently small $dt$ relative to the time scales of the velocity signals.\n- The output is a single line containing $E$ for each case as a comma-separated list enclosed in brackets, with each float rounded to six decimal places and no spaces.\n\nThis design integrates symmetry-based reduction from the CANN and implements a principled comparison between the simulated toroidal phase trajectory and the physically integrated displacement’s corresponding phase.",
            "answer": "```python\nimport numpy as np\n\ndef wrap_to_2pi(angle):\n    # Wrap angles to [0, 2*pi)\n    return (angle % (2.0 * np.pi))\n\ndef wrap_to_pi(angle):\n    # Wrap angles to (-pi, pi]\n    return ((angle + np.pi) % (2.0 * np.pi)) - np.pi\n\ndef simulate_case(T, dt, lam, velocity_fn, K_model):\n    \"\"\"\n    Simulate phase dynamics on T^2 for a given velocity time series and model coupling.\n    Compute RMS geodesic error against true displacement-derived phase.\n\n    Parameters:\n    - T: duration (seconds)\n    - dt: timestep (seconds)\n    - lam: spatial periods (lambda_x, lambda_y) in meters\n    - velocity_fn: function returning velocity array shape (N, 2)\n    - K_model: 2x2 matrix mapping velocity to phase rate (radians per second)\n    \"\"\"\n    N = int(np.round(T / dt))\n    t = np.arange(N) * dt\n    v = velocity_fn(t)  # shape (N,2)\n\n    # True mapping from displacement to phase\n    K_true = np.diag(2.0 * np.pi / np.array(lam))\n\n    # Initialize displacement and phases\n    s = np.zeros(2)              # physical displacement (m)\n    phi_model = np.zeros(2)      # model phase (rad)\n    phi_true = np.zeros(2)       # true phase (rad)\n\n    errors_sq = np.zeros(N)\n\n    for n in range(N):\n        vn = v[n]\n\n        # Update displacement\n        s = s + dt * vn  # integrate velocity\n\n        # True phase from displacement\n        phi_true = wrap_to_2pi(K_true @ s)\n\n        # Model phase update from velocity\n        phi_model = wrap_to_2pi(phi_model + dt * (K_model @ vn))\n\n        # Wrapped difference and instantaneous geodesic error\n        delta = wrap_to_pi(phi_model - phi_true)\n        errors_sq[n] = np.sum(delta**2)\n\n    rms_error = float(np.sqrt(np.mean(errors_sq)))\n    return rms_error\n\ndef velocity_constant_factory(vx, vy):\n    def vfn(t):\n        return np.column_stack((np.full_like(t, vx, dtype=float),\n                                np.full_like(t, vy, dtype=float)))\n    return vfn\n\ndef velocity_sinusoidal_factory(ax, fx, ay, fy):\n    def vfn(t):\n        vx = ax * np.sin(2.0 * np.pi * fx * t)\n        vy = ay * np.cos(2.0 * np.pi * fy * t)\n        return np.column_stack((vx, vy))\n    return vfn\n\ndef solve():\n    # Define test cases as tuples: (T, dt, lambda, velocity_fn, K_model)\n    test_cases = []\n\n    # Case 1: Happy path\n    T1, dt1 = 10.0, 0.01\n    lam1 = (0.5, 0.5)\n    vfn1 = velocity_constant_factory(0.1, 0.05)\n    K_true1 = np.diag(2.0 * np.pi / np.array(lam1))\n    K_model1 = K_true1.copy()\n    test_cases.append((T1, dt1, lam1, vfn1, K_model1))\n\n    # Case 2: High velocity wrapping\n    T2, dt2 = 2.0, 0.005\n    lam2 = (0.25, 0.30)\n    vfn2 = velocity_constant_factory(1.2, -0.8)\n    K_true2 = np.diag(2.0 * np.pi / np.array(lam2))\n    K_model2 = K_true2.copy()\n    test_cases.append((T2, dt2, lam2, vfn2, K_model2))\n\n    # Case 3: Gain mismatch\n    T3, dt3 = 10.0, 0.01\n    lam3 = (0.5, 0.5)\n    vfn3 = velocity_constant_factory(0.09, 0.07)\n    K_true3 = np.diag(2.0 * np.pi / np.array(lam3))\n    scale = np.diag([1.02, 0.97])\n    K_model3 = scale @ K_true3\n    test_cases.append((T3, dt3, lam3, vfn3, K_model3))\n\n    # Case 4: Zero velocity\n    T4, dt4 = 3.0, 0.01\n    lam4 = (0.5, 0.5)\n    vfn4 = velocity_constant_factory(0.0, 0.0)\n    K_true4 = np.diag(2.0 * np.pi / np.array(lam4))\n    K_model4 = K_true4.copy()\n    test_cases.append((T4, dt4, lam4, vfn4, K_model4))\n\n    # Case 5: Rotational mismatch + sinusoidal velocity\n    T5, dt5 = 8.0, 0.01\n    lam5 = (0.45, 0.60)\n    vfn5 = velocity_sinusoidal_factory(ax=0.4, fx=0.5, ay=0.3, fy=0.75)\n    K_true5 = np.diag(2.0 * np.pi / np.array(lam5))\n    theta = np.pi / 12.0\n    R = np.array([[np.cos(theta), -np.sin(theta)],\n                  [np.sin(theta),  np.cos(theta)]])\n    K_model5 = R @ K_true5\n    test_cases.append((T5, dt5, lam5, vfn5, K_model5))\n\n    results = []\n    for (T, dt, lam, vfn, K_model) in test_cases:\n        rms_err = simulate_case(T, dt, lam, vfn, K_model)\n        results.append(f\"{rms_err:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}