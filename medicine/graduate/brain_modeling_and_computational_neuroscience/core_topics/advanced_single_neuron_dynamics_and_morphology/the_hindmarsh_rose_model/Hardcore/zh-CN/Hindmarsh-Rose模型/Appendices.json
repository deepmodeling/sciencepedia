{
    "hands_on_practices": [
        {
            "introduction": "分析任何动力系统的第一步都是理解其平衡点附近的稳定性。雅可比矩阵是进行这种局部线性化分析的关键工具。这项练习旨在构建推导Hindmarsh-Rose模型雅可比矩阵的基础技能，这对于后续所有的稳定性和分岔分析至关重要。",
            "id": "4029005",
            "problem": "考虑三维 Hindmarsh–Rose (HR) 神经元模型，这是一个用于大脑建模和计算神经科学的典范动力系统，以捕捉簇发放和峰发放活动。HR 模型在状态空间上定义了一个光滑向量场，其坐标为 $(x,y,z)$，其中 $x$ 代表膜电位，$y$ 是一个快速恢复变量，$z$ 是一个慢速适应变量。其控制方程为\n$$\\dot{x} = y - a x^{3} + b x^{2} - z,$$\n$$\\dot{y} = c - d x^{2} - y,$$\n$$\\dot{z} = r \\big( s (x - x_{R}) - z \\big),$$\n其中参数 $a$、$b$、$c$、$d$、$r$、$s$ 和 $x_{R}$ 被视为常数。从光滑向量场的雅可比矩阵的基本定义（即方程右侧分量关于状态变量的一阶偏导数矩阵）出发，推导 HR 系统的雅可比矩阵 $J(x,y,z)$。将 $J(x,y,z)$ 显式地写成一个 $3 \\times 3$ 矩阵，其元素仅依赖于参数 $a$、$b$、$c$、$d$、$r$、$s$、$x_{R}$ 以及变量 $x$、$y$、$z$。将最终答案表示为一个单一的闭式矩阵表达式。此符号结果不需要任何数值近似、四舍五入或单位。",
            "solution": "该问题要求推导 Hindmarsh–Rose (HR) 神经元模型的雅可比矩阵。系统的状态由向量 $\\mathbf{x} = (x, y, z)$ 描述，其中 $x$ 是膜电位，$y$ 是一个快速恢复变量，$z$ 是一个慢速适应变量。该动力学由以下三个耦合的一阶常微分方程组控制：\n$$\n\\dot{x} = y - a x^{3} + b x^{2} - z \\\\\n\\dot{y} = c - d x^{2} - y \\\\\n\\dot{z} = r \\big( s (x - x_{R}) - z \\big)\n$$\n该方程组可以写成向量形式 $\\dot{\\mathbf{x}} = \\mathbf{F}(\\mathbf{x})$，其中 $\\mathbf{F}$ 是由以下定义的向量场：\n$$\n\\mathbf{F}(x, y, z) = \\begin{pmatrix} F_{1}(x, y, z) \\\\ F_{2}(x, y, z) \\\\ F_{3}(x, y, z) \\end{pmatrix} = \\begin{pmatrix} y - a x^{3} + b x^{2} - z \\\\ c - d x^{2} - y \\\\ r \\left( s (x - x_{R}) - z \\right) \\end{pmatrix}\n$$\n参数 $a$、$b$、$c$、$d$、$r$、$s$ 和 $x_{R}$ 是常数。\n\n雅可比矩阵，记为 $J(x, y, z)$，是向量场 $\\mathbf{F}$ 的所有一阶偏导数构成的矩阵。对于一个三维系统，其一般形式为：\n$$\nJ(x, y, z) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}} = \\begin{pmatrix}\n\\frac{\\partial F_{1}}{\\partial x}  \\frac{\\partial F_{1}}{\\partial y}  \\frac{\\partial F_{1}}{\\partial z} \\\\\n\\frac{\\partial F_{2}}{\\partial x}  \\frac{\\partial F_{2}}{\\partial y}  \\frac{\\partial F_{2}}{\\partial z} \\\\\n\\frac{\\partial F_{3}}{\\partial x}  \\frac{\\partial F_{3}}{\\partial y}  \\frac{\\partial F_{3}}{\\partial z}\n\\end{pmatrix}\n$$\n我们通过对 $\\mathbf{F}$ 的分量求偏导数来计算雅可比矩阵的九个元素。\n\n对于第一个分量，$F_{1}(x, y, z) = y - a x^{3} + b x^{2} - z$：\n$$\n\\frac{\\partial F_{1}}{\\partial x} = \\frac{\\partial}{\\partial x} (y - a x^{3} + b x^{2} - z) = -3ax^{2} + 2bx\n$$\n$$\n\\frac{\\partial F_{1}}{\\partial y} = \\frac{\\partial}{\\partial y} (y - a x^{3} + b x^{2} - z) = 1\n$$\n$$\n\\frac{\\partial F_{1}}{\\partial z} = \\frac{\\partial}{\\partial z} (y - a x^{3} + b x^{2} - z) = -1\n$$\n这三个表达式构成了雅可比矩阵的第一行。\n\n对于第二个分量，$F_{2}(x, y, z) = c - d x^{2} - y$：\n$$\n\\frac{\\partial F_{2}}{\\partial x} = \\frac{\\partial}{\\partial x} (c - d x^{2} - y) = -2dx\n$$\n$$\n\\frac{\\partial F_{2}}{\\partial y} = \\frac{\\partial}{\\partial y} (c - d x^{2} - y) = -1\n$$\n$$\n\\frac{\\partial F_{2}}{\\partial z} = \\frac{\\partial}{\\partial z} (c - d x^{2} - y) = 0\n$$\n这三个表达式构成了雅可比矩阵的第二行。\n\n对于第三个分量，$F_{3}(x, y, z) = r(s(x - x_{R}) - z) = rsx - rsx_{R} - rz$：\n$$\n\\frac{\\partial F_{3}}{\\partial x} = \\frac{\\partial}{\\partial x} (rsx - rsx_{R} - rz) = rs\n$$\n$$\n\\frac{\\partial F_{3}}{\\partial y} = \\frac{\\partial}{\\partial y} (rsx - rsx_{R} - rz) = 0\n$$\n$$\n\\frac{\\partial F_{3}}{\\partial z} = \\frac{\\partial}{\\partial z} (rsx - rsx_{R} - rz) = -r\n$$\n这三个表达式构成了雅可比矩阵的第三行。\n\n最后，我们将计算出的偏导数代入矩阵结构中，得到雅可比矩阵 $J(x, y, z)$：\n$$\nJ(x, y, z) = \\begin{pmatrix}\n-3ax^{2} + 2bx  1  -1 \\\\\n-2dx  -1  0 \\\\\nrs  0  -r\n\\end{pmatrix}\n$$\n这就是 Hindmarsh–Rose 系统的显式 $3 \\times 3$ 雅可比矩阵，其元素是状态变量 $x$ 和系统参数 $a$、$b$、$d$、$r$ 和 $s$ 的函数。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-3ax^{2} + 2bx  1  -1 \\\\\n-2dx  -1  0 \\\\\nrs  0  -r\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了局部稳定性分析之后，我们现在利用快慢动力学分解来探索Hindmarsh-Rose模型的动态行为。通过将慢变量$z$视为一个参数，我们可以分析负责产生锋电位的二维快子系统。这项计算练习将指导你识别$z$的变化如何导致分岔，从而产生或消失振荡活动，让你直接洞察单个锋电位的生成机制。",
            "id": "4028960",
            "problem": "考虑将慢适应变量视为恒定参数得到的Hindmarsh–Rose模型的二维快速子系统。该快速子系统的状态是数对 $(x(t), y(t))$，其中 $x$ 表示膜电位，$y$ 是一个快速恢复变量。该子系统由以下常微分方程控制\n$$\n\\dot{x} = y - a x^3 + b x^2 + I - z, \\quad \\dot{y} = c - d x^2 - y,\n$$\n其中 $a$、$b$、$c$、$d$、$I$ 是固定参数，$z$ 被视为一个恒定的控制参数。在本问题中，请使用参数值 $a = 1$、$b = 3$、$c = 1$、$d = 5$ 和 $I = 3$，并视所有量为无量纲。自变量 $t$ 是以任意时间常数为单位的无量纲时间，所有报告的频率必须以每单位 $t$ 的周期数表示。\n\n您的任务如下，并且必须纯粹基于平面流动力学系统的第一性原理完成，不得使用任何针对特定分岔的预设快捷公式：\n\n- 使用平衡点（$\\dot{x} = 0$ 和 $\\dot{y} = 0$ 的解）、线性化（平衡点处的雅可比矩阵）和线性稳定性（雅可比矩阵特征值实部的符号）的定义，来确定指定 $z$ 值下的平衡点集及其稳定性。\n- 使用极限环作为平面系统的吸引周期轨道的概念，结合数值积分和后暂态分析，判断系统对于给定的 $z$ 是否表现出稳定的极限环。如果检测到稳定的极限环，通过对 $x(t)$ 连续正斜率过零点之间的事件间时间的平均，来估计其平均振荡频率。事件检测必须在丢弃初始暂态后进行，并且检测阈值必须确保您不会将衰减的暂态振荡误认为稳定的极限环。\n- 使用平面系统中平衡点线性化的霍普夫分岔定义（迹为零，行列式为正，且迹横截穿越），在给定区间内数值定位小幅值-$x$ 平衡点经历霍普夫分岔的参数值 $z$。\n\n请将您的推导基于以下动力学系统理论的基本定义和事实：\n- 平衡点满足 $\\dot{x} = 0$ 和 $\\dot{y} = 0$。\n- 在平衡点 $(x^\\ast, y^\\ast)$ 处的线性化由雅可比矩阵 $J(x^\\ast, y^\\ast)$ 给出，其元素为 $J_{ij} = \\partial f_i / \\partial \\xi_j$，其中矢量场为 $(f_1, f_2) = (\\dot{x}, \\dot{y})$，状态为 $(\\xi_1, \\xi_2) = (x, y)$。\n- 平面平衡点的线性稳定性由雅可比矩阵的迹和行列式决定：两个特征值都具有负实部的充要条件是迹为负且行列式为正。\n- 平面系统中的一般（非退化）霍普夫分岔发生在平衡点处的雅可比矩阵迹为零且行列式为正，并且当参数变化时，迹以非零速度穿越零点。\n- 在具有有界轨道且区域内存在不稳定平衡点的平面系统中，Poincaré–Bendixson定理意味着极限环的存在；在数值上，稳定的极限环可以通过暂态后的轨道持续周期性振荡来检测。\n\n您必须实现一个算法，用于计算在指定的 $z$ 值下，平衡点的数量、线性稳定平衡点的数量、通过带有鲁棒后处理的数值模拟确定的稳定极限环是否存在，以及在稳定极限环存在时的平均振荡频率。使用固定的时间范围 $T = 800$（无量纲时间单位），在事件分析前丢弃时间序列的前半部分，并使用时间步长 $\\Delta t = 0.02$。要从单次模拟中确定稳定极限环的存在，要求在后暂态窗口内 $x(t)$ 至少有 $6$ 次向上过零，并且后暂态振幅 $\\max(x) - \\min(x)$ 至少为 $0.15$。为了在存在共存极限环时增强对稳定平衡点吸引的鲁棒性，每个 $z$ 值需从初始状态 $(x(0), y(0)) = (2, 0)$ 和 $(x(0), y(0)) = (-2, 0)$ 运行两次模拟；如果任一后暂态轨道满足持续振荡标准，则宣布检测到稳定极限环，并使用具有较大后暂态振幅的轨道报告平均振荡频率。\n\n对于给定 $z$ 的平衡点和线性稳定性分析，按以下步骤进行求解\n$$\n\\dot{y} = 0 \\implies y = c - d x^2, \\quad \\dot{x} = 0 \\implies 0 = y - a x^3 + b x^2 + I - z,\n$$\n这些方程共同化简为一个关于 $x$ 的三次方程。确定 $x$ 的所有实数解，然后反代入以获得 $y$，接着使用雅可比矩阵对稳定性进行分类。\n\n为了对与小-$|x|$平衡分支相关的霍普夫分岔进行数值定位，将该平衡点处的雅可比矩阵的迹定义为 $z$ 的函数，并对 $z$ 使用二分法在迹变号的区间内找到迹的零点，同时验证解处的雅可比行列式为正。通过在每个 $z$ 处选择具有最小 $x$ 绝对值的平衡根来跟踪小-$|x|$ 分支，适用时包括 $x = 0$ 的情况。\n\n测试套件和要求的输出：\n- 使用固定参数 $a = 1$、$b = 3$、$c = 1$、$d = 5$、$I = 3$。\n- 对于 $z \\in \\{3.0, 3.8, 4.2\\}$，为每个 $z$ 计算一个形式为 $[N_{\\mathrm{eq}}, N_{\\mathrm{stable}}, \\mathrm{osc}, f]$ 的列表，其中 $N_{\\mathrm{eq}}$ 是平衡点的整数数量，$N_{\\mathrm{stable}}$ 是线性稳定平衡点的整数数量，$\\mathrm{osc}$ 是一个布尔值，指示根据上述数值标准是否存在稳定极限环，$f$ 是当 $\\mathrm{osc}$ 为真时的平均振荡频率（一个浮点数），否则为 $0.0$。将 $f$ 四舍五入到四位小数。\n- 对于小-$|x|$平衡分支，在区间 $[3.5, 4.4]$ 内通过二分法找到霍普夫分岔值 $z_{\\mathrm{H}}$。将 $z_{\\mathrm{H}}$ 作为浮点数返回，并四舍五入到四位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个有四个条目的Python风格列表。前三个条目按 $z$ 值升序对应，且必须是 $[N_{\\mathrm{eq}}, N_{\\mathrm{stable}}, \\mathrm{osc}, f]$ 形式的列表，其中 $f$ 四舍五入到四位小数。第四个条目必须是单个浮点数 $z_{\\mathrm{H}}$，四舍五入到四位小数。例如，一个语法上有效的输出看起来像这样\n$[[2,1,False,0.0000],[1,0,True,0.1532],[3,1,True,0.0975],3.9264]$。",
            "solution": "该问题要求对给定参数集下的Hindmarsh-Rose模型的快速子系统进行全面分析，这是一个二维平面常微分方程（ODE）系统。该分析需基于动力学系统理论的第一性原理进行。任务涉及寻找平衡点及其稳定性，通过数值模拟检测稳定极限环，以及定位霍普夫分岔点。\n\n该系统由以下方程描述：\n$$\n\\dot{x} = y - a x^3 + b x^2 + I - z\n$$\n$$\n\\dot{y} = c - d x^2 - y\n$$\n其中固定参数为 $a = 1$、$b = 3$、$c = 1$、$d = 5$ 和 $I = 3$。参数 $z$ 作为控制参数。所有量均为无量纲。\n\n代入固定参数值后，系统变为：\n$$\n\\dot{x} = y - x^3 + 3 x^2 + 3 - z\n$$\n$$\n\\dot{y} = 1 - 5 x^2 - y\n$$\n\n根据要求，分析分为三个主要部分。\n\n### 第一部分：平衡点与稳定性分析\n\n平衡点 $(x^\\ast, y^\\ast)$ 是系统处于静止状态的点，即 $\\dot{x} = 0$ 且 $\\dot{y} = 0$。\n从 $\\dot{y}$ 的方程中，我们找到y-零斜线：\n$$\n\\dot{y} = 0 \\implies 1 - 5 (x^\\ast)^2 - y^\\ast = 0 \\implies y^\\ast = 1 - 5 (x^\\ast)^2\n$$\n这在 $(x, y)$ 平面中定义了一条抛物线，沿该线轨迹没有垂直运动。\n\n将 $y^\\ast$ 的表达式代入 $\\dot{x} = 0$ 的方程（x-零斜线），得到一个关于平衡点x坐标的方程：\n$$\n(1 - 5 (x^\\ast)^2) - (x^\\ast)^3 + 3 (x^\\ast)^2 + 3 - z = 0\n$$\n整理后得到一个关于 $x^\\ast$ 的三次多项式方程：\n$$\n- (x^\\ast)^3 - 2(x^\\ast)^2 + 4 - z = 0\n$$\n$$\n(x^\\ast)^3 + 2(x^\\ast)^2 + z - 4 = 0\n$$\n对于给定的 $z$ 值，该三次方程的实根提供了所有平衡点的x坐标。不同实根的数量 $N_{\\mathrm{eq}}$ 可以是一、二或三。对于每个实根 $x^\\ast$，对应的 $y^\\ast$ 通过 $y^\\ast = 1 - 5(x^\\ast)^2$ 计算得出。\n\n为了确定每个平衡点 $(x^\\ast, y^\\ast)$ 的线性稳定性，我们通过计算该点处的雅可比矩阵 $J$ 来对系统进行线性化。雅可比矩阵定义为 $J_{ij} = \\partial f_i / \\partial \\xi_j$，其中 $\\vec{f} = (\\dot{x}, \\dot{y})$ 且 $\\vec{\\xi} = (x, y)$。\n$$\nJ(x, y) = \\begin{pmatrix} \\partial \\dot{x} / \\partial x  \\partial \\dot{x} / \\partial y \\\\ \\partial \\dot{y} / \\partial x  \\partial \\dot{y} / \\partial y \\end{pmatrix} = \\begin{pmatrix} -3x^2 + 6x  1 \\\\ -10x  -1 \\end{pmatrix}\n$$\n平衡点的稳定性由 $J(x^\\ast, y^\\ast)$ 的特征值决定。对于二维系统，可以通过雅可比矩阵的迹 $\\mathrm{tr}(J)$ 和行列式 $\\det(J)$ 来评估稳定性。\n$$\n\\mathrm{tr}(J) = (-3(x^\\ast)^2 + 6x^\\ast) - 1 = -3(x^\\ast)^2 + 6x^\\ast - 1\n$$\n$$\n\\mathrm{det}(J) = (-3(x^\\ast)^2 + 6x^\\ast)(-1) - (1)(-10x^\\ast) = 3(x^\\ast)^2 - 6x^\\ast + 10x^\\ast = 3(x^\\ast)^2 + 4x^\\ast\n$$\n一个平衡点是线性稳定的（吸引节点或焦点），当且仅当其两个特征值都具有负实部。此条件等价于 $\\mathrm{tr}(J)  0$ 和 $\\det(J) > 0$。稳定平衡点的数量 $N_{\\mathrm{stable}}$ 通过计算满足这两个条件的已识别平衡点的个数来确定。\n\n对于每个 $z \\in \\{3.0, 3.8, 4.2\\}$，我们数值求解三次方程以获得其实根，找到相应的平衡点，然后计算每个平衡点处雅可比矩阵的迹和行列式，以确定 $N_{\\mathrm{eq}}$ 和 $N_{\\mathrm{stable}}$。\n\n### 第二部分：极限环检测与频率估计\n\n极限环是一条孤立的周期性轨道。稳定的极限环对邻近轨道起到吸引子的作用。Poincaré-Bendixson定理表明，在具有有界轨道和不稳定平衡点（例如，不稳定焦点）的平面系统中，很可能存在极限环。\n\n我们通过在时间范围 $T=800$、时间步长 $\\Delta t = 0.02$ 上对系统方程进行积分来数值检测稳定极限环。四阶龙格-库塔（RK4）方法适用于这种固定步长积分。为鲁棒地探索状态空间，每个 $z$ 值从初始条件 $(x(0), y(0)) = (2, 0)$ 和 $(x(0), y(0)) = (-2, 0)$ 开始运行两次模拟。\n\n模拟之后，我们分析轨道以区分持续振荡（极限环）和导向稳定平衡点的衰减暂态。\n1.  **暂态丢弃**：丢弃模拟数据的前半部分（从 $t=0$ 到 $t=400$），以确保分析在后暂态的渐进行为上进行。\n2.  **持续振荡标准**：如果来自*至少一个*初始条件的后暂态轨道（从 $t=400$ 到 $t=800$）满足两个条件，则认为存在稳定极限环：\n    a.  后暂态振幅 $\\max(x) - \\min(x)$ 必须至少为 $0.15$。\n    b.  膜电位 $x(t)$ 必须至少有 $6$ 次向上过零（即 $x(t)$ 从负值穿越到非负值的事件）。\n3.  **频率计算**：如果检测到稳定极限环，则估计其平均频率 $f$。使用具有较大后暂态振幅的轨道进行此计算。我们使用时间步之间的线性插值来精确识别所有向上过零的时间点 $\\{t_1, t_2, \\dots, t_k\\}$，以确保准确性。事件间间隔为 $\\Delta T_i = t_{i+1} - t_i$。平均周期是这些间隔的平均值，$T_{\\mathrm{mean}} = \\frac{1}{k-1}\\sum_{i=1}^{k-1} \\Delta T_i$。频率则为 $f = 1/T_{\\mathrm{mean}}$。如果未检测到极限环，则将 $f$ 设置为 $0.0$。\n\n该过程为每个测试的 $z$ 值生成一个布尔值 $\\mathrm{osc}$ 和一个频率 $f$。\n\n### 第三部分：霍普夫分岔定位\n\n霍普夫分岔是一种局部-分岔，其中平衡点改变其稳定性，并产生一个小振幅极限环。对于平面系统，当一个平衡点处的雅可比矩阵有一对纯虚特征值时，就会发生一般性的霍普夫分岔。这对应于条件 $\\mathrm{tr}(J)=0$ 和 $\\det(J)>0$。当分岔参数（此处为 $z$）变化时，特征值的实部必须以非零速度穿越零点，如果 $\\frac{d}{dz}(\\mathrm{tr}(J)) \\neq 0$，这一点可以得到保证。\n\n我们被要求找到“小-$|x|$分支”上的平衡点经历霍普夫分岔时的值 $z_{\\mathrm{H}}$。小-$|x|$平衡点定义为三次方程 $(x^\\ast)^3 + 2(x^\\ast)^2 + z - 4 = 0$ 中绝对值最小的根 $x^\\ast$。\n\n我们需要找到满足 $\\mathrm{tr}(J(x^\\ast(z))) = 0$ 的 $z$。我们定义一个函数 $g(z) = \\mathrm{tr}(J(x^\\ast(z))) = -3(x^\\ast(z))^2 + 6x^\\ast(z) - 1$。\n问题指定使用二分法在区间 $[3.5, 4.4]$ 内找到 $g(z)=0$ 的根。算法如下：\n1.  定义函数 $g(z)$，该函数首先找到对应 $z$ 的三次方程的实根，选择绝对值最小的根 $x^\\ast$，然后返回迹的值 $-3(x^\\ast)^2 + 6x^\\ast - 1$。\n2.  验证 $g(3.5)$ 和 $g(4.4)$ 符号相反，以确认区间内存在根。\n3.  迭代应用二分算法，缩小包含 $z_{\\mathrm{H}}$ 的区间，直到达到所需的精度。\n4.  在找到的值 $z_{\\mathrm{H}}$ 处，我们还要确认在相应的平衡点 $x^\\ast(z_{\\mathrm{H}})$ 上 $\\det(J) = 3(x^\\ast)^2 + 4x^\\ast > 0$，从而满足霍普夫分岔的完整条件。\n\n通过实现这三个部分，我们可以为指定的测试套件生成所需的输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Hindmarsh-Rose model analysis problem as specified.\n    \"\"\"\n    \n    # Fixed parameters\n    a, b, c, d, I = 1, 3, 1, 5, 3\n    params = {'a': a, 'b': b, 'c': c, 'd': d, 'I': I}\n\n    # --- Helper functions ---\n\n    def get_system_rhs(z_val, p):\n        \"\"\"Returns the RHS function of the ODE system for a given z.\"\"\"\n        def rhs(t, y):\n            x, y_var = y\n            dxdt = y_var - p['a'] * x**3 + p['b'] * x**2 + p['I'] - z_val\n            dydt = p['c'] - p['d'] * x**2 - y_var\n            return np.array([dxdt, dydt])\n        return rhs\n\n    def find_equilibria(z_val, p):\n        \"\"\"Finds equilibrium points (x*, y*) for a given z.\"\"\"\n        # Cubic equation for x*: x^3 + 2x^2 + z - 4 = 0\n        cubic_coeffs = [1, 2, 0, z_val - 4]\n        \n        roots = np.roots(cubic_coeffs)\n        real_roots_x = [r.real for r in roots if np.isclose(r.imag, 0)]\n        \n        equilibria = []\n        for x_star in sorted(real_roots_x):\n            y_star = p['c'] - p['d'] * x_star**2\n            equilibria.append((x_star, y_star))\n        return equilibria\n\n    def analyze_stability(equilibria, p):\n        \"\"\"Analyzes stability of equilibria and returns counts.\"\"\"\n        if not equilibria:\n            return 0, 0\n            \n        n_eq = len(equilibria)\n        n_stable = 0\n        for x_star, y_star in equilibria:\n            # Jacobian: J = [[-3x^2+6x, 1], [-10x, -1]]\n            tr_J = -3 * x_star**2 + 6 * x_star - 1\n            det_J = 3 * x_star**2 + 4 * x_star\n            \n            if tr_J  0 and det_J > 0:\n                n_stable += 1\n        return n_eq, n_stable\n\n    def run_simulation(z_val, p, ic_list, T, dt):\n        \"\"\"\n        Runs numerical simulation from given initial conditions.\n        Uses a fixed-step 4th-order Runge-Kutta integrator.\n        \"\"\"\n        rhs = get_system_rhs(z_val, p)\n        num_steps = int(T / dt)\n        t_span = np.linspace(0, T, num_steps + 1)\n        \n        trajectories = []\n        for ic in ic_list:\n            y = np.array(ic)\n            history = np.zeros((len(t_span), len(y)))\n            history[0, :] = y\n            \n            for i in range(num_steps):\n                t = t_span[i]\n                k1 = rhs(t, y)\n                k2 = rhs(t + dt/2, y + dt/2 * k1)\n                k3 = rhs(t + dt/2, y + dt/2 * k2)\n                k4 = rhs(t + dt, y + dt * k3)\n                y = y + dt/6 * (k1 + 2*k2 + 2*k3 + k4)\n                history[i+1, :] = y\n            trajectories.append((t_span, history))\n        return trajectories\n\n    def analyze_limit_cycle(trajectories, T, dt):\n        \"\"\"Analyzes trajectories for stable limit cycles.\"\"\"\n        transient_idx = int((T / 2) / dt)\n        \n        osc_detected = False\n        best_freq = 0.0\n        max_amp = -1.0\n\n        for t, traj in trajectories:\n            x_post = traj[transient_idx:, 0]\n            t_post = t[transient_idx:]\n            \n            amplitude = np.max(x_post) - np.min(x_post)\n            \n            # Find upward zero-crossings\n            crossings = np.where((x_post[:-1]  0)  (x_post[1:] >= 0))[0]\n            num_crossings = len(crossings)\n\n            if amplitude >= 0.15 and num_crossings >= 6:\n                osc_detected = True\n                \n                # Use linear interpolation for accurate crossing times\n                crossing_times = []\n                for i in crossings:\n                    t0, x0 = t_post[i], x_post[i]\n                    t1, x1 = t_post[i+1], x_post[i+1]\n                    t_cross = t0 + (0 - x0) * (t1 - t0) / (x1 - x0)\n                    crossing_times.append(t_cross)\n                \n                if len(crossing_times) > 1:\n                    periods = np.diff(crossing_times)\n                    mean_period = np.mean(periods)\n                    freq = 1.0 / mean_period if mean_period > 0 else 0.0\n\n                    # Keep frequency from trajectory with larger amplitude\n                    if amplitude > max_amp:\n                        max_amp = amplitude\n                        best_freq = freq\n            \n        return osc_detected, best_freq\n\n    def find_hopf_bifurcation(bracket, p, tol=1e-5):\n        \"\"\"Finds the Hopf bifurcation point z_H using bisection.\"\"\"\n        def get_trace_at_smallest_x_root(z_val):\n            # Same cubic as in find_equilibria\n            cubic_coeffs = [1, 2, 0, z_val - 4]\n            roots = np.roots(cubic_coeffs)\n            real_roots_x = [r.real for r in roots if np.isclose(r.imag, 0)]\n            \n            if not real_roots_x:\n                return None\n            \n            # Select root with smallest absolute value\n            x_star = min(real_roots_x, key=abs)\n            \n            # Calculate trace\n            tr_J = -3 * x_star**2 + 6 * x_star - 1\n            return tr_J, x_star\n\n        z_a, z_b = bracket\n        trace_a, _ = get_trace_at_smallest_x_root(z_a)\n        trace_b, _ = get_trace_at_smallest_x_root(z_b)\n\n        if trace_a * trace_b >= 0:\n            return None\n\n        while (z_b - z_a) / 2.0 > tol:\n            z_mid = (z_a + z_b) / 2.0\n            trace_mid, _ = get_trace_at_smallest_x_root(z_mid)\n            if trace_mid == 0:\n                return z_mid\n            elif trace_a * trace_mid  0:\n                z_b = z_mid\n            else:\n                z_a = z_mid\n        \n        z_H = (z_a + z_b) / 2.0\n        \n        # Final check for det(J) > 0\n        _, x_star_H = get_trace_at_smallest_x_root(z_H)\n        det_J = 3 * x_star_H**2 + 4 * x_star_H\n        if det_J = 0:\n            return None\n\n        return z_H\n\n    # --- Main Calculation ---\n\n    z_values = [3.0, 3.8, 4.2]\n    all_results = []\n\n    # Simulation parameters\n    T_sim = 800.0\n    dt_sim = 0.02\n    ics = [(2.0, 0.0), (-2.0, 0.0)]\n\n    for z in z_values:\n        # Task 1: Equilibria and stability\n        equilibria = find_equilibria(z, params)\n        N_eq, N_stable = analyze_stability(equilibria, params)\n        \n        # Task 2: Limit cycle detection\n        trajectories = run_simulation(z, params, ics, T_sim, dt_sim)\n        osc, f = analyze_limit_cycle(trajectories, T_sim, dt_sim)\n        \n        all_results.append([N_eq, N_stable, osc, round(f, 4)])\n        \n    # Task 3: Hopf bifurcation\n    z_H_bracket = [3.5, 4.4]\n    z_H = find_hopf_bifurcation(z_H_bracket, params)\n    all_results.append(round(z_H, 4))\n    \n    # Format for printing\n    # Example format: [[2,1,False,0.0000],[1,0,True,0.1532],[3,1,True,0.0975],3.9264]\n    print(all_results)\n```"
        },
        {
            "introduction": "基于对快子系统的分析，我们现在研究完整的三维Hindmarsh-Rose模型，以理解它如何生成复杂的簇发放模式。这项练习通过模拟一个缓慢变化的输入电流来揭示模型的迟滞现象，这是一个关键现象，其中静息态和锋电位发放态之间的转换依赖于输入的历史。量化这个迟滞回线可以让你更深入地理解定义簇发放的快锋电位和慢适应之间的相互作用。",
            "id": "4028937",
            "problem": "考虑一个由三个耦合常微分方程（ODEs）系统描述的簇状放电神经元的 Hindmarsh–Rose 模型：$$\\frac{dx}{dt} = y - a x^3 + b x^2 - z + I(t),\\quad \\frac{dy}{dt} = c - d x^2 - y,\\quad \\frac{dz}{dt} = r \\left(s \\left(x - x_R\\right) - z\\right),$$ 其中 $x$ 是膜电位，$y$ 是一个快速恢复变量，$z$ 是一个慢速适应变量，$I(t)$ 是一个随时间变化的外部电流。常数 $a$、$b$、$c$ 和 $d$ 描述了快子系统的非线性，并被设置为 $a=1$、$b=3$、$c=1$、$d=5$。参数 $(r, s, x_R)$ 控制慢速适应动力学以及其与快子系统的耦合。外部电流 $I(t)$ 将被指定为一个确定性的斜坡函数。\n\n从快慢动力系统及其静息与强直放电模式之间由分岔引起的转换的核心定义出发，设计并实现一个基于原理的计算程序，以证明 $I$ 的变化可以在簇状放电的起始和终止中引发迟滞现象，并量化由此产生的迟滞回线的宽度作为 $(r, s, x_R)$ 的函数。迟滞宽度定义为差值 $\\Delta I = I_{\\mathrm{on}} - I_{\\mathrm{off}}$，其中 $I_{\\mathrm{on}}$ 是当 $I$ 从一个下界准静态增加时，强直放电首次持续性起始时的 $I$ 值；$I_{\\mathrm{off}}$ 是当 $I$ 从一个上界准静态减小时，强直放电终止时的 $I$ 值。本问题中所有量均为无量纲；请用与 $I$ 相同的无量纲单位表示最终的迟滞宽度。\n\n您的程序必须遵循以下科学上真实且可测试的规范：\n\n1. 使用定步长显式四阶龙格-库塔方法实现这些常微分方程。使用均匀时间步长 $dt = 0.05$。\n2. 使用以下外部电流协议：定义一个在时长 $T_{\\uparrow}$ 内从 $I_{\\min}$ 到 $I_{\\max}$ 的上升斜坡，紧接着一个在时长 $T_{\\downarrow}$ 内从 $I_{\\max}$ 回到 $I_{\\min}$ 的下降斜坡。使用 $I_{\\min} = 1.0$，$I_{\\max} = 3.5$，$T_{\\uparrow} = 2000$ 和 $T_{\\downarrow} = 2000$。因此，$I(t)$ 相对于 $t$ 是分段线性的：对于 $0 \\le t \\le T_{\\uparrow}$，$$I(t) = I_{\\min} + \\frac{I_{\\max} - I_{\\min}}{T_{\\uparrow}}\\, t,$$ 对于 $T_{\\uparrow} \\le t \\le T_{\\uparrow} + T_{\\downarrow}$，$$I(t) = I_{\\max} - \\frac{I_{\\max} - I_{\\min}}{T_{\\downarrow}}\\, \\left(t - T_{\\uparrow}\\right).$$\n3. 在静息条件下初始化状态：使用 $x(0) = -1.0$，$y(0) = -10.0$，$z(0) = 1.0$。\n4. 在积分过程中，基于 $x$ 对固定阈值 $x_{\\mathrm{thr}} = 0.0$ 的向上穿越来稳健地检测强直放电。通过计算 $x$ 从低于 $x_{\\mathrm{thr}}$ 穿越到高于 $x_{\\mathrm{thr}}$ 的次数来统计脉冲。维持一个长度为 $W = 200$ 的滑动时间窗，并将瞬时脉冲计数 $N_W(t)$ 定义为时间戳在 $[t - W, t]$ 内的向上穿越次数。如果 $N_W(t) \\ge N_{\\min}$（其中 $N_{\\min} = 4$），则声明系统在时间 $t$ 处于强直放电模式。否则，模型被声明为处于静息状态。\n5. 将 $I_{\\mathrm{on}}$ 定义为在上升斜坡阶段，首次检测到强直放电模式的时间 $t$ 处的 $I(t)$ 值；将 $I_{\\mathrm{off}}$ 定义为在下降斜坡阶段，在至少被检测到一次强直放电模式后，首次不再检测到该模式的时间 $t$ 处的 $I(t)$ 值。如果在指定范围内未检测到起始或终止，则该情况下的迟滞宽度设为 $0.0$。\n6. 对于下面测试套件中的每个参数集，计算迟滞宽度 $\\Delta I = \\max\\left(0,\\, I_{\\mathrm{on}} - I_{\\mathrm{off}}\\right)$。报告每个宽度，四舍五入到六位小数。\n\n测试套件和覆盖范围：\n\n- 情况 A（一般簇状放电模式）：$(r, s, x_R) = (0.003, 4.0, -1.6)$。\n- 情况 B（较慢适应边界）：$(r, s, x_R) = (0.001, 4.0, -1.6)$。\n- 情况 C（较快适应，减小的迟滞）：$(r, s, x_R) = (0.020, 4.0, -1.6)$。\n- 情况 D（改变的慢耦合和反转电位）：$(r, s, x_R) = (0.005, 3.0, -1.8)$。\n\n您的程序应生成单行输出，其中包含按顺序排列的案例 A–D 的迟滞宽度，形式为方括号内以逗号分隔的列表，例如 $[\\Delta I_A,\\Delta I_B,\\Delta I_C,\\Delta I_D]$。输出必须是单行，无任何附加文本。所有值都是与 $I$ 具有相同无量纲单位的浮点数，每个值都四舍五入到六位小数。",
            "solution": "该问题是适定的、有科学依据且计算上可验证的。它描述了计算神经科学中的一个标准数值实验，用于研究 Hindmarsh–Rose 模型（一个典型的快慢动力系统）中的迟滞现象。所有参数、初始条件和程序步骤都得到了明确的规定，从而能够得到唯一且可复现的解。\n\n问题的核心在于模拟 Hindmarsh–Rose 模型，该模型由以下耦合常微分方程（ODE）系统描述：\n$$\n\\frac{dx}{dt} = y - a x^3 + b x^2 - z + I(t) \\\\\n\\frac{dy}{dt} = c - d x^2 - y \\\\\n\\frac{dz}{dt} = r \\left(s \\left(x - x_R\\right) - z\\right)\n$$\n在这里，$x(t)$ 代表神经元的膜电位，$y(t)$ 是与离子通道门控相关的快速恢复变量，$z(t)$ 是一个慢速适应变量，通常代表细胞内钙离子浓度或慢通道动力学的动态过程。变量 $x$ 和 $y$ 构成快子系统，而 $z$ 是慢变量，因为它的变化速率由小参数 $r$ 控制。外部输入是一个随时间变化的电流 $I(t)$。\n\n问题为快子系统指定了固定参数：$a=1$，$b=3$，$c=1$ 和 $d=5$。慢变量的动力学由参数集 $(r, s, x_R)$ 控制，该参数集将在不同测试案例中变化。\n\n所要展示的科学原理是迟滞现象，这是由一个缓慢变化的参数控制的、具有多个稳定状态（多稳态）的系统的共同特征。在此模型中，对于给定的慢变量 $z$ 值，快子系统可以表现出稳定不动点（静息状态）或稳定极限环（强直放电），具体取决于控制参数 $I$ 的值。当 $I$ 缓慢变化时，系统在临界分岔点在这两种状态之间转换。由于 $z$ 的慢动力学特性，当 $I$ 向上斜坡增加时所经过的路径与向下斜坡减少时所经过的路径不同。从静息到放电的转换发生在比从放电回到静息的转换（$I_{\\mathrm{off}}$）更高的 $I$ 值（$I_{\\mathrm{on}}$）处。这个差值 $\\Delta I = I_{\\mathrm{on}} - I_{\\mathrm{off}}$ 就是迟滞回线的宽度。\n\n量化此现象的计算步骤如下：\n\n1.  **数值积分**：使用显式四阶龙格-库塔（RK4）方法对常微分方程系统进行数值积分。对于非刚性常微分方程，此方法在精度和计算成本之间取得了很好的平衡。使用固定时间步长 $dt = 0.05$。系统在时间 $t$ 的状态是向量 $\\mathbf{v}(t) = [x(t), y(t), z(t)]^T$。从时间 $t_n$ 推进到 $t_{n+1} = t_n + dt$ 的一个 RK4 步骤由以下公式给出：\n    $$\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{dt}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    $$\n    其中增量 $\\mathbf{k}_i$ 是：\n    $$\n    \\mathbf{k}_1 = f(t_n, \\mathbf{v}_n) \\\\\n    \\mathbf{k}_2 = f(t_n + \\frac{dt}{2}, \\mathbf{v}_n + \\frac{dt}{2}\\mathbf{k}_1) \\\\\n    \\mathbf{k}_3 = f(t_n + \\frac{dt}{2}, \\mathbf{v}_n + \\frac{dt}{2}\\mathbf{k}_2) \\\\\n    \\mathbf{k}_4 = f(t_n + dt, \\mathbf{v}_n + dt\\mathbf{k}_3)\n    $$\n    其中 $f(t, \\mathbf{v})$ 是由 Hindmarsh–Rose 方程右侧定义的向量场。系统在 $x(0) = -1.0$，$y(0) = -10.0$ 和 $z(0) = 1.0$ 处初始化。\n\n2.  **输入电流协议**：施加一个分段线性电流斜坡 $I(t)$ 以缓慢驱动系统。\n    -   对于上升斜坡（$0 \\le t \\le T_{\\uparrow}$），$I(t) = I_{\\min} + \\frac{I_{\\max} - I_{\\min}}{T_{\\uparrow}} t$。\n    -   对于下降斜坡（$T_{\\uparrow}  t \\le T_{\\uparrow} + T_{\\downarrow}$），$I(t) = I_{\\max} - \\frac{I_{\\max} - I_{\\min}}{T_{\\downarrow}} (t - T_{\\uparrow})$。\n    参数设置为 $I_{\\min} = 1.0$，$I_{\\max} = 3.5$，以及 $T_{\\uparrow} = T_{\\downarrow} = 2000$。这种缓慢变化对于观察迟滞回线至关重要；它近似于分岔参数 $I$ 的准静态变化。\n\n3.  **脉冲和状态检测**：系统的状态（静息 vs. 强直放电）通过算法确定。\n    -   每当膜电位 $x(t)$ 向上穿越阈值 $x_{\\mathrm{thr}} = 0.0$ 时，就记录一个动作电位（脉冲）。\n    -   如果在一个持续时间为 $W = 200$ 的滑动历史窗口内（即在区间 $[t-W, t]$ 内）的脉冲计数 $N_W(t)$ 至少为 $N_{\\min} = 4$，则定义系统在时间 $t$ 处于强直放电模式。这个条件确保了瞬态放电被忽略，只有持续的高频放电才被归类为强直放电状态。\n\n4.  **迟滞测量**：在模拟过程中记录临界电流值 $I_{\\mathrm{on}}$ 和 $I_{\\mathrm{off}}$。\n    -   $I_{\\mathrm{on}}$ 是在上升斜坡期间，$t \\le T_{\\uparrow}$，首次满足强直放电条件 $N_W(t) \\ge N_{\\min}$ 时刻的 $I(t)$ 值。\n    -   $I_{\\mathrm{off}}$ 是在下降斜坡期间，$t > T_{\\uparrow}$，系统从强直放电状态转换出来（即 $N_W(t)  N_{\\min}$）的第一个时刻的 $I(t)$ 值，前提是它在模拟过程中至少进入过一次此状态。\n    -   然后，迟滞宽度计算为 $\\Delta I = \\max(0.0, I_{\\mathrm{on}} - I_{\\mathrm{off}})$。如果根据协议未能检测到 $I_{\\mathrm{on}}$ 或 $I_{\\mathrm{off}}$，则 $\\Delta I$ 取为 $0.0$。\n\n该程序被系统地应用于每个提供的参数集 $(r, s, x_R)$，以计算相应的迟滞宽度。实现将精确遵循这些步骤，以生成所需的数值结果。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Computes the hysteresis width for the Hindmarsh-Rose model under a ramp\n    current stimulus for several parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.003, 4.0, -1.6),  # Case A\n        (0.001, 4.0, -1.6),  # Case B\n        (0.020, 4.0, -1.6),  # Case C\n        (0.005, 3.0, -1.8),  # Case D\n    ]\n\n    # --- Fixed parameters and simulation settings ---\n    # Model parameters\n    a = 1.0\n    b = 3.0\n    c = 1.0\n    d = 5.0\n    \n    # Current protocol parameters\n    I_min = 1.0\n    I_max = 3.5\n    T_up = 2000.0\n    T_down = 2000.0\n    \n    # Simulation parameters\n    dt = 0.05\n    x0 = -1.0\n    y0 = -10.0\n    z0 = 1.0\n    \n    # State detection parameters\n    x_thr = 0.0\n    W = 200.0\n    N_min = 4\n\n    results = []\n\n    for case in test_cases:\n        r, s, x_R = case\n        \n        # Combine all dynamic parameters for clarity\n        model_params = (a, b, c, d, r, s, x_R)\n\n        # --- Helper functions for the simulation ---\n        def get_current(t):\n            if 0.0 = t = T_up:\n                return I_min + (I_max - I_min) / T_up * t\n            elif T_up  t = T_up + T_down:\n                return I_max - (I_max - I_min) / T_down * (t - T_up)\n            return I_min\n\n        def hr_ode(t, state, params):\n            x, y, z = state\n            _a, _b, _c, _d, _r, _s, _x_R = params\n            I_t = get_current(t)\n            \n            dx_dt = y - _a * x**3 + _b * x**2 - z + I_t\n            dy_dt = _c - _d * x**2 - y\n            dz_dt = _r * (_s * (x - _x_R) - z)\n            \n            return np.array([dx_dt, dy_dt, dz_dt])\n\n        def rk4_step(t, state, params, step_dt):\n            k1 = hr_ode(t, state, params)\n            k2 = hr_ode(t + step_dt / 2.0, state + step_dt / 2.0 * k1, params)\n            k3 = hr_ode(t + step_dt / 2.0, state + step_dt / 2.0 * k2, params)\n            k4 = hr_ode(t + step_dt, state + step_dt * k3, params)\n            \n            return state + step_dt / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n        # --- Simulation and Hysteresis Measurement ---\n        state = np.array([x0, y0, z0])\n        x_prev = x0\n        \n        t = 0.0\n        total_time = T_up + T_down\n        \n        spike_times = deque()\n        system_state = \"RESTING\" # Can be RESTING, SPIKING, REST_AGAIN\n        \n        I_on = None\n        I_off = None\n        \n        num_steps = int(total_time / dt)\n\n        for step in range(num_steps + 1):\n            t = step * dt\n            \n            # Integrate one step\n            state = rk4_step(t, state, model_params, dt)\n            x, y, z = state\n            \n            # Spike detection (upward crossing)\n            if x_prev  x_thr and x >= x_thr:\n                spike_times.append(t)\n            x_prev = x # Update for next iteration\n            \n            # Maintain sliding window of spike times\n            while spike_times and spike_times[0]  t - W:\n                spike_times.popleft()\n            \n            # Determine if the system is in the tonic spiking regime\n            is_spiking_now = len(spike_times) >= N_min\n            \n            # Hysteresis detection logic\n            # Up-ramp phase\n            if t = T_up:\n                if system_state == \"RESTING\" and is_spiking_now:\n                    I_on = get_current(t)\n                    system_state = \"SPIKING\"\n            # Down-ramp phase\n            else:\n                if system_state == \"SPIKING\" and not is_spiking_now:\n                    I_off = get_current(t)\n                    system_state = \"REST_AGAIN\"\n\n        # Calculate hysteresis width\n        if I_on is not None and I_off is not None:\n            delta_I = max(0.0, I_on - I_off)\n        else:\n            delta_I = 0.0\n        \n        results.append(delta_I)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{val:.6f}' for val in results])}]\")\n\nsolve()\n```"
        }
    ]
}