{
    "hands_on_practices": [
        {
            "introduction": "The Jacobian matrix is the cornerstone of local stability analysis for any dynamical system, providing a first-order approximation of its behavior near a fixed point. This exercise provides practice in deriving the Jacobian for the Hindmarsh-Rose model, a foundational skill required for exploring its stability and bifurcation structure. ",
            "id": "4029005",
            "problem": "Consider the three-dimensional Hindmarsh–Rose (HR) neuron model, a canonical dynamical system used in brain modeling and computational neuroscience to capture bursting and spiking activity. The HR model defines a smooth vector field on the state space with coordinates $(x,y,z)$, where $x$ represents the membrane potential, $y$ is a fast recovery variable, and $z$ is a slow adaptation variable. The governing equations are\n$$\n\\begin{aligned}\n\\dot{x} = y - a x^{3} + b x^{2} - z, \\\\\n\\dot{y} = c - d x^{2} - y, \\\\\n\\dot{z} = r \\big( s (x - x_{R}) - z \\big).\n\\end{aligned}\n$$\nwith parameters $a$, $b$, $c$, $d$, $r$, $s$, and $x_{R}$ treated as constants. Starting from the fundamental definition of the Jacobian of a smooth vector field as the matrix of first-order partial derivatives of the right-hand-side components with respect to the state variables, derive the Jacobian $J(x,y,z)$ of the HR system. Write $J(x,y,z)$ explicitly as a $3 \\times 3$ matrix whose entries depend only on $a$, $b$, $c$, $d$, $r$, $s$, $x_{R}$ and the variables $x$, $y$, $z$. Express your final answer as a single closed-form matrix expression. No numerical approximation, rounding, or units are required for this symbolic result.",
            "solution": "The problem requires the derivation of the Jacobian matrix for the Hindmarsh–Rose (HR) neuron model. The state of the system is described by the vector $\\mathbf{x} = (x, y, z)$, where $x$ is the membrane potential, $y$ is a fast recovery variable, and $z$ is a slow adaptation variable. The dynamics are governed by a system of three coupled first-order ordinary differential equations:\n$$\n\\dot{x} = y - a x^{3} + b x^{2} - z \\\\\n\\dot{y} = c - d x^{2} - y \\\\\n\\dot{z} = r \\big( s (x - x_{R}) - z \\big)\n$$\nThis system can be written in vector form as $\\dot{\\mathbf{x}} = \\mathbf{F}(\\mathbf{x})$, where $\\mathbf{F}$ is the vector field defined by:\n$$\n\\mathbf{F}(x, y, z) = \\begin{pmatrix} F_{1}(x, y, z) \\\\ F_{2}(x, y, z) \\\\ F_{3}(x, y, z) \\end{pmatrix} = \\begin{pmatrix} y - a x^{3} + b x^{2} - z \\\\ c - d x^{2} - y \\\\ r \\left( s (x - x_{R}) - z \\right) \\end{pmatrix}\n$$\nThe parameters $a$, $b$, $c$, $d$, $r$, $s$, and $x_{R}$ are constants.\n\nThe Jacobian matrix, denoted by $J(x, y, z)$, is the matrix of all first-order partial derivatives of the vector field $\\mathbf{F}$. For a three-dimensional system, its general form is:\n$$\nJ(x, y, z) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}} = \\begin{pmatrix}\n\\frac{\\partial F_{1}}{\\partial x}  \\frac{\\partial F_{1}}{\\partial y}  \\frac{\\partial F_{1}}{\\partial z} \\\\\n\\frac{\\partial F_{2}}{\\partial x}  \\frac{\\partial F_{2}}{\\partial y}  \\frac{\\partial F_{2}}{\\partial z} \\\\\n\\frac{\\partial F_{3}}{\\partial x}  \\frac{\\partial F_{3}}{\\partial y}  \\frac{\\partial F_{3}}{\\partial z}\n\\end{pmatrix}\n$$\nWe proceed to calculate each of the nine entries of the Jacobian matrix by taking the partial derivatives of the components of $\\mathbf{F}$.\n\nFor the first component, $F_{1}(x, y, z) = y - a x^{3} + b x^{2} - z$:\n$$\n\\frac{\\partial F_{1}}{\\partial x} = \\frac{\\partial}{\\partial x} (y - a x^{3} + b x^{2} - z) = -3ax^{2} + 2bx\n$$\n$$\n\\frac{\\partial F_{1}}{\\partial y} = \\frac{\\partial}{\\partial y} (y - a x^{3} + b x^{2} - z) = 1\n$$\n$$\n\\frac{\\partial F_{1}}{\\partial z} = \\frac{\\partial}{\\partial z} (y - a x^{3} + b x^{2} - z) = -1\n$$\nThese three expressions form the first row of the Jacobian matrix.\n\nFor the second component, $F_{2}(x, y, z) = c - d x^{2} - y$:\n$$\n\\frac{\\partial F_{2}}{\\partial x} = \\frac{\\partial}{\\partial x} (c - d x^{2} - y) = -2dx\n$$\n$$\n\\frac{\\partial F_{2}}{\\partial y} = \\frac{\\partial}{\\partial y} (c - d x^{2} - y) = -1\n$$\n$$\n\\frac{\\partial F_{2}}{\\partial z} = \\frac{\\partial}{\\partial z} (c - d x^{2} - y) = 0\n$$\nThese three expressions form the second row of the Jacobian matrix.\n\nFor the third component, $F_{3}(x, y, z) = r(s(x - x_{R}) - z) = rsx - rsx_{R} - rz$:\n$$\n\\frac{\\partial F_{3}}{\\partial x} = \\frac{\\partial}{\\partial x} (rsx - rsx_{R} - rz) = rs\n$$\n$$\n\\frac{\\partial F_{3}}{\\partial y} = \\frac{\\partial}{\\partial y} (rsx - rsx_{R} - rz) = 0\n$$\n$$\n\\frac{\\partial F_{3}}{\\partial z} = \\frac{\\partial}{\\partial z} (rsx - rsx_{R} - rz) = -r\n$$\nThese three expressions form the third row of the Jacobian matrix.\n\nFinally, we assemble the Jacobian matrix $J(x, y, z)$ by substituting the calculated partial derivatives into the matrix structure:\n$$\nJ(x, y, z) = \\begin{pmatrix}\n-3ax^{2} + 2bx  1  -1 \\\\\n-2dx  -1  0 \\\\\nrs  0  -r\n\\end{pmatrix}\n$$\nThis is the explicit $3 \\times 3$ Jacobian matrix of the Hindmarsh–Rose system, with its entries being functions of the state variable $x$ and the system parameters $a$, $b$, $d$, $r$, and $s$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-3ax^{2} + 2bx  1  -1 \\\\\n-2dx  -1  0 \\\\\nrs  0  -r\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The Hindmarsh-Rose model's rich dynamics arise from the interplay between its fast and slow variables. A powerful technique for understanding such systems is fast-slow analysis, where we treat the slow variable as a fixed parameter and study the resulting fast subsystem. In this computational practice, you will explore how the fast subsystem transitions between a resting state and tonic spiking, uncovering the core mechanism of spike generation through the lens of bifurcation theory. ",
            "id": "4028960",
            "problem": "Consider the two-dimensional fast subsystem of the Hindmarsh–Rose model obtained by treating the slow adaptation variable as a constant parameter. The fast subsystem state is the pair $(x(t), y(t))$, where $x$ denotes the membrane potential and $y$ is a fast recovery variable. The subsystem is governed by the ordinary differential equations\n$$\n\\dot{x} = y - a x^3 + b x^2 + I - z, \\quad \\dot{y} = c - d x^2 - y,\n$$\nwhere $a$, $b$, $c$, $d$, $I$ are fixed parameters, and $z$ is treated as a constant control parameter. For the purposes of this problem, use the parameter values $a = 1$, $b = 3$, $c = 1$, $d = 5$, and $I = 3$, with all quantities considered dimensionless. The independent variable $t$ is a dimensionless time in units of an arbitrary time constant, and all reported frequencies must be expressed in cycles per unit $t$.\n\nYour tasks are as follows, and must be completed purely from first principles of dynamical systems for planar flows, without using any pre-supplied shortcut formulas for specific bifurcations:\n\n- Use the definitions of equilibrium points (solutions of $\\dot{x} = 0$ and $\\dot{y} = 0$), linearization (the Jacobian matrix at an equilibrium), and linear stability (signs of the real parts of the Jacobian eigenvalues) to determine the equilibrium set and its stability for specified values of $z$.\n- Use the concept of a limit cycle as an attracting periodic orbit of the planar system, together with numerical integration and post-transient analysis, to decide whether the system exhibits a stable limit cycle for a given $z$. If a stable limit cycle is detected, estimate its mean oscillation frequency by averaging inter-event times between successive zero-crossings of $x(t)$ with positive slope. The event detection must be performed after discarding an initial transient, and the detection thresholding must ensure you do not mistake decaying transient oscillations for a stable limit cycle.\n- Use the definition of a Hopf bifurcation in planar systems in terms of the linearization at an equilibrium (vanishing trace with positive determinant and a transverse crossing) to numerically localize the parameter value $z$ at which the small-magnitude-$x$ equilibrium undergoes a Hopf bifurcation within a given bracket.\n\nBase your derivations on the following foundational definitions and facts from dynamical systems theory:\n- An equilibrium satisfies $\\dot{x} = 0$ and $\\dot{y} = 0$.\n- Linearization at an equilibrium $(x^\\ast, y^\\ast)$ is given by the Jacobian matrix $J(x^\\ast, y^\\ast)$ with entries $J_{ij} = \\partial f_i / \\partial \\xi_j$ for the vector field $(f_1, f_2) = (\\dot{x}, \\dot{y})$ and state $(\\xi_1, \\xi_2) = (x, y)$.\n- Linear stability of a planar equilibrium is determined by the trace and determinant of the Jacobian: both eigenvalues have negative real parts if and only if the trace is negative and the determinant is positive.\n- A generic (nondegenerate) Hopf bifurcation in a planar system occurs when the Jacobian at an equilibrium has zero trace and positive determinant and the trace crosses zero with nonzero speed as the parameter varies.\n- In a planar system with bounded trajectories and with an unstable equilibrium in a region, the Poincaré–Bendixson Theorem implies the existence of a limit cycle; numerically, stable limit cycles can be detected by the sustained periodic oscillations of a trajectory after transients.\n\nYou must implement an algorithm to compute, for prescribed values of $z$, the number of equilibria, the number of linearly stable equilibria, the presence or absence of a stable limit cycle as determined by numerical simulation with robust post-processing, and the mean oscillation frequency if a stable limit cycle is present. Use a fixed time horizon of $T = 800$ (dimensionless time units), discard the first half of the time series before event analysis, and use a time step of $\\Delta t = 0.02$. To determine the presence of a stable limit cycle from a single simulation, require at least $6$ upward zero-crossings of $x(t)$ in the post-transient window and a post-transient amplitude $\\max(x) - \\min(x)$ of at least $0.15$. To increase robustness against attraction to a stable equilibrium when a coexisting limit cycle is present, run two simulations per $z$ from initial states $(x(0), y(0)) = (2, 0)$ and $(x(0), y(0)) = (-2, 0)$; if either post-transient trajectory meets the sustained oscillation criteria, declare a stable limit cycle detected and report the mean oscillation frequency using the trajectory with the larger post-transient amplitude.\n\nFor equilibrium and linear stability analysis at a given $z$, proceed by solving\n$$\n\\dot{y} = 0 \\implies y = c - d x^2, \\quad \\dot{x} = 0 \\implies 0 = y - a x^3 + b x^2 + I - z,\n$$\nwhich together reduce to a cubic equation in $x$. Determine all real solutions for $x$ and back-substitute to obtain $y$, then classify stability using the Jacobian.\n\nFor the numerical localization of a Hopf bifurcation associated with the small-$|x|$ equilibrium branch, define the Jacobian trace at that equilibrium as a function of $z$ and use a bisection method on $z$ to find a zero of the trace within a bracket where the trace changes sign, while verifying that the Jacobian determinant is positive at the solution. Track the small-$|x|$ branch by selecting at each $z$ the equilibrium root with the smallest absolute value of $x$, including the case $x = 0$ where applicable.\n\nTest Suite and required outputs:\n- Use the fixed parameters $a = 1$, $b = 3$, $c = 1$, $d = 5$, $I = 3$.\n- For $z \\in \\{3.0, 3.8, 4.2\\}$, compute for each $z$ a list of the form $[N_{\\mathrm{eq}}, N_{\\mathrm{stable}}, \\mathrm{osc}, f]$, where $N_{\\mathrm{eq}}$ is the integer number of equilibria, $N_{\\mathrm{stable}}$ is the integer number of linearly stable equilibria, $\\mathrm{osc}$ is a boolean indicating whether a stable limit cycle is present based on the numerical criteria above, and $f$ is the mean oscillation frequency (a float) if $\\mathrm{osc}$ is true, or $0.0$ otherwise. Round $f$ to four decimal places.\n- For the small-$|x|$ equilibrium branch, find a Hopf bifurcation value $z_{\\mathrm{H}}$ by bisection within the bracket $[3.5, 4.4]$. Return $z_{\\mathrm{H}}$ as a float rounded to four decimal places.\n\nFinal Output Format:\n- Your program should produce a single line of output containing a Python-style list with four entries. The first three entries correspond to the three values of $z$ in increasing order and must be lists of the form $[N_{\\mathrm{eq}}, N_{\\mathrm{stable}}, \\mathrm{osc}, f]$ with $f$ rounded to four decimals. The fourth entry must be the single float $z_{\\mathrm{H}}$ rounded to four decimals. For example, a syntactically valid output would look like\n$[[2,1,False,0.0000],[1,0,True,0.1532],[3,1,True,0.0975],3.9264]$.",
            "solution": "The problem requires a comprehensive analysis of the fast subsystem of the Hindmarsh-Rose model, a two-dimensional planar system of ordinary differential equations (ODEs), for a given set of parameters. The analysis is to be conducted from first principles of dynamical systems theory. The tasks involve finding equilibria and their stability, detecting stable limit cycles through numerical simulation, and locating a Hopf bifurcation point.\n\nThe system is described by the equations:\n$$\n\\dot{x} = y - a x^3 + b x^2 + I - z\n$$\n$$\n\\dot{y} = c - d x^2 - y\n$$\nwith fixed parameters $a = 1$, $b = 3$, $c = 1$, $d = 5$, and $I = 3$. The parameter $z$ serves as a control parameter. All quantities are dimensionless.\n\nSubstituting the fixed parameter values, the system becomes:\n$$\n\\dot{x} = y - x^3 + 3 x^2 + 3 - z\n$$\n$$\n\\dot{y} = 1 - 5 x^2 - y\n$$\n\nThe analysis is divided into three main parts as requested.\n\n### Part 1: Equilibrium and Stability Analysis\n\nAn equilibrium point $(x^\\ast, y^\\ast)$ is a state where the system is stationary, i.e., $\\dot{x} = 0$ and $\\dot{y} = 0$.\nFrom the equation for $\\dot{y}$, we find the y-nullcline:\n$$\n\\dot{y} = 0 \\implies 1 - 5 (x^\\ast)^2 - y^\\ast = 0 \\implies y^\\ast = 1 - 5 (x^\\ast)^2\n$$\nThis defines a parabola in the $(x, y)$ plane along which trajectories have no vertical motion.\n\nSubstituting this expression for $y^\\ast$ into the equation for $\\dot{x} = 0$ (the x-nullcline) yields an equation for the x-coordinate(s) of the equilibrium points:\n$$\n(1 - 5 (x^\\ast)^2) - (x^\\ast)^3 + 3 (x^\\ast)^2 + 3 - z = 0\n$$\nRearranging gives a cubic polynomial equation in $x^\\ast$:\n$$\n- (x^\\ast)^3 - 2(x^\\ast)^2 + 4 - z = 0\n$$\n$$\n(x^\\ast)^3 + 2(x^\\ast)^2 + z - 4 = 0\n$$\nFor a given value of $z$, the real roots of this cubic equation provide the x-coordinates of all equilibrium points. The number of distinct real roots, $N_{\\mathrm{eq}}$, can be one, two, or three. For each real root $x^\\ast$, the corresponding $y^\\ast$ is found using $y^\\ast = 1 - 5(x^\\ast)^2$.\n\nTo determine the linear stability of each equilibrium point $(x^\\ast, y^\\ast)$, we linearize the system by computing the Jacobian matrix $J$ at that point. The Jacobian matrix is defined as $J_{ij} = \\partial f_i / \\partial \\xi_j$ where $\\vec{f} = (\\dot{x}, \\dot{y})$ and $\\vec{\\xi} = (x, y)$.\n$$\nJ(x, y) = \\begin{pmatrix} \\partial \\dot{x} / \\partial x  \\partial \\dot{x} / \\partial y \\\\ \\partial \\dot{y} / \\partial x  \\partial \\dot{y} / \\partial y \\end{pmatrix} = \\begin{pmatrix} -3x^2 + 6x  1 \\\\ -10x  -1 \\end{pmatrix}\n$$\nThe stability of an equilibrium is determined by the eigenvalues of $J(x^\\ast, y^\\ast)$. For a two-dimensional system, stability can be assessed using the trace, $\\mathrm{tr}(J)$, and the determinant, $\\det(J)$, of the Jacobian.\n$$\n\\mathrm{tr}(J) = (-3(x^\\ast)^2 + 6x^\\ast) - 1 = -3(x^\\ast)^2 + 6x^\\ast - 1\n$$\n$$\n\\mathrm{det}(J) = (-3(x^\\ast)^2 + 6x^\\ast)(-1) - (1)(-10x^\\ast) = 3(x^\\ast)^2 - 6x^\\ast + 10x^\\ast = 3(x^\\ast)^2 + 4x^\\ast\n$$\nAn equilibrium point is linearly stable (an attracting node or focus) if and only if both eigenvalues have negative real parts. This condition is equivalent to $\\mathrm{tr}(J)  0$ and $\\mathrm{det}(J)  0$. The number of stable equilibria, $N_{\\mathrm{stable}}$, is found by counting how many of the identified equilibria satisfy these two conditions.\n\nFor each $z \\in \\{3.0, 3.8, 4.2\\}$, we numerically solve the cubic equation for its real roots, find the corresponding equilibria, and then evaluate the trace and determinant of the Jacobian at each equilibrium to determine $N_{\\mathrm{eq}}$ and $N_{\\mathrm{stable}}$.\n\n### Part 2: Limit Cycle Detection and Frequency Estimation\n\nA limit cycle is an isolated periodic trajectory. A stable limit cycle acts as an attractor for nearby trajectories. The Poincaré-Bendixson theorem suggests that in a planar system with bounded trajectories and an unstable equilibrium (e.g., an unstable focus), a limit cycle is likely to exist.\n\nWe detect stable limit cycles numerically by integrating the system's equations over a time horizon $T=800$ with a time step $\\Delta t = 0.02$. A fourth-order Runge-Kutta (RK4) method is suitable for this fixed-step integration. To explore the state space robustly, two simulations are run for each $z$ value, starting from initial conditions $(x(0), y(0)) = (2, 0)$ and $(x(0), y(0)) = (-2, 0)$.\n\nAfter simulation, we analyze the trajectory to distinguish between sustained oscillations (a limit cycle) and decaying transients leading to a stable equilibrium.\n1.  **Transient Discard**: The first half of the simulation data (from $t=0$ to $t=400$) is discarded to ensure the analysis is performed on the post-transient, asymptotic behavior.\n2.  **Sustained Oscillation Criteria**: A stable limit cycle is deemed present if the post-transient trajectory (from $t=400$ to $t=800$) from *at least one* of the initial conditions satisfies two conditions:\n    a.  The post-transient amplitude, $\\max(x) - \\min(x)$, must be at least $0.15$.\n    b.  There must be at least $6$ upward zero-crossings of the membrane potential $x(t)$ (i.e., events where $x(t)$ crosses from negative to non-negative).\n3.  **Frequency Calculation**: If a stable limit cycle is detected, its mean frequency $f$ is estimated. The trajectory with the larger post-transient amplitude is used for this calculation. We identify the precise times of all upward zero-crossings, $\\{t_1, t_2, \\dots, t_k\\}$, using linear interpolation between time steps for accuracy. The inter-event intervals are $\\Delta T_i = t_{i+1} - t_i$. The mean period is the average of these intervals, $T_{\\mathrm{mean}} = \\frac{1}{k-1}\\sum_{i=1}^{k-1} \\Delta T_i$. The frequency is then $f = 1/T_{\\mathrm{mean}}$. If no limit cycle is detected, $f$ is set to $0.0$.\n\nThis procedure results in a boolean value, $\\mathrm{osc}$, and a frequency, $f$, for each tested $z$.\n\n### Part 3: Hopf Bifurcation Localization\n\nA Hopf bifurcation is a local bifurcation in which an equilibrium point changes its stability, and a small-amplitude limit cycle is born. For a planar system, a generic Hopf bifurcation occurs when the Jacobian matrix at an equilibrium has a pair of purely imaginary eigenvalues. This corresponds to the conditions $\\mathrm{tr}(J)=0$ and $\\mathrm{det}(J)0$. As the bifurcation parameter (here, $z$) is varied, the real part of the eigenvalues must cross zero with non-zero speed, which is guaranteed if $\\frac{d}{dz}(\\mathrm{tr}(J)) \\neq 0$.\n\nWe are asked to find the value $z_{\\mathrm{H}}$ where the equilibrium on the \"small-$|x|$ branch\" undergoes a Hopf bifurcation. The small-$|x|$ equilibrium is defined as the root $x^\\ast$ of the cubic $(x^\\ast)^3 + 2(x^\\ast)^2 + z - 4 = 0$ having the smallest absolute value.\n\nWe need to find $z$ such that $\\mathrm{tr}(J(x^\\ast(z))) = 0$. Let's define a function $g(z) = \\mathrm{tr}(J(x^\\ast(z))) = -3(x^\\ast(z))^2 + 6x^\\ast(z) - 1$.\nThe problem specifies using a bisection method to find the root of $g(z)=0$ within the bracket $[3.5, 4.4]$. The algorithm is as follows:\n1.  Define the function $g(z)$ which first finds the real roots of the cubic equation for $z$, selects the root $x^\\ast$ with the minimum absolute value, and then returns the value of the trace $-3(x^\\ast)^2 + 6x^\\ast - 1$.\n2.  Verify that $g(3.5)$ and $g(4.4)$ have opposite signs, confirming a root exists in the bracket.\n3.  Iteratively apply the bisection algorithm to narrow the interval containing $z_{\\mathrm{H}}$ until a desired precision is reached.\n4.  At the found value $z_{\\mathrm{H}}$, we also confirm that $\\mathrm{det}(J) = 3(x^\\ast)^2 + 4x^\\ast  0$ at the corresponding equilibrium $x^\\ast(z_{\\mathrm{H}})$, satisfying the full condition for a Hopf bifurcation.\n\nBy implementing these three components, we can generate the required output for the specified test suite.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Hindmarsh-Rose model analysis problem as specified.\n    \"\"\"\n    \n    # Fixed parameters\n    a, b, c, d, I = 1, 3, 1, 5, 3\n    params = {'a': a, 'b': b, 'c': c, 'd': d, 'I': I}\n\n    # --- Helper functions ---\n\n    def get_system_rhs(z_val, p):\n        \"\"\"Returns the RHS function of the ODE system for a given z.\"\"\"\n        def rhs(t, y):\n            x, y_var = y\n            dxdt = y_var - p['a'] * x**3 + p['b'] * x**2 + p['I'] - z_val\n            dydt = p['c'] - p['d'] * x**2 - y_var\n            return np.array([dxdt, dydt])\n        return rhs\n\n    def find_equilibria(z_val, p):\n        \"\"\"Finds equilibrium points (x*, y*) for a given z.\"\"\"\n        # Cubic equation for x*: x^3 + 2x^2 + z - 4 = 0\n        cubic_coeffs = [1, 2, 0, z_val - 4]\n        \n        roots = np.roots(cubic_coeffs)\n        real_roots_x = [r.real for r in roots if np.isclose(r.imag, 0)]\n        \n        equilibria = []\n        for x_star in sorted(real_roots_x):\n            y_star = p['c'] - p['d'] * x_star**2\n            equilibria.append((x_star, y_star))\n        return equilibria\n\n    def analyze_stability(equilibria, p):\n        \"\"\"Analyzes stability of equilibria and returns counts.\"\"\"\n        if not equilibria:\n            return 0, 0\n            \n        n_eq = len(equilibria)\n        n_stable = 0\n        for x_star, y_star in equilibria:\n            # Jacobian: J = [[-3ax^2+2bx, 1], [-2dx, -1]]\n            # With params: J = [[-3x^2+6x, 1], [-10x, -1]]\n            tr_J = -3 * x_star**2 + 6 * x_star - 1\n            det_J = (-3 * x_star**2 + 6 * x_star) * (-1) - (-10 * x_star)\n            det_J = 3 * x_star**2 - 6 * x_star + 10 * x_star\n            det_J = 3 * x_star**2 + 4 * x_star\n            \n            if tr_J  0 and det_J  0:\n                n_stable += 1\n        return n_eq, n_stable\n\n    def run_simulation(z_val, p, ic_list, T, dt):\n        \"\"\"\n        Runs numerical simulation from given initial conditions.\n        Uses a fixed-step 4th-order Runge-Kutta integrator.\n        \"\"\"\n        rhs = get_system_rhs(z_val, p)\n        num_steps = int(T / dt)\n        t_span = np.linspace(0, T, num_steps + 1)\n        \n        trajectories = []\n        for ic in ic_list:\n            y = np.array(ic)\n            history = np.zeros((len(t_span), len(y)))\n            history[0, :] = y\n            \n            for i in range(num_steps):\n                t = t_span[i]\n                k1 = rhs(t, y)\n                k2 = rhs(t + dt/2, y + dt/2 * k1)\n                k3 = rhs(t + dt/2, y + dt/2 * k2)\n                k4 = rhs(t + dt, y + dt * k3)\n                y = y + dt/6 * (k1 + 2*k2 + 2*k3 + k4)\n                history[i+1, :] = y\n            trajectories.append((t_span, history))\n        return trajectories\n\n    def analyze_limit_cycle(trajectories, T, dt):\n        \"\"\"Analyzes trajectories for stable limit cycles.\"\"\"\n        transient_idx = int((T / 2) / dt)\n        \n        osc_detected = False\n        best_freq = 0.0\n        max_amp = -1.0\n\n        for t, traj in trajectories:\n            x_post = traj[transient_idx:, 0]\n            t_post = t[transient_idx:]\n            \n            amplitude = np.max(x_post) - np.min(x_post)\n            \n            # Find upward zero-crossings\n            crossings = np.where((x_post[:-1]  0)  (x_post[1:] = 0))[0]\n            num_crossings = len(crossings)\n\n            if amplitude = 0.15 and num_crossings = 6:\n                osc_detected = True\n                \n                # Use linear interpolation for accurate crossing times\n                crossing_times = []\n                for i in crossings:\n                    t0, x0 = t_post[i], x_post[i]\n                    t1, x1 = t_post[i+1], x_post[i+1]\n                    # t_cross = t0 - x0 * (t1 - t0) / (x1 - x0)\n                    t_cross = t0 + (0 - x0) * (t1 - t0) / (x1 - x0)\n                    crossing_times.append(t_cross)\n                \n                if len(crossing_times)  1:\n                    periods = np.diff(crossing_times)\n                    mean_period = np.mean(periods)\n                    freq = 1.0 / mean_period if mean_period  0 else 0.0\n\n                    # Keep frequency from trajectory with larger amplitude\n                    if amplitude  max_amp:\n                        max_amp = amplitude\n                        best_freq = freq\n            \n        return osc_detected, best_freq\n\n    def find_hopf_bifurcation(bracket, p, tol=1e-5):\n        \"\"\"Finds the Hopf bifurcation point z_H using bisection.\"\"\"\n        def get_trace_at_smallest_x_root(z_val):\n            # Same cubic as in find_equilibria\n            cubic_coeffs = [1, 2, 0, z_val - 4]\n            roots = np.roots(cubic_coeffs)\n            real_roots_x = [r.real for r in roots if np.isclose(r.imag, 0)]\n            \n            if not real_roots_x:\n                return None # Should not happen in the bracket of interest\n            \n            # Select root with smallest absolute value\n            x_star = min(real_roots_x, key=abs)\n            \n            # Calculate trace\n            tr_J = -3 * x_star**2 + 6 * x_star - 1\n            return tr_J, x_star\n\n        z_a, z_b = bracket\n        trace_a, _ = get_trace_at_smallest_x_root(z_a)\n        trace_b, _ = get_trace_at_smallest_x_root(z_b)\n\n        if trace_a * trace_b = 0:\n            return None # Bisection requires opposite signs\n\n        while (z_b - z_a) / 2.0  tol:\n            z_mid = (z_a + z_b) / 2.0\n            trace_mid, _ = get_trace_at_smallest_x_root(z_mid)\n            if trace_mid == 0:\n                return z_mid\n            elif trace_a * trace_mid  0:\n                z_b = z_mid\n            else:\n                z_a = z_mid\n        \n        z_H = (z_a + z_b) / 2.0\n        \n        # Final check for det(J)  0\n        _, x_star_H = get_trace_at_smallest_x_root(z_H)\n        det_J = 3 * x_star_H**2 + 4 * x_star_H\n        if det_J = 0:\n            return None # Not a Hopf bifurcation\n\n        return z_H\n\n    # --- Main Calculation ---\n\n    z_values = [3.0, 3.8, 4.2]\n    all_results = []\n\n    # Simulation parameters\n    T_sim = 800.0\n    dt_sim = 0.02\n    ics = [(2.0, 0.0), (-2.0, 0.0)]\n\n    for z in z_values:\n        # Task 1: Equilibria and stability\n        equilibria = find_equilibria(z, params)\n        N_eq, N_stable = analyze_stability(equilibria, params)\n        \n        # Task 2: Limit cycle detection\n        trajectories = run_simulation(z, params, ics, T_sim, dt_sim)\n        osc, f = analyze_limit_cycle(trajectories, T_sim, dt_sim)\n        \n        all_results.append([N_eq, N_stable, osc, round(f, 4)])\n        \n    # Task 3: Hopf bifurcation\n    z_H_bracket = [3.5, 4.4]\n    z_H = find_hopf_bifurcation(z_H_bracket, params)\n    all_results.append(round(z_H, 4))\n    \n    # Format for printing\n    formatted_results = []\n    for item in all_results:\n        if isinstance(item, list):\n            # Format float to have 4 decimal places\n            item[3] = f\"{item[3]:.4f}\"\n            formatted_results.append(f\"[{item[0]},{item[1]},{item[2]},{item[3]}]\")\n        else:\n            formatted_results.append(f\"{item:.4f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "With an understanding of the fast subsystem's spiking mechanism, we can now investigate how it interacts with the slow dynamics in the full three-dimensional model. This interaction gives rise to complex, system-level behaviors that are central to neural coding, such as bursting and hysteresis. This final practice guides you through a simulation to demonstrate and quantify hysteresis, a phenomenon where the threshold for initiating spiking is different from the threshold for terminating it. ",
            "id": "4028937",
            "problem": "Consider the Hindmarsh–Rose model of a bursting neuron described by the system of three coupled Ordinary Differential Equations (ODEs): $$\\frac{dx}{dt} = y - a x^3 + b x^2 - z + I(t),\\quad \\frac{dy}{dt} = c - d x^2 - y,\\quad \\frac{dz}{dt} = r \\left(s \\left(x - x_R\\right) - z\\right),$$ where $x$ is the membrane potential, $y$ is a fast recovery variable, $z$ is a slow adaptation variable, and $I(t)$ is a time-dependent external current. The constants $a$, $b$, $c$, and $d$ describe the fast subsystem nonlinearity and are set to $a=1$, $b=3$, $c=1$, $d=5$. The parameters $(r, s, x_R)$ control the slow adaptation dynamics and the coupling to the fast subsystem. The external current $I(t)$ will be specified as a deterministic ramp.\n\nStarting from the core definitions of slow–fast dynamical systems and their bifurcation-induced transitions between rest and tonic spiking regimes, devise and implement a principled computational procedure to demonstrate that changes in $I$ can induce hysteresis in burst onset and termination and to quantify the width of the resulting hysteresis loop as a function of $(r, s, x_R)$. The hysteresis width is defined as the difference $\\Delta I = I_{\\mathrm{on}} - I_{\\mathrm{off}}$, where $I_{\\mathrm{on}}$ is the value of $I$ at the first persistent onset of tonic spiking when $I$ is increased quasi-statically from a lower bound, and $I_{\\mathrm{off}}$ is the value of $I$ at the termination of tonic spiking when $I$ is decreased quasi-statically from an upper bound. All quantities in this problem are dimensionless; express the final hysteresis widths in the same dimensionless unit as $I$.\n\nYour program must follow these scientifically realistic and testable specifications:\n\n1. Implement the ODEs using a fixed-step explicit fourth-order Runge–Kutta method. Use a uniform time step $dt = 0.05$.\n2. Use the following external current protocol: define an upward ramp from $I_{\\min}$ to $I_{\\max}$ over duration $T_{\\uparrow}$, immediately followed by a downward ramp from $I_{\\max}$ back to $I_{\\min}$ over duration $T_{\\downarrow}$. Use $I_{\\min} = 1.0$, $I_{\\max} = 3.5$, $T_{\\uparrow} = 2000$, and $T_{\\downarrow} = 2000$. Thus, $I(t)$ is piecewise-linear with respect to $t$: for $0 \\le t \\le T_{\\uparrow}$, $$I(t) = I_{\\min} + \\frac{I_{\\max} - I_{\\min}}{T_{\\uparrow}}\\, t,$$ and for $T_{\\uparrow} \\le t \\le T_{\\uparrow} + T_{\\downarrow}$, $$I(t) = I_{\\max} - \\frac{I_{\\max} - I_{\\min}}{T_{\\downarrow}}\\, \\left(t - T_{\\uparrow}\\right).$$\n3. Initialize the state at a resting condition: use $x(0) = -1.0$, $y(0) = -10.0$, $z(0) = 1.0$.\n4. Detect tonic spiking robustly during integration based on upward threshold crossings of $x$ across a fixed threshold $x_{\\mathrm{thr}} = 0.0$. Count spikes using upward crossings where $x$ crosses from below $x_{\\mathrm{thr}}$ to above $x_{\\mathrm{thr}}$. Maintain a sliding time window of length $W = 200$ and define the instantaneous spike count $N_W(t)$ as the number of upward crossings with timestamps within $[t - W, t]$. Declare the system to be in the tonic spiking regime at time $t$ if $N_W(t) \\ge N_{\\min}$, with $N_{\\min} = 4$. The model is declared to be in rest otherwise.\n5. Define $I_{\\mathrm{on}}$ as the value of $I(t)$ at the first time $t$ during the upward ramp phase where the tonic spiking regime is detected, and define $I_{\\mathrm{off}}$ as the value of $I(t)$ at the first time $t$ during the downward ramp phase where the tonic spiking regime is no longer detected after having been detected at least once. If either onset or termination is not detected within the specified range, set the hysteresis width to $0.0$ for that case.\n6. Compute the hysteresis width $\\Delta I = \\max\\left(0,\\, I_{\\mathrm{on}} - I_{\\mathrm{off}}\\right)$ for each parameter set in the test suite below. Report each width rounded to six decimal places.\n\nTest suite and coverage:\n\n- Case A (general bursting regime): $(r, s, x_R) = (0.003, 4.0, -1.6)$.\n- Case B (slower adaptation boundary): $(r, s, x_R) = (0.001, 4.0, -1.6)$.\n- Case C (faster adaptation, reduced hysteresis): $(r, s, x_R) = (0.020, 4.0, -1.6)$.\n- Case D (altered slow coupling and reversal potential): $(r, s, x_R) = (0.005, 3.0, -1.8)$.\n\nYour program should produce a single line of output containing the hysteresis widths for Cases A–D, in order, as a comma-separated list enclosed in square brackets, for example, $[\\Delta I_A,\\Delta I_B,\\Delta I_C,\\Delta I_D]$. The output must be a single line with no additional text. All values are floats in the same dimensionless unit as $I$, each rounded to six decimal places.",
            "solution": "The problem is well-posed, scientifically grounded, and computationally verifiable. It describes a standard numerical experiment in computational neuroscience to investigate hysteresis in the Hindmarsh–Rose model, a canonical slow–fast dynamical system. All parameters, initial conditions, and procedural steps are specified unambiguously, allowing for a unique and reproducible solution.\n\nThe core of the problem lies in simulating the Hindmarsh–Rose model, which is described by the following system of coupled ordinary differential equations (ODEs):\n$$\n\\frac{dx}{dt} = y - a x^3 + b x^2 - z + I(t) \\\\\n\\frac{dy}{dt} = c - d x^2 - y \\\\\n\\frac{dz}{dt} = r \\left(s \\left(x - x_R\\right) - z\\right)\n$$\nHere, $x(t)$ represents the neuron's membrane potential, $y(t)$ is a fast recovery variable associated with ion channel gating, and $z(t)$ is a slow adaptation variable, often representing the dynamics of intracellular calcium concentration or slow channel kinetics. The variables $x$ and $y$ constitute the fast subsystem, while $z$ is the slow variable, as its rate of change is governed by the small parameter $r$. The external input is a time-dependent current $I(t)$.\n\nThe problem specifies fixed parameters for the fast subsystem: $a=1$, $b=3$, $c=1$, and $d=5$. The dynamics of the slow variable are controlled by the parameter set $(r, s, x_R)$, which will be varied across test cases.\n\nThe scientific principle being demonstrated is hysteresis, a common feature of systems with multiple stable states (multistability) that are controlled by a slowly varying parameter. In this model, for a given value of the slow variable $z$, the fast subsystem can exhibit either a stable fixed point (resting state) or a stable limit cycle (tonic spiking), depending on the value of the control parameter $I$. As $I$ is slowly varied, the system transitions between these two states at critical bifurcation points. Due to the slow dynamics of $z$, the path taken during the upward ramp of $I$ is different from the path taken during the downward ramp. The transition from rest to spiking occurs at a higher value of $I$ ($I_{\\mathrm{on}}$) than the transition from spiking back to rest ($I_{\\mathrm{off}}$). The difference, $\\Delta I = I_{\\mathrm{on}} - I_{\\mathrm{off}}$, is the width of the hysteresis loop.\n\nThe computational procedure to quantify this phenomenon is as follows:\n\n1.  **Numerical Integration**: The system of ODEs is integrated numerically using the explicit fourth-order Runge–Kutta (RK4) method. This method provides a good balance between accuracy and computational cost for non-stiff ODEs. A fixed time step of $dt = 0.05$ is used. The state of the system at time $t$ is the vector $\\mathbf{v}(t) = [x(t), y(t), z(t)]^T$. An RK4 step to advance from time $t_n$ to $t_{n+1} = t_n + dt$ is given by:\n    $$\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{dt}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    $$\n    Where the increments $\\mathbf{k}_i$ are:\n    $$\n    \\mathbf{k}_1 = f(t_n, \\mathbf{v}_n) \\\\\n    \\mathbf{k}_2 = f(t_n + \\frac{dt}{2}, \\mathbf{v}_n + \\frac{dt}{2}\\mathbf{k}_1) \\\\\n    \\mathbf{k}_3 = f(t_n + \\frac{dt}{2}, \\mathbf{v}_n + \\frac{dt}{2}\\mathbf{k}_2) \\\\\n    \\mathbf{k}_4 = f(t_n + dt, \\mathbf{v}_n + dt\\mathbf{k}_3)\n    $$\n    and $f(t, \\mathbf{v})$ is the vector field defined by the right-hand side of the Hindmarsh–Rose equations. The system is initialized at $x(0) = -1.0$, $y(0) = -10.0$, and $z(0) = 1.0$.\n\n2.  **Input Current Protocol**: A piecewise-linear current ramp $I(t)$ is applied to slowly drive the system.\n    -   For the upward ramp ($0 \\le t \\le T_{\\uparrow}$), $I(t) = I_{\\min} + \\frac{I_{\\max} - I_{\\min}}{T_{\\uparrow}} t$.\n    -   For the downward ramp ($T_{\\uparrow}  t \\le T_{\\uparrow} + T_{\\downarrow}$), $I(t) = I_{\\max} - \\frac{I_{\\max} - I_{\\min}}{T_{\\downarrow}} (t - T_{\\uparrow})$.\n    The parameters are set to $I_{\\min} = 1.0$, $I_{\\max} = 3.5$, and $T_{\\uparrow} = T_{\\downarrow} = 2000$. This slow variation is crucial for observing the hysteresis loop; it approximates a quasi-static change in the bifurcation parameter $I$.\n\n3.  **Spike and State Detection**: The system's state (resting vs. tonic spiking) is determined algorithmically.\n    -   An action potential (spike) is registered whenever the membrane potential $x(t)$ performs an upward crossing of the threshold $x_{\\mathrm{thr}} = 0.0$.\n    -   The system is defined to be in the tonic spiking regime at time $t$ if the count of spikes $N_W(t)$ within a sliding historical window of duration $W = 200$ (i.e., in the interval $[t-W, t]$) is at least $N_{\\min} = 4$. This condition ensures that transient spiking is ignored and only sustained, high-frequency firing is classified as the tonic spiking state.\n\n4.  **Hysteresis Measurement**: The critical current values $I_{\\mathrm{on}}$ and $I_{\\mathrm{off}}$ are recorded during the simulation.\n    -   $I_{\\mathrm{on}}$ is the value of $I(t)$ at the first moment an upward-ramp time $t \\le T_{\\uparrow}$ when the tonic spiking condition $N_W(t) \\ge N_{\\min}$ is met.\n    -   $I_{\\mathrm{off}}$ is the value of $I(t)$ at the first moment a downward-ramp time $t  T_{\\uparrow}$ when the system transitions out of the tonic spiking state (i.e., $N_W(t)  N_{\\min}$), given that it had entered this state at least once during the simulation.\n    -   The hysteresis width is then calculated as $\\Delta I = \\max(0.0, I_{\\mathrm{on}} - I_{\\mathrm{off}})$. If either $I_{\\mathrm{on}}$ or $I_{\\mathrm{off}}$ is not detected according to the protocol, $\\Delta I$ is taken to be $0.0$.\n\nThis procedure is systematically applied to each provided parameter set $(r, s, x_R)$ to calculate the corresponding hysteresis width. The implementation will follow these steps precisely to generate the required numerical results.",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Computes the hysteresis width for the Hindmarsh-Rose model under a ramp\n    current stimulus for several parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.003, 4.0, -1.6),  # Case A\n        (0.001, 4.0, -1.6),  # Case B\n        (0.020, 4.0, -1.6),  # Case C\n        (0.005, 3.0, -1.8),  # Case D\n    ]\n\n    # --- Fixed parameters and simulation settings ---\n    # Model parameters\n    a = 1.0\n    b = 3.0\n    c = 1.0\n    d = 5.0\n    \n    # Current protocol parameters\n    I_min = 1.0\n    I_max = 3.5\n    T_up = 2000.0\n    T_down = 2000.0\n    \n    # Simulation parameters\n    dt = 0.05\n    x0 = -1.0\n    y0 = -10.0\n    z0 = 1.0\n    \n    # State detection parameters\n    x_thr = 0.0\n    W = 200.0\n    N_min = 4\n\n    results = []\n\n    for case in test_cases:\n        r, s, x_R = case\n        \n        # Combine all dynamic parameters for clarity\n        model_params = (a, b, c, d, r, s, x_R)\n\n        # --- Helper functions for the simulation ---\n        def get_current(t):\n            if 0.0 = t = T_up:\n                return I_min + (I_max - I_min) / T_up * t\n            elif T_up  t = T_up + T_down:\n                return I_max - (I_max - I_min) / T_down * (t - T_up)\n            return I_min\n\n        def hr_ode(t, state, params):\n            x, y, z = state\n            _a, _b, _c, _d, _r, _s, _x_R = params\n            I_t = get_current(t)\n            \n            dx_dt = y - _a * x**3 + _b * x**2 - z + I_t\n            dy_dt = _c - _d * x**2 - y\n            dz_dt = _r * (_s * (x - _x_R) - z)\n            \n            return np.array([dx_dt, dy_dt, dz_dt])\n\n        def rk4_step(t, state, params, step_dt):\n            k1 = hr_ode(t, state, params)\n            k2 = hr_ode(t + step_dt / 2.0, state + step_dt / 2.0 * k1, params)\n            k3 = hr_ode(t + step_dt / 2.0, state + step_dt / 2.0 * k2, params)\n            k4 = hr_ode(t + step_dt, state + step_dt * k3, params)\n            \n            return state + step_dt / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n        # --- Simulation and Hysteresis Measurement ---\n        state = np.array([x0, y0, z0])\n        x_prev = x0\n        \n        t = 0.0\n        total_time = T_up + T_down\n        \n        spike_times = deque()\n        system_state = \"RESTING\" # Can be RESTING, SPIKING, REST_AGAIN\n        \n        I_on = None\n        I_off = None\n        \n        num_steps = int(total_time / dt)\n\n        for step in range(num_steps + 1):\n            t = step * dt\n            \n            # Integrate one step\n            state = rk4_step(t, state, model_params, dt)\n            x, y, z = state\n            \n            # Spike detection (upward crossing)\n            if x_prev  x_thr and x = x_thr:\n                spike_times.append(t)\n            x_prev = x # Update for next iteration\n            \n            # Maintain sliding window of spike times\n            while spike_times and spike_times[0]  t - W:\n                spike_times.popleft()\n            \n            # Determine if the system is in the tonic spiking regime\n            is_spiking_now = len(spike_times) = N_min\n            \n            # Hysteresis detection logic\n            # Up-ramp phase\n            if t = T_up:\n                if system_state == \"RESTING\" and is_spiking_now:\n                    I_on = get_current(t)\n                    system_state = \"SPIKING\"\n            # Down-ramp phase\n            else:\n                if system_state == \"SPIKING\" and not is_spiking_now:\n                    I_off = get_current(t)\n                    system_state = \"REST_AGAIN\"\n\n        # Calculate hysteresis width\n        if I_on is not None and I_off is not None:\n            delta_I = max(0.0, I_on - I_off)\n        else:\n            delta_I = 0.0\n        \n        results.append(delta_I)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{val:.6f}' for val in results])}]\")\n\nsolve()\n```"
        }
    ]
}