{
    "hands_on_practices": [
        {
            "introduction": "A common first step in characterizing a neuron's computational function is to measure its tuning curve. This exercise explores how the mathematical form of a directional tuning curve directly relates to the degree of selectivity. You will derive, from first principles, how the Direction Selectivity Index (DSI) depends on the constituent parts of the tuning function, revealing the critical role that response asymmetry, captured by odd symmetric functions, plays in generating selectivity.",
            "id": "3999450",
            "problem": "A neuron in a motion-processing area exhibits direction tuning described by the firing rate function $R(\\theta) = A + B\\cos(\\theta - \\theta_0) + C\\sin(\\theta - \\theta_0)$, where $\\theta$ is the stimulus motion direction, $\\theta_0$ is a reference direction, and $A$, $B$, $C$ are real parameters. Angles are measured in radians. Assume $A > 0$ and $\\sqrt{B^{2} + C^{2}}  A$ so that the modulation is bounded by the positive baseline. In computational neuroscience, a widely used definition of the Direction Selectivity Index (DSI) is\n$$\\mathrm{DSI} = \\frac{R(\\theta_{\\mathrm{pref}}) - R(\\theta_{\\mathrm{null}})}{R(\\theta_{\\mathrm{pref}}) + R(\\theta_{\\mathrm{null}})},$$\nwhere $\\theta_{\\mathrm{pref}}$ is the direction that maximizes $R(\\theta)$ and $\\theta_{\\mathrm{null}} = \\theta_{\\mathrm{pref}} + \\pi$ is the opposite direction.\n\nStarting only from this definition, trigonometric identities, and the properties of maxima and minima of smooth functions, derive a closed-form expression for $\\mathrm{DSI}$ in terms of $A$, $B$, and $C$. Then, using your derivation, identify how the odd term $C\\sin(\\theta - \\theta_0)$ influences direction selectivity: does it change the magnitude of the Direction Selectivity Index, the preferred direction, both, or neither? Justify your conclusion from first principles. Express the final Direction Selectivity Index as a single analytical expression. No rounding is required, and no units should be included with your final answer.",
            "solution": "The problem provides the firing rate function of a direction-tuned neuron, $R(\\theta) = A + B\\cos(\\theta - \\theta_0) + C\\sin(\\theta - \\theta_0)$, where $\\theta$ is the direction of stimulus motion. We are tasked with deriving a closed-form expression for the Direction Selectivity Index (DSI), defined as $\\mathrm{DSI} = \\frac{R(\\theta_{\\mathrm{pref}}) - R(\\theta_{\\mathrm{null}})}{R(\\theta_{\\mathrm{pref}}) + R(\\theta_{\\mathrm{null}})}$, where $\\theta_{\\mathrm{pref}}$ is the direction eliciting the maximum response and $\\theta_{\\mathrm{null}} = \\theta_{\\mathrm{pref}} + \\pi$. The derivation must proceed from first principles.\n\nFirst, we simplify the expression for the firing rate $R(\\theta)$. The sum of a cosine and a sine term can be expressed as a single phase-shifted cosine function using the harmonic addition theorem. Let the variable part of the rate function be $f(\\theta) = B\\cos(\\theta - \\theta_0) + C\\sin(\\theta - \\theta_0)$.\nWe can write this in the form $M\\cos(\\theta - \\theta_0 - \\delta)$, where $M$ is the amplitude and $\\delta$ is a phase shift.\nExpanding $M\\cos(\\theta - \\theta_0 - \\delta)$ gives:\n$M\\cos(\\theta - \\theta_0 - \\delta) = M[\\cos(\\theta - \\theta_0)\\cos(\\delta) + \\sin(\\theta - \\theta_0)\\sin(\\delta)]$\n$= (M\\cos\\delta)\\cos(\\theta - \\theta_0) + (M\\sin\\delta)\\sin(\\theta - \\theta_0)$.\nBy comparing coefficients with $f(\\theta)$, we must have:\n$B = M\\cos(\\delta)$\n$C = M\\sin(\\delta)$\nTo find the amplitude $M$, we square and add these two equations:\n$B^2 + C^2 = (M\\cos\\delta)^2 + (M\\sin\\delta)^2 = M^2(\\cos^2\\delta + \\sin^2\\delta) = M^2$.\nThus, the amplitude of the modulation is $M = \\sqrt{B^2 + C^2}$. Since $B$ and $C$ are real, $M$ is real and non-negative.\nThe phase shift $\\delta$ is determined by $\\tan(\\delta) = \\frac{M\\sin\\delta}{M\\cos\\delta} = \\frac{C}{B}$. The specific quadrant for $\\delta$ is determined by the signs of $B$ and $C$.\nThe firing rate function can now be written in a more compact form:\n$R(\\theta) = A + M\\cos(\\theta - \\theta_0 - \\delta)$.\n\nThe preferred direction, $\\theta_{\\mathrm{pref}}$, is the direction $\\theta$ that maximizes $R(\\theta)$. The function $R(\\theta)$ is maximal when the term $\\cos(\\theta - \\theta_0 - \\delta)$ is maximal, which occurs when its value is $1$.\n$\\cos(\\theta_{\\mathrm{pref}} - \\theta_0 - \\delta) = 1$.\nThis condition is met when the argument of the cosine is an integer multiple of $2\\pi$, i.e., $\\theta_{\\mathrm{pref}} - \\theta_0 - \\delta = 2k\\pi$ for an integer $k$. We can select the principal angle by setting $k=0$, which yields:\n$\\theta_{\\mathrm{pref}} = \\theta_0 + \\delta$.\nAt this preferred direction, the maximum firing rate is:\n$R(\\theta_{\\mathrm{pref}}) = A + M\\cos(0) = A + M = A + \\sqrt{B^2 + C^2}$.\n\nThe null direction is defined as $\\theta_{\\mathrm{null}} = \\theta_{\\mathrm{pref}} + \\pi$. The firing rate at the null direction is:\n$R(\\theta_{\\mathrm{null}}) = R(\\theta_{\\mathrm{pref}} + \\pi) = A + M\\cos(\\theta_{\\mathrm{pref}} + \\pi - \\theta_0 - \\delta)$.\nSubstituting $\\theta_{\\mathrm{pref}} = \\theta_0 + \\delta$, the argument of the cosine becomes $(\\theta_0 + \\delta) + \\pi - \\theta_0 - \\delta = \\pi$.\nTherefore, the firing rate at the null direction is:\n$R(\\theta_{\\mathrm{null}}) = A + M\\cos(\\pi) = A - M = A - \\sqrt{B^2 + C^2}$.\nThe problem states that $A > 0$ and $\\sqrt{B^2 + C^2}  A$, which ensures that $R(\\theta)$ is always positive, a necessary condition for a firing rate.\n\nNow we can substitute the expressions for $R(\\theta_{\\mathrm{pref}})$ and $R(\\theta_{\\mathrm{null}})$ into the definition of the DSI:\n$\\mathrm{DSI} = \\frac{R(\\theta_{\\mathrm{pref}}) - R(\\theta_{\\mathrm{null}})}{R(\\theta_{\\mathrm{pref}}) + R(\\theta_{\\mathrm{null}})} = \\frac{(A + M) - (A - M)}{(A + M) + (A - M)}$.\nSimplifying the numerator and denominator:\n$\\mathrm{DSI} = \\frac{2M}{2A} = \\frac{M}{A}$.\nSubstituting back the expression for $M$:\n$\\mathrm{DSI} = \\frac{\\sqrt{B^2 + C^2}}{A}$.\nThis is the closed-form expression for the Direction Selectivity Index in terms of the parameters $A$, $B$, and $C$.\n\nFinally, we analyze the influence of the odd term, $C\\sin(\\theta - \\theta_0)$, on direction selectivity. This is equivalent to analyzing the influence of the parameter $C$.\n1.  **Influence on the magnitude of the DSI**: The magnitude is given by $\\mathrm{DSI} = \\frac{\\sqrt{B^2 + C^2}}{A}$. The term $C^2$ appears under the square root in the numerator. For any non-zero value of $C$, $C^2 > 0$, which increases the value of the numerator $\\sqrt{B^2+C^2}$ compared to the case where $C=0$. Therefore, the term $C\\sin(\\theta - \\theta_0)$ directly influences and, for $C \\neq 0$, increases the magnitude of the DSI.\n2.  **Influence on the preferred direction**: The preferred direction is given by $\\theta_{\\mathrm{pref}} = \\theta_0 + \\delta$, where the phase shift $\\delta$ is determined by $\\tan(\\delta) = C/B$. If $C=0$ (and assuming $B > 0$), then $\\tan(\\delta) = 0$, which implies $\\delta = 0$. In this case, $\\theta_{\\mathrm{pref}} = \\theta_0$. However, if $C \\neq 0$, then $\\tan(\\delta) \\neq 0$, which implies $\\delta \\neq 0$. This means the preferred direction $\\theta_{\\mathrm{pref}}$ is shifted away from the reference direction $\\theta_0$. Thus, the term $C\\sin(\\theta - \\theta_0)$ changes the preferred direction.\n\nIn conclusion, the presence of the odd sinusoidal term, characterized by the coefficient $C$, influences **both** the magnitude of the Direction Selectivity Index and the preferred direction of the neuron.",
            "answer": "$$\\boxed{\\frac{\\sqrt{B^{2} + C^{2}}}{A}}$$"
        },
        {
            "introduction": "Having established the mathematical signature of a direction-selective response , we now investigate a canonical mechanism for creating one. This practice guides you through implementing the classic 'delay-and-compare' model in a biophysically plausible conductance-based neuron. By first deriving the analytical condition for input coincidence and then simulating the voltage response, you will gain a concrete understanding of how spatiotemporal filtering generates this fundamental neural computation.",
            "id": "3999490",
            "problem": "You are asked to formalize and compute direction selectivity in a simple conductance-based neuron receiving two spatially separated excitatory inputs with different axonal delays. The neuron is a single isopotential compartment with a passive leak and two synaptic conductances driven by a moving stimulus that sequentially activates the two input sites. The task is to derive, implement, and evaluate when synaptic summation is constructive only in the preferred direction.\n\nUse the following fundamental base and definitions:\n\n- The neuron obeys the passive membrane equation for a single compartment with time-varying total conductance,\n$$\nC_m \\frac{dV(t)}{dt} \\;=\\; -g_L\\left(V(t) - E_L\\right) \\;-\\; \\sum_{i=1}^2 g_i(t)\\left(V(t) - E_E\\right),\n$$\nwhere $C_m$ is the membrane capacitance, $g_L$ is the leak conductance, $E_L$ is the leak reversal potential, $E_E$ is the excitatory synaptic reversal potential, and $g_i(t)$ are synaptic conductances.\n\n- Each synaptic conductance is an alpha function triggered at its arrival time at the soma,\n$$\ng_i(t) \\;=\\; \\bar g \\,\\alpha\\!\\left(t - t_{a,i}\\right), \\quad \\alpha(s) \\;=\\; \\begin{cases}\n\\frac{s}{\\tau_s}\\,\\exp\\!\\left(1 - \\frac{s}{\\tau_s}\\right),  s \\ge 0,\\\\\n0,  s0,\n\\end{cases}\n$$\nwhere $\\bar g$ is the synaptic peak conductance and $\\tau_s$ is the synaptic time constant.\n\n- The two inputs are located at positions $x_1$ and $x_2$ with $x_1 = 0$ and $x_2 = \\Delta x$, where $\\Delta x \\ge 0$. A point stimulus moves at constant speed $v$ along the line connecting $x_1$ and $x_2$. In the preferred direction, the stimulus moves from $x_1$ to $x_2$ with speed $v0$ such that stimulus arrival times at the locations are $t_{s,1}^{\\mathrm{PD}} = 0$ and $t_{s,2}^{\\mathrm{PD}} = \\Delta x / v$. In the null direction, the stimulus moves from $x_2$ to $x_1$ with equal speed magnitude, giving $t_{s,1}^{\\mathrm{ND}} = \\Delta x / v$ and $t_{s,2}^{\\mathrm{ND}} = 0$.\n\n- Each input has an axonal conduction delay from its location to the soma, denoted $d_1$ and $d_2$ respectively, so that synaptic arrival times at the soma are $t_{a,i}^{\\mathrm{dir}} = t_{s,i}^{\\mathrm{dir}} + d_i$ for direction $\\mathrm{dir} \\in \\{\\mathrm{PD}, \\mathrm{ND}\\}$.\n\n- Initial condition is $V(0) = E_L$.\n\nScientific tasks:\n\n1. Starting from the membrane equation and the definition of the synaptic conductances, derive the general condition on $\\Delta x$, $v$, $d_1$, $d_2$, and $\\tau_s$ under which temporal summation is constructive only in the preferred direction. Precisely state your condition in terms of the relative timing of synaptic arrivals and the synaptic time constant.\n\n2. Implement a time-domain simulation of $V(t)$ using the above biophysical parameters, and compute the peak membrane potential in millivolts for both preferred and null directions for each test case. Use the exact per-step solution of the linear ordinary differential equation with piecewise-constant conductance over time steps, or an equally justified and stable numerical method consistent with the fundamental base.\n\n3. For each test case, compute the Direction Selectivity Index (DSI), defined as\n$$\n\\mathrm{DSI} \\;=\\; \\frac{V_{\\max}^{\\mathrm{PD}} - V_{\\max}^{\\mathrm{ND}}}{V_{\\max}^{\\mathrm{PD}} + V_{\\max}^{\\mathrm{ND}}},\n$$\nwhere $V_{\\max}^{\\mathrm{PD}}$ and $V_{\\max}^{\\mathrm{ND}}$ are the respective peak membrane potentials in millivolts. Report DSI as a dimensionless decimal number.\n\nUse the following fixed biophysical parameters for all simulations:\n- $C_m = 200\\,\\mathrm{pF}$,\n- $g_L = 10\\,\\mathrm{nS}$,\n- $E_L = -65\\,\\mathrm{mV}$,\n- $E_E = 0\\,\\mathrm{mV}$,\n- $\\bar g = 5\\,\\mathrm{nS}$,\n- $\\tau_s = 2\\,\\mathrm{ms}$.\n\nUse a simulation time step $\\Delta t = 0.05\\,\\mathrm{ms}$ over a total simulation window $T = 100\\,\\mathrm{ms}$. All time quantities must be in milliseconds, distances in millimeters, conductances in nanosiemens, capacitance in picofarads, and voltages in millivolts. You must compute and use $v$ in units of millimeters per millisecond.\n\nTest suite:\n\nProvide results for the following four parameter sets, where each test case is a tuple $(\\Delta x, v, d_1, d_2)$ using the units specified above:\n\n- Case A (preferred-direction alignment): $(0.2, 0.05, 4.0, 0.0)$.\n- Case B (null-direction alignment): $(0.2, 0.05, 0.0, 4.0)$.\n- Case C (symmetric delays): $(0.2, 0.05, 2.0, 2.0)$.\n- Case D (co-located inputs): $(0.0, 0.05, 1.0, 3.0)$.\n\nRequirements for implementation and output:\n\n- Implement the simulation and compute $V_{\\max}^{\\mathrm{PD}}$ and $V_{\\max}^{\\mathrm{ND}}$ in millivolts for each test case.\n- Compute the Direction Selectivity Index for each test case as defined above.\n- Final program output must be a single line containing a Python list of four floating-point DSI values, one per test case in the order A, B, C, D, each rounded to six decimal places, as a comma-separated list enclosed in square brackets, for example, \"[0.123456,-0.234567,0.000000,0.000000]\".",
            "solution": "We begin from the conductance-based single-compartment passive membrane equation,\n$$\nC_m \\frac{dV(t)}{dt} \\;=\\; -g_L\\left(V(t) - E_L\\right) \\;-\\; \\sum_{i=1}^2 g_i(t)\\left(V(t) - E_E\\right),\n$$\nwith $V(0)=E_L$. The synaptic conductances are alpha functions of the form\n$$\ng_i(t) = \\bar g \\,\\alpha\\!\\left(t - t_{a,i}\\right),\\quad \\alpha(s) = \\frac{s}{\\tau_s}\\,e^{1 - s/\\tau_s}\\;\\text{for}\\; s\\ge 0,\\;\\text{and}\\; \\alpha(s)=0\\;\\text{for}\\; s0,\n$$\nwhere $t_{a,i}$ are synaptic arrival times at the soma. For the preferred direction (from $x_1$ to $x_2$) we have stimulus arrival times at the two locations\n$$\nt_{s,1}^{\\mathrm{PD}}=0,\\qquad t_{s,2}^{\\mathrm{PD}}=\\frac{\\Delta x}{v},\n$$\nand with axonal delays $d_1$ and $d_2$ the soma arrival times are\n$$\nt_{a,1}^{\\mathrm{PD}}=d_1,\\qquad t_{a,2}^{\\mathrm{PD}}=\\frac{\\Delta x}{v} + d_2.\n$$\nFor the null direction (from $x_2$ to $x_1$),\n$$\nt_{s,2}^{\\mathrm{ND}}=0,\\qquad t_{s,1}^{\\mathrm{ND}}=\\frac{\\Delta x}{v},\n$$\nso soma arrivals are\n$$\nt_{a,2}^{\\mathrm{ND}}=d_2,\\qquad t_{a,1}^{\\mathrm{ND}}=\\frac{\\Delta x}{v} + d_1.\n$$\n\nConstructive summation requires that the two synaptic conductances substantially overlap in time at the soma, which happens when the difference between their arrival times is small compared to the synaptic time constant. For the preferred direction, the inter-arrival difference is\n$$\n\\Delta t_{\\mathrm{PD}} \\;=\\; t_{a,2}^{\\mathrm{PD}} - t_{a,1}^{\\mathrm{PD}} \\;=\\; \\frac{\\Delta x}{v} + d_2 - d_1.\n$$\nFor the null direction,\n$$\n\\Delta t_{\\mathrm{ND}} \\;=\\; t_{a,1}^{\\mathrm{ND}} - t_{a,2}^{\\mathrm{ND}} \\;=\\; \\frac{\\Delta x}{v} + d_1 - d_2 \\;=\\; -\\Delta t_{\\mathrm{PD}}.\n$$\nA precise condition for coincidence in the preferred direction is to set $\\Delta t_{\\mathrm{PD}} = 0$, which yields\n$$\nd_1 - d_2 = \\frac{\\Delta x}{v}.\n$$\nThis means the difference in axonal delays exactly compensates for the travel time of the stimulus between the two input locations. In this case, the null-direction separation becomes\n$$\n\\Delta t_{\\mathrm{ND}} = -\\Delta t_{\\mathrm{PD}} = -0 = 0.\n$$\nThis is incorrect. The arrival times must be re-evaluated for the null direction. The separation is between $t_{a,1}^{ND}$ and $t_{a,2}^{ND}$.\n$$\n\\Delta t_{\\mathrm{ND}} \\;=\\; t_{a,1}^{\\mathrm{ND}} - t_{a,2}^{\\mathrm{ND}} \\;=\\; \\left(\\frac{\\Delta x}{v} + d_1\\right) - d_2 \\;=\\; \\frac{\\Delta x}{v} + d_1 - d_2.\n$$\nSubstituting the preferred-direction coincidence condition $d_1 - d_2 = \\Delta x / v$ into this gives:\n$$\n\\Delta t_{\\mathrm{ND}} \\;=\\; \\frac{\\Delta x}{v} + \\left(\\frac{\\Delta x}{v}\\right) \\;=\\; \\frac{2\\Delta x}{v}.\n$$\nTherefore, the general condition under which temporal summation is constructive only in the preferred direction is:\n$$\n\\left| \\frac{\\Delta x}{v} + d_2 - d_1 \\right| \\ll \\tau_s\n\\quad \\text{and} \\quad\n\\left| \\frac{\\Delta x}{v} + d_1 - d_2 \\right| \\gg \\tau_s.\n$$\nThe first part ensures coincidence in the preferred direction, and the second ensures temporal separation in the null direction. This is most effectively achieved when $d_1 - d_2 \\approx \\Delta x / v$, which makes the first term near zero and the second term approximately $2 \\Delta x / v$.\n\nAlgorithmic design for simulation:\n\n- We simulate over a time grid with step $\\Delta t$ up to $T$. At each time step, compute $g_{\\mathrm{syn}}(t) = g_1(t) + g_2(t)$ for either direction using the alpha function with the appropriate $t_{a,i}$.\n- The membrane equation is linear with time-varying coefficients. Over a small step where the total conductance is approximately constant, the ordinary differential equation\n$$\n\\frac{dV}{dt} = -\\frac{g_L + g_{\\mathrm{syn}}(t)}{C_m} V + \\frac{g_L E_L + g_{\\mathrm{syn}}(t) E_E}{C_m}\n$$\nhas the exact per-step solution\n$$\nV(t+\\Delta t) = V_\\infty(t) + \\left(V(t) - V_\\infty(t)\\right)\\exp\\!\\left(-\\frac{g_L + g_{\\mathrm{syn}}(t)}{C_m}\\Delta t\\right),\n$$\nwhere $V_\\infty(t) = \\frac{g_L E_L + g_{\\mathrm{syn}}(t) E_E}{g_L + g_{\\mathrm{syn}}(t)}$ is the instantaneous fixed point.\n- Initialize $V(0)=E_L$ and iterate to obtain $V(t)$ for both preferred and null directions. Record the peak values $V_{\\max}^{\\mathrm{PD}}$ and $V_{\\max}^{\\mathrm{ND}}$.\n- Compute the Direction Selectivity Index as\n$$\n\\mathrm{DSI} = \\frac{V_{\\max}^{\\mathrm{PD}} - V_{\\max}^{\\mathrm{ND}}}{V_{\\max}^{\\mathrm{PD}} + V_{\\max}^{\\mathrm{ND}}}.\n$$\n\nCoverage of test suite:\n\n- Case A sets $d_1 - d_2 = \\Delta x / v$ (with $\\Delta x = 0.2$, $v = 0.05$, so $\\Delta x/v = 4.0$), satisfying the coincidence condition in the preferred direction and creating a null-direction separation of $2\\Delta x/v = 8.0$, which is larger than $\\tau_s = 2.0$, so we expect $\\mathrm{DSI}$ to be positive and large.\n- Case B sets $d_1 - d_2 = -\\Delta x / v$, aligning the null direction, so $\\mathrm{DSI}$ is expected to be negative.\n- Case C uses symmetric delays $d_1 = d_2$ so $|\\Delta t_{\\mathrm{PD}}| = |\\Delta t_{\\mathrm{ND}}| = \\Delta x/v$, leading to similar peak responses and $\\mathrm{DSI}$ near zero.\n- Case D sets $\\Delta x = 0$, making stimulus arrival times identical across directions, so $\\mathrm{DSI}$ should be near zero.\n\nThe program implements the above simulation, computes peak voltages in millivolts, and outputs a single line with a Python list of four Direction Selectivity Index values, each rounded to six decimal places, in the order of the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef alpha_function(t, tau_s):\n    \"\"\"\n    Alpha function: alpha(s) = (s/tau_s) * exp(1 - s/tau_s) for s = 0, else 0.\n    Vectorized for numpy arrays.\n    \"\"\"\n    s = t\n    out = np.zeros_like(s)\n    mask = s = 0.0\n    sm = s[mask]\n    # Avoid underflow/overflow issues by direct computation; tau_s  0 by design.\n    out[mask] = (sm / tau_s) * np.exp(1.0 - sm / tau_s)\n    return out\n\ndef simulate_peak_response(C_m, g_L, E_L, E_E, g_peak, tau_s,\n                           delta_x, v, d1, d2,\n                           dt=0.05, T=100.0, direction='PD'):\n    \"\"\"\n    Simulate the membrane potential V(t) for a given direction (PD or ND)\n    and return the peak membrane potential in mV.\n    Units:\n      - C_m in pF, g_* in nS, E_* in mV, tau_s in ms, dt in ms, T in ms\n      - delta_x in mm, v in mm/ms, d1, d2 in ms\n    \"\"\"\n    # Time vector\n    t = np.arange(0.0, T + dt, dt)\n\n    # Stimulus arrival times at locations x1=0, x2=delta_x for PD and ND\n    ts1_PD = 0.0\n    ts2_PD = (delta_x / v) if v != 0 else 0.0\n    ts1_ND = (delta_x / v) if v != 0 else 0.0\n    ts2_ND = 0.0\n\n    if direction == 'PD':\n        ta1 = ts1_PD + d1\n        ta2 = ts2_PD + d2\n    else:\n        ta1 = ts1_ND + d1\n        ta2 = ts2_ND + d2\n\n    # Synaptic conductances (nS) as alpha functions\n    g1 = g_peak * alpha_function(t - ta1, tau_s)\n    g2 = g_peak * alpha_function(t - ta2, tau_s)\n    gsyn = g1 + g2\n\n    # Precompute constants\n    V = E_L  # initial condition at rest\n    Vmax = V\n\n    # Iterate with exact per-step solution:\n    # V_{k+1} = V_inf + (V_k - V_inf) * exp(-(g_L + gsyn)/C_m * dt)\n    # where V_inf = (g_L*E_L + gsyn*E_E)/(g_L + gsyn)\n    for k in range(len(t) - 1):\n        gtot = g_L + gsyn[k]  # nS\n        # Instantaneous fixed point\n        V_inf = (g_L * E_L + gsyn[k] * E_E) / gtot\n        # Effective rate in 1/ms since (nS)/(pF) = 1/ms\n        rate = gtot / C_m\n        V = V_inf + (V - V_inf) * np.exp(-rate * dt)\n        if V  Vmax:\n            Vmax = V\n\n    return Vmax\n\ndef direction_selectivity_index(Vpd_peak, Vnd_peak):\n    \"\"\"\n    Compute DSI = (PD - ND)/(PD + ND).\n    \"\"\"\n    denom = Vpd_peak + Vnd_peak\n    # To be safe, handle extremely small denom (though in this model denom  0)\n    if abs(denom)  1e-9:\n        return 0.0\n    return (Vpd_peak - Vnd_peak) / denom\n\ndef solve():\n    # Fixed biophysical parameters\n    C_m = 200.0    # pF\n    g_L = 10.0     # nS\n    E_L = -65.0    # mV\n    E_E = 0.0      # mV\n    g_peak = 5.0   # nS\n    tau_s = 2.0    # ms\n\n    # Simulation parameters\n    dt = 0.05      # ms\n    T = 100.0      # ms\n\n    # Test cases: (delta_x [mm], v [mm/ms], d1 [ms], d2 [ms])\n    test_cases = [\n        (0.2, 0.05, 4.0, 0.0),  # Case A: PD alignment (d1 - d2 = delta_x/v = 4.0 ms)\n        (0.2, 0.05, 0.0, 4.0),  # Case B: ND alignment (d1 - d2 = -4.0 ms)\n        (0.2, 0.05, 2.0, 2.0),  # Case C: symmetric delays\n        (0.0, 0.05, 1.0, 3.0),  # Case D: co-located inputs delta_x = 0\n    ]\n\n    results = []\n    for (delta_x, v, d1, d2) in test_cases:\n        # Preferred direction\n        Vpd_peak = simulate_peak_response(C_m, g_L, E_L, E_E, g_peak, tau_s,\n                                          delta_x, v, d1, d2,\n                                          dt=dt, T=T, direction='PD')\n        # Null direction\n        Vnd_peak = simulate_peak_response(C_m, g_L, E_L, E_E, g_peak, tau_s,\n                                          delta_x, v, d1, d2,\n                                          dt=dt, T=T, direction='ND')\n        dsi = direction_selectivity_index(Vpd_peak, Vnd_peak)\n        # Round to six decimals for output\n        results.append(round(dsi, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Moving from a conceptual model to a specific biological circuit, this exercise simulates one of the best-understood examples of direction selectivity in the brain: the retinal circuit involving Direction-Selective Ganglion Cells (DSGCs) and Starburst Amacrine Cells (SACs). Here, selectivity arises not from excitatory coincidence, as in the previous model , but from asymmetric, spatially-tuned inhibition. This advanced computational task requires you to build a detailed model of this circuit, allowing you to probe how the preferred direction of the DSGC is shaped by the kinetics and spatial properties of its inhibitory SAC inputs.",
            "id": "3999419",
            "problem": "Consider a simplified, mechanistic model of Direction-Selective Ganglion Cell (DSGC) responses driven by a moving luminance spot, where direction selectivity arises from the interplay of excitatory bipolar input and inhibitory input from Starburst Amacrine Cells (SACs). The retina is modeled as a two-dimensional spatial domain with the DSGC located at the origin. A stimulus spot moves at a constant speed along a straight path at a direction angle specified in degrees.\n\nThe stimulus intensity is defined by the spatial-temporal function\n$$\nS(\\mathbf{r}, t) = A \\exp\\left( -\\frac{\\|\\mathbf{r} - \\mathbf{s}(t)\\|^2}{2\\sigma_s^2} \\right),\n$$\nwhere $\\mathbf{r} = (x, y)$ is the spatial position in degrees of visual angle, $t$ is time in seconds, $A$ is the stimulus amplitude, $\\sigma_s$ is the spatial standard deviation of the spot in degrees, and $\\mathbf{s}(t) = \\mathbf{r}_0 + v t \\mathbf{u}(\\varphi)$ is the center of the moving spot with initial position $\\mathbf{r}_0 = -L \\mathbf{u}(\\varphi)$, speed $v$ in degrees per second, and unit direction vector $\\mathbf{u}(\\varphi) = (\\cos\\varphi, \\sin\\varphi)$, with $\\varphi$ specified in degrees.\n\nThe DSGC excitatory drive is modeled as linear spatial weighting followed by a causal temporal low-pass filter. The spatial weight is\n$$\nW_e(\\mathbf{r}) = \\exp\\left( -\\frac{\\|\\mathbf{r}\\|^2}{2\\sigma_e^2} \\right),\n$$\nand the excitatory temporal kernel is\n$$\nk_e(t) = H(t)\\frac{1}{\\tau_e} \\exp\\left( -\\frac{t}{\\tau_e} \\right),\n$$\nwhere $H(t)$ is the Heaviside step function, $\\tau_e$ is the excitatory time constant in seconds, and $\\sigma_e$ is the excitatory spatial standard deviation in degrees. The excitatory current is\n$$\nE(t) = \\left( \\iint W_e(\\mathbf{r}) S(\\mathbf{r}, t) \\, d\\mathbf{r} \\right) * k_e(t),\n$$\nwhere $*$ denotes convolution in time.\n\nThe SAC-mediated inhibition is modeled by a direction-gated spatial weighting with dendritic delay and a causal temporal kernel. Define the unit radial vector\n$$\n\\hat{\\mathbf{r}} = \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|},\n$$\nfor $\\mathbf{r} \\neq \\mathbf{0}$. Let a mild azimuthal anisotropy modulate the inhibitory weight, with bias angle $\\theta_{\\text{bias}}$ and modulation depth $\\eta$:\n$$\nM(\\mathbf{r}) = 1 + \\eta \\cos(\\theta(\\mathbf{r}) - \\theta_{\\text{bias}}), \\quad \\theta(\\mathbf{r}) = \\operatorname{atan2}(y, x),\n$$\nand let the centrifugal gating be\n$$\nG(\\mathbf{r}, \\varphi) = H\\left( \\mathbf{u}(\\varphi) \\cdot \\hat{\\mathbf{r}} \\right).\n$$\nThe inhibitory spatial weight is\n$$\nW_i(\\mathbf{r}, \\varphi) = \\exp\\left( -\\frac{\\|\\mathbf{r}\\|}{\\lambda} \\right) M(\\mathbf{r}) G(\\mathbf{r}, \\varphi),\n$$\nwith spatial falloff constant $\\lambda$ in degrees. The SAC dendritic delay is\n$$\n\\tau_d(\\mathbf{r}) = \\tau_{\\text{sac0}} + d \\, \\|\\mathbf{r}\\|,\n$$\nwhere $\\tau_{\\text{sac0}}$ is a base delay in seconds and $d$ is a delay-per-distance parameter in seconds per degree. The inhibitory temporal kernel is\n$$\nk_i(t) = H(t)\\frac{1}{\\tau_i} \\exp\\left( -\\frac{t}{\\tau_i} \\right),\n$$\nwith inhibitory time constant $\\tau_i$ in seconds. The raw inhibitory drive (before filtering) is the delayed spatial integration\n$$\nI_{\\text{raw}}(t; \\varphi) = \\iint W_i(\\mathbf{r}, \\varphi) S(\\mathbf{r}, t - \\tau_d(\\mathbf{r})) \\, d\\mathbf{r},\n$$\nand the filtered inhibitory current is\n$$\nI(t; \\varphi) = I_{\\text{raw}}(\\cdot; \\varphi) * k_i(t).\n$$\n\nThe net synaptic drive is modeled as\n$$\ng(t; \\varphi) = E(t) - g_i I(t; \\varphi),\n$$\nwith inhibitory gain $g_i$ (dimensionless), and the response proxy for direction $\\varphi$ is taken as the half-wave-rectified integral\n$$\nR(\\varphi) = \\int_{0}^{T_{\\text{end}}} \\max\\{0, g(t; \\varphi)\\} \\, dt,\n$$\nover a fixed simulation window $[0, T_{\\text{end}}]$.\n\nDefine the preferred direction (PD) as the angle $\\varphi$ (in degrees) that maximizes $R(\\varphi)$ over a discrete set of directions. Let the discrete set be\n$$\n\\Phi = \\{0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330\\}.\n$$\n\nYour task is to implement a program that computes $R(\\varphi)$ for each $\\varphi \\in \\Phi$ for a baseline parameter set and for three altered parameter sets that change Starburst Amacrine Cell (SAC) kinetics, then extracts the preferred direction for each set and quantifies the shift in preferred direction caused by each alteration relative to the baseline.\n\nUse the following fixed constants across all test cases unless otherwise specified:\n- $A = 1.0$ (unitless intensity),\n- $\\sigma_s = 0.1$ degrees,\n- $\\sigma_e = 0.2$ degrees,\n- $\\tau_e = 0.010$ seconds,\n- $\\tau_i = 0.020$ seconds,\n- $g_i = 1.2$ (dimensionless),\n- $v = 5.0$ degrees per second,\n- $L = 0.8$ degrees,\n- $\\eta = 0.2$ (dimensionless),\n- $\\theta_{\\text{bias}} = 60$ degrees,\n- $T_{\\text{end}} = 0.5$ seconds,\n- spatial domain is a square grid spanning $[-1.5, 1.5]$ degrees in both coordinates with uniform spacing $0.05$ degrees,\n- time step is $\\Delta t = 0.001$ seconds.\n\nThe baseline parameter set is:\n- $\\tau_{\\text{sac0}} = 0.030$ seconds,\n- $d = 0.010$ seconds per degree,\n- $\\lambda = 0.50$ degrees.\n\nThe three altered parameter sets are:\n1. Slower base SAC delay: $\\tau_{\\text{sac0}} = 0.060$ seconds, $d = 0.010$ seconds per degree, $\\lambda = 0.50$ degrees.\n2. Stronger dendritic delay scaling: $\\tau_{\\text{sac0}} = 0.030$ seconds, $d = 0.025$ seconds per degree, $\\lambda = 0.50$ degrees.\n3. Tighter inhibitory spatial falloff: $\\tau_{\\text{sac0}} = 0.030$ seconds, $d = 0.010$ seconds per degree, $\\lambda = 0.25$ degrees.\n\nYou must:\n- Compute $R(\\varphi)$ for all $\\varphi \\in \\Phi$ for the baseline and each altered set.\n- Determine the preferred direction angle for the baseline, denoted $\\varphi_{\\text{PD,base}}$ in degrees.\n- Determine the preferred direction angle for each altered set, denoted $\\varphi_{\\text{PD,case}k}$ for $k \\in \\{1,2,3\\}$ in degrees.\n- Quantify the angular shift $\\Delta_k$ in degrees for each case $k$ as the minimal absolute difference on the circle between $\\varphi_{\\text{PD,case}k}$ and $\\varphi_{\\text{PD,base}}$, that is\n$$\n\\Delta_k = \\min_{m \\in \\mathbb{Z}} \\left| \\varphi_{\\text{PD,case}k} - \\varphi_{\\text{PD,base}} + 360 m \\right|,\n$$\nrestricted to the interval $[0, 180]$ degrees.\n\nAll angles in the program must be treated and reported in degrees. Time must be treated in seconds. Distances must be treated in degrees of visual angle.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and types:\n- $\\varphi_{\\text{PD,base}}$ as a float in degrees,\n- $\\Delta_1$ as a float in degrees,\n- $\\Delta_2$ as a float in degrees,\n- $\\Delta_3$ as a float in degrees.\n\nFor example, the output format must be exactly like\n$$\n[\\text{baseline\\_PD}, \\text{shift\\_case1}, \\text{shift\\_case2}, \\text{shift\\_case3}],\n$$\nwith each entry a float.\n\nTest Suite:\n- Baseline: $\\tau_{\\text{sac0}} = 0.030$, $d = 0.010$, $\\lambda = 0.50$.\n- Case 1: $\\tau_{\\text{sac0}} = 0.060$, $d = 0.010$, $\\lambda = 0.50$.\n- Case 2: $\\tau_{\\text{sac0}} = 0.030$, $d = 0.025$, $\\lambda = 0.50$.\n- Case 3: $\\tau_{\\text{sac0}} = 0.030$, $d = 0.010$, $\\lambda = 0.25$.\n\nYour solution must be a complete, runnable program that performs these computations numerically via discretization and prints the final line exactly as specified. No user input is needed.",
            "solution": "The solution requires a numerical simulation that discretizes the continuous model equations over spatial and temporal grids. The overall procedure loops through each of the four parameter sets (baseline and three alterations), and for each set, it iterates through the 12 specified stimulus directions $\\varphi$.\n\n**1. Numerical Setup:**\n- A spatial grid is defined over the domain $[-1.5, 1.5] \\times [-1.5, 1.5]$ degrees with a spacing of $0.05$ degrees. Spatial integrals are approximated as sums over this grid, with each term weighted by the area element $\\Delta A = (0.05)^2$.\n- A temporal grid is defined from $0$ to $0.5$ seconds with a time step of $\\Delta t = 0.001$ seconds. Temporal integrals and convolutions are replaced by their discrete counterparts (summation and discrete convolution, respectively).\n\n**2. Simulation Steps for each Direction $\\varphi$:**\n- **Stimulus Movie:** The stimulus $S(\\mathbf{r}, t)$, a moving Gaussian spot, is pre-calculated for all points on the spatial and temporal grids and stored as a 3D array (a \"movie\"). This allows for efficient lookup during the delay calculation.\n- **Excitatory Pathway $E(t)$:**\n    1. The raw excitatory drive is computed at each time step by performing a spatial integral (sum) of the stimulus movie multiplied by the fixed excitatory spatial weight $W_e(\\mathbf{r})$.\n    2. This time series is then convolved with the excitatory temporal kernel $k_e(t)$ to produce the final excitatory current $E(t)$.\n- **Inhibitory Pathway $I(t; \\varphi)$:**\n    1. The direction-dependent inhibitory weight $W_i(\\mathbf{r}, \\varphi)$ is calculated. This includes the centrifugal gating term $G(\\mathbf{r}, \\varphi)$, which depends on the stimulus direction.\n    2. The raw inhibitory drive $I_{\\text{raw}}(t; \\varphi)$ is computed. This is the most complex step. For each point on the spatial grid, a unique dendritic delay $\\tau_d(\\mathbf{r})$ is calculated. To find the stimulus value at the delayed time $t - \\tau_d(\\mathbf{r})$, which may not fall on a discrete time step, linear interpolation is used on the pre-computed stimulus movie.\n    3. The interpolated stimulus values are spatially integrated (summed) with the weight $W_i(\\mathbf{r}, \\varphi)$ to get the time series $I_{\\text{raw}}(t; \\varphi)$.\n    4. This time series is then convolved with the inhibitory temporal kernel $k_i(t)$ to yield the final inhibitory current $I(t; \\varphi)$.\n- **Response Calculation:**\n    1. The net synaptic drive $g(t; \\varphi) = E(t) - g_i I(t; \\varphi)$ is computed.\n    2. The total response $R(\\varphi)$ is calculated by integrating (summing) the half-wave rectified net drive over the simulation time.\n\n**3. Final Analysis:**\n- After computing $R(\\varphi)$ for all 12 directions for a given parameter set, the preferred direction (PD) is identified as the angle $\\varphi$ that yielded the maximum response.\n- This process is repeated for all four parameter sets. The angular shifts for the three altered cases are then calculated as the shortest angle on a circle between their respective PDs and the baseline PD.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the preferred direction (PD) of a model DSGC for a baseline and three\n    altered parameter sets, and calculates the shift in PD for each alteration.\n    \"\"\"\n\n    # --- Fixed constants and numerical parameters ---\n    A = 1.0  # Stimulus amplitude\n    SIGMA_S = 0.1  # Stimulus spatial std dev (deg)\n    SIGMA_E = 0.2  # Excitatory spatial std dev (deg)\n    TAU_E = 0.010  # Excitatory time constant (s)\n    TAU_I = 0.020  # Inhibitory time constant (s)\n    G_I = 1.2  # Inhibitory gain\n    V = 5.0  # Stimulus speed (deg/s)\n    L = 0.8  # Stimulus path start distance (deg)\n    ETA = 0.2  # Inhibitory modulation depth\n    THETA_BIAS_DEG = 60.0  # Inhibitory bias angle (deg)\n    T_END = 0.5  # Simulation end time (s)\n\n    # Discretization parameters\n    DX = 0.05  # Spatial step (deg)\n    DT = 0.001  # Time step (s)\n    \n    # Set of directions to test\n    PHI_DIRECTIONS = np.array([0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330], dtype=float)\n\n    # --- Parameter sets for the four cases ---\n    param_sets = [\n        # Baseline\n        {'tau_sac0': 0.030, 'd': 0.010, 'lambda': 0.50},\n        # Case 1: Slower base SAC delay\n        {'tau_sac0': 0.060, 'd': 0.010, 'lambda': 0.50},\n        # Case 2: Stronger dendritic delay scaling\n        {'tau_sac0': 0.030, 'd': 0.025, 'lambda': 0.50},\n        # Case 3: Tighter inhibitory spatial falloff\n        {'tau_sac0': 0.030, 'd': 0.010, 'lambda': 0.25},\n    ]\n\n    # --- Set up grids (do once to save computation) ---\n    x_coords = np.arange(-1.5, 1.5 + DX / 2, DX)\n    y_coords = np.arange(-1.5, 1.5 + DX / 2, DX)\n    t_coords = np.arange(0, T_END + DT / 2, DT)\n    \n    X, Y = np.meshgrid(x_coords, y_coords)\n    R = np.sqrt(X**2 + Y**2)\n    Theta = np.arctan2(Y, X) # atan2(y,x)\n    y_indices, x_indices = np.indices(X.shape)\n    \n    # Pre-compute static components\n    W_e = np.exp(-(R**2) / (2 * SIGMA_E**2))\n    \n    # Temporal kernels\n    kernel_e = (1 / TAU_E) * np.exp(-t_coords / TAU_E)\n    kernel_i = (1 / TAU_I) * np.exp(-t_coords / TAU_I)\n    \n    preferred_directions = []\n\n    for params in param_sets:\n        tau_sac0 = params['tau_sac0']\n        d_delay = params['d']\n        lambda_falloff = params['lambda']\n\n        responses = []\n        for phi_deg in PHI_DIRECTIONS:\n            phi_rad = np.deg2rad(phi_deg)\n            u = np.array([np.cos(phi_rad), np.sin(phi_rad)])\n\n            # --- Calculate Stimulus Movie S(t, y, x) ---\n            s_0 = -L * u\n            s_t = s_0[:, np.newaxis] + V * t_coords * u[:, np.newaxis] # Shape (2, N_t)\n            \n            # Use broadcasting for efficiency\n            dist_sq = (X[np.newaxis, :, :] - s_t[0, :, np.newaxis, np.newaxis])**2 + \\\n                      (Y[np.newaxis, :, :] - s_t[1, :, np.newaxis, np.newaxis])**2\n            \n            S_movie = A * np.exp(-dist_sq / (2 * SIGMA_S**2))\n\n            # --- Excitatory Pathway E(t) ---\n            Ie_t = np.sum(W_e * S_movie, axis=(1, 2)) * DX * DX\n            E_t = np.convolve(Ie_t, kernel_e, 'full')[:len(t_coords)] * DT\n\n            # --- Inhibitory Pathway I(t) ---\n            tau_d_grid = tau_sac0 + d_delay * R\n            \n            theta_bias_rad = np.deg2rad(THETA_BIAS_DEG)\n            M = 1 + ETA * np.cos(Theta - theta_bias_rad)\n            \n            dot_prod_over_R = np.divide(u[0] * X + u[1] * Y, R, out=np.zeros_like(R), where=R != 0)\n            G = np.heaviside(dot_prod_over_R, 0)\n            \n            W_i = np.exp(-R / lambda_falloff) * M * G\n\n            # Calculate I_raw(t) with time-delay interpolation\n            I_raw_t = np.zeros_like(t_coords)\n            for k, t_k in enumerate(t_coords):\n                delayed_times = t_k - tau_d_grid\n                delayed_indices_float = delayed_times / DT\n                \n                idx0 = np.floor(delayed_indices_float).astype(int)\n                idx1 = idx0 + 1\n                \n                # Interpolation weights\n                w1 = delayed_indices_float - idx0\n                w0 = 1.0 - w1\n                \n                # Clip indices to be within bounds of S_movie\n                np.clip(idx0, 0, len(t_coords) - 1, out=idx0)\n                np.clip(idx1, 0, len(t_coords) - 1, out=idx1)\n\n                # Advanced indexing to gather values for interpolation\n                S0 = S_movie[idx0, y_indices, x_indices]\n                S1 = S_movie[idx1, y_indices, x_indices]\n                \n                S_interp_k = S0 * w0 + S1 * w1\n                I_raw_t[k] = np.sum(W_i * S_interp_k * DX * DX)\n                \n            I_t = np.convolve(I_raw_t, kernel_i, 'full')[:len(t_coords)] * DT\n\n            # --- Net Drive and Response ---\n            g_t = E_t - G_I * I_t\n            R_phi = np.sum(np.maximum(0, g_t)) * DT\n            responses.append(R_phi)\n\n        pd_index = np.argmax(responses)\n        preferred_directions.append(PHI_DIRECTIONS[pd_index])\n\n    # --- Final Analysis ---\n    pd_base = preferred_directions[0]\n    pd_cases = preferred_directions[1:]\n    \n    shifts = []\n    for pd_case in pd_cases:\n        diff = np.abs(pd_case - pd_base)\n        shift = min(diff, 360.0 - diff)\n        shifts.append(shift)\n\n    results = [pd_base] + shifts\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}