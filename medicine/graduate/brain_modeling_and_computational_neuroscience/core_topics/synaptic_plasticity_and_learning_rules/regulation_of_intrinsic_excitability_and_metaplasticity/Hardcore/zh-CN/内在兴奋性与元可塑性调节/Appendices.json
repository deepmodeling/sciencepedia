{
    "hands_on_practices": [
        {
            "introduction": "理解复杂的神经元行为始于分析单个离子电流的作用。超极化激活的阳离子电流（$I_h$）在决定神经元的亚阈值特性中扮演着关键角色，它能产生一种被称为“电压凹陷”（voltage sag）的标志性响应。本练习将引导你通过定量分析，运用线性化这一核心的计算神经科学技巧，推导出输入电阻和电压凹陷幅度与 $I_h$ 电导之间的精确关系，从而加深对离子通道生物物理特性如何转化为可测量的细胞电生理特征的理解。",
            "id": "4014274",
            "problem": "一个单室神经元通过被动漏电和超极化激活的环核苷酸门控 (HCN) 电流（记作 $I_h$）进行建模。膜遵循电流守恒和门控的 Hodgkin–Huxley 形式，表示为\n$$C \\frac{dV}{dt} = -I_L - I_h + I_{\\mathrm{app}}(t),$$\n其中 $I_L = g_L\\,(V - E_L)$ 是漏电流，$I_h = g_h\\,m\\,(V - E_h)$ 是 HCN 电流，$g_L$ 和 $g_h$ 分别是漏电和 HCN 的最大电导，$E_L$ 和 $E_h$ 分别是漏电和 HCN 的反转电位，$m$ 是遵循一级动力学的 HCN 激活变量。在静息电压 $V_0$ 附近，假设扰动很小，因此稳态激活可以线性化为 $m_{\\infty}(V) \\approx m_0 + s\\,(V - V_0)$，其中 $m_0 = m_{\\infty}(V_0)$ 且 $s = \\left.\\frac{dm_{\\infty}}{dV}\\right|_{V_0}$。\n\n在 $t=0$ 时，施加一个短暂的超极化电流阶跃 $I_{\\mathrm{app}}(t) = I_0\\,H(t)$，其中 $I_0  0$，$H(t)$ 是赫维赛德阶跃函数。此处的 sag 幅度定义为：在 $t=0^{+}$ 时（此时 $m$ 尚未从 $m_0$ 改变）的初始峰值电压偏转与稳态电压偏转（在 $m$ 达到平衡后）之差的绝对值，除以初始峰值电压偏转的绝对值。输入电阻定义为：在 $|I_0|$ 很小时，稳态电压偏转除以所施加的电流幅度。\n\n仅使用上述定义和线性化假设，推导稳态输入电阻和归一化 sag 幅度的表达式，用 $g_L$、$g_h$、$m_0$、$s$ 和 $(V_0 - E_h)$ 表示。然后，对于基线参数值\n- $g_L = 10\\,\\mathrm{nS}$，\n- $g_h = 5\\,\\mathrm{nS}$，\n- $m_0 = 0.2$，\n- $s = -0.03\\,\\mathrm{mV}^{-1}$，\n- $V_0 = -65\\,\\mathrm{mV}$，\n- $E_h = -45\\,\\mathrm{mV}$，\n计算当 $g_h$ 增加 $0.40$（百分之四十）而所有其他参数保持不变时，稳态输入电阻的倍数变化和归一化 sag 幅度的倍数变化。\n\n按顺序以两个无量纲数报告您的最终答案：首先是输入电阻变化因子（新值除以基线值），其次是 sag 幅度变化因子（新值除以基线值）。将您的两个数字四舍五入到四位有效数字。最终答案中不需要单位。",
            "solution": "在尝试求解之前，将对问题进行验证。\n\n### 步骤 1：提取已知条件\n\n提供的数学模型和定义如下：\n- 膜电位动力学：$C \\frac{dV}{dt} = -I_L - I_h + I_{\\mathrm{app}}(t)$\n- 漏电流：$I_L = g_L\\,(V - E_L)$\n- HCN 电流：$I_h = g_h\\,m\\,(V - E_h)$\n- HCN 激活变量动力学：一级动力学，在静息电压 $V_0$ 附近稳态激活线性化为 $m_{\\infty}(V) \\approx m_0 + s\\,(V - V_0)$，其中 $m_0 = m_{\\infty}(V_0)$ 且 $s = \\left.\\frac{dm_{\\infty}}{dV}\\right|_{V_0}$。\n- 外加电流：$I_{\\mathrm{app}}(t) = I_0\\,H(t)$，其中 $I_0  0$，$H(t)$ 是赫维赛德阶跃函数。\n- Sag 幅度定义：“在 $t=0^{+}$ 时（此时 $m$ 尚未从 $m_0$ 改变）的初始峰值电压偏转与稳态电压偏转（在 $m$ 达到平衡后）之差的绝对值，除以初始峰值电压偏转的绝对值。”\n- 输入电阻定义：“在 $|I_0|$ 很小时，稳态电压偏转除以所施加的电流幅度。”\n\n基线参数值：\n- $g_L = 10\\,\\mathrm{nS}$\n- $g_h = 5\\,\\mathrm{nS}$\n- $m_0 = 0.2$\n- $s = -0.03\\,\\mathrm{mV}^{-1}$\n- $V_0 = -65\\,\\mathrm{mV}$\n- $E_h = -45\\,\\mathrm{mV}$\n\n任务要求：\n1.  用 $g_L$、$g_h$、$m_0$、$s$ 和 $(V_0 - E_h)$ 推导稳态输入电阻和归一化 sag 幅度的表达式。\n2.  计算当 $g_h$ 增加 $40\\%$ ($0.40$) 时，这两个量的倍数变化。\n3.  报告两个无量纲数，四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n该问题具有科学依据，描述了一个标准的单室 Hodgkin-Huxley 式神经元模型，这是计算神经科学中的一个基本模型。超极化激活电流（$I_h$）的使用和电压 sag 的分析是标准概念。围绕稳态对小扰动进行线性化的方法是一种有效且常用的分析技术。输入电阻和 sag 幅度的定义清晰且具有物理意义。所有术语都有定义，并且所提供的参数对于神经元来说在现实范围内。该问题是自洽的、客观的且适定的。未检测到科学、逻辑或事实上的缺陷。\n\n### 步骤 3：结论与行动\n\n问题有效。将提供完整解答。\n\n### 表达式推导\n\n首先，我们推导稳态输入电阻 $R_{in}$ 的表达式。输入电阻是为小电流注入定义的，这意味着我们可以在静息电位 $V_0$ 附近线性化系统的电流-电压（$I-V$）关系。在稳态下，一个恒定的外加电流 $I_0$ 会产生一个恒定的膜电位 $V_{ss}$，此时 $\\frac{dV}{dt} = 0$，门控变量 $m$ 已达到其稳态值 $m_{\\infty}(V_{ss})$。控制方程为：\n$$I_0 = I_L + I_h = g_L(V_{ss} - E_L) + g_h m_{\\infty}(V_{ss})(V_{ss} - E_h)$$\n流出细胞的总稳态电流为 $I_{ion}(V) = g_L(V - E_L) + g_h m_{\\infty}(V)(V - E_h)$。在静息状态（$t0$），$I_{\\mathrm{app}}=0$ 且 $V=V_0$，因此 $I_{ion}(V_0) = 0$。\n对于一个小的外加电流 $I_0$，产生的电压 $V_{ss}$ 接近 $V_0$。我们可以使用 $I_{ion}(V)$ 在 $V_0$ 附近的泰勒展开：\n$$I_0 = I_{ion}(V_{ss}) \\approx I_{ion}(V_0) + \\left.\\frac{dI_{ion}}{dV}\\right|_{V=V_0} (V_{ss} - V_0)$$\n因为 $I_{ion}(V_0) = 0$，我们有 $I_0 \\approx G_{ss}(V_{ss} - V_0)$，其中 $G_{ss}$ 是稳态电导。\n输入电阻为 $R_{in} = \\frac{V_{ss} - V_0}{I_0} = \\frac{1}{G_{ss}}$。我们通过对 $I_{ion}(V)$ 求导来计算 $G_{ss}$：\n$$G_{ss} = \\left.\\frac{dI_{ion}}{dV}\\right|_{V_0} = \\left.\\frac{d}{dV}\\left[ g_L(V - E_L) + g_h m_{\\infty}(V)(V - E_h) \\right]\\right|_{V_0}$$\n$$G_{ss} = g_L + g_h \\left[ \\left.\\frac{dm_{\\infty}}{dV}\\right|_{V_0}(V_0 - E_h) + m_{\\infty}(V_0) \\cdot 1 \\right]$$\n使用所给的记法 $m_{\\infty}(V_0) = m_0$ 和 $\\left.\\frac{dm_{\\infty}}{dV}\\right|_{V_0} = s$，我们得到：\n$$G_{ss} = g_L + g_h(m_0 + s(V_0 - E_h))$$\n因此，稳态输入电阻为：\n$$R_{in} = \\frac{1}{g_L + g_h(m_0 + s(V_0 - E_h))}$$\n\n接下来，我们推导归一化 sag 幅度 $S_A$。这需要求出初始峰值电压偏转 $\\Delta V_{peak}$ 和稳态电压偏转 $\\Delta V_{ss}$。\n稳态偏转为 $\\Delta V_{ss} = V_{ss} - V_0 = I_0 \\cdot R_{in} = I_0 / G_{ss}$。\n初始峰值偏转 $\\Delta V_{peak}$ 发生在 $t=0^+$，即电流阶跃施加后瞬间。在这一刻，电压可以改变，但门控变量 $m$ 还没有时间反应，因此它保持在刺激前的值 $m=m_0$。此刻膜的有效电导是“瞬时”电导 $G_{inst}$：\n$$G_{inst} = g_L + g_h m_0$$\n初始电压偏转由欧姆定律和这个瞬时电导给出：\n$$\\Delta V_{peak} = V(0^+) - V_0 = I_0 / G_{inst}$$\nsag 幅度 $S_A$ 定义为 $\\frac{|\\Delta V_{peak} - \\Delta V_{ss}|}{|\\Delta V_{peak}|}$。因为 $I_0  0$，两个偏转都是负的。sag 现象意味着初始超极化的幅度大于稳态超极化的幅度，即 $|\\Delta V_{peak}| > |\\Delta V_{ss}|$。\n$$S_A = \\frac{|\\Delta V_{peak}| - |\\Delta V_{ss}|}{|\\Delta V_{peak}|} = 1 - \\frac{|\\Delta V_{ss}|}{|\\Delta V_{peak}|}$$\n代入偏转的表达式：\n$$S_A = 1 - \\frac{|I_0 / G_{ss}|}{|I_0 / G_{inst}|} = 1 - \\frac{G_{inst}}{G_{ss}}$$\n代入电导的表达式：\n$$S_A = 1 - \\frac{g_L + g_h m_0}{g_L + g_h(m_0 + s(V_0 - E_h))} = \\frac{g_L + g_h m_0 + g_h s(V_0 - E_h) - (g_L + g_h m_0)}{g_L + g_h(m_0 + s(V_0 - E_h))}$$\n$$S_A = \\frac{g_h s(V_0 - E_h)}{g_L + g_h(m_0 + s(V_0 - E_h))}$$\n\n### 数值计算\n\n我们现在计算 $R_{in}$ 和 $S_A$ 的基线值和新值。\nsag 的驱动项是 $s(V_0 - E_h) = (-0.03\\,\\mathrm{mV}^{-1}) \\times ((-65\\,\\mathrm{mV}) - (-45\\,\\mathrm{mV})) = (-0.03) \\times (-20) = 0.6$。这是一个无量纲量。\n\n**基线计算 ($g_h = 5\\,\\mathrm{nS}$):**\n稳态电导为：\n$$G_{ss,base} = g_L + g_h(m_0 + s(V_0 - E_h))$$\n$$G_{ss,base} = 10\\,\\mathrm{nS} + 5\\,\\mathrm{nS} \\times (0.2 + 0.6) = 10\\,\\mathrm{nS} + 5\\,\\mathrm{nS} \\times 0.8 = 10\\,\\mathrm{nS} + 4\\,\\mathrm{nS} = 14\\,\\mathrm{nS}$$\n所以，$R_{in,base} = \\frac{1}{14\\,\\mathrm{nS}}$。\n基线 sag 幅度为：\n$$S_{A,base} = \\frac{g_h s(V_0 - E_h)}{G_{ss,base}} = \\frac{5\\,\\mathrm{nS} \\times 0.6}{14\\,\\mathrm{nS}} = \\frac{3}{14}$$\n\n**新计算（$g_h$ 增加 $40\\%$）:**\n新的 HCN 电导为 $g_{h,new} = g_h \\times (1+0.40) = 5\\,\\mathrm{nS} \\times 1.4 = 7\\,\\mathrm{nS}$。\n新的稳态电导为：\n$$G_{ss,new} = g_L + g_{h,new}(m_0 + s(V_0 - E_h))$$\n$$G_{ss,new} = 10\\,\\mathrm{nS} + 7\\,\\mathrm{nS} \\times (0.2 + 0.6) = 10\\,\\mathrm{nS} + 7\\,\\mathrm{nS} \\times 0.8 = 10\\,\\mathrm{nS} + 5.6\\,\\mathrm{nS} = 15.6\\,\\mathrm{nS}$$\n所以，$R_{in,new} = \\frac{1}{15.6\\,\\mathrm{nS}}$。\n新的 sag 幅度为：\n$$S_{A,new} = \\frac{g_{h,new} s(V_0 - E_h)}{G_{ss,new}} = \\frac{7\\,\\mathrm{nS} \\times 0.6}{15.6\\,\\mathrm{nS}} = \\frac{4.2}{15.6} = \\frac{42}{156} = \\frac{7}{26}$$\n\n**倍数变化因子：**\n\n1.  **输入电阻变化因子：**\n    $$\\frac{R_{in,new}}{R_{in,base}} = \\frac{1/G_{ss,new}}{1/G_{ss,base}} = \\frac{G_{ss,base}}{G_{ss,new}} = \\frac{14\\,\\mathrm{nS}}{15.6\\,\\mathrm{nS}} = \\frac{14}{15.6} = \\frac{140}{156} = \\frac{35}{39}$$\n    数值上，这是 $\\frac{35}{39} \\approx 0.89743589...$。四舍五入到四位有效数字，结果是 $0.8974$。\n\n2.  **Sag 幅度变化因子：**\n    $$\\frac{S_{A,new}}{S_{A,base}} = \\frac{7/26}{3/14} = \\frac{7}{26} \\times \\frac{14}{3} = \\frac{7 \\times (2 \\times 7)}{ (2 \\times 13) \\times 3} = \\frac{49}{39}$$\n    数值上，这是 $\\frac{49}{39} \\approx 1.25641025...$。四舍五入到四位有效数字，结果是 $1.256$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.8974  1.256\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "单个神经元的整合行为源于其多种离子电导的动态相互作用，并且这种行为并非一成不变，而是持续受到神经调控物质的重塑。M型钾电流（$I_M$）是乙酰胆碱等神经调控物质的关键靶点，对调节神经元的兴奋性和放电模式至关重要。通过这个编程练习，你将构建一个包含 $I_M$ 的电导模型，并用它作为虚拟实验室来探究抑制该电流如何影响神经元的频率-电流（f-I）增益和簇状放电行为，从而掌握从方程到功能预测的建模全过程。",
            "id": "4014311",
            "problem": "要求您实现并分析一个单室电导神经元模型，以量化胆碱能对毒蕈碱M型钾电流 ($I_M$) 的抑制如何改变频率-电流 ($f-I$) 增益和簇发放的可能性。该模型必须是 Hodgkin–Huxley 范式的一个具有物理意义的实例，使用 Morris–Lecar 电压门控钙电流和钾电流，并附加一个慢 $I_M$ 电流。核心膜动力学由标准的电流平衡定律和一阶门控动力学定义。\n\n模型说明：\n- 膜电位 $V$ 遵循电流平衡方程\n$$\nC \\frac{dV}{dt} = -\\left(I_L + I_{\\mathrm{Ca}} + I_{\\mathrm{K}} + I_M\\right) + I_{\\mathrm{app}}(t) + I_{\\mathrm{noise}}(t),\n$$\n其中 $C$ 是电容，$I_L$ 是漏电流，$I_{\\mathrm{Ca}}$ 是电压门控钙电流，$I_{\\mathrm{K}}$ 是延迟整流钾电流，$I_M$ 是毒蕈碱M型钾电流，$I_{\\mathrm{app}}(t)$ 是外部施加电流，$I_{\\mathrm{noise}}(t)$ 是附加噪声电流。\n- 电流由带有电压依赖性激活的欧姆定律给出：\n$$\nI_L = g_L \\left(V - E_L\\right), \\quad I_{\\mathrm{Ca}} = g_{\\mathrm{Ca}} m_{\\infty}(V)\\left(V - E_{\\mathrm{Ca}}\\right), \\quad I_{\\mathrm{K}} = g_{\\mathrm{K}} w \\left(V - E_{\\mathrm{K}}\\right), \\quad I_M = g_M q \\left(V - E_{\\mathrm{K}}\\right),\n$$\n其中 $g_L$、$g_{\\mathrm{Ca}}$、$g_{\\mathrm{K}}$ 和 $g_M$ 是电导，$E_L$、$E_{\\mathrm{Ca}}$ 和 $E_{\\mathrm{K}}$ 是反转电位，$w$ 是延迟整流激活变量，$q$ 是M电流激活变量。\n- 稳态激活和动力学为\n$$\nm_{\\infty}(V) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{V - V_1}{V_2}\\right)\\right],\n$$\n$$\nw_{\\infty}(V) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{V - V_3}{V_4}\\right)\\right], \\quad \\tau_w(V) = \\frac{1}{\\cosh\\left(\\frac{V - V_3}{2 V_4}\\right)},\n$$\n$$\n\\frac{dw}{dt} = \\phi \\frac{w_{\\infty}(V) - w}{\\tau_w(V)},\n$$\n对于M电流激活\n$$\nq_{\\infty}(V) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{V - V_{M,\\mathrm{half}}}{k_M}\\right)\\right], \\quad \\frac{dq}{dt} = \\frac{q_{\\infty}(V) - q}{\\tau_M}.\n$$\n\n物理单位和参数：\n- 使用 $V$ 的单位为毫伏 ($\\mathrm{mV}$)，时间 $t$ 的单位为毫秒 ($\\mathrm{ms}$)，电导 $g$ 的单位为微西门子 ($\\mathrm{\\mu S}$)，电容 $C$ 的单位为纳法拉 ($\\mathrm{nF}$)，电流 $I$ 的单位为纳安 ($\\mathrm{nA}$)。这些单位选择确保了当 $g$ 以微西门子为单位，$V - E$ 以毫伏为单位时，$I = g \\cdot (V - E)$ 的结果为纳安；当 $C$ 以纳法拉为单位，$\\frac{dV}{dt}$ 以 $\\mathrm{mV}/\\mathrm{ms}$ 为单位时，$C \\frac{dV}{dt}$ 的结果为纳安。\n- 使用以下固定参数：\n  - $C = 0.2$,\n  - $g_L = 2.0$, $E_L = -60.0$,\n  - $g_{\\mathrm{Ca}} = 4.0$, $E_{\\mathrm{Ca}} = 120.0$,\n  - $g_{\\mathrm{K}} = 8.0$, $E_{\\mathrm{K}} = -84.0$,\n  - $V_1 = -1.2$, $V_2 = 18.0$, $V_3 = 2.0$, $V_4 = 30.0$,\n  - $\\phi = 0.04$,\n  - $V_{M,\\mathrm{half}} = -35.0$, $k_M = 10.0$, $\\tau_M = 50.0$.\n- 仿真必须使用固定时间步长 $\\Delta t = 0.1$ 和欧拉方法进行数值积分。初始化 $V(0) = E_L$，$w(0) = w_{\\infty}(E_L)$ 和 $q(0) = q_{\\infty}(E_L)$。\n\n计算输出的定义：\n- 通过在 $V_{\\mathrm{th}} = 0.0$ 处向上穿越阈值来定义尖峰检测。一次从低于 $V_{\\mathrm{th}}$ 到高于 $V_{\\mathrm{th}}$ 的穿越计为一个尖峰。\n- 将发放速率（单位：赫兹）定义为尖峰数量除以测量窗口的持续时间（单位：秒）。对于$f-I$测量，丢弃前 $500.0$ 毫秒作为瞬态过程，并在剩余的仿真时间内进行测量。\n- 通过是否存在至少一对峰间期小于 $100.0$ 毫秒的尖峰来定义簇发放检测。如果在仿真窗口期间存在这样的一对尖峰，则该次试验被分类为一次簇发放。\n\n胆碱能抑制操纵：\n- 胆碱能抑制被建模为最大M电流电导的降低，从基线 $g_M$ 降至 $g_M' = \\max(0, g_M - \\Delta g_M)$，其中 $\\Delta g_M \\ge 0$ 由每个测试用例指定。\n\n每个测试用例所需的计算：\n1. 计算基线 $g_M$ 和受抑制 $g_M'$ 下的 $f-I$ 增益 $G$。增益是在五个恒定施加电流值 $I_{\\mathrm{app}} \\in \\{0.10, 0.15, 0.20, 0.25, 0.30\\}$ 纳安下，发放速率 $f$ 对电流 $I_{\\mathrm{app}}$ 的最佳拟合线的斜率。每个电流值仿真 $1500.0$ 毫秒，无噪声。使用最小二乘线性回归估计斜率。报告增益漂移 $\\Delta G = G(g_M') - G(g_M)$，单位为 $\\mathrm{Hz}/\\mathrm{nA}$。\n2. 在固定电流 $I_{\\mathrm{app}} = 0.22$ 纳安下，估计基线 $g_M$ 和受抑制 $g_M'$ 的簇发放概率。通过 $N_{\\mathrm{trials}}$ 次独立试验进行估计，每次试验持续 $1000.0$ 毫秒，并加入标准差为 $\\sigma_{\\mathrm{noise}}$ 纳安的附加高斯噪声 $I_{\\mathrm{noise}}(t)$。为保证可复现性，使用固定的随机种子。计算簇发放概率的增量 $\\Delta P = P(g_M') - P(g_M)$，以小数形式表示。\n\n测试套件：\n- 使用以下三个测试用例，每个都是一个元组 $(g_M, \\Delta g_M, \\sigma_{\\mathrm{noise}}, N_{\\mathrm{trials}})$：\n  1. $(2.0, 0.5, 0.02, 10)$,\n  2. $(2.0, 2.0, 0.01, 10)$,\n  3. $(2.0, 0.0, 0.03, 10)$.\n所有电导单位为 $\\mathrm{\\mu S}$，噪声单位为 $\\mathrm{nA}$，$N_{\\mathrm{trials}}$ 是一个整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序输出两个浮点数：增益漂移 $\\Delta G$（单位 $\\mathrm{Hz}/\\mathrm{nA}$），后跟簇发放概率增量 $\\Delta P$（以小数形式表示）。按顺序聚合所有测试用例的结果，形成一个包含六个数字的扁平列表。例如，输出应具有以下形式 $[x_1,y_1,x_2,y_2,x_3,y_3]$，其中每个 $x_i$ 和 $y_i$ 都是一个浮点数。以 $\\mathrm{Hz}/\\mathrm{nA}$ 表示 $\\Delta G$，以小数形式表示 $\\Delta P$。",
            "solution": "该问题要求实现并分析一个单室电导神经元模型，以研究胆碱能调制对神经元兴奋性的影响。胆碱能调制被建模为对一种缓慢、非失活的钾电流——M型电流 ($I_M$) 的抑制。分析侧重于兴奋性的两个关键指标：频率-电流 (f-I) 曲线的增益和簇发放的概率。\n\n该模型是 Morris-Lecar 模型的一个变体，增加了 M 电流，其动力学由一组遵循 Hodgkin-Huxley 范式的耦合常微分方程 (ODEs) 控制。\n\n首先，我们重申该模型的完整数学公式。\n\n膜电位 $V(t)$ 由电流平衡方程描述：\n$$\nC \\frac{dV}{dt} = -I_{\\mathrm{ion}} + I_{\\mathrm{ext}}\n$$\n其中 $C$ 是膜电容，$I_{\\mathrm{ext}} = I_{\\mathrm{app}}(t) + I_{\\mathrm{noise}}(t)$ 是总外部电流，$I_{\\mathrm{ion}}$ 是所有离子电流的总和：\n$$\nI_{\\mathrm{ion}} = I_L + I_{\\mathrm{Ca}} + I_{\\mathrm{K}} + I_M\n$$\n各电流定义如下：\n- 漏电流: $I_L = g_L (V - E_L)$\n- 电压门控钙电流: $I_{\\mathrm{Ca}} = g_{\\mathrm{Ca}} m_{\\infty}(V) (V - E_{\\mathrm{Ca}})$\n- 延迟整流钾电流: $I_K = g_K w (V - E_K)$\n- M型钾电流: $I_M = g_M q (V - E_K)$\n\n门控变量的动力学由一阶动力学描述。钙电流激活 $m$ 被假定为瞬时的，$m(t) = m_{\\infty}(V(t))$，其稳态值由一个S型函数给出：\n$$\nm_{\\infty}(V) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{V - V_1}{V_2}\\right)\\right]\n$$\n延迟整流钾电流激活 $w$ 遵循：\n$$\n\\frac{dw}{dt} = \\phi \\frac{w_{\\infty}(V) - w}{\\tau_w(V)}\n$$\n其中其稳态值和电压依赖性时间常数为：\n$$\nw_{\\infty}(V) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{V - V_3}{V_4}\\right)\\right]\n$$\n$$\n\\tau_w(V) = \\frac{1}{\\cosh\\left(\\frac{V - V_3}{2 V_4}\\right)}\n$$\nM电流激活 $q$ 具有较慢的动力学，由一个恒定的时间常数 $\\tau_M$ 控制：\n$$\n\\frac{dq}{dt} = \\frac{q_{\\infty}(V) - q}{\\tau_M}\n$$\n其稳态激活为：\n$$\nq_{\\infty}(V) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{V - V_{M,\\mathrm{half}}}{k_M}\\right)\\right]\n$$\n问题指定了所有参数值：$C=0.2\\,\\mathrm{nF}$，$g_L=2.0\\,\\mathrm{\\mu S}$，$E_L=-60.0\\,\\mathrm{mV}$，$g_{\\mathrm{Ca}}=4.0\\,\\mathrm{\\mu S}$，$E_{\\mathrm{Ca}}=120.0\\,\\mathrm{mV}$，$g_{\\mathrm{K}}=8.0\\,\\mathrm{\\mu S}$，$E_{\\mathrm{K}}=-84.0\\,\\mathrm{mV}$，$V_1=-1.2\\,\\mathrm{mV}$，$V_2=18.0\\,\\mathrm{mV}$，$V_3=2.0\\,\\mathrm{mV}$，$V_4=30.0\\,\\mathrm{mV}$，$\\phi=0.04$，$V_{M,\\mathrm{half}}=-35.0\\,\\mathrm{mV}$，$k_M=10.0\\,\\mathrm{mV}$，以及 $\\tau_M=50.0\\,\\mathrm{ms}$。\n\n该常微分方程组将使用时间步长为 $\\Delta t = 0.1\\,\\mathrm{ms}$ 的前向欧拉法进行数值求解。从时间 $t$ 到 $t + \\Delta t$，状态变量 $(V, w, q)$ 的离散化更新规则是：\n$$\nV(t+\\Delta t) = V(t) + \\frac{\\Delta t}{C} \\left[ -I_L(t) - I_{\\mathrm{Ca}}(t) - I_{\\mathrm{K}}(t) - I_M(t) + I_{\\mathrm{app}}(t) + I_{\\mathrm{noise}}(t) \\right]\n$$\n$$\nw(t+\\Delta t) = w(t) + \\Delta t \\cdot \\phi \\frac{w_{\\infty}(V(t)) - w(t)}{\\tau_w(V(t))}\n$$\n$$\nq(t+\\Delta t) = q(t) + \\Delta t \\cdot \\frac{q_{\\infty}(V(t)) - q(t)}{\\tau_M}\n$$\n初始条件设置为静息态：$V(0) = E_L$，$w(0) = w_{\\infty}(E_L)$ 和 $q(0) = q_{\\infty}(E_L)$。\n\n该分析对每个测试用例 $(g_M, \\Delta g_M, \\sigma_{\\mathrm{noise}}, N_{\\mathrm{trials}})$ 涉及两个主要计算：\n\n1.  **$f-I$ 增益漂移 ($\\Delta G$) 计算：**\n    $f-I$ 增益 $G$ 代表神经元发放速率对输入电流变化的敏感度。它被计算为发放速率 $f$ 相对于一组恒定施加电流 $I_{\\mathrm{app}} \\in \\{0.10, 0.15, 0.20, 0.25, 0.30\\}\\,\\mathrm{nA}$ 的线性回归斜率。在这些仿真中，噪声不存在 ($I_{\\mathrm{noise}}(t) = 0$)。每次仿真运行 $1500.0\\,\\mathrm{ms}$。尖峰被检测为向上穿越阈值 $V_{\\mathrm{th}} = 0.0\\,\\mathrm{mV}$。以赫兹为单位的发放速率是根据在 $t=500.0\\,\\mathrm{ms}$ 到 $t=1500.0\\,\\mathrm{ms}$ 的测量窗口内发生的尖峰计算的，以排除初始瞬态。整个过程对基线M电流电导 $g_M$ 和受抑制电导 $g_M' = \\max(0, g_M - \\Delta g_M)$ 都执行一次。最终报告的值是增益漂移 $\\Delta G = G(g_M') - G(g_M)$。一个正的 $\\Delta G$ 值标志着兴奋性的增加。\n\n2.  **簇发放概率增量 ($\\Delta P$) 计算：**\n    簇发放是一种以高频尖峰簇为特征的发放模式，尖峰簇之间由静息期分隔。在这里，如果任何峰间期 (ISI) 小于 $100.0\\,\\mathrm{ms}$，则一次试验被分类为包含簇发放。簇发放的概率 $P$ 是通过在固定输入电流 $I_{\\mathrm{app}} = 0.22\\,\\mathrm{nA}$ 下运行 $N_{\\mathrm{trials}}$ 次独立仿真来估计的，每次仿真持续 $1000.0\\,\\mathrm{ms}$。这些仿真包含一个附加高斯白噪声项 $I_{\\mathrm{noise}}(t)$，其标准差为 $\\sigma_{\\mathrm{noise}}\\cdot\\sqrt{1/\\Delta t}$，以确保注入电流的总方差与时间步长无关。概率 $P$ 是表现出簇发放的试验所占的比例。这个估计对 $g_M$ 和 $g_M'$ 都进行，关注的指标是簇发放概率的增量 $\\Delta P = P(g_M') - P(g_M)$。为保证可复现性，噪声生成过程使用固定的随机种子。\n\n实现将包括一个主仿真函数，该函数根据欧拉更新规则演化状态变量。该函数将被两个更高层次的分析函数调用，一个用于计算 $\\Delta G$，另一个用于计算 $\\Delta P$。主脚本将遍历所提供的测试用例，执行这些分析，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the neuron model simulations and analyses for all test cases.\n    \"\"\"\n    # Fixed model parameters\n    C = 0.2  # nF\n    G_L = 2.0  # µS\n    E_L = -60.0  # mV\n    G_CA = 4.0  # µS\n    E_CA = 120.0  # mV\n    G_K = 8.0  # µS\n    E_K = -84.0  # mV\n    V1 = -1.2  # mV\n    V2 = 18.0  # mV\n    V3 = 2.0  # mV\n    V4 = 30.0  # mV\n    PHI = 0.04\n    V_M_HALF = -35.0  # mV\n    K_M = 10.0  # mV\n    TAU_M = 50.0  # ms\n    V_TH = 0.0  # mV\n    DT = 0.1  # ms\n\n    # Pre-define activation functions for efficiency\n    def m_inf(v):\n        return 0.5 * (1.0 + np.tanh((v - V1) / V2))\n\n    def w_inf(v):\n        return 0.5 * (1.0 + np.tanh((v - V3) / V4))\n\n    def tau_w(v):\n        return 1.0 / np.cosh((v - V3) / (2.0 * V4))\n\n    def q_inf(v):\n        return 0.5 * (1.0 + np.tanh((v - V_M_HALF) / K_M))\n\n    def run_simulation(g_m, i_app, t_sim, sigma_noise=0.0):\n        \"\"\"\n        Runs a single trial of the neuron model simulation.\n        \"\"\"\n        num_steps = int(t_sim / DT)\n        t = np.linspace(0, t_sim, num_steps + 1)\n        v = np.zeros(num_steps + 1)\n        w = np.zeros(num_steps + 1)\n        q = np.zeros(num_steps + 1)\n\n        # Initial conditions\n        v[0] = E_L\n        w[0] = w_inf(v[0])\n        q[0] = q_inf(v[0])\n\n        # Noise term scaling:\n        # The noise I_noise(t) is additive white Gaussian noise. In a discrete simulation,\n        # we generate random numbers from N(0, sigma_noise). To make the variance\n        # of the integrated noise independent of dt, the noise term should be\n        # scaled by 1/sqrt(dt). So the current noise is N(0, sigma_noise^2 * (1/dt)).\n        noise_std_scaled = sigma_noise * np.sqrt(1.0 / DT)\n        noise = np.random.normal(0, noise_std_scaled, num_steps) if sigma_noise > 0 else np.zeros(num_steps)\n\n        for i in range(num_steps):\n            i_l = G_L * (v[i] - E_L)\n            i_ca = G_CA * m_inf(v[i]) * (v[i] - E_CA)\n            i_k = G_K * w[i] * (v[i] - E_K)\n            i_m = g_m * q[i] * (v[i] - E_K)\n            \n            i_total = -i_l - i_ca - i_k - i_m + i_app + noise[i]\n\n            v[i + 1] = v[i] + (DT / C) * i_total\n            w[i + 1] = w[i] + DT * PHI * (w_inf(v[i]) - w[i]) / tau_w(v[i])\n            q[i + 1] = q[i] + DT * (q_inf(v[i]) - q[i]) / TAU_M\n\n        spikes = (v[:-1]  V_TH)  (v[1:] >= V_TH)\n        spike_times = t[1:][spikes]\n        \n        return spike_times\n\n    def calculate_fi_gain(g_m):\n        \"\"\"\n        Calculates the f-I gain for a given M-current conductance.\n        \"\"\"\n        i_app_values = np.array([0.10, 0.15, 0.20, 0.25, 0.30])\n        rates = []\n        t_sim = 1500.0\n        t_transient = 500.0\n        \n        for i_app in i_app_values:\n            spike_times = run_simulation(g_m, i_app, t_sim, sigma_noise=0.0)\n            spikes_in_window = np.sum(spike_times > t_transient)\n            duration_s = (t_sim - t_transient) / 1000.0\n            rates.append(spikes_in_window / duration_s)\n        \n        rates = np.array(rates)\n        \n        # Linear regression using numpy.linalg.lstsq\n        A = np.vstack([i_app_values, np.ones(len(i_app_values))]).T\n        slope, _ = np.linalg.lstsq(A, rates, rcond=None)[0]\n        \n        return slope\n\n    def estimate_burst_prob(g_m, sigma_noise, n_trials):\n        \"\"\"\n        Estimates the burst probability for a given M-current conductance and noise level.\n        \"\"\"\n        i_app_fixed = 0.22\n        t_sim = 1000.0\n        burst_count = 0\n        min_isi_for_burst = 100.0\n        \n        for _ in range(n_trials):\n            spike_times = run_simulation(g_m, i_app_fixed, t_sim, sigma_noise=sigma_noise)\n            if len(spike_times) >= 2:\n                isis = np.diff(spike_times)\n                if np.any(isis  min_isi_for_burst):\n                    burst_count += 1\n        \n        return burst_count / n_trials\n\n    # Test suite from problem statement\n    test_cases = [\n        (2.0, 0.5, 0.02, 10),\n        (2.0, 2.0, 0.01, 10),\n        (2.0, 0.0, 0.03, 10),\n    ]\n\n    all_results = []\n    \n    # Set a global seed for reproducibility of the entire script\n    np.random.seed(42)\n\n    for g_m_base, delta_g_m, sigma_noise, n_trials in test_cases:\n        g_m_suppressed = max(0, g_m_base - delta_g_m)\n\n        # --- 1. Calculate f-I Gain Shift (Delta G) ---\n        gain_base = calculate_fi_gain(g_m_base)\n        gain_suppressed = calculate_fi_gain(g_m_suppressed)\n        delta_g = gain_suppressed - gain_base\n        all_results.append(delta_g)\n\n        # --- 2. Estimate Burst Probability Increase (Delta P) ---\n        prob_base = estimate_burst_prob(g_m_base, sigma_noise, n_trials)\n        prob_suppressed = estimate_burst_prob(g_m_suppressed, sigma_noise, n_trials)\n        delta_p = prob_suppressed - prob_base\n        all_results.append(delta_p)\n\n    # Print output in the required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在理解了特定电流如何影响神经元功能之后，一个更深层次的问题是：神经元如何长期维持其功能的稳定性？本练习将视角从具体的生物物理机制提升到抽象的调控法则层面。我们将稳态调节视为一个在电导参数空间中寻求并维持恒定输出（例如，放电率）的动力学过程，并在此基础上探索一种被称为“简并性”（degeneracy）的现象，即多种不同的电导组合可以产生相同的功能输出。通过推导和模拟在等活动水平流形上的运动，你将接触到一种关于元可塑性（metaplasticity）的强大理论框架——它解释了神经元如何在不改变其整体活动水平的情况下，调整其内在参数以应对未来的挑战。",
            "id": "4014285",
            "problem": "考虑一个简化的基于电导的神经元，其具有 2 个内在电导，由向量 $\\mathbf{g} = (g_1, g_2) \\in \\mathbb{R}^2$ 表示，其中 $g_1$ 和 $g_2$ 的单位是微西门子（$\\mu\\text{S}$）。输出发放频率被建模为一个饱和函数，它随内向电导的增加而增加，随外向电导的增加而减少，这与基于电导的神经元现象学一致。令发放频率定义为\n$$\nF(\\mathbf{g}) = F_{\\max} \\, \\sigma\\!\\left( \\alpha \\left( w_1 g_1 - w_2 g_2 + b \\right) \\right),\n$$\n其中 $F_{\\max}$ 的单位是赫兹（Hz），$\\alpha$ 是无量纲的，$w_1$ 和 $w_2$ 的单位是 $\\mu\\text{S}^{-1}$，$b$ 是无量纲的，并且 $\\sigma(x) = \\frac{1}{1 + e^{-x}}$ 是标准逻辑斯谛函数。该表示编码了一个被广泛观察到的事实：较高的内向电导和较低的外向电导会使发放频率增加，直至达到一个由不应期和尖峰生成极限决定的饱和水平。\n\n稳态调节旨在将输出发放频率维持在目标值 $R^*$（单位：Hz）。然后，元可塑性调节在保持输出不变的情况下重构内在电导，沿着电导空间中的等输出流形移动。我们采用一个两阶段程序：\n\n- 阶段 $1$（频率稳态）：使用最速下降法对误差泛函 $E(\\mathbf{g}) = \\frac{1}{2}\\left(F(\\mathbf{g}) - R^*\\right)^2$ 进行优化，调整 $\\mathbf{g}$ 以实现 $F(\\mathbf{g}) \\approx R^*$。\n- 阶段 $2$（元可塑性遍历）：从位于（或非常接近）等值集 $F(\\mathbf{g}) = R^*$ 上的初始 $\\mathbf{g}$ 出发，通过下降内在成本 $J(\\mathbf{g}) = \\frac{1}{2}\\|\\mathbf{g}\\|_2^2$（电导表达的类能量成本），同时施加约束 $F(\\mathbf{g}) = R^*$，沿着等输出流形移动。更新规则必须从约束优化和矢量微积分的第一性原理推导得出，以确保轨迹保持与等输出等值集相切。\n\n推导的基本依据：\n\n- 多元函数的链式法则以及 $\\mathbb{R}^n$ 中梯度的定义。\n- 对于可微目标函数 $\\Phi$ 和学习率 $\\eta > 0$ 的最速下降动力学 $\\frac{d\\mathbf{g}}{dt} = - \\eta \\nabla \\Phi(\\mathbf{g})$。\n- 拉格朗日乘子和在 $\\mathbb{R}^n$ 中对约束流形的正交投影。\n- 等值集 $F(\\mathbf{g}) = R^*$ 的切空间是 $\\nabla F(\\mathbf{g})^\\top$ 的零空间。\n\n任务：\n\n$1.$ 基于上述依据，推导阶段 $1$ 中 $\\mathbf{g}$ 的更新规则，该规则能减小 $E(\\mathbf{g})$ 并收敛到目标 $R^*$。使用 $\\nabla F(\\mathbf{g})$ 和链式法则，显式地求出梯度 $\\nabla E(\\mathbf{g})$。\n\n$2.$ 基于上述依据，推导阶段 $2$ 的更新规则，该规则能在保持在流形 $F(\\mathbf{g}) = R^*$ 上的同时使 $J(\\mathbf{g})$ 下降。你的推导必须给出一个显式公式，该公式表示 $J$ 的最速下降方向投影到 $F$ 的等值集的切空间上的方向。所得到的连续时间动力学在理想条件下（远离 $\\|\\nabla F(\\mathbf{g})\\|_2 = 0$ 的奇异点）必须满足 $\\frac{d}{dt} F(\\mathbf{g}) = 0$。实现一个具有小学习率的离散时间版本。为确保科学真实性，通过使用一个小的正常数对分母进行正则化来处理饱和区附近的数值奇异点。\n\n$3.$ 对下述每个测试用例模拟两阶段动力学。在阶段 $1$ 中，当 $|F(\\mathbf{g}) - R^*|  \\delta$ 或达到最大迭代次数时停止。在阶段 $2$ 中，记录固定步数下的路径 $\\{\\mathbf{g}_k\\}$。每次更新后，通过钳制操作施加非负性和电导上限 $g_{\\max}$，以反映生物物理极限。\n\n$4.$ 对每个模拟的阶段 $2$ 路径，计算以下几何与动力学指标：\n- 路径长度 $L = \\sum_{k} \\|\\Delta \\mathbf{g}_k\\|_2$，单位为 $\\mu\\text{S}$。\n- 沿离散路径的平均曲率 $\\bar{\\kappa}$，使用单位弧长的离散转角计算。具体来说，对于具有角度 $\\theta_k$（单位为弧度）和步长 $s_k = \\|\\Delta \\mathbf{g}_k\\|_2$（单位为 $\\mu\\text{S}$）的连续步进方向，使用 $\\kappa_k = \\frac{| \\Delta \\theta_k |}{s_k}$ 并报告所有有效步长的平均值。角度单位必须是弧度，曲率单位必须是弧度每微西门子。\n- 步进方向 $\\Delta \\mathbf{g}_k$ 与在 $\\mathbf{g}_k$ 处等值集的切线方向之间的平均对齐角 $\\bar{\\phi}$（单位为弧度）。切线方向是任何与 $\\nabla F(\\mathbf{g}_k)$ 正交的向量；使用 $\\nabla F(\\mathbf{g}_k)$ 的 $90^\\circ$ 旋转来构造这样一个切向量。角度单位必须是弧度。\n- 沿路径与目标输出的最大偏差，定义为 $\\max_k \\left|F(\\mathbf{g}_k) - R^*\\right|$，单位为 Hz。\n\n$5.$ 你的程序必须为下面的测试套件实现此模拟和指标计算，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。使用嵌套列表格式，其中每个测试用例按 $[L, \\bar{\\kappa}, \\bar{\\phi}, \\max \\text{ deviation}]$ 的顺序贡献一个子列表。例如，输出格式必须为 $[[x_1, x_2, x_3, x_4],[y_1, y_2, y_3, y_4],[z_1, z_2, z_3, z_4]]$ 的形式，其中所有条目都是浮点数。\n\n模型参数和测试套件：\n\n所有测试用例的通用模型参数（除非另有说明）：\n- $F_{\\max} = 100.0$ Hz\n- $\\alpha = 1.0$\n- $w_1 = 0.8$ $\\mu\\text{S}^{-1}$\n- $w_2 = 0.5$ $\\mu\\text{S}^{-1}$\n- $b = -2.0$\n- 非负性约束和上限 $g_{\\max} = 20.0$ $\\mu\\text{S}$\n- 用于涉及 $\\|\\nabla F(\\mathbf{g})\\|_2^2$ 的分母的正则化常数 $\\varepsilon = 10^{-12}$\n\n阶段 $1$ 控制参数（所有用例）：\n- 学习率 $\\gamma = 0.05$\n- 容差 $\\delta = 10^{-6}$ Hz\n- 最大迭代次数 $5000$\n\n阶段 $2$ 控制参数和初始条件：\n\n- 测试用例 $1$（投影流形遍历，中等步长）：\n  - 目标 $R^* = 50.0$ Hz\n  - 初始 $\\mathbf{g}_0 = (5.0, 8.0)$ $\\mu\\text{S}$\n  - 阶段 $2$ 学习率 $\\eta = 0.05$\n  - 步数 $N = 300$\n  - 遍历规则：沿流形的投影下降\n\n- 测试用例 $2$（非投影下降，中等步长；评估与流形的偏差）：\n  - 目标 $R^* = 50.0$ Hz\n  - 初始 $\\mathbf{g}_0 = (5.0, 8.0)$ $\\mu\\text{S}$\n  - 阶段 $2$ 学习率 $\\eta = 0.05$\n  - 步数 $N = 300$\n  - 遍历规则：对 $J(\\mathbf{g})$ 的朴素下降，无投影\n\n- 测试用例 $3$（饱和区附近的投影遍历，小步长；评估数值鲁棒性）：\n  - 目标 $R^* = 95.0$ Hz\n  - 初始 $\\mathbf{g}_0 = (15.0, 5.0)$ $\\mu\\text{S}$\n  - 阶段 $2$ 学习率 $\\eta = 0.01$\n  - 步数 $N = 500$\n  - 遍历规则：沿流形的投影下降\n\n输出规范：\n\n- 你的程序必须生成单行输出，其中包含一个嵌套列表 $[[L_1,\\bar{\\kappa}_1,\\bar{\\phi}_1,D_1],[L_2,\\bar{\\kappa}_2,\\bar{\\phi}_2,D_2],[L_3,\\bar{\\kappa}_3,\\bar{\\phi}_3,D_3]]$，其中 $L_i$ 以 $\\mu\\text{S}$ 报告，$\\bar{\\kappa}_i$ 以弧度每 $\\mu\\text{S}$ 报告，$\\bar{\\phi}_i$ 以弧度报告，$D_i$ 以 Hz 报告，所有值均为浮点数。",
            "solution": "该问题具有科学依据，定义明确，且所有必要的参数和条件均已提供。它代表了计算神经科学中的一项标准任务，涉及神经元稳态和元可塑性动力学规则的推导与模拟。因此，该问题被认为是有效的。\n\n解决方案分两部分展开：首先，推导两个调节阶段的更新规则；其次，实现模拟并计算指定的指标。\n\n### 学习规则的推导\n\n#### 阶段 1：频率稳态\n\n阶段 $1$ 的目标是调整电导向量 $\\mathbf{g} = (g_1, g_2)$，以使神经元的发放频率 $F(\\mathbf{g})$ 趋向目标频率 $R^*$。这通过对误差泛函 $E(\\mathbf{g}) = \\frac{1}{2}(F(\\mathbf{g}) - R^*)^2$ 执行最速下降来实现。连续时间动力学由 $\\frac{d\\mathbf{g}}{dt} = -\\gamma \\nabla E(\\mathbf{g})$ 给出，其中 $\\gamma > 0$ 是学习率。离散时间更新规则是 $\\mathbf{g}_{k+1} = \\mathbf{g}_k - \\gamma \\nabla E(\\mathbf{g}_k)$。\n\n为了实现这一点，我们必须首先计算误差的梯度 $\\nabla E(\\mathbf{g})$。使用多元函数的链式法则：\n$$\n\\nabla E(\\mathbf{g}) = \\frac{dE}{dF} \\frac{\\partial F}{\\partial \\mathbf{g}} = (F(\\mathbf{g}) - R^*) \\nabla F(\\mathbf{g})\n$$\n接下来，我们计算发放频率函数的梯度 $\\nabla F(\\mathbf{g})$。发放频率为 $F(\\mathbf{g}) = F_{\\max} \\sigma(x(\\mathbf{g}))$，其中 $x(\\mathbf{g}) = \\alpha (w_1 g_1 - w_2 g_2 + b)$。标准逻辑斯谛函数 $\\sigma(x)$ 的导数是 $\\sigma'(x) = \\sigma(x)(1 - \\sigma(x))$。再次应用链式法则：\n$$\n\\nabla F(\\mathbf{g}) = \\frac{\\partial F}{\\partial \\mathbf{g}} = F_{\\max} \\sigma'(x(\\mathbf{g})) \\nabla x(\\mathbf{g})\n$$\nsigmoid 函数的参数 $x(\\mathbf{g})$ 的梯度是：\n$$\n\\nabla x(\\mathbf{g}) = \\begin{pmatrix} \\frac{\\partial x}{\\partial g_1} \\\\ \\frac{\\partial x}{\\partial g_2} \\end{pmatrix} = \\begin{pmatrix} \\alpha w_1 \\\\ -\\alpha w_2 \\end{pmatrix} = \\alpha \\mathbf{w}\n$$\n其中我们定义权重向量 $\\mathbf{w} = (w_1, -w_2)^\\top$。\n\n代入 $\\nabla x(\\mathbf{g})$ 并用 $F(\\mathbf{g})$ 表示 $\\sigma'(x)$：\n$$\n\\sigma(x(\\mathbf{g})) = \\frac{F(\\mathbf{g})}{F_{\\max}} \\implies \\sigma'(x(\\mathbf{g})) = \\frac{F(\\mathbf{g})}{F_{\\max}} \\left(1 - \\frac{F(\\mathbf{g})}{F_{\\max}}\\right)\n$$\n因此，发放频率的梯度是：\n$$\n\\nabla F(\\mathbf{g}) = \\alpha F(\\mathbf{g}) \\left(1 - \\frac{F(\\mathbf{g})}{F_{\\max}}\\right) \\mathbf{w}\n$$\n最后，综合这些结果，误差泛函的梯度是：\n$$\n\\nabla E(\\mathbf{g}) = (F(\\mathbf{g}) - R^*) \\left[ \\alpha F(\\mathbf{g}) \\left(1 - \\frac{F(\\mathbf{g})}{F_{\\max}}\\right) \\mathbf{w} \\right]\n$$\n因此，阶段 $1$ 的离散时间更新规则是：\n$$\n\\mathbf{g}_{k+1} = \\mathbf{g}_k - \\gamma (F(\\mathbf{g}_k) - R^*) \\alpha F(\\mathbf{g}_k) \\left(1 - \\frac{F(\\mathbf{g}_k)}{F_{\\max}}\\right) \\mathbf{w}\n$$\n每一步之后，电导被钳制在生物物理上合理的范围 $[0, g_{\\max}]$ 内。\n\n#### 阶段 2：元可塑性遍历\n\n阶段 $2$ 的目标是在保持在由约束 $F(\\mathbf{g}) = R^*$ 定义的恒定发放频率流形上的同时，最小化内在成本 $J(\\mathbf{g}) = \\frac{1}{2}\\|\\mathbf{g}\\|_2^2$。这是一个约束优化问题。更新方向必须位于约束流形的切空间内。\n\n$J(\\mathbf{g})$ 的无约束最速下降方向是 $-\\nabla J(\\mathbf{g})$。由于 $J(\\mathbf{g}) = \\frac{1}{2}(g_1^2 + g_2^2)$，其梯度就是 $\\nabla J(\\mathbf{g}) = \\mathbf{g}$。无约束更新方向是 $-\\mathbf{g}$。\n\n在点 $\\mathbf{g}$ 处，等值集 $F(\\mathbf{g}) = R^*$ 的切空间是所有与梯度向量 $\\nabla F(\\mathbf{g})$（该向量垂直于等值集）正交的向量集合。为保持在流形上，更新向量必须位于此切空间内。我们通过将无约束下降方向 $-\\nabla J(\\mathbf{g})$ 投影到切空间上来实现这一点。\n\n一个向量 $\\mathbf{u}$ 到与法向量 $\\mathbf{n}$ 正交的切空间上的投影由 $\\mathbf{u}_{\\text{proj}} = \\mathbf{u} - \\frac{\\mathbf{u} \\cdot \\mathbf{n}}{\\|\\mathbf{n}\\|_2^2} \\mathbf{n}$ 给出。\n在这里，我们的向量是 $\\mathbf{u} = -\\nabla J(\\mathbf{g}) = -\\mathbf{g}$，法向量是 $\\mathbf{n} = \\nabla F(\\mathbf{g})$。投影后的更新方向 $\\mathbf{v}$ 是：\n$$\n\\mathbf{v} = (-\\mathbf{g}) - \\frac{(-\\mathbf{g}) \\cdot \\nabla F(\\mathbf{g})}{\\|\\nabla F(\\mathbf{g})\\|_2^2} \\nabla F(\\mathbf{g}) = - \\left( \\mathbf{g} - \\frac{\\mathbf{g} \\cdot \\nabla F(\\mathbf{g})}{\\|\\nabla F(\\mathbf{g})\\|_2^2} \\nabla F(\\mathbf{g}) \\right)\n$$\n连续时间动力学是 $\\frac{d\\mathbf{g}}{dt} = \\mathbf{v}$。为验证此流保持在流形上，我们检查是否有 $\\frac{d}{dt}F(\\mathbf{g}(t)) = 0$：\n$$\n\\frac{dF}{dt} = \\nabla F(\\mathbf{g})^\\top \\frac{d\\mathbf{g}}{dt} = \\nabla F(\\mathbf{g})^\\top \\mathbf{v} = -\\nabla F(\\mathbf{g})^\\top \\left( \\mathbf{g} - \\frac{\\mathbf{g}^\\top \\nabla F(\\mathbf{g})}{\\|\\nabla F(\\mathbf{g})\\|_2^2} \\nabla F(\\mathbf{g}) \\right) = - \\left( \\nabla F^\\top \\mathbf{g} - \\frac{\\mathbf{g}^\\top \\nabla F}{\\|\\nabla F\\|_2^2} (\\nabla F^\\top \\nabla F) \\right) = 0\n$$\n阶段 $2$ 的离散时间更新规则是 $\\mathbf{g}_{k+1} = \\mathbf{g}_k + \\Delta \\mathbf{g}_k$，其中学习率 $\\eta > 0$ 并引入正则化常数 $\\varepsilon > 0$ 以防止当 $\\|\\nabla F(\\mathbf{g})\\|_2$ 很小（即接近饱和）时出现除以零的情况：\n$$\n\\Delta \\mathbf{g}_k = - \\eta \\left( \\mathbf{g}_k - \\frac{\\mathbf{g}_k \\cdot \\nabla F(\\mathbf{g}_k)}{\\|\\nabla F(\\mathbf{g}_k)\\|_2^2 + \\varepsilon} \\nabla F(\\mathbf{g}_k) \\right)\n$$\n与阶段 $1$ 一样，每一步之后都应用到 $[0, g_{\\max}]$ 的钳制。对于测试用例 $2$ 中的“非投影”遍历，更新规则简化为 $\\Delta \\mathbf{g}_k = -\\eta \\nabla J(\\mathbf{g}_k) = -\\eta \\mathbf{g}_k$。\n\n### 模拟与指标计算\n\n模拟首先运行阶段 $1$ 以找到目标流形 $F(\\mathbf{g}) \\approx R^*$ 上的一个点 $\\mathbf{g}$。然后，以此点为初始条件，运行阶段 $2$ 固定步数，并记录轨迹 $\\{\\mathbf{g}_k\\}$。在阶段 $2$ 的路径上计算以下指标：\n- **路径长度 $L$**：轨迹的总长度，通过步进向量的欧几里得范数之和来近似：$L = \\sum_{k=0}^{N-1} \\|\\mathbf{g}_{k+1} - \\mathbf{g}_k\\|_2$。\n- **平均曲率 $\\bar{\\kappa}$**：沿路径的平均局部曲率。对于每对连续的非零步进 $\\Delta\\mathbf{g}_{k-1}$ 和 $\\Delta\\mathbf{g}_k$，转角为 $\\Delta\\theta_k = \\text{angle}(\\Delta\\mathbf{g}_k) - \\text{angle}(\\Delta\\mathbf{g}_{k-1})$，其中角度经过展开以处理周期性。离散曲率为 $\\kappa_k = |\\Delta\\theta_k| / \\|\\Delta\\mathbf{g}_k\\|_2$。平均值 $\\bar{\\kappa}$ 是在所有有效段上的平均。\n- **平均对齐角 $\\bar{\\phi}$**：实际步进方向 $\\Delta\\mathbf{g}_k$ 与在 $\\mathbf{g}_k$ 处等值集的理想切线方向之间的平均角度。切向量 $\\mathbf{t}_k$ 通过将法向量 $\\nabla F(\\mathbf{g}_k)$ 旋转 $90^\\circ$ 构造。该角度为 $\\phi_k = \\arccos\\left( \\frac{\\Delta\\mathbf{g}_k \\cdot \\mathbf{t}_k}{\\|\\Delta\\mathbf{g}_k\\|_2 \\|\\mathbf{t}_k\\|_2} \\right)$。$\\bar{\\phi}$ 是这些角度在整个路径上的平均值。\n- **最大偏差 $D$**：阶段 $2$ 路径上任意点的发放频率与目标频率之间的最大绝对差值，$D = \\max_k |F(\\mathbf{g}_k) - R^*|$。该指标量化了遍历过程对约束的遵守程度。\n\n该实现将这些推导和过程封装在一个 Python 脚本中，用于运行指定的测试用例并计算指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full simulation and metric calculation for the given problem.\n    \"\"\"\n\n    # Common model parameters\n    F_max = 100.0\n    alpha = 1.0\n    w1 = 0.8\n    w2 = 0.5\n    b = -2.0\n    g_max = 20.0\n    epsilon = 1e-12\n\n    # Vector form of weights for gradient calculation\n    w_vec = np.array([w1, -w2])\n\n    def sigma(x):\n        \"\"\"Standard logistic sigmoid function.\"\"\"\n        return 1.0 / (1.0 + np.exp(-x))\n\n    def F(g):\n        \"\"\"\n        Computes the firing rate for a given conductance vector g.\n        g can be a (2,) vector or a (2, M) array of M vectors.\n        \"\"\"\n        g1, g2 = g[0], g[1]\n        x = alpha * (w1 * g1 - w2 * g2 + b)\n        return F_max * sigma(x)\n\n    def nabla_F(g, f_val=None):\n        \"\"\"Computes the gradient of the firing rate function at a single point g.\"\"\"\n        if f_val is None:\n            f_val = F(g)\n        scalar_part = alpha * f_val * (1.0 - f_val / F_max)\n        return scalar_part * w_vec\n\n    def run_phase1(g0, R_star, gamma, delta, max_iter):\n        \"\"\"Runs the Phase 1 homeostasis simulation.\"\"\"\n        g = np.array(g0, dtype=float)\n        for _ in range(max_iter):\n            f_val = F(g)\n            if np.abs(f_val - R_star)  delta:\n                break\n            \n            grad_F = nabla_F(g, f_val)\n            grad_E = (f_val - R_star) * grad_F\n            g -= gamma * grad_E\n            g = np.clip(g, 0.0, g_max)\n        return g\n\n    def run_phase2(g0_phase2, R_star, eta, N, traversal_rule):\n        \"\"\"Runs the Phase 2 metaplastic traversal simulation.\"\"\"\n        path = [np.copy(g0_phase2)]\n        \n        for _ in range(N):\n            current_g = path[-1]\n            \n            if traversal_rule == 'projected':\n                grad_J = current_g\n                f_val = F(current_g)\n                grad_F = nabla_F(current_g, f_val)\n                \n                norm_grad_F_sq = np.sum(grad_F**2)\n                proj_term = (np.dot(grad_J, grad_F) / (norm_grad_F_sq + epsilon)) * grad_F\n                delta_g = -eta * (grad_J - proj_term)\n            \n            elif traversal_rule == 'unprojected':\n                grad_J = current_g\n                delta_g = -eta * grad_J\n            \n            g_next = current_g + delta_g\n            g_next = np.clip(g_next, 0.0, g_max)\n            path.append(g_next)\n            \n        return np.array(path)\n\n    def calculate_metrics(path, R_star, N):\n        \"\"\"Calculates the four specified metrics from the Phase 2 path.\"\"\"\n        # 1. Path Length L\n        steps = np.diff(path, axis=0)\n        step_sizes = np.linalg.norm(steps, axis=1)\n        path_length = np.sum(step_sizes)\n        \n        valid_steps_mask = step_sizes > epsilon\n        \n        # 2. Mean Curvature kappa_bar\n        if np.sum(valid_steps_mask)  2:\n            mean_curvature = 0.0\n        else:\n            valid_steps = steps[valid_steps_mask]\n            valid_step_sizes = step_sizes[valid_steps_mask]\n            \n            angles = np.arctan2(valid_steps[:, 1], valid_steps[:, 0])\n            unwrapped_angles = np.unwrap(angles)\n            delta_thetas = np.abs(np.diff(unwrapped_angles))\n            \n            kappa_denominators = valid_step_sizes[1:]\n            valid_kappa_mask = kappa_denominators > epsilon\n            \n            if np.sum(valid_kappa_mask) == 0:\n                mean_curvature = 0.0\n            else:\n                kappas = delta_thetas[valid_kappa_mask] / kappa_denominators[valid_kappa_mask]\n                mean_curvature = np.mean(kappas)\n\n        # 3. Mean Alignment Angle phi_bar\n        phi_angles = []\n        for k in range(N):\n            if not valid_steps_mask[k]:\n                continue\n                \n            gk = path[k]\n            delta_gk = steps[k]\n            \n            grad_F_k = nabla_F(gk)\n            tangent_k = np.array([-grad_F_k[1], grad_F_k[0]])\n            \n            norm_tangent_k = np.linalg.norm(tangent_k)\n            if norm_tangent_k  epsilon:\n                continue\n\n            cos_phi = np.dot(delta_gk, tangent_k) / (step_sizes[k] * norm_tangent_k)\n            cos_phi = np.clip(cos_phi, -1.0, 1.0)\n            phi_k = np.arccos(cos_phi)\n            phi_angles.append(phi_k)\n            \n        if not phi_angles:\n            mean_alignment_angle = 0.0\n        else:\n            mean_alignment_angle = np.mean(phi_angles)\n\n        # 4. Maximum Deviation D\n        f_values_on_path = F(path.T)\n        max_deviation = np.max(np.abs(f_values_on_path - R_star))\n        \n        return [path_length, mean_curvature, mean_alignment_angle, max_deviation]\n\n    # --- Main Execution ---\n    \n    # Phase 1 parameters\n    gamma_p1 = 0.05\n    delta_p1 = 1e-6\n    max_iter_p1 = 5000\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (R_star, g0, eta_p2, N_p2, rule)\n        {'R_star': 50.0, 'g0': (5.0, 8.0), 'eta': 0.05, 'N': 300, 'rule': 'projected'},\n        {'R_star': 50.0, 'g0': (5.0, 8.0), 'eta': 0.05, 'N': 300, 'rule': 'unprojected'},\n        {'R_star': 95.0, 'g0': (15.0, 5.0), 'eta': 0.01, 'N': 500, 'rule': 'projected'},\n    ]\n\n    results = []\n    for case in test_cases:\n        g0_phase2 = run_phase1(case['g0'], case['R_star'], gamma_p1, delta_p1, max_iter_p1)\n        path = run_phase2(g0_phase2, case['R_star'], case['eta'], case['N'], case['rule'])\n        metrics = calculate_metrics(path, case['R_star'], case['N'])\n        results.append(metrics)\n\n    # Format the final output string exactly as specified\n    sublist_strs = [f\"[{','.join(f'{x:.7f}' for x in r)}]\" for r in results]\n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}