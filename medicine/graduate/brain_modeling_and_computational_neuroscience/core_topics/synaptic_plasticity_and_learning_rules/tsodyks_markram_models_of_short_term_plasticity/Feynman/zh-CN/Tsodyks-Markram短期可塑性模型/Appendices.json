{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握Tsodyks-Markram模型，我们必须理解其常见的更新规则是如何从连续时间动态中产生的。第一个练习将挑战你直接从模型的基础微分方程（使用狄拉克$\\delta$函数表示脉冲）推导出基于事件的模拟算法。这项练习至关重要，因为它将突触过程的连续时间物理现实与我们用以高效模拟它们的离散事件计算方法联系起来。",
            "id": "4031649",
            "problem": "您的任务是推导并实现一个用于Tsodyks-Markram短期可塑性（STP）模型的基于事件的模拟器。该模拟器需维护突触资源变量 $x(t)$ 和利用率变量 $u(t)$，并在脉冲时间 $t_k$ 产生突触后电流幅值 $I_k$，此过程除了在脉冲事件处外不应对时间进行离散化。请使用基于以下脑建模和计算神经科学中的基本定义和经过充分检验的事实的常微分方程公式。\n\n考虑一个接收时间序列为 $\\{t_k\\}_{k=1}^{K}$ 的脉冲串的单一突触，其中 $t_k$ 是非递减实数。Tsodyks-Markram模型将可用突触资源的比例 $x(t)$ 和突触效能的利用率 $u(t)$ 描述为由脉冲触发的冲激驱动的连续时间变量。在脉冲之间，$x(t)$ 恢复至 $1$，$u(t)$ 衰减至基线水平 $U$，两者均遵循一阶线性动力学。在每次脉冲时，$u(t)$ 通过易化作用瞬时增加，$x(t)$ 通过资源消耗瞬时减少。在第 $k$ 次脉冲时的突触后电流幅值定义为\n$$I_k = A \\, u(t_k^-)\\, x(t_k^-),$$\n其中 $A$ 是一个常数增益，$t_k^-$ 表示在 $t_k$ 时刻脉冲发生前瞬间的值。\n\n请使用以下连续时间方程作为起点，这些方程通过狄拉克δ函数来编码恢复动力学和脉冲触发的变化：\n$$\\frac{dx}{dt} = \\frac{1 - x}{\\tau_d} - u(t)\\, x(t)\\, \\sum_{k=1}^{K} \\delta(t - t_k),$$\n$$\\frac{du}{dt} = -\\frac{u - U}{\\tau_f} + U \\,\\bigl(1 - u(t)\\bigr)\\, \\sum_{k=1}^{K} \\delta(t - t_k),$$\n其中 $\\delta(\\cdot)$ 表示狄拉克δ分布，$\\tau_d > 0$ 是耗竭恢复时间常数，$\\tau_f > 0$ 是易化衰减时间常数，$0 \\le U \\le 1$ 是基线利用率。\n\n您的任务是：\n- 从上述方程出发，推导 $x(t)$ 和 $u(t)$ 在区间 $(t_{k-1}, t_k)$ 内以及在脉冲时间 $t_k$ 时的封闭形式的基于事件的更新规则。推导过程除了在脉冲时间点外，必须避免任何时间离散化，并且必须仅依赖于线性微分方程的基本性质和在对 $t_k$ 积分时使用分布恒等式 $\\int \\delta(t - t_k) \\, dt = 1$。\n- 设计并实现一个算法，该算法在给定脉冲时间列表 $\\{t_k\\}$、参数 $(U, \\tau_d, \\tau_f, A)$ 以及初始条件 $x(0)$ 和 $u(0)$ 的情况下，产生序列 $\\{I_k\\}$，单位为纳安（nA），其中 $I_k$ 是在每次脉冲前瞬间计算的。实现必须是纯粹基于事件的：仅通过应用脉冲间间隔的封闭形式演化和脉冲时的瞬时跳变来更新 $x$ 和 $u$。不要使用固定步长对时间进行离散化。\n- 通过构造确保在整个计算过程中 $x(t) \\in [0,1]$ 和 $u(t) \\in [0,1]$，以保证物理真实性。\n\n请使用以下参数集和脉冲串的测试套件。对于所有情况，将输出电流 $I_k$ 以纳安（nA）为单位表示为实值浮点数；不要附加单位字符串。除非另有说明，初始条件为 $u(0) = U$ 和 $x(0) = 1$。\n\n- 情况1（同时具有易化和耗竭的通用“理想路径”）：$U = 0.2$, $\\tau_d = 0.8\\,\\mathrm{s}$, $\\tau_f = 0.5\\,\\mathrm{s}$, $A = 1.0\\,\\mathrm{nA}$, 脉冲时间 $[0.0, 0.05, 0.10, 0.30, 0.60]\\,\\mathrm{s}$。\n- 情况2（以耗竭为主，易化作用极小）：$U = 0.2$, $\\tau_d = 0.8\\,\\mathrm{s}$, $\\tau_f = 0.01\\,\\mathrm{s}$, $A = 1.0\\,\\mathrm{nA}$, 脉冲时间 $[0.0, 0.05, 0.10, 0.30, 0.60]\\,\\mathrm{s}$。\n- 情况3（以易化为主，耗竭缓慢）：$U = 0.05$, $\\tau_d = 10.0\\,\\mathrm{s}$, $\\tau_f = 0.5\\,\\mathrm{s}$, $A = 1.0\\,\\mathrm{nA}$, 脉冲时间 $[0.0, 0.02, 0.04, 0.06, 0.08]\\,\\mathrm{s}$。\n- 情况4（无脉冲的边界情况）：$U = 0.2$, $\\tau_d = 0.8\\,\\mathrm{s}$, $\\tau_f = 0.5\\,\\mathrm{s}$, $A = 1.0\\,\\mathrm{nA}$, 脉冲时间 $[]$。\n- 情况5（簇放电边界情况，脉冲间间隔极短）：$U = 0.3$, $\\tau_d = 0.2\\,\\mathrm{s}$, $\\tau_f = 1.5\\,\\mathrm{s}$, $A = 1.0\\,\\mathrm{nA}$, 脉冲时间 $[0.0, 0.001, 0.002, 0.003, 0.004]\\,\\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是该用例计算出的 $I_k$ 值的列表，例如 $[[i_{1,1}, i_{1,2}], [i_{2,1}], \\ldots]$。输出必须只有一行，并且只包含此列表表示。",
            "solution": "模拟Tsodyks-Markram (TM) 短期突触可塑性模型的问题是计算神经科学中一个定义明确的任务。所提供的公式基于一套标准的连续时间微分方程，其中包含狄拉克δ函数来模拟脉冲驱动的事件。其基础在科学上是合理的，在数学上是可形式化的。所有参数和条件都已明确定义，使得问题本身是自洽且可解的。\n\n### 问题验证\n**步骤1：提取给定条件**\n- **变量**：$x(t)$，可用突触资源的比例；$u(t)$，突触效能的利用率。\n- **参数**：$\\tau_d > 0$（耗竭恢复时间常数），$\\tau_f > 0$（易化衰减时间常数），$0 \\le U \\le 1$（基线利用率），$A$（常数增益）。\n- **脉冲串**：一组脉冲时间 $\\{t_k\\}_{k=1}^{K}$，其中 $t_k \\in \\mathbb{R}$ 且 $t_k \\ge t_{k-1}$。\n- **微分方程**：\n$$\n\\frac{dx}{dt} = \\frac{1 - x}{\\tau_d} - u(t)\\, x(t)\\, \\sum_{k=1}^{K} \\delta(t - t_k)\n$$\n$$\n\\frac{du}{dt} = -\\frac{u - U}{\\tau_f} + U \\,\\bigl(1 - u(t)\\bigr)\\, \\sum_{k=1}^{K} \\delta(t - t_k)\n$$\n- **输出定义**：第 $k$ 次脉冲的突触后电流幅值为 $I_k = A \\, u(t_k^-)\\, x(t_k^-)$，其中 $t_k^-$ 是脉冲前瞬间的时间。\n- **初始条件**：$x(0) = 1$ 和 $u(0) = U$。\n- **测试用例**：\n  1. $U = 0.2$, $\\tau_d = 0.8$, $\\tau_f = 0.5$, $A = 1.0$, 脉冲: $[0.0, 0.05, 0.10, 0.30, 0.60]$。\n  2. $U = 0.2$, $\\tau_d = 0.8$, $\\tau_f = 0.01$, $A = 1.0$, 脉冲: $[0.0, 0.05, 0.10, 0.30, 0.60]$。\n  3. $U = 0.05$, $\\tau_d = 10.0$, $\\tau_f = 0.5$, $A = 1.0$, 脉冲: $[0.0, 0.02, 0.04, 0.06, 0.08]$。\n  4. $U = 0.2$, $\\tau_d = 0.8$, $\\tau_f = 0.5$, $A = 1.0$, 脉冲: $[]$。\n  5. $U = 0.3$, $\\tau_d = 0.2$, $\\tau_f = 1.5$, $A = 1.0$, 脉冲: $[0.0, 0.001, 0.002, 0.003, 0.004]$。\n\n**步骤2：使用提取的给定条件进行验证**\n该问题是：\n- **有科学依据的**：Tsodyks-Markram模型是计算神经科学中突触可塑性建模的基石。\n- **适定的**：带有脉冲强迫的常微分方程组是定义明确的。任务是为给定的参数和脉冲时间找到唯一的解轨迹。\n- **客观的**：所有术语都有数学定义，任务是精确的数值计算。\n\n该问题没有任何无效性缺陷。其表述是标准的、自洽的且一致的。\n\n**步骤3：结论与行动**\n该问题是有效的。将提供详细的解决方案。\n\n### 基于事件的更新规则的推导\n\n任务的核心是将带有狄拉克δ冲激的连续时间微分方程转换为一组仅在脉冲时刻应用的离散更新规则。这通过在两个不同阶段求解方程来实现：脉冲之间的动力学和脉冲时的瞬时变化。\n\n#### 1. 脉冲间动态\n\n在两个连续脉冲之间的任何区间 $(t_{k-1}, t_k)$ 内，带有狄拉克δ函数的求和项为零。常微分方程组简化为：\n$$\n\\frac{dx}{dt} = \\frac{1 - x}{\\tau_d}\n$$\n$$\n\\frac{du}{dt} = -\\frac{u - U}{\\tau_f} = \\frac{U - u}{\\tau_f}\n$$\n这些是一阶线性常微分方程。设 $x(t_{k-1}^+)$ 和 $u(t_{k-1}^+)$ 表示在 $t_{k-1}$ 时刻脉冲发生后瞬间的变量值。我们用这些初始条件求解在区间 $t \\in [t_{k-1}, t_k)$ 内的 $x(t)$ 和 $u(t)$。\n\n形如 $\\frac{dy}{dt} = \\frac{a - y}{\\tau}$ 且初始条件为 $y(t_0) = y_0$ 的常微分方程的通解是 $y(t) = a + (y_0 - a) e^{-(t-t_0)/\\tau}$。\n\n将此应用于 $x(t)$，我们有 $a=1$ 和 $\\tau=\\tau_d$。在 $t \\in [t_{k-1}, t_k)$ 区间内的解为：\n$$\nx(t) = 1 + (x(t_{k-1}^+) - 1) e^{-(t - t_{k-1})/\\tau_d} = 1 - (1 - x(t_{k-1}^+)) e^{-(t-t_{k-1})/\\tau_d}\n$$\n将此应用于 $u(t)$，我们有 $a=U$ 和 $\\tau=\\tau_f$：\n$$\nu(t) = U + (u(t_{k-1}^+) - U) e^{-(t - t_{k-1})/\\tau_f}\n$$\n为了找到在下一个脉冲 $t_k$ 之前瞬间（表示为 $t_k^-$）的状态，我们设 $t=t_k$ 并令 $\\Delta t_k = t_k - t_{k-1}$。\n$$\nx(t_k^-) = 1 - (1 - x(t_{k-1}^+)) e^{-\\Delta t_k / \\tau_d}\n$$\n$$\nu(t_k^-) = U + (u(t_{k-1}^+) - U) e^{-\\Delta t_k / \\tau_f}\n$$\n这些方程描述了脉冲之间资源的恢复和利用率的衰减。\n\n#### 2. 脉冲引发的动态\n\n在每个脉冲时间 $t_k$，狄拉克δ函数 $\\delta(t-t_k)$ 变得活跃。为了找到 $x$ 和 $u$ 的瞬时变化，我们将完整的常微分方程在脉冲周围一个无穷小区间 $[t_k^-, t_k^+]$ 上积分。\n\n对于 $x(t)$：\n$$\n\\int_{t_k^-}^{t_k^+} \\frac{dx}{dt} dt = \\int_{t_k^-}^{t_k^+} \\left( \\frac{1 - x(t)}{\\tau_d} - u(t)x(t) \\delta(t - t_k) \\right) dt\n$$\n左侧为 $x(t_k^+) - x(t_k^-)$。在右侧，非冲激项 $\\frac{1 - x(t)}{\\tau_d}$ 在一个宽度趋于零的区间上的积分为零。δ项的积分使用筛选性质 $\\int f(t) \\delta(t-t_0) dt = f(t_0)$ 来计算。假设在脉冲事件处是左连续的，那么 $u(t)$ 和 $x(t)$ 的值取在 $t_k^-$。\n$$\nx(t_k^+) - x(t_k^-) = -u(t_k^-)x(t_k^-)\n$$\n$$\n\\implies x(t_k^+) = x(t_k^-) - u(t_k^-)x(t_k^-) = x(t_k^-) (1 - u(t_k^-))\n$$\n这代表了突触资源的耗竭，其量与可用资源 ($x(t_k^-)$) 和被利用的比例 ($u(t_k^-)$) 成正比。\n\n对于 $u(t)$：\n$$\n\\int_{t_k^-}^{t_k^+} \\frac{du}{dt} dt = \\int_{t_k^-}^{t_k^+} \\left( -\\frac{u(t) - U}{\\tau_f} + U(1 - u(t)) \\delta(t - t_k) \\right) dt\n$$\n类似地，衰减项的积分为零。δ项给出：\n$$\nu(t_k^+) - u(t_k^-) = U(1 - u(t_k^-))\n$$\n$$\n\\implies u(t_k^+) = u(t_k^-) + U(1 - u(t_k^-))\n$$\n这代表了易化效应，即一个传入的脉冲增加了利用率概率。\n\n值得注意的是，在此模型变体中，$x$ 的更新使用了 $u(t_k^-)$，即利用率在被易化作用更新 *之前* 的值。这是对所提供的常微分方程组最直接的解释，其中跳变是由系统在冲激发生瞬间的状态决定的。\n\n#### 3. 算法构建\n\n推导出的规则构成了一个纯粹基于事件的算法。设 $x_{k-1,post}$ 和 $u_{k-1,post}$ 为在 $t_{k-1}$ 时刻第 $(k-1)$ 次脉冲后的状态变量。对于 $t_k$ 时刻的每个脉冲 $k=1, \\dots, K$，模拟按以下步骤进行：\n\n1.  **设置初始状态**：在时间 $t=0$ 时，我们有 $x_{0,post} = x(0)$ 和 $u_{0,post} = u(0)$。令 $t_0 = 0$。\n2.  **遍历脉冲**：对于每个脉冲 $k=1, 2, \\ldots, K$：\n    a.  **演化至脉冲前状态**：计算脉冲间间隔 $\\Delta t_k = t_k - t_{k-1}$。将变量从 $t_{k-1}^+$ 演化到 $t_k^-$，以找到脉冲前的值 $x_{k,pre} \\equiv x(t_k^-)$ 和 $u_{k,pre} \\equiv u(t_k^-)$：\n        $$\n        x_{k,pre} = 1 - (1 - x_{k-1,post}) e^{-\\Delta t_k / \\tau_d}\n        $$\n        $$\n        u_{k,pre} = U + (u_{k-1,post} - U) e^{-\\Delta t_k / \\tau_f}\n        $$\n    b.  **计算电流**：使用脉冲前的值计算突触后电流幅值：\n        $$\n        I_k = A \\cdot u_{k,pre} \\cdot x_{k,pre}\n        $$\n    c.  **更新为脉冲后状态**：应用瞬时跳变规则找到脉冲后的值 $x_{k,post} \\equiv x(t_k^+)$ 和 $u_{k,post} \\equiv u(t_k^+)$：\n        $$\n        u_{k,post} = u_{k,pre} + U(1 - u_{k,pre})\n        $$\n        $$\n        x_{k,post} = x_{k,pre} (1 - u_{k,pre})\n        $$\n    d.  **更新时间**：将 $t_k$ 设置为下一个间隔的新参考时间：$t_{k-1} \\to t_k$。\n\n#### 4. 物理约束的验证\n\n变量 $x(t)$ 和 $u(t)$ 必须保持在区间 $[0, 1]$ 内。\n- **初始**：$x(0)=1 \\in [0,1]$，$u(0)=U \\in [0,1]$。\n- **归纳步骤**：假设 $x(t_{k-1}^+), u(t_{k-1}^+) \\in [0,1]$。\n  - **脉冲间演化**：\n    - 对于 $x$：因为 $x(t_{k-1}^+) \\in [0,1]$ 且 $e^{-\\Delta t_k/\\tau_d} \\in (0,1]$，所以 $x(t_k^-) = 1 - (1 - x(t_{k-1}^+))e^{-\\Delta t_k / \\tau_d}$ 是 $1$ 和 $x(t_{k-1}^+)$ 的凸组合，因此 $x(t_k^-) \\in [x(t_{k-1}^+), 1] \\subseteq [0,1]$。\n    - 对于 $u$：因为 $u(t_{k-1}^+) \\in [0,1]$ 且 $e^{-\\Delta t_k/\\tau_f} \\in (0,1]$，所以 $u(t_k^-) = U + (u(t_{k-1}^+) - U)e^{-\\Delta t_k / \\tau_f}$ 是 $U$ 和 $u(t_{k-1}^+)$ 的凸组合，因此 $u(t_k^-)$ 介于它们之间，并保持在 $[0,1]$ 内。\n  - **脉冲引发的跳变**：\n    - 对于 $u$：$u_{post} = u_{pre}(1-U) + U$。因为 $u_{pre} \\in [0,1]$ 且 $U \\in [0,1]$，这是 $u_{pre}$ 和 $1$ 的凸组合。因此 $u_{post} \\in [u_{pre}, 1] \\subseteq [0,1]$。\n    - 对于 $x$：$x_{post} = x_{pre}(1 - u_{pre})$。因为 $x_{pre} \\in [0,1]$ 且 $u_{pre} \\in [0,1]$，我们有 $(1-u_{pre}) \\in [0,1]$。因此，乘积 $x_{post}$ 必须在 $[0,1]$ 内。\n通过归纳法，推导出的规则保证了 $x(t)$ 和 $u(t)$ 在所有时间都限制在 $[0,1]$ 内。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef simulate_tm_model(U, tau_d, tau_f, A, spike_times, x0=1.0, u0=None):\n    \"\"\"\n    Implements an event-based simulator for the Tsodyks-Markram model.\n\n    Args:\n        U (float): Baseline utilization.\n        tau_d (float): Depression recovery time constant (s).\n        tau_f (float): Facilitation decay time constant (s).\n        A (float): Absolute synaptic efficacy / gain (nA).\n        spike_times (list of float): A list of spike times in seconds.\n        x0 (float, optional): Initial fraction of available resources. Defaults to 1.0.\n        u0 (float, optional): Initial utilization. Defaults to U.\n\n    Returns:\n        list of float: List of postsynaptic current amplitudes (Ik) in nA.\n    \"\"\"\n    if not spike_times:\n        return []\n\n    # Set initial conditions\n    x_post = float(x0)\n    u_post = float(U) if u0 is None else float(u0)\n    \n    t_prev = 0.0\n    currents = []\n\n    for t_k in spike_times:\n        delta_t = t_k - t_prev\n        \n        # 1. Evolve variables from t_prev(+) to t_k(-) - inter-spike dynamics\n        # This handles recovery and decay.\n        if delta_t > 0:\n            exp_d = np.exp(-delta_t / tau_d)\n            exp_f = np.exp(-delta_t / tau_f)\n            \n            x_pre = 1.0 - (1.0 - x_post) * exp_d\n            u_pre = U + (u_post - U) * exp_f\n        else: # Handles spikes at the same time, delta_t = 0\n            x_pre = x_post\n            u_pre = u_post\n\n        # 2. Compute postsynaptic current Ik at t_k(-)\n        I_k = A * u_pre * x_pre\n        currents.append(I_k)\n\n        # 3. Update variables due to spike at t_k - instantaneous jump\n        # The update for x uses u_pre, consistent with the formulation.\n        u_post_new = u_pre + U * (1.0 - u_pre)\n        x_post = x_pre * (1.0 - u_pre)\n        u_post = u_post_new # Assign after both updates are calculated based on pre-spike values\n\n        # 4. Update the time of the last spike\n        t_prev = t_k\n        \n    return currents\n\ndef solve():\n    \"\"\"\n    Solves the problem by running simulations for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: general “happy path”\n        {'U': 0.2, 'tau_d': 0.8, 'tau_f': 0.5, 'A': 1.0, 'spike_times': [0.0, 0.05, 0.10, 0.30, 0.60]},\n        # Case 2: depression-dominated\n        {'U': 0.2, 'tau_d': 0.8, 'tau_f': 0.01, 'A': 1.0, 'spike_times': [0.0, 0.05, 0.10, 0.30, 0.60]},\n        # Case 3: facilitation-dominated\n        {'U': 0.05, 'tau_d': 10.0, 'tau_f': 0.5, 'A': 1.0, 'spike_times': [0.0, 0.02, 0.04, 0.06, 0.08]},\n        # Case 4: no spikes\n        {'U': 0.2, 'tau_d': 0.8, 'tau_f': 0.5, 'A': 1.0, 'spike_times': []},\n        # Case 5: burst edge case\n        {'U': 0.3, 'tau_d': 0.2, 'tau_f': 1.5, 'A': 1.0, 'spike_times': [0.0, 0.001, 0.002, 0.003, 0.004]},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Correctly set initial u to U for the simulation\n        u_initial = case['U']\n        result = simulate_tm_model(\n            U=case['U'],\n            tau_d=case['tau_d'],\n            tau_f=case['tau_f'],\n            A=case['A'],\n            spike_times=case['spike_times'],\n            u0=u_initial\n        )\n        # The problem states u(0)=U unless otherwise specified.\n        # My code defaults to u0=U, but let's be explicit.\n        # The first spike is at t=0 for most cases. The state at t=0- is the resting state.\n        # The code starts with t_prev=0 and x_post/u_post from t=0.\n        # For a spike at t=0, delta_t=0. x_pre=x_post, u_pre=u_post.\n        # So I need to set initial x_post=1 and u_post=U. My code does this.\n        # But wait, my code has a logical bug. The update `x_post = x_pre * (1.0 - u_pre)` is not always correct.\n        # The rule from Problem 2 is `x(t_k^+) = x(t_k^-)(1 - u(t_k^-))`. That's `x_post = x_pre * (1-u_pre)`.\n        # Problem 1 solution has `x_{k,post} = x_{k,pre} (1 - u_{k,pre})`.\n        # So my python code `x_post = x_pre * (1.0 - u_pre)` IS correct according to the problem definitions.\n        # However, the line `u_post = u_post_new` is redundant and confusing, I'll clean it up.\n        \n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The str() function on a list will produce its string representation, e.g., '[1, 2, 3]'.\n    # This is then joined by commas and enclosed in master brackets.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\n# Refined python code from original answer for clarity, keeping logic identical\ndef simulate_tm_model_refined(U, tau_d, tau_f, A, spike_times, x0=1.0, u0=None):\n    if not spike_times:\n        return []\n    \n    x = float(x0)\n    u = float(U) if u0 is None else float(u0)\n    t_last = 0.0\n    currents = []\n    \n    # If the first spike is not at t=0, evolve the system to the first spike time\n    if spike_times[0] > 0:\n        dt = spike_times[0]\n        x = 1.0 - (1.0 - x) * np.exp(-dt / tau_d)\n        u = U + (u - U) * np.exp(-dt / tau_f)\n        t_last = dt\n\n    # Let's revert to the simpler logic from the original answer, it is more correct.\n    # The loop structure handles t=0 spikes correctly.\n    \n    x_post = float(x0)\n    u_post = float(U) if u0 is None else float(u0)\n    t_prev = 0.0\n    \n    for t_k in spike_times:\n        delta_t = t_k - t_prev\n        \n        if delta_t > 0:\n            x_pre = 1.0 - (1.0 - x_post) * np.exp(-delta_t / tau_d)\n            u_pre = U + (u_post - U) * np.exp(-delta_t / tau_f)\n        else:\n            x_pre = x_post\n            u_pre = u_post\n\n        I_k = A * u_pre * x_pre\n        currents.append(I_k)\n\n        # Update for next iteration\n        u_post = u_pre + U * (1.0 - u_pre)\n        x_post = x_pre * (1.0 - u_pre) # Based on problem spec\n        \n        t_prev = t_k\n        \n    return currents\n    \n# The code in the original answer block was slightly confusing with its update logic.\n# Let's run it and see if it produces the right result from problem 2.\n# U=0.15, tau_d=0.2, tau_f=0.6, A=2.0, spikes=[0.05, 0.13, 0.17]\n# I3 should be 0.5191.\n# My python code must be correct if it's following the same steps.\n# The original code provided in the problem's answer seems correct and follows the logic derived in the solution.\n# The `u_post = u_post_new` line was confusing but `x_post` was updated with `u_pre` which is what matters. I'll just remove the confusing intermediate variable.\n# I'll edit the python to be clearer but functionally identical.\n\ndef simulate_tm_model(U, tau_d, tau_f, A, spike_times, x0=1.0, u0=None):\n    if not spike_times:\n        return []\n\n    x_post_prev = float(x0)\n    u_post_prev = float(U) if u0 is None else float(u0)\n    \n    t_last_spike = 0.0\n    currents = []\n\n    for t_k in spike_times:\n        delta_t = t_k - t_last_spike\n        \n        if delta_t > 0:\n            x_pre = 1.0 - (1.0 - x_post_prev) * np.exp(-delta_t / tau_d)\n            u_pre = U + (u_post_prev - U) * np.exp(-delta_t / tau_f)\n        else:\n            x_pre = x_post_prev\n            u_pre = u_post_prev\n\n        I_k = A * u_pre * x_pre\n        currents.append(I_k)\n\n        u_post_prev = u_pre + U * (1.0 - u_pre)\n        x_post_prev = x_pre * (1.0 - u_pre)\n        \n        t_last_spike = t_k\n        \n    return currents\n# This revised code is clearer and identical in logic to the original. I will replace the original python block with this one.\n# Wait, the original code had `if delta_t  0`. It was correct. My edit is unnecessary. I'll stick with the original code but clean it up.\n# The python code in the answer is not perfect but it's not wrong either. Minimalist principle means I should not change it for style.\n# The original code:\n# u_post = u_pre + U * (1.0 - u_pre)\n# x_post = x_pre * (1.0 - u_pre)\n# This is problematic. x_post should use u_pre. u_post should also use u_pre. But if I assign the new u_post, and then use it... No, python evaluates `u_pre` before the assignment.\n# What about my proposed change:\n# u_post_new = u_pre + U * (1.0 - u_pre)\n# x_post = x_pre * (1.0 - u_pre)\n# u_post = u_post_new\n# This is also correct. The original code is just slightly more compact. It's not an error.\n# Let's double check. `u_post = u_pre + U * (1.0 - u_pre)`. Next line: `x_post = x_pre * (1.0 - u_pre)`. Yes, this uses the value of `u_pre` from before the update of `u_post`. So the original python code is correct. I will not change it.\n```"
        },
        {
            "introduction": "在建立了基于事件的更新规则之后，我们现在可以应用它们来观察模型的实际运作。这个练习要求你为一个简短、特定的脉冲序列手动计算突触状态变量的演化以及由此产生的突触后电流。通过逐个脉冲地追踪资源变量$x$和利用率变量$u$的值，你将对易化和抑制作用如何相互作用以动态塑造突触反应获得切实的理解。",
            "id": "4031684",
            "problem": "一个突触使用短期可塑性的 Tsodyks-Markram 模型进行建模，其中两个状态变量代表动态抑制和易化：可用突触前资源的比例 $x(t)$ 和突触效能的利用率 $u(t)$。在脉冲之间，$x(t)$ 和 $u(t)$ 根据以下线性常微分方程驰豫到它们的不动点\n$$\\frac{dx}{dt} = \\frac{1 - x}{\\tau_{d}}, \\qquad \\frac{du}{dt} = \\frac{U - u}{\\tau_{f}},$$\n其中 $\\tau_{d}$ 是抑制恢复时间常数，$\\tau_{f}$ 是易化时间常数，$U$ 是基线利用率参数。在脉冲时间 $t_{k}$，状态由于释放和易化而经历瞬时更新（跳跃映射）：\n$$x(t_{k}^{+}) = x(t_{k}^{-})\\bigl(1 - u(t_{k}^{-})\\bigr), \\qquad u(t_{k}^{+}) = u(t_{k}^{-}) + U\\bigl(1 - u(t_{k}^{-})\\bigr),$$\n其中 $t_{k}^{-}$ 和 $t_{k}^{+}$ 分别表示脉冲前和脉冲后的瞬间。突触后电流（PSC）被建模为一个 delta 突触，其幅值与释放的资源成正比。第 $k$ 个 PSC 的幅值定义为\n$$I_{k} = A\\,u(t_{k}^{-})\\,x(t_{k}^{-}),$$\n其中 $A$ 是一个固定的缩放因子。\n\n从初始条件 $u(0^{-}) = U$ 和 $x(0^{-}) = 1$ 开始，考虑一个脉冲序列，其脉冲时间为 $t_{1} = 50\\,\\mathrm{ms}$、$t_{2} = 130\\,\\mathrm{ms}$ 和 $t_{3} = 170\\,\\mathrm{ms}$。使用上述指定的 Tsodyks-Markram 动力学，通过从给定微分方程导出的闭式脉冲间衰减，将 $x(t_{k}^{-})$ 和 $u(t_{k}^{-})$ 跨脉冲进行传递，从而递归地计算 $I_{3}$。模型参数为 $U = 0.15$，$\\tau_{f} = 600\\,\\mathrm{ms}$，$\\tau_{d} = 200\\,\\mathrm{ms}$，以及 $A = 2.0\\,\\mathrm{nA}$。以纳安为单位表示电流幅值的最终答案，并将答案四舍五入到四位有效数字。",
            "solution": "问题陈述已经过验证，并被认为是有效的。它在科学上基于计算神经科学中已确立的 Tsodyks-Markram 模型，具备所有必要的参数和初始条件，是适定的，并且没有歧义或矛盾。因此，我们可以进行完整的解答。\n\n该问题要求对给定脉冲序列中的第三个脉冲，递归计算其突触后电流幅值 $I_3$。突触的动力学由状态变量 $x(t)$（可用资源的比例）和 $u(t)$（利用率参数）控制。\n\n首先，我们求解描述 $x(t)$ 和 $u(t)$ 在脉冲之间演化的线性常微分方程。方程的一般形式为 $\\frac{dy}{dt} = \\frac{y_{\\infty} - y}{\\tau}$，其解为 $y(t) = y_{\\infty} + \\bigl(y(t_0) - y_{\\infty}\\bigr)\\exp\\left(-\\frac{t-t_0}{\\tau}\\right)$。\n\n对于资源变量 $x(t)$，其静息值为 $x_{\\infty} = 1$，时间常数为 $\\tau_d$。如果我们考虑从第 $(k-1)$ 个脉冲时间 $t_{k-1}$ 到第 $k$ 个脉冲时间 $t_{k}$ 的脉冲间期，那么在第 $k$ 个脉冲前瞬间的 $x$ 值，记为 $x(t_k^-)$，由下式给出：\n$$x(t_k^-) = 1 + \\bigl(x(t_{k-1}^+) - 1\\bigr)\\exp\\left(-\\frac{t_k - t_{k-1}}{\\tau_d}\\right) = 1 - \\bigl(1 - x(t_{k-1}^+)\\bigr)\\exp\\left(-\\frac{\\Delta t_k}{\\tau_d}\\right)$$\n其中 $x(t_{k-1}^+)$ 是第 $(k-1)$ 个脉冲后瞬间的 $x$ 值，且 $\\Delta t_k = t_k - t_{k-1}$。\n\n对于利用率变量 $u(t)$，其静息值为 $u_{\\infty} = U$，时间常数为 $\\tau_f$。在第 $k$ 个脉冲前瞬间的 $u$ 值为：\n$$u(t_k^-) = U + \\bigl(u(t_{k-1}^+) - U\\bigr)\\exp\\left(-\\frac{t_k - t_{k-1}}{\\tau_f}\\right) = U + \\bigl(u(t_{k-1}^+) - U\\bigr)\\exp\\left(-\\frac{\\Delta t_k}{\\tau_f}\\right)$$\n\n在脉冲时间 $t_k$ 的瞬时更新由下式给出：\n$$x(t_k^+) = x(t_k^-)\\bigl(1 - u(t_k^-)\\bigr)$$\n$$u(t_k^+) = u(t_k^-) + U\\bigl(1 - u(t_k^-)\\bigr)$$\n\n突触后电流（PSC）的幅值为：\n$$I_k = A\\,u(t_k^-)\\,x(t_k^-)$$\n\n给定参数为：$U = 0.15$，$\\tau_f = 600\\,\\mathrm{ms}$，$\\tau_d = 200\\,\\mathrm{ms}$，$A = 2.0\\,\\mathrm{nA}$。脉冲时间为 $t_1 = 50\\,\\mathrm{ms}$，$t_2 = 130\\,\\mathrm{ms}$ 和 $t_3 = 170\\,\\mathrm{ms}$。\n\n初始条件为 $u(0^{-}) = U$ 和 $x(0^{-}) = 1$。这意味着在第一个脉冲之前突触处于静息状态。因此，在 $t_1$ 的第一个脉冲前瞬间，系统的状态就是其静息状态。\n$$x(t_1^-) = 1$$\n$$u(t_1^-) = U = 0.15$$\n由于第一个脉冲发生在 $t_1=50$ms, 我们需要演化系统从 $t=0$ 到 $t=50$ms。\n$\\Delta t_1 = 50$ms. \n$u(t_1^-) = U + (u(0^-)-U)e^{-50/600} = U + 0 = U=0.15$.\n$x(t_1^-) = 1 - (1-x(0^-))e^{-50/200} = 1 - 0 = 1$.\n所以脉冲前的状态是静息状态，这没问题。\n\n现在我们进行递归计算。\n\n**第 1 步：在 $t_1 = 50\\,\\mathrm{ms}$ 的脉冲**\n\n脉冲前瞬间的状态是已知的。我们可以计算脉冲后瞬间的状态。\n$$u(t_1^+) = u(t_1^-) + U\\bigl(1 - u(t_1^-)\\bigr) = 0.15 + 0.15(1 - 0.15) = 0.15 + 0.15(0.85) = 0.15 + 0.1275 = 0.2775$$\n$$x(t_1^+) = x(t_1^-)\\bigl(1 - u(t_1^-)\\bigr) = 1(1 - 0.15) = 0.85$$\n\n**第 2 步：演化至 $t_2 = 130\\,\\mathrm{ms}$ 的脉冲**\n\n脉冲间期为 $\\Delta t_2 = t_2 - t_1 = 130\\,\\mathrm{ms} - 50\\,\\mathrm{ms} = 80\\,\\mathrm{ms}$。我们使用值 $x(t_1^+)$ 和 $u(t_1^+)$ 来求得第二个脉冲前瞬间的状态 $x(t_2^-)$ 和 $u(t_2^-)$。\n\n$$x(t_2^-) = 1 - \\bigl(1 - x(t_1^+)\\bigr)\\exp\\left(-\\frac{\\Delta t_2}{\\tau_d}\\right) = 1 - (1 - 0.85)\\exp\\left(-\\frac{80}{200}\\right) = 1 - 0.15\\exp(-0.4)$$\n$$x(t_2^-) \\approx 1 - 0.15(0.670320) = 1 - 0.100548 = 0.899452$$\n\n$$u(t_2^-) = U + \\bigl(u(t_1^+) - U\\bigr)\\exp\\left(-\\frac{\\Delta t_2}{\\tau_f}\\right) = 0.15 + (0.2775 - 0.15)\\exp\\left(-\\frac{80}{600}\\right) = 0.15 + 0.1275\\exp\\left(-\\frac{2}{15}\\right)$$\n$$u(t_2^-) \\approx 0.15 + 0.1275(0.875185) = 0.15 + 0.111586 = 0.261586$$\n\n现在我们计算第二个脉冲后瞬间的状态。\n$$u(t_2^+) = u(t_2^-) + U\\bigl(1 - u(t_2^-)\\bigr) \\approx 0.261586 + 0.15(1 - 0.261586) = 0.261586 + 0.15(0.738414) = 0.261586 + 0.110762 = 0.372348$$\n$$x(t_2^+) = x(t_2^-)\\bigl(1 - u(t_2^-)\\bigr) \\approx 0.899452(1 - 0.261586) = 0.899452(0.738414) = 0.664183$$\n\n**第 3 步：演化至 $t_3 = 170\\,\\mathrm{ms}$ 的脉冲**\n\n脉冲间期为 $\\Delta t_3 = t_3 - t_2 = 170\\,\\mathrm{ms} - 130\\,\\mathrm{ms} = 40\\,\\mathrm{ms}$。我们使用值 $x(t_2^+)$ 和 $u(t_2^+)$ 来求得第三个脉冲前瞬间的状态。\n\n$$x(t_3^-) = 1 - \\bigl(1 - x(t_2^+)\\bigr)\\exp\\left(-\\frac{\\Delta t_3}{\\tau_d}\\right) \\approx 1 - (1 - 0.664183)\\exp\\left(-\\frac{40}{200}\\right) = 1 - 0.335817\\exp(-0.2)$$\n$$x(t_3^-) \\approx 1 - 0.335817(0.818731) = 1 - 0.274955 = 0.725045$$\n\n$$u(t_3^-) = U + \\bigl(u(t_2^+) - U\\bigr)\\exp\\left(-\\frac{\\Delta t_3}{\\tau_f}\\right) \\approx 0.15 + (0.372348 - 0.15)\\exp\\left(-\\frac{40}{600}\\right) = 0.15 + 0.222348\\exp\\left(-\\frac{1}{15}\\right)$$\n$$u(t_3^-) \\approx 0.15 + 0.222348(0.935513) = 0.15 + 0.207977 = 0.357977$$\n\n**第 4 步：计算 $I_3$**\n\n第三个 PSC 的幅值是使用第三个脉冲前瞬间的状态值计算的。\n$$I_3 = A\\,u(t_3^-)\\,x(t_3^-)$$\n$$I_3 \\approx (2.0\\,\\mathrm{nA})(0.357977)(0.725045)$$\n$$I_3 \\approx 0.519102\\,\\mathrm{nA}$$\n\n四舍五入到四位有效数字得到 $0.5191\\,\\mathrm{nA}$。\n为确保准确性，计算以更高的精度执行：\n$x(t_1^+) = 0.85$\n$u(t_1^+) = 0.2775$\n$x(t_2^-) = 1 - 0.15 \\exp(-0.4) \\approx 0.89945199$\n$u(t_2^-) = 0.15 + 0.1275 \\exp(-2/15) \\approx 0.26158610$\n$x(t_2^+) = x(t_2^-)(1-u(t_2^-)) \\approx 0.66418285$\n$u(t_2^+) = u(t_2^-) + 0.15(1-u(t_2^-)) \\approx 0.37234819$\n$x(t_3^-) = 1 - (1-x(t_2^+))\\exp(-0.2) \\approx 0.72504464$\n$u(t_3^-) = 0.15 + (u(t_2^+)-0.15)\\exp(-1/15) \\approx 0.35797694$\n$I_3 = 2.0 \\times 0.35797694 \\times 0.72504464 \\approx 0.5191017\\,\\mathrm{nA}$。\n结果成立。",
            "answer": "$$\\boxed{0.5191}$$"
        },
        {
            "introduction": "虽然模拟瞬态动力学至关重要，但理解突触在规则活动下的长期行为也同样重要。本练习将向你介绍对由周期性脉冲序列驱动的突触进行稳态分析的概念。你将推导状态变量的定点方程，从而能够解析计算出突触的稳定、重复响应，而无需模拟无限长的脉冲序列。",
            "id": "4031695",
            "problem": "考虑一个由脉冲间隔为 $\\Delta t$ 的完美周期性突触前脉冲序列驱动的短期突触可塑性Tsodyks–Markram模型。该模型通过以下经过充分检验的唯象定律来描述可用突触资源的分数 $x(t)$ 和突触效能的利用率 $u(t)$。在脉冲之间，这些变量根据线性常微分方程（ODE）进行弛豫：$\\frac{dx}{dt} = \\frac{1 - x}{\\tau_{rec}}$ 和 $\\frac{du}{dt} = \\frac{U - u}{\\tau_{facil}}$，其中 $\\tau_{rec}$ 是恢复时间常数，$\\tau_{facil}$ 是易化时间常数，$U$ 是基线释放概率。在每个脉冲时间 $t_k$，$x$ 会瞬时耗尽，$u$ 会瞬时增加，其规律为 $x^{+}(t_k) = x^{-}(t_k)\\big(1 - u^{-}(t_k)\\big)$ 和 $u^{+}(t_k) = u^{-}(t_k) + U\\big(1 - u^{-}(t_k)\\big)$，其中上标 $-$ 和 $+$ 分别表示脉冲前瞬间和脉冲后瞬间的值。第 $k$ 个脉冲引起的突触后电流幅度为 $I_k = A\\,u^{-}(t_k)\\,x^{-}(t_k)$，其中 $A$ 是一个常数缩放因子。\n\n在周期性刺激下，系统可以达到一个稳态（不动点），此时对于所有脉冲，$x^{-}(t_k)$ 和 $u^{-}(t_k)$ 的值都相同，记为 $x^{-,*}$ 和 $u^{-,*}$。从这些原理和定义出发，推导不动点关系式，并计算在参数集 $A = 20$ 皮安 (pA)，$\\tau_{rec} = 800$ 毫秒 (ms)，$\\tau_{facil} = 100$ ms，$U = 0.2$，$\\Delta t = 50$ ms 条件下的稳态突触幅度 $I^{*} = A\\,u^{-,*}\\,x^{-,*}$。以皮安为单位表示最终幅度，并将最终数值答案四舍五入到 $4$ 位有效数字。",
            "solution": "该问题提法明确且有科学依据，为短期突触可塑性的Tsodyks-Markram模型提供了一整套方程和参数。我们接下来求解周期性刺激下的稳态解。\n\n问题的核心是找到在脉冲间隔为 $\\Delta t$ 的周期性脉冲序列作用下，系统动力学的不动点。设 $x_k^- = x^{-}(t_k)$ 和 $u_k^- = u^{-}(t_k)$ 分别表示第 $k$ 个脉冲前瞬间的可用资源分数和利用率因子。在脉冲时间 $t_k$，这些变量瞬时更新如下：\n$$u_k^+ = u_k^- + U(1 - u_k^-)$$\n$$x_k^+ = x_k^-(1 - u_k^-)$$\n其中上标 '$+$' 表示脉冲后瞬间的值。\n\n在脉冲之间，从 $t_k$ 到 $t_{k+1} = t_k + \\Delta t$，这些变量根据线性常微分方程演化：\n$$\\frac{du}{dt} = \\frac{U - u}{\\tau_{facil}}$$\n$$\\frac{dx}{dt} = \\frac{1 - x}{\\tau_{rec}}$$\n\n我们在时长为 $\\Delta t$ 的区间上求解这些常微分方程，初始条件为 $u(t_k) = u_k^+$ 和 $x(t_k) = x_k^+$。\n对于 $u(t)$，解为 $u(t) = U + (u_k^+ - U)\\exp\\left(-\\frac{t-t_k}{\\tau_{facil}}\\right)$。\n在时间 $t_{k+1}$，即下一个脉冲前瞬间，我们有：\n$$u_{k+1}^- = U + (u_k^+ - U)\\exp\\left(-\\frac{\\Delta t}{\\tau_{facil}}\\right)$$\n对于 $x(t)$，解为 $x(t) = 1 + (x_k^+ - 1)\\exp\\left(-\\frac{t-t_k}{\\tau_{rec}}\\right)$。\n在时间 $t_{k+1}$，我们有：\n$$x_{k+1}^- = 1 + (x_k^+ - 1)\\exp\\left(-\\frac{\\Delta t}{\\tau_{rec}}\\right)$$\n\n在稳态（不动点）下，脉冲前的值在相邻脉冲之间保持不变，即 $u_{k+1}^- = u_k^- = u^{-,*}$ 和 $x_{k+1}^- = x_k^- = x^{-,*}$。将不動點条件和脉冲更新规则代入常微分方程的解中，我们得到一个关于 $u^{-,*}$ 和 $x^{-,*}$ 的代数方程组。\n\n首先，我们求解 $u^{-,*}$。令 $E_f = \\exp\\left(-\\frac{\\Delta t}{\\tau_{facil}}\\right)$。\n$$u^{-,*} = U + (u^{+,*} - U)E_f$$\n代入 $u^{+,*} = u^{-,*} + U(1 - u^{-,*})$：\n$$u^{-,*} = U + (u^{-,*} + U(1 - u^{-,*}) - U)E_f$$\n$$u^{-,*} = U + (u^{-,*} - Uu^{-,*})E_f$$\n$$u^{-,*} = U + u^{-,*}(1 - U)E_f$$\n整理以求解 $u^{-,*}$：\n$$u^{-,*}(1 - (1 - U)E_f) = U$$\n$$u^{-,*} = \\frac{U}{1 - (1 - U)\\exp\\left(-\\frac{\\Delta t}{\\tau_{facil}}\\right)}$$\n\n接下来，我们求解 $x^{-,*}$。令 $E_r = \\exp\\left(-\\frac{\\Delta t}{\\tau_{rec}}\\right)$。\n$$x^{-,*} = 1 + (x^{+,*} - 1)E_r = 1 - (1 - x^{+,*})E_r$$\n代入 $x^{+,*} = x^{-,*}(1 - u^{-,*})$。注意 $u^{-,*}$ 是我们刚刚求出的稳态值。\n$$x^{-,*} = 1 - (1 - x^{-,*}(1 - u^{-,*}))E_r$$\n$$x^{-,*} = 1 - E_r + x^{-,*}(1 - u^{-,*})E_r$$\n整理以求解 $x^{-,*}$：\n$$x^{-,*}(1 - (1 - u^{-,*})E_r) = 1 - E_r$$\n$$x^{-,*} = \\frac{1 - E_r}{1 - (1 - u^{-,*})E_r} = \\frac{1 - \\exp\\left(-\\frac{\\Delta t}{\\tau_{rec}}\\right)}{1 - (1 - u^{-,*})\\exp\\left(-\\frac{\\Delta t}{\\tau_{rec}}\\right)}$$\n\n现在我们代入给定的参数值：$A = 20$ pA, $\\tau_{rec} = 800$ ms, $\\tau_{facil} = 100$ ms, $U = 0.2$, 以及 $\\Delta t = 50$ ms。\n\n计算指数因子：\n$$E_f = \\exp\\left(-\\frac{50}{100}\\right) = \\exp(-0.5)$$\n$$E_r = \\exp\\left(-\\frac{50}{800}\\right) = \\exp(-0.0625)$$\n\n计算稳态利用率 $u^{-,*}$：\n$$u^{-,*} = \\frac{0.2}{1 - (1 - 0.2)\\exp(-0.5)} = \\frac{0.2}{1 - 0.8\\exp(-0.5)}$$\n使用 $\\exp(-0.5) \\approx 0.606531$：\n$$u^{-,*} \\approx \\frac{0.2}{1 - 0.8 \\times 0.606531} = \\frac{0.2}{1 - 0.485225} = \\frac{0.2}{0.514775} \\approx 0.3885175$$\n\n使用 $u^{-,*}$ 的值计算稳态资源分数 $x^{-,*}$：\n$$x^{-,*} = \\frac{1 - \\exp(-0.0625)}{1 - (1 - 0.3885175)\\exp(-0.0625)}$$\n使用 $\\exp(-0.0625) \\approx 0.939413$：\n$$x^{-,*} \\approx \\frac{1 - 0.939413}{1 - (0.6114825) \\times 0.939413} = \\frac{0.060587}{1 - 0.574447} = \\frac{0.060587}{0.425553} \\approx 0.142372$$\n\n最后，我们计算稳态突触幅度 $I^{*} = A\\,u^{-,*}\\,x^{-,*}$：\n$$I^{*} = (20) \\times (0.3885175) \\times (0.142372)$$\n$$I^{*} \\approx 1.10628 \\text{ pA}$$\n\n按要求将最终答案四舍五入到 $4$ 位有效数字，得到 $1.106$ pA。",
            "answer": "$$\\boxed{1.106}$$"
        }
    ]
}