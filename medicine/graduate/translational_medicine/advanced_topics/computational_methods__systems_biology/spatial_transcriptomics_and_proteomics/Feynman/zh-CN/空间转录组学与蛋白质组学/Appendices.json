{
    "hands_on_practices": [
        {
            "introduction": "在分析空间组学数据时，首要问题之一是确定基因表达是否存在空间模式。莫兰指数I（Moran's $I$）是空间统计学中的一个基础工具，用于量化空间自相关性——即一个变量在某个位置的值与其在邻近位置的值的相似程度。本练习将引导你从基本统计概念出发，推导并计算莫兰指数I，从而让你亲手实践如何判断基因表达是呈聚集、分散还是随机分布的模式 。",
            "id": "4386267",
            "problem": "考虑一个通过空间转录组学 (Spatial Transcriptomics, ST) 检测的一维组织条带，其中相邻的捕获点位于一个等间距的线性网格上。关注单个基因，并假设其在 $n$ 个捕获点上的标准化表达量被建模为一个实值场 $x_{i}$，其位置由索引 $i \\in \\{1,2,\\dots,n\\}$ 表示。空间自相关通过一个对称、对角线为零、非行标准化的空间权重矩阵 $W=\\{w_{ij}\\}$ 来评估。该矩阵编码了邻近关系，其中较大的 $w_{ij}$ 意味着位置 $i$ 和 $j$ 之间的空间耦合更强。\n\n从样本均值、样本方差和空间加权协方差等基本统计定义出发，推导空间自相关的无量纲指数，这些指数 (i) 将 $x_{i}$ 的空间加权交叉偏差与其总偏差进行比较，以及 (ii) 将 $x_{i}$ 相邻值之间的平方差与总偏差进行比较。这些构造被称为莫兰指数 $I$ (Moran’s $I$) 和吉尔里指数 $C$ (Geary’s $C$)。您的推导必须确定由 $n$ 和总权重 $S_{0}$（其中 $S_{0}=\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}$）构成的适当归一化因子，以使每个指数对 $x_{i}$ 都是尺度不变且无量纲的。\n\n然后，为以下科学上真实的 ST 设置计算莫兰指数 $I$：\n- 网格上有 $n=7$ 个有序捕获点，其表达值为 $x_{1},\\dots,x_{7}$，由下式给出\n$$\nx = \\left(5,\\,6,\\,7,\\,12,\\,11,\\,9,\\,8\\right).\n$$\n- 空间权重在网格上实现了一阶邻接：\n$$\nw_{ij}=\\begin{cases}\n1  \\text{if } |i-j|=1,\\\\\n0  \\text{otherwise,}\n\\end{cases}\n\\quad \\text{且对所有 } i \\text{ 都有 } w_{ii}=0.\n$$\n\n将莫兰指数 $I$ 的最终数值结果表示为未经四舍五入的精确值。不要包含任何单位。如果引入任何首字母缩略词，请在首次使用时写出其全称，并将缩略词放在括号中。",
            "solution": "我们从在 $n$ 个空间位置上观测到的实值场 $x_{i}$ 的基本统计构造开始。样本均值为\n$$\n\\bar{x}=\\frac{1}{n}\\sum_{i=1}^{n}x_{i},\n$$\n总样本偏差（未归一化的方差分子）为\n$$\n\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2}.\n$$\n为编码空间结构，我们考虑一个对称的空间权重矩阵 $W=\\{w_{ij}\\}$，其中 $w_{ii}=0$，总权重为\n$$\nS_{0}=\\sum_{i=1}^{n}\\sum_{j=1}^{n}w_{ij}.\n$$\n空间加权交叉偏差由下式捕获\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}\\,(x_{i}-\\bar{x})(x_{j}-\\bar{x}),\n$$\n该式通过根据空间邻近性对数据对进行加权，推广了协方差的概念。\n\n莫兰指数 $I$ 的构造是无量纲且对 $x_{i}$ 尺度不变的，方法是用总样本偏差对空间加权交叉偏差进行归一化，并引入一个仅取决于 $n$ 和 $S_{0}$ 的因子，以考虑总权重大小和位置数量。其标准形式推导为\n$$\nI=\\frac{n}{S_{0}}\\cdot \\frac{\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}\\,(x_{i}-\\bar{x})(x_{j}-\\bar{x})}{\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2}},\n$$\n它是无量纲的，在仿射缩放 $x_{i}\\mapsto a x_{i}+b$（其中 $a\\neq 0$）下不变，并使用 $S_{0}$ 来归一化总权重的大小。\n\n吉尔里指数 $C$ 将相邻位置间的平方差与总偏差进行比较，并通过归一化确保其无量纲性和尺度不变性。从空间加权平方差之和\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}\\,(x_{i}-x_{j})^{2},\n$$\n出发，标准的归一化形式为\n$$\nC=\\frac{n-1}{2 S_{0}}\\cdot \\frac{\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}\\,(x_{i}-x_{j})^{2}}{\\sum_{i=1}^{n}(x_{i}-\\bar{x})^{2}},\n$$\n该形式同样是无量纲和尺度不变的。\n\n现在我们为给定的一维网格计算莫兰指数 $I$。\n\n第 1 步：为\n$$\nx=\\left(5,\\,6,\\,7,\\,12,\\,11,\\,9,\\,8\\right)\n$$\n计算均值 $\\bar{x}$。\n总和为\n$$\n\\sum_{i=1}^{7} x_{i} = 5+6+7+12+11+9+8 = 58,\n$$\n所以\n$$\n\\bar{x}=\\frac{58}{7}.\n$$\n\n第 2 步：计算偏差 $d_{i}=x_{i}-\\bar{x}$：\n$$\nd_{1}=\\frac{35-58}{7}=-\\frac{23}{7},\\quad\nd_{2}=\\frac{42-58}{7}=-\\frac{16}{7},\\quad\nd_{3}=\\frac{49-58}{7}=-\\frac{9}{7},\n$$\n$$\nd_{4}=\\frac{84-58}{7}=\\frac{26}{7},\\quad\nd_{5}=\\frac{77-58}{7}=\\frac{19}{7},\\quad\nd_{6}=\\frac{63-58}{7}=\\frac{5}{7},\\quad\nd_{7}=\\frac{56-58}{7}=-\\frac{2}{7}.\n$$\n\n第 3 步：计算总偏差分母\n$$\n\\sum_{i=1}^{7}(x_{i}-\\bar{x})^{2}=\\sum_{i=1}^{7} d_{i}^{2}\n=\\frac{529+256+81+676+361+25+4}{49}=\\frac{1932}{49}.\n$$\n\n第 4 步：为指定的邻接权重计算 $S_{0}$。在一个 7 节点的链上，无向边存在于点对 $(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)$ 之间，共计 6 条边。因为 $w_{ij}=w_{ji}=1$ 并且我们对有序对 $(i,j)$ 求和，所以我们有\n$$\nS_{0}=\\sum_{i=1}^{7}\\sum_{j=1}^{7} w_{ij} = 2\\times 6 = 12.\n$$\n\n第 5 步：计算空间加权交叉偏差分子 $\\sum_{i=1}^{7}\\sum_{j=1}^{7} w_{ij} d_{i} d_{j}$。非零贡献仅在 $|i-j|=1$ 时产生，根据对称性可得\n$$\n\\sum_{i=1}^{7}\\sum_{j=1}^{7} w_{ij} d_{i} d_{j}\n=2\\sum_{\\text{edges }(i,j)} d_{i} d_{j}.\n$$\n计算边乘积：\n$$\n(1,2):\\; d_{1}d_{2}=\\left(-\\frac{23}{7}\\right)\\left(-\\frac{16}{7}\\right)=\\frac{368}{49},\n$$\n$$\n(2,3):\\; d_{2}d_{3}=\\left(-\\frac{16}{7}\\right)\\left(-\\frac{9}{7}\\right)=\\frac{144}{49},\n$$\n$$\n(3,4):\\; d_{3}d_{4}=\\left(-\\frac{9}{7}\\right)\\left(\\frac{26}{7}\\right)=-\\frac{234}{49},\n$$\n$$\n(4,5):\\; d_{4}d_{5}=\\left(\\frac{26}{7}\\right)\\left(\\frac{19}{7}\\right)=\\frac{494}{49},\n$$\n$$\n(5,6):\\; d_{5}d_{6}=\\left(\\frac{19}{7}\\right)\\left(\\frac{5}{7}\\right)=\\frac{95}{49},\n$$\n$$\n(6,7):\\; d_{6}d_{7}=\\left(\\frac{5}{7}\\right)\\left(-\\frac{2}{7}\\right)=-\\frac{10}{49}.\n$$\n将这些边乘积相加，\n$$\n\\sum_{\\text{edges }(i,j)} d_{i} d_{j}\n=\\frac{368+144-234+494+95-10}{49}\n=\\frac{857}{49}.\n$$\n因此，\n$$\n\\sum_{i=1}^{7}\\sum_{j=1}^{7} w_{ij} d_{i} d_{j}\n=2\\cdot \\frac{857}{49}=\\frac{1714}{49}.\n$$\n\n第 6 步：组合莫兰指数 $I$：\n$$\nI=\\frac{n}{S_{0}}\\cdot \\frac{\\sum_{i=1}^{7}\\sum_{j=1}^{7} w_{ij} d_{i} d_{j}}{\\sum_{i=1}^{7} d_{i}^{2}}\n=\\frac{7}{12}\\cdot \\frac{\\frac{1714}{49}}{\\frac{1932}{49}}\n=\\frac{7}{12}\\cdot \\frac{1714}{1932}.\n$$\n化简：\n$$\nI=\\frac{7\\cdot 1714}{12\\cdot 1932}\n=\\frac{7\\cdot 857\\cdot 2}{12\\cdot 1932}\n=\\frac{7\\cdot 857}{6\\cdot 1932}\n=\\frac{5999}{11592}.\n$$\n分子和分母同时除以 $7$：\n$$\nI=\\frac{857}{1656}.\n$$\n分数 $\\frac{857}{1656}$ 已经是最简形式，所以莫兰指数 $I$ 的精确值为\n$$\nI=\\frac{857}{1656}.\n$$",
            "answer": "$$\\boxed{\\frac{857}{1656}}$$"
        },
        {
            "introduction": "许多空间转录组学技术（如Visium）所捕获的表达谱实际上是来自包含多个细胞的混合信号。为了揭示组织微环境中真实的细胞空间排布，一个关键的计算任务是“解卷积”（deconvolution），即估算每个空间位点内不同细胞类型的比例。本练习将此问题构建为一个带约束的回归模型，让你通过解决这个优化问题，掌握从混合信号中解析细胞组成的核心技能 。",
            "id": "4386305",
            "problem": "给定一个系统生物医学场景，其中来自 Visium 空间基因表达 (Visium) 技术的一个空间点包含多种细胞类型的混合物，这些细胞类型的信使核糖核酸 (mRNA) 转录本丰度是跨多个基因测量的。在这样一个空间点中，观测到的表达谱是组成细胞类型表达谱的混合。为了量化一个空间点的组成，假设有一个参考特征矩阵，该矩阵编码了每种细胞类型的平均基因表达。任务是构建并解决一个约束回归问题，以估计每个空间点的细胞类型比例。\n\n使用以下基本依据和假设：\n- 分子生物学中心法则：脱氧核糖核酸 (DNA) 转录为核糖核酸 (RNA)，RNA 再翻译成蛋白质。在充分平均和归一化的设定下，每个基因的观测转录本计数反映了样本中不同细胞类型贡献的总和。\n- 线性混合模型：一个空间点中观测到的基因表达向量可以被建模为细胞类型特异性特征的线性组合，由未知的非负比例加权。设 $G$ 为基因数，$K$ 为细胞类型数，$\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{G \\times K}$ 为已知的特征矩阵，其第 $k$ 列是细胞类型 $k$ 的参考表达谱，$\\mathbf{y} \\in \\mathbb{R}_{\\ge 0}^{G}$ 为一个空间点的观测表达向量。未知的细胞类型比例向量是 $\\mathbf{p} \\in \\mathbb{R}_{\\ge 0}^{K}$。\n- 约束条件：比例为非负且总和为一，即 $\\mathbf{p} \\succeq \\mathbf{0}$ 和 $\\mathbf{1}^{\\top} \\mathbf{p} = 1$，其中 $\\mathbf{1}$ 是 $\\mathbb{R}^{K}$ 中的全一向量。\n- 目标：估计准则是预测表达与观测表达之间的平方欧氏距离，可选地为每个基因设置非负权重 $w_g$ 以反映可靠性，并加入一个小的岭正则化项以确保唯一性和数值稳定性。\n\n形式上，将反卷积定义为针对每个空间点的以下约束优化问题：\n最小化函数\n$$\n\\frac{1}{2} \\sum_{g=1}^{G} w_g \\left( (\\mathbf{S}\\mathbf{p})_g - \\mathbf{y}_g \\right)^2 + \\frac{\\alpha}{2} \\lVert \\mathbf{p} \\rVert_2^2\n$$\n约束条件为 $\\mathbf{p} \\succeq \\mathbf{0}$ 和 $\\mathbf{1}^{\\top} \\mathbf{p} = 1$，\n其中 $w_g \\ge 0$ 是给定的逐基因权重，$\\alpha \\ge 0$ 是一个小的正则化参数。\n\n您的程序必须实现一个求解器，对于每个测试案例，计算在约束条件下最小化上述目标的细胞类型比例向量 $\\widehat{\\mathbf{p}}$。您可以假设问题是凸的且存在一个最小化子。求解器必须是通用的，并且不能依赖于约束的闭式反演。程序必须将 $\\widehat{\\mathbf{p}}$ 的每个分量四舍五入到4位小数。\n\n角度单位不适用。没有物理单位；比例必须以小数形式报告。\n\n测试套件：\n对于每个案例，您将获得 $G$、$K$、特征矩阵 $\\mathbf{S}$、观测表达 $\\mathbf{y}$、权重 $\\mathbf{w}$ 和岭参数 $\\alpha$。所有数值都在下面明确给出。\n\n- 案例 A（一般情况，小噪声）：\n  - $G = 5$, $K = 3$, $\\alpha = 10^{-6}$。\n  - $\\mathbf{S} = \\begin{bmatrix}\n  8  2  1 \\\\\n  1  7  2 \\\\\n  0  1  9 \\\\\n  5  2  1 \\\\\n  2  3  4\n  \\end{bmatrix}$。\n  - $\\mathbf{y} = \\begin{bmatrix} 4.9 \\\\ 2.95 \\\\ 2.12 \\\\ 3.27 \\\\ 2.7 \\end{bmatrix}$。\n  - $\\mathbf{w} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n\n- 案例 B（纯细胞类型，无噪声）：\n  - $G = 5$, $K = 3$, $\\alpha = 10^{-6}$。\n  - $\\mathbf{S}$ 与案例 A 相同。\n  - $\\mathbf{y} = \\begin{bmatrix} 2 \\\\ 7 \\\\ 1 \\\\ 2 \\\\ 3 \\end{bmatrix}$。\n  - $\\mathbf{w} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n\n- 案例 C（共线性，精确混合）：\n  - $G = 4$, $K = 3$, $\\alpha = 10^{-6}$。\n  - $\\mathbf{S} = \\begin{bmatrix}\n  3  3  1 \\\\\n  2  2  0.5 \\\\\n  1  1  4 \\\\\n  0.5  0.5  2\n  \\end{bmatrix}$。\n  - $\\mathbf{y} = \\begin{bmatrix} 2.6 \\\\ 1.7 \\\\ 1.6 \\\\ 0.8 \\end{bmatrix}$。\n  - $\\mathbf{w} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n\n- 案例 D（零值与缺失，中等噪声）：\n  - $G = 4$, $K = 2$, $\\alpha = 10^{-6}$。\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0  3 \\\\\n  5  0 \\\\\n  0  2 \\\\\n  4  1\n  \\end{bmatrix}$。\n  - $\\mathbf{y} = \\begin{bmatrix} 1.15 \\\\ 3.1 \\\\ 0.4 \\\\ 2.7 \\end{bmatrix}$。\n  - $\\mathbf{w} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n\n- 案例 E（加权拟合，对噪声大的第二个基因降权）：\n  - $G = 3$, $K = 3$, $\\alpha = 10^{-6}$。\n  - $\\mathbf{S} = \\begin{bmatrix}\n  10  1  0.5 \\\\\n  0.5  8  1 \\\\\n  1  1  6\n  \\end{bmatrix}$。\n  - $\\mathbf{y} = \\begin{bmatrix} 2.65 \\\\ 5.9 \\\\ 2.4 \\end{bmatrix}$。\n  - $\\mathbf{w} = \\begin{bmatrix} 1 \\\\ 0.2 \\\\ 1 \\end{bmatrix}$。\n\n实现要求：\n- 实现一个求解器，该求解器能精确处理约束 $\\mathbf{p} \\succeq \\mathbf{0}$ 和 $\\mathbf{1}^{\\top} \\mathbf{p} = 1$，不对其进行松弛，并在目标函数中包含岭正则化项 $\\alpha$。\n- 该算法必须是有原则且通用的（例如，一种具有数学依据的步长和到概率单纯形上的投影的投影梯度法）。\n- 对于每个案例，计算估计的比例 $\\widehat{\\mathbf{p}}$，并将每个分量四舍五入到4位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3]$），其中每个 $resulti$ 是对应案例的四舍五入后的比例列表。输出不得包含任何空格。例如：$[[0.5000,0.3000,0.2000],[0.0000,1.0000,0.0000],\\dots]$。",
            "solution": "用户提供了一个问题陈述，该陈述已经过验证，被认为是科学上可靠、适定且客观的。\n\n该问题要求解一个约束二次优化问题，以在空间转录组学中执行细胞类型反卷积。一个空间点的观测基因表达向量 $\\mathbf{y} \\in \\mathbb{R}_{\\ge 0}^{G}$ 被建模为参考细胞类型表达特征的线性组合。这些特征被编码在一个已知矩阵 $\\mathbf{S} \\in \\mathbb{R}_{\\ge 0}^{G \\times K}$ 的列中，其中 $G$ 是基因数，$K$ 是细胞类型数。未知量是每种细胞类型的比例，由向量 $\\mathbf{p} \\in \\mathbb{R}_{\\ge 0}^{K}$ 表示。\n\n比例必须满足两个物理约束：它们必须是非负的，$\\mathbf{p} \\succeq \\mathbf{0}$，并且它们的总和必须为一，$\\mathbf{1}^{\\top} \\mathbf{p} = 1$。满足这些约束的所有向量 $\\mathbf{p}$ 构成了标准的 $K-1$ 维单纯形，记作 $\\Delta^{K-1}$。\n\n目标是找到比例向量 $\\widehat{\\mathbf{p}}$，它能最小化一个正则化、加权的平方误差目标函数。目标函数由下式给出：\n$$\nf(\\mathbf{p}) = \\frac{1}{2} \\sum_{g=1}^{G} w_g \\left( (\\mathbf{S}\\mathbf{p})_g - y_g \\right)^2 + \\frac{\\alpha}{2} \\lVert \\mathbf{p} \\rVert_2^2\n$$\n其中 $w_g \\ge 0$ 是基因特异性权重，$\\alpha \\ge 0$ 是一个 Tikhonov (岭) 正则化参数。\n\n这个问题可以用矩阵形式表示。设 $\\mathbf{W}$ 是一个 $G \\times G$ 的对角矩阵，其对角线上是权重 $w_g$。目标函数为：\n$$\nf(\\mathbf{p}) = \\frac{1}{2} (\\mathbf{S}\\mathbf{p} - \\mathbf{y})^{\\top} \\mathbf{W} (\\mathbf{S}\\mathbf{p} - \\mathbf{y}) + \\frac{\\alpha}{2} \\mathbf{p}^{\\top}\\mathbf{p}\n$$\n该问题是一个二次规划 (QP) 问题，具有凸的目标函数和一个紧凑的凸可行集（单纯形 $\\Delta^{K-1}$）。由岭项 ($\\alpha > 0$) 赋予的严格凸性保证了唯一解的存在。\n\n解决此问题的一个合适且通用的算法是投影梯度下降法。这种迭代方法包括沿负梯度方向迈出一步，然后将得到的点投影回可行集上。\n\n算法流程如下：\n1.  将 $\\mathbf{p}^{(0)}$ 初始化为一个可行点，通常是单纯形的中心：$\\mathbf{p}^{(0)} = \\frac{1}{K}\\mathbf{1}$。\n2.  对于迭代 $t = 0, 1, 2, \\dots$ 直到收敛：\n    a.  通过计算目标函数在当前迭代点 $\\mathbf{p}^{(t)}$ 的梯度 $\\nabla f(\\mathbf{p})$ 来计算下降方向。\n    b.  沿此方向迈出一步：$\\mathbf{z}^{(t+1)} = \\mathbf{p}^{(t)} - \\eta \\nabla f(\\mathbf{p}^{(t)})$，其中 $\\eta > 0$ 是步长。\n    c.  将点 $\\mathbf{z}^{(t+1)}$ 投影到单纯形 $\\Delta^{K-1}$ 上：$\\mathbf{p}^{(t+1)} = \\Pi_{\\Delta^{K-1}}(\\mathbf{z}^{(t+1)})$。\n3.  当两次迭代之间 $\\mathbf{p}$ 的变化小于一个小的容差时，算法终止。\n\n该算法的关键组成部分是梯度计算、步长确定和投影算子。\n\n**1. 梯度计算**\n\n目标函数是：\n$$\nf(\\mathbf{p}) = \\frac{1}{2} \\left( \\mathbf{p}^{\\top}\\mathbf{S}^{\\top}\\mathbf{W}\\mathbf{S}\\mathbf{p} - 2\\mathbf{y}^{\\top}\\mathbf{W}\\mathbf{S}\\mathbf{p} + \\mathbf{y}^{\\top}\\mathbf{W}\\mathbf{y} \\right) + \\frac{\\alpha}{2} \\mathbf{p}^{\\top}\\mathbf{p}\n$$\n关于 $\\mathbf{p}$ 的梯度是：\n$$\n\\nabla f(\\mathbf{p}) = \\mathbf{S}^{\\top}\\mathbf{W}\\mathbf{S}\\mathbf{p} - \\mathbf{S}^{\\top}\\mathbf{W}\\mathbf{y} + \\alpha\\mathbf{p} = \\mathbf{S}^{\\top}\\mathbf{W}(\\mathbf{S}\\mathbf{p} - \\mathbf{y}) + \\alpha\\mathbf{p}\n$$\n\n**2. 步长确定**\n\n为使梯度下降收敛，必须适当地选择步长 $\\eta$。对于一个具有利普希茨连续梯度的凸函数，收敛的充分条件是 $0 < \\eta < 2/L$，其中 $L$ 是梯度的利普希茨常数。对于我们的二次目标函数，$L$ 是海森矩阵 $\\nabla^2 f(\\mathbf{p})$ 的最大特征值。海森矩阵是：\n$$\n\\nabla^2 f(\\mathbf{p}) = \\mathbf{S}^{\\top}\\mathbf{W}\\mathbf{S} + \\alpha\\mathbf{I}\n$$\n其中 $\\mathbf{I}$ 是 $K \\times K$ 的单位矩阵。该海森矩阵是一个常数、对称、正定矩阵（对于 $\\alpha > 0$）。我们可以计算其特征值，并将 $L$ 设置为最大特征值 $\\lambda_{\\text{max}}$。一个安全且恒定的步长便是 $\\eta = 1/L$。\n\n**3. 到概率单纯形上的投影**\n\n投影步骤 $\\mathbf{p}^{(t+1)} = \\Pi_{\\Delta^{K-1}}(\\mathbf{z}^{(t+1)})$ 是在单纯形上找到与 $\\mathbf{z}^{(t+1)}$ 欧氏距离最近的点。这本身也是一个 QP 问题：\n$$\n\\text{minimize}_{\\mathbf{p}} \\quad \\frac{1}{2} \\lVert \\mathbf{p} - \\mathbf{z} \\rVert_2^2 \\quad \\text{subject to} \\quad \\mathbf{p} \\succeq \\mathbf{0}, \\mathbf{1}^{\\top}\\mathbf{p} = 1\n$$\n存在一个 $O(K \\log K)$ 时间复杂度的有效算法来解决这个投影问题。步骤如下：\n1.  将向量 $\\mathbf{z}$ 的元素按降序排序，得到一个新向量 $\\mathbf{u}$。\n2.  找到一个整数 $\\rho$，使得 $\\rho = \\max\\left\\{ j \\in \\{1, \\dots, K\\} \\mid u_j - \\frac{1}{j} \\left( \\sum_{i=1}^j u_i - 1 \\right) > 0 \\right\\}$。\n3.  定义一个阈值 $\\theta = \\frac{1}{\\rho} \\left( \\sum_{i=1}^\\rho u_i - 1 \\right)$。\n4.  通过对原始向量 $\\mathbf{z}$ 的每个元素应用软阈值算子得到投影向量 $\\mathbf{p}$：$p_k = \\max(z_k - \\theta, 0)$，对于 $k = 1, \\dots, K$。\n\n通过将这三个部分组合成一个迭代循环，该算法将为每个测试案例收敛到唯一的最小化子 $\\widehat{\\mathbf{p}}$。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves the constrained regression problem for cell type deconvolution\n    for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general, small noise)\n        {\n            \"G\": 5, \"K\": 3, \"alpha\": 1e-6,\n            \"S\": np.array([\n                [8, 2, 1],\n                [1, 7, 2],\n                [0, 1, 9],\n                [5, 2, 1],\n                [2, 3, 4]\n            ]),\n            \"y\": np.array([4.9, 2.95, 2.12, 3.27, 2.7]),\n            \"w\": np.array([1, 1, 1, 1, 1])\n        },\n        # Case B (pure cell type, no noise)\n        {\n            \"G\": 5, \"K\": 3, \"alpha\": 1e-6,\n            \"S\": np.array([\n                [8, 2, 1],\n                [1, 7, 2],\n                [0, 1, 9],\n                [5, 2, 1],\n                [2, 3, 4]\n            ]),\n            \"y\": np.array([2, 7, 1, 2, 3]),\n            \"w\": np.array([1, 1, 1, 1, 1])\n        },\n        # Case C (collinearity, exact mixture)\n        {\n            \"G\": 4, \"K\": 3, \"alpha\": 1e-6,\n            \"S\": np.array([\n                [3, 3, 1],\n                [2, 2, 0.5],\n                [1, 1, 4],\n                [0.5, 0.5, 2]\n            ]),\n            \"y\": np.array([2.6, 1.7, 1.6, 0.8]),\n            \"w\": np.array([1, 1, 1, 1, 1])\n        },\n        # Case D (zeros and dropout, moderate noise)\n        {\n            \"G\": 4, \"K\": 2, \"alpha\": 1e-6,\n            \"S\": np.array([\n                [0, 3],\n                [5, 0],\n                [0, 2],\n                [4, 1]\n            ]),\n            \"y\": np.array([1.15, 3.1, 0.4, 2.7]),\n            \"w\": np.array([1, 1, 1, 1])\n        },\n        # Case E (weighted fit, noisy second gene downweighted)\n        {\n            \"G\": 3, \"K\": 3, \"alpha\": 1e-6,\n            \"S\": np.array([\n                [10, 1, 0.5],\n                [0.5, 8, 1],\n                [1, 1, 6]\n            ]),\n            \"y\": np.array([2.65, 5.9, 2.4]),\n            \"w\": np.array([1, 0.2, 1])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p_hat = _projected_gradient_descent(\n            S=case[\"S\"],\n            y=case[\"y\"],\n            w=case[\"w\"],\n            alpha=case[\"alpha\"],\n            K=case[\"K\"]\n        )\n        all_results.append(p_hat)\n\n    formatted_results = []\n    for p_vec in all_results:\n        formatted_p = [f\"{x:.4f}\" for x in p_vec]\n        formatted_results.append(f\"[{','.join(formatted_p)}]\")\n\n    print(f\"[[{','.join(formatted_results)}]]\")\n\ndef _project_simplex(z):\n    \"\"\"\n    Projects a vector z onto the probability simplex.\n\n    This implementation uses the efficient O(K log K) algorithm.\n    \"\"\"\n    K = len(z)\n    u = np.sort(z)[::-1]\n    cssv = np.cumsum(u)\n    \n    # Find rho, the number of positive components in the projection\n    i = np.arange(K) + 1\n    # Condition: u_i > (1/i) * (cssv_i - 1)\n    # Using 0-indexed numpy arrays, this becomes u[i-1] > (1/i) * (cssv[i-1] - 1)\n    # rho is the largest i that satisfies this. np.where finds all such i.\n    rho_candidates = np.where(u > (cssv - 1) / i)[0]\n    \n    if len(rho_candidates) == 0:\n        # Fallback in case of numerical issues, should not be hit\n        rho = K\n    else:\n        rho = rho_candidates[-1] + 1\n\n    # Compute threshold theta\n    theta = (cssv[rho - 1] - 1) / rho\n    \n    # Apply soft-thresholding\n    p = np.maximum(z - theta, 0)\n    return p\n\n\ndef _projected_gradient_descent(S, y, w, alpha, K, max_iter=10000, tol=1e-9):\n    \"\"\"\n    Performs projected gradient descent to solve the constrained QP.\n    \"\"\"\n    # Initialize p at the center of the simplex\n    p = np.full(K, 1.0 / K)\n\n    # Pre-compute parts of the gradient and Hessian\n    W = np.diag(w)\n    ST_W = S.T @ W\n    ST_W_S = ST_W @ S\n    ST_W_y = ST_W @ y\n\n    # Compute Hessian and step size (eta)\n    Hessian = ST_W_S + alpha * np.identity(K)\n    # Lipschitz constant L is the maximum eigenvalue of the Hessian.\n    # The Hessian is symmetric, so use eigh for efficiency.\n    eigenvalues = scipy.linalg.eigh(Hessian, eigvals_only=True)\n    L = eigenvalues[-1]\n    eta = 1.0 / L\n\n    for i in range(max_iter):\n        # Gradient calculation: grad = S'W(Sp - y) + alpha*p\n        grad = ST_W_S @ p - ST_W_y + alpha * p\n        \n        # Update step\n        p_unconstrained = p - eta * grad\n        \n        # Projection onto the simplex\n        p_new = _project_simplex(p_unconstrained)\n        \n        # Check for convergence\n        if np.linalg.norm(p_new - p)  tol:\n            break\n            \n        p = p_new\n\n    # Final rounding is handled in the main solve() function\n    return p\n\nsolve()\n```"
        },
        {
            "introduction": "空间组学的一个核心目标是理解组织内细胞如何相互作用。通过分析表达配体（ligand）的细胞与其对应受体（receptor）的细胞在空间上的共定位关系，我们可以推断潜在的细胞间通讯网络。本练习将指导你构建一个考虑了细胞间距离的相互作用分数，并使用置换检验（permutation test）来评估其统计显著性，这是一种在空间背景下发现潜在信号通路的强大方法 。",
            "id": "4386274",
            "problem": "给定空间分辨的单细胞测量数据，其形式为配体及其同源受体的两个基因表达向量以及一组二维细胞坐标。您的任务是形式化一个配体-受体 (LR) 空间共表达分数，该分数应 (i) 遵循潜在的细胞间信号传导随细胞间距离增加而减弱的生物学原理，并且 (ii) 通过消除对边缘表达尺度的依赖性，使其在不同数据集之间具有可比性。然后，使用一种保留细胞位置和边缘分布的空间置换策略，为该分数推导出一个空分布，并为观察到的分数计算一个经验性双边显著性值。\n\n从基本原理出发：\n- 空间邻近性通过欧几里得距离量化。对于位置为 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 和 $\\mathbf{x}_j \\in \\mathbb{R}^2$ 的两个细胞 $i$ 和 $j$，欧几里得距离为 $d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$。\n- 细胞间信号传导的概率随距离递减，这通过一个各向同性、单调递减的核函数来捕捉。使用由 $k(d) = \\exp(-d / \\lambda)$ 给出的指数衰减核，其指定的衰减长度 $\\lambda  0$（单位为微米），并通过将自身权重设为零来排除自相互作用。\n- 为确保跨数据集的可比性，将每个表达向量标准化，使其在所有细胞上的均值为零，方差为一。\n\n您的程序必须：\n- 构建一个权重矩阵 $W$，其元素为 $W_{ij} = k(d_{ij})$（当 $i \\neq j$ 时）和 $W_{ii} = 0$，然后进行归一化，使得 $\\sum_{i \\neq j} W_{ij} = 1$。\n- 给定 $N$ 个细胞（$i \\in \\{1,\\dots,N\\}$）的配体表达 $L_i$ 和受体表达 $R_i$，计算标准化值 $\\tilde{L}_i = (L_i - \\bar{L})/\\sigma_L$ 和 $\\tilde{R}_i = (R_i - \\bar{R})/\\sigma_R$，其中 $\\bar{L}$ 和 $\\bar{R}$ 表示均值，$\\sigma_L$ 和 $\\sigma_R$ 表示标准差（如果标准差等于零，则将相应的标准化向量视为恒等于零）。\n- 通过使用基于距离的权重，对所有有序细胞对的标准化交叉乘积进行聚合，来定义空间 LR 分数。您必须排除自身对，并确保较短的细胞间距离比较长的细胞间距离贡献更大。最终的标量分数必须是无单位的。\n- 通过独立地置换配体表达值在细胞间的分配，同时保持受体表达和位置固定，生成一个保留细胞位置的空分布，重复此过程 $B$ 次。在此空假设下，计算经验性双边显著性值，公式为 $(1 + \\#\\{b \\in \\{1,\\dots,B\\}: |S^{(b)}| \\ge |S^{\\text{obs}}|\\})/(B+1)$，其中 $S^{\\text{obs}}$ 是观察到的分数，$S^{(b)}$ 是置换后的分数。使用固定的随机种子，以确保重复运行产生相同的结果。\n\n单位：\n- 坐标单位为微米。衰减长度 $\\lambda$ 的单位为微米。空间 LR 分数和经验显著性值是无单位的。\n\n角度单位：\n- 此问题中不使用角度。\n\n测试套件：\n对于下方的每个测试用例，使用指定的位置、表达量和衰减长度 $\\lambda$。使用 $B = 5000$ 次置换和固定的随机种子 $12345$。\n\n- 测试用例 1 (配体和受体簇分离；预期为负相关):\n  - 细胞数量 $N = 6$。\n  - 坐标 $(x_i,y_i)$ (单位：微米): $\\{(0,0),(2,1),(-1,-2),(50,0),(52,2),(49,-1)\\}$。\n  - 配体表达 $L = [8,7,6,1,1,1]$。\n  - 受体表达 $R = [1,1,1,7,8,6]$。\n  - 衰减长度 $\\lambda = 20$ 微米。\n\n- 测试用例 2 (配体和受体共定位；预期为正相关):\n  - 细胞数量 $N = 6$。\n  - 坐标与测试用例 1 相同。\n  - 配体表达 $L = [8,7,6,1,1,1]$。\n  - 受体表达 $R = [5,4,6,1,1,1]$。\n  - 衰减长度 $\\lambda = 20$ 微米。\n\n- 测试用例 3 (最小边缘案例):\n  - 细胞数量 $N = 2$。\n  - 坐标 $(x_i,y_i)$ (单位：微米): $\\{(0,0),(5,0)\\}$。\n  - 配体表达 $L = [10,0]$。\n  - 受体表达 $R = [0,8]$。\n  - 衰减长度 $\\lambda = 10$ 微米。\n\n输出规格：\n- 对于每个测试用例，使用上面定义的空分布（$B = 5000$，种子为 $12345$），计算经验性双边显著性值，结果为 $[0,1]$ 范围内的浮点数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，按测试用例 1、2、3 的顺序排列。每个值必须精确到小数点后 $6$ 位。例如，一个可接受的输出格式是 $[0.123456,0.500000,1.000000]$。",
            "solution": "该问题要求开发一种统计方法来检验配体-受体对的空间共表达。解决方案涉及定义一个分数，然后使用置换检验来评估其统计显著性。\n\n**1. 空间权重矩阵的构建**\n\n一个细胞对另一个细胞的影响被假定为随距离衰减。我们首先将其形式化为一个空间权重矩阵 $W$。\n\n给定 $N$ 个具有二维坐标 $\\mathbf{x}_1, \\mathbf{x}_2, \\dots, \\mathbf{x}_N$ 的细胞，我们计算成对欧几里得距离矩阵 $D$，其中 $D_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$。\n\n问题指定了一个指数衰减核 $k(d) = \\exp(-d / \\lambda)$，其衰减长度为 $\\lambda  0$。我们构建一个未归一化的权重矩阵 $W'$，其中每个元素 $W'_{ij}$ 代表从细胞 $i$ 到细胞 $j$ 的潜在相互作用强度。自相互作用被排除。\n$$\nW'_{ij} = \\begin{cases} \\exp(-D_{ij} / \\lambda)  \\text{if } i \\neq j \\\\ 0  \\text{if } i = j \\end{cases}\n$$\n为确保总权重在不同分析中保持恒定，我们对此矩阵进行归一化，使其所有元素之和等于 $1$。具体来说，是对所有非对角线元素求和。\n$$\nW_{ij} = \\frac{W'_{ij}}{\\sum_{k=1}^N \\sum_{l=1, l \\neq k}^N W'_{kl}}\n$$\n该矩阵 $W$ 是对称的，因为 $D_{ij} = D_{ji}$。\n\n**2. 表达数据的标准化**\n\n为了使分数在不同基因和数据集之间具有可比性，我们必须消除表达尺度的影响。我们将配体表达向量 $L = [L_1, \\dots, L_N]^T$ 和受体表达向量 $R = [R_1, \\dots, R_N]^T$ 进行标准化，使其均值为 $0$，标准差为 $1$。\n\n对于一个表达向量 $V$，其均值 $\\bar{V}$ 和总体标准差 $\\sigma_V$ 为：\n$$\n\\bar{V} = \\frac{1}{N} \\sum_{i=1}^N V_i, \\quad \\sigma_V = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (V_i - \\bar{V})^2}\n$$\n标准化后的表达值 $\\tilde{V}_i$ 为：\n$$\n\\tilde{V}_i = \\begin{cases} (V_i - \\bar{V}) / \\sigma_V  \\text{if } \\sigma_V  0 \\\\ 0  \\text{if } \\sigma_V = 0 \\end{cases}\n$$\n此过程应用于获得标准化向量 $\\tilde{L}$ 和 $\\tilde{R}$。\n\n**3. 空间配体-受体分数**\n\n空间 LR 分数 $S$ 定义为对所有有序细胞对的标准化表达值交叉乘积的加权聚合。乘积 $\\tilde{L}_i \\tilde{R}_j$ 代表了从细胞 $i$（表达配体）到细胞 $j$（表达受体）的潜在信号传导。该分数聚合了这些有向相互作用，并按其空间邻近性进行加权。\n$$\nS = \\sum_{i=1}^N \\sum_{j=1, j \\neq i}^N W_{ij} \\tilde{L}_i \\tilde{R}_j\n$$\n鉴于 $W_{ii}=0$，我们可以用矩阵表示法紧凑地表达这一点：\n$$\nS = \\sum_{i=1}^N \\sum_{j=1}^N \\tilde{L}_i W_{ij} \\tilde{R}_j = \\tilde{L}^T W \\tilde{R}\n$$\n这个分数是一个无单位的标量。正分表示配体表达量高的细胞倾向于靠近受体表达量高的细胞（或表达量低的靠近表达量低的），表明存在空间共定位。负分表示配体表达量高的细胞靠近受体表达量低的细胞，表明存在空间分离。\n\n**4. 基于置换的显著性检验**\n\n为了确定观察到的分数 $S^{\\text{obs}}$ 是否具有统计显著性，我们将其与一个空分布进行比较。零假设是配体和受体表达的空间模式之间没有关联。\n\n我们通过置换检验来生成这个空分布。我们保持细胞位置和受体表达向量 $R$ 不变，然后随机地置换细胞间的配体表达值。这个过程打破了配体表达值与细胞位置的特定分配关系，同时保留了配体表达的总体分布和细胞的空间排列。\n\n步骤如下：\n1.  使用原始数据 $L$ 和 $R$ 计算观察分数 $S^{\\text{obs}}$。\n2.  对于 $b = 1, \\dots, B$ 重复以下步骤：\n    a. 通过打乱 $L$ 的元素，生成一个置换后的配体向量 $L^{(b)}$。\n    b. 将 $L^{(b)}$ 标准化得到 $\\tilde{L}^{(b)}$。请注意，$\\tilde{L}^{(b)}$ 中的值集合只是 $\\tilde{L}$ 中值的一个置换。\n    c. 计算此置换的分数，$S^{(b)} = (\\tilde{L}^{(b)})^T W \\tilde{R}$。\n3.  集合 $\\{S^{(b)}\\}_{b=1}^B$ 构成了经验空分布。\n\n**5. 经验 p 值的计算**\n\n问题要求计算一个双边 p 值。这评估了在零假设下，观察到至少与观察分数一样极端（无论是正方向还是负方向）的分数的概率。我们计算有多少置换分数的绝对值大于或等于观察分数的绝对值。\n\n经验 p 值 $p$ 由以下公式给出：\n$$\np = \\frac{1 + |\\{b \\in \\{1,\\dots,B\\}: |S^{(b)}| \\ge |S^{\\text{obs}}|\\}|}{B+1}\n$$\n在分子和分母上加 $1$ 是一种标准做法，用以防止 p 值为 $0$，并考虑到观察数据点本身作为分布的一部分。\n\n这样就完成了该方法的形式化。实现将精确地遵循这些步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef standardize_expression(vec):\n    \"\"\"\n    Standardizes a vector to have mean 0 and variance 1.\n    If std dev is 0, returns a vector of zeros.\n    \"\"\"\n    std_dev = np.std(vec)\n    if std_dev == 0:\n        return np.zeros_like(vec, dtype=float)\n    return (vec - np.mean(vec)) / std_dev\n\ndef compute_spatial_lr_pvalue(coords, L, R, lam, B, seed):\n    \"\"\"\n    Computes the spatial LR score and its empirical p-value.\n\n    Args:\n        coords (np.ndarray): N x 2 array of cell coordinates.\n        L (np.ndarray): N-element array of ligand expression.\n        R (np.ndarray): N-element array of receptor expression.\n        lam (float): Decay length for the exponential kernel.\n        B (int): Number of permutations.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        float: The empirical two-sided p-value.\n    \"\"\"\n    N = coords.shape[0]\n\n    # 1. Construct the normalized spatial weight matrix W\n    dist_matrix = cdist(coords, coords, 'euclidean')\n    \n    # Exponential decay kernel; W' in the write-up\n    W_unnormalized = np.exp(-dist_matrix / lam)\n    np.fill_diagonal(W_unnormalized, 0)\n    \n    # Normalize by the sum of all off-diagonal elements\n    total_weight = np.sum(W_unnormalized)\n    if total_weight == 0:\n        # If all cells are infinitely far apart, weights are 0.\n        # Score will be 0, p-value undefined.\n        # Problem constraints ensure this doesn't happen, but good practice.\n        return 1.0\n        \n    W = W_unnormalized / total_weight\n\n    # 2. Standardize expression vectors\n    L_std = standardize_expression(L)\n    R_std = standardize_expression(R)\n\n    # 3. Calculate the observed score\n    # S_obs = L_std.T @ W @ R_std\n    S_obs = np.sum(L_std[:, np.newaxis] * W * R_std[np.newaxis, :])\n\n\n    # 4. Permutation testing\n    rng = np.random.default_rng(seed)\n    permuted_scores = np.zeros(B)\n    \n    # Optimization: permutation of standardized values is faster\n    # than re-standardizing in each loop iteration.\n    L_std_permute_base = np.copy(L_std)\n\n    for b in range(B):\n        permuted_L_std = rng.permutation(L_std_permute_base)\n        # S_perm = permuted_L_std.T @ W @ R_std\n        S_perm = np.sum(permuted_L_std[:, np.newaxis] * W * R_std[np.newaxis, :])\n        permuted_scores[b] = S_perm\n\n    # 5. Compute the empirical two-sided p-value\n    abs_S_obs = np.abs(S_obs)\n    num_extreme_scores = np.sum(np.abs(permuted_scores) >= abs_S_obs)\n    \n    p_value = (1.0 + num_extreme_scores) / (1.0 + B)\n    \n    return p_value\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the spatial LR analysis on them.\n    \"\"\"\n    B = 5000\n    seed = 12345\n\n    test_cases = [\n        {\n            \"coords\": np.array([[0,0],[2,1],[-1,-2],[50,0],[52,2],[49,-1]]),\n            \"L\": np.array([8,7,6,1,1,1]),\n            \"R\": np.array([1,1,1,7,8,6]),\n            \"lam\": 20.0\n        },\n        {\n            \"coords\": np.array([[0,0],[2,1],[-1,-2],[50,0],[52,2],[49,-1]]),\n            \"L\": np.array([8,7,6,1,1,1]),\n            \"R\": np.array([5,4,6,1,1,1]),\n            \"lam\": 20.0\n        },\n        {\n            \"coords\": np.array([[0,0],[5,0]]),\n            \"L\": np.array([10,0]),\n            \"R\": np.array([0,8]),\n            \"lam\": 10.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = compute_spatial_lr_pvalue(\n            case[\"coords\"], case[\"L\"], case[\"R\"], case[\"lam\"], B, seed\n        )\n        results.append(p_val)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}