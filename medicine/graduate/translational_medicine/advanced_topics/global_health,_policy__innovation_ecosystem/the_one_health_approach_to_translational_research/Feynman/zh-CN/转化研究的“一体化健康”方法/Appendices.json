{
    "hands_on_practices": [
        {
            "introduction": "在“同一健康”框架下，对人畜共患病风险进行量化是制定有效监测和预防策略的第一步。接触矩阵是流行病学中的一个基础工具，它能帮助我们理解并模型化病原体在不同物种间的传播方式。本练习将通过一个假设的场景，指导您如何使用接触率、感染率和传播概率等核心参数，从基本原理出发推导出跨物种传播事件的预期数量，这是评估人与动物接触界面溢出风险的核心技能。",
            "id": "5069077",
            "problem": "一种人畜共患呼吸道病原体正在城乡结合部接受“同一健康”（One Health, OH）方法下的早期外溢监测，该方法整合了人类、家养动物和野生动物的健康。考虑两个宿主物种：人类（表示为 $H$）和蝙蝠（表示为 $B$）。接触矩阵项 $C_{ij}$ 定义为从物种 $i$ 到物种 $j$ 的每个源个体的潜在感染性接触率，单位为 接触次数/个体/天。假设接触遵循无记忆过程，并且每次接触以单次接触传播概率 $q$ 独立地导致病原体转移。设 $N_{i}$ 为物种 $i$ 的总种群数量， $p_{i}$ 为物种 $i$ 中感染个体的比例。\n\n针对 $B \\to H$ 的传播方向，给定以下情景数据：$N_{B} = 30{,}000$，$p_{B} = 0.003$，$C_{BH} = 0.025~\\text{day}^{-1}$，以及 $q = 0.06$。从接触率和单次接触传播概率的核心定义出发，推导一个表达式，用于计算在 $p_{B}$ 很小的早期阶段，单位时间内从蝙蝠到人类的跨物种传播事件的期望数量。使用您的推导计算每天成功的 $B \\to H$ 传播事件的期望数量。将最终数值答案四舍五入到四位有效数字，并以 事件/天 为单位表示。",
            "solution": "首先根据既定标准对问题进行验证。\n\n### 第1步：提取已知条件\n- 宿主物种：人类 ($H$)，蝙蝠 ($B$)。\n- $C_{ij}$：从物种 $i$ 到物种 $j$ 的每个源个体的潜在感染性接触率，单位为 接触次数/个体/天。\n- $q$：单次接触传播概率。\n- $N_{i}$：物种 $i$ 的总种群数量。\n- $p_{i}$：物种 $i$ 中感染个体的比例。\n- 接触过程：无记忆，每次接触都是一个独立的传播事件。\n- $B \\to H$ 传播的情景数据：\n  - $N_{B} = 30,000$\n  - $p_{B} = 0.003$\n  - $C_{BH} = 0.025~\\text{day}^{-1}$\n  - $q = 0.06$\n- 目标：推导一个表达式，用于计算单位时间内从蝙蝠到人类的跨物种传播事件的期望数量，然后计算其每日数值。\n- 四舍五入：最终数值答案必须四舍五入到四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n对问题的有效性进行审查。\n- **科学依据**：该问题使用了数学流行病学中的标准概念，如接触率、患病率、种群数量和传播概率。“同一健康”方法用于人畜共患病外溢的框架是公共卫生和转化医学中一个成熟的概念。给定的参数是假设性的，但在一个早期人畜共患病事件的合理范围内。该问题在科学上是合理的。\n- **适定性**：问题清晰地定义了所有变量，并提供了计算所需量值的全部必要数据。目标明确无误，可以确定一个唯一且有意义的解。\n- **客观性**：语言精确且专业，没有主观或基于观点的断言。\n- **一致性与完整性**：问题是自洽的。所提供的数据彼此一致，足以进行推导和计算。没有矛盾或缺失关键信息。关于 $p_B$ 很小的陈述与 $p_B = 0.003$ 的值是一致的。\n\n### 第3步：结论与行动\n问题被判定为有效。将提供一个合理的解决方案。\n\n### 推导与求解\n目标是推导一个表达式，用于计算单位时间内从蝙蝠种群 ($B$) 到人类种群 ($H$) 的成功跨物种传播事件的期望数量。我们将此量表示为 $\\Lambda_{BH}$。推导过程从所提供的基本定义开始。\n\n1.  **传染源个体数量**：蝙蝠的总种群数量为 $N_{B}$，感染性蝙蝠的比例为 $p_{B}$。因此，能够传播病原体的感染性蝙蝠的绝对数量 $I_{B}$ 是这两个量的乘积：\n    $$I_{B} = N_{B} p_{B}$$\n\n2.  **跨物种接触总率**：术语 $C_{BH}$ 定义为从物种 $B$ 到物种 $H$ 的每个源个体的接触率。这意味着一只蝙蝠每天与人类种群发生 $C_{BH}$ 次接触。为了求得源于整个感染性蝙蝠种群的总接触率，我们将感染性蝙蝠的数量 $I_{B}$ 乘以每个个体的接触率 $C_{BH}$。\n    $$\\text{总接触率} = I_{B} \\times C_{BH} = (N_{B} p_{B}) C_{BH}$$\n    该表达式的单位是 $(\\text{个体}) \\times (\\frac{\\text{接触次数}}{\\text{个体} \\cdot \\text{天}}) = \\frac{\\text{接触次数}}{\\text{天}}$。这表示每天从蝙蝠种群到人类种群的潜在感染性接触的总次数。\n\n3.  **传播事件的期望数量**：每次接触都是一次独立的传播机会，成功概率为 $q$。由于接触过程是无记忆的，总传播事件数可以建模为一系列伯努利试验。期望的成功（传播）次数是总试验（接触）次数乘以每次试验的成功概率 ($q$)。\n    因此，每天在人类中发生新感染的期望数量 $\\Lambda_{BH}$ 为：\n    $$\\Lambda_{BH} = (\\text{总接触率}) \\times q$$\n    代入上一步的表达式，我们得到最终推导出的表达式：\n    $$\\Lambda_{BH} = N_{B} p_{B} C_{BH} q$$\n\n这个表达式代表了单位时间内从蝙蝠到人类的跨物种传播事件的期望数量。\n\n现在，我们将给定的数值代入此表达式，以计算该情景下的具体速率。\n- $N_{B} = 30,000$\n- $p_{B} = 0.003$\n- $C_{BH} = 0.025~\\text{day}^{-1}$\n- $q = 0.06$\n\n首先，计算感染性蝙蝠的数量：\n$$I_{B} = 30,000 \\times 0.003 = 90$$\n所以有 $90$ 只感染性蝙蝠。\n\n接下来，计算每天的潜在感染性接触总率：\n$$\\text{总接触率} = 90 \\times 0.025~\\text{day}^{-1} = 2.25~\\text{day}^{-1}$$\n\n最后，计算每天成功传播事件的期望数量：\n$$\\Lambda_{BH} = 2.25~\\text{day}^{-1} \\times 0.06 = 0.135~\\text{day}^{-1}$$\n\n问题要求答案四舍五入到四位有效数字。计算值为 $0.135$。为了用四位有效数字表示，我们在末尾加一个零。\n$$\\Lambda_{BH} \\approx 0.1350~\\text{事件/天}$$",
            "answer": "$$\\boxed{0.1350}$$"
        },
        {
            "introduction": "一旦病原体开始传播，可靠的检测便成为控制疫情的关键。然而，一项诊断检测在不同物种中的表现可能截然不同，这是转化医学研究中一个常见的挑战。本练习将应用贝叶斯定理来探讨诊断测试的阳性预测值（$PPV$）如何因物种间的患病率和检测特性差异而发生显著变化，从而强调了在“同一健康”应用中进行物种特异性验证的重要性。",
            "id": "5069050",
            "problem": "一个“健康一体”框架下的转化研究团队正在验证一种单一逆转录聚合酶链反应(RT-PCR)检测方法，该方法用于检测一种同时感染人类和牛的人畜共患呼吸道病原体。由于物种特异性的样本基质效应，该检测方法在不同物种中表现出不同的操作特性。在人类中，该检测方法的灵敏度为 $\\,\\mathrm{Se}_{H} = 0.95\\,$，特异性为 $\\,\\mathrm{Sp}_{H} = 0.98\\,$；在牛中，该检测方法的灵敏度为 $\\,\\mathrm{Se}_{C} = 0.90\\,$，特异性为 $\\,\\mathrm{Sp}_{C} = 0.97\\,$。在人类中，检测前概率（患病率）为 $\\,\\pi_{H} = 0.04\\,$，而在牛中的 $\\,\\pi_{C}\\,$ 未知。阳性预测值(PPV)定义为在检测结果为阳性的条件下，个体确实感染的后验概率。\n\n仅从(i) Kolmogorov axioms of probability, (ii) Bayes’ theorem $\\,P(A \\mid B) = \\frac{P(B \\mid A)\\,P(A)}{P(B)}\\,$, (iii) the law of total probability, 以及(iv) 核心诊断定义 $\\,\\mathrm{Se} = P(T^{+} \\mid D)\\,$ 和 $\\,\\mathrm{Sp} = P(T^{-} \\mid \\neg D)\\,$（其中 $\\,D\\,$ 表示患病，$\\,T^{+}\\,$ 表示检测结果为阳性）出发，推导不同物种中检测前概率 $\\,\\pi\\,$ 与 $\\,\\text{PPV}\\,$ 之间的关系。然后，使用人类群体的参数计算 $\\,\\text{PPV}_{H}\\,$。最后，确定牛的患病率 $\\,\\pi_{C}\\,$，使得牛的PPV等于人的PPV，即 $\\,\\text{PPV}_{C}(\\pi_{C}) = \\text{PPV}_{H}\\,$。将 $\\,\\pi_{C}\\,$ 的最终答案表示为四舍五入到四位有效数字的小数。不需要单位。不要使用百分号；以小数形式表示概率。",
            "solution": "该问题经验证是自洽的、有科学依据且定义明确的。解题过程如下。\n\n目标是推导阳性预测值(PPV)关于检测前概率($\\pi$)、灵敏度($\\mathrm{Se}$)和特异性($\\mathrm{Sp}$)的表达式；计算人类群体的PPV($\\text{PPV}_{H}$)；然后确定能产生等效PPV的牛群检测前概率($\\pi_{C}$)。\n\n设 $D$ 为个体患病的事件，$\\neg D$ 为个体未患病的事件。设 $T^{+}$ 为检测结果为阳性的事件。检测前概率，即患病率，记为 $\\pi = P(D)$。根据概率公理，未患病的概率为 $P(\\neg D) = 1 - P(D) = 1 - \\pi$。\n\n提供的核心诊断定义如下：\n灵敏度：$\\mathrm{Se} = P(T^{+} \\mid D)$\n特异性：$\\mathrm{Sp} = P(T^{-} \\mid \\neg D)$，其中 $T^{-}$ 为检测结果阴性。\n\n根据条件概率的定义和补集法则，未患病情况下检测结果为阳性的概率（假阳性率）为 $P(T^{+} \\mid \\neg D) = 1 - P(T^{-} \\mid \\neg D) = 1 - \\mathrm{Sp}$。\n\n阳性预测值(PPV)是在检测结果为阳性的条件下患病的后验概率，$P(D \\mid T^{+})$。使用贝叶斯定理(Bayes’ theorem)，$P(A \\mid B) = \\frac{P(B \\mid A)P(A)}{P(B)}$，我们可以写出：\n$$ \\text{PPV} = P(D \\mid T^{+}) = \\frac{P(T^{+} \\mid D) P(D)}{P(T^{+})} $$\n分子可以使用给定的定义表示为 $P(T^{+} \\mid D) P(D) = \\mathrm{Se} \\cdot \\pi$。\n\n分母 $P(T^{+})$ 是检测结果为阳性的总概率。使用全概率定律，我们可以通过对患病状态（$D$ 或 $\\neg D$）进行条件化来展开 $P(T^{+})$：\n$$ P(T^{+}) = P(T^{+} \\mid D) P(D) + P(T^{+} \\mid \\neg D) P(\\neg D) $$\n代入各项的表达式：\n$$ P(T^{+}) = (\\mathrm{Se} \\cdot \\pi) + ((1 - \\mathrm{Sp}) \\cdot (1 - \\pi)) $$\n将分子和展开后的分母结合起来，得到PPV与检测前概率 $\\pi$ 之间的一般关系：\n$$ \\text{PPV}(\\pi, \\mathrm{Se}, \\mathrm{Sp}) = \\frac{\\mathrm{Se} \\cdot \\pi}{\\mathrm{Se} \\cdot \\pi + (1 - \\mathrm{Sp})(1 - \\pi)} $$\n这就完成了任务的第一部分。\n\n接下来，我们使用人类群体的参数计算 $\\text{PPV}_{H}$：灵敏度 $\\mathrm{Se}_{H} = 0.95$，特异性 $\\mathrm{Sp}_{H} = 0.98$，以及检测前概率 $\\pi_{H} = 0.04$。\n$$ \\text{PPV}_{H} = \\frac{\\mathrm{Se}_{H} \\cdot \\pi_{H}}{\\mathrm{Se}_{H} \\cdot \\pi_{H} + (1 - \\mathrm{Sp}_{H})(1 - \\pi_{H})} $$\n$$ \\text{PPV}_{H} = \\frac{0.95 \\cdot 0.04}{0.95 \\cdot 0.04 + (1 - 0.98)(1 - 0.04)} $$\n$$ \\text{PPV}_{H} = \\frac{0.038}{0.038 + (0.02)(0.96)} $$\n$$ \\text{PPV}_{H} = \\frac{0.038}{0.038 + 0.0192} $$\n$$ \\text{PPV}_{H} = \\frac{0.038}{0.0572} = \\frac{380}{572} = \\frac{95}{143} $$\n人类群体中阳性预测值的精确值为 $\\frac{95}{143}$。\n\n最后，我们必须找到牛的患病率 $\\pi_{C}$，使得牛的PPV，即 $\\text{PPV}_{C}(\\pi_{C})$，等于 $\\text{PPV}_{H}$。牛的参数为灵敏度 $\\mathrm{Se}_{C} = 0.90$ 和特异性 $\\mathrm{Sp}_{C} = 0.97$。\n$\\text{PPV}_{C}$ 的表达式为：\n$$ \\text{PPV}_{C}(\\pi_{C}) = \\frac{\\mathrm{Se}_{C} \\cdot \\pi_{C}}{\\mathrm{Se}_{C} \\cdot \\pi_{C} + (1 - \\mathrm{Sp}_{C})(1 - \\pi_{C})} $$\n$$ \\text{PPV}_{C}(\\pi_{C}) = \\frac{0.90 \\cdot \\pi_{C}}{0.90 \\cdot \\pi_{C} + (1 - 0.97)(1 - \\pi_{C})} $$\n$$ \\text{PPV}_{C}(\\pi_{C}) = \\frac{0.90 \\pi_{C}}{0.90 \\pi_{C} + 0.03(1 - \\pi_{C})} $$\n$$ \\text{PPV}_{C}(\\pi_{C}) = \\frac{0.90 \\pi_{C}}{0.90 \\pi_{C} + 0.03 - 0.03 \\pi_{C}} $$\n$$ \\text{PPV}_{C}(\\pi_{C}) = \\frac{0.90 \\pi_{C}}{0.87 \\pi_{C} + 0.03} $$\n我们令其等于计算出的 $\\text{PPV}_{H}$：\n$$ \\frac{0.90 \\pi_{C}}{0.87 \\pi_{C} + 0.03} = \\frac{95}{143} $$\n现在我们求解 $\\pi_{C}$。交叉相乘得到：\n$$ 143 \\cdot (0.90 \\pi_{C}) = 95 \\cdot (0.87 \\pi_{C} + 0.03) $$\n$$ 128.7 \\pi_{C} = 82.65 \\pi_{C} + 2.85 $$\n$$ (128.7 - 82.65) \\pi_{C} = 2.85 $$\n$$ 46.05 \\pi_{C} = 2.85 $$\n$$ \\pi_{C} = \\frac{2.85}{46.05} $$\n$$ \\pi_{C} \\approx 0.06188925... $$\n问题要求答案以四舍五入到四位有效数字的小数表示。前四位有效数字是 $6$、$1$、$8$、$8$。第五位数字是 $9$，所以我们将第四位数字向上舍入。\n$$ \\pi_{C} \\approx 0.06189 $$\n因此，牛群中约 $0.06189$ 的患病率将导致其阳性预测值与在人群中观察到的值相等。",
            "answer": "$$\n\\boxed{0.06189}\n$$"
        },
        {
            "introduction": "许多“同一健康”问题涉及复杂的演化动态，例如由人类、牲畜和野生动物种群间的选择压力和混合驱动的抗微生物药物抗性的出现。这个高级练习将引导您进入系统层面的思考，通过构建并分析一个多宿主演化模型，来量化不同干预策略（如加强生物安全或改进药物管理）如何改变抗性出现的速率。掌握这种模型化方法对于评估和设计旨在减缓抗性演化的转化研究至关重要。",
            "id": "5069047",
            "problem": "要求您形式化并实现一个符合“同一健康”理念的确定性多宿主进化动力学模型，在该模型中，抗性基因型和易感基因型在多个宿主之间竞争和混合。目标是量化指定的干预措施如何改变抗性出现的早期速率。您的解决方案必须从广为接受的种群遗传学和质量作用混合原理出发，推导出适当的线性化以分离出一个可解释的速率，然后通过编程计算该速率在几种测试场景下的值。最终输出必须按照下文规定，将所有测试案例的结果汇总到单行中。\n\n基本原理和定义：\n- 考虑 $H$ 个宿主区室，索引为 $i \\in \\{1,\\dots,H\\}$，每个区室有两种基因型：易感型（$S$）和抗性型（$R$）。令 $x_i(t) \\in [0,1]$ 表示在时间 $t$（单位为天）时，宿主 $i$ 中基因型 $R$ 的比例。\n- 令 $w_{i,S}$ 和 $w_{i,R}$ 分别表示宿主 $i$ 内 $S$ 和 $R$ 的宿主内繁殖适应度（单位：每天）。通过 $w_{i,R} - w_{i,S} = s_i$（单位：每天）定义选择系数 $s_i$。\n- 令 $\\mu_{S \\to R}$ 和 $\\mu_{R \\to S}$ 分别表示从 $S$ 到 $R$ 和从 $R$ 到 $S$ 的每日突变率。\n- 令 $m_{j i} \\ge 0$（单位：每天）表示质量作用混合速率，即宿主 $j$ 对宿主 $i$ 的基因型混合贡献。混合项表示为 $\\sum_{j \\ne i} m_{j i}\\big(x_j - x_i\\big)$，它将 $x_i$ 驱动向其他宿主的加权平均值，在粗粒化意义上保持了跨宿主的总种群守恒。\n\n模型方程：\n- 在具有质量作用宿主间混合的复制子-突变子动力学下，比例 $x_i(t)$ 服从\n$$\n\\frac{dx_i}{dt} = x_i(1 - x_i)\\, s_i + \\mu_{S \\to R} (1 - x_i) - \\mu_{R \\to S}\\, x_i + \\sum_{j \\ne i} m_{j i}\\big(x_j - x_i\\big).\n$$\n- 早期出现由 $x_i \\approx 0$ 附近的线性化所决定。将上述方程在抗性稀有状态附近进行线性化，得到\n$$\n\\frac{dx_i}{dt} \\approx \\underbrace{s_i\\, x_i - (\\mu_{S \\to R} + \\mu_{R \\to S})\\, x_i - \\left(\\sum_{j \\ne i} m_{j i}\\right) x_i + \\sum_{j \\ne i} m_{j i} x_j}_{\\text{齐次线性部分}} + \\underbrace{\\mu_{S \\to R}}_{\\text{恒定源项}},\n$$\n可以紧凑地写为\n$$\n\\frac{d\\mathbf{x}}{dt} = A\\, \\mathbf{x} + \\mathbf{b}, \\quad \\text{其中} \\quad \\mathbf{x} = (x_1, \\dots, x_H)^\\top,\n$$\n其中\n$$\nA_{i i} = s_i - (\\mu_{S \\to R} + \\mu_{R \\to S}) - \\sum_{j \\ne i} m_{j i}, \\quad A_{i j} = m_{j i} \\ \\text{对于} \\ i \\ne j, \\quad \\mathbf{b}_i = \\mu_{S \\to R}.\n$$\n- 恒定源向量 $\\mathbf{b}$ 设定了一个注入尺度，但并不决定零点附近的渐近增长率。一个有原则且可解释的早期抗性出现速率是 $A$ 的主特征值（最大实部），记为 $\\lambda_{\\max}(A)$，单位为每天。该量控制了在齐次线性动力学下微小抗性比例的指数趋势，并广泛用于稳定性和入侵分析。\n\n任务：\n1. 对于每个测试案例，根据提供的基线参数（$s_i$、$\\mu_{S \\to R}$、$\\mu_{R \\to S}$、$m_{j i}$）构建矩阵 $A$，并计算基线出现速率 $r_{\\text{base}} = \\lambda_{\\max}(A_{\\text{base}})$，单位为每天。\n2. 应用指定的干预策略（修改后的 $s_i$ 和 $m_{j i}$），构建 $A_{\\text{int}}$，并计算 $r_{\\text{int}} = \\lambda_{\\max}(A_{\\text{int}})$，单位为每天。\n3. 以无量纲小数形式报告由干预引起的速率分数变化\n$$\n\\Delta = \\frac{r_{\\text{base}} - r_{\\text{int}}}{\\lvert r_{\\text{base}} \\rvert}.\n$$\n如果 $r_{\\text{base}}  0$，则正的 $\\Delta$ 表示早期抗性出现速率的降低。所有速率的单位均为每天，分数变化 $\\Delta$ 是无量纲的；不应使用百分号。\n\n测试套件（使用 $H=3$ 个宿主；将宿主 $1$ 解释为人类，宿主 $2$ 为牲畜，宿主 $3$ 为野生动物）：\n- 测试案例 1（理想路径；中度宿主间混合；管理措施降低选择压力，生物安全措施减少混合）：\n  - 基线：$s = [0.08, -0.02, 0.00]$ 每天，$\\mu_{S \\to R} = 10^{-7}$ 每天，$\\mu_{R \\to S} = 10^{-6}$ 每天，\n    $M_{\\text{base}} = \\begin{bmatrix} 0  0.02  0.005 \\\\ 0.02  0  0.003 \\\\ 0.005  0.003  0 \\end{bmatrix}$ 每天，其中 $M_{j i} = m_{j i}$。\n  - 干预：$s' = [0.01, -0.02, 0.00]$ 每天，\n    $M_{\\text{int}} = \\begin{bmatrix} 0  0.005  0.002 \\\\ 0.005  0  0.003 \\\\ 0.002  0.003  0 \\end{bmatrix}$ 每天。\n- 测试案例 2（边界情况；零混合；管理措施消除一个宿主中的优势）：\n  - 基线：$s = [0.03, -0.01, -0.01]$ 每天，$\\mu_{S \\to R} = 10^{-7}$ 每天，$\\mu_{R \\to S} = 10^{-6}$ 每天，\n    $M_{\\text{base}} = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$ 每天。\n  - 干预：$s' = [0.00, -0.01, -0.01]$ 每天，\n    $M_{\\text{int}} = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$ 每天。\n- 测试案例 3（更高混合度和中等选择压力；联合疫苗接种和管理措施共同降低混合和选择）：\n  - 基线：$s = [0.02, 0.01, 0.01]$ 每天，$\\mu_{S \\to R} = 5 \\times 10^{-7}$ 每天，$\\mu_{R \\to S} = 10^{-6}$ 每天，\n    $M_{\\text{base}} = \\begin{bmatrix} 0  0.015  0.01 \\\\ 0.015  0  0.012 \\\\ 0.01  0.012  0 \\end{bmatrix}$ 每天。\n  - 干预：$s' = [0.005, 0.005, 0.005]$ 每天，\n    $M_{\\text{int}} = 0.4 \\times M_{\\text{base}}$ 每天（即，混合速率降低 $60\\%$，通过将条目乘以 $0.4$ 来表示）。\n- 测试案例 4（边缘情况；极低的从头突变以确认速率度量与恒定注入无关）：\n  - 基线：$s$ 和 $M_{\\text{base}}$ 与测试案例 1 相同，但 $\\mu_{S \\to R} = 10^{-12}$ 每天，$\\mu_{R \\to S} = 10^{-6}$ 每天。\n  - 干预：$s'$ 和 $M_{\\text{int}}$ 与测试案例 1 相同。\n\n实现和输出规范：\n- 您的程序必须为每个基线和干预对构建 $A$ 并计算 $\\lambda_{\\max}(A)$，为每个测试案例计算 $\\Delta$，并将所有测试案例的结果汇总到单行输出中，格式为方括号内包含的逗号分隔列表，例如 `[result1,result2,result3,result4]`。\n- 所有速率必须以每天为单位进行处理。最终报告的值是每个测试案例的无量纲分数变化 $\\Delta$。",
            "solution": "目标是量化几种干预策略对多宿主系统中抗性基因型早期出现的影响。该问题在“同一健康”范式框架内提出，考虑了人类、牲畜和野生动物种群之间的相互作用。分析的核心是一组常微分方程组，该方程组模拟了每个宿主区室 $i$ 中抗性基因型比例 $x_i(t)$ 的变化。\n\n提供的模型是：\n$$\n\\frac{dx_i}{dt} = x_i(1 - x_i)\\, s_i + \\mu_{S \\to R} (1 - x_i) - \\mu_{R \\to S}\\, x_i + \\sum_{j \\ne i} m_{j i}\\big(x_j - x_i\\big)\n$$\n其中 $s_i$ 是选择系数，$\\mu_{S \\to R}$ 和 $\\mu_{R \\to S}$ 是突变率，$m_{ji}$ 是宿主间的混合率。\n\n为分析抗性的初始出现，动力学在抗性稀有状态（所有 $x_i \\approx 0$）附近进行线性化。这导出了线性系统：\n$$\n\\frac{d\\mathbf{x}}{dt} = A\\, \\mathbf{x} + \\mathbf{b}\n$$\n出现速率由矩阵 $A$ 的性质决定，该矩阵捕捉了线性化动力学的齐次部分。常数向量 $\\mathbf{b}$ 代表由从头突变引起的源项，不影响指数增长率。早期出现速率的原则性度量是 $A$ 的主特征值，记为 $r = \\lambda_{\\max}(A)$，它对应于具有最大实部的特征值。正的 $r$ 值表示微小的抗性比例将倾向于指数增长，而负的 $r$ 值表示它们将衰减。\n\n主要任务是计算由干预导致的该出现速率的分数变化 $\\Delta$。其计算公式为：\n$$\n\\Delta = \\frac{r_{\\text{base}} - r_{\\text{int}}}{\\lvert r_{\\text{base}} \\rvert}\n$$\n其中 $r_{\\text{base}} = \\lambda_{\\max}(A_{\\text{base}})$ 和 $r_{\\text{int}} = \\lambda_{\\max}(A_{\\text{int}})$ 分别是基线和干预情景的出现速率。正的 $\\Delta$ 值表示一次成功的干预，降低了抗性出现的速率。对于每个测试案例，逻辑分三个主要步骤进行。\n\n**步骤 1：构建系统矩阵 $A$**\n\n大小为 $H \\times H$（所有测试案例中 $H=3$）的矩阵 $A$ 是根据模型参数构建的。其元素定义如下：\n$$\nA_{ii} = s_i - (\\mu_{S \\to R} + \\mu_{R \\to S}) - \\sum_{j \\ne i} m_{j i}\n$$\n$$\nA_{ij} = m_{j i} \\quad \\text{对于} \\quad i \\ne j\n$$\n\n这里，$i$ 和 $j$ 是从 $1$ 到 $H$ 的 1-based 索引。\n- 对角元素 $A_{ii}$ 聚合了对宿主 $i$ 抗性比例的影响。它包括正选择（$s_i$）、净反向突变导致的衰减（项 $-(\\mu_{S \\to R} + \\mu_{R \\to S})$ 是一个轻微的简化，但根据问题陈述中从线性化推导，它代表了突变对 $x_i$ 种群的净效应），以及与其他宿主种群混合造成的稀释（项 $-\\sum_{j \\ne i} m_{j i}$）。\n- 非对角元素 $A_{ij}$ 代表宿主 $j$ 通过混合对宿主 $i$ 的贡献，速率为 $m_{ji}$。问题规定，所提供的混合矩阵 $M$ 遵循约定 $M_{ji} = m_{ji}$。因此，为构建 $A$，非对角元素 $A_{ij}$ 取自给定矩阵 $M$ 的第 $j$ 行第 $i$ 列的条目。这对应于使用 $M$ 的转置作为 $A$ 的非对角部分。对角项的求和 $\\sum_{j \\ne i} m_{j i}$ 是 $M$ 的第 $i$ 列之和（因为 $M$ 的对角线条目为零）。\n\n**步骤 2：计算出现速率 $r = \\lambda_{\\max}(A)$**\n\n一旦为给定情景（基线或干预）构建了矩阵 $A$，就对其进行数值计算以求得特征值。出现速率 $r$ 是所有计算出的特征值实部中的最大值。该值决定了线性化系统的长期行为：如果 $r  0$，则系统在无抗性状态下是不稳定的，抗性预计会产生并增长。\n\n**步骤 3：计算分数变化 $\\Delta$**\n\n对于每个测试案例，我们使用基线参数计算 $r_{\\text{base}}$，使用干预参数计算 $r_{\\text{int}}$。然后使用指定公式计算分数变化 $\\Delta$。这个无量纲量提供了衡量干预有效性的标准化度量。\n\n整个过程以编程方式实现。设计一个函数，该函数接收一个情景的参数集（$s$、$\\mu$s、$M$），构建相应的矩阵 $A$，并返回其主特征值。对每个测试案例的基线和干预配置都调用此函数。得到的速率随后用于计算 $\\Delta$。最终输出将所有测试案例的 $\\Delta$ 值汇总成一个格式化的字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the computation for all test cases.\n    \"\"\"\n\n    def get_emergence_rate(s, mu_sr, mu_rs, M, H=3):\n        \"\"\"\n        Constructs the matrix A and computes its dominant eigenvalue (emergence rate).\n\n        Args:\n            s (np.ndarray): Array of selection coefficients for each host.\n            mu_sr (float): Mutation rate from susceptible to resistant.\n            mu_rs (float): Mutation rate from resistant to susceptible.\n            M (np.ndarray): Mixing matrix where M[j, i] is the rate m_ji.\n            H (int): Number of hosts.\n\n        Returns:\n            float: The dominant eigenvalue of matrix A.\n        \"\"\"\n        # Initialize the H x H matrix A\n        A = np.zeros((H, H))\n        \n        # Total mutation effect on the resistant fraction\n        mu_tot = mu_sr + mu_rs\n        \n        # Calculate column sums of M for the diagonal part of A.\n        # Since M_diag is zero, sum(M[:, i]) is equivalent to sum_{j!=i} m_ji.\n        col_sums_M = np.sum(M, axis=0)\n\n        for i in range(H):\n            # Set the diagonal elements of A\n            A[i, i] = s[i] - mu_tot - col_sums_M[i]\n            for j in range(H):\n                if i != j:\n                    # Set the off-diagonal elements of A.\n                    # A_ij = m_ji which is given as M_ji.\n                    # In 0-based numpy, A[i, j] = M[j, i].\n                    A[i, j] = M[j, i]\n\n        # Compute eigenvalues of A\n        eigenvalues = np.linalg.eigvals(A)\n        \n        # The emergence rate is the largest real part of the eigenvalues\n        r = np.max(np.real(eigenvalues))\n        \n        return r\n\n    def calculate_delta(params_base, params_int):\n        \"\"\"\n        Calculates the fractional change in emergence rate for a test case.\n\n        Args:\n            params_base (dict): Dictionary of baseline parameters.\n            params_int (dict): Dictionary of intervention parameters.\n\n        Returns:\n            float: The fractional change delta.\n        \"\"\"\n        r_base = get_emergence_rate(**params_base)\n        r_int = get_emergence_rate(**params_int)\n        \n        if np.abs(r_base) == 0:\n            # Handle the undefined case, though not expected in these tests.\n            # A large number could signify an infinite relative change.\n            return np.inf if r_base != r_int else 0.0\n\n        delta = (r_base - r_int) / np.abs(r_base)\n        return delta\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"baseline\": {\n                \"s\": np.array([0.08, -0.02, 0.00]),\n                \"mu_sr\": 1e-7, \"mu_rs\": 1e-6,\n                \"M\": np.array([\n                    [0, 0.02, 0.005],\n                    [0.02, 0, 0.003],\n                    [0.005, 0.003, 0]\n                ])\n            },\n            \"intervention\": {\n                \"s\": np.array([0.01, -0.02, 0.00]),\n                \"mu_sr\": 1e-7, \"mu_rs\": 1e-6,\n                \"M\": np.array([\n                    [0, 0.005, 0.002],\n                    [0.005, 0, 0.003],\n                    [0.002, 0.003, 0]\n                ])\n            }\n        },\n        # Test case 2\n        {\n            \"baseline\": {\n                \"s\": np.array([0.03, -0.01, -0.01]),\n                \"mu_sr\": 1e-7, \"mu_rs\": 1e-6,\n                \"M\": np.zeros((3, 3))\n            },\n            \"intervention\": {\n                \"s\": np.array([0.00, -0.01, -0.01]),\n                \"mu_sr\": 1e-7, \"mu_rs\": 1e-6,\n                \"M\": np.zeros((3, 3))\n            }\n        },\n        # Test case 3\n        {\n            \"baseline\": {\n                \"s\": np.array([0.02, 0.01, 0.01]),\n                \"mu_sr\": 5e-7, \"mu_rs\": 1e-6,\n                \"M\": np.array([\n                    [0, 0.015, 0.01],\n                    [0.015, 0, 0.012],\n                    [0.01, 0.012, 0]\n                ])\n            },\n            \"intervention\": {\n                \"s\": np.array([0.005, 0.005, 0.005]),\n                \"mu_sr\": 5e-7, \"mu_rs\": 1e-6,\n                \"M\": 0.4 * np.array([\n                    [0, 0.015, 0.01],\n                    [0.015, 0, 0.012],\n                    [0.01, 0.012, 0]\n                ])\n            }\n        },\n        # Test case 4\n        {\n            \"baseline\": {\n                \"s\": np.array([0.08, -0.02, 0.00]),\n                \"mu_sr\": 1e-12, \"mu_rs\": 1e-6,\n                \"M\": np.array([\n                    [0, 0.02, 0.005],\n                    [0.02, 0, 0.003],\n                    [0.005, 0.003, 0]\n                ])\n            },\n            \"intervention\": {\n                \"s\": np.array([0.01, -0.02, 0.00]),\n                \"mu_sr\": 1e-12, \"mu_rs\": 1e-6,\n                \"M\": np.array([\n                    [0, 0.005, 0.002],\n                    [0.005, 0, 0.003],\n                    [0.002, 0.003, 0]\n                ])\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta = calculate_delta(case[\"baseline\"], case[\"intervention\"])\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.8f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}