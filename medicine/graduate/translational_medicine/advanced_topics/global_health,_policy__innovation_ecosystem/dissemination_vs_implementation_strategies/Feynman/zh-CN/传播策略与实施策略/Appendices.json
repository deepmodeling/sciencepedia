{
    "hands_on_practices": [
        {
            "introduction": "在转化医学中，将理论转化为实践需要严谨的定量技能。一个基本功就是精确地衡量干预措施的成效。例如，“采纳”（Adoption）和“渗透”（Penetration）这两个术语虽常被混用，但在传播与实施科学（D&I Science）中却有明确区分，前者衡量服务提供者的行为，后者衡量患者的覆盖情况。本练习  将挑战你处理来自多个医疗中心的真实数据，精确计算这两个关键指标，这要求你运用集合论原理来处理数据重叠的复杂情况。",
            "id": "5010830",
            "problem": "一个区域性综合医疗服务网络在推广的第二季度，于三家医院实施了一个循证的“过渡期心力衰竭护理包”(Transitional Heart Failure Care Bundle)项目。其推广与实施（D&I）计划明确区分了提供者层面的采纳与患者层面的渗透。为进行此项评估，我们采用以下源自实施成果框架的基本定义：采纳是指在评估期间至少使用过一次该干预措施的合格提供者所占的比例；渗透是指在评估期间实际接受了该干预措施的合格患者所占的比例。提供者层面的合格标准要求完成培训，并拥有一个符合预定标准的心力衰竭活跃患者群；患者层面的合格标准要求患者为心力衰竭出院回家、无禁忌症且风险评分高于某一阈值。\n\n标记为 $A$、$B$ 和 $C$ 的三家医院提供了第二季度的数据计数。由于提供者可能在多家医院工作，患者也可能被转院，因此必须使用针对多家医院的容斥原理来移除重复计数。以下所有计数均指每家医院指定集合中的独立个体数量。\n\n提供者合格计数：\n- 医院 $A$：$|E_{A}| = 40$\n- 医院 $B$：$|E_{B}| = 35$\n- 医院 $C$：$|E_{C}| = 25$\n- 两两重叠部分：$|E_{A} \\cap E_{B}| = 10$，$|E_{B} \\cap E_{C}| = 5$，$|E_{A} \\cap E_{C}| = 2$\n- 三重重叠部分：$|E_{A} \\cap E_{B} \\cap E_{C}| = 1$\n\n在合格提供者中，开始使用干预措施的计数（第二季度在指定医院至少使用一次）：\n- $|I_{A}| = 22$，$|I_{B}| = 18$，$|I_{C}| = 15$\n- 开始使用者的两两交集：$|I_{A} \\cap I_{B}| = 8$，$|I_{B} \\cap I_{C}| = 4$，$|I_{A} \\cap I_{C}| = 1$\n- 开始使用者的三重交集：$|I_{A} \\cap I_{B} \\cap I_{C}| = 1$\n\n患者合格计数：\n- 医院 $A$：$|P_{A}| = 520$\n- 医院 $B$：$|P_{B}| = 430$\n- 医院 $C$：$|P_{C}| = 280$\n- 两两重叠部分：$|P_{A} \\cap P_{B}| = 60$，$|P_{B} \\cap P_{C}| = 45$，$|P_{A} \\cap P_{C}| = 25$\n- 三重重叠部分：$|P_{A} \\cap P_{B} \\cap P_{C}| = 12$\n\n在合格患者中，接受干预的计数（第二季度在指定医院接受了护理包）：\n- $|R_{A}| = 310$，$|R_{B}| = 250$，$|R_{C}| = 160$\n- 接受者的两两交集：$|R_{A} \\cap R_{B}| = 40$，$|R_{B} \\cap R_{C}| = 30$，$|R_{A} \\cap R_{C}| = 20$\n- 接受者的三重交集：$|R_{A} \\cap R_{B} \\cap R_{C}| = 10$\n\n假设根据第二季度的定义，所有开始使用者均为合格提供者，所有接受者均为合格患者。请计算系统层面的采纳率和渗透率，以小数比例表示，其分子和分母分别为各医院相关数据的并集。使用容斥原理获取独立计数。将采纳率和渗透率均表示为小数，保留四位有效数字，不加百分号或任何物理单位。",
            "solution": "所述问题是有效的。它在实施科学领域有科学依据，提出了一个基于集合论且定义明确的数学任务，并提供了所有必要的数据，数据之间没有内部矛盾。所有数据都是一致的；例如，任何集合交集的基数都不会大于该交集中任何单个集合的基数。问题中提供了采纳和渗透的定义，这些定义在相关文献中是标准的。任务是使用所提供的数据和容斥原理，计算系统层面的采纳率和渗透率这两个指标。\n\n系统层面指标的定义如下：\n采纳率是指在整个系统中，开始使用干预措施的独立合格提供者所占的比例。\n$$ \\text{Adoption} = \\frac{|\\text{Total unique initiators}|}{|\\text{Total unique eligible providers}|} $$\n渗透率是指在整个系统中，接受了干预措施的独立合格患者所占的比例。\n$$ \\text{Penetration} = \\frac{|\\text{Total unique recipients}|}{|\\text{Total unique eligible patients}|} $$\n\n要计算每个类别（合格提供者、开始使用者、合格患者、接受者）中的独立个体总数，我们必须计算对应于三家医院（表示为 $A$、$B$ 和 $C$）的集合的并集的基数。三个集合 $S_A$、$S_B$ 和 $S_C$ 的容斥原理表述如下：\n$$ |S_A \\cup S_B \\cup S_C| = |S_A| + |S_B| + |S_C| - (|S_A \\cap S_B| + |S_B \\cap S_C| + |S_A \\cap S_C|) + |S_A \\cap S_B \\cap S_C| $$\n\n我们将把这个原理应用于四个组中的每一个。\n\n首先，我们计算独立合格提供者的总数，记为 $|E_{\\text{total}}|$。所涉及的集合是 $E_A$、$E_B$ 和 $E_C$。\n已知数据如下：\n$|E_{A}| = 40$\n$|E_{B}| = 35$\n$|E_{C}| = 25$\n$|E_{A} \\cap E_{B}| = 10$\n$|E_{B} \\cap E_{C}| = 5$\n$|E_{A} \\cap E_{C}| = 2$\n$|E_{A} \\cap E_{B} \\cap E_{C}| = 1$\n\n应用容斥原理：\n$$ |E_{\\text{total}}| = |E_A \\cup E_B \\cup E_C| = |E_A| + |E_B| + |E_C| - (|E_A \\cap E_B| + |E_B \\cap E_C| + |E_A \\cap E_C|) + |E_A \\cap E_B \\cap E_C| $$\n$$ |E_{\\text{total}}| = 40 + 35 + 25 - (10 + 5 + 2) + 1 $$\n$$ |E_{\\text{total}}| = 100 - 17 + 1 = 84 $$\n所以，系统中有 $84$ 名独立的合格提供者。\n\n其次，我们计算开始使用干预措施的独立提供者总数，记为 $|I_{\\text{total}}|$。所涉及的集合是 $I_A$、$I_B$ 和 $I_C$。\n已知数据如下：\n$|I_{A}| = 22$\n$|I_{B}| = 18$\n$|I_{C}| = 15$\n$|I_{A} \\cap I_{B}| = 8$\n$|I_{B} \\cap I_{C}| = 4$\n$|I_{A} \\cap I_{C}| = 1$\n$|I_{A} \\cap I_{B} \\cap I_{C}| = 1$\n\n应用容斥原理：\n$$ |I_{\\text{total}}| = |I_A \\cup I_B \\cup I_C| = |I_A| + |I_B| + |I_C| - (|I_A \\cap I_B| + |I_B \\cap I_C| + |I_A \\cap I_C|) + |I_A \\cap I_B \\cap I_C| $$\n$$ |I_{\\text{total}}| = 22 + 18 + 15 - (8 + 4 + 1) + 1 $$\n$$ |I_{\\text{total}}| = 55 - 13 + 1 = 43 $$\n所以，有 $43$ 名独立的提供者开始使用该干预措施。\n\n系统层面的采纳率是 $|I_{\\text{total}}|$ 与 $|E_{\\text{total}}|$ 的比值：\n$$ \\text{Adoption} = \\frac{|I_{\\text{total}}|}{|E_{\\text{total}}|} = \\frac{43}{84} \\approx 0.51190476... $$\n保留四位有效数字，采纳率为 $0.5119$。\n\n第三，我们计算独立合格患者的总数，记为 $|P_{\\text{total}}|$。所涉及的集合是 $P_A$、$P_B$ 和 $P_C$。\n已知数据如下：\n$|P_{A}| = 520$\n$|P_{B}| = 430$\n$|P_{C}| = 280$\n$|P_{A} \\cap P_{B}| = 60$\n$|P_{B} \\cap P_{C}| = 45$\n$|P_{A} \\cap P_{C}| = 25$\n$|P_{A} \\cap P_{B} \\cap P_{C}| = 12$\n\n应用容斥原理：\n$$ |P_{\\text{total}}| = |P_A \\cup P_B \\cup P_C| = |P_A| + |P_B| + |P_C| - (|P_A \\cap P_B| + |P_B \\cap P_C| + |P_A \\cap P_C|) + |P_A \\cap P_B \\cap P_C| $$\n$$ |P_{\\text{total}}| = 520 + 430 + 280 - (60 + 45 + 25) + 12 $$\n$$ |P_{\\text{total}}| = 1230 - 130 + 12 = 1112 $$\n所以，系统中有 $1112$ 名独立的合格患者。\n\n第四，我们计算接受了干预措施的独立患者总数，记为 $|R_{\\text{total}}|$。所涉及的集合是 $R_A$、$R_B$ 和 $R_C$。\n已知数据如下：\n$|R_{A}| = 310$\n$|R_{B}| = 250$\n$|R_{C}| = 160$\n$|R_{A} \\cap R_{B}| = 40$\n$|R_{B} \\cap R_{C}| = 30$\n$|R_{A} \\cap R_{C}| = 20$\n$|R_{A} \\cap R_{B} \\cap R_{C}| = 10$\n\n应用容斥原理：\n$$ |R_{\\text{total}}| = |R_A \\cup R_B \\cup R_C| = |R_A| + |R_B| + |R_C| - (|R_A \\cap R_B| + |R_B \\cap R_C| + |R_A \\cap R_C|) + |R_A \\cap R_B \\cap R_C| $$\n$$ |R_{\\text{total}}| = 310 + 250 + 160 - (40 + 30 + 20) + 10 $$\n$$ |R_{\\text{total}}| = 720 - 90 + 10 = 640 $$\n所以，有 $640$ 名独立的患者接受了该干预措施。\n\n系统层面的渗透率是 $|R_{\\text{total}}|$ 与 $|P_{\\text{total}}|$ 的比值：\n$$ \\text{Penetration} = \\frac{|R_{\\text{total}}|}{|P_{\\text{total}}|} = \\frac{640}{1112} \\approx 0.57553956... $$\n保留四位有效数字，渗透率为 $0.5755$。\n\n最终结果是采纳率为 $0.5119$，渗透率为 $0.5755$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.5119  0.5755 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了如何衡量结果之后，下一步是主动设计有效的策略。信息的传播并非随机发生，而是通过复杂的社会和专业网络进行的。本练习  让你扮演策略师的角色，利用网络分析方法来识别最具影响力的“种子”临床医生，从而最大化创新实践在早期阶段的传播范围。",
            "id": "5010780",
            "problem": "您正在为转化医学设计一个数学上严谨的决策支持程序，该程序用于区分传播策略（最大化信息的早期扩散）和实施策略（确保持续采纳）。在传播方面，一个来自网络流行病学和创新扩散理论（DoI）的普遍且经过充分检验的事实是，早期覆盖范围由初始种子集的直接邻域驱动。在这个问题中，临床医生被建模为网络中的节点，该网络由一个邻接矩阵表示，而早期覆盖范围则通过一次通信步骤后所覆盖的节点数量来近似。\n\n给定一个代表5名临床医生的邻接矩阵 $A \\in \\{0,1\\}^{5 \\times 5}$，节点 $i$ 的度中心性对于无向网络（其中 $A$ 是对称的）定义为 $C_D(i) = \\sum_{j=1}^{5} A_{ij}$，或者对于有向网络（行和）定义为出度中心性。对于一个大小为 $|S|=k$ 的种子集 $S \\subseteq \\{1,2,3,4,5\\}$，定义单步早期覆盖函数为\n$$\nR(S) = \\left| S \\cup \\left\\{ j \\in \\{1,\\dots,5\\} \\ \\big| \\ \\exists \\, i \\in S \\text{ such that } A_{ij} = 1 \\right\\} \\right|.\n$$\n目标是选择大小为 $k$ 的种子集 $S$ 以最大化 $R(S)$。如果多个种子集达到相同的最大 $R(S)$ 值，则选择字典序最小的已排序索引列表（使用基于1的索引）。\n\n您的任务是编写一个完整的、可运行的程序，为下面的每个测试用例计算：\n- 度中心性列表 $\\left[C_D(1),C_D(2),C_D(3),C_D(4),C_D(5)\\right]$，作为整数。\n- 在平局决胜规则下，最大化 $R(S)$ 的大小为 $k$ 的种子集 $S$（报告为基于1的已排序索引列表）。\n- 最大早期覆盖 $R(S)$，作为整数。\n\n不涉及物理单位；不涉及角度；不应使用百分比。所有答案必须是整数或整数列表。您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。此顶层列表的每个元素对应一个测试用例，并且本身必须是包含三个元素的列表，顺序为：$[\\text{seed\\_indices}, \\text{early\\_reach}, \\text{degree\\_centralities}]$。例如，单个测试用例的输出应如下所示：$[[1,4],5,[2,2,3,2,1]]$。\n\n测试套件（每个测试用例提供 $(A,k,\\text{directed})$）：\n\n- 测试用例 1（无向，中等连通性, $k=2$）:\n  - 第1行: $[0,1,1,0,0]$\n  - 第2行: $[1,0,1,0,0]$\n  - 第3行: $[1,1,0,1,0]$\n  - 第4行: $[0,0,1,0,1]$\n  - 第5行: $[0,0,0,1,0]$\n  - $k=2$, directed $=\\text{False}$\n\n- 测试用例 2（5个节点上的无向完全图, $k=1$）:\n  - 第1行: $[0,1,1,1,1]$\n  - 第2行: $[1,0,1,1,1]$\n  - 第3行: $[1,1,0,1,1]$\n  - 第4行: $[1,1,1,0,1]$\n  - 第5行: $[1,1,1,1,0]$\n  - $k=1$, directed $=\\text{False}$\n\n- 测试用例 3（以节点3为中心的无向星形图, $k=1$）:\n  - 第1行: $[0,0,1,0,0]$\n  - 第2行: $[0,0,1,0,0]$\n  - 第3行: $[1,1,0,1,1]$\n  - 第4行: $[0,0,1,0,0]$\n  - 第5行: $[0,0,1,0,0]$\n  - $k=1$, directed $=\\text{False}$\n\n- 测试用例 4（有向，异构出度, $k=2$）:\n  - 第1行: $[0,1,1,0,0]$\n  - 第2行: $[0,0,1,0,0]$\n  - 第3行: $[0,0,0,1,0]$\n  - 第4行: $[0,0,0,0,0]$\n  - 第5行: $[1,1,1,0,0]$\n  - $k=2$, directed $=\\text{True}$\n\n- 测试用例 5（无向，含一个孤立节点，链状结构, $k=2$）:\n  - 第1行: $[0,1,0,0,0]$\n  - 第2行: $[1,0,1,0,0]$\n  - 第3行: $[0,1,0,1,0]$\n  - 第4行: $[0,0,1,0,0]$\n  - 第5行: $[0,0,0,0,0]$\n  - $k=2$, directed $=\\text{False}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个测试用例的结果格式为 $[\\text{seed\\_indices}, \\text{early\\_reach}, \\text{degree\\_centralities}]$。",
            "solution": "在尝试解决问题之前，需对问题进行验证。\n\n### 第一步：提取已知条件\n- **模型**：临床医生是规模为 $N=5$ 的网络中的节点。\n- **表示法**：一个邻接矩阵 $A \\in \\{0,1\\}^{5 \\times 5}$。\n- **度中心性**：对于节点 $i$，度中心性定义为 $C_D(i) = \\sum_{j=1}^{5} A_{ij}$。对于有向网络，这是出度。对于无向网络，矩阵 $A$ 是对称的，这就是标准的度。\n- **种子集**：节点的一个子集 $S \\subseteq \\{1,2,3,4,5\\}$，其大小固定为 $|S|=k$。\n- **早期覆盖函数**：种子集 $S$ 的单步早期覆盖定义为 $R(S) = \\left| S \\cup \\left\\{ j \\in \\{1,\\dots,5\\} \\ \\big| \\ \\exists \\, i \\in S \\text{ such that } A_{ij} = 1 \\right\\} \\right|$。这是种子集本身及其所有节点的唯一邻居集合的并集中的节点数量。\n- **目标**：找到大小为 $k$ 的种子集 $S$，使得早期覆盖函数 $R(S)$ 最大化。\n- **平局决胜规则**：如果多个种子集产生了相同的最大 $R(S)$ 值，则选择字典序最小的基于1的已排序索引列表。\n- **输出格式**：对于每个测试用例，输出必须是一个包含三个元素的列表：$[\\text{seed\\_indices}, \\text{early\\_reach}, \\text{degree\\_centralities}]$。`seed_indices` 是一个基于1的已排序节点索引列表。`early_reach` 是 $R(S)$ 的最大值。`degree_centralities` 是节点1到5的度中心性列表。\n- **测试用例**：提供了五个测试用例，每个都指定了一个邻接矩阵 $A$、一个种子集大小 $k$ 和一个布尔标志 `directed`，用以指示图是无向还是有向。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题在网络理论（数学和计算机科学的一个分支）中有很好的基础。邻接矩阵、度中心性和邻域覆盖等概念都是标准定义。将其应用于社交网络（临床医生）中的信息传播是流行病学和科学社会学（例如创新扩散理论）中的一个经典模型。该问题在科学上是合理的。\n- **适定性**：该问题要求从一个有限的可能集合中找到一个最优子集。节点数量固定为5，种子集大小 $k$ 已给出。可能的种子集数量是有限的，由二项式系数 $\\binom{5}{k}$ 给出。这保证了覆盖函数 $R(S)$ 的最大值存在。包含字典序平局决胜规则确保了解的唯一性。因此，该问题是适定的。\n- **目标**：问题使用了精确的数学定义和客观标准来陈述。所有术语都有明确定义，目标是明确无误的。\n- **其他缺陷**：问题陈述是完整的，为每个测试用例提供了所有必要的数据。数据是一致的（例如，无向图的矩阵是对称的）。问题的规模（5个节点）很小，但可以作为测试所述算法的完全有效的实例。它并非微不足道，因为它需要系统的搜索和比较。该问题是可验证的，并且不包含任何逻辑矛盾或事实错误。\n\n### 第三步：结论与行动\n问题有效。将提供一个解决方案。\n\n### 解决方案推导\n问题的核心是找到一个大小为 $k$ 的种子集 $S$，以最大化覆盖函数 $R(S)$。鉴于网络规模较小（$N=5$），我们可以通过系统地评估所有可能的候选种子集来解决这个优化问题。\n\n总体算法如下：\n1.  对于每个测试用例，解析邻接矩阵 $A$、种子集大小 $k$ 和有向性。\n2.  计算每个节点 $i \\in \\{1, \\dots, 5\\}$ 的度中心性。根据定义，这是 $A$ 的第 $i$ 行的和：$C_D(i) = \\sum_{j=1}^{5} A_{ij}$。对所有节点执行此操作以形成度中心性列表。\n3.  生成大小为 $k$ 的所有可能的种子集 $S$。一个种子集是从5个可用节点中选出的 $k$ 个节点的组合。这样的组合数量为 $\\binom{5}{k}$。\n4.  对于每个候选种子集 $S$：\n    a.  识别 $S$ 中节点的所有邻居的集合。这是集合 $N(S) = \\{j \\mid \\exists i \\in S \\text{ such that } A_{ij}=1\\}$。\n    b.  所有被覆盖的节点的集合是种子集本身及其邻居的并集：$S \\cup N(S)$。\n    c.  计算早期覆盖 $R(S)$ 为该并集的基数：$R(S) = |S \\cup N(S)|$。\n5.  找到最优种子集。这包括遍历所有生成的种子集，并跟踪产生最高覆盖的集合。让当前最优集合为 $S_{best}$，其覆盖为 $R_{max}$。对于每个新集合 $S_{new}$，其覆盖为 $R_{new}$：\n    a.  如果 $R_{new} > R_{max}$，则更新 $R_{max} = R_{new}$ 和 $S_{best} = S_{new}$。\n    b.  如果 $R_{new} = R_{max}$，我们应用平局决胜规则。规则规定我们必须选择字典序最小的集合。通过按字典序生成节点索引的组合（例如，在Python中使用 `itertools.combinations`，它会产生诸如 $(1,2), (1,3), \\dots$ 的元组），我们遇到的第一个达到最大覆盖的集合将自动满足平局决胜规则。因此，我们只需要在找到一个*严格更大*的覆盖时才更新我们的最优集合。\n6.  一旦评估了所有组合，将得到的 $S_{best}$（转换为基于1的索引）、$R_{max}$ 和度中心性列表按要求格式化输出。\n\n让我们以测试用例1为例来说明这个过程。\n- **已知**：$k=2$，`directed=False`，以及\n$$ A = \\begin{pmatrix} 0  1  1  0  0 \\\\ 1  0  1  0  0 \\\\ 1  1  0  1  0 \\\\ 0  0  1  0  1 \\\\ 0  0  0  1  0 \\end{pmatrix} $$\n- **度中心性**：我们对 $A$ 的每一行求和。\n$C_D(1) = 2$, $C_D(2) = 2$, $C_D(3) = 3$, $C_D(4) = 2$, $C_D(5) = 1$。列表为 $[2, 2, 3, 2, 1]$。\n- **候选集**：我们需要检查所有 $\\binom{5}{2}=10$ 种2个节点的组合。我们使用基于0的索引 $\\{0,1,2,3,4\\}$ 进行计算。\n    - $S=\\{0,1\\}$ (即 $\\{1,2\\}$)：覆盖的节点为 $\\{0,1\\} \\cup N(\\{0\\}) \\cup N(\\{1\\}) = \\{0,1\\} \\cup \\{1,2\\} \\cup \\{0,2\\} = \\{0,1,2\\}$。$R(S)=3$。\n    - $S=\\{0,2\\}$ (即 $\\{1,3\\}$)：覆盖的节点为 $\\{0,2\\} \\cup N(\\{0\\}) \\cup N(\\{2\\}) = \\{0,2\\} \\cup \\{1,2\\} \\cup \\{0,1,3\\} = \\{0,1,2,3\\}$。$R(S)=4$。\n    - $S=\\{0,3\\}$ (即 $\\{1,4\\}$)：覆盖的节点为 $\\{0,3\\} \\cup N(\\{0\\}) \\cup N(\\{3\\}) = \\{0,3\\} \\cup \\{1,2\\} \\cup \\{2,4\\} = \\{0,1,2,3,4\\}$。$R(S)=5$。\n    - $S=\\{0,4\\}$ (即 $\\{1,5\\}$)：覆盖的节点为 $\\{0,4\\} \\cup N(\\{0\\}) \\cup N(\\{4\\}) = \\{0,4\\} \\cup \\{1,2\\} \\cup \\{3\\} = \\{0,1,2,3,4\\}$。$R(S)=5$。\n    - ……以此类推。\n- **最大化与平局决胜**：\n    - 第一个达到覆盖为5的集合是 $S=\\{0,3\\}$（或在基于1的索引中为 $\\{1,4\\}$）。这成为我们当前的最佳集合。\n    - 接着我们评估 $S=\\{0,4\\}$，发现其覆盖也为5。由于平局决胜规则要求选择字典序最小的集合，并且我们是按字典序评估集合的，所以我们不会用 $\\{0,4\\}$ 替换 $\\{0,3\\}$。\n    - 继续这个过程，我们发现最大覆盖确实是5。达到这个值的集合有 $\\{1,4\\}, \\{1,5\\}, \\{2,4\\}, \\{2,5\\}, \\{3,4\\}, \\{3,5\\}$。\n    - 这些集合中字典序最小的是 $\\{1,4\\}$。\n- **测试用例1的最终结果**：最优种子集是 $[1,4]$，最大覆盖是 $5$，度中心性是 $[2,2,3,2,1]$。格式化为 `[[1,4],5,[2,2,3,2,1]]`。\n\n将同样的穷举搜索方法应用于所有其他测试用例，以产生完整的解决方案。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the seed set optimization problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ({\"A_rows\": [[0, 1, 1, 0, 0], [1, 0, 1, 0, 0], [1, 1, 0, 1, 0], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0]],\n          \"k\": 2, \"directed\": False}),\n        # Test case 2\n        ({\"A_rows\": [[0, 1, 1, 1, 1], [1, 0, 1, 1, 1], [1, 1, 0, 1, 1], [1, 1, 1, 0, 1], [1, 1, 1, 1, 0]],\n          \"k\": 1, \"directed\": False}),\n        # Test case 3\n        ({\"A_rows\": [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 0, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]],\n          \"k\": 1, \"directed\": False}),\n        # Test case 4\n        ({\"A_rows\": [[0, 1, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]],\n          \"k\": 2, \"directed\": True}),\n        # Test case 5\n        ({\"A_rows\": [[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]],\n          \"k\": 2, \"directed\": False})\n    ]\n\n    results = []\n    for case in test_cases:\n        A = np.array(case[\"A_rows\"])\n        k = case[\"k\"]\n        # The problem defines degree centrality as row sums for both directed and undirected cases.\n        # For undirected, A is symmetric, so row sum equals column sum.\n        degree_centralities = A.sum(axis=1).astype(int).tolist()\n\n        nodes = range(5)\n        best_seed_set = None\n        max_reach = -1\n\n        # Generate all combinations of node indices of size k.\n        # itertools.combinations produces them in lexicographical order.\n        seed_set_candidates = combinations(nodes, k)\n\n        for seed_set_tuple in seed_set_candidates:\n            seed_set = set(seed_set_tuple)\n            \n            # Start with the seed set itself\n            reached_nodes = set(seed_set)\n            \n            # Add all neighbors of nodes in the seed set\n            for seed_node in seed_set:\n                neighbors = np.where(A[seed_node, :] == 1)[0]\n                reached_nodes.update(neighbors)\n            \n            current_reach = len(reached_nodes)\n\n            # The first set that achieves a max reach is the lexicographically smallest.\n            # So, we only update if we find a strictly greater reach.\n            if current_reach > max_reach:\n                max_reach = current_reach\n                best_seed_set = list(seed_set_tuple)\n\n        # Convert 0-based indices to 1-based for the final output\n        # The seed set is already sorted by itertools.combinations\n        best_seed_set_1based = [x + 1 for x in best_seed_set]\n\n        results.append([best_seed_set_1based, max_reach, degree_centralities])\n\n    def format_case_result(res):\n        \"\"\"Formats a single test case result into the required string format without spaces.\"\"\"\n        seed_indices, early_reach, centralities = res\n        s_idx_str = f\"[{','.join(map(str, seed_indices))}]\"\n        r_str = str(early_reach)\n        d_cen_str = f\"[{','.join(map(str, centralities))}]\"\n        return f\"[{s_idx_str},{r_str},{d_cen_str}]\"\n\n    final_output_strings = [format_case_result(res) for res in results]\n    print(f\"[{','.join(final_output_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将焦点从信息传播转向更具挑战性的实践变革——即实施。现实世界中的一个核心制约是资源有限，你无法执行所有有益的实施策略。本练习  将这一挑战构建为一个经典的资源分配问题，要求你在预算限制下，选择一组能产生最大总体效应的实施策略组合。",
            "id": "5010866",
            "problem": "您正在设计一个转化医学中的实施策略组合，目标是将循证实践整合到常规临床护理中。为清晰起见，需要区分传播策略（侧重于信息扩散）和实施策略（侧重于改变临床系统以将证据采纳到实践中）。理性资源分配的基础是：各个独立、不重叠策略的预期效果可以相加，成本呈线性相加。假设有 $n$ 个候选策略，索引为 $i \\in \\{0,1,\\dots,n-1\\}$，每个策略都有一个预估效果 $e_i$（单位：人，解释为达到目标结果的预期新增患者数）和一个成本 $c_i$（单位：美元(USD)）。每个策略由一个类型指示符 $d_i \\in \\{0,1\\}$ 标记，其中 $d_i=1$ 表示实施策略，$d_i=0$ 表示传播策略。您必须只选择实施策略。定义二元决策变量 $x_i \\in \\{0,1\\}$，表示策略 $i$ 是否被选中。预算约束为 $B=\\$500,000$。\n\n在效果可加性和策略独立性的基本假设下，您必须选择一个实施策略的子集，以在预算约束下最大化预期总效果。形式上，该优化问题为：\n$$\n\\max_{x_i \\in \\{0,1\\}} \\;\\; \\sum_{i=0}^{n-1} e_i x_i\n$$\n约束条件为\n$$\n\\sum_{i=0}^{n-1} c_i x_i \\le B,\\quad x_i \\le d_i \\;\\; \\text{for all } i.\n$$\n必须应用打破平局规则以确保解的唯一性和可复现性：在所有达到相同最大目标值的解中，选择总成本最小的那个；如果仍然存在平局，则选择其选定索引的排序列表字典序最小的那个解。\n\n计算要求：将成本 $c_i$ 和预算 $B$ 视为 $\\$1,000$ 的整数倍。在内部，通过除以 $1,000$ 来缩放成本和预算，以便容量以 $\\$1,000$ 为单位进行度量。所有效果 $e_i$ 都是整数，且预期总效果必须作为整数个的人数返回。\n\n实现一个程序，对于每个给定的测试用例，根据上述约束和打破平局规则，返回唯一的实施策略最优选择。每个测试用例由以下内容指定：\n- 固定预算 $B=\\$500,000$。\n- $c_i$ 的列表（单位：美元），每个都是 $\\$1,000$ 的倍数。\n- $e_i$ 的列表（单位：人，整数）。\n- $d_i \\in \\{0,1\\}$ 的列表，指示策略类型（如果为 $1$ 则是实施策略，如果为 $0$ 则是传播策略）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个测试用例的结果是一个双元素列表 $[\\text{sorted\\_indices}, \\text{total\\_effect}]$。第一个元素 $\\text{sorted\\_indices}$ 是选定策略索引的排序列表，第二个元素 $\\text{total\\_effect}$ 是整数和 $\\sum_i e_i x_i$。例如，三个用例的有效单行输出应如下所示：`[[[0,1],350],[[2],220],[[1,3,4],780]]`。\n\n使用以下测试套件。在所有情况下，$B=\\$500,000$。\n\n测试用例 1 (混合类型的正常路径):\n- $c = [\\$120,000,\\; \\$80,000,\\; \\$60,000,\\; \\$200,000,\\; \\$150,000,\\; \\$90,000,\\; \\$110,000,\\; \\$140,000]$\n- $e = [240,\\; 150,\\; 90,\\; 430,\\; 300,\\; 200,\\; 220,\\; 260]$\n- $d = [1,\\; 1,\\; 0,\\; 1,\\; 0,\\; 1,\\; 1,\\; 1]$\n\n测试用例 2 (总实施成本等于预算的边界情况):\n- $c = [\\$125,000,\\; \\$75,000,\\; \\$150,000,\\; \\$150,000]$\n- $e = [200,\\; 120,\\; 190,\\; 230]$\n- $d = [1,\\; 1,\\; 1,\\; 1]$\n\n测试用例 3 (权衡：一个极高成本高效果选项与几个中等选项):\n- $c = [\\$500,000,\\; \\$120,000,\\; \\$120,000,\\; \\$120,000,\\; \\$120,000,\\; \\$50,000]$\n- $e = [900,\\; 260,\\; 255,\\; 250,\\; 200,\\; 80]$\n- $d = [1,\\; 1,\\; 1,\\; 1,\\; 1,\\; 1]$\n\n测试用例 4 (包含零成本实施策略的边缘情况):\n- $c = [\\$0,\\; \\$100,000,\\; \\$200,000,\\; \\$180,000,\\; \\$50,000]$\n- $e = [40,\\; 300,\\; 450,\\; 390,\\; 120]$\n- $d = [1,\\; 1,\\; 1,\\; 1,\\; 1]$\n\n测试用例 5 (用于检验字典序规则的平局情况):\n- $c = [\\$250,000,\\; \\$250,000,\\; \\$200,000,\\; \\$200,000,\\; \\$100,000,\\; \\$50,000]$\n- $e = [500,\\; 500,\\; 400,\\; 400,\\; 200,\\; 50]$\n- $d = [1,\\; 1,\\; 1,\\; 1,\\; 1,\\; 1]$\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为由方括号括起来的逗号分隔列表，每个结果的格式为 $[\\text{sorted\\_indices}, \\text{total\\_effect}]$，顺序与上述指定相同。例如，最终输出应类似于 $[[[i\\_case1],E\\_case1],[[i\\_case2],E\\_case2],[[i\\_case3],E\\_case3],[[i\\_case4],E\\_case4],[[i\\_case5],E\\_case5]]$，其中占位符被实际整数替换，且不含额外的空白或文本。",
            "solution": "所呈现的问题是一个约束优化任务，在形式上等同于0/1背包问题，其背景设定在转化医学的资源分配中。我们被要求选择一个实施策略的子集，以在固定预算下最大化总预期效果（达到目标结果的患者数量），并采用特定的打破平局规则以确保解的唯一性。\n\n首先，我们必须验证问题陈述。\n\n**第1步：提取已知条件**\n- 策略数量：$n$。\n- 策略索引：$i \\in \\{0, 1, \\dots, n-1\\}$。\n- 策略效果：$e_i$（整数，人）。\n- 策略成本：$c_i$（美元，是 $\\$1,000$ 的倍数）。\n- 策略类型指示符：$d_i \\in \\{0, 1\\}$，其中 $d_i=1$ 表示实施策略。\n- 决策变量：$x_i \\in \\{0, 1\\}$，其中 $x_i=1$ 表示策略 $i$ 被选中。\n- 总预算：$B = \\$500,000$。\n- 优化问题：\n  $$\n  \\max_{x_i \\in \\{0,1\\}} \\;\\; \\sum_{i=0}^{n-1} e_i x_i\n  $$\n  约束条件：\n  $$\n  \\sum_{i=0}^{n-1} c_i x_i \\le B\n  $$\n  $$\n  x_i \\le d_i \\;\\; \\forall i \\in \\{0, 1, \\dots, n-1\\}\n  $$\n- 计算缩放：成本 $c_i$ 和预算 $B$ 将通过除以 $1,000$ 进行缩放。\n- 唯一性打破平局规则：\n  1.  最大化总效果 $\\sum e_i x_i$。\n  2.  在效果最大的解中，最小化总成本 $\\sum c_i x_i$。\n  3.  在仍然平局的解中，选择其选定策略索引的排序列表字典序最小的那个。\n- 测试用例：提供了五个不同的测试用例，包含 $c$、$e$ 和 $d$ 的列表。\n- 输出格式：单行逗号分隔的结果列表，每个结果是一个双元素列表，包含选定索引的排序列表和总效果：`[[sorted_indices], total_effect]`。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**：该问题是一个成熟的整数线性规划模型（0/1背包问题），应用于项目组合优化的现实场景。效果可加和成本线性的假设是此类模型中的标准简化。该问题在科学和数学上是合理的。\n- **良构性**：问题定义清晰，有目标函数、明确的约束条件，以及每个测试用例的完整数据集。三层打破平局规则确保了任何给定输入都存在唯一解，使问题成为良构问题。\n- **客观性**：问题以精确、形式化的数学语言陈述，没有主观性或歧义。\n\n**第3步：结论与行动**\n问题有效。这是一个良构的、有科学依据的优化任务。我们可以着手制定解决方案。\n\n**基于原则的解决方案设计**\n\n问题的核心是选择一个物品（实施策略）的子集，以在重量约束（预算）下最大化总价值（效果）。这就是0/1背包问题。由于增加了复杂的打破平局规则，标准的背包算法必须进行扩充。动态规划（DP）方法非常适合解决此问题。\n\n**1. 预处理**\n首先，我们筛选策略，只考虑实施策略，即那些 $d_i=1$ 的策略。我们还按要求缩放成本和预算。让可用实施策略的集合为 $S$，其中每个元素是一个元组 `(scaled_cost, effect, original_index)`。为了让我们的算法能正确处理字典序打破平局规则，至关重要的是我们按照它们的原始索引顺序 $i=0, 1, 2, \\dots$ 处理这些策略。假设有 $m$ 个这样的策略。缩放后的预算是 $B' = B / 1000 = 500$。\n\n**2. 动态规划公式**\n我们将使用一个二维DP表 $dp[k][w]$ 来找到最优解。状态 $dp[k][w]$ 将表示使用索引从 $k$ 到 $m-1$ 的策略子集，在最大预算为 $w$ 的情况下可获得的最佳结果。为了处理前两条打破平局规则（最大化效果，然后最小化成本），我们的DP表中的每个单元格将存储一个元组：$(\\text{效果}, \\text{成本})$。\n\n让实施策略集合的索引从 $k=0$ 到 $m-1$。DP表的维度将是 $(m+1) \\times (B' + 1)$。我们从 $k=m$ 开始向后填充此表，直到 $k=0$。\n\n基准情况是 $k=m$，对应于不使用任何策略。\n$$dp[m][w] = (0, 0) \\quad \\text{for all } w \\in \\{0, 1, \\dots, B'\\}$$\n\n对于递归步骤，我们计算 $dp[k][w]$，其中 $k \\in \\{m-1, \\dots, 0\\}$ 且 $w \\in \\{0, \\dots, B'\\}$。对于每个具有属性 $(c_k, e_k, i_k)$ 的策略 $k$，我们有两个选择：\n- **不包括策略 $k$**：解是使用策略 $k+1, \\dots, m-1$ 和预算 $w$ 可获得的最佳解。这由 $dp[k+1][w]$ 给出。\n- **包括策略 $k$**：仅当其成本 $c_k \\le w$ 时才可能。如果是，则产生的效果和成本是策略 $k$ 的贡献与剩余策略在剩余预算下的最佳解之和。即 $(e_k + dp[k+1][w-c_k].\\text{effect}, c_k + dp[k+1][w-c_k].\\text{cost})$。\n\n我们比较这两个选项。设 $S_1 = (e_1, c_1)$ 和 $S_2 = (e_2, c_2)$。如果 ($e_1 > e_2$) 或 ($e_1=e_2$ 且 $c_1  c_2$)，则 $S_1$ 优于 $S_2$。\n$$\ndp[k][w] = \\text{better_of}(\\text{solution_without_k}, \\text{solution_with_k})\n$$\n\n**3. 寻找最优结果**\n填充整个DP表后，最优解不一定是 $dp[0][B']$，因为最佳组合可能不会用尽全部预算。我们必须通过检查表第一行中所有可能的预算使用情况来找到全局最优解。我们搜索 $dp[0][w]$ 对于所有 $w \\in \\{0, \\dots, B'\\}$，根据我们的比较标准找到全局最优元组 $(E^*, C^*)$。\n\n**4. 为满足字典序规则进行重构**\n这是最关键的一步。在找到目标最优值 $(E^*, C^*)$ 后，我们必须重构出能达到此结果并满足字典序打破平局规则的具体策略集。\n\n我们从 $k=0$ 到 $m-1$ 遍历策略（即按原始索引升序）。在每一步 $k$，我们决定是否将策略 $k$ 包含在我们的最终解中。\n让我们当前的目标是 $(E_{rem}, C_{rem})$，剩余预算为 $w_{rem}$。初始时，这些值为 $(E^*, C^*, B')$。\n对于具有属性 $(c_k, e_k, i_k)$ 的策略 $k$：\n我们检查包含策略 $k$ 是否能导向我们的目标解。如果包含它，并结合其余项（$k+1, \\dots, m-1$）在剩余预算（$w_{rem}-c_k$）下的最优解，能得到我们表中跟踪的当前最优解，即 $dp[k][w_{rem}]$，则为真。\n\n形式上，我们检查是否 $w_{rem} \\ge c_k$，以及是否采纳项 $k$ 的解 $(e_k + dp[k+1][w_{rem}-c_k].\\text{effect}, c_k + dp[k+1][w_{rem}-c_k].\\text{cost})$ 与 $dp[k][w_{rem}]$ 相同。\n\n如果此条件成立，意味着存在一个包含策略 $k$ 的最优路径。因为我们是按原始索引的升序（$i_0  i_1  \\dots$）遍历策略，所以这种包含当前策略 $k$ 的贪心选择保证了我们正在构建字典序最小的索引集。在决定包含策略 $k$ 后，我们将其原始索引 $i_k$ 添加到结果集中，并更新我们的跟踪变量：\n- $w_{rem} \\leftarrow w_{rem} - c_k$\n- $E_{rem} \\leftarrow E_{rem} - e_k$\n- $C_{rem} \\leftarrow C_{rem} - c_k$\n\n如果条件不成立，我们必定没有包含策略 $k$，因此我们以不变的跟踪变量进入下一个策略 $k+1$。重复此过程直到所有策略都被考虑，从而产生唯一的最优索引集。总效果就是 $E^*$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"c\": [120000, 80000, 60000, 200000, 150000, 90000, 110000, 140000],\n            \"e\": [240, 150, 90, 430, 300, 200, 220, 260],\n            \"d\": [1, 1, 0, 1, 0, 1, 1, 1],\n        },\n        {\n            \"c\": [125000, 75000, 150000, 150000],\n            \"e\": [200, 120, 190, 230],\n            \"d\": [1, 1, 1, 1],\n        },\n        {\n            \"c\": [500000, 120000, 120000, 120000, 120000, 50000],\n            \"e\": [900, 260, 255, 250, 200, 80],\n            \"d\": [1, 1, 1, 1, 1, 1],\n        },\n        {\n            \"c\": [0, 100000, 200000, 180000, 50000],\n            \"e\": [40, 300, 450, 390, 120],\n            \"d\": [1, 1, 1, 1, 1],\n        },\n        {\n            \"c\": [250000, 250000, 200000, 200000, 100000, 50000],\n            \"e\": [500, 500, 400, 400, 200, 50],\n            \"d\": [1, 1, 1, 1, 1, 1],\n        }\n    ]\n\n    budget = 500000\n    results = []\n    \n    for case in test_cases:\n        result = _solve_knapsack(budget, case[\"c\"], case[\"e\"], case[\"d\"])\n        results.append(result)\n\n    # The final output is a string representation of the list of results\n    final_output = \"[\" + \",\".join(map(str, results)) + \"]\"\n    # Python's default str() for lists uses spaces, e.g., '[1, 2]'.\n    # The problem example implies no spaces. Let's remove them.\n    final_output = final_output.replace(\" \", \"\")\n    print(final_output)\n\ndef _solve_knapsack(budget, costs, effects, types):\n    \"\"\"\n    Solves the 0/1 knapsack problem with custom tie-breaking rules.\n    \n    This function implements a dynamic programming solution to find the subset\n    of implementation strategies that maximizes effect under a budget,\n    resolving ties by minimizing cost, and then by lexicographically smallest\n    index set.\n\n    Args:\n        budget (int): Total budget in USD.\n        costs (list[int]): Costs of all strategies.\n        effects (list[int]): Effects of all strategies.\n        types (list[int]): Type indicators (1 for implementation).\n\n    Returns:\n        list: A two-element list containing the sorted list of selected indices\n              and the total effect.\n    \"\"\"\n    \n    budget_scaled = budget // 1000\n    \n    # 1. Preprocessing: Filter for implementation strategies and scale costs.\n    # The items are implicitly sorted by their original index.\n    items = []\n    for i in range(len(costs)):\n        if types[i] == 1:\n            items.append({\n                \"cost\": costs[i] // 1000,\n                \"effect\": effects[i],\n                \"index\": i\n            })\n    \n    num_items = len(items)\n    # dp[k][w] stores (effect, cost) for items k...m-1 with budget w\n    dp = np.full((num_items + 1, budget_scaled + 1, 2), -1, dtype=int)\n    \n    # Base case: for k=num_items (no items left), effect and cost are 0.\n    dp[num_items, :, :] = 0\n\n    # 2. DP Table Construction\n    # Iterate backwards from the last item to the first.\n    for k in range(num_items - 1, -1, -1):\n        item_cost = items[k][\"cost\"]\n        item_effect = items[k][\"effect\"]\n        \n        for w in range(budget_scaled + 1):\n            # Option 1: Don't include item k.\n            sol_without = dp[k + 1, w]\n            \n            # Option 2: Include item k (if possible).\n            if w >= item_cost:\n                prev_sol = dp[k + 1, w - item_cost]\n                sol_with_effect = item_effect + prev_sol[0]\n                sol_with_cost = item_cost + prev_sol[1]\n                \n                # Tie-breaking logic: max effect, then min cost.\n                is_better = False\n                if sol_with_effect > sol_without[0]:\n                    is_better = True\n                elif sol_with_effect == sol_without[0] and sol_with_cost  sol_without[1]:\n                    is_better = True\n                \n                if is_better:\n                    dp[k, w] = [sol_with_effect, sol_with_cost]\n                else:\n                    dp[k, w] = sol_without\n            else:\n                # Cannot afford to include item k.\n                dp[k, w] = sol_without\n\n    # 3. Find Optimal Target Outcome\n    # The best solution may not use the full budget. Search across all budgets.\n    best_effect = -1\n    best_cost = -1\n    \n    for w in range(budget_scaled + 1):\n        current_effect, current_cost = dp[0, w]\n        if current_effect > best_effect:\n            best_effect = current_effect\n            best_cost = current_cost\n        elif current_effect == best_effect and current_cost  best_cost:\n            best_cost = current_cost\n    \n    # 4. Reconstruction\n    # Trace back to find the lexicographically smallest index set.\n    selected_indices = []\n    current_budget = budget_scaled\n    \n    for k in range(num_items):\n        item = items[k]\n        \n        # Check if taking the current item is part of an optimal path to the target.\n        # This decision prioritizes smaller indices, satisfying the third tie-breaker.\n        sol_without = dp[k + 1, current_budget]\n        \n        # Determine if taking the item is the choice made in the DP table for dp[k][current_budget]\n        took_item = False\n        if current_budget >= item['cost']:\n            sol_from_rest = dp[k+1, current_budget - item['cost']]\n            potential_effect = item['effect'] + sol_from_rest[0]\n            potential_cost = item['cost'] + sol_from_rest[1]\n            \n            # If the solution by taking the item is the one stored, it means we took it.\n            if dp[k, current_budget][0] == potential_effect and dp[k, current_budget][1] == potential_cost:\n                took_item = True\n        \n        if took_item:\n            selected_indices.append(item['index'])\n            current_budget -= item['cost']\n\n    return [selected_indices, best_effect if best_effect != -1 else 0]\n\nsolve()\n```"
        }
    ]
}