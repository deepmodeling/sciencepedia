{
    "hands_on_practices": [
        {
            "introduction": "要定量分析调节，我们必须首先掌握近轴光学的基本语言。本练习  要求您从屈光度 (vergence) 的第一性原理出发，推导关键临床指标“调节幅度”与眼睛近点之间的关系。通过将眼睛视为一个简化的光学系统，您将巩固对晶状体屈光力变化如何转化为聚焦范围变化的理解。",
            "id": "4688669",
            "problem": "一个正视眼在看远处时，其远点在光学无限远处，无需任何调节即可将远处的物体聚焦在视网膜上。调节通过睫状肌的收缩增加眼睛的光焦度，使晶状体变得更凸。在临床和生理光学中，光焦度以屈光度为单位进行测量，1屈光度定义为以米为单位的焦距的倒数。将眼睛视为一个单一的薄光学系统，其主平面与角膜顶点重合，并使用近轴光学中的视场度公式，设物方空间的空气折射率为 $n = 1$。\n\n从第一性原理（视场度叠加和正视眼的视网膜共轭条件）出发，正式定义以屈光度为单位的调节幅度作为一个定量度量，然后推导出一个远距屈光状态为正视且调节幅度等于 $3\\,\\mathrm{D}$ 的眼睛的近点物距（从角膜顶点测量）。\n\n假设调节滞后为零，并忽略景深和有限瞳孔大小的影响。\n\n将最终距离四舍五入至四位有效数字，并以厘米为单位表示。你的最终数值结果必须是一个实数。",
            "solution": "分析始于薄光学系统的基本近轴光学方程，该方程以视场度表示。视场度-屈光方程，也称为薄透镜方程的视场度形式，由下式给出：\n$$L' = L + P$$\n在此， $L$ 代表物方视场度， $P$ 是系统的光焦度， $L'$ 是像方视场度。视场度定义为介质的折射率与到参考平面（在此情况下为光学系统的主平面）的距离之比。对于位于空气中（折射率 $n=1$）、距离主平面为 $l$ 的物体，其物方视场度为 $L = \\frac{1}{l}$。类似地，对于位于折射率为 $n'$ 的介质中、距离为 $l'$ 的像，其像方视场度为 $L' = \\frac{n'}{l'}$。所有距离均以米（$\\mathrm{m}$）为单位测量，所有视场度和光焦度均以屈光度（$\\mathrm{D}$）为单位测量，其中 $1 \\, \\mathrm{D} = 1 \\, \\mathrm{m}^{-1}$。按照惯例，光学系统左侧的实物距离为负，右侧的实像距离为正。\n\n对于人眼，像必须聚焦在视网膜上。从主平面到视网膜的距离 $l'_{retina}$ 是固定的。玻璃体的折射率 $n'_{vit}$ 也是恒定的。因此，对于给定的眼睛，清晰视觉所需的像方视场度是一个恒定值：\n$$L'_{retina} = \\frac{n'_{vit}}{l'_{retina}} = K$$\n其中 $K$ 是一个代表眼球视场度需求的常数。因此，眼睛聚焦的基本条件是：\n$$K = L + P_{eye}$$\n其中 $P_{eye}$ 是眼睛的总光焦度，它可以通过调节而变化。\n\n首先，我们分析未调节（完全放松）的正视眼。正视眼是指无需任何调节努力即可将来自远处物体（在光学无限远处）的平行光聚焦在视网膜上的眼睛。\n远处物体的物距为 $l \\to -\\infty$。\n相应的物方视场度为 $L_{fp} = \\frac{1}{-\\infty} = 0 \\, \\mathrm{D}$。这定义了远点（$fp$）视场度。\n设 $P_{unacc}$ 是未调节眼睛的光焦度。聚焦条件变为：\n$$K = L_{fp} + P_{unacc} = 0 + P_{unacc}$$\n因此，对于正视眼，其未调节时的光焦度恰好等于所需的眼球视场度：$P_{unacc} = K$。\n\n接下来，我们分析完全调节的眼睛。当眼睛施加最大调节努力时，它聚焦在其近点（$np$）上。\n设近点距离主平面的物距为 $l_{np}$。\n近点的物方视场度为 $L_{np} = \\frac{1}{l_{np}}$。\n设 $P_{acc}$ 是完全调节眼睛的光焦度。近点的聚焦条件为：\n$$K = L_{np} + P_{acc}$$\n\n调节幅度，用 $A$ 表示，正式定义为眼睛的光焦度从未调节状态到完全调节状态的最大增量。\n$$A = P_{acc} - P_{unacc}$$\n我们现在可以将从聚焦条件中导出的表达式代入此定义。从近点条件，我们有 $P_{acc} = K - L_{np}$。从正视眼的远点条件，我们有 $P_{unacc} = K$。\n将这些代入 $A$ 的定义中：\n$$A = (K - L_{np}) - K = -L_{np}$$\n这是从第一性原理导出的调节幅度的正式定义：调节幅度等于近点物方视场度的负值。\n\n近点物*距*，我们记为 $d_{np}$，是按照惯例从角膜顶点（我们的主平面）到近点的正值距离。遵循符号惯例，物的位置为 $l_{np} = -d_{np}$。\n因此，近点视场度为 $L_{np} = \\frac{1}{l_{np}} = \\frac{1}{-d_{np}}$。\n将此代入我们对 $A$ 的定义中：\n$$A = -L_{np} = -\\left(\\frac{1}{-d_{np}}\\right) = \\frac{1}{d_{np}}$$\n这个结果表明，以屈光度为单位的调节幅度等于以米为单位测量的近点距离的倒数。\n\n问题要求计算一个调节幅度为 $A = 3 \\, \\mathrm{D}$ 的正视眼的近点物距。\n使用导出的关系式：\n$$A = \\frac{1}{d_{np}}$$\n我们求解近点距离 $d_{np}$：\n$$d_{np} = \\frac{1}{A}$$\n代入给定的 $A$ 值：\n$$d_{np} = \\frac{1}{3 \\, \\mathrm{D}} = \\frac{1}{3} \\, \\mathrm{m}$$\n问题要求将距离以厘米（$\\mathrm{cm}$）表示，并四舍五入到四位有效数字。我们进行单位换算：\n$$d_{np} = \\frac{1}{3} \\, \\mathrm{m} \\times \\frac{100 \\, \\mathrm{cm}}{1 \\, \\mathrm{m}} = \\frac{100}{3} \\, \\mathrm{cm}$$\n现在，我们进行除法和四舍五入：\n$$d_{np} = 33.3333... \\, \\mathrm{cm}$$\n四舍五入到四位有效数字，得到：\n$$d_{np} = 33.33 \\, \\mathrm{cm}$$",
            "answer": "$$\\boxed{33.33}$$"
        },
        {
            "introduction": "虽然简化模型很有用，但要更精确地描绘晶状体，就必须将其视为一个厚透镜。本练习  将指导您应用作为高等生理光学基石的厚透镜屈光力公式。通过计算晶状体表面曲率的特定变化所导致的屈光力改变，您将对调节性屈光力变化的结构力学基础有更深刻的认识。",
            "id": "4688647",
            "problem": "一个年轻的人眼晶状体被建模为一个均匀、旋转对称的厚透镜，其两侧都浸没在相同的各向同性介质中（房水和玻璃体），该介质的折射率均为 $n_{m}$。透镜材料具有均匀的折射率 $n_{\\ell}$。光从左向右传播。采用标准的近轴符号约定：如果曲率中心位于曲面右侧，则曲面曲率半径 $R$ 为正，否则为负；中心厚度 $t$ 沿光轴测量，且为正值。假设近轴近似成立。\n\n请仅从共轴系统的近轴高斯光学的基本原理（即，折射率分别为 $n_{1}$ 和 $n_{2}$ 的介质之间的球面界面处的折射，以及在均匀介质中的自由空间传播）出发，推导出一个由两个球面折射面构成的厚透镜的等效近轴光焦度的表达式，该透镜的中心厚度有限，且两侧的周围介质具有相同的折射率 $n_{m}$。然后，使用该表达式，计算当中心厚度被外部约束保持固定时，由于以下类似调节作用的曲率变化所引起的光焦度变化。\n\n周围介质的折射率为 $n_{m} = 1.336$，透镜的折射率为 $n_{\\ell} = 1.42$，中心厚度为 $t = 3.6\\,\\text{mm}$。在基准状态下，前表面和后表面的半径分别为 $R_{1,0} = +10.0\\,\\text{mm}$ 和 $R_{2,0} = -6.0\\,\\text{mm}$。在模拟厚度受限情况下曲率增加的改变后状态下，前表面和后表面的半径分别变为 $R_{1,1} = +8.5\\,\\text{mm}$ 和 $R_{2,1} = -5.3\\,\\text{mm}$。所有距离均沿光轴测量；在所有计算中使用米作为单位。\n\n计算改变后状态与基准状态之间的总光焦度的带符号变化量 $\\Delta F = F_{1} - F_{0}$。将您的最终数值答案四舍五入到四位有效数字，并以屈光度（$\\mathrm{D}$）表示。将您的最终答案表示为单个数字。",
            "solution": "解答过程分为两部分。首先，我们从基本原理出发，推导厚透镜的等效光焦度表达式。其次，我们将此公式应用于透镜两种状态的给定数值数据，并计算光焦度的变化。\n\n**第1部分：厚透镜光焦度公式的推导**\n\n我们考虑一个共轴光学系统，它由两个曲率半径为 $R_1$ 和 $R_2$ 的球面组成，沿光轴相距为 $t$。透镜材料的折射率为 $n_{\\ell}$，并且它两侧都浸没在折射率为 $n_m$ 的介质中。光学系统的等效光焦度 $F$ 是针对一条平行于光轴、入射高度为 $y_1$ 的光线定义的。该光线以相对于光轴的最终角度 $\\alpha'$ 从系统中出射。光焦度由关系式 $F = -\\frac{n_m \\alpha'}{y_1}$ 给出。\n\n让我们追踪这样一条光线穿过该系统。\n1.  **在第一个表面（前表面，半径 $R_1$）的折射**：\n    一条平行于光轴（$\\alpha_1 = 0$）、高度为 $y_1$ 的入射光线到达第一个表面。在介质 $n_a$ 和 $n_b$ 之间的界面处的近轴折射方程为 $n_b \\alpha_b = n_a \\alpha_a - y \\frac{n_b - n_a}{R}$。\n    在此， $n_a = n_m$，$n_b = n_{\\ell}$，$\\alpha_a = 0$，光线高度为 $y_1$。光线在透镜内部的角度 $\\alpha_{\\ell}$ 由下式给出：\n    $$n_{\\ell} \\alpha_{\\ell} = n_m (0) - y_1 \\frac{n_{\\ell} - n_m}{R_1}$$\n    第一个表面的光焦度为 $P_1 = \\frac{n_{\\ell} - n_m}{R_1}$。因此：\n    $$n_{\\ell} \\alpha_{\\ell} = -y_1 P_1 \\implies \\alpha_{\\ell} = -\\frac{y_1 P_1}{n_{\\ell}}$$\n\n2.  **在透镜中传播**：\n    光线在透镜介质（折射率为 $n_{\\ell}$）中传播距离 $t$。光线在第二个表面的高度 $y_2$ 由近轴平移方程 $y_{final} = y_{initial} + d \\cdot \\alpha$ 给出，其中 $d$ 是轴向距离。\n    $$y_2 = y_1 + t \\alpha_{\\ell} = y_1 + t \\left(-\\frac{y_1 P_1}{n_{\\ell}}\\right) = y_1 \\left(1 - \\frac{t P_1}{n_{\\ell}}\\right)$$\n\n3.  **在第二个表面（后表面，半径 $R_2$）的折射**：\n    角度为 $\\alpha_{\\ell}$、高度为 $y_2$ 的光线到达第二个表面。它从透镜（$n_{\\ell}$）折射回周围介质（$n_m$）。最终的出射角为 $\\alpha'$。近轴折射方程为：\n    $$n_m \\alpha' = n_{\\ell} \\alpha_{\\ell} - y_2 \\frac{n_m - n_{\\ell}}{R_2}$$\n    第二个表面的光焦度为 $P_2 = \\frac{n_m - n_{\\ell}}{R_2}$。代入此式，我们得到：\n    $$n_m \\alpha' = n_{\\ell} \\alpha_{\\ell} - y_2 P_2$$\n    现在，我们代入前几步得到的 $\\alpha_{\\ell}$ 和 $y_2$ 的表达式：\n    $$n_m \\alpha' = n_{\\ell} \\left(-\\frac{y_1 P_1}{n_{\\ell}}\\right) - y_1 \\left(1 - \\frac{t P_1}{n_{\\ell}}\\right) P_2$$\n    $$n_m \\alpha' = -y_1 P_1 - y_1 P_2 + y_1 \\frac{t P_1 P_2}{n_{\\ell}}$$\n    $$n_m \\alpha' = -y_1 \\left(P_1 + P_2 - \\frac{t P_1 P_2}{n_{\\ell}}\\right)$$\n\n4.  **等效光焦度**：\n    根据等效光焦度的定义 $F = -\\frac{n_m \\alpha'}{y_1}$，与上述表达式进行比较，我们得到厚透镜的等效光焦度公式：\n    $$F = P_1 + P_2 - \\frac{t}{n_{\\ell}} P_1 P_2$$\n    这就是 Gullstrand 方程，我们已经从基本原理推导出来了。\n\n**第2部分：光焦度变化的计算**\n\n我们已知以下参数。所有长度单位必须转换为米，以便以屈光度（$1\\,\\mathrm{D} = 1\\,\\mathrm{m}^{-1}$）进行计算。\n- $n_{m} = 1.336$ (无量纲)\n- $n_{\\ell} = 1.42$ (无量纲)\n- $t = 3.6\\,\\text{mm} = 3.6 \\times 10^{-3}\\,\\text{m}$\n\n表面光焦度由 $P_1 = \\frac{n_{\\ell} - n_m}{R_1}$ 和 $P_2 = \\frac{n_m - n_{\\ell}}{R_2}$ 给出。\n让我们计算折射率的恒定差值：$n_{\\ell} - n_m = 1.42 - 1.336 = 0.084$。\n\n**基准状态 (状态 0)**\n半径为 $R_{1,0} = +10.0\\,\\text{mm} = 0.010\\,\\text{m}$ 和 $R_{2,0} = -6.0\\,\\text{mm} = -0.006\\,\\text{m}$。\n表面光焦度为：\n$$P_{1,0} = \\frac{0.084}{0.010} = 8.4\\,\\text{D}$$\n$$P_{2,0} = \\frac{1.336 - 1.42}{-0.006} = \\frac{-0.084}{-0.006} = 14.0\\,\\text{D}$$\n透镜在基准状态下的总光焦度 $F_0$ 为：\n$$F_0 = P_{1,0} + P_{2,0} - \\frac{t}{n_{\\ell}} P_{1,0} P_{2,0}$$\n$$F_0 = 8.4 + 14.0 - \\frac{3.6 \\times 10^{-3}}{1.42} (8.4)(14.0)$$\n$$F_0 = 22.4 - \\frac{3.6 \\times 10^{-3}}{1.42} (117.6)$$\n$$F_0 = 22.4 - \\frac{0.42336}{1.42} \\approx 22.4 - 0.298140845$$\n$$F_0 \\approx 22.10185915\\,\\text{D}$$\n\n**改变后状态 (状态 1)**\n半径为 $R_{1,1} = +8.5\\,\\text{mm} = 0.0085\\,\\text{m}$ 和 $R_{2,1} = -5.3\\,\\text{mm} = -0.0053\\,\\text{m}$。\n表面光焦度为：\n$$P_{1,1} = \\frac{0.084}{0.0085} \\approx 9.88235294\\,\\text{D}$$\n$$P_{2,1} = \\frac{-0.084}{-0.0053} \\approx 15.84905660\\,\\text{D}$$\n透镜在改变后状态下的总光焦度 $F_1$ 为：\n$$F_1 = P_{1,1} + P_{2,1} - \\frac{t}{n_{\\ell}} P_{1,1} P_{2,1}$$\n$$F_1 \\approx (9.88235294 + 15.84905660) - \\frac{3.6 \\times 10^{-3}}{1.42} (9.88235294)(15.84905660)$$\n$$F_1 \\approx 25.73140954 - \\frac{3.6 \\times 10^{-3}}{1.42} (156.6259711)$$\n$$F_1 \\approx 25.73140954 - (0.002535211268)(156.6259711)$$\n$$F_1 \\approx 25.73140954 - 0.397143173$$\n$$F_1 \\approx 25.33426637\\,\\text{D}$$\n\n**光焦度变化**\n光焦度的变化为 $\\Delta F = F_{1} - F_{0}$。\n$$\\Delta F \\approx 25.33426637 - 22.10185915$$\n$$\\Delta F \\approx 3.23240722\\,\\text{D}$$\n\n问题要求将最终答案四舍五入至四位有效数字。\n$$\\Delta F \\approx 3.232\\,\\text{D}$$",
            "answer": "$$\\boxed{3.232}$$"
        },
        {
            "introduction": "现代晶状体生理学研究越来越依赖计算方法来揭示复杂的生物力学相互作用。这项高级动手实践  要求您使用简化的有限元模型构建一个计算“思想实验”。通过模拟晶状体局部刚度变化如何影响其在负载下的变形，您将直接探索老视的力学基础，并培养宝贵的计算生物力学技能。",
            "id": "4688585",
            "problem": "要求您设计并实现一个有限元思想实验，以研究在相同的悬韧带载荷下，晶状体核的区域性硬化如何影响表面曲率变化的模式。该问题必须通过构建一个简化的、小应变的、轴对称的离散弹性网络来解决，该网络近似于晶状体的子午截面，然后根据变形后的边界计算前后表面的曲率变化。该实验必须编码为一个完整的、可运行的程序，该程序能生成单行输出，汇总所提供测试套件的结果。\n\n从以下基本和核心定义开始：\n\n- 小应变范围内的线性和静态平衡：在平衡状态下，内部弹性力与外部载荷相平衡，无惯性项。如果 $\\mathbf{f}_i$ 表示节点 $i$ 上的合力，则平衡要求 $\\sum_i \\mathbf{f}_i = \\mathbf{0}$，并且对于每个内部连接，力都遵循胡克定律。\n- 线性轴向弹簧的胡克定律：连接节点 $i$ 和 $j$ 的弹簧沿单位向量 $\\mathbf{u}_{ij}$ 排列，其施加的轴向力大小为 $k_{ij} \\,\\Delta \\ell_{ij}$，其中 $k_{ij}$ 是弹簧刚度（单位为 $\\mathrm{N}/\\mathrm{m}$），$\\Delta \\ell_{ij}$ 是因位移而在 $\\mathbf{u}_{ij}$ 方向上投影长度的变化。在线性化小位移范围内，弹簧力的贡献可以写为 $k_{ij}\\, \\mathbf{u}_{ij} \\mathbf{u}_{ij}^{\\top} (\\mathbf{d}_j - \\mathbf{d}_i)$，其中 $\\mathbf{d}_i$ 和 $\\mathbf{d}_j$ 是节点 $i$ 和 $j$ 相对于其初始位置的位移向量。\n- 组装网络的静态平衡：如果 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{d}$ 是级联位移向量，则 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$，其中 $\\mathbf{f}$ 是外部施加的节点力向量。应用适当的约束来移除刚体模式（例如，固定中心节点）。\n\n建模假设与构造：\n\n1. 通过带角度划分的同心圆节点层来表示晶状体的子午截面，形成一个轴对称网络。初始外边界（皮质表面）是一个半径为 $R_0 = 0.005\\,\\mathrm{m}$ 的圆。核半径为 $r_n = 0.002\\,\\mathrm{m}$。使用三层材料层：一个半径为 $0$ 的中心节点（核中心），一个半径为 $r_n$ 的内环，一个半径为 $0.0035\\,\\mathrm{m}$ 的中环，以及一个半径为 $R_0$ 的外环。每个环使用 $M = 32$ 个均匀分布的角度节点。角度以弧度为单位。\n\n2. 弹簧与刚度：\n   - 径向弹簧连接每个节点与其在相邻内外层中相同角度上的邻居。内环径向连接到中心节点。\n   - 周向弹簧连接同一环内的相邻节点。\n   - 基础皮质刚度为径向弹簧 $k_{\\text{rad,cortex}} = 50\\,\\mathrm{N}/\\mathrm{m}$ 和周向弹簧 $k_{\\text{circ,cortex}} = 25\\,\\mathrm{N}/\\mathrm{m}$。核的硬化由一个乘法因子 $\\phi$ 表示，应用于核的弹簧刚度：$k_{\\text{rad,nucleus}} = \\phi\\,k_{\\text{rad,cortex}}$ 和 $k_{\\text{circ,nucleus}} = \\phi\\,k_{\\text{circ,cortex}}$。对于跨越核-皮质边界的弹簧，使用相应区域刚度的算术平均值。\n\n3. 悬韧带载荷：\n   - 对外边界节点施加向外的赤道力，这些节点的角度位置 $\\theta$ 满足 $|\\theta| \\le \\theta_{\\text{eq}}$ 或 $|\\theta - \\pi| \\le \\theta_{\\text{eq}}$，其中 $\\theta_{\\text{eq}} = \\pi/9$ (弧度)。\n   - 每个受影响边界节点的载荷是一个恒定的、径向向外的力 $\\mathbf{F}_\\text{z}$，其大小为 $F_\\text{z} = 0.002\\,\\mathrm{N}$，在所有测试案例中均相同。\n\n4. 约束：\n   - 将中心节点固定在原点（$x$ 和 $y$ 位移均设置为零），以消除刚体平移。角度以弧度指定。\n\n5. 表面曲率估计：\n   - 在求解平衡位移场 $\\mathbf{d}$ 后，更新节点位置并提取变形后的外边界节点。将边界节点分为 $y>0$ 的前表面节点和 $y<0$ 的后表面节点。\n   - 使用代数最小二乘法将前后边界节点集拟合到 $x^2 + y^2 + A x + B y + C = 0$ 形式的圆；圆心为 $(a,b) = (-A/2,-B/2)$，半径为 $R=\\sqrt{(A^2+B^2)/4 - C}$。\n   - 令 $R_a$ 为拟合的前表面半径，$R_p$ 为拟合的后表面半径。计算与初始半径 $R_0$ 的变化量：$\\Delta R_a = R_a - R_0$ 和 $\\Delta R_p = R_p - R_0$。\n\n6. 物理单位与答案规范：\n   - 所有长度和半径必须以 $\\mathrm{m}$ 为单位处理，力以 $\\mathrm{N}$ 为单位。程序必须为每个测试案例输出以米为单位的曲率半径变化（即 $\\Delta R_a$ 和 $\\Delta R_p$）。\n   - 角度必须以弧度处理。\n\n7. 测试套件：\n   - 在相同的载荷 $F_\\text{z}$、相同的网格和约束条件下，评估 $\\phi$ 值为 $[1.0, 3.0, 10.0, 0.5, 100.0]$。这些值涵盖了一般情况、中度硬化、强硬化、核软化以及一个极端硬化的边界情况。\n\n8. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果对应一个测试案例，是一个包含前后曲率半径变化（单位为米）的双元素列表。例如：\"[[deltaRa1,deltaRp1],[deltaRa2,deltaRp2],...]\"，其中每个 \"deltaR\" 是一个以米为单位的浮点数。输出中不允许有任何额外文本。",
            "solution": "该问题已经过验证，被确定为自洽、有科学依据且定义明确。以下解决方案提供了指定有限元思想实验的完整实现。\n\n此问题的核心是模拟简化的晶状体对外部作用力的静态力学响应，并量化该响应如何随区域材料属性的变化而改变。我们采用离散弹性网络（一种有限元方法的简化形式）来表示晶状体的子午截面。通过求解在小应变假设下由胡克定律产生的线性方程组，可以找到平衡变形。\n\n**1. 模型离散化与网络拓扑**\n\n晶状体的连续子午截面被离散化为有限数量的、排列在同心层中的节点。这种结构遵循了指定的轴对称简化。\n- 单个中心节点位于原点，半径为 $r=0\\,\\mathrm{m}$。\n- 三个同心节点环定义在半径 $r_1 = r_n = 0.002\\,\\mathrm{m}$（核边界）、$r_2 = 0.0035\\,\\mathrm{m}$（中间皮质）和 $r_3 = R_0 = 0.005\\,\\mathrm{m}$（外表面）处。\n- 每个环包含 $M = 32$ 个节点，按角度 $\\theta_k = 2\\pi k/M$ 均匀分布，其中 $k \\in \\{0, 1, ..., M-1\\}$。\n\n这导致总共有 $N_{\\text{nodes}} = 1 + 3M = 97$ 个节点。每个节点有两个平移自由度（DOF），$(d_x, d_y)$，从而使系统总自由度达到 $N_{\\text{DOF}} = 2 N_{\\text{nodes}} = 194$。\n\n这些节点通过线性轴向弹簧连接，形成弹性网络：\n- **径向弹簧：** 将每个节点与其在相邻内外环中相同角度位置的邻居连接起来。最内层环（$r=r_n$）的节点径向连接到中心节点。\n- **周向弹簧：** 连接同一环内的相邻节点。\n\n**2. 本构关系与刚度矩阵组装**\n\n网络的力学行为由小应变范围内的线性弹性理论决定。连接节点 $i$ 和 $j$ 的弹簧所施加的力 $\\mathbf{F}_{ij}$ 由胡克定律的线性化形式给出。该弹簧对节点 $j$ 的力向量为 $\\mathbf{f}_j = k_{ij}\\, \\mathbf{u}_{ij} \\mathbf{u}_{ij}^{\\top} (\\mathbf{d}_j - \\mathbf{d}_i)$，其中 $k_{ij}$ 是弹簧刚度，$\\mathbf{d}_i$ 和 $\\mathbf{d}_j$ 是节点 $i$ 和 $j$ 的位移向量，$\\mathbf{u}_{ij}$ 是沿弹簧初始方向的单位向量。\n\n整个网络的静态平衡由矩阵方程表示：\n$$ \\mathbf{K}\\mathbf{d} = \\mathbf{f} $$\n其中 $\\mathbf{d}$ 是所有节点位移的全局向量，$\\mathbf{f}$ 是外部施加的节点力的全局向量，$\\mathbf{K}$ 是 $194 \\times 194$ 的全局刚度矩阵。\n\n矩阵 $\\mathbf{K}$ 是通过对所有单个弹簧的贡献求和来组装的。对于节点 $p$ 和 $q$ 之间的一个弹簧，其对全局刚度矩阵的贡献包括将其 $2 \\times 2$ 的局部刚度矩阵 $\\mathbf{k}_{\\text{spring}} = k_{pq} \\mathbf{u}_{pq} \\mathbf{u}_{pq}^\\top$ 加减到 $\\mathbf{K}$ 中对应于节点 $p$ 和 $q$ 自由度的相应 $2 \\times 2$ 块中。\n\n弹簧刚度值由其位置决定：\n- **皮质：** 完全位于皮质区域内（$r > r_n = 0.002\\,\\mathrm{m}$）的弹簧具有基础刚度 $k_{\\text{rad,cortex}} = 50\\,\\mathrm{N}/\\mathrm{m}$ 和 $k_{\\text{circ,cortex}} = 25\\,\\mathrm{N}/\\mathrm{m}$。\n- **核：** 完全位于核内（$r \\le r_n$）的弹簧，其刚度通过因子 $\\phi$ 进行缩放：$k_{\\text{rad,nucleus}} = \\phi\\,k_{\\text{rad,cortex}}$ 和 $k_{\\text{circ,nucleus}} = \\phi\\,k_{\\text{circ,cortex}}$。\n- **边界：** 连接核环（$r_1=r_n$）与第一个皮质环（$r_2=0.0035\\,\\mathrm{m}$）的径向弹簧，其刚度等于两个区域的算术平均值：$k_{\\text{boundary}} = \\frac{1}{2}(k_{\\text{rad,nucleus}} + k_{\\text{rad,cortex}}) = \\frac{\\phi+1}{2}k_{\\text{rad,cortex}}$。\n\n**3. 载荷与约束**\n\n- **悬韧带载荷：** 来自悬韧带的外部载荷被建模为施加在外边界（$r=R_0$）节点上的一组力。一个大小为 $F_z = 0.002\\,\\mathrm{N}$ 的恒定径向力被施加到每个角度位置 $\\theta$ 满足 $|\\theta| \\le \\theta_{\\text{eq}}$ 或 $|\\theta - \\pi| \\le \\theta_{\\text{eq}}$ 的外层节点上，其中 $\\theta_{\\text{eq}} = \\pi/9\\,\\text{弧度}$。这些力被组装到全局力向量 $\\mathbf{f}$ 中。\n- **本质边界条件：** 为防止刚体运动并确保唯一解，中心节点（位于 $r=0$）被固定。这通过将其位移分量 $d_x$ 和 $d_y$ 设置为零来实现。在计算上，这是通过在求解前从全局系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$ 中移除相应的行和列来处理的。\n\n**4. 求解与曲率估计**\n\n对于测试套件中硬化参数 $\\phi$ 的每个值，执行以下步骤：\n1. 组装全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$。\n2. 求解简化的线性系统以获得未知的节点位移 $\\mathbf{d}$。\n3. 使用计算出的位移更新所有节点的初始坐标，以获得网络的变形构型。\n4. 将外边界的变形节点分为前表面集（$y>0$）和后表面集（$y<0$）。\n5. 对于每组点 $(x_i, y_i)$，使用代数最小二乘法拟合一个形式为 $x^2 + y^2 + Ax + By + C = 0$ 的圆。这等同于求解线性系统 $\\mathbf{M}\\mathbf{p} = \\mathbf{b}$ 以获得参数向量 $\\mathbf{p} = [A, B, C]^\\top$，其中 $\\mathbf{M}$ 的每一行是 $[x_i, y_i, 1]$，$\\mathbf{b}$ 中对应的项是 $-(x_i^2 + y_i^2)$。\n6. 拟合圆的半径计算公式为 $R = \\sqrt{(A^2+B^2)/4 - C}$。这给出了前表面半径 $R_a$ 和后表面半径 $R_p$。\n7. 最终的输出量是这些半径相对于初始未变形半径 $R_0$ 的变化量：\n   $$ \\Delta R_a = R_a - R_0 $$\n   $$ \\Delta R_p = R_p - R_0 $$\n\n对所有指定的 $\\phi$ 值重复此过程，并将结果汇总为所需的输出格式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a finite element model to study lens accommodation.\n    \"\"\"\n\n    # 1. Define constants and model parameters\n    R0 = 0.005  # m, outer radius\n    R_MID = 0.0035 # m, middle ring radius\n    RN = 0.002  # m, nucleus radius\n    M = 32  # angular nodes per ring\n    K_RAD_CORTEX = 50.0  # N/m\n    K_CIRC_CORTEX = 25.0  # N/m\n    FZ = 0.002  # N, force magnitude per node\n    THETA_EQ = np.pi / 9.0  # radians, equatorial load zone angle\n\n    # Test suite for nucleus stiffening factor\n    test_cases = [1.0, 3.0, 10.0, 0.5, 100.0]\n\n    # Helper function for circle fitting\n    def fit_circle_radius(points):\n        \"\"\"\n        Fits a circle to a set of points using algebraic least-squares.\n        The equation is x^2 + y^2 + Ax + By + C = 0.\n        This is solved as a linear system M * p = b where p = [A, B, C]^T.\n        \"\"\"\n        x = points[:, 0]\n        y = points[:, 1]\n        \n        M_matrix = np.vstack([x, y, np.ones(len(x))]).T\n        b_vector = -(x**2 + y**2)\n        \n        p, _, _, _ = np.linalg.lstsq(M_matrix, b_vector, rcond=None)\n        A, B, C = p\n        \n        # Radius R = sqrt((A^2 + B^2)/4 - C)\n        radius = np.sqrt((A**2 + B**2) / 4.0 - C)\n        return radius\n\n    # 2. Generate initial node coordinates\n    N_RINGS = 3\n    N_NODES = 1 + N_RINGS * M\n    N_DOF = 2 * N_NODES\n    initial_coords = np.zeros((N_NODES, 2))\n    \n    # Rings radii and node indices\n    radii = [RN, R_MID, R0]\n    ring_start_indices = [1, 1 + M, 1 + 2 * M]\n    \n    for i in range(N_RINGS):\n        radius = radii[i]\n        start_idx = ring_start_indices[i]\n        for k in range(M):\n            angle = 2.0 * np.pi * k / M\n            initial_coords[start_idx + k] = [radius * np.cos(angle), radius * np.sin(angle)]\n\n    results = []\n    \n    for phi in test_cases:\n        # 3. Assemble Stiffness Matrix K\n        K = np.zeros((N_DOF, N_DOF))\n        \n        # Define stiffness values for current phi\n        k_rad_nuc = phi * K_RAD_CORTEX\n        k_circ_nuc = phi * K_CIRC_CORTEX\n        k_boundary = 0.5 * (k_rad_nuc + K_RAD_CORTEX)\n        \n        def add_spring_to_K(p_idx, q_idx, k_spring):\n            pos_p = initial_coords[p_idx]\n            pos_q = initial_coords[q_idx]\n            vec = pos_q - pos_p\n            length = np.linalg.norm(vec)\n            if length == 0: return\n            u = vec / length\n            \n            k_mat = k_spring * np.outer(u, u)\n            \n            dof_p = slice(2 * p_idx, 2 * p_idx + 2)\n            dof_q = slice(2 * q_idx, 2 * q_idx + 2)\n            \n            K[dof_p, dof_p] += k_mat\n            K[dof_q, dof_q] += k_mat\n            K[dof_p, dof_q] -= k_mat\n            K[dof_q, dof_p] -= k_mat\n\n        # Radial springs\n        for k in range(M):\n            # Center to Nucleus Ring (Ring 1)\n            add_spring_to_K(0, 1 + k, k_rad_nuc)\n            # Nucleus Ring (1) to Cortex Ring (2)\n            add_spring_to_K(1 + k, 1 + M + k, k_boundary)\n            # Cortex Ring (2) to Outer Ring (3)\n            add_spring_to_K(1 + M + k, 1 + 2 * M + k, K_RAD_CORTEX)\n\n        # Circumferential springs\n        k_circ_values = [k_circ_nuc, K_CIRC_CORTEX, K_CIRC_CORTEX]\n        for i in range(N_RINGS):\n            start_idx = ring_start_indices[i]\n            k_circ = k_circ_values[i]\n            for k in range(M):\n                p_idx = start_idx + k\n                q_idx = start_idx + (k + 1) % M\n                add_spring_to_K(p_idx, q_idx, k_circ)\n\n        # 4. Assemble Force Vector f\n        f = np.zeros(N_DOF)\n        outer_ring_start_idx = 1 + 2 * M\n        for k in range(M):\n            angle = 2.0 * np.pi * k / M\n            \n            # Normalize angle to [-pi, pi] for easier checking\n            angle_norm = (angle + np.pi) % (2 * np.pi) - np.pi\n            \n            is_loaded = abs(angle_norm) = THETA_EQ or abs(abs(angle_norm) - np.pi) = THETA_EQ\n            \n            if is_loaded:\n                node_idx = outer_ring_start_idx + k\n                force_vec = np.array([np.cos(angle), np.sin(angle)]) * FZ\n                f[2 * node_idx : 2 * node_idx + 2] = force_vec\n\n        # 5. Apply Constraints and Solve\n        # Central node (index 0) is fixed.\n        constrained_dof = [0, 1]\n        active_dof = np.setdiff1d(np.arange(N_DOF), constrained_dof)\n        \n        K_reduced = K[np.ix_(active_dof, active_dof)]\n        f_reduced = f[active_dof]\n        \n        d_reduced = np.linalg.solve(K_reduced, f_reduced)\n        \n        d_full = np.zeros(N_DOF)\n        d_full[active_dof] = d_reduced\n        \n        # 6. Post-processing: Compute deformed curvature\n        displacements = d_full.reshape((N_NODES, 2))\n        deformed_coords = initial_coords + displacements\n        \n        outer_nodes_deformed = deformed_coords[outer_ring_start_idx:]\n        \n        # Split into anterior (y > 0) and posterior (y  0)\n        # Exclude equatorial nodes (y=0) from the fit\n        y_coords = outer_nodes_deformed[:, 1]\n        anterior_points = outer_nodes_deformed[y_coords > 1e-9]\n        posterior_points = outer_nodes_deformed[y_coords  -1e-9]\n        \n        R_a = fit_circle_radius(anterior_points)\n        R_p = fit_circle_radius(posterior_points)\n        \n        delta_Ra = R_a - R0\n        delta_Rp = R_p - R0\n        \n        results.append([delta_Ra, delta_Rp])\n        \n    # 7. Format and print the final output\n    output_str = '[' + ','.join([f'[{r[0]},{r[1]}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}