{
    "hands_on_practices": [
        {
            "introduction": "在构建人工视网膜之前，我们必须首先理解其基本组件的工作原理。本练习从分子层面入手，模拟单个光敏通道（“执行器”）如何响应光照。通过推导稳态下的通道开放概率，您将对刺激（光）与细胞反应之间的关系建立起定量的理解，这是光遗传学的核心原理。",
            "id": "4705518",
            "problem": "一群嵌入视网膜神经节细胞膜中的相同的视紫红质通道蛋白-2 (ChR2) 分子被建模为一个双态系统，该系统具有一个闭合状态和一个开放的导电状态。在连续光照下，假设开放通道的比例（记为 $O(t)$）根据应用于状态转换的质量作用定律进行演化。进入开放状态的正向转换速率与双分子开启速率常数 $k_{\\mathrm{on}}$ 和一个在光照方案下保持恒定的有效视蛋白活化浓度 $[A]$ 的乘积成正比，而从开放状态的逆向转换则以一级关闭速率常数 $k_{\\mathrm{off}}$ 发生。假设通道不脱敏，没有额外的中间状态，并且通道独立作用。\n\n给定 $k_{\\mathrm{on}}=1\\times 10^{6}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$，$k_{\\mathrm{off}}=100\\ \\mathrm{s}^{-1}$，以及 $[A]=1\\ \\mu\\mathrm{M}$，请从第一性原理推导连续光照下的稳态开放通道比例 $O_{\\mathrm{ss}}$。在进行计算前，将 $[A]$ 以 $\\mathrm{M}$ 为单位表示。将最终的 $O_{\\mathrm{ss}}$ 以小数形式（无量纲）给出，并四舍五入到 $4$ 位有效数字。",
            "solution": "题目将一群视紫红质通道蛋白-2 (ChR2) 分子描述为一个双态系统，该系统由一个我们记为 $C$ 的闭合状态和一个我们记为 $O$ 的开放导电状态组成。这些状态之间的转换遵循质量作用动力学。动力学方案如下：\n$$ C \\underset{k_{\\mathrm{off}}}{\\stackrel{k_{1}}{\\rightleftharpoons}} O $$\n从 $C$ 到 $O$ 的正向转换由一个伪一级速率常数 $k_1$ 表征。题目指出，该速率与双分子开启速率常数 $k_{\\mathrm{on}}$ 和一个恒定的有效视蛋白活化浓度 $[A]$ 的乘积成正比。因此，我们将 $k_1$ 定义为：\n$$ k_{1} = k_{\\mathrm{on}}[A] $$\n从 $O$ 到 $C$ 的逆向转换是一个一级过程，其速率常数为 $k_{\\mathrm{off}}$。\n\n令 $O(t)$ 和 $C(t)$ 分别为在时间 $t$ 时处于开放状态和闭合状态的通道比例。由于系统完全由这两种状态组成，它们的比例之和必须为1：\n$$ O(t) + C(t) = 1 $$\n这个守恒定律使我们能够用开放通道的比例来表示闭合通道的比例：$C(t) = 1 - O(t)$。\n\n开放通道比例 $O(t)$ 的时间演化由一个微分方程描述。$O(t)$ 的变化率（记为 $\\frac{dO(t)}{dt}$）是通道开放速率与通道关闭速率之差。\n开放速率是正向速率常数 $k_1$ 与处于闭合状态的通道比例 $C(t)$ 的乘积。\n$$ \\text{开放速率} = k_{1} C(t) = k_{1} (1 - O(t)) $$\n关闭速率是逆向速率常数 $k_{\\mathrm{off}}$ 与处于开放状态的通道比例 $O(t)$ 的乘积。\n$$ \\text{关闭速率} = k_{\\mathrm{off}} O(t) $$\n综合这些，得到 $O(t)$ 的完整动力学方程：\n$$ \\frac{dO(t)}{dt} = k_{1}(1 - O(t)) - k_{\\mathrm{off}}O(t) $$\n$$ \\frac{dO(t)}{dt} = k_{1} - k_{1}O(t) - k_{\\mathrm{off}}O(t) $$\n$$ \\frac{dO(t)}{dt} = k_{1} - (k_{1} + k_{\\mathrm{off}})O(t) $$\n题目要求的是稳态开放通道比例 $O_{\\mathrm{ss}}$。在稳态下，系统处于平衡状态，意味着状态布居的净变化率为零。因此，我们令 $\\frac{dO(t)}{dt} = 0$ 并求解相应的比例 $O_{\\mathrm{ss}}$：\n$$ 0 = k_{1} - (k_{1} + k_{\\mathrm{off}})O_{\\mathrm{ss}} $$\n重新整理以求解 $O_{\\mathrm{ss}}$：\n$$ (k_{1} + k_{\\mathrm{off}})O_{\\mathrm{ss}} = k_{1} $$\n$$ O_{\\mathrm{ss}} = \\frac{k_{1}}{k_{1} + k_{\\mathrm{off}}} $$\n代入 $k_1$ 的表达式：\n$$ O_{\\mathrm{ss}} = \\frac{k_{\\mathrm{on}}[A]}{k_{\\mathrm{on}}[A] + k_{\\mathrm{off}}} $$\n这是稳态开放通道比例的通用解析解。\n\n我们给定了以下数值：\n$$ k_{\\mathrm{on}} = 1 \\times 10^{6}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1} $$\n$$ k_{\\mathrm{off}} = 100\\ \\mathrm{s}^{-1} $$\n$$ [A] = 1\\ \\mu\\mathrm{M} $$\n首先，我们必须将浓度 $[A]$ 用摩尔浓度 ($\\mathrm{M}$) 的基本单位表示：\n$$ [A] = 1\\ \\mu\\mathrm{M} = 1 \\times 10^{-6}\\ \\mathrm{M} $$\n接下来，我们计算伪一级速率常数 $k_1 = k_{\\mathrm{on}}[A]$ 的值：\n$$ k_{1} = (1 \\times 10^{6}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}) \\times (1 \\times 10^{-6}\\ \\mathrm{M}) = 1\\ \\mathrm{s}^{-1} $$\n现在，我们可以将 $k_1$ 和 $k_{\\mathrm{off}}$ 的数值代入 $O_{\\mathrm{ss}}$ 的表达式中：\n$$ O_{\\mathrm{ss}} = \\frac{1\\ \\mathrm{s}^{-1}}{1\\ \\mathrm{s}^{-1} + 100\\ \\mathrm{s}^{-1}} = \\frac{1}{101} $$\n题目要求一个四舍五入到 $4$ 位有效数字的小数值。\n$$ O_{\\mathrm{ss}} = \\frac{1}{101} \\approx 0.0099009900... $$\n将此值四舍五入到 $4$ 位有效数字得到：\n$$ O_{\\mathrm{ss}} \\approx 0.009901 $$\n这个结果是一个无量纲的比例，符合预期。",
            "answer": "$$\\boxed{0.009901}$$"
        },
        {
            "introduction": "在模拟了通道的反应之后，下一个挑战是如何将正确的光刺激传递给眼内的目标神经元。本练习旨在弥合外部硬件（光投影设备）与视网膜生物学现实之间的鸿沟。您将计算视网膜上的实际辐照度，同时考虑眼睛的光学特性，这是设计任何有效的光遗传学疗法的关键步骤。",
            "id": "4705564",
            "problem": "一项用于激活视网膜神经节细胞的光遗传学刺激实验，使用眼底投影仪将中心波长为 $\\lambda = 470\\,\\mathrm{nm}$ 的连续蓝光投射到视网膜上。该投影仪在角膜平面输出的标称辐射功率为 $P_{\\text{out}} = 5\\,\\mathrm{mW}$。在波长 $\\lambda = 470\\,\\mathrm{nm}$ 处，眼球介质透射入射辐射功率的一小部分，比例为 $T = 0.60$。该投影仪在视网膜上形成一个均匀的圆形光斑，在眼睛处测量的角直径为 $\\theta_{\\text{diam}} = 5^{\\circ}$。假设眼睛为正视眼，视网膜放大系数为 $M = 0.29\\,\\mathrm{mm/deg}$（每度视角的线性视网膜尺寸），并假设光斑上的能量分布在视网膜上是空间均匀的。\n\n从辐照度的辐射度学定义（单位面积的辐射功率）和用于将视角转换为线性视网膜范围的基本几何光学出发，推导视网膜辐照度的表达式并计算其值。以 $\\mathrm{mW/mm^{2}}$ 为单位表示最终的辐照度，并将答案四舍五入至三位有效数字。对任何角度量均使用度作为单位。",
            "solution": "该问题被评估为有效，因为它具有科学依据，提问明确且客观。它提供了一套完整且一致的已知条件，可用于根据辐射度学和眼科光学的既定原则计算视网膜辐照度。\n\n目标是推导视网膜辐照度 $E_{\\text{retina}}$ 的表达式并计算其值。辐照度定义为单位面积的辐射功率。计算过程分为三个主要步骤：确定到达视网膜的辐射功率，确定视网膜上被照亮光斑的面积，然后计算它们的比率。\n\n首先，我们确定入射到视网膜上的辐射功率 $P_{\\text{retina}}$。问题陈述，眼底投影仪在角膜平面输出的标称辐射功率为 $P_{\\text{out}} = 5\\,\\mathrm{mW}$。眼球介质将此功率的一部分（比例为 $T = 0.60$）透射到视网膜。因此，到达视网膜的功率为：\n$$P_{\\text{retina}} = T \\cdot P_{\\text{out}}$$\n\n其次，我们确定视网膜上被照亮光斑的面积 $A_{\\text{retina}}$。光斑的角直径为 $\\theta_{\\text{diam}} = 5^{\\circ}$。视网膜放大系数 $M = 0.29\\,\\mathrm{mm/deg}$ 提供了从以度为单位的视角到视网膜上以毫米为单位的线性尺寸的转换。因此，视网膜上光斑的线性直径 $d_{\\text{retina}}$ 为：\n$$d_{\\text{retina}} = M \\cdot \\theta_{\\text{diam}}$$\n问题指明光斑是均匀且圆形的。圆的面积由 $A = \\pi r^2 = \\pi (d/2)^2$ 给出。代入视网膜直径的表达式，我们得到视网膜上光斑的面积：\n$$A_{\\text{retina}} = \\frac{\\pi d_{\\text{retina}}^2}{4} = \\frac{\\pi (M \\cdot \\theta_{\\text{diam}})^2}{4}$$\n\n第三，我们计算视网膜辐照度 $E_{\\text{retina}}$。由于能量分布是空间均匀的，辐照度就是到达视网膜的总功率除以光斑的总面积。\n$$E_{\\text{retina}} = \\frac{P_{\\text{retina}}}{A_{\\text{retina}}}$$\n代入先前推导的 $P_{\\text{retina}}$ 和 $A_{\\text{retina}}$ 的表达式，得到以给定参数表示的视网膜辐照度的通用表达式：\n$$E_{\\text{retina}} = \\frac{T \\cdot P_{\\text{out}}}{\\frac{\\pi (M \\cdot \\theta_{\\text{diam}})^2}{4}} = \\frac{4 T P_{\\text{out}}}{\\pi (M \\theta_{\\text{diam}})^2}$$\n\n现在，我们将提供的数值代入此表达式以求得最终答案。\n给定的值为：\n$P_{\\text{out}} = 5\\,\\mathrm{mW}$\n$T = 0.60$\n$\\theta_{\\text{diam}} = 5^{\\circ}$\n$M = 0.29\\,\\mathrm{mm/deg}$\n\n首先，计算光斑的线性直径：\n$$d_{\\text{retina}} = (0.29\\,\\mathrm{mm/deg}) \\cdot (5^{\\circ}) = 1.45\\,\\mathrm{mm}$$\n\n接下来，计算光斑的面积：\n$$A_{\\text{retina}} = \\frac{\\pi (1.45\\,\\mathrm{mm})^2}{4} = \\frac{\\pi (2.1025\\,\\mathrm{mm}^2)}{4} \\approx 1.6513\\,\\mathrm{mm}^2$$\n\n然后，计算到达视网膜的功率：\n$$P_{\\text{retina}} = (0.60) \\cdot (5\\,\\mathrm{mW}) = 3.0\\,\\mathrm{mW}$$\n\n最后，计算辐照度：\n$$E_{\\text{retina}} = \\frac{P_{\\text{retina}}}{A_{\\text{retina}}} = \\frac{3.0\\,\\mathrm{mW}}{1.6513\\,\\mathrm{mm}^2} \\approx 1.81675\\,\\mathrm{mW/mm^2}$$\n\n问题要求将答案四舍五入至三位有效数字。\n$$E_{\\text{retina}} \\approx 1.82\\,\\mathrm{mW/mm^2}$$",
            "answer": "$$\\boxed{1.82}$$"
        },
        {
            "introduction": "一个成功的视觉假体不仅仅是其组件的简单堆砌，它是一个必须实时编码有意义信息的复杂系统。这最后一个练习将视角提升到系统层面，要求您设计并评估一种用于编码运动信息的刺激策略。通过处理相机帧率和电极容量等限制，您将着手解决一个复杂的工程问题：如何将动态的视觉场景转化为连贯的神经刺激模式。",
            "id": "4705589",
            "problem": "一种基于光电刺激的视网膜假体由一个以固定帧率采样视觉场景的摄像头和一个刺激视网膜神经节细胞（RGCs）的微电极阵列驱动。在每个摄像头帧内，刺激必须在严格的延迟时间内发生，以保留对运动感知至关重要的时间信息。考虑一个具有以下要素和假设的系统：(i) 一个帧率为 $f_c$（单位为 $\\text{Hz}$）、帧周期为 $T_c = 1/f_c$（单位为 $\\text{s}$）的摄像头，(ii) 一个包含 $E$ 个电极的电极阵列，其中每个电极的最小脉冲间隔为 $\\tau_e$（单位为 $\\text{ms}$），这代表了对刺激速率的生物物理和安全约束，(iii) 一个延迟预算 $L$（单位为 $\\text{ms}$），与一帧相对应的脉冲必须在此预算内传送，(iv) 视觉刺激是一个宽度为 $w$（单位为像素）的垂直条，以速度 $v$（单位为 $\\text{pixels/s}$）在大小为 $N_x \\times N_y$（单位为像素）的图像上水平平移。对于运动编码，考虑一种 On-Off 时间分解，其中亮度上升的转变（On 事件）发生在（垂直条的）前缘，而亮度下降的转变（Off 事件）发生在后缘。假设在帧期间，垂直条始终保持在图像边界内，因此边缘效应可以忽略不计。\n\n基本原理和约束条件：\n- 时间采样由帧率 $f_c$ 决定，帧周期为 $T_c = 1/f_c$。\n- 脉冲间隔 $\\tau_e$ 限制了在单个电极上调度脉冲的密集程度；这些脉冲间隔不重叠，并遵循 $\\tau_e$ 的最小间隔。\n- 将 $\\tau_e$ 和 $L$ 转换为秒后，每帧允许的刺激时间为离散集合 $\\{ t_k = k \\,\\tau_e \\mid k \\in \\mathbb{Z}_{\\ge 0},\\ 0 \\le t_k  L \\}$。设此类允许的时隙数量为 $S = \\lceil L/\\tau_e \\rceil$，其中 $L$ 和 $\\tau_e$ 的单位均为秒。\n- 每帧脉冲容量为 $C = E \\cdot S$，单位为脉冲/帧。\n\n平移垂直条的需求模型：\n- 在一帧内，垂直条扫过的预期列数为 $v \\cdot T_c$（单位为像素）。经历 On 转变的预期像素数为 $N_y \\cdot v \\cdot T_c$，Off 转变（两个边缘）的预期像素数也相同，因此总需求为 $D \\approx 2\\, N_y \\, v \\, T_c$ 脉冲/帧。\n- 对于整数实现，定义 $N_{\\text{on}} = \\operatorname{round}(N_y \\, v \\, T_c)$，$N_{\\text{off}} = \\operatorname{round}(N_y \\, v \\, T_c)$，以及 $D = N_{\\text{on}} + N_{\\text{off}}$。\n\n在约束下保留运动线索的调度算法：\n- 为 $S$ 个时隙中的每一个维持 $E$ 个脉冲的容量。从最早到最晚的时隙贪婪地调度 On 事件，从最晚到最早的时隙贪婪地调度 Off 事件，两者都受限于每个时隙的容量和总事件数 $N_{\\text{on}}$ 和 $N_{\\text{off}}$。具体来说，将 On 事件分配到时隙 $k = 0,1,\\ldots,S-1$ 中，每个时隙不超过 $E$；将 Off 事件分配到时隙 $k = S-1,S-2,\\ldots,0$ 中，不超过每个时隙的剩余容量。\n- 因容量限制而无法调度的任何事件都将被丢弃。\n- 设 $N_{\\text{sched}}$ 为已调度的总脉冲数。定义映射比率 $R = N_{\\text{sched}}/D$（无量纲；表示为四舍五入到三位小数的小数）。\n- 为量化运动线索的保留程度，使用已调度的 On 和 Off 脉冲之间的时间间隔。设 $\\bar{t}_{\\text{on}}$ 为 On 脉冲的平均调度时间，$\\bar{t}_{\\text{off}}$ 为 Off 脉冲的平均调度时间，根据它们分配的时隙计算得出，公式为 $\\bar{t} = \\sum_k n_k \\, (k\\,\\tau_e) / \\sum_k n_k$，其中 $\\tau_e$ 的单位为秒。定义运动线索分数 $M = \\max\\{0,\\min\\{1,(\\bar{t}_{\\text{off}} - \\bar{t}_{\\text{on}})/L\\}\\}$（无量纲；表示为四舍五入到三位小数的小数），其中 $L$ 的单位为秒。如果任一类别（On 或 Off）的已调度脉冲数为零，则设 $M = 0$。\n\n任务：\n1. 将 $L$ 和 $\\tau_e$ 从毫秒转换为秒。计算 $S = \\lceil L/\\tau_e \\rceil$ 和每帧容量 $C = E \\cdot S$（整数）。\n2. 对于每个测试用例，计算 $N_{\\text{on}}$、$N_{\\text{off}}$，并根据上述算法调度脉冲以获得 $N_{\\text{sched}}$、$R$ 和 $M$。\n3. 实现调度并为每个测试用例计算 $(C,R,M)$。\n\n单位和数值报告：\n- 帧率 $f_c$ 的单位是 $\\text{Hz}$，延迟 $L$ 和脉冲间隔 $\\tau_e$ 的单位是 $\\text{ms}$（内部转换为秒），速度 $v$ 的单位是 $\\text{pixels/s}$，图像尺寸的单位是 $\\text{pixels}$。\n- 报告 $C$ 为整数，$R$ 和 $M$ 为四舍五入到三位小数的小数。\n\n测试套件：\n- 用例 A (理想路径)：$f_c = 60\\,\\text{Hz}$，$E = 500$，$L = 10\\,\\text{ms}$，$\\tau_e = 4\\,\\text{ms}$，$N_x = 128$，$N_y = 64$，$v = 240\\,\\text{pixels/s}$，$w = 3\\,\\text{pixels}$。\n- 用例 B (延迟受限边界)：$f_c = 60\\,\\text{Hz}$，$E = 500$，$L = 5\\,\\text{ms}$，$\\tau_e = 4\\,\\text{ms}$，$N_x = 128$，$N_y = 64$，$v = 600\\,\\text{pixels/s}$，$w = 3\\,\\text{pixels}$。\n- 用例 C (需求主导，时间槽更粗)：$f_c = 60\\,\\text{Hz}$，$E = 500$，$L = 10\\,\\text{ms}$，$\\tau_e = 8\\,\\text{ms}$，$N_x = 256$，$N_y = 128$，$v = 480\\,\\text{pixels/s}$，$w = 5\\,\\text{pixels}$。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个以逗号分隔的列表的列表，其中每个内部列表按 A、B、C 的顺序包含测试用例的 $[C,R,M]$。例如：\"[[C_A,R_A,M_A],[C_B,R_B,M_B],[C_C,R_C,M_C]]\"。确保 $C$ 是整数，$R$ 和 $M$ 是四舍五入到三位小数的小数，不打印任何额外文本。",
            "solution": "该问题要求对一种视网膜假体的简化模型进行定量分析，评估其在特定约束下编码运动的性能。解决方案涉及分步实现所提供的模型，从参数计算到算法执行和指标评估。\n\n首先，我们形式化系统的容量。刺激受到帧延迟预算 $L$ 和每个电极的最小脉冲间隔 $\\tau_e$ 的双重约束。两者都以毫秒 ($ms$) 为单位给出，必须转换为秒 ($s$) 以与以赫兹 ($Hz$) 为单位的帧率 $f_c$ 保持一致。帧周期为 $T_c = 1/f_c$。在延迟预算 $L$ 内，单个电极可以在离散时间点 $t_k = k \\cdot \\tau_e$ 传递脉冲，其中 $k$ 是非负整数且 $t_k  L$。因此，可用时间槽的数量 $S$ 是此类整数 $k$ 的总数，由 $S = \\lceil L/\\tau_e \\rceil$ 给出。由于微电极阵列由 $E$ 个独立电极组成，每个电极在每个时间槽内可以发射一个脉冲，因此每帧的总脉冲容量为 $C = E \\cdot S$。\n\n其次，我们对视觉刺激产生的刺激需求进行建模。刺激是一个垂直条，以速度 $v$（单位为像素/秒）在高度为 $N_y$（单位为像素）的传感器上平移。On-Off 分解模型假设刺激事件在垂直条的前缘 (On) 和后缘 (Off) 产生。在单个帧周期 $T_c$ 内，垂直条扫过 $v \\cdot T_c$ 像素的水平距离。因此，从暗到亮转变的像素数（On 事件）是前缘扫过的面积，近似为 $N_y \\cdot v \\cdot T_c$。类似地，Off 事件的数量也是 $N_y \\cdot v \\cdot T_c$。为了获得整数个事件，我们应用四舍五入函数。设 $d = N_y \\cdot v \\cdot T_c$。On 事件的数量为 $N_{\\text{on}} = \\operatorname{round}(d)$，Off 事件的数量为 $N_{\\text{off}} = \\operatorname{round}(d)$。每帧的总需求为 $D = N_{\\text{on}} + N_{\\text{off}}$。该模型使用 `round` 函数，其实现方式是四舍五入到最近的整数，为确保确定性，半整数向上取整。\n\n第三，我们实现指定的调度算法。该算法管理将 $D$ 个请求的脉冲分配到 $C$ 个可用的脉冲槽中。它为 $S$ 个时间槽中的每一个维持 $E$ 个脉冲的容量。调度是不对称的，以编码 On 和 Off 事件的时间分离，这对于运动感知至关重要。\n1. 首先调度 On 事件（$N_{\\text{on}}$）。算法从最早的时隙（$k=0$）开始，贪婪地填充到最晚的时隙（$k=S-1$），每个时隙分配最多 $E$ 个脉冲，直到所有 $N_{\\text{on}}$ 事件都被调度或容量耗尽。\n2. 其次调度 Off 事件（$N_{\\text{off}}$），使用*剩余*的时隙容量。算法从最晚的时隙（$k=S-1$）向后填充到最早的时隙（$k=0$），同样要遵守每个时隙的剩余容量，直到所有 $N_{\\text{off}}$ 事件都被调度或容量耗尽。\n任何无法放置的事件都将被丢弃。\n\n最后，我们计算性能指标。已调度的总脉冲数为 $N_{\\text{sched}}$。\n- 映射比率 $R$ 量化了成功调度的总需求的分数：$R = N_{\\text{sched}} / D$。$R=1$ 的值表示没有脉冲被丢弃。\n- 运动线索分数 $M$ 量化了 On 和 Off 信号之间的时间分离被保留的程度。它基于 On 脉冲的平均调度时间 $\\bar{t}_{\\text{on}}$ 和 Off 脉冲的平均调度时间 $\\bar{t}_{\\text{off}}$。对于在时隙 $k$ 中调度了 $n_k$ 个脉冲的一组脉冲，平均时间为 $\\bar{t} = (\\sum_k n_k \\cdot k \\cdot \\tau_e) / (\\sum_k n_k)$。然后将该分数通过延迟预算 $L$ 进行归一化，并限制在 $[0, 1]$ 范围内：$M = \\max\\{0, \\min\\{1, (\\bar{t}_{\\text{off}} - \\bar{t}_{\\text{on}})/L\\}\\}$。如果 $N_{\\text{on}}$ 或 $N_{\\text{off}}$ 的已调度脉冲数为零，则时间分离未定义，$M$ 设为 $0$。\n\n该实现将通过应用以下步骤来处理每个测试用例：计算 $S$ 和 $C$；计算 $N_{\\text{on}}$、$N_{\\text{off}}$ 和 $D$；执行调度算法以确定脉冲分布和 $N_{\\text{sched}}$；最后，根据调度计算 $R$ 和 $M$。然后报告每个用例的最终结果 $C$（整数）、$R$（保留3位小数的小数）和 $M$（保留3位小数的小数）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the result.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Note: Nx and w are not used in the provided model equations.\n    test_cases = [\n        # Case A (happy path)\n        {'f_c': 60, 'E': 500, 'L_ms': 10, 'tau_e_ms': 4, 'N_y': 64, 'v': 240},\n        # Case B (latency-limited boundary)\n        {'f_c': 60, 'E': 500, 'L_ms': 5, 'tau_e_ms': 4, 'N_y': 64, 'v': 600},\n        # Case C (demand-dominated with coarser temporal slots)\n        {'f_c': 60, 'E': 500, 'L_ms': 10, 'tau_e_ms': 8, 'N_y': 128, 'v': 480},\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        # Unpack parameters for the current case\n        f_c = case['f_c']\n        E = case['E']\n        L_ms = case['L_ms']\n        tau_e_ms = case['tau_e_ms']\n        N_y = case['N_y']\n        v = case['v']\n\n        # 1. Convert units and calculate primary parameters\n        L_s = L_ms / 1000.0\n        tau_e_s = tau_e_ms / 1000.0\n        T_c = 1.0 / f_c\n\n        # Number of time slots S\n        S = int(np.ceil(L_s / tau_e_s))\n        \n        # Total per-frame capacity C\n        C = E * S\n\n        # 2. Demand Calculation\n        demand_per_edge = N_y * v * T_c\n        # Using int(x + 0.5) for deterministic rounding (round half up)\n        N_on = int(demand_per_edge + 0.5)\n        N_off = int(demand_per_edge + 0.5)\n        D = N_on + N_off\n\n        # 3. Scheduling Algorithm\n        slot_capacity = np.full(S, E, dtype=int)\n        on_pulses_per_slot = np.zeros(S, dtype=int)\n        off_pulses_per_slot = np.zeros(S, dtype=int)\n\n        # Schedule ON events (earliest to latest slots)\n        on_events_to_schedule = N_on\n        for k in range(S):\n            if on_events_to_schedule == 0:\n                break\n            pulses_to_add = min(on_events_to_schedule, slot_capacity[k])\n            on_pulses_per_slot[k] = pulses_to_add\n            slot_capacity[k] -= pulses_to_add\n            on_events_to_schedule -= pulses_to_add\n\n        # Schedule OFF events (latest to earliest slots)\n        off_events_to_schedule = N_off\n        for k in range(S - 1, -1, -1):\n            if off_events_to_schedule == 0:\n                break\n            pulses_to_add = min(off_events_to_schedule, slot_capacity[k])\n            off_pulses_per_slot[k] = pulses_to_add\n            slot_capacity[k] -= pulses_to_add\n            off_events_to_schedule -= pulses_to_add\n            \n        # 4. Calculate Metrics\n        N_on_sched = np.sum(on_pulses_per_slot)\n        N_off_sched = np.sum(off_pulses_per_slot)\n        N_sched = N_on_sched + N_off_sched\n\n        # Mapping Ratio R\n        R = N_sched / D if D  0 else 0.0\n        \n        # Motion-cue Score M\n        if N_on_sched == 0 or N_off_sched == 0:\n            M = 0.0\n        else:\n            slot_indices = np.arange(S)\n            \n            # Mean time for ON pulses: sum(n_k * k * tau_e) / sum(n_k)\n            t_on_mean_numerator = np.sum(on_pulses_per_slot * slot_indices) * tau_e_s\n            t_on_mean = t_on_mean_numerator / N_on_sched\n\n            # Mean time for OFF pulses\n            t_off_mean_numerator = np.sum(off_pulses_per_slot * slot_indices) * tau_e_s\n            t_off_mean = t_off_mean_numerator / N_off_sched\n\n            # Raw M score, before clamping\n            if L_s  0:\n                M_raw = (t_off_mean - t_on_mean) / L_s\n            else: # Avoid division by zero if L is zero\n                M_raw = 0.0\n\n            M = max(0.0, min(1.0, M_raw))\n\n        # Format the result list as a string with no spaces and 3 decimal places for R and M\n        result_str = f\"[{C},{R:.3f},{M:.3f}]\"\n        results_as_strings.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}