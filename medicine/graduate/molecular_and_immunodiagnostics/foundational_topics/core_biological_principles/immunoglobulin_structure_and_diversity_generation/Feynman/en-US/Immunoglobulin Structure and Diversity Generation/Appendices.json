{
    "hands_on_practices": [
        {
            "introduction": "The immense diversity of the antibody repertoire begins with a clever genetic strategy: combining a limited set of gene segments in numerous ways. This exercise provides a foundational calculation of this \"combinatorial diversity\" by applying basic counting principles to the V(D)J recombination process. By working through this problem, you will gain a quantitative appreciation for the vast number of unique antibodies that can be generated even before other diversification mechanisms are considered. ",
            "id": "5123138",
            "problem": "In immunoglobulin (Ig) gene assembly, B lymphocytes generate antigen receptor diversity by somatic recombination of germline gene segments. For the heavy chain locus, Variable ($V$), Diversity ($D$), and Joining ($J$) gene segments recombine to form a heavy-chain variable region; for each light chain locus, only Variable ($V$) and Joining ($J$) segments recombine to form a light-chain variable region. Consider the following foundational facts:\n\n- Somatic recombination is mediated by Recombination Activating Gene (RAG) proteins and respects recombination signal sequences, producing distinct segment choice combinations at the DNA level.\n- Combinatorial diversity, in this context, refers to the total number of distinct segment-choice tuples that can be formed from the available functional gene segments, without accounting for junctional diversification (for example, nucleotide addition or deletion) or any form of selection.\n- An expressed Ig is formed by pairing one recombined heavy chain with one recombined light chain, with the light chain being either kappa ($\\kappa$) or lambda ($\\lambda$). Assume that heavy–light pairing is independent of the particular $V$, $D$, and $J$ choices, and that segment choice does not constrain subsequent pairing.\n\nYou are provided counts of functional gene segments in a species with the following germline configuration:\n\n- Heavy chain locus: $V_{H} = 44$, $D_{H} = 23$, $J_{H} = 6$.\n- Kappa light chain locus: $V_{\\kappa} = 34$, $J_{\\kappa} = 5$.\n- Lambda light chain locus: $V_{\\lambda} = 30$, $J_{\\lambda} = 7$.\n\nUnder the assumptions above and defining combinatorial diversity strictly as the number of distinct heavy–light pairs determined solely by segment choice, compute the total number of possible Ig specificities that can be formed in this system. Provide your final answer as an exact integer with no units.",
            "solution": "The problem statement has been critically reviewed and is determined to be valid. It is scientifically grounded in the principles of molecular immunology, specifically the mechanism of V(D)J recombination for generating immunoglobulin diversity. The problem is well-posed, providing all necessary data and clearly defined constraints to compute a unique, meaningful solution. It is objective and free of any unsound or ambiguous premises.\n\nThe calculation of combinatorial diversity relies on the fundamental counting principle (the product rule) for independent events and the sum rule for mutually exclusive events. The total number of possible immunoglobulin specificities, denoted as $N_{\\text{Ig}}$, is the product of the number of distinct heavy chains ($N_{H}$) and the total number of distinct light chains ($N_{L}$).\n\n$N_{\\text{Ig}} = N_{H} \\times N_{L}$\n\nFirst, we calculate the number of possible heavy chains, $N_{H}$. A heavy chain variable region is formed by the recombination of one Variable ($V_{H}$), one Diversity ($D_{H}$), and one Joining ($J_{H}$) gene segment. The choices for each segment are independent. The number of available functional gene segments are given as:\n- $V_{H} = 44$\n- $D_{H} = 23$\n- $J_{H} = 6$\n\nUsing the product rule, the total number of distinct heavy chains is:\n$$N_{H} = V_{H} \\times D_{H} \\times J_{H}$$\n$$N_{H} = 44 \\times 23 \\times 6$$\n$$N_{H} = 1012 \\times 6 = 6072$$\nThus, there are $6072$ possible heavy chain combinations.\n\nNext, we calculate the total number of possible light chains, $N_{L}$. An immunoglobulin can have either a kappa ($\\kappa$) light chain or a lambda ($\\lambda$) light chain. These are mutually exclusive possibilities, so we calculate the number of combinations for each locus and then sum them.\n\nFor the kappa ($\\kappa$) light chain locus, the variable region is formed by one $V_{\\kappa}$ and one $J_{\\kappa}$ segment. The number of available segments are:\n- $V_{\\kappa} = 34$\n- $J_{\\kappa} = 5$\n\nThe number of distinct kappa light chains, $N_{\\kappa}$, is:\n$$N_{\\kappa} = V_{\\kappa} \\times J_{\\kappa}$$\n$$N_{\\kappa} = 34 \\times 5 = 170$$\n\nFor the lambda ($\\lambda$) light chain locus, the variable region is formed by one $V_{\\lambda}$ and one $J_{\\lambda}$ segment. The number of available segments are:\n- $V_{\\lambda} = 30$\n- $J_{\\lambda} = 7$\n\nThe number of distinct lambda light chains, $N_{\\lambda}$, is:\n$$N_{\\lambda} = V_{\\lambda} \\times J_{\\lambda}$$\n$$N_{\\lambda} = 30 \\times 7 = 210$$\n\nThe total number of possible light chains, $N_{L}$, is the sum of the possibilities for the kappa and lambda loci:\n$$N_{L} = N_{\\kappa} + N_{\\lambda}$$\n$$N_{L} = 170 + 210 = 380$$\nThus, there are $380$ possible light chain combinations.\n\nFinally, we calculate the total number of possible immunoglobulin specificities, $N_{\\text{Ig}}$, by multiplying the number of possible heavy chains by the number of possible light chains. This is justified by the problem statement's assumption that heavy–light pairing is independent of the specific segments chosen.\n$$N_{\\text{Ig}} = N_{H} \\times N_{L}$$\n$$N_{\\text{Ig}} = 6072 \\times 380$$\n$$N_{\\text{Ig}} = 2307360$$\n\nThis final number represents the combinatorial diversity generated solely by the different combinations of germline gene segments, as specified by the problem.",
            "answer": "$$\\boxed{2307360}$$"
        },
        {
            "introduction": "While combinatorial joining creates a large number of potential antibodies, much of the critical hypervariability, especially in the antigen-binding site, comes from junctional diversity. This practice introduces Shannon entropy, a concept from information theory, as a powerful method to quantify the diversity contributed by non-templated nucleotide additions from the enzyme TdT. Calculating the entropy gain allows you to measure the profound impact of this mechanism on the complexity of the antibody repertoire. ",
            "id": "5123127",
            "problem": "A naive B cell immunoglobulin (Ig) heavy chain repertoire acquires non-templated nucleotide additions (N additions) during recombination by Terminal deoxynucleotidyl transferase (TdT). Consider only the insertion-length distributions at the two heavy-chain junctions—variable to diversity (V–D) and diversity to joining (D–J)—and ignore nucleotide composition. Assume the insertion lengths at V–D and D–J are independent random variables. The diversity contributed by the distribution of insertion lengths is quantified by the Shannon entropy, defined for a discrete distribution $p$ over outcomes $i$ as $H(p)=-\\sum_{i} p_{i}\\ln p_{i}$, where $\\ln$ denotes the natural logarithm and the entropy is measured in nats.\n\nYou are provided empirically estimated insertion-length distributions for normal TdT activity and for a TdT-deficient (knockout) background. Let $L\\in\\{0,1,2,3,4,5,6\\}$ be the insertion length (in nucleotides). For normal TdT activity:\n- V–D junction: $p_{VD}(0)=0.05$, $p_{VD}(1)=0.10$, $p_{VD}(2)=0.20$, $p_{VD}(3)=0.25$, $p_{VD}(4)=0.20$, $p_{VD}(5)=0.12$, $p_{VD}(6)=0.08$.\n- D–J junction: $p_{DJ}(0)=0.03$, $p_{DJ}(1)=0.08$, $p_{DJ}(2)=0.17$, $p_{DJ}(3)=0.24$, $p_{DJ}(4)=0.22$, $p_{DJ}(5)=0.16$, $p_{DJ}(6)=0.10$.\n\nFor TdT-deficient background:\n- V–D junction: $p^{\\mathrm{KO}}_{VD}(0)=0.85$, $p^{\\mathrm{KO}}_{VD}(1)=0.10$, $p^{\\mathrm{KO}}_{VD}(2)=0.03$, $p^{\\mathrm{KO}}_{VD}(3)=0.01$, $p^{\\mathrm{KO}}_{VD}(4)=0.005$, $p^{\\mathrm{KO}}_{VD}(5)=0.003$, $p^{\\mathrm{KO}}_{VD}(6)=0.002$.\n- D–J junction: $p^{\\mathrm{KO}}_{DJ}(0)=0.80$, $p^{\\mathrm{KO}}_{DJ}(1)=0.12$, $p^{\\mathrm{KO}}_{DJ}(2)=0.05$, $p^{\\mathrm{KO}}_{DJ}(3)=0.015$, $p^{\\mathrm{KO}}_{DJ}(4)=0.007$, $p^{\\mathrm{KO}}_{DJ}(5)=0.004$, $p^{\\mathrm{KO}}_{DJ}(6)=0.004$.\n\nUsing the Shannon entropy $H(p)=-\\sum_{i} p_{i}\\ln p_{i}$ and the additivity of entropy for independent variables, compute the total insertion-length entropy for normal TdT activity, $H_{\\mathrm{normal}}=H(p_{VD})+H(p_{DJ})$, and for TdT-deficient background, $H_{\\mathrm{KO}}=H(p^{\\mathrm{KO}}_{VD})+H(p^{\\mathrm{KO}}_{DJ})$. Then compute the entropy gain attributable to TdT-mediated N additions, defined as $\\Delta H = H_{\\mathrm{normal}} - H_{\\mathrm{KO}}$.\n\nRound your final numerical value of $\\Delta H$ to four significant figures. Express the final entropy gain in nats.",
            "solution": "The problem has been validated and is deemed sound. It is scientifically grounded in molecular immunology and information theory, well-posed with all necessary data and definitions provided, and internally consistent, as the probabilities for each distribution sum to $1$. There are no contradictions, ambiguities, or unrealistic assumptions that would invalidate the problem statement. We may now proceed with the solution.\n\nThe problem requires the calculation of the entropy gain due to N-nucleotide additions by Terminal deoxynucleotidyl transferase (TdT). This gain, denoted by $\\Delta H$, is the difference between the total insertion-length entropy in normal B cells ($H_{\\mathrm{normal}}$) and TdT-deficient B cells ($H_{\\mathrm{KO}}$).\n\nThe Shannon entropy for a discrete probability distribution $p$ over outcomes $i$ is given by:\n$$H(p) = -\\sum_{i} p_i \\ln(p_i)$$\nThe problem states that the insertion lengths at the V–D and D–J junctions are independent random variables. A fundamental property of Shannon entropy is its additivity for independent distributions. Therefore, the total entropy for the two junctions is the sum of their individual entropies.\n\nFor normal TdT activity, the total entropy is:\n$$H_{\\mathrm{normal}} = H(p_{VD}) + H(p_{DJ})$$\nFor the TdT-deficient background, the total entropy is:\n$$H_{\\mathrm{KO}} = H(p^{\\mathrm{KO}}_{VD}) + H(p^{\\mathrm{KO}}_{DJ})$$\nThe entropy gain attributable to TdT is then:\n$$\\Delta H = H_{\\mathrm{normal}} - H_{\\mathrm{KO}}$$\n\nWe will now calculate each of the four entropy components.\n\nFirst, let's calculate the entropies for the normal TdT activity case.\nFor the V–D junction, the distribution is $p_{VD}(L)$ for $L \\in \\{0, 1, 2, 3, 4, 5, 6\\}$.\n$H(p_{VD}) = - \\sum_{L=0}^{6} p_{VD}(L) \\ln(p_{VD}(L))$\n$H(p_{VD}) = - [0.05 \\ln(0.05) + 0.10 \\ln(0.10) + 0.20 \\ln(0.20) + 0.25 \\ln(0.25) + 0.20 \\ln(0.20) + 0.12 \\ln(0.12) + 0.08 \\ln(0.08)]$\n$H(p_{VD}) \\approx - [-0.149787 - 0.230259 - 0.321888 - 0.346574 - 0.321888 - 0.254432 - 0.202058]$\n$H(p_{VD}) \\approx 1.826886$ nats.\n\nFor the D–J junction, the distribution is $p_{DJ}(L)$.\n$H(p_{DJ}) = - \\sum_{L=0}^{6} p_{DJ}(L) \\ln(p_{DJ}(L))$\n$H(p_{DJ}) = - [0.03 \\ln(0.03) + 0.08 \\ln(0.08) + 0.17 \\ln(0.17) + 0.24 \\ln(0.24) + 0.22 \\ln(0.22) + 0.16 \\ln(0.16) + 0.10 \\ln(0.10)]$\n$H(p_{DJ}) \\approx - [-0.105197 - 0.202058 - 0.301233 - 0.342509 - 0.333108 - 0.293213 - 0.230259]$\n$H(p_{DJ}) \\approx 1.807577$ nats.\n\nThe total entropy for normal TdT activity is:\n$H_{\\mathrm{normal}} = H(p_{VD}) + H(p_{DJ}) \\approx 1.826886 + 1.807577 = 3.634463$ nats.\n\nNext, we calculate the entropies for the TdT-deficient (knockout) case.\nFor the V–D junction, the distribution is $p^{\\mathrm{KO}}_{VD}(L)$.\n$H(p^{\\mathrm{KO}}_{VD}) = - \\sum_{L=0}^{6} p^{\\mathrm{KO}}_{VD}(L) \\ln(p^{\\mathrm{KO}}_{VD}(L))$\n$H(p^{\\mathrm{KO}}_{VD}) = - [0.85 \\ln(0.85) + 0.10 \\ln(0.10) + 0.03 \\ln(0.03) + 0.01 \\ln(0.01) + 0.005 \\ln(0.005) + 0.003 \\ln(0.003) + 0.002 \\ln(0.002)]$\n$H(p^{\\mathrm{KO}}_{VD}) \\approx - [-0.138141 - 0.230259 - 0.105197 - 0.046052 - 0.026492 - 0.017427 - 0.012429]$\n$H(p^{\\mathrm{KO}}_{VD}) \\approx 0.575997$ nats.\n\nFor the D–J junction, the distribution is $p^{\\mathrm{KO}}_{DJ}(L)$.\n$H(p^{\\mathrm{KO}}_{DJ}) = - \\sum_{L=0}^{6} p^{\\mathrm{KO}}_{DJ}(L) \\ln(p^{\\mathrm{KO}}_{DJ}(L))$\n$H(p^{\\mathrm{KO}}_{DJ}) = - [0.80 \\ln(0.80) + 0.12 \\ln(0.12) + 0.05 \\ln(0.05) + 0.015 \\ln(0.015) + 0.007 \\ln(0.007) + 0.004 \\ln(0.004) + 0.004 \\ln(0.004)]$\n$H(p^{\\mathrm{KO}}_{DJ}) \\approx - [-0.178515 - 0.254432 - 0.149787 - 0.062996 - 0.034733 - 0.022086 - 0.022086]$\n$H(p^{\\mathrm{KO}}_{DJ}) \\approx 0.724635$ nats.\n\nThe total entropy for the TdT-deficient background is:\n$H_{\\mathrm{KO}} = H(p^{\\mathrm{KO}}_{VD}) + H(p^{\\mathrm{KO}}_{DJ}) \\approx 0.575997 + 0.724635 = 1.300632$ nats.\n\nFinally, we compute the entropy gain $\\Delta H$:\n$\\Delta H = H_{\\mathrm{normal}} - H_{\\mathrm{KO}} \\approx 3.634463 - 1.300632 = 2.333831$ nats.\n\nThe problem requires rounding the final value to four significant figures.\n$\\Delta H \\approx 2.334$ nats.\nThis positive value represents the significant increase in junctional length diversity contributed by the action of TdT.",
            "answer": "$$\\boxed{2.334}$$"
        },
        {
            "introduction": "The genetic events of V(D)J recombination and junctional diversification have a direct structural consequence: the formation of hypervariable Complementarity-Determining Regions (CDRs) in the final antibody protein. This hands-on bioinformatics exercise challenges you to translate standardized IMGT rules into a working algorithm to identify these critical regions, particularly the highly variable CDR3. This practice bridges the gap between abstract genetic concepts and the tangible protein sequences analyzed in immunodiagnostics and antibody engineering. ",
            "id": "5123111",
            "problem": "You are given amino acid sequences representing the variable domains of Immunoglobulin (Ig) heavy chain (VH) and light chain (VL). Based on International ImMunoGeneTics (IMGT) information system definitions, annotate Complementarity-Determining Regions (CDRs) for CDR1–CDR3 in both heavy and light chains, and compute the heavy chain CDR3 length distribution across a fixed test suite. The task must be solved without external alignment by relying on conserved motif anchors and canonical IMGT region boundaries.\n\nFundamental base and core definitions to use:\n- The Central Dogma of molecular biology connects DNA to RNA to protein, and immunoglobulin diversity arises from V(D)J recombination and junctional diversity in the variable domain. The variable domain of antibodies is organized into Framework Regions (FRs) and Complementarity-Determining Regions (CDRs), with CDRs being hypervariable loops that interact with antigen. IMGT numbering provides a standardized positional system for these regions based on conserved residues.\n- In the Ig variable domain using IMGT numbering, there are conserved residues and motifs that define boundaries:\n  - A conserved cysteine in FR1 at position $23$ and a conserved cysteine in FR3 at position $104$ in the heavy and light chains.\n  - The beginning of the joining (J) segment is marked by a motif $M$ of the form $($W or F$)$–G–X–G, written as $WGXG$ or $FGXG$, where $X$ is any amino acid. For heavy chain J segments, $W$ is typical but $F$ can occur; for light chain J segments, $F$ is typical.\n- In the IMGT variable domain, canonical boundaries are:\n  - CDR1: positions $27$ to $38$ inclusive.\n  - CDR2: positions $56$ to $65$ inclusive.\n  - FR3: positions $66$ to $104$ inclusive.\n  - CDR3 begins immediately after the last conserved cysteine in FR3 (that is, after position $104$ if present) and ends immediately before the first occurrence of the J motif anchor $M$. To make this computable without alignment, use the following robust anchors:\n    - CDR3 start for both heavy and light chains: the residue immediately after the last $C$ found in the window $[90,106]$ (inclusive). If no $C$ is found in that window, treat the CDR3 length as $0$.\n    - CDR3 end for heavy chain: the first index $i$ in the window $[105, \\min(n-3, 140)]$ (inclusive) where $S[i] \\in \\{W, F\\}$ and $S[i+1] = G$ and $S[i+3] = G$. For light chain: the first index $i$ in the same window where $S[i] = F$, $S[i+1] = G$, and $S[i+3] = G$. If no motif is found, treat the CDR3 length as $0$.\n    - Heavy chain CDR3 length is $L_H = \\max(0, i - (j+1))$ where $j$ is the index of the last $C$ in $[90,106]$, and $i$ is the motif anchor index; similarly for light chain $L_L$ with its anchor constraint.\n- For CDR1 and CDR2, if the sequence length $n$ is insufficient to cover the endpoints, treat the respective CDR length as $0$. Otherwise, the lengths are $L_{H,1} = 38 - 27 + 1 = 12$ and $L_{H,2} = 65 - 56 + 1 = 10$ for heavy chain; the same fixed boundaries apply for light chain $L_{L,1} = 12$ and $L_{L,2} = 10$.\n\nAlgorithmic requirements:\n- Represent each sequence as a string of uppercase one-letter amino acid codes; positions are $1$-based in IMGT numbering. When computing indices in code, use $0$-based indexing internally but adhere to the defined $1$-based rules for boundaries and windows.\n- Implement a function to compute for a given sequence $S$ and chain type (\"H\" or \"L\"):\n  - $L_{1}$: length of CDR1 using the fixed interval $[27,38]$ when the sequence covers it, else $0$.\n  - $L_{2}$: length of CDR2 using the fixed interval $[56,65]$ when the sequence covers it, else $0$.\n  - $L_{3}$: length of CDR3 using the anchor rules above; return $0$ if anchors are missing or inconsistent.\n\nTest suite:\nProvide the following VH/VL pairs, each sequence length $n$ and specified residues at certain positions. All unspecified positions are arbitrary valid amino acids (use $A$ for simplicity). Positions below are $1$-based:\n\n- Case $1$ (happy path, heavy $WGQG$ motif far from $C$):\n  - Heavy: $n=130$, set $S[23]=C$, $S[104]=C$, $S[125]=W$, $S[126]=G$, $S[127]=Q$, $S[128]=G$.\n  - Light: $n=130$, set $S[23]=C$, $S[104]=C$, $S[124]=F$, $S[125]=G$, $S[126]=P$, $S[127]=G$.\n- Case $2$ (short heavy CDR3, motif near start):\n  - Heavy: $n=112$, set $S[23]=C$, $S[104]=C$, $S[108]=W$, $S[109]=G$, $S[110]=A$, $S[111]=G$.\n  - Light: $n=112$, set $S[23]=C$, $S[104]=C$, $S[109]=F$, $S[110]=G$, $S[111]=S$, $S[112]=G$.\n- Case $3$ (heavy missing motif, light motif present):\n  - Heavy: $n=125$, set $S[23]=C$, $S[104]=C$, $S[120]=W$, $S[121]=A$, $S[122]=A$, $S[123]=A$.\n  - Light: $n=125$, set $S[23]=C$, $S[104]=C$, $S[120]=F$, $S[121]=G$, $S[122]=D$, $S[123]=G$.\n- Case $4$ (heavy missing $C$ anchor in FR3 window, motif present):\n  - Heavy: $n=130$, set $S[23]=C$, $S[123]=W$, $S[124]=G$, $S[125]=Q$, $S[126]=G$; ensure no $C$ in positions $[90,106]$.\n  - Light: $n=130$, set $S[23]=C$, $S[104]=C$, $S[122]=F$, $S[123]=G$, $S[124]=P$, $S[125]=G$.\n- Case $5$ (heavy $FGXG$ motif instead of $W$, both anchors present):\n  - Heavy: $n=130$, set $S[23]=C$, $S[104]=C$, $S[123]=F$, $S[124]=G$, $S[125]=P$, $S[126]=G$.\n  - Light: $n=130$, set $S[23]=C$, $S[104]=C$, $S[125]=F$, $S[126]=G$, $S[127]=Q$, $S[128]=G$.\n- Case $6$ (boundary: sequences too short to cover CDR1/CDR2 windows or anchors):\n  - Heavy: $n=60$, no modifications.\n  - Light: $n=60$, no modifications.\n\nYour program must:\n- For each case, compute a list with the six integers $[L_{H,1}, L_{H,2}, L_{H,3}, L_{L,1}, L_{L,2}, L_{L,3}]$.\n- Compute the heavy chain CDR3 length distribution across all cases as two lists: the sorted unique heavy CDR3 lengths and the corresponding counts in the same order.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the first $6$ entries are the six-element lists per test case in order, followed by the two distribution lists. For example: $[[h1],[h2],\\dots,[h6],[unique\\_lengths],[counts]]$ where each $hk$ is the per-case six-integer list.\n\nAll outputs must be pure integers or lists of integers. No strings or additional text should be printed. There are no physical units in this problem, and angles are not applicable.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of immunoinformatics, well-posed with clear and unambiguous rules, and objective in its formulation. The problem provides a deterministic algorithm for annotating Complementarity-Determining Regions (CDRs) of immunoglobulin variable domains based on conserved sequence anchors, which is a simplified but conceptually sound approach used in bioinformatics. All definitions, constraints, and edge cases are explicitly provided, enabling the development of a unique and verifiable solution.\n\nThe solution proceeds by first implementing a function to calculate the lengths of CDR1, CDR2, and CDR3 for a given amino acid sequence and chain type (heavy or light). This function adheres strictly to the rules provided in the problem statement, including fixed boundaries for CDR1 and CDR2, and an anchor-based method for CDR3. A second helper function is used to generate the test sequences based on the specified parameters for each case. The main program then iterates through the defined test suite, calculates the six required CDR lengths ($L_{H,1}, L_{H,2}, L_{H,3}, L_{L,1}, L_{L,2}, L_{L,3}$) for each pair of heavy and light chains, and collates these results. Finally, it computes the statistical distribution (unique sorted lengths and their corresponding frequencies) of the heavy chain CDR3 lengths across all test cases.\n\nThe implementation details are as follows:\n\n**1. CDR Length Calculation (`get_cdr_lengths`)**\n\nThis function takes an amino acid sequence $S$ (as a string) and a chain type ('H' or 'L') as input.\n\n- **Sequence Length**: The length of the sequence, $n$, is determined.\n- **CDR1 Length ($L_1$)**: The canonical IMGT region for CDR1 is positions $27-38$. This corresponds to $0$-based indices $26-37$. The length is fixed at $12$. If the sequence length $n$ is less than $38$, the region is incomplete, and its length is set to $0$. Otherwise, $L_1 = 38 - 27 + 1 = 12$.\n- **CDR2 Length ($L_2$)**: The canonical region for CDR2 is positions $56-65$ (indices $55-64$). The length is fixed at $10$. If $n$ is less than $65$, the length is $0$. Otherwise, $L_2 = 65 - 56 + 1 = 10$.\n- **CDR3 Length ($L_3$)**: The length of CDR3 is determined by two anchors: a conserved Cysteine (C) residue near the end of framework region 3 (FR3) and a J-region motif.\n    - **C-anchor (Start)**: The algorithm searches for the last occurrence of 'C' within the $1$-based position window $[90, 106]$ ( $0$-based indices $[89, 105]$). The search is performed backwards from $\\min(n-1, 105)$ down to $89$. If no 'C' is found in this window, the CDR3 length $L_3$ is defined as $0$, and the process for CDR3 terminates. Let the $0$-based index of this Cysteine be $j$.\n    - **J-motif anchor (End)**: The algorithm searches for the first occurrence of a specific motif. The search window is $1$-based positions $[105, \\min(n-3, 140)]$, which translates to $0$-based indices from $104$ to $\\min(n-4, 139)$.\n        - For a heavy chain ('H'), the motif is $(W \\text{ or } F)GXG$. The code checks if $S[i] \\in \\{'W', 'F'\\}$, $S[i+1] == 'G'$, and $S[i+3] == 'G'$.\n        - For a light chain ('L'), the motif is $FGXG$. The code checks if $S[i] == 'F'$, $S[i+1] == 'G'$, and $S[i+3] == 'G'$.\n    If the motif is not found, $L_3$ is defined as $0$. Let the $0$-based index of the start of this motif be $i$.\n    - **Length Calculation**: If both anchors are found, the length is computed as $L_3 = \\max(0, i - (j+1))$. This formula correctly counts the number of amino acid residues between the C-anchor and the J-motif anchor.\n\n**2. Test Case Generation and Execution**\n\n- A helper function, `generate_sequence`, constructs the amino acid sequences for each test case. It initializes a sequence of a given length $n$ with a default amino acid ('A') and then overwrites specific positions with the residues provided in the test case specifications.\n- The main `solve` function defines the parameters for all six test cases. It iterates through them, generates the heavy and light chain sequences, and calls `get_cdr_lengths` for each.\n- The resulting six-element integer list $[L_{H,1}, L_{H,2}, L_{H,3}, L_{L,1}, L_{L,2}, L_{L,3}]$ is stored for each case. The calculated heavy chain CDR3 length, $L_{H,3}$, is also collected for the final distribution analysis.\n\n**3. Heavy Chain CDR3 Distribution**\n\n- After processing all test cases, the collected list of $L_{H,3}$ values is analyzed using `numpy.unique` with the `return_counts=True` option. This efficiently finds the unique length values, sorts them in ascending order, and provides their corresponding frequencies.\n- The resulting NumPy arrays are converted to Python lists to match the required output format.\n\n**4. Final Output Formatting**\n\n- The final output is assembled into a list containing the result lists for each of the six test cases, followed by the two lists representing the CDR3 length distribution (unique lengths and counts). This composite list is then converted to the required string format, ensuring that each sub-list is represented correctly.\n\nThis systematic approach ensures that all rules and edge cases from the problem statement are handled correctly, leading to a verifiable and accurate final result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the immunoglobulin CDR annotation problem.\n    \"\"\"\n\n    def generate_sequence(n, modifications, no_c_in_fr3=False):\n        \"\"\"\n        Generates a test sequence with specified modifications.\n        1-based positions are used for modifications keys.\n        \"\"\"\n        seq = ['A'] * n\n        for pos, aa in modifications.items():\n            if 1 <= pos <= n:\n                # Handle the special case for Case 4 Heavy Chain\n                if no_c_in_fr3 and 90 <= pos <= 106 and aa == 'C':\n                    continue\n                seq[pos - 1] = aa\n        return \"\".join(seq)\n\n    def get_cdr_lengths(S, chain_type):\n        \"\"\"\n        Computes CDR lengths for a given sequence and chain type.\n        Positions are 1-based in IMGT, so indices are position-1.\n        \"\"\"\n        n = len(S)\n        \n        # CDR1 Length (Positions 27-38)\n        L1 = 12 if n >= 38 else 0\n        \n        # CDR2 Length (Positions 56-65)\n        L2 = 10 if n >= 65 else 0\n\n        # CDR3 Length (Anchor-based)\n        L3 = 0\n\n        # Find C-anchor (start of CDR3): Last 'C' in positions [90, 106]\n        c_anchor_idx = -1\n        # Window in 0-based indices: [89, 105]\n        start_search_c = min(n - 1, 105)\n        end_search_c = 89\n        if start_search_c >= end_search_c:\n            for j in range(start_search_c, end_search_c - 1, -1):\n                if S[j] == 'C':\n                    c_anchor_idx = j\n                    break\n        \n        if c_anchor_idx == -1:\n            return [L1, L2, 0]\n\n        # Find J-motif anchor (end of CDR3)\n        motif_anchor_idx = -1\n        # Window in 1-based positions: [105, min(n-3, 140)]\n        # Window in 0-based indices: [104, min(n-4, 139)]\n        start_search_motif = 104\n        end_search_motif = min(n - 4, 139)\n        \n        if start_search_motif <= end_search_motif:\n            for i in range(start_search_motif, end_search_motif + 1):\n                motif_found = False\n                if chain_type == 'H':\n                    if (S[i] == 'W' or S[i] == 'F') and S[i+1] == 'G' and S[i+3] == 'G':\n                        motif_found = True\n                elif chain_type == 'L':\n                    if S[i] == 'F' and S[i+1] == 'G' and S[i+3] == 'G':\n                        motif_found = True\n                \n                if motif_found:\n                    motif_anchor_idx = i\n                    break\n        \n        if motif_anchor_idx != -1:\n            # Length is the number of residues between C and the motif start\n            # CDR3 sequence is S[c_anchor_idx + 1: motif_anchor_idx]\n            length = motif_anchor_idx - (c_anchor_idx + 1)\n            L3 = max(0, length)\n            \n        return [L1, L2, L3]\n\n    test_cases = [\n        # Case 1\n        {'H': {'n': 130, 'mods': {23: 'C', 104: 'C', 125: 'W', 126: 'G', 127: 'Q', 128: 'G'}},\n         'L': {'n': 130, 'mods': {23: 'C', 104: 'C', 124: 'F', 125: 'G', 126: 'P', 127: 'G'}}},\n        # Case 2\n        {'H': {'n': 112, 'mods': {23: 'C', 104: 'C', 108: 'W', 109: 'G', 110: 'A', 111: 'G'}},\n         'L': {'n': 112, 'mods': {23: 'C', 104: 'C', 109: 'F', 110: 'G', 111: 'S', 112: 'G'}}},\n        # Case 3\n        {'H': {'n': 125, 'mods': {23: 'C', 104: 'C', 120: 'W', 121: 'A', 122: 'A', 123: 'A'}},\n         'L': {'n': 125, 'mods': {23: 'C', 104: 'C', 120: 'F', 121: 'G', 122: 'D', 123: 'G'}}},\n        # Case 4\n        {'H': {'n': 130, 'mods': {23: 'C', 123: 'W', 124: 'G', 125: 'Q', 126: 'G'}, 'no_c_fr3': True},\n         'L': {'n': 130, 'mods': {23: 'C', 104: 'C', 122: 'F', 123: 'G', 124: 'P', 125: 'G'}}},\n        # Case 5\n        {'H': {'n': 130, 'mods': {23: 'C', 104: 'C', 123: 'F', 124: 'G', 125: 'P', 126: 'G'}},\n         'L': {'n': 130, 'mods': {23: 'C', 104: 'C', 125: 'F', 126: 'G', 127: 'Q', 128: 'G'}}},\n        # Case 6\n        {'H': {'n': 60, 'mods': {}},\n         'L': {'n': 60, 'mods': {}}},\n    ]\n    \n    all_results = []\n    heavy_cdr3_lengths = []\n\n    for case_data in test_cases:\n        h_data = case_data['H']\n        l_data = case_data['L']\n        \n        heavy_seq = generate_sequence(h_data['n'], h_data['mods'], h_data.get('no_c_fr3', False))\n        light_seq = generate_sequence(l_data['n'], l_data['mods'])\n        \n        lh_list = get_cdr_lengths(heavy_seq, 'H')\n        ll_list = get_cdr_lengths(light_seq, 'L')\n        \n        heavy_cdr3_lengths.append(lh_list[2])\n        case_result = lh_list + ll_list\n        all_results.append(case_result)\n\n    # Compute heavy chain CDR3 length distribution\n    unique_lengths, counts = np.unique(heavy_cdr3_lengths, return_counts=True)\n    \n    unique_lengths_list = unique_lengths.tolist()\n    counts_list = counts.tolist()\n    \n    final_output_list = all_results + [unique_lengths_list, counts_list]\n    \n    # Format the final output string as specified.\n    # str(list) automatically creates the '[...]' format.\n    # We join these string representations with commas and wrap in outer brackets.\n    output_str = f\"[{','.join(map(str, final_output_list))}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}