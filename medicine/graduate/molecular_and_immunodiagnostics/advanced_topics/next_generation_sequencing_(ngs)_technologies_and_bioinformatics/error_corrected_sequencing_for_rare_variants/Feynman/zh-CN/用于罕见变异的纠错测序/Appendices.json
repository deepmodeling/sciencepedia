{
    "hands_on_practices": [
        {
            "introduction": "纠错测序的核心在于利用来自同一原始分子的多个测序读数来构建一个共识序列，从而有效抑制随机测序错误。这个练习将带你从第一性原理出发，通过一个简化的多数投票模型，定量地理解这一过程如何显著降低错误率。通过该实践，你将掌握使用二项分布来量化基于UMI的纠错效果的基础方法。",
            "id": "5113757",
            "problem": "在用于分子诊断和免疫诊断中稀有变异检测的纠错测序中，唯一分子标识符 (UMI) 用于在新一代测序 (NGS) 的扩增和测序之前标记原始模板分子。考虑一个源自单个真实模板碱基的 UMI 家族，并假设该家族的 $k$ 个读数中的每一个都独立同分布地报告碱基，每个读数的碱基替换错误概率为 $p$，且没有其他错误模式起作用。该家族的一致性碱基通过对 $k$ 个读数进行简单多数投票的规则来确定。假设 $k$ 为奇数，因此不会出现平局。在这些假设下，从独立伯努利试验和二项分布的定义出发，推导一致性碱基不正确的概率关于 $k$ 和 $p$ 的函数解析表达式。\n\n然后，对于 UMI 家族大小为 $k=7$ 且每个读数的错误概率为 $p=0.01$ 的情况，评估一致性错误概率。将最终数值答案四舍五入至四位有效数字。提供最终答案时，应为一个不带任何单位的纯数字。",
            "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 步骤1：提取已知条件\n- 单个 UMI 家族源自一个真实的模板碱基。\n- 家族中有 $k$ 个读数。\n- 每个读数独立同分布地报告碱基。\n- 每个读数的碱基替换错误概率为 $p$。\n- 没有其他错误模式在起作用。\n- 一致性碱基通过简单多数投票确定。\n- $k$ 是一个奇数。\n- 需要从第一性原理推导一致性碱基不正确的概率的解析表达式。\n- 推导必须从独立伯努利试验和二项分布的定义开始。\n- 推导出的表达式必须在 $k=7$ 和 $p=0.01$ 的条件下进行评估。\n- 最终数值答案必须四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题具有科学依据。所描述的模型是分子诊断学和生物信息学中用于理解如何使用唯一分子标识符（UMI）进行纠错的一个标准且基础的简化模型。使用二项分布来模拟独立错误事件是该领域的一个核心概念。\n2.  **适定性**：该问题是适定的。所有必要的参数（$k$，$p$）和条件（独立同分布的读数，多数投票）都已明确定义。$k$ 为奇数的约束至关重要，因为它能防止多数投票中出现平局，从而确保总能确定一个唯一的一致性碱基。这导向一个唯一且可计算的概率。\n3.  **客观性**：该问题以客观、正式的语言陈述，不含主观或模棱两可的术语。\n4.  **完整性与一致性**：该问题是自洽且一致的。它提供了推导解析表达式和计算数值所需的所有信息。所提供的数据中没有矛盾。$k=7$ 和 $p=0.01$ 的值对于新一代测序应用是符合实际的。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。它在科学上是合理的、适定的，并且提供了所有必要的信息。现在开始进行求解。\n\n### 解析表达式的推导\n\n让我们将 $k$ 个读数中每一个的状态建模为一次伯努利试验。对于一个给定的读数，如果它报告的碱基与真实模板碱基不同，则结果为“错误”，否则为“正确”。问题陈述，碱基替换错误的概率为 $p$。因此，对于单次试验：\n- “错误”的概率为 $p$。\n- “正确”的概率为 $1-p$。\n\n我们有 $k$ 个这样的读数，规定它们是独立且同分布的。设 $X$ 为随机变量，表示在 $k$ 个读数中错误（不正确的读数）的总数。由于这些试验是独立的且具有相同的错误概率，因此 $X$ 服从参数为 $k$（试验次数）和 $p$（成功概率，即发生错误）的二项分布。我们记为 $X \\sim \\text{Binomial}(k, p)$。\n\n二项分布的概率质量函数（PMF）给出了在 $k$ 次试验中观察到恰好 $i$ 次错误的概率：\n$$\nP(X=i) = \\binom{k}{i} p^i (1-p)^{k-i}\n$$\n其中 $\\binom{k}{i} = \\frac{k!}{i!(k-i)!}$ 是二项式系数，表示从总共 $k$ 个读数中选择 $i$ 个包含错误的读数的方式数量。此公式对 $i = 0, 1, 2, \\dots, k$ 均有效。\n\nUMI 家族的一致性碱基是通过简单多数投票决定的。如果不正确读数的数量大于正确读数的数量，则会得出一个不正确的一致性碱基。设 $i$ 为带有错误的读数数量，则正确读数的数量为 $k-i$。因此，得出不正确一致性碱基的条件是：\n$$\ni > k-i\n$$\n$$\n2i > k\n$$\n$$\ni > \\frac{k}{2}\n$$\n问题指明 $k$ 是一个奇数。设 $k = 2m+1$，其中 $m$ 是某个非负整数。不正确一致性碱基的条件变为 $i > \\frac{2m+1}{2} = m + \\frac{1}{2}$。由于 $i$ 必须是整数，这等价于 $i \\ge m+1$。注意到 $m = \\frac{k-1}{2}$，因此得出不正确结果所需的最小错误数为 $i_{min} = m+1 = \\frac{k-1}{2} + 1 = \\frac{k+1}{2}$。\n\n不正确一致性碱基的概率，记为 $P_{\\text{error}}$，是错误数 $X$ 大于 $k/2$ 的概率。这是满足此条件的所有可能错误数（即 $i = \\frac{k+1}{2}, \\frac{k+1}{2}+1, \\dots, k$）的概率之和。\n因此，一致性错误概率的解析表达式为：\n$$\nP_{\\text{error}} = P\\left(X \\ge \\frac{k+1}{2}\\right) = \\sum_{i=\\frac{k+1}{2}}^{k} P(X=i)\n$$\n代入二项分布的 PMF，我们得到最终表达式：\n$$\nP_{\\text{error}}(k, p) = \\sum_{i=\\frac{k+1}{2}}^{k} \\binom{k}{i} p^i (1-p)^{k-i}\n$$\n至此，完成了从第一性原理的推导。\n\n### 针对特定参数的评估\n\n我们需要为 UMI 家族大小 $k=7$ 和每个读数的错误概率 $p=0.01$ 评估此概率。\n对于 $k=7$，得出不正确一致性碱基的最小错误数为 $\\frac{7+1}{2} = 4$。因此，如果出现 $4$、$5$、$6$ 或 $7$ 个错误，就会得出不正确的一致性碱基。我们必须计算 $P(X \\ge 4)$。\n\n该概率由以下和式给出：\n$$\nP_{\\text{error}} = P(X=4) + P(X=5) + P(X=6) + P(X=7)\n$$\n使用推导出的公式，其中 $k=7$，$p=0.01$，$1-p=0.99$：\n$$\nP_{\\text{error}} = \\sum_{i=4}^{7} \\binom{7}{i} (0.01)^i (0.99)^{7-i}\n$$\n我们计算每一项：\n- 对于 $i=4$：$\\binom{7}{4} (0.01)^4 (0.99)^3 = \\frac{7!}{4!3!} (10^{-2})^4 (0.99)^3 = 35 \\times 10^{-8} \\times (0.970299) \\approx 3.3960465 \\times 10^{-7}$\n- 对于 $i=5$：$\\binom{7}{5} (0.01)^5 (0.99)^2 = \\frac{7!}{5!2!} (10^{-2})^5 (0.99)^2 = 21 \\times 10^{-10} \\times (0.9801) \\approx 2.05821 \\times 10^{-9}$\n- 对于 $i=6$：$\\binom{7}{6} (0.01)^6 (0.99)^1 = \\frac{7!}{6!1!} (10^{-2})^6 (0.99)^1 = 7 \\times 10^{-12} \\times (0.99) \\approx 6.93 \\times 10^{-12}$\n- 对于 $i=7$：$\\binom{7}{7} (0.01)^7 (0.99)^0 = \\frac{7!}{7!0!} (10^{-2})^7 (1) = 1 \\times 10^{-14}$\n\n将这些项相加：\n$$\nP_{\\text{error}} \\approx 3.3960465 \\times 10^{-7} + 2.05821 \\times 10^{-9} + 6.93 \\times 10^{-12} + 1 \\times 10^{-14}\n$$\n$$\nP_{\\text{error}} \\approx 3.3960465 \\times 10^{-7} + 0.0205821 \\times 10^{-7} + 0.0000693 \\times 10^{-7} + 0.0000001 \\times 10^{-7}\n$$\n$$\nP_{\\text{error}} \\approx 3.4166979 \\times 10^{-7}\n$$\n将结果四舍五入至四位有效数字，我们得到 $3.417 \\times 10^{-7}$。",
            "answer": "$$\\boxed{3.417 \\times 10^{-7}}$$"
        },
        {
            "introduction": "虽然单链共识序列（SSCS）能够有效纠错，但在检测极低频率的突变时，其错误率仍可能不够理想。为了达到更高的特异性，研究人员开发了双链共识测序（DCS）技术，它整合了来自DNA双链的信息。本练习将引导你推导DCS的错误率，让你亲身体会到要求两条互补链都支持同一个变异是如何将错误率降低好几个数量级的。",
            "id": "5113791",
            "problem": "在分子与免疫诊断中，一种高特异性稀有变异检测方法在扩增前采用唯一分子标识符（UMI）条形码技术，并根据源自同一原始分子互补链的两个单链一致性序列（SSCS）构建一个双链一致性序列（DCS）。假设以下设计选择和条件成立：\n\n- 每个原始测序读数具有独立的单碱基替换错误概率 $p_{\\mathrm{raw}} = 0.01$，替换错误在三个不正确的核苷酸中均匀分布，并且在不同读数和链之间是独立的。插入缺失（Indel）可以忽略不计。\n- 在给定位置，每个SSCS由来自同一条链的 $f = 3$ 个读数通过四种核苷酸之间的严格多数原则构建：只有当至少有2个读数在同一核苷酸上达成一致时，该碱基才被检出；否则，该位置在SSCS中不被检出。在被检出的条件下，仅当多数读数支持一个不正确的核苷酸时，SSCS碱基才是错误的。\n- 仅当两个SSCS的检出结果一致时，一个DCS碱基才在该位置被检出；如果它们不一致或任一未被检出，该位置在DCS中不被检出。在被检出的条件下，仅当两个SSCS碱基在该位置上同样错误时，一个DCS碱基才是错误的。\n- UMI条形码技术在扩增前进行，因此UMI之后在互补链上产生的错误是独立的。\n\n考虑一个在一个靶向免疫诊断组合中，在 $n = 250$ 个位置上产生有效碱基检出的DCS。仅使用独立性的定义和针对稀有独立事件的二项分布模型，从第一性原理推导这 $n$ 个已检出的DCS位置中至少有一个是伪影错误的概率。将最终概率四舍五入至四位有效数字，并以小数（而非百分比）形式表示。",
            "solution": "该问题要求计算在一个双链一致性序列（DCS）的 $n=250$ 个已检出位置中，至少存在一个伪影错误的概率。解题过程首先确定单链一致性序列（SSCS）的错误概率，然后用此概率求出DCS位置的错误概率，最后对 $n$ 个独立位置应用二项分布模型。\n\n设 $p_{\\mathrm{raw}} = 0.01$ 为原始测序读数中每个碱基的替换错误概率。每个SSCS的读数数量为 $f=3$。错误是均匀分布的，因此任何特定不正确核苷酸的概率为 $\\frac{p_{\\mathrm{raw}}}{3}$。\n\n**步骤1：单链一致性序列（SSCS）分析**\n\n我们首先计算在单个核苷酸位置上SSCS可能结果的概率。不失一般性，假设正确的核苷酸是'A'。三种可能的不正确核苷酸是'C'、'G'和'T'。一个SSCS由 $f=3$ 个读数构成。如果至少有2个读数一致，则检出一个碱基。\n\n设 $P(\\text{true})$ 为一个读数正确的概率，因此 $P(\\text{true}) = 1 - p_{\\mathrm{raw}}$。\n设 $P(\\text{err})$ 为一个读数错误的概率，因此 $P(\\text{err}) = p_{\\mathrm{raw}}$。\n设 $P(\\text{spec-err})$ 为一个特定错误（例如'C'）的概率，因此 $P(\\text{spec-err}) = \\frac{p_{\\mathrm{raw}}}{3}$。\n\n我们确定一个SSCS的三个互斥事件的概率：正确检出、错误检出或未检出。\n\n1.  **正确检出（'A'）的概率**：当2个或3个读数为'A'时发生。\n    - 三个读数均为'A'：概率为 $(1 - p_{\\mathrm{raw}})^3$。\n    - 两个读数为'A'，一个不是：概率为 $\\binom{3}{2}(1 - p_{\\mathrm{raw}})^2 p_{\\mathrm{raw}}$。\n    检出'A'的总概率为：\n    $$P(\\text{call is 'A'}) = (1 - p_{\\mathrm{raw}})^3 + 3(1 - p_{\\mathrm{raw}})^2 p_{\\mathrm{raw}} = (1 - p_{\\mathrm{raw}})^2 ( (1 - p_{\\mathrm{raw}}) + 3p_{\\mathrm{raw}} ) = (1 - p_{\\mathrm{raw}})^2 (1 + 2p_{\\mathrm{raw}})$$\n\n2.  **特定错误检出（例如 'C'）的概率**：当2个或3个读数为'C'时发生。\n    - 三个读数均为'C'：概率为 $(\\frac{p_{\\mathrm{raw}}}{3})^3$。\n    - 两个读数为'C'，一个不是'C'：概率为 $\\binom{3}{2}(\\frac{p_{\\mathrm{raw}}}{3})^2(1 - \\frac{p_{\\mathrm{raw}}}{3})$。\n    检出'C'的总概率为：\n    $$P(\\text{call is 'C'}) = \\binom{3}{2}\\left(\\frac{p_{\\mathrm{raw}}}{3}\\right)^2\\left(1 - \\frac{p_{\\mathrm{raw}}}{3}\\right) + \\left(\\frac{p_{\\mathrm{raw}}}{3}\\right)^3 = 3\\frac{p_{\\mathrm{raw}}^2}{9}\\left(\\frac{3-p_{\\mathrm{raw}}}{3}\\right) + \\frac{p_{\\mathrm{raw}}^3}{27}$$\n    $$P(\\text{call is 'C'}) = \\frac{p_{\\mathrm{raw}}^2(3-p_{\\mathrm{raw}})}{9} + \\frac{p_{\\mathrm{raw}}^3}{27} = \\frac{3p_{\\mathrm{raw}}^2(3-p_{\\mathrm{raw}}) + p_{\\mathrm{raw}}^3}{27} = \\frac{9p_{\\mathrm{raw}}^2 - 3p_{\\mathrm{raw}}^3 + p_{\\mathrm{raw}}^3}{27} = \\frac{9p_{\\mathrm{raw}}^2 - 2p_{\\mathrm{raw}}^3}{27} = \\frac{1}{3}p_{\\mathrm{raw}}^2 - \\frac{2}{27}p_{\\mathrm{raw}}^3$$\n    根据对称性，检出'G'或'T'的概率是相同的。\n\n3.  **SSCS被检出的概率**：如果任何碱基（'A'、'C'、'G'或'T'）占多数，则SCCS被检出。\n    $$P(\\text{SSCS called}) = P(\\text{call is 'A'}) + P(\\text{call is 'C'}) + P(\\text{call is 'G'}) + P(\\text{call is 'T'})$$\n    $$P(\\text{SSCS called}) = P(\\text{call is 'A'}) + 3 \\times P(\\text{call is 'C'})$$\n\n**步骤2：双链一致性序列（DCS）分析**\n\n如果两个独立的SSCS（来自互补链）一致，则DCS碱基被检出。如果两个SSCS同样错误，则发生DCS错误。我们寻求条件概率 $p_{\\text{DCS}}$，定义为在DCS碱基被检出的条件下，发生DCS错误的概率。\n\n设 $S_1$ 和 $S_2$ 表示两个独立SSCS过程的结果。\n- DCS被检出的事件是两个SSCS在某个碱基上达成一致的事件的并集：$(S_1=\\text{'A'} \\cap S_2=\\text{'A'}) \\cup (S_1=\\text{'C'} \\cap S_2=\\text{'C'}) \\cup \\dots$。\n- DCS错误的事件是两个SSCS在某个不正确的碱基上达成一致的事件的并集：$(S_1=\\text{'C'} \\cap S_2=\\text{'C'}) \\cup (S_1=\\text{'G'} \\cap S_2=\\text{'G'}) \\cup (S_1=\\text{'T'} \\cap S_2=\\text{'T'})$。\n\n由于 $S_1$ 和 $S_2$ 的独立性：\n$$P(\\text{DCS error}) = P(S_1=\\text{'C'})^2 + P(S_1=\\text{'G'})^2 + P(S_1=\\text{'T'})^2 = 3 \\times P(\\text{call is 'C'})^2$$\n$$P(\\text{DCS called}) = P(S_1=\\text{'A'})^2 + 3 \\times P(\\text{call is 'C'})^2$$\n\nDCS错误的条件概率是：\n$$p_{\\text{DCS}} = P(\\text{DCS error} | \\text{DCS called}) = \\frac{P(\\text{DCS error} \\cap \\text{DCS called})}{P(\\text{DCS called})}$$\n由于“DCS错误”事件是“DCS被检出”事件的子集，其交集就是“DCS错误”。\n$$p_{\\text{DCS}} = \\frac{P(\\text{DCS error})}{P(\\text{DCS called})} = \\frac{3 \\times P(\\text{call is 'C'})^2}{P(\\text{call is 'A'})^2 + 3 \\times P(\\text{call is 'C'})^2}$$\n\n**步骤3：数值计算**\n\n我们将 $p_{\\mathrm{raw}} = 0.01$ 代入推导出的表达式中。\n$$P(\\text{call is 'A'}) = (1 - 0.01)^2 (1 + 2 \\times 0.01) = (0.99)^2 (1.02) = 0.9801 \\times 1.02 = 0.999702$$\n$$P(\\text{call is 'C'}) = \\frac{1}{3}(0.01)^2 - \\frac{2}{27}(0.01)^3 = \\frac{1}{3} \\times 10^{-4} - \\frac{2}{27} \\times 10^{-6}$$\n$$P(\\text{call is 'C'}) = (3.33333... \\times 10^{-5}) - (0.07407... \\times 10^{-6}) = 3.33333... \\times 10^{-5} - 0.007407... \\times 10^{-5} = 3.3259259... \\times 10^{-5}$$\n\n现在，我们计算 $p_{\\text{DCS}}$：\n分子：\n$$3 \\times P(\\text{call is 'C'})^2 = 3 \\times (3.3259259... \\times 10^{-5})^2 \\approx 3 \\times 1.106173 \\times 10^{-9} \\approx 3.318519 \\times 10^{-9}$$\n分母：\n$$P(\\text{call is 'A'})^2 + 3 \\times P(\\text{call is 'C'})^2 = (0.999702)^2 + 3.318519 \\times 10^{-9}$$\n$$\\approx 0.999404118 + 3.318519 \\times 10^{-9} = 0.9994041213$$\n$$p_{\\text{DCS}} = \\frac{3.318519 \\times 10^{-9}}{0.9994041213} \\approx 3.320490 \\times 10^{-9}$$\n\n**步骤4：在n=250个位置中至少出现一个错误的概率**\n\n这 $n=250$ 个已检出的DCS位置是独立事件。错误数量遵循参数为 $n=250$ 和成功概率为 $p_{\\text{DCS}}$ 的二项分布。观察到至少一个错误的概率是 $1$ 减去观察到零个错误的概率。\n$$P(\\text{at least one error}) = 1 - P(\\text{zero errors}) = 1 - (1 - p_{\\text{DCS}})^n$$\n代入数值 $n=250$ 和 $p_{\\text{DCS}} \\approx 3.320490 \\times 10^{-9}$：\n$$P(\\text{at least one error}) = 1 - (1 - 3.320490 \\times 10^{-9})^{250}$$\n$$P(\\text{at least one error}) \\approx 1 - 0.99999916988 \\approx 8.3012 \\times 10^{-7}$$\n\n问题要求将结果四舍五入至四位有效数字，并以小数形式表示。\n$$8.301 \\times 10^{-7} = 0.0000008301$$",
            "answer": "$$\\boxed{0.0000008301}$$"
        },
        {
            "introduction": "理论计算和错误率推导最终要服务于实际的生物学问题，例如在临床上监测疾病进展。这个综合性练习将理论与实践相结合，要求你应用一个包含测序错误模型的统计框架，对纵向的循环肿瘤DNA（ctDNA）数据进行变点分析。你将学习如何通过最大似然估计和似然比检验，从充满噪声的测序数据中识别出肿瘤负荷的真实生物学变化。",
            "id": "5113782",
            "problem": "给定来自循环肿瘤DNA (ctDNA) 纠错测序的纵向观测数据，该测序使用了唯一分子标识符 (UMI) 的一致性读数。在由整数 $t \\in \\{1,2,\\dots,T\\}$ 索引的每个时间点，您会观测到覆盖一个位点的 UMI 一致性分子总数（表示为 $N_t$）以及其中被分类为突变的 UMI 数量（表示为 $x_t$）。在时间点 $t$，我们感兴趣的未知生物学量是真实的突变等位基因频率 $\\theta_t \\in [0,1]$，其定义为在该位点携带突变的原始模板分子的比例。\n\n在使用 UMI 的纠错测序中，每个 UMI 一致性读数都是一个分类结果，可以被建模为一个伯努利随机变量，反映该一致性读数被判定为突变型还是野生型。设单个 UMI 的假阳性率为 $r_{\\mathrm{fp}} \\in [0,1]$（一个真实的野生型 UMI 被判定为突变的概率），单个 UMI 的假阴性率为 $r_{\\mathrm{fn}} \\in [0,1]$（一个真实的突变型 UMI 被判定为野生型的概率）。假设在给定的时间段内，真实的等位基因频率是恒定的，并且在给定 $\\theta_t$ 的条件下，各个 UMI 是独立的。\n\n建模的基本依据：\n- 在时间点 $t$，每个 UMI 一致性读数以概率 $\\theta_t$ 来自一个真实的突变分子，以概率 $1-\\theta_t$ 来自一个真实的野生型分子。\n- 一个真实的突变型 UMI 以概率 $1 - r_{\\mathrm{fn}}$ 被观测为突变。\n- 一个真实的野生型 UMI 以概率 $r_{\\mathrm{fp}}$ 被观测为突变。\n- 在时间点 $t$ 给定 $N_t$ 个 UMI，观测到的突变计数 $x_t$ 被建模为一个二项随机变量，其参数为 $N_t$ 和一个必须从上述要素推导出的成功概率。\n\n变化点模型：\n- 在零模型（无变化）下，真实的等位基因频率在所有时间点上都是恒定的，即对所有 $t$，$\\theta_t = \\theta$。\n- 在备择模型（单一变化）下，存在一个索引 $k \\in \\{1,2,\\dots,T-1\\}$，使得当 $t \\le k$ 时 $\\theta_t = \\theta_1$，当 $t \\ge k+1$ 时 $\\theta_t = \\theta_2$。\n- 对于疾病进展检测，您必须仅在最大似然变化点同时满足以下两个条件时，才判定发生了进展：(i) 后一时段的等位基因频率比前一时段的等位基因频率至少高出一个指定的最小增量 $\\Delta_{\\min} > 0$，以及 (ii) 超过了指定的对数似然比阈值 $\\Lambda > 0$。\n\n您的任务：\n1. 从上述建模陈述出发，推导在时间点 $t$ 的伯努利成功概率，将其表示为 $\\theta_t$、$r_{\\mathrm{fp}}$ 和 $r_{\\mathrm{fn}}$ 的函数。然后，使用二项似然，为零模型和单一变化模型建立对数似然函数。\n2. 在每个模型下使用最大似然估计，计算零模型下的最大对数似然，以及对于每个可能的变化点 $k \\in \\{1,\\dots,T-1\\}$，计算在 $k$ 点发生变化的备择模型下的最大对数似然。参数空间必须遵循由 $\\theta$ 导出的可观测伯努利成功概率被限制在 $[r_{\\mathrm{fp}}, 1 - r_{\\mathrm{fn}}]$ 范围内的约束。\n3. 计算最佳单一变化点的对数似然比，其值为备择模型和零模型最大对数似然之差的 $2$ 倍。设 $\\widehat{k}$ 是使该比率最大化的索引，$\\widehat{\\theta}_1$ 和 $\\widehat{\\theta}_2$ 分别是对应的前、后时段的最大似然等位基因频率。\n4. 应用进展判定规则：仅当最大对数似然比至少为 $\\Lambda$ 且 $\\widehat{\\theta}_2 - \\widehat{\\theta}_1 \\ge \\Delta_{\\min}$ 时，宣布进展。如果宣布进展，输出变化点索引 $\\widehat{k}$（使用1-基索引，表示变化发生在时间 $\\widehat{k}$ 和 $\\widehat{k}+1$ 之间）。否则，输出 $-1$。\n\n数值稳定性要求：\n- 在计算任何概率的对数时，将概率限制在闭区间 $\\left[\\varepsilon, 1-\\varepsilon\\right]$ 内，其中 $\\varepsilon = 10^{-12}$，以避免计算 $\\log(0)$。\n\n测试套件和参数：\n- 对所有测试用例使用以下常量：$r_{\\mathrm{fp}} = 10^{-4}$，$r_{\\mathrm{fn}} = 2 \\times 10^{-2}$，$\\Delta_{\\min} = 3 \\times 10^{-4}$，以及 $\\Lambda = 10$。\n- 共有四个独立的测试用例。对于每个测试用例 $i \\in \\{1,2,3,4\\}$，给定时间序列长度 $T^{(i)}$、向量 $(N^{(i)}_t)_{t=1}^{T^{(i)}}$ 和 $(x^{(i)}_t)_{t=1}^{T^{(i)}}$：\n\n测试用例1（明显增加）：\n- $T^{(1)} = 8$\n- $N^{(1)} = (10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000)$\n- $x^{(1)} = (6, 5, 7, 6, 49, 52, 51, 48)$\n\n测试用例2（无变化；接近背景水平）：\n- $T^{(2)} = 6$\n- $N^{(2)} = (15000, 15000, 15000, 15000, 15000, 15000)$\n- $x^{(2)} = (1, 2, 2, 1, 3, 0)$\n\n测试用例3（在检测限附近的微弱增加）：\n- $T^{(3)} = 10$\n- $N^{(3)} = (8000, 9500, 7000, 12000, 10000, 11000, 9000, 10000, 10000, 12000)$\n- $x^{(3)} = (3, 3, 2, 4, 3, 8, 6, 7, 7, 8)$\n\n测试用例4（减少；不应被称为进展）：\n- $T^{(4)} = 7$\n- $N^{(4)} = (10000, 10000, 10000, 10000, 10000, 10000, 10000)$\n- $x^{(4)} = (85, 79, 82, 80, 12, 10, 9)$\n\n最终输出格式：\n- 您的程序应处理上述四个测试用例，并生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，输出一个整数：如果宣布进展，则为检测到的变化点索引 $\\widehat{k}$（使用1-基索引）；否则为 $-1$。例如，一个有效的输出行形式为 $[a,b,c,d]$，其中 $a,b,c,d$ 均为指定的整数。",
            "solution": "该问题要求为循环肿瘤DNA (ctDNA) 测序的纵向数据开发一个变化点检测算法。目标是确定真实突变等位基因频率 $\\theta_t$ 是否发生了统计上显著的增加。这涉及对测序数据进行建模，在零假设和备择假设下执行最大似然估计 (MLE)，并使用似然比检验结合效应量约束来做出决策。\n\n首先，我们推导观测到突变唯一分子标识符 (UMI) 一致性读数的概率。设 $p_t$ 为在时间点 $t$ 一个 UMI 一致性读数被分类为突变的概率。这一事件可以通过两种互斥的方式发生：要么原始DNA分子是突变的且被正确识别，要么分子是野生型的但被错误地识别为突变（假阳性）。使用全概率定律，我们可以将 $p_t$ 表示为真实突变等位基因频率 $\\theta_t$、单个UMI假阳性率 $r_{\\mathrm{fp}}$ 和单个UMI假阴性率 $r_{\\mathrm{fn}}$ 的函数。\n\n一个 UMI 源自真实突变分子的概率是 $\\theta_t$，源自真实野生型分子的概率是 $1 - \\theta_t$。一个真实的突变以 $1 - r_{\\mathrm{fn}}$ 的概率被观测为突变，一个真实的野生型以 $r_{\\mathrm{fp}}$ 的概率被观测为突变。因此，$p_t$ 由下式给出：\n$$p_t = P(\\text{观测为突变}) = P(\\text{观测为突变} | \\text{真实为突变})P(\\text{真实为突变}) + P(\\text{观测为突变} | \\text{真实为野生型})P(\\text{真实为野生型})$$\n$$p_t = (1 - r_{\\mathrm{fn}})\\theta_t + r_{\\mathrm{fp}}(1 - \\theta_t)$$\n整理这个线性关系得到：\n$$p_t = r_{\\mathrm{fp}} + (1 - r_{\\mathrm{fp}} - r_{\\mathrm{fn}})\\theta_t$$\n问题指明，在给定总 UMI 计数 $N_t$ 的情况下，时间点 $t$ 观测到的 UMI 突变计数 $x_t$ 服从二项分布，$x_t \\sim \\text{Binomial}(N_t, p_t)$。对于单个观测 $(x_t, N_t)$ 的对数似然，省略不影响最大化的常数二项式系数 $\\log\\binom{N_t}{x_t}$，其形式为：\n$$\\mathcal{L}(p_t | x_t, N_t) \\propto x_t \\log(p_t) + (N_t - x_t) \\log(1 - p_t)$$\n\n接下来，我们定义最大似然估计的步骤。对于给定的时间点集合 $S$，其中假设真实等位基因频率 $\\theta$ 是恒定的，总对数似然是各个对数似然之和：\n$$\\mathcal{L}(\\theta; S) = \\sum_{t \\in S} \\left[ x_t \\log(p) + (N_t - x_t) \\log(1 - p) \\right]$$\n其中 $p = r_{\\mathrm{fp}} + (1 - r_{\\mathrm{fp}} - r_{\\mathrm{fn}})\\theta$。这等价于在 $\\sum_{t \\in S} N_t$ 次试验中取得 $\\sum_{t \\in S} x_t$ 次成功的单次二项实验的对数似然。观测概率 $p$ 的最大似然估计是合并频率：\n$$\\widehat{p} = \\frac{\\sum_{t \\in S} x_t}{\\sum_{t \\in S} N_t}$$\n问题指出，可观测概率 $p$ 的参数空间为 $[r_{\\mathrm{fp}}, 1 - r_{\\mathrm{fn}}]$，对应于 $\\theta \\in [0, 1]$。因此，最大似然估计 $\\widehat{p}$ 必须被限制在该区间内。设 $\\widehat{p}_{\\text{raw}} = (\\sum x_t) / (\\sum N_t)$。则受约束的最大似然估计为 $\\widehat{p} = \\max(r_{\\mathrm{fp}}, \\min(1 - r_{\\mathrm{fn}}, \\widehat{p}_{\\text{raw}}))$。\n由此，我们通过反解该线性关系来找到真实等位基因频率的最大似然估计 $\\widehat{\\theta}$：\n$$\\widehat{\\theta} = \\frac{\\widehat{p} - r_{\\mathrm{fp}}}{1 - r_{\\mathrm{fp}} - r_{\\mathrm{fn}}}$$\n此过程允许我们通过先计算 $\\widehat{p}$，然后使用该估计值评估对数似然函数，来找到任何数据段的最大对数似然。为了数值稳定性，我们将任何对数的参数限制在区间 $[\\varepsilon, 1-\\varepsilon]$ 内，其中 $\\varepsilon = 10^{-12}$。\n\n现在我们将此框架应用于零模型和备择模型。\n在零模型 ($H_0$)下，等位基因频率在所有时间点上都是恒定的，即对于 $t \\in \\{1, \\dots, T\\}$，$\\theta_t = \\theta$。我们通过合并所有数据来计算最大似然估计 $\\widehat{p}_{\\text{null}}$：$S = \\{1, \\dots, T\\}$。零模型下的最大对数似然为：\n$$\\mathcal{L}_{\\text{null, max}} = \\mathcal{L}(\\widehat{\\theta}_{\\text{null}}; S=\\{1, \\dots, T\\}) = \\sum_{t=1}^{T} \\left[ x_t \\log(\\widehat{p}_{\\text{null}}) + (N_t - x_t) \\log(1 - \\widehat{p}_{\\text{null}}) \\right]$$\n\n在备择模型 ($H_1$)下，存在一个单一变化点 $k \\in \\{1, \\dots, T-1\\}$。对于每个可能的 $k$，数据被分成两个段：$S_1 = \\{1, \\dots, k\\}$ 和 $S_2 = \\{k+1, \\dots, T\\}$。我们假设对于 $t \\in S_1$，$\\theta_t = \\theta_1$，对于 $t \\in S_2$，$\\theta_t = \\theta_2$。我们为每个段独立进行最大似然估计，以找到 $\\widehat{p}_{1,k}$ 和 $\\widehat{p}_{2,k}$。对于给定的 $k$，总的最大对数似然是两个段的最大对数似然之和：\n$$\\mathcal{L}_{\\text{alt, max}}(k) = \\left( \\sum_{t=1}^{k} \\left[x_t \\log(\\widehat{p}_{1,k}) + (N_t - x_t) \\log(1 - \\widehat{p}_{1,k})\\right] \\right) + \\left( \\sum_{t=k+1}^{T} \\left[x_t \\log(\\widehat{p}_{2,k}) + (N_t - x_t) \\log(1 - \\widehat{p}_{2,k})\\right] \\right)$$\n我们通过在所有可能的 $k$ 上最大化此量来找到最佳变化点 $\\widehat{k}$：\n$$\\widehat{k} = \\arg\\max_{k \\in \\{1, \\dots, T-1\\}} \\mathcal{L}_{\\text{alt, max}}(k)$$\n备择模型的总体最大对数似然是 $\\mathcal{L}_{\\text{alt, max}} = \\mathcal{L}_{\\text{alt, max}}(\\widehat{k})$。\n\n对数似然比 (LRT) 统计量的计算公式为：\n$$\\text{LRT} = 2 \\times (\\mathcal{L}_{\\text{alt, max}} - \\mathcal{L}_{\\text{null, max}})$$\n该统计量量化了单一变化点模型相对于无变化模型的证据。\n\n最后，应用宣布疾病进展的决策规则。当且仅当对于最佳变化点 $\\widehat{k}$，以下两个条件都满足时，才检测到进展：\n1. LRT超过一个阈值：$\\text{LRT} \\ge \\Lambda$。\n2. 等位基因频率的估计增量满足一个最小阈值：$\\widehat{\\theta}_2 - \\widehat{\\theta}_1 \\ge \\Delta_{\\min}$，其中 $\\widehat{\\theta}_1$ 和 $\\widehat{\\theta}_2$ 是对应于由 $\\widehat{k}$ 定义的两个段的最大似然估计。\n如果两个条件都满足，输出为变化点的1-基索引 $\\widehat{k}$。否则，不宣布进展，输出为 $-1$。第二个条件确保我们只检测等位基因频率的增加，而不是减少或临床意义过小的变化。",
            "answer": "```python\nimport numpy as np\n\n# Constants from the problem statement\nR_FP = 1e-4\nR_FN = 2e-2\nDELTA_MIN = 3e-4\nLAMBDA = 10.0\nEPSILON = 1e-12\n\ndef calculate_mle_and_loglik(x_segment, n_segment, r_fp, r_fn):\n    \"\"\"\n    Calculates the MLEs for p and theta, and the maximum log-likelihood for a data segment.\n    \n    Args:\n        x_segment (np.ndarray): Array of mutant counts.\n        n_segment (np.ndarray): Array of total counts.\n        r_fp (float): False positive rate.\n        r_fn (float): False negative rate.\n\n    Returns:\n        tuple: (theta_hat, max_log_likelihood)\n    \"\"\"\n    if np.sum(n_segment) == 0:\n        return 0.0, -np.inf\n\n    # Calculate raw MLE for the observed probability p by pooling data\n    p_hat_raw = np.sum(x_segment) / np.sum(n_segment)\n\n    # Clamp p_hat to the valid range [r_fp, 1 - r_fn]\n    p_hat_clamped = np.clip(p_hat_raw, r_fp, 1.0 - r_fn)\n\n    # Invert to find the MLE for the true allele fraction theta\n    denominator = 1.0 - r_fp - r_fn\n    theta_hat = (p_hat_clamped - r_fp) / denominator\n\n    # Clamp probability again for numerical stability before taking the logarithm\n    p_log = np.clip(p_hat_clamped, EPSILON, 1.0 - EPSILON)\n    \n    # Calculate the total log-likelihood for the segment\n    loglik = np.sum(\n        x_segment * np.log(p_log) + (n_segment - x_segment) * np.log(1.0 - p_log)\n    )\n\n    return theta_hat, loglik\n\ndef solve_case(N, x, r_fp, r_fn, delta_min, Lambda):\n    \"\"\"\n    Processes a single test case for change-point detection.\n    \n    Returns:\n        int: The 1-based change-point index if progression is detected, otherwise -1.\n    \"\"\"\n    T = len(N)\n    N = np.array(N, dtype=np.float64)\n    x = np.array(x, dtype=np.float64)\n\n    # 1. Null Model (H0: no change)\n    # Calculate the maximum log-likelihood assuming one constant allele fraction\n    _, loglik_null = calculate_mle_and_loglik(x, N, r_fp, r_fn)\n\n    # 2. Alternative Model (H1: one change-point)\n    # Find the best change-point by maximizing the log-likelihood\n    max_loglik_alt = -np.inf\n    best_k = -1\n    best_theta1 = 0.0\n    best_theta2 = 0.0\n\n    # Iterate through all possible change-points k (1-based index).\n    # k represents the last time point of the first segment.\n    for k in range(1, T):\n        # Segment 1: time points 1..k (0-indexed: 0..k-1)\n        x1, n1 = x[:k], N[:k]\n        # Segment 2: time points k+1..T (0-indexed: k..T-1)\n        x2, n2 = x[k:], N[k:]\n\n        theta1, loglik1 = calculate_mle_and_loglik(x1, n1, r_fp, r_fn)\n        theta2, loglik2 = calculate_mle_and_loglik(x2, n2, r_fp, r_fn)\n\n        current_loglik_alt = loglik1 + loglik2\n\n        if current_loglik_alt > max_loglik_alt:\n            max_loglik_alt = current_loglik_alt\n            best_k = k\n            best_theta1 = theta1\n            best_theta2 = theta2\n            \n    # 3. Decision Logic\n    if best_k == -1: # Handles case of T=1, no possible change-point\n        return -1\n        \n    # Calculate the Log-Likelihood Ratio statistic\n    log_likelihood_ratio = 2 * (max_loglik_alt - loglik_null)\n\n    # Check both conditions for progression:\n    # 1. Statistical significance (LRT)\n    # 2. Effect size (magnitude of increase in theta)\n    is_lrt_significant = log_likelihood_ratio >= Lambda\n    is_increase_meaningful = (best_theta2 - best_theta1) >= delta_min\n\n    if is_lrt_significant and is_increase_meaningful:\n        return best_k\n    else:\n        return -1\n        \ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test cases from the problem statement\n    test_cases = [\n        # Case 1: clear increase\n        (\n            [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000],\n            [6, 5, 7, 6, 49, 52, 51, 48]\n        ),\n        # Case 2: no change; near background\n        (\n            [15000, 15000, 15000, 15000, 15000, 15000],\n            [1, 2, 2, 1, 3, 0]\n        ),\n        # Case 3: subtle increase\n        (\n            [8000, 9500, 7000, 12000, 10000, 11000, 9000, 10000, 10000, 12000],\n            [3, 3, 2, 4, 3, 8, 6, 7, 7, 8]\n        ),\n        # Case 4: decrease\n        (\n            [10000, 10000, 10000, 10000, 10000, 10000, 10000],\n            [85, 79, 82, 80, 12, 10, 9]\n        )\n    ]\n\n    results = []\n    for N, x in test_cases:\n        result = solve_case(N, x, R_FP, R_FN, DELTA_MIN, LAMBDA)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}