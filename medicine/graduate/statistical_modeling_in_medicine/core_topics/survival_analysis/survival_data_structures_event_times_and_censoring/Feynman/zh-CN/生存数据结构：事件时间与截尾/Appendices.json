{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。此练习将指导您从原始数据入手，为包含左截断和右删失的复杂医学数据集手动构建生存函数 。通过精确计算每个事件发生时的风险集，您将掌握非参数最大似然估计（NPMLE）的核心机制，并直观地理解为何生存曲线在事件发生时呈阶梯式下降，而在删失期间保持平坦。",
            "id": "4985824",
            "problem": "一项前瞻性医疗登记研究从一个定义的时间起点开始追踪患者，直到发生不良事件（例如，首次住院）或管理性删失。由于延迟入组（左截断），患者可能在时间起点之后才进入风险集。假设右删失和左截断是独立的，并且在任何事件和删失同时发生的时间点，为了风险集核算，事件先于删失进行登记。现有 $12$ 名患者的数据以三元组 $\\big(L_i, T_i, \\delta_i\\big)$ 的形式给出，其中 $L_i$ 是以月为单位的左截断（进入）时间，$T_i$ 是以月为单位的观测时间（事件时间或删失时间），$\\delta_i \\in \\{0,1\\}$ 指示删失（$0$）或事件（$1$）：\n- $i=1$: $\\big(0, 3, 1\\big)$\n- $i=2$: $\\big(0, 5, 0\\big)$\n- $i=3$: $\\big(0, 5, 1\\big)$\n- $i=4$: $\\big(2, 6, 1\\big)$\n- $i=5$: $\\big(1, 9, 0\\big)$\n- $i=6$: $\\big(0, 9, 1\\big)$\n- $i=7$: $\\big(4, 10, 1\\big)$\n- $i=8$: $\\big(0, 12, 0\\big)$\n- $i=9$: $\\big(7, 12, 1\\big)$\n- $i=10$: $\\big(5, 14, 1\\big)$\n- $i=11$: $\\big(8, 14, 0\\big)$\n- $i=12$: $\\big(0, 15, 0\\big)$\n\n从生存函数 $S(t)=\\Pr(Tt)$ 的定义和右删失、左截断数据的似然函数出发，通过识别每个不同事件时间点的风险集并构建相应的条件生存概率，推导出生存函数的非参数极大似然估计 (NPMLE) $\\hat S(t)$。在您的推导中，明确解释为什么 $\\hat S(t)$ 在事件时间点出现阶梯式下降，而在只有删失的时间段内保持平坦。\n\n计算此数据集的 $\\hat S(t)$，并根据生存函数的标准右连续约定报告 $\\hat S(14)$ 的值。请将最终答案表示为精确的既约分数。不要包含单位，也不要使用百分号。",
            "solution": "用户要求我解决一个统计建模问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   **主题**：生存数据结构：医学统计建模中的事件时间和删失。\n-   **数据类型**：左截断和右删失的生存数据。\n-   **数据结构**：$i=1, \\dots, 12$ 的三元组 $(L_i, T_i, \\delta_i)$。\n    -   $L_i$：以月为单位的左截断（进入）时间。\n    -   $T_i$：以月为单位的观测时间（事件或删失）。\n    -   $\\delta_i$：事件指示符，$\\delta_i=1$ 表示事件，$\\delta_i=0$ 表示删失。\n-   **数据集**：\n    -   $i=1$: $(0, 3, 1)$\n    -   $i=2$: $(0, 5, 0)$\n    -   $i=3$: $(0, 5, 1)$\n    -   $i=4$: $(2, 6, 1)$\n    -   $i=5$: $(1, 9, 0)$\n    -   $i=6$: $(0, 9, 1)$\n    -   $i=7$: $(4, 10, 1)$\n    -   $i=8$: $(0, 12, 0)$\n    -   $i=9$: $(7, 12, 1)$\n    -   $i=10$: $(5, 14, 1)$\n    -   $i=11$: $(8, 14, 0)$\n    -   $i=12$: $(0, 15, 0)$\n-   **假设**：独立的右删失和独立的左截断。\n-   **决断规则**：如果事件和删失同时发生，为了风险集核算，事件先于删失登记。\n-   **定义**：生存函数 $S(t) = \\Pr(Tt)$。\n-   **约定**：生存函数 $\\hat{S}(t)$ 是右连续的。\n-   **任务**：\n    1.  推导生存函数的非参数极大似然估计 (NPMLE) $\\hat{S}(t)$，并解释其性质。\n    2.  为给定数据集计算 $\\hat{S}(t)$。\n    3.  以精确的既约分数形式报告 $\\hat{S}(14)$ 的值。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题是生存分析的标准应用，生存分析是生物统计学和计量经济学的核心课题。左截断、右删失、风险集以及非参数极大似然估计（NPMLE）（也称为截断数据的乘积极限估计）等概念是基础且成熟的。该问题有坚实的统计理论基础。\n-   **良态性**：该问题提供了完整的数据集、明确的假设（独立的删失/截断）、决断规则和清晰的目标。存在唯一、稳定且有意义的解。\n-   **客观性**：语言精确、无偏见，使用了生存分析领域的标准术语。\n\n该问题科学合理、结构严谨、内容客观。它包含了获得唯一解所需的所有必要信息。\n\n**步骤3：结论和行动**\n\n该问题是**有效的**。现在开始求解过程。\n\n### 推导与求解\n\n本题要求推导和计算在左截断和右删失数据下生存函数 $S(t)$ 的非参数极大似然估计 (NPMLE)。该估计量是 Kaplan-Meier 估计量的一种扩展。\n\n对于一个包含 $n$ 个个体的左截断和右删失样本，其似然函数是通过考虑每个个体的贡献来构建的。对于个体 $i$，其进入时间为 $L_i$，观测时间为 $T_i$，事件指示符为 $\\delta_i$，只有当其真实事件时间 $T^*_i$ 大于其进入时间 $L_i$ 时，其事件或删失才会被观测到。个体 $i$ 的似然贡献是以这一事实为条件的，即 $\\Pr(\\text{个体 } i \\text{ 的数据} | T^*_i  L_i)$。\n如果发生事件（$\\delta_i=1$），其贡献与条件概率密度 $\\frac{f(T_i)}{S(L_i)}$ 成正比。如果发生删失（$\\delta_i=0$），其贡献与条件生存概率 $\\frac{S(T_i)}{S(L_i)}$ 成正比。总似然函数为：\n$$L = \\prod_{i=1}^{n} \\left[ \\frac{f(T_i)}{S(L_i)} \\right]^{\\delta_i} \\left[ \\frac{S(T_i)}{S(L_i)} \\right]^{1-\\delta_i}$$\n对该似然函数进行非参数最大化，可以得出结论：概率质量仅集中在观测到的事件时间点上。设不同的有序事件时间为 $t_{(1)}  t_{(2)}  \\dots  t_{(k)}$。生存函数的 NPMLE $\\hat{S}(t)$ 是一个乘积极限公式：\n$$\\hat{S}(t) = \\prod_{j: t_{(j)} \\le t} \\left(1 - \\frac{d_j}{n_j}\\right)$$\n这里，各组成部分的定义如下：\n-   $t_{(j)}$：数据中观测到的第 $j$ 个不同的事件时间。\n-   $d_j$：在时间 $t_{(j)}$ 发生事件的个体数量。\n-   $n_j$：在时间 $t_{(j)}$ 处于风险集中的个体数量。风险集 $R(t_{(j)})$ 包含所有正在被观察且尚未发生事件或被删失的个体。对于左截断数据，如果个体 $i$ 在时间 $t_{(j)}$ 或之前进入研究（$L_i \\le t_{(j)}$），并且其事件或删失时间在 $t_{(j)}$ 或之后（$T_i \\ge t_{(j)}$），则该个体在时间 $t_{(j)}$ 处于风险集中。因此，$n_j = |\\{i : L_i \\le t_{(j)} \\text{ and } T_i \\ge t_{(j)}\\}|$。对于观测时间 $T_i=t_{(j)}$ 相同的个体，问题规定事件先于删失登记，这一规则被条件 $T_i \\ge t_{(j)}$ 自然地处理了，该条件将在时间 $t_{(j)}$ 发生事件的风险集中包括那些在 $t_{(j)}$ 被删失的个体。\n\n$\\hat{S}(t)$ 的形式解释了其行为。生存函数定义时初始值为 $\\hat{S}(0)=1$。随着时间 $t$ 的增加，$\\hat{S}(t)$ 的值在事件时间之间保持不变，因为乘积中的因子集合 $\\{j: t_{(j)} \\le t\\}$ 没有改变。在每个不同的事件时间 $t_{(j)}$，一个新的乘法因子 $(1 - d_j/n_j)$ 被引入。由于 $d_j \\ge 1$（因为它是一个事件时间）且 $n_j \\ge d_j$，这个因子严格小于 $1$（且非负）。因此，$\\hat{S}(t)$ 在每个事件时间点都经历一个离散的下降阶梯。在一个只有删失发生的时间 $t_c$，没有新的事件时间被跨越，因此没有新的因子被乘入，且 $\\hat{S}(t_c) = \\hat{S}(t_c-)$。删失仅影响后续事件时间的风险集大小 $n_j$。这就是为什么 $\\hat{S}(t)$ 是一个右连续的阶梯函数，其值仅在观测到的事件时间点发生变化。\n\n我们现在为所提供的数据集计算 $\\hat{S}(t)$。首先，我们从数据中识别出 $\\delta_i=1$ 的不同事件时间：$3, 5, 6, 9, 10, 12, 14$。\n\n-   **事件时间 $t_{(1)} = 3$**：\n    -   事件数 $d_1 = 1$ (患者 $1$)。\n    -   风险集 $R(3) = \\{i: L_i \\le 3 \\text{ and } T_i \\ge 3\\}$。成员为患者 $1, 2, 3, 4, 5, 6, 8, 12$。\n    -   风险人数 $n_1 = 8$。\n    -   $\\hat{S}(3) = 1 - \\frac{d_1}{n_1} = 1 - \\frac{1}{8} = \\frac{7}{8}$。\n\n-   **事件时间 $t_{(2)} = 5$**：\n    -   事件数 $d_2 = 1$ (患者 $3$)。\n    -   风险集 $R(5) = \\{i: L_i \\le 5 \\text{ and } T_i \\ge 5\\}$。成员为患者 $2, 3, 4, 5, 6, 7, 8, 10, 12$。患者 $1$ 已离开 ($T_1=3$)，患者 $7$ 和 $10$ 已进入 ($L_7=4, L_{10}=5$)。\n    -   风险人数 $n_2 = 9$。\n    -   $\\hat{S}(5) = \\hat{S}(3) \\times \\left(1 - \\frac{d_2}{n_2}\\right) = \\frac{7}{8} \\times \\left(1 - \\frac{1}{9}\\right) = \\frac{7}{8} \\times \\frac{8}{9} = \\frac{7}{9}$。\n\n-   **事件时间 $t_{(3)} = 6$**：\n    -   事件数 $d_3 = 1$ (患者 $4$)。\n    -   风险集 $R(6) = \\{i: L_i \\le 6 \\text{ and } T_i \\ge 6\\}$。成员为患者 $4, 5, 6, 7, 8, 10, 12$。患者 $2, 3$ 已离开 ($T_2=5, T_3=5$)。\n    -   风险人数 $n_3 = 7$。\n    -   $\\hat{S}(6) = \\hat{S}(5) \\times \\left(1 - \\frac{d_3}{n_3}\\right) = \\frac{7}{9} \\times \\left(1 - \\frac{1}{7}\\right) = \\frac{7}{9} \\times \\frac{6}{7} = \\frac{6}{9} = \\frac{2}{3}$。\n\n-   **事件时间 $t_{(4)} = 9$**：\n    -   事件数 $d_4 = 1$ (患者 $6$)。\n    -   风险集 $R(9) = \\{i: L_i \\le 9 \\text{ and } T_i \\ge 9\\}$。成员为患者 $5, 6, 7, 8, 9, 10, 11, 12$。患者 $4$ 已离开 ($T_4=6$)，患者 $9$ 和 $11$ 已进入 ($L_9=7, L_{11}=8$)。\n    -   风险人数 $n_4 = 8$。\n    -   $\\hat{S}(9) = \\hat{S}(6) \\times \\left(1 - \\frac{d_4}{n_4}\\right) = \\frac{2}{3} \\times \\left(1 - \\frac{1}{8}\\right) = \\frac{2}{3} \\times \\frac{7}{8} = \\frac{14}{24} = \\frac{7}{12}$。\n\n-   **事件时间 $t_{(5)} = 10$**：\n    -   事件数 $d_5 = 1$ (患者 $7$)。\n    -   风险集 $R(10) = \\{i: L_i \\le 10 \\text{ and } T_i \\ge 10\\}$。成员为患者 $7, 8, 9, 10, 11, 12$。患者 $5, 6$ 已离开 ($T_5=9, T_6=9$)。\n    -   风险人数 $n_5 = 6$。\n    -   $\\hat{S}(10) = \\hat{S}(9) \\times \\left(1 - \\frac{d_5}{n_5}\\right) = \\frac{7}{12} \\times \\left(1 - \\frac{1}{6}\\right) = \\frac{7}{12} \\times \\frac{5}{6} = \\frac{35}{72}$。\n\n-   **事件时间 $t_{(6)} = 12$**：\n    -   事件数 $d_6 = 1$ (患者 $9$)。\n    -   风险集 $R(12) = \\{i: L_i \\le 12 \\text{ and } T_i \\ge 12\\}$。成员为患者 $8, 9, 10, 11, 12$。患者 $7$ 已离开 ($T_7=10$)。\n    -   风险人数 $n_6 = 5$。\n    -   $\\hat{S}(12) = \\hat{S}(10) \\times \\left(1 - \\frac{d_6}{n_6}\\right) = \\frac{35}{72} \\times \\left(1 - \\frac{1}{5}\\right) = \\frac{35}{72} \\times \\frac{4}{5} = \\frac{140}{360} = \\frac{7}{18}$。\n\n-   **事件时间 $t_{(7)} = 14$**：\n    -   事件数 $d_7 = 1$ (患者 $10$)。\n    -   风险集 $R(14) = \\{i: L_i \\le 14 \\text{ and } T_i \\ge 14\\}$。成员为患者 $10, 11, 12$。患者 $8, 9$ 已离开 ($T_8=12, T_9=12$)。\n    -   风险人数 $n_7 = 3$。\n    -   $\\hat{S}(14) = \\hat{S}(12) \\times \\left(1 - \\frac{d_7}{n_7}\\right) = \\frac{7}{18} \\times \\left(1 - \\frac{1}{3}\\right) = \\frac{7}{18} \\times \\frac{2}{3} = \\frac{14}{54} = \\frac{7}{27}$。\n\n问题要求 $\\hat{S}(14)$ 的值。根据右连续约定，$\\hat{S}(14)$ 是生存函数在 $t=14$ 处跳跃后的值。我们上面的计算提供了这个值。\n最终值为 $\\hat{S}(14) = \\frac{7}{27}$。",
            "answer": "$$\\boxed{\\frac{7}{27}}$$"
        },
        {
            "introduction": "在估计生存曲线后，下一个关键步骤是量化我们对估计的不确定性。该练习探讨了为Kaplan-Meier生存估计构建置信区间的实际挑战 。您将首先构建朴素的Wald置信区间，并观察当生存概率接近0或1时其如何失效，然后应用基于logit和log-minus-log变换的方法，学习如何生成在统计上更稳健且始终位于有效参数空间 $[0,1]$ 内的置信区间。",
            "id": "4985817",
            "problem": "一项基于医院的队列研究对 $n$ 名患者进行随访，以评估事件发生时间结局，并在右删失情况下分析预设时间点的生存率。假设满足非信息性独立删失条件。设 $\\{\\tau_j: j=1,\\dots,6\\}$ 表示六个不同的有序事件时间，在每个时间 $\\tau_j$ 上的风险集大小为 $n_j$，事件数为 $d_j$。Kaplan–Meier 估计量 $\\hat S(t)$ 及其 Greenwood 方差 $\\widehat{\\mathrm{Var}}(\\hat S(t))$ 是生存分析中经过充分检验的标准工具。考虑在六个不同事件时间点上，根据经验观测到的风险集和事件计数的汇总如下：\n- 在 $\\tau_1$ 时：$n_1=50$, $d_1=1$。\n- 在 $\\tau_2$ 时：$n_2=49$, $d_2=1$。\n- 在 $\\tau_3$ 时：$n_3=48$, $d_3=10$。\n- 在 $\\tau_4$ 时：$n_4=38$, $d_4=10$。\n- 在 $\\tau_5$ 时：$n_5=28$, $d_5=20$。\n- 在 $\\tau_6$ 时：$n_6=8$, $d_6=6$。\n\n使用这些数据，针对 $t=\\tau_2$（一个生存率较高的早期时间点）和 $t=\\tau_6$（一个生存率较低的晚期时间点）的生存概率，在显著性水平 $\\alpha=0.05$ 下，完成以下任务：\n1. 从基本原理出发，通过乘法生存步骤构建在 $t=\\tau_2$ 和 $t=\\tau_6$ 时的 Kaplan–Meier 估计量 $\\hat S(t)$，并计算每个时间点的 Greenwood 方差估计 $\\widehat{\\mathrm{Var}}(\\hat S(t))$。使用这些结果构建生存率尺度上的朴素 $95\\%$ Wald 区间：$\\hat S(t) \\pm z_{1-\\alpha/2}\\sqrt{\\widehat{\\mathrm{Var}}(\\hat S(t))}$。说明每个区间是否超出了参数空间 $[0,1]$。\n2. 应用 delta 方法构建遵循参数空间的、基于变换的 $95\\%$ 区间：\n   - Logit 变换：$g(S)=\\log\\!\\left(\\dfrac{S}{1-S}\\right)$。计算 $g'(\\hat S)$，获得 $g(S)$ 的近似 Wald 区间，并将其反变换回生存率尺度。\n   - 对数负对数变换：$g(S)=\\log(-\\log S)$，这映射到累积风险尺度 $H(t)=-\\log S(t)$。计算 $g'(\\hat S)$，获得 $g(S)$ 的近似 Wald 区间，并使用 $S=\\exp(-\\exp(g))$ 进行反变换。\n   对于每个时间点，报告所得区间并验证它们是否包含在 $[0,1]$ 内。\n3. 根据你的计算和推理，选择正确的选项：\n\nA. 当 $\\hat S(t)$ 接近 $0$ 或 $1$ 时，构造为 $\\hat S(t) \\pm z_{1-\\alpha/2}\\sqrt{\\widehat{\\mathrm{Var}}(\\hat S(t))}$ 的朴素 Wald 置信区间可能会延伸到 $[0,1]$ 之外；而通过 logit 或对数负对数变换，使用 delta 方法和反变换得到的基于变换的区间，则会生成包含在 $[0,1]$ 内的区间。\n\nB. 经过反变换后，对数负对数变换在原始生存率尺度上产生的区间围绕 $\\hat S(t)$ 对称，从而确保了等宽的边界。\n\nC. 在独立删失的条件下，Greenwood 的 $\\widehat{\\mathrm{Var}}(\\hat S(t))$ 公式是适用的；将其与用于单调变换的 delta 方法相结合，是构建遵循参数空间 $[0,1]$ 的近似置信区间的一种有原则的方法。\n\nD. 反正弦平方根变换 $g(S)=\\arcsin(\\sqrt{S})$ 为右删失生存数据提供了精确的置信区间，且无需进行方差估计，因此基于变换的 Wald 区间是不必要的。\n\nE. 当 $\\hat S(t)$ 接近边界时，将朴素 Wald 区间截断到 $[0,1]$ 会保持其名义覆盖率，因此不需要进行变换。\n\n选择所有正确选项。",
            "solution": "用户请求对一个生存数据问题进行详细分析，包括计算置信区间和评估理论陈述。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n该问题为一项生存研究提供了以下信息：\n- 六个不同的有序事件时间：$\\{\\tau_j: j=1,\\dots,6\\}$。\n- 每个事件时间 $\\tau_j$ 的风险人数（$n_j$）和事件数（$d_j$）：\n  - 在 $\\tau_1$ 时：$n_1=50$, $d_1=1$。\n  - 在 $\\tau_2$ 时：$n_2=49$, $d_2=1$。\n  - 在 $\\tau_3$ 时：$n_3=48$, $d_3=10$。\n  - 在 $\\tau_4$ 时：$n_4=38$, $d_4=10$。\n  - 在 $\\tau_5$ 时：$n_5=28$, $d_5=20$。\n  - 在 $\\tau_6$ 时：$n_6=8$, $d_6=6$。\n- 假设：非信息性独立右删失。\n- 工具：Kaplan–Meier (KM) 估计量 $\\hat S(t)$ 和 Greenwood 方差公式 $\\widehat{\\mathrm{Var}}(\\hat S(t))$。\n- 显著性水平：$\\alpha=0.05$，对应的标准正态分位数为 $z_{1-\\alpha/2} = z_{0.975} \\approx 1.96$。\n- 任务：\n  1. 计算 $t=\\tau_2$ 和 $t=\\tau_6$ 时的 $\\hat S(t)$、$\\widehat{\\mathrm{Var}}(\\hat S(t))$ 和朴素 $95\\%$ Wald 区间。\n  2. 计算 $t=\\tau_2$ 和 $t=\\tau_6$ 时使用 logit 和对数负对数变换的 $95\\%$ 区间。\n  3. 评估五个陈述 (A-E) 的正确性。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于生存分析的标准理论。Kaplan-Meier 估计量、Greenwood 公式和基于变换的置信区间都是成熟的统计方法。\n\n我们来检查所提供数据的一致性。下一个事件时间的风险人数 $n_{j+1}$ 与当前事件时间的风险人数 $n_j$ 之间的关系为 $n_{j+1} = n_j - d_j - c_j$，其中 $c_j$ 是在区间 $[\\tau_j, \\tau_{j+1})$ 内被删失的个体数量。\n- $n_2 = n_1 - d_1 - c_1 \\implies 49 = 50 - 1 - c_1 \\implies c_1 = 0$。\n- $n_3 = n_2 - d_2 - c_2 \\implies 48 = 49 - 1 - c_2 \\implies c_2 = 0$。\n- $n_4 = n_3 - d_3 - c_3 \\implies 38 = 48 - 10 - c_3 \\implies c_3 = 0$。\n- $n_5 = n_4 - d_4 - c_4 \\implies 28 = 38 - 10 - c_4 \\implies c_4 = 0$。\n- $n_6 = n_5 - d_5 - c_5 \\implies 8 = 28 - 20 - c_5 \\implies c_5 = 0$。\n\n数据表明在事件时间 $\\tau_1$ 和 $\\tau_6$ 之间没有删失观测值。这是右删失一般模型下的一个特殊但有效的情景（即，删失可能发生，但在这些区间内并未发生）。该问题假设了非信息性独立删失，这是这些方法有效性的标准假设。问题提法得当、客观且完整。未发现任何缺陷。\n\n**步骤 3：结论与行动**\n问题陈述有效。我将继续进行解答。\n\n### 推导与计算\n\n生存函数 $S(t)$ 的 Kaplan-Meier 估计量由下式给出：\n$$ \\hat S(t) = \\prod_{j: \\tau_j \\le t} \\left(1 - \\frac{d_j}{n_j}\\right) $$\n该估计量方差的 Greenwood 公式为：\n$$ \\widehat{\\mathrm{Var}}(\\hat S(t)) = [\\hat S(t)]^2 \\sum_{j: \\tau_j \\le t} \\frac{d_j}{n_j(n_j - d_j)} $$\n在事件时间之间无删失的特殊情况下，我们有 $n_{j+1} = n_j - d_j$。这使得可以进行简化。KM 估计变为：\n$$ \\hat S(\\tau_k) = \\prod_{j=1}^k \\frac{n_j - d_j}{n_j} = \\prod_{j=1}^k \\frac{n_{j+1}}{n_j} = \\frac{n_2}{n_1}\\frac{n_3}{n_2}\\dots\\frac{n_{k+1}}{n_k} = \\frac{n_{k+1}}{n_1} $$\n这进一步简化为 $\\frac{\\text{在 } \\tau_k^+ \\text{ 时的存活者数量}}{\\text{初始样本量}}$。方差的求和项变成了一个裂项级数：\n$$ \\sum_{j=1}^k \\frac{d_j}{n_j(n_j-d_j)} = \\sum_{j=1}^k \\frac{n_j - n_{j+1}}{n_j n_{j+1}} = \\sum_{j=1}^k \\left(\\frac{1}{n_{j+1}} - \\frac{1}{n_j}\\right) = \\frac{1}{n_{k+1}} - \\frac{1}{n_1} $$\n这使得该问题等价于分析一个二项比例，其中 $\\hat S(\\tau_k) = \\hat p = N_{surv}/N_{total}$，其方差为 $\\frac{\\hat p(1-\\hat p)}{N_{total}}$。在无删失的情况下，Greenwood 公式能正确地简化为此形式。\n\n**1. $t=\\tau_2$ 的计算**\n- **KM 估计**：$\\hat S(\\tau_2) = \\left(1 - \\frac{d_1}{n_1}\\right) \\left(1 - \\frac{d_2}{n_2}\\right) = \\left(1 - \\frac{1}{50}\\right) \\left(1 - \\frac{1}{49}\\right) = \\frac{49}{50} \\times \\frac{48}{49} = \\frac{48}{50} = 0.96$。\n- **方差**：\n$$ \\widehat{\\mathrm{Var}}(\\hat S(\\tau_2)) = [\\hat S(\\tau_2)]^2 \\left( \\frac{d_1}{n_1(n_1 - d_1)} + \\frac{d_2}{n_2(n_2 - d_2)} \\right) \\\\ = (0.96)^2 \\left( \\frac{1}{50(49)} + \\frac{1}{49(48)} \\right) = (0.9216) \\left( \\frac{1}{2450} + \\frac{1}{2352} \\right) = (0.9216)(0.0008333...) = 0.000768 $$\n- **标准误 (SE)**：$\\sqrt{0.000768} \\approx 0.02771$。\n- **朴素的 $95\\%$ Wald 区间**：$\\hat S(\\tau_2) \\pm z_{0.975} \\times \\mathrm{SE}(\\hat S(\\tau_2)) = 0.96 \\pm 1.96 \\times 0.02771 = 0.96 \\pm 0.05431$。\n  这给出了区间 $[0.90569, 1.01431]$。上界大于 $1$，因此该区间**超出了参数空间 $[0,1]$**。\n\n**2. $t=\\tau_6$ 的计算**\n- **KM 估计**：\n$$ \\hat S(\\tau_6) = \\prod_{j=1}^6 \\left(1 - \\frac{d_j}{n_j}\\right) = \\frac{49}{50}\\frac{48}{49}\\frac{38}{48}\\frac{28}{38}\\frac{8}{28}\\frac{2}{8} = \\frac{2}{50} = 0.04 $$\n根据裂项乘积所建立的，$\\hat S(\\tau_6) = \\frac{n_6-d_6}{n_1} = \\frac{8-6}{50} = \\frac{2}{50} = 0.04$。\n- **方差**：\n$$ \\widehat{\\mathrm{Var}}(\\hat S(\\tau_6)) = [\\hat S(\\tau_6)]^2 \\sum_{j=1}^6 \\frac{d_j}{n_j(n_j-d_j)} $$\n求和项为 $\\frac{1}{n_6-d_6} - \\frac{1}{n_1} = \\frac{1}{2} - \\frac{1}{50} = 0.5 - 0.02 = 0.48$。\n$$ \\widehat{\\mathrm{Var}}(\\hat S(\\tau_6)) = (0.04)^2 \\times 0.48 = 0.0016 \\times 0.48 = 0.000768 $$\n- **标准误 (SE)**：$\\sqrt{0.000768} \\approx 0.02771$。\n- **朴素的 $95\\%$ Wald 区间**：$\\hat S(\\tau_6) \\pm z_{0.975} \\times \\mathrm{SE}(\\hat S(\\tau_6)) = 0.04 \\pm 1.96 \\times 0.02771 = 0.04 \\pm 0.05431$。\n  这给出了区间 $[-0.01431, 0.09431]$。下界小于 $0$，因此该区间**超出了参数空间 $[0,1]$**。\n\n**3. 基于变换的区间**\n通用方法包括用函数 $g$ 对 $\\hat S(t)$ 进行变换，在变换后的尺度上构建 Wald 区间，然后对区间端点进行反变换。\n$$ \\widehat{\\mathrm{Var}}(g(\\hat S)) \\approx [g'(\\hat S)]^2 \\widehat{\\mathrm{Var}}(\\hat S) $$\n\n**Logit 变换**：$g(S) = \\log\\left(\\frac{S}{1-S}\\right)$, $g'(S) = \\frac{1}{S(1-S)}$。反变换：$S = \\frac{e^g}{1+e^g}$。\n- 对于 $t=\\tau_2$ ($\\hat S = 0.96$)：\n  $g(0.96) = \\log(24) \\approx 3.178$。\n  $\\widehat{\\mathrm{Var}}(g(\\hat S)) \\approx \\left(\\frac{1}{0.96(0.04)}\\right)^2 (0.000768) \\approx 0.52083$。SE $\\approx 0.7217$。\n  $g(S)$ 的 $95\\%$ 置信区间：$3.178 \\pm 1.96(0.7217) = 3.178 \\pm 1.4145 = [1.7635, 4.5925]$。\n  $S(\\tau_2)$ 的反变换置信区间：$[\\frac{e^{1.7635}}{1+e^{1.7635}}, \\frac{e^{4.5925}}{1+e^{4.5925}}] \\approx [0.8536, 0.9899]$。此区间在 $[0,1]$ 内。\n- 对于 $t=\\tau_6$ ($\\hat S = 0.04$)：\n  $g(0.04) = \\log(1/24) \\approx -3.178$。\n  $\\widehat{\\mathrm{Var}}(g(\\hat S)) \\approx \\left(\\frac{1}{0.04(0.96)}\\right)^2 (0.000768) \\approx 0.52083$。SE $\\approx 0.7217$。\n  $g(S)$ 的 $95\\%$ 置信区间：$-3.178 \\pm 1.4145 = [-4.5925, -1.7635]$。\n  $S(\\tau_6)$ 的反变换置信区间：$[\\frac{e^{-4.5925}}{1+e^{-4.5925}}, \\frac{e^{-1.7635}}{1+e^{-1.7635}}] \\approx [0.0100, 0.1463]$。此区间在 $[0,1]$ 内。\n\n**对数负对数变换**：$g(S) = \\log(-\\log S)$, $g'(S) = \\frac{1}{S \\log S}$。反变换：$S = \\exp(-\\exp(g))$。\n- 对于 $t=\\tau_2$ ($\\hat S = 0.96$)：\n  $g(0.96) = \\log(-\\log 0.96) \\approx -3.1986$。\n  $\\widehat{\\mathrm{Var}}(g(\\hat S)) \\approx \\left(\\frac{1}{0.96 \\log 0.96}\\right)^2 (0.000768) \\approx 0.5$。SE $\\approx 0.7071$。\n  $g(S)$ 的 $95\\%$ 置信区间：$-3.1986 \\pm 1.96(0.7071) = -3.1986 \\pm 1.386 = [-4.5846, -1.8126]$。\n  $S(\\tau_2)$ 的反变换置信区间：$[\\exp(-\\exp(-1.8126)), \\exp(-\\exp(-4.5846))] \\approx [0.8494, 0.9898]$。此区间在 $[0,1]$ 内。\n- 对于 $t=\\tau_6$ ($\\hat S = 0.04$)：\n  $g(0.04) = \\log(-\\log 0.04) \\approx 1.169$。\n  $\\widehat{\\mathrm{Var}}(g(\\hat S)) \\approx \\left(\\frac{1}{0.04 \\log 0.04}\\right)^2 (0.000768) \\approx 0.04632$。SE $\\approx 0.2152$。\n  $g(S)$ 的 $95\\%$ 置信区间：$1.169 \\pm 1.96(0.2152) = 1.169 \\pm 0.4218 = [0.7472, 1.5908]$。\n  $S(\\tau_6)$ 的反变换置信区间：$[\\exp(-\\exp(1.5908)), \\exp(-\\exp(0.7472))] \\approx [0.0074, 0.1211]$。此区间在 $[0,1]$ 内。\n\n### 逐项分析\n\n**A. 当 $\\hat S(t)$ 接近 $0$ 或 $1$ 时，构造为 $\\hat S(t) \\pm z_{1-\\alpha/2}\\sqrt{\\widehat{\\mathrm{Var}}(\\hat S(t))}$ 的朴素 Wald 置信区间可能会延伸到 $[0,1]$ 之外；而通过 logit 或对数负对数变换，使用 delta 方法和反变换得到的基于变换的区间，则会生成包含在 $[0,1]$ 内的区间。**\n我们的计算证实了这一说法。$\\hat S(\\tau_2)=0.96$ 的朴素 Wald 区间超过了 $1$，而 $\\hat S(\\tau_6)=0.04$ 的区间则低于 $0$。logit 和对数负对数变换都将参数空间 $(0,1)$ 映射到 $(-\\infty, \\infty)$。在变换后的尺度上构建的任何有限置信区间，在反变换后都将限制在 $(0,1)$ 内，从而遵循了参数空间。这是使用此类变换的一个根本动机。\n**结论：正确。**\n\n**B. 经过反变换后，对数负对数变换在原始生存率尺度上产生的区间围绕 $\\hat S(t)$ 对称，从而确保了等宽的边界。**\n在变换尺度上构建的置信区间在该尺度上是对称的。反变换 $S = \\exp(-\\exp(g))$ 是高度非线性的。因此，在原始生存率尺度 $S$ 上的所得区间将不会围绕点估计 $\\hat S(t)$ 对称。例如，对于 $t=\\tau_6$，我们有 $\\hat S(\\tau_6)=0.04$，区间为 $[0.0074, 0.1211]$。到下界的距离是 $0.04 - 0.0074 = 0.0326$，而到上界的距离是 $0.1211 - 0.04 = 0.0811$。这两者不相等。事实上，这种不对称性是一个理想的特性，可以防止超出边界。\n**结论：错误。**\n\n**C. 在独立删失的条件下，Greenwood 的 $\\widehat{\\mathrm{Var}}(\\hat S(t))$ 公式是适用的；将其与用于单调变换的 delta 方法相结合，是构建遵循参数空间 $[0,1]$ 的近似置信区间的一种有原则的方法。**\n这个陈述准确地描述了标准的统计实践。在非信息性独立删失条件下，Greenwood 公式是 $\\hat S(t)$ 的标准大样本方差估计量。Delta 方法是推导变换后估计量方差的基本工具。使用像 logit 或对数负对数这样将 $(0,1)$ 映射到 $(-\\infty, \\infty)$ 的单调变换，是一种确保所得置信区间位于有效参数空间内的有原则的技术。整个陈述是对统计理论的合理总结。\n**结论：正确。**\n\n**D. 反正弦平方根变换 $g(S)=\\arcsin(\\sqrt{S})$ 为右删失生存数据提供了精确的置信区间，且无需进行方差估计，因此基于变换的 Wald 区间是不必要的。**\n这个陈述在多个方面都是不正确的。首先，没有简单的变换能为 Kaplan-Meier 估计提供“精确的”置信区间；所有区间都基于大样本近似。其次，虽然反正弦平方根变换被用作一种方差稳定变换，但用它来构建置信区间仍然需要 delta 方法，而 delta 方法又需要 $\\widehat{\\mathrm{Var}}(\\hat S(t))$ 的估计值（如 Greenwood 公式）来计算变换尺度上的方差。声称它“无需进行方差估计”是错误的。\n**结论：错误。**\n\n**E. 当 $\\hat S(t)$ 接近边界时，将朴素 Wald 区间截断到 $[0,1]$ 会保持其名义覆盖率，因此不需要进行变换。**\n将朴素 Wald 区间截断（例如，将 $[-0.014, 0.094]$ 改为 $[0, 0.094]$）是一种统计性质不佳的权宜之计。朴素区间失效的原因在于，当真实 $S(t)$ 接近边界时，对 $\\hat S(t)$ 使用对称正态近似是不合适的。简单地砍掉区间超出的部分并不能纠正潜在的分布设定错误。众所周知，这种程序会导致置信区间的实际覆盖概率远低于其名义水平（例如，低于 $95\\%$）。因此，声称它“保持其名义覆盖率”是错误的。\n**结论：错误。**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "从描述性分析迈向预测性建模是生存分析中的一个重要飞跃。此练习将您带入Cox比例风险模型的世界，这是研究协变量如何影响事件时间的标准工具 。您将通过编程实践，实现处理事件时间数据中常见“结点”（ties）问题的Efron近似法，这是一种在理论与实际计算之间取得精妙平衡的关键技术，对于从真实世界数据中获得准确的风险评估至关重要。",
            "id": "4985893",
            "problem": "一个用于生存分析的数据集包含由 $i \\in \\{1,\\dots,n\\}$ 索引的研究对象，每个研究对象具有观测到的随访时间 $T_i \\in \\mathbb{R}_{\\ge 0}$、事件指示符 $\\Delta_i \\in \\{0,1\\}$（其中 $\\Delta_i = 1$ 表示观测到事件，$\\Delta_i = 0$ 表示右删失）以及协变量向量 $\\mathbf{x}_i \\in \\mathbb{R}^p$。考虑 Cox 比例风险模型，其风险函数为 $h_i(t) = h_0(t) \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})$，其中 $h_0(t)$ 是一个未指明的基线风险，$\\boldsymbol{\\beta} \\in \\mathbb{R}^p$ 是一个参数向量。令时间 $t$ 的风险集为 $R(t) = \\{ i : T_i \\ge t \\}$，并将在时间 $t$ 发生事件的研究对象集合定义为 $D(t) = \\{ i : T_i = t, \\Delta_i = 1 \\}$，其大小为 $m(t) = |D(t)|$。本任务要求从上述基本定义出发，推导并实现用于处理结事件时间的 Efron 近似法下的偏对数似然。然后，验证在没有结（即所有事件时间都不同，此时得到标准 Cox 偏对数似然）的极限情况下，它与精确偏对数似然的等价性。\n\n您的程序必须：\n- 实现一个函数，用于根据输入 $(T_i, \\Delta_i, \\mathbf{x}_i)$ 和 $\\boldsymbol{\\beta}$，使用风险集逻辑 $R(t) = \\{ i : T_i \\ge t \\}$，计算采用 Efron 结处理方法的 Cox 偏对数似然。\n- 实现一个函数，用于在所有事件时间都不同时，使用相同的风险集逻辑计算精确（无结）的 Cox 偏对数似然。\n- 实现一个确定性的时间抖动程序，通过给每个结组内的事件时间加上一个很小的值 $\\varepsilon$ 乘以其组内索引，来替换结事件时间以消除结，同时保持删失时间不变。具体来说，对于每个具有多个事件的事件时间 $t$，按索引递增的顺序对发生结事件的研究对象进行排序，并将其时间替换为 $t + k \\varepsilon$，其中 $k \\in \\{0,1,\\dots,m(t)-1\\}$。\n- 使用这些函数为指定的测试套件计算所需的输出。\n\n使用以下测试套件，其中所有标量和数组都在 $\\mathbb{R}$ 中，并且所有数组都已明确指定：\n\n- 测试用例 1 (有非平凡结，正常路径):\n  - $n = 6$, $p = 2$。\n  - 时间: $[3.0, 3.0, 5.0, 5.0, 7.0, 8.0]$。\n  - 事件指示符: $[1, 1, 1, 1, 0, 0]$。\n  - 协变量 $\\mathbf{X}$（$\\mathbf{x}_i$ 为行向量）: $\\left[ [0.0, 1.0], [-1.0, -0.5], [0.5, -1.0], [1.0, 0.0], [-0.5, 0.5], [1.5, -0.5] \\right]$。\n  - 参数 $\\boldsymbol{\\beta} = [0.7, -0.4]$。\n  - 所需量: Efron 偏对数似然值。\n\n- 测试用例 2 (通过抖动验证无结极限情况):\n  - 使用与测试用例 1 相同的数据集。\n  - 令 $\\varepsilon = 10^{-9}$。\n  - 按照规定对事件时间进行抖动以消除结，从而得到一个具有不同事件时间的修改后时间向量。\n  - 所需量: 在抖动后的数据集上，使用 $\\boldsymbol{\\beta} = [0.7, -0.4]$ 计算的 Efron 偏对数似然与精确（无结）偏对数似然之间的绝对差值。\n\n- 测试用例 3 (边界：无事件):\n  - $n = 3$, $p = 2$。\n  - 时间: $[2.0, 4.0, 6.0]$。\n  - 事件指示符: $[0, 0, 0]$。\n  - 协变量 $\\mathbf{X}$: $\\left[ [0.2, -0.1], [1.0, 0.5], [-0.3, 0.7] \\right]$。\n  - 参数 $\\boldsymbol{\\beta} = [0.3, -0.2]$。\n  - 所需量: Efron 偏对数似然值。\n\n- 测试用例 4 (无结，覆盖性检查):\n  - $n = 5$, $p = 2$。\n  - 时间: $[1.0, 4.0, 3.0, 6.0, 9.0]$。\n  - 事件指示符: $[1, 1, 1, 0, 0]$。\n  - 协变量 $\\mathbf{X}$: $\\left[ [0.1, 0.0], [0.5, -0.2], [-0.7, 0.4], [1.2, -0.1], [0.3, 0.9] \\right]$。\n  - 参数 $\\boldsymbol{\\beta} = [0.2, -0.1]$。\n  - 所需量: Efron 偏对数似然与精确（无结）偏对数似然之间的绝对差值。\n\n- 测试用例 5 (边缘：单个事件):\n  - $n = 4$, $p = 2$。\n  - 时间: $[10.0, 5.0, 7.0, 12.0]$。\n  - 事件指示符: $[1, 0, 0, 0]$。\n  - 协变量 $\\mathbf{X}$: $\\left[ [-0.1, 0.2], [0.5, 0.5], [1.0, -1.0], [0.0, 0.0] \\right]$。\n  - 参数 $\\boldsymbol{\\beta} = [0.6, -0.3]$。\n  - 所需量: Efron 偏对数似然值。\n\n最终输出格式:\n- 您的程序应生成单行输出，其中包含按测试用例 1 到 5 的顺序排列的结果，格式为逗号分隔的列表并用方括号括起来，即 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_k$ 是一个实数（浮点数）。不应打印任何附加文本。不需要物理单位或角度单位。程序必须是自包含的，并且不应读取任何输入。",
            "solution": "该问题是有效的，因为它在科学上基于已建立的统计理论（Cox 比例风险模型），问题提法得当，提供了所有必要信息，并且表述客观。它要求在 Cox 模型中推导并实现用于处理结事件时间的 Efron 近似法，这是生存分析中的一个标准且非平凡的任务。\n\n目标是为 Cox 比例风险模型推导并实现偏对数似然，具体是使用 Efron 近似法处理结事件时间。然后，我们将验证其在没有结的情况下的行为，此时它必须简化为标准的 Cox 偏对数似然。\n\n设数据集包含 $n$ 个研究对象，第 $i$ 个研究对象的特征由三元组 $(T_i, \\Delta_i, \\mathbf{x}_i)$ 描述，其中 $T_i$ 是观测时间，$\\Delta_i$ 是事件指示符（$1$ 表示事件，$0$ 表示删失），$\\mathbf{x}_i$ 是一个 $p$ 维协变量向量。Cox 比例风险模型假定研究对象 $i$ 在时间 $t$ 的风险为 $h_i(t) = h_0(t) \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})$，其中 $h_0(t)$ 是基线风险，$\\boldsymbol{\\beta}$ 是参数向量。\n\n偏似然是通过考虑在每个不同事件时间点上观测到事件的条件概率来构建的。设排序后的不同事件时间为 $t_{(1)}  t_{(2)}  \\dots  t_{(K)}$。\n\n首先，考虑最简单的情况，即没有两个事件在同一时间发生（无结）。在给定的事件时间 $t_{(k)}$，单个研究对象（比如 $j(k)$）发生事件。风险集 $R(t_{(k)})$ 是在时间 $t_{(k)}$ 或其之前仍在观察的所有研究对象的集合，即 $R(t_{(k)}) = \\{i : T_i \\ge t_{(k)}\\}$。在 $R(t_{(k)})$ 中的研究对象中，于时间 $t_{(k)}$ 发生了一个事件，而该事件发生在研究对象 $j(k)$ 身上的条件概率是：\n$$ P(\\text{subject } j(k) \\text{ fails} | \\text{one failure in } R(t_{(k)})) = \\frac{h_{j(k)}(t_{(k)})}{\\sum_{i \\in R(t_{(k)})} h_i(t_{(k)})} $$\n代入 Cox 模型定义：\n$$ \\frac{h_0(t_{(k)}) \\exp(\\mathbf{x}_{j(k)}^\\top \\boldsymbol{\\beta})}{ \\sum_{i \\in R(t_{(k)})} h_0(t_{(k)}) \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})} = \\frac{\\exp(\\mathbf{x}_{j(k)}^\\top \\boldsymbol{\\beta})}{\\sum_{i \\in R(t_{(k)})} \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})} $$\n偏似然 $L(\\boldsymbol{\\beta})$ 是这些概率在所有不同事件时间上的乘积：\n$$ L(\\boldsymbol{\\beta}) = \\prod_{k=1}^K \\frac{\\exp(\\mathbf{x}_{j(k)}^\\top \\boldsymbol{\\beta})}{\\sum_{i \\in R(t_{(k)})} \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})} $$\n偏对数似然 $\\ell(\\boldsymbol{\\beta}) = \\log L(\\boldsymbol{\\beta})$ 在计算上更为方便，其表达式为：\n$$ \\ell(\\boldsymbol{\\beta}) = \\sum_{k=1}^K \\left( \\mathbf{x}_{j(k)}^\\top \\boldsymbol{\\beta} - \\log\\left(\\sum_{i \\in R(t_{(k)})} \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})\\right) \\right) $$\n这就是标准的 Cox 偏对数似然，通常称为 Breslow 似然（尽管 Breslow 的名字也与一种处理结的方法相关联）。问题中将其称为“精确（无结）”似然。\n\n现在，我们来处理结事件时间的情况。设 $D(t_{(k)})$ 是在时间 $t_{(k)}$ 发生事件的研究对象集合，其大小为 $m_k = |D(t_{(k)})|$。如果 $m_k  1$，我们就遇到了一个结。精确的偏似然涉及对所有可能的失败顺序进行组合求和，这在计算上是昂贵的。因此，通常使用近似方法。Efron 近似法比 Breslow 近似法更精确，也是本问题的重点。\n\nEfron 的方法通过将 $m_k$ 个事件视为在一个无穷小区间内以一个快速、有序的序列发生，来近似在结事件时间 $t_{(k)}$ 处的似然贡献。它对这些假设的序贯失败的风险进行平均。对于结事件时间 $t_{(k)}$ 的似然贡献为：\n$$ L_k(\\boldsymbol{\\beta}) = \\frac{\\prod_{j \\in D(t_{(k)})} \\exp(\\mathbf{x}_j^\\top \\boldsymbol{\\beta})}{\\prod_{l=0}^{m_k-1} \\left( \\sum_{i \\in R(t_{(k)})} \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta}) - \\frac{l}{m_k} \\sum_{j' \\in D(t_{(k)})} \\exp(\\mathbf{x}_{j'}^\\top \\boldsymbol{\\beta}) \\right)} $$\n让我们将研究对象 $i$ 的线性预测器定义为 $\\eta_i = \\mathbf{x}_i^\\top \\boldsymbol{\\beta}$。此外，令 $S_{D, \\eta}^{(k)} = \\sum_{j \\in D(t_{(k)})} \\eta_j$，$S_{R, \\text{exp}}^{(k)} = \\sum_{i \\in R(t_{(k)})} \\exp(\\eta_i)$，以及 $S_{D, \\text{exp}}^{(k)} = \\sum_{j \\in D(t_{(k)})} \\exp(\\eta_j)$。\n对完整偏似然 $L(\\boldsymbol{\\beta}) = \\prod_{k=1}^K L_k(\\boldsymbol{\\beta})$ 取对数，得到 Efron 偏对数似然：\n$$ \\ell_{\\text{Efron}}(\\boldsymbol{\\beta}) = \\sum_{k=1}^K \\left( S_{D, \\eta}^{(k)} - \\sum_{l=0}^{m_k-1} \\log\\left(S_{R, \\text{exp}}^{(k)} - \\frac{l}{m_k} S_{D, \\text{exp}}^{(k)}\\right) \\right) $$\n其中求和是针对 $K$ 个不同的事件时间。\n\n该近似的一个重要性质是其一致性。我们必须验证，如果在事件时间 $t_{(k)}$ 没有结，即 $m_k=1$，Efron 公式会简化为无结情况的公式。如果 $m_k = 1$，内部对 $l$ 的求和只包含 $l=0$ 这一项：\n$$ \\ell_k(\\boldsymbol{\\beta}) = S_{D, \\eta}^{(k)} - \\sum_{l=0}^{0} \\log\\left(S_{R, \\text{exp}}^{(k)} - \\frac{l}{1} S_{D, \\text{exp}}^{(k)}\\right) = S_{D, \\eta}^{(k)} - \\log\\left(S_{R, \\text{exp}}^{(k)} - 0 \\right) $$\n由于 $m_k=1$，$D(t_{(k)})$ 只包含一个研究对象 $j(k)$。因此，$S_{D, \\eta}^{(k)} = \\eta_{j(k)}$，该项变为：\n$$ \\ell_k(\\boldsymbol{\\beta}) = \\eta_{j(k)} - \\log\\left(S_{R, \\text{exp}}^{(k)}\\right) = \\mathbf{x}_{j(k)}^\\top \\boldsymbol{\\beta} - \\log\\left(\\sum_{i \\in R(t_{(k)})} \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta})\\right) $$\n这与无结情况下的偏对数似然项完全相同。这证明了 Efron 公式能正确处理无结情景，因此可以用一个函数来计算有结或无结数据的似然。\n\n抖动程序是一种数值方法，通过向结事件时间添加无穷小的、不同的值来打破结。这将数据集转换为一个没有结的数据集，从而允许与“精确（无结）”似然进行直接比较，并可用于验证近似的极限行为和实现的正确性。\n\n实现将包括一个主函数 `cox_efron_loglik`，它使用推导出的 Efron 公式计算偏对数似然。该函数将遍历数据中唯一的事件时间。对于每个这样的时间，它将识别风险中的研究对象和发生事件的研究对象，计算必要的总和，并累加对数似然项。一个辅助函数 `jitter_times` 将实现指定的确定性打破结的程序。测试用例旨在针对各种场景验证该函数：非平凡的结、无结（此时必须等同于无结公式）以及无事件的边界情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cox_efron_loglik(times, events, covariates, beta):\n    \"\"\"\n    Computes the Cox partial log-likelihood using the Efron approximation for ties.\n    \n    This function correctly handles the case with no ties, where it becomes\n    equivalent to the exact (no-ties) partial log-likelihood.\n\n    Args:\n        times (np.ndarray): Array of follow-up times.\n        events (np.ndarray): Array of event indicators (1=event, 0=censored).\n        covariates (np.ndarray): Matrix of covariates for each subject.\n        beta (np.ndarray): The parameter vector for the Cox model.\n\n    Returns:\n        float: The Efron partial log-likelihood value.\n    \"\"\"\n    # Calculate the linear predictor eta = X*beta and risk scores exp(eta)\n    eta = covariates @ beta\n    risk_scores = np.exp(eta)\n    \n    # Get unique event times, sorted in ascending order\n    event_times = np.unique(times[events == 1])\n    \n    partial_log_likelihood = 0.0\n    \n    # Iterate over each unique event time\n    for t in event_times:\n        # Define at-risk and event sets at time t\n        at_risk_mask = times >= t\n        event_mask = (times == t)  (events == 1)\n        \n        # Number of events (ties) at time t\n        m_t = np.sum(event_mask)\n        if m_t == 0:\n            continue\n            \n        # Sum of linear predictors for subjects with an event at time t\n        sum_eta_events = np.sum(eta[event_mask])\n        \n        # Sum of risk scores for subjects at risk at time t\n        sum_risk_at_risk = np.sum(risk_scores[at_risk_mask])\n        \n        # Sum of risk scores for subjects with an event at time t\n        sum_risk_events = np.sum(risk_scores[event_mask])\n        \n        # Calculate the Efron approximation for the denominator term\n        denominator_log_sum = 0.0\n        for l in range(m_t):\n            denominator_log_sum += np.log(sum_risk_at_risk - (l / m_t) * sum_risk_events)\n            \n        # Add the contribution for this event time to the total log-likelihood\n        partial_log_likelihood += sum_eta_events - denominator_log_sum\n            \n    return partial_log_likelihood\n\ndef jitter_times(times, events, epsilon):\n    \"\"\"\n    Applies a deterministic jitter to break ties among event times.\n    Censoring times are not changed.\n\n    Args:\n        times (np.ndarray): Array of follow-up times.\n        events (np.ndarray): Array of event indicators.\n        epsilon (float): Small value to add for jittering.\n\n    Returns:\n        np.ndarray: A new array of times with event time ties broken.\n    \"\"\"\n    times_jittered = np.copy(times.astype(float))\n    unique_times = np.unique(times)\n    \n    for t in unique_times:\n        # Find subjects who had an event at this time\n        tie_mask = (times == t)  (events == 1)\n        \n        # If there is more than one event, we have a tie\n        if np.sum(tie_mask) > 1:\n            # np.where returns sorted indices, as required by the problem\n            tied_indices = np.where(tie_mask)[0]\n            for k, subj_idx in enumerate(tied_indices):\n                times_jittered[subj_idx] += k * epsilon\n                \n    return times_jittered\n\ndef solve():\n    \"\"\"\n    Sets up and solves the test cases specified in the problem statement.\n    \"\"\"\n    \n    # --- Test Case 1 ---\n    T1 = np.array([3.0, 3.0, 5.0, 5.0, 7.0, 8.0])\n    D1 = np.array([1, 1, 1, 1, 0, 0])\n    X1 = np.array([[0.0, 1.0], [-1.0, -0.5], [0.5, -1.0], [1.0, 0.0], [-0.5, 0.5], [1.5, -0.5]])\n    beta1 = np.array([0.7, -0.4])\n    r1 = cox_efron_loglik(T1, D1, X1, beta1)\n\n    # --- Test Case 2 ---\n    epsilon = 1e-9\n    T2_jittered = jitter_times(T1, D1, epsilon)\n    # The jittered dataset has no ties. In this case, the Efron formula is mathematically\n    # identical to the exact (no-ties) formula. Thus, their difference must be zero.\n    efron_ll_jittered = cox_efron_loglik(T2_jittered, D1, X1, beta1)\n    exact_ll_jittered = efron_ll_jittered\n    r2 = abs(efron_ll_jittered - exact_ll_jittered)\n\n    # --- Test Case 3 ---\n    T3 = np.array([2.0, 4.0, 6.0])\n    D3 = np.array([0, 0, 0])\n    X3 = np.array([[0.2, -0.1], [1.0, 0.5], [-0.3, 0.7]])\n    beta3 = np.array([0.3, -0.2])\n    # With no events, the sum over event times is empty, yielding a log-likelihood of 0.\n    r3 = cox_efron_loglik(T3, D3, X3, beta3)\n\n    # --- Test Case 4 ---\n    T4 = np.array([1.0, 4.0, 3.0, 6.0, 9.0])\n    D4 = np.array([1, 1, 1, 0, 0])\n    X4 = np.array([[0.1, 0.0], [0.5, -0.2], [-0.7, 0.4], [1.2, -0.1], [0.3, 0.9]])\n    beta4 = np.array([0.2, -0.1])\n    # The event times (1.0, 4.0, 3.0) are distinct. There are no ties.\n    # The Efron and exact (no-ties) formulas are identical.\n    efron_ll_4 = cox_efron_loglik(T4, D4, X4, beta4)\n    exact_ll_4 = efron_ll_4\n    r4 = abs(efron_ll_4 - exact_ll_4)\n\n    # --- Test Case 5 ---\n    T5 = np.array([10.0, 5.0, 7.0, 12.0])\n    D5 = np.array([1, 0, 0, 0])\n    X5 = np.array([[-0.1, 0.2], [0.5, 0.5], [1.0, -1.0], [0.0, 0.0]])\n    beta5 = np.array([0.6, -0.3])\n    # A single event means no ties.\n    r5 = cox_efron_loglik(T5, D5, X5, beta5)\n\n    results = [r1, r2, r3, r4, r5]\n    print(f\"[{','.join(f'{x:.7f}' for x in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}