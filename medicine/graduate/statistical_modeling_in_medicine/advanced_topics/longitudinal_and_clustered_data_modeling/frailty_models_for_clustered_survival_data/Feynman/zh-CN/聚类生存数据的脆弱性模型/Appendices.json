{
    "hands_on_practices": [
        {
            "introduction": "脆性模型的一个核心目标是量化由共享脆性引起的组内相关性。将模型的方差参数（如 $\\theta$）与一个可解释的依赖性度量联系起来至关重要。此练习将指导您推导在共享伽马脆性模型中，脆性方差与经典的非参数关联度量——肯德尔相关系数 (Kendall's tau) 之间的精确关系。通过这个过程 ，您将深入理解模型参数如何转化为对组内生存时间排序一致性的可量化预测。",
            "id": "4963406",
            "problem": "一项关于聚集生存时间的队列研究使用共享脆弱性模型进行建模。对于每个簇，设未观测到的脆弱性为 $Z$，并假设 $Z \\sim \\operatorname{Gamma}(1/\\theta, 1/\\theta)$，其中参数化使用形状 $1/\\theta$ 和速率 $1/\\theta$，因此 $\\mathbb{E}[Z]=1$ 且 $\\operatorname{Var}(Z)=\\theta$。在给定 $Z$ 和协变量向量 $\\boldsymbol{x}$ 的条件下，个体在时间 $t$ 的风险率由 $h(t \\mid Z, \\boldsymbol{x}) = Z\\, h_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})$ 给出，其中基线风险率为 $h_{0}(t)$，回归系数向量为 $\\boldsymbol{\\beta}$。考虑同一簇中具有相同协变量的两个个体，即 $\\boldsymbol{x}_{1}=\\boldsymbol{x}_{2}=\\boldsymbol{x}$。\n\n从共享脆弱性模型的定义和脆弱性分布的拉普拉斯变换出发，推导连接该模型引出的两个边际生存函数的Copula函数，并根据该Copula函数族的肯德尔τ的定义，求出肯德尔τ作为 $\\theta$ 的函数。然后在 $\\theta=0.8$ 处计算其值。\n\n最后，简要解释对于同一簇中具有可比协变量的两个可交换个体，该依赖性度量的大小所代表的意义。\n\n将您的最终数值答案表示为精确分数（不要四舍五入）。",
            "solution": "该问题要求推导共享伽玛脆弱性模型的Copula函数，随后推导肯德尔τ（$\\tau$），在特定参数值下进行计算，并对结果进行解释。\n\n**步骤 1：问题验证**\n\n给定条件如下：\n- 一个用于聚集生存时间的共享脆弱性模型。\n- 未观测到的脆弱性 $Z \\sim \\operatorname{Gamma}(1/\\theta, 1/\\theta)$，其形状参数为 $\\alpha = 1/\\theta$，速率参数为 $\\lambda = 1/\\theta$。\n- $\\mathbb{E}[Z]=1$ 且 $\\operatorname{Var}(Z)=\\theta$。\n- 条件风险函数：$h(t \\mid Z, \\boldsymbol{x}) = Z\\, h_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})$。\n- 同一簇中具有相同协变量的两个个体：$\\boldsymbol{x}_{1}=\\boldsymbol{x}_{2}=\\boldsymbol{x}$。\n\n该问题具有科学依据，是统计生存分析中的一个标准练习。问题本身是适定的，有足够的信息来推导唯一解。语言客观且精确。因此，该问题被认为是有效的。\n\n**步骤 2：边际和联合生存函数的推导**\n\n首先，我们通过对条件风险函数 $h(t \\mid Z, \\boldsymbol{x})$ 关于时间 $t$ 积分，来确定条件累积风险函数 $H(t \\mid Z, \\boldsymbol{x})$：\n$$\nH(t \\mid Z, \\boldsymbol{x}) = \\int_{0}^{t} h(u \\mid Z, \\boldsymbol{x}) du = \\int_{0}^{t} Z\\, h_{0}(u)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta}) du\n$$\n$$\nH(t \\mid Z, \\boldsymbol{x}) = Z\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta}) \\int_{0}^{t} h_{0}(u) du = Z\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\n$$\n其中 $H_{0}(t)$ 是基线累积风险函数。\n\n条件生存函数 $S(t \\mid Z, \\boldsymbol{x})$ 由下式给出：\n$$\nS(t \\mid Z, \\boldsymbol{x}) = \\exp(-H(t \\mid Z, \\boldsymbol{x})) = \\exp(-Z\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta}))\n$$\n边际生存函数 $S(t \\mid \\boldsymbol{x})$ 是通过对条件生存函数关于脆弱性分布 $Z$ 求期望得到的：\n$$\nS(t \\mid \\boldsymbol{x}) = \\mathbb{E}_{Z}[S(t \\mid Z, \\boldsymbol{x})] = \\mathbb{E}_{Z}[\\exp(-Z \\cdot (H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})))]\n$$\n这个表达式是 $Z$ 分布的拉普拉斯变换，记为 $\\mathcal{L}_{Z}(s)$，在 $s = H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})$ 处求值。对于形状参数为 $\\alpha$、速率参数为 $\\lambda$ 的伽玛分布，其拉普拉斯变换为 $\\mathcal{L}_{Z}(s) = \\left(\\frac{\\lambda}{\\lambda+s}\\right)^{\\alpha}$。\n给定 $Z \\sim \\operatorname{Gamma}(\\alpha=1/\\theta, \\lambda=1/\\theta)$，其拉普拉斯变换为：\n$$\n\\mathcal{L}_{Z}(s) = \\left(\\frac{1/\\theta}{1/\\theta+s}\\right)^{1/\\theta} = \\left(\\frac{1}{1+\\theta s}\\right)^{1/\\theta}\n$$\n将 $s = H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})$ 代入，得到边际生存函数：\n$$\nS(t \\mid \\boldsymbol{x}) = \\left(1 + \\theta\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\\right)^{-1/\\theta}\n$$\n现在，考虑来自同一簇的两个个体的联合生存函数 $S(t_{1}, t_{2} \\mid \\boldsymbol{x})$。因为他们的生存时间 $T_{1}$ 和 $T_{2}$ 在给定 $Z$ 的条件下是独立的，我们有：\n$$\nS(t_{1}, t_{2} \\mid Z, \\boldsymbol{x}) = S(t_{1} \\mid Z, \\boldsymbol{x}) S(t_{2} \\mid Z, \\boldsymbol{x}) = \\exp\\left(-Z \\left(H_{0}(t_{1}) + H_{0}(t_{2})\\right) \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\\right)\n$$\n边际联合生存函数是关于 $Z$ 的期望：\n$$\nS(t_{1}, t_{2} \\mid \\boldsymbol{x}) = \\mathbb{E}_{Z}[S(t_{1}, t_{2} \\mid Z, \\boldsymbol{x})] = \\mathcal{L}_{Z}\\left((H_{0}(t_{1}) + H_{0}(t_{2})) \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\\right)\n$$\n$$\nS(t_{1}, t_{2} \\mid \\boldsymbol{x}) = \\left(1 + \\theta (H_{0}(t_{1}) + H_{0}(t_{2})) \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\\right)^{-1/\\theta}\n$$\n\n**步骤 3：Copula的推导**\n\n根据 Sklar 定理，联合生存函数可以通过一个连接边际生存函数的Copula函数 $C$ 来表示。设 $u_{1} = S(t_{1} \\mid \\boldsymbol{x})$ 和 $u_{2} = S(t_{2} \\mid \\boldsymbol{x})$。我们必须用 $u_{1}$ 和 $u_{2}$ 来表示 $S(t_{1}, t_{2} \\mid \\boldsymbol{x})$。从边际生存函数的表达式中：\n$$\nu = \\left(1 + \\theta\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\\right)^{-1/\\theta}\n$$\n我们可以解出项 $\\theta\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})$：\n$$\nu^{-\\theta} = 1 + \\theta\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta}) \\implies \\theta\\, H_{0}(t)\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta}) = u^{-\\theta} - 1\n$$\n现在，将此结果代回联合生存函数的表达式中：\n$$\nS(t_{1}, t_{2} \\mid \\boldsymbol{x}) = \\left(1 + \\theta\\, H_{0}(t_{1})\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta}) + \\theta\\, H_{0}(t_{2})\\, \\exp(\\boldsymbol{x}^{\\top}\\boldsymbol{\\beta})\\right)^{-1/\\theta}\n$$\n$$\nS(t_{1}, t_{2} \\mid \\boldsymbol{x}) = \\left(1 + (u_{1}^{-\\theta} - 1) + (u_{2}^{-\\theta} - 1)\\right)^{-1/\\theta}\n$$\n$$\nC(u_{1}, u_{2}) = S(t_{1}, t_{2} \\mid \\boldsymbol{x}) = \\left(u_{1}^{-\\theta} + u_{2}^{-\\theta} - 1\\right)^{-1/\\theta}\n$$\n这是参数为 $\\theta$ 的 Clayton copula。\n\n**步骤 4：肯德尔τ（$\\tau$）的推导**\n\n推导出的Copula是阿基米德族的一员，其生成元为 $\\phi(t) = \\frac{t^{-\\theta}-1}{\\theta}$。对于一个阿基米德Copula，肯德尔τ由以下公式给出：\n$$\n\\tau = 1 + 4 \\int_{0}^{1} \\frac{\\phi(t)}{\\phi'(t)} dt\n$$\n生成元的导数是：\n$$\n\\phi'(t) = \\frac{d}{dt}\\left(\\frac{t^{-\\theta}-1}{\\theta}\\right) = \\frac{1}{\\theta}(-\\theta t^{-\\theta-1}) = -t^{-\\theta-1}\n$$\n比值 $\\phi(t)/\\phi'(t)$ 是：\n$$\n\\frac{\\phi(t)}{\\phi'(t)} = \\frac{(t^{-\\theta}-1)/\\theta}{-t^{-\\theta-1}} = -\\frac{t^{-\\theta}-1}{\\theta t^{-\\theta-1}} = -\\frac{t(1-t^{\\theta})}{\\theta}\n$$\n将此代入 $\\tau$ 的积分中：\n$$\n\\tau = 1 + 4 \\int_{0}^{1} \\left(-\\frac{t(1-t^{\\theta})}{\\theta}\\right) dt = 1 - \\frac{4}{\\theta} \\int_{0}^{1} (t-t^{\\theta+1}) dt\n$$\n计算该积分：\n$$\n\\int_{0}^{1} (t-t^{\\theta+1}) dt = \\left[\\frac{t^{2}}{2} - \\frac{t^{\\theta+2}}{\\theta+2}\\right]_{0}^{1} = \\frac{1}{2} - \\frac{1}{\\theta+2} = \\frac{(\\theta+2)-2}{2(\\theta+2)} = \\frac{\\theta}{2(\\theta+2)}\n$$\n最后，将此结果代回 $\\tau$ 的表达式中：\n$$\n\\tau = 1 - \\frac{4}{\\theta} \\left(\\frac{\\theta}{2(\\theta+2)}\\right) = 1 - \\frac{2}{\\theta+2} = \\frac{(\\theta+2)-2}{\\theta+2} = \\frac{\\theta}{\\theta+2}\n$$\n所以，肯德尔τ由函数 $\\tau(\\theta) = \\frac{\\theta}{\\theta+2}$ 给出。\n\n**步骤 5：评估与解释**\n\n我们被要求在 $\\theta=0.8$ 处计算 $\\tau$ 的值：\n$$\n\\tau = \\frac{0.8}{0.8+2} = \\frac{0.8}{2.8} = \\frac{8}{28} = \\frac{2}{7}\n$$\n参数 $\\theta$ 代表脆弱性分布的方差，它量化了簇间的异质性。肯德尔τ，即 $\\tau$，衡量同一簇内两个个体生存时间之间的序数关联强度。$\\tau = 2/7 \\approx 0.2857$ 的值表示一个正向但中等偏弱的关联。这种依赖性在物理上源于共享的脆弱性 $Z$，它代表了簇所共有的未观测到的风险因素（例如，遗传倾向、共同的环境暴露）。该值表明，如果一个簇中的一个个体相对于总体经历了更长（或更短）的生存时间，那么来自同一簇的另一个个体也更有可能经历更长（或更短）的生存时间。观察到两对个体生存时间排序一致的概率比观察到不一致排序的概率高出 $2/7$。具体来说，一致性的概率是 $(1+\\tau)/2 = 9/14$，而不一致性的概率是 $(1-\\tau)/2 = 5/14$。",
            "answer": "$$\\boxed{\\frac{2}{7}}$$"
        },
        {
            "introduction": "在实践中应用脆性模型之前，一个关键的步骤是判断数据中是否存在显著的聚类效应，即我们是否真的需要一个脆性项。这通常通过检验脆性方差为零的原假设（$H_0: \\theta = 0$）来实现。然而，由于方差参数 $\\theta$ 的取值范围为非负（$\\theta \\ge 0$），该检验是一个非标准的统计问题，因为原假设的值位于参数空间的边界上。这个练习  探讨了如何在这种情况下构建似然比检验 (LRT)，并阐明了为何其检验统计量的渐近零分布不再是标准的卡方分布，而是一个混合卡方分布。",
            "id": "4796770",
            "problem": "您正在研究来自 $m$ 个独立临床中心的群集事件时间结局，其中中心 $i$ 有 $n_i$ 名由 $j$ 索引的患者。对于患者 $(i,j)$，您观测到右删失数据 $(Y_{ij}, \\Delta_{ij}, x_{ij})$，其中 $Y_{ij} = \\min(T_{ij}, C_{ij})$ 是观测时间，$\\Delta_{ij} \\in \\{0,1\\}$ 是事件指示符，$x_{ij} \\in \\mathbb{R}^p$ 是一个协变量向量。考虑一个参数化共享脆弱模型，在中心层面具有乘性脆弱项 $U_i$，其条件风险函数为\n$$\nh_{ij}(t \\mid U_i) \\;=\\; U_i\\, h_0(t;\\psi)\\,\\exp(x_{ij}^\\top \\beta),\n$$\n其中 $h_0(t;\\psi)$ 是一个由 $\\psi \\in \\Psi \\subset \\mathbb{R}^q$ 索引的参数化基线风险函数，$\\beta \\in \\mathbb{R}^p$ 是回归系数，$U_i$ 是均值为 $1$、方差为 $\\theta \\ge 0$ 的独立同分布脆弱项。假设 $U_i$ 服从形状参数为 $1/\\theta$、尺度参数为 $\\theta$ 的伽玛分布，因此 $\\mathbb{E}(U_i)=1$ 且 $\\mathrm{Var}(U_i)=\\theta$，并假设在给定脆弱项和协变量的条件下，删失是无信息的。边际似然函数通过对 $U_i$ 积分得到：\n$$\nL(\\beta,\\psi,\\theta)\n\\;=\\;\n\\prod_{i=1}^m\n\\int_0^\\infty\n\\left\\{\n\\prod_{j=1}^{n_i}\n\\big[\nu \\, h_0(Y_{ij};\\psi)\\,\\exp(x_{ij}^\\top \\beta)\n\\big]^{\\Delta_{ij}}\n\\exp\\big(-u\\, H_0(Y_{ij};\\psi)\\,\\exp(x_{ij}^\\top \\beta)\\big)\n\\right\\}\ng(u;\\theta)\\,du,\n$$\n其中 $H_0(t;\\psi)$ 是累积基线风险函数，$g(u;\\theta)$ 是伽玛密度函数。在原假设 $H_0\\!:\\,\\theta=0$ 下，脆弱项退化为 $U_i\\equiv 1$，模型简化为一个没有群集效应的标准参数化比例风险模型。您希望使用似然比检验 (LRT) 来检验 $H_0\\!:\\,\\theta=0$ 与 $H_1\\!:\\,\\theta>0$。\n\n在这种情况下，哪个陈述最能描述如何构建LRT，以及其检验统计量的适当的渐近零分布，包括对任何偏离标准正则渐近理论的理由的论证？\n\nA. 将边际对数似然 $\\ell(\\beta,\\psi,\\theta)=\\log L(\\beta,\\psi,\\theta)$ 在 $(\\beta,\\psi,\\theta\\ge 0)$ 上最大化得到 $(\\hat\\beta,\\hat\\psi,\\hat\\theta)$，并将 $\\ell(\\beta,\\psi,0)$ 在 $(\\beta,\\psi)$ 上最大化得到 $(\\hat\\beta_0,\\hat\\psi_0)$。构建LRT统计量\n$$\n\\Lambda \\;=\\; 2\\big\\{\\ell(\\hat\\beta,\\hat\\psi,\\hat\\theta) - \\ell(\\hat\\beta_0,\\hat\\psi_0,0)\\big\\}.\n$$\n因为 $\\theta\\ge 0$ 将 $H_0$ 置于参数空间的边界上，标准的Wilks定理不适用；相反，在 $H_0$ 和正则性条件下（包括 $m\\to\\infty$ 且 $n_i$ 有界），$\\Lambda \\overset{d}{\\to} \\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$，这是一个在0处的点质量与一个自由度为1的中心卡方分布的混合分布。直观上，单边约束意味着 $\\theta$ 的最大似然估计量的行为类似于 $\\max\\{0, S_\\theta/I_\\theta\\}$，其中 $S_\\theta$ 是 $\\theta$ 在0处的得分，$I_\\theta$ 是其费雪信息量，从而得出一个截断正态论证和50-50混合分布。\n\nB. 计算与选项A中相同的LRT统计量 $\\Lambda$，并且因为零模型嵌套在备择模型中，所以在 $H_0$ 下将 $\\Lambda$ 与中心 $\\chi^2_1$ 分布进行比较。当 $m\\to\\infty$ 时，边界条件 $\\theta\\ge 0$ 在渐近上是无关紧要的。\n\nC. 用Cox偏似然替换完整的边际似然，并将 $\\Lambda$ 定义为脆弱模型拟合与非脆弱模型拟合之间偏对数似然差的两倍，然后在 $H_0$ 下将 $\\Lambda$ 与标准正态分布 $N(0,1)$ 进行比较，因为方差分量的行为类似于单个线性参数。\n\nD. 使用选项A中的积分似然来构建 $\\Lambda$，但在 $H_0$ 下，$\\Lambda$ 的渐近零分布是自由度为 $m$ 的 $\\chi^2_m$ 分布，因为有 $m$ 个群集，并且在备择模型中每个群集都贡献一个额外的随机效应参数。\n\nE. 按照选项A构建 $\\Lambda$，在 $H_0$ 下其渐近零分布是混合分布 $\\tfrac{1}{2}\\chi^2_1 + \\tfrac{1}{2}\\chi^2_2$，因为脆弱项的均值和方差都位于边界上，从而在原假设下产生两个受约束的参数。",
            "solution": "用户要求在用于群集生存数据的参数化共享脆弱模型背景下，对一个假设检验问题进行分析。核心任务是正确识别用于检验脆弱性方差显著性的似然比检验（LRT）统计量的公式及其渐近零分布。\n\n### 第1步：问题验证\n\n**1.1. 提取已知条件**\n\n-   **模型**：一个用于来自 $m$ 个中心的群集事件时间数据的参数化共享脆弱模型。\n-   **数据**：对于中心 $i$ 的患者 $(i,j)$，数据为 $(Y_{ij}, \\Delta_{ij}, x_{ij})$。$Y_{ij}$ 是观测时间，$\\Delta_{ij}$ 是事件指示符，$x_{ij}$ 是协变量向量。\n-   **条件风险**：在给定特定于中心的脆弱项 $U_i$ 的条件下，患者 $(i,j)$ 的风险函数由下式给出\n    $$h_{ij}(t \\mid U_i) \\;=\\; U_i\\, h_0(t;\\psi)\\,\\exp(x_{ij}^\\top \\beta)$$\n-   **组成部分**：\n    -   $h_0(t;\\psi)$：一个参数化基线风险，参数向量为 $\\psi \\in \\mathbb{R}^q$。\n    -   $\\beta \\in \\mathbb{R}^p$：协变量的回归系数向量。\n    -   $U_i$：对于每个中心 $i=1,\\dots,m$ 的独立同分布（i.i.d.）随机脆弱项。\n-   **脆弱项分布**：假设脆弱项 $U_i$ 服从形状参数为 $1/\\theta$、尺度参数为 $\\theta$ 的伽玛分布。\n-   **脆弱项属性**：这种参数化确保了 $\\mathbb{E}(U_i) = (\\text{形状}) \\times (\\text{尺度}) = (1/\\theta) \\times \\theta = 1$ 且 $\\mathrm{Var}(U_i) = (\\text{形状}) \\times (\\text{尺度})^2 = (1/\\theta) \\times \\theta^2 = \\theta$。方差参数 $\\theta$ 必须为非负，即 $\\theta \\ge 0$。\n-   **边际似然**：通过对未观测到的脆弱项 $U_i$ 进行积分，得到似然函数 $L(\\beta,\\psi,\\theta)$：\n    $$\n    L(\\beta,\\psi,\\theta)\n    \\;=\\;\n    \\prod_{i=1}^m\n    \\int_0^\\infty\n    \\left\\{\n    \\prod_{j=1}^{n_i}\n    \\left[\n    u \\, h_0(Y_{ij};\\psi)\\,\\exp(x_{ij}^\\top \\beta)\n    \\right]^{\\Delta_{ij}}\n    \\exp\\big(-u\\, H_0(Y_{ij};\\psi)\\,\\exp(x_{ij}^\\top \\beta)\\big)\n    \\right\\}\n    g(u;\\theta)\\,du\n    $$\n    此处，$H_0(t;\\psi)$ 是累积基线风险函数，$g(u;\\theta)$ 是 Gamma$(1/\\theta, \\theta)$ 分布的概率密度函数。\n-   **假设检验**：我们的任务是检验原假设 $H_0: \\theta=0$ 与单边备择假设 $H_1: \\theta>0$。\n-   **检验方法**：似然比检验 (LRT)。\n-   **$H_0$的解释**：如果 $\\theta=0$，脆弱项的方差为零。由于均值固定为1，这意味着对于所有 $i$，$U_i$ 是一个等于1的常数。模型于是简化为一个标准的（无脆弱项的）参数化比例风险模型，$h_{ij}(t) = h_0(t;\\psi)\\,\\exp(x_{ij}^\\top \\beta)$，表明没有群集效应。\n\n**1.2. 问题陈述的验证**\n\n问题陈述基于科学合理性、良定性和客观性的标准进行评估。\n\n-   **科学基础**：该问题在生存分析和随机效应模型的统计理论中有坚实的基础。共享脆弱模型，特别是具有伽玛分布脆弱项的模型，是分析相关事件时间数据的标准且广泛使用的工具。模型的构建、似然函数以及假设检验的表述都是标准的。\n-   **良定性**：这个问题是良定的。它要求为一个特定的、明确定义的统计检验提供正确的程序和渐近分布。在给定模型和假设的情况下，在渐近统计理论的框架内存在一个唯一且正确的答案。\n-   **客观性**：问题以精确、客观的数学语言陈述。没有主观或模糊的术语。\n-   **完整性**：问题提供了确定正确渐近理论所需的所有信息。关键细节是假设检验的单边性质（$H_1: \\theta>0$）以及方差的参数空间为 $\\theta \\ge 0$ 这一事实，这意味着零假设值 $\\theta=0$ 位于参数空间的边界上。\n\n不存在科学或事实错误、矛盾或任何模糊之处。该问题是高等统计推断中的一个标准的、非平凡的问题。\n\n**1.3. 结论**\n\n问题陈述是**有效的**。我们继续进行推导和选项评估。\n\n### 正确程序和理论的推导\n\n该问题要求为检验 $H_0: \\theta=0$ 与 $H_1: \\theta > 0$ 构建一个似然比检验（LRT）。\n\n**1. LRT统计量的构建**\n\n设 $\\ell(\\beta, \\psi, \\theta) = \\log L(\\beta, \\psi, \\theta)$ 为对数似然函数。LRT统计量 $\\Lambda$ 定义为在备择假设下最大化的对数似然与在原假设下最大化的对数似然之差的两倍。\n\n-   在原假设 $H_0: \\theta=0$ 下，我们关于 $(\\beta, \\psi)$ 最大化 $\\ell(\\beta, \\psi, 0)$。设得到的估计值为 $(\\hat\\beta_0, \\hat\\psi_0)$，最大化的对数似然为 $\\ell_{null} = \\ell(\\hat\\beta_0, \\hat\\psi_0, 0)$。\n\n-   备择假设是 $H_1: \\theta>0$。然而，$\\theta$ 的完整参数空间是 $[0,\\infty)$。“无约束”模型的最大化是在所有参数的完整参数空间上进行的，即 $(\\beta, \\psi, \\theta) \\in \\mathbb{R}^p \\times \\Psi \\times [0, \\infty)$。设得到的最大似然估计（MLEs）为 $(\\hat\\beta, \\hat\\psi, \\hat\\theta)$，最大化的对数似然为 $\\ell_{alt} = \\ell(\\hat\\beta, \\hat\\psi, \\hat\\theta)$。\n\n-   因此，LRT统计量为：\n    $$ \\Lambda = 2(\\ell_{alt} - \\ell_{null}) = 2 \\big\\{ \\ell(\\hat\\beta, \\hat\\psi, \\hat\\theta) - \\ell(\\hat\\beta_0, \\hat\\psi_0, 0) \\big\\} $$\n\n**2. $\\Lambda$的渐近零分布**\n\n由Wilks定理总结的标准似然理论指出，在 $H_0$ 下，涉及 $k$ 个参数约束的检验的LRT统计量渐近服从自由度为 $k$ 的卡方分布（$\\chi^2_k$）。然而，Wilks定理的一个关键假设是，在 $H_0$ 下的真实参数值必须是参数空间的*内点*。\n\n在这个问题中，方差的参数空间是 $\\theta \\in [0, \\infty)$。原假设 $H_0: \\theta=0$ 指定了该空间边界上的一个值。因此，Wilks定理的正则性条件被违反，标准的 $\\chi^2_1$ 分布不适用。\n\n在参数空间边界上进行检验的正确渐近分布是在 Chernoff (1954) 的工作中提出的，并由 Self 和 Liang (1987) 进行了更普遍的推广。对于在边界上检验单个参数与单边备择假设的特定情况（如此处的 $H_0: \\theta=0$ vs. $H_1: \\theta > 0$），LRT统计量 $\\Lambda$ 的渐近零分布是两个分布的混合。\n\n其直观解释如下：\n-   在 $H_0$ 下，数据由 $\\theta=0$ 的模型生成。当我们拟合完整模型时，在零假设估计值处评估的 $\\theta$ 的得分函数 $S_\\theta(\\hat\\beta_0, \\hat\\psi_0, 0)$ 渐近服从均值为0的正态分布。\n-   如果得分恰好为负，对数似然函数会随着 $\\theta$ 从0减小而趋于增加。由于约束 $\\theta \\ge 0$，MLE 将位于边界上，即 $\\hat\\theta = 0$。在这种情况下，受约束和无约束的MLE重合，即 $(\\hat\\beta, \\hat\\psi, \\hat\\theta) = (\\hat\\beta_0, \\hat\\psi_0, 0)$。因此，$\\ell_{alt} = \\ell_{null}$，LRT统计量为 $\\Lambda=0$。渐近地，这种情况以1/2的概率发生。\n-   如果得分恰好为正，对数似然函数会随着 $\\theta$ 从0增加而增加。MLE 将位于参数空间的内部，即 $\\hat\\theta > 0$。在这种情况下，该情况局部上类似于一个标准的无约束检验，LRT统计量的行为如同一个正态随机变量的平方，服从 $\\chi^2_1$ 分布。这种情况也以1/2的概率发生。\n\n结合这两种情况，在 $H_0$ 下 $\\Lambda$ 的渐近分布是在零处的点质量与一个 $\\chi^2_1$ 分布的50:50混合。这可以写作：\n$$ \\Lambda \\overset{d}{\\to} \\frac{1}{2}\\chi^2_0 + \\frac{1}{2}\\chi^2_1 $$\n其中 $\\chi^2_0$ 表示一个在0处有单位点质量的退化分布。\n\n### 选项评估\n\n**A. 将边际对数似然 ... 因为 $\\theta\\ge 0$ 将 $H_0$ 置于参数空间的边界上，标准的Wilks定理不适用；相反，在 $H_0$ 和正则性条件下 ...，$\\Lambda \\overset{d}{\\to} \\tfrac{1}{2}\\chi^2_0 + \\tfrac{1}{2}\\chi^2_1$，这是一个在0处的点质量与一个自由度为1的中心卡方分布的混合分布。 ...**\n此选项正确描述了LRT统计量 $\\Lambda$ 的构建。它正确地指出了核心问题：零假设值 $\\theta=0$ 位于参数空间 $\\theta \\ge 0$ 的边界上。它正确地陈述了标准Wilks定理不适用，并提供了正确的渐近零分布，$\\frac{1}{2}\\chi^2_0 + \\frac{1}{2}\\chi^2_1$。所提供的启发式论证也是正确的，并抓住了理论结果的精髓。\n**结论：正确。**\n\n**B. 计算与选项A中相同的LRT统计量 $\\Lambda$，并且因为零模型嵌套在备择模型中，所以在 $H_0$ 下将 $\\Lambda$ 与中心 $\\chi^2_1$ 分布进行比较。当 $m\\to\\infty$ 时，边界条件 $\\theta\\ge 0$ 在渐近上是无关紧要的。**\n此选项正确地指出模型是嵌套的，但错误地声称边界条件在渐近上是无关紧要的。边界条件是标准理论失效的全部原因。应用标准的Wilks定理将导致不正确的 $\\chi^2_1$ 参考分布，并导致一个过于保守的检验（即，第一类错误率低于名义水平且功效降低）。\n**结论：不正确。**\n\n**C. 用Cox偏似然替换完整的边际似然，并将 $\\Lambda$ 定义为脆弱模型拟合与非脆弱模型拟合之间偏对数似然差的两倍，然后在 $H_0$ 下将 $\\Lambda$ 与标准正态分布 $N(0,1)$ 进行比较，因为方差分量的行为类似于单个线性参数。**\n此选项包含多个错误。首先，它建议将问题从参数化似然设置更改为半参数化偏似然设置。其次，它建议LRT统计量 $\\Lambda$ 将服从正态分布，这在根本上是错误的；LRT统计量是非负的，并且渐近服从卡方分布或卡方分布的混合，而不是正态分布。得分检验统计量可能具有渐近正态分布，但LRT统计量不会。\n**结论：不正确。**\n\n**D. 使用选项A中的积分似然来构建 $\\Lambda$，但在 $H_0$ 下，$\\Lambda$ 的渐近零分布是自由度为 $m$ 的 $\\chi^2_m$ 分布，因为有 $m$ 个群集，并且在备择模型中每个群集都贡献一个额外的随机效应参数。**\n此选项错误地陈述了检验的自由度。脆弱模型并没有向模型中添加 $m$ 个参数；它添加了单个方差参数 $\\theta$，该参数控制着 $m$ 个随机效应（它们是潜变量，而不是参数）的分布。LRT的自由度与原假设下受约束的参数数量有关，在本例中是一个（$\\theta$）。\n**结论：不正确。**\n\n**E. 按照选项A构建 $\\Lambda$，在 $H_0$ 下其渐近零分布是混合分布 $\\tfrac{1}{2}\\chi^2_1 + \\tfrac{1}{2}\\chi^2_2$，因为脆弱项的均值和方差都位于边界上，从而在原假设下产生两个受约束的参数。**\n此选项提出了一个不正确的混合分布。涉及 $\\chi^2_2$ 分量的混合分布会在两个参数在边界上被检验时出现。其理由也是有缺陷的：为了模型的可识别性，脆弱项均值 $\\mathbb{E}(U_i)=1$ 是固定的，并不是一个被检验的参数。原假设 $H_0: \\theta=0$ 只约束了单个参数，即方差 $\\theta$。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在确认了模型中存在显著的聚类效应后，下一步便是对模型参数进行估计。由于脆性（作为潜变量）是不可观测的，直接最大化似然函数通常很困难。期望最大化 (EM) 算法为此类含有潜变量的模型提供了一个强大的迭代式参数估计框架。这个动手编程练习  要求您为一个带有威布尔基准风险的伽马脆性模型实现一个完整的 EM 迭代步骤，从而让您亲身体验这些复杂模型在计算上是如何被拟合的，并深入理解其背后的机制。",
            "id": "4963310",
            "problem": "在一个聚类右删失数据集中，根据以下建模假设和定义，为带有威布尔基线风险的共享脆弱项生存模型实现单次期望最大化 (EM) 迭代，并报告指定测试用例的更新后参数。\n\n建模假设与核心定义：\n- 考虑一个共享脆弱项模型，其中簇由 $i \\in \\{1,\\dots, N\\}$ 索引，簇内个体由 $j$ 索引。\n- 每个观测时间为 $t_{ij} \\in \\mathbb{R}_{+}$，带有事件指示符 $\\delta_{ij} \\in \\{0,1\\}$，其中 $\\delta_{ij} = 1$ 表示事件发生，$\\delta_{ij} = 0$ 表示右删失。\n- 在给定非负共享脆弱项 $Z_i$ 的条件下，个体时间是独立的，其风险函数为 $h(t \\mid Z_i) = Z_i h_0(t)$，其中基线风险为威布尔分布：$h_0(t) = \\kappa \\lambda t^{\\kappa-1}$，累积风险为 $H_0(t) = \\lambda t^{\\kappa}$，形状参数 $\\kappa > 0$，尺度参数 $\\lambda > 0$。\n- 簇脆弱项 $Z_i$ 服从均值为 $1$、方差为 $\\theta > 0$ 的伽马分布，等价于 $Z_i \\sim \\mathrm{Gamma}(\\alpha, \\beta)$，其中形状参数 $\\alpha = 1/\\theta$，率参数 $\\beta = 1/\\theta$。这是一个确保基线可识别性的标准选择。\n- 对于每个簇 $i$，完整数据对数似然（不含与参数无关的加性常数）可以使用充分统计量 $d_i = \\sum_j \\delta_{ij}$ 和 $A_i = \\sum_j H_0(t_{ij}) = \\sum_j \\lambda t_{ij}^{\\kappa}$ 来表示。\n\n期望最大化 (EM) 迭代要求：\n- 期望步骤 (E-步)：利用 $Z_i$ 的伽马先验的共轭性以及 $d_i$ 在暴露量为 $A_i$ 时的类泊松似然结构，计算条件期望 $\\mathbb{E}[Z_i \\mid \\text{data}, \\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)}]$ 和 $\\mathbb{E}[\\log Z_i \\mid \\text{data}, \\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)}]$。此处 $A_i$ 根据当前基线参数计算得出，即 $A_i = \\sum_j \\lambda^{(0)} \\, t_{ij}^{\\kappa^{(0)}}$，而 $d_i = \\sum_j \\delta_{ij}$。\n- 最大化步骤 (M-步)：\n  - 通过关于 $\\theta$ 最大化期望完整数据对数似然来更新脆弱项方差参数 $\\theta$。引入 $\\alpha = 1/\\theta$，并使用数值求根法求解 $\\alpha$ 的一阶最优性条件。\n  - 通过关于 $(\\lambda, \\kappa)$ 最大化期望完整数据对数似然来更新威布尔基线参数，其中潜变量 $Z_i$ 被其在 E-步中得到的条件期望所替代。这将导出一个关于 $\\kappa$ 的一维求根问题，并在给定 $\\kappa$ 的情况下对 $\\lambda$ 进行闭式剖面更新。如果整个数据集中没有事件，为了数值稳定性，保持 $(\\lambda, \\kappa)$ 不变。\n\n计算与算法约束：\n- 假设无协变量和独立右删失。\n- 在 M-步中使用稳健的数值求解器进行一维求根，确保所有参数都满足正性约束。如有必要，将根限定在区间 $[10^{-6}, 10^{2}]$ 内，并回退到带有适当保障措施的牛顿更新法。\n- 所有计算必须使用浮点运算。除了抽象时间外，不涉及任何物理单位；将结果报告为无量纲的浮点数。\n\n测试套件：\n对于每个测试用例，从指定的初始参数和数据集开始，精确运行一次 EM 迭代，并返回更新后的参数三元组 $[\\theta^{(1)}, \\lambda^{(1)}, \\kappa^{(1)}]$，保留 $6$ 位小数。\n\n- 测试用例 1 (正常路径；与注释中给出的聚合值 $A_i$ 匹配)：\n  - 初始参数：$\\theta^{(0)} = 0.5$, $\\lambda^{(0)} = 0.5$, $\\kappa^{(0)} = 1.0$。\n  - 一个簇 ($N = 1$)，包含两个个体 ($n_1 = 2$)：\n    - 时间 $t_{11} = 3.0$, $t_{12} = 4.0$。\n    - 事件指示符 $\\delta_{11} = 1$, $\\delta_{12} = 1$。\n  - 注：使用给定的初始基线， $A_1 = \\sum_j \\lambda^{(0)} t_{1j}^{\\kappa^{(0)}} = 0.5 \\times (3.0 + 4.0) = 3.5$，且 $d_1 = 2$。\n\n- 测试用例 2 (边界条件：零事件)：\n  - 初始参数：$\\theta^{(0)} = 0.5$, $\\lambda^{(0)} = 0.5$, $\\kappa^{(0)} = 1.0$。\n  - 一个簇 ($N = 1$)，包含两个个体：\n    - 时间 $t_{11} = 2.0$, $t_{12} = 5.0$。\n    - 事件指示符 $\\delta_{11} = 0$, $\\delta_{12} = 0$。\n  - 注：使用给定的初始基线， $A_1 = 0.5 \\times (2.0 + 5.0) = 3.5$，且 $d_1 = 0$。\n\n- 测试用例 3 (多簇；混合事件与删失)：\n  - 初始参数：$\\theta^{(0)} = 0.5$, $\\lambda^{(0)} = 0.8$, $\\kappa^{(0)} = 1.2$。\n  - 两个簇 ($N = 2$)：\n    - 簇 1：$t_{11} = 1.0$, $t_{12} = 2.0$，其中 $\\delta_{11} = 1$, $\\delta_{12} = 0$。\n    - 簇 2：$t_{21} = 0.5$, $t_{22} = 1.5$, $t_{23} = 3.0$，其中 $\\delta_{21} = 1$, $\\delta_{22} = 1$, $\\delta_{23} = 0$。\n\n要求的输出格式：\n- 您的程序必须生成单行输出，包含一个含三个列表的列表，每个内部列表对应一个测试用例，格式为 $[\\theta^{(1)}, \\lambda^{(1)}, \\kappa^{(1)}]$，保留 $6$ 位小数。\n- 例如，输出必须类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，除标准列表格式外，没有额外的文本或空白要求。\n\n您的任务：\n- 严格按照描述实现 EM 迭代，为每个测试用例计算更新后的参数，并以指定的单行格式打印结果。",
            "solution": "该问题要求在一个共享伽马脆弱项模型（带有威布尔基线风险）中，为参数估计实现一次期望最大化 (EM) 迭代。数据集包含聚类的、右删失的生存时间。在给出计算解决方案之前，有必要对问题陈述进行严格的验证。\n\n### 问题验证\n\n**步骤 1：提取的已知条件**\n- **模型**：共享脆弱项生存模型。簇 $i \\in \\{1,\\dots,N\\}$，簇 $i$ 内的个体 $j$。\n- **数据**：时间 $t_{ij} \\in \\mathbb{R}_{+}$，事件指示符 $\\delta_{ij} \\in \\{0,1\\}$。\n- **条件风险函数**：$h(t \\mid Z_i) = Z_i h_0(t)$。\n- **基线风险函数**：威布尔分布，$h_0(t) = \\kappa \\lambda t^{\\kappa-1}$，其中形状参数 $\\kappa > 0$，尺度参数 $\\lambda > 0$。\n- **累积基线风险函数**：$H_0(t) = \\lambda t^{\\kappa}$。\n- **脆弱项分布**：$Z_i \\sim \\mathrm{Gamma}(\\alpha, \\beta)$，其中形状参数 $\\alpha = 1/\\theta$，率参数 $\\beta = 1/\\theta$，$\\theta>0$ 是方差。\n- **充分统计量**：对于簇 $i$，$d_i = \\sum_j \\delta_{ij}$ 和 $A_i = \\lambda \\sum_j t_{ij}^{\\kappa}$。\n- **E-步要求**：使用当前参数 $\\Theta^{(0)} = (\\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)})$ 计算 $\\mathbb{E}[Z_i \\mid \\text{data}, \\Theta^{(0)}]$ 和 $\\mathbb{E}[\\log Z_i \\mid \\text{data}, \\Theta^{(0)}]$。\n- **M-步要求**：通过求解关于 $\\alpha=1/\\theta$ 的一维求根问题来更新 $\\theta$。通过求解关于 $\\kappa$ 的一维求根问题并使用 $\\lambda$ 的闭式更新来更新 $(\\lambda, \\kappa)$。如果总事件数为零，则 $(\\lambda, \\kappa)$ 保持不变。\n- **数值求解器约束**：稳健的一维求根，建议的括号区间为 $[10^{-6}, 10^{2}]$。\n- **测试用例**：提供了三个测试用例，包含指定的初始参数和数据。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准评估该问题：\n- **科学性**：带有威布尔基线的伽马脆弱项模型是用于聚类数据的多元生存分析的基石。EM 算法的公式是标准的，源于似然理论和贝叶斯推断的第一性原理。所有组成部分都具有科学合理性。\n- **适定性**：问题以数学精度进行了规定。它提供了所有必要的组成部分：模型、算法、初始条件和数据。任务是执行一个确定性的计算过程，这保证了唯一解的存在。\n- **客观性**：问题以正式、无歧义的语言陈述，不含主观因素。\n- **完整性与一致性**：问题是自洽的。所提供的参数和数据是一致的，这一点已通过对测试用例 1 中 `注` 的检验得到证实：$A_1 = \\lambda^{(0)} \\sum_j t_{1j}^{\\kappa^{(0)}} = 0.5 \\times (3.0^{1.0} + 4.0^{1.0}) = 3.5$。\n- **现实性与可行性**：对于此类统计问题，数据值、参数和计算要求都是现实可行的。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。它在计算统计学中是一个定义明确的标准问题。我现在将着手提供详细的解决方案。\n\n### EM 迭代的推导\n\nEM 算法是一种迭代方法，用于在统计模型中寻找参数的最大似然估计，而这些模型依赖于未观测到的潜变量。在此背景下，脆弱项 $Z_i$ 就是潜变量。一次迭代包括一个期望 (E) 步和一个最大化 (M) 步。\n\n设当前参数估计为 $\\Theta^{(k)} = (\\theta^{(k)}, \\lambda^{(k)}, \\kappa^{(k)})$。\n\n#### E-步：计算条件期望\nE-步涉及计算完整数据对数似然的期望，该期望以观测数据和当前参数估计 $\\Theta^{(k)}$ 为条件。这需要潜变量 $Z_i$ 的后验分布。\n\n在给定脆弱项 $Z_i$ 的条件下，簇 $i$ 中观测数据 $(t_{ij}, \\delta_{ij})_{j}$ 的似然函数为\n$$ L_i(\\text{data}_i \\mid Z_i; \\lambda, \\kappa) = \\prod_j [h(t_{ij} | Z_i)]^{\\delta_{ij}} S(t_{ij} | Z_i) = \\prod_j [Z_i h_0(t_{ij})]^{\\delta_{ij}} \\exp[-Z_i H_0(t_{ij})] $$\n$$ L_i(\\text{data}_i \\mid Z_i; \\lambda, \\kappa) = \\left( \\prod_j [h_0(t_{ij})]^{\\delta_{ij}} \\right) Z_i^{\\sum_j \\delta_{ij}} \\exp\\left[-Z_i \\sum_j H_0(t_{ij})\\right] $$\n使用充分统计量 $d_i = \\sum_j \\delta_{ij}$ 和 $A_i = \\lambda^{(k)} \\sum_j t_{ij}^{\\kappa^{(k)}}$，似然函数正比于 $Z_i^{d_i} e^{-Z_i A_i}$。\n\n$Z_i$ 的先验分布是 $\\mathrm{Gamma}(\\alpha, \\beta)$，其中 $\\alpha = \\beta = 1/\\theta^{(k)}$。其概率密度函数为 $p(Z_i) \\propto Z_i^{\\alpha-1} e^{-\\beta Z_i}$。\n\n根据贝叶斯定理，$Z_i$ 的后验分布为\n$$ p(Z_i \\mid \\text{data}_i, \\Theta^{(k)}) \\propto L_i(\\text{data}_i \\mid Z_i) p(Z_i) \\propto (Z_i^{d_i} e^{-Z_i A_i}) (Z_i^{\\alpha-1} e^{-\\beta Z_i}) = Z_i^{d_i+\\alpha-1} e^{-(A_i+\\beta)Z_i} $$\n这是一个伽马分布的核。因此，后验分布为\n$$ Z_i \\mid \\text{data}_i, \\Theta^{(k)} \\sim \\mathrm{Gamma}(d_i + \\alpha, A_i + \\beta) = \\mathrm{Gamma}\\left(d_i + \\frac{1}{\\theta^{(k)}}, A_i + \\frac{1}{\\theta^{(k)}}\\right) $$\n所需的条件期望是这个后验伽马分布的性质。对于 $X \\sim \\mathrm{Gamma}(a, b)$，我们有 $\\mathbb{E}[X] = a/b$ 和 $\\mathbb{E}[\\log X] = \\psi(a) - \\log(b)$，其中 $\\psi$ 是 digamma 函数。\n\n因此，对于每个簇 $i$：\n$$ E_{Z_i} := \\mathbb{E}[Z_i \\mid \\text{data}_i, \\Theta^{(k)}] = \\frac{d_i + 1/\\theta^{(k)}}{A_i + 1/\\theta^{(k)}} $$\n$$ E_{\\log Z_i} := \\mathbb{E}[\\log Z_i \\mid \\text{data}_i, \\Theta^{(k)}] = \\psi\\left(d_i + \\frac{1}{\\theta^{(k)}}\\right) - \\log\\left(A_i + \\frac{1}{\\theta^{(k)}}\\right) $$\n这些值是为所有簇 $i=1, \\dots, N$ 计算的。\n\n#### M-步：最大化期望对数似然\nM-步相对于参数 $\\Theta = (\\theta, \\lambda, \\kappa)$ 最大化期望完整数据对数似然 $Q(\\Theta \\mid \\Theta^{(k)})$。函数 $Q$ 可以分解为依赖于 $\\theta$ 的部分和依赖于 $(\\lambda, \\kappa)$ 的部分。\n\n**1. 脆弱项方差 $\\theta$ 的更新**\n$Q$ 中依赖于 $\\theta$ (或 $\\alpha = 1/\\theta$) 的部分是：\n$$ Q_{\\theta}(\\alpha) = \\sum_{i=1}^N \\mathbb{E}[\\log p(Z_i; \\alpha)] = \\sum_{i=1}^N \\mathbb{E}[\\alpha \\log \\alpha - \\log \\Gamma(\\alpha) + (\\alpha-1)\\log Z_i - \\alpha Z_i] $$\n$$ Q_{\\theta}(\\alpha) = N(\\alpha \\log \\alpha - \\log \\Gamma(\\alpha)) + (\\alpha-1)\\sum_{i=1}^N E_{\\log Z_i} - \\alpha \\sum_{i=1}^N E_{Z_i} $$\n为了最大化 $Q_{\\theta}(\\alpha)$，我们将其关于 $\\alpha$ 的导数设为零：\n$$ \\frac{\\partial Q_{\\theta}}{\\partial \\alpha} = N(\\log \\alpha + 1 - \\psi(\\alpha)) + \\sum_{i=1}^N E_{\\log Z_i} - \\sum_{i=1}^N E_{Z_i} = 0 $$\n$$ N(\\log \\alpha - \\psi(\\alpha)) + N + \\sum_{i=1}^N E_{\\log Z_i} - \\sum_{i=1}^N E_{Z_i} = 0 $$\n这个关于 $\\alpha$ 的非线性方程必须进行数值求解。令 $K = N + \\sum_i E_{\\log Z_i} - \\sum_i E_{Z_i}$。我们求解 $N(\\log \\alpha - \\psi(\\alpha)) + K = 0$。如果 $K/N \\ge 0$，则左侧恒为正，意味着最大值在 $\\alpha \\to \\infty$ 时出现，即 $\\theta \\to 0$。在这种情况下，我们将 $\\alpha$ 的值限定在一个较大的数值。否则，存在一个唯一的根 $\\alpha^{(k+1)}$，可以使用像 Brent-Dekker 方法这样的数值求解器找到。更新后的脆弱项方差为 $\\theta^{(k+1)} = 1/\\alpha^{(k+1)}$。\n\n**2. 基线风险参数 $(\\lambda, \\kappa)$ 的更新**\n$Q$ 中依赖于 $(\\lambda, \\kappa)$ 的部分是：\n$$ Q_{\\lambda, \\kappa}(\\lambda, \\kappa) = \\sum_{i=1}^N \\mathbb{E} \\left[ \\sum_j \\delta_{ij} \\log(Z_i h_0(t_{ij})) - \\sum_j Z_i H_0(t_{ij}) \\right] $$\n代入 $h_0(t) = \\kappa \\lambda t^{\\kappa-1}$ 和 $H_0(t) = \\lambda t^\\kappa$，并对 $Z_i$ 取期望：\n$$ Q_{\\lambda, \\kappa} = \\sum_{i,j} \\delta_{ij}(\\log(\\kappa\\lambda) + (\\kappa-1)\\log t_{ij}) - \\lambda \\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa} + \\text{const} $$\n令 $D = \\sum_{i,j} \\delta_{ij}$ 为总事件数。\n$$ Q_{\\lambda, \\kappa} = D \\log\\lambda + D \\log\\kappa + (\\kappa-1)\\sum_{i,j} \\delta_{ij}\\log t_{ij} - \\lambda \\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa} $$\n如果 $D=0$，此函数在 $\\lambda \\to 0$ 时最大化，这没有意义。根据问题要求，如果 $D=0$，我们设 $(\\lambda^{(k+1)}, \\kappa^{(k+1)}) = (\\lambda^{(k)}, \\kappa^{(k)})$。\n\n如果 $D > 0$，我们可以为 $\\kappa$ 找到一个剖面似然。对 $\\lambda$ 求导并设为零，得到给定 $\\kappa$ 时的最优 $\\lambda$：\n$$ \\frac{\\partial Q_{\\lambda, \\kappa}}{\\partial \\lambda} = \\frac{D}{\\lambda} - \\sum_{i,j} E_{Z_i} t_{ij}^\\kappa = 0 \\implies \\lambda(\\kappa) = \\frac{D}{\\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa}} $$\n将此代回 $Q_{\\lambda, \\kappa}$，得到一个关于 $\\kappa$ 的剖面目标函数。将其关于 $\\kappa$ 的导数设为零，得到以下关于 $\\kappa$ 的方程：\n$$ \\frac{D}{\\kappa} + \\sum_{i,j} \\delta_{ij} \\log t_{ij} - \\frac{D \\sum_{i,j} E_{Z_i} t_{ij}^\\kappa \\log t_{ij}}{\\sum_{i,j} E_{Z_i} t_{ij}^\\kappa} = 0 $$\n两边除以 $D$，我们得到需要数值求解 $\\kappa^{(k+1)}$ 的方程：\n$$ \\frac{1}{\\kappa} + \\frac{1}{D}\\sum_{i,j} \\delta_{ij} \\log t_{ij} - \\frac{\\sum_{i,j} E_{Z_i} t_{ij}^\\kappa \\log t_{ij}}{\\sum_{i,j} E_{Z_i} t_{ij}^\\kappa} = 0 $$\n这是一个一维求根问题。一旦找到 $\\kappa^{(k+1)}$，$\\lambda$ 的更新值将通过其剖面表达式计算得出：\n$$ \\lambda^{(k+1)} = \\frac{D}{\\sum_{i,j} E_{Z_i} t_{ij}^{\\kappa^{(k+1)}}} $$\n\n### 算法总结\n对于每个具有初始参数 $(\\theta^{(0)}, \\lambda^{(0)}, \\kappa^{(0)})$ 和数据 $\\{(t_{ij}, \\delta_{ij})\\}$ 的测试用例：\n1.  **E-步**：\n    a. 对于每个簇 $i=1,\\dots,N$，计算事件数 $d_i = \\sum_j \\delta_{ij}$ 和累积基线风险总和 $A_i = \\lambda^{(0)} \\sum_j t_{ij}^{\\kappa^{(0)}}$。\n    b. 使用上面推导的公式和当前迭代的值，计算后验期望 $E_{Z_i}$ 和 $E_{\\log Z_i}$。\n2.  **M-步**：\n    a. **更新 $\\theta$**：使用 `scipy.optimize.brentq` 求解方程 $N(\\log \\alpha - \\psi(\\alpha)) + N + \\sum_i E_{\\log Z_i} - \\sum_i E_{Z_i} = 0$ 的根 $\\alpha^{(1)}$。如果在指定区间内未找到根（表示 $\\alpha \\to \\infty$），则将 $\\alpha$ 的值限定在一个较大的数值。新的估计值为 $\\theta^{(1)}=1/\\alpha^{(1)}$。\n    b. **更新 $(\\lambda, \\kappa)$**：\n        i. 计算总事件数 $D = \\sum_i d_i$。\n        ii. 如果 $D=0$，设 $(\\lambda^{(1)}, \\kappa^{(1)}) = (\\lambda^{(0)}, \\kappa^{(0)})$。\n        iii. 如果 $D>0$，使用 `scipy.optimize.brentq` 求解关于 $\\kappa$ 的非线性方程的根 $\\kappa^{(1)}$。\n        iv. 使用 $\\kappa=\\kappa^{(1)}$ 的剖面似然估计量计算 $\\lambda^{(1)}$。\n3.  **输出**：报告更新后的参数 $[\\theta^{(1)}, \\lambda^{(1)}, \\kappa^{(1)}]$，保留 6 位小数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import digamma\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the EM iteration for all test cases and print results.\n    \"\"\"\n\n    # Test cases defined as (initial_params, data) tuples.\n    # initial_params: (theta, lambda, kappa)\n    # data: list of clusters, where each cluster is a list of (time, delta) tuples.\n    test_cases = [\n        (\n            (0.5, 0.5, 1.0),\n            [\n                [(3.0, 1), (4.0, 1)]\n            ]\n        ),\n        (\n            (0.5, 0.5, 1.0),\n            [\n                [(2.0, 0), (5.0, 0)]\n            ]\n        ),\n        (\n            (0.5, 0.8, 1.2),\n            [\n                [(1.0, 1), (2.0, 0)],\n                [(0.5, 1), (1.5, 1), (3.0, 0)]\n            ]\n        )\n    ]\n\n    results = []\n    for params, data in test_cases:\n        theta1, lambda1, kappa1 = run_one_em_iteration(params[0], params[1], params[2], data)\n        results.append([round(p, 6) for p in [theta1, lambda1, kappa1]])\n\n    # Format and print the final output as a single line.\n    # e.g., [[a1,b1,c1],[a2,b2,c2],[a3,b3,c3]]\n    result_str = \",\".join([f\"[{','.join(map(str, r))}]\" for r in results])\n    print(f\"[{result_str}]\")\n\ndef run_one_em_iteration(theta0, lambda0, kappa0, data):\n    \"\"\"\n    Performs a single EM iteration for the shared frailty model.\n    \"\"\"\n    \n    # --- E-Step ---\n    N = len(data)\n    d_i_list = []\n    A_i_list = []\n    EZ_i_list = []\n    ElogZ_i_list = []\n\n    theta0_inv = 1.0 / theta0\n\n    for cluster_data in data:\n        times = np.array([obs[0] for obs in cluster_data])\n        deltas = np.array([obs[1] for obs in cluster_data])\n        \n        d_i = np.sum(deltas)\n        A_i = lambda0 * np.sum(times**kappa0)\n        \n        d_i_list.append(d_i)\n        A_i_list.append(A_i)\n\n        posterior_alpha = d_i + theta0_inv\n        posterior_beta = A_i + theta0_inv\n\n        EZ_i = posterior_alpha / posterior_beta\n        ElogZ_i = digamma(posterior_alpha) - np.log(posterior_beta)\n\n        EZ_i_list.append(EZ_i)\n        ElogZ_i_list.append(ElogZ_i)\n\n    EZ_i = np.array(EZ_i_list)\n    ElogZ_i = np.array(ElogZ_i_list)\n\n    # --- M-Step ---\n\n    # 1. Update theta (via alpha = 1/theta)\n    \n    def g_alpha(alpha, sum_EZ, sum_ElogZ, n_clusters):\n        if alpha == 0: return np.inf\n        # Target function for root finding for alpha\n        # N(log(alpha) - digamma(alpha)) + N + sum(ElogZ) - sum(EZ) = 0\n        return n_clusters * (np.log(alpha) - digamma(alpha)) + n_clusters + sum_ElogZ - sum_EZ\n\n    sum_EZ = np.sum(EZ_i)\n    sum_ElogZ = np.sum(ElogZ_i)\n    \n    # Bracket for alpha corresponds to theta in [1e-6, 1e2]\n    alpha_min, alpha_max = 1e-2, 1e6 \n    \n    try:\n        # Check if a root exists in the interval\n        val_min = g_alpha(alpha_min, sum_EZ, sum_ElogZ, N)\n        val_max = g_alpha(alpha_max, sum_EZ, sum_ElogZ, N)\n        if val_min * val_max  0:\n            alpha1 = brentq(g_alpha, alpha_min, alpha_max, args=(sum_EZ, sum_ElogZ, N))\n        else:\n            # If function values at endpoints have the same sign, it implies\n            # the maximum is at alpha -> infinity (since the function is decreasing).\n            # This corresponds to theta -> 0. We cap alpha at the max of our range.\n            alpha1 = alpha_max\n        theta1 = 1.0 / alpha1\n    except ValueError:\n        # Failsafe: if brentq fails for other reasons, handle it.\n        # Here we assume the case where derivative is always positive, so alpha -> inf\n        alpha1 = alpha_max\n        theta1 = 1.0 / alpha1\n\n\n    # 2. Update lambda and kappa\n    all_times = np.array([obs[0] for cluster in data for obs in cluster])\n    all_deltas = np.array([obs[1] for cluster in data for obs in cluster])\n    \n    total_events = np.sum(all_deltas)\n    \n    if total_events == 0:\n        return theta1, lambda0, kappa0\n\n    EZ_flat = np.array([EZ for EZ, cluster in zip(EZ_i, data) for _ in cluster])\n    \n    avg_log_t_event = np.sum(all_deltas * np.log(all_times)) / total_events\n\n    def h_kappa(kappa, ez_flat, t_flat, avg_log_t):\n        if kappa == 0: return np.inf\n        # Scaled target function for root finding for kappa\n        # 1/kappa + (1/D)*sum(delta*log(t)) - sum(EZ*t^k*log(t))/sum(EZ*t^k) = 0\n        t_k = t_flat**kappa\n        \n        numerator = np.sum(ez_flat * t_k * np.log(t_flat))\n        denominator = np.sum(ez_flat * t_k)\n        \n        if denominator == 0: return np.inf\n        \n        return 1.0/kappa + avg_log_t - numerator / denominator\n\n    kappa_min, kappa_max = 1e-6, 1e2\n    \n    try:\n        kappa1 = brentq(h_kappa, kappa_min, kappa_max, args=(EZ_flat, all_times, avg_log_t_event))\n    except ValueError:\n        # Fallback if bracketing fails, though test cases should be well-behaved\n        kappa1 = kappa0 \n\n    lambda1_denominator = np.sum(EZ_flat * all_times**kappa1)\n    lambda1 = total_events / lambda1_denominator\n    \n    return theta1, lambda1, kappa1\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}