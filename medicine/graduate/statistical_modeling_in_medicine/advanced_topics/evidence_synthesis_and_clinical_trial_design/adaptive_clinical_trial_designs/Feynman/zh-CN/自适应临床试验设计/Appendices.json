{
    "hands_on_practices": [
        {
            "introduction": "自适应临床试验的一个核心挑战是在试验中期进行调整的同时，如何严格控制总体 I 类错误率。逆正态组合方法是一种基于信息权重的强大技术，它从费雪信息和有效分数等基本统计原理出发，为合并来自不同独立阶段的检验统计量提供了一个严谨的框架。通过这个练习，你将从第一性原理推导出这一关键组合函数，从而深入理解在适应性设计中维持统计有效性的理论基础 。",
            "id": "4950399",
            "problem": "考虑一个两阶段自适应临床试验，该试验使用一个预先计划的组合检验框架，以在阶段间进行数据依赖性调整时控制 I 型错误。设分阶段标准化有效得分统计量为 $z_1$ 和 $z_2$，它们分别由第 1 阶段和第 2 阶段的独立患者队列计算得出。在无治疗效果的原假设下，假设广义线性模型具有标准渐近性质：有效得分 $U$ 满足 $U \\approx \\mathcal{N}(0, I)$，其中 $I$ 是费雪信息，且费雪信息在独立阶段上是可加的。具体来说，设 $U_j$ 为第 $j$ 阶段的有效得分，其方差为 $I_j$。定义分阶段标准化统计量为 $z_j = U_j / \\sqrt{I_j}$，在原假设下，它们独立同分布于 $\\mathcal{N}(0,1)$。设总费雪信息为 $I = I_1 + I_2$，信息分数为 $w_1 = I_1 / I$ 和 $w_2 = I_2 / I$。\n\n仅使用这些原则——独立抽样下有效得分和费雪信息的可加性，以及通过费雪信息的平方根进行标准化——推导出 $z_1$ 和 $z_2$ 的线性组合 $Z_{comb}$，该组合在原假设下标准化为 $\\mathcal{N}(0,1)$ 并且遵循基于信息的加权。然后，对于 $w_1 = 0.4$, $w_2 = 0.6$, $z_1 = 1.0$, 和 $z_2 = 2.1$，计算 $Z_{comb}$ 的数值以及为检验优效性而定义的单侧 $p$ 值 $p = \\Pr(Z \\geq Z_{comb})$（其中 $Z \\sim \\mathcal{N}(0,1)$）。将 $p$ 值表示为小数。将 $Z_{comb}$ 和 $p$ 都四舍五入到四位有效数字。",
            "solution": "该问题已经过验证，被认为是合理的。所提供的原则是临床试验统计理论中的标准原则。问题提法明确、客观，并包含足够的信息以获得唯一解。\n\n第一步是推导组合检验统计量 $Z_{comb}$ 的表达式。问题要求该统计量是分阶段标准化统计量 $z_1$ 和 $z_2$ 的线性组合，在原假设下标准化为标准正态分布 $\\mathcal{N}(0,1)$，并且遵循基于信息的加权。\n\n我们从陈述的基本原则开始：有效得分 $U$ 和费雪信息 $I$ 的可加性。对于一个有独立队列的两阶段试验，总有效得分是分阶段得分之和，总费雪信息是分阶段信息度量之和。\n$$U_{total} = U_1 + U_2$$\n$$I_{total} = I_1 + I_2$$\n对于完整数据集，如果在一个步骤中进行分析，其总体标准化检验统计量定义为总有效得分除以总费雪信息的平方根。我们称这个统计量为 $Z$。\n$$Z = \\frac{U_{total}}{\\sqrt{I_{total}}} = \\frac{U_1 + U_2}{\\sqrt{I_1 + I_2}}$$\n在原假设和适当的正则性条件下，这个总体统计量 $Z$ 渐近分布于 $\\mathcal{N}(0,1)$。\n\n问题将分阶段标准化统计量定义为 $z_j = U_j / \\sqrt{I_j}$（对于 $j=1, 2$）。我们可以重新整理这个定义，用标准化统计量来表示分阶段有效得分：\n$$U_1 = z_1 \\sqrt{I_1}$$\n$$U_2 = z_2 \\sqrt{I_2}$$\n现在，我们将这些表达式代回到总体统计量 $Z$ 的公式中。这将得到所需的组合统计量 $Z_{comb}$。\n$$Z_{comb} = \\frac{z_1 \\sqrt{I_1} + z_2 \\sqrt{I_2}}{\\sqrt{I_1 + I_2}}$$\n为了用信息分数 $w_1 = I_1 / I_{total}$ 和 $w_2 = I_2 / I_{total}$ 来表示，我们可以将表达式重写为：\n$$Z_{comb} = \\frac{\\sqrt{I_1}}{\\sqrt{I_1 + I_2}} z_1 + \\frac{\\sqrt{I_2}}{\\sqrt{I_1 + I_2}} z_2$$\n认识到 $\\sqrt{w_1} = \\sqrt{I_1 / (I_1+I_2)} = \\sqrt{I_1} / \\sqrt{I_1+I_2}$，对于 $w_2$ 也类似，我们得到信息加权组合统计量的最终形式：\n$$Z_{comb} = \\sqrt{w_1} z_1 + \\sqrt{w_2} z_2$$\n该推导成功地利用了信息可加性原理，从分阶段的组成部分构建了一个组合统计量。作为检验，我们可以验证其分布。鉴于 $z_1, z_2 \\sim \\mathcal{N}(0,1)$ 且相互独立，$Z_{comb}$ 的均值为 $E[Z_{comb}] = \\sqrt{w_1} E[z_1] + \\sqrt{w_2} E[z_2] = \\sqrt{w_1}(0) + \\sqrt{w_2}(0) = 0$。方差为 $Var(Z_{comb}) = Var(\\sqrt{w_1} z_1 + \\sqrt{w_2} z_2) = (\\sqrt{w_1})^2 Var(z_1) + (\\sqrt{w_2})^2 Var(z_2) = w_1(1) + w_2(1) = w_1 + w_2$。根据定义，$w_1 + w_2 = (I_1/I_{total}) + (I_2/I_{total}) = (I_1+I_2)/I_{total} = 1$。因此，$Var(Z_{comb}) = 1$。由于 $Z_{comb}$ 是独立正态变量的线性组合，它也服从正态分布。因此，$Z_{comb} \\sim \\mathcal{N}(0,1)$，符合要求。\n\n接下来，我们使用所提供的数据计算 $Z_{comb}$ 的数值：$w_1 = 0.4$，$w_2 = 0.6$，$z_1 = 1.0$ 和 $z_2 = 2.1$。\n$$Z_{comb} = \\sqrt{0.4} (1.0) + \\sqrt{0.6} (2.1)$$\n$$Z_{comb} \\approx (0.63245553) (1.0) + (0.77459667) (2.1)$$\n$$Z_{comb} \\approx 0.63245553 + 1.62665290$$\n$$Z_{comb} \\approx 2.25910843$$\n四舍五入到四位有效数字，我们得到 $Z_{comb} = 2.259$。\n\n最后，我们计算单侧 $p$ 值，定义为 $p = \\Pr(Z \\geq Z_{comb})$，其中 $Z \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。这可以计算为 $1 - \\Phi(Z_{comb})$，其中 $\\Phi$ 是标准正态分布的累积分布函数（CDF）。为了精确，我们使用 $Z_{comb}$ 未四舍五入的值：\n$$p = \\Pr(Z \\geq 2.25910843)$$\n$$p = 1 - \\Phi(2.25910843)$$\n使用标准正态分布表或计算软件，我们找到该值。\n$$p \\approx 1 - 0.98806392 = 0.01193608$$\n将此值四舍五入到四位有效数字，得到 $p = 0.01194$。\n所求的两个值是组合检验统计量 $Z_{comb}$ 和相应的单侧 $p$ 值。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2.259  0.01194 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在临床试验的实际操作中，计划阶段对数据变异性的初步假设往往与实际情况有出入，这可能导致试验效力不足。盲态样本量重估（Blinded Sample Size Re-estimation, SSR）是一种广泛应用的自适应设计，它允许研究者在不破坏盲态和不引入偏倚的情况下，根据期中观测到的变异性来调整总样本量。这个实践练习将引导你推导并应用样本量重估的公式，展示如何利用期中信息来确保试验达到预设的统计效力，这是连接理论与实践的关键一步 。",
            "id": "4772912",
            "problem": "一项双臂、等比例分配、平行组优效性试验计划采用由中心极限定理（CLT）证明其合理性的正态理论框架，其主要终点为连续型变量。设每个臂中的个体结局独立同分布，方差为$\\sigma^{2}$，并假设治疗效应定义为均值差$\\delta = \\mu_{1} - \\mu_{2}$。该检验为单侧检验，I类错误率$\\alpha = 0.025$，目标把握度为$1 - \\beta = 0.9$，以检测$\\delta = 0.3$。初始计划假设$\\sigma^{2} = 1$。该设计在期中信息时间$t = 0.5$时，基于信息函数进行盲态样本量重估，其中合并的盲态方差估计值为$\\hat{\\sigma}^{2} = 1.44$。\n\n请从第一性原理出发——即原假设和备择假设下样本均值差的抽样分布、I类错误和把握度的定义，以及单侧$z$检验的行为——推导当盲态期中估计值$\\hat{\\sigma}^{2}$取代计划值$\\sigma^{2}$时，两组总的重估样本量的连续目标值$N_{\\text{new}}$。假设等比例分配，无其他适应性调整，并保留最初计划的临界值。忽略整数约束；报告$N_{\\text{new}}$的实数值，四舍五入至四位有效数字。",
            "solution": "该问题要求基于期中盲态方差估计，推导一项双臂优效性临床试验的重估总样本量$N_{\\text{new}}$。我们将从第一性原理出发，即双样本均值$z$检验的统计框架。\n\n设$X_{1j}$和$X_{2j}$分别为治疗组（第1组）和对照组（第2组）中第$j$名受试者的连续型结局。假设结局是独立的，并且（近似）服从正态分布，$X_{ij} \\sim N(\\mu_i, \\sigma^2)$，对于$i \\in \\{1, 2\\}$，具有共同方差$\\sigma^2$。这由中心极限定理证明是合理的。治疗效应是均值之差，$\\delta = \\mu_1 - \\mu_2$。\n\n该试验采用等比例分配，因此每组的样本量为$n_1 = n_2 = N/2$，其中$N$是总样本量。治疗效应的估计量是样本均值之差，$\\hat{\\delta} = \\bar{X}_1 - \\bar{X}_2$。\n\n$\\hat{\\delta}$的抽样分布是正态分布，其均值为$E[\\hat{\\delta}] = \\mu_1 - \\mu_2 = \\delta$，方差为$\\text{Var}(\\hat{\\delta}) = \\text{Var}(\\bar{X}_1) + \\text{Var}(\\bar{X}_2) = \\frac{\\sigma^2}{n_1} + \\frac{\\sigma^2}{n_2} = \\frac{\\sigma^2}{N/2} + \\frac{\\sigma^2}{N/2} = \\frac{4\\sigma^2}{N}$。因此，$\\hat{\\delta} \\sim N(\\delta, \\frac{4\\sigma^2}{N})$。\n\n该试验旨在检验单侧原假设$H_0: \\delta \\le 0$与备择假设$H_1: \\delta  0$。为构建检验，我们考虑边界情况$H_0: \\delta = 0$。标准化的检验统计量为：\n$$ Z = \\frac{\\hat{\\delta} - 0}{\\sqrt{\\text{Var}(\\hat{\\delta})}} = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\sqrt{4\\sigma^2/N}} $$\n在$H_0$下，$Z$服从标准正态分布，$Z \\sim N(0, 1)$。\n\n单侧I类错误率指定为$\\alpha = 0.025$。如果检验统计量$Z$超过临界值$c$，则拒绝原假设。该临界值由$P(Z  c | H_0) = \\alpha$确定。对于标准正态变量，这意味着$c = z_{1-\\alpha}$，即标准正态分布的$(1-\\alpha)$-分位数。给定$\\alpha = 0.025$，临界值为$c = z_{1-0.025} = z_{0.975}$。\n\n把握度是在特定备择假设为真时正确拒绝$H_0$的概率。该试验的把握度设置为$1 - \\beta = 0.9$，以检测治疗效应$\\delta_A = 0.3$。\n$$ 1 - \\beta = P\\left(Z  z_{1-\\alpha} \\mid \\delta = \\delta_A\\right) $$\n代入$Z$的定义：\n$$ 1 - \\beta = P\\left(\\frac{\\bar{X}_1 - \\bar{X}_2}{\\sqrt{4\\sigma^2/N}}  z_{1-\\alpha} \\mid \\delta = \\delta_A\\right) $$\n为了在备择假设下（其中$E[\\bar{X}_1 - \\bar{X}_2] = \\delta_A$）评估此概率，我们以不同方式对表达式进行标准化：\n$$ 1 - \\beta = P\\left(\\frac{(\\bar{X}_1 - \\bar{X}_2) - \\delta_A}{\\sqrt{4\\sigma^2/N}}  z_{1-\\alpha} - \\frac{\\delta_A}{\\sqrt{4\\sigma^2/N}}\\right) $$\n概率内左侧的表达式是一个标准正态变量。设$Z' \\sim N(0,1)$。那么：\n$$ P\\left(Z'  z_{1-\\alpha} - \\frac{\\delta_A \\sqrt{N}}{2\\sigma}\\right) = 1 - \\beta $$\n这意味着概率的参数必须是标准正态分布的$\\beta$-分位数$z_{\\beta}$，它等于$-z_{1-\\beta}$。\n$$ z_{1-\\alpha} - \\frac{\\delta_A \\sqrt{N}}{2\\sigma} = -z_{1-\\beta} $$\n求解总样本量$N$可得通用公式：\n$$ z_{1-\\alpha} + z_{1-\\beta} = \\frac{\\delta_A \\sqrt{N}}{2\\sigma} $$\n$$ \\sqrt{N} = \\frac{2\\sigma (z_{1-\\alpha} + z_{1-\\beta})}{\\delta_A} $$\n$$ N = \\frac{4\\sigma^2 (z_{1-\\alpha} + z_{1-\\beta})^2}{\\delta_A^2} $$\n该问题描述了一个盲态样本量重估程序。这涉及到使用方差的期中估计值$\\hat{\\sigma}^2 = 1.44$来重新计算达到目标把握度所需的样本量。重估保留了最初计划的临界值（$z_{1-\\alpha}$）、目标把握度（$1-\\beta$）以及感兴趣的效应量（$\\delta_A$）。因此，我们可以使用推导出的样本量公式，将计划方差$\\sigma^2 = 1$替换为期中估计值$\\hat{\\sigma}^2 = 1.44$。所有其他参数保持不变。\n\n重估后的总样本量$N_{\\text{new}}$由下式给出：\n$$ N_{\\text{new}} = \\frac{4\\hat{\\sigma}^2 (z_{1-\\alpha} + z_{1-\\beta})^2}{\\delta_A^2} $$\n我们代入给定值：\n$\\hat{\\sigma}^2 = 1.44$\n$\\delta_A = 0.3$\n$\\alpha = 0.025 \\implies z_{1-\\alpha} = z_{0.975}$\n$1-\\beta = 0.9 \\implies z_{1-\\beta} = z_{0.9}$\n\n标准正态分布所需的分位数为$z_{0.975} \\approx 1.959964$和$z_{0.9} \\approx 1.281552$。\n将这些值代入$N_{\\text{new}}$的方程中：\n$$ N_{\\text{new}} = \\frac{4(1.44) (z_{0.975} + z_{0.9})^2}{(0.3)^2} $$\n$$ N_{\\text{new}} = \\frac{5.76}{0.09} (1.959964 + 1.281552)^2 $$\n$$ N_{\\text{new}} = 64 \\times (3.241516)^2 $$\n$$ N_{\\text{new}} = 64 \\times 10.507427... $$\n$$ N_{\\text{new}} = 672.4753... $$\n问题要求结果四舍五入至四位有效数字。\n$$ N_{\\text{new}} \\approx 672.5 $$\n该值表示在观察到的期中方差下，为达到$90\\%$的把握度，两臂所需的总样本量的连续目标值。",
            "answer": "$$\n\\boxed{672.5}\n$$"
        },
        {
            "introduction": "除了频率主义方法，贝叶斯范式为自适应试验提供了另一种强大的视角，尤其是在反应自适应随机化（Response-Adaptive Randomization, RAR）中，这类问题常被建模为多臂老虎机（Multi-Armed Bandit, MAB）问题。Gittins 指数是解决 MAB 问题的一个经典最优策略，它通过精妙地平衡“探索”（学习未知臂的效应）与“利用”（选择当前最优臂）来最大化总体期望回报。这项编程练习要求你通过动态规划实现 Gittins 指数的计算，为你提供一个宝贵的、深入了解贝叶斯自适应设计背后复杂决策机制的动手实践机会 。",
            "id": "4950423",
            "problem": "考虑一个双臂贝叶斯自适应临床试验，其中每个患者的结果为二元，该试验被建模为一个多臂赌博机 (MAB)。每个臂对应一种治疗方案，其成功概率未知，并用一个贝塔先验进行建模。设臂 $i$ 的先验为 $\\mathrm{Beta}(a_i,b_i)$，结果建模为 $\\mathrm{Bernoulli}(p_i)$，其中 $p_i$ 未知。每当一个患者被分配到臂 $i$ 后，如果成功，则后验通过将 $a_i$ 加 $1$ 进行更新；如果失败，则将 $b_i$ 加 $1$。这与贝塔-伯努利模型的贝叶斯共轭性一致。未来的收益以因子 $\\gamma \\in (0,1)$ 进行几何贴现，其中成功时获得 $1$ 的收益，失败时获得 $0$ 的收益。\n\n在几何贴现因子 $\\gamma$ 下，一个臂状态 $(a,b)$ 的 Gittins 指数 (GI) 是通过一个等价的单臂马尔可夫决策过程 (MDP) 来定义的。在该 MDP 中，如果决定停止对该臂进行抽样，则可以获得一个每期恒定的补贴 $c$。令 $V_c(a,b)$ 表示从状态 $(a,b)$ 开始的最优贴现值，此时停止动作会产生每期为 $c$ 的即时且永久的收益，从而得到停止值为 $c/(1-\\gamma)$。对于状态 $(a,b)$ 的继续动作，期望即时收益是后验均值 $a/(a+b)$，下一状态以概率 $a/(a+b)$ 转移到 $(a+1,b)$，以概率 $b/(a+b)$ 转移到 $(a,b+1)$。因此，对于一个固定的补贴 $c$，贝尔曼最优方程为\n$$\nV_c(a,b) \\;=\\; \\max\\left\\{\\frac{c}{1-\\gamma},\\; \\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_c(a+1,b) + \\frac{b}{a+b}V_c(a,b+1)\\right]\\right\\}.\n$$\nGittins 指数 $\\mathrm{GI}(a,b)$ 是一个唯一的补贴 $c^*$，在该值下，对于状态 $(a,b)$，在停止和继续之间做出选择是无差异的，即停止成为最优选择的阈值补贴：\n$$\n\\mathrm{GI}(a,b) \\;=\\; \\inf\\left\\{c \\;:\\; \\frac{c}{1-\\gamma} \\;\\ge\\; \\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_c(a+1,b) + \\frac{b}{a+b}V_c(a,b+1)\\right]\\right\\}.\n$$\n该指数给出了下一个要分配的短视最优臂：在每个决策点，将下一个患者分配给具有较大 Gittins 指数的臂。\n\n您的任务是实现一个数值算法，通过动态规划和对 $c$ 进行二分法来近似计算贝塔-伯努利臂的 $\\mathrm{GI}(a,b)$。为使计算可行，对每个臂的未来样本数量使用一个有限的截断深度 $N_{\\max}$，并对所有满足 $(a'-a)+(b'-b)\\ge N_{\\max}$ 的状态 $(a',b')$ 施加边界条件 $V_c(a',b')=\\frac{c}{1-\\gamma}$。在此截断下，贴现值的最大误差上界为 $\\gamma^{N_{\\max}}/(1-\\gamma)$，因为每期收益最多为 $1$。\n\n算法要求：\n- 实现一个函数，通过在截断状态空间上进行反向归纳来计算 $V_c(a,b)$，在深度 $N_{\\max}$ 处使用边界条件 $V_c(a',b')=\\frac{c}{1-\\gamma}$。\n- 在 $c\\in[0,1]$ 上实现一个二分搜索，以在代码中指定的容差 $\\varepsilon$ 内找到近似的 Gittins 指数 $\\mathrm{GI}(a,b)$。在每个二分中点，重新计算 $V_c$，并通过比较停止值 $\\frac{c}{1-\\gamma}$ 和继续值来确定在 $(a,b)$ 处继续是否为最优。\n- 对于两个臂，计算它们的指数，并选择将下一次分配给予指数较大的臂。如果指数在舍入规格内相等，则选择臂 1 来打破平局。\n\n使用以下参数值的测试套件来评估您的实现：\n1. 臂 1：$\\mathrm{Beta}(10,6)$，臂 2：$\\mathrm{Beta}(8,8)$，贴现因子 $\\gamma=0.95$，截断深度 $N_{\\max}=200$。\n2. 臂 1：$\\mathrm{Beta}(1,1)$，臂 2：$\\mathrm{Beta}(1,1)$，贴现因子 $\\gamma=0.95$，截断深度 $N_{\\max}=200$。\n3. 臂 1：$\\mathrm{Beta}(100,1)$，臂 2：$\\mathrm{Beta}(10,20)$，贴现因子 $\\gamma=0.95$，截断深度 $N_{\\max}=200$。\n4. 臂 1：$\\mathrm{Beta}(20,20)$，臂 2：$\\mathrm{Beta}(3,1)$，贴现因子 $\\gamma=0.90$，截断深度 $N_{\\max}=200$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果必须是一个包含三项的列表：臂 1 的 Gittins 指数、臂 2 的 Gittins 指数以及所选的臂号（$1$ 或 $2$）。指数表示为四舍五入到六位小数的浮点数，所选臂表示为整数。例如，输出格式必须是\n$$\n[\\,[\\text{GI}_1,\\text{GI}_2,\\text{arm}],\\,[\\text{GI}_1,\\text{GI}_2,\\text{arm}],\\,\\dots]\n$$\n其中每个 $\\text{GI}_i$ 都四舍五入到六位小数。除了构成有效列表所必需的结构外，不应打印任何额外的文本或空白字符。",
            "solution": "该问题要求为具有贝塔-伯努利后验的双臂贝叶斯赌博机计算 Gittins 指数，以决定下一步要抽样哪个臂。这是最优序贯决策领域的一个经典问题，Gittins 指数提供了一种最大化总贴现期望收益的最优策略。\n\n问题的核心是为一个后验成功概率由 $\\mathrm{Beta}(a,b)$ 分布描述的臂计算 Gittins 指数 $\\mathrm{GI}(a,b)$。Gittins 指数通过一个辅助的单臂马尔可夫决策过程 (MDP) 定义。在这个 MDP 中，每一步我们既可以“继续”从该臂抽样，也可以永久“停止”。\n\n此 MDP 的状态由贝塔分布的参数 $(a,b)$ 给出。\n动作为：\n1.  **继续**：再次抽样该臂。此动作产生等于成功概率后验均值的即时期望收益，即 $\\frac{a}{a+b}$。观察到结果（成功或失败）后，状态以概率 $\\frac{a}{a+b}$ 转移到 $(a+1,b)$，或以概率 $\\frac{b}{a+b}$ 转移到 $(a,b+1)$。未来的收益以因子 $\\gamma$ 进行贴现。\n2.  **停止**：终止从此臂抽样。此动作为所有后续时间段提供一个恒定的“补贴”收益 $c$。此永久收益流的总贴现值为 $\\frac{c}{1-\\gamma}$。\n\n令 $V_c(a,b)$ 为在给定补贴 $c$ 的情况下，从状态 $(a,b)$ 开始的最大总贴现期望收益。价值函数 $V_c(a,b)$ 必须满足贝尔曼最优方程，该方程平衡了停止的价值与继续的价值：\n$$\nV_c(a,b) \\;=\\; \\max\\left\\{\\underbrace{\\frac{c}{1-\\gamma}}_{\\text{Value of Stopping}},\\; \\underbrace{\\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_c(a+1,b) + \\frac{b}{a+b}V_c(a,b+1)\\right]}_{\\text{Value of Continuing}}\\right\\}\n$$\n\nGittins 指数 $\\mathrm{GI}(a,b)$ 被定义为使得在状态 $(a,b)$ 处停止和继续的价值相等的特定补贴值 $c$。它是继续抽样这一选项的“公平价格”。数学上，它是满足以下条件的 $c^*$ 值：\n$$\n\\frac{c^*}{1-\\gamma} \\;=\\; \\frac{a}{a+b} + \\gamma\\left[\\frac{a}{a+b}V_{c^*}(a+1,b) + \\frac{b}{a+b}V_{c^*}(a,b+1)\\right]\n$$\n\n为了数值求解此问题，我们采用指定的两部分算法：动态规划和二分搜索。\n\n**1. 状态空间截断与动态规划**\n\n状态空间 $(a,b)$ 是无限的。为了使计算可行，我们对其进行截断。设臂的初始状态为 $(a_0, b_0)$。我们考虑一个包含 $N_{\\max}$ 个未来样本的有限视界。任何在 $N_{\\max}$ 次或更多次抽样后达到的状态 $(a',b')$，即满足 $(a'-a_0) + (b'-b_0) \\ge N_{\\max}$ 的状态，都被视为终止状态。在这些边界状态下，问题指定了边界条件 $V_c(a',b') = \\frac{c}{1-\\gamma}$。这意味着在视界尽头，我们被迫采取停止动作。\n\n对于一个固定的补贴 $c$，我们可以使用动态规划（特别是反向归纳）来计算这个截断视界内任何状态 $(a,b)$ 的 $V_c(a,b)$。设一个状态 $(a_0+i, b_0+j)$ 的“深度”为 $n = i+j$。我们首先计算深度为 $n=N_{\\max}-1$ 的所有状态的 $V_c$ 值，然后是 $n=N_{\\max}-2$，依此类推，直到 $n=0$（初始状态 $(a_0,b_0)$）。\n\n计算深度为 $n$ 的状态 $(a,b)$ 需要深度为 $n+1$ 的状态 $V_c(a+1,b)$ 和 $V_c(a,b+1)$ 的值。反向归纳确保了这些值在归纳的前一步中已经可用。迭代过程如下：\n- 我们使用一个二维数组 `V_table[i][j]` 来存储值 $V_c(a_0+i, b_0+j)$。\n- 我们将 $n$ 从 $N_{\\max}-1$ 迭代到 $0$。\n- 对于每个 $n$，我们遍历所有满足 $i+j=n$ 的有效状态 $(a_0+i, b_0+j)$。\n- 对于每个这样的状态，我们使用深度为 $n+1$ 的状态的已知值（来自 `V_table` 或边界值 $\\frac{c}{1-\\gamma}$）来计算其继续值，然后应用贝尔曼方程中的 `max` 算子来找到 `V_table[i][j]`。\n\n**2. Gittins 指数的二分搜索**\n\nGittins 指数是使得在根状态 $(a_0, b_0)$ 处停止和继续之间无差异的 $c$ 值。我们可以通过在区间 $[0,1]$ 上对 $c$ 进行二分搜索来找到这个值。\n我们定义一个关于 $c$ 的函数：\n$$\nf(c) = \\left( \\frac{a_0}{a_0+b_0} + \\gamma\\left[\\frac{a_0}{a_0+b_0}V_c(a_0+1,b_0) + \\frac{b_0}{a_0+b_0}V_c(a_0,b_0+1)\\right] \\right) - \\frac{c}{1-\\gamma}\n$$\n我们正在寻找使 $f(c^*) = 0$ 的根 $c^*$。函数 $f(c)$ 可以被证明是关于 $c$ 单调递减的，这使得二分法成为一种合适的方法。\n\n二分算法过程如下：\n- 初始化 $c$ 的搜索区间，例如 $[c_{low}, c_{high}] = [0,1]$。\n- 重复直到区间宽度 $(c_{high}-c_{low})$ 小于指定的容差 $\\varepsilon$：\n    a. 选择中点 $c_{mid} = (c_{low} + c_{high})/2$。\n    b. 使用上述动态规划方法计算价值函数 $V_{c_{mid}}$ 的必要值。\n    c. 使用 $V_{c_{mid}}$ 评估根状态 $(a_0, b_0)$ 的继续值。设此值为 $\\text{cont\\_val}$。\n    d. 将 $\\text{cont\\_val}$ 与停止值 $\\text{stop\\_val} = c_{mid}/(1-\\gamma)$ 进行比较。\n    e. 如果 $\\text{cont\\_val}  \\text{stop\\_val}$，这意味着补贴 $c_{mid}$太低，不足以使停止具有吸引力。真实的 Gittins 指数必须更高。我们更新 $c_{low} = c_{mid}$。\n    f. 否则，如果 $\\text{cont\\_val} \\le \\text{stop\\_val}$，则补贴足够高（或正好）。真实的 Gittins 指数必须在下半区间。我们更新 $c_{high} = c_{mid}$。\n- Gittins 指数的近似值是搜索区间的最终中点。\n\n**最终决策规则**\n\n在为两个臂分别计算出 Gittins 指数 $\\mathrm{GI}_1$ 和 $\\mathrm{GI}_2$ 后，下一个患者被分配到指数较高的臂。如果 $\\mathrm{GI}_1 \\ge \\mathrm{GI}_2$，则根据问题的平局打破规则选择臂 1。\n\n这种组合算法能够对 Gittins 指数进行鲁棒的数值近似，为自适应分配问题提供了一个有原则的解决方案。",
            "answer": "```python\nimport numpy as np\n\ndef compute_gittins_index(a0, b0, gamma, N_max, epsilon):\n    \"\"\"\n    Computes the Gittins index for a Beta-Bernoulli arm using dynamic programming\n    and bisection search.\n\n    Args:\n        a0 (float): Initial alpha parameter of the Beta prior.\n        b0 (float): Initial beta parameter of the Beta prior.\n        gamma (float): Discount factor.\n        N_max (int): Truncation depth for the state space.\n        epsilon (float): Tolerance for the bisection search.\n\n    Returns:\n        float: The approximated Gittins index.\n    \"\"\"\n    if a0 = 0 or b0 = 0:\n        raise ValueError(\"Beta parameters a and b must be positive.\")\n\n    c_low, c_high = 0.0, 1.0\n\n    # V_table[i][j] will store V_c(a0+i, b0+j)\n    # The maximum index required is N_max, so size is N_max+1.\n    V_table = np.zeros((N_max + 1, N_max + 1))\n\n    while c_high - c_low  epsilon:\n        c_mid = (c_low + c_high) / 2.0\n        stop_val = c_mid / (1.0 - gamma)\n\n        # Backward induction using dynamic programming to compute V_c_mid\n        # n is the number of future samples, from N_max-1 down to 0\n        for n in range(N_max - 1, -1, -1):\n            # i is the number of future successes\n            for i in range(n + 1):\n                j = n - i  # j is the number of future failures\n                \n                a = a0 + i\n                b = b0 + j\n\n                # Get V for next states (at depth n+1)\n                # Success state: a0+(i+1), b0+j\n                # Failure state: a0+i, b0+(j+1)\n                \n                # Check if the next states are on or past the boundary depth N_max\n                if (i + 1) + j = N_max:\n                    V_succ = stop_val\n                else:\n                    # Value was computed in the (n+1) iteration of the outer loop\n                    V_succ = V_table[i + 1, j]\n                \n                if i + (j + 1) = N_max:\n                    V_fail = stop_val\n                else:\n                    # Value was computed in the (n+1) iteration of the outer loop\n                    V_fail = V_table[i, j + 1]\n\n                p = a / (a + b)\n                \n                continuation_value = p + gamma * (p * V_succ + (1.0 - p) * V_fail)\n                \n                V_table[i, j] = max(stop_val, continuation_value)\n        \n        # After filling the V_table for c_mid, check the condition at the root state (a0, b0)\n        p0 = a0 / (a0 + b0)\n\n        # Get values for next states from root\n        if 1 = N_max:\n            V_succ_root = stop_val\n            V_fail_root = stop_val\n        else:\n            V_succ_root = V_table[1, 0]\n            V_fail_root = V_table[0, 1]\n            \n        root_continuation_value = p0 + gamma * (p0 * V_succ_root + (1.0 - p0) * V_fail_root)\n\n        if root_continuation_value  stop_val:\n            c_low = c_mid\n        else:\n            c_high = c_mid\n            \n    return (c_low + c_high) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {'arm1': (10, 6), 'arm2': (8, 8), 'gamma': 0.95, 'N_max': 200},\n        {'arm1': (1, 1), 'arm2': (1, 1), 'gamma': 0.95, 'N_max': 200},\n        {'arm1': (100, 1), 'arm2': (10, 20), 'gamma': 0.95, 'N_max': 200},\n        {'arm1': (20, 20), 'arm2': (3, 1), 'gamma': 0.90, 'N_max': 200},\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case in test_cases:\n        a1, b1 = case['arm1']\n        a2, b2 = case['arm2']\n        gamma = case['gamma']\n        N_max = case['N_max']\n\n        gi1 = compute_gittins_index(float(a1), float(b1), gamma, N_max, epsilon)\n        gi2 = compute_gittins_index(float(a2), float(b2), gamma, N_max, epsilon)\n\n        # Tie-breaking rule: choose arm 1 if indices are equal\n        chosen_arm = 1 if gi1 = gi2 else 2\n        \n        results.append([round(gi1, 6), round(gi2, 6), chosen_arm])\n\n    # Format the final output string\n    # E.g., [[0.123456,0.234567,2],[...]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}