{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在巩固网络拓扑中一些最基本的度量指标。通过为一个假想的信号传导模块计算每个节点的偏心率和整个网络的直径，你将直接应用这些核心定义。此练习通过对比加权和无权两种模型，突显了相互作用的强度（例如，信号传输的延迟）如何从根本上改变我们对网络中节点间“距离”的理解。",
            "id": "4372739",
            "problem": "在一个哺乳动物细胞的信号模块中，考虑一个由六种蛋白质 $v_1,\\ldots,v_6$ 组成的有向网络。每个有向相互作用 $v_i \\to v_j$ 都被赋予一个有效延迟权重 $w_{ij} \\in \\{0,1,2,3,4\\}$，其中 $w_{ij} = 0$ 表示不存在直接相互作用。加权邻接矩阵 $\\mathbf{W} = (w_{ij})$ 为\n$$\n\\mathbf{W} =\n\\begin{pmatrix}\n0  1  0  3  0  0 \\\\\n0  0  1  0  2  0 \\\\\n0  0  0  1  0  2 \\\\\n4  0  0  0  1  0 \\\\\n0  4  0  0  0  1 \\\\\n1  0  4  0  0  0\n\\end{pmatrix}.\n$$\n假设所有存在的边的延迟都严格为正，并且该网络作为有向图是强连通的。通过二元邻接矩阵 $\\mathbf{A} = (a_{ij})$ 定义无权模型，其中如果 $w_{ij} > 0$，则 $a_{ij} = 1$，否则 $a_{ij} = 0$。在有权模型中，从 $v_i$ 到 $v_j$ 的最短路径距离是从 $v_i$ 到 $v_j$ 的所有有向路径中的最小总延迟。在无权模型中，每条存在的边的长度为 $1$，最短路径距离是有向路径上的最小边数。\n\n对于两种模型（有权和无权），计算每个节点 $v \\in \\{v_1,\\ldots,v_6\\}$ 的离心率 $\\epsilon(v)$，定义为从 $v$ 到网络中任何其他节点的最大最短路径距离。然后计算网络直径 $D$，定义为所有节点离心率的最大值。在每个模型中，识别哪些节点是外周节点，其中如果一个节点的离心率等于直径，则该节点是外周节点。\n\n将您的最终答案表示为单个行矩阵，按顺序连接以下内容：\n- $\\epsilon_{\\mathrm{unw}}(v_1),\\ldots,\\epsilon_{\\mathrm{unw}}(v_6)$，\n- $\\epsilon_{\\mathrm{w}}(v_1),\\ldots,\\epsilon_{\\mathrm{w}}(v_6)$，\n- $D_{\\mathrm{unw}}, D_{\\mathrm{w}}$，\n- 无权模型的外周指示向量 $\\in \\{0,1\\}^6$，按节点顺序 $v_1,\\ldots,v_6$（其中 $1$ 表示外周节点），\n- 有权模型的外周指示向量 $\\in \\{0,1\\}^6$，按节点顺序 $v_1,\\ldots,v_6$。\n\n提供精确的整数值；不要四舍五入。不需要单位。",
            "solution": "用户希望在两种不同的模型（无权模型和有权模型）下分析一个给定的由六种蛋白质组成的有向网络。目标是为每个模型计算节点离心率、网络直径，并识别外周节点。\n\n**问题设置**\n网络包含 $N=6$ 个节点，$\\{v_1, v_2, v_3, v_4, v_5, v_6\\}$。相互作用由加权邻接矩阵 $\\mathbf{W} = (w_{ij})$ 定义：\n$$\n\\mathbf{W} =\n\\begin{pmatrix}\n0  1  0  3  0  0 \\\\\n0  0  1  0  2  0 \\\\\n0  0  0  1  0  2 \\\\\n4  0  0  0  1  0 \\\\\n0  4  0  0  0  1 \\\\\n1  0  4  0  0  0\n\\end{pmatrix}\n$$\n在该矩阵中，$w_{ij}$ 表示从 $v_i$ 到 $v_j$ 的有向边的延迟（权重）。权重为 $0$ 表示不存在边。\n\n该问题要求基于从 $\\mathbf{W}$ 派生出的两种模型进行两部分分析。\n\n**第 1 部分：无权模型分析**\n\n在无权模型中，每条存在的边的长度都被赋为 $1$。连通性由二元邻接矩阵 $\\mathbf{A} = (a_{ij})$ 描述，其中如果 $w_{ij} > 0$，则 $a_{ij} = 1$，否则 $a_{ij} = 0$。\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  1  0  0  0  1 \\\\\n1  0  1  0  0  0\n\\end{pmatrix}\n$$\n最短路径距离 $d_{\\mathrm{unw}}(v_i, v_j)$ 是从 $v_i$ 到 $v_j$ 的有向路径中的最小边数。为了找到离心率，我们必须首先计算所有节点对之间的最短路径矩阵 $\\mathbf{D}_{\\mathrm{unw}}$。由于该图是无权的，我们可以从每个节点开始运行广度优先搜索 (BFS)。\n\n- **从 $v_1$ 出发**：距离为 $(d(v_1,v_1), \\dots, d(v_1,v_6)) = (0, 1, 2, 1, 2, 3)$。\n- **从 $v_2$ 出发**：距离为 $(3, 0, 1, 2, 1, 2)$。\n- **从 $v_3$ 出发**：距离为 $(2, 3, 0, 1, 2, 1)$。\n- **从 $v_4$ 出发**：距离为 $(1, 2, 3, 0, 1, 2)$。\n- **从 $v_5$ 出发**：距离为 $(2, 1, 2, 3, 0, 1)$。\n- **从 $v_6$ 出发**：距离为 $(1, 2, 1, 2, 3, 0)$。\n\n无权模型的所有节点对之间的最短路径矩阵为：\n$$\n\\mathbf{D}_{\\mathrm{unw}} =\n\\begin{pmatrix}\n0  1  2  1  2  3 \\\\\n3  0  1  2  1  2 \\\\\n2  3  0  1  2  1 \\\\\n1  2  3  0  1  2 \\\\\n2  1  2  3  0  1 \\\\\n1  2  1  2  3  0\n\\end{pmatrix}\n$$\n节点 $v$ 的离心率 $\\epsilon(v)$ 是从 $v$ 到网络中任何其他节点的最大最短路径距离。它对应于距离矩阵中 $v$ 所在行的最大值。\n\n- $\\epsilon_{\\mathrm{unw}}(v_1) = \\max(0, 1, 2, 1, 2, 3) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_2) = \\max(3, 0, 1, 2, 1, 2) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_3) = \\max(2, 3, 0, 1, 2, 1) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_4) = \\max(1, 2, 3, 0, 1, 2) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_5) = \\max(2, 1, 2, 3, 0, 1) = 3$。\n- $\\epsilon_{\\mathrm{unw}}(v_6) = \\max(1, 2, 1, 2, 3, 0) = 3$。\n\n无权离心率向量为 $(\\epsilon_{\\mathrm{unw}}(v_1), \\dots, \\epsilon_{\\mathrm{unw}}(v_6)) = (3, 3, 3, 3, 3, 3)$。\n\n网络直径 $D_{\\mathrm{unw}}$ 是所有节点离心率的最大值。\n$$D_{\\mathrm{unw}} = \\max_{i} \\{\\epsilon_{\\mathrm{unw}}(v_i)\\} = 3$$\n如果一个节点的离心率等于直径，则该节点是外周节点。由于所有节点的离心率都是 $3$，等于直径，所以所有节点都是外周节点。外周指示向量是 $(1, 1, 1, 1, 1, 1)$。\n\n**第 2 部分：有权模型分析**\n\n在有权模型中，从 $v_i$ 到 $v_j$ 的边的长度由延迟 $w_{ij}$ 给出。最短路径距离 $d_{\\mathrm{w}}(v_i, v_j)$ 是从 $v_i$ 到 $v_j$ 的有向路径上权重的最小总和。我们可以使用 Floyd-Warshall 算法或从每个节点运行 Dijkstra 算法来计算所有节点对之间的最短路径矩阵 $\\mathbf{D}_{\\mathrm{w}}$。该图没有负权重环（实际上没有负权重），因此这些算法是适用的。\n\n设 $\\mathbf{D}_{\\mathrm{w}}^{(k)}$ 为仅使用来自 $\\{v_1, \\dots, v_k\\}$ 的中间顶点的最短路径距离矩阵。我们用给定的直接边权重初始化 $\\mathbf{D}_{\\mathrm{w}}^{(0)}$，其他情况为 $\\infty$（对角线上为 $0$）。在对 $k=1, \\dots, 6$ 迭代应用 Floyd-Warshall 更新规则 $D_{ij} = \\min(D_{ij}, D_{ik} + D_{kj})$ 后，我们得到最终的距离矩阵 $\\mathbf{D}_{\\mathrm{w}} = \\mathbf{D}_{\\mathrm{w}}^{(6)}$。\n\n有权模型的所有节点对之间的最短路径矩阵结果为：\n$$\n\\mathbf{D}_{\\mathrm{w}} =\n\\begin{pmatrix}\n0  1  2  3  3  4 \\\\\n4  0  1  2  2  3 \\\\\n3  4  0  1  2  2 \\\\\n3  4  5  0  1  2 \\\\\n2  3  4  5  0  1 \\\\\n1  2  3  4  4  0\n\\end{pmatrix}\n$$\n现在，我们通过取 $\\mathbf{D}_{\\mathrm{w}}$ 每一行的最大值来计算有权离心率。\n\n- $\\epsilon_{\\mathrm{w}}(v_1) = \\max(0, 1, 2, 3, 3, 4) = 4$。\n- $\\epsilon_{\\mathrm{w}}(v_2) = \\max(4, 0, 1, 2, 2, 3) = 4$。\n- $\\epsilon_{\\mathrm{w}}(v_3) = \\max(3, 4, 0, 1, 2, 2) = 4$。\n- $\\epsilon_{\\mathrm{w}}(v_4) = \\max(3, 4, 5, 0, 1, 2) = 5$。\n- $\\epsilon_{\\mathrm{w}}(v_5) = \\max(2, 3, 4, 5, 0, 1) = 5$。\n- $\\epsilon_{\\mathrm{w}}(v_6) = \\max(1, 2, 3, 4, 4, 0) = 4$。\n\n有权离心率向量为 $(\\epsilon_{\\mathrm{w}}(v_1), \\dots, \\epsilon_{\\mathrm{w}}(v_6)) = (4, 4, 4, 5, 5, 4)$。\n\n有权网络直径 $D_{\\mathrm{w}}$ 是这些离心率的最大值。\n$$D_{\\mathrm{w}} = \\max_{i} \\{\\epsilon_{\\mathrm{w}}(v_i)\\} = 5$$\n如果一个节点的离心率等于直径（$5$），则该节点是外周节点。离心率为 $5$ 的节点是 $v_4$ 和 $v_5$。因此，有权模型的外周指示向量是 $(0, 0, 0, 1, 1, 0)$。\n\n**最终答案汇总**\n\n问题要求将以下结果按顺序连接成一个单一的行矩阵：\n1. 无权离心率：$(3, 3, 3, 3, 3, 3)$\n2. 有权离心率：$(4, 4, 4, 5, 5, 4)$\n3. 直径（无权，有权）：$(3, 5)$\n4. 无权外周指示向量：$(1, 1, 1, 1, 1, 1)$\n5. 有权外周指示向量：$(0, 0, 0, 1, 1, 0)$\n这构成一个包含 $6+6+2+6+6 = 26$ 个元素的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  3  3  3  3  3  4  4  4  5  5  4  3  5  1  1  1  1  1  1  0  0  0  1  1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本计算之后，此练习将这些概念应用于一个更符合生物学实际的场景：一个有向的信号传导网络。这里的核心任务是区分拓扑距离（以“跳数”或边的数量衡量）与功能距离（以信号转导的累积“成本”或延迟衡量）。这项实践对于理解生物通路中信号传播的速度和可达性至关重要，并要求你阐释为何在评估药理干预效果时，加权直径通常是比无权直径更有意义的指标。",
            "id": "4372644",
            "problem": "在系统生物医学中，有向信号网络模拟了分子实体（例如，受体、衔接蛋白、激酶和转录因子）之间的因果影响。考虑一个有向网络，其节点为 $\\{R, A, B, C, D, E, F\\}$，其中每条有向边 $(u \\rightarrow v)$ 都有一个正的边成本 $c(u,v)$，该成本代表了有效的信号转导成本（例如，以任意单位计的平均传输延迟）。有向边及其成本如下：\n- $R \\rightarrow A$，成本为 $c(R,A)=0.7$\n- $R \\rightarrow C$，成本为 $c(R,C)=3.2$\n- $A \\rightarrow B$，成本为 $c(A,B)=0.6$\n- $A \\rightarrow D$，成本为 $c(A,D)=1.9$\n- $B \\rightarrow C$，成本为 $c(B,C)=0.5$\n- $B \\rightarrow E$，成本为 $c(B,E)=2.8$\n- $C \\rightarrow D$，成本为 $c(C,D)=0.4$\n- $D \\rightarrow E$，成本为 $c(D,E)=0.3$\n- $D \\rightarrow F$，成本为 $c(D,F)=0.2$\n- $E \\rightarrow F$，成本为 $c(E,F)=0.3$\n- $F \\rightarrow C$，成本为 $c(F,C)=0.4$\n\n采用以下定义，这些定义在图论中是标准的，并且适用于有向信号网络：\n- 无权有向最短路径长度 $\\ell_{s}(u,v)$ 是从 $u$ 到 $v$ 的任何有向路径上的最小有向边数。如果从 $u$ 无法到达 $v$，那么为了下面求最大值的目的，$\\ell_{s}(u,v)$ 是未定义的。\n- 加权有向最短路径长度 $\\ell_{w}(u,v)$ 是从 $u$ 到 $v$ 的所有有向路径 $P$ 上的最小总成本 $\\sum_{e \\in P} c(e)$。如果从 $u$ 无法到达 $v$，那么为了下面求最大值的目的，$\\ell_{w}(u,v)$ 是未定义的。\n- 无权有向直径 $D_{s}$ 是对于所有 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$，$\\ell_{s}(u,v)$ 的最大值。\n- 加权有向直径 $D_{w}$ 是对于所有 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$，$\\ell_{w}(u,v)$ 的最大值。\n\n任务：\n1. 通过确定最小有向跳数 $\\ell_{s}(u,v)$，然后对所有具有有限可达性的有序对 $(u,v)$ 取最大值，计算该网络的 $D_{s}$。\n2. 通过确定最小有向路径成本 $\\ell_{w}(u,v)$，然后对所有具有有限可达性的有序对 $(u,v)$ 取最大值，计算该网络的 $D_{w}$。\n3. 从信号级联中路径长度的解释以及独立段成本的可加性出发，解释在评估在单个节点引入的药理学干预的潜在可达性时，偏好 $D_{w}$ 或 $D_{s}$ 的生物学原理。\n\n将您的最终数值结果报告为有序对 $(D_{s}, D_{w})$。无需四舍五入。",
            "solution": "用户提供了一个问题，要求计算代表信号网络的有向图的无权和加权直径，并解释这两种度量的生物学相关性。\n\n### 步骤 1：问题验证\n\n**提取的已知条件：**\n-   **节点：** $V = \\{R, A, B, C, D, E, F\\}$\n-   **有向边和成本：**\n    -   $R \\rightarrow A$, $c(R,A)=0.7$\n    -   $R \\rightarrow C$, $c(R,C)=3.2$\n    -   $A \\rightarrow B$, $c(A,B)=0.6$\n    -   $A \\rightarrow D$, $c(A,D)=1.9$\n    -   $B \\rightarrow C$, $c(B,C)=0.5$\n    -   $B \\rightarrow E$, $c(B,E)=2.8$\n    -   $C \\rightarrow D$, $c(C,D)=0.4$\n    -   $D \\rightarrow E$, $c(D,E)=0.3$\n    -   $D \\rightarrow F$, $c(D,F)=0.2$\n    -   $E \\rightarrow F$, $c(E,F)=0.3$\n    -   $F \\rightarrow C$, $c(F,C)=0.4$\n-   **定义：**\n    -   无权最短路径长度 $\\ell_{s}(u,v)$：从 $u$ 到 $v$ 的路径上的最小边数。\n    -   加权最短路径长度 $\\ell_{w}(u,v)$：从 $u$ 到 $v$ 的路径上的最小成本总和。\n    -   无权直径 $D_{s}$：对于所有 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$，$\\ell_{s}(u,v)$ 的最大值。\n    -   加权直径 $D_{w}$：对于所有 $u \\neq v$ 且 $v$ 可从 $u$ 到达的有序对 $(u,v)$，$\\ell_{w}(u,v)$ 的最大值。\n\n**验证结论：**\n问题是有效的。\n-   它具有**科学基础**，使用标准的图论概念（$D_s, D_w$）来分析系统生物医学中公认的模型（信号网络）。\n-   它是**适定的**。图被完全指定，边成本为正（防止负成本循环），定义精确且标准。每个计算任务都存在唯一解。仅在可达对上取最大值的条件正确处理了未定义的路径长度。\n-   它是**客观的**。这些任务是计算性的，需要基于给定解释的逻辑推理，没有主观因素。\n-   问题没有表现出任何列出的缺陷（例如，不完整性、矛盾、模糊性）。\n\n### 步骤 2：求解推导\n\n该问题要求计算两个网络属性，即无权直径 $D_s$ 和加权直径 $D_w$，然后比较分析它们的生物学效用。这涉及到为给定有向图的无权和加权版本计算所有节点对之间的最短路径。\n\n**任务 1：计算无权直径 $D_s$**\n\n任意两个节点 $u$ 和 $v$ 之间的无权最短路径长度 $\\ell_s(u,v)$ 是从 $u$ 到 $v$ 的路径上的最小边数（跳数）。我们可以通过从网络中的每个节点开始执行广度优先搜索 (BFS) 来找到这些长度。\n\n-   让我们找到强连通分量。集合 $\\{C, D, F\\}$ 构成一个强连通分量，因为 $C \\to D \\to F \\to C$。该循环的长度为 3 跳。所有节点都可以从 $R$ 到达。但并非所有节点都能到达 $R$。\n-   通过从 7 个节点中的每一个执行 BFS，我们可以构建无权最短路径长度矩阵 $\\ell_s(u,v)$。条目 $\\infty$ 表示从 $u$ 无法到达 $v$。\n\n$\\ell_s(u,v)$ 矩阵：\n$$\n\\begin{array}{c|ccccccc}\n\\ell_s(u,v) & R & A & B & C & D & E & F \\\\\n\\hline\nR & 0 & 1 & 2 & 1 & 2 & 3 & 3 \\\\\nA & \\infty & 0 & 1 & 2 & 1 & 2 & 2 \\\\\nB & \\infty & \\infty & 0 & 1 & 2 & 1 & 2 \\\\\nC & \\infty & \\infty & \\infty & 0 & 1 & 2 & 2 \\\\\nD & \\infty & \\infty & \\infty & 2 & 0 & 1 & 1 \\\\\nE & \\infty & \\infty & \\infty & 2 & 3 & 0 & 1 \\\\\nF & \\infty & \\infty & \\infty & 1 & 2 & 3 & 0 \\\\\n\\end{array}\n$$\n无权直径 $D_s$ 是该矩阵中除对角线元素外的最大有限值。\n$$\nD_s = \\max_{u \\neq v, \\ell_s(u,v)  \\infty} \\ell_s(u,v)\n$$\n检查矩阵，最大值为 $3$。该值出现在多个节点对上，包括：\n-   $\\ell_s(R,E) = 3$ (路径: $R \\to A \\to B \\to E$)\n-   $\\ell_s(R,F) = 3$ (路径: $R \\to A \\to D \\to F$)\n-   $\\ell_s(E,D) = 3$ (路径: $E \\to F \\to C \\to D$)\n-   $\\ell_s(F,E) = 3$ (路径: $F \\to C \\to D \\to E$)\n\n因此，无权直径为 $D_s = 3$。\n\n**任务 2：计算加权直径 $D_w$**\n\n加权最短路径长度 $\\ell_w(u,v)$ 是从 $u$ 到 $v$ 的路径上的最小边成本总和。由于所有边成本都是正的，我们可以从每个节点开始使用 Dijkstra 算法来找到所有节点对的最短路径。或者，对于小图，也可以使用 Floyd-Warshall 算法。\n\n让我们将从每个节点运行 Dijkstra 算法的结果总结在一个加权最短路径长度矩阵 $\\ell_w(u,v)$ 中。\n\n-   从源点 $R$ 出发：$\\ell_w(R,E) = \\ell_w(R,D) + c(D,E) = (\\ell_w(R,C) + c(C,D)) + c(D,E) = ((\\ell_w(R,B) + c(B,C)) + c(C,D)) + c(D,E) = (((\\ell_w(R,A) + c(A,B)) + c(B,C)) + c(C,D)) + c(D,E) = (((0.7+0.6)+0.5)+0.4)+0.3 = 2.5$。\n……对所有节点对依此类推。\n\n完整的 $\\ell_w(u,v)$ 矩阵为：\n$$\n\\begin{array}{c|ccccccc}\n\\ell_w(u,v)  R  A  B  C  D  E  F \\\\\n\\hline\nR  0  0.7  1.3  1.8  2.2  2.5  2.4 \\\\\nA  \\infty  0  0.6  1.1  1.5  1.8  1.7 \\\\\nB  \\infty  \\infty  0  0.5  0.9  1.2  1.1 \\\\\nC  \\infty  \\infty  \\infty  0  0.4  0.7  0.6 \\\\\nD  \\infty  \\infty  \\infty  0.6  0  0.3  0.2 \\\\\nE  \\infty  \\infty  \\infty  0.7  1.1  0  0.3 \\\\\nF  \\infty  \\infty  \\infty  0.4  0.8  1.1  0 \\\\\n\\end{array}\n$$\n加权直径 $D_w$ 是该矩阵中除对角线外的最大值。\n$$\nD_w = \\max_{u \\neq v, \\ell_w(u,v)  \\infty} \\ell_w(u,v)\n$$\n通过检查，矩阵中的最大值是 $2.5$，即 $\\ell_w(R,E)$。与此成本对应的路径是 $R \\to A \\to B \\to C \\to D \\to E$，总成本为 $0.7 + 0.6 + 0.5 + 0.4 + 0.3 = 2.5$。\n\n因此，加权直径为 $D_w = 2.5$。\n\n**任务 3：偏好 $D_w$ 或 $D_s$ 的生物学原理**\n\n问题要求基于边成本 $c(u,v)$ 被解释为信号转导成本（例如，时间延迟）的观点，给出在评估药理学干预的可达性时偏好 $D_w$ 或 $D_s$ 的理由。\n\n在节点 $u$ 处的药理学干预会沿着有向路径在网络中传播其影响。该干预在下游节点 $v$ 的“可达性”根本上与信号从 $u$ 传播到 $v$ 所需的时间有关。\n\n无权直径 $D_s$ 衡量信号在任意两个可达节点之间传播所需的最大顺序步骤数。该度量将每个信号传递步骤（每条边）视为等效的。它提供了一个纯粹拓扑学的网络最大“范围”的度量。\n\n加权直径 $D_w$ 衡量信号在任意两个可达节点之间传播的最大累积成本（例如，总时间延迟）。该度量明确地包含了信号传导过程的异质性，其中一些步骤可能很快（低成本），而另一些则很慢（高成本）。问题陈述成本代表“有效的信号转导成本”，例如“平均传输延迟”。\n\n鉴于这种解释，$D_w$ 是更具生物学相关性的度量。生物信号传导是一个时间过程。信号传播的速度和效率决定了细胞反应的时间尺度和幅度。一条包含几个非常缓慢、限速步骤（高成本）的路径，其总延迟可能比一条包含许多快速步骤（低成本）的路径长得多。\n\n例如，比较从 $A$ 直接到 $D$ 的路径与从 $A$ 经由 $B$ 到 $C$ 的路径。\n-   路径 $A \\to D$：$\\ell_s(A,D) = 1$，但 $\\ell_w(A,D) = 1.9$。\n-   路径 $A \\to B \\to C$：$\\ell_s(A,C) = 2$，但 $\\ell_w(A,C) = 0.6 + 0.5 = 1.1$。\n\n在 $A$ 处的干预会比影响节点 $D$（成本 $1.9$）更快地影响节点 $C$（成本 $1.1$），尽管 $D$ 在拓扑上“更近”（1 跳 vs. 2 跳）。$D_s$ 度量会误导性地表明，从 $A$ 出发，$D$ 比 $C$ 更容易受到影响。\n\n因此，在评估药理学干预的潜在可达性时（就其影响传播的距离和速度而言），加权直径 $D_w$ 更为优越。它提供了一个衡量效应在网络中任何地方显现所需的最大时间延迟或累积成本的指标，这在动态生物系统中是比简单地计算中间过程步骤数更现实、功能上更有意义的可达性度量。\n\n最终要求的结果是有序对 $(D_s, D_w)$。根据计算，$D_s = 3$ 且 $D_w = 2.5$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 3  2.5 \\end{pmatrix} } $$"
        },
        {
            "introduction": "这项动手实践将网络直径的概念应用于系统生物医学中的一个关键问题：评估网络的鲁棒性以及与疾病相关的突变所带来的影响。你将需要通过编写程序来实现相关算法，计算网络在移除“中心节点”（hubs）前后的直径变化。这个练习不仅能让你获得计算建模的实践经验，还能让你学会如何解释生物网络在受到扰动（如基因敲除）后发生的拓扑结构变化。",
            "id": "4372650",
            "problem": "给定一组无向生物相互作用网络，这些网络模拟大分子连接性（例如，蛋白质-蛋白质相互作用（PPI）网络）。每个网络表示为一个具有有限节点集和无向边的简单图。考虑将以下图论的基本定义应用于系统生物医学：对于一个简单的无向图 $G = (V, E)$，两节点之间的路径是由边连接的任意不重复节点序列，其长度是该序列中的边数，而最短路径距离 $d(u,v)$ 是连接 $u$ 和 $v$ 的所有存在路径中的最小长度。$G$ 的直径 $D(G)$ 是在给定的目标连通分量中，所有无序节点对之间的最大最短路径距离。在本问题中，目标连通分量定义为按节点数计算最大的连通分量；如果多个分量具有相同的最大尺寸，则选择其中直径最大的那个。如果所选分量的节点数少于 $2$ 个，则定义 $D(G) = 0$。所有路径长度均为无单位的边计数，并且必须作为整数处理。\n\n与疾病相关的功能丧失性突变可以抽象为从网络中移除一个节点（及其所有关联边）。中枢节点定义为当前图中度数最大的节点。给定一个整数 $k \\ge 1$，通过移除 $k$ 个度数最大的节点来执行中枢节点移除操作，若度数相同，则按节点标识符的字典序（升序）解决。移除后，使用与上述相同的规则，在最大的连通分量上重新计算直径。\n\n你的任务是编写一个完整的程序，为每个提供的测试网络计算一对直径 $\\left[D_{\\text{before}}, D_{\\text{after}}\\right]$，其中 $D_{\\text{before}}$ 是原始图最大连通分量的直径，而 $D_{\\text{after}}$ 是按规定移除 $k$ 个中枢节点后最大连通分量的直径。将所有结果以逗号分隔的列表形式输出在单行上，并用方括号括起来，每个元素本身也是一个双元素列表，顺序与测试用例相同。\n\n仅使用上述逻辑和数学定义，不使用任何快捷公式。从第一性原理出发推导计算最短路径距离和直径的方法。\n\n测试套件（边以无序的字符串对给出；所有图都是简单无向图）：\n\n- 测试用例 $1$（具有两个通过桥连接的中枢节点的双星型类PPI网络），移除参数 $k=1$：\n  - 节点包括：TP53, EGFR, BRCA1, AKT1, PTEN, MAPK1, RB1, PIK3CA, CDK2, MDM2, MYC。\n  - 边：\n    - (\"TP53\",\"EGFR\")\n    - (\"TP53\",\"BRCA1\"), (\"TP53\",\"AKT1\"), (\"TP53\",\"PTEN\"), (\"TP53\",\"MAPK1\"), (\"TP53\",\"RB1\")\n    - (\"EGFR\",\"PIK3CA\"), (\"EGFR\",\"CDK2\"), (\"EGFR\",\"MDM2\"), (\"EGFR\",\"MYC\")\n\n- 测试用例 $2$（包含 $6$ 个基因的线性链），移除参数 $k=1$：\n  - 节点：G1, G2, G3, G4, G5, G6。\n  - 边：\n    - (\"G1\",\"G2\"), (\"G2\",\"G3\"), (\"G3\",\"G4\"), (\"G4\",\"G5\"), (\"G5\",\"G6\")\n\n- 测试用例 $3$（大小为 $5$ 的完全团），移除参数 $k=1$：\n  - 节点：A, B, C, D, E。\n  - 边：\n    - (\"A\",\"B\"), (\"A\",\"C\"), (\"A\",\"D\"), (\"A\",\"E\"),\n    - (\"B\",\"C\"), (\"B\",\"D\"), (\"B\",\"E\"),\n    - (\"C\",\"D\"), (\"C\",\"E\"),\n    - (\"D\",\"E\")\n\n答案规范：\n- 对每个测试用例，计算 $D_{\\text{before}}$ 和 $D_{\\text{after}}$ 为整数。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，格式严格为：$\\left[ [D_{\\text{before}}^{(1)}, D_{\\text{after}}^{(1)}], [D_{\\text{before}}^{(2)}, D_{\\text{after}}^{(2)}], [D_{\\text{before}}^{(3)}, D_{\\text{after}}^{(3)}] \\right]$，不含空格。",
            "solution": "该问题要求我们计算一个给定的生物网络（表示为简单无向图）在其最大连通分量（LCC）上的直径，分别在移除指定数量的中枢节点之前和之后。解决方案需要从第一性原理出发，逐步实现图算法。\n\n### 方法论框架\n\n对于每个测试用例，整个过程包括两个主要阶段：\n1.  分析初始图，以确定其LCC的直径 $D_{\\text{before}}$。\n2.  识别并移除 $k$ 个中枢节点，然后分析所得图，以确定新LCC的直径 $D_{\\text{after}}$。\n\n这需要几个基本的图论算法，我们将推导并实现它们。\n\n#### 1. 图的表示\n图 $G = (V, E)$ 由节点集 $V$ 和边集 $E$ 组成。我们将使用邻接表来表示图。这通过一个字典实现，其中每个键是节点标识符，其对应的值是其相邻节点标识符的集合。这种结构对于图的遍历和处理生物学中常见的稀疏网络非常高效。\n\n#### 2. 查找连通分量\n为了识别LCC，我们必须首先将图划分为其连通分量。连通分量是一个子图，其中任意两个节点都通过路径相互连接，并且它与超图中的任何其他节点都没有连接。我们可以使用像广度优先搜索（BFS）这样的图遍历算法来找到所有分量。\n\n算法流程如下：\n- 维护一个已访问节点的集合，初始为空。\n- 遍历图中的每个节点。\n- 如果一个节点尚未被访问，它属于一个新的、未被发现的分量。从这个节点开始进行BFS遍历。\n- BFS将访问所有可达节点，这些节点共同构成一个连通分量。将所有这些节点添加到已访问集合中。\n- 存储这个分量（作为其节点的集合），并重复此过程，直到所有节点都已被访问。\n\n#### 3. 所有节点对最短路径（APSP）与直径\n问题将两节点 $u$ 和 $v$ 之间的最短路径距离 $d(u,v)$ 定义为连接它们的路径中的最小边数。对于无权图，BFS是计算单源最短路径（SSSP）的最有效算法。从源节点 $s$ 开始进行BFS，到任何其他节点 $v$ 的距离是它在BFS树中的层级，即从 $s$ 到 $v$ 的路径上的边数。\n\n为了找到一个连通分量的直径，我们需要该分量内所有节点对之间的最短路径距离。这可以通过对分量中的每个节点执行SSSP（BFS）算法来实现。\n\n连通分量 $G$ 的直径 $D(G)$ 是该分量中所有节点对之间的最大最短路径距离：\n$$\nD(G) = \\max_{u, v \\in V} d(u,v)\n$$\n这等同于找到任意节点的最大离心率，其中节点 $u$ 的离心率是 $\\epsilon(u) = \\max_{v \\in V} d(u,v)$。\n\n计算给定分量直径的步骤是：\n1.  如果分量包含少于 $2$ 个节点，其直径为 $0$。\n2.  否则，初始化一个最大距离变量为 $0$。\n3.  对于分量中的每个节点 $u$：\n    a. 从 $u$ 开始运行BFS，找到到分量中所有其他节点 $v$ 的距离。\n    b. 这些距离中的最大值是 $u$ 的离心率。如果该离心率更大，则更新全局最大距离。\n4.  最终的最大距离就是该分量的直径。\n\n#### 4. 选择最大连通分量（LCC）\n问题为选择目标分量指定了精确的规则：\n1.  找到所有连通分量并确定它们的尺寸（节点数）。\n2.  在所有分量中确定最大尺寸。\n3.  筛选分量列表，只保留那些具有此最大尺寸的分量。\n4.  如果这产生单个分量，则它就是LCC。\n5.  如果出现平局（多个分量具有相同的最大尺寸），则计算每个候选分量的直径。LCC是其中直径最大的那个。返回的值就是这个最大直径。\n\n#### 5. 中枢节点识别与移除\n中枢节点被定义为图中度数最大的节点。移除 $k$ 个中枢节点的过程如下：\n1.  对于图中的每个节点，计算其度（连接到它的边的数量）。\n2.  识别出具有最高度数的节点列表。\n3.  如果度数存在平局，这些节点按其字符串标识符的字典序（升序）排序。\n4.  从此排序列表中的前 $k$ 个节点被指定为要移除的中枢节点。\n5.  通过删除这 $k$ 个节点以及所有与它们关联的边来构建一个新图。\n\n#### 6. 最终计算\n每个测试用例的总体算法是：\n1.  根据提供的节点和边构建初始图。\n2.  对此图应用LCC选择逻辑和直径计算，以找到 $D_{\\text{before}}$。\n3.  从初始图中识别并移除前 $k$ 个中枢节点，以创建一个新的、受扰动的图。\n4.  对此新图应用LCC选择和直径计算，以找到 $D_{\\text{after}}$。\n5.  该测试用例的结果是配对 $[D_{\\text{before}}, D_{\\text{after}}]$。对所有测试用例重复此过程。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the network diameter problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Double-star PPI network\n        {\n            \"nodes\": {\"TP53\", \"EGFR\", \"BRCA1\", \"AKT1\", \"PTEN\", \"MAPK1\", \"RB1\", \"PIK3CA\", \"CDK2\", \"MDM2\", \"MYC\"},\n            \"edges\": [\n                (\"TP53\", \"EGFR\"), (\"TP53\", \"BRCA1\"), (\"TP53\", \"AKT1\"), (\"TP53\", \"PTEN\"),\n                (\"TP53\", \"MAPK1\"), (\"TP53\", \"RB1\"), (\"EGFR\", \"PIK3CA\"), (\"EGFR\", \"CDK2\"),\n                (\"EGFR\", \"MDM2\"), (\"EGFR\", \"MYC\")\n            ],\n            \"k\": 1\n        },\n        # Test Case 2: Linear chain\n        {\n            \"nodes\": {\"G1\", \"G2\", \"G3\", \"G4\", \"G5\", \"G6\"},\n            \"edges\": [(\"G1\", \"G2\"), (\"G2\", \"G3\"), (\"G3\", \"G4\"), (\"G4\", \"G5\"), (\"G5\", \"G6\")],\n            \"k\": 1\n        },\n        # Test Case 3: Complete clique\n        {\n            \"nodes\": {\"A\", \"B\", \"C\", \"D\", \"E\"},\n            \"edges\": [\n                (\"A\", \"B\"), (\"A\", \"C\"), (\"A\", \"D\"), (\"A\", \"E\"),\n                (\"B\", \"C\"), (\"B\", \"D\"), (\"B\", \"E\"),\n                (\"C\", \"D\"), (\"C\", \"E\"),\n                (\"D\", \"E\")\n            ],\n            \"k\": 1\n        }\n    ]\n\n    def build_graph(nodes, edges):\n        \"\"\"Builds an adjacency list representation of the graph.\"\"\"\n        graph = defaultdict(set)\n        for node in nodes:\n            graph[node] # Ensure all nodes are in the graph dict\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        return graph\n\n    def get_connected_components(graph):\n        \"\"\"Finds all connected components in a graph using BFS.\"\"\"\n        visited = set()\n        components = []\n        for node in graph:\n            if node not in visited:\n                component = set()\n                queue = [node]\n                visited.add(node)\n                component.add(node)\n                head = 0\n                while head  len(queue):\n                    current_node = queue[head]\n                    head += 1\n                    for neighbor in graph[current_node]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            component.add(neighbor)\n                            queue.append(neighbor)\n                components.append(frozenset(component))\n        return components\n\n    def bfs_shortest_paths(graph, start_node):\n        \"\"\"Calculates shortest paths from a start node in an unweighted graph.\"\"\"\n        if start_node not in graph:\n            return {}\n        distances = {start_node: 0}\n        queue = [(start_node, 0)]\n        head = 0\n        while head  len(queue):\n            current_node, dist = queue[head]\n            head += 1\n            for neighbor in graph.get(current_node, set()):\n                if neighbor not in distances:\n                    distances[neighbor] = dist + 1\n                    queue.append((neighbor, dist + 1))\n        return distances\n\n\n    def calculate_diameter(graph, component_nodes):\n        \"\"\"Calculates the diameter of a given connected component.\"\"\"\n        if len(component_nodes)  2:\n            return 0\n        \n        max_dist = 0\n        # The graph passed to bfs must only contain nodes of the component.\n        subgraph = {node: graph[node] for node in component_nodes}\n\n        for start_node in component_nodes:\n            distances = bfs_shortest_paths(subgraph, start_node)\n            if not distances:\n                continue\n            # If component is disconnected, max would be on reachable nodes.\n            # But get_connected_components ensures this is not an issue.\n            current_max = max(distances.values())\n            if current_max  max_dist:\n                max_dist = current_max\n        return max_dist\n\n    def compute_diameter_of_lcc(graph):\n        \"\"\"Computes the diameter of the largest connected component (LCC).\"\"\"\n        if not graph:\n            return 0\n        \n        components = get_connected_components(graph)\n        if not components:\n            return 0\n\n        max_size = 0\n        for comp in components:\n            if len(comp)  max_size:\n                max_size = len(comp)\n\n        largest_components = [comp for comp in components if len(comp) == max_size]\n        \n        if len(largest_components) == 1:\n            lcc_nodes = largest_components[0]\n            return calculate_diameter(graph, lcc_nodes)\n        else:\n            max_diam = -1\n            for comp_nodes in largest_components:\n                diam = calculate_diameter(graph, comp_nodes)\n                if diam  max_diam:\n                    max_diam = diam\n            return max_diam if max_diam != -1 else 0\n\n    def remove_hubs(graph, k):\n        \"\"\"Identifies and removes the top k hubs from a graph.\"\"\"\n        if not graph:\n            return {}\n\n        nodes_with_degrees = []\n        for node in graph:\n            nodes_with_degrees.append((len(graph[node]), node))\n        \n        # Sort by degree (descending) and then node ID (ascending)\n        nodes_with_degrees.sort(key=lambda x: (-x[0], x[1]))\n\n        nodes_to_remove = {item[1] for item in nodes_with_degrees[:k]}\n        \n        new_graph = defaultdict(set)\n        original_nodes = set(graph.keys())\n        remaining_nodes = original_nodes - nodes_to_remove\n\n        for node in remaining_nodes:\n            new_graph[node] # Ensure node exists in new graph\n            for neighbor in graph[node]:\n                if neighbor in remaining_nodes:\n                    new_graph[node].add(neighbor)\n\n        return new_graph\n\n    results = []\n    for case in test_cases:\n        nodes, edges, k = case[\"nodes\"], case[\"edges\"], case[\"k\"]\n\n        # Before removal\n        graph_before = build_graph(nodes, edges)\n        d_before = compute_diameter_of_lcc(graph_before)\n\n        # After removal\n        graph_after = remove_hubs(graph_before, k)\n        d_after = compute_diameter_of_lcc(graph_after)\n        \n        results.append([d_before, d_after])\n\n    # Format the final output string exactly as specified.\n    str_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  2 \\\\\n5  3 \\\\\n1  1\n\\end{pmatrix}\n}\n$$"
        }
    ]
}