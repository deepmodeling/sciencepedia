{
    "hands_on_practices": [
        {
            "introduction": "要识别合成致死，第一步是量化两种扰动（例如，两种药物）之间的相互作用。Bliss 独立模型提供了一个基准，用于判断组合效应是协同、拮抗还是简单的相加。本练习将指导您根据细胞增殖数据计算 Bliss 协同作用评分，这是从表型层面评估合成致死潜力的关键定量技能 。",
            "id": "4354444",
            "problem": "一个大小为 $N_0$ 的细胞群体在每种条件下均遵循指数增长规律，这与在无资源限制情况下混合均匀群体的第一性原理相符：$N(t) = N_0 \\exp(\\mu t)$，其中 $N(t)$ 是时间 $t$ 时的细胞数量，$\\mu$ 是人均净增长率。在一项评估潜在合成致死效应的药物组合实验中，在 $t = 72$ 小时内测得以下净增长率（单位为 $\\text{h}^{-1}$）：\n- 对照组（溶剂）：$\\mu_C = \\frac{\\ln 2}{24}$。\n- 单独使用药物 $A$：$\\mu_A = 0.015$。\n- 单独使用药物 $B$：$\\mu_B = 0.020$。\n- 组合 $A+B$：$\\mu_{AB} = -0.005$。\n\n将条件 $X \\in \\{A, B, AB\\}$ 下的归一化存活率定义为比率 $W_X = \\frac{N_X(t)}{N_C(t)}$，其中 $N_C(t)$ 是时间 $t$ 时的对照组细胞计数。在效应独立（Bliss 独立性）的假设下，无相互作用时的预期组合存活率等于各单一药物存活率的乘积。Bliss 协同作用评分定义为在时间 $t$ 时，观测到的组合存活率与此独立性预期的偏差。\n\n仅使用指数增长定律和独立性原理，计算在 $t = 72$ 小时时的 Bliss 协同作用评分。将您的答案四舍五入至四位有效数字，并以无单位小数的形式报告。\n\n此外，采用以下操作性标准来判断合成致死：如果 (i) 两种单一药物都是非致死的，量化为 $W_A > \\theta$ 和 $W_B > \\theta$ (其中 $\\theta = 0.2$)，(ii) 该组合是致死的，量化为 $W_{AB}  \\lambda$ (其中 $\\lambda = 0.1$)，并且 (iii) Bliss 偏差严格为负，则该组合被称为合成致死。根据您计算出的量，判断该组合是否在这些标准下符合合成致死的条件。您最终报告的答案应仅为按规定四舍五入的 Bliss 协同作用评分；请勿在最终答案中包含任何单位或分类标签。",
            "solution": "题目要求计算一种药物组合的 Bliss 协同作用评分，并根据一组给定的标准评估该组合是否为合成致死。首先，我将验证题目陈述。\n\n**步骤 1：提取已知条件**\n- 细胞生长模型：$N(t) = N_0 \\exp(\\mu t)$\n- 分析的时间点：$t = 72$ 小时\n- 净增长率（$\\text{h}^{-1}$）：\n  - 对照组：$\\mu_C = \\frac{\\ln 2}{24}$\n  - 药物 A：$\\mu_A = 0.015$\n  - 药物 B：$\\mu_B = 0.020$\n  - 组合 A+B：$\\mu_{AB} = -0.005$\n- 归一化存活率定义：$W_X = \\frac{N_X(t)}{N_C(t)}$，其中 $X \\in \\{A, B, AB\\}$\n- Bliss 独立性模型：预期组合存活率 $W_{AB, \\text{exp}} = W_A \\cdot W_B$\n- Bliss 协同作用评分定义：观测到的组合存活率（$W_{AB, \\text{obs}}$）与独立性预期（$W_{AB, \\text{exp}}$）的偏差。\n- 合成致死标准：\n  - (i) 单一药物非致死：$W_A > \\theta$ 且 $W_B > \\theta$，其中 $\\theta = 0.2$。\n  - (ii) 组合致死：$W_{AB}  \\lambda$，其中 $\\lambda = 0.1$。\n  - (iii) 协同相互作用：Bliss 偏差严格为负。\n- 最终答案要求：报告四舍五入至四位有效数字的 Bliss 协同作用评分。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，使用了定量药理学和系统生物学中的标准模型（指数增长）和概念（Bliss 独立性、协同作用评分）。所提供的增长率对于体外细胞培养实验是物理上现实的；例如，$\\mu_C$ 对应于 24 小时的倍增时间，这是一个常见值。这个问题是适定的，为得到唯一解提供了所有必要的定义、常数和数据。语言客观而精确。没有内部矛盾或信息缺失。这个问题不简单，因为它需要仔细应用所提供的定义并进行多步计算。\n\n**步骤 3：结论和行动**\n问题有效。我将进行完整解答。\n\n条件 $X$ 在时间 $t$ 时的归一化存活率 $W_X$ 定义为该条件下细胞数量与对照组条件下细胞数量的比值。使用指数增长定律，这可以表示为增长率的函数：\n$$W_X(t) = \\frac{N_X(t)}{N_C(t)} = \\frac{N_0 \\exp(\\mu_X t)}{N_0 \\exp(\\mu_C t)} = \\exp((\\mu_X - \\mu_C) t)$$\n此表达式对 $X \\in \\{A, B, AB\\}$ 均有效。分析在 $t=72$ 小时进行。\n\n首先，我们计算单一药物的存活率 $W_A$ 和 $W_B$。\n对于药物 A：\n$$W_A = \\exp\\left((\\mu_A - \\mu_C)t\\right) = \\exp\\left(\\left(0.015 - \\frac{\\ln 2}{24}\\right) \\cdot 72\\right)$$\n$$W_A = \\exp\\left(0.015 \\cdot 72 - \\frac{\\ln 2}{24} \\cdot 72\\right) = \\exp(1.08 - 3\\ln 2) = \\exp(1.08) \\exp(-\\ln(2^3)) = \\frac{\\exp(1.08)}{8}$$\n对于药物 B：\n$$W_B = \\exp\\left((\\mu_B - \\mu_C)t\\right) = \\exp\\left(\\left(0.020 - \\frac{\\ln 2}{24}\\right) \\cdot 72\\right)$$\n$$W_B = \\exp\\left(0.020 \\cdot 72 - \\frac{\\ln 2}{24} \\cdot 72\\right) = \\exp(1.44 - 3\\ln 2) = \\exp(1.44) \\exp(-\\ln 8) = \\frac{\\exp(1.44)}{8}$$\n\n接下来，我们计算组合的观测存活率 $W_{AB, \\text{obs}}$。\n$$W_{AB, \\text{obs}} = \\exp\\left((\\mu_{AB} - \\mu_C)t\\right) = \\exp\\left(\\left(-0.005 - \\frac{\\ln 2}{24}\\right) \\cdot 72\\right)$$\n$$W_{AB, \\text{obs}} = \\exp\\left(-0.005 \\cdot 72 - \\frac{\\ln 2}{24} \\cdot 72\\right) = \\exp(-0.36 - 3\\ln 2) = \\exp(-0.36) \\exp(-\\ln 8) = \\frac{\\exp(-0.36)}{8}$$\n\nBliss 独立性模型假定，组合的预期存活率是各单一药物存活率的乘积：\n$$W_{AB, \\text{exp}} = W_A \\cdot W_B = \\left(\\frac{\\exp(1.08)}{8}\\right) \\cdot \\left(\\frac{\\exp(1.44)}{8}\\right) = \\frac{\\exp(1.08 + 1.44)}{64} = \\frac{\\exp(2.52)}{64}$$\n\nBliss 协同作用评分 $S_{\\text{Bliss}}$ 是观测存活率与预期存活率的偏差。题目指出，对于合成致死（一种协同作用形式），该偏差必须为负。协同作用意味着观测到的效应（细胞杀伤或生长抑制）比预期的更强，即观测存活率低于预期存活率（$W_{AB, \\text{obs}}  W_{AB, \\text{exp}}$）。因此，该评分必须定义为：\n$$S_{\\text{Bliss}} = W_{AB, \\text{obs}} - W_{AB, \\text{exp}}$$\n代入我们推导出的表达式：\n$$S_{\\text{Bliss}} = \\frac{\\exp(-0.36)}{8} - \\frac{\\exp(2.52)}{64}$$\n\n现在，我们计算数值。\n$W_{AB, \\text{obs}} = \\frac{\\exp(-0.36)}{8} \\approx \\frac{0.6976763}{8} \\approx 0.0872095$\n$W_{AB, \\text{exp}} = \\frac{\\exp(2.52)}{64} \\approx \\frac{12.427179}{64} \\approx 0.1941747$\n$$S_{\\text{Bliss}} \\approx 0.0872095 - 0.1941747 \\approx -0.1069652$$\n四舍五入到四位有效数字，Bliss 协同作用评分为 $-0.1070$。\n\n作为推理过程的一部分，我们评估合成致死的标准。\n(i) 单一药物非致死：检查是否 $W_A > 0.2$ 且 $W_B > 0.2$。\n$W_A = \\frac{\\exp(1.08)}{8} \\approx \\frac{2.94468}{8} \\approx 0.3681$。由于 $0.3681 > 0.2$，此条件满足。\n$W_B = \\frac{\\exp(1.44)}{8} \\approx \\frac{4.22070}{8} \\approx 0.5276$。由于 $0.5276 > 0.2$，此条件满足。\n条件 (i) 满足。\n\n(ii) 组合致死：检查是否 $W_{AB}  0.1$。\n$W_{AB, \\text{obs}} \\approx 0.0872$。由于 $0.0872  0.1$，条件 (ii) 满足。\n\n(iii) 协同相互作用：检查 Bliss 偏差是否严格为负。\n$S_{\\text{Bliss}} \\approx -0.1070$。由于 $-0.1070  0$，条件 (iii) 满足。\n\n所有三个标准均已满足，因此根据所提供的操作性定义，该组合符合合成致死的条件。最终答案是 Bliss 协同作用评分本身。",
            "answer": "$$\\boxed{-0.1070}$$"
        },
        {
            "introduction": "与药物组合类似，基因间的相互作用也可以通过统计模型来量化。在分析高通量基因筛选（如 CRISPR 筛选）的数据时，我们需要一个严谨的框架来区分真实的遗传相互作用和实验噪音。本练习介绍了一种标准方法，即在对数转换后的活力数据上应用线性模型，从而精确检验基因对之间是否存在合成致死关系 。",
            "id": "4354529",
            "problem": "您会获得两个基因在四种基因型中的复本生存力测量值，这两个基因由二元指示符 $a \\in \\{0,1\\}$ 和 $b \\in \\{0,1\\}$ 表示。基因型 $(a,b) = (0,0)$ 是野生型，$(1,0)$ 携带基因 A 的功能丧失突变，$(0,1)$ 携带基因 B 的功能丧失突变，$(1,1)$ 携带 A 和 B 两个基因的功能丧失突变。生存力以无单位分数形式在左开右闭区间 $(0,1]$ 内测量，值越高表示存活率越高。将基因型复本的必需性定义为 $E = -\\log(v)$，其中 $v$ 是测量的生存力。在生存效应独立的情况下，双突变体的生存力相对于单突变体和野生型是乘性关系，经过对数转换后，这使得必需性具有加性期望。如果双突变体的必需性超过加性期望，且超出的部分是一个统计上显著的正交互作用项，则存在合成致死。\n\n您的任务是对每个测试用例实现以下流程：\n- 对于每种基因型的每组复本生存力测量值，计算必需性 $E = -\\log(v)$。\n- 使用组均值计算不同基因型之间的必需性差异，包括主效应和双突变体超出加性模型的过量必需性。\n- 在复本水平上对必需性拟合一个线性模型，模型包含截距项、$a$ 和 $b$ 的主效应项以及它们的交互作用项 $ab$。使用普通最小二乘法 (OLS; Ordinary Least Squares)，并遵循线性模型的标准假设：$E[\\varepsilon] = 0$，$\\operatorname{Var}(\\varepsilon) = \\sigma^2$，以及独立同分布的误差。\n- 在显著性水平 $\\alpha = 0.05$ 下，使用单侧 t 检验来检验交互作用系数是否严格大于 $0$。设原假设为 $H_0: \\beta_{AB} = 0$，备择假设为 $H_1: \\beta_{AB} > 0$。如果估计的交互作用项为正，并且单侧 p 值小于或等于 $\\alpha$，则判定为存在合成致死。\n\n本问题中没有物理单位。所有生存力值均为小数，必须视为区间 $(0,1]$ 内的分数。不使用角度。不使用百分比。\n\n使用以下复本生存力值的测试套件（每个元素是一个复本）。对于每个测试用例，四个列表的顺序是：野生型 $(a=0,b=0)$、单突变体 A $(a=1,b=0)$、单突变体 B $(a=0,b=1)$、双突变体 AB $(a=1,b=1)$：\n- 测试用例 1 (预期有强合成致死效应)：\n  $[0.92, 0.90, 0.91, 0.89, 0.93, 0.90]$,\n  $[0.81, 0.79, 0.80, 0.82, 0.78, 0.80]$,\n  $[0.86, 0.84, 0.85, 0.83, 0.86, 0.85]$,\n  $[0.35, 0.32, 0.34, 0.31, 0.33, 0.34]$.\n- 测试用例 2 (近似加性，无交互作用)：\n  $[0.91, 0.90, 0.92, 0.89, 0.91, 0.90]$,\n  $[0.80, 0.81, 0.79, 0.80, 0.82, 0.78]$,\n  $[0.85, 0.84, 0.86, 0.85, 0.83, 0.85]$,\n  $[0.74, 0.75, 0.76, 0.73, 0.75, 0.74]$.\n- 测试用例 3 (有轻微正交互作用和较高方差；显著性处于临界水平)：\n  $[0.90, 0.85, 0.95, 0.88, 0.92]$,\n  $[0.80, 0.75, 0.85, 0.78, 0.82]$,\n  $[0.86, 0.80, 0.90, 0.83, 0.87]$,\n  $[0.70, 0.76, 0.72, 0.68, 0.79]$.\n- 测试用例 4 (拮抗性交互作用；共同存在时致死性较低)：\n  $[0.91, 0.90, 0.92, 0.89, 0.91, 0.90]$,\n  $[0.82, 0.81, 0.83, 0.80, 0.82, 0.81]$,\n  $[0.86, 0.85, 0.87, 0.84, 0.86, 0.85]$,\n  $[0.82, 0.81, 0.83, 0.80, 0.82, 0.82]$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个布尔值，指示是否在相应的测试用例（按 1 到 4 的顺序）中检测到合成致死。例如，输出形式为 $[r_1, r_2, r_3, r_4]$，其中每个 $r_i \\in \\{\\text{True}, \\text{False}\\}$。",
            "solution": "该问题要求实现一个统计程序，用于从复本生存力测量值中检测两个基因 A 和 B 之间的合成致死。其核心原理是在线性模型框架内对遗传交互作用进行建模，并检验是否存在一个显著的正交互作用项，该项是合成致死的定量标志。\n\n首先，通过对数转换 $E = -\\log(v)$，将原始生存力测量值 $v$ 转换为必需性分数 $E$。此转换至关重要，因为它将生存力上独立乘性效应的原假设转换为了必需性的加性模型。对这种加性模型的偏离，特别是双突变体中出现高于预期的必需性，表明存在合成致死交互作用。\n\n该实验对应于一个 $2 \\times 2$ 析因设计，因子分别是基因 A（指示符 $a \\in \\{0,1\\}$）和基因 B（指示符 $b \\in \\{0,1\\}$）的功能状态。任何复本的必需性 $E$ 都通过以下线性方程建模：\n$$E = \\beta_0 + \\beta_A a + \\beta_B b + \\beta_{AB} ab + \\varepsilon$$\n其中 $\\beta_0$ 是截距（野生型必需性），$\\beta_A$ 和 $\\beta_B$ 分别是基因 A 和 B 中突变的主效应，$\\beta_{AB}$ 是交互作用项，$\\varepsilon$ 是一个随机误差项，假设其服从均值为 0、方差恒为 $\\sigma^2$ 的正态分布。\n\n在该模型下，四种基因型的平均必需性为：\n- 野生型 $(a=0, b=0)$: $\\mu_{00} = \\beta_0$\n- 单突变体 A $(a=1, b=0)$: $\\mu_{10} = \\beta_0 + \\beta_A$\n- 单突变体 B $(a=0, b=1)$: $\\mu_{01} = \\beta_0 + \\beta_B$\n- 双突变体 AB $(a=1, b=1)$: $\\mu_{11} = \\beta_0 + \\beta_A + \\beta_B + \\beta_{AB}$\n\n这些参数的普通最小二乘法 (OLS) 估计值可以从每个基因型组的必需性样本均值（表示为 $\\bar{E}_{00}, \\bar{E}_{10}, \\bar{E}_{01}, \\bar{E}_{11}$）推导出来：\n- $\\hat{\\beta}_0 = \\bar{E}_{00}$\n- $\\hat{\\beta}_A = \\bar{E}_{10} - \\bar{E}_{00}$\n- $\\hat{\\beta}_B = \\bar{E}_{01} - \\bar{E}_{00}$\n- $\\hat{\\beta}_{AB} = \\bar{E}_{11} - (\\bar{E}_{10} - \\bar{E}_{00}) - (\\bar{E}_{01} - \\bar{E}_{00}) - \\bar{E}_{00} = \\bar{E}_{11} - \\bar{E}_{10} - \\bar{E}_{01} + \\bar{E}_{00}$\n\n交互作用项 $\\beta_{AB}$ 量化了对加性模型的偏离。一个正的 $\\beta_{AB}$ 意味着双突变体的必需性大于单个效应的总和，这定义了合成致死。我们使用单侧 t 检验对此进行正式检验，原假设为 $H_0: \\beta_{AB} = 0$ (加性)，备择假设为 $H_1: \\beta_{AB} > 0$ (合成致死)。\n\n$t$ 统计量的计算公式为：\n$$t = \\frac{\\hat{\\beta}_{AB}}{\\text{SE}(\\hat{\\beta}_{AB})}$$\n交互作用系数估计值的标准误 $\\text{SE}(\\hat{\\beta}_{AB})$ 是从样本均值线性组合的方差推导出来的：\n$$\\text{SE}(\\hat{\\beta}_{AB}) = \\sqrt{\\text{Var}(\\bar{E}_{11} - \\bar{E}_{10} - \\bar{E}_{01} + \\bar{E}_{00})}$$\n假设样本独立且存在方差齐性（各组方差恒为 $\\sigma^2$），则变为：\n$$\\text{SE}(\\hat{\\beta}_{AB}) = \\sqrt{\\sigma^2 \\left( \\frac{1}{n_{00}} + \\frac{1}{n_{10}} + \\frac{1}{n_{01}} + \\frac{1}{n_{11}} \\right)}$$\n其中 $n_{ij}$ 是基因型 $(i,j)$ 的复本数。未知的总体方差 $\\sigma^2$ 使用所有四个组的合并方差进行估计，即模型中的均方误差 (MSE)：\n$$\\hat{\\sigma}^2 = \\frac{\\sum_{i,j} \\sum_{k=1}^{n_{ij}} (E_{ijk} - \\bar{E}_{ij})^2}{n - p}$$\n这里，$E_{ijk}$ 是基因型 $(i,j)$ 的第 $k$ 个复本的必需性，$n$ 是总复本数 ($n = n_{00} + n_{10} + n_{01} + n_{11}$)，$p=4$ 是模型中的参数数量。分母 $n-p$ 代表 t 检验的自由度 ($df$)。\n\n计算出 $t$ 统计量后，我们确定单侧 p 值，即在原假设为真的情况下，观察到与我们的统计量一样极端或更极端的值的概率：$p = P(T_{df} > t)$，其中 $T_{df}$ 是一个服从自由度为 $df$ 的 t 分布的随机变量。\n\n最后应用决策规则：如果估计的交互作用项为正 ($\\hat{\\beta}_{AB} > 0$) 并且 p 值小于或等于指定的显著性水平 $\\alpha = 0.05$，则判定存在合成致死。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to process test cases for synthetic lethality detection.\n    \"\"\"\n    # Test suite of replicate viability values.\n    # Order: wild-type (0,0), single mutant A (1,0),\n    # single mutant B (0,1), double mutant AB (1,1).\n    test_cases = [\n        # Test case 1 (strong synthetic lethality expectation)\n        (\n            [0.92, 0.90, 0.91, 0.89, 0.93, 0.90],\n            [0.81, 0.79, 0.80, 0.82, 0.78, 0.80],\n            [0.86, 0.84, 0.85, 0.83, 0.86, 0.85],\n            [0.35, 0.32, 0.34, 0.31, 0.33, 0.34],\n        ),\n        # Test case 2 (approximately additive, no interaction)\n        (\n            [0.91, 0.90, 0.92, 0.89, 0.91, 0.90],\n            [0.80, 0.81, 0.79, 0.80, 0.82, 0.78],\n            [0.85, 0.84, 0.86, 0.85, 0.83, 0.85],\n            [0.74, 0.75, 0.76, 0.73, 0.75, 0.74],\n        ),\n        # Test case 3 (slight positive interaction with higher variance; borderline significance)\n        (\n            [0.90, 0.85, 0.95, 0.88, 0.92],\n            [0.80, 0.75, 0.85, 0.78, 0.82],\n            [0.86, 0.80, 0.90, 0.83, 0.87],\n            [0.70, 0.76, 0.72, 0.68, 0.79],\n        ),\n        # Test case 4 (antagonistic interaction; less lethal together)\n        (\n            [0.91, 0.90, 0.92, 0.89, 0.91, 0.90],\n            [0.82, 0.81, 0.83, 0.80, 0.82, 0.81],\n            [0.86, 0.85, 0.87, 0.84, 0.86, 0.85],\n            [0.82, 0.81, 0.83, 0.80, 0.82, 0.82],\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        v_00, v_10, v_01, v_11 = case\n        result = is_synthetic_lethal(v_00, v_10, v_01, v_11)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_synthetic_lethal(v_00, v_10, v_01, v_11, alpha=0.05):\n    \"\"\"\n    Tests for synthetic lethality based on viability measurements.\n\n    Args:\n        v_00: Replicate viabilities for wild-type (a=0, b=0).\n        v_10: Replicate viabilities for single mutant A (a=1, b=0).\n        v_01: Replicate viabilities for single mutant B (a=0, b=1).\n        v_11: Replicate viabilities for double mutant AB (a=1, b=1).\n        alpha: Significance level for the hypothesis test.\n\n    Returns:\n        A boolean indicating if synthetic lethality is detected.\n    \"\"\"\n    # Step 1: Compute essentialities E = -log(v)\n    e_00 = -np.log(np.array(v_00))\n    e_10 = -np.log(np.array(v_10))\n    e_01 = -np.log(np.array(v_01))\n    e_11 = -np.log(np.array(v_11))\n\n    # Get group sizes\n    n_00, n_10, n_01, n_11 = len(e_00), len(e_10), len(e_01), len(e_11)\n    n_total = n_00 + n_10 + n_01 + n_11\n\n    # Step 2: Compute mean essentialities\n    mean_e_00 = np.mean(e_00)\n    mean_e_10 = np.mean(e_10)\n    mean_e_01 = np.mean(e_01)\n    mean_e_11 = np.mean(e_11)\n\n    # Step 3: Compute interaction coefficient estimate\n    hat_beta_ab = mean_e_11 - mean_e_10 - mean_e_01 + mean_e_00\n\n    # Step 4: Compute pooled variance (Mean Squared Error)\n    ss_00 = np.sum((e_00 - mean_e_00)**2)\n    ss_10 = np.sum((e_10 - mean_e_10)**2)\n    ss_01 = np.sum((e_01 - mean_e_01)**2)\n    ss_11 = np.sum((e_11 - mean_e_11)**2)\n    \n    ssr = ss_00 + ss_10 + ss_01 + ss_11\n    \n    num_params = 4\n    df = n_total - num_params\n    \n    if df == 0:\n        # Not enough data to estimate variance\n        return False\n        \n    pooled_variance = ssr / df\n\n    # Step 5: Compute standard error of the interaction coefficient\n    var_sum_term = (1/n_00) + (1/n_10) + (1/n_01) + (1/n_11)\n    se_hat_beta_ab = np.sqrt(pooled_variance * var_sum_term)\n\n    # Step 6: Compute t-statistic\n    if se_hat_beta_ab == 0:\n        # If SE is zero, a positive coefficient implies infinite evidence.\n        t_stat = np.inf if hat_beta_ab > 0 else 0\n    else:\n        t_stat = hat_beta_ab / se_hat_beta_ab\n\n    # Step 7  8: Compute one-sided p-value from t-distribution survival function\n    p_value = t.sf(t_stat, df)\n\n    # Step 9: Make decision\n    # Synthetic lethality requires a positive interaction term AND\n    # statistical significance.\n    is_lethal = (hat_beta_ab > 0) and (p_value = alpha)\n    \n    return is_lethal\n\nsolve()\n```"
        },
        {
            "introduction": "除了从实验数据中推断相互作用，我们还可以利用系统层面的计算模型来预测合成致死。通量平衡分析 (FBA) 是一种强大的方法，它通过模拟代谢网络来揭示其结构如何决定功能特性，例如基因的必需性。本练习将让您运用 FBA，通过系统性地模拟单个和双重反应敲除，来识别代谢网络中源于通路冗余的合成致死反应对 。",
            "id": "4354454",
            "problem": "您的任务是使用基于约束的稳态建模方法，在小型代谢网络中识别合成致死反应对。出发点是细胞内代谢物的基本稳态质量平衡，由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和通量向量 $v \\in \\mathbb{R}^{n}$ 表示，并受以下线性系统约束\n$$\nS v = 0,\n$$\n通量边界为\n$$\n\\ell \\le v \\le u,\n$$\n其中 $\\ell, u \\in \\mathbb{R}^{n}$ 分别是下界和上界。生物量生成由线性目标函数 $\\max \\; c^{\\top} v$ 建模，其中 $c \\in \\mathbb{R}^{n}$ 除了生物量排出反应对应的分量外，其余分量均为零。生存能力定义为存在一个可行稳态，其最大目标值严格大于一个阈值 $\\tau$，其中 $\\tau$ 是一个小的正标量。\n\n此处，合成致死反应对定义为满足以下四个条件的、由不同反应组成的无序对 $\\{i,j\\}$：\n1. 野生型（无删除）的最大目标值严格大于 $\\tau$。\n2. 单独删除反应 $i$ 后的最大目标值严格大于 $\\tau$。\n3. 单独删除反应 $j$ 后的最大目标值严格大于 $\\tau$。\n4. 同时删除反应 $i$ 和 $j$ 后的最大目标值小于或等于 $\\tau$（包括不可行的情况）。\n\n删除反应 $k$ 是通过强制 $v_k = 0$ 来实现的。\n\n对于所有计算，使用以下阈值 $\\tau$：$\\tau = 10^{-6}$。所有线性规划问题都应求解为在约束 $S v = 0$ 和 $\\ell \\le v \\le u$ 下对 $c^{\\top} v$ 的精确最大化。如果一个线性规划问题不可行，则将其最大目标值视为 $0$。\n\n您必须实现一个程序，对于下面的每个测试用例，枚举所有满足上述合成致死定义的无序反应索引对 $\\{i,j\\}$（其中 $0 \\le i  j \\le n-1$）。反应使用从零开始的索引。将每对报告为一个双元素列表 $[i,j]$。对于每个测试用例，返回一个按字典序排序的此类对的列表。最终输出必须按顺序聚合所有提供的测试用例的列表，生成一个单行，该行是一个列表，其中每个元素对应一个测试用例。\n\n测试套件：\n每个测试用例都明确提供 $(S, \\ell, u, c)$。\n\n测试用例 1（通往生物量的冗余平行路径）：\n- 代谢物（$S$ 的行）：$[A, B, C, BM]$。\n- 反应（$S$ 的列）：$0:$ 摄取 $\\rightarrow A$，$1:$ $A \\rightarrow B$，$2:$ $A \\rightarrow C$，$3:$ $B \\rightarrow BM$，$4:$ $C \\rightarrow BM$，$5:$ $BM \\rightarrow$ 排出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{4 \\times 6}$：\n$$\nS = \\begin{bmatrix}\n1  -1  -1  0  0  0 \\\\\n0  1  0  -1  0  0 \\\\\n0  0  1  0  -1  0 \\\\\n0  0  0  1  1  -1\n\\end{bmatrix}.\n$$\n- 边界 $\\ell, u \\in \\mathbb{R}^{6}$：\n$$\n\\ell = [0, 0, 0, 0, 0, 0], \\quad u = [10, 1000, 1000, 1000, 1000, 1000].\n$$\n- 目标向量 $c \\in \\mathbb{R}^{6}$：\n$$\nc = [0, 0, 0, 0, 0, 1].\n$$\n\n测试用例 2（单一必需线性通路，预计无合成致死）：\n- 代谢物（$S$ 的行）：$[A, D, BM]$。\n- 反应（$S$ 的列）：$0:$ 摄取 $\\rightarrow A$，$1:$ $A \\rightarrow D$，$2:$ $D \\rightarrow BM$，$3:$ $BM \\rightarrow$ 排出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 4}$：\n$$\nS = \\begin{bmatrix}\n1  -1  0  0 \\\\\n0  1  -1  0 \\\\\n0  0  1  -1\n\\end{bmatrix}.\n$$\n- 边界 $\\ell, u \\in \\mathbb{R}^{4}$：\n$$\n\\ell = [0, 0, 0, 0], \\quad u = [10, 1000, 1000, 1000].\n$$\n- 目标向量 $c \\in \\mathbb{R}^{4}$：\n$$\nc = [0, 0, 0, 1].\n$$\n\n测试用例 3（支持重路由的可逆相互转换）：\n- 代谢物（$S$ 的行）：$[A, B, C, BM]$。\n- 反应（$S$ 的列）：$0:$ 摄取 $\\rightarrow A$，$1:$ $A \\rightarrow B$，$2:$ $B \\leftrightarrow C$ (可逆)，$3:$ $B \\rightarrow BM$，$4:$ $C \\rightarrow BM$，$5:$ $BM \\rightarrow$ 排出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{4 \\times 6}$：\n$$\nS = \\begin{bmatrix}\n1  -1  0  0  0  0 \\\\\n0  1  -1  -1  0  0 \\\\\n0  0  1  0  -1  0 \\\\\n0  0  0  1  1  -1\n\\end{bmatrix}.\n$$\n- 边界 $\\ell, u \\in \\mathbb{R}^{6}$：\n$$\n\\ell = [0, 0, -1000, 0, 0, 0], \\quad u = [10, 1000, 1000, 1000, 1000, 1000].\n$$\n- 目标向量 $c \\in \\mathbb{R}^{6}$：\n$$\nc = [0, 0, 0, 0, 0, 1].\n$$\n\n您的程序必须：\n- 为每个测试用例求解线性规划以计算最大目标值。\n- 根据定义，使用 $\\tau = 10^{-6}$ 确定所有合成致死对。\n- 生成一个单行输出，其中包含所有测试用例的列表，格式为用方括号括起来的逗号分隔列表，不含空格。例如，一个有效的输出格式是 [[[i_1,j_1],[i_2,j_2]],[],[[k_1,\\ell_1]]]。\n\n最终答案必须是按规定可完整运行的程序。此问题不涉及物理单位、角度或百分比。所有数值均已在上面明确给出，不带单位，所有输出均为整数列表。",
            "solution": "该问题被评估为**有效的**。它在代谢网络基于约束的建模这一成熟领域有科学依据，特别是在通量平衡分析（FBA）方面。该问题是适定的，为合成致死提供了清晰、形式化的定义，并提供了求解所需的所有必要参数（$S, \\ell, u, c, \\tau$）。定义在数学上是精确和客观的，没有歧义、矛盾或依赖于非科学的前提。\n\n这个问题的核心是通过系统地模拟单个和两个反应删除对代谢网络生物量生成能力的影响，来识别合成致死反应对。这是通过通量平衡分析（FBA）实现的，这是一种用于分析稳态下代谢通量的数学方法。\n\n代谢网络由稳态质量平衡方程描述：\n$$\nS v = 0\n$$\n其中 $S \\in \\mathbb{R}^{m \\times n}$ 是包含 $m$ 个代谢物和 $n$ 个反应的化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量。通量还受下界和上界约束：\n$$\n\\ell \\le v \\le u\n$$\n细胞目标，通常是生物量生成，被假定为通量的线性组合，我们寻求将其最大化：\n$$\n\\max \\quad c^{\\top} v\n$$\n其中向量 $c \\in \\mathbb{R}^{n}$ 定义了目标函数。这个公式构成了一个线性规划（LP）问题。\n\n一个反应 $k$ 的删除（或“敲除”）是通过将其对应的通量 $v_k$ 设置为零来实现的。这是通过修改其边界使得 $\\ell_k = u_k = 0$ 来实现的。\n\n该问题根据与网络生存能力相关的四个条件定义了合成致死对 $\\{i, j\\}$。生存能力是通过将最大目标值（生物量生成）与一个小的正阈值 $\\tau = 10^{-6}$ 进行比较来确定的。设 $Z(\\mathcal{K})$ 表示在删除了反应集合 $\\mathcal{K}$ 的网络中的最大目标值。\n一对 $\\{i, j\\}$ 成为合成致死的条件是：\n1.  野生型生存能力：$Z(\\emptyset) > \\tau$\n2.  单突变体 $i$ 生存能力：$Z(\\{i\\}) > \\tau$\n3.  单突变体 $j$ 生存能力：$Z(\\{j\\}) > \\tau$\n4.  双突变体致死性：$Z(\\{i, j\\}) \\le \\tau$\n\n为了解决这个问题，对每个测试用例都遵循一个系统化的计算过程：\n\n首先，我们需要一个函数来求解给定参数集的 FBA 问题。标准的线性规划求解器通常设计用于求解形式为 $\\min a^{\\top}x$ 的最小化问题。为了解决我们的最大化问题 $\\max c^{\\top}v$，我们可以等价地求解 $\\min (-c)^{\\top}v$。最大化问题的最优值就是最小化结果的负值。如果线性规划问题不可行，问题规定将最大目标值视为 $0$。\n\n识别合成致死对的算法如下：\n\n1.  **求解野生型（WT）生长**：使用原始未修改的边界 $\\ell$ 和 $u$ 求解一个线性规划问题。设结果为 $Z_{WT} = Z(\\emptyset)$。如果 $Z_{WT} \\le \\tau$，则野生型网络不具生存能力。根据条件1，不可能存在合成致死对，因此该测试用例的处理终止，产生一个空列表。\n\n2.  **评估单反应删除**：对于每个反应 $k \\in \\{0, 1, \\dots, n-1\\}$，求解一个单反应删除的线性规划问题。创建一个临时的边界集 $(\\ell', u')$，其中 $\\ell'_k = u'_k = 0$，并计算最大目标值 $Z_k = Z(\\{k\\})$。\n\n3.  **识别非必需反应**：如果删除一个反应 $k$ 不会使网络不具生存能力，即 $Z_k > \\tau$，则该反应为非必需反应。合成致死定义的条件2和3要求合成致死对中的两个反应都必须是非必需的。因此，我们编制一个所有非必需反应索引的列表。\n\n4.  **评估双反应删除**：我们遍历所有唯一的非必需反应无序对 $\\{i, j\\}$，确保 $i  j$ 以维持字典序并避免冗余计算。对于每一对，通过将反应 $i$ 和 $j$ 的边界都设置为零（$\\ell'_i = u'_i = 0$ 和 $\\ell'_j = u'_j = 0$）来求解一个双反应删除的线性规划问题。\n\n5.  **归类合成致死对**：设对 $\\{i, j\\}$ 的双反应删除线性规划的结果为 $Z_{ij} = Z(\\{i, j\\})$。如果 $Z_{ij} \\le \\tau$，则满足条件4。由于前面的步骤已经满足了条件1、2和3，该对 $\\{i, j\\}$ 被归类为合成致死，并添加到我们的结果列表中。\n\n这个过程详尽地检查了所有有效的候选对是否满足四个标准，确保为每个提供的代谢网络模型正确和完整地枚举合成致死对。最终的实现将利用 `numpy` 进行高效的数组和矩阵运算，并使用 `scipy.optimize.linprog` 来求解所需的线性规划问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    Identifies synthetic lethal reaction pairs in metabolic networks using FBA.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([\n                [1, -1, -1, 0, 0, 0],\n                [0, 1, 0, -1, 0, 0],\n                [0, 0, 1, 0, -1, 0],\n                [0, 0, 0, 1, 1, -1]\n            ]),\n            np.array([0, 0, 0, 0, 0, 0], dtype=float),\n            np.array([10, 1000, 1000, 1000, 1000, 1000], dtype=float),\n            np.array([0, 0, 0, 0, 0, 1], dtype=float)\n        ),\n        # Test case 2\n        (\n            np.array([\n                [1, -1, 0, 0],\n                [0, 1, -1, 0],\n                [0, 0, 1, -1]\n            ]),\n            np.array([0, 0, 0, 0], dtype=float),\n            np.array([10, 1000, 1000, 1000], dtype=float),\n            np.array([0, 0, 0, 1], dtype=float)\n        ),\n        # Test case 3\n        (\n            np.array([\n                [1, -1, 0, 0, 0, 0],\n                [0, 1, -1, -1, 0, 0],\n                [0, 0, 1, 0, -1, 0],\n                [0, 0, 0, 1, 1, -1]\n            ]),\n            np.array([0, 0, -1000, 0, 0, 0], dtype=float),\n            np.array([10, 1000, 1000, 1000, 1000, 1000], dtype=float),\n            np.array([0, 0, 0, 0, 0, 1], dtype=float)\n        )\n    ]\n    \n    tau = 1e-6\n    all_results = []\n\n    for S, l, u, c in test_cases:\n        sl_pairs = find_synthetic_lethal_pairs(S, l, u, c, tau)\n        all_results.append(sl_pairs)\n\n    # Format output to be a single string without spaces.\n    results_as_strings = []\n    for res in all_results:\n        # Convert list to string and remove spaces\n        res_str = str(res).replace(\" \", \"\")\n        results_as_strings.append(res_str)\n\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef solve_fba(c_obj, S, l_bounds, u_bounds):\n    \"\"\"\n    Solves the FBA linear program: max c'v s.t. Sv=0, l = v = u.\n    Returns the maximal objective value. Treats infeasible cases as 0.\n    \"\"\"\n    m, n = S.shape\n    b_eq = np.zeros(m)\n    bounds = list(zip(l_bounds, u_bounds))\n\n    # linprog minimizes, so we minimize -c'v to maximize c'v\n    res = linprog(-c_obj, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if res.success:\n        # Return the maximum value (negate the minimized value)\n        return -res.fun\n    else:\n        # Per problem spec, treat infeasible or failed optimization as 0 growth.\n        return 0.0\n\ndef find_synthetic_lethal_pairs(S, l, u, c, tau):\n    \"\"\"\n    Finds all synthetic lethal reaction pairs for a given metabolic model.\n    \"\"\"\n    n_reactions = S.shape[1]\n\n    # 1. Check wild-type viability\n    wt_growth = solve_fba(c, S, l, u)\n    if wt_growth = tau:\n        return []\n\n    # 2. Evaluate all single knockouts\n    single_ko_growths = []\n    for i in range(n_reactions):\n        l_ko = np.copy(l)\n        u_ko = np.copy(u)\n        l_ko[i], u_ko[i] = 0.0, 0.0\n        growth = solve_fba(c, S, l_ko, u_ko)\n        single_ko_growths.append(growth)\n\n    # 3. Identify non-essential reactions (Conditions 2  3)\n    non_essential_indices = [\n        i for i, g in enumerate(single_ko_growths) if g > tau\n    ]\n\n    # 4. Evaluate double knockouts of non-essential reactions\n    sl_pairs = []\n    for i_idx, i in enumerate(non_essential_indices):\n        for j in non_essential_indices[i_idx + 1:]:\n            # Pair is (i, j) with i  j, ensuring lexicographical order and uniqueness\n            l_dko = np.copy(l)\n            u_dko = np.copy(u)\n            l_dko[i], u_dko[i] = 0.0, 0.0\n            l_dko[j], u_dko[j] = 0.0, 0.0\n            \n            dko_growth = solve_fba(c, S, l_dko, u_dko)\n            \n            # 5. Check for synthetic lethality (Condition 4)\n            if dko_growth = tau:\n                sl_pairs.append([i, j])\n                \n    return sl_pairs\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}