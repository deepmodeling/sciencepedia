{
    "hands_on_practices": [
        {
            "introduction": "要理解信号网络如何随时间演变，我们必须分析其动态特性。本练习将指导您在一个更贴近生物事件时序性的异步更新机制下，描绘出一个简单布尔网络所有可能的状态轨迹。通过构建完整的状态转移图，您将能识别出网络的吸引子 (attractor)，即代表系统长期功能结局的稳定状态或循环 。",
            "id": "4358401",
            "problem": "考虑一个基于逻辑的信号通路模型，该模型表示为一个具有三个节点 $A$、$B$ 和 $C$ 的布尔网络，节点取值于 $\\{0,1\\}$。该网络由更新函数 $f_A(A,B,C) := \\neg B$、$f_B(A,B,C) := C$ 和 $f_C(A,B,C) := A$ 定义，其中 $\\neg$ 表示布尔否定。在异步更新机制下，在每个离散时间步，恰好选择一个其当前值与规定更新值不符的节点，并将其更新为该规定值，而其他节点保持不变。在此设定中，吸引子被定义为异步状态转移图的终端强连通分量 (SCC)，即一个非空的状态集合，它在异步转移下是闭合的，并且从该集合中没有转移指向集合外的状态。\n\n从布尔网络、异步更新以及作为终端 SCC 的吸引子的基本定义出发，执行以下操作：\n\n- 枚举所有状态 $(A,B,C) \\in \\{0,1\\}^3$，并对每个状态，通过识别其当前值与更新值不同的节点并只更新其中一个这样的节点，来确定所有可能的异步后继状态。\n- 构建异步状态转移图并识别所有吸引子。\n- 为符合答案规范，请使用整数 $4A + 2B + C$ 对每个状态 $(A,B,C)$进行编码，并按照从状态 $(0,0,0)$ 开始的循环所引导的顺序，列出与吸引子状态相对应的整数。\n\n使用 $\\mathrm{pmatrix}$ 环境将您的最终答案表示为这些整数的单行矩阵。无需四舍五入。不涉及单位。",
            "solution": "该问题定义明确、科学上合理且内部一致。这是布尔网络分析中的一个标准练习，是系统生物医学中的一个有效课题。所有必要的定义、函数和约束都已提供。因此，该问题被认为是有效的。\n\n该布尔网络由三个节点 $A$、$B$ 和 $C$ 组成，其状态属于集合 $\\{0,1\\}$。系统中的总状态数为 $2^3=8$。网络的状态由向量 $(A,B,C)$ 给出。更新函数为 $f_A(A,B,C) = \\neg B$、$f_B(A,B,C) = C$ 和 $f_C(A,B,C) = A$。我们可以将任何状态 $(A,B,C)$ 的目标更新向量表示为 $F = (f_A, f_B, f_C) = (\\neg B, C, A)$。\n\n在异步更新机制下，如果新状态 $S'$ 是通过更新恰好一个节点 $X \\in \\{A,B,C\\}$ 的值得到的，且该节点的当前值 $X$ 不等于其目标值 $f_X$，则从状态 $S$ 到 $S'$ 的转移是可能的。\n\n我们将系统地枚举所有 $8$ 个状态，计算它们对应的更新向量，并确定所有可能的后继状态。\n\n1.  状态 $S_0 = (0,0,0)$:\n    更新向量为 $F_0 = (\\neg 0, 0, 0) = (1,0,0)$。\n    比较 $S_0$ 和 $F_0$，只有节点 $A$ 是不稳定的（$A=0$，$f_A=1$）。\n    唯一可能的后继状态是通过更新 $A$ 得到：$(1,0,0)$。\n\n2.  状态 $S_1 = (0,0,1)$:\n    更新向量为 $F_1 = (\\neg 0, 1, 0) = (1,1,0)$。\n    所有三个节点都不稳定（$A=0 \\neq f_A=1$，$B=0 \\neq f_B=1$，$C=1 \\neq f_C=0$）。\n    有三个可能的后继状态：\n    - 更新 $A$: $(1,0,1)$\n    - 更新 $B$: $(0,1,1)$\n    - 更新 $C$: $(0,0,0)$\n\n3.  状态 $S_2 = (0,1,0)$:\n    更新向量为 $F_2 = (\\neg 1, 0, 0) = (0,0,0)$。\n    只有节点 $B$ 是不稳定的（$B=1$，$f_B=0$）。\n    唯一可能的后继状态是通过更新 $B$ 得到：$(0,0,0)$。\n\n4.  状态 $S_3 = (0,1,1)$:\n    更新向量为 $F_3 = (\\neg 1, 1, 0) = (0,1,0)$。\n    只有节点 $C$ 是不稳定的（$C=1$，$f_C=0$）。\n    唯一可能的后继状态是通过更新 $C$ 得到：$(0,1,0)$。\n\n5.  状态 $S_4 = (1,0,0)$:\n    更新向量为 $F_4 = (\\neg 0, 0, 1) = (1,0,1)$。\n    只有节点 $C$ 是不稳定的（$C=0$，$f_C=1$）。\n    唯一可能的后继状态是通过更新 $C$ 得到：$(1,0,1)$。\n\n6.  状态 $S_5 = (1,0,1)$:\n    更新向量为 $F_5 = (\\neg 0, 1, 1) = (1,1,1)$。\n    只有节点 $B$ 是不稳定的（$B=0$，$f_B=1$）。\n    唯一可能的后继状态是通过更新 $B$ 得到：$(1,1,1)$。\n\n7.  状态 $S_6 = (1,1,0)$:\n    更新向量为 $F_6 = (\\neg 1, 0, 1) = (0,0,1)$。\n    所有三个节点都不稳定（$A=1 \\neq f_A=0$，$B=1 \\neq f_B=0$，$C=0 \\neq f_C=1$）。\n    有三个可能的后继状态：\n    - 更新 $A$: $(0,1,0)$\n    - 更新 $B$: $(1,0,0)$\n    - 更新 $C$: $(1,1,1)$\n\n8.  状态 $S_7 = (1,1,1)$:\n    更新向量为 $F_7 = (\\neg 1, 1, 1) = (0,1,1)$。\n    只有节点 $A$ 是不稳定的（$A=1$，$f_A=0$）。\n    唯一可能的后继状态是通过更新 $A$ 得到：$(0,1,1)$。\n\n不动点（或稳态）是满足 $S=F$ 的状态 $S$。这需要 $(A,B,C) = (\\neg B, C, A)$，意味着 $A = \\neg B$，$B=C$ 且 $C=A$。由后两个等式可得 $A=B=C$。但 $A=\\neg B$ 意味着 $A \\neq B$。这是一个矛盾，因此不存在不动点。吸引子必定是循环的。\n\n现在我们构建状态转移图。让我们从状态 $(0,0,0)$ 开始追踪一条路径：\n$(0,0,0) \\to (1,0,0) \\to (1,0,1) \\to (1,1,1) \\to (0,1,1) \\to (0,1,0) \\to (0,0,0)$。\n这个序列形成了一个长度为 $6$ 的循环。这个由 $6$ 个状态组成的集合，我们称之为 $\\mathcal{A}$，是强连通的。要成为一个吸引子（终端 SCC），$\\mathcal{A}$ 中的任何状态都不能有指向 $\\mathcal{A}$ 外部状态的转移。我们已经确定了每个状态的所有后继状态。回顾循环中各状态的转移，可以证实这一点：\n- $(0,0,0)$ 转移到 $(1,0,0) \\in \\mathcal{A}$。\n- $(1,0,0)$ 转移到 $(1,0,1) \\in \\mathcal{A}$。\n- $(1,0,1)$ 转移到 $(1,1,1) \\in \\mathcal{A}$。\n- $(1,1,1)$ 转移到 $(0,1,1) \\in \\mathcal{A}$。\n- $(0,1,1)$ 转移到 $(0,1,0) \\in \\mathcal{A}$。\n- $(0,1,0)$ 转移到 $(0,0,0) \\in \\mathcal{A}$。\n因此，集合 $\\mathcal{A} = \\{(0,0,0), (1,0,0), (1,0,1), (1,1,1), (0,1,1), (0,1,0)\\}$ 是一个终端 SCC，故而是一个吸引子。\n\n不在此循环中的两个状态是 $(0,0,1)$ 和 $(1,1,0)$。让我们检查它们的转移：\n- 从 $(0,0,1)$ 出发，转移指向 $(1,0,1)$、$(0,1,1)$ 和 $(0,0,0)$。所有三个后继状态都在 $\\mathcal{A}$ 中。\n- 从 $(1,1,0)$ 出发，转移指向 $(0,1,0)$、$(1,0,0)$ 和 $(1,1,1)$。所有三个后继状态都在 $\\mathcal{A}$ 中。\n所以，任何不在吸引子中的状态最终都会转移到其中。这证实了 $\\mathcal{A}$ 是该网络中唯一的吸引子。\n\n最后一步是将 $\\mathcal{A}$ 中的状态编码为整数，并按照从 $(0,0,0)$ 开始的循环顺序排列它们。编码由整数 $I = 4A + 2B + C$ 给出。\n循环中的有序状态是：\n1.  $(0,0,0) \\implies I = 4(0) + 2(0) + 0 = 0$\n2.  $(1,0,0) \\implies I = 4(1) + 2(0) + 0 = 4$\n3.  $(1,0,1) \\implies I = 4(1) + 2(0) + 1 = 5$\n4.  $(1,1,1) \\implies I = 4(1) + 2(1) + 1 = 7$\n5.  $(0,1,1) \\implies I = 4(0) + 2(1) + 1 = 3$\n6.  $(0,1,0) \\implies I = 4(0) + 2(1) + 0 = 2$\n\n代表吸引子状态的有序整数序列是 $(0, 4, 5, 7, 3, 2)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  4  5  7  3  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "对于大型网络而言，遍历整个状态空间在计算上是不可行的。稳定基序 (stable motif) 分析提供了一种强大的替代方法，它通过识别网络中能够自我维持的最小子网络来决定系统的长期行为。本练习将展示如何运用此方法，直接从网络的反馈回路结构中推导出所有可能的稳态吸引子 (fixed-point attractors)，从而更深刻地理解细胞命运是如何被决定的 。",
            "id": "4358399",
            "problem": "考虑一个信号通路的基于逻辑的模型，该模型表示为一个布尔网络，包含四个内部节点和一个外部输入：转录因子 $T_A$ 和 $T_B$、一个靶基因 $G$ 和一个抑制性调节因子 $I$，以及一个外部信号 $S$。每个内部节点在 $\\{0,1\\}$ 中取值，其中 $1$ 表示激活状态，$0$ 表示非激活状态。系统根据布尔更新规则在通用异步动态下演化，并且外部输入 $S$ 固定为 $0$ (关闭)。更新规则如下：\n$$\nT_A^{t+1} \\;=\\; T_B^{t} \\lor S,\\qquad T_B^{t+1} \\;=\\; T_A^{t},\\qquad G^{t+1} \\;=\\; \\left(T_A^{t} \\land T_B^{t}\\right) \\lor G^{t},\\qquad I^{t+1} \\;=\\; \\neg G^{t} \\lor I^{t},\n$$\n其中 $S^{t} \\equiv 0$ 对所有 $t$ 成立。假设对 $\\lor$、$\\land$ 和 $\\neg$ 采用标准的布尔语义。\n\n从布尔网络、反馈回路和稳定基序的基本定义出发，应用稳定基序分析来推导该网络的允许的长期状态（不动点吸引子）的完整集合。使用稳定基序的概念，即一个最小的自持节点状态分配集合，它与网络的更新逻辑一致，并在异步更新下保持不变。通过证明在给定逻辑下不会出现振荡吸引子来确保科学真实性。\n\n在完成允许的长期状态集合的推导后，将该集合的基数报告为单个整数。将您的最终答案提供为不同不动点吸引子的数量。无需四舍五入，也不需要单位。您的最终答案必须是一个单个实值数。",
            "solution": "我们从适用于信号通路基于逻辑的建模的核心定义开始。布尔网络由具有二元状态的节点和将当前节点状态映射到未来状态的更新函数组成。在异步动态下，每一步都有一部分节点可能根据其函数进行更新，而吸引子包括不动点（在所有可能的异步更新下保持不变的状态）。稳定基序被定义为一个最小的节点状态分配集合，它在更新函数下是自持的：如果基序中的所有节点都设置为其基序分配的值，那么更新逻辑保证这些值会持续存在，而不受基序外节点状态的影响。稳定基序可用于约束和识别网络的长期状态（吸引子）。\n\n该网络的更新规则是：\n$$\n\\begin{aligned}\nT_A^{t+1} = T_B^{t} \\lor S, \\quad S^{t} \\equiv 0 \\implies T_A^{t+1} = T_B^{t} \\\\\nT_B^{t+1} = T_A^{t} \\\\\nG^{t+1} = \\left(T_A^{t} \\land T_B^{t}\\right) \\lor G^{t} \\\\\nI^{t+1} = \\neg G^{t} \\lor I^{t}\n\\end{aligned}\n$$\n因此，实际上，\n$$\n\\begin{aligned}\nT_A^{t+1} = T_B^{t} \\\\\nT_B^{t+1} = T_A^{t} \\\\\nG^{t+1} = \\left(T_A^{t} \\land T_B^{t}\\right) \\lor G^{t} \\\\\nI^{t+1} = \\neg G^{t} \\lor I^{t}\n\\end{aligned}\n$$\n\n我们首先分析 $T_A$ 和 $T_B$ 之间的相互增强作用。这对节点的逻辑是：\n$$\nT_A^{t+1} \\;=\\; T_B^{t},\\qquad T_B^{t+1} \\;=\\; T_A^{t}.\n$$\n这是一个正反馈回路。对于这样的回路，稳定基序是任何在更新逻辑下能够自我复制的一致分配。分配 $T_A=1, T_B=1$ 和 $T_A=0, T_B=0$ 是自洽的：\n- 如果 $T_A=1$ 且 $T_B=1$，则 $T_A^{t+1}=T_B^{t}=1$ 且 $T_B^{t+1}=T_A^{t}=1$，所以两者都保持为 $1$。\n- 如果 $T_A=0$ 且 $T_B=0$，则 $T_A^{t+1}=T_B^{t}=0$ 且 $T_B^{t+1}=T_A^{t}=0$，所以两者都保持为 $0$。\n当 $T_A \\neq T_B$ 时的分配不是自持的，因为它们在更新下会交换值，并且不形成不变的不动点（在异步动态下，它们会向一致的状态演化，而不会定义一个稳定基序）。因此，该转录因子对的两个最小稳定基序是：\n$$\n\\{T_A=1,\\,T_B=1\\}\\quad\\text{和}\\quad \\{T_A=0,\\,T_B=0\\}.\n$$\n\n接下来，考虑 $G$：\n$$\nG^{t+1} \\;=\\; \\left(T_A^{t} \\land T_B^{t}\\right) \\lor G^{t}.\n$$\n该规则有一个正自反馈项 $G^{t}$，表明一旦 $G$ 为 $1$，它就是自持的，而不受其他节点的影响：\n- 如果 $G=1$，那么 $G^{t+1} = (T_A^{t} \\land T_B^{t}) \\lor 1 = 1$，所以 $G=1$ 本身就是一个稳定基序：\n$$\n\\{G=1\\}.\n$$\n对于 $G=0$，我们有 $G^{t+1} = T_A^{t} \\land T_B^{t}$。因此 $G=0$ 通常不是自持的；它需要 $T_A=0$ 和 $T_B=0$ 来保证 $G^{t+1}=0$。因此，唯一涉及 $G=0$ 的最小稳定基序是与转录因子复合的：\n$$\n\\{T_A=0,\\,T_B=0,\\,G=0\\},\n$$\n但请注意，$\\{T_A=0,\\,T_B=0\\}$ 本身已经是一个稳定基序，并且除非 $G$ 之前被设为 $1$（这是自持的），否则 $G=0$ 是由它决定的。对于稳定基序的枚举，$\\{G=1\\}$ 是最小的，而 $G=0$ 则依赖于 $\\{T_A=0, T_B=0\\}$ 基序。\n\n现在考虑 $I$：\n$$\nI^{t+1} \\;=\\; \\neg G^{t} \\lor I^{t}.\n$$\n该规则也包含一个正自反馈项 $I^{t}$。因此，无论 $G$ 的状态如何，$I=1$ 都是自持的：\n- 如果 $I=1$，那么 $I^{t+1} = \\neg G^{t} \\lor 1 = 1$，所以\n$$\n\\{I=1\\}\n$$\n是一个稳定基序。相反，$I=0$ 将一直需要 $\\neg G^{t}=0$（即 $G=1$），以避免 $I$ 被迫变为 $1$。如果 $G=1$，那么 $I^{t+1} = 0 \\lor I^{t} = I^{t}$，并且 $I=0$ 变得一致。然而，$I=0$ 本身并不是一个最小稳定基序，因为它的自反馈回路不支持 $0$；它只有在 $G=1$ 的情况下才是自持的。因此，捕获 $I=0$ 的最小基序是复合的：\n$$\n\\{G=1,\\,I=0\\}.\n$$\n\n我们现在根据这些基序组合出允许的长期状态（不动点吸引子），并检查所有节点的一致性。\n\n情况 1：转录因子基序 $\\{T_A=1,\\,T_B=1\\}$。\n- 对于 $G$：当 $T_A=1$ 和 $T_B=1$ 时，$G^{t+1} = 1 \\lor G^{t} = 1$，所以在任何不动点中 $G=1$ 都是被强制的。\n- 对于 $I$：当 $G=1$ 时，$I^{t+1} = 0 \\lor I^{t} = I^{t}$。因此，$I=0$ 和 $I=1$ 都是一致的不动点分配。\n因此，在这种情况下有两个不动点：\n$$\n(T_A,T_B,G,I) = (1,1,1,0)\\quad\\text{和}\\quad(1,1,1,1).\n$$\n\n情况 2：转录因子基序 $\\{T_A=0,\\,T_B=0\\}$。\n- 对于 $G$：当 $T_A=0$ 和 $T_B=0$ 时，$G^{t+1} = 0 \\lor G^{t} = G^{t}$。因此，$G=0$ 和 $G=1$ 都是一致的不动点分配。\n- 对于 $I$：考虑子情况。\n  - 子情况 2a: $G=0$。此时 $I^{t+1} = 1 \\lor I^{t} = 1$，在任何不动点中强制 $I=1$。这产生一个不动点：\n  $$\n  (T_A,T_B,G,I) = (0,0,0,1).\n  $$\n  - 子情况 2b: $G=1$。此时 $I^{t+1} = 0 \\lor I^{t} = I^{t}$，所以 $I=0$ 和 $I=1$ 都是一致的不动点分配。这产生两个不动点：\n  $$\n  (T_A,T_B,G,I) = (0,0,1,0)\\quad\\text{和}\\quad(0,0,1,1).\n  $$\n\n收集所有不动点吸引子，我们得到以下不同的长期状态：\n$$\n(1,1,1,0),\\quad(1,1,1,1),\\quad(0,0,0,1),\\quad(0,0,1,0),\\quad(0,0,1,1).\n$$\n在这些规则下没有振荡吸引子，因为所有的反馈循环要么是正反馈并允许固定分配（$T_A$–$T_B$ 回路），要么包含稳定特定值（$G$ 和 $I$）的正自反馈回路，并且没有会强制交替的负反馈回路。在具有这种结构的异步布尔网络中，已识别的不动点穷尽了所有允许的长期状态。\n\n因此，允许的长期状态（不动点吸引子）集合的基数为 $5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "逻辑模型是强大的工具，但它们是对复杂现实的简化，并且建立在不完整的知识之上。因此，评估其预测在面对模型结构和初始状态不确定性时的鲁棒性至关重要。这个计算练习要求您通过模拟一个包含多种规则变体和初始条件扰动的模型集成，来量化模型表型预测的可靠性，从而直接衡量模型的鲁棒性 。",
            "id": "4358406",
            "problem": "考虑一个被抽象为布尔网络 (BN) 的信号通路，其中每个组件是一个取值为 $\\{0,1\\}$ 的节点，并在同步更新的离散时间步中演化。设节点集为 $\\{S,R,P,A,M,T,X\\}$，纯粹解释为数学变量。外部刺激 $S$ 是一个固定输入，其值在所有时间内为 $0$ 或 $1$。其规范更新规则是一组将前一个状态映射到下一个状态的布尔函数，定义如下：\n- $R(t+1) = S$，\n- $P(t+1) = R(t)$，\n- $A(t+1) = P(t)$，\n- $M(t+1) = R(t)$，\n- $T(t+1) = A(t) \\lor M(t)$，\n- $X(t+1) = \\neg(A(t) \\lor M(t))$，\n对于所有 $t$，$S(t+1) = S$。其中 $\\lor$、$\\land$ 和 $\\neg$ 分别表示逻辑或、逻辑与和逻辑非。\n\n我们将给定时间步的表型定义为一个“类生存”结果的布尔指标。具体来说，从给定的初始条件开始，经过 $t_{\\max}$ 次同步更新后，如果 $T(t_{\\max}) = 1$ 且 $X(t_{\\max}) = 0$，则表型被分类为“类生存”，否则分类为“非类生存”。\n\n为了测试对规则形式不确定性的鲁棒性，我们考虑一个由以下三个二元结构选择得到的规则变体系综：\n- $b_M \\in \\{0,1\\}$：如果 $b_M = 0$，则 $M(t+1) = R(t)$；如果 $b_M = 1$，则 $M(t+1) = R(t) \\land \\neg A(t)$；\n- $b_T \\in \\{0,1\\}$：如果 $b_T = 0$，则 $T(t+1) = A(t) \\lor M(t)$；如果 $b_T = 1$，则 $T(t+1) = A(t) \\land M(t)$；\n- $b_X \\in \\{0,1\\}$：如果 $b_X = 0$，则 $X(t+1) = \\neg(A(t) \\lor M(t))$；如果 $b_X = 1$，则 $X(t+1) = \\neg(A(t) \\land M(t))$。\n\n完整的系综包含 $(b_M,b_T,b_X)$ 的所有 $2^3 = 8$ 种组合。对于给定的系综大小 $n_{\\mathrm{ens}}$，该系综是 $(b_M,b_T,b_X)$ 按字典序排列的前 $n_{\\mathrm{ens}}$ 个组合，其中 $(b_M,b_T,b_X)$ 的排序以 $b_M$ 为最高有效位。\n\n为了测试对初始条件不确定性的鲁棒性，设时间 $t=0$ 时的基线初始状态为 $S(0) = S$ 且 $R(0) = P(0) = A(0) = M(0) = T(0) = X(0) = 0$。通过翻转可扰动内部节点 $\\{R,P,A,M,T,X\\}$ 中初始值的子集（从 $0$ 到 $1$）来构造扰动。给定最大翻转预算 $p_{\\max}$，考虑这 $6$ 个节点的大小介于 $0$ 和 $p_{\\max}$ 之间的所有子集，这些子集按节点索引的字典序列出，其中 $\\{R,P,A,M,T,X\\}$ 映射到索引 $\\{1,2,3,4,5,6\\}$。对于指定的 $n_{\\mathrm{pert}}$，按此顺序选择前 $n_{\\mathrm{pert}}$ 个子集。对于每个选定的子集，在 $t=0$ 时将相应节点的初始值设为 $1$，所有其他内部节点的初始值保持为 $0$，并保持 $S(0) = S$ 固定不变。\n\n定义基线表型 $\\phi_{\\mathrm{base}}$，方法是在指定的刺激 $S$ 下，从基线初始状态（无翻转）开始，使用规范规则集（$b_M = 0$，$b_T = 0$，$b_X = 0$）模拟 $t_{\\max}$ 步，并在 $t_{\\max}$ 时评估类生存分类。对于系综中的每个规则变体和每个初始条件扰动，模拟 $t_{\\max}$ 步，并如上所述对表型进行分类。设鲁棒性分数为总共 $(n_{\\mathrm{ens}} \\times n_{\\mathrm{pert}})$ 次模拟中，其表型与 $\\phi_{\\mathrm{base}}$ 相匹配的模拟所占的比例。\n\n您的任务是编写一个程序，为每个指定的测试用例计算此鲁棒性分数，结果为一个在 $[0,1]$ 区间内的浮点数。\n\n使用同步更新。所有计算都纯粹是组合和逻辑的。不涉及物理单位。不涉及角度。所有答案都以实数表示。\n\n测试套件：\n- 情况 1：$(n_{\\mathrm{ens}}, n_{\\mathrm{pert}}, p_{\\max}, t_{\\max}, S) = (8, 7, 1, 5, 1)$。\n- 情况 2：$(n_{\\mathrm{ens}}, n_{\\mathrm{pert}}, p_{\\max}, t_{\\max}, S) = (8, 1, 0, 5, 1)$。\n- 情况 3：$(n_{\\mathrm{ens}}, n_{\\mathrm{pert}}, p_{\\max}, t_{\\max}, S) = (8, 7, 1, 5, 0)$。\n- 情况 4：$(n_{\\mathrm{ens}}, n_{\\mathrm{pert}}, p_{\\max}, t_{\\max}, S) = (1, 10, 2, 5, 1)$。\n- 情况 5：$(n_{\\mathrm{ens}}, n_{\\mathrm{pert}}, p_{\\max}, t_{\\max}, S) = (8, 5, 1, 1, 1)$。\n\n您的程序应生成单行输出，其中包含这五个测试用例的结果，格式为逗号分隔的列表，并用方括号括起来，顺序如下：例如，$[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是为情况 $i$ 计算出的鲁棒性分数。",
            "solution": "该问题要求计算给定布尔网络模型在指定的更新规则和初始条件不确定性下的鲁棒性分数。解决方案的构建首先通过精确定义模型的各个组件，然后实现其动力学的确定性模拟。整个过程分为四个主要阶段：生成规则系综、生成初始条件扰动集、确定基线表型，最后通过对所有指定情景的穷举模拟来计算鲁棒性分数。\n\n系统在任何时间 $t$ 的状态是一个向量 $\\mathbf{v}(t) \\in \\{0,1\\}^7$，对应于节点 $\\{S,R,P,A,M,T,X\\}$ 的值。系统的演化由函数 $\\mathbf{F}_{\\mathbf{b}}: \\{0,1\\}^7 \\to \\{0,1\\}^7$ 控制，使得 $\\mathbf{v}(t+1) = \\mathbf{F}_{\\mathbf{b}}(\\mathbf{v}(t))$，其中 $\\mathbf{b}=(b_M,b_T,b_X)$ 是二元结构选择的向量。模拟实现了这种同步更新，指定的步数为 $t_{\\max}$。\n\n1.  **规则系综生成**：问题定义了一个由二元向量 $\\mathbf{b} = (b_M, b_T, b_X) \\in \\{0,1\\}^3$ 参数化的更新规则族。这产生了 $2^3 = 8$ 个不同的规则集。对于给定的测试用例，大小为 $n_{\\mathrm{ens}}$ 的系综由根据 $\\mathbf{b}$ 的字典序排列的前 $n_{\\mathrm{ens}}$ 个规则集组成。例如，向量 $(0,0,0)$ 对应于规范规则，$(0,0,1)$ 是下一个变体，依此类推，直到 $(1,1,1)$。\n\n2.  **初始条件扰动集生成**：通过系统地扰动一个基线初始条件来测试对初始状态不确定性的鲁棒性。时间 $t=0$ 时的基线状态为 $S(0) = S$（固定刺激），所有其他节点均设为 $0$。扰动包括将内部节点 $\\{R,P,A,M,T,X\\}$ 的一个子集从 $0$ 翻转到 $1$。扰动集由一个预算 $p_{\\max}$ 定义，这是可以翻转的最大节点数。我们生成大小为 $k \\in \\{0, 1, \\dots, p_{\\max}\\}$ 的 $6$ 个内部节点的所有子集。这些子集首先按大小 $k$ 排序，然后按节点索引的字典序排序（其中 $R \\to 1, \\dots, X \\to 6$）。对于给定的 $n_{\\mathrm{pert}}$，从此有序列表中选择前 $n_{\\mathrm{pert}}$ 个初始条件进行模拟。\n\n3.  **基线表型确定**：必须建立一个参考表型，记为 $\\phi_{\\mathrm{base}}$。这是系统在规范条件下的结果。具体来说，我们使用规范规则集（$\\mathbf{b} = (0,0,0)$）和基线初始条件（无扰动，即大小为 $k=0$ 的子集）模拟网络 $t_{\\max}$ 步。在最后的时间步 $t_{\\max}$，评估表型。如果 $T(t_{\\max}) = 1$ 且 $X(t_{\\max}) = 0$，则定义为“类生存”。我们将此结果赋为 $\\phi_{\\mathrm{base}} = 1$，否则为 $\\phi_{\\mathrm{base}} = 0$。\n\n4.  **鲁棒性分数计算**：任务的核心是计算产生基线表型的模拟所占的比例。这涉及一个对 $n_{\\mathrm{ens}}$ 个规则变体和 $n_{\\mathrm{pert}}$ 个初始条件的嵌套循环。对于 $n_{\\mathrm{ens}} \\times n_{\\mathrm{pert}}$ 个组合中的每一个：\n    a. 将网络初始化到 $t=0$ 时的相应状态。\n    b. 使用相应的规则变体，对系统进行 $t_{\\max}$ 次同步时间步的演化。更新规则为：\n    *   $S(t+1) = S$\n    *   $R(t+1) = S$\n    *   $P(t+1) = R(t)$\n    *   $A(t+1) = P(t)$\n    *   如果 $b_M=0$，则 $M(t+1) = R(t)$；如果 $b_M=1$，则 $M(t+1) = R(t) \\land \\neg A(t)$。\n    *   如果 $b_T=0$，则 $T(t+1) = A(t) \\lor M(t)$；如果 $b_T=1$，则 $T(t+1) = A(t) \\land M(t)$。\n    *   如果 $b_X=0$，则 $X(t+1) = \\neg(A(t) \\lor M(t))$；如果 $b_X=1$，则 $X(t+1) = \\neg(A(t) \\land M(t))$。\n    c. 使用相同的“类生存”准则确定最终状态 $\\mathbf{v}(t_{\\max})$ 的表型 $\\phi$。\n    d. 如果 $\\phi = \\phi_{\\mathrm{base}}$，则计数器加一。\n    \n    最终的鲁棒性分数是匹配总数除以模拟总数 $n_{\\mathrm{ens}} \\times n_{\\mathrm{pert}}$。这为系统表型相对于定义的结构和初始状态不确定性的稳定性提供了一个定量度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy, version: 1.23.5\n\n# Define node mappings for clarity and consistency.\nNODE_MAP = {'S': 0, 'R': 1, 'P': 2, 'A': 3, 'M': 4, 'T': 5, 'X': 6}\nNODE_INDICES = {v: k for k, v in NODE_MAP.items()}\nPERTURBABLE_NODES = ['R', 'P', 'A', 'M', 'T', 'X']\n\ndef get_phenotype(state_vec):\n    \"\"\"\n    Classifies the phenotype based on the final state vector.\n    Phenotype is \"survival-like\" (1) if T=1 and X=0, otherwise \"non-survival-like\" (0).\n    \"\"\"\n    t_val = state_vec[NODE_MAP['T']]\n    x_val = state_vec[NODE_MAP['X']]\n    if t_val == 1 and x_val == 0:\n        return 1\n    else:\n        return 0\n\ndef run_simulation(initial_state, b_vec, t_max, S_val):\n    \"\"\"\n    Simulates the Boolean network for t_max steps with synchronous updates.\n    \"\"\"\n    b_M, b_T, b_X = b_vec\n    current_state = np.array(initial_state, dtype=int)\n    \n    s_idx, r_idx, p_idx, a_idx, m_idx, t_idx, x_idx = (\n        NODE_MAP['S'], NODE_MAP['R'], NODE_MAP['P'], NODE_MAP['A'],\n        NODE_MAP['M'], NODE_MAP['T'], NODE_MAP['X']\n    )\n\n    for _ in range(t_max):\n        # Store state values from time t, used to calculate state at t+1.\n        r_prev, p_prev, a_prev, m_prev = (\n            current_state[r_idx], current_state[p_idx], \n            current_state[a_idx], current_state[m_idx]\n        )\n\n        next_state = np.zeros_like(current_state)\n        \n        # S is a constant input for all time.\n        next_state[s_idx] = S_val\n        \n        # R(t+1) = S\n        next_state[r_idx] = S_val\n        \n        # P(t+1) = R(t)\n        next_state[p_idx] = r_prev\n        \n        # A(t+1) = P(t)\n        next_state[a_idx] = p_prev\n        \n        # M(t+1) rule variant is controlled by b_M.\n        if b_M == 0:\n            next_state[m_idx] = r_prev\n        else:\n            next_state[m_idx] = r_prev  (1 - a_prev)\n            \n        # T(t+1) rule variant is controlled by b_T.\n        if b_T == 0:\n            next_state[t_idx] = a_prev | m_prev\n        else:\n            next_state[t_idx] = a_prev  m_prev\n            \n        # X(t+1) rule variant is controlled by b_X.\n        if b_X == 0:\n            next_state[x_idx] = 1 - (a_prev | m_prev)\n        else:\n            next_state[x_idx] = 1 - (a_prev  m_prev)\n\n        current_state = next_state\n        \n    return current_state\n\ndef compute_robustness_score(n_ens, n_pert, p_max, t_max, S_val):\n    \"\"\"\n    Computes the robustness score for a given test case configuration.\n    \"\"\"\n    \n    # 1. Generate rule ensemble based on n_ens.\n    # The order is lexicographic on (b_M, b_T, b_X).\n    all_b_vecs = [(i  2, (i  1)  1, i  1) for i in range(8)]\n    rule_ensemble = all_b_vecs[:n_ens]\n    \n    # 2. Generate initial condition perturbation set.\n    all_pert_subsets = []\n    for k in range(p_max + 1):\n        all_pert_subsets.extend(combinations(PERTURBABLE_NODES, k))\n    perturbation_sets = all_pert_subsets[:n_pert]\n    \n    # 3. Calculate the baseline phenotype.\n    # Baseline IC: internal nodes are 0, S is S_val.\n    baseline_ic = np.zeros(7, dtype=int)\n    baseline_ic[NODE_MAP['S']] = S_val\n    \n    # Canonical rules: b_M=0, b_T=0, b_X=0.\n    canonical_b_vec = (0, 0, 0)\n    \n    final_state_base = run_simulation(baseline_ic, canonical_b_vec, t_max, S_val)\n    phi_base = get_phenotype(final_state_base)\n    \n    # 4. Run all simulations and compute robustness.\n    match_count = 0\n    total_sims = len(rule_ensemble) * len(perturbation_sets)\n    if total_sims == 0:\n        return 1.0 # By convention, a score of 1.0 for no tests.\n\n    for b_vec in rule_ensemble:\n        for pert_set in perturbation_sets:\n            # Construct IC for the current perturbation.\n            ic = baseline_ic.copy()\n            for node_name in pert_set:\n                ic[NODE_MAP[node_name]] = 1\n                \n            final_state = run_simulation(ic, b_vec, t_max, S_val)\n            current_phi = get_phenotype(final_state)\n            \n            if current_phi == phi_base:\n                match_count += 1\n                \n    robustness_score = match_count / total_sims\n    return robustness_score\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n_ens, n_pert, p_max, t_max, S)\n        (8, 7, 1, 5, 1),\n        (8, 1, 0, 5, 1),\n        (8, 7, 1, 5, 0),\n        (1, 10, 2, 5, 1),\n        (8, 5, 1, 1, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_ens, n_pert, p_max, t_max, S_val = case\n        score = compute_robustness_score(n_ens, n_pert, p_max, t_max, S_val)\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}