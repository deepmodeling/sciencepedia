{
    "hands_on_practices": [
        {
            "introduction": "网络传播是基因优先级排序的有力工具，但其性能严重依赖于“扩散时间” $t$ 等超参数。本练习将指导您从头开始实现基于图拉普拉斯算子 $L$ 的热扩散模型，并通过系统的参数扫描和精确率-召回率评估，找到在区分致病基因方面的最佳扩散时间范围。这项实践对于掌握网络扩散算法的完整工作流程——从模型构建到性能验证——至关重要，是连接理论与应用的关键一步。",
            "id": "4366551",
            "problem": "给定无向的蛋白质-蛋白质相互作用网络（由对称邻接矩阵表示）和基准疾病基因集（已划分为训练子集和测试子集）。您的任务是在图上实现热核传播，对扩散时间参数进行网格搜索，并使用精确率-召回率评估性能，以确定一个鲁棒的扩散时间范围。该问题必须通过编写一个如下文所述的完整、可运行的程序来解决。\n\n基本原理。请使用以下基本定义和经过充分验证的事实。\n\n1. 图与拉普拉斯算子：对于一个有 $n$ 个节点的无向简单图，设其邻接矩阵为 $A \\in \\mathbb{R}^{n \\times n}$，其中元素 $A_{ij} \\in \\{0,1\\}$ 表示边的存在。设度矩阵为 $D = \\mathrm{diag}(d_1, \\dots, d_n)$，其中 $d_i = \\sum_{j=1}^n A_{ij}$。组合图拉普拉斯算子为 $L = D - A$。拉普拉斯算子是半正定对称矩阵。\n\n2. 图上的热扩散：在图上，信号 $f(t) \\in \\mathbb{R}^n$ 随时间 $t \\ge 0$ 的扩散遵循热方程，由常微分方程 $\\frac{d}{dt} f(t) = - L f(t)$ 描述，初始条件为 $f(0) = f_0$。其解使用矩阵指数，形式为 $f(t) = \\exp(-t L) f_0$（对所有 $t \\ge 0$）。\n\n3. 用于基因优先级排序的热核传播：给定一组种子节点（训练集中的疾病基因），构建一个初始种子向量 $y \\in \\mathbb{R}^n$，如果节点 $i$ 是训练集正样本，则 $y_i = 1$，否则 $y_i = 0$。将 $y$ 归一化使其元素之和为 1（即 $\\sum_i y_i = 1$），以避免随 $t$ 产生无关紧要的缩放。对于指定网格上的每个 $t$，计算扩散得分 $s(t) = \\exp(-t L) y$。\n\n4. 精确率-召回率评估：为评估 $s(t)$ 在一个具有训练/测试划分的疾病基因集上的表现，需将训练集正样本从排名中排除。在剩余节点中，为测试集正样本定义二进制标签为 $1$，所有其他节点为 $0$。按 $s_i(t)$ 的值对节点进行降序排名，并计算平均精确率，其值为在发现正样本的各个排名位置上的“前k项精确率”(precision-at-k)之和，再除以正样本的总数。正式地，如果排序后的标签列表为 $\\ell_1, \\dots, \\ell_m \\in \\{0,1\\}$，且有 $P = \\sum_{i=1}^m \\ell_i$ 个正样本，设 $\\mathrm{Prec}(k) = \\frac{\\sum_{i=1}^k \\ell_i}{k}$，则平均精确率为 $\\mathrm{AP} = \\frac{1}{P} \\sum_{k:\\,\\ell_k = 1} \\mathrm{Prec}(k)$。如果某个疾病没有测试集正样本，则跳过它；否则将其纳入计算。对于一组疾病，计算平均精确率均值 $\\mathrm{mAP}(t)$，即所有被纳入计算的疾病的 $\\mathrm{AP}(t)$ 的算术平均值。\n\n5. 鲁棒范围：给定一个时间网格 $\\{t_j\\}_{j=0}^{T-1}$ 和一个容差 $\\epsilon > 0$，定义鲁棒索引集 $\\mathcal{R} = \\{ j \\in \\{0, \\dots, T-1\\} : \\mathrm{mAP}(t_j) \\ge \\max_{k} \\mathrm{mAP}(t_k) - \\epsilon \\}$。将 $\\mathcal{R}$ 压缩为使用零基索引的最大连续索引区间 $[a,b]$（其中 $a \\le b$）。\n\n网络和疾病基因集。\n\n- 网络 $\\mathcal{G}_1$ 有 $n = 12$ 个节点，标记为 $0$到$11$。其无向边集合为：\n  - 模块A的边: $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$, $(4,0)$, $(1,3)$。\n  - 模块B的边: $(5,6)$, $(6,7)$, $(7,8)$, $(8,5)$, $(6,8)$。\n  - 模块C的边: $(9,10)$, $(10,11)$, $(11,9)$。\n  - 模块间的边: $(2,5)$, $(3,6)$, $(4,7)$, $(8,9)$, $(1,10)$。\n  对于每个列出的边 $(i,j)$，设置 $A_{ij} = 1$ 并通过对称性设置 $A_{ji} = 1$ 来构建 $A$，并对所有 $i$ 设置 $A_{ii} = 0$。\n\n- 网络 $\\mathcal{G}_2$ 有 $n = 12$ 个节点，标记为 $0$到$11$。它与 $\\mathcal{G}_1$ 相同，但移除了所有模块间的边。也就是说，只保留上面列出的模块内部的边；该图有三个不相连的组件。\n\n- 疾病基因集（两个网络通用）：\n  - 疾病 $\\mathcal{D}_1$：正样本 $\\{0,1,2,3,4\\}$，其中训练集正样本为 $\\{0,2,4\\}$，测试集正样本为 $\\{1,3\\}$。\n  - 疾病 $\\mathcal{D}_2$：正样本 $\\{5,6,7,8\\}$，其中训练集正样本为 $\\{5,7\\}$，测试集正样本为 $\\{6,8\\}$。\n  - 疾病 $\\mathcal{D}_3$：正样本 $\\{9,10,11\\}$，其中训练集正样本为 $\\{9\\}$，测试集正样本为 $\\{10,11\\}$。\n\n指令。为每个指定的测试用例实现以下步骤：\n\n1. 构建邻接矩阵 $A$、度矩阵 $D$ 和拉普拉斯算子 $L = D - A$。\n2. 对每种疾病 $\\mathcal{D}_k$，使用该疾病的训练集正样本构建初始种子向量 $y^{(k)}$，并将其归一化至元素和为 1。对于测试用例网格中的每个 $t$，计算得分 $s^{(k)}(t) = \\exp(-t L) y^{(k)}$。\n3. 对每种疾病，通过从评估中排除训练集正样本，将测试集正样本标记为1、所有其他被考虑的节点标记为0，来评估 $s^{(k)}(t)$，并计算如上定义的平均精确率 $\\mathrm{AP}^{(k)}(t)$。计算 $\\mathrm{mAP}(t)$ 作为所有具有非空测试集的疾病 $k$ 的 $\\mathrm{AP}^{(k)}(t)$ 的平均值。\n4. 在整个网格上，计算 $\\mathcal{R}$ 并将其压缩为使用零基索引的最大连续索引区间 $[a,b]$。\n5. 对每个测试用例，报告区间列表 $[a,b]$，其中每个区间表示为一个包含两个整数的列表。\n\n测试套件。在以下三个测试用例上运行您的程序：\n\n- 用例 1：网络 $\\mathcal{G}_1$，时间网格 $t \\in \\{0.1, 0.2, 0.3, \\dots, 2.0\\}$，步长为 $0.1$（即 $20$ 个值），容差 $\\epsilon = 0.01$。\n\n- 用例 2：网络 $\\mathcal{G}_1$，时间网格 $t \\in \\{0.0, 0.05, 0.1, 0.2, 0.5\\}$，容差 $\\epsilon = 0.005$。\n\n- 用例 3：网络 $\\mathcal{G}_2$，时间网格 $t \\in \\{0.05, 0.1, 0.2, 0.5, 1.0, 2.0\\}$，容差 $\\epsilon = 0.01$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素对应一个测试用例，其本身是一个区间列表，每个区间 $[a,b]$ 表示为一个包含两个整数的列表。例如，如果用例1有两个鲁棒区间，用例2有一个，用例3有一个，一个有效的输出可能看起来像 \"[[[0,3],[5,7]],[[2,2]],[[0,5]]]\"。不应打印任何额外文本。",
            "solution": "所提供的问题陈述是自包含的，其科学基础植根于图论和网络科学的既定原则，并且在计算上是适定的。所有定义、数据和约束都以足够的精度进行了规定，从而能够得出一个唯一且可验证的解。其核心概念——如图拉普拉斯算子、通过矩阵指数求解的图上热方程，以及使用平均精确率均值进行性能评估——都是标准且被正确阐述的。因此，该问题被认为是有效的。\n\n解决方案是通过系统地遵循概述的原则和指令来实现的。\n\n**1. 图表示与拉普拉斯算子**\n\n网络扩散的基础是图的结构，它在数学上由邻接矩阵 $A$ 和图拉普拉斯算子 $L$ 表示。对于一个有 $n$ 个节点的无向图，邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的元素 $A_{ij} = 1$ 表示节点 $i$ 和 $j$ 之间存在边，否则 $A_{ij} = 0$。节点 $i$ 的度 $d_i$ 是连接到它的边的数量，计算公式为 $d_i = \\sum_{j=1}^n A_{ij}$。度矩阵 $D$ 是一个对角矩阵，对角线上的元素是各个节点的度，即 $D = \\mathrm{diag}(d_1, \\dots, d_n)$。\n\n组合图拉普拉斯算子定义为 $L = D - A$。该算子在图上的扩散过程中起核心作用，因为它是连续拉普拉斯-贝尔特拉米算子的离散模拟。对于本问题，我们分别构建对应于网络 $\\mathcal{G}_1$ 和 $\\mathcal{G}_2$ 的拉普拉斯矩阵 $L_1$ 和 $L_2$。$\\mathcal{G}_1$ 是一个单一的连通分量，而 $\\mathcal{G}_2$ 由三个不连通的分量组成，这导致其拉普拉斯矩阵 $L_2$ 是一个块对角矩阵。\n\n**2. 用于基因优先级排序的热核传播**\n\n信息（在此上下文中，“热量”代表与疾病的关联）从一组种子节点的扩散由图热方程建模：\n$$\n\\frac{d}{dt} f(t) = - L f(t)\n$$\n其中 $f(t) \\in \\mathbb{R}^n$ 是在时间 $t$ 时节点上的得分向量。给定初始热量分布 $f(0) = f_0$，在时间 $t$ 的解由以下公式给出：\n$$\nf(t) = \\exp(-t L) f_0\n$$\n矩阵 $K(t) = \\exp(-t L)$ 被称为热核。\n\n在我们的情境中，对于每种疾病 $\\mathcal{D}_k$，我们定义一个初始种子向量 $y^{(k)}$。该向量仅在对应于 $\\mathcal{D}_k$ 的训练集疾病基因的索引处为非零，其值设为 $1$。为确保总“热量”守恒且在不同疾病间具有可比性，该向量被归一化至元素和为1。然后，通过计算得分向量 $s^{(k)}(t)$，对指定网格中的每个时间 $t$ 执行传播：\n$$\ns^{(k)}(t) = \\exp(-t L) y^{(k)}\n$$\n该计算使用科学计算库中提供的数值稳定的矩阵指数算法来执行。\n\n**3. 通过平均精确率均值 (mAP) 进行性能评估**\n\n为量化扩散过程在基因优先级排序中的有效性，我们使用平均精确率 (AP) 指标。对于每种疾病 $\\mathcal{D}_k$ 和时间点 $t$，我们评估得分向量 $s^{(k)}(t)$ 产生的排名。$\\mathcal{D}_k$ 的训练集正样本被排除在排名之外，因为它们作为扩散源，其得分必然很高。剩余节点根据其得分降序排列。\n\n$\\mathcal{D}_k$ 的测试集正样本作为基准真相 (ground truth)。平均精确率 $\\mathrm{AP}^{(k)}(t)$ 是根据这些测试集正样本的排名计算得出的。如果有 $P$ 个测试集正样本，它们位于排名 $r_1, r_2, \\dots, r_P$，则在这些排名中的每一个位置上的精确率 $\\mathrm{Prec}(r_i)$ 是截至该排名为止找到的真阳性样本的比例。AP是这些精确率值的平均值：\n$$\n\\mathrm{AP}^{(k)}(t) = \\frac{1}{P} \\sum_{i=1}^{P} \\mathrm{Prec}(r_i)\n$$\n该指标奖励将正样本排名更高的算法。为了在给定时间 $t$ 获得跨所有疾病的单一性能度量，我们计算平均精确率均值 $\\mathrm{mAP}(t)$，即所有具有非空测试集疾病的 $\\mathrm{AP}^{(k)}(t)$ 值的算术平均值。\n\n**4. 鲁棒参数范围的识别**\n\n扩散时间 $t$ 是一个关键的超参数。一个鲁棒的算法不仅应在单个最优 $t$ 值上表现良好，而且应在一个值范围内都表现良好。为了确定这个范围，我们首先计算指定网格中所有 $t$ 的 $\\mathrm{mAP}(t)$。然后我们找到最大性能 $\\max_{k} \\mathrm{mAP}(t_k)$。\n\n鲁棒索引集 $\\mathcal{R}$ 定义为所有性能接近最大值（由容差参数 $\\epsilon$ 控制）的零基索引 $j$ 的集合：\n$$\n\\mathcal{R} = \\{ j \\mid \\mathrm{mAP}(t_j) \\ge \\max_{k} \\mathrm{mAP}(t_k) - \\epsilon \\}\n$$\n最后，这个索引集被压缩成一个最小化的最大连续区间集合 $[a, b]$，其中 $a$ 和 $b$ 是每个连续块的起始和结束索引。这提供了一个紧凑的表示，说明了该方法在哪些时间参数范围内能产生鲁棒且近乎最优的性能。整个过程被系统地应用于每个测试用例，以得出最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\nimport json\n\ndef get_network_laplacian(name):\n    \"\"\"\n    Builds the adjacency matrix and combinatorial Laplacian for G1 or G2.\n    \"\"\"\n    n = 12\n    A = np.zeros((n, n), dtype=float)\n    \n    module_A_edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (1, 3)]\n    module_B_edges = [(5, 6), (6, 7), (7, 8), (8, 5), (6, 8)]\n    module_C_edges = [(9, 10), (10, 11), (11, 9)]\n    inter_module_edges = [(2, 5), (3, 6), (4, 7), (8, 9), (1, 10)]\n\n    edges = module_A_edges + module_B_edges + module_C_edges\n    if name == 'G1':\n        edges += inter_module_edges\n\n    for i, j in edges:\n        A[i, j] = 1\n        A[j, i] = 1\n        \n    D = np.diag(np.sum(A, axis=1))\n    L = D - A\n    return L\n\ndef calculate_ap(scores, train_pos, test_pos, n_nodes):\n    \"\"\"\n    Calculates Average Precision for a given ranking.\n    \"\"\"\n    if not test_pos:\n        return np.nan  # As per problem, skip diseases with no test positives\n\n    all_nodes = set(range(n_nodes))\n    eval_nodes_set = all_nodes - train_pos\n    eval_nodes = sorted(list(eval_nodes_set))\n    \n    eval_scores = scores[eval_nodes]\n    \n    # Use stable sort to handle ties consistently by node index\n    sorted_indices = np.argsort(eval_scores, kind='stable')[::-1]\n    \n    ranked_nodes = [eval_nodes[i] for i in sorted_indices]\n    \n    num_positives = len(test_pos)\n    hits = 0\n    sum_prec = 0.0\n    \n    for i, node in enumerate(ranked_nodes):\n        if node in test_pos:\n            hits += 1\n            precision_at_k = hits / (i + 1)\n            sum_prec += precision_at_k\n            \n    return sum_prec / num_positives if num_positives > 0 else 0.0\n\ndef find_robust_intervals(maps, epsilon):\n    \"\"\"\n    Finds maximal contiguous robust index intervals from a list of mAP scores.\n    \"\"\"\n    if not maps:\n        return []\n\n    maps_array = np.array(maps)\n    max_map = np.max(maps_array)\n    # np.where returns a tuple of arrays, we need the first one\n    robust_indices = np.where(maps_array >= max_map - epsilon)[0].tolist()\n    \n    if not robust_indices:\n        return []\n\n    intervals = []\n    start = robust_indices[0]\n    end = robust_indices[0]\n\n    for i in range(1, len(robust_indices)):\n        if robust_indices[i] == end + 1:\n            end = robust_indices[i]\n        else:\n            intervals.append([start, end])\n            start = robust_indices[i]\n            end = robust_indices[i]\n    intervals.append([start, end])\n    \n    return intervals\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'network': 'G1', 'times': np.round(np.arange(0.1, 2.01, 0.1), 2), 'epsilon': 0.01},\n        {'network': 'G1', 'times': np.array([0.0, 0.05, 0.1, 0.2, 0.5]), 'epsilon': 0.005},\n        {'network': 'G2', 'times': np.array([0.05, 0.1, 0.2, 0.5, 1.0, 2.0]), 'epsilon': 0.01},\n    ]\n\n    diseases = [\n        {'train': {0, 2, 4}, 'test': {1, 3}},\n        {'train': {5, 7}, 'test': {6, 8}},\n        {'train': {9}, 'test': {10, 11}},\n    ]\n    \n    n_nodes = 12\n\n    # Pre-calculate Laplacians and initial seed vectors\n    laplacians = {\n        'G1': get_network_laplacian('G1'),\n        'G2': get_network_laplacian('G2'),\n    }\n    \n    y_vectors = []\n    for disease in diseases:\n        y = np.zeros(n_nodes)\n        if disease['train']:\n            y[list(disease['train'])] = 1.0\n            y /= np.sum(y)\n        y_vectors.append(y)\n        \n    all_case_results = []\n    \n    for case in test_cases:\n        L = laplacians[case['network']]\n        times = case['times']\n        epsilon = case['epsilon']\n        \n        map_over_time = []\n        for t in times:\n            if t == 0.0:\n                K = np.identity(n_nodes)\n            else:\n                K = expm(-t * L)\n\n            ap_scores_for_t = []\n            for i, disease in enumerate(diseases):\n                y = y_vectors[i]\n                scores = K @ y\n                ap = calculate_ap(scores, disease['train'], disease['test'], n_nodes)\n                if not np.isnan(ap):\n                    ap_scores_for_t.append(ap)\n            \n            mAP = np.mean(ap_scores_for_t) if ap_scores_for_t else 0.0\n            map_over_time.append(mAP)\n\n        intervals = find_robust_intervals(map_over_time, epsilon)\n        all_case_results.append(intervals)\n    \n    # Format output to be compact JSON-like string, without spaces\n    formatted_results = [json.dumps(res, separators=(',', ':')) for res in all_case_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在生物网络分析中，我们经常会遇到有向网络（如基因调控网络）和无向网络（如蛋白质相互作用网络）。一个常见的简化操作是将有向网络“对称化”为无向网络，但这会丢失方向性信息。本练习通过在有向网络及其对称化版本上分别运行带重启的随机游走 (RWR)算法，并量化两者结果的差异，旨在让您深入理解网络方向性对信息传播模式的影响，从而在建模时做出更明智的选择。",
            "id": "4366480",
            "problem": "一个有向基因调控网络由一个非负项邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 表示从节点 $i$到节点 $j$ 的有向调控强度。其对称化版本定义为 $A^{\\mathrm{sym}} = \\frac{1}{2}\\left(A + A^\\top\\right)$，该版本在消除方向不对称性的同时保留了权重。为了对种子信号的网络传播进行建模，考虑在一个行随机转移矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 上进行带重启的随机游走（RWR）过程。该矩阵通过将 $A$ 的每一行归一化使其和为 1 来获得；如果某一行和为 0，则为该行设置 $W_{ii} = 1$ 以创建一个自循环。设种子分布为一个非负行向量 $b \\in \\mathbb{R}^{1 \\times n}$，且 $\\sum_{i=1}^{n} b_i = 1$。对于重启参数 $\\alpha \\in (0,1)$，定义迭代动力学为 $s^{(0)} = b$ 和\n$$\ns^{(t+1)} = \\alpha b + (1 - \\alpha) s^{(t)} W,\n$$\n对于 $t = 0,1,2,\\dots$，并迭代直至在 $\\ell_1$ 范数下收敛，即直到对于指定的容差 $\\varepsilon > 0$，满足 $\\left\\lVert s^{(t+1)} - s^{(t)} \\right\\rVert_1  \\varepsilon$。将此过程应用于有向网络 $A$ 和对称化网络 $A^{\\mathrm{sym}}$，以获得稳态传播得分向量 $s^\\star_{\\mathrm{dir}}$ 和 $s^\\star_{\\mathrm{sym}}$。通过计算两个指标来量化方向性的重要性：$\\ell_1$ 差值\n$$\nd_1 = \\sum_{i=1}^{n} \\left| s^\\star_{\\mathrm{dir}, i} - s^\\star_{\\mathrm{sym}, i} \\right|,\n$$\n和 $s^\\star_{\\mathrm{dir}}$ 与 $s^\\star_{\\mathrm{sym}}$ 之间的斯皮尔曼等级相关系数 $\\rho$（相同排名通过平均排名处理）。如果两个向量在数值容差范围内逐元素相同，则设 $\\rho = 1$。如果由于等级恒定导致等级相关性未定义，则设 $\\rho = 0$。\n\n实现此过程并为以下每个测试用例计算 $(d_1, \\rho)$。以下所有量均为无量纲，并且必须进行数值处理。使用 $\\varepsilon = 10^{-12}$ 作为收敛条件。\n\n测试用例 1 (正常路径):\n- 大小：$n = 5$。\n- 有向邻接矩阵 $A^{(1)}$:\n$$\n\\begin{bmatrix}\n0  1  0.5  0  0 \\\\\n0.2  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n0.1  0  0.4  0  0\n\\end{bmatrix}\n$$\n- 种子集：节点 $\\{0, 1\\}$，权重相等，即 $b = \\left[\\frac{1}{2}, \\frac{1}{2}, 0, 0, 0\\right]$。\n- 重启参数：$\\alpha = 0.3$。\n\n测试用例 2 (边界条件：已为对称的有向网络):\n- 大小：$n = 5$。\n- 有向邻接矩阵 $A^{(2)}$:\n$$\n\\begin{bmatrix}\n0  1  0  0  0 \\\\\n1  0  1  0  0 \\\\\n0  1  0  1  0 \\\\\n0  0  1  0  1 \\\\\n0  0  0  1  0\n\\end{bmatrix}\n$$\n- 种子集：节点 $\\{2\\}$，即 $b = \\left[0, 0, 1, 0, 0\\right]$。\n- 重启参数：$\\alpha = 0.3$。\n\n测试用例 3 (边缘情况：悬挂汇点凸显方向性):\n- 大小：$n = 5$。\n- 有向邻接矩阵 $A^{(3)}$:\n$$\n\\begin{bmatrix}\n0  1  0.5  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n0  0  0  0  0\n\\end{bmatrix}\n$$\n- 种子集：节点 $\\{0\\}$，即 $b = \\left[1, 0, 0, 0, 0\\right]$。\n- 重启参数：$\\alpha = 0.15$。\n\n你的程序必须：\n- 通过对给定的每个 $A$ 进行行归一化来构建 $W$，对于出度为零的行采用自循环约定。\n- 构建 $A^{\\mathrm{sym}} = \\frac{1}{2}(A + A^\\top)$ 及其对应的行随机矩阵 $W^{\\mathrm{sym}}$，采用相同的零行自循环约定。\n- 对每个测试用例，迭代 RWR 动力学直至收敛，以获得 $s^\\star_{\\mathrm{dir}}$ 和 $s^\\star_{\\mathrm{sym}}$。\n- 为每个测试用例计算 $d_1$ 和 $\\rho$。\n- 输出一行，包含 6 个浮点数结果，格式为方括号括起来的逗号分隔列表，顺序为 $\\left[d_1^{(1)}, \\rho^{(1)}, d_1^{(2)}, \\rho^{(2)}, d_1^{(3)}, \\rho^{(3)}\\right]$，每个值四舍五入到六位小数。",
            "solution": "该问题是有效的，因为它在网络科学中具有科学依据，是良构的、客观的，并提供了一套完整且一致的定义和数据。任务是实现带重启的随机游走（RWR）算法，以量化网络方向性的影响。\n\n问题的核心在于比较有向网络上的随机游走与其对称化版本上的稳态分布。一个有向网络由一个邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 描述，其中 $A_{ij}$ 表示从节点 $i$ 到节点 $j$ 的有向边权重。RWR 算法模拟了该网络上的一个扩散过程，需要一个行随机转移矩阵 $W$。\n\n首先，我们从给定的邻接矩阵（$A$ 或其对称化版本）构建转移矩阵 $W$。对于邻接矩阵的每一行 $i$，$W$ 中的相应行通过将其条目归一化使其和为 1 来计算。如果一行的和为 0（即一个没有出边的节点），则在 $W$ 中为该节点创建一个权重为 1 的自循环。这个过程可以表示为：\n$$\nW_{ij} = \\begin{cases}\nA_{ij} / \\sum_{k=1}^{n} A_{ik}  \\text{if } \\sum_{k=1}^n A_{ik} \\neq 0 \\\\\n\\delta_{ij}  \\text{if } \\sum_{k=1}^n A_{ik} = 0\n\\end{cases}\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。\n\nRWR 过程对从种子分布开始的信号传播进行建模，该分布由一个概率向量 $b \\in \\mathbb{R}^{1 \\times n}$ 表示。该过程根据迭代方程演化：\n$$\ns^{(t+1)} = \\alpha b + (1 - \\alpha) s^{(t)} W\n$$\n从 $s^{(0)} = b$ 开始。参数 $\\alpha \\in (0,1)$ 是重启概率，它确保游走者周期性地返回到种子节点，从而防止扩散完全迷失在网络结构中。项 $(1 - \\alpha) s^{(t)} W$ 描述了随机游走的单步。这个迭代过程是一个压缩映射，保证收敛到一个唯一的稳态概率分布 $s^\\star$。我们进行迭代，直到连续得分向量之差的 $\\ell_1$ 范数小于指定的容差 $\\varepsilon = 10^{-12}$，即 $\\left\\lVert s^{(t+1)} - s^{(t)} \\right\\rVert_1  \\varepsilon$。\n\n为了评估方向性的作用，我们对两个网络执行此 RWR 过程：\n1. 原始有向网络，由其邻接矩阵 $A$ 表示，产生稳态得分向量 $s^\\star_{\\mathrm{dir}}$。\n2. 网络的对称化版本，由 $A^{\\mathrm{sym}} = \\frac{1}{2}(A + A^\\top)$ 表示。这创建了一个无向图，其中两个节点之间的连接强度是两个方向上有向权重的平均值。在此网络上进行 RWR 过程产生 $s^\\star_{\\mathrm{sym}}$。\n\n这两个结果之间的差异使用两个指标来量化：\n1. $\\ell_1$ 差值，$d_1 = \\sum_{i=1}^{n} \\left| s^\\star_{\\mathrm{dir}, i} - s^\\star_{\\mathrm{sym}, i} \\right|$，它衡量节点得分的总绝对偏差。\n2. 斯皮尔曼等级相关系数 $\\rho$，它衡量由有向和对称化传播生成的节点排名之间的单调一致性。问题规定，如果向量逐元素相同，则 $\\rho=1$；如果由于等级恒定导致相关性未定义，则 $\\rho=0$。\n\n我们的实现策略包括创建一个函数，用于对任何给定的邻接矩阵、种子向量和重启参数执行 RWR 迭代过程。对于每个测试用例，我们首先使用提供的有向邻接矩阵 $A$ 计算 $s^\\star_{\\mathrm{dir}}$。然后，我们计算 $A^{\\mathrm{sym}}$，并用它来找到 $s^\\star_{\\mathrm{sym}}$。最后，我们从这两个向量计算 $d_1$ 和 $\\rho$ 指标。`numpy` 库用于所有数值和矩阵运算，而 `scipy.stats.spearmanr` 用于计算等级相关性，并附有处理指定特殊情况的附加逻辑。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import spearmanr\n\ndef row_normalize(A):\n    \"\"\"\n    Normalizes the rows of an adjacency matrix to create a stochastic matrix W.\n    Handles rows with a sum of 0 by creating a self-loop.\n    \"\"\"\n    W = np.zeros_like(A, dtype=float)\n    row_sums = A.sum(axis=1)\n    \n    non_zero_rows_mask = row_sums != 0\n    W[non_zero_rows_mask] = A[non_zero_rows_mask] / row_sums[non_zero_rows_mask, np.newaxis]\n    \n    zero_rows_indices = np.where(row_sums == 0)[0]\n    if zero_rows_indices.size > 0:\n        W[zero_rows_indices, zero_rows_indices] = 1.0\n        \n    return W\n\ndef run_rwr(A, b, alpha, epsilon):\n    \"\"\"\n    Performs Random Walk with Restart until convergence.\n    \"\"\"\n    W = row_normalize(A)\n    s_current = b.copy()\n    \n    while True:\n        s_next = alpha * b + (1 - alpha) * s_current @ W\n        if np.linalg.norm(s_next - s_current, ord=1)  epsilon:\n            break\n        s_current = s_next\n        \n    return s_next\n\ndef calculate_spearman_rho(s1, s2):\n    \"\"\"\n    Calculates the Spearman rank correlation with special case handling.\n    \"\"\"\n    if np.allclose(s1, s2, atol=1e-12, rtol=1e-12):\n        return 1.0\n    \n    rho, _ = spearmanr(s1, s2)\n    \n    if np.isnan(rho):\n        return 0.0\n    \n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    epsilon = 1e-12\n\n    # Test Case 1\n    A1 = np.array([\n        [0.0, 1.0, 0.5, 0.0, 0.0],\n        [0.2, 0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 1.0],\n        [0.1, 0.0, 0.4, 0.0, 0.0]\n    ], dtype=float)\n    b1 = np.array([0.5, 0.5, 0.0, 0.0, 0.0], dtype=float)\n    alpha1 = 0.3\n\n    # Test Case 2\n    A2 = np.array([\n        [0.0, 1.0, 0.0, 0.0, 0.0],\n        [1.0, 0.0, 1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0, 1.0],\n        [0.0, 0.0, 0.0, 1.0, 0.0]\n    ], dtype=float)\n    b2 = np.array([0.0, 0.0, 1.0, 0.0, 0.0], dtype=float)\n    alpha2 = 0.3\n\n    # Test Case 3\n    A3 = np.array([\n        [0.0, 1.0, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 0.0, 1.0],\n        [0.0, 0.0, 0.0, 0.0, 0.0]\n    ], dtype=float)\n    b3 = np.array([1.0, 0.0, 0.0, 0.0, 0.0], dtype=float)\n    alpha3 = 0.15\n\n    test_cases = [\n        (A1, b1, alpha1),\n        (A2, b2, alpha2),\n        (A3, b3, alpha3)\n    ]\n\n    all_results = []\n    for A, b, alpha in test_cases:\n        # Directed network propagation\n        s_star_dir = run_rwr(A, b, alpha, epsilon)\n        \n        # Symmetrized network propagation\n        A_sym = 0.5 * (A + A.T)\n        s_star_sym = run_rwr(A_sym, b, alpha, epsilon)\n        \n        # Compute metrics\n        d1 = np.linalg.norm(s_star_dir - s_star_sym, ord=1)\n        rho = calculate_spearman_rho(s_star_dir, s_star_sym)\n        \n        all_results.extend([d1, rho])\n\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "网络传播算法一个常见的陷阱是“度偏好” (degree confounding)，即高连接度的节点（网络枢纽）无论其与种子节点的真实关联如何，都倾向于获得高分。本练习通过一个具体的计算实例，让您亲手分离并移除传播分数中由节点度 $d$ 贡献的部分，从而获得校正后的分数 $s_{\\mathrm{corr}}$。掌握这种校正方法对于从网络分析结果中提取可靠的、非平凡的生物学见解至关重要。",
            "id": "4366495",
            "problem": "给定一个小型蛋白质-蛋白质相互作用（PPI）网络，该网络被建模为一个无向简单图，用于研究系统生物医学中网络传播的度混杂效应。设顶点集为 $\\{A,B,C,D,E\\}$，并定义邻接矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$（行和列按 $A,B,C,D,E$ 的顺序排列）如下：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  1  0  0 \\\\\n1  0  1  0  0 \\\\\n1  1  0  1  0 \\\\\n0  0  1  0  1 \\\\\n0  0  0  1  0\n\\end{pmatrix}.\n$$\n设度向量为 $d \\in \\mathbb{R}^{5}$，其分量 $d_i$ 等于节点 $i$ 的度，因此 $d = A \\mathbf{1}$，其中 $\\mathbf{1} \\in \\mathbb{R}^{5}$ 是全1向量。定义对角度矩阵 $D = \\mathrm{diag}(d)$ 和行随机转移矩阵 $P = D^{-1} A$。考虑一个疾病相关性种子信号 $y \\in \\mathbb{R}^{5}$ 的单步扩散，该信号为 $y = (1,0,0,0,3)^{\\top}$，代表节点 $A$ 和 $E$ 上的相对初始强度。单步传播后的得分为 $s = P y$。\n\n传播中的度混杂效应指的是得分 $s$ 与度 $d$ 相关的趋势，这可能导致度数高的节点得分被夸大，而这种夸大与生物学上有意义的信号无关。为了分析和校正此效应，请推导一个度校正得分向量 $s_{\\mathrm{corr}}$。推导方法是在最小二乘意义下，移除 $s$ 中可以由 $\\mathbf{1}$ 和 $d$ 所张成的子空间解释的分量。也就是说，找到系数 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$ 以最小化 $\\| s - a \\mathbf{1} - b d \\|_{2}$，并定义 $s_{\\mathrm{corr}} = s - a \\mathbf{1} - b d$。\n\n然后：\n- 计算原始传播得分 $s$ 和校正后得分 $s_{\\mathrm{corr}}$。\n- 分别根据 $s$ 和 $s_{\\mathrm{corr}}$ 对节点进行降序排名。如果出现并列，则为并列的节点分配平均排名。\n- 计算这两个排名之间的斯皮尔曼等级相关系数（Spearman's rho）。\n\n将最终的 Spearman's rho 值四舍五入到四位有效数字。不需要单位。在答案框中仅填写最终的数值，不要添加任何额外文本。",
            "solution": "用户提供的问题已经过验证，并被确定为一个有效的、适定的科学问题。解题过程将按要求分步进行。\n\n问题要求在一个小图上的网络传播场景中分析度混杂效应。步骤如下：\n1.  计算相关的网络矩阵和传播得分向量 $s$。\n2.  求解一个最小二乘问题，以找到 $s$ 在由全1向量和度向量所张成的子空间上的投影。\n3.  计算度校正得分向量 $s_{\\mathrm{corr}}$。\n4.  根据 $s$ 和 $s_{\\mathrm{corr}}$ 对节点进行排名。\n5.  计算两个排名之间的斯皮尔曼等级相关系数。\n\n**步骤1：计算网络属性和传播得分 $s$**\n\n邻接矩阵给定如下：\n$$\nA = \\begin{pmatrix}\n0  1  1  0  0 \\\\\n1  0  1  0  0 \\\\\n1  1  0  1  0 \\\\\n0  0  1  0  1 \\\\\n0  0  0  1  0\n\\end{pmatrix}\n$$\n顶点集为 $\\{A,B,C,D,E\\}$，对应于索引 $1, 2, 3, 4, 5$。度向量 $d$ 是 $A$ 的行和：\n$d_1 = d_A = 0+1+1+0+0 = 2$\n$d_2 = d_B = 1+0+1+0+0 = 2$\n$d_3 = d_C = 1+1+0+1+0 = 3$\n$d_4 = d_D = 0+0+1+0+1 = 2$\n$d_5 = d_E = 0+0+0+1+0 = 1$\n所以，度向量为 $d = (2, 2, 3, 2, 1)^{\\top}$。\n\n对角度矩阵 $D$ 及其逆矩阵 $D^{-1}$ 为：\n$$\nD = \\mathrm{diag}(2, 2, 3, 2, 1) = \\begin{pmatrix}\n2  0  0  0  0 \\\\\n0  2  0  0  0 \\\\\n0  0  3  0  0 \\\\\n0  0  0  2  0 \\\\\n0  0  0  0  1\n\\end{pmatrix}, \\quad D^{-1} = \\begin{pmatrix}\n1/2  0  0  0  0 \\\\\n0  1/2  0  0  0 \\\\\n0  0  1/3  0  0 \\\\\n0  0  0  1/2  0 \\\\\n0  0  0  0  1\n\\end{pmatrix}\n$$\n行随机转移矩阵 $P$ 为 $P = D^{-1} A$：\n$$\nP = \\begin{pmatrix}\n1/2  0  0  0  0 \\\\\n0  1/2  0  0  0 \\\\\n0  0  1/3  0  0 \\\\\n0  0  0  1/2  0 \\\\\n0  0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\n0  1  1  0  0 \\\\\n1  0  1  0  0 \\\\\n1  1  0  1  0 \\\\\n0  0  1  0  1 \\\\\n0  0  0  1  0\n\\end{pmatrix}\n= \\begin{pmatrix}\n0  1/2  1/2  0  0 \\\\\n1/2  0  1/2  0  0 \\\\\n1/3  1/3  0  1/3  0 \\\\\n0  0  1/2  0  1/2 \\\\\n0  0  0  1  0\n\\end{pmatrix}\n$$\n初始种子信号为 $y = (1, 0, 0, 0, 3)^{\\top}$。单步传播得分 $s = Py$ 为：\n$$\ns = \\begin{pmatrix}\n0  1/2  1/2  0  0 \\\\\n1/2  0  1/2  0  0 \\\\\n1/3  1/3  0  1/3  0 \\\\\n0  0  1/2  0  1/2 \\\\\n0  0  0  1  0\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 3\n\\end{pmatrix}\n= \\begin{pmatrix}\n0 \\cdot 1 + 0 + 0 + 0 + 0 \\\\\n(1/2) \\cdot 1 + 0 + 0 + 0 + 0 \\\\\n(1/3) \\cdot 1 + 0 + 0 + 0 + 0 \\\\\n0 + 0 + 0 + 0 + (1/2) \\cdot 3 \\\\\n0 + 0 + 0 + 1 \\cdot 0 + 0\n\\end{pmatrix}\n= \\begin{pmatrix}\n0 \\\\\n1/2 \\\\\n1/3 \\\\\n3/2 \\\\\n0\n\\end{pmatrix}\n$$\n所以，原始传播得分向量为 $s = (0, 1/2, 1/3, 3/2, 0)^{\\top}$。\n\n**步骤2：求解最小二乘问题**\n\n我们要找到系数 $a, b \\in \\mathbb{R}$ 以最小化 $\\| s - a \\mathbf{1} - b d \\|_{2}$，其中 $\\mathbf{1} = (1, 1, 1, 1, 1)^{\\top}$ 且 $d = (2, 2, 3, 2, 1)^{\\top}$。这是一个线性最小二乘问题。设 $X = [\\mathbf{1} \\; d]$。解 $\\begin{pmatrix} a \\\\ b \\end{pmatrix}$ 由正规方程给出：$X^{\\top}X \\begin{pmatrix} a \\\\ b \\end{pmatrix} = X^{\\top}s$。\n\n首先，我们计算矩阵 $X^{\\top}X$ 和 $X^{\\top}s$：\n$\\mathbf{1}^{\\top}\\mathbf{1} = 1^2+1^2+1^2+1^2+1^2 = 5$\n$\\mathbf{1}^{\\top}d = d^{\\top}\\mathbf{1} = 1(2)+1(2)+1(3)+1(2)+1(1) = 10$\n$d^{\\top}d = 2^2+2^2+3^2+2^2+1^2 = 4+4+9+4+1 = 22$\n$$\nX^{\\top}X = \\begin{pmatrix}\n\\mathbf{1}^{\\top}\\mathbf{1}  \\mathbf{1}^{\\top}d \\\\\nd^{\\top}\\mathbf{1}  d^{\\top}d\n\\end{pmatrix} = \\begin{pmatrix}\n5  10 \\\\\n10  22\n\\end{pmatrix}\n$$\n接着，我们计算 $X^{\\top}s$：\n$\\mathbf{1}^{\\top}s = 0 + 1/2 + 1/3 + 3/2 + 0 = 2 + 1/3 = 7/3$\n$d^{\\top}s = 2(0) + 2(1/2) + 3(1/3) + 2(3/2) + 1(0) = 0 + 1 + 1 + 3 + 0 = 5$\n$$\nX^{\\top}s = \\begin{pmatrix} \\mathbf{1}^{\\top}s \\\\ d^{\\top}s \\end{pmatrix} = \\begin{pmatrix} 7/3 \\\\ 5 \\end{pmatrix}\n$$\n我们求解方程组 $\\begin{pmatrix} 5  10 \\\\ 10  22 \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} 7/3 \\\\ 5 \\end{pmatrix}$。\n$X^{\\top}X$ 的逆矩阵是：\n$(X^{\\top}X)^{-1} = \\frac{1}{5(22) - 10(10)} \\begin{pmatrix} 22  -10 \\\\ -10  5 \\end{pmatrix} = \\frac{1}{10} \\begin{pmatrix} 22  -10 \\\\ -10  5 \\end{pmatrix}$\n现在，我们求 $a$ 和 $b$：\n$$\n\\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\frac{1}{10} \\begin{pmatrix} 22  -10 \\\\ -10  5 \\end{pmatrix} \\begin{pmatrix} 7/3 \\\\ 5 \\end{pmatrix} = \\frac{1}{10} \\begin{pmatrix} 22(7/3) - 10(5) \\\\ -10(7/3) + 5(5) \\end{pmatrix} = \\frac{1}{10} \\begin{pmatrix} 154/3 - 150/3 \\\\ -70/3 + 75/3 \\end{pmatrix} = \\frac{1}{10} \\begin{pmatrix} 4/3 \\\\ 5/3 \\end{pmatrix} = \\begin{pmatrix} 4/30 \\\\ 5/30 \\end{pmatrix}\n$$\n所以，$a = 2/15$ 且 $b = 1/6$。\n\n**步骤3：计算校正后得分 $s_{\\mathrm{corr}}$**\n\n校正后得分为 $s_{\\mathrm{corr}} = s - a \\mathbf{1} - b d$。\n$s_{\\mathrm{corr}, A} = s_1 - a(1) - b(d_1) = 0 - 2/15 - (1/6)(2) = -2/15 - 1/3 = -2/15 - 5/15 = -7/15$\n$s_{\\mathrm{corr}, B} = s_2 - a(1) - b(d_2) = 1/2 - 2/15 - (1/6)(2) = 1/2 - 2/15 - 1/3 = 15/30 - 4/30 - 10/30 = 1/30$\n$s_{\\mathrm{corr}, C} = s_3 - a(1) - b(d_3) = 1/3 - 2/15 - (1/6)(3) = 1/3 - 2/15 - 1/2 = 10/30 - 4/30 - 15/30 = -9/30 = -3/10$\n$s_{\\mathrm{corr}, D} = s_4 - a(1) - b(d_4) = 3/2 - 2/15 - (1/6)(2) = 3/2 - 2/15 - 1/3 = 45/30 - 4/30 - 10/30 = 31/30$\n$s_{\\mathrm{corr}, E} = s_5 - a(1) - b(d_5) = 0 - 2/15 - (1/6)(1) = -4/30 - 5/30 = -9/30 = -3/10$\n因此，校正后得分向量为 $s_{\\mathrm{corr}} = (-7/15, 1/30, -3/10, 31/30, -3/10)^{\\top}$。\n\n**步骤4：对节点进行排名**\n\n我们根据两个得分向量对节点进行降序排名。\n原始得分 $s$：$A(0)$, $B(0.5)$, $C(1/3 \\approx 0.333)$, $D(1.5)$, $E(0)$。\n顺序为 $D > B > C > A, E$。\n排名 $R_s$ 为：\n- $D$：排名 $1$\n- $B$：排名 $2$\n- $C$：排名 $3$\n- $A, E$：并列第 $4$ 和第 $5$ 名。平均排名为 $(4+5)/2 = 4.5$。\n所以，$R_s = (4.5, 2, 3, 1, 4.5)^{\\top}$。\n\n校正后得分 $s_{\\mathrm{corr}}$：$A(-7/15 \\approx -0.467)$, $B(1/30 \\approx 0.033)$, $C(-3/10 = -0.3)$, $D(31/30 \\approx 1.033)$, $E(-3/10 = -0.3)$。\n顺序为 $D > B > C, E > A$。\n排名 $R_{s_{\\mathrm{corr}}}$ 为：\n- $D$：排名 $1$\n- $B$：排名 $2$\n- $C, E$：并列第 $3$ 和第 $4$ 名。平均排名为 $(3+4)/2 = 3.5$。\n- $A$：排名 $5$\n所以，$R_{s_{\\mathrm{corr}}} = (5, 2, 3.5, 1, 3.5)^{\\top}$。\n\n**步骤5：计算斯皮尔曼等级相关系数**\n\n斯皮尔曼等级相关系数 rho, $\\rho$，是等级变量的皮尔逊相关系数。\n对于两个大小为 $n$ 的排名向量 $R_x$ 和 $R_y$，公式为：\n$$ \\rho = \\frac{\\sum_{i=1}^n (R_{x,i} - \\bar{R}_x)(R_{y,i} - \\bar{R}_y)}{\\sqrt{\\sum_{i=1}^n (R_{x,i} - \\bar{R}_x)^2 \\sum_{i=1}^n (R_{y,i} - \\bar{R}_y)^2}} $$\n这里，$n=5$。平均排名是 $\\bar{R} = (n+1)/2 = (5+1)/2 = 3$。\n设 $x_i = R_{s,i}$ 且 $y_i = R_{s_{\\mathrm{corr}},i}$。\n$R_s = (4.5, 2, 3, 1, 4.5)$\n$R_{s_{\\mathrm{corr}}} = (5, 2, 3.5, 1, 3.5)$\n与均值 $\\bar{R}=3$ 的偏差：\n$R_s - \\bar{R} = (1.5, -1, 0, -2, 1.5)$\n$R_{s_{\\mathrm{corr}}} - \\bar{R} = (2, -1, 0.5, -2, 0.5)$\n\n分子（协方差项）：\n$\\sum_{i=1}^5 (R_{s,i} - \\bar{R})(R_{s_{\\mathrm{corr}},i} - \\bar{R}) = (1.5)(2) + (-1)(-1) + (0)(0.5) + (-2)(-2) + (1.5)(0.5)$\n$= 3 + 1 + 0 + 4 + 0.75 = 8.75$\n\n分母（方差项）：\n$\\sum_{i=1}^5 (R_{s,i} - \\bar{R})^2 = (1.5)^2 + (-1)^2 + 0^2 + (-2)^2 + (1.5)^2 = 2.25 + 1 + 0 + 4 + 2.25 = 9.5$\n$\\sum_{i=1}^5 (R_{s_{\\mathrm{corr}},i} - \\bar{R})^2 = 2^2 + (-1)^2 + (0.5)^2 + (-2)^2 + (0.5)^2 = 4 + 1 + 0.25 + 4 + 0.25 = 9.5$\n\n现在，计算 $\\rho$：\n$$ \\rho = \\frac{8.75}{\\sqrt{9.5 \\cdot 9.5}} = \\frac{8.75}{9.5} = \\frac{35/4}{19/2} = \\frac{35}{4} \\cdot \\frac{2}{19} = \\frac{35}{38} $$\n为了得到最终的数值，我们进行除法运算：\n$\\rho = 35 / 38 \\approx 0.92105263...$\n四舍五入到四位有效数字得到 $0.9211$。",
            "answer": "$$\\boxed{0.9211}$$"
        }
    ]
}