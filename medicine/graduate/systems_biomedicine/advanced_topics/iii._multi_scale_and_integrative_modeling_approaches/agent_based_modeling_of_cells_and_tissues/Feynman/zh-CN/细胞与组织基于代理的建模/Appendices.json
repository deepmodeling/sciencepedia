{
    "hands_on_practices": [
        {
            "introduction": "要构建基于物理原理的细胞和组织模型，理解力如何产生稳定的结构至关重要。这个练习将复杂性简化为一个一维细胞链模型，其中细胞被视为由弹簧连接的质点 。通过这个理想化的思想实验，我们可以亲手实践如何从势能景观中推导出平衡条件，并使用Hessian矩阵分析其稳定性，这些都是基于物理的建模中的核心理论工具。",
            "id": "4314043",
            "problem": "考虑一个由 $N \\geq 3$ 个相同细胞组成的一维链的基于智能体的模型。这些细胞被表示为沿一条直线上位置为 $x_{1}, x_{2}, \\dots, x_{N}$ 的质点。细胞通过劲度系数为 $k$、有限静息长度为 $r_{0}$ 的最近邻线性弹簧相互作用。总机械势能为\n$$\nU(x_{1}, \\dots, x_{N}) = \\frac{k}{2} \\sum_{i=1}^{N-1} \\left(|x_{i+1} - x_{i}| - r_{0}\\right)^{2}.\n$$\n边界细胞被固定在 $x_{1} = 0$ 和 $x_{N} = L$（其中 $L > 0$），并且在平衡状态下，该链保持 $x_{1}  x_{2}  \\cdots  x_{N}$ 的顺序。\n\n引入无量纲位置 $y_{i} = x_{i}/r_{0}$ 和无量纲长度 $\\ell = L/r_{0}$，并定义无量纲能量\n$$\nE(y_{1}, \\dots, y_{N}) = \\frac{U(x_{1}, \\dots, x_{N})}{k r_{0}^{2}}.\n$$\n仅使用弹簧机械势能的定义、力是势能的负梯度这一定义，以及通过 $E$ 围绕平衡点的二次变分（海森矩阵）判断线性稳定性的方法，推导出：\n\n1. 相邻细胞间的平衡无量纲间距 $s^{\\ast}$，其在平衡时定义为 $s^{\\ast} = y_{i+1} - y_{i}$（对于所有 $i$ 都是均匀的）。\n2. $E$ 关于内部自由度 $(y_{2}, \\dots, y_{N-1})$ 的海森矩阵在平衡构型下计算的最小特征值 $\\lambda_{\\min}$，该值决定了线性稳定性。\n\n将您的最终答案表示为关于 $\\ell$、$N$ 和标准函数的解析表达式。将包含 $s^{\\ast}$ 和 $\\lambda_{\\min}$ 的单个最终答案以行矩阵的形式给出。最终的方框答案中不要包含单位；所有要求的量根据其构造都是无量纲的。无需进行数值四舍五入。",
            "solution": "该模型将细胞视为由最近邻弹簧连接的质点。由弹簧引起的机械势能由下式给出：\n$$\nU(x_{1}, \\dots, x_{N}) = \\frac{k}{2} \\sum_{i=1}^{N-1} \\left(|x_{i+1} - x_{i}| - r_{0}\\right)^{2}.\n$$\n由于边界约束施加了 $x_{1} = 0$ 和 $x_{N} = L > 0$ 并且链保持 $x_{i+1} > x_{i}$，因此在平衡时我们有 $|x_{i+1} - x_{i}| = x_{i+1} - x_{i}$。引入无量纲变量 $y_{i} = x_{i}/r_{0}$ 和 $\\ell = L/r_{0}$。于是\n$$\nx_{i+1} - x_{i} - r_{0} = r_{0}\\left(y_{i+1} - y_{i} - 1\\right),\n$$\n无量纲能量变为\n$$\nE(y_{1}, \\dots, y_{N}) = \\frac{U}{k r_{0}^{2}} = \\frac{1}{2} \\sum_{i=1}^{N-1} \\left(y_{i+1} - y_{i} - 1\\right)^{2},\n$$\n满足固定边界条件 $y_{1} = 0$ 和 $y_{N} = \\ell$（其中 $\\ell > 0$）。\n\n首先，通过最小化 $E$ 关于内部自由度 $(y_{2}, \\dots, y_{N-1})$ 的值来确定平衡构型。通过将 $i = 2, \\dots, N-1$ 的偏导数设为零，可以获得一阶最优性（平稳性）条件：\n$$\n\\frac{\\partial E}{\\partial y_{i}} = \\frac{1}{2} \\cdot 2\\left(y_{i} - y_{i-1} - 1\\right) - \\frac{1}{2} \\cdot 2\\left(y_{i+1} - y_{i} - 1\\right) = \\left(y_{i} - y_{i-1} - 1\\right) - \\left(y_{i+1} - y_{i} - 1\\right) = 0.\n$$\n这可以简化为\n$$\ny_{i+1} - y_{i} = y_{i} - y_{i-1} \\quad \\text{对于所有 } i = 2, \\dots, N-1,\n$$\n这意味着间距是均匀的\n$$\ny_{i+1} - y_{i} = s \\quad \\text{与 } i \\text{ 无关}。\n$$\n使用边界条件 $y_{1} = 0$ 和 $y_{N} = \\ell$，我们得到\n$$\ny_{N} - y_{1} = \\sum_{i=1}^{N-1} (y_{i+1} - y_{i}) = (N-1) s = \\ell,\n$$\n因此，平衡无量纲间距为\n$$\ns^{\\ast} = \\frac{\\ell}{N - 1}.\n$$\n\n其次，通过计算 $E$ 关于内部变量 $(y_{2}, \\dots, y_{N-1})$ 在平衡构型下的海森矩阵来分析线性稳定性。因为 $E$ 是关于差值 $(y_{i+1} - y_{i} - 1)$ 的二次函数，所以它的二阶导数是常数，与具体构型无关。令 $n = N - 2$ 为内部自由度的数量。海森矩阵 $\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ 具有三对角形式\n$$\n\\mathbf{H} = \n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\ddots  \\vdots \\\\\n0  -1  2  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix},\n$$\n这是一维带有狄利克雷边界条件的离散拉普拉斯算子。为了找到其特征值，我们考虑标准的离散正弦特征向量\n$$\nv^{(j)}_{i} = \\sin\\!\\left(\\frac{\\pi j i}{n + 1}\\right), \\quad i = 1, \\dots, n, \\quad j = 1, \\dots, n,\n$$\n其中 $i$ 索引内部节点（$y_{2}$ 到 $y_{N-1}$ 映射为 $i = 1$ 到 $n$），而狄利克雷边界条件对应于强制施加 $v^{(j)}_{0} = v^{(j)}_{n+1} = 0$。将 $\\mathbf{H}$ 作用于 $v^{(j)}$ 得到\n$$\n(\\mathbf{H} v^{(j)})_{i} = 2 v^{(j)}_{i} - v^{(j)}_{i-1} - v^{(j)}_{i+1} = \\left[2 - 2\\cos\\!\\left(\\frac{\\pi j}{n + 1}\\right)\\right] v^{(j)}_{i}.\n$$\n因此，特征值为\n$$\n\\mu_{j} = 2 - 2\\cos\\!\\left(\\frac{\\pi j}{n + 1}\\right), \\quad j = 1, \\dots, n.\n$$\n最小特征值在 $j = 1$ 时出现：\n$$\n\\lambda_{\\min} = \\mu_{1} = 2 - 2\\cos\\!\\left(\\frac{\\pi}{n + 1}\\right).\n$$\n回顾 $n + 1 = (N - 2) + 1 = N - 1$，我们得到\n$$\n\\lambda_{\\min} = 2 - 2\\cos\\!\\left(\\frac{\\pi}{N - 1}\\right).\n$$\n因为对于 $\\theta \\in (0, \\pi)$ 有 $\\cos(\\theta)  1$，所以对于所有 $N \\geq 3$ 都有 $\\lambda_{\\min} > 0$，这证实了平衡点的线性稳定性。\n\n总结结果，平衡无量纲间距为 $s^{\\ast} = \\ell/(N - 1)$，最小海森特征值为 $\\lambda_{\\min} = 2 - 2\\cos\\!\\left(\\pi/(N - 1)\\right)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\dfrac{\\ell}{N - 1}  2 - 2\\cos\\!\\left(\\dfrac{\\pi}{N - 1}\\right)\\end{pmatrix}}$$"
        },
        {
            "introduction": "生物过程，如基因表达或细胞分化，本质上是随机的，而不仅仅是充满噪声。Gillespie算法，或称随机模拟算法(SSA)，是精确模拟这些随机动态的黄金标准 。本练习将引导你从第一性原理出发，基于泊松过程的基本特性推导出下一次反应发生的时间，让你不仅知其然，更知其所以然。理解其背后的数学原理，比仅仅调用一个现成的函数库更能赋予你构建和调试复杂模型的能力。",
            "id": "4314018",
            "problem": "考虑一个汇合上皮单层的基于智能体的模型，其中每个细胞是一个智能体，拥有 $M$ 个随机事件通道（索引为 $\\mu \\in \\{1,\\dots,M\\}$），例如黏附键的更新、细胞因子分泌、体积增长和分裂。在一个足够小的时间间隔内，假设组织的介观状态是准稳态的，因此每个通道的倾向 $a_{\\mu}$ 与时间无关，并将总倾向定义为 $a_{0} = \\sum_{\\mu=1}^{M} a_{\\mu}$。在随机模拟算法（SSA）（也称为 Gillespie 算法）的标准假设下，下一个事件的发生时间由一个随机点过程决定，该过程产生无记忆的事件间隔时间，并与等于 $a_{0}$ 的恒定风险率相符。\n\n从时齐泊松过程的定义性质以及风险函数、生存函数和累积分布函数之间的关系出发，推导出将从单位区间上的均匀分布中抽取的单个样本 $u$ 映射到下一个反应时间 $\\tau$ 的变换关系式（用 $a_{0}$ 和 $u$ 表示）。然后，对于一个处于给定全局状态的特定细胞，其测得的总倾向为 $a_{0} = 3.2\\ \\mathrm{s}^{-1}$，生成的均匀分布随机变量为 $u = 0.10$，计算 $\\tau$ 的值。\n\n最终时间以秒（s）为单位表示。将您的数值答案四舍五入到四位有效数字。",
            "solution": "随机模拟算法（SSA）的核心是确定两个量的方法：下一个将发生哪个事件，以及它何时发生。本问题侧重于后者。在总倾向为 $a_0$ 的系统中，直到下一个事件发生的时间 $\\tau$ 服从指数分布。我们可以按要求从第一性原理推导出这一点。\n\n设 $P(\\tau, \\mu)d\\tau$ 为下一个事件是反应 $\\mu$ 并且发生在无穷小时间区间 $[\\tau, \\tau+d\\tau)$ 内的概率。量 $a_{\\mu}d\\tau$ 是在给定时间 $t$ 的状态下，反应 $\\mu$ 发生在 $[\\tau, \\tau+d\\tau)$ 内的概率。任何反应在此区间内发生的总概率是 $a_{0}d\\tau$，其中 $a_0 = \\sum_{\\mu} a_{\\mu}$。\n\n在时间区间 $[0, \\tau)$ 内没有事件发生的概率由生存函数 $S(\\tau)$ 给出。生存函数与恒定风险率 $a_0$（在没有事件发生的情况下，单位时间内事件发生的瞬时概率）之间的关系由下式给出：\n$$ a_0 = -\\frac{d}{d\\tau} \\ln(S(\\tau)) $$\n我们可以通过从时间 $0$ 到时间 $\\tau$ 积分来求解 $S(\\tau)$。\n$$ \\int_0^{\\tau} a_0 dt' = -\\int_0^{\\tau} \\frac{d}{dt'} \\ln(S(t')) dt' $$\n由于 $a_0$ 是常数（时齐假设）：\n$$ a_0 \\tau = -[\\ln(S(t'))]_0^{\\tau} = -(\\ln(S(\\tau)) - \\ln(S(0))) $$\n在时间 $\\tau=0$ 时，没有时间流逝，因此存活（即尚未发生事件）的概率为 $1$。因此，$S(0) = 1$，这意味着 $\\ln(S(0)) = 0$。\n方程简化为：\n$$ a_0 \\tau = -\\ln(S(\\tau)) $$\n对两边取指数，得到生存函数：\n$$ S(\\tau) = \\exp(-a_0 \\tau) $$\n这个函数给出了下一个事件在时间 $\\tau$ *之后* 发生的概率。\n\n累积分布函数（CDF）$F(\\tau)$ 给出了下一个反应时间小于或等于 $\\tau$ 的概率。它是生存函数的补集：\n$$ F(\\tau) = P(T \\le \\tau) = 1 - S(\\tau) $$\n代入 $S(\\tau)$ 的表达式，我们得到：\n$$ F(\\tau) = 1 - \\exp(-a_0 \\tau) $$\n这是速率参数为 $a_0$ 的指数分布的累积分布函数。\n\n为了从这个分布中生成一个随机变量 $\\tau$，我们使用逆变换采样法。我们从区间 $(0, 1)$ 上的标准均匀分布中生成一个随机数 $u$，即 $u \\sim U(0,1)$。然后我们将此值设为等于累积分布函数，并求解 $\\tau$：\n$$ u = F(\\tau) = 1 - \\exp(-a_0 \\tau) $$\n重新整理以求解 $\\tau$：\n$$ 1 - u = \\exp(-a_0 \\tau) $$\n对两边取自然对数：\n$$ \\ln(1 - u) = -a_0 \\tau $$\n$$ \\tau = -\\frac{1}{a_0} \\ln(1 - u) $$\n均匀分布的一个性质是，如果 $u$ 是来自 $U(0,1)$ 的随机变量，那么 $1-u$ 也是来自 $U(0,1)$ 的随机变量。因此，为了计算方便，我们可以用 $u$ 替换 $1-u$：\n$$ \\tau = -\\frac{1}{a_0} \\ln(u) $$\n这就是将均匀随机变量 $u$ 映射到下一个反应时间 $\\tau$ 所需的变换。这个公式通常等价地表示为 $\\tau = \\frac{1}{a_0} \\ln(\\frac{1}{u})$。\n\n现在，我们将此公式应用于问题中给出的具体值。\n已知条件是：\n- 总倾向， $a_0 = 3.2\\ \\mathrm{s}^{-1}$\n- 均匀随机变量， $u = 0.10$\n\n将这些值代入推导出的变换式中：\n$$ \\tau = -\\frac{1}{3.2} \\ln(0.10) $$\n我们可以计算数值：\n$$ \\ln(0.10) \\approx -2.30258509... $$\n$$ \\frac{1}{3.2} = 0.3125 $$\n$$ \\tau \\approx -(0.3125) \\times (-2.30258509...) $$\n$$ \\tau \\approx 0.71955784... \\ \\mathrm{s} $$\n问题要求答案四舍五入到四位有效数字。\n$$ \\tau \\approx 0.7196 \\ \\mathrm{s} $$",
            "answer": "$$\\boxed{0.7196}$$"
        },
        {
            "introduction": "为了计算上的便捷，许多基于智能体的模型都采用了离散的网格来表示空间。然而，这种简化选择并非没有代价，它可能会引入模型设计者意想不到的人为效应（artifacts）。本练习是一个计算探索任务，要求你实现一个基于网格的细胞趋化运动模型，并通过比较不同的邻域规则（如Moore邻域与von Neumann邻域）来分析由此产生的方向偏差。通过亲手实现和测试，你将获得识别和量化这类“离散化效应”的实践经验，这是模型验证中的一项关键技能。",
            "id": "4313996",
            "problem": "考虑一个平面上细胞运动性的方形晶格基于主体的模型（ABM），其中每个主体执行时间离散的随机游走，每个时间步向一个相邻的晶格点移动一次。考虑两种邻域方案：Moore 邻域（包含 $8$ 个邻居，位移为 $\\{(\\pm 1,0),(0,\\pm 1),(\\pm 1,\\pm 1)\\}$）和 von Neumann 邻域（包含 $4$ 个邻居，位移为 $\\{(\\pm 1,0),(0,\\pm 1)\\}$）。趋化梯度由一个单位向量 $\\hat{\\mathbf{g}}$ 表示，其方向与正 $x$ 轴成 $\\theta$ 角（以弧度为单位），即 $\\hat{\\mathbf{g}} = (\\cos\\theta,\\sin\\theta)$。假设没有静止状态。\n\n定义执行移动时所施加位移的两种步长约定：\n- “物理 (physical)”：位移向量是原始晶格向量 $\\mathbf{d}_i \\in \\mathbb{Z}^2$，产生长度为 $1$ 的基本步和长度为 $\\sqrt{2}$ 的对角线步。\n- “归一化 (normalized)”：位移向量是晶格方向上的单位向量 $\\hat{\\mathbf{d}}_i = \\mathbf{d}_i/\\|\\mathbf{d}_i\\|$，因此所有执行的步长都为单位长度。\n\n假设主体能感知候选移动方向与梯度的方向对齐度（但不能感知其长度），并根据以下原则对选择概率进行建模：在所选邻域的可用邻居方向 $\\{\\mathbf{d}_i\\}$ 中，选择一个方向的概率由最大熵原理决定，该原理受与 $\\hat{\\mathbf{g}}$ 的期望对齐度的约束，并由一个敏感度参数 $\\beta \\ge 0$（无量纲）控制。然后根据指定的步长约定执行所选的移动。方向偏差 $b$ 定义为每个时间步（单位为每个时间步的晶格单元长度）的步位移在 $\\hat{\\mathbf{g}}$ 上的期望投影。形式上，设实际施加的位移为 $\\mathbf{s}_i$，选择概率为 $p_i$，则\n$$\nb = \\sum_i p_i \\, (\\mathbf{s}_i \\cdot \\hat{\\mathbf{g}}).\n$$\n\n您的任务是，根据第一性原理和所述假设，为给定的邻域、敏感度 $\\beta$、步长约定和梯度角 $\\theta$，推导选择概率 $p_i$ 和由此产生的方向偏差 $b$ 的数学显式表达式。然后实现一个程序，为下面的每个测试用例计算 $b$。\n\n物理单位说明：$b$ 以每个时间步的晶格单元长度为单位报告，并四舍五入到六位小数。\n\n角度单位说明：输入角度以弧度为单位指定。\n\n测试套件和参数覆盖范围：\n- 用例 1：邻域 “Moore”，步长约定 “physical”，敏感度 $\\beta = 1$，梯度角 $\\theta = \\pi/4$。\n- 用例 2：邻域 “vonNeumann”，步长约定 “normalized”，敏感度 $\\beta = 10$，梯度角 $\\theta = \\pi/4$。\n- 用例 3：邻域 “Moore”，步长约定 “normalized”，敏感度 $\\beta = 0$，梯度角 $\\theta = \\pi/3$。\n- 用例 4：邻域 “vonNeumann”，步长约定 “physical”，敏感度 $\\beta = 1/2$，梯度角 $\\theta = 0$。\n- 用例 5：邻域 “Moore”，步长约定 “physical”，敏感度 $\\beta = 100$，梯度角 $\\theta = \\arctan(2)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[$result_1,result_2,\\dots$]”），其中每个 $result_i$ 是相应测试用例的方向偏差 $b$，四舍五入到六位小数，并按上述用例的顺序列出。",
            "solution": "该问题要求推导方形晶格上趋化主体的方向偏差 $b$ 的表达式，并为几个测试用例计算其值。解决方案首先从最大熵原理推导选择概率，然后使用这些概率计算期望位移，即方向偏差。\n\n**1. 从最大熵推导选择概率**\n\n问题指出，选择方向 $i$ 的移动的概率 $p_i$ 由最大熵原理（MaxEnt）决定。我们寻求找到在 $N$ 个可用移动上的概率分布 $\\{p_i\\}$，该分布在满足特定约束的条件下，使香农熵 $S = -\\sum_{i=1}^{N} p_i \\ln p_i$ 最大化。\n\n约束条件是：\n1.  **归一化**：概率总和必须为 $1$。\n    $$ \\sum_{i=1}^{N} p_i = 1 $$\n2.  **期望对齐度**：主体的选择受到可能的移动*方向*与梯度向量 $\\hat{\\mathbf{g}}$ 对齐度的影响而有偏差。设第 $i$ 个移动方向的单位向量为 $\\hat{\\mathbf{d}}_i$。对齐度是标量积 $c_i = \\hat{\\mathbf{d}}_i \\cdot \\hat{\\mathbf{g}}$。约束是关于该对齐度的期望值。\n    $$ \\sum_{i=1}^{N} p_i c_i = \\langle c \\rangle $$\n    其中 $\\langle c \\rangle$ 是一个指定的平均对齐度，其值由敏感度参数 $\\beta$ 隐式控制。\n\n我们使用拉格朗日乘子法在这些约束下最大化 $S$。拉格朗日函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(\\{p_i\\}, \\lambda_0, \\beta) = -\\sum_{i=1}^{N} p_i \\ln p_i - \\lambda_0 \\left(\\sum_{i=1}^{N} p_i - 1\\right) - \\beta \\left(\\sum_{i=1}^{N} p_i c_i - \\langle c \\rangle\\right) $$\n此处，$\\lambda_0$ 和 $\\beta$ 是拉格朗日乘子。问题将 $\\beta$ 定义为“敏感度参数”。对于一个表示对吸引性梯度的敏感度的参数，一个更大的正 $\\beta$ 值必须对应于对与梯度对齐的方向有更强的偏好（即更大的 $\\langle c \\rangle$）。我们将确认这一解释。\n\n对 $\\mathcal{L}$ 关于 $p_j$ 求导并令结果为零，得到：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial p_j} = -\\ln p_j - 1 - \\lambda_0 - \\beta c_j = 0 $$\n$$ \\ln p_j = -1 - \\lambda_0 - \\beta c_j \\implies p_j = e^{-1-\\lambda_0} e^{-\\beta c_j} $$\n\n为了找到项 $e^{-1-\\lambda_0}$，我们应用归一化约束：\n$$ \\sum_{j=1}^{N} p_j = e^{-1-\\lambda_0} \\sum_{j=1}^{N} e^{-\\beta c_j} = 1 \\implies e^{-1-\\lambda_0} = \\frac{1}{\\sum_{j=1}^{N} e^{-\\beta c_j}} $$\n分母是配分函数，$Z = \\sum_{j=1}^{N} e^{-\\beta c_j}$。因此，选择移动 $j$ 的概率是：\n$$ p_j = \\frac{e^{-\\beta c_j}}{Z} $$\n这是一个标准的玻尔兹曼-吉布斯分布。期望对齐度为 $\\langle c \\rangle = \\frac{\\partial \\ln Z}{\\partial(-\\beta)}$。为确保 $\\langle c \\rangle$ 随敏感度增加，我们期望 $\\frac{\\partial \\langle c \\rangle}{\\partial \\beta} > 0$。该导数为 $\\frac{\\partial \\langle c \\rangle}{\\partial \\beta} = \\langle c^2 \\rangle - \\langle c \\rangle^2 = \\text{Var}(c) \\ge 0$。如果我们使用乘子 $-\\beta$，那么 $\\frac{\\partial \\langle c \\rangle}{\\partial(-\\beta)} = -\\text{Var}(c) \\le 0$。这将意味着趋化排斥。因此，为了模拟“敏感度”所暗示的吸引作用，拉格朗日乘子应为正，从而得到形式为 $p_j \\propto e^{+\\beta c_j}$ 的分布。正确的公式是：\n$$ p_i = \\frac{e^{\\beta c_i}}{Z}, \\quad \\text{其中} \\quad Z = \\sum_{j=1}^{N} e^{\\beta c_j} $$\n且 $c_i = \\hat{\\mathbf{d}}_i \\cdot \\hat{\\mathbf{g}}$。这就是我们将使用的概率分布。\n\n**2. 定义模型组件**\n\n方向偏差 $b$ 的计算需要为模型的每个组件定义具体的向量。\n*   **梯度向量**：$\\hat{\\mathbf{g}} = (\\cos\\theta, \\sin\\theta)$，其中 $\\theta$ 是与正 $x$ 轴的角度。\n*   **邻域和位移**：设 $N$ 为邻居的数量。\n    *   **Moore 邻域 ($N=8$)**：原始晶格位移集为 $\\{\\mathbf{d}_i^{\\text{Moore}}\\} = \\{(\\pm 1, 0), (0, \\pm 1), (\\pm 1, \\pm 1)\\}$.\n    *   **von Neumann 邻域 ($N=4$)**：原始晶格位移集为 $\\{\\mathbf{d}_i^{\\text{vN}}\\} = \\{(\\pm 1, 0), (0, \\pm 1)\\}$.\n*   **方向向量**：单位方向向量 $\\hat{\\mathbf{d}}_i$ 是通过对原始向量进行归一化得到的：$\\hat{\\mathbf{d}}_i = \\mathbf{d}_i / \\|\\mathbf{d}_i\\|$。对于 von Neumann 移动，$\\|\\mathbf{d}_i\\|=1$，因此 $\\hat{\\mathbf{d}}_i=\\mathbf{d}_i$。对于 Moore 邻域，像 $(1,1)$ 这样的对角线移动长度为 $\\|\\mathbf{d}_i\\|=\\sqrt{2}$，因此对应的方向向量是 $\\hat{\\mathbf{d}}_i=(1/\\sqrt{2}, 1/\\sqrt{2})$。\n*   **步长约定**：实际施加的位移向量 $\\mathbf{s}_i$ 取决于约定。\n    *   **“物理 (physical)”**：步向量是原始晶格向量，$\\mathbf{s}_i = \\mathbf{d}_i$。\n    *   **“归一化 (normalized)”**：步向量是单位方向向量，$\\mathbf{s}_i = \\hat{\\mathbf{d}}_i$。\n\n**3. 方向偏差 $b$ 的公式**\n\n方向偏差 $b$ 定义为步位移向量 $\\mathbf{s}_i$ 在梯度向量 $\\hat{\\mathbf{g}}$ 上的期望投影，并对所有可能的移动进行平均。\n$$ b = \\sum_{i=1}^{N} p_i \\, (\\mathbf{s}_i \\cdot \\hat{\\mathbf{g}}) $$\n使用推导出的概率 $p_i$，$b$ 的完整表达式为：\n$$ b = \\sum_{i=1}^{N} \\left( \\frac{e^{\\beta (\\hat{\\mathbf{d}}_i \\cdot \\hat{\\mathbf{g}})}}{\\sum_{j=1}^{N} e^{\\beta (\\hat{\\mathbf{d}}_j \\cdot \\hat{\\mathbf{g}})}} \\right) (\\mathbf{s}_i \\cdot \\hat{\\mathbf{g}}) $$\n\n**4. 计算算法**\n\n对于任何给定的测试用例（邻域、步长约定、$\\beta$、$\\theta$），$b$ 的计算过程如下：\n\n1.  确定指定邻域的原始位移向量集 $\\{\\mathbf{d}_i\\}$。\n2.  计算相应的单位方向向量集 $\\{\\hat{\\mathbf{d}}_i\\}$。\n3.  根据步长约定确定所施加的步向量集 $\\{\\mathbf{s}_i\\}$。\n4.  构建梯度向量 $\\hat{\\mathbf{g}} = (\\cos\\theta, \\sin\\theta)$。\n5.  计算每次移动 $i$ 的方向对齐度 $c_i = \\hat{\\mathbf{d}}_i \\cdot \\hat{\\mathbf{g}}$。\n6.  计算权重 $w_i = e^{\\beta c_i}$。\n7.  计算配分函数 $Z = \\sum_{i=1}^{N} w_i$。\n8.  确定选择概率 $p_i = w_i / Z$。\n9.  计算每次移动的投影位移 $b_i = \\mathbf{s}_i \\cdot \\hat{\\mathbf{g}}$。\n10. 计算最终方向偏差，即加权和 $b = \\sum_{i=1}^{N} p_i b_i$。\n\n一个特殊情况是 $\\beta=0$。此时，对所有 $i$ 都有 $w_i=e^0=1$，因此 $p_i=1/N$。偏差变为 $b = \\frac{1}{N} \\sum_i (\\mathbf{s}_i \\cdot \\hat{\\mathbf{g}})$。由于 Moore 和 von Neumann 邻域都关于原点对称（即 $\\sum_i \\mathbf{d}_i = \\mathbf{0}$ 和 $\\sum_i \\hat{\\mathbf{d}}_i = \\mathbf{0}$），因此当 $\\beta=0$ 时偏差始终为 $0$，正如测试用例 3 所示。对于 $\\beta > 0$，偏差将为正，表示在梯度方向上存在净漂移。对于非常大的 $\\beta$，概率将集中在具有最高对齐度 $c_i$ 的移动上，$b$ 将接近其最大可能值 $(\\mathbf{s}_{\\text{best}} \\cdot \\hat{\\mathbf{g}})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cell motility problem for the given test suite.\n    \"\"\"\n\n    # Define neighborhood raw displacement vectors\n    neighborhoods_raw = {\n        \"Moore\": np.array([\n            [1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0],\n            [1.0, 1.0], [-1.0, -1.0], [1.0, -1.0], [-1.0, 1.0]\n        ]),\n        \"vonNeumann\": np.array([\n            [1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]\n        ])\n    }\n\n    # Define the test cases from the problem statement.\n    # The format is (neighborhood, step-length convention, sensitivity beta, gradient angle theta).\n    test_cases = [\n        (\"Moore\", \"physical\", 1.0, np.pi / 4),\n        (\"vonNeumann\", \"normalized\", 10.0, np.pi / 4),\n        (\"Moore\", \"normalized\", 0.0, np.pi / 3),\n        (\"vonNeumann\", \"physical\", 0.5, 0.0),\n        (\"Moore\", \"physical\", 100.0, np.arctan(2.0)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        neighborhood_name, convention, beta, theta = case\n\n        # 1. Get raw displacement vectors for the neighborhood\n        d_raw = neighborhoods_raw[neighborhood_name]\n\n        # 2. Calculate unit direction vectors\n        norms = np.linalg.norm(d_raw, axis=1)\n        # Reshape for broadcasting to prevent division errors in logic, although not strictly needed here\n        # as norms are always non-zero.\n        d_unit = d_raw / norms[:, np.newaxis]\n\n        # 3. Determine applied step vectors based on convention\n        if convention == \"physical\":\n            s_vectors = d_raw\n        elif convention == \"normalized\":\n            s_vectors = d_unit\n        else:\n            raise ValueError(f\"Unknown step-length convention: {convention}\")\n\n        # 4. Construct gradient vector\n        g_vector = np.array([np.cos(theta), np.sin(theta)])\n\n        # 5. Calculate directional alignments (c_i = d_hat_i . g_hat)\n        # This is a matrix-vector product where each row of d_unit is a vector\n        alignments = d_unit @ g_vector\n\n        # 6. Calculate choice probabilities (p_i propto exp(beta * c_i))\n        # Handle the beta=0 case explicitly to avoid potential floating point issues,\n        # although np.exp(0) is exactly 1.\n        if beta == 0.0:\n            num_moves = d_raw.shape[0]\n            probabilities = np.full(num_moves, 1.0 / num_moves)\n        else:\n            weights = np.exp(beta * alignments)\n            partition_function = np.sum(weights)\n            probabilities = weights / partition_function\n\n        # 7. Calculate projected displacement for each move (b_i = s_i . g_hat)\n        projected_displacements = s_vectors @ g_vector\n        \n        # 8. Compute final directional bias (b = sum(p_i * b_i))\n        directional_bias = np.sum(probabilities * projected_displacements)\n        \n        results.append(directional_bias)\n\n    # Final print statement in the exact required format.\n    # The results are formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}