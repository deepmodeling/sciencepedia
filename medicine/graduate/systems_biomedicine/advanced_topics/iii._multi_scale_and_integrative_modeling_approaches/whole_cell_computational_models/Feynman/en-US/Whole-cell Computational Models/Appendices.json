{
    "hands_on_practices": [
        {
            "introduction": "Before simulating the complex dynamics of a whole-cell model, it is crucial to understand the fundamental structural properties embedded in its reaction network. Conservation laws, which represent linear combinations of species concentrations that remain constant over time, are key invariants of the system. This practice will equip you to computationally identify these conserved quantities by finding vectors in the left-nullspace of the stoichiometric matrix $S$, a skill that is essential for model verification, simplification, and for understanding the inherent constraints of the biological system you are modeling .",
            "id": "4399280",
            "problem": "Consider a dynamical model of intracellular biochemical species in a whole-cell computational model. Let $m$ denote the number of tracked chemical species and let $n$ denote the number of reactions. The time evolution of the concentration vector $\\mathbf{x}(t) \\in \\mathbb{R}^m$ is governed by the mass-balance Ordinary Differential Equation (ODE)\n$$\n\\frac{d\\mathbf{x}}{dt} = S \\, \\mathbf{v}(t),\n$$\nwhere $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix and $\\mathbf{v}(t) \\in \\mathbb{R}^n$ is the vector of reaction fluxes. A linear conservation relation is any row vector $\\mathbf{l}^\\top \\in \\mathbb{R}^{1 \\times m}$ such that the scalar quantity $\\mathbf{l}^\\top \\mathbf{x}(t)$ is invariant for all time under all admissible reaction fluxes; by the product rule and arbitrariness of $\\mathbf{v}(t)$, this requires\n$$\n\\mathbf{l}^\\top S = \\mathbf{0}^\\top,\n$$\nthat is, $\\mathbf{l}$ lies in the left-nullspace of $S$. A conserved moiety is a conservation relation whose nonzero components align with a single predefined chemical backbone group (for example, the adenylate backbone across adenosine monophosphate, adenosine diphosphate, and adenosine triphosphate) and have equal positive weights on each species in that group; conservation relations that mix multiple groups and/or require unequal weights are general conservation relations.\n\nTask: For each provided stoichiometric matrix, compute a basis for the left-nullspace by finding all vectors $\\mathbf{l}$ satisfying $\\mathbf{l}^\\top S = \\mathbf{0}^\\top$. Then, using the specified moiety groupings (given as sets of zero-based species indices), classify which groups yield conserved moieties by testing the group-indicator vector with equal unit weights on the group’s species. Finally, report for each test case:\n- the total number $k$ of independent conservation relations (the dimension of the left-nullspace),\n- the number $m_c$ of conserved moieties identified using the provided groups,\n- and the number $g_c$ of general conservation relations, computed as $g_c = \\max(0, k - m_c)$.\n\nAll computations are dimensionless; no physical unit conversion is required.\n\nUse the following test suite of stoichiometric matrices and moiety groupings. Species are listed in row order; reaction columns follow the given biochemical interpretation.\n\nTest case $1$ (block-diagonal adenylate and nicotinamide system):\nSpecies order: $[\\mathrm{AMP}, \\mathrm{ADP}, \\mathrm{ATP}, \\mathrm{NAD}, \\mathrm{NADH}]$.\nReactions:\n- $r_1$: $2\\,\\mathrm{ADP} \\rightarrow \\mathrm{AMP} + \\mathrm{ATP}$,\n- $r_2$: $\\mathrm{ATP} \\rightarrow \\mathrm{ADP}$,\n- $r_3$: $\\mathrm{NADH} \\rightarrow \\mathrm{NAD}$.\nStoichiometric matrix:\n$$\nS^{(1)} = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n-2 & 1 & 0 \\\\\n1 & -1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & -1\n\\end{bmatrix}.\n$$\nMoiety groups (zero-based indices): $\\{\\{0,1,2\\}, \\{3,4\\}\\}$.\n\nTest case $2$ (adenylate with inorganic phosphate, including AMP consumption):\nSpecies order: $[\\mathrm{AMP}, \\mathrm{ADP}, \\mathrm{ATP}, \\mathrm{Pi}]$.\nReactions:\n- $r_1$: $2\\,\\mathrm{ADP} \\rightarrow \\mathrm{AMP} + \\mathrm{ATP}$,\n- $r_2$: $\\mathrm{ATP} \\rightarrow \\mathrm{ADP} + \\mathrm{Pi}$,\n- $r_3$: $\\mathrm{AMP} \\rightarrow \\mathrm{Pi} + \\text{external}$.\nStoichiometric matrix:\n$$\nS^{(2)} = \\begin{bmatrix}\n1 & 0 & -1 \\\\\n-2 & 1 & 0 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & 1\n\\end{bmatrix}.\n$$\nMoiety groups (zero-based indices): $\\{\\{0,1,2\\}, \\{3\\}\\}$.\n\nTest case $3$ (full-rank exchange with environment; no internal conservation):\nSpecies order: $[X, Y, Z]$.\nReactions:\n- $r_1$: $X \\rightarrow \\text{external}$,\n- $r_2$: $Y \\rightarrow \\text{external}$,\n- $r_3$: $Z \\rightarrow \\text{external}$.\nStoichiometric matrix:\n$$\nS^{(3)} = \\begin{bmatrix}\n-1 & 0 & 0 \\\\\n0 & -1 & 0 \\\\\n0 & 0 & -1\n\\end{bmatrix}.\n$$\nMoiety groups (zero-based indices): $\\{\\{0,1,2\\}\\}$.\n\nAlgorithmic requirements:\n- Compute a basis for the nullspace of $(S^{(i)})^\\top$ for each test case $i \\in \\{1,2,3\\}$, and set $k$ equal to the basis dimension.\n- For each provided moiety group $G$, form the indicator vector $\\mathbf{l}_G \\in \\mathbb{R}^m$ with $(\\mathbf{l}_G)_j = 1$ for $j \\in G$ and $(\\mathbf{l}_G)_j = 0$ for $j \\notin G$. Classify $G$ as a conserved moiety if $\\mathbf{l}_G^\\top S^{(i)} = \\mathbf{0}^\\top$.\n- Set $m_c$ equal to the count of groups $G$ classified as conserved moieties, and set $g_c = \\max(0, k - m_c)$.\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list $[k, m_c, g_c]$ for the corresponding test case in order $1,2,3$. For example, the output must be of the form\n$[ [k_1, m_{c,1}, g_{c,1}], [k_2, m_{c,2}, g_{c,2}], [k_3, m_{c,3}, g_{c,3}] ]$,\nwith all entries being integers.",
            "solution": "The problem requires an analysis of conservation laws in biochemical reaction networks, a fundamental concept in systems biology and whole-cell modeling. The time evolution of species concentrations, $\\mathbf{x}(t)$, is described by the ordinary differential equation $\\frac{d\\mathbf{x}}{dt} = S \\mathbf{v}(t)$, where $S$ is the stoichiometric matrix and $\\mathbf{v}(t)$ is the vector of reaction fluxes.\n\nA linear conservation relation is a linear combination of species concentrations, $\\mathbf{l}^\\top \\mathbf{x}(t)$, that remains constant over time. For this quantity to be invariant, its time derivative must be zero:\n$$\n\\frac{d}{dt} (\\mathbf{l}^\\top \\mathbf{x}(t)) = \\mathbf{l}^\\top \\frac{d\\mathbf{x}}{dt} = \\mathbf{l}^\\top (S \\mathbf{v}(t)) = (\\mathbf{l}^\\top S) \\mathbf{v}(t) = 0\n$$\nSince this must hold for any arbitrary vector of reaction fluxes $\\mathbf{v}(t)$, it necessitates that the vector $\\mathbf{l}^\\top S$ be the zero vector, $\\mathbf{0}^\\top$. This condition, $\\mathbf{l}^\\top S = \\mathbf{0}^\\top$, defines $\\mathbf{l}$ as a vector in the left-nullspace of the stoichiometric matrix $S$. The set of all such vectors $\\mathbf{l}$ forms a vector space, and the dimension of this space, denoted by $k$, corresponds to the number of linearly independent conservation relations in the system. Computationally, the left-nullspace of $S$ is equivalent to the nullspace of its transpose, $S^\\top$.\n\nThe problem distinguishes between two types of conservation relations:\n$1$. **Conserved Moieties**: These are specific, simple conservation relations where the vector $\\mathbf{l}$ acts as an indicator vector for a predefined group of species. Specifically, for a given moiety group $G$, the corresponding vector $\\mathbf{l}_G$ has components equal to $1$ for species within the group and $0$ otherwise. A group $G$ represents a conserved moiety if its indicator vector $\\mathbf{l}_G$ is in the left-nullspace of $S$ (i.e., $\\mathbf{l}_G^\\top S = \\mathbf{0}^\\top$). The number of such groups is denoted by $m_c$.\n$2$. **General Conservation Relations**: These are any conservation relations that are not accounted for by the predefined conserved moieties. They might involve unequal weighting of species or the mixing of different chemical groups. The number of such relations, $g_c$, is determined by the difference between the total number of independent conservation relations, $k$, and the number of identified conserved moieties, $m_c$, given by $g_c = \\max(0, k - m_c)$.\n\nThe solution proceeds by analyzing each test case according to these principles.\n\n**Test Case 1**:\nThe stoichiometric matrix is given by:\n$$\nS^{(1)} = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n-2 & 1 & 0 \\\\\n1 & -1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & -1\n\\end{bmatrix}\n$$\nThe number of species is $m=5$. To find the conservation laws, we compute a basis for the nullspace of $(S^{(1)})^\\top$:\n$$\n(S^{(1)})^\\top = \\begin{bmatrix}\n1 & -2 & 1 & 0 & 0 \\\\\n0 & 1 & -1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & -1\n\\end{bmatrix}\n$$\nSolving $(S^{(1)})^\\top \\mathbf{l} = \\mathbf{0}$ for $\\mathbf{l} = [l_1, l_2, l_3, l_4, l_5]^\\top$ yields the equations $l_1 - 2l_2 + l_3 = 0$, $l_2 - l_3 = 0$, and $l_4 - l_5 = 0$. These simplify to $l_1 = l_2 = l_3$ and $l_4 = l_5$. The solution space is spanned by two linearly independent vectors, for example $[1, 1, 1, 0, 0]^\\top$ and $[0, 0, 0, 1, 1]^\\top$. Therefore, the dimension of the left-nullspace is $k_1 = 2$.\n\nNext, we test the provided moiety groups: $\\{\\{0, 1, 2\\}, \\{3, 4\\}\\}$.\n- For group $G_1 = \\{0, 1, 2\\}$, the indicator vector is $\\mathbf{l}_{G_1} = [1, 1, 1, 0, 0]^\\top$. We check if $\\mathbf{l}_{G_1}^\\top S^{(1)} = \\mathbf{0}^\\top$:\n$$\n[1, 1, 1, 0, 0] \\begin{bmatrix} 1 & 0 & 0 \\\\ -2 & 1 & 0 \\\\ 1 & -1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & -1 \\end{bmatrix} = [1-2+1, 1-1, 0] = [0, 0, 0]\n$$\nThis condition holds, so this is a conserved moiety.\n- For group $G_2 = \\{3, 4\\}$, the indicator vector is $\\mathbf{l}_{G_2} = [0, 0, 0, 1, 1]^\\top$. We check if $\\mathbf{l}_{G_2}^\\top S^{(1)} = \\mathbf{0}^\\top$:\n$$\n[0, 0, 0, 1, 1] \\begin{bmatrix} 1 & 0 & 0 \\\\ -2 & 1 & 0 \\\\ 1 & -1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & -1 \\end{bmatrix} = [0, 0, 1-1] = [0, 0, 0]\n$$\nThis also holds. Thus, we have identified $m_{c,1} = 2$ conserved moieties.\nFinally, the number of general conservation relations is $g_{c,1} = \\max(0, k_1 - m_{c,1}) = \\max(0, 2 - 2) = 0$.\nThe result for this case is $[2, 2, 0]$.\n\n**Test Case 2**:\nThe stoichiometric matrix is:\n$$\nS^{(2)} = \\begin{bmatrix}\n1 & 0 & -1 \\\\\n-2 & 1 & 0 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & 1\n\\end{bmatrix}\n$$\nThe number of species is $m=4$. We find the nullspace of $(S^{(2)})^\\top$:\n$$\n(S^{(2)})^\\top = \\begin{bmatrix}\n1 & -2 & 1 & 0 \\\\\n0 & 1 & -1 & 1 \\\\\n-1 & 0 & 0 & 1\n\\end{bmatrix}\n$$\nSolving $(S^{(2)})^\\top \\mathbf{l} = \\mathbf{0}$ yields a one-dimensional nullspace spanned by the vector $[1, 2, 3, 1]^\\top$. Thus, the total number of independent conservation relations is $k_2 = 1$. This vector represents the conservation of phosphate groups across AMP (1P), ADP (2P), ATP (3P), and inorganic phosphate Pi (1P).\n\nThe moiety groups to test are $\\{\\{0, 1, 2\\}, \\{3\\}\\}$.\n- For group $G_1 = \\{0, 1, 2\\}$, the indicator vector is $\\mathbf{l}_{G_1} = [1, 1, 1, 0]^\\top$. We check the condition:\n$$\n[1, 1, 1, 0] \\begin{bmatrix} 1 & 0 & -1 \\\\ -2 & 1 & 0 \\\\ 1 & -1 & 0 \\\\ 0 & 1 & 1 \\end{bmatrix} = [1-2+1, 1-1, -1] = [0, 0, -1] \\neq [0, 0, 0]\n$$\n- For group $G_2 = \\{3\\}$, the indicator vector is $\\mathbf{l}_{G_2} = [0, 0, 0, 1]^\\top$:\n$$\n[0, 0, 0, 1] \\begin{bmatrix} 1 & 0 & -1 \\\\ -2 & 1 & 0 \\\\ 1 & -1 & 0 \\\\ 0 & 1 & 1 \\end{bmatrix} = [0, 1, 1] \\neq [0, 0, 0]\n$$\nNeither group yields a conserved moiety, so $m_{c,2} = 0$.\nThe number of general conservation relations is $g_{c,2} = \\max(0, k_2 - m_{c,2}) = \\max(0, 1 - 0) = 1$. The single conservation law found, $[1, 2, 3, 1]^\\top$, involves unequal weights and is thus a general conservation relation.\nThe result for this case is $[1, 0, 1]$.\n\n**Test Case 3**:\nThe stoichiometric matrix is:\n$$\nS^{(3)} = \\begin{bmatrix}\n-1 & 0 & 0 \\\\\n0 & -1 & 0 \\\\\n0 & 0 & -1\n\\end{bmatrix} = -I_3\n$$\nThe number of species is $m=3$. $S^{(3)}$ is a full-rank square matrix. Its transpose, $(S^{(3)})^\\top = -I_3$, is also full-rank. The nullspace of a full-rank matrix contains only the zero vector. Therefore, the dimension of the left-nullspace is $k_3 = 0$. There are no non-trivial conservation relations in this system.\n\nWith $k_3=0$, it is impossible to find any conserved moieties. The number of identified conserved moieties must be $m_{c,3} = 0$.\nThe number of general conservation relations is $g_{c,3} = \\max(0, k_3 - m_{c,3}) = \\max(0, 0 - 0) = 0$.\nThe result for this case is $[0, 0, 0]$.\n\nThe final output is an aggregation of these three results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Computes conservation relations for given biochemical systems.\n\n    For each test case, the function calculates:\n    - k: The total number of independent conservation relations (dimension of the left-nullspace).\n    - m_c: The number of conserved moieties from a given list of species groups.\n    - g_c: The number of general conservation relations.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"S\": np.array([\n                [1, 0, 0],\n                [-2, 1, 0],\n                [1, -1, 0],\n                [0, 0, 1],\n                [0, 0, -1]\n            ]),\n            \"groups\": [[0, 1, 2], [3, 4]]\n        },\n        {\n            \"S\": np.array([\n                [1, 0, -1],\n                [-2, 1, 0],\n                [1, -1, 0],\n                [0, 1, 1]\n            ]),\n            \"groups\": [[0, 1, 2], [3]]\n        },\n        {\n            \"S\": np.array([\n                [-1, 0, 0],\n                [0, -1, 0],\n                [0, 0, -1]\n            ]),\n            \"groups\": [[0, 1, 2]]\n        }\n    ]\n\n    results = []\n    # A small tolerance for floating-point comparisons\n    tolerance = 1e-9\n\n    for case in test_cases:\n        S = case[\"S\"]\n        groups = case[\"groups\"]\n        num_species = S.shape[0]\n\n        # Step 1: Compute a basis for the left-nullspace of S and find its dimension, k.\n        # The left-nullspace of S is the nullspace of S.T.\n        # The columns of `ns` form an orthonormal basis for the nullspace.\n        ns_basis = null_space(S.T)\n        k = ns_basis.shape[1]\n\n        # Step 2: Test each moiety group to count the number of conserved moieties, m_c.\n        m_c = 0\n        for group in groups:\n            # Form the indicator vector l_G for the group.\n            l_G = np.zeros(num_species)\n            l_G[group] = 1.0\n            \n            # Check if l_G is in the left-nullspace, i.e., l_G^T @ S = 0.\n            product = l_G.T @ S\n            if np.allclose(product, np.zeros_like(product), atol=tolerance):\n                # The group corresponds to a conserved moiety.\n                m_c += 1\n\n        # Step 3: Compute the number of general conservation relations, g_c.\n        g_c = max(0, k - m_c)\n\n        results.append(f\"[{k},{m_c},{g_c}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Simulating the time-evolution of a whole-cell model, described by a system of ordinary differential equations, often presents significant numerical challenges. A primary difficulty is \"stiffness,\" which arises when different processes, such as metabolic reactions and gene expression, occur on vastly different timescales. This exercise demonstrates how to diagnose stiffness by analyzing the eigenvalues of the system's Jacobian matrix, $J(x)$, providing a clear justification for why specialized implicit solvers are indispensable tools in computational systems biology .",
            "id": "4399346",
            "problem": "Consider a whole-cell metabolic subsystem modeled as an ordinary differential equation (ODE) system based on mass action kinetics. Let $x \\in \\mathbb{R}^n$ denote the vector of species concentrations, $S \\in \\mathbb{R}^{n \\times r}$ the stoichiometric matrix, and $v(x) \\in \\mathbb{R}^r$ the vector of reaction rates. The dynamics are given by the mass balance law and mass action kinetics: \n$$\n\\frac{dx}{dt} = f(x) = S \\, v(x),\n$$\nwhere for each reaction $j \\in \\{1, \\dots, r\\}$, \n$$\nv_j(x) = k_j \\prod_{i=1}^{n} x_i^{\\nu_{ij}},\n$$ \nwith $k_j > 0$ the rate constant and $\\nu_{ij} \\in \\mathbb{N}_0$ the stoichiometric order (reactant molecularity) of species $i$ in reaction $j$. Define the Jacobian matrix \n$$\nJ(x) = \\frac{\\partial f}{\\partial x}(x) \\in \\mathbb{R}^{n \\times n}.\n$$\nStiffness in such ODE systems can be analyzed by examining the eigenvalues $\\{\\lambda_i\\}_{i=1}^n$ of $J(x)$ at a given state $x$, particularly when the magnitudes $\\{|\\lambda_i|\\}$ span multiple orders of magnitude. This spread forces explicit methods to take very small steps for stability, while implicit methods can remain stable at much larger steps, providing computational advantages in whole-cell models with fast and slow subsystems.\n\nYour task is to derive from first principles how to compute the Jacobian matrix $J(x)$ for mass action kinetics, compute its eigenvalues at specified states, and then quantify stiffness by the ratio \n$$\nR = \\frac{\\max_i |\\lambda_i|}{\\min_{i:\\,|\\lambda_i| > \\varepsilon} |\\lambda_i|},\n$$\nexcluding near-zero eigenvalues using a tolerance $\\varepsilon = 10^{-12}$. Also compute the order-of-magnitude spread \n$$\nM = \\log_{10}(R),\n$$\nand classify the system as stiff if $M \\ge 3$, otherwise non-stiff. Output, for each test case, the list $[R, M, \\text{flag}]$ where $\\text{flag}$ is $1$ for stiff and $0$ for non-stiff. If fewer than two eigenvalues satisfy $|\\lambda_i| > \\varepsilon$, define $R = 1$ and $M = 0$, and set $\\text{flag} = 0$. Angles are not involved. No physical units are required in the output since the metrics are dimensionless.\n\nUse the following test suite of four cases that cover a general case, a highly stiff case, a nonlinear molecularity case with state-dependent Jacobian, and a near-threshold case. All matrices and vectors are specified with entries as follows.\n\nCase $1$ (three-species cycle, first-order rates, similar timescales):\n$$\nS_1 = \\begin{bmatrix}\n-1 & 0 & 1 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix},\\quad\n\\nu_1 = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix},\\quad\nk_1 = \\begin{bmatrix} 0.8 \\\\ 1.0 \\\\ 1.2 \\end{bmatrix},\\quad\nx_1 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}.\n$$\n\nCase $2$ (three-species cycle, first-order rates, widely separated timescales):\n$$\nS_2 = \\begin{bmatrix}\n-1 & 0 & 1 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix},\\quad\n\\nu_2 = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix},\\quad\nk_2 = \\begin{bmatrix} 10^{-3} \\\\ 1.0 \\\\ 10^{3} \\end{bmatrix},\\quad\nx_2 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}.\n$$\n\nCase $3$ (nonlinear molecularity with dimerization, state-dependent Jacobian):\n$$\nS_3 = \\begin{bmatrix}\n-2 & 0 & 1 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix},\\quad\n\\nu_3 = \\begin{bmatrix}\n2 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix},\\quad\nk_3 = \\begin{bmatrix} 5.0 \\\\ 0.1 \\\\ 0.01 \\end{bmatrix},\\quad\nx_3 = \\begin{bmatrix} 100.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}.\n$$\n\nCase $4$ (near-threshold stiffness, first-order rates):\n$$\nS_4 = \\begin{bmatrix}\n-1 & 0 & 1 \\\\\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix},\\quad\n\\nu_4 = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix},\\quad\nk_4 = \\begin{bmatrix} 10^{-2} \\\\ 1.0 \\\\ 10 \\end{bmatrix},\\quad\nx_4 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}.\n$$\n\nImplement a program that, for each case, constructs $J(x)$ from $S$, $\\nu$, $k$, and $x$, computes the eigenvalues of $J(x)$, computes $R$, $M$, and the stiffness flag, and outputs a single line containing a list of the four per-case results as a comma-separated list enclosed in square brackets, where each per-case result is the list $[R, M, \\text{flag}]$. For example, the output format must be \n$$\n\\text{[ [r\\_1,m\\_1,f\\_1], [r\\_2,m\\_2,f\\_2], [r\\_3,m\\_3,f\\_3], [r\\_4,m\\_4,f\\_4] ]}.\n$$\nNo input should be read from the user, and no files should be accessed. Use the tolerance $\\varepsilon = 10^{-12}$ to exclude near-zero eigenvalues when computing $\\min |\\lambda_i|$.",
            "solution": "The user-provided problem has been validated and is determined to be a valid, well-posed scientific problem. The following is the complete, reasoned solution.\n\nThe objective is to derive an expression for the Jacobian matrix $J(x)$ of a metabolic subsystem governed by mass action kinetics, and then to use it to quantify system stiffness for several test cases.\n\nThe system dynamics are described by the ordinary differential equation (ODE):\n$$\n\\frac{dx}{dt} = f(x) = S \\, v(x)\n$$\nwhere $x \\in \\mathbb{R}^n$ is the vector of species concentrations, $S \\in \\mathbb{R}^{n \\times r}$ is the stoichiometric matrix, and $v(x) \\in \\mathbb{R}^r$ is the vector of reaction rates. For a system with $n$ species and $r$ reactions, the dynamics for the $i$-th species concentration, $x_i$, are given by:\n$$\nf_i(x) = \\frac{dx_i}{dt} = \\sum_{j=1}^{r} S_{ij} v_j(x)\n$$\nHere, $S_{ij}$ represents the stoichiometric coefficient of species $i$ in reaction $j$. The reaction rates $v_j(x)$ are defined by the law of mass action:\n$$\nv_j(x) = k_j \\prod_{l=1}^{n} x_l^{\\nu_{lj}}\n$$\nwhere $k_j > 0$ is the rate constant for reaction $j$, and $\\nu_{lj} \\in \\mathbb{N}_0$ is the molecularity of species $l$ acting as a reactant in reaction $j$.\n\nThe Jacobian matrix $J(x)$ is an $n \\times n$ matrix whose elements $J_{ik}(x)$ are the partial derivatives of the rate of change of the $i$-th species with respect to the concentration of the $k$-th species:\n$$\nJ_{ik}(x) = \\frac{\\partial f_i}{\\partial x_k}(x)\n$$\nSubstituting the expression for $f_i(x)$, we have:\n$$\nJ_{ik}(x) = \\frac{\\partial}{\\partial x_k} \\left( \\sum_{j=1}^{r} S_{ij} v_j(x) \\right)\n$$\nSince differentiation is a linear operation, we can interchange the derivative and the summation:\n$$\nJ_{ik}(x) = \\sum_{j=1}^{r} S_{ij} \\frac{\\partial v_j(x)}{\\partial x_k}\n$$\nNext, we must compute the partial derivative of the reaction rate $v_j(x)$ with respect to a species concentration $x_k$:\n$$\n\\frac{\\partial v_j(x)}{\\partial x_k} = \\frac{\\partial}{\\partial x_k} \\left( k_j \\prod_{l=1}^{n} x_l^{\\nu_{lj}} \\right)\n$$\nUsing the product rule for differentiation, the derivative is non-zero only for the term corresponding to $l=k$:\n$$\n\\frac{\\partial v_j(x)}{\\partial x_k} = k_j \\left( \\prod_{l \\neq k} x_l^{\\nu_{lj}} \\right) \\frac{\\partial}{\\partial x_k} (x_k^{\\nu_{kj}}) = k_j \\left( \\prod_{l \\neq k} x_l^{\\nu_{lj}} \\right) (\\nu_{kj} x_k^{\\nu_{kj}-1})\n$$\nIf $\\nu_{kj} = 0$, the derivative is $0$. If $\\nu_{kj} > 0$ and $x_k > 0$, we can rearrange this expression by multiplying and dividing by $x_k$:\n$$\n\\frac{\\partial v_j(x)}{\\partial x_k} = \\nu_{kj} \\frac{1}{x_k} \\left( k_j \\left( \\prod_{l \\neq k} x_l^{\\nu_{lj}} \\right) x_k^{\\nu_{kj}} \\right) = \\frac{\\nu_{kj}}{x_k} \\left( k_j \\prod_{l=1}^{n} x_l^{\\nu_{lj}} \\right)\n$$\nThis simplifies to a compact and elegant form:\n$$\n\\frac{\\partial v_j(x)}{\\partial x_k} = \\frac{\\nu_{kj} v_j(x)}{x_k}\n$$\nThis form is valid for the provided test cases, as all specified concentrations $x_k$ are strictly positive.\n\nSubstituting this back into the expression for the Jacobian element $J_{ik}(x)$:\n$$\nJ_{ik}(x) = \\sum_{j=1}^{r} S_{ij} \\frac{\\nu_{kj} v_j(x)}{x_k}\n$$\nThis expression can be formulated in matrix notation. Let us define a matrix $N(x) \\in \\mathbb{R}^{r \\times n}$ whose elements are $N_{jk}(x) = \\frac{\\partial v_j(x)}{\\partial x_k} = \\frac{\\nu_{kj} v_j(x)}{x_k}$. Then the Jacobian matrix $J(x)$ is the product of the stoichiometric matrix $S$ and the matrix $N(x)$:\n$$\nJ(x) = S \\cdot N(x)\n$$\nThe computational procedure for each test case is as follows:\n1.  Given the parameters $S \\in \\mathbb{R}^{n \\times r}$, $\\nu \\in \\mathbb{R}^{n \\times r}$, $k \\in \\mathbb{R}^{r}$, and $x \\in \\mathbb{R}^{n}$.\n2.  Calculate the reaction rate vector $v(x) \\in \\mathbb{R}^r$, where each element $v_j(x)$ is computed as $v_j(x) = k_j \\prod_{i=1}^{n} x_i^{\\nu_{ij}}$.\n3.  Construct the matrix $N(x) \\in \\mathbb{R}^{r \\times n}$ with elements $N_{jk}(x) = (\\nu_{kj}/x_k) v_j(x)$.\n4.  Compute the Jacobian matrix $J(x) \\in \\mathbb{R}^{n \\times n}$ via the matrix product $J(x) = S N(x)$.\n5.  Calculate the eigenvalues $\\{\\lambda_i\\}_{i=1}^n$ of $J(x)$.\n6.  Compute the set of eigenvalue magnitudes, $\\{|\\lambda_i|\\}$.\n7.  Filter this set to retain only magnitudes greater than the tolerance $\\varepsilon = 10^{-12}$. Let this filtered set of magnitudes be $\\Lambda_{filtered}$.\n8.  If the number of elements in $\\Lambda_{filtered}$ is less than two, set the stiffness ratio $R=1.0$, the logarithmic spread $M=0.0$, and the stiffness flag to $0$.\n9.  Otherwise, compute $R = \\frac{\\max_i |\\lambda_i|}{\\min(|\\Lambda_{filtered}|)}$.\n10. Compute the order-of-magnitude spread $M = \\log_{10}(R)$.\n11. Determine the stiffness flag: $1$ if $M \\geq 3$, and $0$ otherwise.\n12. The final result for the case is the list $[R, M, \\text{flag}]$.\n\nThis procedure is applied to each of the four test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating stiffness metrics for several\n    biochemical reaction networks modeled by ODEs.\n    \"\"\"\n    epsilon = 1e-12\n    stiffness_threshold = 3.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (three-species cycle, first-order rates, similar timescales)\n        (\n            np.array([[-1, 0, 1], [1, -1, 0], [0, 1, -1]]),  # S1\n            np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),      # nu1\n            np.array([0.8, 1.0, 1.2]),                       # k1\n            np.array([1.0, 1.0, 1.0])                        # x1\n        ),\n        # Case 2 (three-species cycle, first-order rates, widely separated timescales)\n        (\n            np.array([[-1, 0, 1], [1, -1, 0], [0, 1, -1]]),  # S2\n            np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),      # nu2\n            np.array([1e-3, 1.0, 1e3]),                      # k2\n            np.array([1.0, 1.0, 1.0])                        # x2\n        ),\n        # Case 3 (nonlinear molecularity with dimerization, state-dependent Jacobian)\n        (\n            np.array([[-2, 0, 1], [1, -1, 0], [0, 1, -1]]),  # S3\n            np.array([[2, 0, 0], [0, 1, 0], [0, 0, 1]]),      # nu3\n            np.array([5.0, 0.1, 0.01]),                      # k3\n            np.array([100.0, 1.0, 1.0])                      # x3\n        ),\n        # Case 4 (near-threshold stiffness, first-order rates)\n        (\n            np.array([[-1, 0, 1], [1, -1, 0], [0, 1, -1]]),  # S4\n            np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),      # nu4\n            np.array([1e-2, 1.0, 10.0]),                     # k4\n            np.array([1.0, 1.0, 1.0])                        # x4\n        )\n    ]\n\n    results = []\n    for S, nu, k, x in test_cases:\n        n = S.shape[0]  # Number of species\n        r = S.shape[1]  # Number of reactions\n\n        # Step 1: Compute the reaction rate vector v(x)\n        v = np.zeros(r)\n        for j in range(r):\n            # v_j = k_j * product(x_i ^ nu_ij for i=1..n)\n            v[j] = k[j] * np.prod(x ** nu[:, j])\n\n        # Step 2: Compute the matrix N(x) of partial derivatives of rates\n        # N_jk = (nu_kj / x_k) * v_j\n        N = np.zeros((r, n))\n        for j in range(r):\n            for k_idx in range(n):\n                if x[k_idx] > 0:  # Avoid division by zero\n                    N[j, k_idx] = (nu[k_idx, j] / x[k_idx]) * v[j]\n                # If x_k is zero, derivative is zero unless nu_kj=1, which is not handled here\n                # but not needed for the given test cases.\n\n        # Step 3: Compute the Jacobian matrix J(x) = S @ N(x)\n        J = S @ N\n\n        # Step 4: Compute the eigenvalues of J(x)\n        eigenvalues = np.linalg.eigvals(J)\n\n        # Step 5: Compute eigenvalue magnitudes and filter\n        abs_eigenvalues = np.abs(eigenvalues)\n        filtered_eigenvalues = abs_eigenvalues[abs_eigenvalues > epsilon]\n        \n        R, M, flag = 0.0, 0.0, 0\n        \n        # Step 6: Handle special case and compute stiffness metrics\n        if filtered_eigenvalues.size  2:\n            R = 1.0\n            M = 0.0\n            flag = 0\n        else:\n            max_lambda = np.max(abs_eigenvalues)\n            min_lambda_filtered = np.min(filtered_eigenvalues)\n            \n            if min_lambda_filtered > 0:\n                R = max_lambda / min_lambda_filtered\n                M = np.log10(R)\n                flag = 1 if M >= stiffness_threshold else 0\n            else: # Should not happen due to filtering\n                R = 1.0\n                M = 0.0\n                flag = 0\n\n        results.append([R, M, flag])\n\n    # Final print statement in the exact required format.\n    # The str() for a list includes spaces, which we remove for consistency.\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A predictive computational model is only as good as its parameters, but a critical question is whether these parameters can be uniquely determined from experimental data. This leads to the concept of parameter identifiability, which distinguishes between a model's theoretical capacity to be identified (structural identifiability) and the practical ability to do so with a given dataset (practical identifiability). This practice provides a rigorous method to diagnose practical nonidentifiability by analyzing the system's sensitivity to parameter changes via the Fisher Information Matrix, a critical step that should precede any attempt at model fitting or calibration .",
            "id": "4399328",
            "problem": "You are tasked with formalizing and implementing an identifiability diagnostic for a gene regulation module used within whole-cell computational models. Begin by providing formal definitions of structural identifiability and practical identifiability grounded in the context of dynamical systems and statistical inference. Then, starting from the assumptions and core definitions listed below, derive a computable test for diagnosing nonidentifiable parameters using the Fisher Information Matrix.\n\nFundamental base:\n- Consider a single-gene regulation module with messenger ribonucleic acid (mRNA) concentration $m(t)$ governed by an ordinary differential equation driven by an external transcription factor input $u(t)$. The dynamics are given by a Hill-type production and first-order degradation:\n$$\n\\frac{dm}{dt} = \\alpha \\, h(u(t); K, n) - \\delta \\, m(t),\n$$\nwhere $\\alpha$ is the maximal transcription rate, $\\delta$ is the degradation rate constant, $K$ is the half-saturation constant, and $n$ is the Hill coefficient. The Hill function is\n$$\nh(u; K, n) = \\frac{\\left(\\frac{u}{K}\\right)^n}{1 + \\left(\\frac{u}{K}\\right)^n}.\n$$\n- The measurement model is additive Gaussian noise: observed mRNA at discrete times $t_i$ satisfies\n$$\ny_i = m(t_i; \\theta) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2),\n$$\nwith parameter vector $\\theta = [\\alpha, \\delta, K]^T$ and known noise variance $\\sigma^2$.\n- You must derive and use the continuous-time sensitivity equations for the state and parameter sensitivities, and connect these to a Fisher Information Matrix constructed under the Gaussian measurement model. You may assume the initial mRNA concentration $m(0)$ is known and independent of the parameters.\n\nYour program must implement the following:\n1. Solve simultaneously for $m(t)$ and its parameter sensitivities $S_\\alpha(t) = \\frac{\\partial m}{\\partial \\alpha}$, $S_\\delta(t) = \\frac{\\partial m}{\\partial \\delta}$, and $S_K(t) = \\frac{\\partial m}{\\partial K}$ using the sensitivity ordinary differential equations derived from the chain rule and the Jacobian of the right-hand side with respect to the state and parameters. Use the fact that if $m(0)$ does not depend on $\\theta$, then $S_\\alpha(0) = S_\\delta(0) = S_K(0) = 0$.\n2. Construct a sensitivity matrix $J$ at the observation times with entries formed from scaled (dimensionless) sensitivities with respect to log-parameters, i.e.,\n$$\n\\tilde{S}_\\alpha(t_i) = \\alpha \\, S_\\alpha(t_i), \\quad \\tilde{S}_\\delta(t_i) = \\delta \\, S_\\delta(t_i), \\quad \\tilde{S}_K(t_i) = K \\, S_K(t_i),\n$$\nand assemble $J \\in \\mathbb{R}^{N \\times 3}$ with $N$ observation times as $J_{i,1} = \\tilde{S}_\\alpha(t_i)/\\sigma$, $J_{i,2} = \\tilde{S}_\\delta(t_i)/\\sigma$, $J_{i,3} = \\tilde{S}_K(t_i)/\\sigma$.\n3. Form the Fisher Information Matrix $F = J^T J$ and use its numerical rank to diagnose nonidentifiability. To attribute nonidentifiability to specific parameters, use a rank-revealing factorization of $J$ with column pivoting to determine which parameter columns are linearly independent. A parameter whose column is not selected among the first $r$ pivot columns, where $r$ is the numerical rank of $J$, must be reported as nonidentifiable under the given design.\n4. Produce the final output as a list of boolean triples indicating parameter identifiability status $[\\text{is}\\_\\alpha, \\text{is}\\_\\delta, \\text{is}\\_K]$ for each test case. A parameter is identifiable if its column is among the linearly independent set determined by the pivoted factorization; otherwise, it is nonidentifiable. Use a strict numerical tolerance for deciding rank based on the diagonal entries of the upper-triangular factor (you must implement and document a reasonable tolerance choice).\n\nScientific setup and parameter values:\n- Time variable $t$ is in seconds. Use $m(0) = 10$ in molecules (answer does not require units, but the model must be physically consistent).\n- Use $n = 2$ fixed and known.\n- Use the nominal parameter vector $\\theta = [\\alpha, \\delta, K]^T$ with $\\alpha = 5$ in molecules per second, $\\delta = 0.2$ in inverse seconds, and $K = 50$ in molecules.\n- Use Gaussian noise with $\\sigma = 0.5$ (i.e., $\\sigma^2 = 0.25$).\n- Observation times are uniform at integer seconds from $t = 0$ to $t = 60$, inclusive; that is, $N = 61$ samples.\n\nTest suite:\nImplement three distinct input designs $u(t)$ and evaluate identifiability for each:\n- Case $1$ (informative, multi-step input): \n$$\nu(t) = \\begin{cases}\n10  \\text{for } 0 \\le t  20, \\\\\n100  \\text{for } 20 \\le t  40, \\\\\n50  \\text{for } t \\ge 40.\n\\end{cases}\n$$\nExpected behavior: all parameters should be identifiable.\n- Case $2$ (saturation input): \n$$\nu(t) = 2000 \\quad \\text{for all } t.\n$$\nExpected behavior: the half-saturation constant $K$ should be nonidentifiable due to near-constant saturation of the Hill function; $\\alpha$ and $\\delta$ should be identifiable.\n- Case $3$ (zero input): \n$$\nu(t) = 0 \\quad \\text{for all } t.\n$$\nExpected behavior: the production pathway is inactive, and $\\alpha$ and $K$ should be nonidentifiable; $\\delta$ should be identifiable from the decay dynamics.\n\nAngle units do not apply. There is no requirement to express the answer in physical units. All computations must be dimensionally consistent internally.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of three booleans in the order $[\\text{is}\\_\\alpha, \\text{is}\\_\\delta, \\text{is}\\_K]$ for Cases $1$, $2$, and $3$, respectively. For example: \n$$\n\\text{print one line: } [[\\text{True},\\text{True},\\text{True}],[\\text{True},\\text{True},\\text{False}],[\\text{False},\\text{True},\\text{False}]].\n$$",
            "solution": "The problem requires the formalization and implementation of a parameter identifiability diagnostic for a single-gene regulation model. This task involves a multi-step process, beginning with theoretical definitions and derivations, followed by a numerical implementation to test specific experimental designs.\n\nFirst, we must establish formal definitions for parameter identifiability within the context of dynamical systems described by ordinary differential equations (ODEs).\n\n**1. Formal Definitions of Identifiability**\n\nA parameter $\\theta_j$ in a model with parameters $\\theta$ is **structurally identifiable** if its value can be uniquely determined from perfect, noise-free observations of the system's output over time, given a sufficiently exciting input. More formally, let the noise-free model output be $m(t; \\theta)$. The parameter vector $\\theta$ is structurally identifiable if for any two parameter vectors $\\theta_1 \\ne \\theta_2$, the corresponding outputs are distinct, i.e., $m(t; \\theta_1) \\ne m(t; \\theta_2)$ for some $t > 0$. A single parameter $\\theta_j$ is structurally identifiable if $m(t; \\theta_1) = m(t; \\theta_2)$ for all $t$ implies $\\theta_{1,j} = \\theta_{2,j}$. Structural identifiability is a property of the model equations alone and is independent of data quality.\n\nIn contrast, **practical identifiability** is a data-dependent concept. It assesses whether a parameter's value can be estimated with a useful level of precision from a specific, finite set of noisy experimental data. A parameter may be structurally identifiable but practically nonidentifiable due to factors such as limited or infrequent measurements, high measurement noise, or an experimental input $u(t)$ that fails to sufficiently stimulate the system dynamics related to that parameter. The diagnostic test we will develop is a probe for practical identifiability under specified experimental conditions.\n\n**2. Sensitivity Analysis and the Fisher Information Matrix (FIM)**\n\nTo diagnose practical identifiability, we analyze how sensitive the model output $m(t)$ is to small changes in each parameter. This is quantified by the sensitivity functions, $S_p(t) = \\frac{\\partial m(t; \\theta)}{\\partial p}$, for each parameter $p \\in \\{\\alpha, \\delta, K\\}$. These sensitivities are governed by a set of linear ODEs derived by differentiating the primary model equation with respect to each parameter.\n\nGiven the model $\\frac{dm}{dt} = f(t, m, \\theta)$, the sensitivity equation for a generic parameter $p$ is obtained via the chain rule:\n$$\n\\frac{d S_p}{dt} = \\frac{d}{dt}\\left(\\frac{\\partial m}{\\partial p}\\right) = \\frac{\\partial}{\\partial p}\\left(\\frac{dm}{dt}\\right) = \\frac{\\partial f}{\\partial p} + \\frac{\\partial f}{\\partial m} \\frac{\\partial m}{\\partial p} = \\frac{\\partial f}{\\partial m} S_p + \\frac{\\partial f}{\\partial p}.\n$$\nThe model is given by $f(t, m, \\theta) = \\alpha h(u(t); K, n) - \\delta m(t)$, where $h(u; K, n) = \\frac{(u/K)^n}{1 + (u/K)^n}$. With the Hill coefficient $n=2$ held fixed, the parameters of interest are $\\theta = [\\alpha, \\delta, K]^T$.\nThe required partial derivatives of $f$ are:\n- $\\frac{\\partial f}{\\partial m} = -\\delta$\n- $\\frac{\\partial f}{\\partial \\alpha} = h(u; K, n)$\n- $\\frac{\\partial f}{\\partial \\delta} = -m(t)$\n- $\\frac{\\partial f}{\\partial K} = \\alpha \\frac{\\partial h}{\\partial K} = \\alpha \\left( -\\frac{n}{K} \\frac{(u/K)^n}{(1 + (u/K)^n)^2} \\right)$\n\nWe can now write the full system of ODEs for the state $m(t)$ and its sensitivities $S_\\alpha(t)$, $S_\\delta(t)$, and $S_K(t)$:\n$$\n\\frac{d}{dt} \\begin{pmatrix} m \\\\ S_\\alpha \\\\ S_\\delta \\\\ S_K \\end{pmatrix}\n=\n\\begin{pmatrix}\n\\alpha h(u; K, n) - \\delta m \\\\\n-\\delta S_\\alpha + h(u; K, n) \\\\\n-\\delta S_\\delta - m \\\\\n-\\delta S_K + \\alpha \\left( -\\frac{n}{K} \\frac{(u/K)^n}{(1 + (u/K)^n)^2} \\right)\n\\end{pmatrix}\n$$\nThe initial conditions are $m(0) = 10$ and $S_\\alpha(0) = S_\\delta(0) = S_K(0) = 0$, as $m(0)$ is assumed to be independent of $\\theta$.\n\nThese sensitivities are the bridge to statistical identifiability via the Fisher Information Matrix (FIM). For a measurement model $y_i = m(t_i; \\theta) + \\varepsilon_i$ with i.i.d. Gaussian noise $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$, the FIM $F$ has elements:\n$$\nF_{jk} = \\frac{1}{\\sigma^2} \\sum_{i=1}^{N} \\frac{\\partial m(t_i; \\theta)}{\\partial \\theta_j} \\frac{\\partial m(t_i; \\theta)}{\\partial \\theta_k}\n$$\nwhere $N$ is the number of observations. A singular or near-singular FIM indicates nonidentifiability, as the inverse of the FIM, the Cramér-Rao bound, provides a lower bound on the variance of any unbiased estimator for $\\theta$. An infinite variance implies nonidentifiability.\n\nThe problem specifies using log-transformed parameters, which is often beneficial for scale parameters. The sensitivity with respect to a log-parameter $\\phi_j = \\log \\theta_j$ is $\\tilde{S}_{\\theta_j}(t) \\equiv \\frac{\\partial m}{\\partial \\phi_j} = \\frac{\\partial m}{\\partial \\theta_j}\\frac{d\\theta_j}{d\\phi_j} = \\theta_j S_{\\theta_j}(t)$. Let $\\tilde{J}_{sens}$ be the matrix with entries $(\\tilde{J}_{sens})_{ij} = \\tilde{S}_{\\theta_j}(t_i)$. The FIM for log-parameters is $F_{\\phi} = \\frac{1}{\\sigma^2} \\tilde{J}_{sens}^T \\tilde{J}_{sens}$.\n\nThe problem further defines a scaled sensitivity matrix $J$ with entries $J_{ij} = (\\tilde{J}_{sens})_{ij} / \\sigma$. Then, $F_{\\phi} = J^T J$. The rank of $F_{\\phi}$ is equal to the rank of $J$. Thus, analyzing the rank of $J$ is sufficient to diagnose identifiability.\n\n**3. Computational Diagnostic for Identifiability**\n\nThe practical identifiability of the parameter set can be diagnosed by computing the numerical rank of the matrix $J$. If $J$ has full column rank (i.e., its columns are linearly independent), all parameters are locally identifiable. If $J$ is rank-deficient, its columns are linearly dependent, implying that the effect of changing one parameter on the output can be mimicked by changing another, making them nonidentifiable from the data.\n\nTo attribute nonidentifiability to specific parameters, we use a rank-revealing QR factorization with column pivoting on the matrix $J$. This factorization takes the form $J P = Q R$, where $P$ is a permutation matrix (or vector of column indices), $Q$ is an orthogonal matrix, and $R$ is an upper-triangular matrix with diagonal elements sorted by magnitude: $|R_{11}| \\ge |R_{22}| \\ge \\dots$. The permutation $P$ reorders the columns of $J$ to achieve this structure, effectively selecting the most linearly independent columns first.\n\nThe numerical rank, $r$, is determined by counting the number of diagonal elements of $R$ that are significantly larger than zero. A standard tolerance for this is a multiple of machine epsilon relative to the largest diagonal element.\n$$\nr = \\left| \\left\\{ k : |R_{kk}| > \\max(\\mathrm{shape}(J)) \\cdot \\epsilon \\cdot |R_{11}| \\right\\} \\right|\n$$\nThe first $r$ columns selected by the permutation $P$ form a basis for the column space of $J$. The parameters corresponding to these columns are deemed identifiable. Any parameter whose column is not among the first $r$ pivot columns is linearly dependent on the others and is thus nonidentifiable under the given experimental design.\n\nThe procedure is as follows:\n1.  For each experimental condition (input $u(t)$), simultaneously solve the ODEs for $m(t)$ and sensitivities $S_p(t)$ over the observation time grid.\n2.  Calculate the scaled, dimensionless sensitivities $\\tilde{S}_p(t_i) = p \\cdot S_p(t_i)$ at each observation time $t_i$ for $p \\in \\{\\alpha, \\delta, K\\}$.\n3.  Construct the $N \\times 3$ matrix $J$ with columns $[\\tilde{S}_\\alpha/\\sigma, \\tilde{S}_\\delta/\\sigma, \\tilde{S}_K/\\sigma]$.\n4.  Compute the QR factorization of $J$ with column pivoting: `Q, R, P = qr(J, pivoting=True)`.\n5.  Determine the numerical rank $r$ by inspecting the diagonal of $R$.\n6.  The indices of the identifiable parameters are the first $r$ elements of the pivot vector $P$.\n7.  Generate the boolean triplet indicating the identifiability status of $[\\alpha, \\delta, K]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Solves for the identifiability of parameters in a gene regulation model\n    under three different experimental input designs.\n    \"\"\"\n\n    # --- Scientific setup and parameter values ---\n    M0 = 10.0           # Initial mRNA concentration\n    N_HILL = 2.0        # Hill coefficient (fixed and known)\n    ALPHA = 5.0         # Maximal transcription rate\n    DELTA = 0.2         # Degradation rate constant\n    K_CONST = 50.0      # Half-saturation constant\n    SIGMA = 0.5         # Standard deviation of measurement noise\n\n    # Nominal parameter vector\n    params_nominal = {'alpha': ALPHA, 'delta': DELTA, 'K': K_CONST, 'n': N_HILL}\n    param_keys = ['alpha', 'delta', 'K']\n\n    # Observation times\n    t_span = (0, 60)\n    t_eval = np.arange(t_span[0], t_span[1] + 1, 1) # t=0 to t=60 inclusive\n\n    # Initial conditions for state and sensitivities\n    y0 = [M0, 0.0, 0.0, 0.0]  # [m, S_alpha, S_delta, S_K]\n\n    # --- Test suite: Input designs u(t) ---\n    def u_case1(t):\n        if t  20:\n            return 10.0\n        elif t  40:\n            return 100.0\n        else:\n            return 50.0\n\n    def u_case2(t):\n        return 2000.0\n\n    def u_case3(t):\n        return 0.0\n\n    test_cases = [u_case1, u_case2, u_case3]\n    results = []\n\n    # --- Main loop for each test case ---\n    for u_func in test_cases:\n\n        # --- Define the system of ODEs for state and sensitivities ---\n        def rhs(t, y, p):\n            m, s_alpha, s_delta, s_k = y\n            alpha, delta, K, n = p['alpha'], p['delta'], p['K'], p['n']\n\n            u_val = u_func(t)\n            \n            # Avoid division by zero if K=0 or u=0\n            if K == 0 or u_val == 0:\n                h = 0.0\n                df_dK = 0.0\n            else:\n                x = u_val / K\n                x_n = x**n\n                h = x_n / (1.0 + x_n)\n                # Partial derivative of f w.r.t. K\n                df_dK = alpha * (-n / K * x_n / (1.0 + x_n)**2)\n            \n            # ODEs for state and sensitivities\n            dm_dt = alpha * h - delta * m\n            ds_alpha_dt = -delta * s_alpha + h\n            ds_delta_dt = -delta * s_delta - m\n            ds_k_dt = -delta * s_k + df_dK\n\n            return [dm_dt, ds_alpha_dt, ds_delta_dt, ds_k_dt]\n\n        # --- Solve the augmented ODE system ---\n        sol = solve_ivp(\n            fun=rhs,\n            t_span=t_span,\n            y0=y0,\n            t_eval=t_eval,\n            args=(params_nominal,),\n            method='RK45'\n        )\n\n        s_alpha_traj, s_delta_traj, s_k_traj = sol.y[1], sol.y[2], sol.y[3]\n\n        # --- Construct the scaled sensitivity matrix J ---\n        # Scale sensitivities for log-parameters\n        s_tilde_alpha = params_nominal['alpha'] * s_alpha_traj\n        s_tilde_delta = params_nominal['delta'] * s_delta_traj\n        s_tilde_k = params_nominal['K'] * s_k_traj\n\n        # Assemble J, normalizing by sigma\n        J = np.vstack([s_tilde_alpha, s_tilde_delta, s_tilde_k]).T / SIGMA\n\n        # --- Perform rank-revealing QR factorization ---\n        Q, R, P = qr(J, pivoting=True)\n\n        # --- Determine numerical rank and identifiability ---\n        # A robust tolerance for numerical rank determination.\n        # Since R's diagonal elements are sorted by magnitude in pivoted QR,\n        # R[0, 0] is the largest-magnitude diagonal element.\n        if np.abs(R[0, 0])  np.finfo(J.dtype).eps:\n            tol = np.finfo(J.dtype).eps\n        else:\n            tol = max(J.shape) * np.finfo(J.dtype).eps * np.abs(R[0, 0])\n\n        rank = np.sum(np.abs(np.diag(R)) > tol)\n        \n        # The first 'rank' elements of the pivot vector P are the indices\n        # of the linearly independent columns (identifiable parameters).\n        identifiable_indices = P[:rank]\n\n        # Check which parameters are in the identifiable set\n        # Indices: 0->alpha, 1->delta, 2->K\n        identifiability_status = [i in identifiable_indices for i in range(len(param_keys))]\n        results.append(identifiability_status)\n\n    # --- Format and print the final output ---\n    # The required format is [[...],[...],[...]] with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}