{
    "hands_on_practices": [
        {
            "introduction": "在构建完整的混合模型之前，理解单个离散单元如何产生连续场至关重要。本练习旨在通过解析方法，求解二维空间中由点源产生的稳态浓度分布。通过此过程，您将发现二维点源的一个关键数学特征——对数奇异性——它揭示了在离散-连续耦合的尺度界面上，纯连续描述的局限性，并强调了精心设计耦合方案的必要性。",
            "id": "4353352",
            "problem": "考虑一个系统生物医学中的离散-连续混合模型，其中位于原点的单个静止细胞充当平面组织中可扩散营养场的局部源项。连续营养物浓度 $c(\\mathbf{x})$ 在稳态下由以下偏微分方程（PDE）控制：\n$$\n\\nabla^2 c(\\mathbf{x}) = \\alpha\\,\\delta(\\mathbf{x}),\n$$\n该方程定义在无限二维域 $\\mathbb{R}^2$ 上，其中 $\\alpha$ 是一个实常数，$\\delta(\\mathbf{x})$ 是以原点为中心的 Dirac delta 分布。假设系统具有各向同性，因此 $c(\\mathbf{x}) = c(r)$ 仅取决于径向距离 $r = |\\mathbf{x}|$。由于无限二维域不允许点源在无穷远处有有限的边界条件，我们通过在指定的宏观半径 $R > 0$ 处施加参考条件 $c(R) = 0$ 来固定加性常数。\n\n从拉普拉斯算子和 Dirac delta 分布的基本性质出发，计算当 $r > 0$ 时稳态营养物浓度分布 $c(r)$ 的显式表达式，用 $r$、$R$ 和 $\\alpha$ 表示。此外，仅使用第一性原理，描述在极限 $r \\to 0^+$ 下 $c(r)$ 的主导阶行为，并解释其在离散-连续混合耦合背景下的物理意义。\n\n请将您的最终分布 $c(r)$ 表示为单个闭式解析表达式。无需进行数值取整。",
            "solution": "该问题陈述经评估有效。它在科学上基于偏微分方程理论（特别是泊松方程），由于包含了用于固定积分常数的参考条件而是适定的，并且其表述是客观的。该问题代表了理论生物物理学中的一个标准、理想化模型，并且可以使用第一性原理求解。\n\n稳态营养物浓度 $c(\\mathbf{x})$ 由二维泊松方程控制：\n$$\n\\nabla^2 c(\\mathbf{x}) = \\alpha\\,\\delta(\\mathbf{x})\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^2$，$\\alpha$ 是表示源强度的常数，$\\delta(\\mathbf{x})$ 是 Dirac delta 分布。问题陈述指出解是各向同性的，意味着 $c(\\mathbf{x}) = c(r)$，其中 $r = |\\mathbf{x}| = \\sqrt{x_1^2 + x_2^2}$ 是到原点的径向距离。\n\n对于任何不包含原点的区域（即 $r > 0$），Dirac delta 项为零，即 $\\delta(\\mathbf{x}) = 0$。在该区域，控制方程简化为拉普拉斯方程：\n$$\n\\nabla^2 c(r) = 0 \\quad \\text{对于 } r > 0\n$$\n为了求解此方程，我们在极坐标 $(r, \\theta)$ 中表示拉普拉斯算子 $\\nabla^2$。其一般形式为 $\\nabla^2 = \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2}{\\partial \\theta^2}$。由于径向对称性，浓度 $c$ 不依赖于角度 $\\theta$，因此 $\\frac{\\partial^2 c}{\\partial \\theta^2}$ 项消失。该偏微分方程因此变为关于 $r$ 的常微分方程（ODE）：\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r\\frac{dc}{dr}\\right) = 0\n$$\n为使此方程在 $r>0$ 时成立，括号中的项必须为常数。设此常数为 $A$：\n$$\nr\\frac{dc}{dr} = A\n$$\n分离变量并积分，得到：\n$$\n\\frac{dc}{dr} = \\frac{A}{r}\n$$\n再次对 $r$ 积分，得到 $c(r)$ 的通解：\n$$\nc(r) = A \\ln(r) + B\n$$\n其中 $A$ 和 $B$ 是积分常数。这是二维拉普拉斯方程在径向对称情况下的基本解。\n\n为了确定常数 $A$，我们必须将其与源强度 $\\alpha$ 联系起来。我们在以原点为中心、半径为 $\\epsilon$ 的小圆盘 $D_\\epsilon$ 上对原始泊松方程进行积分。\n$$\n\\iint_{D_\\epsilon} \\nabla^2 c(\\mathbf{x}) \\, d^2x = \\iint_{D_\\epsilon} \\alpha\\,\\delta(\\mathbf{x}) \\, d^2x\n$$\n根据 Dirac delta 分布的定义性质，右侧的积分就是 $\\alpha$。\n$$\n\\iint_{D_\\epsilon} \\alpha\\,\\delta(\\mathbf{x}) \\, d^2x = \\alpha\n$$\n对于左侧，我们应用二维散度定理（格林公式的一个特例），该定理指出 $\\iint_D \\nabla \\cdot \\mathbf{F} \\, d^2x = \\oint_{\\partial D} \\mathbf{F} \\cdot \\mathbf{\\hat{n}} \\, ds$。令 $\\mathbf{F} = \\nabla c$，我们有：\n$$\n\\iint_{D_\\epsilon} \\nabla^2 c \\, d^2x = \\oint_{\\partial D_\\epsilon} \\nabla c \\cdot \\mathbf{\\hat{n}} \\, ds\n$$\n这里，$\\partial D_\\epsilon$ 是半径为 $\\epsilon$ 的圆周，$\\mathbf{\\hat{n}}$ 是外向单位法向量（即径向单位向量 $\\mathbf{\\hat{r}}$），$ds$ 是弧长元。对于径向对称函数，其在极坐标中的梯度为 $\\nabla c = \\frac{dc}{dr}\\mathbf{\\hat{r}}$。\n积分变为：\n$$\n\\oint_{\\partial D_\\epsilon} \\left(\\frac{dc}{dr}\\mathbf{\\hat{r}}\\right) \\cdot \\mathbf{\\hat{r}} \\, ds = \\oint_{\\partial D_\\epsilon} \\frac{dc}{dr} \\, ds\n$$\n我们代入 $\\frac{dc}{dr} = \\frac{A}{r}$。在 $r=\\epsilon$ 处，被积函数是常数 $\\frac{A}{\\epsilon}$。积分路径是周长为 $2\\pi\\epsilon$ 的圆。\n$$\n\\oint_{\\partial D_\\epsilon} \\frac{A}{\\epsilon} \\, ds = \\frac{A}{\\epsilon} \\int_0^{2\\pi} \\epsilon \\, d\\theta = \\frac{A}{\\epsilon}(2\\pi\\epsilon) = 2\\pi A\n$$\n将积分后泊松方程的左右两边结果相等，得到：\n$$\n2\\pi A = \\alpha \\implies A = \\frac{\\alpha}{2\\pi}\n$$\n因此，浓度分布为 $c(r) = \\frac{\\alpha}{2\\pi}\\ln(r) + B$。\n\n为了确定常数 $B$，我们使用给定的参考条件 $c(R) = 0$，其中 $R > 0$ 是一个给定的半径。\n$$\nc(R) = \\frac{\\alpha}{2\\pi}\\ln(R) + B = 0\n$$\n解出 $B$：\n$$\nB = -\\frac{\\alpha}{2\\pi}\\ln(R)\n$$\n将 $A$ 和 $B$ 代回 $c(r)$ 的表达式，我们得到浓度分布的最终显式形式：\n$$\nc(r) = \\frac{\\alpha}{2\\pi}\\ln(r) - \\frac{\\alpha}{2\\pi}\\ln(R) = \\frac{\\alpha}{2\\pi}\\left(\\ln(r) - \\ln(R)\\right)\n$$\n利用对数的性质，可以写成：\n$$\nc(r) = \\frac{\\alpha}{2\\pi}\\ln\\left(\\frac{r}{R}\\right)\n$$\n\n接下来，我们分析 $c(r)$ 在极限 $r \\to 0^+$ 下的主导阶行为。当 $r$ 从正方向趋近于 $0$ 时，对数的参数 $\\frac{r}{R}$ 也趋近于 $0$。自然对数函数 $\\ln(x)$ 在其参数 $x \\to 0^+$ 时趋近于 $-\\infty$。\n$$\n\\lim_{r\\to 0^+} c(r) = \\lim_{r\\to 0^+} \\frac{\\alpha}{2\\pi}\\left(\\ln(r) - \\ln(R)\\right)\n$$\n当 $r \\to 0^+$ 时，$\\ln(r)$ 项主导了常数项 $-\\ln(R)$。因此，主导阶行为是一个对数奇异性：\n$$\nc(r) \\sim \\frac{\\alpha}{2\\pi}\\ln(r) \\quad \\text{当 } r \\to 0^+\n$$\n这揭示了浓度在点源的位置发散。\n\n这种奇异性的物理诠释对于理解离散-连续混合模型至关重要。连续介质的偏微分方程模型将细胞视为一个体积为零的数学点源，由 Dirac delta 分布 $\\delta(\\mathbf{x})$ 表示。营养物浓度在 $r=0$ 处的对数发散是这种理想化处理的一个直接且不可避免的数学推论。然而，一个物理上的细胞具有有限的尺寸。营养物的浓度在任何地方都不可能是无限的，包括在细胞表面。这种奇异性标志着连续介质描述在与细胞本身相当或更小的长度尺度上失效。\n\n在离散-连续混合框架中，这正是离散和连续描述必须耦合的界面。连续模型提供了远场浓度，当它接近离散对象（细胞）时表现出典型的奇异行为。反过来，细胞的离散模型并不会“看到”一个无限的浓度。相反，需要一个耦合条件。例如，细胞的行为（如其营养物消耗或分泌的速率，这决定了 $\\alpha$）可能取决于在细胞有限表面上或在某个特定的“耦合半径”处评估的连续场的平均浓度。因此，奇异性提供了来自连续场的必要的局部信息，这些信息驱动着离散元素的状态，从而连接了混合模型的两个尺度。它是数学表示所产生的一种人为产物，但它对模型的两个部分必须如何相互作用具有深刻的意义。",
            "answer": "$$\\boxed{\\frac{\\alpha}{2\\pi}\\ln\\left(\\frac{r}{R}\\right)}$$"
        },
        {
            "introduction": "在分析了单个智能体的行为之后，下一步自然是模拟整个种群的动态。本练习将指导您从零开始构建一个完整的二维混合模型，其中包含了核心的反馈回路：智能体消耗扩散的营养物质，而其生存和增殖则由局部营养浓度决定。通过这项实践，您将直接运用关键的数值技术，例如求解偏微分方程的有限差分法，以及用于耦合离散与连续组分的插值方法。",
            "id": "4353262",
            "problem": "考虑一个混合离散-连续模型，用于描述扩散的营养物场与一组离散生物智能体的相互作用。设连续场为无量纲的营养物浓度 $c(\\mathbf{x},t)$，定义在方形域 $\\Omega = [0,1]^2$ 上，离散智能体由 $i=1,\\dots,N(t)$ 索引，其位置为 $\\mathbf{x}_i \\in \\Omega$。从菲克扩散定律（Fick's law of diffusion）的基本原理出发，该定律指出扩散通量为 $\\mathbf{J} = -D \\nabla c$，其中 $D$ 是一个正的扩散系数；并结合质量守恒，即累积量等于流入量减去流出量加上源项减去汇项。在这些假设下，通过写出扩散项并减去由智能体引起的局部吸收（模拟为智能体位置上的点汇），可以得到营养物的控制连续方程。每个智能体的吸收速率是其位置处局部浓度的函数 $\\lambda(c(\\mathbf{x}_i))$，这导致了以下的混合离散-连续偏微分方程\n$$\n\\partial_t c(\\mathbf{x},t) = D \\nabla^2 c(\\mathbf{x},t) - \\sum_{i=1}^{N(t)} \\lambda\\!\\big(c(\\mathbf{x}_i,t)\\big)\\,\\delta\\!\\big(\\mathbf{x}-\\mathbf{x}_i\\big),\n$$\n其中 $\\delta(\\cdot)$ 是狄拉克δ分布（Dirac delta distribution）。假设在 $\\partial \\Omega$ 上为零通量（诺伊曼）边界条件，因此 $\\partial_{\\mathbf{n}} c = 0$ 成立，其中 $\\mathbf{n}$ 是外法向向量。\n\n通过米氏动力学（Michaelis–Menten kinetics, MM）定义吸收函数：\n$$\n\\lambda(c) = k \\frac{c}{K + c},\n$$\n其中 $k$ 和 $K$ 为正常数。智能体不移动，但其种群根据局部营养物通过两种规则演化：凋亡（死亡）和增殖（分裂）。每个智能体 $i$ 有一个整数年龄计数器 $a_i(t)$（以时间步为单位）。在每个时间步，规则如下：\n- 如果局部营养物 $c(\\mathbf{x}_i,t)$ 小于或等于阈值 $c_{\\mathrm{apop}}$，则该智能体发生凋亡并立即被移除。\n- 如果局部营养物 $c(\\mathbf{x}_i,t)$ 大于或等于阈值 $c_{\\mathrm{prolif}}$，则该智能体的年龄 $a_i$ 增加一；否则，年龄不变。如果 $a_i$ 达到或超过预设的分裂间隔 $T_{\\mathrm{div}}$，该智能体分裂成两个智能体：原始智能体年龄重置为零，并在位置 $\\mathbf{x}_i + (\\Delta x,0)$ 处创建一个年龄为零的新智能体，前提是该位置在 $\\Omega$ 内；否则在 $\\mathbf{x}_i - (\\Delta x,0)$ 处创建。这里 $\\Delta x$ 表示下面定义的网格间距。如果新位置会超出 $\\Omega$，则必须将其限制在 $\\Omega$ 内部。\n\n使用一个在 $x$ 方向有 $N_x$ 个节点、在 $y$ 方向有 $N_y$ 个节点的常规笛卡尔网格来数值近似连续场，网格间距为 $\\Delta x = 1/(N_x-1)$ 和 $\\Delta y = 1/(N_y-1)$。设 $c_{j,k}^n$ 表示在网格索引 $(j,k)$ 和时间步 $n$ 处对 $c$ 的离散近似。使用标准的5点模板近似拉普拉斯算子 $ \\nabla^2 c $，并通过使用镜像虚拟值（等效于用边界值填充，以满足 $\\partial_{\\mathbf{n}} c = 0$）来强制执行零通量边界条件。通过使用和为一的双线性权重，将每个智能体的吸收量分配到最近的四个网格节点上，来近似 $\\delta(\\mathbf{x}-\\mathbf{x}_i)$。为保持正确的物理尺度，将沉积的吸收量除以单元面积 $\\Delta x \\Delta y$，使得节点上的离散汇 $S_{j,k}^n$ 表示单位面积的速率。使用显式前向欧拉时间积分，\n$$\nc^{n+1}_{j,k} = c^n_{j,k} + \\Delta t \\left( D \\nabla^2_{\\mathrm{FD}} c^n_{j,k} - S^n_{j,k} \\right),\n$$\n其时间步长 $\\Delta t$ 的选择需满足均匀网格上二维扩散的标准稳定性限制。对于相等的间距 $\\Delta x = \\Delta y$，强制执行\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{4 D}\n$$\n并且对于本任务，为保证数值安全，选择\n$$\n\\Delta t = 0.2 \\frac{\\Delta x^2}{4 D}\n$$\n初始条件为在 $\\Omega$ 中各处均为均匀的 $c(\\mathbf{x},0) = 1$，初始智能体年龄为零。\n\n实现上述混合模型，并对以下三个测试用例中的每一个，模拟预设的时间步数 $T$。所有量均为无量纲；不使用物理单位。对于每个测试用例，输出最终存活智能体的数量 $N(T)$，形式为整数。\n\n测试套件：\n- 案例 A (一般正常路径):\n  - 域和网格: $N_x = 64$, $N_y = 64$.\n  - 扩散: $D = 10^{-3}$.\n  - 吸收参数: $k = 5 \\times 10^{-2}$, $K = 10^{-1}$.\n  - 智能体规则: $c_{\\mathrm{prolif}} = 0.7$, $c_{\\mathrm{apop}} = 0.2$, $T_{\\mathrm{div}} = 30$.\n  - 时间步: $T = 220$.\n  - 初始智能体: 两个智能体，位置为 $\\mathbf{x}_1=(0.5,0.5)$ 和 $\\mathbf{x}_2=(0.55,0.5)$，年龄均为 $0$。\n- 案例 B (边界条件和高消耗压力测试):\n  - 域和网格: $N_x = 64$, $N_y = 64$.\n  - 扩散: $D = 10^{-3}$.\n  - 吸收参数: $k = 2 \\times 10^{-1}$, $K = 5 \\times 10^{-2}$.\n  - 智能体规则: $c_{\\mathrm{prolif}} = 0.6$, $c_{\\mathrm{apop}} = 0.4$, $T_{\\mathrm{div}} = 40$.\n  - 时间步: $T = 200$.\n  - 初始智能体: 两个智能体，位置为 $\\mathbf{x}_1=(0.02,0.02)$ 和 $\\mathbf{x}_2=(0.98,0.98)$，年龄均为 $0$。\n- 案例 C (无智能体的边缘案例):\n  - 域和网格: $N_x = 64$, $N_y = 64$.\n  - 扩散: $D = 10^{-3}$.\n  - 吸收参数: $k = 10^{-1}$, $K = 10^{-1}$.\n  - 智能体规则: $c_{\\mathrm{prolif}} = 0.9$, $c_{\\mathrm{apop}} = 0.1$, $T_{\\mathrm{div}} = 20$.\n  - 时间步: $T = 100$.\n  - 初始智能体: 无。\n\n您的程序应生成单行输出，其中包含三个测试用例的最终存活智能体数量，格式为逗号分隔的列表并用方括号括起来（例如，$[N_A,N_B,N_C]$）。除此确切格式外，不应打印任何多余的文本或空格。程序必须是自包含的，并且不需要用户输入。",
            "solution": "用户的问题陈述已经过严格验证，并被认为是**有效的**。它在科学上基于反应扩散系统和基于智能体的建模原则，问题设定良好、客观，并包含了唯一计算解所需的所有必要信息。\n\n该问题要求实现一个混合离散-连续模型。该模型由两个主要部分组成：一个用于营养物场的连续偏微分方程（PDE），以及一组控制生物智能体种群的离散规则。这两个部分是耦合的：智能体消耗营养物，在连续场中产生局部汇；反过来，局部营养物浓度决定了智能体的生存和增殖。\n\n解决方案是通过数值模拟实现的，该模拟在预设的时间步数 $T$ 内演化系统状态。算法的核心步骤概述如下。\n\n**1. 系统初始化**\n\n首先，我们根据提供的参数建立模拟环境。\n- 定义一个尺寸为 $N_y \\times N_x$ 的二维笛卡尔网格，以表示空间域 $\\Omega = [0,1]^2$。网格间距为 $\\Delta x = 1/(N_x-1)$ 和 $\\Delta y = 1/(N_y-1)$。\n- 营养物浓度场 $c(\\mathbf{x}, t)$ 在此网格上离散化，表示为 $c_{j,k}^n$，其中 $(j,k)$ 是网格索引，$n$ 是时间步索引。它被初始化为均匀值 $c_{j,k}^0 = 1$。\n- 时间步长 $\\Delta t$ 由显式欧拉法的扩散稳定性条件确定，并附加一个0.2的安全因子：\n$$ \\Delta t = 0.2 \\frac{\\min(\\Delta x^2, \\Delta y^2)}{4D} $$\n对于本问题，$\\Delta x = \\Delta y$，表达式简化为 $\\Delta t = 0.2 \\frac{\\Delta x^2}{4D}$。\n- 离散智能体存储为列表或数组，每个智能体都具有其位置 $\\mathbf{x}_i \\in [0,1]^2$ 和整数年龄 $a_i \\in \\mathbb{N}_0$ 的状态变量。初始智能体位置已给出，初始年龄设置为 $a_i(0)=0$。\n\n**2. 模拟循环**\n\n模拟以 $n = 0, 1, \\dots, T-1$ 的方式迭代进行。每个时间步包括三个主要部分：智能体动力学、汇项计算和PDE场更新。\n\n**2.1. 智能体动力学与耦合（离散部分）**\n\n对于每个位置为 $\\mathbf{x}_i$、年龄为 $a_i$ 的智能体 $i$，其命运由局部营养物浓度 $c(\\mathbf{x}_i, t^n)$ 决定。由于智能体的位置是连续的， $c(\\mathbf{x}_i, t^n)$ 通过对 $\\mathbf{x}_i$ 周围四个最近网格节点的值进行双线性插值来近似。设 $\\mathbf{x}_i = (x_i, y_i)$，并设 $(j,k)$ 是左下角网格节点的索引，即 $j = \\lfloor x_i/\\Delta x \\rfloor$ 和 $k = \\lfloor y_i/\\Delta y \\rfloor$。设 $u = (x_i/\\Delta x) - j$ 和 $v = (y_i/\\Delta y) - k$ 为分数距离。局部浓度为：\n$$ c(\\mathbf{x}_i) \\approx (1-u)(1-v)c_{k,j}^n + u(1-v)c_{k,j+1}^n + (1-u)v c_{k+1,j}^n + u v c_{k+1,j+1}^n $$\n根据这个值，应用以下规则：\n- **凋亡：**如果 $c(\\mathbf{x}_i) \\le c_{\\mathrm{apop}}$，该智能体被标记为将从种群中移除。\n- **增殖：**如果智能体存活下来且 $c(\\mathbf{x}_i) \\ge c_{\\mathrm{prolif}}$，其年龄增加：$a_i \\to a_i + 1$。如果更新后的年龄 $a_i$ 达到或超过分裂间隔 $T_{\\mathrm{div}}$，该智能体分裂。母体智能体的年龄重置为 $a_i=0$，并创建一个年龄为0的子代智能体。新智能体被放置在 $\\mathbf{x}_i + (\\Delta x, 0)$，如果该位置在 $\\Omega$ 内；否则放置在 $\\mathbf{x}_i - (\\Delta x, 0)$。最终位置被限制在域边界 $[0,1]^2$ 内。\n\n为确保一致性，所有移除和添加操作都被收集起来，并在智能体更新子步骤结束时同时应用。\n\n**2.2. 汇项计算（耦合）**\n\n智能体对营养物的消耗在PDE中被建模为一个汇项 $S^n_{j,k}$。该项是为每个存活的智能体计算的。\n- 对于每个智能体 $i$，吸收速率由米氏函数给出：\n$$ \\lambda_i = \\lambda(c(\\mathbf{x}_i)) = k \\frac{c(\\mathbf{x}_i)}{K + c(\\mathbf{x}_i)} $$\n- 这个点汇使用与插值相同的双线性权重，被分配到最近的四个网格节点 $(k,j), (k,j+1), (k+1,j), (k+1,j+1)$。为了保持物理一致性，总吸收速率 $\\lambda_i$ 通过除以网格单元面积 $A_{cell} = \\Delta x \\Delta y$ 转换为汇密度。因此，智能体 $i$ 对节点 $(k,j)$ 处汇的贡献是：\n$$ \\Delta S_{k,j} = \\frac{\\lambda_i}{\\Delta x \\Delta y} (1-u)(1-v) $$\n类似项被加到其他三个节点。总汇项 $S_{k,j}^n$ 是所有智能体贡献的总和。\n\n**2.3. 场更新（连续部分）**\n\n浓度场使用前向欧拉法更新：\n$$ c_{j,k}^{n+1} = c_{j,k}^n + \\Delta t \\left( D (\\nabla^2 c^n)_{j,k} - S^n_{j,k} \\right) $$\n- 拉普拉斯算子 $\\nabla^2 c$ 使用均匀网格（$\\Delta x=\\Delta y$）上的标准5点有限差分模板进行近似：\n$$ (\\nabla^2 c^n)_{j,k} \\approx \\frac{c_{j+1,k}^n + c_{j-1,k}^n + c_{j,k+1}^n + c_{j,k-1}^n - 4c_{j,k}^n}{\\Delta x^2} $$\n- 零通量诺伊曼边界条件 $\\partial_{\\mathbf{n}} c = 0$ 是通过用其边缘值填充浓度网格来实现的。这等效于将虚拟单元格的值设置为其相邻内部单元格的值，例如，在左边界上 $c_{-1,k} = c_{1,k}$。\n- 更新后，浓度值被裁剪为非负值，$c_{j,k}^{n+1} = \\max(0, c_{j,k}^{n+1})$，以防止可能由数值不精确性产生的非物理负值。\n\n经过 $T$ 个时间步后，模拟终止，并报告最终存活的智能体数量 $N(T)$。对问题陈述中指定的每个测试用例都执行此过程。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(Nx, Ny, D, k, K, c_prolif, c_apop, T_div, T, initial_agents_pos):\n    \"\"\"\n    Runs a single simulation of the hybrid discrete-continuum model.\n    \"\"\"\n    # 1. Initialization\n    dx = 1.0 / (Nx - 1)\n    dy = 1.0 / (Ny - 1)  # dx is assumed equal to dy in the problem\n    dt = 0.2 * (dx**2) / (4 * D)\n    \n    # Concentration field c[y, x]\n    c = np.ones((Ny, Nx), dtype=np.float64)\n    \n    # Agents array: [x, y, age]\n    if initial_agents_pos:\n        agents = np.array([[pos[0], pos[1], 0.0] for pos in initial_agents_pos], dtype=np.float64)\n    else:\n        agents = np.empty((0, 3), dtype=np.float64)\n\n    # 2. Main simulation loop\n    for _ in range(T):\n        sinks = np.zeros_like(c)\n        \n        if agents.shape[0] > 0:\n            # 2.1. Agent Dynamics\n            # Get local concentration for each agent via bilinear interpolation\n            x_pos = agents[:, 0]\n            y_pos = agents[:, 1]\n            \n            x_scaled = x_pos / dx\n            y_scaled = y_pos / dy\n            \n            # Using min with Nx-2/Ny-2 ensures j+1/k+1 are valid indices\n            j = np.minimum(np.floor(x_scaled).astype(int), Nx - 2)\n            k = np.minimum(np.floor(y_scaled).astype(int), Ny - 2)\n\n            u = x_scaled - j\n            v = y_scaled - k\n            \n            # Vectorized bilinear interpolation for local concentration c_local\n            c_local = (1-v) * ((1-u) * c[k, j] + u * c[k, j+1]) + \\\n                      v * ((1-u) * c[k+1, j] + u * c[k+1, j+1])\n\n            # Apoptosis\n            apoptosis_mask = c_local = c_apop\n            surviving_mask = ~apoptosis_mask\n            \n            # Proliferation\n            prolif_mask = c_local >= c_prolif\n            \n            # Filter to get data for agents that survive this step\n            agents = agents[surviving_mask]\n            c_local = c_local[surviving_mask]\n            prolif_mask = prolif_mask[surviving_mask]\n\n            if agents.shape[0] > 0:\n                # 2.2. Sink Calculation\n                lambda_vals = k * c_local / (K + c_local)\n                sink_per_area = lambda_vals / (dx * dy)\n\n                x_pos = agents[:, 0]\n                y_pos = agents[:, 1]\n                x_scaled = x_pos / dx\n                y_scaled = y_pos / dy\n                j = np.minimum(np.floor(x_scaled).astype(int), Nx - 2)\n                k = np.minimum(np.floor(y_scaled).astype(int), Ny - 2)\n                u = x_scaled - j\n                v = y_scaled - k\n\n                # Distribute sinks to 4 nearest neighbors using bilinear weights.\n                # np.add.at is used to handle multiple agents contributing to the same node.\n                np.add.at(sinks, (k, j), (1-u)*(1-v) * sink_per_area)\n                np.add.at(sinks, (k, j+1), u*(1-v) * sink_per_area)\n                np.add.at(sinks, (k+1, j), (1-u)*v * sink_per_area)\n                np.add.at(sinks, (k+1, j+1), u*v * sink_per_area)\n\n                # Update ages for agents that are in a proliferative environment\n                agents[prolif_mask, 2] += 1\n                \n                # Division\n                division_mask = agents[:, 2] >= T_div\n                dividing_agents = agents[division_mask]\n                \n                new_agents_list = []\n                if dividing_agents.shape[0] > 0:\n                    # Reset age of parent agents\n                    agents[division_mask, 2] = 0\n                    \n                    for agent in dividing_agents:\n                        x, y, _ = agent\n                        x_new = x + dx\n                        # If new position is outside, choose the other side\n                        if x_new > 1.0:\n                            x_new = x - dx\n                        \n                        # Clamp to ensure it remains within [0,1]\n                        x_new = np.clip(x_new, 0.0, 1.0)\n                        y_new = y\n                        \n                        new_agents_list.append([x_new, y_new, 0.0])\n                \n                # Update main agent array with new agents\n                if new_agents_list:\n                    agents = np.vstack([agents, np.array(new_agents_list, dtype=np.float64)])\n\n        # 2.3. Field Update\n        # Laplacian with Neumann BCs (padding with edge values)\n        c_padded = np.pad(c, 1, mode='edge')\n        lap_c = (c_padded[1:-1, :-2] + c_padded[1:-1, 2:] + \n                 c_padded[:-2, 1:-1] + c_padded[2:, 1:-1] - 4*c) / (dx**2)\n        \n        # Forward Euler time step\n        c += dt * (D * lap_c - sinks)\n        \n        # Ensure concentration is non-negative\n        np.clip(c, 0, None, out=c)\n    \n    return agents.shape[0]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the final results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            'Nx': 64, 'Ny': 64, 'D': 1e-3, 'k': 5e-2, 'K': 1e-1,\n            'c_prolif': 0.7, 'c_apop': 0.2, 'T_div': 30, 'T': 220,\n            'initial_agents_pos': [(0.5, 0.5), (0.55, 0.5)]\n        },\n        # Case B\n        {\n            'Nx': 64, 'Ny': 64, 'D': 1e-3, 'k': 2e-1, 'K': 5e-2,\n            'c_prolif': 0.6, 'c_apop': 0.4, 'T_div': 40, 'T': 200,\n            'initial_agents_pos': [(0.02, 0.02), (0.98, 0.98)]\n        },\n        # Case C\n        {\n            'Nx': 64, 'Ny': 64, 'D': 1e-3, 'k': 1e-1, 'K': 1e-1,\n            'c_prolif': 0.9, 'c_apop': 0.1, 'T_div': 20, 'T': 100,\n            'initial_agents_pos': []\n        }\n    ]\n    \n    results = []\n    for params in test_cases:\n        final_agent_count = run_simulation(**params)\n        results.append(final_agent_count)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在之前练习的基础上，本实践引入了许多生物系统中另一个至关重要的方面：智能体响应化学梯度的运动（趋化性）。您将实现一个趋化-消耗模型的单步时间演化，重点关注计算场梯度、在智能体位置上进行插值以及更新智能体位置的力学过程。此练习还介绍了一种表示点源的替代方法——高斯平滑核——从而为您提供更广阔的数值工具视野。",
            "id": "4353459",
            "problem": "考虑一个定义在矩形域 $\\Omega = [0,L_x]\\times[0,L_y]$ 上的二维离散-连续混合趋化-消耗模型，该区域具有无通量边界。一群位置为 $\\mathbf{x}_i(t)\\in\\Omega$ 的离散智能体通过运动和消耗与连续的化学引诱物场 $c(\\mathbf{x},t)$ 相互作用。控制规则如下：\n- 智能体运动学：$\\dot{\\mathbf{x}}_i(t) = \\chi \\nabla c(\\mathbf{x}_i(t),t)$。\n- 连续体动力学：$\\partial_t c(\\mathbf{x},t) = D \\nabla^2 c(\\mathbf{x},t) - \\sum_{i=1}^{N} \\lambda \\,\\delta(\\mathbf{x} - \\mathbf{x}_i(t))$。\n\n此处，$D$ 是扩散系数，$\\chi$ 是趋化敏感度，$\\lambda$ 是每个智能体的消耗率。狄拉克分布 $\\delta$ 用于模拟智能体位置处的点汇。\n\n您的任务是实现一个单一的显式时间步，使用有限差分法离散化连续体，并使用基于双线性插值的耦合进行离散到连续的交换，从而将连续体和智能体的状态从时间 $t$ 推进到 $t+\\Delta t$。该步骤应按以下方式计算：\n1. 用一个沿 $x$ 轴有 $N_x$ 个点、沿 $y$ 轴有 $N_y$ 个点的笛卡尔网格来离散化 $\\Omega$，网格间距分别为 $h_x=L_x/(N_x-1)$ 和 $h_y=L_y/(N_y-1)$。假设连续体满足无通量（齐次诺伊曼）边界条件，即在 $\\partial\\Omega$ 上 $(\\nabla c)\\cdot \\mathbf{n}=0$。\n2. 在内部使用二阶中心差分来近似拉普拉斯算子 $\\nabla^2 c$，并通过在边界处反射虚拟值来施加齐次诺伊曼边界条件。例如，在 $x=0$ 处，使用 $c(-h_x,y)\\equiv c(h_x,y)$；对其他域边界也进行类似处理。\n3. 使用归一化高斯平滑子来近似狄拉克分布 $\\delta(\\mathbf{x}-\\mathbf{x}_i)$。对于每个位于位置 $\\mathbf{x}_i=(x_i,y_i)$ 的智能体，构建\n$$\nG_\\sigma(\\mathbf{x}-\\mathbf{x}_i)=\\frac{1}{2\\pi\\sigma^2}\\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}_i\\|^2}{2\\sigma^2}\\right),\n$$\n并用\n$$\nS(\\mathbf{x})=\\sum_{i=1}^{N} \\lambda\\,G_\\sigma(\\mathbf{x}-\\mathbf{x}_i).\n$$\n来近似网格上的汇场。使用这个 $S(\\mathbf{x})$ 来近似消耗项。注意，离散积分 $\\sum_{j,k} S_{j,k}\\,h_x\\,h_y$ 应近似于 $\\sum_{i=1}^{N}\\lambda$，误差来自于边界附近的截断效应。\n4. 使用显式欧拉步更新连续体：\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\nabla^2 c^n - S \\right).\n$$\n5. 使用内部的中心差分和边界上一致的齐次诺伊曼处理方法，在网格上计算空间梯度 $\\nabla c^{n+1}$。然后，对于每个智能体，通过从四个相邻网格节点进行双线性插值来计算 $\\nabla c^{n+1}(\\mathbf{x}_i)$。\n6. 通过\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\chi\\,\\nabla c^{n+1}(\\mathbf{x}_i^n),\n$$\n更新智能体位置，然后施加反射边界：如果更新后的坐标位于 $[0,L_x]$ 或 $[0,L_y]$ 之外，则通过对称性将其反射回域内（例如，如果 $x0$，则设 $x \\leftarrow -x$；如果 $x>L_x$，则设 $x \\leftarrow 2L_x - x$；对 $y$ 进行类似处理）。\n\n从第一性原理出发，使用 Fick 扩散定律和质量守恒来证明连续体更新和边界条件的合理性。双线性插值必须从基于网格的场的局部线性假设推导得出。\n\n对于每个模拟案例，您的程序必须在单个时间步后计算并返回以下三个量：\n- 该步长内的积分汇质量，定义为 $M_{\\mathrm{sink}} = \\Delta t\\sum_{j,k} S_{j,k}\\,h_x\\,h_y$，单位为浓度单位。\n- 连续体更新后，在智能体位置处的梯度平均大小，定义为 $G_{\\mathrm{mean}} = \\frac{1}{N}\\sum_{i=1}^{N}\\|\\nabla c^{n+1}(\\mathbf{x}_i^n)\\|$，单位为浓度/微米。\n- 该步长内智能体的平均位移大小，定义为 $D_{\\mathrm{mean}} = \\frac{1}{N}\\sum_{i=1}^{N}\\|\\mathbf{x}_i^{n+1}-\\mathbf{x}_i^n\\|$，单位为微米。\n\n如果没有智能体（即 $N=0$），则定义 $G_{\\mathrm{mean}}=0$ 和 $D_{\\mathrm{mean}}=0$，并按上述方式计算 $M_{\\mathrm{sink}}$（其值将为 $0$）。\n\n使用以下参数集测试套件。所有长度单位为微米（$\\mu\\mathrm{m}$），时间单位为秒（$\\mathrm{s}$），浓度单位为任意单位：\n- 案例 1（内部智能体，中等扩散）：$L_x=L_y=200$，$N_x=N_y=101$，$\\Delta t=0.002$，$D=100$，$\\chi=0.4$，$\\lambda=0.02$，$\\sigma=3$，初始 $c^0(\\mathbf{x})\\equiv 1.0$，智能体位于 $(60,100)$ 和 $(140,100)$。\n- 案例 2（靠近边界的智能体，较强消耗）：$L_x=L_y=100$，$N_x=N_y=51$，$\\Delta t=0.002$，$D=50$，$\\chi=0.6$，$\\lambda=0.05$，$\\sigma=5$，初始 $c^0(\\mathbf{x})\\equiv 1.0$，一个智能体位于 $(95,5)$。\n- 案例 3（无智能体，高扩散）：$L_x=L_y=150$，$N_x=N_y=75$，$\\Delta t=0.001$，$D=200$，$\\chi=0.1$，$\\lambda=0.05$，$\\sigma=2$，初始 $c^0(\\mathbf{x})\\equiv 0.5$，无智能体。\n- 案例 4（粗网格，中心智能体，慢扩散）：$L_x=L_y=30$，$N_x=N_y=3$，$\\Delta t=0.1$，$D=5$，$\\chi=1.0$，$\\lambda=0.1$，$\\sigma=1$，初始 $c^0(\\mathbf{x})\\equiv 1.0$，一个智能体位于 $(15,15)$。\n\n您的程序应生成单行输出，其中包含四个案例的结果，形式为列表的列表，每个内部列表为该案例的 $[M_{\\mathrm{sink}},G_{\\mathrm{mean}},D_{\\mathrm{mean}}]$，并按上述顺序排列。例如，输出格式必须为\n$$\n\\left[ [m_1,g_1,d_1],[m_2,g_2,d_2],[m_3,g_3,d_3],[m_4,g_4,d_4] \\right],\n$$\n其中每个 $m_k$、$g_k$ 和 $d_k$ 均以指定单位的浮点数报告。",
            "solution": "用户提供了一个有效的问题陈述，描述了一个混合离散-连续趋化模型的单时间步模拟。该模型、参数和数值算法都有科学依据、自洽且定义明确。在介绍计算实现之前，我们先对方法论进行详细的推导和解释。\n\n该问题要求为一个在域 $\\Omega = [0,L_x]\\times[0,L_y]$ 上由以下方程控制的系统，实现一个单一的显式时间步：\n$$\n\\dot{\\mathbf{x}}_i(t) = \\chi \\nabla c(\\mathbf{x}_i(t),t) \\quad (\\text{智能体运动学})\n$$\n$$\n\\partial_t c(\\mathbf{x},t) = D \\nabla^2 c(\\mathbf{x},t) - \\sum_{i=1}^{N} \\lambda \\,\\delta(\\mathbf{x} - \\mathbf{x}_i(t)) \\quad (\\text{连续体动力学})\n$$\n\n### 基于原理的推导和算法设计\n\n**1. 连续体动力学的理论基础**\n\n控制化学引诱物浓度 $c(\\mathbf{x},t)$ 的偏微分方程 (PDE) 是一个从质量守恒原理推导出的反应-扩散方程。对于任何任意的控制体积 $V \\subset \\Omega$，体积 $V$ 内物质总质量的变化率必须等于穿过边界 $\\partial V$ 的物质净通量，加上 $V$ 内部源或汇产生或移除的速率。在数学上，这表示为：\n$$\n\\frac{d}{dt} \\int_V c(\\mathbf{x},t) \\, d\\mathbf{x} = -\\int_{\\partial V} \\mathbf{J} \\cdot \\mathbf{n} \\, dS + \\int_V Q \\, d\\mathbf{x}\n$$\n其中 $\\mathbf{J}$ 是质量通量矢量，$\\mathbf{n}$ 是表面 $\\partial V$ 的外向单位法向量，而 $Q$ 代表每单位体积的净生成速率（源减去汇）。\n\n通量 $\\mathbf{J}$ 由 Fick 第一扩散定律建模，该定律指出物质从高浓度区域向低浓度区域扩散，其通量与浓度梯度成正比：\n$$\n\\mathbf{J} = -D \\nabla c(\\mathbf{x},t)\n$$\n此处，$D$ 是扩散系数，假定为一个正常数。\n\n使用散度定理，我们可以将通量的面积分转换成体积分：\n$$\n\\int_{\\partial V} \\mathbf{J} \\cdot \\mathbf{n} \\, dS = \\int_V (\\nabla \\cdot \\mathbf{J}) \\, d\\mathbf{x}\n$$\n将此式和 Fick 定律代入守恒方程可得：\n$$\n\\int_V \\frac{\\partial c}{\\partial t} \\, d\\mathbf{x} = \\int_V \\left( -\\nabla \\cdot (-D \\nabla c) + Q \\right) \\, d\\mathbf{x} = \\int_V \\left( D \\nabla^2 c + Q \\right) \\, d\\mathbf{x}\n$$\n由于该等式对任意控制体积 $V$ 都必须成立，因此被积函数必须相同。这就得到了逐点的反应-扩散方程：\n$$\n\\frac{\\partial c}{\\partial t} = D \\nabla^2 c + Q\n$$\n汇项 $Q$ 模拟了 $N$ 个离散智能体对化学引诱物的消耗。每个位于位置 $\\mathbf{x}_i(t)$ 的智能体 $i$ 被建模为一个点汇，以恒定速率 $\\lambda$ 消耗物质。这些汇的空间分布使用狄拉克 delta 分布 $\\delta(\\mathbf{x})$ 来表示，从而得到 $Q(\\mathbf{x},t) = -\\sum_{i=1}^{N} \\lambda \\, \\delta(\\mathbf{x} - \\mathbf{x}_i(t))$。这完全确定了控制 PDE。\n\n无通量边界条件 $(\\nabla c) \\cdot \\mathbf{n} = 0$ 意味着没有物质流过域边界。根据 Fick 定律，这等价于 $\\mathbf{J} \\cdot \\mathbf{n} = 0$，代表一个封闭系统（例如，一个密封的培养皿），这是一个常见且具有物理意义的约束。\n\n**2. 单时间步的数值算法**\n\n我们将系统从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$。总体策略是采用显式欧拉时间步进格式。\n\n**步骤 1：空间离散化**\n将域 $\\Omega = [0,L_x]\\times[0,L_y]$ 离散化为一个包含 $N_x \\times N_y$ 个点的均匀笛卡尔网格。网格点为 $(x_j, y_k)$，其中 $x_j = j \\cdot h_x$ ($j \\in \\{0, \\dots, N_x-1\\}$)，$y_k = k \\cdot h_y$ ($k \\in \\{0, \\dots, N_y-1\\}$)。网格间距为 $h_x = L_x / (N_x-1)$ 和 $h_y = L_y / (N_y-1)$。时间 $t_n$ 的浓度场由一个矩阵 $c^n_{j,k} \\approx c(x_j, y_k, t_n)$ 表示。\n\n**步骤 2：连续体场更新**\n使用前向欧拉法更新 PDE：\n$$\n\\frac{c^{n+1} - c^n}{\\Delta t} = D \\nabla^2 c^n - \\sum_{i=1}^{N} \\lambda \\,\\delta(\\mathbf{x} - \\mathbf{x}_i^n)\n$$\n这需要对拉普拉斯算子和狄拉克 delta 项进行离散化。\n\n**拉普拉斯算子：** 拉普拉斯算子 $\\nabla^2 c = \\partial_{xx}c + \\partial_{yy}c$ 使用二阶中心差分进行近似：\n$$\n(\\nabla^2 c)_{j,k} \\approx \\frac{c_{j+1,k} - 2c_{j,k} + c_{j-1,k}}{h_x^2} + \\frac{c_{j,k+1} - 2c_{j,k} + c_{j,k-1}}{h_y^2}\n$$\n为了处理无通量边界条件，我们引入虚拟点。例如，在左边界（$j=0$），条件 $(\\partial_x c)_{0,k} = 0$ 近似为 $(c_{1,k} - c_{-1,k})/(2h_x) = 0$，这意味着 $c_{-1,k} = c_{1,k}$。将此代入 $j=0$ 处的拉普拉斯公式，得到 $(\\nabla^2 c)_{0,k} \\approx \\frac{2(c_{1,k} - c_{0,k})}{h_x^2} + \\dots$。对所有边界实现此方法的一个实用方式是，用一个单元格宽度的层来填充浓度矩阵 $c^n$，其中每个虚拟单元格中的值是相邻内部单元格值的镜像。\n\n**汇项：** 狄拉克 delta $\\delta(\\mathbf{x}-\\mathbf{x}_i^n)$ 是一个分布（广义函数）而非函数，因此不适合在网格上直接求值。它通过替换为一个称为平滑子的光滑、径向对称函数来进行正则化。问题指定了使用归一化高斯函数：\n$$\nG_\\sigma(\\mathbf{x}-\\mathbf{x}_i) = \\frac{1}{2\\pi\\sigma^2}\\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}_i\\|^2}{2\\sigma^2}\\right)\n$$\n参数 $\\sigma$ 控制平滑子的空间范围。然后，通过在每个网格点 $(x_j, y_k)$ 上计算所有智能体的高斯函数之和，来计算网格上的总汇场 $S$：\n$$\nS_{j,k} = \\sum_{i=1}^{N} \\lambda \\, G_\\sigma((x_j, y_k) - \\mathbf{x}_i^n)\n$$\n因此，连续体场的更新规则为：\n$$\nc^{n+1}_{j,k} = c^{n}_{j,k} + \\Delta t \\left( D (\\nabla^2 c^n)_{j,k} - S_{j,k} \\right)\n$$\n\n**步骤 3：智能体状态更新**\n\n**梯度计算：** 更新后的浓度场 $c^{n+1}$ 创造了一个新的化学景观。需要该场的梯度 $\\nabla c^{n+1}$ 来确定智能体的运动。该梯度也使用网格上的二阶中心差分计算：\n$$\n(\\partial_x c)_{j,k} = \\frac{c_{j+1,k} - c_{j-1,k}}{2h_x}, \\quad (\\partial_y c)_{j,k} = \\frac{c_{j,k+1} - c_{j,k-1}}{2h_y}\n$$\n对诺伊曼边界使用相同的虚拟点策略，这会正确地将边界处梯度的法向分量设置为 $0$。\n\n**在智能体位置的梯度插值：** 智能体位于网格外的点 $\\mathbf{x}_i^n$。为了计算梯度 $\\nabla c^{n+1}(\\mathbf{x}_i^n)$，我们使用双线性插值。该方法假设被插值的场是局部线性的。对于一个在由 $(x_j, y_k)$ 和 $(x_{j+1}, y_{k+1})$ 定义的网格单元角落处已知的标量场 $f$，其在内部点 $(x,y)$ 的值可以通过首先沿两条平行边进行线性插值，然后在结果之间再次进行线性插值来估计。这导出了以下公式：\n$$\nf(x,y) \\approx (1-u)(1-v)f_{j,k} + u(1-v)f_{j+1,k} + (1-u)v f_{j,k+1} + uv f_{j+1,k+1}\n$$\n其中 $u = (x - x_j)/h_x$ 和 $v = (y - y_k)/h_y$ 是单元内的归一化坐标。此公式分别应用于计算出的梯度场的分量 $(\\partial_x c^{n+1})_{j,k}$ 和 $(\\partial_y c^{n+1})_{j,k}$，以找到每个智能体当前位置处的插值梯度矢量 $\\nabla c^{n+1}(\\mathbf{x}_i^n)$。\n\n**位置更新：** 根据趋化定律，使用显式欧拉步更新智能体位置：\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\chi \\, \\nabla c^{n+1}(\\mathbf{x}_i^n)\n$$\n这是一种半隐式耦合，因为智能体的运动依赖于在“过去”的智能体位置 $\\mathbf{x}_i^n$ 处计算的“未来”浓度场 $c^{n+1}$。\n\n**反射边界：** 为确保智能体保持在域 $\\Omega$ 内，应用反射边界条件。如果一个更新后的坐标，例如 $x'_i = x_i^{n+1}$，超出了其允许范围，它将被反射回来。例如，如果 $x'_i  0$，新位置变为 $-x'_i$。如果 $x'_i > L_x$，它将变为 $L_x - (x'_i - L_x) = 2L_x - x'_i$。这模拟了与域壁的完全弹性碰撞。\n\n这就完成了耦合混合系统的单个完全显式时间步的全部过程。输出量 $M_{\\mathrm{sink}}$、$G_{\\mathrm{mean}}$ 和 $D_{\\mathrm{mean}}$ 是根据此过程中计算出的量直接得出的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_single_step(Lx, Ly, Nx, Ny, dt, D, chi, lam, sigma, c0_val, agents_initial):\n    \"\"\"\n    Computes a single time step of the hybrid discrete-continuum model.\n    \"\"\"\n    # 1. Grid setup\n    hx = Lx / (Nx - 1)\n    hy = Ly / (Ny - 1)\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    c_n = np.full((Nx, Ny), c0_val)\n    agents_n = np.array(agents_initial, dtype=float)\n    N = agents_n.shape[0]\n\n    # Handle N=0 case\n    if N == 0:\n        # Sink field is zero\n        S = np.zeros_like(c_n)\n        # Laplacian of a constant field is zero\n        lap_c = np.zeros_like(c_n)\n        # Concentration does not change\n        c_n_plus_1 = c_n + dt * (D * lap_c - S)\n        # Agents do not move\n        agents_n_plus_1 = agents_n\n\n        M_sink = 0.0\n        G_mean = 0.0\n        D_mean = 0.0\n        return [M_sink, G_mean, D_mean]\n\n    # 3. Approximate sink field using Gaussian mollifier\n    S = np.zeros_like(c_n)\n    sigma_sq = sigma**2\n    for i in range(N):\n        xi, yi = agents_n[i]\n        dist_sq = (xx - xi)**2 + (yy - yi)**2\n        gaussian = (1 / (2 * np.pi * sigma_sq)) * np.exp(-dist_sq / (2 * sigma_sq))\n        S += lam * gaussian\n\n    # 2. Approximate Laplacian on c_n using central differences with Neumann BCs\n    # 'reflect' mode for np.pad correctly implements the ghost point values for\n    # a second-order accurate Neumann condition where c_(-1) = c_1.\n    c_padded = np.pad(c_n, 1, mode='reflect')\n    lap_c_x = (c_padded[2:, 1:-1] - 2 * c_padded[1:-1, 1:-1] + c_padded[:-2, 1:-1]) / hx**2\n    lap_c_y = (c_padded[1:-1, 2:] - 2 * c_padded[1:-1, 1:-1] + c_padded[1:-1, :-2]) / hy**2\n    lap_c = lap_c_x + lap_c_y\n\n    # 4. Update continuum field using explicit Euler step\n    c_n_plus_1 = c_n + dt * (D * lap_c - S)\n\n    # 5. Compute gradient of c_n+1 and evaluate at agent positions\n    # Use padding for Neumann BCs, which sets normal gradient component to 0 at boundary.\n    c_p1_padded = np.pad(c_n_plus_1, 1, mode='reflect')\n    grad_c_x = (c_p1_padded[2:, 1:-1] - c_p1_padded[:-2, 1:-1]) / (2 * hx)\n    grad_c_y = (c_p1_padded[1:-1, 2:] - c_p1_padded[1:-1, :-2]) / (2 * hy)\n\n    grad_c_at_agents = np.zeros((N, 2))\n    for i in range(N):\n        xi, yi = agents_n[i]\n\n        # Find bottom-left grid cell index for interpolation\n        # Clamp index to ensure the 4-point stencil is within the grid\n        j = min(int(xi / hx), Nx - 2)\n        k = min(int(yi / hy), Ny - 2)\n\n        # Compute normalized coordinates within the cell\n        u = (xi - j * hx) / hx\n        v = (yi - k * hy) / hy\n\n        # Bilinear interpolation for gradient in x\n        g_x = grad_c_x[j:j+2, k:k+2]\n        interp_grad_x = (g_x[0, 0] * (1 - u) * (1 - v) +\n                         g_x[1, 0] * u * (1 - v) +\n                         g_x[0, 1] * (1 - u) * v +\n                         g_x[1, 1] * u * v)\n\n        # Bilinear interpolation for gradient in y\n        g_y = grad_c_y[j:j+2, k:k+2]\n        interp_grad_y = (g_y[0, 0] * (1 - u) * (1 - v) +\n                         g_y[1, 0] * u * (1 - v) +\n                         g_y[0, 1] * (1 - u) * v +\n                         g_y[1, 1] * u * v)\n\n        grad_c_at_agents[i, 0] = interp_grad_x\n        grad_c_at_agents[i, 1] = interp_grad_y\n\n    # 6. Update agent positions\n    velocities = chi * grad_c_at_agents\n    agents_n_plus_1 = agents_n + dt * velocities\n    \n    # Enforce reflective boundary conditions\n    # This loop could be vectorized but is clear and not a bottleneck for small N.\n    for i in range(N):\n        if agents_n_plus_1[i, 0]  0:\n            agents_n_plus_1[i, 0] = -agents_n_plus_1[i, 0]\n        elif agents_n_plus_1[i, 0] > Lx:\n            agents_n_plus_1[i, 0] = 2 * Lx - agents_n_plus_1[i, 0]\n\n        if agents_n_plus_1[i, 1]  0:\n            agents_n_plus_1[i, 1] = -agents_n_plus_1[i, 1]\n        elif agents_n_plus_1[i, 1] > Ly:\n            agents_n_plus_1[i, 1] = 2 * Ly - agents_n_plus_1[i, 1]\n\n    # Calculate required outputs\n    # M_sink: Integrated sink mass\n    M_sink = dt * np.sum(S) * hx * hy\n    \n    # G_mean: Mean gradient magnitude at agent locations\n    grad_magnitudes = np.linalg.norm(grad_c_at_agents, axis=1)\n    G_mean = np.mean(grad_magnitudes)\n\n    # D_mean: Mean displacement magnitude\n    displacement_vectors = agents_n_plus_1 - agents_n\n    displacement_magnitudes = np.linalg.norm(displacement_vectors, axis=1)\n    D_mean = np.mean(displacement_magnitudes)\n    \n    return [M_sink, G_mean, D_mean]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'Lx': 200, 'Ly': 200, 'Nx': 101, 'Ny': 101, 'dt': 0.002, 'D': 100, \n         'chi': 0.4, 'lam': 0.02, 'sigma': 3, 'c0_val': 1.0, \n         'agents_initial': [(60, 100), (140, 100)]},\n        # Case 2\n        {'Lx': 100, 'Ly': 100, 'Nx': 51, 'Ny': 51, 'dt': 0.002, 'D': 50, \n         'chi': 0.6, 'lam': 0.05, 'sigma': 5, 'c0_val': 1.0, \n         'agents_initial': [(95, 5)]},\n        # Case 3\n        {'Lx': 150, 'Ly': 150, 'Nx': 75, 'Ny': 75, 'dt': 0.001, 'D': 200, \n         'chi': 0.1, 'lam': 0.05, 'sigma': 2, 'c0_val': 0.5, \n         'agents_initial': []},\n        # Case 4\n        {'Lx': 30, 'Ly': 30, 'Nx': 3, 'Ny': 3, 'dt': 0.1, 'D': 5, \n         'chi': 1.0, 'lam': 0.1, 'sigma': 1, 'c0_val': 1.0, \n         'agents_initial': [(15, 15)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_single_step(**case)\n        results.append(result)\n\n    # Format output as a list of lists without extra spaces\n    inner_list_strs = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_list_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}