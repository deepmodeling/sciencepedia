{
    "hands_on_practices": [
        {
            "introduction": "A foundational question in controlling any system is whether the chosen inputs can influence all the internal states of interest. In a biomedical context, such as drug delivery, this translates to asking if an intravenous infusion can be manipulated to achieve a desired drug concentration in not just the blood plasma, but also in peripheral tissues and at the specific site of drug action. This exercise provides direct practice in answering this question by applying the fundamental concept of controllability to a multi-compartment pharmacokinetic model .",
            "id": "4331177",
            "problem": "A three-compartment intravenous drug delivery system is modeled using a linear compartmental framework based on mass conservation and first-order kinetics. Let the states be $x_{1}(t)$, $x_{2}(t)$, and $x_{3}(t)$, representing drug amounts in plasma, peripheral tissue, and effect site, respectively. The intercompartmental exchange and elimination dynamics are characterized by constant rate parameters, yielding a Linear Time-Invariant (LTI) state-space model of the form $\\dot{x}(t) = A x(t) + B u(t)$, where $u(t)$ is the infusion rate.\n\nThe biological parameters (all in $\\text{hr}^{-1}$) are: plasma elimination $k_{e} = 0.5$, plasma-to-peripheral transfer $k_{12} = 0.3$, peripheral-to-plasma transfer $k_{21} = 0.25$, plasma-to-effect-site transfer $k_{13} = 0.2$, effect-site-to-plasma transfer $k_{31} = 0.15$, peripheral elimination $k_{e2} = 0.05$, and effect-site elimination $k_{e3} = 0.1$. Infusion enters only the plasma compartment with unit gain. The resulting matrices are\n$$\nA = \\begin{pmatrix}\n-(k_{e}+k_{12}+k_{13})  k_{21}  k_{31} \\\\\nk_{12}  -(k_{21}+k_{e2})  0 \\\\\nk_{13}  0  -(k_{31}+k_{e3})\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-1.0  0.25  0.15 \\\\\n0.3  -0.3  0 \\\\\n0.2  0  -0.25\n\\end{pmatrix},\n\\quad\nB = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n\nConstruct the controllability matrix $\\mathcal{C}$ whose columns are $B$, $A B$, and $A^{2} B$, and evaluate its rank. Using the rank condition for controllability of LTI systems, determine whether the system is controllable. Report only the rank of $\\mathcal{C}$ as your final answer. No rounding is needed. Do not include any units in your final answer.",
            "solution": "The user has provided a problem statement describing a three-compartment model for intravenous drug delivery, formulated as a Linear Time-Invariant (LTI) state-space system. The task is to evaluate the controllability of this system.\n\nFirst, the validity of the problem statement is assessed.\nThe givens are:\n- An LTI state-space model $\\dot{x}(t) = A x(t) + B u(t)$.\n- The state vector $x(t) \\in \\mathbb{R}^3$ represents drug amounts in three compartments.\n- The state matrix $A$ and input matrix $B$ are given as:\n$$\nA = \\begin{pmatrix}\n-1.0  0.25  0.15 \\\\\n0.3  -0.3  0 \\\\\n0.2  0  -0.25\n\\end{pmatrix},\n\\quad\nB = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n- The problem defines the controllability matrix as $\\mathcal{C} = \\begin{pmatrix} B  A B  A^2 B \\end{pmatrix}$.\n- The objective is to find the rank of $\\mathcal{C}$ and determine if the system is controllable.\n\nThe problem is scientifically grounded, employing standard compartmental analysis and control theory principles (LTI systems, controllability). The provided parameters and the resulting matrix $A$ are consistent with the model's structural definition. The problem is well-posed, objective, and self-contained, with no apparent contradictions or ambiguities. It presents a standard, solvable problem in control theory. Thus, the problem is deemed valid.\n\nThe solution proceeds by constructing the controllability matrix and determining its rank. The state-space dimension is $n=3$. The controllability matrix $\\mathcal{C}$ is a $3 \\times 3$ matrix given by $\\mathcal{C} = \\begin{pmatrix} B  AB  A^2 B \\end{pmatrix}$.\n\nThe columns of $\\mathcal{C}$ are computed sequentially.\nThe first column is the input matrix $B$:\n$$ B = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n\nThe second column is the product $AB$:\n$$ AB = \\begin{pmatrix} -1.0  0.25  0.15 \\\\ 0.3  -0.3  0 \\\\ 0.2  0  -0.25 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (-1.0)(1) + (0.25)(0) + (0.15)(0) \\\\ (0.3)(1) + (-0.3)(0) + (0)(0) \\\\ (0.2)(1) + (0)(0) + (-0.25)(0) \\end{pmatrix} = \\begin{pmatrix} -1.0 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} $$\n\nThe third column is the product $A^2 B = A(AB)$:\n$$ A^2 B = \\begin{pmatrix} -1.0  0.25  0.15 \\\\ 0.3  -0.3  0 \\\\ 0.2  0  -0.25 \\end{pmatrix} \\begin{pmatrix} -1.0 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} = \\begin{pmatrix} (-1.0)(-1.0) + (0.25)(0.3) + (0.15)(0.2) \\\\ (0.3)(-1.0) + (-0.3)(0.3) + (0)(0.2) \\\\ (0.2)(-1.0) + (0)(0.3) + (-0.25)(0.2) \\end{pmatrix} $$\n$$ A^2 B = \\begin{pmatrix} 1.0 + 0.075 + 0.03 \\\\ -0.3 - 0.09 + 0 \\\\ -0.2 + 0 - 0.05 \\end{pmatrix} = \\begin{pmatrix} 1.105 \\\\ -0.39 \\\\ -0.25 \\end{pmatrix} $$\n\nNow, the controllability matrix $\\mathcal{C}$ is assembled from these column vectors:\n$$ \\mathcal{C} = \\begin{pmatrix} 1  -1.0  1.105 \\\\ 0  0.3  -0.39 \\\\ 0  0.2  -0.25 \\end{pmatrix} $$\n\nTo find the rank of $\\mathcal{C}$, we can compute its determinant. A $3 \\times 3$ matrix has rank $3$ if and only if its determinant is non-zero. We use cofactor expansion along the first column:\n$$ \\det(\\mathcal{C}) = (1) \\det \\begin{pmatrix} 0.3  -0.39 \\\\ 0.2  -0.25 \\end{pmatrix} - (0) \\det \\begin{pmatrix} -1.0  1.105 \\\\ 0.2  -0.25 \\end{pmatrix} + (0) \\det \\begin{pmatrix} -1.0  1.105 \\\\ 0.3  -0.39 \\end{pmatrix} $$\n$$ \\det(\\mathcal{C}) = (1) \\left[ (0.3)(-0.25) - (-0.39)(0.2) \\right] $$\n$$ \\det(\\mathcal{C}) = -0.075 - (-0.078) $$\n$$ \\det(\\mathcal{C}) = -0.075 + 0.078 = 0.003 $$\n\nSince $\\det(\\mathcal{C}) = 0.003 \\neq 0$, the matrix $\\mathcal{C}$ is non-singular and its columns are linearly independent. Therefore, the rank of the $3 \\times 3$ matrix $\\mathcal{C}$ is $3$.\n\nThe rank condition for controllability states that an LTI system is controllable if and only if the rank of its controllability matrix is equal to the dimension of the state space, $n$. In this case, $\\text{rank}(\\mathcal{C}) = 3$ and $n=3$. Since $\\text{rank}(\\mathcal{C}) = n$, the system is controllable. This means it is possible, with a suitable control input $u(t)$, to steer the state of the system from any initial state to any final state in a finite time interval.\n\nThe problem asks for the rank of $\\mathcal{C}$.\nThe rank of $\\mathcal{C}$ is $3$.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "Biological processes are rarely instantaneous; delays arising from transcription, translation, and transport are ubiquitous. While negative feedback is a classic stabilizing mechanism, the presence of a significant time delay can fundamentally alter a system's behavior, transforming a stable equilibrium into a state of sustained oscillation. This practice explores this critical phenomenon by analyzing a simple gene-autoregulation model, guiding you through the derivation of the critical delay that triggers a Hopf bifurcation—the mathematical gateway to oscillatory dynamics .",
            "id": "4331150",
            "problem": "A single-gene autoregulatory module in a Gene Regulatory Network (GRN) can be linearized near its steady state to a scalar Delay Differential Equation (DDE) describing small deviations $x(t)$ of the protein concentration from equilibrium under delayed negative feedback due to transcription, translation, and transport times. The linearized model takes the form $\\frac{dx(t)}{dt} = -a\\,x(t) - b\\,x(t-\\tau)$ with $a>0$, $b>0$, and delay $\\tau>0$. Assuming solutions of the form $x(t) = \\exp(s t)$ yields the characteristic equation $s + a + b \\exp(-s \\tau) = 0$. A Hopf bifurcation occurs when a complex-conjugate pair of characteristic roots crosses the imaginary axis, thereby creating oscillations in the protein concentration.\n\nStarting from the characteristic equation and the definition of a Hopf bifurcation as an imaginary-axis crossing of the linearized characteristic roots, derive an analytic expression for the smallest positive delay $\\tau_c$ at which such a crossing occurs, expressed in terms of $a$ and $b$, under the condition $b>a$ that ensures oscillatory onset is possible. Then compute $\\tau_c$ for $a=1\\,\\text{min}^{-1}$ and $b=2\\,\\text{min}^{-1}$. Express the final value of $\\tau_c$ in minutes. No rounding is required.",
            "solution": "The problem asks for the derivation of the critical time delay $\\tau_c$ at which a single-gene autoregulatory system undergoes a Hopf bifurcation, and for the calculation of this value for a specific set of parameters.\n\nThe starting point is the characteristic equation of the linearized system, given as:\n$$s + a + b \\exp(-s \\tau) = 0$$\nwhere $a > 0$, $b > 0$, and $\\tau > 0$ are system parameters. A Hopf bifurcation occurs when a pair of complex-conjugate roots of this equation crosses the imaginary axis of the complex plane. This means we are looking for a purely imaginary root, which can be written as $s = i\\omega_c$, where $\\omega_c$ is the real-valued, non-zero frequency of oscillation at the bifurcation point. Since the system parameters $a$ and $b$ are real, if $i\\omega_c$ is a root, its complex conjugate $-i\\omega_c$ must also be a root. We can, without loss of generality, assume $\\omega_c > 0$.\n\nLet $\\tau_c$ be the critical delay at which this crossing happens. Substituting $s = i\\omega_c$ into the characteristic equation gives:\n$$i\\omega_c + a + b \\exp(-i\\omega_c \\tau_c) = 0$$\n\nTo solve for $\\omega_c$ and $\\tau_c$, we use Euler's formula, $\\exp(-i\\theta) = \\cos(\\theta) - i\\sin(\\theta)$, to expand the exponential term:\n$$i\\omega_c + a + b(\\cos(\\omega_c \\tau_c) - i\\sin(\\omega_c \\tau_c)) = 0$$\n\nNext, we separate the equation into its real and imaginary parts. For the equation to hold, both parts must independently be equal to zero.\n$$ (a + b\\cos(\\omega_c \\tau_c)) + i(\\omega_c - b\\sin(\\omega_c \\tau_c)) = 0 $$\n\nThis yields a system of two equations:\n1. Real part: $a + b\\cos(\\omega_c \\tau_c) = 0$\n2. Imaginary part: $\\omega_c - b\\sin(\\omega_c \\tau_c) = 0$\n\nWe can rearrange these equations to isolate the trigonometric terms:\n$$\\cos(\\omega_c \\tau_c) = -\\frac{a}{b}$$\n$$\\sin(\\omega_c \\tau_c) = \\frac{\\omega_c}{b}$$\n\nTo find the frequency $\\omega_c$, we can eliminate $\\tau_c$ by using the fundamental trigonometric identity $\\sin^2(\\theta) + \\cos^2(\\theta) = 1$. Squaring both equations and adding them together gives:\n$$\\left(\\frac{\\omega_c}{b}\\right)^2 + \\left(-\\frac{a}{b}\\right)^2 = 1$$\n$$\\frac{\\omega_c^2}{b^2} + \\frac{a^2}{b^2} = 1$$\nMultiplying by $b^2$ yields:\n$$\\omega_c^2 + a^2 = b^2$$\nSolving for $\\omega_c^2$, we get:\n$$\\omega_c^2 = b^2 - a^2$$\nSince we assumed $\\omega_c > 0$, we take the positive square root:\n$$\\omega_c = \\sqrt{b^2 - a^2}$$\nFor $\\omega_c$ to be a real and non-zero frequency, we must have $b^2 - a^2 > 0$. Since $a$ and $b$ are positive, this is equivalent to the condition $b > a$, which is explicitly given in the problem statement as a prerequisite for the oscillatory onset. This confirms the consistency of the problem's formulation.\n\nNow we can solve for the critical delay $\\tau_c$. We have an expression for the angle $\\omega_c \\tau_c$ from the sine and cosine equations. Specifically, $\\cos(\\omega_c \\tau_c) = -a/b$. The general solution for an angle whose cosine is known is given by the inverse cosine function plus integer multiples of $2\\pi$.\n$$\\omega_c \\tau_c = \\arccos\\left(-\\frac{a}{b}\\right) + 2k\\pi, \\quad k \\in \\{0, 1, 2, \\dots\\}$$\nHere, $\\arccos$ denotes the principal value, which for an argument in $[-1, 1]$ returns an angle in $[0, \\pi]$. Since $a, b > 0$ and $b > a$, the argument $-a/b$ lies in $(-1, 0)$, and thus $\\arccos(-a/b)$ lies in $(\\pi/2, \\pi)$.\n\nSolving for $\\tau_c$:\n$$\\tau_c = \\frac{1}{\\omega_c} \\left( \\arccos\\left(-\\frac{a}{b}\\right) + 2k\\pi \\right)$$\nSubstituting the expression for $\\omega_c$:\n$$\\tau_c = \\frac{1}{\\sqrt{b^2 - a^2}} \\left( \\arccos\\left(-\\frac{a}{b}\\right) + 2k\\pi \\right)$$\nThe problem asks for the smallest positive delay $\\tau_c$. Since $\\omega_c = \\sqrt{b^2-a^2} > 0$ and $\\arccos(-a/b) \\in (\\pi/2, \\pi)$ is positive, the smallest positive value for $\\tau_c$ is obtained by setting the integer $k=0$.\nThis gives the analytical expression for the smallest critical delay:\n$$\\tau_c = \\frac{1}{\\sqrt{b^2 - a^2}} \\arccos\\left(-\\frac{a}{b}\\right)$$\n\nNow, we compute the value of $\\tau_c$ for the given parameters $a = 1\\,\\text{min}^{-1}$ and $b = 2\\,\\text{min}^{-1}$.\nFirst, we verify the condition $b > a$: $2 > 1$, which is true.\nNext, we calculate the bifurcation frequency $\\omega_c$:\n$$\\omega_c = \\sqrt{b^2 - a^2} = \\sqrt{2^2 - 1^2} = \\sqrt{4 - 1} = \\sqrt{3}\\,\\text{min}^{-1}$$\nThen, we calculate the critical delay $\\tau_c$:\n$$\\tau_c = \\frac{1}{\\sqrt{3}} \\arccos\\left(-\\frac{1}{2}\\right)$$\nThe principal value of the arccosine of $-1/2$ is the angle $\\theta \\in [0, \\pi]$ such that $\\cos(\\theta) = -1/2$. This angle is $\\theta = \\frac{2\\pi}{3}$ radians.\nSubstituting this value gives:\n$$\\tau_c = \\frac{1}{\\sqrt{3}} \\left(\\frac{2\\pi}{3}\\right) = \\frac{2\\pi}{3\\sqrt{3}}\\,\\text{min}$$\nThe resulting value is in minutes, as required.",
            "answer": "$$\\boxed{\\frac{2\\pi}{3\\sqrt{3}}}$$"
        },
        {
            "introduction": "Beyond analyzing existing systems, a key application of control theory in biology is to proactively design experiments that yield the most informative data. Given constraints on total dosage and administration rates for safety and feasibility, how can one design a dosing schedule to best uncover an unknown biological parameter, such as a molecule's degradation rate? This advanced practice moves from analysis to synthesis, challenging you to maximize the Fisher information—a formal measure of parameter uncertainty—by finding an optimal input sequence under realistic constraints, a core problem in the field of optimal experiment design .",
            "id": "4331135",
            "problem": "You are designing an input (dose) sequence to interrogate a simple first-order biological process in discrete time under safety constraints. The underlying system is a single-compartment linear time-invariant model that represents the accumulation and clearance of a measurable molecular species in response to an externally applied, nonnegative input dose. Let the state be $x_k$ at discrete time index $k \\in \\{0,1,\\dots\\}$, with initial condition $x_0 = 0$. The dynamics are given by $x_{k+1} = \\alpha x_k + u_k$, where $\\alpha = \\exp(-k_d \\Delta t)$ with $k_d \\ge 0$ the degradation rate constant and $\\Delta t > 0$ the sampling interval. The measured output at each sampling instant is $y_k = x_k + v_k$, where $v_k$ are independent zero-mean Gaussian random variables with variance $\\sigma^2$. All quantities are normalized and dimensionless; thus, you should give answers in dimensionless units.\n\nThe objective is to choose a finite-horizon nonnegative input sequence $\\{u_0, u_1, \\dots, u_{N-1}\\}$ that maximizes the expected information about the degradation rate constant $k_d$ contained in the outputs $\\{y_1,\\dots,y_N\\}$ under independent Gaussian noise. To make the problem computationally well-posed and to reflect experimental safety constraints, the inputs must satisfy both a per-time-step cap and a total dose budget:\n- Nonnegativity and per-step cap: $0 \\le u_k \\le u_{\\max}$ for each $k \\in \\{0,\\dots,N-1\\}$.\n- Total dose budget: $\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$.\n\nThe information about $k_d$ in Gaussian observations is quantified by the Fisher Information Matrix (FIM) for a scalar parameter, which reduces to a nonnegative scalar. You must use the standard definition of Fisher information for independent Gaussian noise and derive a computable expression in terms of the input sequence and the model sensitivities with respect to $k_d$.\n\nFor algorithmic tractability and to capture protocol granularity, restrict the input values to a uniform grid with spacing $\\delta > 0$, so that each $u_k$ is constrained to the set $\\{0, \\delta, 2\\delta, \\dots, u_{\\max}\\}$ and $\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$. Assume that $u_{\\max}$ and $D_{\\max}$ are integer multiples of $\\delta$ for all test cases.\n\nYour task is to:\n- From first principles, compute the Fisher information about $k_d$ as a function of the input sequence for the stated model and noise assumptions.\n- Over the discrete feasible set described above, find an input sequence that maximizes this Fisher information subject to the dose constraints.\n- In the event of multiple sequences achieving the same maximal Fisher information, break ties by choosing the lexicographically largest sequence, that is, comparing dose sequences element-wise from earliest to latest and selecting the one with the first strictly larger element.\n\nUse the following test suite of parameter sets, each specified as a tuple $(N,\\ \\Delta t,\\ k_d,\\ \\sigma,\\ u_{\\max},\\ D_{\\max},\\ \\delta)$:\n- Case A: $(5,\\ 1.0,\\ 0.3,\\ 0.1,\\ 0.8,\\ 2.0,\\ 0.1)$.\n- Case B: $(5,\\ 1.0,\\ 0.3,\\ 0.1,\\ 0.5,\\ 0.4,\\ 0.1)$.\n- Case C: $(6,\\ 1.0,\\ 1.2,\\ 0.2,\\ 0.5,\\ 1.5,\\ 0.1)$.\n\nYour program must compute, for each case, an optimal sequence $\\{u_k\\}_{k=0}^{N-1}$ that maximizes the Fisher information about $k_d$ under the stated constraints and tie-breaking rule.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a bracket-enclosed comma-separated list of the optimal doses for each time step for the corresponding case, with each dose reported to one decimal place. For example, a valid output format with three cases is of the form $[\\,[0.0,0.1,0.1],\\,[0.2,0.2,0.0],\\,[0.5,0.5,0.5,0.0]\\,]$.",
            "solution": "### Solution Derivation\n\nThe solution process involves three main steps: deriving the objective function (Fisher Information), formulating the constrained optimization problem, and designing an algorithm to solve it.\n\n**1. Fisher Information Formulation**\nThe Fisher Information, $I(\\theta)$, for a scalar parameter $\\theta$ from a set of $N$ independent measurements $\\{y_k\\}_{k=1}^N$, each with Gaussian noise of constant variance $\\sigma^2$, is given by:\n$$ I(\\theta) = \\sum_{k=1}^{N} \\frac{1}{\\operatorname{Var}(y_k)} \\left( \\frac{\\partial \\mathbb{E}[y_k]}{\\partial \\theta} \\right)^2 $$\nIn this problem, the parameter of interest is $\\theta = k_d$. The measurements are $y_k = x_k + v_k$, where $v_k \\sim \\mathcal{N}(0, \\sigma^2)$. The expected value of the output is $\\mathbb{E}[y_k] = \\mathbb{E}[x_k + v_k] = x_k + \\mathbb{E}[v_k] = x_k$. The variance is $\\operatorname{Var}(y_k) = \\sigma^2$.\nSubstituting these into the formula, the Fisher Information for $k_d$ is:\n$$ I(k_d) = \\frac{1}{\\sigma^2} \\sum_{k=1}^{N} \\left( \\frac{\\partial x_k}{\\partial k_d} \\right)^2 $$\nThe goal is to choose the input sequence $\\{u_0, \\dots, u_{N-1}\\}$ to maximize $I(k_d)$. Since $\\sigma^2$ is a positive constant for each test case, this is equivalent to maximizing the sum of squared sensitivities, which we denote by $J$:\n$$ J(\\{u_k\\}) = \\sum_{k=1}^{N} s_k^2 \\quad \\text{where} \\quad s_k = \\frac{\\partial x_k}{\\partial k_d} $$\n\n**2. Sensitivity Analysis**\nTo compute the objective function $J$, we must derive an expression for the sensitivities $s_k$. We can do this by differentiating the state equation with respect to $k_d$.\nThe state equation is $x_{k+1} = \\alpha x_k + u_k$, with $\\alpha = e^{-k_d \\Delta t}$.\nDifferentiating with respect to $k_d$:\n$$ \\frac{\\partial x_{k+1}}{\\partial k_d} = \\frac{\\partial \\alpha}{\\partial k_d} x_k + \\alpha \\frac{\\partial x_k}{\\partial k_d} $$\nWe first find the derivative of $\\alpha$:\n$$ \\frac{\\partial \\alpha}{\\partial k_d} = \\frac{\\partial}{\\partial k_d} \\left( e^{-k_d \\Delta t} \\right) = -\\Delta t \\cdot e^{-k_d \\Delta t} = -\\Delta t \\cdot \\alpha $$\nSubstituting this back and using the definition $s_k = \\frac{\\partial x_k}{\\partial k_d}$, we obtain the dynamics for the sensitivities:\n$$ s_{k+1} = (-\\Delta t \\cdot \\alpha) x_k + \\alpha s_k = \\alpha(s_k - \\Delta t \\cdot x_k) $$\nThe initial conditions are $x_0 = 0$ and $s_0 = \\frac{\\partial x_0}{\\partial k_d} = \\frac{\\partial 0}{\\partial k_d} = 0$. While these recursive equations can be simulated alongside the state $x_k$, a more direct closed-form expression for $s_k$ can be derived.\nThe closed-form solution for the state $x_k$ starting from $x_0=0$ is:\n$$ x_k = \\sum_{j=0}^{k-1} \\alpha^{k-1-j} u_j $$\nDifferentiating with respect to $k_d$:\n$$ s_k = \\frac{\\partial x_k}{\\partial k_d} = \\sum_{j=0}^{k-1} \\frac{\\partial(\\alpha^{k-1-j})}{\\partial k_d} u_j $$\nUsing the chain rule, $\\frac{\\partial(\\alpha^m)}{\\partial k_d} = m\\alpha^{m-1} \\frac{\\partial \\alpha}{\\partial k_d} = m\\alpha^{m-1}(-\\Delta t \\cdot \\alpha) = -m\\Delta t \\alpha^m$.\nSubstituting this into the expression for $s_k$:\n$$ s_k = \\sum_{j=0}^{k-1} \\left( -(k-1-j)\\Delta t \\alpha^{k-1-j} \\right) u_j = -\\Delta t \\sum_{j=0}^{k-1} (k-1-j) \\alpha^{k-1-j} u_j $$\nThis expression allows for the direct calculation of each $s_k$ from the input sequence $\\{u_j\\}$, which is computationally more efficient and numerically stable than simulating the coupled recurrence relations for $x_k$ and $s_k$.\n\n**3. Optimization and Algorithmic Design**\nThe problem is to find an input sequence $\\{u_0, \\dots, u_{N-1}\\}$ that solves:\n$$ \\max_{\\{u_k\\}} J = \\sum_{k=1}^{N} \\left( -\\Delta t \\sum_{j=0}^{k-1} (k-1-j)\\alpha^{k-1-j}u_j \\right)^2 $$\nsubject to the constraints:\n1. $u_k \\in \\{0, \\delta, 2\\delta, \\dots, u_{\\max}\\}$ for $k \\in \\{0, \\dots, N-1\\}$\n2. $\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$\n\nThis is a combinatorial optimization problem over a discrete, finite set. For the small values of $N$ in the test cases ($5$ and $6$), an exhaustive search of all feasible sequences is computationally tractable. We design a backtracking (recursive) algorithm to perform this search.\n\nTo simplify the search, we represent each dose $u_k$ as an integer multiple of $\\delta$, i.e., $u_k = m_k \\delta$ where $m_k$ is an integer. The constraints become:\n1. $m_k \\in \\{0, 1, \\dots, u_{\\max}/\\delta\\}$\n2. $\\sum_{k=0}^{N-1} m_k \\le D_{\\max}/\\delta$\n\nThe algorithm proceeds as follows:\nA recursive function, say `find_sequences_recursive(k, current_sequence, current_sum)`, is defined.\n- `k` is the current time index ($0$ to $N$) for which a dose is being chosen.\n- `current_sequence` stores the integer-multiple doses $\\{m_0, \\dots, m_{k-1}\\}$ chosen so far.\n- `current_sum` is the sum of integer-multiple doses chosen so far.\n\nThe base case for the recursion is when $k=N$, meaning a full sequence has been generated. At this point, the Fisher Information metric $J$ is calculated for this sequence. This value is compared with the maximum information found so far. If the new value is greater, it becomes the new maximum, and the current sequence is stored as the best. If the new value is equal to the maximum, the current sequence is compared lexicographically with the best sequence found so far. If it is lexicographically larger, it replaces the current best sequence, satisfying the tie-breaking rule.\n\nThe recursive step involves iterating through all valid integer doses $m_k$ for the current time step $k$. A dose $m_k$ is valid if it does not exceed the per-step limit ($m_k \\le u_{\\max}/\\delta$) and does not violate the total budget when added to the current sum ($current\\_sum + m_k \\le D_{\\max}/\\delta$). For each valid $m_k$, the function calls itself for the next time step, `find_sequences_recursive(k+1, ...)`. This systematically explores the entire tree of feasible sequences.\nThis method guarantees finding the globally optimal sequence according to the specified criteria.\n\n```python\nimport numpy as np\nimport math\n\nclass OptimalDoseFinder:\n    \"\"\"\n    Finds the optimal dosing sequence to maximize Fisher Information for k_d.\n    \n    This class implements a systematic search over a discrete set of possible \n    input sequences to find one that maximizes the Fisher Information about a \n    model parameter, subject to per-step and total dose constraints.\n    \"\"\"\n    def __init__(self, N, delta_t, k_d, u_max, d_max, delta):\n        \"\"\"\n        Initializes the finder with problem parameters.\n\n        Args:\n            N (int): Horizon length.\n            delta_t (float): Sampling interval.\n            k_d (float): Degradation rate constant.\n            u_max (float): Maximum dose per time step.\n            d_max (float): Maximum total dose.\n            delta (float): Granularity of dose.\n        \"\"\"\n        self.N = N\n        self.delta_t = delta_t\n        self.k_d = k_d\n        self.u_max = u_max\n        self.d_max = d_max\n        self.delta = delta\n\n        # Pre-calculate constants for the search\n        self.alpha = math.exp(-self.k_d * self.delta_t)\n        self.u_max_int = round(self.u_max / self.delta)\n        self.d_max_int = round(self.d_max / self.delta)\n\n        # State for the search algorithm\n        self.max_info = -1.0\n        self.best_sequence_float = []\n        \n        # Tolerance for floating point comparisons of the Fisher Information\n        self.TOL = 1e-9\n\n    def _calculate_fisher_info(self, u_sequence_int):\n        \"\"\"\n        Calculates the Fisher Information metric for a given integer dose sequence.\n        The metric is sum(s_k^2), where s_k is the sensitivity.\n        \"\"\"\n        u_sequence = [val * self.delta for val in u_sequence_int]\n        total_info = 0.0\n        \n        # Calculate s_k for k=1 to N and sum their squares\n        for k in range(1, self.N + 1):\n            s_k = 0.0\n            # s_k = -delta_t * sum_{j=0}^{k-1} (k-1-j) * alpha^(k-1-j) * u_j\n            for j in range(k):  # j iterates from 0 to k-1\n                exponent = k - 1 - j\n                if exponent > 0:\n                    term = (exponent) * (self.alpha ** exponent) * u_sequence[j]\n                    s_k += term\n            \n            s_k *= -self.delta_t\n            total_info += s_k**2\n            \n        return total_info\n\n    def _find_sequences_recursive(self, k, current_sequence_int, current_sum_int):\n        \"\"\"\n        Recursively explores all feasible dose sequences using backtracking.\n        \n        Args:\n            k (int): The current time step to choose a dose for (from 0 to N-1).\n            current_sequence_int (list): The list of integer doses chosen so far.\n            current_sum_int (int): The sum of integer doses in current_sequence_int.\n        \"\"\"\n        if k == self.N:\n            # Base case: a complete sequence is formed\n            info = self._calculate_fisher_info(current_sequence_int)\n            \n            current_sequence_float = [val * self.delta for val in current_sequence_int]\n\n            if not self.best_sequence_float or info > self.max_info + self.TOL:\n                self.max_info = info\n                self.best_sequence_float = current_sequence_float\n            elif abs(info - self.max_info)  self.TOL:\n                # Tie-breaking rule: choose lexicographically largest sequence\n                if current_sequence_float > self.best_sequence_float:\n                    self.best_sequence_float = current_sequence_float\n            return\n\n        # Recursive step: determine range of possible doses for u_k and explore\n        max_dose_k_int = min(self.u_max_int, self.d_max_int - current_sum_int)\n        \n        for m_k in range(max_dose_k_int + 1):\n            current_sequence_int.append(m_k)\n            self._find_sequences_recursive(k + 1, current_sequence_int, current_sum_int + m_k)\n            current_sequence_int.pop()\n    \n    def find_optimal_sequence(self):\n        \"\"\"\n        Starts the search for the optimal sequence.\n        \n        Returns:\n            list: The optimal dose sequence as a list of floats.\n        \"\"\"\n        # Initial call to the recursive search function\n        self._find_sequences_recursive(0, [], 0)\n        \n        # In case no valid sequence is found (e.g., N=0), return a list of zeros.\n        if not self.best_sequence_float:\n           return [0.0] * self.N\n        \n        return self.best_sequence_float\n```",
            "answer": "[[0.8,0.8,0.4,0.0,0.0],[0.4,0.0,0.0,0.0,0.0],[0.5,0.5,0.5,0.0,0.0,0.0]]"
        }
    ]
}