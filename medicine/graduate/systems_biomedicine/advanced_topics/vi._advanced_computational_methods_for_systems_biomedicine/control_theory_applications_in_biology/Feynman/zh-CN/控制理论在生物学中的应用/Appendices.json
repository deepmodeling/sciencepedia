{
    "hands_on_practices": [
        {
            "introduction": "能控性是控制理论中的一个基本概念，它判断我们是否能通过可用的输入，将系统状态驱动到任何期望的构型。在药代动力学中，这对应一个至关重要的问题：一个特定的药物输注方案能否在所有相关身体隔室中实现目标浓度？这项练习 () 将能控性检验应用于一个标准的多室药物递送模型，提供了一个具体的实践案例。",
            "id": "4331177",
            "problem": "一个三室静脉给药系统使用基于质量守恒和一阶动力学的线性房室框架进行建模。设状态为 $x_{1}(t)$、$x_{2}(t)$ 和 $x_{3}(t)$，分别代表血浆、外周组织和效应室中的药物量。室间交换和消除动力学由恒定速率参数表征，得到一个形式为 $\\dot{x}(t) = A x(t) + B u(t)$ 的线性时不变(LTI)状态空间模型，其中 $u(t)$ 是输注速率。\n\n生物学参数（单位均为 $\\text{hr}^{-1}$）为：血浆消除 $k_{e} = 0.5$，血浆至外周组织转移 $k_{12} = 0.3$，外周组织至血浆转移 $k_{21} = 0.25$，血浆至效应室转移 $k_{13} = 0.2$，效应室至血浆转移 $k_{31} = 0.15$，外周消除 $k_{e2} = 0.05$，以及效应室消除 $k_{e3} = 0.1$。输注仅以单位增益进入血浆室。由此得到的矩阵为\n$$\nA = \\begin{pmatrix}\n-(k_{e}+k_{12}+k_{13}) & k_{21} & k_{31} \\\\\nk_{12} & -(k_{21}+k_{e2}) & 0 \\\\\nk_{13} & 0 & -(k_{31}+k_{e3})\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-1.0 & 0.25 & 0.15 \\\\\n0.3 & -0.3 & 0 \\\\\n0.2 & 0 & -0.25\n\\end{pmatrix},\n\\quad\nB = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n\n构建能控性矩阵 $\\mathcal{C}$，其列向量为 $B$、$A B$ 和 $A^{2} B$，并计算其秩。使用LTI系统的能控性秩条件，判断该系统是否能控。最终答案仅报告 $\\mathcal{C}$ 的秩。无需四舍五入。最终答案中不包含任何单位。",
            "solution": "用户提供了一个问题陈述，描述了一个用于静脉给药的三室模型，该模型被建模为一个线性时不变（LTI）状态空间系统。任务是评估该系统的能控性。\n\n首先，评估问题陈述的有效性。\n已知条件如下：\n- 一个LTI状态空间模型 $\\dot{x}(t) = A x(t) + B u(t)$。\n- 状态向量 $x(t) \\in \\mathbb{R}^3$ 代表三个室中的药物量。\n- 状态矩阵 $A$ 和输入矩阵 $B$ 如下所示：\n$$\nA = \\begin{pmatrix}\n-1.0 & 0.25 & 0.15 \\\\\n0.3 & -0.3 & 0 \\\\\n0.2 & 0 & -0.25\n\\end{pmatrix},\n\\quad\nB = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n- 问题将能控性矩阵定义为 $\\mathcal{C} = \\begin{pmatrix} B & A B & A^2 B \\end{pmatrix}$。\n- 目标是求出 $\\mathcal{C}$ 的秩并判断系统是否能控。\n\n该问题具有科学依据，采用了标准的房室分析和控制理论原理（LTI系统，能控性）。所提供的参数和得到的矩阵 $A$ 与模型的结构定义一致。该问题是适定的、客观的、自洽的，没有明显的矛盾或歧义。它提出了一个控制理论中的标准可解问题。因此，该问题被认为是有效的。\n\n解题过程是通过构建能控性矩阵并确定其秩来进行的。状态空间维度为 $n=3$。能控性矩阵 $\\mathcal{C}$ 是一个 $3 \\times 3$ 矩阵，由 $\\mathcal{C} = \\begin{pmatrix} B & AB & A^2 B \\end{pmatrix}$ 给出。\n\n$\\mathcal{C}$ 的列向量被依次计算。\n第一列是输入矩阵 $B$：\n$$ B = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} $$\n\n第二列是乘积 $AB$：\n$$ AB = \\begin{pmatrix} -1.0 & 0.25 & 0.15 \\\\ 0.3 & -0.3 & 0 \\\\ 0.2 & 0 & -0.25 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (-1.0)(1) + (0.25)(0) + (0.15)(0) \\\\ (0.3)(1) + (-0.3)(0) + (0)(0) \\\\ (0.2)(1) + (0)(0) + (-0.25)(0) \\end{pmatrix} = \\begin{pmatrix} -1.0 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} $$\n\n第三列是乘积 $A^2 B = A(AB)$：\n$$ A^2 B = \\begin{pmatrix} -1.0 & 0.25 & 0.15 \\\\ 0.3 & -0.3 & 0 \\\\ 0.2 & 0 & -0.25 \\end{pmatrix} \\begin{pmatrix} -1.0 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix} = \\begin{pmatrix} (-1.0)(-1.0) + (0.25)(0.3) + (0.15)(0.2) \\\\ (0.3)(-1.0) + (-0.3)(0.3) + (0)(0.2) \\\\ (0.2)(-1.0) + (0)(0.3) + (-0.25)(0.2) \\end{pmatrix} $$\n$$ A^2 B = \\begin{pmatrix} 1.0 + 0.075 + 0.03 \\\\ -0.3 - 0.09 + 0 \\\\ -0.2 + 0 - 0.05 \\end{pmatrix} = \\begin{pmatrix} 1.105 \\\\ -0.39 \\\\ -0.25 \\end{pmatrix} $$\n\n现在，从这些列向量组装能控性矩阵 $\\mathcal{C}$：\n$$ \\mathcal{C} = \\begin{pmatrix} 1 & -1.0 & 1.105 \\\\ 0 & 0.3 & -0.39 \\\\ 0 & 0.2 & -0.25 \\end{pmatrix} $$\n\n为了求 $\\mathcal C$ 的秩，我们可以计算它的行列式。一个 $3 \\times 3$ 矩阵的秩为 $3$ 当且仅当其行列式不为零。我们沿第一列进行代数余子式展开：\n$$ \\det(\\mathcal{C}) = (1) \\det \\begin{pmatrix} 0.3 & -0.39 \\\\ 0.2 & -0.25 \\end{pmatrix} - (0) \\det \\begin{pmatrix} -1.0 & 1.105 \\\\ 0.2 & -0.25 \\end{pmatrix} + (0) \\det \\begin{pmatrix} -1.0 & 1.105 \\\\ 0.3 & -0.39 \\end{pmatrix} $$\n$$ \\det(\\mathcal{C}) = (1) \\left[ (0.3)(-0.25) - (-0.39)(0.2) \\right] $$\n$$ \\det(\\mathcal{C}) = -0.075 - (-0.078) $$\n$$ \\det(\\mathcal{C}) = -0.075 + 0.078 = 0.003 $$\n\n由于 $\\det(\\mathcal{C}) = 0.003 \\neq 0$，矩阵 $\\mathcal{C}$ 是非奇异的，其列向量是线性无关的。因此，这个 $3 \\times 3$ 矩阵 $\\mathcal{C}$ 的秩为 $3$。\n\n能控性的秩条件指出，一个LTI系统是能控的，当且仅当其能控性矩阵的秩等于状态空间的维度 $n$。在本例中，$\\text{rank}(\\mathcal{C}) = 3$ 且 $n=3$。由于 $\\text{rank}(\\mathcal{C}) = n$，该系统是能控的。这意味着，通过一个合适的控制输入 $u(t)$，可以在有限的时间间隔内将系统状态从任意初始状态驱动到任意最终状态。\n\n问题要求的是 $\\mathcal{C}$ 的秩。\n$\\mathcal{C}$ 的秩是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在分析了系统的静态特性之后，我们转向其动态行为。时间延迟在生物过程中无处不在，并可能导致振荡等复杂动态，而霍普夫分岔（Hopf bifurcation）是标志着系统从稳定稳态向持续振荡转变的数学事件。这项练习 () 探讨了如何确定一个简单的基因调控网络变得不稳定并开始振荡的临界时间延迟，这对于解释生物节律和设计具有特定动态行为的合成电路至关重要。",
            "id": "4331150",
            "problem": "基因调控网络(GRN)中的单基因自调控模块在其稳态附近可以线性化为一个标量延迟微分方程(DDE)，该方程描述了由于转录、翻译和转运时间引起的延迟负反馈下，蛋白质浓度相对于平衡态的微小偏差$x(t)$。该线性化模型具有$\\frac{dx(t)}{dt} = -a\\,x(t) - b\\,x(t-\\tau)$的形式，其中$a>0$，$b>0$，延迟$\\tau>0$。假设解的形式为$x(t) = \\exp(s t)$，可得到特征方程$s + a + b \\exp(-s \\tau) = 0$。当一对共轭复特征根穿过虚轴时，会发生Hopf分岔，从而在蛋白质浓度中产生振荡。\n\n从特征方程和Hopf分岔（定义为线性化特征根穿越虚轴）出发，在确保振荡可能发生的条件$b>a$下，推导出现此类穿越的最小正延迟$\\tau_c$的解析表达式，并用$a$和$b$表示。然后计算当$a=1\\,\\text{min}^{-1}$和$b=2\\,\\text{min}^{-1}$时$\\tau_c$的值。将$\\tau_c$的最终值以分钟为单位表示。无需四舍五入。",
            "solution": "本题要求推导单基因自调控系统发生Hopf分岔时的临界时间延迟$\\tau_c$，并为一组特定参数计算该值。\n\n出发点是线性化系统的特征方程，如下所示：\n$$s + a + b \\exp(-s \\tau) = 0$$\n其中$a > 0$，$b > 0$和$\\tau > 0$是系统参数。当该方程的一对共轭复根穿过复平面的虚轴时，发生Hopf分岔。这意味着我们正在寻找一个纯虚根，可以写成$s = i\\omega_c$，其中$\\omega_c$是分岔点处实值的非零振荡频率。由于系统参数$a$和$b$是实数，如果$i\\omega_c$是一个根，那么它的共轭复数$-i\\omega_c$也必定是一个根。不失一般性，我们可以假设$\\omega_c > 0$。\n\n设$\\tau_c$为发生此穿越时的临界延迟。将$s = i\\omega_c$代入特征方程，得到：\n$$i\\omega_c + a + b \\exp(-i\\omega_c \\tau_c) = 0$$\n\n为了求解$\\omega_c$和$\\tau_c$，我们使用欧拉公式$\\exp(-i\\theta) = \\cos(\\theta) - i\\sin(\\theta)$来展开指数项：\n$$i\\omega_c + a + b(\\cos(\\omega_c \\tau_c) - i\\sin(\\omega_c \\tau_c)) = 0$$\n\n接下来，我们将方程分为实部和虚部。为使方程成立，其实部和虚部必须各自等于零。\n$$ (a + b\\cos(\\omega_c \\tau_c)) + i(\\omega_c - b\\sin(\\omega_c \\tau_c)) = 0 $$\n\n这得到了一个由两个方程组成的方程组：\n1. 实部: $a + b\\cos(\\omega_c \\tau_c) = 0$\n2. 虚部: $\\omega_c - b\\sin(\\omega_c \\tau_c) = 0$\n\n我们可以重排这些方程以分离出三角函数项：\n$$\\cos(\\omega_c \\tau_c) = -\\frac{a}{b}$$\n$$\\sin(\\omega_c \\tau_c) = \\frac{\\omega_c}{b}$$\n\n为了求出频率$\\omega_c$，我们可以利用基本三角恒等式$\\sin^2(\\theta) + \\cos^2(\\theta) = 1$来消去$\\tau_c$。将两个方程平方后相加，得到：\n$$\\left(\\frac{\\omega_c}{b}\\right)^2 + \\left(-\\frac{a}{b}\\right)^2 = 1$$\n$$\\frac{\\omega_c^2}{b^2} + \\frac{a^2}{b^2} = 1$$\n两边乘以$b^2$得到：\n$$\\omega_c^2 + a^2 = b^2$$\n求解$\\omega_c^2$，我们得到：\n$$\\omega_c^2 = b^2 - a^2$$\n由于我们假设了$\\omega_c > 0$，我们取正平方根：\n$$\\omega_c = \\sqrt{b^2 - a^2}$$\n为了使$\\omega_c$成为一个实数且非零的频率，必须满足$b^2 - a^2 > 0$。由于$a$和$b$都是正数，这等价于条件$b > a$，该条件在问题陈述中已明确给出，作为振荡起始的先决条件。这证实了问题表述的一致性。\n\n现在我们可以求解临界延迟$\\tau_c$。我们从正弦和余弦方程中得到了角度$\\omega_c \\tau_c$的表达式。具体来说，$\\cos(\\omega_c \\tau_c) = -a/b$。一个已知余弦值的角度的通解由反余弦函数加上$2\\pi$的整数倍给出。\n$$\\omega_c \\tau_c = \\arccos\\left(-\\frac{a}{b}\\right) + 2k\\pi, \\quad k \\in \\{0, 1, 2, \\dots\\}$$\n这里，$\\arccos$表示主值，对于$[-1, 1]$内的自变量，其返回值在$[0, \\pi]$区间内。由于$a, b > 0$且$b > a$，自变量$-a/b$位于$(-1, 0)$区间内，因此$\\arccos(-a/b)$位于$(\\pi/2, \\pi)$区间内。\n\n求解$\\tau_c$：\n$$\\tau_c = \\frac{1}{\\omega_c} \\left( \\arccos\\left(-\\frac{a}{b}\\right) + 2k\\pi \\right)$$\n代入$\\omega_c$的表达式：\n$$\\tau_c = \\frac{1}{\\sqrt{b^2 - a^2}} \\left( \\arccos\\left(-\\frac{a}{b}\\right) + 2k\\pi \\right)$$\n题目要求最小的正延迟$\\tau_c$。由于$\\omega_c = \\sqrt{b^2-a^2} > 0$且$\\arccos(-a/b) \\in (\\pi/2, \\pi)$为正，$\\tau_c$的最小正值在整数$k=0$时取得。\n这给出了最小临界延迟的解析表达式：\n$$\\tau_c = \\frac{1}{\\sqrt{b^2 - a^2}} \\arccos\\left(-\\frac{a}{b}\\right)$$\n\n现在，我们为给定的参数$a = 1\\,\\text{min}^{-1}$和$b = 2\\,\\text{min}^{-1}$计算$\\tau_c$的值。\n首先，我们验证条件$b > a$：$2 > 1$，成立。\n接下来，我们计算分岔频率$\\omega_c$：\n$$\\omega_c = \\sqrt{b^2 - a^2} = \\sqrt{2^2 - 1^2} = \\sqrt{4 - 1} = \\sqrt{3}\\,\\text{min}^{-1}$$\n然后，我们计算临界延迟$\\tau_c$：\n$$\\tau_c = \\frac{1}{\\sqrt{3}} \\arccos\\left(-\\frac{1}{2}\\right)$$\n$-1/2$的反余弦主值是满足$\\cos(\\theta) = -1/2$的角度$\\theta \\in [0, \\pi]$。该角度为$\\theta = \\frac{2\\pi}{3}$弧度。\n代入该值可得：\n$$\\tau_c = \\frac{1}{\\sqrt{3}} \\left(\\frac{2\\pi}{3}\\right) = \\frac{2\\pi}{3\\sqrt{3}}\\,\\text{min}$$\n所得结果的单位是分钟，符合要求。",
            "answer": "$$\\boxed{\\frac{2\\pi}{3\\sqrt{3}}}$$"
        },
        {
            "introduction": "现在我们进入控制理论应用的更高层次：最优设计。在有效控制一个系统之前，我们通常需要一个精确的数学模型，而最优实验设计正是利用控制原理来设计输入，从而最大限度地获取关于未知系统参数的信息。这项练习 () 要求你在实际的安全约束下，设计一个给药方案来最大程度地揭示一个生物降解速率。此问题引入了强大的费雪信息（Fisher Information）概念，展示了控制理论如何从被动分析转向主动的、以信息为导向的实验设计。",
            "id": "4331135",
            "problem": "您正在设计一个输入（剂量）序列，用于在安全约束下探究一个离散时间下的一阶生物过程。其底层系统是一个单室线性时不变模型，该模型表示了可测量的分子种类在外部施加的非负输入剂量作用下的累积与清除过程。设状态在离散时间索引 $k \\in \\{0,1,\\dots\\}$ 时为 $x_k$，初始条件为 $x_0 = 0$。其动力学由 $x_{k+1} = \\alpha x_k + u_k$ 给出，其中 $\\alpha = \\exp(-k_d \\Delta t)$，$k_d \\ge 0$ 是降解速率常数，$\\Delta t > 0$ 是采样间隔。在每个采样时刻的测量输出为 $y_k = x_k + v_k$，其中 $v_k$ 是方差为 $\\sigma^2$ 的独立零均值高斯随机变量。所有量都经过归一化且无量纲；因此，您应该以无量纲单位给出答案。\n\n目标是选择一个有限时域的非负输入序列 $\\{u_0, u_1, \\dots, u_{N-1}\\}$，以在独立高斯噪声下，最大化输出 $\\{y_1,\\dots,y_N\\}$ 中包含的关于降解速率常数 $k_d$ 的期望信息。为了使问题在计算上是适定的，并反映实验安全约束，输入必须同时满足每时间步的上限和总剂量预算：\n- 非负性与单步上限：对于每个 $k \\in \\{0,\\dots,N-1\\}$，$0 \\le u_k \\le u_{\\max}$。\n- 总剂量预算：$\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$。\n\n在高斯观测中关于 $k_d$ 的信息由费雪信息矩阵（FIM）量化，对于一个标量参数，它简化为一个非负标量。您必须使用独立高斯噪声下费雪信息的标准定义，并推导出一个可用输入序列和关于 $k_d$ 的模型灵敏度表示的可计算表达式。\n\n为了算法的易处理性并捕捉方案的粒度，将输入值限制在一个间距为 $\\delta > 0$ 的均匀网格上，因此每个 $u_k$ 被约束在集合 $\\{0, \\delta, 2\\delta, \\dots, u_{\\max}\\}$ 中，并且 $\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$。对于所有测试用例，假设 $u_{\\max}$ 和 $D_{\\max}$ 是 $\\delta$ 的整数倍。\n\n您的任务是：\n- 从第一性原理出发，根据给定的模型和噪声假设，计算关于 $k_d$ 的费雪信息，作为输入序列的函数。\n- 在上述离散可行集上，找到一个在剂量约束下最大化此费雪信息的输入序列。\n- 如果有多个序列达到相同的最大费雪信息，则通过选择字典序最大的序列来打破平局，即从最早到最晚逐元素比较剂量序列，并选择第一个具有严格更大元素的序列。\n\n使用以下参数集测试套件，每个参数集指定为一个元组 $(N,\\ \\Delta t,\\ k_d,\\ \\sigma,\\ u_{\\max},\\ D_{\\max},\\ \\delta)$:\n- 情况 A: $(5,\\ 1.0,\\ 0.3,\\ 0.1,\\ 0.8,\\ 2.0,\\ 0.1)$。\n- 情况 B: $(5,\\ 1.0,\\ 0.3,\\ 0.1,\\ 0.5,\\ 0.4,\\ 0.1)$。\n- 情况 C: $(6,\\ 1.0,\\ 1.2,\\ 0.2,\\ 0.5,\\ 1.5,\\ 0.1)$。\n\n您的程序必须为每种情况计算一个最优序列 $\\{u_k\\}_{k=0}^{N-1}$，该序列在给定的约束和打破平局规则下最大化关于 $k_d$ 的费雪信息。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个结果本身是对应情况下每个时间步最优剂量的方括号括起来的逗号分隔列表，每个剂量报告到一位小数。例如，一个包含三种情况的有效输出格式形式为 $[\\,[0.0,0.1,0.1],\\,[0.2,0.2,0.0],\\,[0.5,0.5,0.5,0.0]\\,]$。",
            "solution": "### 步骤 1：提取已知信息\n问题提供了以下信息：\n- **系统动力学**：一个离散时间、单室线性时不变模型。\n  - 时间 $k$ 的状态：$x_k$，初始条件为 $x_0 = 0$。\n  - 状态更新方程：$x_{k+1} = \\alpha x_k + u_k$，对于 $k \\in \\{0, 1, \\dots, N-1\\}$。\n  - 时间 $k$ 的输入（剂量）：$u_k$。\n  - 衰减参数：$\\alpha = \\exp(-k_d \\Delta t)$，其中 $k_d \\ge 0$ 是降解速率常数，$\\Delta t > 0$ 是采样间隔。\n- **测量模型**：\n  - 时间 $k$ 的测量输出：$y_k = x_k + v_k$，对于 $k \\in \\{1, \\dots, N\\}$。\n  - 测量噪声：$v_k$ 是独立同分布（i.i.d.）的零均值高斯随机变量，方差为 $\\sigma^2$，即 $v_k \\sim \\mathcal{N}(0, \\sigma^2)$。\n- **输入约束**：\n  - 输入序列是有限时域的：$\\{u_0, u_1, \\dots, u_{N-1}\\}$。\n  - 非负性与单步上限：$0 \\le u_k \\le u_{\\max}$。\n  - 总剂量预算：$\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$。\n  - 输入的离散化：$u_k \\in \\{0, \\delta, 2\\delta, \\dots, u_{\\max}\\}$，其中 $\\delta > 0$。给定 $u_{\\max}$ 和 $D_{\\max}$ 是 $\\delta$ 的整数倍。\n- **目标**：\n  - 最大化输出序列 $\\{y_1, \\dots, y_N\\}$ 中包含的关于参数 $k_d$ 的费雪信息（FIM）。\n- **打破平局规则**：\n  - 如果多个输入序列产生相同的最大费雪信息，必须选择字典序最大的序列。\n- **测试用例**：提供了三个参数集 $(N, \\Delta t, k_d, \\sigma, u_{\\max}, D_{\\max}, \\delta)$：\n  - 情况 A: $(5, 1.0, 0.3, 0.1, 0.8, 2.0, 0.1)$。\n  - 情况 B: $(5, 1.0, 0.3, 0.1, 0.5, 0.4, 0.1)$。\n  - 情况 C: $(6, 1.0, 1.2, 0.2, 0.5, 1.5, 0.1)$。\n\n### 步骤 2：使用提取的已知信息进行验证\n1.  **科学依据**：该问题在系统生物学和控制理论中有充分的科学依据。一阶线性模型是诸如药物清除（单室药代动力学）等简单生物过程的典型表示。最大化费雪信息的概念是最优实验设计（特别是对于标量参数的 D-最优性）的基石。这些约束是实验限制的现实表示。\n2.  **适定性**：该问题是适定的。目标函数（费雪信息）有明确定义。由输入序列 $\\{u_k\\}$ 的约束定义的搜索空间是一个有限的离散集。因此，最大值的存在性得到保证。指定的打破平局规则确保解是唯一的。\n3.  **客观性**：该问题以精确、客观的数学语言陈述。它不包含任何主观声明或伪深奥的陈述。所有术语在相关科学领域都是标准术语。\n4.  **完整性与一致性**：该问题是自包含的。所有必要的方程、参数和约束都已提供。设置中没有矛盾之处。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个最优实验设计中的标准、适定的问题，可以通过计算解决。将推导并实现一个完整的解决方案。\n\n### 求解推导\n\n求解过程包括三个主要步骤：推导目标函数（费雪信息），构建约束优化问题，以及设计一个算法来解决它。\n\n**1. 费雪信息公式**\n对于一个标量参数 $\\theta$，从一组 $N$ 个独立测量值 $\\{y_k\\}_{k=1}^N$（每个测量值都带有方差为 $\\sigma^2$ 的高斯噪声）中获得的费雪信息 $I(\\theta)$ 由以下公式给出：\n$$ I(\\theta) = \\sum_{k=1}^{N} \\frac{1}{\\operatorname{Var}(y_k)} \\left( \\frac{\\partial \\mathbb{E}[y_k]}{\\partial \\theta} \\right)^2 $$\n在这个问题中，我们关心的参数是 $\\theta = k_d$。测量值为 $y_k = x_k + v_k$，其中 $v_k \\sim \\mathcal{N}(0, \\sigma^2)$。输出的期望值为 $\\mathbb{E}[y_k] = \\mathbb{E}[x_k + v_k] = x_k + \\mathbb{E}[v_k] = x_k$。方差为 $\\operatorname{Var}(y_k) = \\sigma^2$。\n将这些代入公式，关于 $k_d$ 的费雪信息为：\n$$ I(k_d) = \\frac{1}{\\sigma^2} \\sum_{k=1}^{N} \\left( \\frac{\\partial x_k}{\\partial k_d} \\right)^2 $$\n目标是选择输入序列 $\\{u_0, \\dots, u_{N-1}\\}$ 以最大化 $I(k_d)$。由于对于每个测试用例 $\\sigma^2$ 是一个正常数，这等价于最大化灵敏度的平方和，我们将其表示为 $J$：\n$$ J(\\{u_k\\}) = \\sum_{k=1}^{N} s_k^2 \\quad \\text{其中} \\quad s_k = \\frac{\\partial x_k}{\\partial k_d} $$\n\n**2. 灵敏度分析**\n为了计算目标函数 $J$，我们必须推导 $s_k$ 的表达式。我们可以通过对状态方程关于 $k_d$ 求导来实现。\n状态方程是 $x_{k+1} = \\alpha x_k + u_k$，其中 $\\alpha = e^{-k_d \\Delta t}$。\n对 $k_d$ 求导：\n$$ \\frac{\\partial x_{k+1}}{\\partial k_d} = \\frac{\\partial \\alpha}{\\partial k_d} x_k + \\alpha \\frac{\\partial x_k}{\\partial k_d} $$\n我们首先求 $\\alpha$ 的导数：\n$$ \\frac{\\partial \\alpha}{\\partial k_d} = \\frac{\\partial}{\\partial k_d} \\left( e^{-k_d \\Delta t} \\right) = -\\Delta t \\cdot e^{-k_d \\Delta t} = -\\Delta t \\cdot \\alpha $$\n将此代回并使用定义 $s_k = \\frac{\\partial x_k}{\\partial k_d}$，我们得到灵敏度的动力学：\n$$ s_{k+1} = (-\\Delta t \\cdot \\alpha) x_k + \\alpha s_k = \\alpha(s_k - \\Delta t \\cdot x_k) $$\n初始条件是 $x_0 = 0$ 和 $s_0 = \\frac{\\partial x_0}{\\partial k_d} = \\frac{\\partial 0}{\\partial k_d} = 0$。虽然这些递归方程可以与状态 $x_k$ 一起模拟，但推导一个更直接的 $s_k$ 的封闭形式表达式会更有效。\n从 $x_0=0$ 开始，状态 $x_k$ 的封闭解是：\n$$ x_k = \\sum_{j=0}^{k-1} \\alpha^{k-1-j} u_j $$\n对 $k_d$ 求导：\n$$ s_k = \\frac{\\partial x_k}{\\partial k_d} = \\sum_{j=0}^{k-1} \\frac{\\partial(\\alpha^{k-1-j})}{\\partial k_d} u_j $$\n使用链式法则，$\\frac{\\partial(\\alpha^m)}{\\partial k_d} = m\\alpha^{m-1} \\frac{\\partial \\alpha}{\\partial k_d} = m\\alpha^{m-1}(-\\Delta t \\cdot \\alpha) = -m\\Delta t \\alpha^m$。\n将此代入 $s_k$ 的表达式：\n$$ s_k = \\sum_{j=0}^{k-1} \\left( -(k-1-j)\\Delta t \\alpha^{k-1-j} \\right) u_j = -\\Delta t \\sum_{j=0}^{k-1} (k-1-j) \\alpha^{k-1-j} u_j $$\n这个表达式允许从输入序列 $\\{u_j\\}$ 直接计算每个 $s_k$，这比模拟 $x_k$ 和 $s_k$ 的耦合递归关系在计算上更高效，数值上也更稳定。\n\n**3. 优化与算法设计**\n问题是找到一个输入序列 $\\{u_0, \\dots, u_{N-1}\\}$ 来解决：\n$$ \\max_{\\{u_k\\}} J = \\sum_{k=1}^{N} \\left( -\\Delta t \\sum_{j=0}^{k-1} (k-1-j)\\alpha^{k-1-j}u_j \\right)^2 $$\n受以下约束：\n1. $u_k \\in \\{0, \\delta, 2\\delta, \\dots, u_{\\max}\\}$ 对于 $k \\in \\{0, \\dots, N-1\\}$\n2. $\\sum_{k=0}^{N-1} u_k \\le D_{\\max}$\n\n这是一个在离散、有限集合上的组合优化问题。对于测试用例中较小的 $N$ 值（5 和 6），对所有可行序列进行穷举搜索在计算上是可行的。我们设计一个回溯（递归）算法来执行此搜索。\n\n为了简化搜索，我们将每个剂量 $u_k$ 表示为 $\\delta$ 的整数倍，即 $u_k = m_k \\delta$，其中 $m_k$ 是一个整数。约束变为：\n1. $m_k \\in \\{0, 1, \\dots, u_{\\max}/\\delta\\}$\n2. $\\sum_{k=0}^{N-1} m_k \\le D_{\\max}/\\delta$\n\n算法流程如下：\n定义一个递归函数，例如 `find_sequences_recursive(k, current_sequence, current_sum)`。\n- `k` 是当前正在选择剂量的时间索引（从 0 到 $N$）。\n- `current_sequence` 存储了到目前为止选择的整数倍剂量 $\\{m_0, \\dots, m_{k-1}\\}$。\n- `current_sum` 是到目前为止选择的整数倍剂量的总和。\n\n递归的基准情况是当 $k=N$ 时，这意味着已经生成了一个完整的序列。此时，为此序列计算费雪信息度量 $J$。将此值与到目前为止找到的最大信息进行比较。如果新值更大，它就成为新的最大值，并且当前序列被存储为最佳序列。如果新值等于最大值，则将当前序列与到目前为止找到的最佳序列进行字典序比较。如果它在字典序上更大，它将替换当前的最佳序列，以满足打破平局的规则。\n\n递归步骤涉及遍历当前时间步 $k$ 的所有有效整数剂量 $m_k$。一个剂量 $m_k$ 是有效的，如果它不超过单步限制（$m_k \\le u_{\\max}/\\delta$）并且在加到当前总和中时不会违反总预算（$current\\_sum + m_k \\le D_{\\max}/\\delta$）。对于每个有效的 $m_k$，函数为下一个时间步调用自身，即 `find_sequences_recursive(k+1, ...)`。这系统地探索了可行序列的整个树。\n该方法保证根据指定的标准找到全局最优序列。",
            "answer": "```python\nimport numpy as np\nimport math\n\nclass OptimalDoseFinder:\n    \"\"\"\n    Finds the optimal dosing sequence to maximize Fisher Information for k_d.\n    \n    This class implements a systematic search over a discrete set of possible \n    input sequences to find one that maximizes the Fisher Information about a \n    model parameter, subject to per-step and total dose constraints.\n    \"\"\"\n    def __init__(self, N, delta_t, k_d, u_max, d_max, delta):\n        \"\"\"\n        Initializes the finder with problem parameters.\n\n        Args:\n            N (int): Horizon length.\n            delta_t (float): Sampling interval.\n            k_d (float): Degradation rate constant.\n            u_max (float): Maximum dose per time step.\n            d_max (float): Maximum total dose.\n            delta (float): Granularity of dose.\n        \"\"\"\n        self.N = N\n        self.delta_t = delta_t\n        self.k_d = k_d\n        self.u_max = u_max\n        self.d_max = d_max\n        self.delta = delta\n\n        # Pre-calculate constants for the search\n        self.alpha = math.exp(-self.k_d * self.delta_t)\n        self.u_max_int = round(self.u_max / self.delta)\n        self.d_max_int = round(self.d_max / self.delta)\n\n        # State for the search algorithm\n        self.max_info = -1.0\n        self.best_sequence_float = []\n        \n        # Tolerance for floating point comparisons of the Fisher Information\n        self.TOL = 1e-9\n\n    def _calculate_fisher_info(self, u_sequence_int):\n        \"\"\"\n        Calculates the Fisher Information metric for a given integer dose sequence.\n        The metric is sum(s_k^2), where s_k is the sensitivity.\n        \"\"\"\n        u_sequence = [val * self.delta for val in u_sequence_int]\n        total_info = 0.0\n        \n        # Calculate s_k for k=1 to N and sum their squares\n        for k in range(1, self.N + 1):\n            s_k = 0.0\n            # s_k = -delta_t * sum_{j=0}^{k-1} (k-1-j) * alpha^(k-1-j) * u_j\n            for j in range(k):  # j iterates from 0 to k-1\n                exponent = k - 1 - j\n                if exponent > 0:\n                    term = (exponent) * (self.alpha ** exponent) * u_sequence[j]\n                    s_k += term\n            \n            s_k *= -self.delta_t\n            total_info += s_k**2\n            \n        return total_info\n\n    def _find_sequences_recursive(self, k, current_sequence_int, current_sum_int):\n        \"\"\"\n        Recursively explores all feasible dose sequences using backtracking.\n        \n        Args:\n            k (int): The current time step to choose a dose for (from 0 to N-1).\n            current_sequence_int (list): The list of integer doses chosen so far.\n            current_sum_int (int): The sum of integer doses in current_sequence_int.\n        \"\"\"\n        if k == self.N:\n            # Base case: a complete sequence is formed\n            info = self._calculate_fisher_info(current_sequence_int)\n            \n            current_sequence_float = [val * self.delta for val in current_sequence_int]\n\n            if not self.best_sequence_float or info > self.max_info + self.TOL:\n                self.max_info = info\n                self.best_sequence_float = current_sequence_float\n            elif abs(info - self.max_info) < self.TOL:\n                # Tie-breaking rule: choose lexicographically largest sequence\n                if current_sequence_float > self.best_sequence_float:\n                    self.best_sequence_float = current_sequence_float\n            return\n\n        # Recursive step: determine range of possible doses for u_k and explore\n        max_dose_k_int = min(self.u_max_int, self.d_max_int - current_sum_int)\n        \n        for m_k in range(max_dose_k_int + 1):\n            current_sequence_int.append(m_k)\n            self._find_sequences_recursive(k + 1, current_sequence_int, current_sum_int + m_k)\n            current_sequence_int.pop()\n    \n    def find_optimal_sequence(self):\n        \"\"\"\n        Starts the search for the optimal sequence.\n        \n        Returns:\n            list: The optimal dose sequence as a list of floats.\n        \"\"\"\n        # Initial call to the recursive search function\n        self._find_sequences_recursive(0, [], 0)\n        \n        # In case no valid sequence is found (e.g., N=0), return a list of zeros.\n        if not self.best_sequence_float:\n           return [0.0] * self.N\n        \n        return self.best_sequence_float\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (N,  Δt,   k_d,   σ, u_max, D_max,  δ)\n        (5,  1.0,  0.3, 0.1,   0.8,   2.0,  0.1),  # Case A\n        (5,  1.0,  0.3, 0.1,   0.5,   0.4,  0.1),  # Case B\n        (6,  1.0,  1.2, 0.2,   0.5,   1.5,  0.1),  # Case C\n    ]\n\n    results = []\n    for case_params in test_cases:\n        N, delta_t, k_d, _, u_max, d_max, delta = case_params\n        finder = OptimalDoseFinder(N, delta_t, k_d, u_max, d_max, delta)\n        optimal_seq = finder.find_optimal_sequence()\n        \n        # Format the output for each dose to one decimal place\n        formatted_seq = [f\"{dose:.1f}\" for dose in optimal_seq]\n        results.append(f\"[{','.join(formatted_seq)}]\")\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}