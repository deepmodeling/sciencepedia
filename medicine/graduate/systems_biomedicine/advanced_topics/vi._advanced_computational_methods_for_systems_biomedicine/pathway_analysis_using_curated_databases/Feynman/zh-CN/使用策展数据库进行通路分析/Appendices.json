{
    "hands_on_practices": [
        {
            "introduction": "通路分析的第一步往往是处理和整合来自不同来源的数据，其中一个核心挑战是统一不同来源的基因或蛋白质标识符。由于命名法的多样性和历史演变，一个实验特征可能对应多个候选基因，从而产生歧义。本练习  介绍了一种利用贝叶斯推断来量化地解决这种模糊性的方法，这对于确保下游通路分析的准确性至关重要。",
            "id": "4373294",
            "problem": "一个研究小组正在使用诸如京都基因与基因组百科全书 (Kyoto Encyclopedia of Genes and Genomes, KEGG) 和 Reactome 等经过整理的数据库进行通路分析。他们实验的特征表使用了来自通用蛋白质资源库 (Universal Protein Resource, UniProt) 和 Entrez Gene 的标识符进行注释。在标识符协调过程中，他们遇到了 $32$ 个具有歧义同义词的实验特征，每个特征都可以精确地映射到两个候选的 Entrez Gene 标识符。该小组通过结合两条独立的整理证据来解决每个歧义：跨数据库同义词整理（来自 UniProt 和手动整理笔记）和通路共成员证据（来自 KEGG 和 Reactome）。他们将这些证据在给定真实映射的情况下视为条件独立的。\n\n对于每个歧义特征，他们对两个候选者使用具有相等先验几率的贝叶斯定理和最大后验概率决策规则：选择具有较高后验概率的候选者。对于每个歧义特征，同义词整理证据产生一个支持候选者 $g_{1}$ 而非候选者 $g_{2}$ 的似然比 $\\lambda$，通路共成员证据产生一个似然比 $\\mu$（同样支持 $g_{1}$ 而非 $g_{2}$）。在条件独立性假设下，组合似然比为 $L = \\lambda \\times \\mu$。根据整理证据的强度，这些歧义特征被划分为三个不相交的类别：\n\n- 类别 $\\mathcal{A}$：$n_{\\mathcal{A}} = 12$ 个特征，其中 $\\lambda_{\\mathcal{A}} = 2.5$ 且 $\\mu_{\\mathcal{A}} = 1.8$。\n- 类别 $\\mathcal{B}$：$n_{\\mathcal{B}} = 10$ 个特征，其中 $\\lambda_{\\mathcal{B}} = 1.2$ 且 $\\mu_{\\mathcal{B}} = 0.9$。\n- 类别 $\\mathcal{C}$：$n_{\\mathcal{C}} = 10$ 个特征，其中 $\\lambda_{\\mathcal{C}} = 0.7$ 且 $\\mu_{\\mathcal{C}} = 0.6$。\n\n假设对于每个特征，所选候选者是真实标识符的概率，等于在贝叶斯定理下具有相等先验和组合似然比 $L$ 时，该选定候选者的后验概率。仅使用贝叶斯定理、条件独立性和最大后验概率规则的基本定义，推导一个表达式，用于计算这 32 个歧义特征中被正确解析的标识符的期望数量，并为给定类别计算其值。将最终数值答案四舍五入到四位有效数字。将最终答案表示为无量纲计数。",
            "solution": "用户希望解决一个关于在生物信息学中使用贝叶斯框架进行标识符协调的问题。问题要求计算被正确解析的标识符的期望数量。\n\n### 第1步：问题验证\n\n首先，我将验证问题陈述。\n\n**1.1. 提取已知条件**\n- 总歧义特征数：32。\n- 每个特征映射到两个候选 Entrez Gene 标识符，记为 $g_1$ 和 $g_2$。\n- 决策规则：具有相等先验几率的贝叶斯定理和最大后验概率 (MAP) 规则。\n- 证据：两条证据线，即同义词整理和通路共成员，在给定真实映射的情况下被视为条件独立的。\n- 同义词整理的似然比：$\\lambda = \\frac{P(\\text{synonym evidence} | g_1 \\text{ is true})}{P(\\text{synonym evidence} | g_2 \\text{ is true})}$。\n- 通路共成员的似然比：$\\mu = \\frac{P(\\text{pathway evidence} | g_1 \\text{ is true})}{P(\\text{pathway evidence} | g_2 \\text{ is true})}$。\n- 组合证据似然比：$L = \\lambda \\times \\mu$。\n- 特征类别：\n    - 类别 $\\mathcal{A}$：$n_{\\mathcal{A}} = 12$ 个特征，$\\lambda_{\\mathcal{A}} = 2.5$，$\\mu_{\\mathcal{A}} = 1.8$。\n    - 类别 $\\mathcal{B}$：$n_{\\mathcal{B}} = 10$ 个特征，$\\lambda_{\\mathcal{B}} = 1.2$，$\\mu_{\\mathcal{B}} = 0.9$。\n    - 类别 $\\mathcal{C}$：$n_{\\mathcal{C}} = 10$ 个特征，$\\lambda_{\\mathcal{C}} = 0.7$，$\\mu_{\\mathcal{C}} = 0.6$。\n- 特征总数检查：$n_{\\mathcal{A}} + n_{\\mathcal{B}} + n_{\\mathcal{C}} = 12 + 10 + 10 = 32$。\n- 假设：对于每个特征，正确解析的概率等于所选候选者的后验概率。\n- 任务：推导并计算正确解析的标识符的期望数量。\n- 四舍五入：最终数值答案必须四舍五入到四位有效数字。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题在系统生物医学中常用的统计方法学方面有充分的依据。贝叶斯推断、似然比和用于标识符映射的证据整合是标准且现实的概念。\n- **适定性**：问题陈述清晰，提供了所有必要的数值和概率假设，并要求一个具体、可计算的量。\n- **客观性**：语言技术性强且精确，没有主观或含糊的元素。\n- **缺陷检查表**：该问题没有违反任何无效标准。它科学上合理、可形式化、完整、现实且适定。“所选候选者是真实标识符的概率”的定义被明确给出，排除了歧义。\n\n**1.3. 结论与行动**\n问题是有效的。我将继续进行解答。\n\n### 第2步：解题推导\n\n问题要求我们计算在一组 32 个歧义特征中被正确解析的标识符的期望数量。让我们为单个特征形式化贝叶斯框架。\n\n设 $H_1$ 为候选基因 $g_1$ 是真实标识符的假设，而 $H_2$ 为 $g_2$ 是真实标识符的假设。问题陈述了存在相等的先验几率，对于两个互斥且穷尽的假设，这意味着它们具有相等的先验概率：\n$$ P(H_1) = P(H_2) = \\frac{1}{2} $$\n设 $E$ 代表来自同义词整理 ($E_s$) 和通路共成员 ($E_p$) 的组合证据。贝叶斯推断的核心是根据这些证据更新我们的先验信念，以获得后验概率 $P(H_1|E)$ 和 $P(H_2|E)$。\n\n几率形式的贝叶斯定理将后验几率与先验几率和似然比联系起来：\n$$ \\frac{P(H_1|E)}{P(H_2|E)} = \\frac{P(E|H_1)}{P(E|H_2)} \\times \\frac{P(H_1)}{P(H_2)} $$\n项 $\\frac{P(E|H_1)}{P(E|H_2)}$ 是似然比，问题中用 $L$ 表示。给定相等的先验概率，先验几率比 $\\frac{P(H_1)}{P(H_2)} = 1$。因此，后验几率等于似然比：\n$$ \\frac{P(H_1|E)}{P(H_2|E)} = L $$\n问题陈述了两条证据线是条件独立的，并提供了它们各自的似然比 $\\lambda$ 和 $\\mu$。组合似然比 $L$ 是它们的乘积，$L = \\lambda \\mu$，这与条件独立性假设一致。\n\n我们可以用 $L$ 来表示后验概率。由于 $P(H_1|E) + P(H_2|E) = 1$，我们可以将 $P(H_1|E) = L \\cdot P(H_2|E)$ 代入这个和式中：\n$$ L \\cdot P(H_2|E) + P(H_2|E) = 1 \\implies P(H_2|E)(L+1) = 1 \\implies P(H_2|E) = \\frac{1}{L+1} $$\n因此，$H_1$ 的后验概率为：\n$$ P(H_1|E) = 1 - P(H_2|E) = 1 - \\frac{1}{L+1} = \\frac{L}{L+1} $$\n\n决策是使用最大后验概率 (MAP) 规则做出的，即选择具有最高后验概率的假设。\n- 如果 $P(H_1|E) > P(H_2|E)$，这等价于 $\\frac{L}{L+1} > \\frac{1}{L+1}$ 或 $L>1$，我们选择候选者 $g_1$。\n- 如果 $P(H_2|E) > P(H_1|E)$，这等价于 $L1$，我们选择候选者 $g_2$。\n- 如果 $L=1$，概率相等，选择是模糊的，但这种情况在给定数据中不会发生。\n\n问题将单个特征的正确解析概率 $P_C$ 定义为*所选*候选者的后验概率。\n- 如果 $L>1$，我们选择 $g_1$，这个选择正确的概率是 $P_C = P(H_1|E) = \\frac{L}{L+1}$。\n- 如果 $L1$，我们选择 $g_2$，这个选择正确的概率是 $P_C = P(H_2|E) = \\frac{1}{L+1}$。\n这可以紧凑地写成 $P_C = \\max\\left(\\frac{L}{L+1}, \\frac{1}{L+1}\\right)$。\n\n根据期望的线性性质，正确解析的标识符的总期望数量 $E[\\text{correct}]$ 是这 32 个特征中每个特征正确解析概率的总和。我们可以按类别对特征进行分组。\n$$ E[\\text{correct}] = n_{\\mathcal{A}} P_{C, \\mathcal{A}} + n_{\\mathcal{B}} P_{C, \\mathcal{B}} + n_{\\mathcal{C}} P_{C, \\mathcal{C}} $$\n其中 $P_{C, k}$ 是类别 $k$ 中一个特征的正确解析概率。\n\n现在，我们为每个类别计算 $P_C$：\n\n**类别 $\\mathcal{A}$：**\n- 特征数量：$n_{\\mathcal{A}} = 12$。\n- 似然比：$\\lambda_{\\mathcal{A}} = 2.5$, $\\mu_{\\mathcal{A}} = 1.8$。\n- 组合似然比：$L_{\\mathcal{A}} = \\lambda_{\\mathcal{A}} \\times \\mu_{\\mathcal{A}} = 2.5 \\times 1.8 = 4.5$。\n- 由于 $L_{\\mathcal{A}} = 4.5 > 1$，我们选择候选者 $g_1$。\n- 正确解析的概率：$P_{C, \\mathcal{A}} = \\frac{L_{\\mathcal{A}}}{L_{\\mathcal{A}}+1} = \\frac{4.5}{4.5+1} = \\frac{4.5}{5.5} = \\frac{9}{11}$。\n\n**类别 $\\mathcal{B}$：**\n- 特征数量：$n_{\\mathcal{B}} = 10$。\n- 似然比：$\\lambda_{\\mathcal{B}} = 1.2$, $\\mu_{\\mathcal{B}} = 0.9$。\n- 组合似然比：$L_{\\mathcal{B}} = \\lambda_{\\mathcal{B}} \\times \\mu_{\\mathcal{B}} = 1.2 \\times 0.9 = 1.08$。\n- 由于 $L_{\\mathcal{B}} = 1.08 > 1$，我们选择候选者 $g_1$。\n- 正确解析的概率：$P_{C, \\mathcal{B}} = \\frac{L_{\\mathcal{B}}}{L_{\\mathcal{B}}+1} = \\frac{1.08}{1.08+1} = \\frac{1.08}{2.08} = \\frac{108}{208} = \\frac{27}{52}$。\n\n**类别 $\\mathcal{C}$：**\n- 特征数量：$n_{\\mathcal{C}} = 10$。\n- 似然比：$\\lambda_{\\mathcal{C}} = 0.7$, $\\mu_{\\mathcal{C}} = 0.6$。\n- 组合似然比：$L_{\\mathcal{C}} = \\lambda_{\\mathcal{C}} \\times \\mu_{\\mathcal{C}} = 0.7 \\times 0.6 = 0.42$。\n- 由于 $L_{\\mathcal{C}} = 0.42  1$，我们选择候选者 $g_2$。\n- 正确解析的概率：$P_{C, \\mathcal{C}} = \\frac{1}{L_{\\mathcal{C}}+1} = \\frac{1}{0.42+1} = \\frac{1}{1.42} = \\frac{100}{142} = \\frac{50}{71}$。\n\n最后，我们计算正确解析的标识符的总期望数量：\n$$ E[\\text{correct}] = n_{\\mathcal{A}} P_{C, \\mathcal{A}} + n_{\\mathcal{B}} P_{C, \\mathcal{B}} + n_{\\mathcal{C}} P_{C, \\mathcal{C}} $$\n$$ E[\\text{correct}] = 12 \\left(\\frac{9}{11}\\right) + 10 \\left(\\frac{27}{52}\\right) + 10 \\left(\\frac{50}{71}\\right) $$\n$$ E[\\text{correct}] = \\frac{108}{11} + \\frac{270}{52} + \\frac{500}{71} $$\n现在，我们将这些值转换为十进制数以进行最终求和：\n$$ E[\\text{correct}] \\approx 9.818181... + 5.192307... + 7.042253... $$\n$$ E[\\text{correct}] \\approx 22.052742... $$\n问题要求将最终答案四舍五入到四位有效数字。前四位有效数字是 $2$、$2$、$0$ 和 $5$。第五位有效数字是 $2$，所以我们向下舍入。\n$$ E[\\text{correct}] \\approx 22.05 $$\n正确解析的标识符的期望数量约为 $22.05$。",
            "answer": "$$\\boxed{22.05}$$"
        },
        {
            "introduction": "在正确映射标识符之后，下一步是定义统计检验的“背景集”或“基因全集”。这是一个至关重要但又常常被忽视的步骤，错误的选择会系统性地扭曲分析结果。本练习  旨在阐明为何必须根据实验能够测量的范围来定义基因全集（例如，RNA测序中实际表达的基因，或靶向测序panel上的基因），以保证统计推断的有效性，避免产生假阳性结果。",
            "id": "4343680",
            "problem": "在一项精准肿瘤学研究中，您执行了两种不同的富集分析来解释患者肿瘤中的分子发现。在第一项分析中，使用信使RNA测序（RNA-seq）来鉴定肿瘤与匹配的正常组织中的差异表达基因。经过质量控制和检测筛选后，您保留了$12,000$个基因为表达基因，并以$0.05$的假发现率（FDR）鉴定出$300$个差异表达基因。在第二项分析中，使用一个临床基因面板进行靶向DNA测序，该面板检测了$500$个已知在癌症中反复发生改变的基因，您通过队列水平的检验鉴定出$50$个显著突变的基因。您希望使用Fisher精确检验来评估每个列表在分子特征数据库（MSigDB）的精选通路中的过表达情况。\n\n哪个选项为每项分析定义了最合适的基因全集，并正确地解释了为什么需要使用表达的或检测靶向的全集，而不是基因组中的所有基因，来进行有效的过表达检验？\n\nA. 对两项分析都使用人类基因组中所有的蛋白质编码基因（约$19,000$个）作为全集，因为通路是全基因组范围内定义的，并且更大的全集本质上更保守，可以减少假阳性。\n\nB. 对于RNA测序（RNA-seq）差异表达分析，仅使用数据集中表达水平高于检测阈值的基因作为全集；对于靶向DNA面板突变分析，仅使用检测面板覆盖的基因作为全集。这将抽样框架与可以被测量的内容对齐，保留了Fisher精确检验中隐含的无放回抽样的假设，并避免了因在背景中包含未测量或无法测量的基因而产生的反保守$p$-值。\n\nC. 对两项分析都仅使用通路数据库中出现在任何通路里的基因作为全集，因为富集必须相对于通路注释空间进行计算，而不管检测实际测量了什么。\n\nD. 对于RNA测序（RNA-seq）分析，使用表达的基因作为全集；对于靶向DNA面板突变分析，仍然使用所有的蛋白质编码基因作为全集，以避免因面板相对于基因组的非均匀内容而引入的偏差。\n\nE. 为每个通路定义一个单独的基因全集，仅包含注释到该通路的基因，因为这直接控制了通路大小并通过将检验集中于相关成员来增加统计功效。",
            "solution": "用户要求对问题陈述进行批判性验证，然后提供一个详细的解决方案，推导出正确答案并评估所有选项。\n\n**问题验证**\n\n**第一步：提取已知信息**\n-   **分析1（RNA-seq）：**\n    -   筛选后总表达基因数：12,000。\n    -   差异表达基因（DEGs）：300。\n    -   DEGs的假发现率（FDR）：0.05。\n-   **分析2（靶向DNA测序）：**\n    -   临床基因面板检测的总基因数：500。\n    -   显著突变的基因数：50。\n-   **方法学：**\n    -   评估DEG列表和突变基因列表在精选通路中的过表达情况。\n    -   通路数据库：分子特征数据库（MSigDB）。\n    -   统计检验：Fisher精确检验。\n-   **问题：**\n    -   为这两项分析中的每一项定义合适的基因全集。\n    -   为选择该全集提供正确的理由，特别是说明为什么不应是基因组中的所有基因。\n\n**第二步：使用提取的已知信息进行验证**\n-   **科学基础：** 问题陈述在科学上是合理的。它描述了分子肿瘤学中一个标准的生物信息学工作流程，包括使用RNA-seq进行表达分析，使用靶向测序进行突变分析，以及使用Fisher精确检验和信誉良好的数据库（MSigDB）进行过表达分析（ORA）。所提供的数值对于此类实验是现实的。\n-   **适定性：** 问题是适定的。它要求正确定义“基因全集”或“背景集”，这是富集分析的一个关键参数。问题是具体的，可以根据所选检验背后的统计学原理确定一个唯一的最佳答案。\n-   **客观性：** 语言是技术性的、精确的和客观的，没有主观或含糊的术语。\n-   **完整性和一致性：** 提供的信息足以确定正确的统计方法。没有内部矛盾。\n-   **现实性和可行性：** 该场景高度真实地代表了精准医学和基因组学研究中的数据分析。\n-   **不适定或结构不良：** 问题结构良好。“基因全集”的核心概念是需要解决的关键点，这是该主题的一个标准且非平凡的方面。\n-   **琐碎性：** 问题并非琐碎；选择一个合适的背景/全集是生物信息学中一个常见的错误来源，对结果有重大影响，理解其基本原理对于有效的推断至关重要。\n\n**第三步：结论和行动**\n问题陈述是**有效的**。该场景在科学上是合理的、适定的，并包含进行解答所需的所有必要信息。\n\n**解决方案的推导**\n\n问题的核心在于正确应用Fisher精确检验进行过表达分析（ORA）。该检验评估两组基因——一组“感兴趣的”基因和一个预定义的“通路”基因集——交集中的基因数量是否大于随机机会所预期的数量。\n\nORA背后的统计模型是无放回抽样，由超几何分布描述。想象一个瓮，其中包含一个明确定义的“全集”中的所有基因。Fisher精确检验计算在抽取固定数量的项目（“感兴趣的”基因）时，抽到一定数量“特殊”项目（通路中的基因）的概率。\n\n该检验基于一个 $2 \\times 2$ 列联表：\n\n| | 在通路中 | 不在通路中 | 总计 |\n| :--- | :--- | :--- | :--- |\n| **感兴趣** | $a$ | $b$ | $k=a+b$ |\n| **不感兴趣** | $c$ | $d$ | $ N-k$ |\n| **总计** | $m=a+c$ | $N-m$ | $N$ |\n\n这里：\n-   $N$ 是**全集**中的基因总数。\n-   $k$ 是“感兴趣的”基因总数（例如，DEGs或突变基因）。\n-   $m$ 是通路中也存在于全集中的基因总数。\n-   $a$ 是既是感兴趣的基因又在通路中的基因数量。\n\n通过随机机会观察到恰好 $a$ 个重叠的概率由超几何概率公式给出：\n$$ P(\\text{observing } a) = \\frac{\\binom{m}{a}\\binom{N-m}{k-a}}{\\binom{N}{k}} $$\n然后通过对与观察到的结果一样极端或更极端的结果的概率求和来计算$p$-值。\n\n关键参数是 $N$，即全集。**此检验的一个基本假设是，包含在全集 $N$ 中的每个基因都必须具有非零的，且理想情况下相等的，被选入“感兴趣”列表的*先验*概率。** 如果一个基因在实验中无法被检测或测量，它就不可能被包含在感兴趣的基因列表中。将这些无法测量的基因包含在全集 $N$ 中违反了抽样假设。\n\n这种违规行为会导致统计偏差。当你用永远不可能被选中的基因来扩充全集 $N$ 时，你是在与一个被人为稀释的背景进行检验。预期的重叠数是 $E[a] = k \\times (m/N)$。通过人为增加 $N$（以及在较小程度上增加 $m$），全集中通路基因的比例 $(m/N)$ 会减小，从而降低预期的重叠数 $E[a]$。因此，观察到的重叠数 $a$ 相对于这个被人为压低的预期值会显得大得多，导致人为地得到一个很小的$p$-值。这是一种**反保守偏差**，会增加假阳性率。\n\n将此原则应用于两项分析：\n1.  **RNA-seq 分析：** 感兴趣的基因列表是 300 个DEGs。一个基因只有在其表达首先被可靠地检测到时，才能被宣布为“差异表达”。问题陈述中提到，经过质量控制和筛选后，有 12,000 个基因被保留为“表达”基因。这些是唯一有机会进入DEG列表的基因。因此，此分析的正确全集 $N$ 是这 12,000 个表达基因的集合。\n\n2.  **靶向DNA面板分析：** 感兴趣的基因列表是 50 个显著突变的基因。一个基因只有在被包含在用于检测的测序面板上时，才能被发现“突变”。问题陈述中提到该面板检测了 500 个基因。只有这 500 个基因有任何机会出现在最终列表中。因此，此分析的正确全集 $N$ 是该面板覆盖的 500 个基因的集合。\n\n**逐项分析选项**\n\n**A. 对两项分析都使用人类基因组中所有的蛋白质编码基因（约19,000个）作为全集，因为通路是全基因组范围内定义的，并且更大的全集本质上更保守，可以减少假阳性。**\n-   这种方法存在根本性缺陷。对于RNA-seq分析，它包含了数千个未表达的基因，因此不可能被鉴定为差异表达。对于DNA面板分析，它包含了超过 18,500 个未被检测的基因，因此不可能被鉴定为突变。这违反了统计检验的核心假设。\n-   其理由是不正确的。如上所述，使用不适当的大全集会导致反保守偏差，这会*增加*假阳性，而不是更保守。\n-   **结论：不正确。**\n\n**B. 对于RNA测序（RNA-seq）差异表达分析，仅使用数据集中表达水平高于检测阈值的基因作为全集；对于靶向DNA面板突变分析，仅使用检测面板覆盖的基因作为全集。这将抽样框架与可以被测量的内容对齐，保留了Fisher精确检验中隐含的无放回抽样的假设，并避免了因在背景中包含未测量或无法测量的基因而产生的反保守$p$-值。**\n-   此选项根据底层的实验设计正确地为每项分析确定了合适的全集：RNA-seq使用 12,000 个表达基因，DNA-seq使用 500 个面板基因。\n-   其理由是精确且统计上正确的。它正确地指出，全集必须限制在可以被测量的内容范围内，这样做保留了检验的抽样假设，并且不这样做会引入反保守偏差（增加假阳性）。\n-   **结论：正确。**\n\n**C. 对两项分析都仅使用通路数据库中出现在任何通路里的基因作为全集，因为富集必须相对于通路注释空间进行计算，而不管检测实际测量了什么。**\n-   这是不正确的。虽然未注释到任何通路的基因无法对显著性结果做出贡献，但背景仍必须由实验来定义，而不是由注释数据库定义。一个基因可能在某个通路中，但在感兴趣的组织中不表达（因此RNA-seq无法测量），或者未被包含在靶向面板上。这样的基因没有机会进入“感兴趣”列表，必须从全集中排除。这种方法混淆了实验样本空间和注释空间。\n-   **结论：不正确。**\n\n**D. 对于RNA测序（RNA-seq）分析，使用表达的基因作为全集；对于靶向DNA面板突变分析，仍然使用所有的蛋白质编码基因作为全集，以避免因面板相对于基因组的非均匀内容而引入的偏差。**\n-   此选项为RNA-seq分析定义了正确的全集，但对DNA面板分析的定义是错误的。靶向面板的“偏差”是实验设计的一个明确特征。统计问题必须以该设计为条件，即“在我们检测的基因中，突变的基因是否在给定通路中富集？”试图通过使用整个基因组作为背景来“纠正”面板的设计，实际上是在问一个不同的、统计上无效的问题，并且如选项A所解释的，这会引入反保守偏差。\n-   **结论：不正确。**\n\n**E. 为每个通路定义一个单独的基因全集，仅包含注释到该通路的基因，因为这直接控制了通路大小并通过将检验集中于相关成员来增加统计功效。**\n-   这种逻辑是循环的，使检验变得毫无意义。如果全集 ($N$) 被定义为被测试通路中的基因集 ($m$)，那么 $N=m$。列联表将变得微不足道，因为没有“不在通路中”的基因。全集中所有被发现的感兴趣基因，根据定义，都将位于通路中。该检验将失去所有意义，因为它不再是将感兴趣列表中通路成员的频率与它们在背景群体中的频率进行比较。\n-   **结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "当数据准备就绪，统计框架也已设定，我们就可以执行分析了。为了真正理解商业或开源通路分析工具的内部工作原理，从头开始实现其核心算法是一次宝贵的经历。这项编程挑战  将指导你仅使用基本原理来构建两种基础性的通路分析方法：过表达分析（Over-Representation Analysis, ORA）和基因集富集分析（Gene Set Enrichment Analysis, GSEA），从而巩固你对背后统计模型的理解。",
            "id": "4373311",
            "problem": "开发一个完整的、可运行的程序，该程序仅使用第一性原理和经过充分检验的统计学定义，实现两种在系统生物医学中广泛使用、并受 R/Bioconductor 生态系统实用工具启发的通路分析流程。目标是针对一个已排序的基因列表和一个显著基因集，分析经过整理的通路基因集，这两者都定义在一个固定的基因全集上。您的程序必须为每个提供的测试用例计算两个量：(i) 在所有提供的通路中，通过单侧超表示分析计算出的最小 Benjamini–Hochberg 校正 p 值；(ii) 通过加权移动求和富集分析计算出的这些通路中的最大绝对归一化富集分数，其精确零分布通过枚举获得。所有计算必须是完全确定性的，无需用户输入。\n\n从以下基本原理出发。\n\n1) 将整理过的通路视为基因集。通路表示为一个经过整理的基因集合，其来源如京都基因与基因组百科全书（KEGG）或 Reactome。从算法上讲，每个通路是一个大小为 $N$ 的固定基因全集的有限子集。\n\n2) 超表示分析视为无放回抽样。考虑一个大小为 $N$ 的固定基因全集，其中有 $K$ 个基因被标记为“显著”。对于一个大小为 $n$ 的特定通路，假设其中有 $k$ 个基因是显著的。在显著性与通路成员身份无关的原假设下，通路中观察到的显著基因数量遵循超几何分布。单侧超表示 p 值是观察到至少 $k$ 个显著基因的概率：\n$$\np_{\\mathrm{ORA}} \\;=\\; \\sum_{j=k}^{\\min(n,K)} \\frac{\\binom{K}{j}\\,\\binom{N-K}{n-j}}{\\binom{N}{n}} \\, .\n$$\n对于 $m$ 个通路，Benjamini–Hochberg 多重检验校正将 p 值 $\\{p_{(1)} \\le \\dots \\le p_{(m)}\\}$ 映射到校正值 $q_{(i)} = \\min_{t \\ge i} \\left( \\frac{m}{t} \\, p_{(t)} \\right)$，然后将这些校正值恢复到原始顺序以获得 $\\{q_1,\\dots,q_m\\}$。\n\n3) 基于排序列表的加权移动求和基因集富集分析。设全集中的基因按一个实值分数向量 $r = (r_1,\\dots,r_N)$ 降序排列。对于一个大小为 $N_h = |S|$ 的通路 $S$，定义权重 $w_i = |r_i|^p$，其中指数 $p \\ge 0$。移动求和过程从 $i=1$ 到 $i=N$ 扫描排名，并通过以下方式更新累积和：\n- 当基因 $i$ 在 $S$ 中时，增加 $w_i / \\mathrm{NR}$，其中 $\\mathrm{NR} = \\sum_{i \\in S} w_i$，\n- 当基因 $i$ 不在 $S$ 中时，减少 $1/(N-N_h)$，\n按照惯例，如果 $N_h \\in \\{0,N\\}$，则富集分数为 $0$。\n设移动累积和为 $\\mathrm{RS}_i$。富集分数 $\\mathrm{ES}(S)$ 是 $\\mathrm{RS}_i$ 的最大值和最小值中绝对值较大的那个，其符号由更极端偏差的方向决定。为了归一化，通过枚举在 $N$ 个排名中放置 $N_h$ 个“命中”位置的所有 $\\binom{N}{N_h}$ 种方式来定义精确零分布，在保持 $w_i$ 固定的情况下计算这些排列下的相应富集分数，并设 $\\mu_+ = \\mathbb{E}[\\mathrm{ES} \\mid \\mathrm{ES}>0]$ 和 $\\mu_- = \\mathbb{E}[-\\mathrm{ES} \\mid \\mathrm{ES}0]$。具有观测富集分数 $\\mathrm{ES}$ 的通路的归一化富集分数为：\n$$\n\\mathrm{NES}(S) \\;=\\;\n\\begin{cases}\n\\mathrm{ES}/\\mu_+  \\text{如果 } \\mathrm{ES} > 0 \\text{ 且 } \\mu_+ > 0,\\\\\n-\\mathrm{ES}/\\mu_-  \\text{如果 } \\mathrm{ES}  0 \\text{ 且 } \\mu_- > 0,\\\\\n0  \\text{如果 } N_h \\in \\{0,N\\} \\text{ 或相关均值为 } 0 \\, 。\n\\end{cases}\n$$\n在每个测试用例中，报告所有提供通路中的最大绝对归一化富集分数。\n\n您的程序必须根据以上定义实现这些功能，不需要任何用户输入或外部文件，并且必须确定性地执行。\n\n使用以下测试套件。在所有情况下，基因全集为 $\\{1,2,\\dots,N\\}$，排名按所提供分数 $r$ 的降序排列，权重指数为 $p=1$。\n\n- 测试用例 1：\n  - 全集大小 $N = 12$。\n  - 排名分数 $r = [2.5, 1.8, 1.2, 0.9, 0.4, -0.2, -0.5, -1.0, -1.3, -1.7, -2.0, -2.6]$。\n  - 显著基因 $G_{\\mathrm{sig}} = \\{1,2,3,8,11,12\\}$，所以 $K = 6$。\n  - 通路（整理过的集合）：$S_1 = \\{1,4,6,8\\}$, $S_2 = \\{2,3,5,7,9\\}$, $S_3 = \\{10,11,12\\}$。\n\n- 测试用例 2：\n  - 全集大小 $N = 10$。\n  - 排名分数 $r = [3.0, 2.2, 1.5, 0.8, 0.1, -0.3, -0.9, -1.4, -2.1, -2.8]$。\n  - 显著基因 $G_{\\mathrm{sig}} = \\{1,2,3,9\\}$，所以 $K = 4$。\n  - 通路：$S_1 = \\{4,5,6\\}$, $S_2 = \\{1,2,3,9\\}$, $S_3 = \\{7\\}$。\n\n- 测试用例 3：\n  - 全集大小 $N = 8$。\n  - 排名分数 $r = [1.2, 0.7, 0.3, -0.1, -0.4, -0.8, -1.1, -1.5]$。\n  - 显著基因 $G_{\\mathrm{sig}} = \\varnothing$，所以 $K = 0$。\n  - 通路：$S_1 = \\{1,2,3\\}$, $S_2 = \\{4,5,6,7,8\\}$, $S_3 = \\{1,2,3,4,5,6,7,8\\}$。\n\n为每个测试用例计算：\n- 来自上述定义的超表示分析的、所有列出通路中的最小 Benjamini–Hochberg 校正 p 值，以浮点数形式表示，四舍五入到 $6$ 位小数。\n- 来自具有精确零分布枚举的加权移动求和分析的、所有列出通路中的最大绝对归一化富集分数，以浮点数形式表示，四舍五入到 $6$ 位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个测试用例结果的逗号分隔列表，每个结果本身是按上述顺序排列的双元素列表。具体来说，输出必须是 $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$ 形式的单行文本，其中每个 $a_i$ 和 $b_i$ 都是精确到 $6$ 位小数的浮点数。",
            "solution": "该问题要求实现两种不同的生物信息学通路分析算法：带 Benjamini-Hochberg (BH) 校正的单侧超表示分析 (ORA)，以及使用精确零分布进行归一化的加权移动求和基因集富集分析 (GSEA)。解决方案被划分为多个函数，这些函数直接实现了所提供的统计和算法定义。\n\n**1. 超表示分析 (ORA)**\n\nORA 组件量化了一个通路是否富集了“显著”基因。其统计基础是超几何分布，该分布模拟了无放回抽样。\n\n**1.1. 超几何 p 值**\n\nORA 的核心是计算从一个包含 $K$ 个显著基因、总数为 $N$ 的基因全集中，抽取一个大小为 $n$ 的通路时，观察到至少 $k$ 个显著基因的概率。这个单侧 p 值由超几何分布的生存函数给出：\n$$\np_{\\mathrm{ORA}} \\;=\\; P(X \\ge k) \\;=\\; \\sum_{j=k}^{\\min(n,K)} \\frac{\\binom{K}{j}\\,\\binom{N-K}{n-j}}{\\binom{N}{n}}\n$$\n该公式通过首先定义一个计算二项式系数 $\\binom{n}{k}$ 的函数来实现，为此我们可以利用 `scipy.special.comb`。一个名为 `calculate_hypergeometric_p_value(k, n, K, N)` 的函数从 $j=k$ 迭代到 $\\min(n, K)$，对每种结果的概率求和。分子是两个二项式系数 `comb(K, j)` 和 `comb(N-K, n-j)` 的乘积，分母是 `comb(N, n)`。特殊情况如 $k=0$ 会导致 $p_{\\mathrm{ORA}}=1$，这被明确处理。\n\n**1.2. Benjamini-Hochberg (BH) 多重检验校正**\n\n当检验多个通路时，必须对得到的 p 值进行校正以控制假发现率。Benjamini-Hochberg 过程实现如下：\n1.  设 $m$ 个通路的初始 p 值为 $\\{p_1, p_2, \\dots, p_m\\}$。\n2.  将 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。保留原始索引以便稍后恢复顺序。\n3.  为每个排好序的 p 值计算原始校正 p 值，我们称之为 $q'_{\\text{raw}}$：$q'_{(i)} = \\frac{m}{i} p_{(i)}$，其中 $i$ 是从 1 到 $m$ 的排名。\n4.  为确保校正后的 p 值随原始排序的 p 值单调递增，采用累积最小值。排名为 $i$ 的最终校正 p 值 $q_{(i)}$ 由规则 $q_{(i)} = \\min_{t \\ge i} \\left( \\frac{m}{t} p_{(t)} \\right)$ 定义。这可以通过从排名 $m$ 开始向后迭代来高效计算：\n    $$\n    q_{(m)} = p_{(m)} \\\\\n    q_{(i)} = \\min\\left(q_{(i+1)}, \\frac{m}{i} p_{(i)}\\right) \\quad \\text{for } i = m-1, m-2, \\dots, 1\n    $$\n5.  然后将计算出的已排序 q 值 $\\{q_{(1)}, \\dots, q_{(m)}\\}$ 重新排序，以匹配通路的原始输入顺序。\n该问题 ORA 部分的最终结果是这些校正后 p 值 $\\{q_1, \\dots, q_m\\}$ 中的最小值。\n\n**2. 加权移动求和基因集富集分析 (GSEA)**\n\n这种类 GSEA 的过程评估一个通路的基因是否集中在所有基因的预排序列表的顶部或底部。\n\n**2.1. 富集分数 (ES) 的计算**\n\n对于一个给定的大小为 $N_h$ 的通路 $S$，算法按以下步骤进行：\n1.  全集中的基因根据提供的降序分数 $r_i$ 从 1 到 $N$ 排序。\n2.  为每个基因分配一个权重 $w_i = |r_i|^p$，在此问题中 $p=1$。\n3.  一个移动和 $\\mathrm{RS}$ 初始化为 $0$。算法从 $i=1$ 到 $N$ 迭代遍历排序后的基因列表。\n4.  在每一步 $i$，移动和更新如下：\n    -   如果基因 $i$ 在通路 $S$ 中（一次“命中”），则和增加：$\\mathrm{RS}_i = \\mathrm{RS}_{i-1} + \\frac{w_i}{\\mathrm{NR}}$，其中 $\\mathrm{NR} = \\sum_{j \\in S} w_j$ 是通路中所有基因的权重之和。\n    -   如果基因 $i$ 不在通路 $S$ 中（一次“未命中”），则和减少：$\\mathrm{RS}_i = \\mathrm{RS}_{i-1} - \\frac{1}{N-N_h}$。\n5.  富集分数 $\\mathrm{ES}(S)$ 是移动和与 $0$ 的最大偏差。它被定义为所有 $\\mathrm{RS}_i$ 中绝对值最大的那个值，并保留其原始符号。这可以通过计算 $\\max_i(\\mathrm{RS}_i)$ 和 $\\min_i(\\mathrm{RS}_i)$ 并选择绝对值较大的那个来找到。\n6.  根据定义，如果通路为空 ($N_h=0$) 或包含所有基因 ($N_h=N$)，则富集分数为 $0$。\n\n**2.2. 通过精确零分布进行归一化**\n\n为了使分数在不同通路和数据集之间具有可比性，需要对观测到的 $\\mathrm{ES}$ 进行归一化。\n1.  通过为每个可能的大小为 $N_h$ 的通路计算 $\\mathrm{ES}$，生成一个富集分数的精确零分布。共有 $\\binom{N}{N_h}$ 个这样的通路。这通过从 $N$ 个基因的全集中生成所有 $N_h$ 个基因的组合来实现。\n2.  对于每个“零”通路，使用上述相同的移动求和方法计算一个 $\\mathrm{ES}_{\\text{null}}$，同时保持基因权重 $w_i$ 固定。\n3.  从所有 $\\mathrm{ES}_{\\text{null}}$ 值的所得集合中，将正分数和负分数分开以计算两个归一化因子：\n    -   $\\mu_+ = \\mathbb{E}[\\mathrm{ES} \\mid \\mathrm{ES}>0]$：零分布中所有正富集分数的均值。\n    -   $\\mu_- = \\mathbb{E}[-\\mathrm{ES} \\mid \\mathrm{ES}0]$：零分布中所有负富集分数绝对值的均值。\n4.  然后计算观测通路 $S$ 的归一化富集分数 (Normalized Enrichment Score, $\\mathrm{NES}(S)$)：\n    $$\n    \\mathrm{NES}(S) \\;=\\;\n    \\begin{cases}\n    \\mathrm{ES}(S)/\\mu_+  \\text{如果 } \\mathrm{ES}(S) > 0 \\text{ 且 } \\mu_+ > 0,\\\\\n    -\\mathrm{ES}(S)/\\mu_-  \\text{如果 } \\mathrm{ES}(S)  0 \\text{ 且 } \\mu_- > 0,\\\\\n    0  \\text{其他情况。}\n    \\end{cases}\n    $$\n    第二种情况中的负号确保了对于正富集和负富集，NES 均为正值。该问题 GSEA 部分的最终结果是测试用例中所有通路的最大绝对 NES 值。\n\n**3. 程序结构和执行**\n\n整个程序被构造成独立处理每个测试用例。\n1.  测试用例在一个列表中定义，每个条目包含全集大小 $N$、排名分数 $r$、显著基因集 $G_{\\mathrm{sig}}$ 和通路列表。\n2.  对于每个测试用例，程序首先计算最小的 BH 校正 p 值。它为每个通路计算原始 p 值，然后对整套 p 值应用 BH 校正。\n3.  接下来，它计算最大绝对 NES。为了优化 GSEA 计算，归一化因子 $\\mu_+$ 和 $\\mu_-$ 被缓存。由于这些因子仅取决于全集大小 $N$、通路大小 $N_h$ 和排序列表的权重，因此在给定的测试用例中，对于每个唯一的通路大小，它们只计算一次。\n4.  最后，每个测试用例所需的两个值——最小校正 p 值和最大绝对 NES——被四舍五入到 6 位小数，并格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nfrom itertools import combinations\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the pathway analysis problem for a suite of test cases.\n    It implements Over-Representation Analysis (ORA) with Benjamini-Hochberg\n    correction and a weighted Gene Set Enrichment Analysis (GSEA) with an\n    exact null distribution, as per the problem definitions.\n    \"\"\"\n\n    # --- ORA Helper Functions ---\n\n    def calculate_hypergeometric_p_value(k, n, K, N):\n        \"\"\"\n        Computes the one-sided ORA p-value using the hypergeometric distribution.\n        p_ORA = P(X = k) = sum_{j=k to min(n,K)} [C(K,j)*C(N-K,n-j)] / C(N,n)\n        \n        Args:\n            k (int): Number of significant genes in the pathway.\n            n (int): Size of the pathway.\n            K (int): Total number of significant genes in the universe.\n            N (int): Size of the gene universe.\n\n        Returns:\n            float: The hypergeometric p-value.\n        \"\"\"\n        if k  0 or n  k or K  k or N  n or N  K:\n            # Invalid parameters are not expected but good to handle.\n            return 1.0\n\n        # P(X=k) is 1 if k=0\n        if k == 0:\n            return 1.0\n        \n        try:\n            total_combinations = comb(N, n, exact=True)\n            if total_combinations == 0:\n                return 1.0\n        except ValueError: # Occurs if comb returns a non-integer float\n             total_combinations = comb(N, n, exact=False)\n\n        p_sum = 0.0\n        for j in range(k, min(n, K) + 1):\n            try:\n                term = comb(K, j, exact=True) * comb(N - K, n - j, exact=True)\n                p_sum += term\n            except (ValueError, TypeError): # Handle non-integer results if numbers are large\n                term = comb(K, j, exact=False) * comb(N - K, n - j, exact=False)\n                p_sum += term\n                \n        return p_sum / float(total_combinations)\n\n    def benjamini_hochberg(p_values):\n        \"\"\"\n        Applies the Benjamini-Hochberg (BH) multiple testing correction.\n\n        Args:\n            p_values (list[float]): A list of raw p-values.\n\n        Returns:\n            list[float]: A list of BH-adjusted p-values in the original order.\n        \"\"\"\n        m = len(p_values)\n        if m == 0:\n            return []\n        \n        p_values_np = np.array(p_values)\n        sorted_indices = np.argsort(p_values_np)\n        sorted_p_values = p_values_np[sorted_indices]\n        \n        q_values_sorted = np.zeros(m)\n        q_values_sorted[m-1] = sorted_p_values[m-1]\n        for i in range(m - 2, -1, -1):\n            rank = i + 1\n            correction = m / rank\n            q_values_sorted[i] = min(q_values_sorted[i+1], sorted_p_values[i] * correction)\n\n        q_values = np.zeros(m)\n        q_values[sorted_indices] = q_values_sorted\n        \n        return q_values.tolist()\n\n    # --- GSEA Helper Functions ---\n    \n    def calculate_es(pathway, weights, N):\n        \"\"\"\n        Calculates the Enrichment Score (ES) for a a single pathway.\n\n        Args:\n            pathway (set or list): The set of gene indices in the pathway.\n            weights (list[float]): The weights for all genes in the universe.\n            N (int): The size of the gene universe.\n\n        Returns:\n            float: The raw Enrichment Score.\n        \"\"\"\n        pathway_set = set(pathway)\n        N_h = len(pathway_set)\n        \n        if N_h == 0 or N_h == N:\n            return 0.0\n\n        # Calculate NR, sum of weights for genes in the pathway\n        NR_list = [weights[i-1] for i in pathway_set]\n        NR = sum(NR_list)\n\n        # If all weights in pathway are 0, NR is 0, increments are 0; ES should be -1.\n        # But problem states mu+  0 etc, which will fail. Let's rely on problem data not having this.\n        # For given data, all r_i != 0, so w_i  0, NR  0.\n        if NR == 0.0:\n            return -1.0 # The running sum will only decrease.\n\n        miss_penalty = 1.0 / (N - N_h)\n        \n        rs = 0.0\n        max_rs = -np.inf\n        min_rs = np.inf\n\n        for i in range(1, N + 1):\n            if i in pathway_set:\n                rs += weights[i-1] / NR\n            else:\n                rs -= miss_penalty\n            \n            if rs > max_rs:\n                max_rs = rs\n            if rs  min_rs:\n                min_rs = rs\n        \n        # Return the deviation with the larger absolute value\n        if max_rs > -min_rs:\n            return max_rs\n        else:\n            return min_rs\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 12, \"r\": [2.5, 1.8, 1.2, 0.9, 0.4, -0.2, -0.5, -1.0, -1.3, -1.7, -2.0, -2.6],\n            \"G_sig\": {1, 2, 3, 8, 11, 12},\n            \"pathways\": [{1, 4, 6, 8}, {2, 3, 5, 7, 9}, {10, 11, 12}],\n            \"p_exp\": 1\n        },\n        {\n            \"N\": 10, \"r\": [3.0, 2.2, 1.5, 0.8, 0.1, -0.3, -0.9, -1.4, -2.1, -2.8],\n            \"G_sig\": {1, 2, 3, 9},\n            \"pathways\": [{4, 5, 6}, {1, 2, 3, 9}, {7}],\n            \"p_exp\": 1\n        },\n        {\n            \"N\": 8, \"r\": [1.2, 0.7, 0.3, -0.1, -0.4, -0.8, -1.1, -1.5],\n            \"G_sig\": set(),\n            \"pathways\": [{1, 2, 3}, {4, 5, 6, 7, 8}, {1, 2, 3, 4, 5, 6, 7, 8}],\n            \"p_exp\": 1\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        r = case[\"r\"]\n        G_sig = case[\"G_sig\"]\n        pathways = case[\"pathways\"]\n        p_exp = case[\"p_exp\"]\n        K = len(G_sig)\n        \n        # --- Part 1: ORA Calculation ---\n        ora_p_values = []\n        for S in pathways:\n            n = len(S)\n            k = len(S.intersection(G_sig))\n            p_val = calculate_hypergeometric_p_value(k, n, K, N)\n            ora_p_values.append(p_val)\n        \n        q_values = benjamini_hochberg(ora_p_values)\n        min_q_value = min(q_values) if q_values else 0.0\n        \n        # --- Part 2: GSEA Calculation ---\n        all_nes_values = []\n        gsea_norm_cache = {} \n        weights = [abs(score)**p_exp for score in r]\n        gene_indices = range(1, N + 1)\n        \n        for S in pathways:\n            N_h = len(S)\n            \n            if N_h == 0 or N_h == N:\n                nes = 0.0\n            else:\n                if N_h not in gsea_norm_cache:\n                    # Calculate null distribution for this N_h and cache it\n                    positive_es_sum, negative_es_sum = 0.0, 0.0\n                    n_pos, n_neg = 0, 0\n                    \n                    for null_pathway in combinations(gene_indices, N_h):\n                        es_null = calculate_es(null_pathway, weights, N)\n                        if es_null > 0:\n                            positive_es_sum += es_null\n                            n_pos += 1\n                        elif es_null  0:\n                            negative_es_sum += es_null\n                            n_neg += 1\n                            \n                    mu_plus = positive_es_sum / n_pos if n_pos > 0 else 0.0\n                    mu_minus = -negative_es_sum / n_neg if n_neg > 0 else 0.0\n                    gsea_norm_cache[N_h] = (mu_plus, mu_minus)\n                \n                mu_plus, mu_minus = gsea_norm_cache[N_h]\n                observed_es = calculate_es(S, weights, N)\n                \n                if observed_es > 0 and mu_plus > 0:\n                    nes = observed_es / mu_plus\n                elif observed_es  0 and mu_minus > 0:\n                    nes = -observed_es / mu_minus\n                else:\n                    nes = 0.0\n            \n            all_nes_values.append(nes)\n            \n        max_abs_nes = max([abs(nes) for nes in all_nes_values]) if all_nes_values else 0.0\n        \n        final_results.append([min_q_value, max_abs_nes])\n    \n    # Format the final output as specified\n    formatted_case_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in final_results]\n    print(f\"[{','.join(formatted_case_results)}]\")\n\nsolve()\n```"
        }
    ]
}