{
    "hands_on_practices": [
        {
            "introduction": "在系统生物医学中，物种进化谱（phylogenetic profiles）通过跨物种的基因存在与否来捕捉基因的功能关联。这些谱通常表示为二元向量，因此，量化它们之间的相似性是推断功能联系的第一步。本练习  旨在从第一性原理出发，推导我们熟悉的皮尔逊相关系数（Pearson correlation coefficient）在应用于二元数据时，如何精确地转化为phi系数，从而揭示两者在这一特定背景下的数学等价性。",
            "id": "4375029",
            "problem": "在系统生物医学中，系统发育谱分析将一组物种中基因组特征（例如，直系同源基因家族）的存在与否表示为二元向量。考虑两个这样的谱，$x,y \\in \\{0,1\\}^{N}$，代表 $N$ 个物种。定义经验 $2 \\times 2$ 列联计数如下\n$$\nn_{11}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=1,y_{i}=1\\},\\quad\nn_{10}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=1,y_{i}=0\\},\\quad\nn_{01}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=0,y_{i}=1\\},\\quad\nn_{00}=\\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=0,y_{i}=0\\},\n$$\n并注意 $N=n_{11}+n_{10}+n_{01}+n_{00}$。令 $n_{1.}=n_{11}+n_{10}$，$n_{0.}=n_{01}+n_{00}$，$n_{.1}=n_{11}+n_{01}$ 和 $n_{.0}=n_{10}+n_{00}$ 表示边际计数。\n\n从第一性原理出发，使用经验数据的皮尔逊相关系数 (PCC) 的定义，\n$$\nr_{xy}=\\frac{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)}{\\sqrt{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}}\\sqrt{\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2}}},\n$$\n其中 $\\bar{x}=\\frac{1}{N}\\sum_{i=1}^{N}x_{i}$ 且 $\\bar{y}=\\frac{1}{N}\\sum_{i=1}^{N}y_{i}$，并利用 phi 系数作为 $2 \\times 2$ 列联表的标准化关联度量的核心定义，推导出一个完全用四个联合计数 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 表示的 $r_{xy}$ 的单一闭式解析表达式。然后，在不计算任何额外公式的情况下，用文字解释在何种条件下，皮尔逊相关系数和 phi 系数在系统发育谱分析中对基因对关联的排序结果是相同的。\n\n最终答案表示为仅包含 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 的单一解析表达式。不需要单位，也不需要四舍五入。",
            "solution": "用户希望我首先验证然后解决一个关于二元系统发育谱的皮尔逊相关系数 (PCC) 和 phi 系数之间关系的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **数据：** 两个代表 $N$ 个物种的二元向量（系统发育谱）$x, y \\in \\{0,1\\}^{N}$。\n*   **列联计数：**\n    *   $n_{11} = \\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=1,y_{i}=1\\}$\n    *   $n_{10} = \\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=1,y_{i}=0\\}$\n    *   $n_{01} = \\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=0,y_{i}=1\\}$\n    *   $n_{00} = \\sum_{i=1}^{N}\\mathbf{1}\\{x_{i}=0,y_{i}=0\\}$\n*   **总计数：** $N=n_{11}+n_{10}+n_{01}+n_{00}$。\n*   **边际计数：**\n    *   $n_{1.} = n_{11}+n_{10}$\n    *   $n_{0.} = n_{01}+n_{00}$\n    *   $n_{.1} = n_{11}+n_{01}$\n    *   $n_{.0} = n_{10}+n_{00}$\n*   **皮尔逊相关系数 (PCC) 定义：**\n    $$\n    r_{xy}=\\frac{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)}{\\sqrt{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}}\\sqrt{\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2}}}\n    $$\n*   **均值定义：** $\\bar{x}=\\frac{1}{N}\\sum_{i=1}^{N}x_{i}$ 和 $\\bar{y}=\\frac{1}{N}\\sum_{i=1}^{N}y_{i}$。\n*   **任务：**\n    1.  推导一个用 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 表示的 $r_{xy}$ 的闭式表达式。\n    2.  解释在何种条件下 PCC 和 phi 系数对基因对关联产生相同的排序。问题陈述通过其作为“$2 \\times 2$ 列联表的标准化关联度量”的定义来指代 phi 系数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在科学上和数学上都是合理的。它要求进行统计学中的一个标准推导，特别是证明二元变量的皮尔逊相关系数等同于 phi 系数。\n\n*   **科学依据：** 该问题牢固地植根于生物统计学和生物信息学。系统发育谱分析和使用列联表来衡量基因存在/缺失之间的关联是标准技术。皮尔逊相关系数和 phi 系数是基本的统计度量。\n*   **良构性：** 这个问题是良构的。定义精确，目标明确：进行代数推导。结果是一个唯一的、精确的解析表达式。\n*   **客观性：** 语言正式、精确，没有任何主观或模棱两可的术语。\n*   **缺陷清单：**\n    1.  **科学/事实不健全：** 无。前提是正确的。\n    2.  **不可形式化/不相关：** 无。问题是形式化的，并与指定领域直接相关。\n    3.  **不完整/矛盾：** 无。虽然没有明确给出 phi 系数的公式，但问题指导用户从第一性原理推导 $r_{xy}$ 的公式。上下文暗示这个推导出的公式将是 phi 系数的公式。这是一个标准结果，并且提供了推导所需的所有信息。\n    4.  **不切实际/不可行：** 无。上下文是生物信息学中的一个标准应用。\n    5.  **病态/结构不良：** 无。存在唯一解。\n    6.  **伪深刻/琐碎/同义反复：** 无。该推导需要多个非平凡的代数步骤。\n    7.  **超出科学可验证性：** 无。该推导是一个数学证明。\n\n**步骤 3：结论和行动**\n\n问题是 **有效的**。我将继续进行推导和解释。\n\n### 解答\n\n目标是推导一个完全用四个联合列联计数 $n_{11}$、$n_{10}$、$n_{01}$ 和 $n_{00}$ 表示的二元数据皮尔逊相关系数 $r_{xy}$ 的表达式。我们将从给定的 $r_{xy}$ 定义开始，并系统地使用给定的计数来表示其每个组成部分。\n\n皮尔逊相关系数定义为：\n$$\nr_{xy}=\\frac{\\text{Cov}(x, y)}{\\sigma_x \\sigma_y} = \\frac{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right)}{\\sqrt{\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}}\\sqrt{\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2}}}\n$$\n\n首先，我们用计数来表示样本均值 $\\bar{x}$ 和 $\\bar{y}$。\n和 $\\sum_{i=1}^{N}x_{i}$ 计算了基因 $x$ 存在的物种数量（即 $x_i=1$）。这对应于 ($x_i=1, y_i=1$) 或 ($x_i=1, y_i=0$) 的情况。因此，$\\sum_{i=1}^{N}x_{i} = n_{11} + n_{10} = n_{1.}$。均值 $\\bar{x}$ 是：\n$$\n\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N}x_{i} = \\frac{n_{1.}}{N} = \\frac{n_{11}+n_{10}}{N}\n$$\n根据对称性，均值 $\\bar{y}$ 是：\n$$\n\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N}y_{i} = \\frac{n_{.1}}{N} = \\frac{n_{11}+n_{01}}{N}\n$$\n\n接下来，我们计算分母中的项，这些项与方差有关。\n对于项 $\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2}$，我们使用恒等式 $\\sum (z - \\bar{z})^2 = \\sum z^2 - N\\bar{z}^2$。由于数据是二元的，$x_i \\in \\{0,1\\}$，我们有性质 $x_i^2 = x_i$。因此，$\\sum_{i=1}^{N}x_i^2 = \\sum_{i=1}^{N}x_i = n_{1.}$。该项变为：\n$$\n\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2} = \\sum_{i=1}^{N}x_{i}^2 - N\\bar{x}^2 = n_{1.} - N\\left(\\frac{n_{1.}}{N}\\right)^2 = n_{1.} - \\frac{n_{1.}^2}{N} = \\frac{Nn_{1.} - n_{1.}^2}{N} = \\frac{n_{1.}(N-n_{1.})}{N}\n$$\n由于 $N = n_{1.} + n_{0.}$，我们有 $N - n_{1.} = n_{0.}$。所以，我们得到：\n$$\n\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)^{2} = \\frac{n_{1.}n_{0.}}{N}\n$$\n根据变量 $y$ 的对称性：\n$$\n\\sum_{i=1}^{N}\\left(y_{i}-\\bar{y}\\right)^{2} = \\frac{n_{.1}n_{.0}}{N}\n$$\n\n现在，我们计算分子，这与协方差有关。\n我们使用恒等式 $\\sum (x_i - \\bar{x})(y_i - \\bar{y}) = \\sum x_iy_i - N\\bar{x}\\bar{y}$。\n乘积 $x_i y_i$ 等于 $1$ 当且仅当 $x_i=1$ 且 $y_i=1$。在所有其他情况下，乘积为 $0$。因此，和 $\\sum_{i=1}^{N}x_i y_i$ 只是计算两个基因都存在的物种数量，根据定义即为 $n_{11}$。\n分子项变为：\n$$\n\\sum_{i=1}^{N}\\left(x_{i}-\\bar{x}\\right)\\left(y_{i}-\\bar{y}\\right) = n_{11} - N\\left(\\frac{n_{1.}}{N}\\right)\\left(\\frac{n_{.1}}{N}\\right) = n_{11} - \\frac{n_{1.}n_{.1}}{N} = \\frac{Nn_{11} - n_{1.}n_{.1}}{N}\n$$\n为了简化项 $Nn_{11} - n_{1.}n_{.1}$，我们代入 $N$、$n_{1.}$ 和 $n_{.1}$ 的定义：\n\\begin{align*}\nNn_{11} - n_{1.}n_{.1} = (n_{11}+n_{10}+n_{01}+n_{00})n_{11} - (n_{11}+n_{10})(n_{11}+n_{01}) \\\\\n= (n_{11}^2 + n_{10}n_{11} + n_{01}n_{11} + n_{00}n_{11}) - (n_{11}^2 + n_{11}n_{01} + n_{10}n_{11} + n_{10}n_{01}) \\\\\n= n_{11}^2 + n_{10}n_{11} + n_{01}n_{11} + n_{00}n_{11} - n_{11}^2 - n_{11}n_{01} - n_{10}n_{11} - n_{10}n_{01}\n\\end{align*}\n消去项后，我们剩下：\n$$\nNn_{11} - n_{1.}n_{.1} = n_{11}n_{00} - n_{10}n_{01}\n$$\n所以 $r_{xy}$ 的分子是 $\\frac{n_{11}n_{00} - n_{10}n_{01}}{N}$。\n\n最后，我们组合成 $r_{xy}$ 的完整表达式：\n$$\nr_{xy} = \\frac{\\frac{n_{11}n_{00} - n_{10}n_{01}}{N}}{\\sqrt{\\left(\\frac{n_{1.}n_{0.}}{N}\\right)\\left(\\frac{n_{.1}n_{.0}}{N}\\right)}} = \\frac{\\frac{n_{11}n_{00} - n_{10}n_{01}}{N}}{\\frac{\\sqrt{n_{1.}n_{0.}n_{.1}n_{.0}}}{N}}\n$$\n分子的分母中的因子 $N$ 和整个表达式的分母中的因子 $N$ 相互抵消，得到：\n$$\nr_{xy} = \\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{n_{1.}n_{0.}n_{.1}n_{.0}}}\n$$\n这个表达式就是 phi 系数 $\\phi$ 的定义。为了提供仅用四个联合计数表示的最终答案，我们代入边际计数（$n_{1.}, n_{0.}, n_{.1}, n_{.0}$）的定义：\n$$\nr_{xy} = \\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{(n_{11}+n_{10})(n_{01}+n_{00})(n_{11}+n_{01})(n_{10}+n_{00})}}\n$$\n推导完成。\n\n关于问题的第二部分：“在不计算任何额外公式的情况下，用文字解释在何种条件下，皮尔逊相关系数和 phi 系数在系统发育谱分析中对基因对关联的排序结果是相同的。”\n\n上述推导表明，对于二元变量，例如系统发育谱分析中的存在/缺失向量，皮尔逊相关系数在代数上与 phi 系数完全相同。它们不是在特定条件下碰巧一致的两种不同度量；相反，phi 系数*就是*专门针对两个二元变量情况的皮尔逊相关系数。因此，由于 $r_{xy}$ 和 $\\phi$ 在此上下文中代表相同的数学量，它们对于任何给定的基因对总是会产生相同的值。因此，它们对于任何一组基因对的关联排序必然是相同的。这种等同性成立的唯一“条件”是相关数据必须是二元的，这正是问题陈述本身的基本假设（“系统发育谱分析将存在与否......表示为二元向量”）。",
            "answer": "$$\n\\boxed{\\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{(n_{11}+n_{10})(n_{01}+n_{00})(n_{11}+n_{01})(n_{10}+n_{00})}}}\n$$"
        },
        {
            "introduction": "直接计算物种进化谱之间的相似性会产生误导，因为它忽略了一个基本事实：物种由于共享进化历史而并非相互独立的观测点。为了解决这个问题，我们需要使用考虑了系统发育关系的统计方法，例如系统发育广义最小二乘法（Phylogenetic Generalized Least Squares, PGLS）。这个编程练习  将引导您亲手实现这一关键校正过程，通过“白化”数据来消除系统发育协方差，并进一步学习如何利用自助法（bootstrap）来量化由系统发育树不确定性带来的关联评分的置信区间。",
            "id": "4375055",
            "problem": "给定一组物种水平的协方差矩阵，这些矩阵源于在性状演化的布朗运动模型下，对一个估计的物种系统发育树进行自助法重采样（bootstrap replicates）所产生的结果。在用于功能注释的系统发育谱分析中，两个基因谱在不同物种间的关联得分应考虑到共同的演化历史。在布朗运动模型下，如果一个连续性状沿着一个总根到尖时间为 $T$ 的物种树演化，那么跨物种的性状协方差矩阵等于物种间的共同演化时间，这可以从物种树中估计出来。物种树的自助法重采样会导出一组协方差矩阵，这些矩阵近似了由树推断引起的不确定性。\n\n你的任务是编写一个程序，对于每个测试用例，通过传播自助法协方差矩阵中的变异，计算两个基因谱之间的系统发育校正关联得分，然后报告一个双侧置信区间。该程序必须从第一性原理实现以下步骤：\n\n1. 对于一个给定的对称正定协方差矩阵 $\\mathbf{C} \\in \\mathbb{R}^{n \\times n}$，计算两个向量 $\\mathbf{x} \\in \\mathbb{R}^{n}$ 和 $\\mathbf{y} \\in \\mathbb{R}^{n}$ 之间的系统发育校正关联得分，这两个向量代表了 $n$ 个物种的基因谱。使用以下步骤：\n   - 计算 Cholesky 分解 $\\mathbf{C} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中 $\\mathbf{L}$ 是下三角矩阵。\n   - 求解 $\\mathbf{L}\\mathbf{z}_{x} = \\mathbf{x}$ 和 $\\mathbf{L}\\mathbf{z}_{y} = \\mathbf{y}$ 以获得白化向量 $\\mathbf{z}_{x}$ 和 $\\mathbf{z}_{y}$。\n   - 通过减去各自的算术平均值来中心化每个白化向量：$\\tilde{\\mathbf{z}}_{x} = \\mathbf{z}_{x} - \\bar{z}_{x}\\mathbf{1}$ 和 $\\tilde{\\mathbf{z}}_{y} = \\mathbf{z}_{y} - \\bar{z}_{y}\\mathbf{1}$，其中 $\\bar{z}_{x} = \\frac{1}{n}\\sum_{i=1}^{n} z_{x,i}$ 和 $\\bar{z}_{y} = \\frac{1}{n}\\sum_{i=1}^{n} z_{y,i}$，$\\mathbf{1}$ 是 $\\mathbb{R}^{n}$ 中的全1向量。\n   - 将系统发育校正的关联得分定义为中心化白化向量的 Pearson 相关系数，\n     $$ r = \\frac{\\tilde{\\mathbf{z}}_{x}^{\\top}\\tilde{\\mathbf{z}}_{y}}{\\|\\tilde{\\mathbf{z}}_{x}\\|_{2}\\,\\|\\tilde{\\mathbf{z}}_{y}\\|_{2}}. $$\n     如果 $\\|\\tilde{\\mathbf{z}}_{x}\\|_{2} = 0$ 或 $\\|\\tilde{\\mathbf{z}}_{y}\\|_{2} = 0$，则将该重采样样本的 $r$ 定义为 $0$，以避免除以零。\n   这种构造通过白化实现了广义最小二乘法，其合理性基于布朗运动模型和高斯增量的假设。\n\n2. 对于一组 $K$ 个自助法协方差矩阵 $\\{\\mathbf{C}^{(k)}\\}_{k=1}^{K}$，计算 $K$ 个关联得分 $\\{r^{(k)}\\}_{k=1}^{K}$，每个重采样协方差矩阵对应一个。对于给定的双侧置信水平 $1-\\alpha$，其中 $\\alpha \\in (0,1)$，将下置信限和上置信限计算为经验分位数，其分位点为 $q_{\\mathrm{low}} = \\alpha/2$ 和 $q_{\\mathrm{high}} = 1 - \\alpha/2$。使用以下分位数定义（顺序统计量之间的分段线性插值，也称为类型7分位数）：\n   - 设排序后的值为 $v_{(1)} \\le \\cdots \\le v_{(K)}$。\n   - 对于分位水平 $q \\in [0,1]$，计算\n     $$ h = (K - 1)q + 1, \\quad k = \\lfloor h \\rfloor, \\quad \\gamma = h - k. $$\n   - 分位数为\n     $$ Q(q) = \\begin{cases}\n     v_{(k)}  \\text{如果 } \\gamma = 0,\\\\\n     v_{(k)} + \\gamma\\left(v_{(k+1)} - v_{(k)}\\right)  \\text{如果 } \\gamma \\in (0,1).\n     \\end{cases} $$\n\n3. 将此过程应用于下面的每个测试用例，设 $\\alpha = 0.05$（即 $q_{\\mathrm{low}} = 0.025$ 和 $q_{\\mathrm{high}} = 0.975$）。为了数值稳定性，如果协方差矩阵接近奇异，你可以在进行 Cholesky 分解之前添加一个小的对角线抖动 $\\varepsilon \\mathbf{I}$，其中 $\\varepsilon = 10^{-10}$。\n\n测试套件。每个测试用例包含一对 $(\\mathbf{x}, \\mathbf{y})$ 和一个自助法协方差矩阵列表。所有数字都是实数值。向量按物种顺序 $\\{s_{1}, s_{2}, s_{3}, s_{4}\\}$ 列出。\n\n- 测试用例 1 (理想情况；强一致性):\n  - $\\mathbf{x} = [\\,1,\\,1,\\,0,\\,0\\,]$, $\\mathbf{y} = [\\,1,\\,1,\\,0,\\,0\\,]$.\n  - 自助法协方差矩阵 ($K = 5$):\n    - $\\mathbf{C}^{(1)} = \\begin{bmatrix}\n      1.0  0.8  0.2  0.2\\\\\n      0.8  1.0  0.2  0.2\\\\\n      0.2  0.2  1.0  0.7\\\\\n      0.2  0.2  0.7  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(2)} = \\begin{bmatrix}\n      1.0  0.75  0.25  0.25\\\\\n      0.75  1.0  0.25  0.25\\\\\n      0.25  0.25  1.0  0.65\\\\\n      0.25  0.25  0.65  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(3)} = \\begin{bmatrix}\n      1.0  0.85  0.15  0.15\\\\\n      0.85  1.0  0.15  0.15\\\\\n      0.15  0.15  1.0  0.6\\\\\n      0.15  0.15  0.6  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(4)} = \\begin{bmatrix}\n      1.0  0.7  0.3  0.2\\\\\n      0.7  1.0  0.2  0.3\\\\\n      0.3  0.2  1.0  0.55\\\\\n      0.2  0.3  0.55  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(5)} = \\begin{bmatrix}\n      1.0  0.78  0.22  0.22\\\\\n      0.78  1.0  0.22  0.22\\\\\n      0.22  0.22  1.0  0.68\\\\\n      0.22  0.22  0.68  1.0\n      \\end{bmatrix}$.\n\n- 测试用例 2 (边界情况；近星状树，完全一致性):\n  - $\\mathbf{x} = [\\,0,\\,1,\\,0,\\,1\\,]$, $\\mathbf{y} = [\\,0,\\,1,\\,0,\\,1\\,]$.\n  - 自助法协方差矩阵 ($K = 5$):\n    - $\\mathbf{C}^{(1)} = \\begin{bmatrix}\n      1.0  0.4  0.4  0.4\\\\\n      0.4  1.0  0.4  0.4\\\\\n      0.4  0.4  1.0  0.4\\\\\n      0.4  0.4  0.4  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(2)} = \\begin{bmatrix}\n      1.0  0.3  0.3  0.3\\\\\n      0.3  1.0  0.3  0.3\\\\\n      0.3  0.3  1.0  0.3\\\\\n      0.3  0.3  0.3  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(3)} = \\begin{bmatrix}\n      1.0  0.2  0.2  0.2\\\\\n      0.2  1.0  0.2  0.2\\\\\n      0.2  0.2  1.0  0.2\\\\\n      0.2  0.2  0.2  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(4)} = \\begin{bmatrix}\n      1.0  0.5  0.5  0.5\\\\\n      0.5  1.0  0.5  0.5\\\\\n      0.5  0.5  1.0  0.5\\\\\n      0.5  0.5  0.5  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(5)} = \\begin{bmatrix}\n      1.0  0.35  0.35  0.35\\\\\n      0.35  1.0  0.35  0.35\\\\\n      0.35  0.35  1.0  0.35\\\\\n      0.35  0.35  0.35  1.0\n      \\end{bmatrix}$.\n\n- 测试用例 3 (边缘情况；自助法树之间的模式不一致):\n  - $\\mathbf{x} = [\\,1,\\,1,\\,0,\\,0\\,]$, $\\mathbf{y} = [\\,1,\\,0,\\,1,\\,0\\,]$.\n  - 自助法协方差矩阵 ($K = 5$):\n    - $\\mathbf{C}^{(1)} = \\begin{bmatrix}\n      1.0  0.8  0.2  0.2\\\\\n      0.8  1.0  0.2  0.2\\\\\n      0.2  0.2  1.0  0.7\\\\\n      0.2  0.2  0.7  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(2)} = \\begin{bmatrix}\n      1.0  0.2  0.8  0.2\\\\\n      0.2  1.0  0.2  0.75\\\\\n      0.8  0.2  1.0  0.2\\\\\n      0.2  0.75  0.2  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(3)} = \\begin{bmatrix}\n      1.0  0.2  0.2  0.8\\\\\n      0.2  1.0  0.75  0.2\\\\\n      0.2  0.75  1.0  0.2\\\\\n      0.8  0.2  0.2  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(4)} = \\begin{bmatrix}\n      1.0  0.6  0.4  0.3\\\\\n      0.6  1.0  0.3  0.4\\\\\n      0.4  0.3  1.0  0.6\\\\\n      0.3  0.4  0.6  1.0\n      \\end{bmatrix}$,\n      $\\mathbf{C}^{(5)} = \\begin{bmatrix}\n      1.0  0.3  0.3  0.3\\\\\n      0.3  1.0  0.3  0.3\\\\\n      0.3  0.3  1.0  0.3\\\\\n      0.3  0.3  0.3  1.0\n      \\end{bmatrix}$.\n\n实现要求:\n- 使用上述确切的分位数定义，其中 $q_{\\mathrm{low}} = 0.025$ 和 $q_{\\mathrm{high}} = 0.975$。\n- 如果由于数值问题导致 Cholesky 分解失败，你可以在对角线上添加一个抖动 $\\varepsilon = 10^{-10}$。\n- 对于每个测试用例，将置信区间报告为一对 $[L, U]$，其中 $L$ 和 $U$ 是四舍五入到 $6$ 位小数的实数。\n\n最终输出格式:\n- 你的程序应生成单行输出，包含三个测试用例的结果，形式为一个包含三个区间的列表，每个区间本身是一个双元素列表，没有空格，数字四舍五入到 $6$ 位小数。例如：$[[0.123456,0.654321],[0.100000,0.900000],[\\dots,\\dots]]$。",
            "solution": "该问题要求实现一个程序，用于计算两个基因谱之间经系统发育校正的关联得分，并基于底层物种系统发育树的自助法重采样构建该得分的置信区间。该问题在科学上是合理的，在数学上是明确定义的，并提供了所有必要的数据和规范。因此，我们可以着手解决。\n\n该解决方案基于三个主要原则：\n1.  使用广义最小二乘法 (GLS) 通过数据白化来校正数据的非独立性。\n2.  将关联得分计算为白化数据上的 Pearson 相关系数。\n3.  使用自助法百分位置信区间来量化不确定性。\n\n**1. 通过数据白化进行系统发育校正**\n\n在演化生物学中，对一组相关物种测量的性状在统计上并非独立的。共同的演化历史引入了一种协方差结构，在统计分析中必须予以考虑。性状演化的布朗运动模型假定，对于 $n$ 个物种，一个连续性状向量 $\\mathbf{x} \\in \\mathbb{R}^{n}$ 服从多元正态分布 $\\mathbf{x} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$，其中 $\\boldsymbol{\\mu}$ 是均值向量，$\\mathbf{C} \\in \\mathbb{R}^{n \\times n}$ 是协方差矩阵。该矩阵的元素 $C_{ij}$ 与从系统发育树的根到物种 $i$ 和 $j$ 的最近共同祖先的共享分支长度（演化时间）成正比。\n\n像 Pearson 相关性这样的标准统计方法假设观测值是独立同分布的 (i.i.d.)。为了使用这类方法，我们必须首先对数据进行变换以消除系统发育相关性。这个过程被称为“白化”。我们寻求一个线性变换矩阵 $\\mathbf{M}$，使得变换后的向量 $\\mathbf{z} = \\mathbf{M}\\mathbf{x}$ 的协方差矩阵等于单位矩阵 $\\mathbf{I}$。$\\mathbf{z}$ 的协方差由下式给出：\n$$ \\text{Cov}(\\mathbf{z}) = \\text{Cov}(\\mathbf{M}\\mathbf{x}) = \\mathbf{M} \\text{Cov}(\\mathbf{x}) \\mathbf{M}^{\\top} = \\mathbf{M}\\mathbf{C}\\mathbf{M}^{\\top} $$\n我们需要 $\\mathbf{M}\\mathbf{C}\\mathbf{M}^{\\top} = \\mathbf{I}$。\n\n寻找这样一个矩阵 $\\mathbf{M}$ 的标准方法是通过对对称正定协方差矩阵 $\\mathbf{C}$ 进行 Cholesky 分解。Cholesky 分解为 $\\mathbf{C} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中 $\\mathbf{L}$ 是一个唯一的、对角线元素为正的下三角矩阵。\n\n通过选择白化矩阵为 Cholesky 因子的逆，即 $\\mathbf{M} = \\mathbf{L}^{-1}$，我们达到了期望的性质：\n$$ \\mathbf{M}\\mathbf{C}\\mathbf{M}^{\\top} = \\mathbf{L}^{-1} (\\mathbf{L}\\mathbf{L}^{\\top}) (\\mathbf{L}^{-1})^{\\top} = (\\mathbf{L}^{-1}\\mathbf{L}) (\\mathbf{L}^{\\top}(\\mathbf{L}^{\\top})^{-1}) = \\mathbf{I} \\mathbf{I} = \\mathbf{I} $$\n因此，白化向量为 $\\mathbf{z} = \\mathbf{L}^{-1}\\mathbf{x}$。与其显式计算逆矩阵 $\\mathbf{L}^{-1}$，更数值稳定的方法是通过前向代入法求解下三角线性系统 $\\mathbf{L}\\mathbf{z} = \\mathbf{x}$ 来获得 $\\mathbf{z}$。可以向 $\\mathbf{C}$ 添加一个小的对角线抖动 $\\varepsilon\\mathbf{I}$（其中 $\\varepsilon = 10^{-10}$），以确保其在分解前是数值上正定的。\n\n**2. 系统发育校正关联得分的计算**\n\n一旦我们将基因谱 $\\mathbf{x}$ 和 $\\mathbf{y}$ 转换为它们的白化对应项 $\\mathbf{z}_{x}$ 和 $\\mathbf{z}_{y}$，这些新向量的分量就是不相关且具有单位方差的。现在我们可以使用标准的 Pearson 相关系数来计算一个有意义的关联得分。\n\nPearson 相关系数衡量两个数据集之间的线性关系。对于两个向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，它定义为两个向量的协方差除以它们标准差的乘积。这等同于计算它们中心化版本的点积，并用它们的欧几里得范数进行归一化。\n\n首先，我们通过减去各自的算术平均值来中心化白化向量：\n$$ \\tilde{\\mathbf{z}}_{x} = \\mathbf{z}_{x} - \\bar{z}_{x}\\mathbf{1}, \\quad \\text{其中} \\quad \\bar{z}_{x} = \\frac{1}{n}\\sum_{i=1}^{n} z_{x,i} $$\n$$ \\tilde{\\mathbf{z}}_{y} = \\mathbf{z}_{y} - \\bar{z}_{y}\\mathbf{1}, \\quad \\text{其中} \\quad \\bar{z}_{y} = \\frac{1}{n}\\sum_{i=1}^{n} z_{y,i} $$\n这里，$\\mathbf{1}$ 是全1向量。系统发育校正的关联得分 $r$ 是 $\\mathbf{z}_{x}$ 和 $\\mathbf{z}_{y}$ 的 Pearson 相关系数：\n$$ r = \\frac{\\tilde{\\mathbf{z}}_{x}^{\\top}\\tilde{\\mathbf{z}}_{y}}{\\|\\tilde{\\mathbf{z}}_{x}\\|_{2}\\,\\|\\tilde{\\mathbf{z}}_{y}\\|_{2}} $$\n如果任一中心化白化向量的范数为零（即 $\\|\\tilde{\\mathbf{z}}_{x}\\|_{2} = 0$ 或 $\\|\\tilde{\\mathbf{z}}_{y}\\|_{2} = 0$），这种情况发生在原始白化向量的所有分量都相同时，相关性是未定义的。在这种特定情况下，问题规定将得分定义为 $r = 0$。\n\n**3. 自助法置信区间**\n\n协方差矩阵 $\\mathbf{C}$ 是从一个估计的系统发育树中得出的，而这个树本身也存在不确定性。为了将这种不确定性传播到我们的关联得分中，我们使用一组 $K$ 个自助法重采样系统发育树，这会产生一组 $K$ 个协方差矩阵 $\\{\\mathbf{C}^{(k)}\\}_{k=1}^{K}$。\n\n对于每个矩阵 $\\mathbf{C}^{(k)}$，我们如上所述计算关联得分 $r^{(k)}$。这给了我们一个关联得分的样本分布 $\\{r^{(k)}\\}_{k=1}^{K}$，它反映了系统发育树中的不确定性。\n\n一个置信水平为 $1-\\alpha$ 的双侧置信区间可以通过找到这个自助法分布的经验分位数来构建。下限是分位数 $q_{\\mathrm{low}} = \\alpha/2$，上限是分位数 $q_{\\mathrm{high}} = 1 - \\alpha/2$。问题指定了类型7分位数定义，该定义涉及线性插值。\n\n设排序后的得分为 $v_{(1)} \\le v_{(2)} \\le \\cdots \\le v_{(K)}$。对于一个期望的分位数 $q \\in [0,1]$，我们计算一个基于1的索引 $h = (K - 1)q + 1$。我们找到它的整数部分 $k = \\lfloor h \\rfloor$ 和小数部分 $\\gamma = h - k$。然后分位数 $Q(q)$ 通过插值计算得出：\n$$ Q(q) = v_{(k)} + \\gamma(v_{(k+1)} - v_{(k)}) $$\n对于边缘情况，如果 $\\gamma = 0$，则 $Q(q) = v_{(k)}$。这是从有限样本中估计分位数的标准方法。对于给定的问题，$\\alpha = 0.05$，所以我们计算 $q=0.025$ 和 $q=0.975$ 时的分位数。\n\n这完成了算法的正式规范。我们现在将进行其实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cholesky, solve_triangular\nfrom scipy.linalg.lapack import dpotrf\n\ndef solve():\n    \"\"\"\n    Computes phylogenetically corrected association scores and confidence intervals\n    for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"y\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"C_list\": [\n                np.array([\n                    [1.0, 0.8, 0.2, 0.2],\n                    [0.8, 1.0, 0.2, 0.2],\n                    [0.2, 0.2, 1.0, 0.7],\n                    [0.2, 0.2, 0.7, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.75, 0.25, 0.25],\n                    [0.75, 1.0, 0.25, 0.25],\n                    [0.25, 0.25, 1.0, 0.65],\n                    [0.25, 0.25, 0.65, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.85, 0.15, 0.15],\n                    [0.85, 1.0, 0.15, 0.15],\n                    [0.15, 0.15, 1.0, 0.6],\n                    [0.15, 0.15, 0.6, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.7, 0.3, 0.2],\n                    [0.7, 1.0, 0.2, 0.3],\n                    [0.3, 0.2, 1.0, 0.55],\n                    [0.2, 0.3, 0.55, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.78, 0.22, 0.22],\n                    [0.78, 1.0, 0.22, 0.22],\n                    [0.22, 0.22, 1.0, 0.68],\n                    [0.22, 0.22, 0.68, 1.0]\n                ])\n            ]\n        },\n        {\n            \"x\": np.array([0.0, 1.0, 0.0, 1.0]),\n            \"y\": np.array([0.0, 1.0, 0.0, 1.0]),\n            \"C_list\": [\n                np.array([\n                    [1.0, 0.4, 0.4, 0.4], [0.4, 1.0, 0.4, 0.4],\n                    [0.4, 0.4, 1.0, 0.4], [0.4, 0.4, 0.4, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.3, 0.3, 0.3], [0.3, 1.0, 0.3, 0.3],\n                    [0.3, 0.3, 1.0, 0.3], [0.3, 0.3, 0.3, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.2, 0.2, 0.2], [0.2, 1.0, 0.2, 0.2],\n                    [0.2, 0.2, 1.0, 0.2], [0.2, 0.2, 0.2, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.5, 0.5, 0.5], [0.5, 1.0, 0.5, 0.5],\n                    [0.5, 0.5, 1.0, 0.5], [0.5, 0.5, 0.5, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.35, 0.35, 0.35], [0.35, 1.0, 0.35, 0.35],\n                    [0.35, 0.35, 1.0, 0.35], [0.35, 0.35, 0.35, 1.0]\n                ])\n            ]\n        },\n        {\n            \"x\": np.array([1.0, 1.0, 0.0, 0.0]),\n            \"y\": np.array([1.0, 0.0, 1.0, 0.0]),\n            \"C_list\": [\n                np.array([\n                    [1.0, 0.8, 0.2, 0.2], [0.8, 1.0, 0.2, 0.2],\n                    [0.2, 0.2, 1.0, 0.7], [0.2, 0.2, 0.7, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.2, 0.8, 0.2], [0.2, 1.0, 0.2, 0.75],\n                    [0.8, 0.2, 1.0, 0.2], [0.2, 0.75, 0.2, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.2, 0.2, 0.8], [0.2, 1.0, 0.75, 0.2],\n                    [0.2, 0.75, 1.0, 0.2], [0.8, 0.2, 0.2, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.6, 0.4, 0.3], [0.6, 1.0, 0.3, 0.4],\n                    [0.4, 0.3, 1.0, 0.6], [0.3, 0.4, 0.6, 1.0]\n                ]),\n                np.array([\n                    [1.0, 0.3, 0.3, 0.3], [0.3, 1.0, 0.3, 0.3],\n                    [0.3, 0.3, 1.0, 0.3], [0.3, 0.3, 0.3, 1.0]\n                ])\n            ]\n        }\n    ]\n\n    alpha = 0.05\n    q_low = alpha / 2.0\n    q_high = 1.0 - alpha / 2.0\n    epsilon = 1e-10\n\n    results = []\n    \n    for case in test_cases:\n        x = case[\"x\"]\n        y = case[\"y\"]\n        C_list = case[\"C_list\"]\n        n = x.shape[0]\n\n        r_scores = []\n        for C_orig in C_list:\n            C = C_orig.copy()\n            # Perform Cholesky factorization, adding jitter if not positive definite\n            try:\n                # Use raw LAPACK call to check for non-positive-definiteness\n                # dpotrf returns a positive info value if not positive definite\n                _, info = dpotrf(C, lower=True, overwrite_a=False, clean=True)\n                if info > 0:\n                    raise np.linalg.LinAlgError(\"Matrix is not positive definite\")\n                L = cholesky(C, lower=True)\n            except np.linalg.LinAlgError:\n                C_jittered = C + np.eye(n) * epsilon\n                L = cholesky(C_jittered, lower=True)\n\n            # Whiten the vectors by solving L * z = x (and y)\n            zx = solve_triangular(L, x, lower=True)\n            zy = solve_triangular(L, y, lower=True)\n\n            # Center the whitened vectors\n            zx_tilde = zx - np.mean(zx)\n            zy_tilde = zy - np.mean(zy)\n\n            # Compute norms\n            norm_zx = np.linalg.norm(zx_tilde)\n            norm_zy = np.linalg.norm(zy_tilde)\n\n            # Compute the phylogenetically corrected association score (Pearson correlation)\n            if norm_zx == 0 or norm_zy == 0:\n                r = 0.0\n            else:\n                numerator = np.dot(zx_tilde, zy_tilde)\n                denominator = norm_zx * norm_zy\n                r = numerator / denominator\n            \n            r_scores.append(r)\n\n        # Compute the confidence interval using type-7 quantiles\n        # np.quantile with interpolation='linear' implements type-7\n        lower_bound = np.quantile(r_scores, q_low, interpolation='linear')\n        upper_bound = np.quantile(r_scores, q_high, interpolation='linear')\n        \n        results.append([round(lower_bound, 6), round(upper_bound, 6)])\n\n    # Format the final output string\n    output_str = \"[[\" + \"],[\".join([\",\".join([f\"{v:.6f}\" for v in r]) for r in results]) + \"]]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在计算出经过系统发育校正的关联评分后，下一个关键步骤是评估这些评分预测真实功能连锁（functional linkage）的效力。然而，构建一个可靠的“金标准”基准数据集充满挑战，最大的陷阱之一是循环论证——即用于评估的“答案”本身可能是基于我们正在测试的计算信号（如基因共现）所构建的。本练习  挑战您像一位严谨的研究者一样思考，设计一个能避免常见偏见和信息泄露的验证方案，从而确保模型评估的公正性和科学有效性。",
            "id": "4374981",
            "problem": "一个系统生物医学研究小组正在构建一个系统发育谱分析模型，以推断人类基因之间的功能联系。对于每个基因 $g$，他们构建一个系统发育谱 $p_g \\in \\{0,1\\}^{S}$，用以表示该基因在 $S$ 个参考物种中是否存在。他们将训练一个预测器，该预测器在给定两个基因 $g$ 和 $h$ 的情况下，仅使用 $(p_g,p_h)$ 的函数作为特征，输出一个功能联系的分数。他们需要一个包含正例和负例的“金标准”来评估该预测器。他们意识到，一些通路和复合物数据库的整理（至少部分地）使用了包括系统发育共现性在内的比较基因组学信号，他们希望避免评估标签在统计上依赖于输入特征而产生的循环论证。\n\n从基本原则出发，考虑以下核心定义和事实：\n\n- 功能联系被操作化为一个关于基因对 $(g,h)$ 的未观测二元变量 $Y \\in \\{0,1\\}$，其中 $Y=1$ 表示 $g$ 和 $h$ 参与在至少一个相关细胞环境中活跃的同一分子机器或通路，否则 $Y=0$。\n- 金标准使用经过整理的证据，在一部分基因对上定义了观测标签 $\\tilde{Y}$。如果生成 $\\tilde{Y}$ 的机制，在训练和评估方案的条件下，独立于预测器所使用的从系统发育谱中派生的特定特征，那么该金标准就适用于无偏评估。形式上，如果使用的特征是 $X=\\phi(p_g,p_h)$，避免循环论证的一个必要条件是，生成 $\\tilde{Y}$ 的整理过程不使用 $X$ 或与 $X$ 紧密共线的变换，并且训练集和测试集之间没有信息泄露。\n- 如果随机负例对在与生物学无关的协变量（如系统发育谱的稀疏性或基因家族大小）上与正例对存在系统性差异，它们可能会引入混杂因素。在这些协变量上进行匹配或分层可以减少偏差。\n- 时间划分和物种划分设计可以强制实现独立性。时间划分将金标准冻结在过去的某个时间点 $t_0$，并禁止任何在 $t_0$ 之后进行的整理工作进入标签。物种划分将特征构建限制在一个物种子集上，该子集与整理信号中使用的物种不相交，从而减少依赖性。\n\n研究小组提出了以下候选方案，用于定义正例和负例并评估其预测器。当系统发育谱可能已对数据整理做出贡献时，哪种方案为功能联系提供了科学上合理的金标准，并避免了循环论证？\n\nA. 正例是在时间点 $t_1>t_0$ 发布的一个著名通路数据库中被共同注释的所有人类基因对，该数据库明确整合了多种计算信号，包括系统发育共现性、基因邻近性和共表达；负例是随机的人类基因对；评估使用基于基因对的随机 $k$-折交叉验证，特征从所有 $S$ 个物种计算得出。\n\nB. 正例是在一个手动整理的复合物数据库中，共同出现在同一蛋白质复合物中的人类基因对，仅限于具有直接实验证据代码的条目，且数据库快照冻结在时间点 $t_0$；负例是与正例在基因家族大小以及边际谱稀疏度 $\\|p_g\\|_0$ 和 $\\|p_h\\|_0$ 上相匹配的人类基因对；评估采用复合物级别的交叉验证，即没有复合物同时为训练集和测试集贡献基因对，并且特征是从物种子集 $S_{\\text{feat}} \\subset S$ 计算得出，该子集排除了整理者用于组装复合物的任何分类单元，并进行“留一进化分支”的物种敏感性分析。\n\nC. 正例是在一个包含手动和电子推断注释的通路数据库的最新快照（时间 $t_2>t_0$）中，被共同注释到同一通路的人类基因对；负例是来自不同染色体的人类基因对；评估使用按基因身份进行的分层 $k$-折交叉验证，允许来自同一复合物的基因对出现在不同的折中；特征从所有 $S$ 个物种计算得出。\n\nD. 正例被定义为谱相似度高于一个固定阈值的人类基因对，即 $\\rho(p_g,p_h) \\ge \\tau$，其中 $\\rho(\\cdot,\\cdot)$ 是在 $S$ 个物种上计算的皮尔逊相关性，且选择 $\\tau>0$ 以产生期望的类别平衡；负例是满足 $\\rho(p_g,p_h) \\le \\tau'$ 的基因对，其中 $\\tau'  \\tau$；评估时保留一个随机的基因对子集；特征是用于定义标签的 $(p_g,p_h)$ 的相同函数。\n\n选择唯一最佳选项，该选项既为功能联系定义了一个可辩护的金标准，又在考虑到系统发育谱分析可能对数据整理有贡献的情况下正确地避免了循环论证。通过以上述原则和定义进行推理来证明你的选择，并说明其他选项为何失败。注意：$t_0$ 和 $t_1,t_2$ 表示时间点，其中 $t_1>t_0$ 和 $t_2>t_0$，$\\|\\cdot\\|_0$ 表示非零项的计数。只有一个选项是正确的。",
            "solution": "用户要求评估用于创建金标准的候选方案，该金标准用于对一个系统发育谱分析模型进行基准测试。核心挑战是避免循环论证，即评估标签在统计上依赖于输入特征。\n\n**问题验证**\n\n**步骤 1：提取给定信息**\n-   一个模型推断人类基因 $g$ 和 $h$ 之间的功能联系。\n-   输入特征源自系统发育谱 $p_g, p_h \\in \\{0,1\\}^{S}$，其中 $S$ 是物种数量。特征集为 $X=\\phi(p_g,p_h)$。\n-   目标是创建一个包含正例和负例对的金标准来评估模型。\n-   一个关键约束是避免循环论证，如果金标准标签 ($\\tilde{Y}$) 依赖于用于预测的特征 ($X$)，就会出现这种情况。这是一个特别值得关注的问题，因为一些生物学数据库使用系统发育共现性进行数据整理。\n-   功能联系是一个未观测的二元变量 $Y \\in \\{0,1\\}$，其中 $Y=1$ 表示共同参与一个分子机器或通路。\n-   金标准有标签 $\\tilde{Y}$。如果标签生成过程独立于特征 $X$，那么它是无偏的。\n-   随机负例对可能受到诸如谱稀疏性 ($\\|p_g\\|_0$) 或基因家族大小等协变量的混淆。\n-   强制独立性的策略包括时间划分（在时间 $t_0$ 冻结数据库）和物种划分（使用不相交的物种集进行特征构建和数据整理）。\n\n**步骤 2：使用提取的给定信息进行验证**\n问题陈述在科学上是合理的、定义明确的且客观的。\n-   **科学依据：** 该问题描述了计算生物学和生物信息学中一个标准且关键的问题——为预测模型创建非循环的基准。系统发育谱分析、功能联系推断、金标准、交叉验证和混杂变量都是已确立的概念。所概述的策略（时间划分、物种划分、匹配负例）是解决这些问题的公认方法。\n-   **定义明确：** 该问题提供了一个明确的目标（选择最佳方案）和一套可用于评估选项的原则和形式化定义。提供了足够的信息来做出一个合理的、明确的选择。\n-   **客观性：** 问题使用了精确的技术语言和形式化定义（例如，关于循环论证、功能联系）。它没有主观或模糊的术语。\n-   **无缺陷：** 该问题不违反任何无效性标准。它在事实上并非不合理、不是微不足道的、不是定义不当的，也不是无法验证的。该场景是现实的，并提出了一个需要仔细推理的非平凡挑战。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。我将继续对每个选项进行详细分析。\n\n**解决方案推导**\n\n核心任务是找出最能满足问题描述中定义的、科学上合理且非循环的金标准条件的方案。主要标准是：\n1.  **正例来源：** 正例集 ($\\tilde{Y}=1$) 必须是真实功能联系 ($Y=1$) 的可信代理，并且关键是，必须源自独立于系统发育谱特征的证据。\n2.  **负例来源：** 负例集 ($\\tilde{Y}=0$) 的构建必须能最大限度地减少混杂偏倚。\n3.  **避免循环论证：** 该方案必须主动打破特征 $X$ 和标签 $\\tilde{Y}$ 之间的任何统计依赖性。\n4.  **评估设计：** 交叉验证或测试方案必须防止训练集和测试集之间的信息泄露。\n\n**选项分析**\n\n**选项 A：正例来自一个近期的、经计算增强的数据库；负例是随机对；评估使用随机k折交叉验证。**\n-   **正例**：正例集取自一个在时间点 $t_1 > t_0$ 发布的、*明确整合了系统发育共现性*的数据库。这是对独立性原则的直接且严重的违反。标签 $\\tilde{Y}$ 是使用一个已知依赖于特征 $X$ 的过程生成的。这正是该背景下循环论证的定义。\n-   **负例**：使用“随机人类基因对”未能控制已知的混杂因素，如基因家族大小或谱稀疏性。如问题陈述中所述，这可能导致分类器学习到系统性的人为偏差，而不是真正的功能联系生物信号。\n-   **评估**：基于基因对的随机 $k$-折交叉验证是一种较弱的评估策略。如果一个基因 $g$ 是一个大复合物的一部分，基因对 $(g, h_1), (g, h_2), \\dots$ 可能会被分到训练集和测试集中，从而让分类器学习到基因特异的属性，而不是通用的相互作用规则。这会导致性能评估结果虚高。\n-   **结论**：**不正确**。该方案在所有主要标准上都失败了，最关键的是它使循环论证制度化了。\n\n**选项 B：正例来自一个旧的、经实验验证的复合物数据库；负例是匹配的；评估使用复合物级别的交叉验证和物种划分。**\n-   **正例**：正例集由蛋白质复合物数据库中的基因对组成。这是功能联系的一个强有力的代理。该方案实施了几个关键的保障措施：\n    1.  **时间划分：** 数据库冻结在时间点 $t_0$，最大限度地减少了现代计算注释方法的影响。\n    2.  **证据筛选：** 它仅限于具有*直接实验证据代码*的条目，主动过滤掉可能源自像系统发育谱分析这类计算信号的注释。\n-   **负例**：负例明确地“与正例在基因家族大小以及边际谱稀疏度 $\\|p_g\\|_0$ 和 $\\|p_h\\|_0$ 上相匹配”。这是一种严谨的方法，用于创建一个能控制主要已知混杂因素的负例集，从而迫使分类器关注共现信号，而不是更简单的基因属性。\n-   **避免循环论证**：该方案通过结合时间划分、证据筛选以及最重要的**物种划分**，在避免循环论证方面异常强大。通过从一个排除了可能用于数据整理的任何分类单元的物种子集 $S_{\\text{feat}}$ 计算特征，它在用于定义标签的信息和用于构建特征的信息之间创建了一个硬性分离。\n-   **评估**：“复合物级别的交叉验证”是一种鲁棒的评估方案，可确保模型在其泛化到新蛋白质复合物的能力上得到测试，防止了在基于对的划分中常见的信息泄露。“留一进化分支”的物种敏感性分析是严谨研究设计的另一个标志，用于测试所发现模式的鲁棒性。\n-   **结论**：**正确**。该方案系统地、严谨地解决了问题陈述中列出的每一个挑战。它结合了多种最佳实践，以创建一个科学上合理、非循环的金标准和评估框架。\n\n**选项 C：正例来自一个包含电子推断注释的近期数据库；负例来自不同染色体；评估使用分层k折交叉验证。**\n-   **正例**：这使用了一个*近期*（$t_2 > t_0$）的、包含“电子推断注释”的数据库。这带来了非常高的循环论证风险，因为这些电子推断通常基于与预测器使用的证据类别相同（比较基因组学）。\n-   **负例**：将负例定义为来自“不同染色体”的基因对是一种过于简化的启发式方法。许多功能上相关的人类基因位于不同的染色体上。该方法也未能控制基因家族大小、表达偏倚或谱稀疏性等关键混杂因素。\n-   **评估**：“按基因身份进行的分层 $k$-折交叉验证”的描述因“允许来自同一复合物的基因对出现在不同的折中”这一条款而变得模棱两可。这表明是一种基于对的划分，如选项A所讨论的，这种划分容易发生信息泄露和性能虚高。\n-   **结论**：**不正确**。该方案重新引入了循环论证问题，使用了构建不佳的负例集，并采用了可能较弱的评估设计。\n\n**选项 D：正例和负例直接由谱相似度定义。**\n-   **正例/负例**：标签直接由系统发育谱的函数定义：如果 $\\rho(p_g,p_h) \\ge \\tau$，则 $\\tilde{Y}=1$；如果 $\\rho(p_g,p_h) \\le \\tau'$，则 $\\tilde{Y}=0$。在这里，皮尔逊相关性 $\\rho(p_g,p_h)$ 是模型可能使用的特征 $X=\\phi(p_g,p_h)$ 之一。\n-   **循环论证**：这是最极端的循环论证形式。标签不是一个独立的“金标准”，而是输入特征的直接、同义反复的转换。任何在此数据上训练的机器学习模型，其评估都将是看它学习“$\\rho(p_g,p_h)$ 是否大于 $\\tau$？”这个简单规则的能力，这是微不足道的，并且没有提供关于预测*经生物学验证的*功能联系的任何信息。问题陈述明确禁止这种情况：“...生成 $\\tilde{Y}$ 的整理过程不使用 $X$ 或与 $X$ 紧密共线的变换”。\n-   **评估**：在一个标签是输入特征的直接函数的數據集上评估预测器，对于衡量其在外部真实情况下的预测能力来说，不是一个有意义的基准测试。这是一个对同义反复的函数逼近能力的测试。\n-   **结论**：**不正确**。该方案没有创建一个金标准；它创建了一个循环的、自我引用的任务，这对于基准测试来说在科学上是无效的。\n\n**总结**\n选项B是唯一一个展示了对计算生物学中基准构建陷阱有深入理解的方案。它采用多层防御来对抗循环论证和混杂因素，使用正交策略（时间划分、证据筛选、物种划分、匹配负例和鲁棒的交叉验证）以确保公平和严谨的评估。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}