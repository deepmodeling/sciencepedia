{
    "hands_on_practices": [
        {
            "introduction": "理解布尔网络如何从一个状态转换到下一个状态，是掌握其动力学的第一步。这个练习将指导你构建一个简单的三节点基因调控网络的接线图，并计算一个同步更新步骤，从而为你提供关于布尔逻辑和同步更新机制的基础实践。通过这个基本计算，你可以直观地看到网络状态是如何根据预设规则演变的 。",
            "id": "4321671",
            "problem": "在系统生物医学中，基因调控网络（GRN）可以被建模为一个布尔网络，其节点代表基因，其更新规则编码调控逻辑。考虑一个具有节点 $A$、$B$ 和 $C$ 的确定性布尔网络，以及同步更新函数 $f_{A}$、$f_{B}$ 和 $f_{C}$，使得 $f_{A} = B \\land \\neg C$，$f_{B} = A \\lor C$，以及 $f_{C} = \\neg A$。使用布尔网络、布尔逻辑（$\\neg$、$\\land$、$\\lor$）和同步更新的基本定义，执行以下任务：\n\n1. 根据以下原则构建网络的接线图：如果节点 $X$ 出现在 $f_{Y}$ 中，则存在从节点 $X$ 到节点 $Y$ 的有向边，如果 $X$ 未被否定，则为正（激活）符号，如果 $X$ 被否定，则为负（抑制）符号。\n\n2. 从状态 $(A,B,C) = (1,0,1)$ 开始，计算一次同步更新以获得 $(A',B',C')$，其中每个节点根据在当前状态下评估的各自函数同时更新。\n\n将得到的更新后状态作为最终答案。无需四舍五入，也无单位适用。最终答案必须使用 LaTeX 括号表示为单个行向量。",
            "solution": "问题陈述经评估有效。它在科学上基于已建立的布尔网络理论，该理论是系统生物学和离散动力系统的基石。该问题是适定的，提供了一套完整且一致的定义、规则和条件——具体来说，包括网络节点（$A$、$B$、$C$）、同步更新函数（$f_{A}$、$f_{B}$、$f_{C}$）、初始状态以及构建网络拓扑的规则。其语言客观明确，可以得出一个唯一且可验证的解。\n\n该问题需要完成两项任务。首先，我们构建接线图，其次，我们从给定的初始状态计算一次同步更新。\n\n该系统是一个具有三个节点的布尔网络，其状态由向量 $(A, B, C)$ 表示，其中每个变量可以取 $\\{0, 1\\}$ 中的一个值。网络的动力学由同步更新函数控制：\n$$f_{A} = B \\land \\neg C$$\n$$f_{B} = A \\lor C$$\n$$f_{C} = \\neg A$$\n\n**任务 1：接线图构建**\n\n接线图描述了节点之间的调控相互作用。如果节点 $X$ 的状态是节点 $Y$ 更新函数 $f_{Y}$ 的一个参数，则存在从 $X$ 到 $Y$ 的有向边。如果 $X$ 未被否定，则该相互作用定义为激活（正向）；如果 $X$ 以否定形式（$\\neg X$）出现，则定义为抑制（负向）。\n\n1.  **$f_{A} = B \\land \\neg C$ 的分析**：\n    *   节点 $A$ 的函数依赖于节点 $B$ 和 $C$。\n    *   $B$ 未被否定，表示从 $B$ 到 $A$ 的激活相互作用。\n    *   $C$ 以 $\\neg C$ 的形式被否定，表示从 $C$ 到 $A$ 的抑制相互作用。\n\n2.  **$f_{B} = A \\lor C$ 的分析**：\n    *   节点 $B$ 的函数依赖于节点 $A$ 和 $C$。\n    *   $A$ 未被否定，表示从 $A$ 到 $B$ 的激活相互作用。\n    *   $C$ 未被否定，表示从 $C$ 到 $B$ 的激活相互作用。\n\n3.  **$f_{C} = \\neg A$ 的分析**：\n    *   节点 $C$ 的函数依赖于节点 $A$。\n    *   $A$ 以 $\\neg A$ 的形式被否定，表示从 $A$ 到 $C$ 的抑制相互作用。\n\n总结来说，有向边为：$A \\to B$ (激活)，$A \\dashv C$ (抑制)，$B \\to A$ (激活)，$C \\to A$ (抑制)，以及 $C \\to B$ (激活)。\n\n**任务 2：同步状态更新**\n\n我们被要求计算网络在时间 $t+1$ 的状态，表示为 $(A', B', C')$，已知时间 $t$ 的状态为 $(A, B, C) = (1, 0, 1)$。在同步更新方案中，所有节点都基于网络在时间 $t$ 的状态同时更新。\n\n设时间 $t$ 的状态为 $(A(t), B(t), C(t)) = (1, 0, 1)$。时间 $t+1$ 的状态 $(A(t+1), B(t+1), C(t+1))$ 计算如下：\n\n1.  **节点 A 的更新**：\n    $A(t+1) = f_{A}(A(t), B(t), C(t)) = B(t) \\land \\neg C(t)$\n    代入给定值：\n    $A(t+1) = 0 \\land \\neg 1$\n    在布尔逻辑中，$\\neg 1 = 0$。因此：\n    $A(t+1) = 0 \\land 0 = 0$\n\n2.  **节点 B 的更新**：\n    $B(t+1) = f_{B}(A(t), B(t), C(t)) = A(t) \\lor C(t)$\n    代入给定值：\n    $B(t+1) = 1 \\lor 1$\n    在布尔逻辑中，$1 \\lor 1 = 1$。因此：\n    $B(t+1) = 1$\n\n3.  **节点 C 的更新**：\n    $C(t+1) = f_{C}(A(t), B(t), C(t)) = \\neg A(t)$\n    代入给定值：\n    $C(t+1) = \\neg 1$\n    在布尔逻辑中，$\\neg 1 = 0$。因此：\n    $C(t+1) = 0$\n\n综合这些结果，网络的更新后状态为 $(A', B', C') = (A(t+1), B(t+1), C(t+1)) = (0, 1, 0)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  1  0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在布尔网络建模中，更新机制的选择（同步或异步）是一个关键决策，它会深刻影响模型的预测结果。本练习通过对比同步与异步更新，揭示不同动力学假设如何导致截然不同的可达状态集和系统长期行为（吸引子）。通过计算和比较这两种模式下的状态轨迹，你将深入理解模型假设对系统动力学分析的重要性 。",
            "id": "4321648",
            "problem": "考虑一个小型基因调控模块的布尔网络模型，该模型具有三个节点 $A$、$B$ 和 $C$。每个节点代表一个二值调控元件，$0$ 表示非激活状态，$1$ 表示激活状态。该网络通过更新函数 $f_A$、$f_B$ 和 $f_C$ 进行演化，这些函数将当前全局状态映射到每个节点的下一个值。更新函数定义为 $f_A = B$、$f_B = \\neg C$ 和 $f_C = A \\land B$，其中 $\\neg$ 表示逻辑非，$\\land$ 表示逻辑与。全局状态是向量 $(A,B,C) \\in \\{0,1\\}^3$。初始状态为 $(0,1,0)$。\n\n考虑两种更新语义：\n\n- 同步更新：在每个时间步，所有节点 $A$、$B$ 和 $C$ 使用各自的函数 $f_A$、$f_B$ 和 $f_C$ 应用于当前全局状态同时进行更新。\n\n- 一般异步更新：在每个时间步，任意选择一个非空节点子集，只有被选中的节点使用应用于当前全局状态的函数进行更新；未被选中的节点保持其当前值。\n\n从初始状态 $(0,1,0)$ 开始，执行以下操作：\n\n1. 在同步更新下，通过迭代同步更新来枚举轨迹，直到某个状态重复出现，并确定所有不同可达状态的集合及其吸引子（指轨迹中重复出现的模式）。\n\n2. 在一般异步更新下，按如下方式构建从给定状态出发的单步转移可能性：对于当前状态 $(A,B,C)$ 和每个非空子集 $U \\subseteq \\{A,B,C\\}$，通过将 $U$ 中每个节点 $i$ 的值更新为 $f_i(A,B,C)$ 来定义下一个状态，而 $U$ 之外的节点值保持不变。从 $(0,1,0)$ 开始，枚举通过任何此类更新的有限序列可达的所有状态。将吸引子识别为状态转移图中的终端组件，定义为终端强连通分量（TSCCs），其中强连通分量（SCC）是具有相互可达性的最大状态集，而终端组件没有指向组件外部状态的出边转移。\n\n3. 设 $R_{\\text{sync}}$ 为在同步更新下从 $(0,1,0)$ 出发可达的不同状态的数量，设 $R_{\\text{async}}$ 为在一般异步更新下从 $(0,1,0)$ 出发可达的不同状态的数量。计算比率 $r = \\dfrac{R_{\\text{async}}}{R_{\\text{sync}}}$，结果表示为最简精确分数。\n\n将最终答案以单一值 $r$ 的形式给出。无需四舍五入。将分数表示为最简形式，不要包含任何单位。",
            "solution": "用户提供了一个关于布尔网络的问题，并要求计算在两种不同更新方案下可达状态数量的比率。\n\n### 步骤 1：提取已知条件\n- **节点**：$A$、$B$、$C$。\n- **状态空间**：全局状态的集合是 $\\{0,1\\}^3$，其中一个状态是一个向量 $(A,B,C)$。\n- **更新函数**：\n  - $f_A(A,B,C) = B$\n  - $f_B(A,B,C) = \\neg C$\n  - $f_C(A,B,C) = A \\land B$\n- **初始状态**：$S_0 = (0,1,0)$。\n- **更新语义**：\n  1.  **同步**：所有节点在每个时间步同时更新。\n  2.  **一般异步**：在每个时间步，任何非空节点子集都可以更新。\n- **任务**：\n  1.  找到同步更新方案下的可达状态集和吸引子。设可达状态的数量为 $R_{\\text{sync}}$。\n  2.  找到一般异步更新方案下的所有可达状态集和吸引子（终端强连通分量，或 TSCCs）。设可达状态的数量为 $R_{\\text{async}}$。\n  3.  计算比率 $r = \\frac{R_{\\text{async}}}{R_{\\text{sync}}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在布尔网络理论中有坚实的基础，这是系统生物学、计算机科学及相关领域的标准建模框架。同步和异步更新、状态转移图、可达性以及吸引子（环路、SCCs、TSCCs）等概念都是标准的且在数学上是严谨的。\n- **适定性**：该问题定义清晰，具有唯一的初始状态、明确的更新规则和精确的动力学定义。所提问题有确定的、可计算的答案。\n- **客观性**：该问题以形式化的数学语言陈述，没有歧义或主观性。\n\n### 步骤 3：结论与行动\n问题是有效的。这是一个定义明确的离散动力系统练习。我将继续进行求解。\n\n### 第 1 部分：同步更新动力学\n\n在同步更新方案下，网络在时间步 $t+1$ 的状态，记为 $S_{t+1} = (A_{t+1}, B_{t+1}, C_{t+1})$，由时间步 $t$ 的状态 $S_t = (A_t, B_t, C_t)$ 通过以下规则确定：\n$A_{t+1} = f_A(S_t) = B_t$\n$B_{t+1} = f_B(S_t) = \\neg C_t = 1 - C_t$\n$C_{t+1} = f_C(S_t) = A_t \\land B_t = A_t \\cdot B_t$\n\n从初始状态 $S_0 = (0,1,0)$ 开始，我们迭代更新映射：\n- **$t=0$**: $S_0 = (0,1,0)$\n- **$t=1$**: $S_1 = (f_A(S_0), f_B(S_0), f_C(S_0)) = (1, \\neg 0, 0 \\land 1) = (1,1,0)$\n- **$t=2$**: $S_2 = (f_A(S_1), f_B(S_1), f_C(S_1)) = (1, \\neg 0, 1 \\land 1) = (1,1,1)$\n- **$t=3$**: $S_3 = (f_A(S_2), f_B(S_2), f_C(S_2)) = (1, \\neg 1, 1 \\land 1) = (1,0,1)$\n- **$t=4$**: $S_4 = (f_A(S_3), f_B(S_3), f_C(S_3)) = (0, \\neg 1, 1 \\land 0) = (0,0,0)$\n- **$t=5$**: $S_5 = (f_A(S_4), f_B(S_4), f_C(S_4)) = (0, \\neg 0, 0 \\land 0) = (0,1,0)$\n\n由于 $S_5=S_0$，系统进入一个环路。轨迹为 $(0,1,0) \\to (1,1,0) \\to (1,1,1) \\to (1,0,1) \\to (0,0,0) \\to (0,1,0) \\dots$。\n所有不同可达状态的集合是该轨迹中的状态集合：\n$\\mathcal{R}_{\\text{sync}} = \\{(0,1,0), (1,1,0), (1,1,1), (1,0,1), (0,0,0)\\}$。\n在同步更新下，不同可达状态的数量为 $R_{\\text{sync}} = 5$。\n吸引子是环路本身，即集合 $\\mathcal{R}_{\\text{sync}}$。\n\n### 第 2 部分：一般异步更新动力学\n\n在一般异步方案下，从当前状态 $S=(A,B,C)$，我们首先计算目标状态 $S' = (f_A(S), f_B(S), f_C(S))$。任何非空节点子集 $U \\subseteq \\{A,B,C\\}$ 都可以被更新。下一个状态 $S_{next}$ 是通过将 $U$ 中节点 $i$ 的值设为它们在 $S'$ 中的值，并保持 $U$ 之外的节点 $j$ 的值与它们在 $S$ 中的值相同而形成的。\n\n我们从初始状态 $S_0 = (0,1,0)$ 开始执行广度优先搜索（BFS）来找到所有可达状态。\n设 $\\mathcal{R}_{\\text{async}}$ 为可达状态的集合。初始时，$\\mathcal{R}_{\\text{async}} = \\{(0,1,0)\\}$。我们维护一个待访问状态的队列。\n\n1.  **从 $S=(0,1,0)$ 开始**：\n    - 目标状态 $S' = (1, \\neg 0, 0 \\land 1) = (1,1,0)$。\n    - 当前状态 $(0,1,0)$ 与目标状态 $(1,1,0)$ 仅在分量 $A$ 上不同。\n    - 任何包含 $A$ 的更新集 $U$ 将导致下一个状态为 $(1,1,0)$。任何不包含 $A$ 的更新集（即 $\\{B\\}$、$\\{C\\}$、$\\{B,C\\}$）不会改变状态。\n    - 新的可达状态：$(1,1,0)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0)\\}$。\n\n2.  **从 $S=(1,1,0)$ 开始**：\n    - 目标状态 $S' = (1, \\neg 0, 1 \\land 1) = (1,1,1)$。\n    - 差异仅在分量 $C$ 上。任何包含 $C$ 的更新集将导致状态 $(1,1,1)$。\n    - 新的可达状态：$(1,1,1)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0), (1,1,1)\\}$。\n\n3.  **从 $S=(1,1,1)$ 开始**：\n    - 目标状态 $S' = (1, \\neg 1, 1 \\land 1) = (1,0,1)$。\n    - 差异仅在分量 $B$ 上。任何包含 $B$ 的更新集将导致状态 $(1,0,1)$。\n    - 新的可达状态：$(1,0,1)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0), (1,1,1), (1,0,1)\\}$。\n\n4.  **从 $S=(1,0,1)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 1, 1 \\land 0) = (0,0,0)$。\n    - 当前状态 $(1,0,1)$ 与目标状态 $(0,0,0)$ 在分量 $A$ 和 $C$ 上不同。\n    - 更新 $\\{A\\} \\to (0,0,1)$。新状态。\n    - 更新 $\\{C\\} \\to (1,0,0)$。新状态。\n    - 更新 $\\{A,C\\} \\to (0,0,0)$。新状态。\n    - （其他涉及 $B$ 的更新没有效果，因为 $B$ 已经是 $0$）。\n    - 新的可达状态：$(0,0,1), (1,0,0), (0,0,0)$。$\\mathcal{R}_{\\text{async}} = \\{(0,1,0), (1,1,0), (1,1,1), (1,0,1), (0,0,1), (1,0,0), (0,0,0)\\}$。\n\n5.  **从 $S=(0,0,1)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 1, 0 \\land 0) = (0,0,0)$。\n    - 差异在分量 $C$ 上。任何包含 $C$ 的更新集将导致 $(0,0,0)$，该状态已在 $\\mathcal{R}_{\\text{async}}$ 中。没有新状态。\n\n6.  **从 $S=(1,0,0)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 0, 1 \\land 0) = (0,1,0)$。\n    - 差异在分量 $A$ 和 $B$ 上。\n    - 更新 $\\{A\\} \\to (0,0,0)$。已找到。\n    - 更新 $\\{B\\} \\to (1,1,0)$。已找到。\n    - 更新 $\\{A,B\\} \\to (0,1,0)$。已找到。没有新状态。\n\n7.  **从 $S=(0,0,0)$ 开始**：\n    - 目标状态 $S' = (0, \\neg 0, 0 \\land 0) = (0,1,0)$。\n    - 差异在分量 $B$ 上。任何包含 $B$ 的更新集将导致 $(0,1,0)$，该状态已在 $\\mathcal{R}_{\\text{async}}$ 中。没有新状态。\n\n搜索完成。所有可达状态的集合是：\n$\\mathcal{R}_{\\text{async}} = \\{(0,0,0), (0,0,1), (0,1,0), (1,0,0), (1,0,1), (1,1,0), (1,1,1)\\}$。\n有 $7$ 个可达状态。唯一不可达的状态是 $(0,1,1)$。\n所以，$R_{\\text{async}} = 7$。\n\n为了找到吸引子，我们分析这 $7$ 个状态上的状态转移图以寻找强连通分量（SCCs）。\n转移如下：\n- $(0,1,0) \\to (1,1,0)$\n- $(1,1,0) \\to (1,1,1)$\n- $(1,1,1) \\to (1,0,1)$\n- $(1,0,1) \\to \\{(0,0,1), (1,0,0), (0,0,0)\\}$\n- $(0,0,1) \\to (0,0,0)$\n- $(1,0,0) \\to \\{(0,0,0), (1,1,0), (0,1,0)\\}$\n- $(0,0,0) \\to (0,1,0)$\n\n让我们追踪路径以展示相互可达性：\n- 存在一个环路：$(0,1,0) \\to (1,1,0) \\to (1,1,1) \\to (1,0,1) \\to (1,0,0) \\to (0,1,0)$。这表明 $\\{(0,1,0), (1,1,0), (1,1,1), (1,0,1), (1,0,0)\\}$ 都在同一个 SCC 中。\n- 从这个环路，我们可以到达其他状态。从 $(1,0,1)$，我们可以到达 $(0,0,1)$ 和 $(0,0,0)$。\n- 我们必须检查是否可以返回。从 $(0,0,0)$，我们可以到达 $(0,1,0)$，它在环路中。从 $(0,0,1)$，我们可以到达 $(0,0,0)$，并从那里返回到环路。\n- 这证明了所有 $7$ 个可达状态都是相互可达的。它们形成一个单一的大型 SCC。\n\n由于这个 SCC 包含了所有可达状态，没有从中引出的转移。因此，这个 SCC 是一个终端 SCC (TSCC)。异步动力学有一个吸引子，即集合 $\\mathcal{R}_{\\text{async}}$ 本身。\n\n### 第 3 部分：计算比率\n\n根据前面部分，我们有：\n- 在同步更新下可达的不同状态数量：$R_{\\text{sync}} = 5$。\n- 在一般异步更新下可达的不同状态数量：$R_{\\text{async}} = 7$。\n\n所需的比率 $r$ 是：\n$$r = \\frac{R_{\\text{async}}}{R_{\\text{sync}}} = \\frac{7}{5}$$\n这是一个最简精确分数，因为 $5$ 和 $7$ 都是素数。",
            "answer": "$$\\boxed{\\frac{7}{5}}$$"
        },
        {
            "introduction": "对于任何实际规模的生物网络，手动分析其所有可能的动态行为都是不现实的。这项实践挑战你将如图论中的强连通分量（Strongly Connected Components, SCCs）和可达性等理论概念转化为一个可执行的计算机程序。你将编写代码来系统地识别异步更新网络中的所有吸引子及其对应的吸引盆（basins of attraction），这是计算系统生物学家的核心技能之一 。",
            "id": "4321637",
            "problem": "在系统生物医学的背景下，考虑一个布尔网络，其中一个基因调控网络（GRN）被建模为 $n$ 个二元节点，其状态空间为 $\\{0,1\\}^n$。设节点索引标记为 $1,2,\\dots,n$，一个布尔状态表示为 $x=(x_1,x_2,\\dots,x_n)$，其中每个 $x_i \\in \\{0,1\\}$。对于每个节点 $i$，其布尔更新函数为 $f_i:\\{0,1\\}^n \\to \\{0,1\\}$。异步更新语义定义如下：从一个状态 $x$ 出发，对于每个满足 $f_i(x) \\neq x_i$ 的索引 $i$，存在一个到后继状态 $y^{(i)}$ 的有向转移，该后继状态的分量满足 $y^{(i)}_i = f_i(x)$ 且对于所有 $j \\neq i$ 有 $y^{(i)}_j = x_j$。如果对于所有 $i \\in \\{1,\\dots,n\\}$ 都有 $f_i(x) = x_i$，则 $x$ 是一个没有出向转移的不动点。异步更新下的全局动态可以表示为一个包含 $2^n$ 个状态的有限有向图。\n\n我们定义有向状态转移图 $G$，其顶点是 $2^n$ 个二元状态，其边 $x \\to y$ 表示如上所述的单节点异步更新。在异步语义下，吸引子是图 $G$ 的一个终端强连通分量（SCC），即一个非空子集 $A \\subseteq \\{0,1\\}^n$，该子集是强连通的，并且没有指向集合 $A$ 外部状态的出边。吸引子 $A$ 的吸引域在此定义为所有状态的集合，从这些状态出发，存在至少一条有向路径（在异步更新下）到达 $A$ 中的任意一个状态。吸引域大小是该集合的基数。我们将使用从二元状态向量到整数索引 $s \\in \\{0,1,\\dots,2^n-1\\}$ 的映射，该映射由以下公式给出：\n$$\ns(x) \\;=\\; \\sum_{i=1}^{n} x_i \\, 2^{\\,n-i},\n$$\n使得 $x_1$ 是最高有效位，$x_n$ 是最低有效位。这种整数编码定义了状态上的一个全序，我们将用它来根据吸引子包含的最小索引对吸引子进行排序，并按索引递增顺序对每个吸引子内的状态进行排序。\n\n你的任务是编写一个完整的程序，该程序能够：\n- 对每个给定的网络，枚举所有 $2^n$ 个状态，\n- 根据上述定义构建所有异步转移，\n- 计算所有作为终端SCC的吸引子，\n- 确定每个吸引子的大小（SCC中的状态数），\n- 通过计算能通过有向路径到达吸引子中至少一个状态的状态数量来确定每个吸引域的大小，\n- 完全按照所需格式为提供的测试套件输出结果。\n\n从布尔网络、异步更新语义和图论中的强连通分量的基本定义出发，不要假设任何专门的快捷公式。确保你的算法推理与这些定义一致。\n\n测试套件：\n对于每个测试用例 $k$，网络由一个整数 $n_k$ 和节点更新函数列表 $(f_1,\\dots,f_{n_k})$ 指定。测试套件包含三个网络：\n\n- 测试用例1：$n_1 = 3$，其中\n  $f_1(x) = x_2$, $f_2(x) = x_1$, $f_3(x) = x_3$。\n- 测试用例2：$n_2 = 3$，带有一个负反馈环\n  $f_1(x) = \\neg x_2$, $f_2(x) = \\neg x_3$, $f_3(x) = \\neg x_1$,\n  其中 $\\neg$ 表示逻辑非。\n- 测试用例3：$n_3 = 2$，其中\n  $f_1(x) = \\neg x_1$, $f_2(x) = x_2$。\n\n答案规范：\n- 对于每个测试用例，你的程序必须生成一个包含四个元素的列表：[吸引子数量, 作为状态索引列表的吸引子列表, 吸引子大小列表, 吸引域大小列表]。\n- 每个吸引子表示为其状态的整数索引列表，根据 $s(x)$ 按升序排序。\n- 吸引子在总列表中按其包含的最小状态索引的升序排列。\n- 吸引域大小的排序与相应的吸引子对齐。\n- 所有数字必须是整数。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，例如：\n$[ \\text{result\\_tc1} , \\text{result\\_tc2} , \\text{result\\_tc3} ]$,\n打印行中不含任何额外的空白字符。\n\n问题不涉及物理单位，也没有角度或百分比。最终输出是纯粹的组合数据，采用上述定义的整数编码。该问题具有普遍适用性，可以通过构建和分析由异步布尔更新导出的有限有向图，在任何现代编程语言中解决。请遵循定义的语义，并返回逻辑上一致的吸引子和吸引域大小，以确保科学真实性。",
            "solution": "该问题要求对异步布尔网络进行全面分析，包括识别吸引子及其吸引域。解决方案需要一个基于图论的多步算法方法。具有 $n$ 个节点的布尔网络的状态空间是 $\\{0,1\\}^n$，其中包含 $2^n$ 个唯一状态。我们将系统动态建模为一个有向状态转移图 $G=(V, E)$，其中顶点集 $V$ 是所有 $2^n$ 个状态的集合，如果状态 $y$ 可以通过一次异步更新从状态 $x$ 到达，则存在一条有向边 $(x, y) \\in E$。\n\n首先，我们形式化状态表示。每个状态 $x = (x_1, x_2, \\dots, x_n)$ 使用指定的公式映射到一个唯一的整数索引 $s \\in \\{0, 1, \\dots, 2^n-1\\}$：\n$$\ns(x) = \\sum_{i=1}^{n} x_i \\, 2^{n-i}\n$$\n该编码将 $(x_1, \\dots, x_n)$ 视为 $s$ 的二进制表示，其中 $x_1$ 是最高有效位。这使我们可以使用整数索引来表示状态，这对于实现图算法很方便。\n\n算法过程如下：\n\n1.  **状态转移图构建**：我们首先构建图 $G$ 的邻接表表示。对于 $2^n$ 个状态中的每一个（由其整数索引 $s$ 标识），我们首先将 $s$ 转换回其二进制向量形式 $x=(x_1, \\dots, x_n)$。然后，对于每个节点 $i \\in \\{1, \\dots, n\\}$，我们评估相应的更新函数 $f_i(x)$。如果节点的当前状态 $x_i$ 与目标值不同，即 $x_i \\neq f_i(x)$，则可能发生异步转移。此转移导致一个后继状态 $y^{(i)}$，其中只有第 $i$ 个分量被更新：$y^{(i)}_i = f_i(x)$ 且对于所有 $j \\neq i$ 有 $y^{(i)}_j = x_j$。我们将每个这样的后继状态 $y^{(i)}$ 转换为其整数索引，并将其添加到状态 $s$ 的邻接表中。如果一个状态 $x$ 对所有 $i$ 都满足 $f_i(x) = x_i$，则它是一个不动点，没有出向转移。\n\n2.  **强连通分量（SCC）分解**：吸引子被定义为状态转移图 $G$ 的一个终端强连通分量（SCC）。为了找到所有的SCC，我们采用 Tarjan 算法，这是一种基于图的单次深度优先搜索（DFS）遍历的标准高效方法。对于每个顶点 $u$，该算法维护两个值：发现时间 `disc[u]`（即首次访问的时间）和一个 \"low-link\" 值 `low[u]`（即从 $u$ 通过其DFS子树可达的最低发现时间，包括其自身）。一个顶点 $u$ 是一个SCC的根当且仅当 `disc[u] == low[u]`。当找到这样一个根时，算法栈上所有在 $u$之上（并包括$u$）的顶点构成一个单独的SCC。此过程将整个状态集 $V$ 划分为不相交的SCC。\n\n3.  **吸引子（终端SCC）的识别**：将图分解为SCC后，我们必须识别哪些是终端的。一个SCC，例如 $C$，是终端的当且仅当不存在从任何状态 $u \\in C$ 发出并指向状态 $v \\notin C$ 的边。我们遍历每个计算出的SCC。对于SCC内的每个状态，我们检查其在原始图 $G$ 中的后继状态。如果SCC中所有状态的所有后继状态也都包含在同一个SCC内，则它被声明为终端SCC，即一个吸引子。\n\n4.  **吸引域计算**：吸引子 $A$ 的吸引域被定义为所有可以存在至少一条路径到达 $A$ 中任意状态的状态集合。要计算这个集合的大小，我们可以解决图上的一个可达性问题。能够到达 $A$ 的状态集合可以通过考虑反向图 $G_{rev}$ 来最有效地找到，其中 $G$ 中的每条边 $(u,v)$ 都被替换为边 $(v,u)$。然后，在 $G_{rev}$ 上从吸引子 $A$ 中的所有状态同时开始图遍历（如广度优先搜索或深度优先搜索），我们可以发现所有能到达 $A$ 的状态。此次遍历中访问到的所有唯一状态的总数构成了 $A$ 的吸引域，其基数就是吸引域的大小。\n\n5.  **输出格式化**：最后，对每个测试用例的结果进行整理。识别出的吸引子根据它们包含的最小状态索引进行排序。每个吸引子内的状态也按其索引的升序排序。吸引子大小和吸引域大小按照与排序后的吸引子相对应的顺序列出。然后将这些结构化数据格式化为指定的列表格式以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# Increase recursion limit for deep graphs, although not strictly necessary for these small examples.\nsys.setrecursionlimit(20000)\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and print results for all test cases.\n    \"\"\"\n\n    # Helper function to format lists without whitespace, as per output requirements.\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(x) for x in item)}]\"\n        else:\n            return str(item)\n\n    test_cases = [\n        {\n            \"n\": 3,\n            \"functions\": [lambda x: x[1], lambda x: x[0], lambda x: x[2]],\n        },\n        {\n            \"n\": 3,\n            \"functions\": [lambda x: 1 - x[1], lambda x: 1 - x[2], lambda x: 1 - x[0]],\n        },\n        {\n            \"n\": 2,\n            \"functions\": [lambda x: 1 - x[0], lambda x: x[1]],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        functions = case[\"functions\"]\n        result = analyze_network(n, functions)\n        all_results.append(result)\n\n    print(format_list(all_results))\n\ndef analyze_network(n, functions):\n    \"\"\"\n    Analyzes a single Boolean network to find its attractors and their basins.\n\n    Args:\n        n (int): The number of nodes in the network.\n        functions (list of callables): The list of Boolean update functions.\n\n    Returns:\n        list: A list containing [num_attractors, attractors, attractor_sizes, basin_sizes].\n    \"\"\"\n    num_states = 1  n  # Equivalent to 2**n\n\n    # --- 1. Graph Construction ---\n    adj = {i: [] for i in range(num_states)}\n    rev_adj = {i: [] for i in range(num_states)}\n\n    for s in range(num_states):\n        # Convert integer index to binary state tuple\n        state_str = f'{s:0{n}b}'\n        state = tuple(int(c) for c in state_str)\n\n        for i in range(n):\n            target_val = functions[i](state)\n            if state[i] != target_val:\n                next_state_list = list(state)\n                next_state_list[i] = target_val\n                # Convert next state to integer index\n                next_s = int(\"\".join(map(str, next_state_list)), 2)\n                if next_s not in adj[s]:\n                    adj[s].append(next_s)\n                if s not in rev_adj[next_s]:\n                    rev_adj[next_s].append(s)\n    \n    # --- 2. SCC Decomposition (Tarjan's Algorithm) ---\n    disc = [-1] * num_states\n    low = [-1] * num_states\n    on_stack = [False] * num_states\n    stack = []\n    time = 0\n    sccs = []\n\n    def tarjan_dfs(u):\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n        stack.append(u)\n        on_stack[u] = True\n\n        for v in adj[u]:\n            if disc[v] == -1:\n                tarjan_dfs(v)\n                low[u] = min(low[u], low[v])\n            elif on_stack[v]:\n                low[u] = min(low[u], disc[v])\n\n        if low[u] == disc[u]:\n            scc = []\n            while True:\n                node = stack.pop()\n                on_stack[node] = False\n                scc.append(node)\n                if node == u:\n                    break\n            sccs.append(set(scc))\n\n    for i in range(num_states):\n        if disc[i] == -1:\n            tarjan_dfs(i)\n\n    # --- 3. Identify Terminal SCCs (Attractors) ---\n    attractors = []\n    scc_map = {node: scc for scc in sccs for node in scc}\n    for scc in sccs:\n        is_terminal = True\n        for u in scc:\n            for v in adj[u]:\n                if v not in scc:\n                    is_terminal = False\n                    break\n            if not is_terminal:\n                break\n        if is_terminal:\n            attractors.append(sorted(list(scc)))\n\n    # Sort attractors by their minimum state index\n    attractors.sort(key=lambda a: a[0])\n\n    # --- 4. Basin of Attraction Calculation ---\n    basin_sizes = []\n    for attractor in attractors:\n        queue = list(attractor)\n        visited = set(attractor)\n        head = 0\n        while head  len(queue):\n            u = queue[head]\n            head += 1\n            for p in rev_adj.get(u, []):\n                if p not in visited:\n                    visited.add(p)\n                    queue.append(p)\n        basin_sizes.append(len(visited))\n\n    # --- 5. Format Output ---\n    num_attractors = len(attractors)\n    attractor_sizes = [len(a) for a in attractors]\n    \n    return [num_attractors, attractors, attractor_sizes, basin_sizes]\n\nsolve()\n```"
        }
    ]
}