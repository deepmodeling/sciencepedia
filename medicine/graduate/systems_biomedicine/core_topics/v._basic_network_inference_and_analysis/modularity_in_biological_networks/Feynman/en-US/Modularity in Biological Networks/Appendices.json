{
    "hands_on_practices": [
        {
            "introduction": "A key challenge in network biology is to distinguish meaningful large-scale organization from simple local clustering. This exercise provides a hands-on opportunity to contrast network motifs, which represent local structural patterns, with communities derived from a global perspective. By calculating and comparing the modularity of different partitions in a hypothetical protein-protein interaction network, you will gain a deeper intuition for why a region dense with motifs is not necessarily a \"community\" in the formal sense, and how this distinction is critical for correctly interpreting network structure .",
            "id": "4362361",
            "problem": "An undirected protein–protein interaction network representing two pathway compartments with cross-talk is given on $10$ nodes labeled $1$ through $10$. Edges are the unordered pairs\n$\\{(1,2), (2,3), (3,4), (4,5), (6,7), (7,8), (6,8), (8,9), (9,10), (3,6), (3,7), (4,6), (4,7)\\}$.\nConsider the $3$-node cycle motif (triangle) as the motif of interest. Suppose a motif-enrichment analyst proposes the set $S=\\{3,4,6,7\\}$ as a putative module because these nodes participate in many triangles. A community analyst instead proposes the compartmental partition $C_1=\\{1,2,3,4,5\\}$ and $C_2=\\{6,7,8,9,10\\}$, motivated by within-compartment edge density and cross-talk edges between compartments.\n\nUsing foundational definitions for network motifs (triangles are $3$-node cycles) and community quality assessed against a degree-preserving null model (the widely used Newman–Girvan modularity framework), proceed as follows without relying on any shortcut formulas: \n- Enumerate the triangles in the network and verify whether the nodes in $S$ indeed have higher triangle participation than others.\n- For each of the two candidate partitions, quantify the number of edges internal to each community and the sum of degrees in each community.\n- From first principles, evaluate which partition yields higher community quality under a degree-preserving null model and explain whether high motif frequency at $S$ aligns with community boundaries.\n\nWhich statement is most consistent with the results and their implications for inference in systems biomedicine?\n\nA. The motif-enriched partition $\\{S, V\\setminus S\\}$ yields higher community quality than $\\{C_1, C_2\\}$; therefore high triangle frequency is sufficient to delineate community boundaries.\n\nB. The compartmental partition $\\{C_1, C_2\\}$ yields higher community quality than $\\{S, V\\setminus S\\}$; high triangle frequency at $\\{3,4,6,7\\}$ does not define community boundaries, and relying solely on motif counts can misidentify boundary regions as separate modules.\n\nC. Both partitions have identical community quality because they each contain the same total number of internal edges; community quality depends only on internal edge counts and not on degree distributions.\n\nD. Motif enrichment detects functional communities even when community quality under a degree-preserving null model is lower, so modularity is irrelevant for module detection in biological networks.",
            "solution": "The problem statement provides a well-defined network and two alternative partitions. It poses a clear, quantitative question regarding the comparison of these partitions using a standard and specified metric from network science. The givens are complete, consistent, and scientifically sound. We may therefore proceed with a formal analysis.\n\nLet the network be represented by a graph $G=(V, E)$, where the set of vertices is $V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}$ and the set of edges is $E = \\{(1,2), (2,3), (3,4), (4,5), (6,7), (7,8), (6,8), (8,9), (9,10), (3,6), (3,7), (4,6), (4,7)\\}$. The total number of edges is $m = |E| = 13$.\n\nFirst, we calculate the degree $k_i$ for each node $i \\in V$:\n$k_1=1$\n$k_2=2$\n$k_3=4$ (edges to $2,4,6,7$)\n$k_4=4$ (edges to $3,5,6,7$)\n$k_5=1$\n$k_6=4$ (edges to $3,4,7,8$)\n$k_7=4$ (edges to $3,4,6,8$)\n$k_8=3$ (edges to $6,7,9$)\n$k_9=2$\n$k_{10}=1$\nThe sum of degrees is $\\sum_{i \\in V} k_i = 1+2+4+4+1+4+4+3+2+1 = 26$, which correctly equals $2m = 2 \\times 13$.\n\n**1. Triangle Enumeration and Participation**\n\nA triangle is a $3$-node cycle, a set of three nodes $\\{a,b,c\\}$ such that $(a,b), (b,c), (c,a) \\in E$. By inspection of the edge set, we enumerate the triangles:\n- $\\{3,4,6\\}$: edges $(3,4), (3,6), (4,6)$ exist.\n- $\\{3,4,7\\}$: edges $(3,4), (3,7), (4,7)$ exist.\n- $\\{3,6,7\\}$: edges $(3,6), (3,7), (6,7)$ exist.\n- $\\{4,6,7\\}$: edges $(4,6), (4,7), (6,7)$ exist.\n- $\\{6,7,8\\}$: edges $(6,7), (6,8), (7,8)$ exist.\nThere are a total of $5$ triangles in the network.\n\nThe number of triangles each node participates in is:\n- Node $3$: in $\\{3,4,6\\}, \\{3,4,7\\}, \\{3,6,7\\}$. Total: $3$.\n- Node $4$: in $\\{3,4,6\\}, \\{3,4,7\\}, \\{4,6,7\\}$. Total: $3$.\n- Node $6$: in $\\{3,4,6\\}, \\{3,6,7\\}, \\{4,6,7\\}, \\{6,7,8\\}$. Total: $4$.\n- Node $7$: in $\\{3,4,7\\}, \\{3,6,7\\}, \\{4,6,7\\}, \\{6,7,8\\}$. Total: $4$.\n- Node $8$: in $\\{6,7,8\\}$. Total: $1$.\n- All other nodes ($1,2,5,9,10$) have degrees less than or equal to $2$ and their neighbors are not connected, so their triangle participation is $0$.\n\nThe set $S = \\{3,4,6,7\\}$ consists of nodes with triangle participation counts of $3, 3, 4, 4$. All other nodes have participation counts of $1$ or $0$. Thus, the nodes in $S$ indeed have significantly higher triangle participation.\n\n**2. Community Quality Evaluation**\n\nWe evaluate community quality using the Newman-Girvan modularity, $Q$. For a partition of the network into communities $c$, the modularity is defined from first principles as the fraction of edges that fall within the given communities, minus the expected such fraction if edges were rewired at random while preserving the degree of each node.\nThe formula is:\n$$Q = \\sum_{c} \\left[ \\frac{L_c}{m} - \\left( \\frac{K_c}{2m} \\right)^2 \\right]$$\nwhere for each community $c$, $L_c$ is the number of internal edges and $K_c$ is the sum of the degrees of its nodes. Here, $m=13$ and $2m=26$.\n\n**Partition 1: Motif-enriched partition $P_S = \\{S, V\\setminus S\\}$**\n- Community $S = \\{3,4,6,7\\}$.\n- Community $V\\setminus S = \\{1,2,5,8,9,10\\}$.\n\nFor community $S$:\n- Internal edges are $(3,4)$, $(3,6)$, $(3,7)$, $(4,6)$, $(4,7)$, $(6,7)$. Thus, $L_S = 6$.\n- Sum of degrees is $K_S = k_3 + k_4 + k_6 + k_7 = 4+4+4+4 = 16$.\n\nFor community $V\\setminus S$:\n- Internal edges are $(1,2)$, $(8,9)$, $(9,10)$. Thus, $L_{V\\setminus S} = 3$.\n- Sum of degrees is $K_{V\\setminus S} = k_1+k_2+k_5+k_8+k_9+k_{10} = 1+2+1+3+2+1=10$.\n\nThe total number of internal edges is $6+3=9$. The modularity $Q_{P_S}$ is:\n$$Q_{P_S} = \\left[ \\frac{6}{13} - \\left(\\frac{16}{26}\\right)^2 \\right] + \\left[ \\frac{3}{13} - \\left(\\frac{10}{26}\\right)^2 \\right]$$\n$$Q_{P_S} = \\left[ \\frac{6}{13} - \\left(\\frac{8}{13}\\right)^2 \\right] + \\left[ \\frac{3}{13} - \\left(\\frac{5}{13}\\right)^2 \\right]$$\n$$Q_{P_S} = \\left[ \\frac{78}{169} - \\frac{64}{169} \\right] + \\left[ \\frac{39}{169} - \\frac{25}{169} \\right] = \\frac{14}{169} + \\frac{14}{169} = \\frac{28}{169}$$\n$Q_{P_S} \\approx 0.1657$.\n\n**Partition 2: Compartmental partition $P_C = \\{C_1, C_2\\}$**\n- Community $C_1 = \\{1,2,3,4,5\\}$.\n- Community $C_2 = \\{6,7,8,9,10\\}$.\n\nFor community $C_1$:\n- Internal edges are $(1,2)$, $(2,3)$, $(3,4)$, $(4,5)$. Thus, $L_{C_1} = 4$.\n- Sum of degrees is $K_{C_1} = k_1+k_2+k_3+k_4+k_5 = 1+2+4+4+1 = 12$.\n\nFor community $C_2$:\n- Internal edges are $(6,7)$, $(7,8)$, $(6,8)$, $(8,9)$, $(9,10)$. Thus, $L_{C_2} = 5$.\n- Sum of degrees is $K_{C_2} = k_6+k_7+k_8+k_9+k_{10} = 4+4+3+2+1=14$.\n\nThe total number of internal edges is $4+5=9$. The modularity $Q_{P_C}$ is:\n$$Q_{P_C} = \\left[ \\frac{4}{13} - \\left(\\frac{12}{26}\\right)^2 \\right] + \\left[ \\frac{5}{13} - \\left(\\frac{14}{26}\\right)^2 \\right]$$\n$$Q_{P_C} = \\left[ \\frac{4}{13} - \\left(\\frac{6}{13}\\right)^2 \\right] + \\left[ \\frac{5}{13} - \\left(\\frac{7}{13}\\right)^2 \\right]$$\n$$Q_{P_C} = \\left[ \\frac{52}{169} - \\frac{36}{169} \\right] + \\left[ \\frac{65}{169} - \\frac{49}{169} \\right] = \\frac{16}{169} + \\frac{16}{169} = \\frac{32}{169}$$\n$Q_{P_C} \\approx 0.1893$.\n\n**3. Comparison and Implications**\n\nComparing the modularity values, we find $Q_{P_C} = \\frac{32}{169} > Q_{P_S} = \\frac{28}{169}$. The compartmental partition $\\{C_1, C_2\\}$ has a higher community quality score than the motif-enriched partition $\\{S, V\\setminus S\\}$.\n\nThe set $S=\\{3,4,6,7\\}$ is a dense subgraph (specifically, a $K_4$ clique) where nodes have high triangle participation. However, these nodes also form the exclusive communication bridge between the two otherwise separate pathways. The nodes $\\{3,4\\}$ are in pathway $1$ and $\\{6,7\\}$ are in pathway $2$. The partition $\\{S, V\\setminus S\\}$ isolates this dense interface as a community, which results in a lower modularity. The higher modularity of $\\{C_1, C_2\\}$ indicates that the network is better described as two larger communities that have some cross-talk, rather than a dense core module and a sparse periphery. This demonstrates that regions of high motif density do not necessarily constitute communities themselves; they can represent interfaces or boundary regions between communities. Relying solely on local features like motif counts can be misleading for identifying global community structure.\n\n**Evaluation of Options**\n\nA. The motif-enriched partition $\\{S, V\\setminus S\\}$ yields higher community quality than $\\{C_1, C_2\\}$; therefore high triangle frequency is sufficient to delineate community boundaries.\n- The premise is false. Our calculation shows $Q_{P_S} < Q_{P_C}$. The conclusion is also inconsistent with our findings.\n- **Incorrect**.\n\nB. The compartmental partition $\\{C_1, C_2\\}$ yields higher community quality than $\\{S, V\\setminus S\\}$; high triangle frequency at $\\{3,4,6,7\\}$ does not define community boundaries, and relying solely on motif counts can misidentify boundary regions as separate modules.\n- The first clause is true ($Q_{P_C} > Q_{P_S}$). The subsequent claims are the correct interpretation of this result, as explained in our analysis. High motif frequency characterized the interface between the two higher-modularity communities.\n- **Correct**.\n\nC. Both partitions have identical community quality because they each contain the same total number of internal edges; community quality depends only on internal edge counts and not on degree distributions.\n- The premise that community quality is identical is false. The reason provided is also false; the modularity formula explicitly includes a term, $(K_c/2m)^2$, that depends on the sum of degrees $K_c$. While both partitions happen to have the same total number of internal edges ($9$), their modularity scores differ because of the different distributions of degrees within the communities.\n- **Incorrect**.\n\nD. Motif enrichment detects functional communities even when community quality under a degree-preserving null model is lower, so modularity is irrelevant for module detection in biological networks.\n- This statement makes a broad, subjective claim about the general utility of modularity, which is beyond the scope of this specific problem's analysis. The question asks what is consistent with the results derived here. The result is that modularity provides a different, and in this context more intuitive, answer than simple motif counting. To declare modularity \"irrelevant\" based on this is an unsupportable leap of logic.\n- **Incorrect**.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "While modularity maximization is a powerful and widely used method for community detection, it is essential to understand its inherent limitations. This analytical practice delves into the well-known \"resolution limit,\" a scale-dependent artifact where the algorithm may fail to identify communities smaller than a certain size. By deriving the smallest detectable module size for a canonical \"ring-of-cliques\" network, you will see precisely how the resolution of community detection depends on network size and the resolution parameter $\\gamma$, providing a crucial theoretical foundation for critically evaluating modularity-based results .",
            "id": "4362323",
            "problem": "Consider an undirected, unweighted ring-of-cliques network that consists of $r$ identical cliques, each clique containing $s$ nodes, where $s \\geq 3$. Consecutive cliques are connected by a single inter-clique edge, forming a simple cycle over cliques. Let $m$ be the total number of edges in the network. Community detection is performed by maximizing the generalized modularity with resolution parameter $\\gamma$, defined by\n$$\nQ_{\\gamma} \\;=\\; \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} \\;-\\; \\gamma \\,\\frac{k_i k_j}{2m} \\right) \\delta(g_i, g_j),\n$$\nwhere $A_{ij}$ is the adjacency matrix, $k_i$ is the degree of node $i$, $g_i$ is the community assignment of node $i$, and $\\delta(\\cdot,\\cdot)$ is the Kronecker delta.\n\nUsing only this definition and basic combinatorial facts about the ring-of-cliques construction, determine the smallest detectable module size, in terms of the number of nodes per module, denoted $s_{\\min}(m,\\gamma)$, such that a single clique of size $s \\geq s_{\\min}(m,\\gamma)$ is preferred as an individual community (rather than being merged with one of its neighbors) when maximizing $Q_{\\gamma}$. Assume $m$ is large and that the cliques are arranged homogeneously as described above. Express your final answer as a single closed-form symbolic expression in terms of $m$ and $\\gamma$. Do not round; treat $s$ as a real variable for the purpose of expressing $s_{\\min}(m,\\gamma)$.",
            "solution": "The problem asks for the minimum clique size, $s_{\\min}(m, \\gamma)$, for which a single clique in a ring-of-cliques network is detected as a distinct community. This occurs when the modularity $Q_{\\gamma}$ of the partition where each clique is a separate community is greater than the modularity of a partition where two adjacent cliques have been merged. We find this minimum size by determining the stability threshold, which is the point where the change in modularity, $\\Delta Q_{\\gamma}$, from merging two adjacent communities is zero. A single clique is a stable community if merging it with a neighbor results in a decrease in modularity, i.e., $\\Delta Q_{\\gamma} < 0$.\n\nThe change in generalized modularity $Q_{\\gamma}$ upon merging two communities, $C_a$ and $C_b$, is given by:\n$$\n\\Delta Q_{\\gamma} = \\frac{1}{2m} \\left( 2 L_{ab} - \\gamma \\frac{V_a V_b}{m} \\right)\n$$\nwhere $L_{ab}$ is the number of edges between communities $C_a$ and $C_b$, and $V_a = \\sum_{i \\in C_a} k_i$ is the volume of community $C_a$ (the sum of the degrees of its nodes).\n\nFirst, we must characterize the network to find the necessary parameters. The network consists of $r$ identical cliques of size $s$.\nThe communities we consider for merging, $C_a$ and $C_b$, are two adjacent cliques. From the problem statement, consecutive cliques are connected by a single inter-clique edge. Therefore, the number of edges between $C_a$ and $C_b$ is $L_{ab} = 1$.\n\nNext, we calculate the volume of a single clique community, $V_C$. A clique of size $s$ has $\\binom{s}{2}$ internal edges. Each node within an isolated clique has a degree of $s-1$. In the ring-of-cliques structure, each clique is connected to two neighbors via single edges. For any given clique $C$, there are two inter-clique edges connecting to its nodes. We must determine the degrees of the nodes in $C$.\nTwo cases for the attachment of these two edges are possible:\n1.  The two edges attach to two distinct nodes in the clique. In this case, two \"bridge\" nodes have degree $k_{bridge} = (s-1) + 1 = s$. The remaining $s-2$ \"internal\" nodes have degree $k_{internal} = s-1$.\n2.  The two edges attach to the same node in the clique. In this case, one \"bridge\" node has degree $k_{bridge} = (s-1) + 2 = s+1$. The remaining $s-1$ \"internal\" nodes have degree $k_{internal} = s-1$.\n\nLet's calculate the volume $V_C$ for both cases.\nCase 1: $V_C = 2 \\cdot k_{bridge} + (s-2) \\cdot k_{internal} = 2s + (s-2)(s-1) = 2s + s^2 - 3s + 2 = s^2 - s + 2$.\nCase 2: $V_C = 1 \\cdot k_{bridge} + (s-1) \\cdot k_{internal} = (s+1) + (s-1)(s-1) = s+1 + s^2 - 2s + 1 = s^2 - s + 2$.\nIn both scenarios, the volume of a single clique community is identical. Thus, our analysis is robust to this structural detail.\n$V_C = s^2 - s + 2$.\n\nSince all cliques are identical, the network is homogeneous. For any two adjacent cliques $C_a$ and $C_b$, their volumes are equal: $V_a = V_b = V_C = s^2 - s + 2$.\n\nA single clique is a stable community if merging it with a neighbor is not favorable, meaning $\\Delta Q_{\\gamma} < 0$. The threshold for this stability, $s_{\\min}$, is found by setting $\\Delta Q_{\\gamma} = 0$.\nSubstituting the values of $L_{ab}$, $V_a$, and $V_b$ into the $\\Delta Q_{\\gamma}$ equation:\n$$\n\\Delta Q_{\\gamma} = \\frac{1}{2m} \\left( 2(1) - \\gamma \\frac{(s^2 - s + 2)(s^2 - s + 2)}{m} \\right) = 0\n$$\n$$\n2 - \\gamma \\frac{(s^2 - s + 2)^2}{m} = 0\n$$\nWe now solve for $s$ to find the critical size $s_{\\min}$.\n$$\n(s^2 - s + 2)^2 = \\frac{2m}{\\gamma}\n$$\nTaking the positive square root of both sides (since $s^2 - s + 2 = (s - 1/2)^2 + 7/4 > 0$ for any real $s$):\n$$\ns^2 - s + 2 = \\sqrt{\\frac{2m}{\\gamma}}\n$$\nThis is a quadratic equation for $s$. Rearranging it into standard form $as^2+bs+c=0$:\n$$\ns^2 - s + \\left(2 - \\sqrt{\\frac{2m}{\\gamma}}\\right) = 0\n$$\nWe use the quadratic formula to solve for $s$:\n$$\ns = \\frac{-(-1) \\pm \\sqrt{(-1)^2 - 4(1)\\left(2 - \\sqrt{\\frac{2m}{\\gamma}}\\right)}}{2(1)}\n$$\n$$\ns = \\frac{1 \\pm \\sqrt{1 - 8 + 4\\sqrt{\\frac{2m}{\\gamma}}}}{2}\n$$\n$$\ns = \\frac{1 \\pm \\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7}}{2}\n$$\nThe problem specifies that $s \\ge 3$. We must choose the root that is consistent with this condition. Let's examine the two possible solutions.\nThe smaller root is $s_1 = \\frac{1 - \\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7}}{2}$. For this root to be greater than or equal to $3$, we would need $1 - \\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7} \\ge 6$, which implies $\\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7} \\le -5$. This is impossible for a real-valued square root. Therefore, the smaller root is not a valid solution under the given constraints.\n\nThe larger root is $s_2 = \\frac{1 + \\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7}}{2}$. This root can be greater than $3$ for appropriate choices of $m$ and $\\gamma$. This solution represents the threshold size $s_{\\min}$ for which a clique becomes a stable community. For any size $s > s_{\\min}$, the condition $\\Delta Q_{\\gamma} < 0$ will hold, making the separated state preferable.\n\nTherefore, the smallest detectable module size is:\n$$\ns_{\\min}(m, \\gamma) = \\frac{1 + \\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7}}{2}\n$$\nThis expression is in terms of $m$ and $\\gamma$, as required. The assumption that $m$ is large ensures that the term under the square root, $4\\sqrt{\\frac{2m}{\\gamma}} - 7$, is positive.",
            "answer": "$$\n\\boxed{\\frac{1 + \\sqrt{4\\sqrt{\\frac{2m}{\\gamma}} - 7}}{2}}\n$$"
        },
        {
            "introduction": "In biological systems, modularity is often defined by shared function rather than just topological connectivity. This practice shifts the focus to metabolic networks, where functional modules consist of reactions whose fluxes are coupled due to stoichiometric constraints. You will implement a computational workflow using linear programming to identify these functional modules based on flux coupling analysis, providing practical experience with a powerful, constraint-based approach that is central to systems biology and metabolic engineering .",
            "id": "4362294",
            "problem": "You are given the task of implementing a program that, for a set of metabolic network instances, computes flux coupling relationships between reaction pairs using the stoichiometric matrix and mass balance at steady state, and then delineates metabolic modules from the strong coupling relationships. The goal is to derive from first principles how to decide whether a reaction pair is strongly coupled, directionally coupled, or weakly coupled, starting from conservation of mass under steady state and linear bounds on fluxes, and to translate this into a robust algorithm based on linear programming. The final output must aggregate results across the provided test suite in a single line, as specified below.\n\nDefinitions and assumptions:\n- Let $S \\in \\mathbb{R}^{m \\times n}$ denote the stoichiometric matrix of a metabolic network with $m$ internal metabolites and $n$ reactions. Let $v \\in \\mathbb{R}^{n}$ denote the reaction flux vector.\n- Steady state mass balance imposes $S v = 0$.\n- Each reaction $i$ has lower and upper bounds $l_i \\le v_i \\le u_i$, collected into vectors $l \\in \\mathbb{R}^{n}$ and $u \\in \\mathbb{R}^{n}$.\n- The feasible flux set is the polyhedron $\\mathcal{F} = \\{ v \\in \\mathbb{R}^{n} \\mid S v = 0,\\, l \\le v \\le u \\}$.\n- All reactions in the test suite are irreversible with $l_i = 0$, so $v_i \\ge 0$ for all $i$, which is a common scenario in steady-state Flux Balance Analysis. Nevertheless, your algorithm must be mathematically correct for general $l$ and $u$.\n\nFlux status classification:\n- Define a small numerical tolerance $\\varepsilon = 10^{-9}$ to decide positivity. A reaction $i$ is called “blocked” if $\\max\\{ v_i \\mid v \\in \\mathcal{F} \\} < \\varepsilon$.\n- For a pair of non-blocked reactions $(i,j)$, define three coupling types:\n  1. Strong coupling (code $2$): $i$ and $j$ are strongly coupled if there exists a positive scalar $\\phi \\ge \\varepsilon$ such that, when $v_j$ is fixed to $\\phi$, the feasible value of $v_i$ is unique across $\\mathcal{F}$, and symmetrically, when $v_i$ is fixed to $\\phi$, the feasible value of $v_j$ is unique across $\\mathcal{F}$. Uniqueness is to be numerically certified by checking that the minimum and maximum of the target flux under the corresponding equality constraint coincide within a tolerance $\\tau = 10^{-7}$ in absolute value. To ensure feasibility of the equality constraint, choose $\\phi = \\min\\{\\max v_i, \\max v_j\\}$, where $\\max v_k = \\max\\{ v_k \\mid v \\in \\mathcal{F} \\}$.\n  2. Directional coupling (code $1$ for the ordered pair $i \\to j$): $i$ is directionally coupled to $j$ if, for all $v \\in \\mathcal{F}$ with $v_i \\ge \\varepsilon$, it must hold that $v_j \\ge \\varepsilon$. Algorithmically, this is equivalent to checking infeasibility of the constraints $S v = 0$, $l \\le v \\le u$, $v_i \\ge \\varepsilon$, and $v_j \\le 0$. If infeasible, declare $i \\to j$ directionally coupled. If feasible, then $i \\to j$ is not directionally coupled. Do not evaluate directional coupling from a blocked reaction.\n  3. Weak coupling (code $0$ for $i \\to j$): if neither strong coupling nor directional coupling holds for the ordered pair, declare weak coupling. By convention, the diagonal entries are $0$.\n\nMetabolic modules:\n- Define undirected strong-coupling edges between $i$ and $j$ when both $i \\to j$ and $j \\to i$ are strong (which your strong test enforces symmetrically). A metabolic module is a maximal undirected connected component induced by these strong edges on the set of non-blocked reactions. Singletons (non-blocked reactions with no strong edges) count as modules. Blocked reactions are excluded from modules.\n\nFundamental base:\n- Use mass conservation at steady state $S v = 0$ and the definition of the feasible polyhedron $\\mathcal{F}$ under linear bounds as the starting point. All determinations must be reduced to linear programs (or feasibility problems) with linear equality and bound constraints.\n\nTest suite:\nFor each test case, you are given a stoichiometric matrix $S$, lower bounds $l$, and upper bounds $u$. There are no physical units for fluxes in this problem; treat fluxes as dimensionless real numbers.\n\n- Test case $1$ (linear chain, all reactions expected to be strongly coupled):\n  - $S \\in \\mathbb{R}^{3 \\times 4}$:\n    $$\n    S = \\begin{bmatrix}\n    1 & -1 & 0 & 0 \\\\\n    0 & 1 & -1 & 0 \\\\\n    0 & 0 & 1 & -1\n    \\end{bmatrix}\n    $$\n  - $l = [0, 0, 0, 0]$\n  - $u = [10, 100, 100, 100]$\n\n- Test case $2$ (converging supply to an intermediate, generating directional couplings but not strong coupling across the branch):\n  - $S \\in \\mathbb{R}^{3 \\times 5}$:\n    $$\n    S = \\begin{bmatrix}\n    1 & -1 & 0 & 0 & 0 \\\\\n    0 & 1 & -1 & 0 & 1 \\\\\n    0 & 0 & 1 & -1 & 0\n    \\end{bmatrix}\n    $$\n  - $l = [0, 0, 0, 0, 0]$\n  - $u = [10, 100, 100, 100, 7]$\n\n- Test case $3$ (one blocked reaction due to an internal pool with no sink, others strongly coupled):\n  - $S \\in \\mathbb{R}^{3 \\times 4}$:\n    $$\n    S = \\begin{bmatrix}\n    1 & -1 & 0 & 0 \\\\\n    0 & 1 & -1 & 0 \\\\\n    0 & 0 & 0 & 1\n    \\end{bmatrix}\n    $$\n    The third row enforces $v_4 = 0$, thereby blocking reaction $4$.\n  - $l = [0, 0, 0, 0]$\n  - $u = [5, 100, 100, 100]$\n\nProgram requirements:\n- Implement the classification for each test case by solving the required linear programs using only linear constraints derived from $S v = 0$ and bounds $l \\le v \\le u$.\n- Use $\\varepsilon = 10^{-9}$ and $\\tau = 10^{-7}$ as numerical tolerances as defined above.\n- For each test case with $n$ reactions, construct an $n \\times n$ integer matrix $C$ where entry $C_{ij}$ is:\n  - $2$ if reactions $i$ and $j$ are strongly coupled (symmetric and applied to both directions),\n  - $1$ if reaction $i$ is directionally coupled to reaction $j$ but they are not strongly coupled,\n  - $0$ otherwise (including diagonal entries).\n- Compute the metabolic modules as the list of connected components under undirected strong edges among non-blocked reactions. Use zero-based indices for reaction identifiers inside modules. Sort reactions ascending within each module. Sort the list of modules ascending by their smallest index.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case. For each test case, output a two-element list:\n  - The first element is the flattened $C$ matrix in row-major order as a list of integers.\n  - The second element is the list of modules, each module being a list of integers.\nThus the overall output is of the form $[ [C^{(1)}\\_{\\mathrm{flat}}, \\mathrm{modules}^{(1)}], [C^{(2)}\\_{\\mathrm{flat}}, \\mathrm{modules}^{(2)}], [C^{(3)}\\_{\\mathrm{flat}}, \\mathrm{modules}^{(3)}] ]$, printed on a single line with no extra text.\n\nYour implementation must be general and correct for the provided test suite and adhere to the above definitions exactly.",
            "solution": "The problem of identifying flux coupling relationships and metabolic modules in a biological network is a well-posed question within the domain of systems biology and constraint-based modeling. The solution can be derived from the fundamental principle of mass conservation at steady state, subject to thermodynamic and capacity constraints on reaction fluxes.\n\n### Principle-Based Derivation\n\nA metabolic network is described by its stoichiometry, represented by the matrix $S \\in \\mathbb{R}^{m \\times n}$, where $m$ is the number of metabolites and $n$ is the number of reactions. The vector $v \\in \\mathbb{R}^{n}$ contains the fluxes of these reactions.\n\n1.  **Steady-State and Feasible Flux Space**: The core principle is the conservation of mass for internal metabolites. Under the quasi-steady-state assumption ($\\frac{d[\\text{metabolite}]}{dt} = 0$), the production and consumption of each metabolite must balance, leading to the linear system of equations:\n    $$S v = 0$$\n    Furthermore, each reaction flux $v_i$ is constrained by lower and upper bounds, $l_i \\le v_i \\le u_i$, which arise from thermodynamic irreversibility (e.g., $l_i=0$) and enzymatic capacity ($u_i < \\infty$). These constraints define a convex polyhedron in $\\mathbb{R}^n$, known as the feasible flux space:\n    $$\\mathcal{F} = \\{ v \\in \\mathbb{R}^{n} \\mid S v = 0, \\, l \\le v \\le u \\}$$\n    All subsequent analyses operate on this set $\\mathcal{F}$.\n\n2.  **Flux Variability and Blocked Reactions**: To understand the capability of an individual reaction $i$, we can determine its minimum and maximum possible flux values over the entire feasible space. This is a Linear Programming (LP) problem. For example, to find the maximum flux of reaction $i$:\n    $$\n    \\begin{aligned}\n    & \\underset{v}{\\text{maximize}} & & v_i \\\\\n    & \\text{subject to} & & S v = 0 \\\\\n    & & & l \\le v \\le u\n    \\end{aligned}\n    $$\n    A reaction $i$ is defined as \"blocked\" if its flux is forced to be negligible across all feasible states. As per the problem's definition, this is checked by determining if its maximal flux is below a small tolerance $\\varepsilon > 0$. For a generally reversible reaction, one must check if $\\max(|v_i|)$ is negligible, which involves solving for both $\\max(v_i)$ and $\\min(v_i)$. The problem specifies checking if $\\max\\{ v_i \\mid v \\in \\mathcal{F} \\} < \\varepsilon = 10^{-9}$. This is sufficient for the test cases where $l_i=0$.\n\n3.  **Flux Coupling Analysis**: Coupling relationships describe how the activity of one reaction constrains another. These relationships can be systematically uncovered by solving a series of LPs. Let's consider two non-blocked reactions, $i$ and $j$.\n\n    a.  **Strong Coupling**: Reactions $i$ and $j$ are strongly coupled if their fluxes are obligatorily proportional. The problem provides a specific algorithmic test for this: fix the flux of one reaction to a chosen positive value $\\phi$ and check if the flux of the other reaction becomes uniquely determined. The value $\\phi$ is prescribed as $\\phi = \\min\\{\\max v_i, \\max v_j\\}$. The procedure is:\n    \n        -   First, test the implication $j \\to i$: solve for the minimum and maximum of $v_i$ over the restricted feasible set $\\mathcal{F}'_j = \\{ v \\in \\mathcal{F} \\mid v_j = \\phi \\}$. If this set is empty (infeasible) or if $\\max_{\\mathcal{F}'_j}(v_i) - \\min_{\\mathcal{F}'_j}(v_i) \\ge \\tau = 10^{-7}$, the test fails.\n        -   Second, test the implication $i \\to j$: symmetrically, solve for the min/max of $v_j$ over $\\mathcal{F}'_i = \\{ v \\in \\mathcal{F} \\mid v_i = \\phi \\}$. If this is infeasible or the flux range is not within $\\tau$, the test fails.\n        -   If both tests pass, reactions $i$ and $j$ are declared strongly coupled (code $2$).\n\n    b.  **Directional Coupling**: Reaction $i$ is directionally coupled to reaction $j$ ($i \\to j$) if a positive flux through $i$ necessitates a positive flux through $j$. The problem defines this by an equivalent algorithmic check: the system of constraints corresponding to \"a flux vector exists in $\\mathcal{F}$ with $v_i \\ge \\varepsilon$ and $v_j \\le 0$\" must be infeasible. This is a feasibility LP problem:\n        $$\n        \\begin{aligned}\n        & \\text{find} & & v \\\\\n        & \\text{subject to} & & S v = 0 \\\\\n        & & & l \\le v \\le u \\\\\n        & & & v_i \\ge \\varepsilon \\\\\n        & & & v_j \\le 0\n        \\end{aligned}\n        $$\n        If an LP solver finds this system to be infeasible, we conclude that $i$ is directionally coupled to $j$ (code $1$). This check is performed only if the pair is not already strongly coupled.\n\n    c.  **Weak Coupling**: If a pair of reactions is neither strongly nor directionally coupled in a given direction, they are weakly coupled (code $0$). This is the default state.\n\n4.  **Metabolic Modules**: Strongly coupled reactions form tightly co-regulated blocks within a metabolic network, often corresponding to linear pathways or obligatorily co-functional enzyme sets. These can be defined as metabolic modules. The problem defines a module as a maximal connected component in a graph where the vertices are the non-blocked reactions and an edge exists between two vertices if they are strongly coupled. Finding these modules is a standard graph traversal problem (e.g., using Breadth-First Search or Depth-First Search) to identify the connected components. Single non-blocked reactions that are not strongly coupled to any other reaction form singleton modules.\n\n### Algorithmic Implementation\n\nThe overall algorithm proceeds as follows:\n1.  For each of the $n$ reactions, solve an LP to find its maximal flux $\\max v_i$. Identify all blocked reactions ($\\max v_i < \\varepsilon$) and store the list of non-blocked reactions and their maximal fluxes.\n2.  Initialize an $n \\times n$ coupling matrix $C$ with zeros.\n3.  Iterate through all unique pairs $(i, j)$ of non-blocked reactions. For each pair, apply the strong coupling test using four LPs ($\\min/\\max v_i$ with fixed $v_j$, and $\\min/\\max v_j$ with fixed $v_i$). If the tests pass, set $C_{ij} = C_{ji} = 2$.\n4.  Iterate through all ordered pairs $(i, j)$ of reactions. If $i$ is not blocked and $C_{ij}$ is not already $2$, perform the directional coupling feasibility test. If the corresponding LP is infeasible, set $C_{ij} = 1$.\n5.  Construct a graph using the non-blocked reactions as vertices. Add an undirected edge between any two reactions $i$ and $j$ if $C_{ij} = 2$.\n6.  Find the connected components of this graph. Each component is a metabolic module. Sort the reactions within each module and sort the list of modules by their smallest element.\n7.  Format the flattened $C$ matrix and the list of modules as specified for each test case.\nThe `scipy.optimize.linprog` function is used to solve all required linear programming and feasibility problems.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the metabolic network analysis problem for all test cases.\n    \"\"\"\n\n    def list_to_str(data):\n        \"\"\"\n        Recursively converts a Python list to a string with no whitespace.\n        \"\"\"\n        if isinstance(data, list):\n            return f\"[{','.join(map(list_to_str, data))}]\"\n        return str(data)\n\n    class MetabolicNetworkAnalyzer:\n        \"\"\"\n        A class to perform flux coupling and module analysis on a metabolic network.\n        \"\"\"\n        def __init__(self, S, l, u, eps=1e-9, tau=1e-7):\n            self.S = np.array(S, dtype=float)\n            self.l = np.array(l, dtype=float)\n            self.u = np.array(u, dtype=float)\n            self.eps = eps\n            self.tau = tau\n            self.m, self.n = self.S.shape\n            \n            self.b_eq = np.zeros(self.m)\n            self.base_bounds = list(zip(self.l, self.u))\n            \n            self.max_fluxes = np.zeros(self.n)\n            self.non_blocked_reactions = []\n            self.coupling_matrix = np.zeros((self.n, self.n), dtype=int)\n            self.modules = []\n\n        def _solve_lp(self, c, bounds):\n            \"\"\"Helper function to call scipy's linprog.\"\"\"\n            # The 'highs' method is robust and recommended.\n            res = linprog(c, A_eq=self.S, b_eq=self.b_eq, bounds=bounds, method='highs')\n            return res\n\n        def _find_blocked_reactions(self):\n            \"\"\"\n            Identifies blocked reactions by maximizing flux for each reaction.\n            A reaction i is blocked if max(v_i) < eps.\n            \"\"\"\n            non_blocked = []\n            for i in range(self.n):\n                c = np.zeros(self.n)\n                c[i] = -1  # To maximize v_i\n                \n                res = self._solve_lp(c, self.base_bounds)\n                \n                max_v = -res.fun if res.success else 0.0\n                self.max_fluxes[i] = max_v\n                \n                if max_v >= self.eps:\n                    non_blocked.append(i)\n            \n            self.non_blocked_reactions = non_blocked\n\n        def _check_strong_coupling(self, i, j):\n            \"\"\"\n            Checks for strong coupling between reactions i and j.\n            \"\"\"\n            phi = min(self.max_fluxes[i], self.max_fluxes[j])\n            if phi < self.eps:\n                return False\n\n            # Test 1: Fix v_j = phi, check if v_i is unique\n            bounds1 = list(self.base_bounds)\n            bounds1[j] = (phi, phi)\n\n            # Minimize v_i\n            c_min_i = np.zeros(self.n)\n            c_min_i[i] = 1\n            res_min_i = self._solve_lp(c_min_i, bounds1)\n            if not res_min_i.success: return False\n            v_i_min = res_min_i.fun\n\n            # Maximize v_i\n            c_max_i = np.zeros(self.n)\n            c_max_i[i] = -1\n            res_max_i = self._solve_lp(c_max_i, bounds1)\n            if not res_max_i.success: return False\n            v_i_max = -res_max_i.fun\n            \n            if abs(v_i_max - v_i_min) >= self.tau:\n                return False\n\n            # Test 2: Fix v_i = phi, check if v_j is unique\n            bounds2 = list(self.base_bounds)\n            bounds2[i] = (phi, phi)\n            \n            # Minimize v_j\n            c_min_j = np.zeros(self.n)\n            c_min_j[j] = 1\n            res_min_j = self._solve_lp(c_min_j, bounds2)\n            if not res_min_j.success: return False\n            v_j_min = res_min_j.fun\n            \n            # Maximize v_j\n            c_max_j = np.zeros(self.n)\n            c_max_j[j] = -1\n            res_max_j = self._solve_lp(c_max_j, bounds2)\n            if not res_max_j.success: return False\n            v_j_max = -res_max_j.fun\n            \n            if abs(v_j_max - v_j_min) >= self.tau:\n                return False\n\n            return True\n\n        def _check_directional_coupling(self, i, j):\n            \"\"\"\n            Checks for directional coupling i -> j.\n            \"\"\"\n            if i not in self.non_blocked_reactions:\n                return False\n\n            temp_bounds = list(self.base_bounds)\n            \n            # v_i >= eps\n            l_i, u_i = temp_bounds[i]\n            temp_bounds[i] = (max(l_i, self.eps), u_i)\n            \n            # v_j <= 0\n            l_j, u_j = temp_bounds[j]\n            temp_bounds[j] = (l_j, min(u_j, 0.0))\n\n            if temp_bounds[i][0] > temp_bounds[i][1] or temp_bounds[j][0] > temp_bounds[j][1]:\n                return True # Inherently infeasible bounds\n\n            # Feasibility problem: objective is zero vector.\n            c_feasibility = np.zeros(self.n)\n            res = self._solve_lp(c_feasibility, temp_bounds)\n            \n            # Infeasible (status 2) implies directional coupling\n            return res.status == 2\n\n        def _calculate_couplings(self):\n            \"\"\"\n            Calculates the full coupling matrix C.\n            \"\"\"\n            # Strong coupling (symmetric)\n            for idx1, i in enumerate(self.non_blocked_reactions):\n                for j in self.non_blocked_reactions[idx1+1:]:\n                    if self._check_strong_coupling(i, j):\n                        self.coupling_matrix[i, j] = 2\n                        self.coupling_matrix[j, i] = 2\n\n            # Directional coupling\n            for i in range(self.n):\n                for j in range(self.n):\n                    if i == j or self.coupling_matrix[i, j] == 2:\n                        continue\n                    if self._check_directional_coupling(i, j):\n                        self.coupling_matrix[i, j] = 1\n        \n        def _find_modules(self):\n            \"\"\"\n            Finds metabolic modules from strong coupling graph.\n            \"\"\"\n            adj = {r: [] for r in self.non_blocked_reactions}\n            for i in range(self.n):\n                for j in range(i + 1, self.n):\n                    if self.coupling_matrix[i, j] == 2:\n                        adj[i].append(j)\n                        adj[j].append(i)\n\n            visited = set()\n            modules = []\n            for r in self.non_blocked_reactions:\n                if r not in visited:\n                    current_module = []\n                    q = [r]\n                    visited.add(r)\n                    while q:\n                        node = q.pop(0)\n                        current_module.append(node)\n                        for neighbor in adj[node]:\n                            if neighbor not in visited:\n                                visited.add(neighbor)\n                                q.append(neighbor)\n                    modules.append(sorted(current_module))\n            \n            self.modules = sorted(modules, key=lambda m: m[0])\n\n        def run(self):\n            \"\"\"\n            Executes the full analysis pipeline.\n            \"\"\"\n            self._find_blocked_reactions()\n            self._calculate_couplings()\n            self._find_modules()\n\n        def get_result(self):\n            \"\"\"\n            Returns the final formatted result for the test case.\n            \"\"\"\n            c_flat = self.coupling_matrix.flatten().tolist()\n            return [c_flat, self.modules]\n\n    test_cases = [\n        (\n            [[1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n            [0, 0, 0, 0],\n            [10, 100, 100, 100],\n        ),\n        (\n            [[1, -1, 0, 0, 0], [0, 1, -1, 0, 1], [0, 0, 1, -1, 0]],\n            [0, 0, 0, 0, 0],\n            [10, 100, 100, 100, 7],\n        ),\n        (\n            [[1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 0, 1]],\n            [0, 0, 0, 0],\n            [5, 100, 100, 100],\n        )\n    ]\n    \n    all_results = []\n    for S, l, u in test_cases:\n        analyzer = MetabolicNetworkAnalyzer(S, l, u)\n        analyzer.run()\n        all_results.append(analyzer.get_result())\n        \n    print(list_to_str(all_results))\n\nsolve()\n```"
        }
    ]
}