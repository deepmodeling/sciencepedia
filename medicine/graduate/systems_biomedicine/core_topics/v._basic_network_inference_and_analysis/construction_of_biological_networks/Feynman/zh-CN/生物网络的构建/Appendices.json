{
    "hands_on_practices": [
        {
            "introduction": "生物学知识来源于众多可靠性各异的实验。要构建一个有意义的网络模型，我们必须以一种原则性的方式整合这些多样化的证据。本练习将指导您如何结合来自不同数据源的独立概率来为相互作用赋予权重，并学习如何利用邻接矩阵来表示一个包含有向和无向边的复杂网络。",
            "id": "4330440",
            "problem": "您正在使用多种异构证据来源，为四种蛋白质 $P_1$、$P_2$、$P_3$ 和 $P_4$ 构建一个概率性的有向蛋白质相互作用网络。在系统生物医学中，边的置信度被解释为所报告的相互作用为真的概率，而当生物学机制意味着因果关系（例如，激酶到底物或转录因子到靶基因）时，则编码方向性。提供了以下证据代码及其基础可靠性，每种可靠性在单独考虑时被解释为独立的真实概率：酵母双杂交 (Y2H): $0.35$，免疫共沉淀 (Co-IP): $0.65$，亲和纯化质谱 (AP-MS): $0.55$，染色质免疫沉淀测序 (ChIP-seq): $0.75$，整理的文献 (CUR): $0.90$，磷酸化基序 (PM): $0.30$。观察到的相互作用如下：\n- $P_1$ 和 $P_2$ 由 Y2H 和 AP-MS 报告，没有明确的方向性。\n- $P_1$ 在 CUR 的支持下调控 $P_3$，方向为 $P_1 \\rightarrow P_3$。\n- $P_2$ 和 $P_3$ 由 Co-IP 报告，没有明确的方向性。\n- $P_3$ 在 ChIP-seq 的支持下调控 $P_4$，方向为 $P_3 \\rightarrow P_4$。\n- $P_4$ 和 $P_1$ 由 AP-MS 和 Co-IP 报告，没有明确的方向性。\n- $P_2$ 在 PM 的支持下磷酸化 $P_4$，方向为 $P_2 \\rightarrow P_4$。\n请设计一种表示方法，该方法基于适用于系统生物医学网络构建的基本概率和图论定义，采用一种有原则的方法来编码边的置信度和（在可用时）方向性。然后，为节点顺序 $(P_1, P_2, P_3, P_4)$ 构建有向、边加权的邻接矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$，并清楚地说明如何表示无向边。最后，计算标量\n$$S = \\sum_{i=1}^{4}\\sum_{j=1}^{4} A_{ij}$$\n并以无单位的纯数字形式提供其数值。不需要四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于概率网络构建的原理，问题陈述清晰且信息充分，可得唯一解，并且是客观陈述的。\n\n任务是为由4个蛋白质 $P_1, P_2, P_3, P_4$ 构成的网络构建一个有向、边加权的邻接矩阵 $A$，然后计算其所有元素的总和。构建过程需要一种有原则的方法来合并来自多个独立来源的证据，并表示有向和无向的相互作用。\n\n首先，我们定义网络构建的原则。\n$1$. **合并独立的概率性证据**：问题指出，每个证据来源都提供了一个真实相互作用的独立概率。假设一个相互作用由 $n$ 个独立的证据来源支持，其各自的概率（可靠性）为 $p_1, p_2, \\dots, p_n$。至少有一个证据来源是正确的概率，等于 $1$ 减去所有证据来源都不正确的概率。来源 $i$ 不正确的概率是 $(1-p_i)$。由于这些来源是独立的，它们全部不正确的概率是它们各自不正确概率的乘积。因此，该相互作用的组合置信度分数 $c$ 为：\n$$c = 1 - \\prod_{i=1}^{n} (1 - p_i)$$\n问题给出了每种证据代码的基础概率：$p_{Y2H} = 0.35$, $p_{CoIP} = 0.65$, $p_{APMS} = 0.55$, $p_{ChIP} = 0.75$, $p_{CUR} = 0.90$, and $p_{PM} = 0.30$。\n\n$2$. **在邻接矩阵中表示边**：问题要求为有序节点 $(P_1, P_2, P_3, P_4)$ 构建一个有向邻接矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$。条目 $A_{ij}$ 将表示有向相互作用 $P_i \\rightarrow P_j$ 的置信度分数。\n- 对于由组合置信度为 $c$ 的证据支持的**有向相互作用** $P_i \\rightarrow P_j$，我们设置 $A_{ij} = c$。在没有证据支持反向相互作用 $P_j \\rightarrow P_i$ 的情况下，我们设置 $A_{ji} = 0$。\n- 对于 $P_i$ 和 $P_j$ 之间组合置信度为 $c$ 的**无向相互作用**，证据证实了物理关联但没有因果关系。在有向矩阵中，一种标准的、有原则的图论表示方法是将置信度分数分配给两个方向的边，表示该连接是对称存在的。因此，我们设置 $A_{ij} = A_{ji} = c$。\n- 如果 $P_i$ 和 $P_j$ 之间没有相互作用的证据，则 $A_{ij} = A_{ji} = 0$。\n- 没有提到自环，所以我们假设对所有 $i$ 都有 $A_{ii} = 0$。\n\n我们现在为每个报告的相互作用计算置信度分数，并填充矩阵 $A$。\n\n- **$P_1$ 和 $P_2$ 之间的相互作用**：由 Y2H ($p=0.35$) 和 AP-MS ($p=0.55$) 支持。没有明确的方向性。\n组合置信度为 $c_{12} = 1 - (1 - 0.35)(1 - 0.55) = 1 - (0.65)(0.45) = 1 - 0.2925 = 0.7075$。\n由于相互作用是无向的，我们设置 $A_{12} = 0.7075$ 和 $A_{21} = 0.7075$。\n\n- **$P_1$ 和 $P_3$ 之间的相互作用**：由 CUR ($p=0.90$) 支持，方向为 $P_1 \\rightarrow P_3$。\n置信度为 $c_{13} = 0.90$。\n由于相互作用是有向的，我们设置 $A_{13} = 0.90$。没有反向相互作用的证据，所以 $A_{31} = 0$。\n\n- **$P_2$ 和 $P_3$ 之间的相互作用**：由 Co-IP ($p=0.65$) 支持。没有明确的方向性。\n置信度为 $c_{23} = 0.65$。\n由于相互作用是无向的，我们设置 $A_{23} = 0.65$ 和 $A_{32} = 0.65$。\n\n- **$P_3$ 和 $P_4$ 之间的相互作用**：由 ChIP-seq ($p=0.75$) 支持，方向为 $P_3 \\rightarrow P_4$。\n置信度为 $c_{34} = 0.75$。\n由于相互作用是有向的，我们设置 $A_{34} = 0.75$。没有反向相互作用的证据，所以 $A_{43} = 0$。\n\n- **$P_4$ 和 $P_1$ 之间的相互作用**：由 AP-MS ($p=0.55$) 和 Co-IP ($p=0.65$) 支持。没有明确的方向性。\n组合置信度为 $c_{41} = 1 - (1 - 0.55)(1 - 0.65) = 1 - (0.45)(0.35) = 1 - 0.1575 = 0.8425$。\n由于相互作用是无向的，我们设置 $A_{41} = 0.8425$ 和 $A_{14} = 0.8425$。\n\n- **$P_2$ 和 $P_4$ 之间的相互作用**：由 PM ($p=0.30$) 支持，方向为 $P_2 \\rightarrow P_4$。\n置信度为 $c_{24} = 0.30$。\n由于相互作用是有向的，我们设置 $A_{24} = 0.30$。没有反向相互作用的证据，所以 $A_{42} = 0$。\n\n结合这些结果，有向邻接矩阵 $A$ 为：\n$$A = \\begin{pmatrix} A_{11}  A_{12}  A_{13}  A_{14} \\\\ A_{21}  A_{22}  A_{23}  A_{24} \\\\ A_{31}  A_{32}  A_{33}  A_{34} \\\\ A_{41}  A_{42}  A_{43}  A_{44} \\end{pmatrix} = \\begin{pmatrix} 0  0.7075  0.90  0.8425 \\\\ 0.7075  0  0.65  0.30 \\\\ 0  0.65  0  0.75 \\\\ 0.8425  0  0  0 \\end{pmatrix}$$\n\n最后，我们计算标量 $S$，即 $A$ 中所有元素的总和。\n$$S = \\sum_{i=1}^{4}\\sum_{j=1}^{4} A_{ij}$$\n我们将上面计算出的所有非零项相加：\n$S = A_{12} + A_{13} + A_{14} + A_{21} + A_{23} + A_{24} + A_{32} + A_{34} + A_{41}$\n$S = 0.7075 + 0.90 + 0.8425 + 0.7075 + 0.65 + 0.30 + 0.65 + 0.75 + 0.8425$\n分组各项：\n$S = (0.7075 + 0.7075) + (0.8425 + 0.8425) + (0.65 + 0.65) + 0.90 + 0.30 + 0.75$\n$S = (2 \\times 0.7075) + (2 \\times 0.8425) + (2 \\times 0.65) + 0.90 + 0.30 + 0.75$\n$S = 1.415 + 1.685 + 1.30 + 0.90 + 0.30 + 0.75$\n$S = 3.100 + 1.30 + 0.90 + 0.30 + 0.75$\n$S = 4.40 + 0.90 + 0.30 + 0.75$\n$S = 5.30 + 0.30 + 0.75$\n$S = 5.60 + 0.75$\n$S = 6.35$\n\n标量 $S$ 的数值为 $6.35$。",
            "answer": "$$\\boxed{6.35}$$"
        },
        {
            "introduction": "网络中的节点并非同等重要。构建网络后，一个主要目标是识别那些具有中心地位或影响力的节点，它们往往是关键的调控蛋白或潜在的药物靶点。本练习将引导您计算并比较三种经典的中心性度量——度中心性、介数中心性和特征向量中心性，从而学习如何从网络拓扑结构中识别出核心功能组分。",
            "id": "4330471",
            "problem": "您的任务是使用图论中心性度量来构建和分析有向生物信号网络。考虑一个在节点集 $V=\\{0,1,\\ldots,n-1\\}$ 上的有向、无权图，由邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示，其中 $A_{ij}=1$ 表示从节点 $i$ 到节点 $j$ 的一个有向相互作用。在系统生物医学中，这类图通常是通过将经过整理的蛋白质-蛋白质相互作用（PPI）数据和激酶-底物关系整合到一个统一的信号网络中来构建的。对于每个网络实例，都提供了一个节点集合 $H \\subseteq V$，这些节点有文献支持作为“已知枢纽”。您的任务是计算中心性度量，并量化中心节点（根据每种度量排名）与已知枢纽的对应程度。所有计算必须按照下面定义的纯数学术语进行。\n\n基本基础、定义和要求：\n- 有向图 $G=(V,E)$ 由 $V=\\{0,\\ldots,n-1\\}$ 和 $E=\\{(i,j)\\mid A_{ij}=1\\}$ 定义。有向路径是遵循边方向性的节点序列。图论距离 $d(s,t)$ 是从节点 $s$ 到节点 $t$ 的最短有向路径的长度（边的数量），如果存在路径的话；否则，距离被认为是无限的。\n- 度中心性：对于每个节点 $v \\in V$，将其度定义为其入度和出度之和，即考虑方向性的关联边数。您必须计算此度数以进行排名。排名不需要归一化。\n- 介数中心性：对于每个节点 $v \\in V$，其分数定义为在所有满足 $s \\neq v$、$t \\neq v$ 和 $s \\neq t$ 的有序节点对 $(s,t)$ 之间，经过 $v$ 的最短有向路径所占的比例。使用无权度量下的最短有向路径。使用有向图的标准归一化方法，即除以 $(n-1)(n-2)$。\n- 特征向量中心性：定义一个非负向量 $x \\in \\mathbb{R}_{\\ge 0}^n$，其条目量化了节点的影响力，使得节点 $i$ 的中心性与指向它的节点的中心性之和成正比。具体来说，$x$ 是 $A^{\\top}$ 的主特征向量（对应于最大特征值），通过从一个严格正向量开始并每次迭代进行归一化的幂迭代法计算。当连续迭代之间的差的 $\\ell_2$-范数低于一个容差或达到最大迭代次数时终止。如果在任何迭代中 $A^{\\top}x$ 变为零向量，则返回零向量作为 $x$。\n- 排名和打破平局：对于每个中心性度量 $C \\in \\{\\text{degree}, \\text{betweenness}, \\text{eigenvector}\\}$，按中心性得分降序对节点进行排名。如果两个节点的得分完全相等，则通过优先选择较小的节点索引来打破平局。\n- 枢纽重叠量化：给定一个包含 $|H|=k$ 个已知枢纽的集合 $H$，将 top-$k$ 集合 $T_C$ 定义为根据上述排名规则，按度量 $C$ 计算出的中心性最高的 $k$ 个节点。使用 Jaccard 指数 $J(T_C,H) = \\frac{|T_C \\cap H|}{|T_C \\cup H|}$ 来量化对应关系。该值为 $[0,1]$ 范围内的实数，并且必须以浮点值的形式报告。\n- 最终输出必须是四舍五入到三位小数的浮点数。\n\n测试套件：\n为以下三个有向网络中的每一个计算三个 Jaccard 指数 $[J_{\\text{deg}}, J_{\\text{bet}}, J_{\\text{eig}}]$。对于每个网络，使用给定的邻接矩阵 $A$ 和已知枢纽集 $H$。显示的所有条目都在 $\\{0,1\\}$ 中，节点索引是从 $0$ 开始的。\n\n- 测试用例 1：\n    - 大小 $n=7$。\n    - 邻接矩阵 $A_1$（行 $i$，列 $j$ 给出 $A_{ij}$）：\n      $$\n      \\begin{bmatrix}\n      0  1  1  0  0  0  0 \\\\\n      1  0  1  1  1  0  0 \\\\\n      0  0  0  1  1  1  0 \\\\\n      0  0  0  0  1  1  0 \\\\\n      0  0  0  0  0  1  1 \\\\\n      0  0  0  0  0  0  1 \\\\\n      0  0  0  0  0  0  0\n      \\end{bmatrix}\n      $$\n    - 已知枢纽 $H_1=\\{1,4\\}$。\n\n- 测试用例 2：\n    - 大小 $n=8$。\n    - 邻接矩阵 $A_2$：\n      $$\n      \\begin{bmatrix}\n      0  1  1  0  0  0  0  0 \\\\\n      0  0  1  0  0  0  0  0 \\\\\n      0  1  0  1  0  0  0  0 \\\\\n      0  0  0  0  0  0  0  0 \\\\\n      0  0  0  0  0  1  0  1 \\\\\n      0  0  0  0  0  0  1  1 \\\\\n      0  0  0  0  1  0  0  0 \\\\\n      0  0  0  0  0  0  0  0\n      \\end{bmatrix}\n      $$\n    - 已知枢纽 $H_2=\\{2,5\\}$。\n\n- 测试用例 3：\n    - 大小 $n=9$。\n    - 邻接矩阵 $A_3$：\n      $$\n      \\begin{bmatrix}\n      0  1  1  0  0  0  0  0  0 \\\\\n      0  0  0  1  0  0  0  0  0 \\\\\n      0  0  0  1  0  0  0  0  0 \\\\\n      0  0  0  0  1  1  0  0  0 \\\\\n      0  0  0  0  0  0  1  0  0 \\\\\n      0  0  0  0  0  0  1  0  0 \\\\\n      0  0  0  0  0  0  0  1  1 \\\\\n      0  0  0  0  0  0  0  0  0 \\\\\n      0  0  0  0  0  0  0  0  0\n      \\end{bmatrix}\n      $$\n    - 已知枢纽 $H_3=\\{3,6\\}$。\n\n编程要求：\n- 根据上述定义实现三种中心性度量的计算，使用有向图的标准最短路径概念和通过对 $A^{\\top}$ 进行幂迭代的主特征向量计算。\n- 对于每个测试用例，令 $k=|H|$，并根据指定的打破平局规则计算每种中心性下的 top-$k$ 节点 $T_{\\text{deg}}$、$T_{\\text{bet}}$、$T_{\\text{eig}}$。计算 $T_C$ 和 $H$ 之间的三个 Jaccard 指数。\n- 您的程序必须生成单行输出，其中包含结果，格式为一个包含三个列表（每个测试用例一个）的逗号分隔列表，每个内部列表包含三个四舍五入到三位小数的浮点 Jaccard 指数，并用方括号括起来。例如，输出将类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$，其中每个 $a_i,b_i,c_i$ 都是四舍五入到三位小数的浮点数。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于网络理论及其在系统生物学中的应用，在数学上是适定的，具有明确定义的术语和目标，并为所需计算提供了一套完整且一致的数据。该问题构成了在实现和解释标准图中心性度量方面的一个严谨练习。因此，我们可以着手提供完整的解决方案。\n\n解决方案涉及为每个给定的网络计算三种不同的中心性度量，然后与一组提供的已知枢纽节点进行定量比较。下面详细介绍每个步骤，这些步骤基于图论和数值线性代数的既定原理。\n\n问题的核心是一个包含 $n$ 个节点的有向图 $G=(V,E)$，由邻接矩阵 $A$ 表示。条目 $A_{ij}=1$ 表示从节点 $i$到节点 $j$ 的一条有向边。对于每次分析，我们都给定一个包含 $k = |H|$ 个已知枢纽节点的集合 $H$。我们的目标是，对于每种中心性度量 $C$，计算出 top-$k$ 节点 $T_C$，然后计算 Jaccard 指数 $J(T_C, H)$。\n\n### 1. 度中心性\n\n**原理**：度中心性是衡量节点重要性的局部度量，通过其连接数来量化。对于有向图，这是一个节点的入度和出度之和。节点 $v$ 的入度是指向它的边的数量，而出度是从它发出的边的数量。\n\n**计算**：给定邻接矩阵 $A$，节点 $j$ 的入度是第 $j$ 列的和，即 $\\sum_{i=0}^{n-1} A_{ij}$。节点 $i$ 的出度是第 $i$ 行的和，即 $\\sum_{j=0}^{n-1} A_{ij}$。因此，节点 $v$ 的总度数由下式给出：\n$$\n\\text{deg}(v) = \\sum_{i=0}^{n-1} A_{iv} + \\sum_{j=0}^{n-1} A_{vj}\n$$\n为图中的每个节点计算这些值。\n\n### 2. 介数中心性\n\n**原理**：介数中心性是一种全局度量，它量化了节点位于其他节点之间最短路径上的程度。具有高介数中心性的节点在网络中充当通信或流动的关键“桥梁”或“瓶颈”。对于一个节点 $v$，其介数中心性 $C_B(v)$ 定义为在所有其他节点对 $(s, t)$ 之间，经过 $v$ 的最短路径所占比例的总和。\n\n**计算**：有向图的公式为：\n$$\nC_B(v) = \\sum_{s,t \\in V, s \\neq v \\neq t, s \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}\n$$\n其中 $\\sigma_{st}$ 是从 $s$ 到 $t$ 的最短有向路径的总数，而 $\\sigma_{st}(v)$ 是其中包含 $v$ 作为中间节点的路径数量。使用 Brandes' 算法可以高效地进行计算。对于每个作为源节点的 $s \\in V$，该算法主要分两个阶段进行：\n1.  **最短路径计数**：从 $s$ 开始的广度优先搜索（BFS）用于计算到所有其他节点的最短路径距离 $d(s, \\cdot)$ 和最短路径的数量 $\\sigma_{s\\cdot}$。\n2.  **依赖累积**：按与 $s$ 距离递减的顺序处理节点。对于每个节点 $w$，计算一个依赖分数 $\\delta_s(w)$，表示距离 $s$ 更远的节点通过 $w$ 的路径所产生的依赖总和。节点 $v$ 对其后继节点 $w$ 的依赖是从 $s$ 到 $w$ 的最短路径中经过 $v$ 的路径所占的比例。每个节点 $v$ 的中心性得分会加上它从源节点 $s$ 获得的总依赖。\n\n在遍历所有可能的源节点 $s$ 之后，将所得分数除以 $(n-1)(n-2)$ 进行归一化，这是不包括端点的不同节点有序对的总数。\n\n### 3. 特征向量中心性\n\n**原理**：特征向量中心性是一种递归的影响力度量。一个节点的中心性不仅取决于其连接数（如度中心性），还取决于连接到它的节点的中心性。如果一个节点被其他重要节点指向，那么它就是重要的。\n\n**计算**：这个原理在数学上被形式化为一个特征向量问题。设 $x_i$ 为节点 $i$ 的中心性。定义规定 $x_i$ 与指向节点 $i$ 的节点 $j$ 的中心性之和成正比。这可以写成：\n$$\nx_i = \\frac{1}{\\lambda} \\sum_{j: (j,i) \\in E} x_j = \\frac{1}{\\lambda} \\sum_{j=0}^{n-1} A_{ji} x_j\n$$\n以矩阵形式表示，即为 $\\lambda x = A^\\top x$。因此，中心性向量 $x$ 是邻接矩阵转置 $A^\\top$ 的一个特征向量。根据 Perron-Frobenius 定理及其对非负矩阵的扩展，存在一个最大的非负特征值 $\\lambda_{\\text{max}}$，其对应一个非负特征向量。这就是我们寻求的主特征向量。\n\n它使用幂迭代法进行数值计算。从一个严格为正的向量 $x^{(0)}$（例如，全为1的向量）开始，我们迭代计算：\n$$\nx^{(k+1)} = \\frac{A^\\top x^{(k)}}{\\|A^\\top x^{(k)}\\|_2}\n$$\n重复此过程，直到连续向量之间的差值 $\\|x^{(k+1)} - x^{(k)}\\|_2$ 小于指定的容差，或达到最大迭代次数。得到的向量 $x$ 包含特征向量中心性得分。对于有向无环图（DAG），如测试用例所示，$A^\\top$ 的最大特征值为 $0$，幂迭代会正确收敛到相应的特征向量。在这种情况下，中心性在网络中“流动”，并在更下游的节点处累积。\n\n### 4. 排名和枢纽重叠量化\n\n**排名**：对于三种中心性度量中的每一种，所有 $n$ 个节点都按其中心性得分降序排列。根据问题规范，得分的任何平局都通过优先选择较小索引的节点来解决。\n\n**Jaccard 指数**：为量化排名靠前的节点集与已知枢纽集之间的重叠度，我们使用 Jaccard 指数。给定一个包含 $k$ 个已知枢纽的集合 $H$，我们根据中心性 C 确定 top-$k$ 节点的集合 $T_C$。Jaccard 指数则为：\n$$\nJ(T_C, H) = \\frac{|T_C \\cap H|}{|T_C \\cup H|} = \\frac{|T_C \\cap H|}{|T_C| + |H| - |T_C \\cap H|}\n$$\n该值范围从 $0$（无重叠）到 $1$（完全重叠），提供了一个标准化的对应度量。最终结果呈现为四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (\n            [\n                [0, 1, 1, 0, 0, 0, 0],\n                [1, 0, 1, 1, 1, 0, 0],\n                [0, 0, 0, 1, 1, 1, 0],\n                [0, 0, 0, 0, 1, 1, 0],\n                [0, 0, 0, 0, 0, 1, 1],\n                [0, 0, 0, 0, 0, 0, 1],\n                [0, 0, 0, 0, 0, 0, 0]\n            ],\n            {1, 4}\n        ),\n        (\n            [\n                [0, 1, 1, 0, 0, 0, 0, 0],\n                [0, 0, 1, 0, 0, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 0, 0, 0, 1, 1],\n                [0, 0, 0, 0, 1, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0]\n            ],\n            {2, 5}\n        ),\n        (\n            [\n                [0, 1, 1, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 1, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 1, 1],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0]\n            ],\n            {3, 6}\n        )\n    ]\n\n    final_results = []\n    for A_list, H_set in test_cases:\n        A = np.array(A_list, dtype=np.int32)\n        n = A.shape[0]\n        k = len(H_set)\n\n        # Calculate centralities\n        deg_cen = calculate_degree_centrality(A, n)\n        bet_cen = calculate_betweenness_centrality(A, n)\n        eig_cen = calculate_eigenvector_centrality(A, n)\n\n        # Get rankings\n        deg_rank = rank_nodes(deg_cen)\n        bet_rank = rank_nodes(bet_cen)\n        eig_rank = rank_nodes(eig_cen)\n\n        # Get top-k sets\n        T_deg = set(deg_rank[:k])\n        T_bet = set(bet_rank[:k])\n        T_eig = set(eig_rank[:k])\n\n        # Calculate Jaccard indices\n        j_deg = jaccard_index(T_deg, H_set)\n        j_bet = jaccard_index(T_bet, H_set)\n        j_eig = jaccard_index(T_eig, H_set)\n\n        final_results.append([j_deg, j_bet, j_eig])\n\n    # Format output as specified\n    outer_list_str = []\n    for res_list in final_results:\n        inner_list_str = \",\".join([f\"{x:.3f}\" for x in res_list])\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    print(f\"[{','.join(outer_list_str)}]\")\n\ndef calculate_degree_centrality(A, n):\n    \"\"\"Computes degree centrality (in-degree + out-degree) for each node.\"\"\"\n    in_degree = np.sum(A, axis=0)\n    out_degree = np.sum(A, axis=1)\n    return in_degree + out_degree\n\ndef calculate_betweenness_centrality(A, n):\n    \"\"\"Computes betweenness centrality using Brandes' algorithm for directed graphs.\"\"\"\n    betweenness = np.zeros(n, dtype=np.float64)\n    nodes = list(range(n))\n    \n    for s in nodes:\n        # Single-source shortest path using BFS\n        S = []  # Stack of nodes in order of non-increasing distance from s\n        P = [[] for _ in range(n)]  # List of predecessors on shortest paths from s\n        sigma = np.zeros(n, dtype=np.float64)\n        sigma[s] = 1.0\n        d = np.full(n, -1, dtype=np.int32)\n        d[s] = 0\n        \n        Q = deque([s])\n        \n        while Q:\n            v = Q.popleft()\n            S.append(v)\n            \n            # Find neighbors of v\n            neighbors = np.where(A[v, :] == 1)[0]\n            for w in neighbors:\n                # Path discovery\n                if d[w]  0:\n                    Q.append(w)\n                    d[w] = d[v] + 1\n                \n                # Path counting\n                if d[w] == d[v] + 1:\n                    sigma[w] += sigma[v]\n                    P[w].append(v)\n                    \n        # Dependency accumulation\n        delta = np.zeros(n, dtype=np.float64)\n        while S:\n            w = S.pop()\n            for v in P[w]:\n                if sigma[w] != 0:\n                    delta[v] += (sigma[v] / sigma[w]) * (1.0 + delta[w])\n            if w != s:\n                betweenness[w] += delta[w]\n\n    # Normalization\n    if n > 2:\n        norm = (n - 1) * (n - 2)\n        betweenness /= norm\n    \n    return betweenness\n\ndef calculate_eigenvector_centrality(A, n, tol=1e-9, max_iters=1000):\n    \"\"\"Computes eigenvector centrality using power iteration on A.T.\"\"\"\n    At = A.T.astype(np.float64)\n    x = np.ones(n, dtype=np.float64)\n    \n    for _ in range(max_iters):\n        x_prev = x\n        x = At @ x\n        \n        norm_x = np.linalg.norm(x)\n        if norm_x == 0:\n            return np.zeros(n, dtype=np.float64)\n            \n        x = x / norm_x\n        \n        if np.linalg.norm(x - x_prev)  tol:\n            break\n            \n    return x\n\ndef rank_nodes(centrality_scores):\n    \"\"\"Ranks nodes by centrality, breaking ties with smaller node index.\"\"\"\n    nodes = list(range(len(centrality_scores)))\n    # Pair scores with node indices\n    scored_nodes = list(zip(centrality_scores, nodes))\n    \n    # Sort by score descending (-score), then by node index ascending\n    scored_nodes.sort(key=lambda item: (-item[0], item[1]))\n    \n    # Return just the ranked node indices\n    return [node for score, node in scored_nodes]\n\ndef jaccard_index(set1, set2):\n    \"\"\"Computes the Jaccard index between two sets.\"\"\"\n    intersection_size = float(len(set1.intersection(set2)))\n    union_size = float(len(set1.union(set2)))\n    \n    if union_size == 0:\n        # This case is not expected in this problem as k > 0\n        return 1.0\n    \n    return intersection_size / union_size\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "静态的网络图谱展示了潜在的相互作用，但无法解释系统如何响应刺激并随时间演变。要理解细胞的决策过程，例如在生存与凋亡之间做出选择，我们需要对网络动态进行建模。本练习将介绍布尔网络，一个用于模拟信号通路逻辑的强大框架，您将通过它来探索网络如何从其结构和规则中涌现出稳定的细胞表型。",
            "id": "5002323",
            "problem": "您的任务是构建并分析一个同步布尔网络模型，该模型在转化医学背景下代表一个简化的生存-凋亡信号通路。该通路包括受体激活、下游激酶信号传导、转录调控，以及一个可响应转录因子活性而切换状态的反馈调节器。该模型将药物抑制、旁路激活和应激信号作为钳位输入进行整合。您的程序必须在指定的输入条件下枚举网络的所有吸引子，并总结吸引子的属性。\n\n使用的基本定义：\n- 布尔网络是一个离散时间动力学系统，其状态向量为 $x(t) \\in \\{0,1\\}^n$，并根据 $x(t+1) = f(x(t), u)$ 同步更新，其中 $u$ 表示在所有时间 $t$ 内保持恒定的钳位输入变量。\n- 吸引子是动力学系统达到的一个循环集合，可以是不动点或极限环。在一个有限、确定性的同步布尔网络中，由于状态空间的有限性，每个轨迹最终都会进入一个吸引子。\n\n网络规格：\n- 钳位输入：$L_1$ (配体1)、$L_2$ (配体2)、$D$ (受体阻断药物)、$S$ (应激信号)、$ALT$ (替代旁路激活)、$I$ (激酶抑制剂药物)。每个输入取值于 $\\{0,1\\}$ 并且随时间保持不变。\n- 需要同步更新的动态节点：\n  - $R$: 受体激活\n  - $A$: 衔接蛋白\n  - $K$: 激酶活性\n  - $TF$: 转录因子 (TF)\n  - $F$: 反馈调节器\n  - $Apop$: 凋亡效应子\n  - $Prolif$: 增殖效应子\n- 同步更新的逻辑更新规则 ($t \\mapsto t+1$)：\n  - $R(t+1) = (L_1 \\lor L_2) \\land \\neg D$\n  - $A(t+1) = R(t)$\n  - $K(t+1) = (A(t) \\lor ALT) \\land \\neg I \\land \\neg F(t)$\n  - $TF(t+1) = K(t) \\lor \\left(ALT \\land \\neg S\\right)$\n  - $F(t+1) = TF(t) \\oplus F(t)$，其中 $\\oplus$ 表示异或，定义为若 $a \\neq b$ 则 $a \\oplus b = 1$，否则为 $0$\n  - $Apop(t+1) = S \\land \\neg TF(t)$\n  - $Prolif(t+1) = TF(t) \\land \\neg S$\n- 所有逻辑运算都是在 $\\{0,1\\}$ 上的逐点运算，其中 $\\lor$ 是逻辑或，$\\land$ 是逻辑与，$\\neg$ 是逻辑非，$\\oplus$ 是异或。在每次模拟中，输入 $L_1, L_2, D, S, ALT, I$ 在所有时间 $t$ 内保持固定。\n\n状态表示：\n- 将动态状态向量表示为有序元组 $(R, A, K, TF, F, Apop, Prolif) \\in \\{0,1\\}^7$。\n\n吸引子分析要求：\n- 对于一组给定的钳位输入，从所有 $2^7$ 个可能的初始动态状态开始枚举轨迹。对每个轨迹，迭代应用同步更新，直到遇到一个先前访问过的状态，此时该循环的状态集合构成一个吸引子（如果集合大小为 $1$，则为不动点，否则为极限环）。\n- 通过比较构成每个吸引子的状态集，对来自不同初始条件的吸引子进行去重。如果两个吸引子由相同的动态状态集组成，则无论其相位或遍历顺序如何，都视为同一个吸引子。\n\n测试套件：\n- 使用以下输入参数集来运行该模型：\n  1. $(L_1,L_2,D,S,ALT,I) = (1,0,0,0,0,0)$\n  2. $(L_1,L_2,D,S,ALT,I) = (1,1,1,1,0,1)$\n  3. $(L_1,L_2,D,S,ALT,I) = (0,0,1,0,1,1)$\n  4. $(L_1,L_2,D,S,ALT,I) = (0,0,0,0,0,0)$\n- 这些案例包括一个有活性配体且无抑制的通用情况、一个高抑制和应激情况、一个预期会产生振荡反馈的旁路激活情况，以及一个所有输入都关闭的边界情况。\n\n每个测试用例的所需输出：\n- 对于每个输入参数集，计算并输出以下三个量：\n  1. 整数 $n$，表示不同吸引子的数量。\n  2. 整数 $\\ell$，等于所有不同吸引子的长度之和（每个不动点贡献长度 $1$，每个极限环贡献其周期长度）。\n  3. 布尔值 $b$，指示是否存在任何吸引子，其至少包含一个细胞凋亡处于激活状态的状态，即是否存在某个吸引子，其某个状态满足 $Apop = 1$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含测试套件的聚合结果，格式为方括号括起来的逗号分隔列表。该列表必须按 $[n_1,\\ell_1,b_1,n_2,\\ell_2,b_2,n_3,\\ell_3,b_3,n_4,\\ell_4,b_4]$ 的顺序排列，其中下标按上述给定的测试用例顺序进行索引。不应打印任何其他文本。",
            "solution": "该问题提出了一个计算系统生物学领域中明确定义的任务：分析一个同步布尔网络模型的吸引子。该模型代表了一个简化的信号转导通路，这是生物学中研究诸如生存与凋亡等细胞决策过程的常见范式。该问题具有科学依据，数学上精确，且算法上是可处理的。\n\n该系统的核心是一个定义在有限状态空间上的离散时间动力学系统。网络在任何时间`$t$`的状态由一个`$7$`维二元向量`$x(t) \\in \\{0,1\\}^7$`给出，其中每个分量对应于一个特定生物实体的活性水平（开/关，`$1$/$0$`）。状态向量被指定为有序元组`$x(t) = (R(t), A(t), K(t), TF(t), F(t), Apop(t), Prolif(t))$`。可能的状态总数为`$2^7 = 128$`。\n\n系统的演化由一组确定性的同步更新规则控制，这可以表示为一个函数`$f$`，它将当前状态`$x(t)$`和一组钳位输入`$u$`映射到下一个状态`$x(t+1)$`。输入`$u = (L_1, L_2, D, S, ALT, I)$`代表外部条件或药物干预，并在给定的模拟过程中保持恒定。\n\n每个节点`$x_i$`（例如，`$x_1=R$`、`$x_2=A$`等）的逻辑更新函数如下：\n- `$x_1(t+1) = (L_1 \\lor L_2) \\land \\neg D$`。受体`$R$`被配体`$L_1$`或`$L_2$`激活，除非被药物`$D$`阻断。注意，其在`$t+1$`时刻的状态完全由静态输入决定，而不取决于`$t$`时刻的动态状态。\n- `$x_2(t+1) = x_1(t)$`。衔接蛋白`$A$`仅跟随前一时间步的受体状态。\n- `$x_3(t+1) = (x_2(t) \\lor ALT) \\land \\neg I \\land \\neg x_5(t)$`。激酶`$K$`由衔接蛋白`$A$`或旁路通路`$ALT$`激活，但其活性可被抑制剂`$I$`或反馈调节器`$F$`抑制。\n- `$x_4(t+1) = x_3(t) \\lor (ALT \\land \\neg S)$`。转录因子`$TF$`由激酶`$K$`激活，或在没有应激信号`$S$`的情况下由旁路通路`$ALT$`激活。\n- `$x_5(t+1) = x_4(t) \\oplus x_5(t)$`。反馈调节器`$F$`充当一个触发开关。如果转录因子`$TF$`在前一步是激活的（`$x_4(t)=1$`），它就翻转其状态；否则（`$x_4(t)=0$`）则保持其状态。这引入了记忆和振荡动力学的可能性。\n- `$x_6(t+1) = S \\land \\neg x_4(t)$`。凋亡效应子`$Apop$`仅在应激信号`$S$`存在且促生存转录因子`$TF$`未激活时才被激活。\n- `$x_7(t+1) = x_4(t) \\land \\neg S$`。增殖效应子`$Prolif$`在没有应激信号`$S$`的情况下由转录因子`$TF$`激活。\n\n由于状态空间是有限的且动力学是确定性的，任何从初始状态`$x(0)$`开始的轨迹最终都必然重复一个状态，此时它便进入了一个吸引子。吸引子是状态空间的一个在动力学作用下封闭的子集；它可以是一个不动点（长度为`$1$`的循环）或一个极限环（长度为`$k > 1$`的循环）。所有导致特定吸引子的状态集合被称为其吸引盆。\n\n为给定的输入配置`$u$`识别和表征所有吸引子的算法流程如下：\n1.  **状态空间枚举**：我们必须从所有可能的初始条件开始探索动力学，以保证找到所有吸引子。我们将遍历系统的所有`$128$`个状态，这些状态由从`$0$`到`$127$`的整数来数值表示。\n2.  **轨迹模拟**：对于每个尚未属于先前探索过的轨迹的初始状态`$x_{init}$`，我们逐步模拟网络的演化：`$x_0 = x_{init}$`，`$x_1 = f(x_0, u)$`，`$x_2 = f(x_1, u)$`，...。我们在当前轨迹中维护一个已访问状态的历史记录。\n3.  **吸引子识别**：当生成一个在其历史记录中已出现过的状态时，给定轨迹的模拟终止。这个重复的状态标志着进入了一个吸引子。吸引子本身由从重复状态首次出现到计算出的轨迹末尾的所有状态组成。\n4.  **去重与存储**：为了只计算唯一的吸引子，我们存储已识别吸引子的状态集。使用一种规范表示，例如状态元组的`frozenset`。这允许在一个能自动处理去重的主`set`中进行高效存储。在任何已找到的轨迹中的所有状态都标记为“已访问”，以避免冗余模拟。\n5.  **度量计算**：一旦所有`$128$`个初始状态都已处理完毕（即，已分配到某个吸引子的吸引盆中），我们就可以从唯一吸引子集合中计算所需的度量：\n    -   `$n$\"`：不同吸引子的数量，即唯一吸引子集合的大小。\n    -   `$\\ell$\"`：所有不同吸引子长度的总和。通过将每个唯一吸引子中的状态数相加来计算。\n    -   `\"$b$\"`：一个布尔值，指示任何吸引子内的任何状态是否具有激活的`$Apop$`节点（`$x_6=1$`）。这通过遍历所有已找到的吸引子的所有状态来确定。\n\n对四个指定的输入参数集中的每一个都执行此综合分析。然后将结果聚合并格式化为所需的单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a synchronous Boolean network model of a signaling pathway.\n    For given input conditions, it finds all attractors (fixed points and limit cycles)\n    and computes statistics about them.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # (L1, L2, D, S, ALT, I)\n    test_cases = [\n        (1, 0, 0, 0, 0, 0),  # Case 1: Ligand-activated, no inhibition\n        (1, 1, 1, 1, 0, 1),  # Case 2: High-inhibition and stress\n        (0, 0, 1, 0, 1, 1),  # Case 3: Bypass-activated\n        (0, 0, 0, 0, 0, 0),  # Case 4: All inputs off\n    ]\n\n    final_results = []\n\n    for inputs in test_cases:\n        L1, L2, D, S, ALT, I = inputs\n\n        memoized_updates = {}\n\n        def update_function(state_tuple):\n            \"\"\"\n            Computes the next state of the Boolean network given the current state.\n            The state is a tuple (R, A, K, TF, F, Apop, Prolif).\n            \"\"\"\n            if state_tuple in memoized_updates:\n                return memoized_updates[state_tuple]\n\n            R_curr, A_curr, K_curr, TF_curr, F_curr, _, _ = state_tuple\n\n            # Logical update rules\n            R_next = (L1 or L2) and not D\n            A_next = R_curr\n            K_next = (A_curr or ALT) and not I and not F_curr\n            TF_next = K_curr or (ALT and not S)\n            # XOR logic: a != b is equivalent to a ^ b for 0/1 integers\n            F_next = TF_curr != F_curr\n            Apop_next = S and not TF_curr\n            Prolif_next = TF_curr and not S\n            \n            # Convert booleans to integers (0 or 1) and form the next state tuple\n            next_state = (\n                int(R_next), int(A_next), int(K_next), int(TF_next),\n                int(F_next), int(Apop_next), int(Prolif_next)\n            )\n            \n            memoized_updates[state_tuple] = next_state\n            return next_state\n\n        num_nodes = 7\n        num_states = 2**num_nodes\n        \n        # A set to keep track of states that are already part of a found trajectory\n        processed_states = set()\n        # A set to store unique attractors (as frozensets of state tuples)\n        unique_attractors = set()\n\n        # Iterate through all possible 2^7 = 128 initial states\n        for i in range(num_states):\n            # Generate the state tuple from its integer representation\n            initial_state = tuple(int((i >> (num_nodes - 1 - j))  1) for j in range(num_nodes))\n\n            if initial_state in processed_states:\n                continue\n\n            # Simulate trajectory starting from this un-processed state\n            trajectory = []\n            state_to_index_map = {}\n            current_state = initial_state\n\n            while current_state not in state_to_index_map:\n                state_to_index_map[current_state] = len(trajectory)\n                trajectory.append(current_state)\n                current_state = update_function(current_state)\n\n            # An attractor is found when a state is repeated\n            cycle_start_index = state_to_index_map[current_state]\n            attractor_states = trajectory[cycle_start_index:]\n            \n            # Add the canonical form of the attractor (a frozenset) to the set of unique attractors\n            unique_attractors.add(frozenset(attractor_states))\n            \n            # Mark all states in the found trajectory (transient path + attractor) as processed\n            processed_states.update(trajectory)\n\n        # Analyze the collected unique attractors for the current test case\n        # 1. Number of distinct attractors\n        n = len(unique_attractors)\n        \n        # 2. Sum of the lengths of all distinct attractors\n        ell = sum(len(att) for att in unique_attractors)\n        \n        # 3. Boolean indicating if apoptosis is ever active in any attractor\n        apoptosis_is_active = False\n        APOP_NODE_INDEX = 5  # (R, A, K, TF, F, Apop, Prolif) -> index 5\n        for attractor in unique_attractors:\n            if any(state[APOP_NODE_INDEX] == 1 for state in attractor):\n                apoptosis_is_active = True\n                break\n        \n        # Convert the boolean to an integer (0 or 1) for the final output\n        b = int(apoptosis_is_active)\n        \n        final_results.extend([n, ell, b])\n\n    # Print the final result in the exact required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}