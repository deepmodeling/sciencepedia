{
    "hands_on_practices": [
        {
            "introduction": "共表达网络分析的基础在于超越简单的成对相关性，转向更稳健的连接性度量。拓扑重叠矩阵（Topological Overlap Measure, TOM）正是一种这样的度量，它通过整合节点的共享邻域信息来评估连接强度。这项练习  将通过一个微型网络，引导您逐步完成TOM的计算，让您在实践中具体理解直接邻接关系和共享邻域连接是如何共同构成这一强大度量的，为后续的功能模块识别奠定基础。",
            "id": "2854762",
            "problem": "在系统遗传学中，基因共表达网络是通过将基因间的成对相关性转换为加权邻接关系，然后通过拓扑重叠度量（Topological Overlap Measure, TOM）来量化节点邻近度而构建的。考虑三个基因 $G_{1}$、$G_{2}$ 和 $G_{3}$，其成对皮尔逊相关性的对称矩阵由 $r_{12} = 0.8$，$r_{13} = 0.3$ 和 $r_{23} = -0.4$ 给出，且对于 $i \\in \\{1,2,3\\}$，$r_{ii} = 1$。使用软阈值幂 $\\beta = 6$ 的无符号加权基因共表达网络分析（WGCNA）约定来构建加权邻接关系，然后计算 $G_{1}$ 和 $G_{2}$ 之间的加权拓扑重叠度量（TOM）。假设标准的 WGCNA 约定，即自邻接满足 $a_{ii} = 0$。\n\n执行以下操作：\n- 根据给定的成对相关性，计算所有非对角邻接项 $a_{ij}$。\n- 使用加权基因共表达网络分析（WGCNA）中使用的 TOM 标准加权定义，计算 $G_{1}$ 和 $G_{2}$ 之间的 TOM。\n\n最终答案仅报告 $G_{1}$ 和 $G_{2}$ 之间的 TOM 值，四舍五入至四位有效数字。无需单位。",
            "solution": "问题陈述具有科学依据，提法明确，并为得出唯一解提供了所有必要信息。这是加权基因共表达网络分析（WGCNA）方法的一个标准应用。我们将进行计算。\n\n第一步是根据给定的皮尔逊相关矩阵 $R = [r_{ij}]$ 构建加权邻接矩阵 $A = [a_{ij}]$。对于无符号网络，基因 $i$ 和 $j$ 之间的邻接性 $a_{ij}$ 是使用软阈值幂 $\\beta$ 计算的。公式如下：\n$$a_{ij} = |r_{ij}|^{\\beta}$$\n题目给出的软阈值幂为 $\\beta = 6$。给定的非对角皮尔逊相关性为 $r_{12} = 0.8$，$r_{13} = 0.3$ 和 $r_{23} = -0.4$。邻接矩阵是对称的（$a_{ij} = a_{ji}$），且题目规定对角线元素为零（$a_{ii} = 0$）。我们计算所需的非对角邻接项：\n$$a_{12} = |r_{12}|^{\\beta} = |0.8|^{6} = (0.8)^{6} = 0.262144$$\n$$a_{13} = |r_{13}|^{\\beta} = |0.3|^{6} = (0.3)^{6} = 0.000729$$\n$$a_{23} = |r_{23}|^{\\beta} = |-0.4|^{6} = (0.4)^{6} = 0.004096$$\n\n第二步是计算基因 $G_1$ 和 $G_2$ 之间的拓扑重叠度量（TOM），记为 $\\omega_{12}$。加权 TOM 的标准公式是：\n$$\\omega_{ij} = \\frac{l_{ij} + a_{ij}}{\\min(k_i, k_j) + 1 - a_{ij}}$$\n此处，$k_i$ 是基因 $i$ 的总网络连通性（或节点度），$l_{ij}$ 表示基因 $i$ 和 $j$ 之间的共享连通性。这些项的定义如下：\n$$k_i = \\sum_{u \\neq i} a_{iu}$$\n$$l_{ij} = \\sum_{u \\neq i, j} a_{iu} a_{uj}$$\n我们必须为对 $(i, j) = (1, 2)$ 计算这些量。\n\n首先，我们计算连通性 $k_1$ 和 $k_2$：\n$$k_1 = \\sum_{u \\neq 1} a_{1u} = a_{12} + a_{13} = 0.262144 + 0.000729 = 0.262873$$\n$$k_2 = \\sum_{u \\neq 2} a_{2u} = a_{21} + a_{23} = a_{12} + a_{23} = 0.262144 + 0.004096 = 0.26624$$\n\n接下来，我们计算共享连通性项 $l_{12}$。求和是对所有非 1 或 2 的节点 $u$ 进行的。在这个三基因系统中，唯一这样的节点是 $u=3$。\n$$l_{12} = \\sum_{u \\neq 1, 2} a_{1u} a_{u2} = a_{13} a_{32} = a_{13} a_{23}$$\n$$l_{12} = (0.000729) \\times (0.004096) = 0.000002985984 = 2.985984 \\times 10^{-6}$$\n\n现在我们有了计算 $\\omega_{12}$ 所需的所有部分。分子是：\n$$l_{12} + a_{12} = 2.985984 \\times 10^{-6} + 0.262144 = 0.262146985984$$\n分母需要 $\\min(k_1, k_2)$：\n$$\\min(k_1, k_2) = \\min(0.262873, 0.26624) = 0.262873$$\n所以，分母是：\n$$\\min(k_1, k_2) + 1 - a_{12} = 0.262873 + 1 - 0.262144 = 1.000729$$\n\n最后，我们计算 TOM 值 $\\omega_{12}$：\n$$\\omega_{12} = \\frac{0.262146985984}{1.000729} \\approx 0.26196232$$\n题目要求答案四舍五入到四位有效数字。\n$$\\omega_{12} \\approx 0.2620$$\n这个值表示基因 $G_1$ 和 $G_2$ 之间的拓扑重叠，它基于它们在网络中的直接连接以及与其他基因的共享连接来量化它们的相似性。",
            "answer": "$$\\boxed{0.2620}$$"
        },
        {
            "introduction": "构建加权基因共表达网络的关键一步，是将相关性矩阵转化为邻接矩阵，而这一过程由软阈值功效参数 $\\beta$ 控制。选择一个合适的 $\\beta$ 值至关重要，因为它将决定整个网络的拓扑结构。这项练习  将指导您完成选择 $\\beta$ 值的标准流程，即在实现近似无标度拓扑和维持足够平均连接度这两个目标之间取得平衡。这个实践模拟了真实世界中的分析任务，教会您如何在网络构建中为参数选择提供合理的依据。",
            "id": "4328704",
            "problem": "您的任务是设计并实现一个有原则的选择程序，用于在从基因表达数据构建加权共表达网络时，选择软阈值幂参数$\\beta$，并使其与系统生物医学的目标保持一致。该网络是使用绝对皮尔逊相关系数$|r_{ij}|$通过$a_{ij} = |r_{ij}|^{\\beta}$变换来构建的，以定义一个加权邻接矩阵，其中$a_{ii} = 0$且$i \\neq j$索引不同的基因。目标是选择一个能在近似无标度行为和足够的平均连接度这两个目标之间取得平衡的$\\beta$。\n\n使用的基本定义和出发点：\n- 基因$i$和基因$j$之间的皮尔逊相关性是为跨越$m$个样本的表达向量$\\mathbf{x}_i \\in \\mathbb{R}^m$和$\\mathbf{x}_j \\in \\mathbb{R}^m$定义的，公式如下：\n$$\nr_{ij} = \\frac{\\sum_{s=1}^{m} (x_{i,s} - \\bar{x}_i)(x_{j,s} - \\bar{x}_j)}{\\sqrt{\\sum_{s=1}^{m} (x_{i,s} - \\bar{x}_i)^2} \\sqrt{\\sum_{s=1}^{m} (x_{j,s} - \\bar{x}_j)^2}},\n$$\n其中$\\bar{x}_i$是$\\mathbf{x}_i$的样本均值。\n- 加权邻接矩阵定义为：\n$$\na_{ij}(\\beta) = \n\\begin{cases}\n|r_{ij}|^{\\beta}, & i \\neq j, \\\\\n0, & i = j.\n\\end{cases}\n$$\n- 节点$i$的加权连接度（度）为：\n$$\nk_i(\\beta) = \\sum_{j \\neq i} a_{ij}(\\beta).\n$$\n- 平均连接度为：\n$$\n\\bar{k}(\\beta) = \\frac{1}{n} \\sum_{i=1}^{n} k_i(\\beta),\n$$\n其中$n$是基因数量。\n- 近似无标度行为通过经验分布$p(k)$与幂律$p(k) \\propto k^{-\\gamma}$的线性拟合来评估，具体通过对$\\log p(k)$与$\\log k$进行线性回归得到的决定系数$R^2(\\beta)$来操作。为近似$p(k)$，使用 Sturges' bin count（斯特奇斯分组计数）$B = \\lceil \\log_2(n) + 1 \\rceil$对$\\{k_i(\\beta)\\}_{i=1}^{n}$进行直方图分析，并取其组中点$\\{m_b\\}_{b=1}^{B}$。为保证稳定性，排除计数为零的组，并添加一个小的常数$\\delta$以避免对零取对数，即计算$y_b = \\log(p_b + \\delta)$和$x_b = \\log(m_b + \\delta)$用于回归。线性回归是普通最小二乘法，决定系数为：\n$$\nR^2(\\beta) = 1 - \\frac{\\sum_{b} (y_b - \\hat{y}_b)^2}{\\sum_{b} (y_b - \\bar{y})^2},\n$$\n其中$\\hat{y}_b$是拟合值，$\\bar{y}$是$\\{y_b\\}$的均值。如果非空组少于$2$个或$\\{y_b\\}$的方差为零，则设$R^2(\\beta) = 0$。\n\n按如下方式设计选择程序：\n1. 对于给定集合中的每个候选$\\beta$，计算如上定义的$R^2(\\beta)$和平均连接度$\\bar{k}(\\beta)$。\n2. 通过其理论最大值$n - 1$对平均连接度进行归一化，得到：\n$$\nc(\\beta) = \\frac{\\bar{k}(\\beta)}{n - 1},\n$$\n其值在$[0, 1]$区间内。\n3. 定义一个使用权重$\\alpha \\in [0, 1]$平衡两个目标的标量目标函数：\n$$\nO(\\beta) = \\alpha \\, R^2(\\beta) + (1 - \\alpha) \\, c(\\beta).\n$$\n4. 选择使$O(\\beta)$最大化的$\\beta^\\star$。如果在数值公差范围内出现平局，则优先选择最小的$\\beta$。\n5. 报告三元组$[\\beta^\\star, R^2(\\beta^\\star), \\bar{k}(\\beta^\\star)]$，其中第二和第三个条目以小数形式表示（无百分号），并四舍五入到四位小数。\n\n实现此程序并将其应用于以下测试套件。在所有情况下，取对数时设置$\\delta = 10^{-10}$。不涉及物理单位。不出现角度。所有结果必须是小数或整数，不带百分号。\n\n测试套件：\n- 情况$A$（理想路径，模块化结构）：\n    - 基因数$n = 50$，样本数$m = 60$。\n    - 构建$2$个潜模块因子$\\mathbf{L}_1, \\mathbf{L}_2 \\in \\mathbb{R}^m$，其条目独立地从标准正态分布中抽取。\n    - 将基因$1$到$20$分配给模块$1$，基因$21$到$35$分配给模块$2$，基因$36$到$50$为非模块化基因。\n    - 对于模块$j \\in \\{1, 2\\}$中的基因，生成表达式为$\\mathbf{x}_i = 0.9 \\, \\mathbf{L}_j + \\boldsymbol{\\epsilon}_i$，其中独立噪声$\\boldsymbol{\\epsilon}_i$的条目从均值为$0$、标准差为$0.5$的正态分布中抽取。\n    - 对于非模块化基因，使用$\\mathbf{x}_i = \\boldsymbol{\\epsilon}_i$，其条目从均值为$0$、标准差为$1$的正态分布中抽取。\n    - 跨样本计算$r_{ij}$，然后计算$a_{ij}(\\beta)$。\n    - 候选幂：$\\beta \\in \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}$。\n    - 权重：$\\alpha = 0.8$。\n    - 随机种子：在此情况下使用固定的种子$42$以确保可复现性。\n\n- 情况$B$（边界情况，具有均匀相关性的近乎完全网络）：\n    - 基因数$n = 30$。\n    - 定义$r_{ij} = 0.9$（当$i \\neq j$时）和$r_{ii} = 1$。\n    - 候选幂：$\\beta \\in \\{1, 2, 4, 8\\}$。\n    - 权重：$\\alpha = 0.5$。\n\n- 情况$C$（边缘情况，弱共表达）：\n    - 基因数$n = 40$，样本数$m = 50$。\n    - 为每个$\\mathbf{x}_i$生成条目，这些条目独立地从标准正态分布中抽取（基因间相互独立）。\n    - 跨样本计算$r_{ij}$，然后计算$a_{ij}(\\beta)$。\n    - 候选幂：$\\beta \\in \\{1, 2, 3, 4, 5\\}$。\n    - 权重：$\\alpha = 0.7$。\n    - 随机种子：在此情况下使用固定的种子$123$以确保可复现性。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个$[\\beta^\\star, R^2(\\beta^\\star), \\bar{k}(\\beta^\\star)]$形式的列表。例如，格式必须是$[[b_1,r_1,k_1],[b_2,r_2,k_2],[b_3,r_3,k_3]]$。所有数值条目必须是小数或整数，不带百分号，其中$R^2$和$\\bar{k}$四舍五入到四位小数。",
            "solution": "任务是设计并实现一个程序，用于选择在构建加权基因共表达网络时使用的最佳软阈值幂参数$\\beta$。该选择必须平衡两个相互竞争的目标：实现近似无标度的网络拓扑结构和维持足够水平的平均连接度。这是系统生物医学中一个常见且根本性的问题，特别是在加权基因共表达网络分析（WGCNA）等方法中。\n\n该程序的核心原则在于选择$\\beta$时固有的权衡。网络的邻接矩阵通过幂函数$a_{ij} = |r_{ij}|^{\\beta}$（其中 $i \\neq j$）对基因表达谱之间的绝对皮尔逊相关值$|r_{ij}|$进行变换来定义。较高的$\\beta$值会放大高相关性和低相关性之间的对比，有效滤除弱连接并强调强连接。这可以推动网络的度分布$p(k)$趋向于幂律分布$p(k) \\propto k^{-\\gamma}$，这是无标度拓扑的一个特征。无标度网络被认为是稳健的，并拥有关键的枢纽节点，这对于识别重要基因是一个理想的特性。然而，过高的$\\beta$值也可能导致网络非常稀疏，整体连接度低，可能会丢弃包含在中等相关性中的有价值的生物信息。\n\n我们的程序通过一个正式的目标函数系统地评估一组候选的$\\beta$值，该函数封装了这种权衡。对于每个测试用例，设计的算法按以下步骤进行。\n\n首先，我们建立基础相关结构。对于需要生成数据的情况（情况 A 和 C），我们根据指定的统计模型和随机种子，合成一个大小为$n \\times m$（$n$个基因，$m$个样本）的表达矩阵$\\mathbf{X}$。对于情况 B，相关矩阵$\\mathbf{R}$是直接定义的。对于情况 A 和 C，皮尔逊相关矩阵$\\mathbf{R}$从$\\mathbf{X}$计算得出，其中每个条目$r_{ij}$衡量基因$i$和基因$j$表达之间的线性关系。\n\n其次，对于所提供集合中的每个候选幂$\\beta$，我们执行以下计算：\n1.  **构建邻接矩阵**：计算加权邻接矩阵$\\mathbf{A}(\\beta)$。其元素由$a_{ij}(\\beta) = |r_{ij}|^{\\beta}$（当 $i \\neq j$ 时）给出，对角线元素$a_{ii}(\\beta)$设置为$0$以排除自环。\n\n2.  **计算节点连接度**：通过对每个基因$i$的所有连接权重求和来计算其连接度（或度）$k_i(\\beta)$：$k_i(\\beta) = \\sum_{j \\neq i} a_{ij}(\\beta)$。\n\n3.  **评估无标度拓扑**：我们量化网络连接度分布近似幂律的程度。这通过计算线性回归的决定系数$R^2(\\beta)$来实现。\n    - 将连接度集合$\\{k_i(\\beta)\\}_{i=1}^{n}$分组到一个直方图中。组数$B$由斯特奇斯公式确定，$B = \\lceil \\log_2(n) + 1 \\rceil$。\n    - 幂律分布$p(k) \\propto k^{-\\gamma}$的核心思想是其对数与变量的对数呈线性关系：$\\log p(k) = -\\gamma \\log k + C$。我们检验这种关系。\n    - 对于直方图的每个非空组$b$，我们确定其组中点$m_b$和其频数$p_b$。然后，我们对变换后的坐标$y_b = \\log(p_b + \\delta)$与$x_b = \\log(m_b + \\delta)$进行普通最小二乘线性回归，其中$\\delta=10^{-10}$是一个小的常数，以防止对零取对数时出现数值问题。\n    - 该回归的$R^2(\\beta)$值衡量了与线性模型的拟合优度。接近$1$的值表示与幂律的拟合良好，因此拓扑结构近似无标度。在非空组少于$2$个或$\\{y_b\\}$的方差为零的特殊情况下，$R^2(\\beta)$定义为$0$。\n\n4.  **计算平均连接度**：计算网络的平均连接度$\\bar{k}(\\beta) = \\frac{1}{n} \\sum_{i=1}^{n} k_i(\\beta)$。为了创建一个标准化的度量，该值通过可能的最大平均连接度$n-1$进行归一化，得到$c(\\beta) = \\frac{\\bar{k}(\\beta)}{n-1}$。这个归一化值$c(\\beta)$位于$[0, 1]$区间内。\n\n第三，我们选择最优的幂$\\beta^\\star$。两个度量，$R^2(\\beta)$和$c(\\beta)$，被组合成一个单一的标量目标函数$O(\\beta) = \\alpha \\, R^2(\\beta) + (1 - \\alpha) \\, c(\\beta)$，其中$\\alpha \\in [0, 1]$是一个权重，用于调整无标度拓扑拟合与平均连接度的相对重要性。我们为所有候选幂计算$O(\\beta)$。\n\n最优幂$\\beta^\\star$被选为最大化$O(\\beta)$的那个。如果在$O(\\beta)$的值上出现平局（在数值精度范围内），则选择竞争者中最小的$\\beta$。当主要目标度量饱和时，这个平局打破规则偏好更简单的模型和更密集的网络。\n\n最后，对于每个测试用例，报告所选的三元组$[\\beta^\\star, R^2(\\beta^\\star), \\bar{k}(\\beta^\\star)]$，其中$R^2$和平均连接度值四舍五入到四位小数。整个过程被实现并应用于提供的测试套件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef calculate_r_squared(k, n, delta):\n    \"\"\"\n    Calculates the scale-free topology fit R^2 for a given connectivity vector k.\n    \n    Args:\n        k (np.ndarray): Vector of node connectivities.\n        n (int): Number of genes (nodes).\n        delta (float): Small constant to avoid log(0).\n\n    Returns:\n        float: The R^2 value.\n    \"\"\"\n    if n == 1:\n        return 0.0\n    num_bins = int(np.ceil(np.log2(n) + 1))\n    \n    # Filter out any potential non-finite values from k\n    k_finite = k[np.isfinite(k)]\n    if k_finite.size == 0:\n        return 0.0\n\n    counts, bin_edges = np.histogram(k_finite, bins=num_bins)\n    \n    non_empty_indices = np.where(counts > 0)[0]\n    \n    # If there are fewer than 2 non-empty bins, R^2 is undefined/unstable.\n    if len(non_empty_indices) < 2:\n        return 0.0\n        \n    non_empty_counts = counts[non_empty_indices]\n    \n    bin_midpoints = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n    non_empty_midpoints = bin_midpoints[non_empty_indices]\n    \n    # Avoid log of zero for midpoints\n    # Connectivities k_i are >= 0, so midpoints are >= 0.\n    valid_midpoints_mask = non_empty_midpoints > 0\n    if np.sum(valid_midpoints_mask) < 2:\n        return 0.0\n\n    x = np.log(non_empty_midpoints[valid_midpoints_mask] + delta)\n    y = np.log(non_empty_counts[valid_midpoints_mask] + delta)\n    \n    if x.size < 2:\n        return 0.0\n\n    # If variance of y is zero, R^2 is 0 or undefined.\n    if np.var(y) < 1e-12:\n        return 0.0\n        \n    # If variance of x is zero (should not happen if x.size > 1 and midpoints are distinct)\n    if np.var(x) < 1e-12:\n        return 0.0\n\n    lin_reg_result = stats.linregress(x, y)\n    r_squared = lin_reg_result.rvalue**2\n    \n    return r_squared\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case for beta selection.\n    \"\"\"\n    case_name = params['name']\n    n = params['n']\n    beta_candidates = params['betas']\n    alpha = params['alpha']\n    delta = 1e-10\n    \n    R = None\n\n    if case_name == 'A':\n        m = params['m']\n        seed = params['seed']\n        rng = np.random.default_rng(seed)\n        \n        L1 = rng.normal(size=m)\n        L2 = rng.normal(size=m)\n        X = np.zeros((n, m))\n        \n        # Module 1: genes 1-20 (indices 0-19)\n        eps1 = rng.normal(loc=0.0, scale=0.5, size=(20, m))\n        X[0:20, :] = 0.9 * L1[np.newaxis, :] + eps1\n        # Module 2: genes 21-35 (indices 20-34)\n        eps2 = rng.normal(loc=0.0, scale=0.5, size=(15, m))\n        X[20:35, :] = 0.9 * L2[np.newaxis, :] + eps2\n        # Non-modular: genes 36-50 (indices 35-49)\n        eps3 = rng.normal(loc=0.0, scale=1.0, size=(15, m))\n        X[35:50, :] = eps3\n        \n        R = np.corrcoef(X)\n        \n    elif case_name == 'B':\n        R = np.full((n, n), 0.9)\n        np.fill_diagonal(R, 1.0)\n        \n    elif case_name == 'C':\n        m = params['m']\n        seed = params['seed']\n        rng = np.random.default_rng(seed)\n        X = rng.normal(loc=0.0, scale=1.0, size=(n, m))\n        R = np.corrcoef(X)\n    \n    abs_R = np.abs(R)\n    \n    results = []\n    for beta in beta_candidates:\n        A = np.power(abs_R, beta)\n        np.fill_diagonal(A, 0)\n        \n        k = A.sum(axis=1)\n        k_bar = k.mean()\n        \n        r_sq = calculate_r_squared(k, n, delta)\n        \n        c = k_bar / (n - 1) if n > 1 else 0\n        \n        O = alpha * r_sq + (1 - alpha) * c\n        \n        results.append({'beta': beta, 'O': O, 'r_sq': r_sq, 'k_bar': k_bar})\n        \n    # Sort by objective value descending, then by beta ascending to break ties\n    best_result = sorted(results, key=lambda x: (-x['O'], x['beta']))[0]\n    \n    return [best_result['beta'], best_result['r_sq'], best_result['k_bar']]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'name': 'A', 'n': 50, 'm': 60, 'seed': 42,\n            'betas': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'alpha': 0.8\n        },\n        {\n            'name': 'B', 'n': 30, 'betas': [1, 2, 4, 8], 'alpha': 0.5\n        },\n        {\n            'name': 'C', 'n': 40, 'm': 50, 'seed': 123,\n            'betas': [1, 2, 3, 4, 5], 'alpha': 0.7\n        }\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = solve_case(case_params)\n        all_results.append(result)\n\n    # Format the final output string as per requirements\n    formatted_parts = []\n    for part in all_results:\n        beta_val = part[0]\n        r2_val = part[1]\n        k_val = part[2]\n        formatted_parts.append(f\"[{beta_val},{r2_val:.4f},{k_val:.4f}]\")\n    \n    print(f\"[{','.join(formatted_parts)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "系统生物医学中，共表达网络分析的一个核心目标是揭示调控网络在不同生物学条件下（例如疾病与健康状态）如何发生重构。这通常涉及识别那些共表达强度发生显著变化的“差异共表达”边。这项练习  为您介绍了比较两个独立样本相关系数的统计学基础。通过应用 Fisher z-变换，您将学会如何对差异共表达进行严格的假设检验，这项技能对于发现条件特异性的基因相互作用至关重要。",
            "id": "4328670",
            "problem": "在系统生物医学中，基因共表达网络编码了表现出协同转录调控的基因之间的边。为了识别其共表达特定于某一生物学条件的边，请考虑一个基因对，其在两种条件下独立测量的样本相关系数分别为 $r_1$ 和 $r_2$，样本量分别为 $n_1$ 和 $n_2$。假设在这两种条件下，这两个基因的联合表达近似为二元正态分布，并回顾 Fisher 变换 $z = \\arctanh(r) = \\frac{1}{2}\\ln\\!\\left(\\frac{1+r}{1-r}\\right)$，对于较大的 $n$，该变换产生一个近似正态的变量，其均值为 $\\arctanh(\\rho)$，方差为 $1/(n-3)$，其中 $\\rho$ 是总体相关系数。假设两项研究是独立的。\n\n从这些事实和原假设 $H_0:\\ \\rho_1 = \\rho_2$ 出发，推导出一个标准化的检验统计量，该统计量使用两个 Fisher 变换后的相关系数之差来评估这条边的差异相关性。然后，对于具体情况 $r_1=0.42$，$r_2=0.05$，$n_1=60$ 和 $n_2=55$，计算该检验统计量的值。将最终数值表示为一个纯数字，并将您的答案四舍五入到四位有效数字。",
            "solution": "问题陈述已经过验证，被认为是科学合理的、定义明确的、客观的。它描述了一种用于比较两个独立相关系数的标准且有效的统计程序。所有必要信息均已提供，且其前提与已建立的统计理论一致。\n\n目标是基于两个独立样本，为两个总体相关系数之间无差异的原假设 $H_0: \\rho_1 = \\rho_2$ 推导出一个标准化的检验统计量，然后计算其在特定情况下的值。\n\n设 $r_1$ 和 $r_2$ 分别是来自两个独立研究的样本相关系数，样本量分别为 $n_1$ 和 $n_2$。相应的总体相关系数是 $\\rho_1$ 和 $\\rho_2$。问题陈述指出，基础变量的联合分布是二元正态的。\n\nFisher 变换由 $z = \\arctanh(r) = \\frac{1}{2}\\ln\\left(\\frac{1+r}{1-r}\\right)$ 给出。对于大小为 $n$ 的大样本，变换后的变量 $z$ 近似服从正态分布，其均值为 $\\arctanh(\\rho)$，方差为 $\\sigma_z^2 = \\frac{1}{n-3}$。\n\n我们将此变换应用于我们的两个样本相关系数 $r_1$ 和 $r_2$。我们得到两个随机变量 $z_1$ 和 $z_2$：\n$$ z_1 = \\arctanh(r_1) \\quad \\text{和} \\quad z_2 = \\arctanh(r_2) $$\n根据问题陈述，它们的分布近似为正态分布：\n$$ z_1 \\sim N\\left(\\mu_1 = \\arctanh(\\rho_1), \\sigma_1^2 = \\frac{1}{n_1-3}\\right) $$\n$$ z_2 \\sim N\\left(\\mu_2 = \\arctanh(\\rho_2), \\sigma_2^2 = \\frac{1}{n_2-3}\\right) $$\n这两项研究是独立的，这意味着随机变量 $z_1$ 和 $z_2$ 也是独立的。\n\n我们关心的是两个 Fisher 变换后的相关系数之差，$D = z_1 - z_2$。由于 $z_1$ 和 $z_2$ 是独立的正态变量，它们的差 $D$ 也服从正态分布。\n差值的均值是均值的差值：\n$$ E[D] = E[z_1] - E[z_2] = \\arctanh(\\rho_1) - \\arctanh(\\rho_2) $$\n独立变量之差的方差是它们方差的和：\n$$ \\text{Var}(D) = \\text{Var}(z_1) + \\text{Var}(z_2) = \\frac{1}{n_1-3} + \\frac{1}{n_2-3} $$\n原假设是 $H_0: \\rho_1 = \\rho_2$。这等价于陈述 $\\arctanh(\\rho_1) = \\arctanh(\\rho_2)$，因为 $\\arctanh$ 是一个严格递增的函数。在此原假设下，差值 $D$ 的期望值为零：\n$$ E[D]_{H_0} = \\arctanh(\\rho_1) - \\arctanh(\\rho_1) = 0 $$\n一个标准化的检验统计量，通常表示为 $Z$，是通过从观测值中减去原假设下的均值，然后除以标准差（也称为标准误）来构建的。差值的标准误是 $\\text{SE}_D = \\sqrt{\\text{Var}(D)}$。\n因此，标准化的检验统计量是：\n$$ Z = \\frac{(z_1 - z_2) - E[D]_{H_0}}{\\text{SE}_D} = \\frac{z_1 - z_2 - 0}{\\sqrt{\\frac{1}{n_1-3} + \\frac{1}{n_2-3}}} $$\n这简化为检验统计量的一般公式：\n$$ Z = \\frac{\\arctanh(r_1) - \\arctanh(r_2)}{\\sqrt{\\frac{1}{n_1-3} + \\frac{1}{n_2-3}}} $$\n在原假设下，对于足够大的 $n_1$ 和 $n_2$，这个 $Z$ 统计量服从标准正态分布 $Z \\sim N(0,1)$。推导到此完成。\n\n接下来，我们为给定的数据计算该检验统计量的值：$r_1=0.42$，$r_2=0.05$，$n_1=60$ 和 $n_2=55$。\n\n首先，我们计算 Fisher 变换后的相关系数 $z_1$ 和 $z_2$：\n$$ z_1 = \\arctanh(0.42) = \\frac{1}{2}\\ln\\left(\\frac{1+0.42}{1-0.42}\\right) = \\frac{1}{2}\\ln\\left(\\frac{1.42}{0.58}\\right) \\approx 0.447675 $$\n$$ z_2 = \\arctanh(0.05) = \\frac{1}{2}\\ln\\left(\\frac{1+0.05}{1-0.05}\\right) = \\frac{1}{2}\\ln\\left(\\frac{1.05}{0.95}\\right) \\approx 0.050042 $$\n分子中的差值是：\n$$ z_1 - z_2 \\approx 0.447675 - 0.050042 = 0.397633 $$\n接下来，我们计算分母中的标准误：\n$$ \\text{SE}_D = \\sqrt{\\frac{1}{n_1-3} + \\frac{1}{n_2-3}} = \\sqrt{\\frac{1}{60-3} + \\frac{1}{55-3}} = \\sqrt{\\frac{1}{57} + \\frac{1}{52}} $$\n$$ \\frac{1}{57} \\approx 0.01754386 $$\n$$ \\frac{1}{52} \\approx 0.01923077 $$\n$$ \\text{SE}_D = \\sqrt{0.01754386 + 0.01923077} = \\sqrt{0.03677463} \\approx 0.191767 $$\n最后，我们计算检验统计量 $Z$：\n$$ Z = \\frac{0.397633}{0.191767} \\approx 2.073539 $$\n将结果四舍五入到四位有效数字得到 $2.074$。",
            "answer": "$$\\boxed{2.074}$$"
        }
    ]
}