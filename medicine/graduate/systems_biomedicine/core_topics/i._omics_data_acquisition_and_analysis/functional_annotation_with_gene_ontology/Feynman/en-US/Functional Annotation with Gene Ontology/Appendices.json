{
    "hands_on_practices": [
        {
            "introduction": "The Gene Ontology's power lies not just in its vocabulary but in its structure as a Directed Acyclic Graph (DAG), where terms are connected by precisely defined relationships. A foundational concept, the \"true path rule,\" dictates how annotations propagate, but it only applies to subsumptive relations like $is\\_a$ and $part\\_of$. This practice challenges you to reason from first principles about why non-subsumptive relations like $regulates$ break this rule, and to see firsthand how misinterpretation leads to biologically incorrect conclusions . By working through this scenario, you will solidify your understanding of GO's semantic logic, a critical skill for accurately interpreting annotation data.",
            "id": "4344264",
            "problem": "In the Gene Ontology (GO) Biological Process (BP) domain, terms are organized in a Directed Acyclic Graph (DAG) where edges encode relationships such as \"is_a,\" \"part_of,\" and \"regulates\" (including \"positively_regulates\" and \"negatively_regulates\"). The widely used \"true path rule\" applies to \"is_a\" and \"part_of\" relations, supporting upward propagation of annotations from a child term to all its ancestors along these relations. The \"regulates\" family of relations does not denote class subsumption and therefore does not, by definition, guarantee the validity of upward propagation. Consider the following BP subgraph and gene annotations that are scientifically plausible in a eukaryotic model system:\n- Terms and relations:\n  - $t_1$: cell cycle process.\n  - $t_2$: regulation of cell cycle process, with $t_2 \\xrightarrow{\\mathrm{regulates}} t_1$.\n  - $t_3$: positive regulation of cell cycle process, with $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2$.\n  - $t_4$: DNA replication, with $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$.\n  - $t_5$: checkpoint signaling, with $t_5 \\xrightarrow{\\mathrm{regulates}} t_4$.\n- Gene product annotations with evidence:\n  - $g_1 \\rightarrow t_5$ with Inferred from Direct Assay (IDA).\n  - $g_2 \\rightarrow t_3$ with Inferred from Mutant Phenotype (IMP).\n  - $g_3 \\rightarrow t_4$ with Inferred from Direct Assay (IDA).\n  - $g_4 \\rightarrow t_1$ with Traceable Author Statement (TAS).\n\nSuppose an annotation engine performs unguarded upward propagation that treats \"regulates\" like \"part_of\" and \"is_a\" (i.e., it traverses any edge type as if they justified class subsumption). Using only the core definitions above and set logic, reason from first principles about how this unguarded propagation inflates the set of gene products annotated to $t_1$.\n\nYour task is twofold: \n- First, use the graph and annotations to identify the specific paths by which unguarded propagation adds gene products to $t_1$ that should not be counted under the true path rule.\n- Second, select a rule set that prevents this inflation while preserving all valid upward propagation along \"is_a\" and \"part_of\" relations. For the option you select, the predicted number of unique gene products annotated to $t_1$ after applying the rule set must match the logically correct count implied by the definitions.\n\nWhich option both identifies a rule set that prevents inflation and gives the correct predicted count of unique gene products annotated to $t_1$ after propagation?\n\nA. Adopt the following rule set: apply upward propagation only along \"is_a\" and \"part_of\" relations; never traverse any path that includes any \"regulates\"-family edge (that is, \"regulates,\" \"positively_regulates,\" or \"negatively_regulates\"), regardless of what edges follow; maintain qualifiers such as \"NOT\" as blockers of propagation if present. Predicted count at $t_1$ after propagation: $2$.\n\nB. Allow upward propagation along \"is_a\" and \"part_of,\" and also allow a single \"regulates\" hop only when it is immediately followed by a \"part_of\" hop; disallow \"regulates\" in all other contexts. Predicted count at $t_1$ after propagation: $3$.\n\nC. Allow upward propagation along all edge types, but after propagation, remove gene products whose direct annotation was to a term whose name contains the substring \"regulation of.\" Predicted count at $t_1$ after propagation: $3$.\n\nD. Disallow upward propagation across \"negatively_regulates\" edges but allow propagation across \"regulates\" and \"positively_regulates\" edges; otherwise propagate as usual across \"is_a\" and \"part_of.\" Predicted count at $t_1$ after propagation: $4$.",
            "solution": "The user has provided a problem concerning annotation propagation within the Gene Ontology (GO) framework. I will first validate the problem statement and then proceed to a full derivation and evaluation of the options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following information:\n\n*   **Ontology Terms and Definitions:**\n    *   $t_1$: cell cycle process\n    *   $t_2$: regulation of cell cycle process\n    *   $t_3$: positive regulation of cell cycle process\n    *   $t_4$: DNA replication\n    *   $t_5$: checkpoint signaling\n*   **Ontology Relations (Edges):**\n    *   $t_2 \\xrightarrow{\\mathrm{regulates}} t_1$\n    *   $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2$\n    *   $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$\n    *   $t_5 \\xrightarrow{\\mathrm{regulates}} t_4$\n*   **Direct Gene Product Annotations:**\n    *   $g_1 \\rightarrow t_5$\n    *   $g_2 \\rightarrow t_3$\n    *   $g_3 \\rightarrow t_4$\n    *   $g_4 \\rightarrow t_1$\n*   **Propagation Rules and Definitions:**\n    *   The \"true path rule\" applies to `is_a` and `part_of` relations, supporting upward propagation from a child term to its ancestors.\n    *   The `regulates` family of relations does not denote class subsumption, and upward propagation is not guaranteed to be valid.\n*   **Hypothetical Scenario:**\n    *   An \"unguarded\" annotation engine is defined as one that treats `regulates` relations as if they justified upward propagation (i.e., like `is_a` and `part_of`).\n*   **Task:**\n    1.  Identify the specific paths causing incorrect (\"inflated\") annotation of gene products to term $t_1$ under the unguarded propagation model.\n    2.  Select an option that provides a rule set to prevent this inflation and correctly predicts the number of unique gene products annotated to $t_1$ after applying that rule set.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientifically Grounded:** The problem is firmly based on the real-world structure and use of the Gene Ontology, a cornerstone of bioinformatics. The concepts of a Directed Acyclic Graph (DAG), different relationship types (`is_a`, `part_of`, `regulates`), the \"true path rule\", and the semantic issues surrounding propagation over `regulates` edges are all standard and scientifically sound. The specific biological example is plausible. The problem does not violate any scientific principles.\n2.  **Well-Posed:** The problem provides a clearly defined graph structure, a complete set of initial annotations, and a clear distinction between the correct propagation logic (\"true path rule\") and a flawed logic (\"unguarded propagation\"). It asks for a specific outcome: identifying the correct rule set and the resulting count, which is a solvable problem given the inputs.\n3.  **Objective:** The language is precise and technical. All terms are either formally defined within the problem (`unguarded propagation`) or are standard in the field (`Gene Ontology`, `true path rule`). There are no subjective or opinion-based statements.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is valid. It is scientifically sound, well-posed, and objective. I will proceed with the solution.\n\n### Derivation and Analysis\n\nThe core of the problem is to determine the correct set of gene annotations for term $t_1$ and then evaluate which of the proposed rule sets in the options correctly reproduces this set and its cardinality.\n\n**1. Graph Structure and Annotation Paths**\n\nLet us represent the connections from gene annotations to the target term $t_1$:\n*   **Direct:** $g_4 \\rightarrow t_1$\n*   **Path for $g_3$:** $g_3 \\rightarrow t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$\n*   **Path for $g_2$:** $g_2 \\rightarrow t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2 \\xrightarrow{\\mathrm{regulates}} t_1$\n*   **Path for $g_1$:** $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$\n\n**2. Logically Correct Annotations for $t_1$ (Applying the True Path Rule)**\n\nThe \"true path rule\" mandates that for an annotation to propagate from a term $C$ to an ancestor term $P$, the entire path from $C$ to $P$ must consist only of relations that imply class subsumption, namely `is_a` and `part_of`.\n\n*   **$g_4$:** Is directly annotated to $t_1$. It is included.\n*   **$g_3$:** Is annotated to $t_4$. The path $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$ consists solely of a `part_of` edge. This is a valid propagation path. Thus, $g_3$ is correctly annotated to $t_1$.\n*   **$g_2$:** Is annotated to $t_3$. The path to $t_1$ is $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2 \\xrightarrow{\\mathrm{regulates}} t_1$. This path contains a `regulates` edge. Propagation along this edge is not valid under the true path rule. Therefore, $g_2$ should not be annotated to $t_1$.\n*   **$g_1$:** Is annotated to $t_5$. The path to $t_1$ is $t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$. This path contains a `regulates` edge, which breaks the true path. Therefore, $g_1$ should not be annotated to $t_1$. A gene product involved in checkpoint signaling ($t_5$) that regulates DNA replication ($t_4$) is a regulator of a part of the cell cycle; it is not itself a part of the cell cycle process ($t_1$).\n\nThe set of logically correct annotations for $t_1$ is $\\{g_3, g_4\\}$.\nThe correct count of unique gene products for $t_1$ is $2$.\n\n**3. Inflated Annotations for $t_1$ (Unguarded Propagation)**\n\nThe \"unguarded\" engine propagates along all edge types.\n*   $g_4$ is included (direct).\n*   $g_3$ is included via $t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$.\n*   $g_2$ is included via $t_3 \\xrightarrow{\\mathrm{is\\_a}} t_2 \\xrightarrow{\\mathrm{regulates}} t_1$.\n*   $g_1$ is included via $t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$.\n\nThe inflated set is $\\{g_1, g_2, g_3, g_4\\}$, with a count of $4$. The inflation is the addition of $\\{g_1, g_2\\}$.\n\n**4. Option-by-Option Analysis**\n\nThe goal is to find a rule set that yields the correct set $\\{g_3, g_4\\}$ and a count of $2$.\n\n**A. Adopt the following rule set: apply upward propagation only along \"is_a\" and \"part_of\" relations; never traverse any path that includes any \"regulates\"-family edge... Predicted count at $t_1$ after propagation: $2$.**\n\n*   **Analysis of Rule Set:** This rule set is a precise statement of the true path rule. It allows propagation only along `is_a` and `part_of` paths.\n*   **Application to Paths:**\n    *   $g_4$: Included (direct).\n    *   $g_3 \\rightarrow t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$: Path is valid. $g_3$ is included.\n    *   $g_2 \\rightarrow t_3 \\rightarrow t_2 \\xrightarrow{\\mathrm{regulates}} t_1$: Path contains a `regulates` edge and is blocked. $g_2$ is excluded.\n    *   $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\rightarrow t_1$: Path contains a `regulates` edge and is blocked. $g_1$ is excluded.\n*   **Resulting Set and Count:** The resulting set is $\\{g_3, g_4\\}$, and the count is $2$.\n*   **Predicted Count:** The option predicts a count of $2$. This matches the calculated correct count.\n*   **Verdict:** This option provides a rule set that correctly prevents inflation and preserves valid annotations. The predicted count is also correct. This is the logically sound approach. **Correct.**\n\n**B. Allow upward propagation along \"is_a\" and \"part_of,\" and also allow a single \"regulates\" hop only when it is immediately followed by a \"part_of\" hop; disallow \"regulates\" in all other contexts. Predicted count at $t_1$ after propagation: $3$.**\n\n*   **Analysis of Rule Set:** This is a custom, non-standard rule.\n*   **Application to Paths:**\n    *   $g_4$: Included (direct).\n    *   $g_3 \\rightarrow t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$: Valid. $g_3$ is included.\n    *   $g_2 \\rightarrow t_3 \\rightarrow t_2 \\xrightarrow{\\mathrm{regulates}} t_1$: The `regulates` hop is not followed by `part_of`. It is disallowed. $g_2$ is excluded.\n    *   $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\xrightarrow{\\mathrm{part\\_of}} t_1$: The `regulates` hop is immediately followed by a `part_of` hop. This rule explicitly allows this propagation. $g_1$ is included.\n*   **Resulting Set and Count:** The resulting set is $\\{g_1, g_3, g_4\\}$, and the count is $3$.\n*   **Predicted Count:** The option's predicted count of $3$ matches this calculation. However, the rule set itself is flawed because it does not prevent the inflation caused by $g_1$. It incorrectly propagates an annotation that violates the \"part-of\" semantics.\n*   **Verdict:** The rule set does not lead to the logically correct result. **Incorrect.**\n\n**C. Allow upward propagation along all edge types, but after propagation, remove gene products whose direct annotation was to a term whose name contains the substring \"regulation of.\" Predicted count at $t_1$ after propagation: $3$.**\n\n*   **Analysis of Rule Set:** This is a heuristic, post-processing approach based on string matching in term names, not on the semantic logic of the graph relations.\n*   **Application:**\n    1.  Propagate all, yielding the inflated set $\\{g_1, g_2, g_3, g_4\\}$.\n    2.  Filter based on the direct annotation term's name:\n        *   $g_1 \\rightarrow t_5$ (\"checkpoint signaling\"): Name does not contain \"regulation of\". Keep.\n        *   $g_2 \\rightarrow t_3$ (\"positive regulation of cell cycle process\"): Name contains \"regulation of\". Remove.\n        *   $g_3 \\rightarrow t_4$ (\"DNA replication\"): Name does not contain \"regulation of\". Keep.\n        *   $g_4 \\rightarrow t_1$ (\"cell cycle process\"): Name does not contain \"regulation of\". Keep.\n*   **Resulting Set and Count:** The resulting set is $\\{g_1, g_3, g_4\\}$, and the count is $3$.\n*   **Predicted Count:** The predicted count of $3$ matches the calculation. However, like option B, this rule set is flawed. It fails to filter the incorrect propagation of $g_1$. Such a name-based rule is not robust.\n*   **Verdict:** The rule set is not principled and leads to an incorrect result. **Incorrect.**\n\n**D. Disallow upward propagation across \"negatively_regulates\" edges but allow propagation across \"regulates\" and \"positively_regulates\" edges... Predicted count at $t_1$ after propagation: $4$.**\n\n*   **Analysis of Rule Set:** This rule makes a distinction within the `regulates` family but still allows propagation over the generic `regulates` relation.\n*   **Application to Paths:**\n    *   $g_4$: Included (direct).\n    *   $g_3$: Included (valid `part_of` path).\n    *   $g_2 \\rightarrow t_3 \\rightarrow t_2 \\xrightarrow{\\mathrm{regulates}} t_1$: The rule allows propagation across `regulates`. $g_2$ is included.\n    *   $g_1 \\rightarrow t_5 \\xrightarrow{\\mathrm{regulates}} t_4 \\rightarrow t_1$: The rule allows propagation across `regulates`. $g_1$ is included.\n*   **Resulting Set and Count:** The resulting set is $\\{g_1, g_2, g_3, g_4\\}$, the fully inflated set. The count is $4$.\n*   **Predicted Count:** The predicted count of $4$ matches the calculation. However, this rule set fails to correct any of the inflation present in this specific problem.\n*   **Verdict:** The rule set does not solve the stated problem of preventing inflation. **Incorrect.**\n\n**Conclusion**\n\nOption A is the only choice that both identifies a logically sound rule set (the true path rule) for preventing annotation inflation over non-subsumptive relations and correctly predicts the resulting number of annotations for $t_1$.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Once we have correctly interpreted gene annotations, a common next step is to perform an enrichment analysis to see which GO terms are over-represented in a set of interesting genes. The statistical workhorse for this task is the hypergeometric test, which models sampling without replacement. However, the validity of this test is critically dependent on defining the correct background, or \"universe,\" of genes. This exercise provides a hands-on calculation to demonstrate and quantify the statistical bias that arises from using an inappropriate background, such as the entire genome instead of the set of genes detectable by a specific assay .",
            "id": "4344210",
            "problem": "In functional annotation with Gene Ontology (GO), one tests whether a set of differentially expressed genes is enriched for a GO term relative to an appropriate background set. The appropriate background is the set of genes that could have been detected by the assay, not the entire genome. Consider the following scientifically realistic toy scenario designed to isolate the effect of an incorrect background choice.\n\nA targeted assay interrogates a curated panel of $N=30$ genes. After stringent quality control, only $D=20$ genes in the panel are deemed detectable. A specific GO term $T$ annotates $K_{\\mathrm{genome}}=10$ of the $N=30$ genes in the full panel and $K_{\\mathrm{detectable}}=8$ of the $D=20$ detectable genes. In a contrast of interest, a differential analysis yields a gene set of size $n=5$, of which $k=3$ are annotated by $T$.\n\nStarting only from the fundamental principles of sampling without replacement and combinatorial counting, and treating the one-sided enrichment significance as the probability to draw at least $k$ annotated items in $n$ draws from a background containing $K$ annotated items out of a total of $N$ items, do the following:\n\n1. Derive the general counting expression for the one-sided tail probability of observing at least $k$ annotated genes in $n$ draws from a background with parameters $(N,K)$.\n2. Evaluate this probability for both background choices: the incorrect “genome” background $(N=30, K=10)$ and the correct detectable background $(N=20, K=8)$, using the observed $(n=5, k=3)$.\n3. Define the significance-inflation factor as $I = p_{\\mathrm{detectable}} / p_{\\mathrm{genome}}$, where $p_{\\mathrm{detectable}}$ is the one-sided $p$-value under the detectable background and $p_{\\mathrm{genome}}$ is the one-sided $p$-value under the genome background. Compute $I$.\n\nReport $I$ as a dimensionless number rounded to four significant figures.",
            "solution": "The Gene Ontology (GO) enrichment test for a given term compares the observed count of annotated genes in a study set to the distribution expected by random sampling without replacement from a specified background. The correct background for an assay is the set of genes that could have been detected by the assay; using a larger or smaller background changes the null distribution and can bias the significance.\n\nFundamental base: sampling without replacement from a finite population with $N$ total items of which $K$ are “annotated” (successes) and $N-K$ are “not annotated” (failures). Drawing $n$ items without replacement yields a random variable $X$ equal to the number of annotated items in the draw. The exact distribution of $X$ is the hypergeometric distribution derived from combinatorial counting: the number of ways to draw exactly $i$ annotated items and $n-i$ not annotated items is the product of the number of ways to choose the annotated items and the number of ways to choose the non-annotated items, divided by the total number of ways to choose $n$ items from $N$.\n\n1. Derivation of the one-sided tail probability. The probability of observing exactly $i$ annotated items in $n$ draws is\n$$\n\\Pr(X=i) = \\frac{\\binom{K}{i}\\,\\binom{N-K}{n-i}}{\\binom{N}{n}},\n$$\nwhich follows from counting $\\binom{K}{i}$ ways to choose $i$ annotated items and $\\binom{N-K}{n-i}$ ways to choose $n-i$ non-annotated items, normalized by the total number of size-$n$ subsets $\\binom{N}{n}$. The one-sided enrichment significance for an observed $k$ or more annotated items is the upper tail probability\n$$\np(N,K;n,k) \\equiv \\Pr(X \\ge k) = \\sum_{i=k}^{\\min\\{K,n\\}} \\frac{\\binom{K}{i}\\,\\binom{N-K}{n-i}}{\\binom{N}{n}}.\n$$\n\n2. Evaluate for both backgrounds with the observed values $n=5$ and $k=3$.\n\n(a) Incorrect “genome” background: $(N,K)=(30,10)$.\nHere $\\min\\{K,n\\}=\\min\\{10,5\\}=5$, so\n$$\np_{\\mathrm{genome}} = \\sum_{i=3}^{5} \\frac{\\binom{10}{i}\\,\\binom{20}{5-i}}{\\binom{30}{5}}.\n$$\nCompute each term:\n- For $i=3$: $\\binom{10}{3}=120$, $\\binom{20}{2}=190$, product $120 \\times 190 = 22800$.\n- For $i=4$: $\\binom{10}{4}=210$, $\\binom{20}{1}=20$, product $210 \\times 20 = 4200$.\n- For $i=5$: $\\binom{10}{5}=252$, $\\binom{20}{0}=1$, product $252 \\times 1 = 252$.\n\nSum of numerators: $22800 + 4200 + 252 = 27252$.\n\nDenominator: $\\binom{30}{5} = 142506$.\n\nThus\n$$\np_{\\mathrm{genome}} = \\frac{27252}{142506}.\n$$\nThis fraction simplifies by dividing numerator and denominator by $18$:\n$$\n\\frac{27252}{142506} = \\frac{1514}{7917}.\n$$\n\n(b) Correct detectable background: $(N,K)=(20,8)$.\nHere $\\min\\{K,n\\}=\\min\\{8,5\\}=5$, so\n$$\np_{\\mathrm{detectable}} = \\sum_{i=3}^{5} \\frac{\\binom{8}{i}\\,\\binom{12}{5-i}}{\\binom{20}{5}}.\n$$\nCompute each term:\n- For $i=3$: $\\binom{8}{3}=56$, $\\binom{12}{2}=66$, product $56 \\times 66 = 3696$.\n- For $i=4$: $\\binom{8}{4}=70$, $\\binom{12}{1}=12$, product $70 \\times 12 = 840$.\n- For $i=5$: $\\binom{8}{5}=56$, $\\binom{12}{0}=1$, product $56 \\times 1 = 56$.\n\nSum of numerators: $3696 + 840 + 56 = 4592$.\n\nDenominator: $\\binom{20}{5} = 15504$.\n\nThus\n$$\np_{\\mathrm{detectable}} = \\frac{4592}{15504}.\n$$\nThis fraction simplifies by dividing numerator and denominator by $16$:\n$$\n\\frac{4592}{15504} = \\frac{287}{969}.\n$$\n\n3. Compute the significance-inflation factor $I$ defined as\n$$\nI \\equiv \\frac{p_{\\mathrm{detectable}}}{p_{\\mathrm{genome}}} = \\frac{\\frac{287}{969}}{\\frac{1514}{7917}} = \\frac{287 \\times 7917}{969 \\times 1514}.\n$$\nMultiply numerators and denominators:\n$$\n287 \\times 7917 = 2{,}272{,}179, \\quad 969 \\times 1514 = 1{,}467{,}066.\n$$\nTherefore\n$$\nI = \\frac{2{,}272{,}179}{1{,}467{,}066} \\approx 1.54879\\ldots\n$$\nRounded to four significant figures,\n$$\nI \\approx 1.549.\n$$\n\nInterpretation: Because the GO term frequency among detectable genes is higher ($K_{\\mathrm{detectable}}/D = 8/20 = 0.4$) than in the genome background ($K_{\\mathrm{genome}}/N = 10/30 \\approx 0.333\\ldots$), using the genome background lowers the null expectation and produces a smaller one-sided tail probability. The resulting bias inflates apparent significance by a factor of approximately $I \\approx 1.549$ in this constructed example.",
            "answer": "$$\\boxed{1.549}$$"
        },
        {
            "introduction": "Functional annotation is not a static process; the Gene Ontology and its associated gene annotations are continuously updated by the scientific community. This dynamic nature presents a significant challenge to computational reproducibility, a cornerstone of modern science. This final practice guides you through the simulation of a robust, containerized workflow designed to ensure that your analytical results are verifiable and reproducible over time . By creating and comparing cryptographic signatures of your results, you will learn a powerful technique for validating the integrity of a complex bioinformatics pipeline against changes in its underlying data and software environment.",
            "id": "4344249",
            "problem": "You are tasked with writing a complete, runnable program that simulates a containerized workflow for functional annotation using Gene Ontology (GO) within systems biomedicine. The goal is to demonstrate how freezing GO and annotation snapshots yields identical results when reproduced at later times, and how changes in the snapshots lead to changes in results. The program must implement a deterministic functional enrichment pipeline grounded in first principles, compute a reproducibility signature of the results, and compare signatures across pairs of snapshots for multiple gene set queries.\n\nThe foundational base includes:\n- The definition of Gene Ontology (GO) as a Directed Acyclic Graph (DAG), where each term is a node, and edges encode parent-child relationships such that the \"true path rule\" holds: if a gene is annotated to a child term, it is implicitly annotated to all ancestor terms along any path to the root. Let the GO be represented by a set of terms $\\mathcal{T}$ and a parent mapping $P : \\mathcal{T} \\to 2^{\\mathcal{T}}$, where $P(t)$ returns the set of parent terms of $t$. Let ancestors of a term $t$ be defined recursively via the transitive closure of $P$.\n- The definition of the statistical enrichment test using the Hypergeometric Distribution (HD). Given a universe of genes of size $N$, a query (foreground) set of size $n$, and for a GO term $t$ the number of universe genes annotated to $t$ equal to $M$, suppose $k$ genes in the query are annotated to $t$. Under random sampling without replacement, the probability of observing at least $k$ annotated genes in the query is the right-tail hypergeometric probability:\n$$\np_t = \\mathbb{P}(X \\ge k) = \\sum_{i=k}^{\\min(M,n)} \\frac{\\binom{M}{i}\\binom{N-M}{n-i}}{\\binom{N}{n}}.\n$$\nThis is a well-tested statistical formula for gene set enrichment under the assumption of a fixed background and random sampling without replacement.\n\nYour program must:\n1. Encode two snapshots of GO structure and gene-to-GO annotations that represent frozen states at different times. Each snapshot must include:\n   - A GO DAG given by parent relationships for terms.\n   - A gene-to-term direct annotation map.\n   - A timestamp string and version strings that simulate a frozen manifest.\n2. Implement the true path rule by propagating all direct annotations to include all ancestor terms in the GO DAG (transitive closure).\n3. For a given query gene set, compute enrichment $p$-values $p_t$ for all GO terms $t$ that have at least one query gene annotated (i.e., $k > 0$), using the hypergeometric right-tail probability as given above.\n4. Construct a reproducibility signature for the results of a snapshot and a query by:\n   - Sorting terms by ascending $p$-value and then by term identifier to break ties.\n   - Rounding each $p$-value to a fixed number of decimal places to ensure deterministic string formatting.\n   - Concatenating term identifiers and their rounded $p$-values into a single canonical string and hashing it using a cryptographic hash function (e.g., SHA-256).\n   - The signature depends solely on the results and not on timestamps or environment strings.\n5. Compare the signatures between two snapshots for the same query to produce a boolean indicating whether the results are identical ($\\text{True}$ if signatures match, and $\\text{False}$ otherwise).\n\nData to embed in the program:\n- Snapshot $\\mathsf{A}$ at time $t_1$ and a repeated snapshot $\\mathsf{A}$ at time $t_2$ with identical content:\n  - Terms: $A$ (root), $B$ and $C$ are children of $A$, $D$ and $E$ are children of $B$, $F$ is a child of $C$.\n    - Formally, the parent mapping is:\n      $P(B) = \\{A\\}$, $P(C) = \\{A\\}$, $P(D) = \\{B\\}$, $P(E) = \\{B\\}$, $P(F) = \\{C\\}$, and $P(A) = \\emptyset$.\n  - Genes: $\\{g_1,g_2,g_3,g_4,g_5,g_6,g_7,g_8,g_9,g_{10}\\}$.\n  - Direct annotations:\n    $g_1 \\mapsto D$, $g_2 \\mapsto E$, $g_3 \\mapsto B$, $g_4 \\mapsto C$, $g_5 \\mapsto F$, $g_6 \\mapsto C$, $g_7 \\mapsto D$, $g_8 \\mapsto E$, $g_9 \\mapsto F$, $g_{10} \\mapsto A$.\n  - Timestamps for both snapshots are different strings but contents are identical.\n- Snapshot $\\mathsf{B}$ at time $t_3$ with modified content:\n  - Adds a term $G$ as a child of $C$ with $P(G)=\\{C\\}$.\n  - Moves the direct annotation of $g_6$ from $C$ to $G$.\n  - Moves the direct annotation of $g_5$ from $F$ to $G$.\n  - All other annotations and parent relationships are as in snapshot $\\mathsf{A}$.\n\nYour program must define the following query gene sets:\n- Query $\\mathsf{Q_1} = \\{g_1,g_2,g_5,g_7,g_9\\}$.\n- Query $\\mathsf{Q_2} = \\emptyset$ (boundary case).\n- Query $\\mathsf{Q_3} = \\{g_6\\}$.\n\nThe hypergeometric parameters must be derived from first principles for each term and snapshot:\n- Universe size $N$ equals the number of unique genes in the snapshot (which is $N=10$).\n- Query size $n$ equals the number of genes in the query set for the test ($n=5$ for $\\mathsf{Q_1}$, $n=0$ for $\\mathsf{Q_2}$, and $n=1$ for $\\mathsf{Q_3}$).\n- For each term $t$, compute $M$ as the number of universe genes annotated to $t$ after applying the true path rule, and $k$ as the number of query genes annotated to $t$ after applying the true path rule.\n\nTest Suite and required output:\n- Define the following six test cases, each producing a single boolean by comparing the reproducibility signatures between two snapshots for the specified query:\n  1. Compare snapshot $\\mathsf{A}(t_1)$ versus snapshot $\\mathsf{A}(t_2)$ for query $\\mathsf{Q_1}$.\n  2. Compare snapshot $\\mathsf{A}(t_1)$ versus snapshot $\\mathsf{B}(t_3)$ for query $\\mathsf{Q_1}$.\n  3. Compare snapshot $\\mathsf{A}(t_1)$ versus snapshot $\\mathsf{A}(t_2)$ for query $\\mathsf{Q_2}$.\n  4. Compare snapshot $\\mathsf{A}(t_1)$ versus snapshot $\\mathsf{B}(t_3)$ for query $\\mathsf{Q_2}$.\n  5. Compare snapshot $\\mathsf{A}(t_1)$ versus snapshot $\\mathsf{A}(t_2)$ for query $\\mathsf{Q_3}$.\n  6. Compare snapshot $\\mathsf{A}(t_1)$ versus snapshot $\\mathsf{B}(t_3)$ for query $\\mathsf{Q_3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots]$), where each $\\text{result}_i$ is a boolean computed as described above. There are no physical units or angles involved. All $p$-values and arithmetic must be computed as decimals (floating-point numbers), without any percentage signs. The output must be reproducible across runs and must not depend on user input, external files, or network access.",
            "solution": "The problem requires the implementation of a deterministic bioinformatics workflow for Gene Ontology (GO) functional enrichment analysis to demonstrate the principle of computational reproducibility. The core task is to create two distinct \"snapshots\" of GO data, run an analysis pipeline on them with several gene queries, and show that identical snapshots yield identical results, while modified snapshots produce different results. This is achieved by generating a cryptographic hash, or \"reproducibility signature,\" from the analysis output.\n\nThe solution is structured around several key principles: data modeling, graph traversal for logical inference, statistical testing, and canonicalization of results for hashing.\n\nFirst, the data for each snapshot is modeled according to the problem specification. A snapshot comprises a Gene Ontology structure, a set of gene-to-term annotations, and a universe of all genes. The GO is represented as a directed acyclic graph (DAG), specifically using a parent map where each term (a node) maps to a set of its parents. For instance, a relationship `term D is a child of term B` is encoded as term $D$ mapping to the set containing $B$. Gene annotations are represented as a mapping from each gene identifier to the set of GO terms it is directly associated with.\n\nSecond, the \"true path rule\" is implemented. This is a fundamental concept in Gene Ontology, stating that an annotation to a term implies annotation to all its ancestors up to the root. To implement this, an algorithm first computes the transitive closure of the parent relationships for every term in the GO DAG. This can be done efficiently for all terms using repeated graph traversals (e.g., breadth-first or depth-first search) starting from each term and navigating up to its parents, collecting all unique ancestors. Once the full ancestor set for every term is known, the direct annotations are propagated. For each gene, its full set of annotations becomes the union of its direct annotation terms and all of their respective ancestors. This process results in a complete mapping from each GO term to the full set of genes annotated to it, either directly or implicitly.\n\nThird, the statistical analysis is performed using the hypergeometric test. For each GO term $t$ and a given query gene set, we calculate a $p$-value, $p_t$, which represents the probability of observing an equal or greater number of associations between the query set and the term than expected by random chance. The parameters for the test are derived as follows:\n- The universe size, $N$, is the total count of unique genes in the snapshot.\n- The query size, $n$, is the number of genes in the input query set.\n- For a given term $t$, the population successes, $M$, is the total number of genes from the universe $N$ that are annotated to term $t$ (after true path propagation).\n- The sample successes, $k$, is the number of genes from the query set $n$ that are also annotated to term $t$.\nThe enrichment $p$-value is the right-tail probability of the hypergeometric distribution, $\\mathbb{P}(X \\ge k)$, which is calculated for every term where at least one query gene is annotated ($k > 0$). This ensures we only test terms relevant to the query.\n\nFourth, a reproducibility signature is generated from the enrichment results. This is a critical step to create a single, comparable identifier for the entire output of an analysis run. The process is as follows:\n1. The list of resulting pairs, $(t, p_t)$, is sorted. The primary sorting key is the $p$-value in ascending order. The secondary key, used to deterministically resolve ties in $p$-values, is the term identifier in lexicographical (alphabetical) order.\n2. Each $p$-value is rounded to a fixed number of decimal places. This step is crucial to prevent minor floating-point variations across different machine architectures from affecting the final signature.\n3. The sorted and rounded results are concatenated into a single, canonical string. For each result, the term identifier and its rounded $p$-value are appended together without separators.\n4. This canonical string is then hashed using the SHA-256 algorithm. The resulting hexadecimal digest serves as the unique and deterministic reproducibility signature for the given snapshot and query. An empty query results in an empty set of results, which deterministically hashes to a signature for an empty string.\n\nFinally, the program executes the specified test suite. For each test case, it runs the pipeline and generates a signature for two snapshot-query combinations. The two resulting signatures are compared. If they are identical, the analysis is deemed reproducible, and the comparison yields $\\text{True}$; otherwise, it yields $\\text{False}$. This directly tests the problem's central hypothesis: identical inputs (frozen snapshots $\\mathsf{A}(t_1)$ and $\\mathsf{A}(t_2)$) produce identical results, while differing inputs (snapshot $\\mathsf{A}$ vs. snapshot $\\mathsf{B}$) lead to different outcomes, thereby validating the integrity of the containerized workflow simulation. The logic correctly handles the boundary case of an empty query set, for which the results are empty and the signatures are consequently identical regardless of the snapshot data.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import hypergeom\nimport hashlib\nfrom collections import defaultdict\n\ndef get_reproducibility_signature(snapshot_data, query_set):\n    \"\"\"\n    Computes a deterministic reproducibility signature for a given GO snapshot and gene query.\n\n    The pipeline involves propagating annotations, running a hypergeometric test for enrichment,\n    and hashing a canonical representation of the results.\n    \"\"\"\n    # 1. Unpack snapshot data\n    parent_map = snapshot_data['parents']\n    direct_annotations = snapshot_data['annotations']\n    all_genes = snapshot_data['genes']\n\n    # 2. Pre-compute ancestors for all terms (transitive closure)\n    all_terms = set(parent_map.keys())\n    for term_list in parent_map.values():\n        all_terms.update(term_list)\n    \n    term_ancestors = {}\n    for term in all_terms:\n        # Non-recursive DFS/BFS for ancestor traversal\n        queue = list(parent_map.get(term, set()))\n        visited = set(queue)\n        ancestors = set(queue)\n        head = 0\n        while head  len(queue):\n            current_term = queue[head]\n            head += 1\n            parents = parent_map.get(current_term, set())\n            for p in parents:\n                if p not in visited:\n                    visited.add(p)\n                    ancestors.add(p)\n                    queue.append(p)\n        term_ancestors[term] = ancestors\n\n    # 3. Propagate annotations (true path rule) to get term -> {genes} map\n    term_to_all_genes = defaultdict(set)\n    for gene, terms in direct_annotations.items():\n        for term in terms:\n            # Add gene to its direct term\n            term_to_all_genes[term].add(gene)\n            # Add gene to all ancestors of the direct term\n            for ancestor in term_ancestors.get(term, set()):\n                term_to_all_genes[ancestor].add(gene)\n\n    # 4. Compute enrichment p-values\n    N = len(all_genes)\n    n = len(query_set)\n    \n    enrichment_results = []\n    if n > 0:\n        for term in all_terms:\n            genes_in_term = term_to_all_genes[term]\n            M = len(genes_in_term)\n            k = len(genes_in_term.intersection(query_set))\n            \n            if k > 0:\n                # Scipy's hypergeometric survival function P(X >= k) is sf(k-1, ...)\n                pval = hypergeom.sf(k - 1, N, M, n)\n                enrichment_results.append((term, pval))\n\n    # 5. Construct reproducibility signature\n    # Sort by p-value (asc), then term ID (asc) to break ties\n    enrichment_results.sort(key=lambda x: (x[1], x[0]))\n    \n    # Round p-values to a fixed precision for deterministic string formatting\n    precision = 12\n    canonical_string = \"\".join(f\"{term}{pval:.{precision}f}\" for term, pval in enrichment_results)\n    \n    # Hash the canonical string using SHA-256\n    hasher = hashlib.sha256()\n    hasher.update(canonical_string.encode('utf-8'))\n    return hasher.hexdigest()\n\ndef solve():\n    # Define the universe of genes\n    UNIVERSE_GENES = {f'g_{i}' for i in range(1, 11)}\n\n    # Snapshot A Data\n    SNAPSHOT_A_DATA = {\n        'timestamp': \"2023-01-15T10:00:00Z\",\n        'version': \"GO:2023-01-15, Annotations:v1.0\",\n        'genes': UNIVERSE_GENES,\n        'parents': {\n            'B': {'A'}, 'C': {'A'}, 'D': {'B'}, 'E': {'B'}, 'F': {'C'}\n        },\n        'annotations': {\n            'g_1': {'D'}, 'g_2': {'E'}, 'g_3': {'B'}, 'g_4': {'C'}, 'g_5': {'F'},\n            'g_6': {'C'}, 'g_7': {'D'}, 'g_8': {'E'}, 'g_9': {'F'}, 'g_10': {'A'}\n        }\n    }\n    \n    # Repeated Snapshot A' to simulate a later, identical run\n    SNAPSHOT_A_PRIME_DATA = {\n        'timestamp': \"2023-10-20T14:30:00Z\",\n        'version': \"GO:2023-01-15, Annotations:v1.0\",\n        'genes': UNIVERSE_GENES,\n        'parents': SNAPSHOT_A_DATA['parents'],\n        'annotations': SNAPSHOT_A_DATA['annotations']\n    }\n\n    # Snapshot B Data (modified)\n    SNAPSHOT_B_DATA = {\n        'timestamp': \"2024-03-01T11:00:00Z\",\n        'version': \"GO:2024-03-01, Annotations:v1.1\",\n        'genes': UNIVERSE_GENES,\n        'parents': {\n            'B': {'A'}, 'C': {'A'}, 'D': {'B'}, 'E': {'B'}, 'F': {'C'}, 'G': {'C'} # Added term G\n        },\n        'annotations': {\n            'g_1': {'D'}, 'g_2': {'E'}, 'g_3': {'B'}, 'g_4': {'C'}, 'g_5': {'G'},  # Moved from F to G\n            'g_6': {'G'}, 'g_7': {'D'}, 'g_8': {'E'}, 'g_9': {'F'}, 'g_10': {'A'}  # Moved from C to G\n        }\n    }\n\n    # Define Query Gene Sets\n    QUERY_Q1 = {'g_1', 'g_2', 'g_5', 'g_7', 'g_9'}\n    QUERY_Q2 = set()\n    QUERY_Q3 = {'g_6'}\n\n    # Define the test suite\n    test_cases = [\n        # Snap A vs. Snap A'\n        (SNAPSHOT_A_DATA, QUERY_Q1, SNAPSHOT_A_PRIME_DATA),  # 1. Test Q1, expect True\n        (SNAPSHOT_A_DATA, QUERY_Q1, SNAPSHOT_B_DATA),          # 2. Test Q1, expect False\n        (SNAPSHOT_A_DATA, QUERY_Q2, SNAPSHOT_A_PRIME_DATA),  # 3. Test Q2, expect True\n        (SNAPSHOT_A_DATA, QUERY_Q2, SNAPSHOT_B_DATA),          # 4. Test Q2, expect True (empty query)\n        (SNAPSHOT_A_DATA, QUERY_Q3, SNAPSHOT_A_PRIME_DATA),  # 5. Test Q3, expect True\n        (SNAPSHOT_A_DATA, QUERY_Q3, SNAPSHOT_B_DATA),          # 6. Test Q3, expect False\n    ]\n\n    results = []\n    for snap1_data, query, snap2_data in test_cases:\n        sig1 = get_reproducibility_signature(snap1_data, query)\n        sig2 = get_reproducibility_signature(snap2_data, query)\n        results.append(sig1 == sig2)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, [r.title() for r in results]))}]\")\n\nsolve()\n```"
        }
    ]
}