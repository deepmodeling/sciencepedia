{
    "hands_on_practices": [
        {
            "introduction": "为了建立我们对参数敏感性的直观理解，我们从一个局部敏感性分析的基础练习开始。这项练习要求我们为一个简单的一阶衰减模型推导归一化灵敏度，这是一阶药代动力学模型的基础 。我们的目标不仅是完成计算，更重要的是学习如何解读结果，即模型输出对参数的敏感性是如何随时间演变的。",
            "id": "4385521",
            "problem": "考虑一个均匀细胞区室中单个生物分子物质的最小一阶衰变模型，其中浓度 $x(t)$ 随常微分方程 $ \\dot{x}(t) = -k\\,x(t)$ 演化，初始条件为 $x(0) = x_{0}$，测量输出为 $y(t) = x(t)$。假设 $k > 0$ 且 $x_{0} > 0$，时间单位为秒，k 的单位为 $\\text{s}^{-1}$。使用动力学系统中局部归一化参数灵敏度的基本定义，其中对于输出 $y(t)$ 和参数 $k$，灵敏度函数为\n$$\nS_{y,k}(t) \\equiv \\frac{k}{y(t)}\\,\\frac{\\partial y(t)}{\\partial k},\n$$\n推导给定模型的 $S_{y,k}(t)$ 的闭式解。然后，从第一性原理出发，解释 $S_{y,k}(t)$ 的符号和时间依赖性如何反映衰变参数 $k$ 的生物物理意义以及模型的动力学特性。将你最终的灵敏度函数表示为单个解析表达式。无需进行数值四舍五入，你的最终表达式应为无量纲的。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第一步：提取已知条件\n已知条件如下：\n-   生物分子物质浓度 $x(t)$ 的常微分方程 (ODE)：$\\dot{x}(t) = -k\\,x(t)$。\n-   初始条件：$x(0) = x_0$。\n-   测量输出：$y(t) = x(t)$。\n-   参数约束：$k > 0$ 和 $x_0 > 0$。\n-   单位：时间 $t$ 的单位为秒（$\\text{s}$），速率常数 $k$ 的单位为 $\\text{s}^{-1}$。\n-   输出 $y(t)$ 相对于参数 $k$ 的局部归一化参数灵敏度函数的定义：$S_{y,k}(t) \\equiv \\frac{k}{y(t)}\\,\\frac{\\partial y(t)}{\\partial k}$。\n\n### 第二步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n-   **科学依据：** 模型 $\\dot{x} = -k\\,x$ 描述了一阶衰变，这是物理学、化学和生物学中一个基本且普遍存在的过程（例如，放射性衰变、单分子化学反应、蛋白质降解）。归一化灵敏度的定义是系统理论和灵敏度分析中的一个标准核心概念。该问题坚实地建立在已有的科学和数学原理之上。\n-   **适定性：** 该问题是一个适定的初值问题，待推导的量有标准定义。它提供了所有必要的信息（常微分方程、初始条件、输出定义和参数约束），以找到一个唯一的、稳定的且有意义的解。\n-   **客观性：** 语言正式、精确，没有任何主观或基于观点的陈述。\n-   设置完整且一致；没有缺失数据或矛盾的约束。\n-   对于一个简化的生物分子衰变模型，这些条件是物理上现实的。\n-   该问题需要推导和解释，这是一项实质性的任务，而非微不足道或同义反复的任务。\n\n### 第三步：结论与行动\n该问题被判定为**有效**。现在开始求解过程。\n\n第一步是求出输出 $y(t)$ 的解。该系统由线性一阶常微分方程 $\\frac{dx}{dt} = -k\\,x(t)$ 描述，初始条件为 $x(0) = x_0$。这是一个可分离变量的方程：\n$$\n\\frac{dx}{x} = -k\\,dt\n$$\n对两边从初始状态 $(0, x_0)$ 到一般状态 $(t, x(t))$ 进行积分，得到：\n$$\n\\int_{x_0}^{x(t)} \\frac{1}{\\xi}\\,d\\xi = \\int_{0}^{t} -k\\,d\\tau\n$$\n$$\n[\\ln|\\xi|]_{x_0}^{x(t)} = [-k\\,\\tau]_{0}^{t}\n$$\n考虑到 $x_0 > 0$ 且在生物物理背景下浓度 $x(t)$ 不可能为负，我们可以去掉绝对值符号。\n$$\n\\ln(x(t)) - \\ln(x_0) = -k\\,t\n$$\n$$\n\\ln\\left(\\frac{x(t)}{x_0}\\right) = -k\\,t\n$$\n对两边取指数，得到 $x(t)$ 的解：\n$$\nx(t) = x_0 \\exp(-k\\,t)\n$$\n因为输出定义为 $y(t) = x(t)$，我们有：\n$$\ny(t) = x_0 \\exp(-k\\,t)\n$$\n接下来，我们必须计算输出 $y(t)$ 对参数 $k$ 的偏导数。初始条件 $x_0$ 被视为一个与 $k$ 无关的常数。\n$$\n\\frac{\\partial y(t)}{\\partial k} = \\frac{\\partial}{\\partial k} \\left( x_0 \\exp(-k\\,t) \\right)\n$$\n使用链式法则求导，其中 $\\exp(u)$ 的导数是 $\\exp(u)\\frac{du}{dk}$，且 $u = -k\\,t$：\n$$\n\\frac{\\partial y(t)}{\\partial k} = x_0 \\exp(-k\\,t) \\cdot \\frac{\\partial}{\\partial k}(-k\\,t) = x_0 \\exp(-k\\,t) \\cdot (-t)\n$$\n$$\n\\frac{\\partial y(t)}{\\partial k} = -x_0\\,t\\,\\exp(-k\\,t)\n$$\n现在，将 $y(t)$ 和 $\\frac{\\partial y(t)}{\\partial k}$ 的表达式代入归一化灵敏度函数 $S_{y,k}(t)$ 的定义中：\n$$\nS_{y,k}(t) \\equiv \\frac{k}{y(t)}\\,\\frac{\\partial y(t)}{\\partial k} = \\frac{k}{x_0 \\exp(-k\\,t)} \\left( -x_0\\,t\\,\\exp(-k\\,t) \\right)\n$$\n分子和分母中的 $x_0$ 和 $\\exp(-k\\,t)$ 项相互抵消：\n$$\nS_{y,k}(t) = k \\cdot (-t) = -k\\,t\n$$\n这就是灵敏度函数的闭式表达式。该表达式是无量纲的，因为 $k$（单位 $\\text{s}^{-1}$）和 $t$（单位 $\\text{s}$）的乘积是无量纲的，这与归一化灵敏度的定义相符。\n\n从第一性原理的解释：\n灵敏度函数 $S_{y,k}(t) = -k\\,t$ 提供了关于系统输出如何响应衰变速率参数 $k$ 扰动的见解。其性质可以通过其符号和时间依赖性来分析。\n\n1.  **符号：** 对于所有 $t \\ge 0$（因为 $k > 0$），灵敏度函数 $S_{y,k}(t) \\le 0$。负灵敏度表示参数 $k$ 和输出 $y(t)$ 之间存在反比关系。具体来说，对于任何 $t>0$，$k$ 的增加会导致 $y(t)$ 的减少。从生物物理学的角度来看，这是直观正确的：参数 $k$ 代表衰变速率。更大的衰变速率常数意味着物质的消耗更快，导致在任何给定的时间点 $t > 0$，其浓度 $x(t) = y(t)$ 都低于具有较小 $k$ 值的系统。负号正式地捕捉了这种反比行为。\n\n2.  **时间依赖性：** 灵敏度的绝对值 $|S_{y,k}(t)| = k\\,t|$ 随时间线性增加。\n    -   在 $t=0$ 时，$S_{y,k}(0) = 0$。这意味着在初始时刻，输出对 $k$ 的值完全不敏感。这是因为 $t=0$ 时的输出由初始条件 $y(0) = x_0$ 确定，该条件独立于衰变过程本身，因此也独立于 $k$。\n    -   当 $t$ 从 0 开始增加时，灵敏度的绝对值无界增长。这种线性增长反映了衰变过程的累积性质。随着时间的推移，衰变速率 $k$ 的微小扰动对浓度 $y(t)$ 的相对影响会逐渐增大。对于较长的时间，系统状态受衰变过程影响的时间更长，使得最终浓度高度依赖于 $k$ 的精确值。衰变过程进行的时间越长，不同 $k$ 值导致的最终结果差异就越显著。这种随时间增加的灵敏度是这个简单动力学系统的一个关键特征。\n\n总之，推导得出 $S_{y,k}(t) = -k\\,t$，这正确地捕捉了生物物理现实：更快的衰变速率（$k$）导致更低的浓度（$y(t)$），并且这种影响随时间推移而变得更加显著。",
            "answer": "$$\\boxed{-k\\,t}$$"
        },
        {
            "introduction": "真实的生物过程很少是完全线性的。下一个练习将通过分析一个经典的米氏-门顿（Michaelis–Menten）消除模型来引入非线性问题 。通过推导模型状态对于最大消除速率 $V_{\\max}$ 的敏感性，我们将发现敏感性本身如何依赖于系统状态，并展现出比线性情况更复杂的动态行为。",
            "id": "4385597",
            "problem": "考虑一个浓度为 $x(t)$ 的单室生物分子物种，其经历具有 Michaelis–Menten 结构的饱和消除。状态动力学由以下常微分方程给出\n$$\n\\dot{x}(t) \\equiv \\frac{dx}{dt} \\;=\\; -\\,\\frac{V_{\\max}\\,x(t)}{K_{m} + x(t)},\n$$\n初始条件为 $x(0)=x_{0}>0$，其中 $K_{m}>0$ 和 $V_{\\max}>0$ 是恒定参数。测量输出为 $y(t)=x(t)$。假设 $x_{0}$ 不依赖于 $V_{\\max}$。仅使用局部参数灵敏度作为偏导数的基本定义和标准微积分方法（例如，变量分离法、对参数求导），推导未标度的局部灵敏度的显式解析表达式\n$$\nS_{y,V_{\\max}}(t) \\;=\\; \\frac{\\partial y(t)}{\\partial V_{\\max}}\n$$\n该表达式沿解轨迹 $x(t)$ 进行评估，并用 $x(t)$、$K_{m}$ 和 $t$ 表示。然后，根据你推导的表达式，说明 $S_{y,V_{\\max}}(t)$ 的符号和大小如何随 $x(t)$ 变化。你最终报告的答案必须是 $S_{y,V_{\\max}}(t)$ 的单个显式解析表达式。不需要数值近似，也不需要四舍五入。",
            "solution": "该问题要求推导状态变量 $x(t)$ 相对于参数 $V_{\\max}$ 的未标度的局部参数灵敏度。状态动力学由 Michaelis-Menten 常微分方程（ODE）给出：\n$$\n\\frac{dx}{dt} = -\\frac{V_{\\max} x(t)}{K_{m} + x(t)}\n$$\n初始条件为 $x(0) = x_{0} > 0$。参数 $V_{\\max}$ 和 $K_{m}$ 是正常数。测量输出为 $y(t) = x(t)$。我们需要求灵敏度 $S_{y,V_{\\max}}(t)$，其定义为：\n$$\nS_{y,V_{\\max}}(t) = \\frac{\\partial y(t)}{\\partial V_{\\max}} = \\frac{\\partial x(t)}{\\partial V_{\\max}}\n$$\n为简化表示，我们将此量记为 $S(t)$。问题指明初始条件 $x_{0}$ 与 $V_{\\max}$ 无关，这意味着 $\\frac{\\partial x_{0}}{\\partial V_{\\max}} = 0$。\n\n求 $S(t)$ 的一个直接方法是，首先通过对状态 ODE 积分得到 $x(t)$、时间 $t$ 和模型参数之间的关系，然后将此关系对 $V_{\\max}$ 求导。\n\n首先，我们用变量分离法求解该 ODE。\n$$\n\\frac{K_{m} + x(t)}{x(t)} dx = -V_{\\max} dt\n$$\n整理左侧得到：\n$$\n\\left( \\frac{K_{m}}{x(t)} + 1 \\right) dx = -V_{\\max} dt\n$$\n我们对两边从初始时间 $t=0$ 到任意时间 $t$ 进行积分。在这些时间点的浓度分别为 $x(0)=x_{0}$ 和 $x(t)$。\n$$\n\\int_{x_{0}}^{x(t)} \\left( \\frac{K_{m}}{z} + 1 \\right) dz = \\int_{0}^{t} -V_{\\max} d\\tau\n$$\n计算积分得出：\n$$\n\\left[ K_{m} \\ln(z) + z \\right]_{x_{0}}^{x(t)} = \\left[ -V_{\\max} \\tau \\right]_{0}^{t}\n$$\n由于 $x_{0} > 0$ 并且当 $x>0$ 时变化率 $\\frac{dx}{dt}$ 为负，因此对于所有 $t \\geq 0$，浓度 $x(t)$ 保持为正。因此，我们不需要在对数中使用绝对值。\n$$\n\\left( K_{m} \\ln(x(t)) + x(t) \\right) - \\left( K_{m} \\ln(x_{0}) + x_{0} \\right) = -V_{\\max} t\n$$\n这个方程给出了 $x(t)$ 的一个隐式解。\n\n接下来，我们通过对此隐式解关于 $V_{\\max}$ 求导来求得灵敏度 $S(t) = \\frac{\\partial x(t)}{\\partial V_{\\max}}$。我们将 $x(t)$ 视为 $V_{\\max}$（和 $t$）的函数，并在适当的地方应用链式法则。根据题目陈述（$\\frac{\\partial x_{0}}{\\partial V_{\\max}} = 0$）以及 $K_{m}$ 是一个不依赖于 $V_{\\max}$ 的参数这一事实，仅涉及 $x_{0}$ 和 $K_{m}$ 的项对 $V_{\\max}$ 的导数为零。\n$$\n\\frac{\\partial}{\\partial V_{\\max}} \\left[ K_{m} \\ln(x(t)) + x(t) - K_{m} \\ln(x_{0}) - x_{0} \\right] = \\frac{\\partial}{\\partial V_{\\max}} \\left[ -V_{\\max} t \\right]\n$$\n对左侧逐项求导：\n$$\n\\frac{\\partial}{\\partial V_{\\max}} (K_{m} \\ln(x(t))) = K_{m} \\frac{1}{x(t)} \\frac{\\partial x(t)}{\\partial V_{\\max}} = \\frac{K_{m}}{x(t)} S(t)\n$$\n$$\n\\frac{\\partial}{\\partial V_{\\max}} (x(t)) = \\frac{\\partial x(t)}{\\partial V_{\\max}} = S(t)\n$$\n$$\n\\frac{\\partial}{\\partial V_{\\max}} (- K_{m} \\ln(x_{0}) - x_{0}) = 0\n$$\n所以左侧的导数是：\n$$\n\\frac{K_{m}}{x(t)} S(t) + S(t) = \\left( \\frac{K_{m}}{x(t)} + 1 \\right) S(t) = \\left( \\frac{K_{m} + x(t)}{x(t)} \\right) S(t)\n$$\n对右侧关于 $V_{\\max}$ 求导（在此上下文中将 $t$ 视为常数）得到：\n$$\n\\frac{\\partial}{\\partial V_{\\max}} (-V_{\\max} t) = -t\n$$\n令两边的导数相等，我们得到一个关于 $S(t)$ 的代数方程：\n$$\n\\left( \\frac{K_{m} + x(t)}{x(t)} \\right) S(t) = -t\n$$\n解出 $S(t)$ 得到灵敏度的最终表达式：\n$$\nS(t) = -t \\left( \\frac{x(t)}{K_{m} + x(t)} \\right)\n$$\n这就是题目所要求的未标度的局部灵敏度 $S_{y,V_{\\max}}(t)$ 的显式解析表达式，用 $x(t)$、$K_{m}$ 和 $t$ 表示。\n\n最后，我们分析 $S_{y,V_{\\max}}(t)$ 如何变化。\n对于 $t > 0$，时间 $t$ 是正的。由于 $x(t) > 0$ 且 $K_{m} > 0$，分数 $\\frac{x(t)}{K_{m} + x(t)}$ 总是正的。由于前导负号，灵敏度 $S_{y,V_{\\max}}(t)$ 对于 $t > 0$ 总是负的。在 $t=0$ 时，$S(0)=0$。这个负号在物理上是一致的：最大消除速率 $V_{\\max}$ 的增加将导致浓度 $x(t)$ 在任何后续时间都更低，因此偏导数必须为负。\n\n灵敏度的大小为 $|S(t)| = t \\frac{x(t)}{K_{m} + x(t)}$。这个大小是两项的乘积：单调增加的时间 $t$，以及项 $\\frac{x(t)}{K_{m} + x(t)}$。由于 $x(t)$ 是时间的单调递减函数，且函数 $f(z) = \\frac{z}{K_{m}+z}$ 对于 $z>0$ 是单调递增的，因此项 $\\frac{x(t)}{K_{m} + x(t)}$ 也是时间的单调递减函数。\n在 $t \\to 0$ 时， $|S(t)| \\to 0$。当 $t \\to \\infty$ 时，$x(t) \\to 0$。在 $x(t) \\ll K_{m}$ 的情况下，状态动力学近似为 $\\frac{dx}{dt} \\approx -\\frac{V_{\\max}}{K_{m}}x(t)$，导致指数衰减 $x(t) \\sim \\exp(-\\frac{V_{\\max}}{K_{m}}t)$。此时灵敏度的大小表现为 $|S(t)| \\approx t \\frac{x(t)}{K_{m}} \\sim t \\exp(-\\frac{V_{\\max}}{K_{m}}t)$，当 $t \\to \\infty$ 时，该值趋近于 0，因为指数衰减主导了 $t$ 的线性增长。\n由于灵敏度的大小在 $t=0$ 时从 0 开始，并在 $t \\to \\infty$ 时回到 0，因此它必须在某个中间时间 $t > 0$ 达到一个最大值。这意味着系统的输出 $x(t)$ 在衰减曲线上的某个中间点对 $V_{\\max}$ 的变化最敏感，而不是在开始时或消除过程的后期。",
            "answer": "$$\\boxed{-t \\frac{x(t)}{K_{m} + x(t)}}$$"
        },
        {
            "introduction": "从解析理论走向计算实践，我们现在将探讨在处理含噪声的实验数据时，如何评估模型参数的可信度。这个编程练习将为一个二室模型实现参数剖析（parameter profiling），这是一种评估参数可辨识性和置信区间的强大计算技术 。这项实践展示了敏感性分析的概念如何在模型校准和验证这一核心研究任务中发挥关键作用。",
            "id": "4385525",
            "problem": "给定一个参数化动力学系统，该系统常用于系统生物医学中，以模拟带有消除过程的双室模型。设状态向量为 $x(t) = [x_1(t), x_2(t)]^\\top$，初始条件为 $x_1(0) = D$ 和 $x_2(0) = 0$。输入为一次性推注剂量，因此在 $t=0$ 后没有随时间变化的输入。状态动力学遵循线性质量平衡定律：\n$$\n\\frac{dx_1}{dt} = -k_{\\mathrm{el}} x_1 - k_{12} x_1 + k_{21} x_2,\n\\qquad\n\\frac{dx_2}{dt} = k_{12} x_1 - k_{21} x_2,\n$$\n其中参数 $k_{\\mathrm{el}}$、$k_{12}$ 和 $k_{21}$ 均为严格正值。测量输出由一个线性观测模型给出\n$$\ny(t) = C_1 x_1(t),\n$$\n其中测量缩放因子 $C_1$ 为严格正值。令 $\\theta = [k_{\\mathrm{el}}, k_{12}, k_{21}, C_1]^\\top$ 表示完整的参数向量。\n\n为您提供在指定采样时间 $t_j$ 由模型生成的合成数据 $\\{(t_j, y_j)\\}_{j=1}^m$，数据带有加性噪声。定义加权最小二乘成本函数\n$$\nJ(\\theta) = \\sum_{j=1}^m \\left( \\frac{y_j - C_1 x_1(t_j;\\, k_{\\mathrm{el}}, k_{12}, k_{21})}{\\sigma} \\right)^2,\n$$\n其中 $\\sigma$ 是已知的噪声尺度，$x_1(t_j;\\, k_{\\mathrm{el}}, k_{12}, k_{21})$ 是通过对动力学系统进行数值积分得到的。\n\n考虑通过对讨厌参数 $[k_{12}, k_{21}, C_1]^\\top$ 进行约束优化，从而对目标参数 $k_{\\mathrm{el}}$ 进行参数剖析。对于一个固定的 $k_{\\mathrm{el}}$ 值，剖析成本定义为\n$$\nJ_{\\mathrm{prof}}(k_{\\mathrm{el}}) = \\min_{k_{12},\\,k_{21},\\,C_1} \\, J\\big([k_{\\mathrm{el}}, k_{12}, k_{21}, C_1]^\\top\\big)\n\\quad\n\\text{subject to}\n\\quad\nk_{12} \\ge 0, \\; k_{21} \\ge 0, \\; C_1 \\ge 0.\n$$\n沿剖析路径的讨厌参数的最小化器由优化器路径表示\n$$\n[k_{12}^\\star(k_{\\mathrm{el}}),\\,k_{21}^\\star(k_{\\mathrm{el}}),\\,C_1^\\star(k_{\\mathrm{el}})]^\\top\n\\quad \\text{such that} \\quad\nJ_{\\mathrm{prof}}(k_{\\mathrm{el}}) = J\\big([k_{\\mathrm{el}}, k_{12}^\\star(k_{\\mathrm{el}}), k_{21}^\\star(k_{\\mathrm{el}}), C_1^\\star(k_{\\mathrm{el}})]^\\top\\big).\n$$\n\n您的任务是实现一个数值程序，该程序能够：\n- 在指定区间上为 $k_{\\mathrm{el}}$ 构建一个网格值。\n- 对于每个网格值，求解约束优化问题以计算 $J_{\\mathrm{prof}}(k_{\\mathrm{el}})$，并记录相应的优化器路径 $[k_{12}^\\star(k_{\\mathrm{el}}), k_{21}^\\star(k_{\\mathrm{el}}), C_1^\\star(k_{\\mathrm{el}})]$。\n- 通过使用前一个网格点的优化器作为每次优化的种子来进行热启动，以平滑地跟踪整个网格上的优化器路径。\n- 选择使剖析 $J_{\\mathrm{prof}}(k_{\\mathrm{el}})$ 最小化的网格值 $k_{\\mathrm{el}}^\\star$。\n\n为以下三个测试用例实现此程序。在每个用例中，通过使用指定的 $\\theta_{\\text{true}}$ 对模型进行积分，并添加均值为零、标准差为 $\\sigma$ 的独立高斯噪声来生成合成数据。为保证可复现性，请使用固定的随机种子 $42$。所有用例中的剂量均为 $D=1$。\n\n测试用例1（理想情况）：\n- 真实参数：$\\theta_{\\text{true}} = [0.25, 0.40, 0.20, 1.00]^\\top$。\n- 采样时间：$t_j$ 在 $[0, 10]$ 内均匀分布，共 $m=21$ 个点。\n- 噪声尺度：$\\sigma = 0.02$。\n- 剖析网格：$k_{\\mathrm{el}} \\in [0.05, 0.60]$，包含 $21$ 个均匀间隔的点。\n- 讨厌参数的界限：$0.01 \\le k_{12} \\le 2.00$, $0.01 \\le k_{21} \\le 2.00$, $0.50 \\le C_1 \\le 1.50$。\n\n测试用例2（边界行为）：\n- 真实参数：$\\theta_{\\text{true}} = [0.01, 0.30, 0.50, 1.00]^\\top$。\n- 采样时间：$t_j$ 在 $[0, 5]$ 内均匀分布，共 $m=26$ 个点。\n- 噪声尺度：$\\sigma = 0.02$。\n- 剖析网格：$k_{\\mathrm{el}} \\in [0.01, 0.20]$，包含 $21$ 个均匀间隔的点。\n- 讨厌参数的界限：$0.05 \\le k_{12} \\le 2.00$, $0.05 \\le k_{21} \\le 2.00$, $0.80 \\le C_1 \\le 1.20$。\n\n测试用例3（稀疏和含噪数据，潜在的可辨识性问题）：\n- 真实参数：$\\theta_{\\text{true}} = [0.50, 0.30, 0.10, 1.00]^\\top$。\n- 采样时间：$t_j = [0, 1, 2, 3, 4]$，所以 $m=5$。\n- 噪声尺度：$\\sigma = 0.10$。\n- 剖析网格：$k_{\\mathrm{el}} \\in [0.10, 1.00]$，包含 $21$ 个均匀间隔的点。\n- 讨厌参数的界限：$0.01 \\le k_{12} \\le 2.00$, $0.01 \\le k_{21} \\le 2.00$, $0.50 \\le C_1 \\le 1.50$。\n\n您的程序必须：\n- 为每个测试用例生成合成数据。\n- 对于每个测试用例，使用约束优化和对讨厌参数的热启动路径跟踪，计算指定网格上的完整剖析 $J_{\\mathrm{prof}}(k_{\\mathrm{el}})$。\n- 为每个测试用例返回使剖析 $J_{\\mathrm{prof}}(k_{\\mathrm{el}})$ 最小化的网格值 $k_{\\mathrm{el}}^\\star$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”），其中每个结果是相应测试用例的最小化 $k_{\\mathrm{el}}^\\star$ 值，表示为浮点数。",
            "solution": "该问题已经过验证并被认为是有效的。这是一个适定的、具有科学依据的练习，涉及系统生物医学中一个常见房室模型的参数估计和可辨识性分析。所有必要的常数、方程和条件均已提供。\n\n问题的核心是为参数 $k_{\\mathrm{el}}$ 执行参数剖面似然分析。这涉及到在固定的 $k_{\\mathrm{el}}$ 值下，为讨厌参数重复求解一个约束优化问题。\n\n解决方案分为四个主要步骤：\n1. 推导常微分方程（ODE）系统的解析解，以实现高效计算。\n2. 构建数值优化问题，包括目标函数和热启动策略。\n3. 为每个测试用例生成指定的合成数据。\n4. 实现完整的剖析程序，为每个案例找到最优的 $k_{\\mathrm{el}}^\\star$。\n\n### 1. 动力系统的解析解\n\n状态动力学由一个线性常微分方程组给出：\n$$\n\\frac{d}{dt} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} -k_{\\mathrm{el}} - k_{12} & k_{21} \\\\ k_{12} & -k_{21} \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix}\n$$\n其形式为 $\\dot{x} = A x$，其中 $A$ 是一个 $2 \\times 2$ 的系统矩阵。解由 $x(t) = e^{At} x(0)$ 给出，其中 $x(0) = [D, 0]^\\top$。一个更直接的方法是使用 $A$ 的特征值和特征向量。特征方程为 $\\lambda^2 - \\mathrm{tr}(A)\\lambda + \\det(A) = 0$。\n\n$A$ 的迹和行列式是：\n$$\n\\mathrm{tr}(A) = -k_{\\mathrm{el}} - k_{12} - k_{21}\n$$\n$$\n\\det(A) = (-k_{\\mathrm{el}} - k_{12})(-k_{21}) - (k_{12})(k_{21}) = k_{\\mathrm{el}}k_{21} + k_{12}k_{21} - k_{12}k_{21} = k_{\\mathrm{el}}k_{21}\n$$\n特征值 $\\lambda_{1,2}$ 是特征多项式的根：\n$$\n\\lambda_{1,2} = \\frac{\\mathrm{tr}(A) \\pm \\sqrt{\\mathrm{tr}(A)^2 - 4\\det(A)}}{2} = \\frac{-(k_{\\mathrm{el}} + k_{12} + k_{21}) \\pm \\sqrt{(k_{\\mathrm{el}} + k_{12} + k_{21})^2 - 4k_{\\mathrm{el}}k_{21}}}{2}\n$$\n由于所有速率参数都是严格正的，判别式 $\\Delta = (k_{\\mathrm{el}} + k_{12} + k_{21})^2 - 4k_{\\mathrm{el}}k_{21} = (k_{\\mathrm{el}} + k_{12} - k_{21})^2 + 4k_{12}k_{21}$ 是严格正的。因此，特征值 $\\lambda_{1,2}$ 总是实数且不相等。此外，由于 $\\sqrt{\\Delta} < (k_{\\mathrm{el}} + k_{12} + k_{21})$，两个特征值都是严格负的，对应于一个稳定系统。\n\n$x_1(t)$ 的通解是两个指数项的和，$x_1(t) = A_1 e^{\\lambda_1 t} + A_2 e^{\\lambda_2 t}$。通过应用初始条件 $x_1(0)=D$ 和 $x_2(0)=0$（这意味着 $\\dot{x_1}(0) = -D(k_{\\mathrm{el}}+k_{12})$），我们可以求解这些系数。一个更系统的方法是使用特征向量来得到完整解。可以证明，第一房室的解 $x_1(t)$ 为：\n$$\nx_1(t; k_{\\mathrm{el}}, k_{12}, k_{21}) = \\frac{D}{\\lambda_1 - \\lambda_2} \\left[ (k_{21} + \\lambda_1) e^{\\lambda_1 t} - (k_{21} + \\lambda_2) e^{\\lambda_2 t} \\right]\n$$\n观测到的输出则为 $y(t) = C_1 x_1(t)$。在优化循环中使用此解析公式可以避免数值积分，从而显著提高计算效率和准确性。\n\n### 2. 数值优化和剖析\n\n对于指定网格中一个固定的 $k_{\\mathrm{el}}$ 值，我们必须找到最小化成本函数 $J$ 的讨厌参数 $\\psi = [k_{12}, k_{21}, C_1]^\\top$。成本函数为：\n$$\nJ(k_{\\mathrm{el}}, \\psi) = \\sum_{j=1}^m \\left( \\frac{y_j - y(t_j; k_{\\mathrm{el}}, \\psi)}{\\sigma} \\right)^2\n$$\n其中 $y(t_j; k_{\\mathrm{el}}, \\psi)$ 是模型预测值 $C_1 x_1(t_j; k_{\\mathrm{el}}, k_{12}, k_{21})$，而 $(t_j, y_j)$ 是合成数据点。\n\n这是一个带约束的非线性最小二乘问题。我们寻求：\n$$\n\\psi^\\star(k_{\\mathrm{el}}) = \\arg\\min_{\\psi} J(k_{\\mathrm{el}}, \\psi) \\quad \\text{subject to} \\quad \\psi_{lb} \\le \\psi \\le \\psi_{ub}\n$$\n其中 $\\psi_{lb}$ 和 $\\psi_{ub}$ 是每个测试用例中给出的讨厌参数的下界和上界。\n\n对网格中的每个 $k_{\\mathrm{el}}$ 执行此优化。`L-BFGS-B` 算法是 `scipy.optimize.minimize` 中可用的一种拟牛顿法，它非常适合此任务，因为它能有效处理箱式约束。\n\n该程序的一个关键部分是热启动策略。对于网格中的第一个 $k_{\\mathrm{el}}$ 值，优化使用一个中性猜测值进行初始化，例如 $\\psi$ 允许范围的中点。对于随后的每个 $k_{\\mathrm{el}}$ 值，优化使用为前一个 $k_{\\mathrm{el}}$ 值找到的最优 $\\psi^\\star$ 进行初始化。这种路径跟踪方法提高了收敛速度，并帮助优化器沿着局部最小值的连续路径前进，这是构建参数剖析的精髓所在。\n\n剖析成本是所获得的最小成本值的集合，$J_{\\mathrm{prof}}(k_{\\mathrm{el}}) = J(k_{\\mathrm{el}}, \\psi^\\star(k_{\\mathrm{el}}))$。最后一步是找到与 $J_{\\mathrm{prof}}(k_{\\mathrm{el}})$ 的最小值相对应的网格值 $k_{\\mathrm{el}}^\\star$。\n\n### 3. 合成数据生成\n\n对于每个测试用例，合成数据按以下方式生成：\n1. 使用提供的“真实”参数 $\\theta_{\\text{true}} = [k_{\\mathrm{el,true}}, k_{12,\\text{true}}, k_{21,\\text{true}}, C_{1,\\text{true}}]^\\top$ 求解模型，以获得无噪声输出 $y_{\\text{true}}(t_j) = C_{1,\\text{true}} x_1(t_j; \\theta_{\\text{true}})$。\n2. 将独立同分布的高斯噪声 $\\epsilon_j \\sim \\mathcal{N}(0, \\sigma^2)$ 添加到真实输出中。含噪数据为 $y_j = y_{\\text{true}}(t_j) + \\epsilon_j$。\n3. 为确保可复现性，使用固定值 $42$ 为随机数生成器设定种子。\n\n### 4. 实现总结\n\n整个算法在一个 Python 脚本中实现。\n- 一个主函数 `solve` 遍历三个测试用例。\n- 对于每个用例，使用一个以 $42$ 为种子的 `numpy.random.Generator` 来生成含噪数据。\n- 一个辅助函数 `solve_analytical` 实现了 $x_1(t)$ 的解析解，并返回模型输出 $y(t)$。\n- 创建了一个工厂函数 `make_cost_function` 来封装固定的数据、$k_{\\mathrm{el}}$ 值和其他常量，返回一个仅以讨厌参数 $\\psi$ 为变量的成本函数。\n- 一个循环遍历 $k_{\\mathrm{el}}$ 网格。在循环内部，调用 `scipy.optimize.minimize`，并使用 `L-BFGS-B` 方法、适当的界限和热启动初始猜测值。\n- 存储剖析循环的结果（最小成本）。\n- 使用 `numpy.argmin` 找到最小剖析成本的索引，从而确定最优网格点 $k_{\\mathrm{el}}^\\star$。\n- 收集三个案例中得到的 $k_{\\mathrm{el}}^\\star$，并按指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the parameter profiling for all test cases.\n    \"\"\"\n    \n    def solve_analytical(params, times, D):\n        \"\"\"\n        Calculates the model output using the analytical solution of the ODE.\n        \n        Args:\n            params (list or np.ndarray): vector of parameters [kel, k12, k21, C1].\n            times (np.ndarray): time points for evaluation.\n            D (float): initial dose in compartment 1.\n            \n        Returns:\n            np.ndarray: The predicted model output y(t).\n        \"\"\"\n        kel, k12, k21, C1 = params\n        \n        # Eigenvalue calculation\n        trace = -(kel + k12 + k21)\n        det = kel * k21\n        \n        # The discriminant is (kel + k12 - k21)^2 + 4*k12*k21, which is always > 0\n        # for strictly positive parameters, so eigenvalues are real and distinct.\n        sqrt_delta = np.sqrt(trace**2 - 4 * det)\n        \n        lambda1 = (trace + sqrt_delta) / 2.0\n        lambda2 = (trace - sqrt_delta) / 2.0\n        \n        if np.isclose(lambda1, lambda2):\n            # This case is theoretically not reached with positive params,\n            # but is a safeguard for numerical stability.\n            return np.full_like(times, np.inf)\n\n        # Coefficients from initial conditions x1(0)=D, x2(0)=0\n        # x1(t) = D/(l1-l2) * [ (k21+l1)exp(l1*t) - (k21+l2)exp(l2*t) ]\n        factor = D / (lambda1 - lambda2)\n        term1 = (k21 + lambda1) * np.exp(lambda1 * times)\n        term2 = (k21 + lambda2) * np.exp(lambda2 * times)\n        \n        x1_t = factor * (term1 - term2)\n        \n        return C1 * x1_t\n\n    def make_cost_function(fixed_kel, data_t, data_y, sigma, D):\n        \"\"\"\n        Factory function to create the cost function for a fixed kel.\n        The returned function takes only the nuisance parameters as input.\n        \"\"\"\n        def cost_function(nuisance_params):\n            k12, k21, C1 = nuisance_params\n            full_params = [fixed_kel, k12, k21, C1]\n            \n            y_model = solve_analytical(full_params, data_t, D)\n            \n            residuals = (data_y - y_model) / sigma\n            return np.sum(residuals**2)\n            \n        return cost_function\n\n    test_cases = [\n        {\n            \"theta_true\": [0.25, 0.40, 0.20, 1.00],\n            \"times\": np.linspace(0, 10, 21),\n            \"sigma\": 0.02,\n            \"kel_grid\": np.linspace(0.05, 0.60, 21),\n            \"bounds\": [(0.01, 2.00), (0.01, 2.00), (0.50, 1.50)],\n        },\n        {\n            \"theta_true\": [0.01, 0.30, 0.50, 1.00],\n            \"times\": np.linspace(0, 5, 26),\n            \"sigma\": 0.02,\n            \"kel_grid\": np.linspace(0.01, 0.20, 21),\n            \"bounds\": [(0.05, 2.00), (0.05, 2.00), (0.80, 1.20)],\n        },\n        {\n            \"theta_true\": [0.50, 0.30, 0.10, 1.00],\n            \"times\": np.array([0., 1., 2., 3., 4.]),\n            \"sigma\": 0.10,\n            \"kel_grid\": np.linspace(0.10, 1.00, 21),\n            \"bounds\": [(0.01, 2.00), (0.01, 2.00), (0.50, 1.50)],\n        }\n    ]\n\n    results = []\n    D_dose = 1.0  # Dose is 1 for all cases\n    \n    # Use a single RNG for all cases for consistency\n    rng = np.random.default_rng(42)\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        y_true = solve_analytical(case[\"theta_true\"], case[\"times\"], D_dose)\n        noise = rng.normal(loc=0.0, scale=case[\"sigma\"], size=len(case[\"times\"]))\n        y_data = y_true + noise\n\n        profile_costs = []\n        \n        # Warm-start initialization\n        # For the first point, use the midpoint of the bounds.\n        initial_guess = np.array([(b[0] + b[1]) / 2 for b in case[\"bounds\"]])\n        last_optimal_nuisance = initial_guess\n\n        # 2. Compute profile likelihood\n        for kel_val in case[\"kel_grid\"]:\n            # Create the cost function for the current k_el\n            cost_func = make_cost_function(kel_val, case[\"times\"], y_data, case[\"sigma\"], D_dose)\n            \n            # Solve the constrained optimization problem for nuisance parameters\n            res = minimize(\n                fun=cost_func,\n                x0=last_optimal_nuisance,\n                method='L-BFGS-B',\n                bounds=case[\"bounds\"],\n                options={'ftol': 1e-9, 'gtol': 1e-7} # Tighter tolerances for accuracy\n            )\n            \n            profile_costs.append(res.fun)\n            \n            # Update the guess for the next iteration (warm-start)\n            last_optimal_nuisance = res.x\n            \n        # 3. Find k_el that minimizes the profile\n        min_cost_idx = np.argmin(profile_costs)\n        best_kel = case[\"kel_grid\"][min_cost_idx]\n        results.append(best_kel)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}