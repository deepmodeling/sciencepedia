{
    "hands_on_practices": [
        {
            "introduction": "理解多个信号通路如何汇聚以调控基因表达是系统生物学的核心主题之一。本问题提供了一个定量建模的实践练习，其中转录输出由 Wnt、Notch 和 TGF-β 信号的乘法整合决定。通过应用希尔函数来模拟协同激活和药物抑制，你将学会计算达到预期系统水平响应所需的精确抑制剂浓度，这是药物研发和定量药理学中的一项基本技能。",
            "id": "4399612",
            "problem": "在一个简化的系统生物医学模型中，一个由无翅相关整合位点（Wnt）/$\\beta$-catenin、Notch和转化生长因子-$\\beta$（TGF-$\\beta$）信号联合调控的转录程序，其瞬时转录输出$R$被建模为三个协同激活函数的乘法整合。具体来说，假设启动子占据和转录起始遵循基于质量作用和协同结合的广泛使用的希尔函数形式，因此\n$$\nR \\;=\\; R_{\\max}\\, f_{B}\\, f_{N}\\, f_{S},\n$$\n其中 $R_{\\max}$ 是最大转录速率，对于通路 $j \\in \\{B,N,S\\}$，\n$$\nf_{j} \\;=\\; \\frac{x_{j}^{h_{j}}}{K_{j}^{h_{j}} + x_{j}^{h_{j}}}.\n$$\n在此，$x_{B}$ 表示核内$\\beta$-catenin活性，$x_{N}$ 表示Notch胞内域活性，$x_{S}$ 表示磷酸化Smad活性，$K_{j}$ 是半饱和常数，$h_{j}$ 是捕捉转录复合物组装协同性的希尔系数。\n\n药理学抑制剂通过一个抑制性希尔函数降低通路特异性活性，\n$$\nx_{j}(c_{j}) \\;=\\; x_{j,0}\\, g_{j}(c_{j}), \\qquad g_{j}(c_{j}) \\;=\\; \\frac{1}{1 + \\left(\\frac{c_{j}}{K_{I,j}}\\right)^{n_{j}}},\n$$\n其中 $c_{j}$ 是通路 $j$ 的抑制剂浓度，$K_{I,j}$ 是抑制剂效力常数，$n_{j}$ 是抑制性希尔系数，$x_{j,0}$ 是未受抑制的活性。假设对于所有三个通路，$x_{j,0} = K_{j}$。\n\n你使用固定浓度的Notch和TGF-$\\beta$抑制剂，$c_{N} = 0.5\\,\\mu\\mathrm{M}$ 和 $c_{S} = 0.2\\,\\mu\\mathrm{M}$，其中 $K_{I,N} = 1.0\\,\\mu\\mathrm{M}$，$n_{N} = 1$，$K_{I,S} = 0.2\\,\\mu\\mathrm{M}$，$n_{S} = 1$。对于Wnt/$\\beta$-catenin，参数为 $K_{I,B} = 0.5\\,\\mu\\mathrm{M}$ 和 $n_{B} = 2$，具有协同性启动子依赖性 $h_{B} = 2$，而 $h_{N} = 1$ 和 $h_{S} = 1$。\n\n确定为使总转录输出 $R$ 达到 $R_{\\max} \\times \\frac{1}{30}$ 所需的Wnt/$\\beta$-catenin抑制剂浓度 $c_{B}$（单位为微摩尔）。以微摩尔（$\\mu\\mathrm{M}$）表示你的最终 $c_{B}$ 值。将你的答案四舍五入到四位有效数字。",
            "solution": "题目要求计算Wnt/$\\beta$-catenin抑制剂的浓度 $c_{B}$，该浓度能使总转录输出 $R$ 等于最大可能速率 $R_{\\max}$ 的一个特定分数。\n\n转录输出 $R$ 由以下乘法模型给出：\n$$\nR = R_{\\max} f_{B} f_{N} f_{S}\n$$\n其中 $f_{j}$（对于 $j \\in \\{B, N, S\\}$）是通路 $j$ 对靶基因启动子的分数激活。目标条件是 $R = R_{\\max} \\times \\frac{1}{30}$。将此代入模型方程得到：\n$$\nR_{\\max} \\times \\frac{1}{30} = R_{\\max} f_{B} f_{N} f_{S}\n$$\n两边除以 $R_{\\max}$（假设其不为零），问题简化为找到满足以下条件的状况：\n$$\nf_{B} f_{N} f_{S} = \\frac{1}{30}\n$$\n每个通路 $j$ 的激活函数是其活性 $x_j$ 的希尔函数：\n$$\nf_{j} = \\frac{x_{j}^{h_{j}}}{K_{j}^{h_{j}} + x_{j}^{h_{j}}}\n$$\n活性 $x_j$ 由未受抑制的活性 $x_{j,0}$ 和浓度为 $c_j$ 的药物的抑制效应决定：\n$$\nx_{j}(c_{j}) = x_{j,0} g_{j}(c_{j})\n$$\n其中抑制函数 $g_{j}$ 由下式给出：\n$$\ng_{j}(c_{j}) = \\frac{1}{1 + \\left(\\frac{c_{j}}{K_{I,j}}\\right)^{n_{j}}}\n$$\n一个关键信息是假设每个通路的未受抑制活性等于其半饱和常数：$x_{j,0} = K_{j}$。我们可以将其代入 $x_j$ 的表达式中：\n$$\nx_{j} = K_{j} g_{j}(c_{j})\n$$\n现在，我们将这个 $x_j$ 的表达式代入激活函数 $f_j$ 中：\n$$\nf_{j} = \\frac{(K_{j} g_{j})^{h_{j}}}{K_{j}^{h_{j}} + (K_{j} g_{j})^{h_{j}}} = \\frac{K_{j}^{h_{j}} g_{j}^{h_{j}}}{K_{j}^{h_{j}}(1 + g_{j}^{h_{j}})} = \\frac{g_{j}^{h_{j}}}{1 + g_{j}^{h_{j}}}\n$$\n$f_j$ 和 $g_j$ 之间的这个简化关系是解决问题的关键。\n\n首先，我们计算来自Notch（$N$）和TGF-$\\beta$（$S$）通路的恒定贡献，因为它们的抑制剂浓度是固定的。\n\n对于Notch通路（$j=N$）：\n给定参数为 $c_{N} = 0.5\\,\\mu\\mathrm{M}$，$K_{I,N} = 1.0\\,\\mu\\mathrm{M}$，$n_{N} = 1$ 和 $h_{N} = 1$。抑制因子 $g_{N}$ 为：\n$$\ng_{N} = \\frac{1}{1 + \\left(\\frac{c_{N}}{K_{I,N}}\\right)^{n_{N}}} = \\frac{1}{1 + \\left(\\frac{0.5}{1.0}\\right)^{1}} = \\frac{1}{1 + 0.5} = \\frac{1}{1.5} = \\frac{2}{3}\n$$\n相应的激活 $f_{N}$ 为：\n$$\nf_{N} = \\frac{g_{N}^{h_{N}}}{1 + g_{N}^{h_{N}}} = \\frac{(2/3)^{1}}{1 + (2/3)^{1}} = \\frac{2/3}{5/3} = \\frac{2}{5}\n$$\n\n对于TGF-$\\beta$通路（$j=S$）：\n给定参数为 $c_{S} = 0.2\\,\\mu\\mathrm{M}$，$K_{I,S} = 0.2\\,\\mu\\mathrm{M}$，$n_{S} = 1$ 和 $h_{S} = 1$。抑制因子 $g_{S}$ 为：\n$$\ng_{S} = \\frac{1}{1 + \\left(\\frac{c_{S}}{K_{I,S}}\\right)^{n_{S}}} = \\frac{1}{1 + \\left(\\frac{0.2}{0.2}\\right)^{1}} = \\frac{1}{1 + 1} = \\frac{1}{2}\n$$\n相应的激活 $f_{S}$ 为：\n$$\nf_{S} = \\frac{g_{S}^{h_{S}}}{1 + g_{S}^{h_{S}}} = \\frac{(1/2)^{1}}{1 + (1/2)^{1}} = \\frac{1/2}{3/2} = \\frac{1}{3}\n$$\n\n现在我们可以将 $f_N$ 和 $f_S$ 的值代入我们的主方程，以求解Wnt/$\\beta$-catenin通路所需的激活 $f_B$：\n$$\nf_{B} \\left(\\frac{2}{5}\\right) \\left(\\frac{1}{3}\\right) = \\frac{1}{30}\n$$\n$$\nf_{B} \\left(\\frac{2}{15}\\right) = \\frac{1}{30}\n$$\n$$\nf_{B} = \\frac{1}{30} \\times \\frac{15}{2} = \\frac{15}{60} = \\frac{1}{4}\n$$\n接下来，我们必须找到能使 $f_B = 1/4$ 的抑制剂浓度 $c_B$。我们使用关系式 $f_B = \\frac{g_B^{h_B}}{1+g_B^{h_B}}$。Wnt/$\\beta$-catenin通路（$j=B$）的参数为 $h_B = 2$，$K_{I,B} = 0.5\\,\\mu\\mathrm{M}$ 和 $n_B = 2$。\n$$\n\\frac{1}{4} = \\frac{g_{B}^{2}}{1 + g_{B}^{2}}\n$$\n令 $y = g_{B}^{2}$。方程变为：\n$$\n\\frac{1}{4} = \\frac{y}{1 + y} \\implies 1 + y = 4y \\implies 3y = 1 \\implies y = \\frac{1}{3}\n$$\n所以，$g_{B}^{2} = 1/3$。由于 $g_B$ 必须为正（它是一个活性分数），我们取正平方根：\n$$\ng_{B} = \\sqrt{\\frac{1}{3}} = \\frac{1}{\\sqrt{3}}\n$$\n最后，我们使用 $g_B$ 的表达式来求解 $c_B$：\n$$\ng_{B} = \\frac{1}{1 + \\left(\\frac{c_{B}}{K_{I,B}}\\right)^{n_{B}}}\n$$\n代入已知值：\n$$\n\\frac{1}{\\sqrt{3}} = \\frac{1}{1 + \\left(\\frac{c_{B}}{0.5}\\right)^{2}}\n$$\n取两边的倒数：\n$$\n\\sqrt{3} = 1 + \\left(\\frac{c_{B}}{0.5}\\right)^{2}\n$$\n重新整理以求解包含 $c_B$ 的项：\n$$\n\\left(\\frac{c_{B}}{0.5}\\right)^{2} = \\sqrt{3} - 1\n$$\n对两边取平方根。由于浓度 $c_B$ 必须是非负实数，我们取正根：\n$$\n\\frac{c_{B}}{0.5} = \\sqrt{\\sqrt{3} - 1}\n$$\n求解 $c_B$：\n$$\nc_{B} = 0.5 \\times \\sqrt{\\sqrt{3} - 1}\n$$\n现在，我们计算数值。\n$$\nc_{B} = 0.5 \\times \\sqrt{1.7320508... - 1} = 0.5 \\times \\sqrt{0.7320508...}\n$$\n$$\nc_{B} = 0.5 \\times 0.8555996... = 0.4277998...\n$$\n题目要求答案四舍五入到四位有效数字。\n$$\nc_{B} \\approx 0.4278\n$$\n$c_B$ 的单位是微摩尔（$\\mu\\mathrm{M}$），与给定常数的单位一致。",
            "answer": "$$\\boxed{0.4278}$$"
        },
        {
            "introduction": "信号网络通常包含反馈回路，这些回路能产生复杂的动态行为，例如对发育过程至关重要的振荡。本练习从静态分析转向动态模拟，通过探索 Hes1 转录抑制因子的模型——Notch 信号通路中的一个关键组分。你将通过编程实现一个计算模型，亲眼见证一个时间延迟的负反馈回路如何能够产生持续的振荡——这一现象对体节发生等过程至关重要，并学会表征产生此类动态模式的条件。",
            "id": "4399622",
            "problem": "考虑一个 Notch 通路转录反馈的最小动力学系统模型，该模型捕捉了在 Notch 信号传导下 Hairy 和 Enhancer of Split 1 (Hes1) 的振荡。该模型平衡了由 Notch 细胞内结构域 (NICD) 和转化生长因子-β (TGF-β) 介导的转录激活与 Hes1 的自抑制。假设遵循分子生物学中心法则（DNA 到信使核糖核酸 (mRNA) 再到蛋白质）以及生产和降解的质量作用动力学。令 $M(t)$ 表示 Hes1 mRNA，$P(t)$ 表示 Hes1 蛋白，$R(t)$ 表示一个有效的抑制复合物（例如，蛋白质介导的启动子占据从而减少转录），所有浓度均以任意单位表示。时间 $t$ 以分钟为单位。\n\n使用以下经过充分检验的建模选择：\n- 转录被 NICD 和 TGF-β 乘性激活，并通过一个源自平衡结合的希尔函数被抑制物 $R(t)$ 所抑制：转录速率正比于 $\\nu \\big/ \\left(1 + R(t)^h\\right)$，其中 $\\nu = \\alpha_0 \\left(1 + \\sigma_N A_N\\right)\\left(1 + \\sigma_T A_T\\right)$，$\\alpha_0$ 是基础转录速率，$A_N$ 是无量纲的 Notch 激活水平，$A_T$ 是无量纲的 TGF-β 激活水平，$\\sigma_N$ 和 $\\sigma_T$ 是缩放系数，$h$ 是代表抑制协同性的希尔系数。所有速率常数均为非负。\n- 翻译和抑制物形成是线性的，每个物质的降解是一阶的。\n\n得到的 Goodwin 型系统为\n$$\n\\frac{dM}{dt} = \\frac{\\nu}{1 + R^h} - k_1 M,\\quad\n\\frac{dP}{dt} = k_s M - k_2 P,\\quad\n\\frac{dR}{dt} = k_p P - k_3 R,\n$$\n其中 $k_1$、$k_2$、$k_3$ 是降解速率（单位为 $\\text{min}^{-1}$），$k_s$ 和 $k_p$ 是生成速率常数（单位为 $\\text{min}^{-1}$），所有变量和参数均为非负。\n\n您的任务是编写一个完整的程序，对于下方测试套件中的每一组参数，该程序从小的正初始条件开始对系统进行积分，并判断系统是否在长时间范围内在 $P(t)$ 上表现出持续振荡。如果一个振荡在丢弃初始暂态后，$P(t)$ 轨迹的最后部分包含至少3个不同的局部最大值，并且其振幅（该部分的最高值减去最低值）超过一个小的阈值，则应将其归类为持续性振荡。如果这两个标准都满足，则该测试用例返回布尔值 True；否则返回 False。\n\n在所有模拟中，除非另有说明，否则请使用以下常量：初始条件 $M(0) = 0.1, P(0) = 0.1, R(0) = 0.1$，积分时程 $T_{\\text{end}} = 1000$ 分钟，并在评估振荡时丢弃前 $500$ 分钟的初始暂态。使用足够小的绝对容差和相对容差来解析动力学。速率必须以 $\\text{min}^{-1}$ 为单位处理。\n\n测试套件参数集，每组均指定为一个元组 $\\left(A_N, A_T, h, k_1, k_2, k_3, k_s, k_p, \\alpha_0, \\sigma_N, \\sigma_T\\right)$:\n- 案例 1 (理想振荡路径): $\\left(1.0,\\, 0.5,\\, 8.0,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n- 案例 2 (边界，低协同性): $\\left(1.0,\\, 0.5,\\, 3.0,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n- 案例 3 (边缘情况，快速降解): $\\left(1.0,\\, 0.5,\\, 8.0,\\, 0.08,\\, 0.08,\\, 0.08,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n- 案例 4 (强激活): $\\left(2.0,\\, 1.0,\\, 8.0,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.4,\\, 0.4,\\, 1.0,\\, 1.0,\\, 0.5\\right)$。\n\n您的程序应产生单行输出，其中包含四个案例的结果，格式为逗号分隔的列表并用方括号括起（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$），其中每个 $\\text{result}_i$ 是一个布尔值，根据上述标准指示是否存在持续振荡。不应产生任何额外输出。",
            "solution": "已对用户提供的问题陈述进行分析，并认定其有效。它在科学上基于生物化学动力学和系统生物学的原理，作为一个数值积分和分析任务，其提法是适定的，并且足够完整和客观，可以得到唯一的解。该模型是一个标准的 Goodwin 型振荡器，是遗传负反馈回路的经典表示。参数和初始条件都已明确指定。唯一微小的不明确之处在于振荡振幅的“小阈值”的定义。在本分析中，选择了一个物理上合理的阈值 $0.1$ 浓度单位，以区分持续振荡与数值噪声或向不动点的快速衰减。\n\n该问题要求对一个由三个耦合非线性常微分方程 (ODE) 组成的系统进行数值积分，该系统模拟了 Hes1 mRNA $M(t)$、Hes1 蛋白 $P(t)$ 和一个有效抑制复合物 $R(t)$ 的动力学。该系统由以下方程给出：\n$$\n\\frac{dM}{dt} = \\frac{\\nu}{1 + R^h} - k_1 M\n$$\n$$\n\\frac{dP}{dt} = k_s M - k_2 P\n$$\n$$\n\\frac{dR}{dt} = k_p P - k_3 R\n$$\n状态变量 $M$、$P$ 和 $R$ 代表浓度，是时间 $t$ 的函数。参数如下：$k_1$、$k_2$、$k_3$ 是一阶降解速率常数；$k_s$ 和 $k_p$ 是生成速率常数；$h$ 是抑制作用的希尔系数。$\\nu$ 项代表最大转录速率，受外部信号调节，定义为：\n$$\n\\nu = \\alpha_0 (1 + \\sigma_N A_N)(1 + \\sigma_T A_T)\n$$\n其中 $\\alpha_0$ 是基础转录速率，$A_N$ 和 $A_T$ 分别是 Notch 和 TGF-$\\beta$ 信号的无量纲激活水平，$\\sigma_N$ 和 $\\sigma_T$ 是相应的缩放系数。\n\n对于每组提供的参数集，求解方法包括以下步骤：\n1.  **参数设置**：从测试用例元组 $\\left(A_N, A_T, h, k_1, k_2, k_3, k_s, k_p, \\alpha_0, \\sigma_N, \\sigma_T\\right)$ 中分配参数，并计算复合参数 $\\nu$。\n2.  **数值积分**：从初始条件 $M(0) = 0.1$、$P(0) = 0.1$ 和 $R(0) = 0.1$ 开始，在时间区间 $t \\in [0, 1000]$ 分钟内对 ODE 系统进行数值积分。采用一个高质量的自适应步长求解器，特别是来自 SciPy 库的 `scipy.integrate.solve_ivp`。请求密集输出以获得状态变量的高分辨率时间序列，这对于准确识别局部极值至关重要。使用高精度的相对和绝对容差（例如，$10^{-9}$）来确保数值解的准确性。\n3.  **暂态丢弃**：根据问题说明，丢弃模拟的初始暂态阶段。仅对 $t \\in [500, 1000]$ 分钟的时间序列数据进行分析。这确保了将行为分类为振荡或稳定是基于系统的长期渐近动力学，而不是其初始响应。\n4.  **振荡检测**：在暂态后窗口（$t \\ge 500$）内，根据两个特定标准分析 Hes1 蛋白 $P(t)$ 的轨迹，以确定是否存在持续振荡。\n    *   **振幅标准**：振荡的振幅计算为分析窗口内 $P(t)$ 的最大值与最小值之差。此振幅必须超过一个预定义的阈值，该阈值设定为 $0.1$ 浓度单位。此标准确保观察到的波动是显著的，而不是围绕稳定稳态的数值误差所产生的假象。如果 $\\left( \\max_{t \\ge 500} P(t) - \\min_{t \\ge 500} P(t) \\right) > 0.1$，则此条件满足。\n    *   **峰值计数标准**：计算分析窗口内 $P(t)$ 轨迹中局部最大值（峰值）的数量。如果一个点 $P(t_i)$ 严格大于其紧邻的邻居，即 $P(t_{i-1})  P(t_i)$ 且 $P(t_i) > P(t_{i+1})$，则它被视为一个局部最大值。问题要求至少有 $3$ 个不同的局部最大值才能将行为归类为持续振荡。这确保了系统正在经历多个周期，而不仅仅是在稳定下来之前表现出单次过冲。\n5.  **分类**：对于每组参数集，最终输出是一个布尔值。当且仅当振幅标准和峰值计数标准都满足时，它为 `True`。否则，它为 `False`。所有四个测试用例的结果都汇编成一个列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Integrates the Hes1 oscillator model and detects sustained oscillations\n    for a suite of test case parameters.\n    \"\"\"\n    \n    # Define common constants for the simulation\n    y0 = np.array([0.1, 0.1, 0.1])  # Initial conditions [M(0), P(0), R(0)]\n    t_span = [0, 1000]             # Integration time horizon in minutes\n    transient_time = 500           # Time to discard for transient behavior\n    amp_threshold = 0.1            # Amplitude threshold for oscillation\n    min_peaks = 3                  # Minimum number of peaks for sustained oscillation\n\n    # Test suite parameter sets:\n    # (A_N, A_T, h, k_1, k_2, k_3, k_s, k_p, alpha_0, sigma_N, sigma_T)\n    test_cases = [\n        # Case 1: happy path oscillatory\n        (1.0, 0.5, 8.0, 0.02, 0.02, 0.02, 0.4, 0.4, 1.0, 1.0, 0.5),\n        # Case 2: boundary, low cooperativity\n        (1.0, 0.5, 3.0, 0.02, 0.02, 0.02, 0.4, 0.4, 1.0, 1.0, 0.5),\n        # Case 3: edge case, fast degradation\n        (1.0, 0.5, 8.0, 0.08, 0.08, 0.08, 0.4, 0.4, 1.0, 1.0, 0.5),\n        # Case 4: strong activation\n        (2.0, 1.0, 8.0, 0.02, 0.02, 0.02, 0.4, 0.4, 1.0, 1.0, 0.5),\n    ]\n\n    def hes1_model(t, y, nu, h, k1, k2, k3, ks, kp):\n        \"\"\"\n        Defines the ODE system for the Hes1 oscillator.\n        y = [M, P, R]\n        \"\"\"\n        M, P, R = y\n        dM_dt = nu / (1 + R**h) - k1 * M\n        dP_dt = ks * M - k2 * P\n        dR_dt = kp * P - k3 * R\n        return [dM_dt, dP_dt, dR_dt]\n\n    results = []\n    \n    # Generate time points for evaluation to ensure dense output\n    t_eval = np.linspace(t_span[0], t_span[1], 2000)\n\n    for case in test_cases:\n        A_N, A_T, h, k1, k2, k3, ks, kp, alpha_0, sigma_N, sigma_T = case\n        \n        # Calculate the composite transcription rate nu\n        nu = alpha_0 * (1 + sigma_N * A_N) * (1 + sigma_T * A_T)\n        \n        # Package arguments for the ODE solver\n        args = (nu, h, k1, k2, k3, ks, kp)\n        \n        # Integrate the ODE system\n        sol = solve_ivp(\n            hes1_model, \n            t_span, \n            y0, \n            method='RK45', \n            t_eval=t_eval, \n            args=args,\n            rtol=1e-9, \n            atol=1e-9\n        )\n        \n        # Extract time and P(t) solution\n        t_sol = sol.t\n        P_sol = sol.y[1]\n        \n        # Find the index where the analysis window starts\n        transient_idx = np.searchsorted(t_sol, transient_time, side='left')\n        \n        # Get the post-transient part of the P trajectory\n        P_analysis = P_sol[transient_idx:]\n        \n        is_oscillatory = False\n        if P_analysis.size > 2: # Need at least 3 points to find a peak\n            # 1. Amplitude criterion\n            amplitude = np.max(P_analysis) - np.min(P_analysis)\n            amplitude_criterion_met = amplitude > amp_threshold\n            \n            # 2. Peak count criterion\n            peak_count = 0\n            for i in range(1, len(P_analysis) - 1):\n                if P_analysis[i] > P_analysis[i-1] and P_analysis[i] > P_analysis[i+1]:\n                    peak_count += 1\n            peaks_criterion_met = peak_count >= min_peaks\n            \n            # Both criteria must be met\n            if amplitude_criterion_met and peaks_criterion_met:\n                is_oscillatory = True\n        \n        results.append(is_oscillatory)\n\n    # Format and print the final output exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "系统生物医学的一个主要挑战是从可观测的输出（如基因表达数据）推断内部细胞网络的活性。本练习通过引入一个强大的数据驱动推断框架来解决这个“逆问题”。你将使用贝叶斯原理，推导并实现一种方法，根据下游靶基因的表达水平来估计 Wnt、Notch 和 TGF-β 通路的未测量活性。这种被称为岭回归的实践，对于将高通量数据转化为关于细胞信号转导的机理见解至关重要。",
            "id": "4399635",
            "problem": "要求您对三种信号通路进行数据驱动的通路活性推断：Wnt/$\\beta$-catenin 信号通路、Notch 信号通路和转化生长因子-β (TGF-β) 信号通路。在系统生物医学中，根据小信号近似和稳态假设，下游靶基因的转录响应通常被建模为通路活性的线性叠加。形式上，假设 $n$ 个靶基因的测量表达向量（表示为 $\\mathbf{y} \\in \\mathbb{R}^n$）由以下公式生成：\n$$\n\\mathbf{y} = \\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{b} \\in \\mathbb{R}^n$ 是基线表达向量，$\\mathbf{S} \\in \\mathbb{R}^{n \\times p}$ 是一个已知的特征（灵敏度）矩阵，编码了每条通路对每个基因的影响，$\\mathbf{a} \\in \\mathbb{R}^p$ 是 $p$ 条通路的未知通路活性向量，而 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_n)$ 表示方差为 $\\sigma^2$ 的独立高斯测量噪声。假设通路活性集中在 $0$ 附近的先验信念由一个方差为 $\\tau^2$ 的零均值高斯先验 $\\mathbf{a} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_p)$ 建模。\n\n从分子生物学的中心法则和稳态附近基因调控响应的线性化出发，使用带有高斯似然和高斯先验的贝叶斯推断，推导出 $\\mathbf{a}$ 的最大后验 (MAP) 估计量，并以算法方式实现它，不依赖任何预先推导的快捷公式。推导过程必须从概率和优化的第一性原理出发。然后，对下面的每个测试用例，计算通路活性的 MAP 估计值。所有活性都是无量纲的，并且必须以浮点数形式报告，保留 $6$ 位小数。\n\n参数值测试套件：\n\n- 案例 1（良态，加性激活）：\n  - $n = 6$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.8  0.1  0.2 \\\\\n  0.6  0.2  0.1 \\\\\n  0.1  0.7  0.3 \\\\\n  0.2  0.6  0.4 \\\\\n  0.0  0.1  0.9 \\\\\n  0.3  0.2  0.8\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\\\0.0\\\\0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.99\\\\0.77\\\\0.66\\\\0.78\\\\0.68\\\\0.96\\end{bmatrix}$\n  - $\\sigma^2 = 0.01$, $\\tau^2 = 10.0$\n\n- 案例 2（Wnt/β-catenin 和 Notch 特征之间存在强共线性）：\n  - $n = 4$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.5  0.49  0.1 \\\\\n  0.4  0.41  0.2 \\\\\n  0.6  0.6  0.3 \\\\\n  0.55  0.54  0.2\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.812\\\\0.688\\\\1.02\\\\0.912\\end{bmatrix}$\n  - $\\sigma^2 = 0.1$, $\\tau^2 = 1.0$\n\n- 案例 3（特征中混合了激活和抑制）：\n  - $n = 5$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.7  -0.2  0.1 \\\\\n  0.2  0.5  -0.3 \\\\\n  -0.1  0.6  0.4 \\\\\n  0.3  -0.4  0.7 \\\\\n  -0.2  0.3  0.8\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\\\0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.43\\\\0.05\\\\0.54\\\\0.65\\\\0.72\\end{bmatrix}$\n  - $\\sigma^2 = 0.02$, $\\tau^2 = 2.0$\n\n- 案例 4（$n  p$ 的欠定系统）：\n  - $n = 2$, $p = 3$\n  - $\\mathbf{S} = \\begin{bmatrix}\n  0.5  0.2  0.3 \\\\\n  0.1  0.3  0.6\n  \\end{bmatrix}$\n  - $\\mathbf{b} = \\begin{bmatrix}0.0\\\\0.0\\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix}0.49\\\\0.55\\end{bmatrix}$\n  - $\\sigma^2 = 0.05$, $\\tau^2 = 0.5$\n\n您的程序必须为每个案例计算 MAP 估计值 $\\widehat{\\mathbf{a}}$，并以单行输出的形式返回结果，该输出包含一个列表的列表，其中每个内部列表对应一个案例，并按固定顺序 $[\\text{Wnt/}\\beta\\text{-catenin}, \\text{Notch}, \\text{TGF-}\\beta]$ 包含三种通路活性，每种活性都四舍五入到 $6$ 位小数。例如，输出格式应类似于 $\\left[[a_{11},a_{12},a_{13}],[a_{21},a_{22},a_{23}],\\ldots\\right]$，其中每个 $a_{ij}$ 都以浮点数形式打印，保留 $6$ 位小数。",
            "solution": "该问题是有效的。它在科学上基于系统生物医学的原理，特别是将基因表达建模为对信号通路活性的线性响应。该问题是适定的、客观的，并提供了推导和计算通路活性的最大后验 (MAP) 估计所需的所有信息。\n\n解决方案通过从贝叶斯推断的第一性原理推导 MAP 估计量来展开。观测到的基因表达向量 $\\mathbf{y} \\in \\mathbb{R}^n$ 的模型由下式给出：\n$$\n\\mathbf{y} = \\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon}\n$$\n其中 $\\mathbf{b} \\in \\mathbb{R}^n$ 是基线表达，$\\mathbf{S} \\in \\mathbb{R}^{n \\times p}$ 是特征矩阵，$\\mathbf{a} \\in \\mathbb{R}^p$ 是未知的通路活性向量，$\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^n$ 是测量噪声。我们已知噪声和通路活性的概率模型：\n$1$. 测量噪声服从独立高斯分布：$\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I}_n)$。\n$2$. 关于通路活性的先验信念是一个零均值高斯分布：$\\mathbf{a} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_p)$。\n\n我们的目标是找到 $\\mathbf{a}$ 的 MAP 估计，表示为 $\\widehat{\\mathbf{a}}_{\\text{MAP}}$，它是使后验概率密度 $p(\\mathbf{a} | \\mathbf{y})$ 最大化的 $\\mathbf{a}$ 的值。根据贝叶斯定理，后验概率与似然和先验的乘积成正比：\n$$\np(\\mathbf{a} | \\mathbf{y}) \\propto p(\\mathbf{y} | \\mathbf{a}) p(\\mathbf{a})\n$$\n最大化后验概率等价于最大化其对数，因为对数是单调递增函数。对数后验为：\n$$\n\\ln p(\\mathbf{a} | \\mathbf{y}) = \\ln p(\\mathbf{y} | \\mathbf{a}) + \\ln p(\\mathbf{a}) + \\text{constant}\n$$\n我们推导对数似然和对数先验的表达式。\n\n首先，我们定义似然 $p(\\mathbf{y} | \\mathbf{a})$。根据模型方程，对于给定的 $\\mathbf{a}$，观测向量 $\\mathbf{y}$ 是一个常数向量 $\\mathbf{b} + \\mathbf{S}\\mathbf{a}$ 和一个随机噪声向量 $\\boldsymbol{\\varepsilon}$ 的和。因此，$\\mathbf{y}$ 也是一个高斯随机向量。\n给定 $\\mathbf{a}$ 时 $\\mathbf{y}$ 的均值为 $E[\\mathbf{y} | \\mathbf{a}] = E[\\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon}] = \\mathbf{b} + \\mathbf{S}\\mathbf{a}$。\n给定 $\\mathbf{a}$ 时 $\\mathbf{y}$ 的协方差为 $\\text{Cov}(\\mathbf{y} | \\mathbf{a}) = \\text{Cov}(\\mathbf{b} + \\mathbf{S}\\mathbf{a} + \\boldsymbol{\\varepsilon}) = \\text{Cov}(\\boldsymbol{\\varepsilon}) = \\sigma^2 \\mathbf{I}_n$。\n因此，似然由多元高斯概率密度函数 (PDF) 给出：\n$$\np(\\mathbf{y} | \\mathbf{a}) = \\mathcal{N}(\\mathbf{y}; \\mathbf{b} + \\mathbf{S}\\mathbf{a}, \\sigma^2\\mathbf{I}_n) = \\frac{1}{(2\\pi\\sigma^2)^{n/2}} \\exp\\left(-\\frac{1}{2\\sigma^2} (\\mathbf{y} - (\\mathbf{b} + \\mathbf{S}\\mathbf{a}))^T (\\mathbf{y} - (\\mathbf{b} + \\mathbf{S}\\mathbf{a}))\\right)\n$$\n对数似然，忽略与 $\\mathbf{a}$ 无关的项，为：\n$$\n\\ln p(\\mathbf{y} | \\mathbf{a}) = -\\frac{1}{2\\sigma^2} \\|\\mathbf{y} - \\mathbf{b} - \\mathbf{S}\\mathbf{a}\\|_2^2 + \\text{constant}\n$$\n\n接下来，我们定义先验 $p(\\mathbf{a})$。我们已知 $\\mathbf{a} \\sim \\mathcal{N}(\\mathbf{0}, \\tau^2 \\mathbf{I}_p)$。其概率密度函数 (PDF) 为：\n$$\np(\\mathbf{a}) = \\mathcal{N}(\\mathbf{a}; \\mathbf{0}, \\tau^2\\mathbf{I}_p) = \\frac{1}{(2\\pi\\tau^2)^{p/2}} \\exp\\left(-\\frac{1}{2\\tau^2} \\mathbf{a}^T \\mathbf{a}\\right)\n$$\n对数先验，同样忽略常数项，为：\n$$\n\\ln p(\\mathbf{a}) = -\\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2 + \\text{constant}\n$$\n\n结合对数似然和对数先验，需要最大化的对数后验为：\n$$\n\\widehat{\\mathbf{a}}_{\\text{MAP}} = \\arg\\max_{\\mathbf{a}} \\left( -\\frac{1}{2\\sigma^2} \\|\\mathbf{y} - \\mathbf{b} - \\mathbf{S}\\mathbf{a}\\|_2^2 - \\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2 \\right)\n$$\n最大化此表达式等价于最小化其负值：\n$$\n\\widehat{\\mathbf{a}}_{\\text{MAP}} = \\arg\\min_{\\mathbf{a}} J(\\mathbf{a}) = \\arg\\min_{\\mathbf{a}} \\left( \\frac{1}{2\\sigma^2} \\|\\mathbf{y} - \\mathbf{b} - \\mathbf{S}\\mathbf{a}\\|_2^2 + \\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2 \\right)\n$$\n让我们定义一个修正的观测向量 $\\mathbf{y}' = \\mathbf{y} - \\mathbf{b}$。目标函数为：\n$$\nJ(\\mathbf{a}) = \\frac{1}{2\\sigma^2} \\|\\mathbf{y}' - \\mathbf{S}\\mathbf{a}\\|_2^2 + \\frac{1}{2\\tau^2} \\|\\mathbf{a}\\|_2^2\n$$\n为了找到最小值，我们计算 $J(\\mathbf{a})$ 相对于 $\\mathbf{a}$ 的梯度，并将其设为零向量。\n$$\n\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\nabla_{\\mathbf{a}} \\left[ \\frac{1}{2\\sigma^2} (\\mathbf{y}' - \\mathbf{S}\\mathbf{a})^T (\\mathbf{y}' - \\mathbf{S}\\mathbf{a}) + \\frac{1}{2\\tau^2} \\mathbf{a}^T \\mathbf{a} \\right]\n$$\n使用矩阵微积分恒等式 $\\nabla_{\\mathbf{x}} (\\mathbf{c} - \\mathbf{A}\\mathbf{x})^T(\\mathbf{c} - \\mathbf{A}\\mathbf{x}) = -2\\mathbf{A}^T(\\mathbf{c} - \\mathbf{A}\\mathbf{x})$ 和 $\\nabla_{\\mathbf{x}} (\\mathbf{x}^T\\mathbf{B}\\mathbf{x}) = 2\\mathbf{B}\\mathbf{x}$ 对于对称矩阵 $\\mathbf{B}$：\n$$\n\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\frac{1}{2\\sigma^2} (-2\\mathbf{S}^T(\\mathbf{y}' - \\mathbf{S}\\mathbf{a})) + \\frac{1}{2\\tau^2} (2\\mathbf{a}) = -\\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{y}' + \\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{S}\\mathbf{a} + \\frac{1}{\\tau^2} \\mathbf{a}\n$$\n将梯度设为 $\\mathbf{0}$：\n$$\n\\left(\\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{S} + \\frac{1}{\\tau^2} \\mathbf{I}_p\\right) \\mathbf{a} = \\frac{1}{\\sigma^2} \\mathbf{S}^T\\mathbf{y}'\n$$\n两边乘以 $\\sigma^2$ 得：\n$$\n\\left(\\mathbf{S}^T\\mathbf{S} + \\frac{\\sigma^2}{\\tau^2} \\mathbf{I}_p\\right) \\mathbf{a} = \\mathbf{S}^T\\mathbf{y}'\n$$\n矩阵 $\\mathbf{S}^T\\mathbf{S}$ 是半正定的。由于 $\\sigma^2 > 0$ 且 $\\tau^2 > 0$，比率 $\\lambda = \\sigma^2/\\tau^2 > 0$。因此，矩阵 $\\mathbf{S}^T\\mathbf{S} + \\lambda\\mathbf{I}_p$ 是正定的，因而是可逆的。这保证了 $\\mathbf{a}$ 有唯一解。我们求解 $\\mathbf{a}$ 得到 MAP 估计量：\n$$\n\\widehat{\\mathbf{a}}_{\\text{MAP}} = \\left(\\mathbf{S}^T\\mathbf{S} + \\frac{\\sigma^2}{\\tau^2} \\mathbf{I}_p\\right)^{-1} \\mathbf{S}^T (\\mathbf{y} - \\mathbf{b})\n$$\n这个结果也称为 Tikhonov 正则化最小二乘法或岭回归 (Ridge Regression)，其中正则化参数由噪声方差与先验方差的比值确定。该框架通过确保问题保持适定性，正确处理了所有提供的测试用例，包括病态（案例2）和欠定（案例4）场景。\n\n该算法通过为每个案例构建给定的参数矩阵和向量，并求解由此产生的线性方程组来实现。具体来说，我们求解线性系统 $A\\mathbf{x}=\\mathbf{v}$，其中 $A = \\mathbf{S}^T\\mathbf{S} + (\\sigma^2/\\tau^2)\\mathbf{I}_p$，$\\mathbf{x} = \\mathbf{a}$，以及 $\\mathbf{v} = \\mathbf{S}^T(\\mathbf{y} - \\mathbf{b})$。使用线性求解器比直接计算矩阵的逆在数值上更稳定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": np.array([\n                [0.8, 0.1, 0.2],\n                [0.6, 0.2, 0.1],\n                [0.1, 0.7, 0.3],\n                [0.2, 0.6, 0.4],\n                [0.0, 0.1, 0.9],\n                [0.3, 0.2, 0.8]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.99, 0.77, 0.66, 0.78, 0.68, 0.96]),\n            \"sigma_sq\": 0.01,\n            \"tau_sq\": 10.0\n        },\n        {\n            \"S\": np.array([\n                [0.5, 0.49, 0.1],\n                [0.4, 0.41, 0.2],\n                [0.6, 0.6, 0.3],\n                [0.55, 0.54, 0.2]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.812, 0.688, 1.02, 0.912]),\n            \"sigma_sq\": 0.1,\n            \"tau_sq\": 1.0\n        },\n        {\n            \"S\": np.array([\n                [0.7, -0.2, 0.1],\n                [0.2, 0.5, -0.3],\n                [-0.1, 0.6, 0.4],\n                [0.3, -0.4, 0.7],\n                [-0.2, 0.3, 0.8]\n            ]),\n            \"b\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"y\": np.array([0.43, 0.05, 0.54, 0.65, 0.72]),\n            \"sigma_sq\": 0.02,\n            \"tau_sq\": 2.0\n        },\n        {\n            \"S\": np.array([\n                [0.5, 0.2, 0.3],\n                [0.1, 0.3, 0.6]\n            ]),\n            \"b\": np.array([0.0, 0.0]),\n            \"y\": np.array([0.49, 0.55]),\n            \"sigma_sq\": 0.05,\n            \"tau_sq\": 0.5\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        S = case[\"S\"]\n        b = case[\"b\"]\n        y = case[\"y\"]\n        sigma_sq = case[\"sigma_sq\"]\n        tau_sq = case[\"tau_sq\"]\n\n        # Number of pathways (columns of S)\n        p = S.shape[1]\n\n        # Shift the observation vector by the baseline\n        y_prime = y - b\n        \n        # Calculate the regularization parameter lambda\n        lambda_reg = sigma_sq / tau_sq\n        \n        # Construct the matrix A = (S^T S + lambda * I)\n        A = S.T @ S + lambda_reg * np.identity(p)\n        \n        # Construct the vector v = S^T (y - b)\n        v = S.T @ y_prime\n        \n        # Solve the linear system A * a = v for a.\n        # This is more numerically stable than computing the inverse of A.\n        a_map = np.linalg.solve(A, v)\n        all_results.append(a_map)\n\n    # Format the final output string according to the problem specification.\n    # The result is a list of lists, with each number as a float rounded to 6 decimals.\n    result_str_parts = []\n    for a_map in all_results:\n        # Format each list of results to \"[val1,val2,...]\" with 6 decimal places\n        inner_list_str = f\"[{','.join([f'{x:.6f}' for x in a_map])}]\"\n        result_str_parts.append(inner_list_str)\n\n    final_output = f\"[{','.join(result_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}