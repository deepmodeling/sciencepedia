{"hands_on_practices": [{"introduction": "Implementing an asynchronous protocol requires translating its rules into a precise digital circuit. The first step in this process is often creating a finite-state machine (FSM) to capture the behavior. This exercise [@problem_id:1910555] will guide you through the fundamental task of converting a descriptive specification of a 4-phase handshake receiver into a formal state table, a cornerstone skill for digital logic design.", "problem": "In an asynchronous data transfer system, a receiver unit must coordinate with a sender using a handshake protocol. Consider a simple receiver implementing a 4-phase (also known as return-to-zero or RTZ) handshake protocol. The receiver's behavior is governed by a single input signal from the sender, `Req` (Request), and it produces a single output signal to the sender, `Ack` (Acknowledge).\n\nThe behavior of this receiver's sequential circuit can be described by a state diagram with two states: `S0` (Idle) and `S1` (Data Latched). The initial state of the system is `S0`. The state transitions and outputs are defined as follows:\n\n1.  In state `S0`, the `Ack` signal is held low (logic 0). The receiver remains in `S0` as long as `Req` is low (logic 0).\n2.  When the `Req` signal goes high (logic 1), the receiver transitions from state `S0` to state `S1`.\n3.  Upon entering state `S1`, the `Ack` signal is driven high (logic 1). The receiver remains in `S1` as long as `Req` is high.\n4.  When the `Req` signal returns to low (logic 0), the receiver transitions from state `S1` back to state `S0`, completing the handshake cycle.\n\nYour task is to create the corresponding state table for this Moore-type finite-state machine. A state table systematically lists the next state and the output for every possible combination of the present state and input.\n\nWhich of the following options correctly represents the state table for the described 4-phase handshake receiver?\n\n**A.**\n| Present State | Input `Req` | Next State | Output `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      1       |\n|      `S0`     |      1      |    `S1`    |      1       |\n|      `S1`     |      0      |    `S0`    |      0       |\n|      `S1`     |      1      |    `S1`    |      0       |\n\n**B.**\n| Present State | Input `Req` | Next State | Output `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S1`    |      0       |\n|      `S1`     |      0      |    `S0`    |      1       |\n|      `S1`     |      1      |    `S1`    |      1       |\n\n**C.**\n| Present State | Input `Req` | Next State | Output `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S1`    |      0       |\n|      `S0`     |      1      |    `S0`    |      0       |\n|      `S1`     |      0      |    `S1`    |      1       |\n|      `S1`     |      1      |    `S0`    |      1       |\n\n**D.**\n| Present State | Input `Req` | Next State | Output `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S0`    |      1       |\n|      `S1`     |      0      |    `S1`    |      0       |\n|      `S1`     |      1      |    `S1`    |      1       |", "solution": "A Moore finite-state machine has outputs determined solely by the present state. From the description: in state $S0$ the output $Ack$ is held low and in state $S1$ the output $Ack$ is held high. Therefore,\n$$Ack(S0)=0,\\quad Ack(S1)=1.$$\nThe state transitions are governed by the input $Req$ as follows: remain in $S0$ while $Req=0$ and go to $S1$ when $Req=1$; remain in $S1$ while $Req=1$ and go to $S0$ when $Req=0$. Therefore, the next-state function satisfies\n$$\\text{Next}(S0,Req=0)=S0,\\quad \\text{Next}(S0,Req=1)=S1,$$\n$$\\text{Next}(S1,Req=1)=S1,\\quad \\text{Next}(S1,Req=0)=S0.$$\nCombining these with the Moore outputs gives the four required rows:\n- Present $S0$, $Req=0$: Next $S0$, $Ack=0$.\n- Present $S0$, $Req=1$: Next $S1$, $Ack=0$.\n- Present $S1$, $Req=0$: Next $S0$, $Ack=1$.\n- Present $S1$, $Req=1$: Next $S1$, $Ack=1$.\nComparing with the provided options, only option B matches these next-state and output relations exactly.", "answer": "$$\\boxed{B}$$", "id": "1910555"}, {"introduction": "Beyond correct functionality, performance is a critical metric for any communication link. The speed of an asynchronous handshake is not governed by a clock but by the cumulative delays of its components. This practice problem [@problem_id:1910561] focuses on quantifying the performance of a 4-phase protocol by calculating the minimum transaction time, giving you a tangible understanding of how logic and wire delays dictate the overall data throughput.", "problem": "In the design of a modern System-on-Chip (SoC), a central processing unit (CPU) communicates with a specialized neural processing unit (NPU) to offload machine learning computations. The communication link between them uses an asynchronous 4-phase return-to-zero (RTZ) handshake protocol controlled by two signals: `VALID`, asserted by the CPU (sender) to indicate that data is available, and `READY`, asserted by the NPU (receiver) to acknowledge that the data has been read.\n\nA complete transaction cycle consists of four distinct signal transitions:\n1. The CPU asserts `VALID` high.\n2. The NPU responds by asserting `READY` high.\n3. The CPU sees `READY` is high and de-asserts `VALID` low.\n4. The NPU sees `VALID` is low and de-asserts `READY` low, returning the system to its initial state.\n\nThe timing characteristics of the link are determined by the following delays:\n- Sender logic delay (`t_sl`): The time required for the CPU's logic to process an input change and assert or de-assert the `VALID` signal is $120~\\text{ps}$.\n- Receiver logic delay (`t_rl`): The time required for the NPU's logic to process an input change and assert or de-assert the `READY` signal is $150~\\text{ps}$.\n- Interconnect propagation delay (`t_wire`): The time it takes for a signal change on either the `VALID` or `READY` line to travel along the wire from the CPU to the NPU (or vice versa) is $80~\\text{ps}$.\n\nCalculate the minimum total time required to complete one full data transaction. This time is measured from the moment the CPU initiates the transfer (starting the process of asserting `VALID`) until the system is fully reset to its initial state and ready to begin the next transaction. Express your final answer in nanoseconds (ns), rounded to two significant figures.", "solution": "We model the 4-phase handshake as a sequence of causally dependent events, each incurring logic delay at the driving end and propagation over the interconnect. Let $t_{sl}$ be the sender (CPU) logic delay, $t_{rl}$ the receiver (NPU) logic delay, and $t_{\\text{wire}}$ the interconnect propagation delay. The total transaction time is measured from when the CPU starts asserting $VALID$ until the CPU has observed $READY$ deasserted and both signals are back low.\n\nStep-by-step timing:\n1) CPU asserts $VALID$: CPU logic delay $t_{sl}$, then the $VALID$ edge propagates to NPU in $t_{\\text{wire}}$.\nCumulative time after step 1: $t_{sl} + t_{\\text{wire}}$.\n\n2) NPU asserts $READY$: NPU logic delay $t_{rl}$, then $READY$ edge propagates to CPU in $t_{\\text{wire}}$.\nAdditional time for step 2: $t_{rl} + t_{\\text{wire}}$.\nCumulative time after step 2: $t_{sl} + t_{\\text{wire}} + t_{rl} + t_{\\text{wire}}$.\n\n3) CPU deasserts $VALID$: upon seeing $READY$ high at CPU, CPU logic delay $t_{sl}$ to drive $VALID$ low, then $VALID$ low propagates to NPU in $t_{\\text{wire}}$.\nAdditional time for step 3: $t_{sl} + t_{\\text{wire}}$.\nCumulative time after step 3: $t_{sl} + t_{\\text{wire}} + t_{rl} + t_{\\text{wire}} + t_{sl} + t_{\\text{wire}}$.\n\n4) NPU deasserts $READY$: upon seeing $VALID$ low at NPU, NPU logic delay $t_{rl}$ to drive $READY$ low, then $READY$ low propagates to CPU in $t_{\\text{wire}}$ (ensuring the initiator sees the handshake complete and the system is ready for the next transaction).\nAdditional time for step 4: $t_{rl} + t_{\\text{wire}}$.\n\nTherefore, the minimum total time is\n$$\nT_{\\text{min}} \\;=\\; 2\\,t_{sl} \\;+\\; 2\\,t_{rl} \\;+\\; 4\\,t_{\\text{wire}}.\n$$\n\nSubstituting the given values (in picoseconds) and then converting to nanoseconds:\n$$\nT_{\\text{min}} \\;=\\; 2\\cdot 120 \\;+\\; 2\\cdot 150 \\;+\\; 4\\cdot 80 \\;=\\; 240 \\;+\\; 300 \\;+\\; 320 \\;=\\; 860~\\text{ps} \\;=\\; 0.86~\\text{ns}\n$$\nRounded to two significant figures, the result is $0.86~\\text{ns}$.", "answer": "$$\\boxed{0.86}$$", "id": "1910561"}, {"introduction": "A truly robust system must be able to handle not just ideal conditions, but also potential faults, such as an unresponsive communication partner. This advanced exercise [@problem_id:1910509] challenges you to move beyond basic protocol implementation and design a sender-side FSM that includes a vital timeout mechanism. Successfully completing this task demonstrates your ability to integrate protocol logic with essential error-handling features, a key aspect of real-world system design.", "problem": "In the avionics system of a deep-space probe, a central processor needs to communicate with a specialized Cryogenic Sensor Interface Unit (CSIU). The communication follows a 4-phase asynchronous handshake protocol. To ensure system reliability in case the CSIU becomes unresponsive, a timeout mechanism is required.\n\nYou are tasked with designing the sender-side Mealy-type Finite State Machine (FSM) that controls this data transfer. The FSM has the following inputs and outputs:\n\n**Inputs:**\n*   `Go`: A single-bit signal from the central processor. A transition from 0 to 1 initiates a data transfer request. The signal remains 1 for the duration of the transaction.\n*   `Ack`: A single-bit Acknowledgment signal from the CSIU.\n*   `Timeout`: A single-bit signal from an external timer. It asserts to 1 if `Ack` is not asserted within a predefined duration after a request is made. It is guaranteed that `Timeout` will not be 1 if `Ack` is 1.\n\n**Outputs:**\n*   `Req`: A single-bit Request signal sent to the CSIU.\n*   `DataValid`: A single-bit signal indicating that the data on the bus (not explicitly modeled here) is valid. For this protocol, `DataValid` is asserted and de-asserted along with `Req`.\n*   `Error`: A single-bit signal to flag a timeout event to the central processor.\n*   `StartTimer`: A single-bit pulse output to start the external timer. It is asserted for a single state transition.\n\nThe FSM operates through four defined states:\n*   `S0` (Idle): The initial state, waiting for the `Go` signal.\n*   `S1` (Wait for Ack): The request has been sent, and the FSM is waiting for the `Ack` signal or a `Timeout`.\n*   `S2` (Handshake Finish): `Ack` has been received, and the FSM is waiting for the CSIU to de-assert `Ack` to complete the 4-phase cycle.\n*   `S3` (Error): A timeout has occurred. The FSM holds in this state, asserting the `Error` signal until reset by the processor.\n\nA state transition is described by the notation: `CurrentState, (Go, Ack, Timeout) -> NextState, (Req, DataValid, Error, StartTimer)`, where `X` denotes a don't-care condition.\n\nWhich of the following options correctly describes a complete and valid set of transition rules for this FSM?\n\nA.\n1. `S1, (X, 1, 0) -> S2, (0, 0, 0, 0)`\n2. `S1, (X, 0, 1) -> S3, (0, 0, 1, 0)`\n3. `S2, (0, 0, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S1, (1, 1, 0, 1)`\n\nB.\n1. `S1, (X, 1, 0) -> S2, (1, 1, 0, 0)`\n2. `S1, (X, 0, 1) -> S3, (0, 0, 0, 0)`\n3. `S2, (0, 0, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S1, (1, 1, 0, 0)`\n\nC.\n1. `S1, (X, 1, 0) -> S0, (0, 0, 0, 0)`\n2. `S1, (X, 0, 1) -> S0, (0, 0, 1, 0)`\n3. `S2, (0, 0, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S2, (1, 1, 0, 1)`\n\nD.\n1. `S1, (X, 1, 0) -> S2, (0, 0, 0, 0)`\n2. `S1, (X, 0, 0) -> S3, (0, 0, 1, 0)`\n3. `S2, (1, 1, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S1, (1, 1, 0, 1)`", "solution": "We first restate the required 4-phase sender-side behavior. In a return-to-zero handshake, the sender asserts Req (and with it DataValid) to request service, waits for Ack from the receiver, then upon seeing Ack asserted, the sender de-asserts Req (and DataValid), and finally waits for the receiver to de-assert Ack to complete the cycle. A timeout protection must take the system to an error state if Ack does not arrive in due time. The StartTimer output must be a single-transition pulse that starts the external timer exactly when a new request is issued.\n\nFrom this, the necessary Mealy-type transitions and outputs at the sender are:\n1) In S1 (Wait for Ack): if Ack becomes 1 (with Timeout guaranteed 0 when Ack is 1), the sender must move to S2 (Handshake Finish) and immediately de-assert Req and DataValid to perform the return-to-zero step after the receiverâ€™s Ack. Error must be 0, and StartTimer must be 0. This requires S1, (X, 1, 0) -> S2, (0, 0, 0, 0).\n2) In S1: if Timeout becomes 1 while Ack is still 0, the sender must go to S3 (Error), assert Error, and de-assert Req and DataValid. StartTimer must be 0. This requires S1, (X, 0, 1) -> S3, (0, 0, 1, 0).\n3) In S2 (Handshake Finish): when Ack de-asserts to 0, there are two subcases. If Go is 0 (no new request), the sender returns to idle S0 with all outputs de-asserted. This requires S2, (0, 0, 0) -> S0, (0, 0, 0, 0).\n4) In S2: when Ack de-asserts to 0 and Go is 1 (a new request is desired immediately), the sender must immediately start a new transaction by asserting Req and DataValid, emitting a single StartTimer pulse, and moving back to S1 to wait for the next Ack. This requires S2, (1, 0, 0) -> S1, (1, 1, 0, 1).\n\nNow compare to the options:\n- Option A has exactly these four transitions and outputs:\n  1. S1, (X, 1, 0) -> S2, (0, 0, 0, 0): correct de-assertion of Req/DataValid upon Ack.\n  2. S1, (X, 0, 1) -> S3, (0, 0, 1, 0): correct timeout to error.\n  3. S2, (0, 0, 0) -> S0, (0, 0, 0, 0): correct completion to idle when Go is 0.\n  4. S2, (1, 0, 0) -> S1, (1, 1, 0, 1): correct immediate restart with StartTimer pulse.\n- Option B is incorrect because it keeps Req and DataValid asserted after Ack (rule 1), fails to assert Error on timeout (rule 2), and omits the StartTimer pulse on immediate restart (rule 4).\n- Option C is incorrect because it jumps from S1 to S0 instead of to S2 on Ack and timeout (rules 1 and 2), and it incorrectly stays in S2 while issuing a new request (rule 4).\n- Option D is incorrect because it signals error without Timeout (rule 2) and incorrectly transitions from S2 to S0 while Ack is still 1 (rule 3), violating the 4-phase completion requirement.\n\nTherefore, only option A correctly and completely matches the required transitions and outputs for the specified sender-side FSM with timeout.", "answer": "$$\\boxed{A}$$", "id": "1910509"}]}