{"hands_on_practices": [{"introduction": "The greatest challenge in asynchronous FIFO design is safely passing pointer values across clock domains. This practice demonstrates the core principle of using Gray codes, a special binary system where only one bit changes between consecutive values, which fundamentally prevents data corruption during synchronization [@problem_id:1910272]. You will perform a basic but essential conversion from a standard binary pointer to its Gray code equivalent.", "problem": "In digital systems, an asynchronous First-In First-Out (FIFO) buffer is a crucial component for reliably transferring data between two modules that operate with different, unrelated clocks (a situation known as crossing clock domains). To keep track of where to write data and where to read from, the FIFO uses internal counters called a write pointer and a read pointer, which index the memory locations within the buffer.\n\nA major design challenge in asynchronous FIFOs is safely passing the value of a pointer from one clock domain to the other for synchronization and status flag generation (e.g., full or empty signals). If a standard binary counter is used for the pointers, multiple bits can change simultaneously when the counter increments (for example, transitioning from binary `011` to `100`). If the receiving clock samples the pointer during this multi-bit transition, it might capture a meaningless intermediate value, leading to a catastrophic system failure.\n\nTo prevent this issue, pointers in asynchronous FIFOs are almost always implemented using Gray code, a binary numeral system where any two successive values differ in only one bit. This single-bit change property ensures that even if the pointer is sampled during a transition, the received value will be either the old value or the new value, both of which are valid states.\n\nConsider an 8-word deep asynchronous FIFO, which requires a 3-bit pointer to address its memory locations. At a certain moment, the binary value of the write pointer is `101`. To safely transfer this pointer value to the read clock domain, it must first be converted to its Gray code equivalent.\n\nWhich of the following represents the correct 3-bit Gray code for the binary pointer value `101`?\n\nA. 111\n\nB. 101\n\nC. 110\n\nD. 010", "solution": "To convert a binary value to Gray code, use the bitwise relation between the binary bits $b_{2}, b_{1}, b_{0}$ (with $b_{2}$ the most significant bit) and the Gray code bits $g_{2}, g_{1}, g_{0}$:\n$$\ng_{2} = b_{2}, \\quad g_{1} = b_{2} \\oplus b_{1}, \\quad g_{0} = b_{1} \\oplus b_{0},\n$$\nwhere $\\oplus$ denotes the XOR operation.\n\nGiven the binary pointer $b_{2}b_{1}b_{0} = 101$, we have $b_{2} = 1$, $b_{1} = 0$, and $b_{0} = 1$. Compute each Gray bit:\n$$\ng_{2} = 1, \\quad g_{1} = 1 \\oplus 0 = 1, \\quad g_{0} = 0 \\oplus 1 = 1.\n$$\nThus, the 3-bit Gray code is $111$, which corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1910272"}, {"introduction": "After understanding the 'what' and 'why' of Gray codes, the next step is implementation. This exercise guides you through deriving the combinational logic for a binary-to-Gray code converter [@problem_id:1910274]. This is not just a theoretical task; it represents a fundamental hardware block required in nearly every asynchronous FIFO design.", "problem": "In digital systems, an asynchronous First-In First-Out (FIFO) buffer is often used to safely transfer data between circuits operating on different, unsynchronized clocks. To manage the read and write operations, the FIFO uses pointers which are addresses into its memory array. When these pointers are passed from one clock domain to another to check for full or empty conditions, synchronization errors can occur if multiple bits of the pointer value change simultaneously.\n\nTo mitigate this issue, pointers are often implemented using Gray code, a binary numeral system where two successive values differ in only one bit. In a typical design, a standard binary counter, which is simple to implement, generates the address sequence. A combinational logic circuit is then required to convert the binary counter's output to Gray code before the pointer value is used for cross-domain comparisons.\n\nConsider a small asynchronous FIFO that requires a 2-bit address pointer. The binary output from the counter is denoted as $B_1 B_0$, where $B_1$ is the most significant bit. The corresponding 2-bit Gray code output required is denoted as $G_1 G_0$, where $G_1$ is the most significant bit.\n\nWhich of the following represents the correct set of Boolean expressions for the Gray code outputs $G_1$ and $G_0$ in terms of the binary inputs $B_1$ and $B_0$? In the options below, the symbol $\\oplus$ represents the exclusive-OR (XOR) operation, and $+$ represents the logical OR operation.\n\nA) $G_1 = B_1$; $G_0 = B_1 \\oplus B_0$\n\nB) $G_1 = B_1 \\oplus B_0$; $G_0 = B_0$\n\nC) $G_1 = B_1$; $G_0 = B_1 + B_0$\n\nD) $G_1 = B_1$; $G_0 = (B_1 \\oplus B_0)'$\n\nE) $G_1 = B_1 \\oplus B_0$; $G_0 = B_1$", "solution": "We seek Boolean expressions mapping a 2-bit binary count $B_{1}B_{0}$ to the corresponding 2-bit Gray code $G_{1}G_{0}$, where successive Gray values differ in exactly one bit. The standard binary-to-Gray conversion for an $n$-bit word $B_{n-1}\\ldots B_{1}B_{0}$ is:\n$$\nG_{n-1} = B_{n-1}, \\quad G_{i} = B_{i+1} \\oplus B_{i} \\text{ for } i = 0,1,\\ldots,n-2.\n$$\nFor the 2-bit case ($n=2$), substituting $i=0$ yields:\n$$\nG_{1} = B_{1}, \\quad G_{0} = B_{1} \\oplus B_{0}.\n$$\nTo verify that this mapping yields Gray code (one-bit transitions) over the binary count sequence $00 \\to 01 \\to 10 \\to 11$:\n- For $B_{1}B_{0} = 00$: $G_{1} = 0$, $G_{0} = 0 \\oplus 0 = 0$, hence $G = 00$.\n- For $B_{1}B_{0} = 01$: $G_{1} = 0$, $G_{0} = 0 \\oplus 1 = 1$, hence $G = 01$.\n- For $B_{1}B_{0} = 10$: $G_{1} = 1$, $G_{0} = 1 \\oplus 0 = 1$, hence $G = 11$.\n- For $B_{1}B_{0} = 11$: $G_{1} = 1$, $G_{0} = 1 \\oplus 1 = 0$, hence $G = 10$.\nThe sequence $00 \\to 01 \\to 11 \\to 10$ changes only one bit at each step, confirming correctness.\n\nComparing with the options, this corresponds to:\n$$\nG_{1} = B_{1}, \\quad G_{0} = B_{1} \\oplus B_{0},\n$$\nwhich is option A.", "answer": "$$\\boxed{A}$$", "id": "1910274"}, {"introduction": "This final practice integrates pointer logic into the FIFO's control system. You will explore a robust, industry-standard technique for generating the 'full' signal by comparing pointers of extended width, which elegantly distinguishes between full and empty states [@problem_id:1910302]. You will then use this status to create the final write enable signal, completing a critical piece of the FIFO's control path.", "problem": "You are a junior digital logic designer tasked with creating a portion of the control logic for an asynchronous First-In First-Out (FIFO) buffer. The FIFO has a storage depth of $D=2^N$ data words.\n\nTo correctly manage the buffer's state and prevent overflow or underflow across different clock domains, the FIFO uses $(N+1)$-bit binary pointers: a write pointer `wr_ptr` and a read pointer `rd_ptr`. These pointers range from $0$ to $2^{N+1}-1$.\n\nWithin the write clock domain, you are provided with the following signals:\n- `wr_req`: An active-high signal. When `wr_req` is logic '1', there is an external request to write data into the FIFO.\n- `wr_ptr[(N):0]`: The current $(N+1)$-bit write pointer.\n- `rd_ptr_sync[(N):0]`: The $(N+1)$-bit read pointer, which has been safely synchronized from the read clock domain into the write clock domain.\n\nThe status of the FIFO is determined by comparing `wr_ptr` and `rd_ptr_sync` according to the following rules:\n- **Full Condition**: The FIFO is considered full when the most significant bit (MSB), which is bit $N$, of the pointers are different, but all the lower $N$ bits (from bit $N-1$ down to $0$) are identical.\n- **Empty Condition**: The FIFO is considered empty when the write pointer and the synchronized read pointer are identical (`wr_ptr == rd_ptr_sync`).\n\nYour task is to derive the logic for the internal write enable signal, `wr_en`. `wr_en` should be asserted (logic '1') if and only if an external write is requested (`wr_req` is '1') AND the FIFO is not full.\n\nDerive a simplified Boolean expression for `wr_en` in terms of `wr_req` and the individual bits of the pointers `wr_ptr` and `rd_ptr_sync`.", "solution": "Let $\\mathrm{wr\\_ptr}_{i}$ and $\\mathrm{rd\\_ptr\\_sync}_{i}$ denote bit $i$ of the write and synchronized read pointers, respectively, with $i \\in \\{0,1,\\ldots,N\\}$ and $i=N$ the MSB. By the stated rules:\n- Full condition:\n$$\n\\text{FULL}=\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\land \\bigwedge_{i=0}^{N-1}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n- Empty condition:\n$$\n\\text{EMPTY}=\\bigwedge_{i=0}^{N}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\nThe internal write enable must assert if and only if an external write is requested and the FIFO is not full, so\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land \\lnot(\\text{FULL}).\n$$\nApplying De Morganâ€™s law to $\\lnot(\\text{FULL})$ gives\n$$\n\\lnot(\\text{FULL})=\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\nTherefore,\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right).\n$$\nThis expression states that a write is enabled when a write is requested and either the MSBs are equal or at least one of the lower $N$ bits differs, which is exactly the negation of the full condition.", "answer": "$$\\boxed{\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right)}$$", "id": "1910302"}]}