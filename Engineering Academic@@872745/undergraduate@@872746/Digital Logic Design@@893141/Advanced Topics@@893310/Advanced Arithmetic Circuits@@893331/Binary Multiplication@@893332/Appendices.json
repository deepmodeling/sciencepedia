{"hands_on_practices": [{"introduction": "To truly grasp binary multiplication, we must start with its hardware foundation. The array multiplier is a direct implementation of the pencil-and-paper method, where the first step is to generate all the partial products. This exercise [@problem_id:1914114] provides a concrete way to quantify the basic hardware cost—in terms of simple logic gates—required for this crucial initial stage.", "problem": "A team of digital logic designers is creating a specialized co-processor for a real-time Digital Signal Processing (DSP) application. A key component of this co-processor is a dedicated hardware multiplier designed to perform multiplication of two unsigned binary numbers. The architecture specifies that the first operand (the multiplicand) is a 7-bit number, and the second operand (the multiplier) is a 5-bit number.\n\nThe multiplication process is implemented using the standard array multiplier method. In the first stage of this process, a set of partial products is generated. Each partial product is formed by the logical AND operation between one bit of the multiplier and all the bits of the multiplicand. These partial products are then fed into an array of adders in the subsequent stage.\n\nAssuming the hardware for generating these partial products is constructed exclusively from two-input AND gates, calculate the total number of two-input AND gates required for this partial product generation stage.", "solution": "Let the multiplicand have $m$ bits and the multiplier have $n$ bits. For a standard array multiplier, the partial product bits are generated by ANDing each bit of the multiplicand with each bit of the multiplier. If $a_{i}$ denotes the $i$th bit of the multiplicand for $i \\in \\{0,\\dots,m-1\\}$ and $b_{j}$ denotes the $j$th bit of the multiplier for $j \\in \\{0,\\dots,n-1\\}$, then each partial product bit is\n$$\np_{i,j} = a_{i} \\land b_{j},\n$$\nwhich is implemented by one two-input AND gate.\n\nTherefore, the total number of two-input AND gates required equals the total number of such $(i,j)$ pairs, which is the size of the Cartesian product of the $m$ multiplicand bits and $n$ multiplier bits:\n$$\n\\sum_{j=0}^{n-1}\\sum_{i=0}^{m-1} 1 = m \\times n.\n$$\nSubstituting $m=7$ and $n=5$ gives\n$$\n7 \\times 5 = 35.\n$$\nHence, the partial product generation stage requires $35$ two-input AND gates.", "answer": "$$\\boxed{35}$$", "id": "1914114"}, {"introduction": "Digital circuits in the real world are not always perfect; manufacturing defects can lead to faults that alter their behavior. This next practice [@problem_id:1914169] moves us from an ideal circuit diagram to a practical scenario involving a 'stuck-at-0' fault in one of the AND gates generating a partial product. By determining when the faulty multiplier still produces the correct answer, you will develop a deeper understanding of how each partial product contributes to the final result and the principles of fault masking.", "problem": "A standard $2 \\times 2$ unsigned binary array multiplier is designed to compute the product $P = A \\times B$. The inputs are two 2-bit unsigned numbers, $A$ represented by bits $a_1a_0$ (where its value is $2a_1 + a_0$) and $B$ represented by bits $b_1b_0$ (where its value is $2b_1 + b_0$). The product is a 4-bit number $P = p_3p_2p_1p_0$. The logic for this multiplication can be expressed as the weighted sum of partial products: $A \\times B = (a_1b_1) \\cdot 2^2 + (a_1b_0 + a_0b_1) \\cdot 2^1 + (a_0b_0) \\cdot 2^0$. In the physical circuit, each term $a_i b_j$ is generated by an AND gate.\n\nDuring post-fabrication testing, it is discovered that one of the AND gates has a \"stuck-at-0\" fault. Specifically, the gate that is supposed to compute the partial product term $a_0b_1$ always outputs a 0, regardless of the actual values of its inputs $a_0$ and $b_1$.\n\nFrom the list of input pairs $(A, B)$ below, identify all pairs for which this faulty multiplier still produces the correct final product. Note that all inputs are given in their decimal representation, and you should only consider pairs where neither $A$ nor $B$ is zero.\n\nA. $A=2, B=3$\n\nB. $A=3, B=2$\n\nC. $A=1, B=2$\n\nD. $A=3, B=1$\n\nE. $A=3, B=3$", "solution": "Let $A=2a_{1}+a_{0}$ and $B=2b_{1}+b_{0}$ with $a_{i},b_{j}\\in\\{0,1\\}$. The correct product is\n$$\nP_{\\text{true}}=(a_{1}b_{1})\\cdot 2^{2}+(a_{1}b_{0}+a_{0}b_{1})\\cdot 2^{1}+(a_{0}b_{0})\\cdot 2^{0}.\n$$\nWith the stuck-at-0 fault on the $a_{0}b_{1}$ AND gate, the implemented product is\n$$\nP_{\\text{faulty}}=(a_{1}b_{1})\\cdot 2^{2}+(a_{1}b_{0}+0)\\cdot 2^{1}+(a_{0}b_{0})\\cdot 2^{0}.\n$$\nTherefore the error is\n$$\nP_{\\text{true}}-P_{\\text{faulty}}=(a_{0}b_{1})\\cdot 2^{1}.\n$$\nHence the faulty multiplier produces the correct product if and only if $a_{0}b_{1}=0$.\n\nEncode each decimal input into bits:\n- $1\\equiv 01$ so $(a_{1},a_{0})=(0,1)$ or $(b_{1},b_{0})=(0,1)$.\n- $2\\equiv 10$ so $(a_{1},a_{0})=(1,0)$ or $(b_{1},b_{0})=(1,0)$.\n- $3\\equiv 11$ so $(a_{1},a_{0})=(1,1)$ or $(b_{1},b_{0})=(1,1)$.\n\nCheck each option by evaluating $a_{0}b_{1}$:\n- A: $A=2\\Rightarrow a_{0}=0$, $B=3\\Rightarrow b_{1}=1$, so $a_{0}b_{1}=0$; correct.\n- B: $A=3\\Rightarrow a_{0}=1$, $B=2\\Rightarrow b_{1}=1$, so $a_{0}b_{1}=1$; incorrect.\n- C: $A=1\\Rightarrow a_{0}=1$, $B=2\\Rightarrow b_{1}=1$, so $a_{0}b_{1}=1$; incorrect.\n- D: $A=3\\Rightarrow a_{0}=1$, $B=1\\Rightarrow b_{1}=0$, so $a_{0}b_{1}=0$; correct.\n- E: $A=3\\Rightarrow a_{0}=1$, $B=3\\Rightarrow b_{1}=1$, so $a_{0}b_{1}=1$; incorrect.\n\nThus the correct options are A and D.", "answer": "$$\\boxed{AD}$$", "id": "1914169"}, {"introduction": "While the standard array multiplier is intuitive, more efficient methods exist, especially for signed numbers. Booth's algorithm reduces the number of addition and subtraction operations, which are costly in terms of time and circuit complexity. This problem [@problem_id:1914183] challenges you to think about the 'why' behind the algorithm's efficiency by finding an input that minimizes these operations, thereby revealing the core principle that makes Booth's algorithm a powerful optimization.", "problem": "In digital systems, Booth's algorithm is a multiplication algorithm that multiplies two signed binary numbers in 2's complement notation. Its efficiency stems from its ability to handle strings of consecutive ones in the multiplier, often reducing the number of required addition and subtraction operations compared to the standard \"add and shift\" method. The algorithm inspects the multiplier bits from right to left, one pair at a time.\n\nConsider the multiplication of two signed 4-bit integers, $P = M \\times R$, where $M$ is the multiplicand and $R$ is the multiplier. The number of addition and subtraction operations performed by Booth's algorithm is determined entirely by the bit pattern of the multiplier $R$.\n\nYour task is to find a non-zero 4-bit binary value for the multiplier $R$ that results in the minimum possible number of total addition and subtraction operations. If multiple such 4-bit values for $R$ exist, select the one that represents the signed decimal integer with the smallest absolute value (i.e., the value closest to zero). Provide this 4-bit binary value as your answer.", "solution": "Let the 4-bit two’s complement multiplier be $R = Q_{3}Q_{2}Q_{1}Q_{0}$ with an extra bit $Q_{-1}=0$ appended at the right as in Booth’s algorithm. At each step $i \\in \\{0,1,2,3\\}$, the algorithm examines the pair $(Q_{i},Q_{i-1})$ and:\n- performs an addition if $(Q_{i},Q_{i-1})=(0,1)$,\n- performs a subtraction if $(Q_{i},Q_{i-1})=(1,0)$,\n- performs no operation if $(Q_{i},Q_{i-1})=(0,0)$ or $(1,1)$.\n\nTherefore, the total number of additions and subtractions is exactly the number of transitions between adjacent bits in the extended sequence $Q_{-1},Q_{0},Q_{1},Q_{2},Q_{3}$. Equivalently,\n$$\nN_{\\text{ops}}=\\sum_{i=0}^{3} \\mathbf{1}\\{Q_{i}\\neq Q_{i-1}\\},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n\nThe minimum possible value of $N_{\\text{ops}}$ for a non-zero $R$ is $1$. Indeed:\n- If $R=0000$, then $N_{\\text{ops}}=0$, but this is excluded by the non-zero constraint.\n- If $R\\neq 0000$, let $k$ be the smallest index with $Q_{k}=1$. Since $Q_{-1}=0$ and $Q_{0},\\ldots,Q_{k-1}=0$ by minimality of $k$, the pair $(Q_{k},Q_{k-1})=(1,0)$ contributes at least one operation, hence $N_{\\text{ops}} \\geq 1$.\n- To achieve $N_{\\text{ops}}=1$, there must be no further transitions, which requires $Q_{j}=1$ for all $j \\geq k$. Thus $R$ must have the form of a single transition from zeros (least significant side) to ones (most significant side).\n\nFor 4 bits, the exact $R$ that yield $N_{\\text{ops}}=1$ are\n$$\nR \\in \\{1000,\\,1100,\\,1110,\\,1111\\}.\n$$\nIn 4-bit two’s complement these represent, respectively,\n$$\n1000=-8,\\quad 1100=-4,\\quad 1110=-2,\\quad 1111=-1.\n$$\nAmong these, the smallest absolute value is $|-1|=1$, corresponding to $R=1111$.\n\nTherefore, the non-zero 4-bit multiplier that minimizes the number of additions/subtractions and, among ties, has the smallest absolute value is $1111$.", "answer": "$$\\boxed{1111}$$", "id": "1914183"}]}