{"hands_on_practices": [{"introduction": "A key function of any Arithmetic Logic Unit (ALU) is its ability to perform subtraction, which is most efficiently implemented by adding the two's complement of a number. This practice challenges you to design the combinational logic that conditionally transforms an input into its two's complement form based on a control signal. Mastering this design is a crucial first step toward building an ALU capable of both addition and subtraction [@problem_id:1909155].", "problem": "An essential component of an Arithmetic Logic Unit (ALU) is a circuit that can conditionally negate a number. You are tasked with designing a 4-bit combinational circuit that performs this function for two's complement numbers.\n\nThe circuit has a 4-bit binary input $B = B_3B_2B_1B_0$, where $B_3$ is the most significant bit, and a single control input $S$. The circuit produces a 4-bit binary output $Y = Y_3Y_2Y_1Y_0$.\n\nThe behavior of the circuit is defined as follows:\n- If $S=0$, the output is the same as the input: $Y = B$.\n- If $S=1$, the output is the two's complement of the input: $Y = \\text{Two's Complement}(B)$.\n\nIn your expressions, use $\\cdot$ for AND, $+$ for OR, $\\oplus$ for XOR, and an overbar for NOT (e.g., $\\bar{A}$).\n\nWhich of the following sets of simplified Boolean expressions correctly describes the outputs $Y_3, Y_2, Y_1, Y_0$?\n\nA.\n$Y_0 = B_0$\n$Y_1 = (B_1 \\oplus S) \\oplus (\\bar{B_0} \\cdot S)$\n$Y_2 = (B_2 \\oplus S) \\oplus (\\bar{B_1} \\cdot \\bar{B_0} \\cdot S)$\n$Y_3 = (B_3 \\oplus S) \\oplus (\\bar{B_2} \\cdot \\bar{B_1} \\cdot \\bar{B_0} \\cdot S)$\n\nB.\n$Y_0 = B_0 \\oplus S$\n$Y_1 = B_1 \\oplus S$\n$Y_2 = B_2 \\oplus S$\n$Y_3 = B_3 \\oplus S$\n\nC.\n$Y_0 = B_0 \\oplus S$\n$Y_1 = B_1 \\oplus (B_0 \\cdot S)$\n$Y_2 = B_2 \\oplus (B_1 \\cdot B_0 \\cdot S)$\n$Y_3 = B_3 \\oplus (B_2 \\cdot B_1 \\cdot B_0 \\cdot S)$\n\nD.\n$Y_0 = B_0$\n$Y_1 = (B_1 \\oplus S) \\oplus (B_0 \\cdot S)$\n$Y_2 = (B_2 \\oplus S) \\oplus (B_1 \\cdot B_0 \\cdot S)$\n$Y_3 = (B_3 \\oplus S) \\oplus (B_2 \\cdot B_1 \\cdot B_0 \\cdot S)$", "solution": "We require a 4-bit circuit that outputs $Y=B$ when $S=0$ and $Y=\\text{Two's Complement}(B)$ when $S=1$. The two's complement of $B$ is $\\overline{B}+1$. A standard way to realize this conditionally is:\n- Conditionally invert each bit with $X_{i}=B_{i}\\oplus S$ (so $X=B$ if $S=0$ and $X=\\overline{B}$ if $S=1$).\n- Add $S$ as the carry-in to the least significant bit, i.e., compute $Y=X+S$.\n\nLet $C_{0}=S$ and for each bit $i$ (from $0$ to $3$) use the half-adder relations for adding $X_{i}$ and $C_{i}$:\n$$\nY_{i}=X_{i}\\oplus C_{i},\\qquad C_{i+1}=X_{i}\\cdot C_{i}.\n$$\nUse $X_{i}=B_{i}\\oplus S$ and the identity $A\\oplus B=A\\cdot\\bar{B}+\\bar{A}\\cdot B$ along with $S\\cdot\\bar{S}=0$.\n\nBit $0$:\n$$\nX_{0}=B_{0}\\oplus S,\\quad Y_{0}=(B_{0}\\oplus S)\\oplus S=B_{0},\\quad C_{1}=(B_{0}\\oplus S)\\cdot S=\\bar{B_{0}}\\cdot S.\n$$\n\nBit $1$:\n$$\nX_{1}=B_{1}\\oplus S,\\quad Y_{1}=(B_{1}\\oplus S)\\oplus C_{1}=(B_{1}\\oplus S)\\oplus(\\bar{B_{0}}\\cdot S),\n$$\n$$\nC_{2}=X_{1}\\cdot C_{1}=(B_{1}\\oplus S)\\cdot(\\bar{B_{0}}\\cdot S)=(B_{1}\\bar{S}+\\bar{B_{1}}S)\\cdot\\bar{B_{0}}S=\\bar{B_{1}}\\bar{B_{0}}S.\n$$\n\nBit $2$:\n$$\nX_{2}=B_{2}\\oplus S,\\quad Y_{2}=(B_{2}\\oplus S)\\oplus C_{2}=(B_{2}\\oplus S)\\oplus(\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S),\n$$\n$$\nC_{3}=X_{2}\\cdot C_{2}=(B_{2}\\oplus S)\\cdot(\\bar{B_{1}}\\bar{B_{0}}S)=(B_{2}\\bar{S}+\\bar{B_{2}}S)\\cdot\\bar{B_{1}}\\bar{B_{0}}S=\\bar{B_{2}}\\bar{B_{1}}\\bar{B_{0}}S.\n$$\n\nBit $3$:\n$$\nX_{3}=B_{3}\\oplus S,\\quad Y_{3}=(B_{3}\\oplus S)\\oplus C_{3}=(B_{3}\\oplus S)\\oplus(\\bar{B_{2}}\\cdot\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S).\n$$\n\nThus the simplified expressions are:\n$$\nY_{0}=B_{0},\\quad Y_{1}=(B_{1}\\oplus S)\\oplus(\\bar{B_{0}}\\cdot S),\\quad Y_{2}=(B_{2}\\oplus S)\\oplus(\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S),\\quad Y_{3}=(B_{3}\\oplus S)\\oplus(\\bar{B_{2}}\\cdot\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S),\n$$\nwhich exactly match option A. Options B, C, and D have incorrect carry terms (B produces one’s complement when $S=1$; C and D use $B$-product carries instead of the required $\\bar{B}$-product carries).", "answer": "$$\\boxed{A}$$", "id": "1909155"}, {"introduction": "Once an ALU can perform arithmetic, it's vital to know if the result is valid. This exercise focuses on designing the logic for an overflow flag, a critical status indicator for two's complement operations. You will derive an elegant and surprisingly simple circuit that detects overflow by examining only the carry-in ($C_{n-1}$) and carry-out ($C_n$) of the most significant bit, a fundamental technique used in virtually all processors [@problem_id:1914733].", "problem": "In the design of an Arithmetic Logic Unit (ALU), a critical component is a binary parallel adder capable of handling signed numbers. Consider an $n$-bit parallel adder designed to compute the sum $S = A + B$, where $A$ and $B$ are $n$-bit signed integers represented in two's complement format. The adder is built from a cascade of full-adder circuits.\n\nLet the bits of the operands be $A = a_{n-1}a_{n-2}...a_0$ and $B = b_{n-1}b_{n-2}...b_0$, where $a_{n-1}$ and $b_{n-1}$ are the sign bits, representing the Most Significant Bit (MSB). Let $C_{n-1}$ denote the carry-in signal to the full adder at the MSB position (stage $n-1$), and let $C_n$ denote the carry-out signal generated from this same MSB stage.\n\nYou are tasked with designing a minimal logic circuit that produces a single-bit overflow signal, $V$. This signal must be logic '1' if the sum $S$ has exceeded the representation range of an $n$-bit two's complement number, and logic '0' otherwise. The circuit should use only $C_{n-1}$ and $C_n$ as its inputs.\n\nWhich of the following Boolean expressions correctly represents the overflow signal $V$?\n\nA. $V = C_n$\n\nB. $V = C_{n-1} \\cdot C_n$\n\nC. $V = C_{n-1} + C_n$\n\nD. $V = C_{n-1} \\oplus C_n$\n\nE. $V = \\overline{C_{n-1} \\oplus C_n}$", "solution": "In two's complement addition of $n$-bit signed integers, overflow occurs if and only if the sign bits of the addends are equal but the sign bit of the sum differs. Equivalently, overflow can be detected using only the carry into the MSB and the carry out of the MSB: overflow occurs exactly when these two carries differ.\n\nLet $a \\equiv a_{n-1}$, $b \\equiv b_{n-1}$, $C \\equiv C_{n-1}$, $C_{\\text{out}} \\equiv C_{n}$, and $s \\equiv s_{n-1}$ be the MSB sum bit. For the MSB full adder,\n$$\ns = a \\oplus b \\oplus C,\\qquad C_{\\text{out}} = a b + a C + b C.\n$$\nThe overflow condition in terms of operand signs and the result sign is\n$$\nV = a b\\,\\overline{s} + \\overline{a}\\,\\overline{b}\\,s.\n$$\nWe will show that this equals $C \\oplus C_{\\text{out}}$.\n\nFirst, compute\n$$\nC \\oplus C_{\\text{out}} = C\\,\\overline{C_{\\text{out}}} + \\overline{C}\\,C_{\\text{out}}.\n$$\nUsing $C_{\\text{out}} = a b + a C + b C$ and De Morgan’s law,\n$$\n\\overline{C_{\\text{out}}} = \\overline{a b}\\,\\overline{a C}\\,\\overline{b C} = (\\overline{a}+\\overline{b})(\\overline{a}+\\overline{C})(\\overline{b}+\\overline{C}).\n$$\nTherefore,\n$$\nC\\,\\overline{C_{\\text{out}}} = C(\\overline{a}+\\overline{b})(\\overline{a}+\\overline{C})(\\overline{b}+\\overline{C})\n= C\\,\\overline{a}\\,(\\overline{a}+\\overline{b})(\\overline{b}+\\overline{C})\n= C\\,\\overline{a}\\,(\\overline{b}+\\overline{C})\n= C\\,\\overline{a}\\,\\overline{b}.\n$$\nAlso,\n$$\n\\overline{C}\\,C_{\\text{out}} = \\overline{C}(a b + a C + b C) = \\overline{C}\\,a b.\n$$\nHence,\n$$\nC \\oplus C_{\\text{out}} = C\\,\\overline{a}\\,\\overline{b} + \\overline{C}\\,a b.\n$$\nNow evaluate the overflow definition by cases on $(a,b)$:\n- If $a=b=1$, then $s = 1 \\oplus 1 \\oplus C = C$, so $V = a b\\,\\overline{s} = \\overline{C} = \\overline{C}\\,a b$.\n- If $a=b=0$, then $s = 0 \\oplus 0 \\oplus C = C$, so $V = \\overline{a}\\,\\overline{b}\\,s = C = C\\,\\overline{a}\\,\\overline{b}$.\n- If $a \\neq b$, then $a b = \\overline{a}\\,\\overline{b} = 0$, so $V=0$.\n\nThus in all cases,\n$$\nV = C\\,\\overline{a}\\,\\overline{b} + \\overline{C}\\,a b = C \\oplus C_{\\text{out}}.\n$$\nTherefore the minimal logic using only $C_{n-1}$ and $C_{n}$ is\n$$\nV = C_{n-1} \\oplus C_{n},\n$$\nwhich corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1914733"}, {"introduction": "Beyond standard binary arithmetic, versatile ALUs must often handle different number encodings. This advanced practice guides you through augmenting a standard binary adder to also perform Binary-Coded Decimal (BCD) addition, a format common in financial and industrial applications. You will design the necessary mode-selection and correction logic, learning how a single core component can be adapted to perform multiple, distinct functions [@problem_id:1909126].", "problem": "A digital systems engineer is designing a versatile 4-bit arithmetic unit. This unit must be capable of performing addition on two 4-bit operands, $A = A_3A_2A_1A_0$ and $B = B_3B_2B_1B_0$. The behavior of the unit is determined by a single-bit mode control signal, $M$.\n\n- If $M=0$, the unit performs standard 4-bit binary addition.\n- If $M=1$, the unit performs packed Binary-Coded Decimal (BCD) addition. In this mode, the operands $A$ and $B$ are assumed to be valid single BCD digits, representing decimal values from 0 to 9.\n\nThe internal architecture of the unit is based on a standard 4-bit binary adder. This core adder receives the inputs $A$ and $B$, with its initial carry-in, $C_{in}$, permanently grounded (set to 0). It produces a 4-bit intermediate sum, $Z = Z_3Z_2Z_1Z_0$, and an intermediate carry-out signal, $K$.\n\nBased on the mode signal $M$, additional correction logic processes the intermediate results $Z$ and $K$ to generate the final 4-bit sum $S = S_3S_2S_1S_0$ and the final carry-out signal for the entire unit, $C_{out}$. For BCD addition ($M=1$), a correction is required if the preliminary binary sum is greater than 9. A BCD carry-out is asserted if the binary addition results in a value of 10 or greater.\n\nYour task is to determine the correct minimal Boolean logic expression for the final carry-out signal, $C_{out}$. The expression should be a function of the mode signal $M$, the intermediate carry-out $K$ from the binary adder, and the bits of the intermediate sum $Z$. Which of the following expressions correctly represents $C_{out}$?\n\nA. $C_{out} = K + M \\cdot (Z_3 Z_2 + Z_3 Z_1)$\n\nB. $C_{out} = M K + Z_3 Z_2 + Z_3 Z_1$\n\nC. $C_{out} = K$\n\nD. $C_{out} = \\overline{M} K + M \\cdot (Z_3 Z_2 + Z_3 Z_1)$\n\nE. $C_{out} = M + K + Z_3 Z_2 + Z_3 Z_1$", "solution": "We seek a Boolean expression for the final carry-out $C_{out}$ as a function of $M$, $K$, and the intermediate sum bits $Z_{3}, Z_{2}, Z_{1}, Z_{0}$.\n\nIn binary mode ($M=0$), the final carry-out must equal the binary adder’s carry-out:\n$$\nC_{out}\\big|_{M=0} = K.\n$$\n\nIn BCD mode ($M=1$), a correction (adding $0110$) is required if the preliminary 4-bit sum exceeds $9$. The standard detection condition for a BCD correction (and thus for a BCD carry) is\n$$\nD = K + Z_{3} Z_{2} + Z_{3} Z_{1},\n$$\nbecause $Z_{3} Z_{2} + Z_{3} Z_{1}$ is true for binary values $1010$ to $1111$, and $K=1$ covers cases where the 4-bit adder overflowed (sum $\\geq 16$). Therefore, in BCD mode the final carry-out is\n$$\nC_{out}\\big|_{M=1} = D = K + Z_{3} Z_{2} + Z_{3} Z_{1}.\n$$\n\nUse mode selection to combine both cases:\n$$\nC_{out} = \\overline{M}\\,K + M\\,(K + Z_{3} Z_{2} + Z_{3} Z_{1}).\n$$\nApply Boolean algebra:\n$$\nC_{out} = K(\\overline{M} + M) + M(Z_{3} Z_{2} + Z_{3} Z_{1}) = K + M(Z_{3} Z_{2} + Z_{3} Z_{1}).\n$$\n\nThis matches option A:\n$$\nC_{out} = K + M \\cdot (Z_{3} Z_{2} + Z_{3} Z_{1}).\n$$", "answer": "$$\\boxed{A}$$", "id": "1909126"}]}