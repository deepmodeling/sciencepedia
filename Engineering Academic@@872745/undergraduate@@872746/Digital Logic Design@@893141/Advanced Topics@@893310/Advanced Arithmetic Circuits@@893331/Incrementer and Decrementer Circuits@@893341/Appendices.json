{"hands_on_practices": [{"introduction": "Efficient digital design often involves re-purposing existing hardware blocks for multiple functions. This first practice explores how a standard parallel adder, a cornerstone of arithmetic logic units, can be configured to perform subtraction. By understanding the principle of two's complement arithmetic, you will determine the correct input settings to make an adder behave as a decrementer, a fundamental skill for creating versatile and resource-efficient circuits [@problem_id:1942940].", "problem": "A digital circuit is being designed to perform a specific arithmetic operation on a 4-bit unsigned binary number, $A = A_3A_2A_1A_0$. The core of this circuit is a standard 4-bit binary parallel adder. This adder has two 4-bit data inputs, designated as $X$ and $W$, and a single-bit carry-in, $C_{in}$. The circuit's 4-bit output, $Y = Y_3Y_2Y_1Y_0$, is taken directly from the sum output of the adder.\n\nThe circuit must compute the operation $Y = A - 2$. The input number $A$ is connected to the adder's $X$ input. To achieve the desired subtraction, the second data input $W = W_3W_2W_1W_0$ and the carry-in $C_{in}$ must be set to specific constant binary values. Assume that any overflow from the 4-bit calculation is ignored.\n\nWhich of the following configurations for the input $W$ and carry-in $C_{in}$ will correctly implement the operation $Y = A - 2$?\n\nNote: The binary values for $W$ are given with the most significant bit first (e.g., $W_3W_2W_1W_0$).\n\nA. $W=1101_2$, $C_{in}=1$\n\nB. $W=0010_2$, $C_{in}=0$\n\nC. $W=1101_2$, $C_{in}=0$\n\nD. $W=0001_2$, $C_{in}=1$\n\nE. $W=1110_2$, $C_{in}=1$", "solution": "The problem requires us to implement the subtraction operation $Y = A - 2$ using a 4-bit parallel adder. In digital logic, subtraction is typically performed by adding the 2's complement of the subtrahend. Therefore, the operation $A - 2$ can be rewritten as $A + (-2)$, where $-2$ is represented in its 4-bit 2's complement form.\n\nFirst, we must find the 4-bit 2's complement representation of the number 2.\nThe positive number 2 in a 4-bit binary format is $0010_2$.\n\nTo find the 2's complement, we follow two steps:\n1.  Find the 1's complement by inverting all the bits of the number.\n    The 1's complement of $0010_2$ is $1101_2$.\n2.  Add 1 to the 1's complement to get the 2's complement.\n    $1101_2 + 1 = 1110_2$.\n\nSo, the 4-bit 2's complement representation of $-2$ is $1110_2$.\nThe desired computation $Y = A - 2$ is thus equivalent to the addition $Y = A + 1110_2$. The problem states that any overflow is ignored, which is consistent with 2's complement arithmetic.\n\nThe 4-bit parallel adder circuit calculates the sum $S = X + W + C_{in}$, where $X$ and $W$ are the 4-bit inputs and $C_{in}$ is the carry-in. We are given that the input $A$ is connected to $X$ (so $X=A$) and the output $Y$ is the sum $S$ (so $Y=S$).\nSubstituting these into the adder's equation gives:\n$Y = A + W + C_{in}$.\n\nTo implement the desired operation, this expression must be equivalent to $Y = A + 1110_2$. By comparing the two expressions, we can deduce the necessary condition for the inputs $W$ and $C_{in}$:\n$A + W + C_{in} = A + 1110_2$\n$W + C_{in} = 1110_2$\n\nNow we must evaluate each of the given options to find which one satisfies this condition. The addition of $C_{in}$ occurs at the least significant bit position of $W$.\n\nA. $W=1101_2$, $C_{in}=1$.\n   The sum is $1101_2 + 1 = 1110_2$. This matches our required value.\n\nB. $W=0010_2$, $C_{in}=0$.\n   The sum is $0010_2 + 0 = 0010_2$. This is incorrect. This configuration would compute $Y=A+2$.\n\nC. $W=1101_2$, $C_{in}=0$.\n   The sum is $1101_2 + 0 = 1101_2$. This is incorrect. This configuration would compute $Y=A-3$, since $1101_2$ is the 2's complement of 3.\n\nD. $W=0001_2$, $C_{in}=1$.\n   The sum is $0001_2 + 1 = 0010_2$. This is incorrect. This configuration would compute $Y=A+2$.\n\nE. $W=1110_2$, $C_{in}=1$.\n   The sum is $1110_2 + 1 = 1111_2$. This is incorrect. This configuration would compute $Y=A-1$, since $1111_2$ is the 2's complement of 1.\n\nOnly option A results in $W + C_{in} = 1110_2$. This configuration corresponds to the standard method of implementing subtraction $A-B$ as $A + \\bar{B} + 1$, where $\\bar{B}$ is the 1's complement of $B$. In our case, $B=0010_2$, so $\\bar{B}=1101_2$, which is set as the input $W$. The `$+\\,1$` is provided by setting the carry-in $C_{in}=1$. Thus, this is the correct configuration.", "answer": "$$\\boxed{A}$$", "id": "1942940"}, {"introduction": "A robust digital circuit must handle all possible inputs correctly, especially edge cases that can lead to unexpected behavior. This exercise focuses on a critical boundary condition: decrementing the number zero in a two's complement system [@problem_id:1942964]. By analyzing this operation at the bit level, you will gain a deeper understanding of how signed number systems 'wrap around' and the functional role of the borrow-out signal in detecting underflow.", "problem": "A digital logic circuit is designed to function as a 4-bit decrementer for signed numbers represented in the two's complement format. The circuit accepts a 4-bit binary input, denoted as $X = X_3X_2X_1X_0$, and produces a 4-bit binary output, $Y = Y_3Y_2Y_1Y_0$, along with a single bit for the final borrow-out, $B_{out}$. The operation performed by the circuit is $Y = X - 1$.\n\nGiven an input of $X = 0000_2$, determine the 4-bit output $Y$ and the final borrow-out bit $B_{out}$.\n\nSelect the correct pair $(Y, B_{out})$ from the options below.\n\nA. $(1111_2, 1)$\n\nB. $(1111_2, 0)$\n\nC. $(0001_2, 0)$\n\nD. $(1110_2, 1)$\n\nE. $(0000_2, 1)$", "solution": "We are performing $Y = X - 1$ on a 4-bit two’s complement input $X$. For $X = 0000_{2}$, this is arithmetic zero, so $Y$ should be the two’s complement representation of $-1$. In 4 bits, $-1$ is $1111_{2}$ because taking the two’s complement of $1$ (invert $0001 \\mapsto 1110$ and add $1$) yields $1111$.\n\nTo determine the final borrow-out $B_{out}$ using bitwise subtraction, treat the operation as subtracting $B = 0001_{2}$ from $X = 0000_{2}$. For each bit position $i$ (from least significant to most significant), the full-subtractor relations are\n$$\nd_{i} = a_{i} \\oplus b_{i} \\oplus b_{in,i}\n$$\n$$\nb_{out,i} = \\overline{a_{i}}b_{i} + \\overline{a_{i}}b_{in,i} + b_{i}b_{in,i}\n$$\nwhere $a_{i}$ is the $i$th bit of $X$, $b_{i}$ is the $i$th bit of $B$, $b_{in,i}$ is the borrow-in to bit $i$, $d_{i}$ is the difference bit, and $b_{out,i}$ is the borrow-out to the next bit. Initialize $b_{in,0} = 0$.\n\n- Bit $0$: $a_{0} = 0$, $b_{0} = 1$, $b_{in,0} = 0$.\n  $d_{0} = 0 \\oplus 1 \\oplus 0 = 1$, and $b_{out,0} = \\overline{0}\\cdot 1 + \\overline{0}\\cdot 0 + 1\\cdot 0 = 1$.\n- Bit $1$: $a_{1} = 0$, $b_{1} = 0$, $b_{in,1} = b_{out,0} = 1$.\n  $d_{1} = 0 \\oplus 0 \\oplus 1 = 1$, and $b_{out,1} = \\overline{0}\\cdot 0 + \\overline{0}\\cdot 1 + 0\\cdot 1 = 1$.\n- Bit $2$: $a_{2} = 0$, $b_{2} = 0$, $b_{in,2} = 1$.\n  $d_{2} = 0 \\oplus 0 \\oplus 1 = 1$, and $b_{out,2} = \\overline{0}\\cdot 0 + \\overline{0}\\cdot 1 + 0\\cdot 1 = 1$.\n- Bit $3$: $a_{3} = 0$, $b_{3} = 0$, $b_{in,3} = 1$.\n  $d_{3} = 0 \\oplus 0 \\oplus 1 = 1$, and $b_{out,3} = \\overline{0}\\cdot 0 + \\overline{0}\\cdot 1 + 0\\cdot 1 = 1$.\n\nThus, $Y = d_{3}d_{2}d_{1}d_{0} = 1111_{2}$ and the final borrow-out $B_{out} = b_{out,3} = 1$. This corresponds to option A.", "answer": "$$\\boxed{A}$$", "id": "1942964"}, {"introduction": "Moving from abstract logic gates to real-world implementation reveals the building blocks of modern digital systems. This final practice challenges you to map a 4-bit incrementer onto a simplified model of a Field-Programmable Gate Array (FPGA) logic cell, which uses Look-Up Tables (LUTs) and dedicated carry logic [@problem_id:1942932]. By determining how to configure these cells, you will gain insight into how high-level arithmetic functions are synthesized into physical hardware, a key concept in advanced digital design and computer architecture.", "problem": "In modern reconfigurable hardware like Field-Programmable Gate Arrays (FPGAs), complex arithmetic circuits are constructed by chaining together specialized logic cells. Consider the design of a 4-bit synchronous binary incrementer, which computes the output $S = A + 1$ for a 4-bit input $A = A_3A_2A_1A_0$.\n\nThis incrementer is to be implemented by cascading four identical Arithmetic Logic Cells (ALCs), indexed from $i=0$ for the least significant bit (LSB) to $i=3$ for the most significant bit (MSB). The carry-in to the first cell, $C_0$, is permanently connected to a logic '1'.\n\nEach ALC for stage $i$ is defined by the following structure:\n- **Inputs**: A data bit $A_i$ and a carry-in bit $C_i$.\n- **Outputs**: A sum bit $S_i$ and a carry-out bit $C_{i+1}$.\n- **Internal Components and Wiring**:\n    1.  A 3-input Look-Up Table (LUT), whose output is denoted `LUT_OUT`. The LUT's inputs, $I_1, I_2, I_3$, can be connected to any signal from the set $\\{A_i, C_i, '0' \\text{(GND)}, '1' \\text{(VCC)}\\}$.\n    2.  A dedicated 2-input XOR gate that generates the sum bit, with the fixed wiring: $S_i = \\text{LUT\\_OUT} \\oplus C_i$.\n    3.  A 2-to-1 multiplexer (MUX) that generates the carry-out bit $C_{i+1}$. The MUX inputs, `Sel`, $D_0$, and $D_1$, can be connected to any signal from the set $\\{A_i, C_i, '0', '1', \\text{LUT\\_OUT}\\}$.\n\nYour task is to determine the correct configuration for the LUTs within the ALCs to properly realize the 4-bit incrementer.\n\nLet $f_0(A_0, C_0)$ be the Boolean function implemented by the LUT in cell $ALC_0$, and let $f_i(A_i, C_i)$ be the Boolean function implemented by the LUT in any of the subsequent cells $ALC_i$ (for $i \\in \\{1, 2, 3\\}$). Which of the following options correctly specifies these functions?\n\nA. $f_0 = A_0$; and for $i>0$, $f_i = A_i$.\n\nB. $f_0 = \\neg A_0$; and for $i>0$, $f_i = A_i \\oplus C_i$.\n\nC. $f_0 = 1$; and for $i>0$, $f_i = A_i$.\n\nD. $f_0 = A_0$; and for $i>0$, $f_i = A_i \\cdot C_i$.\n\nE. $f_0 = A_0 \\oplus C_0$; and for $i>0$, $f_i = A_i \\oplus C_i$.", "solution": "We implement a 4-bit incrementer computing $S = A + 1$ with $A = A_{3}A_{2}A_{1}A_{0}$ and $C_{0} = 1$. For each bit $i$, the required sum and carry-out for incrementing are the standard ripple-carry relations:\n$$\nS_{i} = A_{i} \\oplus C_{i}, \\quad C_{i+1} = A_{i} \\cdot C_{i}.\n$$\n\nEach ALC has a LUT output denoted $\\text{LUT\\_OUT}$ and a fixed sum wiring:\n$$\nS_{i} = \\text{LUT\\_OUT} \\oplus C_{i}.\n$$\nTo match the required sum $S_{i} = A_{i} \\oplus C_{i}$ for all $i$, we must have\n$$\n\\text{LUT\\_OUT} = A_{i},\n$$\nindependent of $C_{i}$. In particular, for $i=0$ with $C_{0}=1$, this yields\n$$\nS_{0} = \\text{LUT\\_OUT} \\oplus C_{0} = A_{0} \\oplus 1 = \\neg A_{0},\n$$\nwhich is the correct least significant sum bit for incrementing.\n\nNext, verify that the carry-out can be realized by the MUX. We need $C_{i+1} = A_{i} \\cdot C_{i}$. Using the available MUX connections, choose\n- $\\text{Sel} = A_{i}$,\n- $D_{0} = 0$,\n- $D_{1} = C_{i}$.\nThen the MUX output is $C_{i+1} = 0$ when $A_{i}=0$ and $C_{i+1} = C_{i}$ when $A_{i}=1$, which is exactly $A_{i} \\cdot C_{i}$. Alternatively, with $\\text{LUT\\_OUT} = A_{i}$, one could set $\\text{Sel} = C_{i}$, $D_{0} = 0$, $D_{1} = \\text{LUT\\_OUT}$ to achieve the same function.\n\nTherefore, the correct LUT functions are $f_{0}(A_{0}, C_{0}) = A_{0}$ and, for all $i \\in \\{1,2,3\\}$, $f_{i}(A_{i}, C_{i}) = A_{i}$.\n\nTo eliminate the other options:\n- If $f_{0} = \\neg A_{0}$, then $S_{0} = \\neg A_{0} \\oplus 1 = A_{0}$, which is incorrect for incrementing. For $i>0$, $f_{i} = A_{i} \\oplus C_{i}$ gives $S_{i} = (A_{i} \\oplus C_{i}) \\oplus C_{i} = A_{i}$, not $A_{i} \\oplus C_{i}$; hence option B is invalid.\n- If $f_{0} = 1$, then $S_{0} = 1 \\oplus 1 = 0$, not $\\neg A_{0}$; hence option C is invalid.\n- If $f_{i} = A_{i} \\cdot C_{i}$ for $i>0$, then $S_{i} = (A_{i} \\cdot C_{i}) \\oplus C_{i} = C_{i} \\cdot \\neg A_{i}$, not $A_{i} \\oplus C_{i}$; hence option D is invalid.\n- If $f_{i} = A_{i} \\oplus C_{i}$ for any $i$, then $S_{i} = (A_{i} \\oplus C_{i}) \\oplus C_{i} = A_{i}$, not $A_{i} \\oplus C_{i}$; hence option E is invalid.\n\nThus the only configuration that yields the correct sum and enables correct carry generation with the given MUX is $f_{0} = A_{0}$ and $f_{i} = A_{i}$ for $i>0$, which is option A.", "answer": "$$\\boxed{A}$$", "id": "1942932"}]}