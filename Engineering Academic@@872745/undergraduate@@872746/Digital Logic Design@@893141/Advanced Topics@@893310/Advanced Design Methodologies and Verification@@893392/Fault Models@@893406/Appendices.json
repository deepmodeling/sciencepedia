{"hands_on_practices": [{"introduction": "The goal of circuit testing is to be both thorough and efficient. This foundational exercise guides you through the process of creating the smallest possible set of input patterns, or \"test vectors,\" to guarantee detection of any single stuck-at fault in a basic 2-input AND gate. Mastering this systematic approach [@problem_id:1934760] is a cornerstone of digital logic testing, teaching you how to excite a potential fault and propagate its effect to an observable output.", "problem": "In a semiconductor manufacturing facility, a quality assurance engineer is tasked with developing a testing procedure for a batch of chips containing a large number of simple 2-input AND gates. The goal is to create the most efficient test possible. To do this, the engineer must find the smallest set of input patterns that can guarantee the detection of any single fault within a gate, based on the widely used single stuck-at fault model.\n\nConsider a single 2-input AND gate with inputs labeled A and B, and an output labeled Y. The function of the gate is Y = A AND B. According to the single stuck-at fault model, a fault can occur at any input (A, B) or the output (Y), causing that line to be permanently \"stuck\" at a logical 0 (stuck-at-0) or a logical 1 (stuck-at-1).\n\nA \"test vector\" is a specific combination of input values (A, B). A set of test vectors achieves 100% fault coverage if, for every possible single stuck-at fault, there is at least one vector in the set that produces a different output at Y than a non-faulty gate would.\n\nWhich of the following represents the minimal set of test vectors, represented as pairs (A, B), required to achieve 100% single stuck-at fault coverage for the 2-input AND gate?\n\nA. `{(0, 0), (1, 1)}`\n\nB. `{(0, 1), (1, 0)}`\n\nC. `{(0, 1), (1, 0), (1, 1)}`\n\nD. `{(0, 0), (0, 1), (1, 0)}`\n\nE. `{(0, 0), (0, 1), (1, 0), (1, 1)}`", "solution": "Let the 2-input AND gate implement the Boolean function\n$$Y = A B.$$\nUnder the single stuck-at fault model, a test vector $(A,B)$ detects a fault if it excites the fault (forces the fault-free value on the faulty line to be the opposite of the stuck value) and propagates the resulting error to the primary output so that\n$$Y_{\\text{good}}(A,B) \\neq Y_{\\text{faulty}}(A,B).$$\n\nEnumerate and derive detecting vectors for all single stuck-at faults:\n\n- Fault $A$ stuck-at-$0$:\n  Excite by setting $A=1$. To propagate through the AND, make the output depend on $A$ by setting $B=1$, so that $Y = A\\cdot 1 = A$.\n  Compute:\n  $$Y_{\\text{good}} = 1\\cdot 1 = 1,\\quad Y_{\\text{faulty}} = 0\\cdot 1 = 0.$$\n  Detected by $(1,1)$.\n\n- Fault $B$ stuck-at-$0$:\n  Symmetrically, set $B=1$ and $A=1$ to sensitize $Y$ to $B$:\n  $$Y_{\\text{good}} = 1\\cdot 1 = 1,\\quad Y_{\\text{faulty}} = 1\\cdot 0 = 0.$$\n  Detected by $(1,1)$.\n\n- Fault $A$ stuck-at-$1$:\n  Excite by setting $A=0$, and propagate by setting $B=1$ so $Y$ depends on $A$:\n  $$Y_{\\text{good}} = 0\\cdot 1 = 0,\\quad Y_{\\text{faulty}} = 1\\cdot 1 = 1.$$\n  Detected by $(0,1)$.\n\n- Fault $B$ stuck-at-$1$:\n  Excite by setting $B=0$, and propagate by setting $A=1$:\n  $$Y_{\\text{good}} = 1\\cdot 0 = 0,\\quad Y_{\\text{faulty}} = 1\\cdot 1 = 1.$$\n  Detected by $(1,0)$.\n\n- Fault $Y$ stuck-at-$0$:\n  Excite the output to $1$ in the good circuit so the discrepancy appears at $Y$:\n  $$Y_{\\text{good}} = 1\\cdot 1 = 1,\\quad Y_{\\text{faulty}} = 0.$$\n  Detected by $(1,1)$.\n\n- Fault $Y$ stuck-at-$1$:\n  Excite the output to $0$ in the good circuit so the discrepancy appears at $Y$. Any input with $A B = 0$ works; notably,\n  $$Y_{\\text{good}} = 0,\\quad Y_{\\text{faulty}} = 1.$$\n  Both $(0,1)$ and $(1,0)$ detect this fault.\n\nFrom the above, the set $\\{(1,1),(0,1),(1,0)\\}$ detects all six single stuck-at faults.\n\nMinimality:\n- Any complete set must include $(1,1)$ to detect $Y$ stuck-at-$0$ and input stuck-at-$0$ faults, since only $(1,1)$ makes $Y_{\\text{good}}=1$.\n- To detect $A$ stuck-at-$1$, the other input must be $1$ so the AND output depends on $A$; thus $(0,1)$ is required (vectors with $B=0$ block propagation).\n- To detect $B$ stuck-at-$1$, symmetrically $(1,0)$ is required.\n\nTherefore, any 100% coverage set must contain $(1,1)$, $(0,1)$, and $(1,0)$, and three vectors suffice. Among the given options, this is option C.", "answer": "$$\\boxed{C}$$", "id": "1934760"}, {"introduction": "While comprehensive testing is ideal, real-world scenarios often impose constraints on time and resources. This practice explores the practical consequences of using an incomplete set of test vectors. By analyzing which faults remain hidden when testing a 3-input OR gate with a limited number of inputs [@problem_id:1934725], you will develop a deeper appreciation for the concept of \"fault coverage\" and the critical trade-offs involved in test engineering.", "problem": "In a quality control process for digital circuits, a standard 3-input OR gate is being tested. The gate has inputs denoted by $A$, $B$, and $C$, and a single output $Z$. The testing procedure is constrained by time and resources, allowing for the application of only two specific input test vectors: $(A, B, C) = (0, 0, 0)$ and $(A, B, C) = (1, 1, 1)$.\n\nThe analysis considers the possibility of a single stuck-at fault, where one of the input or output lines is permanently fixed to either a logic 0 (stuck-at-0) or a logic 1 (stuck-at-1). A fault is considered \"detected\" if, for at least one of the applied test vectors, the output of the faulty gate differs from the output of a fault-free gate. If a fault is not detected by any of the available test vectors, it \"remains undetected\".\n\nGiven this testing scenario, which of the following single stuck-at faults would remain undetected?\n\nA. Input $A$ is stuck-at-0.\n\nB. Input $A$ is stuck-at-1.\n\nC. Output $Z$ is stuck-at-0.\n\nD. Output $Z$ is stuck-at-1.\n\nE. Input $B$ is stuck-at-1.", "solution": "Let the fault-free 3-input OR gate be described by $Z = A \\lor B \\lor C$. Under the two available test vectors, the fault-free outputs are:\n$$Z(0,0,0) = 0,\\quad Z(1,1,1) = 1.$$\nA fault is detected if there exists at least one applied test vector for which the faulty output $Z_{\\text{f}}$ differs from the fault-free output $Z$.\n\nConsider each listed single stuck-at fault:\n\nOption A: Input $A$ stuck-at-0. For $(A,B,C)=(0,0,0)$, the forced input is $(0,0,0)$, so $Z_{\\text{f}}=0$, which equals $Z=0$. For $(A,B,C)=(1,1,1)$, the forced input becomes $(0,1,1)$ and $Z_{\\text{f}}=1$, which equals $Z=1$. Since $Z_{\\text{f}}$ equals $Z$ for both vectors, this fault remains undetected.\n\nOption B: Input $A$ stuck-at-1. For $(0,0,0)$, the forced input is $(1,0,0)$ and $Z_{\\text{f}}=1$, while $Z=0$, hence detected. (For $(1,1,1)$, both give $1$, but detection already occurs.)\n\nOption C: Output $Z$ stuck-at-0. For $(0,0,0)$, $Z_{\\text{f}}=0$ equals $Z=0$. For $(1,1,1)$, $Z_{\\text{f}}=0$ while $Z=1$, hence detected.\n\nOption D: Output $Z$ stuck-at-1. For $(0,0,0)$, $Z_{\\text{f}}=1$ while $Z=0$, hence detected. (For $(1,1,1)$, both give $1$.)\n\nOption E: Input $B$ stuck-at-1. For $(0,0,0)$, the forced input is $(0,1,0)$ and $Z_{\\text{f}}=1$, while $Z=0$, hence detected. (For $(1,1,1)$, both give $1$.)\n\nTherefore, among the listed faults, only input $A$ stuck-at-0 remains undetected.", "answer": "$$\\boxed{A}$$", "id": "1934725"}, {"introduction": "The single stuck-at model is a powerful abstraction, but physical defects can manifest in more complex ways. This advanced exercise introduces the \"bridging fault,\" where an unintended connection is formed between two signal lines. You will analyze how a hypothetical dominant-0 (wired-AND) bridging fault alters a circuit's logical behavior, learning to translate a physical defect into a modified Boolean function [@problem_id:1934770]. This problem highlights that the principles of fault analysis can be extended beyond the basic stuck-at model.", "problem": "A digital logic circuit is designed to implement the Boolean function $F(A, B, C, D) = ((A \\cdot B) + C) \\oplus D$. In this expression, $A, B, C, D$ are the primary inputs, the symbol `+` denotes the logical OR operation, `.` or juxtaposition denotes the logical AND operation, `âŠ•` denotes the Exclusive OR (XOR) operation, and the expression is realized using elementary logic gates corresponding to these operations.\n\nDuring manufacturing, a defect occurs, creating a bridging fault. This fault establishes an unintended connection between the output of the AND gate (which computes $A \\cdot B$) and the primary input line for $D$. The fault is characterized as a dominant-0, or wired-AND, bridging fault. This means that if the two connected lines attempt to carry different logic levels (one 0, the other 1), the fault forces both lines to the logic 0 level. If both lines attempt to carry the same level, they maintain that level. This behavior is equivalent to inserting a logical AND gate whose inputs are the original signals on the two lines, with the output of this \"fault gate\" driving both lines.\n\nDetermine the modified Boolean function, $F_{faulty}(A, B, C, D)$, that describes the behavior of the circuit in the presence of this specific fault. Provide your answer as a simplified Boolean expression in terms of the inputs $A, B, C,$ and $D$. Use a prime (e.g., $A'$) to denote the NOT operation.", "solution": "Let the intended circuit compute $F(A,B,C,D) = ((A B) + C) \\oplus D$. Define the internal nets without fault:\n- AND output: $G = A B$,\n- OR output: $O = G + C$,\n- Final output: $F = O \\oplus D$.\n\nA dominant-0 (wired-AND) bridging fault shorts the net $G$ with the input line $D$, forcing both shorted nets to the logical AND of their intended values. Therefore both nets carry\n$$S = G \\cdot D = (A B) D = A B D.$$\nUnder the fault, the OR gate input from $G$ becomes $S$, and the XOR input from $D$ becomes $S$. Hence the faulty output is\n$$F_{\\text{faulty}} = \\big(S + C\\big) \\oplus S.$$\nUse the XOR identity $X \\oplus Y = X Y' + X' Y$ with $X = S + C$ and $Y = S$:\n$$(S + C) \\oplus S = (S + C) S' + (S + C)' S.$$\nCompute each term:\n- $(S + C) S' = S S' + C S' = 0 + C S' = C S'$,\n- $(S + C)' S = (S' C') S = S S' C' = 0$,\nso\n$$F_{\\text{faulty}} = C S'.$$\nSubstitute $S = A B D$ and apply DeMorgan's law:\n$$S' = (A B D)' = A' + B' + D',$$\ntherefore\n$$F_{\\text{faulty}} = C \\big(A' + B' + D'\\big) = C A' + C B' + C D'.$$\nThis is a simplified Boolean expression in terms of $A,B,C,D$ using prime for NOT.", "answer": "$$\\boxed{C\\left(A' + B' + D'\\right)}$$", "id": "1934770"}]}