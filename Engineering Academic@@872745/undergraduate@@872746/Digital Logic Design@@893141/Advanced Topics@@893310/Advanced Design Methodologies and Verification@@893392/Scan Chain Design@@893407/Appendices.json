{"hands_on_practices": [{"introduction": "To effectively use scan chains for testing, we must first have a solid grasp of their most basic function: operating as a large shift register. This initial exercise will walk you through the step-by-step process of shifting a test pattern into a scan chain. By tracking the data movement cycle by cycle, you will build a foundational understanding of how we gain control over the internal states of a circuit [@problem_id:1958985].", "problem": "In modern digital circuit design, a technique known as Design for Testability (DFT) is employed to facilitate testing of manufactured chips. A common DFT method involves adding scan chains, which reconfigure the circuit's flip-flops into a large shift register during a special test mode.\n\nConsider a simple 5-bit scan chain composed of five D-type flip-flops, labeled FF1 through FF5. In test mode, the data input of FF1 is connected to a primary input port `scan_in`. The output of FF1 (Q1) is connected to the input of FF2 (D2), the output of FF2 (Q2) to the input of FF3 (D3), and so on, until the output of FF5 (Q5), which is connected to a primary output port `scan_out`.\n\nInitially, all five flip-flops in the scan chain are reset, so their contents, represented as the ordered bit-string `[Q1, Q2, Q3, Q4, Q5]`, are `00000`.\n\nA test vector sequence `10110` is serially shifted into the chain via the `scan_in` port over five consecutive clock cycles. The first bit of the sequence (`1`) is applied at `scan_in` for the first clock cycle, the second bit (`0`) is applied for the second clock cycle, and so forth.\n\nWhat is the binary content of the scan chain, `[Q1, Q2, Q3, Q4, Q5]`, after exactly 5 clock cycles?\n\nA. `10110`\n\nB. `01101`\n\nC. `00000`\n\nD. `01100`\n\nE. `11010`", "solution": "In a scan chain made of positive-edge triggered D flip-flops, at each active clock edge the next state equals the input: for FF1, $Q_{1}^{+}=D_{1}=\\text{scan\\_in}$; for $i \\in \\{2,3,4,5\\}$, $Q_{i}^{+}=D_{i}=Q_{i-1}$. Let $Q_{i}[k]$ denote the content after the $k$-th clock, with initial state $Q_{i}[0]=0$. Let the applied serial inputs be $s[1]=1$, $s[2]=0$, $s[3]=1$, $s[4]=1$, $s[5]=0$. Then the update equations per clock are\n$$\nQ_{1}[k]=s[k], \\quad Q_{i}[k]=Q_{i-1}[k-1] \\text{ for } i=2,3,4,5.\n$$\nCompute iteratively:\n- $k=1$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,0,0,0]$.\n- $k=2$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,0,0,0]$.\n- $k=3$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,1,0,0]$.\n- $k=4$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,1,0,1,0]$.\n- $k=5$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,1,0,1]$.\n\nThus, after exactly five clock cycles, the scan chain content is $01101$, corresponding to option B.", "answer": "$$\\boxed{B}$$", "id": "1958985"}, {"introduction": "Once we can reliably load and unload data, the true power of scan chains in fault diagnosis becomes apparent. By comparing the bitstream we expect to see with the one we actually observe from a physical chip, we can pinpoint the exact location of a failure. This practice [@problem_id:1958964] demonstrates this diagnostic process, challenging you to trace an error back to the specific flip-flop that captured an incorrect value.", "problem": "In a modern System-on-Chip (SoC), extensive testing is performed using Design-for-Test (DFT) methodologies. A key component of this is the scan chain, which connects the chip's flip-flops into a giant shift register during test mode. This allows engineers to control and observe the internal state of the circuit.\n\nConsider a digital logic block containing 16 state-holding flip-flops, indexed FF1 through FF16. For testing purposes, these have been connected into a single scan chain. The physical index of a flip-flop does not necessarily correspond to its position in the scan chain. The specific scan chain order, from the scan-in pin to the scan-out pin, is as follows:\n\nFF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7\n\nAfter scanning in a specific test vector, the chip is placed in functional mode for a single clock cycle to capture the outputs of the combinational logic into the flip-flops. The chip is then returned to test mode, and the captured state is scanned out.\n\nThe expected scan-out bitstream, based on a fault-free simulation, is:\n`E = 1011010111010110`\n\nThe actually observed bitstream from the physical chip is:\n`O = 1011010110010110`\n\nThe bitstreams are read from left to right, where the first bit is the first one to emerge from the scan-out pin, and the last bit is the last one. A single, non-intermittent fault exists in the combinational logic, causing exactly one flip-flop to capture an erroneous value. Identify the index $k$ of the faulty flip-flop $FF_k$. The first flip-flop to capture an error is defined as the one that is furthest along the scan path from the scan-out pin (i.e., closest to the scan-in pin) among all flip-flops that captured incorrect data.", "solution": "The problem requires us to identify which flip-flop, $FF_k$, captured an incorrect value by analyzing the expected and observed scan-out bitstreams. The core of the problem lies in correctly mapping the positions in the bitstream to the specific flip-flops in the non-sequential scan chain.\n\nStep 1: Understand the Scan-Out Process\nThe problem states that the scan-out bitstream is generated by shifting the captured values out, starting from the flip-flop closest to the scan-out pin. The scan chain order is given from scan-in to scan-out. We need to reverse this order to find the sequence of flip-flops as their data appears at the output.\n\nThe given scan chain path is:\nSCAN_IN → FF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7 → SCAN_OUT\n\nThe flip-flop nearest to the scan-out pin is FF7. Its captured value will be the first bit in the scan-out stream. The next flip-flop in the chain towards the scan-in pin is FF3, so its value will be the second bit. This continues until the last flip-flop, FF13 (nearest to the scan-in pin), whose captured value will be the last bit of the stream.\n\nLet's establish the mapping from the bit position in the stream (1 to 16) to the originating flip-flop index:\n- Bit 1: FF7\n- Bit 2: FF3\n- Bit 3: FF12\n- Bit 4: FF6\n- Bit 5: FF15\n- Bit 6: FF10\n- Bit 7: FF1\n- Bit 8: FF8\n- Bit 9: FF14\n- Bit 10: FF4\n- Bit 11: FF11\n- Bit 12: FF5\n- Bit 13: FF16\n- Bit 14: FF9\n- Bit 15: FF2\n- Bit 16: FF13\n\nStep 2: Identify Mismatches between Expected and Observed Streams\nNow, we compare the expected bitstream `E` with the observed bitstream `O` to find the position of any errors.\n\nExpected: `E = 1011010111010110`\nObserved: `O = 1011010110010110`\n\nLet's compare them bit by bit from left to right (position 1 to 16):\n- Positions 1-9: The bits are identical (`101101011`).\n- Position 10: `E` has a `1`, while `O` has a `0`. This is a mismatch.\n- Positions 11-16: The bits are identical (`010110`).\n\nThe only mismatch occurs at the 10th bit position of the scan-out stream.\n\nStep 3: Localize the Faulty Flip-Flop\nThe problem states that the source of the error is the first flip-flop in the scan chain to capture an erroneous value, defined as the one furthest from the scan-out pin among all faulty captures. In a scan-out stream, bits that come out later correspond to flip-flops that are deeper (further from the scan-out pin) in the chain. Therefore, we should identify the mismatch that occurs at the highest bit position index.\n\nIn this case, there is only one mismatch, at bit position 10. We now use the mapping from Step 1 to determine which flip-flop's captured value corresponds to this 10th bit.\n\nAccording to our mapping: Bit 10 corresponds to the value captured by FF4.\n\nSince this is the only error, the fault must be in the combinational logic cone that provides the input to FF4. Therefore, FF4 is the flip-flop that captured the erroneous value. The index $k$ of the faulty flip-flop $FF_k$ is 4.", "answer": "$$\\boxed{4}$$", "id": "1958964"}, {"introduction": "A critical step before using a scan chain to test the main logic is to first verify the integrity of the chain itself. If the chain is broken, any data shifted out is meaningless, rendering our diagnostic efforts useless. This exercise [@problem_id:1958987] explores the concept of a \"flush test,\" where a specific pattern is used to efficiently check for common manufacturing defects like stuck-at faults within the scan path.", "problem": "In modern Very Large Scale Integration (VLSI) circuit design, a common Design for Testability (DFT) technique is the use of a scan chain. This involves connecting all the internal storage elements (like flip-flops) into one long shift register. During test mode, a known sequence of bits can be shifted into this chain via a dedicated `Scan_In` port, and the resulting state can be shifted out from a `Scan_Out` port.\n\nBefore using the scan chain to test the combinational logic of the circuit, it is crucial to first verify the integrity of the scan chain itself. This is often done with a \"flush test,\" where a specific bit pattern is shifted through the entire chain to confirm it can correctly transport data.\n\nConsider a scan chain composed of $N$ flip-flops. We want to perform a flush test to detect the most common manufacturing defects within the scan path, specifically single stuck-at-0 faults (where a node is permanently shorted to ground) and single stuck-at-1 faults (where a node is permanently shorted to the power supply).\n\nWhich of the following input data sequences, when applied to the `Scan_In` port for $N$ consecutive clock cycles, provides the most comprehensive and efficient check for both single stuck-at-0 and stuck-at-1 faults throughout the entire length of the scan chain?\n\nA. A constant sequence of `0`s (i.e., `000...`).\n\nB. A constant sequence of `1`s (i.e., `111...`).\n\nC. An alternating sequence of `0`s and `1`s (e.g., `010101...`).\n\nD. A sequence containing a single `1` followed by $N-1$ zeros (a \"walking 1\" pattern, i.e., `1000...`).\n\nE. A sequence of $N/2$ zeros followed by $N/2$ ones (assuming $N$ is even).", "solution": "Let the scan chain be a cascade of $N$ edge-triggered flip-flops, indexed from $1$ (nearest to the Scan\\_In) to $N$ (nearest to the Scan\\_Out). Denote the applied serial input sequence by $s(t)$, with one bit applied per clock at time $t$. In a fault-free chain, after the pipeline is filled, the Scan\\_Out equals the input delayed by $N$ clocks:\n$$\ny(t) = s(t - N).\n$$\nA single stuck-at-$b$ fault ($b \\in \\{0,1\\}$) at stage $k$ can be abstracted as forcing the output of stage $k$ to be constantly $b$. Consequently, whenever the intended bit at stage $k$ should be $1-b$, a discrepancy is created that propagates to the Scan\\_Out and is observable after the appropriate shift latency.\n\nTo detect both stuck-at-0 and stuck-at-1 faults at every position $k \\in \\{1,\\dots,N\\}$ using a single $N$-cycle flush, the applied sequence $s(t)$ must:\n1) Drive every stage to both logic $0$ and logic $1$ during the test (to excite both polarities).\n2) Create frequent $0 \\leftrightarrow 1$ transitions between adjacent stages, ensuring prompt propagation of discrepancies to the Scan\\_Out within the $N$-cycle window, independent of initial state.\n\nEvaluate the options:\n\nA. Constant $0$s: $s(t)=0$ for all $t$. This never attempts to drive a $1$ at any stage, so a stuck-at-0 fault is not excited; only stuck-at-1 can be detected. Thus it is not comprehensive.\n\nB. Constant $1$s: $s(t)=1$ for all $t$. This never attempts to drive a $0$ at any stage, so a stuck-at-1 fault is not excited; only stuck-at-0 can be detected. Thus it is not comprehensive.\n\nC. Alternating $0,1,0,1,\\dots$: $s(t)$ toggles every cycle. For any stage $k$, the intended value at that stage alternates between $0$ and $1$ in consecutive cycles, so both stuck-at-0 and stuck-at-1 faults are excited at $k$. Moreover, the continuous alternation guarantees frequent transitions between adjacent stages, which makes any discrepancy caused by a stuck-at fault manifest quickly at the Scan\\_Out within the $N$-cycle test. This satisfies both completeness (both polarities at all positions) and efficiency (single pattern, maximal toggle rate).\n\nD. Walking $1$: $s(0)=1$ and $s(t)=0$ for $t \\in \\{1,\\dots,N-1\\}$. Each stage sees mostly $0$s with a single $1$ passing through. This can excite stuck-at-0 at the moment the $1$ reaches a given stage and can also reveal stuck-at-1 because zeros are applied for most cycles. However, relative to the alternating pattern, detection latency can be longer for some positions (e.g., near the Scan\\_Out), and completeness within exactly $N$ applied cycles can be marginal for the last stages because the single $1$ arrives at the final stage only at the end of the $N$th cycle, leaving no additional cycle for observation at the Scan\\_Out under the stated constraint of $N$ applied cycles. Thus it is less robust and less efficient than the alternating sequence for a single-pass $N$-cycle flush.\n\nE. Blocked $N/2$ zeros followed by $N/2$ ones (assuming $N$ even): This creates only one transition in the input stream. Many stages will not experience both logic levels within the $N$-cycle application window, so one of the two stuck-at polarities may not be excited at certain positions. Thus it is not comprehensive.\n\nTherefore, the alternating sequence $010101\\dots$ provides the most comprehensive and efficient single-pass check for both single stuck-at-0 and stuck-at-1 faults across the entire scan chain length.", "answer": "$$\\boxed{C}$$", "id": "1958987"}]}