{"hands_on_practices": [{"introduction": "The power of a microprogrammed control unit lies in its ability to orchestrate the datapath through a sequence of microinstructions. In a horizontal microprogramming scheme, each microinstruction is a wide word where individual bits or small fields directly control specific hardware components. This practice challenges you to design such a microinstruction by determining its total width based on the requirements of the processor's datapath, giving you a concrete understanding of the trade-off between control parallelism and the size of the control store [@problem_id:1941350].", "problem": "An engineering team is designing the control unit for a new 32-bit Central Processing Unit (CPU). They have opted for a microprogrammed approach using a purely horizontal format to maximize performance by eliminating decoding delays for control signals. The datapath of the CPU has the following components and requirements that must be managed by each microinstruction:\n\n1.  **Register File**: The CPU contains a register file with 32 general-purpose registers. A microinstruction must be able to specify the addresses for two source registers (sources A and B) and one destination register. It must also include a single, dedicated bit to enable or disable writing to the destination register (`RegWrite`).\n\n2.  **Arithmetic Logic Unit (ALU)**: The ALU is capable of performing 30 distinct operations. The control scheme for the ALU is unencoded, meaning that for each of the 30 operations, there is a dedicated, independent control bit in the microinstruction.\n\n3.  **Data Path Multiplexers**:\n    *   One 2-to-1 multiplexer selects the second ALU operand. Its single control bit (`ALUSrc`) chooses between the value from source register B and an immediate value provided by the main instruction.\n    *   Another 2-to-1 multiplexer selects the data to be written back into the register file. Its single control bit (`MemToReg`) chooses between the result from the ALU and data fetched from memory.\n\n4.  **Memory Interface**: The interface to the main memory requires two separate control signals: `MemRead` to initiate a read operation and `MemWrite` to initiate a write operation.\n\n5.  **Branching Control**: Two independent control bits are used for program flow: `PCWrite` to enable updates to the program counter and `Branch` to execute a conditional branch.\n\n6.  **Microprogram Sequencing**: Each microinstruction must explicitly specify the address of the next microinstruction to be executed. The control store that holds the microprogram has a total capacity of 1024 microinstructions.\n\nBased on these specifications, determine the total width, in bits, of a single microinstruction in this control unit.", "solution": "To determine the microinstruction width, sum the bits required by each specified field.\n\nRegister file addressing:\n- There are $32$ registers, so each register address requires $\\log_{2} 32 = 5$ bits.\n- Two source addresses and one destination address require\n$$2 \\cdot 5 + 5 = 15 \\text{ bits}.$$\n- Add the single write-enable bit:\n$$15 + 1 = 16 \\text{ bits}.$$\n\nALU control:\n- Unencoded control with $30$ distinct operations uses $30$ independent bits:\n$$30 \\text{ bits}.$$\n\nData path multiplexers:\n- Two $2$-to-$1$ mux controls ($\\text{ALUSrc}$ and $\\text{MemToReg}$) require\n$$1 + 1 = 2 \\text{ bits}.$$\n\nMemory interface:\n- $\\text{MemRead}$ and $\\text{MemWrite}$ require\n$$1 + 1 = 2 \\text{ bits}.$$\n\nBranching control:\n- $\\text{PCWrite}$ and $\\text{Branch}$ require\n$$1 + 1 = 2 \\text{ bits}.$$\n\nMicroprogram sequencing:\n- Control store has $1024$ entries, so the next-address field needs\n$$\\log_{2} 1024 = 10 \\text{ bits}.$$\n\nTotal microinstruction width:\n$$16 + 30 + 2 + 2 + 2 + 10 = 62 \\text{ bits}.$$", "answer": "$$\\boxed{62}$$", "id": "1941350"}, {"introduction": "One of the key advantages of microprogramming is its flexibility. Adding a new, complex instruction to a processor's instruction set does not require a hardware redesign; instead, it involves adding a new sequence of microinstructions—a micro-routine—to the control store. This exercise demonstrates this process by tasking you with calculating the storage space required for a new instruction, reinforcing the concept of control logic as a \"program\" and illustrating the tangible cost of adding functionality in a microprogrammed architecture [@problem_id:1941344].", "problem": "A systems architect is tasked with upgrading a legacy processor that utilizes a microprogrammed control unit. The control unit's behavior is dictated by microinstructions stored in a Control Store memory. The format of each microinstruction in this architecture is fixed and consists of several fields with the following bit widths:\n\n*   **ALU Control**: 6 bits\n*   **Source Register 1 Select**: 5 bits\n*   **Source Register 2 Select**: 5 bits\n*   **Destination Register Select**: 5 bits\n*   **Memory Operation Control (No-Op, Read, Write)**: 2 bits\n*   **Sequencing Logic (determines next microinstruction)**: 3 bits\n*   **Next Address / Branch Target**: 12 bits\n\nThe architect needs to add a new instruction, `SWAPMEM [R_A], [R_B]`, to the processor's instruction set. This instruction swaps the data stored at the two memory addresses contained in general-purpose registers `R_A` and `R_B`. The execution of this new instruction, after it has been fetched and decoded, requires the following sequence of fundamental micro-operations:\n\n1.  Transfer the contents of register `R_A` to the Memory Address Register (MAR).\n2.  Initiate a memory read cycle, storing the fetched data word into a dedicated temporary register, `TEMP1`.\n3.  Transfer the contents of register `R_B` to the MAR.\n4.  Initiate a memory read cycle, storing the fetched data word into a second dedicated temporary register, `TEMP2`.\n5.  Transfer the contents of register `R_A` to the MAR.\n6.  Initiate a memory write cycle, transferring the data from `TEMP2` to the memory location indicated by the MAR.\n7.  Transfer the contents of register `R_B` to the MAR.\n8.  Initiate a memory write cycle, transferring the data from `TEMP1` to the memory location indicated by the MAR.\n9.  Branch to the beginning of the standard instruction-fetch micro-routine.\n\nAssuming that each of the nine micro-operations listed above is implemented by a single, unique microinstruction, calculate the total number of bits required to store the new microprogram for the `SWAPMEM` instruction in the control store.", "solution": "The control store uses a fixed-format microinstruction. Let $W$ be the width in bits of one microinstruction. By summing the field widths:\n$$\nW = 6 + 5 + 5 + 5 + 2 + 3 + 12 = 38 \\text{ bits}.\n$$\nThe new instruction requires $N=9$ distinct microinstructions (one per micro-operation). The total number of bits required is:\n$$\nS = N \\times W = 9 \\times 38 = 342 \\text{ bits}.\n$$\nTherefore, the control store needs $342$ bits to hold the microprogram for the new instruction.", "answer": "$$\\boxed{342}$$", "id": "1941344"}, {"introduction": "The choice between a hardwired and a microprogrammed control unit often boils down to a fundamental trade-off between speed and flexibility. Hardwired units are typically faster but rigid, while microprogrammed units are flexible but can be slower due to the overhead of fetching microinstructions. This final practice moves from implementation to analysis, asking you to derive a formal condition that determines which design will have a faster clock cycle based on underlying hardware parameters like logic gate delay and memory access time. By finding this performance \"tipping point,\" you will gain a deeper appreciation for the engineering decisions that shape processor design [@problem_id:1941359].", "problem": "A digital systems engineering team is evaluating two different design philosophies for the control unit of a new processor. Both designs must implement the same Instruction Set Architecture (ISA).\n\nThe first option is a **hardwired control unit**. The performance of this design is limited by the longest combinational logic path. The maximum logic depth, defined as the greatest number of gates in any path from input to output, is denoted by $D_{HW}$. The clock period for this design is determined by the propagation delay through this longest path plus the setup time for the state registers.\n\nThe second option is a **microprogrammed control unit**. This design uses a control store implemented as a Read-Only Memory (ROM) and some supporting logic. The clock period for this design (i.e., the time for one micro-cycle) is determined by the critical path required to fetch the next microinstruction. This path involves accessing the ROM, processing part of the fetched microinstruction through next-address generation logic, and preparing the microprogram counter for the subsequent cycle. The logic depth of the next-address generation circuitry is denoted by $D_{addr}$.\n\nFor both designs, assume the following:\n- All logic gates have an identical propagation delay of $t_{pd}$.\n- All registers (e.g., state registers in the hardwired unit, the microprogram counter in the microprogrammed unit) have an identical setup time of $t_{setup}$.\n- The ROM in the microprogrammed unit has a specified access time of $T_{ROM}$.\n\nTo decide which design is superior in terms of raw clock speed, the team wants to find a critical threshold. Derive an expression for the threshold value of the ROM access time, let's call it $T_{threshold}$. If the actual ROM access time $T_{ROM}$ of the chosen component is greater than this $T_{threshold}$, the hardwired control unit will have a strictly shorter clock period than the microprogrammed control unit. Express your answer in terms of $D_{HW}$, $D_{addr}$, and $t_{pd}$.", "solution": "The clock period of a synchronous design is determined by the sum of the critical combinational logic delay along the longest path plus the setup time of the destination registers.\n\nFor the hardwired control unit, the maximum logic depth is $D_{HW}$ gates, each with propagation delay $t_{pd}$, and the destination register has setup time $t_{setup}$. Therefore, the clock period is\n$$\nT_{HW} = D_{HW}\\,t_{pd} + t_{setup}.\n$$\n\nFor the microprogrammed control unit, the critical path per micro-cycle consists of the ROM access plus the next-address generation logic of depth $D_{addr}$, followed by registering into the microprogram counter with setup time $t_{setup}$. Therefore, the clock period is\n$$\nT_{MP} = T_{ROM} + D_{addr}\\,t_{pd} + t_{setup}.\n$$\n\nThe hardwired control unit is strictly faster (has a strictly shorter clock period) when $T_{HW} < T_{MP}$. Substituting the expressions above,\n$$\nD_{HW}\\,t_{pd} + t_{setup} < T_{ROM} + D_{addr}\\,t_{pd} + t_{setup}.\n$$\nCancel $t_{setup}$ from both sides and rearrange to isolate $T_{ROM}$:\n$$\nD_{HW}\\,t_{pd} < T_{ROM} + D_{addr}\\,t_{pd}\n\\;\\;\\Longrightarrow\\;\\;\nT_{ROM} > (D_{HW} - D_{addr})\\,t_{pd}.\n$$\n\nThus, the threshold ROM access time at which both designs tie is\n$$\nT_{threshold} = (D_{HW} - D_{addr})\\,t_{pd}.\n$$\nFor $T_{ROM} > T_{threshold}$, the hardwired control unit has a strictly shorter clock period than the microprogrammed control unit.", "answer": "$$\\boxed{(D_{HW}-D_{addr})\\,t_{pd}}$$", "id": "1941359"}]}