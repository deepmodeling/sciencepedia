{"hands_on_practices": [{"introduction": "To begin, we explore the heart of processor operation: the control unit's direction of the datapath. Every instruction, from a simple addition to a complex memory access, is realized by a specific configuration of control signals that route data and enable functional units. In this exercise, you will step into the role of a control unit designer, tasked with determining the precise settings for a single-cycle datapath to execute a custom memory-store instruction [@problem_id:1926288]. This practice will solidify your understanding of how high-level instruction semantics are translated into the low-level binary language of hardware.", "problem": "Consider a simplified single-cycle processor datapath designed to execute a set of instructions. The datapath includes a register file with two read ports and one write port, a main memory unit, and an Arithmetic Logic Unit (ALU). The flow of data is managed by several control signals and multiplexers.\n\nThe primary control signals and their functions are defined as follows:\n- `RegWrite` (1 bit): When set to 1, enables writing the result to the register file.\n- `MemtoReg` (1 bit): Selects the data source for the register file's write port. If 0, the source is the ALU result; if 1, the source is the data read from memory.\n- `MemRead` (1 bit): When set to 1, a read operation is performed on the main memory.\n- `MemWrite` (1 bit): When set to 1, a write operation is performed on the main memory.\n- `ALUSrc` (1 bit): Selects the second operand for the ALU. If 0, the operand is from the second read port of the register file; if 1, the operand is the sign-extended 16-bit immediate value from the instruction.\n- `Branch` (1 bit): When set to 1, enables logic for a conditional branch instruction.\n- `ALUOp` (2 bits): A 2-bit signal, `ALUOp_1` `ALUOp_0`, that specifies the ALU's operation. The codes are: `00` for bitwise AND, `01` for bitwise OR, `10` for addition, and `11` for subtraction.\n\nA new instruction, `STOR_OFFSET Rsrc, immediate(Rbase)`, has been added to the instruction set. This instruction performs the following operation: it retrieves the value from register `Rsrc` and stores it in memory at an address calculated by adding the value in register `Rbase` to the sign-extended `immediate` value. The operation can be described as: `Memory[Register[Rbase] + sign_extend(immediate)] - Register[Rsrc]`.\n\nYour task is to determine the state of the primary control signals required for the processor to correctly execute the `STOR_OFFSET` instruction. Provide the binary values for the signals in the following specific order: (`RegWrite`, `ALUSrc`, `MemtoReg`, `MemRead`, `MemWrite`, `Branch`, `ALUOp_1`, `ALUOp_0`).", "solution": "The instruction semantics are given by:\n$$\n\\text{Memory}\\big[\\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate})\\big] \\leftarrow \\text{Register}[R_{\\text{src}}].\n$$\nTo implement this on the single-cycle datapath, the following actions must occur in one cycle:\n1) Read two registers: $\\text{Register}[R_{\\text{base}}]$ (for address computation) and $\\text{Register}[R_{\\text{src}}]$ (the data to store).\n2) Compute the effective address using the ALU:\n$$\n\\text{ALU\\_result} = \\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate}).\n$$\nThis requires selecting the sign-extended immediate as the ALU second operand and selecting the ALU operation as addition.\n3) Perform a memory write at the computed address with write data equal to $\\text{Register}[R_{\\text{src}}]$.\n4) Do not write any value back to the register file, since a store does not produce a register result.\n\nMapping these requirements to control signals:\n- RegWrite: No register write-back is performed for a store, hence set to $0$.\n- ALUSrc: The ALU second operand must be the sign-extended immediate for base-plus-offset addressing, hence set to $1$.\n- MemtoReg: The register write-back data source is irrelevant because RegWrite is $0$; this is a don't-care. It can be set to $0$ without affecting correctness.\n- MemRead: A store does not read from memory, hence set to $0$.\n- MemWrite: A store writes to memory, hence set to $1$.\n- Branch: This instruction is not a branch, hence set to $0$.\n- ALUOp: The ALU must perform addition for effective address calculation. Given the encoding, addition corresponds to $\\text{ALUOp} = 10$, i.e., $\\text{ALUOp\\_1} = 1$ and $\\text{ALUOp\\_0} = 0$.\n\nTherefore, in the specified order $(\\text{RegWrite}, \\text{ALUSrc}, \\text{MemtoReg}, \\text{MemRead}, \\text{MemWrite}, \\text{Branch}, \\text{ALUOp\\_1}, \\text{ALUOp\\_0})$, the required control values are:\n$$\n(0, 1, 0, 0, 1, 0, 1, 0).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0  1  0  0  1  0  1  0\\end{pmatrix}}$$", "id": "1926288"}, {"introduction": "While the single-cycle model is a powerful learning tool, real-world processors divide instructions into multiple, simpler steps managed by a multi-cycle control unit. This approach not only allows for reusing hardware components across clock cycles but also provides a mechanism to handle components with unpredictable delays, such as main memory. This problem [@problem_id:1926245] asks you to trace the execution path through a Finite State Machine (FSM) that must pause and wait for a `$MemReady$` signal from a slow memory unit. Mastering this concept is key to understanding how processors remain synchronized with the rest of the computer system.", "problem": "Consider a simplified multi-cycle processor designed to execute a small instruction set. The processor's control unit is implemented as a Finite State Machine (FSM). The FSM has the following states, identified by numbers:\n- State 0: Instruction Fetch (Fetches the instruction from memory).\n- State 1: Instruction Decode (Decodes the instruction and fetches source registers).\n- State 2: Execute (Performs an Arithmetic Logic Unit, or ALU, operation for an R-type instruction).\n- State 3: R-type Write-back (Writes the ALU result back to a register).\n- State 4: Memory Address Calculation (Calculates the effective memory address for a load or store instruction).\n- State 5: Memory Read (Reads data from the memory location specified by the ALU).\n- State 6: Memory Write-back (Writes the data fetched from memory back to a register).\n\nThe processor's memory unit can be slow. To handle this, the FSM has a special behavior in State 5. When the FSM is in State 5, it checks an input signal called `MemReady`.\n- If `MemReady` is 1, it means the memory has successfully provided the data, and the FSM transitions to State 6 on the next clock edge.\n- If `MemReady` is 0, it means the memory is still processing the read request, and the FSM remains in State 5 on the next clock edge, effectively waiting for the memory.\n\nAssume that a `load` instruction is being executed. The memory is slow and requires exactly one extra clock cycle to provide the data. This means that after the FSM first enters State 5, the `MemReady` signal will be 0 for one full clock cycle, and will become 1 at the end of that cycle.\n\nGiven this scenario, what is the complete sequence of states (represented by their numbers) that the control unit FSM will pass through to execute this single `load` instruction, starting from the beginning of the instruction execution (State 0)?\n\nA. 0, 1, 4, 5, 6\n\nB. 0, 1, 2, 3\n\nC. 0, 1, 4, 5, 5, 6\n\nD. 0, 1, 5, 6\n\nE. 0, 1, 4, 5, 4, 6", "solution": "A load instruction in this multi-cycle FSM follows the standard path of instruction fetch, decode, address calculation, memory read, and register write-back. With state numbers, the nominal sequence when memory responds immediately is $0 \\rightarrow 1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$.\n\nHowever, the transition rule in State $5$ is conditional on the input $MemReady$: while in State $5$, if $MemReady=1$, the FSM transitions to State $6$ on the next clock edge; if $MemReady=0$, the FSM remains in State $5$ on the next clock edge. The problem specifies that after the FSM first enters State $5$, $MemReady=0$ for one full clock cycle and becomes $1$ at the end of that cycle. Consequently, upon first being in State $5$, the FSM observes $MemReady=0$ at the next clock edge and thus stays in State $5$ for one extra cycle. After that waiting cycle, $MemReady=1$, so on the next clock edge the FSM transitions from State $5$ to State $6$.\n\nTherefore, starting from the beginning of the instruction execution, the complete sequence of states is:\n$0$ (fetch) $\\rightarrow$ $1$ (decode) $\\rightarrow$ $4$ (address calculation) $\\rightarrow$ $5$ (memory read, initial entry) $\\rightarrow$ $5$ (stall due to $MemReady=0$) $\\rightarrow$ $6$ (write-back).\n\nThis matches option C.", "answer": "$$\\boxed{C}$$", "id": "1926245"}, {"introduction": "A processor's instruction set is not static; computer architects constantly seek to improve performance by adding powerful, specialized instructions. This advanced exercise challenges you to go beyond merely controlling a given datapath and instead to modify it. You are tasked with implementing a 'zero-overhead loop' instruction, which requires analyzing the existing hardware's capabilities and limitations [@problem_id:1926243]. Successfully designing the necessary changes to the datapath and its control FSM demonstrates a comprehensive grasp of the deep interplay between a processor's hardware and the instructions it can execute.", "problem": "A digital systems engineer is tasked with augmenting a classic multi-cycle processor datapath to include a specialized \"zero-overhead loop\" instruction. The baseline processor has a datapath consisting of a Program Counter (PC), a main memory unit, a register file with 32 registers, and an Arithmetic Logic Unit (ALU). It executes instructions through a sequence of states managed by a Finite State Machine (FSM).\n\nThe baseline datapath has the following key components and control signals:\n- **PC:** Updated based on the `PCSource` control signal. `PCWrite` enables the update.\n- **Register File:** Has two read ports (for operands A and B) and one write port. `RegWrite` enables a write operation. The destination register is selected by the `RegDst` MUX.\n- **ALU:** Performs arithmetic/logic operations. Its inputs are controlled by `ALUSrcA` and `ALUSrcB` MUXes. Its operation is determined by the `ALUOp` signal. It has a `Zero` output flag that is asserted when the ALU result is zero.\n- **MUXes:**\n    - `RegDst` MUX: Selects the destination register number between the `rt` field (`IR[20:16]`) and the `rd` field (`IR[15:11]`).\n    - `ALUSrcB` MUX: Selects the second ALU operand between the B register output and the sign-extended 16-bit immediate from the instruction register (`IR`).\n    - `MemtoReg` MUX: Selects the data to be written to the register file, either from the ALU output or from the data memory.\n    - `PCSource` MUX: Selects the next PC value from among (PC+4), the branch target address (from the ALU output), or the jump target address.\n\nThe baseline FSM already implements standard R-type (`add`, `sub`), memory-access (`lw`, `sw`), and conditional branch (`beq`) instructions. For the `beq rs, rt, offset` instruction, the branch target address `PC + 4 + (sign_extend(offset)  2)` is calculated in the Decode state and the branch is taken based on the `Zero` flag from a subsequent comparison of `rs` and `rt`.\n\nThe new instruction to be added is `LOOP Rx, offset`. Its 32-bit machine code format is:\n`Opcode (bits 31-26) | rs (25-21) | Unused (20-16) | immediate (15-0)`\nThe register operand `Rx` is specified by the `rs` field.\n\nThe `LOOP` instruction performs the following two actions atomically as a single instruction:\n1.  Decrement the value in register `Rx`: `Rx ← Rx - 1`.\n2.  Conditional Branch: If the new value of `Rx` is not zero, the PC is updated to the branch target address, calculated as `PC + 4 + (sign_extend(offset)  2)`. If the new value of `Rx` is zero, the PC proceeds to the next instruction sequentially (`PC + 4`).\n\nYour task is to determine the minimal set of modifications required to both the datapath and the control FSM to implement this `LOOP` instruction efficiently. Assuming the baseline FSM for `lw`, `sw`, R-type, and `beq` instructions contains 10 states (States 0 through 9), which of the following describes the necessary changes?\n\nA. 1 new state is added to the FSM; the `ALUSrcB` MUX is modified to select a constant '1'; and the `PCSource` MUX is modified to select the `rs` field.\n\nB. 2 new states are added to the FSM; the `MemtoReg` MUX is modified to select the `rs` field; and the `RegDst` MUX is modified to select a constant '1'.\n\nC. 1 new state is added to the FSM; one new ALU designed for decrementing is added; and the `RegDst` MUX is modified to select the `rs` field.\n\nD. 2 new states are added to the FSM; the `ALUSrcB` MUX is modified to select a constant '1'; and the `RegDst` MUX is modified to select the `rs` field.\n\nE. 2 new states are added to the FSM; only the `ALUSrcB` MUX must be modified to select a constant '1'. No other datapath modifications are needed.", "solution": "We begin by identifying the precise micro-operations required by the new instruction and how they map onto the existing datapath and control.\n\nThe instruction is $LOOP\\ R_{x},\\ \\text{offset}$ encoded as:\n$$\n\\text{Opcode}[31:26]\\ |\\ rs[25:21]\\ |\\ \\text{unused}[20:16]\\ |\\ \\text{immediate}[15:0],\n$$\nwhere $rs$ names the loop counter register $R_{x}$. Its semantics are:\n1) Decrement: $R[rs] \\leftarrow R[rs] - 1$.\n2) Conditional branch on the new value: if $R[rs] \\neq 0$, update $PC$ to the branch target; otherwise fall through.\n\nThe branch target address is the same form as for $beq$:\n$$\n\\text{BT} = PC + 4 + \\left(\\text{sign\\_extend}(\\text{offset}) \\ll 2\\right).\n$$\n\nBaseline datapath and FSM notes:\n- The baseline already computes $\\text{BT}$ in the Decode state (as per the given $beq$ behavior) and later uses a comparison state to derive the branch decision from the ALU’s $Zero$ flag.\n- The ALU inputs are selected by $ALUSrcA$ and $ALUSrcB$; currently, $ALUSrcB$ selects between the $B$ register and the sign-extended immediate. There is no path for a constant $1$.\n- The register write destination is selected by $RegDst$ between $IR[20:16]$ ($rt$) and $IR[15:11]$ ($rd$); there is no selection of $IR[25:21]$ ($rs$).\n- The $PCSource$ MUX already selects among $PC+4$, the branch target, and the jump target; no new PC source tied to a register is needed.\n- The beq’s branch decision uses the ALU’s $Zero$ flag in a later state; for LOOP we need to branch on “not zero,” which can be handled by control (invert the sense of $Zero$) without datapath changes.\n\nRequired datapath modifications:\n- To decrement $R[rs]$ using the existing ALU, we must be able to compute $R[rs] - 1$. Since the immediate field is the branch offset and cannot be repurposed to encode $-1$, the ALU needs access to a constant $1$. Therefore, $ALUSrcB$ must be extended to include a constant $1$ selection. With $ALUOp$ set appropriately (subtract or add with two’s-complement), this yields the decrement.\n- The destination register for the write-back must be $rs$ ($IR[25:21]$). The baseline $RegDst$ supports only $rt$ and $rd$. Therefore, $RegDst$ must be extended to include a third option selecting $IR[25:21]$.\n\nNo other datapath changes are necessary:\n- No new ALU is needed; the existing ALU can perform the decrement once $ALUSrcB$ can supply $1$.\n- $PCSource$ does not need a new input; the branch target path already exists from decode through the standard branch-address datapath.\n- $MemtoReg$ does not need a new input; for this instruction the write-back uses the ALU result path, as with R-type arithmetic (i.e., not from data memory).\n\nFSM sequencing and number of new states:\n- State 0 (Fetch): unchanged; fetch instruction, update $PC$ to $PC+4$ as usual.\n- State 1 (Decode): unchanged structure; read $R[rs]$ (into $A$), compute and store the branch target\n$$\n\\text{BT} = PC + 4 + \\left(\\text{sign\\_extend}(\\text{offset}) \\ll 2\\right)\n$$\ninto the ALUOut-like latch used for $beq$.\n- New execute/branch-decision state: configure $ALUSrcA$ to select $A=R[rs]$, $ALUSrcB$ to select constant $1$, and $ALUOp$ to perform a decrement ($R[rs] - 1$). In this state, the ALU result is the new $R[rs]$ and the $Zero$ flag corresponds to “new value equals zero.” The branch decision “branch if not zero” uses the same conditional PC update mechanism as $beq$ but with the sense inverted in control (no datapath changes). The branch target is supplied by the previously latched address from Decode via the existing $PCSource$ selection.\n- Write-back timing: in the classic multicycle organization (with ALU result captured in an ALUOut register and $MemtoReg$ sourcing that register), register writes happen in a distinct write-back state. Therefore, to write $R[rs] \\leftarrow R[rs]-1$, a second new state is used to assert $RegWrite$ with $RegDst$ selecting $rs$ and $MemtoReg$ selecting the ALU result path. This preserves the standard separation of execute/decision and write-back.\n\nThus, minimally:\n- Datapath changes: add constant $1$ option to $ALUSrcB$; add $rs$ option to $RegDst$.\n- FSM changes: add two new states, one to perform the decrement and branch decision using the new ALUSrcB option and existing branch-target datapath, and one to perform the register write-back to $rs$.\n\nThis exactly matches option D, and the other options are incorrect for the following reasons:\n- A: Incorrectly claims $PCSource$ must select $rs$; also omits the needed $RegDst$ change to target $rs$.\n- B: Proposes unrelated MemtoReg and RegDst changes (constant 1 as destination) that do not implement LOOP semantics.\n- C: Adds a new decrement ALU unnecessarily and omits the necessary ALUSrcB modification; not minimal.\n- E: Omits the essential $RegDst$ modification to select $rs$.", "answer": "$$\\boxed{D}$$", "id": "1926243"}]}