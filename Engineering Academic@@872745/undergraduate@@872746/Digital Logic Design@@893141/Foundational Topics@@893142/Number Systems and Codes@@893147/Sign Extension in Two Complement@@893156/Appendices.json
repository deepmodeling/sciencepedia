{"hands_on_practices": [{"introduction": "One of the most frequent applications of sign extension occurs during arithmetic operations involving numbers of different bit widths. Before a CPU can add a 4-bit number to an 8-bit number, it must first convert them to a common format without changing their values. This practice [@problem_id:1913334] walks you through this essential process, showing how to correctly sign-extend a negative number to ensure the final sum is accurate.", "problem": "A simplified Central Processing Unit (CPU) contains an 8-bit adder designed to work with integers in two's complement representation. The CPU needs to compute the sum of two numbers, $X$ and $Y$. The number $X$ is stored in a 4-bit register and has the value $1010_2$. The number $Y$ is stored in an 8-bit register and has the value $00010110_2$.\n\nTo perform the operation, the 4-bit number $X$ must first be converted to an equivalent 8-bit two's complement representation before being sent to the adder. The adder then computes the sum $S = X + Y$.\n\nWhat is the resulting 8-bit two's complement binary value of the sum $S$?\n\nA. $00010000_2$\n\nB. $00100000_2$\n\nC. $11110000_2$\n\nD. $11001000_2$\n\nE. $00000000_2$", "solution": "We work in two's complement arithmetic.\n\n1) Interpret the 4-bit number $X=1010_{2}$ in two's complement. For an $n$-bit two's complement number with bits $b_{n-1}\\dots b_{0}$, the value is\n$$\nv=-b_{n-1}2^{n-1}+\\sum_{k=0}^{n-2} b_{k}2^{k}.\n$$\nFor $X=1010_{2}$ with $n=4$, we have $b_{3}=1$, $b_{1}=1$, and $b_{2}=b_{0}=0$, hence\n$$\nX=-1\\cdot 2^{3}+1\\cdot 2^{1}=-8+2=-6.\n$$\n\n2) Sign-extend $X$ from 4 bits to 8 bits. In two's complement, sign extension replicates the most significant bit. Since the sign bit of $X$ is $1$, the 8-bit representation is\n$$\nX_{(8\\text{-bit})}=11111010_{2}.\n$$\n\n3) Interpret $Y=00010110_{2}$ as an 8-bit two's complement number. Its sign bit is $0$, so it is nonnegative:\n$$\nY=2^{4}+2^{2}+2^{1}=16+4+2=22.\n$$\n\n4) Compute the sum $S=X+Y$:\n$$\nS=-6+22=16.\n$$\nIn 8-bit two's complement, $16$ is\n$$\nS=00010000_{2}.\n$$\nEquivalently, direct binary addition confirms this:\n$$\n11111010_{2}+00010110_{2}=00010000_{2},\n$$\nwith a carry out that is ignored in fixed-width two's complement addition; no overflow occurs because the addends have opposite signs.\n\nThus, the correct option is A.", "answer": "$$\\boxed{A}$$", "id": "1913334"}, {"introduction": "Understanding a rule is one thing; understanding why it's the *only* correct rule is another. This thought experiment [@problem_id:1960202] presents a scenario with a faulty bus-expander that uses a fixed bit for extension instead of the sign bit. By deriving a closed-form expression for the resulting arithmetic error, you will see precisely why replicating the sign bit is non-negotiable for preserving a number's value.", "problem": "In the design of a specialized digital signal processor, a core component is a bus-expander module. This module's function is to convert an $M$-bit data word into an $N$-bit data word, where $N  M$. Both the input and output words are used to represent signed integers using the two's complement representation.\n\nLet the input be an $M$-bit word, represented by the bit vector $A = (a_{M-1}, a_{M-2}, \\dots, a_0)$, where $a_{M-1}$ is the most significant bit (the sign bit). The numerical value of an arbitrary $X$-bit two's complement word $W = (w_{X-1}, \\dots, w_0)$ is defined as $V(W) = -w_{X-1} 2^{X-1} + \\sum_{i=0}^{X-2} w_i 2^i$.\n\nA design flaw has been discovered in the bus-expander logic. Instead of performing a standard sign extension, the circuit constructs the $N$-bit output word $B = (b_{N-1}, b_{N-2}, \\dots, b_0)$ from the input word $A$ according to the following rules:\n1. The lower $M$ bits of the output word $B$ are a direct copy of the bits of the input word $A$. That is, $b_i = a_i$ for all integers $i$ such that $0 \\leq i \\leq M-1$.\n2. The upper $N-M$ bits of the output word $B$, which are the \"extension bits,\" are all set to a fixed, constant bit value $k$, where $k \\in \\{0, 1\\}$. That is, $b_i = k$ for all integers $i$ such that $M \\leq i \\leq N-1$.\n\nLet $V_A$ be the numerical value represented by the input word $A$, and $V_B$ be the numerical value represented by the output word $B$. Your task is to derive a closed-form analytic expression for the error introduced by this faulty logic, which is defined as the difference $\\Delta V = V_B - V_A$. Your final expression should be in terms of the input sign bit $a_{M-1}$, the fixed padding bit $k$, and the input bit-width $M$.", "solution": "By the given two’s complement definition, for any $X$-bit word $W=(w_{X-1},\\dots,w_{0})$,\n$$\nV(W)=-w_{X-1}2^{X-1}+\\sum_{i=0}^{X-2}w_{i}2^{i}.\n$$\nFor the $M$-bit input $A=(a_{M-1},\\dots,a_{0})$,\n$$\nV_{A}=-a_{M-1}2^{M-1}+\\sum_{i=0}^{M-2}a_{i}2^{i}.\n$$\nFor the $N$-bit output $B=(b_{N-1},\\dots,b_{0})$ with $b_{i}=a_{i}$ for $0\\leq i\\leq M-1$ and $b_{i}=k$ for $M\\leq i\\leq N-1$,\n$$\nV_{B}=-k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\sum_{i=M}^{N-2}2^{i}.\n$$\nUsing the geometric series identity $\\sum_{i=p}^{q}2^{i}=2^{p}\\left(2^{q-p+1}-1\\right)$ with $p=M$ and $q=N-2$, we get\n$$\n\\sum_{i=M}^{N-2}2^{i}=2^{M}\\left(2^{N-1-M}-1\\right).\n$$\nHence\n$$\nV_{B}=-k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\left[2^{M}\\left(2^{N-1-M}-1\\right)\\right]\n= -k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\,2^{N-1}-k\\,2^{M}.\n$$\nThe terms $\\pm k\\,2^{N-1}$ cancel, yielding\n$$\nV_{B}=\\sum_{i=0}^{M-1}a_{i}2^{i}-k\\,2^{M}.\n$$\nTherefore, the error is\n$$\n\\Delta V=V_{B}-V_{A}=\\left(\\sum_{i=0}^{M-1}a_{i}2^{i}\\right)-k\\,2^{M}-\\left(-a_{M-1}2^{M-1}+\\sum_{i=0}^{M-2}a_{i}2^{i}\\right).\n$$\nSimplifying the sums,\n$$\n\\Delta V=\\left(\\sum_{i=0}^{M-2}a_{i}2^{i}+a_{M-1}2^{M-1}\\right)-k\\,2^{M}+\\;a_{M-1}2^{M-1}-\\sum_{i=0}^{M-2}a_{i}2^{i}\n=2\\,a_{M-1}2^{M-1}-k\\,2^{M}.\n$$\nThus,\n$$\n\\Delta V=2^{M}\\left(a_{M-1}-k\\right).\n$$\nThis expression depends only on $a_{M-1}$, $k$, and $M$, and is independent of $N$ for all $NM$.", "answer": "$$\\boxed{2^{M}\\left(a_{M-1}-k\\right)}$$", "id": "1960202"}, {"introduction": "How can we be sure that a piece of hardware is performing sign extension correctly? The answer lies in building a verification module that checks the operation at the bit level. This exercise [@problem_id:1960208] challenges you to translate the definition of sign extension into a formal Boolean expression, a task that is fundamental to digital circuit design and hardware verification.", "problem": "In a modern computing system, a 32-bit Central Processing Unit (CPU) needs to interface with a legacy peripheral device that provides data in a 12-bit format. Both the CPU and the peripheral use two's complement representation for signed integers. An interface coprocessor is tasked with reading the 12-bit value from the peripheral and loading it into a 32-bit CPU register. This process requires sign extension.\n\nLet the 12-bit value from the peripheral be denoted by $A$, with its bits represented as $a_{11}a_{10}...a_0$, where $a_{11}$ is the sign bit. The value of $A$ is given by $-a_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} a_i \\cdot 2^i$.\n\nLet the 32-bit value in the CPU register be denoted by $B$, with its bits represented as $b_{31}b_{30}...b_0$, where $b_{31}$ is the sign bit.\n\nA correct sign extension from a 12-bit number $A$ to a 32-bit number $B$ requires two conditions to be met:\n1. The lower 12 bits of $B$ must be identical to the bits of $A$.\n2. The upper 20 bits of $B$ (from bit 12 to bit 31) must all be identical to the sign bit of $A$, which is $a_{11}$.\n\nYou are tasked with designing a hardware verification module. This module receives all 44 bits (the 12 bits of $A$ and the 32 bits of $B$) as input and produces a single output signal, $V$. The signal $V$ must be logic '1' if $B$ is a correct sign extension of $A$, and '0' otherwise.\n\nDerive the simplified Boolean expression for the output signal $V$. The expression should be formulated in terms of the individual bits $a_i$ and $b_j$. For logical equivalence (XNOR), you may use the biconditional symbol $\\Leftrightarrow$. For conjunction (AND), you may use the symbol $\\land$ or product notation.", "solution": "We are to verify that a 32-bit value $B$ is the correct sign extension of a 12-bit two’s-complement value $A$. By definition of sign extension:\n1. The lower 12 bits must be copied directly: for all $i \\in \\{0,1,\\dots,11\\}$, we require $b_{i} = a_{i}$.\n2. All the upper 20 bits must replicate the sign bit $a_{11}$: for all $j \\in \\{12,13,\\dots,31\\}$, we require $b_{j} = a_{11}$.\n\nTo check exact bit equality in hardware, a natural primitive is the logical equivalence (XNOR), written as the biconditional. For any pair of bits $x,y \\in \\{0,1\\}$, the condition “$x$ equals $y$” is captured by $x \\Leftrightarrow y$, which is logically equivalent to $(x \\land y) \\lor (\\lnot x \\land \\lnot y)$.\n\nTherefore, the verification signal $V$ must be the conjunction of all required per-bit equalities:\n- For the lower 12 bits: $\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)$.\n- For the upper 20 bits: $\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)$.\n\nCombining these two independent conditions with a conjunction yields the final Boolean expression:\n$$\nV \\;=\\; \\left(\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)\\right) \\land \\left(\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)\\right).\n$$\nThis expression is already simplified in terms of the allowed primitives, and directly reflects the required conditions for correct sign extension.", "answer": "$$\\boxed{\\left(\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)\\right) \\land \\left(\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)\\right)}$$", "id": "1960208"}]}