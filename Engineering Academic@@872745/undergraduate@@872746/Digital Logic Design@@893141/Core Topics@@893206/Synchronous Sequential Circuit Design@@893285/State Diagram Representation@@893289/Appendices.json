{"hands_on_practices": [{"introduction": "This first practice exercise introduces a fundamental application of finite state machines: detecting a specific sequence in a stream of data. We will design a Mealy machine that identifies the sequence '111', a common task in digital communication and control systems. This problem [@problem_id:1962078] provides an excellent opportunity to practice defining states based on the progress toward a target and mapping transitions and outputs, which in a Mealy machine, depend on both the current state and the input.", "problem": "A digital system includes a \"burst signal trigger\" designed to monitor a single-bit serial data stream. The trigger has one input, $x$, and one output, $z$. The system operates synchronously with a clock. The trigger's function is to set its output $z$ to a high logic level ('1') if and only if the current input bit is '1' and the two immediately preceding input bits were also '1's. This functionality must account for overlapping sequences; for instance, an input stream of '...011110...' should produce an output stream of '...000110...'. At all other times, the output $z$ must be at a low logic level ('0').\n\nThis behavior can be described by a finite state machine. Assuming the system is designed as a Mealy machine with the minimum number of states, which of the following state transition tables correctly represents its behavior? The states are defined as:\n- $S_0$: The initial or reset state. The required sequence of '1's has been broken.\n- $S_1$: The most recent input bit was a '1'.\n- $S_2$: The two most recent input bits were '11'.\n\nThe tables are presented in the format (Present State, Input $x$, Next State, Output $z$).\n\nA)\n($S_0$, 0, $S_0$, 0)\n($S_0$, 1, $S_1$, 0)\n($S_1$, 0, $S_0$, 0)\n($S_1$, 1, $S_2$, 0)\n($S_2$, 0, $S_0$, 0)\n($S_2$, 1, $S_2$, 1)\n\nB)\n($S_0$, 0, $S_0$, 0)\n($S_0$, 1, $S_1$, 0)\n($S_1$, 0, $S_0$, 0)\n($S_1$, 1, $S_2$, 0)\n($S_2$, 0, $S_0$, 0)\n($S_2$, 1, $S_0$, 1)\n\nC)\n($S_0$, 0, $S_0$, 0)\n($S_0$, 1, $S_1$, 0)\n($S_1$, 0, $S_1$, 0)\n($S_1$, 1, $S_2$, 0)\n($S_2$, 0, $S_0$, 0)\n($S_2$, 1, $S_2$, 1)\n\nD)\n($S_0$, 0, $S_0$, 0)\n($S_0$, 1, $S_1$, 0)\n($S_1$, 0, $S_0$, 0)\n($S_1$, 1, $S_2$, 0)\n($S_2$, 0, $S_0$, 0)\n($S_2$, 1, $S_1$, 1)\n\nE)\n($S_0$, 0, $S_0$, 0)\n($S_0$, 1, $S_1$, 1)\n($S_1$, 0, $S_0$, 0)\n($S_1$, 1, $S_2$, 1)\n($S_2$, 0, $S_0$, 0)\n($S_2$, 1, $S_2$, 1)", "solution": "The problem requires us to design a Mealy-type finite state machine that detects the sequence '111' in a serial bitstream, including overlapping occurrences. A Mealy machine's output is a function of its current state and the current input. We need to determine the state transitions and the corresponding outputs.\n\nThe states are defined based on the progress towards detecting the '111' sequence:\n- $S_0$: The reset state. No prefix of the target sequence has been detected. This is the state after receiving a '0' or at startup.\n- $S_1$: The last input was a '1'. This represents having seen the prefix '1'.\n- $S_2$: The last two inputs were '11'. This represents having seen the prefix '11'.\n\nLet's analyze the transitions for each state based on the input $x \\in \\{0, 1\\}$.\n\n**Analysis of State $S_0$ (Reset State):**\n- If the current input is $x=0$: The machine has not seen a '1' that could start the sequence. The system remains in the reset state $S_0$. The output $z$ must be 0.\n  - Transition: (Present State: $S_0$, Input: 0) $\\rightarrow$ (Next State: $S_0$, Output: 0).\n- If the current input is $x=1$: This is the first '1' of a potential sequence. The machine transitions to state $S_1$ to remember that it has seen one '1'. The full sequence is not yet detected, so the output $z$ is 0.\n  - Transition: (Present State: $S_0$, Input: 1) $\\rightarrow$ (Next State: $S_1$, Output: 0).\n\n**Analysis of State $S_1$ (Seen a single '1'):**\n- If the current input is $x=0$: The sequence is broken because a '0' has been received. The machine must return to the reset state $S_0$. The output $z$ is 0.\n  - Transition: (Present State: $S_1$, Input: 0) $\\rightarrow$ (Next State: $S_0$, Output: 0).\n- If the current input is $x=1$: The machine was in state $S_1$ (meaning the previous input was '1') and now receives another '1'. The sequence now ends in '11'. The machine transitions to state $S_2$. The full '111' sequence is not yet complete, so the output $z$ is 0.\n  - Transition: (Present State: $S_1$, Input: 1) $\\rightarrow$ (Next State: $S_2$, Output: 0).\n\n**Analysis of State $S_2$ (Seen '11'):**\n- If the current input is $x=0$: The sequence is broken. The machine must return to the reset state $S_0$. The output $z$ is 0.\n  - Transition: (Present State: $S_2$, Input: 0) $\\rightarrow$ (Next State: $S_0$, Output: 0).\n- If the current input is $x=1$: The machine was in state $S_2$ (previous two inputs were '11') and now receives a '1'. This completes the '111' sequence. Therefore, the output $z$ must be 1. The problem specifies that the detector must handle overlapping sequences. Consider the input '1111'. The first '111' should produce an output of 1. At this point, the last two inputs received are '11'. This is precisely the condition for being in state $S_2$. Therefore, to detect the next '111' sequence (which consists of the last two '1's of the first sequence and the new '1'), the machine must transition back to state $S_2$.\n  - Transition: (Present State: $S_2$, Input: 1) $\\rightarrow$ (Next State: $S_2$, Output: 1).\n\n**Compiling the State Table:**\nBy combining all the transitions derived above, we can construct the complete state transition table:\n\n| Present State | Input $x$ | Next State | Output $z$ |\n|---------------|-----------|------------|------------|\n| $S_0$         | 0         | $S_0$      | 0          |\n| $S_0$         | 1         | $S_1$      | 0          |\n| $S_1$         | 0         | $S_0$      | 0          |\n| $S_1$         | 1         | $S_2$      | 0          |\n| $S_2$         | 0         | $S_0$      | 0          |\n| $S_2$         | 1         | $S_2$      | 1          |\n\nThis table exactly matches the one provided in option A. Let's analyze the other options to confirm they are incorrect.\n- Option B is a non-overlapping detector because on ($S_2$, 1), it transitions to $S_0$, resetting the sequence.\n- Option C is incorrect because the transition ($S_1$, 0, $S_1$, 0) is wrong; receiving a '0' must break the sequence and reset to $S_0$.\n- Option D incorrectly transitions from $S_2$ to $S_1$ on input '1'. This would fail to detect overlapping sequences like '1111' correctly. It would detect '111' and then transition to a state 'saw one 1', failing to recognize that the last two inputs were '11'.\n- Option E incorrectly sets the output to 1 for transitions ($S_0$, 1) and ($S_1$, 1), which is not what the problem specifies. The output should only be 1 when the full '111' sequence is complete.\n\nTherefore, option A is the only correct representation of the specified burst signal trigger.", "answer": "$$\\boxed{A}$$", "id": "1962078"}, {"introduction": "Moving from Mealy to Moore machines, this problem explores a scenario where the output is strictly determined by the machine's current state. You will analyze a Moore FSM designed as a data integrity checker that flags an error after a sequence of five or more '1's. By tracing the output for a given input stream, this exercise [@problem_id:1962047] highlights the characteristic timing of Moore machines and solidifies the concept of state as a representation of past input history.", "problem": "A digital system for monitoring data integrity includes a bitstream anomaly checker. This checker is implemented as a synchronous Finite State Machine (FSM). The FSM processes a serial binary input stream, denoted by `X`, one bit per clock cycle. It produces a single binary output, `E`, which serves as an error flag.\n\nThe system is designed as a Moore machine, where the output is determined solely by the machine's current state. The error flag `E` must be asserted (set to `1`) if and only if the machine is in a state corresponding to having just received a sequence of five or more consecutive `1`s on the input `X`. In all other states, `E` must be `0`.\n\nThe FSM begins operation in a designated initial state, `S_reset`, which represents the condition where no consecutive `1`s have been detected yet (e.g., after power-on or after receiving a `0`).\n\nConsider the system at discrete time steps $t=1, 2, 3, ...$. The state of the machine at time $t$ is denoted $S(t)$, and the input bit received at that time is $X(t)$. The machine's output at time $t$, denoted $E(t)$, is a function of the current state $S(t)$. The state for the next cycle, $S(t+1)$, is determined by the current state $S(t)$ and the current input $X(t)$. The initial state is $S(1) = S_{\\text{reset}}$.\n\nGiven the 14-bit input sequence `X` for $t=1$ to $t=14$ as `11110111110111`, determine the corresponding 14-bit output sequence `E`. Express your answer as a single binary string of length 14, representing the sequence $E(1)E(2)...E(14)$.", "solution": "We can model the Moore FSM with states that encode the current run length of consecutive ones. Let's define $c(t)$ to be the count of consecutive ones represented by the current state $S(t)$. The necessary counts are $c(t)\\in\\{0, 1, 2, 3, 4, 5^+\\}$, where $c(t)=0$ corresponds to $S_{\\text{reset}}$ and $c(t)=5^+$ represents a count of five or more.\n\nThe Moore output $E(t)$ is a function of the current state's count $c(t)$:\n$$E(t)=\\begin{cases}\n1,& \\text{if } c(t)=5^+,\\\\\n0,& \\text{otherwise}.\n\\end{cases}$$\nThe next-state logic, determining $c(t+1)$ from $c(t)$ and $X(t)$, is:\n- If $X(t)=0$, the count resets: $c(t+1)=0$.\n- If $X(t)=1$, the count increments, saturating at $5^+$: $c(t+1) = \\min(c(t) + 1, 5^+)$.\n\nThe initial condition is $S(1)=S_{\\text{reset}}$, which means $c(1)=0$.\n\nWe can now process the input sequence $X(1 \\dots 14) = 11110111110111$ step by step, first determining the output $E(t)$ from the current state count $c(t)$, and then calculating the next state count $c(t+1)$ based on the input $X(t)$.\n\n- $t=1$: $c(1)=0$. Output $E(1)=0$. Input $X(1)=1 \\implies c(2)=1$.\n- $t=2$: $c(2)=1$. Output $E(2)=0$. Input $X(2)=1 \\implies c(3)=2$.\n- $t=3$: $c(3)=2$. Output $E(3)=0$. Input $X(3)=1 \\implies c(4)=3$.\n- $t=4$: $c(4)=3$. Output $E(4)=0$. Input $X(4)=1 \\implies c(5)=4$.\n- $t=5$: $c(5)=4$. Output $E(5)=0$. Input $X(5)=0 \\implies c(6)=0$.\n- $t=6$: $c(6)=0$. Output $E(6)=0$. Input $X(6)=1 \\implies c(7)=1$.\n- $t=7$: $c(7)=1$. Output $E(7)=0$. Input $X(7)=1 \\implies c(8)=2$.\n- $t=8$: $c(8)=2$. Output $E(8)=0$. Input $X(8)=1 \\implies c(9)=3$.\n- $t=9$: $c(9)=3$. Output $E(9)=0$. Input $X(9)=1 \\implies c(10)=4$.\n- $t=10$: $c(10)=4$. Output $E(10)=0$. Input $X(10)=1 \\implies c(11)=5^+$.\n- $t=11$: $c(11)=5^+$. Output $E(11)=1$. Input $X(11)=0 \\implies c(12)=0$.\n- $t=12$: $c(12)=0$. Output $E(12)=0$. Input $X(12)=1 \\implies c(13)=1$.\n- $t=13$: $c(13)=1$. Output $E(13)=0$. Input $X(13)=1 \\implies c(14)=2$.\n- $t=14$: $c(14)=2$. Output $E(14)=0$. Input $X(14)=1 \\implies c(15)=3$.\n\nThe resulting output sequence $E(1 \\dots 14)$ is $00000000001000$.", "answer": "$$\\boxed{00000000001000}$$", "id": "1962047"}, {"introduction": "This final practice problem presents an advanced design challenge that tests a deeper understanding of state definition. Instead of detecting a fixed sequence, the task is to design a Mealy machine that recognizes a parameterized pattern of the form $b_1 b_2 b_3 b_1 b_2$. Solving this problem [@problem_id:1962028] requires you to think critically about what information the FSM must remember—its 'state'—to make correct decisions, pushing beyond simple sequence counting to more abstract state encoding.", "problem": "A synchronous digital system is designed to monitor a continuous serial stream of binary data. The system employs a Mealy-type finite state machine (FSM) to detect a specific class of 5-bit sequences. The FSM has a single data input, `X`, where one bit arrives per clock cycle, and a single output, `Z`.\n\nThe output `Z` is to be asserted to $1$ if and only if the five most recently received bits (including the current bit at input `X`) form a sequence with the structure $b_1 b_2 b_3 b_1 b_2$. For this structure, the first bit, $b_1$, must be identical to the fourth bit, and the second bit, $b_2$, must be identical to the fifth (most recent) bit. The bit in the third position, $b_3$, may be either `0` or `1` and does not affect the validity of the pattern. The machine is required to detect all such valid 5-bit patterns, including those that overlap.\n\nFor example, if the input stream ends in `...01101`, the output `Z` should be `1` when the final `1` is received, because the sequence `01101` matches the structure with $b_1=0$, $b_2=1$, and $b_3=1$. Similarly, for an input stream ending in `...11011`, the output `Z` is `1` on the final `1`, corresponding to $b_1=1$, $b_2=1$, and $b_3=0$.\n\nDetermine the minimum number of states required to implement this Mealy FSM.", "solution": "To determine the minimum number of states for this Mealy FSM, we must identify the minimum amount of historical information the machine needs to \"remember\" to correctly determine the output for any future input.\n\nThe detection rule is that the output $Z$ is 1 if the five most recent bits, let's call them $x_{t-4} x_{t-3} x_{t-2} x_{t-1} x_t$ (where $x_t$ is the current input), satisfy $x_{t-4} = x_{t-1}$ and $x_{t-3} = x_t$.\n\nAt any given time, before the current input $x_t$ arrives, the FSM's state must encapsulate all the past information needed to check this condition and all future conditions. To evaluate the pattern ending at time $t$, the machine needs to know the values of the bits that will become $x_{t-4}$, $x_{t-3}$, and $x_{t-1}$. This means the state must preserve the history of the last four bits received.\n\nLet's define the state of the FSM as the tuple of the last four bits received: $S = (h_3, h_2, h_1, h_0)$, where $h_0$ is the most recent bit. When a new input $X$ arrives, the 5-bit sequence to be checked is $(h_3, h_2, h_1, h_0, X)$. According to the rule, the output $Z$ is 1 if and only if $h_3 = h_0$ and $h_2 = X$.\n\n**1. Upper Bound on the Number of States**\n\nWe can construct a valid FSM where each state corresponds to one unique 4-bit history.\n-   **States:** There are $2^4 = 16$ possible 4-bit histories, so we can define 16 states, one for each tuple $(h_3, h_2, h_1, h_0)$.\n-   **State Transition:** When a new bit $X$ is input, the history shifts. The new state becomes $(h_2, h_1, h_0, X)$.\n-   **Output Logic:** For a state $(h_3, h_2, h_1, h_0)$ and input $X$, the output is $Z = 1$ if $(h_3 = h_0 \\text{ and } h_2 = X)$, and $Z = 0$ otherwise.\n\nThis construction correctly implements the specified logic. Therefore, the minimum number of states is at most 16.\n\n**2. Lower Bound on the Number of States**\n\nTo prove that 16 states are necessary, we use the principle of state distinguishability (from Myhill-Nerode theory). We must show that any two distinct 4-bit histories are distinguishable, meaning there is some future input sequence that will produce different outputs depending on which history was the starting point.\n\nLet's consider two distinct histories, $H_A = (A_3, A_2, A_1, A_0)$ and $H_B = (B_3, B_2, B_1, B_0)$. We need to find an input sequence that distinguishes them.\n\n-   **Example 1: Histories differ in the oldest bit ($A_3 \\neq B_3$).**\n    Let $H_A = (0, 0, 0, 0)$ and $H_B = (1, 0, 0, 0)$.\n    Apply the input \"0\".\n    -   Starting from $H_A$: The 5-bit window is $(0, 0, 0, 0, 0)$. The conditions are $x_{t-4}=x_{t-1} \\implies 0=0$ (True) and $x_{t-3}=x_t \\implies 0=0$ (True). **Output Z=1**.\n    -   Starting from $H_B$: The 5-bit window is $(1, 0, 0, 0, 0)$. The condition $x_{t-4}=x_{t-1} \\implies 1=0$ is False. **Output Z=0**.\n    The outputs differ, so these histories are distinguishable.\n\n-   **Example 2: Histories differ in the second-oldest bit ($A_2 \\neq B_2$).**\n    Let $H_A = (0, 0, 0, 0)$ and $H_B = (0, 1, 0, 0)$.\n    Apply the input \"1\".\n    -   Starting from $H_A$: The window is $(0, 0, 0, 0, 1)$. The condition $x_{t-3}=x_t \\implies 0=1$ is False. **Output Z=0**.\n    -   Starting from $H_B$: The window is $(0, 1, 0, 0, 1)$. The conditions are $x_{t-4}=x_{t-1} \\implies 0=0$ (True) and $x_{t-3}=x_t \\implies 1=1$ (True). **Output Z=1**.\n    The outputs differ, so these histories are distinguishable.\n\nThis logic can be generalized. A distinguishing input sequence of at most three bits can be found for any pair of distinct 4-bit histories. Since all 16 possible histories lead to different future behaviors (i.e., they are pairwise distinguishable), they must each map to a unique state in any minimal implementation of the FSM.\n\n**Conclusion**\n\nThe upper bound (16 states) from our construction matches the lower bound (16 states) from the distinguishability analysis. Therefore, the minimum number of states required is exactly 16.", "answer": "$$\\boxed{16}$$", "id": "1962028"}]}