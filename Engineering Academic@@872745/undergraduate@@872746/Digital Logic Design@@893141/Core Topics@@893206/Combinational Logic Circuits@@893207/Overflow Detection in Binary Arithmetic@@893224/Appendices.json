{"hands_on_practices": [{"introduction": "Understanding overflow begins with a clear grasp of the representable range of a number system. This first practice focuses on the fundamental definition of overflow by asking you to identify when the result of an addition exceeds the limits of a 5-bit two's complement system. By working with familiar decimal values, you can build an intuition for overflow before tackling the complexities of binary arithmetic. [@problem_id:1950184]", "problem": "A simple processor core is designed to handle sensor data. It operates exclusively with 5-bit signed integers using two's complement representation. The range of representable numbers in this system is from $-16$ to $+15$. The core's Arithmetic Logic Unit (ALU) performs addition on two 5-bit operands, $A$ and $B$. An overflow occurs if the true result of the addition falls outside the representable range.\n\nYou are provided with several pairs of operands $(A, B)$, specified in their decimal values. Your task is to identify which of the following addition operations, $A + B$, will cause an overflow in this 5-bit two's complement system.\n\nA) $A = 12, B = -5$\n\nB) $A = -8, B = -7$\n\nC) $A = 9, B = 6$\n\nD) $A = 10, B = 6$\n\nE) $A = -15, B = 15$", "solution": "In a two's complement system with word size $n$, the representable range is from $-2^{n-1}$ to $2^{n-1}-1$. For $n=5$, the range is\n$$\n[-2^{4},\\,2^{4}-1]=[-16,\\,15].\n$$\nAn overflow in addition occurs if the true integer sum $r=A+B$ lies outside this interval. Equivalently, overflow can occur only when adding two operands of the same sign produces a result whose magnitude exceeds the representable bound, which manifests as the result's sign differing from the operands' sign.\n\nEvaluate each option by computing the true sum and comparing to the interval:\n- A) $12+(-5)=7$, with opposite signs and $7\\in[-16,15]$; no overflow.\n- B) $-8+(-7)=-15$, both negative and $-15\\in[-16,15]$; no overflow.\n- C) $9+6=15$, both positive and $15\\in[-16,15]$; no overflow.\n- D) $10+6=16$, both positive and $16\\notin[-16,15]$; overflow occurs.\n- E) $-15+15=0$, opposite signs and $0\\in[-16,15]$; no overflow.\n\nTherefore, only option D causes an overflow.", "answer": "$$\\boxed{D}$$", "id": "1950184"}, {"introduction": "Processors don't work with decimal numbers; they operate directly on binary bits. This exercise takes you inside a simple microprocessor to track how sequential additions affect an accumulator register and to pinpoint where overflow occurs. You will practice performing 8-bit two's complement addition and applying the sign-bit rule, a key skill for debugging and understanding low-level computation. [@problem_id:1950214]", "problem": "An 8-bit microprocessor, which uses two's complement representation for signed integers, has an accumulator register denoted as `ACC`. Initially, the `ACC` holds the binary value $A = 01101101_2$. A small program is executed, which consists of the following two sequential instructions:\n\n1.  Add the value $B = 01010110_2$ to the `ACC`. The result is stored back in the `ACC`.\n2.  Add the value $C = 10011011_2$ to the `ACC`. The result is again stored back in the `ACC`.\n\nBased on this sequence of operations, which of the following statements correctly describes the final binary value in the `ACC` register and specifies in which of the two addition steps (if any) an arithmetic overflow occurred?\n\nA. Final ACC: $01011110_2$, Overflow: First addition only.\n\nB. Final ACC: $11000011_2$, Overflow: Neither addition.\n\nC. Final ACC: $01011110_2$, Overflow: Both additions.\n\nD. Final ACC: $10100001_2$, Overflow: Second addition only.\n\nE. Final ACC: $11000011_2$, Overflow: First addition only.\n\nF. Final ACC: $01011110_2$, Overflow: Second addition only.\n\nG. Final ACC: $01011110_2$, Overflow: Neither addition.", "solution": "We use 8-bit two's complement arithmetic, where values are modulo $2^{8}$ and the signed range is from $-128$ to $127$. An overflow in two's complement addition occurs if and only if the addends have the same sign bit and the result has the opposite sign bit (equivalently, the carry into the most significant bit differs from the carry out).\n\nInitial accumulator: $A=01101101_{2}$. First addition adds $B=01010110_{2}$:\n$$\n01101101_{2}+01010110_{2}=11000011_{2}\\quad(\\text{mod }2^{8}).\n$$\nInterpreting signs: $A$ and $B$ have sign bit $0$ (both positive), while the result $11000011_{2}$ has sign bit $1$ (negative). Therefore, the first addition causes signed overflow. The accumulator after step 1 is $11000011_{2}$.\n\nSecond addition adds $C=10011011_{2}$ to the current accumulator:\n$$\n11000011_{2}+10011011_{2}=1\\,01011110_{2}\\;\\Rightarrow\\;\\text{ACC}=01011110_{2}\\quad(\\text{discarding carry out}).\n$$\nHere both addends $11000011_{2}$ and $10011011_{2}$ have sign bit $1$ (both negative), while the result $01011110_{2}$ has sign bit $0$ (positive). Therefore, the second addition also causes signed overflow.\n\nHence, the final accumulator value is $01011110_{2}$, and overflow occurred in both additions, which corresponds to option C.", "answer": "$$\\boxed{C}$$", "id": "1950214"}, {"introduction": "Having mastered the concept and manual calculation of overflow, the next step is to design the hardware that detects it automatically. This final practice challenges you to specify a Finite State Machine (FSM) that processes numbers serially and raises an overflow flag, mirroring how a real ALU might operate. By connecting the overflow condition, $V = c_{n-1} \\oplus c_{n}$, to the carry bits, you will translate an arithmetic rule into a concrete digital logic design. [@problem_id:1950178]", "problem": "A specialized, resource-constrained processor is designed with a serial Arithmetic Logic Unit (ALU). This ALU operates on two $n$-bit integers, $A$ and $B$, which are represented in two's complement format. The numbers are processed bit-by-bit, starting from the Least Significant Bit (LSB). At each clock cycle $i$ (from $i=0$ for the LSB to $i=n-1$ for the Most Significant Bit, MSB), the ALU's 1-bit full adder receives the input bits $a_i$ and $b_i$, along with a carry-in $c_i$ from the previous stage, and computes a sum bit $s_i$ and a carry-out $c_{i+1}$. For the first stage, the carry-in $c_0$ is 0.\n\nYour task is to specify the behavior of a Mealy-type Finite State Machine (FSM) that works in conjunction with the full adder to detect arithmetic overflow. This FSM must generate a single-bit output, $V$. The value of $V$ at the clock cycle corresponding to the MSB ($i=n-1$) must be 1 if an overflow has occurred during the $n$-bit addition, and 0 otherwise. The FSM's state transitions are synchronized with the processing of each bit pair.\n\nThe FSM has two states:\n-   $S_0$: Represents the condition where the carry-in to the current bit-slice, $c_i$, is 0.\n-   $S_1$: Represents the condition where the carry-in to the current bit-slice, $c_i$, is 1.\n\nThe FSM's inputs at cycle $i$ are the data bits $a_i$ and $b_i$. The FSM begins in state $S_0$.\n\nWhich of the following state transition and output tables correctly describes this overflow-detecting Mealy FSM?\n\nA.\n| Current State | Inputs ($a_i, b_i$) | Next State | Output ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_1$     |        0       |\n|      $S_1$      |        10         |    $S_1$     |        0       |\n|      $S_1$      |        11         |    $S_1$     |        0       |\n\nB.\n| Current State | Inputs ($a_i, b_i$) | Next State | Output ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        0       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_1$     |        1       |\n|      $S_1$      |        10         |    $S_1$     |        1       |\n|      $S_1$      |        11         |    $S_1$     |        1       |\n\nC.\n| Current State | Inputs ($a_i, b_i$) | Next State | Output ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        0       |\n|      $S_1$      |        01         |    $S_1$     |        1       |\n|      $S_1$      |        10         |    $S_1$     |        1       |\n|      $S_1$      |        11         |    $S_1$     |        1       |\n\nD.\n| Current State | Inputs ($a_i, b_i$) | Next State | Output ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        1       |\n|      $S_0$      |        01         |    $S_1$     |        0       |\n|      $S_0$      |        10         |    $S_1$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_0$     |        0       |\n|      $S_1$      |        10         |    $S_0$     |        0       |\n|      $S_1$      |        11         |    $S_1$     |        1       |", "solution": "We add two two's complement numbers serially with a 1-bit full adder per cycle. Let the FSM state encode the carry-in to the current bit-slice: $S_{0}$ means $c_{i}=0$, $S_{1}$ means $c_{i}=1$. The full-adder carry-out is\n$$\nc_{i+1}=a_{i}b_{i}+a_{i}c_{i}+b_{i}c_{i}.\n$$\nThus the next-state function is determined by $c_{i+1}$:\n- If $c_{i}=0$ (state $S_{0}$), then $c_{i+1}=a_{i}b_{i}$. Hence from $S_{0}$ the next state is $S_{1}$ only when $(a_{i},b_{i})=(1,1)$; otherwise it stays in $S_{0}$.\n- If $c_{i}=1$ (state $S_{1}$), then $c_{i+1}=a_{i}+b_{i}$ (logical OR). Hence from $S_{1}$ the next state is $S_{0}$ only when $(a_{i},b_{i})=(0,0)$; otherwise it stays in $S_{1}$.\n\nIn two's complement addition, the overflow flag at the MSB satisfies\n$$\nV_{n-1}=c_{n-1}\\oplus c_{n}.\n$$\nA Mealy FSM can generate this at cycle $i$ using\n$$\nV_{i}=c_{i}\\oplus c_{i+1},\n$$\nbecause $c_{i+1}$ is a function of the current state and inputs.\n\nCompute the output per state and inputs:\n- For $S_{0}$ ($c_{i}=0$): $V_{i}=0\\oplus c_{i+1}=c_{i+1}=a_{i}b_{i}$. Therefore $(a_{i},b_{i})$ equal to $00,01,10,11$ yields $V_{i}=0,0,0,1$ respectively.\n- For $S_{1}$ ($c_{i}=1$): $V_{i}=1\\oplus c_{i+1}=1\\oplus(a_{i}+b_{i})$. Therefore $(a_{i},b_{i})$ equal to $00,01,10,11$ yields $V_{i}=1,0,0,0$ respectively.\n\nCombining the derived next-state and output behaviors matches exactly the table in option A and differs from the others (which have incorrect outputs and/or transitions).", "answer": "$$\\boxed{A}$$", "id": "1950178"}]}