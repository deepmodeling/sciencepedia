{"hands_on_practices": [{"introduction": "Understanding the behavior of a parallel-load counter begins with tracing its state changes under different control inputs. This first exercise provides a fundamental workout in predicting the counter's output by stepping through a predefined sequence of clock cycles [@problem_id:1925182]. By manually tracking the effects of the `Load` signal, you will solidify your grasp of the core choice a presettable counter makes at every clock edge: to either increment its value or adopt a new one from its parallel inputs.", "problem": "A digital system incorporates a 2-bit synchronous binary up-counter with parallel load capability. The counter's state is represented by the outputs $Q_1Q_0$. The counter has two data inputs, $D_1$ and $D_0$, and an active-high synchronous load enable signal, `Load`. The behavior of the counter is determined by the `Load` signal just before the rising edge of the system clock signal, `CLK`:\n\n- If `Load` is high (logic 1), on the next rising edge of `CLK`, the counter loads the values from the data inputs, such that the new state becomes $Q_1Q_0 = D_1D_0$.\n- If `Load` is low (logic 0), on the next rising edge of `CLK`, the counter increments its current value by one. The count sequence is 00, 01, 10, 11, and then it wraps around back to 00.\n\nThe counter is initially in the state $Q_1Q_0 = 00$. The system experiences a sequence of six rising clock edges. The values of the `Load` signal and the data inputs $D_1D_0$ are held stable just before each corresponding clock edge as follows:\n\n- Before clock edge 1: `Load` = 1, $D_1D_0$ = 10\n- Before clock edge 2: `Load` = 0\n- Before clock edge 3: `Load` = 0\n- Before clock edge 4: `Load` = 1, $D_1D_0$ = 01\n- Before clock edge 5: `Load` = 0\n- Before clock edge 6: `Load` = 0\n\nWhat is the binary state of the counter, $Q_1Q_0$, immediately after the 6th rising clock edge?\n\nA. 00\n\nB. 01\n\nC. 10\n\nD. 11", "solution": "Define the synchronous update rule on each rising edge of the clock:\n$$\n(Q_1Q_0)^{+} =\n\\begin{cases}\nD_1D_0, & \\text{if Load}=1,\\\\\n(Q_1Q_0)+1 \\pmod{4}, & \\text{if Load}=0,\n\\end{cases}\n$$\nwhere $(Q_1Q_0)$ is interpreted as a 2-bit binary number and the result is written as a 2-bit binary state.\n\nThe initial state is $Q_1Q_0=00$.\n\nClock edge 1: Load $=1$, $D_1D_0=10$. Therefore,\n$$\n(Q_1Q_0)^{+} = D_1D_0 = 10.\n$$\nNew state: $10$.\n\nClock edge 2: Load $=0$. Therefore,\n$$\n10 \\to 11.\n$$\nNew state: $11$.\n\nClock edge 3: Load $=0$. Therefore,\n$$\n11 \\to 00 \\quad (\\text{wrap around}).\n$$\nNew state: $00$.\n\nClock edge 4: Load $=1$, $D_1D_0=01$. Therefore,\n$$\n(Q_1Q_0)^{+} = D_1D_0 = 01.\n$$\nNew state: $01$.\n\nClock edge 5: Load $=0$. Therefore,\n$$\n01 \\to 10.\n$$\nNew state: $10$.\n\nClock edge 6: Load $=0$. Therefore,\n$$\n10 \\to 11.\n$$\nNew state after the sixth edge: $11$, which corresponds to option D.", "answer": "$$\\boxed{D}$$", "id": "1925182"}, {"introduction": "Moving from analysis to design, this next practice challenges you to create the internal logic for a versatile synchronous counter. Your task is to derive the Boolean expressions that manage not only parallel loading but also counting direction (up/down) and state holding, based on a prioritized set of control signals [@problem_id:1925209]. This exercise mirrors a common engineering task, requiring you to translate a set of operational requirements into precise combinational logic for the flip-flop inputs.", "problem": "You are tasked with designing the control logic for a custom 4-bit synchronous counter. The counter's state is represented by four bits, $Q_3, Q_2, Q_1, Q_0$, where $Q_0$ is the least significant bit. The counter is constructed from D-type flip-flops, meaning the value of each bit $Q_i$ on the next clock cycle is determined by the logic level at the corresponding input, $D_i$.\n\nThe counter must support several operations determined by three active-high control signals: `L` (Load), `E` (Enable), and `U` (Up/Down direction). The operations are prioritized as follows:\n\n1.  **Parallel Load (Highest Priority):** If `L` is high (1), the counter ignores all other control signals. On the next active clock edge, the counter's state $Q_3Q_2Q_1Q_0$ is loaded with the values from four parallel data inputs, $P_3, P_2, P_1, P_0$.\n2.  **Hold State:** If `L` is low (0) and `E` is low (0), the counter holds its current state.\n3.  **Count (Lowest Priority):** If `L` is low (0) and `E` is high (1), the counter performs a count operation. The direction is determined by the `U` signal:\n    *   If `U=1`, the counter increments its value (counts up). For example, a state of `0101` becomes `0110`.\n    *   If `U=0`, the counter decrements its value (counts down). For example, a state of `0101` becomes `0100`.\n    The counting operation includes wrap-around behavior (e.g., when counting up from `1111`, the next state is `0000`; when counting down from `0000`, the next state is `1111`).\n\nYour task is to derive the complete Boolean logic expression for the input $D_2$ of the flip-flop corresponding to the state bit $Q_2$. Present your answer as a sum-of-products expression. The expression should be formulated in terms of the state bits $Q_2, Q_1, Q_0$, the parallel input $P_2$, and the control signals $L, E, U$.", "solution": "Let $D_{2}$ denote the next-state input of the flip-flop producing $Q_{2}$. The prioritized control behavior is:\n1) If $L=1$, parallel load overrides all else, so $D_{2}=P_{2}$.\n2) If $L=0$ and $E=0$, the counter holds its state, so $D_{2}=Q_{2}$.\n3) If $L=0$ and $E=1$, the counter counts. For counting up, bit $Q_{2}$ toggles when there is a carry from the lower bits, i.e., when $Q_{1}Q_{0}=1$. Thus for up-counting,\n$$\nD_{2}=\\;Q_{2}\\oplus(Q_{1}Q_{0}) \\;=\\; Q_{2}\\overline{Q_{1}Q_{0}}+\\overline{Q_{2}}\\,Q_{1}Q_{0}\n\\;=\\; Q_{2}\\overline{Q_{1}}+Q_{2}\\overline{Q_{0}}+\\overline{Q_{2}}\\,Q_{1}Q_{0}.\n$$\nFor counting down, bit $Q_{2}$ toggles when there is a borrow from the lower bits, i.e., when $\\overline{Q_{1}}\\overline{Q_{0}}=1$. Thus for down-counting,\n$$\nD_{2}=\\;Q_{2}\\oplus(\\overline{Q_{1}}\\overline{Q_{0}}) \\;=\\; Q_{2}\\,\\overline{\\overline{Q_{1}}\\overline{Q_{0}}}+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}\n\\;=\\; Q_{2}(Q_{1}+Q_{0})+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}\n\\;=\\; Q_{2}Q_{1}+Q_{2}Q_{0}+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}.\n$$\nUsing $U$ to select the direction when $L=0$ and $E=1$, and incorporating the priority of $L$, the complete logic is\n$$\nD_{2}=L\\,P_{2}+\\overline{L}\\,\\overline{E}\\,Q_{2}+\\overline{L}\\,E\\Big[U\\big(Q_{2}\\overline{Q_{1}}+Q_{2}\\overline{Q_{0}}+\\overline{Q_{2}}\\,Q_{1}Q_{0}\\big)+\\overline{U}\\big(Q_{2}Q_{1}+Q_{2}Q_{0}+\\overline{Q_{2}}\\,\\overline{Q_{1}}\\overline{Q_{0}}\\big)\\Big].\n$$\nExpanding to an explicit sum-of-products yields\n$$\nD_{2}\n= L P_{2}\n+ \\overline{L}\\,\\overline{E}\\,Q_{2}\n+ \\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{1}}\n+ \\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{0}}\n+ \\overline{L}\\,E\\,U\\,\\overline{Q_{2}}\\,Q_{1}\\,Q_{0}\n+ \\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{1}\n+ \\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{0}\n+ \\overline{L}\\,E\\,\\overline{U}\\,\\overline{Q_{2}}\\,\\overline{Q_{1}}\\,\\overline{Q_{0}}.\n$$\nThis is the required sum-of-products expression in terms of $Q_{2},Q_{1},Q_{0},P_{2},L,E,U$ with the correct priority behavior.", "answer": "$$\\boxed{L P_{2}+\\overline{L}\\,\\overline{E}\\,Q_{2}+\\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{1}}+\\overline{L}\\,E\\,U\\,Q_{2}\\,\\overline{Q_{0}}+\\overline{L}\\,E\\,U\\,\\overline{Q_{2}}\\,Q_{1}\\,Q_{0}+\\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{1}+\\overline{L}\\,E\\,\\overline{U}\\,Q_{2}\\,Q_{0}+\\overline{L}\\,E\\,\\overline{U}\\,\\overline{Q_{2}}\\,\\overline{Q_{1}}\\,\\overline{Q_{0}}}$$", "id": "1925209"}, {"introduction": "This final problem showcases a powerful application of the parallel load feature: creating custom, non-linear state machines. Instead of loading an external value, you will design logic that calculates the next state based on an arithmetic function of the current state, using the parallel load mechanism to perform the update [@problem_id:1925204]. This technique of turning a counter into a programmable state generator is fundamental in fields like cryptography and signal processing, demonstrating how basic digital blocks can be used to implement complex algorithms.", "problem": "A specialized 4-bit synchronous counter is being designed to serve as a state generator in a cryptographic module. The counter's state is represented by the 4-bit vector $Q = [Q_3, Q_2, Q_1, Q_0]$, where $Q_3$ is the most significant bit. The counter has a synchronous control input, `UPDATE`.\n\nThe behavior of the counter is defined as follows:\n- If the `UPDATE` signal is low (0), the circuit behaves as a standard synchronous binary up-counter, incrementing its state on each active clock edge, i.e., $Q_{next} = (Q_{current} + 1) \\pmod{16}$.\n- If the `UPDATE` signal is high (1), the counter performs a parallel load operation on the next active clock edge. The data to be loaded, denoted by the 4-bit vector $D = [D_3, D_2, D_1, D_0]$, is a function of the current state $Q$. The function is given by the arithmetic expression $D = (2 \\cdot Q_{val} + 3) \\pmod{16}$, where $Q_{val}$ is the decimal value of the current state $Q$.\n\nYour task is to determine the combinational logic required for the parallel load path. Specifically, find the minimized Sum-of-Products (SOP) boolean expression for the most significant bit of the load data, $D_3$, in terms of the current state bits $Q_3, Q_2, Q_1,$ and $Q_0$. In your expression, use `+` to represent the OR operation, multiplication (juxtaposition) for the AND operation, and an overbar for the NOT operation (e.g., $\\overline{A}$).", "solution": "The problem asks for the minimized Sum-of-Products (SOP) expression for the logic that generates the parallel load input bit $D_3$. The load value $D$ is defined by the arithmetic function $D = (2 \\cdot Q_{val} + 3) \\pmod{16}$, where $Q_{val}$ is the decimal representation of the 4-bit state $Q = [Q_3, Q_2, Q_1, Q_0]$.\n\nFirst, let's analyze the arithmetic function at the bit level. The state $Q$ is a 4-bit binary number.\nThe operation $2 \\cdot Q_{val}$ in binary is equivalent to a logical left shift of the bits of $Q$.\nIf $Q = Q_3Q2Q1Q_0$, a 1-bit left shift results in the 5-bit number $Q_3Q_2Q_1Q_00$.\n\nThe operation is modulo 16, which means we are only interested in the lower 4 bits of the result. When we perform the left shift, the most significant bit $Q_3$ is shifted out of the 4-bit range.\nSo, $2 \\cdot Q_{val} \\pmod{16}$ is represented by the 4-bit binary number $Q_2Q_1Q_00$.\n\nNext, we must add 3 to this result. The decimal value 3 is represented in 4-bit binary as $0011$.\nThe complete operation $D = (2 \\cdot Q_{val} + 3) \\pmod{16}$ can thus be implemented as a 4-bit binary addition:\n$$\n\\begin{array}{ccccc}\n  & Q_2 & Q_1 & Q_0 & 0 \\\\\n+ & 0 & 0 & 1 & 1 \\\\\n\\hline\n  & D_3 & D_2 & D_1 & D_0 \\\\\n\\end{array}\n$$\nThe modulo 16 operation implies that any carry-out from the most significant bit position is discarded.\n\nWe can now derive the logic for each output bit $D_i$ using the equations for a full adder at each bit position $i$:\n$S_i = A_i \\oplus B_i \\oplus C_{in,i}$\n$C_{out,i} = A_i B_i + A_i C_{in,i} + B_i C_{in,i}$\n\nLet the two numbers being added be $A = Q_2Q_1Q_00$ and $B = 0011$.\nThe input bits to the adder are:\n$A_3=Q_2, A_2=Q_1, A_1=Q_0, A_0=0$\n$B_3=0, B_2=0, B_1=1, B_0=1$\nLet $C_i$ be the carry-in to stage $i$. The initial carry-in $C_0$ is 0.\n\n**Bit 0:**\n$D_0 = A_0 \\oplus B_0 \\oplus C_0 = 0 \\oplus 1 \\oplus 0 = 1$\n$C_1 = A_0 B_0 + A_0 C_0 + B_0 C_0 = (0 \\cdot 1) + (0 \\cdot 0) + (1 \\cdot 0) = 0$\n\n**Bit 1:**\n$D_1 = A_1 \\oplus B_1 \\oplus C_1 = Q_0 \\oplus 1 \\oplus 0 = \\overline{Q_0}$\n$C_2 = A_1 B_1 + A_1 C_1 + B_1 C_1 = (Q_0 \\cdot 1) + (Q_0 \\cdot 0) + (1 \\cdot 0) = Q_0$\n\n**Bit 2:**\n$D_2 = A_2 \\oplus B_2 \\oplus C_2 = Q_1 \\oplus 0 \\oplus Q_0 = Q_1 \\oplus Q_0$\n$C_3 = A_2 B_2 + A_2 C_2 + B_2 C_2 = (Q_1 \\cdot 0) + (Q_1 \\cdot Q_0) + (0 \\cdot Q_0) = Q_1 Q_0$\n\n**Bit 3 (The desired output):**\n$D_3 = A_3 \\oplus B_3 \\oplus C_3 = Q_2 \\oplus 0 \\oplus (Q_1 Q_0) = Q_2 \\oplus (Q_1 Q_0)$\n\nThe problem asks for the minimized Sum-of-Products (SOP) expression for $D_3$. We expand the XOR expression:\n$D_3 = Q_2 \\oplus (Q_1 Q_0)$\nUsing the definition of XOR, $X \\oplus Y = X\\overline{Y} + \\overline{X}Y$:\n$D_3 = Q_2 \\overline{(Q_1 Q_0)} + \\overline{Q_2} (Q_1 Q_0)$\nApplying De Morgan's law to the first term, $\\overline{(Q_1 Q_0)} = \\overline{Q_1} + \\overline{Q_0}$:\n$D_3 = Q_2 (\\overline{Q_1} + \\overline{Q_0}) + \\overline{Q_2} Q_1 Q_0$\nDistributing $Q_2$ gives the final SOP expression:\n$D_3 = Q_2 \\overline{Q_1} + Q_2 \\overline{Q_0} + \\overline{Q_2} Q_1 Q_0$\n\nThis expression is in minimized SOP form. It's worth noting that the input $Q_3$ does not affect the calculation of any of the $D$ bits, which is a direct consequence of the left shift in a modulo-16 system.\n\nFor completeness, the SOP expressions for the other bits are:\n$D_0 = 1$\n$D_1 = \\overline{Q_0}$\n$D_2 = Q_1 \\overline{Q_0} + \\overline{Q_1} Q_0$\n\nThe question specifically asks for the expression for $D_3$.", "answer": "$$\\boxed{Q_2 \\overline{Q_1} + Q_2 \\overline{Q_0} + \\overline{Q_2} Q_1 Q_0}$$", "id": "1925204"}]}