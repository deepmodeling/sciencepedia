{"hands_on_practices": [{"introduction": "One of the most critical distinctions to master in Verilog is the difference between `reg` and `wire` data types. This exercise [@problem_id:1975222] presents a common coding error to reinforce the fundamental rule: variables assigned within procedural blocks, such as `initial` or `always`, must be of a variable type like `reg`.", "problem": "In the context of the Verilog Hardware Description Language (HDL), consider the following simple module designed to initialize two signals at the beginning of a simulation.\n\n```verilog\nmodule simple_init;\n\n  reg  a;\n  wire b;\n\n  initial begin\n    a = 1'b0;\n    b = 1'b1;\n  end\n\nendmodule\n```\n\nThis code contains a fundamental error that will prevent it from compiling and simulating correctly. Which one of the following changes is the necessary and correct modification to fix the error in the provided module?\n\nA. Change the declaration of `b` from `wire b;` to `reg b;`\n\nB. Change the declaration of `a` from `reg a;` to `wire a;`\n\nC. Add an `always @(*)` block around the assignments to `a` and `b`.\n\nD. Replace the `initial` block with two continuous assignment statements: `assign a = 1'b0;` and `assign b = 1'b1;`", "solution": "Verilog distinguishes between net types (such as `wire`) and variable types (such as `reg`). The fundamental rule is that procedural assignments within an `initial` or `always` block can only assign to variables (e.g., `reg`), not to nets (e.g., `wire`). Continuous assignments using the `assign` keyword drive nets, not `reg`s.\n\nIn the given module, the `initial` block assigns to both `a` and `b`. The declaration of `a` as a `reg` is correct for a procedural assignment. However, `b` is declared as a `wire`, which cannot be assigned in a procedural block. This is the compilation error.\n\nEvaluate the options:\n- Option A changes `b` from `wire` to `reg`. This makes both `a` and `b` variables that can legally be assigned within the `initial` block. This directly fixes the error without altering behavior.\n- Option B changes `a` from `reg` to `wire`, which would make the procedural assignment to `a` illegal, introducing another error.\n- Option C wraps the assignments in an `always @(*)` block, which remains a procedural context; assigning to `wire b` would still be illegal, so this does not fix the error.\n- Option D replaces the procedural `initial` block with continuous assignments. Continuous assignments require nets; since `a` is declared as `reg`, `assign a = 1'b0;` would be illegal unless `a` were also changed to a net type. Because the option does not change the declaration of `a`, this is not a correct fix as stated.\n\nTherefore, the necessary and correct modification is to declare `b` as a `reg`, which is Option A.", "answer": "$$\\boxed{A}$$", "id": "1975222"}, {"introduction": "Once you have data stored in a register, you often need to access specific portions of it. This practice [@problem_id:1975211] focuses on the essential syntax for vector part-selection, a technique used constantly to isolate and manipulate groups of bits from a wider bus or data word.", "problem": "In a digital system being designed using Verilog, a register is declared to hold an 8-bit data value from a sensor. This register is defined as:\n\n`reg [7:0] data_bus;`\n\nFor a specific processing unit, only the two least significant bits (LSBs) of `data_bus` are required. Which of the following expressions correctly selects these two bits?\n\nA. `data_bus[0:1]`\n\nB. `data_bus[2:1]`\n\nC. `data_bus[1:0]`\n\nD. `data_bus(1:0)`\n\nE. `data_bus[7:6]`\n\nF. `data_bus[0,1]`", "solution": "A Verilog declaration `reg [7:0] data_bus;` defines an 8-bit vector with indices from the most significant bit (MSB) at index 7 down to the least significant bit (LSB) at index 0. In Verilog, a part-select uses square brackets with a descending range specified as `[msb:lsb]`, where the left index must be greater than or equal to the right index.\n\nThe two least significant bits are bit 1 and bit 0. Therefore, the correct part-select for the two LSBs is `[1:0]`.\n\nEvaluating the options:\n- A. `data_bus[0:1]` uses an ascending range, which is invalid in standard Verilog part-select syntax.\n- B. `data_bus[2:1]` selects bits 2 and 1, not the two LSBs.\n- C. `data_bus[1:0]` correctly selects bits 1 and 0, the two LSBs.\n- D. `data_bus(1:0)` uses parentheses, which is invalid syntax; Verilog requires square brackets for indexing.\n- E. `data_bus[7:6]` selects the two MSBs, not the LSBs.\n- F. `data_bus[0,1]` is invalid syntax; multiple bit selection would require concatenation like `{data_bus[1], data_bus[0]}`, not a comma within brackets.\n\nTherefore, only option C is correct.", "answer": "$$\\boxed{C}$$", "id": "1975211"}, {"introduction": "Effective hardware design involves not just writing code, but also debugging it. This problem [@problem_id:1975238] simulates a subtle but common bug caused by an undeclared net, forcing you to apply your knowledge of Verilog's implicit rules, port connection truncation, and bit-width extension to predict the circuit's final output.", "problem": "In a digital system designed using Verilog, a top-level module, `system_controller`, integrates a `data_source` submodule and a `data_sink` submodule. The `data_source` module generates an 8-bit value. This value is intended to be passed to the `data_sink` module for processing. However, the engineer forgot to explicitly declare the wire connecting the output of the `data_source` instance to the input of the `data_sink` instance within the `system_controller`.\n\nYou are given the Verilog descriptions for all three modules. Your task is to analyze this design and determine the final, stable decimal value of the `system_output` port of the `system_controller`. Assume the simulation runs long enough for all initial values to propagate and all combinational logic to settle.\n\n**Module `data_source`:**\n```verilog\nmodule data_source (\n  output reg [7:0] source_out\n);\n\n  initial begin\n    source_out = 8'hA9; // Hexadecimal A9\n  end\n\nendmodule\n```\n\n**Module `data_sink`:**\n```verilog\nmodule data_sink (\n  input [3:0] sink_in,\n  output [7:0] sink_out\n);\n\n  // Re-arrange and combine input bits to form the output\n  assign sink_out = {sink_in[3:2], 2'b11, sink_in[1:0], 2'b01};\n\nendmodule\n```\n\n**Module `system_controller`:**\n```verilog\nmodule system_controller (\n  output [7:0] system_output\n);\n\n  // Instantiation of submodules\n  data_source source_inst (\n    .source_out(internal_connection)\n  );\n\n  data_sink sink_inst (\n    .sink_in(internal_connection),\n    .sink_out(system_output)\n  );\n\n  // NOTE: The wire 'internal_connection' is intentionally NOT declared.\n\nendmodule\n```\n\nWhat is the final decimal value of the `system_output`?", "solution": "This problem hinges on Verilog's rules for implicit nets and port connection width mismatches.\n\n1.  **Implicit Net Declaration:** The signal `internal_connection` is not declared in the `system_controller` module. According to Verilog's rules (unless overridden by `` `default_nettype``), an undeclared identifier used in a port connection is implicitly declared as a 1-bit `wire`.\n\n2.  **Source Value and Truncation:** The `data_source` module sets its 8-bit output `source_out` to `8'hA9`, which is `8'b10101001`. When this 8-bit output is connected to the 1-bit `internal_connection` wire, the value is truncated. Only the least significant bit (LSB) is passed. Therefore, the value of `internal_connection` becomes `1` (the LSB of `8'b10101001`).\n\n3.  **Input Extension:** This 1-bit wire `internal_connection` is then connected to the 4-bit input `sink_in` of the `data_sink` module. When connecting a narrower signal to a wider input port, Verilog performs zero-extension for unsigned values. The 1-bit value `1'b1` is extended to `4'b0001`. So, `sink_in` is `4'b0001`.\n\n4.  **Sink Logic Calculation:** The `data_sink` module calculates its output with the assignment:\n    `assign sink_out = {sink_in[3:2], 2'b11, sink_in[1:0], 2'b01};`\n    Substituting the value of `sink_in` (`4'b0001`):\n    *   `sink_in[3:2]` is `2'b00`.\n    *   `sink_in[1:0]` is `2'b01`.\n    The expression becomes:\n    `sink_out = {2'b00, 2'b11, 2'b01, 2'b01};`\n    Concatenating these bits results in `8'b00110101`.\n\n5.  **Final Value:** The value `8'b00110101` is assigned to `system_output`. To convert this to decimal:\n    `8'b00110101` is `8'h35` in hexadecimal.\n    The decimal value is $3 \\times 16^1 + 5 \\times 16^0 = 48 + 5 = 53$.\n\nSince the logic settles after the initial block runs, the final, stable value of `system_output` is 53.", "answer": "$$\\boxed{53}$$", "id": "1975238"}]}