{"hands_on_practices": [{"introduction": "VHDL's strength lies in its strong typing system, which prevents unintended operations between incompatible data types. This exercise [@problem_id:1976718] provides essential practice in handling a common scenario: performing arithmetic between a `std_logic_vector` and a numeric literal. You will learn to use the standard `ieee.numeric_std` library to perform explicit type conversions, a foundational skill for creating synthesizable logic for arithmetic circuits.", "problem": "You are designing a simple digital signal processor in VHDL. A part of this processor needs to take an 8-bit unsigned sensor reading and add a fixed integer offset to it.\n\nConsider a VHDL entity defined as follows:\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity DataCalibrator is\n    port (\n        clk      : in  std_logic;\n        data_in  : in  std_logic_vector(7 downto 0);\n        data_out : out std_logic_vector(7 downto 0)\n    );\nend entity DataCalibrator;\n```\n\nWithin the architecture of `DataCalibrator`, a clocked process is required. This process must, on the rising edge of the `clk` signal, read the `data_in` vector, add the integer literal `17` to its value, and assign the 8-bit result to the `data_out` signal. The result should correctly handle overflow by wrapping around (e.g., if `data_in` is `250`, adding `17` should result in `11`, as `(250+17) mod 256 = 11`).\n\nWhich of the following code snippets correctly implements the required process?\n\nA.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));\n    end if;\nend process;\n```\n\nB.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + 17;\n    end if;\nend process;\n```\n\nC.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + \"00010001\";\n    end if;\nend process;\n```\n\nD.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= conv_std_logic_vector(conv_integer(data_in) + 17, 8);\n    end if;\nend process;\n```", "solution": "The goal is to add an `integer` literal to a `std_logic_vector` signal and assign the `std_logic_vector` result to an output. VHDL is a strongly-typed language, meaning that operations can only be performed on compatible data types. The `+` operator is not defined by default for mixing `std_logic_vector` and `integer` types. Therefore, explicit type conversion is necessary. The problem specifies the use of the `ieee.numeric_std` library, which is the industry standard for such operations.\n\nLet's analyze the required steps for the conversion and calculation:\n1.  The input signal `data_in` is of type `std_logic_vector`. To perform arithmetic, it must be converted to a numeric type. The `numeric_std` library provides the `unsigned` type for this purpose. Since the sensor reading is stated to be unsigned, this is the correct choice. The `std_logic_vector` must first be cast to `unsigned`: `unsigned(data_in)`.\n2.  The addition involves an operand of type `integer` (the literal `17`). The `+` operator in `numeric_std` is defined for `unsigned` + `integer`, which returns an `unsigned` result. It is also defined for `integer` + `integer`. For clarity and robustness, it's common to convert the `unsigned` vector to an `integer` before the addition. The function `to_integer()` from `numeric_std` achieves this: `to_integer(unsigned(data_in))`.\n3.  Now the addition can be performed between two integers: `to_integer(unsigned(data_in)) + 17`. The result of this operation is an `integer`.\n4.  The output port `data_out` is an 8-bit `std_logic_vector`. The integer result from the addition must be converted back to this type. First, we convert the integer to an `unsigned` vector of the correct size (8 bits). The `to_unsigned()` function does this: `to_unsigned(integer_result, 8)`. This function correctly handles the wrap-around behavior (modulo arithmetic) required by the problem.\n5.  Finally, the `unsigned` vector is cast back to `std_logic_vector` to match the type of the output signal: `std_logic_vector(unsigned_result)`.\n\nCombining all these steps into a single line gives the expression:\n`data_out <= std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));`\n\nNow, let's evaluate the given options:\n\n**A.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));\n    end if;\nend process;\n```\nThis option perfectly matches the derivation above. It correctly casts `data_in` to `unsigned`, converts it to `integer`, performs the addition, converts the integer result back to an 8-bit `unsigned` vector, and finally casts it to `std_logic_vector`. This is the correct implementation.\n\n**B.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + 17;\n    end if;\nend process;\n```\nThis option attempts to directly add a `std_logic_vector` and an `integer`. This will cause a type mismatch error during compilation because the `+` operator is not defined for these types in the standard libraries.\n\n**C.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= data_in + \"00010001\";\n    end if;\nend process;\n```\nThis option attempts to add two `std_logic_vector`s. The `+` operator is not defined for the `std_logic_vector` type in `ieee.std_logic_1164` or `ieee.numeric_std`. Arithmetic addition is defined for `unsigned` and `signed` types, but not directly for `std_logic_vector`. This will also result in a compilation error.\n\n**D.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out <= conv_std_logic_vector(conv_integer(data_in) + 17, 8);\n    end if;\nend process;\n```\nThis option uses the functions `conv_integer` and `conv_std_logic_vector`. These functions are not part of the standard `ieee.numeric_std` library. They belong to non-standard, vendor-specific, or deprecated libraries like `std_logic_arith` (from Synopsys). Using them is incorrect when the standard `ieee.numeric_std` is specified and is considered poor modern VHDL practice.\n\nTherefore, Option A is the only correct and standard-compliant solution.", "answer": "$$\\boxed{A}$$", "id": "1976718"}, {"introduction": "Beyond static data types, understanding how VHDL models concurrency is critical for accurate simulation and design. This problem [@problem_id:1976697] delves into the behavior of shared variables when accessed by multiple concurrent processes. It constructs a hypothetical scenario designed to reveal a race condition, where the final result is non-deterministic due to the simulator's scheduling of processes, providing a memorable lesson on the dangers of shared variables and the VHDL simulation cycle.", "problem": "An engineer is designing a digital system to count events detected by two independent, synchronized sensors. A VHDL model is created to simulate the behavior of the event counter. The design uses two concurrent processes, one for each sensor, which are intended to increment a shared counter on every rising edge of a common clock signal `clk`. The simulation is controlled by a third process that enables the counting for a fixed number of clock cycles, `N_CYCLES`, after an initial `reset`.\n\nConsider the following VHDL code snippet for the `race_condition_eval` entity.\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity race_condition_eval is\n    port (\n        clk   : in  std_logic;\n        reset : in  std_logic;\n        final_count : out integer\n    );\nend entity race_condition_eval;\n\narchitecture behavioral of race_condition_eval is\n    signal stop_sim : boolean := false;\n    shared variable event_counter : integer := 0;\n    \n    constant N_CYCLES : integer := 80;\n\nbegin\n\n    process_A: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_A;\n\n    process_B: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_B;\n\n    control_proc: process\n    begin\n        -- Wait for reset to be applied and then de-asserted\n        wait until reset = '1';\n        wait until reset = '0';\n        \n        event_counter := 0;\n        stop_sim <= false;\n        \n        for i in 1 to N_CYCLES loop\n            wait until rising_edge(clk);\n        end loop;\n        \n        stop_sim <= true;\n        \n        -- Allow one final delta cycle for processes to stop\n        wait for 0 ns; \n        \n        final_count <= event_counter;\n        \n        wait; -- Halt the control process\n    end process control_proc;\n\nend architecture behavioral;\n```\n\nAssume a VHDL simulator executes this code. Due to the properties of shared variables in concurrent processes, the final value of `event_counter`, reported on the `final_count` output port, is non-deterministic.\n\nDetermine the minimum possible value and the maximum possible value for `final_count` after the simulation completes. Calculate the sum of this minimum and maximum possible value.", "solution": "We analyze the execution per rising edge of the common clock. Both process_A and process_B are sensitive to $rising\\_edge(clk)$ and, when $stop\\_sim$ is false, each executes a read-modify-write on the shared variable:\n$$\nevent\\_counter := event\\_counter + 1.\n$$\nIn VHDL, shared variable updates are immediate, but concurrent processes resume in an unspecified order within the same delta cycle. Therefore, on a given rising edge:\n- If both processes read the same old value $x$ before either writes, they each compute $x+1$ and then write $x+1$, resulting in a single net increment. \n- If one process completes its increment before the other reads, the second reads $x+1$ and writes $x+2$, resulting in two net increments.\n\nThus, for each enabled rising edge $k$, the net increment $m_{k}$ satisfies $m_{k} \\in \\{1,2\\}$ and no other outcomes are possible.\n\nThe control process performs:\n1) It waits for $reset$ to assert and then de-assert, then executes $event\\_counter := 0$ and $stop\\_sim \\leq false$. The assignment to $event\\_counter$ ensures prior activity is cleared; the subsequent loop counts exactly the next $N\\_CYCLES$ rising edges.\n2) It then waits for exactly $N\\_CYCLES$ rising edges:\n$$\n\\text{for } i=1 \\text{ to } N\\_CYCLES: \\quad \\text{wait until } rising\\_edge(clk).\n$$\nDuring these $N\\_CYCLES$ edges, $stop\\_sim$ remains false as the assignment $stop\\_sim \\leq true$ occurs only after the loop and takes effect on the next delta cycle, so both processes are enabled at each of these edges.\n3) After the loop, it executes $stop\\_sim \\leq true$ and then $wait \\; for \\; 0 \\; ns$ to allow one delta cycle for the clocked processes to observe $stop\\_sim = true$ and cease further increments before assigning $final\\_count \\leq event\\_counter$.\n\nLet $N := N\\_CYCLES$. Starting from $event\\_counter = 0$ at the beginning of the counting window, after $N$ enabled rising edges the final shared variable value is\n$$\nevent\\_counter = \\sum_{k=1}^{N} m_{k}, \\quad \\text{with } m_{k} \\in \\{1,2\\}.\n$$\nTherefore, the minimum possible value is attained when every cycle loses one increment:\n$$\nevent\\_counter_{\\min} = \\sum_{k=1}^{N} 1 = N,\n$$\nand the maximum possible value is attained when both increments are preserved in every cycle:\n$$\nevent\\_counter_{\\max} = \\sum_{k=1}^{N} 2 = 2N.\n$$\nThe requested sum is\n$$\nevent\\_counter_{\\min} + event\\_counter_{\\max} = N + 2N = 3N.\n$$\nWith $N\\_CYCLES = 80$, we obtain\n$$\n3N = 3 \\times 80 = 240.\n$$", "answer": "$$\\boxed{240}$$", "id": "1976697"}, {"introduction": "VHDL is not limited to the predefined `std_logic` and `integer` types; its true power is revealed when designing custom data types to model complex systems. This advanced practice [@problem_id:1976728] challenges you to work with a custom resolved logic type that embeds a priority arbitration scheme directly into its behavior. By analyzing how multiple drivers on a shared bus are resolved, you will gain insight into how VHDL can be used to create elegant, high-level models of sophisticated hardware protocols.", "problem": "In digital systems design, a shared bus allows multiple components (masters) to communicate over a common set of wires. Managing access to this bus to prevent conflicts is crucial and is typically handled by an arbiter circuit. This problem explores a novel bus architecture that eliminates the need for an explicit arbiter by embedding the arbitration logic directly into the data type of the bus signals using features of the Very High-Speed Integrated Circuit Hardware Description Language (VHDL).\n\nConsider a custom VHDL logic type named `priority_logic`, defined as an enumerated type with the following possible values: `'U'` (Uninitialized), `'X'` (Unknown/Conflict), `'1'` (Logic High), `'0'` (Logic Low), and `'Z'` (High-Impedance).\n\nWhen multiple masters drive a single signal of this type simultaneously, a special resolution function determines the signal's final value. This function operates based on a strict priority scheme, where the value with the highest priority among all driving values \"wins\". The priority order is defined as:\n`'U' > 'X' > '1' > '0' > 'Z'`\n\nFor example, if three drivers attempt to place `'0'`, `'Z'`, and `'1'` on the line, the resolved value will be `'1'` because it has the highest priority of the three. If the drivers provide `'1'` and `'X'`, the resolved value will be `'X'`. If all drivers are `'Z'`, the line remains in the high-impedance state `'Z'`.\n\nNow, consider a 4-bit shared bus, `DATA_BUS`, where each bit is an independent signal of the resolved `priority_logic` type. This means each of the four bits is resolved independently according to the priority rule described above. Three masters, `M1`, `M2`, and `M3`, are connected to this bus. The system behaves according to the following sequence of events:\n\n1.  For all time `t < 10 ns`, the masters are driving the `DATA_BUS` with the following constant 4-bit values (from bit 3 down to bit 0):\n    *   `M1` drives `\"0Z1Z\"`\n    *   `M2` drives `\"ZZ01\"`\n    *   `M3` drives `\"ZZZZ\"`\n\n2.  At `t = 10 ns`, master `M3` changes its output and begins driving the value `\"X10X\"`.\n\n3.  At `t = 20 ns`, master `M1` changes its output and begins driving the value `\"Z110\"`.\n\nAssuming all signal changes are instantaneous, determine the 4-bit state of `DATA_BUS` at time `t = 25 ns`. Express your answer as a 4-character string representing the value of the bus from bit 3 down to bit 0.", "solution": "The bus uses a resolved type whose resolution function selects, for each bit independently, the highest-priority driven value according to the strict order $\\text{'U'}>\\text{'X'}>\\text{'1'}>\\text{'0'}>\\text{'Z'}$. Signal changes are instantaneous, so at $t=25\\,\\text{ns}$ the active drive values are those in effect after the last event at $t=20\\,\\text{ns}$. Thus the masters drive:\n- $M1$: \"Z110\" (changed at $t=20\\,\\text{ns}$),\n- $M2$: \"ZZ01\" (unchanged throughout),\n- $M3$: \"X10X\" (changed at $t=10\\,\\text{ns}$).\n\nResolve each bit from most significant (bit $3$) to least significant (bit $0$):\n- Bit $3$: $M1=\\text{'Z'}$, $M2=\\text{'Z'}$, $M3=\\text{'X'}$; the highest priority present is $\\text{'X'}$, so bit $3=\\text{'X'}$.\n- Bit $2$: $M1=\\text{'1'}$, $M2=\\text{'Z'}$, $M3=\\text{'1'}$; the highest priority present is $\\text{'1'}$, so bit $2=\\text{'1'}$.\n- Bit $1$: $M1=\\text{'1'}$, $M2=\\text{'0'}$, $M3=\\text{'0'}$; the highest priority present is $\\text{'1'}$, so bit $1=\\text{'1'}$.\n- Bit $0$: $M1=\\text{'0'}$, $M2=\\text{'1'}$, $M3=\\text{'X'}$; the highest priority present is $\\text{'X'}$, so bit $0=\\text{'X'}$.\n\nTherefore, the resolved 4-bit bus value at $t=25\\,\\text{ns}$ from bit $3$ to bit $0$ is \"X11X\".", "answer": "$$\\boxed{X11X}$$", "id": "1976728"}]}