{"hands_on_practices": [{"introduction": "This first exercise focuses on the fundamental rule of non-blocking assignments (=). By predicting the outcome of two simultaneous updates to different parts of the same register, you will see how all right-hand side expressions are evaluated *before* any left-hand side registers are updated. Understanding this core concept [@problem_id:1915845] is the first step to correctly modeling synchronous hardware.", "problem": "In a digital circuit design specified using the Verilog Hardware Description Language (HDL), a 4-bit register named `vec` is declared as `reg [3:0] vec;`. At time `t = 0`, the register holds the initial value `4'b0010`. The logic for updating this register is implemented within a clocked process sensitive to the positive edge of a clock signal `clk`, as shown in the code snippet below:\n\n```verilog\nalways @(posedge clk) begin\n  vec[1:0] = 2'b11;\n  vec[3:2] = vec[1:0];\nend\n```\n\nAssuming the system starts with the given initial value and the first positive clock edge occurs at time `t_1  0`, determine the binary value of the register `vec` immediately after this first clock edge.\n\nA. `4'b0010`\n\nB. `4'b0011`\n\nC. `4'b1011`\n\nD. `4'b1111`", "solution": "We are given a 4-bit register with initial value vec = 0010, i.e., $vec[3:0] = (0,0,1,0)$, so $vec[1:0] = (1,0)$ and $vec[3:2] = (0,0)$ at $t=0$.\n\nOn the first positive edge of clk at time $t_{1}$, the process executes two nonblocking assignments. The semantics of nonblocking assignments ($\\leq$) are:\n- All right-hand sides are evaluated using the pre-edge (old) values.\n- All left-hand sides are updated concurrently after the evaluations are complete.\n\nThus, at the posedge:\n1) The right-hand side of the first assignment is a constant, so it schedules\n$$vec[1:0] \\gets (1,1).$$\n2) The right-hand side of the second assignment is the old value of $vec[1:0]$, which is $(1,0)$, so it schedules\n$$vec[3:2] \\gets (1,0).$$\n\nAfter both scheduled updates take effect concurrently, the new register value is\n$$vec[3:0] = (1,0,1,1),$$\nwhich is the binary value 1011, i.e., option C.", "answer": "$$\\boxed{C}$$", "id": "1915845"}, {"introduction": "Building on the basic mechanism, this problem requires you to trace the state of a multi-register system over several clock cycles [@problem_id:1915874]. This simulates the behavior of real sequential circuits, like state machines or pipelines, where the output of one cycle becomes the input for the next. This practice is crucial for developing the skill to analyze and debug the temporal behavior of your digital designs.", "problem": "In a synchronous digital circuit, three 4-bit registers, `x`, `y`, and `z`, are updated on every rising edge of a clock signal. The behavior of these registers is described by a set of rules that are all evaluated concurrently based on the register values at the beginning of the clock cycle. The new values are then assigned simultaneously at the end of the evaluation. This type of update is known as a non-blocking assignment.\n\nThe initial values of the registers before the first clock edge are:\n- `x = 4`\n- `y = 1`\n- `z = 8`\n\nThe update logic that executes on each rising clock edge is as follows:\n1. `x` is assigned the value of `y + z`.\n2. `y` is assigned the value of `x`.\n3. If the value of `y` is `4`, then `z` is assigned the value of `z - 1`.\n\nAll registers are 4-bit unsigned integers, capable of holding values from 0 to 15. Any arithmetic operation that results in a value outside this range will wrap around. For example, an operation resulting in 17 would be stored as `17 \\mod 16 = 1`. An operation resulting in -1 would be stored as `-1 \\mod 16 = 15`.\n\nDetermine the decimal values of the registers `x`, `y`, and `z` immediately after the 3rd rising clock edge. Provide the three integer values in the specific order: x, then y, then z.", "solution": "Treat the 4-bit unsigned arithmetic as computations modulo $16$. Because the updates are non-blocking, each right-hand side and the conditional test use the register values at the beginning of the clock cycle, and all new values are latched simultaneously at the clock edge.\n\nLet $(x_{n},y_{n},z_{n})$ denote the register values immediately after the $n$-th rising edge, with initial pre-edge values $(x_{0},y_{0},z_{0})=(4,1,8)$. The update rules per cycle using the old values are:\n$$\nx^{+}\\equiv (y+z)\\bmod 16,\\quad y^{+}\\equiv x,\\quad z^{+}\\equiv\n\\begin{cases}\n(z-1)\\bmod 16, \\text{if } y=4,\\\\\nz, \\text{if } y\\neq 4.\n\\end{cases}\n$$\n\nFirst rising edge (from $(x_{0},y_{0},z_{0})=(4,1,8)$):\n$$\nx_{1}\\equiv (y_{0}+z_{0})\\bmod 16=(1+8)\\bmod 16=9,\\quad\ny_{1}\\equiv x_{0}=4,\\quad\nz_{1}\\equiv z_{0}=8\\ \\ (\\text{since }y_{0}\\neq 4).\n$$\n\nSecond rising edge (from $(x_{1},y_{1},z_{1})=(9,4,8)$):\n$$\nx_{2}\\equiv (y_{1}+z_{1})\\bmod 16=(4+8)\\bmod 16=12,\\quad\ny_{2}\\equiv x_{1}=9,\\quad\nz_{2}\\equiv (z_{1}-1)\\bmod 16=(8-1)\\bmod 16=7\\ \\ (\\text{since }y_{1}=4).\n$$\n\nThird rising edge (from $(x_{2},y_{2},z_{2})=(12,9,7)$):\n$$\nx_{3}\\equiv (y_{2}+z_{2})\\bmod 16=(9+7)\\bmod 16=16\\bmod 16=0,\\quad\ny_{3}\\equiv x_{2}=12,\\quad\nz_{3}\\equiv z_{2}=7\\ \\ (\\text{since }y_{2}\\neq 4).\n$$\n\nTherefore, immediately after the third rising edge, the registers are $(x,y,z)=(0,12,7)$.", "answer": "$$\\boxed{\\begin{pmatrix}0  12  7\\end{pmatrix}}$$", "id": "1915874"}, {"introduction": "This final practice shifts our focus from sequential to purely combinational logic, addressing a critical design rule: use blocking assignments ($=$) for combinational `always @(*)` blocks. You are asked to analyze several implementations of a priority encoder and identify the one that functions correctly without simulation issues [@problem_id:1915902]. This exercise solidifies the distinction between modeling sequential and combinational logic, a key to robust and reliable digital design.", "problem": "A junior digital design engineer is tasked with creating a 4-to-2 priority encoder in Verilog. The encoder has a 4-bit data input `d[3:0]`, a 2-bit encoded output `y[1:0]`, and a 1-bit valid output `v`. The circuit should function as follows:\n\n-   The output `y` should represent the binary index of the most significant bit (MSB) that is high in the input `d`. The priority is from MSB to LSB, meaning `d[3]` has the highest priority and `d[0]` has the lowest.\n-   If `d[3]` is high, `y` should be `2'b11`.\n-   If `d[3]` is low but `d[2]` is high, `y` should be `2'b10`.\n-   If `d[3]` and `d[2]` are low but `d[1]` is high, `y` should be `2'b01`.\n-   If `d[3]`, `d[2]`, and `d[1]` are low but `d[0]` is high, `y` should be `2'b00`.\n-   The valid bit `v` should be high if at least one bit in `d` is high. If `d` is `4'b0000`, then `v` should be low and the value of `y` is irrelevant (don't care).\n\nThe engineer wrote an initial implementation using a single combinational `always @(*)` block. However, during simulation, the outputs `y` and `v` do not update correctly within the same simulation time step as the input `d`, leading to functional failures when integrated into a larger system.\n\nYour task is to identify the correct implementation from the options below that describes a purely combinational priority encoder and will reliably produce the correct outputs in simulation and synthesis.\n\nA.\n```verilog\nalways @(*) begin\n  if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nB.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nC.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nD.\n```verilog\nalways @(*) begin\n  casex (d)\n    4'b1xxx: y = 2'b11;\n    4'b01xx: y = 2'b10;\n    4'b001x: y = 2'b01;\n    4'b0001: y = 2'b00;\n    default: y = 2'b00; // a 'don't care' value\n  endcase\n  \n  if (d != 4'b0000) begin\n    v = 1'b1;\n  end else begin\n    v = 1'b0;\n  end\nend\n```\n\nE.\n```verilog\nalways @(*) begin\n  y = 2'b00; // Default assignment\n  v = 1'b0;  // Default assignment\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) {v, y} = {1'b1, 2'b00};\nend\n```", "solution": "We require a purely combinational priority encoder that:\n- Gives MSB-first priority: check $d[3]$, then $d[2]$, then $d[1]$, then $d[0]$.\n- Drives both outputs in all branches to avoid latches.\n- Uses blocking assignments in a combinational always block so that outputs reflect input changes within the same simulation time step (delta cycle). Using nonblocking assignments in combinational logic can defer updates, creating the very simulation issue described.\n\nEvaluate each option:\n\nA. This uses blocking assignments in a combinational block, but it checks from LSB to MSB. If multiple bits are high, it will incorrectly prioritize $d[0]$ over $d[3]$, violating the required MSB-first priority. Therefore, A is incorrect.\n\nB. This uses nonblocking assignments in a combinational always block. Nonblocking defers updates until the end of the time step, which can cause the outputs not to update as expected within the same simulation time step when integrated with other logic. This matches the reported failure mode, so B is not the correct fix.\n\nC. This uses blocking assignments in a combinational always block with the correct MSB-to-LSB priority ordering. All outputs are assigned in all branches, so no latches are inferred. This is the standard, reliable style for a combinational priority encoder in both simulation and synthesis.\n\nD. This uses casex for prioritization and a separate conditional for the valid bit. While combinational and synthesizable, casex can introduce simulation-synthesis mismatches and mask unknowns, and the separate valid computation using a four-state comparison can behave unexpectedly in the presence of unknowns. The problem asks for a reliably correct implementation; this style is generally discouraged compared to a straightforward if-else chain with blocking assignments.\n\nE. This mixes blocking (defaults) and nonblocking (conditional updates) assignments within the same combinational always block, which is a known bad practice leading to race conditions and the same simulation timing issues. Therefore, E is incorrect.\n\nHence, the correct implementation is C.", "answer": "$$\\boxed{C}$$", "id": "1915902"}]}