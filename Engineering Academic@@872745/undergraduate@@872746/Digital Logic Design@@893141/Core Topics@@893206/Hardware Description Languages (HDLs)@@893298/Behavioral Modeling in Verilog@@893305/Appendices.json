{"hands_on_practices": [{"introduction": "Behavioral modeling in Verilog allows us to describe complex hardware using high-level, procedural-style constructs. A `for` loop, for instance, is a powerful tool not for sequential execution over time, but for describing regular, repetitive combinational logic. This practice [@problem_id:1912832] explores this concept by tackling a common data formatting task: reversing the bit order of a data vector, a frequent necessity when interfacing between systems with different bit-level conventions.", "problem": "In the process of designing an interface between a modern Field-Programmable Gate Array (FPGA) and a legacy peripheral device, an engineer discovers a data-formatting incompatibility. The legacy device uses an 8-bit parallel bus, but it interprets the bit order in reverse of the standard MSB-first (Most Significant Bit) convention. Specifically, the bit that the FPGA considers `data[7]` (the MSB) is treated as bit 0 by the peripheral, `data[6]` is treated as bit 1, and so on, down to `data[0]` (the Least Significant Bit, LSB) which is treated as bit 7.\n\nTo address this, a behavioral Verilog module must be created. This module will have an 8-bit input port `data_in` and an 8-bit output port `data_out_rev`. The logic must ensure that for any given `data_in`, the output `data_out_rev` is the bit-reversed version. For example, if `data_in` is `8'b11001010`, `data_out_rev` must be `8'b01010011`.\n\nWhich of the following behavioral Verilog code snippets, designed to be placed within an `always @(data_in)` block, correctly implements this bit-reversal logic? Assume `data_out_rev` has been declared as `reg [7:0] data_out_rev;`.\n\nA.\n```verilog\ninteger i;\nfor (i = 0; i < 8; i = i + 1) begin\n    data_out_rev[i] = data_in[7-i];\nend\n```\n\nB.\n```verilog\ninteger i;\nfor (i = 0; i < 8; i = i + 1) begin\n    data_out_rev[i] = data_in[i];\nend\n```\n\nC.\n```verilog\ndata_out_rev = ~data_in;\n```\n\nD.\n```verilog\ndata_out_rev = ^data_in;\n```", "solution": "We require the output bus to be the bit-reversed version of the input bus. Formally, for all bit indices $i \\in \\{0,1,\\dots,7\\}$, the correct mapping is\n$$\n\\text{data\\_out\\_rev}[i] = \\text{data\\_in}[7 - i].\n$$\nEvaluating each option:\n\n- Option A implements exactly the required mapping with a loop over $i$ from $0$ to $7$, assigning $\\text{data\\_out\\_rev}[i] = \\text{data\\_in}[7-i]$. This matches the specification.\n\n- Option B assigns $\\text{data\\_out\\_rev}[i] = \\text{data\\_in}[i]$, which leaves the bit order unchanged and therefore does not reverse the bits.\n\n- Option C performs a bitwise inversion: $\\text{data\\_out\\_rev}[i] = \\lnot \\text{data\\_in}[i]$. This complements bits rather than reversing their positions.\n\n- Option D applies a reduction XOR on $\\text{data\\_in}$, producing a single-bit parity result $\\bigoplus_{i=0}^{7} \\text{data\\_in}[i]$, which does not implement bit reversal and does not produce the required 8-bit reversed vector.\n\nTherefore, only Option A is correct.", "answer": "$$\\boxed{A}$$", "id": "1912832"}, {"introduction": "Moving from structured data manipulation to implementing specific logical specifications, digital systems often need to perform calculations based on mathematical formulas, such as those for error-correction codes. Behavioral Verilog excels at translating these logical equations directly into hardware description. This practice [@problem_id:1912766] challenges you to implement a (7,4) Hamming code generator, which involves calculating parity bits using XOR operationsâ€”a perfect demonstration of how concise behavioral code can describe complex, purely combinational logic.", "problem": "You are tasked with designing a purely combinational (7,4) Hamming code generator circuit in Verilog. The circuit takes a 4-bit data word as input and produces a 7-bit codeword as output.\n\nThe input is a 4-bit vector named `data_in[3:0]`. These four bits correspond to the data portions of the Hamming code, which we will denote as $d_4, d_3, d_2, d_1$, according to the following mapping:\n- $d_4 = \\text{data\\_in}[3]$\n- $d_3 = \\text{data\\_in}[2]$\n- $d_2 = \\text{data\\_in}[1]$\n- $d_1 = \\text{data\\_in}[0]$\n\nThe circuit must calculate three even-parity bits, $p_4, p_2, p_1$, based on the following standard parity-check equations, where $\\oplus$ denotes the bitwise XOR operation:\n- $p_1 = d_1 \\oplus d_2 \\oplus d_4$\n- $p_2 = d_1 \\oplus d_3 \\oplus d_4$\n- $p_4 = d_2 \\oplus d_3 \\oplus d_4$\n\nThe final 7-bit output, `hamming_out[6:0]`, must be assembled by arranging the data bits and the calculated parity bits in specific positions as follows:\n- `hamming_out[6]` = $d_4$\n- `hamming_out[5]` = $d_3$\n- `hamming_out[4]` = $d_2$\n- `hamming_out[3]` = $p_4$\n- `hamming_out[2]` = $d_1$\n- `hamming_out[1]` = $p_2$\n- `hamming_out[0]` = $p_1$\n\nGiven these specifications, identify which of the following Verilog modules correctly implements the behavioral model for this Hamming code generator.\n\nA.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Parity bits\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        // Data bits\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nB.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @(data_in[1], data_in[2]) begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nC.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] & data_in[2] & data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nD.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nE.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Incorrect mapping of data bits to output\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[2]; // Wrong\n        hamming_out[5] = data_in[1]; // Wrong\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```", "solution": "We are given the data-to-symbol mapping $d_{4}=\\text{data\\_in}[3]$, $d_{3}=\\text{data\\_in}[2]$, $d_{2}=\\text{data\\_in}[1]$, $d_{1}=\\text{data\\_in}[0]$ and the even-parity equations\n$$\np_{1}=d_{1}\\oplus d_{2}\\oplus d_{4},\\quad\np_{2}=d_{1}\\oplus d_{3}\\oplus d_{4},\\quad\np_{4}=d_{2}\\oplus d_{3}\\oplus d_{4}.\n$$\nIn terms of data\\_in indexing, these become\n$$\np_{1}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[1]\\oplus \\text{data\\_in}[3],\\quad\np_{2}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3],\\quad\np_{4}=\\text{data\\_in}[1]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3].\n$$\nThe required output mapping is\n$$\n\\text{hamming\\_out}[6]=d_{4}=\\text{data\\_in}[3],\\;\n\\text{hamming\\_out}[5]=d_{3}=\\text{data\\_in}[2],\\;\n\\text{hamming\\_out}[4]=d_{2}=\\text{data\\_in}[1],\\;\n\\text{hamming\\_out}[3]=p_{4},\\;\n\\text{hamming\\_out}[2]=d_{1}=\\text{data\\_in}[0],\\;\n\\text{hamming\\_out}[1]=p_{2},\\;\n\\text{hamming\\_out}[0]=p_{1}.\n$$\nNow check each option:\n\n- Option A uses always @* (combinational), computes $p_{1}$, $p_{2}$, $p_{4}$ exactly as above with the XOR operator, and assigns data bits to indices $[2],[4],[5],[6]$ exactly as required. This matches both the parity equations and the bit placement, and is purely combinational. Therefore A is correct.\n\n- Option B uses an incomplete sensitivity list always @(data\\_in[1], data\\_in[2]). This omits $\\text{data\\_in}[0]$ and $\\text{data\\_in}[3]$, so it does not model a correct purely combinational behavior in simulation, even though the assignments themselves match the equations. Therefore B is not correct as a behavioral model.\n\n- Option C incorrectly computes $p_{4}$ using the bitwise AND operator instead of XOR. Therefore C is incorrect.\n\n- Option D declares the output as a wire (implicit) but assigns it within an always block, which requires a reg type in Verilog. This is not a correct Verilog behavioral description. Therefore D is incorrect.\n\n- Option E swaps $\\text{hamming\\_out}[4]$ and $\\text{hamming\\_out}[5]$ for the data bits, contradicting the required mapping. Therefore E is incorrect.\n\nHence the only correct module is A.", "answer": "$$\\boxed{A}$$", "id": "1912766"}, {"introduction": "Our exploration culminates with the crucial leap from combinational (stateless) to sequential (stateful) logic, which is essential for systems that must remember past events and manage behavior over time. This final practice [@problem_id:1912819] presents a classic and indispensable real-world problem: debouncing a mechanical push-button. You will analyze a complete sequential circuit that uses a Finite State Machine (FSM) and a counter to filter a noisy input and produce a clean, single-cycle pulse, synthesizing the core concepts of state, timing, and robust input handling.", "problem": "In digital systems, mechanical push-buttons and switches are common user inputs. However, they suffer from a physical phenomenon known as \"contact bounce\" or \"chatter,\" where a single press or release action generates a rapid series of noisy, invalid transitions between logic high and low before settling to a stable state. To use such a button as a reliable digital input, a \"debouncer\" circuit is required.\n\nYour task is to analyze Verilog implementations of a push-button debouncer. The debouncer should operate based on a Finite State Machine (FSM) and a counter. The specifications for the debouncer module are as follows:\n\n**Module Interface:**\n-   `clk`: System clock input.\n-   `reset_n`: Active-low asynchronous reset input.\n-   `button_in`: The noisy input from a push-button. It is normally high (logic 1) and goes low (logic 0) when pressed.\n-   `pulse_out`: The clean, debounced output.\n\n**Functional Behavior:**\n1.  The circuit should detect when the `button_in` signal is pressed (goes to 0).\n2.  After detection, it must wait to confirm that `button_in` remains stable at logic 0 for exactly 16 consecutive clock cycles.\n3.  If the signal is stable for the required duration, the module must generate a clean, single-cycle high pulse on `pulse_out`.\n4.  After the pulse is generated, the circuit must wait for the `button_in` to be released (return to 1) before it is ready to detect another press. This prevents multiple pulses if the button is held down for a long time.\n5.  If at any point during the 16-cycle stability check the `button_in` signal bounces back to 1, the check fails, the timer must be reset, and the circuit should return to its initial state.\n6.  The asynchronous `reset_n` signal, when asserted (low), must immediately return the FSM to its initial state, reset any counters, and ensure `pulse_out` is low.\n\n**FSM and Implementation Details:**\nThe FSM uses four states defined by parameters:\n`parameter IDLE = 2'b00, WAIT_STABLE = 2'b01, PULSE = 2'b10, WAIT_RELEASE = 2'b11;`\nIt also uses a parameter for the stability duration and a counter register:\n`parameter STABLE_CYCLES = 16;`\n`reg [3:0] counter;`\n\nYou are given four different Verilog code snippets, each claiming to implement the logic inside an `always @(posedge clk or negedge reset_n)` block for this debouncer. Only one of them correctly implements all the specified behaviors. Identify the correct implementation.\n\nA.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin\n                pulse_out <= 1'b0;\n                if (button_in) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= IDLE; // Transition to IDLE\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin // Unused state\n                pulse_out <= 1'b0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin\n                // pulse_out is not assigned here\n                if (button_in) begin\n                    state <= IDLE;\n                    pulse_out <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    // Counter not reset here\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0; // Counter is reset here\n            end\n            WAIT_RELEASE: begin\n                pulse_out <= 1'b0;\n                if (button_in) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n```", "solution": "We restate the required FSM behavior as constraints to verify against each implementation:\n- On asynchronous reset assertion, the FSM must go to IDLE, the counter to $0$, and $pulse\\_out=0$ immediately.\n- From IDLE, upon detecting a press ($button\\_in=0$), the FSM must go to WAIT\\_STABLE and reset the counter to $0$.\n- In WAIT\\_STABLE, while $button\\_in=0$, it must count consecutive stable low cycles and, upon exactly $STABLE\\_CYCLES=16$ such cycles, transition to PULSE. If $button\\_in$ returns to $1$ at any time before reaching $16$, the check fails, the timer must be reset, and it must return to IDLE.\n- In PULSE, it must assert $pulse\\_out=1$ for exactly one clock cycle, then transition to WAIT\\_RELEASE and ensure the counter is reset.\n- In WAIT\\_RELEASE, it must deassert $pulse\\_out$ and wait until release ($button\\_in=1$) to return to IDLE, thereby preventing multiple pulses if the button remains pressed.\n\nWe now analyze the correctness of the cycle-counting mechanism used: entering WAIT\\_STABLE with $counter=0$, the logic checks $counter==STABLE\\_CYCLES-1=15$. With nonblocking assignments, at each rising clock edge in WAIT\\_STABLE while $button\\_in=0$:\n- For the first stable cycle after entry, the old $counter=0\\neq 15$, so it increments to $1$.\n- After $k$ stable cycles, the old $counter=k-1$; it increments to $k$ if $k-1\\neq 15$.\n- On the $16$th stable cycle, the old $counter=15$, which satisfies $counter==15$, so the FSM transitions to PULSE at that clock. Therefore, the PULSE state is reached exactly after $16$ consecutive stable low cycles have been observed, satisfying the specification.\n\nCheck option A:\n- IDLE: on press, transitions to WAIT\\_STABLE and resets $counter$ to $0$; $pulse\\_out=0$.\n- WAIT\\_STABLE: while $button\\_in=0$, it increments $counter$ and transitions to PULSE when $counter==15$, giving exactly $16$ cycles as shown above. If $button\\_in$ returns to $1$, it transitions to IDLE. Although it does not explicitly reset $counter$ on this bounce, the counter is reset upon the next entry into WAIT\\_STABLE from IDLE, so the timer is effectively reset before any new stability check begins, meeting the functional requirement.\n- PULSE: asserts $pulse\\_out=1$ and transitions to WAIT\\_RELEASE on the next clock; $counter$ is reset, guaranteeing a single-cycle pulse.\n- WAIT\\_RELEASE: forces $pulse\\_out=0$ and waits for release ($button\\_in=1$) before returning to IDLE, preventing multiple pulses while the button remains held.\n- Reset behavior is correct. Therefore, A satisfies all requirements.\n\nCheck option B:\n- PULSE transitions directly to IDLE, bypassing WAIT\\_RELEASE. If the button remains pressed, IDLE will immediately detect $button\\_in=0$ and start a new WAIT\\_STABLE period, allowing repeated pulses every $16$ cycles while the button is held. This violates the requirement to wait for release after the pulse. Hence B is incorrect.\n\nCheck option C:\n- In WAIT\\_RELEASE, $pulse\\_out$ is not driven low unless $button\\_in$ is $1$. Coming from PULSE with $pulse\\_out=1$, if the button remains held ($button\\_in=0$), $pulse\\_out$ retains its previous value $1$, producing a multi-cycle pulse. This violates the single-cycle pulse requirement. Hence C is incorrect.\n\nCheck option D:\n- In IDLE, on detecting a press, it does not reset the counter before entering WAIT\\_STABLE. Thus the wait length depends on a potentially stale counter value from a previous attempt, which can shorten the required $16$-cycle confirmation and violates the requirement that the timer be reset when starting a new detection. It also fails to reset the timer upon bounce back to IDLE until later in PULSE, which is too late. Hence D is incorrect.\n\nTherefore, only option A correctly implements all specified behaviors.", "answer": "$$\\boxed{A}$$", "id": "1912819"}]}