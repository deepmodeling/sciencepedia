{"hands_on_practices": [{"introduction": "We begin our hands-on journey with a cornerstone of sequential circuit design: a counter with an asynchronous reset. This exercise is fundamental because it teaches the standard VHDL template for creating stateful logic that can be immediately forced into a known state, a crucial requirement for system initialization. By correctly structuring the process sensitivity list and the `if-elsif` statement, you will learn how VHDL differentiates between asynchronous events and synchronous, clock-edge-triggered behavior [@problem_id:1976164].", "problem": "You are tasked with designing a component in a Very High-Speed Integrated Circuit Hardware Description Language (VHDL) for a digital system. The component is a 3-bit binary down-counter with the following specifications:\n- It has a clock input `clk`.\n- It has an active-low asynchronous reset input `rst_n`.\n- It has a 3-bit output `q_out`.\n\nThe behavior of the counter must be as follows:\n1.  When the reset signal `rst_n` is asserted (i.e., when `rst_n` is logic '0'), the output `q_out` must immediately and asynchronously be set to the value `111`.\n2.  When the reset is not asserted, on each rising edge of the clock `clk`, the counter's value must decrement by one.\n3.  The counter should wrap around. That is, when it decrements from `000`, the next state should be `111`.\n\nAssume the following VHDL context is provided:\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\nUSE ieee.numeric_std.ALL;\n\nENTITY down_counter IS\n  PORT (\n    clk   : IN  std_logic;\n    rst_n : IN  std_logic;\n    q_out : OUT std_logic_vector(2 DOWNTO 0)\n  );\nEND ENTITY down_counter;\n\nARCHITECTURE behavioral OF down_counter IS\n  SIGNAL q_reg : unsigned(2 DOWNTO 0);\nBEGIN\n\n  -- A VHDL process block goes here --\n  \n  q_out = std_logic_vector(q_reg);\n\nEND ARCHITECTURE behavioral;\n```\n\nWhich of the following VHDL `PROCESS` blocks, when inserted into the architecture above, correctly implements the specified 3-bit down-counter?\n\nA.\n```vhdl\ncounter_proc : PROCESS (clk)\nBEGIN\n  IF rising_edge(clk) THEN\n    IF rst_n = '0' THEN\n      q_reg = \"111\";\n    ELSE\n      q_reg = q_reg - 1;\n    END IF;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nB.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '1' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nC.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg + 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nD.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nE.\n```vhdl\ncounter_proc : PROCESS (clk, q_reg)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```", "solution": "We identify the required behaviors and map them to VHDL process structure and sensitivity requirements:\n\n1) Asynchronous, active-low reset:\n- Asynchronous reset means the process must be sensitive to the reset signal and assign the reset value immediately when the reset condition is met, independent of the clock edge. Therefore, the process sensitivity list must include both the clock and the reset signals, i.e., it must contain $clk$ and $rst\\_n$.\n- Active-low means the reset action must occur when $rst\\_n = '0'$.\n- The standard VHDL template for an asynchronous reset places the reset condition as the first branch before the clock edge test: IF $rst\\_n = '0'$ THEN reset action; ELSIF rising\\_edge($clk$) THEN sequential action; END IF.\n\n2) Decrement on rising edge of clock:\n- When reset is not asserted, the counter must decrement by one on each rising edge of $clk$: this requires the ELSIF rising\\_edge($clk$) branch to perform $q\\_reg \\leftarrow q\\_reg - 1$.\n\n3) Wrap-around from $000$ to $111$:\n- Using ieee.numeric\\_std with type unsigned, the operation $q\\_reg - 1$ on a fixed-width unsigned vector wraps modulo $2^{3}$. Thus $000 - 1$ becomes $111$ automatically, satisfying the wrap requirement without extra logic.\n\nNow evaluate each option against these requirements:\n\n- Option A: The process sensitivity list contains only $clk$, and the reset check is inside the rising edge branch. This implements a synchronous reset, not an asynchronous one. Therefore, it does not meet the asynchronous reset requirement.\n\n- Option B: The sensitivity list includes $clk$ and $rst\\_n$, but it resets on $rst\\_n = '1'$. This implements an active-high reset, which contradicts the active-low requirement.\n\n- Option C: The sensitivity list and active-low asynchronous reset are correctly placed, but the clocked action increments, $q\\_reg \\leftarrow q\\_reg + 1$, instead of decrementing. This violates the specified behavior.\n\n- Option D: The sensitivity list includes $clk$ and $rst\\_n$. The first branch resets on $rst\\_n = '0'$ (active-low, asynchronous), and the ELSIF rising\\_edge($clk$) branch performs $q\\_reg \\leftarrow q\\_reg - 1$, which decrements with correct modulo $2^{3}$ wrap-around. This matches all requirements.\n\n- Option E: The sensitivity list incorrectly uses $(clk, q\\_reg)$ and omits $rst\\_n$, so changes on $rst\\_n$ would not trigger the process, violating the asynchronous reset requirement.\n\nTherefore, the only option that correctly implements the specified 3-bit down-counter is Option D.", "answer": "$$\\boxed{D}$$", "id": "1976164"}, {"introduction": "While processes are often associated with clocked, sequential logic, they are also a powerful way to describe complex combinational circuits. This practice shifts our focus to just that, tasking you with creating a parity generator using a `for` loop. This exercise [@problem_id:1976114] is vital for understanding how iterative structures synthesize into hardware and, more importantly, it illuminates the critical distinction between variables and signals within a process—a common point of confusion that has a significant impact on simulation and synthesis results.", "problem": "In the context of Very High-Speed Integrated Circuit (VHSIC) Hardware Description Language (VHDL), you are tasked with designing a combinatorial logic circuit that computes the odd parity of a 16-bit data bus. The entity for this circuit is defined as follows:\n\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\n\nENTITY parity_checker IS\n    PORT (\n        data_in        : IN  STD_LOGIC_VECTOR(15 DOWNTO 0);\n        odd_parity_out : OUT STD_LOGIC\n    );\nEND ENTITY parity_checker;\n```\n\nThe output `odd_parity_out` should be '1' if the number of '1's in the input `data_in` is odd, and '0' otherwise. The implementation must use a sequential process containing a `FOR` loop to iterate through the bits of the input bus.\n\nBelow are five potential architectures for the `parity_checker`. Which of the following VHDL code snippets correctly and robustly implements the desired odd parity generator?\n\n**A.**\n```vhdl\nARCHITECTURE behavioral_A OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        temp_parity := '0';\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out = temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_A;\n```\n\n**B.**\n```vhdl\nARCHITECTURE behavioral_B OF parity_checker IS\n    signal temp_parity : std_logic;\nBEGIN\n    process(data_in)\n    begin\n        temp_parity = '0';\n        for i in 0 to 15 loop\n            temp_parity = temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out = temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_B;\n```\n\n**C.**\n```vhdl\nARCHITECTURE behavioral_C OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out = temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_C;\n```\n\n**D.**\n```vhdl\nARCHITECTURE behavioral_D OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        temp_parity := '1';\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n        end loop;\n        odd_parity_out = temp_parity;\n    end process;\nEND ARCHITECTURE behavioral_D;\n```\n\n**E.**\n```vhdl\nARCHITECTURE behavioral_E OF parity_checker IS\nBEGIN\n    process(data_in)\n        variable temp_parity : std_logic;\n    begin\n        temp_parity := '0';\n        for i in 0 to 15 loop\n            temp_parity := temp_parity xor data_in(i);\n            odd_parity_out = temp_parity;\n        end loop;\n    end process;\nEND ARCHITECTURE behavioral_E;\n```", "solution": "We need a combinational odd-parity generator over a 16-bit vector. By definition, odd parity is the XOR reduction of all bits, starting from an initial neutral element '0'. In symbolic terms, the required output is\n$$\n\\text{odd\\_parity\\_out} = \\bigoplus_{i=0}^{15} \\text{data\\_in}(i),\n$$\nwhere XOR of an even number of '1's yields '0' and of an odd number yields '1'.\n\nIn VHDL, within a combinational process:\n- A variable updates immediately on assignment inside the process and therefore can be safely used to accumulate over a loop, provided it is initialized at the start of the process.\n- A signal assignment inside the process does not take effect until the process suspends; thus, reading that signal within the same process activation yields its old value. Using a signal as an accumulator in a loop will not work as intended.\n- Failing to initialize a variable used as an accumulator leads to an undefined ('U') value propagating through XOR operations.\n- Initializing the accumulator to '1' inverts the parity result (producing even parity instead of odd).\n- Assigning the output repeatedly inside the loop is functionally redundant and less robust style; although the last assignment will determine the final value after the process suspends, robust practice is to assign the output once after producing the final accumulated value.\n\nEvaluate each option:\n\nA. Uses a process sensitive to data_in, a variable accumulator initialized to '0', XORs all bits in a for loop, and assigns the result to the output after the loop. This matches\n$$\n\\text{temp\\_parity} := '0';\\quad \\text{temp\\_parity} := \\text{temp\\_parity} \\oplus \\text{data\\_in}(i)\\ \\forall i;\\quad \\text{odd\\_parity\\_out} \\leftarrow \\text{temp\\_parity},\n$$\nwhich implements the desired XOR reduction correctly and robustly. Correct.\n\nB. Uses a signal as an accumulator inside the process. Because signal reads return the old value during the process activation and updates are scheduled for after suspension, each loop iteration uses the same stale value, and the final scheduled value effectively depends only on the last iteration. This does not compute the XOR reduction. Incorrect.\n\nC. Uses a variable accumulator but does not initialize it. The initial value is 'U', and XOR with 'U' remains 'U' under std_logic_1164, so the result is undefined. Incorrect.\n\nD. Initializes the variable to '1' and then XORs all bits, which yields the logical complement of the desired odd parity:\n$$\n'1' \\oplus \\bigoplus_{i=0}^{15} \\text{data\\_in}(i),\n$$\nwhich is the even parity indicator. Incorrect.\n\nE. Initializes the variable to '0', accumulates XOR in a loop, but assigns the output inside the loop on every iteration. While the final value after the process suspends will match the last assigned temp_parity (i.e., the correct parity), this practice is less robust and not idiomatic; robust combinational coding assigns outputs once after computing the final value to avoid potential maintenance hazards if loop bounds or conditions change. Compared to A, A is the clean, canonical, and robust implementation.\n\nTherefore, the correctly and robustly implemented architecture is A.", "answer": "$$\\boxed{A}$$", "id": "1976114"}, {"introduction": "Our final practice delves into a more advanced and subtle aspect of VHDL: the discrepancy between simulation behavior and synthesized hardware. This problem presents a common design flaw—a combinational feedback loop—that can be challenging for new designers to identify. By analyzing this code [@problem_id:1976132], you will explore why an event-driven simulator may get stuck in a zero-delay infinite loop, while a synthesis tool would create a physical oscillator, providing a deep insight into the underlying models of VHDL and the importance of writing synthesizable code.", "problem": "An engineer is designing a simple fault detection module in a system using the VHSIC Hardware Description Language (VHDL). The module has an input `system_ok` which is '1' during normal operation and '0' when a fault is detected. The module has an output `alarm_active`. The design intent is that when a fault occurs (`system_ok` = '0'), the `alarm_active` signal should begin to toggle, presumably to flash a status light-emitting diode (LED). If the system returns to normal (`system_ok` = '1'), the alarm should be reset to '0'.\n\nThe engineer has written the following VHDL code. Analyze the `p_alarm_logic` process, specifically the behavior that occurs when the `system_ok` input is held at a constant value of '0'.\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity fault_detector is\n    port (\n        system_ok    : in  std_logic;\n        alarm_active : out std_logic\n    );\nend entity fault_detector;\n\narchitecture behavioral of fault_detector is\n    signal internal_alarm : std_logic := '0';\nbegin\n\n    -- Process to control the alarm state\n    p_alarm_logic : process(system_ok, internal_alarm)\n    begin\n        if system_ok = '1' then\n            internal_alarm = '0';\n        else\n            -- When system is not okay, toggle the alarm\n            internal_alarm = not internal_alarm;\n        end if;\n    end process p_alarm_logic;\n\n    -- Assign internal state to the output port\n    alarm_active = internal_alarm;\n\nend architecture behavioral;\n```\n\nWhich of the following options most accurately describes the discrepancy between the behavior of this code in a standard event-driven VHDL simulator and the behavior of the physical circuit produced by a typical RTL synthesis tool when `system_ok` is held at '0'?\n\nA. **Simulation:** The signal `internal_alarm` will be stably latched to a value of '1'. **Synthesis:** A transparent latch is created that holds the value '1' as long as `system_ok` is '0'.\nB. **Simulation:** The simulator reports a stable state for `internal_alarm` after a single logic inversion from its previous value. **Synthesis:** A simple inverter is created whose input is tied to ground and whose output drives `alarm_active`.\nC. **Simulation:** The simulator is likely to halt and report an error due to exceeding an iteration limit in a zero-delay infinite loop. **Synthesis:** A free-running asynchronous oscillator is created.\nD. **Simulation:** The signal `internal_alarm` toggles its value exactly once per a predefined simulation time step (e.g., 1 ns). **Synthesis:** A T-type flip-flop is incorrectly inferred, which is then flagged as an error due to a missing clock signal.\nE. **Simulation:** The code simulates without error, showing `internal_alarm` toggling at a very high, simulator-dependent frequency. **Synthesis:** The code is considered fundamentally non-synthesizable and will be rejected by the synthesis tool with a fatal error.", "solution": "We analyze the process semantics and the synthesized hardware separately under the condition that the input is held at the constant value $system\\_ok = '0'$.\n\nFirst, express the process behavior symbolically. Let $s$ denote $system\\_ok$, $i$ denote the current value of $internal\\_alarm$, and $i^{+}$ denote the value of $internal\\_alarm$ scheduled by the process (the next value after the current delta cycle). The process implements the Boolean mapping\n$$\ni^{+} =\n\\begin{cases}\n0,  s = '1' \\\\\n\\lnot i,  s = '0'\n\\end{cases}\n$$\nand the process is sensitive to both $s$ and $i$.\n\nEvent-driven simulation behavior for $s = '0'$:\n1. With $s = '0'$ held constant, the process mapping reduces to $i^{+} = \\lnot i$.\n2. In VHDL signal assignment within a process with a sensitivity list is scheduled to take effect after the process suspends, i.e., on the next delta cycle at the same simulation time. Therefore, after the process computes $i^{+} = \\lnot i$, the simulator updates $i \\leftarrow i^{+}$ on the next delta cycle without advancing simulation time.\n3. Because the process sensitivity list includes $internal\\_alarm$, this update to $i$ is an event that immediately re-triggers the process in the same simulation time. The condition $s = '0'$ still holds, so the process computes $i^{+} = \\lnot i$ again.\n4. The result is an infinite sequence of delta cycles at the same simulation time with $i$ toggling each delta: $i \\mapsto \\lnot i \\mapsto \\lnot(\\lnot i) \\mapsto \\cdots$, which never converges in zero delay. Standard event-driven simulators detect this as a zero-delay non-convergent oscillation and terminate with an error such as an iteration limit exceeded or non-convergence at a given time.\n\nSynthesis and physical circuit behavior for $s = '0'$:\n1. RTL synthesis maps the process to combinational logic. The logic is equivalent to a 2-to-1 multiplexer whose select is $s$, output is $i^{+}$, data inputs are constant $0$ and $\\lnot i$, with $i$ fed back to form the $\\lnot i$ input:\n   - If $s = '1'$: the multiplexer selects constant $0$, so $i$ is driven to $0$.\n   - If $s = '0'$: the multiplexer selects $\\lnot i$, closing a combinational loop that enforces $i = \\lnot i$ through the propagation delay of the logic.\n2. In actual hardware, this combinational feedback with an odd inversion constitutes a ring oscillator. Due to real, nonzero gate and routing delays, the node $i$ will asynchronously oscillate at a frequency determined by the physical delays. Synthesis tools typically warn about a combinational loop but still produce a netlist that implements this feedback; it is not a latch or a clocked element and is not rejected solely for lacking a clock.\n\nTherefore, when $system\\_ok$ is held at '0':\n- In simulation, the model enters a zero-delay infinite delta-cycle oscillation and the simulator is likely to halt with a non-convergence or iteration-limit error.\n- In synthesized hardware, the feedback through the inverter creates a free-running asynchronous oscillator.\n\nComparing with the options, this matches option C precisely and contradicts the alternatives (no stable latch at '1', no single-time-step toggling, no T flip-flop inference, and not generally rejected as non-synthesizable).", "answer": "$$\\boxed{C}$$", "id": "1976132"}]}