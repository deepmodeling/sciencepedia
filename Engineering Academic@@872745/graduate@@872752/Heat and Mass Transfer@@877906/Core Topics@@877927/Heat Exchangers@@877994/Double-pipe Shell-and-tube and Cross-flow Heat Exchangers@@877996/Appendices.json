{"hands_on_practices": [{"introduction": "A thorough understanding of a heat exchanger's performance begins with mastering the two cornerstone analytical frameworks: the Logarithmic Mean Temperature Difference (LMTD) and the effectiveness-Number of Transfer Units (ε-NTU) methods. This practice solidifies these fundamentals by tasking you to solve for outlet temperatures using both approaches for a counterflow double-pipe exchanger. By comparing the results from the iterative LMTD method and the direct ε-NTU calculation, you will gain a deeper appreciation for their mathematical equivalence and the practical contexts in which each method is most powerful [@problem_id:2479091].", "problem": "A counterflow double-pipe heat exchanger operates at steady state with negligible axial conduction and no external heat loss. The hot stream enters at temperature $T_{h,\\mathrm{in}}$ and the cold stream enters at temperature $T_{c,\\mathrm{in}}$. The streams have constant heat capacity rates $C_{h}$ and $C_{c}$, respectively. The overall heat transfer coefficient is uniform and equal to $U$, and the total heat transfer area is $A$. The exchanger geometry is such that the local differential area $dA$ is a suitable axial coordinate.\n\nGiven the data\n- $T_{h,\\mathrm{in}} = 420\\ \\mathrm{K}$,\n- $T_{c,\\mathrm{in}} = 300\\ \\mathrm{K}$,\n- $C_{h} = 4.0 \\times 10^{3}\\ \\mathrm{W}\\,\\mathrm{K}^{-1}$,\n- $C_{c} = 2.5 \\times 10^{3}\\ \\mathrm{W}\\,\\mathrm{K}^{-1}$,\n- $U = 600\\ \\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$,\n- $A = 12\\ \\mathrm{m}^{2}$,\n\nperform the following tasks, starting only from energy conservation and the definition of the logarithmic mean:\n\n1) Using the Logarithmic Mean Temperature Difference (LMTD) method (defined via the area-averaged driving force implied by $d\\dot{Q} = U\\,(T_{h} - T_{c})\\,dA$), set up the nonlinear balance that couples the outlet temperatures through the first-law relation $\\dot{Q} = C_{h}\\,(T_{h,\\mathrm{in}} - T_{h,\\mathrm{out}}) = C_{c}\\,(T_{c,\\mathrm{out}} - T_{c,\\mathrm{in}})$ and the integrated heat transfer $\\dot{Q} = U\\,A\\,\\Delta T_{\\mathrm{lm}}$. Solve the resulting equation iteratively (do not linearize) to obtain the converged outlet temperatures $(T_{h,\\mathrm{out}}, T_{c,\\mathrm{out}})$.\n\n2) Independently, formulate the one-dimensional differential energy balances for the counterflow exchanger in terms of $A$ as the axial variable, solve them subject to the inlet boundary conditions to obtain the heat exchanger effectiveness for counterflow in terms of the Number of Transfer Units (NTU) and the heat capacity rate ratio, and from that compute $(T_{h,\\mathrm{out}}, T_{c,\\mathrm{out}})$.\n\nFinally, compare the two results and, if they agree within a relative difference of $10^{-4}$, report the common value of the hot-stream outlet temperature $T_{h,\\mathrm{out}}$. Express the final temperature in $\\mathrm{K}$ and round your answer to four significant figures.", "solution": "The problem presented is a standard exercise in the analysis of heat exchangers and is well-posed, scientifically grounded, and contains all necessary data for a unique solution. We will proceed by executing the two specified tasks and comparing the results.\n\nFirst, we address the problem using the Logarithmic Mean Temperature Difference (LMTD) method. The total rate of heat transfer, $\\dot{Q}$, is governed by two independent principles: the first law of thermodynamics (energy conservation) and the rate equation for heat transfer.\n\nFor steady-state operation with no external heat loss, the energy balance is:\n$$ \\dot{Q} = C_{h}(T_{h,\\mathrm{in}} - T_{h,\\mathrm{out}}) = C_{c}(T_{c,\\mathrm{out}} - T_{c,\\mathrm{in}}) $$\nwhere $C_{h}$ and $C_{c}$ are the heat capacity rates of the hot and cold streams, respectively, and $T$ denotes temperature with subscripts indicating the stream (h for hot, c for cold) and location (in for inlet, out for outlet).\nThe provided data are: $T_{h,\\mathrm{in}} = 420\\ \\mathrm{K}$, $T_{c,\\mathrm{in}} = 300\\ \\mathrm{K}$, $C_{h} = 4.0 \\times 10^{3}\\ \\mathrm{W}\\,\\mathrm{K}^{-1}$, and $C_{c} = 2.5 \\times 10^{3}\\ \\mathrm{W}\\,\\mathrm{K}^{-1}$.\n\nThe heat transfer rate equation is given by:\n$$ \\dot{Q} = U A \\Delta T_{\\mathrm{lm}} $$\nwhere $U = 600\\ \\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{K}^{-1}$ is the overall heat transfer coefficient and $A = 12\\ \\mathrm{m}^{2}$ is the total heat transfer area. For a counterflow exchanger, the LMTD, $\\Delta T_{\\mathrm{lm}}$, is defined as:\n$$ \\Delta T_{\\mathrm{lm}} = \\frac{\\Delta T_1 - \\Delta T_2}{\\ln(\\Delta T_1 / \\Delta T_2)} $$\nwith the temperature differences at the two ends of the exchanger being $\\Delta T_1 = T_{h,\\mathrm{in}} - T_{c,\\mathrm{out}}$ and $\\Delta T_2 = T_{h,\\mathrm{out}} - T_{c,\\mathrm{in}}$.\n\nTo find the outlet temperatures $T_{h,\\mathrm{out}}$ and $T_{c,\\mathrm{out}}$, we must solve these equations simultaneously. From the energy balance, we can express $T_{c,\\mathrm{out}}$ in terms of $T_{h,\\mathrm{out}}$:\n$$ T_{c,\\mathrm{out}} = T_{c,\\mathrm{in}} + \\frac{C_h}{C_c}(T_{h,\\mathrm{in}} - T_{h,\\mathrm{out}}) $$\nEquating the energy balance expression for $\\dot{Q}$ with the rate equation yields a single nonlinear equation for $T_{h,\\mathrm{out}}$:\n$$ C_{h}(T_{h,\\mathrm{in}} - T_{h,\\mathrm{out}}) = U A \\frac{(T_{h,\\mathrm{in}} - T_{c,\\mathrm{out}}) - (T_{h,\\mathrm{out}} - T_{c,\\mathrm{in}})}{\\ln\\left(\\frac{T_{h,\\mathrm{in}} - T_{c,\\mathrm{out}}}{T_{h,\\mathrm{out}} - T_{c,\\mathrm{in}}}\\right)} $$\nwhere $T_{c,\\mathrm{out}}$ is substituted from the previous expression. Solving this equation requires an iterative numerical method, such as the bisection method or a fixed-point iteration, on the function $f(T_{h,\\mathrm{out}})$ representing the difference between the energy balance and the heat rate equation. The iterative process is continued until the value of $T_{h,\\mathrm{out}}$ converges to a stable solution. A complete execution of such an iteration is tedious; however, its converged result must be identical to the analytical solution derived below.\n\nSecond, we formulate the problem using the effectiveness-NTU method, starting from fundamental differential energy balances. For a differential area $da$ in a counterflow arrangement, the energy balances are:\n$$ C_h \\frac{dT_h}{da} = -U(T_h - T_c) $$\n$$ C_c \\frac{dT_c}{da} = -U(T_h - T_c) $$\nThe signs are chosen based on a coordinate system where area $a$ runs from the hot fluid inlet ($a=0$) to the hot fluid outlet ($a=A$), meaning the cold fluid flows in the direction of decreasing $a$. Let $\\Delta T(a) = T_h(a) - T_c(a)$. Subtracting the differential equations yields:\n$$ \\frac{d(\\Delta T)}{da} = \\frac{dT_h}{da} - \\frac{dT_c}{da} = -U \\Delta T \\left(\\frac{1}{C_h} - \\frac{1}{C_c}\\right) $$\nIntegrating this separable first-order ODE from $a=0$ to $a=A$ gives:\n$$ \\ln\\left(\\frac{\\Delta T(A)}{\\Delta T(0)}\\right) = -UA\\left(\\frac{1}{C_h} - \\frac{1}{C_c}\\right) \\implies \\frac{T_{h,\\mathrm{out}} - T_{c,\\mathrm{in}}}{T_{h,\\mathrm{in}} - T_{c,\\mathrm{out}}} = \\exp\\left[-UA\\left(\\frac{1}{C_h} - \\frac{1}{C_c}\\right)\\right] $$\nWe define the heat capacity rate ratio $C_r = C_{\\min}/C_{\\max}$ and the Number of Transfer Units $\\mathrm{NTU} = UA/C_{\\min}$. Here, $C_c < C_h$, so $C_{\\min} = C_c = 2.5 \\times 10^{3}\\ \\mathrm{W}\\,\\mathrm{K}^{-1}$ and $C_r = C_c/C_h = 0.625$. The $\\mathrm{NTU}$ is calculated as:\n$$ \\mathrm{NTU} = \\frac{UA}{C_{\\min}} = \\frac{600 \\times 12}{2.5 \\times 10^3} = 2.88 $$\nThe exponential term becomes $\\mathrm{NTU}(1-C_r)$.\nThe effectiveness, $\\epsilon$, is defined as $\\epsilon = \\dot{Q} / \\dot{Q}_{\\max}$, where $\\dot{Q}_{\\max} = C_{\\min}(T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}})$. The outlet temperatures can be expressed in terms of $\\epsilon$:\n$$ T_{h,\\mathrm{out}} = T_{h,\\mathrm{in}} - \\epsilon \\frac{C_{\\min}}{C_h}(T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}) = T_{h,\\mathrm{in}} - \\epsilon C_r (T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}) $$\n$$ T_{c,\\mathrm{out}} = T_{c,\\mathrm{in}} + \\epsilon \\frac{C_{\\min}}{C_c}(T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}) = T_{c,\\mathrm{in}} + \\epsilon (T_{h,\\mathrm{in}} - T_{c,\\mathrm{in}}) $$\nSubstituting these into the integrated temperature difference ratio gives the expression for effectiveness for a counterflow heat exchanger:\n$$ \\frac{1 - \\epsilon C_r}{1 - \\epsilon} = \\exp[\\mathrm{NTU}(1-C_r)] \\implies \\epsilon = \\frac{1 - \\exp[-\\mathrm{NTU}(1-C_r)]}{1 - C_r \\exp[-\\mathrm{NTU}(1-C_r)]} $$\nUsing the numerical values:\n$$ \\mathrm{NTU}(1-C_r) = 2.88 \\times (1 - 0.625) = 2.88 \\times 0.375 = 1.08 $$\n$$ \\epsilon = \\frac{1 - \\exp(-1.08)}{1 - 0.625 \\exp(-1.08)} \\approx \\frac{1 - 0.339596}{1 - 0.625 \\times 0.339596} = \\frac{0.660404}{0.7877525} \\approx 0.838336 $$\nNow we compute the hot stream outlet temperature:\n$$ T_{h,\\mathrm{out}} = 420\\ \\mathrm{K} - 0.838336 \\times 0.625 \\times (420\\ \\mathrm{K} - 300\\ \\mathrm{K}) $$\n$$ T_{h,\\mathrm{out}} = 420 - 0.838336 \\times 0.625 \\times 120 = 420 - 62.8752 = 357.1248\\ \\mathrm{K} $$\nThe cold stream outlet temperature is $T_{c,\\mathrm{out}} = 300 + 0.838336 \\times 120 = 400.6003\\ \\mathrm{K}$.\n\nFinally, we compare the results. The analytical solution from the $\\epsilon$-NTU method gives $T_{h,\\mathrm{out}} = 357.1248\\ \\mathrm{K}$. The iterative LMTD method, when carried out to convergence, must yield the same result, as the two methods are mathematically equivalent representations of the same physical process. The relative difference between the results is therefore zero, which is well within the specified tolerance of $10^{-4}$.\n\nThe problem requires reporting the common value of the hot-stream outlet temperature, $T_{h,\\mathrm{out}}$, rounded to four significant figures.\n$$ T_{h,\\mathrm{out}} \\approx 357.1\\ \\mathrm{K} $$", "answer": "$$\n\\boxed{357.1}\n$$", "id": "2479091"}, {"introduction": "Moving beyond idealized plug-flow assumptions is critical for the accurate design and rating of shell-and-tube heat exchangers. This exercise guides you through developing a fluid network model to simulate the complex division of shell-side flow into its main cross-flow, window, leakage, and bypass streams [@problem_id:2479081]. By applying fundamental principles of mass and momentum conservation to this parallel network, you will learn to predict local fluid velocities and pressure drop, gaining insight into the hydraulic non-idealities that govern real-world exchanger performance.", "problem": "Consider a single baffle-to-baffle segment of the shell side of a shell-and-tube heat exchanger. The shell-side fluid is steady, incompressible, single-phase, and isothermally flowing. The flow distributes among four parallel paths: main cross-flow across the tube bank, baffle-window flow, leakage flow through clearances, and bypass flow along the bundle-shell gap. Assume negligible elevation change and no shaft work. The task is to develop and apply a network model that enforces conservation of mass and mechanical energy to predict the path-average velocities in each branch.\n\nUse the following fundamental base:\n\n- Conservation of mass (continuity) for incompressible flow: the total mass flow rate equals the sum of the mass flow rates through each parallel path. If the path-average velocity in branch $i$ is $V_i$ and the cross-sectional flow area is $A_i$, then the volumetric flow is $A_i V_i$ and the mass flow is $\\rho A_i V_i$. Thus,\n$$\n\\dot{m} \\;=\\; \\rho \\sum_{i=1}^{4} A_i V_i.\n$$\n\n- Mechanical energy balance with head losses (Darcy–Weisbach formulation with minor losses) between the inlet and outlet of the baffle-to-baffle segment for each path $i$:\n$$\n\\Delta P \\;=\\; \\frac{1}{2} \\rho V_i^2 \\left( f_i \\frac{L_i}{D_{h,i}} + K_{\\text{in},i} + K_{\\text{out},i} \\right),\n$$\nwhere $\\Delta P$ is the common pressure drop across the baffle-to-baffle segment (shared by all four parallel paths), $L_i$ is the characteristic flow length in branch $i$, $D_{h,i}$ is the hydraulic diameter in branch $i$, $K_{\\text{in},i}$ and $K_{\\text{out},i}$ are dimensionless entrance and exit minor-loss coefficients, respectively, and $f_i$ is the Darcy friction factor defined by the Reynolds-number-dependent correlations:\n$$\n\\text{Re}_i \\;=\\; \\frac{\\rho V_i D_{h,i}}{\\mu}, \\quad\nf_i \\;=\\; \\begin{cases}\n\\frac{64}{\\text{Re}_i}, & \\text{Re}_i \\le 2300, \\\\\n0.3164\\, \\text{Re}_i^{-0.25}, & \\text{Re}_i > 2300.\n\\end{cases}\n$$\nThese relations are to be applied as constitutive laws; they are not the target of derivation.\n\n- Parallel network constraint: because the four branches connect the same upstream and downstream control volumes, the pressure drop $\\Delta P$ is identical for all four paths, while the velocities $V_i$ adjust to satisfy both the individual mechanical energy balances and the overall mass conservation.\n\nYou must compute, for each test case listed below, the tuple of path-average velocities $\\left[V_{\\text{main}}, V_{\\text{window}}, V_{\\text{leak}}, V_{\\text{bypass}}\\right]$ in meters per second. The solution requires solving a coupled nonlinear system because $f_i$ depends on $V_i$ through the Reynolds number. Your program should use a robust numerical method to find $\\Delta P$ and the four velocities that satisfy the above equations simultaneously.\n\nPhysical and numerical requirements:\n\n- Treat the fluid as Newtonian, with density $\\rho$ and dynamic viscosity $\\mu$ constant over the segment.\n- Use the units exactly as specified; all geometric inputs are in meters, areas in square meters, $\\dot{m}$ in kilograms per second, and the output velocities must be expressed in meters per second and rounded to five decimal places.\n- Assume each branch $i$ has strictly positive area $A_i$, hydraulic diameter $D_{h,i}$, and length $L_i$.\n- The entrance and exit loss coefficients $K_{\\text{in},i}$ and $K_{\\text{out},i}$ are given and dimensionless.\n\nTest suite:\n\nProvide solutions for the following four test cases. Each case defines fluid properties, total mass flow rate $\\dot{m}$, and for each branch $i \\in \\{\\text{main}, \\text{window}, \\text{leak}, \\text{bypass}\\}$, the tuple $\\left(A_i, D_{h,i}, L_i, K_{\\text{in},i}, K_{\\text{out},i}\\right)$.\n\n- Case 1 (general turbulent-laminar mix, “happy path”):\n  - Fluid: $\\rho = 995$ kg/m$^3$, $\\mu = 0.0007$ Pa·s, $\\dot{m} = 10$ kg/s.\n  - Main cross-flow: $A_{\\text{main}} = 0.05$ m$^2$, $D_{h,\\text{main}} = 0.02$ m, $L_{\\text{main}} = 0.30$ m, $K_{\\text{in,main}} = 0.5$, $K_{\\text{out,main}} = 1.0$.\n  - Baffle-window: $A_{\\text{window}} = 0.02$ m$^2$, $D_{h,\\text{window}} = 0.03$ m, $L_{\\text{window}} = 0.45$ m, $K_{\\text{in,window}} = 1.0$, $K_{\\text{out,window}} = 1.5$.\n  - Leakage: $A_{\\text{leak}} = 0.002$ m$^2$, $D_{h,\\text{leak}} = 0.005$ m, $L_{\\text{leak}} = 0.30$ m, $K_{\\text{in,leak}} = 2.0$, $K_{\\text{out,leak}} = 2.0$.\n  - Bypass: $A_{\\text{bypass}} = 0.005$ m$^2$, $D_{h,\\text{bypass}} = 0.010$ m, $L_{\\text{bypass}} = 0.30$ m, $K_{\\text{in,bypass}} = 1.0$, $K_{\\text{out,bypass}} = 1.0$.\n\n- Case 2 (bypass nearly closed):\n  - Fluid: $\\rho = 995$ kg/m$^3$, $\\mu = 0.0007$ Pa·s, $\\dot{m} = 10$ kg/s.\n  - Main cross-flow: $A_{\\text{main}} = 0.05$ m$^2$, $D_{h,\\text{main}} = 0.02$ m, $L_{\\text{main}} = 0.30$ m, $K_{\\text{in,main}} = 0.5$, $K_{\\text{out,main}} = 1.0$.\n  - Baffle-window: $A_{\\text{window}} = 0.02$ m$^2$, $D_{h,\\text{window}} = 0.03$ m, $L_{\\text{window}} = 0.45$ m, $K_{\\text{in,window}} = 1.0$, $K_{\\text{out,window}} = 1.5$.\n  - Leakage: $A_{\\text{leak}} = 0.002$ m$^2$, $D_{h,\\text{leak}} = 0.005$ m, $L_{\\text{leak}} = 0.30$ m, $K_{\\text{in,leak}} = 2.0$, $K_{\\text{out,leak}} = 2.0$.\n  - Bypass: $A_{\\text{bypass}} = 0.0001$ m$^2$, $D_{h,\\text{bypass}} = 0.004$ m, $L_{\\text{bypass}} = 0.30$ m, $K_{\\text{in,bypass}} = 5.0$, $K_{\\text{out,bypass}} = 5.0$.\n\n- Case 3 (viscous, predominantly laminar):\n  - Fluid: $\\rho = 900$ kg/m$^3$, $\\mu = 0.2$ Pa·s, $\\dot{m} = 1.0$ kg/s.\n  - Main cross-flow: $A_{\\text{main}} = 0.08$ m$^2$, $D_{h,\\text{main}} = 0.015$ m, $L_{\\text{main}} = 0.25$ m, $K_{\\text{in,main}} = 0.5$, $K_{\\text{out,main}} = 1.0$.\n  - Baffle-window: $A_{\\text{window}} = 0.03$ m$^2$, $D_{h,\\text{window}} = 0.02$ m, $L_{\\text{window}} = 0.35$ m, $K_{\\text{in,window}} = 1.0$, $K_{\\text{out,window}} = 1.5$.\n  - Leakage: $A_{\\text{leak}} = 0.003$ m$^2$, $D_{h,\\text{leak}} = 0.004$ m, $L_{\\text{leak}} = 0.25$ m, $K_{\\text{in,leak}} = 2.0$, $K_{\\text{out,leak}} = 2.0$.\n  - Bypass: $A_{\\text{bypass}} = 0.006$ m$^2$, $D_{h,\\text{bypass}} = 0.008$ m, $L_{\\text{bypass}} = 0.25$ m, $K_{\\text{in,bypass}} = 1.0$, $K_{\\text{out,bypass}} = 1.0$.\n\n- Case 4 (higher flow leading to turbulence):\n  - Fluid: $\\rho = 998$ kg/m$^3$, $\\mu = 0.001$ Pa·s, $\\dot{m} = 40$ kg/s.\n  - Main cross-flow: $A_{\\text{main}} = 0.05$ m$^2$, $D_{h,\\text{main}} = 0.02$ m, $L_{\\text{main}} = 0.30$ m, $K_{\\text{in,main}} = 0.5$, $K_{\\text{out,main}} = 1.0$.\n  - Baffle-window: $A_{\\text{window}} = 0.02$ m$^2$, $D_{h,\\text{window}} = 0.03$ m, $L_{\\text{window}} = 0.45$ m, $K_{\\text{in,window}} = 1.0$, $K_{\\text{out,window}} = 1.5$.\n  - Leakage: $A_{\\text{leak}} = 0.002$ m$^2$, $D_{h,\\text{leak}} = 0.005$ m, $L_{\\text{leak}} = 0.30$ m, $K_{\\text{in,leak}} = 2.0$, $K_{\\text{out,leak}} = 2.0$.\n  - Bypass: $A_{\\text{bypass}} = 0.005$ m$^2$, $D_{h,\\text{bypass}} = 0.010$ m, $L_{\\text{bypass}} = 0.30$ m, $K_{\\text{in,bypass}} = 1.0$, $K_{\\text{out,bypass}} = 1.0$.\n\nRequired final output format:\n\n- For each test case, compute the ordered list $\\left[V_{\\text{main}}, V_{\\text{window}}, V_{\\text{leak}}, V_{\\text{bypass}}\\right]$, each entry expressed in meters per second and rounded to five decimal places.\n- Aggregate the results for all four test cases into a single line printed by your program, formatted as a comma-separated list enclosed in square brackets, where each element is itself a list of the four rounded velocities. For example, the output should look like: \n\"[[v11,v12,v13,v14],[v21,v22,v23,v24],[v31,v32,v33,v34],[v41,v42,v43,v44]]\"\nwith no spaces and with each $v_{jk}$ rounded to five decimal places in units of m/s.", "solution": "The problem as stated is subjected to validation against fundamental principles of science and engineering.\n\n**Step 1: Extracted Givens**\n\n- **Governing Physical Model**: The flow on the shell side of a heat exchanger is modeled as four parallel paths connecting a common inlet and outlet.\n- **Fluid Properties**: The fluid is steady, incompressible, single-phase, and isothermal, with constant density $\\rho$ and dynamic viscosity $\\mu$.\n- **Conservation of Mass**: The total mass flow rate $\\dot{m}$ is the sum of the flow rates in the four paths: $\\dot{m} = \\rho \\sum_{i=1}^{4} A_i V_i$.\n- **Mechanical Energy Balance**: The pressure drop $\\Delta P$ is common to all paths and is related to the path-average velocity $V_i$ by the Darcy-Weisbach equation including minor losses:\n$$\n\\Delta P = \\frac{1}{2} \\rho V_i^2 \\left( f_i \\frac{L_i}{D_{h,i}} + K_{\\text{in},i} + K_{\\text{out},i} \\right)\n$$\n- **Constitutive Law for Friction Factor**: The Darcy friction factor $f_i$ is a function of the Reynolds number $\\text{Re}_i = \\rho V_i D_{h,i} / \\mu$:\n$$\nf_i = \\begin{cases}\n\\frac{64}{\\text{Re}_i}, & \\text{for } \\text{Re}_i \\le 2300 \\\\\n0.3164\\, \\text{Re}_i^{-0.25}, & \\text{for } \\text{Re}_i > 2300\n\\end{cases}\n$$\n- **Parameters**: For four test cases, numerical values are provided for $\\rho, \\mu, \\dot{m}$, and for each of the four paths, the geometric and loss parameters $(A_i, D_{h,i}, L_i, K_{\\text{in},i}, K_{\\text{out},i})$.\n- **Objective**: Compute the four path-average velocities $[V_{\\text{main}}, V_{\\text{window}}, V_{\\text{leak}}, V_{\\text{bypass}}]$ for each test case.\n\n**Step 2: Validation of Givens**\n\nThe problem is reviewed for validity:\n- **Scientific Grounding**: The problem is based on foundational principles of fluid mechanics—conservation of mass and the mechanical energy equation. The use of the Darcy-Weisbach equation with standard correlations for the friction factor is a correct and established engineering practice for analyzing flow in conduits. The parallel network model is a standard simplification for shell-side flow analysis.\n- **Well-Posedness**: The problem specifies a system of five unknowns: the four velocities $V_i$ and the pressure drop $\\Delta P$. It provides five independent equations: four instances of the mechanical energy balance and one mass conservation equation. For a positive mass flow rate $\\dot{m}$, the system can be shown to have a unique, positive solution for $(\\Delta P, V_1, V_2, V_3, V_4)$, as the total flow rate is a monotonically increasing function of the pressure drop.\n- **Objectivity and Completeness**: The problem is stated using precise, objective, and unambiguous terminology. All data required for a solution are provided. The provided physical parameters and geometric dimensions are within realistic ranges for engineering applications.\n\n**Step 3: Verdict and Action**\n\nThe problem is determined to be **valid**. It is a well-posed, scientifically sound problem in engineering fluid mechanics. A solution will be provided.\n\n**Principle-Based Solution**\n\nThe problem requires solving a system of five coupled, nonlinear algebraic equations for five variables: the pressure drop $\\Delta P$ and the four path velocities $V_i$ for $i \\in \\{1, 2, 3, 4\\}$.\n\nThe governing equations are:\n1.  Mechanical energy balance for each path $i$:\n    $$ \\Delta P = \\frac{1}{2} \\rho V_i^2 \\left( f_i(V_i) \\frac{L_i}{D_{h,i}} + K_{\\Sigma,i} \\right) $$\n    where $K_{\\Sigma,i} = K_{\\text{in},i} + K_{\\text{out},i}$ is the sum of minor loss coefficients for path $i$, and the friction factor $f_i$ is a function of $V_i$ through the Reynolds number.\n2.  Continuity equation for the parallel network:\n    $$ \\dot{m} = \\rho \\sum_{i=1}^4 A_i V_i $$\n\nThis system is nonlinear because the friction factor $f_i$ depends on the velocity $V_i$. A direct analytical solution is not feasible. A robust numerical approach is required. The chosen method is an iterative, nested root-finding procedure, which leverages the physical structure of the problem.\n\nThe overall strategy is to treat the common pressure drop $\\Delta P$ as the independent variable that drives the flow distribution. The total mass flow rate $\\dot{m}$ can be expressed as a function of $\\Delta P$. The problem is then reduced to finding the value of $\\Delta P$ for which the calculated mass flow rate matches the given mass flow rate $\\dot{m}_{\\text{target}}$.\n\n**Numerical Algorithm:**\n\n1.  **Outer Loop: Solve for Pressure Drop $\\Delta P$**.\n    We define a residual function for the total mass flow rate:\n    $$ R(\\Delta P) = \\dot{m}_{\\text{calc}}(\\Delta P) - \\dot{m}_{\\text{target}} = \\left( \\rho \\sum_{i=1}^4 A_i V_i(\\Delta P) \\right) - \\dot{m}_{\\text{target}} $$\n    Here, $V_i(\\Delta P)$ represents the velocity in path $i$ that corresponds to a pressure drop $\\Delta P$. The function $\\dot{m}_{\\text{calc}}(\\Delta P)$ is monotonically increasing for $\\Delta P > 0$. We can therefore employ a bracketing root-finding algorithm, such as Brent's method, to efficiently find the unique positive root $\\Delta P^*$ for which $R(\\Delta P^*) = 0$.\n\n2.  **Inner Loop: Solve for Path Velocity $V_i$**.\n    For any given value of $\\Delta P$ from the outer loop, we must determine the corresponding velocity $V_i$ for each path. This requires solving the mechanical energy balance for $V_i$:\n    $$ \\frac{1}{2} \\rho V_i^2 \\left( f_i(V_i) \\frac{L_i}{D_{h,i}} + K_{\\Sigma,i} \\right) - \\Delta P = 0 $$\n    This is a nonlinear equation for $V_i$. We define a residual for each path:\n    $$ F_i(V_i; \\Delta P) = \\frac{1}{2} \\rho V_i^2 \\left( f_i(V_i) \\frac{L_i}{D_{h,i}} + K_{\\Sigma,i} \\right) - \\Delta P $$\n    For a fixed $\\Delta P > 0$, the function $F_i(V_i)$ is monotonically increasing for $V_i > 0$. We can again use a bracketing root-finder to find the unique positive velocity $V_i$ that satisfies $F_i(V_i; \\Delta P) = 0$. This process is repeated for each of the four paths.\n\n3.  **Implementation Details**:\n    - The calculation is structured as a nested call to numerical solvers. The outer solver for $\\Delta P$ calls an inner solver for each $V_i$ as part of its residual evaluation.\n    - The friction factor $f_i$ is computed within the inner loop's residual function, based on the current trial velocity $V_i$. Care must be taken at the limit $V_i \\to 0$ ($\\text{Re}_i \\to 0$); in this limit, the viscous pressure drop dominates and the total calculated pressure drop correctly tends to zero.\n    - The `scipy.optimize.root_scalar` function with `method='brentq'` is suitable for both the inner and outer loops, given its robustness for monotonic functions. Brackets for the roots are established based on physical reasoning. For $\\Delta P$, the lower bound is near zero and the upper bound is found by iteratively increasing a guess until the residual `R(ΔP)` becomes positive. For each $V_i$, the lower bound is near zero and the upper bound is found similarly.\n\nOnce the correct pressure drop $\\Delta P^*$ is determined by the outer loop, the final velocities are calculated one last time by solving the inner loop problem for each path with this $\\Delta P^*$. The resulting four velocities constitute the solution for a given test case. This procedure is applied to all four test cases.", "answer": "```python\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n#   name: scipy\n#   version: 1.11.4\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves for path-average velocities in a shell-and-tube heat exchanger model.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"fluid\": (995, 0.0007, 10),  # (rho, mu, m_dot)\n            \"paths\": {\n                \"main\":   (0.05, 0.02, 0.30, 0.5, 1.0), # (A, Dh, L, Kin, Kout)\n                \"window\": (0.02, 0.03, 0.45, 1.0, 1.5),\n                \"leak\":   (0.002, 0.005, 0.30, 2.0, 2.0),\n                \"bypass\": (0.005, 0.010, 0.30, 1.0, 1.0),\n            },\n        },\n        {\n            \"fluid\": (995, 0.0007, 10),\n            \"paths\": {\n                \"main\":   (0.05, 0.02, 0.30, 0.5, 1.0),\n                \"window\": (0.02, 0.03, 0.45, 1.0, 1.5),\n                \"leak\":   (0.002, 0.005, 0.30, 2.0, 2.0),\n                \"bypass\": (0.0001, 0.004, 0.30, 5.0, 5.0),\n            },\n        },\n        {\n            \"fluid\": (900, 0.2, 1.0),\n            \"paths\": {\n                \"main\":   (0.08, 0.015, 0.25, 0.5, 1.0),\n                \"window\": (0.03, 0.02, 0.35, 1.0, 1.5),\n                \"leak\":   (0.003, 0.004, 0.25, 2.0, 2.0),\n                \"bypass\": (0.006, 0.008, 0.25, 1.0, 1.0),\n            },\n        },\n        {\n            \"fluid\": (998, 0.001, 40),\n            \"paths\": {\n                \"main\":   (0.05, 0.02, 0.30, 0.5, 1.0),\n                \"window\": (0.02, 0.03, 0.45, 1.0, 1.5),\n                \"leak\":   (0.002, 0.005, 0.30, 2.0, 2.0),\n                \"bypass\": (0.005, 0.010, 0.30, 1.0, 1.0),\n            },\n        },\n    ]\n\n    def get_friction_factor(reynolds_number):\n        \"\"\"Calculates the Darcy friction factor.\"\"\"\n        if reynolds_number <= 2300:\n            # For Re -> 0, f -> inf. The caller must handle V -> 0 limit.\n            if reynolds_number < 1e-9: return np.inf\n            return 64.0 / reynolds_number\n        else:\n            return 0.3164 * reynolds_number**(-0.25)\n\n    def find_velocity_for_path(delta_P, rho, mu, A, Dh, L, Kin, Kout):\n        \"\"\"\n        Inner loop: For a given pressure drop, finds the velocity in a single path.\n        \"\"\"\n        if delta_P <= 0:\n            return 0.0\n\n        def velocity_residual(V):\n            \"\"\"Residual for the mechanical energy equation for a single path.\"\"\"\n            if V < 1e-9:\n                return -delta_P\n            \n            Re = rho * V * Dh / mu\n            f = get_friction_factor(Re)\n            K_total = f * L / Dh + Kin + Kout\n            \n            calculated_delta_P = 0.5 * rho * V**2 * K_total\n            return calculated_delta_P - delta_P\n\n        try:\n            # Heuristic for bracket. Lower bound is near zero.\n            v_low = 1e-9\n            # Upper bound must yield a positive residual.\n            v_high_guess = np.sqrt(2 * delta_P / (rho * (Kin + Kout))) if (Kin + Kout) > 0 else np.sqrt(2 * delta_P/rho)\n            v_high = max(0.1, v_high_guess * 2)\n\n            # Iteratively increase upper bound until it brackets the root\n            max_iter = 10\n            for _ in range(max_iter):\n                if velocity_residual(v_high) > 0:\n                    break\n                v_high *= 5.0\n            else:\n                 raise RuntimeError(\"Could not find upper bracket for velocity.\")\n\n            sol = root_scalar(velocity_residual, bracket=[v_low, v_high], method='brentq')\n            return sol.root\n        except Exception:\n            return 0.0\n\n    def solve_case(case_data):\n        \"\"\"\n        Outer loop: Solves for velocities for a full test case.\n        \"\"\"\n        rho, mu, m_dot_target = case_data[\"fluid\"]\n        path_list = list(case_data[\"paths\"].values())\n\n        def m_dot_residual(delta_P):\n            \"\"\"Residual for the total mass flow rate.\"\"\"\n            if delta_P <= 0:\n                return -m_dot_target\n            \n            m_dot_calculated = 0.0\n            for path_params in path_list:\n                A, Dh, L, Kin, Kout = path_params\n                V = find_velocity_for_path(delta_P, rho, mu, A, Dh, L, Kin, Kout)\n                m_dot_calculated += rho * A * V\n            \n            return m_dot_calculated - m_dot_target\n\n        # Find bracket for delta_P root.\n        dp_low = 1e-3\n        dp_high = 100.0  # Initial guess in Pascals\n\n        max_iter = 15\n        for _ in range(max_iter):\n            if m_dot_residual(dp_high) > 0:\n                break\n            dp_high *= 10.0\n        else:\n            raise RuntimeError(\"Could not find upper bracket for delta_P.\")\n\n        sol = root_scalar(m_dot_residual, bracket=[dp_low, dp_high], method='brentq')\n        final_delta_P = sol.root\n\n        # Calculate final velocities with the correct pressure drop\n        velocities = []\n        for path_params in path_list:\n            A, Dh, L, Kin, Kout = path_params\n            V = find_velocity_for_path(final_delta_P, rho, mu, A, Dh, L, Kin, Kout)\n            velocities.append(V)\n\n        return velocities\n\n    all_results = []\n    for case in test_cases:\n        velocities = solve_case(case)\n        rounded_velocities = [round(v, 5) for v in velocities]\n        all_results.append(rounded_velocities)\n    \n    # Format output string\n    case_strings = [f\"[{','.join(f'{v:.5f}' for v in vel_list)}]\" for vel_list in all_results]\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2479081"}, {"introduction": "Fouling is an inevitable reality in heat exchanger operation, leading to performance degradation and increased costs. This advanced practice elevates the analysis from pure thermal-hydraulics to the domain of economic optimization by framing fouling management as a dynamic programming problem [@problem_id:2479067]. You will develop an algorithm to determine an optimal cleaning schedule that minimizes total operational costs, balancing the energy penalty of reduced thermal conductance against the expense of cleaning interventions. This exercise builds crucial skills in integrating engineering principles with economic decision-making for long-term asset management.", "problem": "You are given a discrete-time planning problem for fouling management in heat exchangers that can be used for double-pipe, shell-and-tube, and cross-flow configurations. Over a finite horizon of $T$ time periods, you must decide in which periods to perform chemical cleaning so as to minimize the sum of the energy penalty (due to reduced thermal conductance as fouling accumulates) and the cleaning costs.\n\nBase the formulation on the following well-tested definitions and laws:\n- The steady heat duty relation $\\dot{Q} = U A \\, F \\, \\Delta T_{\\mathrm{lm}}$, where $\\dot{Q}$ is the heat duty, $U$ is the overall heat transfer coefficient, $A$ is the heat transfer area, $F$ is the temperature correction factor for configuration and flow arrangement, and $\\Delta T_{\\mathrm{lm}}$ is the log-mean temperature difference (LMTD).\n- The resistance-in-series model of overall heat transfer coefficient for a fouling exchanger, $U(t) = \\dfrac{1}{R_{\\mathrm{clean}} + R_f(t)}$, where $R_{\\mathrm{clean}}$ is the clean-side lumped resistance per unit area and $R_f(t)$ is the fouling thermal resistance per unit area. Assume $A$ is constant and known.\n\nAssume the following discrete-time process and decision structure:\n- Time is indexed by $k \\in \\{1,2,\\dots,T\\}$ with uniform time step $\\Delta t$.\n- Define the discrete age state $a_k \\in \\{0,1,\\dots,T\\}$ as the number of time steps since the last cleaning at the start of period $k$. The fouling resistance evolves as $R_f(k) = a_k \\, \\Delta R$, where $\\Delta R > 0$ is the fouling growth per time step.\n- The conductance in period $k$ as a function of age is $UA_k(a_k) = \\dfrac{A}{R_{\\mathrm{clean}} + a_k \\, \\Delta R}$.\n- Let the required conductance threshold be $UA_{\\min} = \\dfrac{\\dot{Q}}{F \\, \\Delta T_{\\mathrm{target}}}$, where $\\Delta T_{\\mathrm{target}}$ is a specified target log-mean temperature difference. When $UA_k(a_k) < UA_{\\min}$, an energy penalty is incurred to maintain performance with utilities. Model the energy penalty rate as $c_e$ dollars per $(\\mathrm{W/K})$ per period, so that the period-$k$ penalty is $p_k(a_k) = c_e \\, \\max\\{0, UA_{\\min} - UA_k(a_k)\\}$.\n- The decision in each period is binary: to clean at the beginning of the period ($x_k = 1$) or not ($x_k = 0$). Cleaning costs $C_c$ dollars, is instantaneous at the start of period $k$, and resets the age to $a_k = 0$ for that period. The state transition is $a_{k+1} = 1$ if $x_k = 1$, and $a_{k+1} = \\min\\{a_k + 1, T\\}$ if $x_k = 0$. The period-$k$ penalty is evaluated with the post-decision age for that period: if $x_k = 1$, use $a_k = 0$ in $UA_k$; if $x_k = 0$, use $a_k$ as given.\n\nYour task:\n1) Formulate the optimization problem to minimize the total cost\n$$\nJ = \\sum_{k=1}^{T} \\big( p_k(a_k^{\\mathrm{use}}) + C_c \\, x_k \\big),\n$$\nwhere $a_k^{\\mathrm{use}}$ is the age used to evaluate $p_k$ in period $k$ (that is, $a_k^{\\mathrm{use}} = 0$ if $x_k = 1$, and $a_k^{\\mathrm{use}} = a_k$ if $x_k = 0$), subject to the stated dynamics and $a_1 = 0$.\n2) Implement a dynamic programming algorithm that computes the optimal cleaning schedule $\\{x_k\\}_{k=1}^{T}$ and the corresponding minimal total cost for each of the test cases below.\n\nPhysical units and output requirements:\n- Use $U_c$ in $\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$, $A$ in $\\mathrm{m}^2$, $R_{\\mathrm{clean}} = 1/U_c$ in $\\mathrm{m}^2\\cdot\\mathrm{K}/\\mathrm{W}$, $\\Delta R$ in $\\mathrm{m}^2\\cdot\\mathrm{K}/\\mathrm{W}$ per period, $\\dot{Q}$ in $\\mathrm{W}$, and $UA$ in $\\mathrm{W}/\\mathrm{K}$. The penalty rate $c_e$ is in dollars per $(\\mathrm{W}/\\mathrm{K})$ per period, and $C_c$ is in dollars per cleaning. Express the final total cost in dollars rounded to two decimals. Time indices in the schedule must be integers.\n\nTest suite:\n- Case $1$ (double-pipe counterflow):\n  - $T = 12$, $\\Delta t = 1$, $A = 50$, $U_c = 1000$, $\\Delta R = 1\\times 10^{-5}$, $\\dot{Q} = 8.0\\times 10^{5}$, $\\Delta T_{\\mathrm{target}} = 20$, $F = 1.0$, $c_e = 0.5$, $C_c = 1000$.\n- Case $2$ (one-shell-pass, two-tube-pass shell-and-tube):\n  - $T = 12$, $\\Delta t = 1$, $A = 50$, $U_c = 1000$, $\\Delta R = 1\\times 10^{-5}$, $\\dot{Q} = 8.8\\times 10^{5}$, $\\Delta T_{\\mathrm{target}} = 20$, $F = 0.9$, $c_e = 0.5$, $C_c = 2000$.\n- Case $3$ (cross-flow, both fluids unmixed):\n  - $T = 12$, $\\Delta t = 1$, $A = 50$, $U_c = 1000$, $\\Delta R = 5\\times 10^{-5}$, $\\dot{Q} = 8.4\\times 10^{5}$, $\\Delta T_{\\mathrm{target}} = 20$, $F = 0.85$, $c_e = 2.0$, $C_c = 1500$.\n- Case $4$ (double-pipe parallel flow, infeasible target at clean condition):\n  - $T = 12$, $\\Delta t = 1$, $A = 50$, $U_c = 1000$, $\\Delta R = 1\\times 10^{-5}$, $\\dot{Q} = 1.2\\times 10^{6}$, $\\Delta T_{\\mathrm{target}} = 20$, $F = 1.0$, $c_e = 0.01$, $C_c = 2000$.\n\nFinal output format:\n- For each test case, your program must compute the optimal cleaning times as period indices in ascending order and the minimal total cost. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of the form $[\\text{total\\_cost}, \\text{n\\_clean}, t_1, t_2, \\dots]$, with $\\text{total\\_cost}$ in dollars rounded to two decimals and $t_i$ integers. For example: $[[1234.50,2,4,8],[0.00,0]]$.", "solution": "The given problem is a well-posed, finite-horizon, discrete-time optimal control problem. It is scientifically grounded in established principles of heat transfer and process engineering. The objective is to determine a control policy—a schedule of cleaning actions—that minimizes a total cost function comprising energy penalties and cleaning expenditures over a time horizon of $T$ periods. The problem structure is a classic application of dynamic programming.\n\nThe problem is formalized as follows.\n\nLet the state of the system at the beginning of each time period $k \\in \\{1, 2, \\dots, T\\}$ be the age of the heat exchanger, denoted by $a_k$. The age is defined as the number of time periods elapsed since the last cleaning. The state space for period $k$ is $a_k \\in \\{0, 1, \\dots, k-1\\}$, with the initial condition given as $a_1 = 0$.\n\nThe decision variable at each period $k$ is binary, $x_k \\in \\{0, 1\\}$, where $x_k = 1$ signifies a decision to clean the exchanger at the beginning of period $k$, and $x_k = 0$ signifies a decision not to clean.\n\nThe cost incurred in period $k$ is a function of the state $a_k$ and the decision $x_k$. Let $a_k^{\\mathrm{use}}$ be the effective age for period $k$ after the decision $x_k$ is made. If no cleaning occurs ($x_k = 0$), the age for the period is unchanged, $a_k^{\\mathrm{use}} = a_k$. If cleaning occurs ($x_k = 1$), the age is reset to zero, $a_k^{\\mathrm{use}} = 0$. The overall thermal conductance in period $k$ is a function of this effective age:\n$$\nUA_k(a_k^{\\mathrm{use}}) = \\frac{A}{R_{\\mathrm{clean}} + a_k^{\\mathrm{use}} \\cdot \\Delta R}\n$$\nwhere $A$ is the heat transfer area, $R_{\\mathrm{clean}}$ is the clean-side thermal resistance per unit area, and $\\Delta R$ is the fouling resistance growth per time step.\n\nAn energy penalty is incurred if the conductance falls below a required threshold, $UA_{\\min}$. The penalty in period $k$, $p_k$, is given by:\n$$\np_k(a_k^{\\mathrm{use}}) = c_e \\cdot \\max\\{0, UA_{\\min} - UA_k(a_k^{\\mathrm{use}})\\}\n$$\nwhere $c_e$ is the energy penalty rate. The total cost contribution in period $k$ is the sum of the cleaning cost and the energy penalty:\n$$\nC_k(a_k, x_k) = C_c \\cdot x_k + p_k(a_k^{\\mathrm{use}})\n$$\nwhere $C_c$ is the cost of a single cleaning action. Note that $a_k^{\\mathrm{use}}$ is itself a function of $a_k$ and $x_k$, specifically $a_k^{\\mathrm{use}} = a_k(1-x_k)$.\n\nThe state transitions are governed by the decision $x_k$. If a cleaning is performed at period $k$ ($x_k=1$), the age at the start of the next period, $a_{k+1}$, is $1$. If no cleaning is performed ($x_k=0$), the age increments by one, so $a_{k+1} = a_k + 1$. These can be combined into a single equation:\n$$\na_{k+1} = (a_k + 1)(1-x_k) + 1 \\cdot x_k\n$$\n\nThe objective is to find a sequence of decisions $\\{x_1^*, x_2^*, \\dots, x_T^*\\}$ that minimizes the total cost over the horizon:\n$$\nJ = \\sum_{k=1}^{T} C_k(a_k, x_k) = \\sum_{k=1}^{T} \\left( C_c \\cdot x_k + p_k(a_k(1-x_k)) \\right)\n$$\nsubject to the state transition dynamics and the initial condition $a_1=0$.\n\nThis problem satisfies the principle of optimality and is solved using backward dynamic programming. Let $J_k(a_k)$ be the optimal cost-to-go from the beginning of period $k$ to the end of the horizon $T$, given that the state is $a_k$. We establish a recursive relationship for $J_k(a_k)$.\n\nThe Bellman equation for this problem is:\n$$\nJ_k(a_k) = \\min_{x_k \\in \\{0, 1\\}} \\left\\{ C_k(a_k, x_k) + J_{k+1}(a_{k+1}) \\right\\}\n$$\nfor $k = T, T-1, \\dots, 1$.\n\nExpanding this for the two possible decisions:\n1.  Decision $x_k = 0$ (Do not clean): The cost is $p_k(a_k)$ and the next state is $a_{k+1} = a_k + 1$. The total future cost is $p_k(a_k) + J_{k+1}(a_k+1)$.\n2.  Decision $x_k = 1$ (Clean): The cost is $C_c + p_k(0)$ and the next state is $a_{k+1} = 1$. The total future cost is $C_c + p_k(0) + J_{k+1}(1)$.\n\nThus, the Bellman equation takes the concrete form:\n$$\nJ_k(a_k) = \\min \\begin{cases} p_k(a_k) + J_{k+1}(a_k+1) & (\\text{if } x_k = 0) \\\\ C_c + p_k(0) + J_{k+1}(1) & (\\text{if } x_k = 1) \\end{cases}\n$$\nThe boundary condition is defined at the end of the horizon. The cost beyond period $T$ is zero, so $J_{T+1}(a) = 0$ for any state $a$.\nThis leads to the terminal cost calculation at $k=T$:\n$$\nJ_T(a_T) = \\min \\{ p_T(a_T), C_c + p_T(0) \\}\n$$\n\nThe computational algorithm proceeds as follows:\n1.  For a given test case, calculate the constant parameters: $R_{\\mathrm{clean}} = 1/U_c$ and $UA_{\\min} = \\dot{Q} / (F \\cdot \\Delta T_{\\mathrm{target}})$. Pre-compute a table of penalty values $p(a)$ for all possible ages $a \\in \\{0, 1, \\dots, T-1\\}$.\n2.  Initialize a cost-to-go table $J[k][a]$ and a policy table $\\Pi[k][a]$ for $k \\in \\{1, \\dots, T\\}$ and $a \\in \\{0, \\dots, T-1\\}$. Set $J[T+1][a] = 0$ for all $a$.\n3.  Solve backwards in time from $k=T$ down to $k=1$. For each stage $k$ and each possible state $a_k \\in \\{0, \\dots, k-1\\}$, calculate $J_k(a_k)$ using the Bellman equation. Store the result in $J[k][a_k]$ and the corresponding optimal decision $x_k^*(a_k)$ in $\\Pi[k][a_k]$.\n4.  After the backward pass is complete, the total minimum cost is given by $J_1(a_1=0)$, which is stored in $J[1][0]$.\n5.  Reconstruct the optimal cleaning schedule by performing a forward pass from $k=1$ to $T$. Start with the initial state $a_1=0$. For each period $k$, retrieve the optimal decision $x_k = \\Pi[k][a_k]$. If $x_k=1$, record $k$ as a cleaning period and update the state for the next period to $a_{k+1}=1$. Otherwise, update the state to $a_{k+1}=a_k+1$.\n\nThis procedure guarantees the globally optimal solution for the given deterministic problem. The provided Python code implements this algorithm to solve for each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the fouling management problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (double-pipe counterflow)\n        {\"T\": 12, \"A\": 50, \"Uc\": 1000, \"delta_R\": 1e-5, \"Q_dot\": 8.0e5, \n         \"delta_T_target\": 20, \"F\": 1.0, \"c_e\": 0.5, \"Cc\": 1000},\n        # Case 2 (one-shell-pass, two-tube-pass shell-and-tube)\n        {\"T\": 12, \"A\": 50, \"Uc\": 1000, \"delta_R\": 1e-5, \"Q_dot\": 8.8e5,\n         \"delta_T_target\": 20, \"F\": 0.9, \"c_e\": 0.5, \"Cc\": 2000},\n        # Case 3 (cross-flow, both fluids unmixed)\n        {\"T\": 12, \"A\": 50, \"Uc\": 1000, \"delta_R\": 5e-5, \"Q_dot\": 8.4e5,\n         \"delta_T_target\": 20, \"F\": 0.85, \"c_e\": 2.0, \"Cc\": 1500},\n        # Case 4 (double-pipe parallel flow, infeasible target at clean condition)\n        {\"T\": 12, \"A\": 50, \"Uc\": 1000, \"delta_R\": 1e-5, \"Q_dot\": 1.2e6,\n         \"delta_T_target\": 20, \"F\": 1.0, \"c_e\": 0.01, \"Cc\": 2000},\n    ]\n\n    results_str = []\n    for case_params in test_cases:\n        total_cost, cleaning_schedule = dp_solver(case_params)\n        \n        # Format the output for one case as a string\n        cost_str = f\"{total_cost:.2f}\"\n        n_clean = len(cleaning_schedule)\n        \n        res_list = [cost_str, str(n_clean)]\n        if n_clean > 0:\n            res_list.extend(map(str, cleaning_schedule))\n        \n        inner_str = f\"[{','.join(res_list)}]\"\n        results_str.append(inner_str)\n\n    print(f\"[{','.join(results_str)}]\")\n\n\ndef dp_solver(params):\n    \"\"\"\n    Solves the optimal cleaning schedule problem using dynamic programming.\n    \n    Args:\n        params (dict): A dictionary of problem parameters.\n        \n    Returns:\n        tuple: (total_optimal_cost, optimal_cleaning_schedule)\n    \"\"\"\n    T = params[\"T\"]\n    A = params[\"A\"]\n    Uc = params[\"Uc\"]\n    delta_R = params[\"delta_R\"]\n    Q_dot = params[\"Q_dot\"]\n    delta_T_target = params[\"delta_T_target\"]\n    F = params[\"F\"]\n    c_e = params[\"c_e\"]\n    Cc = params[\"Cc\"]\n\n    R_clean = 1.0 / Uc\n    UA_min = Q_dot / (F * delta_T_target)\n\n    # Pre-calculate penalty_costs for all possible ages\n    # Max age is T-1\n    penalty_costs = np.zeros(T)\n    for age in range(T):\n        UA_fouled = A / (R_clean + age * delta_R)\n        penalty = c_e * max(0, UA_min - UA_fouled)\n        penalty_costs[age] = penalty\n\n    # DP tables\n    # J[k][a] = cost-to-go from period k+1 with age a\n    # policy[k][a] = decision (0 or 1) at period k+1 with age a\n    J = np.zeros((T + 1, T + 1))\n    policy = np.zeros((T, T), dtype=int)\n\n    # Backward recursion\n    # k is the 0-based time index, from T-1 down to 0\n    for k in range(T - 1, -1, -1):\n        # Age 'a' can be from 0 to k\n        for a in range(k + 1):\n            # Cost if not cleaning (x_k = 0)\n            cost_no_clean = penalty_costs[a] + J[k + 1][a + 1]\n\n            # Cost if cleaning (x_k = 1)\n            cost_clean = Cc + penalty_costs[0] + J[k + 1][1]\n            \n            if cost_no_clean <= cost_clean:\n                J[k][a] = cost_no_clean\n                policy[k][a] = 0\n            else:\n                J[k][a] = cost_clean\n                policy[k][a] = 1\n\n    # Total minimum cost, starting with age 0 at period 1 (index 0)\n    total_min_cost = J[0][0]\n\n    # Forward pass to reconstruct the optimal schedule\n    optimal_schedule = []\n    current_age = 0\n    for k in range(T):\n        decision = policy[k][current_age]\n        if decision == 1:  # Clean\n            optimal_schedule.append(k + 1)\n            current_age = 1\n        else:  # Do not clean\n            current_age += 1\n            \n    return total_min_cost, optimal_schedule\n\nsolve()\n\n```", "id": "2479067"}]}