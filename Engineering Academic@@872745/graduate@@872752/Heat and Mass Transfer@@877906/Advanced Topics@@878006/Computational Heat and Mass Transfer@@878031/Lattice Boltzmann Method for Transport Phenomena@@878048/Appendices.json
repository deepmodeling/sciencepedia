{"hands_on_practices": [{"introduction": "A successful simulation begins not with code, but with careful planning. The first crucial step in applying the Lattice Boltzmann Method is to correctly map the physical problem, with its real-world units, into the dimensionless world of the lattice. This exercise ([@problem_id:2500937]) guides you through this fundamental process, ensuring that key dimensionless parameters like the Reynolds number ($\\mathrm{Re}$) and Péclet number ($\\mathrm{Pe}$) are preserved. Mastering this translation is essential for your simulation to accurately reflect the physical phenomena you wish to study.", "problem": "A two-dimensional heated channel of length $L$ and height $H$ carries a passive scalar with advection by a steady flow of characteristic speed $U$. The fluid has kinematic viscosity $\\nu$ and thermal diffusivity $\\alpha$. You will set up a lattice Boltzmann method (LBM) simulation using a single-relaxation-time Bhatnagar–Gross–Krook (BGK) model and a two-dimensional nine-velocity (D2Q9) lattice for both the momentum and scalar transport. The lattice discrete sound speed satisfies $c_{s}^{2} = 1/3$. The Reynolds number ($\\mathrm{Re}$) and Péclet number ($\\mathrm{Pe}$) are defined by $\\mathrm{Re} = UL/\\nu$ and $\\mathrm{Pe} = UL/\\alpha$.\n\nGiven the following physical properties and geometry:\n- $L = 0.100\\,\\mathrm{m}$, $H = 0.010\\,\\mathrm{m}$,\n- $U = 0.50\\,\\mathrm{m/s}$,\n- $\\nu = 1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$,\n- $\\alpha = 2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$,\n\ndesign a lattice with $N_{x} = 1000$ nodes uniformly spanning the length $L$ (use a square lattice so that the lattice spacing is $\\Delta x = L/N_{x}$ in both directions). To keep compressibility error small, choose a characteristic lattice speed $U_{\\ell b} = 0.050$ (in lattice units). Using the similarity requirement that the Reynolds number and Péclet number computed in lattice units equal their physical values, determine the time step $\\Delta t$ consistent with this choice, and then compute the BGK relaxation times for momentum and temperature, $\\tau_{\\nu}$ and $\\tau_{T}$, required to represent the given $\\nu$ and $\\alpha$.\n\nExpress the final answer as a row matrix $\\left(\\tau_{\\nu},\\ \\tau_{T}\\right)$ with no units. Round your answer to five significant figures.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. It is a standard exercise in applying the scaling relations of the Lattice Boltzmann Method (LBM). Therefore, I will proceed with the derivation.\n\nThe core principle of LBM simulation is the invariance of dimensionless numbers, such as the Reynolds number ($\\mathrm{Re}$) and Péclet number ($\\mathrm{Pe}$), between the physical system and its lattice representation. This requires consistent scaling of physical quantities (length, time, mass) to their counterparts in lattice units.\n\nFirst, we define the lattice parameters. The physical length of the channel is $L = 0.100\\,\\mathrm{m}$, which is discretized by $N_{x} = 1000$ nodes. This defines the lattice spacing, $\\Delta x$, which is the physical distance between adjacent lattice nodes.\n$$\n\\Delta x = \\frac{L}{N_{x}} = \\frac{0.100\\,\\mathrm{m}}{1000} = 1.0 \\times 10^{-4}\\,\\mathrm{m}\n$$\nThe problem specifies a square lattice, so the spacing is the same in both dimensions.\n\nNext, we must determine the simulation time step, $\\Delta t$. This is found by relating the physical characteristic velocity, $U = 0.50\\,\\mathrm{m/s}$, to the specified characteristic velocity in lattice units, $U_{\\ell b} = 0.050$. The conversion between physical velocity ($v_{p}$) and lattice velocity ($v_{\\ell b}$) is given by $v_{p} = v_{\\ell b} \\frac{\\Delta x}{\\Delta t}$. Applying this to the characteristic velocities:\n$$\nU = U_{\\ell b} \\frac{\\Delta x}{\\Delta t}\n$$\nSolving for the time step $\\Delta t$:\n$$\n\\Delta t = \\frac{U_{\\ell b} \\Delta x}{U} = \\frac{0.050 \\times (1.0 \\times 10^{-4}\\,\\mathrm{m})}{0.50\\,\\mathrm{m/s}} = 1.0 \\times 10^{-5}\\,\\mathrm{s}\n$$\n\nWith the scaling factors $\\Delta x$ and $\\Delta t$ established, we can convert the physical transport coefficients—kinematic viscosity $\\nu$ and thermal diffusivity $\\alpha$—into their lattice unit equivalents, $\\nu_{\\ell b}$ and $\\alpha_{\\ell b}$. The conversion for these quantities, which have units of length$^2$/time, is given by:\n$$\n\\nu_{\\ell b} = \\frac{\\nu \\Delta t}{\\Delta x^{2}} \\quad \\text{and} \\quad \\alpha_{\\ell b} = \\frac{\\alpha \\Delta t}{\\Delta x^{2}}\n$$\nSubstituting the given physical values and the calculated scaling factors:\n$\\nu = 1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$\n$\\alpha = 2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$\n$$\n\\nu_{\\ell b} = \\frac{(1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}) \\times (1.0 \\times 10^{-5}\\,\\mathrm{s})}{(1.0 \\times 10^{-4}\\,\\mathrm{m})^{2}} = \\frac{1.5 \\times 10^{-10}}{1.0 \\times 10^{-8}} = 0.015\n$$\n$$\n\\alpha_{\\ell b} = \\frac{(2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}) \\times (1.0 \\times 10^{-5}\\,\\mathrm{s})}{(1.0 \\times 10^{-4}\\,\\mathrm{m})^{2}} = \\frac{2.2 \\times 10^{-10}}{1.0 \\times 10^{-8}} = 0.022\n$$\nThese are the dimensionless values for viscosity and diffusivity in the lattice simulation.\n\nFinally, we use the relations from the single-relaxation-time Bhatnagar–Gross–Krook (BGK) model for the D2Q9 lattice to find the required relaxation times, $\\tau_{\\nu}$ and $\\tau_{T}$. For this model, the transport coefficients in lattice units are related to their respective relaxation times by:\n$$\n\\nu_{\\ell b} = c_{s}^{2} (\\tau_{\\nu} - 0.5)\n$$\n$$\n\\alpha_{\\ell b} = c_{s}^{2} (\\tau_{T} - 0.5)\n$$\nThe problem specifies the square of the lattice speed of sound in lattice units as $c_{s}^{2} = 1/3$. We can now solve for the relaxation times.\n\nFor the momentum relaxation time, $\\tau_{\\nu}$:\n$$\n\\tau_{\\nu} = \\frac{\\nu_{\\ell b}}{c_{s}^{2}} + 0.5 = \\frac{0.015}{1/3} + 0.5 = 3 \\times 0.015 + 0.5 = 0.045 + 0.5 = 0.545\n$$\nFor the temperature (passive scalar) relaxation time, $\\tau_{T}$:\n$$\n\\tau_{T} = \\frac{\\alpha_{\\ell b}}{c_{s}^{2}} + 0.5 = \\frac{0.022}{1/3} + 0.5 = 3 \\times 0.022 + 0.5 = 0.066 + 0.5 = 0.566\n$$\nThe problem requires the answer to be rounded to five significant figures.\n$\\tau_{\\nu} = 0.54500$\n$\\tau_{T} = 0.56600$\n\nThe final answer is presented as a row matrix.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.54500  0.56600 \\end{pmatrix}}\n$$", "id": "2500937"}, {"introduction": "Once your simulation parameters are set, how can you be sure your LBM code is working correctly? The gold standard for verification is a grid refinement study, where you compare your numerical results against a known analytical solution. This hands-on coding practice ([@problem_id:2500947]) has you implement a simple 1D diffusion solver and measure its convergence rate. By confirming that the error decreases at the theoretically predicted rate, you gain confidence in your implementation and a deeper understanding of the LBM's accuracy.", "problem": "A one-dimensional diffusive heat pulse evolves according to the heat equation on a periodic domain. Consider the scalar temperature field $T(x,t)$ on a periodic interval of length $L$, governed by the equation $\\partial_t T = \\alpha \\,\\partial_{xx} T$, where $\\alpha$ is the constant thermal diffusivity. The lattice Boltzmann method (LBM) with the single-relaxation-time Bhatnagar–Gross–Krook (BGK) model in the one-dimensional, three-velocity stencil (D1Q3) will be used to approximate the evolution of this scalar field. The D1Q3 model employs discrete particle velocities $e_i \\in \\{-c, 0, +c\\}$ in physical units, quadrature weights $w_0 = 2/3$ and $w_{\\pm 1} = 1/6$, and a linear equilibrium distribution $f_i^{\\mathrm{eq}} = w_i \\, T$ for the scalar. The lattice sound speed satisfies $c_s^2 = c^2/3$. Under diffusive scaling consistent with the macroscopic heat equation, the thermal diffusivity is related to the lattice parameters by $\\alpha = c_s^2 \\, (\\tau - 1/2)\\,\\Delta t$, where $\\tau$ is the dimensionless relaxation time and $\\Delta t$ is the physical time step. With a uniform grid of $N_x$ nodes and grid spacing $\\Delta x = L/N_x$, streaming in D1Q3 is exact when $c = \\Delta x/\\Delta t$, which implies the coupling $\\Delta t = \\frac{\\Delta x^2}{3\\alpha}\\,(\\tau - 1/2)$ to keep $\\alpha$ fixed as the grid is refined.\n\nInitial condition and exact solution. Let the initial temperature be a periodic Gaussian pulse of amplitude $A$ and width parameter $\\sigma_0$, centered at $x_0 = L/2$. The $2J+1$-image periodic approximation is\n$$\nT(x,0) \\;=\\; A\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2}\\right).\n$$\nBy linear superposition and the fundamental solution of the heat equation, the corresponding periodic exact solution at time $t$ is\n$$\nT_{\\mathrm{exact}}(x,t) \\;=\\; A\\sqrt{\\frac{\\sigma_0^2}{\\sigma_0^2 + 4\\alpha t}} \\;\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2 + 4\\alpha t}\\right).\n$$\nAll quantities are nondimensional, so report any final numerical values as unitless numbers.\n\nDiscretization and error norm. Implement the scalar D1Q3 LBM with BGK collision and exact streaming on a periodic grid. The macroscopic temperature is the zeroth moment $T = \\sum_i f_i$. Initialize the populations by $f_i(x,0) = w_i \\, T(x,0)$. Evolve for $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ time steps to approximate the solution at $t^\\ast = N_t \\,\\Delta t$. Compare the numerical solution $T_{\\mathrm{num}}(x,t^\\ast)$ with the exact solution $T_{\\mathrm{exact}}(x,t^\\ast)$ using the discrete $L^2$ norm\n$$\nE \\;=\\; \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k,t^\\ast) - T_{\\mathrm{exact}}(x_k,t^\\ast)\\right]^2 \\right)^{1/2}.\n$$\n\nObserved orders of accuracy. Perform a grid refinement study with $N_x \\in \\{64,128,256,512\\}$ while keeping $\\alpha$ fixed via the diffusive scaling relation above. For each refinement, compute the error $E$, the grid spacing $\\Delta x$, and the time step $\\Delta t$. Estimate:\n- the observed spatial order $p_x$ as the slope of the least-squares linear fit of $\\log E$ versus $\\log \\Delta x$;\n- the observed temporal order $p_t$ as the slope of the least-squares linear fit of $\\log E$ versus $\\log \\Delta t$.\nBecause $\\Delta t \\propto \\Delta x^2$ under diffusive scaling, both fits must be performed on the same set of refinement data to separately characterize how errors scale with $\\Delta x$ and with $\\Delta t$.\n\nTest suite. Use the following three parameter sets, each with domain length $L=1$, center $x_0=L/2$, and image count $J=6$:\n- Case A (baseline): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n- Case B (lower diffusivity): $\\alpha=0.005$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n- Case C (sharper pulse): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.03$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n\nProgram requirements. Write a complete program that:\n- Implements the D1Q3 scalar LBM described above for each case and for $N_x \\in \\{64,128,256,512\\}$.\n- For each case, computes the arrays $\\{E\\}$, $\\{\\Delta x\\}$, and $\\{\\Delta t\\}$ across refinements, then returns $(p_x, p_t)$ using least-squares fits.\n- Produces as its only output a single line containing the six floating-point values $[p_x^{(A)},p_t^{(A)},p_x^{(B)},p_t^{(B)},p_x^{(C)},p_t^{(C)}]$ in that order, each rounded to three decimal places, formatted as a comma-separated list enclosed in square brackets.\n\nAngle units and physical units. There are no angle quantities, and all variables are nondimensional. No physical units should be reported; all outputs are pure numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\").", "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, and self-contained. It presents a standard numerical analysis task involving the application of the lattice Boltzmann method (LBM) to the one-dimensional heat equation. All parameters, equations, and procedures are specified with sufficient clarity and correctness to permit a unique solution. We therefore proceed with the derivation and implementation of the solution.\n\nThe problem requires the numerical solution of the scalar heat diffusion equation,\n$$\n\\partial_t T = \\alpha \\,\\partial_{xx} T\n$$\non a one-dimensional periodic domain of length $L$. The method specified is the D1Q3 lattice Boltzmann model with a Bhatnagar-Gross-Krook (BGK) collision operator.\n\nThe D1Q3 model discretizes velocity space into three directions, $i \\in \\{0, 1, 2\\}$, corresponding to microscopic particle velocities $e_0 = 0$, $e_1 = +c$, and $e_2 = -c$. The evolution of the particle distribution functions, $f_i(x,t)$, is governed by the lattice Boltzmann equation:\n$$\nf_i(x+e_i\\Delta t, t+\\Delta t) - f_i(x,t) = -\\frac{1}{\\tau} (f_i(x,t) - f_i^{\\mathrm{eq}}(x,t))\n$$\nwhere $\\tau$ is the dimensionless relaxation time, and $f_i^{\\mathrm{eq}}$ is the local equilibrium distribution. The left-hand side represents the streaming of particles to adjacent lattice sites, while the right-hand side represents the relaxation towards equilibrium due to collisions.\n\nFor a scalar diffusive process, the equilibrium distribution is a linear function of the macroscopic scalar field, in this case, the temperature $T$. It is given by $f_i^{\\mathrm{eq}} = w_i T$, where $w_i$ are the quadrature weights. For the D1Q3 stencil, these weights are $w_0 = 2/3$ and $w_{1,2} = 1/6$. The macroscopic temperature is recovered as the zeroth moment of the distribution functions:\n$$\nT(x,t) = \\sum_{i=0}^{2} f_i(x,t)\n$$\nIt can be verified that $\\sum_i f_i^{\\mathrm{eq}} = \\sum_i w_i T = T(\\sum_i w_i) = T(2/3 + 1/6 + 1/6) = T$, which ensures local conservation of the scalar quantity $T$ during collision.\n\nThe numerical algorithm proceeds in two steps at each time increment: collision and streaming.\n1.  **Collision Step**: The post-collision distribution functions, $f_i^{\\ast}$, are computed at each grid node $x_k$:\n    $$\n    f_i^{\\ast}(x_k, t) = f_i(x_k, t) - \\frac{1}{\\tau} (f_i(x_k, t) - f_i^{\\mathrm{eq}}(x_k, t))\n    $$\n    First, the macroscopic temperature $T(x_k,t) = \\sum_i f_i(x_k,t)$ is calculated from the current populations. Then, the equilibrium populations $f_i^{\\mathrm{eq}}(x_k,t) = w_i T(x_k,t)$ are determined, and finally the collision update is applied.\n\n2.  **Streaming Step**: The post-collision populations propagate to adjacent nodes according to their velocities. With the lattice speed set to $c = \\Delta x/\\Delta t$, where $\\Delta x$ is the grid spacing and $\\Delta t$ is the time step, particles move exactly from one node to its neighbor in one time step. For a periodic domain, this is implemented as a circular shift:\n    $$\n    f_0(x_k, t+\\Delta t) = f_0^{\\ast}(x_k, t) \\\\\n    f_1(x_k, t+\\Delta t) = f_1^{\\ast}(x_{k-1}, t) \\\\\n    f_2(x_k, t+\\Delta t) = f_2^{\\ast}(x_{k+1}, t)\n    $$\n    The indices $k-1$ and $k+1$ are handled with periodic wrap-around.\n\nThe simulation is initialized at time $t=0$. The initial temperature field $T(x,0)$ is given by a periodic sum of Gaussian functions. The initial particle distributions are set to be in local equilibrium with this field: $f_i(x_k, 0) = f_i^{\\mathrm{eq}}(x_k, 0) = w_i T(x_k, 0)$. The simulation then evolves for $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ time steps. The final numerical temperature profile $T_{\\mathrm{num}}(x_k, t^{\\ast})$ is computed at the actual final time $t^{\\ast} = N_t \\Delta t$.\n\nThe problem specifies a diffusive scaling relationship to keep the physical thermal diffusivity $\\alpha$ constant across grid refinements. The relation is:\n$$\n\\alpha = c_s^2 (\\tau - 1/2) \\Delta t\n$$\nwhere $c_s^2 = c^2/3 = (\\Delta x/\\Delta t)^2/3$ is the square of the lattice sound speed. Substituting $c_s^2$ into the expression for $\\alpha$ and solving for $\\Delta t$ yields the explicit coupling between the time step and grid spacing:\n$$\n\\Delta t = \\frac{\\Delta x^2}{3\\alpha} (\\tau - 1/2)\n$$\nThis relation implies that $\\Delta t \\propto \\Delta x^2$.\n\nA grid refinement study is performed using grid sizes $N_x \\in \\{64, 128, 256, 512\\}$. For each $N_x$, the grid spacing is $\\Delta x=L/N_x$, and the corresponding $\\Delta t$ is calculated. The simulation is run, and the error $E$ is computed using the discrete $L^2$ norm against the provided exact solution evaluated at $t^{\\ast}$:\n$$\nE = \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k, t^{\\ast}) - T_{\\mathrm{exact}}(x_k, t^{\\ast})\\right]^2 \\right)^{1/2}\n$$\nThe order of accuracy is determined from the assumption of an error scaling law $E \\approx C (\\Delta x)^{p_x}$ for some constant $C$ and spatial order $p_x$. Taking the logarithm gives $\\log E \\approx \\log C + p_x \\log \\Delta x$. The spatial order $p_x$ is therefore the slope of the least-squares linear fit of $\\log E$ versus $\\log \\Delta x$. Similarly, since $\\Delta t \\propto \\Delta x^2$, we have $\\log E \\approx \\log C' + p_t \\log \\Delta t$, where $p_t = p_x/2$. The temporal order $p_t$ is the slope of the fit of $\\log E$ versus $\\log \\Delta t$. These two slopes will be computed for each of the three test cases specified. The LBM-BGK scheme for diffusion is expected to be second-order accurate in space, so we anticipate $p_x \\approx 2.0$ and consequently $p_t \\approx 1.0$.\n\nThe implementation proceeds by first defining functions for the initial condition and the exact analytical solution. A main simulation function encapsulates the LBM algorithm for a given set of physical and numerical parameters. This function is called for each refinement level. The resulting errors and grid parameters are collected. Finally, a linear regression is performed on the log-transformed data to extract the observed orders of accuracy, which are then reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef setup_exact_solution_function(L, A, sigma0, alpha, J, x0):\n    \"\"\"\n    Creates a function that computes the exact solution for a given time t.\n    \"\"\"\n    def get_exact_solution(x_grid, t):\n        if t == 0:\n            var_term = sigma0**2\n            time_prefactor = A\n        else:\n            var_term = sigma0**2 + 4 * alpha * t\n            time_prefactor = A * np.sqrt(sigma0**2 / var_term)\n\n        if var_term == 0:\n            # Handle the case of a delta function, though not expected here.\n            T_exact = np.zeros_like(x_grid)\n            idx = np.abs(x_grid - x0).argmin()\n            T_exact[idx] = np.inf\n            return T_exact\n\n        T_exact = np.zeros_like(x_grid)\n        for j in range(-J, J + 1):\n            T_exact += np.exp(-((x_grid - x0 + j * L)**2) / var_term)\n        \n        return time_prefactor * T_exact\n\n    return get_exact_solution\n\n\ndef run_lbm_and_get_error(Nx, L, alpha, tau, T_final, A, sigma0, J, x0):\n    \"\"\"\n    Runs a single D1Q3 LBM simulation and computes the L2 error.\n    \"\"\"\n    # Grid and time parameters\n    dx = L / Nx\n    dt = (dx**2 / (3 * alpha)) * (tau - 0.5)\n    Nt = int(round(T_final / dt))\n    t_star = Nt * dt\n    x = np.linspace(0, L, Nx, endpoint=False) + dx / 2.0\n\n    # LBM parameters\n    w = np.array([2./3., 1./6., 1./6.]) # w0, w+, w-\n    omega = 1.0 / tau\n\n    # Initialization\n    exact_solution_func = setup_exact_solution_function(L, A, sigma0, alpha, J, x0)\n    T0 = exact_solution_func(x, 0)\n    \n    # Populations f0, f+, f-\n    f0 = w[0] * T0\n    f1 = w[1] * T0\n    f2 = w[2] * T0\n    \n    # Main time-stepping loop\n    for _ in range(Nt):\n        # Macroscopic temperature\n        T = f0 + f1 + f2\n        \n        # Collision\n        f0_eq = w[0] * T\n        f1_eq = w[1] * T\n        f2_eq = w[2] * T\n        \n        f0 = f0 - omega * (f0 - f0_eq)\n        f1 = f1 - omega * (f1 - f1_eq)\n        f2 = f2 - omega * (f2 - f2_eq)\n        \n        # Streaming\n        f1 = np.roll(f1, 1)  # moves right\n        f2 = np.roll(f2, -1) # moves left\n\n    # Final numerical temperature\n    T_num = f0 + f1 + f2\n    \n    # Exact solution at final time\n    T_exact = exact_solution_func(x, t_star)\n    \n    # L2 Error calculation\n    error = np.sqrt(dx * np.sum((T_num - T_exact)**2))\n    \n    return error, dx, dt\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute orders of accuracy.\n    \"\"\"\n    test_cases = [\n        # Case A (baseline)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case B (lower diffusivity)\n        {\"alpha\": 0.005, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case C (sharper pulse)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.03, \"A\": 1.0, \"T_final\": 0.02},\n    ]\n\n    # Shared parameters\n    L = 1.0\n    x0 = L / 2.0\n    J = 6\n    Nx_refinements = [64, 128, 256, 512]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        errors = []\n        dxs = []\n        dts = []\n        \n        for Nx in Nx_refinements:\n            error, dx, dt = run_lbm_and_get_error(Nx, L, **case_params, J=J, x0=x0)\n            errors.append(error)\n            dxs.append(dx)\n            dts.append(dt)\n        \n        # Log-transform data for linear regression\n        log_errors = np.log(np.array(errors))\n        log_dxs = np.log(np.array(dxs))\n        log_dts = np.log(np.array(dts))\n        \n        # Perform linear regression to find slopes (orders of accuracy)\n        px_res = linregress(log_dxs, log_errors)\n        pt_res = linregress(log_dts, log_errors)\n        \n        px = px_res.slope\n        pt = pt_res.slope\n        \n        all_results.extend([px, pt])\n\n    # Format the final output string\n    # [px_A, pt_A, px_B, pt_B, px_C, pt_C] rounded to 3 decimal places\n    output_str = f\"[{','.join([f'{r:.3f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2500947"}, {"introduction": "Real-world applications rarely involve simple, grid-aligned geometries. Handling curved boundaries is a critical challenge in LBM, as simplistic approaches can introduce significant errors that contaminate the entire solution. This advanced practice ([@problem_id:2500986]) delves into the analysis of boundary-induced errors using a manufactured solution. You will not only quantify the first-order error from a basic boundary rule but also derive and implement a second-order accurate correction, showcasing how to systematically improve the fidelity of your simulations.", "problem": "Consider heat conduction of a passive scalar governed by the energy balance in the absence of advection, where the temperature field $T(\\mathbf{x},t)$ satisfies $\\partial T/\\partial t = \\alpha \\nabla^2 T + S$, with thermal diffusivity $\\alpha$ and source term $S$. Focus on the local, steady-state behavior in the vicinity of a smooth, curved isothermal boundary (Dirichlet condition) where the temperature at the wall is $T_{\\mathrm{w}}$. Introduce the local orthonormal Frenet frame $(s,n)$ where $n$ is the outward normal coordinate from the wall and $s$ is the tangential coordinate along the wall. For a locally tangentially uniform field (i.e., $\\partial/\\partial s = 0$), the Laplacian reduces to $\\nabla^2 T = \\partial^2 T/\\partial n^2 + \\kappa\\, \\partial T/\\partial n$, where $\\kappa$ is the signed curvature of the boundary at the point of interest (positive for locally convex boundaries as seen from the fluid).\n\nIn a Lattice Boltzmann Method (LBM) for scalar transport, a widely used boundary treatment for curved walls is the Interpolated Bounce-Back (IBB). Consider one lattice link crossing the wall where the fluid node is located at a normal distance $q\\,\\Delta x$ from the wall, with $q\\in(0,1)$ and spatial step $\\Delta x$. For an isothermal wall at $T_{\\mathrm{w}}$ and a nearby fluid node with temperature $T_{\\mathrm{f}}$, a common, geometry-consistent estimator of the wall-normal temperature gradient (needed to compute heat flux) is the finite-difference quotient\n$$\nG_{\\mathrm{naive}}(\\Delta x; \\kappa, q) \\equiv \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}.\n$$\nThe corresponding wall-normal heat flux is $q_n = -k\\, G$, where $k$ is the thermal conductivity. In the IBB context, $G_{\\mathrm{naive}}$ captures the effect of the off-grid intersection via $q$, but neglects curvature-induced coupling.\n\nYour tasks are:\n\n- Starting from the steady normal-direction diffusion equation in the local frame, $\\partial^2 T/\\partial n^2 + \\kappa\\, \\partial T/\\partial n = 0$, and a Taylor expansion about the wall location $n=0$, derive the leading-order truncation error of $G_{\\mathrm{naive}}$ in powers of $\\Delta x$. Then, propose a curvature-aware corrected estimator $G_{\\mathrm{corr}}(\\Delta x; \\kappa, q)$ that restores second-order accuracy in $\\Delta x$ for the wall-normal gradient. The correction must be obtained by systematically eliminating the leading curvature-induced bias term in the Taylor expansion.\n- To produce concrete, testable numbers without simulating a full Lattice Boltzmann Method, consider the manufactured local exact solution defined by the boundary-value problem\n$$\n\\frac{\\partial^2 T}{\\partial n^2} + \\kappa\\, \\frac{\\partial T}{\\partial n} = 0,\\quad T(0) = T_{\\mathrm{w}},\\quad \\left.\\frac{\\partial T}{\\partial n}\\right|_{n=0} = G_{\\ast},\n$$\nwith constant $\\kappa \\neq 0$ and constant prescribed wall-normal gradient $G_{\\ast}$. This has the exact solution\n$$\nT(n) = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{-\\kappa n} - 1\\right).\n$$\nIn particular, at the fluid node located at $n = -q\\,\\Delta x$ (inside the fluid), the exact temperature is\n$$\nT_{\\mathrm{f}} = T(-q\\,\\Delta x) = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{\\kappa\\, q\\, \\Delta x} - 1\\right).\n$$\nUse this exact $T_{\\mathrm{f}}$ to evaluate numerical estimators of the wall-normal gradient without evolving any time-dependent scheme.\n\n- Define the absolute errors\n$$\nE_{\\mathrm{naive}}(\\Delta x; \\kappa, q) \\equiv \\left| G_{\\mathrm{naive}}(\\Delta x; \\kappa, q) - G_{\\ast} \\right|,\\qquad\nE_{\\mathrm{corr}}(\\Delta x; \\kappa, q) \\equiv \\left| G_{\\mathrm{corr}}(\\Delta x; \\kappa, q) - G_{\\ast} \\right|.\n$$\nFor each estimator, compute the observed convergence order $p$ by performing a least-squares linear regression of $\\log E$ versus $\\log \\Delta x$ over a refinement sequence.\n\n- Use the following test suite of curvature and intersection parameters and grid refinements:\n    - Curvature and intersection pairs $(\\kappa, q)$:\n        $$\n        (\\kappa, q) \\in \\left\\{ (1.0, 0.3),\\ (0.5, 0.8),\\ (-1.0, 0.4),\\ (2.0, 0.1) \\right\\}.\n        $$\n    - Refinement sequence for the grid spacing:\n        $$\n        \\Delta x \\in \\left\\{ 1/10,\\ 1/20,\\ 1/40,\\ 1/80 \\right\\}.\n        $$\n    - Use $T_{\\mathrm{w}} = 0$ and $G_{\\ast} = 1$ (dimensionless units), and $k=1$ so that the heat flux magnitude equals the gradient magnitude. Report only the gradient convergence orders; units are not required for $p$ (dimensionless).\n\n- Program requirements:\n    - Implement both the naive estimator and your derived curvature-corrected estimator.\n    - For each $(\\kappa,q)$ in the test suite, compute the observed convergence orders $p_{\\mathrm{naive}}$ and $p_{\\mathrm{corr}}$ over the specified refinement sequence.\n    - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n      $[p_{\\mathrm{naive},1}, p_{\\mathrm{corr},1}, p_{\\mathrm{naive},2}, p_{\\mathrm{corr},2}, p_{\\mathrm{naive},3}, p_{\\mathrm{corr},3}, p_{\\mathrm{naive},4}, p_{\\mathrm{corr},4}]$,\n      where the subscript index runs over the four $(\\kappa,q)$ cases in the order given above.\n\nAll computations are to be carried out in dimensionless form. Explicitly express the final output exactly as a single Python print of the bracketed list described above.", "solution": "The problem statement is critically examined and found to be valid. It is scientifically grounded in the principles of heat transfer and numerical analysis, well-posed with a clear objective, and provides a self-contained, consistent set of data and definitions. The use of a manufactured solution is a standard and rigorous technique for verifying the order of accuracy of numerical schemes. We may thus proceed with the formal solution.\n\nThe task is to derive a curvature-corrected estimator for the wall-normal temperature gradient and to verify its numerical convergence properties against a simpler, naive estimator.\n\nLet us begin with the steady-state, tangentially uniform energy balance equation in the local Frenet frame $(s,n)$, where $n$ is the normal coordinate:\n$$\n\\frac{d^2 T}{d n^2} + \\kappa \\frac{d T}{d n} = 0\n$$\nHere, $T(n)$ is the temperature profile along the normal direction, and $\\kappa$ is the local wall curvature. The boundary is located at $n=0$ and is isothermal, so $T(0) = T_{\\mathrm{w}}$. The true wall-normal gradient is denoted by $G_{\\ast} = \\left.\\frac{dT}{dn}\\right|_{n=0}$.\n\nFrom the governing equation evaluated at the wall $n=0$, we can relate the second derivative to the first:\n$$\n\\left.\\frac{d^2 T}{d n^2}\\right|_{n=0} = -\\kappa \\left.\\frac{d T}{d n}\\right|_{n=0} = -\\kappa G_{\\ast}\n$$\nWe can find higher-order derivatives by differentiating the governing equation with respect to $n$:\n$$\n\\frac{d^3 T}{d n^3} = -\\kappa \\frac{d^2 T}{d n^2} = (-\\kappa)(-\\kappa \\frac{dT}{dn}) = \\kappa^2 \\frac{d T}{d n}\n$$\nAt the wall, $\\left.\\frac{d^3 T}{d n^3}\\right|_{n=0} = \\kappa^2 G_{\\ast}$.\n\nWe now construct a Taylor series expansion for the temperature $T(n)$ around the wall location $n=0$:\n$$\nT(n) = T(0) + n \\left.\\frac{dT}{dn}\\right|_{n=0} + \\frac{n^2}{2!} \\left.\\frac{d^2T}{dn^2}\\right|_{n=0} + \\frac{n^3}{3!} \\left.\\frac{d^3T}{dn^3}\\right|_{n=0} + \\mathcal{O}(n^4)\n$$\nSubstituting the known values and derived derivative relations:\n$$\nT(n) = T_{\\mathrm{w}} + n G_{\\ast} - \\frac{n^2}{2} \\kappa G_{\\ast} + \\frac{n^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(n^4)\n$$\nThe fluid node under consideration is located at a normal distance $q\\,\\Delta x$ from the wall. Since $n$ is the outward normal, a fluid node inside the domain is at $n = -q\\,\\Delta x$. Evaluating the temperature at this fluid node, $T_{\\mathrm{f}} = T(-q\\,\\Delta x)$:\n$$\nT_{\\mathrm{f}} = T_{\\mathrm{w}} + (-q\\,\\Delta x) G_{\\ast} - \\frac{(-q\\,\\Delta x)^2}{2} \\kappa G_{\\ast} - \\frac{(-q\\,\\Delta x)^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n$$\nT_{\\mathrm{f}} = T_{\\mathrm{w}} - q\\,\\Delta x\\, G_{\\ast} - \\frac{q^2 \\Delta x^2}{2} \\kappa G_{\\ast} + \\frac{q^3 \\Delta x^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\nRearranging for the difference $T_{\\mathrm{w}} - T_{\\mathrm{f}}$:\n$$\nT_{\\mathrm{w}} - T_{\\mathrm{f}} = q\\,\\Delta x\\, G_{\\ast} + \\frac{\\kappa q^2 \\Delta x^2}{2} G_{\\ast} - \\frac{\\kappa^2 q^3 \\Delta x^3}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\nThe naive gradient estimator is defined as $G_{\\mathrm{naive}} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}$. Substituting the expansion:\n$$\nG_{\\mathrm{naive}} = \\frac{1}{q\\,\\Delta x} \\left( q\\,\\Delta x\\, G_{\\ast} + \\frac{\\kappa q^2 \\Delta x^2}{2} G_{\\ast} - \\frac{\\kappa^2 q^3 \\Delta x^3}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^4) \\right)\n$$\n$$\nG_{\\mathrm{naive}} = G_{\\ast} + \\frac{\\kappa q \\Delta x}{2} G_{\\ast} - \\frac{\\kappa^2 q^2 \\Delta x^2}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^3)\n$$\nThe truncation error of this estimator is $G_{\\mathrm{naive}} - G_{\\ast} = \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\mathcal{O}(\\Delta x^2)$. This error is first-order in $\\Delta x$, so we expect a convergence order of $p=1$. This is the leading curvature-induced bias.\n\nTo restore second-order accuracy, we must eliminate this leading error term. From the expression for $G_{\\mathrm{naive}}$, we can write:\n$$\nG_{\\ast} = G_{\\mathrm{naive}} - \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\mathcal{O}(\\Delta x^2)\n$$\nTo eliminate the unknown $G_{\\ast}$ on the right-hand side, we can substitute its lowest-order approximation, $G_{\\ast} \\approx G_{\\mathrm{naive}}$, which is permissible as it only introduces an error of higher order. However, a more systematic approach is to rearrange the expression $T_{\\mathrm{w}} - T_{\\mathrm{f}}$:\n$$\nT_{\\mathrm{w}} - T_{\\mathrm{f}} = q\\,\\Delta x\\, G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} - \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\mathcal{O}(\\Delta x^3) \\right)\n$$\nSolving for $G_{\\ast}$:\n$$\nG_{\\ast} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\mathcal{O}(\\Delta x^2) \\right)} = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{\\kappa q \\Delta x}{2} + \\mathcal{O}(\\Delta x^2)}\n$$\nThis motivates the definition of a curvature-corrected estimator, $G_{\\mathrm{corr}}$, which is second-order accurate:\n$$\nG_{\\mathrm{corr}}(\\Delta x; \\kappa, q) = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{\\kappa q \\Delta x}{2}}\n$$\nLet us verify the accuracy of this new estimator. We substitute the full expansion for $G_{\\mathrm{naive}}$:\n$$\nG_{\\mathrm{corr}} = \\frac{G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} - \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\mathcal{O}(\\Delta x^3)\\right)}{1 + \\frac{\\kappa q \\Delta x}{2}}\n$$\nUsing the geometric series expansion $\\frac{1}{1+z} = 1 - z + z^2 - \\dots$ with $z = \\frac{\\kappa q \\Delta x}{2}$:\n$$\nG_{\\mathrm{corr}} = G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} - \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\dots\\right) \\left(1 - \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\dots\\right)\n$$\nExpanding and collecting terms by powers of $\\Delta x$:\n- Term of order $\\Delta x^0$: $G_{\\ast} \\cdot 1 \\cdot 1 = G_{\\ast}$.\n- Term of order $\\Delta x^1$: $G_{\\ast} \\left( -\\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa q \\Delta x}{2} \\right) = 0$. The first-order error term is successfully eliminated.\n- Term of order $\\Delta x^2$: $G_{\\ast} \\left( \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\frac{\\kappa^2 q^2 \\Delta x^2}{6} \\right) = -G_{\\ast} \\frac{\\kappa^2 q^2 \\Delta x^2}{6}$.\n\nSo, the expansion for the corrected estimator is:\n$$\nG_{\\mathrm{corr}} = G_{\\ast} - \\frac{\\kappa^2 q^2 \\Delta x^2}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^3)\n$$\nThe truncation error is $G_{\\mathrm{corr}} - G_{\\ast} = \\mathcal{O}(\\Delta x^2)$, confirming that this estimator is second-order accurate. We expect a numerical convergence order of $p=2$.\n\nFor the numerical part of the problem, we will implement the following formulae:\n1.  The exact fluid temperature $T_{\\mathrm{f}}$ at $n=-q\\Delta x$ is given by the manufactured solution:\n    $$T_{\\mathrm{f}} = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{\\kappa\\, q\\, \\Delta x} - 1\\right)$$\n2.  The naive estimator is computed as:\n    $$G_{\\mathrm{naive}} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}$$\n3.  The curvature-corrected estimator is:\n    $$G_{\\mathrm{corr}} = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{1}{2}\\kappa q \\Delta x}$$\n4.  The absolute errors are $E_{\\mathrm{naive}} = |G_{\\mathrm{naive}} - G_{\\ast}|$ and $E_{\\mathrm{corr}} = |G_{\\mathrm{corr}} - G_{\\ast}|$.\n5.  The convergence order $p$ is the slope of the linear least-squares fit of $\\log E$ versus $\\log \\Delta x$.\n\nAll computations will be performed with the specified parameters $T_{\\mathrm{w}}=0$, $G_{\\ast}=1$, and the provided sets of $(\\kappa, q)$ and $\\Delta x$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convergence orders for naive and curvature-corrected\n    wall-normal gradient estimators.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.3),  # (kappa, q) pair 1\n        (0.5, 0.8),  # (kappa, q) pair 2\n        (-1.0, 0.4), # (kappa, q) pair 3\n        (2.0, 0.1),  # (kappa, q) pair 4\n    ]\n\n    # Refinement sequence for the grid spacing.\n    dx_values = np.array([1/10, 1/20, 1/40, 1/80])\n    \n    # Constants for the manufactured solution.\n    Tw = 0.0\n    G_star = 1.0\n\n    results = []\n\n    for kappa, q in test_cases:\n        errors_naive = []\n        errors_corr = []\n\n        for dx in dx_values:\n            # 1. Calculate the exact fluid temperature Tf at the fluid node n = -q*dx\n            # using the provided manufactured solution.\n            # T_f = T_w + (G_star / -kappa) * (e^(kappa*q*dx) - 1)\n            # Since kappa is guaranteed to be non-zero, no division-by-zero check is needed.\n            Tf = Tw + (G_star / -kappa) * (np.exp(kappa * q * dx) - 1.0)\n            \n            # 2. Calculate the naive gradient estimator G_naive.\n            # G_naive = (T_w - T_f) / (q*dx)\n            G_naive = (Tw - Tf) / (q * dx)\n            \n            # 3. Calculate the curvature-corrected gradient estimator G_corr.\n            # G_corr = G_naive / (1 + 0.5 * kappa * q * dx)\n            G_corr = G_naive / (1.0 + 0.5 * kappa * q * dx)\n            \n            # 4. Calculate the absolute errors for both estimators.\n            E_naive = np.abs(G_naive - G_star)\n            E_corr = np.abs(G_corr - G_star)\n            \n            errors_naive.append(E_naive)\n            errors_corr.append(E_corr)\n\n        # 5. Compute the convergence orders p_naive and p_corr.\n        # This is done by a linear least-squares regression of log(E) vs log(dx).\n        # The slope of this regression is the convergence order p.\n        log_dx = np.log(dx_values)\n        \n        # For the naive estimator\n        log_E_naive = np.log(np.array(errors_naive))\n        # np.polyfit with degree 1 returns [slope, intercept]\n        p_naive = np.polyfit(log_dx, log_E_naive, 1)[0]\n        \n        # For the corrected estimator\n        log_E_corr = np.log(np.array(errors_corr))\n        p_corr = np.polyfit(log_dx, log_E_corr, 1)[0]\n        \n        results.extend([p_naive, p_corr])\n\n    # Final print statement in the exact required format.\n    # The output format is a single line: [p_naive1,p_corr1,p_naive2,p_corr2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2500986"}]}