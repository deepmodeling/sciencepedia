{"hands_on_practices": [{"introduction": "Mastering system inversion begins with a solid foundation. This first exercise provides a fundamental walkthrough of inverting a simple yet common discrete-time system, a first-order IIR filter. By using the Z-transform to find the inverse and then verifying the result in the time domain through direct convolution, this practice reinforces the powerful connection between time-domain operations and algebraic manipulation in the transform domain [@problem_id:2909246].", "problem": "Consider a causal linear time-invariant (LTI) discrete-time system with impulse response $h[n]=\\alpha^{n}u[n]$, where $|\\alpha|1$ and $u[n]$ is the unit-step sequence. Using only the fundamental definitions of convolution, system invertibility for linear time-invariant systems, and the two-sided Z-transform (ZT) along with its convolution-multiplication property, determine a causal impulse response $g[n]$ for an inverse system such that $(h*g)[n]=\\delta[n]$, where $\\delta[n]$ is the Kronecker delta. Rigorously justify the causality and absolute summability of $g[n]$, and verify in the time domain that $(h*g)[n]=\\delta[n]$ by direct evaluation of the convolution sum from first principles. Provide your final answer as a single closed-form expression for $g[n]$ in terms of $\\delta[\\cdot]$ and $\\alpha$. No numerical approximation is required, and no units are involved.", "solution": "The problem statement is subjected to validation.\n\nGivens are extracted verbatim as follows:\n1.  System is a causal linear time-invariant (LTI) discrete-time system.\n2.  The impulse response is given by $h[n]=\\alpha^{n}u[n]$.\n3.  A constraint on the parameter $\\alpha$ is $|\\alpha|1$.\n4.  $u[n]$ is the unit-step sequence.\n5.  An inverse system with a causal impulse response $g[n]$ must be found.\n6.  The condition for the inverse system is $(h*g)[n]=\\delta[n]$.\n7.  $\\delta[n]$ is the Kronecker delta.\n8.  The determination must use only the fundamental definitions of convolution, system invertibility for LTI systems, the two-sided Z-transform (ZT), and its convolution-multiplication property.\n9.  The causality and absolute summability of $g[n]$ must be rigorously justified.\n10. The result $(h*g)[n]=\\delta[n]$ must be verified in the time domain by direct evaluation of the convolution sum.\n11. The final answer must be a single closed-form expression for $g[n]$ in terms of $\\delta[\\cdot]$ and $\\alpha$.\n\nValidation assessment:\nThe problem is scientifically grounded, being a fundamental exercise in the theory of discrete-time LTI systems. It is well-posed, providing sufficient and consistent information to determine a unique, stable, and causal inverse system. The language is objective and precise. The problem is free from scientific unsoundness, ambiguity, and is formalizable within the specified domain of signal processing. It is a standard, non-trivial problem that requires rigorous application of first principles as demanded. Therefore, the problem is deemed valid and a solution will be furnished.\n\nThe objective is to find the impulse response $g[n]$ of a causal LTI system that is the inverse of the system with impulse response $h[n] = \\alpha^n u[n]$. The defining property of an inverse system is that the convolution of the original impulse response and the inverse impulse response yields the Kronecker delta function, which is the identity element for convolution:\n$$ (h*g)[n] = \\delta[n] $$\nWe are instructed to use the Z-transform. The convolution property of the Z-transform states that convolution in the time domain corresponds to multiplication in the Z-domain. Let $H(z) = \\mathcal{Z}\\{h[n]\\}$ and $G(z) = \\mathcal{Z}\\{g[n]\\}$. Applying the Z-transform to the defining equation gives:\n$$ H(z)G(z) = \\mathcal{Z}\\{\\delta[n]\\} $$\nThe Z-transform of the Kronecker delta is $1$. Thus, the transfer function of the inverse system, $G(z)$, is given by:\n$$ G(z) = \\frac{1}{H(z)} $$\nFirst, we must compute $H(z)$, the Z-transform of $h[n] = \\alpha^n u[n]$. By the definition of the two-sided Z-transform:\n$$ H(z) = \\sum_{n=-\\infty}^{\\infty} h[n] z^{-n} = \\sum_{n=-\\infty}^{\\infty} \\alpha^n u[n] z^{-n} $$\nSince $u[n] = 0$ for $n  0$ and $u[n] = 1$ for $n \\ge 0$, the summation becomes:\n$$ H(z) = \\sum_{n=0}^{\\infty} \\alpha^n z^{-n} = \\sum_{n=0}^{\\infty} (\\alpha z^{-1})^n $$\nThis is a geometric series which converges if and only if $|\\alpha z^{-1}|  1$. This condition defines the Region of Convergence (ROC) as $|z|  |\\alpha|$. Given that $|\\alpha|  1$, the ROC $|z|  |\\alpha|$ includes the unit circle, $|z|=1$, which is consistent with the fact that the original system is stable (a causal system with $h[n]=\\alpha^n u[n]$ is stable if $|\\alpha|1$). The sum of the convergent geometric series is:\n$$ H(z) = \\frac{1}{1 - \\alpha z^{-1}}, \\quad \\text{ROC: } |z|  |\\alpha| $$\nNow we can determine the transfer function $G(z)$ of the inverse system:\n$$ G(z) = \\frac{1}{H(z)} = \\frac{1}{\\frac{1}{1 - \\alpha z^{-1}}} = 1 - \\alpha z^{-1} $$\nThe expression for $G(z)$ is a finite polynomial in $z^{-1}$, so its ROC is the entire z-plane, except for a possible pole at $z=0$. So the ROC is $|z|0$. To find the impulse response $g[n]$, we compute the inverse Z-transform of $G(z)$. By inspection of the terms:\nThe inverse Z-transform of $1$ is $\\delta[n]$.\nThe inverse Z-transform of $z^{-1}$ is $\\delta[n-1]$.\nTherefore, using the linearity of the Z-transform:\n$$ g[n] = \\mathcal{Z}^{-1}\\{1 - \\alpha z^{-1}\\} = \\mathcal{Z}^{-1}\\{1\\} - \\alpha \\mathcal{Z}^{-1}\\{z^{-1}\\} = \\delta[n] - \\alpha \\delta[n-1] $$\nThis provides the closed-form expression for the impulse response of the inverse system.\n\nNext, we must justify the causality and absolute summability of $g[n]$.\nCausality: A discrete-time system is causal if its impulse response $g[n]$ is zero for all $n  0$. The derived impulse response is $g[n] = \\delta[n] - \\alpha \\delta[n-1]$.\nFor any $n  0$, both $\\delta[n]$ and $\\delta[n-1]$ are zero. Specifically, for $n=-1$, $g[-1] = \\delta[-1] - \\alpha \\delta[-2] = 0 - 0 = 0$. For any $n \\le -2$, all terms are zero. Thus, $g[n]=0$ for all $n0$. The system is causal, as required.\n\nAbsolute Summability (Stability): A system is stable if its impulse response is absolutely summable, meaning $\\sum_{n=-\\infty}^{\\infty} |g[n]|  \\infty$.\nWe compute this sum for our derived $g[n]$:\n$$ \\sum_{n=-\\infty}^{\\infty} |g[n]| = \\sum_{n=-\\infty}^{\\infty} |\\delta[n] - \\alpha \\delta[n-1]| $$\nThe expression is non-zero only at $n=0$ and $n=1$.\nFor $n=0$: $|g[0]| = |\\delta[0] - \\alpha \\delta[-1]| = |1 - \\alpha(0)| = 1$.\nFor $n=1$: $|g[1]| = |\\delta[1] - \\alpha \\delta[0]| = |0 - \\alpha(1)| = |-\\alpha| = |\\alpha|$.\nFor all other integers $n$, $g[n] = 0$.\nThe sum is therefore:\n$$ \\sum_{n=-\\infty}^{\\infty} |g[n]| = |g[0]| + |g[1]| = 1 + |\\alpha| $$\nThe problem states that $|\\alpha|  1$. Therefore, the sum is $1 + |\\alpha|  1 + 1 = 2$. Since the sum is finite, the impulse response $g[n]$ is absolutely summable, and the inverse system is stable.\n\nFinally, we must verify the result $(h*g)[n] = \\delta[n]$ by direct evaluation of the convolution sum in the time domain.\n$$ (h*g)[n] = \\sum_{k=-\\infty}^{\\infty} h[k] g[n-k] $$\nSubstitute the expressions for $h[k] = \\alpha^k u[k]$ and $g[n-k] = \\delta[n-k] - \\alpha \\delta[n-k-1]$:\n$$ (h*g)[n] = \\sum_{k=-\\infty}^{\\infty} (\\alpha^k u[k]) (\\delta[n-k] - \\alpha \\delta[n-k-1]) $$\nBy linearity of summation, we can split this into two sums:\n$$ (h*g)[n] = \\sum_{k=-\\infty}^{\\infty} \\alpha^k u[k] \\delta[n-k] - \\alpha \\sum_{k=-\\infty}^{\\infty} \\alpha^k u[k] \\delta[n-k-1] $$\nWe evaluate each sum using the sifting property of the Kronecker delta, which states that $\\sum_k f[k]\\delta[k-k_0] = f[k_0]$.\nFor the first sum, the delta function $\\delta[n-k]$ is non-zero only when $k=n$. Applying the sifting property:\n$$ \\sum_{k=-\\infty}^{\\infty} \\alpha^k u[k] \\delta[n-k] = \\alpha^n u[n] $$\nFor the second sum, the delta function $\\delta[n-k-1]$ is non-zero only when $k=n-1$. Applying the sifting property:\n$$ \\sum_{k=-\\infty}^{\\infty} \\alpha^k u[k] \\delta[n-k-1] = \\alpha^{n-1} u[n-1] $$\nSubstituting these results back into the expression for the convolution:\n$$ (h*g)[n] = \\alpha^n u[n] - \\alpha (\\alpha^{n-1} u[n-1]) = \\alpha^n u[n] - \\alpha^n u[n-1] $$\nNow, we must analyze this result for all integer values of $n$.\nCase 1: $n  0$.\nIn this case, $u[n] = 0$ and $u[n-1] = 0$.\n$(h*g)[n] = \\alpha^n (0) - \\alpha^n (0) = 0$.\n\nCase 2: $n = 0$.\nIn this case, $u[0] = 1$ and $u[-1] = 0$.\n$(h*g)[0] = \\alpha^0 u[0] - \\alpha^0 u[-1] = 1 \\cdot 1 - 1 \\cdot 0 = 1$.\n\nCase 3: $n  0$.\nIn this case, $u[n] = 1$ and $u[n-1] = 1$.\n$(h*g)[n] = \\alpha^n (1) - \\alpha^n (1) = 0$.\n\nComparing these results with the definition of the Kronecker delta $\\delta[n]$:\n$$ \\delta[n] = \\begin{cases} 1,  n=0 \\\\ 0,  n \\neq 0 \\end{cases} $$\nOur evaluated convolution $(h*g)[n]$ matches $\\delta[n]$ for all $n$. The verification is complete and successful. The determined impulse response $g[n]$ is correct.", "answer": "$$\n\\boxed{\\delta[n] - \\alpha \\delta[n-1]}\n$$", "id": "2909246"}, {"introduction": "Having established the principle in the discrete-time domain, we now turn our attention to its continuous-time counterpart. This practice involves a first-order continuous-time LTI system, requiring the use of the Laplace transform to determine its causal inverse. The exercise places special emphasis on the interplay between pole locations, the Region of Convergence (ROC), and the resulting properties of causality and BIBO stability, which are critical for designing physically realizable and well-behaved systems [@problem_id:2909256].", "problem": "Consider a continuous-time, linear time-invariant (LTI) system with rational transfer function $H(s)$ defined on the bilateral Laplace-transform domain, where the bilateral Laplace transform of a signal $x(t)$ is $X(s)=\\int_{-\\infty}^{\\infty} x(t)\\exp(-st)\\,dt$ with a region of convergence (ROC) that ensures the integral exists. A system is invertible if there exists another LTI system with transfer function $H_{\\mathrm{inv}}(s)$ such that $H_{\\mathrm{inv}}(s)H(s)=1$ on a common ROC. For a rational $H(s)$, causality of the corresponding impulse response $h(t)$ is characterized by an ROC that is a right half-plane to the right of the rightmost pole. Bounded-input bounded-output (BIBO) stability for a rational LTI system is equivalent to the ROC including the imaginary axis $s=\\mathrm{j}\\omega$ (i.e., all poles in the open left-half plane and a causal ROC).\n\nGiven the minimum-phase, strictly proper numerator and proper denominator system\n$$\nH(s)=\\frac{s+1}{s+2},\n$$\ndo the following:\n\n1. Determine a causal inverse transfer function $H_{\\mathrm{inv}}(s)$ satisfying $H_{\\mathrm{inv}}(s)H(s)=1$ on a ROC that renders the inverse system causal. State the ROC you select for causality and justify it from first principles.\n\n2. Compute the corresponding causal impulse response $h_{\\mathrm{inv}}(t)$ of the inverse system by inverse Laplace transformation in the sense of distributions, explicitly indicating any singular components.\n\n3. Using the bounded-input bounded-output (BIBO) stability definition and its equivalence for rational LTI systems, assess whether the causal inverse is BIBO-stable. Support your conclusion from the pole-zero locations and ROC considerations.\n\nProvide your final answer as a single row matrix using the $\\texttt{pmatrix}$ environment with three entries in this exact order:\n- $H_{\\mathrm{inv}}(s)$,\n- $h_{\\mathrm{inv}}(t)$,\n- $I_{\\mathrm{stab}}$, where $I_{\\mathrm{stab}}=1$ if the causal inverse is BIBO-stable and $I_{\\mathrm{stab}}=0$ otherwise.\n\nNo numerical rounding is required. Do not include any units in the final answer.", "solution": "The problem statement has been subjected to rigorous validation and is deemed to be scientifically grounded, well-posed, and objective. It presents a standard exercise in the analysis of linear time-invariant (LTI) systems. While the descriptive language contains minor non-standard phrasing—specifically, referring to a proper system with degree-one numerator and denominator as having a \"strictly proper numerator and proper denominator\"—this imprecision does not create a logical contradiction or impede the solvability of the problem, as the mathematical definition of the system $H(s) = \\frac{s+1}{s+2}$ is unambiguous. We may therefore proceed with the solution.\n\nThe problem requires a three-part analysis of the inverse of a given LTI system.\n\n1.  To determine the inverse transfer function $H_{\\mathrm{inv}}(s)$, we use the definition of invertibility, which requires that $H_{\\mathrm{inv}}(s)H(s) = 1$. Given the system transfer function $H(s) = \\frac{s+1}{s+2}$, the inverse is found by algebraic manipulation:\n    $$\n    H_{\\mathrm{inv}}(s) = \\frac{1}{H(s)} = \\frac{1}{\\frac{s+1}{s+2}} = \\frac{s+2}{s+1}\n    $$\n    This is an improper rational function, as the degree of the numerator polynomial is equal to the degree of the denominator polynomial (both are degree $1$). To facilitate inverse transformation, we perform polynomial long division:\n    $$\n    H_{\\mathrm{inv}}(s) = \\frac{(s+1)+1}{s+1} = \\frac{s+1}{s+1} + \\frac{1}{s+1} = 1 + \\frac{1}{s+1}\n    $$\n    This transfer function has a single pole at $s = -1$. According to the principles of LTI system theory, a system is causal if and only if its impulse response $h(t)$ is zero for all $t  0$. For a system with a rational transfer function, this property corresponds to a region of convergence (ROC) that is a right half-plane extending to the right of the rightmost pole. The rightmost (and only) pole of $H_{\\mathrm{inv}}(s)$ is at $s = -1$. Therefore, for the inverse system to be causal, its ROC must be the set of all complex numbers $s$ such that its real part is greater than $-1$. The ROC is $\\text{Re}\\{s\\}  -1$.\n\n2.  To compute the causal impulse response $h_{\\mathrm{inv}}(t)$, we must find the inverse Laplace transform of $H_{\\mathrm{inv}}(s) = 1 + \\frac{1}{s+1}$ corresponding to the causal ROC, $\\text{Re}\\{s\\}  -1$. The inverse Laplace transform is a linear operator. We consider each term separately.\n    The constant term, $1$, is the Laplace transform of the Dirac delta distribution, $\\delta(t)$. The ROC for this transform pair is the entire complex plane, so it is consistent with the causal ROC $\\text{Re}\\{s\\}  -1$.\n    $$\n    \\mathcal{L}^{-1}\\{1\\} = \\delta(t)\n    $$\n    The second term, $\\frac{1}{s+1}$, corresponds to a pole at $s = -1$. For the causal ROC $\\text{Re}\\{s\\}  -1$, the inverse transform is a right-sided exponential function. This is a standard transform pair:\n    $$\n    \\mathcal{L}^{-1}\\left\\{\\frac{1}{s+a}\\right\\} = \\exp(-at)u(t) \\quad \\text{for ROC } \\text{Re}\\{s\\}  -\\text{Re}\\{a\\}\n    $$\n    Here, $a=1$, and the ROC $\\text{Re}\\{s\\}  -1$ correctly corresponds to the causal signal. Thus:\n    $$\n    \\mathcal{L}^{-1}\\left\\{\\frac{1}{s+1}\\right\\} = \\exp(-t)u(t)\n    $$\n    where $u(t)$ is the Heaviside unit step function. Combining the two parts, the complete impulse response of the causal inverse system is:\n    $$\n    h_{\\mathrm{inv}}(t) = \\delta(t) + \\exp(-t)u(t)\n    $$\n    The term $\\delta(t)$ is the singular component of the impulse response, which arises because the inverse system is proper but not strictly proper.\n\n3.  To assess the bounded-input bounded-output (BIBO) stability of the causal inverse system, we use the condition provided: the system's ROC must include the imaginary axis, $s = \\mathrm{j}\\omega$, which is the line $\\text{Re}\\{s\\} = 0$ in the complex plane.\n    The ROC for the causal inverse system was determined to be $\\text{Re}\\{s\\}  -1$. This region is the open half-plane to the right of the vertical line at $\\text{Re}\\{s\\} = -1$. Since $0  -1$, the imaginary axis ($\\text{Re}\\{s\\} = 0$) is entirely contained within this ROC. Therefore, the causal inverse system is BIBO-stable.\n    This conclusion is corroborated by analyzing the pole locations. For a causal LTI system, BIBO stability is equivalent to the condition that all poles lie in the open left-half complex plane (i.e., $\\text{Re}\\{p_k\\}  0$ for all poles $p_k$). The only pole of $H_{\\mathrm{inv}}(s)$ is at $s = -1$. Since $\\text{Re}\\{-1\\} = -1  0$, the pole is in the open left-half plane. This confirms that the causal inverse system is indeed BIBO-stable. The stability indicator is therefore $I_{\\mathrm{stab}} = 1$.\n\nThe three required components are thus: $H_{\\mathrm{inv}}(s) = \\frac{s+2}{s+1}$, $h_{\\mathrm{inv}}(t) = \\delta(t) + \\exp(-t)u(t)$, and $I_{\\mathrm{stab}} = 1$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{s+2}{s+1}  \\delta(t) + \\exp(-t)u(t)  1\n\\end{pmatrix}\n}\n$$", "id": "2909256"}, {"introduction": "Our final practice tackles a significant real-world challenge: the inversion of nonminimum-phase systems, where a direct causal inverse would be unstable. This advanced computational exercise guides you through the implementation of the stable inversion technique, a sophisticated method that decomposes the inverse into stable causal and anti-causal parts. By addressing the practical need for a finite 'preview' of the signal, this problem bridges the gap between theoretical concepts and their robust numerical application in fields like control and signal processing [@problem_id:2909240].", "problem": "You are given discrete-time, single-input single-output linear time-invariant systems characterized by transfer functions in the complex $z$-domain of the form $H(z) = \\dfrac{B(z)}{A(z)}$, where $A(z)$ and $B(z)$ are polynomials in $z^{-1}$ with real coefficients and leading coefficient $1$. A system is called minimum-phase if all zeros of $H(z)$ lie strictly inside the unit circle, nonminimum-phase if at least one zero lies strictly outside the unit circle, and Bounded-Input Bounded-Output (BIBO) stable if all poles lie strictly inside the unit circle. For such systems, classical causal inversion fails to be BIBO stable when zeros lie outside the unit circle. The stable inversion technique leverages the fact that the inverse corresponding to the nonminimum-phase zeros is anti-causal but stable in backward time, which can be implemented using a finite preview of the desired output to approximate the noncausal inverse.\n\nStarting from the fundamental definitions of convolution and invertibility of linear time-invariant systems in the $z$-domain, and the classification of zeros and poles by their location relative to the unit circle, design and implement a program that performs the following tasks:\n\n- For each system specified in the test suite below, compute the stable inverse input sequence $u[n]$ that produces a given finite-length desired output sequence $y_{\\mathrm{d}}[n]$, using a preview-based implementation of the stable inversion technique. You must:\n  - Factor the numerator polynomial $B(z)$ into two polynomials $B_{\\min}(z)$ and $B_{\\mathrm{nmp}}(z)$, where $B_{\\min}(z)$ contains the zeros strictly inside the unit circle and $B_{\\mathrm{nmp}}(z)$ contains the zeros strictly outside the unit circle.\n  - Construct a causal, BIBO-stable component $G_{\\mathrm{c}}(z) = \\dfrac{A(z)}{B_{\\min}(z)}$ and an anti-causal, backward-time-stable component $G_{\\mathrm{a}}(z) = \\dfrac{1}{B_{\\mathrm{nmp}}(z)}$ so that the overall inverse is $H^{-1}(z) = G_{\\mathrm{c}}(z) \\, G_{\\mathrm{a}}(z)$.\n  - Implement $G_{\\mathrm{a}}(z)$ using time reversal and a finite preview of length $L$ samples. Specifically, assume the desired output beyond the available horizon is zero and use $L$ samples of preview to approximate the anti-causal inverse. Then apply the causal stable filter $G_{\\mathrm{c}}(z)$ to complete the inversion.\n- For each system, quantify the minimal preview length $L_{\\min}$ (an integer number of samples) needed to guarantee that the maximum absolute difference between the preview-limited inverse input and a reference inverse input (computed with a sufficiently large preview) is no greater than a given tolerance $\\varepsilon$.\n\nUse the following desired output and test suite. Angles must be in radians. The desired output is a finite-length signal defined for $n \\in \\{0,1,\\dots,T-1\\}$ with $T = 256$ by\n$$\ny_{\\mathrm{d}}[n] = \\sin(2\\pi f_1 n) + 0.5 \\sin(2\\pi f_2 n + \\varphi),\n$$\nwith $f_1 = 0.05$, $f_2 = 0.12$, and $\\varphi = 0.3$. Outside this interval, the desired output is assumed to be zero.\n\nTest suite (each test case consists of the numerator and denominator polynomials written as coefficient arrays of $z^{-1}$ with leading coefficient equal to $1$, and the tolerance $\\varepsilon$):\n- Case A: $B_{\\mathrm{A}}(z) = 1 - 1.5 z^{-1}$, $A_{\\mathrm{A}}(z) = 1 - 0.5 z^{-1}$, $\\varepsilon_{\\mathrm{A}} = 10^{-4}$.\n- Case B: $B_{\\mathrm{B}}(z) = 1 - 0.3 z^{-1}$, $A_{\\mathrm{B}}(z) = 1 - 0.5 z^{-1}$, $\\varepsilon_{\\mathrm{B}} = 10^{-6}$.\n- Case C: $B_{\\mathrm{C}}(z) = 1 - 2.45 z^{-1} + 1.5 z^{-2}$, $A_{\\mathrm{C}}(z) = 1 - 1.3 z^{-1} + 0.42 z^{-2}$, $\\varepsilon_{\\mathrm{C}} = 10^{-4}$.\n- Case D: $B_{\\mathrm{D}}(z) = 1 - 1.5 z^{-1} + 0.44 z^{-2}$, $A_{\\mathrm{D}}(z) = 1 - 1.1 z^{-1} + 0.18 z^{-2}$, $\\varepsilon_{\\mathrm{D}} = 10^{-4}$.\n\nDefinitions and constraints to be respected in your implementation:\n- Polynomial factorization must be performed by finding the zeros of $B(z)$, classifying them by magnitude relative to the unit circle, reconstructing $B_{\\min}(z)$ and $B_{\\mathrm{nmp}}(z)$, and preserving the leading coefficient $1$ normalization in the $z^{-1}$ representation.\n- The causal component $G_{\\mathrm{c}}(z)$ must be implemented as a stable causal linear time-invariant filter applied in the forward time direction.\n- The anti-causal component $G_{\\mathrm{a}}(z)$ must be implemented by reversing time, applying a stable causal filter in the reversed domain, and reversing back. A finite preview length $L$ corresponds to appending $L$ zeros to the desired output before performing the reversed-domain causal filtering.\n- The reference inverse for error evaluation must be computed using a sufficiently large preview length $L_{\\mathrm{ref}}$ chosen so that further increases in preview do not change the result to within numerical precision. You must use the same $L_{\\mathrm{ref}}$ for all cases.\n\nYour program must, for each case, search for the smallest integer preview length $L_{\\min} \\in \\{0,1,2,\\dots,L_{\\mathrm{ref}}\\}$ such that the maximum absolute error between the inverse input computed with preview length $L_{\\min}$ and the reference inverse input is less than or equal to $\\varepsilon$ across all $n \\in \\{0,1,\\dots,T-1\\}$. If no such $L_{\\min}$ exists up to $L_{\\mathrm{ref}}$, report $L_{\\min} = L_{\\mathrm{ref}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[L_{\\min,\\mathrm{A}},L_{\\min,\\mathrm{B}},L_{\\min,\\mathrm{C}},L_{\\min,\\mathrm{D}}]$.", "solution": "The user has provided a valid problem statement. It is scientifically grounded in the principles of digital signal processing, well-posed, and objective. All necessary data and definitions are provided, and the constraints are consistent. The task is to design and implement a program for stable inversion of linear time-invariant (LTI) systems and to determine the minimal preview length required for a given accuracy.\n\nThe core of the problem lies in inverting a nonminimum-phase system in a stable manner. A system with transfer function $H(z)$ is nonminimum-phase if its transfer function $H(z)$ has at least one zero $z_0$ such that $|z_0|  1$. A direct causal inverse $H^{-1}(z)$ would have a pole at $z_0$, located outside the unit circle, rendering the inverse filter Bounded-Input Bounded-Output (BIBO) unstable. The technique of stable inversion overcomes this by implementing the unstable part of the inverse filter anti-causally.\n\nThe overall procedure is as follows:\n\n1.  **System Decomposition**: The transfer function's numerator polynomial, $B(z)$, is factored into its minimum-phase and nonminimum-phase components.\n    $$\n    B(z) = B_{\\min}(z) B_{\\mathrm{nmp}}(z)\n    $$\n    This factorization is achieved by finding the roots of $B(z)$, which are the zeros of the system $H(z)$. The zeros are classified based on their magnitude relative to the unit circle.\n    - Zeros $z_i$ with $|z_i|  1$ are minimum-phase. The polynomial $B_{\\min}(z)$ is constructed from these zeros.\n    - Zeros $z_j$ with $|z_j|  1$ are nonminimum-phase. The polynomial $B_{\\mathrm{nmp}}(z)$ is constructed from these zeros.\n    Given that the original polynomial $B(z)$ has real coefficients, any complex roots will appear in conjugate pairs, ensuring that the resulting polynomials $B_{\\min}(z)$ and $B_{\\mathrm{nmp}}(z)$ also have real coefficients.\n\n2.  **Inverse System Construction**: The inverse system $H^{-1}(z)$ is split into two components:\n    $$\n    H^{-1}(z) = \\frac{A(z)}{B(z)} = \\frac{A(z)}{B_{\\min}(z)} \\cdot \\frac{1}{B_{\\mathrm{nmp}}(z)} = G_{\\mathrm{c}}(z) G_{\\mathrm{a}}(z)\n    $$\n    - The causal component, $G_{\\mathrm{c}}(z) = \\frac{A(z)}{B_{\\min}(z)}$, is BIBO stable because its poles (the zeros of $B_{\\min}(z)$) all lie inside the unit circle. It can be implemented using a standard forward-time recursive filter.\n    - The anti-causal component, $G_{\\mathrm{a}}(z) = \\frac{1}{B_{\\mathrm{nmp}}(z)}$, has poles corresponding to the nonminimum-phase zeros of $H(z)$, which lie outside the unit circle. A causal implementation would be unstable. However, a stable anti-causal implementation is possible.\n\n3.  **Anti-Causal Filtering Implementation**: The stable implementation of $G_{\\mathrm{a}}(z)$ is achieved through time reversal. Filtering a sequence $x[n]$ with an anti-causal filter $G_{\\mathrm{a}}(z)$ is equivalent to performing the following three steps:\n    a. Time-reversing the input signal: $x_{\\mathrm{rev}}[n] = x[-n]$.\n    b. Filtering $x_{\\mathrm{rev}}[n]$ with a causal, stable filter $F(z) = G_{\\mathrm{a}}(1/z)$.\n    c. Time-reversing the output of the filter.\n\n    The transfer function of the reversed filter is $F(z) = 1 / B_{\\mathrm{nmp}}(1/z)$. If $z_j$ is a root of $B_{\\mathrm{nmp}}(z)$ with $|z_j|  1$, then $1/z_j$ is a root of $B_{\\mathrm{nmp}}(1/z)$ with $|1/z_j|  1$. Consequently, all poles of $F(z)$ are inside the unit circle, making it a stable, causal filter. The denominator polynomial of $F(z)$ is constructed from the set of roots $\\{1/z_j\\}$, where $\\{z_j\\}$ are the nonminimum-phase zeros of the original system.\n\n4.  **Finite Preview Approximation**: In practice, we operate on finite-length signals. The desired output $y_{\\mathrm{d}}[n]$ is given for $n \\in \\{0, 1, \\dots, T-1\\}$ and is assumed to be zero otherwise. The anti-causal filtering step requires future values of the signal. We approximate this by using a finite preview of length $L$, effectively operating on a signal composed of $y_{\\mathrm{d}}[n]$ followed by $L$ zero-valued samples. The error resulting from this truncation diminishes as $L$ increases. The rate of error decay depends on the impulse response of the reversed filter $F(z)$, which is determined by the pole of $F(z)$ with the largest magnitude, i.e., $\\max_j |1/z_j| = 1/\\min_j |z_j|$.\n\n5.  **Computation of Minimal Preview Length $L_{\\min}$**: To find the minimal preview length $L_{\\min}$ that achieves a specified accuracy $\\varepsilon$, we perform the following steps for each test case:\n    a. A reference input sequence, $u_{\\mathrm{ref}}[n]$, is computed using a sufficiently large preview length, $L_{\\mathrm{ref}}$, chosen to ensure the truncation error is negligible. A value of $L_{\\mathrm{ref}} = 500$ is chosen, as it is significantly larger than the expected time constants of the anti-causal dynamics in all test cases.\n    b. The input sequence $u_L[n]$ is computed for increasing preview lengths $L = 0, 1, 2, \\dots$.\n    c. For each $L$, the maximum absolute error is calculated over the interval of interest:\n       $$\n       E_L = \\max_{n \\in \\{0, \\dots, T-1\\}} |u_L[n] - u_{\\mathrm{ref}}[n]|\n       $$\n    d. The minimal preview length $L_{\\min}$ is the smallest integer $L$ for which $E_L \\le \\varepsilon$. If this condition is not met for any $L \\le L_{\\mathrm{ref}}$, $L_{\\min}$ is reported as $L_{\\mathrm{ref}}$.\n\nThe implementation will utilize `numpy` for polynomial operations (finding roots via `numpy.roots` and reconstructing polynomials via `numpy.poly`) and `scipy.signal.lfilter` for the implementation of the causal digital filters. For a nonminimum-phase system, the overall signal flow to compute the input $u[n]$ from the desired output $y_{\\mathrm{d}}[n]$ is:\n$$\ny_{\\mathrm{d}}[n] \\xrightarrow{\\text{Pad with } L \\text{ zeros}} \\xrightarrow{\\text{Time Reversal}} \\xrightarrow{\\text{Filter with } F(z)} \\xrightarrow{\\text{Time Reversal}} y_{\\mathrm{c}}[n] \\xrightarrow{\\text{Filter with } G_{\\mathrm{c}}(z)} u[n]\n$$\nFor a minimum-phase system, the anti-causal filtering stage is an identity operation, and $L_{\\min}$ is expected to be $0$.", "answer": "```python\nimport numpy as np\nfrom scipy import signal\n\ndef calculate_inverse_input(y_d, preview_L, b_coeffs, a_coeffs):\n    \"\"\"\n    Computes the stable inverse input for a given LTI system and desired output.\n\n    Args:\n        y_d (np.ndarray): The desired output sequence.\n        preview_L (int): The number of preview samples.\n        b_coeffs (np.ndarray): Numerator coefficients of the system H(z).\n        a_coeffs (np.ndarray): Denominator coefficients of the system H(z).\n\n    Returns:\n        np.ndarray: The computed stable inverse input sequence.\n    \"\"\"\n    # Step 1: Factor the numerator B(z) into minimum and non-minimum phase parts.\n    zeros = np.roots(b_coeffs)\n    min_phase_zeros = zeros[np.abs(zeros)  1.0]\n    non_min_phase_zeros = zeros[np.abs(zeros)  1.0]\n\n    b_min_coeffs = np.poly(min_phase_zeros).real if len(min_phase_zeros)  0 else np.array([1.0])\n\n    # Step 2: Apply the anti-causal filter G_a(z) = 1/B_nmp(z).\n    # This is implemented using time reversal.\n    y_extended = np.concatenate((y_d, np.zeros(preview_L)))\n\n    if len(non_min_phase_zeros)  0:\n        # The reversed filter F(z)=G_a(1/z) has poles at 1/z_j, which are stable.\n        reversed_poles = 1.0 / non_min_phase_zeros\n        a_rev = np.poly(reversed_poles).real\n\n        # Implement G_a(z) via time-reversal and filtering with F(z).\n        y_rev = y_extended[::-1]\n        w_rev = signal.lfilter([1.0], a_rev, y_rev)\n        y_c = w_rev[::-1]\n    else:\n        # If the system is minimum-phase, G_a(z) is identity.\n        y_c = y_extended\n\n    # Step 3: Apply the causal filter G_c(z) = A(z)/B_min(z).\n    u = signal.lfilter(a_coeffs, b_min_coeffs, y_c)\n\n    return u\n\ndef find_min_preview_length(y_d, b_coeffs, a_coeffs, epsilon, L_ref):\n    \"\"\"\n    Finds the minimum preview length L_min to meet a given error tolerance.\n\n    Args:\n        y_d (np.ndarray): The desired output sequence.\n        b_coeffs (np.ndarray): Numerator coefficients.\n        a_coeffs (np.ndarray): Denominator coefficients.\n        epsilon (float): The error tolerance.\n        L_ref (int): The reference preview length.\n\n    Returns:\n        int: The minimum required preview length L_min.\n    \"\"\"\n    T = len(y_d)\n\n    # If the system is minimum-phase, no preview is needed.\n    zeros = np.roots(b_coeffs)\n    if not np.any(np.abs(zeros)  1.0):\n        return 0\n\n    # Compute the reference input using a large preview length L_ref.\n    u_ref = calculate_inverse_input(y_d, L_ref, b_coeffs, a_coeffs)\n\n    # Search for the minimum L that satisfies the error criterion.\n    for L in range(L_ref + 1):\n        u_L = calculate_inverse_input(y_d, L, b_coeffs, a_coeffs)\n\n        # The error is the max absolute difference over the original signal duration.\n        error = np.max(np.abs(u_L[:T] - u_ref[:T]))\n\n        if error = epsilon:\n            return L\n\n    # If tolerance is not met, return L_ref.\n    return L_ref\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the final results.\n    \"\"\"\n    # Define desired output signal parameters\n    T = 256\n    f1 = 0.05\n    f2 = 0.12\n    phi = 0.3\n    n = np.arange(T)\n    y_d = np.sin(2 * np.pi * f1 * n) + 0.5 * np.sin(2 * np.pi * f2 * n + phi)\n\n    # Define test suite\n    test_cases = [\n        # Case A: Nonminimum-phase (1 zero outside unit circle)\n        {'b': np.array([1.0, -1.5]), 'a': np.array([1.0, -0.5]), 'eps': 1e-4},\n        # Case B: Minimum-phase\n        {'b': np.array([1.0, -0.3]), 'a': np.array([1.0, -0.5]), 'eps': 1e-6},\n        # Case C: Nonminimum-phase (2 zeros outside unit circle)\n        {'b': np.array([1.0, -2.45, 1.5]), 'a': np.array([1.0, -1.3, 0.42]), 'eps': 1e-4},\n        # Case D: Mixed-phase (1 zero inside, 1 zero outside unit circle)\n        {'b': np.array([1.0, -1.5, 0.44]), 'a': np.array([1.0, -1.1, 0.18]), 'eps': 1e-4},\n    ]\n\n    # Reference preview length, chosen to be sufficiently large for all cases.\n    L_ref = 500\n\n    results = []\n    for case in test_cases:\n        L_min = find_min_preview_length(y_d, case['b'], case['a'], case['eps'], L_ref)\n        results.append(L_min)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2909240"}]}