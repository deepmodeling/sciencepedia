{"hands_on_practices": [{"introduction": "The Butterworth filter serves as a cornerstone of analog and digital filter design due to its maximally flat passband response. This first exercise provides fundamental practice in translating frequency-domain specifications, such as passband and stopband attenuation, directly into the filter's defining parameters: its order $n$ and cutoff frequency $\\Omega_c$. By working through this analytical design [@problem_id:2871002], you will also uncover the practical impact of the constraint that filter order must be an integer, revealing how this creates a performance margin.", "problem": "A continuous-time, Linear Time-Invariant (LTI) lowpass filter is to be designed from a normalized Butterworth prototype with passband edge at angular frequency $\\Omega_{p} = 1$ and unknown order $n \\in \\mathbb{N}$ and cutoff $\\Omega_{c} gt; 0$. The specifications are given in terms of passband and stopband attenuations in decibels (dB): at $\\Omega=\\Omega_{p}$ the attenuation must not exceed $A_{p}$, and at the stopband frequency $\\Omega=\\Omega_{s}$ the attenuation must be at least $A_{s}$. The Butterworth magnitude-squared response is defined by\n$$\n|H(j\\Omega)|^{2} \\;=\\; \\frac{1}{1 + \\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2n}} \\, ,\n$$\nand attenuation is defined by\n$$\nA(\\Omega) \\;=\\; -20 \\log_{10}\\big(|H(j\\Omega)|\\big) \\, .\n$$\n\n(a) Starting from these definitions, derive explicit expressions for the real-valued order $n^{\\star}$ and cutoff $\\Omega_{c}$ in terms of $A_{p}$, $A_{s}$, and $\\Omega_{s}$ that simultaneously satisfy equality at the passband edge $\\Omega=\\Omega_{p}$ and the stopband inequality at $\\Omega=\\Omega_{s}$.\n\n(b) Enforce the integer-order constraint by choosing the minimal integer $n=\\lceil n^{\\star}\\rceil$ and reselect $\\Omega_{c}$ so that the passband-edge attenuation at $\\Omega=\\Omega_{p}$ exactly equals $A_{p}$. With this integer $n$, quantify the resulting realized stopband attenuation at $\\Omega=\\Omega_{s}$ and hence the margin induced by integer rounding.\n\nUse the concrete specifications $A_{p}=1$ (in dB), $A_{s}=50$ (in dB), and $\\Omega_{s}=2.5$. Your final answer must be the realized stopband attenuation at $\\Omega=\\Omega_{s}$, expressed in decibels (dB) and rounded to four significant figures.", "solution": "We begin from the definition of the Butterworth prototype magnitude-squared response,\n$$\n|H(j\\Omega)|^{2} \\;=\\; \\frac{1}{1 + \\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2n}} \\, ,\n$$\nand the attenuation in decibels,\n$$\nA(\\Omega) \\;=\\; -20 \\log_{10}\\big(|H(j\\Omega)|\\big) \\, .\n$$\nSubstituting the magnitude expression gives\n$$\nA(\\Omega) \\;=\\; -20 \\log_{10}\\!\\left(\\frac{1}{\\sqrt{1+\\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2n}}}\\right)\n\\;=\\; 20 \\log_{10}\\!\\left(\\sqrt{1+\\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2n}}\\right)\n\\;=\\; 10 \\log_{10}\\!\\left(1+\\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2n}\\right).\n$$\n\nAt the passband edge $\\Omega=\\Omega_{p}$, the specification is that the attenuation does not exceed $A_{p}$. For the tightest design, we impose equality at $\\Omega=\\Omega_{p}$, which yields\n$$\nA(\\Omega_{p}) \\;=\\; A_{p}\n\\;\\;\\Longrightarrow\\;\\;\n10 \\log_{10}\\!\\left(1+\\left(\\frac{\\Omega_{p}}{\\Omega_{c}}\\right)^{2n}\\right) \\;=\\; A_{p}.\n$$\nDefine the standard ripple parameter\n$$\n\\varepsilon^{2} \\;\\triangleq\\; 10^{A_{p}/10} - 1,\n$$\nwhich is strictly positive for $A_{p}0$. Then the passband-edge equality gives\n$$\n\\left(\\frac{\\Omega_{p}}{\\Omega_{c}}\\right)^{2n} \\;=\\; \\varepsilon^{2}\n\\;\\;\\Longrightarrow\\;\\;\n\\Omega_{c} \\;=\\; \\Omega_{p}\\,\\varepsilon^{-1/n}.\n$$\nWith the normalized choice $\\Omega_{p}=1$, this simplifies to\n$$\n\\Omega_{c} \\;=\\; \\varepsilon^{-1/n}.\n$$\n\nAt the stopband frequency $\\Omega=\\Omega_{s}$ the specification is $A(\\Omega_{s}) \\ge A_{s}$. Substituting the passband-determined relation, we obtain\n$$\nA(\\Omega_{s})\n\\;=\\;\n10 \\log_{10}\\!\\left(1+\\left(\\frac{\\Omega_{s}}{\\Omega_{c}}\\right)^{2n}\\right)\n\\;=\\;\n10 \\log_{10}\\!\\left(1+\\Omega_{s}^{2n}\\left(\\frac{1}{\\Omega_{c}}\\right)^{2n}\\right)\n\\;=\\;\n10 \\log_{10}\\!\\left(1+\\varepsilon^{2}\\,\\Omega_{s}^{2n}\\right).\n$$\nThe stopband inequality $A(\\Omega_{s}) \\ge A_{s}$ is therefore equivalent to\n$$\n10 \\log_{10}\\!\\left(1+\\varepsilon^{2}\\,\\Omega_{s}^{2n}\\right) \\;\\ge\\; A_{s}\n\\;\\;\\Longleftrightarrow\\;\\;\n1+\\varepsilon^{2}\\,\\Omega_{s}^{2n} \\;\\ge\\; 10^{A_{s}/10}\n\\;\\;\\Longleftrightarrow\\;\\;\n\\varepsilon^{2}\\,\\Omega_{s}^{2n} \\;\\ge\\; 10^{A_{s}/10} - 1.\n$$\nSolving for the real-valued order gives\n$$\nn^{\\star}\n\\;=\\;\n\\frac{\\ln\\!\\left(\\frac{10^{A_{s}/10}-1}{\\varepsilon^{2}}\\right)}{2\\,\\ln(\\Omega_{s})}\n\\;=\\;\n\\frac{\\ln\\!\\left(10^{A_{s}/10}-1\\right) - \\ln\\!\\left(10^{A_{p}/10}-1\\right)}{2\\,\\ln(\\Omega_{s})}.\n$$\nThis completes part (a): for any given $A_{p}$, $A_{s}$, and $\\Omega_{s}$ with $\\Omega_{p}=1$, we have\n$$\nn^{\\star} \\;=\\; \\frac{\\ln\\!\\left(\\frac{10^{A_{s}/10}-1}{10^{A_{p}/10}-1}\\right)}{2\\,\\ln(\\Omega_{s})},\n\\qquad\n\\Omega_{c} \\;=\\; \\varepsilon^{-1/n},\\;\\;\\text{with}\\;\\; \\varepsilon^{2}=10^{A_{p}/10}-1.\n$$\n\nFor part (b), the implementable order is the minimal integer $n=\\lceil n^{\\star}\\rceil$. We then reselect $\\Omega_{c}$ from the passband equality so that $A(\\Omega_{p})=A_{p}$ holds exactly:\n$$\n\\Omega_{c} \\;=\\; \\varepsilon^{-1/n}\n\\;\\;=\\;\\; \\left(10^{A_{p}/10}-1\\right)^{-1/(2n)}.\n$$\nWith this integer-order design, the realized stopband attenuation at $\\Omega=\\Omega_{s}$ is\n$$\nA_{\\text{real}}(\\Omega_{s})\n\\;=\\;\n10 \\log_{10}\\!\\left(1+\\varepsilon^{2}\\,\\Omega_{s}^{2n}\\right),\n$$\nwhich generally exceeds $A_{s}$ because $n$ was rounded up.\n\nWe now specialize to the numerical specifications $A_{p}=1$ (in dB), $A_{s}=50$ (in dB), and $\\Omega_{s}=2.5$, with $\\Omega_{p}=1$.\n\nCompute the ripple parameter:\n$$\n\\varepsilon^{2} \\;=\\; 10^{A_{p}/10}-1 \\;=\\; 10^{0.1}-1 \\;=\\; 1.2589254117941673 - 1 \\;=\\; 0.2589254117941673.\n$$\nCompute the real-valued order:\n$$\nn^{\\star}\n\\;=\\;\n\\frac{\\ln\\!\\left(10^{50/10}-1\\right) - \\ln\\!\\left(10^{1/10}-1\\right)}{2\\,\\ln(2.5)}\n\\;=\\;\n\\frac{\\ln(99999) - \\ln(0.2589254117941673)}{2\\,\\ln(2.5)}.\n$$\nNumerically,\n$$\n\\ln(99999) \\approx 11.512915464920230,\\quad\n\\ln(0.2589254117941673) \\approx -1.351215541995,\n$$\nso\n$$\nn^{\\star} \\;\\approx\\; \\frac{11.512915464920230 - (-1.351215541995)}{2\\times 0.916290731874155} \\;\\approx\\; \\frac{12.864131006915}{1.83258146374831} \\;\\approx\\; 7.01968.\n$$\nThe minimal integer order is therefore\n$$\nn \\;=\\; \\lceil n^{\\star}\\rceil \\;=\\; 8.\n$$\nReselect the cutoff to meet the passband equality with this $n$:\n$$\n\\Omega_{c} \\;=\\; \\left(10^{A_{p}/10}-1\\right)^{-1/(2n)} \\;=\\; \\left(0.2589254117941673\\right)^{-1/16}.\n$$\nUsing $\\ln\\!\\left(0.2589254117941673\\right)\\approx -1.351215541995$, we obtain\n$$\n\\ln(\\Omega_{c}) \\;=\\; -\\frac{1}{16}\\,\\ln\\!\\left(0.2589254117941673\\right) \\;\\approx\\; 0.0844509713747,\n\\quad\\Rightarrow\\quad\n\\Omega_{c} \\;\\approx\\; \\exp(0.0844509713747) \\;\\approx\\; 1.08806.\n$$\n\nFinally, compute the realized stopband attenuation at $\\Omega_{s}=2.5$ with $n=8$:\n$$\nA_{\\text{real}}(2.5)\n\\;=\\;\n10 \\log_{10}\\!\\left(1+\\varepsilon^{2}\\,(2.5)^{2n}\\right)\n\\;=\\;\n10 \\log_{10}\\!\\left(1+\\big(10^{0.1}-1\\big)\\,(2.5)^{16}\\right).\n$$\nNote that $(2.5)^{16} \\approx 2{,}328{,}306.4365386963$. Therefore\n$$\n\\varepsilon^{2}\\,(2.5)^{16}\n\\;\\approx\\;\n\\left(0.2589254117941673\\right)\\times 2{,}328{,}306.4365386963\n\\;\\approx\\;\n602{,}857.705,\n$$\nand hence\n$$\nA_{\\text{real}}(2.5)\n\\;\\approx\\;\n10 \\log_{10}\\!\\left(1+602{,}857.705\\right)\n\\;=\\;\n10 \\log_{10}\\!\\left(602{,}858.705\\right)\n\\;\\approx\\;\n57.802.\n$$\nRounded to four significant figures, the realized stopband attenuation is $57.80$ (in dB).\n\nThis value exceeds the specified $A_{s}=50$ (in dB) due to $n$ being rounded up from $n^{\\star}\\approx 7.01968$ to $n=8$, illustrating the integer-order rounding margin.", "answer": "$$\\boxed{57.80}$$", "id": "2871002"}, {"introduction": "Moving from classic IIR prototypes to optimal digital FIR filters, we encounter the powerful weighted minimax design methodology, often implemented via the Parks-McClellan algorithm. This practice explores the sophisticated relationship between the desired multi-band ripple specifications $\\{E_{k}^{\\star}\\}$ and the weights $\\{w_{k}\\}$ that guide the optimization process. By deriving an iterative update rule [@problem_id:2871135], you will gain insight into how modern design tools can be programmed to converge precisely on demanding performance targets.", "problem": "Consider the design of a real, linear-phase Finite Impulse Response (FIR) filter of fixed length using a weighted minimax (Chebyshev) formulation over a set of disjoint frequency bands indexed by $k \\in \\{1,\\dots,K\\}$. In band $k$, the desired magnitude response is $D_{k}(\\omega)$ and the weight is a positive constant $w_{k}0$. Let the bandwise maximum magnitude ripple (unweighted) achieved by the minimax design with weights $\\{w_{k}\\}$ be denoted $E_{k}0$, defined as the supremum of the absolute magnitude approximation error over band $k$. A well-tested fact from Chebyshev approximation theory is that at a weighted minimax optimum there exists a common ripple level $\\rho0$ such that the maximum weighted errors are equalized across all bands, i.e., $w_{k} E_{k}=\\rho$ for every $k$.\n\nSuppose a performance specification is given in terms of target ripples $\\{E_{k}^{\\star}\\}_{k=1}^{K}$, with each $E_{k}^{\\star}0$, which the design should achieve in the sense that $E_{k}$ equals $E_{k}^{\\star}$ in every band. However, the initial weights $\\{w_{k}^{(0)}\\}$ are mis-specified, and for iteration index $n \\in \\mathbb{N}$, the exact weighted minimax design computed with $\\{w_{k}^{(n)}\\}$ produces unweighted ripples $\\{E_{k}^{(n)}\\}$ that satisfy the equalization condition $w_{k}^{(n)} E_{k}^{(n)}=\\rho^{(n)}$ for some $\\rho^{(n)}0$.\n\nTasks:\n- Using only the stated equalization property and the positivity of all quantities, derive from first principles why mis-specified weights generally lead to unweighted ripples $\\{E_{k}^{(n)}\\}$ that do not match the targets $\\{E_{k}^{\\star}\\}$, and quantify the mismatch in terms of the weights.\n- Then, by enforcing that the next iterationâ€™s weights should steer the bandwise ripples toward the targets under the same equalization property, derive a multiplicative iterative update for the weights $\\{w_{k}^{(n)}\\}$ that uses only the measured $\\{E_{k}^{(n)}\\}$ and the targets $\\{E_{k}^{\\star}\\}$, and includes a normalization that removes arbitrary overall scaling of the weight vector so that the update has a fixed point at $\\{E_{k}^{\\star}\\}$.\n\nYour final answer must be a single, closed-form analytic expression for the iterative update $w_{k}^{(n+1)}$ in terms of $w_{k}^{(n)}$, $E_{k}^{(n)}$, and $E_{k}^{\\star}$ (and $K$ if your normalization uses it). Do not provide inequalities or equations other than this single update expression. No numerical approximation or rounding is required.", "solution": "The problem asks for an iterative update rule for the weights in a minimax FIR filter design to achieve a set of target ripples $\\{E_k^\\star\\}$. The derivation relies on the fundamental equalization property of minimax designs.\n\n**Part 1: Analysis of Ripple Mismatch**\nAt any iteration $n$, the design is optimal for the weights $\\{w_k^{(n)}\\}$. This optimality is characterized by the equalization condition: the weighted error is constant across all bands.\n$$ w_k^{(n)} E_k^{(n)} = \\rho^{(n)} \\quad \\text{for } k=1, \\dots, K $$\nwhere $E_k^{(n)}$ is the resulting unweighted ripple in band $k$ and $\\rho^{(n)}$ is a positive constant.\n\nThis implies that the ratio of unweighted ripples between any two bands, say $j$ and $k$, is determined entirely by the inverse ratio of their weights:\n$$ \\frac{E_j^{(n)}}{E_k^{(n)}} = \\frac{\\rho^{(n)}/w_j^{(n)}}{\\rho^{(n)}/w_k^{(n)}} = \\frac{w_k^{(n)}}{w_j^{(n)}} $$\nFor the design to meet the target ripple specifications $\\{E_k^\\star\\}$, the weights used must produce these ripples. This means the weights must satisfy the same ratio relationship as the target ripples:\n$$ \\frac{w_k^\\star}{w_j^\\star} = \\frac{E_j^\\star}{E_k^\\star} $$\nIf the initial weights $\\{w_k^{(n)}\\}$ are \"mis-specified\", it means their ratios do not match the inverse ratios of the target ripples, i.e., $\\frac{w_k^{(n)}}{w_j^{(n)}} \\neq \\frac{E_j^\\star}{E_k^\\star}$. As a result, the achieved ripple ratios $\\frac{E_j^{(n)}}{E_k^{(n)}}$ will not match the target ripple ratios $\\frac{E_j^\\star}{E_k^\\star}$.\n\n**Part 2: Derivation of the Iterative Update Rule**\nWe want to find a new set of weights $\\{w_k^{(n+1)}\\}$ that will produce ripples closer to $\\{E_k^\\star\\}$. We can propose a multiplicative update rule that adjusts the current weights based on the observed error.\n$$ w_k^{(n+1)} = C \\cdot w_k^{(n)} \\cdot f(E_k^{(n)}, E_k^\\star) $$\nThe correction function $f$ should increase the weight if the ripple $E_k^{(n)}$ is too large (i.e., $E_k^{(n)}  E_k^\\star$) and decrease it if the ripple is too small. A simple choice for this correction factor is the ratio of the achieved ripple to the target ripple, $E_k^{(n)}/E_k^\\star$. Let's propose an unnormalized update:\n$$ w_{k, \\text{un}}^{(n+1)} = w_k^{(n)} \\frac{E_k^{(n)}}{E_k^\\star} $$\nTo see if this steers the design correctly, we substitute the known relation $w_k^{(n)} = \\rho^{(n)} / E_k^{(n)}$:\n$$ w_{k, \\text{un}}^{(n+1)} = \\left(\\frac{\\rho^{(n)}}{E_k^{(n)}}\\right) \\frac{E_k^{(n)}}{E_k^\\star} = \\frac{\\rho^{(n)}}{E_k^\\star} $$\nThis shows that the updated weights are proportional to $1/E_k^\\star$. This is exactly the property required for the weights to produce the target ripples $\\{E_k^\\star\\}$.\n\nThe final step is to introduce a normalization constant $C$ to prevent the weights from growing or shrinking indefinitely and to ensure a stable fixed point. At a fixed point, $E_k^{(n)} = E_k^\\star$ for all $k$, and we should have $w_k^{(n+1)} = w_k^{(n)}$. Our unnormalized update becomes $w_{k, \\text{un}}^{(n+1)} = w_k^{(n)}$ at the fixed point. A normalization that achieves this behavior is to divide by the geometric mean of the correction factors.\n\nLet the correction factor be $U_k^{(n)} = E_k^{(n)} / E_k^\\star$. The normalization constant $C$ is set to the inverse of the geometric mean of these factors:\n$$ C = \\left( \\prod_{j=1}^{K} U_j^{(n)} \\right)^{-1/K} = \\left( \\prod_{j=1}^{K} \\frac{E_j^{(n)}}{E_j^\\star} \\right)^{-1/K} $$\nCombining the unnormalized update with this normalization constant gives the final iterative update rule:\n$$ w_k^{(n+1)} = w_k^{(n)} \\frac{E_k^{(n)}}{E_k^\\star} \\left( \\prod_{j=1}^{K} \\frac{E_j^{(n)}}{E_j^\\star} \\right)^{-1/K} $$\nThis formula provides a robust method to iteratively refine the weights to meet precise multi-band ripple specifications.", "answer": "$$\n\\boxed{w_{k}^{(n+1)} = w_{k}^{(n)} \\frac{E_{k}^{(n)}}{E_{k}^{\\star}} \\left(\\prod_{j=1}^{K} \\frac{E_{j}^{(n)}}{E_{j}^{\\star}}\\right)^{-1/K}}\n$$", "id": "2871135"}, {"introduction": "A theoretical filter design is only complete once its performance under real-world implementation constraints is verified. This final practice bridges theory and application by investigating the effects of finite-precision arithmetic on filter coefficients. You will implement a Monte Carlo simulation [@problem_id:2871028] to statistically estimate the probability of a quantized filter failing its specifications, a crucial step in predicting manufacturing yield and ensuring robust system performance.", "problem": "You are given a fixed base linear time-invariant (LTI) discrete-time low-pass filter implemented as a finite impulse response (FIR) with tap-length $M$, designed from a windowed ideal impulse response and normalized to unit direct current (DC) gain. The discrete-time frequency response of a filter with impulse response $\\{h[n]\\}_{n=0}^{M-1}$ at normalized frequency $f \\in [0, \\tfrac{1}{2}]$ (cycles per sample) is defined by the Fourier series\n$$\nH(f) \\triangleq \\sum_{n=0}^{M-1} h[n] \\, e^{-j 2 \\pi f n}.\n$$\nFilter design specifications are given in terms of a passband range $[0, f_p]$ and a stopband range $[f_s, \\tfrac{1}{2}]$ together with tolerances for passband ripple and stopband magnitude. Specifically, the passband ripple specification requires that for all $f \\in [0, f_p]$,\n$$\n\\bigl|\\,|H(f)| - 1\\,\\bigr| \\le \\delta_p,\n$$\nand the stopband attenuation specification requires that for all $f \\in [f_s, \\tfrac{1}{2}]$,\n$$\n|H(f)| \\le \\delta_s.\n$$\nConsider an implementation where each coefficient is subject to quantization error modeled as independent and identically distributed random variables. For a fixed bit depth $b \\in \\mathbb{N}$, define the quantization step $\\Delta = 2^{-b}$. Model the quantized coefficient as\n$$\nh_q[n] \\triangleq h_0[n] + \\varepsilon[n], \\quad \\varepsilon[n] \\sim \\mathcal{U}\\!\\left(-\\tfrac{\\Delta}{2}, \\tfrac{\\Delta}{2}\\right), \\quad \\text{independent over } n,\n$$\nwhere $\\{h_0[n]\\}_{n=0}^{M-1}$ is the unquantized base design. Let $H_q(f)$ be the corresponding frequency response computed from $\\{h_q[n]\\}$ using the same definition as above.\n\nA specification violation event occurs for a quantized instance if either the passband ripple exceeds the tolerance, that is\n$$\n\\max_{f \\in [0, f_p]} \\bigl|\\,|H_q(f)| - 1\\,\\bigr|  \\delta_p,\n$$\nor the stopband magnitude exceeds the tolerance, that is\n$$\n\\max_{f \\in [f_s, \\tfrac{1}{2}]} |H_q(f)|  \\delta_s.\n$$\nWe will estimate the probability of specification violation using Monte Carlo (MC) simulation, and we will quantify estimator uncertainty with a binomial-proportion confidence interval.\n\nStart from the following fundamental base:\n- The frequency response definition of a discrete-time LTI system.\n- The Monte Carlo principle that independent draws from a distribution allow estimation of event probabilities by relative frequency.\n- The binomial model: if $X$ counts violations over $N$ independent trials, then $X \\sim \\operatorname{Binomial}(N, p)$ where $p$ is the (unknown) violation probability.\n- The Wilson score interval derived by inverting a normal approximation to the binomial distribution, providing a two-sided confidence interval for $p$ at confidence level $c \\in (0,1)$ with $z$-value $z_{1-\\alpha/2}$, where $\\alpha = 1 - c$.\n\nYour task is to write a complete, runnable program that:\n1. Constructs a base FIR low-pass filter of length $M = 31$ by windowing the ideal impulse response with a Hamming window and normalizes it to unit DC gain. Use an ideal low-pass with cutoff $f_c = 0.20$ cycles per sample:\n   - Ideal impulse response before windowing:\n     $$\n     h_{\\text{ideal}}[n] \\triangleq 2 f_c \\, \\operatorname{sinc}\\!\\bigl(2 f_c (n - \\tfrac{M-1}{2})\\bigr), \\quad n = 0,1,\\dots,M-1,\n     $$\n     where $\\operatorname{sinc}(x) \\triangleq \\dfrac{\\sin(\\pi x)}{\\pi x}$ for $x \\neq 0$ and $\\operatorname{sinc}(0) \\triangleq 1$.\n   - Hamming window:\n     $$\n     w[n] \\triangleq 0.54 - 0.46 \\cos\\!\\left(\\dfrac{2 \\pi n}{M-1}\\right).\n     $$\n   - Windowed response $h_w[n] \\triangleq h_{\\text{ideal}}[n] \\, w[n]$ and normalized base coefficients $h_0[n] \\triangleq \\dfrac{h_w[n]}{\\sum_{k=0}^{M-1} h_w[k]}$.\n2. Discretizes the frequency axis on a dense uniform grid via the discrete Fourier transform length $N_{\\text{fft}} = 2048$ so that the set of evaluated frequencies is $\\{ f_k \\triangleq \\tfrac{k}{N_{\\text{fft}}} : k = 0,1,\\dots,\\tfrac{N_{\\text{fft}}}{2} \\}$.\n3. For each Monte Carlo trial, draws independent quantization errors $\\varepsilon[n] \\sim \\mathcal{U}(-\\tfrac{\\Delta}{2}, \\tfrac{\\Delta}{2})$ for all $n$, forms $h_q[n] = h_0[n] + \\varepsilon[n]$, computes $H_q(f_k)$ on the grid, and records a violation if either the passband or stopband inequalities above are broken.\n4. Repeats for $N$ trials and computes the Monte Carlo estimate $\\hat{p} \\triangleq \\dfrac{X}{N}$ where $X$ is the total number of violations. Construct the two-sided Wilson score confidence interval at confidence level $c = 0.95$, with $z \\approx 1.959964$, given by\n   $$\n   \\hat{p}_\\text{W} \\pm \\text{half\\_width}, \\quad \\hat{p}_\\text{W} \\triangleq \\dfrac{\\hat{p} + \\dfrac{z^2}{2N}}{1 + \\dfrac{z^2}{N}}, \\quad \\text{half\\_width} \\triangleq \\dfrac{z}{1 + \\dfrac{z^2}{N}} \\sqrt{\\dfrac{\\hat{p}(1-\\hat{p})}{N} + \\dfrac{z^2}{4 N^2}}.\n   $$\n   Clip the bounds to the unit interval $[0,1]$.\n\nUse the specifications\n- Passband edge $f_p = 0.18$,\n- Stopband edge $f_s = 0.22$,\n- Passband ripple tolerance $\\delta_p = 0.02$,\n- Stopband magnitude tolerance $\\delta_s = 0.003$.\n\nAngle units are dimensionless normalized frequency in cycles per sample. No physical units are involved. The confidence level is $c = 0.95$.\n\nTest suite. Your program must run the Monte Carlo estimator for the following four test cases, each specified as a pair $(N, b)$ where $N$ is the number of Monte Carlo trials and $b$ is the number of fractional bits that define $\\Delta = 2^{-b}$:\n- Case $1$: $(N, b) = (50, 10)$,\n- Case $2$: $(N, b) = (1000, 12)$,\n- Case $3$: $(N, b) = (1000, 8)$,\n- Case $4$: $(N, b) = (1000, 6)$.\n\nFor each case, output the triple $[\\hat{p}, \\text{CI}_{\\text{low}}, \\text{CI}_{\\text{high}}]$, where $\\hat{p}$ is the estimated violation probability, and $\\text{CI}_{\\text{low}}$ and $\\text{CI}_{\\text{high}}$ are the lower and upper Wilson interval bounds, respectively. All three values must be real numbers rounded to six decimal digits.\n\nFinal output format. Your program should produce a single line of output containing a JSON array of length $4$, where the $i$-th element is the three-element list corresponding to Case $i$ in the order given above. For example, an acceptable format is\n$[[0.0,0.0,0.07],[0.01,0.004,0.02],[0.2,0.18,0.22],[0.6,0.57,0.63]]$,\nbut with the actual numbers replaced by the computed values for the specified test cases and each float rounded to six decimal digits.", "solution": "The problem requires an analysis of a finite impulse response (FIR) filter's performance under coefficient quantization. The solution involves three stages: first, the design of a baseline low-pass FIR filter using the window method; second, a Monte Carlo simulation to estimate the probability of performance specification violation due to quantization noise; and third, the calculation of a statistical confidence interval for this probability estimate. The entire process rests on fundamental principles of digital signal processing and statistical estimation theory.\n\nFirst, we address the design of the base filter. The problem specifies a linear-phase FIR filter of length $M=31$. Such a filter is symmetric, and its design begins with an ideal low-pass filter impulse response, which is non-causal and infinitely long. The ideal impulse response for a low-pass filter with cutoff frequency $f_c$ is given by a sinc function:\n$$\nh_{\\text{ideal, raw}}[n] = 2 f_c \\operatorname{sinc}(2 f_c n), \\quad n \\in \\mathbb{Z}\n$$\nwhere $\\operatorname{sinc}(x) \\triangleq \\frac{\\sin(\\pi x)}{\\pi x}$. To make this response finite and causal, we apply two operations: truncation and time-shifting. A symmetric filter of length $M$ is centered around $\\frac{M-1}{2}$. Thus, we shift the ideal response by this amount and select $M$ samples:\n$$\nh_{\\text{ideal}}[n] \\triangleq 2 f_c \\operatorname{sinc}\\left(2 f_c \\left(n - \\frac{M-1}{2}\\right)\\right), \\quad n=0, 1, \\dots, M-1\n$$\nFor the given parameters $M=31$ and $f_c=0.20$, the center is at $\\frac{31-1}{2}=15$. Abruptly truncating the impulse response (i.e., using a rectangular window) leads to the Gibbs phenomenon, which manifests as large ripples in the frequency response near the band edges. To mitigate this, we multiply the ideal response by a window function that tapers smoothly to zero at its ends. The problem specifies a Hamming window:\n$$\nw[n] \\triangleq 0.54 - 0.46 \\cos\\left(\\frac{2 \\pi n}{M-1}\\right), \\quad n=0, 1, \\dots, M-1\n$$\nThe windowed impulse response is $h_w[n] = h_{\\text{ideal}}[n] \\cdot w[n]$. Finally, the filter must have unit DC gain, meaning its frequency response at frequency $f=0$ is $H(0)=1$. The frequency response is $H(f) = \\sum_{n=0}^{M-1} h[n] e^{-j 2 \\pi f n}$, so the DC gain is $H(0) = \\sum_{n=0}^{M-1} h[n]$. To enforce unit DC gain, we normalize the coefficients:\n$$\nh_0[n] \\triangleq \\frac{h_w[n]}{\\sum_{k=0}^{M-1} h_w[k]}\n$$\nThese normalized coefficients $\\{h_0[n]\\}$ constitute the unquantized base filter design.\n\nSecond, we model the effect of quantization and evaluate performance. The coefficients are quantized to a fixed-point representation with $b$ fractional bits. The quantization step size is $\\Delta = 2^{-b}$. We model the quantization error for each coefficient as an independent random variable $\\varepsilon[n]$ drawn from a uniform distribution $\\mathcal{U}(-\\Delta/2, \\Delta/2)$. The quantized coefficient is thus $h_q[n] = h_0[n] + \\varepsilon[n]$. The frequency response of the quantized filter, $H_q(f)$, is a random function.\n\nA specification violation occurs if the magnitude of this response, $|H_q(f)|$, fails to meet the criteria in the passband $[0, f_p]$ or the stopband $[f_s, 1/2]$.\n- Passband violation: $\\max_{f \\in [0, f_p]} \\bigl|\\,|H_q(f)| - 1\\,\\bigr|  \\delta_p$\n- Stopband violation: $\\max_{f \\in [f_s, 1/2]} |H_q(f)|  \\delta_s$\nwhere $f_p=0.18$, $f_s=0.22$, $\\delta_p=0.02$, and $\\delta_s=0.003$.\n\nAnalytically computing the probability of such a violation is intractable due to the complex interplay of the random errors and the max operations. Therefore, we employ Monte Carlo simulation. For a given number of trials $N$, we perform the following steps in each trial:\n$1$. Generate a set of $M=31$ independent quantization errors $\\{\\varepsilon[n]\\}_{n=0}^{M-1}$.\n$2$. Form the quantized coefficients $h_q[n] = h_0[n] + \\varepsilon[n]$.\n$3$. Compute the discrete frequency response $H_q(f_k)$ on a dense grid of frequencies $f_k = k/N_{\\text{fft}}$ for $k=0, \\dots, N_{\\text{fft}}/2$, using the Fast Fourier Transform (FFT) of length $N_{\\text{fft}}=2048$.\n$4$. Check if the passband or stopband specifications are violated on this grid.\nIf a violation occurs, we count it. After $N$ trials, if $X$ violations are recorded, the estimated violation probability is $\\hat{p} = X/N$.\n\nThird, we quantify the uncertainty of the estimate $\\hat{p}$. Each trial is an independent Bernoulli experiment with an unknown success (violation) probability $p$. The number of violations $X$ follows a binomial distribution, $X \\sim \\operatorname{Binomial}(N, p)$. To construct a confidence interval for $p$, we use the Wilson score interval, which is more reliable than simpler methods, especially when $p$ is close to $0$ or $1$. For a confidence level $c=0.95$, the corresponding z-score is $z = z_{1-(1-c)/2} \\approx 1.959964$. The interval is centered at $\\hat{p}_{\\text{W}}$ with a half-width as specified:\n$$\n\\hat{p}_{\\text{W}} = \\frac{\\hat{p} + \\frac{z^2}{2N}}{1 + \\frac{z^2}{N}}, \\quad \\text{half\\_width} = \\frac{z}{1 + \\frac{z^2}{N}} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{N} + \\frac{z^2}{4 N^2}}\n$$\nThe lower and upper bounds of the confidence interval are $\\text{CI}_{\\text{low}} = \\hat{p}_{\\text{W}} - \\text{half\\_width}$ and $\\text{CI}_{\\text{high}} = \\hat{p}_{\\text{W}} + \\text{half\\_width}$, respectively, clipped to the interval $[0, 1]$.\n\nThis procedure is executed for four test cases, each defined by a pair $(N, b)$: $(50, 10)$, $(1000, 12)$, $(1000, 8)$, and $(1000, 6)$. The final output for each case consists of the triplet $[\\hat{p}, \\text{CI}_{\\text{low}}, \\text{CI}_{\\text{high}}]$, rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo simulation for all test cases and print the final result.\n    \"\"\"\n    # ----------------------------------------------------------------------\n    # Define problem constants and specifications\n    # ----------------------------------------------------------------------\n    M = 31  # FIR filter tap-length\n    f_c = 0.20  # Ideal low-pass cutoff frequency\n    N_fft = 2048  # FFT length for frequency response evaluation\n\n    # Filter performance specifications\n    f_p = 0.18  # Passband edge\n    f_s = 0.22  # Stopband edge\n    delta_p = 0.02  # Passband ripple tolerance\n    delta_s = 0.003  # Stopband magnitude tolerance\n\n    # Confidence interval parameters\n    c = 0.95  # Confidence level\n    z = 1.959964  # z-value for 95% confidence\n\n    # Test cases: (N_trials, bits)\n    test_cases = [\n        (50, 10),\n        (1000, 12),\n        (1000, 8),\n        (1000, 6),\n    ]\n\n    # ----------------------------------------------------------------------\n    # Step 1: Design the base FIR filter (h0)\n    # ----------------------------------------------------------------------\n    # Time index vector, centered for linear phase\n    n = np.arange(M)\n    n_centered = n - (M - 1) / 2\n\n    # Ideal sinc impulse response\n    # np.sinc(x) computes sin(pi*x)/(pi*x)\n    h_ideal = 2 * f_c * np.sinc(2 * f_c * n_centered)\n\n    # Hamming window\n    w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (M - 1))\n\n    # Windowed impulse response\n    h_w = h_ideal * w_hamming\n\n    # Normalize for unit DC gain\n    h_0 = h_w / np.sum(h_w)\n\n    # ----------------------------------------------------------------------\n    # Step 2: Set up frequency grid and band indices\n    # ----------------------------------------------------------------------\n    # Frequency grid from 0 to 0.5 cycles/sample\n    freqs = np.arange(N_fft // 2 + 1) / N_fft\n\n    # Get indices for passband and stopband\n    passband_indices = np.where(freqs = f_p)[0]\n    stopband_indices = np.where(freqs >= f_s)[0]\n\n    # ----------------------------------------------------------------------\n    # Step 3  4: Run simulations and compute results\n    # ----------------------------------------------------------------------\n    results = []\n    for N, b in test_cases:\n        p_hat, ci_low, ci_high = _run_simulation(\n            N, b, h_0, N_fft, passband_indices, stopband_indices, delta_p, delta_s, z)\n        results.append([round(p_hat, 6), round(ci_low, 6), round(ci_high, 6)])\n\n    # Format the final output as a JSON-like string without spaces\n    case_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\ndef _run_simulation(N, b, h_0, N_fft, passband_indices, stopband_indices, delta_p, delta_s, z):\n    \"\"\"\n    Helper function to run a single Monte Carlo simulation case.\n    \"\"\"\n    M = len(h_0)\n    delta_q = 2**(-b)\n    violation_count = 0\n\n    for _ in range(N):\n        # Generate quantization errors\n        errors = np.random.uniform(-delta_q / 2, delta_q / 2, size=M)\n\n        # Create quantized filter coefficients\n        h_q = h_0 + errors\n\n        # Compute frequency response via FFT\n        H_q = np.fft.fft(h_q, N_fft)\n        H_q_mag = np.abs(H_q[:N_fft // 2 + 1])\n\n        # Check for passband violation\n        passband_ripple = np.max(np.abs(H_q_mag[passband_indices] - 1))\n        is_passband_violated = passband_ripple > delta_p\n\n        # Check for stopband violation\n        stopband_mag = np.max(H_q_mag[stopband_indices])\n        is_stopband_violated = stopband_mag > delta_s\n\n        if is_passband_violated or is_stopband_violated:\n            violation_count += 1\n\n    # Estimated probability of violation\n    p_hat = violation_count / N\n\n    # Calculate Wilson score confidence interval\n    z2 = z**2\n    N_float = float(N)\n    \n    # Denominator of the main terms\n    denominator = 1 + z2 / N_float\n\n    # Center of the Wilson interval\n    p_hat_w = (p_hat + z2 / (2 * N_float)) / denominator\n\n    # Half-width of the interval\n    sqrt_term = np.sqrt((p_hat * (1 - p_hat) / N_float) + (z2 / (4 * N_float**2)))\n    half_width = (z / denominator) * sqrt_term\n\n    # Calculate and clip the bounds\n    ci_low = max(0.0, p_hat_w - half_width)\n    ci_high = min(1.0, p_hat_w + half_width)\n\n    return p_hat, ci_low, ci_high\n\n# Execute the main function\nsolve()\n```", "id": "2871028"}]}