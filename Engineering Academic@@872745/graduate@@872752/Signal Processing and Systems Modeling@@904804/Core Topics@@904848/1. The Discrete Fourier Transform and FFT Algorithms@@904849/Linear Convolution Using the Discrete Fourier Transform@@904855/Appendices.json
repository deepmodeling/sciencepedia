{"hands_on_practices": [{"introduction": "Textbook examples often simplify convolution by assuming signals start at index $n=0$. This practice challenges you to generalize your understanding by developing a rigorous procedure for any two finite-length signals, regardless of their time origin [@problem_id:2880468]. By constructing the method from first principles, you will master the critical steps of determining DFT length, managing index shifts, and correctly interpreting the output, ensuring your implementations are robust for real-world scenarios.", "problem": "You are given finite-length discrete-time signals with arbitrary supports. Starting only from the definitions of linear convolution and the Discrete Fourier Transform (DFT), construct a rigorous, step-by-step procedure to compute the linear convolution via the DFT when the signals are supported on arbitrary index intervals. Your procedure must explicitly include: (i) how to determine the minimal transform length, (ii) how to reindex signals supported on intervals other than $[0,L-1]$ to zero-based arrays, (iii) how and why zero-padding avoids aliasing, and (iv) how to map the inverse-transform result back to the original time indices.\n\nThen apply your procedure to the following signals supported on arbitrary index intervals:\n- $x[n]$ supported on $[-2,1]$ with values $x[-2]=2$, $x[-1]=-1$, $x[0]=3$, $x[1]=1$.\n- $h[n]$ supported on $[3,6]$ with values $h[3]=1$, $h[4]=0$, $h[5]=-2$, $h[6]=4$.\n\nUse the minimal valid DFT length and compute the linear convolution output sample $y[4]$. Provide the final result as an exact number. No rounding is required. The final answer must be a single number.", "solution": "The problem is valid. It is a well-posed problem in digital signal processing that is scientifically grounded and objective. We begin by constructing the general procedure, then apply it to the specific signals provided.\n\nThe objective is to compute the linear convolution of two finite-length discrete-time signals, $x[n]$ and $h[n]$, using the Discrete Fourier Transform (DFT). The signals are defined on arbitrary integer supports.\n\nThe linear convolution is defined as:\n$$y[n] = (x * h)[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]$$\nThe $N$-point DFT and its inverse (IDFT) are defined for a signal $x[n]$ of length $N$ (supported on $[0, N-1]$) as:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-\\mathrm{j}\\frac{2\\pi}{N}nk}, \\quad k \\in [0, N-1]$$\n$$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] e^{\\mathrm{j}\\frac{2\\pi}{N}nk}, \\quad n \\in [0, N-1]$$\nwhere $\\mathrm{j} = \\sqrt{-1}$. The convolution theorem for the DFT states that the DFT of the circular convolution of two signals is the product of their individual DFTs. Let $x_N[n]$ and $h_N[n]$ be two signals of length $N$. Their $N$-point circular convolution is defined as:\n$$(x_N \\circledast_N h_N)[n] = \\sum_{m=0}^{N-1} x_N[m] h_N[(n-m) \\pmod N]$$\nThe theorem states:\n$$DFT\\{(x_N \\circledast_N h_N)[n]\\} = X_N[k] H_N[k]$$\nThis implies that we can compute circular convolution by transforming the signals to the frequency domain, multiplying them, and transforming back:\n$$(x_N \\circledast_N h_N)[n] = IDFT\\{X_N[k] H_N[k]\\}$$\nThe core of the procedure is to use this property to compute linear convolution.\n\nHere is the step-by-step procedure:\n\n**(i) Minimal Transform Length and (iii) Zero-Padding to Avoid Aliasing**\n\nLet the signal $x[n]$ have support starting at index $n_{x,min}$ and ending at $n_{x,max}$. The length of the signal is $L_x = n_{x,max} - n_{x,min} + 1$. Similarly, let $h[n]$ have support on $[n_{h,min}, n_{h,max}]$ and length $L_h = n_{h,max} - n_{h,min} + 1$.\n\nThe linear convolution $y[n] = (x * h)[n]$ is a finite-length signal. Its support starts at $n_{y,min} = n_{x,min} + n_{h,min}$ and ends at $n_{y,max} = n_{x,max} + n_{h,max}$. The length of the resulting signal $y[n]$ is $L_y = n_{y,max} - n_{y,min} + 1 = L_x + L_h - 1$.\n\nCircular convolution of length $N$ is related to linear convolution by the expression:\n$$(x_N \\circledast_N h_N)[n] = \\sum_{m=-\\infty}^{\\infty} y[n-mN]$$\nThis shows that the circular convolution is a time-aliased version of the linear convolution. To ensure that the result of an $N$-point circular convolution is identical to the linear convolution for its entire duration, we must prevent the non-zero parts of the shifted copies $y[n-mN]$ from overlapping. Since the linear convolution $y[n]$ has a length of $L_y = L_x + L_h - 1$, we must choose a transform length $N$ such that $N \\ge L_y$.\n\nThe minimal valid DFT length is therefore:\n$$N_{min} = L_x + L_h - 1$$\nTo use an $N$-point DFT where $N \\ge N_{min}$, we must extend the original signals $x[n]$ and $h[n]$ to this length. This is accomplished by zero-padding.\n\n**(ii) Reindexing to Zero-Based Arrays**\n\nThe DFT is formally defined for signals on the index interval $[0, N-1]$. Our signals $x[n]$ and $h[n]$ have arbitrary supports. We must re-index them to create new zero-based signals, which we will denote as $x_p[n]$ and $h_p[n]$, of length $N$.\n\nFor $x[n]$ supported on $[n_{x,min}, n_{x,max}]$, we create $x_p[n]$ of length $N$:\n$$x_p[n] = \\begin{cases} x[n + n_{x,min}]  \\text{for } 0 \\le n  L_x \\\\ 0  \\text{for } L_x \\le n  N \\end{cases}$$\nSimilarly, for $h[n]$ supported on $[n_{h,min}, n_{h,max}]$, we create $h_p[n]$ of length $N$:\n$$h_p[n] = \\begin{cases} h[n + n_{h,min}]  \\text{for } 0 \\le n  L_h \\\\ 0  \\text{for } L_h \\le n  N \\end{cases}$$\nThese padded signals $x_p[n]$ and $h_p[n]$ are the inputs to the DFT.\n\nThe full computational sequence is:\n1. Compute the $N$-point DFTs: $X_p[k] = DFT\\{x_p[n]\\}$ and $H_p[k] = DFT\\{h_p[n]\\}$.\n2. Multiply in the frequency domain: $Y_p[k] = X_p[k] H_p[k]$.\n3. Compute the $N$-point inverse DFT: $y_p[n] = IDFT\\{Y_p[k]\\}$. The resulting signal $y_p[n]$ contains the values of the linear convolution for $n \\in [0, L_y-1]$.\n\n**(iv) Mapping the Inverse-Transform Result Back to Original Time Indices**\n\nThe computed signal $y_p[n]$ is supported on $[0, N-1]$, with its non-zero part contained within $[0, L_y-1]$. This signal represents the values of the true linear convolution output $y[n]$, but on a zero-based index. We must map these values back to the correct support of $y[n]$, which is $[n_{y,min}, n_{y,max}]$.\n\nThe starting index of the convolution is $n_{y,min} = n_{x,min} + n_{h,min}$. The mapping is a simple index shift:\n$$y[n] = y_p[n - n_{y,min}] = y_p[n - (n_{x,min} + n_{h,min})]$$\nThis provides the final linear convolution result $y[n]$ on its correct support interval.\n\n**Application to the Specific Problem**\n\nWe are given:\n- $x[n]$ supported on $[-2, 1]$ with values $\\{x[-2]=2, x[-1]=-1, x[0]=3, x[1]=1\\}$.\n- $h[n]$ supported on $[3, 6]$ with values $\\{h[3]=1, h[4]=0, h[5]=-2, h[6]=4\\}$.\n\nFirst, we determine the properties of the signals:\n- For $x[n]$: $n_{x,min} = -2$, $n_{x,max} = 1$. The length is $L_x = 1 - (-2) + 1 = 4$.\n- For $h[n]$: $n_{h,min} = 3$, $n_{h,max} = 6$. The length is $L_h = 6 - 3 + 1 = 4$.\n\nNext, we apply the procedure:\n\n1.  **Determine Minimal DFT Length:**\n    $N_{min} = L_x + L_h - 1 = 4 + 4 - 1 = 7$. We will use $N=7$.\n\n2.  **Reindex and Pad:**\n    We create zero-based signals $x_p[n]$ and $h_p[n]$ of length $N=7$.\n    - For $x_p[n]$, the values are $x[n-2]$ for $n \\in [0,3]$:\n      $x_p[0] = x[-2] = 2$\n      $x_p[1] = x[-1] = -1$\n      $x_p[2] = x[0] = 3$\n      $x_p[3] = x[1] = 1$\n      $x_p[4]=x_p[5]=x_p[6]=0$.\n      Thus, the sequence is $x_p = \\{2, -1, 3, 1, 0, 0, 0\\}$.\n    - For $h_p[n]$, the values are $h[n+3]$ for $n \\in [0,3]$:\n      $h_p[0] = h[3] = 1$\n      $h_p[1] = h[4] = 0$\n      $h_p[2] = h[5] = -2$\n      $h_p[3] = h[6] = 4$\n      $h_p[4]=h_p[5]=h_p[6]=0$.\n      Thus, the sequence is $h_p = \\{1, 0, -2, 4, 0, 0, 0\\}$.\n\n3.  **Determine Output Mapping:**\n    We need to compute the sample $y[4]$. First, we find the support of the output $y[n]$.\n    $n_{y,min} = n_{x,min} + n_{h,min} = -2 + 3 = 1$.\n    The mapping from the computed sequence $y_p[n]$ to $y[n]$ is $y[n] = y_p[n-1]$.\n    Therefore, the desired sample $y[4]$ corresponds to $y_p[4-1] = y_p[3]$.\n\n4.  **Compute the Required Sample:**\n    The sequence $y_p[n]$ is the result of the $7$-point circular convolution of $x_p[n]$ and $h_p[n]$. We compute $y_p[3]$ directly from this definition:\n    $$y_p[3] = (x_p \\circledast_7 h_p)[3] = \\sum_{m=0}^{6} x_p[m] h_p[(3-m) \\pmod 7]$$\n    We expand the sum term by term for $m=0, 1, ..., 6$. The sum is non-zero only for $m \\in [0,3]$ since $x_p[m]=0$ for $m  3$.\n    - $m=0$: $x_p[0] h_p[(3-0) \\pmod 7] = x_p[0] h_p[3] = (2)(4) = 8$.\n    - $m=1$: $x_p[1] h_p[(3-1) \\pmod 7] = x_p[1] h_p[2] = (-1)(-2) = 2$.\n    - $m=2$: $x_p[2] h_p[(3-2) \\pmod 7] = x_p[2] h_p[1] = (3)(0) = 0$.\n    - $m=3$: $x_p[3] h_p[(3-3) \\pmod 7] = x_p[3] h_p[0] = (1)(1) = 1$.\n    - $m=4,5,6$: The terms are zero because $x_p[m]=0$.\n\n    Summing the contributions:\n    $$y_p[3] = 8 + 2 + 0 + 1 = 11$$\n    Since $y[4] = y_p[3]$, the final answer is $11$. This result is identical to what would be obtained via direct evaluation of the linear convolution sum, which confirms the correctness of the procedure.", "answer": "$$\\boxed{11}$$", "id": "2880468"}, {"introduction": "A correct algorithm is only the first step; robust engineering also requires the ability to diagnose and correct errors. This exercise [@problem_id:2880462] simulates a common implementation bug—a missing scaling factor in the inverse FFT—and tasks you with deriving a detection and correction method. The solution lies not in guesswork, but in applying a fundamental property of the DFT to create a data-driven verification procedure, a powerful technique for validating any FFT-based process.", "problem": "Consider two real, finite-length discrete-time signals $x[n]$ and $h[n]$ of lengths $L_{x}$ and $L_{h}$, respectively. Define their zero-padded versions to a common length $N \\geq L_{x}+L_{h}-1$ as $x_{N}[n]$ and $h_{N}[n]$, with $x_{N}[n]=x[n]$ for $0 \\leq n \\leq L_{x}-1$ and $x_{N}[n]=0$ otherwise, and similarly for $h_{N}[n]$. Let the length-$N$ Discrete Fourier Transform (DFT) be defined by\n$$\nX[k] \\triangleq \\sum_{n=0}^{N-1} x_{N}[n] \\exp\\!\\left(-\\mathrm{j} \\frac{2\\pi}{N}kn\\right), \\quad H[k] \\triangleq \\sum_{n=0}^{N-1} h_{N}[n] \\exp\\!\\left(-\\mathrm{j} \\frac{2\\pi}{N}kn\\right),\n$$\nfor $k=0,1,\\ldots,N-1$, and the corresponding inverse DFT (IDFT) be defined by\n$$\nx_{N}[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp\\!\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right), \\quad h_{N}[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} H[k] \\exp\\!\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right),\n$$\nfor $n=0,1,\\ldots,N-1$. The true linear convolution is $y[n] \\triangleq (x*h)[n]$ for $n=0,1,\\ldots,L_{x}+L_{h}-2$.\n\nAn engineer computes the linear convolution via the circular-convolution embedding using the DFT and the Fast Fourier Transform (FFT), but misapplies the inverse FFT (IFFT) scaling by omitting the $1/N$ factor. Specifically, they form\n$$\n\\tilde{y}[n] \\triangleq \\sum_{k=0}^{N-1} X[k]\\,H[k]\\,\\exp\\!\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right), \\quad n=0,1,\\ldots,N-1,\n$$\nand then keep the first $L_{x}+L_{h}-1$ samples as the purported linear convolution.\n\nStarting strictly from the above definitions and standard properties that follow from them, do the following:\n\n1. Derive the exact scalar amplitude bias $\\alpha$ such that $\\tilde{y}[n] = \\alpha\\, y[n]$ for all $n \\in \\{0,1,\\ldots,L_{x}+L_{h}-2\\}$, and express $\\alpha$ in terms of $N$.\n\n2. Propose a detection and correction procedure that does not assume prior knowledge of $N$ or any particular library’s scaling convention. Your procedure must rely only on directly observable quantities from $x[n]$, $h[n]$, and the computed $\\tilde{y}[n]$. In particular, derive a scalar correction factor $\\hat{c}$ that, when multiplied with $\\tilde{y}[n]$, produces the true linear convolution $y[n]$ for all $n \\in \\{0,1,\\ldots,L_{x}+L_{h}-2\\}$. Express $\\hat{c}$ purely in terms of $\\sum_{n=0}^{L_{x}-1} x[n]$, $\\sum_{m=0}^{L_{h}-1} h[m]$, and $\\sum_{n=0}^{L_{x}+L_{h}-2} \\tilde{y}[n]$.\n\nProvide, as your final answer, the explicit closed-form analytic expression for the correction factor $\\hat{c}$. No numerical approximation is required, and no units are involved.", "solution": "The problem statement is reviewed for validity.\n\n**Step 1: Extract Givens**\n- Two real, finite-length signals, $x[n]$ of length $L_x$ and $h[n]$ of length $L_h$.\n- Zero-padded versions $x_N[n]$ and $h_N[n]$ to a common length $N \\geq L_x+L_h-1$.\n- Length-$N$ Discrete Fourier Transform (DFT) definition: $X[k] \\triangleq \\sum_{n=0}^{N-1} x_{N}[n] \\exp(-\\mathrm{j} \\frac{2\\pi}{N}kn)$.\n- Length-$N$ Inverse Discrete Fourier Transform (IDFT) definition: $x_{N}[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp(\\mathrm{j} \\frac{2\\pi}{N}kn)$.\n- Linear convolution definition: $y[n] \\triangleq (x*h)[n]$ for $n=0,1,\\ldots,L_{x}+L_{h}-2$.\n- Incorrectly computed signal: $\\tilde{y}[n] \\triangleq \\sum_{k=0}^{N-1} X[k]\\,H[k]\\,\\exp(\\mathrm{j} \\frac{2\\pi}{N}kn)$.\n- Task 1: Find scalar bias $\\alpha$ such that $\\tilde{y}[n] = \\alpha\\, y[n]$.\n- Task 2: Find correction factor $\\hat{c}$ in terms of $\\sum_{n=0}^{L_{x}-1} x[n]$, $\\sum_{m=0}^{L_{h}-1} h[m]$, and $\\sum_{n=0}^{L_{x}+L_{h}-2} \\tilde{y}[n]$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it deals with standard definitions and applications of the Discrete Fourier Transform for linear convolution, a cornerstone of digital signal processing. The problem is well-posed, providing all necessary definitions and constraints, such as $N \\geq L_x+L_h-1$, which is the precise condition to ensure that circular convolution implemented via the DFT is equivalent to linear convolution. The scenario of a missing scaling factor in an IFFT implementation is a practical and common error. The problem is objective, using precise mathematical language and requesting a formal derivation. It does not exhibit any of the flaws listed in the validation checklist.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A full solution will be provided.\n\nThe fundamental principle for performing linear convolution using the DFT is the convolution theorem. For two discrete-time signals $x_N[n]$ and $h_N[n]$, their circular convolution, denoted $y_c[n] = (x_N \\circledast h_N)[n]$, has a DFT given by the product of the individual DFTs: $Y_c[k] = X[k]H[k]$.\nThe linear convolution $y[n]$ of the original signals $x[n]$ and $h[n]$ has a length of $L_y = L_x+L_h-1$. By zero-padding the input signals to a length $N \\geq L_y$, we ensure that the circular convolution $y_c[n]$ is equivalent to the linear convolution $y[n]$ for the first $L_y$ samples, i.e., $y_c[n] = y[n]$ for $n \\in \\{0, 1, \\ldots, L_y-1\\}$, and $y_c[n]=0$ for $n \\geq L_y$.\n\nLet us call the result of the correct procedure $y_N[n]$. It is obtained by taking the proper inverse DFT of the product $X[k]H[k]$. According to the provided IDFT definition:\n$$\ny_N[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k]H[k] \\exp\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right)\n$$\nFor $n \\in \\{0, 1, \\ldots, L_x+L_h-2\\}$, this $y_N[n]$ is identical to the true linear convolution $y[n]$.\n\n**Part 1: Derivation of the scalar amplitude bias $\\alpha$**\n\nThe engineer computes the quantity $\\tilde{y}[n]$ defined as:\n$$\n\\tilde{y}[n] \\triangleq \\sum_{k=0}^{N-1} X[k]H[k] \\exp\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right)\n$$\nBy direct comparison of the expression for the correct result $y_N[n]$ and the erroneously computed $\\tilde{y}[n]$, we immediately see the relationship:\n$$\n\\tilde{y}[n] = N \\cdot y_N[n]\n$$\nSince $y_N[n]=y[n]$ for the relevant indices $n \\in \\{0, 1, \\ldots, L_x+L_h-2\\}$, it follows that:\n$$\n\\tilde{y}[n] = N \\cdot y[n]\n$$\nTherefore, the scalar amplitude bias is $\\alpha = N$.\n\n**Part 2: Derivation of the correction factor $\\hat{c}$**\n\nThe task is to find a correction factor $\\hat{c}$ such that $\\hat{c} \\cdot \\tilde{y}[n] = y[n]$. From Part $1$, we have $\\tilde{y}[n] = N y[n]$, so we must have $\\hat{c} \\cdot (N y[n]) = y[n]$, which implies $\\hat{c} = \\frac{1}{N}$. However, $N$ is unknown. We must express $N$ using only the observable quantities: the input signals $x[n]$ and $h[n]$, and the computed output $\\tilde{y}[n]$.\n\nWe use the property of the DFT at frequency index $k=0$. The DFT at $k=0$ is the sum of the time-domain samples. For the input signals $x[n]$ and $h[n]$, their zero-padded versions $x_N[n]$ and $h_N[n]$ have DFTs $X[k]$ and $H[k]$.\nAt $k=0$:\n$$\nX[0] = \\sum_{n=0}^{N-1} x_N[n] \\exp(0) = \\sum_{n=0}^{N-1} x_N[n] = \\sum_{n=0}^{L_x-1} x[n]\n$$\n$$\nH[0] = \\sum_{m=0}^{N-1} h_N[m] \\exp(0) = \\sum_{m=0}^{N-1} h_N[m] = \\sum_{m=0}^{L_h-1} h[m]\n$$\nNow consider the sum of the samples of the computed signal $\\tilde{y}[n]$. We sum over the full period from $n=0$ to $N-1$:\n$$\n\\sum_{n=0}^{N-1} \\tilde{y}[n] = \\sum_{n=0}^{N-1} \\left( \\sum_{k=0}^{N-1} X[k]H[k] \\exp\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right) \\right)\n$$\nBy interchanging the order of summation:\n$$\n\\sum_{n=0}^{N-1} \\tilde{y}[n] = \\sum_{k=0}^{N-1} X[k]H[k] \\left( \\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right) \\right)\n$$\nThe inner sum is a fundamental identity for the DFT basis vectors. It evaluates to $N$ when $k=0$ (or any integer multiple of $N$) and to $0$ otherwise. For $k \\in \\{0, 1, \\ldots, N-1\\}$, the sum is non-zero only for $k=0$.\n$$\n\\sum_{n=0}^{N-1} \\exp\\left(\\mathrm{j} \\frac{2\\pi}{N}kn\\right) = N \\delta[k]\n$$\nwhere $\\delta[k]$ is the Kronecker delta function.\nSubstituting this into the expression for the sum of $\\tilde{y}[n]$ yields:\n$$\n\\sum_{n=0}^{N-1} \\tilde{y}[n] = \\sum_{k=0}^{N-1} X[k]H[k] (N \\delta[k]) = N \\cdot X[0]H[0]\n$$\nAs established, the true linear convolution $y[n]$ is non-zero only for $n \\in \\{0, 1, \\ldots, L_x+L_h-2\\}$. Since $\\tilde{y}[n] = N y[n]$, $\\tilde{y}[n]$ must also be zero for $n \\geq L_x+L_h-1$. Therefore, the sum of $\\tilde{y}[n]$ from $n=0$ to $N-1$ is identical to the sum from $n=0$ to $L_x+L_h-2$:\n$$\n\\sum_{n=0}^{L_x+L_h-2} \\tilde{y}[n] = \\sum_{n=0}^{N-1} \\tilde{y}[n]\n$$\nCombining these results, we establish a relationship between the observable quantities:\n$$\n\\sum_{n=0}^{L_x+L_h-2} \\tilde{y}[n] = N \\cdot X[0]H[0] = N \\left( \\sum_{n=0}^{L_x-1} x[n] \\right) \\left( \\sum_{m=0}^{L_h-1} h[m] \\right)\n$$\nWe can solve for $N$ from this equation, under the non-trivial condition that the product of the sums of the input signals is non-zero:\n$$\nN = \\frac{\\sum_{n=0}^{L_x+L_h-2} \\tilde{y}[n]}{\\left( \\sum_{n=0}^{L_x-1} x[n] \\right) \\left( \\sum_{m=0}^{L_h-1} h[m] \\right)}\n$$\nThe required correction factor is $\\hat{c} = \\frac{1}{N}$. Therefore:\n$$\n\\hat{c} = \\frac{\\left( \\sum_{n=0}^{L_x-1} x[n] \\right) \\left( \\sum_{m=0}^{L_h-1} h[m] \\right)}{\\sum_{n=0}^{L_x+L_h-2} \\tilde{y}[n]}\n$$\nThis expression depends only on the sums of the samples of the known input signals $x[n]$ and $h[n]$, and the sum of the samples of the erroneously computed output $\\tilde{y}[n]$, as required. Multiplying $\\tilde{y}[n]$ by this factor $\\hat{c}$ will correct the scaling error and produce the true linear convolution $y[n]$.", "answer": "$$\n\\boxed{\\frac{\\left( \\sum_{n=0}^{L_x-1} x[n] \\right) \\left( \\sum_{m=0}^{L_h-1} h[m] \\right)}{\\sum_{n=0}^{L_x+L_h-2} \\tilde{y}[n]}}\n$$", "id": "2880462"}, {"introduction": "We now apply our knowledge to a practical system design scenario using the Overlap-Add method for real-time filtering. Efficiency is paramount, but it must be balanced against system requirements like latency [@problem_id:2880451]. This practice guides you through the process of minimizing computational cost per sample by optimally choosing the FFT size and block length, demonstrating how to navigate the trade-offs between algorithmic complexity and performance constraints in a complete design problem.", "problem": "A causal finite impulse response filter with impulse response length $M = 601$ samples is to be implemented by linear convolution using the Overlap-Add (OLA) method via the Discrete Fourier Transform (DFT). Let $L_b$ denote the number of new input samples processed per block, and let $N$ denote the DFT size. Assume a radix-$2$ Fast Fourier Transform (FFT) is used and $N$ must be a power of two. The DFT of the impulse response is precomputed offline and reused for all blocks.\n\nYour design objective is to choose $N$ and $L_b$ to minimize the average number of complex multiplications per input sample, subject to the following constraints:\n- Linear convolution without time-domain aliasing requires $N \\geq L_b + M - 1$.\n- The end-to-end algorithmic latency is the sum of the filter group delay and the block accumulation delay. Model the group delay as $M - 1$ samples and the block accumulation delay as $L_b - 1$ samples, so the total latency is $M + L_b - 2$ samples. This total latency must not exceed a budget $L_{\\max} = 1440$ samples.\n- The FFT size $N$ must be a power of two.\n\nUsing only fundamental definitions of linear convolution, the OLA block structure, and the standard complexity scaling of the radix-$2$ FFT, derive from first principles the per-block computational cost, convert it to the average cost per input sample, characterize the feasible set implied by the constraints, and determine the optimal $(N, L_b)$ that minimize the average cost per input sample. Provide a rigorous justification of optimality.\n\nReport your final answer as the ordered pair $(N_{\\mathrm{opt}}, L_{b,\\mathrm{opt}})$ with each entry an integer number of samples. No rounding is required and no physical units are to be included in the final answer.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It provides a complete set of constraints and a clear objective function for a standard optimization task in digital signal processing. Therefore, the problem is valid, and we shall proceed with its formal solution.\n\nThe objective is to minimize the average number of complex multiplications per input sample, which we denote as $C_{sample}$. This cost is determined by the implementation of linear convolution using the Overlap-Add (OLA) method with a radix-$2$ Fast Fourier Transform (FFT).\n\nFirst, we establish the computational cost per block. For each block of new input samples, the OLA method involves three main steps contributing to the multiplication count:\n1.  An $N$-point FFT of the input block.\n2.  An element-wise complex multiplication of the transformed input and the precomputed transformed filter response.\n3.  An $N$-point Inverse FFT (IFFT) to obtain the time-domain output block.\n\nThe number of complex multiplications for a radix-$2$ FFT of size $N$ is $\\frac{N}{2} \\log_2(N)$. The IFFT has the same computational complexity. The element-wise product of two $N$-point vectors requires $N$ complex multiplications. The DFT of the filter impulse response is precomputed, so its cost is not part of the per-block calculation for a long input signal.\n\nThe total number of complex multiplications per block, $C_{block}$, is the sum of the costs of these three operations:\n$$ C_{block} = \\left(\\frac{N}{2} \\log_2(N)\\right)_{\\text{FFT}} + (N)_{\\text{Product}} + \\left(\\frac{N}{2} \\log_2(N)\\right)_{\\text{IFFT}} = N \\log_2(N) + N = N (\\log_2(N) + 1) $$\nEach block processes $L_b$ new input samples. Therefore, the average number of complex multiplications per input sample is:\n$$ C_{sample}(N, L_b) = \\frac{C_{block}}{L_b} = \\frac{N (\\log_2(N) + 1)}{L_b} $$\nOur goal is to minimize this function $C_{sample}(N, L_b)$ subject to the given constraints.\n\nNext, we formalize the constraints on the variables $N$ and $L_b$.\nThe problem provides the filter impulse response length $M = 601$ samples.\n\nConstraint 1: To avoid time-domain aliasing in the linear convolution, the DFT size $N$ must be at least the length of the resulting convolved sequence, which is $(L_b + M - 1)$.\n$$ N \\geq L_b + M - 1 \\implies N \\geq L_b + 601 - 1 \\implies N \\geq L_b + 600 $$\nThis can be rewritten as an upper bound on $L_b$ for a given $N$:\n$$ L_b \\leq N - 600 $$\n\nConstraint 2: The total algorithmic latency must not exceed the budget $L_{\\max} = 1440$ samples. The latency is given as $M + L_b - 2$.\n$$ M + L_b - 2 \\leq L_{\\max} \\implies 601 + L_b - 2 \\leq 1440 \\implies L_b + 599 \\leq 1440 $$\nThis provides a fixed upper bound on $L_b$:\n$$ L_b \\leq 1440 - 599 \\implies L_b \\leq 841 $$\n\nConstraint 3: The DFT size $N$ must be a power of two, i.e., $N = 2^k$ for some positive integer $k$.\n\nTo minimize the cost function $C_{sample}(N, L_b) = \\frac{N (\\log_2(N) + 1)}{L_b}$, for any fixed value of $N$, we must choose the largest possible value for $L_b$. Combining the two upper bounds on $L_b$, we find that the optimal $L_b$ for a given $N$ is:\n$$ L_{b,\\mathrm{opt}}(N) = \\min(N - 600, 841) $$\nWe must also ensure that $L_b \\geq 1$, which implies from the first constraint that $N - 600 \\geq 1$, so $N \\geq 601$. Since $N$ must be a power of two, the smallest possible value for $N$ is $2^{10} = 1024$, because $2^9 = 512  601$.\n\nSubstituting $L_{b,\\mathrm{opt}}(N)$ into the cost function, we obtain a cost function that depends only on $N$:\n$$ C(N) = \\frac{N (\\log_2(N) + 1)}{\\min(N - 600, 841)} $$\nThe behavior of this function depends on which term in the minimum operator is active. The crossover point occurs when $N - 600 = 841$, which is at $N = 1441$.\n\nCase 1: $N  1441$.\nIn this range, $N - 600  841$, so $\\min(N - 600, 841) = N - 600$. The cost function is:\n$$ C_1(N) = \\frac{N (\\log_2(N) + 1)}{N - 600} $$\nThe only power of two that satisfies $601 \\leq N  1441$ is $N = 1024$.\nFor $N = 1024$, the optimal block size is $L_b = 1024 - 600 = 424$. The corresponding cost is:\n$$ C(1024) = \\frac{1024 (\\log_2(1024) + 1)}{424} = \\frac{1024 (10 + 1)}{424} = \\frac{1024 \\times 11}{424} = \\frac{11264}{424} $$\n\nCase 2: $N \\geq 1441$.\nIn this range, $N - 600 \\geq 841$, so $\\min(N - 600, 841) = 841$. The optimal $L_b$ is fixed at $841$. The cost function is:\n$$ C_2(N) = \\frac{N (\\log_2(N) + 1)}{841} $$\nWe must find the power-of-two $N \\geq 1441$ that minimizes $C_2(N)$. Let us examine the numerator $f(N) = N (\\log_2(N) + 1)$. Its derivative with respect to $N$ is $f'(N) = \\log_2(N) + 1 + \\frac{1}{\\ln(2)}$. For $N \\geq 1441$, this derivative is clearly positive, meaning $f(N)$ is a strictly increasing function of $N$. Therefore, $C_2(N)$ is also strictly increasing for $N \\geq 1441$. The minimum value of $C_2(N)$ in this region will occur at the smallest possible power of two for $N$, which is $N = 2^{11} = 2048$.\nFor $N = 2048$, the optimal block size is $L_b = 841$. The corresponding cost is:\n$$ C(2048) = \\frac{2048 (\\log_2(2048) + 1)}{841} = \\frac{2048 (11 + 1)}{841} = \\frac{2048 \\times 12}{841} = \\frac{24576}{841} $$\n\nFinally, we must compare the minimum costs from the two cases to find the global minimum.\n$$ C(1024) = \\frac{11264}{424} = \\frac{1408}{53} \\approx 26.566 $$\n$$ C(2048) = \\frac{24576}{841} \\approx 29.222 $$\nSince $\\frac{11264}{424}  \\frac{24576}{841}$, the minimum average computational cost is achieved in Case 1. The unique optimal parameters are therefore $N_{\\mathrm{opt}} = 1024$ and the corresponding block size $L_{b,\\mathrm{opt}} = 1024 - 600 = 424$.\n\nThis pair $(N_{\\mathrm{opt}}, L_{b,\\mathrm{opt}}) = (1024, 424)$ satisfies all constraints:\n1.  $N = 1024 \\geq L_b + 600 = 424 + 600 = 1024$. The condition holds with equality.\n2.  $L_b = 424 \\leq 841$. The condition holds.\n3.  $N = 1024$ is a power of two.\n\nThe solution is optimal because we have systematically searched the entire feasible space of discrete $(N, L_b)$ pairs by first optimizing $L_b$ for a given $N$ and then analyzing the resulting cost function of $N$ over its valid domain of powers of two.\nThe optimal pair is $(N_{\\mathrm{opt}}, L_{b,\\mathrm{opt}}) = (1024, 424)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1024  424\n\\end{pmatrix}\n}\n$$", "id": "2880451"}]}