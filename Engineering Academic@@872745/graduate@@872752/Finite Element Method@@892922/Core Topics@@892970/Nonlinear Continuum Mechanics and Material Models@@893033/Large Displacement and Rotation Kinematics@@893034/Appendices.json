{"hands_on_practices": [{"introduction": "Mastering large deformation kinematics begins with a solid grasp of the fundamental tensors that quantify deformation. This exercise provides a direct application of these core definitions, starting from a given motion map. By calculating the deformation gradient ($\\boldsymbol{F}$), the right and left Cauchy-Green tensors ($\\boldsymbol{C}$ and $\\boldsymbol{B}$), and the Jacobian determinant ($J$), you will build a concrete understanding of how these quantities are derived and what they represent [@problem_id:2573025].", "problem": "Consider a three-dimensional continuum body analyzed within the framework of large-deformation kinematics used in the finite element method. Let the motion be defined by the mapping from the reference configuration coordinates $\\boldsymbol{X}=\\left(X_{1},X_{2},X_{3}\\right)$ to the current configuration coordinates $\\boldsymbol{x}=\\boldsymbol{\\varphi}(\\boldsymbol{X})$ given by\n$$\n\\boldsymbol{x}=\\boldsymbol{\\varphi}(\\boldsymbol{X})=(1+\\epsilon)X_{1}\\,\\boldsymbol{e}_{1}+(1-\\epsilon)X_{2}\\,\\boldsymbol{e}_{2}+X_{3}\\,\\boldsymbol{e}_{3},\n$$\nwhere $\\epsilon$ is a finite constant satisfying $|\\epsilon|<1$ to ensure an invertible, orientation-preserving deformation, and $\\{\\boldsymbol{e}_{1},\\boldsymbol{e}_{2},\\boldsymbol{e}_{3}\\}$ is the fixed spatial basis. Using only core kinematic definitions, derive exactly (without any linearization in $\\epsilon$) the deformation gradient $\\boldsymbol{F}$, the right Cauchy–Green deformation tensor $\\boldsymbol{C}$, the left Cauchy–Green deformation tensor $\\boldsymbol{B}$, and the Jacobian determinant $J$ as functions of $\\epsilon$.\n\nUse the following fundamental definitions: the deformation gradient $\\boldsymbol{F}$ is the gradient of the motion with respect to the reference coordinates, the right Cauchy–Green tensor is $\\boldsymbol{C}=\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$, the left Cauchy–Green tensor is $\\boldsymbol{B}=\\boldsymbol{F} \\boldsymbol{F}^{\\mathsf{T}}$, and the Jacobian is $J=\\det \\boldsymbol{F}$.\n\nAnswer specification:\n- Provide exact expressions in terms of $\\epsilon$. Do not assume $\\epsilon$ is small.\n- No rounding is required.\n- No units are required.\n- Express your final answer by listing the entries of $\\boldsymbol{F}$, $\\boldsymbol{C}$, and $\\boldsymbol{B}$ in row-major order (i.e., $11$, $12$, $13$, $21$, $22$, $23$, $31$, $32$, $33$ for each tensor), followed by $J$, all concatenated into a single row matrix.", "solution": "We work from the standard kinematic definitions for large deformations. The motion is given componentwise by\n$$\nx_{1}=(1+\\epsilon)X_{1},\\quad x_{2}=(1-\\epsilon)X_{2},\\quad x_{3}=X_{3}.\n$$\nBy definition, the deformation gradient $\\boldsymbol{F}$ is the gradient of $\\boldsymbol{x}$ with respect to $\\boldsymbol{X}$,\n$$\n\\boldsymbol{F}=\\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{X}}=\\begin{bmatrix}\n\\frac{\\partial x_{1}}{\\partial X_{1}} & \\frac{\\partial x_{1}}{\\partial X_{2}} & \\frac{\\partial x_{1}}{\\partial X_{3}}\\\n$$4pt]\n\\frac{\\partial x_{2}}{\\partial X_{1}} & \\frac{\\partial x_{2}}{\\partial X_{2}} & \\frac{\\partial x_{2}}{\\partial X_{3}}\\\n$$4pt]\n\\frac{\\partial x_{3}}{\\partial X_{1}} & \\frac{\\partial x_{3}}{\\partial X_{2}} & \\frac{\\partial x_{3}}{\\partial X_{3}}\n\\end{bmatrix}.\n$$\nFrom the component expressions, we obtain\n$$\n\\frac{\\partial x_{1}}{\\partial X_{1}}=1+\\epsilon,\\quad \\frac{\\partial x_{1}}{\\partial X_{2}}=0,\\quad \\frac{\\partial x_{1}}{\\partial X_{3}}=0,\\\\\n\\frac{\\partial x_{2}}{\\partial X_{1}}=0,\\quad \\frac{\\partial x_{2}}{\\partial X_{2}}=1-\\epsilon,\\quad \\frac{\\partial x_{2}}{\\partial X_{3}}=0,\\\\\n\\frac{\\partial x_{3}}{\\partial X_{1}}=0,\\quad \\frac{\\partial x_{3}}{\\partial X_{2}}=0,\\quad \\frac{\\partial x_{3}}{\\partial X_{3}}=1.\n$$\nTherefore,\n$$\n\\boldsymbol{F}=\\begin{bmatrix}\n1+\\epsilon & 0 & 0\\\\\n0 & 1-\\epsilon & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}.\n$$\nThe right Cauchy–Green deformation tensor is defined by $\\boldsymbol{C}=\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$. Since $\\boldsymbol{F}$ is diagonal, $\\boldsymbol{F}^{\\mathsf{T}}=\\boldsymbol{F}$ and $\\boldsymbol{C}$ is simply the diagonal matrix whose diagonal entries are the squares of those of $\\boldsymbol{F}$:\n$$\n\\boldsymbol{C}=\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}=\\begin{bmatrix}\n(1+\\epsilon)^{2} & 0 & 0\\\\\n0 & (1-\\epsilon)^{2} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}.\n$$\nSimilarly, the left Cauchy–Green deformation tensor is $\\boldsymbol{B}=\\boldsymbol{F} \\boldsymbol{F}^{\\mathsf{T}}$, which for diagonal $\\boldsymbol{F}$ is identical to $\\boldsymbol{C}$:\n$$\n\\boldsymbol{B}=\\boldsymbol{F} \\boldsymbol{F}^{\\mathsf{T}}=\\begin{bmatrix}\n(1+\\epsilon)^{2} & 0 & 0\\\\\n0 & (1-\\epsilon)^{2} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}.\n$$\nFinally, the Jacobian determinant is defined by $J=\\det \\boldsymbol{F}$. For diagonal $\\boldsymbol{F}$,\n$$\nJ=\\det \\boldsymbol{F}=(1+\\epsilon)(1-\\epsilon)\\cdot 1=1-\\epsilon^{2}.\n$$\nTo adhere to the requested output format, we now list the entries of $\\boldsymbol{F}$, $\\boldsymbol{C}$, and $\\boldsymbol{B}$ in row-major order, followed by $J$. Row-major order means listing $(11,12,13,21,22,23,31,32,33)$ for each tensor. Thus,\n- For $\\boldsymbol{F}$: $(1+\\epsilon,\\,0,\\,0,\\,0,\\,(1-\\epsilon),\\,0,\\,0,\\,0,\\,1)$.\n- For $\\boldsymbol{C}$: $((1+\\epsilon)^{2},\\,0,\\,0,\\,0,\\,(1-\\epsilon)^{2},\\,0,\\,0,\\,0,\\,1)$.\n- For $\\boldsymbol{B}$: $((1+\\epsilon)^{2},\\,0,\\,0,\\,0,\\,(1-\\epsilon)^{2},\\,0,\\,0,\\,0,\\,1)$.\n- Then $J=1-\\epsilon^{2}$.\nConcatenating these yields the requested single row matrix.", "answer": "$$\\boxed{\\begin{pmatrix}\n1+\\epsilon & 0 & 0 & 0 & 1-\\epsilon & 0 & 0 & 0 & 1 & (1+\\epsilon)^{2} & 0 & 0 & 0 & (1-\\epsilon)^{2} & 0 & 0 & 0 & 1 & (1+\\epsilon)^{2} & 0 & 0 & 0 & (1-\\epsilon)^{2} & 0 & 0 & 0 & 1 & 1-\\epsilon^{2}\n\\end{pmatrix}}$$", "id": "2573025"}, {"introduction": "A central concept in large-rotation kinematics is the polar decomposition, which uniquely separates a deformation into a pure stretch followed by a rigid rotation. This practice explores the classic case of simple shear, a deformation that often leads to the counter-intuitive insight that a seemingly 'pure shear' motion inherently contains a rotational component. By explicitly deriving the rotation tensor $\\boldsymbol{R}$ and stretch tensor $\\boldsymbol{U}$, you will gain a deeper physical intuition for how deformation and rotation are coupled in the finite-strain regime [@problem_id:2573030].", "problem": "Consider a planar simple shear deformation of a continuous body described by the motion $\\boldsymbol{\\varphi}:\\mathbb{R}^{2}\\to\\mathbb{R}^{2}$ given in Cartesian coordinates by\n$$\nx_{1} = X_{1} + \\gamma X_{2}, \\quad x_{2} = X_{2},\n$$\nwhere $\\gamma \\in \\mathbb{R}$ is a prescribed shear parameter, $\\boldsymbol{X} = (X_{1},X_{2})$ are the reference coordinates, and $\\boldsymbol{x} = (x_{1},x_{2})$ are the current coordinates. Let $\\boldsymbol{F} = \\nabla_{\\! \\boldsymbol{X}} \\boldsymbol{\\varphi}$ be the deformation gradient. Use the right polar decomposition to write $\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}$, where $\\boldsymbol{R}$ is a proper orthogonal rotation tensor and $\\boldsymbol{U}$ is a symmetric positive-definite right stretch tensor. Starting only from the kinematic definitions $\\boldsymbol{F} = \\partial \\boldsymbol{\\varphi}/\\partial \\boldsymbol{X}$ and $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F} = \\boldsymbol{U}^{2}$, derive explicit closed-form expressions for $\\boldsymbol{R}$ and $\\boldsymbol{U}$ in terms of $\\gamma$, and identify the shear-induced rigid-body rotation angle $\\phi$ associated with $\\boldsymbol{R}$. Assume the physically relevant branch in which $\\phi(\\gamma)$ varies continuously with $\\phi(0) = 0$. Provide as your final answer the rotation angle $\\phi(\\gamma)$ in radians as a function of $\\gamma$. Do not include units in your final boxed answer.", "solution": "The motion is given by the mapping $\\boldsymbol{\\varphi}(\\boldsymbol{X}) = \\boldsymbol{x}$, with components:\n$$\nx_{1} = X_{1} + \\gamma X_{2}\n$$\n$$\nx_{2} = X_{2}\n$$\nThe deformation gradient tensor $\\boldsymbol{F}$ is defined as $\\boldsymbol{F} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{X}}$, with components $F_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}$. We compute the components of $\\boldsymbol{F}$:\n$$\nF_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{1} + \\gamma X_{2}) = 1\n$$\n$$\nF_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{1} + \\gamma X_{2}) = \\gamma\n$$\n$$\nF_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{2}) = 0\n$$\n$$\nF_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{2}) = 1\n$$\nIn matrix form, the deformation gradient is:\n$$\n\\boldsymbol{F} = \\begin{pmatrix} 1 & \\gamma \\\\ 0 & 1 \\end{pmatrix}\n$$\nThe right Cauchy-Green deformation tensor $\\boldsymbol{C}$ is defined as $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$. We calculate $\\boldsymbol{C}$:\n$$\n\\boldsymbol{C} = \\begin{pmatrix} 1 & 0 \\\\ \\gamma & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\gamma \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} (1)(1)+(0)(0) & (1)(\\gamma)+(0)(1) \\\\ (\\gamma)(1)+(1)(0) & (\\gamma)(\\gamma)+(1)(1) \\end{pmatrix} = \\begin{pmatrix} 1 & \\gamma \\\\ \\gamma & 1+\\gamma^{2} \\end{pmatrix}\n$$\nThe right polar decomposition is $\\boldsymbol{F} = \\boldsymbol{R}\\boldsymbol{U}$, where $\\boldsymbol{U}$ is the right stretch tensor, given by the unique positive-definite square root of $\\boldsymbol{C}$, i.e., $\\boldsymbol{U} = \\sqrt{\\boldsymbol{C}}$. For a $2 \\times 2$ symmetric positive-definite matrix $\\boldsymbol{A}$, its square root is given by the formula:\n$$\n\\sqrt{\\boldsymbol{A}} = \\frac{1}{\\sqrt{\\operatorname{tr}(\\boldsymbol{A}) + 2\\sqrt{\\det(\\boldsymbol{A})}}} (\\boldsymbol{A} + \\sqrt{\\det(\\boldsymbol{A})}\\boldsymbol{I})\n$$\nFor our tensor $\\boldsymbol{C}$, we have $\\operatorname{tr}(\\boldsymbol{C}) = 1 + (1+\\gamma^{2}) = 2+\\gamma^{2}$ and $\\det(\\boldsymbol{C}) = (1)(1+\\gamma^{2}) - (\\gamma)(\\gamma) = 1$.\nSubstituting these into the formula for $\\boldsymbol{U} = \\sqrt{\\boldsymbol{C}}$:\n$$\n\\boldsymbol{U} = \\frac{1}{\\sqrt{(2+\\gamma^{2}) + 2\\sqrt{1}}} \\left( \\boldsymbol{C} + \\sqrt{1}\\boldsymbol{I} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} (\\boldsymbol{C} + \\boldsymbol{I})\n$$\n$$\n\\boldsymbol{U} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\left( \\begin{pmatrix} 1 & \\gamma \\\\ \\gamma & 1+\\gamma^{2} \\end{pmatrix} + \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2 & \\gamma \\\\ \\gamma & 2+\\gamma^{2} \\end{pmatrix}\n$$\nThis is the explicit expression for the right stretch tensor $\\boldsymbol{U}$.\n\nNext, we find the rotation tensor $\\boldsymbol{R}$ from the relation $\\boldsymbol{R} = \\boldsymbol{F}\\boldsymbol{U}^{-1}$. First, we compute the inverse of $\\boldsymbol{U}$. Since $\\det(\\boldsymbol{U}) = \\det(\\sqrt{\\boldsymbol{C}}) = \\sqrt{\\det(\\boldsymbol{C})} = 1$, we can use the formula for the inverse of a $2 \\times 2$ matrix with determinant $1$:\n$$\n\\boldsymbol{U}^{-1} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2} & -\\gamma \\\\ -\\gamma & 2 \\end{pmatrix}\n$$\nNow we compute $\\boldsymbol{R}$:\n$$\n\\boldsymbol{R} = \\boldsymbol{F}\\boldsymbol{U}^{-1} = \\begin{pmatrix} 1 & \\gamma \\\\ 0 & 1 \\end{pmatrix} \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2} & -\\gamma \\\\ -\\gamma & 2 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} (1)(2+\\gamma^{2})+(\\gamma)(-\\gamma) & (1)(-\\gamma)+(\\gamma)(2) \\\\ (0)(2+\\gamma^{2})+(1)(-\\gamma) & (0)(-\\gamma)+(1)(2) \\end{pmatrix}\n$$\n$$\n\\boldsymbol{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}-\\gamma^{2} & -\\gamma+2\\gamma \\\\ -\\gamma & 2 \\end{pmatrix} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2 & \\gamma \\\\ -\\gamma & 2 \\end{pmatrix}\n$$\nThis is the explicit expression for the proper orthogonal rotation tensor $\\boldsymbol{R}$.\nA general $2\\mathrm{D}$ counter-clockwise rotation by an angle $\\phi$ is represented by the matrix:\n$$\n\\boldsymbol{R}(\\phi) = \\begin{pmatrix} \\cos\\phi & -\\sin\\phi \\\\ \\sin\\phi & \\cos\\phi \\end{pmatrix}\n$$\nBy comparing the components of our computed $\\boldsymbol{R}$ with this standard form, we can identify $\\phi$:\n$$\n\\cos\\phi = \\frac{2}{\\sqrt{4+\\gamma^{2}}}\n$$\n$$\n\\sin\\phi = \\frac{-\\gamma}{\\sqrt{4+\\gamma^{2}}}\n$$\nTo find $\\phi$, we can compute the tangent:\n$$\n\\tan\\phi = \\frac{\\sin\\phi}{\\cos\\phi} = \\frac{-\\gamma/\\sqrt{4+\\gamma^{2}}}{2/\\sqrt{4+\\gamma^{2}}} = -\\frac{\\gamma}{2}\n$$\nThis gives the rotation angle $\\phi$ as a function of the shear parameter $\\gamma$:\n$$\n\\phi(\\gamma) = \\arctan\\left(-\\frac{\\gamma}{2}\\right)\n$$\nUsing the property that $\\arctan(-x) = -\\arctan(x)$, we can write this as:\n$$\n\\phi(\\gamma) = -\\arctan\\left(\\frac{\\gamma}{2}\\right)\n$$\nWe must verify this solution against the given physical constraint that $\\phi(\\gamma)$ varies continuously with $\\phi(0) = 0$. The function $\\phi(\\gamma) = -\\arctan(\\gamma/2)$ is continuous for all $\\gamma \\in \\mathbb{R}$. At $\\gamma=0$, we have $\\phi(0) = -\\arctan(0) = 0$. The condition is satisfied. This expression thus represents the physically relevant rotation angle. The negative sign indicates that for a positive shear $\\gamma > 0$, the induced rigid-body rotation is clockwise.", "answer": "$$\\boxed{-\\arctan\\left(\\frac{\\gamma}{2}\\right)}$$", "id": "2573030"}, {"introduction": "Bridging theoretical kinematics with computational practice is essential for finite element analysis, especially when handling large rotations over many time steps. This programming exercise challenges you to implement and compare two popular methods for updating rotations: quaternion composition and direct matrix multiplication using the exponential map. By evaluating their numerical stability and accuracy, you will uncover the practical challenges of floating-point drift and the importance of algorithmic choices, such as re-normalization, in robust simulations [@problem_id:2573012].", "problem": "Implement a program that compares two rotation update schemes for large displacement and rotation kinematics in three dimensions. The two schemes are: (i) a unit-quaternion composition update with per-step re-normalization, and (ii) a rotation-matrix update using the matrix exponential of the per-step rotation vector without any re-orthonormalization during accumulation. The aim is to evaluate numerical stability and accuracy of both schemes over many incremental updates.\n\nYou must start from the following fundamental bases:\n- The rigid rotation kinematics is represented by a proper orthogonal matrix $\\boldsymbol{R} \\in \\mathrm{SO}(3)$ with $\\boldsymbol{R}^{\\mathsf{T}} \\boldsymbol{R} = \\boldsymbol{I}$ and $\\det(\\boldsymbol{R}) = 1$.\n- A small incremental rotation can be represented by a rotation vector $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ whose norm is the rotation angle in radians, and whose direction is the rotation axis.\n- The matrix exponential of the skew-symmetric matrix $[\\boldsymbol{\\varphi}]_{\\times}$ maps the rotation vector $\\boldsymbol{\\varphi}$ to $\\boldsymbol{R} = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)$.\n- A unit quaternion $q \\in \\mathbb{R}^4$ with unit norm represents a rotation in $\\mathrm{SO}(3)$, and quaternion multiplication composes rotations; normalization of $q$ maintains unit length.\n\nTask requirements:\n1. Implement a function that, given a per-step rotation vector $\\boldsymbol{\\varphi}_k$ in radians, constructs the associated unit quaternion increment and composes it with the current quaternion. After each composition, re-normalize the quaternion. Initialize with the identity quaternion. At the end, convert the quaternion to a rotation matrix $\\boldsymbol{R}_{\\mathrm{quat}}$.\n2. Implement a function that, given the same per-step rotation vector $\\boldsymbol{\\varphi}_k$, constructs the corresponding incremental rotation matrix using the matrix exponential $\\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ (use a numerically stable formulation for small angles), and left-multiplies it to the current rotation matrix without any re-orthonormalization. Initialize with the identity matrix. At the end, denote the accumulated matrix as $\\boldsymbol{R}_{\\mathrm{mat}}$.\n3. For each test case specified below, compute the following quantitative diagnostics:\n   - Orthogonality error for each method: $e_{\\mathrm{orth}}(\\boldsymbol{R}) = \\left\\|\\boldsymbol{R}^{\\mathsf{T}} \\boldsymbol{R} - \\boldsymbol{I}\\right\\|_F$.\n   - Determinant deviation for each method: $e_{\\det}(\\boldsymbol{R}) = \\left|\\det(\\boldsymbol{R}) - 1\\right|$.\n   - Rotation angle error with respect to a reference rotation matrix $\\boldsymbol{R}_{\\mathrm{ref}}$: $e_{\\angle}(\\boldsymbol{R}, \\boldsymbol{R}_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\dfrac{\\mathrm{tr}\\left(\\boldsymbol{R}^{\\mathsf{T}} \\boldsymbol{R}_{\\mathrm{ref}}\\right) - 1}{2}, -1, 1\\right)\\right)$, expressed in radians.\n4. Reference rotation $\\boldsymbol{R}_{\\mathrm{ref}}$:\n   - For test cases where the per-step rotation vector is constant, the exact reference is $\\boldsymbol{R}_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$, since the exponentials commute when the incremental rotation vector is constant. Here, $N$ is the number of steps.\n   - For test cases where the per-step rotation vector varies with the step index, define $\\boldsymbol{R}_{\\mathrm{ref}}$ as the orthogonal projection onto $\\mathrm{SO}(3)$ (via the polar decomposition using singular value decomposition) of the exact product $\\prod_{k=1}^{N} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ computed in finite precision. This defines a stable reference without in-step re-orthonormalization.\n\nAngle unit requirement:\n- All angles and rotation vectors must be treated in radians. All reported angle errors must be expressed in radians.\n\nTest suite:\nUse the following four test cases. For each case, the per-step rotation vector is given in radians, and $N$ is the number of steps.\n- Test $1$ (constant increments, multi-axis):\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.001,\\,-0.002,\\,0.0015\\,]$, $N = 10000$.\n  - Reference: $\\boldsymbol{R}_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$.\n- Test $2$ (constant increments, single-axis, moderate step size):\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.01,\\,0.0,\\,0.0\\,]$, $N = 3000$.\n  - Reference: $\\boldsymbol{R}_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$.\n- Test $3$ (time-varying increments, non-commutative accumulation):\n  - For $k = 0,1,\\dots,N-1$ with $N=8000$, define $\\boldsymbol{\\varphi}_k = s \\,[\\,\\cos(\\alpha k),\\, \\sin(\\alpha k),\\, 0.5\\,]$ with $s = 0.002$ and $\\alpha = 0.005$.\n  - Reference: Let $\\widehat{\\boldsymbol{R}} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ and define $\\boldsymbol{R}_{\\mathrm{ref}}$ as the closest rotation via polar decomposition of $\\widehat{\\boldsymbol{R}}$.\n- Test $4$ (near-zero increments, extreme small-angle robustness):\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,10^{-12},\\, -2\\times 10^{-12},\\, 3\\times 10^{-12}\\,]$, $N = 1000$.\n  - Reference: $\\boldsymbol{R}_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$.\n\nYour program must:\n- Implement numerically stable small-angle formulas for both quaternion increments and matrix exponentials to avoid division by zero for $\\|\\boldsymbol{\\varphi}\\| \\to 0$.\n- Produce for each test case the six diagnostics in the following order as floating-point numbers:\n  1. $e_{\\mathrm{orth}}(\\boldsymbol{R}_{\\mathrm{quat}})$\n  2. $e_{\\mathrm{orth}}(\\boldsymbol{R}_{\\mathrm{mat}})$\n  3. $e_{\\det}(\\boldsymbol{R}_{\\mathrm{quat}})$\n  4. $e_{\\det}(\\boldsymbol{R}_{\\mathrm{mat}})$\n  5. $e_{\\angle}(\\boldsymbol{R}_{\\mathrm{quat}}, \\boldsymbol{R}_{\\mathrm{ref}})$ in radians\n  6. $e_{\\angle}(\\boldsymbol{R}_{\\mathrm{mat}}, \\boldsymbol{R}_{\\mathrm{ref}})$ in radians\n\nFinal output format:\n- Your program should produce a single line of output containing the concatenated results for all four test cases as a comma-separated list enclosed in square brackets. The list must contain $24$ floating-point numbers in the order specified per test case and in the order of the tests $1$ through $4$ (for example, $[r_1,r_2,\\dots,r_{24}]$). No additional text must be printed.", "solution": "We base the construction on rigid rotation kinematics and the exponential map between the Lie algebra of skew-symmetric matrices and the Lie group of rotation matrices. A rotation matrix $\\boldsymbol{R} \\in \\mathrm{SO}(3)$ satisfies $\\boldsymbol{R}^{\\mathsf{T}}\\boldsymbol{R} = \\boldsymbol{I}$ and $\\det(\\boldsymbol{R}) = 1$. A rotation vector $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ encodes a rotation by angle $\\theta = \\|\\boldsymbol{\\varphi}\\|$ about the unit axis $\\mathbf{u} = \\boldsymbol{\\varphi}/\\theta$ when $\\theta \\neq 0$. The associated skew-symmetric matrix is $[\\boldsymbol{\\varphi}]_{\\times}$, defined for $\\boldsymbol{\\varphi} = [\\varphi_1,\\varphi_2,\\varphi_3]^{\\mathsf{T}}$ by\n$$\n[\\boldsymbol{\\varphi}]_{\\times} =\n\\begin{bmatrix}\n0 & -\\varphi_3 & \\varphi_2\\\\\n\\varphi_3 & 0 & -\\varphi_1\\\\\n-\\varphi_2 & \\varphi_1 & 0\n\\end{bmatrix}.\n$$\nThe matrix exponential provides the update for a per-step rotation vector $\\boldsymbol{\\varphi}$ via\n$$\n\\boldsymbol{R}_{\\mathrm{inc}} = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)\n= \\boldsymbol{I} + \\frac{\\sin \\theta}{\\theta}[\\boldsymbol{\\varphi}]_{\\times}\n+ \\frac{1 - \\cos \\theta}{\\theta^2}[\\boldsymbol{\\varphi}]_{\\times}^2,\n$$\nwhere $\\boldsymbol{I}$ is the identity matrix and $\\theta = \\|\\boldsymbol{\\varphi}\\|$. This representation follows from Rodrigues' rotation formula. For small $\\theta$, we use series expansions to avoid division by zero:\n$$\n\\frac{\\sin \\theta}{\\theta} = 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120} + \\mathcal{O}(\\theta^6), \\quad\n\\frac{1 - \\cos \\theta}{\\theta^2} = \\frac{1}{2} - \\frac{\\theta^2}{24} + \\frac{\\theta^4}{720} + \\mathcal{O}(\\theta^6).\n$$\nThe matrix-based accumulation without re-orthonormalization is then\n$$\n\\boldsymbol{R}_{k+1}^{\\mathrm{mat}} = \\boldsymbol{R}_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\, \\boldsymbol{R}_k^{\\mathrm{mat}}, \\quad \\boldsymbol{R}_0^{\\mathrm{mat}} = \\boldsymbol{I}.\n$$\nDue to floating-point errors, repeated multiplication can drift away from $\\mathrm{SO}(3)$, causing $\\boldsymbol{R}^{\\mathsf{T}}\\boldsymbol{R} \\neq \\boldsymbol{I}$ and $\\det(\\boldsymbol{R}) \\neq 1$.\n\nAlternatively, a unit quaternion $q = [q_0,q_1,q_2,q_3]^{\\mathsf{T}}$ represents the same rotation with the constraint $\\|q\\|=1$, mapping to a rotation matrix through a smooth homomorphism. The quaternion increment associated with rotation vector $\\boldsymbol{\\varphi}$ is\n$$\nq_{\\mathrm{inc}} = \\begin{bmatrix}\n\\cos(\\theta/2)\\\\\n\\mathbf{u} \\, \\sin(\\theta/2)\n\\end{bmatrix}, \\quad \\theta = \\|\\boldsymbol{\\varphi}\\|, \\ \\mathbf{u} = \n\\begin{cases}\n\\boldsymbol{\\varphi}/\\theta, & \\theta \\neq 0,\\\\\n[0,0,0]^{\\mathsf{T}}, & \\theta = 0,\n\\end{cases}\n$$\nwith the small-angle stabilization\n$$\n\\frac{\\sin(\\theta/2)}{\\theta} = \\frac{1}{2} - \\frac{\\theta^2}{48} + \\frac{\\theta^4}{3840} + \\mathcal{O}(\\theta^6).\n$$\nQuaternion composition of rotations corresponds to quaternion multiplication $\\otimes$. Accumulation proceeds as\n$$\nq_{k+1} = q_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\otimes q_k, \\quad q_0 = [1,0,0,0]^{\\mathsf{T}},\n$$\nwith explicit normalization\n$$\nq_{k+1} \\leftarrow \\frac{q_{k+1}}{\\|q_{k+1}\\|},\n$$\nto mitigate floating-point drift. The final rotation matrix is $\\boldsymbol{R}_{\\mathrm{quat}} = \\mathcal{R}(q_N)$ where $\\mathcal{R}(\\cdot)$ is the quaternion-to-rotation mapping, which preserves orthogonality when $q$ is unit length.\n\nFor validation and stability assessment, we define the following diagnostics for any $3\\times 3$ matrix $\\boldsymbol{R}$:\n- Orthogonality error $e_{\\mathrm{orth}}(\\boldsymbol{R}) = \\|\\boldsymbol{R}^{\\mathsf{T}}\\boldsymbol{R} - \\boldsymbol{I}\\|_F$ (Frobenius norm).\n- Determinant deviation $e_{\\det}(\\boldsymbol{R}) = |\\det(\\boldsymbol{R}) - 1|$.\n- Rotation angle error relative to a reference $\\boldsymbol{R}_{\\mathrm{ref}}$:\n$$\ne_{\\angle}(\\boldsymbol{R}, \\boldsymbol{R}_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\frac{\\operatorname{tr}(\\boldsymbol{R}^{\\mathsf{T}} \\boldsymbol{R}_{\\mathrm{ref}}) - 1}{2}, \\,-1,\\, 1\\right)\\right),\n$$\nwhich yields the principal angle in radians of the relative rotation $\\Delta \\boldsymbol{R} = \\boldsymbol{R}^{\\mathsf{T}} \\boldsymbol{R}_{\\mathrm{ref}}$. Clipping ensures numerical robustness against round-off violating the domain of the inverse cosine.\n\nFor constant per-step increments $\\boldsymbol{\\varphi}_{\\text{step}}$, the exact reference is\n$$\n\\boldsymbol{R}_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right),\n$$\nbecause $[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}$ commutes with itself, and hence $\\left(\\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)\\right)^N = \\exp\\left(N \\,[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)$. For time-varying increments $\\boldsymbol{\\varphi}_k$, non-commutativity prevents a closed form. We therefore compute the product\n$$\n\\widehat{\\boldsymbol{R}} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right),\n$$\nand project it onto $\\mathrm{SO}(3)$ via the polar decomposition. Let $\\widehat{\\boldsymbol{R}} = \\boldsymbol{U} \\Sigma \\boldsymbol{V}^{\\mathsf{T}}$ be the singular value decomposition, then the closest rotation (in the Frobenius norm) is\n$$\n\\boldsymbol{R}_{\\mathrm{ref}} = \\boldsymbol{U} \\, \\operatorname{diag}(1,1,\\operatorname{sign}(\\det(\\boldsymbol{U}\\boldsymbol{V}^{\\mathsf{T}}))) \\, \\boldsymbol{V}^{\\mathsf{T}}.\n$$\n\nAlgorithmic design:\n1. Implement a robust function to map $\\boldsymbol{\\varphi}$ to $\\boldsymbol{R}_{\\mathrm{inc}}$ using the series expansions for $\\sin\\theta/\\theta$ and $(1-\\cos\\theta)/\\theta^2$ for small $\\theta$.\n2. Implement quaternion increment mapping using a robust evaluation of $\\sin(\\theta/2)/\\theta$ for small $\\theta$ and compose by quaternion multiplication, with normalization after each step.\n3. Simulate both accumulations for each test case to obtain $\\boldsymbol{R}_{\\mathrm{quat}}$ and $\\boldsymbol{R}_{\\mathrm{mat}}$.\n4. Build the reference $\\boldsymbol{R}_{\\mathrm{ref}}$:\n   - For constant cases: as a single exponential at $N \\boldsymbol{\\varphi}_{\\text{step}}$.\n   - For the varying case: as the polar factor of the direct product of exponentials.\n5. Compute the diagnostics $e_{\\mathrm{orth}}$, $e_{\\det}$, and $e_{\\angle}$ for both $\\boldsymbol{R}_{\\mathrm{quat}}$ and $\\boldsymbol{R}_{\\mathrm{mat}}$.\n6. Output the $24$ floating-point results in the specified order:\n   - For each test $i \\in \\{1,2,3,4\\}$, output\n     $[\\,e_{\\mathrm{orth}}(\\boldsymbol{R}_{\\mathrm{quat}}^{(i)}),\\ e_{\\mathrm{orth}}(\\boldsymbol{R}_{\\mathrm{mat}}^{(i)}),\\ e_{\\det}(\\boldsymbol{R}_{\\mathrm{quat}}^{(i)}),\\ e_{\\det}(\\boldsymbol{R}_{\\mathrm{mat}}^{(i)}),\\ e_{\\angle}(\\boldsymbol{R}_{\\mathrm{quat}}^{(i)}, \\boldsymbol{R}_{\\mathrm{ref}}^{(i)}),\\ e_{\\angle}(\\boldsymbol{R}_{\\mathrm{mat}}^{(i)}, \\boldsymbol{R}_{\\mathrm{ref}}^{(i)})\\,]$.\n   Concatenate the four sublists into a single list and print as a single line.\n\nExpected qualitative outcomes:\n- The quaternion method with per-step normalization should maintain $e_{\\mathrm{orth}}$ and $e_{\\det}$ near machine precision across all tests, demonstrating high numerical stability.\n- The matrix exponential accumulation without re-orthonormalization is expected to exhibit increasing $e_{\\mathrm{orth}}$ and $e_{\\det}$ with the number of steps, indicating drift from $\\mathrm{SO}(3)$.\n- The angle errors $e_{\\angle}$ for the quaternion method should generally be smaller or comparable to the matrix method across tests; differences become more pronounced with many steps or near singular configurations, such as long sequences or extremely small angles where stable series expansions are essential.\n\nAll angles must be expressed in radians. No physical units are involved besides the angle unit. The program must print exactly one line: a single list of $24$ floating-point numbers as specified, with no additional text.", "answer": "```python\nimport numpy as np\n\ndef skew(v):\n    \"\"\"Return the 3x3 skew-symmetric matrix of a 3-vector v.\"\"\"\n    vx, vy, vz = v\n    return np.array([[0.0, -vz,  vy],\n                     [vz,  0.0, -vx],\n                     [-vy, vx,  0.0]], dtype=float)\n\ndef safe_sinc(x):\n    \"\"\"Return sin(x)/x with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax < 1e-8:\n        x2 = x*x\n        # 1 - x^2/6 + x^4/120\n        return 1.0 - x2/6.0 + x2*x2/120.0\n    return np.sin(x)/x\n\ndef safe_one_minus_cos_over_x2(x):\n    \"\"\"Return (1-cos(x))/x^2 with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax < 1e-8:\n        x2 = x*x\n        # 1/2 - x^2/24 + x^4/720\n        return 0.5 - x2/24.0 + x2*x2/720.0\n    return (1.0 - np.cos(x))/(x*x)\n\ndef exp_rotvec(phi):\n    \"\"\"\n    Compute rotation matrix R = exp([phi]_x) using Rodrigues' formula with\n    stable small-angle handling.\n    \"\"\"\n    theta = np.linalg.norm(phi)\n    A = skew(phi)\n    if theta < 1e-16:\n        # Very small, R ~ I + A\n        return np.eye(3) + A\n    a = safe_sinc(theta)\n    b = safe_one_minus_cos_over_x2(theta)\n    return np.eye(3) + a * A + b * (A @ A)\n\ndef quat_mul(p, q):\n    \"\"\"Hamilton product p ⊗ q for quaternions p=[w,x,y,z], q=[w,x,y,z].\"\"\"\n    pw, px, py, pz = p\n    qw, qx, qy, qz = q\n    w = pw*qw - px*qx - py*qy - pz*qz\n    x = pw*qx + px*qw + py*qz - pz*qy\n    y = pw*qy - px*qz + py*qw + pz*qx\n    z = pw*qz + px*qy - py*qx + pz*qw\n    return np.array([w, x, y, z], dtype=float)\n\ndef quat_normalize(q):\n    n = np.linalg.norm(q)\n    if n == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    return q / n\n\ndef rotvec_to_quat(phi):\n    \"\"\"Map rotation vector phi to unit quaternion q = [w, x, y, z].\"\"\"\n    theta = np.linalg.norm(phi)\n    if theta < 1e-16:\n        # q ≈ [1, 0.5*phi]\n        return quat_normalize(np.array([1.0, 0.5*phi[0], 0.5*phi[1], 0.5*phi[2]], dtype=float))\n    half = 0.5 * theta\n    # sin(half)/theta stabilized\n    s = np.sin(half)\n    c = np.cos(half)\n    scale = s / theta\n    q = np.array([c, scale*phi[0], scale*phi[1], scale*phi[2]], dtype=float)\n    return quat_normalize(q)\n\ndef quat_to_R(q):\n    \"\"\"Convert unit quaternion q=[w,x,y,z] to rotation matrix.\"\"\"\n    w, x, y, z = q\n    # Normalize to avoid drift\n    n = w*w + x*x + y*y + z*z\n    if n == 0.0:\n        w, x, y, z = 1.0, 0.0, 0.0, 0.0\n        n = 1.0\n    s = 2.0 / n\n    wx, wy, wz = s*w*x, s*w*y, s*w*z\n    xx, xy, xz = s*x*x, s*x*y, s*x*z\n    yy, yz, zz = s*y*y, s*y*z, s*z*z\n    R = np.array([\n        [1.0 - (yy + zz), xy - wz,       xz + wy      ],\n        [xy + wz,         1.0 - (xx + zz), yz - wx     ],\n        [xz - wy,         yz + wx,       1.0 - (xx + yy)]\n    ], dtype=float)\n    return R\n\ndef orthogonality_error(R):\n    E = R.T @ R - np.eye(3)\n    return float(np.linalg.norm(E, ord='fro'))\n\ndef det_deviation(R):\n    return float(abs(np.linalg.det(R) - 1.0))\n\ndef angle_error(R, Rref):\n    RtR = R.T @ Rref\n    tr = (np.trace(RtR) - 1.0) / 2.0\n    tr = max(-1.0, min(1.0, tr))\n    return float(np.arccos(tr))\n\ndef project_to_SO3(R):\n    \"\"\"Project a matrix to the nearest rotation matrix via SVD-based polar decomposition.\"\"\"\n    U, S, Vt = np.linalg.svd(R)\n    M = U @ Vt\n    if np.linalg.det(M) < 0.0:\n        # Fix reflection\n        D = np.diag([1.0, 1.0, -1.0])\n        M = U @ D @ Vt\n    return M\n\ndef accumulate_quaternion(increments):\n    q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    for phi in increments:\n        q_inc = rotvec_to_quat(phi)\n        q = quat_mul(q_inc, q)\n        q = quat_normalize(q)\n    return quat_to_R(q)\n\ndef accumulate_matrix(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return R\n\ndef reference_constant(phi_step, N):\n    phi_tot = phi_step * N\n    return exp_rotvec(phi_tot)\n\ndef reference_varying(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return project_to_SO3(R)\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: constant increments, multi-axis\n    phi_step1 = np.array([0.001, -0.002, 0.0015], dtype=float)\n    N1 = 10000\n    inc1 = [phi_step1 for _ in range(N1)]\n    Rref1 = reference_constant(phi_step1, N1)\n    tests.append((inc1, Rref1))\n\n    # Test 2: constant increments, single-axis\n    phi_step2 = np.array([0.01, 0.0, 0.0], dtype=float)\n    N2 = 3000\n    inc2 = [phi_step2 for _ in range(N2)]\n    Rref2 = reference_constant(phi_step2, N2)\n    tests.append((inc2, Rref2))\n\n    # Test 3: varying increments\n    N3 = 8000\n    s = 0.002\n    alpha = 0.005\n    inc3 = []\n    for k in range(N3):\n        vk = np.array([np.cos(alpha * k), np.sin(alpha * k), 0.5], dtype=float)\n        inc3.append(s * vk)\n    Rref3 = reference_varying(inc3)\n    tests.append((inc3, Rref3))\n\n    # Test 4: near-zero increments\n    phi_step4 = np.array([1e-12, -2e-12, 3e-12], dtype=float)\n    N4 = 1000\n    inc4 = [phi_step4 for _ in range(N4)]\n    Rref4 = reference_constant(phi_step4, N4)\n    tests.append((inc4, Rref4))\n\n    return tests\n\ndef solve():\n    tests = build_test_cases()\n    results = []\n    for increments, Rref in tests:\n        Rq = accumulate_quaternion(increments)\n        Rm = accumulate_matrix(increments)\n\n        e_orth_q = orthogonality_error(Rq)\n        e_orth_m = orthogonality_error(Rm)\n        e_det_q = det_deviation(Rq)\n        e_det_m = det_deviation(Rm)\n        e_ang_q = angle_error(Rq, Rref)\n        e_ang_m = angle_error(Rm, Rref)\n\n        results.extend([e_orth_q, e_orth_m, e_det_q, e_det_m, e_ang_q, e_ang_m])\n\n    # Print as a single line list, comma-separated, no spaces\n    # Format floats with scientific notation for consistency\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2573012"}]}