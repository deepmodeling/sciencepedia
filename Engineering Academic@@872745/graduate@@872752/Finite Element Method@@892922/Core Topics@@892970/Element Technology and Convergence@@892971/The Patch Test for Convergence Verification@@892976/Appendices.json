{"hands_on_practices": [{"introduction": "Before writing any code, it is essential to have a clear conceptual understanding of what the patch test is and what constitutes a valid result. This first exercise challenges you to design the correct procedure for a linear patch test, focusing on a non-conforming element where this verification is non-trivial. By distinguishing between correct and incorrect methodologies, you will solidify your understanding of the test's fundamental goal: to confirm consistency by ensuring an element can exactly reproduce a constant strain state across a patch of distorted elements [@problem_id:2405118].", "problem": "A custom-developed, non-conforming $4$-node quadrilateral element is to be verified for correctness in small-strain, linear elasticity in $2$D using the Finite Element Method (FEM). The material is homogeneous and isotropic with Young’s modulus $E$ and Poisson’s ratio $\\nu$. Consider a patch domain $\\Omega$ composed of several such elements, with zero body forces $\\boldsymbol{b}=\\boldsymbol{0}$, and with boundary conditions applied on $\\partial\\Omega$. The goal is to design and execute a linear patch test that determines whether the element passes the fundamental consistency requirement associated with reproducing constant strain states. Which option best describes a correct and sufficient procedure, including acceptance criteria, for the linear patch test of this non-conforming element?\n\nA. Build a patch of at least $2\\times 2$ non-conforming $4$-node quadrilateral elements, allowing element distortion so that isoparametric mappings are nontrivial. Impose on all boundary nodes essential boundary conditions that match a generic linear displacement field in the form $u_{x}(x,y)=a_{0}+a_{1}x+a_{2}y$ and $u_{y}(x,y)=b_{0}+b_{1}x+b_{2}y$ with constants $\\{a_{i},b_{i}\\}$ chosen to produce nonzero constant strains, and set $\\boldsymbol{b}=\\boldsymbol{0}$. Assemble and solve the global system without additional constraints beyond those required to remove rigid body modes. Acceptance criteria: the assembled interior nodal residual forces are exactly zero to machine precision, the recovered stresses inside each element are constant and identical across the patch and match the analytical constant stress from the imposed linear field, the boundary reaction forces equilibrate the constant stress field, and the total strain energy matches the analytical value. Passing these criteria indicates the element passes the linear patch test despite its non-conformity.\n\nB. Test a single non-conforming $4$-node element in isolation by applying a uniform traction on one edge and leaving all other edges free; if the resulting element stiffness matrix is positive definite and the displacement solution is unique, then the element passes the linear patch test.\n\nC. Assemble a $2\\times 2$ patch but prescribe only uniform tractions on the outer boundary corresponding to a constant stress field; do not prescribe any displacements. If the computed average strain over the patch equals the analytical constant strain once the mesh is refined, the element passes the patch test.\n\nD. Use a $3\\times 3$ patch and prescribe quadratic displacement boundary conditions such that $u_{x}(x,y)$ and $u_{y}(x,y)$ include terms $x^{2}$, $xy$, and $y^{2}$. If the computed stress field is exactly linear across the patch, then the element passes the linear patch test.\n\nE. For a $2\\times 2$ patch, impose periodic boundary conditions and compute the rank of the assembled stiffness matrix. If the rank deficiency equals exactly the number of rigid body modes in $2$D, declare that the element passes the patch test because stability and rank sufficiency imply consistency.", "solution": "The problem statement will first be subjected to validation.\n\n### Step 1: Extract Givens\n- Element type: custom-developed, non-conforming $4$-node quadrilateral element.\n- Physics: small-strain, linear elasticity in $2$D.\n- Material: homogeneous and isotropic with Young’s modulus $E$ and Poisson’s ratio $\\nu$.\n- Domain: a patch $\\Omega$ composed of several such elements.\n- Loading: zero body forces, $\\boldsymbol{b}=\\boldsymbol{0}$.\n- Boundary Conditions: applied on $\\partial\\Omega$.\n- Objective: Design and execute a linear patch test to determine if the element passes the fundamental consistency requirement of reproducing constant strain states.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is scrutinized against the validation criteria.\n\n- **Scientifically Grounded:** The problem is set in the context of the Finite Element Method (FEM), a well-established discipline within computational engineering. The patch test is a standard, fundamental verification procedure for finite elements, first proposed by Bruce Irons. The physics described—linear elasticity—is a cornerstone of solid mechanics. All concepts are scientifically sound.\n- **Well-Posed:** The problem asks for the correct procedure for a standard test. It is a conceptual question about methodology, which has a well-defined answer in the literature and practice of FEM.\n- **Objective:** The language is technical and precise. It asks for a \"correct and sufficient procedure,\" which is an objective question within the established theory of FEM.\n- **Completeness and Consistency:** The problem provides all necessary context to understand the question. It specifies the element type (non-conforming $4$-node quad), the physical model (linear elasticity), and the goal (linear patch test for constant strain). There are no contradictions.\n- **Realism and Feasibility:** The scenario described is a common task for developers of new finite elements. It is entirely realistic and feasible.\n- **Structure:** The question is clearly formulated and does not contain ambiguities or circular reasoning.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a standard, clear, and scientifically sound question in computational mechanics. I will now proceed with the solution.\n\nThe core of the problem is the understanding of the **linear patch test**. The patch test is a necessary condition for the convergence of a finite element method. It verifies the element's **consistency**, which is its ability to reproduce a state of constant strain exactly. For conforming elements that contain a complete set of linear polynomials in their shape function basis, passing the patch test is automatically satisfied. However, for **non-conforming** elements, the displacement field is not continuous across element boundaries ($u \\notin C^0(\\Omega)$). This violation of conformity means that convergence is not guaranteed, and the patch test becomes a critical, non-trivial verification step.\n\nA linear patch test is designed to verify the reproduction of a constant strain state. In $2$D linear elasticity, a constant strain state corresponds to a linear displacement field. A general linear displacement field can be written as:\n$$u_x(x,y) = a_0 + a_1 x + a_2 y$$\n$$u_y(x,y) = b_0 + b_1 x + b_2 y$$\nwhere $\\{a_0, a_1, a_2, b_0, b_1, b_2\\}$ are arbitrary constants. The terms $a_0$ and $b_0$ correspond to rigid body translation, while the combination of other terms can represent rigid body rotation. The associated strain components are constant:\n$$\\epsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = a_1$$\n$$\\epsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = b_2$$\n$$\\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x} = a_2 + b_1$$\nThe procedure for the displacement-based patch test is as follows:\n1.  Construct a patch of at least two elements, preferably with irregular geometry, to ensure there is at least one internal node whose degrees of freedom are not prescribed. A $2 \\times 2$ patch is common.\n2.  On the exterior boundary nodes of the patch, impose essential (Dirichlet) boundary conditions by prescribing the nodal displacements according to the linear field $u_x(x,y)$ and $u_y(x,y)$ for specific, non-trivial constants $\\{a_i, b_i\\}$.\n3.  Solve the global system of equations for the unknown displacements of the internal nodes.\n4.  Check the results. The element passes the test if, to machine precision:\n    a. The computed displacements of the internal nodes match the values from the analytical linear displacement field.\n    b. The strains (and stresses, via the constitutive law $\\boldsymbol{\\sigma} = \\mathbf{C}\\boldsymbol{\\epsilon}$) computed within *each* element are constant throughout the element and uniform across the entire patch, matching the analytical values ($a_1, b_2, a_2+b_1$).\n\nNow, each option will be evaluated based on these principles.\n\n**Evaluation of Option A:**\nThis option proposes a procedure with the following steps:\n- `Build a patch of at least 2x2 non-conforming 4-node quadrilateral elements, allowing element distortion...`: This correctly establishes a patch with internal nodes and considers a general case with non-trivial element mappings.\n- `Impose on all boundary nodes essential boundary conditions that match a generic linear displacement field...`: This is the standard, correct method for imposing a constant strain state on the patch.\n- `set b=0`: Correct, this simplifies the test to focus on consistency.\n- `Assemble and solve the global system...`: Correct.\n- **Acceptance criteria:**\n    - `the assembled interior nodal residual forces are exactly zero to machine precision`: This is an equivalent condition to the internal nodal displacements matching the analytical linear field exactly. If nodal displacements are correct, the system is in equilibrium, and residuals are zero. This is a valid check.\n    - `the recovered stresses inside each element are constant and identical across the patch and match the analytical constant stress...`: This is the primary and most direct criterion for passing the patch test. It directly confirms the reproduction of the constant strain/stress state.\n    - `the boundary reaction forces equilibrate the constant stress field, and the total strain energy matches the analytical value`: These are valid global equilibrium and energy checks that must also be satisfied if the local criteria are met.\n- `Passing these criteria indicates the element passes the linear patch test despite its non-conformity.`: This conclusion is correct. Passing this test is the definition of consistency for a non-conforming element.\n\nThis option provides a comprehensive and accurate description of the linear patch test.\n**Verdict: Correct**\n\n**Evaluation of Option B:**\nThis option suggests testing a single isolated element. The patch test, by its very nature, is designed to test the behavior across **inter-element boundaries**, which is the critical point of failure for non-conforming elements. A single-element test cannot evaluate this. Furthermore, it proposes checking if the stiffness matrix is positive definite. This is a test for element **stability** (i.e., it has no spurious zero-energy modes beyond rigid body modes), not **consistency**. Stability is a necessary but not sufficient condition for convergence. Consistency must be tested separately.\n**Verdict: Incorrect**\n\n**Evaluation of Option C:**\nThis option correctly suggests a $2 \\times 2$ patch but proposes applying uniform tractions. While a traction-based patch test is a valid alternative, the option states `do not prescribe any displacements`, which would leave the system singular due to rigid body modes. At a minimum, three displacement degrees of freedom must be constrained to get a unique solution. The most significant flaw is the acceptance criterion: `if the computed average strain over the patch equals the analytical constant strain once the mesh is refined`. The patch test is not a convergence study. It must pass **exactly** (to machine precision) on a **fixed, coarse patch**. The purpose of the patch test is to *predict* convergence, not to measure it as a limit. An element that only reproduces constant strains asymptotically upon mesh refinement **fails** the patch test.\n**Verdict: Incorrect**\n\n**Evaluation of Option D:**\nThis option describes a setup for a **quadratic patch test**, not a linear one. It proposes prescribing `quadratic displacement boundary conditions`, which correspond to a **linear strain field**. A simple $4$-node element, whose shape functions are typically bilinear, is not expected to represent a linear strain field exactly and would fail such a test. The problem explicitly asks for a **linear patch test**, which verifies the ability to reproduce **constant** strains. This option is testing for a higher-order capability that the element is not designed for and is not required for basic convergence.\n**Verdict: Incorrect**\n\n**Evaluation of Option E:**\nThis option suggests checking the rank of the assembled stiffness matrix for a patch with periodic boundary conditions. As with option B, this is a test for **stability**, not **consistency**. The statement `stability and rank sufficiency imply consistency` is fundamentally false. A stable element can still be inconsistent and fail to converge. For example, an element might have the correct rank but use an integration rule that is too inaccurate, causing it to fail the patch test. The concepts of stability (related to the kernel of the stiffness matrix) and consistency (related to reproducing polynomial fields) are distinct.\n**Verdict: Incorrect**", "answer": "$$\\boxed{A}$$", "id": "2405118"}, {"introduction": "Having established the conceptual framework, the next step is to translate theory into a practical, automated tool. This hands-on practice guides you through the process of building a complete patch test framework from the ground up for two-dimensional linear elasticity. You will implement the test for both quadrilateral and triangular elements, learning how to verify that they correctly reproduce a linear displacement field and correctly fail to capture a higher-order field for which they were not designed [@problem_id:2605421].", "problem": "Design and implement an automated patch test framework for two-dimensional small-strain linear elasticity within the Finite Element Method (FEM). The framework must verify the linear patch test for convergence verification on rectangular patches using both bilinear quadrilateral elements and linear triangular elements. The objective is to assess whether a given mesh and element formulation can exactly reproduce prescribed polynomial displacement fields when those fields lie within the discrete trial space, and to report a boolean result for each test case.\n\nStart from the following fundamental base:\n\n- The governing model is small-strain linear elasticity on a rectangular domain $\\Omega = [0,L_x] \\times [0,L_y]$, with displacement field $\\mathbf{u} = (u_x,u_y)$.\n- The small-strain tensor is $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{T}\\right)$.\n- The constitutive relation for an isotropic material under plane stress is $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$, where $\\mathbf{D}$ depends on Young’s modulus $E$ and Poisson’s ratio $\\nu$ and is positive definite for $E > 0$ and $-1 < \\nu < 0.5$.\n- The weak form with essential (Dirichlet) boundary conditions $\\mathbf{u} = \\mathbf{g}$ on $\\partial \\Omega$ and zero body force is: find $\\mathbf{u} \\in \\mathcal{V}$ with $\\mathbf{u}|_{\\partial \\Omega} = \\mathbf{g}$ such that\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{v})^{T} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0 \\quad \\text{for all } \\mathbf{v} \\in \\mathcal{V}_0.\n$$\n\nYour automated patch test must implement the following procedure:\n\n- Mesh generation on $\\Omega$ using either:\n  - Bilinear quadrilateral elements (denoted $Q4$) on a uniform $n_x \\times n_y$ grid of rectangles, or\n  - Linear triangular elements (denoted $T3$) obtained by splitting each rectangle into two triangles.\n- Conforming finite element discretization with standard isoparametric interpolation for $Q4$ and affine interpolation for $T3$.\n- Full Dirichlet boundary conditions on $\\partial \\Omega$ defined by a prescribed displacement field $\\mathbf{u}^{\\star}(x,y)$ that is either linear in $x$ and $y$ or quadratic in $x$ and $y$. The body force is zero.\n- Assemble the global stiffness matrix and enforce the Dirichlet boundary conditions by elimination.\n- Solve the resulting linear system for the unknown displacement degrees of freedom.\n- Evaluate the discrete solution $\\mathbf{u}_h$ at interior sampling points:\n  - For $Q4$ elements: use the standard $2 \\times 2$ Gauss points in the reference square, mapped to each physical element.\n  - For $T3$ elements: use the centroid of each triangle.\n- Compute the maximum absolute error over all sample points,\n$$\ne_{\\max} = \\max_{\\text{samples}} \\max\\left( \\left| u_{x,h} - u^{\\star}_x \\right|, \\left| u_{y,h} - u^{\\star}_y \\right| \\right).\n$$\n- Declare that a test case passes if $e_{\\max} \\le \\tau$, where $\\tau$ is a specified tolerance.\n\nYour program must implement element-level matrices based on the above definitions and exact numerical integration rules standard for each element type:\n- For $Q4$, use tensor-product Gauss integration with $2 \\times 2$ points.\n- For $T3$, exploit that the strain-displacement matrix is constant over an affine triangle and integrate exactly over the area.\n\nUse the following test suite. Each test provides $(\\text{element type}, n_x, n_y, L_x, L_y, E, \\nu, \\text{field type}, \\text{coefficients or None}, \\tau)$, where:\n- For a linear field, $\\mathbf{u}^{\\star}(x,y)$ is given by\n$$\nu_x(x,y) = a_0 + a_1 x + a_2 y, \\quad u_y(x,y) = b_0 + b_1 x + b_2 y,\n$$\nwith coefficients $(a_0,a_1,a_2,b_0,b_1,b_2)$ provided in the test case.\n- For the quadratic field case, use\n$$\nu_x(x,y) = x^2 + y, \\quad u_y(x,y) = x + y^2.\n$$\n- The material parameters are $E$ and $\\nu$, the tolerance is $\\tau$, and the domain is $\\Omega = [0,L_x]\\times[0,L_y]$.\n\nTest suite to implement:\n\n- Case $1$ (happy path, $Q4$, linear field):\n  - $(\\text{element type} = Q4, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{linear}, \\text{coefficients} = (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), \\tau = 10^{-10})$.\n- Case $2$ (coverage on $T3$, linear field):\n  - $(\\text{element type} = T3, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{linear}, \\text{coefficients} = (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), \\tau = 10^{-10})$.\n- Case $3$ (negative case to ensure discrimination, $Q4$, quadratic field):\n  - $(\\text{element type} = Q4, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{quadratic}, \\text{coefficients} = \\text{None}, \\tau = 10^{-10})$.\n- Case $4$ (edge case: single element patch, $Q4$, linear field):\n  - $(\\text{element type} = Q4, n_x = 1, n_y = 1, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{field type} = \\text{linear}, \\text{coefficients} = (0.0, 1.0, 0.0, 0.2, -0.1, 0.0), \\tau = 10^{-10})$.\n\nScientific realism requirements:\n\n- Assume all computations are non-dimensional; no physical units are required.\n- Angles do not appear in the input or output and need not be specified.\n\nYour program must output a single line containing the pass/fail boolean results for the above four cases as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is either $\\text{True}$ or $\\text{False}$. No other output is permitted.", "solution": "The problem requires the design and implementation of a patch test framework for two-dimensional linear elasticity. The patch test is a fundamental necessary condition for the convergence of a finite element formulation. It ascertains whether the element can exactly represent a constant strain state, which corresponds to a linear displacement field. A conforming element that passes the linear patch test is guaranteed to converge to the correct solution as the mesh is refined.\n\nThe governing equations are those of linear elastostatics. The displacement field is denoted by $\\mathbf{u} = (u_x, u_y)^T$. The strain-displacement relationship is given by the symmetric gradient operator, yielding the small strain tensor $\\boldsymbol{\\varepsilon}$:\n$$ \\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix} = \\begin{pmatrix} \\partial u_x / \\partial x \\\\ \\partial u_y / \\partial y \\\\ \\partial u_x / \\partial y + \\partial u_y / \\partial x \\end{pmatrix} $$\nFor a linear isotropic material under plane stress conditions, the stress tensor $\\boldsymbol{\\sigma}$ is related to the strain tensor via the constitutive matrix $\\mathbf{D}$:\n$$ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} $$\nwhere the matrix $\\mathbf{D}$ for plane stress is defined in terms of Young's modulus $E$ and Poisson's ratio $\\nu$ as:\n$$ \\mathbf{D} = \\frac{E}{1 - \\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1 - \\nu}{2} \\end{pmatrix} $$\n\nThe finite element method provides an approximate solution to the problem's weak form. The domain $\\Omega$ is discretized into elements. Within each element $e$, the displacement field $\\mathbf{u}_h$ is interpolated from nodal displacements $\\mathbf{d}_e$ using shape functions $\\mathbf{N}$:\n$$ \\mathbf{u}_h(x, y) = \\mathbf{N}(x, y) \\mathbf{d}_e $$\nThe strain field is then obtained by differentiating the shape functions:\n$$ \\boldsymbol{\\varepsilon}_h(x, y) = \\mathbf{B}(x, y) \\mathbf{d}_e $$\nThe matrix $\\mathbf{B}$ is the strain-displacement matrix, which connects nodal displacements to element strains.\n\nThe element stiffness matrix $\\mathbf{k}_e$ relates the nodal displacements to nodal forces for an element and is computed by integrating over the element's domain $\\Omega_e$:\n$$ \\mathbf{k}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega $$\nThese element matrices are assembled into a global stiffness matrix $\\mathbf{K}$. The resulting system of linear equations is $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$. For the patch test, boundary conditions are prescribed from an exact polynomial displacement field $\\mathbf{u}^\\star$. The system is solved for the unknown interior nodal displacements.\n\nThe test passes if the computed numerical solution $\\mathbf{u}_h$ is identical to the exact solution $\\mathbf{u}^\\star$ within the domain, to within machine precision. We verify this by comparing the solutions at specific interior sampling points. The maximum error is calculated:\n$$ e_{\\max} = \\max_{\\text{samples}} \\| \\mathbf{u}_h(\\mathbf{x}_{\\text{sample}}) - \\mathbf{u}^\\star(\\mathbf{x}_{\\text{sample}}) \\|_{\\infty} $$\nThe test is passed if $e_{\\max} \\le \\tau$, where $\\tau$ is a small tolerance.\n\nTwo element types are considered:\n1.  Bilinear Quadrilateral ($Q4$): The shape functions are bilinear, of the form $N_i(\\xi, \\eta) = c_0 + c_1 \\xi + c_2 \\eta + c_3 \\xi \\eta$ in the reference element coordinate system $(\\xi, \\eta)$. This basis includes all linear polynomials. The integral for $\\mathbf{k}_e$ is evaluated using $2 \\times 2$ Gauss quadrature, which is exact for polynomials of degree up to $3$ in $\\xi$ and $\\eta$. For a rectangular element and a linear displacement field, the integrand is quadratic, so this rule is sufficient. The check is performed at the same Gauss quadrature points inside each element.\n\n2.  Linear Triangular ($T3$): The shape functions are linear, $N_i(x, y) = c_0 + c_1 x + c_2 y$. This basis also contains all linear polynomials. For this element, the strain-displacement matrix $\\mathbf{B}$ is constant. The integral for $\\mathbf{k}_e$ becomes trivial: $\\mathbf{k}_e = \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\cdot A_e$, where $A_e$ is the element area. The check is performed at the element centroid.\n\nThe logic of the patch test cases is as follows:\n- A linear displacement field corresponds to a constant strain state. Both $Q4$ and $T3$ elements must be able to reproduce this state exactly. Cases $1$, $2$, and $4$ test this fundamental property.\n- A quadratic displacement field is not, in general, representable by the $Q4$ element basis. The bilinear shape functions cannot exactly capture terms like $x^2$ or $y^2$. Therefore, the $Q4$ element is expected to fail the patch test for a general quadratic field. Case $3$ tests this discrimination capability, which is essential for a valid test framework.\n\nThe implementation procedure is:\n1.  A mesh generator creates the nodal coordinates and element connectivity for a given $n_x \\times n_y$ grid. For $T3$ elements, each rectangle is consistently divided into two triangles.\n2.  The global stiffness matrix $\\mathbf{K}$ is assembled by iterating over all elements and adding their respective $\\mathbf{k}_e$ to the correct global degrees of freedom (DOFs).\n3.  Dirichlet boundary conditions are identified for all nodes on the boundary $\\partial\\Omega$. The known displacements are computed from the analytical field $\\mathbf{u}^\\star$.\n4.  The linear system is partitioned into free and fixed DOFs and solved via elimination: $\\mathbf{K}_{ff} \\mathbf{U}_f = -\\mathbf{K}_{fd} \\mathbf{U}_d$.\n5.  After solving for the unknown displacements $\\mathbf{U}_f$, the full solution vector $\\mathbf{U}$ is reconstructed.\n6.  The maximum error $e_{\\max}$ is computed by iterating over all elements and their specified sampling points, comparing the interpolated FEM solution $\\mathbf{u}_h$ to the exact solution $\\mathbf{u}^\\star$.\n7.  Finally, the result is reported as `True` if $e_{\\max} \\le \\tau$, and `False` otherwise. This structured approach ensures a rigorous and verifiable implementation of the patch test.", "answer": "```python\nimport numpy as np\n\ndef perform_test(element_type, nx, ny, Lx, Ly, E, nu, field_type, coeffs, tau):\n    \"\"\"Performs a single patch test case.\"\"\"\n\n    # 1. Mesh Generation\n    dx = Lx / nx\n    dy = Ly / ny\n    num_nodes = (nx + 1) * (ny + 1)\n    nodes = np.zeros((num_nodes, 2))\n    for i in range(nx + 1):\n        for j in range(ny + 1):\n            node_idx = i * (ny + 1) + j\n            nodes[node_idx] = [i * dx, j * dy]\n\n    elements = []\n    if element_type == 'Q4':\n        for i in range(nx):\n            for j in range(ny):\n                n1 = i * (ny + 1) + j\n                n2 = (i + 1) * (ny + 1) + j\n                n3 = (i + 1) * (ny + 1) + (j + 1)\n                n4 = i * (ny + 1) + (j + 1)\n                elements.append([n1, n2, n3, n4])\n    elif element_type == 'T3':\n        for i in range(nx):\n            for j in range(ny):\n                n1 = i * (ny + 1) + j\n                n2 = (i + 1) * (ny + 1) + j\n                n3 = (i + 1) * (ny + 1) + (j + 1)\n                n4 = i * (ny + 1) + (j + 1)\n                # Consistent split: n1-n3 diagonal\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n    \n    # 2. Define Exact Solution\n    if field_type == 'linear':\n        a0, a1, a2, b0, b1, b2 = coeffs\n        u_star = lambda x, y: np.array([a0 + a1 * x + a2 * y, b0 + b1 * x + b2 * y])\n    elif field_type == 'quadratic':\n        u_star = lambda x, y: np.array([x**2 + y, x + y**2])\n    else:\n        raise ValueError(\"Unknown field type\")\n\n    # 3. FEM Assembly\n    # Constitutive matrix for Plane Stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    K = np.zeros((2 * num_nodes, 2 * num_nodes))\n\n    if element_type == 'Q4':\n        gauss_points = 1 / np.sqrt(3) * np.array([[-1, -1], [1, -1], [-1, 1], [1, 1]])\n        gauss_weights = [1, 1, 1, 1]\n\n        for el_nodes_idx in elements:\n            k_e = np.zeros((8, 8))\n            el_nodes_coords = nodes[el_nodes_idx]\n            \n            for gp, w in zip(gauss_points, gauss_weights):\n                xi, eta = gp\n                # Derivatives of shape functions w.r.t. ref coords\n                dN_dxi_eta = 0.25 * np.array([\n                    [-(1-eta),  (1-eta), (1+eta), -(1+eta)],\n                    [-(1-xi), -(1+xi),  (1+xi),  (1-xi)]\n                ])\n                \n                # Jacobian matrix\n                J = dN_dxi_eta @ el_nodes_coords\n                detJ = np.linalg.det(J)\n                invJ = np.linalg.inv(J)\n                \n                # Derivatives of shape functions w.r.t. physical coords\n                dN_dxy = invJ @ dN_dxi_eta\n                \n                # B matrix\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2*i] = dN_dxy[0, i]\n                    B[1, 2*i+1] = dN_dxy[1, i]\n                    B[2, 2*i] = dN_dxy[1, i]\n                    B[2, 2*i+1] = dN_dxy[0, i]\n                \n                k_e += B.T @ D @ B * detJ * w\n                \n            # Assembly\n            dof_map = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n    elif element_type == 'T3':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            x1, y1 = el_nodes_coords[0]\n            x2, y2 = el_nodes_coords[1]\n            x3, y3 = el_nodes_coords[2]\n\n            area = 0.5 * np.abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n            \n            # B matrix (constant for T3)\n            B = (1 / (2 * area)) * np.array([\n                [y2-y3, 0,     y3-y1, 0,     y1-y2, 0    ],\n                [0,     x3-x2, 0,     x1-x3, 0,     x2-x1],\n                [x3-x2, y2-y3, x1-x3, y3-y1, x2-x1, y1-y2]\n            ])\n            \n            k_e = B.T @ D @ B * area\n            \n            # Assembly\n            dof_map = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n    # 4. Apply Boundary Conditions by Elimination\n    is_boundary_node = np.array([\n        np.isclose(n[0], 0.0) or np.isclose(n[0], Lx) or\n        np.isclose(n[1], 0.0) or np.isclose(n[1], Ly)\n        for n in nodes\n    ])\n    \n    fixed_dofs = np.where(np.repeat(is_boundary_node, 2))[0]\n    free_dofs = np.where(~np.repeat(is_boundary_node, 2))[0]\n    \n    U = np.zeros(2 * num_nodes)\n    for node_idx in np.where(is_boundary_node)[0]:\n        x, y = nodes[node_idx]\n        U[2*node_idx : 2*node_idx+2] = u_star(x, y)\n        \n    U_d = U[fixed_dofs]\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fd = K[np.ix_(free_dofs, fixed_dofs)]\n    \n    F_eff = -K_fd @ U_d\n    \n    if free_dofs.size > 0:\n        U_f = np.linalg.solve(K_ff, F_eff)\n        U[free_dofs] = U_f\n\n    # 5. Error Evaluation\n    max_error = 0.0\n    if element_type == 'Q4':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            el_dofs = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            el_U = U[el_dofs]\n\n            for gp in gauss_points:\n                xi, eta = gp\n                # Shape functions at GP\n                N = 0.25 * np.array([\n                    (1-xi)*(1-eta), (1+xi)*(1-eta), \n                    (1+xi)*(1+eta), (1-xi)*(1+eta)\n                ])\n                # Physical coordinates of GP\n                xy_gp = N @ el_nodes_coords\n                # FEM solution at GP\n                u_h = np.array([N @ el_U[0::2], N @ el_U[1::2]])\n                # Exact solution at GP\n                u_exact = u_star(xy_gp[0], xy_gp[1])\n                \n                max_error = max(max_error, np.max(np.abs(u_h - u_exact)))\n\n    elif element_type == 'T3':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            el_dofs = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            el_U = U[el_dofs]\n            \n            # Centroid coordinates\n            xy_c = np.mean(el_nodes_coords, axis=0)\n            \n            # For linear triangle, interpolated value at centroid is average of nodal values\n            u_h = np.mean(el_U.reshape(-1, 2), axis=0)\n            u_exact = u_star(xy_c[0], xy_c[1])\n            \n            max_error = max(max_error, np.max(np.abs(u_h - u_exact)))\n\n    return max_error = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the suite of patch tests.\n    \"\"\"\n    test_suite = [\n        # Case 1: Q4, linear field (should pass)\n        ('Q4', 2, 2, 1.0, 1.0, 1.0, 0.25, 'linear', (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), 1e-10),\n        # Case 2: T3, linear field (should pass)\n        ('T3', 2, 2, 1.0, 1.0, 1.0, 0.25, 'linear', (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), 1e-10),\n        # Case 3: Q4, quadratic field (should fail)\n        ('Q4', 2, 2, 1.0, 1.0, 1.0, 0.25, 'quadratic', None, 1e-10),\n        # Case 4: Single element Q4, linear field (should pass)\n        ('Q4', 1, 1, 1.0, 1.0, 1.0, 0.25, 'linear', (0.0, 1.0, 0.0, 0.2, -0.1, 0.0), 1e-10),\n    ]\n\n    results = []\n    for params in test_suite:\n        result = perform_test(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2605421"}, {"introduction": "A theoretically sound element can still produce incorrect results in practice due to the limitations of computer arithmetic. This final exercise explores the critical interplay between mesh quality, matrix conditioning, and numerical precision. You will implement a patch test that simulates finite-precision arithmetic, allowing you to observe how ill-conditioned meshes can amplify rounding errors and cause a test to fail, even when it should pass in exact arithmetic [@problem_id:2605438].", "problem": "You are asked to implement, from first principles, a computational patch test for two-dimensional linearized elasticity using the Finite Element Method (FEM) with Constant Strain Triangle (CST) elements, and to explicitly study how mesh conditioning and numerical precision affect the verification outcome. The patch test checks whether a discretization reproduces any linear displacement field exactly when appropriate Dirichlet boundary conditions are applied and body forces are zero. Your implementation must incorporate a controlled rounding model that simulates arithmetic with a specified number of binary mantissa bits to assess sensitivity to numerical precision.\n\nStart from the following fundamental base:\n- The weak form of small-strain, plane-stress linear elasticity with no body forces: find the displacement field $u : \\Omega \\to \\mathbb{R}^2$ in the admissible space such that for all admissible virtual displacements $w$, one has\n$$\n\\int_{\\Omega} \\varepsilon(w)^{\\mathsf{T}} D \\, \\varepsilon(u)\\, \\mathrm{d}\\Omega = 0,\n$$\nwith $D$ the constitutive matrix for isotropic plane-stress elasticity and $\\varepsilon(\\cdot)$ the linearized strain operator.\n- A Constant Strain Triangle (CST) element with nodal coordinates $(x_i,y_i)$, $i \\in \\{1,2,3\\}$, has a constant strain-displacement matrix $B$ and element stiffness\n$$\nK_e = t \\, A \\, B^{\\mathsf{T}} D B,\n$$\nwhere $t$ is element thickness, $A$ is the triangle area, and $D$ is the plane-stress constitutive tensor\n$$\nD = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n- The patch test for first-order completeness prescribes displacements from a linear field\n$$\nu(x,y) =\n\\begin{bmatrix}\na_0 + a_1 x + a_2 y\\\\\nb_0 + b_1 x + b_2 y\n\\end{bmatrix},\n$$\non the boundary. For a mesh of CST elements and exact arithmetic, the interior nodal solution must match the exact linear field exactly.\n\nGeometry and mesh:\n- Consider the square $\\Omega = [0,1]\\times[0,1]$ discretized by a $3\\times 3$ node grid at coordinates $x \\in \\{0, 0.5, 1\\}$ and $y \\in \\{0, 0.5, 1\\}$, triangulated into $8$ CST elements by splitting each of the $4$ squares along the same diagonal. To control conditioning, anisotropically compress the $y$-coordinates by a factor $s0$, i.e., use node coordinates $(x, s y)$ while keeping $x$ unchanged. Denote the compression factor by $s$.\n- Use the interior node at the geometric center as the only free node, and apply Dirichlet boundary conditions given by the linear field on all boundary nodes.\n\nMaterial and loading:\n- Use plane-stress with Young’s modulus $E = 1$ and Poisson’s ratio $\\nu = 0.3$, thickness $t = 1$. There are no body forces and no tractions.\n- Use the linear displacement field coefficients $a_0 = 0.3$, $a_1 = 1.7$, $a_2 = -0.9$, $b_0 = -0.2$, $b_1 = 0.4$, $b_2 = 1.1$.\n\nNumerical precision model:\n- Simulate arithmetic with a specified number of binary mantissa bits $p$ by rounding every elementary arithmetic result to $p$ bits of mantissa in base $2$. Use rounding to nearest in the mantissa after representing a real number as $m 2^e$ with $m \\in [0.5,1)$ via the standard decomposition. Apply this rounding consistently to scalar additions, subtractions, multiplications, and divisions used in element stiffness computation and global stiffness assembly, as well as to matrix–vector products used to form the reduced right-hand side. Solve the final reduced linear system with a standard double-precision solver.\n- After solving, quantize the recovered interior nodal displacement to $p$-bit mantissa before error evaluation to reflect limited precision output.\n\nError metric:\n- Let $u_h$ be the computed displacement at the interior (free) node and $u_{\\star}$ the exact linear-field displacement at that node. Define the relative error\n$$\n\\mathrm{err} = \\frac{\\|u_h - u_{\\star}\\|_2}{\\|u_{\\star}\\|_2}.\n$$\n\nTask:\n- Implement the above for the following test suite of $(s,p)$ pairs:\n  1. $s = 1$, $p = 53$ (well-conditioned geometry, double-precision mantissa).\n  2. $s = 10^{-3}$, $p = 24$ (moderately ill-conditioned geometry, single-precision-like mantissa).\n  3. $s = 10^{-6}$, $p = 53$ (highly ill-conditioned geometry, double-precision mantissa).\n  4. $s = 10^{-6}$, $p = 10$ (highly ill-conditioned geometry, very low precision mantissa).\n- For each case, compute $\\mathrm{err}$ as defined above.\n\nOutput specification:\n- Your program should produce a single line of output containing the four relative errors as a comma-separated list enclosed in square brackets, in the order listed above (for the four $(s,p)$ cases). The numbers are dimensionless. For example, a conforming output format is\n$$\n[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3,\\mathrm{err}_4],\n$$\nwith each $\\mathrm{err}_i$ a floating-point number in standard decimal notation.", "solution": "The problem statement is critically examined and found to be valid. It is a well-posed, scientifically grounded problem in computational mechanics that requests the implementation of a finite element patch test under controlled numerical precision. The parameters, equations, and objectives are specified with sufficient clarity and rigor to permit a unique and meaningful solution.\n\nThe task is to verify the first-order completeness of the Constant Strain Triangle (CST) element for two-dimensional plane-stress elasticity. This is achieved through a patch test, which asserts that for a patch of elements, a linear displacement field subjected to corresponding Dirichlet boundary conditions must be reproduced exactly by the finite element solution. The problem introduces two key complexities: anisotropic mesh distortion to induce ill-conditioning, and a simulated finite-precision arithmetic model to study its interaction with numerical error.\n\nThe governing weak form for static equilibrium in the absence of body forces is:\n$$\n\\int_{\\Omega} \\varepsilon(w)^{\\mathsf{T}} D \\, \\varepsilon(u)\\, \\mathrm{d}\\Omega = 0 \\quad \\forall w \\in V_0\n$$\nwhere $u$ is the displacement field in the space of admissible functions $V$, $w$ is a virtual displacement in the space $V_0$ (vanishing on the Dirichlet boundary), $\\varepsilon(\\cdot)$ is the symmetric gradient operator yielding strain components, and $D$ is the material constitutive matrix. For isotropic plane-stress, $D$ is given by:\n$$\nD = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\nwith Young's modulus $E=1$ and Poisson's ratio $\\nu=0.3$.\n\nThe domain $\\Omega = [0,1]\\times[0,1]$ is discretized using a mesh of $8$ CST elements on a $3 \\times 3$ grid of nodes. The node coordinates are $(x, sy)$ for $x, y \\in \\{0, 0.5, 1\\}$, where $s$ is the mesh compression factor. The nodal degrees of freedom (DOFs) are the horizontal and vertical displacements $(u_x, u_y)$. The discretization leads to the algebraic system $KU=F$.\n\nFor a single CST element with nodes $i, j, k$ at coordinates $(x_i, y_i), (x_j, y_j), (x_k, y_k)$, the element stiffness matrix $K_e$ is a $6 \\times 6$ matrix calculated as:\n$$\nK_e = t A B^{\\mathsf{T}} D B\n$$\nHere, $t=1$ is the thickness, $A$ is the element area, and $B$ is the constant strain-displacement matrix:\n$$\nB = \\frac{1}{2A} \\begin{bmatrix}\ny_j-y_k  0  y_k-y_i  0  y_i-y_j  0 \\\\\n0  x_k-x_j  0  x_i-x_k  0  x_j-x_i \\\\\ny_j-y_k  x_k-x_j  y_k-y_i  x_i-x_k  y_i-y_j  x_j-x_i\n\\end{bmatrix}\n$$\nThe area $A$ is given by $A = \\frac{1}{2} |x_i(y_j - y_k) + x_j(y_k - y_i) + x_k(y_i - y_j)|$.\n\nA critical component of this problem is the simulation of finite-precision arithmetic. Every elementary operation (addition, subtraction, multiplication, division) throughout the calculation of element stiffness matrices, their assembly into the global matrix, and the formation of the right-hand side vector must be rounded to a mantissa of $p$ binary bits. This is implemented by a custom rounding function that operates on a number $x$ by first decomposing it into a mantissa and exponent, $x=m \\cdot 2^e$ with $m \\in [-1, -0.5) \\cup \\{0\\} \\cup [0.5, 1)$, rounding the mantissa $m$ to the nearest value representable with $p$ bits, and then reconstructing the number.\n\nThe prescribed displacement field is linear:\n$$\nu(x,y) = \\begin{bmatrix} u_x(x,y) \\\\ u_y(x,y) \\end{bmatrix} =\n\\begin{bmatrix}\na_0 + a_1 x + a_2 y\\\\\nb_0 + b_1 x + b_2 y\n\\end{bmatrix}\n$$\nwith coefficients $a_0 = 0.3, a_1 = 1.7, a_2 = -0.9, b_0 = -0.2, b_1 = 0.4, b_2 = 1.1$. This field is evaluated at the coordinates of the $8$ boundary nodes to define the Dirichlet boundary conditions. The single interior node at $(0.5, 0.5s)$ remains free.\n\nThe global system $KU=F$ is partitioned into free (f) and prescribed (p) DOFs:\n$$\n\\begin{bmatrix} K_{ff}  K_{fp} \\\\ K_{pf}  K_{pp} \\end{bmatrix} \\begin{Bmatrix} U_f \\\\ U_p \\end{Bmatrix} = \\begin{Bmatrix} F_f \\\\ F_p \\end{Bmatrix}\n$$\nWith no external forces on the free node, $F_f = 0$. The reduced system for the unknown displacements $U_f$ is:\n$$\nK_{ff} U_f = -K_{fp} U_p\n$$\nThe matrices $K_{ff}$ and $K_{fp}$ are submatrices of the global stiffness matrix $K$, which is assembled element-by-element using the finite-precision arithmetic. The right-hand side vector $RHS = -K_{fp} U_p$ is also computed using precision-aware matrix-vector multiplication. As per the problem specification, this final $2 \\times 2$ system is solved using a standard double-precision linear solver.\n\nAfter obtaining the computed displacement $u_h$ for the free node, its components are quantized to $p$-bit precision. The relative error is then calculated against the exact displacement at that node, $u_{\\star} = u(0.5, 0.5s)$:\n$$\n\\mathrm{err} = \\frac{\\|u_h - u_{\\star}\\|_2}{\\|u_{\\star}\\|_2}\n$$\nThis procedure is repeated for each pair of parameters $(s, p)$ provided in the test suite. The implementation will systematically construct all matrices and vectors under the specified precision constraints to evaluate the impact of conditioning and rounding error on the patch test outcome.", "answer": "```python\nimport numpy as np\nimport math\n\nclass PFloatOps:\n    \"\"\"\n    A class to handle arithmetic operations with controlled precision.\n    All elementary operations are rounded to a mantissa of p binary bits.\n    \"\"\"\n    def __init__(self, p):\n        if not (1 = p = 53):\n            raise ValueError(\"Precision bits p must be between 1 and 53.\")\n        self.p = p\n\n    def round(self, val: float) - float:\n        \"\"\"Rounds a float to p mantissa bits.\"\"\"\n        if val == 0.0 or not np.isfinite(val):\n            return val\n        \n        m, e = math.frexp(val)\n        # m is in [-1, -0.5) or [0.5, 1)\n        # Scale mantissa, round to nearest integer, and scale back.\n        scale = 2**self.p\n        rounded_m = round(m * scale) / scale\n        return math.ldexp(rounded_m, e)\n\n    def add(self, a: float, b: float) - float:\n        return self.round(a + b)\n\n    def sub(self, a: float, b: float) - float:\n        return self.round(a - b)\n\n    def mul(self, a: float, b: float) - float:\n        return self.round(a * b)\n\n    def div(self, a: float, b: float) - float:\n        return self.round(a / b)\n\n    def matmul(self, A: np.ndarray, B: np.ndarray) - np.ndarray:\n        \"\"\"Performs matrix multiplication with controlled precision.\"\"\"\n        m, n = A.shape\n        n_B, p_ = B.shape\n        if n != n_B:\n            raise ValueError(\"Matrix dimensions are incompatible for multiplication.\")\n        \n        C = np.zeros((m, p_))\n        for i in range(m):\n            for j in range(p_):\n                sum_val = 0.0\n                for k in range(n):\n                    prod = self.mul(A[i, k], B[k, j])\n                    sum_val = self.add(sum_val, prod)\n                C[i, j] = sum_val\n        return C\n    \n    def matvecmul(self, A: np.ndarray, v: np.ndarray) - np.ndarray:\n        \"\"\"Performs matrix-vector multiplication with controlled precision.\"\"\"\n        m, n = A.shape\n        if n != v.shape[0]:\n            raise ValueError(\"Matrix and vector dimensions are incompatible.\")\n\n        res = np.zeros(m)\n        for i in range(m):\n            sum_val = 0.0\n            for j in range(n):\n                prod = self.mul(A[i, j], v[j])\n                sum_val = self.add(sum_val, prod)\n            res[i] = sum_val\n        return res\n\ndef get_cst_stiffness(nodes_coords: np.ndarray, D: np.ndarray, t: float, ops: PFloatOps) - np.ndarray:\n    \"\"\"\n    Computes the stiffness matrix for a single Constant Strain Triangle (CST) element\n    using the provided precision operations.\n    \"\"\"\n    (x1, y1), (x2, y2), (x3, y3) = nodes_coords\n    \n    # Calculate area with precision\n    term1 = ops.mul(x1, ops.sub(y2, y3))\n    term2 = ops.mul(x2, ops.sub(y3, y1))\n    term3 = ops.mul(x3, ops.sub(y1, y2))\n    sum_terms = ops.add(ops.add(term1, term2), term3)\n    area = ops.div(sum_terms, 2.0)\n    \n    if area = 0:\n        raise ValueError(\"Element has zero or negative area.\")\n\n    # Components of B matrix\n    beta1, beta2, beta3 = ops.sub(y2, y3), ops.sub(y3, y1), ops.sub(y1, y2)\n    gamma1, gamma2, gamma3 = ops.sub(x3, x2), ops.sub(x1, x3), ops.sub(x2, x1)\n\n    inv_2A = ops.div(1.0, ops.mul(2.0, area))\n\n    B = np.zeros((3, 6))\n    betas = [beta1, beta2, beta3]\n    gammas = [gamma1, gamma2, gamma3]\n\n    for i in range(3):\n        B[0, 2*i] = ops.mul(betas[i], inv_2A)\n        B[1, 2*i+1] = ops.mul(gammas[i], inv_2A)\n        B[2, 2*i] = ops.mul(gammas[i], inv_2A)\n        B[2, 2*i+1] = ops.mul(betas[i], inv_2A)\n\n    # Ke = t * A * B.T @ D @ B with controlled precision\n    Bt = B.T\n    DB = ops.matmul(D, B)\n    BtDB = ops.matmul(Bt, DB)\n    \n    Ke = np.zeros((6, 6))\n    scalar = ops.mul(t, area)\n    for i in range(6):\n        for j in range(6):\n            Ke[i, j] = ops.mul(scalar, BtDB[i, j])\n\n    return Ke\n\ndef solve_case(s: float, p: int) - float:\n    \"\"\"\n    Runs the patch test for a given geometry scaling `s` and precision `p`.\n    \"\"\"\n    ops = PFloatOps(p)\n\n    # Material properties\n    E = 1.0\n    nu = 0.3\n    t = 1.0\n    \n    # Constitutive matrix D for plane stress, calculated with precision\n    nu_sq = ops.mul(nu, nu)\n    one_minus_nu_sq = ops.sub(1.0, nu_sq)\n    factor = ops.div(E, one_minus_nu_sq)\n    \n    D = np.zeros((3, 3))\n    D[0, 0] = factor\n    D[0, 1] = ops.mul(factor, nu)\n    D[1, 0] = D[0, 1]\n    D[1, 1] = factor\n    D[2, 2] = ops.mul(factor, ops.div(ops.sub(1.0, nu), 2.0))\n\n    # Mesh definition\n    x_coords = [0.0, 0.5, 1.0]\n    y_coords = [0.0, 0.5, 1.0]\n    nodes = np.array([[x, ops.mul(s, y)] for y in y_coords for x in x_coords])\n    \n    # Node indices are 0-8, row-by-row from bottom-left\n    # Elements are numbered to create a consistent triangulation\n    elements = [\n        (0, 1, 4), (0, 4, 3), (1, 2, 5), (1, 5, 4),\n        (3, 4, 7), (3, 7, 6), (4, 5, 8), (4, 8, 7)\n    ]\n    \n    # Assembly\n    num_nodes = 9\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for el_nodes in elements:\n        node1_idx, node2_idx, node3_idx = el_nodes\n        el_coords = nodes[[node1_idx, node2_idx, node3_idx]]\n        \n        Ke = get_cst_stiffness(el_coords, D, t, ops)\n        \n        dof_indices = [2*node1_idx, 2*node1_idx+1, 2*node2_idx, 2*node2_idx+1, 2*node3_idx, 2*node3_idx+1]\n        \n        for i in range(6):\n            for j in range(6):\n                global_i, global_j = dof_indices[i], dof_indices[j]\n                K_global[global_i, global_j] = ops.add(K_global[global_i, global_j], Ke[i, j])\n\n    # Boundary conditions and partitioning\n    free_dofs = [8, 9]  # DOFs for the central node (node 4)\n    prescribed_dofs = [i for i in range(2 * num_nodes) if i not in free_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n    \n    # Prescribed displacement field coefficients\n    a0, a1, a2 = 0.3, 1.7, -0.9\n    b0, b1, b2 = -0.2, 0.4, 1.1\n\n    def u_exact(x, y):\n        ux = a0 + a1*x + a2*y\n        uy = b0 + b1*x + b2*y\n        return np.array([ux, uy])\n\n    U_p = np.zeros(len(prescribed_dofs))\n    for i, dof in enumerate(prescribed_dofs):\n        node_idx = dof // 2\n        dof_type = dof % 2\n        node_coord = nodes[node_idx]\n        u_val = u_exact(node_coord[0], node_coord[1])[dof_type]\n        U_p[i] = u_val\n        \n    # Solve system: K_ff * U_f = -K_fp * U_p\n    RHS = ops.matvecmul(K_fp, U_p)\n    RHS = -RHS\n    \n    # Solve using standard double precision solver\n    try:\n        Uh_f = np.linalg.solve(K_ff, RHS)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # Quantize solution\n    Uh_f_quantized = np.array([ops.round(Uh_f[0]), ops.round(Uh_f[1])])\n    \n    # Error calculation\n    center_node_coord = nodes[4]\n    U_star = u_exact(center_node_coord[0], center_node_coord[1])\n    \n    diff_vec = Uh_f_quantized - U_star\n    err_norm = np.linalg.norm(diff_vec)\n    ustar_norm = np.linalg.norm(U_star)\n    \n    if ustar_norm == 0:\n        return 0.0 if err_norm == 0.0 else np.inf\n    \n    return err_norm / ustar_norm\n\ndef solve():\n    test_cases = [\n        (1.0, 53),\n        (1e-3, 24),\n        (1e-6, 53),\n        (1e-6, 10),\n    ]\n\n    results = []\n    for s, p in test_cases:\n        rel_err = solve_case(s, p)\n        results.append(rel_err)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2605438"}]}