{"hands_on_practices": [{"introduction": "We begin with the foundational case of node-to-surface contact, which provides the essential building blocks for more complex contact simulations. This exercise [@problem_id:2548022] focuses on computing the signed normal gap $g_n$ for a slave node relative to a master plane, a direct application of vector projection. By evaluating the contact state, you will then apply a penalty regularization to calculate the resulting repulsive force and its associated tangent stiffness, core components of an implicit finite element solver.", "problem": "Consider a point-to-plane (node-to-surface) unilateral contact scenario in the Finite Element Method (FEM), in which a slave node at current position $\\boldsymbol{x}_s \\in \\mathbb{R}^3$ interacts with a planar master surface. The master surface is defined by a point $\\boldsymbol{x}_0 \\in \\mathbb{R}^3$ and a unit normal $\\boldsymbol{n} \\in \\mathbb{R}^3$. Assume small kinematics and a frictionless, purely normal interaction.\n\nStarting from first principles of contact kinematics and the principle of virtual work with a quadratic penalty regularization for unilateral contact, proceed as follows:\n- Define the signed normal gap $g_n$ in terms of $\\boldsymbol{x}_s$, $\\boldsymbol{x}_0$, and $\\boldsymbol{n}$ for a planar master surface, and explain the contact activation condition.\n- From an admissible penalty potential for unilateral normal contact, derive the scalar normal contact force $f_c$ and the associated scalar consistent tangent $k_c := \\partial f_c / \\partial g_n$.\n- Evaluate $g_n$, $f_c$, and $k_c$ for the numerical data given below.\n\nUse the following data:\n- Slave node position $\\boldsymbol{x}_s = \\left(0.3998,\\, -0.1,\\, 0.1998\\right)\\,\\text{m}$,\n- Point on the plane $\\boldsymbol{x}_0 = \\left(0.4,\\, -0.1,\\, 0.2\\right)\\,\\text{m}$,\n- Unit normal to the plane $\\boldsymbol{n} = \\dfrac{1}{3}\\left(1,\\, 2,\\, 2\\right)$,\n- Normal penalty parameter $\\epsilon_n = 3.5 \\times 10^{7}\\,\\text{N/m}$.\n\nAdopt the sign convention that $g_n  0$ denotes penetration (active contact) and $g_n \\ge 0$ denotes separation (no contact). Express $g_n$ in meters, $f_c$ in Newtons, and $k_c$ in Newtons per meter. Round your final numerical results to four significant figures.\n\nYour final answer must report, in the order $(g_n,\\ f_c,\\ k_c)$, the three values.", "solution": "The problem statement presented is formally examined and found to be valid. It is scientifically grounded in the principles of computational contact mechanics, specifically the penalty method in the Finite Element Method. It is well-posed, providing all necessary data for a unique solution. The language is objective and unambiguous. We may therefore proceed with the solution.\n\nThe problem asks for the evaluation of the contact state between a slave node and a master plane. This requires, first, a precise definition of the geometric relationship (the gap), and second, a constitutive law for the interaction force based on this geometry.\n\nFirst, we define the signed normal gap, $g_n$. For a slave node at position $\\boldsymbol{x}_s$ and a master plane defined by a point $\\boldsymbol{x}_0$ and an outward-pointing unit normal $\\boldsymbol{n}$, the gap is the signed orthogonal distance from the node to the plane. This is computed by projecting the vector connecting a point on the plane to the slave node, $(\\boldsymbol{x}_s - \\boldsymbol{x}_0)$, onto the normal vector $\\boldsymbol{n}$.\n$$g_n = (\\boldsymbol{x}_s - \\boldsymbol{x}_0) \\cdot \\boldsymbol{n}$$\nThe sign convention is given: $g_n  0$ implies penetration, meaning the slave node has crossed the plane in the direction opposite to $\\boldsymbol{n}$. The condition $g_n \\ge 0$ implies that the node is on or outside the contact surface, resulting in separation. Therefore, the contact activation condition, or Kuhn-Tucker condition for this unilateral constraint, is $g_n  0$.\n\nSecond, we derive the contact force and tangent stiffness from a penalty potential. The penalty method regularizes the strict non-penetration constraint by allowing for a small, unphysical penetration, which is penalized by a repulsive force proportional to the penetration depth. A standard quadratic penalty potential $\\Pi_p$ for unilateral normal contact is given by:\n$$\\Pi_p(g_n) = \\begin{cases} \\frac{1}{2} \\epsilon_n g_n^2  \\text{if } g_n  0 \\\\ 0  \\text{if } g_n \\ge 0 \\end{cases}$$\nwhere $\\epsilon_n > 0$ is the penalty parameter.\n\nThe scalar normal contact force, which we define as the magnitude of the repulsive force vector $\\boldsymbol{F}_c = f_c \\boldsymbol{n}$, must be non-negative, $f_c \\ge 0$. It is derived from the Karush-Kuhn-Tucker (KKT) conditions, which are approximated in the penalty method as $f_c \\approx \\epsilon_n \\max(0, -g_n)$. This results in:\n$$f_c(g_n) = \\begin{cases} -\\epsilon_n g_n  \\text{if } g_n  0 \\\\ 0  \\text{if } g_n \\ge 0 \\end{cases}$$\nFor $g_n  0 $, the penetration depth is $|g_n| = -g_n$, so the force $f_c = \\epsilon_n |g_n|$ is positive, correctly representing repulsion.\n\nThe associated scalar consistent tangent is defined as $k_c := \\partial f_c / \\partial g_n$. We differentiate the expression for $f_c$:\n$$k_c(g_n) = \\frac{\\partial f_c}{\\partial g_n} = \\begin{cases} \\frac{\\partial}{\\partial g_n}(-\\epsilon_n g_n)  \\text{if } g_n  0 \\\\ \\frac{\\partial}{\\partial g_n}(0)  \\text{if } g_n \\ge 0 \\end{cases} = \\begin{cases} -\\epsilon_n  \\text{if } g_n  0 \\\\ 0  \\text{if } g_n \\ge 0 \\end{cases}$$\nThe negative sign of $k_c$ for an active contact is correct and expected from these definitions. It signifies that an increase in the force magnitude ($df_c > 0$) corresponds to an increase in penetration, which means a decrease in the algebraic value of the gap ($dg_n  0$).\n\nWe now evaluate these quantities using the provided numerical data:\n- Slave node position $\\boldsymbol{x}_s = \\begin{pmatrix} 0.3998 \\\\ -0.1 \\\\ 0.1998 \\end{pmatrix}\\,\\text{m}$\n- Point on the plane $\\boldsymbol{x}_0 = \\begin{pmatrix} 0.4 \\\\ -0.1 \\\\ 0.2 \\end{pmatrix}\\,\\text{m}$\n- Unit normal to the plane $\\boldsymbol{n} = \\frac{1}{3}\\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix}$\n- Normal penalty parameter $\\epsilon_n = 3.5 \\times 10^{7}\\,\\text{N/m}$\n\nFirst, we compute the vector from $\\boldsymbol{x}_0$ to $\\boldsymbol{x}_s$:\n$$\\boldsymbol{x}_s - \\boldsymbol{x}_0 = \\begin{pmatrix} 0.3998 - 0.4 \\\\ -0.1 - (-0.1) \\\\ 0.1998 - 0.2 \\end{pmatrix} = \\begin{pmatrix} -0.0002 \\\\ 0 \\\\ -0.0002 \\end{pmatrix}\\,\\text{m}$$\n\nNext, we calculate the signed normal gap $g_n$:\n$$g_n = (\\boldsymbol{x}_s - \\boldsymbol{x}_0) \\cdot \\boldsymbol{n} = \\begin{pmatrix} -0.0002 \\\\ 0 \\\\ -0.0002 \\end{pmatrix} \\cdot \\left(\\frac{1}{3}\\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix}\\right)$$\n$$g_n = \\frac{1}{3} \\left( (-0.0002)(1) + (0)(2) + (-0.0002)(2) \\right) = \\frac{1}{3} (-0.0002 - 0.0004) = \\frac{-0.0006}{3}$$\n$$g_n = -0.0002\\,\\text{m}$$\nRounding to four significant figures gives $g_n = -2.000 \\times 10^{-4}\\,\\text{m}$.\n\nSince $g_n  0$, the contact is active (penetration). We proceed to calculate the force $f_c$ and stiffness $k_c$.\nFor active contact:\n$$f_c = -\\epsilon_n g_n = -(3.5 \\times 10^{7}\\,\\text{N/m})(-0.0002\\,\\text{m})$$\n$$f_c = (3.5 \\times 10^{7})(2 \\times 10^{-4})\\,\\text{N} = 7 \\times 10^{3}\\,\\text{N}$$\n$$f_c = 7000\\,\\text{N}$$\nRounding to four significant figures gives $f_c = 7.000 \\times 10^{3}\\,\\text{N}$.\n\nFor active contact, the tangent stiffness is:\n$$k_c = -\\epsilon_n = -3.5 \\times 10^{7}\\,\\text{N/m}$$\nRounding to four significant figures gives $k_c = -3.500 \\times 10^{7}\\,\\text{N/m}$.\n\nThe final results are $(g_n, f_c, k_c)$.", "answer": "$$\\boxed{\\begin{pmatrix} -2.000 \\times 10^{-4}  7.000 \\times 10^{3}  -3.500 \\times 10^{7} \\end{pmatrix}}$$", "id": "2548022"}, {"introduction": "Real-world geometries are seldom perfectly smooth, and handling features like edges and corners is a critical aspect of robust contact modeling. This practice [@problem_id:2547993] explores the kinematics of a node approaching a master edge, where the contact normal is no longer unique. You will apply the concept of the normal cone, defined by the normals of the adjacent facets, to determine the appropriate gap distance in this non-smooth scenario.", "problem": "A single slave node in a Finite Element Method (FEM) contact analysis approaches a straight master edge in three dimensions. The master edge is the closed line segment from point $\\boldsymbol{x}_A = (0,0,0)$ to point $\\boldsymbol{x}_B = (2,0,0)$. The slave node is at position $\\boldsymbol{x}_s = (0.8,0.2,0.6)$. The master edge is shared by two planar facets whose unit outward normals at the edge are $\\boldsymbol{n}_1 = \\left(0,\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)$ and $\\boldsymbol{n}_2 = \\left(0,-\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right)$. The edge tangent is orthogonal to both facet normals, as required by geometric compatibility.\n\nUse the following fundamental definitions and facts:\n- The orthogonal projection of a point onto a line is obtained by removing the component of the point-to-line-origin vector orthogonal to the line’s unit tangent, and clamping to the line segment’s endpoints if the projected parameter lies outside the segment.\n- The edge normal cone is the convex cone generated by the adjacent facet normals, i.e., the set $\\mathcal{C} = \\{\\alpha\\,\\boldsymbol{n}_1 + \\beta\\,\\boldsymbol{n}_2 \\,|\\, \\alpha \\ge 0,\\ \\beta \\ge 0\\}$. Admissible unit contact normals along the edge are $\\boldsymbol{n} \\in \\mathcal{C}$ with $\\|\\boldsymbol{n}\\|=1$.\n- The robust normal gap is the minimum normal separation, defined consistent with the main text as the minimum projection of the slave-to-edge vector onto the set of admissible unit normals in the cone.\n\nTasks:\n1) Determine the orthogonal projection $\\boldsymbol{x}_p$ of $\\boldsymbol{x}_s$ onto the master edge segment $\\overline{AB}$.\n2) Using the edge normal cone $\\mathcal{C}$, determine the corresponding robust normal gap $g_n$ defined by\n$$\ng_n \\;=\\; \\min\\limits_{\\boldsymbol{n} \\in \\mathcal{C},\\ \\|\\boldsymbol{n}\\|=1} \\ \\boldsymbol{n} \\cdot \\big(\\boldsymbol{x}_s - \\boldsymbol{x}_p\\big).\n$$\n\nReport only the value of $g_n$. Round your answer to $4$ significant figures and express it in meters.", "solution": "The problem requires the determination of a robust contact normal gap for a slave node approaching a master edge, a standard calculation in the finite element analysis of non-smooth contact. The solution proceeds in two stages: first, the orthogonal projection of the slave node onto the master edge segment is found; second, the normal gap is computed by minimizing the projection of the slave-to-projection vector onto the set of admissible unit contact normals.\n\nThe givens are:\nMaster edge endpoints: $\\boldsymbol{x}_A = (0, 0, 0)$ and $\\boldsymbol{x}_B = (2, 0, 0)$.\nSlave node position: $\\boldsymbol{x}_s = (0.8, 0.2, 0.6)$.\nAdjacent facet normals: $\\boldsymbol{n}_1 = \\left(0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right)$ and $\\boldsymbol{n}_2 = \\left(0, -\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right)$.\n\nFirst, we determine the orthogonal projection $\\boldsymbol{x}_p$ of the slave node $\\boldsymbol{x}_s$ onto the line segment $\\overline{AB}$. The master line can be parameterized as $\\boldsymbol{x}(l) = \\boldsymbol{x}_A + l(\\boldsymbol{x}_B - \\boldsymbol{x}_A)$ for $l \\in [0, 1]$. The parameter $l$ for the orthogonal projection of $\\boldsymbol{x}_s$ onto the infinite line containing $\\overline{AB}$ is given by the formula:\n$$\nl = \\frac{(\\boldsymbol{x}_s - \\boldsymbol{x}_A) \\cdot (\\boldsymbol{x}_B - \\boldsymbol{x}_A)}{\\|\\boldsymbol{x}_B - \\boldsymbol{x}_A\\|^2}\n$$\nThe vector from the origin of the segment $\\boldsymbol{x}_A$ to the slave node is $\\boldsymbol{v}_{As} = \\boldsymbol{x}_s - \\boldsymbol{x}_A = (0.8, 0.2, 0.6)$. The vector representing the master segment is $\\boldsymbol{v}_{AB} = \\boldsymbol{x}_B - \\boldsymbol{x}_A = (2, 0, 0)$.\n\nSubstituting these vectors into the formula for $l$:\n$$\nl = \\frac{(0.8, 0.2, 0.6) \\cdot (2, 0, 0)}{\\|(2, 0, 0)\\|^2} = \\frac{(0.8)(2) + (0.2)(0) + (0.6)(0)}{2^2} = \\frac{1.6}{4} = 0.4\n$$\nSince this value $l=0.4$ lies within the interval $[0, 1]$, the projection point $\\boldsymbol{x}_p$ lies on the segment $\\overline{AB}$. The clamping operation described in the problem statement is not required. The coordinate of the projection point is:\n$$\n\\boldsymbol{x}_p = \\boldsymbol{x}_A + l (\\boldsymbol{x}_B - \\boldsymbol{x}_A) = (0, 0, 0) + 0.4 \\cdot (2, 0, 0) = (0.8, 0, 0)\n$$\n\nNext, we calculate the robust contact normal gap $g_n$. The definition is:\n$$\ng_n = \\min\\limits_{\\boldsymbol{n} \\in \\mathcal{C},\\ \\|\\boldsymbol{n}\\|=1} \\boldsymbol{n} \\cdot \\boldsymbol{d}\n$$\nwhere $\\boldsymbol{d} = \\boldsymbol{x}_s - \\boldsymbol{x}_p$. This vector is:\n$$\n\\boldsymbol{d} = (0.8, 0.2, 0.6) - (0.8, 0, 0) = (0, 0.2, 0.6)\n$$\nThe set of admissible unit contact normals $\\boldsymbol{n}$ are unit vectors in the convex cone $\\mathcal{C} = \\{\\alpha\\,\\boldsymbol{n}_1 + \\beta\\,\\boldsymbol{n}_2 \\,|\\, \\alpha \\ge 0,\\ \\beta \\ge 0\\}$. We must minimize the function $f(\\boldsymbol{n}) = \\boldsymbol{n} \\cdot \\boldsymbol{d}$ subject to $\\boldsymbol{n} = \\alpha \\boldsymbol{n}_1 + \\beta \\boldsymbol{n}_2$, $\\alpha \\ge 0$, $\\beta \\ge 0$, and $\\|\\boldsymbol{n}\\|=1$.\n\nFirst, we check the dot product of the generating normals:\n$$\n\\boldsymbol{n}_1 \\cdot \\boldsymbol{n}_2 = \\left(0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right) \\cdot \\left(0, -\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right) = 0 - \\frac{1}{2} + \\frac{1}{2} = 0\n$$\nSince $\\boldsymbol{n}_1$ and $\\boldsymbol{n}_2$ are orthogonal unit vectors, the normalization constraint $\\|\\boldsymbol{n}\\|^2=1$ simplifies to $\\alpha^2 + \\beta^2 = 1$. The parameters $(\\alpha, \\beta)$ must lie on the arc of the unit circle in the first quadrant.\nThe objective function to minimize is:\n$$\n\\boldsymbol{n} \\cdot \\boldsymbol{d} = (\\alpha \\boldsymbol{n}_1 + \\beta \\boldsymbol{n}_2) \\cdot \\boldsymbol{d} = \\alpha (\\boldsymbol{n}_1 \\cdot \\boldsymbol{d}) + \\beta (\\boldsymbol{n}_2 \\cdot \\boldsymbol{d})\n$$\nLet us compute the coefficients $c_1 = \\boldsymbol{n}_1 \\cdot \\boldsymbol{d}$ and $c_2 = \\boldsymbol{n}_2 \\cdot \\boldsymbol{d}$:\n$$\nc_1 = \\left(0, \\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right) \\cdot (0, 0.2, 0.6) = \\frac{0.2}{\\sqrt{2}} + \\frac{0.6}{\\sqrt{2}} = \\frac{0.8}{\\sqrt{2}}\n$$\n$$\nc_2 = \\left(0, -\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right) \\cdot (0, 0.2, 0.6) = -\\frac{0.2}{\\sqrt{2}} + \\frac{0.6}{\\sqrt{2}} = \\frac{0.4}{\\sqrt{2}}\n$$\nWe want to minimize $c_1 \\alpha + c_2 \\beta$ subject to $\\alpha^2 + \\beta^2 = 1$, $\\alpha \\ge 0$, $\\beta \\ge 0$. Since both $c_1$ and $c_2$ are positive, the gradient of the objective function, $(c_1, c_2)$, points into the first quadrant. Therefore, the minimum value of this linear function over the circular arc must occur at one of the endpoints of the arc, where the projection of the gradient is smallest. The endpoints correspond to $(\\alpha,\\beta) = (1,0)$ and $(\\alpha,\\beta) = (0,1)$.\n\n- At $(\\alpha,\\beta)=(1,0)$, the objective function is $c_1 = \\frac{0.8}{\\sqrt{2}}$.\n- At $(\\alpha,\\beta)=(0,1)$, the objective function is $c_2 = \\frac{0.4}{\\sqrt{2}}$.\n\nThe minimum of these two values is the solution:\n$$\ng_n = \\min(c_1, c_2) = c_2 = \\frac{0.4}{\\sqrt{2}}\n$$\nWe must now evaluate this numerically and round to 4 significant figures.\n$$\ng_n = \\frac{0.4}{\\sqrt{2}} = 0.2\\sqrt{2} \\approx 0.2828427...\n$$\nRounding to 4 significant figures, we get $0.2828$.", "answer": "$$\n\\boxed{0.2828}\n$$", "id": "2547993"}, {"introduction": "While node-to-surface methods are simple, surface-to-surface discretizations often provide more accurate and robust results by integrating contact constraints over element faces. A central challenge in this approach is the nonlinear geometric search for the closest point on the master surface for each slave integration point. This problem [@problem_id:2548007] provides hands-on practice with the core of this search, requiring you to perform one step of the Gauss-Newton algorithm to update the projection and compute the resulting normal gap.", "problem": "You are given two isoparametric bilinear quadrilateral patches in three-dimensional Euclidean space, a slave patch and a master patch, each defined by four nodes and the standard bilinear shape functions over the reference square. The goal is to compute the normal gap for surface-to-surface contact at a specified slave Gauss point by solving for the master closest-point parametric coordinates using a single Gauss–Newton step starting from a given initial guess.\n\nUse the following fundamental base and definitions:\n\n- The slave surface mapping is given by the isoparametric bilinear map\n$$\\mathbf{x}_s(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_{s,i},$$\nand the master surface mapping\n$$\\mathbf{x}_m(\\hat{\\xi},\\hat{\\eta}) = \\sum_{i=1}^{4} N_i(\\hat{\\xi},\\hat{\\eta})\\,\\mathbf{X}_{m,i},$$\nwhere the bilinear shape functions over the parametric domain $[-1,1]\\times[-1,1]$ are\n$$N_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad N_2(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),$$\n$$N_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad N_4(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta).$$\n- The master surface tangent vectors are\n$$\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})=\\frac{\\partial \\mathbf{x}_m}{\\partial \\xi}(\\hat{\\xi},\\hat{\\eta}),\\quad \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})=\\frac{\\partial \\mathbf{x}_m}{\\partial \\eta}(\\hat{\\xi},\\hat{\\eta}).$$\n- The master unit normal (following the right-hand rule of the parametrization) is\n$$\\mathbf{n}(\\hat{\\xi},\\hat{\\eta})=\\frac{\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})\\times \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})}{\\|\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})\\times \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})\\|}.$$\n- For a given slave point $\\mathbf{x}_s(\\xi_s,\\eta_s)$, the closest-point projection onto the master surface seeks $\\hat{\\boldsymbol{\\xi}}=[\\hat{\\xi},\\hat{\\eta}]^\\top$ such that the residual\n$$\\mathbf{R}(\\hat{\\xi},\\hat{\\eta})=\\mathbf{x}_m(\\hat{\\xi},\\hat{\\eta})-\\mathbf{x}_s(\\xi_s,\\eta_s)$$\nis orthogonal to the local tangent space, that is,\n$$\\mathbf{t}_\\xi(\\hat{\\xi},\\hat{\\eta})\\cdot \\mathbf{R}(\\hat{\\xi},\\hat{\\eta})=0,\\quad \\mathbf{t}_\\eta(\\hat{\\xi},\\hat{\\eta})\\cdot \\mathbf{R}(\\hat{\\xi},\\hat{\\eta})=0.$$\n- The Gauss–Newton update for these conditions, from an initial guess $\\hat{\\boldsymbol{\\xi}}_0$, solves\n$$\\mathbf{G}(\\hat{\\boldsymbol{\\xi}}_0)\\,\\Delta \\hat{\\boldsymbol{\\xi}} = -\\mathbf{b}(\\hat{\\boldsymbol{\\xi}}_0),$$\nwith\n$$\\mathbf{G}=\n\\begin{bmatrix}\n\\mathbf{t}_\\xi\\cdot \\mathbf{t}_\\xi  \\mathbf{t}_\\xi\\cdot \\mathbf{t}_\\eta\\\\\n\\mathbf{t}_\\eta\\cdot \\mathbf{t}_\\xi  \\mathbf{t}_\\eta\\cdot \\mathbf{t}_\\eta\n\\end{bmatrix},\\quad\n\\mathbf{b}=\n\\begin{bmatrix}\n\\mathbf{t}_\\xi\\cdot \\mathbf{R}\\\\\n\\mathbf{t}_\\eta\\cdot \\mathbf{R}\n\\end{bmatrix},$$\nwhere all quantities are evaluated at $\\hat{\\boldsymbol{\\xi}}_0$. The one-step update is $\\hat{\\boldsymbol{\\xi}}_1=\\hat{\\boldsymbol{\\xi}}_0+\\Delta \\hat{\\boldsymbol{\\xi}}$.\n- The normal gap at the slave point is defined as\n$$g_n(\\xi_s,\\eta_s) = \\mathbf{n}(\\hat{\\boldsymbol{\\xi}}_1)\\cdot\\left(\\mathbf{x}_s(\\xi_s,\\eta_s)-\\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_1)\\right).$$\n\nAll coordinates are in meters; the normal gap must be reported in meters. Use the above definitions without introducing any additional modeling assumptions. Do not clamp the updated parametric coordinates $\\hat{\\boldsymbol{\\xi}}_1$ to the reference square; evaluate $\\mathbf{n}$ and $\\mathbf{x}_m$ at the updated value as-is.\n\nCompute $g_n(\\xi_s,\\eta_s)$ for the following test suite. In each case, use the same slave Gauss point and the same initial guess for the master parametric coordinates:\n- Slave Gauss point parameters: $(\\xi_s,\\eta_s)=\\left(\\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}}\\right)$.\n- Initial guess for the master projection: $\\hat{\\boldsymbol{\\xi}}_0=[0,0]^\\top$.\n\nTest cases:\n\n- Case $1$ (parallel planes, constant offset):\n  - Master nodes $(\\mathbf{X}_{m,1},\\mathbf{X}_{m,2},\\mathbf{X}_{m,3},\\mathbf{X}_{m,4})$:\n    $$\\left[(-1,-1,0),\\ (1,-1,0),\\ (1,1,0),\\ (-1,1,0)\\right].$$\n  - Slave nodes $(\\mathbf{X}_{s,1},\\mathbf{X}_{s,2},\\mathbf{X}_{s,3},\\mathbf{X}_{s,4})$:\n    $$\\left[(-1,-1,0.2),\\ (1,-1,0.2),\\ (1,1,0.2),\\ (-1,1,0.2)\\right].$$\n\n- Case $2$ (tilted master about the $x$-axis by $10$ degrees, slave parallel plane at constant height):\n  - Let $\\theta=\\frac{\\pi}{18}$ (radians). Start from the square in the plane $z=0$ with nodes\n    $$\\left[(-1,-1,0),\\ (1,-1,0),\\ (1,1,0),\\ (-1,1,0)\\right]$$\n    and rotate each node about the $x$-axis by angle $\\theta$ using the standard rotation\n    $$y' = y\\cos\\theta - z\\sin\\theta,\\quad z' = y\\sin\\theta + z\\cos\\theta.$$\n    The rotated coordinates define $(\\mathbf{X}_{m,i})$.\n  - Slave nodes:\n    $$\\left[(-1,-1,0.2),\\ (1,-1,0.2),\\ (1,1,0.2),\\ (-1,1,0.2)\\right].$$\n\n- Case $3$ (twisted master, slave offset plane):\n  - Master nodes:\n    $$\\left[(-1,-1,0.0),\\ (1,-1,0.1),\\ (1,1,0.0),\\ (-1,1,-0.1)\\right].$$\n  - Slave nodes:\n    $$\\left[(-1,-1,0.05),\\ (1,-1,0.05),\\ (1,1,0.05),\\ (-1,1,0.05)\\right].$$\n\n- Case $4$ (slave point outside the master span, smaller master patch):\n  - Master nodes:\n    $$\\left[(-0.5,-0.5,0.0),\\ (0.5,-0.5,0.0),\\ (0.5,0.5,0.0),\\ (-0.5,0.5,0.0)\\right].$$\n  - Slave nodes:\n    $$\\left[(-1,-1,0.1),\\ (1,-1,0.1),\\ (1,1,0.1),\\ (-1,1,0.1)\\right].$$\n\nRequirements and output specification:\n\n- Implement the evaluation of the bilinear shape functions and their parametric derivatives exactly as defined above.\n- Implement the Gauss–Newton linear system for a single update from $\\hat{\\boldsymbol{\\xi}}_0$ to $\\hat{\\boldsymbol{\\xi}}_1$ using the matrix $\\mathbf{G}$ and right-hand side $\\mathbf{b}$ defined above.\n- For each case, compute the slave point $\\mathbf{x}_s(\\xi_s,\\eta_s)$, update $\\hat{\\boldsymbol{\\xi}}$ once, compute the master unit normal at the updated parametric location, and then compute $g_n(\\xi_s,\\eta_s)$.\n- Express the final normal gaps in meters, rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ to $4$, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$.", "solution": "The problem posed is a well-defined exercise in computational contact mechanics, specifically concerning the surface-to-surface contact formulation within the finite element method. All provided definitions, initial conditions, and test cases are scientifically sound, mathematically consistent, and complete. The problem is therefore valid and permits a direct, unambiguous solution.\n\nThe objective is to compute the normal gap, $g_n$, between a slave surface and a master surface at a specific slave point. This computation involves a single Gauss-Newton iteration to approximate the closest point on the master surface. The entire procedure will be executed for four distinct test cases.\n\nLet us begin by formalizing the required mathematical components. The position vector of a point on an isoparametric bilinear quadrilateral patch is given by\n$$\n\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_{i}\n$$\nwhere $\\mathbf{X}_{i}$ are the coordinates of the four corner nodes, and $N_i(\\xi,\\eta)$ are the bilinear shape functions defined on the parametric domain $[-1,1]\\times[-1,1]$:\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\nThe tangent vectors to the surface are found by differentiating the position vector with respect to the parametric coordinates, $\\xi$ and $\\eta$.\n$$\n\\begin{aligned}\n\\mathbf{t}_\\xi(\\xi,\\eta) = \\frac{\\partial \\mathbf{x}}{\\partial \\xi}(\\xi,\\eta) = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi}(\\xi,\\eta)\\,\\mathbf{X}_{i} \\\\\n\\mathbf{t}_\\eta(\\xi,\\eta) = \\frac{\\partial \\mathbf{x}}{\\partial \\eta}(\\xi,\\eta) = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta}(\\xi,\\eta)\\,\\mathbf{X}_{i}\n\\end{aligned}\n$$\nThe necessary partial derivatives of the shape functions are:\n$$\n\\begin{aligned}\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta) \\\\\n\\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi), \\quad \\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n\\end{aligned}\n$$\nThe procedure for computing the normal gap $g_n$ for each case is as follows.\n\nStep $1$: Compute the position of the specified slave point.\nThe slave Gauss point is given by $(\\xi_s, \\eta_s) = (\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}})$. The slave point in $3$D space, $\\mathbf{x}_s$, is computed using the slave surface mapping:\n$$\n\\mathbf{x}_s = \\mathbf{x}_s(\\xi_s, \\eta_s) = \\sum_{i=1}^{4} N_i(\\xi_s,\\eta_s)\\,\\mathbf{X}_{s,i}\n$$\n\nStep $2$: Perform one Gauss-Newton iteration to find the projected master coordinates.\nWe start with the initial guess for the master parametric coordinates, $\\hat{\\boldsymbol{\\xi}}_0 = [\\hat{\\xi}_0, \\hat{\\eta}_0]^\\top = [0, 0]^\\top$. We must solve the linear system $\\mathbf{G}(\\hat{\\boldsymbol{\\xi}}_0)\\,\\Delta \\hat{\\boldsymbol{\\xi}} = -\\mathbf{b}(\\hat{\\boldsymbol{\\xi}}_0)$ for the update $\\Delta \\hat{\\boldsymbol{\\xi}} = [\\Delta\\hat{\\xi}, \\Delta\\hat{\\eta}]^\\top$.\n\nFirst, evaluate all quantities at $\\hat{\\boldsymbol{\\xi}}_0$.\nThe master point is $\\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_0)$. The residual vector is $\\mathbf{R}(\\hat{\\boldsymbol{\\xi}}_0) = \\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_0) - \\mathbf{x}_s$. The master tangent vectors are $\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_0)$ and $\\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_0)$.\n\nNext, assemble the $2 \\times 2$ matrix $\\mathbf{G}$ and the $2 \\times 1$ vector $\\mathbf{b}$:\n$$\n\\mathbf{G}(\\hat{\\boldsymbol{\\xi}}_0) =\n\\begin{bmatrix}\n\\mathbf{t}_\\xi \\cdot \\mathbf{t}_\\xi  \\mathbf{t}_\\xi \\cdot \\mathbf{t}_\\eta \\\\\n\\mathbf{t}_\\eta \\cdot \\mathbf{t}_\\xi  \\mathbf{t}_\\eta \\cdot \\mathbf{t}_\\eta\n\\end{bmatrix}_{\\hat{\\boldsymbol{\\xi}}_0}\n\\quad\n\\mathbf{b}(\\hat{\\boldsymbol{\\xi}}_0) =\n\\begin{bmatrix}\n\\mathbf{t}_\\xi \\cdot \\mathbf{R} \\\\\n\\mathbf{t}_\\eta \\cdot \\mathbf{R}\n\\end{bmatrix}_{\\hat{\\boldsymbol{\\xi}}_0}\n$$\nSolving the linear system yields the update $\\Delta \\hat{\\boldsymbol{\\xi}}$. For a $2 \\times 2$ system, this is straightforward using Cramer's rule or matrix inversion.\n\nStep $3$: Update the master parametric coordinates.\nThe updated master coordinates are $\\hat{\\boldsymbol{\\xi}}_1 = \\hat{\\boldsymbol{\\xi}}_0 + \\Delta \\hat{\\boldsymbol{\\xi}}$. The problem specifies not to clamp these values to the domain $[-1,1]^2$.\n\nStep $4$: Compute the normal gap.\nThe final step is to evaluate the normal gap $g_n$ using the updated coordinates $\\hat{\\boldsymbol{\\xi}}_1 = [\\hat{\\xi}_1, \\hat{\\eta}_1]^\\top$.\nFirst, calculate the master point $\\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_1)$ and the master tangent vectors $\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_1)$ and $\\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_1)$ at the new location.\nThen, compute the master unit normal vector:\n$$\n\\mathbf{n}(\\hat{\\boldsymbol{\\xi}}_1) = \\frac{\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_1) \\times \\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_1)}{\\|\\mathbf{t}_\\xi(\\hat{\\boldsymbol{\\xi}}_1) \\times \\mathbf{t}_\\eta(\\hat{\\boldsymbol{\\xi}}_1)\\|}\n$$\nThe normal gap is the signed distance from the projected master point to the slave point, measured along the master normal:\n$$\ng_n = \\mathbf{n}(\\hat{\\boldsymbol{\\xi}}_1) \\cdot (\\mathbf{x}_s - \\mathbf{x}_m(\\hat{\\boldsymbol{\\xi}}_1))\n$$\nThis procedure is repeated for all four test cases provided.\n\nFor Case $2$, the master nodes must first be computed. Starting from the nodes $\\mathbf{X}_{i}^{(0)} = (x_i, y_i, 0)$ of a square in the $z=0$ plane, we apply a rotation by $\\theta = \\pi/18$ radians about the $x$-axis. The transformation is given by:\n$$\nx' = x, \\quad y' = y\\cos\\theta - z\\sin\\theta, \\quad z' = y\\sin\\theta + z\\cos\\theta\n$$\nFor a point $(x, y, 0)$, this simplifies to $(x, y\\cos\\theta, y\\sin\\theta)$. The resulting coordinates $\\mathbf{X}_{m,i} = (x_i, y_i\\cos\\theta, y_i\\sin\\theta)$ are then used in the general algorithm.\n\nThe implementation will follow these steps precisely for each case, using numerical arrays to represent vectors and matrices and employing standard linear algebra operations for dot products, cross products, and solving the linear system. The final results are rounded to six decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the contact kinematics problem for four test cases.\n    \"\"\"\n\n    # --- Utilities for Bilinear Quadrilateral Patches ---\n\n    def eval_shape_functions(xi, eta):\n        \"\"\"\n        Evaluates the 4 bilinear shape functions at a given parametric point.\n        \"\"\"\n        N1 = 0.25 * (1.0 - xi) * (1.0 - eta)\n        N2 = 0.25 * (1.0 + xi) * (1.0 - eta)\n        N3 = 0.25 * (1.0 + xi) * (1.0 + eta)\n        N4 = 0.25 * (1.0 - xi) * (1.0 + eta)\n        return np.array([N1, N2, N3, N4])\n\n    def eval_shape_derivatives(xi, eta):\n        \"\"\"\n        Evaluates the parametric derivatives of the 4 bilinear shape functions.\n        Returns two arrays: dN/d_xi and dN/d_eta.\n        \"\"\"\n        dN_dxi = np.array([\n            -0.25 * (1.0 - eta),\n             0.25 * (1.0 - eta),\n             0.25 * (1.0 + eta),\n            -0.25 * (1.0 + eta)\n        ])\n        dN_deta = np.array([\n            -0.25 * (1.0 - xi),\n            -0.25 * (1.0 + xi),\n             0.25 * (1.0 + xi),\n             0.25 * (1.0 - xi)\n        ])\n        return dN_dxi, dN_deta\n\n    def eval_position(xi, eta, nodes):\n        \"\"\"\n        Computes the position vector x for a given parametric point.\n        \"\"\"\n        N = eval_shape_functions(xi, eta)\n        return N @ nodes\n\n    def eval_tangents(xi, eta, nodes):\n        \"\"\"\n        Computes the tangent vectors t_xi and t_eta.\n        \"\"\"\n        dN_dxi, dN_deta = eval_shape_derivatives(xi, eta)\n        t_xi = dN_dxi @ nodes\n        t_eta = dN_deta @ nodes\n        return t_xi, t_eta\n\n    # --- Problem Parameters ---\n\n    xi_s, eta_s = 1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)\n    xi_hat_0 = np.array([0.0, 0.0])\n\n    # --- Test Case Definitions ---\n\n    # Case 1: Parallel planes\n    Xm1 = np.array([\n        [-1.0, -1.0, 0.0],\n        [ 1.0, -1.0, 0.0],\n        [ 1.0,  1.0, 0.0],\n        [-1.0,  1.0, 0.0]\n    ])\n    Xs1 = np.array([\n        [-1.0, -1.0, 0.2],\n        [ 1.0, -1.0, 0.2],\n        [ 1.0,  1.0, 0.2],\n        [-1.0,  1.0, 0.2]\n    ])\n\n    # Case 2: Tilted master plane\n    theta = np.pi / 18.0\n    rot_matrix = np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, np.cos(theta), -np.sin(theta)],\n        [0.0, np.sin(theta), np.cos(theta)]\n    ])\n    # Base nodes are same as Xm1\n    Xm2 = np.array([\n        [-1.0, -1.0 * np.cos(theta), -1.0 * np.sin(theta)],\n        [ 1.0, -1.0 * np.cos(theta), -1.0 * np.sin(theta)],\n        [ 1.0,  1.0 * np.cos(theta),  1.0 * np.sin(theta)],\n        [-1.0,  1.0 * np.cos(theta),  1.0 * np.sin(theta)]\n    ])\n    Xs2 = np.array([\n        [-1.0, -1.0, 0.2],\n        [ 1.0, -1.0, 0.2],\n        [ 1.0,  1.0, 0.2],\n        [-1.0,  1.0, 0.2]\n    ])\n\n    # Case 3: Twisted master\n    Xm3 = np.array([\n        [-1.0, -1.0,  0.0],\n        [ 1.0, -1.0,  0.1],\n        [ 1.0,  1.0,  0.0],\n        [-1.0,  1.0, -0.1]\n    ])\n    Xs3 = np.array([\n        [-1.0, -1.0, 0.05],\n        [ 1.0, -1.0, 0.05],\n        [ 1.0,  1.0, 0.05],\n        [-1.0,  1.0, 0.05]\n    ])\n\n    # Case 4: Slave point outside master span\n    Xm4 = np.array([\n        [-0.5, -0.5, 0.0],\n        [ 0.5, -0.5, 0.0],\n        [ 0.5,  0.5, 0.0],\n        [-0.5,  0.5, 0.0]\n    ])\n    Xs4 = np.array([\n        [-1.0, -1.0, 0.1],\n        [ 1.0, -1.0, 0.1],\n        [ 1.0,  1.0, 0.1],\n        [-1.0,  1.0, 0.1]\n    ])\n\n    test_cases = [\n        (Xm1, Xs1),\n        (Xm2, Xs2),\n        (Xm3, Xs3),\n        (Xm4, Xs4),\n    ]\n\n    results = []\n\n    for master_nodes, slave_nodes in test_cases:\n        # Step 1: Compute slave point\n        x_s = eval_position(xi_s, eta_s, slave_nodes)\n\n        # Step 2: Perform one Gauss-Newton step\n        # Evaluate quantities at initial guess xi_hat_0\n        xi0, eta0 = xi_hat_0\n        x_m_0 = eval_position(xi0, eta0, master_nodes)\n        t_xi_0, t_eta_0 = eval_tangents(xi0, eta0, master_nodes)\n        R_0 = x_m_0 - x_s\n\n        # Assemble Gauss-Newton system\n        G_matrix = np.array([\n            [np.dot(t_xi_0, t_xi_0), np.dot(t_xi_0, t_eta_0)],\n            [np.dot(t_eta_0, t_xi_0), np.dot(t_eta_0, t_eta_0)]\n        ])\n        b_vector = np.array([np.dot(t_xi_0, R_0), np.dot(t_eta_0, R_0)])\n\n        # Solve for the update\n        delta_xi_hat = np.linalg.solve(G_matrix, -b_vector)\n\n        # Step 3: Update master parametric coordinates\n        xi_hat_1 = xi_hat_0 + delta_xi_hat\n\n        # Step 4: Compute normal gap\n        xi1, eta1 = xi_hat_1\n        \n        # Evaluate quantities at updated coordinates xi_hat_1\n        x_m_1 = eval_position(xi1, eta1, master_nodes)\n        t_xi_1, t_eta_1 = eval_tangents(xi1, eta1, master_nodes)\n\n        # Compute master normal\n        normal_vec = np.cross(t_xi_1, t_eta_1)\n        norm_of_normal = np.linalg.norm(normal_vec)\n        if norm_of_normal > 1e-12: # Avoid division by zero for degenerate cases\n            unit_normal = normal_vec / norm_of_normal\n        else:\n            # Fallback for degenerate normal, though not expected in these cases\n            unit_normal = np.array([0.0, 0.0, 1.0])\n\n        # Compute final gap\n        gap_vector = x_s - x_m_1\n        g_n = np.dot(unit_normal, gap_vector)\n        \n        results.append(g_n)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2548007"}]}