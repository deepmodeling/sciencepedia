{"hands_on_practices": [{"introduction": "A cornerstone of developing reliable numerical simulations is verification: testing the code against a problem with a known analytical solution. This exercise provides fundamental practice in this process. By deriving the exact solution for a one-dimensional heat diffusion problem and comparing the decay rate of a single Fourier mode to its numerical counterpart from a finite element model, you will directly quantify the numerical dissipation introduced by the discretization and gain a deeper understanding of how well the discrete model captures the underlying physics. [@problem_id:2607785]", "problem": "Consider one-dimensional transient heat conduction in a homogeneous rod of length $L>0$ with thermal diffusivity $\\alpha>0$. The temperature field $u(x,t)$ satisfies homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(L,t)=0$ for all $t\\ge 0$. The initial condition is a single sine mode $u(x,0)=\\sin\\!\\left(\\frac{m\\pi x}{L}\\right)$ with mode index $m\\in\\mathbb{N}$. \n\nStarting from the principles of local energy conservation and Fourier’s law, derive the governing partial differential equation (PDE) for $u(x,t)$ and justify that the continuous eigenfunctions under these boundary conditions are spatial sine modes. By separation of variables and orthogonality, derive the analytical time evolution of the mode amplitude for the given initial condition.\n\nNext, discretize the spatial domain uniformly with $N\\in\\mathbb{N}$ elements of size $h=L/N$ and approximate $u(x,t)$ in the standard piecewise-linear finite element method (FEM) with a consistent mass matrix. Let $\\mathbf{M}$ and $\\mathbf{K}$ denote the resulting mass and stiffness matrices. Show that the interior grid sine vectors with components $\\sin\\!\\left(\\frac{jm\\pi}{N}\\right)$ at interior node indices $j=1,2,\\dots,N-1$ are generalized eigenvectors of the matrix pencil $(\\mathbf{K},\\mathbf{M})$, and derive the corresponding generalized eigenvalue in closed form as a function of $N$, $L$, and $m$. \n\nDiscretize the semi-discrete system $\\mathbf{M} \\dot{\\mathbf{U}}(t)+\\alpha \\mathbf{K} \\mathbf{U}(t)=\\mathbf{0}$ in time using the backward Euler (BE) method with time step $\\Delta t>0$, and specialize the resulting one-step update to a single discrete eigenmode. Define the per-step amplification factor of this discrete mode, and compare it to the exact per-step amplification factor obtained from the continuous analytical solution for the same mode over a time interval of length $\\Delta t$.\n\nFinally, taking $m$ in the continuous problem to match the discrete mode index and assuming $1\\le m \\le N-1$, derive a single closed-form analytic expression for the ratio $\\mathcal{R}$ of the discrete one-step amplification factor to the exact one-step amplification factor, expressed in terms of $\\alpha$, $L$, $N$, $m$, and $\\Delta t$. State your final result as a single closed-form expression. No units are required for $\\mathcal{R}$, and no rounding is needed.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and self-contained. It presents a standard, albeit multipart, exercise in the analysis of numerical methods for partial differential equations. All parameters are clearly defined, and the task requires a rigorous derivation based on established principles of mathematical physics and numerical analysis. The problem is therefore valid, and a solution will be provided.\n\nFirst, we derive the governing partial differential equation (PDE) for one-dimensional heat conduction. We consider an infinitesimal segment of the rod from $x$ to $x+\\Delta x$. The local energy conservation principle states that the time rate of change of internal energy within this volume is equal to the net heat flux across its boundaries. Let $A$ be the cross-sectional area, $\\rho$ the density, and $c$ the specific heat capacity. The internal energy is $\\int_x^{x+\\Delta x} c \\rho A u(x',t) dx'$. The heat flux is given by Fourier's law, $q(x,t) = -k \\frac{\\partial u}{\\partial x}$, where $k$ is the thermal conductivity. The energy balance equation is:\n$$ \\frac{d}{dt} \\int_x^{x+\\Delta x} c \\rho A u(x',t) dx' = A q(x,t) - A q(x+\\Delta x, t) $$\nAssuming $c, \\rho, A$ are constant, we have:\n$$ \\int_x^{x+\\Delta x} c \\rho A \\frac{\\partial u}{\\partial t} dx' = A \\left( -k \\frac{\\partial u}{\\partial x} \\bigg|_x - \\left( -k \\frac{\\partial u}{\\partial x} \\bigg|_{x+\\Delta x} \\right) \\right) $$\nDividing by $A \\Delta x$ and taking the limit as $\\Delta x \\to 0$, we invoke the fundamental theorem of calculus on the left and the definition of the derivative on the right:\n$$ c \\rho \\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( k \\frac{\\partial u}{\\partial x} \\right) $$\nFor a homogeneous rod, $k$ is constant. Defining the thermal diffusivity $\\alpha = k/(c\\rho)$, we obtain the heat equation:\n$$ \\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2} $$\nTo find the analytical solution, we use the method of separation of variables, assuming a solution of the form $u(x,t) = X(x)T(t)$. Substituting into the PDE yields $X(x)T'(t) = \\alpha X''(x)T(t)$. Separating variables gives:\n$$ \\frac{T'(t)}{\\alpha T(t)} = \\frac{X''(x)}{X(x)} = -\\lambda^2 $$\nThe separation constant must be negative to satisfy the homogeneous Dirichlet boundary conditions $u(0,t)=u(L,t)=0$ with a non-trivial solution. The spatial problem is an eigenvalue problem for the operator $-\\frac{d^2}{dx^2}$:\n$$ X''(x) + \\lambda^2 X(x) = 0, \\quad X(0)=0, \\quad X(L)=0 $$\nThe general solution is $X(x) = C_1 \\cos(\\lambda x) + C_2 \\sin(\\lambda x)$. The condition $X(0)=0$ implies $C_1=0$. The condition $X(L)=0$ implies $C_2 \\sin(\\lambda L) = 0$. For a non-trivial solution ($C_2 \\neq 0$), we must have $\\sin(\\lambda L)=0$, which requires $\\lambda L = m\\pi$ for an integer $m \\in \\mathbb{N}$. The eigenvalues are $\\lambda_m^2 = \\left(\\frac{m\\pi}{L}\\right)^2$ and the corresponding eigenfunctions are $X_m(x) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$. These are the spatial sine modes.\n\nThe temporal problem is $T'(t) + \\alpha \\lambda_m^2 T(t) = 0$, with solution $T_m(t) = T_m(0) \\exp(-\\alpha \\lambda_m^2 t)$. The full solution is a superposition of these modes. Given the initial condition $u(x,0) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$, we see that only one mode is present. The analytical solution is:\n$$ u(x,t) = \\sin\\left(\\frac{m\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 t\\right) $$\nThe exact per-step amplification factor over a time interval $\\Delta t$ is the factor by which the amplitude decays, which is:\n$$ G_{\\text{exact}} = \\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right) $$\nNow we proceed to the finite element discretization. The weak form of the PDE is to find $u \\in H^1_0([0,L])$ such that for all test functions $v \\in H^1_0([0,L])$:\n$$ \\int_0^L \\frac{\\partial u}{\\partial t} v \\,dx + \\alpha \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial v}{\\partial x} \\,dx = 0 $$\nUsing a piecewise-linear finite element basis $\\{\\phi_j(x)\\}_{j=1}^{N-1}$ on a uniform mesh with element size $h=L/N$, we approximate $u(x,t) \\approx u_h(x,t) = \\sum_{j=1}^{N-1} U_j(t) \\phi_j(x)$. This leads to the semi-discrete system $\\mathbf{M} \\dot{\\mathbf{U}}(t)+\\alpha \\mathbf{K} \\mathbf{U}(t)=\\mathbf{0}$, where the entries of the consistent mass matrix $\\mathbf{M}$ and stiffness matrix $\\mathbf{K}$ are:\n$$ M_{ij} = \\int_0^L \\phi_i \\phi_j \\,dx, \\quad K_{ij} = \\int_0^L \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx} \\,dx $$\nFor hat functions on a uniform 1D mesh, these matrices are tridiagonal with entries: $M_{ii} = \\frac{2h}{3}$, $M_{i,i\\pm 1} = \\frac{h}{6}$, $K_{ii} = \\frac{2}{h}$, and $K_{i,i\\pm 1} = -\\frac{1}{h}$.\n\nWe must show that the discrete sine vectors $\\boldsymbol{v}_m$ with components $(v_m)_j = \\sin\\left(\\frac{jm\\pi}{N}\\right)$ for $j=1, \\dots, N-1$ are generalized eigenvectors of $(\\mathbf{K},\\mathbf{M})$ and find the eigenvalue $\\Lambda_m$ satisfying $\\mathbf{K}\\boldsymbol{v}_m = \\Lambda_m \\mathbf{M}\\boldsymbol{v}_m$. We compute the action of $\\mathbf{K}$ and $\\mathbf{M}$ on $\\boldsymbol{v}_m$. For the $j$-th component:\n$$ (\\mathbf{K}\\boldsymbol{v}_m)_j = \\frac{1}{h}\\left[-\\sin\\left(\\frac{(j-1)m\\pi}{N}\\right) + 2\\sin\\left(\\frac{jm\\pi}{N}\\right) - \\sin\\left(\\frac{(j+1)m\\pi}{N}\\right)\\right] $$\nUsing the identity $\\sin(A-B)+\\sin(A+B) = 2\\sin(A)\\cos(B)$, this simplifies to:\n$$ (\\mathbf{K}\\boldsymbol{v}_m)_j = \\frac{1}{h}\\left[2\\sin\\left(\\frac{jm\\pi}{N}\\right) - 2\\sin\\left(\\frac{jm\\pi}{N}\\right)\\cos\\left(\\frac{m\\pi}{N}\\right)\\right] = \\frac{2}{h}\\left(1 - \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)(v_m)_j $$\nFor the mass matrix:\n$$ (\\mathbf{M}\\boldsymbol{v}_m)_j = \\frac{h}{6}\\left[\\sin\\left(\\frac{(j-1)m\\pi}{N}\\right) + 4\\sin\\left(\\frac{jm\\pi}{N}\\right) + \\sin\\left(\\frac{(j+1)m\\pi}{N}\\right)\\right] $$\n$$ (\\mathbf{M}\\boldsymbol{v}_m)_j = \\frac{h}{6}\\left[2\\sin\\left(\\frac{jm\\pi}{N}\\right)\\cos\\left(\\frac{m\\pi}{N}\\right) + 4\\sin\\left(\\frac{jm\\pi}{N}\\right)\\right] = \\frac{h}{3}\\left(2 + \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)(v_m)_j $$\nThe sine vectors are indeed eigenvectors for both matrices. The generalized eigenvalue $\\Lambda_m$ is the ratio of their respective eigenvalues:\n$$ \\Lambda_m = \\frac{\\frac{2}{h}\\left(1 - \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)}{\\frac{h}{3}\\left(2 + \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)} = \\frac{6}{h^2}\\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)} $$\nSubstituting $h=L/N$, the generalized eigenvalue is:\n$$ \\Lambda_m = \\frac{6N^2}{L^2} \\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)} $$\nNext, we discretize the semi-discrete system in time using the backward Euler method. For a single eigenmode, the system reduces to the scalar ordinary differential equation $c'(t) + \\alpha \\Lambda_m c(t) = 0$ for the modal amplitude $c(t)$. Applying backward Euler with step size $\\Delta t$ to an equation of the form $\\dot{y}=-\\lambda y$ yields $y^{n+1} = y^n - \\lambda \\Delta t y^{n+1}$, which gives the update $y^{n+1} = (1+\\lambda\\Delta t)^{-1} y^n$. Here, $\\lambda = \\alpha \\Lambda_m$. The discrete one-step amplification factor is:\n$$ G_{\\text{discrete}} = \\frac{1}{1 + \\alpha \\Lambda_m \\Delta t} = \\frac{1}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}} $$\nFinally, we compute the ratio $\\mathcal{R}$ of the discrete to the exact amplification factor.\n$$ \\mathcal{R} = \\frac{G_{\\text{discrete}}}{G_{\\text{exact}}} = \\frac{\\left(1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}\\right)^{-1}}{\\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)} $$\nThis simplifies to the final expression:\n$$ \\mathcal{R} = \\frac{\\exp\\left(\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}} $$\nThis is the required closed-form analytic expression for the ratio $\\mathcal{R}$.", "answer": "$$\n\\boxed{\\frac{\\exp\\left(\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)}}}\n$$", "id": "2607785"}, {"introduction": "Moving from theory to practice, this exercise involves coding a complete 2D transient heat solver using the finite element method. The goal is not just implementation, but investigation: you will design a test case with sharp gradients to probe a well-known limitation of the popular Crank-Nicolson time-stepping scheme. This hands-on experience will provide concrete insight into how numerical methods can produce non-physical artifacts, such as spurious oscillations, and how these effects depend on the relationship between the time step and mesh size. [@problem_id:2607746]", "problem": "You are to implement a transient heat diffusion solver using the finite element method with continuous, piecewise linear basis functions over an acute triangulation. The goal is to design a test case with strong gradients and evaluate whether the Crank–Nicolson time discretization preserves the positivity of the finite element solution on an acute triangulation, and to explain any observed oscillations. Your program must assemble the spatial operators from first principles and time-step the solution directly.\n\nStart from the following fundamental physical and mathematical base:\n- Conservation of energy in a continuum: for temperature field $u(\\boldsymbol{x},t)$, thermal conductivity $\\kappa$, density $\\rho$, and heat capacity $c$, the energy balance with no source reads $\\rho c\\, \\partial_t u - \\nabla \\cdot (\\kappa \\nabla u) = 0$.\n- Fourier’s law of heat conduction: the heat flux is $\\boldsymbol{q} = -\\kappa \\nabla u$.\n- Assume nondimensionalization yielding $\\rho c = 1$ and $\\kappa = 1$, so that the governing equation reduces to $\\partial_t u - \\Delta u = 0$ in a domain $\\Omega$, with homogeneous Dirichlet boundary condition $u=0$ on $\\partial \\Omega$.\n\nYou must:\n- Derive the weak form of the initial boundary value problem on an equilateral triangular domain $\\Omega$ with vertices at $(0,0)$, $(1,0)$, and $(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})$. Use continuous, piecewise linear trial and test functions on a conforming, shape-regular, acute triangulation obtained by subdividing the equilateral triangle into $N \\times N$ uniform sub-triangles (all interior angles strictly less than $90^\\circ$). Use a consistent mass matrix.\n- Discretize in time by the Crank–Nicolson method with time step $\\Delta t$ and zero source, i.e., by the trapezoidal rule applied to the semidiscrete system. Enforce Dirichlet boundary conditions strongly at every time step by eliminating boundary degrees of freedom.\n- Use the initial condition $u(\\boldsymbol{x},0) = \\exp\\!\\big(-\\|\\boldsymbol{x}-\\boldsymbol{x}_c\\|^2/(2\\sigma^2)\\big)$, where $\\boldsymbol{x}_c$ is the top vertex $(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})$, and set $u=0$ at boundary nodes to be consistent with the boundary condition. This choice produces strong spatial gradients for small $\\sigma$.\n- Evaluate the positivity of the numerical solution over time by tracking the minimum and maximum nodal values across all time steps and computing a boolean indicating whether the solution remained nonnegative up to a tolerance $\\varepsilon = 10^{-12}$. Also compute an undershoot ratio defined as $r = \\max(0,-\\min u)/\\max u$ using the global minimum and maximum encountered during the simulation, where the maximum is taken over all nodes and all time steps. If $\\max u$ is zero within tolerance, define $r=0$ to avoid division by zero.\n\nYour program must implement the following from first principles:\n- The weak form for the heat equation after integration by parts on $\\Omega$ with $u=0$ on $\\partial \\Omega$.\n- The assembly of the global consistent mass matrix and stiffness matrix using the linear shape functions on triangles.\n- The Crank–Nicolson update for the semidiscrete system.\n- The identification of boundary nodes for the equilateral triangulation using the lattice description of the mesh.\n\nYou must run the solver on the following test suite of parameter values $(N,\\Delta t, n_{\\text{steps}}, \\sigma)$:\n- Case $1$: $(12, 5\\times 10^{-4}, 40, 0.04)$.\n- Case $2$: $(12, 5\\times 10^{-3}, 4, 0.02)$.\n- Case $3$: $(8, 1\\times 10^{-2}, 3, 0.015)$.\n- Case $4$: $(20, 1\\times 10^{-3}, 20, 0.04)$.\n\nFor each case, you must:\n- Assemble the mesh with $N$ subdivisions per edge as described above.\n- Initialize $u^0$ from the Gaussian and enforce $u=0$ at boundary nodes.\n- Advance $n_{\\text{steps}}$ steps with the Crank–Nicolson method using time step $\\Delta t$.\n- Record the global minimum $m$ and maximum $M$ over all nodes and time steps, compute the boolean $\\text{nonneg} = (m \\ge -\\varepsilon)$ with $\\varepsilon = 10^{-12}$, and compute the undershoot ratio $r$ as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list of the form $[m, M, \\text{nonneg}, r]$ in this order, where $m$ and $M$ are floating-point numbers, $\\text{nonneg}$ is a boolean, and $r$ is a floating-point number. The overall output must be a list of these per-case lists, for example:\n\"[ [m1,M1,nonneg1,r1], [m2,M2,nonneg2,r2], [m3,M3,nonneg3,r3], [m4,M4,nonneg4,r4] ]\"\nAll numbers are nondimensional; no physical units are required.\n\nYour implementation must be a complete, runnable program as specified. No user input is allowed; all parameters are as specified above. Your code must rely only on the allowed libraries and must conform to the execution environment stated elsewhere in this task.", "solution": "The problem presented is a well-posed, scientifically grounded exercise in the numerical solution of partial differential equations. It requires the implementation of a finite element method (FEM) solver for the transient heat equation on a specific domain geometry. All necessary physical laws, mathematical formulations, and numerical parameters are provided. The problem asks for an analysis of a key numerical property, the preservation of positivity, for the Crank–Nicolson time-stepping scheme on an acute triangulation, a classic topic in numerical analysis. The premise that the acuteness of the mesh and the size of the time step relative to the mesh spacing are crucial for this property is correct. The problem is valid, and I shall proceed with a full solution.\n\nThe derivation and implementation will follow these steps:\n1.  **Weak Formulation**: The governing equation is the nondimensionalized heat equation, $\\partial_t u - \\Delta u = 0$ in a domain $\\Omega$, with a homogeneous Dirichlet boundary condition $u=0$ on $\\partial\\Omega$. To derive the weak form, we multiply by a test function $v$ from the Sobolev space $H_0^1(\\Omega)$ (the space of functions with square-integrable first derivatives that are zero on the boundary $\\partial\\Omega$) and integrate over $\\Omega$:\n    $$ \\int_{\\Omega} (\\partial_t u) v \\, d\\boldsymbol{x} - \\int_{\\Omega} (\\Delta u) v \\, d\\boldsymbol{x} = 0 $$\n    Applying Green's first identity (integration by parts) to the second term yields:\n    $$ \\int_{\\Omega} (\\Delta u) v \\, d\\boldsymbol{x} = - \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} + \\int_{\\partial\\Omega} (\\nabla u \\cdot \\boldsymbol{n}) v \\, dS $$\n    Since the test function $v \\in H_0^1(\\Omega)$, $v=0$ on the boundary $\\partial\\Omega$, which causes the boundary integral to vanish. The weak formulation is then: find $u(\\cdot, t) \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$:\n    $$ \\int_{\\Omega} (\\partial_t u) v \\, d\\boldsymbol{x} + \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} = 0 $$\n\n2.  **Spatial Discretization (FEM)**: We seek an approximate solution $u_h(\\boldsymbol{x}, t)$ in a finite-dimensional subspace $V_h \\subset H_0^1(\\Omega)$. We define $u_h$ as a linear combination of basis functions $\\phi_j(\\boldsymbol{x})$ associated with the interior nodes of the mesh:\n    $$ u_h(\\boldsymbol{x}, t) = \\sum_{j \\in \\mathcal{I}} U_j(t) \\phi_j(\\boldsymbol{x}) $$\n    where $\\mathcal{I}$ is the set of indices for interior nodes and $U_j(t)$ are the unknown time-dependent coefficients representing the temperature at these nodes. By selecting the test functions $v$ to be the basis functions $\\phi_i$ for $i \\in \\mathcal{I}$ (the Galerkin method), we obtain a system of ordinary differential equations (ODEs):\n    $$ \\sum_{j \\in \\mathcal{I}} \\left(\\int_{\\Omega} \\phi_i \\phi_j \\, d\\boldsymbol{x}\\right) \\frac{dU_j}{dt} + \\sum_{j \\in \\mathcal{I}} \\left(\\int_{\\Omega} \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\boldsymbol{x}\\right) U_j(t) = 0, \\quad \\forall i \\in \\mathcal{I} $$\n    This is the semi-discrete system, written in matrix form as:\n    $$ \\mathbf{M} \\frac{d\\mathbf{U}}{dt} + \\mathbf{K} \\mathbf{U} = \\mathbf{0} $$\n    where $\\mathbf{U}(t)$ is the vector of nodal values $\\{U_j(t)\\}_{j \\in \\mathcal{I}}$. The matrices $\\mathbf{M}$ and $\\mathbf{K}$ are the consistent mass matrix and stiffness matrix, respectively, restricted to the interior degrees of freedom. Their entries are:\n    $$ M_{ij} = \\int_{\\Omega} \\phi_i \\phi_j \\, d\\boldsymbol{x}, \\quad K_{ij} = \\int_{\\Omega} \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\boldsymbol{x} $$\n\n3.  **Temporal Discretization (Crank–Nicolson)**: We discretize the time derivative using the trapezoidal rule (Crank–Nicolson scheme) with a time step $\\Delta t$, where $\\mathbf{U}^n \\approx \\mathbf{U}(n\\Delta t)$:\n    $$ \\mathbf{M} \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} + \\mathbf{K} \\frac{\\mathbf{U}^{n+1} + \\mathbf{U}^n}{2} = \\mathbf{0} $$\n    Rearranging the terms to solve for the unknown state $\\mathbf{U}^{n+1}$ at the next time step gives the linear system:\n    $$ \\left(\\mathbf{M} + \\frac{\\Delta t}{2} \\mathbf{K}\\right) \\mathbf{U}^{n+1} = \\left(\\mathbf{M} - \\frac{\\Delta t}{2} \\mathbf{K}\\right) \\mathbf{U}^n $$\n    This system must be solved at each time step. The matrix on the left-hand side is constant, so its factorization can be pre-computed for efficiency.\n\n4.  **Element Matrices**: The global matrices $\\mathbf{M}$ and $\\mathbf{K}$ are assembled by summing up contributions from local element matrices, $\\mathbf{M}^e$ and $\\mathbf{K}^e$. For a uniform triangulation using equilateral triangles of side length $h = 1/N$, all element matrices are identical. The area of each element is $A = \\frac{\\sqrt{3}}{4}h^2$. For piecewise linear ($\\mathbb{P}_1$) basis functions, the element stiffness and mass matrices are:\n    $$ \\mathbf{K}^e = \\frac{1}{2\\sqrt{3}} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix}, \\quad \\mathbf{M}^e = \\frac{A}{12} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} = \\frac{\\sqrt{3}h^2}{48} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\n    The stiffness matrix $\\mathbf{K}^e$ has non-positive off-diagonal entries, and its assembly results in a global stiffness matrix $\\mathbf{K}$ that is an M-matrix for an acute triangulation. This property is crucial for the discrete maximum principle. However, the Crank-Nicolson update matrix, $(\\mathbf{M} + \\frac{\\Delta t}{2} \\mathbf{K})^{-1} (\\mathbf{M} - \\frac{\\Delta t}{2} \\mathbf{K})$, does not guarantee positivity unless a condition on $\\Delta t$ is met. Specifically, positivity is maintained if the matrix $\\mathbf{M} - \\frac{\\Delta t}{2} \\mathbf{K}$ is non-negative, which imposes a CFL-like condition of the form $\\Delta t \\le C h^2$. The problem cases are designed to probe this condition: cases with larger $\\Delta t$ are expected to violate it and produce spurious oscillations (undershoots), leading to negative temperature values, even with an initial condition that is non-negative everywhere.\n\n5.  **Implementation Strategy**:\n    - **Mesh**: An equilateral triangle domain with vertices $(0,0)$, $(1,0)$, and $(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$ is triangulated into $N^2$ smaller equilateral triangles. The nodes are generated using a barycentric coordinate system. A node $\\boldsymbol{x}_{ijk}$ is defined by $\\boldsymbol{x}_{ijk} = \\frac{i}{N}(0,0) + \\frac{j}{N}(1,0) + \\frac{k}{N}(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$ where $i,j,k$ are non-negative integers with $i+j+k=N$. We can use $(j,k)$ as independent indices ($j,k \\ge 0$, $j+k \\le N$).\n    - **Assembly**: global $\\mathbf{M}$ and $\\mathbf{K}$ matrices are assembled by iterating through all elements and adding the local element matrix contributions to the corresponding global indices.\n    - **Boundary Conditions**: Dirichlet boundary conditions ($u=0$) are enforced by identifying all boundary nodes ($i=0$ or $j=0$ or $k=0$ in the barycentric indexing) and restricting the linear system to only the interior nodes.\n    - **Time Marching**: The initial condition vector $\\mathbf{U}^0$ is constructed by evaluating the Gaussian function at all interior node coordinates and setting boundary nodes to $0$. The simulation then proceeds for $n_{\\text{steps}}$ by repeatedly solving the Crank-Nicolson linear system.\n    - **Analysis**: During the simulation, the minimum and maximum nodal values across all nodes (interior and boundary) are tracked at every time step from $t=0$ to $t_{final}$. These are used to compute the final required metrics: global minimum $m$, global maximum $M$, a boolean `nonneg` for positivity, and the undershoot ratio $r$.\n\nThe following program implements this entire procedure from first principles.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM solver for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, n_steps, sigma)\n        (12, 5e-4, 40, 0.04),\n        (12, 5e-3, 4, 0.02),\n        (8, 1e-2, 3, 0.015),\n        (20, 1e-3, 20, 0.04),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        N, dt, n_steps, sigma = params\n        result = run_simulation(N, dt, n_steps, sigma)\n        all_results.append(result)\n\n    # Format the final output string\n    # E.g., [[-2.3e-05, 0.9, False, 2.5e-05], ...]\n    # using f-strings for demonstration of format. The exact values will be computed.\n    result_str = \"[\" + \", \".join([\n        f\"[{m:.8e}, {M:.8e}, {str(nonneg).lower()}, {r:.8e}]\"\n        for m, M, nonneg, r in all_results\n    ]) + \"]\"\n    print(result_str)\n\ndef run_simulation(N, dt, n_steps, sigma):\n    \"\"\"\n    Runs a single simulation for the transient heat equation using FEM.\n    \n    Args:\n        N (int): Number of subdivisions along each edge of the domain.\n        dt (float): Time step size.\n        n_steps (int): Number of time steps to perform.\n        sigma (float): Standard deviation of the initial Gaussian pulse.\n\n    Returns:\n        tuple: A tuple containing (m, M, nonneg, r) for the simulation.\n    \"\"\"\n    TOL = 1.0e-12\n\n    # 1. Mesh Generation\n    # Vertices of the main equilateral triangle\n    v1 = np.array([0.0, 0.0])\n    v2 = np.array([1.0, 0.0])\n    v3 = np.array([0.5, np.sqrt(3.0) / 2.0])\n\n    # Generate nodes using barycentric coordinates\n    nodes = []\n    node_map = {}  # maps (j, k) -> node_idx\n    idx_counter = 0\n    for k in range(N + 1):\n        for j in range(N - k + 1):\n            i = N - j - k\n            coord = (j / N) * v2 + (k / N) * v3  # v1 is origin\n            nodes.append(coord)\n            node_map[(j, k)] = idx_counter\n            idx_counter += 1\n    nodes = np.array(nodes)\n    num_nodes = len(nodes)\n\n    # Generate elements (triangles)\n    elements = []\n    # \"Up\" pointing triangles\n    for k in range(N):\n        for j in range(N - k):\n            v_idx1 = node_map[(j, k)]\n            v_idx2 = node_map[(j + 1, k)]\n            v_idx3 = node_map[(j, k + 1)]\n            elements.append([v_idx1, v_idx2, v_idx3])\n    # \"Down\" pointing triangles\n    for k in range(N - 1):\n        for j in range(N - k - 1):\n            v_idx1 = node_map[(j + 1, k)]\n            v_idx2 = node_map[(j + 1, k + 1)]\n            v_idx3 = node_map[(j, k + 1)]\n            elements.append([v_idx1, v_idx2, v_idx3])\n    \n    # Identify interior and boundary nodes\n    interior_nodes_indices = []\n    boundary_nodes_indices = []\n    for k in range(N + 1):\n        for j in range(N - k + 1):\n            i = N - j - k\n            idx = node_map[(j, k)]\n            if i > 0 and j > 0 and k > 0:\n                interior_nodes_indices.append(idx)\n            else:\n                boundary_nodes_indices.append(idx)\n\n    # 2. Assemble Matrices\n    h = 1.0 / N\n    area = np.sqrt(3.0) / 4.0 * h**2\n    \n    # Element stiffness matrix for equilateral triangle\n    K_e = (1.0 / (2.0 * np.sqrt(3.0))) * np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]])\n    # Element mass matrix\n    M_e = (area / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    M = np.zeros((num_nodes, num_nodes))\n    K = np.zeros((num_nodes, num_nodes))\n\n    for el in elements:\n        for i in range(3):\n            for j in range(3):\n                gi, gj = el[i], el[j]\n                M[gi, gj] += M_e[i, j]\n                K[gi, gj] += K_e[i, j]\n    \n    # Extract submatrices for interior nodes\n    ix = np.ix_(interior_nodes_indices, interior_nodes_indices)\n    M_int = M[ix]\n    K_int = K[ix]\n    \n    # 3. Initial Condition\n    u0 = np.zeros(num_nodes)\n    xc = v3\n    for i in range(num_nodes):\n        if i in interior_nodes_indices:\n            dist_sq = np.sum((nodes[i] - xc)**2)\n            u0[i] = np.exp(-dist_sq / (2.0 * sigma**2))\n    \n    global_min = np.min(u0)\n    global_max = np.max(u0)\n\n    u_int = u0[interior_nodes_indices]\n\n    # 4. Time Stepping\n    A = M_int + (dt / 2.0) * K_int\n    B = M_int - (dt / 2.0) * K_int\n    \n    # Pre-factorize A\n    lu, piv = lu_factor(A)\n    \n    u_current_full = np.copy(u0)\n\n    for step in range(n_steps):\n        rhs = B @ u_int\n        u_int = lu_solve((lu, piv), rhs)\n        \n        # Update full solution vector and track min/max\n        u_current_full[interior_nodes_indices] = u_int\n        step_min = np.min(u_current_full)\n        step_max = np.max(u_current_full)\n        \n        if step_min < global_min:\n            global_min = step_min\n        if step_max > global_max:\n            global_max = step_max\n\n    # 5. Compute final metrics\n    m = global_min\n    M = global_max\n    \n    nonneg = m >= -TOL\n    \n    if M < TOL:\n        r = 0.0\n    else:\n        r = max(0.0, -m) / M\n        \n    return m, M, nonneg, r\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2607746"}, {"introduction": "To create truly efficient and robust solvers, we must often move beyond fixed parameters to adaptive algorithms that respond to the evolving solution. This final practice guides you through the implementation of a variable-step-size Crank-Nicolson scheme with local error control. You will build a solver that automatically adjusts its time step to efficiently capture the dynamics of a moving heat front, exploring the powerful connection between the physical features of the solution and the behavior of the numerical algorithm. [@problem_id:2607783]", "problem": "Consider the one-dimensional transient heat diffusion problem on a fixed spatial domain with a localized moving heat source. The governing partial differential equation is the heat equation\n$$\n\\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + s(x,t), \\quad x \\in (0,L), \\; t \\in (0,T],\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu(0,t) = 0, \\quad u(L,t) = 0, \\quad t \\in (0,T],\n$$\nand initial condition\n$$\nu(x,0) = 0, \\quad x \\in [0,L].\n$$\nThe source term is a moving Gaussian of the form\n$$\ns(x,t) = A \\exp\\!\\left(-\\frac{\\left(x - x_c(t)\\right)^2}{2\\sigma^2}\\right),\n$$\nwhere the center of the Gaussian moves according to\n$$\nx_c(t) = x_0 + v t,\n$$\nwith constant speed parameter $v$. Assume $k = 1$, $L = 1$, $T = 0.5$, $A = 10$, $\\sigma = 0.05$, and $x_0 = 0.2$. Throughout, take the spatial grid to be a uniform partition of $[0,L]$ with $N_e = 100$ linear finite elements (so $N_n = 101$ nodes), and use the standard Galerkin method with continuous, piecewise-linear basis functions; use a consistent mass matrix.\n\nTask:\n1. Starting from the strong form of the partial differential equation and the boundary/initial conditions above, derive the weak form and the semi-discrete system of ordinary differential equations in time for the finite element coefficients. Do not use any shortcut formulas; start from the definition of the weighted residual and perform integration by parts, carefully justifying boundary term treatment under the stated boundary conditions.\n2. From the semi-discrete system, derive a variable-step Crank–Nicolson time discretization with local error control based on step doubling. The acceptance criterion must be defined by the following error estimate: given one full step of size $\\Delta t$ and two half-steps of size $\\Delta t/2$, form the difference between the two end-of-step solutions and define the scalar error as the mass-matrix weighted Euclidean norm of this difference, divided by the square root of the number of unknowns. Use this as a proxy for the local truncation error. Design a time-step controller that accepts a step if the error is at most a given tolerance and updates the next step size $\\Delta t_{\\text{new}}$ using a power law appropriate for a method whose local error scales like $\\mathcal{O}(\\Delta t^3)$. Your controller must also enforce minimum and maximum time steps and bounded growth/shrink factors to avoid extreme changes.\n3. Define the “front location” at an accepted time level as the midpoint of the mesh element where the magnitude of the piecewise-constant finite element gradient (computed from adjacent nodal values) is maximal. For a sequence of accepted steps indexed by $i = 1, 2, \\dots, M$, with accepted time steps $\\Delta t_i$ and corresponding successive front locations $x^{\\text{front}}_{i-1}$ and $x^{\\text{front}}_{i}$, define the instantaneous front speed magnitude by\n$$\n\\lvert v^{\\text{front}}_i \\rvert = \\frac{\\left|x^{\\text{front}}_{i} - x^{\\text{front}}_{i-1}\\right|}{\\Delta t_i}.\n$$\nTo quantify how the step-size control follows the front speed, define the tracking metric time series by\n$$\ny_i = \\frac{1}{\\varepsilon + \\lvert v^{\\text{front}}_i \\rvert},\n$$\nwith a regularization parameter $\\varepsilon = 10^{-8}$ to avoid division by zero. Compute the Pearson correlation coefficient between the two sequences $\\{\\Delta t_i\\}$ and $\\{y_i\\}$ over all accepted steps in the interval $(0,T]$. If either sequence has zero variance, define the correlation to be $0$.\n4. Implement the complete finite element solver with the variable-step Crank–Nicolson scheme and the step-doubling controller. Use the following controller and numerical parameters: initial time step $\\Delta t_0 = 10^{-3}$, minimum step $\\Delta t_{\\min} = 10^{-4}$, maximum step $\\Delta t_{\\max} = 2\\times 10^{-2}$, tolerance $\\text{tol} = 10^{-4}$, safety factor $\\eta = 0.9$, maximum growth factor $g_{\\max} = 2.0$, and minimum shrink factor $g_{\\min} = 0.5$. When a step is accepted, advance using the more accurate solution from the two half-steps. Ensure that the final time $T$ is matched exactly by shortening the last step if necessary.\n5. Test Suite. Run the solver for the three speeds\n$$\nv \\in \\{0.0, \\; 0.4, \\; 0.8\\},\n$$\nwith all other parameters fixed as stated above, and compute the correlation coefficient for each case as described. The outputs are dimensionless real numbers.\n6. Required Final Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite speeds, for example\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$\nNo additional text should be printed.\n\nNotes:\n- Angles do not appear in this problem, so no angle unit is required.\n- The outputs are pure numbers without physical units.\n- Ensure scientific realism by enforcing the acceptance/rejection logic and bounding the time step as described; do not rely on any unstated formulas.", "solution": "The posed problem is a standard exercise in the numerical solution of partial differential equations, specifically the transient heat equation. It requires the application of the finite element method (FEM) for spatial discretization and an adaptive implicit time-stepping scheme for the temporal evolution. The problem is well-defined, scientifically sound, and contains all necessary parameters for a unique numerical solution. We proceed with the derivation and implementation.\n\n**1. Weak Formulation and Spatial Discretization**\n\nThe problem is governed by the strong form of the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + s(x,t), \\quad x \\in (0,L), \\; t \\in (0,T]\n$$\nwith homogeneous Dirichlet boundary conditions, $u(0,t) = u(L,t) = 0$, and a zero initial condition, $u(x,0) = 0$.\n\nTo derive the weak formulation, we multiply the PDE by an arbitrary test function $w(x)$ from a suitable function space and integrate over the spatial domain $\\Omega = (0,L)$. The test functions are chosen from the Sobolev space $H_0^1(0,L)$, which consists of functions that are square-integrable, have square-integrable first derivatives, and are zero at the boundaries $x=0$ and $x=L$. This yields the weighted residual statement:\n$$\n\\int_0^L \\left( \\frac{\\partial u}{\\partial t} - k \\frac{\\partial^2 u}{\\partial x^2} - s(x,t) \\right) w(x) \\, dx = 0 \\quad \\forall w \\in H_0^1(0,L)\n$$\nWe apply integration by parts to the diffusion term to reduce the order of the spatial derivative and transfer one derivative from the solution $u$ to the test function $w$:\n$$\n- \\int_0^L \\frac{\\partial^2 u}{\\partial x^2} w(x) \\, dx = \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial w}{\\partial x} \\, dx - \\left[ \\frac{\\partial u}{\\partial x} w(x) \\right]_0^L\n$$\nThe boundary term, $\\left[ \\frac{\\partial u}{\\partial x} w(x) \\right]_0^L = \\frac{\\partial u}{\\partial x}(L,t)w(L) - \\frac{\\partial u}{\\partial x}(0,t)w(0)$, is identically zero because $w(0)=0$ and $w(L)=0$ by definition of the test space $H_0^1(0,L)$. This leads to the weak form of the problem: find $u(t) \\in H^1(0,L)$ with $u(0,t)=u(L,t)=0$ such that for all $w \\in H_0^1(0,L)$:\n$$\n\\int_0^L \\frac{\\partial u}{\\partial t} w \\, dx + k \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial w}{\\partial x} \\, dx = \\int_0^L s(x,t) w \\, dx\n$$\nFor the finite element method, we approximate the solution $u(x,t)$ in a finite-dimensional subspace $V_h \\subset H^1(0,L)$ spanned by piecewise-linear basis functions $N_j(x)$:\n$$\nu(x,t) \\approx u_h(x,t) = \\sum_{j=1}^{N_n} U_j(t) N_j(x)\n$$\nwhere $U_j(t)$ are the time-dependent nodal values. The boundary conditions $u(0,t)=0$ and $u(L,t)=0$ enforce $U_1(t)=0$ and $U_{N_n}(t)=0$, leaving $N_{dof} = N_n-2$ interior nodal values as unknowns. The Galerkin method employs the same basis functions for the test space, $w(x) = N_i(x)$ for each interior node $i \\in \\{2, \\ldots, N_n-1\\}$. Substituting the approximation into the weak form yields a system of ordinary differential equations (ODEs):\n$$\n\\sum_{j=2}^{N_n-1} \\left( \\int_0^L N_i N_j \\, dx \\right) \\frac{dU_j}{dt} + k \\sum_{j=2}^{N_n-1} \\left( \\int_0^L \\frac{dN_i}{dx} \\frac{dN_j}{dx} \\, dx \\right) U_j = \\int_0^L s(x,t) N_i \\, dx\n$$\nThis is the semi-discrete system, which can be expressed in matrix form as:\n$$\n\\mathbf{M} \\frac{d\\mathbf{U}}{dt} + k \\mathbf{K} \\mathbf{U} = \\mathbf{F}(t)\n$$\nwhere $\\mathbf{U}(t)$ is the vector of the $N_{dof}$ unknown interior nodal values. The system matrices are:\n-   **Consistent Mass Matrix**: $M_{ij} = \\int_0^L N_i(x) N_j(x) \\, dx$\n-   **Stiffness Matrix**: $K_{ij} = \\int_0^L \\frac{dN_i}{dx}\\frac{dN_j}{dx} \\, dx$\n-   **Load Vector**: $F_i(t) = \\int_0^L s(x,t) N_i(x) \\, dx$\n\n**2. Temporal Discretization and Adaptive Step Control**\n\nThe semi-discrete ODE system is solved using the Crank–Nicolson method, a second-order accurate implicit scheme. Discretizing in time from $t_n$ to $t_{n+1} = t_n + \\Delta t$, the scheme is:\n$$\n\\mathbf{M} \\frac{\\mathbf{U}_{n+1} - \\mathbf{U}_n}{\\Delta t} = \\frac{1}{2}\\left[ (\\mathbf{F}_n - k\\mathbf{K}\\mathbf{U}_n) + (\\mathbf{F}_{n+1} - k\\mathbf{K}\\mathbf{U}_{n+1}) \\right]\n$$\nRearranging to isolate the unknown vector $\\mathbf{U}_{n+1}$ results in a linear system to be solved at each time step:\n$$\n\\left( \\mathbf{M} + \\frac{k\\Delta t}{2}\\mathbf{K} \\right) \\mathbf{U}_{n+1} = \\left( \\mathbf{M} - \\frac{k\\Delta t}{2}\\mathbf{K} \\right) \\mathbf{U}_n + \\frac{\\Delta t}{2}(\\mathbf{F}_n + \\mathbf{F}_{n+1})\n$$\nAdaptive time-stepping is implemented via step doubling. The local truncation error (LTE) of the Crank-Nicolson method is $\\mathcal{O}(\\Delta t^3)$. We compute two solutions at $t_{n+1}$: $\\mathbf{U}_{n+1}^{(1)}$ using one step of size $\\Delta t$, and $\\mathbf{U}_{n+1}^{(2)}$ using two steps of size $\\Delta t/2$. The difference vector $\\mathbf{d} = \\mathbf{U}_{n+1}^{(2)} - \\mathbf{U}_{n+1}^{(1)}$ serves as an estimate of the LTE. A scalar error measure is defined as the mass-matrix weighted norm of this difference:\n$$\n\\text{err} = \\frac{\\sqrt{\\mathbf{d}^T \\mathbf{M} \\mathbf{d}}}{\\sqrt{N_{dof}}}\n$$\nIf $\\text{err} \\le \\text{tol}$, the step is accepted, and the solution is advanced using the more accurate result: $\\mathbf{U}_{n+1} = \\mathbf{U}_{n+1}^{(2)}$. If not, the step is rejected, and the calculation is repeated with a smaller $\\Delta t$. The new step size is calculated based on the error scaling property:\n$$\n\\Delta t_{\\text{new}} = \\eta \\, \\Delta t \\left( \\frac{\\text{tol}}{\\text{err}} \\right)^{1/3}\n$$\nwhere $\\eta$ is a safety factor. The step size is further bounded by specified minimum/maximum values and growth/shrink factors to ensure the stability of the controller.\n\n**3. Implementation and Final Analysis**\n\nThe algorithm is implemented in Python. The matrices $\\mathbf{M}$ and $\\mathbf{K}$ are assembled for the interior degrees of freedom. The load vector $\\mathbf{F}(t)$ requires numerical integration of the source term against each basis function, for which `scipy.integrate.quad` is suitable. The time-stepping loop executes the adaptive Crank–Nicolson scheme until the final time $T$ is reached. At each accepted step, the front location is identified as the midpoint of the element with the highest gradient magnitude. Finally, the Pearson correlation coefficient is computed between the sequence of accepted time steps $\\{\\Delta t_i\\}$ and a tracking metric $\\{y_i\\}$, defined as the reciprocal of the front speed. This analysis is performed for each specified source speed $v$.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve_for_v(v_val, params):\n    \"\"\"\n    Solves the 1D transient heat equation for a given source speed v.\n    \"\"\"\n    # --- Problem Parameters ---\n    k, L, T_final, A, sigma, x0 = params['phys']\n    v = v_val\n\n    # --- Numerical Parameters ---\n    Ne, TOL, DT_INIT, DT_MIN, DT_MAX, ETA, G_MAX, G_MIN, EPS_REG = params['num']\n    Nn = Ne + 1\n    Ndof = Nn - 2\n    h = L / Ne\n\n    # --- Spatial Grid ---\n    nodes = np.linspace(0, L, Nn)\n\n    # --- Assemble Mass and Stiffness Matrices (for interior nodes) ---\n    M = np.zeros((Ndof, Ndof))\n    K = np.zeros((Ndof, Ndof))\n\n    diag_M = 2 * h / 3\n    offdiag_M = h / 6\n    diag_K = 2 / h\n    offdiag_K = -1 / h\n\n    for i in range(Ndof):\n        M[i, i] = diag_M\n        K[i, i] = diag_K\n        if i > 0:\n            M[i, i-1] = offdiag_M\n            K[i, i-1] = offdiag_K\n        if i < Ndof - 1:\n            M[i, i+1] = offdiag_M\n            K[i, i+1] = offdiag_K\n\n    # --- Source Term Functions ---\n    def source_center(t):\n        return x0 + v * t\n\n    def source_func(x, t):\n        xc = source_center(t)\n        return A * np.exp(-(x - xc)**2 / (2 * sigma**2))\n\n    # --- Force Vector Calculation ---\n    memo_F = {}\n    def get_force_vector(t):\n        if t in memo_F:\n            return memo_F[t]\n\n        F = np.zeros(Ndof)\n        for i_dof in range(Ndof):\n            i_glob = i_dof + 1\n            x_prev, x_curr, x_next = nodes[i_glob-1], nodes[i_glob], nodes[i_glob+1]\n            \n            def N_left(x): return (x - x_prev) / h\n            def N_right(x): return (x_next - x) / h\n            \n            integral_left, _ = quad(lambda x: source_func(x, t) * N_left(x), x_prev, x_curr, epsabs=1e-9)\n            integral_right, _ = quad(lambda x: source_func(x, t) * N_right(x), x_curr, x_next, epsabs=1e-9)\n            \n            F[i_dof] = integral_left + integral_right\n        \n        memo_F[t] = F\n        return F\n\n    # --- Front Location Calculation ---\n    def get_front_location(U_full):\n        grads = np.abs(np.diff(U_full)) / h\n        max_grad_elem_idx = np.argmax(grads)\n        return (nodes[max_grad_elem_idx] + nodes[max_grad_elem_idx + 1]) / 2\n\n    # --- Time Marching Loop ---\n    t = 0.0\n    dt = DT_INIT\n    U = np.zeros(Ndof)\n\n    initial_elem_idx = int(np.floor(x0 / h))\n    x_front_0 = (nodes[initial_elem_idx] + nodes[initial_elem_idx+1]) / 2.0\n    \n    accepted_steps = []\n    front_locations = [x_front_0]\n\n    while t < T_final:\n        final_step = False\n        if t + dt >= T_final:\n            dt = T_final - t\n            final_step = True\n        \n        if dt < 1e-12: break\n\n        # --- Step Doubling ---\n        dt_full = dt\n        A1 = M + (k * dt_full / 2) * K\n        F_n = get_force_vector(t)\n        F_n1 = get_force_vector(t + dt_full)\n        b1 = (M - (k * dt_full / 2) * K) @ U + (dt_full / 2) * (F_n + F_n1)\n        U_n1_1 = np.linalg.solve(A1, b1)\n\n        dt_half = dt / 2\n        A2 = M + (k * dt_half / 2) * K\n        F_n_half = get_force_vector(t + dt_half)\n        \n        b2_1 = (M - (k * dt_half / 2) * K) @ U + (dt_half / 2) * (F_n + F_n_half)\n        U_n_half = np.linalg.solve(A2, b2_1)\n        \n        b2_2 = (M - (k * dt_half / 2) * K) @ U_n_half + (dt_half / 2) * (F_n_half + F_n1)\n        U_n1_2 = np.linalg.solve(A2, b2_2)\n\n        # --- Error Estimation ---\n        d = U_n1_2 - U_n1_1\n        err = np.sqrt(np.dot(d, M @ d) / Ndof)\n        \n        # --- Step Control ---\n        if err <= TOL or final_step:\n            t += dt\n            U = U_n1_2\n            \n            accepted_steps.append(dt)\n            U_full = np.concatenate(([0], U, [0]))\n            front_loc = get_front_location(U_full)\n            front_locations.append(front_loc)\n\n            if final_step: break\n                \n            if err < 1e-12:\n                dt_new = G_MAX * dt\n            else:\n                dt_new = ETA * dt * (TOL / err)**(1/3.0)\n            \n            dt = np.clip(dt_new, G_MIN * dt, G_MAX * dt)\n            dt = np.clip(dt, DT_MIN, DT_MAX)\n\n        else:\n            if err < 1e-12:\n                dt_new = G_MIN * dt\n            else:\n                dt_new = ETA * dt * (TOL / err)**(1/3.0)\n            dt = np.clip(dt_new, G_MIN * dt, G_MAX * dt)\n            dt = np.clip(dt, DT_MIN, DT_MAX)\n\n    # --- Post-processing: Correlation Calculation ---\n    delta_t_seq = np.array(accepted_steps)\n    front_loc_seq = np.array(front_locations)\n    \n    if len(delta_t_seq) < 2: return 0.0\n\n    front_speeds = np.abs(np.diff(front_loc_seq)) / delta_t_seq\n    y_seq = 1.0 / (EPS_REG + front_speeds)\n\n    if np.var(delta_t_seq) == 0 or np.var(y_seq) == 0:\n        return 0.0\n    else:\n        return np.corrcoef(delta_t_seq, y_seq)[0, 1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    params = {\n        'phys': (1.0, 1.0, 0.5, 10.0, 0.05, 0.2), # k, L, T, A, sigma, x0\n        'num': (100, 1.0e-4, 1.0e-3, 1.0e-4, 2.0e-2, 0.9, 2.0, 0.5, 1.0e-8) # Ne, TOL, ...\n    }\n    \n    test_cases_v = [0.0, 0.4, 0.8]\n    results = [solve_for_v(v, params) for v in test_cases_v]\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2607783"}]}