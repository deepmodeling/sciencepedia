{"hands_on_practices": [{"introduction": "Before any code can be written, a solid grasp of the underlying theory is essential. This first practice challenges you to derive the core constitutive relations for a classic incompressible hyperelastic model from its strain-energy function. By working through the derivation of the Kirchhoff stress tensor and the consistent spatial tangent modulus [@problem_id:2545790], you will build the analytical foundation required for a robust finite element implementation.", "problem": "Consider a three-dimensional, isotropic, incompressible hyperelastic solid in a spatial (Eulerian) finite element formulation. The strain-energy density is assumed to be purely isochoric and given by the Mooney–Rivlin form\n$$\nW(\\bar{I}_{1},\\bar{I}_{2}) \\;=\\; c_{1}\\,(\\bar{I}_{1}-3) \\;+\\; c_{2}\\,(\\bar{I}_{2}-3),\n$$\nwhere $c_{1}$ and $c_{2}$ are positive material parameters, $\\bar{I}_{1}$ and $\\bar{I}_{2}$ are the first and second invariants of the isochoric left Cauchy–Green tensor $\\bar{\\boldsymbol{B}}$, and incompressibility implies $J=\\det \\boldsymbol{F}=1$ so that $\\bar{\\boldsymbol{B}}=J^{-2/3}\\boldsymbol{B}=\\boldsymbol{B}$. Here $\\boldsymbol{F}$ is the deformation gradient and $\\boldsymbol{B}=\\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}}$ is the left Cauchy–Green tensor. Let $\\boldsymbol{\\tau}$ denote the Kirchhoff stress and $\\boldsymbol{\\sigma}=\\boldsymbol{\\tau}/J$ the Cauchy stress. The incompressibility is enforced by a Lagrange multiplier (pressure) $p$.\n\nStarting only from the standard hyperelastic relations (Kirchhoff stress obtained by pushing forward $\\partial W/\\partial \\boldsymbol{C}$, with $\\boldsymbol{C}=\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$, and the definitions of the invariants of $\\boldsymbol{C}$ or $\\boldsymbol{B}$), derive:\n\n1) The Kirchhoff stress $\\boldsymbol{\\tau}$ in terms of $\\bar{\\boldsymbol{B}}$ and $\\bar{\\boldsymbol{B}}^{-1}$.\n\n2) The spatial, algorithmically consistent tangent (elasticity) tensor $\\mathbb{c}$ mapping the rate-of-deformation tensor $\\boldsymbol{d}=\\tfrac{1}{2}(\\boldsymbol{L}+\\boldsymbol{L}^{\\mathsf{T}})$ to the Jaumann rate of the isochoric part of the Kirchhoff stress, $\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}}=\\mathbb{c}:\\boldsymbol{d}$, expressed purely in terms of $\\bar{\\boldsymbol{B}}$ and $\\bar{\\boldsymbol{B}}^{-1}$ and the material parameters $c_{1},c_{2}$. The vorticity $\\boldsymbol{w}=\\tfrac{1}{2}(\\boldsymbol{L}-\\boldsymbol{L}^{\\mathsf{T}})$ defines the Jaumann rate $\\overset{\\nabla}{(\\cdot)}=\\dot{(\\cdot)}-\\boldsymbol{w}(\\cdot)+(\\cdot)\\,\\boldsymbol{w}$, and you may use $\\overset{\\nabla}{\\bar{\\boldsymbol{B}}}=\\boldsymbol{d}\\,\\bar{\\boldsymbol{B}}+\\bar{\\boldsymbol{B}}\\,\\boldsymbol{d}-\\tfrac{2}{3}(\\mathrm{tr}\\,\\boldsymbol{d})\\,\\bar{\\boldsymbol{B}}$ and $\\overset{\\nabla}{\\bar{\\boldsymbol{B}}^{-1}}=-\\bar{\\boldsymbol{B}}^{-1}\\,\\overset{\\nabla}{\\bar{\\boldsymbol{B}}}\\,\\bar{\\boldsymbol{B}}^{-1}$ as kinematic identities. Write your final tensorial expression for $\\mathbb{c}$ using the left-right dyadic product $\\otimes$ defined by $(\\boldsymbol{A}\\otimes\\boldsymbol{C}):\\boldsymbol{X}=\\boldsymbol{A}\\,\\boldsymbol{X}\\,\\boldsymbol{C}^{\\mathsf{T}}$ and the identity tensor $\\boldsymbol{I}$.\n\nProvide your final result as a pair consisting of the symbolic expressions for $\\boldsymbol{\\tau}$ and $\\mathbb{c}$, with no numerical substitution. Your final answer must be a single, closed-form analytic expression; place both entries in a single row using the LaTeX $\\,\\mathrm{pmatrix}\\,$ format. No units are required. Round-off is not applicable.", "solution": "The problem is validated as self-contained, scientifically grounded, and well-posed. We proceed with the derivation.\n\nThe problem asks for two quantities for an incompressible Mooney-Rivlin hyperelastic material: the Kirchhoff stress tensor $\\boldsymbol{\\tau}$ and the spatial elasticity tensor $\\mathbb{c}$.\n\nPart 1: Derivation of the Kirchhoff Stress Tensor $\\boldsymbol{\\tau}$\n\nFor a hyperelastic material, the rate of work done per unit current volume is given by the contraction of the Kirchhoff stress tensor $\\boldsymbol{\\tau}$ with the rate-of-deformation tensor $\\boldsymbol{d}$. This must be equal to the rate of change of the stored strain energy density $W$. For an incompressible material, $J=\\det\\boldsymbol{F}=1$, which implies $\\text{tr}(\\boldsymbol{d})=0$. The stress response is composed of a part derived from the strain energy and a hydrostatic pressure part due to the incompressibility constraint. The Kirchhoff stress $\\boldsymbol{\\tau}$ is thus written as:\n$$\n\\boldsymbol{\\tau} = -p\\boldsymbol{I} + \\boldsymbol{\\tau}_{\\text{iso}}\n$$\nwhere $p$ is the Lagrange multiplier (pressure) and $\\boldsymbol{\\tau}_{\\text{iso}}$ is the part of the stress derived from the strain-energy function $W$. The power equation is $\\boldsymbol{\\tau}:\\boldsymbol{d} = \\dot{W}$. Since $(\\text{-}p\\boldsymbol{I}):\\boldsymbol{d} = -p\\,\\text{tr}(\\boldsymbol{d}) = 0$ for incompressible materials, we have $\\boldsymbol{\\tau}_{\\text{iso}}:\\boldsymbol{d} = \\dot{W}$.\n\nThe strain-energy density is given as $W = c_{1}\\,(\\bar{I}_{1}-3) + c_{2}\\,(\\bar{I}_{2}-3)$. For an incompressible material with $J=1$, the isochoric left Cauchy-Green tensor $\\bar{\\boldsymbol{B}} = J^{-2/3}\\boldsymbol{B}$ becomes identical to the left Cauchy-Green tensor $\\boldsymbol{B}$. Thus, $\\bar{\\boldsymbol{B}} = \\boldsymbol{B}$. The invariants are then given by:\n$$\n\\bar{I}_{1} = \\mathrm{tr}(\\bar{\\boldsymbol{B}}) = \\mathrm{tr}(\\boldsymbol{B})\n$$\n$$\n\\bar{I}_{2} = \\frac{1}{2}\\left( (\\mathrm{tr}(\\bar{\\boldsymbol{B}}))^{2} - \\mathrm{tr}(\\bar{\\boldsymbol{B}}^{2}) \\right) = \\mathrm{tr}(\\bar{\\boldsymbol{B}}^{-1}) = \\mathrm{tr}(\\boldsymbol{B}^{-1})\n$$\nThe last equality for $\\bar{I}_{2}$ follows from the Cayley-Hamilton theorem for a tensor with determinant $1$. So, the strain energy is $W = c_{1}(\\mathrm{tr}(\\boldsymbol{B})-3) + c_{2}(\\mathrm{tr}(\\boldsymbol{B}^{-1})-3)$.\n\nTo find $\\boldsymbol{\\tau}_{\\text{iso}}$, we compute the material time derivative of $W$:\n$$\n\\dot{W} = \\frac{\\partial W}{\\partial \\bar{I}_1}\\dot{\\bar{I}}_1 + \\frac{\\partial W}{\\partial \\bar{I}_2}\\dot{\\bar{I}}_2 = c_1 \\frac{d}{dt}(\\mathrm{tr}(\\boldsymbol{B})) + c_2 \\frac{d}{dt}(\\mathrm{tr}(\\boldsymbol{B}^{-1}))\n$$\nThe material time derivative of the left Cauchy-Green tensor $\\boldsymbol{B}$ is $\\dot{\\boldsymbol{B}} = \\boldsymbol{L}\\boldsymbol{B} + \\boldsymbol{B}\\boldsymbol{L}^{\\mathsf{T}}$, where $\\boldsymbol{L}=\\dot{\\boldsymbol{F}}\\boldsymbol{F}^{-1}$ is the velocity gradient. Using $\\boldsymbol{L}=\\boldsymbol{d}+\\boldsymbol{w}$ where $\\boldsymbol{d}$ is symmetric and $\\boldsymbol{w}$ is skew-symmetric, we have:\n$$\n\\dot{\\bar{I}}_1 = \\frac{d}{dt}(\\mathrm{tr}(\\boldsymbol{B})) = \\mathrm{tr}(\\dot{\\boldsymbol{B}}) = \\mathrm{tr}(\\boldsymbol{L}\\boldsymbol{B} + \\boldsymbol{B}\\boldsymbol{L}^{\\mathsf{T}}) = \\mathrm{tr}(\\boldsymbol{B}(\\boldsymbol{L}^{\\mathsf{T}} + \\boldsymbol{L})) = \\mathrm{tr}(2\\boldsymbol{B}\\boldsymbol{d}) = 2\\boldsymbol{B}:\\boldsymbol{d}\n$$\nThe time derivative of the inverse tensor $\\boldsymbol{B}^{-1}$ is $\\dot{\\boldsymbol{B}^{-1}} = -\\boldsymbol{B}^{-1}\\dot{\\boldsymbol{B}}\\boldsymbol{B}^{-1}$. So:\n$$\n\\dot{\\bar{I}}_2 = \\frac{d}{dt}(\\mathrm{tr}(\\boldsymbol{B}^{-1})) = \\mathrm{tr}(\\dot{\\boldsymbol{B}^{-1}}) = -\\mathrm{tr}(\\boldsymbol{B}^{-1}\\dot{\\boldsymbol{B}}\\boldsymbol{B}^{-1}) = -\\mathrm{tr}(\\dot{\\boldsymbol{B}}\\boldsymbol{B}^{-2})\n$$\nThis path is less direct. Instead:\n$$\n\\dot{\\bar{I}}_2 = \\mathrm{tr}(-\\boldsymbol{B}^{-1}(\\boldsymbol{L}\\boldsymbol{B}+\\boldsymbol{B}\\boldsymbol{L}^{\\mathsf{T}})\\boldsymbol{B}^{-1}) = -\\mathrm{tr}(\\boldsymbol{B}^{-1}\\boldsymbol{L}+\\boldsymbol{L}^{\\mathsf{T}}\\boldsymbol{B}^{-1}) = -\\mathrm{tr}(\\boldsymbol{B}^{-1}(\\boldsymbol{L}+\\boldsymbol{L}^{\\mathsf{T}})) = -2\\mathrm{tr}(\\boldsymbol{B}^{-1}\\boldsymbol{d}) = -2\\boldsymbol{B}^{-1}:\\boldsymbol{d}\n$$\nSubstituting these rates into the expression for $\\dot{W}$:\n$$\n\\dot{W} = c_1(2\\boldsymbol{B}:\\boldsymbol{d}) + c_2(-2\\boldsymbol{B}^{-1}:\\boldsymbol{d}) = (2c_1\\boldsymbol{B} - 2c_2\\boldsymbol{B}^{-1}):\\boldsymbol{d}\n$$\nBy comparing this with $\\dot{W} = \\boldsymbol{\\tau}_{\\text{iso}}:\\boldsymbol{d}$, we identify:\n$$\n\\boldsymbol{\\tau}_{\\text{iso}} = 2c_1\\boldsymbol{B} - 2c_2\\boldsymbol{B}^{-1}\n$$\nThe total Kirchhoff stress, using $\\bar{\\boldsymbol{B}}=\\boldsymbol{B}$ for the incompressible case, is:\n$$\n\\boldsymbol{\\tau} = -p\\boldsymbol{I} + 2c_1\\bar{\\boldsymbol{B}} - 2c_2\\bar{\\boldsymbol{B}}^{-1}\n$$\n\nPart 2: Derivation of the Spatial Elasticity Tensor $\\mathbb{c}$\n\nThe problem asks for the spatial elasticity tensor $\\mathbb{c}$ defined by the relation $\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}}=\\mathbb{c}:\\boldsymbol{d}$, where $\\overset{\\nabla}{(\\cdot)}$ is the Jaumann rate. We need to compute the Jaumann rate of $\\boldsymbol{\\tau}_{\\text{iso}}$:\n$$\n\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}} = \\overset{\\nabla}{(2c_1\\bar{\\boldsymbol{B}} - 2c_2\\bar{\\boldsymbol{B}}^{-1})} = 2c_1\\overset{\\nabla}{\\bar{\\boldsymbol{B}}} - 2c_2\\overset{\\nabla}{\\bar{\\boldsymbol{B}}^{-1}}\n$$\nThe problem provides the kinematic identity $\\overset{\\nabla}{\\bar{\\boldsymbol{B}}}=\\boldsymbol{d}\\,\\bar{\\boldsymbol{B}}+\\bar{\\boldsymbol{B}}\\,\\boldsymbol{d}-\\tfrac{2}{3}(\\mathrm{tr}\\,\\boldsymbol{d})\\,\\bar{\\boldsymbol{B}}$. For an incompressible material, $\\mathrm{tr}(\\boldsymbol{d})=0$. Thus, the identity simplifies to:\n$$\n\\overset{\\nabla}{\\bar{\\boldsymbol{B}}} = \\boldsymbol{d}\\,\\bar{\\boldsymbol{B}} + \\bar{\\boldsymbol{B}}\\,\\boldsymbol{d}\n$$\nUsing the second identity $\\overset{\\nabla}{\\bar{\\boldsymbol{B}}^{-1}} = -\\bar{\\boldsymbol{B}}^{-1}\\,\\overset{\\nabla}{\\bar{\\boldsymbol{B}}}\\,\\bar{\\boldsymbol{B}}^{-1}$, we find:\n$$\n\\overset{\\nabla}{\\bar{\\boldsymbol{B}}^{-1}} = -\\bar{\\boldsymbol{B}}^{-1}(\\boldsymbol{d}\\,\\bar{\\boldsymbol{B}} + \\bar{\\boldsymbol{B}}\\,\\boldsymbol{d})\\bar{\\boldsymbol{B}}^{-1} = -(\\bar{\\boldsymbol{B}}^{-1}\\boldsymbol{d} + \\boldsymbol{d}\\bar{\\boldsymbol{B}}^{-1})\n$$\nSubstituting these rates into the expression for $\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}}$:\n$$\n\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}} = 2c_1(\\boldsymbol{d}\\,\\bar{\\boldsymbol{B}} + \\bar{\\boldsymbol{B}}\\,\\boldsymbol{d}) - 2c_2(-(\\bar{\\boldsymbol{B}}^{-1}\\boldsymbol{d} + \\boldsymbol{d}\\bar{\\boldsymbol{B}}^{-1}))\n$$\n$$\n\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}} = 2c_1(\\boldsymbol{d}\\,\\bar{\\boldsymbol{B}} + \\bar{\\boldsymbol{B}}\\,\\boldsymbol{d}) + 2c_2(\\bar{\\boldsymbol{B}}^{-1}\\boldsymbol{d} + \\boldsymbol{d}\\bar{\\boldsymbol{B}}^{-1})\n$$\nWe must now express this result in the form $\\mathbb{c}:\\boldsymbol{d}$, using the dyadic product definition $(\\boldsymbol{A}\\otimes\\boldsymbol{C}):\\boldsymbol{X}=\\boldsymbol{A}\\,\\boldsymbol{X}\\,\\boldsymbol{C}^{\\mathsf{T}}$. Given that $\\boldsymbol{d}$ and $\\bar{\\boldsymbol{B}}$ are symmetric:\nThe term $\\bar{\\boldsymbol{B}}\\boldsymbol{d}$ can be written as $(\\bar{\\boldsymbol{B}}\\otimes\\boldsymbol{I}):\\boldsymbol{d} = \\bar{\\boldsymbol{B}}\\boldsymbol{d}\\boldsymbol{I}^{\\mathsf{T}} = \\bar{\\boldsymbol{B}}\\boldsymbol{d}$.\nThe term $\\boldsymbol{d}\\bar{\\boldsymbol{B}}$ can be written as $(\\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}}):\\boldsymbol{d} = \\boldsymbol{I}\\boldsymbol{d}\\bar{\\boldsymbol{B}}^{\\mathsf{T}} = \\boldsymbol{d}\\bar{\\boldsymbol{B}}$.\nApplying this to all terms in the expression for $\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}}$ yields:\n$$\n\\overset{\\nabla}{\\boldsymbol{\\tau}}_{\\text{iso}} = \\left[ 2c_1(\\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}} + \\bar{\\boldsymbol{B}}\\otimes\\boldsymbol{I}) + 2c_2(\\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}}^{-1} + \\bar{\\boldsymbol{B}}^{-1}\\otimes\\boldsymbol{I}) \\right] : \\boldsymbol{d}\n$$\nFrom this, we identify the fourth-order tensor $\\mathbb{c}$:\n$$\n\\mathbb{c} = 2c_1(\\bar{\\boldsymbol{B}}\\otimes\\boldsymbol{I} + \\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}}) + 2c_2(\\bar{\\boldsymbol{B}}^{-1}\\otimes\\boldsymbol{I} + \\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}}^{-1})\n$$\nThis is the final expression for the spatial elasticity tensor.", "answer": "$$\n\\boxed{\\begin{pmatrix} -p\\boldsymbol{I} + 2c_{1}\\bar{\\boldsymbol{B}} - 2c_{2}\\bar{\\boldsymbol{B}}^{-1} & 2c_{1}(\\bar{\\boldsymbol{B}}\\otimes\\boldsymbol{I} + \\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}}) + 2c_{2}(\\bar{\\boldsymbol{B}}^{-1}\\otimes\\boldsymbol{I} + \\boldsymbol{I}\\otimes\\bar{\\boldsymbol{B}}^{-1}) \\end{pmatrix}}\n$$", "id": "2545790"}, {"introduction": "A correct constitutive theory is only half the battle; its numerical implementation within a finite element framework presents its own unique challenges. This exercise explores the notorious phenomena of volumetric locking and hourglassing that can arise in low-order elements. By implementing and comparing different numerical integration schemes [@problem_id:2545811], you will gain hands-on experience in diagnosing and remedying these critical issues, a key skill in developing reliable simulations.", "problem": "Consider a single three-dimensional trilinear hexahedral element with $8$ nodes (an $8$-node brick) in the context of the Finite Element Method (FEM). The material is compressible hyperelastic neo-Hookean, and the analysis is performed in the undeformed configuration under small strains to permit a consistent tangent linearization. Use the principle of virtual work and the definition of hyperelasticity as the fundamental base.\n\nStarting from the principle of virtual work for hyperelasticity, for a body occupying a reference region with coordinates $\\mathbf{X}$, the internal virtual work is the variation of the total strain energy. At small strains around the undeformed configuration, the consistent tangent reduces to an isotropic linear mapping where the deviatoric and volumetric parts of the strain energy density separate. In this regime, with shear modulus $\\mu$ and bulk modulus $\\kappa$, the stress response operator decouples into a deviatoric part weighted by $\\mu$ and a volumetric part weighted by $\\kappa$, acting on the small strain tensor. You must use this small-strain tangent at the reference configuration to assemble the element stiffness matrix.\n\nLet the element occupy a rectangular parallelepiped of edge lengths $L_x$, $L_y$, $L_z$ aligned with the coordinate axes. The displacement field is interpolated using trilinear shape functions in the isoparametric domain $\\{(\\xi,\\eta,\\zeta)\\in[-1,1]^3\\}$. Use the standard $6$-component engineering-strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{11},\\varepsilon_{22},\\varepsilon_{33},\\gamma_{23},\\gamma_{13},\\gamma_{12}]^\\top$ with $\\gamma_{ij} = 2 \\varepsilon_{ij}$ for $i\\neq j$. The element stiffness is\n$$\n\\mathbf{K} = \\int_{\\Omega_0} \\mathbf{B}^\\top \\mathbf{C} \\,\\mathbf{B}\\, \\mathrm{d}V,\n$$\nwhere $\\mathbf{B}$ is the standard strain-displacement matrix for the $8$-node brick, and $\\mathbf{C}$ is the small-strain tangent at the undeformed state, which separates additively into a deviatoric operator and a volumetric operator.\n\nYour task is to implement three quadrature schemes for assembling $\\mathbf{K}$:\n- Scheme $\\mathsf{full}$: full integration for both volumetric and deviatoric parts using $2\\times 2\\times 2$ Gauss points at $\\xi,\\eta,\\zeta \\in \\{\\pm 1/\\sqrt{3}\\}$ with unit weights in each direction.\n- Scheme $\\mathsf{reduced}$: single-point reduced integration for the entire stiffness using the single Gauss point at $(\\xi,\\eta,\\zeta)=(0,0,0)$ with weight $2$ in each direction (total weight $8$ in three dimensions).\n- Scheme $\\mathsf{sri}$ (selective reduced integration): full integration for the deviatoric part as in $\\mathsf{full}$, and single-point reduced integration for the volumetric part as in $\\mathsf{reduced}$.\n\nAnalyze the impact on hourglass modes by computing the eigenvalues of the assembled element stiffness matrix $\\mathbf{K}$ for a free-free element (i.e., no essential boundary conditions). In a consistent small-strain formulation, rigid body motions contribute zero-energy modes. Hourglass modes appear as additional spurious zero-energy modes when under-integration does not capture all strain modes. To quantify this, let $\\lambda_i$ be the eigenvalues of $\\mathbf{K}$ and define a near-zero eigenvalue as one with magnitude less than a tolerance $\\tau$, where\n$$\n\\tau = \\max\\left(10^{-7} \\max_i \\lambda_i,\\; 10^{-12}\\right).\n$$\nCount the number of eigenvalues with absolute value less than or equal to $\\tau$.\n\nImplement a complete, runnable program that:\n- Constructs the $8$-node brick element stiffness matrix $\\mathbf{K}$ for each scheme using the small-strain tangent split into volumetric and deviatoric parts at the undeformed state and the appropriate quadrature rule(s) as stated above.\n- Computes the eigenvalues of $\\mathbf{K}$ and counts the number of near-zero eigenvalues for each test case as the measure of zero-energy modes (rigid body plus possible hourglass modes).\n\nNo physical output units are required for the final integer counts. Angles are not involved. All computations must be internally consistent in any chosen unit system.\n\nTest suite:\n- Case $1$: $\\mu = 8.0\\times 10^{4}$, $\\kappa = 1.6\\times 10^{5}$, $L_x=1$, $L_y=1$, $L_z=1$, scheme $\\mathsf{full}$.\n- Case $2$: same parameters as Case $1$, scheme $\\mathsf{reduced}$.\n- Case $3$: same parameters as Case $1$, scheme $\\mathsf{sri}$.\n- Case $4$: $\\mu = 8.0\\times 10^{4}$, $\\kappa = 1.6\\times 10^{5}$, $L_x=2$, $L_y=1$, $L_z=0.5$, scheme $\\mathsf{sri}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where $r_j$ is the integer number of near-zero eigenvalues for Case $j$ in the order listed above.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for its resolution. It represents a standard and fundamental exercise in the theory and application of the Finite Element Method. We proceed to the solution.\n\nThe foundation of the analysis is the principle of virtual work, which for a hyperelastic material states that the internal virtual work is the variation of the total strain energy, $\\delta W_{int} = \\delta \\Pi$. The stiffness matrix $\\mathbf{K}$ relates the nodal forces to nodal displacements and is obtained from the second variation of the strain energy potential. For a single finite element, this gives the expression:\n$$\n\\mathbf{K} = \\frac{\\partial^2 \\Pi}{\\partial \\mathbf{d}^2} = \\int_{\\Omega_0} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}V\n$$\nwhere $\\mathbf{d}$ is the vector of nodal displacements, $\\Omega_0$ is the element's volume in the reference configuration, $\\mathbf{B}$ is the strain-displacement matrix, and $\\mathbf{C}$ is the constitutive tangent modulus. The problem specifies a small-strain formulation at the undeformed state, where $\\mathbf{C}$ becomes the standard isotropic linear elasticity tensor.\n\nThe solution requires a three-part construction:\n1. Formulation of the constitutive matrix $\\mathbf{C}$ and its decomposition.\n2. Formulation of the strain-displacement matrix $\\mathbf{B}$ for the $8$-node hexahedral element.\n3. Numerical integration of the stiffness matrix $\\mathbf{K}$ using the specified quadrature schemes.\nFinally, an eigenvalue analysis of the resulting matrix $\\mathbf{K}$ is performed to determine the number of zero-energy modes.\n\n**1. Constitutive Matrix $\\mathbf{C}$**\n\nFor an isotropic linear elastic material, the constitutive matrix $\\mathbf{C}$ maps the engineering strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, \\gamma_{23}, \\gamma_{13}, \\gamma_{12}]^\\top$ to the stress vector $\\boldsymbol{\\sigma}$. The matrix is defined by the shear modulus $\\mu$ and bulk modulus $\\kappa$.\n\nThe strain energy is additively decomposed into deviatoric and volumetric parts. This leads to an additive decomposition of the constitutive matrix: $\\mathbf{C} = \\mathbf{C}_{\\text{dev}} + \\mathbf{C}_{\\text{vol}}$.\n\nThe volumetric part is related to the volumetric strain $\\varepsilon_v = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}$. In vector form, $\\varepsilon_v = \\mathbf{m}^\\top \\boldsymbol{\\varepsilon}$ with $\\mathbf{m} = [1, 1, 1, 0, 0, 0]^\\top$. The volumetric part of the constitutive matrix is:\n$$\n\\mathbf{C}_{\\text{vol}} = \\kappa \\mathbf{m} \\mathbf{m}^\\top = \\kappa \\begin{bmatrix} 1 & 1 & 1 & 0 & 0 & 0 \\\\ 1 & 1 & 1 & 0 & 0 & 0 \\\\ 1 & 1 & 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 \\end{bmatrix}\n$$\nThe full isotropic constitutive matrix $\\mathbf{C}$ is given by:\n$$\n\\mathbf{C} = \\begin{bmatrix} \\kappa + \\frac{4}{3}\\mu & \\kappa - \\frac{2}{3}\\mu & \\kappa - \\frac{2}{3}\\mu & 0 & 0 & 0 \\\\ \\kappa - \\frac{2}{3}\\mu & \\kappa + \\frac{4}{3}\\mu & \\kappa - \\frac{2}{3}\\mu & 0 & 0 & 0 \\\\ \\kappa - \\frac{2}{3}\\mu & \\kappa - \\frac{2}{3}\\mu & \\kappa + \\frac{4}{3}\\mu & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\mu & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\mu & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\mu \\end{bmatrix}\n$$\nThe deviatoric part is then $\\mathbf{C}_{\\text{dev}} = \\mathbf{C} - \\mathbf{C}_{\\text{vol}}$:\n$$\n\\mathbf{C}_{\\text{dev}} = \\mu \\begin{bmatrix} 4/3 & -2/3 & -2/3 & 0 & 0 & 0 \\\\ -2/3 & 4/3 & -2/3 & 0 & 0 & 0 \\\\ -2/3 & -2/3 & 4/3 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 \\end{bmatrix}\n$$\n\n**2. Strain-Displacement Matrix $\\mathbf{B}$**\n\nThe displacement field $\\mathbf{u}(\\mathbf{X})$ is interpolated from the nodal displacements $\\mathbf{d}$ using trilinear shape functions $N_i(\\xi, \\eta, \\zeta)$:\n$$\n\\mathbf{u}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) \\mathbf{u}_i\n$$\nThe shape function for node $i$ with isoparametric coordinates $(\\xi_i, \\eta_i, \\zeta_i) \\in \\{-1, 1\\}^3$ is:\n$$\nN_i(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1+\\xi_i\\xi)(1+\\eta_i\\eta)(1+\\zeta_i\\zeta)\n$$\nThe strain-displacement matrix $\\mathbf{B}$ is defined by $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}$. It is a $6\\times24$ matrix composed of $8$ blocks $\\mathbf{B}_i$ ($6\\times3$ each), corresponding to each node: $\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\ldots, \\mathbf{B}_8]$. Each block $\\mathbf{B}_i$ is built from the spatial derivatives of the shape function $N_i$:\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} & 0 \\\\ 0 & 0 & \\frac{\\partial N_i}{\\partial z} \\\\ 0 & \\frac{\\partial N_i}{\\partial z} & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial z} & 0 & \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} & 0 \\end{bmatrix}\n$$\nThe spatial derivatives are found via the chain rule using the Jacobian of the mapping from isoparametric to physical coordinates:\n$$\n\\begin{Bmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial z \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\\\ \\partial N_i/\\partial \\zeta \\end{Bmatrix}\n$$\nFor a rectangular parallelepiped of dimensions $L_x, L_y, L_z$, centered at the origin, the mapping is $x = L_x\\xi/2, y = L_y\\eta/2, z = L_z\\zeta/2$. The Jacobian matrix is diagonal and constant:\n$$\n\\mathbf{J} = \\begin{bmatrix} L_x/2 & 0 & 0 \\\\ 0 & L_y/2 & 0 \\\\ 0 & 0 & L_z/2 \\end{bmatrix} \\implies \\mathbf{J}^{-1} = \\begin{bmatrix} 2/L_x & 0 & 0 \\\\ 0 & 2/L_y & 0 \\\\ 0 & 0 & 2/L_z \\end{bmatrix}\n$$\nThe volume element for integration is $\\mathrm{d}V = \\det(\\mathbf{J})\\mathrm{d}\\xi\\mathrm{d}\\eta\\mathrm{d}\\zeta = \\frac{L_x L_y L_z}{8} \\mathrm{d}\\xi\\mathrm{d}\\eta\\mathrm{d}\\zeta$.\n\n**3. Numerical Integration of Stiffness Matrix $\\mathbf{K}$**\n\nThe integral for $\\mathbf{K}$ is evaluated numerically using Gauss quadrature:\n$$\n\\mathbf{K} = \\int_{-1}^1\\int_{-1}^1\\int_{-1}^1 \\mathbf{B}(\\xi,\\eta,\\zeta)^\\top \\mathbf{C} \\mathbf{B}(\\xi,\\eta,\\zeta) \\det(\\mathbf{J}) \\mathrm{d}\\xi\\mathrm{d}\\eta\\mathrm{d}\\zeta \\approx \\sum_{k} w_k \\mathbf{B}(\\xi_k, \\eta_k, \\zeta_k)^\\top \\mathbf{C} \\mathbf{B}(\\xi_k, \\eta_k, \\zeta_k) \\det(\\mathbf{J})\n$$\nwhere $(\\xi_k, \\eta_k, \\zeta_k)$ are the Gauss points and $w_k$ are the corresponding weights.\n\n- Scheme $\\mathsf{full}$: $2\\times2\\times2$ Gauss quadrature is used. There are $8$ points at $(\\xi, \\eta, \\zeta) \\in \\{\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}\\}$, each with weight $w_k=1$. This rule is sufficient to exactly integrate the stiffness matrix for a rectangular element. It is expected to yield $6$ zero-energy modes, corresponding to the $3$ rigid-body translations and $3$ rigid-body rotations.\n\n- Scheme $\\mathsf{reduced}$: A single Gauss point at $(\\xi, \\eta, \\zeta)=(0,0,0)$ with weight $w_k=8$ is used for the entire matrix. This scheme is computationally efficient but is unable to detect certain deformation modes (hourglass modes) that produce zero strain at the element center. For an $8$-node brick, this results in $5$ spurious zero-energy modes in addition to the $6$ rigid-body modes, for a total of $11$.\n\n- Scheme $\\mathsf{sri}$ (Selective Reduced Integration): The stiffness matrix is split: $\\mathbf{K} = \\mathbf{K}_{\\text{dev}} + \\mathbf{K}_{\\text{vol}}$.\n  - $\\mathbf{K}_{\\text{dev}} = \\int \\mathbf{B}^\\top \\mathbf{C}_{\\text{dev}} \\mathbf{B} \\,\\mathrm{d}V$ is integrated using the `full` $2\\times2\\times2$ scheme.\n  - $\\mathbf{K}_{\\text{vol}} = \\int \\mathbf{B}^\\top \\mathbf{C}_{\\text{vol}} \\mathbf{B} \\,\\mathrm{d}V$ is integrated using the `reduced` single-point scheme.\nThis technique is used to prevent volumetric locking in nearly incompressible materials while maintaining sufficient rank to resist hourglassing. The full integration of the deviatoric part provides stiffness against shear hourglass modes. This scheme is expected to yield only the $6$ authentic rigid-body zero-energy modes.\n\n**4. Eigenvalue Analysis**\n\nAfter assembling $\\mathbf{K}$ for each case, its eigenvalues $\\lambda_i$ are computed. The number of near-zero eigenvalues corresponds to the number of zero-energy modes. An eigenvalue is considered near-zero if its magnitude is less than a tolerance $\\tau = \\max(10^{-7} \\max_i \\lambda_i, 10^{-12})$. This dual relative/absolute tolerance correctly identifies numerical zeros from floating-point computations. The matrix $\\mathbf{K}$ is symmetric and positive semi-definite, so its eigenvalues are real and non-negative.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the FEM analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: mu, kappa, Lx, Ly, Lz, scheme\n        (8.0e4, 1.6e5, 1.0, 1.0, 1.0, 'full'),\n        # Case 2\n        (8.0e4, 1.6e5, 1.0, 1.0, 1.0, 'reduced'),\n        # Case 3\n        (8.0e4, 1.6e5, 1.0, 1.0, 1.0, 'sri'),\n        # Case 4\n        (8.0e4, 1.6e5, 2.0, 1.0, 0.5, 'sri'),\n    ]\n\n    results = []\n    for mu, kappa, Lx, Ly, Lz, scheme in test_cases:\n        K = assemble_stiffness_matrix(mu, kappa, Lx, Ly, Lz, scheme)\n        \n        # Eigenvalue analysis\n        # K is symmetric, use eigvalsh for efficiency and stability\n        eigenvalues = np.linalg.eigvalsh(K)\n        \n        # As K is positive-semidefinite, max(abs(lambda)) is just the max eigenvalue.\n        max_eig = eigenvalues[-1]\n        tolerance = max(1e-7 * max_eig, 1e-12)\n        \n        # Count near-zero eigenvalues\n        zero_modes_count = np.sum(eigenvalues = tolerance)\n        results.append(zero_modes_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_constitutive_matrices(mu, kappa):\n    \"\"\"\n    Constructs the deviatoric and volumetric parts of the constitutive matrix C.\n    \"\"\"\n    C_vol = np.zeros((6, 6))\n    m = np.array([1.0, 1.0, 1.0, 0.0, 0.0, 0.0])\n    C_vol = kappa * np.outer(m, m)\n\n    C_dev = np.zeros((6, 6))\n    C_dev[0, 0] = C_dev[1, 1] = C_dev[2, 2] = 4.0 / 3.0 * mu\n    C_dev[0, 1] = C_dev[1, 0] = C_dev[0, 2] = C_dev[2, 0] = C_dev[1, 2] = C_dev[2, 1] = -2.0 / 3.0 * mu\n    C_dev[3, 3] = C_dev[4, 4] = C_dev[5, 5] = mu\n    \n    return C_dev, C_vol\n\ndef get_shape_func_derivatives(xi, eta, zeta, node_iso_coords):\n    \"\"\"\n    Computes derivatives of 8-node hex shape functions w.r.t. isoparametric coordinates.\n    \"\"\"\n    dN_dxi_eta_zeta = np.zeros((8, 3))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_iso_coords[i]\n        dN_dxi_eta_zeta[i, 0] = 0.125 * xi_i * (1 + eta_i * eta) * (1 + zeta_i * zeta)\n        dN_dxi_eta_zeta[i, 1] = 0.125 * eta_i * (1 + xi_i * xi) * (1 + zeta_i * zeta)\n        dN_dxi_eta_zeta[i, 2] = 0.125 * zeta_i * (1 + xi_i * xi) * (1 + eta_i * eta)\n    return dN_dxi_eta_zeta\n\ndef get_B_matrix(dN_dxi_eta_zeta, Lx, Ly, Lz):\n    \"\"\"\n    Constructs the strain-displacement matrix B.\n    \"\"\"\n    J_inv_diag = np.array([2.0 / Lx, 2.0 / Ly, 2.0 / Lz])\n    dN_dxyz = dN_dxi_eta_zeta @ np.diag(J_inv_diag)\n\n    B = np.zeros((6, 24))\n    for i in range(8):\n        # Derivatives for node i in x, y, z\n        dN_dx_i = dN_dxyz[i, 0]\n        dN_dy_i = dN_dxyz[i, 1]\n        dN_dz_i = dN_dxyz[i, 2]\n        \n        # Populate the B matrix for node i (columns 3*i, 3*i+1, 3*i+2)\n        B[0, 3 * i] = dN_dx_i\n        B[1, 3 * i + 1] = dN_dy_i\n        B[2, 3 * i + 2] = dN_dz_i\n        B[3, 3 * i + 1] = dN_dz_i\n        B[3, 3 * i + 2] = dN_dy_i\n        B[4, 3 * i] = dN_dz_i\n        B[4, 3 * i + 2] = dN_dx_i\n        B[5, 3 * i] = dN_dy_i\n        B[5, 3 * i + 1] = dN_dx_i\n        \n    return B\n\ndef assemble_stiffness_matrix(mu, kappa, Lx, Ly, Lz, scheme):\n    \"\"\"\n    Assembles the element stiffness matrix K using the specified quadrature scheme.\n    \"\"\"\n    K = np.zeros((24, 24))\n    det_J = Lx * Ly * Lz / 8.0\n\n    # Isoparametric coordinates of the 8 nodes\n    node_iso_coords = np.array([\n        [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],\n        [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]\n    ])\n\n    C_dev, C_vol = get_constitutive_matrices(mu, kappa)\n\n    # Define Gauss quadrature points and weights\n    a = 1.0 / np.sqrt(3.0)\n    gp_8pt = [\n        (-a, -a, -a), ( a, -a, -a), ( a,  a, -a), (-a,  a, -a),\n        (-a, -a,  a), ( a, -a,  a), ( a,  a,  a), (-a,  a,  a)\n    ]\n    w_8pt = [1.0] * 8\n\n    gp_1pt = [(0.0, 0.0, 0.0)]\n    w_1pt = [8.0]\n\n    if scheme == 'full':\n        C = C_dev + C_vol\n        for i, (xi, eta, zeta) in enumerate(gp_8pt):\n            dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n            B = get_B_matrix(dN, Lx, Ly, Lz)\n            K += w_8pt[i] * B.T @ C @ B * det_J\n\n    elif scheme == 'reduced':\n        C = C_dev + C_vol\n        xi, eta, zeta = gp_1pt[0]\n        dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n        B = get_B_matrix(dN, Lx, Ly, Lz)\n        K += w_1pt[0] * B.T @ C @ B * det_J\n\n    elif scheme == 'sri':\n        # Deviatoric part with full integration\n        K_dev = np.zeros((24, 24))\n        for i, (xi, eta, zeta) in enumerate(gp_8pt):\n            dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n            B = get_B_matrix(dN, Lx, Ly, Lz)\n            K_dev += w_8pt[i] * B.T @ C_dev @ B * det_J\n        \n        # Volumetric part with reduced integration\n        K_vol = np.zeros((24, 24))\n        xi, eta, zeta = gp_1pt[0]\n        dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n        B = get_B_matrix(dN, Lx, Ly, Lz)\n        K_vol += w_1pt[0] * B.T @ C_vol @ B * det_J\n        \n        K = K_dev + K_vol\n        \n    return K\n\n# Execute the solver\nsolve()\n```", "id": "2545811"}, {"introduction": "With a material model derived and implemented, the final step is to ensure its correctness through rigorous verification. This practice focuses on a cornerstone of continuum mechanics: the principle of material frame indifference, or objectivity. You will write a program to verify that your implementation of stress and tangent tensors correctly transforms under superposed rigid-body rotations [@problem_id:2545696], a fundamental test for any robust constitutive routine.", "problem": "Design and implement a self-contained program that performs software verification tests for constitutive routines used in the Finite Element Method (FEM). The goal is to verify the principle of material frame indifference (objectivity) for both compressible and incompressible hyperelastic models at the level of the First Piola–Kirchhoff (PK1) stress and its tangent (the directional derivative of PK1 with respect to the deformation gradient).\n\nStart from the following fundamental base:\n- The hyperelastic stored energy density of a materially frame-indifferent solid depends on the right Cauchy–Green tensor $C = F^{\\mathsf T} F$, i.e., $W(F) = \\widehat{W}(C)$ for admissible $F$.\n- The PK1 stress is $P(F) = \\dfrac{\\partial W}{\\partial F}(F)$.\n- Material frame indifference under a superposed rigid rotation $Q \\in \\mathrm{SO}(3)$ requires $W(QF) = W(F)$ for all proper orthogonal $Q$ with $Q^{\\mathsf T} Q = I$ and $\\det Q = 1$.\n\nYou must implement two constitutive models:\n1. Compressible Neo-Hookean model with Lamé shear modulus $\\mu  0$ and bulk modulus $\\kappa  0$, with stored energy density\n$$\nW_{\\mathrm{c}}(F) = \\frac{\\mu}{2}\\,(I_1 - 3) - \\mu \\ln J + \\frac{\\kappa}{2}\\,(\\ln J)^2,\n$$\nwhere $I_1 = \\mathrm{tr}(C)$ and $J = \\det F$.\n2. Incompressible Neo-Hookean model with shear modulus $\\mu  0$ and Lagrange multiplier (pressure) $p \\in \\mathbb{R}$, with stored energy $W_{\\mathrm{inc}}(F) = \\dfrac{\\mu}{2}\\,(I_1 - 3)$ subject to the constraint $J = 1$ enforced by $p$. The corresponding PK1 stress depends on $F$ and $p$.\n\nFrom this base, derive expressions for the PK1 stress for each model and implement routines that compute:\n- For the compressible model, $P_{\\mathrm{c}}(F;\\mu,\\kappa)$ for any invertible $F$ with $J0$.\n- For the incompressible model at fixed $p$, $P_{\\mathrm{inc}}(F;\\mu,p)$ for any invertible $F$ with $J0$.\n\nNext, derive and use the correct objectivity transformation identities that must hold for any $Q \\in \\mathrm{SO}(3)$:\n- For stresses:\n$$\nP(QF) = Q\\,P(F).\n$$\n- For tangents, stated operationally using directional derivatives: letting $A(F)$ denote the fourth-order tangent and $H'$ an arbitrary perturbation, the identity to verify is\n$$\nA(QF) : H' \\;=\\; Q \\,\\big( A(F) : (Q^{\\mathsf T} H') \\big),\n$$\nwhere $X:Y = \\mathrm{d}P(F)[Y]$ denotes the action of the tangent on the perturbation. You must verify this identity numerically by computing the action $A(\\cdot):(\\cdot)$ via a centered finite-difference directional derivative of $P(\\cdot)$.\n\nYour program must:\n- Implement stress routines for both models.\n- Implement a function that, given a constitutive routine $P(\\cdot)$, a base deformation $F$, and a direction $H$, returns the tangent action $A(F):H$ using a centered finite difference with a small step size $\\varepsilon  0$.\n- Implement a rotation generator $Q(\\boldsymbol{a},\\theta)$ from a given axis $\\boldsymbol{a} \\in \\mathbb{R}^3$ and angle $\\theta$ in radians, using the standard axis–angle construction, ensuring $Q \\in \\mathrm{SO}(3)$.\n\nObjectivity tests to implement:\n- Stress objectivity: compute the relative Frobenius error\n$$\ne_{\\mathrm{stress}} = \\frac{\\lVert P(QF) - Q P(F) \\rVert_F}{1 + \\lVert P(F) \\rVert_F}.\n$$\n- Tangent objectivity: for each prescribed perturbation $H'$ in a test set, compute\n$$\n\\Delta_{\\mathrm{left}} = A(QF):H',\\quad \\Delta_{\\mathrm{right}} = Q\\,[A(F):(Q^{\\mathsf T} H')],\n$$\nand report the maximum relative Frobenius error over the test set,\n$$\ne_{\\mathrm{tangent}} = \\max_{H'} \\frac{\\lVert \\Delta_{\\mathrm{left}} - \\Delta_{\\mathrm{right}} \\rVert_F}{1 + \\lVert \\Delta_{\\mathrm{right}} \\rVert_F}.\n$$\n\nAngles must be treated in radians. All quantities are nondimensional; no physical units are required.\n\nTest suite:\nUse the following four cases that cover a general case, near-incompressible kinematics, pure rotation, and a trivial boundary case. In each case, compute and report both $e_{\\mathrm{stress}}$ and $e_{\\mathrm{tangent}}$ as floating-point numbers.\n\nCommon perturbation directions $H'_k$ to be used in every case (three matrices):\n- $H'_1 = \\begin{bmatrix} 0.3  -0.2  0.1 \\\\ 0.05  -0.1  0.0 \\\\ 0.2  0.15  -0.05 \\end{bmatrix}$,\n- $H'_2 = \\begin{bmatrix} -0.25  0.4  0.0 \\\\ 0.0  0.1  -0.3 \\\\ 0.05  -0.2  0.25 \\end{bmatrix}$,\n- $H'_3 = \\begin{bmatrix} 0.0  0.2  -0.1 \\\\ -0.15  0.0  0.35 \\\\ 0.2  -0.05  0.0 \\end{bmatrix}$.\n\nCase $1$ (compressible, general deformation):\n- $\\mu = 2.3$, $\\kappa = 120.7$,\n- $F = \\begin{bmatrix} 1.2  0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{bmatrix}$,\n- Rotation axis $\\boldsymbol{a} = (0.3,\\,0.7,\\,0.2)$, angle $\\theta = 0.65$.\n\nCase $2$ (incompressible, $J$ near $1$):\n- $\\mu = 1.9$, $p = 1.7$,\n- $F = \\begin{bmatrix} 1.05  0.02  0.0 \\\\ 0.01  0.98  0.03 \\\\ 0.0  0.02  0.97 \\end{bmatrix}$,\n- Rotation axis $\\boldsymbol{a} = (-0.2,\\,0.4,\\,0.5)$, angle $\\theta = 1.1$.\n\nCase $3$ (compressible, pure rotation as deformation gradient):\n- $\\mu = 5.0$, $\\kappa = 200.0$,\n- $F$ is the rotation matrix generated by axis $\\boldsymbol{a} = (0.2,\\,-0.1,\\,0.3)$ and angle $\\theta = 0.5$,\n- Superposed rotation axis $\\boldsymbol{a} = (0.5,\\,0.2,\\,-0.4)$, angle $\\theta = 0.8$.\n\nCase $4$ (incompressible, identity deformation):\n- $\\mu = 3.0$, $p = -0.8$,\n- $F = I$,\n- Rotation axis $\\boldsymbol{a} = (0.1,\\,0.3,\\,0.2)$, angle $\\theta = 1.3$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of $8$ floating-point numbers enclosed in square brackets, ordered as\n$[e_{\\mathrm{stress}}^{(1)}, e_{\\mathrm{tangent}}^{(1)}, e_{\\mathrm{stress}}^{(2)}, e_{\\mathrm{tangent}}^{(2)}, e_{\\mathrm{stress}}^{(3)}, e_{\\mathrm{tangent}}^{(3)}, e_{\\mathrm{stress}}^{(4)}, e_{\\mathrm{tangent}}^{(4)}]$,\nwhere the superscript $(k)$ denotes Case $k$.", "solution": "The problem statement is parsed and validated. It is found to be scientifically grounded, well-posed, objective, and complete. It represents a standard verification procedure in computational continuum mechanics. There are no flaws; therefore, a solution is provided.\n\nThe task is to verify the material frame indifference (objectivity) of two hyperelastic constitutive models, one compressible and one incompressible. This is achieved by testing the transformation properties of the First Piola-Kirchhoff stress tensor, $P$, and its corresponding tangent modulus. The foundation of this principle is that the stored energy function, $W$, must be invariant under superposed rigid-body rotations. For an isotropic material, this implies that $W$ can be expressed as a function of the invariants of a strain tensor, such as the right Cauchy-Green tensor $C = F^{\\mathsf T} F$. The problem provides $W(F) = \\widehat{W}(C)$. The First Piola-Kirchhoff stress tensor $P$ is the derivative of the stored energy density $W$ with respect to the deformation gradient $F$, i.e., $P = \\dfrac{\\partial W}{\\partial F}$.\n\nTo derive the expressions for $P$ for the given models, we use the chain rule. The variation of $W$ is given by $\\delta W = \\dfrac{\\partial \\widehat{W}}{\\partial I_1} \\delta I_1 + \\dfrac{\\partial \\widehat{W}}{\\partial J} \\delta J$, where $I_1 = \\mathrm{tr}(C)$ and $J = \\det F$. The variations of $I_1$ and $J$ with respect to $F$ are $\\delta I_1 = 2F : \\delta F$ and $\\delta J = J F^{-\\mathsf{T}} : \\delta F$. Since $\\delta W = P : \\delta F$, we can identify the general expression for the PK1 stress as:\n$$\nP = 2 \\frac{\\partial \\widehat{W}}{\\partial I_1} F + \\frac{\\partial \\widehat{W}}{\\partial J} J F^{-\\mathsf{T}}\n$$\n\nFirst, for the compressible Neo-Hookean model, the stored energy density is\n$$\nW_{\\mathrm{c}}(F) = \\frac{\\mu}{2}\\,(I_1 - 3) - \\mu \\ln J + \\frac{\\kappa}{2}\\,(\\ln J)^2\n$$\nThe partial derivatives with respect to the invariants $I_1$ and $J$ are:\n$$\n\\frac{\\partial W_{\\mathrm{c}}}{\\partial I_1} = \\frac{\\mu}{2} \\quad \\text{and} \\quad \\frac{\\partial W_{\\mathrm{c}}}{\\partial J} = -\\frac{\\mu}{J} + \\frac{\\kappa \\ln J}{J}\n$$\nSubstituting these into the general expression for $P$ yields the PK1 stress for the compressible model:\n$$\nP_{\\mathrm{c}}(F) = 2 \\left(\\frac{\\mu}{2}\\right) F + \\left(-\\frac{\\mu}{J} + \\frac{\\kappa \\ln J}{J}\\right) J F^{-\\mathsf{T}} = \\mu F + (\\kappa \\ln J - \\mu) F^{-\\mathsf{T}}\n$$\n\nSecond, for the incompressible Neo-Hookean model, the behavior is described by an augmented energy functional incorporating the incompressibility constraint $J=1$ via a Lagrange multiplier $p$:\n$$\n\\Pi(F,p) = \\frac{\\mu}{2}\\,(I_1 - 3) - p\\,(J-1)\n$$\nThe PK1 stress is the derivative of this functional with respect to $F$. Treating $\\Pi$ as our effective energy function, the partial derivatives are:\n$$\n\\frac{\\partial \\Pi}{\\partial I_1} = \\frac{\\mu}{2} \\quad \\text{and} \\quad \\frac{\\partial \\Pi}{\\partial J} = -p\n$$\nSubstituting these into the general form for $P$ gives the PK1 stress for the incompressible model, evaluated for a given pressure $p$:\n$$\nP_{\\mathrm{inc}}(F,p) = 2 \\left(\\frac{\\mu}{2}\\right) F + (-p) J F^{-\\mathsf{T}} = \\mu F - p J F^{-\\mathsf{T}}\n$$\nThis form is standard for mixed finite element formulations where the deformation might momentarily result in $J \\neq 1$ during the iterative solution process.\n\nThe verification program implements these derived stress routines. It also implements the required numerical tools. A rotation matrix $Q \\in \\mathrm{SO}(3)$ is generated from an axis $\\boldsymbol{a}$ and angle $\\theta$ using Rodrigues' rotation formula. The axis is first normalized to $\\boldsymbol{n} = \\boldsymbol{a} / \\lVert \\boldsymbol{a} \\rVert$. The rotation matrix is then $Q = I + (\\sin\\theta)[\\boldsymbol{n}]_\\times + (1-\\cos\\theta)[\\boldsymbol{n}]_\\times^2$, where $[\\boldsymbol{n}]_\\times$ is the skew-symmetric matrix associated with the cross-product operator for $\\boldsymbol{n}$.\n\nThe action of the tangent modulus, $A(F):H = \\mathrm{d}P(F)[H]$, is approximated using a second-order accurate centered finite difference scheme with a small step size $\\varepsilon  0$:\n$$\nA(F):H \\approx \\frac{P(F + \\varepsilon H) - P(F - \\varepsilon H)}{2\\varepsilon}\n$$\nThe value $\\varepsilon = 10^{-7}$ is chosen to balance truncation error and floating-point round-off error.\n\nWith these components, the objectivity tests are performed.\nFor stress objectivity, the relative Frobenius error $e_{\\mathrm{stress}}$ is computed to verify that $P(QF) = Q P(F)$:\n$$\ne_{\\mathrm{stress}} = \\frac{\\lVert P(QF) - Q P(F) \\rVert_F}{1 + \\lVert P(F) \\rVert_F}\n$$\nFor tangent objectivity, the program verifies the identity $A(QF) : H' = Q ( A(F) : (Q^{\\mathsf T} H') )$ for a set of perturbation matrices $\\{H'\\}$. The maximum relative Frobenius error over this set is computed:\n$$\ne_{\\mathrm{tangent}} = \\max_{H'} \\frac{\\lVert \\Delta_{\\mathrm{left}} - \\Delta_{\\mathrm{right}} \\rVert_F}{1 + \\lVert \\Delta_{\\mathrm{right}} \\rVert_F}\n$$\nwhere $\\Delta_{\\mathrm{left}}$ and $\\Delta_{\\mathrm{right}}$ are the left and right hand sides of the identity, respectively, computed using the finite difference scheme. The denominator term $1 + \\lVert \\cdot \\rVert_F$ ensures numerical stability in cases where the reference stress or tangent action is zero. The program systematically applies these tests to the four specified cases, and the resulting eight error values are reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix(axis, angle):\n    \"\"\"\n    Generates a rotation matrix Q in SO(3) from an axis and angle\n    using Rodrigues' rotation formula.\n    \"\"\"\n    a = np.asarray(axis)\n    norm_a = np.linalg.norm(a)\n    if norm_a == 0:\n        return np.eye(3)\n    n = a / norm_a\n    \n    K = np.array([\n        [0, -n[2], n[1]],\n        [n[2], 0, -n[0]],\n        [-n[1], n[0], 0]\n    ])\n    \n    Q = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    return Q\n\ndef P_compressible(F, mu, kappa):\n    \"\"\"\n    Computes the First Piola-Kirchhoff stress for a compressible Neo-Hookean model.\n    P_c(F) = mu*F + (kappa*ln(J) - mu)*F^{-T}\n    \"\"\"\n    J = np.linalg.det(F)\n    if J = 0:\n        raise ValueError(\"Deformation gradient must have a positive determinant.\")\n    F_inv_T = np.linalg.inv(F).T\n    P = mu * F + (kappa * np.log(J) - mu) * F_inv_T\n    return P\n\ndef P_incompressible(F, mu, p):\n    \"\"\"\n    Computes the First Piola-Kirchhoff stress for an incompressible Neo-Hookean model.\n    P_inc(F, p) = mu*F - p*J*F^{-T}\n    \"\"\"\n    J = np.linalg.det(F)\n    if J = 0:\n        raise ValueError(\"Deformation gradient must have a positive determinant.\")\n    F_inv_T = np.linalg.inv(F).T\n    P = mu * F - p * J * F_inv_T\n    return P\n\ndef tangent_action(P_func, F, H, eps):\n    \"\"\"\n    Computes the action of the tangent modulus A(F):H using a centered finite difference.\n    A(F):H approx (P(F + eps*H) - P(F - eps*H)) / (2*eps)\n    \"\"\"\n    P_plus = P_func(F + eps * H)\n    P_minus = P_func(F - eps * H)\n    return (P_plus - P_minus) / (2 * eps)\n\ndef run_verification_test(model_type, params, F_base, Q_params, H_primes, eps):\n    \"\"\"\n    Runs objectivity tests for stress and tangent for a single case.\n    \"\"\"\n    # Unpack parameters\n    if model_type == 'compressible':\n        mu, kappa = params\n        P_func = lambda F_arg: P_compressible(F_arg, mu, kappa)\n    elif model_type == 'incompressible':\n        mu, p = params\n        P_func = lambda F_arg: P_incompressible(F_arg, mu, p)\n    else:\n        raise ValueError(\"Unknown model type.\")\n\n    Q_axis, Q_angle = Q_params\n    Q = get_rotation_matrix(Q_axis, Q_angle)\n\n    # Stress objectivity test\n    P_F = P_func(F_base)\n    F_rot = Q @ F_base\n    P_QF = P_func(F_rot)\n    Q_P_F = Q @ P_F\n    \n    e_stress = np.linalg.norm(P_QF - Q_P_F, 'fro') / (1.0 + np.linalg.norm(P_F, 'fro'))\n\n    # Tangent objectivity test\n    tangent_errors_for_case = []\n    for H_prime in H_primes:\n        # Left side: A(QF):H'\n        delta_left = tangent_action(P_func, F_rot, H_prime, eps)\n        \n        # Right side: Q * [A(F) : (Q^T * H')]\n        H = Q.T @ H_prime\n        delta_base = tangent_action(P_func, F_base, H, eps)\n        delta_right = Q @ delta_base\n        \n        err_h = np.linalg.norm(delta_left - delta_right, 'fro') / (1.0 + np.linalg.norm(delta_right, 'fro'))\n        tangent_errors_for_case.append(err_h)\n        \n    e_tangent = max(tangent_errors_for_case)\n    \n    return e_stress, e_tangent\n\ndef solve():\n    \"\"\"\n    Main solver function that defines and runs all test cases.\n    \"\"\"\n    # Common parameters for all tests\n    eps = 1e-7\n    H_primes = [\n        np.array([[0.3, -0.2, 0.1], [0.05, -0.1, 0.0], [0.2, 0.15, -0.05]]),\n        np.array([[-0.25, 0.4, 0.0], [0.0, 0.1, -0.3], [0.05, -0.2, 0.25]]),\n        np.array([[0.0, 0.2, -0.1], [-0.15, 0.0, 0.35], [0.2, -0.05, 0.0]])\n    ]\n\n    # Define test cases\n    F_case3 = get_rotation_matrix(axis=(0.2, -0.1, 0.3), angle=0.5)\n    \n    test_cases = [\n        # Case 1 (compressible, general deformation)\n        {'model_type': 'compressible', 'params': (2.3, 120.7), \n         'F_base': np.array([[1.2, 0.1, 0.0], [0.0, 0.9, 0.2], [0.0, 0.0, 1.1]]), \n         'Q_params': ((0.3, 0.7, 0.2), 0.65)},\n        # Case 2 (incompressible, J near 1)\n        {'model_type': 'incompressible', 'params': (1.9, 1.7), \n         'F_base': np.array([[1.05, 0.02, 0.0], [0.01, 0.98, 0.03], [0.0, 0.02, 0.97]]), \n         'Q_params': ((-0.2, 0.4, 0.5), 1.1)},\n        # Case 3 (compressible, pure rotation F)\n        {'model_type': 'compressible', 'params': (5.0, 200.0), \n         'F_base': F_case3, \n         'Q_params': ((0.5, 0.2, -0.4), 0.8)},\n        # Case 4 (incompressible, identity deformation)\n        {'model_type': 'incompressible', 'params': (3.0, -0.8), \n         'F_base': np.eye(3), \n         'Q_params': ((0.1, 0.3, 0.2), 1.3)}\n    ]\n\n    results = []\n    for case in test_cases:\n        e_stress, e_tangent = run_verification_test(\n            case['model_type'],\n            case['params'],\n            case['F_base'],\n            case['Q_params'],\n            H_primes,\n            eps\n        )\n        results.append(e_stress)\n        results.append(e_tangent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2545696"}]}