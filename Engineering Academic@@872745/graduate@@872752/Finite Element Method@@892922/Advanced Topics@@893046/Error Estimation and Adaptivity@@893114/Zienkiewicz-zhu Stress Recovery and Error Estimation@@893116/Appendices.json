{"hands_on_practices": [{"introduction": "The raw stresses computed from a finite element solution are often discontinuous and less accurate than the displacements, especially at element nodes. The Zienkiewicz-Zhu (ZZ) method addresses this by creating a continuous, more accurate stress field through local polynomial fitting. This first exercise breaks down the core mechanism of the ZZ method: the least-squares fit on a patch of elements surrounding a node [@problem_id:2612978]. By explicitly constructing and solving the system for a given set of stress samples, you will gain a concrete understanding of how a more accurate nodal stress value is \"recovered\" from the raw, element-based data.", "problem": "Consider planar linear elasticity and the Zienkiewicz–Zhu stress recovery procedure on a patch of elements surrounding an interior node at spatial position $\\mathbf{x}_{0} = (0,\\,0)$. You are given elementwise constant approximations of the normal stress component $\\sigma_{xx}$ evaluated at four sampling points in the patch:\n$\\mathbf{x}_{1} = (-1,\\,0)$ with $\\sigma_{xx}^{(1)} = -0.9$ (MPa),\n$\\mathbf{x}_{2} = (1,\\,0)$ with $\\sigma_{xx}^{(2)} = 5.2$ (MPa),\n$\\mathbf{x}_{3} = (0,\\,1)$ with $\\sigma_{xx}^{(3)} = 0.8$ (MPa),\n$\\mathbf{x}_{4} = (0,\\,-1)$ with $\\sigma_{xx}^{(4)} = 3.1$ (MPa).\nAssume a linear polynomial ansatz for the recovered stress component on the patch,\n$p(x,y) = a_{0} + a_{1}\\,x + a_{2}\\,y$,\nand use an unweighted least-squares fit over the given sampling points.\n\nTasks:\n(a) Explicitly construct the Vandermonde-like design matrix $A \\in \\mathbb{R}^{4 \\times 3}$ and the data vector $\\mathbf{s} \\in \\mathbb{R}^{4}$ for this patch and basis.\n(b) Starting from the least-squares principle, write the normal equations and solve for the coefficient vector $\\mathbf{a} = (a_{0},\\,a_{1},\\,a_{2})^{\\mathsf{T}}$.\n(c) Evaluate the recovered stress at the interior node, $p(0,0)$, and express your final numerical answer in MPa. Round your final answer to $4$ significant figures.\n(d) Now consider a boundary node patch on a straight boundary segment with known outward unit normal $\\mathbf{n} = (0,\\,1)$ and available boundary traction measurements $\\bar{\\mathbf{t}}(\\mathbf{x}) = (\\bar{t}_{x}(\\mathbf{x}),\\,\\bar{t}_{y}(\\mathbf{x}))$ at a finite set of boundary collocation points $\\{\\mathbf{x}_{b}^{(k)}\\}_{k=1}^{m_{b}}$. Suppose each independent stress component is approximated on the patch by a linear polynomial of the same form as $p$, namely\n$\\sigma_{xx}(x,y) = a_{xx,0} + a_{xx,1}\\,x + a_{xx,2}\\,y$, \n$\\sigma_{yy}(x,y) = a_{yy,0} + a_{yy,1}\\,x + a_{yy,2}\\,y$, \n$\\sigma_{xy}(x,y) = a_{xy,0} + a_{xy,1}\\,x + a_{xy,2}\\,y$.\nExplain, by constructing the constraint matrix explicitly, how to impose the traction conditions $\\sigma(\\mathbf{x})\\,\\mathbf{n} = \\bar{\\mathbf{t}}(\\mathbf{x})$ at the boundary collocation points via Lagrange multipliers, and write down the corresponding augmented Karush–Kuhn–Tucker linear system without solving it.\n\nYour final answer must be the single real value of $p(0,0)$ in MPa, rounded to $4$ significant figures as instructed.", "solution": "The problem presents a standard application of the Zienkiewicz-Zhu stress recovery technique within the framework of the finite element method. The problem is validated to be scientifically grounded, well-posed, and contains all necessary data for its resolution. We will proceed by addressing each task sequentially.\n\n(a) Explicitly construct the Vandermonde-like design matrix $A \\in \\mathbb{R}^{4 \\times 3}$ and the data vector $\\mathbf{s} \\in \\mathbb{R}^{4}$.\n\nThe recovered stress field is a linear polynomial of the form $p(x,y) = a_{0} + a_{1}x + a_{2}y$. This can be written as a product of a row vector of basis functions and a column vector of coefficients: $p(x,y) = \\begin{pmatrix} 1  x  y \\end{pmatrix} \\begin{pmatrix} a_{0} \\\\ a_{1} \\\\ a_{2} \\end{pmatrix}$.\nThe least-squares problem seeks to find the coefficient vector $\\mathbf{a} = (a_{0}, a_{1}, a_{2})^{\\mathsf{T}}$ that minimizes the squared error between the polynomial evaluated at the sampling points and the given stress data. The system of equations for the four sampling points is $A\\mathbf{a} \\approx \\mathbf{s}$.\n\nThe design matrix $A$ is constructed by evaluating the basis functions at each of the four sampling points $\\mathbf{x}_{i} = (x_{i}, y_{i})$. The $i$-th row of $A$ is given by $(1, x_{i}, y_{i})$.\nThe given points are $\\mathbf{x}_{1} = (-1,0)$, $\\mathbf{x}_{2} = (1,0)$, $\\mathbf{x}_{3} = (0,1)$, and $\\mathbf{x}_{4} = (0,-1)$.\nThe resulting design matrix $A$ is:\n$$A = \\begin{pmatrix} 1  -1  0 \\\\ 1  1  0 \\\\ 1  0  1 \\\\ 1  0  -1 \\end{pmatrix}$$\nThe data vector $\\mathbf{s}$ consists of the given stress values $\\sigma_{xx}^{(i)}$ corresponding to each sampling point: $\\sigma_{xx}^{(1)} = -0.9$, $\\sigma_{xx}^{(2)} = 5.2$, $\\sigma_{xx}^{(3)} = 0.8$, and $\\sigma_{xx}^{(4)} = 3.1$.\nThe data vector $\\mathbf{s}$ is:\n$$\\mathbf{s} = \\begin{pmatrix} -0.9 \\\\ 5.2 \\\\ 0.8 \\\\ 3.1 \\end{pmatrix}$$\n\n(b) Starting from the least-squares principle, write the normal equations and solve for the coefficient vector $\\mathbf{a}$.\n\nThe unweighted least-squares principle seeks to minimize the squared Euclidean norm of the residual vector, $J(\\mathbf{a}) = \\|\\mathbf{r}\\|_{2}^{2} = \\|\\mathbf{s} - A\\mathbf{a}\\|_{2}^{2}$. The minimum is found where the gradient of $J$ with respect to $\\mathbf{a}$ is zero: $\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\mathbf{0}$.\nCalculating the gradient:\n$\\nabla_{\\mathbf{a}} \\left( (\\mathbf{s} - A\\mathbf{a})^{\\mathsf{T}} (\\mathbf{s} - A\\mathbf{a}) \\right) = \\nabla_{\\mathbf{a}} \\left( \\mathbf{s}^{\\mathsf{T}}\\mathbf{s} - 2\\mathbf{s}^{\\mathsf{T}}A\\mathbf{a} + \\mathbf{a}^{\\mathsf{T}}A^{\\mathsf{T}}A\\mathbf{a} \\right) = -2A^{\\mathsf{T}}\\mathbf{s} + 2A^{\\mathsf{T}}A\\mathbf{a}$.\nSetting the gradient to zero yields the normal equations:\n$$A^{\\mathsf{T}}A\\mathbf{a} = A^{\\mathsf{T}}\\mathbf{s}$$\nWe compute the matrix $A^{\\mathsf{T}}A$ and the vector $A^{\\mathsf{T}}\\mathbf{s}$.\n$$A^{\\mathsf{T}} = \\begin{pmatrix} 1  1  1  1 \\\\ -1  1  0  0 \\\\ 0  0  1  -1 \\end{pmatrix}$$\n$$A^{\\mathsf{T}}A = \\begin{pmatrix} 1  1  1  1 \\\\ -1  1  0  0 \\\\ 0  0  1  -1 \\end{pmatrix} \\begin{pmatrix} 1  -1  0 \\\\ 1  1  0 \\\\ 1  0  1 \\\\ 1  0  -1 \\end{pmatrix} = \\begin{pmatrix} 1+1+1+1  -1+1+0+0  0+0+1-1 \\\\ -1+1+0+0  1+1+0+0  0+0+0+0 \\\\ 0+0+1-1  0+0+0+0  0+0+1+1 \\end{pmatrix} = \\begin{pmatrix} 4  0  0 \\\\ 0  2  0 \\\\ 0  0  2 \\end{pmatrix}$$\nThe orthogonality of the columns in a sense of dot product weighted by the sampling points leads to a diagonal matrix, which simplifies the solution.\n$$A^{\\mathsf{T}}\\mathbf{s} = \\begin{pmatrix} 1  1  1  1 \\\\ -1  1  0  0 \\\\ 0  0  1  -1 \\end{pmatrix} \\begin{pmatrix} -0.9 \\\\ 5.2 \\\\ 0.8 \\\\ 3.1 \\end{pmatrix} = \\begin{pmatrix} (-0.9) + 5.2 + 0.8 + 3.1 \\\\ -(-0.9) + 5.2 \\\\ 0.8 - 3.1 \\end{pmatrix} = \\begin{pmatrix} 8.2 \\\\ 6.1 \\\\ -2.3 \\end{pmatrix}$$\nThe normal equations are thus:\n$$\\begin{pmatrix} 4  0  0 \\\\ 0  2  0 \\\\ 0  0  2 \\end{pmatrix} \\begin{pmatrix} a_{0} \\\\ a_{1} \\\\ a_{2} \\end{pmatrix} = \\begin{pmatrix} 8.2 \\\\ 6.1 \\\\ -2.3 \\end{pmatrix}$$\nSolving this diagonal system gives the coefficients:\n$4a_{0} = 8.2 \\implies a_{0} = \\frac{8.2}{4} = 2.05$\n$2a_{1} = 6.1 \\implies a_{1} = \\frac{6.1}{2} = 3.05$\n$2a_{2} = -2.3 \\implies a_{2} = \\frac{-2.3}{2} = -1.15$\nThe coefficient vector is $\\mathbf{a} = (2.05, 3.05, -1.15)^{\\mathsf{T}}$.\n\n(c) Evaluate the recovered stress at the interior node, $p(0,0)$.\n\nThe recovered stress at the node position $\\mathbf{x}_{0} = (0,0)$ is found by evaluating the polynomial $p(x,y)$ at these coordinates.\n$$p(0,0) = a_{0} + a_{1}(0) + a_{2}(0) = a_{0}$$\nFrom the previous step, $a_{0} = 2.05$. The units are Megapascals (MPa). Rounding to $4$ significant figures, the result is $2.050$ MPa.\n\n(d) Explain how to impose traction conditions via Lagrange multipliers.\n\nIn this scenario, we perform a least-squares fit for all three independent stress components ($\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}$) subject to linear constraints imposed by known boundary tractions. Let the complete set of unknown coefficients be $\\mathbf{\\alpha} \\in \\mathbb{R}^{9}$:\n$$\\mathbf{\\alpha} = (a_{xx,0}, a_{xx,1}, a_{xx,2}, \\,\\,\\, a_{yy,0}, a_{yy,1}, a_{yy,2}, \\,\\,\\, a_{xy,0}, a_{xy,1}, a_{xy,2})^{\\mathsf{T}}$$\nThe traction vector $\\mathbf{t}$ on a surface with outward unit normal $\\mathbf{n}$ is given by $\\mathbf{t} = \\sigma \\mathbf{n}$. For $\\mathbf{n} = (0, 1)^{\\mathsf{T}}$, this becomes:\n$$\\mathbf{t} = \\begin{pmatrix} t_{x} \\\\ t_{y} \\end{pmatrix} = \\begin{pmatrix} \\sigma_{xx}  \\sigma_{xy} \\\\ \\sigma_{xy}  \\sigma_{yy} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\sigma_{xy} \\\\ \\sigma_{yy} \\end{pmatrix}$$\nThese tractions must equal the measured tractions $\\bar{\\mathbf{t}}(\\mathbf{x}) = (\\bar{t}_{x}(\\mathbf{x}), \\bar{t}_{y}(\\mathbf{x}))^{\\mathsf{T}}$ at a set of $m_{b}$ boundary collocation points $\\{\\mathbf{x}_{b}^{(k)}\\}_{k=1}^{m_{b}}$. For each point $\\mathbf{x}_{b}^{(k)} = (x_{b}^{(k)}, y_{b}^{(k)})$, we have two linear constraints on $\\mathbf{\\alpha}$:\n$$ \\sigma_{xy}(x_{b}^{(k)}, y_{b}^{(k)}) = a_{xy,0} + a_{xy,1}x_{b}^{(k)} + a_{xy,2}y_{b}^{(k)} = \\bar{t}_{x}(\\mathbf{x}_{b}^{(k)}) $$\n$$ \\sigma_{yy}(x_{b}^{(k)}, y_{b}^{(k)}) = a_{yy,0} + a_{yy,1}x_{b}^{(k)} + a_{yy,2}y_{b}^{(k)} = \\bar{t}_{y}(\\mathbf{x}_{b}^{(k)}) $$\nThese $2m_{b}$ constraints can be written in matrix form $C\\mathbf{\\alpha} = \\mathbf{d}$, where $C$ is a $(2m_{b}) \\times 9$ matrix and $\\mathbf{d}$ is a $(2m_{b}) \\times 1$ vector.\nLet $\\mathbf{p}_{k} = (1, x_{b}^{(k)}, y_{b}^{(k)})$. The pair of rows in $C$ corresponding to point $\\mathbf{x}_{b}^{(k)}$ is:\n$$ C_{(2k-1, \\cdot)} = \\begin{pmatrix} 0  0  0  0  0  0  1  x_{b}^{(k)}  y_{b}^{(k)} \\end{pmatrix} $$\n$$ C_{(2k, \\cdot)} = \\begin{pmatrix} 0  0  0  1  x_{b}^{(k)}  y_{b}^{(k)}  0  0  0 \\end{pmatrix} $$\nThe right-hand side vector is $\\mathbf{d} = (\\bar{t}_{x}(\\mathbf{x}_{b}^{(1)}), \\bar{t}_{y}(\\mathbf{x}_{b}^{(1)}), \\dots, \\bar{t}_{x}(\\mathbf{x}_{b}^{(m_{b})}), \\bar{t}_{y}(\\mathbf{x}_{b}^{(m_{b})}))^{\\mathsf{T}}$.\nThe optimization problem is to minimize the least-squares functional for the interior sampling points, $\\frac{1}{2}\\|A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full}\\|^{2}$, subject to $C\\mathbf{\\alpha}=\\mathbf{d}$. Using the method of Lagrange multipliers, we introduce a vector of multipliers $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2m_{b}}$ and form the Lagrangian:\n$$ \\mathcal{L}(\\mathbf{\\alpha}, \\boldsymbol{\\lambda}) = \\frac{1}{2}(A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full})^{\\mathsf{T}}(A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full}) + \\boldsymbol{\\lambda}^{\\mathsf{T}}(C\\mathbf{\\alpha} - \\mathbf{d}) $$\nThe Karush-Kuhn-Tucker (KKT) conditions for an optimum are $\\nabla_{\\mathbf{\\alpha}}\\mathcal{L} = \\mathbf{0}$ and $\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L} = \\mathbf{0}$, which yield:\n$$ (A_{full}^{\\mathsf{T}}A_{full})\\mathbf{\\alpha} + C^{\\mathsf{T}}\\boldsymbol{\\lambda} = A_{full}^{\\mathsf{T}}\\mathbf{s}_{full} $$\n$$ C\\mathbf{\\alpha} = \\mathbf{d} $$\nLet $K = A_{full}^{\\mathsf{T}}A_{full}$ and $\\mathbf{f} = A_{full}^{\\mathsf{T}}\\mathbf{s}_{full}$. The augmented KKT linear system is:\n$$ \\begin{pmatrix} K  C^{\\mathsf{T}} \\\\ C  \\mathbf{0} \\end{pmatrix} \\begin{pmatrix} \\mathbf{\\alpha} \\\\ \\boldsymbol{\\lambda} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f} \\\\ \\mathbf{d} \\end{pmatrix} $$\nHere, $K$ is the block-diagonal matrix arising from the unconstrained least-squares fit over the interior element sampling points, and $\\mathbf{f}$ is the corresponding right-hand side vector. This symmetric but indefinite system can be solved for the coefficients $\\mathbf{\\alpha}$ and the multipliers $\\boldsymbol{\\lambda}$.", "answer": "$$\\boxed{2.050}$$", "id": "2612978"}, {"introduction": "A primary motivation for stress recovery is its application in *a posteriori* error estimation, which is crucial for adaptive mesh refinement. The difference between the recovered stress field, $\\boldsymbol{\\sigma}^*$, and the raw finite element stress, $\\boldsymbol{\\sigma}_h$, provides a powerful and computationally inexpensive estimate of the true error in the energy norm. In this computational exercise, you will implement the full ZZ recovery process for a problem with a known analytical solution [@problem_id:2613010]. By computing the effectivity index—the ratio of the estimated error to the true error—you will numerically verify the asymptotic exactness of the estimator, a key property that validates its use in practical engineering analysis.", "problem": "Consider small-strain, linear, isotropic elasticity in plane strain on the square domain $\\Omega = [0,1] \\times [0,1]$. Let the exact displacement field be prescribed by the manufactured solution\n$$\n\\mathbf{u}^{\\mathrm{ex}}(x,y) = \\begin{bmatrix} \\sin(\\pi x)\\sin(\\pi y) \\\\ \\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nAssume the Lamé parameters $\\lambda$ and $\\mu$ derived from Young’s modulus $E$ and Poisson’s ratio $\\nu$ via\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n$$\nIn plane strain, the Cauchy stress tensor $\\boldsymbol{\\sigma}$ is related to the small strain tensor $\\boldsymbol{\\varepsilon}$ by Hooke’s law\n$$\n\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I},\n$$\nwith $\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$. Let body forces be chosen to enforce equilibrium for the exact displacement, i.e.,\n$$\n\\mathbf{b}(x,y) = (\\lambda + \\mu)\\,\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) + \\mu\\,\\Delta \\mathbf{u}^{\\mathrm{ex}},\n$$\nso that the strong form $-\\nabla \\cdot \\boldsymbol{\\sigma}(\\mathbf{u}) = \\mathbf{b}$ holds exactly for $\\mathbf{u} = \\mathbf{u}^{\\mathrm{ex}}$. Impose Dirichlet boundary conditions $\\mathbf{u} = \\mathbf{u}^{\\mathrm{ex}}$ on $\\partial \\Omega$.\n\nDiscretize $\\Omega$ by a uniform mesh of bilinear quadrilateral elements ($Q_4$), with $n \\times n$ elements, $n \\in \\mathbb{N}$. Let $\\mathbf{u}_h$ denote the finite element solution obtained with $2 \\times 2$ Gauss quadrature for stiffness and load assembly. Construct the Zienkiewicz–Zhu (ZZ) recovered stress field $\\boldsymbol{\\sigma}^\\star$ as follows:\n- Compute the finite element stress $\\boldsymbol{\\sigma}_h$ at Gauss points in each element.\n- For each mesh node, form a patch consisting of all elements sharing that node. Using all Gauss-point samples $(x_k,y_k,\\boldsymbol{\\sigma}_h(x_k,y_k))$ in the patch, compute, for each stress component, a least-squares fit to a linear polynomial in the spatial coordinates, namely $s(x,y) \\approx a_0 + a_1 x + a_2 y$. Evaluate this fit at the node to obtain the recovered nodal stresses.\n- Interpolate the recovered nodal stresses within each element using the bilinear finite element shape functions to obtain $\\boldsymbol{\\sigma}^\\star$ at Gauss points.\n\nDefine the energy-norm of the error and the ZZ error estimator by\n$$\n\\| e_h \\|_E^2 = \\int_{\\Omega} \\left( \\boldsymbol{\\sigma}(\\mathbf{u}^{\\mathrm{ex}}) - \\boldsymbol{\\sigma}_h \\right)^{\\top} \\mathbf{D}^{-1} \\left( \\boldsymbol{\\sigma}(\\mathbf{u}^{\\mathrm{ex}}) - \\boldsymbol{\\sigma}_h \\right)\\, \\mathrm{d}\\Omega,\n$$\n$$\n\\eta_h^2 = \\int_{\\Omega} \\left( \\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h \\right)^{\\top} \\mathbf{D}^{-1} \\left( \\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h \\right)\\, \\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{D}$ is the plane-strain constitutive matrix in Voigt notation acting on the vector $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^{\\top}$ with $\\gamma_{xy} = 2 \\varepsilon_{xy}$. The effectivity index is\n$$\n\\theta_h = \\frac{\\eta_h}{\\| e_h \\|_E}.\n$$\nYour task is to:\n1. Implement the described finite element method (FEM) and Zienkiewicz–Zhu (ZZ) stress recovery to compute $\\theta_h$ for successive uniform refinements.\n2. Use $E = 1$ and the following test suite of Poisson ratios and mesh resolutions:\n   - Case A (typical compressible): $\\nu = 0.30$, $n \\in \\{2, 4, 8, 16\\}$,\n   - Case B (nearly incompressible): $\\nu = 0.49$, $n \\in \\{4, 8\\}$,\n   - Case C (low Poisson’s ratio): $\\nu = 0.00$, $n \\in \\{4, 8, 16\\}$.\n3. For each pair $(\\nu, n)$, compute the effectivity index $\\theta_h$ using numerical quadrature consistent with the finite element formulation.\n\nThe final program output should be a single line containing a Python-like list of all computed $\\theta_h$ values, ordered as\n$$\n[\\theta_h(\\nu{=}0.30,n{=}2), \\theta_h(\\nu{=}0.30,n{=}4), \\theta_h(\\nu{=}0.30,n{=}8), \\theta_h(\\nu{=}0.30,n{=}16), \\theta_h(\\nu{=}0.49,n{=}4), \\theta_h(\\nu{=}0.49,n{=}8), \\theta_h(\\nu{=}0.00,n{=}4), \\theta_h(\\nu{=}0.00,n{=}8), \\theta_h(\\nu{=}0.00,n{=}16)].\n$$\nAll values must be printed as floating-point numbers in a single list, with no additional text. No physical unit is required for the final output since $\\theta_h$ is dimensionless. Angles, if any, must be in radians.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r_1,r_2,\\dots,r_9]\").", "solution": "The problem statement has been validated and is deemed scientifically sound, well-posed, and complete. We proceed with a formal solution.\n\nThe problem requires the implementation of a finite element method (FEM) for $2$-dimensional, linear, isotropic elasticity under plane strain conditions. We are given a manufactured solution for the displacement field $\\mathbf{u}^{\\mathrm{ex}}$ on the unit square domain $\\Omega = [0,1] \\times [0,1]$. This exact solution is\n$$\n\\mathbf{u}^{\\mathrm{ex}}(x,y) = \\begin{bmatrix} u^{\\mathrm{ex}}(x,y) \\\\ v^{\\mathrm{ex}}(x,y) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\pi x)\\sin(\\pi y) \\\\ \\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nThe material is defined by Young's modulus $E$ and Poisson's ratio $\\nu$, from which the Lamé parameters $\\lambda$ and $\\mu$ are derived. The constitutive relation, or Hooke's Law, is given by $\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\boldsymbol{\\varepsilon}$ is the small strain tensor, $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$.\n\nIn Voigt notation, with stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$ and strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$ (where $\\gamma_{xy} = 2\\varepsilon_{xy}$), the constitutive law is $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$. The plane strain constitutive matrix $\\mathbf{D}$ is\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n    \\lambda+2\\mu  \\lambda  0 \\\\\n    \\lambda  \\lambda+2\\mu  0 \\\\\n    0  0  \\mu\n\\end{bmatrix}\n= \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n    1-\\nu  \\nu  0 \\\\\n    \\nu  1-\\nu  0 \\\\\n    0  0  (1-2\\nu)/2\n\\end{bmatrix}.\n$$\nThe governing equation is the equilibrium equation $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{b}$, where the body force $\\mathbf{b}$ is specifically chosen to be satisfied by $\\mathbf{u}^{\\mathrm{ex}}$. From the given expression $\\mathbf{b} = (\\lambda + \\mu)\\,\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) + \\mu\\,\\Delta \\mathbf{u}^{\\mathrm{ex}}$, we derive the components of the body force. The divergence of $\\mathbf{u}^{\\mathrm{ex}}$ is $\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}} = \\pi \\sin(\\pi(x+y))$. Its gradient is $\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) = [\\pi^2 \\cos(\\pi(x+y)), \\pi^2 \\cos(\\pi(x+y))]^{\\top}$. The Laplacian of each displacement component is $\\Delta u^{\\mathrm{ex}} = \\Delta v^{\\mathrm{ex}} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$. Thus, the body force vector is\n$$\n\\mathbf{b}(x,y) = \\begin{bmatrix} (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y)) - 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) \\\\ (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y)) - 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\nThe domain is discretized into a uniform $n \\times n$ mesh of bilinear quadrilateral ($Q_4$) elements. The finite element solution $\\mathbf{u}_h$ is found by solving the linear system $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$, resulting from theGalerkin weak form of the governing equations. The element stiffness matrix $\\mathbf{K}^e$ and load vector $\\mathbf{F}^e$ are computed via numerical integration using $2 \\times 2$ Gauss quadrature:\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega, \\quad \\mathbf{F}^e = \\int_{\\Omega_e} \\mathbf{N}^{\\top} \\mathbf{b} \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix and $\\mathbf{N}$ is the shape function matrix. Dirichlet boundary conditions $\\mathbf{u}_h = \\mathbf{u}^{\\mathrm{ex}}$ are strongly enforced on all boundaries $\\partial \\Omega$.\n\nAfter obtaining the nodal displacements $\\mathbf{U}$, the finite element stress tensor $\\boldsymbol{\\sigma}_h$ is computed at the Gauss points of each element. The Zienkiewicz-Zhu (ZZ) stress recovery procedure is then applied to obtain a more accurate, continuous stress field $\\boldsymbol{\\sigma}^\\star$. For each node in the mesh, a patch of elements connected to that node is formed. The stress values $\\boldsymbol{\\sigma}_h$ at all Gauss points within this patch are collected. A least-squares fit to a linear polynomial $s(x,y) = a_0 + a_1 x + a_2 y$ is performed for each stress component. The recovered stress at the node is then the value of this polynomial evaluated at the nodal coordinates. This yields a set of recovered stresses at all nodes. The field $\\boldsymbol{\\sigma}^\\star$ is then defined within each element by interpolating these recovered nodal values using the same bilinear shape functions.\n\nFinally, we compute the energy norm of the true error, $\\| e_h \\|_E$, and the ZZ error estimator, $\\eta_h$. Their squared values are given by:\n$$\n\\| e_h \\|_E^2 = \\int_{\\Omega} (\\boldsymbol{\\sigma}^{\\mathrm{ex}} - \\boldsymbol{\\sigma}_h)^{\\top} \\mathbf{D}^{-1} (\\boldsymbol{\\sigma}^{\\mathrm{ex}} - \\boldsymbol{\\sigma}_h) \\, \\mathrm{d}\\Omega,\n$$\n$$\n\\eta_h^2 = \\int_{\\Omega} (\\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h)^{\\top} \\mathbf{D}^{-1} (\\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\boldsymbol{\\sigma}^{\\mathrm{ex}}$ is the exact stress derived from $\\mathbf{u}^{\\mathrm{ex}}$, and the inverse constitutive matrix is\n$$\n\\mathbf{D}^{-1} = \\frac{1+\\nu}{E}\n\\begin{bmatrix}\n    1-\\nu  -\\nu  0 \\\\\n    -\\nu  1-\\nu  0 \\\\\n    0  0  2\n\\end{bmatrix}.\n$$\nThe integrals for the error and the estimator are computed numerically using the same $2 \\times 2$ Gauss quadrature. The quality of the estimator is assessed by the effectivity index $\\theta_h = \\eta_h / \\| e_h \\|_E$. A value of $\\theta_h$ close to $1$ indicates an effective error estimator. The following implementation carries out this entire procedure for the specified test cases.", "answer": "```python\nimport numpy as np\n\ndef compute_effectivity(n, nu):\n    \"\"\"\n    Computes the effectivity index for a given mesh resolution n and Poisson's ratio nu.\n    \"\"\"\n    E = 1.0\n    PI = np.pi\n\n    # --- 1. Material and Exact Solution Definition ---\n    if np.isclose(nu, 0.5): # Avoid singularity\n        # This case is not in the test suite but is a necessary check.\n        lam = 0.0 # Placeholder, should not be used\n    else:\n        lam = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    D = np.array([\n        [lam + 2 * mu, lam, 0],\n        [lam, lam + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    \n    D_inv = (1 + nu) / E * np.array([\n        [1 - nu, -nu, 0],\n        [-nu, 1 - nu, 0],\n        [0, 0, 2]\n    ])\n\n    def u_exact(x, y):\n        val = np.sin(PI * x) * np.sin(PI * y)\n        return np.array([val, val])\n\n    def strain_exact(x, y):\n        exx = PI * np.cos(PI * x) * np.sin(PI * y)\n        eyy = PI * np.sin(PI * x) * np.cos(PI * y)\n        gxy = PI * np.sin(PI * (x + y))\n        return np.array([exx, eyy, gxy])\n    \n    def body_force(x, y):\n        f_val = (lam + mu) * PI**2 * np.cos(PI * (x + y)) - 2 * mu * PI**2 * np.sin(PI * x) * np.sin(PI * y)\n        return np.array([f_val, f_val])\n\n    # --- 2. Mesh Generation ---\n    num_nodes = (n + 1) * (n + 1)\n    num_elems = n * n\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(n + 1):\n        for i in range(n + 1):\n            node_idx = j * (n + 1) + i\n            node_coords[node_idx] = [i / n, j / n]\n            \n    elem_nodes = np.zeros((num_elems, 4), dtype=int)\n    for j in range(n):\n        for i in range(n):\n            elem_idx = j * n + i\n            n0 = j * (n + 1) + i\n            n1 = j * (n + 1) + i + 1\n            n2 = (j + 1) * (n + 1) + i + 1\n            n3 = (j + 1) * (n + 1) + i\n            elem_nodes[elem_idx] = [n0, n1, n2, n3]\n\n    # --- 3. FEM Assembly ---\n    gp_loc = 1.0 / np.sqrt(3)\n    gauss_points = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    def shape_functions(xi, eta):\n        return 0.25 * np.array([\n            (1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)\n        ])\n\n    def shape_derivatives(xi, eta):\n        return 0.25 * np.array([\n            [-(1-eta),  (1-eta),  (1+eta), -(1+eta)],  # dN/dxi\n            [-(1-xi), -(1+xi),  (1+xi),   (1-xi)]   # dN/deta\n        ])\n\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n\n    # Store Gauss point coordinates and FE stresses for all elements\n    gauss_pt_coords = np.zeros((num_elems, 4, 2))\n    \n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        \n        Ke = np.zeros((8, 8))\n        Fe = np.zeros(8)\n        \n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[gp_idx]\n            N_vec = shape_functions(xi, eta)\n            dN_dxi_eta = shape_derivatives(xi, eta)\n            \n            J = dN_dxi_eta @ el_node_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            dN_dx_dy = invJ @ dN_dxi_eta\n            \n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2*i] = dN_dx_dy[0, i]\n                B[1, 2*i+1] = dN_dx_dy[1, i]\n                B[2, 2*i] = dN_dx_dy[1, i]\n                B[2, 2*i+1] = dN_dx_dy[0, i]\n                \n            Ke += B.T @ D @ B * detJ * w\n            \n            x_gp, y_gp = N_vec @ el_node_coords\n            gauss_pt_coords[e_idx, gp_idx, :] = [x_gp, y_gp]\n            \n            b_vec = body_force(x_gp, y_gp)\n            N_mat = np.zeros((2, 8))\n            for i in range(4):\n                N_mat[0, 2*i] = N_vec[i]\n                N_mat[1, 2*i+1] = N_vec[i]\n            \n            Fe += N_mat.T @ b_vec * detJ * w\n            \n        dof_map = np.array([[2*nid, 2*nid+1] for nid in el_node_ids]).flatten()\n        K[np.ix_(dof_map, dof_map)] += Ke\n        F[dof_map] += Fe\n    \n    # --- 4. Boundary Conditions ---\n    boundary_nodes = []\n    for i in range(n + 1):\n        boundary_nodes.extend([i, i*(n+1), i*(n+1)+n, n*(n+1)+i])\n    boundary_nodes = sorted(list(set(boundary_nodes)))\n\n    boundary_dofs = []\n    u_bc_vals = {}\n    for node_idx in boundary_nodes:\n        x, y = node_coords[node_idx]\n        u, v = u_exact(x, y)\n        dof_x, dof_y = 2 * node_idx, 2 * node_idx + 1\n        boundary_dofs.extend([dof_x, dof_y])\n        u_bc_vals[dof_x] = u\n        u_bc_vals[dof_y] = v\n    boundary_dofs = sorted(list(set(boundary_dofs)))\n\n    active_dofs = list(set(range(num_dofs)) - set(boundary_dofs))\n    \n    F_mod = F[active_dofs] - K[np.ix_(active_dofs, boundary_dofs)] @ [u_bc_vals[d] for d in boundary_dofs]\n    K_mod = K[np.ix_(active_dofs, active_dofs)]\n\n    # --- 5. Solve ---\n    U_h = np.zeros(num_dofs)\n    U_h[active_dofs] = np.linalg.solve(K_mod, F_mod)\n    for dof in boundary_dofs:\n        U_h[dof] = u_bc_vals[dof]\n\n    # --- 6. Compute FE Stresses ---\n    gauss_stresses_h = np.zeros((num_elems, 4, 3))\n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        dof_map = np.array([[2*nid, 2*nid+1] for nid in el_node_ids]).flatten()\n        U_e = U_h[dof_map]\n        \n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            dN_dxi_eta = shape_derivatives(xi, eta)\n            J = dN_dxi_eta @ el_node_coords\n            invJ = np.linalg.inv(J)\n            dN_dx_dy = invJ @ dN_dxi_eta\n            \n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2 * i] = dN_dx_dy[0, i]\n                B[1, 2 * i + 1] = dN_dx_dy[1, i]\n                B[2, 2 * i] = dN_dx_dy[1, i]\n                B[2, 2 * i + 1] = dN_dx_dy[0, i]\n\n            strain_h = B @ U_e\n            stress_h = D @ strain_h\n            gauss_stresses_h[e_idx, gp_idx, :] = stress_h\n\n    # --- 7. Zienkiewicz-Zhu Recovery ---\n    node_patches = [[] for _ in range(num_nodes)]\n    for e_idx, nodes in enumerate(elem_nodes):\n        for node_id in nodes:\n            node_patches[node_id].append(e_idx)\n\n    sigma_star_nodal = np.zeros((num_nodes, 3))\n    for node_idx in range(num_nodes):\n        patch_elems = node_patches[node_idx]\n        patch_coords = []\n        patch_stresses = []\n        for e_idx in patch_elems:\n            patch_coords.extend(gauss_pt_coords[e_idx, :, :])\n            patch_stresses.extend(gauss_stresses_h[e_idx, :, :])\n        \n        patch_coords = np.array(patch_coords)\n        patch_stresses = np.array(patch_stresses)\n        \n        A = np.c_[np.ones(patch_coords.shape[0]), patch_coords]\n        \n        for comp in range(3):\n            s = patch_stresses[:, comp]\n            coeffs = np.linalg.lstsq(A, s, rcond=None)[0]\n            xn, yn = node_coords[node_idx]\n            sigma_star_nodal[node_idx, comp] = coeffs[0] + coeffs[1] * xn + coeffs[2] * yn\n\n    # --- 8. Error and Estimator Calculation ---\n    error_sq_sum = 0.0\n    estimator_sq_sum = 0.0\n    \n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        nodal_sigma_star = sigma_star_nodal[el_node_ids]\n\n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[gp_idx]\n            N_vec = shape_functions(xi, eta)\n            \n            J = shape_derivatives(xi, eta) @ el_node_coords\n            detJ = np.linalg.det(J)\n            \n            x_gp, y_gp = gauss_pt_coords[e_idx, gp_idx]\n            \n            sigma_h = gauss_stresses_h[e_idx, gp_idx, :]\n            \n            strain_ex = strain_exact(x_gp, y_gp)\n            sigma_ex = D @ strain_ex\n            \n            sigma_star = N_vec @ nodal_sigma_star\n            \n            diff_err = sigma_ex - sigma_h\n            diff_est = sigma_star - sigma_h\n            \n            error_sq_sum += (diff_err.T @ D_inv @ diff_err) * detJ * w\n            estimator_sq_sum += (diff_est.T @ D_inv @ diff_est) * detJ * w\n\n    return np.sqrt(estimator_sq_sum) / np.sqrt(error_sq_sum)\n\n\ndef solve():\n    test_cases = [\n        (0.30, 2), (0.30, 4), (0.30, 8), (0.30, 16),\n        (0.49, 4), (0.49, 8),\n        (0.00, 4), (0.00, 8), (0.00, 16)\n    ]\n\n    results = []\n    for nu, n in test_cases:\n        theta_h = compute_effectivity(n, nu)\n        results.append(theta_h)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2613010"}, {"introduction": "Standard error estimators typically provide a single scalar value per element, guiding isotropic refinement where elements are uniformly subdivided. However, for problems with strongly directional features like boundary or internal layers, this approach is inefficient. A more intelligent strategy is anisotropic refinement, where elements are refined only in the direction of large solution gradients. This final practice demonstrates how the recovered stress tensor, $\\boldsymbol{\\sigma}^*$, can provide the necessary directional information to create such a strategy [@problem_id:2613032]. By analyzing a boundary layer problem, you will design a simple anisotropic adaptation rule and compare its efficiency against a standard isotropic approach, highlighting a key advantage of advanced error analysis.", "problem": "Consider the scalar diffusion model on the unit square domain with coordinates $(x,y) \\in [0,1] \\times [0,1]$ and an exact solution exhibiting a boundary layer near $x=1$ given by\n$$\nu(x,y;\\epsilon) = \\left(1 - e^{-\\frac{1-x}{\\epsilon}}\\right)\\,\\sin(\\pi y),\n$$\nwhere $\\epsilon \\in (0,1]$ is a fixed parameter controlling the layer thickness. Interpreting the negative gradient as the \"stress\" (flux) in this scalar setting, define\n$$\n\\sigma(x,y;\\epsilon) = -\\nabla u(x,y;\\epsilon).\n$$\nLet a mesh be the Cartesian partition of $[0,1]^2$ into $N_x \\times N_y$ rectangles, each rectangle split into two triangles by the diagonal from the lower-left to the upper-right vertex. Let $u_h$ be the nodal interpolant of $u$ using piecewise linear shape functions on the resulting triangulation. For each triangle $K$, the element stress is the constant vector\n$$\n\\sigma_h|_K = -\\nabla u_h|_K.\n$$\nThe Zienkiewicz–Zhu (ZZ) recovered stress $\\sigma^*$ is defined by nodal averaging: for each node $P$, form the area-weighted average of neighboring element stresses $\\sigma_h|_K$ over all triangles $K$ sharing $P$, and assign that average as $\\sigma^*(P)$; for a triangle $K$ with vertices $P_1,P_2,P_3$, define the elementwise recovered stress by\n$$\n\\sigma^*_K = \\frac{1}{3}\\left(\\sigma^*(P_1)+\\sigma^*(P_2)+\\sigma^*(P_3)\\right).\n$$\nUse the ZZ energy-norm indicator on triangle $K$,\n$$\n\\eta_K^2 = |K|\\,\\lVert \\sigma^*_K - \\sigma_h|_K \\rVert_2^2,\n$$\nand the global ZZ estimator\n$$\n\\eta = \\left(\\sum_{K} \\eta_K^2\\right)^{1/2}.\n$$\nAdditionally, define directional energy measures based on the recovered stress as\n$$\nS_x = \\sum_{K} |K|\\,\\left(\\sigma^*_K\\right)_x^2,\\qquad S_y = \\sum_{K} |K|\\,\\left(\\sigma^*_K\\right)_y^2,\n$$\nand the directional dominance ratio\n$$\nR = \\frac{S_x}{S_y + \\delta},\n$$\nwith a fixed tiny constant $\\delta = 10^{-30}$ to avoid division by zero.\n\nYour tasks are:\n1) Implement the above definitions and computations for any $(N_x,N_y)$ grid, including construction of the triangulation, computation of $\\sigma_h$ by elementwise gradients, and nodal recovery of $\\sigma^*$. Ensure the ZZ estimator $\\eta$ and directional measures $S_x$, $S_y$, and $R$ are computed exactly as specified.\n\n2) Using only information derived from $\\sigma^*$, demonstrate that isotropic refinement guided by the ZZ estimator can be suboptimal for boundary layers and design an anisotropic refinement strategy that uses the directional information in $\\sigma^*$ to choose a preferential refinement direction. Specifically, proceed as follows:\n- Use the base mesh $(N_x,N_y)=(8,8)$ to compute the directional dominance ratio $R$ for a given $\\epsilon$.\n- Set a threshold $\\alpha=3$. If $R \\ge \\alpha$, adopt an anisotropic refinement rule that refines only along the $x$-direction by setting $(N_x,N_y)=(B/N_y^{(0)},N_y^{(0)})$ with $N_y^{(0)}=8$ for a target cell budget $B$ (total number of rectangles), assuming $B$ is divisible by $N_y^{(0)}$. Otherwise, adopt an isotropic refinement rule with $(N_x,N_y)=(\\sqrt{B},\\sqrt{B})$.\n- For any $(N_x,N_y)$, define the global ZZ estimator $\\eta(N_x,N_y;\\epsilon)$ as above.\n\n3) For the same target cell budget $B$, define the isotropic baseline as $(N_x,N_y)=(\\sqrt{B},\\sqrt{B})$ regardless of $R$. Compare the isotropic and anisotropic strategies by the ratio\n$$\n\\rho(B;\\epsilon) = \\frac{\\eta_{\\text{iso}}(B;\\epsilon)}{\\eta_{\\text{ani}}(B;\\epsilon)},\n$$\nwhere $\\eta_{\\text{iso}}(B;\\epsilon)$ is the ZZ estimator on the isotropic grid and $\\eta_{\\text{ani}}(B;\\epsilon)$ is the ZZ estimator on the anisotropically chosen grid.\n\nImplement a program that, for each test case below, computes the three ratios $\\rho(B;\\epsilon)$ for the listed budgets $B$. The set of test cases is:\n- $\\epsilon \\in \\{0.2,\\;0.05,\\;1.0\\}$, which respectively represent a moderate boundary layer, a strong boundary layer, and a weak (nearly absent) boundary layer.\n- For each $\\epsilon$, budgets $B \\in \\{256,\\;1024,\\;4096\\}$.\n\nAll computations are nondimensional; no physical units are required. Angles are not used. Your program should produce its final output as a single line containing a Python-like nested list of results in the following order:\n- An outer list of length three, one entry per $\\epsilon$ in the order $\\epsilon=0.2$, $\\epsilon=0.05$, $\\epsilon=1.0$.\n- Each entry is an inner list of three floating-point numbers corresponding to budgets $B=256$, $B=1024$, and $B=4096$ in that order, containing the computed ratios $\\rho(B;\\epsilon)$.\n\nFor example, the output must have the exact form \"[[r11,r12,r13],[r21,r22,r23],[r31,r32,r33]]\" where each \"rij\" is a float. The program must not read any input and must not print anything else.", "solution": "The problem as stated is subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of the finite element method, specifically concerning *a posteriori* error estimation via Zienkiewicz-Zhu stress recovery. The problem is well-posed, objective, and contains all necessary information for its unique, verifiable, and non-trivial solution. There are no contradictions, ambiguities, or factual inaccuracies. We may therefore proceed with the solution.\n\nThe problem requires the implementation and comparison of isotropic versus anisotropic mesh refinement strategies, guided by directional information extracted from a recovered stress field. The core of the task is to compute the Zienkiewicz-Zhu (ZZ) error estimator $\\eta$ and a directional dominance ratio $R$ for various grid configurations.\n\nFirst, we establish the mathematical framework. The exact solution on the domain $\\Omega = [0,1] \\times [0,1]$ is given by\n$$\nu(x,y;\\epsilon) = \\left(1 - e^{-\\frac{1-x}{\\epsilon}}\\right)\\,\\sin(\\pi y)\n$$\nThe exact \"stress\" (flux) field $\\sigma$ is the negative gradient of $u$:\n$$\n\\sigma(x,y;\\epsilon) = -\\nabla u = -\\begin{pmatrix} \\partial_x u \\\\ \\partial_y u \\end{pmatrix} = -\\begin{pmatrix} \\frac{1}{\\epsilon}e^{-\\frac{1-x}{\\epsilon}}\\sin(\\pi y) \\\\ \\pi\\left(1 - e^{-\\frac{1-x}{\\epsilon}}\\right)\\cos(\\pi y) \\end{pmatrix}\n$$\nThe domain is discretized into a Cartesian grid of $N_x \\times N_y$ rectangular cells. Each cell, with lower-left corner at grid point $(i,j)$, is composed of vertices $P_{i,j}, P_{i+1,j}, P_{i,j+1}, P_{i+1,j+1}$. This cell is subdivided into two triangles by a diagonal from the lower-left vertex $P_{i,j}$ to the upper-right vertex $P_{i+1,j+1}$:\n- Triangle $K_{1,i,j}$ with vertices $(P_{i,j}, P_{i+1,j}, P_{i+1,j+1})$.\n- Triangle $K_{2,i,j}$ with vertices $(P_{i,j}, P_{i,j+1}, P_{i+1,j+1})$.\nThe area of each triangle is uniform: $|K| = \\frac{1}{2}h_x h_y$, where $h_x = 1/N_x$ and $h_y = 1/N_y$.\n\nThe approximate solution $u_h$ is the nodal interpolant of $u$ using piecewise linear basis functions. On any triangle $K$, the gradient $\\nabla u_h$ is constant. The element stress $\\sigma_h|_K = -\\nabla u_h|_K$ can be computed from the vertex values of $u_h$. For a triangle with vertices $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ and nodal values $u_1, u_2, u_3$, the gradient is\n$$\n\\nabla u_h = \\frac{1}{2|K|} \\begin{bmatrix}\nu_1(y_2 - y_3) + u_2(y_3 - y_1) + u_3(y_1 - y_2) \\\\\nu_1(x_3 - x_2) + u_2(x_1 - x_3) + u_3(x_2 - x_1)\n\\end{bmatrix}\n$$\nApplying this to our specific triangles in cell $(i,j)$:\n- For $K_{1,i,j}$: $\\nabla u_h = \\left( \\frac{u_{i+1,j} - u_{i,j}}{h_x}, \\frac{u_{i+1,j+1} - u_{i+1,j}}{h_y} \\right)$\n- For $K_{2,i,j}$: $\\nabla u_h = \\left( \\frac{u_{i+1,j+1} - u_{i,j+1}}{h_x}, \\frac{u_{i,j+1} - u_{i,j}}{h_y} \\right)$\nHere, $u_{k,l} = u(k h_x, l h_y; \\epsilon)$ are the nodal values from the exact solution.\n\nThe next step is the Zienkiewicz-Zhu stress recovery. The recovered stress at a node $P$, denoted $\\sigma^*(P)$, is the area-weighted average of the element stresses $\\sigma_h|_K$ over all triangles $K$ sharing the node $P$. As all triangles have equal area, this simplifies to the arithmetic mean:\n$$\n\\sigma^*(P) = \\frac{1}{M_P} \\sum_{K \\ni P} \\sigma_h|_K\n$$\nwhere $M_P$ is the number of triangles adjacent to node $P$. $M_P$ varies from $1$ to $6$ depending on the node's location (corner, edge, or interior). The calculation requires careful book-keeping of triangle connectivity for each node on the grid.\n\nOnce nodal recovered stresses are known, the element-wise recovered stress for a triangle $K$ with vertices $P_1, P_2, P_3$ is the average of the nodal values:\n$$\n\\sigma^*_K = \\frac{1}{3} \\left( \\sigma^*(P_1) + \\sigma^*(P_2) + \\sigma^*(P_3) \\right)\n$$\nThe local error indicator for triangle $K$ is then\n$$\n\\eta_K^2 = |K| \\lVert \\sigma^*_K - \\sigma_h|_K \\rVert_2^2\n$$\nand the global error estimator is the sum over all $N_T = 2 N_x N_y$ triangles:\n$$\n\\eta = \\sqrt{\\sum_{K} \\eta_K^2}\n$$\n\nTo guide anisotropic refinement, we compute directional energy measures from the recovered stress field:\n$$\nS_x = \\sum_{K} |K|\\,(\\sigma^*_{K,x})^2, \\quad S_y = \\sum_{K} |K|\\,(\\sigma^*_{K,y})^2\n$$\nThe directional dominance ratio is $R = \\frac{S_x}{S_y + \\delta}$, with $\\delta = 10^{-30}$. A large value of $R$ indicates that the error is dominated by gradients in the $x$-direction, suggesting that refinement in $x$ is more efficient.\n\nThe overall algorithm proceeds as follows for each test case $(\\epsilon, B)$:\n1.  Compute the dominance ratio $R$ on a base mesh $(N_x^{(0)}, N_y^{(0)}) = (8,8)$.\n2.  If $R \\geq \\alpha = 3$, the anisotropic strategy dictates a mesh $(N_x, N_y) = (B/8, 8)$. Otherwise, an isotropic mesh $(N_x, N_y) = (\\sqrt{B}, \\sqrt{B})$ is chosen. This defines the grid for $\\eta_{\\text{ani}}$.\n3.  The isotropic baseline strategy always uses the mesh $(N_x, N_y) = (\\sqrt{B}, \\sqrt{B})$, defining the grid for $\\eta_{\\text{iso}}$.\n4.  Compute $\\eta_{\\text{ani}}(B;\\epsilon)$ and $\\eta_{\\text{iso}}(B;\\epsilon)$ on their respective grids.\n5.  Calculate the performance ratio $\\rho(B;\\epsilon) = \\eta_{\\text{iso}}(B;\\epsilon) / \\eta_{\\text{ani}}(B;\\epsilon)$.\n\nThe implementation will heavily leverage `numpy` for vectorized calculations. Nodal values of $u$ are computed on a grid. Element stresses $\\sigma_h$ are computed using array differences. Nodal stress recovery $\\sigma^*$ is performed by iterating over each grid node and summing contributions from its defined neighbors. Element-wise recovered stresses $\\sigma^*_K$ and the final sums for $\\eta^2$, $S_x$, and $S_y$ are also computed using vectorized operations. This entire procedure is encapsulated in a function that is called for each required grid configuration to obtain the final ratios.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_quantities(Nx, Ny, epsilon, delta=1e-30):\n    \"\"\"\n    Computes the ZZ error estimator eta and directional ratio R for a given grid and epsilon.\n    \"\"\"\n    if Nx = 0 or Ny = 0:\n        raise ValueError(\"Nx and Ny must be positive.\")\n\n    # 1. Grid and Nodal Values\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n    x_coords = np.linspace(0, 1, Nx + 1)\n    y_coords = np.linspace(0, 1, Ny + 1)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n    # Exact solution u at nodes\n    U = (1.0 - np.exp(-(1.0 - xx) / epsilon)) * np.sin(np.pi * yy)\n\n    # 2. Element Stresses (sigma_h)\n    # Vectorized computation of gradients on all triangles\n    gradx_h_on_U = np.diff(U, axis=0) / hx\n    grady_h_on_U = np.diff(U, axis=1) / hy\n\n    # Gradients for type 1 triangles (LL, LR, UR)\n    grad_K1_x = gradx_h_on_U[:, :-1]\n    grad_K1_y = grady_h_on_U[1:, :]\n    sigma_h_K1 = -np.stack([grad_K1_x, grad_K1_y], axis=-1)\n\n    # Gradients for type 2 triangles (LL, UL, UR)\n    grad_K2_x = gradx_h_on_U[:, 1:]\n    grad_K2_y = grady_h_on_U[:-1, :]\n    sigma_h_K2 = -np.stack([grad_K2_x, grad_K2_y], axis=-1)\n\n    # 3. Nodal Stress Recovery (sigma_star_nodal)\n    sigma_star_nodal = np.zeros((Nx + 1, Ny + 1, 2))\n    # Pad element stresses for easier summation\n    sigma_h_K1_padded = np.pad(sigma_h_K1, ((1, 1), (1, 1), (0, 0)), 'constant')\n    sigma_h_K2_padded = np.pad(sigma_h_K2, ((1, 1), (1, 1), (0, 0)), 'constant')\n\n    # Sum contributions from 6 possible neighboring triangles for each node\n    sigma_star_nodal += sigma_h_K1_padded[1:-1, 1:-1, :]  # From cell (k, l), triangle 1\n    sigma_star_nodal += sigma_h_K2_padded[1:-1, 1:-1, :]  # From cell (k, l), triangle 2\n    sigma_star_nodal += sigma_h_K1_padded[1:-1, 0:-2, :]  # From cell (k-1, l), triangle 1\n    sigma_star_nodal += sigma_h_K2_padded[0:-2, 1:-1, :]  # From cell (k, l-1), triangle 2\n    sigma_star_nodal += sigma_h_K1_padded[0:-2, 0:-2, :]  # From cell (k-1, l-1), triangle 1\n    sigma_star_nodal += sigma_h_K2_padded[0:-2, 0:-2, :]  # From cell (k-1, l-1), triangle 2\n\n    # Normalization factors (number of adjacent triangles)\n    counts = np.ones((Nx + 1, Ny + 1)) * 6\n    counts[0, :] = counts[-1, :] = counts[:, 0] = counts[:, -1] = 3\n    counts[0, 0] = counts[0, -1] = counts[-1, 0] = counts[-1, -1] = 1\n    counts[1:-1, 0] = counts[1:-1, -1] = counts[0, 1:-1] = counts[-1, 1:-1] = 2 # Mistake in simple logic, let's correct it\n    \n    # Correct counts\n    counts_correct = np.ones((Nx+1, Ny+1)) * 6\n    counts_correct[0, :] = 3; counts_correct[-1, :] = 3\n    counts_correct[:, 0] = 3; counts_correct[:, -1] = 3\n    counts_correct[0,0]=1; counts_correct[0,-1]=2\n    counts_correct[-1,0]=2; counts_correct[-1,-1]=1\n    # The padding/summing logic is tricky. A simple loop is safer\n    sigma_star_nodal_loop = np.zeros((Nx + 1, Ny + 1, 2))\n    counts_loop = np.zeros((Nx+1, Ny+1))\n    for k in range(Nx):\n        for l in range(Ny):\n            # K1 vertices: (k,l), (k+1,l), (k+1,l+1)\n            sigma_star_nodal_loop[k,l] += sigma_h_K1[k,l]; counts_loop[k,l]+=1\n            sigma_star_nodal_loop[k+1,l] += sigma_h_K1[k,l]; counts_loop[k+1,l]+=1\n            sigma_star_nodal_loop[k+1,l+1] += sigma_h_K1[k,l]; counts_loop[k+1,l+1]+=1\n            # K2 vertices: (k,l), (k,l+1), (k+1,l+1)\n            sigma_star_nodal_loop[k,l] += sigma_h_K2[k,l]; counts_loop[k,l]+=1\n            sigma_star_nodal_loop[k,l+1] += sigma_h_K2[k,l]; counts_loop[k,l+1]+=1\n            sigma_star_nodal_loop[k+1,l+1] += sigma_h_K2[k,l]; counts_loop[k+1,l+1]+=1\n    sigma_star_nodal = sigma_star_nodal_loop / counts_loop[:, :, np.newaxis]\n\n    # 4. Elementwise Recovered Stress (sigma_star_K) and Indicators\n    s_star_p1 = sigma_star_nodal[:-1, :-1]\n    s_star_p2 = sigma_star_nodal[1:, :-1]\n    s_star_p3 = sigma_star_nodal[1:, 1:]\n    sigma_star_K1 = (s_star_p1 + s_star_p2 + s_star_p3) / 3.0\n\n    s_star_p1 = sigma_star_nodal[:-1, :-1]\n    s_star_p2 = sigma_star_nodal[:-1, 1:]\n    s_star_p3 = sigma_star_nodal[1:, 1:]\n    sigma_star_K2 = (s_star_p1 + s_star_p2 + s_star_p3) / 3.0\n    \n    # Correction: need to match vertices with element definitions\n    # K1: (k,l), (k+1,l), (k+1,l+1)\n    sigma_star_K1 = (sigma_star_nodal[:-1, :-1] + sigma_star_nodal[1:, :-1] + sigma_star_nodal[1:, 1:]) / 3.0\n    # K2: (k,l), (k,l+1), (k+1,l+1)\n    sigma_star_K2 = (sigma_star_nodal[:-1, :-1] + sigma_star_nodal[:-1, 1:] + sigma_star_nodal[1:, 1:]) / 3.0\n    \n    # 5. Global Quantities\n    tri_area = 0.5 * hx * hy\n    \n    diff1_sq_norm = np.sum((sigma_star_K1 - sigma_h_K1)**2)\n    diff2_sq_norm = np.sum((sigma_star_K2 - sigma_h_K2)**2)\n    eta_squared_sum = tri_area * (diff1_sq_norm + diff2_sq_norm)\n    eta = np.sqrt(eta_squared_sum)\n\n    Sx = tri_area * (np.sum(sigma_star_K1[:, :, 0]**2) + np.sum(sigma_star_K2[:, :, 0]**2))\n    Sy = tri_area * (np.sum(sigma_star_K1[:, :, 1]**2) + np.sum(sigma_star_K2[:, :, 1]**2))\n    R = Sx / (Sy + delta)\n\n    return eta, R\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem logic and print the final results.\n    \"\"\"\n    epsilons = [0.2, 0.05, 1.0]\n    budgets = [256, 1024, 4096]\n    alpha = 3.0\n    Nx0, Ny0 = 8, 8\n\n    all_results = []\n\n    for epsilon in epsilons:\n        budget_results = []\n        \n        _, R_base = compute_quantities(Nx0, Ny0, epsilon)\n        is_anisotropic = R_base >= alpha\n\n        for B in budgets:\n            N_iso = int(np.sqrt(B))\n            Nx_iso, Ny_iso = N_iso, N_iso\n            \n            if is_anisotropic:\n                Nx_ani, Ny_ani = int(B / Ny0), Ny0\n            else:\n                N_ani = int(np.sqrt(B))\n                Nx_ani, Ny_ani = N_ani, N_ani\n            \n            eta_iso, _ = compute_quantities(Nx_iso, Ny_iso, epsilon)\n            eta_ani, _ = compute_quantities(Nx_ani, Ny_ani, epsilon)\n\n            if eta_ani > 0:\n                rho = eta_iso / eta_ani\n            else:\n                rho = 1.0 if eta_iso == 0 else np.inf\n                \n            budget_results.append(rho)\n        all_results.append(budget_results)\n\n    print(str(all_results).replace(\" \", \"\").replace(\"inf\", \"np.inf\"))\n\nsolve()\n```", "id": "2613032"}]}