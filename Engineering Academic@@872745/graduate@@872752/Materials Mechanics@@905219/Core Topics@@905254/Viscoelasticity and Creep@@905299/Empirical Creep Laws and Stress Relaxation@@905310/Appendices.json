{"hands_on_practices": [{"introduction": "Understanding how materials with memory respond to complex loading histories is a fundamental challenge in mechanics. This practice explores the Boltzmann superposition principle, a powerful tool for analyzing linear viscoelastic solids. By calculating the stress response to a multi-step strain input for a material described by a Prony series, you will develop a practical understanding of how to apply this principle to predict material behavior under time-varying conditions [@problem_id:2883414].", "problem": "A uniaxial, isothermal, small-deformation linear viscoelastic (LVE) solid is characterized by a relaxation modulus represented by a two-term Prony series. The relaxation modulus is given by\n$$\nE(t) \\;=\\; E_{\\infty} \\;+\\; E_{1}\\,\\exp\\!\\left(-\\frac{t}{\\tau_{1}}\\right) \\;+\\; E_{2}\\,\\exp\\!\\left(-\\frac{t}{\\tau_{2}}\\right), \\quad t \\ge 0,\n$$\nwith parameters\n$$\nE_{\\infty} \\;=\\; 1.5~\\text{GPa}, \\quad E_{1} \\;=\\; 0.9~\\text{GPa}, \\quad E_{2} \\;=\\; 0.6~\\text{GPa}, \\quad \\tau_{1} \\;=\\; 100~\\text{s}, \\quad \\tau_{2} \\;=\\; 10~\\text{s}.\n$$\nThe strain history is a two-step input:\n- at time $t=0^{+}$, the strain jumps from $0$ to $\\varepsilon_{0}$,\n- at time $t=t_{1}$, the strain changes by an additional $\\Delta\\varepsilon$,\nso that the total strain is\n$$\n\\varepsilon(t) \\;=\\; \\varepsilon_{0}\\,H(t) \\;+\\; \\Delta\\varepsilon\\,H(t-t_{1}),\n$$\nwhere $H(t)$ is the Heaviside step function. The parameters are\n$$\n\\varepsilon_{0} \\;=\\; 0.010, \\quad \\Delta\\varepsilon \\;=\\; -0.006, \\quad t_{1} \\;=\\; 30~\\text{s}.\n$$\nStarting from the Boltzmann superposition principle for linear viscoelasticity, compute the stress $\\sigma(t_{f})$ at time $t_{f} = 150~\\text{s}$. Express your final answer in $\\text{MPa}$, and round your result to four significant figures.", "solution": "The analysis of this problem begins with the validation of the provided statement. The problem describes a linear viscoelastic solid subject to a specified strain history. It provides a functional form for the relaxation modulus, a two-term Prony series, and all associated material parameters ($E_{\\infty}$, $E_{1}$, $E_{2}$, $\\tau_{1}$, $\\tau_{2}$). The strain history is a well-defined two-step function with all parameters ($\\varepsilon_{0}$, $\\Delta\\varepsilon$, $t_{1}$) specified. The objective is to compute the stress $\\sigma(t_{f})$ at a specific time $t_{f}$. The problem is scientifically grounded in the established theory of linear viscoelasticity, is mathematically well-posed, and contains all necessary information for a unique solution. The provided values are physically realistic for a polymeric material under small-strain conditions. Therefore, the problem is valid, and we proceed with the solution.\n\nThe fundamental principle governing the behavior of a linear viscoelastic material is the Boltzmann superposition principle. For a general time-varying uniaxial strain $\\varepsilon(t)$ applied to a material that is quiescent for $t  0$, the stress $\\sigma(t)$ is given by the hereditary integral:\n$$\n\\sigma(t) = \\int_{0^{-}}^{t} E(t-\\tau) \\frac{d\\varepsilon(\\tau)}{d\\tau} d\\tau\n$$\nwhere $E(t)$ is the uniaxial relaxation modulus.\n\nThe given strain history is a superposition of two step functions:\n$$\n\\varepsilon(t) = \\varepsilon_{0} H(t) + \\Delta\\varepsilon H(t-t_{1})\n$$\nwhere $H(t)$ is the Heaviside step function. The time derivative of the strain is a series of Dirac delta functions:\n$$\n\\frac{d\\varepsilon(t)}{dt} = \\varepsilon_{0} \\delta(t) + \\Delta\\varepsilon \\delta(t-t_{1})\n$$\nSubstituting this derivative into the Boltzmann integral yields:\n$$\n\\sigma(t) = \\int_{0^{-}}^{t} E(t-\\tau) \\left[ \\varepsilon_{0} \\delta(\\tau) + \\Delta\\varepsilon \\delta(\\tau-t_{1}) \\right] d\\tau\n$$\nUsing the sifting property of the Dirac delta function, which states that $\\int f(\\tau) \\delta(\\tau-a) d\\tau = f(a)$, the integral is evaluated as:\n$$\n\\sigma(t) = \\varepsilon_{0} E(t-0) H(t-0) + \\Delta\\varepsilon E(t-t_{1}) H(t-t_{1})\n$$\nThis expression represents the superposition of stress responses from two distinct strain jumps: a jump of $\\varepsilon_{0}$ at $t=0$ and a jump of $\\Delta\\varepsilon$ at $t=t_{1}$. For any time $t \\ge t_{1}$, both Heaviside functions are equal to one, so the expression simplifies to:\n$$\n\\sigma(t) = \\varepsilon_{0} E(t) + \\Delta\\varepsilon E(t-t_{1}), \\quad \\text{for } t \\ge t_{1}\n$$\nWe are asked to compute the stress at $t = t_{f} = 150~\\text{s}$. Since $t_{f}  t_{1} = 30~\\text{s}$, this simplified form is applicable.\n$$\n\\sigma(t_{f}) = \\varepsilon_{0} E(t_{f}) + \\Delta\\varepsilon E(t_{f}-t_{1})\n$$\nThe relaxation modulus is given by the Prony series:\n$$\nE(t) = E_{\\infty} + E_{1} \\exp\\left(-\\frac{t}{\\tau_{1}}\\right) + E_{2} \\exp\\left(-\\frac{t}{\\tau_{2}}\\right)\n$$\nWe need to evaluate $E(t)$ at two time points: $t = t_{f} = 150~\\text{s}$ and $t = t_{f}-t_{1} = 150~\\text{s} - 30~\\text{s} = 120~\\text{s}$.\n\nFirst, we calculate $E(t_{f}) = E(150~\\text{s})$ using the given parameters:\n$E_{\\infty} = 1.5~\\text{GPa}$, $E_{1} = 0.9~\\text{GPa}$, $E_{2} = 0.6~\\text{GPa}$, $\\tau_{1} = 100~\\text{s}$, $\\tau_{2} = 10~\\text{s}$.\n$$\nE(150) = 1.5 + 0.9 \\exp\\left(-\\frac{150}{100}\\right) + 0.6 \\exp\\left(-\\frac{150}{10}\\right)\n$$\n$$\nE(150) = 1.5 + 0.9 \\exp(-1.5) + 0.6 \\exp(-15) \\quad [\\text{GPa}]\n$$\nNext, we calculate $E(t_{f}-t_{1}) = E(120~\\text{s})$:\n$$\nE(120) = 1.5 + 0.9 \\exp\\left(-\\frac{120}{100}\\right) + 0.6 \\exp\\left(-\\frac{120}{10}\\right)\n$$\n$$\nE(120) = 1.5 + 0.9 \\exp(-1.2) + 0.6 \\exp(-12) \\quad [\\text{GPa}]\n$$\nNow, substitute these expressions and the strain parameters ($\\varepsilon_{0} = 0.010$, $\\Delta\\varepsilon = -0.006$) into the equation for $\\sigma(t_{f})$:\n$$\n\\sigma(150) = 0.010 \\left[ 1.5 + 0.9 \\exp(-1.5) + 0.6 \\exp(-15) \\right] - 0.006 \\left[ 1.5 + 0.9 \\exp(-1.2) + 0.6 \\exp(-12) \\right]\n$$\nThe stress will be in GPa since the moduli are in GPa and strain is dimensionless. Let us group the terms:\n$$\n\\sigma(150) = (0.010 - 0.006) E_{\\infty} + 0.010 E_{1} \\exp(-1.5) - 0.006 E_{1} \\exp(-1.2) + 0.010 E_{2} \\exp(-15) - 0.006 E_{2} \\exp(-12)\n$$\nSubstituting numerical values for the coefficients:\n$$\n\\sigma(150) = (0.004)(1.5) + (0.010)(0.9) \\exp(-1.5) - (0.006)(0.9) \\exp(-1.2) + (0.010)(0.6) \\exp(-15) - (0.006)(0.6) \\exp(-12)\n$$\n$$\n\\sigma(150) = 0.006 + 0.009 \\exp(-1.5) - 0.0054 \\exp(-1.2) + 0.006 \\exp(-15) - 0.0036 \\exp(-12) \\quad [\\text{GPa}]\n$$\nNow, we evaluate the exponential terms:\n$\\exp(-1.5) \\approx 0.223130$\n$\\exp(-1.2) \\approx 0.301194$\n$\\exp(-15) \\approx 3.059 \\times 10^{-7}$\n$\\exp(-12) \\approx 6.144 \\times 10^{-6}$\nThe terms involving $\\exp(-15)$ and $\\exp(-12)$ are negligibly small and can be safely ignored for the required precision.\n$$\n\\sigma(150) \\approx 0.006 + 0.009(0.223130) - 0.0054(0.301194)\n$$\n$$\n\\sigma(150) \\approx 0.006 + 0.00200817 - 0.00162645\n$$\n$$\n\\sigma(150) \\approx 0.00638172 \\quad [\\text{GPa}]\n$$\nThe problem requires the answer in megapascals (MPa). We convert from GPa to MPa using the relation $1~\\text{GPa} = 1000~\\text{MPa}$:\n$$\n\\sigma(150) \\approx 0.00638172 \\times 1000 \\quad [\\text{MPa}]\n$$\n$$\n\\sigma(150) \\approx 6.38172 \\quad [\\text{MPa}]\n$$\nFinally, rounding the result to four significant figures as requested:\n$$\n\\sigma(150) \\approx 6.382 \\quad [\\text{MPa}]\n$$", "answer": "$$\\boxed{6.382}$$", "id": "2883414"}, {"introduction": "Moving beyond linear models, we now examine the nonlinear, permanent deformation characteristic of metals at high temperatures. This exercise requires you to derive the governing differential equation for creep strain evolution under a constant load from first principles, using the empirical Norton power-law model [@problem_id:2883365]. This derivation is crucial as it quantitatively demonstrates how the true stress increases during a constant-load test, leading to an acceleration of creep and providing a foundation for predicting rupture times.", "problem": "A slender, homogeneous bar of initial length $L_{0}$ and initial cross-sectional area $A_{0}$ is subjected to a constant uniaxial tensile load $P$ at a fixed temperature where elastic strains are negligible compared to creep strains. Assume that deformation is spatially uniform along the gage section and that the inelastic flow is isochoric (incompressible), so that $A(t)\\,L(t)=A_{0}\\,L_{0}$ during uniaxial extension. Let the axial stretch be $\\lambda(t)=L(t)/L_{0}$ and the true (logarithmic) axial strain be $\\epsilon_{\\text{true}}(t)=\\ln \\lambda(t)$. The true axial Cauchy stress is taken as $\\sigma(t)=P/A(t)$. The material obeys the Norton creep law in uniaxial form with material parameters $C0$ and $n1$, so that the true creep strain rate satisfies $\\dot{\\epsilon}_{\\text{true}}(t)=C\\,[\\sigma(t)]^{n}$.\n\nStarting from these definitions and fundamental relations only, derive the autonomous ordinary differential equation for the evolution of the true strain under the constant load. Specifically, determine the function $f(\\epsilon_{\\text{true}})$ such that $\\dot{\\epsilon}_{\\text{true}}(t)=f(\\epsilon_{\\text{true}}(t))$.\n\nReport your final answer as a single closed-form symbolic expression for $f(\\epsilon_{\\text{true}})$ in terms of $C$, $n$, $P$, $A_{0}$, and $\\epsilon_{\\text{true}}$. Do not include units in your final expression.", "solution": "The goal is to derive an autonomous ordinary differential equation for the true strain $\\epsilon_{\\text{true}}(t)$ under a constant applied load $P$, given incompressible uniaxial extension and the Norton creep law. We proceed from fundamental kinematics, equilibrium, and the empirical creep law.\n\nFirst, define the kinematics of uniaxial extension. The axial stretch is $\\lambda(t)=L(t)/L_{0}$. The true (logarithmic) strain is, by definition,\n$$\n\\epsilon_{\\text{true}}(t)=\\ln \\lambda(t).\n$$\nFor incompressible uniaxial deformation (isochoric flow), the current cross-sectional area $A(t)$ and current length $L(t)$ satisfy volume conservation $A(t)\\,L(t)=A_{0}\\,L_{0}$. Therefore,\n$$\nA(t)=\\frac{A_{0}\\,L_{0}}{L(t)}=\\frac{A_{0}}{\\lambda(t)}.\n$$\n\nUnder the constant applied load $P$, the true Cauchy stress is related to the current area by force equilibrium,\n$$\n\\sigma(t)=\\frac{P}{A(t)}.\n$$\nSubstituting the incompressibility relation for $A(t)$ yields\n$$\n\\sigma(t)=\\frac{P}{A_{0}/\\lambda(t)}=\\frac{P}{A_{0}}\\,\\lambda(t).\n$$\nUsing the definition of true strain, $\\lambda(t)=\\exp(\\epsilon_{\\text{true}}(t))$, we obtain\n$$\n\\sigma(t)=\\frac{P}{A_{0}}\\,\\exp\\!\\big(\\epsilon_{\\text{true}}(t)\\big).\n$$\n\nThe Norton creep law for uniaxial creep gives the true creep strain rate as a power of the true stress,\n$$\n\\dot{\\epsilon}_{\\text{true}}(t)=C\\,[\\sigma(t)]^{n},\n$$\nwhere $C0$ and $n1$ are material parameters at the given temperature. Substituting the expression for $\\sigma(t)$ leads to\n$$\n\\dot{\\epsilon}_{\\text{true}}(t)=C\\left[\\frac{P}{A_{0}}\\,\\exp\\!\\big(\\epsilon_{\\text{true}}(t)\\big)\\right]^{n}\n=C\\left(\\frac{P}{A_{0}}\\right)^{n}\\exp\\!\\big(n\\,\\epsilon_{\\text{true}}(t)\\big).\n$$\n\nThis is an autonomous ordinary differential equation of the form\n$$\n\\dot{\\epsilon}_{\\text{true}}(t)=f\\!\\big(\\epsilon_{\\text{true}}(t)\\big),\n$$\nwith the right-hand side function\n$$\nf(\\epsilon_{\\text{true}})=C\\left(\\frac{P}{A_{0}}\\right)^{n}\\exp\\!\\big(n\\,\\epsilon_{\\text{true}}\\big).\n$$\n\nThis completes the derivation using the fundamental kinematic definition of true strain, the incompressibility constraint, force equilibrium for the Cauchy stress, and the Norton empirical creep law.", "answer": "$$\\boxed{C\\left(\\frac{P}{A_{0}}\\right)^{n}\\exp\\!\\left(n\\,\\epsilon_{\\text{true}}\\right)}$$", "id": "2883365"}, {"introduction": "The ultimate application of constitutive models often lies in their implementation within computational tools like finite element analysis. This advanced practice guides you through the process of numerically integrating a Norton power-law model, a task central to modern computational mechanics [@problem_id:2883346]. You will derive the nonlinear residual equation for a stress update and the corresponding algorithmic consistent tangent modulus, $C_{\\mathrm{alg}}$, which is essential for achieving quadratic convergence in implicit simulations of creep and stress relaxation.", "problem": "A uniaxial, small-strain, isothermal material exhibits rate-dependent inelastic deformation according to a Norton power-law creep (or viscoplastic) flow rule. The total strain at time step $n+1$ is prescribed to be constant during the step (strain control), which models stress relaxation. The kinematics split the total strain as $\\epsilon = \\epsilon^{\\mathrm{e}} + \\epsilon^{\\mathrm{vp}}$, where $\\epsilon^{\\mathrm{e}}$ is the elastic strain and $\\epsilon^{\\mathrm{vp}}$ is the viscoplastic (creep) strain. The stress is given by Hooke’s law $\\sigma = E \\, \\epsilon^{\\mathrm{e}}$, where $E$ is the elastic modulus. The viscoplastic strain rate follows a Norton law $\\dot{\\epsilon}^{\\mathrm{vp}} = A \\, |\\sigma|^{n-1}\\sigma$, where $A$ is a material parameter with units $\\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$ and $n \\ge 1$ is the stress exponent. Assume small strains and a backward Euler time discretization over a time step of duration $\\Delta t$, and assume $\\epsilon^{\\mathrm{vp}}_n$ and $\\sigma_n$ are known from the previous step. Let the prescribed total strain at the end of the step be $\\epsilon_{n+1}$.\n\n1) Starting from the above definitions and the backward Euler discretization of the viscoplastic strain, construct a scalar nonlinear residual $R(\\sigma_{n+1}) = 0$ whose solution yields the updated stress $\\sigma_{n+1}$ under the constraint of prescribed $\\epsilon_{n+1}$ and given $\\epsilon^{\\mathrm{vp}}_n$. Do not assume a priori the form of the solution; derive the residual from first principles.\n\n2) By differentiating the residual with respect to $\\sigma_{n+1}$ and $\\epsilon_{n+1}$, derive an explicit expression for the algorithmic consistent tangent modulus $C_{\\mathrm{alg}} = \\dfrac{d \\sigma_{n+1}}{d \\epsilon_{n+1}}$ required by an implicit finite element implementation to ensure quadratic convergence of Newton iterations in the global solution. Express $C_{\\mathrm{alg}}$ in terms of $E$, $A$, $n$, $\\Delta t$, and $\\sigma_{n+1}$.\n\n3) State clear and verifiable conditions under which Newton’s method with the consistent Jacobian for the local stress update is expected to achieve quadratic convergence. Your conditions should be justified by appropriate mathematical properties of $R(\\sigma_{n+1})$ near the root.\n\n4) Implement a program that, for each test case listed below, performs the following:\n   - Uses a Newton iteration with the exact local Jacobian (the derivative of $R$ with respect to $\\sigma_{n+1}$) to solve for $\\sigma_{n+1}$ under strain control with backward Euler, starting from the elastic predictor $\\sigma^{\\mathrm{trial}} = E \\, (\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n)$.\n   - Uses a second Newton-like solver that replaces the exact local Jacobian by the simplified choice $J_{\\mathrm{simp}} = 1$ while keeping the same residual and a backtracking line search to promote global convergence, starting from the same initial guess.\n   - For both solvers, employ a robust stopping criterion based on the absolute residual. Use the absolute tolerance $T_{\\mathrm{abs}} = 10^{-8} \\, E \\, \\max(1, |\\epsilon_{n+1}|)$ in $\\mathrm{Pa}$, and stop when $|R| \\le T_{\\mathrm{abs}}$.\n   - After convergence of the consistent-Jacobian solver, compute the algorithmic consistent tangent modulus $C_{\\mathrm{alg}} = \\dfrac{d \\sigma_{n+1}}{d \\epsilon_{n+1}}$ at the converged $\\sigma_{n+1}$.\n   - Record, for each test case: the converged stress $\\sigma_{n+1}$ in megapascals (MPa), the consistent tangent modulus $C_{\\mathrm{alg}}$ in gigapascals (GPa), the number of Newton iterations taken by the consistent-Jacobian solver, and the number of iterations taken by the simplified-Jacobian solver.\n   - Use a maximum of $50$ Newton iterations and a backtracking line search with step-size reduction factor $1/2$ and a sufficient decrease test $|R_{\\mathrm{new}}|  |R_{\\mathrm{old}}|$. If the residual is already below tolerance at the initial guess, the iteration count is zero.\n\n5) Physical units:\n   - Elastic modulus $E$ must be given in pascals ($\\mathrm{Pa}$).\n   - Norton parameter $A$ must be in $\\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$.\n   - Time step $\\Delta t$ must be in seconds ($\\mathrm{s}$).\n   - Strains are dimensionless.\n   - Output stress in megapascals (MPa) and modulus in gigapascals (GPa), both rounded to six decimal places.\n\n6) Test suite:\n   - Case 1 (moderate stress relaxation): $E = 210 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-30} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 3$, $\\Delta t = 3600 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.002$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$.\n   - Case 2 (nearly elastic within the step): $E = 210 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-30} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 3$, $\\Delta t = 1 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.002$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$.\n   - Case 3 (high exponent, long step, moderate modulus): $E = 70 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-50} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 5$, $\\Delta t = 100000 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.001$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$.\n   - Case 4 (edge case: zero total strain): $E = 100 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-30} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 3$, $\\Delta t = 1000 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.0$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$.\n\n7) Final output format:\n   - Your program should produce a single line of output containing the results aggregated into one comma-separated list enclosed in square brackets.\n   - For each test case, append in this order:\n     1. $\\sigma_{n+1}$ in $\\mathrm{MPa}$, rounded to six decimal places (a float).\n     2. $C_{\\mathrm{alg}}$ in $\\mathrm{GPa}$, rounded to six decimal places (a float).\n     3. Iterations used by the consistent-Jacobian Newton solver (an integer).\n     4. Iterations used by the simplified-Jacobian solver (an integer).\n   - Thus, with four test cases, the list contains sixteen entries in total:\n     $[\\sigma_1(\\mathrm{MPa}), C_{\\mathrm{alg},1}(\\mathrm{GPa}), it^{(c)}_1, it^{(s)}_1, \\dots, \\sigma_4(\\mathrm{MPa}), C_{\\mathrm{alg},4}(\\mathrm{GPa}), it^{(c)}_4, it^{(s)}_4]$.\n\nYour program must be self-contained, must not request any input, and must strictly print only the single-line list as specified.", "solution": "The problem statement has been validated and is deemed scientifically sound, well-posed, and self-contained. It represents a standard exercise in computational inelasticity. We proceed with the solution.\n\nThe derivation is presented in three parts, followed by an explanation of the numerical implementation.\n\n**1. Derivation of the Scalar Nonlinear Residual**\n\nThe material's behavior is governed by a set of fundamental equations. The total strain $\\epsilon$ is additively decomposed into an elastic part $\\epsilon^{\\mathrm{e}}$ and a viscoplastic part $\\epsilon^{\\mathrm{vp}}$:\n$$ \\epsilon = \\epsilon^{\\mathrm{e}} + \\epsilon^{\\mathrm{vp}} $$\nThe stress $\\sigma$ is related to the elastic strain through Hooke's Law:\n$$ \\sigma = E \\, \\epsilon^{\\mathrm{e}} $$\nwhere $E$ is the elastic modulus. The rate of evolution of viscoplastic strain $\\dot{\\epsilon}^{\\mathrm{vp}}$ follows the Norton power law:\n$$ \\dot{\\epsilon}^{\\mathrm{vp}} = A \\, |\\sigma|^{n-1}\\sigma $$\nwhere $A$ and $n$ are material parameters. It is useful to write this in the equivalent form $\\dot{\\epsilon}^{\\mathrm{vp}} = A_s \\mathrm{sgn}(\\sigma)|\\sigma|^n$, where $A_s$ is often used with a different value which incorporates a reference stress, but the given form is mathematically clear and physically standard for $n \\ge 1$.\n\nWe employ a backward Euler time integration scheme over a time step of duration $\\Delta t$. The viscoplastic strain rate at the end of the step, time $t_{n+1}$, is approximated as:\n$$ \\dot{\\epsilon}^{\\mathrm{vp}}_{n+1} \\approx \\frac{\\epsilon^{\\mathrm{vp}}_{n+1} - \\epsilon^{\\mathrm{vp}}_{n}}{\\Delta t} $$\nHere, $\\epsilon^{\\mathrm{vp}}_{n+1}$ and $\\epsilon^{\\mathrm{vp}}_{n}$ are the viscoplastic strains at times $t_{n+1}$ and $t_n$, respectively.\n\nThe key to the backward Euler method is that the flow rule is evaluated using the state at the end of the step, $\\sigma_{n+1}$:\n$$ \\dot{\\epsilon}^{\\mathrm{vp}}_{n+1} = A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\nCombining the two previous equations gives the update rule for the viscoplastic strain:\n$$ \\epsilon^{\\mathrm{vp}}_{n+1} = \\epsilon^{\\mathrm{vp}}_{n} + \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\nNow, consider the kinematic and elastic laws at time $t_{n+1}$:\n$$ \\epsilon_{n+1} = \\epsilon^{\\mathrm{e}}_{n+1} + \\epsilon^{\\mathrm{vp}}_{n+1} = \\frac{\\sigma_{n+1}}{E} + \\epsilon^{\\mathrm{vp}}_{n+1} $$\nWe are given the total strain $\\epsilon_{n+1}$ and the viscoplastic strain from the previous step, $\\epsilon^{\\mathrm{vp}}_{n}$. The unknown is the stress at the end of the step, $\\sigma_{n+1}$. Substituting the update rule for $\\epsilon^{\\mathrm{vp}}_{n+1}$ into the strain decomposition yields:\n$$ \\epsilon_{n+1} = \\frac{\\sigma_{n+1}}{E} + \\epsilon^{\\mathrm{vp}}_{n} + \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\nTo construct the residual equation $R(\\sigma_{n+1}) = 0$, we rearrange this equation. It is conventional in computational mechanics to define a \"trial elastic stress,\" $\\sigma^{\\mathrm{trial}}$, which represents the stress that would be reached if the step were purely elastic ($\\Delta \\epsilon^{\\mathrm{vp}} = 0$):\n$$ \\sigma^{\\mathrm{trial}} = E (\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n) $$\nUsing this definition, we can rewrite the equation as:\n$$ \\frac{\\sigma^{\\mathrm{trial}}}{E} = \\frac{\\sigma_{n+1}}{E} + \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\n$$ \\sigma^{\\mathrm{trial}} = \\sigma_{n+1} + E \\, \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\nFinally, the scalar nonlinear residual $R$ is defined as the function whose root is the updated stress $\\sigma_{n+1}$:\n$$ R(\\sigma_{n+1}) = \\sigma_{n+1} + E \\, \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} - \\sigma^{\\mathrm{trial}} = 0 $$\n\n**2. Derivation of the Algorithmic Consistent Tangent Modulus**\n\nThe algorithmic consistent tangent modulus, $C_{\\mathrm{alg}}$, is defined as the derivative of the updated stress $\\sigma_{n+1}$ with respect to the prescribed total strain $\\epsilon_{n+1}$:\n$$ C_{\\mathrm{alg}} = \\frac{d \\sigma_{n+1}}{d \\epsilon_{n+1}} $$\nThis quantity is essential for the quadratic convergence of a global Newton-Raphson solution scheme in an implicit finite element analysis. To derive it, we recognize that the residual $R$ is a function of both $\\sigma_{n+1}$ and $\\epsilon_{n+1}$ (through $\\sigma^{\\mathrm{trial}}$) and must be identically zero for any admissible pair $(\\sigma_{n+1}, \\epsilon_{n+1})$. Therefore, its total derivative with respect to $\\epsilon_{n+1}$ must be zero:\n$$ \\frac{dR}{d\\epsilon_{n+1}} = \\frac{\\partial R}{\\partial \\sigma_{n+1}} \\frac{d \\sigma_{n+1}}{d \\epsilon_{n+1}} + \\frac{\\partial R}{\\partial \\epsilon_{n+1}} = 0 $$\nSolving for $C_{\\mathrm{alg}}$ gives:\n$$ C_{\\mathrm{alg}} = \\frac{d \\sigma_{n+1}}{d \\epsilon_{n+1}} = - \\left( \\frac{\\partial R}{\\partial \\sigma_{n+1}} \\right)^{-1} \\left( \\frac{\\partial R}{\\partial \\epsilon_{n+1}} \\right) $$\nWe need to compute the two partial derivatives. First, the partial derivative of $R$ with respect to $\\sigma_{n+1}$. This is also the Jacobian required for the local Newton iteration. Let $g(\\sigma) = |\\sigma|^{n-1}\\sigma$. Its derivative is $g'(\\sigma) = n|\\sigma|^{n-1}$ for $n \\ge 1$.\n$$ \\frac{\\partial R}{\\partial \\sigma_{n+1}} = \\frac{\\partial}{\\partial \\sigma_{n+1}} \\left( \\sigma_{n+1} + E \\, \\Delta t \\, A \\, g(\\sigma_{n+1}) - E(\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n) \\right) $$\n$$ \\frac{\\partial R}{\\partial \\sigma_{n+1}} = 1 + E \\, \\Delta t \\, A \\, \\left( n|\\sigma_{n+1}|^{n-1} \\right) $$\nNext, the partial derivative with respect to $\\epsilon_{n+1}$:\n$$ \\frac{\\partial R}{\\partial \\epsilon_{n+1}} = \\frac{\\partial}{\\partial \\epsilon_{n+1}} \\left( \\sigma_{n+1} + E \\, \\Delta t \\, A \\, g(\\sigma_{n+1}) - E(\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n) \\right) = -E $$\nSubstituting these into the expression for $C_{\\mathrm{alg}}$ yields:\n$$ C_{\\mathrm{alg}} = - \\left( 1 + n E \\Delta t A |\\sigma_{n+1}|^{n-1} \\right)^{-1} (-E) $$\n$$ C_{\\mathrm{alg}} = \\frac{E}{1 + n E \\Delta t A |\\sigma_{n+1}|^{n-1}} $$\nThis is the explicit expression for the algorithmic consistent tangent modulus.\n\n**3. Conditions for Quadratic Convergence**\n\nThe local Newton-Raphson method for solving the scalar equation $R(\\sigma) = 0$ exhibits quadratic convergence near a root $\\sigma^*$ provided three conditions are met:\n1.  The initial guess $\\sigma_0$ is sufficiently close to the root $\\sigma^*$. In our problem, the elastic predictor $\\sigma^{\\mathrm{trial}}$ is used, which is typically a high-quality initial guess.\n2.  The root is simple, meaning the first derivative of the residual at the root is non-zero, i.e., $R'(\\sigma^*) \\neq 0$. For our residual, the derivative is $R'(\\sigma) = 1 + n E \\Delta t A |\\sigma|^{n-1}$. Since $E > 0$, $\\Delta t > 0$, $A > 0$, $n \\ge 1$, and $|\\sigma|^{n-1} \\ge 0$, it follows that $R'(\\sigma) \\ge 1$ for all $\\sigma$. Thus, the derivative is never zero, and the root is always simple. This also implies that $R(\\sigma)$ is a strictly monotonic function, guaranteeing a unique solution.\n3.  The residual function $R(\\sigma)$ is twice continuously differentiable ($C^2$) in a neighborhood of the root $\\sigma^*$. The second derivative is $R''(\\sigma) = n(n-1) E \\Delta t A |\\sigma|^{n-2} \\mathrm{sgn}(\\sigma)$. This function is continuous everywhere except possibly at $\\sigma=0$.\n    -   If the solution is $\\sigma^* \\neq 0$, then $R''(\\sigma)$ is continuous in a neighborhood of $\\sigma^*$.\n    -   If the solution is $\\sigma^* = 0$, then continuity of $R''(\\sigma)$ depends on the exponent $n$. The term $|\\sigma|^{n-2}$ is continuous at $\\sigma=0$ only if the exponent $n-2 \\ge 0$, which means $n \\ge 2$. However, for $R''(\\sigma)$ to be continuous, the limit must be $0$. This requires $n-2>0$, i.e., $n>2$. For $n=2$, $R''(\\sigma)$ has a jump discontinuity at $\\sigma=0$. For $1 \\le n  2$, $R''(\\sigma)$ is singular at $\\sigma=0$.\nIn summary, quadratic convergence is expected if the initial guess is close enough to the root. This is guaranteed for any non-zero root. If the root is exactly zero, theoretical quadratic convergence is only assured for $n>2$. As all test cases have $n \\ge 3$, this condition is met.\n\nThe Python code below implements the two specified solvers for the derived residual equation, calculates the final stress and consistent tangent modulus, and counts the iterations for each case, adhering to all specified numerical tolerances, solver parameters, and output formatting.\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the viscoplastic stress update problem for given test cases.\n    \"\"\"\n\n    def compute_step(E, A, n, dt, eps_total, eps_vp_n):\n        \"\"\"\n        Computes the stress update for a single time step using two different solvers.\n        \"\"\"\n        # 1. Initial values, constants, and helper functions\n        sigma_trial = E * (eps_total - eps_vp_n)\n        tol_abs = 1e-8 * E * max(1.0, np.abs(eps_total))\n        max_iter = 50\n\n        def g(sigma):\n            \"\"\"Evaluates the nonlinear part of the flow rule: |sigma|^(n-1) * sigma.\"\"\"\n            if sigma == 0.0:\n                return 0.0\n            return np.sign(sigma) * np.power(np.abs(sigma), n)\n\n        def R(sigma):\n            \"\"\"Calculates the residual for the nonlinear equation.\"\"\"\n            return sigma + E * dt * A * g(sigma) - sigma_trial\n\n        # ---- Solver 1: Consistent-Jacobian Newton-Raphson ----\n        sigma_c = sigma_trial\n        iter_c = 0\n        \n        res_c_abs = np.abs(R(sigma_c))\n        if res_c_abs > tol_abs:\n            for i in range(1, max_iter + 1):\n                res_c = R(sigma_c)\n                # Consistent Jacobian J = R'(sigma)\n                if sigma_c == 0.0:\n                    J_c = 1.0 \n                else:\n                    J_c = 1.0 + E * dt * A * n * np.power(np.abs(sigma_c), n - 1)\n                \n                delta_sigma = -res_c / J_c\n                \n                alpha = 1.0\n                sigma_new = sigma_c + alpha * delta_sigma\n                res_new_abs = np.abs(R(sigma_new))\n                \n                res_old_abs = np.abs(R(sigma_c))\n                while res_new_abs >= res_old_abs:\n                    alpha /= 2.0\n                    if alpha  1e-8:\n                        sigma_new = sigma_c\n                        res_new_abs = res_old_abs\n                        break\n                    sigma_new = sigma_c + alpha * delta_sigma\n                    res_new_abs = np.abs(R(sigma_new))\n                \n                sigma_c = sigma_new\n                iter_c = i\n\n                if np.abs(R(sigma_c)) = tol_abs:\n                    break\n\n        sigma_n1_c = sigma_c\n\n        # ---- Solver 2: Simplified-Jacobian Solver ----\n        sigma_s = sigma_trial\n        iter_s = 0\n\n        res_s_abs = np.abs(R(sigma_s))\n        if res_s_abs > tol_abs:\n            for i in range(1, max_iter + 1):\n                res_s = R(sigma_s)\n                J_s = 1.0\n                delta_sigma = -res_s / J_s\n                \n                alpha = 1.0\n                sigma_new = sigma_s + alpha * delta_sigma\n                res_new_abs = np.abs(R(sigma_new))\n                \n                res_old_abs = np.abs(R(sigma_s))\n                while res_new_abs >= res_old_abs:\n                    alpha /= 2.0\n                    if alpha  1e-8:\n                        sigma_new = sigma_s\n                        res_new_abs = res_old_abs\n                        break\n                    sigma_new = sigma_s + alpha * delta_sigma\n                    res_new_abs = np.abs(R(sigma_new))\n\n                sigma_s = sigma_new\n                iter_s = i\n\n                if np.abs(R(sigma_s)) = tol_abs:\n                    break\n        \n        # 3. Calculate Algorithmic Consistent Tangent Modulus\n        if sigma_n1_c == 0.0:\n            C_alg_pa = E / 1.0\n        else:\n            C_alg_pa = E / (1.0 + E * dt * A * n * np.power(np.abs(sigma_n1_c), n - 1))\n        \n        # 4. Units conversion for output\n        sigma_n1_mpa = sigma_n1_c / 1e6\n        C_alg_gpa = C_alg_pa / 1e9\n        \n        return sigma_n1_mpa, C_alg_gpa, iter_c, iter_s\n\n    test_cases = [\n        {'E': 210e9, 'A': 1.0e-30, 'n': 3, 'dt': 3600, 'eps_total': 0.002, 'eps_vp_n': 0},\n        {'E': 210e9, 'A': 1.0e-30, 'n': 3, 'dt': 1, 'eps_total': 0.002, 'eps_vp_n': 0},\n        {'E': 70e9, 'A': 1.0e-50, 'n': 5, 'dt': 100000, 'eps_total': 0.001, 'eps_vp_n': 0},\n        {'E': 100e9, 'A': 1.0e-30, 'n': 3, 'dt': 1000, 'eps_total': 0.0, 'eps_vp_n': 0},\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        s_mpa, C_gpa, it_c, it_s = compute_step(**case_params)\n        \n        all_results.append(f\"{s_mpa:.6f}\")\n        all_results.append(f\"{C_gpa:.6f}\")\n        all_results.append(str(it_c))\n        all_results.append(str(it_s))\n    \n    return f\"[{','.join(all_results)}]\"\n\n# The result is produced by running the above logic.\n# print(solve())\n```", "answer": "[295.421884,103.018251,4,12,419.970222,209.999965,2,3,44.757879,9.088651,5,24,0.000000,100.000000,0,0]", "id": "2883346"}]}