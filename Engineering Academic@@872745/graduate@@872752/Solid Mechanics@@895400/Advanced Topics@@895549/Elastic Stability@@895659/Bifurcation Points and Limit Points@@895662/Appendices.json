{"hands_on_practices": [{"introduction": "Understanding the distinction between stable and unstable equilibria is central to structural stability. This exercise explores the behavior of a system with a bistable potential energy landscape, which serves as a canonical model for snap-through buckling in structures like shallow arches and shells. By analyzing a simple one-degree-of-freedom potential, you will derive the full equilibrium path, identify the critical limit points where stability is lost, and determine the Maxwell load, which provides an energy-based criterion for the transition between stable states [@problem_id:2618872]. This practice builds a fundamental intuition for limit point instabilities and the concept of dissipative energy release during a dynamic snap-through event.", "problem": "A pin-pin shallow symmetric elastic arch of span much larger than rise is subjected to a slowly increased dead transverse generalized load. A standard single-mode Rayleigh–Ritz reduction yields a nondimensional one-degree-of-freedom total potential energy\n$$\n\\Pi(q;\\,\\Lambda) \\;=\\; \\frac{1}{4}\\,\\big(q^{2}-1\\big)^{2} \\;-\\; \\Lambda\\,q,\n$$\nwhere $q$ is the nondimensional generalized displacement amplitude of the symmetric mode, and $\\Lambda$ is the nondimensional dead load conjugate to $q$. Assume quasistatic loading with negligible inertia and small viscous damping so that equilibria are stationary points of $\\Pi$ and snap-through occurs at the first limit (fold) point on the equilibrium path under load control.\n\nUsing only fundamental principles of energy minimization and bifurcation theory in solid mechanics:\n\n1) Derive the equilibrium path $\\Lambda(q)$ from the stationarity condition on $\\Pi(q;\\Lambda)$.\n\n2) Locate the limit (fold) points by enforcing the loss of local invertibility of the equilibrium path with respect to $q$ under dead loading, and extract the first limit point $\\Lambda_{L1}$ reached when $\\Lambda$ is increased monotonically from $\\Lambda=0$ starting near the left well (i.e., $q \\approx -1$ at zero load).\n\n3) Define the Maxwell load $\\Lambda_{M}$ as the value of $\\Lambda$ at which the two stable equilibria that coexist at the same $\\Lambda$ have equal total potential energy. Starting from the definition of total potential energy and without invoking any pre-tabulated formula, derive an equal-area condition and compute the resulting $\\Lambda_{M}$.\n\n4) Based on a comparison between $\\Lambda_{M}$ and $\\Lambda_{L1}$, state whether snap-through from the left well at the first limit point under dead loading is dissipative (i.e., whether there is a net release of total potential energy).\n\nAnswer specification:\n- Express both the Maxwell load and the first limit point as exact nondimensional numbers. Do not round.\n- Provide your final answer as the ordered pair $\\big(\\Lambda_{M},\\,\\Lambda_{L1}\\big)$.\n- Do not include units in the final answer (the variables are nondimensional by construction).", "solution": "The problem is first validated to be scientifically grounded, well-posed, and objective. It represents a canonical problem in the theory of elastic stability, specifically the snap-through buckling of a shallow arch modeled via a cusp catastrophe potential. The problem is solvable using fundamental principles.\n\nThe total potential energy of the system is given by\n$$\n\\Pi(q;\\,\\Lambda) \\;=\\; \\frac{1}{4}\\,\\big(q^{2}-1\\big)^{2} \\;-\\; \\Lambda\\,q\n$$\nwhere $q$ is the generalized displacement and $\\Lambda$ is the applied dead load.\n\n1) Derivation of the equilibrium path.\nAccording to the principle of stationary potential energy, equilibrium configurations are those for which the total potential energy is stationary with respect to the generalized coordinate $q$. This is expressed mathematically as the vanishing of the first variation of $\\Pi$, which for a single degree of freedom is $\\frac{\\partial \\Pi}{\\partial q} = 0$.\nTaking the derivative of $\\Pi$ with respect to $q$:\n$$\n\\frac{\\partial \\Pi}{\\partial q} = \\frac{\\partial}{\\partial q} \\left[ \\frac{1}{4}(q^4 - 2q^2 + 1) - \\Lambda q \\right] = \\frac{1}{4}(4q^3 - 4q) - \\Lambda\n$$\nSetting the derivative to zero yields the equilibrium equation:\n$$\nq^3 - q - \\Lambda = 0\n$$\nThis equation defines the equilibrium path, which expresses the load $\\Lambda$ as a function of the displacement $q$:\n$$\n\\Lambda(q) = q^3 - q\n$$\n\n2) Location of limit points.\nLimit points (or fold bifurcations) are critical points on the equilibrium path where the stability of the equilibrium changes. A stable equilibrium corresponds to a local minimum of the potential energy, which requires the second derivative of $\\Pi$ with respect to $q$ to be positive. The loss of stability occurs when this second derivative becomes zero.\nThe second derivative of the potential energy is:\n$$\n\\frac{\\partial^2 \\Pi}{\\partial q^2} = \\frac{\\partial}{\\partial q}(q^3-q-\\Lambda) = 3q^2 - 1\n$$\nThe condition for a limit point is $\\frac{\\partial^2 \\Pi}{\\partial q^2} = 0$, which gives:\n$$\n3q^2 - 1 = 0 \\implies q^2 = \\frac{1}{3} \\implies q_{L} = \\pm \\frac{1}{\\sqrt{3}} = \\pm \\frac{\\sqrt{3}}{3}\n$$\nThese are the displacement values at the two limit points of the system. The corresponding load values are found by substituting these values of $q_{L}$ into the equilibrium path equation $\\Lambda(q) = q^3 - q$:\nFor $q_{L} = -\\frac{\\sqrt{3}}{3}$:\n$$\n\\Lambda_{L1} = \\left(-\\frac{\\sqrt{3}}{3}\\right)^3 - \\left(-\\frac{\\sqrt{3}}{3}\\right) = -\\frac{3\\sqrt{3}}{27} + \\frac{\\sqrt{3}}{3} = -\\frac{\\sqrt{3}}{9} + \\frac{3\\sqrt{3}}{9} = \\frac{2\\sqrt{3}}{9}\n$$\nFor $q_{L} = +\\frac{\\sqrt{3}}{3}$:\n$$\n\\Lambda_{L2} = \\left(\\frac{\\sqrt{3}}{3}\\right)^3 - \\left(\\frac{\\sqrt{3}}{3}\\right) = \\frac{3\\sqrt{3}}{27} - \\frac{\\sqrt{3}}{3} = \\frac{\\sqrt{3}}{9} - \\frac{3\\sqrt{3}}{9} = -\\frac{2\\sqrt{3}}{9}\n$$\nThe problem states that loading begins from $\\Lambda=0$ near the left well ($q \\approx -1$). The initial state is a stable equilibrium at $(q, \\Lambda) = (-1, 0)$, since $\\frac{\\partial^2 \\Pi}{\\partial q^2}|_{q=-1} = 3(-1)^2 - 1 = 2 > 0$. As the load $\\Lambda$ is increased monotonically from $0$, the system follows the stable equilibrium path originating from $q=-1$. This path leads to the first limit point encountered, which must have a positive load. This corresponds to the limit point at $q = -\\frac{\\sqrt{3}}{3}$.\nThus, the first limit point load is $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9}$.\n\n3) Derivation of the Maxwell load.\nThe Maxwell load $\\Lambda_M$ is defined as the value of the load parameter $\\Lambda$ at which two distinct stable equilibria, say at displacements $q_1$ and $q_2$, have equal total potential energy: $\\Pi(q_1; \\Lambda_M) = \\Pi(q_2; \\Lambda_M)$.\nThis condition implies that the change in potential energy between these two states is zero:\n$$\n\\Pi(q_2; \\Lambda_M) - \\Pi(q_1; \\Lambda_M) = \\int_{q_1}^{q_2} \\frac{\\partial \\Pi(q; \\Lambda_M)}{\\partial q} dq = 0\n$$\nSubstituting the derivative $\\frac{\\partial \\Pi}{\\partial q} = q^3 - q - \\Lambda_M$:\n$$\n\\int_{q_1}^{q_2} (q^3 - q - \\Lambda_M) dq = 0\n$$\nThis can be rewritten using the equilibrium path function $\\Lambda(q) = q^3 - q$ as:\n$$\n\\int_{q_1}^{q_2} (\\Lambda(q) - \\Lambda_M) dq = 0\n$$\nThis is the equal-area condition: the line $\\Lambda = \\Lambda_M$ must cut two lobes of equal area from the equilibrium path curve $\\Lambda(q)$.\nThe points $q_1$ and $q_2$ are themselves equilibrium points at load $\\Lambda_M$, so they are roots of the equilibrium equation $q^3 - q - \\Lambda_M = 0$.\nThe structure of the potential energy $\\Pi(q; \\Lambda) = \\frac{1}{4}(q^2-1)^2 - \\Lambda q$ shows that for $\\Lambda=0$, the potential energy $\\Pi(q;0)=\\frac{1}{4}(q^2-1)^2$ is symmetric. The equilibrium equation becomes $q^3-q=0$, with roots $q=0, \\pm 1$. The stable equilibria ($3q^2-1>0$) are at $q_1 = -1$ and $q_2 = 1$.\nLet us evaluate their potential energies at $\\Lambda=0$:\n$$\n\\Pi(-1; 0) = \\frac{1}{4}((-1)^2-1)^2 - 0 = 0\n$$\n$$\n\\Pi(1; 0) = \\frac{1}{4}((1)^2-1)^2 - 0 = 0\n$$\nSince the potential energies of the two stable equilibria are equal, the Maxwell load is precisely $\\Lambda_M = 0$. We can verify this with the equal-area rule:\n$$\n\\int_{-1}^{1} (q^3 - q - 0) dq = \\left[ \\frac{q^4}{4} - \\frac{q^2}{2} \\right]_{-1}^{1} = \\left(\\frac{1}{4}-\\frac{1}{2}\\right) - \\left(\\frac{1}{4} - \\frac{1}{2}\\right) = 0\n$$\nThe condition is satisfied. Therefore, $\\Lambda_M = 0$.\n\n4) Dissipation during snap-through.\nSnap-through from the left well occurs at the limit load $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9}$. At this point, the system is at the brink of instability. Under dead loading, the load $\\Lambda$ is maintained at $\\Lambda_{L1}$, and the system dynamically jumps to the other available stable equilibrium state at this same load.\nThe Maxwell load $\\Lambda_M = 0$ is the load at which the two stable equilibrium \"wells\" have equal potential energy. For any load $\\Lambda > \\Lambda_M$, the $-\\Lambda q$ term in the potential energy expression biases the system, lowering the energy of the well at positive $q$ and raising the energy of the well at negative $q$.\nSince snap-through occurs at $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9} > 0 = \\Lambda_M$, the jump is from a higher-energy state (the pre-snap equilibrium in the left well) to a lower-energy state (the post-snap equilibrium in the right well). This transition involves a net decrease in the total potential energy of the system, $\\Delta\\Pi < 0$. The released energy is dissipated, typically through viscous damping or emission of stress waves. Therefore, the snap-through is dissipative.\n\nThe final answer requires the ordered pair $(\\Lambda_M, \\Lambda_{L1})$. Based on the derivations above, we have $\\Lambda_M = 0$ and $\\Lambda_{L1} = \\frac{2\\sqrt{3}}{9}$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{2\\sqrt{3}}{9} \\end{pmatrix}}\n$$", "id": "2618872"}, {"introduction": "While some structures fail by snapping through a limit point, others fail via bifurcation, where the primary equilibrium path intersects with a secondary one. This exercise demonstrates how to predict such an instability in a continuous system, the classic Euler-Bernoulli beam, using the Finite Element Method (FEM). You will derive the elastic and geometric stiffness matrices from first principles and formulate the stability problem as a generalized eigenvalue problem [@problem_id:2543000]. Solving for the lowest eigenvalue reveals the critical buckling load, providing a foundational experience in the computational analysis of bifurcation phenomena.", "problem": "A uniform, prismatic Euler–Bernoulli beam of length $L$ and flexural rigidity $EI$ is axially compressed by a constant end force $N$ applied in the centroidal axis. Small strains and small rotations are assumed, and shear deformation is neglected. The beam is simply supported at both ends, modeled as $w(0)=0$, $w(L)=0$, with free end rotations. Consider the detection of buckling as a bifurcation of equilibrium, characterized by loss of positive definiteness of the second variation of the total potential energy, equivalently by the vanishing of the smallest eigenvalue of the tangent stiffness.\n\nUsing the Finite Element Method (FEM) with a single two-node Euler–Bernoulli beam element with Hermite cubic interpolation of the transverse displacement $w(x)$ and nodal degrees of freedom (DOFs) $w_{1}$, $\\theta_{1}$ at $x=0$ and $w_{2}$, $\\theta_{2}$ at $x=L$, proceed as follows from first principles:\n- Starting from the principle of virtual work and the linearization of the geometric nonlinearity induced by $N$, derive the consistent element bending stiffness and geometric (initial stress) stiffness in terms of the Hermite shape functions.\n- Assemble the element tangent stiffness, impose the simply supported boundary conditions by constraining $w_{1}=0$ and $w_{2}=0$ while leaving $\\theta_{1}$ and $\\theta_{2}$ free, and write the resulting reduced generalized eigenvalue problem for the rotational DOFs.\n- Solve this reduced problem to obtain the lowest critical load $N_{\\mathrm{cr}}^{\\mathrm{FE}}$ that predicts bifurcation.\n\nLet the analytical Euler buckling load for a simply supported beam be $N_{\\mathrm{cr}}^{\\mathrm{exact}}=\\pi^{2} EI / L^{2}$. As your final answer, report the single dimensionless ratio\n$$\nr \\;=\\; \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}}.\n$$\nExpress your final result as an exact closed-form analytic expression. Do not round or approximate.", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It presents a standard problem in computational structural mechanics, specifically the finite element analysis of elastic buckling. All required data and conditions are provided, and there are no contradictions or fallacies. The problem is valid. We proceed with the solution from first principles as requested.\n\nThe analysis is based on the linearized principle of virtual work for an Euler-Bernoulli beam subjected to an axial compressive force $N$. The tangent stiffness matrix $\\mathbf{K}_T$ is the sum of the standard elastic (bending) stiffness matrix $\\mathbf{K}_E$ and the geometric (initial stress) stiffness matrix $\\mathbf{K}_G$. Buckling bifurcation occurs when $\\mathbf{K}_T$ ceases to be positive definite, which is equivalent to finding the lowest load $N$ for which the eigenvalue problem $(\\mathbf{K}_E - \\mathbf{K}_G(N)) \\mathbf{d} = \\mathbf{0}$ has a non-trivial solution $\\mathbf{d} \\neq \\mathbf{0}$. Since $\\mathbf{K}_G$ is linearly dependent on $N$, we write $\\mathbf{K}_G = N \\mathbf{K}_{G0}$, and the problem becomes a standard linear eigenvalue problem $(\\mathbf{K}_E - N_{\\mathrm{cr}} \\mathbf{K}_{G0}) \\mathbf{d} = \\mathbf{0}$, where $N_{\\mathrm{cr}}$ are the critical loads.\n\nA single two-node beam element of length $L$ is used. The transverse displacement field $w(x)$ is interpolated using Hermite cubic shape functions. The nodal degrees of freedom (DOFs) are $\\mathbf{d} = [w_1, \\theta_1, w_2, \\theta_2]^T$, where $w_1 = w(0)$, $\\theta_1 = w'(0)$, $w_2 = w(L)$, and $\\theta_2 = w'(L)$. The displacement is given by $w(x) = \\mathbf{N}(x) \\mathbf{d}$, where $\\mathbf{N}(x) = [H_1(x), H_2(x), H_3(x), H_4(x)]$ is the vector of shape functions. In terms of the non-dimensional coordinate $\\xi = x/L$, these are:\n$$ H_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 $$\n$$ H_2(\\xi) = L(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ H_3(\\xi) = 3\\xi^2 - 2\\xi^3 $$\n$$ H_4(\\xi) = L(-\\xi^2 + \\xi^3) $$\n\nThe internal virtual work for a beam-column, considering bending and the effect of the axial force, is given by its linearization:\n$$ \\delta W_{\\mathrm{int}} = \\int_0^L \\delta\\epsilon_{xx} \\sigma_{xx} dA dx = \\int_0^L EI \\delta w'' w'' dx + \\int_0^L N \\delta w' w' dx $$\nwhere $w''$ is the curvature and $w'$ is the slope. The first term gives rise to the elastic stiffness matrix $\\mathbf{K}_E$ and the second term to the geometric stiffness matrix $\\mathbf{K}_G$.\n\nThe components of the elastic stiffness matrix $\\mathbf{K}_E$ are derived from the bending strain energy:\n$$ K_{E,ij} = EI \\int_0^L H_i''(x) H_j''(x) dx = EI \\int_0^1 H_i''(\\xi L) H_j''(\\xi L) L d\\xi $$\nEvaluation of these standard integrals over the element domain $[0, L]$ yields the matrix:\n$$ \\mathbf{K}_E = \\frac{EI}{L^3} \\begin{pmatrix} 12 & 6L & -12 & 6L \\\\ 6L & 4L^2 & -6L & 2L^2 \\\\ -12 & -6L & 12 & -6L \\\\ 6L & 2L^2 & -6L & 4L^2 \\end{pmatrix} $$\n\nThe components of the geometric stiffness matrix $\\mathbf{K}_G = N \\mathbf{K}_{G0}$ are derived from the work done by the axial force $N$ due to member rotation:\n$$ K_{G,ij} = \\int_0^L N H_i'(x) H_j'(x) dx = N \\int_0^1 H_i'(\\xi L) H_j'(\\xi L) L d\\xi $$\nThe matrix $\\mathbf{K}_{G0}$ is therefore:\n$$ K_{G0,ij} = \\int_0^L H_i'(x) H_j'(x) dx $$\nEvaluation of these integrals yields:\n$$ \\mathbf{K}_G = \\frac{N}{30L} \\begin{pmatrix} 36 & 3L & -36 & 3L \\\\ 3L & 4L^2 & -3L & -L^2 \\\\ -36 & -3L & 36 & -3L \\\\ 3L & -L^2 & -3L & 4L^2 \\end{pmatrix} $$\n\nThe problem specifies simply supported boundary conditions, which are $w(0)=w_1=0$ and $w(L)=w_2=0$. These constraints eliminate the first and third DOFs. The eigenvalue problem is reduced to the subspace of the free rotational DOFs, $\\theta_1$ and $\\theta_2$. We extract the submatrices corresponding to the second and fourth rows and columns of $\\mathbf{K}_E$ and $\\mathbf{K}_G$.\nThe reduced elastic stiffness matrix $\\mathbf{K}_{E, red}$ is:\n$$ \\mathbf{K}_{E, red} = \\frac{EI}{L^3} \\begin{pmatrix} 4L^2 & 2L^2 \\\\ 2L^2 & 4L^2 \\end{pmatrix} = \\frac{EI}{L} \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} $$\nThe reduced geometric stiffness matrix $\\mathbf{K}_{G, red}$ is:\n$$ \\mathbf{K}_{G, red} = \\frac{N}{30L} \\begin{pmatrix} 4L^2 & -L^2 \\\\ -L^2 & 4L^2 \\end{pmatrix} = \\frac{NL}{30} \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} $$\n\nThe reduced eigenvalue problem for the critical load $N = N_{\\mathrm{cr}}^{\\mathrm{FE}}$ is:\n$$ (\\mathbf{K}_{E, red} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\mathbf{K}_{G0, red}) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\nSubstituting the matrices gives:\n$$ \\left( \\frac{EI}{L} \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\frac{L}{30} \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} \\right) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\nFor a non-trivial solution, the determinant of the matrix must be zero. Let us define a dimensionless eigenvalue $\\lambda = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{30EI}$. The characteristic equation becomes:\n$$ \\det \\left( \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} - \\lambda \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det \\begin{pmatrix} 4 - 4\\lambda & 2 + \\lambda \\\\ 2 + \\lambda & 4 - 4\\lambda \\end{pmatrix} = 0 $$\n$$ (4 - 4\\lambda)^2 - (2 + \\lambda)^2 = 0 $$\nThis equation can be factored as a difference of squares:\n$$ [4(1-\\lambda) - (2+\\lambda)] [4(1-\\lambda) + (2+\\lambda)] = 0 $$\nThis leads to two possible solutions for $\\lambda$:\n$1$. $4 - 4\\lambda - 2 - \\lambda = 0 \\implies 2 - 5\\lambda = 0 \\implies \\lambda_1 = \\frac{2}{5}$\n$2$. $4 - 4\\lambda + 2 + \\lambda = 0 \\implies 6 - 3\\lambda = 0 \\implies \\lambda_2 = 2$\n\nThe lowest critical load corresponds to the smallest eigenvalue $\\lambda_1$.\n$$ N_{\\mathrm{cr}}^{\\mathrm{FE}} = \\frac{30EI}{L^2} \\lambda_1 = \\frac{30EI}{L^2} \\left(\\frac{2}{5}\\right) = \\frac{12EI}{L^2} $$\nThe analytical Euler buckling load for a simply supported beam is given as $N_{\\mathrm{cr}}^{\\mathrm{exact}} = \\frac{\\pi^2 EI}{L^2}$.\n\nThe required ratio $r$ is:\n$$ r = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}} = \\frac{12EI/L^2}{\\pi^2EI/L^2} = \\frac{12}{\\pi^2} $$\nThis result indicates that the single finite element model, due to its polynomial shape functions, is overly stiff and overestimates the true buckling load. The error is approximately $21.6\\%$. More elements would be required for convergence to the exact solution.", "answer": "$$\n\\boxed{\\frac{12}{\\pi^2}}\n$$", "id": "2543000"}, {"introduction": "Analyzing critical points gives us markers of instability, but tracing the full, often complex, equilibrium path provides a complete picture of a structure's nonlinear response. Standard load- or displacement-controlled solvers fail at limit points, making specialized algorithms necessary. This hands-on practice guides you through the derivation and implementation of the arc-length method, a robust path-following technique capable of navigating around limit points [@problem_id:2618840]. By building a solver for a classic two-bar truss exhibiting snap-through, you will gain practical, code-level mastery of a cornerstone technique in modern computational nonlinear mechanics.", "problem": "Consider a symmetric two-bar truss undergoing large displacements. The supports are at coordinates $\\left(-a,0\\right)$ and $\\left(a,0\\right)$, each with a pin support. The apex joint is initially located at $\\left(0,h_0\\right)$, connected to the two supports by identical bars of axial rigidity $EA$ and undeformed length $L_0=\\sqrt{a^2+h_0^2}$. The apex joint is constrained to move only vertically, with downward displacement denoted by $w \\ge 0$. A vertical reference load of magnitude $\\lambda$ (in Newtons) acts downward at the apex joint. The angle unit, if needed, is radians. All lengths must be treated in meters and all forces in Newtons. You are to implement the arc-length method (also known as the Riks method) to trace the equilibrium path through a limit point (fold) that arises from geometric nonlinearity (snap-through). You must derive and implement all necessary equations from first principles.\n\nTasks:\n- Adopt the definition that the internal generalized force at the apex, conjugate to the downward displacement $w$, is the derivative of the total internal strain energy with respect to $w$. Use the following fundamental bases only: conservation of energy, the definition of axial strain energy in a truss bar for linear elastic axial behavior, and geometry of the deformed configuration. The bar length under displacement $w$ is $L(w)=\\sqrt{a^2+\\left(h_0-w\\right)^2}$, and the axial strain energy in each bar is $U_b=\\dfrac{EA}{2L_0}\\left(L(w)-L_0\\right)^2$. The total internal energy is the sum over the two identical bars. From these definitions and geometry, derive the equilibrium equation $r\\left(w,\\lambda\\right)=0$ in the residual form $r\\left(w,\\lambda\\right)=f_{\\mathrm{int}}(w)-\\lambda$, and derive the scalar tangent stiffness $K_t(w)=\\dfrac{\\partial f_{\\mathrm{int}}}{\\partial w}(w)$. Do not use any pre-packaged or shortcut formulas; the derivation must be from the stated base.\n- Formulate the arc-length method with a single displacement degree of freedom $w$ and the load parameter $\\lambda$. Use the quadratic constraint $g\\left(w,\\lambda\\right)=\\left(w-w_n\\right)^2+\\alpha\\left(\\lambda-\\lambda_n\\right)^2-\\Delta s^2=0$, where $\\left(w_n,\\lambda_n\\right)$ is the converged state from the previous load-displacement step and $\\Delta s$ is the prescribed arc-length radius. The scaling parameter $\\alpha$ must be chosen to balance the units between displacement and load; use the choice $\\alpha=\\left(K_t\\left(0\\right)\\right)^{-2}$, where $K_t\\left(0\\right)$ is the initial tangent stiffness at $w=0$. Specify clearly the predictor direction from the linearization of the equilibrium equation and scale it to satisfy the arc-length constraint. Derive the Newton corrector system for the augmented set $\\left\\{r,g\\right\\}$ and show the predictor-corrector iteration equations.\n- Implement a robust algorithm that:\n  - Initializes at $\\left(w_0,\\lambda_0\\right)=\\left(0,0\\right)$, adopts $\\alpha=\\left(K_t\\left(0\\right)\\right)^{-2}$, and advances with arc-length step size $\\Delta s$.\n  - Uses a predictor direction consistent with the previous step by enforcing that the dot product in the scaled metric $[\\Delta w,\\sqrt{\\alpha}\\Delta\\lambda]\\cdot[\\Delta w_{\\text{prev}},\\sqrt{\\alpha}\\Delta\\lambda_{\\text{prev}}]$ is nonnegative.\n  - Applies Newton iterations to the $2\\times 2$ augmented system at each step until the absolute residuals in both $r$ and $g$ are below fixed tolerances in their native units: use absolute tolerances $\\varepsilon_r$ in Newtons and $\\varepsilon_g$ in $\\text{m}^2$, with no nondimensionalization beyond $\\alpha$.\n  - Detects and reports the first limit point (fold) by monitoring the sign of $K_t(w)$. When a sign change of $K_t$ between two consecutive converged states is found for the first time, bracket the fold and compute an approximation to the fold displacement $w_{\\mathrm{fold}}$ by a one-dimensional bisection on $K_t(w)=0$, and then compute $\\lambda_{\\mathrm{fold}}=f_{\\mathrm{int}}(w_{\\mathrm{fold}})$. If no fold is detected, report that the fold was not passed.\n  - Uses a backtracking strategy on the arc-length radius $\\Delta s$ if a step fails to converge: halve $\\Delta s$ on failure and retry the same step, and abort the case if $\\Delta s$ drops below a prescribed minimum $\\Delta s_{\\min}$.\n\nOutput requirements:\n- For each test case, your program must output a list with the following entries in order: `[`lambda_fold`, `w_fold`, `passed_fold`, `lambda_end`, `N_steps`]`, where $\\lambda_{\\mathrm{fold}}$ is in Newtons, $w_{\\mathrm{fold}}$ is in meters, `passed_fold` is a boolean, $\\lambda_{\\mathrm{end}}$ is the final converged load in Newtons, and $N_{\\mathrm{steps}}$ is the integer number of converged arc-length steps taken. If no fold is detected, output $\\lambda_{\\mathrm{fold}}=-1.0$ and $w_{\\mathrm{fold}}=-1.0$.\n- Your program should produce a single line of output containing the results as a comma-separated list of the case results enclosed in square brackets, for example: \"[[case1_result_list],[case2_result_list],[case3_result_list]]\".\n\nTest suite:\nUse the following parameter values, with all lengths in meters, all forces in Newtons, and angles in radians.\n- Case $1$ (happy-path shallow configuration with snap-through): $a=1.0$, $h_0=0.05$, $EA=1.0\\times 10^{5}$, $\\Delta s=0.003$, $N_{\\max}=120$, $\\varepsilon_r=1.0\\times 10^{-8}$, $\\varepsilon_g=1.0\\times 10^{-12}$, and minimum step $\\Delta s_{\\min}=1.0\\times 10^{-5}$.\n- Case $2$ (higher rise, no snap-through expected within the step budget): $a=1.0$, $h_0=0.5$, $EA=1.0\\times 10^{5}$, $\\Delta s=0.010$, $N_{\\max}=60$, $\\varepsilon_r=1.0\\times 10^{-8}$, $\\varepsilon_g=1.0\\times 10^{-12}$, and minimum step $\\Delta s_{\\min}=1.0\\times 10^{-5}$.\n- Case $3$ (very shallow, stronger snap-through, smaller arc-length): $a=1.0$, $h_0=0.02$, $EA=1.0\\times 10^{5}$, $\\Delta s=0.002$, $N_{\\max}=150$, $\\varepsilon_r=1.0\\times 10^{-8}$, $\\varepsilon_g=1.0\\times 10^{-12}$, and minimum step $\\Delta s_{\\min}=1.0\\times 10^{-5}$.\n\nFinal answer specification:\n- Implement the complete solver as a standalone program that takes no input and prints exactly one line: a list of the three case results in the format described above. All computations must adhere to the units and definitions given. No external data or user interaction is permitted.", "solution": "The problem presented requires the derivation and implementation of a numerical path-following algorithm, specifically the arc-length method, to trace the nonlinear equilibrium path of a two-bar truss. The analysis must be conducted from first principles. The problem is scientifically sound, well-posed, and contains all necessary information for a complete solution. We proceed with the derivation and subsequent implementation.\n\nThe system consists of two identical bars of axial rigidity $EA$ and initial length $L_0 = \\sqrt{a^2 + h_0^2}$. The bars connect supports at $(\\pm a, 0)$ to an apex joint initially at $(0, h_0)$. The apex is constrained to move vertically, with downward displacement denoted by $w$. An external downward load $\\lambda$ is applied at the apex.\n\nFirst, we establish the fundamental equations of state for the structure, namely the internal force and tangent stiffness, as a function of the generalized displacement $w$.\n\nThe length of each bar in the deformed configuration, $L(w)$, is given by the geometry of the system:\n$$L(w) = \\sqrt{a^2 + (h_0 - w)^2}$$\nThe problem defines the axial strain energy in a single bar, $U_b$, based on a linear elastic material model as:\n$$U_b = \\frac{EA}{2L_0} (L(w) - L_0)^2$$\nThe total internal strain energy of the two-bar system, $U_{\\text{total}}$, is the sum of the energies in each bar:\n$$U_{\\text{total}}(w) = 2 U_b = \\frac{EA}{L_0} (L(w) - L_0)^2$$\nThe problem states that the internal generalized force, $f_{\\text{int}}(w)$, conjugate to the displacement $w$, is the derivative of the total strain energy with respect to $w$. This is a direct application of the principle of virtual work.\n$$f_{\\text{int}}(w) = \\frac{dU_{\\text{total}}}{dw}$$\nApplying the chain rule, we find:\n$$f_{\\text{int}}(w) = \\frac{EA}{L_0} \\cdot 2(L(w) - L_0) \\cdot \\frac{dL(w)}{dw}$$\nThe derivative of the bar length with respect to the displacement $w$ is:\n$$\\frac{dL(w)}{dw} = \\frac{d}{dw}\\left(a^2 + (h_0 - w)^2\\right)^{1/2} = \\frac{1}{2L(w)} \\cdot 2(h_0 - w) \\cdot (-1) = \\frac{w - h_0}{L(w)}$$\nSubstituting this into the expression for $f_{\\text{int}}(w)$ yields the internal force:\n$$f_{\\text{int}}(w) = \\frac{2EA}{L_0} (L(w) - L_0) \\frac{w - h_0}{L(w)} = 2EA \\left(1 - \\frac{L_0}{L(w)}\\right) \\frac{w - h_0}{L_0}$$\nEquilibrium requires that the internal force balances the external load, $\\lambda$. This gives the residual equation $r(w, \\lambda) = 0$:\n$$r(w, \\lambda) = f_{\\text{int}}(w) - \\lambda = 0$$\nThe stability of the equilibrium path is determined by the tangent stiffness, $K_t(w)$, which is the derivative of the internal force with respect to displacement:\n$$K_t(w) = \\frac{df_{\\text{int}}}{dw} = \\frac{d}{dw} \\left[ \\frac{2EA}{L_0} \\left( (w - h_0) - L_0 \\frac{w - h_0}{L(w)} \\right) \\right]$$\n$$K_t(w) = \\frac{2EA}{L_0} \\left[ 1 - L_0 \\frac{d}{dw}\\left(\\frac{w - h_0}{L(w)}\\right) \\right]$$\nUsing the quotient rule, the derivative of the geometric term is:\n$$\\frac{d}{dw}\\left(\\frac{w - h_0}{L(w)}\\right) = \\frac{1 \\cdot L(w) - (w - h_0) \\frac{dL}{dw}}{L(w)^2} = \\frac{L(w) - (w-h_0)\\frac{w-h_0}{L(w)}}{L(w)^2} = \\frac{L(w)^2 - (w-h_0)^2}{L(w)^3}$$\nSince $L(w)^2 = a^2 + (h_0 - w)^2 = a^2 + (w-h_0)^2$, the numerator simplifies to $a^2$. Therefore:\n$$\\frac{d}{dw}\\left(\\frac{w - h_0}{L(w)}\\right) = \\frac{a^2}{L(w)^3}$$\nSubstituting this back, we obtain the final expression for the tangent stiffness:\n$$K_t(w) = \\frac{2EA}{L_0} \\left( 1 - \\frac{L_0 a^2}{L(w)^3} \\right)$$\nA limit point, or fold, occurs when the tangent stiffness vanishes, $K_t(w) = 0$, indicating a loss of stability and a maximum or minimum on the load-displacement curve.\n\nTo trace the equilibrium path through such limit points, standard load-controlled methods fail. We employ the arc-length method, which augments the equilibrium equation with a constraint on the step length in the state space $(w, \\lambda)$. The system of equations to be solved at each step is:\n$$ \\mathbf{F}(w, \\lambda) = \\begin{Bmatrix} r(w, \\lambda) \\\\ g(w, \\lambda) \\end{Bmatrix} = \\begin{Bmatrix} f_{\\text{int}}(w) - \\lambda \\\\ (w-w_n)^2 + \\alpha(\\lambda-\\lambda_n)^2 - \\Delta s^2 \\end{Bmatrix} = \\begin{Bmatrix} 0 \\\\ 0 \\end{Bmatrix} $$\nHere, $(w_n, \\lambda_n)$ is the previously converged equilibrium point, $\\Delta s$ is the prescribed arc-length radius, and $\\alpha$ is a scaling parameter to reconcile the different physical units of displacement and load. As specified, we use $\\alpha = (K_t(0))^{-2}$, where $K_t(0) = 2EA h_0^2 / L_0^3$ is the initial stiffness.\n\nThe solution process is a predictor-corrector scheme.\nFirst, a predictor step is taken along the tangent to the equilibrium path at $(w_n, \\lambda_n)$. The tangent direction $(\\Delta w_p, \\Delta \\lambda_p)$ satisfies $d r = K_t(w_n) dw - d\\lambda = 0$, so $\\Delta \\lambda_p = K_t(w_n) \\Delta w_p$. This direction is scaled to satisfy the arc-length constraint:\n$$ (\\Delta w_p)^2 + \\alpha (\\Delta \\lambda_p)^2 = \\Delta s^2 \\implies \\Delta w_p^2 (1 + \\alpha K_t(w_n)^2) = \\Delta s^2$$\nSolving for the predictor increments:\n$$ \\Delta w_p = \\beta, \\quad \\Delta \\lambda_p = \\beta K_t(w_n), \\quad \\text{where} \\quad \\beta = \\pm \\frac{\\Delta s}{\\sqrt{1 + \\alpha K_t(w_n)^2}} $$\nThe sign of $\\beta$ is chosen to maintain a consistent direction of traversal along the path, ensuring that the scaled dot product of the current step vector and the previous step vector is non-negative. The predictor point is $(w_n + \\Delta w_p, \\lambda_n + \\Delta \\lambda_p)$.\n\nSecond, starting from the predictor point, a corrector phase uses Newton's method to find a point that satisfies the augmented system $\\mathbf{F}(w, \\lambda) = \\mathbf{0}$. At each Newton iteration $k$, we solve the linear system for the corrections $(\\delta w, \\delta \\lambda)$:\n$$ \\mathbf{J}(w^{(k)}, \\lambda^{(k)}) \\begin{Bmatrix} \\delta w \\\\ \\delta \\lambda \\end{Bmatrix} = - \\mathbf{F}(w^{(k)}, \\lambda^{(k)}) $$\nThe Jacobian matrix $\\mathbf{J}$ is:\n$$ \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial r}{\\partial w} & \\frac{\\partial r}{\\partial \\lambda} \\\\ \\frac{\\partial g}{\\partial w} & \\frac{\\partial g}{\\partial \\lambda} \\end{bmatrix} = \\begin{bmatrix} K_t(w^{(k)}) & -1 \\\\ 2(w^{(k)} - w_n) & 2\\alpha(\\lambda^{(k)} - \\lambda_n) \\end{bmatrix} $$\nThe iterations $w^{(k+1)} = w^{(k)} + \\delta w$, $\\lambda^{(k+1)} = \\lambda^{(k)} + \\delta \\lambda$ continue until the residuals $|r|$ and $|g|$ are below their respective tolerances, $\\varepsilon_r$ and $\\varepsilon_g$.\n\nThe first limit point is detected by monitoring the sign of $K_t(w)$. A change in sign between two consecutive converged points $(w_n, \\lambda_n)$ and $(w_{n+1}, \\lambda_{n+1})$ indicates that a fold has been passed. The location of the fold $(w_{\\text{fold}}, \\lambda_{\\text{fold}})$ is then precisely determined by finding the root $w_{\\text{fold}}$ of the equation $K_t(w) = 0$ within the interval $[w_n, w_{n+1}]$ using a bisection algorithm. The corresponding load is $\\lambda_{\\text{fold}} = f_{\\text{int}}(w_{\\text{fold}})$. The algorithm incorporates backtracking by halving the arc-length $\\Delta s$ if a step fails to converge, providing robustness.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the two-bar truss problem.\n    \"\"\"\n\n    class TwoBarTruss:\n        \"\"\"Encapsulates the physics of the two-bar truss.\"\"\"\n        def __init__(self, a, h0, EA):\n            if not (a > 0 and h0 >= 0 and EA > 0):\n                raise ValueError(\"Physical parameters a, h0, EA must be positive.\")\n            self.a = float(a)\n            self.h0 = float(h0)\n            self.EA = float(EA)\n            # Undeformed length of each bar\n            self.L0 = np.sqrt(self.a**2 + self.h0**2)\n\n        def get_current_length(self, w):\n            \"\"\"Computes the length of a bar for a given vertical displacement w.\"\"\"\n            return np.sqrt(self.a**2 + (self.h0 - w)**2)\n\n        def get_internal_force(self, w):\n            \"\"\"Computes the internal force f_int(w).\"\"\"\n            if self.L0 == 0: return 0.0 # Should not happen with valid h0>0 or a>0\n            L_w = self.get_current_length(w)\n            if L_w < 1e-12:  # Avoid division by zero\n                # Physically, w cannot reach h0 +/- sqrt(L0^2-a^2) = 2h0 or 0\n                # if the bar is to have non-zero length, unless a=0.\n                # However, for robustness we check.\n                if np.isclose(w, self.h0) and self.a == 0:\n                  return 0.0 # special case of vertical bars\n                return np.inf\n            \n            # Per derivation: f_int = 2*EA*(1 - L0/L(w))*(w-h0)/L0\n            return 2.0 * self.EA * (1.0 - self.L0 / L_w) * (w - self.h0) / self.L0\n\n        def get_tangent_stiffness(self, w):\n            \"\"\"Computes the tangent stiffness K_t(w).\"\"\"\n            if self.L0 == 0: return np.inf\n            L_w = self.get_current_length(w)\n            if L_w < 1e-12:\n                return np.inf\n\n            # Per derivation: K_t = (2*EA/L0) * (1 - L0*a^2 / L(w)^3)\n            return (2.0 * self.EA / self.L0) * (1.0 - self.L0 * self.a**2 / L_w**3)\n\n    def run_arc_length_analysis(params):\n        \"\"\"\n        Performs the arc-length analysis for a single set of parameters.\n        \"\"\"\n        a, h0, EA, ds_initial, N_max, tol_r, tol_g, ds_min = params\n        newton_max_iter = 15\n        \n        truss = TwoBarTruss(a, h0, EA)\n\n        # Initialization\n        w_n, lambda_n = 0.0, 0.0\n        path_history = [(w_n, lambda_n)]\n        \n        # Store increments for direction control\n        dw_prev, dlambda_prev = 0.0, 0.0\n        \n        # Initial stiffness and scaling parameter alpha\n        K0 = truss.get_tangent_stiffness(0.0)\n        if K0 <= 0: # Initial state must be stable\n            return [-1.0, -1.0, False, lambda_n, 0]\n        alpha = (1.0 / K0)**2\n\n        # Fold tracking\n        fold_found, passed_fold = False, False\n        w_fold, lambda_fold = -1.0, -1.0\n        kt_prev = K0\n        \n        num_converged_steps = 0\n        for _ in range(N_max):\n            ds = ds_initial\n            step_converged_with_backtracking = False\n\n            while ds >= ds_min:\n                # Predictor phase\n                K_tn = truss.get_tangent_stiffness(w_n)\n                \n                # Determine sign of predictor step\n                if num_converged_steps == 0:\n                    sign = 1.0 # Start with increasing load\n                else:\n                    # dot product in scaled metric\n                    dot = dw_prev + alpha * K_tn * dlambda_prev\n                    sign = np.sign(dot) if dot != 0 else 1.0\n\n                beta = sign * ds / np.sqrt(1.0 + alpha * K_tn**2)\n                dw_p = beta\n                dlambda_p = beta * K_tn\n                \n                w_k, lambda_k = w_n + dw_p, lambda_n + dlambda_p\n\n                # Corrector phase (Newton-Raphson)\n                converged = False\n                for _ in range(newton_max_iter):\n                    f_int_k = truss.get_internal_force(w_k)\n                    r_k = f_int_k - lambda_k\n                    g_k = (w_k - w_n)**2 + alpha * (lambda_k - lambda_n)**2 - ds**2\n\n                    if abs(r_k) < tol_r and abs(g_k) < tol_g:\n                        converged = True\n                        break\n\n                    K_t_k = truss.get_tangent_stiffness(w_k)\n                    \n                    # Jacobian of the augmented system\n                    J11 = K_t_k\n                    J12 = -1.0\n                    J21 = 2.0 * (w_k - w_n)\n                    J22 = 2.0 * alpha * (lambda_k - lambda_n)\n                    \n                    detJ = J11 * J22 - J12 * J21\n                    if abs(detJ) < 1e-12:\n                        converged = False # Jacobian is singular\n                        break\n                    \n                    # Solve 2x2 system for corrections\n                    delta_w = (-J22 * r_k + J12 * g_k) / detJ\n                    delta_lambda = (J21 * r_k - J11 * g_k) / detJ\n\n                    w_k += delta_w\n                    lambda_k += delta_lambda\n                \n                if converged:\n                    w_next, lambda_next = w_k, lambda_k\n                    path_history.append((w_next, lambda_next))\n                    \n                    dw_prev = w_next - w_n\n                    dlambda_prev = lambda_next - lambda_n\n                    w_n, lambda_n = w_next, lambda_next # Update for next step\n                    \n                    num_converged_steps += 1\n\n                    # Check for fold crossing\n                    kt_next = truss.get_tangent_stiffness(w_n)\n                    if not fold_found and kt_prev * kt_next < 0:\n                        fold_found = True\n                        passed_fold = True\n                        # Bisection to find w_fold where K_t(w) = 0\n                        w_fold = bisect(truss.get_tangent_stiffness, path_history[-2][0], w_n, xtol=1e-12)\n                        lambda_fold = truss.get_internal_force(w_fold)\n                    \n                    kt_prev = kt_next\n                    step_converged_with_backtracking = True\n                    break # Exit backtracking loop\n                else:\n                    ds /= 2.0 # Halve step size and retry\n\n            if not step_converged_with_backtracking:\n                break # Abort if step fails to converge even with min step size\n\n        return [lambda_fold, w_fold, passed_fold, lambda_n, num_converged_steps]\n\n    test_cases = [\n        # Case 1: a, h0, EA, ds, N_max, tol_r, tol_g, ds_min\n        (1.0, 0.05, 1.0e5, 0.003, 120, 1.0e-8, 1.0e-12, 1.0e-5),\n        # Case 2\n        (1.0, 0.5, 1.0e5, 0.010, 60, 1.0e-8, 1.0e-12, 1.0e-5),\n        # Case 3\n        (1.0, 0.02, 1.0e5, 0.002, 150, 1.0e-8, 1.0e-12, 1.0e-5),\n    ]\n\n    results = []\n    for params in test_cases:\n        case_result = run_arc_length_analysis(params)\n        results.append(case_result)\n\n    # Format output as a string representation of a list of lists\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2618840"}]}