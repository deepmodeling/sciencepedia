{"hands_on_practices": [{"introduction": "The reliability of any numerical approximation scheme rests on its ability to exactly represent simple, fundamental solutions. For meshless methods built upon polynomial bases, this core requirement is known as the 'reproduction property.' This practice provides a hands-on coding task to numerically verify that a Moving Least Squares (MLS) approximation using a linear basis can perfectly replicate an arbitrary linear field in two dimensions, a cornerstone for ensuring the method's convergence and accuracy [@problem_id:2662008].", "problem": "You are asked to verify, through a fully reproducible numerical experiment, the linear reproduction property of Moving Least Squares (MLS) meshless shape functions in two dimensions. Consider a set of nodes $\\{\\mathbf{x}_I\\}_{I=1}^N \\subset \\mathbb{R}^2$ and a weight function $w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h)$ with smoothing length $h>0$. Use a linear polynomial basis $p(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$. The MLS shape functions $\\{\\phi_I(\\mathbf{x})\\}_{I=1}^N$ are defined such that the MLS approximant of a scalar field $u(\\mathbf{x})$ is $\\widehat{u}(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x}) u_I$, where $u_I = u(\\mathbf{x}_I)$. The linear reproduction property states that, if $u(\\mathbf{x})$ is any linear function $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x}$ with $a \\in \\mathbb{R}$ and $\\mathbf{b} \\in \\mathbb{R}^2$, then $\\widehat{u}(\\mathbf{x}) = u(\\mathbf{x})$ for all $\\mathbf{x}$ where the moment matrix is invertible.\n\nYour program must implement the MLS shape functions with the Gaussian weight\n$$\nw(r;h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right),\n$$\nwhere $r=\\|\\mathbf{x}-\\mathbf{x}_I\\|_2$ and $h>0$ is the smoothing length. Let $P \\in \\mathbb{R}^{N\\times 3}$ be the matrix with rows $p(\\mathbf{x}_I)^{\\mathsf{T}}$, and $W(\\mathbf{x}) \\in \\mathbb{R}^{N\\times N}$ be the diagonal matrix with entries $w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h)$. Define the moment matrix $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P \\in \\mathbb{R}^{3\\times 3}$. The MLS shape function row vector at $\\mathbf{x}$ is\n$$\n\\boldsymbol{\\phi}(\\mathbf{x})^{\\mathsf{T}} = G(\\mathbf{x})^{\\mathsf{T}} p(\\mathbf{x}), \\quad \\text{where } G(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) \\in \\mathbb{R}^{3\\times N}.\n$$\nEquivalently, for each node $I$, the scalar shape function is $\\phi_I(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} A(\\mathbf{x})^{-1} w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h) p(\\mathbf{x}_I)$.\n\nWrite a program that, for specified node sets, smoothing lengths, and test points, evaluates the two sums\n$$\nS_0(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x})\\, a,\\qquad S_1(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x})\\, \\mathbf{b}\\cdot \\mathbf{x}_I,\n$$\nand compares $S_0(\\mathbf{x}) + S_1(\\mathbf{x})$ against the exact linear value $a + \\mathbf{b}\\cdot \\mathbf{x}$. For each test, report whether the maximum absolute error over the specified set of evaluation points is below a tolerance $\\varepsilon=10^{-10}$.\n\nImplement the following four tests. All coordinates are in $\\mathbb{R}$ and dimensionless, so no physical units are required. Angles do not appear. The program must be deterministic; use the provided random seeds.\n\n- Test $1$ (regular grid, moderate smoothing, interior points):\n  - Nodes: a regular $5\\times 5$ tensor grid on $[0,1]\\times[0,1]$, i.e., $\\mathbf{x}_{i,j} = \\left(\\frac{i}{4}, \\frac{j}{4}\\right)$ for $i,j\\in\\{0,1,2,3,4\\}$, so $N=25$.\n  - Smoothing length: $h=0.30$.\n  - Linear function parameters: $a=1.2345$, $\\mathbf{b} = (-0.5, 2.2)$.\n  - Evaluation points: $M=200$ points uniformly random in $[0,1]^2$, generated with seed $11$.\n  - Output: a boolean indicating whether $\\max_{\\mathbf{x}} |(S_0(\\mathbf{x})+S_1(\\mathbf{x}))-(a+\\mathbf{b}\\cdot \\mathbf{x})| \\le \\varepsilon$.\n\n- Test $2$ (regular grid, small smoothing, interior points):\n  - Nodes: same $5\\times 5$ grid as Test $1$.\n  - Smoothing length: $h=0.12$.\n  - Linear function parameters: $a=-0.9$, $\\mathbf{b}=(2.0, 1.5)$.\n  - Evaluation points: $M=200$ points uniformly random in $[0,1]^2$, generated with seed $22$.\n  - Output: a boolean as in Test $1$.\n\n- Test $3$ (jittered grid, moderate smoothing, interior points):\n  - Nodes: start from a $6\\times 6$ grid $\\mathbf{x}_{i,j}=\\left(\\frac{i}{5},\\frac{j}{5}\\right)$ for $i,j\\in\\{0,1,2,3,4,5\\}$, then add independent uniform jitter in $[-0.04,0.04]$ to each coordinate; clip to $[0,1]$. Use jitter seed $333$.\n  - Smoothing length: $h=0.25$.\n  - Linear function parameters: $a=0.0$, $\\mathbf{b}=(1.0, -1.0)$.\n  - Evaluation points: $M=400$ points uniformly random in $[0,1]^2$, generated with seed $33$.\n  - Output: a boolean as in Test $1$.\n\n- Test $4$ (regular grid, boundary-focused points):\n  - Nodes: same $5\\times 5$ grid as Test $1$.\n  - Smoothing length: $h=0.20$.\n  - Linear function parameters: $a=0.3$, $\\mathbf{b}=(0.2, -0.4)$.\n  - Evaluation points: the nine points $\\{(0,0),(1,0),(0,1),(1,1),(0.5,0),(0.5,1),(0,0.5),(1,0.5),(0.5,0.5)\\}$.\n  - Output: a boolean as in Test $1$.\n\nYour program should produce a single line of output containing the four boolean results as a comma-separated list enclosed in square brackets (e.g., \"[True,True,True,True]\"). The booleans must appear in the order of Tests $1$ through $4$ exactly, and each boolean must be computed by comparing the maximum absolute error against $\\varepsilon=10^{-10}$ for that test.", "solution": "The problem statement is parsed and validated.\n\n**1. Givens Extraction**\n\n- **Method**: Moving Least Squares (MLS) in two dimensions, $\\mathbb{R}^2$.\n- **Property to Verify**: Linear reproduction for an approximant $\\widehat{u}(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x}) u_I$ of a linear scalar field $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x}$.\n- **Nodes**: A set of $N$ points $\\{\\mathbf{x}_I\\}_{I=1}^N \\subset \\mathbb{R}^2$.\n- **Basis**: Linear polynomial basis $p(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$.\n- **Weight Function**: Gaussian, $w(r;h) = \\exp(-(r/h)^2)$, where $r=\\|\\mathbf{x}-\\mathbf{x}_I\\|_2$ and $h$ is the smoothing length.\n- **Moment Matrix**: $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P$, where $P$ is the $N\\times 3$ matrix of basis functions evaluated at nodes, and $W(\\mathbf{x})$ is the $N\\times N$ diagonal matrix of weights.\n- **Shape Functions**: The vector of shape functions is $\\boldsymbol{\\phi}(\\mathbf{x})^{\\mathsf{T}} = p(\\mathbf{x})^{\\mathsf{T}} A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x})$.\n- **Verification Task**: For four specified tests, calculate the maximum absolute error $|\\left(\\sum_I \\phi_I(\\mathbf{x}) u_I\\right) - u(\\mathbf{x})|$ over a set of evaluation points and determine if this maximum error is less than or equal to a tolerance $\\varepsilon=10^{-10}$.\n- **Test $1$**: $5\\times 5$ regular grid, $h=0.30$, $a=1.2345$, $\\mathbf{b} = (-0.5, 2.2)$, $200$ random evaluation points (seed $11$).\n- **Test $2$**: $5\\times 5$ regular grid, $h=0.12$, $a=-0.9$, $\\mathbf{b}=(2.0, 1.5)$, $200$ random evaluation points (seed $22$).\n- **Test $3$**: $6\\times 6$ jittered grid (seed $333$), $h=0.25$, $a=0.0$, $\\mathbf{b}=(1.0, -1.0)$, $400$ random evaluation points (seed $33$).\n- **Test $4$**: $5\\times 5$ regular grid, $h=0.20$, $a=0.3$, $\\mathbf{b}=(0.2, -0.4)$, $9$ specific boundary and interior evaluation points.\n\n**2. Validation**\n\nThe problem statement is scientifically sound and computationally verifiable. It describes a standard numerical experiment in the field of computational mechanics to validate a correct implementation of the Moving Least Squares method. All definitions and formulas are standard and correct. All test cases are well-defined with all necessary parameters, data, and random seeds for reproducibility. The problem is self-contained, consistent, and free of any logical or scientific flaws.\n\n**3. Verdict**\n\nThe problem is **valid**. I will proceed with a complete solution.\n\n**Solution Derivation**\n\nThe objective is to numerically verify the linear reproduction property of Moving Least Squares (MLS) shape functions. This property dictates that if the function being approximated, $u(\\mathbf{x})$, is a member of the polynomial basis used to construct the approximation, the MLS approximant $\\widehat{u}(\\mathbf{x})$ must be identical to $u(\\mathbf{x})$.\n\nThe MLS approximation $\\widehat{u}(\\mathbf{x})$ is constructed as $\\widehat{u}(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x})$, where $p(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$ is the linear basis and $\\boldsymbol{\\alpha}(\\mathbf{x})$ is a vector of coefficients determined by minimizing a weighted least-squares functional. This minimization leads to the expression $\\boldsymbol{\\alpha}(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) \\mathbf{u}$, where $\\mathbf{u}$ is the vector of nodal values $u_I = u(\\mathbf{x}_I)$.\n\nLet us consider a general linear function, $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x} = a + b_x x + b_y y$. This function is an element of the space spanned by the basis $p(\\mathbf{x})$. We can write it as $u(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{c}$, where the coefficient vector is $\\boldsymbol{c} = [a, b_x, b_y]^{\\mathsf{T}}$. The value of this function at node $I$ is $u_I = u(\\mathbf{x}_I) = p(\\mathbf{x}_I)^{\\mathsf{T}} \\boldsymbol{c}$. The vector of all nodal values is thus $\\mathbf{u} = P\\boldsymbol{c}$.\n\nSubstituting this expression for $\\mathbf{u}$ into the formula for $\\boldsymbol{\\alpha}(\\mathbf{x})$ yields:\n$$\n\\boldsymbol{\\alpha}(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) (P\\boldsymbol{c})\n$$\nBy definition, the moment matrix is $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P$. Substituting this into the equation gives:\n$$\n\\boldsymbol{\\alpha}(\\mathbf{x}) = (P^{\\mathsf{T}} W(\\mathbf{x}) P)^{-1} (P^{\\mathsf{T}} W(\\mathbf{x}) P) \\boldsymbol{c} = A(\\mathbf{x})^{-1} A(\\mathbf{x}) \\boldsymbol{c} = \\boldsymbol{c}\n$$\nThis holds if and only if the moment matrix $A(\\mathbf{x})$ is invertible. The result shows that the coefficient vector $\\boldsymbol{\\alpha}(\\mathbf{x})$ is constant and equal to $\\boldsymbol{c}$. The MLS approximant is then:\n$$\n\\widehat{u}(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{c} = u(\\mathbf{x})\n$$\nThis confirms theoretically that $\\widehat{u}(\\mathbf{x}) = u(\\mathbf{x})$. The numerical experiment must verify that the computational error $|\\widehat{u}(\\mathbf{x}) - u(\\mathbf{x})|$ is on the order of machine precision, here bounded by the tolerance $\\varepsilon = 10^{-10}$.\n\nThe numerical implementation will proceed as follows for each test case.\nFirst, the required node set $\\{\\mathbf{x}_I\\}$, evaluation point set $\\{\\mathbf{x}_{\\text{eval}}\\}$, smoothing length $h$, and linear function parameters $a$ and $\\mathbf{b}$ are generated. The constant $N \\times 3$ matrix $P$ is constructed, with row $I$ being $[1, x_I, y_I]$. The vector of nodal values $\\mathbf{u}$ is computed, with entry $I$ being $u_I = a + \\mathbf{b}\\cdot\\mathbf{x}_I$.\n\nThen, for each evaluation point $\\mathbf{x}_{\\text{eval}}$:\n$1$. The distances $r_I = \\|\\mathbf{x}_{\\text{eval}} - \\mathbf{x}_I\\|$ are computed for all nodes $I=1, \\dots, N$.\n$2$. The corresponding weights $w_I = \\exp(-(r_I/h)^2)$ are calculated. These form the diagonal of the matrix $W(\\mathbf{x}_{\\text{eval}})$.\n$3$. The $3\\times 3$ moment matrix $A(\\mathbf{x}_{\\text{eval}}) = P^{\\mathsf{T}} W(\\mathbf{x}_{\\text{eval}}) P$ is assembled. This is efficiently computed as $\\sum_{I=1}^N w_I p(\\mathbf{x}_I) p(\\mathbf{x}_I)^{\\mathsf{T}}$.\n$4$. The coefficient vector $\\boldsymbol{\\alpha}(\\mathbf{x}_{\\text{eval}})$ is computed by solving the linear system $A(\\mathbf{x}_{\\text{eval}}) \\boldsymbol{\\alpha} = P^{\\mathsf{T}} W(\\mathbf{x}_{\\text{eval}}) \\mathbf{u}$. This is equivalent to calculating $\\boldsymbol{\\alpha} = A(\\mathbf{x}_{\\text{eval}})^{-1} (P^{\\mathsf{T}} (W(\\mathbf{x}_{\\text{eval}})\\mathbf{u}))$.\n$5$. The MLS approximant is calculated as $\\widehat{u}(\\mathbf{x}_{\\text{eval}}) = p(\\mathbf{x}_{\\text{eval}})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x}_{\\text{eval}})$.\n$6$. The exact value $u(\\mathbf{x}_{\\text{eval}}) = a + \\mathbf{b}\\cdot\\mathbf{x}_{\\text{eval}}$ is determined.\n$7$. The absolute error $|\\widehat{u}(\\mathbf{x}_{\\text{eval}}) - u(\\mathbf{x}_{\\text{eval}})|$ is computed.\n\nAfter iterating through all evaluation points, the maximum absolute error is found and compared against the tolerance $\\varepsilon=10^{-10}$. The boolean result of this comparison is reported for each of the four tests.", "answer": "```python\nimport numpy as np\n\ndef run_mls_reproduction_test(nodes, h, a, b_vec, eval_points, tol):\n    \"\"\"\n    Performs a numerical test of the MLS linear reproduction property.\n\n    Args:\n        nodes (np.ndarray): N-by-2 array of node coordinates.\n        h (float): Smoothing length for the Gaussian weight function.\n        a (float): Constant term of the linear function u(x) = a + b.x.\n        b_vec (np.ndarray): 2-element array for the linear term of u(x).\n        eval_points (np.ndarray): M-by-2 array of evaluation point coordinates.\n        tol (float): Error tolerance for the verification.\n\n    Returns:\n        bool: True if the max absolute error is within the tolerance, False otherwise.\n    \"\"\"\n    N = nodes.shape[0]\n\n    # Construct the P matrix (N x 3) where row I is [1, x_I, y_I]\n    P = np.hstack([np.ones((N, 1)), nodes])\n\n    # Pre-compute nodal values of the linear function u_I = a + b . x_I\n    u_nodes = a + nodes @ b_vec\n\n    max_error = 0.0\n\n    for x_eval in eval_points:\n        # Calculate distances from the evaluation point to all nodes\n        dists = np.linalg.norm(x_eval - nodes, axis=1)\n        \n        # Calculate Gaussian weights\n        weights = np.exp(-(dists / h)**2)\n\n        # Assemble the moment matrix A(x) = P^T W(x) P\n        # W is a diagonal matrix, so W*P is equivalent to scaling rows of P by weights.\n        # A more efficient way is P.T @ (weights_as_column * P)\n        A = P.T @ (weights[:, np.newaxis] * P)\n\n        # The problem setup ensures A is invertible. For robustness, one\n        # might check the determinant or condition number.\n        # If det(A) is close to zero, numerical issues may arise.\n        if np.linalg.det(A) < 1e-30:\n            # This indicates a potential singularity; the reproduction would fail.\n            # We set a large error to ensure the test fails.\n            max_error = np.inf\n            break\n            \n        # Invert the moment matrix\n        A_inv = np.linalg.inv(A)\n\n        # Calculate the coefficient vector alpha(x) = A(x)^-1 * P^T * W(x) * u\n        # The term W(x) * u is an element-wise product of weights and nodal values\n        pT_W_u = P.T @ (weights * u_nodes)\n        alpha = A_inv @ pT_W_u\n\n        # Calculate the MLS approximation at x_eval\n        # p_eval is the basis vector [1, x, y] at the evaluation point\n        p_eval = np.array([1.0, x_eval[0], x_eval[1]])\n        u_hat = p_eval @ alpha\n\n        # Calculate the exact value of the linear function\n        u_exact = a + x_eval @ b_vec\n\n        # Compute the absolute error and update the maximum\n        error = np.abs(u_hat - u_exact)\n        if error > max_error:\n            max_error = error\n\n    return max_error <= tol\n\ndef solve():\n    \"\"\"\n    Sets up and runs the four test cases specified in the problem,\n    and prints the results in the required format.\n    \"\"\"\n    TOLERANCE = 1e-10\n\n    # --- Test Case Data Generation ---\n\n    # Nodes for Tests 1, 2, 4: Regular 5x5 grid\n    grid_pts_5x5 = np.linspace(0.0, 1.0, 5)\n    X5, Y5 = np.meshgrid(grid_pts_5x5, grid_pts_5x5)\n    nodes_5x5 = np.vstack([X5.ravel(), Y5.ravel()]).T\n\n    # Nodes for Test 3: Jittered 6x6 grid\n    grid_pts_6x6 = np.linspace(0.0, 1.0, 6)\n    X6, Y6 = np.meshgrid(grid_pts_6x6, grid_pts_6x6)\n    nodes_6x6_base = np.vstack([X6.ravel(), Y6.ravel()]).T\n    rng_jitter = np.random.default_rng(333)\n    jitter = rng_jitter.uniform(-0.04, 0.04, size=nodes_6x6_base.shape)\n    nodes_6x6_jittered = np.clip(nodes_6x6_base + jitter, 0.0, 1.0)\n    \n    # Evaluation points for Test 4\n    eval_pts_test4 = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0],\n        [0.5, 0.0], [0.5, 1.0], [0.0, 0.5], [1.0, 0.5],\n        [0.5, 0.5]\n    ])\n\n    test_cases_params = [\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.30,\n            \"a\": 1.2345,\n            \"b\": np.array([-0.5, 2.2]),\n            \"eval_points\": np.random.default_rng(11).uniform(0.0, 1.0, size=(200, 2))\n        },\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.12,\n            \"a\": -0.9,\n            \"b\": np.array([2.0, 1.5]),\n            \"eval_points\": np.random.default_rng(22).uniform(0.0, 1.0, size=(200, 2))\n        },\n        {\n            \"nodes\": nodes_6x6_jittered,\n            \"h\": 0.25,\n            \"a\": 0.0,\n            \"b\": np.array([1.0, -1.0]),\n            \"eval_points\": np.random.default_rng(33).uniform(0.0, 1.0, size=(400, 2))\n        },\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.20,\n            \"a\": 0.3,\n            \"b\": np.array([0.2, -0.4]),\n            \"eval_points\": eval_pts_test4\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result = run_mls_reproduction_test(\n            params[\"nodes\"],\n            params[\"h\"],\n            params[\"a\"],\n            params[\"b\"],\n            params[\"eval_points\"],\n            TOLERANCE\n        )\n        results.append(result)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "2662008"}, {"introduction": "To demystify a new numerical method, it is often insightful to compare it with a well-established one. This practice delves into the fundamental connection between the Element-Free Galerkin (EFG) method and the ubiquitous Finite Element Method (FEM). By analytically deriving the stiffness matrix for a simple 1D bar under specific assumptions about the basis, weight function support, and numerical integration, you will uncover the conditions under which the two methods become identical, providing a deeper appreciation for EFG as a powerful generalization of FEM [@problem_id:2662032].", "problem": "Consider a one-dimensional elastic bar of length $L$ and constant cross-sectional area $A$, with uniform Young's modulus $E$. The domain is $\\Omega = [0,L]$. The bar is discretized by $n+1$ uniformly spaced nodes $\\{x_{i}\\}_{i=0}^{n}$ with $x_{i} = i\\,h$ and $h = L/n$. Assume essential boundary condition $u(0)=0$ and a prescribed traction $t=L$ at $x=L$; body forces are absent.\n\nUse a meshless Galerkin formulation based on moving least squares (MLS) shape functions built from a linear basis $\\{1, x\\}$ and a symmetric compactly supported weight function whose support radius equals the nodal spacing $h$, so that for any $x \\in (x_{i},x_{i+1})$ only nodes $i$ and $i+1$ have nonzero weight. For numerical integration, employ a background partition of $\\Omega$ into the $n$ subcells $[x_{i},x_{i+1}]$ and use one-point Gaussian quadrature per subcell.\n\nStarting from the principle of virtual work and the definition of MLS approximation spaces, perform the following:\n\n1. Derive the discrete equilibrium equations in the form $\\mathbf{K}_{\\mathrm{ml}} \\mathbf{u} = \\mathbf{f}$, identifying the expression for the entries $K_{\\mathrm{ml},ab}$ obtained by background Gaussian quadrature.\n\n2. Compute the $2 \\times 2$ contribution to $\\mathbf{K}_{\\mathrm{ml}}$ from a single subcell $[x_{i},x_{i+1}]$ and assemble the global pattern for interior nodes.\n\n3. For the same nodal spacing $h$ and background partition, consider the standard linear finite element method (FEM) with linear shape functions on each subcell. Compare the assembled nearest-neighbor stiffness coefficient between nodes $i$ and $i+1$ obtained by the meshless Galerkin method to that of linear FEM.\n\nReport as your final answer the dimensionless ratio $r$ of the meshless nearest-neighbor stiffness coefficient to the FEM nearest-neighbor stiffness coefficient. Provide $r$ as a single real number. No rounding is required, and no units should be included in the final answer.", "solution": "The problem will be validated and then, if valid, solved.\n\nProblem Validation:\n\nStep 1: Extract Givens.\n- System: One-dimensional elastic bar, length $L$, constant cross-sectional area $A$, uniform Young's modulus $E$.\n- Domain: $\\Omega = [0,L]$.\n- Discretization: $n+1$ uniformly spaced nodes $\\{x_{i}\\}_{i=0}^{n}$, with $x_{i} = i\\,h$ and $h = L/n$.\n- Boundary Conditions: Essential boundary condition $u(0)=0$. Prescribed traction $t=L$ at $x=L$.\n- Body Forces: Absent.\n- Method: Meshless Galerkin formulation with Moving Least Squares (MLS) shape functions.\n- MLS Basis: Linear basis $\\{1, x\\}$.\n- MLS Weight Function: Symmetric, compactly supported with support radius equal to nodal spacing $h$. For any point $x \\in (x_{i},x_{i+1})$, only nodes $i$ and $i+1$ have nonzero weight.\n- Numerical Integration: Background partition into $n$ subcells $[x_{i},x_{i+1}]$ using one-point Gaussian quadrature per subcell.\n- Tasks:\n  1. Derive discrete equilibrium equations $\\mathbf{K}_{\\mathrm{ml}} \\mathbf{u} = \\mathbf{f}$ and the expression for $K_{\\mathrm{ml},ab}$.\n  2. Compute the $2 \\times 2$ stiffness contribution from a subcell $[x_{i},x_{i+1}]$.\n  3. Compare the assembled nearest-neighbor stiffness coefficient with that of the linear Finite Element Method (FEM).\n- Final Answer: Report the dimensionless ratio $r$ of the meshless nearest-neighbor coefficient to the FEM nearest-neighbor coefficient.\n\nStep 2: Validate Using Extracted Givens.\nThe problem statement is scientifically grounded within the fields of continuum mechanics and numerical analysis. It describes a standard boundary value problem and its discretization using two well-established methods, MLS and FEM. The terminology is precise and objective. The problem is well-posed; the given information is sufficient to derive the quantities requested. The MLS formulation is specified with sufficient detail (linear basis, support radius of weight function, integration scheme) to permit a unique derivation. The supposed dimensional inconsistency \"traction $t=L$\" is irrelevant to the calculation of the stiffness matrix and the final ratio, which depend only on the left-hand side of the weak form. The problem is a standard exercise in comparing numerical methods and is neither trivial nor ill-posed.\n\nStep 3: Verdict and Action.\nThe problem is deemed valid. A complete, reasoned solution will be provided.\n\nSolution:\n\nThe governing weak form for the one-dimensional elasticity problem, derived from the principle of virtual work and in the absence of body forces, is:\n$$\n\\int_{0}^{L} E A \\frac{du}{dx} \\frac{d(\\delta u)}{dx} dx = \\left[ \\delta u(x) F(x) \\right]_{0}^{L}\n$$\nwhere $u$ is the displacement field, $\\delta u$ is a kinematically admissible virtual displacement, and $F(x)$ represents the external point forces. The stiffness matrix is derived from the left-hand side of this equation.\n\nThe displacement field $u(x)$ is approximated by a linear combination of shape functions $\\Phi_a(x)$ and nodal parameters $u_a$:\n$$\nu(x) \\approx u^h(x) = \\sum_{a=0}^{n} \\Phi_a(x) u_a\n$$\nThe virtual displacement is $\\delta u(x) = \\sum_{b=0}^{n} \\Phi_b(x) \\delta u_b$. Substituting these approximations into the weak form yields the discrete system $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$, where the entries of the global stiffness matrix $\\mathbf{K}$ are given by:\n$$\nK_{ab} = \\int_{0}^{L} E A \\frac{d\\Phi_a}{dx}(x) \\frac{d\\Phi_b}{dx}(x) dx\n$$\nThe problem asks to evaluate the contribution to this matrix from a single subcell $[x_{i}, x_{i+1}]$ using one-point Gaussian quadrature. The Gauss point for this interval is $x_g = x_i + \\frac{h}{2}$, and the quadrature weight is $h$. The contribution to the stiffness matrix from this subcell, denoted $\\mathbf{K}^{(i)}$, has entries:\n$$\nK_{ab}^{(i)} \\approx E A h \\left( \\frac{d\\Phi_a}{dx}(x_g) \\frac{d\\Phi_b}{dx}(x_g) \\right)\n$$\nWe must determine the derivatives of the MLS shape functions, $\\frac{d\\Phi_a}{dx}$, at the point $x_g$.\n\nThe MLS shape functions with a linear basis $\\mathbf{p}(x) = [1, x]^T$ must satisfy the linear reproduction property:\n$$\n\\sum_{I} \\Phi_I(x) p_k(x_I) = p_k(x) \\quad \\text{for } k=1,2\n$$\nDifferentiating this property with respect to $x$ gives a consistency condition for the derivatives of the shape functions:\n$$\n\\sum_{I} \\frac{d\\Phi_I}{dx}(x) \\mathbf{p}(x_I) = \\frac{d\\mathbf{p}}{dx}(x)\n$$\nFor our basis, $\\frac{d\\mathbf{p}}{dx}(x) = [0, 1]^T$. The problem states that for any point $x$ in the interval $(x_i, x_{i+1})$, the support of the weight function ensures that only nodes $i$ and $i+1$ have non-zero shape functions. Therefore, for any $x \\in (x_i, x_{i+1})$, the sum is restricted to $I \\in \\{i, i+1\\}$:\n$$\n\\frac{d\\Phi_i}{dx}(x) \\mathbf{p}(x_i) + \\frac{d\\Phi_{i+1}}{dx}(x) \\mathbf{p}(x_{i+1}) = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nThis is a system of two linear equations for the two unknown derivatives $\\frac{d\\Phi_i}{dx}(x)$ and $\\frac{d\\Phi_{i+1}}{dx}(x)$:\n$$\n\\begin{pmatrix} 1 & 1 \\\\ x_i & x_{i+1} \\end{pmatrix} \\begin{pmatrix} \\frac{d\\Phi_i}{dx}(x) \\\\ \\frac{d\\Phi_{i+1}}{dx}(x) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nSubstituting $x_i = ih$ and $x_{i+1}=(i+1)h$:\n$$\n\\begin{pmatrix} 1 & 1 \\\\ ih & (i+1)h \\end{pmatrix} \\begin{pmatrix} \\frac{d\\Phi_i}{dx}(x) \\\\ \\frac{d\\Phi_{i+1}}{dx}(x) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\nThe determinant of the matrix is $(i+1)h - ih = h$. Solving the system by matrix inversion yields:\n$$\n\\begin{pmatrix} \\frac{d\\Phi_i}{dx}(x) \\\\ \\frac{d\\Phi_{i+1}}{dx}(x) \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} (i+1)h & -1 \\\\ -ih & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{h} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{h} \\\\ \\frac{1}{h} \\end{pmatrix}\n$$\nCrucially, these derivatives are constant for any $x \\in (x_i, x_{i+1})$ and are independent of the specific form of the weight function. Thus, at the Gauss point $x_g$, we have $\\frac{d\\Phi_i}{dx}(x_g) = -1/h$ and $\\frac{d\\Phi_{i+1}}{dx}(x_g) = 1/h$.\n\nUsing these derivatives, we compute the $2 \\times 2$ stiffness matrix contribution from the subcell $[x_i, x_{i+1}]$ for the meshless method:\n$K_{\\mathrm{ml},ii}^{(i)} = E A h \\left( -\\frac{1}{h} \\right)^2 = \\frac{EA}{h}$\n$K_{\\mathrm{ml},i,i+1}^{(i)} = E A h \\left( -\\frac{1}{h} \\right) \\left( \\frac{1}{h} \\right) = -\\frac{EA}{h}$\n$K_{\\mathrm{ml},i+1,i}^{(i)} = E A h \\left( \\frac{1}{h} \\right) \\left( -\\frac{1}{h} \\right) = -\\frac{EA}{h}$\n$K_{\\mathrm{ml},i+1,i+1}^{(i)} = E A h \\left( \\frac{1}{h} \\right)^2 = \\frac{EA}{h}$\nThe MLS subcell stiffness matrix is:\n$$\n\\mathbf{K}_{\\mathrm{ml}}^{(i)} = \\frac{EA}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe assembled nearest-neighbor stiffness coefficient between nodes $i$ and $i+1$ in a 1D problem comes solely from the contribution of the subcell $[x_i, x_{i+1}]$. Thus, the meshless coefficient is $K_{\\mathrm{ml,global},i,i+1} = K_{\\mathrm{ml},i,i+1}^{(i)} = -\\frac{EA}{h}$.\n\nNow, we derive the same quantity for the standard linear Finite Element Method (FEM). For a linear element on $[x_i, x_{i+1}]$, the standard Lagrangian shape functions are $N_i(x) = \\frac{x_{i+1}-x}{h}$ and $N_{i+1}(x) = \\frac{x-x_i}{h}$. Their derivatives with respect to $x$ are constant over the element:\n$$\n\\frac{dN_i}{dx} = -\\frac{1}{h} \\quad \\text{and} \\quad \\frac{dN_{i+1}}{dx} = \\frac{1}{h}\n$$\nThe FEM element stiffness matrix entries are calculated by exact integration:\n$K_{\\mathrm{fem},ab}^{(i)} = \\int_{x_i}^{x_{i+1}} E A \\frac{dN_a}{dx} \\frac{dN_b}{dx} dx$\n$K_{\\mathrm{fem},ii}^{(i)} = \\int_{x_i}^{x_{i+1}} E A \\left(-\\frac{1}{h}\\right)^2 dx = \\frac{EA}{h^2} \\int_{x_i}^{x_{i+1}} dx = \\frac{EA}{h}$\n$K_{\\mathrm{fem},i,i+1}^{(i)} = \\int_{x_i}^{x_{i+1}} E A \\left(-\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right) dx = -\\frac{EA}{h^2} \\int_{x_i}^{x_{i+1}} dx = -\\frac{EA}{h}$\nThe resulting FEM element stiffness matrix is:\n$$\n\\mathbf{K}_{\\mathrm{fem}}^{(i)} = \\frac{EA}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe assembled FEM nearest-neighbor stiffness coefficient is $K_{\\mathrm{fem,global},i,i+1} = K_{\\mathrm{fem},i,i+1}^{(i)} = -\\frac{EA}{h}$.\n\nThe meshless stiffness coefficient is $-\\frac{EA}{h}$ and the FEM stiffness coefficient is $-\\frac{EA}{h}$. The problem asks for the ratio $r$ of the meshless coefficient to the FEM coefficient.\n$$\nr = \\frac{K_{\\mathrm{ml,global},i,i+1}}{K_{\\mathrm{fem,global},i,i+1}} = \\frac{-EA/h}{-EA/h} = 1\n$$\nThis result demonstrates that for a linear basis, a support radius equal to the nodal spacing, and one-point quadrature, the meshless Galerkin method reproduces the stiffness matrix of the linear finite element method exactly.", "answer": "$$\n\\boxed{1}\n$$", "id": "2662032"}, {"introduction": "This practice synthesizes the core concepts of MLS approximation and the Galerkin weak form to build a complete numerical solver from first principles. You will implement a one-dimensional Element-Free Galerkin (EFG) code to determine the displacement field of an elastic bar subjected to body forces and boundary constraints. This comprehensive exercise addresses practical implementation details, including the use of background cells for numerical integration and the enforcement of essential boundary conditions via Lagrange multipliers—a robust technique particularly well-suited to meshless methods [@problem_id:2662012].", "problem": "Implement a complete one-dimensional Element-Free Galerkin (EFG) solver for a prismatic bar in linear elastostatics. The bar occupies the interval $\\left[0,L\\right]$, has constant Young's modulus $E$ and cross-sectional area $A$, is subjected to a constant body force density $b$ (force per unit volume), and has essential (Dirichlet) boundary conditions $u(0)=0$ and $u(L)=\\bar{u}$. Use a Moving Least Squares (MLS) approximation with a linear polynomial basis and a compactly supported weight function to construct meshless shape functions, and enforce the essential boundary conditions by Lagrange multipliers. Compare the computed displacement field to the analytical solution in the $L^2$ sense. All inputs must be treated in International System of Units (SI): $E$ in pascals, $A$ in $\\mathrm{m}^2$, $L$ in $\\mathrm{m}$, $b$ in $\\mathrm{N}/\\mathrm{m}^3$, and $\\bar{u}$ in $\\mathrm{m}$. The final output must be a dimensionless quantity.\n\nStarting point (fundamental base): Use the strong form of equilibrium for a one-dimensional bar in small-strain, linear elasticity with constant material properties, expressed as\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(EA\\,\\frac{\\mathrm{d}u}{\\mathrm{d}x}\\right)+A\\,b=0\\quad\\text{in}\\ \\left(0,L\\right),\n$$\ntogether with the essential boundary conditions $u(0)=0$ and $u(L)=\\bar{u}$. Derive the weak form by multiplying with an admissible virtual displacement $v$ and integrating over the domain. From the weak form, formulate an EFG discretization using an MLS approximation with a linear polynomial basis, compactly-supported weights, background (cell-based) Gaussian quadrature for numerical integration, and Lagrange multipliers for the essential boundary conditions. Do not use any prederived meshless stiffness or shape-function formulas that skip the derivation from the weak form.\n\nRequirements for the numerical method:\n- Use an MLS approximation with the linear basis $p(x)=[1,x]^{\\top}$ and a compactly supported, smooth weight function with support radius $d=\\alpha\\,h$, where $h$ is the nodal spacing and $\\alpha>0$ is a prescribed non-dimensional influence parameter.\n- Use background cells that partition $\\left[0,L\\right]$ for numerical quadrature; employ Gauss–Legendre quadrature with either $2$ or $3$ points per cell as indicated in each test case.\n- Enforce the essential boundary conditions by Lagrange multipliers, resulting in an augmented linear system. Do not eliminate degrees of freedom by direct substitution because the EFG shape functions do not satisfy the Kronecker-delta property at the boundary.\n- Compute the analytical displacement field for constant $E$, $A$, and $b$ by solving the ordinary differential equation with the given essential boundary conditions.\n- Measure accuracy by the relative $L^2$ error of the displacement over the domain, defined as\n$$\n\\varepsilon_{L^2}=\\sqrt{\\frac{\\int_{0}^{L}\\left(u_h(x)-u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}{\\int_{0}^{L}\\left(u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}},\n$$\napproximated by the same background Gaussian quadrature used for assembly. Report this error for each test case as a floating-point number.\n\nTest suite:\nYour program must solve the following four test cases and aggregate the results in a single output line.\n\n- Test $1$ (general case with moderate body force):\n  - $E=70\\times 10^9$, $A=5\\times 10^{-4}$, $L=1.0$, $b=1\\times 10^4$, $\\bar{u}=1\\times 10^{-3}$, number of nodes $n=31$, influence parameter $\\alpha=2.0$, Gauss points per cell $=3$.\n- Test $2$ (zero body force, purely kinematic boundary data):\n  - $E=210\\times 10^9$, $A=1\\times 10^{-3}$, $L=2.0$, $b=0.0$, $\\bar{u}=2\\times 10^{-3}$, $n=21$, $\\alpha=2.0$, Gauss points per cell $=2$.\n- Test $3$ (zero displacement at $x=L$ and nonzero body force):\n  - $E=100\\times 10^9$, $A=2\\times 10^{-4}$, $L=0.5$, $b=2\\times 10^5$, $\\bar{u}=0.0$, $n=15$, $\\alpha=2.5$, Gauss points per cell $=3$.\n- Test $4$ (coarser discretization to probe robustness):\n  - $E=200\\times 10^9$, $A=8\\times 10^{-4}$, $L=1.5$, $b=5\\times 10^4$, $\\bar{u}=5\\times 10^{-4}$, $n=7$, $\\alpha=2.5$, Gauss points per cell $=3$.\n\nAnalytical solution for validation:\nFor constant $E$, $A$, and $b$, the analytical displacement $u_{\\mathrm{exact}}(x)$ solves $EA\\,u''(x)+A\\,b=0$ with $u(0)=0$, $u(L)=\\bar{u}$. The solution has the quadratic form\n$$\nu_{\\mathrm{exact}}(x)=-\\frac{b}{2E}\\,x^2+\\left(\\frac{\\bar{u}}{L}+\\frac{bL}{2E}\\right)x.\n$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry must be the relative $L^2$ error $\\varepsilon_{L^2}$ for one test case, written in scientific notation with exactly $6$ digits after the decimal point (for example, $\\left[1.234567\\mathrm{e}{-04},2.345678\\mathrm{e}{-05},\\dots\\right]$). The entries must appear in the same order as the test cases above.\n\nClarifications and constraints:\n- Angles are not involved, so no angular unit is required.\n- All reported errors are dimensionless.\n- Your implementation must be self-contained and must not rely on any external data beyond the specified inputs.", "solution": "The problem statement is critically examined and found to be valid. It presents a well-posed boundary value problem in one-dimensional linear elastostatics, for which a complete set of physical parameters, boundary conditions, and numerical specifications is provided. The task is to construct and apply an Element-Free Galerkin (EFG) solver, a standard and scientifically sound method in computational mechanics. The problem is objective, self-contained, and free of scientific or logical inconsistencies.\n\nThe solution proceeds by first deriving the integral weak form from the governing differential equation. Subsequently, the EFG discretization is developed using a Moving Least Squares (MLS) approximation. The essential boundary conditions are enforced via the method of Lagrange multipliers, leading to an augmented system of linear equations. This system is assembled using numerical quadrature and then solved. Finally, the accuracy of the numerical solution is quantified by computing the relative $L^2$ error against the provided analytical solution.\n\nThe strong form of the equilibrium equation for a one-dimensional bar with constant axial rigidity $EA$ and constant body force density $b$ is given as:\n$$\nEA \\frac{\\mathrm{d}^2u}{\\mathrm{d}x^2} + Ab = 0 \\quad \\text{for} \\ x \\in (0, L)\n$$\nwith essential boundary conditions $u(0)=0$ and $u(L)=\\bar{u}$.\n\nTo derive the weak form, we multiply by an arbitrary virtual displacement (test function) $v(x)$ and integrate over the domain $\\Omega = [0, L]$:\n$$\n\\int_{0}^{L} v \\left( EA \\frac{\\mathrm{d}^2u}{\\mathrm{d}x^2} + Ab \\right) \\mathrm{d}x = 0\n$$\nApplying integration by parts to the first term yields:\n$$\n\\int_{0}^{L} EA v \\frac{\\mathrm{d}^2u}{\\mathrm{d}x^2} \\mathrm{d}x = \\left[ EA v \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\right]_0^L - \\int_{0}^{L} EA \\frac{\\mathrm{d}v}{\\mathrm{d}x} \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\mathrm{d}x\n$$\nSubstituting this back, the weak form is: Find $u$ satisfying the essential boundary conditions such that for all admissible $v$:\n$$\n\\int_{0}^{L} EA \\frac{\\mathrm{d}v}{\\mathrm{d}x} \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\mathrm{d}x = \\int_{0}^{L} v Ab \\, \\mathrm{d}x + \\left[ v EA \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\right]_0^L\n$$\nThe variational or principle of minimum potential energy approach is equivalent. The potential energy functional $\\Pi$ is:\n$$\n\\Pi(u) = \\frac{1}{2} \\int_{0}^{L} EA \\left( \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\right)^2 \\mathrm{d}x - \\int_{0}^{L} u Ab \\, \\mathrm{d}x\n$$\nThe solution $u(x)$ minimizes $\\Pi(u)$ subject to the boundary conditions.\n\nIn the Element-Free Galerkin method, the displacement field $u(x)$ is approximated by a trial function $u_h(x)$ constructed using a Moving Least Squares (MLS) scheme. The domain is discretized by a set of $n$ nodes $\\{x_I\\}_{I=1}^n$. The approximation $u_h(x)$ is expressed as a linear combination of shape functions $\\Phi_I(x)$ and nodal parameter values $\\hat{u}_I$:\n$$\nu_h(x) = \\sum_{I=1}^{n} \\Phi_I(x) \\hat{u}_I = \\mathbf{\\Phi}(x)^\\top \\hat{\\mathbf{u}}\n$$\nThe MLS shape functions $\\Phi_I(x)$ are constructed as follows. At any point $x$, the approximation is expressed locally as a polynomial, here chosen to be linear: $u_h(x, \\mathbf{a}) = \\mathbf{p}(x)^\\top \\mathbf{a}(x)$, where $\\mathbf{p}(x) = [1, x]^\\top$ is the basis vector and $\\mathbf{a}(x)$ are coefficients. These coefficients are determined by minimizing a weighted, discrete $L_2$ norm of the difference between the local approximation and the nodal parameters $\\hat{u}_I$:\n$$\nJ(\\mathbf{a}) = \\sum_{I=1}^{n} w(x - x_I) \\left[ \\mathbf{p}(x_I)^\\top \\mathbf{a}(x) - \\hat{u}_I \\right]^2\n$$\nwhere $w$ is a compactly supported weight function. The stationarity condition $\\frac{\\partial J}{\\partial \\mathbf{a}} = \\mathbf{0}$ yields the coefficients $\\mathbf{a}(x) = \\mathbf{M}(x)^{-1} \\mathbf{B}(x) \\hat{\\mathbf{u}}$, where the moment matrix $\\mathbf{M}(x)$ and matrix $\\mathbf{B}(x)$ are defined as:\n$$\n\\mathbf{M}(x) = \\sum_{I=1}^{n} w(x-x_I) \\mathbf{p}(x_I) \\mathbf{p}(x_I)^\\top\n$$\n$$\n\\mathbf{B}(x)_{iJ} = w(x-x_J) p_i(x_J)\n$$\nThe shape function vector is thus $\\mathbf{\\Phi}(x)^\\top = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\mathbf{B}(x)$, which gives the individual shape function for node $I$ as:\n$$\n\\Phi_I(x) = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\mathbf{p}(x_I) w(x-x_I)\n$$\nThe derivative of the shape function is required for the weak form and is found using the chain rule:\n$$\n\\Phi_I'(x) = \\left( (\\mathbf{p}')^\\top \\mathbf{M}^{-1} - \\mathbf{p}^\\top \\mathbf{M}^{-1} \\mathbf{M}' \\mathbf{M}^{-1} \\right) \\mathbf{p}(x_I) w(x-x_I) + \\left( \\mathbf{p}^\\top \\mathbf{M}^{-1} \\mathbf{p}(x_I) \\right) w'(x-x_I)\n$$\nwhere $\\mathbf{p}'(x)=[0, 1]^\\top$, $\\mathbf{M}'(x) = \\sum_I w'(x-x_I) \\mathbf{p}(x_I)\\mathbf{p}(x_I)^\\top$. For this implementation, a quartic spline weight function is used, defined over a normalized distance $s = |x-x_I|/d \\in [0, 1]$, where $d$ is the support radius.\n\nA key property of MLS shape functions is that $\\Phi_I(x_J) \\neq \\delta_{IJ}$ (the Kronecker delta). Therefore, essential boundary conditions cannot be imposed by simply setting nodal parameter values. We use the method of Lagrange multipliers. The augmented potential energy functional $\\Pi^*$ is introduced:\n$$\n\\Pi^*(\\hat{\\mathbf{u}}, \\boldsymbol{\\lambda}) = \\Pi(u_h) + \\lambda_1 \\left( \\sum_{I=1}^{n} \\Phi_I(0)\\hat{u}_I - 0 \\right) + \\lambda_2 \\left( \\sum_{I=1}^{n} \\Phi_I(L)\\hat{u}_I - \\bar{u} \\right)\n$$\nwhere $\\boldsymbol{\\lambda} = [\\lambda_1, \\lambda_2]^\\top$ is the vector of Lagrange multipliers. The stationarity conditions $\\frac{\\partial \\Pi^*}{\\partial \\hat{\\mathbf{u}}} = \\mathbf{0}$ and $\\frac{\\partial \\Pi^*}{\\partial \\boldsymbol{\\lambda}} = \\mathbf{0}$ lead to a partitioned matrix system:\n$$\n\\begin{pmatrix}\n\\mathbf{K} & \\mathbf{G}^\\top \\\\\n\\mathbf{G} & \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\hat{\\mathbf{u}} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{f} \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\nThe components of this system are defined as follows:\n- The stiffness matrix $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$:\n$$K_{IJ} = \\int_{0}^{L} EA \\, \\Phi_I'(x) \\Phi_J'(x) \\, \\mathrm{d}x$$\n- The force vector $\\mathbf{f} \\in \\mathbb{R}^{n}$:\n$$f_I = \\int_{0}^{L} AB \\, \\Phi_I(x) \\, \\mathrm{d}x$$\n- The constraint matrix $\\mathbf{G} \\in \\mathbb{R}^{2 \\times n}$:\n$$G_{1I} = \\Phi_I(0), \\quad G_{2I} = \\Phi_I(L)$$\n- The prescribed displacement vector $\\mathbf{d} \\in \\mathbb{R}^{2}$:\n$$\\mathbf{d} = \\begin{bmatrix} 0 \\\\ \\bar{u} \\end{bmatrix}$$\n\nThe integrals for $\\mathbf{K}$ and $\\mathbf{f}$ are computed numerically using Gauss-Legendre quadrature over a background mesh of cells that partition the domain $[0, L]$. The same quadrature scheme is used to compute the numerator and denominator of the relative $L^2$ error:\n$$\n\\varepsilon_{L^2} = \\sqrt{\\frac{\\int_{0}^{L}\\left(u_h(x)-u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}{\\int_{0}^{L}\\left(u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}}\n$$\nAfter solving the augmented system for the nodal parameters $\\hat{\\mathbf{u}}$, the displacement field $u_h(x)$ is computed at each quadrature point to evaluate the error integrals. The analytical solution for comparison is given by:\n$$\nu_{\\mathrm{exact}}(x)=-\\frac{b}{2E}\\,x^2+\\left(\\frac{\\bar{u}}{L}+\\frac{bL}{2E}\\right)x\n$$\nThis procedure provides a complete framework for solving the problem and evaluating the accuracy of the EFG method.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D Element-Free Galerkin (EFG) solver for a prismatic bar\n    with Lagrange multipliers for essential boundary conditions.\n    \"\"\"\n\n    def efg_solver(E, A, L, b, u_bar, n, alpha, n_gauss):\n        \"\"\"\n        Core EFG solver for a single test case.\n        \"\"\"\n        # 1. Discretization and parameters\n        nodes = np.linspace(0, L, n)\n        h = L / (n - 1) if n > 1 else L\n        d = alpha * h  # Support radius of the weight function\n\n        # Quartic spline weight function and its derivative\n        def weight_function(s):\n            if s > 1.0:\n                return 0.0, 0.0\n            s2, s3, s4 = s * s, s * s * s, s * s * s * s\n            w = 1.0 - 6.0 * s2 + 8.0 * s3 - 3.0 * s4\n            dw_ds = -12.0 * s + 24.0 * s2 - 12.0 * s3\n            return w, dw_ds\n\n        def compute_mls_shape_functions(x, nodes, d):\n            \"\"\"\n            Computes MLS shape functions and their derivatives at a point x.\n            \"\"\"\n            p_basis = np.array([1.0, x])\n            dp_basis = np.array([0.0, 1.0])\n            \n            influential_nodes_idx = np.where(np.abs(x - nodes) < d)[0]\n            \n            nonlocal n\n            phis = np.zeros(n)\n            dphis = np.zeros(n)\n\n            if len(influential_nodes_idx) < 2:  # Need at least 2 nodes for linear basis\n                return phis, dphis\n            \n            p_matrix_I = np.ones((len(influential_nodes_idx), 2))\n            p_matrix_I[:, 1] = nodes[influential_nodes_idx]\n\n            M = np.zeros((2, 2))\n            dM = np.zeros((2, 2))\n            \n            weights = np.zeros(len(influential_nodes_idx))\n            dweights_dx = np.zeros(len(influential_nodes_idx))\n\n            for i, node_idx in enumerate(influential_nodes_idx):\n                s = np.abs(x - nodes[node_idx]) / d\n                w_val, dw_ds_val = weight_function(s)\n                weights[i] = w_val\n                dweights_dx[i] = dw_ds_val * np.sign(x - nodes[node_idx]) / d\n                \n                p_node = np.array([[1.0], [nodes[node_idx]]])\n                pp_T = p_node @ p_node.T\n                M += w_val * pp_T\n                dM += dweights_dx[i] * pp_T\n\n            try:\n                M_inv = np.linalg.inv(M)\n            except np.linalg.LinAlgError:\n                return phis, dphis\n            \n            psi_T = p_basis.T @ M_inv\n            dpsi_T = dp_basis.T @ M_inv - p_basis.T @ M_inv @ dM @ M_inv\n\n            for i, node_idx in enumerate(influential_nodes_idx):\n                p_node = np.array([1.0, nodes[node_idx]])\n                phi_val = psi_T @ p_node * weights[i]\n                dphi_val = dpsi_T @ p_node * weights[i] + psi_T @ p_node * dweights_dx[i]\n                phis[node_idx] = phi_val\n                dphis[node_idx] = dphi_val\n\n            return phis, dphis\n\n        # 2. Gaussian Quadrature Setup\n        gauss_points, gauss_weights = np.polynomial.legendre.leggauss(n_gauss)\n        cells = np.array([nodes[:-1], nodes[1:]]).T\n\n        # 3. System Assembly\n        K = np.zeros((n, n))\n        f = np.zeros(n)\n        \n        for cell_start, cell_end in cells:\n            cell_len = cell_end - cell_start\n            for gp, gw in zip(gauss_points, gauss_weights):\n                x_gp = cell_start + (gp + 1) * cell_len / 2.0\n                w_gp = gw * cell_len / 2.0\n                \n                phis, dphis = compute_mls_shape_functions(x_gp, nodes, d)\n                \n                # Check for influential nodes at the Gauss point\n                influential_idx = np.where(phis != 0)[0]\n                if len(influential_idx) == 0:\n                    continue\n\n                dphis_vec = dphis[influential_idx]\n                K_contrib = E * A * np.outer(dphis_vec, dphis_vec)\n                f_contrib = A * b * phis[influential_idx]\n\n                ix = np.ix_(influential_idx, influential_idx)\n                K[ix] += K_contrib * w_gp\n                f[influential_idx] += f_contrib * w_gp\n\n        # 4. Lagrange Multiplier Constraints\n        G = np.zeros((2, n))\n        G[0, :], _ = compute_mls_shape_functions(0.0, nodes, d)\n        G[1, :], _ = compute_mls_shape_functions(L, nodes, d)\n\n        d_bc = np.array([0.0, u_bar])\n\n        # 5. Form and Solve Augmented System\n        size = n + 2\n        A_aug = np.zeros((size, size))\n        b_aug = np.zeros(size)\n\n        A_aug[:n, :n] = K\n        A_aug[n:, :n] = G\n        A_aug[:n, n:] = G.T\n        \n        b_aug[:n] = f\n        b_aug[n:] = d_bc\n        \n        try:\n            sol = np.linalg.solve(A_aug, b_aug)\n        except np.linalg.LinAlgError:\n            return np.nan # Indicate failure\n\n        u_hat = sol[:n]\n\n        # 6. Error Calculation\n        def analytical_solution(x, E, A, L, b, u_bar):\n            if E == 0: return np.nan\n            c1 = u_bar / L + b * L / (2.0 * E)\n            c2 = 0\n            return -b * x**2 / (2.0 * E) + c1 * x + c2\n\n        num_integral = 0.0\n        den_integral = 0.0\n\n        for cell_start, cell_end in cells:\n            cell_len = cell_end - cell_start\n            for gp, gw in zip(gauss_points, gauss_weights):\n                x_gp = cell_start + (gp + 1) * cell_len / 2.0\n                w_gp = gw * cell_len / 2.0\n\n                phis, _ = compute_mls_shape_functions(x_gp, nodes, d)\n                u_h = phis @ u_hat\n                u_exact = analytical_solution(x_gp, E, A, L, b, u_bar)\n\n                num_integral += (u_h - u_exact)**2 * w_gp\n                den_integral += u_exact**2 * w_gp\n\n        if den_integral == 0.0:\n            return 0.0 if num_integral == 0.0 else np.inf\n        \n        rel_l2_error = np.sqrt(num_integral / den_integral)\n        return rel_l2_error\n\n    test_cases = [\n        # (E, A, L, b, u_bar, n, alpha, n_gauss)\n        (70e9, 5e-4, 1.0, 1e4, 1e-3, 31, 2.0, 3),\n        (210e9, 1e-3, 2.0, 0.0, 2e-3, 21, 2.0, 2),\n        (100e9, 2e-4, 0.5, 2e5, 0.0, 15, 2.5, 3),\n        (200e9, 8e-4, 1.5, 5e4, 5e-4, 7, 2.5, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = efg_solver(*case)\n        results.append(\"{:.6e}\".format(error))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2662012"}]}