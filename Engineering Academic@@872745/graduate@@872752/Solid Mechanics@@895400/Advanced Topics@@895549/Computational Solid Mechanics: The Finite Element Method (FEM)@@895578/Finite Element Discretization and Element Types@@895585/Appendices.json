{"hands_on_practices": [{"introduction": "The journey into finite element formulation begins with its most fundamental building block: the element itself. This exercise focuses on the 3-node constant strain triangle (T3), the simplest two-dimensional element. You will derive the crucial strain-displacement matrix, $\\mathbf{B}$, which links nodal displacements to the internal strains, and discover why the element's linear interpolation scheme leads to a constant strain field. This practice is essential for understanding how an element's kinematic assumptions dictate its behavior and predictive capabilities, as evaluated by the classic patch test.", "problem": "Consider a $2$-dimensional, small-strain, displacement-based Finite Element Method (FEM) discretization of linear elasticity over a single $3$-node triangular element with straight sides. Let the physical coordinates of the triangle be given by node $1$ at $(0,0)$, node $2$ at $(4,0)$, and node $3$ at $(1,3)$, with all coordinates in $\\mathrm{m}$. Denote the nodal displacement vector by\n$$\n\\mathbf{d}_{e}=\\begin{bmatrix}u_{1} & v_{1} & u_{2} & v_{2} & u_{3} & v_{3}\\end{bmatrix}^{\\mathsf{T}},\n$$\nwhere $u_{i}$ and $v_{i}$ are the Cartesian displacement components at node $i$. The small-strain tensor is defined by\n$$\n\\boldsymbol{\\varepsilon}=\\frac{1}{2}\\left(\\nabla \\mathbf{u} + \\left(\\nabla \\mathbf{u}\\right)^{\\mathsf{T}}\\right),\n$$\nand the element employs linear shape functions in the physical $(x,y)$-plane.\n\nTasks:\n$1.$ Starting only from the kinematic definition of small strain and the linear interpolation of displacement using the element’s shape functions, derive the explicit expression for the element strain–displacement matrix $\\mathbf{B}$ such that $\\boldsymbol{\\varepsilon}=\\mathbf{B}\\,\\mathbf{d}_{e}$ for this triangle. Your derivation must make clear how $\\mathbf{B}$ depends on the nodal coordinates.\n\n$2.$ Prove that the strains produced by this element are constant over the element domain and explain the geometric reason for this fact. Then, using polynomial completeness and equilibrium arguments, deduce what this implies for the element’s performance on the Irons–Razzaque patch test: state precisely which order of displacement or stress fields are exactly reproduced and which are not.\n\n$3.$ For the given triangle, define the scalar\n$$\nS=\\|\\mathbf{B}\\|_{F}^{2}=\\sum_{i=1}^{3}\\sum_{j=1}^{6}\\left(B_{ij}\\right)^{2},\n$$\nthe squared Frobenius norm of $\\mathbf{B}$. Compute $S$ exactly. Express the final value of $S$ in $\\mathrm{m}^{-2}$, and do not round; provide an exact value.\n\nAnswer specification: The final answer must be a single real number (no units in the boxed answer). If you perform any intermediate numerical operations, do not round; carry exact arithmetic to the end.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is a standard problem in the study of the Finite Element Method for solid mechanics, specifically concerning the properties of the $3$-node linear triangular element, often referred to as the Constant Strain Triangle (CST) or T3 element. All necessary information is provided, and the tasks are well-defined. Therefore, the problem is valid and a solution will be provided.\n\nThe analysis begins with the fundamental principles of displacement-based finite element formulation.\n\n**Task 1: Derivation of the Strain-Displacement Matrix $\\mathbf{B}$**\n\nThe displacement field, $\\mathbf{u}(x,y) = \\begin{pmatrix} u(x,y) & v(x,y) \\end{pmatrix}^{\\mathsf{T}}$, within the element is interpolated from the nodal displacements $\\mathbf{d}_e$ using linear shape functions $N_i(x,y)$.\n$$\nu(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i\n$$\n$$\nv(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i\n$$\nThis can be written in matrix form as $\\mathbf{u} = \\mathbf{N} \\mathbf{d}_e$, where $\\mathbf{N}$ is the matrix of shape functions:\n$$\n\\mathbf{N} = \\begin{pmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{pmatrix}\n$$\nThe linear shape function for node $i$ has the form $N_i(x,y) = \\alpha_i + \\beta_i x + \\gamma_i y$. The coefficients are determined by the property $N_i(x_j, y_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. A direct formula for the spatial derivatives of the shape functions exists, which is more convenient for deriving the strain-displacement matrix. These derivatives depend on the nodal coordinates $(x_i, y_i)$ and the area of the element, $A$.\nThe area $A$ of the triangle with vertices $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ is given by:\n$$\nA = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix} = \\frac{1}{2} \\left[ x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \\right]\n$$\nThe spatial derivatives of the shape functions are constant and given by:\n$$\n\\frac{\\partial N_i}{\\partial x} = \\beta_i = \\frac{1}{2A}(y_j - y_k)\n$$\n$$\n\\frac{\\partial N_i}{\\partial y} = \\gamma_i = \\frac{1}{2A}(x_k - x_j)\n$$\nwhere the indices $(i, j, k)$ are cyclic permutations of $(1, 2, 3)$.\n\nThe small-strain tensor components in Voigt notation for a $2$-dimensional problem are $\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} & \\varepsilon_{yy} & \\gamma_{xy} \\end{pmatrix}^{\\mathsf{T}}$, where $\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}$, $\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}$, and $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$.\n\nSubstituting the displacement interpolations:\n$$\n\\varepsilon_{xx} = \\frac{\\partial}{\\partial x} \\sum_{i=1}^{3} N_i u_i = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial x} u_i = \\beta_1 u_1 + \\beta_2 u_2 + \\beta_3 u_3\n$$\n$$\n\\varepsilon_{yy} = \\frac{\\partial}{\\partial y} \\sum_{i=1}^{3} N_i v_i = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial y} v_i = \\gamma_1 v_1 + \\gamma_2 v_2 + \\gamma_3 v_3\n$$\n$$\n\\gamma_{xy} = \\frac{\\partial}{\\partial y} \\sum_{i=1}^{3} N_i u_i + \\frac{\\partial}{\\partial x} \\sum_{i=1}^{3} N_i v_i = \\sum_{i=1}^{3} \\left( \\frac{\\partial N_i}{\\partial y} u_i + \\frac{\\partial N_i}{\\partial x} v_i \\right) = \\sum_{i=1}^{3} (\\gamma_i u_i + \\beta_i v_i)\n$$\nWe assemble these relationships into the matrix equation $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$:\n$$\n\\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix} = \\begin{pmatrix}\n\\beta_1 & 0 & \\beta_2 & 0 & \\beta_3 & 0 \\\\\n0 & \\gamma_1 & 0 & \\gamma_2 & 0 & \\gamma_3 \\\\\n\\gamma_1 & \\beta_1 & \\gamma_2 & \\beta_2 & \\gamma_3 & \\beta_3\n\\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\\\ u_3 \\\\ v_3 \\end{pmatrix}\n$$\nThus, the strain-displacement matrix $\\mathbf{B}$ is:\n$$\n\\mathbf{B} = \\begin{pmatrix}\n\\beta_1 & 0 & \\beta_2 & 0 & \\beta_3 & 0 \\\\\n0 & \\gamma_1 & 0 & \\gamma_2 & 0 & \\gamma_3 \\\\\n\\gamma_1 & \\beta_1 & \\gamma_2 & \\beta_2 & \\gamma_3 & \\beta_3\n\\end{pmatrix}\n$$\nSubstituting the expressions for $\\beta_i$ and $\\gamma_i$ and defining $y_{ij} = y_i - y_j$ and $x_{ij} = x_i - x_j$:\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{pmatrix}\ny_{2}-y_{3} & 0 & y_{3}-y_{1} & 0 & y_{1}-y_{2} & 0 \\\\\n0 & x_{3}-x_{2} & 0 & x_{1}-x_{3} & 0 & x_{2}-x_{1} \\\\\nx_{3}-x_{2} & y_{2}-y_{3} & x_{1}-x_{3} & y_{3}-y_{1} & x_{2}-x_{1} & y_{1}-y_{2}\n\\end{pmatrix}\n$$\nThis expression demonstrates explicitly how $\\mathbf{B}$ depends on the nodal coordinates.\n\n**Task 2: Constant Strain and Patch Test Implications**\n\nThe displacement field is interpolated by functions that are linear in the spatial coordinates $x$ and $y$. The strain components are defined by the first spatial derivatives of the displacement components. The derivative of a linear function is a constant. Consequently, $\\varepsilon_{xx}$, $\\varepsilon_{yy}$, and $\\gamma_{xy}$ are constant throughout the element's domain.\n\nGeometrically, the linear shape functions define an affine mapping from a master element (e.g., a right triangle in a reference $(\\xi, \\eta)$ coordinate system) to the physical element in the $(x,y)$ plane. The Jacobian of this mapping is constant. Since the derivatives of the shape functions with respect to the reference coordinates are constants, and the Jacobian is constant, the derivatives with respect to the physical coordinates are also constant. This is the fundamental reason for the constant strain behavior of the T3 element.\n\nThis property has direct implications for the element's performance, as evaluated by the patch test. The patch test is a necessary condition for convergence.\nThe polynomial completeness of the T3 element's shape functions means it can exactly represent any displacement field that is a linear polynomial in $x$ and $y$, i.e., $u(x,y)=a_0+a_1 x+a_2 y$ and $v(x,y)=b_0+b_1 x+b_2 y$. Such a displacement field corresponds to a state of constant strain, where $\\varepsilon_{xx}=a_1$, $\\varepsilon_{yy}=b_2$, and $\\gamma_{xy}=a_2+b_1$. For a homogeneous linear elastic material, a constant strain state implies a constant stress state. In the absence of body forces, a constant stress field $\\boldsymbol{\\sigma}$ trivially satisfies the equilibrium equation $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$. Therefore, a patch of T3 elements can exactly reproduce a constant stress field when the appropriate linear displacement field is applied to the boundary nodes. The element passes the constant stress patch test.\n\nHowever, the element cannot represent higher-order displacement fields exactly. For example, a quadratic displacement field, which would produce a linearly varying strain field (as in pure bending), cannot be captured. The element will approximate a linear strain field with a piecewise-constant strain field, which is a poor approximation. Thus, the T3 element fails the patch test for linear strain fields.\nIn summary, the T3 element exactly reproduces constant displacement gradients, corresponding to constant strain and stress fields. It does not exactly reproduce any fields of higher order.\n\n**Task 3: Computation of $S = \\|\\mathbf{B}\\|_{F}^{2}$**\n\nThe nodal coordinates are given as $1: (0,0)$, $2: (4,0)$, and $3: (1,3)$, with units in meters.\nFirst, we compute the area $A$ of the triangle.\n$$\n2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) = 0(0 - 3) + 4(3 - 0) + 1(0 - 0) = 12 \\, \\mathrm{m}^2\n$$\nSo, $A = 6 \\, \\mathrm{m}^2$.\n\nNext, we compute the coordinate differences needed for the $\\mathbf{B}$ matrix:\n$y_{23} = y_2 - y_3 = 0 - 3 = -3$\n$y_{31} = y_3 - y_1 = 3 - 0 = 3$\n$y_{12} = y_1 - y_2 = 0 - 0 = 0$\n$x_{32} = x_3 - x_2 = 1 - 4 = -3$\n$x_{13} = x_1 - x_3 = 0 - 1 = -1$\n$x_{21} = x_2 - x_1 = 4 - 0 = 4$\n\nNow we construct the $\\mathbf{B}$ matrix:\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{pmatrix} y_{23} & 0 & y_{31} & 0 & y_{12} & 0 \\\\ 0 & x_{32} & 0 & x_{13} & 0 & x_{21} \\\\ x_{32} & y_{23} & x_{13} & y_{31} & x_{21} & y_{12} \\end{pmatrix} = \\frac{1}{12} \\begin{pmatrix} -3 & 0 & 3 & 0 & 0 & 0 \\\\ 0 & -3 & 0 & -1 & 0 & 4 \\\\ -3 & -3 & -1 & 3 & 4 & 0 \\end{pmatrix}\n$$\nThe squared Frobenius norm is the sum of the squares of all elements: $S = \\sum_{i,j} (B_{ij})^2$.\n$$\nS = \\left(\\frac{1}{12}\\right)^{2} \\left[ (-3)^2 + 3^2 + (-3)^2 + (-1)^2 + 4^2 + (-3)^2 + (-3)^2 + (-1)^2 + 3^2 + 4^2 \\right]\n$$\nSumming the squares of the integer matrix elements:\nSum = $(9+9) + (9+1+16) + (9+9+1+9+16)$\nSum = $18 + 26 + 44 = 88$\nTherefore,\n$$\nS = \\frac{1}{144} \\times 88 = \\frac{88}{144}\n$$\nThis fraction can be simplified by dividing the numerator and denominator by their greatest common divisor, which is $8$.\n$$\nS = \\frac{88 \\div 8}{144 \\div 8} = \\frac{11}{18}\n$$\nThe units of the coefficients $\\beta_i$ and $\\gamma_i$ are $\\mathrm{m}^{-1}$. The quantity $S$ is a sum of squares of these coefficients, so its units are $\\mathrm{m}^{-2}$. The problem asks for a final numeric value.", "answer": "$$\\boxed{\\frac{11}{18}}$$", "id": "2639920"}, {"introduction": "A correct theoretical formulation is necessary but not sufficient for a reliable finite element analysis; the implementation must also be rigorously verified. A key physical principle is that rigid-body motions induce no strain, and thus, no stress or strain energy. This practice guides you through the development of a numerical test harness to confirm that your element stiffness matrix, $\\mathbf{K}_e$, for both triangular and quadrilateral elements, remains invariant under translation and rotation. This is a critical skill in computational code development, teaching you to distinguish true physical behavior from numerical artifacts and to manage the realities of finite-precision arithmetic.", "problem": "You are to implement a program that constructs a finite element test harness to verify the invariance of the element stiffness matrix under rigid-body translations and rotations for common two-dimensional elements in linear elasticity. The test harness must be grounded in first principles of solid mechanics and the finite element method, without relying on precomputed formulas for invariance.\n\nThe fundamental base to use is:\n- Linear momentum balance and small-strain linear elasticity, leading to the total potential energy whose second variation defines the symmetric positive semidefinite element stiffness matrix.\n- For a two-dimensional elastic body with small strains, the element stiffness matrix is given by\n$$\n\\mathbf{K}_e \\;=\\; \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T}\\,\\mathbf{D}\\,\\mathbf{B}\\,t\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix derived from the element shape functions, $\\mathbf{D}$ is the constitutive matrix for isotropic linear elasticity in either plane stress or plane strain, $t$ is the thickness, and $\\Omega_e$ is the element domain in physical coordinates.\n- The constitutive matrix for plane stress is\n$$\n\\mathbf{D}_{\\text{ps}} \\;=\\; \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\dfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\nwith Young’s modulus $E$ and Poisson’s ratio $\\nu$.\n\nYou must:\n- Build routines to compute $\\mathbf{K}_e$ for a $3$-node linear triangle ($\\mathrm{T3}$) and a $4$-node bilinear quadrilateral ($\\mathrm{Q4}$) in plane stress. For $\\mathrm{T3}$, use the exact constant $\\mathbf{B}$ formulation. For $\\mathrm{Q4}$, use isoparametric mapping with a standard $2\\times 2$ Gaussian quadrature.\n- Implement rigid-body transformations of nodal coordinates: a translation by a vector $\\mathbf{t}\\in\\mathbb{R}^2$ and a rotation by an angle $\\theta$ (in radians) about the origin with rotation matrix\n$$\n\\mathbf{R}(\\theta) \\;=\\; \\begin{bmatrix}\\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta\\end{bmatrix}.\n$$\n\nScientific rationale to encode and test:\n- Invariance of $\\mathbf{K}_e$ under rigid-body translations and rotations follows from the fact that $\\mathbf{B}$ depends on spatial derivatives of shape functions, which depend only on relative geometry (metric) and not on absolute position or orientation. Rigid translations leave the Jacobian and metric unchanged, and rigid rotations preserve lengths and areas, so $\\int_{\\Omega_e}\\mathbf{B}^\\mathsf{T}\\mathbf{D}\\mathbf{B}\\,t\\,\\mathrm{d}\\Omega$ is invariant. Numerically, floating-point roundoff introduces small differences.\n\nYour test harness must:\n1. Compute a reference stiffness matrix $\\mathbf{K}_e$ for the original nodal coordinates, and two transformed stiffness matrices: $\\mathbf{K}_e^{\\text{trans}}$ using translated coordinates and $\\mathbf{K}_e^{\\text{rot}}$ using rotated coordinates.\n2. Quantify differences using both an absolute metric and a relative metric:\n   - Absolute metric: the maximum absolute componentwise deviation\n   $$\n   \\Delta_\\infty \\;=\\; \\max_{i,j} \\left| (\\mathbf{K}_e^{\\star} - \\mathbf{K}_e)_{ij} \\right|.\n   $$\n   - Relative metric: the Frobenius-norm relative deviation\n   $$\n   \\Delta_{\\mathrm{rel}} \\;=\\; \\frac{\\left\\| \\mathbf{K}_e^{\\star} - \\mathbf{K}_e \\right\\|_F}{\\max\\!\\left(\\left\\|\\mathbf{K}_e\\right\\|_F,\\;\\varepsilon\\right)},\n   $$\n   where $\\varepsilon$ is a small positive scalar to prevent division by zero and $\\star\\in\\{\\text{trans},\\text{rot}\\}$.\n3. Declare a pass if and only if both $\\Delta_\\infty \\le \\mathrm{abs\\_tol}$ and $\\Delta_{\\mathrm{rel}} \\le \\mathrm{rel\\_tol}$ for the given tolerances.\n\nAcceptable numerical tolerances, justified by double-precision roundoff (approximately machine epsilon $\\approx 2.22\\times 10^{-16}$) and moderate operation counts, are:\n- For well-conditioned elements: $\\mathrm{abs\\_tol} = 10^{-11}$ to $10^{-10}$ and $\\mathrm{rel\\_tol} = 10^{-11}$ to $10^{-10}$.\n- For near-degenerate or severely skewed elements, looser tolerances such as $\\mathrm{abs\\_tol} = 10^{-6}$ and $\\mathrm{rel\\_tol} = 10^{-6}$ may be necessary due to amplification of roundoff by poor conditioning.\n\nPhysical units to use:\n- Coordinates, thickness, and translations in meters ($\\mathrm{m}$).\n- Young’s modulus in Pascals ($\\mathrm{Pa}$).\n- Angles in radians.\n- The output must be boolean pass/fail indicators.\n\nTest suite to implement exactly as specified below (all coordinates are in meters, thicknesses in meters, moduli in Pascals, and angles in radians):\n- Test case $\\#1$ ($\\mathrm{T3}$, well-shaped):\n  - Nodes: $\\big[(0.0,\\,0.0),\\,(1.2,\\,0.3),\\,(0.2,\\,0.9)\\big]$.\n  - $E = 210\\times 10^{9}$, $\\nu = 0.3$, $t = 0.01$.\n  - Rotation $\\theta = \\pi/3$, translation $\\mathbf{t} = (5.0,\\,-3.0)$.\n  - Tolerances: $\\mathrm{abs\\_tol} = 10^{-10}$, $\\mathrm{rel\\_tol} = 10^{-10}$.\n- Test case $\\#2$ ($\\mathrm{Q4}$, unit square):\n  - Nodes: $\\big[(0.0,\\,0.0),\\,(1.0,\\,0.0),\\,(1.0,\\,1.0),\\,(0.0,\\,1.0)\\big]$.\n  - $E = 70\\times 10^{9}$, $\\nu = 0.33$, $t = 0.05$.\n  - Rotation $\\theta = \\pi/4$, translation $\\mathbf{t} = (0.0,\\,0.0)$.\n  - Tolerances: $\\mathrm{abs\\_tol} = 10^{-11}$, $\\mathrm{rel\\_tol} = 10^{-11}$.\n- Test case $\\#3$ ($\\mathrm{Q4}$, skew convex quadrilateral with large translation and tiny rotation):\n  - Nodes: $\\big[(0.0,\\,0.0),\\,(2.0,\\,0.2),\\,(1.8,\\,1.1),\\,(-0.1,\\,1.0)\\big]$.\n  - $E = 1.0\\times 10^{5}$, $\\nu = 0.25$, $t = 0.1$.\n  - Rotation $\\theta = 10^{-6}$, translation $\\mathbf{t} = (10^{6},\\,-10^{6})$.\n  - Tolerances: $\\mathrm{abs\\_tol} = 10^{-8}$, $\\mathrm{rel\\_tol} = 10^{-8}$.\n- Test case $\\#4$ ($\\mathrm{T3}$, near-degenerate):\n  - Nodes: $\\big[(0.0,\\,0.0),\\,(1.0,\\,0.0),\\,(10^{-6},\\,10^{-6})\\big]$.\n  - $E = 200\\times 10^{9}$, $\\nu = 0.29$, $t = 0.02$.\n  - Rotation $\\theta = 2.0$, translation $\\mathbf{t} = (1000.0,\\,-1000.0)$.\n  - Tolerances: $\\mathrm{abs\\_tol} = 10^{-6}$, $\\mathrm{rel\\_tol} = 10^{-6}$.\n\nAlgorithmic requirements:\n- Implement shape-function gradients and Jacobians directly from their definitions. For $\\mathrm{Q4}$, use a $2\\times 2$ Gaussian quadrature with points at $\\xi,\\eta \\in \\{\\pm 1/\\sqrt{3}\\}$ and unit weights.\n- Use the plane stress constitutive matrix $\\mathbf{D}_{\\text{ps}}$ with the provided $E$ and $\\nu$.\n- For the $\\mathrm{T3}$ element, let the element area be the absolute value of the signed area to avoid orientation dependence in the area factor. Use the exact constant $\\mathbf{B}$-matrix over the element domain.\n\nProgram output specification:\n- For each test case, produce two boolean results in order: the translation-invariance pass and the rotation-invariance pass.\n- Aggregate all results across the four test cases into a single Python-style list literal, in order $\\big[\\text{case }1\\text{ translation},\\text{ case }1\\text{ rotation},\\text{ case }2\\text{ translation},\\text{ case }2\\text{ rotation},\\text{ case }3\\text{ translation},\\text{ case }3\\text{ rotation},\\text{ case }4\\text{ translation},\\text{ case }4\\text{ rotation}\\big]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True,True,False,True,True,True]\").", "solution": "The problem as stated requires the construction of a numerical test harness to verify a fundamental property of the finite element stiffness matrix, which is its invariance under rigid-body motions. This property arises because strain, the physical quantity measured by the finite element formulation, is defined by relative deformation and is independent of the absolute position or orientation of the body in space. We will implement the stiffness matrix calculations for two common two-dimensional linear elastic elements, the 3-node linear triangle ($\\mathrm{T3}$) and the 4-node bilinear quadrilateral ($\\mathrm{Q4}$), based on first principles. These implementations will then be subjected to rigid-body translation and rotation transformations to numerically test the invariance property.\n\n**1. Theoretical Foundation of the Stiffness Matrix**\n\nThe element stiffness matrix, denoted $\\mathbf{K}_e$, provides the linear relationship between the vector of nodal forces $\\mathbf{f}_e$ and the vector of nodal displacements $\\mathbf{d}_e$ for an element, expressed as $\\mathbf{f}_e = \\mathbf{K}_e \\mathbf{d}_e$. It is formally derived from the second variation of the total potential energy of the elastic system. For a two-dimensional body of constant thickness $t$ undergoing small deformations under plane stress conditions, this matrix is computed by the integral over the element's domain $\\Omega_e$:\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, t \\, \\mathrm{d}\\Omega\n$$\nThe components of this integral are:\n-   The thickness $t$, assumed constant over the element.\n-   The constitutive matrix $\\mathbf{D}$, which relates stress to strain. For an isotropic linear elastic material under plane stress, it is a function of Young's modulus $E$ and Poisson's ratio $\\nu$:\n    $$\n    \\mathbf{D} = \\frac{E}{1-\\nu^2}\n    \\begin{bmatrix}\n    1 & \\nu & 0\\\\\n    \\nu & 1 & 0\\\\\n    0 & 0 & \\dfrac{1-\\nu}{2}\n    \\end{bmatrix}\n    $$\n-   The strain-displacement matrix $\\mathbf{B}$, which maps the nodal displacement vector $\\mathbf{d}_e$ to the engineering strain vector $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\mathsf{T}$. The $\\mathbf{B}$ matrix is constructed from the spatial derivatives of the element's shape functions $N_i$.\n\n**2. Element Formulations**\n\nWe will implement two distinct element formulations as specified.\n\n**2.1. 3-Node Linear Triangle (T3)**\n\nFor a triangle defined by nodes $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$, the use of linear interpolation functions for displacement results in a state of constant strain throughout the element. Consequently, the strain-displacement matrix $\\mathbf{B}$ is also constant. Its explicit form is:\n$$\n\\mathbf{B} = \\frac{1}{2 A}\n\\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\nwhere $A$ is the signed area of the element, calculated as $A = \\frac{1}{2} [x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)]$. The determinant of the Jacobian for this element's mapping from a reference domain is constant and equals $2A$. Since the entire integrand $\\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B}$ is constant, the integration is reduced to a multiplication by the element's area. To ensure the integration volume is positive, we use the absolute value of the area:\n$$\n\\mathbf{K}_e = (\\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B}) \\cdot |A| \\cdot t\n$$\n\n**2.2. 4-Node Bilinear Quadrilateral (Q4)**\n\nFor an isoparametric quadrilateral element, all computations are performed in a standardized parent domain, a square defined by $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$. The physical coordinates $(x,y)$ are mapped from the parent coordinates using bilinear shape functions, $N_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i\\xi)(1 + \\eta_i\\eta)$, where $(\\xi_i, \\eta_i)$ are the coordinates of the nodes in the parent domain.\nThe integrand for $\\mathbf{K}_e$ is no longer constant and must be evaluated using numerical quadrature. The problem specifies a $2 \\times 2$ Gaussian quadrature scheme. The integral transforms as:\n$$\n\\mathbf{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\, t \\, \\det(\\mathbf{J}(\\xi, \\eta)) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\approx t \\sum_{k=1}^{4} w_k \\left[ \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\det(\\mathbf{J}) \\right]_{(\\xi_k, \\eta_k)}\n$$\nThe quadrature points $(\\xi_k, \\eta_k)$ are located at $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$, and the corresponding weights $w_k$ are all equal to $1$. The Jacobian matrix $\\mathbf{J}$ relates derivatives in the parent domain to derivatives in the physical domain. The $\\mathbf{B}$ matrix is assembled at each quadrature point using the spatial derivatives $\\partial N_i / \\partial x$ and $\\partial N_i / \\partial y$, which are themselves computed using the inverse of the Jacobian.\n\n**3. Verification of Invariance**\n\nThe fundamental principle being tested is that a rigid-body motion, which is an isometry, does not induce strain. Therefore, the strain energy and the stiffness matrix must be invariant. Let $f$ be such a motion. If nodal coordinates $\\mathbf{x}_i$ are transformed to $\\mathbf{x}'_i = f(\\mathbf{x}_i)$, the resulting stiffness matrix $\\mathbf{K}'_e$ must be identical to $\\mathbf{K}_e$.\nMathematically, the Jacobian of the coordinate mapping is invariant under translation and transforms covariantly under rotation in a precise manner that leaves the final integrated value of the stiffness matrix unchanged.\nHowever, in finite-precision arithmetic, this invariance may not hold perfectly. Large translations can cause a loss of significance when computing differences between large floating-point numbers. Ill-conditioned element geometries (e.g., near-zero area) result in poorly-conditioned Jacobians, which amplify any computational inaccuracies.\nThe verification protocol is as follows:\n1.  For a given element, compute the reference stiffness matrix $\\mathbf{K}_e$ using its original nodal coordinates.\n2.  Apply a rigid-body translation $\\mathbf{t}$ to the nodes and compute the corresponding stiffness matrix $\\mathbf{K}_e^{\\text{trans}}$.\n3.  Apply a rigid-body rotation $\\mathbf{R}(\\theta)$ to the original nodes and compute $\\mathbf{K}_e^{\\text{rot}}$.\n4.  Quantify the deviation of the transformed matrices from the reference using two metrics:\n    -   Maximum absolute component-wise error: $\\Delta_\\infty = \\max_{i,j} | (\\mathbf{K}_e^{\\star} - \\mathbf{K}_e)_{ij} |$.\n    -   Relative Frobenius norm error: $\\Delta_{\\mathrm{rel}} = \\| \\mathbf{K}_e^{\\star} - \\mathbf{K}_e \\|_F / \\max(\\| \\mathbf{K}_e \\|_F, \\varepsilon)$, with $\\varepsilon$ being a small constant to prevent division by zero.\n5.  A test is declared \"passed\" if both $\\Delta_\\infty \\le \\mathrm{abs\\_tol}$ and $\\Delta_{\\mathrm{rel}} \\le \\mathrm{rel\\_tol}$ for the supplied tolerances.\n\n**4. Implementation and Test Execution**\n\nThe test harness is implemented in Python, using the `numpy` library for matrix operations. Functions for computing the T3 and Q4 stiffness matrices are created. A main routine orchestrates the process: it iterates through the four specified test cases, applies the transformations, computes the reference and transformed stiffness matrices, evaluates the pass/fail criteria based on the given tolerances, and aggregates the boolean results.\n- Test Cases $\\#1$ and $\\#2$ represent well-behaved elements and are expected to pass with stringent tolerances, confirming the correct implementation of the underlying theory.\n- Test Case $\\#3$ probes the numerical stability of the Q4 implementation when subjected to a large translation, which can induce loss-of-precision errors.\n- Test Case $\\#4$ tests the robustness of the T3 formulation when dealing with a near-degenerate geometry, which leads to an ill-conditioned problem that amplifies roundoff errors.\n\nThe final output is a single list containing the boolean pass/fail indicators for translation and rotation invariance for each of the four test cases, in the specified order.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_d_plane_stress(E, nu):\n    \"\"\"\n    Computes the constitutive matrix for plane stress.\n    \"\"\"\n    factor = E / (1.0 - nu**2)\n    D = np.array([\n        [1.0, nu, 0.0],\n        [nu, 1.0, 0.0],\n        [0.0, 0.0, (1.0 - nu) / 2.0]\n    ])\n    return factor * D\n\ndef get_ke_t3(nodes, E, nu, t):\n    \"\"\"\n    Computes the stiffness matrix for a 3-node linear triangle (T3).\n    \"\"\"\n    D = get_d_plane_stress(E, nu)\n    \n    x1, y1 = nodes[0]\n    x2, y2 = nodes[1]\n    x3, y3 = nodes[2]\n    \n    # The B matrix formulation relies on the signed area.\n    area_signed = 0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # If the element is degenerate, the area is zero.\n    if abs(area_signed)  1e-30:\n        return np.zeros((6, 6))\n\n    # The integration volume must be positive.\n    area = abs(area_signed)\n    \n    B = np.zeros((3, 6))\n    B[0, 0] = y2 - y3; B[0, 2] = y3 - y1; B[0, 4] = y1 - y2\n    B[1, 1] = x3 - x2; B[1, 3] = x1 - x3; B[1, 5] = x2 - x1\n    B[2, 0] = x3 - x2; B[2, 1] = y2 - y3\n    B[2, 2] = x1 - x3; B[2, 3] = y3 - y1\n    B[2, 4] = x2 - x1; B[2, 5] = y1 - y2\n    \n    B /= (2.0 * area_signed)\n    \n    K_e = B.T @ D @ B * area * t\n    return K_e\n\ndef get_ke_q4(nodes, E, nu, t):\n    \"\"\"\n    Computes the stiffness matrix for a 4-node bilinear quadrilateral (Q4)\n    using 2x2 Gaussian quadrature.\n    \"\"\"\n    D = get_d_plane_stress(E, nu)\n    K_e = np.zeros((8, 8))\n    \n    gauss_pt = 1.0 / np.sqrt(3.0)\n    gauss_points = [\n        (-gauss_pt, -gauss_pt),\n        ( gauss_pt, -gauss_pt),\n        ( gauss_pt,  gauss_pt),\n        (-gauss_pt,  gauss_pt)\n    ]\n    # All quadrature weights are 1.0 for this scheme.\n    \n    # Nodal coordinates in parent domain for CCW node ordering from (-1,-1)\n    xi_node_coords = np.array([-1.0, 1.0, 1.0, -1.0])\n    eta_node_coords = np.array([-1.0, -1.0, 1.0, 1.0])\n\n    for xi, eta in gauss_points:\n        # Derivatives of shape functions wrt parent coordinates (d/d_xi, d/d_eta)\n        dNd_parent = np.zeros((4, 2))\n        dNd_parent[:, 0] = 0.25 * xi_node_coords * (1.0 + eta_node_coords * eta)\n        dNd_parent[:, 1] = 0.25 * eta_node_coords * (1.0 + xi_node_coords * xi)\n        \n        # Jacobian matrix\n        J = dNd_parent.T @ nodes\n        \n        detJ = np.linalg.det(J)\n        if detJ = 0:\n            # Invalid element mapping (e.g., concave or twisted)\n            # For this problem, we assume valid convex elements.\n            # In a real code, an error or warning should be raised.\n            return np.zeros((8, 8))\n            \n        invJ = np.linalg.inv(J)\n        \n        # Derivatives of shape functions wrt physical coordinates (d/dx, d/dy)\n        dNd_phys = invJ @ dNd_parent.T\n\n        # Strain-displacement matrix B\n        B = np.zeros((3, 8))\n        for i in range(4):\n            dNi_dx = dNd_phys[0, i]\n            dNi_dy = dNd_phys[1, i]\n            B[0, 2 * i]     = dNi_dx\n            B[1, 2 * i + 1] = dNi_dy\n            B[2, 2 * i]     = dNi_dy\n            B[2, 2 * i + 1] = dNi_dx\n            \n        K_e += B.T @ D @ B * detJ * t\n        \n    return K_e\n\ndef check_pass(K_star, K_ref, abs_tol, rel_tol):\n    \"\"\"\n    Checks if the transformed matrix K_star is close to the reference K_ref.\n    \"\"\"\n    eps = 1e-15 # Small value to prevent division by zero\n    diff = K_star - K_ref\n    \n    # Absolute metric\n    abs_dev = np.max(np.abs(diff))\n    \n    # Relative metric\n    norm_ref = np.linalg.norm(K_ref, 'fro')\n    norm_diff = np.linalg.norm(diff, 'fro')\n    rel_dev = norm_diff / max(norm_ref, eps)\n    \n    return abs_dev = abs_tol and rel_dev = rel_tol\n\ndef solve():\n    \"\"\"\n    Main test harness to run all specified test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"type\": \"T3\", \"nodes\": np.array([[0.0, 0.0], [1.2, 0.3], [0.2, 0.9]]),\n            \"E\": 210e9, \"nu\": 0.3, \"t\": 0.01,\n            \"theta\": np.pi / 3, \"trans\": np.array([5.0, -3.0]),\n            \"abs_tol\": 1e-10, \"rel_tol\": 1e-10\n        },\n        {\n            \"type\": \"Q4\", \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"E\": 70e9, \"nu\": 0.33, \"t\": 0.05,\n            \"theta\": np.pi / 4, \"trans\": np.array([0.0, 0.0]),\n            \"abs_tol\": 1e-11, \"rel_tol\": 1e-11\n        },\n        {\n            \"type\": \"Q4\", \"nodes\": np.array([[0.0, 0.0], [2.0, 0.2], [1.8, 1.1], [-0.1, 1.0]]),\n            \"E\": 1.0e5, \"nu\": 0.25, \"t\": 0.1,\n            \"theta\": 1e-6, \"trans\": np.array([1e6, -1e6]),\n            \"abs_tol\": 1e-8, \"rel_tol\": 1e-8\n        },\n        {\n            \"type\": \"T3\", \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1e-6, 1e-6]]),\n            \"E\": 200e9, \"nu\": 0.29, \"t\": 0.02,\n            \"theta\": 2.0, \"trans\": np.array([1000.0, -1000.0]),\n            \"abs_tol\": 1e-6, \"rel_tol\": 1e-6\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        E, nu, t = case[\"E\"], case[\"nu\"], case[\"t\"]\n        \n        get_ke = get_ke_t3 if case[\"type\"] == \"T3\" else get_ke_q4\n        \n        # 1. Compute reference stiffness matrix\n        K_ref = get_ke(nodes, E, nu, t)\n        \n        # 2. Test translation invariance\n        trans_vec = case[\"trans\"]\n        nodes_trans = nodes + trans_vec\n        K_trans = get_ke(nodes_trans, E, nu, t)\n        trans_pass = check_pass(K_trans, K_ref, case[\"abs_tol\"], case[\"rel_tol\"])\n        results.append(trans_pass)\n        \n        # 3. Test rotation invariance\n        theta = case[\"theta\"]\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        nodes_rot = (R @ nodes.T).T\n        K_rot = get_ke(nodes_rot, E, nu, t)\n        rot_pass = check_pass(K_rot, K_ref, case[\"abs_tol\"], case[\"rel_tol\"])\n        results.append(rot_pass)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "answer": "[True,True,True,True,True,True,True,True]", "id": "2639900"}, {"introduction": "With verified elements in hand, we can now assemble them to solve a complete boundary value problem. This practice involves building a small axisymmetric FEM solver to analyze a classic benchmark: a pressurized thick-walled cylinder. You will implement the full workflow, from assembling element matrices in a cylindrical coordinate system to applying pressure loads and comparing your numerical results against a derived analytical solution. This capstone exercise not only demonstrates the power of FEM for solving real-world engineering problems but also highlights potential numerical issues like element locking, a critical concept in advanced element technology.", "problem": "Implement a small, self-contained axisymmetric Finite Element Method (FEM) solver using four-node bilinear quadrilateral (Q4) elements to approximate the radial displacement in a long, pressurized thick-walled cylinder under plane strain conditions. The goal is to compute the radial displacement field and compare it against the analytical solution derived from the fundamental equations of equilibrium and linear elasticity. The comparison must be quantified by a relative $L^{2}$-type error norm over the cross-sectional domain.\n\nConsider a long cylinder with inner radius $a$ and outer radius $b$, made of a homogeneous, isotropic, linear elastic material with Young’s modulus $E$ and Poisson’s ratio $\\nu$. The loading consists of a uniform internal pressure $p_{i}$ applied on the inner cylindrical surface $r=a$ and a uniform external pressure $p_{o}$ applied on the outer cylindrical surface $r=b$. Assume small strains and plane strain in the axial direction, i.e., the axial strain $\\varepsilon_{z}=0$. Use an axisymmetric formulation in cylindrical coordinates with the cross-section in the $(r,z)$-plane, where $r\\in[a,b]$ and $z\\in[0,L]$ with $L=1$. Enforce plane strain by constraining the axial displacement $u_{z}=0$ everywhere.\n\nDiscretization requirements:\n- Use isoparametric Q4 elements with standard bilinear shape functions on the reference square. Use $2\\times 2$ Gaussian quadrature for element stiffness and volume terms, and $2$-point Gauss quadrature for boundary traction integrals.\n- Use the axisymmetric weak form, where all integrals are weighted by the radius $r$ and include the circumferential factor $2\\pi$. Specifically, the element stiffness must be assembled from\n$$\n\\mathbf{K}_{e}=\\int_{\\Omega_{e}} \\left(\\mathbf{B}^{T}\\mathbf{D}\\mathbf{B}\\right)\\, 2\\pi r \\, \\mathrm{d}A,\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix for axisymmetry with strain components $\\varepsilon_{r}$, $\\varepsilon_{z}$, $\\varepsilon_{\\theta}$, $\\gamma_{rz}$, and $\\mathbf{D}$ is the isotropic elasticity matrix in axisymmetric form using Lamé parameters $\\lambda$ and $\\mu$ with $\\mu= \\dfrac{E}{2(1+\\nu)}$ and $\\lambda=\\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$.\n- Apply the Neumann boundary conditions on $r=a$ and $r=b$ via consistent boundary integrals of the form\n$$\n\\mathbf{f}_{e}^{(\\text{traction})}=\\int_{\\Gamma_{e}} \\mathbf{N}^{T}\\,\\mathbf{t}\\, 2\\pi r\\, \\mathrm{d}\\ell,\n$$\nwith $\\mathbf{t}=\\left[+p_{i},\\,0\\right]^{T}$ on $r=a$ and $\\mathbf{t}=\\left[-p_{o},\\,0\\right]^{T}$ on $r=b$. Here $\\mathbf{N}$ is the matrix of shape functions mapping nodal displacements to the displacement field, and $\\mathrm{d}\\ell$ is the line element along the boundary edge in the $(r,z)$-plane.\n\nAnalytical target:\n- Starting from the axisymmetric radial equilibrium equation, the strain-displacement relations, and Hooke’s law (do not assume any target formula), derive the analytical expression for the radial displacement $u_{\\text{an}}(r)$ under plane strain for given $(a,b,p_{i},p_{o},E,\\nu)$.\n\nError metric:\n- Define the relative $L^{2}$-type error over the cross-section by\n$$\n\\varepsilon_{\\text{rel}}=\\frac{\\left(\\int_{\\Omega} \\left(u_{h}(r,z)-u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}}{\\left(\\int_{\\Omega} \\left(u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}},\n$$\nwhere $u_{h}$ is the FEM radial displacement solution and $u_{\\text{an}}$ is the analytical radial displacement. Use $2\\times 2$ Gaussian quadrature per element to approximate these integrals numerically. The error $\\varepsilon_{\\text{rel}}$ is dimensionless.\n\nBoundary conditions and constraints:\n- Enforce plane strain by prescribing $u_{z}=0$ at all nodes.\n- No additional displacement constraints in the radial direction are to be imposed.\n\nTest suite:\nRun your solver for the following four test cases, using the specified units (all in the International System of Units). The axial length is $L=1$ in meters for all cases. For each case, discretize the domain with $N_{r}$ elements in the radial direction and $N_{z}$ elements in the axial direction.\n\n$1.$ Case A (happy path, moderate mesh):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.0\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.30$, $N_{r}=8$, $N_{z}=3$.\n\n$2.$ Case B (coarse mesh edge case):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.0\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.30$, $N_{r}=1$, $N_{z}=1$.\n\n$3.$ Case C (nonzero external pressure):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.60\\times 10^{6}\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.30$, $N_{r}=6$, $N_{z}=2$.\n\n$4.$ Case D (near-incompressible material to expose locking in plane strain with Q4):\n- $a = 0.3\\,\\text{m}$, $b=1.0\\,\\text{m}$, $p_{i}=1.25\\times 10^{6}\\,\\text{Pa}$, $p_{o}=0.0\\,\\text{Pa}$, $E=200\\times 10^{9}\\,\\text{Pa}$, $\\nu=0.49$, $N_{r}=8$, $N_{z}=2$.\n\nFinal output format:\nYour program must produce a single line of output containing the four relative errors for Cases A–D as a comma-separated list enclosed in square brackets, for example\n$[\\varepsilon_{A},\\varepsilon_{B},\\varepsilon_{C},\\varepsilon_{D}]$,\nwith each entry formatted as a decimal number rounded to exactly six digits after the decimal point. The relative error is dimensionless, so no physical units are required in the output. There must be no other output.\n\nNotes:\n- Angles are not used in the input or output, so no angle unit is required.\n- All inputs use the International System of Units, but the requested outputs are dimensionless numbers as specified.", "solution": "The user requires the development of an axisymmetric Finite Element Method (FEM) solver for a thick-walled pressurized cylinder under plane strain conditions. The problem is well-posed and scientifically sound, representing a classic problem in linear elasticity. The process involves two main stages: first, the derivation of the analytical solution for validation, and second, the formulation and implementation of the FEM solver.\n\nFirst, we derive the analytical solution for the radial displacement $u_r(r)$. The problem is axisymmetric, so displacements and stresses do not vary with the circumferential coordinate $\\theta$. The cylinder is assumed to be long, and plane strain conditions are imposed, meaning the axial strain $\\varepsilon_z = 0$. Due to uniform loading along the length, the radial displacement $u_r$ depends only on the radial coordinate $r$, so $u_r = u_r(r)$.\n\nThe radial and circumferential strains are given by:\n$$\n\\varepsilon_r = \\frac{du_r}{dr}, \\quad \\varepsilon_\\theta = \\frac{u_r}{r}\n$$\nThe axial strain is $\\varepsilon_z = 0$. The shear strain $\\gamma_{rz}$ is also zero due to axial symmetry and uniform loading.\n\nThe governing equation is the radial equilibrium equation in cylindrical coordinates, which simplifies to:\n$$\n\\frac{d\\sigma_r}{dr} + \\frac{\\sigma_r - \\sigma_\\theta}{r} = 0\n$$\nwhere $\\sigma_r$ and $\\sigma_\\theta$ are the radial and circumferential (hoop) stresses.\n\nUnder plane strain conditions ($\\varepsilon_z=0$), Hooke's law relating stresses and strains for an isotropic material is:\n$$\n\\sigma_r = \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ (1-\\nu)\\varepsilon_r + \\nu\\varepsilon_\\theta \\right] = (\\lambda + 2\\mu)\\varepsilon_r + \\lambda\\varepsilon_\\theta \\\\\n\\sigma_\\theta = \\frac{E}{(1+\\nu)(1-2\\nu)} \\left[ \\nu\\varepsilon_r + (1-\\nu)\\varepsilon_\\theta \\right] = \\lambda\\varepsilon_r + (\\lambda + 2\\mu)\\varepsilon_\\theta \\\\\n\\sigma_z = \\nu(\\sigma_r + \\sigma_\\theta) = \\lambda(\\varepsilon_r + \\varepsilon_\\theta)\n$$\nwhere $E$ is Young's modulus, $\\nu$ is Poisson's ratio, and $\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\frac{E}{2(1+\\nu)}$ are Lamé's parameters.\n\nSubstituting the strain-displacement relations into the stress expressions, and then into the equilibrium equation, yields a second-order ordinary differential equation for $u_r(r)$:\n$$\n\\frac{d^2u_r}{dr^2} + \\frac{1}{r}\\frac{du_r}{dr} - \\frac{u_r}{r^2} = 0\n$$\nThis is a Cauchy-Euler equation with the general solution of the form:\n$$\nu_r(r) = C_1 r + \\frac{C_2}{r}\n$$\nThe constants of integration, $C_1$ and $C_2$, are determined from the boundary conditions on the radial stress:\n$$\n\\sigma_r(r=a) = -p_i, \\quad \\sigma_r(r=b) = -p_o\n$$\nSubstituting the general solution for $u_r(r)$ into the expression for $\\sigma_r$ gives:\n$$\n\\sigma_r(r) = 2(\\lambda+\\mu)C_1 - \\frac{2\\mu C_2}{r^2}\n$$\nApplying the boundary conditions yields a system of two linear equations for $C_1$ and $C_2$:\n$$\n-p_i = 2(\\lambda+\\mu)C_1 - \\frac{2\\mu C_2}{a^2} \\\\\n-p_o = 2(\\lambda+\\mu)C_1 - \\frac{2\\mu C_2}{b^2}\n$$\nSolving this system gives:\n$$\nC_1 = \\frac{p_ia^2 - p_ob^2}{2(\\lambda+\\mu)(b^2-a^2)} = \\frac{(1+\\nu)(1-2\\nu)}{E} \\frac{p_ia^2-p_ob^2}{b^2-a^2} \\\\\nC_2 = \\frac{(p_i-p_o)a^2b^2}{2\\mu(b^2-a^2)} = \\frac{1+\\nu}{E} \\frac{(p_i-p_o)a^2b^2}{b^2-a^2}\n$$\nFinally, the analytical solution for the radial displacement is:\n$$\nu_{\\text{an}}(r) = \\frac{1+\\nu}{E(b^2-a^2)} \\left[ (1-2\\nu)(p_ia^2-p_ob^2)r + (p_i-p_o)\\frac{a^2b^2}{r} \\right]\n$$\n\nNext, we establish the Finite Element formulation. The domain is discretized using four-node bilinear quadrilateral (Q4) elements. The displacement field within an element is interpolated from the nodal displacements $\\mathbf{d}^e$ using shape functions $\\mathbf{N}$:\n$$\n\\mathbf{u}(r,z) = \\begin{Bmatrix} u_r \\\\ u_z \\end{Bmatrix} = \\mathbf{N}\\mathbf{d}^e = \\sum_{i=1}^{4} \\mathbf{N}_i \\mathbf{d}_i\n$$\nwhere $\\mathbf{N}_i = \\begin{bmatrix} N_i  0 \\\\ 0  N_i \\end{bmatrix}$ and $\\mathbf{d}_i=\\begin{Bmatrix} u_r^i \\\\ u_z^i \\end{Bmatrix}$. The shape functions $N_i(\\xi, \\eta)$ are defined on the reference square $[-1,1] \\times [-1,1]$.\n\nThe axisymmetric strain vector is $\\boldsymbol{\\varepsilon} = [\\varepsilon_r, \\varepsilon_z, \\varepsilon_\\theta, \\gamma_{rz}]^T$. The strains are related to nodal displacements via the strain-displacement matrix $\\mathbf{B}$: $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}^e$. For node $i$, the matrix $\\mathbf{B}_i$ is:\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial r}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial z} \\\\ \\frac{N_i}{r}  0 \\\\ \\frac{\\partial N_i}{\\partial z}  \\frac{\\partial N_i}{\\partial r} \\end{bmatrix}\n$$\nThe derivatives of the shape functions with respect to global coordinates $(r,z)$ are obtained from derivatives with respect to local coordinates $(\\xi,\\eta)$ using the Jacobian of the isoparametric mapping: $\\begin{Bmatrix} \\partial/\\partial r \\\\ \\partial/\\partial z \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{Bmatrix}$.\n\nThe constitutive matrix $\\mathbf{D}$ relates the stress vector $\\boldsymbol{\\sigma} = [\\sigma_r, \\sigma_z, \\sigma_\\theta, \\tau_{rz}]^T$ to the strain vector $\\boldsymbol{\\varepsilon}$ via $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$. For an isotropic material, this matrix is:\n$$\n\\mathbf{D} = \\begin{bmatrix}\n\\lambda+2\\mu  \\lambda  \\lambda  0 \\\\\n\\lambda  \\lambda+2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda  \\lambda+2\\mu  0 \\\\\n0  0  0  \\mu\n\\end{bmatrix}\n$$\nThe element stiffness matrix $\\mathbf{K}_e$ is computed by integrating over the element volume in cylindrical coordinates:\n$$\n\\mathbf{K}_{e} = \\int_{\\Omega_{e}} \\mathbf{B}^{T}\\mathbf{D}\\mathbf{B} \\, 2\\pi r \\, dA = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^{T}\\mathbf{D}\\mathbf{B} \\, 2\\pi r(\\xi,\\eta) \\, |\\det(\\mathbf{J})| \\, d\\xi d\\eta\n$$\nThis integral is evaluated numerically using $2 \\times 2$ Gaussian quadrature.\n\nThe external pressures are applied as Neumann boundary conditions. The consistent nodal force vector for an element edge $\\Gamma_e$ is:\n$$\n\\mathbf{f}_{e}^{(\\text{traction})} = \\int_{\\Gamma_{e}} \\mathbf{N}^{T} \\mathbf{t} \\, 2\\pi r \\, d\\ell\n$$\nFor an edge on the inner boundary $r=a$, the traction is $\\mathbf{t} = [p_i, 0]^T$. For the outer boundary $r=b$, $\\mathbf{t} = [-p_o, 0]^T$. These line integrals are evaluated using $2$-point Gaussian quadrature.\n\nAfter assembling the global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$, the system $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$ is solved for the global displacement vector $\\mathbf{U}$. The plane strain condition is enforced by constraining the axial displacements $u_z=0$ for all nodes. This is achieved by modifying the global system of equations before solving.\n\nFinally, the relative error between the FEM solution $u_h$ and the analytical solution $u_{\\text{an}}$ is calculated using the specified $L^2$-type norm:\n$$\n\\varepsilon_{\\text{rel}} = \\frac{\\|u_h - u_{\\text{an}}\\|_{L^2(\\Omega)}}{\\|u_{\\text{an}}\\|_{L^2(\\Omega)}} = \\frac{\\left(\\int_{\\Omega} \\left(u_{h}(r,z)-u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}}{\\left(\\int_{\\Omega} \\left(u_{\\text{an}}(r)\\right)^{2}\\, 2\\pi r \\,\\mathrm{d}A\\right)^{1/2}}\n$$\nThe integrals for the error norm are also computed numerically using $2 \\times 2$ Gaussian quadrature over each element.\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n\n    # Gauss quadrature points and weights\n    # 2x2 for area integrals\n    gauss_pts_2d = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_wts_2d = np.array([1.0, 1.0])\n    # 2-point for line integrals\n    gauss_pts_1d = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_wts_1d = np.array([1.0, 1.0])\n\n    def analytical_displacement(r, a, b, pi, po, E, nu):\n        \"\"\"Calculates the analytical radial displacement for plane strain.\"\"\"\n        if abs(b**2 - a**2)  1e-12:\n            return np.zeros_like(r)\n        \n        # Coefficients from derivation\n        C1_num = pi * a**2 - po * b**2\n        C1_den = b**2 - a**2\n        C1_factor = (1 + nu) * (1 - 2 * nu) / E\n        C1 = C1_factor * C1_num / C1_den\n\n        C2_num = (pi - po) * a**2 * b**2\n        C2_den = b**2 - a**2\n        C2_factor = (1 + nu) / E\n        C2 = C2_factor * C2_num / C2_den\n        \n        return C1 * r + C2 / r\n\n    def shape_functions(xi, eta):\n        \"\"\"Computes Q4 shape functions and their derivatives in local coordinates.\"\"\"\n        N = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n        dNdxi = 0.25 * np.array([-(1-eta), (1-eta), (1+eta), -(1+eta)])\n        dNdeta = 0.25 * np.array([-(1-xi), -(1+xi), (1+xi), (1-xi)])\n        return N, dNdxi, dNdeta\n\n    def run_fem_case(a, b, L, pi, po, E, nu, Nr, Nz):\n        \"\"\"Runs a single FEM simulation case.\"\"\"\n        \n        # Material properties\n        lame_lambda = E * nu / ((1 + nu) * (1 - 2 * nu))\n        lame_mu = E / (2 * (1 + nu))\n\n        D = np.array([\n            [lame_lambda + 2*lame_mu, lame_lambda, lame_lambda, 0],\n            [lame_lambda, lame_lambda + 2*lame_mu, lame_lambda, 0],\n            [lame_lambda, lame_lambda, lame_lambda + 2*lame_mu, 0],\n            [0, 0, 0, lame_mu]\n        ])\n\n        # Mesh generation\n        num_nodes = (Nr + 1) * (Nz + 1)\n        num_elements = Nr * Nz\n        node_coords = np.zeros((num_nodes, 2))\n        r_nodes = np.linspace(a, b, Nr + 1)\n        z_nodes = np.linspace(0, L, Nz + 1)\n        \n        for i in range(Nr + 1):\n            for j in range(Nz + 1):\n                node_idx = i * (Nz + 1) + j\n                node_coords[node_idx] = [r_nodes[i], z_nodes[j]]\n\n        elements = np.zeros((num_elements, 4), dtype=int)\n        for i in range(Nr):\n            for j in range(Nz):\n                el_idx = i * Nz + j\n                n1 = i * (Nz + 1) + j\n                n2 = (i + 1) * (Nz + 1) + j\n                n3 = (i + 1) * (Nz + 1) + (j + 1)\n                n4 = i * (Nz + 1) + (j + 1)\n                elements[el_idx] = [n1, n2, n3, n4]\n        \n        # Assembly\n        num_dofs = 2 * num_nodes\n        K_global = np.zeros((num_dofs, num_dofs))\n        F_global = np.zeros(num_dofs)\n\n        # Element loop for stiffness matrix\n        for el_nodes in elements:\n            el_coords = node_coords[el_nodes]\n            Ke = np.zeros((8, 8))\n            \n            for gp_xi in gauss_pts_2d:\n                for gp_eta in gauss_pts_2d:\n                    N_vec, dNdxi_vec, dNdeta_vec = shape_functions(gp_xi, gp_eta)\n                    \n                    J = np.zeros((2, 2))\n                    J[0, 0] = np.dot(dNdxi_vec, el_coords[:, 0]) # dr/dxi\n                    J[0, 1] = np.dot(dNdxi_vec, el_coords[:, 1]) # dz/dxi\n                    J[1, 0] = np.dot(dNdeta_vec, el_coords[:, 0])# dr/deta\n                    J[1, 1] = np.dot(dNdeta_vec, el_coords[:, 1])# dz/deta\n\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    \n                    dN_drz = invJ @ np.vstack([dNdxi_vec, dNdeta_vec])\n                    dNdr_vec = dN_drz[0, :]\n                    dNdz_vec = dN_drz[1, :]\n                    \n                    r_gp = np.dot(N_vec, el_coords[:, 0])\n\n                    B = np.zeros((4, 8))\n                    for i in range(4):\n                        B[0, 2*i] = dNdr_vec[i]\n                        B[1, 2*i+1] = dNdz_vec[i]\n                        B[2, 2*i] = N_vec[i] / r_gp\n                        B[3, 2*i] = dNdz_vec[i]\n                        B[3, 2*i+1] = dNdr_vec[i]\n                    \n                    Ke += B.T @ D @ B * (2 * np.pi * r_gp) * detJ * 1.0 * 1.0 # weights are 1.0\n\n            # Assemble Ke into K_global\n            dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n            K_global[np.ix_(dof_indices, dof_indices)] += Ke\n\n        # Boundary conditions (Traction)\n        # Inner pressure on r = a\n        if pi > 0:\n            for i in range(Nz):\n                el_idx = i\n                el_nodes = elements[el_idx] # these are elements [0, i]\n                # Edge is between node 1 (local) and 4 (local) i.e. xi = -1\n                edge_nodes = [el_nodes[0], el_nodes[3]]\n                edge_coords = node_coords[edge_nodes]\n                \n                Fe_trac = np.zeros(8)\n                t = np.array([pi, 0])\n                \n                dz_deta = (edge_coords[1, 1] - edge_coords[0, 1]) / 2.0\n                dl = np.sqrt(dz_deta**2)\n\n                for gp_eta in gauss_pts_1d:\n                    eta_local_edge = gp_eta\n                    xi_local_edge = -1.0\n                    N_vec, _, _ = shape_functions(xi_local_edge, eta_local_edge)\n                    r_gp = np.dot(N_vec, node_coords[el_nodes, 0])\n                    \n                    for i_node in range(4):\n                        Fe_trac[2*i_node:2*i_node+2] += N_vec[i_node] * t * (2*np.pi*r_gp) * dl * 1.0\n\n                dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n                F_global[dof_indices] += Fe_trac\n\n        # Outer pressure on r = b\n        if po > 0:\n            for i in range(Nz):\n                el_idx = (Nr - 1) * Nz + i\n                el_nodes = elements[el_idx]\n                # Edge is between node 2 and 3 i.e. xi = 1\n                edge_nodes = [el_nodes[1], el_nodes[2]]\n                edge_coords = node_coords[edge_nodes]\n                \n                Fe_trac = np.zeros(8)\n                t = np.array([-po, 0])\n                \n                dz_deta = (edge_coords[1, 1] - edge_coords[0, 1]) / 2.0\n                dl = np.sqrt(dz_deta**2)\n                \n                for gp_eta in gauss_pts_1d:\n                    eta_local_edge = gp_eta\n                    xi_local_edge = 1.0\n                    N_vec, _, _ = shape_functions(xi_local_edge, eta_local_edge)\n                    r_gp = np.dot(N_vec, node_coords[el_nodes, 0])\n                    \n                    for i_node in range(4):\n                        Fe_trac[2*i_node:2*i_node+2] += N_vec[i_node] * t * (2*np.pi*r_gp) * dl * 1.0\n\n                dof_indices = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n                F_global[dof_indices] += Fe_trac\n        \n        # Enforce u_z = 0 for all nodes\n        for i in range(num_nodes):\n            dof = 2 * i + 1\n            K_global[dof, :] = 0\n            K_global[:, dof] = 0\n            K_global[dof, dof] = 1.0\n            F_global[dof] = 0\n        \n        # Solve system\n        U = np.linalg.solve(K_global, F_global)\n\n        # Error calculation\n        err_num_sq = 0.0\n        err_den_sq = 0.0\n        \n        for el_nodes in elements:\n            el_coords = node_coords[el_nodes]\n            el_dofs = np.array([[2*n, 2*n+1] for n in el_nodes]).flatten()\n            el_U = U[el_dofs]\n            el_Ur = el_U[::2]\n\n            for gp_xi in gauss_pts_2d:\n                for gp_eta in gauss_pts_2d:\n                    N_vec, dNdxi_vec, dNdeta_vec = shape_functions(gp_xi, gp_eta)\n                    \n                    J = np.zeros((2, 2))\n                    J[0, 0] = np.dot(dNdxi_vec, el_coords[:, 0])\n                    J[0, 1] = np.dot(dNdxi_vec, el_coords[:, 1])\n                    J[1, 0] = np.dot(dNdeta_vec, el_coords[:, 0])\n                    J[1, 1] = np.dot(dNdeta_vec, el_coords[:, 1])\n                    detJ = np.linalg.det(J)\n                    \n                    r_gp = np.dot(N_vec, el_coords[:, 0])\n                    \n                    u_h = np.dot(N_vec, el_Ur)\n                    u_an = analytical_displacement(r_gp, a, b, pi, po, E, nu)\n                    \n                    integrand_factor = 2 * np.pi * r_gp * detJ * 1.0 * 1.0\n\n                    err_num_sq += (u_h - u_an)**2 * integrand_factor\n                    err_den_sq += u_an**2 * integrand_factor\n\n        if err_den_sq  1e-30:\n            return 0.0\n            \n        return np.sqrt(err_num_sq / err_den_sq)\n\n\n    # Test cases\n    test_cases = [\n        # Case A\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.0, 'E': 200e9, 'nu': 0.30, 'Nr': 8, 'Nz': 3, 'L': 1.0},\n        # Case B\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.0, 'E': 200e9, 'nu': 0.30, 'Nr': 1, 'Nz': 1, 'L': 1.0},\n        # Case C\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.60e6, 'E': 200e9, 'nu': 0.30, 'Nr': 6, 'Nz': 2, 'L': 1.0},\n        # Case D\n        {'a': 0.3, 'b': 1.0, 'pi': 1.25e6, 'po': 0.0, 'E': 200e9, 'nu': 0.49, 'Nr': 8, 'Nz': 2, 'L': 1.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_fem_case(**case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```", "answer": "[0.000305,0.082725,0.000624,0.027091]", "id": "2639858"}]}