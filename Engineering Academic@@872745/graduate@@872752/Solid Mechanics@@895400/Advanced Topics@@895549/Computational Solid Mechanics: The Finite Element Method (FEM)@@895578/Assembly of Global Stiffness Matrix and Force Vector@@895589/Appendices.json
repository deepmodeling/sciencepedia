{"hands_on_practices": [{"introduction": "The assembly of the global stiffness matrix is the cornerstone of the finite element method, translating a collection of discrete elements into a unified system model. This first practice provides a foundational, step-by-step exercise in this process. By manually combining two simple element stiffness matrices into a larger global matrix [@problem_id:2115177], you will gain a concrete understanding of how stiffness contributions are superimposed at shared nodes.", "problem": "Consider a one-dimensional mechanical system modeled with two distinct elements and three nodes, labeled 1, 2, and 3 in order.\n- Element (1) connects Node 1 and Node 2. Its behavior is described by a 2x2 element stiffness matrix, $k^{(1)}$, which relates the forces and displacements at its two nodes.\n- Element (2) connects Node 2 and Node 3. Its behavior is described by a 2x2 element stiffness matrix, $k^{(2)}$.\n\nThe given element stiffness matrices are:\n$$ k^{(1)} = \\begin{pmatrix} k_1 & -k_1 \\\\ -k_1 & k_1 \\end{pmatrix} \\quad \\text{and} \\quad k^{(2)} = \\begin{pmatrix} k_2 & -k_2 \\\\ -k_2 & k_2 \\end{pmatrix} $$\nHere, $k_1$ and $k_2$ are positive real constants representing the stiffness of each element.\n\nAssemble the 3x3 global stiffness matrix, $K$, for the entire three-node system. The global matrix relates the vector of global nodal forces, $F = (F_1, F_2, F_3)^T$, to the vector of global nodal displacements, $U = (u_1, u_2, u_3)^T$, through the equation $F = KU$.\n\nExpress your answer as a 3x3 matrix in terms of $k_1$ and $k_2$.", "solution": "We assemble the global stiffness matrix by superposition of element contributions using the standard finite element assembly principle. Let the global displacement vector be $U = (u_{1}, u_{2}, u_{3})^{T}$ and the global force vector be $F = (F_{1}, F_{2}, F_{3})^{T}$. For each element $(e)$ with local displacement vector $U^{(e)}$ and element stiffness matrix $k^{(e)}$, the contribution to the global stiffness matrix is formed via connectivity matrices $A^{(e)}$ such that $U^{(e)} = A^{(e)} U$ and\n$$\nK = \\sum_{e} A^{(e) T} k^{(e)} A^{(e)}.\n$$\n\nFor element $(1)$ connecting nodes $1$ and $2$, the connectivity matrix is\n$$\nA^{(1)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix}, \\quad k^{(1)} = \\begin{pmatrix} k_{1} & -k_{1} \\\\ -k_{1} & k_{1} \\end{pmatrix}.\n$$\nCompute\n$$\nk^{(1)} A^{(1)} = \\begin{pmatrix} k_{1} & -k_{1} \\\\ -k_{1} & k_{1} \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\end{pmatrix},\n$$\nthen\n$$\nK^{(1)} = A^{(1) T} \\left(k^{(1)} A^{(1)}\\right) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\end{pmatrix} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}.\n$$\n\nFor element $(2)$ connecting nodes $2$ and $3$, the connectivity matrix is\n$$\nA^{(2)} = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}, \\quad k^{(2)} = \\begin{pmatrix} k_{2} & -k_{2} \\\\ -k_{2} & k_{2} \\end{pmatrix}.\n$$\nCompute\n$$\nk^{(2)} A^{(2)} = \\begin{pmatrix} k_{2} & -k_{2} \\\\ -k_{2} & k_{2} \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix},\n$$\nthen\n$$\nK^{(2)} = A^{(2) T} \\left(k^{(2)} A^{(2)}\\right) = \\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}.\n$$\n\nSumming the element contributions gives the global stiffness matrix\n$$\nK = K^{(1)} + K^{(2)} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} + k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}.\n$$\nThis $K$ satisfies $F = K U$ for the three-node system.", "answer": "$$\\boxed{\\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1}+k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}}$$", "id": "2115177"}, {"introduction": "While manual assembly is instructive for simple systems, practical engineering problems require an algorithmic approach. This practice challenges you to translate the principle of superposition into a functional program that performs direct stiffness assembly [@problem_id:2378075]. Implementing the mapping from local element degrees of freedom to the global system will solidify your understanding of how complex structures are handled computationally.", "problem": "You are asked to implement a complete, runnable program that assembles the global stiffness matrix for linear elasticity from given element stiffness matrices and a connectivity array. The assembly must follow first principles of computational solid mechanics and linear elasticity and reflect how discrete equilibrium equations are constructed from contributions of each finite element.\n\nYour implementation must be based on the following fundamental base only:\n- The principle of virtual work, which, upon spatial discretization with suitable shape functions, leads to a linear system of the form $K u = f$, where $K$ is the global stiffness matrix, $u$ is the global displacement vector, and $f$ is the global force vector.\n- The definition of degrees of freedom (DOFs) per node, and the notion that each element contributes a local stiffness matrix that couples only the DOFs of its own nodes.\n\nDo not use any pre-derived assembly \"shortcut\" formula in the problem statement. Instead, infer from the above foundational principles that the global stiffness matrix emerges by summing, at the correct global DOF positions, all element contributions that act on the same global DOFs.\n\nYour program must:\n- Accept, as hard-coded data inside the program, a list of test cases. Each test case specifies:\n  - The number of nodes $N_{\\text{nodes}}$.\n  - The number of degrees of freedom per node $n_{\\text{dof}}$.\n  - A connectivity array listing, for each element, the global node indices that it connects. Node indices are zero-based.\n  - A list of element stiffness matrices $K_e$ of appropriate size, one per element, given in the International System of Units (SI) as newtons per meter ($\\mathrm{N/m}$). The global stiffness matrix must also be in $\\mathrm{N/m}$, but you must output the entries as pure numbers without printing units.\n- Map element-level DOFs to global DOFs using the definition that the $d$-th DOF ($d \\in \\{0,\\dots,n_{\\text{dof}}-1\\}$) of node $n$ corresponds to the global index $g = n \\cdot n_{\\text{dof}} + d$.\n- Assemble the global stiffness matrix by adding each element’s local stiffness matrix entries into their corresponding positions in the global matrix according to the connectivity mapping.\n- Produce, for each test case, the full assembled global stiffness matrix, flattened row-major into a single list of numbers.\n\nTest Suite (all stiffness values are in $\\mathrm{N/m}$; print raw numbers without the unit):\n\n- Test Case $1$ (one-dimensional bar elements, \"happy path\"):\n  - $N_{\\text{nodes}} = 3$, $n_{\\text{dof}} = 1$.\n  - Connectivity: two elements with node pairs $\\big(0,1\\big)$ and $\\big(1,2\\big)$.\n  - Element stiffness matrices:\n    - For element $\\big(0,1\\big)$: $K_e^{(1)} = 10 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n    - For element $\\big(1,2\\big)$: $K_e^{(2)} = 20 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n  - The global stiffness matrix has size $3 \\times 3$ and should be output as $9$ numbers.\n\n- Test Case $2$ (two-dimensional, two degrees of freedom per node, block-structured assembly):\n  - $N_{\\text{nodes}} = 3$, $n_{\\text{dof}} = 2$.\n  - Connectivity: two elements with node pairs $\\big(0,1\\big)$ and $\\big(1,2\\big)$.\n  - Element stiffness matrices (each $4 \\times 4$) of the form $k \\begin{bmatrix} I & -I \\\\ -I & I \\end{bmatrix}$, where $I$ is the $2 \\times 2$ identity:\n    - For element $\\big(0,1\\big)$: $k = 3$.\n    - For element $\\big(1,2\\big)$: $k = 5$.\n  - The global stiffness matrix has size $6 \\times 6$ and should be output as $36$ numbers.\n\n- Test Case $3$ (one-dimensional bar chain, interior accumulation, boundary condition edge behavior):\n  - $N_{\\text{nodes}} = 4$, $n_{\\text{dof}} = 1$.\n  - Connectivity: three elements with node pairs $\\big(0,1\\big)$, $\\big(1,2\\big)$, and $\\big(2,3\\big)$.\n  - Element stiffness matrices:\n    - $K_e^{(1)} = 2 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$,\n    - $K_e^{(2)} = 4 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$,\n    - $K_e^{(3)} = 6 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n  - The global stiffness matrix has size $4 \\times 4$ and should be output as $16$ numbers.\n\n- Test Case $4$ (nonconsecutive node indices and a $3$-node element):\n  - $N_{\\text{nodes}} = 4$, $n_{\\text{dof}} = 1$.\n  - Connectivity: one element with node triple $\\big(0,2,3\\big)$.\n  - Element stiffness matrix (a symmetric $3 \\times 3$ matrix):\n    - $K_e^{(1)} = \\begin{bmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{bmatrix}$.\n  - The global stiffness matrix has size $4 \\times 4$ and should be output as $16$ numbers.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item corresponds to one test case and is itself a list of the flattened global stiffness matrix entries in row-major order. For example, a line of the form $\\big[$ list for Test Case $1$, list for Test Case $2$, list for Test Case $3$, list for Test Case $4$ $\\big]$.\n- All numeric outputs must be printed as pure numbers representing $\\mathrm{N/m}$; do not print units, do not round or format in scientific notation unless necessary by the programming language defaults.", "solution": "The problem presented is to construct a global stiffness matrix, a fundamental procedure in the Finite Element Method (FEM) for linear elasticity. This task is not merely an exercise in programming but a direct implementation of the physical principle of superposition within a discretized continuum. The process is rigorously derived from the principle of virtual work, which culminates in a system of linear algebraic equations, $K u = f$.\n\nThe global stiffness matrix, denoted by $K$, relates the vector of global nodal displacements, $u$, to the vector of global nodal forces, $f$. The matrix $K$ encapsulates the stiffness properties of the entire discretized structure. It is formed by the systematic superposition of the stiffness contributions from each individual finite element. The total internal virtual work of a system is the sum of the internal virtual works of its constituent elements. This additivity principle directly translates to the assembly of the global stiffness matrix:\n$$\nK = \\sum_{e} \\mathcal{L}_e^T K_e \\mathcal{L}_e\n$$\nHere, $K_e$ is the stiffness matrix of element $e$ in its own local coordinate system, and $\\mathcal{L}_e$ is a Boolean locator matrix that maps the local degrees of freedom (DOFs) of element $e$ to their corresponding positions in the global system of DOFs. In computational practice, the explicit construction of $\\mathcal{L}_e$ is bypassed in favor of a more efficient direct stiffness assembly algorithm, which is what we will formalize.\n\nThe total number of degrees of freedom, $N_{DOF}$, in the system is the product of the number of nodes, $N_{\\text{nodes}}$, and the number of degrees of freedom per node, $n_{\\text{dof}}$. That is, $N_{DOF} = N_{\\text{nodes}} \\cdot n_{\\text{dof}}$. Consequently, the global stiffness matrix $K$ is a square matrix of size $N_{DOF} \\times N_{DOF}$. We begin by initializing $K$ as a zero matrix of this dimension.\n\nThe core of the assembly algorithm lies in the mapping from an element's local DOF indices to the system's global DOF indices. This mapping is governed by two pieces of information: the element's connectivity array and the defined ordering of DOFs at each node. The problem specifies a standard mapping: the $d$-th DOF (where $d$ is a zero-based index from $0$ to $n_{\\text{dof}}-1$) of global node $n$ corresponds to the global DOF index $g = n \\cdot n_{\\text{dof}} + d$.\n\nLet us consider a single element, $e$, which connects a set of $m$ nodes with global indices $\\{N_1, N_2, \\dots, N_m\\}$. The element stiffness matrix $K_e$ is of size $(m \\cdot n_{\\text{dof}}) \\times (m \\cdot n_{\\text{dof}})$. An entry $K_e[i, j]$ of this matrix represents the coupling between the $i$-th and $j$-th local DOFs of the element. Our objective is to add this contribution to the correct location in the global matrix $K$.\n\nThe local row index $i$ (from $0$ to $m \\cdot n_{\\text{dof}}-1$) corresponds to a specific DOF on a specific node of the element. We can decompose this index into a local node index, $a$, and a local DOF index, $p$, at that node. This is achieved through integer division and the modulo operation:\n- Local node index: $a = \\lfloor i / n_{\\text{dof}} \\rfloor$. Here, $a \\in \\{0, 1, \\dots, m-1\\}$.\n- Local DOF index at the node: $p = i \\pmod{n_{\\text{dof}}}$. Here, $p \\in \\{0, 1, \\dots, n_{\\text{dof}}-1\\}$.\n\nThe connectivity array for element $e$ provides the global node index corresponding to the local node index $a$. Let the connectivity be given as a tuple $(N_1, N_2, \\dots, N_m)$. The global node index, $N_a$, is the $(a+1)$-th entry in this tuple (using 1-based indexing for description, while computation uses 0-based).\n\nUsing the provided global DOF mapping rule, the global row index, $g_r$, corresponding to the local row index $i$ is:\n$$\ng_r = N_a \\cdot n_{\\text{dof}} + p\n$$\nSimilarly, for a local column index $j$, we determine the corresponding global column index, $g_c$:\n- Local node index: $b = \\lfloor j / n_{\\text{dof}} \\rfloor$.\n- Local DOF index: $q = j \\pmod{n_{\\text{dof}}}$.\n- Global node index: $N_b$.\n- Global column index: $g_c = N_b \\cdot n_{\\text{dof}} + q$.\n\nThe assembly rule is therefore the summation of contributions into the global matrix. For each element $e$, and for every entry $K_e[i, j]$ in its local stiffness matrix, we update the global stiffness matrix as follows:\n$$\nK[g_r, g_c] \\leftarrow K[g_r, g_c] + K_e[i, j]\n$$\nThis procedure is repeated for all elements in the mesh. The resulting matrix $K$ correctly represents the combined stiffness of the entire assembly, respecting the connectivity and shared degrees of freedom between elements. Nodes that share an element will have their corresponding entries in $K$ receive contributions from that element's stiffness matrix, correctly coupling their behavior. If a node is part of multiple elements, its diagonal term in the global stiffness matrix accumulates the stiffness contributions from all connected elements, which is a physical necessity.\n\nThe algorithm to be implemented is a direct translation of this logic:\n1.  Determine the total number of degrees of freedom, $N_{DOF} = N_{\\text{nodes}} \\cdot n_{\\text{dof}}$, and initialize the global stiffness matrix $K$ as a zero matrix of size $N_{DOF} \\times N_{DOF}$.\n2.  Iterate through each element $e$ provided in the input.\n3.  For each element, retrieve its connectivity array (the global indices of its nodes) and its element stiffness matrix $K_e$.\n4.  Iterate through each row $i$ and column $j$ of the element stiffness matrix $K_e$.\n5.  For each pair $(i, j)$, calculate the corresponding global row index $g_r$ and global column index $g_c$ using the mapping logic described above.\n6.  Add the value $K_e[i, j]$ to the entry $K[g_r, g_c]$ of the global stiffness matrix.\n7.  After iterating through all elements, the matrix $K$ is fully assembled. The final step is to flatten this matrix into a one-dimensional list in row-major order for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_stiffness(n_nodes, n_dof, connectivity, element_stiffness_matrices):\n    \"\"\"\n    Assembles the global stiffness matrix from element stiffness matrices.\n\n    Args:\n        n_nodes (int): The total number of nodes in the mesh.\n        n_dof (int): The number of degrees of freedom per node.\n        connectivity (list of tuples): A list where each tuple contains the \n                                       zero-based global node indices for an element.\n        element_stiffness_matrices (list of numpy.ndarray): A list of element \n                                                            stiffness matrices.\n\n    Returns:\n        numpy.ndarray: The assembled global stiffness matrix.\n    \"\"\"\n    total_dofs = n_nodes * n_dof\n    K_global = np.zeros((total_dofs, total_dofs), dtype=float)\n\n    # Iterate over each element to assemble its contribution to the global matrix\n    for elem_idx, elem_nodes in enumerate(connectivity):\n        K_e = element_stiffness_matrices[elem_idx]\n        num_elem_nodes = len(elem_nodes)\n        elem_dofs = num_elem_nodes * n_dof\n\n        # Map local DOFs to global DOFs and add stiffness contribution\n        for i in range(elem_dofs):\n            for j in range(elem_dofs):\n                # Decompose local DOF index 'i' into local node and local DOF type\n                local_node_row = i // n_dof\n                local_dof_row = i % n_dof\n                # Get the global node index from the connectivity array\n                global_node_row = elem_nodes[local_node_row]\n                # Calculate the global DOF index\n                global_dof_row = global_node_row * n_dof + local_dof_row\n\n                # Repeat for the column index 'j'\n                local_node_col = j // n_dof\n                local_dof_col = j % n_dof\n                global_node_col = elem_nodes[local_node_col]\n                global_dof_col = global_node_col * n_dof + local_dof_col\n\n                # Add the element's stiffness contribution to the global matrix\n                K_global[global_dof_row, global_dof_col] += K_e[i, j]\n                \n    return K_global\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for global stiffness matrix assembly.\n    \"\"\"\n    I2 = np.identity(2)\n    test_cases = [\n        # Test Case 1: 1D bar elements\n        {\n            \"n_nodes\": 3,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 1), (1, 2)],\n            \"element_stiffness_matrices\": [\n                10.0 * np.array([[1, -1], [-1, 1]]),\n                20.0 * np.array([[1, -1], [-1, 1]]),\n            ],\n        },\n        # Test Case 2: 2D elements with 2 DOFs/node\n        {\n            \"n_nodes\": 3,\n            \"n_dof\": 2,\n            \"connectivity\": [(0, 1), (1, 2)],\n            \"element_stiffness_matrices\": [\n                3.0 * np.block([[I2, -I2], [-I2, I2]]),\n                5.0 * np.block([[I2, -I2], [-I2, I2]]),\n            ],\n        },\n        # Test Case 3: 1D bar chain\n        {\n            \"n_nodes\": 4,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 1), (1, 2), (2, 3)],\n            \"element_stiffness_matrices\": [\n                2.0 * np.array([[1, -1], [-1, 1]]),\n                4.0 * np.array([[1, -1], [-1, 1]]),\n                6.0 * np.array([[1, -1], [-1, 1]]),\n            ],\n        },\n        # Test Case 4: Nonconsecutive nodes, 3-node element\n        {\n            \"n_nodes\": 4,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 2, 3)],\n            \"element_stiffness_matrices\": [\n                np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]]),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K_global = assemble_stiffness(\n            case[\"n_nodes\"],\n            case[\"n_dof\"],\n            case[\"connectivity\"],\n            case[\"element_stiffness_matrices\"],\n        )\n        # Flatten the matrix in row-major order and convert to a list of floats\n        flattened_list = K_global.flatten().tolist()\n        results.append(flattened_list)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2378075"}, {"introduction": "The way we number nodes during meshing has profound consequences for the efficiency of the finite element analysis. This exercise explores the relationship between node connectivity, the sparsity pattern of the global stiffness matrix, and solver performance [@problem_id:2615741]. By analyzing an inefficiently numbered mesh and applying a reordering algorithm, you will see firsthand how strategic indexing can dramatically reduce matrix bandwidth and, consequently, the computational cost of solving the system.", "problem": "Consider a one-dimensional, linearly elastic bar of length $L$ and constant Young's modulus $E$ and cross-sectional area $A$. The bar is discretized into $N$ nodes with $N = 12$ and $N-1 = 11$ two-node, $C^{0}$-continuous linear finite elements. Let the global stiffness matrix $K \\in \\mathbb{R}^{N \\times N}$ and the global force vector $f \\in \\mathbb{R}^{N}$ be assembled in the standard way from elemental contributions arising from the bilinear form $a(u,v) = \\int_{0}^{L} E A \\, u'(x) v'(x) \\, \\mathrm{d}x$. Ignore the application of essential (Dirichlet) boundary conditions for the purpose of sparsity analysis.\n\nThe element connectivity along the physical bar (from left to right) is given by the following node labels:\n$$\np = \\big( 1,\\, 12,\\, 2,\\, 11,\\, 3,\\, 10,\\, 4,\\, 9,\\, 5,\\, 8,\\, 6,\\, 7 \\big),\n$$\nmeaning that the $k$-th element connects node $p_{k}$ to node $p_{k+1}$ for each $k \\in \\{1,2,\\dots,11\\}$. This induces a symmetric sparsity graph in $K$ in which two degrees of freedom couple if and only if their corresponding nodes share at least one element.\n\nLet the half-bandwidth $b$ of a symmetric sparse matrix be defined by\n$$\nb \\equiv 1 + \\max_{\\substack{(i,j) \\\\ K_{ij} \\neq 0}} |i - j| \\,,\n$$\nwhich is equivalently $b = 1 + \\max_{\\substack{(i,j) \\\\ K_{ij} \\neq 0,\\, j \\ge i}} (j - i)$.\n\nTasks:\n1. Using only the fact that $K_{ij} \\neq 0$ if and only if nodes $i$ and $j$ appear together in at least one element, determine the set of off-diagonal nonzeros in $K$ for the given connectivity and compute the half-bandwidth $b_{\\text{orig}}$ under the given node numbering.\n2. Apply the Reverse Cuthill–McKee (RCM) reordering to the adjacency graph defined by the above connectivity. Use the standard breadth-first traversal that begins from a node of minimal degree, with ties broken by the smallest node label, and orders neighbors by increasing label within each level; then reverse the resulting Cuthill–McKee sequence to obtain the RCM ordering. Compute the half-bandwidth $b_{\\text{RCM}}$ after this reordering.\n3. Using the concept of a permutation matrix $P$ that implements the RCM ordering, argue from first principles of assembly that the reordered system $K' = P^{\\top} K P$ and $f' = P^{\\top} f$ preserves all element-level numerical values, modifying only their positions in $K'$ and entries in $f'$ due to reindexing.\n4. Let $r \\equiv b_{\\text{orig}} / b_{\\text{RCM}}$. Provide the exact value of $r$.\n\nYour final answer must be the single number $r$ (dimensionless). Do not round; report the exact value.", "solution": "The problem statement has been analyzed and is determined to be valid. It is a well-posed problem in computational solid mechanics, grounded in the principles of the finite element method and sparse matrix theory. I will now proceed with a complete solution.\n\nThe problem asks for an analysis of the sparsity structure of a global stiffness matrix $K$ for a one-dimensional bar discretized into $N-1 = 11$ linear finite elements connecting $N=12$ nodes. The core of the problem lies in the specified non-sequential node connectivity and the effect of reordering on the matrix bandwidth.\n\nThe connectivity is defined by the sequence of nodes $p = \\big( 1,\\, 12,\\, 2,\\, 11,\\, 3,\\, 10,\\, 4,\\, 9,\\, 5,\\, 8,\\, 6,\\, 7 \\big)$. The $k$-th element, for $k \\in \\{1, 2, \\dots, 11\\}$, connects node $p_k$ to node $p_{k+1}$. This establishes the set of edges in the adjacency graph of the matrix $K$. The non-zero off-diagonal entries $K_{ij}$ correspond to pairs of nodes $(i,j)$ that are connected by an element.\n\nFirst, we list the pairs of connected nodes from the given sequence $p$:\n\\begin{itemize}\n    \\item Element 1: $(p_1, p_2) = (1, 12)$\n    \\item Element 2: $(p_2, p_3) = (12, 2)$\n    \\item Element 3: $(p_3, p_4) = (2, 11)$\n    \\item Element 4: $(p_4, p_5) = (11, 3)$\n    \\item Element 5: $(p_5, p_6) = (3, 10)$\n    \\item Element 6: $(p_6, p_7) = (10, 4)$\n    \\item Element 7: $(p_7, p_8) = (4, 9)$\n    \\item Element 8: $(p_8, p_9) = (9, 5)$\n    \\item Element 9: $(p_9, p_{10}) = (5, 8)$\n    \\item Element 10: $(p_{10}, p_{11}) = (8, 6)$\n    \\item Element 11: $(p_{11}, p_{12}) = (6, 7)$\n\\end{itemize}\nThis set of $11$ edges, $\\{(1,12), (12,2), (2,11), \\dots, (6,7)\\}$, defines the locations of all off-diagonal non-zero entries in the symmetric matrix $K$.\n\n**Task 1: Original Half-Bandwidth, $b_{\\text{orig}}$**\n\nThe half-bandwidth $b$ is given by $b = 1 + \\max_{(i,j), K_{ij} \\neq 0} |i - j|$. We must compute this maximum for the original node numbering. We calculate the absolute difference $|i - j|$ for each connected pair $(i, j)$:\n\\begin{itemize}\n    \\item $|1 - 12| = 11$\n    \\item $|12 - 2| = 10$\n    \\item $|2 - 11| = 9$\n    \\item $|11 - 3| = 8$\n    \\item $|3 - 10| = 7$\n    \\item $|10 - 4| = 6$\n    \\item $|4 - 9| = 5$\n    \\item $|9 - 5| = 4$\n    \\item $|5 - 8| = 3$\n    \\item $|8 - 6| = 2$\n    \\item $|6 - 7| = 1$\n\\end{itemize}\nThe maximum of these values is $\\max |i-j| = 11$.\nTherefore, the original half-bandwidth is $b_{\\text{orig}} = 1 + 11 = 12$.\n\n**Task 2: RCM Reordering and New Half-Bandwidth, $b_{\\text{RCM}}$**\n\nWe must apply the Reverse Cuthill–McKee (RCM) algorithm to reorder the nodes. This requires constructing the adjacency graph and performing a breadth-first search (BFS).\n\nThe adjacency list for the graph is:\n\\begin{itemize}\n    \\item $\\text{adj}(1): \\{12\\}$\n    \\item $\\text{adj}(2): \\{11, 12\\}$\n    \\item $\\text{adj}(3): \\{10, 11\\}$\n    \\item $\\text{adj}(4): \\{9, 10\\}$\n    \\item $\\text{adj}(5): \\{8, 9\\}$\n    \\item $\\text{adj}(6): \\{7, 8\\}$\n    \\item $\\text{adj}(7): \\{6\\}$\n    \\item $\\text{adj}(8): \\{5, 6\\}$\n    \\item $\\text{adj}(9): \\{4, 5\\}$\n    \\item $\\text{adj}(10): \\{3, 4\\}$\n    \\item $\\text{adj}(11): \\{2, 3\\}$\n    \\item $\\text{adj}(12): \\{1, 2\\}$\n\\end{itemize}\nThe degrees of the nodes are: $\\text{deg}(1) = 1$, $\\text{deg}(7) = 1$, and all other nodes have degree $2$. The minimum degree is $1$. The nodes with minimum degree are $\\{1, 7\\}$. The specified tie-breaking rule is to select the node with the smallest label, so the starting node for the BFS is node $1$.\n\nThe Cuthill–McKee (CM) ordering, $R_{\\text{CM}}$, is generated by a BFS starting from node $1$. Since the graph is a simple path, the levels of the BFS will each contain a single node.\n\\begin{itemize}\n    \\item Level 0: $\\{1\\}$\n    \\item Level 1: Neighbors of level 0: $\\{12\\}$\n    \\item Level 2: Neighbors of level 1: $\\{2\\}$\n    \\item Level 3: Neighbors of level 2: $\\{11\\}$\n    \\item ...and so on, following the path defined by the connectivity.\n\\end{itemize}\nThe resulting CM ordering sequence is $R_{\\text{CM}} = (1, 12, 2, 11, 3, 10, 4, 9, 5, 8, 6, 7)$.\n\nThe RCM ordering, $R_{\\text{RCM}}$, is obtained by reversing the CM sequence:\n$R_{\\text{RCM}} = (7, 6, 8, 5, 9, 4, 10, 3, 11, 2, 12, 1)$.\n\nThis sequence defines the renumbering. The new node label $i'$ corresponds to the old node label given by the $i'$-th entry of $R_{\\text{RCM}}$.\nNew $1 \\rightarrow$ Old $7$, New $2 \\rightarrow$ Old $6$, New $3 \\rightarrow$ Old $8$, and so on.\n\nLet us find the adjacencies in the new numbering system. The original connections are between physically adjacent nodes. The RCM algorithm renumbers the nodes sequentially along the physical length of the bar. Let's verify this by remapping the original edges to the new labels. The mapping from old label $i$ to new label $i'$ is $i' = M(i)$:\n$M(7)=1, M(6)=2, M(8)=3, M(5)=4, M(9)=5, M(4)=6, M(10)=7, M(3)=8, M(11)=9, M(2)=10, M(12)=11, M(1)=12$.\n\nThe remapped edges $(i', j') = (M(i), M(j))$ are:\n\\begin{itemize}\n    \\item $(1, 12) \\rightarrow (M(1), M(12)) = (12, 11)$\n    \\item $(12, 2) \\rightarrow (M(12), M(2)) = (11, 10)$\n    \\item $(2, 11) \\rightarrow (M(2), M(11)) = (10, 9)$\n    \\item ...and so on.\n\\end{itemize}\nThe complete set of remapped connections is $\\{(12,11), (11,10), (10,9), (9,8), (8,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1)\\}$.\nFor every connected pair $(i', j')$ in the new ordering, the absolute difference is $|i' - j'| = 1$.\nThe maximum of these differences is $\\max|i'-j'| = 1$.\nThe half-bandwidth of the reordered matrix is $b_{\\text{RCM}} = 1 + 1 = 2$.\nThis result is expected, as RCM optimally reorders a path graph to a tridiagonal structure, for which the half-bandwidth is $2$.\n\n**Task 3: First Principles Argument for Invariance of Numerical Values**\n\nThe global stiffness matrix $K$ and force vector $f$ are assembled from elemental contributions. For an element $e$ connecting nodes $i$ and $j$, its element stiffness matrix $K^{(e)}$ and force vector $f^{(e)}$ contribute to the global system. The values from $K^{(e)}$ are added to the submatrix of $K$ corresponding to indices $(i,j)$, and values from $f^{(e)}$ are added to entries $f_i$ and $f_j$.\n\nA reordering of nodes is a permutation, which can be represented by a permutation matrix $P$. If the RCM algorithm maps an old node index $i$ to a new index $i'$, this defines the permutation. Let the reordered stiffness matrix be $K' = P^{\\top} K P$ and the reordered force vector be $f' = P^{\\top} f$.\n\nLet the permutation be such that the new node $i'$ corresponds to the old node $p_{i'}$. The permutation matrix $P$ is defined by $P_{jk} = 1$ if $j = p_k$ and $0$ otherwise. Its transpose is $P^{\\top}_{ij} = P_{ji} = 1$ if $j=p_i$ and $0$ otherwise.\n\nLet us examine an entry $(i', j')$ in the reordered matrix $K'$:\n$$ K'_{i'j'} = (P^{\\top} K P)_{i'j'} = \\sum_{a=1}^{N} \\sum_{b=1}^{N} (P^{\\top})_{i'a} K_{ab} P_{bj'} $$\nBy definition of the permutation matrix, $(P^{\\top})_{i'a}$ is non-zero only for $a=p_{i'}$, and $P_{bj'}$ is non-zero only for $b=p_{j'}$. The sums therefore collapse to a single term:\n$$ K'_{i'j'} = K_{p_{i'}, p_{j'}} $$\nThis equation shows that the value at entry $(i',j')$ of the new matrix $K'$ is precisely the value that was at entry $(p_{i'}, p_{j'})$ of the original matrix $K$. The old nodes $p_{i'}$ and $p_{j'}$ are connected by some element, which gives rise to the numerical value $K_{p_{i'}, p_{j'}}$. The reordering operation simply moves this numerical value to a new position in the matrix, $(i', j')$. It does not alter the value itself, because the physical basis—the integral $a(u,v)$ over the element domain—is unchanged.\n\nSimilarly, for the force vector:\n$$ f'_{i'} = (P^{\\top} f)_{i'} = \\sum_{a=1}^{N} (P^{\\top})_{i'a} f_a = f_{p_{i'}} $$\nThe force component $f_{p_{i'}}$ associated with the old node $p_{i'}$ is moved to the position $i'$ in the new vector $f'$. The numerical values assembled from element-level calculations are preserved, merely relocated according to the permutation.\n\n**Task 4: Compute the ratio $r$**\n\nThe ratio $r$ is defined as $r = b_{\\text{orig}} / b_{\\text{RCM}}$. Using the values calculated in Tasks 1 and 2:\n$$ r = \\frac{b_{\\text{orig}}}{b_{\\text{RCM}}} = \\frac{12}{2} = 6 $$\nThe ratio is a dimensionless quantity representing the improvement in bandwidth achieved by the RCM reordering.", "answer": "$$\\boxed{6}$$", "id": "2615741"}]}