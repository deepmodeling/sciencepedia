{
    "hands_on_practices": [
        {
            "introduction": "量子谐振子是量子力学中的基本模型。本练习提供了一个关键的验证，展示了离散化的路径积分表示如何随着“珠子”数量 $P$ 的增加而正确地收敛到精确的量子配分函数 。通过分析计算精确配分函数和近似配分函数，您将深入理解特罗特 (Trotter) 分解误差及其系统性，这是所有路径积分方法的基础。",
            "id": "2659206",
            "problem": "考虑一个质量为 $m$、角频率为 $\\omega$、逆温度为 $\\beta$ 的一维量子谐振子。在约化单位制下进行计算，其中普朗克常数除以 $2\\pi$ 设为 $\\hbar = 1$，玻尔兹曼常数设为 $k_{\\mathrm{B}} = 1$，因此所有量均为无量纲。您的任务是推导、实现并测试精确量子正则配分函数与其虚时路径积分离散化之间的比较，该比较是 Trotter 数 $P$ 的函数。\n\n从以下基本依据出发：\n- 正则配分函数为 $Z = \\mathrm{Tr}\\left[e^{-\\beta \\hat{H}}\\right]$，其中哈密顿量为 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{q}^2$。\n- Trotter 分解和 Feynman 虚时路径积分表示将 $Z$ 表达为虚时演化算符的 $P$ 重分解的极限，对于有限的 $P$，这会产生一个在具有最近邻谐振弹簧和珠上势 $V(q) = \\frac{1}{2} m \\omega^2 q^2$ 的 $P$ 珠环状聚合物上的经典组态积分。\n- 对于二次型作用量，高斯积分可简化为该二次型的行列式。\n\n要求：\n1) 在这些单位下，推导一维谐振子的精确量子配分函数 $Z_{\\mathrm{exact}}(\\beta,\\omega)$。\n2) 从具有 $P$ 个珠子和原始 Trotter 分裂的离散化虚时路径积分出发，推导出一个关于环状聚合物简正模的乘积的显式可计算表达式 $Z_P(\\beta,\\omega)$，该表达式适用于有限的 $P$（这是真正的蒙特卡洛抽样会估计的 $P$ 级路径积分蒙特卡洛（PIMC）目标；在此，您将通过等价的高斯积分确定性地计算它）。\n3) 对于下面指定的每个测试用例，计算 $P \\in \\{1,2,4,8,16,32,64\\}$ 时的 $Z_{\\mathrm{exact}}(\\beta,\\omega)$ 和 $Z_P(\\beta,\\omega)$。使用这些值计算每个 $P$ 的绝对误差 $|Z_P - Z_{\\mathrm{exact}}|$。\n4) 通过对最后四个 $P$ 值 $P \\in \\{8,16,32,64\\}$ 拟合幂律 $|Z_P - Z_{\\mathrm{exact}}| \\approx C P^{-r}$ 来量化收敛速率，使用对数-对数数据的线性最小二乘法提取指数 $r$。\n5) 将上述步骤实现为一个完整的程序，为测试套件生成所需的输出。\n\n使用以下参数集测试套件（在所述单位 $\\hbar = 1$, $k_{\\mathrm{B}}=1$ 下均为无量纲）：\n- 情况 1：$(\\beta,\\omega) = (0.5, 1.0)$。\n- 情况 2：$(\\beta,\\omega) = (1.0, 1.0)$。\n- 情况 3：$(\\beta,\\omega) = (3.0, 1.0)$。\n- 情况 4：$(\\beta,\\omega) = (1.0, 0.5)$。\n\n程序输入：无。所有参数均已在上方提供。\n\n程序输出：\n- 对于每种情况，输出一个浮点数：从步骤 4 拟合得到的收敛指数 $r$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述情况的顺序列出，例如 $[r_1,r_2,r_3,r_4]$。\n- 每个 $r$ 必须以浮点数形式报告。由于选择了 $\\hbar = 1$, $k_{\\mathrm{B}}=1$，所有输出都是无单位的。\n\n数值指导与约束：\n- 为保证数值稳定性，使用本征模贡献的对数来计算 $Z_P(\\beta,\\omega)$ 的乘积。\n- 三角函数中使用的角度必须是弧度。\n- 不允许外部输入或随机性；您的实现必须是确定性的且自包含的。",
            "solution": "该问题陈述已经过严格验证，并被证实是科学上合理的、良置的且客观的。这是统计力学中的一个标准问题，它有一个唯一且可验证的解。我们现在按要求进行推导和实现。分析将在约化单位制下进行，其中普朗克常数除以 $2\\pi$ 为 $\\hbar=1$，玻尔兹曼常数为 $k_{\\mathrm{B}}=1$。\n\n首先，我们推导精确的量子正则配分函数 $Z_{\\mathrm{exact}}$。一维量子谐振子的哈密顿量由 $\\hat{H} = \\frac{\\hat{p}^2}{2m} + \\frac{1}{2} m \\omega^2 \\hat{q}^2$ 给出。该系统的能量本征值是量子化的，由 $E_n = \\hbar \\omega (n + \\frac{1}{2})$ 给出，其中 $n$ 是一个非负整数，$n=0, 1, 2, \\ldots$。在指定的 $\\hbar=1$ 的约化单位制中，能级为 $E_n = \\omega(n + \\frac{1}{2})$。在逆温度 $\\beta = 1/(k_{\\mathrm{B}}T)$ 下，正则配分函数 $Z$ 定义为玻尔兹曼算符的迹，$Z = \\mathrm{Tr}[e^{-\\beta \\hat{H}}]$。在能量本征基中，这成为对所有态的求和：\n$$Z_{\\mathrm{exact}} = \\sum_{n=0}^{\\infty} e^{-\\beta E_n} = \\sum_{n=0}^{\\infty} e^{-\\beta \\omega (n + 1/2)}$$\n我们可以提出基态贡献因子，并将剩余的和辨认为一个几何级数：\n$$Z_{\\mathrm{exact}} = e^{-\\beta \\omega/2} \\sum_{n=0}^{\\infty} (e^{-\\beta \\omega})^n$$\n对于 $|x|<1$，几何级数 $\\sum_{n=0}^{\\infty} x^n$ 收敛于 $1/(1-x)$。此处，$x=e^{-\\beta\\omega}$，对于正的 $\\beta$ 和 $\\omega$，它总是小于 $1$。因此，该和的计算结果为 $1/(1-e^{-\\beta\\omega})$。将其代回，我们得到：\n$$Z_{\\mathrm{exact}} = \\frac{e^{-\\beta \\omega/2}}{1 - e^{-\\beta \\omega}} = \\frac{1}{e^{\\beta \\omega/2} - e^{-\\beta \\omega/2}}$$\n此表达式等价于双曲余割函数：\n$$Z_{\\mathrm{exact}}(\\beta, \\omega) = \\frac{1}{2\\sinh(\\beta\\omega/2)}$$\n请注意，此表达式与质量 $m$ 无关。\n\n接下来，我们从离散化的虚时路径积分公式推导近似配分函数 $Z_P$。配分函数可以表示为在虚时间 $\\tau \\in [0, \\beta\\hbar]$ 上的闭合路径积分。将此时间区间离散为 $P$ 个大小为 $\\epsilon = \\beta/P$ 的步长，并使用原始 Trotter 分解 $e^{-\\beta \\hat{H}} \\approx (e^{-\\epsilon \\hat{V}} e^{-\\epsilon \\hat{T}})^P$ 可得到 $Z_P$ 的表达式：\n$$Z_P = \\mathrm{Tr}\\left[ \\left(e^{-\\frac{\\beta}{P}\\hat{T}} e^{-\\frac{\\beta}{P}\\hat{V}}\\right)^P \\right]$$\n在算符之间插入完备的位置本征态集，得到一个关于循环聚合物链（“环状聚合物”）位置 $q_1, q_2, \\ldots, q_P$ 的类经典组态积分。对于质量为 $m$ 的粒子，表达式为：\n$$Z_P = \\left(\\frac{mP}{2\\pi\\beta\\hbar^2}\\right)^{P/2} \\int_{-\\infty}^{\\infty} \\! \\dots \\! \\int_{-\\infty}^{\\infty} d\\mathbf{q} \\exp\\left(-\\sum_{i=1}^{P} \\left[ \\frac{mP}{2\\beta\\hbar^2}(q_{i+1}-q_i)^2 + \\frac{\\beta}{P}V(q_i) \\right] \\right)$$\n其中 $q_{P+1} \\equiv q_1$ 强制环闭合。在我们的约化单位制（$\\hbar=1$）和对于谐振势 $V(q) = \\frac{1}{2}m\\omega^2 q^2$ 的情况下，指数的宗量变为：\n$$S(\\mathbf{q}) = \\sum_{i=1}^{P} \\left[ \\frac{mP}{2\\beta}(q_{i+1}-q_i)^2 + \\frac{\\beta m\\omega^2}{2P} q_i^2 \\right]$$\n该积分是一个多维高斯积分。$S(\\mathbf{q})$ 项可以写成二次型 $S(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^T \\mathbf{A} \\mathbf{q}$，其中 $\\mathbf{q} = (q_1, \\ldots, q_P)^T$，$\\mathbf{A}$ 是一个 $P \\times P$ 对称矩阵。$\\mathbf{A}$ 的元素可通过展开求和得到：\n$$A_{ij} = m \\left[ \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right)\\delta_{ij} - \\frac{P}{\\beta}(\\delta_{i,j+1} + \\delta_{i,j-1}) \\right]$$\n其中指数按模 $P$ 计算。这是一个循环矩阵。\n$d$ 维高斯积分的通用公式是 $\\int d^d\\mathbf{x} \\exp(-\\frac{1}{2}\\mathbf{x}^T \\mathbf{M} \\mathbf{x}) = (2\\pi)^{d/2} (\\det \\mathbf{M})^{-1/2}$。将此应用于我们的 $Z_P$ 积分，得到：\n$$Z_P = \\left(\\frac{mP}{2\\pi\\beta}\\right)^{P/2} (2\\pi)^{P/2} (\\det \\mathbf{A})^{-1/2} = \\left(\\frac{mP}{\\beta}\\right)^{P/2} m^{-P/2} (\\det \\mathbf{A}')^{-1/2} = \\left(\\frac{P}{\\beta}\\right)^{P/2} (\\det \\mathbf{A}')^{-1/2}$$\n其中 $\\mathbf{A}' = \\mathbf{A}/m$。质量 $m$ 消掉了，与精确结果一致。循环矩阵 $\\mathbf{A}'$ 的本征值 $\\lambda_k$ 由其第一行的离散傅里叶变换给出。对于 $k=0, 1, \\dots, P-1$：\n$$\\lambda_k = \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right) - \\frac{P}{\\beta}e^{2\\pi i k/P} - \\frac{P}{\\beta}e^{-2\\pi i k/P} = \\left(\\frac{2P}{\\beta} + \\frac{\\beta\\omega^2}{P}\\right) - \\frac{2P}{\\beta}\\cos\\left(\\frac{2\\pi k}{P}\\right)$$\n使用恒等式 $1-\\cos(2\\theta) = 2\\sin^2(\\theta)$，上式简化为：\n$$\\lambda_k = \\frac{2P}{\\beta} \\left(1 - \\cos\\left(\\frac{2\\pi k}{P}\\right)\\right) + \\frac{\\beta\\omega^2}{P} = \\frac{4P}{\\beta}\\sin^2\\left(\\frac{\\pi k}{P}\\right) + \\frac{\\beta\\omega^2}{P}$$\n行列式是本征值的乘积，$\\det \\mathbf{A}' = \\prod_{k=0}^{P-1} \\lambda_k$。将其代入 $Z_P$ 的表达式，得到最终的可计算公式：\n$$Z_P(\\beta, \\omega) = \\left(\\frac{P}{\\beta}\\right)^{P/2} \\left[ \\prod_{k=0}^{P-1} \\left( \\frac{4P}{\\beta}\\sin^2\\left(\\frac{\\pi k}{P}\\right) + \\frac{\\beta\\omega^2}{P} \\right) \\right]^{-1/2}$$\n对于数值计算，特别是对于大的 $P$，计算 $Z_P$ 的对数更为稳定：\n$$\\log Z_P = \\frac{P}{2} \\log\\left(\\frac{P}{\\beta}\\right) - \\frac{1}{2} \\sum_{k=0}^{P-1} \\log(\\lambda_k)$$\n这个表达式是路径积分公式的直接推论，并代表了 PIMC 模拟的目标值。\n\n最终的要求是分析当 $P$ 增加时 $Z_P$ 向 $Z_{\\mathrm{exact}}$ 的收敛性。原始 Trotter 近似引入的误差随珠子数量 $P$ 缩放。我们期望绝对误差存在幂律关系：\n$$|Z_P - Z_{\\mathrm{exact}}| \\approx C P^{-r}$$\n其中 $C$ 是一个常数，$r$ 是收敛指数。为确定 $r$，我们可以对此方程的对数形式进行线性回归：\n$$\\log|Z_P - Z_{\\mathrm{exact}}| \\approx \\log C - r \\log P$$\n这是一个形式为 $y = b + mx$ 的线性方程，其中 $y = \\log|Z_P - Z_{\\mathrm{exact}}|$，$x = \\log P$，斜率 $m = -r$，截距 $b = \\log C$。我们将计算 $P \\in \\{1, 2, 4, 8, 16, 32, 64\\}$ 的误差，并使用最后四个数据点（$P \\in \\{8, 16, 32, 64\\}$）进行线性最小二乘拟合以提取斜率 $m$。收敛指数则为 $r = -m$。对于此处使用的原始算法，理论上预测 $r=2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing the exact and path-integral discretized\n    partition functions for a quantum harmonic oscillator.\n    \"\"\"\n\n    # Test cases from the problem statement: (beta, omega)\n    test_cases = [\n        (0.5, 1.0),\n        (1.0, 1.0),\n        (3.0, 1.0),\n        (1.0, 0.5),\n    ]\n\n    # Trotter numbers for the analysis\n    P_values = np.array([1, 2, 4, 8, 16, 32, 64])\n\n    # List to store the final convergence exponents r for each test case\n    convergence_exponents = []\n\n    for beta, omega in test_cases:\n        # 1. Calculate the exact partition function Z_exact\n        # Z_exact = 1 / (2 * sinh(beta * omega / 2))\n        z_exact = 1.0 / (2.0 * np.sinh(beta * omega / 2.0))\n\n        errors = []\n        for P in P_values:\n            # 2. Calculate the discretized path integral partition function Z_P\n            # The formula is derived in the solution text. We compute its logarithm\n            # for numerical stability.\n            # log(Z_P) = (P/2)*log(P/beta) - (1/2)*sum_{k=0}^{P-1}log(lambda_k)\n            # lambda_k = (4P/beta)*sin^2(pi*k/P) + (beta*omega^2)/P\n\n            k_vals = np.arange(P)\n            sin_term = np.sin(np.pi * k_vals / P)**2\n            lambda_k = (4.0 * P / beta) * sin_term + (beta * omega**2 / P)\n            \n            # The logarithm of lambda_k can have -inf if lambda_k is 0,\n            # which does not happen for omega > 0.\n            log_lambda_k_sum = np.sum(np.log(lambda_k))\n\n            log_z_p = (P / 2.0) * np.log(P / beta) - 0.5 * log_lambda_k_sum\n            z_p = np.exp(log_z_p)\n\n            # 3. Compute the absolute error\n            error = np.abs(z_p - z_exact)\n            errors.append(error)\n\n        # 4. Fit the convergence rate r from the last four P values\n        # Model: error = C * P^(-r) => log(error) = log(C) - r * log(P)\n        # We perform a linear fit on log-log data.\n        \n        # Use last four points for the fit: P = {8, 16, 32, 64}\n        fit_P_values = P_values[-4:]\n        fit_errors = np.array(errors[-4:])\n        \n        log_P = np.log(fit_P_values)\n        log_error = np.log(fit_errors)\n\n        # Using numpy's polyfit to find the slope of the linear regression\n        # polyfit returns [slope, intercept] for degree 1\n        slope, _ = np.polyfit(log_P, log_error, 1)\n\n        # The convergence exponent r is the negative of the slope\n        r = -slope\n        convergence_exponents.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in convergence_exponents)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然谐振子具有启发性，但真实的分子系统是高度非谐的。本练习转向一个双阱势模型，在这种情况下，采样效率变得至关重要 。您将比较两种强大的坐标系——简正模 (normal modes) 和分阶 (staging) 坐标——用于探索环状聚合物复杂的能量形貌。通过分析自相关时间，您将学习如何量化和比较不同采样算法的效率，这是马尔可夫链蒙特卡洛 (MCMC) 模拟中的一个核心挑战。",
            "id": "3793344",
            "problem": "实现一个独立完整的程序，该程序在一个一维量子粒子处于非谐势中的路径积分分子动力学 (PIMD) 框架下，通过估计势能的积分自相关时间，比较两种坐标表示（分阶坐标和简正模）的统计效率。请使用以下基本基础。\n\n- 量子正则配分函数可以通过一个离散化的费曼路径积分来表示，该积分将量子系统映射到一个由 $P$ 个珠子组成的经典环状聚合物。在约化单位中，普朗克常数 $\\hbar$ 设为 $1$，玻尔兹曼常数 $k_B$ 设为 $1$，质量 $m$ 设为 $1$，环状聚合物的等效经典势为\n$$\nU_{\\mathrm{eff}}(\\mathbf{x}) \\;=\\; \\frac{1}{2}\\,\\omega_P^2 \\sum_{j=0}^{P-1} \\left(x_j - x_{j+1}\\right)^2 \\;+\\; \\frac{1}{P}\\sum_{j=0}^{P-1} V(x_j),\n$$\n其中具有周期性边界 $x_P \\equiv x_0$ 和 $\\omega_P = \\frac{P}{\\beta}$，$\\beta$ 是逆温度。非谐外势为双阱势\n$$\nV(x) \\;=\\; a \\left(x^2 - b^2\\right)^2,\n$$\n参数 $a>0$ 和 $b>0$。珠子坐标 $\\mathbf{x}\\in\\mathbb{R}^P$ 的正则概率密度正比于 $\\exp\\left(-\\beta\\,U_{\\mathrm{eff}}(\\mathbf{x})\\right)$。\n\n- 需要实现两种线性坐标变换：\n  1. 简正模：将环状聚合物弹簧矩阵 $\\mathbf{K}\\in\\mathbb{R}^{P\\times P}$ 对角化，该矩阵定义为 $K_{jj}=2$，$K_{j,j+1}=K_{j+1,j}=-1$ 并采用周期性索引，使得 $\\mathbf{K}=\\mathbf{Q}\\,\\mathrm{diag}(\\lambda_0,\\dots,\\lambda_{P-1})\\,\\mathbf{Q}^\\top$，其中 $\\mathbf{Q}$ 是标准正交的且 $\\lambda_k\\ge 0$。通过在简正模坐标中添加高斯增量来产生提议，即 $\\delta \\mathbf{x}=\\mathbf{Q}\\,\\delta\\mathbf{q}$，并根据 $\\lambda_k$ 选择依赖于模式的尺度。\n  2. 分阶变换：通过下三角、保体积的映射定义分阶坐标 $\\mathbf{s}\\in\\mathbb{R}^P$\n     - $s_0 = x_0$，\n     - 对于 $j\\in\\{1,\\dots,P-1\\}$，\n       $$\n       s_j \\;=\\; x_j \\;-\\; \\frac{j}{j+1}\\,x_{j-1} \\;-\\; \\frac{1}{j+1}\\,x_0.\n       $$\n     逆映射为\n       $$\n       x_0 \\;=\\; s_0, \\qquad\n       x_j \\;=\\; s_0 \\;+\\; \\sum_{m=1}^{j} \\frac{m+1}{j+1}\\,s_m \\quad \\text{对于 } j\\in\\{1,\\dots,P-1\\}.\n       $$\n     通过在分阶坐标中添加高斯增量并线性地映射回珠子空间来产生提议，即 $\\delta \\mathbf{x}=\\mathbf{T}\\,\\delta\\mathbf{s}$，其中 $\\mathbf{T}$ 是由上述逆映射定义的下三角矩阵。\n\n- 必须在所选的内坐标中使用单步全局高斯提议进行抽样，然后进行 Metropolis 接受/拒绝步骤，其接受概率为\n$$\n\\alpha \\;=\\; \\min\\!\\left\\{1,\\;\\exp\\!\\left[-\\beta\\left(U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{new}})-U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{old}})\\right)\\right]\\right\\}.\n$$\n由于两种变换都是线性的且具有恒定的雅可比行列式，因此在内坐标中的对称高斯提议会在珠子空间中产生对称提议。\n\n- 对于简正模提议，将每个模式 $k$（$k\\ge 1$）按一个与 $1/\\sqrt{\\lambda_k}$ 成正比的因子进行缩放，并对 $k=0$ 使用有限的质心尺度。对于分阶提议，将分阶坐标 $s_j$（$j\\ge 1$）按与 $\\sqrt{\\frac{j}{j+1}}$ 成正比的比例进行缩放，并对 $s_0$ 使用有限尺度。为实现公平比较，两种方法应使用相同的基准步长因子。\n\n- 从马尔可夫链蒙特卡洛 (MCMC) 轨迹中，记录环状聚合物平均势能的时间序列\n$$\n\\overline{V}_t \\;=\\; \\frac{1}{P}\\sum_{j=0}^{P-1} V\\!\\left(x_j^{(t)}\\right).\n$$\n\n- 使用初始正序列法估计标量序列 $\\{\\overline{V}_t\\}$ 的积分自相关时间 (IAT)：通过标准快速傅里叶变换卷积估计量计算归一化自相关函数 $\\rho(\\tau)$，然后定义\n$$\n\\tau_{\\mathrm{int}} \\;=\\; 1 + 2 \\sum_{\\tau=1}^{\\tau^\\star} \\rho(\\tau),\n$$\n其中 $\\tau^\\star$ 是使得每个成对和 $\\rho(2\\ell-1)+\\rho(2\\ell)$ 保持非负的最大偶数延迟。如果方差在数值上为零，则定义 $\\tau_{\\mathrm{int}}=1$。\n\n- 对于下述每个测试用例，运行两种抽样器（简正模和分阶），使用相同的总 MCMC 步数，丢弃初始的预烧期部分，并从保留的样本中估计 IAT。报告以下比率\n$$\nR \\;=\\; \\frac{\\tau_{\\mathrm{int}}^{\\mathrm{NM}}}{\\tau_{\\mathrm{int}}^{\\mathrm{ST}}}\n$$\n结果为浮点数。值 $R>1$ 表示在该用例中，分阶方法比简正模方法产生更短的自相关（即效率更高）。\n\n假设与计算细节：\n\n- 使用约化的无量纲单位，其中 $\\hbar=1$，$k_B=1$，$m=1$。在这些单位中，$\\beta$ 是无量纲的，位置是无量纲的，MCMC 轨迹中的时间索引是蒙特卡洛步数的计数（无量纲）。不需要进行物理单位转换。\n- 不涉及角度；无需特殊说明。\n- 程序必须是确定性的，且不需要外部输入。固定一个内部伪随机种子。\n\n测试套件：\n\n对于每个参数元组 $(P,\\beta,a,b,N_{\\mathrm{steps}})$，运行两种抽样器并输出上文定义的标量比率 $R$。使用以下四种情况：\n\n- 情况 A: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (16,\\,4.0,\\,1.0,\\,1.0,\\,12000)$。\n- 情况 B: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (32,\\,8.0,\\,1.0,\\,1.0,\\,12000)$。\n- 情况 C: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (24,\\,2.0,\\,0.5,\\,1.2,\\,12000)$。\n- 情况 D: $(P,\\beta,a,b,N_{\\mathrm{steps}}) = (12,\\,1.5,\\,0.25,\\,0.5,\\,10000)$。\n\n最终输出格式：\n\n- 您的程序应产生单行输出，其中包含按顺序排列的测试用例 A–D 的四个比率 $R$，格式为用方括号括起来的逗号分隔列表（例如 $[r_A,r_B,r_C,r_D]$）。",
            "solution": "该问题要求在路径积分分子动力学 (PIMD) 框架下，针对处于非谐势中的一维量子粒子，比较两种坐标表示（简正模和分阶坐标）的统计效率。效率通过势能估计量的积分自相关时间 (IAT) 来量化。\n\n### 1. 理论框架：路径积分分子动力学\n\n一个量子系统在逆温度 $\\beta = 1/(k_B T)$ 下的正则配分函数 $Z$ 可以用费曼路径积分表示。通过将该积分离散化为 $P$ 个时间片（或“珠子”），该量子粒子被映射到一个由 $P$ 个珠子组成的经典环状聚合物系统。对于一个质量 $m=1$ 的粒子，在 $\\hbar=1$ 和 $k_B=1$ 的约化单位下，该环状聚合物的等效经典势能由下式给出：\n$$\nU_{\\mathrm{eff}}(\\mathbf{x}) = \\frac{1}{2}\\,\\omega_P^2 \\sum_{j=0}^{P-1} \\left(x_j - x_{j+1}\\right)^2 + \\frac{1}{P}\\sum_{j=0}^{P-1} V(x_j)\n$$\n此处，$\\mathbf{x} = (x_0, x_1, \\dots, x_{P-1})$ 是 $P$ 个珠子的位置，满足环闭合条件 $x_P \\equiv x_0$。第一项通过连接相邻珠子的谐振子弹簧代表动能，其频率为 $\\omega_P = P/\\beta$。第二项是珠子所经历的平均外势 $V(x)$。对于本问题，该外势为非谐双阱势：\n$$\nV(x) = a \\left(x^2 - b^2\\right)^2\n$$\n环状聚合物的位形空间是从正则概率分布 $p(\\mathbf{x}) \\propto \\exp(-\\beta U_{\\mathrm{eff}}(\\mathbf{x}))$ 中抽样的。\n\n### 2. 抽样与坐标表示\n\n使用简单的蒙特卡洛移动直接对珠子坐标 $x_j$ 进行抽样是出了名的低效。谐振子弹簧项在相邻珠子之间产生了强烈的相关性，并且其刚度随 $P$ 和 $\\beta$ 的增加而增加，导致对位形空间的探索缓慢。为了克服这个问题，我们采用坐标变换来解耦系统的自由度。\n\n#### a. 简正模 (NM) 坐标\n二次弹簧势项 $\\frac{1}{2}\\omega_P^2 \\sum_{j=0}^{P-1} (x_j - x_{j+1})^2$ 可以写成矩阵形式 $\\frac{1}{2}\\omega_P^2 \\mathbf{x}^\\top \\mathbf{K} \\mathbf{x}$，其中 $\\mathbf{K}$ 是循环弹簧矩阵。简正模变换将该矩阵对角化：$\\mathbf{K} = \\mathbf{Q} \\mathbf{\\Lambda} \\mathbf{Q}^\\top$，其中 $\\mathbf{\\Lambda} = \\mathrm{diag}(\\lambda_0, \\dots, \\lambda_{P-1})$ 包含特征值，$\\mathbf{Q}$ 是标准正交特征向量组成的矩阵。简正模坐标为 $\\mathbf{q} = \\mathbf{Q}^\\top \\mathbf{x}$。在这些坐标中，弹簧势变成了一组解耦的谐振子之和：$\\frac{1}{2}\\omega_P^2 \\sum_{k=0}^{P-1} \\lambda_k q_k^2$。特征值由 $\\lambda_k = 4\\sin^2(\\pi k/P)$ 给出。一个特征值 $\\lambda_0=0$ 对应于质心模（聚合物的质心），它像一个自由粒子一样运动。其他模式 $k>0$ 具有非零频率，代表环状聚合物的内部振动。\n\n一种高效的提议策略是在简正模空间中进行高斯移动，将每个模式 $q_k$ 的移动大小按其特征频率的倒数进行缩放。根据问题要求，我们将模式 $k \\ge 1$ 的提议标准差按 $1/\\sqrt{\\lambda_k}$ 进行缩放，并对质心模（$k=0$）使用一个恒定尺度。在简正模中提出的移动 $\\delta\\mathbf{q}$ 通过 $\\delta\\mathbf{x} = \\mathbf{Q} \\delta\\mathbf{q}$ 变换回珠子空间。\n\n#### b. 分阶 (ST) 坐标\n分阶变换提供了另一种对珠子坐标进行顺序解耦的方法。它由从珠子坐标 $\\mathbf{x}$ 到分阶坐标 $\\mathbf{s}$ 的下三角映射定义：\n$$\ns_0 = x_0, \\quad s_j = x_j - \\frac{j}{j+1}x_{j-1} - \\frac{1}{j+1}x_0 \\quad \\text{for } j \\in \\{1,\\dots,P-1\\}\n$$\n这种变换是保体积的，并且可以被反转以用分阶坐标表示珠子位置。其关键思想是弹簧势能项也可以用 $\\mathbf{s}$ 来表示，在这种表示中模式比在珠子表示中更加解耦。一种高效的提议是在 $\\mathbf{s}$ 空间中进行高斯移动，步长根据分阶索引 $j$ 进行缩放。问题指定将 $s_j$（$j \\ge 1$）的提议按 $\\sqrt{j/(j+1)}$ 进行缩放，并对 $s_0$ 使用一个恒定尺度。提出的移动 $\\delta\\mathbf{s}$ 通过线性逆变换 $\\delta\\mathbf{x} = \\mathbf{T} \\delta\\mathbf{s}$ 映射回珠子空间。\n\n### 3. 模拟与分析\n\n我们使用 Metropolis-Hastings 马尔可夫链蒙特卡洛 (MCMC) 算法来抽样珠子构型。对于 NM 和 ST 两种表示，我们都从一个对称高斯分布中同时为所有坐标生成一个全局提议移动。由于坐标变换是线性的，并且提议分布是对称的，因此在珠子空间中的提议概率也是对称的，Metropolis 接受概率简化为：\n$$\n\\alpha = \\min\\left\\{1, \\exp\\left[-\\beta\\left(U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{new}}) - U_{\\mathrm{eff}}(\\mathbf{x}^{\\mathrm{old}})\\right)\\right]\\right\\}\n$$\n对于每个测试用例，我们运行两个独立的模拟，一个使用 NM 提议，另一个使用 ST 提议，总步数为 $N_{\\mathrm{steps}}$。为了确保公平比较，我们在两次运行中使用相同的基准步长因子和随机数种子。在丢弃用于热化（预烧期）的初始部分步数后，我们记录平均势能估计量的时间序列：\n$$\n\\overline{V}_t = \\frac{1}{P}\\sum_{j=0}^{P-1} V(x_j^{(t)})\n$$\n统计效率由该时间序列的积分自相关时间 (IAT) $\\tau_{\\mathrm{int}}$ 来衡量。较小的 IAT 表示抽样器效率更高，因为样本之间的相关性较小，能更快地收敛到真实平均值。我们使用问题中指定的初始正序列法来估计 $\\tau_{\\mathrm{int}}$：\n$$\n\\tau_{\\mathrm{int}} = 1 + 2 \\sum_{\\tau=1}^{\\tau^\\star} \\rho(\\tau)\n$$\n其中 $\\rho(\\tau)$ 是延迟为 $\\tau$ 时的归一化自相关函数，$\\tau^\\star$ 是使所有先前的成对和 $\\rho(2\\ell-1)+\\rho(2\\ell)$ 保持非负的最大偶数延迟。$\\rho(\\tau)$ 通过快速傅里叶变换 (FFT) 高效计算。\n\n最后，对于每个测试用例，我们计算比率 $R = \\tau_{\\mathrm{int}}^{\\mathrm{NM}} / \\tau_{\\mathrm{int}}^{\\mathrm{ST}}$。该比率量化了两种方法的相对性能，其中 $R > 1$ 表示分阶方法比简正模方法更有效。",
            "answer": "```python\nimport numpy as np\n\n# Global constants as specified or reasonably chosen for the problem\nRANDOM_SEED = 1337\nBURN_IN_FRACTION = 0.2\n# Baseline step-size factors selected to give reasonable acceptance rates\n# across the different physical conditions of the test cases.\n# The same factor is used for both Normal Mode and Staging samplers within a given case.\nSTEP_SIZES = {\n    'A': 0.8,\n    'B': 0.6,\n    'C': 1.2,\n    'D': 1.5,\n}\n\ndef calculate_iat(series):\n    \"\"\"\n    Calculates the Integrated Autocorrelation Time (IAT) of a time series.\n    Uses the initial positive sequence method with pairwise sums, as specified.\n    \"\"\"\n    n = len(series)\n    if n < 4:  # Need at least two lags for the first pair sum\n        return 1.0\n        \n    variance = np.var(series)\n    if variance < 1e-12:\n        return 1.0\n\n    series_centered = series - np.mean(series)\n    \n    # Use FFT to compute the biased autocorrelation function\n    fft_len = 2 * n\n    autocorr_fft = np.fft.fft(series_centered, n=fft_len)\n    autocorr_real = np.fft.ifft(autocorr_fft * np.conj(autocorr_fft)).real\n    \n    # Normalize to get the autocorrelation function rho(tau)\n    # autocorr_real[0] is n * variance\n    if autocorr_real[0] <= 0:\n        return 1.0\n    rho = autocorr_real[:n] / autocorr_real[0]\n\n    # Sum using the initial positive sequence (pairwise) method\n    cutoff_lag = 0\n    # Iterate through pairs of lags\n    for l in range(1, (n // 2)):\n        lag1_idx = 2 * l - 1\n        lag2_idx = 2 * l\n        \n        if lag2_idx >= n:\n            break\n        \n        if rho[lag1_idx] + rho[lag2_idx] >= 0:\n            cutoff_lag = lag2_idx\n        else:\n            break\n            \n    sum_rho = 0.0\n    if cutoff_lag > 0:\n        sum_rho = np.sum(rho[1 : cutoff_lag + 1])\n        \n    tau_int = 1.0 + 2.0 * sum_rho\n    return tau_int\n\n\nclass PIMDSimulator:\n    \"\"\"\n    A class to perform PIMD simulations for a 1D particle in a double-well potential.\n    \"\"\"\n    def __init__(self, P, beta, a, b, N_steps, step_size):\n        self.P = P\n        self.beta = beta\n        self.a = a\n        self.b = b\n        self.N_steps = N_steps\n        self.step_size = step_size\n        self.omega_p = P / beta\n        \n        self.Q = None\n        self.nm_scales = None\n        self.T_st = None\n        self.st_scales = None\n        \n        self._setup_transforms()\n        self.rng = None  # RNG is set before each run for comparability\n\n    def _v_external(self, x):\n        return self.a * (x**2 - self.b**2)**2\n\n    def _u_effective(self, x):\n        diff = x - np.roll(x, -1)\n        u_spring = 0.5 * self.omega_p**2 * np.dot(diff, diff)\n        u_ext = np.sum(self._v_external(x)) / self.P\n        return u_spring + u_ext\n\n    def _setup_transforms(self):\n        # 1. Normal Modes\n        K = 2.0 * np.eye(self.P) - np.eye(self.P, k=1) - np.eye(self.P, k=-1)\n        K[0, -1] = -1.0\n        K[-1, 0] = -1.0\n        \n        lambdas, Q = np.linalg.eigh(K)\n        self.Q = Q\n        \n        self.nm_scales = np.ones(self.P)\n        if self.P > 1:\n            # lambdas[0] is ~0 for the centroid mode. Its scale is kept at 1.\n            # For other modes, scale is 1/sqrt(lambda_k)\n            self.nm_scales[1:] = 1.0 / np.sqrt(lambdas[1:])\n        \n        # 2. Staging\n        # T_st matrix for the inverse transform s -> x\n        T_st_mat = np.zeros((self.P, self.P))\n        T_st_mat[:, 0] = 1.0\n        for j in range(1, self.P):\n            for m in range(1, j + 1):\n                T_st_mat[j, m] = (m + 1.0) / (j + 1.0)\n        self.T_st = T_st_mat\n        \n        self.st_scales = np.ones(self.P)\n        if self.P > 1:\n            j_vals = np.arange(1, self.P)\n            self.st_scales[1:] = np.sqrt(j_vals / (j_vals + 1.0))\n\n    def run(self, mode):\n        # Initialize position at one of the potential minima\n        x = np.full(self.P, self.b)\n        u_eff = self._u_effective(x)\n        \n        potential_energies = np.zeros(self.N_steps)\n        \n        for i in range(self.N_steps):\n            if mode == 'NM':\n                delta_internal = self.step_size * self.rng.normal(size=self.P) * self.nm_scales\n                delta_x = self.Q @ delta_internal\n            elif mode == 'ST':\n                delta_internal = self.step_size * self.rng.normal(size=self.P) * self.st_scales\n                delta_x = self.T_st @ delta_internal\n            else:\n                raise ValueError(\"Invalid mode specified.\")\n\n            x_new = x + delta_x\n            u_eff_new = self._u_effective(x_new)\n            \n            # Metropolis-Hastings acceptance step\n            if u_eff_new < u_eff or self.rng.random() < np.exp(-self.beta * (u_eff_new - u_eff)):\n                x = x_new\n                u_eff = u_eff_new\n\n            potential_energies[i] = np.mean(self._v_external(x))\n            \n        n_burn = int(self.N_steps * BURN_IN_FRACTION)\n        return potential_energies[n_burn:]\n\ndef solve():\n    test_cases = [\n        # (Key, P, beta, a, b, N_steps)\n        ('A', 16, 4.0, 1.0, 1.0, 12000),\n        ('B', 32, 8.0, 1.0, 1.0, 12000),\n        ('C', 24, 2.0, 0.5, 1.2, 12000),\n        ('D', 12, 1.5, 0.25, 0.5, 10000),\n    ]\n\n    results = []\n    \n    for case_key, P, beta, a, b, N_steps in test_cases:\n        step_size = STEP_SIZES[case_key]\n        \n        sim = PIMDSimulator(P=P, beta=beta, a=a, b=b, N_steps=N_steps, step_size=step_size)\n\n        # Run Normal Modes simulation\n        sim.rng = np.random.default_rng(RANDOM_SEED)\n        v_series_nm = sim.run(mode='NM')\n        tau_nm = calculate_iat(v_series_nm)\n\n        # Run Staging simulation\n        sim.rng = np.random.default_rng(RANDOM_SEED)\n        v_series_st = sim.run(mode='ST')\n        tau_st = calculate_iat(v_series_st)\n        \n        if tau_st > 0:\n            ratio = tau_nm / tau_st\n        else:\n            # Handle cases where IAT is ~0 or calculation fails.\n            # If both are zero, ratio is 1. If only ST is zero, NM is less efficient.\n            ratio = float('inf') if tau_nm > 0 else 1.0\n\n        results.append(ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将路径积分分子动力学应用于具有昂贵计算成本的力场（例如来自第一性原理计算）的系统时，需要有效的近似方案。本练习介绍了环状聚合物收缩 (Ring Polymer Contraction, RPC) 这种强大的方法，它允许以不同的近似水平评估势能的不同组成部分 。您将实现并分析不同RPC方案（质心收缩与低通滤波器收缩）所引入的误差，从而直接洞察在准确性和计算成本之间的权衡，这是现代多尺度模拟的一个中心主题。",
            "id": "2914435",
            "problem": "实现一个程序，该程序在路径积分分子动力学 (PIMD) 形式体系下，针对一维量子粒子，计算完整的多分量力评估与其环状聚合物收缩 (RPC) 近似之间的差异。该 RPC 近似对两个不同的高计算成本力分量使用了两种不同的收缩策略。程序需在原子单位下工作，因此约化普朗克常数 $\\hbar = 1$ 且玻尔兹曼常数 $k_{\\mathrm{B}} = 1$。能量必须以哈特里 (Hartree) 表示，长度以玻尔 (Bohr) 表示，力以哈特里每玻尔 (Hartree per Bohr) 表示。任何三角函数内部使用的角度必须为弧度。\n\n从虚时路径积分离散化为 $P$ 个珠子 (beads) 开始，其中逆温度为 $\\beta$，质量为 $m$，环状聚合物频率为 $\\omega_{P} = \\dfrac{P}{\\beta \\hbar} = \\dfrac{P}{\\beta}$。对于位形 $\\mathbf{q} = (q_{0},\\ldots,q_{P-1})$，其环状聚合物哈密顿量为\n$$\nH_{P}(\\mathbf{q},\\mathbf{p}) = \\sum_{j=0}^{P-1} \\left[ \\dfrac{p_{j}^{2}}{2 m} + \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{j} - q_{j+1}\\right)^{2} \\right] + \\sum_{j=0}^{P-1} V(q_{j}),\n$$\n其中循环边界条件为 $q_{P} \\equiv q_{0}$。作用在珠子 $j$ 上的力的位形部分为 $- \\dfrac{\\partial}{\\partial q_{j}} \\left[ \\sum_{k} \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{k} - q_{k+1}\\right)^{2} + \\sum_{k} V(q_{k}) \\right]$。\n\n考虑将势能分解为三个分量，\n$$\nV(x) = V_{\\mathrm{L}}(x) + \\Delta V_{\\mathrm{A}}(x) + \\Delta V_{\\mathrm{B}}(x),\n$$\n定义如下：\n- 应用于完整环状聚合物的低计算成本分量：\n$$\nV_{\\mathrm{L}}(x) = \\dfrac{1}{2} k_{\\mathrm{L}} x^{2}.\n$$\n- 待收缩至质心的高计算成本分量 $\\Delta V_{\\mathrm{A}}$（质心收缩）：\n$$\n\\Delta V_{\\mathrm{A}}(x) = \\alpha x^{4}.\n$$\n- 通过环状聚合物简正模式空间中的低通投影算子进行收缩的高计算成本分量 $\\Delta V_{\\mathrm{B}}$（低通收缩）：\n$$\n\\Delta V_{\\mathrm{B}}(x) = \\dfrac{1}{2} k_{\\mathrm{B}} x^{2}.\n$$\n\n定义质心为\n$$\nq_{\\mathrm{c}} = \\dfrac{1}{P} \\sum_{j=0}^{P-1} q_{j}.\n$$\n定义在 $\\mathbb{C}^{P}$ 上的酉离散傅里叶变换 (DFT) 及其逆变换为\n$$\n\\hat{\\mathbf{q}} = \\dfrac{1}{\\sqrt{P}} \\sum_{n=0}^{P-1} q_{n} \\, e^{- 2 \\pi i k n / P}, \\quad\n\\mathbf{q} = \\dfrac{1}{\\sqrt{P}} \\sum_{k=0}^{P-1} \\hat{q}_{k} \\, e^{+ 2 \\pi i k n / P},\n$$\n在数值上，通过缩放标准的 DFT 和逆 DFT 以使变换成为酉变换来实现。对于一个给定的非负整数截断值 $k_{\\max}$，定义低通投影算子 $\\mathcal{P}_{\\mathrm{L}}$ 为保留模式 $k \\in \\{0,1,\\ldots,k_{\\max}\\}$ 及其复共轭伙伴 $P-k$（当它们不同时），并将所有其他模式置零。投影后的坐标为\n$$\n\\mathbf{q}^{\\mathrm{low}} = \\mathcal{P}_{\\mathrm{L}} \\mathbf{q}.\n$$\n在对 $\\Delta V_{\\mathrm{A}}$ 进行质心收缩时，将 $\\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{A}}(q_{j})$ 替换为 $P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}})$。在对 $\\Delta V_{\\mathrm{B}}$ 进行低通收缩时，将 $\\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q_{j})$ 替换为 $\\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j})$。\n\n力必须从这些近似中推导得出。使用链式法则：\n- 珠子 $j$ 上的弹簧力是\n$$\nF^{\\mathrm{spring}}_{j} = - m \\omega_{P}^{2} \\left(2 q_{j} - q_{j-1} - q_{j+1}\\right).\n$$\n- 珠子 $j$ 上的低成本分量力是\n$$\nF^{\\mathrm{L}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} V_{\\mathrm{L}}(x)\\bigg|_{x=q_{j}} = - k_{\\mathrm{L}} q_{j}.\n$$\n- 针对 $\\Delta V_{\\mathrm{A}}$ 的质心收缩力是\n$$\nF^{\\mathrm{A,RPC}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\left[ P \\, \\Delta V_{\\mathrm{A}}(x) \\right]\\bigg|_{x=q_{\\mathrm{c}}} \\cdot \\dfrac{\\partial q_{\\mathrm{c}}}{\\partial q_{j}} = - 4 \\alpha q_{\\mathrm{c}}^{3}.\n$$\n- 针对 $\\Delta V_{\\mathrm{B}}$ 的低通收缩力是，其中 $\\mathbf{g}$ 逐珠子定义为 $g_{j} = \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\Delta V_{\\mathrm{B}}(x)\\big|_{x=q^{\\mathrm{low}}_{j}} = k_{\\mathrm{B}} q^{\\mathrm{low}}_{j}$，\n$$\n\\mathbf{F}^{\\mathrm{B,RPC}} = - \\mathcal{P}_{\\mathrm{L}} \\, \\mathbf{g}.\n$$\n由于 $\\mathcal{P}_{\\mathrm{L}}$ 是一个由酉 DFT 构建的幂等正交投影算子，这可以简化为\n$$\n\\mathbf{F}^{\\mathrm{B,RPC}} = - k_{\\mathrm{B}} \\, \\mathbf{q}^{\\mathrm{low}}.\n$$\n\n为了进行比较，定义完整（未收缩）的势能和力为\n$$\nV_{\\mathrm{full}} = \\dfrac{1}{2} m \\omega_{P}^{2} \\sum_{j=0}^{P-1} \\left(q_{j} - q_{j+1}\\right)^{2} + \\sum_{j=0}^{P-1} \\left[ V_{\\mathrm{L}}(q_{j}) + \\Delta V_{\\mathrm{A}}(q_{j}) + \\Delta V_{\\mathrm{B}}(q_{j}) \\right],\n$$\n和\n$$\nF^{\\mathrm{A,full}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\Delta V_{\\mathrm{A}}(x)\\bigg|_{x=q_{j}} = - 4 \\alpha q_{j}^{3}, \\quad\nF^{\\mathrm{B,full}}_{j} = - \\dfrac{\\mathrm{d}}{\\mathrm{d}x} \\Delta V_{\\mathrm{B}}(x)\\bigg|_{x=q_{j}} = - k_{\\mathrm{B}} q_{j}.\n$$\n定义 RPC 近似的势能为\n$$\nV_{\\mathrm{RPC}} = \\dfrac{1}{2} m \\omega_{P}^{2} \\sum_{j=0}^{P-1} \\left(q_{j} - q_{j+1}\\right)^{2} + \\sum_{j=0}^{P-1} V_{\\mathrm{L}}(q_{j}) + P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j}),\n$$\n及其相应的总力 $\\mathbf{F}_{\\mathrm{RPC}} = \\mathbf{F}^{\\mathrm{spring}} + \\mathbf{F}^{\\mathrm{L}} + \\mathbf{F}^{\\mathrm{A,RPC}} + \\mathbf{F}^{\\mathrm{B,RPC}}$。\n\n你的程序必须对下面列出的每个测试用例计算：\n- 能量差 $\\Delta E = V_{\\mathrm{RPC}} - V_{\\mathrm{full}}$，单位为哈特里。\n- 均方根 (RMS) 力差\n$$\n\\mathrm{RMS} = \\sqrt{ \\dfrac{1}{P} \\sum_{j=0}^{P-1} \\left( F_{\\mathrm{RPC},j} - F_{\\mathrm{full},j} \\right)^{2} }\n$$\n单位为哈特里每玻尔。\n\n测试套件（正弦和余弦函数内部的角度以弧度为单位）：\n- 用例 $\\#1$：$P = 8$，$\\beta = 10.0$，$m = 1.0$，$k_{\\mathrm{L}} = 1.5$，$\\alpha = 0.05$，$k_{\\mathrm{B}} = 0.7$，$k_{\\max} = 1$，以及珠子坐标\n$$\nq_{j} = 0.3 \\sin\\!\\left( \\dfrac{2 \\pi j}{P} \\right) + 0.1 \\cos\\!\\left( \\dfrac{4 \\pi j}{P} \\right), \\quad j = 0,\\ldots,P-1.\n$$\n- 用例 $\\#2$：$P = 6$，$\\beta = 4.0$，$m = 2.0$，$k_{\\mathrm{L}} = 0.8$，$\\alpha = 0.2$，$k_{\\mathrm{B}} = 1.1$，$k_{\\max} = 2$，以及对所有 $j$ 有 $q_{j} = 0.2$。\n- 用例 $\\#3$：$P = 10$，$\\beta = 2.5$，$m = 1.0$，$k_{\\mathrm{L}} = 0.5$，$\\alpha = 0.1$，$k_{\\mathrm{B}} = 2.0$，$k_{\\max} = 1$，以及对所有 $j$ 有 $q_{j} = 0.3 \\, (-1)^{j}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个由 $2 \\times 3 = 6$ 个逗号分隔的浮点数组成的扁平列表，并用方括号括起来。这些数字必须按以下顺序出现：$[\\Delta E_{\\#1}, \\mathrm{RMS}_{\\#1}, \\Delta E_{\\#2}, \\mathrm{RMS}_{\\#2}, \\Delta E_{\\#3}, \\mathrm{RMS}_{\\#3}]$。",
            "solution": "问题陈述在科学上是合理的，在计算上是适定的。它要求在路径积分分子动力学 (PIMD) 形式体系下，为一个一维量子系统实现环状聚合物收缩 (RPC) 近似，并与完整的、未收缩的计算进行比较。我们将为三个特定的测试用例计算势能差 $\\Delta E$ 和力的均方根 (RMS) 差。\n\n目标是计算两个量：\n$1$. 势能差，$\\Delta E = V_{\\mathrm{RPC}} - V_{\\mathrm{full}}$。\n$2$. 均方根力差，$\\mathrm{RMS} = \\sqrt{ \\dfrac{1}{P} \\sum_{j=0}^{P-1} \\left( F_{\\mathrm{RPC},j} - F_{\\mathrm{full},j} \\right)^{2} }$。\n\n总势能由下式给出：\n$$\nV_{\\mathrm{full}} = \\sum_{j=0}^{P-1} \\left[ \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{j} - q_{j+1}\\right)^{2} + V_{\\mathrm{L}}(q_{j}) + \\Delta V_{\\mathrm{A}}(q_{j}) + \\Delta V_{\\mathrm{B}}(q_{j}) \\right]\n$$\n$$\nV_{\\mathrm{RPC}} = \\sum_{j=0}^{P-1} \\left[ \\dfrac{1}{2} m \\omega_{P}^{2} \\left(q_{j} - q_{j+1}\\right)^{2} + V_{\\mathrm{L}}(q_{j}) \\right] + P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j})\n$$\n能量差 $\\Delta E$ 得到简化，因为谐波弹簧项和低成本势能项 $V_{\\mathrm{L}}$ 在两个表达式中是相同的，因此相互抵消：\n$$\n\\Delta E = \\left( P \\, \\Delta V_{\\mathrm{A}}(q_{\\mathrm{c}}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q^{\\mathrm{low}}_{j}) \\right) - \\left( \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{A}}(q_{j}) + \\sum_{j=0}^{P-1} \\Delta V_{\\mathrm{B}}(q_{j}) \\right)\n$$\n代入具体的势能形式 $\\Delta V_{\\mathrm{A}}(x) = \\alpha x^{4}$ 和 $\\Delta V_{\\mathrm{B}}(x) = \\dfrac{1}{2} k_{\\mathrm{B}} x^{2}$，我们得到：\n$$\n\\Delta E = \\left( P \\alpha q_{\\mathrm{c}}^{4} + \\sum_{j=0}^{P-1} \\dfrac{1}{2} k_{\\mathrm{B}} (q^{\\mathrm{low}}_{j})^{2} \\right) - \\left( \\sum_{j=0}^{P-1} \\alpha q_{j}^{4} + \\sum_{j=0}^{P-1} \\dfrac{1}{2} k_{\\mathrm{B}} q_{j}^{2} \\right)\n$$\n\n类似地，总力为：\n$$\nF_{\\mathrm{full},j} = F^{\\mathrm{spring}}_{j} + F^{\\mathrm{L}}_{j} + F^{\\mathrm{A,full}}_{j} + F^{\\mathrm{B,full}}_{j}\n$$\n$$\nF_{\\mathrm{RPC},j} = F^{\\mathrm{spring}}_{j} + F^{\\mathrm{L}}_{j} + F^{\\mathrm{A,RPC}}_{j} + F^{\\mathrm{B,RPC}}_{j}\n$$\n珠子 $j$ 上的力差 $\\Delta F_{j} = F_{\\mathrm{RPC},j} - F_{\\mathrm{full},j}$ 也因为弹簧力和低成本力相互抵消而得到简化：\n$$\n\\Delta F_{j} = \\left( F^{\\mathrm{A,RPC}}_{j} + F^{\\mathrm{B,RPC}}_{j} \\right) - \\left( F^{\\mathrm{A,full}}_{j} + F^{\\mathrm{B,full}}_{j} \\right)\n$$\n代入力表达式：\n- $F^{\\mathrm{A,RPC}}_{j} = - 4 \\alpha q_{\\mathrm{c}}^{3}$\n- $F^{\\mathrm{B,RPC}}_{j} = - k_{\\mathrm{B}} q^{\\mathrm{low}}_{j}$\n- $F^{\\mathrm{A,full}}_{j} = - 4 \\alpha q_{j}^{3}$\n- $F^{\\mathrm{B,full}}_{j} = - k_{\\mathrm{B}} q_{j}$\n我们得到珠子 $j$ 上的力差表达式：\n$$\n\\Delta F_{j} = \\left( -4 \\alpha q_{\\mathrm{c}}^{3} - k_{\\mathrm{B}} q^{\\mathrm{low}}_{j} \\right) - \\left( -4 \\alpha q_{j}^{3} - k_{\\mathrm{B}} q_{j} \\right) = 4 \\alpha (q_{j}^{3} - q_{\\mathrm{c}}^{3}) + k_{\\mathrm{B}} (q_{j} - q^{\\mathrm{low}}_{j})\n$$\n然后使用这个 $\\Delta \\mathbf{F}$ 计算所有珠子的 RMS 力差。\n\n算法的核心是计算质心 $q_{\\mathrm{c}}$ 和低通投影坐标 $\\mathbf{q}^{\\mathrm{low}}$。\n给定一个珠子位形向量 $\\mathbf{q} = (q_0, \\dots, q_{P-1})$：\n$1$. 质心就是算术平均值：$q_{\\mathrm{c}} = \\dfrac{1}{P} \\sum_{j=0}^{P-1} q_{j}$。\n$2$. 低通投影 $\\mathbf{q}^{\\mathrm{low}} = \\mathcal{P}_{\\mathrm{L}} \\mathbf{q}$ 在环状聚合物简正模式空间中执行，该空间通过离散傅里叶变换 (DFT) 等价于频域。步骤如下：\n    a. 计算珠子坐标的酉 DFT：$\\hat{\\mathbf{q}} = \\dfrac{1}{\\sqrt{P}} \\mathrm{DFT}(\\mathbf{q})$。\n    b. 构建一个滤波器（掩码），对于要保留的模式其值为 $1$，否则为 $0$。要保留的模式是 $k \\in \\{0, 1, \\dots, k_{\\max}\\}$ 及其复共轭伙伴 $P-k$（对于 $k \\in \\{1, \\dots, k_{\\max}\\}$）。对于 $k=0$，它本身就是自己的伙伴。\n    c. 将滤波器应用于变换后的坐标：$\\hat{\\mathbf{q}}^{\\mathrm{low}}_{k} = \\hat{q}_{k} \\cdot \\mathrm{mask}_{k}$。\n    d. 计算滤波后坐标的逆酉 DFT 以获得 $\\mathbf{q}^{\\mathrm{low}}$：$\\mathbf{q}^{\\mathrm{low}} = \\dfrac{1}{1/\\sqrt{P}} \\mathrm{IDFT}(\\hat{\\mathbf{q}}^{\\mathrm{low}}) = \\sqrt{P} \\cdot \\mathrm{IDFT}(\\hat{\\mathbf{q}}^{\\mathrm{low}})$。由于输入 $\\mathbf{q}$ 是实数且滤波器是对称的，$\\mathbf{q}^{\\mathrm{low}}$ 必须是实数。我们取结果的实部以舍弃由浮点不精确性产生的可忽略的虚部。\n\n实现将通过定义一个函数来完成，该函数接受给定测试用例的参数，构建珠子坐标向量 $\\mathbf{q}$，计算 $q_{\\mathrm{c}}$ 和 $\\mathbf{q}^{\\mathrm{low}}$，然后评估 $\\Delta E$ 和 $\\mathrm{RMS}(\\Delta \\mathbf{F})$ 的表达式。这个函数将为所提供的三个测试用例中的每一个被调用。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_quantities(P, beta, m, k_L, alpha, k_B, k_max, q_func):\n    \"\"\"\n    Computes the energy and RMS force differences for a given set of PIMD parameters.\n\n    Args:\n        P (int): Number of beads.\n        beta (float): Inverse temperature.\n        m (float): Mass of the particle.\n        k_L (float): Force constant for the cheap potential V_L.\n        alpha (float): Parameter for the expensive potential Delta V_A.\n        k_B (float): Force constant for the expensive potential Delta V_B.\n        k_max (int): Cutoff for the low-pass projector.\n        q_func (function): A function that takes (j, P) and returns the coordinate q_j.\n\n    Returns:\n        tuple[float, float]: A tuple containing (Delta E, RMS_force_diff).\n    \"\"\"\n\n    # 1. Generate bead coordinates\n    j_indices = np.arange(P)\n    q = q_func(j_indices, P)\n\n    # 2. Calculate intermediate quantities: centroid and low-pass coordinates\n    # 2a. Calculate centroid\n    q_c = np.mean(q)\n\n    # 2b. Calculate low-pass projected coordinates q_low\n    # Unitary DFT\n    q_hat = np.fft.fft(q) / np.sqrt(P)\n\n    # Create the low-pass filter mask\n    mask = np.zeros(P)\n    # Keep modes k = 0, 1, ..., k_max\n    mask[0 : k_max + 1] = 1\n    # Keep partner modes P-k for k = 1, ..., k_max\n    if k_max > 0:\n        mask[P - k_max : P] = 1\n\n    # Apply mask\n    q_hat_low = q_hat * mask\n\n    # Unitary inverse DFT\n    q_low = (np.fft.ifft(q_hat_low) * np.sqrt(P)).real\n\n    # 3. Calculate energy difference Delta E = V_RPC - V_full\n    # The spring and V_L terms cancel, so we only need the expensive parts.\n    # V_A_RPC = P * alpha * q_c^4\n    # V_B_RPC = sum(0.5 * k_B * q_low**2)\n    # V_A_full = sum(alpha * q**4)\n    # V_B_full = sum(0.5 * k_B * q**2)\n    \n    V_RPC = P * alpha * q_c**4 + 0.5 * k_B * np.sum(q_low**2)\n    V_full = alpha * np.sum(q**4) + 0.5 * k_B * np.sum(q**2)\n    \n    delta_E = V_RPC - V_full\n\n    # 4. Calculate RMS force difference\n    # Force difference Delta_F_j = (F_A_RPC_j + F_B_RPC_j) - (F_A_full_j + F_B_full_j)\n    # Delta_F_j = (-4*alpha*q_c^3 - k_B*q_low_j) - (-4*alpha*q_j^3 - k_B*q_j)\n    # Delta_F_j = 4*alpha*(q_j^3 - q_c^3) + k_B*(q_j - q_low_j)\n    \n    delta_F = 4.0 * alpha * (q**3 - q_c**3) + k_B * (q - q_low)\n    \n    rms_force_diff = np.sqrt(np.mean(delta_F**2))\n\n    return delta_E, rms_force_diff\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"P\": 8, \"beta\": 10.0, \"m\": 1.0, \"k_L\": 1.5, \"alpha\": 0.05, \"k_B\": 0.7, \"k_max\": 1,\n            \"q_func\": lambda j, P: 0.3 * np.sin(2 * np.pi * j / P) + 0.1 * np.cos(4 * np.pi * j / P)\n        },\n        {\n            \"P\": 6, \"beta\": 4.0, \"m\": 2.0, \"k_L\": 0.8, \"alpha\": 0.2, \"k_B\": 1.1, \"k_max\": 2,\n            \"q_func\": lambda j, P: 0.2 * np.ones_like(j, dtype=float)\n        },\n        {\n            \"P\": 10, \"beta\": 2.5, \"m\": 1.0, \"k_L\": 0.5, \"alpha\": 0.1, \"k_B\": 2.0, \"k_max\": 1,\n            \"q_func\": lambda j, P: 0.3 * (-1)**j\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_E, rms_force_diff = calculate_quantities(\n            P=case[\"P\"],\n            beta=case[\"beta\"],\n            m=case[\"m\"],\n            k_L=case[\"k_L\"],\n            alpha=case[\"alpha\"],\n            k_B=case[\"k_B\"],\n            k_max=case[\"k_max\"],\n            q_func=case[\"q_func\"]\n        )\n        results.extend([delta_E, rms_force_diff])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}