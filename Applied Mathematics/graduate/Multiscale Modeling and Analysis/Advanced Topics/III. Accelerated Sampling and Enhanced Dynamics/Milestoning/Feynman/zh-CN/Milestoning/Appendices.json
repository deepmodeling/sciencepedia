{
    "hands_on_practices": [
        {
            "introduction": "Milestoning方法的一个核心目标是从微观模拟数据中计算宏观动力学速率。本练习为此提供了基础实践。给定一个已知的里程碑网络，其特征在于里程碑之间的转移概率和局部等待时间，您将推导并计算到达目标状态的平均首达时间（Mean First Passage Time, MFPT），这是衡量过程时间尺度的直接指标。",
            "id": "5259162",
            "problem": "一个生物分子构象变化被划分为多个里程碑表面，这些里程碑表面构成一个马尔可夫更新过程 (MRP)。令集合 $A$ 表示非吸收里程碑 $\\{M_1, M_2, M_3\\}$，集合 $B$ 表示吸收产物态。已使用里程碑之间的短分子动力学片段来估计 $A$ 中里程碑之间的单步转移概率，以及在下一次穿越前每个里程碑上的平均局部等待时间。$A$ 中（即不包括直接跳跃到 $B$）的条件转移概率子矩阵为\n$$\nQ \\;=\\; \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix},\n$$\n且相应的平均局部等待时间向量为\n$$\n\\mathbf{t} \\;=\\; \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix} \\,\\text{ns}.\n$$\n每行中的剩余概率 $1 - \\sum_{j} Q_{ij}$ 代表从里程碑 $i \\in A$ 直接跳跃到 $B$ 的概率。假设在里程碑穿越之间更新性质成立，并且 $Q$ 的谱半径小于 $1$，这确保了平均首达时间是有限的。\n\n从适用于里程碑方法和马尔可夫更新过程的基本原理出发，使用全期望定律推导出确定从每个 $i \\in A$ 到 $B$ 的平均首达时间的线性方程组，并求解这些方程，计算当过程从里程碑 $M_1$ 启动时从集合 $A$ 到集合 $B$ 的平均首达时间。将最终数值结果四舍五入至 $4$ 位有效数字，并以纳秒 ($\\text{ns}$) 为单位表示。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- 非吸收里程碑集合：$A = \\{M_1, M_2, M_3\\}$。\n- 吸收产物态：$B$。\n- $A$ 中里程碑之间的条件转移概率子矩阵：\n$$\nQ = \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix}\n$$\n- 平均局部等待时间向量（单位：纳秒，$\\text{ns}$）：\n$$\n\\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n- 从里程碑 $i \\in A$ 转移到 $B$ 的概率：$1 - \\sum_{j} Q_{ij}$。\n- 其基础随机过程是一个马尔可夫更新过程 (MRP)。\n- $Q$ 的谱半径小于 $1$，记为 $\\rho(Q)  1$。\n- 任务是计算从里程碑 $M_1$ 到状态 $B$ 的平均首达时间 (MFPT)。\n- 最终结果需四舍五入至 $4$ 位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：**该问题是里程碑理论的标准应用，里程碑理论是计算生物物理学中一种成熟的方法，用于从分子动力学模拟中计算动力学速率。使用马尔可夫更新过程、转移概率和平均局部等待时间的表述是正确的，并且是该理论的核心。\n- **适定性：**该问题是适定的。它要求计算从一组瞬态到一个吸收态的平均首达时间 (MFPT)。所提供的数据，即瞬态到瞬态的概率子矩阵 $Q$ 和平均局部等待时间向量 $\\mathbf{t}$，正是所需的量。关键条件 $\\rho(Q)  1$ 保证了矩阵 $(I-Q)$ 是可逆的，从而确保了 MFPT 是有限的并且存在唯一解。\n- **客观性：**该问题使用精确、无歧义的数学语言陈述，不含任何主观或基于观点的内容。\n\n**步骤 3：结论与行动**\n该问题具有科学依据、适定、客观且内部一致。它被认为是**有效的**。我们可以继续进行求解。\n\n### 解\n目标是计算从里程碑 $M_1$ 到吸收态 $B$ 的平均首达时间 (MFPT)。令 $\\tau_i$ 表示从非吸收里程碑 $M_i \\in A$ 到状态 $B$ 的 MFPT。我们要求解的是 $\\tau_1$ 的值。\n\n此计算的基本原理是全期望定律，应用于描述里程碑之间转移的马尔可夫更新过程。对于任何起始里程碑 $M_i$，到达吸收态 $B$ 的总时间可以分解为两部分：\n$1$. 在下一次转移发生前，在里程碑 $M_i$ 附近花费的平均局部等待时间 $t_i$。\n$2$. 从后续状态到达 $B$ 的期望时间，该时间是对所有可能的下一个状态进行平均得到的。\n\n在等待时间 $t_i$ 之后，系统从里程碑 $M_i$ 转移到另一个状态。下一个状态有两种可能性：\n- 系统转移到另一个非吸收里程碑 $M_j \\in A$。这以条件概率 $Q_{ij}$ 发生。一旦到达 $M_j$，根据定义，到达 $B$ 的剩余期望时间为 $\\tau_j$。\n- 系统直接转移到吸收态 $B$。这以概率 $P_{iB} = 1 - \\sum_{j \\in A} Q_{ij}$ 发生。一旦进入状态 $B$，过程就终止了，到达 $B$ 的剩余时间为 $0$。\n\n通过应用全期望定律，我们可以通过对第一次转移进行条件化来写出 $\\tau_i$ 的方程：\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\cdot \\tau_j + \\left(1 - \\sum_{j \\in A} Q_{ij}\\right) \\cdot 0\n$$\n这可以简化为一个线性方程组：\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\tau_j \\quad \\text{ for } i \\in \\{1, 2, 3\\}\n$$\n\n令 $\\boldsymbol{\\tau}$ 为未知 MFPT 的列向量，$\\boldsymbol{\\tau} = [\\tau_1, \\tau_2, \\tau_3]^T$。该方程组可以写成矩阵形式：\n$$\n\\boldsymbol{\\tau} = \\mathbf{t} + Q \\boldsymbol{\\tau}\n$$\n其中 $\\mathbf{t}$ 是平均局部等待时间向量，$Q$ 是非吸收里程碑之间的条件转移概率矩阵。\n\n为了求解 $\\boldsymbol{\\tau}$，我们重排方程：\n$$\n\\boldsymbol{\\tau} - Q \\boldsymbol{\\tau} = \\mathbf{t}\n$$\n$$\n(I - Q) \\boldsymbol{\\tau} = \\mathbf{t}\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵。然后通过对矩阵 $(I - Q)$ 求逆来获得解：\n$$\n\\boldsymbol{\\tau} = (I - Q)^{-1} \\mathbf{t}\n$$\n谱半径 $\\rho(Q)  1$ 的条件确保了矩阵 $(I - Q)$ 是可逆的。\n\n我们已知：\n$$\nQ = \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n\n首先，我们构造矩阵 $(I-Q)$：\n$$\nI - Q = \\begin{bmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix} - \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix} = \\begin{bmatrix}\n1  -0.3  -0.4 \\\\\n-0.2  1  -0.5 \\\\\n-0.1  -0.6  1\n\\end{bmatrix}\n$$\n\n接下来，我们计算该矩阵的逆矩阵 $(I-Q)^{-1}$。逆矩阵由公式 $\\frac{1}{\\det(I-Q)} \\text{adj}(I-Q)$ 给出。\n$(I-Q)$ 的行列式为：\n$$\n\\det(I-Q) = 1(1 \\cdot 1 - (-0.5)(-0.6)) - (-0.3)((-0.2) \\cdot 1 - (-0.5)(-0.1)) + (-0.4)((-0.2)(-0.6) - 1(-0.1))\n$$\n$$\n\\det(I-Q) = 1(1 - 0.3) + 0.3(-0.2 - 0.05) - 0.4(0.12 + 0.1)\n$$\n$$\n\\det(I-Q) = 0.7 + 0.3(-0.25) - 0.4(0.22) = 0.7 - 0.075 - 0.088 = 0.537\n$$\n\n伴随矩阵 $\\text{adj}(I-Q)$ 是代数余子式矩阵的转置。代数余子式 $C_{ij}$ 为：\n$C_{11} = 1 - 0.3 = 0.7$\n$C_{12} = -(-0.2 - 0.05) = 0.25$\n$C_{13} = 0.12 + 0.1 = 0.22$\n$C_{21} = -(-0.3 - 0.24) = 0.54$\n$C_{22} = 1 - 0.04 = 0.96$\n$C_{23} = -(-0.6 - 0.03) = 0.63$\n$C_{31} = 0.15 + 0.4 = 0.55$\n$C_{32} = -(-0.5 - 0.08) = 0.58$\n$C_{33} = 1 - 0.06 = 0.94$\n\n代数余子式矩阵为 $\\begin{bmatrix} 0.7  0.25  0.22 \\\\ 0.54  0.96  0.63 \\\\ 0.55  0.58  0.94 \\end{bmatrix}$。伴随矩阵是其转置：\n$$\n\\text{adj}(I-Q) = \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix}\n$$\n\n所以，逆矩阵是：\n$$\n(I-Q)^{-1} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix}\n$$\n\n现在我们可以计算 MFPT 向量 $\\boldsymbol{\\tau}$：\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix} \\begin{bmatrix}\n4 \\\\\n6 \\\\\n5\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n(0.7)(4) + (0.54)(6) + (0.55)(5) \\\\\n(0.25)(4) + (0.96)(6) + (0.58)(5) \\\\\n(0.22)(4) + (0.63)(6) + (0.94)(5)\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n2.8 + 3.24 + 2.75 \\\\\n1.0 + 5.76 + 2.9 \\\\\n0.88 + 3.78 + 4.7\n\\end{bmatrix}\n= \\frac{1}{0.537} \\begin{bmatrix}\n8.79 \\\\\n9.66 \\\\\n9.36\n\\end{bmatrix}\n$$\n\n从里程碑 $M_1$ 开始的 MFPT 是 $\\tau_1$，即向量 $\\boldsymbol{\\tau}$ 的第一个元素：\n$$\n\\tau_1 = \\frac{8.79}{0.537} \\approx 16.368715...\n$$\n问题要求将答案四舍五入到 $4$ 位有效数字。\n$$\n\\tau_1 \\approx 16.37 \\, \\text{ns}\n$$\n其他的 MFPT 分别是 $\\tau_2 \\approx 17.99 \\, \\text{ns}$ 和 $\\tau_3 \\approx 17.43 \\, \\text{ns}$。所求的量是 $\\tau_1$。",
            "answer": "$$\n\\boxed{16.37}\n$$"
        },
        {
            "introduction": "马尔可夫假设的有效性是Milestoning框架的核心，而这在很大程度上取决于里程碑的设置。本练习深入探讨提交者概率（committor probability）的概念，用以诊断和改进里程碑的定义。您将通过计算重返（recrossing）分数来量化“记忆”效应，并根据等提交者概率面（isocommittor surfaces）的原则确定界面的最佳位置。",
            "id": "5259164",
            "problem": "考虑生物分子模拟中用于多尺度动力学的里程碑框架，其中构型空间被一系列界面 $\\Sigma_i$（称为里程碑）划分，轨迹根据过阻尼动力学演化。在两个相邻界面 $\\Sigma_i$ 和 $\\Sigma_{i+1}$ 之间的区间内，假设存在具有恒定漂移和扩散的一维过阻尼朗之万（Smoluchowski）动力学，由随机微分方程 $dX_t = \\mu\\,dt + \\sigma\\,dW_t$ 建模，其中 $X_t$ 是以纳米为单位的位置，$t$ 是以纳秒为单位的时间，$\\mu$ 是以纳米/纳秒为单位的恒定漂移，$\\sigma$ 是以纳米/根号纳秒为单位的恒定噪声振幅，$W_t$ 是标准布朗运动。在局部线性势下的热平衡中，漂移和扩散满足爱因斯坦关系 $\\mu / D = -\\beta\\,G$，其中扩散系数 $D$ 的单位为 $\\mathrm{nm}^2/\\mathrm{ns}$，逆热能 $\\beta = 1/(k_B T)$ 的单位为 $\\mathrm{mol}/\\mathrm{kJ}$，玻尔兹曼常数 $k_B$ 的单位为 $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{K})$，绝对温度 $T$ 的单位为 $\\mathrm{K}$，恒定势梯度 $G$ 的单位为 $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{nm})$。噪声振幅和扩散通过 $\\sigma^2 = 2D$ 相关联。\n\n将前向提交者概率 $q(x)$ 定义为：从位置 $x \\in (a,b)$（其中 $a$ 等同于 $\\Sigma_i$，$b$ 等同于 $\\Sigma_{i+1}$）开始，轨迹在返回到 $a$ 之前到达 $b$ 的概率。对于刚刚穿过 $\\Sigma_i$ 进入区间 $(a,b)$ 的轨迹，将再穿越分数 $r$ 定义为：从 $x_0 = a + \\delta$（其中 $\\delta$ 是以纳米为单位的小位移）开始，在首次到达 $\\Sigma_{i+1}$ 之前返回到 $\\Sigma_i$ 的概率。因此，$r = 1 - q(x_0)$。\n\n任务：\n- 从第一性原理出发，以在 $x=a$ 和 $x=b$ 处有吸收边界的 $dX_t = \\mu\\,dt + \\sigma\\,dW_t$ 下的到达概率的后向方程为起点，推导 $q(x)$ 的函数形式，并由此推导出在 $x_0 = a + \\delta$ 处的再穿越分数 $r$ 的表达式。\n- 提出一种在 $(a,b)$ 内部对界面 $\\Sigma_i$ 的修正性重定义，该重定义通过将界面重参数化为等提交者概率曲面来减少记忆效应。具体来说，通过准则 $q(x^\\star) = c$（其中 $c = 0.5$，即值为0.5的等提交者概率面）来定义新界面位置 $x^\\star$。用 $(a,b,\\mu,\\sigma)$ 推导出 $x^\\star$，并一致地处理零漂移极限 $\\mu \\to 0$。\n\n您的程序必须实现推导出的表达式，并为每个提供的测试用例计算：\n- 从 $x_0 = a + \\delta$ 初始化的轨迹对应的再穿越分数 $r$。\n- 满足 $q(x^\\star) = 0.5$ 的建议新界面位置 $x^\\star$。\n\n物理单位和输出规范：\n- 位置 $a$、$b$、$\\delta$ 和 $x^\\star$ 必须以纳米为单位处理和报告。\n- 扩散系数 $D$ 必须以 $\\mathrm{nm}^2/\\mathrm{ns}$ 为单位处理。\n- 绝对温度 $T$ 必须以 $\\mathrm{K}$ 为单位处理。\n- 势梯度 $G$ 必须以 $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{nm})$ 为单位处理。\n- 再穿越分数 $r$ 是无量纲的。\n- 使用 $k_B = 0.008314462618$ $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{K})$。\n- 将 $x^\\star$ 和 $r$ 分别四舍五入到六位小数。\n\n测试套件：\n为以下参数集提供计算，每个参数集指定为 $(a,b,D,T,G,\\delta)$：\n1. $(0.0, 1.0, 0.1, 300.0, -0.5, 0.01)$: 正常路径，具有中等向右漂移（预期再穿越减少）。\n2. $(0.0, 1.0, 0.1, 300.0, 0.0, 0.01)$: 边界情况，纯扩散（无漂移）。\n3. $(0.0, 1.0, 0.1, 300.0, 2.0, 0.01)$: 反向左漂移（预期高再穿越）。\n4. $(0.3, 0.5, 0.1, 300.0, -0.5, 0.002)$: 窄区间，具有中等向右漂移。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含以逗号分隔并用方括号括起来的结果列表。每个测试用例贡献一对 $[r, x^\\star]$，因此总体输出必须是 $[[r_1,x^\\star_1],[r_2,x^\\star_2],\\ldots]$ 的形式，没有空格，并且每个数值都四舍五入到六位小数。",
            "solution": "该问题要求在一个由过阻尼朗之万动力学支配的一维系统中，在里程碑框架内推导和计算两个量：从一个界面出发的再穿越分数 $r$ 和由等提交者概率曲面定义的修正界面的位置 $x^\\star$。\n\n系统的动力学由以下随机微分方程（SDE）描述：\n$$dX_t = \\mu\\,dt + \\sigma\\,dW_t$$\n其中 $X_t$ 是位置，$\\mu$ 是恒定漂移，$\\sigma$ 是噪声振幅，通过 $\\sigma^2 = 2D$ 与扩散系数 $D$ 相关。漂移 $\\mu$ 通过爱因斯坦关系 $\\mu/D = -\\beta G$ 与恒定的外部势梯度 $G$ 相关，其中 $\\beta = 1/(k_B T)$ 是逆热能。\n\n结合这些关系，我们可以表达将在我们推导中出现的项 $\\frac{2\\mu}{\\sigma^2}$：\n$$\\frac{2\\mu}{\\sigma^2} = \\frac{2\\mu}{2D} = \\frac{\\mu}{D} = -\\beta G = -\\frac{G}{k_B T}$$\n这个量概括了漂移与扩散的比率，将是解决方案的核心。\n\n**第1部分：前向提交者概率 $q(x)$ 的推导**\n\n前向提交者概率 $q(x)$ 是指从区间 $(a, b)$ 中的位置 $x$ 开始的轨迹在到达边界 $x=a$ 之前先到达边界 $x=b$ 的概率。它是到达概率的后向科尔莫戈罗夫方程的解，这是一个二阶常微分方程（ODE）。对于给定的SDE，其后向算子 $\\mathcal{L}$ 为：\n$$\\mathcal{L} = \\mu \\frac{d}{dx} + \\frac{\\sigma^2}{2} \\frac{d^2}{dx^2}$$\n提交者概率 $q(x)$ 在定义域 $(a, b)$ 上满足 $\\mathcal{L}q(x) = 0$，并服从反映边界吸收性质的边界条件：\n$$q(a) = 0$$\n$$q(b) = 1$$\n需要求解的ODE是：\n$$\\frac{\\sigma^2}{2} \\frac{d^2q}{dx^2} + \\mu \\frac{dq}{dx} = 0$$\n这是一个二阶线性齐次常系数常微分方程。我们可以通过先令 $z(x) = \\frac{dq}{dx}$ 来求其通解，这将方程转换为关于 $z(x)$ 的一阶ODE：\n$$\\frac{\\sigma^2}{2} \\frac{dz}{dx} + \\mu z = 0 \\implies \\frac{dz}{z} = -\\frac{2\\mu}{\\sigma^2} dx$$\n积分得到 $\\ln(z) = -\\frac{2\\mu}{\\sigma^2} x + C_1$，或 $z(x) = C_2 e^{-2\\mu x / \\sigma^2}$。\n对 $z(x)$ 积分以求得 $q(x)$：\n$$q(x) = \\int C_2 e^{-2\\mu x / \\sigma^2} dx = C_2 \\left( -\\frac{\\sigma^2}{2\\mu} \\right) e^{-2\\mu x / \\sigma^2} + C_3$$\n为方便起见，我们将通解写为：\n$$q(x) = A e^{-2\\mu x / \\sigma^2} + B$$\n应用边界条件：\n1. $q(a) = A e^{-2\\mu a / \\sigma^2} + B = 0 \\implies B = -A e^{-2\\mu a / \\sigma^2}$\n2. $q(b) = A e^{-2\\mu b / \\sigma^2} + B = 1$\n\n将 $B$ 代入第二个方程：\n$$A e^{-2\\mu b / \\sigma^2} - A e^{-2\\mu a / \\sigma^2} = 1 \\implies A \\left( e^{-2\\mu b / \\sigma^2} - e^{-2\\mu a / \\sigma^2} \\right) = 1$$\n$$A = \\frac{1}{e^{-2\\mu b / \\sigma^2} - e^{-2\\mu a / \\sigma^2}}$$\n将 $A$ 和 $B$ 代回 $q(x)$ 的表达式：\n$$q(x) = \\frac{e^{-2\\mu x / \\sigma^2} - e^{-2\\mu a / \\sigma^2}}{e^{-2\\mu b / \\sigma^2} - e^{-2\\mu a / \\sigma^2}}$$\n这是当 $\\mu \\neq 0$ 时提交者概率的函数形式。\n\n对于零漂移情况，即 $\\mu = 0$，ODE 简化为 $\\frac{\\sigma^2}{2} \\frac{d^2q}{dx^2} = 0$，这意味着 $q''(x)=0$。通解为 $q(x) = C_1 x + C_2$。应用边界条件：\n1. $q(a) = C_1 a + C_2 = 0 \\implies C_2 = -C_1 a$\n2. $q(b) = C_1 b + C_2 = 1 \\implies C_1(b-a) = 1 \\implies C_1 = \\frac{1}{b-a}$\n因此，对于 $\\mu=0$：\n$$q(x) = \\frac{x-a}{b-a}$$\n这个结果也可以通过对 $q(x)$ 的一般表达式使用洛必达法则取极限 $\\mu \\to 0$ 得到。\n\n为保证数值稳定性和清晰性，我们定义 $\\lambda = -2\\mu/\\sigma^2 = \\beta G = G/(k_B T)$。$q(x)$ 的表达式变为：\n$$q(x) = \\frac{e^{\\lambda x} - e^{\\lambda a}}{e^{\\lambda b} - e^{\\lambda a}} = \\frac{e^{\\lambda a}(e^{\\lambda(x-a)} - 1)}{e^{\\lambda a}(e^{\\lambda(b-a)} - 1)} = \\frac{e^{\\lambda(x-a)} - 1}{e^{\\lambda(b-a)} - 1}$$\n这种形式适合计算，特别是使用 `expm1` 函数计算 $e^z - 1$。\n\n**第2部分：再穿越分数 $r$ 的计算**\n\n再穿越分数 $r$ 定义为从一个无穷小位移的位置 $x_0 = a + \\delta$ 开始，在到达 $\\Sigma_{i+1} \\equiv b$ 之前返回到 $\\Sigma_i \\equiv a$ 的概率。根据定义，这是前向提交者概率在 $x_0$ 处的补集：\n$$r = 1 - q(x_0) = 1 - q(a+\\delta)$$\n将 $x = a+\\delta$ 代入我们推导的 $q(x)$ 表达式：\n对于 $\\mu \\neq 0$（或 $\\lambda \\neq 0$）：\n$$r = 1 - \\frac{e^{\\lambda(a+\\delta)} - e^{\\lambda a}}{e^{\\lambda b} - e^{\\lambda a}} = 1 - \\frac{e^{\\lambda \\delta} - 1}{e^{\\lambda (b-a)} - 1}$$\n对于 $\\mu = 0$（或 $\\lambda = 0$）：\n$$r = 1 - \\frac{(a+\\delta) - a}{b-a} = 1 - \\frac{\\delta}{b-a}$$\n\n**第3部分：等提交者概率界面位置 $x^\\star$ 的推导**\n\n新界面位置 $x^\\star$ 由等提交者概率条件 $q(x^\\star) = c$ 定义，其中 $c=0.5$。\n对于 $\\mu \\neq 0$（或 $\\lambda \\neq 0$）：\n$$\\frac{e^{\\lambda x^\\star} - e^{\\lambda a}}{e^{\\lambda b} - e^{\\lambda a}} = 0.5$$\n解出 $e^{\\lambda x^\\star}$：\n$$e^{\\lambda x^\\star} - e^{\\lambda a} = 0.5 (e^{\\lambda b} - e^{\\lambda a})$$\n$$e^{\\lambda x^\\star} = e^{\\lambda a} + 0.5 e^{\\lambda b} - 0.5 e^{\\lambda a} = 0.5 (e^{\\lambda a} + e^{\\lambda b})$$\n取自然对数并解出 $x^\\star$：\n$$\\lambda x^\\star = \\ln\\left(0.5 (e^{\\lambda a} + e^{\\lambda b})\\right)$$\n$$x^\\star = \\frac{1}{\\lambda} \\ln\\left(0.5 (e^{\\lambda a} + e^{\\lambda b})\\right)$$\n对于 $\\mu = 0$（或 $\\lambda = 0$）：\n$$\\frac{x^\\star - a}{b-a} = 0.5$$\n$$x^\\star = a + 0.5(b-a) = 0.5(a+b)$$\n正如预期的，对于纯扩散，值为0.5的提交者概率曲面位于区间的几何中点。\n\n这些推导出的公式在所提供的程序中实现，用于计算给定测试用例所需的值。首先从输入计算参数 $\\lambda = G/(k_B T)$，其值决定了是使用通用公式（$\\lambda \\neq 0$）还是特殊情况公式（$\\lambda = 0$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import expm1\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the milestoning problem for the given test cases.\n\n    The solution involves:\n    1. Deriving the forward committor q(x) for 1D overdamped Langevin dynamics.\n    2. Using q(x) to find the recrossing fraction r = 1 - q(a + delta).\n    3. Finding the isocommittor surface position x* where q(x*) = 0.5.\n    \"\"\"\n    \n    # Define the Boltzmann constant in kJ/(mol·K)\n    K_B = 0.008314462618\n\n    # Test cases: (a, b, D, T, G, delta)\n    # a, b: interval boundaries in nm\n    # D: diffusion coefficient in nm^2/ns\n    # T: absolute temperature in K\n    # G: potential gradient in kJ/(mol·nm)\n    # delta: initial displacement in nm\n    test_cases = [\n        (0.0, 1.0, 0.1, 300.0, -0.5, 0.01),\n        (0.0, 1.0, 0.1, 300.0, 0.0, 0.01),\n        (0.0, 1.0, 0.1, 300.0, 2.0, 0.01),\n        (0.3, 0.5, 0.1, 300.0, -0.5, 0.002),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, D, T, G, delta = case\n        \n        # Calculate the composite parameter lambda = G / (k_B * T)\n        # This parameter combines drift and diffusion characteristics.\n        # lambda = -2*mu/sigma^2 = G / (k_B*T)\n        k_b_T = K_B * T\n        \n        # A small tolerance to handle the zero-drift case robustly\n        TOLERANCE = 1e-9\n\n        if abs(G)  TOLERANCE: # Handle the zero drift (mu = 0) case\n            # For pure diffusion, the committor is linear: q(x) = (x-a)/(b-a)\n            # Recrossing fraction r = 1 - q(a + delta)\n            if b - a > 0:\n                r = 1.0 - delta / (b - a)\n            else:\n                # Should not happen with valid inputs, but handle defensively\n                r = 1.0\n            \n            # Isocommittor surface q(x*) = 0.5 is at the midpoint\n            x_star = a + 0.5 * (b - a)\n        else: # Handle the non-zero drift (mu != 0) case\n            lam = G / k_b_T\n            \n            # Calculate recrossing fraction r = 1 - q(a + delta)\n            # q(x) = (exp(lam*(x-a)) - 1) / (exp(lam*(b-a)) - 1)\n            # We use scipy.special.expm1 for numerical stability when the argument is small.\n            # q(a + delta) = expm1(lam * delta) / expm1(lam * (b - a))\n            numerator_r = expm1(lam * delta)\n            denominator_r = expm1(lam * (b - a))\n            \n            if abs(denominator_r) > TOLERANCE:\n                q_at_x0 = numerator_r / denominator_r\n                r = 1.0 - q_at_x0\n            else:\n                # This case might indicate an issue, but for small arguments expm1(z) ~ z\n                q_at_x0 = (lam * delta) / (lam * (b-a))\n                r = 1.0 - q_at_x0\n\n            # Calculate isocommittor surface position x* where q(x*) = 0.5\n            # Derived formula: x* = (1/lam) * ln(0.5 * (exp(lam*a) + exp(lam*b)))\n            # We use np.log and np.exp which are generally robust.\n            x_star = (1.0 / lam) * np.log(0.5 * (np.exp(lam * a) + np.exp(lam * b)))\n            \n        # Round the results to six decimal places as required\n        r_rounded = round(r, 6)\n        x_star_rounded = round(x_star, 6)\n        \n        results.append([r_rounded, x_star_rounded])\n\n    # Format the final output string\n    # E.g., [[0.988978,0.475],[0.99,0.5],...]\n    output_str = \"[\" + \",\".join([f\"[{r},{x}]\" for r, x in results]) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Milestoning将原始轨迹数据转化为一个离散的动力学网络。本练习模拟了该工作流程中的一个关键步骤：分析该网络的性质以验证底层粗粒度模型的有效性。利用测量的跨越计数，您将计算离散的提交者概率，并利用其沿着反应坐标的光滑度作为诊断工具，以评估所选里程碑的质量。",
            "id": "5259212",
            "problem": "给定生物分子模拟中一组有限里程碑之间测得的跨越统计数据，要求您估计前向“committor”概率，解读其平滑性，并报告诊断值。考虑一个定义在由整数 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的有限里程碑集合上的离散时间马尔可夫链，其行随机转移矩阵 $P$ 是从跨越计数中推断出来的。前向 committor $q(i)$ 定义为从里程碑 $i$ 开始的轨迹在击中指定的反应物集 $A$ 之前，先击中指定的产物集 $B$ 的概率，其中 $A$ 和 $B$ 构成了 committor 的吸收边界。在离散里程碑法中，committor 由后向方程和边界条件确定：对于 $i \\notin A \\cup B$，有 $q(i) = \\sum_{j} P_{ij} \\, q(j)$；对于 $i \\in A$，有 $q(i) = 0$；对于 $i \\in B$，有 $q(i) = 1$。为了进行解读，当里程碑足够精细和均匀时，我们期望 committor 沿着粗粒度反应坐标 $s(i)$ 平滑变化；与平滑性的偏离可能表明里程碑内部存在动力学异质性、分辨率不足，或在所选粗粒度水平上存在非马尔可夫效应。\n\n使用的基本原理：\n- 具有行随机转移矩阵 $P$（对每一行 $i$ 都有 $\\sum_{j} P_{ij} = 1$）的离散时间马尔可夫链。\n- 前向 committor $q(i)$ 的定义，即在击中 $A$ 之前先击中 $B$ 的概率。\n- 使用全概率定律和马尔可夫性质推导后向方程。\n\n您的任务是编写一个完整的程序，该程序：\n1. 通过按行归一化测量的跨越计数 $C_{ij}$ 来构造转移概率矩阵 $P$，即 $P_{ij} = C_{ij} / \\sum_{k} C_{ik}$。\n2. 通过强制所有 $i \\in A$ 满足 $q(i) = 0$ 和所有 $i \\in B$ 满足 $q(i) = 1$，并求解由 $q=Pq$ 对所有内部 $i \\notin A \\cup B$ 所隐含的相应线性方程组，来求解里程碑集合上的 committor $q$。\n3. 使用非均匀网格上离散二阶导数的最大绝对值，量化 $q$ 沿给定标量粗粒度坐标 $s(i)$ 的平滑性偏离。设 $i$ 按 $s(i)$ 的递增顺序列举里程碑，并对于此排序顺序中具有邻居的内部索引 $i$，定义 $h_{1} = s(i) - s(i-1)$ 和 $h_{2} = s(i+1) - s(i)$。在 $i$ 处的二阶导数的非均匀三点近似为\n$$\nq''(s(i)) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q(i+1) - q(i)}{h_{2}} - \\frac{q(i) - q(i-1)}{h_{1}} \\right).\n$$\n将平滑性偏离度量 $S$ 定义为在所有按 $s$ 排序后同时具有两个邻居（不包括端点）的内部索引上，此近似值的最大绝对值。以无量纲浮点数形式报告 $S$。\n4. 生成单行输出，其中包含六个浮点数：下面描述的三个测试用例中，每个用例在指定目标内部里程碑索引处的 committor 值和平滑性偏离 $S$，连接成一个用方括号括起来的、逗号分隔的列表。\n\n测试套件：\n- 案例1（基准一维链）：\n  - 里程碑索引为 $i \\in \\{0,1,2,3,4\\}$。\n  - 反应物集 $A = \\{0\\}$ 和产物集 $B = \\{4\\}$。\n  - 跨越计数矩阵 $C^{(1)}$：\n    $$\n    C^{(1)} =\n    \\begin{bmatrix}\n    0  100  0  0  0 \\\\\n    50  0  50  0  0 \\\\\n    0  50  0  50  0 \\\\\n    0  0  50  0  50 \\\\\n    0  0  0  100  0\n    \\end{bmatrix}.\n    $$\n  - 粗粒度坐标 $s^{(1)} = [0, 1, 2, 3, 4]$。\n  - 报告 $q^{(1)}(2)$ 和 $S^{(1)}$。\n\n- 案例2（导致曲率的瓶颈）：\n  - 里程碑索引为 $i \\in \\{0,1,2,3,4\\}$。\n  - 反应物集 $A = \\{0\\}$ 和产物集 $B = \\{4\\}$。\n  - 跨越计数矩阵 $C^{(2)}$：\n    $$\n    C^{(2)} =\n    \\begin{bmatrix}\n    0  100  0  0  0 \\\\\n    70  0  30  0  0 \\\\\n    0  90  0  10  0 \\\\\n    0  0  30  0  70 \\\\\n    0  0  0  100  0\n    \\end{bmatrix}.\n    $$\n  - 粗粒度坐标 $s^{(2)} = [0, 1, 2, 3, 4]$。\n  - 报告 $q^{(2)}(2)$ 和 $S^{(2)}$。\n\n- 案例3（粗粒度坐标上的分支连接）：\n  - 里程碑索引为 $i \\in \\{0,1,2,3,4,5\\}$。\n  - 反应物集 $A = \\{0\\}$ 和产物集 $B = \\{5\\}$。\n  - 跨越计数矩阵 $C^{(3)}$：\n    $$\n    C^{(3)} =\n    \\begin{bmatrix}\n    0  200  0  0  0  0 \\\\\n    100  0  50  50  0  0 \\\\\n    0  40  0  0  60  0 \\\\\n    0  40  0  0  60  0 \\\\\n    0  0  50  50  0  100 \\\\\n    0  0  0  0  200  0\n    \\end{bmatrix}.\n    $$\n  - 粗粒度坐标 $s^{(3)} = [0, 1, 2, 2.5, 3.5, 4]$。\n  - 报告 $q^{(3)}(2)$ 和 $S^{(3)}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个结果，格式为用方括号括起来的逗号分隔列表，并严格按照以下顺序\n$$\n[q^{(1)}(2), S^{(1)}, q^{(2)}(2), S^{(2)}, q^{(3)}(2), S^{(3)}].\n$$\n所有六个输出都必须是浮点数。不涉及物理单位；概率和平滑性偏离都是无量纲的。不使用角度。使用标准十进制表示法表示浮点数。程序必须是自包含的，不需要任何输入，并使用指定的库；它必须从提供的跨越计数计算 $P$，求解 committor，计算平滑性偏离，并完全按照规定打印最后一行。",
            "solution": "该问题提出了一个在分析源自生物分子模拟的离散时间马尔可夫链模型中的明确任务，特别是在里程碑法（milestoning）的背景下。它要求计算前向 committor 概率及其平滑性的度量。该问题具有科学依据，数学上是适定的，并且提供了所有必要的数据和定义。因此，我们可以着手解决。\n\n问题的核心是确定一组里程碑的前向 committor $q(i)$，其中里程碑由 $i \\in \\{0, 1, \\dots, N-1\\}$ 索引。Committor $q(i)$ 是从里程碑 $i$ 开始的轨迹在到达反应物集 $A$ 中的一个里程碑之前，首先到达产物集 $B$ 中的一个里程碑的概率。$A$ 和 $B$ 集是吸收边界，其 committor 值由定义固定：\n$$ q(i) = 0, \\quad \\forall i \\in A $$\n$$ q(i) = 1, \\quad \\forall i \\in B $$\n\n对于所有其他被称为内部里程碑（$i \\notin A \\cup B$）的里程碑，committor 必须满足后向 Kolmogorov 方程。对于具有行随机转移矩阵 $P$ 的离散时间马尔可夫链，此方程是通过考虑过程的第一步，从全概率定律推导出来的：\n$$ q(i) = \\sum_{j=0}^{N-1} P_{ij} q(j), \\quad \\forall i \\notin A \\cup B $$\n在这里，$P_{ij}$ 是在一步内从里程碑 $i$ 转移到里程碑 $j$ 的概率。矩阵 $P$ 是通过对给定的跨越计数矩阵 $C$进行归一化得到的，其中 $C_{ij}$ 是观察到的从 $i$ 到 $j$ 的转移次数。归一化是按行执行的：\n$$ P_{ij} = \\frac{C_{ij}}{\\sum_{k=0}^{N-1} C_{ik}} $$\n这假设需要计算 $P_{ij}$ 的任何里程碑 $i$ 的出向转移总数不为零，所提供的数据满足此条件。\n\n为了求解内部里程碑处未知的 committor 值，我们可以构建一个线性方程组。设内部里程碑的集合为 $I$。对于任何 $i \\in I$，后向方程可以通过将状态和分离到 $A$、$B$ 和 $I$ 上来重写：\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in A} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} q(j) $$\n代入已知的边界条件 $q(j)=0$（对于 $j \\in A$）和 $q(j)=1$（对于 $j \\in B$）：\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} (1) $$\n整理这些项可以得到一个关于内部 committor 值向量 $q_I$ 的线性系统：\n$$ q(i) - \\sum_{j \\in I} P_{ij} q(j) = \\sum_{j \\in B} P_{ij} $$\n这可以表示为矩阵形式 $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$，其中 $\\mathbf{P}_{II}$ 是 $P$ 中包含内部状态之间转移的子矩阵，$\\mathbf{q}_I$ 是 $I$ 中状态的 committor 值向量，而右侧向量 $\\mathbf{b}$ 的元素为 $b_i = \\sum_{j \\in B} P_{ij}$。这个系统可以使用标准的线性代数方法求解 $\\mathbf{q}_I$。\n\n任务的第二部分是计算平滑性偏离 $S$。该度量量化了当 committor 函数 $q(i)$ 相对于粗粒度反应坐标 $s(i)$ 绘制时其非线性程度。我们首先根据里程碑的 $s(i)$ 值对其进行排序。然后，对于这个排序列表中既有前驱又有后继的每个内部里程碑，我们使用非均匀网格的三点有限差分公式来近似 $q$ 相对于 $s$ 的二阶导数。设排序后的里程碑由 $j \\in \\{0, \\dots, N-1\\}$ 索引，使得 $s_j  s_{j+1}$。对于排序列表中索引为 $j$ 的点（对应于原始里程碑索引 $k$），其公式为：\n$$ q''(s_k) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q_{j+1} - q_{j}}{h_{2}} - \\frac{q_{j} - q_{j-1}}{h_{1}} \\right) $$\n其中 $h_1 = s_j - s_{j-1}$，$h_2 = s_{j+1} - s_j$，$q_j$ 是在排序后位置 $j$ 的里程碑处的 committor 值。度量 $S$ 是在所有适用的内部里程碑上这些二阶导数近似值的最大绝对值。\n\n计算过程如下：\n1. 对于每个测试用例，从计数矩阵 $C$ 构造转移矩阵 $P$。\n2. 识别反应物（$A$）、产物（$B$）和内部（$I$）里程碑集合。\n3. 构建并求解线性系统 $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$，以找到所有 $i \\in I$ 的 committor 值。\n4. 组装完整的 committor 向量 $q$，包括边界值。\n5. 根据粗粒度坐标 $s$ 对里程碑进行排序。\n6. 在每个具有邻居的内部里程碑位置计算二阶导数近似值。\n7. 确定 $S$ 为所计算导数的绝对值的最大值。\n8. 提取所需的 committor 值 $q(i_{target})$ 和平滑性度量 $S$。\n\n对于案例1（基准一维链）：\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$。转移矩阵 $P^{(1)}$ 对于内部转移是对称的，$P_{i,i-1}=P_{i,i+1}=0.5$（对于 $i \\in I$）。$q^{(1)}$ 的方程组为：\n$q(1) = 0.5q(2)$\n$q(2) = 0.5q(1) + 0.5q(3)$\n$q(3) = 0.5q(2) + 0.5$\n求解该系统得出 $q^{(1)}=(0, 0.25, 0.5, 0.75, 1)^{T}$。请求的 committor 值为 $q^{(1)}(2)=0.5$。粗粒度坐标是 $s^{(1)}=(0,1,2,3,4)$，这是线性的。Committor $q^{(1)}(i)$ 是 $s^{(1)}(i)$ 的线性函数，导致所有点的二阶导数均为零。因此，$S^{(1)}=0.0$。\n\n对于案例2（瓶颈）：\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$。$P^{(2)}$ 中的不对称转移概率引入了偏差。求解相应的线性系统得出 $q^{(2)}=(0, 0.03, 0.1, 0.73, 1)^{T}$，所以 $q^{(2)}(2)=0.1$。Committor 是高度非线性的。使用 $s^{(2)}=(0,1,2,3,4)$，在 $s=1, 2, 3$ 处计算二阶导数。其值为 $0.04$，$0.56$ 和 $-0.36$。最大绝对值为 $S^{(2)}=0.56$。\n\n对于案例3（分支连接）：\n$A=\\{0\\}$, $B=\\{5\\}$, $I=\\{1,2,3,4\\}$。从里程碑2和3出发的转移对称性意味着 $q(2)=q(3)$。求解 $q^{(3)}$ 的系统得出 $(0, 0.3, 0.6, 0.6, 0.8, 1)^{T}$。请求的值为 $q^{(3)}(2)=0.6$。粗粒度坐标是非均匀的：$s^{(3)}=(0, 1, 2, 2.5, 3.5, 4)$。在与内部里程碑1,2,3,4相对应的排序位置上计算二阶导数。其值为 $0.0$，$-0.4$，$4/15 \\approx 0.267$ 和 $4/15 \\approx 0.267$。最大绝对值为 $S^{(3)}=0.4$。\n\n对所有三个案例实施这些计算以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_committor_and_smoothness(C, A, B, s, target_idx):\n    \"\"\"\n    Calculates the committor probability and smoothness deviation.\n    \n    Args:\n        C (list of lists): The crossing count matrix.\n        A (set): The set of reactant milestone indices.\n        B (set): The set of product milestone indices.\n        s (list): The coarse coordinate values for each milestone.\n        target_idx (int): The index of the milestone for which to report the committor.\n\n    Returns:\n        tuple: A tuple containing (q_target, S), where q_target is the\n               committor at the target index and S is the smoothness deviation metric.\n    \"\"\"\n    C_matrix = np.array(C, dtype=float)\n    s_coord = np.array(s, dtype=float)\n    N = C_matrix.shape[0]\n\n    # Step 1: Construct the transition probability matrix P\n    row_sums = C_matrix.sum(axis=1)\n    # Ensure no division by zero for rows with all zero counts.\n    # Rows with a sum of 0 are left as is (all zeros), although the problem\n    # data ensures all relevant row sums are positive.\n    non_zero_sums = row_sums != 0\n    P = np.zeros_like(C_matrix)\n    P[non_zero_sums] = C_matrix[non_zero_sums] / row_sums[non_zero_sums, np.newaxis]\n\n    # Step 2: Set up and solve the linear system for the committor q\n    all_indices = set(range(N))\n    interior_indices = sorted(list(all_indices - A - B))\n    n_interior = len(interior_indices)\n\n    # System is M * q_I = b, where M = I_II - P_II and b = P_IB * 1\n    # P_II: transitions between interior states\n    P_II = P[np.ix_(interior_indices, interior_indices)]\n    # M = I - P_II\n    M = np.identity(n_interior) - P_II\n\n    # b: sum of transition probabilities from interior states to product states\n    b = P[np.ix_(interior_indices, list(B))].sum(axis=1)\n\n    # Solve for q_I, the committor values at interior milestones\n    q_I = np.linalg.solve(M, b)\n\n    # Construct the full committor vector q\n    q = np.zeros(N, dtype=float)\n    q[list(A)] = 0.0\n    q[list(B)] = 1.0\n    q[interior_indices] = q_I\n\n    # Step 3: Quantify deviations from smoothness using the metric S\n    sorted_order = np.argsort(s_coord)\n    s_sorted = s_coord[sorted_order]\n    q_sorted = q[sorted_order]\n    \n    # Map original milestone index to its position in the sorted list\n    original_to_sorted_map = {val: i for i, val in enumerate(sorted_order)}\n\n    second_derivatives = []\n    # Calculate second derivative for each interior milestone with neighbors\n    for k in interior_indices:\n        j = original_to_sorted_map.get(k)\n        # Check if milestone k is not at the ends of the sorted list\n        if j is not None and 1 = j  N - 1:\n            q_prev, q_curr, q_next = q_sorted[j - 1], q_sorted[j], q_sorted[j + 1]\n            s_prev, s_curr, s_next = s_sorted[j - 1], s_sorted[j], s_sorted[j + 1]\n            \n            h1 = s_curr - s_prev\n            h2 = s_next - s_curr\n            \n            # The problem data guarantees h1 > 0 and h2 > 0.\n            if h1 > 1e-9 and h2 > 1e-9: # Use a tolerance for float comparison\n                term1 = (q_next - q_curr) / h2\n                term2 = (q_curr - q_prev) / h1\n                q_double_prime = (2.0 / (h1 + h2)) * (term1 - term2)\n                second_derivatives.append(q_double_prime)\n\n    S = 0.0\n    if second_derivatives:\n        S = np.max(np.abs(second_derivatives))\n\n    # Step 4: Report the target committor value and S\n    q_target = q[target_idx]\n    \n    return q_target, S\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [50, 0, 50, 0, 0],\n                [0, 50, 0, 50, 0],\n                [0, 0, 50, 0, 50],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [70, 0, 30, 0, 0],\n                [0, 90, 0, 10, 0],\n                [0, 0, 30, 0, 70],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 200, 0, 0, 0, 0],\n                [100, 0, 50, 50, 0, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 0, 50, 50, 0, 100],\n                [0, 0, 0, 0, 200, 0]\n            ],\n            \"A\": {0},\n            \"B\": {5},\n            \"s\": [0, 1, 2, 2.5, 3.5, 4],\n            \"target_idx\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        q_target, S = calculate_committor_and_smoothness(\n            case[\"C\"], case[\"A\"], case[\"B\"], case[\"s\"], case[\"target_idx\"]\n        )\n        results.append(q_target)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}