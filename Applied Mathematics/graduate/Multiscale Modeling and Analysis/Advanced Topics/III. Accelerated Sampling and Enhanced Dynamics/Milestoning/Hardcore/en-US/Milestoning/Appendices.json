{
    "hands_on_practices": [
        {
            "introduction": "This first practice focuses on the fundamental mathematics of milestoning. Once a complex system is coarse-grained into a set of milestones and the necessary transition statistics are gathered, this exercise demonstrates how to assemble these data into a matrix equation to calculate a key kinetic observable: the Mean First Passage Time (MFPT). By working through this problem , you will gain hands-on experience with the core algebraic framework that transforms milestoning into a powerful computational tool for kinetics.",
            "id": "5259162",
            "problem": "A biomolecular conformational change is partitioned into milestone surfaces that give rise to a Markov renewal process (MRP) over milestones. Let set $A$ denote the nonabsorbing milestones $\\{M_1, M_2, M_3\\}$ and set $B$ denote the absorbing product state. Short molecular dynamics segments between milestones have been used to estimate one-step transition probabilities among milestones in $A$ and the mean local waiting times on each milestone before the next crossing. The submatrix of conditional transition probabilities among $A$ (i.e., excluding direct jumps to $B$) is\n$$\nQ \\;=\\; \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix},\n$$\nand the corresponding mean local waiting time vector is\n$$\n\\mathbf{t} \\;=\\; \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix} \\,\\text{ns}.\n$$\nThe leftover probability in each row, $1 - \\sum_{j} Q_{ij}$, represents the probability to jump from milestone $i \\in A$ directly into $B$. Assume the renewal property holds between milestone crossings and that the spectral radius of $Q$ is less than $1$, ensuring that the mean first passage times are finite.\n\nStarting from first principles appropriate to milestoning and MRPs, use the law of total expectation to obtain the linear equations that determine the mean first passage times from each $i \\in A$ to $B$, and solve these equations to compute the mean first passage time from set $A$ to set $B$ when the process is launched at milestone $M_1$. Round your final numerical result to $4$ significant figures and express your answer in nanoseconds ($\\text{ns}$).",
            "solution": "The problem is first validated against the specified criteria.\n\n### Problem Validation\n**Step 1: Extract Givens**\n- Set of nonabsorbing milestones: $A = \\{M_1, M_2, M_3\\}$.\n- Absorbing product state: $B$.\n- Submatrix of conditional transition probabilities among milestones in $A$:\n$$\nQ = \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix}\n$$\n- Mean local waiting time vector (in nanoseconds, $\\text{ns}$):\n$$\n\\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n- Probability to transition from milestone $i \\in A$ to $B$: $1 - \\sum_{j} Q_{ij}$.\n- The underlying stochastic process is a Markov renewal process (MRP).\n- The spectral radius of $Q$ is less than $1$, denoted $\\rho(Q)  1$.\n- The task is to compute the mean first passage time (MFPT) from milestone $M_1$ to state $B$.\n- The final result is to be rounded to $4$ significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is a standard application of milestoning theory, a well-established method in computational biophysics for calculating kinetic rates from molecular dynamics simulations. The formulation using a Markov renewal process, transition probabilities, and mean local waiting times is correct and central to the theory.\n- **Well-Posed:** The problem is well-posed. It requests the calculation of the Mean First Passage Time (MFPT) to an absorbing state from a set of transient states. The provided data, the submatrix of transient-to-transient probabilities $Q$ and the vector of mean local waiting times $\\mathbf{t}$, are precisely the quantities required. The crucial condition $\\rho(Q)  1$ guarantees that the matrix $(I-Q)$ is invertible, which ensures that the MFPTs are finite and a unique solution exists.\n- **Objective:** The problem is stated using precise, unambiguous mathematical language and is devoid of any subjective or opinion-based content.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically grounded, well-posed, objective, and internally consistent. It is deemed **valid**. We may proceed with the solution.\n\n### Solution\nThe objective is to compute the mean first passage time (MFPT) from milestone $M_1$ to the absorbing state $B$. Let $\\tau_i$ denote the MFPT from a nonabsorbing milestone $M_i \\in A$ to the state $B$. We are looking for the value of $\\tau_1$.\n\nThe fundamental principle for this calculation is the law of total expectation, applied to the Markov renewal process that describes the transitions between milestones. For any starting milestone $M_i$, the total time to absorption in $B$ can be decomposed into two parts:\n$1$. The mean local waiting time, $t_i$, spent in the vicinity of milestone $M_i$ before the next transition occurs.\n$2$. The expected time to reach $B$ from the subsequent state, averaged over all possible next states.\n\nAfter the waiting time $t_i$, the system transitions from milestone $M_i$ to another state. There are two possibilities for the next state:\n- The system transitions to another nonabsorbing milestone $M_j \\in A$. This occurs with a conditional probability $Q_{ij}$. Once at $M_j$, the remaining expected time to reach $B$ is, by definition, $\\tau_j$.\n- The system transitions directly to the absorbing state $B$. This occurs with probability $P_{iB} = 1 - \\sum_{j \\in A} Q_{ij}$. Once in state $B$, the process has terminated, and the remaining time to reach $B$ is $0$.\n\nBy applying the law of total expectation, we can write an equation for $\\tau_i$ by conditioning on the first transition:\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\cdot \\tau_j + \\left(1 - \\sum_{j \\in A} Q_{ij}\\right) \\cdot 0\n$$\nThis simplifies to a system of linear equations:\n$$\n\\tau_i = t_i + \\sum_{j \\in A} Q_{ij} \\tau_j \\quad \\text{ for } i \\in \\{1, 2, 3\\}\n$$\n\nLet $\\boldsymbol{\\tau}$ be the column vector of the unknown MFPTs, $\\boldsymbol{\\tau} = [\\tau_1, \\tau_2, \\tau_3]^T$. The system of equations can be written in matrix form as:\n$$\n\\boldsymbol{\\tau} = \\mathbf{t} + Q \\boldsymbol{\\tau}\n$$\nwhere $\\mathbf{t}$ is the vector of mean local waiting times and $Q$ is the matrix of conditional transition probabilities among nonabsorbing milestones.\n\nTo solve for $\\boldsymbol{\\tau}$, we rearrange the equation:\n$$\n\\boldsymbol{\\tau} - Q \\boldsymbol{\\tau} = \\mathbf{t}\n$$\n$$\n(I - Q) \\boldsymbol{\\tau} = \\mathbf{t}\n$$\nwhere $I$ is the $3 \\times 3$ identity matrix. The solution is then obtained by inverting the matrix $(I - Q)$:\n$$\n\\boldsymbol{\\tau} = (I - Q)^{-1} \\mathbf{t}\n$$\nThe condition that the spectral radius $\\rho(Q)  1$ ensures that the matrix $(I - Q)$ is invertible.\n\nWe are given:\n$$\nQ = \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix} \\quad \\text{and} \\quad \\mathbf{t} = \\begin{bmatrix} 4 \\\\ 6 \\\\ 5 \\end{bmatrix}\n$$\n\nFirst, we construct the matrix $(I-Q)$:\n$$\nI - Q = \\begin{bmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix} - \\begin{bmatrix}\n0  0.3  0.4 \\\\\n0.2  0  0.5 \\\\\n0.1  0.6  0\n\\end{bmatrix} = \\begin{bmatrix}\n1  -0.3  -0.4 \\\\\n-0.2  1  -0.5 \\\\\n-0.1  -0.6  1\n\\end{bmatrix}\n$$\n\nNext, we calculate the inverse of this matrix, $(I-Q)^{-1}$. The inverse is given by $\\frac{1}{\\det(I-Q)} \\text{adj}(I-Q)$.\nThe determinant of $(I-Q)$ is:\n$$\n\\det(I-Q) = 1(1 \\cdot 1 - (-0.5)(-0.6)) - (-0.3)((-0.2) \\cdot 1 - (-0.5)(-0.1)) + (-0.4)((-0.2)(-0.6) - 1(-0.1))\n$$\n$$\n\\det(I-Q) = 1(1 - 0.3) + 0.3(-0.2 - 0.05) - 0.4(0.12 + 0.1)\n$$\n$$\n\\det(I-Q) = 0.7 + 0.3(-0.25) - 0.4(0.22) = 0.7 - 0.075 - 0.088 = 0.537\n$$\n\nThe adjugate matrix, $\\text{adj}(I-Q)$, is the transpose of the cofactor matrix. The cofactors $C_{ij}$ are:\n$C_{11} = 1 - 0.3 = 0.7$\n$C_{12} = -(-0.2 - 0.05) = 0.25$\n$C_{13} = 0.12 + 0.1 = 0.22$\n$C_{21} = -(-0.3 - 0.24) = 0.54$\n$C_{22} = 1 - 0.04 = 0.96$\n$C_{23} = -(-0.6 - 0.03) = 0.63$\n$C_{31} = 0.15 + 0.4 = 0.55$\n$C_{32} = -(-0.5 - 0.08) = 0.58$\n$C_{33} = 1 - 0.06 = 0.94$\n\nThe cofactor matrix is $\\begin{bmatrix} 0.7  0.25  0.22 \\\\ 0.54  0.96  0.63 \\\\ 0.55  0.58  0.94 \\end{bmatrix}$. The adjugate matrix is its transpose:\n$$\n\\text{adj}(I-Q) = \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix}\n$$\n\nSo, the inverse matrix is:\n$$\n(I-Q)^{-1} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix}\n$$\n\nNow we can compute the vector of MFPTs, $\\boldsymbol{\\tau}$:\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n0.7  0.54  0.55 \\\\\n0.25  0.96  0.58 \\\\\n0.22  0.63  0.94\n\\end{bmatrix} \\begin{bmatrix}\n4 \\\\\n6 \\\\\n5\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n(0.7)(4) + (0.54)(6) + (0.55)(5) \\\\\n(0.25)(4) + (0.96)(6) + (0.58)(5) \\\\\n(0.22)(4) + (0.63)(6) + (0.94)(5)\n\\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\tau} = \\frac{1}{0.537} \\begin{bmatrix}\n2.8 + 3.24 + 2.75 \\\\\n1.0 + 5.76 + 2.9 \\\\\n0.88 + 3.78 + 4.7\n\\end{bmatrix}\n= \\frac{1}{0.537} \\begin{bmatrix}\n8.79 \\\\\n9.66 \\\\\n9.36\n\\end{bmatrix}\n$$\n\nThe MFPT from milestone $M_1$ is $\\tau_1$, the first element of the vector $\\boldsymbol{\\tau}$:\n$$\n\\tau_1 = \\frac{8.79}{0.537} \\approx 16.368715...\n$$\nThe problem requires the answer to be rounded to $4$ significant figures.\n$$\n\\tau_1 \\approx 16.37 \\, \\text{ns}\n$$\nThe other MFPTs are $\\tau_2 \\approx 17.99 \\, \\text{ns}$ and $\\tau_3 \\approx 17.43 \\, \\text{ns}$. The requested quantity is $\\tau_1$.",
            "answer": "$$\n\\boxed{16.37}\n$$"
        },
        {
            "introduction": "A crucial assumption in milestoning is that trajectories effectively \"forget\" their history upon reaching a new milestone, allowing for a Markovian description. This practice explores what happens when this assumption is weakened by immediate \"recrossings,\" a common issue arising from poorly placed milestones. By deriving the committor probability for a model system , you will learn to quantify these recrossing errors and, more importantly, use the committor itself to define theoretically optimal milestone surfaces that minimize such memory effects.",
            "id": "5259164",
            "problem": "Consider the milestoning framework for multiscale kinetics in biomolecular simulation, where configuration space is partitioned by a sequence of interfaces $\\Sigma_i$ (called milestones) and trajectories evolve according to overdamped dynamics. Within the interval between two adjacent interfaces $\\Sigma_i$ and $\\Sigma_{i+1}$, assume one-dimensional overdamped Langevin (Smoluchowski) dynamics with constant drift and diffusion, modeled by the stochastic differential equation $dX_t = \\mu\\,dt + \\sigma\\,dW_t$, where $X_t$ is position in nanometers, $t$ is time in nanoseconds, $\\mu$ is a constant drift in nanometers per nanosecond, $\\sigma$ is a constant noise amplitude in nanometers per square root nanosecond, and $W_t$ is standard Brownian motion. In thermal equilibrium under a locally linear potential, the drift and diffusion satisfy the Einstein relation $\\mu / D = -\\beta\\,G$, with diffusion coefficient $D$ in $\\mathrm{nm}^2/\\mathrm{ns}$, inverse thermal energy $\\beta = 1/(k_B T)$ in $\\mathrm{mol}/\\mathrm{kJ}$, Boltzmann constant $k_B$ in $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{K})$, absolute temperature $T$ in $\\mathrm{K}$, and constant potential gradient $G$ in $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{nm})$. The noise amplitude and diffusion are related by $\\sigma^2 = 2D$.\n\nDefine the forward committor $q(x)$ as the probability that, starting at position $x \\in (a,b)$ with $a$ identified with $\\Sigma_i$ and $b$ identified with $\\Sigma_{i+1}$, the trajectory reaches $b$ before returning to $a$. For trajectories that have just crossed $\\Sigma_i$ into the interval $(a,b)$, define the recrossing fraction $r$ as the probability of returning to $\\Sigma_i$ before first reaching $\\Sigma_{i+1}$, when starting from $x_0 = a + \\delta$ with a small displacement $\\delta$ in nanometers. Thus, $r = 1 - q(x_0)$.\n\nTasks:\n- From first principles, starting with the backward equation for the hitting probability under $dX_t = \\mu\\,dt + \\sigma\\,dW_t$ with absorbing boundaries at $x=a$ and $x=b$, derive the functional form of $q(x)$ and hence the expression for the recrossing fraction $r$ at $x_0 = a + \\delta$.\n- Propose a corrective redefinition of the interface $\\Sigma_i$ inside $(a,b)$ that reduces memory effects, based on reparameterizing interfaces as isocommittor surfaces. Specifically, define the new interface location $x^\\star$ inside $(a,b)$ by the criterion $q(x^\\star) = c$, with $c = 0.5$ (an isocommittor at one-half). Derive $x^\\star$ in terms of $(a,b,\\mu,\\sigma)$ and handle the limit of zero drift $\\mu \\to 0$ consistently.\n\nYour program must implement the derived expressions and compute, for each provided test case:\n- The recrossing fraction $r$ corresponding to a trajectory initialized at $x_0 = a + \\delta$.\n- The proposed new interface position $x^\\star$ that satisfies $q(x^\\star) = 0.5$.\n\nPhysical units and output specification:\n- Positions $a$, $b$, $\\delta$, and $x^\\star$ must be treated in nanometers and reported in nanometers.\n- Diffusion coefficient $D$ must be treated in $\\mathrm{nm}^2/\\mathrm{ns}$.\n- Absolute temperature $T$ must be treated in $\\mathrm{K}$.\n- Potential gradient $G$ must be treated in $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{nm})$.\n- The recrossing fraction $r$ is dimensionless.\n- Use $k_B = 0.008314462618$ in $\\mathrm{kJ}/(\\mathrm{mol}\\cdot\\mathrm{K})$.\n- Report $x^\\star$ and $r$ each rounded to six decimal places.\n\nTest suite:\nProvide computations for the following parameter sets, each specified as $(a,b,D,T,G,\\delta)$:\n1. $(0.0, 1.0, 0.1, 300.0, -0.5, 0.01)$: Happy path with moderate drift to the right (reduced recrossing expected).\n2. $(0.0, 1.0, 0.1, 300.0, 0.0, 0.01)$: Boundary case with pure diffusion (no drift).\n3. $(0.0, 1.0, 0.1, 300.0, 2.0, 0.01)$: Opposing drift to the left (high recrossing expected).\n4. $(0.3, 0.5, 0.1, 300.0, -0.5, 0.002)$: Narrow interval with moderate drift to the right.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a pair $[r, x^\\star]$ so the overall output must be of the form $[[r_1,x^\\star_1],[r_2,x^\\star_2],\\ldots]$ with no spaces, and each numerical entry rounded to six decimal places.",
            "solution": "The problem requires the derivation and calculation of two quantities within the milestoning framework for a one-dimensional system governed by overdamped Langevin dynamics: the recrossing fraction $r$ from an interface and the position $x^\\star$ of a corrected interface defined by an isocommittor surface.\n\nThe system's dynamics are described by the stochastic differential equation (SDE):\n$$dX_t = \\mu\\,dt + \\sigma\\,dW_t$$\nwhere $X_t$ is the position, $\\mu$ is a constant drift, and $\\sigma$ is the noise amplitude related to the diffusion coefficient $D$ by $\\sigma^2 = 2D$. The drift $\\mu$ is related to a constant external potential gradient $G$ via the Einstein relation $\\mu/D = -\\beta G$, where $\\beta = 1/(k_B T)$ is the inverse thermal energy.\n\nCombining these relations, we can express the term $\\frac{2\\mu}{\\sigma^2}$ which will appear in our derivations:\n$$\\frac{2\\mu}{\\sigma^2} = \\frac{2\\mu}{2D} = \\frac{\\mu}{D} = -\\beta G = -\\frac{G}{k_B T}$$\nThis quantity encapsulates the ratio of drift to diffusion and will be central to the solution.\n\n**Part 1: Derivation of the Forward Committor $q(x)$**\n\nThe forward committor, $q(x)$, is the probability that a trajectory starting at position $x$ in the interval $(a, b)$ reaches the boundary at $x=b$ before reaching the boundary at $x=a$. It is the solution to the backward Kolmogorov equation for the hitting probability, which is a second-order ordinary differential equation (ODE). The backward generator $\\mathcal{L}$ for the given SDE is:\n$$\\mathcal{L} = \\mu \\frac{d}{dx} + \\frac{\\sigma^2}{2} \\frac{d^2}{dx^2}$$\nThe committor $q(x)$ satisfies $\\mathcal{L}q(x) = 0$ on the domain $(a, b)$, subject to the boundary conditions reflecting the absorbing nature of the boundaries:\n$$q(a) = 0$$\n$$q(b) = 1$$\nThe ODE to solve is:\n$$\\frac{\\sigma^2}{2} \\frac{d^2q}{dx^2} + \\mu \\frac{dq}{dx} = 0$$\nThis is a second-order linear homogeneous ODE with constant coefficients. We can find its general solution by first letting $z(x) = \\frac{dq}{dx}$, which transforms the equation to a first-order ODE for $z(x)$:\n$$\\frac{\\sigma^2}{2} \\frac{dz}{dx} + \\mu z = 0 \\implies \\frac{dz}{z} = -\\frac{2\\mu}{\\sigma^2} dx$$\nIntegrating gives $\\ln(z) = -\\frac{2\\mu}{\\sigma^2} x + C_1$, or $z(x) = C_2 e^{-2\\mu x / \\sigma^2}$.\nIntegrating $z(x)$ to find $q(x)$ yields:\n$$q(x) = \\int C_2 e^{-2\\mu x / \\sigma^2} dx = C_2 \\left( -\\frac{\\sigma^2}{2\\mu} \\right) e^{-2\\mu x / \\sigma^2} + C_3$$\nFor convenience, let's write the general solution as:\n$$q(x) = A e^{-2\\mu x / \\sigma^2} + B$$\nApplying the boundary conditions:\n1. $q(a) = A e^{-2\\mu a / \\sigma^2} + B = 0 \\implies B = -A e^{-2\\mu a / \\sigma^2}$\n2. $q(b) = A e^{-2\\mu b / \\sigma^2} + B = 1$\n\nSubstituting $B$ into the second equation:\n$$A e^{-2\\mu b / \\sigma^2} - A e^{-2\\mu a / \\sigma^2} = 1 \\implies A \\left( e^{-2\\mu b / \\sigma^2} - e^{-2\\mu a / \\sigma^2} \\right) = 1$$\n$$A = \\frac{1}{e^{-2\\mu b / \\sigma^2} - e^{-2\\mu a / \\sigma^2}}$$\nSubstituting $A$ and $B$ back into the expression for $q(x)$:\n$$q(x) = \\frac{e^{-2\\mu x / \\sigma^2} - e^{-2\\mu a / \\sigma^2}}{e^{-2\\mu b / \\sigma^2} - e^{-2\\mu a / \\sigma^2}}$$\nThis is the functional form of the committor for $\\mu \\neq 0$.\n\nFor the case of zero drift, $\\mu = 0$, the ODE simplifies to $\\frac{\\sigma^2}{2} \\frac{d^2q}{dx^2} = 0$, which implies $q''(x)=0$. The general solution is $q(x) = C_1 x + C_2$. Applying the boundary conditions:\n1. $q(a) = C_1 a + C_2 = 0 \\implies C_2 = -C_1 a$\n2. $q(b) = C_1 b + C_2 = 1 \\implies C_1(b-a) = 1 \\implies C_1 = \\frac{1}{b-a}$\nThus, for $\\mu=0$:\n$$q(x) = \\frac{x-a}{b-a}$$\nThis result can also be obtained by taking the limit $\\mu \\to 0$ of the general expression for $q(x)$ using L'Hôpital's rule.\n\nFor numerical stability and clarity, let's define $\\lambda = -2\\mu/\\sigma^2 = \\beta G = G/(k_B T)$. The expression for $q(x)$ becomes:\n$$q(x) = \\frac{e^{\\lambda x} - e^{\\lambda a}}{e^{\\lambda b} - e^{\\lambda a}} = \\frac{e^{\\lambda a}(e^{\\lambda(x-a)} - 1)}{e^{\\lambda a}(e^{\\lambda(b-a)} - 1)} = \\frac{e^{\\lambda(x-a)} - 1}{e^{\\lambda(b-a)} - 1}$$\nThis form is suitable for computation, particularly using the `expm1` function for $e^z - 1$.\n\n**Part 2: Calculation of the Recrossing Fraction $r$**\n\nThe recrossing fraction $r$ is defined as the probability of returning to $\\Sigma_i \\equiv a$ before reaching $\\Sigma_{i+1} \\equiv b$, when starting from an infinitesimally displaced position $x_0 = a + \\delta$. By definition, this is the complement of the forward committor at $x_0$:\n$$r = 1 - q(x_0) = 1 - q(a+\\delta)$$\nSubstituting $x = a+\\delta$ into our derived expression for $q(x)$:\nFor $\\mu \\neq 0$ (or $\\lambda \\neq 0$):\n$$r = 1 - \\frac{e^{\\lambda(a+\\delta)} - e^{\\lambda a}}{e^{\\lambda b} - e^{\\lambda a}} = 1 - \\frac{e^{\\lambda \\delta} - 1}{e^{\\lambda (b-a)} - 1}$$\nFor $\\mu = 0$ (or $\\lambda = 0$):\n$$r = 1 - \\frac{(a+\\delta) - a}{b-a} = 1 - \\frac{\\delta}{b-a}$$\n\n**Part 3: Derivation of the Isocommittor Interface Position $x^\\star$**\n\nThe new interface position $x^\\star$ is defined by the isocommittor condition $q(x^\\star) = c$, with $c=0.5$.\nFor $\\mu \\neq 0$ (or $\\lambda \\neq 0$):\n$$\\frac{e^{\\lambda x^\\star} - e^{\\lambda a}}{e^{\\lambda b} - e^{\\lambda a}} = 0.5$$\nSolving for $e^{\\lambda x^\\star}$:\n$$e^{\\lambda x^\\star} - e^{\\lambda a} = 0.5 (e^{\\lambda b} - e^{\\lambda a})$$\n$$e^{\\lambda x^\\star} = e^{\\lambda a} + 0.5 e^{\\lambda b} - 0.5 e^{\\lambda a} = 0.5 (e^{\\lambda a} + e^{\\lambda b})$$\nTaking the natural logarithm and solving for $x^\\star$:\n$$\\lambda x^\\star = \\ln\\left(0.5 (e^{\\lambda a} + e^{\\lambda b})\\right)$$\n$$x^\\star = \\frac{1}{\\lambda} \\ln\\left(0.5 (e^{\\lambda a} + e^{\\lambda b})\\right)$$\nFor $\\mu = 0$ (or $\\lambda = 0$):\n$$\\frac{x^\\star - a}{b-a} = 0.5$$\n$$x^\\star = a + 0.5(b-a) = 0.5(a+b)$$\nAs expected, for pure diffusion, the half-committor surface is located at the geometric midpoint of the interval.\n\nThese derived formulae are implemented in the provided program to compute the required values for the given test cases. The parameter $\\lambda = G/(k_B T)$ is first calculated from the inputs, and its value determines whether the general ($\\lambda \\neq 0$) or the special-case ($\\lambda = 0$) formulae are used.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import expm1\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the milestoning problem for the given test cases.\n\n    The solution involves:\n    1. Deriving the forward committor q(x) for 1D overdamped Langevin dynamics.\n    2. Using q(x) to find the recrossing fraction r = 1 - q(a + delta).\n    3. Finding the isocommittor surface position x* where q(x*) = 0.5.\n    \"\"\"\n    \n    # Define the Boltzmann constant in kJ/(mol·K)\n    K_B = 0.008314462618\n\n    # Test cases: (a, b, D, T, G, delta)\n    # a, b: interval boundaries in nm\n    # D: diffusion coefficient in nm^2/ns\n    # T: absolute temperature in K\n    # G: potential gradient in kJ/(mol·nm)\n    # delta: initial displacement in nm\n    test_cases = [\n        (0.0, 1.0, 0.1, 300.0, -0.5, 0.01),\n        (0.0, 1.0, 0.1, 300.0, 0.0, 0.01),\n        (0.0, 1.0, 0.1, 300.0, 2.0, 0.01),\n        (0.3, 0.5, 0.1, 300.0, -0.5, 0.002),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, D, T, G, delta = case\n        \n        # Calculate the composite parameter lambda = G / (k_B * T)\n        # This parameter combines drift and diffusion characteristics.\n        # lambda = -2*mu/sigma^2 = G / (k_B*T)\n        k_b_T = K_B * T\n        \n        # A small tolerance to handle the zero-drift case robustly\n        TOLERANCE = 1e-9\n\n        if abs(G)  TOLERANCE: # Handle the zero drift (mu = 0) case\n            # For pure diffusion, the committor is linear: q(x) = (x-a)/(b-a)\n            # Recrossing fraction r = 1 - q(a + delta)\n            if b - a > 0:\n                r = 1.0 - delta / (b - a)\n            else:\n                # Should not happen with valid inputs, but handle defensively\n                r = 1.0\n            \n            # Isocommittor surface q(x*) = 0.5 is at the midpoint\n            x_star = a + 0.5 * (b - a)\n        else: # Handle the non-zero drift (mu != 0) case\n            lam = G / k_b_T\n            \n            # Calculate recrossing fraction r = 1 - q(a + delta)\n            # q(x) = (exp(lam*(x-a)) - 1) / (exp(lam*(b-a)) - 1)\n            # We use scipy.special.expm1 for numerical stability when the argument is small.\n            # q(a + delta) = expm1(lam * delta) / expm1(lam * (b - a))\n            numerator_r = expm1(lam * delta)\n            denominator_r = expm1(lam * (b - a))\n            \n            if abs(denominator_r) > TOLERANCE:\n                q_at_x0 = numerator_r / denominator_r\n                r = 1.0 - q_at_x0\n            else:\n                # This case might indicate an issue, but for small arguments expm1(z) ~ z\n                q_at_x0 = (lam * delta) / (lam * (b-a))\n                r = 1.0 - q_at_x0\n\n            # Calculate isocommittor surface position x* where q(x*) = 0.5\n            # Derived formula: x* = (1/lam) * ln(0.5 * (exp(lam*a) + exp(lam*b)))\n            # We use np.log and np.exp which are generally robust.\n            x_star = (1.0 / lam) * np.log(0.5 * (np.exp(lam * a) + np.exp(lam * b)))\n            \n        # Round the results to six decimal places as required\n        r_rounded = round(r, 6)\n        x_star_rounded = round(x_star, 6)\n        \n        results.append([r_rounded, x_star_rounded])\n\n    # Format the final output string\n    # E.g., [[0.988978,0.475],[0.99,0.5],...]\n    output_str = \"[\" + \",\".join([f\"[{r},{x}]\" for r, x in results]) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "This final exercise simulates a real-world data analysis workflow, bridging the gap between raw simulation output and kinetic insights. Starting from a matrix of observed transition counts between discrete milestones, you will construct a Markov model and solve for the committor probabilities . You will then analyze the \"smoothness\" of the resulting committor profile, learning how to use this powerful diagnostic to assess the quality of your coarse-grained model and identify features like kinetic bottlenecks or complex, branching pathways.",
            "id": "5259212",
            "problem": "You are given measured crossing statistics between a finite set of milestones in a biomolecular simulation and asked to estimate the forward committor probability, interpret its smoothness, and report diagnostic values. Consider a discrete-time Markov chain on a finite set of milestones indexed by integers $i \\in \\{0,1,\\dots,N-1\\}$ with row-stochastic transition matrix $P$ inferred from crossing counts. The forward committor $q(i)$ is defined as the probability that a trajectory starting at milestone $i$ hits a designated product set $B$ before hitting a designated reactant set $A$, where $A$ and $B$ form an absorbing boundary for the committor. In discrete milestoning, the committor is determined by the backward equation and boundary conditions: $q(i) = \\sum_{j} P_{ij} \\, q(j)$ for $i \\notin A \\cup B$, $q(i) = 0$ for $i \\in A$, and $q(i) = 1$ for $i \\in B$. For interpretation, a smoothly varying committor along a coarse reaction coordinate $s(i)$ is expected when milestones are sufficiently fine and homogeneous; deviations from smoothness may indicate kinetic heterogeneity within milestones, insufficient resolution, or non-Markovian effects at the chosen coarse level.\n\nFundamental base to use:\n- Discrete-time Markov chain with row-stochastic transition matrix $P$ ($\\sum_{j} P_{ij} = 1$ for each row $i$).\n- Definition of the forward committor $q(i)$ as the hitting probability of $B$ before $A$.\n- Law of total probability and the Markov property to derive the backward equation.\n\nYour task is to write a complete program that:\n1. Constructs the transition probability matrix $P$ by normalizing measured crossing counts $C_{ij}$ row-wise, i.e., $P_{ij} = C_{ij} / \\sum_{k} C_{ik}$.\n2. Solves the committor $q$ on the milestone set by enforcing $q(i) = 0$ for all $i \\in A$ and $q(i) = 1$ for all $i \\in B$, and solving the corresponding linear equations for all interior $i \\notin A \\cup B$ implied by $q = P q$.\n3. Quantifies deviations from smoothness of $q$ along a provided scalar coarse coordinate $s(i)$ using the maximum absolute value of the discrete second derivative on a nonuniform grid. Let $i$ enumerate milestones in increasing order of $s(i)$, and define $h_{1} = s(i) - s(i-1)$ and $h_{2} = s(i+1) - s(i)$ for an interior index $i$ with neighbors in this sorted order. The nonuniform three-point approximation to the second derivative at $i$ is\n$$\nq''(s(i)) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q(i+1) - q(i)}{h_{2}} - \\frac{q(i) - q(i-1)}{h_{1}} \\right).\n$$\nDefine the smoothness deviation metric $S$ as the maximum absolute value of this approximation over all interior indices in the sorted-by-$s$ order that have both neighbors, excluding the endpoints. Report $S$ as a dimensionless float.\n4. Produces a single line of output containing six floats: the committor at a specified target interior milestone index and the smoothness deviation $S$ for each of three test cases described below, concatenated as a single comma-separated list enclosed in square brackets.\n\nTest suite:\n- Case 1 (baseline one-dimensional chain):\n  - Milestones are indexed $i \\in \\{0,1,2,3,4\\}$.\n  - Reactant set $A = \\{0\\}$ and product set $B = \\{4\\}$.\n  - Crossing counts matrix $C^{(1)}$:\n    $$\n    C^{(1)} =\n    \\begin{bmatrix}\n    0  100  0  0  0 \\\\\n    50  0  50  0  0 \\\\\n    0  50  0  50  0 \\\\\n    0  0  50  0  50 \\\\\n    0  0  0  100  0\n    \\end{bmatrix}.\n    $$\n  - Coarse coordinate $s^{(1)} = [0, 1, 2, 3, 4]$.\n  - Report $q^{(1)}(2)$ and $S^{(1)}$.\n\n- Case 2 (bottleneck causing curvature):\n  - Milestones are indexed $i \\in \\{0,1,2,3,4\\}$.\n  - Reactant set $A = \\{0\\}$ and product set $B = \\{4\\}$.\n  - Crossing counts matrix $C^{(2)}$:\n    $$\n    C^{(2)} =\n    \\begin{bmatrix}\n    0  100  0  0  0 \\\\\n    70  0  30  0  0 \\\\\n    0  90  0  10  0 \\\\\n    0  0  30  0  70 \\\\\n    0  0  0  100  0\n    \\end{bmatrix}.\n    $$\n  - Coarse coordinate $s^{(2)} = [0, 1, 2, 3, 4]$.\n  - Report $q^{(2)}(2)$ and $S^{(2)}$.\n\n- Case 3 (branched connectivity on a coarse coordinate):\n  - Milestones are indexed $i \\in \\{0,1,2,3,4,5\\}$.\n  - Reactant set $A = \\{0\\}$ and product set $B = \\{5\\}$.\n  - Crossing counts matrix $C^{(3)}$:\n    $$\n    C^{(3)} =\n    \\begin{bmatrix}\n    0  200  0  0  0  0 \\\\\n    100  0  50  50  0  0 \\\\\n    0  40  0  0  60  0 \\\\\n    0  40  0  0  60  0 \\\\\n    0  0  50  50  0  100 \\\\\n    0  0  0  0  200  0\n    \\end{bmatrix}.\n    $$\n  - Coarse coordinate $s^{(3)} = [0, 1, 2, 2.5, 3.5, 4]$.\n  - Report $q^{(3)}(2)$ and $S^{(3)}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the exact order\n$$\n[q^{(1)}(2), S^{(1)}, q^{(2)}(2), S^{(2)}, q^{(3)}(2), S^{(3)}].\n$$\nAll six outputs must be floats. No physical units are involved; probabilities and the smoothness deviation are dimensionless. Angles are not used. Express floats in standard decimal notation. The program must be self-contained, require no input, and use the specified libraries; it must compute $P$ from the provided crossing counts, solve the committor, compute the smoothness deviation, and print the final line exactly as specified.",
            "solution": "The problem presents a well-defined task in the analysis of discrete-time Markov chain models derived from biomolecular simulations, specifically within the context of milestoning. It requires the computation of the forward committor probability and a metric for its smoothness. The problem is scientifically grounded, mathematically well-posed, and all necessary data and definitions are provided. We may therefore proceed with a solution.\n\nThe core of the problem is to determine the forward committor, $q(i)$, for a set of milestones, indexed $i \\in \\{0, 1, \\dots, N-1\\}$. The committor $q(i)$ is the probability that a trajectory initiated at milestone $i$ will first reach a milestone in the product set $B$ before reaching one in the reactant set $A$. The sets $A$ and $B$ are absorbing boundaries, with committor values fixed by definition:\n$$ q(i) = 0, \\quad \\forall i \\in A $$\n$$ q(i) = 1, \\quad \\forall i \\in B $$\n\nFor all other milestones, known as interior milestones ($i \\notin A \\cup B$), the committor must satisfy the backward Kolmogorov equation. For a discrete-time Markov chain with a row-stochastic transition matrix $P$, this equation is derived from the law of total probability by considering the first step of the process:\n$$ q(i) = \\sum_{j=0}^{N-1} P_{ij} q(j), \\quad \\forall i \\notin A \\cup B $$\nHere, $P_{ij}$ is the probability of transitioning from milestone $i$ to milestone $j$ in one step. The matrix $P$ is obtained by normalizing the given crossing count matrix $C$, where $C_{ij}$ is the number of observed transitions from $i$ to $j$. The normalization is performed row-wise:\n$$ P_{ij} = \\frac{C_{ij}}{\\sum_{k=0}^{N-1} C_{ik}} $$\nThis assumes the total count of transitions out of any milestone $i$ for which $P_{ij}$ is needed is non-zero, a condition satisfied by the provided data.\n\nTo solve for the unknown committor values at interior milestones, we can formulate a system of linear equations. Let the set of interior milestones be $I$. For any $i \\in I$, the backward equation can be rewritten by separating the sum over states in $A$, $B$, and $I$:\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in A} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} q(j) $$\nSubstituting the known boundary conditions $q(j)=0$ for $j \\in A$ and $q(j)=1$ for $j \\in B$:\n$$ q(i) = \\sum_{j \\in I} P_{ij} q(j) + \\sum_{j \\in B} P_{ij} (1) $$\nRearranging the terms yields a linear system for the vector of interior committor values, $q_I$:\n$$ q(i) - \\sum_{j \\in I} P_{ij} q(j) = \\sum_{j \\in B} P_{ij} $$\nThis can be expressed in matrix form as $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$, where $\\mathbf{P}_{II}$ is the submatrix of $P$ containing transitions between interior states, $\\mathbf{q}_I$ is the vector of committor values for states in $I$, and the right-hand side vector $\\mathbf{b}$ has elements $b_i = \\sum_{j \\in B} P_{ij}$. This system can be solved for $\\mathbf{q}_I$ using standard linear algebra methods.\n\nThe second part of the task is to compute the smoothness deviation, $S$. This metric quantifies the non-linearity of the committor function $q(i)$ when plotted against a coarse reaction coordinate $s(i)$. We first sort the milestones according to their $s(i)$ values. Then, for each interior milestone that has both a predecessor and a successor in this sorted list, we approximate the second derivative of $q$ with respect to $s$ using a three-point finite difference formula for a non-uniform grid. Let the sorted milestones be indexed by $j \\in \\{0, \\dots, N-1\\}$, such that $s_j  s_{j+1}$. For a point at index $j$ in the sorted list, corresponding to an original milestone index $k$, this is:\n$$ q''(s_k) \\approx \\frac{2}{h_{1} + h_{2}} \\left( \\frac{q_{j+1} - q_{j}}{h_{2}} - \\frac{q_{j} - q_{j-1}}{h_{1}} \\right) $$\nwhere $h_1 = s_j - s_{j-1}$, $h_2 = s_{j+1} - s_j$, and $q_j$ is the committor value at the milestone at sorted position $j$. The metric $S$ is the maximum absolute value of these second derivative approximations over all applicable interior milestones.\n\nThe computational procedure is as follows:\n1. For each test case, construct the transition matrix $P$ from the count matrix $C$.\n2. Identify the reactant ($A$), product ($B$), and interior ($I$) sets of milestones.\n3. Construct and solve the linear system $(\\mathbf{I} - \\mathbf{P}_{II}) \\mathbf{q}_I = \\mathbf{b}$ to find the committor values for all $i \\in I$.\n4. Assemble the full committor vector $q$, including the boundary values.\n5. Sort the milestones based on the coarse coordinate $s$.\n6. Calculate the second derivative approximation at each interior milestone location that has neighbors in the sorted list.\n7. Determine $S$ as the maximum of the absolute values of the calculated derivatives.\n8. Extract the required committor value $q(i_{target})$ and the smoothness metric $S$.\n\nFor Case 1 (baseline one-dimensional chain):\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$. The transition matrix $P^{(1)}$ is symmetric for interior transitions, $P_{i,i-1}=P_{i,i+1}=0.5$ for $i \\in I$. The system of equations for $q^{(1)}$ is:\n$q(1) = 0.5q(2)$\n$q(2) = 0.5q(1) + 0.5q(3)$\n$q(3) = 0.5q(2) + 0.5$\nSolving this system yields $q^{(1)}=(0, 0.25, 0.5, 0.75, 1)^{T}$. The requested committor value is $q^{(1)}(2)=0.5$. The coarse coordinate is $s^{(1)}=(0,1,2,3,4)$, which is linear. The committor $q^{(1)}(i)$ is a linear function of $s^{(1)}(i)$, leading to a second derivative of zero at all points. Thus, $S^{(1)}=0.0$.\n\nFor Case 2 (bottleneck):\n$A=\\{0\\}$, $B=\\{4\\}$, $I=\\{1,2,3\\}$. The asymmetric transition probabilities in $P^{(2)}$ introduce a bias. Solving the corresponding linear system yields $q^{(2)}=(0, 0.03, 0.1, 0.73, 1)^{T}$, so $q^{(2)}(2)=0.1$. The committor is highly non-linear. With $s^{(2)}=(0,1,2,3,4)$, the second derivatives are computed at $s=1, 2, 3$. The values are $0.04$, $0.56$, and $-0.36$. The maximum absolute value is $S^{(2)}=0.56$.\n\nFor Case 3 (branched connectivity):\n$A=\\{0\\}$, $B=\\{5\\}$, $I=\\{1,2,3,4\\}$. The symmetry in transitions from milestones $2$ and $3$ implies $q(2)=q(3)$. Solving the system for $q^{(3)}$ yields $(0, 0.3, 0.6, 0.6, 0.8, 1)^{T}$. The requested value is $q^{(3)}(2)=0.6$. The coarse coordinate is non-uniform: $s^{(3)}=(0, 1, 2, 2.5, 3.5, 4)$. The second derivatives are computed at sorted positions corresponding to interior milestones $1,2,3,4$. The values are $0.0$, $-0.4$, $4/15 \\approx 0.267$, and $4/15 \\approx 0.267$. The maximum absolute value is $S^{(3)}=0.4$.\n\nThese calculations are implemented for all three cases to generate the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_committor_and_smoothness(C, A, B, s, target_idx):\n    \"\"\"\n    Calculates the committor probability and smoothness deviation.\n    \n    Args:\n        C (list of lists): The crossing count matrix.\n        A (set): The set of reactant milestone indices.\n        B (set): The set of product milestone indices.\n        s (list): The coarse coordinate values for each milestone.\n        target_idx (int): The index of the milestone for which to report the committor.\n\n    Returns:\n        tuple: A tuple containing (q_target, S), where q_target is the\n               committor at the target index and S is the smoothness deviation metric.\n    \"\"\"\n    C_matrix = np.array(C, dtype=float)\n    s_coord = np.array(s, dtype=float)\n    N = C_matrix.shape[0]\n\n    # Step 1: Construct the transition probability matrix P\n    row_sums = C_matrix.sum(axis=1)\n    # Ensure no division by zero for rows with all zero counts.\n    # Rows with a sum of 0 are left as is (all zeros), although the problem\n    # data ensures all relevant row sums are positive.\n    non_zero_sums = row_sums != 0\n    P = np.zeros_like(C_matrix)\n    P[non_zero_sums] = C_matrix[non_zero_sums] / row_sums[non_zero_sums, np.newaxis]\n\n    # Step 2: Set up and solve the linear system for the committor q\n    all_indices = set(range(N))\n    interior_indices = sorted(list(all_indices - A - B))\n    n_interior = len(interior_indices)\n\n    # System is M * q_I = b, where M = I_II - P_II and b = P_IB * 1\n    # P_II: transitions between interior states\n    P_II = P[np.ix_(interior_indices, interior_indices)]\n    # M = I - P_II\n    M = np.identity(n_interior) - P_II\n\n    # b: sum of transition probabilities from interior states to product states\n    b = P[np.ix_(interior_indices, list(B))].sum(axis=1)\n\n    # Solve for q_I, the committor values at interior milestones\n    q_I = np.linalg.solve(M, b)\n\n    # Construct the full committor vector q\n    q = np.zeros(N, dtype=float)\n    q[list(A)] = 0.0\n    q[list(B)] = 1.0\n    q[interior_indices] = q_I\n\n    # Step 3: Quantify deviations from smoothness using the metric S\n    sorted_order = np.argsort(s_coord)\n    s_sorted = s_coord[sorted_order]\n    q_sorted = q[sorted_order]\n    \n    # Map original milestone index to its position in the sorted list\n    original_to_sorted_map = {val: i for i, val in enumerate(sorted_order)}\n\n    second_derivatives = []\n    # Calculate second derivative for each interior milestone with neighbors\n    for k in interior_indices:\n        j = original_to_sorted_map.get(k)\n        # Check if milestone k is not at the ends of the sorted list\n        if j is not None and 1 = j  N - 1:\n            q_prev, q_curr, q_next = q_sorted[j - 1], q_sorted[j], q_sorted[j + 1]\n            s_prev, s_curr, s_next = s_sorted[j - 1], s_sorted[j], s_sorted[j + 1]\n            \n            h1 = s_curr - s_prev\n            h2 = s_next - s_curr\n            \n            # The problem data guarantees h1 > 0 and h2 > 0.\n            if h1 > 1e-9 and h2 > 1e-9: # Use a tolerance for float comparison\n                term1 = (q_next - q_curr) / h2\n                term2 = (q_curr - q_prev) / h1\n                q_double_prime = (2.0 / (h1 + h2)) * (term1 - term2)\n                second_derivatives.append(q_double_prime)\n\n    S = 0.0\n    if second_derivatives:\n        S = np.max(np.abs(second_derivatives))\n\n    # Step 4: Report the target committor value and S\n    q_target = q[target_idx]\n    \n    return q_target, S\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [50, 0, 50, 0, 0],\n                [0, 50, 0, 50, 0],\n                [0, 0, 50, 0, 50],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 100, 0, 0, 0],\n                [70, 0, 30, 0, 0],\n                [0, 90, 0, 10, 0],\n                [0, 0, 30, 0, 70],\n                [0, 0, 0, 100, 0]\n            ],\n            \"A\": {0},\n            \"B\": {4},\n            \"s\": [0, 1, 2, 3, 4],\n            \"target_idx\": 2\n        },\n        {\n            \"C\": [\n                [0, 200, 0, 0, 0, 0],\n                [100, 0, 50, 50, 0, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 40, 0, 0, 60, 0],\n                [0, 0, 50, 50, 0, 100],\n                [0, 0, 0, 0, 200, 0]\n            ],\n            \"A\": {0},\n            \"B\": {5},\n            \"s\": [0, 1, 2, 2.5, 3.5, 4],\n            \"target_idx\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        q_target, S = calculate_committor_and_smoothness(\n            case[\"C\"], case[\"A\"], case[\"B\"], case[\"s\"], case[\"target_idx\"]\n        )\n        results.append(q_target)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}