{
    "hands_on_practices": [
        {
            "introduction": "这项基础练习旨在搭建近场动力学理论与经典材料科学之间的桥梁。通过分析一根简单的一维杆，您将推导出近场动力学微观模量与宏观杨氏模量之间的关系，这是任何模拟中都至关重要的校准步骤。此外，通过引入脆性键断裂准则，您将确定材料的拉伸强度，从而建立从微观失效规则到宏观断裂行为的直接联系 。",
            "id": "3793741",
            "problem": "考虑一个一维的基于键的近场动力学 (Peridynamics, PD) 模型，用于描述一根长度为 $L$、横截面积为 $A$ 的线弹性脆性杆，其定义域为 $x \\in [0,L]$。点通过具有近场范围 $\\delta > 0$ 的对偶键相互作用。对于一个具有恒定微模量的微弹性材料，位于 $x$ 的点与位于 $x' = x + \\xi$ 的点之间的对偶力函数由 $f(\\xi) = c\\,s\\,\\text{sign}(\\xi)$（当 $|\\xi| \\le \\delta$ 时）给出，否则 $f(\\xi) = 0$。其中 $c > 0$ 是恒定的微模量，$s$ 是键的拉伸，对于小应变，其定义为 $s = \\frac{u(x+\\xi) - u(x)}{\\xi}$，其中 $u(x)$ 是位移场。当一个键的拉伸超过临界拉伸 $s_c > 0$ 时，该键会发生不可逆断裂。假设准静态单轴拉伸，使得施加的宏观应变为均匀的 $\\varepsilon$，从而在材料保持完整时有 $u(x) = \\varepsilon x$。\n\n仅从上述基本定义、经典小应变线弹性理论以及跨越横截面（切口）的近场动力学面力概念出发，推导在完整状态下，通过一个切口传递的单轴宏观柯西应力 $\\sigma(\\varepsilon)$ 作为 $c$、$\\delta$ 和 $\\varepsilon$ 的函数。通过与杨氏模量为 $E$ 的经典完整杆强制等效，来标定 $c$（用 $E$ 和 $\\delta$ 表示）。然后，使用脆性键断裂规则，确定在单调加载下的完整应力-应变曲线 $\\sigma(\\varepsilon)$ 和表观抗拉强度 $\\sigma_{\\max}$，其定义为 $\\sigma(\\varepsilon)$ 在 $\\varepsilon \\ge 0$ 上的最大值。所有应力均以帕斯卡 (Pa) 表示。\n\n您的程序必须实现推导出的公式，为每个测试用例计算一组从 $0$ 到 $1.5\\,s_c$ 的应变值对应的应力-应变曲线，并仅输出指定测试套件的表观抗拉强度 $\\sigma_{\\max}$（单位为帕斯卡）。您不得使用任何未从给定定义和等效性推导出的快捷公式。最终输出应为单行，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\sigma_1,\\sigma_2,\\sigma_3]$），其中每个 $\\sigma_i$ 是一个以帕斯卡为单位的浮点数。\n\n测试套件（每个用例是一个元组 $(E,\\delta,s_c)$）：\n- 用例 1 (happy path): $(E = 200 \\times 10^9\\ \\text{Pa},\\ \\delta = 0.01\\ \\text{m},\\ s_c = 0.005)$。\n- 用例 2 (更大的近场范围): $(E = 200 \\times 10^9\\ \\text{Pa},\\ \\delta = 0.05\\ \\text{m},\\ s_c = 0.01)$。\n- 用例 3 (不同的材料刚度): $(E = 70 \\times 10^9\\ \\text{Pa},\\ \\delta = 0.005\\ \\text{m},\\ s_c = 0.015)$。\n- 用例 4 (非常小的临界拉伸): $(E = 200 \\times 10^9\\ \\text{Pa},\\ \\delta = 0.002\\ \\text{m},\\ s_c = 10^{-4})$。\n- 用例 5 (小的近场范围): $(E = 200 \\times 10^9\\ \\text{Pa},\\ \\delta = 0.001\\ \\text{m},\\ s_c = 0.008)$。\n\n您的程序应生成单行输出，其中包含五个测试用例的表观抗拉强度（以帕斯卡为单位），格式为用方括号括起来的逗号分隔列表。",
            "solution": "该问题定义明确，具有科学依据，且内容自洽。它要求使用基于键的近场动力学 (PD) 原理推导一维脆性弹性杆的抗拉强度，并随后根据经典弹性力学进行标定。我们将逐步进行推导。\n\n### 步骤 1：推导完整状态下的宏观应力\n\n单轴宏观柯西应力 $\\sigma$ 是通过单位横截面积传递的总力。在近场动力学连续体中，这是通过对所有穿过一个概念性平面的键的力进行求和来计算的。对于一维杆，穿过位于 $x_0$ 处平面的面力（应力）$\\sigma$ 由 $x > x_0$ 区域的材料作用于 $x < x_0$ 区域的材料的总力除以横截面积 $A$ 给出。这可以表示为对所有穿过该平面的相互作用键的积分。\n\n穿过该平面的力 $F$ 是连接点 $x < x_0$ 和点 $x' > x_0$ 的所有键的力之和。总力是通过对所有此类点对进行积分得到的。在具有均匀属性的连续体中，表达式为：\n$$\nF = \\int_{V_L} \\int_{V_R \\cap H_x} f(x'-x, u(x')-u(x)) \\, dV' \\, dV\n$$\n其中 $V_L$ 和 $V_R$ 是切口左右两侧的体积，而 $H_x$ 是点 $x$ 的近场范围。对于我们的一维情况，$dV = A\\,dx$。力相互作用核 $f$ 以单位体积平方的力给出。可以证明，通过面积 $A$ 的总力是 $A$ 乘以一个涉及力核的积分。从这些原理推导出的标准一维柯西应力公式为：\n$$\n\\sigma = \\int_{0}^{\\delta} \\xi f(\\xi) \\, d\\xi\n$$\n\n问题陈述，对于均匀的宏观应变 $\\varepsilon$，位移场为 $u(x) = \\varepsilon x$。对于长度为 $\\xi = x' - x$ 的键，相应的键拉伸 $s$ 为：\n$$\ns = \\frac{u(x+\\xi) - u(x)}{\\xi} = \\frac{\\varepsilon(x+\\xi) - \\varepsilon x}{\\xi} = \\frac{\\varepsilon\\xi}{\\xi} = \\varepsilon\n$$\n因此，所有键的拉伸都是均匀的，并且等于宏观应变 $\\varepsilon$。\n\n对于完整材料（$s < s_c$），对偶力函数由 $f(\\xi) = c\\,s\\,\\text{sign}(\\xi)$ 给出。代入 $s = \\varepsilon$：\n$$\nf(\\xi) = c\\,\\varepsilon\\,\\text{sign}(\\xi)\n$$\n现在我们可以计算完整状态下的应力 $\\sigma(\\varepsilon)$。对于从 $0$ 到 $\\delta$ 的积分，自变量 $\\xi$ 是正的，所以 $\\text{sign}(\\xi) = 1$。\n$$\n\\sigma(\\varepsilon) = \\int_{0}^{\\delta} \\xi (c\\,\\varepsilon \\cdot 1) \\, d\\xi = c\\,\\varepsilon \\int_{0}^{\\delta} \\xi \\, d\\xi\n$$\n$$\n\\sigma(\\varepsilon) = c\\,\\varepsilon \\left[ \\frac{\\xi^2}{2} \\right]_{0}^{\\delta} = \\frac{1}{2} c \\delta^2 \\varepsilon\n$$\n这就是完整近场动力学杆的应力-应变关系。\n\n我们可以使用基于能量的方法来验证这个结果。储存在单个键中的势能 $\\phi$ 满足对偶力是其相对于相对位移 $\\eta = u(x+\\xi)-u(x) = s\\xi$ 的导数。所以，$f(\\xi) = \\frac{1}{\\xi} \\frac{\\partial \\phi}{\\partial s}$。\n$$\n\\frac{\\partial \\phi}{\\partial s} = \\xi f(\\xi) = \\xi (c s \\, \\text{sign}(\\xi)) = c s |\\xi|\n$$\n对 $s$ 积分得到键势能：$\\phi(s) = \\frac{1}{2} c |\\xi| s^2$。应变能密度 $W$ 是通过在近场范围内对一半的键势能密度进行积分得到的（因子 $\\frac{1}{2}$ 避免了键的双重计数）：\n$$\nW = \\frac{1}{2} \\int_{-\\delta}^{\\delta} \\phi(s) \\, d\\xi = \\frac{1}{2} \\int_{-\\delta}^{\\delta} \\frac{1}{2} c |\\xi| s^2 \\, d\\xi\n$$\n当 $s=\\varepsilon$ 时，这变成：\n$$\nW = \\frac{1}{4} c \\varepsilon^2 \\int_{-\\delta}^{\\delta} |\\xi| \\, d\\xi = \\frac{1}{4} c \\varepsilon^2 \\left( \\int_{-\\delta}^{0} (-\\xi) \\, d\\xi + \\int_{0}^{\\delta} \\xi \\, d\\xi \\right) = \\frac{1}{4} c \\varepsilon^2 \\left( \\frac{\\delta^2}{2} + \\frac{\\delta^2}{2} \\right) = \\frac{1}{4} c \\delta^2 \\varepsilon^2\n$$\n应力是应变能密度对应变的导数：\n$$\n\\sigma = \\frac{\\partial W}{\\partial \\varepsilon} = \\frac{\\partial}{\\partial \\varepsilon} \\left( \\frac{1}{4} c \\delta^2 \\varepsilon^2 \\right) = \\frac{1}{2} c \\delta^2 \\varepsilon\n$$\n两种方法得到相同的表达式，证实了其正确性。\n\n### 步骤 2：标定微模量 $c$\n\n为了标定近场动力学模型，我们强制其在小应变下与经典线弹性力学对于完整材料的行为等效。在经典连续介质力学中，单轴应力-应变关系由胡克定律 (Hooke's Law) 给出：\n$$\n\\sigma(\\varepsilon) = E \\varepsilon\n$$\n其中 $E$ 是杨氏模量。将经典和近场动力学的应力表达式相等：\n$$\nE \\varepsilon = \\frac{1}{2} c \\delta^2 \\varepsilon\n$$\n这个等式必须对任何 $\\varepsilon \\neq 0$ 都成立，因此我们可以解出微模量 $c$：\n$$\nc = \\frac{2E}{\\delta^2}\n$$\n这个关系根据宏观材料属性 $E$ 和模型参数 $\\delta$ 标定了近场动力学参数 $c$。将此代回我们的 PD 应力方程，可以确认其等效性：$\\sigma(\\varepsilon) = \\frac{1}{2}\\left(\\frac{2E}{\\delta^2}\\right)\\delta^2\\varepsilon = E\\varepsilon$。\n\n### 步骤 3：推导完整的应力-应变曲线和抗拉强度 $\\sigma_{\\max}$\n\n问题陈述了一个脆性失效准则：当一个键的拉伸 $s$ 超过临界值 $s_c > 0$ 时，它会不可逆地断裂。一旦断裂，键就不再能承受力，意味着其对偶力函数变为 $f(\\xi) = 0$。\n\n加载在宏观应变 $\\varepsilon$ 上是单调的，并且我们已经确定每个键的拉伸都是 $s = \\varepsilon$。\n- 对于 $0 \\le \\varepsilon \\le s_c$：所有键的拉伸都小于或等于临界拉伸。没有键断裂。材料表现为线弹性固体，应力为 $\\sigma(\\varepsilon) = E \\varepsilon$。\n- 对于 $\\varepsilon > s_c$：所有键的拉伸现在都超过了临界拉伸。由于均匀应变的假设，材料中所有的键同时断裂。对偶力函数 $f(\\xi)$ 对所有 $\\xi$ 都变为零。\n\n因此，作为键力积分的应力降至零。\n$$\n\\sigma(\\varepsilon) = \\int_{0}^{\\delta} \\xi \\cdot 0 \\, d\\xi = 0 \\quad \\text{对于 } \\varepsilon > s_c\n$$\n这代表了整个杆的灾难性脆性断裂。\n\n因此，完整的应力-应变曲线 $\\sigma(\\varepsilon)$ 是一个分段函数：\n$$\n\\sigma(\\varepsilon) = \\begin{cases} E \\varepsilon & \\text{如果 } 0 \\le \\varepsilon \\le s_c \\\\ 0 & \\text{如果 } \\varepsilon > s_c \\end{cases}\n$$\n表观抗拉强度 $\\sigma_{\\max}$ 定义为 $\\sigma(\\varepsilon)$ 在 $\\varepsilon \\ge 0$ 上的最大值。函数 $\\sigma(\\varepsilon)$ 从 $\\sigma(0)=0$ 线性增加到在 $\\varepsilon = s_c$ 处的最大值，然后降为零。因此，最大应力恰好在失效点达到：\n$$\n\\sigma_{\\max} = \\sigma(s_c) = E \\cdot s_c\n$$\n这就是表观抗拉强度的最终公式。请注意，这个结果与近场动力学近场范围 $\\delta$ 无关，尽管 $\\delta$ 在中间的推导和标定过程中是必需的，但在宏观属性之间的最终关系中被消除了。\n\n程序将实现这个简单的公式 $\\sigma_{\\max} = E \\cdot s_c$，为每个测试用例计算抗拉强度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the apparent tensile strength for a 1D bond-based peridynamic model\n    based on the derived formula sigma_max = E * s_c.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (E in Pa, delta in m, s_c dimensionless).\n    # E: Young's modulus\n    # delta: Peridynamic horizon\n    # s_c: Critical stretch\n    test_cases = [\n        (200e9, 0.01, 0.005),   # Case 1\n        (200e9, 0.05, 0.01),    # Case 2\n        (70e9, 0.005, 0.015),   # Case 3\n        (200e9, 0.002, 1e-4),   # Case 4\n        (200e9, 0.001, 0.008)    # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case.\n        E, delta, s_c = case\n\n        # The derivation shows that under the assumption of homogeneous strain,\n        # the peridynamic model is equivalent to a classical elastic model\n        # with Young's modulus E up to the point of failure.\n        # The stress-strain relation is sigma(epsilon) = E * epsilon.\n        # Failure occurs when the strain epsilon exceeds the critical stretch s_c.\n        # Therefore, the maximum stress (apparent tensile strength) is achieved\n        # at epsilon = s_c.\n        #\n        # sigma_max = E * s_c\n        #\n        # The peridynamic horizon 'delta' is required for the theoretical\n        # derivation and calibration of the micro-modulus 'c', but it does not\n        # appear in the final formula for the macroscopic tensile strength.\n\n        sigma_max = E * s_c\n        results.append(sigma_max)\n\n    # The final print statement must produce only the specified single-line format.\n    # The map(str, results) converts each float in the results list to its string representation.\n    # ','.join(...) concatenates these strings with a comma separator.\n    # The f-string encloses the final joined string in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "从准静态行为转向动力学，本练习将探讨非局域性最深刻的后果之一。您将推导近场动力学固体中的波色散关系，并发现它与经典的局域理论有何根本不同。这一分析将揭示截止频率的概念，这是模型内禀长度尺度 $ \\delta $ 的自然结果，它解决了经典理论在极小尺度下存在的非物理行为 。",
            "id": "3793709",
            "problem": "考虑一个均匀、无限的一维 (1D) 线性近场动力学固体，其质量密度为 $\\rho$，视域为 $\\delta$。对于标量位移场 $u(x,t)$，其小应变、基于键的近场动力学运动方程由线性动量的积分平衡定义：对于位于位置 $x$ 的每个物质点，其内力密度等于半径为 $\\delta$ 的邻域内成对相互作用的非局部积分。假设微模量函数 $c(\\xi)$ 仅依赖于键向量 $\\xi$，且 $c(\\xi)$ 是对称的，并在 $|\\xi|>\\delta$ 时为零。令微模量分解为 $c(\\xi)=c_{0}\\,\\omega(\\xi)$，其中 $c_{0}$ 是一个常数，$\\omega(\\xi)$ 是一个对称的无量纲核函数。使用以下特定的核函数选择：当 $|\\xi|\\leq \\delta$ 时 $\\omega(\\xi)=1$，当 $|\\xi|>\\delta$ 时 $\\omega(\\xi)=0$。\n\n从近场动力学运动方程出发，采用小振幅平面波拟设 $u(x,t)=U\\,\\exp\\!\\big(i(kx-\\omega t)\\big)$，其中 $U$ 是常数振幅，$k$ 是实数波数，$\\omega$ 是实数角频率，推导色散关系 $\\omega=\\omega(k)$ 的闭式解。\n\n通过强制在长波极限 $k\\to 0$ 下，近场动力学色散关系恢复到基于杨氏模量 $E$ 的经典弹性杆波速，即 $\\omega\\approx k\\sqrt{E/\\rho}$，来标定 $c_{0}$。用 $E$、$\\rho$、$\\delta$ 和 $k$ 表示最终的色散关系 $\\omega(k)$。\n\n然后，使用您推导出的表达式，从第一性原理出发解释为什么与经典弹性色散关系相比，这种非局部模型在高波数下会产生带限效应，并确定 $\\omega(k)$ 在高波数下的有限极限。您最终报告的答案必须是 $\\omega(k)$ 的单一闭式解析表达式；不需要四舍五入，且最终方框内的表达式不应包含单位。",
            "solution": "该问题是有效的，因为它科学地基于已建立的近场动力学理论，问题陈述清晰且信息充分，可得到唯一解，并且陈述客观。\n\n推导始于物质点 $x$ 在时间 $t$ 的位移场 $u(x,t)$ 的一维、线性化、基于键的近场动力学运动方程。给定质量密度 $\\rho$ 和微模量函数 $c(\\xi)$，该方程是一个表示线性动量平衡的积分微分方程：\n$$ \\rho \\frac{\\partial^2 u(x,t)}{\\partial t^2} = \\int_{-\\infty}^{\\infty} c(\\xi) [u(x+\\xi,t) - u(x,t)] \\, d\\xi $$\n微模量由 $c(\\xi) = c_0 \\, \\omega(\\xi)$ 给出，其中当 $|\\xi| \\leq \\delta$ 时 $\\omega(\\xi) = 1$，当 $|\\xi| > \\delta$ 时 $\\omega(\\xi)=0$。参数 $\\delta$ 是视域。代入这种形式的 $c(\\xi)$ 可以简化积分的域：\n$$ \\rho \\frac{\\partial^2 u(x,t)}{\\partial t^2} = \\int_{-\\delta}^{\\delta} c_0 [u(x+\\xi,t) - u(x,t)] \\, d\\xi $$\n为了求出色散关系，我们将平面波拟设 $u(x,t) = U \\exp(i(kx - \\omega t))$ 代入运动方程。首先，我们计算左侧 (LHS)：\n$$ \\text{LHS} = \\rho \\frac{\\partial^2}{\\partial t^2} \\left[ U \\exp(i(kx - \\omega t)) \\right] = \\rho U (-i\\omega)^2 \\exp(i(kx - \\omega t)) = -\\rho \\omega^2 U \\exp(i(kx - \\omega t)) $$\n接下来，我们计算右侧 (RHS)：\n$$ \\text{RHS} = \\int_{-\\delta}^{\\delta} c_0 [U \\exp(i(k(x+\\xi) - \\omega t)) - U \\exp(i(kx - \\omega t))] \\, d\\xi $$\n$$ \\text{RHS} = c_0 U \\exp(i(kx - \\omega t)) \\int_{-\\delta}^{\\delta} [\\exp(ik\\xi) - 1] \\, d\\xi $$\n令 LHS 和 RHS 相等，并除以公共的非零项 $U \\exp(i(kx - \\omega t))$，我们得到：\n$$ -\\rho \\omega^2 = c_0 \\int_{-\\delta}^{\\delta} [\\exp(ik\\xi) - 1] \\, d\\xi $$\n$$ \\rho \\omega^2 = c_0 \\int_{-\\delta}^{\\delta} [1 - \\exp(ik\\xi)] \\, d\\xi $$\n使用欧拉公式 $\\exp(ik\\xi) = \\cos(k\\xi) + i\\sin(k\\xi)$，积分变为：\n$$ \\rho \\omega^2 = c_0 \\int_{-\\delta}^{\\delta} [1 - \\cos(k\\xi) - i\\sin(k\\xi)] \\, d\\xi $$\n奇函数 $\\sin(k\\xi)$ 在对称区间 $[-\\delta, \\delta]$ 上的积分为零。偶函数 $1 - \\cos(k\\xi)$ 留下：\n$$ \\rho \\omega^2 = c_0 \\int_{-\\delta}^{\\delta} [1 - \\cos(k\\xi)] \\, d\\xi = 2 c_0 \\int_{0}^{\\delta} [1 - \\cos(k\\xi)] \\, d\\xi $$\n进行积分：\n$$ \\int_{0}^{\\delta} [1 - \\cos(k\\xi)] \\, d\\xi = \\left[ \\xi - \\frac{\\sin(k\\xi)}{k} \\right]_0^\\delta = \\delta - \\frac{\\sin(k\\delta)}{k} $$\n因此，用常数 $c_0$ 表示的色散关系是：\n$$ \\rho \\omega^2(k) = 2 c_0 \\left( \\delta - \\frac{\\sin(k\\delta)}{k} \\right) $$\n\n接下来，我们通过将模型在长波极限 ($k \\to 0$) 下的行为与经典弹性理论的行为相匹配来标定微模量常数 $c_0$。对于杨氏模量为 $E$、密度为 $\\rho$ 的弹性杆，其经典色散关系为 $\\omega(k) = k \\sqrt{E/\\rho}$，或 $\\omega^2(k) = k^2 E/\\rho$。\n为了求出近场动力学色散关系的长波极限，我们使用 $\\sin(k\\delta)$ 在 $k=0$ 附近的泰勒级数展开：\n$$ \\sin(k\\delta) = (k\\delta) - \\frac{(k\\delta)^3}{3!} + \\frac{(k\\delta)^5}{5!} - \\dots $$\n将此代入括号中的项：\n$$ \\delta - \\frac{\\sin(k\\delta)}{k} = \\delta - \\frac{1}{k}\\left( k\\delta - \\frac{k^3\\delta^3}{6} + O(k^5) \\right) = \\delta - \\left( \\delta - \\frac{k^2\\delta^3}{6} + O(k^4) \\right) = \\frac{k^2\\delta^3}{6} + O(k^4) $$\n在 $k \\to 0$ 的极限下，色散关系变为：\n$$ \\rho \\omega^2(k) \\approx 2 c_0 \\left( \\frac{k^2\\delta^3}{6} \\right) = \\frac{c_0 \\delta^3}{3} k^2 $$\n将其与经典关系 $\\omega^2(k) \\approx k^2 E/\\rho$ 相等：\n$$ \\frac{c_0 \\delta^3}{3\\rho} k^2 = \\frac{E}{\\rho} k^2 $$\n这得出了标定后的微模量常数的表达式：\n$$ c_0 = \\frac{3E}{\\delta^3} $$\n现在我们将这个标定后的 $c_0$ 代回到完整的近场动力学色散关系中：\n$$ \\rho \\omega^2(k) = 2 \\left(\\frac{3E}{\\delta^3}\\right) \\left( \\delta - \\frac{\\sin(k\\delta)}{k} \\right) $$\n$$ \\omega^2(k) = \\frac{6E}{\\rho\\delta^3} \\left( \\delta - \\frac{\\sin(k\\delta)}{k} \\right) = \\frac{6E}{\\rho\\delta^2} \\left( 1 - \\frac{\\sin(k\\delta)}{k\\delta} \\right) $$\n取平方根（并考虑物理上非负的频率），我们得到色散关系的最终表达式：\n$$ \\omega(k) = \\sqrt{\\frac{6E}{\\rho\\delta^2} \\left( 1 - \\frac{\\sin(k\\delta)}{k\\delta} \\right)} $$\n\n最后，我们解释带限效应。经典色散关系 $\\omega_{cl}(k) = k \\sqrt{E/\\rho}$ 是线性的，这意味着随着波数 $k$ 的增加，频率可以无限增大。这是局部连续介质模型的一个非物理的人为结果，该模型缺乏内在的长度尺度。\n相比之下，近场动力学色散关系在高波数下表现出根本不同的行为。这直接源于积分公式的非局部性，其中相互作用发生在由视域 $\\delta$ 定义的有限距离内。为了看到这一点，我们考察 $\\omega(k)$ 在 $k \\to \\infty$ 时的极限：\n$$ \\lim_{k\\to\\infty} \\omega(k) = \\lim_{k\\to\\infty} \\sqrt{\\frac{6E}{\\rho\\delta^2} \\left( 1 - \\frac{\\sin(k\\delta)}{k\\delta} \\right)} $$\n当 $k \\to \\infty$ 时，项 $\\sin(k\\delta)$ 保持在 $-1$ 和 $1$ 之间有界，而分母 $k\\delta$ 趋于无穷大。因此，$\\lim_{k\\to\\infty} \\frac{\\sin(k\\delta)}{k\\delta} = 0$。\n频率的极限则为：\n$$ \\omega_{max} = \\lim_{k\\to\\infty} \\omega(k) = \\sqrt{\\frac{6E}{\\rho\\delta^2} (1 - 0)} = \\sqrt{\\frac{6E}{\\rho\\delta^2}} $$\n这表明频率不会无限增长，而是渐近地趋近于一个有限的最大值 $\\omega_{max}$。这就是带限效应或截止频率。在物理上，这意味着频率大于 $\\omega_{max}$ 的平面波无法在介质中传播。这种行为是材料内部长度尺度 $\\delta$ 的直接结果。对于非常高的波数，相应的波长 $\\lambda = 2\\pi/k$ 变得远小于视域 $\\delta$。原始积分中的项 $\\exp(ik\\xi)$ 在积分域 $[-\\delta, \\delta]$ 上非常迅速地振荡，导致来自相邻粒子的合力被平均掉并达到饱和。在短波长下内力的这种饱和现象阻止了波频率的无限增加，从而引入了经典局部理论中所没有的自然正则化。",
            "answer": "$$\\boxed{\\sqrt{\\frac{6E}{\\rho \\delta^2} \\left( 1 - \\frac{\\sin(k\\delta)}{k\\delta} \\right)}}$$"
        },
        {
            "introduction": "最后的这项实践将带您进入计算近场动力学的核心，要求您实现一个断裂杆的动态模拟。核心任务不仅是编写运动方程的代码，更要执行严格的能量平衡审计，这是验证任何数值动力学代码的关键步骤。您将学习如何追踪动能、弹性能和断裂能，并量化数值误差，区分来自时间积分器的耗散与来自离散键断裂过程的伪影 。",
            "id": "3587038",
            "problem": "考虑一个一维均质杆的键基近场动力学公式，该杆被离散为 $N$ 个等间距的物质点。近场动力学运动方程直接源于牛顿第二定律和成对近场动力学力函数。您的任务是为具有不可逆键断裂的微弹性脆性模型实现一个显式中心差分时间积分器，并执行严格的能量平衡检验，包括动能、弹性（成对键）能以及因键断裂而累积的断裂功。此外，您必须量化由两个来源引起的数值耗散：显式时间积分和断裂时的步进式邻域（键）更新。\n\n基本原理：\n- 牛顿第二定律：对于每个质量为 $m_i$ 的物质点 $i$，其加速度由内部近场动力学合力给出，即 $m_i \\, \\ddot{y}_i(t) = \\sum_{j \\in \\mathcal{H}_i} f_{ij}(t)$，其中 $\\mathcal{H}_i$ 表示在参考构型中点 $i$ 的作用范围内的邻域点集。\n- 具有恒定微模量 $c$ 和单位影响函数的一维键基微弹性脆性近场动力学：对于点 $i$ 和 $j$ 之间的一个键，参考间距为 $r_{0,ij} = x_j - x_i > 0$，当前间距为 $r_{ij}(t) = y_j(t) - y_i(t)$，伸长率为 $s_{ij}(t) = \\dfrac{r_{ij}(t) - r_{0,ij}}{r_{0,ij}}$。沿键的成对标量力贡献为 $f_{ij}(t) = c \\, s_{ij}(t) \\, V_i V_j$，对点 $i$ 起正向作用，对点 $j$ 起负向作用，其中 $V_i$ 和 $V_j$ 是相关的点体积。当 $s_{ij}(t) \\ge s_{\\mathrm{crit}}$ 时，键发生不可逆断裂。\n- 能量学：动能为 $E_{\\mathrm{kin}}(t) = \\sum_i \\dfrac{1}{2} m_i v_i(t)^2$，其中 $v_i(t)$ 是物质点的速度。储存在所有未断裂键中的弹性势能为 $E_{\\mathrm{el}}(t) = \\sum_{(i,j) \\in \\mathcal{B}(t)} \\dfrac{1}{2} c \\, r_{0,ij} \\, s_{ij}(t)^2 \\, V_i V_j$，其中 $\\mathcal{B}(t)$ 是当前未断裂键的集合（每个键只计一次）。因键断裂而累积的断裂功为 $E_{\\mathrm{frac}}(t) = \\sum_{(i,j) \\in \\mathcal{F}(t)} \\dfrac{1}{2} c \\, r_{0,ij} \\, s_{\\mathrm{crit}}^2 \\, V_i V_j$，其中 $\\mathcal{F}(t)$ 是到时间 $t$ 为止已经断裂的键的集合。\n- 能量平衡检验：在没有外力功的情况下，理想的能量平衡为 $E_{\\mathrm{tot}}(t) = E_{\\mathrm{kin}}(t) + E_{\\mathrm{el}}(t) + E_{\\mathrm{frac}}(t) = \\mathrm{constant}$。任何与恒定值的偏差都是由数值伪影引起的。将给定时间 $t$ 的总数值耗散定义为 $D_{\\mathrm{tot}}(t) = E_{\\mathrm{tot}}(0) - E_{\\mathrm{tot}}(t)$。当在离散的更新时间检测到键断裂时，键的伸长率可能会超过 $s_{\\mathrm{crit}}$；与此相关的、未被 $E_{\\mathrm{frac}}$ 计入的过冲能量为 $D_{\\mathrm{nbr}}(t) = \\sum_{\\text{break events}} \\dfrac{1}{2} c \\, r_{0,ij} \\, \\left( s_{ij}(t)^2 - s_{\\mathrm{crit}}^2 \\right) \\, V_i V_j$，此值在检测时间进行评估。将此量归因于步进式邻域（键）更新耗散。然后将其余部分 $D_{\\mathrm{time}}(t) = D_{\\mathrm{tot}}(t) - D_{\\mathrm{nbr}}(t)$ 归因于显式时间积分误差。\n\n几何与离散化：\n- 长度为 $L$ 的一维均质杆被离散为 $N$ 个物质点。参考位置为 $x_i = i \\, \\Delta x$，其中 $i = 0, 1, \\dots, N-1$，且 $\\Delta x = L/(N-1)$。每个点的体积为 $V_i = \\Delta x$。每个点的质量为 $m_i = \\rho \\, A \\, V_i$，其中 $A$ 是横截面积，$\\rho$ 是质量密度。使用 $A = 1$ 和 $\\rho = 1$（无量纲一致单位）。\n- 近场动力学作用范围为 $h$。参考构型中的邻域集包括所有满足 $j > i$ 和 $x_j - x_i \\le h$ 的点对 $(i,j)$。所有键的影响函数均为单位1，因此没有额外的加权。\n\n时间积分与键断裂：\n- 使用显式中心差分更新，速度存储在半时间步长上：$v_i^{n+\\frac{1}{2}} = v_i^{n-\\frac{1}{2}} + \\dfrac{F_i^n}{m_i} \\, \\Delta t$，以及 $y_i^{n+1} = y_i^n + v_i^{n+\\frac{1}{2}} \\, \\Delta t$，其中 $F_i^n$ 是根据构型 $y^n$ 下未断裂键计算的内部合力。使用 $y_i^0 = x_i$ 和 $v_i^{\\frac{1}{2}} = v_i^0$ 进行初始化（因为当 $s_{ij}^0 = 0$ 时 $F_i^0 = 0$）。\n- 更新到 $y^{n+1}$ 后，检测所有满足 $s_{ij}^{n+1} \\ge s_{\\mathrm{crit}}$ 的键。对于每个这样的键，累加断裂功增量 $\\Delta E_{\\mathrm{frac}} = \\dfrac{1}{2} c \\, r_{0,ij} \\, s_{\\mathrm{crit}}^2 \\, V_i V_j$，计算过冲耗散增量 $\\Delta D_{\\mathrm{nbr}} = \\dfrac{1}{2} c \\, r_{0,ij} \\, \\left( s_{ij}^{n+1}{}^2 - s_{\\mathrm{crit}}^2 \\right) \\, V_i V_j$，并将该键标记为已断裂，使其此后不再贡献力或弹性势能。请注意，检测是在离散时间点进行的，不使用子步长；因此，当发生过冲时，$\\Delta D_{\\mathrm{nbr}} \\ge 0$。\n\n初始条件：\n- 初始位移为零，$y_i^0 = x_i$。初始速度为线性斜坡 $v_i^0 = v_{\\mathrm{amp}} \\, \\dfrac{x_i}{L}$，这会在短时间内对所有键产生均匀的伸长率。当 $s_{ij}$ 保持较小时，此选择导致作用范围内所有键的初始伸长率均为 $ \\dot{s}_{ij}(0) \\approx \\dfrac{v_{\\mathrm{amp}}}{L}$。\n\n所需输出和单位：\n- 所有量都是无量纲的（无量纲一致单位体系）。无需进行物理单位转换。\n- 对于每个测试用例，计算在最终仿真时间 $T$ 的以下浮点数：$D_{\\mathrm{tot}}(T)$、$D_{\\mathrm{nbr}}(T)$ 和 $D_{\\mathrm{time}}(T)$。此外，使用每个时间步采样值，计算整个仿真过程中的最大总耗散幅值 $D_{\\max} = \\max_{0 \\le t \\le T} \\left| D_{\\mathrm{tot}}(t) \\right|$。\n\n测试套件：\n使用以下参数集实现三个测试用例。在所有情况下，均使用 $N = 101$、$L = 1$、$\\rho = 1$、$A = 1$、作用范围 $h = 3 \\Delta x$、微模量 $c = 0.5$ 和临界伸长率 $s_{\\mathrm{crit}} = 0.02$。\n1. 正常情况：中等时间步长和速度幅值，预期会有一些键断裂和中等程度的过冲。\n   - $\\Delta t = 2.0 \\times 10^{-4}$, $T = 5.0 \\times 10^{-2}$, $v_{\\mathrm{amp}} = 0.5$。\n2. 近保守边界：小时间步长，预期显式积分误差非常低，过冲减小。\n   - $\\Delta t = 5.0 \\times 10^{-5}$, $T = 5.0 \\times 10^{-2}$, $v_{\\mathrm{amp}} = 0.5$。\n3. 边缘情况：大时间步长，预期由过冲引起的耗散更大，且积分误差明显。\n   - $\\Delta t = 8.0 \\times 10^{-4}$, $T = 5.0 \\times 10^{-2}$, $v_{\\mathrm{amp}} = 0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例产生一个包含四个浮点数的列表，顺序为 $[D_{\\mathrm{tot}}(T), D_{\\mathrm{nbr}}(T), D_{\\mathrm{time}}(T), D_{\\max}]$。因此，总输出是包含三个此类列表的列表，每个测试用例一个，例如 $[[d_{1,\\mathrm{tot}}, d_{1,\\mathrm{nbr}}, d_{1,\\mathrm{time}}, d_{1,\\max}], [d_{2,\\mathrm{tot}}, d_{2,\\mathrm{nbr}}, d_{2,\\mathrm{time}}, d_{2,\\max}], [d_{3,\\mathrm{tot}}, d_{3,\\mathrm{nbr}}, d_{3,\\mathrm{time}}, d_{3,\\max}]]$.",
            "solution": "该问题要求为微弹性脆性杆实现一个一维的、基于键的近场动力学仿真。目标是进行详细的能量平衡分析，量化来自两个不同来源的数值耗散：显式时间积分方案和键断裂更新的离散性。\n\n本解决方案首先将长度为 $L$ 的一维杆离散为 $N$ 个物质点。每个点 $i$ 的参考位置是 $x_i = i \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，等间距为 $\\Delta x = L/(N-1)$。每个点具有体积 $V_i = \\Delta x$ 和质量 $m_i = \\rho A V_i$，其中 $\\rho$ 是质量密度，$A$ 是横截面积。对于此问题，我们使用 $\\rho=1$ 和 $A=1$。\n\n该近场动力学模型是基于键的，这意味着物质点在一个称为作用范围（horizon）$h$ 的有限半径内通过成对力相互作用。如果任意两点 $i$ 和 $j$ 的初始间距 $r_{0,ij} = |x_j - x_i|$ 小于或等于 $h$，则它们之间建立一个键。在实现中，我们只考虑 $i < j$ 的点对，因此 $r_{0,ij} = x_j - x_i$。这组键被预先计算并存储。每个键的状态（活动或断裂）在整个仿真过程中被跟踪。\n\n系统的动力学由每个物质点 $i$ 的牛顿第二定律决定：\n$$m_i \\ddot{y}_i(t) = F_i(t)$$\n其中 $y_i(t)$ 是点 $i$ 的当前位置，$F_i(t)$ 是作用于其上的近场动力学合力。该力是连接到点 $i$ 的所有键的贡献之和。根据问题的定义，点 $i$ 和 $j$ 之间的键（$i < j$）的伸长率为 $s_{ij}(t) = (y_j(t) - y_i(t) - r_{0,ij}) / r_{0,ij}$。如果键是活动的，它会贡献一个成对力大小为 $f_{ij} = c s_{ij}(t) V_i V_j$。这个力作用于点 $i$，方向为正，作用于点 $j$，方向为负。因此，$F_i(t) = \\sum_{j \\in \\mathcal{H}_i} f_{ij}(t)$。\n\n时间积分采用显式中心差分方案（在形式上等价于速度Verlet算法）。速度在半时间步长上评估，位置在完整时间步长上评估：\n$$ v_i^{n+1/2} = v_i^{n-1/2} + \\frac{F_i^n}{m_i} \\Delta t $$\n$$ y_i^{n+1} = y_i^n + v_i^{n+1/2} \\Delta t $$\n其中上标 $n$ 表示时间步。初始化时，速度 $v_i^{1/2} = v_i^0$，因为初始力 $F_i^0=0$（零初始位移）。\n\n能量计算是关键部分。在每个时间步 $n$，我们需要在同一时间点评估所有能量项。整数时间步 $n$ 的速度值可以通过半步速度的平均值来近似：$v_i^n = (v_i^{n-1/2} + v_i^{n+1/2}) / 2$。\n- **动能**：$E_{\\mathrm{kin}}^n = \\sum_i \\frac{1}{2} m_i (v_i^n)^2$\n- **弹性势能**：$E_{\\mathrm{el}}^n = \\sum_{(i,j) \\in \\mathcal{B}^n} \\frac{1}{2} c r_{0,ij} (s_{ij}^n)^2 V_i V_j$，其中 $\\mathcal{B}^n$ 是在时间步 $n$ 开始时活动的键的集合。\n- **断裂能**：$E_{\\mathrm{frac}}^n$ 是之前所有时间步中累积的断裂能。\n- **总能量**：$E_{\\mathrm{tot}}^n = E_{\\mathrm{kin}}^n + E_{\\mathrm{el}}^n + E_{\\mathrm{frac}}^n$。\n- **总耗散**：$D_{\\mathrm{tot}}^n = E_{\\mathrm{tot}}^0 - E_{\\mathrm{tot}}^n$。\n\n键断裂检查在位置更新之后进行。在计算出 $y^{n+1}$ 后，我们为每个活动的键计算新的伸长率 $s_{ij}^{n+1}$。如果 $s_{ij}^{n+1} \\ge s_{\\mathrm{crit}}$，则该键断裂。\n- 该键被标记为非活动，在后续步骤中不再贡献力或弹性势能。\n- 断裂能增加一个标准量：$\\Delta E_{\\mathrm{frac}} = \\frac{1}{2} c r_{0,ij} s_{\\mathrm{crit}}^2 V_i V_j$。\n- 由于离散时间步，伸长率可能超过临界值（过冲）。这种过冲能量被视为数值耗散，并累积到邻域更新耗散项 $D_{\\mathrm{nbr}}$ 中：$\\Delta D_{\\mathrm{nbr}} = \\frac{1}{2} c r_{0,ij} ((s_{ij}^{n+1})^2 - s_{\\mathrm{crit}}^2) V_i V_j$。\n\n在仿真结束时，总耗散 $D_{\\mathrm{tot}}(T)$ 可以分解为由时间积分器引起的耗散 $D_{\\mathrm{time}}(T)$ 和由键断裂过冲引起的耗散 $D_{\\mathrm{nbr}}(T)$：\n$$ D_{\\mathrm{time}}(T) = D_{\\mathrm{tot}}(T) - D_{\\mathrm{nbr}}(T) $$\n该程序将执行这些步骤，并在仿真结束时报告 $D_{\\mathrm{tot}}(T)$, $D_{\\mathrm{nbr}}(T)$, $D_{\\mathrm{time}}(T)$ 和整个过程中的最大总耗散 $D_{\\max}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the peridynamic simulation for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n\n    def run_simulation(N, L, rho, A, c, scrit, h, dt, T, v_amp):\n        \"\"\"\n        Executes a single peridynamic simulation with a given set of parameters.\n\n        Returns a list of floats: [D_tot(T), D_nbr(T), D_time(T), D_max].\n        \"\"\"\n        # 1. Discretization and Initialization\n        dx = L / (N - 1)\n        m = rho * A * dx\n        V2 = dx * dx  # Pre-calculate V_i * V_j as it's constant\n\n        x = np.linspace(0, L, N, dtype=np.float64)\n        y_n = np.copy(x)\n\n        # Initial velocities\n        v_0 = v_amp * x / L\n        \n        # Central difference scheme uses velocities at half-time steps.\n        # v_n_minus_half represents v^{n-1/2}.\n        # For initialization, v^{1/2} = v^0 since F^0 is zero.\n        v_n_minus_half = np.copy(v_0)\n\n        # 2. Bond Setup\n        bonds = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = x[j] - x[i]\n                if dist = h + 1e-9: # Add tolerance for float comparison\n                    bonds.append({'i': i, 'j': j, 'r0': dist, 'active': True})\n        \n        # 3. Energy Initialization\n        E_frac = 0.0\n        D_nbr = 0.0\n        \n        # Initial kinetic energy at t=0. v(0) = v_0.\n        E_kin_0 = 0.5 * m * np.sum(v_0**2)\n        # Initial elastic and fracture energies are zero.\n        E_tot_0 = E_kin_0\n\n        D_max = 0.0\n        \n        num_steps = int(round(T / dt))\n\n        # 4. Time-stepping Loop\n        for n in range(num_steps):\n            # A. Compute forces F^n from positions y^n\n            F_n = np.zeros(N, dtype=np.float64)\n            s_n_values = {}  # Store stretches s^n for energy calculation\n\n            for k, bond in enumerate(bonds):\n                if bond['active']:\n                    i, j = bond['i'], bond['j']\n                    r_n = y_n[j] - y_n[i]\n                    s_n = (r_n - bond['r0']) / bond['r0']\n                    s_n_values[k] = s_n\n                    \n                    f = c * s_n * V2\n                    F_n[i] += f\n                    F_n[j] -= f\n\n            # B. Update velocities from v^{n-1/2} to v^{n+1/2}\n            v_n_plus_half = v_n_minus_half + (F_n / m) * dt\n\n            # C. Energy calculation at time t_n\n            # v^n = (v^{n-1/2} + v^{n+1/2}) / 2\n            v_n = 0.5 * (v_n_minus_half + v_n_plus_half)\n            E_kin_n = 0.5 * m * np.sum(v_n**2)\n            \n            E_el_n = 0.0\n            for k, bond in enumerate(bonds):\n                if bond['active']:\n                    s_n = s_n_values[k]\n                    E_el_n += 0.5 * c * bond['r0'] * s_n**2 * V2\n\n            E_tot_n = E_kin_n + E_el_n + E_frac\n            D_tot_n = E_tot_0 - E_tot_n\n            D_max = max(D_max, abs(D_tot_n))\n\n            # D. Update positions from y^n to y^{n+1}\n            y_n_plus_1 = y_n + v_n_plus_half * dt\n            \n            # E. Check for bond breaks based on new positions y^{n+1}\n            # The accumulated E_frac, D_nbr will be used in the next step's energy calc\n            for k, bond in enumerate(bonds):\n                if bond['active']:\n                    i, j = bond['i'], bond['j']\n                    r_np1 = y_n_plus_1[j] - y_n_plus_1[i]\n                    s_np1 = (r_np1 - bond['r0']) / bond['r0']\n                    \n                    if s_np1 >= scrit:\n                        bond['active'] = False\n                        \n                        E_frac += 0.5 * c * bond['r0'] * scrit**2 * V2\n                        D_nbr += 0.5 * c * bond['r0'] * (s_np1**2 - scrit**2) * V2\n            \n            # F. Prepare for the next iteration\n            y_n = y_n_plus_1\n            v_n_minus_half = v_n_plus_half\n    \n        # 5. Post-loop: Final calculation at time T\n        # Current state: y_n = y^{N_steps}, v_n_minus_half = v^{N_steps-1/2}\n        \n        # Final force calculation at t_N = T\n        F_N = np.zeros(N, dtype=np.float64)\n        s_N_values = {}\n        for k, bond in enumerate(bonds):\n            if bond['active']:\n                i, j = bond['i'], bond['j']\n                r_N = y_n[j] - y_n[i]\n                s_N = (r_N - bond['r0']) / bond['r0']\n                s_N_values[k] = s_N\n                \n                f = c * s_N * V2\n                F_N[i] += f\n                F_N[j] -= f\n\n        # Final velocity updates to get v at time T\n        v_N_plus_half = v_n_minus_half + (F_N / m) * dt\n        v_N = 0.5 * (v_n_minus_half + v_N_plus_half)\n        \n        # Final energy calculation\n        E_kin_T = 0.5 * m * np.sum(v_N**2)\n        \n        E_el_T = 0.0\n        for k, bond in enumerate(bonds):\n            if bond['active']:\n                s_N = s_N_values.get(k, 0) # Use .get for safety, though key should exist\n                E_el_T += 0.5 * c * bond['r0'] * s_N**2 * V2\n\n        # E_frac and D_nbr are their final accumulated values\n        E_tot_T = E_kin_T + E_el_T + E_frac\n        D_tot_T = E_tot_0 - E_tot_T\n        D_time_T = D_tot_T - D_nbr\n        \n        D_max = max(D_max, abs(D_tot_T))\n        \n        return [D_tot_T, D_nbr, D_time_T, D_max]\n\n    # --- Main execution ---\n    # Common parameters\n    N = 101\n    L = 1.0\n    rho = 1.0\n    A = 1.0\n    c = 0.5\n    scrit = 0.02\n    dx = L / (N - 1)\n    h = 3.0 * dx\n    \n    test_cases = [\n        # (dt, T, v_amp)\n        (2.0e-4, 5.0e-2, 0.5), # Case 1: Happy path\n        (5.0e-5, 5.0e-2, 0.5), # Case 2: Near-conservative\n        (8.0e-4, 5.0e-2, 0.5)  # Case 3: Edge case (large dt)\n    ]\n\n    results = []\n    for dt, T, v_amp in test_cases:\n        case_results = run_simulation(N, L, rho, A, c, scrit, h, dt, T, v_amp)\n        results.append(case_results)\n\n    # Format the final output string exactly as required\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}