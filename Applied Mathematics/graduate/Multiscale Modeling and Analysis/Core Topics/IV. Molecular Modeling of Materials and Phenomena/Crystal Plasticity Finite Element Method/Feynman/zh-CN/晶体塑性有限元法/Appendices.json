{
    "hands_on_practices": [
        {
            "introduction": "晶体中的塑性变形是通过在特定的晶体学平面和方向上发生滑移来实现的。在对滑移的动力学进行建模之前，掌握其几何学基础至关重要。本练习  将指导您列举出常见的面心立方（FCC）晶体的12个滑移系，并计算施密特张量的一个基本不变量，这些张量是将宏观应力与驱动滑移的分切应力联系起来的几何投影算子。",
            "id": "3748328",
            "problem": "考虑一个面心立方（FCC）金属单晶，其晶体坐标系与笛卡尔基底对齐，其中晶轴 $[100]$、$[010]$ 和 $[001]$ 分别与空间基向量 $\\mathbf{e}_{1}$、$\\mathbf{e}_{2}$ 和 $\\mathbf{e}_{3}$ 重合。在晶体塑性有限元法（CPFEM）中，FCC晶体的滑移发生在 $\\{111\\}\\langle 110\\rangle$ 滑移系上。一个滑移系 $\\alpha$ 由一个滑移面和一个滑移方向定义。滑移面具有单位法向量 $\\mathbf{n}^{\\alpha}$，滑移方向 $\\mathbf{s}^{\\alpha}$ 是位于该平面内且与 $\\mathbf{n}^{\\alpha}$ 正交的单位向量，即 $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$，$\\|\\mathbf{s}^{\\alpha}\\|=1$，且 $\\|\\mathbf{n}^{\\alpha}\\|=1$。滑移系上的分切应力由柯西应力（Cauchy）与施密德（Schmid）张量的双点积给出。对于FCC晶体，滑移系 $\\alpha$ 上的Schmid张量定义为\n$$\n\\mathbf{P}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right),\n$$\n其中 $\\otimes$ 表示张量（外）积。\n\n从晶体坐标系中 $\\{111\\}$ 平面法线和 $\\langle 110\\rangle$ 方向的定义出发，完成以下操作：\n1. 在晶体坐标系中，以单位向量的形式明确列出十二个滑移系 $\\{(\\mathbf{n}^{\\alpha},\\mathbf{s}^{\\alpha})\\}_{\\alpha=1}^{12}$。\n2. 使用上述定义构建相应的Schmid张量 $\\{\\mathbf{P}^{\\alpha}\\}_{\\alpha=1}^{12}$。\n3. 计算标量不变量\n$$\nI \\equiv \\sum_{\\alpha=1}^{12} \\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha},\n$$\n其中 $:$ 表示两个二阶张量的Frobenius内积。\n\n以精确实数的形式给出 $I$ 的最终值。将最终答案表示为无量纲量。无需四舍五入。",
            "solution": "该问题要求计算一个标量不变量 $I$，其定义为面心立方（FCC）晶体中所有十二个滑移系的Schmid张量的Frobenius范数平方和。计算过程如问题陈述中所述，分三个阶段进行：首先，识别滑移系；其次，理解Schmid张量的结构；第三，计算总和。\n\n待计算的不变量由下式给出：\n$$\nI \\equiv \\sum_{\\alpha=1}^{12} \\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}\n$$\n其中 $\\mathbf{P}^{\\alpha}$ 是滑移系 $\\alpha$ 的Schmid张量，定义为：\n$$\n\\mathbf{P}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\n$$\n此处，$\\mathbf{s}^{\\alpha}$ 是滑移方向上的单位向量，$\\mathbf{n}^{\\alpha}$ 是滑移面的单位法向量，且满足条件 $\\|\\mathbf{s}^{\\alpha}\\|=1$、$\\|\\mathbf{n}^{\\alpha}\\|=1$ 和 $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$。符号 $:$ 表示两个张量的Frobenius内积，$(\\mathbf{A}:\\mathbf{B}) = \\sum_{i,j} A_{ij}B_{ij}$。\n\n我们首先分析求和中的一个单项，$\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$。\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\left[\\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\\right] : \\left[\\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\\right]\n$$\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} \\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right) : \\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)\n$$\n利用Frobenius内积的线性性质，我们可以展开该表达式：\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} \\left[ (\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) + (\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) + (\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) + (\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) \\right]\n$$\n我们使用两个并矢积的Frobenius积的恒等式：$(\\mathbf{a} \\otimes \\mathbf{b}) : (\\mathbf{c} \\otimes \\mathbf{d}) = (\\mathbf{a} \\cdot \\mathbf{c})(\\mathbf{b} \\cdot \\mathbf{d})$。将此应用于每一项：\n1.  $(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) = (\\mathbf{s}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha})(\\mathbf{n}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha}) = \\|\\mathbf{s}^{\\alpha}\\|^2 \\|\\mathbf{n}^{\\alpha}\\|^2 = 1 \\cdot 1 = 1$。\n2.  $(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) = (\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha})(\\mathbf{n}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha}) = 0 \\cdot 0 = 0$。\n3.  $(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}) = (\\mathbf{n}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha})(\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha}) = 0 \\cdot 0 = 0$。\n4.  $(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}):(\\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}) = (\\mathbf{n}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha})(\\mathbf{s}^{\\alpha} \\cdot \\mathbf{s}^{\\alpha}) = \\|\\mathbf{n}^{\\alpha}\\|^2 \\|\\mathbf{s}^{\\alpha}\\|^2 = 1 \\cdot 1 = 1$。\n\n将这些结果代回 $\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ 的表达式中：\n$$\n\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha} = \\frac{1}{4} (1 + 0 + 0 + 1) = \\frac{2}{4} = \\frac{1}{2}\n$$\n这个结果值得注意，因为它对于任何有效的滑移系 $\\alpha$ 都是一个常数值。$\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ 的值与滑移面法线和滑移方向的具体取向无关，只要它们是单位向量且相互正交。\n\n下一步是确定FCC晶体的滑移系数量。滑移发生在 $\\{111\\}$ 平面上的 $\\langle 110 \\rangle$ 方向。我们必须枚举所有有效的组合。\n\n首先，识别 $\\{111\\}$ 滑移面族。有四种唯一的平面取向：\n$(111)$、$(1\\bar{1}1)$、$(\\bar{1}11)$ 和 $(11\\bar{1})$。相应平面法线的米勒指数 $[hkl]$ 的长度为 $\\sqrt{h^2+k^2+l^2} = \\sqrt{1^2+1^2+1^2} = \\sqrt{3}$。因此，通过除以 $\\sqrt{3}$ 得到归一化向量 $\\mathbf{n}^{\\alpha}$。\n\n其次，识别 $\\langle 110 \\rangle$ 滑移方向族。有六个唯一的方向线：\n$[110]$、$[1\\bar{1}0]$、$[101]$、$[10\\bar{1}]$、$[011]$、$[01\\bar{1}]$。这些方向的米勒指数 $[uvw]$ 的长度为 $\\sqrt{u^2+v^2+w^2} = \\sqrt{1^2+1^2+0^2} = \\sqrt{2}$。通过除以 $\\sqrt{2}$ 得到归一化向量 $\\mathbf{s}^{\\alpha}$。\n\n滑移方向必须位于滑移面内，这转化为正交条件 $\\mathbf{s}^{\\alpha} \\cdot \\mathbf{n}^{\\alpha} = 0$。我们对每个平面检查此条件，以找到其相关的滑移方向。让我们列出由 $\\alpha = 1, \\dots, 12$ 索引的十二个滑移系：\n\n滑移面 1：$(111)$，法线与 $[1,1,1]$ 成比例。\n满足 $u+v+w=0$ 的方向 $[uvw]$ 是 $[1\\bar{1}0]$、$[10\\bar{1}]$、$[01\\bar{1}]$ 及其负方向。我们从每个方向线上选择一个。\n1.  $\\alpha=1$: $\\mathbf{n}^{(1)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(1)} = \\frac{1}{\\sqrt{2}}(1,-1,0)$。\n2.  $\\alpha=2$: $\\mathbf{n}^{(2)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(2)} = \\frac{1}{\\sqrt{2}}(1,0,-1)$。\n3.  $\\alpha=3$: $\\mathbf{n}^{(3)} = \\frac{1}{\\sqrt{3}}(1,1,1)$, $\\mathbf{s}^{(3)} = \\frac{1}{\\sqrt{2}}(0,1,-1)$。\n\n滑移面 2：$(1\\bar{1}1)$，法线与 $[1,-1,1]$ 成比例。\n满足 $u-v+w=0$ 的方向 $[uvw]$ 是 $[110]$、$[\\bar{1}01]$、$[011]$。\n4.  $\\alpha=4$: $\\mathbf{n}^{(4)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(4)} = \\frac{1}{\\sqrt{2}}(1,1,0)$。\n5.  $\\alpha=5$: $\\mathbf{n}^{(5)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(5)} = \\frac{1}{\\sqrt{2}}(-1,0,1)$。\n6.  $\\alpha=6$: $\\mathbf{n}^{(6)} = \\frac{1}{\\sqrt{3}}(1,-1,1)$, $\\mathbf{s}^{(6)} = \\frac{1}{\\sqrt{2}}(0,1,1)$。\n\n滑移面 3：$(\\bar{1}11)$，法线与 $[-1,1,1]$ 成比例。\n满足 $-u+v+w=0$ 的方向 $[uvw]$ 是 $[110]$、$[101]$、$[0\\bar{1}1]$。\n7.  $\\alpha=7$: $\\mathbf{n}^{(7)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(7)} = \\frac{1}{\\sqrt{2}}(1,1,0)$。\n8.  $\\alpha=8$: $\\mathbf{n}^{(8)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(8)} = \\frac{1}{\\sqrt{2}}(1,0,1)$。\n9.  $\\alpha=9$: $\\mathbf{n}^{(9)} = \\frac{1}{\\sqrt{3}}(-1,1,1)$, $\\mathbf{s}^{(9)} = \\frac{1}{\\sqrt{2}}(0,-1,1)$。\n\n滑移面 4：$(11\\bar{1})$，法线与 $[1,1,-1]$ 成比例。\n满足 $u+v-w=0$ 的方向 $[uvw]$ 是 $[1\\bar{1}0]$、$[101]$、$[011]$。\n10. $\\alpha=10$: $\\mathbf{n}^{(10)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(10)} = \\frac{1}{\\sqrt{2}}(1,-1,0)$。\n11. $\\alpha=11$: $\\mathbf{n}^{(11)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(11)} = \\frac{1}{\\sqrt{2}}(1,0,1)$。\n12. $\\alpha=12$: $\\mathbf{n}^{(12)} = \\frac{1}{\\sqrt{3}}(1,1,-1)$, $\\mathbf{s}^{(12)} = \\frac{1}{\\sqrt{2}}(0,1,1)$。\n\n这个枚举确认了FCC晶体恰好有12个滑移系。明确列出 $\\alpha = 1, \\dots, 12$ 的向量 $(\\mathbf{n}^{\\alpha}, \\mathbf{s}^{\\alpha})$ 完成了第一个任务。第二个任务，即构建Schmid张量 $\\{\\mathbf{P}^{\\alpha}\\}_{\\alpha=1}^{12}$，通过提供 $\\mathbf{P}^{\\alpha}$ 的公式和每个系的向量分量而隐式完成。\n\n最后，我们计算不变量 $I$。由于我们发现对于所有的 $\\alpha$，$\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}$ 是一个常数，并且我们已经确认有12个这样的滑移系，因此求和变得很简单：\n$$\nI = \\sum_{\\alpha=1}^{12} (\\mathbf{P}^{\\alpha} : \\mathbf{P}^{\\alpha}) = \\sum_{\\alpha=1}^{12} \\frac{1}{2}\n$$\n$$\nI = 12 \\times \\frac{1}{2} = 6\n$$\n不变量的值是 $6$。如要求，它是一个无量纲量。",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "任何晶体塑性有限元（CPFEM）模拟的核心都是“返回映射”算法，它在每个材料点（高斯积分点）上对一个时间步内的塑性流动本构关系进行积分。这个动手编程练习  将挑战您从零开始构建这个核心求解器。您将为一个应变率相关的流动法则实现一个后向欧拉格式，并使用牛顿-拉弗森方法来求解由此产生的非线性方程组，这是计算塑性力学的一块基石。",
            "id": "3748295",
            "problem": "您的任务是实现一个基于晶体塑性有限元法 (CPFEM) 中滑移率的后向欧拉离散化的局部单积分点晶体塑性更新。目标是根据率相关的流动法则对塑性流动进行积分，强制执行类似返回映射的一致性，更新塑性变形梯度同时保持不可压缩性，并验证牛顿迭代的局部收敛性。\n\n该问题的基本基础是变形梯度的乘法分解和标准有限应变弹性理论，并结合率相关的晶体流动法则。请从以下经过充分检验的定义和定律开始：\n\n- 变形梯度 $F$ 可乘法分解为 $F = F_e F_p$，其中 $F_e$ 是弹性变形梯度，$F_p$ 是塑性变形梯度。\n\n- 塑性不可压缩性要求 $J_p = \\det(F_p) = 1$。\n\n- 塑性速度梯度 $L_p$ 由 $N_s$ 个滑移系上的滑移率定义为 $L_p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^\\alpha s^\\alpha \\otimes m^\\alpha$，其中 $s^\\alpha$ 是滑移方向，$m^\\alpha$ 是滑移面法线，两者都在晶体构型中定义，且 $s^\\alpha \\cdot m^\\alpha = 0$。\n\n- 在大小为 $\\Delta t$ 的时间步长上，后向欧拉时间离散化将塑性更新近似为 $F_{p,n+1} \\approx \\left(I + \\Delta t L_{p,n+1}\\right) F_{p,n}$，这可转化为 $F_{p,n+1} \\approx \\left(I + \\sum_{\\alpha=1}^{N_s} \\Delta \\gamma^\\alpha s^\\alpha \\otimes m^\\alpha \\right) F_{p,n}$，其中 $\\Delta \\gamma^\\alpha = \\Delta t \\, \\dot{\\gamma}^\\alpha$ 是滑移增量。\n\n- 为严格强制 $J_p = 1$，在更新后应用体积投影：$F_{p,n+1} \\leftarrow J_{p,n+1}^{-1/3} F_{p,n+1}$，其中 $J_{p,n+1} = \\det(F_{p,n+1})$。\n\n- 弹性变形梯度为 $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$。\n\n- 使用可压缩 Neo-Hookean 弹性响应。定义弹性右 Cauchy-Green 张量 $C_e = F_e^\\top F_e$ 和弹性雅可比 $J_e = \\det(F_e)$。Mandel 应力 $M$ 为 $M = C_e S_e$，其中 Neo-Hookean 弹性的第二 Piola-Kirchhoff 应力为 $S_e = \\mu I - \\mu C_e^{-1} + \\lambda \\ln(J_e) C_e^{-1}$，$\\lambda$ 和 $\\mu$ 是 Lamé 参数，$I$ 是单位张量。对于此模型，Mandel 应力简化为 $M = \\mu \\left(C_e - I\\right) + \\lambda \\ln(J_e) I$。\n\n- 滑移系 $\\alpha$ 上的分解剪应力为 $\\tau^\\alpha = S^\\alpha : M$，其中 $S^\\alpha = \\frac{1}{2} \\left(s^\\alpha \\otimes m^\\alpha + m^\\alpha \\otimes s^\\alpha\\right)$ 是对称 Schmid 张量，$A : B = \\operatorname{tr}(A^\\top B)$ 表示双点积。\n\n- 率相关滑移流动法则为 $\\dot{\\gamma}^\\alpha = \\gamma_0 \\left(\\frac{|\\tau^\\alpha|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha)$，其中 $\\gamma_0$ 是参考滑移率，$\\tau_c^\\alpha$ 是滑移阻力，$n$ 是率敏感性指数。\n\n您的任务是：\n\n- 在单个时间步长内，实现滑移增量 $\\Delta \\gamma^\\alpha$（$\\alpha = 1, \\dots, N_s$）的后向欧拉积分。给定 $F_{p,n} = I$，每个测试用例会指定 $F_{n+1}$。\n\n- 开发一个类似返回映射的算法，求解隐式非线性系统 $\\Delta \\gamma^\\alpha - \\Delta t \\, \\gamma_0 \\left(\\frac{|\\tau^\\alpha(\\Delta \\gamma)|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha(\\Delta \\gamma)) = 0$（对所有 $\\alpha$）。其中 $\\tau^\\alpha$ 通过 $F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$ 依赖于更新后的 $F_{p,n+1}$（因此也依赖于 $\\Delta \\gamma$）。使用牛顿类迭代来强制执行流动法则和一致性。您可以使用残差的有限差分来数值近似牛顿迭代所需的雅可比矩阵。\n\n- 更新 $F_p$ 后，通过上述的体积投影严格强制 $J_p = 1$。\n\n- 验证牛顿迭代的局部收敛性，方法是检查迭代是否在合理的最大步数内收敛，以及残差范数在解附近是否表现出超线性下降。通过计算最后可用的一对迭代的比率 $q_k = \\frac{r_{k+1}}{r_k^2}$ 来量化这一点，其中 $r_k = \\left\\|\\mathbf{R}(\\Delta \\gamma^{(k)})\\right\\|_2$ 是第 $k$ 次迭代的残差范数。如果残差单调递减，且最后的 $q_k$ 是有限的并低于指定的阈值，则声明局部收敛性检查通过。\n\n本问题中所有量均为无量纲形式，没有物理单位。角度（如适用）必须以弧度为单位。\n\n测试套件：\n实现您的程序以处理以下4个测试用例，每个用例包含 $N_s = 2$ 个滑移系：\n- 滑移系定义为 $s^1 = [1, 0, 0]$, $m^1 = [0, 1, 0]$ 和 $s^2 = [0, 1, 0]$, $m^2 = [0, 0, 1]$。所有情况下均使用 $F_{p,n} = I$。取材料参数 $\\lambda = 1$, $\\mu = 1$，流动参数 $\\gamma_0 = 0.01$, $n = 5$，滑移阻力 $\\tau_c^1 = 0.5$, $\\tau_c^2 = 0.5$，以及时间步长 $\\Delta t = 1$。\n\n- 用例1（理想路径）：简单剪切，其中 $F = \\begin{bmatrix} 1  \\gamma  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$，$\\gamma = 0.1$。\n\n- 用例2（边界情况：无剪切）：纯拉伸，其中 $F = \\operatorname{diag}(1.05, 0.95, 1.0)$。\n\n- 用例3（更大剪切）：简单剪切，其中 $F = \\begin{bmatrix} 1  \\gamma  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$，$\\gamma = 0.3$。\n\n- 用例4（纯旋转）：绕 $z$ 轴旋转角度 $\\theta = \\pi/6$ 弧度，其中 $F = R_z(\\theta)$ 定义为 $R_z(\\theta) = \\begin{bmatrix} \\cos(\\theta)  -\\sin(\\theta)  0 \\\\ \\sin(\\theta)  \\cos(\\theta)  0 \\\\ 0  0  1 \\end{bmatrix}$。\n\n答案规格：\n对于每个测试用例，您的程序必须计算：\n- 一个布尔值，指示牛顿迭代是否在最大迭代次数内收敛到容差。\n- 一个浮点数，等于绝对滑移增量之和 $\\sum_{\\alpha=1}^{N_s} |\\Delta \\gamma^\\alpha|$，四舍五入到六位小数。\n- 一个浮点数，等于不可压缩性投影后的 $\\det(F_{p,n+1})$，四舍五入到六位小数。\n- 一个布尔值，指示是否满足如上定义的局部收敛性检查。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含聚合了4个测试用例结果的逗号分隔列表，并用方括号括起来。每个测试用例的结果本身应该是一个列表，按上述顺序排列。例如，输出必须具有形式 $[\\,[c_1, s_1, d_1, \\ell_1], [c_2, s_2, d_2, \\ell_2], [c_3, s_3, d_3, \\ell_3], [c_4, s_4, d_4, \\ell_4]\\,]$，其中 $c_i$ 和 $\\ell_i$ 是布尔值，$s_i$ 和 $d_i$ 是针对用例 $i$ 的四舍五入到六位小数的浮点数。",
            "solution": "用户提供了一个需要实现单点晶体塑性更新算法的问题。我将首先验证问题陈述，然后详细描述求解方法论。\n\n### 问题验证\n\n我已提取出给定的信息、定义和要求如下：\n\n*   **运动学**：变形梯度的乘法分解 $F = F_e F_p$。\n*   **塑性流动**：塑性速度梯度为 $L_p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^\\alpha s^\\alpha \\otimes m^\\alpha$。塑性变形梯度通过后向欧拉格式更新：$F_{p,n+1} \\approx \\left(I + \\sum_{\\alpha=1}^{N_s} \\Delta \\gamma^\\alpha s^\\alpha \\otimes m^\\alpha \\right) F_{p,n}$。\n*   **塑性不可压缩性**：$J_p = \\det(F_p) = 1$ 通过更新后的体积投影严格强制执行：$F_{p,n+1} \\leftarrow J_{p,n+1}^{-1/3} F_{p,n+1}$。\n*   **弹性**：使用可压缩 Neo-Hookean 模型。Mandel 应力由 $M = \\mu \\left(C_e - I\\right) + \\lambda \\ln(J_e) I$ 给出，其中 $C_e = F_e^\\top F_e$ 且 $J_e = \\det(F_e) = \\det(F_{n+1})$。\n*   **流动法则**：滑移率由率相关的幂律法则控制：$\\dot{\\gamma}^\\alpha = \\gamma_0 \\left(\\frac{|\\tau^\\alpha|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha)$，其中 $\\tau^\\alpha$ 是分解剪应力，$\\tau^\\alpha = S^\\alpha : M$，且 $S^\\alpha = \\frac{1}{2} \\left(s^\\alpha \\otimes m^\\alpha + m^\\alpha \\otimes s^\\alpha\\right)$。\n*   **控制方程**：问题的核心是求解滑移增量 $\\Delta \\gamma^\\alpha$ 的非线性系统：$R^\\alpha(\\Delta \\gamma) = \\Delta \\gamma^\\alpha - \\Delta t \\, \\gamma_0 \\left(\\frac{|\\tau^\\alpha(\\Delta \\gamma)|}{\\tau_c^\\alpha}\\right)^n \\operatorname{sign}(\\tau^\\alpha(\\Delta \\gamma)) = 0$，对于 $\\alpha = 1, \\dots, N_s$。\n*   **数值方法**：要求使用一个带有数值近似（有限差分）雅可比矩阵的牛顿类迭代求解器。\n*   **收敛性验证**：必须验证算法收敛性（残差低于容差）和局部收敛速率（残差单调递减，二次收敛因子检查）。\n*   **参数**：为 $N_s = 2$ 个滑移系提供了所有材料、流动和几何参数。指定了总变形梯度 $F_{n+1}$ 的四个不同测试用例，初始条件为 $F_{p,n} = I$。\n*   **输出**：对于每个测试用例，必须计算一个包含四个值的特定列表：牛顿收敛状态、绝对滑移增量之和、最终塑性变形梯度的行列式以及局部收敛速率检查状态。\n\n该问题是 **有效的**。它在科学上基于连续介质力学和计算晶体塑性学的成熟理论。其公式是自洽的，所有必要的方程、参数和边界条件都已明确定义。该任务是客观、适定的，并需要对计算材料科学中的一个标准数值算法进行非平凡的实现。不存在矛盾、歧义或事实性错误。\n\n### 求解设计\n\n该问题需要为滑移增量 $\\Delta \\gamma^\\alpha$ 求解一个非线性方程组。该算法是在单个材料点（积分点）上执行的返回映射过程。未知数是 $N_s$ 个滑移系上各自的滑移增量，我们可以将它们收集成一个向量 $\\Delta\\mathbf{\\gamma} = [\\Delta\\gamma^1, \\dots, \\Delta\\gamma^{N_s}]^\\top$。该方程组由时间离散化的流动法则给出，它构成了残差向量 $\\mathbf{R}(\\Delta\\mathbf{\\gamma})$，其中每个分量为 $R^\\alpha = 0$。\n\n我们将采用 Newton-Raphson 方法来寻找 $\\mathbf{R}(\\Delta\\mathbf{\\gamma}) = \\mathbf{0}$ 的根。迭代更新格式为：\n$$\n\\Delta\\mathbf{\\gamma}^{(k+1)} = \\Delta\\mathbf{\\gamma}^{(k)} - \\left[ \\mathbf{J}_{\\mathbf{R}}^{(k)} \\right]^{-1} \\mathbf{R}(\\Delta\\mathbf{\\gamma}^{(k)})\n$$\n其中 $\\Delta\\mathbf{\\gamma}^{(k)}$ 是第 $k$ 次迭代时的滑移增量向量，$\\mathbf{J}_{\\mathbf{R}}^{(k)}$ 是残差向量关于滑移增量的雅可比矩阵，在 $\\Delta\\mathbf{\\gamma}^{(k)}$ 处求值。雅可比矩阵的分量是 $J_{\\alpha\\beta} = \\frac{\\partial R^\\alpha}{\\partial \\Delta\\gamma^\\beta}$。根据要求，该雅可比矩阵将使用前向有限差分格式进行数值计算：\n$$\n\\frac{\\partial \\mathbf{R}}{\\partial \\Delta\\gamma^\\beta} \\approx \\frac{\\mathbf{R}(\\Delta\\mathbf{\\gamma} + h \\mathbf{e}_\\beta) - \\mathbf{R}(\\Delta\\mathbf{\\gamma})}{h}\n$$\n其中 $h$ 是一个小扰动，$\\mathbf{e}_\\beta$ 是一个标准基向量。\n\n对于每个测试用例，总体算法流程如下：\n\n1.  **初始化**:\n    *   将滑移增量的初始猜测值设为零：$\\Delta\\mathbf{\\gamma}^{(0)} = \\mathbf{0}$。\n    *   设置滑移系数量 $N_s = 2$。\n    *   初始化迭代计数器 $k=0$，并创建一个列表来存储残差范数。\n\n2.  **Newton-Raphson 迭代**：执行以下步骤，直到残差向量的L2范数低于指定容差（例如，$10^{-8}$）或达到最大迭代次数（例如，20）。\n\n    a.  **计算残差 $\\mathbf{R}(\\Delta\\mathbf{\\gamma}^{(k)})$**:\n        i.  根据当前的猜测值 $\\Delta\\mathbf{\\gamma}^{(k)}$，计算试探塑性变形梯度增量：$L_{p,n+1} \\Delta t = \\sum_{\\alpha=1}^{N_s} \\Delta\\gamma^{\\alpha, (k)} s^\\alpha \\otimes m^\\alpha$。\n        ii. 更新塑性变形梯度：$F_{p,n+1}^{\\text{trial}} = (I + L_{p,n+1} \\Delta t) F_{p,n}$。由于 $F_{p,n} = I$，这简化为 $F_{p,n+1}^{\\text{trial}} = I + L_{p,n+1} \\Delta t$。\n        iii. 通过体积投影强制执行塑性不可压缩性。计算 $J_p^{\\text{trial}} = \\det(F_{p,n+1}^{\\text{trial}})$ 并更新 $F_{p,n+1} = (J_p^{\\text{trial}})^{-1/3} F_{p,n+1}^{\\text{trial}}$。这确保了 $\\det(F_{p,n+1}) = 1$。\n        iv. 计算弹性变形梯度：$F_{e,n+1} = F_{n+1} F_{p,n+1}^{-1}$。\n        v.  计算弹性右 Cauchy-Green 张量 $C_{e,n+1} = F_{e,n+1}^\\top F_{e,n+1}$ 和弹性体积变化 $J_e = \\det(F_{e,n+1})$。注意，由于 $\\det(F_{p,n+1}) = 1$，我们有 $J_e = \\det(F_{n+1})$。\n        vi. 计算 Mandel 应力：$M = \\mu (C_{e,n+1} - I) + \\lambda \\ln(J_e) I$。\n        vii. 对于每个滑移系 $\\alpha = 1, \\dots, N_s$，计算分解剪应力 $\\tau^\\alpha = S^\\alpha : M$。\n        viii. 组合残差向量分量 $R^\\alpha = \\Delta\\gamma^{\\alpha, (k)} - \\Delta t \\, \\gamma_0 (|\\tau^\\alpha| / \\tau_c^\\alpha)^n \\operatorname{sign}(\\tau^\\alpha)$。\n\n    b.  **检查收敛性**：计算残差范数 $r_k = \\|\\mathbf{R}\\|_2$。如果 $r_k$ 低于容差，则迭代收敛。\n\n    c.  **计算雅可比矩阵**：如果未收敛，使用上述有限差分法计算 $N_s \\times N_s$ 的雅可比矩阵 $\\mathbf{J}_{\\mathbf{R}}$。每一列需要额外评估一次残差函数。\n\n    d.  **求解与更新**：求解线性系统 $\\mathbf{J}_{\\mathbf{R}} \\, \\delta\\mathbf{\\gamma} = -\\mathbf{R}$ 以获得更新量 $\\delta\\mathbf{\\gamma}$，并更新解：$\\Delta\\mathbf{\\gamma}^{(k+1)} = \\Delta\\mathbf{\\gamma}^{(k)} + \\delta\\mathbf{\\gamma}$。\n\n3.  **后处理和输出生成**:\n    *   循环终止后，检查 `converged` 标志。\n    *   如果收敛，使用收敛的 $\\Delta\\mathbf{\\gamma}$ 计算最终所需的输出：\n        *   计算绝对滑移增量之和：$\\sum_{\\alpha=1}^{N_s} |\\Delta\\gamma^\\alpha|$。\n        *   使用收敛的 $\\Delta\\mathbf{\\gamma}$ 和体积投影对 $F_{p,n+1}$ 进行最终更新，然后计算其行列式。在浮点精度范围内，该值应为 $1.0$。\n        *   执行局部收敛性检查：验证残差范数序列是单调递减的，并且对于最后两次迭代（范数为 $r_{k-1}$ 和 $r_k$），比率 $q = r_k / r_{k-1}^2$ 是有限的并且小于一个合理的阈值（例如 $1000$）。如果在两次或更少次迭代中实现收敛，则该检查视为通过。\n    *   将四个输出值：`[converged, sum_slips, det_Fp, local_conv_ok]` 聚合到当前测试用例的列表中。\n\n最终的实现将封装此逻辑，处理所有四个测试用例，并完全按照指定格式化结果。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef calculate_residual(dgamma_vec, F_n1, F_pn, s_list, m_list, params):\n    \"\"\"\n    Calculates the residual vector for the crystal plasticity update.\n\n    Args:\n        dgamma_vec (np.ndarray): Vector of current trial slip increments [dgamma_1, dgamma_2, ...].\n        F_n1 (np.ndarray): Total deformation gradient at step n+1.\n        F_pn (np.ndarray): Plastic deformation gradient at step n.\n        s_list (list): List of slip direction vectors.\n        m_list (list): List of slip plane normal vectors.\n        params (dict): Dictionary of material and simulation parameters.\n\n    Returns:\n        np.ndarray: The residual vector R(dgamma_vec).\n    \"\"\"\n    lambda_, mu, g0, n, tc_vec, dt = params['lambda_'], params['mu'], params['g0'], params['n'], params['tc_vec'], params['dt']\n    Ns = len(dgamma_vec)\n    \n    # Update trial plastic deformation gradient\n    Lp_times_dt = np.zeros((3, 3))\n    for alpha in range(Ns):\n        Lp_times_dt += dgamma_vec[alpha] * np.outer(s_list[alpha], m_list[alpha])\n    \n    Fp_trial = (np.identity(3) + Lp_times_dt) @ F_pn\n    \n    # Enforce plastic incompressibility via volumetric projection\n    Jp_trial = np.linalg.det(Fp_trial)\n    if abs(Jp_trial)  1e-12:  # Avoid non-physical states\n        return np.full(Ns, 1e12) # Return large residual to steer solver away\n        \n    Fp_n1 = (Jp_trial**(-1.0/3.0)) * Fp_trial\n    \n    # Calculate elastic quantities\n    Fp_n1_inv = np.linalg.inv(Fp_n1)\n    Fe_n1 = F_n1 @ Fp_n1_inv\n    Ce_n1 = Fe_n1.T @ Fe_n1\n    \n    # Since det(Fp_n1) = 1 due to projection, Je = det(F_n1)\n    Je_n1 = np.linalg.det(F_n1)\n    \n    # Calculate Mandel stress\n    M = mu * (Ce_n1 - np.identity(3)) + lambda_ * np.log(Je_n1) * np.identity(3)\n    \n    # Calculate resolved shear stresses and assemble residual vector\n    residual_vec = np.zeros(Ns)\n    for alpha in range(Ns):\n        s_alpha = s_list[alpha]\n        m_alpha = m_list[alpha]\n        Schmid_tensor = 0.5 * (np.outer(s_alpha, m_alpha) + np.outer(m_alpha, s_alpha))\n        tau_alpha = np.sum(Schmid_tensor * M)  # Double contraction\n        \n        flow_term = g0 * (np.abs(tau_alpha) / tc_vec[alpha])**n * np.sign(tau_alpha)\n        residual_vec[alpha] = dgamma_vec[alpha] - dt * flow_term\n        \n    return residual_vec\n\ndef process_case(F_n1, F_pn, s_list, m_list, params):\n    \"\"\"\n    Processes a single test case using a Newton-Raphson solver.\n    \"\"\"\n    Ns = len(s_list)\n    dgamma = np.zeros(Ns)\n    \n    # Newton solver parameters\n    max_iter = 20\n    tolerance = 1e-8\n    fd_step = 1e-7\n    q_threshold = 1000.0 # Threshold for quadratic convergence check\n\n    converged = False\n    residual_norms = []\n\n    for k in range(max_iter):\n        R = calculate_residual(dgamma, F_n1, F_pn, s_list, m_list, params)\n        r_norm = np.linalg.norm(R)\n        residual_norms.append(r_norm)\n\n        if r_norm  tolerance:\n            converged = True\n            break\n            \n        # Compute Jacobian via finite differences\n        Jac = np.zeros((Ns, Ns))\n        for j in range(Ns):\n            dgamma_pert = dgamma.copy()\n            dgamma_pert[j] += fd_step\n            R_pert = calculate_residual(dgamma_pert, F_n1, F_pn, s_list, m_list, params)\n            Jac[:, j] = (R_pert - R) / fd_step\n\n        # Solve linear system and update\n        try:\n            # Check for ill-conditioning\n            if np.linalg.cond(Jac) > 1 / np.finfo(Jac.dtype).eps:\n                break\n            delta_dgamma = np.linalg.solve(Jac, -R)\n            dgamma += delta_dgamma\n        except np.linalg.LinAlgError:\n            break\n            \n    if not converged:\n        return [False, 0.0, 0.0, False]\n\n    # Post-processing for converged solution\n    sum_abs_dgamma = np.sum(np.abs(dgamma))\n\n    # Calculate final Fp and its determinant\n    Lp_times_dt = np.zeros((3, 3))\n    for alpha in range(Ns):\n        Lp_times_dt += dgamma[alpha] * np.outer(s_list[alpha], m_list[alpha])\n    Fp_trial = (np.identity(3) + Lp_times_dt) @ F_pn\n    Jp_trial = np.linalg.det(Fp_trial)\n    Fp_final = (Jp_trial**(-1.0/3.0)) * Fp_trial\n    det_Fp = np.linalg.det(Fp_final)\n\n    # Local convergence check\n    local_conv_check = False\n    num_residuals = len(residual_norms)\n    if num_residuals = 2: # Converged in 0, 1, or 2 steps\n        local_conv_check = True\n    else:\n        is_monotonic = all(residual_norms[i]  residual_norms[i-1] for i in range(1, num_residuals))\n        if is_monotonic:\n            r_k = residual_norms[-1]\n            r_k_minus_1 = residual_norms[-2]\n            if r_k_minus_1 > 1e-15: # Avoid division by zero\n                q_last = r_k / (r_k_minus_1**2)\n                if np.isfinite(q_last) and q_last  q_threshold:\n                    local_conv_check = True\n\n    return [\n        converged, \n        round(sum_abs_dgamma, 6), \n        round(det_Fp, 6), \n        local_conv_check\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to define parameters, test cases, and aggregate results.\n    \"\"\"\n    params = {\n        'lambda_': 1.0,\n        'mu': 1.0,\n        'g0': 0.01,\n        'n': 5.0,\n        'tc_vec': np.array([0.5, 0.5]),\n        'dt': 1.0\n    }\n\n    s1 = np.array([1., 0., 0.])\n    m1 = np.array([0., 1., 0.])\n    s2 = np.array([0., 1., 0.])\n    m2 = np.array([0., 0., 1.])\n    s_list = [s1, s2]\n    m_list = [m1, m2]\n\n    F_pn = np.identity(3)\n\n    # Define test cases\n    gamma1 = 0.1\n    F1 = np.array([[1., gamma1, 0.], [0., 1., 0.], [0., 0., 1.]])\n    \n    F2 = np.diag([1.05, 0.95, 1.0])\n    \n    gamma3 = 0.3\n    F3 = np.array([[1., gamma3, 0.], [0., 1., 0.], [0., 0., 1.]])\n    \n    theta4 = math.pi / 6.0\n    c, s = math.cos(theta4), math.sin(theta4)\n    F4 = np.array([[c, -s, 0.], [s, c, 0.], [0., 0., 1.]])\n\n    test_cases_F = [F1, F2, F3, F4]\n    \n    all_results = []\n    for F_n1 in test_cases_F:\n        result = process_case(F_n1, F_pn, s_list, m_list, params)\n        all_results.append(result)\n\n    case_strings = []\n    for c, s_val, d_val, l in all_results:\n        c_str = str(c).lower()\n        s_str = f\"{s_val:.6f}\"\n        d_str = f\"{d_val:.6f}\"\n        l_str = str(l).lower()\n        case_strings.append(f\"[{c_str},{s_str},{d_str},{l_str}]\")\n\n    final_output = f\"[[{','.join(case_strings)}]]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "为了使隐式有限元求解器能够高效（二次收敛）地收敛，必须正确实施“一致切线”模量，它对应力更新算法进行了精确的线性化。这项高级实践  涉及计算力学中的一个标准验证程序：将解析推导的切线矩阵与通过有限差分法数值计算的切线矩阵进行比较。此举可确保局部本构点求解器能与全局有限元框架正确“通信”。",
            "id": "3748331",
            "problem": "要求您在一个小应变各向异性晶体塑性本构模型中，为单个积分（高斯）点验证算法一致切线算子的正确性。此验证必须通过将解析推导的算法一致切线（记为 $C^{\\text{alg}}$）与数值有限差分近似进行比较来完成。设定为一个具有立方弹性各向异性、多个滑移系和粘塑性流动法则的面心立方晶体。必须对随机晶体取向和随机应力状态进行比较，并为一组指定的测试用例报告结果。\n\n物理和数学框架如下：\n- 使用小应变运动学和单高斯点更新。令应变增量为 $\\Delta \\boldsymbol{\\varepsilon}$，柯西应力为 $\\boldsymbol{\\sigma}$，弹性刚度为 $\\mathbb{C}$。\n- 在晶体坐标系中采用具有常数 $C_{11}$、$C_{12}$、$C_{44}$（单位均为 $\\text{MPa}$）的立方晶体弹性，通过取向旋转张量 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 旋转到试样坐标系中。\n- 使用一组 $12$ 个面心立方滑移系 $\\{\\alpha\\}$，其在晶体坐标系中的滑移面法线为 $\\mathbf{n}^{\\alpha}$，滑移方向为 $\\mathbf{s}^{\\alpha}$，通过 $\\mathbf{R}$ 旋转到试样坐标系。为每个滑移系 $\\alpha$ 定义对称Schmid张量 $\\mathbf{m}^{\\alpha} = \\frac{1}{2}\\left(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha}\\right)$。\n- 分解剪应力为 $\\tau^{\\alpha} = \\mathbf{m}^{\\alpha} : \\boldsymbol{\\sigma}$。\n- 采用形式为 $\\dot{\\gamma}^{\\alpha} = \\gamma_0 \\left(\\frac{|\\tau^{\\alpha}|}{g}\\right)^{n} \\mathrm{sign}(\\tau^{\\alpha})$ 的粘塑性流动法则来描述滑移速率 $\\dot{\\gamma}^{\\alpha}$，其中 $\\gamma_0$ 是参考滑移速率（单位 $\\text{s}^{-1}$），$g$ 是一个恒定的滑移阻力（单位 $\\text{MPa}$），$n$ 是一个率敏感性指数（无量纲）。时间增量为 $\\Delta t$（单位 $\\text{s}$）。\n- 后向欧拉应力更新满足关于 $\\boldsymbol{\\sigma}$ 的非线性方程：\n$$\n\\boldsymbol{\\sigma} - \\mathbb{C} : \\left(\\Delta \\boldsymbol{\\varepsilon} - \\sum_{\\alpha=1}^{12} \\Delta t \\, \\dot{\\gamma}^{\\alpha} \\, \\mathbf{m}^{\\alpha}\\right) = \\mathbf{0}.\n$$\n- 令 $h^{\\alpha} = \\frac{\\partial \\dot{\\gamma}^{\\alpha}}{\\partial \\tau^{\\alpha}}$ 在 $\\boldsymbol{\\sigma}$ 的收敛状态下计算；对于上述流动法则，该导数为 $h^{\\alpha} = \\gamma_0 \\, n \\, g^{-n} |\\tau^{\\alpha}|^{n-1}$，其为非负值，单位为 $\\text{s}^{-1}\\,\\text{MPa}^{-1}$。\n- 定义雅可比矩阵（应力空间中的算法算子）为\n$$\n\\mathbf{J} = \\mathbf{I} + \\mathbb{C} : \\sum_{\\alpha=1}^{12} \\Delta t \\, h^{\\alpha} \\, \\mathbf{m}^{\\alpha} \\otimes \\mathbf{m}^{\\alpha},\n$$\n其中 $\\mathbf{I}$ 是对称张量空间中的四阶单位张量。从 $\\Delta \\boldsymbol{\\varepsilon}$ 到 $\\Delta \\boldsymbol{\\sigma}$ 的算法一致切线映射则为\n$$\nC^{\\text{alg}} = \\mathbf{J}^{-1} : \\mathbb{C}.\n$$\n\n您必须使用Mandel向量表示以数值稳健的方式实现上述模型，以确保对称张量空间中的正交归一性。Mandel映射必须对剪切分量使用$\\sqrt{2}$缩放，并且旋转后的弹性刚度在转换为$6 \\times 6$ Mandel矩阵之前，必须作为四阶张量进行一致的变换。\n\n验证协议：\n1. 对于每个测试用例，使用固定的随机种子生成一个随机取向 $\\mathbf{R}$ 和一个随机初始应力 $\\boldsymbol{\\sigma}_0$（仅用作牛顿迭代的初始猜测值）。\n2. 对于给定的 $\\Delta \\boldsymbol{\\varepsilon}$、$\\Delta t$、$\\gamma_0$、$n$、$g$ 和 $\\mathbb{C}$，通过牛顿迭代求解非线性应力更新，以获得高斯点处的收敛应力 $\\boldsymbol{\\sigma}$。\n3. 使用收敛的 $\\boldsymbol{\\sigma}$ 计算解析的 $C^{\\text{alg}}$。\n4. 通过对 $\\Delta \\boldsymbol{\\varepsilon}$ 的六个独立分量分别进行微小的扰动 $\\delta$（无量纲），为每次扰动重新求解非线性应力更新，并从应力差除以 $\\delta$ 中收集 $C^{\\text{FD}}$ 的列，从而计算数值有限差分切线 $C^{\\text{FD}}$。\n5. 报告相对Frobenius范数误差，\n$$\n\\text{error} = \\frac{\\|C^{\\text{alg}} - C^{\\text{FD}}\\|_F}{\\|C^{\\text{FD}}\\|_F},\n$$\n作为每个测试用例的浮点数。\n\n使用以下物理上一致的参数：\n- 弹性常数（单位 $\\text{MPa}$）：$C_{11} = 168000$, $C_{12} = 121000$, $C_{44} = 75000$。\n- 滑移阻力为 $g$（单位 $\\text{MPa}$），参考速率为 $\\gamma_0$（单位 $\\text{s}^{-1}$），率敏感性指数为 $n$（无量纲），时间增量为 $\\Delta t$（单位 $\\text{s}$）。\n- 应变增量无量纲；应力单位为 $\\text{MPa}$；时间单位为 $\\text{s}$。\n- 有限差分扰动 $\\delta$ 无量纲。\n\n测试套件规范（每一项是一个元组，顺序为 $(\\text{seed},\\Delta t,\\gamma_0,n,g,\\|\\Delta \\boldsymbol{\\varepsilon}\\|,\\delta)$）：\n- 案例1（通用，中等粘塑性）：$(2025, 0.01, 0.001, 20, 80, 1\\times 10^{-4}, 1\\times 10^{-8})$。\n- 案例2（近弹性边界）：$(77, 1\\times 10^{-6}, 0.001, 20, 80, 1\\times 10^{-4}, 1\\times 10^{-8})$。\n- 案例3（更强的粘塑性）：$(314, 0.05, 0.1, 10, 40, 5\\times 10^{-4}, 1\\times 10^{-8})$。\n\n角度单位不直接使用；随机取向必须生成为正常的旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），其中每个结果是相应测试用例的浮点数相对Frobenius范数误差。所有数值输出必须使用一致的单位：应力为 $\\text{MPa}$，应变为无量纲，时间为 $\\text{s}$。",
            "solution": "用户提供了一个有效的问题陈述。它描述了计算晶体塑性领域中一个适定、有科学依据的验证任务。该问题是完整的，明确定义了所有必要的物理参数、本构定律和数值程序。任务是针对一个小应变、粘塑性、各向异性的晶体塑性模型，通过数值有限差分近似来验证算法一致切线模量的解析形式。\n\n解决方案分为以下几个步骤：\n1.  使用Mandel-Voigt记法建立张量的数学表示。\n2.  定义立方弹性和粘塑性滑移的本构关系。\n3.  使用牛顿-拉弗森格式构建隐式应力更新过程。\n4.  从收敛的牛顿-拉弗森雅可比矩阵推导出算法一致切线算子 $C^{\\text{alg}}$。\n5.  详细说明计算近似切线 $C^{\\text{FD}}$ 的数值有限差分程序。\n6.  指定实现细节，包括晶体取向和滑移系的表示。\n\n**1. Mandel-Voigt空间中的张量表示**\n\n为便于数值实现，像应力$\\boldsymbol{\\sigma}$和应变$\\boldsymbol{\\varepsilon}$这样的二阶对称张量被表示为$6 \\times 1$的列向量。具有主、次对称性的四阶张量，如弹性刚度$\\mathbb{C}$，被表示为$6 \\times 6$的矩阵。使用对剪切分量进行$\\sqrt{2}$缩放的Mandel-Voigt映射，以将张量点积保留为向量点积，即$\\boldsymbol{\\sigma} : \\boldsymbol{\\varepsilon} = \\sigma^T \\varepsilon$。\n\n从张量 $\\mathbf{A}$ 到其Mandel向量 $A$ 的映射为：\n$$\nA = [\\mathrm{A}_{11}, \\mathrm{A}_{22}, \\mathrm{A}_{33}, \\sqrt{2}\\mathrm{A}_{23}, \\sqrt{2}\\mathrm{A}_{13}, \\sqrt{2}\\mathrm{A}_{12}]^T\n$$\n逆映射也是唯一定义的。这种表示确保了正交归一基的维持。\n\n**2. 本构框架**\n\n**弹性**：晶体表现出立方弹性各向异性。在晶体的晶体学参考系中，由常数 $C_{11}$、$C_{12}$ 和 $C_{44}$ 给出的 $6 \\times 6$ 弹性刚度矩阵 $C_{\\text{crys}}$ 为：\n$$\nC_{\\text{crys}} =\n\\begin{pmatrix}\nC_{11}  C_{12}  C_{12}  0  0  0 \\\\\nC_{12}  C_{11}  C_{12}  0  0  0 \\\\\nC_{12}  C_{12}  C_{11}  0  0  0 \\\\\n0  0  0  C_{44}  0  0 \\\\\n0  0  0  0  C_{44}  0 \\\\\n0  0  0  0  0  C_{44}\n\\end{pmatrix}\n$$\n晶体取向由一个旋转张量 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 描述，该张量将坐标从晶体坐标系映射到试样（全局）坐标系。试样坐标系中的刚度 $\\mathbb{C}$ 是通过旋转 $\\mathbb{C}_{\\text{crys}}$ 得到的。在 $6 \\times 6$ Mandel矩阵形式中，此旋转执行为：\n$$\nC = T(\\mathbf{R}) \\, C_{\\text{crys}} \\, T(\\mathbf{R})^T\n$$\n其中 $T(\\mathbf{R})$ 是与旋转 $\\mathbf{R}$ 对应的 $6 \\times 6$ 变换矩阵。\n\n**塑性**：塑性变形通过面心立方（FCC）晶格上的一组 $N_s = 12$ 个滑移系的晶体学滑移发生。每个滑移系 $\\alpha$ 由晶体坐标系中的滑移面法线 $\\mathbf{n}^{\\alpha}$ 和滑移方向 $\\mathbf{s}^{\\alpha}$ 定义。塑性速度梯度由所有滑移系的贡献之和给出：$\\mathbf{L}^p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha} \\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha}$。对于小应变，塑性应变率是对称部分：$\\dot{\\boldsymbol{\\varepsilon}}^p = \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha} \\mathbf{m}^{\\alpha}$，其中 $\\mathbf{m}^{\\alpha} = \\frac{1}{2}(\\mathbf{s}^{\\alpha} \\otimes \\mathbf{n}^{\\alpha} + \\mathbf{n}^{\\alpha} \\otimes \\mathbf{s}^{\\alpha})$ 是对称Schmid张量。每个 $\\mathbf{m}^{\\alpha}$ 被转换为一个 $6 \\times 1$ 的Mandel向量 $m^{\\alpha}_{\\text{crys}}$，然后旋转到试样坐标系：$m^{\\alpha} = T(\\mathbf{R}) \\, m^{\\alpha}_{\\text{crys}}$。\n\n滑移速率 $\\dot{\\gamma}^{\\alpha}$ 由一个粘塑性幂律流动法则控制，该法则依赖于分解剪应力 $\\tau^{\\alpha} = \\boldsymbol{\\sigma} : \\mathbf{m}^{\\alpha} = \\sigma^T m^{\\alpha}$：\n$$\n\\dot{\\gamma}^{\\alpha} = \\gamma_0 \\left(\\frac{|\\tau^{\\alpha}|}{g}\\right)^{n} \\mathrm{sign}(\\tau^{\\alpha})\n$$\n这里，$\\gamma_0$ 是参考滑移速率， $g$ 是滑移阻力， $n$ 是率敏感性指数。\n\n**3. 隐式应力更新**\n\n本构模型使用后向欧拉法在一个时间步长 $\\Delta t$ 上积分。给定总应变增量 $\\Delta \\boldsymbol{\\varepsilon}$，该步长末尾的应力 $\\boldsymbol{\\sigma}$ 必须满足非线性方程组：\n$$\n\\mathbf{F}(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\mathbb{C} : \\left( \\Delta \\boldsymbol{\\varepsilon} - \\Delta \\boldsymbol{\\varepsilon}^p(\\boldsymbol{\\sigma}) \\right) = \\mathbf{0}\n$$\n其中 $\\Delta \\boldsymbol{\\varepsilon}^p(\\boldsymbol{\\sigma}) = \\Delta t \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha}(\\boldsymbol{\\sigma}) \\mathbf{m}^{\\alpha}$。在Mandel向量记法中，此残差方程为：\n$$\nF(\\sigma) = \\sigma - C \\left( \\Delta\\varepsilon - \\Delta t \\sum_{\\alpha=1}^{N_s} \\dot{\\gamma}^{\\alpha}(\\sigma) m^{\\alpha} \\right) = 0\n$$\n该方程组使用牛顿-拉弗森法求解 $\\sigma$。在迭代 $k+1$ 次时，应力更新为 $\\sigma_{k+1} = \\sigma_k + \\Delta\\sigma_k$，其中校正量 $\\Delta\\sigma_k$ 通过求解线性系统得到：\n$$\nJ_{\\sigma}(\\sigma_k) \\, \\Delta\\sigma_k = -F(\\sigma_k)\n$$\n雅可比矩阵 $J_{\\sigma}$ 是残差 $F$ 相对于应力 $\\sigma$ 的导数：\n$$\nJ_{\\sigma} = \\frac{\\partial F}{\\partial \\sigma} = I + C : \\left( \\Delta t \\sum_{\\alpha=1}^{N_s} \\frac{\\partial \\dot{\\gamma}^{\\alpha}}{\\partial \\sigma} \\otimes \\mathbf{m}^{\\alpha} \\right) = I + C : \\left( \\Delta t \\sum_{\\alpha=1}^{N_s} \\frac{\\partial \\dot{\\gamma}^{\\alpha}}{\\partial \\tau^{\\alpha}} \\frac{\\partial \\tau^{\\alpha}}{\\partial \\sigma} \\otimes \\mathbf{m}^{\\alpha} \\right)\n$$\n使用 $\\partial \\tau^{\\alpha} / \\partial \\sigma = \\mathbf{m}^{\\alpha}$ 并定义 $h^{\\alpha} = \\partial \\dot{\\gamma}^{\\alpha} / \\partial \\tau^{\\alpha} = \\gamma_0 \\, n \\, g^{-n} |\\tau^{\\alpha}|^{n-1}$，雅可比矩阵变为：\n$$\nJ_{\\sigma} = I + C : \\left( \\Delta t \\sum_{\\alpha=1}^{N_s} h^{\\alpha} \\mathbf{m}^{\\alpha} \\otimes \\mathbf{m}^{\\alpha} \\right)\n$$\n在 $6 \\times 6$ 矩阵形式中：\n$$\nJ_{\\sigma} = I_{6} + \\Delta t \\, C \\left( \\sum_{\\alpha=1}^{N_s} h^{\\alpha} m^{\\alpha} (m^{\\alpha})^T \\right)\n$$\n其中 $I_6$ 是 $6 \\times 6$ 的单位矩阵。\n\n**4. 算法一致切线**\n\n算法一致切线模量 $C^{\\text{alg}}$ 是步末应力 $\\sigma$ 相对于总应变增量 $\\Delta\\varepsilon$ 的导数，即 $C^{\\text{alg}} = d\\sigma/d(\\Delta\\varepsilon)$。通过在收敛状态下对残差方程 $F(\\sigma, \\Delta\\varepsilon) = 0$ 进行微分，我们得到：\n$$\ndF = \\frac{\\partial F}{\\partial \\sigma} : d\\sigma + \\frac{\\partial F}{\\partial (\\Delta\\varepsilon)} : d(\\Delta\\varepsilon) = 0\n$$\n$$\nJ_{\\sigma} : d\\sigma - C : d(\\Delta\\varepsilon) = 0 \\implies d\\sigma = (J_{\\sigma}^{-1} : C) : d(\\Delta\\varepsilon)\n$$\n因此，算法切线为：\n$$\nC^{\\text{alg}} = J_{\\sigma}^{-1} : C\n$$\n在 $6 \\times 6$ 矩阵形式中，这计算为 $C^{\\text{alg}} = (J_{\\sigma})^{-1} C$，其中 $J_{\\sigma}$ 和 $C$ 是在收敛应力状态下计算的矩阵。\n\n**5. 有限差分验证**\n\n为了验证解析切线 $C^{\\text{alg}}$ 的正确性，将其与使用有限差分法计算的数值切线 $C^{\\text{FD}}$ 进行比较。虽然中心差分格式是精确的，但前向差分格式足够且更简单。$C^{\\text{FD}}$ 矩阵的第 $j$ 列通过扰动应变增量 $\\Delta\\varepsilon$ 的第 $j$ 个分量来近似：\n1.  对未扰动的应变增量 $\\Delta\\varepsilon$ 求解应力更新，以找到参考应力 $\\sigma$。\n2.  对于Mandel-Voigt应变向量的每个分量 $j \\in \\{1, \\dots, 6\\}$：\n    a.  定义一个扰动应变增量 $\\Delta\\varepsilon^{\\text{pert}} = \\Delta\\varepsilon + \\delta \\cdot e_j$，其中 $e_j$ 是第 $j$ 个标准基向量，$\\delta$ 是一个小的无量纲扰动值。\n    b.  对 $\\Delta\\varepsilon^{\\text{pert}}$ 求解应力更新，以找到扰动应力 $\\sigma^{\\text{pert}}$。\n    c.  $C^{\\text{FD}}$ 的第 $j$ 列计算如下：\n    $$\n    (C^{\\text{FD}})_{:,j} = \\frac{\\sigma^{\\text{pert}} - \\sigma}{\\delta}\n    $$\n3.  然后通过Frobenius范数中的相对误差来量化解析切线的准确性：\n$$\n\\text{error} = \\frac{\\|C^{\\text{alg}} - C^{\\text{FD}}\\|_F}{\\|C^{\\text{FD}}\\|_F}\n$$\n一个小的误差（接近机器精度或受限于有限差分截断误差）证实了推导和实现的 $C^{\\text{alg}}$ 的正确性。\n\n**6. 实现策略**\n\n实现将遵循上述理论步骤。为每个测试用例设定种子的随机数生成器确保了可复现性。一个函数将通过对高斯分布矩阵进行QR分解来生成随机旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$。FCC滑移系和Mandel变换矩阵 $T(\\mathbf{R})$ 将被预先计算。代码的核心是牛顿-拉弗森求解器，它迭代地找到满足残差方程的应力。然后，该求解器被调用一次以求解未扰动的应变，并为 $6$ 个扰动中的每一个调用一次以构建 $C^{\\text{FD}}$。然后计算最终的误差度量并为每个测试用例报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef get_fcc_slip_systems():\n    \"\"\"\n    Generates the 12 FCC slip systems {111}110>.\n    Returns: A tuple of (normals, directions) as 12x3 numpy arrays.\n    \"\"\"\n    sqrt2 = np.sqrt(2.0)\n    sqrt3 = np.sqrt(3.0)\n    \n    # Define the 12 canonical FCC slip systems\n    # For plane (1,1,1)\n    n1 = [1, 1, 1] / sqrt3\n    s1_1 = [-1, 1, 0] / sqrt2\n    s1_2 = [-1, 0, 1] / sqrt2\n    s1_3 = [0, -1, 1] / sqrt2\n    # For plane (1,1,-1)\n    n2 = [1, 1, -1] / sqrt3\n    s2_1 = [-1, 1, 0] / sqrt2\n    s2_2 = [1, 0, 1] / sqrt2\n    s2_3 = [0, 1, 1] / sqrt2\n    # For plane (1,-1,1)\n    n3 = [1, -1, 1] / sqrt3\n    s3_1 = [1, 1, 0] / sqrt2\n    s3_2 = [-1, 0, 1] / sqrt2\n    s3_3 = [0, 1, 1] / sqrt2\n    # For plane (-1,1,1)\n    n4 = [-1, 1, 1] / sqrt3\n    s4_1 = [1, 1, 0] / sqrt2\n    s4_2 = [1, 0, -1] / sqrt2\n    s4_3 = [0, -1, 1] / sqrt2\n\n    all_n = np.array([n1, n1, n1, n2, n2, n2, n3, n3, n3, n4, n4, n4])\n    all_s = np.array([s1_1, s1_2, s1_3, s2_1, s2_2, s2_3, s3_1, s3_2, s3_3, s4_1, s4_2, s4_3])\n    \n    return all_n, all_s\n\ndef get_mandel_vectors_from_slip_systems(normals, directions):\n    \"\"\"\n    Computes Mandel vectors for Schmid tensors.\n    \"\"\"\n    num_sys = normals.shape[0]\n    m_vecs = np.zeros((6, num_sys))\n    sqrt2 = np.sqrt(2.0)\n    for i in range(num_sys):\n        n = normals[i, :]\n        s = directions[i, :]\n        m_tensor = 0.5 * (np.outer(s, n) + np.outer(n, s))\n        m_vecs[:, i] = [\n            m_tensor[0, 0], m_tensor[1, 1], m_tensor[2, 2],\n            sqrt2 * m_tensor[1, 2], sqrt2 * m_tensor[0, 2], sqrt2 * m_tensor[0, 1]\n        ]\n    return m_vecs\n\ndef get_mandel_rotation_matrix(R):\n    \"\"\"\n    Computes the 6x6 Mandel rotation matrix T from a 3x3 rotation matrix R.\n    \"\"\"\n    T = np.zeros((6, 6))\n    r = R\n    s2 = np.sqrt(2.0)\n\n    T[0,:] = [r[0,0]**2, r[0,1]**2, r[0,2]**2, s2*r[0,1]*r[0,2], s2*r[0,0]*r[0,2], s2*r[0,0]*r[0,1]]\n    T[1,:] = [r[1,0]**2, r[1,1]**2, r[1,2]**2, s2*r[1,1]*r[1,2], s2*r[1,0]*r[1,2], s2*r[1,0]*r[1,1]]\n    T[2,:] = [r[2,0]**2, r[2,1]**2, r[2,2]**2, s2*r[2,1]*r[2,2], s2*r[2,0]*r[2,2], s2*r[2,0]*r[2,1]]\n    T[3,:] = [s2*r[1,0]*r[2,0], s2*r[1,1]*r[2,1], s2*r[1,2]*r[2,2], r[1,1]*r[2,2]+r[1,2]*r[2,1], r[1,0]*r[2,2]+r[1,2]*r[2,0], r[1,0]*r[2,1]+r[1,1]*r[2,0]]\n    T[4,:] = [s2*r[0,0]*r[2,0], s2*r[0,1]*r[2,1], s2*r[0,2]*r[2,2], r[0,1]*r[2,2]+r[0,2]*r[2,1], r[0,0]*r[2,2]+r[0,2]*r[2,0], r[0,0]*r[2,1]+r[0,1]*r[2,0]]\n    T[5,:] = [s2*r[0,0]*r[1,0], s2*r[0,1]*r[1,1], s2*r[0,2]*r[1,2], r[0,1]*r[1,2]+r[0,2]*r[1,1], r[0,0]*r[1,2]+r[0,2]*r[1,0], r[0,0]*r[1,1]+r[0,1]*r[1,0]]\n    \n    return T\n\nclass CrystalPlasticityModel:\n    def __init__(self, C11, C12, C44, dt, gamma0, n, g, m_vecs_sample, C_sample):\n        self.C11 = C11\n        self.C12 = C12\n        self.C44 = C44\n        self.dt = dt\n        self.gamma0 = gamma0\n        self.n = n\n        self.g = g\n        self.m_vecs = m_vecs_sample\n        self.C = C_sample\n        self.I6 = np.eye(6)\n\n    def solve_stress_update(self, delta_eps, sigma_initial_guess):\n        sigma = sigma_initial_guess.copy()\n        \n        max_iter = 100\n        tolerance = 1e-12 * self.C11 * np.linalg.norm(delta_eps)\n        if tolerance  1e-9:\n            tolerance = 1e-9\n\n        for i in range(max_iter):\n            # 1. Calculate resolved shear stress\n            tau = self.m_vecs.T @ sigma\n            \n            # 2. Calculate slip rates\n            tau_abs = np.abs(tau)\n            # Avoid division by zero for g, though g is always > 0\n            # A small epsilon could be added if g could be zero.\n            gamma_dot = self.gamma0 * (tau_abs / self.g)**self.n * np.sign(tau)\n\n            # 3. Calculate residual\n            delta_eps_p = self.dt * (self.m_vecs @ gamma_dot)\n            residual = sigma - self.C @ (delta_eps - delta_eps_p)\n            \n            res_norm = np.linalg.norm(residual)\n            if res_norm  tolerance:\n                return sigma, True\n\n            # 4. Calculate Jacobian\n            # h = d(gamma_dot)/d(tau)\n            # Here n > 1, so it is safe.\n            h = (self.gamma0 * self.n / self.g**self.n) * tau_abs**(self.n - 1)\n            \n            # Sum(h_alpha * m_alpha * m_alpha^T)\n            # Broadcasting (6, 12) * (1, 12) -> (6, 12). Then matmul with (12, 6)\n            sum_term = (self.m_vecs * h[np.newaxis, :]) @ self.m_vecs.T\n            \n            J = self.I6 + self.dt * self.C @ sum_term\n            \n            # 5. Solve for stress increment\n            delta_sigma = np.linalg.solve(J, -residual)\n            \n            # 6. Update stress\n            sigma += delta_sigma\n\n        return sigma, False\n\ndef run_verification_case(seed, dt, gamma0, n, g, norm_delta_eps, delta_pert):\n    # Setup parameters\n    C11, C12, C44 = 168000.0, 121000.0, 75000.0\n    \n    # Reproducibility\n    rng = np.random.default_rng(seed)\n    \n    # Random orientation\n    A = rng.standard_normal((3, 3))\n    Q, _ = qr(A)\n    if np.linalg.det(Q)  0:\n        Q[:, 0] *= -1\n    R_orient = Q\n    \n    # Random strain increment\n    delta_eps_rand = rng.standard_normal(6)\n    delta_eps = delta_eps_rand / np.linalg.norm(delta_eps_rand) * norm_delta_eps\n    \n    # Random initial stress guess\n    sigma0_rand = rng.standard_normal(6)\n    sigma0 = sigma0_rand / np.linalg.norm(sigma0_rand) * g\n    \n    # Crystal frame data\n    C_crys = np.array([\n        [C11, C12, C12, 0, 0, 0],\n        [C12, C11, C12, 0, 0, 0],\n        [C12, C12, C11, 0, 0, 0],\n        [0, 0, 0, C44, 0, 0],\n        [0, 0, 0, 0, C44, 0],\n        [0, 0, 0, 0, 0, C44],\n    ])\n    \n    n_slip, s_slip = get_fcc_slip_systems()\n    m_vecs_crys = get_mandel_vectors_from_slip_systems(n_slip, s_slip)\n\n    # Rotate to sample frame\n    T_mat = get_mandel_rotation_matrix(R_orient)\n    C_sample = T_mat @ C_crys @ T_mat.T\n    m_vecs_sample = T_mat @ m_vecs_crys\n\n    # Instantiate model\n    model = CrystalPlasticityModel(C11, C12, C44, dt, gamma0, n, g, m_vecs_sample, C_sample)\n    \n    # --- Solve for reference stress ---\n    sigma, converged = model.solve_stress_update(delta_eps, sigma0)\n    if not converged:\n        return np.nan # Indicate failure\n\n    # --- Compute analytical tangent C_alg ---\n    tau = m_vecs_sample.T @ sigma\n    tau_abs = np.abs(tau)\n    h = (gamma0 * n / g**n) * tau_abs**(n - 1)\n    sum_term = (m_vecs_sample * h[np.newaxis, :]) @ m_vecs_sample.T\n    J_final = np.eye(6) + dt * C_sample @ sum_term\n    C_alg = np.linalg.inv(J_final) @ C_sample\n\n    # --- Compute finite difference tangent C_fd ---\n    C_fd = np.zeros((6, 6))\n    for j in range(6):\n        delta_eps_pert = delta_eps.copy()\n        delta_eps_pert[j] += delta_pert\n        \n        # Use converged sigma as better initial guess for perturbed solve\n        sigma_pert, converged_pert = model.solve_stress_update(delta_eps_pert, sigma)\n        if not converged_pert:\n            return np.nan\n        \n        C_fd[:, j] = (sigma_pert - sigma) / delta_pert\n        \n    # --- Compute error ---\n    norm_diff = np.linalg.norm(C_alg - C_fd)\n    norm_fd = np.linalg.norm(C_fd)\n    \n    if norm_fd  1e-12:\n        return 0.0 if norm_diff  1e-12 else np.inf\n        \n    return norm_diff / norm_fd\n\ndef solve():\n    # Test suite: (seed, dt, gamma0, n, g, ||delta_eps||, delta_pert)\n    test_cases = [\n        (2025, 0.01, 0.001, 20, 80, 1e-4, 1e-8),\n        (77, 1e-6, 0.001, 20, 80, 1e-4, 1e-8),\n        (314, 0.05, 0.1, 10, 40, 5e-4, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_verification_case(*case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\n# Execute the solution\nsolve()\n```"
        }
    ]
}