{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of multiscale analysis is the ability to derive effective properties from first principles. This first practice provides a fundamental, analytical exercise using the concept of a Representative Volume Element (RVE) in a simple one-dimensional setting . By deriving the effective thermal conductivity for a layered composite, you will directly observe how microstructural geometry dictates macroscopic behavior and uncover the classic harmonic mean rule for transport processes oriented normal to the layers.",
            "id": "3791455",
            "problem": "A Representative Volume Element (RVE) is constructed from a periodic, layered, two-phase medium composed of alternating layers of materials with constant scalar thermal conductivities $k_1$ and $k_2$. Let the layer thicknesses be $l_1$ and $l_2$, respectively, and define the period $L = l_1 + l_2$ and the volume fraction $f = l_1/L \\in (0,1)$. Assume steady-state heat conduction without internal heat sources, and that heat flow is imposed in the direction normal to the layers, so that temperature varies only along the stacking direction $x$. The fine-scale constitutive law is Fourier’s law $q(x) = -k(x)\\,\\frac{dT}{dx}$, where $k(x)$ is piecewise constant, equal to $k_1$ in the subinterval of thickness $l_1$ and $k_2$ in the subinterval of thickness $l_2$ within each period. \n\nAdopt first-order computational homogenization with periodic boundary conditions: write the microtemperature field as $T(x) = \\bar{E}\\,x + \\tilde{T}(x)$, where $\\bar{E}$ is a prescribed constant macroscopic temperature gradient and $\\tilde{T}(x)$ is a periodic fluctuation of period $L$ whose average gradient over one period is zero. The homogenized constitutive relation is defined by $\\bar{q} = -k_{\\mathrm{eff}}\\,\\bar{E}$, where $\\bar{q}$ is the average heat flux over the RVE.\n\nUsing only the foundational ingredients above (Fourier’s law, steady-state balance, periodicity, and the Hill–Mandel macro-homogeneity condition), derive the closed-form expression of the effective conductivity $k_{\\mathrm{eff}}$ in the loading direction as a function of $k_1$, $k_2$, and $f$. Additionally, assess where this $k_{\\mathrm{eff}}$ lies relative to the arithmetic and harmonic means of $k_1$ and $k_2$ weighted by $f$ and $1-f$, and state any conditions for equality. \n\nProvide your final answer as a single closed-form expression for $k_{\\mathrm{eff}}$. No numerical evaluation is required, and no units are needed in the final expression.",
            "solution": "The problem statement is first validated against the required criteria.\n\n**Step 1: Extract Givens**\n-   Medium: Periodic, layered, two-phase composite.\n-   Constituent properties: Constant scalar thermal conductivities $k_1$ and $k_2$.\n-   Geometry: Layer thicknesses $l_1$ and $l_2$; period $L = l_1 + l_2$; volume fraction $f = l_1/L \\in (0,1)$.\n-   Physics: Steady-state heat conduction, no internal heat sources.\n-   Loading: Heat flow is normal to the layers; temperature $T$ varies only along the stacking direction $x$.\n-   Fine-scale law: Fourier’s law, $q(x) = -k(x)\\,\\frac{dT}{dx}$, where $k(x)$ is piecewise constant ($k_1$ for thickness $l_1$, $k_2$ for thickness $l_2$).\n-   Homogenization framework: First-order homogenization with periodic boundary conditions.\n-   Temperature field decomposition: $T(x) = \\bar{E}\\,x + \\tilde{T}(x)$, where $\\bar{E}$ is the constant macroscopic temperature gradient and $\\tilde{T}(x)$ is a periodic fluctuation with period $L$ and zero average gradient.\n-   Homogenized law: $\\bar{q} = -k_{\\mathrm{eff}}\\,\\bar{E}$, where $\\bar{q}$ is the average heat flux.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is a classic and fundamental exercise in the theory of homogenization and mechanics of composite materials. It is based on Fourier's law of heat conduction and standard multiscale analysis principles. It is scientifically sound.\n-   **Well-Posedness**: The problem is well-posed. The combination of the governing differential equation (from steady-state balance), constitutive law, and periodic boundary conditions on the fluctuation field provides sufficient constraints to uniquely determine the effective property $k_{\\mathrm{eff}}$.\n-   **Objectivity**: The problem is stated in precise, objective mathematical and physical terms, with no ambiguity or subjective elements.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A rigorous solution can be constructed from the provided information.\n\n**Derivation of the Effective Conductivity**\n\nThe governing equation for steady-state heat conduction in one dimension without heat sources is derived from the energy balance, which simplifies to $\\frac{d}{dx}q(x) = 0$. This implies that the local heat flux $q(x)$ must be constant throughout the Representative Volume Element (RVE). Let us denote this constant flux as $q_0$, so $q(x) = q_0$.\n\nThe average heat flux, $\\bar{q}$, over the period $L$ is defined as:\n$$ \\bar{q} = \\frac{1}{L} \\int_{0}^{L} q(x) dx $$\nSince $q(x) = q_0$ is constant, the average flux is simply $\\bar{q} = q_0$.\n\nThe local constitutive relation is Fourier's law: $q(x) = -k(x) \\frac{dT}{dx}$. Combining this with the constant flux condition, we can express the local temperature gradient as:\n$$ \\frac{dT}{dx} = -\\frac{q_0}{k(x)} $$\nThe macroscopic temperature gradient, $\\bar{E}$, is defined as the volume average (in this 1D case, a line average) of the microscopic temperature gradient over the RVE:\n$$ \\bar{E} = \\left\\langle \\frac{dT}{dx} \\right\\rangle = \\frac{1}{L} \\int_{0}^{L} \\frac{dT}{dx} dx $$\nSubstituting the expression for the local gradient:\n$$ \\bar{E} = \\frac{1}{L} \\int_{0}^{L} \\left(-\\frac{q_0}{k(x)}\\right) dx = -\\frac{q_0}{L} \\int_{0}^{L} \\frac{1}{k(x)} dx $$\nThe integral is evaluated over the two layers. The first layer has conductivity $k_1$ and extends from $x=0$ to $x=l_1$. The second layer has conductivity $k_2$ and extends from $x=l_1$ to $x=L=l_1+l_2$.\n$$ \\bar{E} = -\\frac{q_0}{L} \\left( \\int_{0}^{l_1} \\frac{1}{k_1} dx + \\int_{l_1}^{L} \\frac{1}{k_2} dx \\right) $$\nSince $k_1$ and $k_2$ are constant within each layer, the integration is straightforward:\n$$ \\bar{E} = -\\frac{q_0}{L} \\left( \\frac{l_1}{k_1} + \\frac{l_2}{k_2} \\right) $$\nWe are given the volume fraction $f = l_1/L$, which implies $l_1 = fL$. Consequently, $l_2 = L - l_1 = L(1-f)$. Substituting these into the expression for $\\bar{E}$:\n$$ \\bar{E} = -\\frac{q_0}{L} \\left( \\frac{fL}{k_1} + \\frac{(1-f)L}{k_2} \\right) = -q_0 \\left( \\frac{f}{k_1} + \\frac{1-f}{k_2} \\right) $$\nThe homogenized constitutive relation is defined as $\\bar{q} = -k_{\\mathrm{eff}} \\bar{E}$. As established, $\\bar{q} = q_0$. Therefore:\n$$ q_0 = -k_{\\mathrm{eff}} \\bar{E} $$\nAssuming a non-trivial temperature gradient exists ($\\bar{E} \\neq 0$), which implies a non-zero heat flux ($q_0 \\neq 0$), we can substitute the expression for $q_0$ into the equation for $\\bar{E}$:\n$$ \\bar{E} = -(-k_{\\mathrm{eff}} \\bar{E}) \\left( \\frac{f}{k_1} + \\frac{1-f}{k_2} \\right) $$\nDividing both sides by $\\bar{E}$ (since $\\bar{E} \\neq 0$):\n$$ 1 = k_{\\mathrm{eff}} \\left( \\frac{f}{k_1} + \\frac{1-f}{k_2} \\right) $$\nSolving for the effective conductivity, $k_{\\mathrm{eff}}$, we find:\n$$ k_{\\mathrm{eff}} = \\left( \\frac{f}{k_1} + \\frac{1-f}{k_2} \\right)^{-1} $$\nThis expression can be written with a common denominator as:\n$$ k_{\\mathrm{eff}} = \\left( \\frac{f k_2 + (1-f) k_1}{k_1 k_2} \\right)^{-1} = \\frac{k_1 k_2}{f k_2 + (1-f) k_1} $$\n\n**Assessment Relative to Weighted Means**\nThe expression for $k_{\\mathrm{eff}}$ is the definition of the weighted harmonic mean of the conductivities $k_1$ and $k_2$, with weights $f$ and $1-f$. Let us denote this by $k_H$:\n$$ k_H(k_1, k_2; f) = \\left( \\frac{f}{k_1} + \\frac{1-f}{k_2} \\right)^{-1} = k_{\\mathrm{eff}} $$\nThe weighted arithmetic mean, denoted $k_A$, is given by:\n$$ k_A(k_1, k_2; f) = f k_1 + (1-f) k_2 $$\nThis corresponds to the effective conductivity for heat flow parallel to the layers. By the arithmetic mean-harmonic mean (AM-HM) inequality, for any set of positive numbers, the arithmetic mean is greater than or equal to the harmonic mean. Specifically, for $k_1, k_2 > 0$ and $f \\in (0,1)$, we have the inequality $k_A \\ge k_H$. This can be proven by observing that $(k_1-k_2)^2 \\ge 0$, which implies $k_1^2 + k_2^2 \\ge 2k_1k_2$. Multiplying by the positive quantity $f(1-f)$ and performing algebraic manipulations leads to the desired result.\n\nTherefore, the derived effective conductivity $k_{\\mathrm{eff}}$ is the weighted harmonic mean, and it is always less than or equal to the weighted arithmetic mean:\n$$ k_{\\mathrm{eff}} \\le f k_1 + (1-f) k_2 $$\nEquality holds if and only if the constituents are identical, i.e., $k_1 = k_2$. In this case, the medium is homogeneous, and $k_{\\mathrm{eff}} = k_1 = k_2$, as expected. Equality also holds in the trivial cases where the medium is composed of a single phase, i.e., $f=0$ or $f=1$, which are excluded by the problem statement $f \\in (0,1)$.",
            "answer": "$$\n\\boxed{\\frac{k_1 k_2}{(1-f) k_1 + f k_2}}\n$$"
        },
        {
            "introduction": "Moving from analytical solutions to computational methods is a key step in tackling more complex, realistic problems. This practice introduces the Heterogeneous Multiscale Method (HMM), a powerful framework for problems where the microstructure, and thus the effective property, varies slowly throughout the domain . You will implement a complete computational homogenization workflow by building a micro-solver to compute the effective diffusivity on-the-fly and coupling it with a macro-scale finite element code.",
            "id": "3791452",
            "problem": "Consider the one-dimensional diffusion equation with rapidly oscillatory microstructure on the domain $[0,1]$ under homogeneous Dirichlet boundary conditions,\n$$\n-\\frac{d}{dx}\\left(K\\left(x,\\frac{x}{\\varepsilon}\\right)\\frac{du}{dx}(x)\\right)=f(x),\\quad u(0)=u(1)=0,\n$$\nwhere the diffusion coefficient is given by the parametrized periodic form\n$$\nK\\left(x,y\\right)=a(x)+b(x)\\sin(2\\pi y),\n$$\nwith $y=\\frac{x}{\\varepsilon}$, $a(x)=a_0+a_1 x$, $b(x)=b_0+b_1 x$, and $a(x)-|b(x)|>0$ for all $x\\in[0,1]$. The goal is to construct a macro-scale solver using the Heterogeneous Multiscale Method (HMM) and to specify how the cell problems are sampled to compute the effective coefficient $K^*$ on each macro element. The sine function $\\sin(\\cdot)$ must use angles in radians.\n\nStarting point for derivations and algorithm design must be the fundamental laws and core definitions underlying diffusion and homogenization, including the flux form of Fick’s law and the conservation law at both scales. The solution must not rely on shortcut formulas provided in the problem statement.\n\nYou must implement the following computational procedure:\n\n- Macro discretization: Partition $[0,1]$ into $N$ uniform elements, with nodes $x_i=\\frac{i}{N}$ for $i=0,1,\\dots,N$. Use linear finite elements to assemble the macro system with piecewise constant coefficient $K^*$ per element.\n\n- Parameter passing via HMM: For each macro element $E=[x_i,x_{i+1}]$, choose the sampling point $x_E=\\frac{x_i+x_{i+1}}{2}$, define the local parameters $a_E=a(x_E)$ and $b_E=b(x_E)$, and solve the periodic one-dimensional micro cell problem on the unit representative volume element $Y=[0,1]$ with periodic boundary conditions to obtain an effective scalar $K^*(x_E)$ representing the average flux generated by a unit imposed macro gradient. The micro cell problem must be sampled on a uniform grid of $M$ points in $Y$. Explicitly, enforce flux conservation across $Y$ and periodicity to compute $K^*(x_E)$ numerically. Use the numerically computed $K^*(x_E)$ to populate the macro element coefficient.\n\n- Macro right-hand side: Use either a constant source $f(x)=1$ or a sinusoidal source $f(x)=\\sin(\\pi x)$ (angles in radians) as specified in the test suite for each case. Assemble the load vector by two-point Gaussian quadrature per element.\n\n- Reference solution: Construct a fine-scale homogenized reference by computing $K^*(x)$ at a fine set of points over $[0,1]$ via the same periodic micro cell problem and solving the variable-coefficient homogenized macro problem on a fine mesh of $N_f$ elements using linear finite elements. This yields $u_{\\text{ref}}(x)$.\n\n- Error metric: Report the normalized $L^2$ error\n$$\n\\mathcal{E}=\\frac{\\left(\\int_0^1 \\left(u_{\\text{HMM}}(x)-u_{\\text{ref}}(x)\\right)^2\\,dx\\right)^{1/2}}{\\left(\\int_0^1 \\left(u_{\\text{ref}}(x)\\right)^2\\,dx\\right)^{1/2}}\n$$\napproximated by the trapezoidal rule over the fine mesh, where $u_{\\text{HMM}}(x)$ is the piecewise linear interpolation of the coarse HMM solution onto the fine grid.\n\nImplement the program to evaluate the following test suite. For each case, compute and return the single normalized $L^2$ error as a floating-point number.\n\nTest suite parameters:\n- Case $1$ (happy path): $a_0=2$, $a_1=0$, $b_0=0.5$, $b_1=0$, $N=20$, $N_f=400$, $M=1000$, $f(x)=1$.\n- Case $2$ (spatially varying amplitude and sinusoidal forcing): $a_0=1.5$, $a_1=0.5$, $b_0=0.4$, $b_1=0.3$, $N=30$, $N_f=600$, $M=1200$, $f(x)=\\sin(\\pi x)$ with angle in radians.\n- Case $3$ (near-constant coefficient edge case): $a_0=2$, $a_1=0$, $b_0=0$, $b_1=0$, $N=10$, $N_f=300$, $M=800$, $f(x)=1$.\n- Case $4$ (coarse macro mesh with strong variation): $a_0=1.5$, $a_1=0.8$, $b_0=0.8$, $b_1=0.6$, $N=6$, $N_f=600$, $M=1000$, $f(x)=1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the four cases in order, for example, $[\\mathcal{E}_1,\\mathcal{E}_2,\\mathcal{E}_3,\\mathcal{E}_4]$.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the theory of homogenization for elliptic partial differential equations, is well-posed, objective, and contains all necessary information for a unique numerical solution. The problem asks for the implementation of the Heterogeneous Multiscale Method (HMM) to solve a one-dimensional diffusion equation with an oscillatory coefficient, and to compare the result against a reference solution obtained from the analytically-derived homogenized equation.\n\nThe core of the problem lies in systematically deriving and an implementing the parameter passing from the fine scale (microstructure) to the coarse scale (macro-model). This will be achieved by first deriving the effective diffusion coefficient $K^*(x)$ and then showing its numerical implementation within the HMM framework.\n\n**1. Theoretical Foundation: Homogenization and the Cell Problem**\n\nThe governing equation is a one-dimensional, steady-state diffusion equation in flux form:\n$$\n-\\frac{d}{dx}\\left(J(x)\\right)=f(x) \\quad \\text{for } x \\in [0,1]\n$$\nwhere the flux $J(x)$ is given by Fick's law with a multiscale diffusion coefficient $K$:\n$$\nJ(x) = -K\\left(x,\\frac{x}{\\varepsilon}\\right)\\frac{du}{dx}(x)\n$$\nThe coefficient $K(x,y) = a(x) + b(x)\\sin(2\\pi y)$ contains two scales: a slow scale $x$ and a fast, periodic scale $y=x/\\varepsilon$, where $\\varepsilon \\ll 1$. The boundary conditions are $u(0)=u(1)=0$.\n\nTo derive the macroscopic behavior, we employ a two-scale asymptotic expansion for the solution $u(x)$:\n$$\nu(x) = u_0(x,y) + \\varepsilon u_1(x,y) + \\varepsilon^2 u_2(x,y) + \\dots\n$$\nwhere each $u_i(x,y)$ is periodic in $y$. The chain rule transforms the spatial derivative: $\\frac{d}{dx} = \\frac{\\partial}{\\partial x} + \\frac{1}{\\varepsilon}\\frac{\\partial}{\\partial y}$. Substituting this into the diffusion equation and grouping terms by powers of $\\varepsilon$ yields a hierarchy of equations.\n\nThe leading order ($\\mathcal{O}(\\varepsilon^{-2})$) term gives:\n$$\n-\\frac{\\partial}{\\partial y}\\left(K(x,y)\\frac{\\partial u_0}{\\partial y}\\right) = 0\n$$\nSince $K(x,y) > 0$, this implies $\\frac{\\partial u_0}{\\partial y} = 0$, meaning the leading-order solution $u_0$ depends only on the macroscopic variable, i.e., $u_0 = u_0(x)$.\n\nThe next order ($\\mathcal{O}(\\varepsilon^{-1})$) term yields the cell problem. After simplification using $\\frac{\\partial u_0}{\\partial y}=0$:\n$$\n-\\frac{\\partial}{\\partial y}\\left(K(x,y)\\left(\\frac{du_0}{dx} + \\frac{\\partial u_1}{\\partial y}\\right)\\right) = 0\n$$\nWe seek a solution for $u_1$ by postulating the ansatz $u_1(x,y) = \\chi(x,y)\\frac{du_0}{dx}(x)$, where $\\chi(x,y)$ is the periodic \"corrector\" function. Substituting this and factoring out $\\frac{du_0}{dx}$ (which is constant with respect to $y$) leads to the local cell problem for $\\chi$ at a given macro-position $x$:\n$$\n-\\frac{\\partial}{\\partial y}\\left(K(x,y)\\left(1 + \\frac{\\partial \\chi}{\\partial y}\\right)\\right) = 0 \\quad \\text{for } y \\in Y = [0,1]\n$$\nwith $\\chi$ being $Y$-periodic. Integrating with respect to $y$ shows that the microscopic flux is constant within the cell:\n$$\nK(x,y)\\left(1 + \\frac{\\partial \\chi}{\\partial y}\\right) = C(x)\n$$\nThe effective macroscopic flux $J^*(x)$ is the average of the microscopic flux over the cell $Y$. The homogenized equation is then $-\\frac{dJ^*}{dx} = f(x)$, where $J^*(x) = -K^*(x)\\frac{du_0}{dx}$. The effective coefficient $K^*(x)$ is defined as the average of the microscopic flux generated by a unit macroscopic gradient. In our derivation, this corresponds to the constant $C(x)$.\n$$\nK^*(x) = \\left\\langle K(x,y)\\left(1 + \\frac{\\partial \\chi}{\\partial y}\\right) \\right\\rangle_Y = \\int_0^1 C(x) dy = C(x)\n$$\nTo find $C(x)$, we rearrange the expression for the corrector's gradient and enforce its periodicity:\n$$\n\\frac{\\partial \\chi}{\\partial y} = \\frac{C(x)}{K(x,y)} - 1\n$$\n$$\n\\int_0^1 \\frac{\\partial \\chi}{\\partial y} dy = \\chi(x,1) - \\chi(x,0) = 0\n$$\nThis gives:\n$$\n\\int_0^1 \\left(\\frac{C(x)}{K(x,y)} - 1\\right) dy = 0 \\implies C(x) \\int_0^1 \\frac{dy}{K(x,y)} = 1\n$$\nFinally, we obtain the expression for the effective coefficient as the harmonic average of the microscopic coefficient over the representative cell:\n$$\nK^*(x) = C(x) = \\left( \\int_0^1 \\frac{dy}{K(x,y)} \\right)^{-1} = \\left( \\int_0^1 \\frac{dy}{a(x)+b(x)\\sin(2\\pi y)} \\right)^{-1}\n$$\n\n**2. Numerical Implementation: The Heterogeneous Multiscale Method**\n\nThe HMM provides a computational framework to solve the macroscopic problem without explicitly knowing the analytical form of $K^*(x)$. It couples a macro-scale solver (here, a Finite Element Method solver) with a micro-scale solver that computes the necessary effective properties on demand.\n\n**Micro-Solver:** For each macro-element $E = [x_i, x_{i+1}]$, we need to compute the effective coefficient $K^*(x_E)$ at the element's sampling point, $x_E = (x_i+x_{i+1})/2$. The integral for $K^*$ is approximated numerically. As specified, we use a uniform grid of $M$ points in the micro-cell $Y=[0,1]$, say $y_j=j/M$ for $j=0, \\dots, M-1$. The integral is approximated by a Riemann sum (which is equivalent to the trapezoidal rule for a periodic function over its period):\n$$\n\\int_0^1 \\frac{dy}{K(x_E, y)} \\approx \\frac{1}{M}\\sum_{j=0}^{M-1} \\frac{1}{K(x_E, y_j)} = \\frac{1}{M}\\sum_{j=0}^{M-1} \\frac{1}{a(x_E)+b(x_E)\\sin(2\\pi y_j)}\n$$\nThus, the numerically computed effective coefficient for the macro-element $E$ is:\n$$\nK^*_E \\equiv K^*(x_E) \\approx \\left( \\frac{1}{M}\\sum_{j=0}^{M-1} \\frac{1}{a(x_E)+b(x_E)\\sin(2\\pi y_j)} \\right)^{-1}\n$$\n\n**Macro-Solver (Finite Element Method):** We solve the homogenized equation $-\\frac{d}{dx}(K^*(x)\\frac{du}{dx}) = f(x)$ using linear finite elements on a uniform mesh of $N$ elements. The weak form is to find $u \\in H_0^1([0,1])$ such that for all test functions $v \\in H_0^1([0,1])$:\n$$\n\\int_0^1 K^*(x) u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx\n$$\nDiscretizing with the standard linear (hat) basis functions $\\phi_i(x)$ yields a linear system $A U = F$. The stiffness matrix $A$ and load vector $F$ are assembled element-wise. For an element $E_j = [x_j, x_{j+1}]$ of length $h$, the local stiffness matrix $A^{(j)}$ is:\n$$\nA^{(j)} \\approx \\frac{K^*_j}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nwhere $K^*_j$ is the effective coefficient for element $E_j$, computed by the micro-solver. For the HMM solver, $K^*_j = K^*(x_{j+1/2})$ on the coarse grid. For the reference solution, $K^*_j$ is computed at the midpoint of each fine grid element.\n\nThe local load vector $F^{(j)}$ is assembled using two-point Gaussian quadrature on each element, as specified:\n$$\nF^{(j)}_k = \\int_{E_j} f(x) \\phi_k(x) dx \\approx \\frac{h}{2} \\sum_{q=1}^2 w_q f(x(\\xi_q)) N_k(\\xi_q)\n$$\nwhere $\\xi_q \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$ are the quadrature points, $w_q=1$ are the weights, $x(\\xi)$ maps from $[-1,1]$ to $E_j$, and $N_k(\\xi)$ are the local linear shape functions. After assembly, the system is solved for the interior nodal values of the solution vector $U$.\n\n**3. Reference Solution and Error Metric**\n\nA fine-scale reference solution $u_{\\text{ref}}$ is generated by solving the same homogenized problem on a fine mesh of $N_f$ elements. The coefficient $K^*(x)$ is evaluated at the midpoint of each fine element using the same numerical micro-solver. This provides a high-resolution approximation of the true homogenized solution.\n\nThe HMM solution $u_{\\text{HMM}}$, defined on the coarse mesh, is interpolated piecewise linearly onto the fine mesh nodes. The relative $L^2$ error is then computed by approximating the integrals via the trapezoidal rule on the fine grid:\n$$\n\\mathcal{E}=\\frac{\\|u_{\\text{HMM}} - u_{\\text{ref}}\\|_{L^2}}{\\|u_{\\text{ref}}\\|_{L^2}} = \\left(\\frac{\\int_0^1 (u_{\\text{HMM}}(x)-u_{\\text{ref}}(x))^2 dx}{\\int_0^1 u_{\\text{ref}}(x)^2 dx}\\right)^{1/2} \\approx \\left(\\frac{\\text{trapz}((u_{\\text{HMM}}^{\\text{fine}} - u_{\\text{ref}})^2, x_{\\text{fine}})}{\\text{trapz}(u_{\\text{ref}}^2, x_{\\text{fine}})}\\right)^{1/2}\n$$\nwhere $u_{\\text{HMM}}^{\\text{fine}}$ denotes the vector of HMM solution values at the fine grid nodes, and $u_{\\text{ref}}$ is the reference solution vector.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the HMM simulation for the given test cases.\n    \"\"\"\n    # Test suite parameters:\n    # (a0, a1, b0, b1, N, Nf, M, f_type)\n    # f_type 'const' for f(x)=1, 'sin' for f(x)=sin(pi*x)\n    test_cases = [\n        (2.0, 0.0, 0.5, 0.0, 20, 400, 1000, 'const'),\n        (1.5, 0.5, 0.4, 0.3, 30, 600, 1200, 'sin'),\n        (2.0, 0.0, 0.0, 0.0, 10, 300, 800, 'const'),\n        (1.5, 0.8, 0.8, 0.6, 6, 600, 1000, 'const'),\n    ]\n\n    results = []\n    for case in test_cases:\n        a0, a1, b0, b1, N, Nf, M, f_type = case\n\n        # Define coefficient and forcing functions\n        a = lambda x: a0 + a1 * x\n        b = lambda x: b0 + b1 * x\n        if f_type == 'const':\n            f = lambda x: np.ones_like(x) if isinstance(x, np.ndarray) else 1.0\n        else: # 'sin'\n            f = lambda x: np.sin(np.pi * x)\n\n        # Micro-solver to compute effective coefficient K*\n        y_micro = np.linspace(0, 1, M, endpoint=False) # y in [0, 1)\n        two_pi_y = 2 * np.pi * y_micro\n        \n        memo_k_star = {}\n        def compute_k_star(x_macro):\n            if x_macro in memo_k_star:\n                return memo_k_star[x_macro]\n            \n            a_val = a(x_macro)\n            b_val = b(x_macro)\n            \n            # Constraint check a(x) - |b(x)| > 0\n            if a_val <= np.abs(b_val):\n                raise ValueError(\"Positivity constraint a(x) > |b(x)| violated.\")\n\n            integrand = 1.0 / (a_val + b_val * np.sin(two_pi_y))\n            # Integral approximated by mean over periodic cell\n            integral_val = np.mean(integrand)\n            \n            k_star = 1.0 / integral_val\n            memo_k_star[x_macro] = k_star\n            return k_star\n\n        # Generic 1D FEM solver\n        def fem_solve(N_elem, k_func, f_func):\n            nodes = np.linspace(0, 1, N_elem + 1)\n            h = 1.0 / N_elem\n            \n            # Stiffness matrix and load vector\n            A = np.zeros((N_elem + 1, N_elem + 1))\n            F = np.zeros(N_elem + 1)\n            \n            # Gaussian quadrature points and weights for [-1, 1]\n            xi_q = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n            w_q = np.array([1.0, 1.0])\n            \n            # Shape functions on reference element [-1, 1]\n            N1_xi = lambda xi: 0.5 * (1.0 - xi)\n            N2_xi = lambda xi: 0.5 * (1.0 + xi)\n\n            # Element-wise assembly\n            for j in range(N_elem):\n                x_j, x_j1 = nodes[j], nodes[j+1]\n                x_mid = (x_j + x_j1) / 2.0\n                \n                # Element stiffness\n                k_e = k_func(x_mid)\n                A_e = (k_e / h) * np.array([[1, -1], [-1, 1]])\n                \n                # Assemble stiffness\n                A[j:j+2, j:j+2] += A_e\n\n                # Element load vector (Gaussian quadrature)\n                x_q = x_j + (h / 2.0) * (1.0 + xi_q)\n                f_vals_q = f_func(x_q)\n                \n                F_e1 = (h / 2.0) * np.sum(w_q * f_vals_q * N1_xi(xi_q))\n                F_e2 = (h / 2.0) * np.sum(w_q * f_vals_q * N2_xi(xi_q))\n                \n                # Assemble load\n                F[j] += F_e1\n                F[j+1] += F_e2\n\n            # Apply Dirichlet boundary conditions u(0)=u(1)=0\n            A_int = A[1:-1, 1:-1]\n            F_int = F[1:-1]\n            \n            U_int = np.linalg.solve(A_int, F_int)\n            \n            U = np.zeros(N_elem + 1)\n            U[1:-1] = U_int\n            \n            return U\n\n        # --- HMM Solution (Coarse Grid) ---\n        k_func_hmm = compute_k_star\n        U_hmm = fem_solve(N, k_func_hmm, f)\n        x_coarse = np.linspace(0, 1, N + 1)\n        \n        # --- Reference Solution (Fine Grid) ---\n        k_func_ref = compute_k_star\n        U_ref = fem_solve(Nf, k_func_ref, f)\n        x_fine = np.linspace(0, 1, Nf + 1)\n\n        # --- Error Calculation ---\n        # Interpolate HMM solution onto the fine grid\n        U_hmm_fine = np.interp(x_fine, x_coarse, U_hmm)\n        \n        # Calculate L2 norms using the trapezoidal rule\n        diff_sq = (U_hmm_fine - U_ref)**2\n        ref_sq = U_ref**2\n        \n        norm_diff_sq = np.trapz(diff_sq, x=x_fine)\n        norm_ref_sq = np.trapz(ref_sq, x=x_fine)\n        \n        if norm_ref_sq == 0:\n            error = 0.0 if norm_diff_sq == 0 else np.inf\n        else:\n            error = np.sqrt(norm_diff_sq / norm_ref_sq)\n        \n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The final practice escalates the complexity to nonlinear material behavior, a ubiquitous challenge in engineering and materials science. This exercise delves into the concurrent multiscale method known as FE$^2$ (Finite Element to the second power) and the crucial concept of the *consistent algorithmic tangent* required for implicit solvers . By deriving this tangent for a 1D elastoplastic model, you will understand why accurately passing not just an effective parameter, but also its derivative, from the fine scale to the coarse scale is essential for achieving robust and rapid convergence in nonlinear simulations.",
            "id": "3791499",
            "problem": "You are asked to derive and implement the consistent algorithmic tangent that must be passed from a micro-scale Representative Volume Element (RVE) to the macro-scale in a two-scale finite element method (Finite Element to the second power (FE$^2$)) for small-strain elastoplasticity. The consistent algorithmic tangent is the derivative of the homogenized stress with respect to the macro strain that is consistent with the chosen stress update algorithm at the micro-level. This tangent must be passed from the fine scale (micro) to the coarse scale (macro) to ensure quadratic convergence of the macro-scale Newton iterations.\n\nThe derivation must start from the following fundamental base:\n- Balance laws and small-strain kinematics: $\\boldsymbol{\\varepsilon} = \\frac{1}{2} \\left( \\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\top} \\right)$.\n- Linear elastic law: $\\boldsymbol{\\sigma} = \\mathbb{C} : (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}^{p})$, where $\\mathbb{C}$ is the fourth-order elastic modulus tensor, $\\boldsymbol{\\varepsilon}$ is the total strain, and $\\boldsymbol{\\varepsilon}^{p}$ is the plastic strain.\n- Von Mises ($J_{2}$) yield function with linear isotropic hardening: $f(\\boldsymbol{\\sigma}, \\alpha) = q(\\boldsymbol{\\sigma}) - \\sigma_{y}(\\alpha)$, where $q(\\boldsymbol{\\sigma}) = \\sqrt{\\frac{3}{2}} \\lVert \\boldsymbol{s} \\rVert$, $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3} \\text{tr}(\\boldsymbol{\\sigma}) \\boldsymbol{I}$, $\\sigma_{y}(\\alpha) = \\sigma_{y0} + H \\alpha$, $\\sigma_{y0}$ is the initial yield stress, $H$ is the hardening modulus, and $\\alpha$ is the accumulated equivalent plastic strain.\n- Kuhn-Tucker conditions and consistency for associative plasticity: $\\gamma \\ge 0$, $f \\le 0$, $\\gamma f = 0$, and the plastic flow $\\dot{\\boldsymbol{\\varepsilon}}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$.\n\nTo make the implementation universally applicable in a single program and to produce scalar outputs suitable for automated testing, consider the one-dimensional specialization (a scalar RVE) with total strain $\\varepsilon$, stress $\\sigma$, elastic modulus $E$, plastic strain $\\varepsilon^{p}$, accumulated plastic strain $\\alpha$, and linear isotropic hardening $H$:\n- One-dimensional stress update: $\\sigma = E (\\varepsilon - \\varepsilon^{p})$.\n- One-dimensional yield function: $f(\\sigma, \\alpha) = \\lvert \\sigma \\rvert - (\\sigma_{y0} + H \\alpha)$.\n- One-dimensional associative flow: $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\gamma \\, \\text{sign}(\\sigma_{\\text{trial}})$ and $\\alpha_{n+1} = \\alpha_{n} + \\lvert \\Delta \\gamma \\rvert$, where $\\Delta \\gamma \\ge 0$ is the plastic multiplier increment and $\\sigma_{\\text{trial}} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$ is the elastic predictor.\n\nYour tasks:\n1. Derive, from the above foundational base without introducing shortcut formulas, the consistent algorithmic tangent $C_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$ for the one-dimensional RVE stress update algorithm that uses a return-mapping scheme with linear isotropic hardening. Show the elastic and plastic branches and the dependence on the material parameters $E$ and $H$.\n2. Explain how passing $C_{\\text{alg}}$ from the fine scale to the coarse scale in FE$^{2}$ ensures quadratic convergence of the macro-scale Newton iterations. Your explanation should start from the macro-scale residual $R(\\boldsymbol{u})$ and its Newton linearization, and argue why using the algorithmically consistent tangent from the micro-scale yields the exact Jacobian of the discretized residual.\n3. Implement a program that, for a given test suite of parameter values, computes and outputs the one-dimensional consistent algorithmic tangent in gigapascals (GPa) as floating-point numbers.\n\nUse the following test suite. For each case, assume the previous plastic strain and accumulated plastic strain are zero, i.e., $\\varepsilon^{p}_{n} = 0$ and $\\alpha_{n} = 0$:\n- Case 1 (elastic, small strain): $E = 210 \\times 10^{9} \\, \\text{Pa}$, $H = 1 \\times 10^{9} \\, \\text{Pa}$, $\\sigma_{y0} = 400 \\times 10^{6} \\, \\text{Pa}$, $\\varepsilon_{n+1} = 1 \\times 10^{-6}$.\n- Case 2 (at yield boundary): $E = 210 \\times 10^{9} \\, \\text{Pa}$, $H = 1 \\times 10^{9} \\, \\text{Pa}$, $\\sigma_{y0} = 400 \\times 10^{6} \\, \\text{Pa}$, $\\varepsilon_{n+1} = \\sigma_{y0} / E$.\n- Case 3 (plastic, tensile): $E = 210 \\times 10^{9} \\, \\text{Pa}$, $H = 1 \\times 10^{9} \\, \\text{Pa}$, $\\sigma_{y0} = 400 \\times 10^{6} \\, \\text{Pa}$, $\\varepsilon_{n+1} = 3 \\times 10^{-3}$.\n- Case 4 (plastic, compressive): $E = 210 \\times 10^{9} \\, \\text{Pa}$, $H = 1 \\times 10^{9} \\, \\text{Pa}$, $\\sigma_{y0} = 400 \\times 10^{6} \\, \\text{Pa}$, $\\varepsilon_{n+1} = -3 \\times 10^{-3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in gigapascals (GPa), with each entry being a floating-point number. For example: $[x_1,x_2,x_3,x_4]$.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in continuum mechanics and computational plasticity, well-posed with sufficient and consistent data, and objective in its formulation. The tasks are clearly defined and formalizable within the specified theoretical framework.\n\nThis solution is presented in two parts as requested: first, the derivation of the one-dimensional consistent algorithmic tangent for a return-mapping scheme with linear isotropic hardening; second, an explanation of its role in ensuring quadratic convergence in a two-scale finite element (FE$^2$) analysis.\n\n**1. Derivation of the Consistent Algorithmic Tangent ($C_{\\text{alg}}$) in One Dimension**\n\nWe are tasked with deriving the consistent algorithmic tangent, defined as $C_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$, for a one-dimensional elastoplastic model. The state at a time step $n$ is described by the plastic strain $\\varepsilon^p_n$ and the accumulated equivalent plastic strain $\\alpha_n$. The material is subjected to a new total strain $\\varepsilon_{n+1}$ at step $n+1$. The material properties are the Young's modulus $E$, the initial yield stress $\\sigma_{y0}$, and the linear hardening modulus $H$.\n\nThe stress update follows a standard predictor-corrector scheme (return mapping).\n\n**Step 1: Elastic Predictor**\n\nFirst, we compute an elastic trial stress, $\\sigma_{\\text{trial}}$, assuming the entire strain increment from step $n$ to $n+1$ is elastic.\n$$\n\\sigma_{\\text{trial}} = E (\\varepsilon_{n+1} - \\varepsilon^p_n)\n$$\nThe problem specifies that the material starts from an undeformed state, so we take $\\varepsilon^p_n = 0$ and $\\alpha_n = 0$. Thus,\n$$\n\\sigma_{\\text{trial}} = E \\varepsilon_{n+1}\n$$\n\n**Step 2: Yield Criterion Check**\n\nNext, we check if this trial stress violates the yield condition. The yield function is $f(\\sigma, \\alpha) = \\lvert \\sigma \\rvert - (\\sigma_{y0} + H \\alpha)$. We evaluate this at the trial state:\n$$\nf_{\\text{trial}} = f(\\sigma_{\\text{trial}}, \\alpha_n) = \\lvert \\sigma_{\\text{trial}} \\rvert - (\\sigma_{y0} + H\\alpha_n)\n$$\nGiven $\\alpha_n=0$, the yield condition becomes:\n$$\nf_{\\text{trial}} = \\lvert E \\varepsilon_{n+1} \\rvert - \\sigma_{y0}\n$$\nTwo mutually exclusive cases arise.\n\n**Case A: Elastic Response ($f_{\\text{trial}} \\le 0$)**\n\nIf the trial yield function is non-positive, the trial state is admissible. The material response is purely elastic. No plastic flow occurs, so the plastic multiplier increment $\\Delta\\gamma = 0$. Consequently, the internal state variables do not change:\n$$\n\\varepsilon^p_{n+1} = \\varepsilon^p_n\n$$\n$$\n\\alpha_{n+1} = \\alpha_n\n$$\nThe final stress at step $n+1$ is simply the trial stress:\n$$\n\\sigma_{n+1} = \\sigma_{\\text{trial}} = E (\\varepsilon_{n+1} - \\varepsilon^p_n)\n$$\nThe consistent algorithmic tangent is the derivative of this final stress with respect to the new total strain $\\varepsilon_{n+1}$:\n$$\nC_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial}{\\partial \\varepsilon_{n+1}} [E (\\varepsilon_{n+1} - \\varepsilon^p_n)] = E\n$$\nIn the elastic regime, the consistent tangent is the elastic modulus $E$.\n\n**Case B: Plastic Response ($f_{\\text{trial}} > 0$)**\n\nIf the trial yield function is positive, the trial state is inadmissible and plastic deformation occurs. The final state $(\\sigma_{n+1}, \\alpha_{n+1})$ must lie on the updated yield surface. This is enforced by the discrete consistency condition $f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$. The state variables are updated according to the associative flow rule:\n$$\n\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\gamma \\, \\text{sign}(\\sigma_{\\text{trial}})\n$$\n$$\n\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma\n$$\nwhere $\\Delta\\gamma > 0$ is the plastic multiplier increment. The final stress is given by the elastic law using the updated plastic strain:\n$$\n\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1}) = E (\\varepsilon_{n+1} - (\\varepsilon^p_n + \\Delta\\gamma \\, \\text{sign}(\\sigma_{\\text{trial}})))\n$$\nRearranging this, we can relate the final stress to the trial stress:\n$$\n\\sigma_{n+1} = [E (\\varepsilon_{n+1} - \\varepsilon^p_n)] - E \\Delta\\gamma \\, \\text{sign}(\\sigma_{\\text{trial}}) = \\sigma_{\\text{trial}} - E \\Delta\\gamma \\, \\text{sign}(\\sigma_{\\text{trial}})\n$$\nThis equation describes the \"return\" of the stress from the trial state back towards the yield surface. The final state must satisfy consistency:\n$$\n|\\sigma_{n+1}| - (\\sigma_{y0} + H \\alpha_{n+1}) = 0\n$$\nSubstituting the update rules for $\\sigma_{n+1}$ and $\\alpha_{n+1}$ into the consistency condition, and noting that for this return path $\\text{sign}(\\sigma_{n+1}) = \\text{sign}(\\sigma_{\\text{trial}})$, we have:\n$$\n|\\sigma_{\\text{trial}} - E \\Delta\\gamma \\, \\text{sign}(\\sigma_{\\text{trial}})| - (\\sigma_{y0} + H (\\alpha_n + \\Delta\\gamma)) = 0\n$$\n$$\n|\\sigma_{\\text{trial}}| - E \\Delta\\gamma - (\\sigma_{y0} + H \\alpha_n) - H \\Delta\\gamma = 0\n$$\nWe can now solve for the unknown plastic multiplier $\\Delta\\gamma$:\n$$\n|\\sigma_{\\text{trial}}| - (\\sigma_{y0} + H \\alpha_n) = (E + H) \\Delta\\gamma\n$$\nThe left-hand side is the trial yield function, $f_{\\text{trial}}$.\n$$\n\\Delta\\gamma = \\frac{f_{\\text{trial}}}{E+H} = \\frac{|\\sigma_{\\text{trial}}| - (\\sigma_{y0} + H \\alpha_n)}{E+H}\n$$\nNow we find the explicit expression for $\\sigma_{n+1}$ as a function of the input strain $\\varepsilon_{n+1}$. We substitute $\\Delta\\gamma$ back into the expression for $\\sigma_{n+1}$:\n$$\n\\sigma_{n+1} = \\sigma_{\\text{trial}} - E \\left( \\frac{|\\sigma_{\\text{trial}}| - (\\sigma_{y0} + H\\alpha_n)}{E+H} \\right) \\text{sign}(\\sigma_{\\text{trial}})\n$$\nSince $\\sigma_{\\text{trial}} = E(\\varepsilon_{n+1} - \\varepsilon^p_n)$, it is a direct function of $\\varepsilon_{n+1}$. We can now differentiate $\\sigma_{n+1}$ with respect to $\\varepsilon_{n+1}$ to find the consistent algorithmic tangent. During a plastic loading step, $\\text{sign}(\\sigma_{\\text{trial}})$ is constant with respect to infinitesimal changes in $\\varepsilon_{n+1}$. Let's rearrange the expression for $\\sigma_{n+1}$ by collecting terms with $\\sigma_{\\text{trial}}$:\n$$\n\\sigma_{n+1} = \\sigma_{\\text{trial}} \\left( 1 - \\frac{E}{E+H} \\right) + \\frac{E(\\sigma_{y0} + H\\alpha_n)}{E+H} \\text{sign}(\\sigma_{\\text{trial}})\n$$\n$$\n\\sigma_{n+1} = \\frac{H}{E+H} \\sigma_{\\text{trial}} + \\frac{E(\\sigma_{y0} + H\\alpha_n)}{E+H} \\text{sign}(\\sigma_{\\text{trial}})\n$$\nThe second term is constant with respect to an infinitesimal change in $\\varepsilon_{n+1}$ (since $\\alpha_n$ is from the previous step and $\\text{sign}(\\sigma_{\\text{trial}})$ does not change). Thus, differentiating with respect to $\\varepsilon_{n+1}$:\n$$\nC_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{H}{E+H} \\frac{\\partial \\sigma_{\\text{trial}}}{\\partial \\varepsilon_{n+1}} = \\frac{H}{E+H} E\n$$\n$$\nC_{\\text{alg}} = \\frac{E H}{E+H}\n$$\nThis is the one-dimensional elastoplastic tangent modulus.\n\n**Summary of $C_{\\text{alg}}$**\nThe consistent algorithmic tangent depends on whether the material response is elastic or plastic:\n- If $|E(\\varepsilon_{n+1} - \\varepsilon^p_n)| \\le \\sigma_{y0} + H\\alpha_n$: $C_{\\text{alg}} = E$\n- If $|E(\\varepsilon_{n+1} - \\varepsilon^p_n)| > \\sigma_{y0} + H\\alpha_n$: $C_{\\text{alg}} = \\frac{EH}{E+H}$\n\n**2. Role of the Consistent Tangent in FE$^2$ for Quadratic Convergence**\n\nThe FE$^2$ method is a hierarchical multiscale scheme for solving boundary value problems on a macroscopic domain whose material behavior is determined by the response of a microscopic Representative Volume Element (RVE) at each point.\n\nThe macroscopic problem is discretized using the Finite Element Method, leading to a system of nonlinear algebraic equations for the global vector of unknown nodal displacements $\\boldsymbol{d}$:\n$$\n\\boldsymbol{R}(\\boldsymbol{d}) = \\boldsymbol{F}_{\\text{ext}} - \\boldsymbol{F}_{\\text{int}}(\\boldsymbol{d}) = \\boldsymbol{0}\n$$\nwhere $\\boldsymbol{R}$ is the residual vector, $\\boldsymbol{F}_{\\text{ext}}$ is the external force vector, and $\\boldsymbol{F}_{\\text{int}}$ is the internal force vector. The internal forces depend on the macroscopic stress field $\\boldsymbol{\\Sigma}$, which is assembled from the values at each macroscopic quadrature point.\n\nThis nonlinear system is solved using the Newton-Raphson iterative method. For an iteration $k$, the update $\\Delta \\boldsymbol{d}$ is found by solving the linear system:\n$$\n\\boldsymbol{K}_T^{(k)} \\Delta \\boldsymbol{d}^{(k)} = -\\boldsymbol{R}(\\boldsymbol{d}^{(k)})\n$$\nwhere $\\boldsymbol{K}_T$ is the global tangent stiffness matrix, which is the Jacobian of the residual vector:\n$$\n\\boldsymbol{K}_T = \\frac{\\partial \\boldsymbol{R}}{\\partial \\boldsymbol{d}} = -\\frac{\\partial \\boldsymbol{F}_{\\text{int}}}{\\partial \\boldsymbol{d}}\n$$\nThe well-known quadratic convergence of the Newton-Raphson method is achieved if and only if this tangent matrix $\\boldsymbol{K}_T$ is the exact Jacobian of the residual.\n\nThe contribution to $\\boldsymbol{K}_T$ from a single macroscopic Gauss point involves the derivative of the macroscopic stress $\\boldsymbol{\\Sigma}$ with respect to the macroscopic strain $\\boldsymbol{E}$, which is called the homogenized tangent modulus $\\mathbb{C}^{\\text{hom}}$:\n$$\n\\mathbb{C}^{\\text{hom}} = \\frac{\\partial \\boldsymbol{\\Sigma}}{\\partial \\boldsymbol{E}}\n$$\nIn the FE$^2$ method, the macroscopic stress $\\boldsymbol{\\Sigma}$ is not given by a closed-form constitutive law but is computed via volume averaging the microscopic stress field $\\boldsymbol{\\sigma}$ over the RVE, where $\\boldsymbol{\\sigma}$ is the solution to a micro-scale boundary value problem driven by the macro-strain $\\boldsymbol{E}$:\n$$\n\\boldsymbol{\\Sigma}(\\boldsymbol{E}) = \\frac{1}{|V_{\\text{RVE}}|} \\int_{V_{\\text{RVE}}} \\boldsymbol{\\sigma}(\\boldsymbol{x}, \\boldsymbol{E}) \\, dV\n$$\nTo obtain the exact macroscopic tangent $\\mathbb{C}^{\\text{hom}}$, we must differentiate this expression:\n$$\n\\mathbb{C}^{\\text{hom}} = \\frac{\\partial}{\\partial \\boldsymbol{E}} \\left( \\frac{1}{|V_{\\text{RVE}}|} \\int_{V_{\\text{RVE}}} \\boldsymbol{\\sigma}(\\boldsymbol{x}, \\boldsymbol{E}) \\, dV \\right) = \\frac{1}{|V_{\\text{RVE}}|} \\int_{V_{\\text{RVE}}} \\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\boldsymbol{E}} \\, dV\n$$\nThe microscopic stress $\\boldsymbol{\\sigma}$ at a point $\\boldsymbol{x}$ in the RVE is computed from the microscopic strain $\\boldsymbol{\\varepsilon}$ at that point via a discrete numerical algorithm (the stress update or return-mapping algorithm). Therefore, the derivative $\\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\boldsymbol{E}}$ must be computed consistently with this algorithm. Using the chain rule, we have:\n$$\n\\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\boldsymbol{E}} = \\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\boldsymbol{\\varepsilon}} : \\frac{\\partial \\boldsymbol{\\varepsilon}}{\\partial \\boldsymbol{E}}\n$$\nThe term $\\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\boldsymbol{\\varepsilon}}$ is precisely the **consistent algorithmic tangent** at the micro-scale, which we denote $\\mathbb{C}_{\\text{alg}}$. It is the derivative of the stress computed by the chosen integration algorithm with respect to the strain input to that algorithm. The term $\\frac{\\partial \\boldsymbol{\\varepsilon}}{\\partial \\boldsymbol{E}}$ is a fourth-order localization tensor that relates the change in micro-strain to a change in the applied macro-strain.\n\nTherefore, the homogenized tangent is the volume average of the product of the micro-scale consistent algorithmic tangent and the localization tensor. For the specialized one-dimensional RVE in this problem, the RVE is a single point, so homogenization is trivial ($\\boldsymbol{\\Sigma} = \\boldsymbol{\\sigma}, \\boldsymbol{E} = \\boldsymbol{\\varepsilon}$) and the localization tensor is unity. The macro-tangent is simply the micro-tangent: $C^{\\text{hom}} = C_{\\text{alg}}$.\n\nIn conclusion, passing the consistent algorithmic tangent $C_{\\text{alg}}$ (or its homogenized counterpart $\\mathbb{C}^{\\text{hom}}$ in the general case) from the fine scale (micro-RVE) to the coarse scale (macro-problem) provides the exact Jacobian for the macroscopic Newton-Raphson solver. This exactness is the necessary condition for achieving the characteristic quadratic rate of convergence of the method. Using any other tangent, such as the less complex elastic tangent or the continuum elastoplastic tangent, would result in an approximate Jacobian, degrading convergence to be linear at best.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the one-dimensional consistent algorithmic tangent for a series of test cases\n    in small-strain elastoplasticity with linear isotropic hardening.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (E (Pa), H (Pa), sigma_y0 (Pa), epsilon_n+1).\n    test_cases_params = [\n        (210e9, 1e9, 400e6, 1e-6),\n        (210e9, 1e9, 400e6, 'sigma_y0/E'),\n        (210e9, 1e9, 400e6, 3e-3),\n        (210e9, 1e9, 400e6, -3e-3),\n    ]\n\n    results = []\n    # All cases start from a virgin state (zero plastic strain and hardening).\n    eps_p_n = 0.0\n    alpha_n = 0.0\n\n    for case in test_cases_params:\n        E, H, sigma_y0, eps_n1_val = case\n\n        if isinstance(eps_n1_val, str) and eps_n1_val == 'sigma_y0/E':\n            # Case 2: Strain at the yield boundary\n            eps_n1 = sigma_y0 / E\n        else:\n            eps_n1 = eps_n1_val\n\n        # Step 1: Elastic Predictor\n        # Calculate the trial stress assuming a purely elastic step.\n        sigma_trial = E * (eps_n1 - eps_p_n)\n\n        # Step 2: Yield Criterion Check\n        # Calculate the current yield stress based on the previous state.\n        sigma_y_n = sigma_y0 + H * alpha_n\n        \n        # Evaluate the trial yield function f_trial = |sigma_trial| - sigma_y(alpha_n)\n        f_trial = np.abs(sigma_trial) - sigma_y_n\n\n        # Determine the consistent algorithmic tangent (C_alg)\n        if f_trial <= 0:\n            # Case A: Elastic response. The tangent is the elastic modulus.\n            C_alg = E\n        else:\n            # Case B: Plastic response. The tangent is the elastoplastic modulus.\n            C_alg = (E * H) / (E + H)\n\n        # Convert result from Pascals to Gigapascals for output.\n        C_alg_GPa = C_alg / 1e9\n        results.append(C_alg_GPa)\n\n    # Format the final output as a comma-separated list in brackets.\n    # Using a format specifier to avoid excessive decimal places in the output string.\n    output_str = f\"[{','.join(f'{r:.10f}'.rstrip('0').rstrip('.') for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}