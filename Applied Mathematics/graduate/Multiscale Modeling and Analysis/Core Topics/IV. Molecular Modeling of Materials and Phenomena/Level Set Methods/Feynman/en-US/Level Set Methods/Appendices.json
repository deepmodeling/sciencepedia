{
    "hands_on_practices": [
        {
            "introduction": "A core strength of the level set method is its ability to implicitly define geometric properties of an interface. Quantities like the normal vector and curvature, which are essential for modeling physical phenomena such as surface tension, can be computed directly from the derivatives of the level set function $\\phi$. This exercise provides hands-on practice with this fundamental concept by guiding you to calculate these properties for a simple circle, reinforcing the connection between the implicit function and the explicit geometry it represents .",
            "id": "3774752",
            "problem": "Consider a planar interface represented by the level set function $\\phi(x,y) = \\sqrt{x^{2}+y^{2}} - R$, where $R > 0$ is a constant and the zero level set $\\{\\phi=0\\}$ is the circle of radius $R$ centered at the origin. In the level set formulation, the outward unit normal to the interface is defined as $\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|$, and the scalar curvature (in the planar sense) is defined as $\\kappa = \\nabla \\cdot \\mathbf{n}$. Starting only from these core definitions and standard vector calculus, derive explicit expressions for $\\mathbf{n}$ and $\\kappa$ evaluated on the zero level set $\\{\\phi=0\\}$, and deduce the curvature as a function of $R$. State clearly the orientation of $\\mathbf{n}$ you adopt and any regularity assumptions you use. Your final reported answer must be a single analytic expression for the curvature $\\kappa$ on the zero level set in terms of $R$. No rounding is required, and no units are involved.",
            "solution": "The problem statement is critically evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n-   **Level Set Function**: The planar interface is represented by $\\phi(x,y) = \\sqrt{x^{2}+y^{2}} - R$.\n-   **Constant**: $R > 0$.\n-   **Zero Level Set**: The set $\\{\\phi=0\\}$ defines the interface, which is a circle of radius $R$ centered at the origin.\n-   **Unit Normal Vector Definition**: $\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|}$.\n-   **Scalar Curvature Definition**: $\\kappa = \\nabla \\cdot \\mathbf{n}$.\n-   **Task**: Derive expressions for $\\mathbf{n}$ and $\\kappa$ evaluated on the zero level set $\\{\\phi=0\\}$.\n-   **Task**: State the orientation of $\\mathbf{n}$ and any regularity assumptions.\n-   **Final Answer**: A single analytic expression for the curvature $\\kappa$ on the zero level set in terms of $R$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n-   **Scientifically Grounded**: The problem is founded on the standard mathematical framework of level set methods and differential geometry. The definitions provided for the unit normal vector and curvature are standard in this context. The level set function $\\phi(x,y)$ is a signed distance function for a circle, a canonical example in the field. The premises are mathematically and scientifically sound.\n-   **Well-Posed**: The problem is well-posed. It provides all necessary information and definitions to derive a unique and meaningful solution. The goal is clearly specified.\n-   **Objective**: The language is precise, formal, and free of any subjective or ambiguous statements.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a standard, well-defined problem in multiscale modeling and analysis that tests the understanding of fundamental concepts of level set methods. A complete solution will be provided.\n\n### Solution Derivation\nThe objective is to derive the curvature $\\kappa$ of the interface defined by the zero level set of $\\phi(x,y) = \\sqrt{x^{2}+y^{2}} - R$. The derivation proceeds by first computing the gradient of $\\phi$, then the unit normal vector $\\mathbf{n}$, and finally the divergence of $\\mathbf{n}$, which is the curvature $\\kappa$.\n\n**1. Regularity Assumption and Gradient of $\\phi$**\nThe level set function is given by $\\phi(x,y) = (x^{2}+y^{2})^{1/2} - R$. We assume that $\\phi$ is sufficiently smooth. The function $\\phi$ and its derivatives are well-defined for all $(x,y) \\in \\mathbb{R}^{2}$ except at the origin $(0,0)$. Since the problem specifies $R > 0$, the zero level set $\\sqrt{x^{2}+y^{2}} = R$ is a circle that does not contain the origin. Thus, all subsequent calculations on and in a neighborhood of the interface are well-defined.\n\nThe gradient of $\\phi$ is computed as $\\nabla \\phi = \\left(\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y}\\right)$.\nThe partial derivatives are:\n$$\n\\frac{\\partial \\phi}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( (x^{2}+y^{2})^{1/2} - R \\right) = \\frac{1}{2}(x^{2}+y^{2})^{-1/2}(2x) = \\frac{x}{\\sqrt{x^{2}+y^{2}}}\n$$\n$$\n\\frac{\\partial \\phi}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( (x^{2}+y^{2})^{1/2} - R \\right) = \\frac{1}{2}(x^{2}+y^{2})^{-1/2}(2y) = \\frac{y}{\\sqrt{x^{2}+y^{2}}}\n$$\nTherefore, the gradient vector field is:\n$$\n\\nabla \\phi(x,y) = \\left( \\frac{x}{\\sqrt{x^{2}+y^{2}}}, \\frac{y}{\\sqrt{x^{2}+y^{2}}} \\right)\n$$\n\n**2. Unit Normal Vector $\\mathbf{n}$ and its Orientation**\nThe unit normal vector $\\mathbf{n}$ is defined as $\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|}$. First, we compute the norm of the gradient:\n$$\n|\\nabla \\phi| = \\sqrt{ \\left(\\frac{x}{\\sqrt{x^{2}+y^{2}}}\\right)^{2} + \\left(\\frac{y}{\\sqrt{x^{2}+y^{2}}}\\right)^{2} } = \\sqrt{ \\frac{x^{2}}{x^{2}+y^{2}} + \\frac{y^{2}}{x^{2}+y^{2}} } = \\sqrt{ \\frac{x^{2}+y^{2}}{x^{2}+y^{2}} } = 1\n$$\nThe fact that $|\\nabla \\phi| = 1$ (for $(x,y) \\neq (0,0)$) confirms that $\\phi$ is a signed distance function.\nThe unit normal vector is then:\n$$\n\\mathbf{n}(x,y) = \\frac{\\nabla \\phi}{1} = \\left( \\frac{x}{\\sqrt{x^{2}+y^{2}}}, \\frac{y}{\\sqrt{x^{2}+y^{2}}} \\right)\n$$\nThe orientation of $\\mathbf{n}$ is determined by the sign of $\\phi$. By convention, the gradient $\\nabla \\phi$ points in the direction of increasing $\\phi$. For points outside the circle, $\\sqrt{x^{2}+y^{2}} > R$, so $\\phi > 0$. For points inside the circle, $\\sqrt{x^{2}+y^{2}} < R$, so $\\phi < 0$. Therefore, $\\mathbf{n} = \\nabla \\phi$ points from the region of negative $\\phi$ to the region of positive $\\phi$, which is from the interior to the exterior of the circle. We adopt this orientation, meaning $\\mathbf{n}$ is the **outward unit normal vector**.\n\nOn the zero level set $\\{\\phi=0\\}$, we have $\\sqrt{x^{2}+y^{2}} = R$. Substituting this into the expression for $\\mathbf{n}$ gives the normal vector on the interface:\n$$\n\\mathbf{n}\\big|_{\\phi=0} = \\left( \\frac{x}{R}, \\frac{y}{R} \\right)\n$$\nThis vector points radially outward from the origin to a point $(x,y)$ on the circle, and has unit length, as expected.\n\n**3. Curvature $\\kappa$**\nThe curvature is defined as the divergence of the unit normal vector field, $\\kappa = \\nabla \\cdot \\mathbf{n}$. We must compute this divergence using the general expression for $\\mathbf{n}(x,y)$ valid in a neighborhood of the interface, not just on the interface itself.\nLet the components of $\\mathbf{n}$ be $n_x = \\frac{x}{\\sqrt{x^{2}+y^{2}}}$ and $n_y = \\frac{y}{\\sqrt{x^{2}+y^{2}}}$.\nThe divergence is $\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$.\nWe compute the partial derivatives using the quotient rule or product rule. Using the product rule for $n_x = x \\cdot (x^{2}+y^{2})^{-1/2}$:\n$$\n\\frac{\\partial n_x}{\\partial x} = 1 \\cdot (x^{2}+y^{2})^{-1/2} + x \\cdot \\left( -\\frac{1}{2}(x^{2}+y^{2})^{-3/2} \\cdot 2x \\right) = \\frac{1}{\\sqrt{x^{2}+y^{2}}} - \\frac{x^{2}}{(x^{2}+y^{2})^{3/2}}\n$$\n$$\n\\frac{\\partial n_x}{\\partial x} = \\frac{x^{2}+y^{2}}{(x^{2}+y^{2})^{3/2}} - \\frac{x^{2}}{(x^{2}+y^{2})^{3/2}} = \\frac{y^{2}}{(x^{2}+y^{2})^{3/2}}\n$$\nBy symmetry, swapping $x$ and $y$:\n$$\n\\frac{\\partial n_y}{\\partial y} = \\frac{x^{2}}{(x^{2}+y^{2})^{3/2}}\n$$\nSumming the partial derivatives gives the curvature:\n$$\n\\kappa(x,y) = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y} = \\frac{y^{2}}{(x^{2}+y^{2})^{3/2}} + \\frac{x^{2}}{(x^{2}+y^{2})^{3/2}} = \\frac{x^{2}+y^{2}}{(x^{2}+y^{2})^{3/2}} = \\frac{1}{(x^{2}+y^{2})^{1/2}} = \\frac{1}{\\sqrt{x^{2}+y^{2}}}\n$$\nThis is the expression for the curvature at any point $(x,y)$ where $\\phi$ is defined (i.e., not at the origin).\n\n**4. Curvature on the Zero Level Set**\nFinally, we evaluate the expression for $\\kappa$ on the zero level set $\\{\\phi=0\\}$, where $\\sqrt{x^{2}+y^{2}} = R$.\n$$\n\\kappa\\big|_{\\phi=0} = \\frac{1}{R}\n$$\nThis result confirms that the curvature of a circle of radius $R$ is $1/R$. The positive sign is consistent with the convention of an outward normal for a convex shape enclosing the origin.",
            "answer": "$$\n\\boxed{\\frac{1}{R}}\n$$"
        },
        {
            "introduction": "Beyond representing static shapes, the true power of the level set method lies in modeling the evolution of complex interfaces over time. This dynamic behavior is governed by a partial differential equation (PDE) for the level set function $\\phi$. This practice problem offers a unique opportunity to find an exact analytical solution for a classic and important evolution law—motion by mean curvature—by showing how an initially circular interface shrinks and ultimately vanishes .",
            "id": "3774749",
            "problem": "Consider a smooth, closed, convex planar interface evolving by motion by mean curvature and represented by a level set function $\\phi(\\mathbf{x}, t)$ with the sign convention $\\phi(\\mathbf{x}, t) < 0$ inside the interface and $\\phi(\\mathbf{x}, t) > 0$ outside. The evolution law is given in the level set formulation by the partial differential equation (PDE) $\\phi_{t} = |\\nabla \\phi| \\, \\kappa$, where $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$ is the scalar curvature of the zero level set in two dimensions. At time $t = 0$, the zero level set $\\{ \\mathbf{x} : \\phi(\\mathbf{x}, 0) = 0 \\}$ is a circle of radius $R_{0} > 0$ centered at the origin in $\\mathbb{R}^{2}$. Assume radial symmetry persists for as long as the solution remains smooth and the interface remains convex.\n\nStarting from the level set PDE and the given geometric definitions, use rotational symmetry to reduce the PDE to an ordinary differential equation for the radius $R(t)$ of the evolving circle. Solve this ordinary differential equation with the initial condition $R(0) = R_{0}$ to obtain a closed-form expression for $R(t)$ that is valid up to, but not beyond, the extinction time at which the radius reaches zero.\n\nProvide your final answer as a single analytic expression for $R(t)$. No numerical evaluation is required, and no units are involved.",
            "solution": "The user-provided problem is deemed valid as it is scientifically grounded in the theory of partial differential equations and differential geometry, specifically the level set method for interface evolution. It is well-posed, with a clear initial condition and governing equation, and objective in its formulation. No inconsistencies, ambiguities, or factual errors are present. We may therefore proceed with the solution.\n\nThe problem asks for the derivation of the radius $R(t)$ of a circle evolving under motion by mean curvature, starting from the level set formulation. The evolution of the level set function $\\phi(\\mathbf{x}, t)$ is governed by the partial differential equation (PDE):\n$$ \\phi_{t} = |\\nabla \\phi| \\, \\kappa $$\nwhere $\\kappa$ is the mean curvature of the level sets, given by $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$. The initial condition is a circle of radius $R_0$ at $t=0$. The problem assumes that radial symmetry is preserved during the evolution.\n\nLet us exploit this radial symmetry. In a 2D Cartesian coordinate system $(x, y)$, the distance from the origin is $r = |\\mathbf{x}| = \\sqrt{x^2 + y^2}$. Due to radial symmetry, the level set function $\\phi$ depends only on $r$ and $t$. We can write $\\phi(\\mathbf{x}, t) = \\psi(r, t)$ for some function $\\psi$.\n\nFirst, we calculate the gradient $\\nabla \\phi$. For a radially symmetric function $\\psi(r)$, the gradient is given by:\n$$ \\nabla \\phi = \\nabla \\psi(r) = \\frac{d\\psi}{dr} \\frac{\\partial r}{\\partial \\mathbf{x}} = \\psi_{r} \\hat{\\mathbf{r}} $$\nwhere $\\psi_{r} = \\frac{\\partial \\psi}{\\partial r}$ and $\\hat{\\mathbf{r}} = \\frac{\\mathbf{x}}{r}$ is the unit radial vector.\n\nThe magnitude of the gradient is:\n$$ |\\nabla \\phi| = \\left| \\psi_{r} \\hat{\\mathbf{r}} \\right| = |\\psi_{r}| |\\hat{\\mathbf{r}}| = |\\psi_{r}| $$\nThe problem specifies that $\\phi < 0$ inside the interface and $\\phi > 0$ outside. For a circle of radius $R(t)$, this means $\\psi(r, t) < 0$ for $r < R(t)$ and $\\psi(r, t) > 0$ for $r > R(t)$. This implies that $\\psi$ is an increasing function of $r$ in the vicinity of the interface $r=R(t)$. Therefore, $\\psi_{r} > 0$ at the interface, and we can write $|\\nabla \\phi| = \\psi_{r}$ without the absolute value.\n\nNow, we compute the curvature $\\kappa$. The unit normal vector to the level set is $\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|}$.\n$$ \\mathbf{n} = \\frac{\\psi_{r} \\hat{\\mathbf{r}}}{\\psi_{r}} = \\hat{\\mathbf{r}} $$\nThis confirms that for a circle centered at the origin, the outward unit normal is the radial unit vector.\n\nThe curvature is the divergence of the unit normal vector:\n$$ \\kappa = \\nabla \\cdot \\mathbf{n} = \\nabla \\cdot \\hat{\\mathbf{r}} $$\nIn 2D Cartesian coordinates, $\\hat{\\mathbf{r}} = (x/r, y/r) = (x/\\sqrt{x^2+y^2}, y/\\sqrt{x^2+y^2})$. The divergence is:\n$$ \\nabla \\cdot \\hat{\\mathbf{r}} = \\frac{\\partial}{\\partial x} \\left( \\frac{x}{\\sqrt{x^2+y^2}} \\right) + \\frac{\\partial}{\\partial y} \\left( \\frac{y}{\\sqrt{x^2+y^2}} \\right) $$\nCalculating the first term:\n$$ \\frac{\\partial}{\\partial x} \\left( \\frac{x}{r} \\right) = \\frac{1 \\cdot r - x \\cdot \\frac{\\partial r}{\\partial x}}{r^2} = \\frac{r - x(x/r)}{r^2} = \\frac{r^2 - x^2}{r^3} $$\nSimilarly, for the second term:\n$$ \\frac{\\partial}{\\partial y} \\left( \\frac{y}{r} \\right) = \\frac{r - y(y/r)}{r^2} = \\frac{r^2 - y^2}{r^3} $$\nAdding them together:\n$$ \\kappa = \\frac{r^2 - x^2}{r^3} + \\frac{r^2 - y^2}{r^3} = \\frac{2r^2 - (x^2+y^2)}{r^3} = \\frac{2r^2 - r^2}{r^3} = \\frac{r^2}{r^3} = \\frac{1}{r} $$\nSo, the curvature of a circle of radius $r$ is indeed $\\kappa = 1/r$.\n\nNow we substitute our expressions for $\\phi_{t}$, $|\\nabla \\phi|$, and $\\kappa$ back into the level set PDE. The time derivative is $\\phi_{t} = \\psi_{t}$.\n$$ \\psi_{t} = (\\psi_{r}) \\left( \\frac{1}{r} \\right) $$\nThis is the PDE for $\\psi(r,t)$.\n\nThe interface is the zero level set, defined by the condition $\\phi(\\mathbf{x}, t) = 0$. In our radially symmetric case, this corresponds to a circle of radius $R(t)$, so we have the implicit definition $\\psi(R(t), t) = 0$.\nTo find the evolution of $R(t)$, we differentiate this identity with respect to time $t$ using the chain rule:\n$$ \\frac{d}{dt} \\psi(R(t), t) = \\frac{\\partial \\psi}{\\partial r} \\frac{dR}{dt} + \\frac{\\partial \\psi}{\\partial t} = 0 $$\nAll derivatives here are evaluated at $r=R(t)$. Substituting the PDE $\\psi_{t} = \\frac{1}{r}\\psi_{r}$ (evaluated at $r=R(t)$) into this equation, we get:\n$$ \\psi_{r}(R(t), t) \\frac{dR}{dt} + \\frac{1}{R(t)} \\psi_{r}(R(t), t) = 0 $$\nAs long as the interface is well-defined, the level set function is not flat at the interface, meaning $\\psi_{r}(R(t), t) \\neq 0$. We can therefore divide by this term to obtain an ordinary differential equation (ODE) for the radius $R(t)$:\n$$ \\frac{dR}{dt} + \\frac{1}{R(t)} = 0 \\quad \\implies \\quad \\frac{dR}{dt} = -\\frac{1}{R} $$\nThis is a separable first-order ODE. We can write it as:\n$$ R \\, dR = -dt $$\nWe integrate this equation from the initial time $t=0$ to a general time $t$. The radius evolves from $R(0)=R_0$ to $R(t)$.\n$$ \\int_{R_0}^{R(t)} R' \\, dR' = \\int_{0}^{t} -1 \\, dt' $$\n$$ \\left[ \\frac{1}{2} (R')^2 \\right]_{R_0}^{R(t)} = [-t']_{0}^{t} $$\n$$ \\frac{1}{2} R(t)^2 - \\frac{1}{2} R_0^2 = -t $$\nNow, we solve for $R(t)$:\n$$ R(t)^2 = R_0^2 - 2t $$\n$$ R(t) = \\sqrt{R_0^2 - 2t} $$\nThis solution is valid as long as the term under the square root is non-negative, i.e., $R_0^2 - 2t \\ge 0$, or $t \\le R_0^2/2$. The time $t_{ext} = R_0^2/2$ is the extinction time, at which the radius shrinks to zero. The problem asks for the expression for $R(t)$ up to this time.",
            "answer": "$$\\boxed{\\sqrt{R_{0}^{2} - 2t}}$$"
        },
        {
            "introduction": "While analytical solutions are insightful, most real-world applications of level set methods rely on robust numerical algorithms. The Eikonal equation, $|\\nabla T| = 1/s$, is a fundamental Hamilton-Jacobi equation that appears frequently in problems of front propagation and is key to initializing or re-distancing a level set function. This exercise takes you from theory to practice by tasking you with implementing the core computational step of the Fast Marching Method (FMM), a highly efficient algorithm designed to solve the Eikonal equation on a grid .",
            "id": "3774639",
            "problem": "You are given a discretized two-dimensional grid and a positive speed field $s(x)$ defined at each grid node. In the context of the Fast Marching Method (FMM), which is a numerical algorithm for solving the Eikonal equation in level set methods, suppose you seek the arrival time $T$ at a single trial node using two already accepted neighbors: one along the $x$-axis and one along the $y$-axis. The underlying arrival time formulation comes from the Eikonal equation for arrival times, which states that the magnitude of the gradient of the arrival time equals the reciprocal of the speed, namely $|\\nabla T| = 1/s(x)$. Using a first-order monotone upwind discretization, you must compute the update at the trial node from its two accepted neighbors.\n\nStarting from well-established principles:\n- The Eikonal equation $|\\nabla T| = 1/s(x)$ models front propagation governed by a speed field $s(x)$.\n- The Fast Marching Method (FMM) advances the front by solving a local update using upwind finite differences from accepted neighbors in order to maintain causality.\n- On a rectangular grid with spacings $h_x > 0$ and $h_y > 0$, and local speed $s > 0$ at the node, the upwind approximation uses $(T - T_x)/h_x$ and $(T - T_y)/h_y$, where $T_x$ and $T_y$ are the arrival times at the accepted neighbors along the $x$- and $y$-axes, respectively.\n\nYour task is to implement a program that, for each provided test case, computes the trial-node arrival time $T$ by:\n- Formulating the monotone upwind discretization of the Eikonal equation at the node with the two accepted neighbors,\n- Solving the resulting local equation for $T$,\n- Enforcing the causality condition $T \\ge \\max(T_x, T_y)$; if the two-neighbor solution violates causality or yields no real solution (e.g., negative discriminant in the quadratic), then fall back to the one-neighbor update $T = \\min(T_x, T_y) + h_i/s$, where $h_i$ is the grid spacing along the axis corresponding to the smaller neighbor time.\n\nAll computations are purely numerical; no physical units are required. Angles are not involved. Your program must compute $T$ for each test case, round each result to six decimal places, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\"[t_1,t_2,t_3]\"$.\n\nUse the following test suite, where each test case is a tuple $(T_x, T_y, h_x, h_y, s)$:\n- Test Case $1$: $(1.0, 1.2, 1.0, 1.0, 2.0)$.\n- Test Case $2$: $(1.0, 3.0, 1.0, 1.0, 10.0)$.\n- Test Case $3$: $(0.5, 0.6, 2.0, 1.0, 1.0)$.\n- Test Case $4$: $(2.0, 2.0, 0.5, 2.0, 0.5)$.\n- Test Case $5$: $(0.0, 0.0, 1.0, 1.0, 0.2)$.\n\nDesign for coverage:\n- The first test is a general isotropic-grid case with two-neighbor update.\n- The second test forces a one-neighbor fallback due to a large disparity between neighbor times and very fast speed.\n- The third test examines anisotropic grid spacings with two-neighbor update.\n- The fourth test presents equal neighbor times with highly anisotropic spacings and slow speed.\n- The fifth test examines a boundary case with zero neighbor times and very slow speed.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places, for example, $\"[t_1,t_2,t_3,t_4,t_5]\"$.",
            "solution": "The derivation begins from the Eikonal equation for arrival time $T(x)$:\n$$\n|\\nabla T(x)| \\;=\\; \\frac{1}{s(x)} \\,,\n$$\nwhere $s(x) > 0$ is the speed field. On a rectangular grid, let the node of interest be adjacent to two already accepted neighbors, one along the $x$-axis with arrival time $T_x$ and one along the $y$-axis with arrival time $T_y$. Let $h_x > 0$ and $h_y > 0$ denote the corresponding grid spacings along the $x$- and $y$-directions, respectively. For a monotone upwind discretization at the trial node, the gradient components are approximated using one-sided differences pointing from the accepted neighbors toward the trial node. Specifically,\n$$\n\\left(\\frac{\\partial T}{\\partial x}\\right) \\approx \\frac{T - T_x}{h_x}, \n\\qquad\n\\left(\\frac{\\partial T}{\\partial y}\\right) \\approx \\frac{T - T_y}{h_y}.\n$$\nSubstituting these into the Eikonal equation yields\n$$\n\\left(\\frac{T - T_x}{h_x}\\right)^2 + \\left(\\frac{T - T_y}{h_y}\\right)^2 \\;=\\; \\left(\\frac{1}{s}\\right)^2,\n$$\nwhere $s$ is the speed at the trial node (assumed positive). Define $A = 1/h_x^2$ and $B = 1/h_y^2$, and denote $\\alpha = 1/s$. Then the equation becomes\n$$\nA\\,(T - T_x)^2 + B\\,(T - T_y)^2 \\;=\\; \\alpha^2.\n$$\nExpanding and collecting terms in $T$, we obtain a quadratic equation:\n$$\n(A + B)\\,T^2 - 2\\,(A\\,T_x + B\\,T_y)\\,T + \\left(A\\,T_x^2 + B\\,T_y^2 - \\alpha^2\\right) \\;=\\; 0.\n$$\nLet\n$$\nc_2 = A + B, \\quad c_1 = -2\\,(A\\,T_x + B\\,T_y), \\quad c_0 = A\\,T_x^2 + B\\,T_y^2 - \\alpha^2.\n$$\nThe discriminant is\n$$\n\\Delta = c_1^2 - 4\\,c_2\\,c_0.\n$$\nThere are two candidate roots\n$$\nT_{\\pm} = \\frac{-c_1 \\pm \\sqrt{\\Delta}}{2\\,c_2}.\n$$\nThe monotonicity (causality) requirement in the Fast Marching Method (FMM) mandates that the accepted arrival times must not decrease along characteristics, which here implies that the trial update must satisfy\n$$\nT \\ge \\max(T_x, T_y).\n$$\nMoreover, the physically relevant root is the larger root $T_{+}$, since the smaller root $T_{-}$ typically violates the monotonicity constraint. However, two failures can occur:\n1. If $\\Delta < 0$, then no real two-neighbor solution exists.\n2. If $T_{+} < \\max(T_x, T_y)$, the two-neighbor solution violates causality.\n\nIn either failure, FMM prescribes the one-neighbor fallback update using the smaller of the two arrival times. If $T_x \\le T_y$, use the $x$-neighbor:\n$$\nT = T_x + \\frac{h_x}{s} = T_x + \\alpha\\,h_x,\n$$\notherwise use the $y$-neighbor:\n$$\nT = T_y + \\frac{h_y}{s} = T_y + \\alpha\\,h_y.\n$$\n\nAlgorithm summary for a single node with two accepted neighbors:\n- Compute $A = 1/h_x^2$, $B = 1/h_y^2$, and $\\alpha = 1/s$.\n- Form $c_2 = A + B$, $c_1 = -2(A\\,T_x + B\\,T_y)$, $c_0 = A\\,T_x^2 + B\\,T_y^2 - \\alpha^2$.\n- Compute the discriminant $\\Delta = c_1^2 - 4\\,c_2\\,c_0$. If $\\Delta < 0$ (within floating-point tolerance), perform the one-neighbor fallback.\n- Otherwise, compute $T_{+} = \\dfrac{-c_1 + \\sqrt{\\Delta}}{2\\,c_2}$. If $T_{+} < \\max(T_x, T_y)$, perform the one-neighbor fallback. Otherwise, accept $T = T_{+}$.\n\nApplying this to the test suite:\n- Test Case $1$: $(T_x, T_y, h_x, h_y, s) = (1.0, 1.2, 1.0, 1.0, 2.0)$. This yields a valid two-neighbor solution with $T \\approx 1.4391165$, rounded to $1.439117$.\n- Test Case $2$: $(1.0, 3.0, 1.0, 1.0, 10.0)$. The discriminant is negative, and the fallback uses the smaller neighbor $T_x = 1.0$ with $h_x = 1.0$, giving $T = 1.0 + 0.1 = 1.1$, rounded to $1.100000$.\n- Test Case $3$: $(0.5, 0.6, 2.0, 1.0, 1.0)$. Anisotropic update produces a valid two-neighbor solution, approximately $T \\approx 1.4736$, rounded to $1.473600$.\n- Test Case $4$: $(2.0, 2.0, 0.5, 2.0, 0.5)$. With equal neighbor times, the two-neighbor anisotropic solution yields $T \\approx 2.9701425$, rounded to $2.970143$.\n- Test Case $5$: $(0.0, 0.0, 1.0, 1.0, 0.2)$. The isotropic two-neighbor solution gives $T \\approx 3.5355339$, rounded to $3.535534$.\n\nThe program will implement this logic for each test case, round to six decimal places, and print the results as a single bracketed comma-separated list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fast_marching_update(Tx: float, Ty: float, hx: float, hy: float, s: float) -> float:\n    \"\"\"\n    Compute the Fast Marching Method (FMM) two-neighbor update for arrival time T at a single node.\n    Tx: arrival time at accepted neighbor along x-axis\n    Ty: arrival time at accepted neighbor along y-axis\n    hx: grid spacing along x-axis (> 0)\n    hy: grid spacing along y-axis (> 0)\n    s: local speed at the node (> 0)\n    Returns: updated arrival time T (float)\n    \"\"\"\n    # Ensure positive spacings and speed\n    if hx <= 0.0 or hy <= 0.0 or s <= 0.0:\n        raise ValueError(\"Grid spacings hx, hy and speed s must be positive.\")\n\n    alpha = 1.0 / s  # 1/s\n    A = 1.0 / (hx * hx)\n    B = 1.0 / (hy * hy)\n\n    # Quadratic coefficients: c2*T^2 + c1*T + c0 = 0\n    c2 = A + B\n    c1 = -2.0 * (A * Tx + B * Ty)\n    c0 = A * Tx * Tx + B * Ty * Ty - alpha * alpha\n\n    # Discriminant\n    disc = c1 * c1 - 4.0 * c2 * c0\n\n    # Numerical tolerance for discriminant\n    if disc < 0.0:\n        # If slightly negative due to floating error, clamp to zero\n        if disc > -1e-12:\n            disc = 0.0\n        else:\n            # No real two-neighbor solution; fallback to one-neighbor update\n            if Tx <= Ty:\n                return Tx + alpha * hx\n            else:\n                return Ty + alpha * hy\n\n    sqrt_disc = np.sqrt(disc)\n    # Larger root\n    T_candidate = (-c1 + sqrt_disc) / (2.0 * c2)\n\n    # Monotonicity (causality) check\n    if T_candidate < max(Tx, Ty):\n        # Fallback to one-neighbor update using the smaller neighbor\n        if Tx <= Ty:\n            return Tx + alpha * hx\n        else:\n            return Ty + alpha * hy\n\n    return T_candidate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Tx, Ty, hx, hy, s)\n    test_cases = [\n        (1.0, 1.2, 1.0, 1.0, 2.0),   # General isotropic, two-neighbor\n        (1.0, 3.0, 1.0, 1.0, 10.0),  # One-neighbor fallback due to large disparity and fast speed\n        (0.5, 0.6, 2.0, 1.0, 1.0),   # Anisotropic spacings, two-neighbor\n        (2.0, 2.0, 0.5, 2.0, 0.5),   # Equal neighbors, anisotropic, slow speed\n        (0.0, 0.0, 1.0, 1.0, 0.2),   # Zero neighbors, very slow speed\n    ]\n\n    results = []\n    for Tx, Ty, hx, hy, s in test_cases:\n        T = fast_marching_update(Tx, Ty, hx, hy, s)\n        results.append(T)\n\n    # Final print statement in the exact required format: single line with bracketed comma-separated list.\n    # Round each result to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}