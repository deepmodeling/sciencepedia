{
    "hands_on_practices": [
        {
            "introduction": "驻留时间算法的核心在于其如何推进模拟时间。本练习旨在深入探讨计算模拟时间步长的统计理论基础。我们将展示，对于一系列独立的、遵循泊松过程的事件，系统等待至下一个事件发生的时间间隔——即驻留时间——遵循一个指数分布，这个练习将巩固KMC时钟推进机制的理论根基。",
            "id": "3851130",
            "problem": "考虑一个晶体表面的动力学蒙特卡洛 (KMC) 模拟，在任何瞬间可能发生三种独立的基本过程：空位跳跃、吸附原子脱附和近邻交换。假设每个过程都被建模为一个独立的泊松过程，其恒定速率分别为 $r_{1}$、$r_{2}$ 和 $r_{3}$，并且模拟使用驻留时间算法将时钟推进到下一个事件发生，时间增量为 $\\Delta t$。驻留时间算法所基于的物理假设是：下一个事件的时间是这些独立泊松过程中的首次到达时间，并且该过程是马尔可夫性的。\n\n从事件的独立性以及生存函数 $S(t)$（即到时间 $t$ 为止没有事件发生的概率）的定义出发，推导出 $\\Delta t$ 的概率密度函数 $f_{\\Delta t}(t)$，用总速率 $R_{\\text{tot}}=\\sum_{i=1}^{3} r_{i}$ 表示。然后，使用此 $f_{\\Delta t}(t)$，计算期望 $\\mathbb{E}[\\Delta t]$ 和方差 $\\mathrm{Var}[\\Delta t]$，将其表示为 $R_{\\text{tot}}$ 的函数。\n\n最后，将速率实例化为 $r_{1}=3\\,\\mathrm{s}^{-1}$、$r_{2}=5\\,\\mathrm{s}^{-1}$ 和 $r_{3}=2\\,\\mathrm{s}^{-1}$，并计算 $\\mathbb{E}[\\Delta t]$（单位：秒）和 $\\mathrm{Var}[\\Delta t]$（单位：平方秒）的数值。提供精确的数值；无需四舍五入。按 $\\mathbb{E}[\\Delta t]$、$\\mathrm{Var}[\\Delta t]$ 的顺序报告最终的数值对。",
            "solution": "首先将根据所需标准对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 三个独立的基本过程：空位跳跃、吸附原子脱附、近邻交换。\n- 每个过程被建模为独立的泊松过程，其恒定速率分别为 $r_{1}$、$r_{2}$ 和 $r_{3}$。\n- 模拟使用驻留时间算法将时钟以时间 $\\Delta t$ 推进。\n- 物理假设：$\\Delta t$ 是独立泊松过程中的首次到达时间。该过程是马尔可夫性的。\n- 出发点：生存函数 $S(t)$ 是到时间 $t$ 为止没有事件发生的概率。\n- 总速率定义为 $R_{\\text{tot}}=\\sum_{i=1}^{3} r_{i}$。\n- 目标 1：用 $R_{\\text{tot}}$ 表示 $\\Delta t$ 的概率密度函数 $f_{\\Delta t}(t)$。\n- 目标 2：计算期望 $\\mathbb{E}[\\Delta t]$ 和方差 $\\mathrm{Var}[\\Delta t]$，将其表示为 $R_{\\text{tot}}$ 的函数。\n- 目标 3：将速率实例化为 $r_{1}=3\\,\\mathrm{s}^{-1}$、$r_{2}=5\\,\\mathrm{s}^{-1}$ 和 $r_{3}=2\\,\\mathrm{s}^{-1}$。\n- 目标 4：计算 $\\mathbb{E}[\\Delta t]$ 和 $\\mathrm{Var}[\\Delta t]$ 的数值，并按指定顺序报告。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行审查。\n\n- **科学基础（关键）**：该问题坚实地基于随机过程理论，特别是泊松过程和指数分布。驻留时间算法（也称为 BKL 算法或标准 KMC）是计算材料科学和化学中一种基础且广泛使用的方法。其假设（独立泊松过程、马尔可夫行为）是此类模型的标准假设。该问题在科学上是合理的。\n- **适定性**：该问题提供了推导所要求的所有量的必要信息。在概率论的框架内，速率、概率和时间演化之间的关系被清晰定义。存在唯一且有意义的解。\n- **客观性（关键）**：语言精确、量化，没有任何主观或模糊的术语。任务是明确陈述的数学目标。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个统计力学和模拟理论中的标准、适定的问题。现在开始求解过程。\n\n### 求解推导\n\n令 $T_i$ 为第 $i$ 个过程的等待时间，其中 $i \\in \\{1, 2, 3\\}$。由于每个过程都是速率为 $r_i$ 的泊松过程，等待时间 $T_i$ 是一个服从参数为 $r_i$ 的指数分布的随机变量。$T_i$ 的概率密度函数 (PDF) 为 $f_{T_i}(t) = r_i \\exp(-r_i t)$ (当 $t \\ge 0$)，累积分布函数 (CDF) 为 $F_{T_i}(t) = P(T_i \\le t) = 1 - \\exp(-r_i t)$。\n\n第 $i$ 个过程的生存函数 $S_i(t)$ 是指到时间 $t$ 为止过程 $i$ 尚未发生的概率。它由下式给出：\n$$S_i(t) = P(T_i  t) = 1 - F_{T_i}(t) = \\exp(-r_i t)$$\n\n在 KMC 模拟中，到下一个事件发生的时间 $\\Delta t$ 是所有可能的独立过程的等待时间中的最小值。\n$$\\Delta t = \\min(T_1, T_2, T_3)$$\n\n根据问题陈述，$\\Delta t$ 的生存函数表示为 $S(t)$，是到下一个事件发生的时间大于 $t$ 的概率。这等价于到时间 $t$ 为止三个事件均未发生的概率。\n$$S(t) = P(\\Delta t  t) = P(\\min(T_1, T_2, T_3)  t)$$\n\n要使几个随机变量的最小值大于 $t$，每个随机变量都必须大于 $t$。\n$$S(t) = P(T_1  t \\text{ and } T_2  t \\text{ and } T_3  t)$$\n\n由于这些过程是独立的，其联合概率是各个概率的乘积：\n$$S(t) = P(T_1  t) P(T_2  t) P(T_3  t) = S_1(t) S_2(t) S_3(t)$$\n\n代入各个生存函数的表达式：\n$$S(t) = \\exp(-r_1 t) \\exp(-r_2 t) \\exp(-r_3 t) = \\exp(-(r_1 + r_2 + r_3)t)$$\n\n使用总速率的定义 $R_{\\text{tot}} = r_1 + r_2 + r_3$，生存函数变为：\n$$S(t) = \\exp(-R_{\\text{tot}} t)$$\n\n概率密度函数 $f_{\\Delta t}(t)$ 可通过对生存函数关于 $t$ 求负导数得到。\n$$f_{\\Delta t}(t) = -\\frac{d}{dt}S(t) = -\\frac{d}{dt}\\left(\\exp(-R_{\\text{tot}} t)\\right) = -(-R_{\\text{tot}} \\exp(-R_{\\text{tot}} t))$$\n$$f_{\\Delta t}(t) = R_{\\text{tot}} \\exp(-R_{\\text{tot}} t) \\quad \\text{for } t \\ge 0$$\n这是速率参数为 $R_{\\text{tot}}$ 的指数分布的概率密度函数。\n\n接下来，我们计算期望 $\\mathbb{E}[\\Delta t]$ 和方差 $\\mathrm{Var}[\\Delta t]$。\n期望值根据定义计算：\n$$\\mathbb{E}[\\Delta t] = \\int_{0}^{\\infty} t f_{\\Delta t}(t) dt = \\int_{0}^{\\infty} t (R_{\\text{tot}} \\exp(-R_{\\text{tot}} t)) dt$$\n我们使用分部积分法 $\\int u \\, dv = uv - \\int v \\, du$，令 $u = t$ 且 $dv = R_{\\text{tot}} \\exp(-R_{\\text{tot}} t) dt$。可得 $du = dt$ 且 $v = -\\exp(-R_{\\text{tot}} t)$。\n$$\\mathbb{E}[\\Delta t] = \\left[ -t \\exp(-R_{\\text{tot}} t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} (-\\exp(-R_{\\text{tot}} t)) dt$$\n第一项的值为 $0$，因为当 $R_{\\text{tot}}  0$ 时，$\\lim_{t\\to\\infty} t \\exp(-R_{\\text{tot}} t) = 0$。\n$$\\mathbb{E}[\\Delta t] = \\int_{0}^{\\infty} \\exp(-R_{\\text{tot}} t) dt = \\left[ -\\frac{1}{R_{\\text{tot}}} \\exp(-R_{\\text{tot}} t) \\right]_{0}^{\\infty} = 0 - \\left(-\\frac{1}{R_{\\text{tot}}}\\right) = \\frac{1}{R_{\\text{tot}}}$$\n\n为求方差，我们首先计算二阶矩 $\\mathbb{E}[(\\Delta t)^2]$。\n$$\\mathbb{E}[(\\Delta t)^2] = \\int_{0}^{\\infty} t^2 f_{\\Delta t}(t) dt = \\int_{0}^{\\infty} t^2 (R_{\\text{tot}} \\exp(-R_{\\text{tot}} t)) dt$$\n再次使用分部积分法，令 $u = t^2$ 且 $dv = R_{\\text{tot}} \\exp(-R_{\\text{tot}} t) dt$。可得 $du = 2t \\, dt$ 且 $v = -\\exp(-R_{\\text{tot}} t)$。\n$$\\mathbb{E}[(\\Delta t)^2] = \\left[ -t^2 \\exp(-R_{\\text{tot}} t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} (-\\exp(-R_{\\text{tot}} t))(2t) dt$$\n第一项为 $0$。\n$$\\mathbb{E}[(\\Delta t)^2] = 2 \\int_{0}^{\\infty} t \\exp(-R_{\\text{tot}} t) dt$$\n我们可以看出该积分与期望的计算有关。由 $\\mathbb{E}[\\Delta t] = R_{\\text{tot}} \\int_{0}^{\\infty} t \\exp(-R_{\\text{tot}} t) dt = \\frac{1}{R_{\\text{tot}}}$，我们知道 $\\int_{0}^{\\infty} t \\exp(-R_{\\text{tot}} t) dt = \\frac{1}{R_{\\text{tot}}^2}$。\n$$\\mathbb{E}[(\\Delta t)^2] = 2 \\left( \\frac{1}{R_{\\text{tot}}^2} \\right) = \\frac{2}{R_{\\text{tot}}^2}$$\n\n方差由 $\\mathrm{Var}[\\Delta t] = \\mathbb{E}[(\\Delta t)^2] - (\\mathbb{E}[\\Delta t])^2$ 给出。\n$$\\mathrm{Var}[\\Delta t] = \\frac{2}{R_{\\text{tot}}^2} - \\left(\\frac{1}{R_{\\text{tot}}}\\right)^2 = \\frac{1}{R_{\\text{tot}}^2}$$\n\n最后，我们代入给定的速率数值：\n$r_{1}=3\\,\\mathrm{s}^{-1}$，$r_{2}=5\\,\\mathrm{s}^{-1}$ 和 $r_{3}=2\\,\\mathrm{s}^{-1}$。\n总速率 $R_{\\text{tot}}$ 为：\n$$R_{\\text{tot}} = r_1 + r_2 + r_3 = 3\\,\\mathrm{s}^{-1} + 5\\,\\mathrm{s}^{-1} + 2\\,\\mathrm{s}^{-1} = 10\\,\\mathrm{s}^{-1}$$\n\n现在我们可以计算期望和方差：\n$$\\mathbb{E}[\\Delta t] = \\frac{1}{R_{\\text{tot}}} = \\frac{1}{10\\,\\mathrm{s}^{-1}} = 0.1\\,\\mathrm{s}$$\n$$\\mathrm{Var}[\\Delta t] = \\frac{1}{R_{\\text{tot}}^2} = \\frac{1}{(10\\,\\mathrm{s}^{-1})^2} = \\frac{1}{100\\,\\mathrm{s}^{-2}} = 0.01\\,\\mathrm{s}^2$$\n\n所要求的数值为期望值 $0.1$ 和方差 $0.01$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.1  0.01 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了驻留时间的理论基础后，我们将从理论转向具体的实践计算。本练习模拟了计算机在KMC循环中执行单次迭代的完整过程。通过亲手完成一个完整的驻留时间算法步骤，您能将抽象的算法流程与实际的数值应用联系起来，这在多尺度模拟中是一种常见的实践。",
            "id": "3851110",
            "problem": "在介观尺度上，使用动力学蒙特卡洛（KMC）方法和驻留时间算法（RTA），对面心立方金属中的单空位扩散过程进行建模。通过原子尺度模拟，分子动力学（MD）提供了事件特定的尝试频率，微动弹性带（NEB）方法提供了活化能垒。系统温度为 $T = 950\\ \\mathrm{K}$。玻尔兹曼常数为 $k_{B} = 8.617333262 \\times 10^{-5}\\ \\mathrm{eV/K}$。由于局域各向异性，可能发生四种不同的最近邻空位跳跃事件，其参数如下：\n- 事件 $1$：尝试频率 $\\nu_{1} = 4.8 \\times 10^{12}\\ \\mathrm{s}^{-1}$，活化能垒 $E_{1} = 0.62\\ \\mathrm{eV}$。\n- 事件 $2$：尝试频率 $\\nu_{2} = 6.1 \\times 10^{12}\\ \\mathrm{s}^{-1}$，活化能垒 $E_{2} = 0.59\\ \\mathrm{eV}$。\n- 事件 $3$：尝试频率 $\\nu_{3} = 4.0 \\times 10^{12}\\ \\mathrm{s}^{-1}$，活化能垒 $E_{3} = 0.68\\ \\mathrm{eV}$。\n- 事件 $4$：尝试频率 $\\nu_{4} = 7.5 \\times 10^{12}\\ \\mathrm{s}^{-1}$，活化能垒 $E_{4} = 0.73\\ \\mathrm{eV}$。\n\n假设KMC过程是一个连续时间马尔可夫链，具有无记忆的等待时间和与速率成正比的事件选择。使用过渡态理论和泊松过程的基本定义，计算四个事件中每个事件的KMC事件速率，使用单个均匀分布随机数 $u_{\\mathrm{sel}} = 0.74$ 选择一个事件，并使用单个均匀分布随机数 $u_{\\mathrm{time}} = 0.23$ 推进KMC时钟。\n\n将所选事件的索引和计算出的时间增量以行矩阵的形式报告。时间增量以秒为单位表示，并四舍五入到四位有效数字。",
            "solution": "用户要求使用驻留时间算法（RTA）实现动力学蒙特卡洛（KMC）模拟的单步计算。该问题是适定的，并且其科学基础在于计算材料科学和统计力学的原理。所有必需的参数均已提供。\n\nRTA的核心涉及两个主要步骤：\n1.  计算所有可能事件的速率，并根据这些速率选择一个事件。\n2.  根据所选事件的景观，将模拟时间推進一个适当的量。\n\n一个热激活事件 $i$ 的速率 $k_i$ 由过渡态理论（TST）描述，并由阿伦尼乌斯方程给出：\n$$\nk_i = \\nu_i \\exp\\left(-\\frac{E_i}{k_B T}\\right)\n$$\n其中 $\\nu_i$ 是尝试频率，$E_i$ 是活化能垒，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n从当前状态逃逸的总速率是所有单个事件速率的总和：\n$$\nK_{\\text{tot}} = \\sum_{i=1}^{N} k_i\n$$\n其中 $N$ 是可能事件的总数，在此情况下为 $4$。\n\n选择哪个事件 $m$ 将发生，取决于其对总速率的相对贡献。为此使用一个均匀随机数 $u_{\\text{sel}} \\in (0, 1]$。选择的事件 $m$ 满足：\n$$\n\\sum_{i=1}^{m-1} k_i  u_{\\text{sel}} K_{\\text{tot}} \\le \\sum_{i=1}^{m} k_i\n$$\n\n等待任一事件发生的过程是一个泊松过程。事件发生前的时间间隔 $\\Delta t$ 服从速率参数为 $K_{\\text{tot}}$ 的指数分布。这个时间增量可以使用逆变换采样法，通过第二个均匀随机数 $u_{\\text{time}} \\in (0, 1]$ 来计算：\n$$\n\\Delta t = -\\frac{\\ln(u_{\\text{time}})}{K_{\\text{tot}}}\n$$\n直接使用 $u_{\\text{time}}$ 是标准做法，因为它等同于使用 $1 - u_{\\text{time}}$，因为两者都在 $(0, 1)$ 上均匀分布。\n\n现在我们将此框架应用于给定的问题。\n\n首先，我们计算热能 $k_B T$。\n给定 $T = 950\\ \\mathrm{K}$ 和 $k_{B} = 8.617333262 \\times 10^{-5}\\ \\mathrm{eV/K}$：\n$$\nk_B T = (8.617333262 \\times 10^{-5}\\ \\mathrm{eV/K}) \\times (950\\ \\mathrm{K}) \\approx 0.08186467\\ \\mathrm{eV}\n$$\n\n接下来，我们使用提供的参数计算四个事件中每个事件的速率 $k_i$：\n$\\nu_{1} = 4.8 \\times 10^{12}\\ \\mathrm{s}^{-1}$，$E_{1} = 0.62\\ \\mathrm{eV}$\n$\\nu_{2} = 6.1 \\times 10^{12}\\ \\mathrm{s}^{-1}$，$E_{2} = 0.59\\ \\mathrm{eV}$\n$\\nu_{3} = 4.0 \\times 10^{12}\\ \\mathrm{s}^{-1}$，$E_{3} = 0.68\\ \\mathrm{eV}$\n$\\nu_{4} = 7.5 \\times 10^{12}\\ \\mathrm{s}^{-1}$，$E_{4} = 0.73\\ \\mathrm{eV}$\n\n速率为：\n$$\nk_1 = (4.8 \\times 10^{12}) \\exp\\left(-\\frac{0.62}{0.08186467}\\right) \\approx 2.4667 \\times 10^9\\ \\mathrm{s}^{-1}\n$$\n$$\nk_2 = (6.1 \\times 10^{12}) \\exp\\left(-\\frac{0.59}{0.08186467}\\right) \\approx 4.5233 \\times 10^9\\ \\mathrm{s}^{-1}\n$$\n$$\nk_3 = (4.0 \\times 10^{12}) \\exp\\left(-\\frac{0.68}{0.08186467}\\right) \\approx 0.9879 \\times 10^9\\ \\mathrm{s}^{-1}\n$$\n$$\nk_4 = (7.5 \\times 10^{12}) \\exp\\left(-\\frac{0.73}{0.08186467}\\right) \\approx 1.0055 \\times 10^9\\ \\mathrm{s}^{-1}\n$$\n\n总速率 $K_{\\text{tot}}$ 是这些单个速率的总和：\n$$\nK_{\\text{tot}} = k_1 + k_2 + k_3 + k_4 \\approx (2.4667 + 4.5233 + 0.9879 + 1.0055) \\times 10^{9}\\ \\mathrm{s}^{-1} \\approx 8.9834 \\times 10^{9}\\ \\mathrm{s}^{-1}\n$$\n\n现在，我们选择事件。给定用于选择的均匀随机数 $u_{\\text{sel}} = 0.74$。我们构建速率的累积和，并找到包含 $u_{\\text{sel}} K_{\\text{tot}}$ 的区间。\n$$\nu_{\\text{sel}} K_{\\text{tot}} = 0.74 \\times (8.9834 \\times 10^{9}\\ \\mathrm{s}^{-1}) \\approx 6.6477 \\times 10^{9}\\ \\mathrm{s}^{-1}\n$$\n\n我们来检查累积和：\n- 到事件 $1$ 的累积和：$S_1 = k_1 \\approx 2.4667 \\times 10^{9}\\ \\mathrm{s}^{-1}$。由于 $u_{\\text{sel}} K_{\\text{tot}} > S_1$，我们继续。\n- 到事件 $2$ 的累积和：$S_2 = k_1 + k_2 \\approx (2.4667 + 4.5233) \\times 10^{9}\\ \\mathrm{s}^{-1} = 6.9899 \\times 10^{9}\\ \\mathrm{s}^{-1}$。\n\n我们检查条件 $S_1  u_{\\text{sel}} K_{\\text{tot}} \\le S_2$：\n$$\n2.4667 \\times 10^{9}  6.6477 \\times 10^{9} \\le 6.9899 \\times 10^{9}\n$$\n此条件满足。因此，所选事件为事件 $m=2$。\n\n最后，我们推进KMC时钟。给定用于时间的均匀随机数 $u_{\\text{time}} = 0.23$。时间增量 $\\Delta t$ 计算如下：\n$$\n\\Delta t = -\\frac{\\ln(u_{\\text{time}})}{K_{\\text{tot}}} = -\\frac{\\ln(0.23)}{8.9834 \\times 10^{9}\\ \\mathrm{s}^{-1}}\n$$\n$$\n\\Delta t \\approx -\\frac{-1.469676}{8.9834 \\times 10^{9}\\ \\mathrm{s}^{-1}} \\approx 1.6360 \\times 10^{-10}\\ \\mathrm{s}\n$$\n问题要求时间增量四舍五入到四位有效数字。\n$$\n\\Delta t \\approx 1.636 \\times 10^{-10}\\ \\mathrm{s}\n$$\n\n结果包括所选事件索引（为 $2$）和时间增量（为 $1.636 \\times 10^{-10}\\ \\mathrm{s}$）。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2  1.636 \\times 10^{-10} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "最后的这个练习旨在连接单个KMC步骤的微观动力学与系统的长期宏观行为。练习的目标是验证通过长时间KMC轨迹所测量的系统通量，是否能够收敛到理论预测的精确稳态通量。这种将模拟结果与解析解进行比较的方法是代码验证的经典范例，也是任何计算科学家都必须掌握的关键技能。",
            "id": "3851132",
            "problem": "考虑一个具有3个状态的连续时间马尔可夫链，状态标记为$0$、$1$和$2$，形成一个单向循环。唯一允许的跃迁是$0 \\to 1$、$1 \\to 2$和$2 \\to 0$。跃迁速率如下：从状态$0$到状态$1$的速率为$k$，从状态$1$到状态$2$的速率为$k$，从状态$2$到状态$0$的速率为$2k$。速率常数$k$的单位是$\\mathrm{s}^{-1}$，时间应以秒为单位表示。\n\n您的任务是基于连续时间马尔可夫链的基本原理以及使用驻留时间算法（RTA）的标准动力学蒙特卡洛（KMC）方法，完成两项工作：\n\n1. 仅使用连续时间马尔可夫链的稳态概率流平衡和状态概率归一化，推导出沿循环中任意单条边的稳态通量。穿过一条边的稳态通量定义为在长时间极限下，单位时间内穿过该边的预期跃迁次数，以$\\mathrm{s}^{-1}$表示。\n\n2. 使用驻留时间算法（RTA）实现动力学蒙特卡洛（KMC）模拟，以生成该过程的轨迹并测量穿过每条边的通量。在RTA中，对于总出射速率为$R$的当前状态，到下一个事件的等待时间$\\Delta t$是参数为$R$的指数分布随机变量，下一个事件的选择概率与当前状态下所有可用事件的速率成正比。\n\n您的程序必须：\n- 计算在步骤1中推导的解析稳态通量。\n- 使用RTA对多个参数集模拟长轨迹。\n- 对于每个参数集，测量穿过每条边的通量，即穿过该边的总跃迁次数除以总模拟时间（单位为$\\mathrm{s}^{-1}$）。\n- 使用相对容差验证测量的通量与解析稳态通量之间的一致性。\n\n所有类时间量的要求单位是秒，所有速率和通量必须以$\\mathrm{s}^{-1}$表示。每个测试用例的最终答案将是布尔值，表示在指定容差内是否一致；布尔值是无单位的。\n\n您可以假定的基本原理：\n- 状态概率$p_i(t)$根据连续时间马尔可夫链的主方程演化。\n- 在稳态下，时间导数$\\mathrm{d}p_i/\\mathrm{d}t$为零，流入每个状态的概率流与流出该状态的概率流相平衡。\n- 在驻留时间算法中，对于总出射速率为$R$的当前状态，等待时间的指数分布均值为$1/R$，事件发生的概率与其速率成正比。\n\n不要使用预设答案的快捷公式。从上述基本原理进行推导。\n\n测试套件规范：\n- 对于每个测试用例，给定一个四元组$(k, \\text{seed}, \\alpha, \\epsilon)$，其中$k$是速率常数（单位为$\\mathrm{s}^{-1}$），$\\text{seed}$是整数伪随机种子，$\\alpha$是无量纲的缩放因子，通过$T = \\alpha/k$（单位为秒）设置模拟时域$T$，$\\epsilon$是相对容差（无量纲）。初始状态始终为$0$。对于每个测试用例，运行RTA直到累积时间首次超过$T$，然后使用实际的总模拟时间计算测量的通量。\n- 对于每个测试用例，程序应返回一个布尔值，当且仅当以下两个条件都成立时，该值为真：\n  1. 三个单边测量通量与解析稳态通量的最大相对偏差小于或等于$\\epsilon$。\n  2. 总事件速率（总跃迁次数除以总模拟时间）与解析稳态通量的三倍之间的相对偏差小于或等于$\\epsilon$。\n\n提供以下三个测试用例：\n- 测试 $1$：$(k, \\text{seed}, \\alpha, \\epsilon) = (1.0, 42, 200000, 10^{-2})$。\n- 测试 $2$：$(k, \\text{seed}, \\alpha, \\epsilon) = (10^{-6}, 7, 200000, 10^{-2})$。\n- 测试 $3$：$(k, \\text{seed}, \\alpha, \\epsilon) = (10^{3}, 2023, 200000, 10^{-2})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述测试顺序排列的结果，形式为逗号分隔的列表并用方括号括起。例如，一个有效的输出形式为$[\\text{True},\\text{False},\\text{True}]$。",
            "solution": "该问题是有效的，因为它在科学上基于连续时间马尔可夫链和动力学蒙特卡洛方法的原理，问题陈述清晰，提供了所有必要信息，并且具有明确、可验证的客观标准。\n\n解决方案分为两部分：首先是稳态通量的解析推导，其次是设计一个动力学蒙特卡洛（KMC）模拟来验证这一结果。\n\n### 1. 稳态通量的解析推导\n\n该系统是一个具有三个状态（标记为$0$、$1$和$2$）的连续时间马尔可夫链。允许的跃迁及其速率为：\n-   $0 \\to 1$，速率为$k_{0 \\to 1} = k$\n-   $1 \\to 2$，速率为$k_{1 \\to 2} = k$\n-   $2 \\to 0$，速率为$k_{2 \\to 0} = 2k$\n\n设$p_0(t)$、$p_1(t)$和$p_2(t)$分别为系统在时间$t$处于状态$0$、$1$和$2$的概率。这些概率的演化由主方程描述。在稳态下，概率是恒定的，即对于$i \\in \\{0, 1, 2\\}$，有$\\frac{\\mathrm{d}p_i}{\\mathrm{d}t} = 0$。这意味着对于每个状态，流入的总概率速率必须等于流出的总概率速率。设$p_0$、$p_1$、$p_2$表示稳态概率。\n\n对于状态$0$，流入来自状态$2$，流出至状态$1$。平衡方程为：\n$$\n\\text{Flow in} = \\text{Flow out} \\implies p_2 \\cdot k_{2 \\to 0} = p_0 \\cdot k_{0 \\to 1}\n$$\n代入给定的速率：\n$$\np_2 \\cdot (2k) = p_0 \\cdot k \\implies p_0 = 2p_2 \\quad (1)\n$$\n\n对于状态$1$，流入来自状态$0$，流出至状态$2$。平衡方程为：\n$$\np_0 \\cdot k_{0 \\to 1} = p_1 \\cdot k_{1 \\to 2}\n$$\n代入速率：\n$$\np_0 \\cdot k = p_1 \\cdot k \\implies p_0 = p_1 \\quad (2)\n$$\n\n对于状态$2$，流入来自状态$1$，流出至状态$0$。平衡方程为：\n$$\np_1 \\cdot k_{1 \\to 2} = p_2 \\cdot k_{2 \\to 0}\n$$\n代入速率：\n$$\np_1 \\cdot k = p_2 \\cdot (2k) \\implies p_1 = 2p_2 \\quad (3)\n$$\n请注意，这三个方程是线性相关的。例如，结合(1)和(2)得到$p_1 = 2p_2$，这与(3)相同。我们需要一个额外的约束条件，即概率的归一化：所有状态的概率之和必须为$1$。\n$$\np_0 + p_1 + p_2 = 1 \\quad (4)\n$$\n我们可以使用方程(1)和(3)将$p_0$和$p_1$用$p_2$表示：$p_0 = 2p_2$和$p_1 = 2p_2$。将这些代入归一化方程(4)：\n$$\n2p_2 + 2p_2 + p_2 = 1 \\implies 5p_2 = 1 \\implies p_2 = \\frac{1}{5}\n$$\n现在我们可以求出其他概率：\n$$\np_0 = 2p_2 = \\frac{2}{5}\n$$\n$$\np_1 = 2p_2 = \\frac{2}{5}\n$$\n稳态概率为$p_0 = 2/5$，$p_1 = 2/5$和$p_2 = 1/5$。\n\n从状态$i$到状态$j$穿过一条边的稳态通量$J_{i \\to j}$定义为单位时间内的预期跃迁次数。它由跃迁速率乘以处于源状态的概率给出：$J_{i \\to j} = k_{i \\to j} \\cdot p_i$。\n让我们计算循环中每条边的通量：\n-   $0 \\to 1$的通量：$J_{0 \\to 1} = k_{0 \\to 1} \\cdot p_0 = k \\cdot \\frac{2}{5} = \\frac{2k}{5}$。\n-   $1 \\to 2$的通量：$J_{1 \\to 2} = k_{1 \\to 2} \\cdot p_1 = k \\cdot \\frac{2}{5} = \\frac{2k}{5}$。\n-   $2 \\to 0$的通量：$J_{2 \\to 0} = k_{2 \\to 0} \\cdot p_2 = (2k) \\cdot \\frac{1}{5} = \\frac{2k}{5}$。\n\n正如稳态下单向循环所预期的那样，所有边的通量都是相同的。解析稳态通量为：\n$$\nJ_{ss} = \\frac{2k}{5}\n$$\n\n### 2. 动力学蒙特卡洛模拟设计\n\n模拟将使用驻留时间算法（RTA）进行，这是一种模拟连续时间马尔可夫链轨迹的精确方法。\n\n**算法步骤：**\n1.  **初始化**：\n    -   设置初始状态`current_state` $= 0$。\n    -   设置初始时间`total_time` $= 0$。\n    -   初始化跃迁计数器$N_{0 \\to 1}$、$N_{1 \\to 2}$、$N_{2 \\to 0}$为$0$。\n    -   定义每个状态下可能的跃迁及其速率。在这个单向系统中，任何给定状态只有一个可能的出口。\n    -   从状态$i$的总出射速率为$R_i = \\sum_{j} k_{i \\to j}$。\n        -   $R_0 = k_{0 \\to 1} = k$。\n        -   $R_1 = k_{1 \\to 2} = k$。\n        -   $R_2 = k_{2 \\to 0} = 2k$。\n\n2.  **模拟循环**：模拟迭代进行，直到`total_time`超过指定的时域$T = \\alpha/k$。\n    -   **a. 时间步长生成**：在当前状态$i$，从参数为$R_i$的指数分布中抽取一个时间步长$\\Delta t$。这在计算上通过生成一个均匀随机数$u \\in (0, 1)$并计算以下公式实现：\n        $$\n        \\Delta t = -\\frac{\\ln(u)}{R_i}\n        $$\n    -   **b. 事件选择**：从状态$i$选择下一个事件（跃迁）。在这个问题中，选择是确定性的，因为每个状态只有一个出射路径：\n        -   如果当前状态是$0$，下一个状态是$1$。\n        -   如果当前状态是$1$，下一个状态是$2$。\n        -   如果当前状态是$2$，下一个状态是$0$。\n    -   **c. 系统更新**：\n        -   推进总模拟时间：`total_time` $\\leftarrow$ `total_time` + $\\Delta t$。\n        -   相应的跃迁计数器递增（例如，$N_{0 \\to 1} \\leftarrow N_{0 \\to 1} + 1$）。\n        -   系统状态更新为新状态。\n\n3.  **测量与验证**：循环终止后，计算测量的通量并与解析结果进行比较。\n    -   总模拟时间为$t_{final} = \\text{total\\_time}$。\n    -   每条边的测量通量是该跃迁的总计数除以总时间：\n        $$\n        J_{0 \\to 1}^{\\text{meas}} = \\frac{N_{0 \\to 1}}{t_{final}}, \\quad J_{1 \\to 2}^{\\text{meas}} = \\frac{N_{1 \\to 2}}{t_{final}}, \\quad J_{2 \\to 0}^{\\text{meas}} = \\frac{N_{2 \\to 0}}{t_{final}}\n        $$\n    -   总事件速率测量为：\n        $$\n        R_{\\text{total}}^{\\text{meas}} = \\frac{N_{0 \\to 1} + N_{1 \\to 2} + N_{2 \\to 0}}{t_{final}}\n        $$\n    -   **验证检查**：如果模拟在相对容差$\\epsilon$内通过了与解析预测（$J_{ss} = 2k/5$和$R_{\\text{total}}^{\\text{analytical}} = 3 J_{ss} = 6k/5$）的两项检查，则认为模拟成功。\n        -   **检查 1**：三个独立测量的通量与解析通量的最大相对偏差不得超过$\\epsilon$。\n            $$\n            \\max \\left( \\frac{|J_{0 \\to 1}^{\\text{meas}} - J_{ss}|}{J_{ss}}, \\frac{|J_{1 \\to 2}^{\\text{meas}} - J_{ss}|}{J_{ss}}, \\frac{|J_{2 \\to 0}^{\\text{meas}} - J_{ss}|}{J_{ss}} \\right) \\le \\epsilon\n            $$\n        -   **检查 2**：测量的总事件速率与解析总事件速率的相对偏差不得超过$\\epsilon$。\n            $$\n            \\frac{|R_{\\text{total}}^{\\text{meas}} - 3J_{ss}|}{3J_{ss}} \\le \\epsilon\n            $$\n    -   一个测试用例的最终布尔结果当且仅当两项检查都通过时为`True`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kinetic Monte Carlo problem for the given test cases.\n    It derives the analytical steady-state flux, simulates the system using the\n    Residence Time Algorithm, measures the fluxes, and verifies the agreement\n    between simulation and theory.\n    \"\"\"\n    \n    # Test suite specification:\n    # (k, seed, alpha, epsilon)\n    test_cases = [\n        (1.0, 42, 200000, 10**-2),\n        (10**-6, 7, 200000, 10**-2),\n        (10**3, 2023, 200000, 10**-2),\n    ]\n\n    results = []\n    \n    for k, seed, alpha, epsilon in test_cases:\n        # Analytical steady-state flux derivation: J_ss = 2*k/5\n        J_ss = 2.0 * k / 5.0\n        \n        # Setup KMC simulation\n        rng = np.random.default_rng(seed)\n        \n        current_state = 0\n        total_time = 0.0\n        \n        # Transition counters for 0-1, 1-2, 2-0\n        transition_counts = {(0, 1): 0, (1, 2): 0, (2, 0): 0}\n        \n        # Define rates and the deterministic transition map for the cycle\n        # Total exit rates R_i for each state i\n        exit_rates = {0: k, 1: k, 2: 2.0 * k}\n        \n        # The next state j given current state i\n        next_state_map = {0: 1, 1: 2, 2: 0}\n        \n        # Simulation horizon T = alpha / k\n        T_horizon = alpha / k\n        \n        # KMC loop using Residence Time Algorithm (RTA)\n        while total_time  T_horizon:\n            # Get total exit rate from the current state\n            R_current = exit_rates[current_state]\n            \n            # Draw a time step from an exponential distribution with mean 1/R_current\n            # dt = -ln(u) / R_current, where u is from U(0,1)\n            u = rng.random()\n            if u == 0.0:  # Avoid log(0)\n                u = np.finfo(float).eps\n            dt = -np.log(u) / R_current\n            \n            total_time += dt\n            \n            # Determine the next state (deterministic in this unidirectional cycle)\n            next_state = next_state_map[current_state]\n            \n            # Record the transition\n            transition_counts[(current_state, next_state)] += 1\n            \n            # Update the state\n            current_state = next_state\n\n        # Post-simulation analysis\n        # Measured fluxes\n        J_meas_01 = transition_counts[(0, 1)] / total_time\n        J_meas_12 = transition_counts[(1, 2)] / total_time\n        J_meas_20 = transition_counts[(2, 0)] / total_time\n        \n        # Verification Check 1: Maximum relative deviation of per-edge fluxes\n        if J_ss == 0: # Avoid division by zero, although not expected in these tests\n            max_rel_dev = float('inf') if any(j != 0 for j in [J_meas_01, J_meas_12, J_meas_20]) else 0.0\n        else:\n            rel_dev_01 = abs(J_meas_01 - J_ss) / J_ss\n            rel_dev_12 = abs(J_meas_12 - J_ss) / J_ss\n            rel_dev_20 = abs(J_meas_20 - J_ss) / J_ss\n            max_rel_dev = max(rel_dev_01, rel_dev_12, rel_dev_20)\n        \n        cond1 = max_rel_dev = epsilon\n        \n        # Verification Check 2: Relative deviation of the total event rate\n        total_transitions = sum(transition_counts.values())\n        total_rate_meas = total_transitions / total_time\n        total_rate_analytical = 3.0 * J_ss\n        \n        if total_rate_analytical == 0: # Avoid division by zero\n            rel_dev_total = float('inf') if total_rate_meas != 0 else 0.0\n        else:\n            rel_dev_total = abs(total_rate_meas - total_rate_analytical) / total_rate_analytical\n            \n        cond2 = rel_dev_total = epsilon\n        \n        # Final result for the test case\n        results.append(cond1 and cond2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}