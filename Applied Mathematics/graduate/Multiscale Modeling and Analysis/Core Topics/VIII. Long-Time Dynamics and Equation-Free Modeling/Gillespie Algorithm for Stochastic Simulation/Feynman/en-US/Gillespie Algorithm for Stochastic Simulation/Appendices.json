{
    "hands_on_practices": [
        {
            "introduction": "Before automating any process, it is essential to understand its fundamental mechanics. This first practice exercise grounds your understanding of the Gillespie algorithm by walking you through a single, complete simulation step by hand. By manually calculating the propensities for a simple gene expression network, generating the waiting time, and selecting the next reaction, you will gain a concrete feel for how the algorithm advances time and state based on stochastic principles .",
            "id": "4388732",
            "problem": "Consider a constitutive gene expression microcircuit in a single cell with two molecular species, messenger ribonucleic acid ($M$) and protein ($P$). The system is modeled as a continuous-time Markov chain governed by the Chemical Master Equation (CME) under mass-action kinetics. The Stochastic Simulation Algorithm (SSA; Gillespie algorithm) is applied. The reaction network is:\n1. $\\varnothing \\rightarrow M$ with stochastic rate constant $c_{1}$,\n2. $M \\rightarrow M + P$ with stochastic rate constant $c_{2}$,\n3. $M \\rightarrow \\varnothing$ with stochastic rate constant $c_{3}$,\n4. $P \\rightarrow \\varnothing$ with stochastic rate constant $c_{4}$.\n\nAssume the stochastic rate constants are $c_{1} = 0.05\\,\\mathrm{s}^{-1}$, $c_{2} = 0.50\\,\\mathrm{s}^{-1}$, $c_{3} = 0.10\\,\\mathrm{s}^{-1}$, and $c_{4} = 0.02\\,\\mathrm{s}^{-1}$. The initial molecular counts at time $t(0)$ are $x_{M}(0) = 3$ and $x_{P}(0) = 10$, and the initial time is $t(0) = 0\\,\\mathrm{s}$. For a single SSA iteration, use two independent uniform random variates on $(0,1)$ given by $r_{1} = \\exp(-2)$ and $r_{2} = 0.925$.\n\nStarting from the foundational definitions of propensity functions in the CME and the memoryless property of exponential waiting times governing SSA reaction times, perform one SSA iteration: compute propensities $a_{\\mu}(x)$ for $\\mu \\in \\{1,2,3,4\\}$, the total propensity $a_{0}$, the waiting time $\\tau$, the index $j$ of the next reaction, and the updated time and state after firing reaction $j$. Round the waiting time and the updated time to four significant figures, and express the updated time in seconds. Provide the final numerical values for $a_{0}$, $\\tau$, $j$, the updated time $t(0)+\\tau$, and the updated state $(x_{M}, x_{P})$.",
            "solution": "The problem requires the execution of a single iteration of the Stochastic Simulation Algorithm (SSA), also known as the Gillespie algorithm, for a given gene expression network. The state of the system is described by the vector of molecular counts $x(t) = (x_{M}(t), x_{P}(t))$, where $x_{M}$ is the number of messenger RNA molecules and $x_{P}$ is the number of protein molecules.\n\nThe four chemical reactions are:\n1. $R_1: \\varnothing \\xrightarrow{c_1} M$\n2. $R_2: M \\xrightarrow{c_2} M + P$\n3. $R_3: M \\xrightarrow{c_3} \\varnothing$\n4. $R_4: P \\xrightarrow{c_4} \\varnothing$\n\nThe initial state at time $t(0) = 0\\,\\mathrm{s}$ is given as $x(0) = (x_{M}(0), x_{P}(0)) = (3, 10)$. The stochastic rate constants are $c_{1} = 0.05\\,\\mathrm{s}^{-1}$, $c_{2} = 0.50\\,\\mathrm{s}^{-1}$, $c_{3} = 0.10\\,\\mathrm{s}^{-1}$, and $c_{4} = 0.02\\,\\mathrm{s}^{-1}$.\n\nThe first step of the SSA is to calculate the propensity function $a_{\\mu}(x)$ for each reaction $\\mu \\in \\{1, 2, 3, 4\\}$. The propensity function represents the probability, per unit time, that a specific reaction occurs given the current state $x$. For mass-action kinetics, the propensities are:\n- $a_{1}(x) = c_{1}$ (zeroth-order reaction)\n- $a_{2}(x) = c_{2} x_{M}$ (first-order reaction)\n- $a_{3}(x) = c_{3} x_{M}$ (first-order reaction)\n- $a_{4}(x) = c_{4} x_{P}$ (first-order reaction)\n\nWe evaluate these propensities at the initial state $x(0) = (3, 10)$:\n- $a_{1}(x(0)) = 0.05\\,\\mathrm{s}^{-1}$\n- $a_{2}(x(0)) = (0.50\\,\\mathrm{s}^{-1})(3) = 1.50\\,\\mathrm{s}^{-1}$\n- $a_{3}(x(0)) = (0.10\\,\\mathrm{s}^{-1})(3) = 0.30\\,\\mathrm{s}^{-1}$\n- $a_{4}(x(0)) = (0.02\\,\\mathrm{s}^{-1})(10) = 0.20\\,\\mathrm{s}^{-1}$\n\nThe total propensity, $a_{0}(x)$, is the sum of the individual propensities. It represents the rate of any reaction occurring.\n$$a_{0}(x(0)) = \\sum_{\\mu=1}^{4} a_{\\mu}(x(0)) = 0.05 + 1.50 + 0.30 + 0.20 = 2.05\\,\\mathrm{s}^{-1}$$\n\nThe second step is to generate two independent random numbers, $r_{1}$ and $r_{2}$, from a uniform distribution on $(0, 1)$. These are given as $r_{1} = \\exp(-2)$ and $r_{2} = 0.925$.\n\nThe waiting time $\\tau$ until the next reaction is an exponentially distributed random variable with rate $a_{0}(x)$. The memoryless property of the exponential distribution is fundamental here. We can generate $\\tau$ using the inversion method:\n$$\\tau = \\frac{1}{a_{0}(x)} \\ln\\left(\\frac{1}{r_{1}}\\right) = -\\frac{\\ln(r_{1})}{a_{0}(x)}$$\nSubstituting the given values for $r_{1}$ and the calculated $a_{0}(x(0))$:\n$$\\tau = -\\frac{\\ln(\\exp(-2))}{2.05} = -\\frac{-2}{2.05} = \\frac{2}{2.05} \\approx 0.975609756\\,\\mathrm{s}$$\nRounding to four significant figures as required, we get $\\tau \\approx 0.9756\\,\\mathrm{s}$.\n\nThe next reaction to occur, with index $j$, is determined using the second random number $r_{2}$. The index $j$ is the smallest integer satisfying the condition:\n$$\\sum_{\\mu=1}^{j} a_{\\mu}(x) \\ge r_{2} \\cdot a_{0}(x)$$\nFirst, we compute the target value:\n$$r_{2} \\cdot a_{0}(x(0)) = 0.925 \\cdot 2.05 = 1.89625$$\nNow we check the cumulative sum of propensities:\n- For $j=1$: $\\sum_{\\mu=1}^{1} a_{\\mu} = a_{1} = 0.05$. This is less than $1.89625$.\n- For $j=2$: $\\sum_{\\mu=1}^{2} a_{\\mu} = a_{1} + a_{2} = 0.05 + 1.50 = 1.55$. This is less than $1.89625$.\n- For $j=3$: $\\sum_{\\mu=1}^{3} a_{\\mu} = a_{1} + a_{2} + a_{3} = 1.55 + 0.30 = 1.85$. This is less than $1.89625$.\n- For $j=4$: $\\sum_{\\mu=1}^{4} a_{\\mu} = a_{1} + a_{2} + a_{3} + a_{4} = 1.85 + 0.20 = 2.05$. This is greater than or equal to $1.89625$.\n\nThe condition is satisfied for $j=4$. Thus, the next reaction to fire is $R_4$.\n\nThe final step is to update the system time and state.\nThe new time $t'$ is the sum of the old time and the waiting time $\\tau$:\n$$t' = t(0) + \\tau = 0\\,\\mathrm{s} + 0.9756\\,\\mathrm{s} = 0.9756\\,\\mathrm{s}$$\n\nThe new state $x'$ is obtained by adding the state-change vector $\\nu_j$ for reaction $j=4$ to the old state $x(0)$. The reaction $R_4: P \\rightarrow \\varnothing$ corresponds to a decrease of one molecule of protein $P$. The state-change vector is $\\nu_4 = (0, -1)$.\n$$x' = x(0) + \\nu_4 = (3, 10) + (0, -1) = (3, 9)$$\nThe updated state is $x_{M}' = 3$ and $x_{P}' = 9$.\n\nIn summary, the results of one SSA iteration are:\n- Total propensity $a_{0} = 2.05\\,\\mathrm{s}^{-1}$.\n- Waiting time $\\tau \\approx 0.9756\\,\\mathrm{s}$.\n- Index of next reaction $j=4$.\n- Updated time $t' \\approx 0.9756\\,\\mathrm{s}$.\n- Updated state $(x_{M}', x_{P}') = (3, 9)$.\n\nThese values are compiled for the final answer.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.05 & 0.9756 & 4 & 0.9756 & 3 & 9\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Moving from manual calculation to a functional computer program reveals the need to handle real-world implementation details and edge cases. This practice focuses on building a robust Gillespie simulator that correctly manages termination conditions. You will implement logic to handle absorbing states—where no more reactions can occur—and to stop the simulation precisely at a specified end time, ensuring your code is both accurate and practical for finite-time analysis .",
            "id": "3935575",
            "problem": "Consider the Direct method of the Gillespie stochastic simulation algorithm (SSA) for discrete-state, continuous-time reaction networks used in synthetic biology modeling. A reaction network consists of a finite set of reaction channels, each with a propensity function that depends on the current molecular counts. At any state $\\mathbf{x}$, the total hazard of any reaction occurring is the sum of reaction propensities, denoted by $a_0(\\mathbf{x})$. A rigorous interpretation of the case $a_0(\\mathbf{x}) = 0$ is required to ensure correct modeling of absorbing states and termination behavior.\n\nStarting from first principles of continuous-time Markov jump processes and mass-action kinetics for discrete molecules, derive the conditions under which the system is absorbing and how the Direct method should stop when $a_0(\\mathbf{x}) = 0$. Then, implement a program that robustly detects and handles $a_0(\\mathbf{x}) = 0$ both initially and during the simulation, and that stops at a user-specified final time $T_{\\mathrm{end}}$ if $a_0(\\mathbf{x}) > 0$ but the next reaction time would exceed $T_{\\mathrm{end}}$.\n\nThe implementation must:\n- Use discrete mass-action kinetics with integer molecular counts. For each reaction, define a nonnegative integer reactant stoichiometry vector and a positive rate constant in $\\mathrm{s}^{-1}$. The propensity of a reaction should be computed as the rate constant multiplied by the product of binomial terms $\\binom{x_i}{r_i}$ across species, treating $\\binom{x_i}{0} = 1$ and $\\binom{x_i}{r_i} = 0$ whenever $x_i < r_i$.\n- At each step, compute $a_0(\\mathbf{x})$; if $a_0(\\mathbf{x}) = 0$, interpret the state $\\mathbf{x}$ as absorbing and stop immediately.\n- If $a_0(\\mathbf{x}) > 0$, draw an exponentially distributed waiting time by sampling with the correct hazard, and select the next reaction index by a probability proportional to individual propensities. If the proposed next reaction time would exceed $T_{\\mathrm{end}}$, do not fire any reaction and stop at $T_{\\mathrm{end}}$.\n- Return, for each test case, the number of fired reactions as an integer, whether the run ended in an absorbing state as a boolean, and the final time as a float expressed in seconds.\n\nExpress all times in $\\mathrm{s}$. Angles are not involved. There are no percentages in this problem.\n\nImplement the program to run the following test suite, each defined by a reaction network, an initial state, a final time, and a pseudorandom seed. For mass-action kinetics, use the binomial-based discrete formulation for propensities as described above.\n\nTest Suite:\n- Case $1$ (Absorption reached during simulation): Single-species degradation. Species $X$ with one reaction $X \\to \\varnothing$ having rate constant $c = 1.0\\,\\mathrm{s}^{-1}$. Initial count $x(0) = 3$. Final time $T_{\\mathrm{end}} = 2.0\\,\\mathrm{s}$. Seed $12345$.\n- Case $2$ (Initial absorbing state): Single-species dimerization to inert. Species $X$ with one reaction $2X \\to \\varnothing$ having rate constant $c = 1.0\\,\\mathrm{s}^{-1}$. Initial count $x(0) = 1$. Final time $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$. Seed $42$.\n- Case $3$ (Never absorbing before final time): Birth-death. Species $X$ with two reactions $\\varnothing \\to X$ at rate $k_0 = 2.0\\,\\mathrm{s}^{-1}$ and $X \\to \\varnothing$ at rate $k_1 = 1.0\\,\\mathrm{s}^{-1}$. Initial count $x(0) = 0$. Final time $T_{\\mathrm{end}} = 1.0\\,\\mathrm{s}$. Seed $314159$.\n- Case $4$ (Absorption after a finite chain): Two-species chain. Species $X,Y$ with reactions $X \\to Y$ at rate $c_1 = 0.5\\,\\mathrm{s}^{-1}$ and $Y \\to \\varnothing$ at rate $c_2 = 0.7\\,\\mathrm{s}^{-1}$. Initial counts $(x(0), y(0)) = (1,0)$. Final time $T_{\\mathrm{end}} = 5.0\\,\\mathrm{s}$. Seed $2024$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test-case result must itself be a list of the form $[N_{\\mathrm{events}}, \\mathrm{absorbed}, t_{\\mathrm{final}}]$, where $N_{\\mathrm{events}}$ is an integer, $\\mathrm{absorbed}$ is a boolean, and $t_{\\mathrm{final}}$ is a float in seconds. For example, the entire output line should look like $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$.",
            "solution": "The user has provided a valid problem statement. It is scientifically grounded, well-posed, and objective. It consists of a request to derive the theoretical basis for handling absorbing states in the Gillespie stochastic simulation algorithm (SSA) and to implement the algorithm to solve a series of test cases. All parameters, conditions, and requirements are clearly defined.\n\n### Theoretical Derivation and Algorithmic Design\n\nThe Gillespie Stochastic Simulation Algorithm (SSA) is a method for generating a statistically correct trajectory of a stochastic chemical system, modeled as a continuous-time, discrete-state Markov jump process. The state of the system is a vector $\\mathbf{X}(t) = (X_1(t), X_2(t), \\ldots, X_N(t))$ representing the integer counts of $N$ molecular species at time $t$. The system evolves through a series of $M$ reaction channels.\n\n#### Waiting Time to the Next Reaction\n\nThe core of the SSA is based on the **propensity function**, $a_j(\\mathbf{x})$, for each reaction $j \\in \\{1, \\ldots, M\\}$. The quantity $a_j(\\mathbf{x})dt$ represents the probability that reaction $j$ will occur in the infinitesimal time interval $[t, t+dt)$, given the system is in state $\\mathbf{x}$ at time $t$. The propensity function for discrete mass-action kinetics, as specified, is given by:\n$$ a_j(\\mathbf{x}) = c_j \\prod_{i=1}^{N} \\binom{x_i}{r_{ij}} $$\nwhere $c_j$ is the stochastic rate constant for reaction $j$, $x_i$ is the number of molecules of species $i$, and $r_{ij}$ is the reactant stoichiometry, i.e., the number of molecules of species $i$ consumed by one instance of reaction $j$. The binomial coefficient $\\binom{n}{k}$ is defined as $0$ if $k > n$, which naturally ensures that a reaction cannot occur if there are insufficient reactants.\n\nThe total propensity, or hazard, $a_0(\\mathbf{x})$, is the sum of the propensities of all possible reactions:\n$$ a_0(\\mathbf{x}) = \\sum_{j=1}^{M} a_j(\\mathbf{x}) $$\nThe quantity $a_0(\\mathbf{x})dt$ is the probability that *any* reaction will occur in the interval $[t, t+dt)$.\n\nTo determine *when* the next reaction occurs, we seek the probability distribution of the waiting time $\\tau$. Let $P_0(\\tau, \\mathbf{x})$ be the probability that, starting in state $\\mathbf{x}$ at time $t$, no reaction occurs in the interval $[t, t+\\tau)$. For no reaction to occur in $[t, t+\\tau+d\\tau)$, no reaction must occur in $[t, t+\\tau)$ AND no reaction must occur in $[t+\\tau, t+\\tau+d\\tau)$. Since the process is Markovian, these events are independent. The probability of no reaction in $[t+\\tau, t+\\tau+d\\tau)$ is $1 - a_0(\\mathbf{x})d\\tau$. Therefore:\n$$ P_0(\\tau+d\\tau, \\mathbf{x}) = P_0(\\tau, \\mathbf{x}) (1 - a_0(\\mathbf{x})d\\tau) $$\nRearranging gives the differential equation:\n$$ \\frac{P_0(\\tau+d\\tau, \\mathbf{x}) - P_0(\\tau, \\mathbf{x})}{d\\tau} = \\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = -a_0(\\mathbf{x}) P_0(\\tau, \\mathbf{x}) $$\nWith the initial condition $P_0(0, \\mathbf{x}) = 1$ (the probability of no reaction in zero time is $1$), the solution is:\n$$ P_0(\\tau, \\mathbf{x}) = e^{-a_0(\\mathbf{x})\\tau} $$\nThis is the survival function for the waiting time $\\tau$. The probability density function $p(\\tau | \\mathbf{x})$ is found by differentiation:\n$$ p(\\tau | \\mathbf{x}) = -\\frac{dP_0(\\tau, \\mathbf{x})}{d\\tau} = a_0(\\mathbf{x}) e^{-a_0(\\mathbf{x})\\tau} $$\nThis is the probability density function of an exponential distribution with rate parameter $a_0(\\mathbf{x})$. To sample a value for $\\tau$, we use inverse transform sampling. We draw a uniform random number $u_1 \\in (0,1)$ and set the cumulative distribution $F(\\tau) = 1 - e^{-a_0(\\mathbf{x})\\tau}$ equal to $u_1$. Solving for $\\tau$:\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{1-u_1}\\right) $$\nSince $1-u_1$ is also uniformly distributed on $(0,1)$, we can simplify this to:\n$$ \\tau = \\frac{1}{a_0(\\mathbf{x})} \\ln\\left(\\frac{1}{u_1}\\right) $$\n\n#### The Absorbing State Condition: $a_0(\\mathbf{x}) = 0$\n\nA critical insight arises from examining the case where $a_0(\\mathbf{x}) = 0$.\nThe mean waiting time to the next reaction is $E[\\tau] = 1/a_0(\\mathbf{x})$. If $a_0(\\mathbf{x}) = 0$, the mean waiting time becomes infinite. The probability density function $p(\\tau | \\mathbf{x})$ becomes $0$ for any finite $\\tau$, meaning the probability of a reaction occurring in any finite time interval is zero. The system will remain in state $\\mathbf{x}$ indefinitely. Such a state is called an **absorbing state**.\n\nSince all propensities $a_j(\\mathbf{x})$ are non-negative, the condition $a_0(\\mathbf{x}) = \\sum_j a_j(\\mathbf{x}) = 0$ holds if and only if $a_j(\\mathbf{x}) = 0$ for all reactions $j = 1, \\ldots, M$. Given the definition of the propensity function, $a_j(\\mathbf{x})$ becomes $0$ if, for at least one of its reactant species $i$, the number of available molecules $x_i$ is less than the number required by the reaction, $r_{ij}$. Thus, an absorbing state is reached when every reaction in the network is \"starved\" of at least one of its required reactants.\n\nThe SSA implementation must therefore check the value of $a_0(\\mathbf{x})$ at each step. If $a_0(\\mathbf{x}) = 0$, the simulation must terminate immediately, and the state must be flagged as absorbing. This condition can be met either at the beginning of the simulation (if the initial state is absorbing) or at any subsequent step.\n\n#### Selection of the Next Reaction\n\nIf $a_0(\\mathbf{x}) > 0$, a reaction will occur after time $\\tau$. To determine *which* reaction occurs, we find the probability that the event is specifically reaction $\\mu$. This is the ratio of the probability of reaction $\\mu$ occurring to the probability of any reaction occurring:\n$$ P(\\text{reaction } \\mu) = \\frac{a_\\mu(\\mathbf{x})dt}{a_0(\\mathbf{x})dt} = \\frac{a_\\mu(\\mathbf{x})}{a_0(\\mathbf{x})} $$\nThe Gillespie Direct method samples a reaction index $\\mu$ from this discrete probability distribution. This is done by drawing a second uniform random number $u_2 \\in (0,1)$ and finding the smallest integer $\\mu$ that satisfies:\n$$ \\sum_{j=1}^{\\mu} a_j(\\mathbf{x}) > u_2 \\cdot a_0(\\mathbf{x}) $$\n\n#### Algorithm and Stopping Conditions\n\nThe implemented algorithm will proceed as follows:\n$1$. Initialize time $t=0$, the state vector $\\mathbf{x} = \\mathbf{x}_0$, and number of events $N_{\\mathrm{events}}=0$.\n$2$. Begin a loop that continues as long as the simulation time $t$ is less than the final time $T_{\\mathrm{end}}$.\n$3$. At each step, calculate the propensities $a_j(\\mathbf{x})$ for all reactions and their sum $a_0(\\mathbf{x})$.\n$4$. **First stopping condition (absorption):** If $a_0(\\mathbf{x}) = 0$, the system is in an absorbing state. The loop terminates. The final time is the current time $t$, and the `absorbed` flag is set to `True`.\n$5$. If $a_0(\\mathbf{x}) > 0$, draw two random numbers $u_1, u_2$ from $U(0,1)$ and calculate the waiting time $\\tau$.\n$6$. **Second stopping condition (end time):** If the time of the next reaction, $t + \\tau$, is greater than or equal to $T_{\\mathrm{end}}$, no further reactions are processed. The simulation time is set to $T_{\\mathrm{end}}$, and the loop terminates. The `absorbed` flag is `False`.\n$7$. If the reaction occurs before $T_{\\mathrm{end}}$, update the time $t \\leftarrow t + \\tau$. Select the reaction index $\\mu$ using $u_2$. Update the state vector $\\mathbf{x} \\leftarrow \\mathbf{x} + \\mathbf{v}_{\\mu}$, where $\\mathbf{v}_{\\mu}$ is the state-change vector for reaction $\\mu$. Increment $N_{\\mathrm{events}}$.\n$8$. The loop repeats from step $3$.\n$9$. Upon termination, the algorithm returns the total number of events fired, a boolean indicating if termination was due to absorption, and the final simulation time.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the Gillespie SSA implementation.\n    \"\"\"\n\n    def run_gillespie(initial_state, reactant_stoich, state_change, rate_constants, T_end, seed):\n        \"\"\"\n        Implements the Gillespie Direct Method SSA.\n\n        Args:\n            initial_state (list or np.ndarray): Initial molecular counts.\n            reactant_stoich (np.ndarray): Matrix of reactant stoichiometries (reactions x species).\n            state_change (np.ndarray): State-change matrix (reactions x species).\n            rate_constants (list or np.ndarray): Vector of reaction rate constants.\n            T_end (float): The final simulation time.\n            seed (int): Seed for the pseudorandom number generator.\n\n        Returns:\n            list: A list containing [N_events, absorbed, t_final].\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        num_species = len(initial_state)\n        num_reactions = len(rate_constants)\n\n        t = 0.0\n        x = np.array(initial_state, dtype=int)\n        n_events = 0\n        absorbed = False\n\n        def calculate_propensities(current_x):\n            propensities = np.zeros(num_reactions, dtype=float)\n            for j in range(num_reactions):\n                # Calculate the product of binomial terms, h_j\n                h_j = 1.0\n                possible = True\n                for i in range(num_species):\n                    r_ij = reactant_stoich[j, i]\n                    if r_ij > 0:\n                        x_i = current_x[i]\n                        if x_i  r_ij:\n                            possible = False\n                            break\n                        h_j *= comb(x_i, r_ij, exact=False)\n                \n                if possible:\n                    propensities[j] = rate_constants[j] * h_j\n            return propensities\n\n        # Main simulation loop\n        while t  T_end:\n            propensities = calculate_propensities(x)\n            a0 = np.sum(propensities)\n\n            if a0 == 0.0:\n                absorbed = True\n                break\n\n            u1, u2 = rng.random(2)\n            tau = (1.0 / a0) * np.log(1.0 / u1)\n\n            if t + tau >= T_end:\n                t = T_end\n                break\n            \n            t += tau\n\n            # Select the next reaction\n            target = u2 * a0\n            a_sum = 0.0\n            mu = -1  # reaction index\n            for j in range(num_reactions):\n                a_sum += propensities[j]\n                if a_sum >= target:\n                    mu = j\n                    break\n\n            # Update state and event count\n            x += state_change[mu]\n            n_events += 1\n\n        t_final = t\n        return [n_events, absorbed, t_final]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Absorption reached during simulation\n        {\n            \"initial_state\": [3],\n            \"reactant_stoich\": np.array([[1]]),\n            \"state_change\": np.array([[-1]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 2.0,\n            \"seed\": 12345,\n        },\n        # Case 2: Initial absorbing state\n        {\n            \"initial_state\": [1],\n            \"reactant_stoich\": np.array([[2]]),\n            \"state_change\": np.array([[-2]]),\n            \"rate_constants\": [1.0],\n            \"T_end\": 1.0,\n            \"seed\": 42,\n        },\n        # Case 3: Never absorbing before final time\n        {\n            \"initial_state\": [0],\n            \"reactant_stoich\": np.array([[0], [1]]),\n            \"state_change\": np.array([[1], [-1]]),\n            \"rate_constants\": [2.0, 1.0],\n            \"T_end\": 1.0,\n            \"seed\": 314159,\n        },\n        # Case 4: Absorption after a finite chain\n        {\n            \"initial_state\": [1, 0],\n            \"reactant_stoich\": np.array([[1, 0], [0, 1]]),\n            \"state_change\": np.array([[-1, 1], [0, -1]]),\n            \"rate_constants\": [0.5, 0.7],\n            \"T_end\": 5.0,\n            \"seed\": 2024,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_gillespie(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[N_events,absorbed,t_final],[...],[...],[...]]\n    outer_list = []\n    for res in results:\n        # res is like [3, True, 1.2345]\n        inner_list_str = f\"[{res[0]},{str(res[1])},{res[2]}]\"\n        outer_list.append(inner_list_str)\n    \n    print(f\"[{','.join(outer_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The direct method of the Gillespie algorithm, while exact, can be computationally expensive for large reaction networks because it re-evaluates every propensity function at every step. This exercise introduces a critical optimization technique based on the reaction dependency graph. By identifying which reactions are affected by the firing of another, you can selectively update only the necessary propensities, significantly boosting simulation speed. This practice will guide you in constructing such a graph and understanding its power to create more efficient simulation tools .",
            "id": "3935525",
            "problem": "Consider a well-mixed, isothermal single-cell synthetic gene circuit modeled as a continuous-time Markov process under the Chemical Master Equation and simulated via the Gillespie stochastic simulation algorithm (SSA), where the propensity of each reaction is a function of the current molecular counts. The circuit involves a promoter that can bind a transcription factor, resulting in regulated transcription and translation with degradation. Let the molecular species be $G$ (unbound promoter), $C$ (promoter bound by transcription factor), $T$ (transcription factor), $M$ (messenger ribonucleic acid), and $P$ (protein). The reaction network is:\n- $R_{1}: G + T \\xrightarrow{k_{1}} C$,\n- $R_{2}: C \\xrightarrow{k_{2}} G + T$,\n- $R_{3}: C \\xrightarrow{k_{3}} C + M$,\n- $R_{4}: G \\xrightarrow{k_{4}} G + M$,\n- $R_{5}: M \\xrightarrow{k_{5}} \\varnothing$,\n- $R_{6}: M \\xrightarrow{k_{6}} M + P$,\n- $R_{7}: P \\xrightarrow{k_{7}} \\varnothing$,\n- $R_{8}: P \\xrightarrow{k_{8}} P + T$,\n- $R_{9}: T \\xrightarrow{k_{9}} \\varnothing$.\n\nAssume stochastic mass-action kinetics for all reactions so that each propensity $a_{j}$ depends only on the molecular counts of the reactant species of reaction $R_{j}$ (for example, $a_1(G,T) = k_1 G T$, $a_2(C) = k_2 C$, $a_3(C) = k_3 C$, $a_4(G) = k_4 G$, $a_5(M) = k_5 M$, $a_6(M) = k_6 M$, $a_7(P) = k_7 P$, $a_8(P) = k_8 P$, $a_9(T) = k_9 T$). Let $\\nu_{i}$ denote the net stoichiometric change vector of reaction $R_{i}$ in the species order $(G, T, C, M, P)$.\n\nStarting from the definitions of the Chemical Master Equation and the Gillespie stochastic simulation algorithm (SSA), and using only the standard mass-action dependence of propensities on molecular counts, do the following:\n1. Define the rule that determines an edge in the dependency graph between reactions $R_{i}$ and $R_{j}$ in terms of the species changed by $R_{i}$ and the species appearing in $a_{j}$.\n2. Construct the dependency graph for the given network by identifying, for each $i \\in \\{1,\\dots,9\\}$, the set of indices $j$ such that the propensity $a_{j}$ must be recomputed immediately after the firing of $R_{i}$.\n3. Using your graph, determine the minimal number of distinct propensities that must be recomputed immediately after a single firing of $R_{1}$.\n\nExpress your final answer as an integer. No rounding is required and no units are needed.",
            "solution": "The problem asks for three items related to the Gillespie Stochastic Simulation Algorithm (SSA) and its optimization via a dependency graph for a given biochemical reaction network. We will address each in turn. The state of the system at any time $t$ is given by the vector of molecular counts $X(t) = (N_G, N_T, N_C, N_M, N_P)$, where $N_S$ is the number of molecules of species $S$.\n\nThe core idea of the SSA is to, at each step, determine the time to the next reaction and which reaction occurs. This requires knowledge of the propensity functions, $a_j(X)$, for each reaction $R_j$. After a reaction $R_i$ fires, the state vector updates from $X$ to $X + \\nu_i$, where $\\nu_i$ is the stoichiometric change vector for $R_i$. Consequently, all propensity functions must be updated to reflect the new state. However, a propensity function $a_j(X)$ only needs to be recomputed if its value changes, which happens if and only if the count of at least one of its reactant species has changed. The dependency graph formalizes this relationship.\n\n### Part 1: Defining the Dependency Graph Rule\n\nA dependency graph for a reaction network is a directed graph where the nodes are the reactions $\\{R_1, \\dots, R_M\\}$ and a directed edge exists from node $i$ to node $j$ (denoted $R_i \\to R_j$) if the firing of reaction $R_i$ necessitates the recomputation of the propensity $a_j$.\n\nLet the set of all molecular species be $\\mathcal{S} = \\{S_1, \\dots, S_N\\}$. The state of the system is $X = (N_1, \\dots, N_N)$ where $N_k$ is the count of species $S_k$.\nThe stoichiometric change vector for reaction $R_i$ is $\\nu_i = (\\nu_{i1}, \\nu_{i2}, \\dots, \\nu_{iN})$, where $\\nu_{ik}$ is the net change in the number of molecules of species $S_k$ when reaction $R_i$ fires once.\nThe set of species whose counts are altered by the firing of $R_i$ is $\\mathcal{U}_i = \\{ S_k \\in \\mathcal{S} \\mid \\nu_{ik} \\neq 0 \\}$.\n\nThe propensity function $a_j(X)$ for reaction $R_j$ depends on the counts of its reactant species. Let the set of reactant species for reaction $R_j$ be $\\mathcal{R}_j$.\nThe propensity $a_j$ must be recomputed after the firing of $R_i$ if and only if the count of at least one species in $\\mathcal{R}_j$ is changed by $R_i$. This occurs if the set of species altered by $R_i$ has a non-empty intersection with the set of reactant species for $R_j$.\n\nTherefore, the rule for determining an edge in the dependency graph is:\nA directed edge exists from $R_i$ to $R_j$ if and only if $\\mathcal{U}_i \\cap \\mathcal{R}_j \\neq \\emptyset$.\n\n### Part 2: Constructing the Dependency Graph\n\nWe apply the rule defined above to the given reaction network. The species are $G, T, C, M, P$.\n\nFirst, we identify the set of species whose counts are changed by each reaction, $\\mathcal{U}_i = \\{S_k \\mid \\nu_{ik} \\neq 0\\}$, and the set of reactant species for each reaction, $\\mathcal{R}_j$.\nThe species order is $(G, T, C, M, P)$. The stoichiometric vectors $\\nu_i$ are:\n- $R_1: G + T \\to C \\implies \\nu_1 = (-1, -1, 1, 0, 0) \\implies \\mathcal{U}_1 = \\{G, T, C\\}$\n- $R_2: C \\to G + T \\implies \\nu_2 = (1, 1, -1, 0, 0) \\implies \\mathcal{U}_2 = \\{G, T, C\\}$\n- $R_3: C \\to C + M \\implies \\nu_3 = (0, 0, 0, 1, 0) \\implies \\mathcal{U}_3 = \\{M\\}$\n- $R_4: G \\to G + M \\implies \\nu_4 = (0, 0, 0, 1, 0) \\implies \\mathcal{U}_4 = \\{M\\}$\n- $R_5: M \\to \\varnothing \\implies \\nu_5 = (0, 0, 0, -1, 0) \\implies \\mathcal{U}_5 = \\{M\\}$\n- $R_6: M \\to M + P \\implies \\nu_6 = (0, 0, 0, 0, 1) \\implies \\mathcal{U}_6 = \\{P\\}$\n- $R_7: P \\to \\varnothing \\implies \\nu_7 = (0, 0, 0, 0, -1) \\implies \\mathcal{U}_7 = \\{P\\}$\n- $R_8: P \\to P + T \\implies \\nu_8 = (0, 1, 0, 0, 0) \\implies \\mathcal{U}_8 = \\{T\\}$\n- $R_9: T \\to \\varnothing \\implies \\nu_9 = (0, -1, 0, 0, 0) \\implies \\mathcal{U}_9 = \\{T\\}$\n\nThe reactant sets $\\mathcal{R}_j$ for the propensities $a_j$ (assuming mass-action kinetics) are:\n- $a_1(G,T) = k_1GT \\implies \\mathcal{R}_1 = \\{G, T\\}$\n- $a_2(C) = k_2C \\implies \\mathcal{R}_2 = \\{C\\}$\n- $a_3(C) = k_3C \\implies \\mathcal{R}_3 = \\{C\\}$\n- $a_4(G) = k_4G \\implies \\mathcal{R}_4 = \\{G\\}$\n- $a_5(M) = k_5M \\implies \\mathcal{R}_5 = \\{M\\}$\n- $a_6(M) = k_6M \\implies \\mathcal{R}_6 = \\{M\\}$\n- $a_7(P) = k_7P \\implies \\mathcal{R}_7 = \\{P\\}$\n- $a_8(P) = k_8P \\implies \\mathcal{R}_8 = \\{P\\}$\n- $a_9(T) = k_9T \\implies \\mathcal{R}_9 = \\{T\\}$\n\nNow, we construct the graph by checking the condition $\\mathcal{U}_i \\cap \\mathcal{R}_j \\neq \\emptyset$ for all pairs $(i,j)$:\n- **$R_1$ fires ($\\mathcal{U}_1 = \\{G, T, C\\}$):**\n  - $\\mathcal{U}_1 \\cap \\mathcal{R}_1 = \\{G, T\\} \\neq \\emptyset \\implies R_1 \\to R_1$\n  - $\\mathcal{U}_1 \\cap \\mathcal{R}_2 = \\{C\\} \\neq \\emptyset \\implies R_1 \\to R_2$\n  - $\\mathcal{U}_1 \\cap \\mathcal{R}_3 = \\{C\\} \\neq \\emptyset \\implies R_1 \\to R_3$\n  - $\\mathcal{U}_1 \\cap \\mathcal{R}_4 = \\{G\\} \\neq \\emptyset \\implies R_1 \\to R_4$\n  - $\\mathcal{U}_1 \\cap \\mathcal{R}_9 = \\{T\\} \\neq \\emptyset \\implies R_1 \\to R_9$\n  - Other intersections are empty.\n  - Dependencies from $R_1$: $\\{R_1, R_2, R_3, R_4, R_9\\}$.\n\n- **$R_2$ fires ($\\mathcal{U}_2 = \\{G, T, C\\}$):** Same as $R_1$. Dependencies from $R_2$: $\\{R_1, R_2, R_3, R_4, R_9\\}$.\n\n- **$R_3$ fires ($\\mathcal{U}_3 = \\{M\\}$):**\n  - $\\mathcal{U}_3 \\cap \\mathcal{R}_5 = \\{M\\} \\neq \\emptyset \\implies R_3 \\to R_5$\n  - $\\mathcal{U}_3 \\cap \\mathcal{R}_6 = \\{M\\} \\neq \\emptyset \\implies R_3 \\to R_6$\n  - Dependencies from $R_3$: $\\{R_5, R_6\\}$.\n\n- **$R_4$ fires ($\\mathcal{U}_4 = \\{M\\}$):** Same as $R_3$. Dependencies from $R_4$: $\\{R_5, R_6\\}$.\n- **$R_5$ fires ($\\mathcal{U}_5 = \\{M\\}$):** Same as $R_3$. Dependencies from $R_5$: $\\{R_5, R_6\\}$.\n\n- **$R_6$ fires ($\\mathcal{U}_6 = \\{P\\}$):**\n  - $\\mathcal{U}_6 \\cap \\mathcal{R}_7 = \\{P\\} \\neq \\emptyset \\implies R_6 \\to R_7$\n  - $\\mathcal{U}_6 \\cap \\mathcal{R}_8 = \\{P\\} \\neq \\emptyset \\implies R_6 \\to R_8$\n  - Dependencies from $R_6$: $\\{R_7, R_8\\}$.\n\n- **$R_7$ fires ($\\mathcal{U}_7 = \\{P\\}$):** Same as $R_6$. Dependencies from $R_7$: $\\{R_7, R_8\\}$.\n\n- **$R_8$ fires ($\\mathcal{U}_8 = \\{T\\}$):**\n  - $\\mathcal{U}_8 \\cap \\mathcal{R}_1 = \\{T\\} \\neq \\emptyset \\implies R_8 \\to R_1$\n  - $\\mathcal{U}_8 \\cap \\mathcal{R}_9 = \\{T\\} \\neq \\emptyset \\implies R_8 \\to R_9$\n  - Dependencies from $R_8$: $\\{R_1, R_9\\}$.\n\n- **$R_9$ fires ($\\mathcal{U}_9 = \\{T\\}$):** Same as $R_8$. Dependencies from $R_9$: $\\{R_1, R_9\\}$.\n\nThe dependency graph is fully specified by these sets of directed edges.\n\n### Part 3: Minimal Propensities to Recompute after Firing $R_1$\n\nThe minimal number of distinct propensities that must be recomputed immediately after a single firing of a reaction $R_i$ corresponds to the number of reactions $R_j$ for which there is a dependency edge $R_i \\to R_j$. This is the out-degree of the node $R_i$ in the dependency graph.\n\nFrom Part 2, we identified the set of reactions whose propensities are affected by the firing of $R_1$. When $R_1$ fires, the species counts of $G$, $T$, and $C$ are changed ($\\mathcal{U}_1 = \\{G, T, C\\}$). We must recompute the propensity of any reaction $R_j$ that has $G$, $T$, or $C$ as a reactant.\n\nThe reactions whose propensities depend on these species are:\n1.  $R_1$: Propensity $a_1$ depends on $G$ and $T$.\n2.  $R_2$: Propensity $a_2$ depends on $C$.\n3.  $R_3$: Propensity $a_3$ depends on $C$.\n4.  $R_4$: Propensity $a_4$ depends on $G$.\n5.  $R_9$: Propensity $a_9$ depends on $T$.\n\nThe propensities $a_5, a_6, a_7, a_8$ depend on $M$ and $P$, whose counts are unaffected by $R_1$. Therefore, these propensities do not change and do not need to be recomputed.\n\nThe set of indices of propensities to recompute is $\\{1, 2, 3, 4, 9\\}$. Each $a_j$ is a distinct propensity for a distinct reaction channel. The minimal number of distinct propensities that must be recomputed is the size of this set.\nThe number is $5$.",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}