{
    "hands_on_practices": [
        {
            "introduction": "本征正交分解（Proper Orthogonal Decomposition, POD）是数据驱动降阶建模的基石。该方法旨在从一组高维数据（称为“快照”）中提取一个最优的低维子空间。本练习将指导你完成核心的POD算法：利用奇异值分解（Singular Value Decomposition, SVD）从给定的快照矩阵中提取最主要的特征，即POD模态。通过计算并分析不同阶数近似的重构误差，你将亲身体验POD在数据压缩方面的强大能力与基本原理 。",
            "id": "4249036",
            "problem": "考虑一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$，它收集了一个信息物理系统的 $m$ 个状态快照，这些快照按列排列，每个状态是 $n$ 维的。本征正交分解 (Proper Orthogonal Decomposition, POD) 用于代理和降阶建模，以找到一个能够捕获数据中主要相干结构的低维子空间。POD 基可以通过对 $X$ 进行奇异值分解 (Singular Value Decomposition, SVD) 获得。目标是计算前 $r$ 个 POD 模态和相应的秩-$r$ 重构，然后报告相对重构误差。\n\n从任何实数矩阵都允许 SVD 这一基本前提开始，您的程序必须：\n\n- 计算奇异值分解 (SVD) $X = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times p}$，$V \\in \\mathbb{R}^{m \\times p}$，以及 $\\Sigma \\in \\mathbb{R}^{p \\times p}$，其中 $p = \\min(n,m)$，$U$ 和 $V$ 的列是标准正交的，并且 $\\Sigma$ 是对角矩阵，其对角线元素为非负值（奇异值）。\n- 提取前 $r$ 个 POD 模态作为 $U$ 的前 $r$ 列，记为 $U_r \\in \\mathbb{R}^{n \\times r}$，以及相应的截断对角矩阵 $\\Sigma_r \\in \\mathbb{R}^{r \\times r}$，其对角线元素是前 $r$ 个最大的奇异值，同时还有由 $V$ 的前 $r$ 列组成的 $V_r \\in \\mathbb{R}^{m \\times r}$。\n- 构造秩-$r$ 近似 $X_r = U_r \\Sigma_r V_r^\\top$ 并计算相对弗罗贝尼乌斯范数误差\n$$\ne_r = \\frac{\\|X - X_r\\|_F}{\\|X\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n- 如果 $\\|X\\|_F = 0$，则定义 $e_r = 0$。\n\n您的程序必须为以下测试套件中的每个测试用例实现上述步骤，并按规定格式生成结果。不需要外部输入；矩阵和 $r$ 的值如下所示。\n\n测试套件：\n\n- 情况 $1$ (一般的非方阵，理想路径): $X_1 \\in \\mathbb{R}^{4 \\times 3}$\n$$\nX_1 = \\begin{bmatrix}\n2  -1  0 \\\\\n0  1  3 \\\\\n4  -2  1 \\\\\n1  0  -1\n\\end{bmatrix},\n$$\n$r_1 = 2$。\n\n- 情况 $2$ (列线性相关的秩亏矩阵): $X_2 \\in \\mathbb{R}^{3 \\times 3}$\n$$\nX_2 = \\begin{bmatrix}\n1  2  3 \\\\\n2  4  6 \\\\\n1  2  3\n\\end{bmatrix},\n$$\n$r_2 = 1$。\n\n- 情况 $3$ (边界情况 $r=0$): $X_3 \\in \\mathbb{R}^{2 \\times 2}$\n$$\nX_3 = \\begin{bmatrix}\n3  -1 \\\\\n0  2\n\\end{bmatrix},\n$$\n$r_3 = 0$。\n\n- 情况 $4$ (使用 $r = \\min(n,m)$ 的满秩重构): $X_4 \\in \\mathbb{R}^{5 \\times 3}$\n$$\nX_4 = \\begin{bmatrix}\n1  0  2 \\\\\n0  1  -1 \\\\\n2  -1  0 \\\\\n1  3  1 \\\\\n-2  0  1\n\\end{bmatrix},\n$$\n$r_4 = 3$。\n\n- 情况 $5$ (零矩阵边缘情况): $X_5 \\in \\mathbb{R}^{3 \\times 4}$\n$$\nX_5 = \\begin{bmatrix}\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{bmatrix},\n$$\n$r_5 = 2$。\n\n- 情况 $6$ (具有衰减尺度的病态对角矩阵): $X_6 \\in \\mathbb{R}^{3 \\times 3}$\n$$\nX_6 = \\begin{bmatrix}\n10  0  0 \\\\\n0  1  0 \\\\\n0  0  0.1\n\\end{bmatrix},\n$$\n$r_6 = 2$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个 $e_r$ 四舍五入到 $8$ 位小数，按情况 1 到 6 的顺序排列，例如：$[e_1,e_2,e_3,e_4,e_5,e_6]$。\n- 每个条目必须是十进制数。",
            "solution": "问题要求计算给定矩阵 $X$ 的秩-$r$ 近似的相对弗罗贝尼乌斯范数误差，该近似通过本征正交分解 (POD) 获得。这是降阶建模中的一项基本任务，其目标是用低维表示来捕获高维系统的最显著特征。实现这一目标的数学工具是奇异值分解 (SVD)。\n\n给定的数据矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 聚合了 $n$ 维状态向量的 $m$ 个快照。$X$ 的 SVD 是一种形式如下的分解：\n$$\nX = U \\Sigma V^\\top\n$$\n问题指定使用“薄”或“经济”SVD。对于维度为 $n \\times m$ 的矩阵 $X$，令 $p = \\min(n, m)$。薄 SVD 的组成部分是：\n- $U \\in \\mathbb{R}^{n \\times p}$：一个矩阵，其列是 $X$ 的前 $p$ 个左奇异向量。这些列是标准正交的，被称为 POD 模态。它们在最小二乘意义上构成了数据的最优基。\n- $\\Sigma \\in \\mathbb{R}^{p \\times p}$：一个对角矩阵，包含 $X$ 的 $p$ 个奇异值，按降序排列，记为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_p \\ge 0$。每个奇异值 $\\sigma_i$ 的大小对应于第 $i$ 个 POD 模态的重要性。\n- $V \\in \\mathbb{R}^{m \\times p}$：一个矩阵，其列是 $X$ 的前 $p$ 个右奇异向量。这些列也是标准正交的。\n\nEckart-Young-Mirsky 定理指出，矩阵 $X$ 在弗罗贝尼乌斯范数（以及谱范数）下的最佳秩-$r$ 近似是通过截断 SVD 获得的。这个秩-$r$ 近似，记为 $X_r$，是使用前 $r$ 个奇异值及其对应的奇异向量构造的：\n$$\nX_r = U_r \\Sigma_r V_r^\\top\n$$\n其中：\n- $U_r \\in \\mathbb{R}^{n \\times r}$ 是包含 $U$ 的前 $r$ 列的矩阵。\n- $\\Sigma_r \\in \\mathbb{R}^{r \\times r}$ 是包含前 $r$ 个奇异值 $\\sigma_1, \\dots, \\sigma_r$ 的对角矩阵。\n- $V_r \\in \\mathbb{R}^{m \\times r}$ 是包含 $V$ 的前 $r$ 列的矩阵，因此 $V_r^\\top \\in \\mathbb{R}^{r \\times m}$。\n\n问题要求计算相对重构误差，定义为：\n$$\ne_r = \\frac{\\|X - X_r\\|_F}{\\|X\\|_F}\n$$\n其中 $\\|\\cdot\\|_F$ 是矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 的弗罗贝尼乌斯范数，计算公式为 $\\|A\\|_F = \\sqrt{\\sum_{i=1}^n \\sum_{j=1}^m A_{ij}^2}$。\n\nSVD 的一个关键性质是它与弗罗贝尼乌斯范数的关系。矩阵的弗罗贝尼乌斯范数的平方等于其奇异值平方的和：\n$$\n\\|X\\|_F^2 = \\sum_{i=1}^p \\sigma_i^2\n$$\n近似误差矩阵 $X - X_r$ 的奇异值为 $\\sigma_{r+1}, \\sigma_{r+2}, \\dots, \\sigma_p$。因此，误差的弗罗贝尼乌斯范数的平方是：\n$$\n\\|X - X_r\\|_F^2 = \\sum_{i=r+1}^p \\sigma_i^2\n$$\n这提供了一种非常高效的方法，可以直接从奇异值计算相对误差 $e_r$，而无需显式构造矩阵 $X_r$：\n$$\ne_r = \\sqrt{\\frac{\\sum_{i=r+1}^p \\sigma_i^2}{\\sum_{i=1}^p \\sigma_i^2}}\n$$\n这个公式在 $\\|X\\|_F > 0$ 的情况下有效。如果 $X$ 是零矩阵，其范数为 $0$，且所有奇异值也为 $0$。在这种情况下，问题规定误差 $e_r$ 应定义为 $0$。\n\n对每个测试用例 $(X, r)$ 的算法如下：\n$1$. 计算 $X$ 的弗罗贝尼乌斯范数 $\\|X\\|_F$。如果 $\\|X\\|_F = 0$，则误差 $e_r$ 为 $0$。\n$2$. 如果 $\\|X\\|_F > 0$，计算 $X$ 的奇异值。设它们为数组 $s = [\\sigma_1, \\sigma_2, \\dots, \\sigma_p]$。\n$3$. 奇异值的数量为 $p = \\min(n, m)$。切片索引对应于从 0 开始的编程索引。误差范数的求和涉及从索引 $r$ 到 $p-1$ 的奇异值。\n$4$. 计算分子，即误差范数：$\\|X - X_r\\|_F = \\sqrt{\\sum_{i=r}^{p-1} s_i^2}$。\n$5$. 分母 $\\|X\\|_F$ 已经计算过。它也可以计算为 $\\sqrt{\\sum_{i=0}^{p-1} s_i^2}$。\n$6$. 计算相对误差 $e_r = \\|X - X_r\\|_F / \\|X\\|_F$。\n\n此过程应用于每个测试用例：\n- 对于情况 1 ($r_1=2$)，误差将由最小的奇异值 $\\sigma_3$ 决定。\n- 对于情况 2 (秩亏)，矩阵的秩为 $1$。因此，只有一个奇异值 $\\sigma_1$ 非零。对于 $r_2=1$，我们保留了谱的整个非零部分，所以误差 $\\|X - X_1\\|_F$ 应为 $0$，得出 $e_2=0$。\n- 对于情况 3 ($r_3=0$)，近似 $X_0$ 是零矩阵。误差为 $\\|X - \\mathbf{0}\\|_F = \\|X\\|_F$。相对误差是 $e_3 = \\|X\\|_F / \\|X\\|_F = 1$，因为 $X_3$ 不是零矩阵。\n- 对于情况 4 ($r_4=3$)，我们有 $p = \\min(5, 3) = 3$。由于 $r_4=p$，我们正在执行完全重构。因此，$X_3 = X$，误差 $e_4$ 将为 $0$（在机器精度范围内）。\n- 对于情况 5 ($X_5=\\mathbf{0}$)，矩阵范数为 $0$。根据问题的定义，误差 $e_5$ 为 $0$。\n- 对于情况 6 (对角矩阵)，奇异值是对角线元素的绝对值：$10, 1, 0.1$。对于 $r_6=2$，误差由最小的奇异值 $\\sigma_3=0.1$ 决定。相对误差将是 $\\sigma_3 / \\sqrt{\\sigma_1^2 + \\sigma_2^2 + \\sigma_3^2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative Frobenius norm error for rank-r POD approximations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([\n            [2., -1., 0.],\n            [0., 1., 3.],\n            [4., -2., 1.],\n            [1., 0., -1.]\n        ]), 2),\n        (np.array([\n            [1., 2., 3.],\n            [2., 4., 6.],\n            [1., 2., 3.]\n        ]), 1),\n        (np.array([\n            [3., -1.],\n            [0., 2.]\n        ]), 0),\n        (np.array([\n            [1., 0., 2.],\n            [0., 1., -1.],\n            [2., -1., 0.],\n            [1., 3., 1.],\n            [-2., 0., 1.]\n        ]), 3),\n        (np.array([\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.]\n        ]), 2),\n        (np.array([\n            [10., 0., 0.],\n            [0., 1., 0.],\n            [0., 0., 0.1]\n        ]), 2)\n    ]\n\n    results = []\n    for X, r in test_cases:\n        # Calculate the Frobenius norm of the original matrix X.\n        norm_X = np.linalg.norm(X, 'fro')\n\n        # Handle the special case where the matrix is the zero matrix.\n        # If norm_X is 0, the relative error is defined as 0.\n        if np.isclose(norm_X, 0.0):\n            relative_error = 0.0\n            results.append(relative_error)\n            continue\n\n        # Compute the singular values of X.\n        # We only need the singular values, so we don't compute U and Vh for efficiency.\n        # singular values are returned in descending order.\n        s = np.linalg.svd(X, compute_uv=False)\n        \n        # The squared Frobenius norm of the error matrix (X - X_r) is the sum\n        # of the squares of the truncated singular values (from index r onwards).\n        # s[r:] gives all singular values from index r to the end.\n        squared_error_norm = np.sum(s[r:]**2)\n        \n        # The error norm is the square root of this sum.\n        error_norm = np.sqrt(squared_error_norm)\n        \n        # The relative error is the ratio of the error norm to the original matrix norm.\n        relative_error = error_norm / norm_X\n        \n        results.append(relative_error)\n\n    # Format the results to 8 decimal places and print in the specified format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在许多物理系统中，保持特定的物理量（如能量）比最小化一个通用的数学误差（如Frobenius范数）更为关键。本练习在前一个实践的基础上，引入了加权内积的概念，它允许我们根据系统的物理特性（例如能量）来定制POD过程。你将学习如何通过求解一个广义的特征值问题来生成一个能最优地捕捉系统能量的降阶基，这是在固体力学、流体力学等领域建立有物理意义的降阶模型的关键一步 。",
            "id": "2679837",
            "problem": "考虑瞬态弹性动力学的降阶建模，其中一组位移或速度快照的能量含量在代表离散化能量内积的对称正定（SPD）加权下进行评估。设$X \\in \\mathbb{R}^{n \\times m}$为一个快照矩阵，其列为状态快照，设$W \\in \\mathbb{R}^{n \\times n}$为一个SPD矩阵，定义了加权内积$\\langle u,v \\rangle_W = u^\\top W v$。目标是确定在$W$内积下，最优秩-$r$子空间的前$r$个模态捕获了$X$总能量含量的多少，并选择最小的$r$，使得舍弃的能量分数最多为指定的容差$\\varepsilon$。所有量均为无量纲分数；不需要物理单位。不出现角度；不需要角度单位。\n\n仅从内积、正交投影和加权范数下的能量等基本线性代数原理出发，推导在$W$内积下与$X$相关的最佳$r$维子空间所捕获的累积能量含量的度量。利用该推导设计一个算法，对于每个测试用例$(X,W,\\varepsilon)$，计算：\n- 最小的整数$r \\ge 0$，使得舍弃的能量分数小于或等于$\\varepsilon$，以及\n- 在该$r$下实现的舍弃能量分数。\n\n如果在$W$内积下$X$的总能量为零，则定义$r=0$且舍弃的能量分数为$0$。将舍弃的能量分数表示为四舍五入到$10$位小数的小数。\n\n你的程序必须解决以下测试套件。每个用例都明确提供了$X$、$W$和$\\varepsilon$。\n\n测试用例 #1：\n- $n = 5$, $m = 4$。\n- $W_1 = I_5$。\n- $X_1 = \\begin{bmatrix}\n1.5  0.0  0.0  0.0 \\\\\n0.0  1.2  0.0  0.0 \\\\\n0.1  0.0  0.9  0.0 \\\\\n0.0  0.1  0.0  0.6 \\\\\n0.05  0.02  0.01  0.01\n\\end{bmatrix}$。\n- $\\varepsilon_1 = 0.1$。\n\n测试用例 #2：\n- $n = 5$, $m = 3$。\n- $W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$。\n- $X_2 = \\begin{bmatrix}\n1.0  0.5  0.2 \\\\\n0.0  0.4  0.0 \\\\\n0.0  0.0  0.3 \\\\\n0.2  0.0  0.1 \\\\\n0.0  0.0  0.05\n\\end{bmatrix}$。\n- $\\varepsilon_2 = 0.01$。\n\n测试用例 #3（秩亏快照）：\n- $n = 5$, $m = 3$。\n- $W_3 = I_5$。\n- $X_3 = \\begin{bmatrix}\n1.0  1.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.5  0.5  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.2  0.2  0.0\n\\end{bmatrix}$。\n- $\\varepsilon_3 = 0$。\n\n测试用例 #4（全SPD加权）：\n- $n = 5$, $m = 2$。\n- $W_4 = \\begin{bmatrix}\n2.0  0.3  0.0  0.0  0.0 \\\\\n0.3  1.5  0.2  0.0  0.0 \\\\\n0.0  0.2  1.2  0.1  0.0 \\\\\n0.0  0.0  0.1  1.1  0.05 \\\\\n0.0  0.0  0.0  0.05  1.0\n\\end{bmatrix}$。\n- $X_4 = \\begin{bmatrix}\n0.5  0.1 \\\\\n0.1  0.4 \\\\\n0.0  0.3 \\\\\n0.2  0.0 \\\\\n0.0  0.1\n\\end{bmatrix}$。\n- $\\varepsilon_4 = 0.5$。\n\n对于每个测试用例，你的程序必须：\n- 计算最小的$r$，使得舍弃的能量分数小于或等于$\\varepsilon$，\n- 计算在该$r$下舍弃的能量分数，四舍五入到$10$位小数，\n- 将该用例的结果以$[r, \\text{discarded}]$形式的列表输出。\n\n最终输出格式要求：\n你的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个方括号列表。例如，输出必须是$[[r_1,\\text{discarded}_1],[r_2,\\text{discarded}_2],[r_3,\\text{discarded}_3],[r_4,\\text{discarded}_4]]$的形式，行内任何地方都没有空格。",
            "solution": "**解决方案的推导**\n\n我们的任务是找到一个最优的秩$r$子空间，以最佳地逼近一组快照 $\\{x_i\\}_{i=1}^m$，这些快照是矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列。逼近的质量由捕获的能量含量来衡量，其中能量通过加权内积 $\\langle u, v \\rangle_W = u^\\top W v$ 及其诱导范数 $\\|u\\|_W = \\sqrt{u^\\top W u}$ 来定义。矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的。\n\n$1$. 总能量含量：\n单个快照向量 $x_i$ 的能量是其范数的平方，$\\|x_i\\|_W^2 = x_i^\\top W x_i$。整个快照集的总能量含量是各个快照能量的总和：\n$$ E_{total} = \\sum_{i=1}^{m} \\|x_i\\|_W^2 = \\sum_{i=1}^{m} x_i^\\top W x_i $$\n这个和可以用迹算子表示。矩阵乘积 $X^\\top W X$ 的第 $i$ 个对角元素恰好是 $x_i^\\top W x_i$。因此，总能量是该乘积的迹：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) $$\n\n$2$. 转换为标准欧几里得空间：\n在一般加权内积下寻找最优子空间的问题，可以通过将其转换为标准欧几里得内积（$\\langle u,v \\rangle = u^\\top v$）下的等价问题来简化。\n由于 $W$ 是SPD矩阵，它允许唯一的Cholesky分解 $W = L L^\\top$，其中 $L$ 是一个具有正对角线元素的实数下三角矩阵。加权内积可以重写为：\n$$ \\langle u, v \\rangle_W = u^\\top W v = u^\\top (L L^\\top) v = (L^\\top u)^\\top (L^\\top v) $$\n此表达式表明，向量 $u$ 和 $v$ 的 $W$内积等价于变换后向量 $\\tilde{u} = L^\\top u$ 和 $\\tilde{v} = L^\\top v$ 的标准欧几里得内积。\n\n因此，在 $W$范数下为原始快照 $X = [x_1, \\dots, x_m]$ 寻找最优表示，等价于在标准欧几里得范数下为变换后的快照 $\\tilde{X} = L^\\top X = [L^\\top x_1, \\dots, L^\\top x_m]$ 寻找最优表示。总能量在该变换下保持不变：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) = \\mathrm{Tr}(X^\\top L L^\\top X) = \\mathrm{Tr}((L^\\top X)^\\top(L^\\top X)) = \\mathrm{Tr}(\\tilde{X}^\\top \\tilde{X}) = \\|\\tilde{X}\\|_F^2 $$\n其中 $\\|\\cdot\\|_F$ 表示Frobenius范数。\n\n$3$. 最优子空间与奇异值分解（SVD）：\n根据Eckart-Young-Mirsky定理，矩阵 $\\tilde{X}$ 在Frobenius范数下的最佳秩$r$逼近由其截断的奇异值分解（SVD）给出。设 $\\tilde{X}$ 的SVD为 $\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 的对角矩阵。\n最优秩$r$子空间由 $U$ 的前 $r$ 列张成。该子空间捕获的能量是 $\\tilde{X}$ 投影到该子空间上的Frobenius范数的平方。这等于前 $r$ 个奇异值平方的和：\n$$ E_r = \\sum_{i=1}^{r} \\sigma_i^2 $$\n\n$4$. 与特征值问题的关系：\n计算 $\\tilde{X}$ 的完整SVD可能计算量很大，特别是当 $n$ 很大时。有一个更直接的方法。$\\tilde{X}$ 的奇异值的平方是矩阵 $\\tilde{X}^\\top \\tilde{X}$ 的特征值。这个被称为相关矩阵的较小矩阵的维度为 $m \\times m$：\n$$ C = \\tilde{X}^\\top \\tilde{X} = (L^\\top X)^\\top(L^\\top X) = X^\\top L L^\\top X = X^\\top W X $$\n设 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$ 为对称半正定矩阵 $C = X^\\top W X$ 的特征值。那么，对于 $i=1, \\dots, m$，有 $\\lambda_i = \\sigma_i^2$。\n\n$5$. 舍弃的能量分数：\n总能量是 $C$ 的所有特征值之和：$E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n前 $r$ 个模态捕获的能量是 $E_r = \\sum_{i=1}^{r} \\lambda_i$。\n舍弃的能量是剩余部分：$E_{discarded}(r) = E_{total} - E_r = \\sum_{i=r+1}^{m} \\lambda_i$。\n因此，对于一个秩$r$的逼近，舍弃的能量分数为：\n$$ f_d(r) = \\frac{E_{discarded}(r)}{E_{total}} = \\frac{\\sum_{i=r+1}^{m} \\lambda_i}{\\sum_{i=1}^{m} \\lambda_i} $$\n\n$6$. 算法设计：\n基于上述推导，找到满足 $f_d(r) \\le \\varepsilon$ 的最小整数 $r \\ge 0$ 的算法如下：\n1. 给定矩阵 $X$、$W$ 和容差 $\\varepsilon$。\n2. 构造相关矩阵 $C = X^\\top W X$。\n3. 计算 $C$ 的特征值。由于 $C$ 是对称的，其所有特征值都是实数。由于它也是半正定的，所有特征值都是非负的。\n4. 将特征值按降序排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。\n5. 计算总能量 $E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n6. 如果 $E_{total}$ 在数值上为零，则问题陈述规定返回 $r=0$ 和舍弃分数为 $0.0$。\n7. 从 $0$ 到 $m$ 遍历可能的秩 $r$。对于每个 $r$：\n    a. 计算捕获的能量 $E_r = \\sum_{i=1}^{r} \\lambda_i$。（对于 $r=0$， $E_0=0$）。\n    b. 计算舍弃的能量分数 $f_d(r) = (E_{total} - E_r) / E_{total}$。\n    c. 如果 $f_d(r) \\le \\varepsilon$，则该 $r$ 值为所需的最小秩。算法终止并返回该 $r$ 和计算出的 $f_d(r)$。\n这个迭代过程保证能找到最小的 $r$，因为舍弃的能量分数是关于 $r$ 的单调非增函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    # Test case #1\n    X1 = np.array([\n        [1.5, 0.0, 0.0, 0.0],\n        [0.0, 1.2, 0.0, 0.0],\n        [0.1, 0.0, 0.9, 0.0],\n        [0.0, 0.1, 0.0, 0.6],\n        [0.05, 0.02, 0.01, 0.01]\n    ])\n    W1 = np.identity(5)\n    epsilon1 = 0.1\n\n    # Test case #2\n    X2 = np.array([\n        [1.0, 0.5, 0.2],\n        [0.0, 0.4, 0.0],\n        [0.0, 0.0, 0.3],\n        [0.2, 0.0, 0.1],\n        [0.0, 0.0, 0.05]\n    ])\n    W2 = np.diag([2.0, 1.0, 0.5, 1.5, 1.0])\n    epsilon2 = 0.01\n\n    # Test case #3\n    X3 = np.array([\n        [1.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.5, 0.5, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.2, 0.2, 0.0]\n    ])\n    W3 = np.identity(5)\n    epsilon3 = 0.0\n\n    # Test case #4\n    X4 = np.array([\n        [0.5, 0.1],\n        [0.1, 0.4],\n        [0.0, 0.3],\n        [0.2, 0.0],\n        [0.0, 0.1]\n    ])\n    W4 = np.array([\n        [2.0, 0.3, 0.0, 0.0, 0.0],\n        [0.3, 1.5, 0.2, 0.0, 0.0],\n        [0.0, 0.2, 1.2, 0.1, 0.0],\n        [0.0, 0.0, 0.1, 1.1, 0.05],\n        [0.0, 0.0, 0.0, 0.05, 1.0]\n    ])\n    epsilon4 = 0.5\n\n    test_cases = [\n        (X1, W1, epsilon1),\n        (X2, W2, epsilon2),\n        (X3, W3, epsilon3),\n        (X4, W4, epsilon4)\n    ]\n\n    results = []\n    for X, W, epsilon in test_cases:\n        result = compute_optimal_rank(X, W, epsilon)\n        results.append(result)\n\n    # Format the final output string without spaces.\n    inner_results_str = [f\"[{r},{d}]\" for r, d in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\ndef compute_optimal_rank(X, W, epsilon):\n    \"\"\"\n    Computes the smallest rank r and the corresponding discarded energy fraction.\n\n    Args:\n        X (np.ndarray): Snapshot matrix of size n x m.\n        W (np.ndarray): SPD weighting matrix of size n x n.\n        epsilon (float): Tolerance for the discarded energy fraction.\n\n    Returns:\n        list: A list containing [r, discarded_fraction].\n    \"\"\"\n    # Form the m x m correlation matrix C = X^T * W * X\n    C = X.T @ W @ X\n\n    # The eigenvalues of C are the squared singular values of L^T * X.\n    # We use eigh for symmetric matrices, which is numerically stable and efficient.\n    # It returns eigenvalues in ascending order.\n    eigenvalues = linalg.eigh(C, eigvals_only=True)\n    \n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n    \n    # Total energy is the sum of all eigenvalues.\n    total_energy = np.sum(eigenvalues)\n\n    # Handle the case where total energy is zero.\n    if np.isclose(total_energy, 0.0):\n        return [0, 0.0]\n\n    # Number of snapshots (and maximum possible rank)\n    m = X.shape[1]\n\n    # Iterate from r=0 to m to find the smallest r satisfying the condition.\n    cumulative_energy = 0.0\n    for r in range(m + 1):\n        if r == 0:\n            retained_energy = 0.0\n        else:\n            # For a given r, we retain the first r largest eigenvalues.\n            retained_energy = np.sum(eigenvalues[:r])\n\n        discarded_fraction = (total_energy - retained_energy) / total_energy\n        \n        # Check against the tolerance.\n        if discarded_fraction = epsilon:\n            # Found the minimal r. Round the fraction and return.\n            return [r, round(discarded_fraction, 10)]\n    \n    # This part should not be reached for epsilon >= 0, as for r=m,\n    # the discarded fraction is 0. It's included for robustness.\n    return [m, 0.0]\n\nsolve()\n```"
        },
        {
            "introduction": "一个优秀的降阶基（即重构误差极低）是否总能保证一个准确且稳定的降阶动态模型？本练习将引导你探索这个问题的答案，揭示一个降阶建模中的关键“陷阱”。你将通过一个精心设计的数值实验发现，对于某些系统（特别是具有非正规算子的系统），即使原始的全阶模型是稳定的，通过伽辽金投影得到的降阶模型也可能变得不稳定甚至“爆炸”。这个高级实践旨在强调，在构建和使用降阶模型时，除了关注数据表示的精度外，还必须对模型的动态行为进行审慎的分析 。",
            "id": "2432128",
            "problem": "要求您在降阶建模中实现一个完整的数值实验，以展示以下现象：对于一个稳定的全阶线性时不变系统，本征正交分解 (Proper Orthogonal Decomposition, POD) 基在重构训练快照方面可能表现出色，然而，通过Galerkin投影得到的降阶模型 (reduced-order model, ROM) 在进行时间积分时却可能产生发散的不稳定动力学。\n\n您的实现必须从以下全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数域上进行，并采用标准欧几里得内积。在整个实验中，您将使用 $n=2$。\n\n基本定义与要求：\n- 本征正交分解 (POD) 基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解 (SVD) $\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的POD基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取为 $\\mathbf{U}$ 的前 $r$ 列。\n- Galerkin投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 按如下方式演化\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- 时间积分：对全阶模型和ROM均使用经典的四阶Runge–Kutta方法，并采用固定时间步长 $h0$。设置初始条件为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照收集：在训练区间 $[0,T_{\\text{train}}]$ 上对全阶模型进行积分，采用恒定时间步长 $h$，并在每一步对状态进行采样以构建 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对POD重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示Frobenius范数。\n- 发散检测：在测试区间 $[0,T_{\\text{test}}]$ 上使用相同的 $h$ 对全阶模型和ROM进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或任何分量变为非数值 (not-a-number) 或无穷大，则声明解“已发散”。使用阈值 $M=10^6$。\n\n为引发ROM不稳定性而构造的强迫项：\n- 对于每个测试，您必须按如下方式构造恒定强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$ (若有并列，则以任意但确定的方式选择)。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的，且 $\\mathbf{S}$ 的最大特征值为正时，用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 获得的标量ROM具有降阶动力学 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}0$ 且 $b_r=-a_r$，该模型是不稳定的，并会从 $z(0)=0$ 开始发散。\n\n所有测试通用的数值规格：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典的四阶Runge–Kutta方法。\n- 对所有向量范数使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试组：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上收集快照以形成 $\\mathbf{Q}$，然后构建ROM并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 1 (高度非正规，秩为1的POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 2 (高度非正规，秩为2的POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 3 (对称负定，秩为1的POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 4 (更高程度非正规，秩为1的POD)：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n\n要求输出：\n- 对于每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$ (四舍五入到六位小数)，\n  - 一个指示ROM是否在 $[0,T_{\\text{test}}]$ 上发散的布尔值，\n  - 一个指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发散的布尔值。\n- 将所有测试的结果汇总为单行，形式为用方括号括起的逗号分隔列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$。",
            "solution": "问题的核心在于矩阵 $\\mathbf{A}$ 的谱 (spectrum) 与其数值范围 (numerical range, 或值域 field of values) 之间的区别，后者定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，其稳定性由 $\\mathbf{A}$ 的特征值（即谱 $\\sigma(\\mathbf{A})$）决定。如果所有特征值的实部都为负，则系统是稳定的，并且当 $t\\to\\infty$ 时，$\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围为这种瞬态行为提供了深刻见解。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到右半平面，这表明存在瞬态能量增长的可能。\n\n使用秩为 $r$ 的POD基 $\\mathbf{Q}$ 进行Galerkin投影，将FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 转换为ROM $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。ROM的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键在于，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围内，但不一定在其谱的凸包内。如果数值范围 $W(\\mathbf{A})$ 跨入右半平面，就有可能找到一个投影子空间（基为 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 具有正实部的特征值，从而导致ROM不稳定。\n\n问题的构造旨在暴露这种病态现象。FOM是稳定的（$\\mathbf{A}$的特征值为$\\{-0.1, -1.0\\}$）。强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 的选择使得FOM的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是与 $\\mathbf{S}$ 的最大特征值相对应的特征向量。这会驱动系统动力学朝着最大瞬态增长的方向发展。由此产生的快照将由该方向主导，导致主POD模态（$\\mathbf{Q}$的第一列）与 $\\mathbf{q}$ 对齐。对于秩为1的ROM（$r=1$），降阶矩阵 $\\mathbf{A}_r$ 变为一个标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，则 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试1和测试4中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S}) > 0$，从而导致一个不稳定的ROM。\n\n每个测试用例的计算步骤如下：\n$1$. 定义系统参数：矩阵 $\\mathbf{A}$、ROM的秩 $r$、以及时间区间 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n$2$. 构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。求其特征值和特征向量。令 $\\mathbf{q}$ 为对应最大特征值的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n$3$. 生成训练数据：使用经典的四阶Runge-Kutta方法，从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始，在时间区间 $[0, T_{\\text{train}}]$ 上对FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 进行积分。将每个时间步的状态收集到快照矩阵 $\\mathbf{X}$ 中。\n$4$. 计算POD基：对快照矩阵进行奇异值分解 (SVD)，$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的POD基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n$5$. 计算重构误差：相对Frobenius范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n$6$. 构造ROM：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n$7$. 进行时间积分以供测试：FOM和ROM都从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$, $\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上进行积分。在积分过程中，每一步都将状态向量的欧几里得范数与发散阈值 $M=10^6$ 进行比较。\n$8$. 记录结果：测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示ROM是否发散的布尔值，以及一个指示FOM是否发散的布尔值。\n\n各测试的预期结果：\n- **测试 1**：（$\\mathbf{A}$ 非正规， $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的ROM。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM会发散，而FOM不会发散。\n- **测试 2**：（$\\mathbf{A}$ 非正规， $r=2$）：此时 $r=n=2$。POD基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，这意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度量级）。ROM在动力学上与FOM等价，只是在不同的基中表示。由于FOM是稳定的，ROM也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，ROM和FOM都不会发散。\n- **测试 3**：（$\\mathbf{A}$ 对称， $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值（即 $\\{-1.0, -2.0\\}$）的凸包。因此，数值范围是实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必须为负。ROM将是稳定的。我们预期两个模型都不会发散。\n- **测试 4**：（$\\mathbf{A}$ 更非正规， $r=1$）：与测试1类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有一个更大的正特征值。ROM的不稳定性应该更加显著。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM会发散，而FOM不会发散。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if not blew_up and (np.linalg.norm(y) > M or not np.all(np.isfinite(y))):\n                blew_up = True\n            \n            # Continue collecting snapshots even after blow-up for a complete trajectory.\n            # But the status is latched once it blows up.\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>=r)) / sqrt(sum(s_i^2))\n        if X.shape[1] > 1:\n            norm_X_sq = np.sum(s**2)\n            if norm_X_sq > 0:\n                norm_err_sq = np.sum(s[r:]**2)\n                eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n            else:\n                eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}