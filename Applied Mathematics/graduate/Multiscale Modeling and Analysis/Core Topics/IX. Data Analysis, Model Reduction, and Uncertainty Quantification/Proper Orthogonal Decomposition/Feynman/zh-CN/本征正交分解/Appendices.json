{
    "hands_on_practices": [
        {
            "introduction": "本征正交分解 (POD) 的理论基础在于其能够为给定数据集找到最优的低维基。在深入研究数值计算方法之前，通过一个解析可解的例子来从第一性原理出发进行推导，是理解其核心思想的宝贵练习。本实践  将引导你推导一个由两个正交空间模态和两个不同时间频率构成的简单时空场的 POD 模态，从而揭示 POD 模态与数据内在结构之间的直接联系。",
            "id": "3265890",
            "problem": "考虑空间域 $x \\in [0,1]$，其空间内积由 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 给出，时间集总平均由长时间均值 $\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} (\\cdot) \\, dt$ 定义。设时空场为\n$$\nu(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t),\n$$\n其中 $\\omega_{1} > 0$ 和 $\\omega_{2} > 0$ 是不同的实常数。使用本征正交分解 (Proper Orthogonal Decomposition, POD) 的基本定义，其中空间 POD 模态是空间相关算子\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy,\n$$\n的特征函数，该算子由相关核\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt,\n$$\n构建。推导与 $u(x,t)$ 相关的解析空间 POD 模态。将模态表示为 $L^{2}([0,1])$-归一化函数。你的最终答案必须在一个单行矩阵中列出两个归一化空间 POD 模态。无需单位，也无需四舍五入。",
            "solution": "该问题要求推导给定空时场 $u(x,t)$ 的空间本征正交分解 (POD) 模态。根据定义，空间 POD 模态（记为 $\\phi(x)$）是空间两点相关算子 $\\mathcal{C}$ 的特征函数，该算子是以 $C(x,y)$ 为核的积分算子。该特征问题由下式给出：\n$$\n\\mathcal{C}[\\phi](x) = \\int_{0}^{1} C(x,y) \\, \\phi(y) \\, dy = \\lambda \\phi(x)\n$$\n核 $C(x,y)$ 定义为场在两个空间位置 $x$ 和 $y$ 的乘积的时间平均值。\n$$\nC(x,y) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} u(x,t) \\, u(y,t) \\, dt\n$$\n第一步是计算给定场 $u(x,t) = \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t)$ 的这个核。\n\n让我们展开乘积 $u(x,t) \\, u(y,t)$：\n\\begin{align*}\nu(x,t) \\, u(y,t) =  \\left[ \\sin(2\\pi x) \\cos(\\omega_{1} t) + \\sin(3\\pi x) \\cos(\\omega_{2} t) \\right] \\left[ \\sin(2\\pi y) \\cos(\\omega_{1} t) + \\sin(3\\pi y) \\cos(\\omega_{2} t) \\right] \\\\\n=  \\sin(2\\pi x) \\sin(2\\pi y) \\cos^2(\\omega_{1} t) \\\\\n + \\sin(3\\pi x) \\sin(3\\pi y) \\cos^2(\\omega_{2} t) \\\\\n + \\sin(2\\pi x) \\sin(3\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t) \\\\\n + \\sin(3\\pi x) \\sin(2\\pi y) \\cos(\\omega_{1} t) \\cos(\\omega_{2} t)\n\\end{align*}\n为了求得 $C(x,y)$，我们必须计算时间分量的长时间平均值。我们需要以下关于谐波函数的标准时间平均结果：\n1. 对于任何非零频率 $\\omega > 0$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\frac{1 + \\cos(2\\omega t)}{2} \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\left[ \\frac{t}{2} + \\frac{\\sin(2\\omega t)}{4\\omega} \\right]_{0}^{T} = \\frac{1}{2}\n$$\n2. 对于两个不同的正频率 $\\omega_1 \\neq \\omega_2$，\n$$\n\\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos(\\omega_1 t) \\cos(\\omega_2 t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{2T} \\int_{0}^{T} \\left[ \\cos((\\omega_1 - \\omega_2)t) + \\cos((\\omega_1 + \\omega_2)t) \\right] dt = 0\n$$\n第二个结果成立，因为余弦函数在一个周期内的积分为零，其不定积分是一个有界的正弦函数。除以 $T \\to \\infty$ 会使平均值趋于 $0$。\n\n将这些时间平均值应用于展开的乘积，涉及 $\\cos(\\omega_{1} t) \\cos(\\omega_{2} t)$ 的交叉项的平均值为零。我们得到：\n\\begin{align*}\nC(x,y) = \\sin(2\\pi x) \\sin(2\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{1} t) \\, dt \\right) + \\sin(3\\pi x) \\sin(3\\pi y) \\left( \\lim_{T \\to \\infty} \\frac{1}{T} \\int_{0}^{T} \\cos^2(\\omega_{2} t) \\, dt \\right) \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y)\n\\end{align*}\n这是一个秩为 $2$ 的可分离核。具有此类核的算子的特征函数必须位于构成该核的函数的张成空间中，即 $\\text{span}\\{\\sin(2\\pi x), \\sin(3\\pi x)\\}$。\n\n让我们检查基函数 $\\psi_1(x) = \\sin(2\\pi x)$ 和 $\\psi_2(x) = \\sin(3\\pi x)$ 在给定的内积 $\\langle f, g \\rangle = \\int_{0}^{1} f(x) g(x) \\, dx$ 下是否正交：\n$$\n\\langle \\psi_1, \\psi_2 \\rangle = \\int_{0}^{1} \\sin(2\\pi x) \\sin(3\\pi x) \\, dx = \\frac{1}{2} \\int_{0}^{1} \\left[ \\cos(\\pi x) - \\cos(5\\pi x) \\right] dx = \\frac{1}{2} \\left[ \\frac{\\sin(\\pi x)}{\\pi} - \\frac{\\sin(5\\pi x)}{5\\pi} \\right]_{0}^{1} = 0\n$$\n由于空间函数是正交的，它们确实是相关算子 $\\mathcal{C}$ 的特征函数。我们可以通过将它们代入特征问题来验证这一点。\n\n对于第一个候选特征函数 $\\phi(x) = \\psi_1(x) = \\sin(2\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_1](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(2\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin^2(2\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin(3\\pi y) \\sin(2\\pi y) \\, dy\n\\end{align*}\n由于正交性，第二个积分为零。第一个积分为：\n$$\n\\int_{0}^{1} \\sin^2(2\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(4\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(4\\pi y)}{8\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_1](x) = \\frac{1}{2} \\sin(2\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(2\\pi x)$。\n所以，$\\phi_1(x) = \\sin(2\\pi x)$ 是一个特征函数，其特征值为 $\\lambda_1 = \\frac{1}{4}$。\n\n对于第二个候选特征函数 $\\phi(x) = \\psi_2(x) = \\sin(3\\pi x)$：\n\\begin{align*}\n\\mathcal{C}[\\psi_2](x) = \\int_{0}^{1} \\left[ \\frac{1}{2} \\sin(2\\pi x) \\sin(2\\pi y) + \\frac{1}{2} \\sin(3\\pi x) \\sin(3\\pi y) \\right] \\sin(3\\pi y) \\, dy \\\\\n= \\frac{1}{2} \\sin(2\\pi x) \\int_{0}^{1} \\sin(2\\pi y) \\sin(3\\pi y) \\, dy + \\frac{1}{2} \\sin(3\\pi x) \\int_{0}^{1} \\sin^2(3\\pi y) \\, dy\n\\end{align*}\n第一个积分为零。第二个积分为：\n$$\n\\int_{0}^{1} \\sin^2(3\\pi y) \\, dy = \\int_{0}^{1} \\frac{1 - \\cos(6\\pi y)}{2} \\, dy = \\left[ \\frac{y}{2} - \\frac{\\sin(6\\pi y)}{12\\pi} \\right]_{0}^{1} = \\frac{1}{2}\n$$\n因此，$\\mathcal{C}[\\psi_2](x) = \\frac{1}{2} \\sin(3\\pi x) \\cdot \\frac{1}{2} = \\frac{1}{4} \\sin(3\\pi x)$。\n所以，$\\phi_2(x) = \\sin(3\\pi x)$ 是一个特征函数，其特征值为 $\\lambda_2 = \\frac{1}{4}$。\n\n最后一步是归一化这些特征函数，使其具有单位 $L^2$-范数。特征函数 $\\phi$ 的范数平方为 $\\|\\phi\\|^2 = \\langle \\phi, \\phi \\rangle = \\int_{0}^{1} \\phi(x)^2 \\, dx$。\n对于第一个模态 $\\sin(2\\pi x)$：\n$$\n\\|\\sin(2\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(2\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数为 $1 / \\sqrt{1/2} = \\sqrt{2}$。第一个归一化 POD 模态为 $\\hat{\\phi_1}(x) = \\sqrt{2} \\sin(2\\pi x)$。\n\n对于第二个模态 $\\sin(3\\pi x)$：\n$$\n\\|\\sin(3\\pi x)\\|^2 = \\int_{0}^{1} \\sin^2(3\\pi x) \\, dx = \\frac{1}{2}\n$$\n归一化常数也为 $\\sqrt{2}$。第二个归一化 POD 模态为 $\\hat{\\phi_2}(x) = \\sqrt{2} \\sin(3\\pi x)$。\n\n因此，两个非平凡的空间 POD 模态是 $\\sqrt{2} \\sin(2\\pi x)$ 和 $\\sqrt{2} \\sin(3\\pi x)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sqrt{2}\\sin(2\\pi x)  \\sqrt{2}\\sin(3\\pi x)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在工程和物理应用中，我们衡量一个场的“能量”或“重要性”时，通常需要考虑非均匀网格或物理属性，这要求使用加权内积。直接应用基于标准欧几里得范数的 POD 可能会产生物理上无意义的结果。本实践  将以一维热传导问题为例，指导你如何正确地实现加权 POD，确保所提取的模态在物理上是能量最优的，并能准确反映系统的热力学行为。",
            "id": "3981898",
            "problem": "考虑一个长度为 $L=1$ 的均匀杆中的一维瞬态热传导过程，其边界条件为均匀狄利克雷边界条件。设温度场在空间上由 $m$ 个网格点离散，在时间上由 $n_s$ 个快照离散，形成快照矩阵 $\\mathbf{X} \\in \\mathbb{R}^{m \\times n_s}$，其列是在不同时刻的空间温度场。表示具有热学意义的能量含量的空间内积由一个对称正定（SPD）权重矩阵 $\\mathbf{W} \\in \\mathbb{R}^{m \\times m}$ 定义，该矩阵源于空间求积或有限体积/有限元质量矩阵。因此，对于向量 $\\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^m$，加权内积为 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{W}} = \\mathbf{u}^\\top \\mathbf{W} \\mathbf{v}$。\n\n从能量守恒和 Fourier 定律出发，一维热方程由 $\\rho c \\,\\partial T/\\partial t = k \\,\\partial^2 T/\\partial x^2$ 给出，其中 $\\rho$ 是密度， $c$ 是比热， $k$ 是热导率。当在空间上进行离散化时，使用 $\\mathbf{W}$-加权内积来度量温度场的能量范数。本征正交分解（POD）旨在寻找一个降阶基，以最小化在 $\\mathbf{W}$-加权范数下度量的均方投影误差。降阶模型（ROM）则使用相应的时间相关系数来表示快照数据。\n\n您的任务是实现一个完整的算法，用于计算 $r$ 个关于 $\\mathbf{W}$ 正交归一的 POD 模态 $\\boldsymbol{\\Phi} \\in \\mathbb{R}^{m \\times r}$ 以及每个快照对应的系数 $\\mathbf{a}(t)$，具体方法如下：\n- 从最小化 $\\mathbf{W}$-加权重构误差的变分表征出发，推导一个源自 $\\mathbf{W}$-加权最优性定义的算法，而不依赖于快捷公式，并将其与一个适定且数值稳定的计算过程联系起来。\n- 确保 $\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\boldsymbol{\\Phi} = \\mathbf{I}_r$ 并计算用于从降阶基重构快照的系数矩阵。\n- 使用 $\\mathbf{W}$-加权 Frobenius 范数，量化 $r$ 个模态捕获的能量以及相对重构误差。\n\n为了进行测试，请使用具有均匀狄利克雷边界条件的一维热方程的解析级数解来构建 $\\mathbf{X}$：\n$$\nT(x,t) = \\sum_{n=1}^{N} b_n \\sin(n\\pi x)\\,\\exp\\left(-\\alpha (n\\pi)^2 t\\right),\n$$\n该解在 $[0,1]$ 上的 $m$ 个空间点 $\\{x_i\\}_{i=1}^m$ 和 $[0,t_{\\max}]$ 上的 $n_s$ 个时间实例处采样。使用由 $x_i = \\left(\\frac{i}{m-1}\\right)^{p}$（其中 $i=0,\\dots,m-1$ 且指数 $p>0$）定义的非均匀空间网格，并构建 $\\mathbf{W}$ 作为梯形法则权重 $w_i$ 的对角 SPD 矩阵，该权重近似于 $\\int_0^1 f(x)^2 \\, dx \\approx \\sum_{i=0}^{m-1} w_i f(x_i)^2$。非均匀网格上的梯形权重定义为 $w_0 = \\frac{x_1 - x_0}{2}$，$w_{m-1} = \\frac{x_{m-1} - x_{m-2}}{2}$，以及对于 $i=1,\\dots,m-2$ 有 $w_i = \\frac{x_{i+1} - x_{i-1}}{2}$。\n\n计算秩为 $r$ 的相对重构误差，它是一个无量纲量：\n$$\n\\varepsilon_r = 1 - \\frac{E_r}{E_{\\text{tot}}},\n$$\n其中 $E_{\\text{tot}}$ 是 $\\mathbf{W}$-加权快照总能量，$E_r$ 是 $r$ 个模态捕获的能量。所有最终输出都应表示为无物理单位的十进制浮点数。\n\n实现您的程序，为以下测试套件生成结果，每个测试由 $(m, n_s, t_{\\max}, \\alpha, N, \\{b_n\\}, p, r, c)$ 指定，其中 $c$ 用于缩放权重矩阵，即 $\\mathbf{W} \\leftarrow c\\,\\mathbf{W}$：\n\n- 测试用例 1（一般情况，非均匀网格，中等扩散率）：\n    - $m=80$, $n_s=60$, $t_{\\max}=1.0$, $\\alpha=0.05$, $N=3$, $\\{b_n\\} = \\{1.0, 0.8, 0.5\\}$, $p=1.2$, $r=3$, $c=1.0$。\n- 测试用例 2（边界情况，其中保留的模态数量等于生成的空间模态数量）：\n    - $m=60$, $n_s=40$, $t_{\\max}=1.2$, $\\alpha=0.04$, $N=2$, $\\{b_n\\} = \\{1.0, 0.5\\}$, $p=1.1$, $r=2$, $c=1.0$。\n- 测试用例 3（边缘情况，测试相对误差在 $\\mathbf{W}$ 缩放下的不变性）：\n    - $m=80$, $n_s=60$, $t_{\\max}=1.0$, $\\alpha=0.05$, $N=3$, $\\{b_n\\} = \\{1.0, 0.8, 0.5\\}$, $p=1.2$, $r=3$, $c=7.0$。\n- 测试用例 4（边缘情况 $r=0$）：\n    - $m=80$, $n_s=60$, $t_{\\max}=1.0$, $\\alpha=0.05$, $N=3$, $\\{b_n\\} = \\{1.0, 0.8, 0.5\\}$, $p=1.2$, $r=0$, $c=1.0$。\n\n您的程序必须：\n- 根据每个测试用例的指定参数构建 $\\mathbf{X}$。\n- 在指定的非均匀网格上使用梯形法则构建 $\\mathbf{W}$，并应用缩放因子 $c$。\n- 计算 $r$ 个 $\\mathbf{W}$-正交归一的 POD 模态及相应的系数。\n- 基于快照矩阵的 $\\mathbf{W}$-加权 Frobenius 范数和保留模态的贡献，为每个测试用例计算 $\\varepsilon_r$。\n- 生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号内逗号分隔的列表，例如：$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$。\n\n所有可能出现的角度都必须以弧度表示。最终的数值输出是无量纲的十进制浮点数。不允许外部输入；程序必须自包含运行并产生单行输出。",
            "solution": "任务的核心是推导并实现一种算法，用于计算关于由对称正定（SPD）矩阵 $\\mathbf{W}$ 定义的加权内积最优的 POD 模态。这通常被称为加权 POD 或广义 POD。\n\n设快照数据收集在一个矩阵 $\\mathbf{X} = [\\mathbf{x}_1, \\dots, \\mathbf{x}_{n_s}] \\in \\mathbb{R}^{m \\times n_s}$ 中，其中每列 $\\mathbf{x}_k$ 是在时刻 $t_k$ 的 $m$ 个空间点上的温度值向量。加权内积为 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle_{\\mathbf{W}} = \\mathbf{u}^\\top \\mathbf{W} \\mathbf{v}$，相应的范数为 $||\\mathbf{u}||_{\\mathbf{W}} = \\sqrt{\\mathbf{u}^\\top \\mathbf{W} \\mathbf{u}}$。\n\nPOD 的目标是找到一组 $r$ 个基向量（模态） $\\boldsymbol{\\Phi} = [\\boldsymbol{\\phi}_1, \\dots, \\boldsymbol{\\phi}_r] \\in \\mathbb{R}^{m \\times r}$，它们关于 $\\mathbf{W}$-内积是正交归一的，即 $\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\boldsymbol{\\Phi} = \\mathbf{I}_r$，并且能最小化原始快照与其在由 $\\boldsymbol{\\Phi}$ 张成的子空间上的投影之间的平均平方误差。快照 $\\mathbf{x}_k$ 的投影由 $\\mathbf{x}_{k,r} = \\boldsymbol{\\Phi}\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\mathbf{x}_k$ 给出。\n\n因此，优化问题是：\n$$\n\\min_{\\boldsymbol{\\Phi} \\in \\mathbb{R}^{m \\times r}, \\boldsymbol{\\Phi}^\\top \\mathbf{W} \\boldsymbol{\\Phi} = \\mathbf{I}_r} \\sum_{k=1}^{n_s} || \\mathbf{x}_k - \\boldsymbol{\\Phi}\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\mathbf{x}_k ||_{\\mathbf{W}}^2\n$$\n由于到正交归一基上投影的性质，这种最小化等价于最大化投影能量：\n$$\n\\max_{\\boldsymbol{\\Phi} \\in \\mathbb{R}^{m \\times r}, \\boldsymbol{\\Phi}^\\top \\mathbf{W} \\boldsymbol{\\Phi} = \\mathbf{I}_r} \\sum_{k=1}^{n_s} || \\boldsymbol{\\Phi}\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\mathbf{x}_k ||_{\\mathbf{W}}^2 = \\max_{\\boldsymbol{\\Phi} \\in \\mathbb{R}^{m \\times r}, \\boldsymbol{\\Phi}^\\top \\mathbf{W} \\boldsymbol{\\Phi} = \\mathbf{I}_r} \\sum_{j=1}^r \\sum_{k=1}^{n_s} (\\boldsymbol{\\phi}_j^\\top \\mathbf{W} \\mathbf{x}_k)^2\n$$\n这可以写成矩阵形式，即最大化 $\\text{Tr}(\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\mathbf{X} \\mathbf{X}^\\top \\mathbf{W} \\boldsymbol{\\Phi})$。根据 Courant-Fischer 定理，解由广义特征值问题 $\\mathbf{W} \\mathbf{X} \\mathbf{X}^\\top \\mathbf{W} \\boldsymbol{\\phi}_j = \\lambda_j \\mathbf{W} \\boldsymbol{\\phi}_j$ 的特征向量给出。直接求解此问题可能不稳定或效率低下。\n\n一种更鲁棒且在计算上更稳定的方法涉及将问题转换为一个标准的 POD 问题。由于 $\\mathbf{W}$ 是 SPD 矩阵，它有一个唯一的 SPD 平方根 $\\mathbf{W}^{1/2}$，也可以看作是 Cholesky 因子 $\\mathbf{L}$，其中 $\\mathbf{W}=\\mathbf{L}\\mathbf{L}^\\top$。由于 $\\mathbf{W}$ 是对角矩阵，$\\mathbf{W}^{1/2}$ 就是一个对角矩阵，其对角线元素是 $\\mathbf{W}$ 对角线元素的平方根。\n\n我们定义一个变换后的快照矩阵 $\\tilde{\\mathbf{X}} = \\mathbf{W}^{1/2} \\mathbf{X}$ 和变换后的基向量 $\\tilde{\\boldsymbol{\\Phi}} = \\mathbf{W}^{1/2} \\boldsymbol{\\Phi}$。正交归一条件 $\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\boldsymbol{\\Phi} = \\mathbf{I}_r$ 变为 $\\boldsymbol{\\Phi}^\\top (\\mathbf{W}^{1/2})^\\top \\mathbf{W}^{1/2} \\boldsymbol{\\Phi} = (\\mathbf{W}^{1/2}\\boldsymbol{\\Phi})^\\top(\\mathbf{W}^{1/2}\\boldsymbol{\\Phi}) = \\tilde{\\boldsymbol{\\Phi}}^\\top \\tilde{\\boldsymbol{\\Phi}} = \\mathbf{I}_r$。变换后的基向量必须在标准欧几里得内积下是正交归一的。\n\n类似地，目标函数变为最小化变换后数据的重构误差的标准 Frobenius 范数：\n$$\n\\sum_{k=1}^{n_s} || \\mathbf{x}_k - \\boldsymbol{\\Phi}\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\mathbf{x}_k ||_{\\mathbf{W}}^2 = || \\mathbf{W}^{1/2}(\\mathbf{X} - \\boldsymbol{\\Phi}\\boldsymbol{\\Phi}^\\top \\mathbf{W} \\mathbf{X}) ||_F^2 = || \\tilde{\\mathbf{X}} - \\tilde{\\boldsymbol{\\Phi}}\\tilde{\\boldsymbol{\\Phi}}^\\top \\tilde{\\mathbf{X}} ||_F^2\n$$\n这是矩阵 $\\tilde{\\mathbf{X}}$ 的标准 POD 问题。其解由 $\\tilde{\\mathbf{X}}$ 的奇异值分解（SVD）给出。设 $\\tilde{\\mathbf{X}} = \\mathbf{U} \\mathbf{\\Sigma} \\mathbf{V}^\\top$。最优的秩-$r$ 基 $\\tilde{\\boldsymbol{\\Phi}}$ 由 $\\tilde{\\mathbf{X}}$ 的前 $r$ 个左奇异向量组成，即 $\\tilde{\\boldsymbol{\\Phi}} = \\mathbf{U}_{:,1:r}$。\n原始物理空间中的 POD 模态通过逆变换得到：$\\boldsymbol{\\Phi} = (\\mathbf{W}^{1/2})^{-1} \\tilde{\\boldsymbol{\\Phi}} = \\mathbf{W}^{-1/2} \\mathbf{U}_{:,1:r}$。\n\n在 $\\mathbf{W}$-加权 Frobenius 范数下度量的快照总能量为：\n$$\nE_{\\text{tot}} = ||\\mathbf{X}||_{\\mathbf{W},F}^2 = \\text{Tr}(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}) = \\text{Tr}((\\mathbf{W}^{1/2}\\mathbf{X})^\\top (\\mathbf{W}^{1/2}\\mathbf{X})) = ||\\tilde{\\mathbf{X}}||_F^2\n$$\n根据 SVD 的性质， $||\\tilde{\\mathbf{X}}||_F^2 = \\sum_j \\sigma_j^2$，其中 $\\sigma_j$ 是 $\\tilde{\\mathbf{X}}$ 的奇异值。前 $r$ 个 POD 模态捕获的能量是 $E_r = \\sum_{j=1}^r \\sigma_j^2$。\n那么相对重构误差是：\n$$\n\\varepsilon_r = 1 - \\frac{E_r}{E_{\\text{tot}}} = 1 - \\frac{\\sum_{j=1}^r \\sigma_j^2}{\\sum_j \\sigma_j^2} = \\frac{\\sum_{j=r+1}^{\\min(m,n_s)} \\sigma_j^2}{\\sum_{j=1}^{\\min(m,n_s)} \\sigma_j^2}\n$$\n\n算法步骤如下：\n1.  对每个测试用例，定义参数 $m, n_s, t_{\\max}, \\alpha, N, \\{b_n\\}, p, r, c$。\n2.  使用 $x_i = (\\frac{i}{m-1})^p$ 构建非均匀空间网格 $\\{x_i\\}_{i=0}^{m-1}$。\n3.  使用给定的非均匀网格梯形法则构建对角权重矩阵 $\\mathbf{W} \\in \\mathbb{R}^{m \\times m}$，并应用缩放因子 $c$。\n4.  通过在空间网格点和 $[0, t_{\\max}]$ 内的 $n_s$ 个均匀分布的时间实例上评估 $T(x,t)$ 的解析解，构建快照矩阵 $\\mathbf{X} \\in \\mathbb{R}^{m \\times n_s}$。\n5.  计算对角矩阵 $\\mathbf{W}^{1/2}$。\n6.  形成加权快照矩阵 $\\tilde{\\mathbf{X}} = \\mathbf{W}^{1/2} \\mathbf{X}$。\n7.  使用 SVD 计算 $\\tilde{\\mathbf{X}}$ 的奇异值 $\\sigma_j$。\n8.  计算总能量 $E_{\\text{tot}} = \\sum_j \\sigma_j^2$ 和捕获的能量 $E_r = \\sum_{j=1}^r \\sigma_j^2$。\n9.  计算相对误差 $\\varepsilon_r = 1 - E_r / E_{\\text{tot}}$。对于边缘情况 $r=0$，这会得到 $\\varepsilon_0 = 1$。根据定义，当 $E_{\\text{tot}}=0$ 时，$\\varepsilon_r=0$。\n10. 存储每个测试用例的结果，并将最终输出格式化为逗号分隔的列表。\n\n作为一项解析性检验，将权重矩阵 $\\mathbf{W}$ 乘以一个常数 $c>0$，会使变换后的矩阵 $\\tilde{\\mathbf{X}}$ 缩放 $\\sqrt{c}$ 倍，其奇异值 $\\sigma_j$ 缩放 $\\sqrt{c}$ 倍，而 $E_{\\text{tot}}$ 和 $E_r$ 均缩放 $c$ 倍。因此，相对误差 $\\varepsilon_r$ 对此缩放必须是不变的。测试用例 3 对此性质提供了数值验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    Main function to solve the POD problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (m, ns, t_max, alpha, N, b_n, p, r, c)\n        (80, 60, 1.0, 0.05, 3, [1.0, 0.8, 0.5], 1.2, 3, 1.0),\n        (60, 40, 1.2, 0.04, 2, [1.0, 0.5], 1.1, 2, 1.0),\n        (80, 60, 1.0, 0.05, 3, [1.0, 0.8, 0.5], 1.2, 3, 7.0),\n        (80, 60, 1.0, 0.05, 3, [1.0, 0.8, 0.5], 1.2, 0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, ns, t_max, alpha, N, b_n_coeffs, p, r, c = case\n\n        # Step 1: Construct spatial and temporal grids\n        # Spatial grid on [0, 1] with m points\n        x = np.linspace(0, 1.0, m)**p\n        # Temporal grid on [0, t_max] with ns points\n        t = np.linspace(0, 1.0, ns) * t_max\n\n        # Step 2: Construct the snapshot matrix X\n        X = np.zeros((m, ns))\n        # Use broadcasting for efficiency: x becomes (m,1), t becomes (1,ns)\n        x_col = x[:, np.newaxis]\n        t_row = t[np.newaxis, :]\n        \n        for n_idx, b_val in enumerate(b_n_coeffs):\n            n = n_idx + 1\n            mode_term = b_val * np.sin(n * np.pi * x_col) * np.exp(-alpha * (n * np.pi)**2 * t_row)\n            X += mode_term\n\n        # Step 3: Construct the W matrix (trapezoidal weights)\n        w = np.zeros(m)\n        if m > 1:\n            dx = np.diff(x)\n            w[0] = dx[0] / 2.0\n            w[-1] = dx[-1] / 2.0\n            if m > 2:\n                w[1:-1] = (dx[:-1] + dx[1:]) / 2.0\n        \n        # W is a diagonal matrix. For multiplication, we can just use the vector w.\n        # Apply scaling factor c\n        w *= c\n\n        # Step 4: Form the weighted snapshot matrix\n        # W_sqrt is diag(sqrt(w)). W_sqrt @ X is equivalent to multiplying each row of X\n        # by the corresponding sqrt(w_i).\n        w_sqrt_diag = np.sqrt(w)\n        X_tilde = w_sqrt_diag[:, np.newaxis] * X\n\n        # Step 5: Compute SVD of the weighted snapshot matrix\n        # We only need the singular values. full_matrices=False is more efficient.\n        # compute_uv=False would be even better if only singular values are needed.\n        sigmas = svd(X_tilde, compute_uv=False)\n\n        # Step 6: Calculate energy and relative error\n        # The eigenvalues of the correlation matrix are the squares of the singular values.\n        eigenvalues = sigmas**2\n        \n        total_energy = np.sum(eigenvalues)\n        \n        if r > len(eigenvalues):\n            # If r is larger than the number of available modes, clamp it.\n            r_clamped = len(eigenvalues)\n        else:\n            r_clamped = r\n            \n        # For r=0, the sum over an empty slice is correctly 0.\n        captured_energy = np.sum(eigenvalues[:r_clamped])\n\n        if total_energy == 0.0:\n            # Avoid division by zero if all snapshots are zero.\n            relative_error = 0.0\n        else:\n            relative_error = 1.0 - (captured_energy / total_energy)\n            \n        results.append(relative_error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "虽然 POD 在处理扩散主导或振动问题时非常高效，但它在面对平流或平移主导的现象时会遇到基本限制。理解这些局限性对于正确选择和应用降阶模型至关重要。本实践  通过分析一个简单的平移高斯脉冲，让你亲身体验为何 POD 需要大量的模态才能捕捉平移运动，从而培养对模型适用边界的批判性思维。",
            "id": "3265968",
            "problem": "考虑由 $u(x,t) = \\exp\\!\\left(-\\big(x - c t\\big)^{2}\\right)$ 定义的平移高斯脉冲的快照函数族，其空间区间为 $x \\in [-L,L]$，离散时间为 $t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$。从基本原理出发，本征正交分解（POD）是这样一个过程：对于给定的秩 $r$，它在空间中选择一个 $r$ 维标准正交基，以最小化快照集的总平方投影误差。等价地，它在所有网格点和时间上，以欧几里得最小二乘意义，产生快照数据的最佳 $r$ 秩近似。\n\n您的任务是实现一个程序，该程序：\n- 构建快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$，其第 $k$ 列是在 $[-L,L]$ 上的 $N_x$ 个均匀间隔网格点上采样的快照 $u(x,t_k)$。其中，给定速度 $c$、快照数量 $m$ 和最终时间 $T$，时间点 $t_k$ 在 $[0,T]$ 内均匀分布。\n- 对于秩 $r \\in \\{1,2,5,10\\}$，计算最佳 $r$ 秩近似 $X_r$（由 POD 定义）及相应的相对重构误差\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F},$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 以浮点数形式报告每个测试案例的误差 $E_r$，四舍五入到六位小数。\n\n使用的基本原理：\n- 欧几里得内积和弗罗贝尼乌斯范数的定义。\n- 本征正交分解（POD）的定义性优化性质：在所有 $r$ 维标准正交基中，POD 最小化快照的总平方投影误差。这在最小二乘意义上产生了快照矩阵的最佳 $r$ 秩近似。\n\n测试套件：\n所有案例均使用 $L = 10$ 和 $N_x = 401$。四个测试案例如下：\n1. 案例 A（静止脉冲）：$c = 0$，$T = 5$，$m = 50$。\n2. 案例 B（慢速平移）：$c = 0.5$，$T = 10$，$m = 100$。\n3. 案例 C（快速平移）：$c = 2.0$，$T = 4$，$m = 80$。\n4. 案例 D（少量快照）：$c = 0.5$，$T = 10$，$m = 5$。\n\n答案规格：\n- 对于每个测试案例，输出一个包含四个浮点数的列表 $[E_{1},E_{2},E_{5},E_{10}]$，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表的每个元素是对应一个测试案例的四个误差的方括号列表，按案例 A、B、C、D 的顺序排列。例如，正确格式的输出应如下所示：\n$[[e_{A,1},e_{A,2},e_{A,5},e_{A,10}],[e_{B,1},e_{B,2},e_{B,5},e_{B,10}],[e_{C,1},e_{C,2},e_{C,5},e_{C,10}],[e_{D,1},e_{D,2},e_{D,5},e_{D,10}]]$，\n整行中没有任何空格。\n\n单位：\n- 此问题不要求使用物理单位。\n\n角度单位：\n- 不适用。\n\n百分比：\n- 不适用；所有量均以小数表示。\n\n您的实现必须是自包含的，不需要用户输入、外部文件或网络访问。它必须在现代编程语言中运行，并以单行形式生成上述确切的最终输出格式。",
            "solution": "### 基于原理的解决方案\n目标是计算一组数据快照的 $r$ 秩近似的相对重构误差。基本原理是，在弗罗贝尼乌斯范数定义的最小二乘意义上，最优的 $r$ 秩近似是通过奇异值分解（SVD）得到的。这一结果由 Eckart-Young-Mirsky 定理正式阐述。\n\n**1. 快照矩阵的构建**\n首先，我们对问题域进行离散化。空间域 $x \\in [-L, L]$ 在 $N_x$ 个均匀间隔的点上采样，形成网格 $\\{x_j\\}_{j=0}^{N_x-1}$。时间区间 $t \\in [0, T]$ 在 $m$ 个离散、等距的点上采样，形成 $\\{t_k\\}_{k=0}^{m-1}$。每个时间点 $t_k$ 的快照数据是一个 $\\mathbb{R}^{N_x}$ 中的向量，其元素由函数 $u(x_j, t_k)$ 给出。这些快照的集合构成了快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$ 的列。该矩阵的一个元素 $X_{jk}$ 由下式给出：\n$$X_{jk} = u(x_j, t_k) = \\exp\\!\\left(-\\big(x_j - c t_k\\big)^{2}\\right)$$\n\n**2. 奇异值分解与最优近似**\n快照矩阵 $X$ 的 SVD 分解如下：\n$$X = U \\Sigma V^T$$\n其中 $U \\in \\mathbb{R}^{N_x \\times N_x}$ 是一个正交矩阵，其列 $u_i$ 是左奇异向量（POD 模态）；$V \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列 $v_i$ 是右奇异向量；$\\Sigma \\in \\mathbb{R}^{N_x \\times m}$ 是一个矩形对角矩阵，包含奇异值 $\\sigma_i$。奇异值非负，并按惯例排序：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$，其中 $k = \\min(N_x, m)$ 是矩阵的秩。\n\nEckart-Young-Mirsky 定理指出，最小化差异的弗罗贝尼乌斯范数 $\\lVert X - X_r \\rVert_F$ 的 $X$ 的最佳 $r$ 秩近似是截断的 SVD：\n$$X_r = \\sum_{i=1}^{r} \\sigma_i u_i v_i^T$$\n这个近似是使用前 $r$ 个奇异值及其对应的左、右奇异向量构造的。\n\n**3. 误差计算**\n相对重构误差 $E_r$ 定义为误差矩阵 $(X - X_r)$ 的弗罗贝尼乌斯范数与原始矩阵 $X$ 的弗罗贝尼乌斯范数之比。弗罗贝尼乌斯范数与奇异值通过恒等式 $\\lVert A \\rVert_F^2 = \\sum_{i=1}^{\\text{rank}(A)} \\sigma_i(A)^2$ 相关联。\n应用此性质，原始矩阵的范数平方是其所有奇异值平方的和：\n$$\\lVert X \\rVert_F^2 = \\sum_{i=1}^{k} \\sigma_i^2$$\n误差矩阵为 $X - X_r = \\sum_{i=r+1}^{k} \\sigma_i u_i v_i^T$。由于奇异向量的正交性，误差矩阵的弗罗贝尼乌斯范数平方是被舍弃的奇异值的平方和：\n$$\\lVert X - X_r \\rVert_F^2 = \\sum_{i=r+1}^{k} \\sigma_i^2$$\n结合这些结果，相对重构误差由下式给出：\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F} = \\frac{\\sqrt{\\sum_{i=r+1}^{k} \\sigma_i^2}}{\\sqrt{\\sum_{i=1}^{k} \\sigma_i^2}}$$\n请注意，如果请求的秩 $r$ 大于或等于矩阵的实际秩 $k$，则分子中的和为空，其值为 $0$，从而正确地得到误差 $E_r = 0$。\n\n**4. 计算步骤**\n对每个测试案例，算法按以下步骤进行：\n1. 定义参数 $c$、$T$ 和 $m$，以及固定常数 $L=10$ 和 $N_x=401$。\n2. 构建空间网格 $x$ 和时间网格 $t$。\n3. 使用给定的函数 $u(x,t)$ 组装 $N_x \\times m$ 的快照矩阵 $X$。\n4. 使用标准的数值库函数进行 SVD 分解，计算 $X$ 的奇异值 $\\sigma_i$。最有效的方法是只计算奇异值，而不是完整的 $U$ 和 $V$ 矩阵。\n5. 计算总能量，即弗罗贝尼乌斯范数的平方，$S_{total} = \\sum_{i=1}^{k} \\sigma_i^2$。\n6. 对于每个所需的秩 $r \\in \\{1, 2, 5, 10\\}$，计算误差能量 $S_{error} = \\sum_{i=r+1}^{k} \\sigma_i^2$。\n7. 相对误差即为 $E_r = \\sqrt{S_{error} / S_{total}}$。\n8. 收集每个测试案例计算出的误差，并根据输出规格进行格式化。\n此过程提供了一种直接且数值稳定的方法，用于根据线性代数的基本原理确定所需的重构误差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Proper Orthogonal Decomposition problem for a translating Gaussian pulse.\n    \"\"\"\n    # Global parameters for all test cases\n    L = 10.0\n    Nx = 401\n    ranks_to_compute = [1, 2, 5, 10]\n\n    # Test suite: (c, T, m)\n    # c: speed, T: final time, m: number of snapshots\n    test_cases = [\n        (0.0, 5.0, 50),   # Case A: stationary pulse\n        (0.5, 10.0, 100), # Case B: slow translation\n        (2.0, 4.0, 80),   # Case C: fast translation\n        (0.5, 10.0, 5),   # Case D: few snapshots\n    ]\n\n    all_results = []\n\n    for c, T, m in test_cases:\n        # 1. Create spatial and temporal grids\n        x = np.linspace(-L, L, Nx)\n        t = np.linspace(0.0, T, m)\n\n        # 2. Construct the snapshot matrix X using broadcasting\n        # x_col has shape (Nx, 1) and t_row has shape (1, m)\n        # Broadcasting expands them to (Nx, m) for element-wise operations\n        x_col = x[:, np.newaxis]\n        t_row = t[np.newaxis, :]\n        X = np.exp(-((x_col - c * t_row) ** 2))\n\n        # 3. Compute the singular values of X\n        # We only need the singular values, so compute_uv=False is most efficient.\n        s = np.linalg.svd(X, compute_uv=False)\n        num_singular_values = s.shape[0]\n\n        # 4. Calculate the total energy (squared Frobenius norm of X)\n        # This is the sum of the squares of all singular values.\n        norm_X_sq = np.sum(s**2)\n\n        case_errors = []\n        for r in ranks_to_compute:\n            # 5. Calculate the reconstruction error for rank r\n            \n            # If norm_X_sq is zero, all errors are zero.\n            if norm_X_sq == 0.0:\n                 error = 0.0\n            # If rank r is >= number of singular values, the approximation is perfect.\n            elif r >= num_singular_values:\n                error = 0.0\n            else:\n                # The error norm is based on the truncated singular values (from r to end).\n                # s[r:] corresponds to sigma_{r+1}, sigma_{r+2}, ...\n                norm_err_sq = np.sum(s[r:]**2)\n                error = np.sqrt(norm_err_sq / norm_X_sq)\n            \n            case_errors.append(error)\n\n        all_results.append(case_errors)\n\n    # 6. Format the output string exactly as specified.\n    # e.g., [[err1,err2,...],[err1,err2,...]] with no spaces.\n    formatted_sublists = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        formatted_numbers = [f\"{err:.6f}\" for err in res_list]\n        # Join numbers with commas and enclose in brackets.\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    # Join the sublists with commas and enclose in outer brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}