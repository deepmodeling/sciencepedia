{
    "hands_on_practices": [
        {
            "introduction": "从粗粒化模型重建原子细节的最直接方法之一，是寻找在满足粗粒化约束条件下能量最低的原子构型。这本质上是一个约束优化问题，即在保持粗粒化变量 $y$ 不变（$M(x)=y$）的同时，最小化原子势能 $U_{\\mathrm{AA}}(x)$。通过解决一个一维原子链的简化模型，本练习将引导您构建并求解此类问题，为您提供基于能量最小化进行反向映射的数学和计算核心的实践经验。",
            "id": "3735180",
            "problem": "考虑一个由 $N=4$ 个原子组成的一维原子链，其位置汇集于一个向量 $x \\in \\mathbb{R}^4$ 中。原子势能 $U_{\\mathrm{AA}}(x)$ 通过连续原子之间的一系列谐振子弹簧来建模，这些弹簧具有均匀的刚度 $k>0$ 和平衡间距 $a>0$，其定义为\n$$\nU_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\sum_{i=1}^{3} \\left(x_{i+1} - x_i - a\\right)^2.\n$$\n引入线性差分算子 $D \\in \\mathbb{R}^{3 \\times 4}$，其形式为\n$$\nD = \\begin{bmatrix}\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1\n\\end{bmatrix},\n$$\n因此 $U_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\left\\| D x - a \\mathbf{1} \\right\\|_2^2$，其中 $\\mathbf{1} \\in \\mathbb{R}^3$ 是全一向量。定义一个粗粒化映射 $M \\in \\mathbb{R}^{2 \\times 4}$，它通过珠粒平均的方式将原子位置 $x$ 映射到两个粗粒化珠粒位置 $y \\in \\mathbb{R}^2$，\n$$\nM = \\begin{bmatrix}\n\\frac{1}{2}  \\frac{1}{2}  0  0 \\\\\n0  0  \\frac{1}{2}  \\frac{1}{2}\n\\end{bmatrix}, \\quad \\text{即} \\quad M x = y, \\quad \\text{也即 } y_1 = \\frac{x_1 + x_2}{2}, \\; y_2 = \\frac{x_3 + x_4}{2}.\n$$\n任务是应用约束能量最小化来弛豫高频畸变，同时精确保持粗粒化映射约束 $M(x) = y$，然后量化其对指定初始畸变集合上 $U_{\\mathrm{AA}}$ 分布的影响。\n\n对于一个给定的粗粒化状态 $y \\in \\mathbb{R}^2$，定义一个基础原子构型 $x^{\\mathrm{base}}(y,a) \\in \\mathbb{R}^4$ 为\n$$\nx^{\\mathrm{base}}(y,a) = \\begin{bmatrix}\ny_1 - \\frac{a}{2} \\\\\ny_1 + \\frac{a}{2} \\\\\ny_2 - \\frac{a}{2} \\\\\ny_2 + \\frac{a}{2}\n\\end{bmatrix}.\n$$\n一个保持粗粒化映射 $M x = y$ 的高频畸变是任何形如 $d(s_1,s_2) \\in \\mathbb{R}^4$ 的向量\n$$\nd(s_1,s_2) = \\begin{bmatrix}\ns_1 \\\\\n- s_1 \\\\\ns_2 \\\\\n- s_2\n\\end{bmatrix},\n$$\n对于实数标量 $(s_1,s_2)$，因为 $M d(s_1,s_2) = 0$。对于一个畸变振幅列表 $\\{(s_1^{(j)}, s_2^{(j)})\\}_{j=1}^{S}$，定义初始原子构型\n$$\nx^{(0)}_j = x^{\\mathrm{base}}(y,a) + d\\!\\left(s_1^{(j)}, s_2^{(j)}\\right), \\quad j = 1,\\dots,S,\n$$\n它们都满足 $M x^{(0)}_j = y$。对于每个初始构型，评估初始能量 $U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right)$ 并计算样本均值和总体方差\n$$\n\\mu_{\\mathrm{pre}} = \\frac{1}{S} \\sum_{j=1}^{S} U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right), \\qquad\n\\sigma^2_{\\mathrm{pre}} = \\frac{1}{S} \\sum_{j=1}^{S} \\left( U_{\\mathrm{AA}}\\!\\left(x^{(0)}_j\\right) - \\mu_{\\mathrm{pre}} \\right)^2.\n$$\n\n为弛豫高频畸变，在线性等式约束 $M x = y$ 下对 $U_{\\mathrm{AA}}(x)$ 进行约束能量最小化。从 $U_{\\mathrm{AA}}(x)$ 的基本定义和线性约束出发，使用拉格朗日乘子法推导约束极小值点 $\\hat{x}(y)$。然后计算最小化后的能量 $U_{\\mathrm{AA}}\\!\\left(\\hat{x}(y)\\right)$，并定义在相同初始畸变集合上的最小化后分布。因为对于固定的 $y$，极小值点是唯一的，所以最小化后的能量在整个畸变集合中是恒定的，从而得到\n$$\n\\mu_{\\mathrm{post}} = U_{\\mathrm{AA}}\\!\\left(\\hat{x}(y)\\right), \\qquad \\sigma^2_{\\mathrm{post}} = 0.\n$$\n通过差值来量化最小化对分布的影响\n$$\n\\Delta \\mu = \\mu_{\\mathrm{pre}} - \\mu_{\\mathrm{post}}, \\qquad \\Delta \\sigma^2 = \\sigma^2_{\\mathrm{pre}} - \\sigma^2_{\\mathrm{post}} = \\sigma^2_{\\mathrm{pre}}.\n$$\n所有计算均采用无量纲单位；将能量和统计数据报告为无量纲数值。\n\n实现一个程序，该程序构建 $D$ 和 $M$，构造约束最小化问题，并为以下每个测试用例计算 $\\Delta \\mu$ 和 $\\Delta \\sigma^2$。使用上面给出的总体方差定义。不允许有任何随机性；所有结果必须由指定的输入确定。\n\n测试套件：\n- 用例 1 (理想情况): $k = 10$, $a = 1$, $y = [0, 3]$, 畸变 $\\{(s_1^{(j)}, s_2^{(j)})\\}_{j=1}^{5}$ 为 $(0.2,-0.1)$, $(0.4,0.0)$, $(-0.3,0.6)$, $(0.0,0.0)$, $(1.0,-0.5)$。\n- 用例 2 (边界情况，零畸变): $k = 5$, $a = 1$, $y = [1, 4]$, 畸变 $\\{(0.0, 0.0)\\}$。\n- 用例 3 (软弹簧): $k = 0.1$, $a = 1.5$, $y = [2.0, 2.0]$, 畸变 $\\{(0.5, -0.5), (0.2, 0.3), (0.0, 0.0), (-0.4, 0.1)\\}$。\n- 用例 4 (硬弹簧，应变): $k = 1000$, $a = 1.0$, $y = [0.0, 0.5]$, 畸变 $\\{(0.1, -0.1), (0.2, 0.3), (-0.2, 0.0)\\}$。\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，输出数对 $[\\Delta \\mu, \\Delta \\sigma^2]$，并将所有四个用例的结果按顺序汇总到一个列表中，例如 $[[\\Delta \\mu_1,\\Delta \\sigma^2_1],[\\Delta \\mu_2,\\Delta \\sigma^2_2],[\\Delta \\mu_3,\\Delta \\sigma^2_3],[\\Delta \\mu_4,\\Delta \\sigma^2_4]]$。",
            "solution": "该问题是有效的，因为它在经典力学和线性代数方面有科学依据，是适定的、客观的且内部一致的。它提出了一个多尺度建模中的标准可解问题，具体来说是通过约束能量最小化，从粗粒化表示反向映射到详细的原子构型。所有需要的数据和定义都已提供。\n\n任务的核心是找到原子构型 $\\hat{x} \\in \\mathbb{R}^4$，它在满足线性约束 $M x = y$ 的条件下，使原子势能 $U_{\\mathrm{AA}}(x)$ 最小化，其中 $y$ 是一个给定的粗粒化状态。势能是原子位置 $x$ 的二次函数：\n$$\nU_{\\mathrm{AA}}(x) = \\frac{1}{2} k \\| D x - a \\mathbf{1} \\|_2^2\n$$\n这是一个带线性等式约束的二次规划问题。我们可以使用拉格朗日乘子法来解决此问题。要最小化的目标函数是 $f(x) = U_{\\mathrm{AA}}(x)$，约束是 $g(x) = M x - y = 0$。拉格朗日函数 $\\mathcal{L}(x, \\lambda)$ 定义为：\n$$\n\\mathcal{L}(x, \\lambda) = f(x) + \\lambda^T g(x) = \\frac{1}{2} k (D x - a \\mathbf{1})^T (D x - a \\mathbf{1}) + \\lambda^T (M x - y)\n$$\n其中 $\\lambda \\in \\mathbb{R}^2$ 是拉格朗日乘子向量。为了找到极小值点 $\\hat{x}$，我们通过将拉格朗日函数关于 $x$ 和 $\\lambda$ 的梯度设置为零来找到其驻点。\n\n关于 $x$ 的梯度是：\n$$\n\\nabla_x \\mathcal{L} = \\nabla_x \\left( \\frac{1}{2} k (x^T D^T D x - 2a \\mathbf{1}^T D x + a^2 \\mathbf{1}^T \\mathbf{1}) + \\lambda^T M x - \\lambda^T y \\right) = k (D^T D x - a D^T \\mathbf{1}) + M^T \\lambda\n$$\n设置 $\\nabla_x \\mathcal{L} = 0$ 得到第一个 Karush-Kuhn-Tucker (KKT) 条件：\n$$\nk (D^T D) x + M^T \\lambda = k a D^T \\mathbf{1}\n$$\n关于 $\\lambda$ 的梯度是：\n$$\n\\nabla_\\lambda \\mathcal{L} = M x - y\n$$\n设置 $\\nabla_\\lambda \\mathcal{L} = 0$ 得到第二个 KKT 条件，它就是原始的约束：\n$$\nM x = y\n$$\n这两个条件构成了一个关于未知极小值点 $\\hat{x}$ 和拉格朗日乘子 $\\lambda$ 的线性方程组。我们可以将此系统写成分块矩阵形式：\n$$\n\\begin{bmatrix}\nk D^T D  M^T \\\\\nM  0\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nk a D^T \\mathbf{1} \\\\\ny\n\\end{bmatrix}\n$$\n其中左侧的分块矩阵是 KKT 矩阵。这是一个 $6 \\times 6$ 的系统，因为 $x \\in \\mathbb{R}^4$ 且 $\\lambda \\in \\mathbb{R}^2$。矩阵 $D^T D$ 是离散一维拉普拉斯算子 $\\begin{bsmallmatrix} 1  -1  0  0 \\\\ -1  2  -1  0 \\\\ 0  -1  2  -1 \\\\ 0  0  -1  1 \\end{bsmallmatrix}$。KKT 矩阵是可逆的，这保证了对于任何有效的参数集，都存在唯一的解 $(\\hat{x}, \\lambda)$。$x$ 的解就是约束极小值点 $\\hat{x}(y)$。\n\n总体算法如下：\n1.  对于每个由参数 $k$、$a$、$y$ 和一个包含 $S$ 个畸变对 $\\{(s_1^{(j)}, s_2^{(j)})\\}$ 的集合指定的测试用例，首先计算初始能量。\n    a. 构建基础构型 $x^{\\mathrm{base}}(y,a) = [y_1 - a/2, y_1 + a/2, y_2 - a/2, y_2 + a/2]^T$。\n    b. 对于每个 $j=1, \\dots, S$，构建初始构型 $x^{(0)}_j = x^{\\mathrm{base}} + d(s_1^{(j)}, s_2^{(j)})$。\n    c. 对于每个初始构型，评估能量 $U_{\\mathrm{AA}}(x^{(0)}_j) = \\frac{1}{2} k \\| D x^{(0)}_j - a \\mathbf{1} \\|_2^2$。\n    d. 计算这些初始能量的最小化前样本均值 $\\mu_{\\mathrm{pre}}$ 和总体方差 $\\sigma^2_{\\mathrm{pre}}$。\n\n2.  接下来，计算单个最小化后的能量。\n    a. 使用给定的 $k$、$a$ 和 $y$ 构建 $6 \\times 6$ 的 KKT 矩阵和 $6 \\times 1$ 的右端向量。\n    b. 求解该线性系统以找到解向量，并从中提取约束极小值点 $\\hat{x}(y)$。\n    c. 计算最小化后的能量 $\\mu_{\\mathrm{post}} = U_{\\mathrm{AA}}(\\hat{x}(y))$。最小化后的方差为 $\\sigma^2_{\\mathrm{post}} = 0$，因为对于给定的 $y$，极小值点 $\\hat{x}(y)$ 是唯一的，且与初始高频畸变无关。\n\n3.  最后，计算所需的差值：$\\Delta \\mu = \\mu_{\\mathrm{pre}} - \\mu_{\\mathrm{post}}$ 和 $\\Delta \\sigma^2 = \\sigma^2_{\\mathrm{pre}} - \\sigma^2_{\\mathrm{post}} = \\sigma^2_{\\mathrm{pre}}$。\n\n为所提供的四个测试用例分别执行此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained energy minimization problem for four test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"k\": 10.0,\n            \"a\": 1.0,\n            \"y\": np.array([0.0, 3.0]),\n            \"distortions\": [(0.2, -0.1), (0.4, 0.0), (-0.3, 0.6), (0.0, 0.0), (1.0, -0.5)]\n        },\n        {\n            \"k\": 5.0,\n            \"a\": 1.0,\n            \"y\": np.array([1.0, 4.0]),\n            \"distortions\": [(0.0, 0.0)]\n        },\n        {\n            \"k\": 0.1,\n            \"a\": 1.5,\n            \"y\": np.array([2.0, 2.0]),\n            \"distortions\": [(0.5, -0.5), (0.2, 0.3), (0.0, 0.0), (-0.4, 0.1)]\n        },\n        {\n            \"k\": 1000.0,\n            \"a\": 1.0,\n            \"y\": np.array([0.0, 0.5]),\n            \"distortions\": [(0.1, -0.1), (0.2, 0.3), (-0.2, 0.0)]\n        }\n    ]\n\n    # Define constant matrices D and M\n    D = np.array([\n        [-1.0, 1.0, 0.0, 0.0],\n        [0.0, -1.0, 1.0, 0.0],\n        [0.0, 0.0, -1.0, 1.0]\n    ])\n    M = np.array([\n        [0.5, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 0.5, 0.5]\n    ])\n    \n    DTD = D.T @ D\n    MT = M.T\n    \n    def compute_U_aa(x, k, a):\n        \"\"\"Computes the atomistic potential energy.\"\"\"\n        bonds = D @ x\n        a_vec = a * np.ones(3)\n        return 0.5 * k * np.sum((bonds - a_vec)**2)\n\n    results = []\n    for case in test_cases:\n        k = case[\"k\"]\n        a = case[\"a\"]\n        y = case[\"y\"]\n        distortions = case[\"distortions\"]\n\n        # --- Pre-minimization statistics ---\n        x_base = np.array([y[0] - a/2, y[0] + a/2, y[1] - a/2, y[1] + a/2])\n        \n        initial_energies = []\n        for s1, s2 in distortions:\n            d = np.array([s1, -s1, s2, -s2])\n            x0 = x_base + d\n            energy = compute_U_aa(x0, k, a)\n            initial_energies.append(energy)\n        \n        energies_arr = np.array(initial_energies)\n        mu_pre = np.mean(energies_arr)\n        # Population variance (ddof=0 is the default in np.var)\n        sigma2_pre = np.var(energies_arr)\n\n        # --- Post-minimization statistics ---\n        # Construct and solve the KKT system\n        # [ k*DTD  M^T ] [x] = [ k*a*D^T*1 ]\n        # [ M      0   ] [l]   [ y         ]\n        \n        # KKT matrix (6x6)\n        kkt_mat = np.zeros((6, 6))\n        kkt_mat[0:4, 0:4] = k * DTD\n        kkt_mat[0:4, 4:6] = MT\n        kkt_mat[4:6, 0:4] = M\n        \n        # RHS vector (6x1)\n        rhs = np.zeros(6)\n        DT_ones = D.T @ np.ones(3)\n        rhs[0:4] = k * a * DT_ones\n        rhs[4:6] = y\n        \n        # Solve the system\n        solution = np.linalg.solve(kkt_mat, rhs)\n        x_hat = solution[0:4]\n        \n        mu_post = compute_U_aa(x_hat, k, a)\n        # sigma2_post is 0 by definition\n\n        # --- Calculate differences ---\n        delta_mu = mu_pre - mu_post\n        delta_sigma2 = sigma2_pre # since sigma2_post is 0\n        \n        results.append([delta_mu, delta_sigma2])\n\n    # Format output as a string representing a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在实践中，为了提高灵活性和数值稳定性，研究者们常用“软”谐波限制取代严格的几何约束。然而，一个关键问题随之而来：如何以物理上有意义的方式选择限制强度（即刚度系数 $\\kappa$）？本练习将启发式地选择 $\\kappa$ 与严谨的贝叶斯推断框架联系起来，将粗粒化数据视为对真实原子状态的带噪声测量。通过推导最佳刚度，您将深刻理解如何验证和校准模拟参数，以确保反向映射过程不会引入非预期的偏差。",
            "id": "3735196",
            "problem": "考虑一个热平衡的原子系统，其坐标为 $x \\in \\mathbb{R}^{n}$，势能为 $U(x)$，绝对温度为 $T$。其在 $x$ 上的平衡分布是玻尔兹曼分布 $p(x) \\propto \\exp(-\\beta U(x))$，其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数。设 $M: \\mathbb{R}^{n} \\to \\mathbb{R}^{m}$ 是一个已知的多对一粗粒化映射，它返回粗粒化描述符 $m = M(x)$，例如粗粒化表示中的珠子位置。\n\n假设给定目标粗粒化坐标 $y \\in \\mathbb{R}^{m}$，我们希望通过对条件分布 $p(x \\mid y)$ 进行采样来重建原子细节，且采样方式不会对预期的后验分布产生偏差。假设粗粒化数据的观测模型在映射空间中是各向同性高斯的，这意味着 $y$ 是通过 $y = M(x) + \\varepsilon$ 从 $M(x)$ 生成的，其中 $\\varepsilon$ 服从均值为零、协方差为 $\\sigma^{2} I_{m}$ 的高斯分布，$I_{m}$ 是 $m \\times m$ 单位矩阵，且 $\\sigma^{2} > 0$ 是已知的。在该模型下，似然函数为 $p(y \\mid x) \\propto \\exp\\!\\left(-\\frac{1}{2 \\sigma^{2}} \\|M(x) - y\\|^{2}\\right)$。\n\n在实践中，多尺度建模和分析中反向映射（backmapping）的常用策略是，在原子势能中加入一个软谐波限制能 $E_{\\mathrm{rest}}(x;y) = \\frac{\\kappa}{2} \\|M(x) - y\\|^{2}$，并从受限的玻尔兹曼分布 $q(x \\mid y) \\propto \\exp\\!\\left(-\\beta \\left[ U(x) + E_{\\mathrm{rest}}(x;y) \\right]\\right)$ 中进行采样。为了平衡对粗粒化目标 $y$ 的保真度和原子自由度的弛豫，并避免对条件分布 $p(x \\mid y)$ 产生偏差，请选择 $\\kappa$ 使得在所述观测模型下，$q(x \\mid y)$ 与 $p(x \\mid y)$ 相匹配。\n\n请从第一性原理出发，不使用任何快捷公式，推导出一个关于 $k_B$、$T$ 和 $\\sigma^{2}$ 的最优标量刚度 $\\kappa$ 的闭式解析表达式，该表达式能确保受限系综 $q(x \\mid y)$ 再现由高斯观测模型所蕴含的贝叶斯后验分布 $p(x \\mid y)$。请将您的最终答案表示为单个解析表达式。不要代入数值，最终的方框答案中也不要包含单位。为便于解释，$\\kappa$ 的单位是能量/长度的平方（例如，千焦/摩尔/平方纳米）。不需要进行数值舍入。",
            "solution": "目标是确定最优的标量刚度常数 $\\kappa$，使得受限玻尔兹曼分布 $q(x \\mid y)$ 等价于贝叶斯后验分布 $p(x \\mid y)$。这种等价性要求它们的概率密度函数必须相同。\n\n首先，我们使用贝叶斯定理推导后验分布 $p(x \\mid y)$ 的函数形式。给定观测到的粗粒化数据 $y$，原子坐标 $x$ 的后验分布正比于似然函数 $p(y \\mid x)$ 和先验分布 $p(x)$ 的乘积：\n$$p(x \\mid y) \\propto p(y \\mid x) p(x)$$\n问题给出了先验分布和似然函数的表达式。先验分布 $p(x)$ 是原子系统在绝对温度 $T$ 下的正则玻尔兹曼分布：\n$$p(x) \\propto \\exp(-\\beta U(x))$$\n其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数，$U(x)$ 是原子势能。\n\n似然函数 $p(y \\mid x)$ 源于观测模型 $y = M(x) + \\varepsilon$，其中噪声 $\\varepsilon$ 服从均值为零、协方差为 $\\sigma^2 I_m$ 的高斯分布。因此，对于给定的噪声向量 $\\varepsilon = y - M(x)$，其概率密度正比于 $\\exp(-\\frac{1}{2\\sigma^2} \\|\\varepsilon\\|^2)$。这给出了似然函数：\n$$p(y \\mid x) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2} \\|y - M(x)\\|^2\\right)$$\n由于欧几里得范数的平方 $\\|A-B\\|^2$ 等于 $\\|B-A\\|^2$，我们可以将其写为：\n$$p(y \\mid x) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2\\right)$$\n将先验分布和似然函数的表达式代入贝叶斯定理，我们得到后验分布的函数形式：\n$$p(x \\mid y) \\propto \\exp(-\\beta U(x)) \\cdot \\exp\\left(-\\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2\\right)$$\n根据指数函数的性质，我们合并指数中的项：\n$$p(x \\mid y) \\propto \\exp\\left(-\\beta U(x) - \\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2\\right)$$\n\n接下来，我们分析受限玻尔兹曼分布 $q(x \\mid y)$ 的函数形式。该分布是通过在原子势能 $U(x)$ 中补充一个谐波限制能 $E_{\\mathrm{rest}}(x;y)$ 来定义的：\n$$q(x \\mid y) \\propto \\exp\\left(-\\beta \\left[U(x) + E_{\\mathrm{rest}}(x;y)\\right]\\right)$$\n限制能由 $E_{\\mathrm{rest}}(x;y) = \\frac{\\kappa}{2} \\|M(x) - y\\|^2$ 给出。将其代入 $q(x \\mid y)$ 的表达式得到：\n$$q(x \\mid y) \\propto \\exp\\left(-\\beta \\left[U(x) + \\frac{\\kappa}{2} \\|M(x) - y\\|^2\\right]\\right)$$\n将逆温度 $\\beta$ 分配到方括号中的各项，得到：\n$$q(x \\mid y) \\propto \\exp\\left(-\\beta U(x) - \\frac{\\beta \\kappa}{2} \\|M(x) - y\\|^2\\right)$$\n\n问题要求我们找到使 $q(x \\mid y)$ 和 $p(x \\mid y)$ 相同的 $\\kappa$ 值。对于两个在归一化常数内定义的概率分布，若要它们相同，其密度函数对变量 $x$ 的函数依赖关系必须相同。这意味着它们各自表达式中的指数项必须相等，可能相差一个不依赖于 $x$ 的加性常数。\n\n比较 $p(x \\mid y)$ 和 $q(x \\mid y)$ 的指数项：\n$$p(x \\mid y) \\text{ 的指数项}: \\quad -\\beta U(x) - \\frac{1}{2\\sigma^2} \\|M(x) - y\\|^2$$\n$$q(x \\mid y) \\text{ 的指数项}: \\quad -\\beta U(x) - \\frac{\\beta \\kappa}{2} \\|M(x) - y\\|^2$$\n为使这两个表达式对所有构型 $x$ 都等价，$-\\beta U(x)$ 项已经匹配。因此，我们必须令剩余项 $\\|M(x) - y\\|^2$ 的系数相等：\n$$\\frac{1}{2\\sigma^2} = \\frac{\\beta \\kappa}{2}$$\n现在我们可以解这个代数方程求 $\\kappa$。两边同乘以 $2$ 消去因子 $1/2$：\n$$\\frac{1}{\\sigma^2} = \\beta \\kappa$$\n分离出 $\\kappa$，我们得到：\n$$\\kappa = \\frac{1}{\\beta \\sigma^2}$$\n最后，我们将 $\\beta = 1/(k_B T)$ 的定义代入此表达式：\n$$\\kappa = \\frac{1}{\\left(\\frac{1}{k_B T}\\right) \\sigma^2}$$\n简化表达式得到最优刚度常数的最终结果：\n$$\\kappa = \\frac{k_B T}{\\sigma^2}$$\n该结果提供了约束强度 $\\kappa$、系统的热能 $k_B T$ 以及粗粒化空间中测量噪声的方差 $\\sigma^2$ 之间的直接物理联系。",
            "answer": "$$\\boxed{\\frac{k_B T}{\\sigma^2}}$$"
        },
        {
            "introduction": "成功的反向映射不仅需要生成一个合理的结构，更需要生成与粗粒化状态一致的完整原子构型系综，这要求在受限的概率分布上进行采样。本练习深入探讨了如何在受限流形上构建一个Metropolis-Hastings采样器，并强调了为确保采样器指向正确分布，坐标变换和雅可比行列式因子所起的关键作用。通过对一个简单的三原子分子进行求解，您将明晰在受限条件下进行采样所涉及的理论复杂性，并为实现更高级的反向映射算法奠定坚实的基础。",
            "id": "3735228",
            "problem": "给定一个在从粗粒化模型进行反向映射时产生的约束原子级目标分布。令 $x \\in \\mathbb{R}^{n}$ 表示原子坐标，$y \\in \\mathbb{R}^{m}$ 表示粗粒化变量。在固定粗粒化变量 $y$ 的条件下，$x$ 的目标分布为\n$$\np(x \\mid y) \\propto e^{-\\beta U_{\\mathrm{AA}}(x)} \\, \\delta\\!\\big(y - M(x)\\big),\n$$\n其中 $U_{\\mathrm{AA}}(x)$ 是原子势能，$\\beta$ 是逆热能 $1/(k_{\\mathrm{B}} T)$（$k_{\\mathrm{B}}$ 为玻尔兹曼常数，$T$ 为温度），$M:\\mathbb{R}^{n}\\to \\mathbb{R}^{m}$ 是粗粒化映射，$\\delta(\\cdot)$ 是狄拉克δ分布。\n\n你必须构建一个以内坐标为基础的 Metropolis-Hastings (MH) 采样器，其目标为 $p(x\\mid y)$，并从第一性原理推导其接受概率。使用以下基本原理：\n- 玻尔兹曼分布 $p(x) \\propto e^{-\\beta U(x)}$。\n- 狄拉克δ分布的定义以及将积分与映射 $M$ 的水平集关联起来的余面积公式。\n- 针对目标密度 $\\pi$ 和提议密度 $q$ 的 Metropolis-Hastings (MH) 接受准则 $\\alpha = \\min\\!\\left(1, \\frac{\\pi(x') q(x \\mid x')}{\\pi(x) q(x' \\mid x)}\\right)$。\n\n推导在内坐标 $q \\in \\mathbb{R}^{d}$ 中定义的提议的接受概率。这些提议通过一个图卡 $x = F(q,y)$ 映射到原子构型，该图卡强制执行约束 $M\\big(F(q,y)\\big)=y$。明确表述图卡的雅可比因子和粗粒化映射的雅可比矩阵所扮演的角色。你的推导必须从标准的 MH 接受准则开始，并利用余面积公式来表示流形 $\\{x : M(x)=y\\}$ 上的约束测度。\n\n然后，将问题具体化到以下具体且科学一致的反向映射场景，以实现一个确定性程序，用于计算指定提议移动的接受概率：\n\n- 系统：一个位于二维平面上的三原子分子 $\\mathrm{A}$-$\\mathrm{B}$-$\\mathrm{C}$。原子坐标 $x \\in \\mathbb{R}^{6}$ 的顺序为 $(x_{\\mathrm{A}}^{(1)}, x_{\\mathrm{A}}^{(2)}, x_{\\mathrm{B}}^{(1)}, x_{\\mathrm{B}}^{(2)}, x_{\\mathrm{C}}^{(1)}, x_{\\mathrm{C}}^{(2)})$。\n- 粗粒化映射：$M(x)$ 选取原子 $\\mathrm{A}$ 和 $\\mathrm{C}$ 的位置，即 $M(x) = \\big(x_{\\mathrm{A}}^{(1)}, x_{\\mathrm{A}}^{(2)}, x_{\\mathrm{C}}^{(1)}, x_{\\mathrm{C}}^{(2)}\\big)$。约束 $M(x)=y$ 固定了 $\\mathrm{A}$ 和 $\\mathrm{C}$，而使 $\\mathrm{B}$ 保持自由。\n- 内坐标：对原子 $\\mathrm{B}$ 使用相对于原子 $\\mathrm{A}$ 的极坐标 $q=(r,\\theta)$，其中 $r\\ge 0$ 且 $\\theta \\in \\mathbb{R}$（以弧度为单位）。图卡为 $x_{\\mathrm{A}}=y_{\\mathrm{A}}$，$x_{\\mathrm{C}}=y_{\\mathrm{C}}$，以及 $x_{\\mathrm{B}}=y_{\\mathrm{A}} + r\\big(\\cos\\theta, \\sin\\theta\\big)$，这确保了 $M\\big(F(q,y)\\big)=y$。\n- 势能：\n$$\nU_{\\mathrm{AA}}(x) = \\frac{k_{\\mathrm{bond}}}{2}\\left(\\|x_{\\mathrm{B}}-x_{\\mathrm{A}}\\| - r_{0}\\right)^{2} + \\frac{k_{\\mathrm{bond}}}{2}\\left(\\|x_{\\mathrm{C}}-x_{\\mathrm{B}}\\| - r_{0}\\right)^{2} + \\frac{k_{\\mathrm{angle}}}{2}\\left(\\angle \\mathrm{ABC} - \\theta_{0}\\right)^{2},\n$$\n其中距离单位为纳米 (nm)，角度单位为弧度，能量单位为千焦/摩尔 (kJ/mol)。此处，$\\angle \\mathrm{ABC}$ 是由从 $x$ 计算出的向量 $\\overrightarrow{\\mathrm{BA}}$ 和 $\\overrightarrow{\\mathrm{BC}}$ 在 $\\mathrm{B}$ 处形成的夹角；请使用标准的基于反余弦的定义，并通过将余弦函数的参数裁剪到区间 $[-1,1]$ 来确保数值鲁棒性。\n- 常数和单位：设 $k_{\\mathrm{B}} = 8.314462618\\times 10^{-3}$ kJ/(mol·K)，$T=300$ K (因此 $\\beta = 1/(k_{\\mathrm{B}}T)$)，$k_{\\mathrm{bond}} = 1000$ kJ/(mol·nm$^{2}$)，$k_{\\mathrm{angle}} = 100$ kJ/(mol·rad$^{2}$)，$r_{0}=0.6$ nm，以及 $\\theta_{0} = \\pi$ 弧度。\n- 粗粒化变量：固定 $y_{\\mathrm{A}}=(0.0\\,\\mathrm{nm}, 0.0\\,\\mathrm{nm})$ 和 $y_{\\mathrm{C}}=(1.0\\,\\mathrm{nm}, 0.0\\,\\mathrm{nm})$。\n\n假设内坐标 $q=(r,\\theta)$ 中的提议核是对称的，即 $q(q' \\mid q)=q(q \\mid q')$，这使得 MH 接受概率可以简化为 $q$ 空间中目标密度的比率。\n\n任务1（推导）：从 MH 接受准则出发，利用余面积公式，推导在上述图卡下从 $q$ 移动到 $q'$ 的接受概率 $\\alpha$。用 $\\Delta U = U_{\\mathrm{AA}}(F(q',y)) - U_{\\mathrm{AA}}(F(q,y))$、逆热能 $\\beta$ 以及由图卡和粗粒化约束引入的任何雅可比因子来明确表示 $\\alpha$。\n\n任务2（实现）：实现一个程序，计算以下测试套件中每次提议移动的接受概率。所有角度单位均为弧度。距离单位为纳米。能量单位为千焦/摩尔。接受概率是无量纲的，必须以浮点数形式输出。\n\n测试套件（每个测试用例是一对 $(q,q')$）：\n1. $(q, q') = \\big((0.6, 0.3), (0.62, 0.35)\\big)$\n2. $(q, q') = \\big((1.0\\times 10^{-6}, 0.0), (2.0\\times 10^{-6}, 0.1)\\big)$\n3. $(q, q') = \\big((0.6, 3.0), (0.6, -3.0)\\big)$\n4. $(q, q') = \\big((1.2, 0.0), (0.2, \\pi)\\big)$\n\n最终输出格式：你的程序应生成一行输出，其中包含四个测试用例的接受概率，形式为用方括号括起来的逗号分隔列表，并按上述顺序排列（例如，“[a,b,c,d]”）。不允许有任何其他输出。",
            "solution": "该问题是有效的，因为它具有科学依据、自洽且定义明确。它提出了计算统计物理学中一个关于在约束流形上采样问题的标准（尽管不简单）范例，该问题是多尺度建模中反向映射方法的核心。\n\n根据要求，解决方案分为两部分：首先，从第一性原理推导 Metropolis-Hastings 接受概率；其次，实现一个程序来计算特定情况下的此概率。\n\n### 第1部分：接受概率的推导\n\n目标是推导 Metropolis-Hastings (MH) 接受概率 $\\alpha$，该概率对应于从由内坐标 $q$ 定义的状态移动到新状态 $q'$，并以约束的原子级分布 $p(x \\mid y)$ 为目标。\n\n**1. 约束目标分布**\n\n在给定固定粗粒化变量 $y \\in \\mathbb{R}^{m}$ 的情况下，原子坐标 $x \\in \\mathbb{R}^{n}$ 的目标概率分布为\n$$\np(x \\mid y) \\propto e^{-\\beta U_{\\mathrm{AA}}(x)} \\, \\delta\\!\\big(y - M(x)\\big)\n$$\n其中 $U_{\\mathrm{AA}}(x)$ 是原子势能，$\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆温度，$M: \\mathbb{R}^n \\to \\mathbb{R}^m$ 是粗粒化映射，$\\delta(\\cdot)$ 是狄拉克δ分布。该分布定义了一个集中在流形 $\\mathcal{S}_y = \\{x \\in \\mathbb{R}^n : M(x) = y \\}$ 上的概率测度。\n\n为了处理这个分布，我们将其表示为流形 $\\mathcal{S}_y$ 上的一个密度。余面积公式提供了必要的工具，可将 $\\mathbb{R}^n$ 中的积分与 $M$ 的水平集上的积分联系起来。对于任意可积函数 $g(x)$，该公式为：\n$$\n\\int_{\\mathbb{R}^n} g(x) \\, \\delta(y - M(x)) \\, dx = \\int_{\\mathcal{S}_y} \\frac{g(x)}{\\sqrt{\\det(J_M(x) J_M(x)^T)}} \\, d\\sigma_y(x)\n$$\n此处，$J_M(x)$ 是映射 $M$ 的 $m \\times n$ 雅可比矩阵，其元素为 $(J_M)_{ij} = \\partial M_i / \\partial x_j$。项 $\\sqrt{\\det(J_M(x) J_M(x)^T)}$ 是考虑了水平集局部密度的几何校正因子。$d\\sigma_y(x)$ 是流形 $\\mathcal{S}_y$ 上的表面积元。\n\n将此应用于我们的概率分布，相对于表面测度 $d\\sigma_y(x)$，流形 $\\mathcal{S}_y$ 上正确归一化的目标密度为：\n$$\n\\pi_{\\mathcal{S}_y}(x) \\propto \\frac{e^{-\\beta U_{\\mathrm{AA}}(x)}}{\\sqrt{\\det(J_M(x) J_M(x)^T)}}\n$$\n\n**2. 变量变换到内坐标**\n\n问题指定采样在内坐标空间 $q \\in \\mathbb{R}^d$ 中进行，其中 $d=n-m$。图卡 $x = F(q, y)$ 提供了流形 $\\mathcal{S}_y$ 的一个参数化。为了找到 $q$ 空间中的目标密度，我们必须对测度进行变量变换。根据以下关系，表面积元 $d\\sigma_y(x)$ 变换为体积元 $dq$：\n$$\nd\\sigma_y(x) = \\sqrt{\\det(J_F(q, y)^T J_F(q, y))} \\, dq\n$$\n其中 $J_F(q, y)$ 是图卡 $F$ 相对于内坐标 $q$ 的 $n \\times d$ 雅可比矩阵，即 $(J_F)_{ij} = \\partial F_i / \\partial q_j$。\n\n在 $q$ 周围的无穷小体积 $dq$ 中找到系统的概率与 $\\tilde{\\pi}(q) dq$ 成正比，其中 $\\tilde{\\pi}(q)$ 是 $q$ 空间中的目标密度。这个概率必须等于流形上相应小块上的概率：\n$$\n\\tilde{\\pi}(q) dq \\propto \\pi_{\\mathcal{S}_y}(F(q, y)) \\, d\\sigma_y(F(q, y))\n$$\n代入 $\\pi_{\\mathcal{S}_y}$ 和 $d\\sigma_y$ 的表达式，我们得到：\n$$\n\\tilde{\\pi}(q)dq \\propto \\frac{e^{-\\beta U_{\\mathrm{AA}}(F(q, y))}}{\\sqrt{\\det(J_M(F(q, y)) J_M(F(q, y))^T)}} \\sqrt{\\det(J_F(q, y)^T J_F(q, y))} \\, dq\n$$\n因此，内坐标空间中的目标密度为：\n$$\n\\tilde{\\pi}(q) \\propto e^{-\\beta U_{\\mathrm{AA}}(F(q, y))} \\frac{\\sqrt{\\det(J_F(q, y)^T J_F(q, y))}}{\\sqrt{\\det(J_M(F(q, y)) J_M(F(q, y))^T)}}\n$$\n\n**3. Metropolis-Hastings 接受概率**\n\n由提议分布 $p(q' \\mid q)$ 生成的从 $q$ 到 $q'$ 的移动的 MH 接受概率由下式给出：\n$$\n\\alpha(q \\to q') = \\min\\left(1, \\frac{\\tilde{\\pi}(q') p(q \\mid q')}{\\tilde{\\pi}(q) p(q' \\mid q)}\\right)\n$$\n问题指定了一个对称提议，$p(q' \\mid q) = p(q \\mid q')$，这将准则简化为目标密度的比率：\n$$\n\\alpha(q \\to q') = \\min\\left(1, \\frac{\\tilde{\\pi}(q')}{\\tilde{\\pi}(q)}\\right)\n$$\n代入 $\\tilde{\\pi}(q)$ 的表达式，我们得到接受概率的通用公式：\n$$\n\\alpha(q \\to q') = \\min\\left(1, e^{-\\beta \\Delta U} \\frac{\\sqrt{\\det(J_F(q')^T J_F(q'))}}{\\sqrt{\\det(J_F(q)^T J_F(q))}} \\frac{\\sqrt{\\det(J_M(x) J_M(x)^T)}}{\\sqrt{\\det(J_M(x') J_M(x')^T)}}\\right)\n$$\n其中 $\\Delta U = U_{\\mathrm{AA}}(x') - U_{\\mathrm{AA}}(x)$，$x = F(q, y)$ 且 $x' = F(q', y)$。这个表达式明确地显示了玻尔兹曼因子、内坐标图卡 ($J_F$) 的雅可比矩阵以及粗粒化映射 ($J_M$) 的雅可比矩阵所起的作用。\n\n**4. 具体化到三原子系统**\n\n我们现在将此通用公式应用于所提供的具体系统。\n- **坐标：** 原子级 $x \\in \\mathbb{R}^6$，粗粒化 $y \\in \\mathbb{R}^4$，内坐标 $q \\in \\mathbb{R}^2$。\n- **图卡：** $x = F(q,y)$，其中 $q=(r,\\theta)$ 映射为 $x_A=y_A, x_C=y_C, x_B=y_A+r(\\cos\\theta, \\sin\\theta)$。\n- **映射：** $M(x) = (x_A, x_C)$。\n\n**图卡 $F$ 的雅可比矩阵：** 该图卡将 $q=(r,\\theta)$ 映射到原子坐标。雅可比矩阵 $J_F$ 是 $x$ 对 $r$ 和 $\\theta$ 的偏导数构成的 $6 \\times 2$ 矩阵。唯一的非零分量是原子 B 的坐标 ($x_B^{(1)}, x_B^{(2)}$)。\n令 $x_B = (y_A^{(1)} + r\\cos\\theta, y_A^{(2)} + r\\sin\\theta)$。则\n$\\frac{\\partial x_B}{\\partial r} = (\\cos\\theta, \\sin\\theta)$ 且 $\\frac{\\partial x_B}{\\partial \\theta} = (-r\\sin\\theta, r\\cos\\theta)$。\n矩阵 $J_F^T J_F$ 于是为：\n$$\nJ_F(q)^T J_F(q) =\n\\begin{pmatrix}\n\\cos^2\\theta + \\sin^2\\theta  -r\\cos\\theta\\sin\\theta + r\\sin\\theta\\cos\\theta \\\\\n-r\\cos\\theta\\sin\\theta + r\\sin\\theta\\cos\\theta  r^2\\sin^2\\theta + r^2\\cos^2\\theta\n\\end{pmatrix} =\n\\begin{pmatrix}\n1  0 \\\\\n0  r^2\n\\end{pmatrix}\n$$\n其行列式为 $\\det(J_F(q)^T J_F(q)) = r^2$。因此，来自图卡的雅可比因子是 $\\sqrt{r^2} = |r| = r$，因为半径 $r \\ge 0$。\n\n**粗粒化映射 $M$ 的雅可比矩阵：** 映射 $M(x) = (x_A^{(1)}, x_A^{(2)}, x_C^{(1)}, x_C^{(2)})$ 是一个线性投影。其 $4 \\times 6$ 的雅可比矩阵 $J_M$ 是恒定的：\n$$\nJ_M = \\frac{\\partial(x_A, x_C)}{\\partial(x_A, x_B, x_C)} = \\begin{pmatrix} I_2  0_2  0_2 \\\\ 0_2  0_2  I_2 \\end{pmatrix}\n$$\n（以分块矩阵形式表示，其中 $I_2$ 是 $2 \\times 2$ 单位矩阵，$0_2$ 是 $2 \\times 2$ 零矩阵）。\n乘积 $J_M J_M^T$ 是 $4 \\times 4$ 的单位矩阵：$J_M J_M^T = I_4$。其行列式为 $\\det(J_M J_M^T) = 1$。对于所有构型 $x$，该项都是常数且等于 $1$。\n\n**最终接受概率：** 将这些雅可比行列式代入 $\\alpha$ 的通用公式，来自 $J_M$ 的因子变为 $1$，来自 $J_F$ 的因子变为 $\\sqrt{(r')^2 / r^2} = r'/r$。接受概率简化为：\n$$\n\\alpha(q \\to q') = \\min\\left(1, \\frac{r'}{r} e^{-\\beta (U_{\\mathrm{AA}}(x') - U_{\\mathrm{AA}}(x))}\\right)\n$$\n其中 $q=(r,\\theta)$ 且 $q'=(r',\\theta')$。这是用于实现的最终表达式。势能 $U_{\\mathrm{AA}}$ 是使用通过图卡 $F$ 从内坐标 $q=(r,\\theta)$ 推导出的笛卡尔坐标 $x$ 计算的。\n具体来说，$x_A = (0,0)$，$x_C = (1,0)$，以及 $x_B = (r\\cos\\theta, r\\sin\\theta)$。\n能量项为：\n- $\\|x_B - x_A\\| = r$\n- $\\|x_C - x_B\\| = \\sqrt{(1-r\\cos\\theta)^2 + (-r\\sin\\theta)^2} = \\sqrt{1 - 2r\\cos\\theta + r^2}$\n- $\\angle \\mathrm{ABC} = \\arccos\\left(\\frac{(x_A-x_B)\\cdot(x_C-x_B)}{\\|x_A-x_B\\|\\|x_C-x_B\\|}\\right) = \\arccos\\left(\\frac{r-\\cos\\theta}{\\sqrt{1-2r\\cos\\theta+r^2}}\\right)$\n\n以下程序使用这些表达式来计算数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the backmapping acceptance probability problem.\n    This involves deriving and implementing the acceptance probability for a \n    Metropolis-Hastings sampler operating in internal coordinates.\n    \"\"\"\n\n    # --- Constants and System Parameters ---\n    K_B = 8.314462618e-3  # Boltzmann constant in kJ/(mol·K)\n    T = 300.0             # Temperature in K\n    BETA = 1.0 / (K_B * T)  # Inverse thermal energy in mol/kJ\n\n    K_BOND = 1000.0  # Bond force constant in kJ/(mol·nm^2)\n    K_ANGLE = 100.0  # Angle force constant in kJ/(mol·rad^2)\n    R_0 = 0.6        # Equilibrium bond length in nm\n    THETA_0 = np.pi  # Equilibrium angle in radians\n\n    # Fixed coarse-grained variables (positions of atoms A and C)\n    Y_A = np.array([0.0, 0.0])  # Position of atom A in nm\n    Y_C = np.array([1.0, 0.0])  # Position of atom C in nm\n\n    def calculate_potential_energy(q):\n        \"\"\"\n        Calculates the atomistic potential energy U_AA(x) for a given \n        internal coordinate configuration q = (r, theta).\n        \n        Args:\n            q (tuple): A tuple (r, theta) representing internal coordinates.\n                       r is the distance in nm, theta is the angle in radians.\n        \n        Returns:\n            float: The total potential energy in kJ/mol.\n        \"\"\"\n        r, theta = q\n\n        # Chart: Map internal coordinates q to Cartesian coordinates x\n        # x_A and x_C are fixed by y_A and y_C\n        x_A = Y_A\n        x_C = Y_C\n        x_B = Y_A + np.array([r * np.cos(theta), r * np.sin(theta)])\n\n        # --- Calculate Energy Terms ---\n        \n        # 1. Bond Energy (A-B)\n        # The distance ||x_B - x_A|| is simply r.\n        energy_bond_AB = 0.5 * K_BOND * (r - R_0)**2\n\n        # 2. Bond Energy (B-C)\n        vec_BC = x_C - x_B\n        dist_BC = np.linalg.norm(vec_BC)\n        energy_bond_BC = 0.5 * K_BOND * (dist_BC - R_0)**2\n\n        # 3. Angle Energy (A-B-C)\n        # The angle is formed by vectors BA and BC.\n        # Check for the edge case r=0, where the angle is ill-defined.\n        # In this scenario, the energy contribution would be infinite.\n        if r  1e-9: # A practical threshold for r being zero\n            return np.inf\n\n        vec_BA = x_A - x_B\n        \n        # Cosine of the angle using the dot product formula\n        dot_product = np.dot(vec_BA, vec_BC)\n        norm_BA = r # ||x_A - x_B|| is r\n        \n        # Argument for arccos must be clipped to [-1, 1] for numerical stability\n        cos_angle_arg = dot_product / (norm_BA * dist_BC)\n        cos_angle_arg_clipped = np.clip(cos_angle_arg, -1.0, 1.0)\n        \n        angle_ABC = np.arccos(cos_angle_arg_clipped)\n        \n        energy_angle = 0.5 * K_ANGLE * (angle_ABC - THETA_0)**2\n        \n        total_energy = energy_bond_AB + energy_bond_BC + energy_angle\n        return total_energy\n\n    def calculate_acceptance_probability(q_current, q_proposed):\n        \"\"\"\n        Calculates the Metropolis-Hastings acceptance probability for a move\n        from q_current to q_proposed.\n        \n        The formula is alpha = min(1, (r'/r) * exp(-beta * delta_U)).\n        \n        Args:\n            q_current (tuple): The current internal coordinates (r, theta).\n            q_proposed (tuple): The proposed internal coordinates (r', theta').\n            \n        Returns:\n            float: The acceptance probability (unitless).\n        \"\"\"\n        r_current, _ = q_current\n        r_proposed, _ = q_proposed\n\n        # Handle edge case where current r is zero (though not in test cases)\n        if r_current  1e-9:\n             # Move from r=0 has infinite Jacobian ratio, accept if delta_U is not +inf\n             U_proposed = calculate_potential_energy(q_proposed)\n             return 1.0 if U_proposed != np.inf else 0.0\n\n        U_current = calculate_potential_energy(q_current)\n        U_proposed = calculate_potential_energy(q_proposed)\n\n        delta_U = U_proposed - U_current\n        \n        # Jacobian factor from the change of coordinates to polar\n        jacobian_ratio = r_proposed / r_current\n        \n        # Acceptance ratio\n        ratio = jacobian_ratio * np.exp(-BETA * delta_U)\n        \n        return min(1.0, ratio)\n\n    # Test suite provided in the problem statement\n    test_cases = [\n        ((0.6, 0.3), (0.62, 0.35)),\n        ((1.0e-6, 0.0), (2.0e-6, 0.1)),\n        ((0.6, 3.0), (0.6, -3.0)),\n        ((1.2, 0.0), (0.2, np.pi)),\n    ]\n\n    results = []\n    for q_curr, q_prop in test_cases:\n        alpha = calculate_acceptance_probability(q_curr, q_prop)\n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}