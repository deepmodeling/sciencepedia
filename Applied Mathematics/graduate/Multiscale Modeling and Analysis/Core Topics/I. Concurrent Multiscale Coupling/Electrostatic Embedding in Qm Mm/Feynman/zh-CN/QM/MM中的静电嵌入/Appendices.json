{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在揭示静电嵌入的核心机制。你将直接计算由经典分子力学（MM）点电荷产生的电场如何极化量子力学（QM）区域，从而诱导出偶极矩。通过比较不同MM电荷模型所产生的结果，你将亲身体会到MM环境的选择对QM区域电子性质预测的重要性 ()。",
            "id": "3753075",
            "problem": "考虑一个量子力学/分子力学 (QM/MM) 中的静电嵌入场景，其中一个量子力学溶质被嵌入到由固定的经典分子力学点电荷产生的静电场中。假设溶质位于原点，其对外部均匀电场的电子响应在一阶近似下由各向同性分子极化率 $\\alpha$ 描述，单位为原子单位（玻尔半径的立方）。分子力学 (MM) 环境由三个点电荷组成，它们位于位置 $\\mathbf{r}_1 = (3\\,a_0, 0, 0)$、$\\mathbf{r}_2 = (0, 4\\,a_0, 0)$ 和 $\\mathbf{r}_3 = (0, 0, 5\\,a_0)$，其中 $a_0$ 是玻尔半径。给出了两种不同的 MM 电荷模型：\n- 真空拟合电荷：$q_1^{\\mathrm{vac}} = +0.40$, $q_2^{\\mathrm{vac}} = -0.25$, $q_3^{\\mathrm{vac}} = -0.15$。\n- 环境拟合电荷：$q_1^{\\mathrm{env}} = +0.45$, $q_2^{\\mathrm{env}} = -0.30$, $q_3^{\\mathrm{env}} = -0.15$。\n\n假设静电学计算采用原子单位（因此 $4\\pi\\epsilon_0 = 1$ 且基本电荷量为 $1$），并取溶质的各向同性极化率为 $\\alpha = 10\\,a_0^3$。将 MM 点电荷视为作用于量子溶质的外部场的固定源，在线性响应范围内，通过计算两组电荷在原点产生的外部场之差，并将其通过溶质的线性响应进行传播，来估计环境拟合嵌入和真空拟合嵌入之间的嵌入式量子力学偶极矩差向量 $\\Delta \\boldsymbol{\\mu}$。\n\n计算此偶极矩差的欧几里得范数 $|\\Delta \\boldsymbol{\\mu}|$，并以德拜 (Debye) 为单位表示您的最终答案。使用一个原子单位的偶极矩等于 $2.541746$ 德拜的转换关系。将您的最终答案四舍五入至四位有效数字。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于静电相互作用和线性响应理论在QM/MM建模中的应用原理。该问题是适定的，为获得唯一解提供了所有必要的数据和条件，没有任何内部矛盾或歧义。\n\n核心任务是计算一个量子力学 (QM) 溶质在由经典分子力学 (MM) 点电荷提供的两种不同静电环境下，其诱导偶极矩的差异。根据线性响应理论，诱导偶极矩 $\\boldsymbol{\\mu}_{\\mathrm{ind}}$ 通过分子极化率张量与外部电场 $\\mathbf{E}$ 相关。对于各向同性极化率 $\\alpha$，此关系为标量关系：\n$$ \\boldsymbol{\\mu}_{\\mathrm{ind}} = \\alpha \\mathbf{E} $$\n所有计算都将在原子单位下进行，其中基本电荷 $e$、约化普朗克常数 $\\hbar$、电子质量 $m_e$ 以及库仑常数 $k_e = \\frac{1}{4\\pi\\epsilon_0}$ 均设为 $1$。长度单位为玻尔半径 $a_0$。\n\n问题要求计算由环境拟合电荷诱导的偶极矩 $\\boldsymbol{\\mu}_{\\mathrm{env}}$ 与由真空拟合电荷诱导的偶极矩 $\\boldsymbol{\\mu}_{\\mathrm{vac}}$ 之间的差向量 $\\Delta \\boldsymbol{\\mu}$。\n$$ \\Delta \\boldsymbol{\\mu} = \\boldsymbol{\\mu}_{\\mathrm{env}} - \\boldsymbol{\\mu}_{\\mathrm{vac}} $$\n代入线性响应公式：\n$$ \\Delta \\boldsymbol{\\mu} = \\alpha \\mathbf{E}_{\\mathrm{env}} - \\alpha \\mathbf{E}_{\\mathrm{vac}} = \\alpha (\\mathbf{E}_{\\mathrm{env}} - \\mathbf{E}_{\\mathrm{vac}}) = \\alpha \\Delta \\mathbf{E} $$\n其中 $\\Delta \\mathbf{E}$ 是两种电荷分布在原点产生的电场之差。\n\n根据叠加原理，位于位置 $\\mathbf{r}_i$ 的一组点电荷 $q_i$ 在原点 ($\\mathbf{r} = \\mathbf{0}$) 产生的电场 $\\mathbf{E}$ 为：\n$$ \\mathbf{E} = \\sum_{i} \\frac{q_i (\\mathbf{0} - \\mathbf{r}_i)}{|\\mathbf{0} - \\mathbf{r}_i|^3} = - \\sum_{i} \\frac{q_i \\mathbf{r}_i}{|\\mathbf{r}_i|^3} $$\n因此，场差 $\\Delta \\mathbf{E}$ 为：\n$$ \\Delta \\mathbf{E} = \\mathbf{E}_{\\mathrm{env}} - \\mathbf{E}_{\\mathrm{vac}} = \\left( - \\sum_{i} \\frac{q_i^{\\mathrm{env}} \\mathbf{r}_i}{|\\mathbf{r}_i|^3} \\right) - \\left( - \\sum_{i} \\frac{q_i^{\\mathrm{vac}} \\mathbf{r}_i}{|\\mathbf{r}_i|^3} \\right) = - \\sum_{i} \\frac{(q_i^{\\mathrm{env}} - q_i^{\\mathrm{vac}})\\mathbf{r}_i}{|\\mathbf{r}_i|^3} $$\n令 $\\Delta q_i = q_i^{\\mathrm{env}} - q_i^{\\mathrm{vac}}$。场差的表达式变为：\n$$ \\Delta \\mathbf{E} = - \\sum_{i} \\frac{\\Delta q_i \\mathbf{r}_i}{|\\mathbf{r}_i|^3} $$\n首先，我们计算电荷差 $\\Delta q_i$：\n$$ \\Delta q_1 = q_1^{\\mathrm{env}} - q_1^{\\mathrm{vac}} = 0.45 - 0.40 = 0.05 $$\n$$ \\Delta q_2 = q_2^{\\mathrm{env}} - q_2^{\\mathrm{vac}} = -0.30 - (-0.25) = -0.05 $$\n$$ \\Delta q_3 = q_3^{\\mathrm{env}} - q_3^{\\mathrm{vac}} = -0.15 - (-0.15) = 0 $$\n电荷位置以 $a_0$ 为单位给出，在原子单位制中长度为 $1$。\n$$ \\mathbf{r}_1 = (3, 0, 0) \\implies |\\mathbf{r}_1| = 3, |\\mathbf{r}_1|^3 = 27 $$\n$$ \\mathbf{r}_2 = (0, 4, 0) \\implies |\\mathbf{r}_2| = 4, |\\mathbf{r}_2|^3 = 64 $$\n$$ \\mathbf{r}_3 = (0, 0, 5) \\implies |\\mathbf{r}_3| = 5, |\\mathbf{r}_3|^3 = 125 $$\n现在，我们计算 $\\Delta \\mathbf{E}$ 的分量：\n$$ \\Delta \\mathbf{E} = - \\left( \\frac{\\Delta q_1 \\mathbf{r}_1}{|\\mathbf{r}_1|^3} + \\frac{\\Delta q_2 \\mathbf{r}_2}{|\\mathbf{r}_2|^3} + \\frac{\\Delta q_3 \\mathbf{r}_3}{|\\mathbf{r}_3|^3} \\right) $$\n$\\Delta q_3$ 对应的项为零。\n$$ \\Delta \\mathbf{E} = - \\left( \\frac{0.05 \\cdot (3, 0, 0)}{27} + \\frac{-0.05 \\cdot (0, 4, 0)}{64} \\right) $$\n$$ \\Delta \\mathbf{E} = - \\left( \\left(\\frac{0.15}{27}, 0, 0\\right) + \\left(0, \\frac{-0.20}{64}, 0\\right) \\right) = - \\left( \\frac{1}{180}, -\\frac{1}{320}, 0 \\right) $$\n$$ \\Delta \\mathbf{E} = \\left(-\\frac{1}{180}, \\frac{1}{320}, 0\\right) $$\n该电场的单位是原子单位 ($E_h / (e a_0)$)。给定的极化率为 $\\alpha = 10\\,a_0^3$，在原子单位中即 $\\alpha = 10$。\n偶极矩差向量为：\n$$ \\Delta \\boldsymbol{\\mu} = \\alpha \\Delta \\mathbf{E} = 10 \\cdot \\left(-\\frac{1}{180}, \\frac{1}{320}, 0\\right) = \\left(-\\frac{10}{180}, \\frac{10}{320}, 0\\right) = \\left(-\\frac{1}{18}, \\frac{1}{32}, 0\\right) $$\n这是以原子单位表示的偶极矩 ($e \\cdot a_0$)。问题要求计算该向量的欧几里得范数 $|\\Delta \\boldsymbol{\\mu}|$：\n$$ |\\Delta \\boldsymbol{\\mu}| = \\sqrt{ \\left(-\\frac{1}{18}\\right)^2 + \\left(\\frac{1}{32}\\right)^2 + 0^2 } = \\sqrt{ \\frac{1}{324} + \\frac{1}{1024} } $$\n$$ |\\Delta \\boldsymbol{\\mu}| = \\sqrt{ \\frac{1024 + 324}{324 \\times 1024} } = \\sqrt{ \\frac{1348}{331776} } \\approx \\sqrt{0.004062982} \\approx 0.06374152 \\text{ a.u.} $$\n最后，我们使用给定的转换因子将此值转换为德拜 (Debye)：$1$ 原子单位 $= 2.541746$ 德拜。\n$$ |\\Delta \\boldsymbol{\\mu}|_{\\mathrm{Debye}} = |\\Delta \\boldsymbol{\\mu}|_{\\mathrm{a.u.}} \\times 2.541746 $$\n$$ |\\Delta \\boldsymbol{\\mu}|_{\\mathrm{Debye}} \\approx 0.06374152 \\times 2.541746 \\approx 0.162013 $$\n将结果四舍五入到四位有效数字，得到 $0.1620$。",
            "answer": "$$\n\\boxed{0.1620}\n$$"
        },
        {
            "introduction": "在理解了静电相互作用能之后，下一步自然是计算驱动系统演化的力。本练习将指导你完成模拟软件开发中的一个关键步骤：力的验证 ()。通过推导MM电荷所受静电力的解析表达式，并将其与基于能量的有限差分法得到的数值力进行比较，你将掌握验证代码实现正确性的核心技能。",
            "id": "3753098",
            "problem": "考虑一个原子单位制下的量子力学/分子力学 (QM/MM) 静电嵌入场景，其中一个最小的量子力学 (QM) 子系统由两个固定的原子核组成，它们位于位置 $R_A \\in \\mathbb{R}^3$ 和 $R_B \\in \\mathbb{R}^3$ 处，带有正电荷 $Z_A$ 和 $Z_B$。QM 电子密度被近似为两个独立的 s-型高斯电荷分布的归一化球对称和，这两个高斯分布以 $R_A$ 和 $R_B$ 为中心，具有共同的指数 $\\alpha > 0$ 和权重 $w_A, w_B$，满足 $w_A + w_B = 1$ 和 $w_A, w_B \\ge 0$。一个分子力学 (MM) 单点电荷 $q$ 位于位置 $R_q \\in \\mathbb{R}^3$ 处。所有物理量均以原子单位表示：距离以玻尔 (Bohr) 为单位，力以哈特里/玻尔 (Hartree per Bohr) 为单位。\n\n总 QM/MM 静电相互作用能 $E_{\\mathrm{int}}(R_q)$ 包括 MM 电荷与 QM 原子核以及 QM 电子密度之间的库仑相互作用。对于一个以 $R_X$ 为中心、指数为 $\\alpha$ 的球对称归一化高斯电子密度，在距离 $r = \\lVert R_q - R_X \\rVert$ 处的静电势是一个经过充分检验的事实：\n$$\nV_{\\mathrm{G}}(r) = \\frac{\\operatorname{erf}(\\beta r)}{r}, \\quad \\beta = \\sqrt{\\alpha},\n$$\n其中 $\\operatorname{erf}$ 是高斯误差函数。使用库仑定律和上述电势，能量为\n$$\nE_{\\mathrm{int}}(R_q) = q\\left(\\frac{Z_A}{\\lVert R_q - R_A \\rVert} + \\frac{Z_B}{\\lVert R_q - R_B \\rVert} - w_A V_{\\mathrm{G}}(\\lVert R_q - R_A \\rVert) - w_B V_{\\mathrm{G}}(\\lVert R_q - R_B \\rVert)\\right).\n$$\n\n您的任务是通过两种方法计算 MM 电荷 $q$ 上的力，并评估它们之间的差异：\n1. 沿每个笛卡尔坐标轴，使用步长 $h$，通过能量的中心有限差分计算数值力 $F_{\\mathrm{num}}(R_q)$：\n$$\nF_{\\mathrm{num},i}(R_q) = -\\frac{E_{\\mathrm{int}}(R_q + h\\, \\hat{e}_i) - E_{\\mathrm{int}}(R_q - h\\, \\hat{e}_i)}{2h}, \\quad i \\in \\{x,y,z\\},\n$$\n其中 $\\hat{e}_i$ 表示沿 $i$ 轴的单位向量。\n2. 使用向量微积分和链式法则，对原子核库仑项和高斯势相对于 $R_q$ 进行微分，从而推导并实现解析力 $F_{\\mathrm{ana}}(R_q) = -\\nabla_{R_q} E_{\\mathrm{int}}(R_q)$。\n\n最后，计算两种力之间误差向量的欧几里得范数：\n$$\n\\Delta = \\lVert F_{\\mathrm{num}}(R_q) - F_{\\mathrm{ana}}(R_q) \\rVert,\n$$\n并以 哈特里/玻尔 (Hartree per Bohr) 为单位报告 $\\Delta$。\n\n使用以下参数集测试套件，其设计旨在覆盖典型、远场、近场和对称情况。在所有情况下，距离以玻尔 (Bohr) 为单位，力以哈特里/玻尔 (Hartree per Bohr) 为单位，而 $h$ 也以玻尔 (Bohr) 为单位。\n\n- 测试用例 1 (靠近两个原子核的一般位置):\n  - $R_A = (-0.7, 0.0, 0.0)$\n  - $R_B = (0.7, 0.0, 0.0)$\n  - $Z_A = 1$, $Z_B = 1$\n  - $q = 0.5$\n  - $\\alpha = 0.5$\n  - $w_A = 0.6$, $w_B = 0.4$\n  - $R_q = (0.3, 0.1, -0.2)$\n  - $h = 10^{-4}$\n\n- 测试用例 2 (远离两个原子核的远场):\n  - $R_A = (-0.7, 0.0, 0.0)$\n  - $R_B = (0.7, 0.0, 0.0)$\n  - $Z_A = 1$, $Z_B = 1$\n  - $q = 0.5$\n  - $\\alpha = 0.5$\n  - $w_A = 0.6$, $w_B = 0.4$\n  - $R_q = (10.0, -9.0, 5.0)$\n  - $h = 10^{-4}$\n\n- 测试用例 3 (靠近一个原子核的近场):\n  - $R_A = (-0.7, 0.0, 0.0)$\n  - $R_B = (0.7, 0.0, 0.0)$\n  - $Z_A = 1$, $Z_B = 1$\n  - $q = 0.5$\n  - $\\alpha = 0.5$\n  - $w_A = 0.6$, $w_B = 0.4$\n  - $R_q = (-0.65, 0.0, 0.0)$\n  - $h = 10^{-5}$\n\n- 测试用例 4 (位于中点的对称情况，具有相等的电子权重和负的 MM 电荷):\n  - $R_A = (-1.2, 0.0, 0.0)$\n  - $R_B = (1.2, 0.0, 0.0)$\n  - $Z_A = 1$, $Z_B = 1$\n  - $q = -1.0$\n  - $\\alpha = 1.0$\n  - $w_A = 0.5$, $w_B = 0.5$\n  - $R_q = (0.0, 0.0, 0.0)$\n  - $h = 10^{-4}$\n\n您的程序应为每个测试用例计算 $\\Delta$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。将每个 $\\Delta$ 值以 哈特里/玻尔 (Hartree per Bohr) 为单位表示，并四舍五入到八位小数。例如，输出格式必须是\n$$\n[\\delta_1,\\delta_2,\\delta_3,\\delta_4],\n$$\n其中每个 $\\delta_k$ 是一个小数点后有八位数字的十进制浮点数。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n该问题为量子力学/分子力学 (QM/MM) 静电嵌入模型提供了以下数据和定义：\n\n**QM 子系统：**\n-   两个固定原子核，位于位置 $\\mathbf{R}_A, \\mathbf{R}_B \\in \\mathbb{R}^3$。\n-   正原子核电荷 $Z_A, Z_B$。\n-   一个电子密度，建模为以 $\\mathbf{R}_A$ 和 $\\mathbf{R}_B$ 为中心的两个归一化、球对称的 s 型高斯电荷分布之和。\n-   共同的高斯指数 $\\alpha > 0$。\n-   高斯分布的权重 $w_A, w_B$，满足 $w_A + w_B = 1$ 和 $w_A, w_B \\ge 0$。\n\n**MM 子系统：**\n-   一个点电荷 $q$，位于位置 $\\mathbf{R}_q \\in \\mathbb{R}^3$。\n\n**物理与方程：**\n-   所有物理量均以原子单位表示（距离单位为玻尔，力单位为哈特里/玻尔）。\n-   一个指数为 $\\alpha$ 的归一化球对称高斯分布在其中心距离 $r$ 处的静电势：\n    $$V_{\\mathrm{G}}(r) = \\frac{\\operatorname{erf}(\\beta r)}{r}, \\quad \\beta = \\sqrt{\\alpha}$$\n-   总 QM/MM 静电相互作用能：\n    $$E_{\\mathrm{int}}(\\mathbf{R}_q) = q\\left(\\frac{Z_A}{\\lVert \\mathbf{R}_q - \\mathbf{R}_A \\rVert} + \\frac{Z_B}{\\lVert \\mathbf{R}_q - \\mathbf{R}_B \\rVert} - w_A V_{\\mathrm{G}}(\\lVert \\mathbf{R}_q - \\mathbf{R}_A \\rVert) - w_B V_{\\mathrm{G}}(\\lVert \\mathbf{R}_q - \\mathbf{R}_B \\rVert)\\right)$$\n-   MM 电荷上的数值力（中心有限差分）：\n    $$\\mathbf{F}_{\\mathrm{num},i}(\\mathbf{R}_q) = -\\frac{E_{\\mathrm{int}}(\\mathbf{R}_q + h\\, \\hat{\\mathbf{e}}_i) - E_{\\mathrm{int}}(\\mathbf{R}_q - h\\, \\hat{\\mathbf{e}}_i)}{2h}, \\quad i \\in \\{x,y,z\\}$$\n-   MM 电荷上的解析力：$\\mathbf{F}_{\\mathrm{ana}}(\\mathbf{R}_q) = -\\nabla_{\\mathbf{R}_q} E_{\\mathrm{int}}(\\mathbf{R}_q)$。\n-   待计算的误差：$\\Delta = \\lVert \\mathbf{F}_{\\mathrm{num}}(\\mathbf{R}_q) - \\mathbf{F}_{\\mathrm{ana}}(\\mathbf{R}_q) \\rVert$。\n\n**测试用例：**\n-   用例 1: $\\mathbf{R}_A = (-0.7, 0.0, 0.0)$, $\\mathbf{R}_B = (0.7, 0.0, 0.0)$, $Z_A = 1$, $Z_B = 1$, $q = 0.5$, $\\alpha = 0.5$, $w_A = 0.6$, $w_B = 0.4$, $\\mathbf{R}_q = (0.3, 0.1, -0.2)$, $h = 10^{-4}$。\n-   用例 2: $\\mathbf{R}_A = (-0.7, 0.0, 0.0)$, $\\mathbf{R}_B = (0.7, 0.0, 0.0)$, $Z_A = 1$, $Z_B = 1$, $q = 0.5$, $\\alpha = 0.5$, $w_A = 0.6$, $w_B = 0.4$, $\\mathbf{R}_q = (10.0, -9.0, 5.0)$, $h = 10^{-4}$。\n-   用例 3: $\\mathbf{R}_A = (-0.7, 0.0, 0.0)$, $\\mathbf{R}_B = (0.7, 0.0, 0.0)$, $Z_A = 1$, $Z_B = 1$, $q = 0.5$, $\\alpha = 0.5$, $w_A = 0.6$, $w_B = 0.4$, $\\mathbf{R}_q = (-0.65, 0.0, 0.0)$, $h = 10^{-5}$。\n-   用例 4: $\\mathbf{R}_A = (-1.2, 0.0, 0.0)$, $\\mathbf{R}_B = (1.2, 0.0, 0.0)$, $Z_A = 1$, $Z_B = 1$, $q = -1.0$, $\\alpha = 1.0$, $w_A = 0.5$, $w_B = 0.5$, $\\mathbf{R}_q = (0.0, 0.0, 0.0)$, $h = 10^{-4}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：**该问题基于 QM/MM 方法中使用的一种称为静电嵌入的标准简化。使用高斯基函数表示电子密度是现代量子化学的基石。由高斯电荷分布产生的静电势公式是经典静电学中一个公认的结果。通过负梯度从能量计算力是物理学的基本原理。该问题的前提在科学和数学上都是合理的。\n2.  **良态问题：**该问题提供了明确的目标：计算数值力与解析力之间的差异。所有必需的参数和方程都已指定。推导解析梯度和实现有限差分法的任务是定义明确的数学和计算过程，对于每个测试用例都会得出唯一的解。\n3.  **客观性：**问题陈述以精确、无偏见和正式的科学语言编写。没有主观因素。\n4.  **完整性和一致性：**为每个测试用例提供了所有必要的信息（几何结构、电荷、参数、常数）。给定数据中没有矛盾之处（例如，在所有情况下都满足 $w_A + w_B = 1$）。该问题是自包含的。MM 电荷 $q$ 的位置从不与原子核位置重合，正确地避免了势能和力中的奇点。\n5.  **现实性和可行性：**参数选择在原子单位制下分子模拟的典型范围内。该任务在计算上是可行的。\n6.  **其他缺陷：**该问题并非微不足道，因为它需要正确应用向量微积分和仔细的数值实现。它不是同义反复、病态或无法验证的。\n\n### 步骤 3：结论与行动\n该问题被判定为 **有效**。它在科学上合理、良态且完整。我将继续进行求解。\n\n## 解法\n\n目标是计算 MM 电荷 $q$ 上的数值力 $\\mathbf{F}_{\\mathrm{num}}$ 和解析力 $\\mathbf{F}_{\\mathrm{ana}}$ 之间的差异 $\\Delta$。\n\n### 1. 解析力 $\\mathbf{F}_{\\mathrm{ana}}$ 的推导\n\n位于位置 $\\mathbf{R}_q$ 的 MM 电荷所受的力由相互作用能相对于 $\\mathbf{R}_q$ 的负梯度给出：\n$$ \\mathbf{F}_{\\mathrm{ana}}(\\mathbf{R}_q) = -\\nabla_{\\mathbf{R}_q} E_{\\mathrm{int}}(\\mathbf{R}_q) $$\n相互作用能是来自两个 QM 中心 A 和 B 的贡献之和。让我们分析来自一个通用中心 $X \\in \\{A, B\\}$ 的贡献，其核电荷为 $Z_X$，电子密度权重为 $w_X$，位置为 $\\mathbf{R}_X$。令 $\\mathbf{r}_X = \\mathbf{R}_q - \\mathbf{R}_X$ 且 $r_X = \\lVert \\mathbf{r}_X \\rVert$。能量表达式可以按中心分组：\n$$ E_{\\mathrm{int}}(\\mathbf{R}_q) = q \\sum_{X \\in \\{A,B\\}} \\left( \\frac{Z_X}{r_X} - w_X V_{\\mathrm{G}}(r_X) \\right) $$\n其中 $V_{\\mathrm{G}}(r_X) = \\frac{\\operatorname{erf}(\\beta r_X)}{r_X}$ 且 $\\beta=\\sqrt{\\alpha}$。\n\n力是来自每个中心的力之和：$\\mathbf{F}_{\\mathrm{ana}} = \\sum_{X \\in \\{A,B\\}} \\mathbf{F}_X$。\n$$ \\mathbf{F}_X = -\\nabla_{\\mathbf{R}_q} \\left[ q \\left( \\frac{Z_X}{r_X} - w_X \\frac{\\operatorname{erf}(\\beta r_X)}{r_X} \\right) \\right] $$\n使用梯度的链式法则，$\\nabla_{\\mathbf{R}_q} f(r_X) = \\frac{df}{dr_X} \\nabla_{\\mathbf{R}_q} r_X = \\frac{df}{dr_X} \\frac{\\mathbf{r}_X}{r_X}$。\n\n我们来求括号中两项相对于 $r_X$ 的导数：\n1.  **原子核库仑项：**\n    $$ \\frac{d}{dr_X} \\left( \\frac{Z_X}{r_X} \\right) = -\\frac{Z_X}{r_X^2} $$\n2.  **电子高斯项：** 我们使用商法则和误差函数的导数，$\\frac{d}{du}\\operatorname{erf}(u) = \\frac{2}{\\sqrt{\\pi}}e^{-u^2}$。\n    $$ \\frac{d}{dr_X} \\left( w_X \\frac{\\operatorname{erf}(\\beta r_X)}{r_X} \\right) = w_X \\frac{r_X \\left(\\frac{2\\beta}{\\sqrt{\\pi}}e^{-\\beta^2 r_X^2}\\right) - \\operatorname{erf}(\\beta r_X) \\cdot 1}{r_X^2} = w_X \\left( \\frac{2\\beta}{\\sqrt{\\pi} r_X}e^{-\\beta^2 r_X^2} - \\frac{\\operatorname{erf}(\\beta r_X)}{r_X^2} \\right) $$\n\n结合这些结果，中心 $X$ 的能量项的梯度为：\n$$ \\nabla_{\\mathbf{R}_q} \\left[ \\dots \\right]_X = \\left[ -\\frac{Z_X}{r_X^2} - w_X \\left( \\frac{2\\beta}{\\sqrt{\\pi} r_X}e^{-\\beta^2 r_X^2} - \\frac{\\operatorname{erf}(\\beta r_X)}{r_X^2} \\right) \\right] \\frac{\\mathbf{r}_X}{r_X} $$\n力的贡献 $\\mathbf{F}_X = -q \\cdot (\\nabla_{\\mathbf{R}_q} [\\dots]_X)$ 为：\n$$ \\mathbf{F}_X = q \\left[ \\frac{Z_X}{r_X^2} + w_X \\left( \\frac{2\\beta}{\\sqrt{\\pi} r_X}e^{-\\beta^2 r_X^2} - \\frac{\\operatorname{erf}(\\beta r_X)}{r_X^2} \\right) \\right] \\frac{\\mathbf{r}_X}{r_X} $$\n重新整理得到一个更紧凑的表达式：\n$$ \\mathbf{F}_X = q \\frac{\\mathbf{r}_X}{r_X^3} \\left( Z_X - w_X \\operatorname{erf}(\\beta r_X) + w_X \\frac{2\\beta r_X}{\\sqrt{\\pi}} e^{-\\beta^2 r_X^2} \\right) $$\n总解析力是两个中心的矢量和：\n$$ \\mathbf{F}_{\\mathrm{ana}}(\\mathbf{R}_q) = q \\sum_{X \\in \\{A,B\\}} \\frac{\\mathbf{R}_q - \\mathbf{R}_X}{\\lVert \\mathbf{R}_q - \\mathbf{R}_X \\rVert^3} \\left( Z_X - w_X \\left[ \\operatorname{erf}(\\beta \\lVert \\mathbf{R}_q - \\mathbf{R}_X \\rVert) - \\frac{2\\beta \\lVert \\mathbf{R}_q - \\mathbf{R}_X \\rVert}{\\sqrt{\\pi}} e^{-\\beta^2 \\lVert \\mathbf{R}_q - \\mathbf{R}_X \\rVert^2} \\right] \\right) $$\n这是要为解析力实现的最终表达式。\n\n### 2. 实现策略\n\n该解法将使用 `numpy` 和 `scipy` 库以 Python 实现。\n\n1.  **能量函数：** 将定义一个函数 `calculate_energy` 来为给定的位置向量 $\\mathbf{R}_q$ 计算 $E_{\\mathrm{int}}(\\mathbf{R}_q)$。它将接收所有系统参数作为参数。需要注意 $r \\to 0$ 的情况，此时电势 $V_G(r)$ 有一个有限的极限值 $V_G(0) = 2\\beta/\\sqrt{\\pi}$。尽管给定的测试用例避免了 $r=0$，但健壮的代码应考虑此情况。\n2.  **数值力：** 一个函数 `calculate_numerical_force` 将计算 $\\mathbf{F}_{\\mathrm{num}}(\\mathbf{R}_q)$。它将在每个笛卡尔坐标轴 $i \\in \\{x,y,z\\}$ 的位置 $\\mathbf{R}_q \\pm h\\hat{\\mathbf{e}}_i$ 调用 `calculate_energy` 函数，并应用中心差分公式。\n3.  **解析力：** 一个函数 `calculate_analytic_force` 将实现推导出的 $\\mathbf{F}_{\\mathrm{ana}}(\\mathbf{R}_q)$ 公式。它将计算来自中心 A 和 B 的力贡献并将它们相加。\n4.  **主循环：** 一个主循环将遍历提供的测试用例。对于每个用例，它将：a. 设置参数。b. 调用函数计算 $\\mathbf{F}_{\\mathrm{num}}$ 和 $\\mathbf{F}_{\\mathrm{ana}}$。c. 计算它们之间差值的欧几里得范数 $\\Delta = \\lVert \\mathbf{F}_{\\mathrm{num}} - \\mathbf{F}_{\\mathrm{ana}} \\rVert$。d. 将结果格式化为八位小数并存储。\n5.  **输出：** 最后，所有测试用例的汇总结果将以指定的格式 `[d1,d2,d3,d4]` 打印。\n\n有限差分法会引入一个截断误差，预计其量级为 $O(h^2)$。因此，计算出的差异 $\\Delta$ 将会很小但非零（除非在像测试用例 4 这样的特殊情况下，对称性可能导致精确的零力，从而使数值结果也为零）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM electrostatic force problem for a suite of test cases.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        {\n            \"RA\": np.array([-0.7, 0.0, 0.0]), \"RB\": np.array([0.7, 0.0, 0.0]),\n            \"ZA\": 1.0, \"ZB\": 1.0, \"q\": 0.5, \"alpha\": 0.5,\n            \"wA\": 0.6, \"wB\": 0.4, \"Rq\": np.array([0.3, 0.1, -0.2]), \"h\": 1e-4\n        },\n        {\n            \"RA\": np.array([-0.7, 0.0, 0.0]), \"RB\": np.array([0.7, 0.0, 0.0]),\n            \"ZA\": 1.0, \"ZB\": 1.0, \"q\": 0.5, \"alpha\": 0.5,\n            \"wA\": 0.6, \"wB\": 0.4, \"Rq\": np.array([10.0, -9.0, 5.0]), \"h\": 1e-4\n        },\n        {\n            \"RA\": np.array([-0.7, 0.0, 0.0]), \"RB\": np.array([0.7, 0.0, 0.0]),\n            \"ZA\": 1.0, \"ZB\": 1.0, \"q\": 0.5, \"alpha\": 0.5,\n            \"wA\": 0.6, \"wB\": 0.4, \"Rq\": np.array([-0.65, 0.0, 0.0]), \"h\": 1e-5\n        },\n        {\n            \"RA\": np.array([-1.2, 0.0, 0.0]), \"RB\": np.array([1.2, 0.0, 0.0]),\n            \"ZA\": 1.0, \"ZB\": 1.0, \"q\": -1.0, \"alpha\": 1.0,\n            \"wA\": 0.5, \"wB\": 0.5, \"Rq\": np.array([0.0, 0.0, 0.0]), \"h\": 1e-4\n        }\n    ]\n\n    results = []\n\n    def calculate_energy(Rq_vec, RA, RB, ZA, ZB, q, beta, wA, wB):\n        \"\"\"Calculates the total QM/MM electrostatic interaction energy.\"\"\"\n        sqrt_pi = np.sqrt(np.pi)\n        \n        # Contribution from center A\n        rA = np.linalg.norm(Rq_vec - RA)\n        if rA > 1e-12:\n            V_G_A = erf(beta * rA) / rA\n            E_nuc_A = ZA / rA\n        else: # Handle limit r -> 0\n            V_G_A = 2 * beta / sqrt_pi\n            E_nuc_A = np.inf # singularity\n        \n        # Contribution from center B\n        rB = np.linalg.norm(Rq_vec - RB)\n        if rB > 1e-12:\n            V_G_B = erf(beta * rB) / rB\n            E_nuc_B = ZB / rB\n        else: # Handle limit r -> 0\n            V_G_B = 2 * beta / sqrt_pi\n            E_nuc_B = np.inf # singularity\n\n        E_int = q * (E_nuc_A + E_nuc_B - wA * V_G_A - wB * V_G_B)\n        return E_int\n\n    def calculate_analytic_force(Rq, RA, RB, ZA, ZB, q, beta, wA, wB):\n        \"\"\"Calculates the analytical force on the MM charge.\"\"\"\n        sqrt_pi = np.sqrt(np.pi)\n        \n        def force_contribution(Rq_vec, RX, ZX, wX):\n            r_vec = Rq_vec - RX\n            r = np.linalg.norm(r_vec)\n            \n            if r  1e-12:\n                # Force is infinite if charge is at a nucleus position, but test cases avoid this.\n                # If a charge is at a point of symmetry where force should be zero, return zero.\n                return np.zeros(3)\n\n            # This implementation directly follows from F = -grad(E)\n            F_nuc_on_q = q * ZX * r_vec / (r**3)\n            \n            # Note the minus sign for electron density contribution\n            F_elec_on_q = -q * wX * ( erf(beta * r) / r**2 - (2 * beta / sqrt_pi) * np.exp(-beta**2 * r**2) / r ) * (r_vec / r)\n            \n            return F_nuc_on_q + F_elec_on_q\n\n        F_A = force_contribution(Rq, RA, ZA, wA)\n        F_B = force_contribution(Rq, RB, ZB, wB)\n        \n        return F_A + F_B\n\n    for case in test_cases:\n        Rq = case[\"Rq\"]\n        RA = case[\"RA\"]\n        RB = case[\"RB\"]\n        ZA = case[\"ZA\"]\n        ZB = case[\"ZB\"]\n        q = case[\"q\"]\n        alpha = case[\"alpha\"]\n        wA = case[\"wA\"]\n        wB = case[\"wB\"]\n        h = case[\"h\"]\n        \n        beta = np.sqrt(alpha)\n\n        # 1. Compute numerical force F_num\n        F_num = np.zeros(3)\n        h_vectors = [np.array([h, 0, 0]), np.array([0, h, 0]), np.array([0, 0, h])]\n        \n        for i in range(3):\n            h_vec = h_vectors[i]\n            E_plus = calculate_energy(Rq + h_vec, RA, RB, ZA, ZB, q, beta, wA, wB)\n            E_minus = calculate_energy(Rq - h_vec, RA, RB, ZA, ZB, q, beta, wA, wB)\n            F_num[i] = -(E_plus - E_minus) / (2 * h)\n\n        # 2. Compute analytical force F_ana\n        F_ana = calculate_analytic_force(Rq, RA, RB, ZA, ZB, q, beta, wA, wB)\n        \n        # 3. Compute the error Delta\n        delta = np.linalg.norm(F_num - F_ana)\n        results.append(f\"{delta:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "此项高级实践将QM/MM方法应用于一个核心化学问题：反应动力学。你将通过实施一种“留一法”（Leave-One-Out）分析，来系统地评估MM环境中的每个残基对化学反应活化能的贡献有多大 ()。这项练习不仅能让你熟练运用QM/MM进行能量计算，更重要的是，它将教会你如何从复杂的模拟数据中提取出关键的物理化学见解。",
            "id": "3753082",
            "problem": "考虑一个化学反应的量子力学/分子力学 (QM/MM) 静电嵌入，其中反应能垒是过渡态和反应物态之间的能量差。在静电嵌入中，量子力学 (QM) 区域会受到由分子力学 (MM) 点电荷产生的外部静电势的影响，从而改变 QM 能量。假设一个简化的第一性原理模型，其中对能垒偏移的 QM/MM 耦合贡献由离散化的 QM 电荷分布差值与 MM 点电荷之间的库仑相互作用给出。\n\n使用以下基本依据：\n- QM/MM 静电耦合能量贡献（过渡态与反应物态之差）建模为\n$$\nE_{\\text{cpl}} = \\int \\Delta \\rho(\\mathbf{r}) \\, V_{\\text{MM}}(\\mathbf{r}) \\, d\\mathbf{r},\n$$\n其中 $V_{\\text{MM}}(\\mathbf{r})$ 是由位于 $\\mathbf{R}_a$ 的 MM 电荷 $q_a$ 产生的 MM 静电势，$\\Delta \\rho(\\mathbf{r})$ 是过渡态与反应物态之间的 QM 电子密度差。\n- 将积分离散化为对 $N_{\\text{QM}}$ 个 QM 支持点的求和，这些支持点带有位于 $\\mathbf{r}_i$ 的差分电荷 $q_i^{\\Delta}$。所有电荷 $q_i^{\\Delta}$ 和 $q_a$ 均以基本电荷为单位，距离以纳米为单位，能量以千焦/摩尔 (kJ/mol) 表示。总耦合能 $E_{\\text{cpl}}$ 的计算公式为：\n$$\nE_{\\text{cpl}} \\approx 138.935 \\sum_{i=1}^{N_{\\text{QM}}} \\sum_{a=1}^{N_{\\text{MM}}} \\dfrac{q_i^{\\Delta} q_a}{\\lVert \\mathbf{r}_i - \\mathbf{R}_a \\rVert_{\\text{nm}}}.\n$$\n其中，系数 $138.935 \\ \\text{kJ}\\cdot\\text{nm}/\\text{mol}$ 是将单位（基本电荷²/nm）转换为 kJ/mol 的物理转换因子。\n- 静电嵌入中的总反应能垒则建模为\n$$\nE_{\\text{barrier}} = E_0 + E_{\\text{cpl}},\n$$\n其中 $E_0$ 是在没有 MM 静电耦合的情况下的固有 QM 能垒。\n\n对 MM 残基进行留一法 (LOO) 分析：将 MM 点电荷分组为由 $r = 0,1,\\dots,R-1$ 索引的残基。对于每个残基 $r$，将其电荷设置为零，重新计算能垒 $E_{\\text{barrier}}^{(-r)}$，并计算下降值 $\\delta_r = E_{\\text{barrier}} - E_{\\text{barrier}}^{(-r)}$。识别出使 $\\delta_r$ 最大化的主要贡献残基索引 $r^\\star$（若有多个最大值，则选择最小的索引）。使用 LOO 能垒相对于总能垒的变异系数来评估稳健性：\n$$\n\\text{robustness} = \\dfrac{\\operatorname{std}\\left( \\{ E_{\\text{barrier}}^{(-r)} \\}_{r=0}^{R-1} \\right)}{\\left| E_{\\text{barrier}} \\right|}.\n$$\n将此稳健性表示为小数（不带百分号）。\n\n你的程序必须实现此模型，并为每个测试用例生成一个包含四个值的列表：总能垒 $E_{\\text{barrier}}$ (kJ/mol)，四舍五入到三位小数；最大 LOO 能垒下降值 $\\max_r \\delta_r$ (kJ/mol)，四舍五入到三位小数；稳健性值，四舍五入到三位小数；以及主要残基索引 $r^\\star$，作为整数。\n\n测试套件：\n对于每个测试用例，输入参数为 $E_0$ (kJ/mol)，一个 QM 支持点列表 $(q_i^{\\Delta}, \\mathbf{r}_i)$，以及一个残基列表，每个残基是一个 MM 点电荷列表 $(q_a, \\mathbf{R}_a)$。\n\n- 测试用例 $1$ (正常路径)：\n  - $E_0 = 45.0$ kJ/mol。\n  - QM 点：$\\left[ (0.40, (0.00, 0.00, 0.00)), \\ (-0.20, (0.30, 0.00, 0.00)), \\ (0.10, (0.00, 0.40, 0.00)) \\right]$，距离单位为 nm。\n  - 残基：\n    - 残基 $0$：$\\left[ (0.50, (0.70, 0.00, 0.00)), \\ (-0.20, (0.80, 0.20, 0.00)) \\right]$。\n    - 残基 $1$：$\\left[ (-0.40, (0.20, 0.50, 0.00)) \\right]$。\n    - 残基 $2$：$\\left[ (0.30, (1.00, 0.00, 0.00)) \\right]$。\n\n- 测试用例 $2$ (边界情况，包含远近电荷和近中性残基)：\n  - $E_0 = 60.0$ kJ/mol。\n  - QM 点：$\\left[ (0.30, (0.00, 0.00, 0.00)), \\ (0.15, (0.50, 0.00, 0.00)) \\right]$。\n  - 残基：\n    - 残基 $0$：$\\left[ (0.60, (5.00, 0.00, 0.00)) \\right]$。\n    - 残基 $1$：$\\left[ (-0.20, (0.85, 0.00, 0.00)) \\right]$。\n    - 残基 $2$：$\\left[ (0.40, (0.25, 0.00, 0.00)), \\ (-0.40, (0.26, 0.00, 0.00)) \\right]$。\n\n- 测试用例 $3$ (对称性与抵消)：\n  - $E_0 = 35.0$ kJ/mol。\n  - QM 点：$\\left[ (0.25, (0.00, 0.00, 0.00)), \\ (-0.10, (0.40, 0.00, 0.00)), \\ (-0.05, (0.20, 0.35, 0.00)) \\right]$。\n  - 残基：\n    - 残基 $0$：$\\left[ (0.50, (0.60, 0.00, 0.00)) \\right]$。\n    - 残基 $1$：$\\left[ (-0.50, (0.60, 0.00, 0.00)) \\right]$。\n    - 残基 $2$：$\\left[ (0.05, (2.00, 2.00, 0.00)) \\right]$。\n\n你的程序应生成单行输出，其中包含三个测试用例的结果，形式为一个包含在方括号中的逗号分隔列表，其中每个元素本身就是上述针对一个测试用例的列表。例如，格式必须类似于 $\\left[ [E_{\\text{barrier}}^{(1)}, \\max\\delta^{(1)}, \\text{robust}^{(1)}, r^{\\star(1)}], [E_{\\text{barrier}}^{(2)}, \\max\\delta^{(2)}, \\text{robust}^{(2)}, r^{\\star(2)}], [E_{\\text{barrier}}^{(3)}, \\max\\delta^{(3)}, \\text{robust}^{(3)}, r^{\\star(3)}] \\right]$，其中能量单位为 kJ/mol，四舍五入到三位小数，稳健性为小数，四舍五入到三位小数。",
            "solution": "### 步骤 1：问题验证\n\n#### 提取已知条件\n\n问题提供了以下数据和定义：\n\n1.  **物理模型：**\n    *   离散化的 QM/MM 静电耦合能量贡献：\n        $$\n        E_{\\text{cpl}} \\approx 138.935 \\sum_{i=1}^{N_{\\text{QM}}} \\sum_{a=1}^{N_{\\text{MM}}} \\dfrac{q_i^{\\Delta} q_a}{\\lVert \\mathbf{r}_i - \\mathbf{R}_a \\rVert_{\\text{nm}}}\n        $$\n        其中 $q_i^{\\Delta}$ 和 $q_a$ 以基本电荷为单位，距离 $\\mathbf{r}_i, \\mathbf{R}_a$ 以纳米为单位，能量以 kJ/mol 为单位。\n    *   静电嵌入中的反应能垒：\n        $$\n        E_{\\text{barrier}} = E_0 + E_{\\text{cpl}}\n        $$\n        其中 $E_0$ 是固有 QM 能垒。\n\n2.  **分析流程 (留一法)：**\n    *   MM 电荷被分组为残基 $r=0, \\dots, R-1$。\n    *   对于每个残基 $r$，通过将该残基的电荷设置为零来计算一个留一能垒 $E_{\\text{barrier}}^{(-r)}$。\n    *   能垒下降值定义为 $\\delta_r = E_{\\text{barrier}} - E_{\\text{barrier}}^{(-r)}$。\n    *   通过最大化 $\\delta_r$ 的索引 $r^\\star$ 来识别主要贡献残基。若有多个最大值，则选择最小的索引。\n\n3.  **稳健性度量：**\n    *   LOO 能垒相对于总能垒的变异系数定义为：\n        $$\n        \\text{robustness} = \\dfrac{\\operatorname{std}\\left( \\{ E_{\\text{barrier}}^{(-r)} \\}_{r=0}^{R-1} \\right)}{\\left| E_{\\text{barrier}} \\right|}\n        $$\n\n4.  **测试用例：** 提供了三个具有不同参数的测试用例。\n\n5.  **输出要求：**\n    *   对于每个测试用例，一个包含四个值的列表：$[E_{\\text{barrier}}, \\max_r \\delta_r, \\text{robustness}, r^\\star]$。\n    *   能量必须以 kJ/mol 为单位，四舍五入到三位小数。\n    *   稳健性必须是小数，四舍五入到三位小数。\n    *   $r^\\star$ 必须是整数。\n\n#### 验证与结论\n\n1.  **科学依据：** 该问题描述了一个 QM/MM 模拟中静电嵌入的简化但标准的模型。使用库仑定律来模拟 QM 电荷密度和 MM 点电荷之间的相互作用是该领域的一个基本概念。提供的转换因子是物理上正确的。该模型在科学上是合理的。\n2.  **定义明确：** 该问题为计算所需量提供了一个清晰、确定性的算法。所有必要的输入（常数、函数形式、数据）都已给出，并且输出被明确定义。每个测试用例都存在唯一解。\n3.  **客观性：** 语言是形式化和定量的，使用了已确立的科学和数学术语。没有主观或基于意见的陈述。\n4.  **完整与一致：** 问题是自洽的。它指定了所有单位、转换因子和计算步骤。测试用例中提供的数据结构符合模型要求。没有明显的矛盾。例如，在测试用例 3 中，来自不同残基的两个 MM 原子共享相同的坐标，这在物理上是不太可能的，但在数学上是明确定义的，并且不会产生奇点，因为没有 QM 点占据相同的位置。\n5.  **结论：** 该问题被认定为**有效**。它是一个基于计算化学原理的、定义明确的计算问题。\n\n### 步骤 2：解决方案设计\n\n问题的核心是计算静电耦合能 $E_{\\text{cpl}}$。这需要对一组 QM 支持点和一组 MM 点电荷之间的成对库仑相互作用进行求和。\n\n分析过程如下：\n1.  **预计算残基贡献：** 执行留一法 (LOO) 分析最有效的方法是首先计算每个单独残基对总耦合能 $E_{\\text{cpl}}$ 的贡献。这个贡献 $\\delta_r$ 正是问题中定义的能垒下降值。\n    $$\n    \\delta_r = 138.935 \\sum_{i=1}^{N_{\\text{QM}}} \\sum_{a \\in \\text{residue } r} \\frac{q_i^{\\Delta} q_a}{\\lVert \\mathbf{r}_i - \\mathbf{R}_a \\rVert}\n    $$\n2.  **总能垒计算：** 总耦合能是所有残基贡献的总和：$E_{\\text{cpl}} = \\sum_r \\delta_r$。总能垒是 $E_{\\text{barrier}} = E_0 + E_{\\text{cpl}}$。\n3.  **LOO 分析：** 当残基 $r$ 被移除时，能垒的下降值 $\\delta_r$ 正是它对 $E_{\\text{cpl}}$ 的贡献。这是因为 $\\delta_r = E_{\\text{barrier}} - E_{\\text{barrier}}^{(-r)} = (E_0 + E_{\\text{cpl}}) - (E_0 + E_{\\text{cpl}}^{(-r)}) = E_{\\text{cpl}} - (E_{\\text{cpl}} - \\delta_r) = \\delta_r$。因此，在步骤 1 中计算的残基贡献列表与 LOO 下降值列表相同。\n4.  **主要残基：** 最大下降值 $\\max_r \\delta_r$ 及其对应的索引 $r^\\star$ 可以直接从 $\\delta_r$ 值列表中找到。\n5.  **稳健性计算：** 对于每个被留出的残基 $r$，其 LOO 能垒为 $E_{\\text{barrier}}^{(-r)} = E_{\\text{barrier}} - \\delta_r$。我们计算集合 $\\{E_{\\text{barrier}}^{(-r)}\\}$ 的标准差，然后除以总能垒的绝对值 $|E_{\\text{barrier}}|$。检查 $E_{\\text{barrier}} = 0$ 是一个好习惯，以防止除以零。\n\n这种结构化的方法避免了冗余计算，并直接映射到所需的输出。实现将使用 `numpy` 进行高效的向量操作，特别是使用 `numpy.linalg.norm` 来计算欧几里得距离。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM electrostatic embedding problem for a given set of test cases.\n    \"\"\"\n    # The conversion factor transforms (e^2 / nm) to kJ/mol.\n    # 1 / (4 * pi * eps0) * e^2 * N_A / (1e-9 m/nm) / (1000 J/kJ)\n    CONVERSION_FACTOR = 138.9354576\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"E0\": 45.0,\n            \"qm_points\": [\n                (0.40, (0.00, 0.00, 0.00)),\n                (-0.20, (0.30, 0.00, 0.00)),\n                (0.10, (0.00, 0.40, 0.00))\n            ],\n            \"residues\": [\n                [\n                    (0.50, (0.70, 0.00, 0.00)),\n                    (-0.20, (0.80, 0.20, 0.00))\n                ],\n                [\n                    (-0.40, (0.20, 0.50, 0.00))\n                ],\n                [\n                    (0.30, (1.00, 0.00, 0.00))\n                ]\n            ]\n        },\n        # Test Case 2\n        {\n            \"E0\": 60.0,\n            \"qm_points\": [\n                (0.30, (0.00, 0.00, 0.00)),\n                (0.15, (0.50, 0.00, 0.00))\n            ],\n            \"residues\": [\n                [\n                    (0.60, (5.00, 0.00, 0.00))\n                ],\n                [\n                    (-0.20, (0.85, 0.00, 0.00))\n                ],\n                [\n                    (0.40, (0.25, 0.00, 0.00)),\n                    (-0.40, (0.26, 0.00, 0.00))\n                ]\n            ]\n        },\n        # Test Case 3\n        {\n            \"E0\": 35.0,\n            \"qm_points\": [\n                (0.25, (0.00, 0.00, 0.00)),\n                (-0.10, (0.40, 0.00, 0.00)),\n                (-0.05, (0.20, 0.35, 0.00))\n            ],\n            \"residues\": [\n                [\n                    (0.50, (0.60, 0.00, 0.00))\n                ],\n                [\n                    (-0.50, (0.60, 0.00, 0.00))\n                ],\n                [\n                    (0.05, (2.00, 2.00, 0.00))\n                ]\n            ]\n        }\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        E0 = case[\"E0\"]\n        # Convert points to numpy arrays for vectorized operations\n        qm_points = [(q, np.array(pos)) for q, pos in case[\"qm_points\"]]\n        residues = [[(q, np.array(pos)) for q, pos in res] for res in case[\"residues\"]]\n\n        # Calculate the contribution of each residue to the coupling energy (delta_r)\n        residue_contributions = []\n        for residue in residues:\n            res_energy = 0.0\n            for qm_charge, qm_pos in qm_points:\n                for mm_charge, mm_pos in residue:\n                    dist = np.linalg.norm(qm_pos - mm_pos)\n                    # A distance of 0 would mean a singularity, which is not expected\n                    # in valid problem setups.\n                    if dist > 1e-9:\n                        res_energy += (qm_charge * mm_charge) / dist\n            \n            residue_contributions.append(res_energy * CONVERSION_FACTOR)\n\n        # Total coupling energy is the sum of all residue contributions\n        Ecpl = sum(residue_contributions)\n        \n        # Total barrier energy\n        E_barrier = E0 + Ecpl\n\n        # The barrier drop delta_r is equal to the residue's contribution\n        loo_drops = residue_contributions\n        \n        if not loo_drops:\n            max_delta = 0.0\n            r_star = 0 # Placeholder for no residues\n        else:\n            max_delta = max(loo_drops)\n            # Find the index of the dominant residue (smallest index in case of a tie)\n            r_star = np.argmax(loo_drops)\n\n        # Calculate Leave-One-Out (LOO) barriers\n        loo_barriers = [E_barrier - drop for drop in loo_drops]\n        \n        # Calculate robustness\n        if abs(E_barrier)  1e-9:\n            robustness = np.inf if np.std(loo_barriers) > 0 else 0\n        else:\n            # For robustness, std deviation is only meaningful for R > 1\n            if len(loo_barriers) > 1:\n                robustness = np.std(loo_barriers, ddof=0) / abs(E_barrier)\n            else:\n                robustness = 0.0\n\n        # Collate and round results for the current test case\n        case_result = [\n            round(E_barrier, 3),\n            round(max_delta, 3) if loo_drops else 0.0,\n            round(robustness, 3),\n            int(r_star)\n        ]\n        final_results.append(case_result)\n\n    # Format the final output string\n    output_str = str(final_results).replace(\"'\", '\"')\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}