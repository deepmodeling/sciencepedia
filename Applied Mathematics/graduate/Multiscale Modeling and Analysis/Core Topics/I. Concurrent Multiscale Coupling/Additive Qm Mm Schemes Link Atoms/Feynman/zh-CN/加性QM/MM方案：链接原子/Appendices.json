{
    "hands_on_practices": [
        {
            "introduction": "在将理论性的QM/MM方案应用于实际分子模拟时，首要步骤是精确地定义和构建QM/MM边界。当共价键跨越此边界时，必须引入连接原子（link atom）来饱和QM区域的化学价键。这项实践将指导你完成这一基本设置过程，通过编写一个算法来自动识别跨界共价键，并根据标准的化学原理（如共价半径和典型振动频率）来确定连接原子的位置和力场参数 。",
            "id": "3731032",
            "problem": "给定一个具有原子、笛卡尔坐标和共价键的分子图，考虑一个加和性量子力学/分子力学 (QM/MM) 方案，其中共价键可能跨越所提出的 QM/MM 划分。在这种情况下，会引入一个连接原子来饱和量子力学一侧的价键，同时保持沿断裂共价键的几何结构。\n\n从基本原理出发的起点：\n- 一个分子体系被建模为一个图，其中节点代表原子，边代表共价键。将原子集划分为两个不相交的子集：量子力学区域 $\\mathcal{Q}$ 和分子力学区域 $\\mathcal{M}$，其中 $\\mathcal{Q} \\cup \\mathcal{M}$ 等于全体原子集合，且 $\\mathcal{Q} \\cap \\mathcal{M} = \\emptyset$。\n- 对于每个键 $(i,j)$，当且仅当 $i \\in \\mathcal{Q}$ 且 $j \\in \\mathcal{M}$ 或 $i \\in \\mathcal{M}$ 且 $j \\in \\mathcal{Q}$ 时，该键跨越 QM/MM 边界。\n- 连接原子的位置是根据由共价半径定义的目标键长，使用方向缩放，沿着从量子力学原子到其分子力学配对原子的矢量放置的。设量子力学原子为 $q$，分子力学原子为 $m$。定义位置 $\\mathbf{r}_q$ 和 $\\mathbf{r}_m$，单位为埃。定义原始键长 $d_{qm} = \\|\\mathbf{r}_m - \\mathbf{r}_q\\|$，单位为埃。设 $X$ 是原子 $q$ 的元素，$H$ 是氢。定义元素 $E$ 的共价半径 $R_{\\mathrm{cov}}(E)$，单位为埃。目标连接键长为 $d_{\\mathrm{ref}}(X\\text{-}H) = R_{\\mathrm{cov}}(X) + R_{\\mathrm{cov}}(H)$，单位为埃。放置缩放因子为 $\\lambda = d_{\\mathrm{ref}}(X\\text{-}H)/d_{qm}$。连接原子的坐标为\n$$\n\\mathbf{r}_L = \\mathbf{r}_q + \\lambda (\\mathbf{r}_m - \\mathbf{r}_q)\n$$\n单位为埃，使得连接键长为 $d_{\\mathrm{link}} = d_{\\mathrm{ref}}(X\\text{-}H)$，单位为埃。\n- 为了进行参数化，将连接键建模为谐振子。角频率 $\\omega$ 通过 $\\omega = 2\\pi c \\tilde{\\nu}$ 与光谱波数 $\\tilde{\\nu}$（单位为反厘米）相关，其中 $c$ 是光速，单位为厘米/秒。力常数 $k$ 为\n$$\nk = \\mu \\,\\omega^2\n$$\n单位为牛顿/米，其中折合质量为\n$$\n\\mu = \\frac{m_X m_H}{m_X + m_H}\n$$\n$m_X$ 和 $m_H$ 的单位为千克。原子质量单位换算为 $1\\ \\mathrm{u} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$。光速为 $c = 2.99792458 \\times 10^{10}\\ \\mathrm{cm/s}$。$X\\text{-}H$ 伸缩振动的典型波数与元素相关：对于 $X=\\mathrm{C}$，$\\tilde{\\nu} = 3000\\ \\mathrm{cm}^{-1}$；对于 $X=\\mathrm{N}$，$\\tilde{\\nu} = 3300\\ \\mathrm{cm}^{-1}$；对于 $X=\\mathrm{O}$，$\\tilde{\\nu} = 3600\\ \\mathrm{cm}^{-1}$；对于 $X=\\mathrm{Si}$，$\\tilde{\\nu} = 2100\\ \\mathrm{cm}^{-1}$。\n\n您的任务是实现一个算法，该算法能够：\n- 识别所有跨越 QM/MM 划分的共价键。\n- 对于每个跨界键，使用上述方向缩放规则，在量子力学一侧构建一个单一的氢连接原子。\n- 通过计算其键长 $d_{\\mathrm{link}}$（单位埃）、折合质量 $\\mu$（单位千克）和简谐力常数 $k$（单位牛顿/米），对每个连接原子键进行参数化，其中波数需根据量子力学原子类型选择合适的数值。\n- 对于每个跨界键，返回一个列表，其中包含以下物理量，并严格遵守此顺序：$[x_L, y_L, z_L, d_{\\mathrm{link}}, k, \\mu, \\lambda]$，其中 $(x_L,y_L,z_L)$ 是连接原子的坐标（单位埃），$d_{\\mathrm{link}}$（单位埃），$k$（单位 $\\mathrm{N}/\\mathrm{m}$），$\\mu$（单位 $\\mathrm{kg}$），以及无量纲的 $\\lambda$。如果没有跨界键，则为该测试用例返回一个空列表。\n\n使用以下常数和元素属性：\n- 共价半径（单位：埃）：$R_{\\mathrm{cov}}(\\mathrm{H}) = 0.31$, $R_{\\mathrm{cov}}(\\mathrm{C}) = 0.76$, $R_{\\mathrm{cov}}(\\mathrm{N}) = 0.71$, $R_{\\mathrm{cov}}(\\mathrm{O}) = 0.66$, $R_{\\mathrm{cov}}(\\mathrm{Si}) = 1.11$。\n- 原子质量（单位：原子质量单位）：$m_{\\mathrm{H}} = 1.00784\\ \\mathrm{u}$, $m_{\\mathrm{C}} = 12.0107\\ \\mathrm{u}$, $m_{\\mathrm{N}} = 14.0067\\ \\mathrm{u}$, $m_{\\mathrm{O}} = 15.999\\ \\mathrm{u}$, $m_{\\mathrm{Si}} = 28.085\\ \\mathrm{u}$。\n- 波数（单位：反厘米）：$\\tilde{\\nu}_{\\mathrm{C}\\text{-}\\mathrm{H}} = 3000$, $\\tilde{\\nu}_{\\mathrm{N}\\text{-}\\mathrm{H}} = 3300$, $\\tilde{\\nu}_{\\mathrm{O}\\text{-}\\mathrm{H}} = 3600$, $\\tilde{\\nu}_{\\mathrm{Si}\\text{-}\\mathrm{H}} = 2100$。\n\n物理单位：\n- 坐标和距离必须以埃表示。\n- 力常数必须以 $\\mathrm{N}/\\mathrm{m}$ 表示。\n- 折合质量必须以 $\\mathrm{kg}$ 表示。\n\n测试套件：\n提供一个程序，使用以下六个测试用例（所有索引均从零开始），并根据上述规则生成结果。\n\n- 测试用例 $1$（正常路径，碳-碳边界）：\n  - 位置（单位埃）：$\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.54, 0.0, 0.0)$。\n  - 元素：$[\\mathrm{C}, \\mathrm{C}]$。\n  - 键：$\\{(0,1)\\}$。\n  - QM 集：$\\mathcal{Q} = \\{0\\}$, MM 集：$\\mathcal{M} = \\{1\\}$。\n\n- 测试用例 $2$（氮-碳边界）：\n  - 位置（单位埃）：$\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.47, 0.0, 0.0)$。\n  - 元素：$[\\mathrm{N}, \\mathrm{C}]$。\n  - 键：$\\{(0,1)\\}$。\n  - QM 集：$\\mathcal{Q} = \\{0\\}$, MM 集：$\\mathcal{M} = \\{1\\}$。\n\n- 测试用例 $3$（氧-碳边界）：\n  - 位置（单位埃）：$\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.43, 0.0, 0.0)$。\n  - 元素：$[\\mathrm{O}, \\mathrm{C}]$。\n  - 键：$\\{(0,1)\\}$。\n  - QM 集：$\\mathcal{Q} = \\{0\\}$, MM 集：$\\mathcal{M} = \\{1\\}$。\n\n- 测试用例 $4$（硅-碳边界）：\n  - 位置（单位埃）：$\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.89, 0.0, 0.0)$。\n  - 元素：$[\\mathrm{Si}, \\mathrm{C}]$。\n  - 键：$\\{(0,1)\\}$。\n  - QM 集：$\\mathcal{Q} = \\{0\\}$, MM 集：$\\mathcal{M} = \\{1\\}$。\n\n- 测试用例 $5$（无跨界键）：\n  - 位置（单位埃）：$\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (1.54, 0.0, 0.0)$。\n  - 元素：$[\\mathrm{C}, \\mathrm{C}]$。\n  - 键：$\\{(0,1)\\}$。\n  - QM 集：$\\mathcal{Q} = \\{0,1\\}$, MM 集：$\\mathcal{M} = \\emptyset$。\n\n- 测试用例 $6$（拉伸的碳-碳边界）：\n  - 位置（单位埃）：$\\mathbf{r}_0 = (0.0, 0.0, 0.0)$, $\\mathbf{r}_1 = (3.0, 0.0, 0.0)$。\n  - 元素：$[\\mathrm{C}, \\mathrm{C}]$。\n  - 键：$\\{(0,1)\\}$。\n  - QM 集：$\\mathcal{Q} = \\{0\\}$, MM 集：$\\mathcal{M} = \\{1\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目。每个测试用例条目本身必须是一个连接原子条目的列表。每个连接原子条目必须是按规定顺序排列的列表 $[x_L,y_L,z_L,d_{\\mathrm{link}},k,\\mu,\\lambda]$。例如，如果测试用例 $i$ 有一个跨界键，其条目将看起来像 $[[x_L,y_L,z_L,d_{\\mathrm{link}},k,\\mu,\\lambda]]$；如果没有跨界键，其条目将是 $[]$。",
            "solution": "该问题要求实现一个算法，用于在加和性量子力学/分子力学 (QM/MM) 模拟中放置连接原子并对其进行参数化。该过程基于计算化学中的既定方法。解决方案是遵循所提供的物理原理和数学定义而设计的。\n\n任务的核心是处理一系列分子体系，每个体系都由其原子成分、笛卡尔坐标、共价连接性以及划分为量子力学 ($\\mathcal{Q}$) 区域和分子力学 ($\\mathcal{M}$) 区域来定义。对于每个体系，我们必须识别跨越此划分的共价键，并为每个此类键引入一个氢连接原子并计算其属性。\n\n该算法由一系列逻辑步骤构成：\n\n1.  **识别跨界键**：共价键连接两个原子，假设其索引为 $i$ 和 $j$。如果一个原子属于 $\\mathcal{Q}$ 区域，而另一个原子属于 $\\mathcal{M}$ 区域，则该键被定义为“跨界键”。这由逻辑条件 $(i \\in \\mathcal{Q} \\land j \\in \\mathcal{M}) \\lor (j \\in \\mathcal{Q} \\land i \\in \\mathcal{M})$ 表达。对体系键列表中的每个键检查此条件。如果不满足，则该键完全位于一个区域内，不需要连接原子。\n\n2.  **连接原子的几何放置**：对于每个识别出的跨界键，引入一个氢连接原子 ($L$) 来饱和 QM 原子 ($q$) 的自由价，该 QM 原子先前与 MM 原子 ($m$) 成键。连接原子的位置 $\\mathbf{r}_L$ 由方向缩放规则确定。此规则将连接原子放置在从 QM 原子指向 MM 原子的矢量 $\\mathbf{v}_{qm} = \\mathbf{r}_m - \\mathbf{r}_q$ 的方向上。\n    关键原则是将 QM 原子 ($X$) 和连接原子 ($H$) 之间的新键长设置为一个标准的参考值 $d_{\\mathrm{link}}$，该值与原始键的几何结构无关。此参考长度定义为两个原子共价半径之和，$d_{\\mathrm{link}} = d_{\\mathrm{ref}}(X\\text{-}H) = R_{\\mathrm{cov}}(X) + R_{\\mathrm{cov}}(H)$。\n    原始键的长度为 $d_{qm} = \\|\\mathbf{r}_m - \\mathbf{r}_q\\|$。为达到所需的连接键长，矢量 $\\mathbf{v}_{qm}$ 按比例因子 $\\lambda = d_{\\mathrm{link}} / d_{qm}$ 进行缩放。\n    连接原子的最终坐标由以下公式给出：\n    $$\n    \\mathbf{r}_L = \\mathbf{r}_q + \\lambda (\\mathbf{r}_m - \\mathbf{r}_q)\n    $$\n    其中所有坐标和距离的单位均为埃 ($\\mathrm{\\AA}$)。\n\n3.  **连接键的物理参数化**：新形成的 $X$-$H$ 连接键在 QM/MM 能量表达式的 MM 力场部分通常被建模为一个简谐振子（尽管这里我们只计算参数）。这需要计算 $X$-$H$ 体系的折合质量 ($\\mu$) 和键伸缩的简谐力常数 ($k$)。\n\n    a.  **折合质量 ($\\mu$)**：对于由 QM 原子 $X$ 和氢连接原子 $H$ 组成的双体系统，折合质量使用它们各自的原子质量 $m_X$ 和 $m_H$ 计算：\n        $$\n        \\mu = \\frac{m_X m_H}{m_X + m_H}\n        $$\n        所提供的原子质量单位为原子质量单位 ($\\mathrm{u}$)，在后续计算中必须使用换算因子 $1\\ \\mathrm{u} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$ 将其转换为千克 ($\\mathrm{kg}$) 以保持一致性。\n\n    b.  **力常数 ($k$)**：力常数由键的振动频率导出。在光谱学中，这通常以波数 $\\tilde{\\nu}$（单位为 $\\mathrm{cm}^{-1}$）的形式给出，它特定于键的类型（例如，C-H、N-H）。波数通过以下公式与角频率 $\\omega$ 相关：\n        $$\n        \\omega = 2\\pi c \\tilde{\\nu}\n        $$\n        其中 $c$ 是光速。使用单位为 $\\mathrm{cm/s}$ 的 $c$ 和单位为 $\\mathrm{cm}^{-1}$ 的 $\\tilde{\\nu}$，可以得到单位为 $\\mathrm{s}^{-1}$ 的 $\\omega$。谐振子的力常数 $k$ 则由以下公式给出：\n        $$\n        k = \\mu \\omega^2\n        $$\n        如果 $\\mu$ 的单位是 $\\mathrm{kg}$，$\\omega$ 的单位是 $\\mathrm{s}^{-1}$，则得出的力常数 $k$ 的单位将是 $\\mathrm{kg/s^2}$，这等同于牛顿/米 ($\\mathrm{N/m}$)。\n\n4.  **实现与数据聚合**：实现该算法以处理一套测试用例。对于每个用例，算法遍历指定的键。如果一个键跨越 QM/MM 边界，算法会识别出 QM 侧的原子 ($q$) 及其对应的元素 ($X$)，计算所需的七个量（$\\mathbf{r}_L = (x_L, y_L, z_L)$，$d_{\\mathrm{link}}$，$k$，$\\mu$ 和 $\\lambda$），并将它们存储在一个列表中。每个测试用例的最终输出是一个包含其所有跨界键结果的列表。如果测试用例没有跨界键，则返回一个空列表。所有计算均遵循所提供的物理常数和特定于元素的参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM link atom problem for a given set of test cases.\n    \"\"\"\n    # Define constants and element properties\n    U_TO_KG = 1.66053906660e-27  # kg/u\n    C_CMS = 2.99792458e10       # cm/s\n\n    COVALENT_RADII = {\n        'H': 0.31, 'C': 0.76, 'N': 0.71, 'O': 0.66, 'Si': 1.11\n    }\n    ATOMIC_MASSES = {\n        'H': 1.00784, 'C': 12.0107, 'N': 14.0067, 'O': 15.999, 'Si': 28.085\n    }\n    WAVENUMBERS = {\n        'C': 3000, 'N': 3300, 'O': 3600, 'Si': 2100\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: C-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.54, 0.0, 0.0)],\n            \"elements\": ['C', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 2: N-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.47, 0.0, 0.0)],\n            \"elements\": ['N', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 3: O-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.43, 0.0, 0.0)],\n            \"elements\": ['O', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 4: Si-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.89, 0.0, 0.0)],\n            \"elements\": ['Si', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        },\n        # Test Case 5: No crossing bond\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (1.54, 0.0, 0.0)],\n            \"elements\": ['C', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0, 1},\n            \"mm_set\": set()\n        },\n        # Test Case 6: Stretched C-C boundary\n        {\n            \"positions\": [(0.0, 0.0, 0.0), (3.0, 0.0, 0.0)],\n            \"elements\": ['C', 'C'],\n            \"bonds\": {(0, 1)},\n            \"qm_set\": {0},\n            \"mm_set\": {1}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        positions = [np.array(p) for p in case[\"positions\"]]\n        elements = case[\"elements\"]\n        bonds = case[\"bonds\"]\n        qm_set = case[\"qm_set\"]\n        mm_set = case[\"mm_set\"]\n\n        for i, j in bonds:\n            is_crossing = (i in qm_set and j in mm_set) or \\\n                          (j in qm_set and i in mm_set)\n\n            if is_crossing:\n                if i in qm_set:\n                    q_idx, m_idx = i, j\n                else:\n                    q_idx, m_idx = j, i\n                \n                r_q = positions[q_idx]\n                r_m = positions[m_idx]\n                \n                # 1. Geometric Placement\n                d_qm = np.linalg.norm(r_m - r_q)\n                \n                X_element = elements[q_idx]\n                d_link = COVALENT_RADII[X_element] + COVALENT_RADII['H']\n                \n                # Avoid division by zero for coincident atoms\n                if d_qm == 0:\n                    lambda_scale = 0.0\n                else:\n                    lambda_scale = d_link / d_qm\n                \n                r_L = r_q + lambda_scale * (r_m - r_q)\n\n                # 2. Physical Parameterization\n                # Reduced Mass\n                m_X_u = ATOMIC_MASSES[X_element]\n                m_H_u = ATOMIC_MASSES['H']\n                mu_u = (m_X_u * m_H_u) / (m_X_u + m_H_u)\n                mu_kg = mu_u * U_TO_KG\n\n                # Force Constant\n                wavenumber = WAVENUMBERS[X_element] # in cm^-1\n                omega = 2 * math.pi * C_CMS * wavenumber # in s^-1\n                k_force = mu_kg * omega**2 # in N/m\n\n                # 3. Assemble results in specified order\n                link_atom_data = [\n                    r_L[0], r_L[1], r_L[2],  # x_L, y_L, z_L\n                    d_link,                  # d_link\n                    k_force,                 # k\n                    mu_kg,                   # mu\n                    lambda_scale             # lambda\n                ]\n                case_results.append(link_atom_data)\n\n        all_results.append(case_results)\n\n    # Format the final output string without extra spaces in lists\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(x) for x in item)}]\"\n        return str(item)\n    \n    final_output_str = f\"[{','.join(format_list(res) for res in all_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "虽然连接原子方案解决了悬空键问题，但它本身作为一种近似方法，会引入新的误差，尤其是在描述跨界二面角（扭转角）时。这项练习将引导你掌握一种量化和补偿这种扭转偏倚（torsional bias）的强大技术。通过对扭转势能面进行采样，并拟合一个修正势，你可以系统性地消除连接原子引入的误差，从而显著提高QM/MM模型的精度 。",
            "id": "3731025",
            "problem": "您的任务是建立一种有原则的方法，用于量化和补偿在加性量子力学/分子力学 (QM/MM) 方案中，由共价边界处的连接原子引入的扭转能量偏差。其背景是一个由跨越QM/MM边界的四个原子定义的二面角（扭转角）。在量子力学 (QM) 计算中，连接原子取代了边界原子之一，这可能相对于原始、未切割的分子拓扑结构中相应的扭转，引入系统性的扭转能量偏差。\n\n基本原理和定义：\n- 在加性 QM/MM 方案中，总能量分解为量子力学 (QM) 子系统的能量、整个系统的分子力学 (MM) 能量，以及减去 QM 区域上的 MM 能量以避免重复计算之和。二面角（扭转）能量是 MM 能量的一个分量，它依赖于扭转角 $\\phi$。\n- 令 $\\phi$ 为边界二面角的扭转角，以弧度为单位，且 $\\phi \\in [0, 2\\pi)$。\n- 令 $V^{\\mathrm{QM}}(\\phi)$ 表示未切割系统的参考扭转能量曲线（即没有连接原子的理想化曲线），该曲线与高水平 QM 描述相容。\n- 令 $V^{\\mathrm{QM+LA}}(\\phi)$ 表示在 QM 计算中连接原子 (LA) 取代边界原子时实际获得的扭转能量曲线。\n- 由连接原子引起的残余扭转偏差定义为 $B(\\phi) = V^{\\mathrm{QM+LA}}(\\phi) - V^{\\mathrm{QM}}(\\phi)$。\n- 许多分子力学 (MM) 力场通过 $\\phi$ 的截断傅里叶级数来表示扭转。在本问题中，MM 校正势被约束在傅里叶族 $V^{\\mathrm{corr}}(\\phi) = c_0 + \\sum_{m=1}^{M} \\left[a_m \\cos(m \\phi) + b_m \\sin(m \\phi)\\right]$ 中，其中 $M$ 是最大谐波阶数，$c_0$、$a_m$、$b_m$ 是待确定的实系数。\n\n您的任务：\n1. 从以上定义出发，构建一个计算方法，该方法：\n   - 在 $[0, 2\\pi)$ 范围内以弧度为单位均匀采样 $\\phi$，\n   - 为每个样本计算残余偏差 $B(\\phi)$，\n   - 确定 $V^{\\mathrm{corr}}(\\phi)$ 的系数 $c_0$、$a_m$、$b_m$，使得在采样角度上 $B(\\phi)$ 和 $V^{\\mathrm{corr}}(\\phi)$ 之间的均方偏差最小化。\n2. 证明应用 $V^{\\mathrm{corr}}(\\phi)$ 会根据校正后的残余偏差 $B_{\\mathrm{corr}}(\\phi) = B(\\phi) - V^{\\mathrm{corr}}(\\phi)$ 来减小偏差。\n3. 通过为每个测试案例计算两个度量来量化补偿效果：\n   - 校正前的均方根偏差，$\\mathrm{RMSE}_{\\mathrm{before}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} B(\\phi_i)^2}$，\n   - 校正后的均方根偏差，$\\mathrm{RMSE}_{\\mathrm{after}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left(B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i)\\right)^2}$，\n   其中 $N$ 是采样角度的数量。\n4. 所有能量必须以千卡/摩尔 (kcal/mol) 表示，角度必须以弧度表示。\n\n用于测试的扭转曲线表示：\n- 为了生成一个科学上合理、可复现的测试套件，假设扭转曲线具有以下参数化表示，这与广泛使用的 MM 扭转形式一致。对于整数 $m \\ge 1$，振幅 $V_m$ (单位 kcal/mol)，以及相移 $\\gamma_m$ (单位 弧度)，\n  $$V(\\phi) = \\sum_{m} \\frac{V_{m}}{2} \\left[1 + \\cos\\!\\left(m \\phi - \\gamma_{m}\\right)\\right].$$\n- 在本问题中，残余偏差 $B(\\phi)$ 是由相同形式的项之和生成的（即，两个扭转曲线之间的差异本身可以表示为此类项的和），并且可选地，为一个边界情况添加一个小的振幅噪声项，以模拟数值或模型误差。\n\n程序要求：\n- 使用大小为 $N$ 的均匀网格，在 $[0, 2\\pi)$ 范围内（不包括端点），以弧度为单位实现上述方法。\n- 在最大谐波阶数 $M$ 内，通过最小化与网格上 $B(\\phi)$ 的均方偏差来拟合 MM 校正势 $V^{\\mathrm{corr}}(\\phi)$。\n- 对于每个测试案例，计算以 kcal/mol 为单位的 $\\mathrm{RMSE}_{\\mathrm{before}}$ 和 $\\mathrm{RMSE}_{\\mathrm{after}}$。\n- 使用以下带有明确参数的测试套件。在所有情况下，能量单位为 kcal/mol，角度单位为弧度，且 $N=360$：\n  1. 理想情况 (Happy path)：$B(\\phi)$ 由校正族能够完全表示的谐波构成。\n     - 偏差项：$(m, U_m, \\psi_m)$ 列表为 $\\{(1, 0.6, \\pi/6), (3, 0.4, -\\pi/3)\\}$，其中 $B(\\phi) = \\sum \\frac{U_m}{2}\\left[1 + \\cos(m\\phi - \\psi_m)\\right]$。\n     - 拟合阶数：$M=3$。\n     - 噪声标准差：$\\sigma=0.0$。\n  2. 零偏差边界情况：$B(\\phi) \\equiv 0$。\n     - 偏差项：空列表。\n     - 拟合阶数：$M=3$。\n     - 噪声标准差：$\\sigma=0.0$。\n  3. 欠拟合边界情况：$B(\\phi)$ 包含超出拟合阶数的谐波。\n     - 偏差项：$\\{(6, 0.5, \\pi/8), (4, 0.3, \\pi/3)\\}$。\n     - 拟合阶数：$M=3$。\n     - 噪声标准差：$\\sigma=0.0$。\n  4. 含噪声偏差情况：$B(\\phi)$ 在拟合阶数内，并加上小的加性噪声。\n     - 偏差项：$\\{(2, 0.5, \\pi/4), (1, 0.3, -\\pi/6)\\}$。\n     - 拟合阶数：$M=3$。\n     - 噪声标准差：$\\sigma=0.05$。使用固定的伪随机种子 $42$ 来生成独立同分布的高斯噪声，其均值为 $0$，标准差为 $\\sigma$，并加到 $B(\\phi)$ 上。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n  $$\\left[\\mathrm{RMSE}_{\\mathrm{before}}^{(1)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(1)}, \\mathrm{RMSE}_{\\mathrm{before}}^{(2)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(2)}, \\mathrm{RMSE}_{\\mathrm{before}}^{(3)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(3)}, \\mathrm{RMSE}_{\\mathrm{before}}^{(4)}, \\mathrm{RMSE}_{\\mathrm{after}}^{(4)}\\right],$$\n  其中上标表示测试案例编号。\n- 每个值必须是浮点数，单位为 kcal/mol，并四舍五入到六位小数。",
            "solution": "所提出的问题是开发、实现并测试一种计算校正势 $V^{\\mathrm{corr}}(\\phi)$ 的方法，以补偿在量子力学/分子力学 (QM/MM) 边界由连接原子引入的扭转能量偏差 $B(\\phi)$。该校正势必须属于一个特定的截断傅里叶级数族，并通过最小化与偏差势的均方偏差来确定。\n\n首先，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   **背景**：在共价边界处有连接原子的加性 QM/MM 方案。\n-   **二面角**：$\\phi \\in [0, 2\\pi)$。\n-   **参考势（理想）**：$V^{\\mathrm{QM}}(\\phi)$。\n-   **含连接原子的势**：$V^{\\mathrm{QM+LA}}(\\phi)$。\n-   **残余偏差**：$B(\\phi) = V^{\\mathrm{QM+LA}}(\\phi) - V^{\\mathrm{QM}}(\\phi)$。\n-   **校正势形式**：$V^{\\mathrm{corr}}(\\phi) = c_0 + \\sum_{m=1}^{M} \\left[a_m \\cos(m \\phi) + b_m \\sin(m \\phi)\\right]$，其中 $M$ 是最大谐波阶数。\n-   **方法论**：在 $[0, 2\\pi)$ 范围内用 $N$ 个点均匀采样 $\\phi$。通过最小化 $B(\\phi)$ 和 $V^{\\mathrm{corr}}(\\phi)$ 之间的均方偏差来确定系数 $c_0$、$a_m$、$b_m$。\n-   **校正后残差**：$B_{\\mathrm{corr}}(\\phi) = B(\\phi) - V^{\\mathrm{corr}}(\\phi)$。\n-   **量化度量**：\n    -   $\\mathrm{RMSE}_{\\mathrm{before}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} B(\\phi_i)^2}$。\n    -   $\\mathrm{RMSE}_{\\mathrm{after}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\left(B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i)\\right)^2}$。\n-   **测试偏差函数形式**：$B(\\phi) = \\sum_{k} \\frac{U_{k}}{2} \\left[1 + \\cos\\!\\left(k \\phi - \\psi_{k}\\right)\\right]$，可能带有加性噪声。\n-   **参数**：$N=360$。能量单位 kcal/mol，角度单位弧度。\n-   **测试案例**：\n    1.  理想情况：$B(\\phi)$ 来自项 $(m, U_m, \\psi_m) = \\{(1, 0.6, \\pi/6), (3, 0.4, -\\pi/3)\\}$。拟合阶数 $M=3$。噪声 $\\sigma=0.0$。\n    2.  零偏差：$B(\\phi)$ 来自空列表项。拟合阶数 $M=3$。噪声 $\\sigma=0.0$。\n    3.  欠拟合：$B(\\phi)$ 来自项 $\\{(6, 0.5, \\pi/8), (4, 0.3, \\pi/3)\\}$。拟合阶数 $M=3$。噪声 $\\sigma=0.0$。\n    4.  含噪声偏差：$B(\\phi)$ 来自项 $\\{(2, 0.5, \\pi/4), (1, 0.3, -\\pi/6)\\}$。拟合阶数 $M=3$。噪声 $\\sigma=0.05$ (高斯噪声，种子=42)。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学上合理**：该问题牢固地植根于多尺度计算化学领域。加性 QM/MM 方案、连接原子问题以及使用傅里叶级数表示扭转势都是标准概念。拟合校正势的方法是提高 QM/MM 准确性的一种公认策略。该问题在科学上是合理的。\n-   **良态的 (Well-Posed)**：任务是找到基函数的线性组合的系数，以最小二乘的方式最好地拟合一组数据。这是一个经典的普通最小二乘 (OLS) 问题。鉴于基函数（$1$, $\\cos(m\\phi)$, $\\sin(m\\phi)$）是线性无关的，存在唯一且稳定的解。该问题是良态的。\n-   **客观性**：该问题用精确的数学公式、数值参数和明确的指令来定义。测试案例是具体且可复现的。语言是客观的，没有主观论断。\n\n该问题没有表现出任何无效性缺陷。它是科学上合理的、可形式化的、完整的、现实的且良态的。\n\n**步骤 3：结论与行动**\n问题有效。将提供一个合理的解决方案。\n\n**解法推导**\n\n主要目标是通过最小化在从 $[0, 2\\pi)$ 均匀采样的 $N$ 个离散角度集合 $\\{\\phi_i\\}_{i=1}^N$ 上，偏差曲线 $B(\\phi)$ 的均方偏差，来确定校正势 $V^{\\mathrm{corr}}(\\phi)$ 的系数 $c_0$、$\\{a_m\\}_{m=1}^M$ 和 $\\{b_m\\}_{m=1}^M$。角度由 $\\phi_i = \\frac{2\\pi (i-1)}{N}$ 给出，其中 $i=1, \\dots, N$。\n\n需要最小化的量是残差平方和 $\\chi^2$：\n$$\n\\chi^2 = \\sum_{i=1}^{N} \\left[ B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i) \\right]^2 = \\sum_{i=1}^{N} \\left[ B(\\phi_i) - \\left( c_0 + \\sum_{m=1}^{M} \\left[ a_m \\cos(m \\phi_i) + b_m \\sin(m \\phi_i) \\right] \\right) \\right]^2\n$$\n为了找到最小值，我们对 $\\chi^2$ 关于每个系数求偏导数，并将其设为零。\n\n对于常数项 $c_0$：\n$$\n\\frac{\\partial \\chi^2}{\\partial c_0} = -2 \\sum_{i=1}^{N} \\left[ B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i) \\right] = 0\n$$\n代入 $V^{\\mathrm{corr}}(\\phi_i)$ 并利用三角基函数在均匀网格上的正交性，其中对于整数 $m \\neq 0, N, 2N, \\dots$，有 $\\sum_{i=1}^{N} \\cos(m\\phi_i) = 0$ 和 $\\sum_{i=1}^{N} \\sin(m\\phi_i) = 0$，我们得到：\n$$\n\\sum_{i=1}^{N} B(\\phi_i) = \\sum_{i=1}^{N} c_0 = N c_0 \\implies c_0 = \\frac{1}{N} \\sum_{i=1}^{N} B(\\phi_i)\n$$\n这恰好是偏差在采样点上的平均值。\n\n对于余弦系数 $a_k$ (其中 $k \\in \\{1, \\dots, M\\}$)：\n$$\n\\frac{\\partial \\chi^2}{\\partial a_k} = -2 \\sum_{i=1}^{N} \\left[ B(\\phi_i) - V^{\\mathrm{corr}}(\\phi_i) \\right] \\cos(k \\phi_i) = 0\n$$\n这导致 $\\sum_{i=1}^{N} B(\\phi_i) \\cos(k \\phi_i) = \\sum_{i=1}^{N} V^{\\mathrm{corr}}(\\phi_i) \\cos(k \\phi_i)$。同样，由于在均匀网格上的正交性（对于不在奈奎斯特频率的 $m,k$，有 $\\sum \\cos(m\\phi_i)\\cos(k\\phi_i) = \\frac{N}{2}\\delta_{mk}$，$\\sum \\sin(m\\phi_i)\\cos(k\\phi_i) = 0$），等式右边的和会大大简化：\n$$\n\\sum_{i=1}^{N} B(\\phi_i) \\cos(k \\phi_i) = a_k \\sum_{i=1}^{N} \\cos^2(k \\phi_i) = a_k \\frac{N}{2} \\implies a_k = \\frac{2}{N} \\sum_{i=1}^{N} B(\\phi_i) \\cos(k \\phi_i)\n$$\n\n对于正弦系数 $b_k$ (其中 $k \\in \\{1, \\dots, M\\}$)：\n一个并行的推导给出：\n$$\n\\sum_{i=1}^{N} B(\\phi_i) \\sin(k \\phi_i) = b_k \\sum_{i=1}^{N} \\sin^2(k \\phi_i) = b_k \\frac{N}{2} \\implies b_k = \\frac{2}{N} \\sum_{i=1}^{N} B(\\phi_i) \\sin(k \\phi_i)\n$$\n这些公式定义了采样偏差函数 $B(\\phi_i)$ 的离散傅里叶级数展开的系数。这证实了最小二乘拟合过程等价于将偏差函数投影到傅里叶基上。\n\n在计算上，这些系数可以通过快速傅里叶变换 (FFT) 高效获得。对于一个实值输入向量（即样本 $\\{B(\\phi_i)\\}$），`rfft` 算法计算 $F_k = \\sum_{i=1}^{N} B(\\phi_i) e^{-j \\phi_i k}$，其中 $j=\\sqrt{-1}$。然后，系数与 $F_k$ 的分量相关联：\n-   $c_0 = F_0 / N$\n-   $a_m = 2 \\cdot \\mathrm{Re}(F_m) / N$\n-   $b_m = -2 \\cdot \\mathrm{Im}(F_m) / N$\n\n一旦确定了系数，$V^{\\mathrm{corr}}(\\phi)$ 就被完全指定了。将此校正应用于原始偏差 $B(\\phi)$ 会得到校正后的残余偏差 $B_{\\mathrm{corr}}(\\phi) = B(\\phi) - V^{\\mathrm{corr}}(\\phi)$。\n\n这种补偿的有效性通过比较校正前后的均方根偏差 (RMSE) 来量化。根据最小二乘法原理，校正势 $V^{\\mathrm{corr}}(\\phi)$ 是其族内唯一能最小化残差平方和的函数，因此也最小化了 $\\mathrm{RMSE}_{\\mathrm{after}}$。因此，可以保证 $\\mathrm{RMSE}_{\\mathrm{after}} \\le \\mathrm{RMSE}_{\\mathrm{before}}$。RMSE 的显著降低表明系统偏差得到了成功补偿。\n\n对指定测试案例的分析将展示该方法在不同条件下的行为：\n1.  **理想情况**：偏差谐波完全包含在拟合基 ($M=3$) 中。预计会发生几乎完美的抵消，$\\mathrm{RMSE}_{\\mathrm{after}} \\approx 0$。\n2.  **零偏差**：当 $B(\\phi) = 0$ 时，$V^{\\mathrm{corr}}(\\phi)$ 的所有系数都将为零。两个 RMSE 值都将为零。\n3.  **欠拟合**：偏差包含拟合基 ($M=3$)之外的谐波 ($m=4, 6$)。该过程将只拟合偏差中投影到 $m \\le 3$ 基上的分量。由于正交性，这只会是常数项 ($m=0$)。$\\mathrm{RMSE}_{\\mathrm{after}}$ 将为非零但小于 $\\mathrm{RMSE}_{\\mathrm{before}}$，因为偏差的平均值已被移除。\n4.  **含噪声偏差**：底层信号在拟合基内，但被随机噪声破坏。拟合将逼近信号，而剩余误差 $B_{\\mathrm{corr}}(\\phi)$ 将主要由低阶傅里叶级数无法捕捉的高频噪声主导。$\\mathrm{RMSE}_{\\mathrm{after}}$ 预计会接近噪声的标准差 $\\sigma$。\n\n现在，实现将继续为给定的测试案例计算这些量。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_correction(bias_terms, M, N, noise_sigma, seed=None):\n    \"\"\"\n    Calculates and applies a torsional bias correction.\n\n    Args:\n        bias_terms (list): A list of tuples (m, U_m, psi_m) defining the bias potential.\n        M (int): The maximum harmonic order for the correction potential fit.\n        N (int): The number of sample points for the angle phi.\n        noise_sigma (float): The standard deviation of Gaussian noise to add to the bias.\n        seed (int, optional): A seed for the random number generator for reproducibility.\n\n    Returns:\n        tuple: A tuple containing (RMSE_before, RMSE_after) in kcal/mol.\n    \"\"\"\n    # 1. Generate the angle grid and the bias potential B(phi)\n    phi = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    \n    B_phi = np.zeros(N)\n    for m, U_m, psi_m in bias_terms:\n        B_phi += (U_m / 2.0) * (1 + np.cos(m * phi - psi_m))\n\n    # Add optional noise\n    if noise_sigma > 0.0:\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(0, noise_sigma, N)\n        B_phi += noise\n        \n    # 2. Compute RMSE_before\n    rmse_before = np.sqrt(np.mean(B_phi**2))\n\n    # 3. Determine coefficients for V_corr(phi) using FFT\n    # This is equivalent to the least-squares fit for a uniform grid\n    coeffs_fft = np.fft.rfft(B_phi)\n\n    c0 = coeffs_fft[0] / N\n    a = 2 * coeffs_fft[1:M+1].real / N\n    b = -2 * coeffs_fft[1:M+1].imag / N\n\n    # 4. Construct the correction potential V_corr(phi)\n    V_corr_phi = np.full(N, c0)\n    for m_idx, m_val in enumerate(range(1, M + 1)):\n        V_corr_phi += a[m_idx] * np.cos(m_val * phi) + b[m_idx] * np.sin(m_val * phi)\n        \n    # 5. Compute the corrected residual and RMSE_after\n    B_corr_phi = B_phi - V_corr_phi\n    rmse_after = np.sqrt(np.mean(B_corr_phi**2))\n\n    return rmse_before, rmse_after\n\ndef solve():\n    \"\"\"\n    Runs the full test suite for the torsional bias correction problem.\n    \"\"\"\n    N = 360 # Number of sample points\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path\n        {\"bias_terms\": [(1, 0.6, np.pi/6), (3, 0.4, -np.pi/3)], \"M\": 3, \"noise_sigma\": 0.0},\n        # 2. Zero-bias boundary case\n        {\"bias_terms\": [], \"M\": 3, \"noise_sigma\": 0.0},\n        # 3. Underfitting edge case\n        {\"bias_terms\": [(6, 0.5, np.pi/8), (4, 0.3, np.pi/3)], \"M\": 3, \"noise_sigma\": 0.0},\n        # 4. Noisy bias case\n        {\"bias_terms\": [(2, 0.5, np.pi/4), (1, 0.3, -np.pi/6)], \"M\": 3, \"noise_sigma\": 0.05, \"seed\": 42}\n    ]\n\n    results = []\n    for case in test_cases:\n        rmse_before, rmse_after = calculate_correction(\n            bias_terms=case[\"bias_terms\"],\n            M=case[\"M\"],\n            N=N,\n            noise_sigma=case[\"noise_sigma\"],\n            seed=case.get(\"seed\")\n        )\n        results.extend([rmse_before, rmse_after])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何近似方法的价值最终取决于其准确性。在完成了QM/MM模型的构建和修正后，我们必须进行严格的验证，以确保其能够可靠地模拟真实的全量子力学系统。这项实践将引导你建立一个正式的验证流程，通过将QM/MM计算得到的能量和原子间作用力与“金标准”的全QM计算结果进行比较，并使用明确的误差度量（能量偏差和力的均方根偏差）来评估模型的可靠性 。",
            "id": "3731100",
            "problem": "您的任务是为一种采用连接原子的加和式量子力学/分子力学 (QM/MM) 方案构建一个验证协议，该协议通过在一系列边界切割上，将计算值与参考的全量子力学 (full-QM) 值进行比较来实现。其目的是利用基于第一性原理的能量和力差异，为每次切割确定接受标准。您将实现一个程序，根据定义的容差评估每次切割是否通过验证。\n\n基本原理和定义：\n- 来自量子力学 (QM) 的势能是一个标量可观测量，用 $E$ 表示。原子上的力由势能相对于原子核坐标的负梯度给出，即 $\\mathbf{F}_i = -\\nabla_{\\mathbf{R}_i} E$，其中 $\\mathbf{R}_i \\in \\mathbb{R}^3$ 是原子 $i$ 的位置矢量，$\\mathbf{F}_i \\in \\mathbb{R}^3$。\n- 在一个使用连接原子的加和式量子力学/分子力学 (QM/MM) 方案中，您需要在一个固定的几何构型下近似计算体系的总能量和力。为了进行验证，您需要将这些值与在相同几何构型和基组下进行的全量子力学 (full-QM) 计算结果进行比较。\n- 对于给定的切割 $k$，验证过程必须计算两个误差度量：\n  1. 能量偏差：$\\Delta E_k = \\left| E_k^{\\mathrm{QMMM}} - E_k^{\\mathrm{QM}} \\right|$。\n  2. 均方根力偏差：\n  $$\\mathrm{RMSF}_k = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}} \\right\\|_2^2},$$\n  其中 $N$ 是进行力比较的原子数量，$\\|\\cdot\\|_2$ 表示欧几里得范数。\n- 每次切割 $k$ 的接受标准：当且仅当 $\\Delta E_k \\le \\tau_E$ 且 $\\mathrm{RMSF}_k \\le \\tau_F$ 时，该切割被接受，容差如下：\n  - 能量容差 $\\tau_E = 0.001$ Hartree (Ha)。\n  - 力容差 $\\tau_F = 0.005$ Hartree每Bohr (Ha/Bohr)。\n- 单位：所有能量必须以Hartree (Ha)为单位，所有力必须以Hartree每Bohr (Ha/Bohr)为单位。您的程序的输出是无量纲的布尔值，因此没有单位，但数值输入和阈值遵循所提供的单位规范。\n\n测试套件：\n给定一组包含4次切割（边界位置）的数据，其中包括针对一个具有 $N=3$ 个原子的固定原子几何构型的全QM和连接原子QM/MM计算结果。对于所有切割 $k \\in \\{1,2,3,4\\}$，每个原子的全QM力是相同的，并且等于零（几何构型处于或接近一个驻点）：\n\n- 所有切割的通用全QM力：\n  - $\\mathbf{F}_{k,1}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{F}_{k,2}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$,\n  - $\\mathbf{F}_{k,3}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$.\n\n对于每次切割 $k$，为您提供：\n- 全QM能量 $E_k^{\\mathrm{QM}}$，单位为Hartree (Ha)。\n- 连接原子QM/MM能量 $E_k^{\\mathrm{QMMM}}$，单位为Hartree (Ha)。\n- 同样 $N=3$ 个原子上的连接原子QM/MM力，单位为Hartree每Bohr (Ha/Bohr)。\n\n切割如下：\n\n- 切割 1：\n  - $E_1^{\\mathrm{QM}} = -76.4200$, $E_1^{\\mathrm{QMMM}} = -76.4196$.\n  - $\\mathbf{F}_{1,1}^{\\mathrm{QMMM}} = (0.003, 0.000, 0.000)$,\n    $\\mathbf{F}_{1,2}^{\\mathrm{QMMM}} = (-0.003, 0.000, 0.000)$,\n    $\\mathbf{F}_{1,3}^{\\mathrm{QMMM}} = (0.000, 0.003, 0.000)$.\n\n- 切割 2：\n  - $E_2^{\\mathrm{QM}} = -76.4200$, $E_2^{\\mathrm{QMMM}} = -76.4190$.\n  - $\\mathbf{F}_{2,1}^{\\mathrm{QMMM}} = (0.005, 0.000, 0.000)$,\n    $\\mathbf{F}_{2,2}^{\\mathrm{QMMM}} = (0.000, 0.005, 0.000)$,\n    $\\mathbf{F}_{2,3}^{\\mathrm{QMMM}} = (0.000, 0.000, -0.005)$.\n\n- 切割 3：\n  - $E_3^{\\mathrm{QM}} = -76.4200$, $E_3^{\\mathrm{QMMM}} = -76.4188$.\n  - $\\mathbf{F}_{3,1}^{\\mathrm{QMMM}} = (0.003, 0.000, 0.000)$,\n    $\\mathbf{F}_{3,2}^{\\mathrm{QMMM}} = (0.000, -0.003, 0.000)$,\n    $\\mathbf{F}_{3,3}^{\\mathrm{QMMM}} = (0.000, 0.000, 0.003)$.\n\n- 切割 4：\n  - $E_4^{\\mathrm{QM}} = -76.4200$, $E_4^{\\mathrm{QMMM}} = -76.4198$.\n  - $\\mathbf{F}_{4,1}^{\\mathrm{QMMM}} = (0.006, 0.000, 0.000)$,\n    $\\mathbf{F}_{4,2}^{\\mathrm{QMMM}} = (0.000, -0.006, 0.000)$,\n    $\\mathbf{F}_{4,3}^{\\mathrm{QMMM}} = (0.000, 0.000, 0.006)$.\n\n您的任务：\n- 实现一个程序，对于每次切割 $k$，使用上述定义计算 $\\Delta E_k$ 和 $\\mathrm{RMSF}_k$，用给定的容差检查接受标准，并为每次切割返回一个表示是否接受的布尔值。\n- 最终输出格式：您的程序应生成单行输出，其中包含切割1到4的接受结果，形式为方括号内由逗号分隔的列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}]$。布尔值必须是编程语言的原生布尔格式，并按指定顺序排列。\n\n关于数值鲁棒性的说明：\n- 当将浮点数量与容差进行比较时，评估是否 $\\Delta E_k \\le \\tau_E$ 且 $\\mathrm{RMSF}_k \\le \\tau_F$。为缓解在接近相等时的浮点舍入误差，您可以将比较视为 $\\Delta E_k \\le \\tau_E + \\epsilon$ 和 $\\mathrm{RMSF}_k \\le \\tau_F + \\epsilon$，其中 $\\epsilon$ 是一个小的正数，例如 $\\epsilon = 10^{-12}$ (无量纲)。",
            "solution": "用户提供了一个问题陈述，在尝试解决方案之前需要对其进行验证。\n\n### 步骤1：提取已知条件\n\n问题陈述中提供了以下数据和定义：\n\n*   **可观测量和定义**：\n    *   来自量子力学 (QM) 的势能用 $E$ 表示。\n    *   原子 $i$ 上的力由势能的负梯度给出：$\\mathbf{F}_i = -\\nabla_{\\mathbf{R}_i} E$，其中 $\\mathbf{R}_i \\in \\mathbb{R}^3$ 是原子 $i$ 的位置。\n    *   切割 $k$ 的能量偏差为 $\\Delta E_k = \\left| E_k^{\\mathrm{QMMM}} - E_k^{\\mathrm{QM}} \\right|$。\n    *   切割 $k$ 的均方根力偏差为 $\\mathrm{RMSF}_k = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}} \\right\\|_2^2}$。\n    *   用于力比较的原子数为 $N = 3$。\n\n*   **接受标准**：\n    *   切割 $k$ 被接受当且仅当 $\\Delta E_k \\le \\tau_E$ 且 $\\mathrm{RMSF}_k \\le \\tau_F$。\n    *   能量容差：$\\tau_E = 0.001$ Hartree (Ha)。\n    *   力容差：$\\tau_F = 0.005$ Hartree每Bohr (Ha/Bohr)。\n\n*   **测试套件数据（$N=3$个原子）**：\n    *   所有切割 $k \\in \\{1,2,3,4\\}$ 的通用全QM力：$\\mathbf{F}_{k,1}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$，$\\mathbf{F}_{k,2}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$，$\\mathbf{F}_{k,3}^{\\mathrm{QM}} = (0.0, 0.0, 0.0)$。\n    *   **切割 1**：\n        *   $E_1^{\\mathrm{QM}} = -76.4200$ Ha, $E_1^{\\mathrm{QMMM}} = -76.4196$ Ha.\n        *   $\\mathbf{F}_{1,1}^{\\mathrm{QMMM}} = (0.003, 0.000, 0.000)$ Ha/Bohr, $\\mathbf{F}_{1,2}^{\\mathrm{QMMM}} = (-0.003, 0.000, 0.000)$ Ha/Bohr, $\\mathbf{F}_{1,3}^{\\mathrm{QMMM}} = (0.000, 0.003, 0.000)$ Ha/Bohr.\n    *   **切割 2**：\n        *   $E_2^{\\mathrm{QM}} = -76.4200$ Ha, $E_2^{\\mathrm{QMMM}} = -76.4190$ Ha.\n        *   $\\mathbf{F}_{2,1}^{\\mathrm{QMMM}} = (0.005, 0.000, 0.000)$ Ha/Bohr, $\\mathbf{F}_{2,2}^{\\mathrm{QMMM}} = (0.000, 0.005, 0.000)$ Ha/Bohr, $\\mathbf{F}_{2,3}^{\\mathrm{QMMM}} = (0.000, 0.000, -0.005)$ Ha/Bohr.\n    *   **切割 3**：\n        *   $E_3^{\\mathrm{QM}} = -76.4200$ Ha, $E_3^{\\mathrm{QMMM}} = -76.4188$ Ha.\n        *   $\\mathbf{F}_{3,1}^{\\mathrm{QMMM}} = (0.003, 0.000, 0.000)$ Ha/Bohr, $\\mathbf{F}_{3,2}^{\\mathrm{QMMM}} = (0.000, -0.003, 0.000)$ Ha/Bohr, $\\mathbf{F}_{3,3}^{\\mathrm{QMMM}} = (0.000, 0.000, 0.003)$ Ha/Bohr.\n    *   **切割 4**：\n        *   $E_4^{\\mathrm{QM}} = -76.4200$ Ha, $E_4^{\\mathrm{QMMM}} = -76.4198$ Ha.\n        *   $\\mathbf{F}_{4,1}^{\\mathrm{QMMM}} = (0.006, 0.000, 0.000)$ Ha/Bohr, $\\mathbf{F}_{4,2}^{\\mathrm{QMMM}} = (0.000, -0.006, 0.000)$ Ha/Bohr, $\\mathbf{F}_{4,3}^{\\mathrm{QMMM}} = (0.000, 0.000, 0.006)$ Ha/Bohr.\n\n*   **数值鲁棒性**：比较应处理为小于或等于容差加上一个小的epsilon，例如 $\\epsilon = 10^{-12}$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n对该问题进行严格验证。\n1.  科学依据：该问题设定在计算化学的既定框架内，特别是多尺度QM/MM建模。势能、力、连接原子以及与更高级别理论（全QM）进行验证的概念都是标准实践。使用原子单位（能量用Hartree，力用Hartree/Bohr）是恰当的。该问题在科学上是合理的。\n2.  良态问题：该问题是良态的。它提供了所有必要的数据、一组清晰的待执行计算和明确的接受标准。存在唯一解且可直接计算。\n3.  客观性：该问题使用精确的数学语言陈述。它没有主观性和模糊性。\n4.  缺陷分析：\n    *   不存在科学或事实上的不合理之处。\n    *   该问题可直接形式化，并与其所述主题高度相关。\n    *   设置是完整的且自洽的。\n    *   对于处于驻点的小分子体系，物理条件和数值是合理的。\n    *   结构清晰，问题不是病态的。\n    *   该任务是已定义原理的直接应用，这是一种有效的科学问题解决方法，而非无聊或故作高深的练习。\n    *   结果可通过计算完全验证。\n\n### 步骤3：结论和行动\n\n该问题有效。将提供一个解决方案。\n\n### 解决方案\n\n目标是通过将四个不同的QM/MM边界切割的计算能量和力与参考的全QM计算结果进行比较，来实现一个验证协议。当且仅当一个切割的能量偏差和其均方根力偏差都落在指定的容差范围内时，该切割才被视为“接受”。\n\n接受标准由每次切割 $k$ 的两个度量定义：\n1.  绝对能量偏差：$\\Delta E_k = \\left| E_k^{\\mathrm{QMMM}} - E_k^{\\mathrm{QM}} \\right|$。这必须满足 $\\Delta E_k \\le \\tau_E$，其中容差 $\\tau_E = 0.001$ Ha。\n2.  均方根力偏差：\n    $$ \\mathrm{RMSF}_k = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}} \\right\\|_2^2} $$\n    这必须满足 $\\mathrm{RMSF}_k \\le \\tau_F$，其中容差 $\\tau_F = 0.005$ Ha/Bohr。\n\n分析针对每个切割中的 $N=3$ 个原子进行。参考的全QM力给定为 $\\mathbf{F}_{k,i}^{\\mathrm{QM}} = \\mathbf{0}$，适用于所有原子和所有切割。这简化了RMSF的计算，因为力的差值 $\\mathbf{F}_{k,i}^{\\mathrm{QMMM}} - \\mathbf{F}_{k,i}^{\\mathrm{QM}}$ 就变成了 $\\mathbf{F}_{k,i}^{\\mathrm{QMMM}}$。\n\n我们现在根据这些标准评估四个切割中的每一个。\n\n**切割 1：**\n*   能量数据：$E_1^{\\mathrm{QM}} = -76.4200$ Ha, $E_1^{\\mathrm{QMMM}} = -76.4196$ Ha.\n    *   $\\Delta E_1 = | -76.4196 - (-76.4200) | = 0.0004$ Ha.\n    *   比较：$0.0004 \\le 0.001$。能量标准已满足。\n*   力数据 ($k=1$)：$\\mathbf{F}_{1,1}^{\\mathrm{QMMM}} = (0.003, 0, 0)$, $\\mathbf{F}_{1,2}^{\\mathrm{QMMM}} = (-0.003, 0, 0)$, $\\mathbf{F}_{1,3}^{\\mathrm{QMMM}} = (0, 0.003, 0)$。所有单位均为 Ha/Bohr。\n    *   力矢量的平方范数：\n        *   $\\|\\mathbf{F}_{1,1}^{\\mathrm{QMMM}}\\|_2^2 = (0.003)^2 + 0^2 + 0^2 = 0.000009$。\n        *   $\\|\\mathbf{F}_{1,2}^{\\mathrm{QMMM}}\\|_2^2 = (-0.003)^2 + 0^2 + 0^2 = 0.000009$。\n        *   $\\|\\mathbf{F}_{1,3}^{\\mathrm{QMMM}}\\|_2^2 = 0^2 + (0.003)^2 + 0^2 = 0.000009$。\n    *   $\\mathrm{RMSF}_1 = \\sqrt{\\frac{1}{3} (0.000009 + 0.000009 + 0.000009)} = \\sqrt{\\frac{0.000027}{3}} = \\sqrt{0.000009} = 0.003$ Ha/Bohr。\n    *   比较：$0.003 \\le 0.005$。力标准已满足。\n*   **切割1的结论**：两个标准均已满足。该切割被**接受**。\n\n**切割 2：**\n*   能量数据：$E_2^{\\mathrm{QM}} = -76.4200$ Ha, $E_2^{\\mathrm{QMMM}} = -76.4190$ Ha.\n    *   $\\Delta E_2 = | -76.4190 - (-76.4200) | = 0.0010$ Ha.\n    *   比较：$0.0010 \\le 0.001$。能量标准已满足（等于容差）。\n*   力数据 ($k=2$)：$\\mathbf{F}_{2,1}^{\\mathrm{QMMM}} = (0.005, 0, 0)$, $\\mathbf{F}_{2,2}^{\\mathrm{QMMM}} = (0, 0.005, 0)$, $\\mathbf{F}_{2,3}^{\\mathrm{QMMM}} = (0, 0, -0.005)$。\n    *   力矢量的平方范数：\n        *   $\\|\\mathbf{F}_{2,1}^{\\mathrm{QMMM}}\\|_2^2 = (0.005)^2 = 0.000025$。\n        *   $\\|\\mathbf{F}_{2,2}^{\\mathrm{QMMM}}\\|_2^2 = (0.005)^2 = 0.000025$。\n        *   $\\|\\mathbf{F}_{2,3}^{\\mathrm{QMMM}}\\|_2^2 = (-0.005)^2 = 0.000025$。\n    *   $\\mathrm{RMSF}_2 = \\sqrt{\\frac{1}{3} (0.000025 + 0.000025 + 0.000025)} = \\sqrt{\\frac{0.000075}{3}} = \\sqrt{0.000025} = 0.005$ Ha/Bohr。\n    *   比较：$0.005 \\le 0.005$。力标准已满足（等于容差）。\n*   **切割2的结论**：两个标准均已满足。该切割被**接受**。\n\n**切割 3：**\n*   能量数据：$E_3^{\\mathrm{QM}} = -76.4200$ Ha, $E_3^{\\mathrm{QMMM}} = -76.4188$ Ha.\n    *   $\\Delta E_3 = | -76.4188 - (-76.4200) | = 0.0012$ Ha.\n    *   比较：$0.0012 > 0.001$。能量标准**未**满足。\n*   **切割3的结论**：由于一个标准未通过，整个切割被**拒绝**。无需评估力标准。\n\n**切割 4：**\n*   能量数据：$E_4^{\\mathrm{QM}} = -76.4200$ Ha, $E_4^{\\mathrm{QMMM}} = -76.4198$ Ha.\n    *   $\\Delta E_4 = | -76.4198 - (-76.4200) | = 0.0002$ Ha.\n    *   比较：$0.0002 \\le 0.001$。能量标准已满足。\n*   力数据 ($k=4$)：$\\mathbf{F}_{4,1}^{\\mathrm{QMMM}} = (0.006, 0, 0)$, $\\mathbf{F}_{4,2}^{\\mathrm{QMMM}} = (0, -0.006, 0)$, $\\mathbf{F}_{4,3}^{\\mathrm{QMMM}} = (0, 0, 0.006)$。\n    *   力矢量的平方范数：\n        *   $\\|\\mathbf{F}_{4,1}^{\\mathrm{QMMM}}\\|_2^2 = (0.006)^2 = 0.000036$。\n        *   $\\|\\mathbf{F}_{4,2}^{\\mathrm{QMMM}}\\|_2^2 = (-0.006)^2 = 0.000036$。\n        *   $\\|\\mathbf{F}_{4,3}^{\\mathrm{QMMM}}\\|_2^2 = (0.006)^2 = 0.000036$。\n    *   $\\mathrm{RMSF}_4 = \\sqrt{\\frac{1}{3} (3 \\times 0.000036)} = \\sqrt{0.000036} = 0.006$ Ha/Bohr。\n    *   比较：$0.006 > 0.005$。力标准**未**满足。\n*   **切割4的结论**：由于力标准未通过，整个切割被**拒绝**。\n\n最终结果摘要：\n*   切割 1：接受 (True)\n*   切割 2：接受 (True)\n*   切割 3：拒绝 (False)\n*   切割 4：拒绝 (False)\n程序将形式化这些计算并生成最终的布尔值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Validates a set of QM/MM cuts against full-QM reference data based on\n    energy and force deviation criteria.\n    \"\"\"\n    # Define the acceptance criteria tolerances.\n    # Energy tolerance tau_E in Hartree (Ha).\n    tau_E = 0.001\n    # Force tolerance tau_F in Hartree per Bohr (Ha/Bohr).\n    tau_F = 0.005\n    \n    # Number of atoms for force comparison.\n    N_atoms = 3\n    \n    # Epsilon for robust floating-point comparisons, as suggested.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E_QM, E_QMMM, list_of_F_QMMM_vectors).\n    # Since F_QM is zero for all atoms in all cuts, it is not stored here\n    # but is accounted for in the calculation.\n    test_cases = [\n        # Cut 1\n        (-76.4200, -76.4196, [\n            np.array([0.003, 0.000, 0.000]),\n            np.array([-0.003, 0.000, 0.000]),\n            np.array([0.000, 0.003, 0.000])\n        ]),\n        # Cut 2\n        (-76.4200, -76.4190, [\n            np.array([0.005, 0.000, 0.000]),\n            np.array([0.000, 0.005, 0.000]),\n            np.array([0.000, 0.000, -0.005])\n        ]),\n        # Cut 3\n        (-76.4200, -76.4188, [\n            np.array([0.003, 0.000, 0.000]),\n            np.array([0.000, -0.003, 0.000]),\n            np.array([0.000, 0.000, 0.003])\n        ]),\n        # Cut 4\n        (-76.4200, -76.4198, [\n            np.array([0.006, 0.000, 0.000]),\n            np.array([0.000, -0.006, 0.000]),\n            np.array([0.000, 0.000, 0.006])\n        ])\n    ]\n\n    results = []\n    # Full-QM reference forces are zero vectors.\n    F_QM_ref = np.array([0.0, 0.0, 0.0])\n\n    for case in test_cases:\n        E_QM, E_QMMM, Fs_QMMM = case\n\n        # 1. Calculate energy deviation (Delta E)\n        delta_E = abs(E_QMMM - E_QM)\n\n        # 2. Calculate Root-Mean-Square Force deviation (RMSF)\n        # The sum of squared norms of force differences.\n        sum_sq_force_diff = 0.0\n        for F_QMMM_i in Fs_QMMM:\n            # Force difference is F_QMMM - F_QM. Since F_QM is zero, this is just F_QMMM.\n            force_diff = F_QMMM_i - F_QM_ref\n            # Add the squared Euclidean norm to the sum.\n            sum_sq_force_diff += np.linalg.norm(force_diff)**2\n        \n        rmsf = np.sqrt(sum_sq_force_diff / N_atoms)\n\n        # 3. Apply acceptance criteria\n        # Check if Delta E is within tolerance.\n        energy_accepted = (delta_E <= tau_E + epsilon)\n        # Check if RMSF is within tolerance.\n        force_accepted = (rmsf <= tau_F + epsilon)\n\n        # A cut is accepted if and only if both criteria are met.\n        cut_accepted = energy_accepted and force_accepted\n        results.append(cut_accepted)\n\n    # Final print statement in the exact required format: [True,False,True,True]\n    # The map(str, ...) converts Python booleans (True, False) to their string\n    # representations (\"True\", \"False\").\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}