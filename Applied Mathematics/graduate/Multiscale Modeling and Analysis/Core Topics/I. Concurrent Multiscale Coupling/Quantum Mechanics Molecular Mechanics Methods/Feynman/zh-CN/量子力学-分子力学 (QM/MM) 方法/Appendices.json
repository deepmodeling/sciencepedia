{
    "hands_on_practices": [
        {
            "introduction": "要深刻理解可极化QM/MM方法，关键在于掌握量子区域如何通过其电场使经典环境极化。该练习将此复杂问题简化为一个核心的静电学模型，让您能够通过解析推导来求解诱导偶极矩和极化能。通过这种方式，您可以亲手处理自洽场方程，从而清晰地揭示可极化相互作用的内在物理机制。",
            "id": "3799184",
            "problem": "一个双位点可极化分子力学 (MM) 子系统嵌入在一个量子力学/分子力学 (QM/MM) 多尺度模型中，其中量子力学 (QM) 区域由单个点电荷表示。两个 MM 可极化位点分别位于 $z$ 轴上的 $z=+a$ 和 $z=-a$ 位置，具有相同的各向同性极化率 $\\alpha$。QM 区域被一个固定在原点的点电荷 $q$ 所取代。假设真空介电常数为 $\\varepsilon_0$，不存在永久 MM 电荷，没有更高阶的多极子，也没有短程阻尼。所有相互作用都纯粹是经典静电学和线性极化。\n\n使用以下基本原理：\n- 点电荷电场的库仑定律：位于原点的电荷 $q$ 在位置 $\\mathbf{r}$ 处产生的电场为 $\\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r})=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q\\,\\hat{\\mathbf{r}}}{r^2}$。\n- 位于原点的点偶极子 $\\boldsymbol{\\mu}$ 产生的电场为 $\\mathbf{E}_{\\mathrm{dip}}(\\mathbf{r})=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{3(\\boldsymbol{\\mu}\\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}-\\boldsymbol{\\mu}}{r^3}$。\n- 各向同性位点的线性极化率：位点 $i$ 处的感生偶极子为 $\\boldsymbol{\\mu}_i=\\alpha\\,\\mathbf{E}_{\\mathrm{loc},i}$，其中 $\\mathbf{E}_{\\mathrm{loc},i}$ 是位点 $i$ 处的局域场。\n- 外电场中 $N$ 个各向同性可极化点偶极子的极化能泛函为\n$$\nU_{\\mathrm{pol}}(\\{\\boldsymbol{\\mu}_i\\})=\\sum_{i=1}^{N}\\frac{1}{2\\alpha}\\,|\\boldsymbol{\\mu}_i|^2-\\sum_{i=1}^{N}\\boldsymbol{\\mu}_i\\cdot \\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r}_i)-\\frac{1}{2}\\sum_{i\\neq j}\\boldsymbol{\\mu}_i\\cdot \\mathbf{T}_{ij}\\cdot \\boldsymbol{\\mu}_j,\n$$\n其中 $\\mathbf{T}_{ij}$ 是从 $\\mathbf{E}_{\\mathrm{dip}}$ 推导出的偶极-偶极相互作用张量。\n\n鉴于沿 $z$ 轴的共线几何构型，您可以仅关注 $z$ 分量，并通过张量的标量 $zz$ 分量 $T_{zz}(r)=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{2}{r^3}$ 来处理偶极-偶极耦合，其中两个位点沿 $z$ 轴相距为 $r$。\n\n任务：\n1. 从能量泛函和上述定义出发，推导两个 MM 位点处感生偶极子的自洽方程（用 $z$ 分量表示，即 $z=+a$ 处的 $\\mu_1$ 和 $z=-a$ 处的 $\\mu_2$）。求解这些方程，得到 $\\mu_1$ 和 $\\mu_2$ 的闭合形式解。\n2. 计算稳态解下的极化能。以闭合形式给出结果，并通过证明其与二次能量泛函的稳态性质一致来验证结果。\n3. 将 $\\mu_1$、$\\mu_2$ 和 $U_{\\mathrm{pol}}$ 的最终结果完全用 $q$、$a$、$\\alpha$ 和 $\\varepsilon_0$ 表示，并使用国际单位制。感生偶极子以库仑-米为单位，能量以焦耳为单位。无需进行数值四舍五入。在最终答案中，将这三个量作为一个单行矩阵一起呈现。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且客观的。它提出了一个经典静电学中的标准问题，与多尺度建模相关，特别是可极化的量子力学/分子力学 (QM/MM) 方法。所有必要信息均已提供，设置是自洽且无矛盾的。因此，该问题被认为是有效的，并将构建一个解决方案。\n\n系统由两个可极化位点组成，标记为 $1$ 和 $2$，分别位于位置 $\\mathbf{r}_1 = a\\hat{\\mathbf{z}}$ 和 $\\mathbf{r}_2 = -a\\hat{\\mathbf{z}}$。两个位点都具有相同的各向同性极化率 $\\alpha$。一个点电荷 $q$ 位于原点 $\\mathbf{r}_q = \\mathbf{0}$。由于沿 $z$ 轴的共线排列，感生偶极矩 $\\boldsymbol{\\mu}_1, \\boldsymbol{\\mu}_2$ 和电场将与 $z$ 轴对齐。因此，我们可以将所有矢量视为表示其 $z$ 分量的标量。设 $\\mu_1$ 和 $\\mu_2$ 为位点 $1$ 和 $2$ 处感生偶极矩的标量 $z$ 分量。\n\n首先，我们确定由电荷 $q$ 在每个位点产生的外部电场 $E_{\\mathrm{ext}}$。来自原点处点电荷 $q$ 的电场为 $\\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r})=\\dfrac{q}{4\\pi \\varepsilon_0 r^2}\\hat{\\mathbf{r}}$。\n在位点 $1$ ($\\mathbf{r}_1 = a\\hat{\\mathbf{z}}$) 处，位置矢量为 $\\mathbf{r}=a\\hat{\\mathbf{z}}$，因此 $r=a$ 且 $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$。场的 $z$ 分量为：\n$$\nE_{\\mathrm{ext},1} = \\frac{q}{4\\pi \\varepsilon_0 a^2}\n$$\n在位点 $2$ ($\\mathbf{r}_2 = -a\\hat{\\mathbf{z}}$) 处，位置矢量为 $\\mathbf{r}=-a\\hat{\\mathbf{z}}$，因此 $r=a$ 且 $\\hat{\\mathbf{r}}=-\\hat{\\mathbf{z}}$。场的 $z$ 分量为：\n$$\nE_{\\mathrm{ext},2} = \\frac{q}{4\\pi \\varepsilon_0 a^2}(-1) = -\\frac{q}{4\\pi \\varepsilon_0 a^2}\n$$\n根据对称性，我们注意到 $E_{\\mathrm{ext},2} = -E_{\\mathrm{ext},1}$。为简单起见，我们定义 $E_0 = \\frac{q}{4\\pi \\varepsilon_0 a^2}$，因此 $E_{\\mathrm{ext},1} = E_0$ 且 $E_{\\mathrm{ext},2} = -E_0$。\n\n接下来，我们建立两个感生偶极子之间的相互作用。两个位点之间的距离为 $r=a - (-a) = 2a$。问题指定了共线构型下偶极-偶极相互作用张量的标量 $zz$ 分量为 $T_{zz}(r)=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{2}{r^3}$。对于我们的系统，这个标量相互作用常数，我们称之为 $T$，是：\n$$\nT = T_{zz}(2a) = \\frac{1}{4\\pi \\varepsilon_0}\\frac{2}{(2a)^3} = \\frac{1}{4\\pi \\varepsilon_0}\\frac{2}{8a^3} = \\frac{1}{16\\pi \\varepsilon_0 a^3}\n$$\n位点 $2$ 处的偶极子 $\\mu_2$ 在位点 $1$ 处产生的场为 $E_{\\mathrm{ind},1} = T \\mu_2$。类似地，位点 $1$ 处的偶极子 $\\mu_1$ 在位点 $2$ 处产生的场为 $E_{\\mathrm{ind},2} = T \\mu_1$。\n\n每个位点处的总局域电场是外部电场和来自另一个感生偶极子的场的总和。\n$$\nE_{\\mathrm{loc},1} = E_{\\mathrm{ext},1} + E_{\\mathrm{ind},1} = E_0 + T \\mu_2\n$$\n$$\nE_{\\mathrm{loc},2} = E_{\\mathrm{ext},2} + E_{\\mathrm{ind},2} = -E_0 + T \\mu_1\n$$\n\n**任务1：推导并求解 $\\mu_1$ 和 $\\mu_2$ 的自洽方程**\n\n自洽方程源于线性极化率关系 $\\mu_i = \\alpha E_{\\mathrm{loc},i}$。\n$$\n\\mu_1 = \\alpha (E_0 + T \\mu_2)\n$$\n$$\n\\mu_2 = \\alpha (-E_0 + T \\mu_1)\n$$\n这些方程也可以通过最小化极化能泛函 $U_{\\mathrm{pol}}(\\mu_1, \\mu_2)$ （分别对 $\\mu_1$ 和 $\\mu_2$ 求导）来推导。该系统的泛函为：\n$$\nU_{\\mathrm{pol}}(\\mu_1, \\mu_2) = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\mu_1 E_{\\mathrm{ext},1} - \\mu_2 E_{\\mathrm{ext},2} - \\mu_1 T \\mu_2\n$$\n对 $\\mu_1$ 进行最小化：\n$$\n\\frac{\\partial U_{\\mathrm{pol}}}{\\partial \\mu_1} = \\frac{\\mu_1}{\\alpha} - E_{\\mathrm{ext},1} - T \\mu_2 = 0 \\implies \\mu_1 = \\alpha(E_{\\mathrm{ext},1} + T\\mu_2)\n$$\n对 $\\mu_2$ 进行最小化：\n$$\n\\frac{\\partial U_{\\mathrm{pol}}}{\\partial \\mu_2} = \\frac{\\mu_2}{\\alpha} - E_{\\mathrm{ext},2} - T \\mu_1 = 0 \\implies \\mu_2 = \\alpha(E_{\\mathrm{ext},2} + T\\mu_1)\n$$\n这些方程与从局域场定义推导出的方程相同。\n\n我们现在求解这个二元线性方程组：\n1. $\\mu_1 - \\alpha T \\mu_2 = \\alpha E_0$\n2. $-\\alpha T \\mu_1 + \\mu_2 = -\\alpha E_0$\n\n从问题的对称性 ($E_{\\mathrm{ext},2} = -E_{\\mathrm{ext},1}$) 可以推断出 $\\mu_2 = -\\mu_1$。将此代入第一个方程：\n$$\n\\mu_1 - \\alpha T (-\\mu_1) = \\alpha E_0 \\implies \\mu_1(1 + \\alpha T) = \\alpha E_0\n$$\n$$\n\\mu_1 = \\frac{\\alpha E_0}{1 + \\alpha T}\n$$\n因此，$\\mu_2 = -\\mu_1 = -\\frac{\\alpha E_0}{1 + \\alpha T}$。我们可以通过代入第二个方程来验证其一致性：\n$$\n-\\alpha T (\\frac{\\alpha E_0}{1 + \\alpha T}) + (-\\frac{\\alpha E_0}{1 + \\alpha T}) = -\\alpha E_0 \\implies \\frac{-\\alpha^2 T E_0 - \\alpha E_0}{1+\\alpha T} = -\\alpha E_0 \\implies -\\alpha E_0 \\frac{\\alpha T + 1}{1+\\alpha T} = -\\alpha E_0\n$$\n解是一致的。\n\n现在代入 $E_0$ 和 $T$ 的表达式：\n$$\n1 + \\alpha T = 1 + \\alpha \\left(\\frac{1}{16\\pi \\varepsilon_0 a^3}\\right) = \\frac{16\\pi \\varepsilon_0 a^3 + \\alpha}{16\\pi \\varepsilon_0 a^3}\n$$\n$$\n\\mu_1 = \\frac{\\alpha \\left(\\frac{q}{4\\pi \\varepsilon_0 a^2}\\right)}{\\frac{16\\pi \\varepsilon_0 a^3 + \\alpha}{16\\pi \\varepsilon_0 a^3}} = \\frac{\\alpha q}{4\\pi \\varepsilon_0 a^2} \\frac{16\\pi \\varepsilon_0 a^3}{16\\pi \\varepsilon_0 a^3 + \\alpha} = \\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha}\n$$\n偶极矩的解是：\n$$\n\\mu_1 = \\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha} \\quad \\text{和} \\quad \\mu_2 = -\\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha}\n$$\n\n**任务2：计算极化能 $U_{\\mathrm{pol}}$**\n\n问题要求计算稳态解下的极化能并对其进行验证。对于形式为 $U(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^T \\mathbf{A} \\mathbf{x} - \\mathbf{x}^T \\mathbf{b}$ 的二次能量泛函，稳态点 $\\mathbf{x}_{\\mathrm{sol}}$ 满足 $\\mathbf{A}\\mathbf{x}_{\\mathrm{sol}} = \\mathbf{b}$，该点的能量为 $U(\\mathbf{x}_{\\mathrm{sol}}) = -\\frac{1}{2}\\mathbf{x}_{\\mathrm{sol}}^T \\mathbf{b}$。在我们的问题中，$\\mathbf{x} \\equiv (\\mu_1, \\mu_2)^T$ 且 $\\mathbf{b} \\equiv (E_{\\mathrm{ext},1}, E_{\\mathrm{ext},2})^T$。因此，稳态能量为：\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2})\n$$\n这就是所要求的验证。我们可以通过直接代入完整的能量泛函来确认这一点：\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - (\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2}) - \\mu_1 T \\mu_2\n$$\n使用 $E_{\\mathrm{ext},1} = \\frac{\\mu_1}{\\alpha} - T\\mu_2$ 和 $E_{\\mathrm{ext},2} = \\frac{\\mu_2}{\\alpha} - T\\mu_1$：\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\left(\\mu_1(\\frac{\\mu_1}{\\alpha} - T\\mu_2) + \\mu_2(\\frac{\\mu_2}{\\alpha} - T\\mu_1)\\right) - \\mu_1 T \\mu_2\n$$\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\frac{1}{\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2 + \\mu_2 T \\mu_1 - \\mu_1 T \\mu_2\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2\n$$\n现在，与 $-\\frac{1}{2}(\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2}) = -\\frac{1}{2}\\left(\\mu_1(\\frac{\\mu_1}{\\alpha} - T\\mu_2) + \\mu_2(\\frac{\\mu_2}{\\alpha} - T\\mu_1)\\right) = -\\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2$ 比较。表达式相同，证实了稳态性质。\n\n现在我们使用更简单的形式计算 $U_{\\mathrm{pol}}$ 的值：\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_0 + \\mu_2 (-E_0)) = -\\frac{1}{2}(\\mu_1 E_0 - \\mu_2 E_0)\n$$\n代入 $\\mu_2 = -\\mu_1$：\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_0 - (-\\mu_1) E_0) = -\\frac{1}{2}(2\\mu_1 E_0) = -\\mu_1 E_0\n$$\n代入 $\\mu_1$ 和 $E_0$ 的表达式：\n$$\nU_{\\mathrm{pol}} = -\\left(\\frac{\\alpha E_0}{1 + \\alpha T}\\right) E_0 = -\\frac{\\alpha E_0^2}{1 + \\alpha T}\n$$\n现在用基本常数表示：\n$$\nE_0^2 = \\left(\\frac{q}{4\\pi \\varepsilon_0 a^2}\\right)^2 = \\frac{q^2}{16\\pi^2 \\varepsilon_0^2 a^4}\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha \\frac{q^2}{16\\pi^2 \\varepsilon_0^2 a^4}}{1 + \\frac{\\alpha}{16\\pi \\varepsilon_0 a^3}} = -\\frac{\\alpha q^2}{16\\pi^2 \\varepsilon_0^2 a^4} \\left(\\frac{16\\pi \\varepsilon_0 a^3}{16\\pi \\varepsilon_0 a^3 + \\alpha}\\right)\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)}\n$$\n\n**任务3：呈现最终结果**\n\n所要求的量是 $\\mu_1, \\mu_2$ 和 $U_{\\mathrm{pol}}$，用 $q, a, \\alpha$ 和 $\\varepsilon_0$ 表示。\n$$\n\\mu_1 = \\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}\n$$\n$$\n\\mu_2 = -\\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)}\n$$\n这些结果是以最终的闭合形式给出的，使用了规定的常数。根据量纲分析，偶极子的单位是库仑-米，能量的单位是焦耳。",
            "answer": "$$ \\boxed{\\begin{pmatrix} \\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha} & -\\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha} & -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)} \\end{pmatrix}} $$"
        },
        {
            "introduction": "在任何QM/MM模拟中，嵌入方案的选择都是一个至关重要的决策，它直接决定了量子区域与分子力学环境的耦合方式。本练习将提供一个具体的计算实践，让您比较机械嵌入和静电嵌入两种方案对分子几何构型优化的影响。通过这个过程，您将直观地看到不同的理论模型如何改变势能面，从而影响最终的计算结果，这对于理解和评判QM/MM计算的可靠性至关重要。",
            "id": "3799213",
            "problem": "你需要实现一个数值优化，以分析在量子力学/分子力学 (QM/MM) 方法中嵌入方式的选择如何影响电荷分离中间体的优化几何构型。需要比较的两种嵌入方式是机械嵌入和静电嵌入。该研究必须在玻恩-奥本海默近似和总势能的标准 QM/MM 划分框架下进行。你将把分子处理为一个线性三原子体系，原子标记为 $A$、$B$ 和 $C$，并考虑两个关键键长：$A$ 和 $B$ 之间的 $r_1$，以及 $B$ 和 $C$ 之间的 $r_2$。分析的目标是量化由于量子力学区域与外部自分子力学环境之间存在或不存在静电相互作用而导致的优化后键长 $r_1$ 和 $r_2$ 的变化。\n\n使用的基本原理和定义：\n- 在玻恩-奥本海默近似下，对于固定的原子核位置，电子能量被最小化，原子核在所得的势能面上运动。\n- 在量子力学/分子力学 (QM/MM) 中，总势能被分解为来自量子力学自由度和经典分子力学自由度的贡献，以及它们之间的相互作用项。\n- 在机械嵌入中，量子力学区域不感受来自自分子力学环境的显式静电场；在静电嵌入中，量子力学区域受到自分子力学点电荷产生的外部静电场的影响。\n- 能量和力必须由经过充分检验且具有物理意义的模型定义。所有数学构造必须在科学上合理且一致。\n\n几何和建模假设：\n- 该三原子体系是线性的，沿一条直线的位置为 $x_A = 0$，$x_B = r_1$，以及 $x_C = r_1 + r_2$。\n- 每个键的量子力学能量由一个莫尔斯势表示。键之间存在一个弱交叉耦合，反映了电荷分离中间体中的振动耦合。嵌入方式影响量子力学区域是否与代表分子力学环境的固定点电荷发生静电相互作用。\n\n你的任务：\n1. 对于给定的参数集，定义机械嵌入下的总势能和静电嵌入下的总势能。\n2. 在物理上合理的键长边界条件下，对每个总势能关于键长 $r_1$ 和 $r_2$ 进行数值最小化。\n3. 计算优化后键长的差异，定义为 $\\Delta r_1 = r_{1,\\mathrm{elec}} - r_{1,\\mathrm{mech}}$ 和 $\\Delta r_2 = r_{2,\\mathrm{elec}} - r_{2,\\mathrm{mech}}$。\n4. 以埃为单位报告差异，四舍五入到小数点后四位。\n\n单位：\n- 键长必须以埃为单位表示，差异 $\\Delta r_1$ 和 $\\Delta r_2$ 必须以埃为单位报告，并四舍五入到小数点后四位。\n- 能量必须以一致的方式计算；如果使用点电荷之间的库仑相互作用，请确保使用物理上一致的常数和单位，以使最小化具有物理意义。\n\n测试套件：\n实现以下三个测试用例来验证你的程序。在所有情况下，分子都是相同的线性三原子体系，量子力学区域由带有部分电荷 $q_A$、$q_B$ 和 $q_C$ 的原子 $A$、$B$ 和 $C$ 组成。分子力学环境是一组固定的点电荷，其大小和位置在同一条线上指定。为本问题之目的，莫尔斯势中的平衡键长是指定的；优化的初始猜测值应取这些平衡值。\n\n- 测试用例 1 (一般情况)：\n  - 量子力学莫尔斯参数：\n    - 键 $A\\text{-}B$：势阱深度 $D_1 = 80.0$，刚度 $a_1 = 2.0$，平衡长度 $r_{e1} = 1.35$。\n    - 键 $B\\text{-}C$：势阱深度 $D_2 = 100.0$，刚度 $a_2 = 2.5$，平衡长度 $r_{e2} = 1.10$。\n  - 交叉耦合系数：$k_{\\mathrm{cross}} = 3.0$。\n  - 量子力学部分电荷：$q_A = 0.8$, $q_B = 0.1$, $q_C = -0.9$。\n  - 分子力学环境（点电荷和位置）：$(-0.5, 5.0)$ 和 $(+0.5, -3.0)$。\n  - 键长边界：$r_1 \\in [0.7, 2.5]$，$r_2 \\in [0.7, 2.5]$。\n\n- 测试用例 2 (场可忽略的边界情况)：\n  - 与测试用例 1 相同的量子力学莫尔斯参数和交叉耦合系数。\n  - 与测试用例 1 相同的量子力学部分电荷。\n  - 分子力学环境：空集（无外部点电荷）。\n  - 键长边界：$r_1 \\in [0.7, 2.5]$，$r_2 \\in [0.7, 2.5]$。\n\n- 测试用例 3 (强场情况)：\n  - 与测试用例 1 相同的量子力学莫尔斯参数和交叉耦合系数。\n  - 与测试用例 1 相同的量子力学部分电荷。\n  - 分子力学环境：$(-1.0, 2.2)$、$(+1.0, 12.0)$ 和 $(-0.3, 6.5)$。\n  - 键长边界：$r_1 \\in [0.7, 2.5]$，$r_2 \\in [0.7, 2.5]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试用例的结果，即测试用例 1 的两个差异 $\\Delta r_1$ 和 $\\Delta r_2$，然后是测试用例 2 的，再然后是测试用例 3 的。例如，输出形式应为“[dr1_case1,dr2_case1,dr1_case2,dr2_case2,dr1_case3,dr2_case3]”，其中每个条目都是一个四舍五入到小数点后四位并以埃为单位的浮点数。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、良构且客观的。它提出了一个计算化学领域的简化但标准的练习，特别是在多尺度量子力学/分子力学 (QM/MM) 建模领域。任务是通过与机械嵌入方案进行比较，来量化静电嵌入对模型三原子体系几何构型的影响。该问题需要对两个不同的势能面进行数值最小化。\n\n虽然该问题在根本上是明确定义的，但它省略了键-键交叉耦合项的显式函数形式以及能量参数的单位。这些疏漏并不会使问题无效，因为存在标准惯例，且问题强制要求“能量必须以一致的方式计算”。此处将采纳的最科学合理的解释是，使用双线性伸缩-伸缩相互作用项（这是分子力场中的常见选择），并采用分子建模中标准的一致单位集：能量使用千卡/摩尔（$\\mathrm{kcal}/\\mathrm{mol}$），距离使用埃（$\\mathrm{\\AA}$），电荷使用基本电荷单位（$e$）。\n\n线性三原子分子 $A\\text{-}B\\text{-}C$ 的几何构型由两个键长定义：$r_1 = d(A,B)$ 和 $r_2 = d(B,C)$。沿一个轴的原子位置为 $x_A = 0$，$x_B = r_1$ 和 $x_C = r_1 + r_2$。\n\n在玻恩-奥本海默近似内，总势能是这些原子核坐标的函数。在 QM/MM 的背景下，该能量被划分。我们关心的是依赖于 QM 区域几何构型的项，即内部 QM 能量 $U_{\\mathrm{QM}}(r_1, r_2)$，以及 QM 和 MM 区域之间的静电相互作用能 $U_{\\mathrm{QM/MM,elec}}(r_1, r_2)$。需要最小化的总能量为 $E(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) + U_{\\mathrm{QM/MM,elec}}(r_1, r_2)$。\n\n两种嵌入方案通过是否包含 $U_{\\mathrm{QM/MM,elec}}$ 项来定义。\n\n**1. 机械嵌入势能**\n\n在机械嵌入中，QM 区域不感受 MM 环境的静电场。需要最小化的势能 $E_{\\mathrm{mech}}$ 仅为 QM 区域的内部能量：\n$$ E_{\\mathrm{mech}}(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) $$\n该内部能量被建模为两个键的莫尔斯势和一个交叉耦合项之和：\n$$ U_{\\mathrm{QM}}(r_1, r_2) = V_{\\mathrm{Morse},1}(r_1) + V_{\\mathrm{Morse},2}(r_2) + V_{\\mathrm{cross}}(r_1, r_2) $$\n每个莫尔斯势由下式给出：\n$$ V_{\\mathrm{Morse},i}(r_i) = D_i (1 - e^{-a_i (r_i - r_{ei})})^2 $$\n其中 $D_i$ 是势阱深度，$a_i$ 是刚度参数，$r_{ei}$ 是平衡键长。交叉耦合项建模为：\n$$ V_{\\mathrm{cross}}(r_1, r_2) = k_{\\mathrm{cross}}(r_1 - r_{e1})(r_2 - r_{e2}) $$\n其中 $k_{\\mathrm{cross}}$ 是耦合力常数。\n\n**2. 静电嵌入势能**\n\n在静电嵌入中，QM 的电子和原子核被 MM 电荷的静电场所极化。势能 $E_{\\mathrm{elec}}$ 包括静电相互作用项：\n$$ E_{\\mathrm{elec}}(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) + U_{\\mathrm{QM/MM,elec}}(r_1, r_2) $$\n相互作用项 $U_{\\mathrm{QM/MM,elec}}$ 是 QM 原子（$q_A, q_B, q_C$）的部分电荷与 MM 环境的固定点电荷之间的库仑相互作用之和：\n$$ U_{\\mathrm{QM/MM,elec}}(r_1, r_2) = k_e \\sum_{i \\in \\{A,B,C\\}} \\sum_{j \\in \\mathrm{MM}} \\frac{q_i q_j}{|x_i - x_{j,\\mathrm{MM}}|} $$\n此处，$q_i$ 和 $x_i$ 是第 $i$ 个 QM 原子的电荷和位置，$q_j$ 和 $x_{j,\\mathrm{MM}}$ 是第 $j$ 个 MM 点电荷的电荷和位置，$k_e$ 是库仑常数。为保证单位一致（能量单位为 $\\mathrm{kcal}/\\mathrm{mol}$，距离单位为 $\\mathrm{\\AA}$，电荷单位为 $e$），我们使用 $k_e = 332.0637 \\, \\frac{\\mathrm{kcal}}{\\mathrm{mol}} \\frac{\\mathrm{\\AA}}{e^2}$。因此，势参数的单位为：$D_i$ 的单位是 $\\mathrm{kcal}/\\mathrm{mol}$，$a_i$ 的单位是 $\\mathrm{\\AA}^{-1}$，$k_{\\mathrm{cross}}$ 的单位是 $\\mathrm{kcal}/(\\mathrm{mol} \\cdot \\mathrm{\\AA}^2)$。\n\n**3. 数值优化**\n\n对于每个测试用例，我们找到最小化 $E_{\\mathrm{mech}}(r_1, r_2)$ 的优化键长 $(r_{1,\\mathrm{mech}}, r_{2,\\mathrm{mech}})$ 和最小化 $E_{\\mathrm{elec}}(r_1, r_2)$ 的优化键长 $(r_{1,\\mathrm{elec}}, r_{2,\\mathrm{elec}})$。这是一个非线性优化问题：\n$$ (r_{1,\\mathrm{opt}}, r_{2,\\mathrm{opt}}) = \\arg\\min_{r_1, r_2} E(r_1, r_2) $$\n优化使用 `L-BFGS-B` 算法进行数值计算，该算法适用于带箱式约束的拟牛顿优化。搜索被限制在物理上合理的边界 $r_1, r_2 \\in [0.7, 2.5] \\, \\mathrm{\\AA}$ 内。优化的初始猜测值设为平衡键长 $(r_{e1}, r_{e2})$。\n\n**4. 最终差异计算**\n\n在获得两种嵌入方案的优化几何构型后，由静电环境引起的键长变化计算如下：\n$$ \\Delta r_1 = r_{1,\\mathrm{elec}} - r_{1,\\mathrm{mech}} $$\n$$ \\Delta r_2 = r_{2,\\mathrm{elec}} - r_{2,\\mathrm{mech}} $$\n对每个测试用例计算这些差异，并报告至小数点后四位。对于测试用例 2，其中 MM 环境为空，则 $U_{\\mathrm{QM/MM,elec}} = 0$，导致 $E_{\\mathrm{elec}} = E_{\\mathrm{mech}}$。因此，我们预期 $\\Delta r_1 = 0$ 和 $\\Delta r_2 = 0$，这为方法学提供了可靠的内部检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM geometry optimization problem for three test cases.\n    \"\"\"\n    # Coulomb's constant in units of (kcal/mol) * Angstrom / e^2\n    COULOMB_K = 332.0637\n\n    def energy_qm(r, qm_params):\n        \"\"\"Calculates the internal QM energy.\"\"\"\n        r1, r2 = r\n        D1, a1, re1, D2, a2, re2, k_cross = qm_params\n        v_morse1 = D1 * (1 - np.exp(-a1 * (r1 - re1)))**2\n        v_morse2 = D2 * (1 - np.exp(-a2 * (r2 - re2)))**2\n        v_cross = k_cross * (r1 - re1) * (r2 - re2)\n        return v_morse1 + v_morse2 + v_cross\n\n    def energy_qmmm_elec(r, qm_charges, mm_env):\n        \"\"\"Calculates the QM/MM electrostatic interaction energy.\"\"\"\n        r1, r2 = r\n        qA, qB, qC = qm_charges\n        \n        # Atomic positions\n        xA = 0.0\n        xB = r1\n        xC = r1 + r2\n        \n        qm_atoms = [\n            {'charge': qA, 'pos': xA},\n            {'charge': qB, 'pos': xB},\n            {'charge': qC, 'pos': xC}\n        ]\n        \n        e_elec = 0.0\n        for q_mm, x_mm in mm_env:\n            for qm_atom in qm_atoms:\n                dist = np.abs(qm_atom['pos'] - x_mm)\n                # This check avoids division by zero, though unlikely with the given test cases.\n                if dist  1e-12:\n                    return np.inf\n                e_elec += COULOMB_K * qm_atom['charge'] * q_mm / dist\n                \n        return e_elec\n\n    def total_energy_mech(r, params):\n        \"\"\"Total energy for mechanical embedding.\"\"\"\n        return energy_qm(r, params['qm_params'])\n\n    def total_energy_elec(r, params):\n        \"\"\"Total energy for electrostatic embedding.\"\"\"\n        e_qm = energy_qm(r, params['qm_params'])\n        e_qmmm = energy_qmmm_elec(r, params['qm_charges'], params['mm_env'])\n        return e_qm + e_qmmm\n\n    test_cases = [\n        { # Test Case 1\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [(-0.5, 5.0), (0.5, -3.0)],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        },\n        { # Test Case 2\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        },\n        { # Test Case 3\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [(-1.0, 2.2), (1.0, 12.0), (-0.3, 6.5)],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        re1 = case_params['qm_params'][2]\n        re2 = case_params['qm_params'][5]\n        initial_guess = [re1, re2]\n        bounds = case_params['bounds']\n\n        # Mechanical embedding optimization\n        res_mech = minimize(total_energy_mech, initial_guess, args=(case_params,), method='L-BFGS-B', bounds=bounds)\n        r1_mech, r2_mech = res_mech.x\n\n        # Electrostatic embedding optimization\n        res_elec = minimize(total_energy_elec, initial_guess, args=(case_params,), method='L-BFGS-B', bounds=bounds)\n        r1_elec, r2_elec = res_elec.x\n\n        # Calculate and store differences\n        dr1 = r1_elec - r1_mech\n        dr2 = r2_elec - r2_mech\n        \n        results.append(round(dr1, 4))\n        results.append(round(dr2, 4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "QM/MM计算的准确性在很大程度上取决于描述量子(QM)与经典(MM)区域之间相互作用的力场参数的质量。这项高级练习将引导您完成一个真实的研究任务：通过将QM/MM模型产生的力与高精度的纯QM计算参考力进行拟合，来校准两者间的Lennard-Jones参数。这个实践不仅揭示了力场参数化的基本流程，也展示了如何为特定的QM/MM应用量身定制精确的力场，是连接理论与实际应用的关键一步。",
            "id": "3799215",
            "problem": "您的任务是在量子力学/分子力学 (QM/MM) 框架下，构建并实现一个协议，用于校准交叉相互作用的 Lennard-Jones 参数。该协议通过在二聚体构象训练集上，最小化混合 QM/MM 径向力与参考量子力学 (QM) 径向力之间的偏差来完成。量子力学/分子力学 (QM/MM) 指的是一种多尺度建模方法，其中系统的子集使用量子力学哈密顿量处理，而其余部分则使用经典力场处理。在这个简化的校准任务中，您需要将 QM-MM 非键交叉相互作用视为单个 QM 原子和单个 MM 原子之间的经典 Lennard-Jones 对势，并通过拟合交叉参数，来重现在多个分子间距下沿原子间轴线的参考 QM 径向力投影。\n\n从以下基本要素开始：\n- 两个位点间距为 $r$ 时的 Lennard-Jones 对势由 $V(r) = 4 \\epsilon \\left[ \\left( \\dfrac{\\sigma}{r} \\right)^{12} - \\left( \\dfrac{\\sigma}{r} \\right)^6 \\right]$ 给出，其中 $\\sigma$ 和 $\\epsilon$ 分别是表征有限尺寸排斥和势阱深度的正参数。\n- 保守力是势能的负梯度，因此沿连接两个位点的直线的径向力为 $F(r) = - \\dfrac{dV}{dr}$。\n- 在此校准问题中，损失函数是模型径向力与参考 QM 径向力值在整个训练集构象上的偏差平方和。\n\n您必须实现一个完整的程序，对每个提供的训练集，求解以下参数估计问题：\n- 给定原子间距 $\\{ r_k \\}_{k=1}^{N}$ 和相应的参考 QM 力 $\\{ F_k^{\\mathrm{ref}} \\}_{k=1}^{N}$，找到参数 $\\sigma  0$ 和 $\\epsilon  0$，以最小化目标函数\n$$\n\\mathcal{L}(\\sigma,\\epsilon) \\;=\\; \\sum_{k=1}^{N} \\left( F(r_k;\\sigma,\\epsilon) \\;-\\; F_k^{\\mathrm{ref}} \\right)^2,\n$$\n其中 $F(r;\\sigma,\\epsilon)$ 是由势 $V(r)$ 导出的 Lennard-Jones 径向力，所有量均为沿原子间轴线的标量径向投影。\n- 在优化过程中，使用数学上良定的变换来强制施加物理约束 $\\sigma  0$ 和 $\\epsilon  0$。\n\n仅根据力是势能负梯度的基本定义，从 $V(r)$ 推导出 $F(r;\\sigma,\\epsilon)$。除了 $V(r)$ 和力的定义之外，不要假定任何预先给定的表达式。\n\n物理和数值单位：\n- 距离单位必须是埃 ($\\mathrm{\\AA}$)。\n- 能量单位必须是千焦耳每摩尔 ($\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$)。\n- 力单位必须是千焦耳每摩尔每埃 ($\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{\\AA}^{-1}$)。\n- 以 $\\mathrm{\\AA}$ 表示最终拟合的 $\\sigma$，以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 表示 $\\epsilon$。\n\n测试套件：\n对于下述每个测试用例，参考 QM 力需使用您推导出的相同力的定义，从具有指定 $(\\sigma^\\star,\\epsilon^\\star)$ 的基准真相 Lennard-Jones 模型中综合生成。您不得对参考力进行硬编码；相反，必须根据提供的 $(\\sigma^\\star,\\epsilon^\\star)$ 和列出的距离来计算它们。\n\n- 测试用例 1 (中等势阱，宽覆盖范围)：\n  - 基准真相参数：$\\sigma^\\star = 3.5\\,\\mathrm{\\AA}$，$\\epsilon^\\star = 0.5\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - 距离：$\\{ 2.8, 3.0, 3.2, 3.5, 4.0, 5.0, 6.0 \\}\\,\\mathrm{\\AA}$。\n\n- 测试用例 2 (极弱吸引力，强调长程尾部)：\n  - 基准真相参数：$\\sigma^\\star = 3.8\\,\\mathrm{\\AA}$，$\\epsilon^\\star = 0.05\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - 距离：$\\{ 3.2, 3.6, 4.0, 5.0, 7.0, 8.0 \\}\\,\\mathrm{\\AA}$。\n\n- 测试用例 3 (排斥主导的近接触区域)：\n  - 基准真相参数：$\\sigma^\\star = 3.2\\,\\mathrm{\\AA}$，$\\epsilon^\\star = 0.6\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - 距离：$\\{ 2.5, 2.7, 2.9, 3.1, 3.3, 3.5 \\}\\,\\mathrm{\\AA}$。\n\n算法要求：\n- 对每个测试用例，分别使用非线性最小二乘求解器来最小化 $\\mathcal{L}(\\sigma,\\epsilon)$。\n- 通过在变换变量（例如，对数）中进行优化来强制执行 $\\sigma  0$ 和 $\\epsilon  0$，使得搜索空间无约束但能映射到正的物理参数。\n- 提供残差相对于变换变量的解析雅可比矩阵，以提高鲁棒性和可复现性。\n- 对所有情况使用固定的确定性初始猜测值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 该列表必须按顺序包含测试用例 1、测试用例 2、然后是测试用例 3 的校准 $\\sigma$ 和 $\\epsilon$。\n- 每个数字必须精确到六位小数，$\\sigma$ 的单位是 $\\mathrm{\\AA}$，$\\epsilon$ 的单位是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 具体来说，输出格式为\n$[ \\sigma_{1}, \\epsilon_{1}, \\sigma_{2}, \\epsilon_{2}, \\sigma_{3}, \\epsilon_{3} ]$\n每个条目打印到六位小数。\n\n您的实现必须是自包含的，不需要用户输入，并严格遵守上述输出格式。",
            "solution": "该问题已经过验证并被认为是有效的。它在科学上基于经典力学和统计力学的原理，特别是使用 Lennard-Jones 势来模拟非键原子间相互作用，这是分子力学力场的基石。该问题作为一个使用非线性最小二乘优化（计算科学中的标准技术）的参数估计任务，是良定的。所有必要的数据、模型和约束都已提供，使得问题自包含且明确。不存在事实错误、逻辑矛盾或主观因素。\n\n校准 Lennard-Jones (LJ) 交叉相互作用参数 $\\sigma$ 和 $\\epsilon$ 的协议，涉及最小化模型预测力与参考量子力学 (QM) 力之间的平方差之和。下面将详细介绍逐步的推导和实现。\n\n首先，必须从 Lennard-Jones 势 $V(r)$ 推导出径向力 $F(r)$ 的解析表达式。势由以下公式给出：\n$$\nV(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right] = 4 \\epsilon \\left( \\sigma^{12}r^{-12} - \\sigma^6 r^{-6} \\right)\n$$\n保守力是势能的负梯度。对于球对称势，径向力为 $F(r) = - \\frac{dV(r)}{dr}$。我们计算其导数：\n$$\n\\frac{dV}{dr} = 4 \\epsilon \\frac{d}{dr} \\left( \\sigma^{12}r^{-12} - \\sigma^6 r^{-6} \\right)\n$$\n$$\n\\frac{dV}{dr} = 4 \\epsilon \\left( \\sigma^{12}(-12)r^{-13} - \\sigma^6(-6)r^{-7} \\right) = 4 \\epsilon \\left( -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right)\n$$\n因此，力 $F(r)$ 为：\n$$\nF(r) = - \\frac{dV}{dr} = -4 \\epsilon \\left( -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right) = 4 \\epsilon \\left( 12 \\frac{\\sigma^{12}}{r^{13}} - 6 \\frac{\\sigma^6}{r^7} \\right)\n$$\n该表达式可以重写为更紧凑的形式：\n$$\nF(r; \\sigma, \\epsilon) = \\frac{24 \\epsilon}{r} \\left[ 2 \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]\n$$\n这是模型力函数。目标是找到参数 $\\sigma  0$ 和 $\\epsilon  0$，以在包含距离 $\\{r_k\\}_{k=1}^N$ 和参考力 $\\{F_k^{\\text{ref}}\\}_{k=1}^N$ 的 $N$ 个构象的训练集上，最小化损失函数 $\\mathcal{L}(\\sigma,\\epsilon)$：\n$$\n\\mathcal{L}(\\sigma,\\epsilon) = \\sum_{k=1}^{N} \\left( F(r_k; \\sigma, \\epsilon) - F_k^{\\text{ref}} \\right)^2\n$$\n这是一个非线性最小二乘问题。物理约束 $\\sigma  0$ 和 $\\epsilon  0$ 通过变量替换来处理。我们定义新的无约束参数 $p_1$ 和 $p_2$ 使得：\n$$\n\\sigma = e^{p_1} \\quad \\text{和} \\quad \\epsilon = e^{p_2}\n$$\n然后在实值参数 $p_1, p_2 \\in \\mathbb{R}$ 上执行优化。最小二乘求解器旨在最小化其 $L_2$ 范数的残差向量由 $R_k(p_1,p_2) = F(r_k; e^{p_1}, e^{p_2}) - F_k^{\\text{ref}}$ 给出。\n\n为确保鲁棒且高效的收敛，我们必须向求解器提供残差向量相对于变换后参数的解析雅可比矩阵。雅可比矩阵 $J$ 的元素为 $J_{ki} = \\frac{\\partial R_k}{\\partial p_i}$。由于 $F_k^{\\text{ref}}$ 相对于参数是常数，这可以简化为 $J_{ki} = \\frac{\\partial F(r_k; p_1, p_2)}{\\partial p_i}$。\n\n让我们来推导偏导数。首先，对 $p_1 = \\ln(\\sigma)$ 求导：使用链式法则，$\\frac{\\partial F}{\\partial p_1} = \\frac{\\partial F}{\\partial \\sigma} \\frac{\\partial \\sigma}{\\partial p_1} = \\frac{\\partial F}{\\partial \\sigma} e^{p_1} = \\sigma \\frac{\\partial F}{\\partial \\sigma}$。\n$$\n\\frac{\\partial F}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma} \\left[ 4 \\epsilon \\left( 12 \\frac{\\sigma^{12}}{r^{13}} - 6 \\frac{\\sigma^6}{r^7} \\right) \\right] = 4 \\epsilon \\left( 12 \\frac{12 \\sigma^{11}}{r^{13}} - 6 \\frac{6 \\sigma^5}{r^7} \\right) = 4 \\epsilon \\left( 144 \\frac{\\sigma^{11}}{r^{13}} - 36 \\frac{\\sigma^5}{r^7} \\right)\n$$\n因此，雅可比矩阵元素为：\n$$\nJ_{k1} = \\frac{\\partial F_k}{\\partial p_1} = \\sigma \\cdot \\left[ 4 \\epsilon \\left( 144 \\frac{\\sigma^{11}}{r_k^{13}} - 36 \\frac{\\sigma^5}{r_k^7} \\right) \\right] = 4 \\epsilon \\left( 144 \\frac{\\sigma^{12}}{r_k^{13}} - 36 \\frac{\\sigma^6}{r_k^7} \\right)\n$$\n$$\nJ_{k1} = \\frac{144 \\epsilon}{r_k} \\left[ 4 \\left(\\frac{\\sigma}{r_k}\\right)^{12} - \\left(\\frac{\\sigma}{r_k}\\right)^6 \\right]\n$$\n\n接下来，我们推导对 $p_2 = \\ln(\\epsilon)$ 的偏导数：$\\frac{\\partial F}{\\partial p_2} = \\frac{\\partial F}{\\partial \\epsilon} \\frac{\\partial \\epsilon}{\\partial p_2} = \\frac{\\partial F}{\\partial \\epsilon} e^{p_2} = \\epsilon \\frac{\\partial F}{\\partial \\epsilon}$。力 $F$ 与 $\\epsilon$ 呈线性关系：$F(\\sigma, \\epsilon) = \\epsilon \\cdot F(\\sigma, \\epsilon=1)$。因此，$\\frac{\\partial F}{\\partial \\epsilon} = \\frac{F}{\\epsilon}$。\n$$\nJ_{k2} = \\frac{\\partial F_k}{\\partial p_2} = \\epsilon \\cdot \\frac{F(r_k; \\sigma, \\epsilon)}{\\epsilon} = F(r_k; \\sigma, \\epsilon)\n$$\n这个非常简洁的结果完成了我们雅可比矩阵的推导。对于每个距离 $r_k$，雅可比矩阵的两列分别是如上推导的 $\\frac{\\partial F_k}{\\partial p_1}$ 和 $\\frac{\\partial F_k}{\\partial p_2}$，其中 $\\sigma=e^{p_1}$ 且 $\\epsilon=e^{p_2}$。\n\n解决方案的实现对每个测试用例包括以下步骤：\n1.  使用提供的基准真相参数 $(\\sigma^\\star, \\epsilon^\\star)$ 和推导出的力表达式 $F(r; \\sigma, \\epsilon)$ 生成合成的参考力数据 $\\{F_k^{\\text{ref}}\\}$。\n2.  定义残差向量和雅可比矩阵的函数，两者都以变换后的参数向量 $\\vec{p} = [p_1, p_2]$ 作为输入。\n3.  为优化器选择一个固定的初始猜测值。对所有情况使用一个物理上合理的猜测值，例如 $\\sigma_0 = 3.0 \\, \\mathrm{\\AA}$ 和 $\\epsilon_0 = 0.5 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，这对应于初始的变换后参数向量 $\\vec{p}_0 = [\\ln(3.0), \\ln(0.5)]$。\n4.  使用 `scipy.optimize.least_squares` 函数，向其提供残差函数、初始猜测值和解析雅可比函数。\n5.  从求解器的结果中提取优化后的变换参数 $\\vec{p}_{\\text{opt}}$。\n6.  将优化后的参数转换回物理表示：$\\sigma_{\\text{fit}} = e^{p_{1, \\text{opt}}}$ 和 $\\epsilon_{\\text{fit}} = e^{p_{2, \\text{opt}}}$。\n7.  按照规定收集并格式化结果。由于参考数据是从正在拟合的同一模型生成的，因此预计优化将高精度地恢复基准真相参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the Lennard-Jones parameter calibration problem for three test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (ground_truth_sigma, ground_truth_epsilon, distances)\n    test_cases = [\n        (3.5, 0.5, [2.8, 3.0, 3.2, 3.5, 4.0, 5.0, 6.0]),  # Test case 1\n        (3.8, 0.05, [3.2, 3.6, 4.0, 5.0, 7.0, 8.0]),      # Test case 2\n        (3.2, 0.6, [2.5, 2.7, 2.9, 3.1, 3.3, 3.5]),       # Test case 3\n    ]\n\n    # This function is defined once and used for all calculations.\n    def lj_force(r, sigma, epsilon):\n        \"\"\"\n        Calculates the Lennard-Jones radial force.\n        F(r) = 24*eps/r * [2*(sigma/r)^12 - (sigma/r)^6]\n        A positive force is repulsive, a negative force is attractive.\n        \"\"\"\n        if np.any(r = 0) or sigma = 0 or epsilon = 0:\n            # Handle non-physical inputs to prevent division by zero or errors\n            # Return high values to steer optimizer away\n            return np.full_like(r, np.inf)\n\n        r_ratio_sq = (sigma / r)**2\n        r_ratio_6 = r_ratio_sq**3\n        r_ratio_12 = r_ratio_6**2\n        \n        force = (24.0 * epsilon / r) * (2.0 * r_ratio_12 - r_ratio_6)\n        return force\n\n    all_results = []\n    \n    # A fixed deterministic initial guess for the transformed parameters [ln(sigma), ln(epsilon)]\n    # Corresponds to sigma=3.0 Angstrom, epsilon=0.5 kJ/mol\n    p0 = np.array([np.log(3.0), np.log(0.5)])\n\n    for sigma_star, epsilon_star, r_values in test_cases:\n        r_k = np.array(r_values)\n\n        # Generate the reference QM forces synthetically\n        F_ref = lj_force(r_k, sigma_star, epsilon_star)\n\n        def residuals_func(p, r_data, F_ref_data):\n            \"\"\"\n            Calculates the vector of residuals: F_model(p) - F_ref.\n            p = [ln(sigma), ln(epsilon)]\n            \"\"\"\n            sigma_fit = np.exp(p[0])\n            epsilon_fit = np.exp(p[1])\n            F_model = lj_force(r_data, sigma_fit, epsilon_fit)\n            return F_model - F_ref_data\n\n        def jacobian_func(p, r_data, F_ref_data):\n            \"\"\"\n            Calculates the Jacobian of the residuals with respect to p.\n            p = [ln(sigma), ln(epsilon)]\n            The Jacobian has shape (N_data, 2).\n            \"\"\"\n            sigma_fit = np.exp(p[0])\n            epsilon_fit = np.exp(p[1])\n\n            # Pre-calculate common terms for efficiency\n            r_ratio_sq = (sigma_fit / r_data)**2\n            r_ratio_6 = r_ratio_sq**3\n            r_ratio_12 = r_ratio_6**2\n            \n            # Jacobian column 1: d(Residual)/d(p[0]) = d(F_model)/d(ln(sigma))\n            # dF/d(ln(sigma)) = 144*eps/r * [4*(sigma/r)^12 - (sigma/r)^6]\n            dF_dp1 = (144.0 * epsilon_fit / r_data) * (4.0 * r_ratio_12 - r_ratio_6)\n\n            # Jacobian column 2: d(Residual)/d(p[1]) = d(F_model)/d(ln(epsilon))\n            # dF/d(ln(epsilon)) = F_model\n            dF_dp2 = lj_force(r_data, sigma_fit, epsilon_fit)\n            \n            # Combine columns and transpose to get (N_data, 2) shape\n            return np.array([dF_dp1, dF_dp2]).T\n\n        # Perform the non-linear least-squares optimization\n        result = least_squares(\n            fun=residuals_func,\n            x0=p0,\n            jac=jacobian_func,\n            args=(r_k, F_ref),\n            method='lm',  # Levenberg-Marquardt is robust\n            gtol=1e-12,\n            xtol=1e-12,\n            ftol=1e-12\n        )\n        \n        # Extract optimized transformed parameters\n        p_opt = result.x\n        \n        # Convert back to physical parameters\n        sigma_fit = np.exp(p_opt[0])\n        epsilon_fit = np.exp(p_opt[1])\n        \n        all_results.extend([sigma_fit, epsilon_fit])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'{val:.6f}' for val in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}