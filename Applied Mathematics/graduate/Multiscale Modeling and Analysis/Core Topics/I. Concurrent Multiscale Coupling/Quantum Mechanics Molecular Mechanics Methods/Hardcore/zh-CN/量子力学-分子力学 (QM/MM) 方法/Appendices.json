{
    "hands_on_practices": [
        {
            "introduction": "理解量子区域和经典区域之间如何通过静电相互影响是 QM/MM 方法的核心。本练习通过要求您解析求解一个简化的可极化 QM/MM 模型，为理解这种相互作用提供了基础性视角 。通过推导感应偶极子的自洽方程，您将从第一性原理层面理解静电极化这一在许多模拟中至关重要的效应。",
            "id": "3799184",
            "problem": "一个双位点可极化分子力学 (MM) 子系统被嵌入到一个量子力学/分子力学 (QM/MM) 多尺度模型中，其中量子力学 (QM) 区域由单个点电荷表示。两个 MM 可极化位点分别位于 $z$ 轴上的 $z=+a$ 和 $z=-a$ 位置，具有相同的各向同性极化率 $\\alpha$。QM 区域被一个固定在原点的点电荷 $q$ 所取代。假设真空介电常数为 $\\varepsilon_0$，没有永久 MM 电荷，没有高阶多极矩，也没有短程阻尼。所有相互作用都是纯粹的经典静电学和线性极化。\n\n使用以下基本原理：\n- 点电荷产生电场的库仑定律：位于原点的电荷 $q$ 在位置 $\\mathbf{r}$ 处产生的电场为 $\\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r})=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q\\,\\hat{\\mathbf{r}}}{r^2}$。\n- 位于原点的点偶极子 $\\boldsymbol{\\mu}$ 产生的电场为 $\\mathbf{E}_{\\mathrm{dip}}(\\mathbf{r})=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{3(\\boldsymbol{\\mu}\\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}-\\boldsymbol{\\mu}}{r^3}$。\n- 各向同性位点的线性极化率：位点 $i$ 上的感应偶极子为 $\\boldsymbol{\\mu}_i=\\alpha\\,\\mathbf{E}_{\\mathrm{loc},i}$，其中 $\\mathbf{E}_{\\mathrm{loc},i}$ 是位点 $i$ 处的局域电场。\n- 外电场中 $N$ 个各向同性可极化点偶极子的极化能泛函为\n$$\nU_{\\mathrm{pol}}(\\{\\boldsymbol{\\mu}_i\\})=\\sum_{i=1}^{N}\\frac{1}{2\\alpha}\\,|\\boldsymbol{\\mu}_i|^2-\\sum_{i=1}^{N}\\boldsymbol{\\mu}_i\\cdot \\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r}_i)-\\frac{1}{2}\\sum_{i\\neq j}\\boldsymbol{\\mu}_i\\cdot \\mathbf{T}_{ij}\\cdot \\boldsymbol{\\mu}_j,\n$$\n其中 $\\mathbf{T}_{ij}$ 是从 $\\mathbf{E}_{\\mathrm{dip}}$ 导出的偶极-偶极相互作用张量。\n\n给定沿 $z$ 轴的共线几何结构，您可以只关注 $z$ 分量，并通过张量的标量 $zz$ 分量 $T_{zz}(r)=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{2}{r^3}$ 来处理偶极-偶极耦合，适用于沿 $z$ 轴相距为 $r$ 的两个位点。\n\n任务：\n1. 从能量泛函和上述定义出发，推导两个 MM 位点上感应偶极子的自洽方程（用 $z$ 分量表示，即 $z=+a$ 处的 $\\mu_1$ 和 $z=-a$ 处的 $\\mu_2$）。以闭合形式求解这些方程，得到 $\\mu_1$ 和 $\\mu_2$。\n2. 计算稳态解处的极化能。以闭合形式给出结果，并通过证明其与二次能量泛函的稳态性质一致来验证它。\n3. 仅用 $q$, $a$, $\\alpha$ 和 $\\varepsilon_0$ 表示您的最终结果 $\\mu_1$、$\\mu_2$ 和 $U_{\\mathrm{pol}}$，使用国际单位制 (SI)。感应偶极子以库仑-米为单位，能量以焦耳为单位。不需要进行数值四舍五入。在最终答案中将这三个量一起以单行矩阵的形式呈现。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的和客观的。它提出了一个经典静电学中的标准问题，与多尺度建模相关，特别是可极化的量子力学/分子力学 (QM/MM) 方法。所有必要的信息都已提供，并且设置是自洽的，没有矛盾。因此，该问题被认为是有效的，并将构建一个解决方案。\n\n该系统由两个可极化位点组成，标记为 $1$ 和 $2$，分别位于位置 $\\mathbf{r}_1 = a\\hat{\\mathbf{z}}$ 和 $\\mathbf{r}_2 = -a\\hat{\\mathbf{z}}$。两个位点都具有相同的各向同性极化率 $\\alpha$。一个点电荷 $q$ 位于原点 $\\mathbf{r}_q = \\mathbf{0}$。由于沿 $z$ 轴的共线排列，感应偶极矩 $\\boldsymbol{\\mu}_1, \\boldsymbol{\\mu}_2$ 和电场将与 $z$ 轴对齐。因此，我们可以将所有矢量视为表示其 $z$ 分量的标量。设 $\\mu_1$ 和 $\\mu_2$ 分别是位点 $1$ 和 $2$ 上感应偶极矩的标量 $z$ 分量。\n\n首先，我们确定由电荷 $q$ 在每个位点产生的外部电场 $E_{\\mathrm{ext}}$。来自原点处点电荷 $q$ 的电场为 $\\mathbf{E}_{\\mathrm{ext}}(\\mathbf{r})=\\dfrac{q}{4\\pi \\varepsilon_0 r^2}\\hat{\\mathbf{r}}$。\n在位点 $1$（$\\mathbf{r}_1 = a\\hat{\\mathbf{z}}$），位置矢量为 $\\mathbf{r}=a\\hat{\\mathbf{z}}$，所以 $r=a$ 且 $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$。电场的 $z$ 分量为：\n$$\nE_{\\mathrm{ext},1} = \\frac{q}{4\\pi \\varepsilon_0 a^2}\n$$\n在位点 $2$（$\\mathbf{r}_2 = -a\\hat{\\mathbf{z}}$），位置矢量为 $\\mathbf{r}=-a\\hat{\\mathbf{z}}$，所以 $r=a$ 且 $\\hat{\\mathbf{r}}=-\\hat{\\mathbf{z}}$。电场的 $z$ 分量为：\n$$\nE_{\\mathrm{ext},2} = \\frac{q}{4\\pi \\varepsilon_0 a^2}(-1) = -\\frac{q}{4\\pi \\varepsilon_0 a^2}\n$$\n通过对称性，我们注意到 $E_{\\mathrm{ext},2} = -E_{\\mathrm{ext},1}$。为简单起见，我们定义 $E_0 = \\frac{q}{4\\pi \\varepsilon_0 a^2}$，因此 $E_{\\mathrm{ext},1} = E_0$ 且 $E_{\\mathrm{ext},2} = -E_0$。\n\n接下来，我们建立两个感应偶极子之间的相互作用。两个位点之间的距离是 $r=a - (-a) = 2a$。问题指定了共线构型下偶极-偶极相互作用张量的标量 $zz$ 分量为 $T_{zz}(r)=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{2}{r^3}$。对于我们的系统，这个标量相互作用常数，我们称之为 $T$，是：\n$$\nT = T_{zz}(2a) = \\frac{1}{4\\pi \\varepsilon_0}\\frac{2}{(2a)^3} = \\frac{1}{4\\pi \\varepsilon_0}\\frac{2}{8a^3} = \\frac{1}{16\\pi \\varepsilon_0 a^3}\n$$\n位点 $2$ 处的偶极子 $\\mu_2$ 在位点 $1$ 处产生的电场是 $E_{\\mathrm{ind},1} = T \\mu_2$。同样，偶极子 $\\mu_1$ 在位点 $2$ 处产生的电场是 $E_{\\mathrm{ind},2} = T \\mu_1$。\n\n每个位点处的总局域电场是外部电场与另一个感应偶极子产生的电场之和。\n$$\nE_{\\mathrm{loc},1} = E_{\\mathrm{ext},1} + E_{\\mathrm{ind},1} = E_0 + T \\mu_2\n$$\n$$\nE_{\\mathrm{loc},2} = E_{\\mathrm{ext},2} + E_{\\mathrm{ind},2} = -E_0 + T \\mu_1\n$$\n\n**任务1：推导并求解 $\\mu_1$ 和 $\\mu_2$ 的自洽方程**\n\n自洽方程源于线性极化率关系 $\\mu_i = \\alpha E_{\\mathrm{loc},i}$。\n$$\n\\mu_1 = \\alpha (E_0 + T \\mu_2)\n$$\n$$\n\\mu_2 = \\alpha (-E_0 + T \\mu_1)\n$$\n这些方程也可以通过最小化极化能泛函 $U_{\\mathrm{pol}}(\\mu_1, \\mu_2)$ 相对于 $\\mu_1$ 和 $\\mu_2$ 来推导。该系统的泛函为：\n$$\nU_{\\mathrm{pol}}(\\mu_1, \\mu_2) = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\mu_1 E_{\\mathrm{ext},1} - \\mu_2 E_{\\mathrm{ext},2} - \\mu_1 T \\mu_2\n$$\n对 $\\mu_1$ 进行最小化：\n$$\n\\frac{\\partial U_{\\mathrm{pol}}}{\\partial \\mu_1} = \\frac{\\mu_1}{\\alpha} - E_{\\mathrm{ext},1} - T \\mu_2 = 0 \\implies \\mu_1 = \\alpha(E_{\\mathrm{ext},1} + T\\mu_2)\n$$\n对 $\\mu_2$ 进行最小化：\n$$\n\\frac{\\partial U_{\\mathrm{pol}}}{\\partial \\mu_2} = \\frac{\\mu_2}{\\alpha} - E_{\\mathrm{ext},2} - T \\mu_1 = 0 \\implies \\mu_2 = \\alpha(E_{\\mathrm{ext},2} + T\\mu_1)\n$$\n这些方程与从局域电场定义推导出的方程相同。\n\n我们现在求解这个二元线性方程组：\n1. $\\mu_1 - \\alpha T \\mu_2 = \\alpha E_0$\n2. $-\\alpha T \\mu_1 + \\mu_2 = -\\alpha E_0$\n\n根据问题的对称性（$E_{\\mathrm{ext},2} = -E_{\\mathrm{ext},1}$），我们可以推断出 $\\mu_2 = -\\mu_1$。将此代入第一个方程：\n$$\n\\mu_1 - \\alpha T (-\\mu_1) = \\alpha E_0 \\implies \\mu_1(1 + \\alpha T) = \\alpha E_0\n$$\n$$\n\\mu_1 = \\frac{\\alpha E_0}{1 + \\alpha T}\n$$\n因此，$\\mu_2 = -\\mu_1 = -\\frac{\\alpha E_0}{1 + \\alpha T}$。我们可以通过代入第二个方程来验证其一致性：\n$$\n-\\alpha T (\\frac{\\alpha E_0}{1 + \\alpha T}) + (-\\frac{\\alpha E_0}{1 + \\alpha T}) = -\\alpha E_0 \\implies \\frac{-\\alpha^2 T E_0 - \\alpha E_0}{1+\\alpha T} = -\\alpha E_0 \\implies -\\alpha E_0 \\frac{\\alpha T + 1}{1+\\alpha T} = -\\alpha E_0\n$$\n解是一致的。\n\n现在代入 $E_0$ 和 $T$ 的表达式：\n$$\n1 + \\alpha T = 1 + \\alpha \\left(\\frac{1}{16\\pi \\varepsilon_0 a^3}\\right) = \\frac{16\\pi \\varepsilon_0 a^3 + \\alpha}{16\\pi \\varepsilon_0 a^3}\n$$\n$$\n\\mu_1 = \\frac{\\alpha \\left(\\frac{q}{4\\pi \\varepsilon_0 a^2}\\right)}{\\frac{16\\pi \\varepsilon_0 a^3 + \\alpha}{16\\pi \\varepsilon_0 a^3}} = \\frac{\\alpha q}{4\\pi \\varepsilon_0 a^2} \\frac{16\\pi \\varepsilon_0 a^3}{16\\pi \\varepsilon_0 a^3 + \\alpha} = \\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha}\n$$\n偶极矩的解为：\n$$\n\\mu_1 = \\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha} \\quad \\text{和} \\quad \\mu_2 = -\\frac{4\\alpha q a}{16\\pi \\varepsilon_0 a^3 + \\alpha}\n$$\n\n**任务2：计算极化能 $U_{\\mathrm{pol}}$**\n\n问题要求计算稳态解处的极化能并对其进行验证。对于形式为 $U(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^T \\mathbf{A} \\mathbf{x} - \\mathbf{x}^T \\mathbf{b}$ 的二次能量泛函，稳态点 $\\mathbf{x}_{\\mathrm{sol}}$ 满足 $\\mathbf{A}\\mathbf{x}_{\\mathrm{sol}} = \\mathbf{b}$，且该点处的能量为 $U(\\mathbf{x}_{\\mathrm{sol}}) = -\\frac{1}{2}\\mathbf{x}_{\\mathrm{sol}}^T \\mathbf{b}$。在我们的情境中，$\\mathbf{x} \\equiv (\\mu_1, \\mu_2)^T$ 且 $\\mathbf{b} \\equiv (E_{\\mathrm{ext},1}, E_{\\mathrm{ext},2})^T$。因此，稳态能量为：\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2})\n$$\n这就是所要求的验证。我们可以通过直接代入完整的能量泛函来证实这一点：\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - (\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2}) - \\mu_1 T \\mu_2\n$$\n使用 $E_{\\mathrm{ext},1} = \\frac{\\mu_1}{\\alpha} - T\\mu_2$ 和 $E_{\\mathrm{ext},2} = \\frac{\\mu_2}{\\alpha} - T\\mu_1$：\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\left(\\mu_1(\\frac{\\mu_1}{\\alpha} - T\\mu_2) + \\mu_2(\\frac{\\mu_2}{\\alpha} - T\\mu_1)\\right) - \\mu_1 T \\mu_2\n$$\n$$\nU_{\\mathrm{pol}} = \\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) - \\frac{1}{\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2 + \\mu_2 T \\mu_1 - \\mu_1 T \\mu_2\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2\n$$\n现在，与 $-\\frac{1}{2}(\\mu_1 E_{\\mathrm{ext},1} + \\mu_2 E_{\\mathrm{ext},2}) = -\\frac{1}{2}\\left(\\mu_1(\\frac{\\mu_1}{\\alpha} - T\\mu_2) + \\mu_2(\\frac{\\mu_2}{\\alpha} - T\\mu_1)\\right) = -\\frac{1}{2\\alpha}(\\mu_1^2 + \\mu_2^2) + \\mu_1 T \\mu_2$ 比较。表达式相同，证实了稳态性质。\n\n现在我们使用更简单的形式计算 $U_{\\mathrm{pol}}$ 的值：\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_0 + \\mu_2 (-E_0)) = -\\frac{1}{2}(\\mu_1 E_0 - \\mu_2 E_0)\n$$\n代入 $\\mu_2 = -\\mu_1$：\n$$\nU_{\\mathrm{pol}} = -\\frac{1}{2}(\\mu_1 E_0 - (-\\mu_1) E_0) = -\\frac{1}{2}(2\\mu_1 E_0) = -\\mu_1 E_0\n$$\n代入 $\\mu_1$ 和 $E_0$ 的表达式：\n$$\nU_{\\mathrm{pol}} = -\\left(\\frac{\\alpha E_0}{1 + \\alpha T}\\right) E_0 = -\\frac{\\alpha E_0^2}{1 + \\alpha T}\n$$\n现在用基本常数表示：\n$$\nE_0^2 = \\left(\\frac{q}{4\\pi \\varepsilon_0 a^2}\\right)^2 = \\frac{q^2}{16\\pi^2 \\varepsilon_0^2 a^4}\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha \\frac{q^2}{16\\pi^2 \\varepsilon_0^2 a^4}}{1 + \\frac{\\alpha}{16\\pi \\varepsilon_0 a^3}} = -\\frac{\\alpha q^2}{16\\pi^2 \\varepsilon_0^2 a^4} \\left(\\frac{16\\pi \\varepsilon_0 a^3}{16\\pi \\varepsilon_0 a^3 + \\alpha}\\right)\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha q^2}{\\pi \\varepsilon_0 a (16\\pi \\varepsilon_0 a^3 + \\alpha)}\n$$\n\n**任务3：呈现最终结果**\n\n所要求的量是 $\\mu_1, \\mu_2$ 和 $U_{\\mathrm{pol}}$，用 $q, a, \\alpha$ 和 $\\varepsilon_0$ 表示。\n$$\n\\mu_1 = \\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}\n$$\n$$\n\\mu_2 = -\\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}\n$$\n$$\nU_{\\mathrm{pol}} = -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)}\n$$\n这些结果是其最终的闭合形式，用规定的常数表示。通过量纲分析确定，偶极子的单位是库仑-米，能量的单位是焦耳。",
            "answer": "$$ \\boxed{\\begin{pmatrix} \\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}  -\\frac{4\\alpha q a}{16\\pi\\varepsilon_0 a^3 + \\alpha}  -\\frac{\\alpha q^2}{\\pi\\varepsilon_0 a(16\\pi\\varepsilon_0 a^3 + \\alpha)} \\end{pmatrix}} $$"
        },
        {
            "introduction": "嵌入方案的选择——即量子区域如何“感受”分子力学环境——直接影响预测的分子结构和性质。本练习要求您通过数值方法研究在一个模型系统上，机械嵌入和静电嵌入对其几何构型的影响 。通过这个编程实践，您将量化静电相互作用如何通过改变键长来移动化学平衡。",
            "id": "3799213",
            "problem": "你需要实现一个数值优化，以分析量子力学/分子力学 (QM/MM) 方法中嵌入方案的选择如何影响电荷分离中间体的优化几何构型。需要比较的两种嵌入方案是机械嵌入和静电嵌入。该研究必须在 Born-Oppenheimer 近似的框架下，并采用标准的 QM/MM 总势能划分方案进行。你将把分子处理为一个线性三原子体系，原子标记为 $A$、$B$ 和 $C$，并考虑两个关键键长：$A$ 和 $B$ 之间的 $r_1$，以及 $B$ 和 $C$ 之间的 $r_2$。分析的目标是量化由于量子力学区域与外部自分子力学环境之间静电相互作用的存在与否，所导致的优化键长 $r_1$ 和 $r_2$ 的变化。\n\n使用的基本原理和定义：\n- 在 Born-Oppenheimer 近似下，对于固定的原子核位置，电子能量被最小化，原子核在所得的势能面上运动。\n- 在量子力学/分子力学 (QM/MM) 中，总势能被分解为量子力学自由度和经典分子力学自由度的贡献，以及它们之间的相互作用项。\n- 在机械嵌入中，量子力学区域不感受来自自分子力学环境的显式静电场；在静电嵌入中，量子力学区域受到分子力学点电荷产生的外部静电场的影响。\n- 能量和力必须由经过充分测试且具有物理意义的模型来定义。所有数学构建都必须是科学上合理且一致的。\n\n几何构型与建模假设：\n- 该三原子体系是线性的，原子位置沿一条直线分布，分别为 $x_A = 0$、$x_B = r_1$ 和 $x_C = r_1 + r_2$。\n- 每个键的量子力学能量由一个莫尔斯势表示。键之间存在一个弱的交叉耦合项，反映了电荷分离中间体中的振动耦合。嵌入方案影响量子力学区域是否与代表分子力学环境的固定点电荷发生静电相互作用。\n\n你的任务：\n1. 对于给定的参数集，定义机械嵌入下的总势能和静电嵌入下的总势能。\n2. 在物理上合理的键长边界条件下，对每个总势能相对于键长 $r_1$ 和 $r_2$ 进行数值最小化。\n3. 计算优化后键长的差异，定义为 $\\Delta r_1 = r_{1,\\mathrm{elec}} - r_{1,\\mathrm{mech}}$ 和 $\\Delta r_2 = r_{2,\\mathrm{elec}} - r_{2,\\mathrm{mech}}$。\n4. 以埃为单位报告差异，四舍五入到小数点后四位。\n\n单位：\n- 键长必须以埃为单位表示，差异 $\\Delta r_1$ 和 $\\Delta r_2$ 必须以埃为单位报告，并四舍五入到小数点后四位。\n- 能量必须以一致的方式计算；如果使用点电荷之间的库仑相互作用，请确保使用物理上一致的常数和单位，以使最小化具有物理意义。\n\n测试套件：\n实现以下三个测试用例来验证你的程序。在所有情况下，分子都是相同的线性三原子体系，量子力学区域由带有部分电荷 $q_A$、$q_B$ 和 $q_C$ 的原子 $A$、$B$ 和 $C$ 组成。分子力学环境是一组固定的点电荷，其大小和位置在同一条直线上指定。为便于解决此问题，莫尔斯势中的平衡键长是指定的；优化的初始猜测值应取这些平衡值。\n\n- 测试用例 1（一般情况）：\n  - 量子力学莫尔斯势参数：\n    - 键 $A\\text{-}B$：势阱深度 $D_1 = 80.0$，刚度 $a_1 = 2.0$，平衡长度 $r_{e1} = 1.35$。\n    - 键 $B\\text{-}C$：势阱深度 $D_2 = 100.0$，刚度 $a_2 = 2.5$，平衡长度 $r_{e2} = 1.10$。\n  - 交叉耦合系数：$k_{\\mathrm{cross}} = 3.0$。\n  - 量子力学部分电荷：$q_A = 0.8$，$q_B = 0.1$，$q_C = -0.9$。\n  - 分子力学环境（点电荷及其位置）：$(-0.5, 5.0)$ 和 $(+0.5, -3.0)$。\n  - 键长边界：$r_1 \\in [0.7, 2.5]$，$r_2 \\in [0.7, 2.5]$。\n\n- 测试用例 2（可忽略场的边界情况）：\n  - 量子力学莫尔斯势参数和交叉耦合系数与测试用例 1 相同。\n  - 量子力学部分电荷与测试用例 1 相同。\n  - 分子力学环境：空集（无外部点电荷）。\n  - 键长边界：$r_1 \\in [0.7, 2.5]$，$r_2 \\in [0.7, 2.5]$。\n\n- 测试用例 3（强场情况）：\n  - 量子力学莫尔斯势参数和交叉耦合系数与测试用例 1 相同。\n  - 量子力学部分电荷与测试用例 1 相同。\n  - 分子力学环境：$(-1.0, 2.2)$、$(+1.0, 12.0)$ 和 $(-0.3, 6.5)$。\n  - 键长边界：$r_1 \\in [0.7, 2.5]$，$r_2 \\in [0.7, 2.5]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个测试用例的结果，即测试用例 1 的两个差异 $\\Delta r_1$ 和 $\\Delta r_2$，然后是测试用例 2 的，再然后是测试用例 3 的。例如，输出形式应为“[dr1_case1,dr2_case1,dr1_case2,dr2_case2,dr1_case3,dr2_case3]”，其中每个条目都是一个四舍五入到小数点后四位并以埃为单位表示的浮点数。",
            "solution": "该问题陈述已经过严格验证，被认为是科学上可靠、定义明确且客观的。它呈现了一个计算化学中简化但标准的练习，特别是在多尺度量子力学/分子力学 (QM/MM) 建模领域。任务是通过与机械嵌入方案进行比较，来量化静电嵌入对一个模型三原子体系几何构型的影响。该问题需要对两个不同的势能面进行数值最小化。\n\n虽然该问题在根本上是定义明确的，但它省略了键-键交叉耦合项的显式函数形式以及能量参数的单位。这些疏漏并不会使问题无效，因为存在标准惯例，并且问题要求“能量必须以一致的方式计算”。在此将采用的最科学合理的解释是，使用双线性伸缩-伸缩相互作用项（这是分子力场中的常见选择），并采用分子建模中标准的一致单位制：能量单位为千卡/摩尔（$\\mathrm{kcal}/\\mathrm{mol}$），距离单位为埃（$\\mathrm{\\AA}$），电荷单位为基本电荷单位（$e$）。\n\n线性三原子分子 $A\\text{-}B\\text{-}C$ 的几何构型由两个键长 $r_1 = d(A,B)$ 和 $r_2 = d(B,C)$ 定义。沿坐标轴的原子位置为 $x_A = 0$，$x_B = r_1$ 和 $x_C = r_1 + r_2$。\n\n在 Born-Oppenheimer 近似内，总势能是这些原子核坐标的函数。在 QM/MM 的背景下，该能量被划分。我们关心的是依赖于 QM 区域几何构型的项，即内部 QM 能量 $U_{\\mathrm{QM}}(r_1, r_2)$，以及 QM 和 MM 区域之间的静电相互作用能 $U_{\\mathrm{QM/MM,elec}}(r_1, r_2)$。需要最小化的总能量为 $E(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) + U_{\\mathrm{QM/MM,elec}}(r_1, r_2)$。\n\n两种嵌入方案通过是否包含 $U_{\\mathrm{QM/MM,elec}}$ 项来定义。\n\n**1. 机械嵌入势能**\n\n在机械嵌入中，QM 区域不感受 MM 环境的静电场。需要最小化的势能 $E_{\\mathrm{mech}}$ 仅为 QM 区域的内部能量：\n$$ E_{\\mathrm{mech}}(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) $$\n该内部能量被建模为两个键的莫尔斯势和一个交叉耦合项之和：\n$$ U_{\\mathrm{QM}}(r_1, r_2) = V_{\\mathrm{Morse},1}(r_1) + V_{\\mathrm{Morse},2}(r_2) + V_{\\mathrm{cross}}(r_1, r_2) $$\n每个莫尔斯势由以下公式给出：\n$$ V_{\\mathrm{Morse},i}(r_i) = D_i (1 - e^{-a_i (r_i - r_{ei})})^2 $$\n其中 $D_i$ 是势阱深度，$a_i$ 是刚度参数，$r_{ei}$ 是平衡键长。交叉耦合项建模为：\n$$ V_{\\mathrm{cross}}(r_1, r_2) = k_{\\mathrm{cross}}(r_1 - r_{e1})(r_2 - r_{e2}) $$\n其中 $k_{\\mathrm{cross}}$ 是耦合力常数。\n\n**2. 静电嵌入势能**\n\n在静电嵌入中，QM 电子和原子核被 MM 电荷的静电场极化。势能 $E_{\\mathrm{elec}}$ 包括静电相互作用项：\n$$ E_{\\mathrm{elec}}(r_1, r_2) = U_{\\mathrm{QM}}(r_1, r_2) + U_{\\mathrm{QM/MM,elec}}(r_1, r_2) $$\n相互作用项 $U_{\\mathrm{QM/MM,elec}}$ 是 QM 原子（$q_A, q_B, q_C$）的部分电荷与 MM 环境的固定点电荷之间的库仑相互作用之和：\n$$ U_{\\mathrm{QM/MM,elec}}(r_1, r_2) = k_e \\sum_{i \\in \\{A,B,C\\}} \\sum_{j \\in \\mathrm{MM}} \\frac{q_i q_j}{|x_i - x_{j,\\mathrm{MM}}|} $$\n这里，$q_i$ 和 $x_i$ 是第 $i$ 个 QM 原子的电荷和位置，$q_j$ 和 $x_{j,\\mathrm{MM}}$ 是第 $j$ 个 MM 点电荷的电荷和位置，$k_e$ 是库仑常数。为保证单位一致性（能量单位 $\\mathrm{kcal}/\\mathrm{mol}$，距离单位 $\\mathrm{\\AA}$，电荷单位 $e$），我们使用 $k_e = 332.0637 \\, \\frac{\\mathrm{kcal}}{\\mathrm{mol}} \\frac{\\mathrm{\\AA}}{e^2}$。因此，势能参数的单位为：$D_i$ 的单位是 $\\mathrm{kcal}/\\mathrm{mol}$，$a_i$ 的单位是 $\\mathrm{\\AA}^{-1}$，$k_{\\mathrm{cross}}$ 的单位是 $\\mathrm{kcal}/(\\mathrm{mol} \\cdot \\mathrm{\\AA}^2)$。\n\n**3. 数值优化**\n\n对于每个测试用例，我们找到最小化 $E_{\\mathrm{mech}}(r_1, r_2)$ 的优化键长 $(r_{1,\\mathrm{mech}}, r_{2,\\mathrm{mech}})$ 和最小化 $E_{\\mathrm{elec}}(r_1, r_2)$ 的键长 $(r_{1,\\mathrm{elec}}, r_{2,\\mathrm{elec}})$。这是一个非线性优化问题：\n$$ (r_{1,\\mathrm{opt}}, r_{2,\\mathrm{opt}}) = \\arg\\min_{r_1, r_2} E(r_1, r_2) $$\n优化使用 `L-BFGS-B` 算法进行数值计算，该算法适用于带箱式约束的准牛顿优化。搜索范围被限制在物理上合理的边界 $r_1, r_2 \\in [0.7, 2.5] \\, \\mathrm{\\AA}$ 内。优化的初始猜测值设为平衡键长 $(r_{e1}, r_{e2})$。\n\n**4. 最终差异计算**\n\n在获得两种嵌入方案的优化几何构型后，由静电环境引起的键长变化计算如下：\n$$ \\Delta r_1 = r_{1,\\mathrm{elec}} - r_{1,\\mathrm{mech}} $$\n$$ \\Delta r_2 = r_{2,\\mathrm{elec}} - r_{2,\\mathrm{mech}} $$\n对每个测试用例计算这些差异，并报告到小数点后四位。对于测试用例 2，其中 MM 环境为空，$U_{\\mathrm{QM/MM,elec}} = 0$，导致 $E_{\\mathrm{elec}} = E_{\\mathrm{mech}}$。因此，我们预期 $\\Delta r_1 = 0$ 和 $\\Delta r_2 = 0$，这为该方法提供了一个可靠的内部检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM geometry optimization problem for three test cases.\n    \"\"\"\n    # Coulomb's constant in units of (kcal/mol) * Angstrom / e^2\n    COULOMB_K = 332.0637\n\n    def energy_qm(r, qm_params):\n        \"\"\"Calculates the internal QM energy.\"\"\"\n        r1, r2 = r\n        D1, a1, re1, D2, a2, re2, k_cross = qm_params\n        v_morse1 = D1 * (1 - np.exp(-a1 * (r1 - re1)))**2\n        v_morse2 = D2 * (1 - np.exp(-a2 * (r2 - re2)))**2\n        v_cross = k_cross * (r1 - re1) * (r2 - re2)\n        return v_morse1 + v_morse2 + v_cross\n\n    def energy_qmmm_elec(r, qm_charges, mm_env):\n        \"\"\"Calculates the QM/MM electrostatic interaction energy.\"\"\"\n        r1, r2 = r\n        qA, qB, qC = qm_charges\n        \n        # Atomic positions\n        xA = 0.0\n        xB = r1\n        xC = r1 + r2\n        \n        qm_atoms = [\n            {'charge': qA, 'pos': xA},\n            {'charge': qB, 'pos': xB},\n            {'charge': qC, 'pos': xC}\n        ]\n        \n        e_elec = 0.0\n        for q_mm, x_mm in mm_env:\n            for qm_atom in qm_atoms:\n                dist = np.abs(qm_atom['pos'] - x_mm)\n                # This check avoids division by zero, though unlikely with the given test cases.\n                if dist  1e-12:\n                    return np.inf\n                e_elec += COULOMB_K * qm_atom['charge'] * q_mm / dist\n                \n        return e_elec\n\n    def total_energy_mech(r, params):\n        \"\"\"Total energy for mechanical embedding.\"\"\"\n        return energy_qm(r, params['qm_params'])\n\n    def total_energy_elec(r, params):\n        \"\"\"Total energy for electrostatic embedding.\"\"\"\n        e_qm = energy_qm(r, params['qm_params'])\n        e_qmmm = energy_qmmm_elec(r, params['qm_charges'], params['mm_env'])\n        return e_qm + e_qmmm\n\n    test_cases = [\n        { # Test Case 1\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [(-0.5, 5.0), (0.5, -3.0)],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        },\n        { # Test Case 2\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        },\n        { # Test Case 3\n            'qm_params': (80.0, 2.0, 1.35, 100.0, 2.5, 1.10, 3.0),\n            'qm_charges': (0.8, 0.1, -0.9),\n            'mm_env': [(-1.0, 2.2), (1.0, 12.0), (-0.3, 6.5)],\n            'bounds': [(0.7, 2.5), (0.7, 2.5)]\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        re1 = case_params['qm_params'][2]\n        re2 = case_params['qm_params'][5]\n        initial_guess = [re1, re2]\n        bounds = case_params['bounds']\n\n        # Mechanical embedding optimization\n        res_mech = minimize(total_energy_mech, initial_guess, args=(case_params,), method='L-BFGS-B', bounds=bounds)\n        r1_mech, r2_mech = res_mech.x\n\n        # Electrostatic embedding optimization\n        res_elec = minimize(total_energy_elec, initial_guess, args=(case_params,), method='L-BFGS-B', bounds=bounds)\n        r1_elec, r2_elec = res_elec.x\n\n        # Calculate and store differences\n        dr1 = r1_elec - r1_mech\n        dr2 = r2_elec - r2_mech\n        \n        results.append(round(dr1, 4))\n        results.append(round(dr2, 4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个成功的 QM/MM 模拟在很大程度上依赖于对 QM-MM 边界处非键相互作用的精确描述。这个高级练习将指导您完成该相互作用中 Lennard-Jones 部分的参数化过程，这是力场开发中的一项常见任务 。通过拟合参数以再现参考的量子力学力，您将学到一项构建稳健可靠的多尺度模型的基本技术。",
            "id": "3799215",
            "problem": "您的任务是构建并实现一个协议，在量子力学/分子力学 (QM/MM) 设置中校准交叉相互作用的 Lennard-Jones 参数，方法是在一个二聚体构型的训练集上，最小化混合 QM/MM 径向力与参考量子力学 (QM) 径向力之间的偏差。量子力学/分子力学 (QM/MM) 指的是一种多尺度建模方法，其中系统的子集用量子力学哈密顿量处理，而其余部分用经典力场处理。在这个简化的校准任务中，您将把 QM-MM 非键交叉相互作用处理为单个 QM 原子和单个 MM 原子之间的经典 Lennard-Jones 对势，并拟合交叉参数，以在多个分子间距上重现沿原子间轴的参考 QM 径向力投影。\n\n从以下基本要素开始：\n- 两个位点间距为 $r$ 时的 Lennard-Jones 对势由 $V(r) = 4 \\epsilon \\left[ \\left( \\dfrac{\\sigma}{r} \\right)^{12} - \\left( \\dfrac{\\sigma}{r} \\right)^6 \\right]$ 给出，其中 $\\sigma$ 和 $\\epsilon$ 是分别表征有限尺寸排斥和势阱深度的正常数。\n- 保守力是势能的负梯度，因此沿连接两个位点的直线的径向力为 $F(r) = - \\dfrac{dV}{dr}$。\n- 在此校准问题中，损失函数是模型径向力与参考 QM 径向力值在整个训练集构型上的平方偏差之和。\n\n您必须实现一个完整的程序，为每个提供的训练集解决以下参数估计问题：\n- 给定原子间距 $\\{ r_k \\}_{k=1}^{N}$ 和相关的参考 QM 力 $\\{ F_k^{\\mathrm{ref}} \\}_{k=1}^{N}$，找到参数 $\\sigma  0$ 和 $\\epsilon  0$，使目标函数最小化\n$$\n\\mathcal{L}(\\sigma,\\epsilon) \\;=\\; \\sum_{k=1}^{N} \\left( F(r_k;\\sigma,\\epsilon) \\;-\\; F_k^{\\mathrm{ref}} \\right)^2,\n$$\n其中 $F(r;\\sigma,\\epsilon)$ 是由势能 $V(r)$ 蕴含的 Lennard-Jones 径向力，所有量都是沿原子间轴的标量径向投影。\n- 在优化过程中，使用数学上适定的变换来强制执行物理约束 $\\sigma  0$ 和 $\\epsilon  0$。\n\n仅根据力是势能负梯度的基本定义，从 $V(r)$ 推导出 $F(r;\\sigma,\\epsilon)$。除了 $V(r)$ 和力的定义之外，不要假设任何预先给定的表达式。\n\n物理和数值单位：\n- 距离单位必须是埃 ($\\mathrm{\\AA}$)。\n- 能量单位必须是千焦耳每摩尔 ($\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$)。\n- 力单位必须是千焦耳每摩尔每埃 ($\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{\\AA}^{-1}$)。\n- 最终拟合的 $\\sigma$ 以 $\\mathrm{\\AA}$ 表示，$\\epsilon$ 以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 表示。\n\n测试套件：\n对于下方的每个测试用例，参考 QM 力将使用您推导的相同力定义，通过具有指定 $(\\sigma^\\star,\\epsilon^\\star)$ 的基准 Lennard-Jones 模型综合生成。您不得硬编码参考力；相反，应根据提供的 $(\\sigma^\\star,\\epsilon^\\star)$ 和列出的距离计算它们。\n\n- 测试用例 1（中等势阱，宽覆盖范围）：\n  - 基准参数：$\\sigma^\\star = 3.5\\,\\mathrm{\\AA}$，$\\epsilon^\\star = 0.5\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - 距离：$\\{ 2.8, 3.0, 3.2, 3.5, 4.0, 5.0, 6.0 \\}\\,\\mathrm{\\AA}$。\n\n- 测试用例 2（极弱吸引力，强调长程尾部）：\n  - 基准参数：$\\sigma^\\star = 3.8\\,\\mathrm{\\AA}$，$\\epsilon^\\star = 0.05\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - 距离：$\\{ 3.2, 3.6, 4.0, 5.0, 7.0, 8.0 \\}\\,\\mathrm{\\AA}$。\n\n- 测试用例 3（排斥主导的近接触区域）：\n  - 基准参数：$\\sigma^\\star = 3.2\\,\\mathrm{\\AA}$，$\\epsilon^\\star = 0.6\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n  - 距离：$\\{ 2.5, 2.7, 2.9, 3.1, 3.3, 3.5 \\}\\,\\mathrm{\\AA}$。\n\n算法要求：\n- 使用非线性最小二乘求解器为每个测试用例分别最小化 $\\mathcal{L}(\\sigma,\\epsilon)$。\n- 通过在变换变量（例如对数）中进行优化来强制执行 $\\sigma  0$ 和 $\\epsilon  0$，从而使搜索空间无约束但能映射到正的物理参数。\n- 提供残差相对于变换变量的解析雅可比矩阵，以提高鲁棒性和可复现性。\n- 对所有情况使用固定的确定性初始猜测值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 该列表必须按顺序包含测试用例 1、测试用例 2、然后是测试用例 3 的校准后 $\\sigma$ 和 $\\epsilon$。\n- 每个数字必须四舍五入到恰好六位小数，$\\sigma$ 的单位是 $\\mathrm{\\AA}$，$\\epsilon$ 的单位是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 具体而言，输出格式为\n$[ \\sigma_{1}, \\epsilon_{1}, \\sigma_{2}, \\epsilon_{2}, \\sigma_{3}, \\epsilon_{3} ]$\n每个条目打印到六位小数。\n\n您的实现必须是自包含的，不需要用户输入，并严格遵守上述输出格式。",
            "solution": "此问题已经过验证，被认为是有效的。它在科学上基于经典力学和统计力学的原理，特别是使用 Lennard-Jones 势来模拟非键原子间相互作用，这是分子力学力场的基石。该问题被明确表述为一个使用非线性最小二乘优化的参数估计任务，这是计算科学中的一种标准技术。所有必需的数据、模型和约束都已提供，使得问题自洽且明确。没有事实错误、逻辑矛盾或主观因素。\n\n校准 Lennard-Jones (LJ) 交叉相互作用参数 $\\sigma$ 和 $\\epsilon$ 的协议，涉及最小化模型预测力与参考量子力学 (QM) 力之间的平方差之和。详细的推导和实现步骤如下。\n\n首先，必须从 Lennard-Jones 势 $V(r)$ 推导出径向力 $F(r)$ 的解析表达式。势能由以下公式给出：\n$$\nV(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right] = 4 \\epsilon \\left( \\sigma^{12}r^{-12} - \\sigma^6 r^{-6} \\right)\n$$\n保守力是势能的负梯度。对于球对称势，径向力为 $F(r) = - \\frac{dV(r)}{dr}$。我们计算其导数：\n$$\n\\frac{dV}{dr} = 4 \\epsilon \\frac{d}{dr} \\left( \\sigma^{12}r^{-12} - \\sigma^6 r^{-6} \\right)\n$$\n$$\n\\frac{dV}{dr} = 4 \\epsilon \\left( \\sigma^{12}(-12)r^{-13} - \\sigma^6(-6)r^{-7} \\right) = 4 \\epsilon \\left( -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right)\n$$\n因此，力 $F(r)$ 为：\n$$\nF(r) = - \\frac{dV}{dr} = -4 \\epsilon \\left( -12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7} \\right) = 4 \\epsilon \\left( 12 \\frac{\\sigma^{12}}{r^{13}} - 6 \\frac{\\sigma^6}{r^7} \\right)\n$$\n这个表达式可以重写为更紧凑的形式：\n$$\nF(r; \\sigma, \\epsilon) = \\frac{24 \\epsilon}{r} \\left[ 2 \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]\n$$\n这是模型力函数。目标是找到参数 $\\sigma  0$ 和 $\\epsilon  0$，以在一个包含 $N$ 个构型（距离为 $\\{r_k\\}_{k=1}^N$，参考力为 $\\{F_k^{\\text{ref}}\\}_{k=1}^N$）的训练集上最小化损失函数 $\\mathcal{L}(\\sigma,\\epsilon)$：\n$$\n\\mathcal{L}(\\sigma,\\epsilon) = \\sum_{k=1}^{N} \\left( F(r_k; \\sigma, \\epsilon) - F_k^{\\text{ref}} \\right)^2\n$$\n这是一个非线性最小二乘问题。物理约束 $\\sigma  0$ 和 $\\epsilon  0$ 通过变量替换来处理。我们定义新的无约束参数 $p_1$ 和 $p_2$ 如下：\n$$\n\\sigma = e^{p_1} \\quad \\text{和} \\quad \\epsilon = e^{p_2}\n$$\n然后，优化在实值参数 $p_1, p_2 \\in \\mathbb{R}$ 上执行。最小二乘求解器旨在最小化其 $L_2$ 范数的残差向量由 $R_k(p_1,p_2) = F(r_k; e^{p_1}, e^{p_2}) - F_k^{\\text{ref}}$ 给出。\n\n为确保稳健高效的收敛，我们必须为求解器提供残差向量相对于变换参数的解析雅可比矩阵。雅可比矩阵 $J$ 的元素为 $J_{ki} = \\frac{\\partial R_k}{\\partial p_i}$。由于 $F_k^{\\text{ref}}$ 是相对于参数的常数，这简化为 $J_{ki} = \\frac{\\partial F(r_k; p_1, p_2)}{\\partial p_i}$。\n\n让我们推导这些偏导数。首先，关于 $p_1 = \\ln(\\sigma)$：\n使用链式法则，$\\frac{\\partial F}{\\partial p_1} = \\frac{\\partial F}{\\partial \\sigma} \\frac{\\partial \\sigma}{\\partial p_1} = \\frac{\\partial F}{\\partial \\sigma} e^{p_1} = \\sigma \\frac{\\partial F}{\\partial \\sigma}$。\n$$\n\\frac{\\partial F}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma} \\left[ 4 \\epsilon \\left( 12 \\frac{\\sigma^{12}}{r^{13}} - 6 \\frac{\\sigma^6}{r^7} \\right) \\right] = 4 \\epsilon \\left( 12 \\frac{12 \\sigma^{11}}{r^{13}} - 6 \\frac{6 \\sigma^5}{r^7} \\right) = 4 \\epsilon \\left( 144 \\frac{\\sigma^{11}}{r^{13}} - 36 \\frac{\\sigma^5}{r^7} \\right)\n$$\n因此，雅可比矩阵元素为：\n$$\nJ_{k1} = \\sigma \\cdot \\left[ 4 \\epsilon \\left( 144 \\frac{\\sigma^{11}}{r_k^{13}} - 36 \\frac{\\sigma^5}{r_k^7} \\right) \\right] = 4 \\epsilon \\left( 144 \\frac{\\sigma^{12}}{r_k^{13}} - 36 \\frac{\\sigma^6}{r_k^7} \\right)\n$$\n$$\nJ_{k1} = \\frac{144 \\epsilon}{r_k} \\left[ 4 \\left(\\frac{\\sigma}{r_k}\\right)^{12} - \\left(\\frac{\\sigma}{r_k}\\right)^6 \\right]\n$$\n\n接下来，我们推导关于 $p_2 = \\ln(\\epsilon)$ 的偏导数：\n$\\frac{\\partial F}{\\partial p_2} = \\frac{\\partial F}{\\partial \\epsilon} \\frac{\\partial \\epsilon}{\\partial p_2} = \\frac{\\partial F}{\\partial \\epsilon} e^{p_2} = \\epsilon \\frac{\\partial F}{\\partial \\epsilon}$。\n力 $F$ 与 $\\epsilon$ 线性成正比：$F(\\sigma, \\epsilon) = \\epsilon \\cdot F(\\sigma, \\epsilon=1)$。因此，$\\frac{\\partial F}{\\partial \\epsilon} = \\frac{F}{\\epsilon}$。\n$$\nJ_{k2} = \\frac{\\partial F_k}{\\partial p_2} = \\epsilon \\cdot \\frac{F(r_k; \\sigma, \\epsilon)}{\\epsilon} = F(r_k; \\sigma, \\epsilon)\n$$\n这个非常简洁的结果完成了我们的雅可比矩阵。对于每个距离 $r_k$，雅可比矩阵的两列分别是如上推导的 $\\frac{\\partial F_k}{\\partial p_1}$ 和 $\\frac{\\partial F_k}{\\partial p_2}$，其中 $\\sigma=e^{p_1}$ 且 $\\epsilon=e^{p_2}$。\n\n该解决方案的实现包括针对每个测试用例的以下步骤：\n1.  使用提供的基准参数 $(\\sigma^\\star, \\epsilon^\\star)$ 和推导出的力表达式 $F(r; \\sigma, \\epsilon)$ 生成合成参考力数据 $\\{F_k^{\\text{ref}}\\}$。\n2.  定义残差向量和雅可比矩阵的函数，两者都以变换后的参数向量 $\\vec{p} = [p_1, p_2]$ 作为输入。\n3.  为优化器选择一个固定的初始猜测值。对所有情况都使用一个物理上合理的猜测值，如 $\\sigma_0 = 3.0 \\, \\mathrm{\\AA}$ 和 $\\epsilon_0 = 0.5 \\, \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，这对应于初始变换参数向量 $\\vec{p}_0 = [\\ln(3.0), \\ln(0.5)]$。\n4.  利用 `scipy.optimize.least_squares` 函数，向其提供残差函数、初始猜测值和解析雅可比矩阵函数。\n5.  从求解器的结果中提取优化后的变换参数 $\\vec{p}_{\\text{opt}}$。\n6.  将优化后的参数转换回物理表示：$\\sigma_{\\text{fit}} = e^{p_{1, \\text{opt}}}$ 和 $\\epsilon_{\\text{fit}} = e^{p_{2, \\text{opt}}}$。\n7.  收集并按规定格式化结果。由于参考数据是由待拟合的同一模型生成的，因此预期优化过程能够高精度地恢复基准参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the Lennard-Jones parameter calibration problem for three test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (ground_truth_sigma, ground_truth_epsilon, distances)\n    test_cases = [\n        (3.5, 0.5, [2.8, 3.0, 3.2, 3.5, 4.0, 5.0, 6.0]),  # Test case 1\n        (3.8, 0.05, [3.2, 3.6, 4.0, 5.0, 7.0, 8.0]),      # Test case 2\n        (3.2, 0.6, [2.5, 2.7, 2.9, 3.1, 3.3, 3.5]),       # Test case 3\n    ]\n\n    # This function is defined once and used for all calculations.\n    def lj_force(r, sigma, epsilon):\n        \"\"\"\n        Calculates the Lennard-Jones radial force.\n        F(r) = 24*eps/r * [2*(sigma/r)^12 - (sigma/r)^6]\n        A positive force is repulsive, a negative force is attractive.\n        \"\"\"\n        if np.any(r = 0) or sigma = 0 or epsilon = 0:\n            # Handle non-physical inputs to prevent division by zero or errors\n            # Return high values to steer optimizer away\n            return np.full_like(r, np.inf)\n\n        r_ratio_sq = (sigma / r)**2\n        r_ratio_6 = r_ratio_sq**3\n        r_ratio_12 = r_ratio_6**2\n        \n        force = (24.0 * epsilon / r) * (2.0 * r_ratio_12 - r_ratio_6)\n        return force\n\n    all_results = []\n    \n    # A fixed deterministic initial guess for the transformed parameters [ln(sigma), ln(epsilon)]\n    # Corresponds to sigma=3.0 Angstrom, epsilon=0.5 kJ/mol\n    p0 = np.array([np.log(3.0), np.log(0.5)])\n\n    for sigma_star, epsilon_star, r_values in test_cases:\n        r_k = np.array(r_values)\n\n        # Generate the reference QM forces synthetically\n        F_ref = lj_force(r_k, sigma_star, epsilon_star)\n\n        def residuals_func(p, r_data, F_ref_data):\n            \"\"\"\n            Calculates the vector of residuals: F_model(p) - F_ref.\n            p = [ln(sigma), ln(epsilon)]\n            \"\"\"\n            sigma_fit = np.exp(p[0])\n            epsilon_fit = np.exp(p[1])\n            F_model = lj_force(r_data, sigma_fit, epsilon_fit)\n            return F_model - F_ref_data\n\n        def jacobian_func(p, r_data, F_ref_data):\n            \"\"\"\n            Calculates the Jacobian of the residuals with respect to p.\n            p = [ln(sigma), ln(epsilon)]\n            The Jacobian has shape (N_data, 2).\n            \"\"\"\n            sigma_fit = np.exp(p[0])\n            epsilon_fit = np.exp(p[1])\n\n            # Pre-calculate common terms for efficiency\n            r_ratio_sq = (sigma_fit / r_data)**2\n            r_ratio_6 = r_ratio_sq**3\n            r_ratio_12 = r_ratio_6**2\n            \n            # Jacobian column 1: d(Residual)/d(p[0]) = d(F_model)/d(ln(sigma))\n            # dF/d(ln(sigma)) = 144*eps/r * [4*(sigma/r)^12 - (sigma/r)^6]\n            dF_dp1 = (144.0 * epsilon_fit / r_data) * (4.0 * r_ratio_12 - r_ratio_6)\n\n            # Jacobian column 2: d(Residual)/d(p[1]) = d(F_model)/d(ln(epsilon))\n            # dF/d(ln(epsilon)) = F_model\n            dF_dp2 = lj_force(r_data, sigma_fit, epsilon_fit)\n            \n            # Combine columns and transpose to get (N_data, 2) shape\n            return np.array([dF_dp1, dF_dp2]).T\n\n        # Perform the non-linear least-squares optimization\n        result = least_squares(\n            fun=residuals_func,\n            x0=p0,\n            jac=jacobian_func,\n            args=(r_k, F_ref),\n            method='lm',  # Levenberg-Marquardt is robust\n            gtol=1e-12,\n            xtol=1e-12,\n            ftol=1e-12\n        )\n        \n        # Extract optimized transformed parameters\n        p_opt = result.x\n        \n        # Convert back to physical parameters\n        sigma_fit = np.exp(p_opt[0])\n        epsilon_fit = np.exp(p_opt[1])\n        \n        all_results.extend([sigma_fit, epsilon_fit])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'{val:.6f}' for val in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}