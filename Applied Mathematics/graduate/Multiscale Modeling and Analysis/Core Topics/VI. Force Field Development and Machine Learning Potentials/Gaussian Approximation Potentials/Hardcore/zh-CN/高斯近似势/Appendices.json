{
    "hands_on_practices": [
        {
            "introduction": "高斯近似势（GAP）的核心是局域性原理，即一个原子的能量主要由其周围的原子环境决定。因此，在实践中应用GAP的第一步就是精确地定义和识别每个原子的“局域环境”。本练习将指导您完成这项基本任务：为周期性体系中的原子构建近邻列表 ()。通过为通用的三斜晶胞实现最小镜像约定，您将掌握材料建模中的一项关键编程技能。",
            "id": "3763478",
            "problem": "给定一个由晶格基矢和一组原子位置定义的三维周期性原子构型。目标是，根据第一性原理，为给定的截断半径 $r_c$ 构建周期性边界条件下的近邻列表，并阐明该近邻列表如何作为高斯近似势 (GAP) 中使用的局域原子环境 $\\mathcal{X}_i$ 的基础输入。推导必须从晶体周期性的定义和晶格基矢导出的度量标准开始，并逻辑地推导出应如何实现。\n\n使用以下基本依据：\n- 周期性：如果空间中两点的差异为晶格基矢的整数线性组合，则这两点被认为是等效的。如果晶格基矢由一个 $3 \\times 3$ 矩阵 $\\mathbf{A}$ 表示，其列为基矢，那么对于任何 $\\mathbf{n} \\in \\mathbb{Z}^3$，平移 $\\mathbf{x} \\mapsto \\mathbf{x} + \\mathbf{A}\\mathbf{n}$ 都会使晶体保持不变。\n- 在一般的三斜晶格中，距离是在笛卡尔空间中使用欧几里得范数测量的。其导出的度量张量为 $\\mathbf{G} = \\mathbf{A}^\\top \\mathbf{A}$，因此与分数坐标差 $\\Delta \\mathbf{s}$ 相关联的距离平方为 $\\Delta \\mathbf{s}^\\top \\mathbf{G} \\Delta \\mathbf{s}$。\n\n将原子 $i$ 的近邻列表 $\\mathcal{N}(i)$ 定义为所有索引 $j \\ne i$ 的集合，其中原子 $i$ 和原子 $j$ 在周期性边界条件下的最短距离小于或等于截断半径 $r_c$。位置以笛卡尔坐标表示，单位为埃（Angstrom），截断半径 $r_c$ 的单位也为埃。近邻判据必须包含等式，即距离为 $r_{ij} = r_c$ 的原子对应被视为近邻。\n\n您必须实现一个程序，该程序：\n1. 对每个测试用例，计算每个原子 $i$ 在周期性边界条件下的近邻数 $|\\mathcal{N}(i)|$。\n2. 使用与一般三斜晶胞一致的最小镜像约定。将位置表示为分数坐标 $\\mathbf{s}_i = \\mathbf{A}^{-1}\\mathbf{x}_i$，并使用整数晶格平移来确定笛卡尔坐标中最短的原子间矢量，然后使用欧几里得范数和截断半径 $r_c$ 来决定是否将其纳入近邻。\n3. 在注释或附带的推导中，概述所得到的近邻列表如何为高斯近似势 (GAP) 定义局域环境 $\\mathcal{X}_i$，包括哪些数据进入 $\\mathcal{X}_i$ 以及它们将如何用于典型的二体或更高阶描述符中。程序的输出必须仅为下面指定的数值结果。\n\n物理单位：所有距离和截断半径 $r_c$ 都必须以埃（Angstroms）为单位处理。本任务中不需要角度。\n\n测试套件：\n为以下四个测试用例提供结果。\n\n- 测试用例 1（立方，典型情况）：\n  - 晶格矩阵 $\\mathbf{A} = \\mathrm{diag}(5.0, 5.0, 5.0)$ 埃。\n  - 笛卡尔坐标 $\\mathbf{x}_1 = (0.5, 0.5, 0.5)$ 埃, $\\mathbf{x}_2 = (2.0, 2.0, 2.0)$ 埃。\n  - 截断半径 $r_c = 3.0$ 埃。\n\n- 测试用例 2（三斜，边界环绕情况）：\n  - 晶格矩阵\n    $$\n    \\mathbf{A} =\n    \\begin{bmatrix}\n    4.0  0.5  0.0 \\\\\n    0.0  3.5  0.5 \\\\\n    0.2  0.0  4.5\n    \\end{bmatrix}\n    \\text{ 埃。}\n    $$\n  - 分数坐标 $\\mathbf{s}_1 = (0.98, 0.50, 0.50)$，$\\mathbf{s}_2 = (0.02, 0.50, 0.50)$，$\\mathbf{s}_3 = (0.50, 0.50, 0.50)$，其笛卡尔坐标由 $\\mathbf{x}_i = \\mathbf{A}\\mathbf{s}_i$ 定义。\n  - 截断半径 $r_c = 2.5$ 埃。\n\n- 测试用例 3（立方，小截断半径边界情况）：\n  - 晶格矩阵 $\\mathbf{A} = \\mathrm{diag}(5.0, 5.0, 5.0)$ 埃。\n  - 笛卡尔坐标 $\\mathbf{x}_1 = (0.5, 0.5, 0.5)$ 埃, $\\mathbf{x}_2 = (2.0, 2.0, 2.0)$ 埃。\n  - 截断半径 $r_c = 1.0$ 埃。\n\n- 测试用例 4（立方，精确边界包含情况）：\n  - 晶格矩阵 $\\mathbf{A} = \\mathrm{diag}(10.0, 10.0, 10.0)$ 埃。\n  - 笛卡尔坐标 $\\mathbf{x}_1 = (0.0, 0.0, 0.0)$ 埃, $\\mathbf{x}_2 = (5.0, 0.0, 0.0)$ 埃。\n  - 截断半径 $r_c = 5.0$ 埃。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，列表中的每个元素对应一个测试用例，并且本身是该用例中每个原子的近邻数列表。例如，对于各有2个原子的四个测试用例，输出格式必须为 $[[n_{1,1},n_{1,2}], [n_{2,1},n_{2,2}], [n_{3,1},n_{3,2}], [n_{4,1},n_{4,2}]]$。对于上述测试套件，每个用例的原子数分别为 $2$、$3$、$2$ 和 $2$。输出必须只包含整数。",
            "solution": "该问题要求为给定的原子构型和截断半径构建周期性近邻列表，并解释其作为高斯近似势 (GAP) 基础输入的作用。解决方案首先建立周期性系统中距离计算的理论框架，然后将此框架应用于提供的测试用例。\n\n### 理论框架\n\n**1. 周期性与坐标系**\n理想的晶体结构由重复的晶胞表征。晶胞的几何形状由一组三个线性无关的晶格基矢 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$ 定义。这些矢量可以作为列组合成一个 $3 \\times 3$ 的晶格矩阵 $\\mathbf{A} = [\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3]$。\n\n晶体中的任何点都可以用笛卡尔坐标 $\\mathbf{x} \\in \\mathbb{R}^3$ 来描述。或者，我们可以使用分数（或晶体）坐标 $\\mathbf{s} \\in \\mathbb{R}^3$，它将位置表示为基矢的线性组合。两种坐标系之间的关系由下式给出：\n$$ \\mathbf{x} = \\mathbf{A}\\mathbf{s} \\quad \\Leftrightarrow \\quad \\mathbf{s} = \\mathbf{A}^{-1}\\mathbf{x} $$\n周期性的定义属性是晶体在晶格矢量任意整数线性组合的平移下保持不变。也就是说，对于任何位置矢量 $\\mathbf{x}$ 和任何整数矢量 $\\mathbf{n} = (n_1, n_2, n_3)^\\top \\in \\mathbb{Z}^3$，点 $\\mathbf{x}' = \\mathbf{x} + \\mathbf{A}\\mathbf{n}$ 在物理上等效于 $\\mathbf{x}$。在分数坐标中，这对应于一个简单的整数矢量平移：$\\mathbf{s}' = \\mathbf{s} + \\mathbf{n}$。\n\n**2. 最小镜像约定**\n要确定位于位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 的两个原子 $i$ 和 $j$ 是否为近邻，我们必须找到原子 $i$ 与原子 $j$ 的任何周期性镜像之间的最短可能距离。原子 $j$ 的周期性镜像位于 $\\mathbf{x}_j'(\\mathbf{n}) = \\mathbf{x}_j + \\mathbf{A}\\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。我们需要找到能使距离 $||\\mathbf{x}_j'(\\mathbf{n}) - \\mathbf{x}_i||$ 最小化的整数矢量 $\\mathbf{n}^*$。\n\n这个最小化问题在分数坐标中最容易解决。连接原子 $i$ 和原子 $j$ 的一个镜像的矢量为 $\\mathbf{r}_{ij}(\\mathbf{n}) = \\mathbf{x}_j'(\\mathbf{n}) - \\mathbf{x}_i = \\mathbf{A}(\\mathbf{s}_j + \\mathbf{n} - \\mathbf{s}_i)$。令 $\\Delta\\mathbf{s} = \\mathbf{s}_j - \\mathbf{s}_i$，则 $\\mathbf{r}_{ij}(\\mathbf{n}) = \\mathbf{A}(\\Delta\\mathbf{s} + \\mathbf{n})$。我们需要找到使该矢量长度最小化的 $\\mathbf{n}^*$。\n\n**最小镜像约定**提供了一种直接方法来找到对应于最短距离的位移矢量的表示。我们寻找一个整数矢量 $\\mathbf{n}$，使得平移后的分数位移 $\\Delta\\mathbf{s}' = \\Delta\\mathbf{s} + \\mathbf{n}$ 的分量位于一个特定域内，通常以原点为中心。通过选择域为 $[-0.5, 0.5]^3$，我们确保考虑的是最近的周期性镜像。这可以通过设置 $\\mathbf{n} = -\\mathrm{round}(\\Delta\\mathbf{s})$ 来实现，其中 `round` 操作逐分量地应用于矢量 $\\Delta\\mathbf{s}$。因此，最小分数位移矢量为：\n$$ \\Delta\\mathbf{s}_\\text{min} = \\Delta\\mathbf{s} - \\mathrm{round}(\\Delta\\mathbf{s}) $$\n$\\Delta\\mathbf{s}_\\text{min}$ 的每个分量都保证在区间 $[-0.5, 0.5]$ 内。然后在笛卡尔坐标中的最短位移矢量可以通过应用晶格矩阵得到：\n$$ \\mathbf{r}_{ij, \\text{min}} = \\mathbf{A} \\Delta\\mathbf{s}_\\text{min} $$\n最后，最短距离的平方是该矢量的欧几里得范数的平方：\n$$ d_{ij}^2 = ||\\mathbf{r}_{ij, \\text{min}}||^2 = \\mathbf{r}_{ij, \\text{min}} \\cdot \\mathbf{r}_{ij, \\text{min}} $$\n\n**3. 近邻列表的构建**\n原子 $i$ 的近邻列表，记为 $\\mathcal{N}(i)$，是所有其他原子 $j$ ($j \\neq i$) 的索引集合，其中最短距离 $d_{ij}$ 小于或等于指定的截断半径 $r_c$。\n$$ \\mathcal{N}(i) = \\{ j \\mid j \\neq i \\land d_{ij} \\le r_c \\} $$\n原子 $i$ 的近邻数是该集合的基数 $|\\mathcal{N}(i)|$。\n\n计算近邻数的算法如下：\n1.  对于给定的原子构型（晶格矩阵 $\\mathbf{A}$ 和原子位置），如果尚未提供分数坐标，则将所有笛卡尔坐标 $\\mathbf{x}_k$ 转换为分数坐标 $\\mathbf{s}_k = \\mathbf{A}^{-1}\\mathbf{x}_k$。\n2.  对于系统中的每个原子 $i$：\n    a. 初始化一个近邻计数器，$C_i = 0$。\n    b. 对于系统中的每个其他原子 $j$ ($j \\neq i$)：\n        i.   计算分数位移矢量：$\\Delta\\mathbf{s} = \\mathbf{s}_j - \\mathbf{s}_i$。\n        ii.  应用最小镜像约定：$\\Delta\\mathbf{s}_\\text{min} = \\Delta\\mathbf{s} - \\mathrm{round}(\\Delta\\mathbf{s})$。\n        iii. 转换为最短笛卡尔位移矢量：$\\mathbf{r}_{ij, \\text{min}} = \\mathbf{A} \\Delta\\mathbf{s}_\\text{min}$。\n        iv.  计算距离平方：$d_{ij}^2 = \\mathbf{r}_{ij, \\text{min}} \\cdot \\mathbf{r}_{ij, \\text{min}}$。\n        v.   检查近邻判据：如果 $d_{ij}^2 \\le r_c^2$，则计数器 $C_i$ 加一。\n3.  该构型的最终结果是所有近邻计数的列表 $[C_0, C_1, \\dots, C_{N-1}]$。\n\n**4. 与高斯近似势 (GAP) 的联系**\n高斯近似势 (Gaussian Approximation Potentials) 与许多其他机器学习的原子间势一样，都建立在局域性原理之上。该原理指出，一个原子 $i$ 的势能 $E_i$ 由其周围原子的排列决定。系统的总能量则近似为这些原子贡献的总和：\n$$ E_\\text{total} \\approx \\sum_{i=1}^{N} E_i(\\mathcal{X}_i) $$\n项 $\\mathcal{X}_i$ 代表原子 $i$ 的**局域原子环境**。近邻列表是用于定义此环境的主要组成部分。形式上，局域环境 $\\mathcal{X}_i$ 是从原子 $i$ 指向其所有近邻 $j \\in \\mathcal{N}(i)$ 的最短位移矢量的集合，通常还会附加上每个原子的化学种类。\n$$ \\mathcal{X}_i = \\{ (\\mathbf{r}_{ij, \\text{min}}, Z_j) \\mid j \\in \\mathcal{N}(i) \\} $$\n其中 $Z_j$ 是原子 $j$ 的原子序数（或元素类型）。\n\n$\\mathcal{X}_i$ 中的原始矢量数据不能直接用于机器学习模型，因为它对于旋转或相同近邻的排列不具有不变性。因此，$\\mathcal{X}_i$ 被转换为一个固定大小、对称性不变的特征向量，称为**描述符**。\n-   **二体描述符**在早期的 GAP 模型中使用，它依赖于距离 $d_{ij} = ||\\mathbf{r}_{ij, \\text{min}}||$。例如，描述符可以是这些距离的直方图，或在这些距离上求值的函数之和。\n-   **多体描述符**，如原子位置光滑重叠 (Smooth Overlap of Atomic Positions, SOAP)，提供了对三维几何形状更完整的描述。SOAP 通过在每个近邻矢量 $\\mathbf{r}_{ij, \\text{min}}$ 的位置放置高斯函数来构建局域原子密度场。然后，该场在径向函数和球谐函数基中展开。得到的展开系数被组合起来，形成一个旋转和排列不变的描述符矢量。\n\n在所有情况下，准确高效地构建近邻列表 $\\mathcal{N}(i)$ 和相应的位移矢量集 $\\{\\mathbf{r}_{ij, \\text{min}}\\}$ 是不可或缺的第一步。它定义了每个原子的“视野”，此步骤中的任何错误或不一致都会直接损害势能模型的保真度。因此，上述算法是现代计算材料建模的基石。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neighbor list problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.diag([5.0, 5.0, 5.0]),\n            \"pos\": np.array([[0.5, 0.5, 0.5], [2.0, 2.0, 2.0]]),\n            \"r_c\": 3.0,\n            \"pos_type\": \"cartesian\"\n        },\n        {\n            \"A\": np.array([\n                [4.0, 0.5, 0.0],\n                [0.0, 3.5, 0.5],\n                [0.2, 0.0, 4.5]\n            ]),\n            \"pos\": np.array([\n                [0.98, 0.50, 0.50],\n                [0.02, 0.50, 0.50],\n                [0.50, 0.50, 0.50]\n            ]),\n            \"r_c\": 2.5,\n            \"pos_type\": \"fractional\"\n        },\n        {\n            \"A\": np.diag([5.0, 5.0, 5.0]),\n            \"pos\": np.array([[0.5, 0.5, 0.5], [2.0, 2.0, 2.0]]),\n            \"r_c\": 1.0,\n            \"pos_type\": \"cartesian\"\n        },\n        {\n            \"A\": np.diag([10.0, 10.0, 10.0]),\n            \"pos\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0]]),\n            \"r_c\": 5.0,\n            \"pos_type\": \"cartesian\"\n        },\n    ]\n\n    results = []\n\n    # The derivation of local atomic environments for GAP is as follows:\n    # 1. For each atom 'i', its neighbor list N(i) is constructed by finding all\n    #    atoms 'j' whose shortest periodic distance d_ij is within a cutoff r_c.\n    #    This is the core calculation performed in this function.\n    # 2. The local atomic environment, X_i, is the set of shortest displacement\n    #    vectors from atom 'i' to its neighbors: X_i = {r_ij | j in N(i)}.\n    # 3. These vectors {r_ij} are inputs to descriptor functions.\n    #    - For two-body terms, only the distances ||r_ij|| are used.\n    #    - For many-body terms (like SOAP), the full 3D vectors {r_ij} are\n    #      used to construct a local atomic density, which is then expanded\n    #      in a basis of spherical harmonics and radial functions to produce\n    #      a rotationally-invariant descriptor vector.\n    # The neighbor list is therefore the fundamental input that defines the\n    # local chemical information processed by the GAP model.\n\n    for case in test_cases:\n        A = case[\"A\"]\n        pos = case[\"pos\"]\n        r_c = case[\"r_c\"]\n        pos_type = case[\"pos_type\"]\n        \n        num_atoms = pos.shape[0]\n        r_c_sq = r_c**2\n\n        # Step 1: Convert Cartesian to fractional coordinates if necessary.\n        if pos_type == \"cartesian\":\n            A_inv = np.linalg.inv(A)\n            # To transform a set of row vectors (N, 3), we compute (X @ A_inv.T)\n            frac_pos = pos @ A_inv.T\n        else: # pos_type == \"fractional\"\n            frac_pos = pos\n\n        neighbor_counts = []\n        for i in range(num_atoms):\n            count = 0\n            for j in range(num_atoms):\n                if i == j:\n                    continue\n\n                # Step 2: Calculate fractional displacement and apply minimum image convention.\n                # delta_s = s_j - s_i\n                delta_s = frac_pos[j] - frac_pos[i]\n                \n                # delta_s_min = delta_s - round(delta_s)\n                # This maps each component to the interval [-0.5, 0.5].\n                delta_s_min = delta_s - np.round(delta_s)\n\n                # Step 3: Convert minimal fractional vector back to Cartesian.\n                # r_ij_min = A * delta_s_min\n                r_ij_min = A @ delta_s_min\n                \n                # Step 4: Calculate squared distance and check against cutoff.\n                d_sq = np.dot(r_ij_min, r_ij_min)\n\n                # The problem requires inclusion on the boundary (r_ij = r_c), so we use =.\n                # A small tolerance is generally wise for float comparisons, but the test\n                # cases are constructed to be exact, so a direct comparison is sufficient.\n                if d_sq = r_c_sq:\n                    count += 1\n            \n            neighbor_counts.append(count)\n        \n        results.append(neighbor_counts)\n\n    # Final print statement in the exact required format.\n    # Using a custom string formatter to avoid spaces after commas in lists.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了一个原子的近邻原子之后，下一步需要将这些几何信息转化为定量的、机器可读的格式，即“描述符”。本练习将带您深入了解“原子位置平滑重叠”（SOAP）方法的核心，这是一种创建旋转不变描述符的强大技术 ()。通过为一个简单的原子构型从头计算一个SOAP功率谱分量，您将亲身体验这些关键特征向量是如何构建的。",
            "id": "3763502",
            "problem": "在高斯近似势 (GAP) 中，通过将中心原子周围的邻近原子密度在径向函数和球谐函数的正交归一基上展开，并形成旋转不变的功率谱分量，来构建原子位置平滑重叠 (SOAP) 描述符。考虑一个位于原点的中心原子和两个分别位于 $\\mathbf{r}_{1} = (0,0,1\\,\\mathrm{\\AA})$ 和 $\\mathbf{r}_{2} = (2\\,\\mathrm{\\AA},0,0)$ 的邻近原子。邻近原子密度被建模为以每个邻近原子为中心、宽度为 $\\sigma$ 的归一化三维高斯函数的和，\n$$\n\\rho(\\mathbf{r}) = \\sum_{i=1}^{2} \\left(2\\pi \\sigma^{2}\\right)^{-3/2} \\exp\\!\\left(-\\frac{|\\mathbf{r}-\\mathbf{r}_{i}|^{2}}{2\\sigma^{2}}\\right).\n$$\n展开基由单个径向基函数 $R_{1}(r)$ 和零阶 ($l=0$) 球谐函数组成。具体来说，取高斯展宽宽度为 $\\sigma = 0.5\\,\\mathrm{\\AA}$，并选择径向基 $R_{1}(r)$ 为归一化的高斯函数\n$$\nR_{1}(r) = \\mathcal{N} \\exp\\!\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right),\n$$\n其归一化常数 $\\mathcal{N}$ 由正交归一条件 $\\int_{0}^{\\infty} r^{2} \\, R_{1}(r)^{2} \\, dr = 1$ 确定。仅使用 $l=0$ 的球谐函数 $Y_{00}(\\hat{\\mathbf{r}}) = \\left(4\\pi\\right)^{-1/2}$，即设 $l_{\\max}=0$ 和 $n_{\\max}=1$。\n\n从标准的 SOAP 定义出发，\n- 展开系数 $c_{nlm} = \\int d^{3}\\mathbf{r}\\, R_{n}(r)\\, Y_{lm}^{*}(\\hat{\\mathbf{r}})\\, \\rho(\\mathbf{r})$，\n- 功率谱分量 $p_{nn'l} = \\sum_{m=-l}^{l} c_{nlm}\\, c_{n'lm}^{*}$，\n\n推导此环境下唯一的非零 SOAP 功率谱分量 $p_{11,0}$ 的精确闭式表达式。将您的最终结果表示为一个包含指数和 $\\pi$ 的简化解析表达式。除已说明的内容外，不要引入任何额外的截断函数或窗函数。最终数值的单位用 $\\mathrm{\\AA}^{-3}$ 表示。无需四舍五入；请提供精确表达式。",
            "solution": "用户提供了一个问题，要求在原子位置平滑重叠 (SOAP) 框架内计算一个特定的功率谱分量 $p_{11,0}$，该框架是高斯近似势 (GAP) 方法论的一部分。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **中心原子：** 位于原点 $\\mathbf{r}_{0} = (0,0,0)$。\n- **邻近原子：** 两个原子，位置分别为 $\\mathbf{r}_{1} = (0,0,1\\,\\mathrm{\\AA})$ 和 $\\mathbf{r}_{2} = (2\\,\\mathrm{\\AA},0,0)$。\n- **邻近原子密度：** $\\rho(\\mathbf{r}) = \\sum_{i=1}^{2} \\left(2\\pi \\sigma^{2}\\right)^{-3/2} \\exp\\!\\left(-\\frac{|\\mathbf{r}-\\mathbf{r}_{i}|^{2}}{2\\sigma^{2}}\\right)$。\n- **高斯展宽宽度：** $\\sigma = 0.5\\,\\mathrm{\\AA}$。\n- **展开基：**\n  - 径向部分 ($n_{\\max}=1$)：$R_{1}(r) = \\mathcal{N} \\exp\\!\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right)$，归一化条件为 $\\int_{0}^{\\infty} r^{2} \\, R_{1}(r)^{2} \\, dr = 1$。\n  - 角向部分 ($l_{\\max}=0$)：$Y_{00}(\\hat{\\mathbf{r}}) = \\left(4\\pi\\right)^{-1/2}$。\n- **SOAP 定义：**\n  - 展开系数：$c_{nlm} = \\int d^{3}\\mathbf{r}\\, R_{n}(r)\\, Y_{lm}^{*}(\\hat{\\mathbf{r}})\\, \\rho(\\mathbf{r})$。\n  - 功率谱：$p_{nn'l} = \\sum_{m=-l}^{l} c_{nlm}\\, c_{n'lm}^{*}$。\n- **目标：** 推导 $p_{11,0}$ 的精确闭式表达式。\n\n**1.2. 使用提取的已知条件进行验证**\n该问题具有坚实的科学基础，完全处于计算材料科学的既定理论框架之内。术语、定义和物理参数都是标准的且自洽的。问题提法严谨，为求得唯一解提供了所有必要信息。不存在矛盾、歧义或科学上不成立的前提。\n\n**1.3. 结论与行动**\n问题有效。将提供一个完整的、附有推理过程的解答。\n\n### 步骤 2：求解推导\n\n目标是计算功率谱分量 $p_{11,0}$。根据所提供的定义，对于 $n=1, n'=1, l=0$，我们有：\n$$\np_{11,0} = \\sum_{m=-0}^{0} c_{10m}\\, c_{10m}^{*} = c_{100}\\,c_{100}^{*} = |c_{100}|^{2}\n$$\n因此，计算过程分为三个主要步骤：\n1. 确定径向基函数 $R_{1}(r)$ 的归一化常数 $\\mathcal{N}$。\n2. 计算展开系数 $c_{100}$。\n3. 根据 $c_{100}$ 计算 $p_{11,0}$ 并代入给定的物理值。\n\n**2.1. 径向基函数的归一化**\n$R_{1}(r)$ 的归一化条件是 $\\int_{0}^{\\infty} r^{2} R_{1}(r)^{2} dr = 1$。代入 $R_{1}(r)$ 的函数形式：\n$$\n\\int_{0}^{\\infty} r^{2} \\left(\\mathcal{N} \\exp\\!\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right)\\right)^{2} dr = \\mathcal{N}^{2} \\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\frac{r^{2}}{\\sigma^{2}}\\right) dr = 1\n$$\n这是一个标准的高斯积分，形式为 $\\int_0^\\infty x^{2n} e^{-ax^2} dx = \\frac{(2n-1)!!}{2^{n+1}}\\sqrt{\\frac{\\pi}{a^{2n+1}}}$。对于本例，$n=1$ 且 $a=1/\\sigma^2$。\n$$\n\\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\frac{r^{2}}{\\sigma^{2}}\\right) dr = \\frac{1!!}{2^{2}} \\sqrt{\\frac{\\pi}{(1/\\sigma^2)^3}} = \\frac{1}{4}\\sqrt{\\pi\\sigma^6} = \\frac{\\sigma^3\\sqrt{\\pi}}{4}\n$$\n归一化条件变为：\n$$\n\\mathcal{N}^{2} \\frac{\\sigma^3\\sqrt{\\pi}}{4} = 1 \\implies \\mathcal{N}^{2} = \\frac{4}{\\sigma^3\\sqrt{\\pi}} \\implies \\mathcal{N} = \\frac{2}{\\sigma^{3/2}\\pi^{1/4}}\n$$\n由于 $\\mathcal{N}$ 通常取正值，我们取正根。\n\n**2.2. 展开系数 $c_{100}$ 的计算**\n系数 $c_{100}$ 定义为：\n$$\nc_{100} = \\int d^{3}\\mathbf{r}\\, R_{1}(r)\\, Y_{00}^{*}(\\hat{\\mathbf{r}})\\, \\rho(\\mathbf{r})\n$$\n由于 $Y_{00}(\\hat{\\mathbf{r}}) = (4\\pi)^{-1/2}$ 是一个实常数，所以 $Y_{00}^{*} = Y_{00}$。代入 $\\rho(\\mathbf{r})$、$R_{1}(r)$ 和 $Y_{00}(\\hat{\\mathbf{r}})$ 的表达式：\n$$\nc_{100} = \\int d^{3}\\mathbf{r}\\, \\left(\\mathcal{N} \\exp\\!\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right)\\right) \\left(\\frac{1}{\\sqrt{4\\pi}}\\right) \\left(\\sum_{i=1}^{2} \\left(2\\pi \\sigma^{2}\\right)^{-3/2} \\exp\\!\\left(-\\frac{|\\mathbf{r}-\\mathbf{r}_{i}|^{2}}{2\\sigma^{2}}\\right)\\right)\n$$\n根据积分的线性性质，我们可以交换求和与积分的顺序：\n$$\nc_{100} = \\sum_{i=1}^{2} \\frac{\\mathcal{N}}{\\sqrt{4\\pi}(2\\pi\\sigma^2)^{3/2}} \\int d^3\\mathbf{r} \\exp\\!\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right) \\exp\\!\\left(-\\frac{|\\mathbf{r}-\\mathbf{r}_{i}|^{2}}{2\\sigma^{2}}\\right)\n$$\n该积分代表了两个高斯函数的重叠，一个以原点为中心，另一个以 $\\mathbf{r}_i$ 为中心。两个高斯函数的乘积是另一个高斯函数。我们来合并指数部分：\n$$\n-\\frac{r^{2}}{2\\sigma^{2}} - \\frac{|\\mathbf{r}-\\mathbf{r}_{i}|^{2}}{2\\sigma^{2}} = -\\frac{1}{2\\sigma^{2}} \\left(r^{2} + r^{2} - 2\\mathbf{r}\\cdot\\mathbf{r}_{i} + r_{i}^{2}\\right) = -\\frac{1}{\\sigma^{2}}\\left(r^{2} - \\mathbf{r}\\cdot\\mathbf{r}_{i} + \\frac{r_{i}^{2}}{2}\\right)\n$$\n对含 $\\mathbf{r}$ 的项进行配方：\n$$\n-\\frac{1}{\\sigma^{2}}\\left(\\left|\\mathbf{r} - \\frac{\\mathbf{r}_{i}}{2}\\right|^{2} - \\frac{r_{i}^{2}}{4} + \\frac{r_{i}^{2}}{2}\\right) = -\\frac{1}{\\sigma^{2}}\\left|\\mathbf{r} - \\frac{\\mathbf{r}_{i}}{2}\\right|^{2} - \\frac{r_{i}^{2}}{4\\sigma^{2}}\n$$\n积分变为：\n$$\n\\int d^3\\mathbf{r} \\exp\\!\\left(-\\frac{r_{i}^{2}}{4\\sigma^{2}}\\right) \\exp\\!\\left(-\\frac{|\\mathbf{r} - \\mathbf{r}_{i}/2|^{2}}{\\sigma^{2}}\\right) = \\exp\\!\\left(-\\frac{r_{i}^{2}}{4\\sigma^{2}}\\right) \\int d^3\\mathbf{r}' \\exp\\!\\left(-\\frac{|\\mathbf{r}'|^{2}}{\\sigma^{2}}\\right)\n$$\n剩下的积分是一个标准的三维高斯积分，$\\int \\exp(-ax^2)dx = \\sqrt{\\pi/a}$，所以 $\\int \\exp(-ar^2)d^3\\mathbf{r} = (\\pi/a)^{3/2}$。当 $a=1/\\sigma^2$ 时，积分结果为 $(\\pi\\sigma^2)^{3/2}$。\n原子 $i$ 对 $c_{100}$ 的贡献是：\n$$\nc_{100}^{(i)} = \\frac{\\mathcal{N}}{\\sqrt{4\\pi}(2\\pi\\sigma^2)^{3/2}} \\left(\\exp\\!\\left(-\\frac{r_{i}^{2}}{4\\sigma^{2}}\\right) (\\pi\\sigma^2)^{3/2}\\right)\n= \\frac{\\mathcal{N}}{2\\pi^{1/2} \\cdot 2^{3/2}\\pi^{3/2}\\sigma^3} \\exp\\!\\left(-\\frac{r_{i}^{2}}{4\\sigma^{2}}\\right) \\pi^{3/2}\\sigma^3\n$$\n$$\nc_{100}^{(i)} = \\frac{\\mathcal{N}}{4\\sqrt{2}\\pi^{1/2}} \\exp\\!\\left(-\\frac{r_{i}^{2}}{4\\sigma^{2}}\\right)\n$$\n现在，对两个原子求和，并代入 $\\mathcal{N}$ 的表达式：\n$$\nc_{100} = \\sum_{i=1}^{2} c_{100}^{(i)} = \\frac{\\mathcal{N}}{4\\sqrt{2}\\pi^{1/2}} \\left(\\exp\\!\\left(-\\frac{r_{1}^{2}}{4\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{r_{2}^{2}}{4\\sigma^{2}}\\right)\\right)\n$$\n$$\nc_{100} = \\frac{1}{4\\sqrt{2}\\pi^{1/2}} \\left(\\frac{2}{\\sigma^{3/2}\\pi^{1/4}}\\right) \\left(\\exp\\!\\left(-\\frac{r_{1}^{2}}{4\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{r_{2}^{2}}{4\\sigma^{2}}\\right)\\right)\n$$\n$$\nc_{100} = \\frac{1}{2\\sqrt{2}\\sigma^{3/2}\\pi^{3/4}} \\left(\\exp\\!\\left(-\\frac{r_{1}^{2}}{4\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{r_{2}^{2}}{4\\sigma^{2}}\\right)\\right)\n$$\n\n**2.3. 功率谱 $p_{11,0}$ 的计算**\n系数 $c_{100}$ 是实数，因此 $p_{11,0} = |c_{100}|^2 = c_{100}^2$：\n$$\np_{11,0} = \\left(\\frac{1}{2\\sqrt{2}\\sigma^{3/2}\\pi^{3/4}}\\right)^{2} \\left(\\exp\\!\\left(-\\frac{r_{1}^{2}}{4\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{r_{2}^{2}}{4\\sigma^{2}}\\right)\\right)^{2}\n$$\n$$\np_{11,0} = \\frac{1}{8\\sigma^3\\pi^{3/2}} \\left(\\exp\\!\\left(-\\frac{r_{1}^{2}}{4\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{r_{2}^{2}}{4\\sigma^{2}}\\right)\\right)^{2}\n$$\n现在，我们代入给定值：$\\sigma = 0.5\\,\\mathrm{\\AA}$，$\\mathbf{r}_1 = (0,0,1\\,\\mathrm{\\AA})$，$\\mathbf{r}_2 = (2\\,\\mathrm{\\AA},0,0)$。\n这得到 $r_1=|\\mathbf{r}_1| = 1\\,\\mathrm{\\AA}$ 和 $r_2=|\\mathbf{r}_2| = 2\\,\\mathrm{\\AA}$。\n指数的值为：\n$$\n\\frac{r_1^2}{4\\sigma^2} = \\frac{1^2}{4(0.5)^2} = \\frac{1}{4(0.25)} = 1\n$$\n$$\n\\frac{r_2^2}{4\\sigma^2} = \\frac{2^2}{4(0.5)^2} = \\frac{4}{4(0.25)} = 4\n$$\n$\\sigma^3$ 的值是 $(0.5)^3 = 1/8$。将这些值代入 $p_{11,0}$ 的表达式中：\n$$\np_{11,0} = \\frac{1}{8(1/8)\\pi^{3/2}} \\left(\\exp(-1) + \\exp(-4)\\right)^{2} = \\frac{1}{\\pi^{3/2}} \\left(\\exp(-1) + \\exp(-4)\\right)^{2}\n$$\n为了提供一个简化的解析表达式，我们可以展开平方项：\n$$\np_{11,0} = \\frac{1}{\\pi^{3/2}} \\left((\\exp(-1))^2 + 2\\exp(-1)\\exp(-4) + (\\exp(-4))^2\\right)\n$$\n$$\np_{11,0} = \\frac{\\exp(-2) + 2\\exp(-5) + \\exp(-8)}{\\pi^{3/2}}\n$$\n这就是功率谱分量 $p_{11,0}$ 的最终精确表达式，单位为 $\\mathrm{\\AA}^{-3}$。",
            "answer": "$$\n\\boxed{\\frac{\\exp(-2) + 2\\exp(-5) + \\exp(-8)}{\\pi^{3/2}}}\n$$"
        },
        {
            "introduction": "有了描述符和相应的参考能量（通常来自密度泛函理论DFT计算），我们就可以训练高斯过程（GP）回归模型了。本练习着重于一个关键的实际挑战：用于训练的DFT数据本身含有固有的数值噪声 ()。您将学习如何从统计学上为这种噪声建模，并将其正确地融入GP框架中，这正是GP模型在材料科学中表现稳健的关键所在。",
            "id": "3763460",
            "problem": "您的任务是构建一个基于原理的估计量，用于估计密度泛函理论（DFT）计算中因有限$k$点采样和自洽场（SCF）收敛阈值而存在的标记噪声，并将该噪声通过高斯近似势（GAP）中使用的高斯过程模型进行传播。您必须从第一性原理出发，论证将DFT标记的可变性建模为加性高斯噪声的合理性，从重复计算中估计其方差，并在指定的描述符点上计算高斯过程的预测不确定性。\n\n使用以下科学依据：\n- 中心极限定理（CLT）：许多独立的、有界的随机贡献的平均值在分布上收敛于一个高斯随机变量。\n- 高斯过程的定义：一族随机变量的集合，其任何有限子集都具有联合高斯分布。\n- 一个经过充分检验的事实是，DFT总能量依赖于布里渊区上的$k$点积分和迭代的SCF收敛，这两者都会引入微小且可控的数值变异性。\n\n模型和估计任务：\n- 设潜能量函数为 $f(\\mathbf{x})$，其中 $\\mathbf{x}$ 是高斯近似势（GAP）中使用的原子环境描述符。\n- 对于一个固定的描述符 $\\mathbf{x}_i$，假设您使用$k$点子集和SCF停止准则可变性的独立实现进行重复的DFT计算，得到以电子伏特为单位的测量值 $y_{i1}, y_{i2}, \\dots, y_{i m_i}$。\n- 请援引中心极限定理以及SCF残差在收敛附近的稳定性，论证为什么将 $y_{ij} = f(\\mathbf{x}_i) + \\epsilon_{ij}$（其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma_n^2)$ 且对$j$独立）建模是合理的。\n- 当 $f(\\mathbf{x}_i)$ 被视为每组的未知均值时，请仅使用每个描述符组内的重复观测值，从第一性原理推导出 $\\sigma_n^2$ 的最大似然估计量（MLE）。请明确说明如何处理 $m_i = 1$ 的组（无组内方差），并证明您的选择是合理的。\n\n高斯过程模型和预测：\n- 在 $f(\\mathbf{x})$ 上设置一个零均值高斯过程先验，其核函数为平方指数核 $k(\\mathbf{x}, \\mathbf{x}') = \\sigma_f^2 \\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}'\\|^2}{2 \\ell^2}\\right)$，其中 $\\sigma_f^2$ 是以平方电子伏特为单位的信号方差，$\\ell$ 是以描述符单位为单位的长度尺度。\n- 使用方差为 $\\sigma_n^2$（以平方电子伏特为单位）的加性高斯噪声观测模型。\n- 对于任意测试描述符 $\\mathbf{x}_*$，根据高斯过程条件化规则，推导带噪声观测值 $y_*$ 的高斯过程后验预测方差，即 $\\mathrm{Var}(y_* \\mid \\text{data})$（以平方电子伏特为单位）。\n\n实现要求：\n- 实现一个程序，对于下面的每个测试用例，使用您推导的MLE从重复标记中估计 $\\sigma_n^2$。在仅基于组内偏差计算MLE时，忽略任何 $m_i = 1$ 的描述符组，并在MLE分母中使用所包含观测值的总数（不减去组数）。然后，使用所有单个观测值（包括单元素组）作为训练数据，计算在给定测试描述符 $\\mathbf{x}_*$ 处带噪声观测值的高斯过程后验预测方差。\n- 所有能量必须以电子伏特处理，所有方差必须以平方电子伏特表示。输出是数值，并隐式采用这些单位。\n- 使用提供的 $\\sigma_f^2$ 和 $\\ell$ 的平方指数核函数。\n\n测试套件：\n- 案例1（理想情况，小噪声）：描述符 $\\mathbf{x}_i \\in \\mathbb{R}$ 为 $[0.0, 1.0, 2.0]$；每个描述符组内的重复标记（单位：电子伏特）：\n  - 对于 $\\mathbf{x}_1 = 0.0$：$[0.00, 0.01, -0.02]$，\n  - 对于 $\\mathbf{x}_2 = 1.0$：$[0.84, 0.85, 0.86]$，\n  - 对于 $\\mathbf{x}_3 = 2.0$：$[0.91, 0.93, 0.92]$。\n  使用 $\\sigma_f^2 = 1.0$ 和 $\\ell = 0.8$。在 $\\mathbf{x}_* = 1.5$ 处进行预测。\n- 案例2（较大噪声，粗糙的$k$点采样和宽松的SCF阈值）：描述符 $\\mathbf{x}_i \\in \\mathbb{R}$ 为 $[0.0, 1.0, 2.0]$；重复标记（单位：电子伏特）：\n  - 对于 $\\mathbf{x}_1 = 0.0$：$[0.00, 0.05, -0.04]$，\n  - 对于 $\\mathbf{x}_2 = 1.0$：$[0.80, 0.90, 0.78]$，\n  - 对于 $\\mathbf{x}_3 = 2.0$：$[0.85, 0.97, 0.88]$。\n  使用 $\\sigma_f^2 = 1.0$ 和 $\\ell = 0.8$。在 $\\mathbf{x}_* = 1.5$ 处进行预测。\n- 案例3（边界条件，含单元素组）：描述符 $\\mathbf{x}_i \\in \\mathbb{R}$ 为 $[0.0, 1.0, 2.0]$；重复标记（单位：电子伏特）：\n  - 对于 $\\mathbf{x}_1 = 0.0$：$[0.01, -0.02]$，\n  - 对于 $\\mathbf{x}_2 = 1.0$：$[0.88]$，\n  - 对于 $\\mathbf{x}_3 = 2.0$：$[0.93, 0.96, 0.91, 0.94]$。\n  使用 $\\sigma_f^2 = 1.0$ 和 $\\ell = 0.8$。在 $\\mathbf{x}_* = 1.5$ 处进行预测。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个包含该案例的 $[\\hat{\\sigma}_n^2, \\mathrm{Var}(y_* \\mid \\text{data})]$ 的逗号分隔双元素列表。例如，以格式 $[[s_1,v_1],[s_2,v_2],[s_3,v_3]]$ 生成输出，其中每个 $s_i$ 和 $v_i$ 均为数值。",
            "solution": "所提出的问题是统计建模和机器学习领域一个有效且适定的练习，特别是在计算材料科学中的应用。它在科学上基于密度泛函理论（DFT）、中心极限定理（CLT）和高斯过程（GP）回归的原理。唯一且有意义解所需的所有组件均已提供。因此，我们可以进行基于原理的推导和求解。\n\n解答结构如下：首先，我们为将DFT计算中的数值变异性建模为加性高斯噪声提供理论论证。其次，我们推导该噪声方差的最大似然估计量（MLE）。第三，我们在高斯过程框架内推导新观测值的后验预测方差。最后，我们概述为解决给定测试用例而实现的算法。\n\n\\textbf{1. 加性高斯噪声模型的合理性论证}\n\n该问题关注DFT计算中固有的数值噪声，其主要来源于两个方面：使用离散$k$点集对布里渊区进行的有限采样，以及自洽场（SCF）程序的迭代性质，该程序在满足指定收敛阈值时终止。\n\n设具有描述符 $\\mathbf{x}_i$ 的原子构型的真实潜在总能量为 $f(\\mathbf{x}_i)$。单次DFT计算产生一个观测值 $y_{ij}$。观测值与真实值之间的差异 $\\epsilon_{ij} = y_{ij} - f(\\mathbf{x}_i)$ 可归因于大量微小的、准随机的数值误差的累积效应。\n\n-   \\textbf{$k$点采样}：总能量是布里渊区上的一个积分。使用有限$k$点集进行数值积分会引入离散化误差。如果我们为重复计算考虑不同的、随机选择的（或系统性移动的）$k$点网格，那么每次计算的误差可以看作一个随机变量。\n-   \\textbf{SCF收敛}：SCF循环迭代求解Kohn-Sham方程，直到迭代间的电荷密度或总能量变化低于某个阈值。因此，最终状态与真实基态之间存在一个微小的、非零的残余距离。这种残余误差会在最终能量中引入微小的变异性。\n\n\\textbf{中心极限定理（CLT）}指出，大量具有有限均值和方差的独立同分布随机变量的和或平均值将近似服从正态分布。尽管来自$k$点积分和SCF收敛的单个误差贡献可能并非严格独立或同分布，但它们的累积效应可以合理地近似为如此。总数值误差 $\\epsilon_{ij}$ 是大量此类微小、有界贡献的总和。因此，援引CLT，将总误差 $\\epsilon_{ij}$ 视为从高斯分布中抽取的随机变量，是一个合理且标准的物理建模假设。由于数值方法被设计为无偏的，该分布的均值为零。\n\n因此，我们采用以下观测模型：\n$$y_{ij} = f(\\mathbf{x}_i) + \\epsilon_{ij}, \\quad \\text{其中} \\quad \\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma_n^2)$$\n其中 $\\sigma_n^2$ 是数值噪声的方差，我们假设对于给定的计算精度水平（即固定的$k$点密度和SCF阈值），该方差是恒定的。因此，对于固定的描述符 $\\mathbf{x}_i$，观测值 $y_{ij}$ 是来自 $\\mathcal{N}(f(\\mathbf{x}_i), \\sigma_n^2)$ 的样本。\n\n\\textbf{2. 噪声方差 $\\sigma_n^2$ 的最大似然估计量}\n\n我们的任务是从按描述符 $\\mathbf{x}_i$ 分组的重复观测值 $\\{y_{ij}\\}$ 中推导 $\\sigma_n^2$ 的MLE。对于每个组 $i$，我们有 $m_i$ 个观测值。真实能量 $f(\\mathbf{x}_i)$ 是每个组的一个未知参数，我们将其表示为 $\\mu_i$。\n\n单个观测值 $y_{ij}$ 的概率密度为：\n$$p(y_{ij} | \\mu_i, \\sigma_n^2) = \\frac{1}{\\sqrt{2\\pi\\sigma_n^2}} \\exp\\left(-\\frac{(y_{ij} - \\mu_i)^2}{2\\sigma_n^2}\\right)$$\n假设独立性，所有观测值的似然函数是各概率密度的乘积。对数似然 $\\mathcal{L}$ 是对数的和：\n$$\\mathcal{L}(\\{\\mu_i\\}, \\sigma_n^2 | \\{\\mathbf{y}_i\\}) = \\sum_{i=1}^{G} \\sum_{j=1}^{m_i} \\left[ -\\frac{1}{2} \\ln(2\\pi) - \\frac{1}{2} \\ln(\\sigma_n^2) - \\frac{(y_{ij} - \\mu_i)^2}{2\\sigma_n^2} \\right]$$\n其中 $G$ 是组数。\n\n为了找到MLE，我们对参数求偏导数并令其为零。首先，对每个组均值 $\\mu_k$：\n$$\\frac{\\partial\\mathcal{L}}{\\partial\\mu_k} = \\sum_{j=1}^{m_k} \\frac{y_{kj} - \\mu_k}{\\sigma_n^2} = 0 \\implies \\sum_{j=1}^{m_k} y_{kj} = m_k \\mu_k$$\n这给出了组均值的MLE，即样本均值：$\\hat{\\mu}_k = \\frac{1}{m_k}\\sum_{j=1}^{m_k} y_{kj} = \\bar{y}_k$。\n\n接下来，我们将 $\\hat{\\mu}_i$ 代回到对数似然函数中，并对 $\\sigma_n^2$ 求导：\n$$\\mathcal{L}(\\sigma_n^2 | \\{\\mathbf{y}_i\\}, \\{\\hat{\\mu}_i\\}) = \\sum_{i=1}^{G} \\sum_{j=1}^{m_i} \\left[ C - \\frac{1}{2} \\ln(\\sigma_n^2) - \\frac{(y_{ij} - \\bar{y}_i)^2}{2\\sigma_n^2} \\right]$$\n令 $V = \\sigma_n^2$ 且 $N_{tot} = \\sum_i m_i$。\n$$\\mathcal{L}(V) = -\\frac{N_{tot}}{2} \\ln(2\\pi) - \\frac{N_{tot}}{2} \\ln(V) - \\frac{1}{2V} \\sum_{i=1}^{G} \\sum_{j=1}^{m_i} (y_{ij} - \\bar{y}_i)^2$$\n$$\\frac{\\partial\\mathcal{L}}{\\partial V} = -\\frac{N_{tot}}{2V} + \\frac{1}{2V^2} \\sum_{i,j} (y_{ij} - \\bar{y}_i)^2 = 0$$\n$$\\frac{N_{tot}}{2V} = \\frac{1}{2V^2} \\sum_{i,j} (y_{ij} - \\bar{y}_i)^2 \\implies V = \\frac{1}{N_{tot}} \\sum_{i,j} (y_{ij} - \\bar{y}_i)^2$$\n问题规定我们必须忽略 $m_i=1$ 的组。这是合乎逻辑的，因为这样的组不提供关于组内方差的任何信息，因为 $(y_{i1} - \\bar{y}_i)^2 = (y_{i1} - y_{i1})^2 = 0$。设 $I = \\{i \\mid m_i  1\\}$ 是观测数大于一的组的索引集。这些被包含的组中的总观测数为 $N_{eff} = \\sum_{i \\in I} m_i$。那么 $\\sigma_n^2$ 的MLE是这些有效组的合并方差：\n$$\\hat{\\sigma}_n^2 = \\frac{\\sum_{i \\in I} \\sum_{j=1}^{m_i} (y_{ij} - \\bar{y}_i)^2}{\\sum_{i \\in I} m_i} = \\frac{1}{N_{eff}} \\sum_{i \\in I} \\sum_{j=1}^{m_i} (y_{ij} - \\bar{y}_i)^2$$\n这就是所要求的估计量。\n\n\\textbf{3. 高斯过程后验预测方差}\n\n我们使用零均值GP先验对潜函数 $f(\\mathbf{x})$ 进行建模：$f(\\mathbf{x}) \\sim \\mathcal{GP}(0, k(\\mathbf{x}, \\mathbf{x}'))$。\n核函数是平方指数核：$k(\\mathbf{x}, \\mathbf{x}') = \\sigma_f^2 \\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}'\\|^2}{2 \\ell^2}\\right)$。\n我们的训练数据由 $N$ 个观测值 $\\mathcal{D} = \\{\\mathbf{X}, \\mathbf{y}\\}$ 组成，其中 $\\mathbf{X} = (\\mathbf{x}_1, \\dots, \\mathbf{x}_N)^T$ 且 $\\mathbf{y} = (y_1, \\dots, y_N)^T$。请注意，对于GP，我们使用所有单个观测值，即将组结构展平。\n观测模型为 $\\mathbf{y} = f(\\mathbf{X}) + \\boldsymbol{\\epsilon}$，其中 $\\boldsymbol{\\epsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_n^2 \\mathbf{I})$。\n\n我们想要找到在测试点 $\\mathbf{x}_*$ 处一个新的带噪声观测值 $y_*$ 的预测方差。根据GP的假设，训练输出 $\\mathbf{y}$ 和测试输出 $y_*$ 具有联合高斯分布：\n$$ \\begin{pmatrix} \\mathbf{y} \\\\ y_* \\end{pmatrix} \\sim \\mathcal{N} \\left( \\mathbf{0}, \\begin{pmatrix} \\mathbf{K} + \\sigma_n^2 \\mathbf{I}  \\mathbf{k}_* \\\\ \\mathbf{k}_*^T  k_{**} + \\sigma_n^2 \\end{pmatrix} \\right) $$\n其中 $\\mathbf{K}$ 是 $N \\times N$ 的核矩阵，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$，$\\mathbf{k}_*$ 是 $N \\times 1$ 的向量，其元素为 $k_{*i} = k(\\mathbf{x}_*, \\mathbf{x}_i)$，而 $k_{**} = k(\\mathbf{x}_*, \\mathbf{x}_*)$。对角线上的 $\\sigma_n^2$ 项解释了加性观测噪声。\n\n使用多元高斯分布的条件分布的标准公式，给定数据 $\\mathcal{D}$ 的 $y_*$ 的后验分布也是高斯分布，$p(y_* | \\mathcal{D}) = \\mathcal{N}(y_* | \\mu_*, \\Sigma_*)$，其预测方差为：\n$$\\Sigma_* = \\mathrm{Var}(y_* \\mid \\mathcal{D}) = (k_{**} + \\sigma_n^2) - \\mathbf{k}_*^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{k}_*$$\n这就是所求的量。它代表了我们对一个新的带噪声测量值 $y_*$ 的不确定性。它是潜函数值的后验方差 $\\mathrm{Var}(f_* \\mid \\mathcal{D}) = k_{**} - \\mathbf{k}_*^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{k}_*$ 与测量本身固有的噪声方差 $\\sigma_n^2$ 的和。\n\n\\textbf{4. 计算算法}\n\n对于每个测试用例，实现的程序执行以下步骤：\n1.  \\textbf{估计噪声方差 $\\hat{\\sigma}_n^2$}：\n    a. 遍历所提供的重复标记组。\n    b. 对于每个观测值多于一个（$m_i  1$）的组，计算样本均值 $\\bar{y}_i$ 和与该均值的偏差平方和 $\\sum_{j=1}^{m_i} (y_{ij} - \\bar{y}_i)^2$。\n    c. 将所有这些组的偏差平方和相加，得到总平方和（TSS）。\n    d. 将这些组中的观测数 $m_i$ 相加，得到有效总数 $N_{eff}$。\n    e. 计算 $\\hat{\\sigma}_n^2 = \\text{TSS} / N_{eff}$。\n\n2.  \\textbf{计算GP预测方差}：\n    a. 通过取消分组来组装完整的训练数据集。这将创建一组包含 $N$ 个描述符-标记对 $(\\mathbf{x}_j, y_j)$ 的集合，其中包括来自单元素组的对。\n    b. 使用给定的超参数 $\\sigma_f^2$ 和 $\\ell$，以及测试点 $\\mathbf{x}_*$：\n        i. 构建 $N \\times N$ 核矩阵 $\\mathbf{K}$，其中 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$。\n        ii. 构建 $N \\times 1$ 向量 $\\mathbf{k}_*$，其中 $k_{*i} = k(\\mathbf{x}_*, \\mathbf{x}_i)$。\n        iii. 计算标量 $k_{**} = k(\\mathbf{x}_*, \\mathbf{x}_*)$。\n    c. 构造带噪声的协方差矩阵 $\\mathbf{C} = \\mathbf{K} + \\hat{\\sigma}_n^2 \\mathbf{I}_N$。\n    d. 求解线性系统 $\\mathbf{C}\\mathbf{v} = \\mathbf{k}_*$ 以得到向量 $\\mathbf{v}$。这在数值上比计算矩阵逆 $\\mathbf{C}^{-1}$ 更稳定。\n    e. 使用推导出的公式计算预测方差：\n    $$\\mathrm{Var}(y_* \\mid \\mathcal{D}) = k_{**} + \\hat{\\sigma}_n^2 - \\mathbf{k}_*^T \\mathbf{v}$$\n3.  每个案例的结果 $[\\hat{\\sigma}_n^2, \\mathrm{Var}(y_* \\mid \\mathcal{D})]$ 被存储并按要求格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, estimating label noise variance\n    and computing the Gaussian Process posterior predictive variance.\n    \"\"\"\n    test_cases = [\n        {\n            \"groups\": {\n                0.0: [0.00, 0.01, -0.02],\n                1.0: [0.84, 0.85, 0.86],\n                2.0: [0.91, 0.93, 0.92],\n            },\n            \"sigma_f_sq\": 1.0,\n            \"l\": 0.8,\n            \"x_star\": 1.5,\n        },\n        {\n            \"groups\": {\n                0.0: [0.00, 0.05, -0.04],\n                1.0: [0.80, 0.90, 0.78],\n                2.0: [0.85, 0.97, 0.88],\n            },\n            \"sigma_f_sq\": 1.0,\n            \"l\": 0.8,\n            \"x_star\": 1.5,\n        },\n        {\n            \"groups\": {\n                0.0: [0.01, -0.02],\n                1.0: [0.88],\n                2.0: [0.93, 0.96, 0.91, 0.94],\n            },\n            \"sigma_f_sq\": 1.0,\n            \"l\": 0.8,\n            \"x_star\": 1.5,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        groups = case[\"groups\"]\n\n        # Step 1: Estimate sigma_n_sq using MLE from within-group variance\n        total_squared_deviations = 0.0\n        effective_n = 0\n        \n        for x_val, y_vals in groups.items():\n            if len(y_vals) > 1:\n                y_arr = np.array(y_vals)\n                mean_y = np.mean(y_arr)\n                squared_deviations = np.sum((y_arr - mean_y)**2)\n                total_squared_deviations += squared_deviations\n                effective_n += len(y_vals)\n        \n        sigma_n_sq_hat = total_squared_deviations / effective_n if effective_n > 0 else 0.0\n\n        # Step 2: Prepare data for Gaussian Process regression\n        x_train_list = []\n        y_train_list = []\n        for x_val, y_vals in groups.items():\n            for y in y_vals:\n                x_train_list.append([x_val])\n                y_train_list.append(y)\n        \n        X_train = np.array(x_train_list)\n        y_train = np.array(y_train_list)\n        x_star = np.array([[case[\"x_star\"]]])\n        \n        sigma_f_sq = case[\"sigma_f_sq\"]\n        l = case[\"l\"]\n        \n        # Step 3: Define squared exponential kernel function\n        def squared_exp_kernel(xa, xb, sf2, l_scale):\n            sq_dist = cdist(xa, xb, 'sqeuclidean')\n            return sf2 * np.exp(-sq_dist / (2 * l_scale**2))\n\n        # Step 4: Compute GP posterior predictive variance\n        \n        # Kernel matrices\n        K = squared_exp_kernel(X_train, X_train, sigma_f_sq, l)\n        k_star = squared_exp_kernel(X_train, x_star, sigma_f_sq, l)\n        k_star_star = squared_exp_kernel(x_star, x_star, sigma_f_sq, l)[0, 0]\n        \n        # Noisy covariance matrix\n        K_noisy = K + sigma_n_sq_hat * np.eye(len(X_train))\n        \n        # Solve (K + sigma_n^2*I)v = k_star to find v\n        v = np.linalg.solve(K_noisy, k_star)\n        \n        # Predictive variance for a noisy observation y_star\n        # Var(y_*) = (k_** + sigma_n^2) - k_*^T * (K + sigma_n^2*I)^-1 * k_*\n        #          = (k_** + sigma_n^2) - k_*^T * v\n        pred_var = k_star_star + sigma_n_sq_hat - np.dot(k_star.T, v)\n        \n        # Ensure pred_var is a scalar\n        final_pred_var = pred_var.item()\n\n        results.append([str(sigma_n_sq_hat), str(final_pred_var)])\n\n    # Format the final output string\n    inner_results_str = [f\"[{s},{v}]\" for s, v in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}