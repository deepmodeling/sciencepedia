{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的计算方法之前，掌握平均力势（PMF）的基本组成至关重要。第一个练习  使用简化的连续介质溶剂模型来解构离子解离过程的 PMF。通过解析计算 PMF，你将能够区分直接的静电相互作用与由可用相空间体积产生的关键熵贡献，从而清晰地阐明 PMF 与简单势能的区别。",
            "id": "2460705",
            "problem": "您需要构建一个第一性原理模型，用于描述氯化钠 (NaCl) 在两种不同溶剂中沿其标量分离坐标解离为钠离子和氯离子的平均力势 (PMF)。目的是量化和对比在相同温度下，液态水和液态己烷中的 PMF，从而分离出溶剂的作用。\n\n假设和定义：\n\n- 考虑一对非反应性点离子，其固定电荷为 $q_1=+e$ 和 $q_2=-e$，在温度为 $T$ 的均匀、各向同性电介质连续体中处于无限稀释状态，它们仅通过经典静电学相互作用。忽略任何由外加电解质引起的离子屏蔽、色散力以及特定的短程溶剂化结构。\n- 假设系统处于温度为 $T$ 的正则系综中。平均力势 $W(r)$ 沿离子间距 $r$ 的定义为 $W(r) = -k_{\\mathrm B} T \\ln P(r)$（不考虑一个加性常数），其中 $P(r)$ 是标量分离坐标 $r$ 的边际平衡概率密度。边际密度 $P(r)$ 既反映了相互作用能的玻尔兹曼权重，也反映了与球坐标相关的三维测度。\n- 对于相对介电常数为 $\\varepsilon_r$ 的均匀电介质，两个相距为 $r$ 的点电荷之间的经典静电相互作用能为 $U(r) = \\dfrac{q_1 q_2}{4 \\pi \\varepsilon_0 \\varepsilon_r \\, r}$。\n- 报告相对平均力势 $\\Delta W(r) = W(r) - W(r_{\\mathrm{ref}})$，其中参考距离 $r_{\\mathrm{ref}}$ 在下文指定。这消除了任何加性常数。\n\n常数和参数（请使用这些精确值和单位）：\n\n- 基本电荷：$e = 1.602176634 \\times 10^{-19}$ 库仑。\n- 真空介电常数：$\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ 法拉第/米。\n- 玻尔兹曼常数：$k_{\\mathrm B} = 1.380649 \\times 10^{-23}$ 焦耳/开尔文。\n- 阿伏伽德罗常数：$N_{\\mathrm A} = 6.02214076 \\times 10^{23}$ 每摩尔。\n- 温度：$T = 298.15$ 开尔文。\n- $T$ 温度下液态水的相对介电常数：$\\varepsilon_r^{\\mathrm{(water)}} = 78.37$。\n- $T$ 温度下液态己烷的相对介电常数：$\\varepsilon_r^{\\mathrm{(hexane)}} = 1.89$。\n\n测试组：\n\n- 待评估的离子间距 $r$：$\\{0.28, 0.50, 1.00, 2.00\\}$ 纳米。\n- 参考距离：$r_{\\mathrm{ref}} = 2.00$ 纳米。\n- 待评估的溶剂：水（$\\varepsilon_r^{\\mathrm{(water)}}$）和己烷（$\\varepsilon_r^{\\mathrm{(hexane)}}$）。\n\n要求输出：\n\n- 对于每种溶剂和每个指定的距离 $r$，计算以千焦耳/摩尔表示的相对 PMF $\\Delta W(r)$。将每个数值四舍五入到三位小数。必须使用自然对数，并且不涉及角度。\n- 最终输出必须是包含在方括号中的、由逗号分隔的列表的单行。列表必须按以下顺序包含值：\n  - 首先，对于水，在 $r = 0.28, 0.50, 1.00, 2.00$ 纳米处的值（按此顺序），\n  - 然后，对于己烷，在 $r = 0.28, 0.50, 1.00, 2.00$ 纳米处的值（按此顺序）。\n  也就是说，输出必须是以下形式\n  $[\\Delta W_{\\mathrm{water}}(0.28\\,\\mathrm{nm}), \\Delta W_{\\mathrm{water}}(0.50\\,\\mathrm{nm}), \\Delta W_{\\mathrm{water}}(1.00\\,\\mathrm{nm}), \\Delta W_{\\mathrm{water}}(2.00\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(0.28\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(0.50\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(1.00\\,\\mathrm{nm}), \\Delta W_{\\mathrm{hexane}}(2.00\\,\\mathrm{nm})]$，\n  其中每个条目都以千焦耳/摩尔为单位，四舍五入到三位小数。\n\n在代入物理公式时，所有依赖于 $r$ 的量都必须使用以米为单位的 $r$ 进行计算。确保任何对数内部使用的比率 $r/r_{\\mathrm{ref}}$ 是无量纲的。如上所述，最终答案以千焦耳/摩尔为单位表示，并四舍五入到三位小数。",
            "solution": "问题陈述已经过严格审查，并被认定是有效的。它提出了一个统计热力学中的标准、适定的问题，没有科学上的不一致或逻辑上的缺陷。我们将继续进行推导和求解。\n\n核心量是平均力势 (PMF)，$W(r)$，它描述了两个离子之间的有效势，作为它们标量距离 $r$ 的函数。它通过在距离 $r$ 处找到离子的边际概率密度 $P(r)$ 来定义。在温度为 $T$ 的正则系综中，该关系由以下公式给出：\n$$W(r) = -k_{\\mathrm B} T \\ln P(r)$$\n其中 $k_{\\mathrm B}$ 是玻尔兹曼常数。$W(r)$ 的定义允许相差一个任意的加性常数，这个问题通过考虑相对 PMF 来解决。\n\n概率密度 $P(r)$ 必须考虑两个因素：离子间的能量相互作用和在给定距离下可用的相空间体积。对于三维空间中的两个离子，其中一个离子固定在原点，在无穷小体积元 $d\\mathbf{r}$ 中找到第二个离子的概率与玻尔兹曼因子 $\\exp(-U(|\\mathbf{r}|)/k_{\\mathrm{B}}T)$ 成正比，其中 $U(r)$ 是对相互作用能。\n\n为了找到标量距离 $r$ 的边际概率 $P(r)$，我们必须在固定距离 $r$ 上对所有方向进行积分。这对应于对半径为 $r$ 的球面进行积分。球坐标中的体积元是 $r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$。对立体角 $\\Omega$ 积分得到一个几何因子 $4\\pi r^2$。因此，边际概率密度正比于：\n$$P(r) \\propto 4\\pi r^2 \\exp\\left(-\\frac{U(r)}{k_{\\mathrm B} T}\\right)$$\n\n将此代入 $W(r)$ 的定义中：\n$$W(r) = -k_{\\mathrm B} T \\ln\\left[C_0 \\cdot 4\\pi r^2 \\exp\\left(-\\frac{U(r)}{k_{\\mathrm B} T}\\right)\\right]$$\n其中 $C_0$ 是一个归一化常数。利用对数的性质，我们可以分离各项：\n$$W(r) = -k_{\\mathrm B} T \\left[\\ln(4\\pi C_0) + \\ln(r^2) - \\frac{U(r)}{k_{\\mathrm B} T}\\right]$$\n$$W(r) = U(r) - 2 k_{\\mathrm B} T \\ln r + C_1$$\n此处，$C_1 = -k_{\\mathrm B} T \\ln(4\\pi C_0)$ 是一个常数。此表达式表明 PMF 由两个依赖于 $r$ 的部分组成：直接相互作用能 $U(r)$ 和一个熵项 $-2 k_{\\mathrm B} T \\ln r$，后者源于在更大距离处可用的相空间体积更大。\n\n问题要求的是相对 PMF，$\\Delta W(r) = W(r) - W(r_{\\mathrm{ref}})$，这消除了未知常数 $C_1$：\n$$\\Delta W(r) = \\left(U(r) - 2 k_{\\mathrm B} T \\ln r\\right) - \\left(U(r_{\\mathrm{ref}}) - 2 k_{\\mathrm B} T \\ln r_{\\mathrm{ref}}\\right)$$\n$$\\Delta W(r) = \\left(U(r) - U(r_{\\mathrm{ref}})\\right) - 2 k_{\\mathrm B} T \\left( \\ln r - \\ln r_{\\mathrm{ref}} \\right)$$\n$$\\Delta W(r) = U(r) - U(r_{\\mathrm{ref}}) - 2 k_{\\mathrm B} T \\ln\\left(\\frac{r}{r_{\\mathrm{ref}}}\\right)$$\n\n在相对介电常数为 $\\varepsilon_r$ 的电介质连续体中，两个点电荷 $q_1 = +e$ 和 $q_2 = -e$ 的相互作用能 $U(r)$ 由库仑定律给出：\n$$U(r) = \\frac{q_1 q_2}{4 \\pi \\varepsilon_0 \\varepsilon_r r} = -\\frac{e^2}{4 \\pi \\varepsilon_0 \\varepsilon_r r}$$\n其中 $\\varepsilon_0$ 是真空介电常数，而 $e$ 是基本电荷。\n\n将此代入 $\\Delta W(r)$ 的表达式中，我们得到用于计算的最终公式：\n$$\\Delta W(r) = -\\frac{e^2}{4 \\pi \\varepsilon_0 \\varepsilon_r} \\left(\\frac{1}{r} - \\frac{1}{r_{\\mathrm{ref}}}\\right) - 2 k_{\\mathrm B} T \\ln\\left(\\frac{r}{r_{\\mathrm{ref}}}\\right)$$\n这给出了单个离子对的相对 PMF，单位为焦耳。为了按要求将其表示为千焦耳/摩尔，我们乘以阿伏伽德罗常数 $N_{\\mathrm A}$ 和一个转换因子 $10^{-3}$：\n$$\\Delta W_{\\text{kJ/mol}}(r) = \\Delta W(r) \\times N_{\\mathrm A} \\times 10^{-3}$$\n\n计算过程是使用所提供的物理常数和参数来实现这个公式。所有涉及物理公式的计算都必须使用国际单位制单位（距离使用米）。参数为：\n- 温度：$T = 298.15$ K。\n- 参考距离：$r_{\\mathrm{ref}} = 2.00 \\times 10^{-9}$ m。\n- 溶剂：水（$\\varepsilon_r^{\\mathrm{(water)}} = 78.37$）和己烷（$\\varepsilon_r^{\\mathrm{(hexane)}} = 1.89$）。\n- 评估距离 $r$：$\\{0.28, 0.50, 1.00, 2.00\\}$ 纳米。\n\n代码将对两种溶剂及其各自的四个指定距离进行迭代，计算 $\\Delta W_{\\text{kJ/mol}}(r)$，并按指定顺序报告四舍五入到三位小数的值。当 $r = r_{\\mathrm{ref}}$ 时，平凡地得出 $\\Delta W(r_{\\mathrm{ref}}) = 0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a model for the potential of mean force (PMF) governing NaCl \n    dissociation and computes it for water and hexane.\n    \"\"\"\n    # Define physical constants in SI units as provided.\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n    EPSILON_0 = 8.8541878128e-12 # Vacuum permittivity in F/m\n    K_BOLTZMANN = 1.380649e-23   # Boltzmann constant in J/K\n    N_AVOGADRO = 6.02214076e23    # Avogadro constant in 1/mol\n    \n    # Define problem parameters.\n    TEMPERATURE = 298.15  # Temperature in Kelvin\n    \n    # Define solvent properties.\n    solvents = {\n        \"water\": 78.37,\n        \"hexane\": 1.89,\n    }\n    \n    # Define test suite parameters from the problem statement.\n    r_separations_nm = [0.28, 0.50, 1.00, 2.00]  # Interionic separations in nanometers\n    r_ref_nm = 2.00  # Reference separation in nanometers\n\n    # Convert separation distances to SI units (meters).\n    r_separations_m = [r * 1e-9 for r in r_separations_nm]\n    r_ref_m = r_ref_nm * 1e-9\n\n    results = []\n    \n    # The calculation is performed first for water, then for hexane.\n    solvent_order = [\"water\", \"hexane\"]\n\n    for solvent_name in solvent_order:\n        eps_r = solvents[solvent_name]\n        \n        for r_m in r_separations_m:\n            # The PMF relative to r_ref is zero at r_ref itself.\n            if r_m == r_ref_m:\n                delta_W_kj_per_mol = 0.0\n            else:\n                # Calculate the potential energy term U(r) - U(r_ref).\n                # This is the coulombic interaction part of the PMF.\n                u_term = (-E_CHARGE**2) / (4 * np.pi * EPSILON_0 * eps_r) * (1/r_m - 1/r_ref_m)\n                \n                # Calculate the entropic term -2*kB*T*ln(r/r_ref).\n                # This arises from the r^2 factor in the spherical volume element.\n                entropic_term = -2 * K_BOLTZMANN * TEMPERATURE * np.log(r_m / r_ref_m)\n                \n                # The total relative PMF in Joules per ion pair.\n                delta_W_j_per_pair = u_term + entropic_term\n                \n                # Convert the result to kilojoules per mole.\n                delta_W_kj_per_mol = delta_W_j_per_pair * N_AVOGADRO * 1e-3\n            \n            results.append(delta_W_kj_per_mol)\n\n    # Format the final list of results into the specified string format.\n    # Each value is formatted to three decimal places.\n    output_str = \"[\" + \",\".join([f\"{res:.3f}\" for res in results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "使用诸如伞形采样等方法进行有效的 PMF 计算需要仔细选择参数。本练习  聚焦于其中最关键的参数之一：用于约束系统的谐波力常数 $k$。通过一个解析模型，你将研究 $k$ 如何直接影响相邻采样窗口之间的统计重叠，并确定所需的最优窗口数量，为设计高效、准确的自由能模拟建立必要的直觉。",
            "id": "2460733",
            "problem": "您的任务是编写一个完整的程序，定量研究在伞形采样中改变谐波弹簧常数 $k$ 如何影响 (i) 相邻窗口之间的统计重叠度，以及 (ii) 一个计算效率的简单代理指标，该指标定义为确保达到指定目标重叠度所需的最少均匀分布窗口数量。该系统是一个一维反应坐标 $x$，具有已知的平均力势 (PMF)，在绝对温度 $T$ 下使用谐波伞形势进行采样。\n\n系统定义：\n- 基础 PMF：$U_{0}(x) = \\tfrac{1}{2}\\,k_{0}\\,(x - x_{c})^{2}$，单位为 kJ/mol，其中 $k_{0} = 25$ kJ/(mol·nm$^{2}$) 且 $x_{c} = 0.5$ nm。\n- 窗口 $i$ 中的伞形势：$U_{b}^{(i)}(x) = \\tfrac{1}{2}\\,k\\,(x - x_{0}^{(i)})^{2}$，单位为 kJ/mol，其中 $k$ 是弹簧常数（待变量），单位为 kJ/(mol·nm$^{2}$)。\n- 温度 $T = 300$ K 的正则系综，玻尔兹曼常数 $k_{\\mathrm{B}} = 0.008314462618$ kJ/(mol·K)，因此 $\\beta = 1/(k_{\\mathrm{B}} T)$，单位为 (mol/kJ)。\n- 用于窗口放置的反应坐标域：区间 $[0, L]$，其中 $L = 1.0$ nm。\n\n统计重叠度量：\n- 对于每个伞形窗口 $i$，定义在温度 $T$ 下，偏置势 $U_{0}(x) + U_{b}^{(i)}(x)$ 的归一化正则分布：\n$$\np_{i}(x) = \\frac{\\exp\\!\\left(-\\beta\\,[U_{0}(x) + U_{b}^{(i)}(x)]\\right)}{\\int_{-\\infty}^{\\infty}\\exp\\!\\left(-\\beta\\,[U_{0}(x) + U_{b}^{(i)}(x)]\\right)\\,dx}.\n$$\n- 相邻窗口 $i$ 和 $i+1$ 之间的统计重叠度通过巴氏系数定义\n$$\nB_{i,i+1} = \\int_{-\\infty}^{\\infty} \\sqrt{\\,p_{i}(x)\\,p_{i+1}(x)\\,}\\;dx,\n$$\n它是一个在 $[0,1]$ 范围内的无量纲量。值越高表示重叠度越大。\n\n效率代理指标：\n- 对于一个给定的目标最小重叠度 $B_{\\min}$（无量纲），将 $N_{\\mathrm{req}}(k)$ 定义为在 $[0, L]$ 上均匀分布的窗口的最小整数数量，要求所有相邻窗口的重叠度都至少为 $B_{\\min}$。\n\n程序任务与要求输出：\n1) 在 $[0,L]$ 上固定 $N_{\\mathrm{fix}} = 5$ 个均匀分布的伞形窗口中心 $x_{0}^{(i)}$，并对于每个给定的 $k$，计算平均相邻窗口重叠度\n$$\n\\overline{B}(k) = \\frac{1}{N_{\\mathrm{fix}}-1}\\sum_{i=1}^{N_{\\mathrm{fix}}-1} B_{i,i+1}.\n$$\n报告 $\\overline{B}(k)$，四舍五入到六位小数（无量纲）。\n2) 对于每个给定的 $k$，使用相同的系统参数，计算所需的最小窗口数 $N_{\\mathrm{req}}(k)$，以确保在 $[0,L]$ 上的每一对相邻窗口都达到至少为 $B_{\\min} = 0.3$ 的目标重叠度（无量纲）。将 $N_{\\mathrm{req}}(k)$ 报告为整数。\n\n测试套件：\n- 使用以下三个弹簧常数 $k$（单位 kJ/(mol·nm$^{2}$)）：$k \\in \\{1.0, 10.0, 200.0\\}$。\n- 如上所述，使用 $k_{0} = 25.0$ kJ/(mol·nm$^{2}$), $x_{c} = 0.5$ nm, $L = 1.0$ nm, $T = 300.0$ K, $k_{\\mathrm{B}} = 0.008314462618$ kJ/(mol·K), $N_{\\mathrm{fix}} = 5$ 和 $B_{\\min} = 0.3$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于按上述顺序给出的每个 $k$，输出一个双元素列表 $[\\overline{B}(k), N_{\\mathrm{req}}(k)]$，其中 $\\overline{B}(k)$ 四舍五入到六位小数，而 $N_{\\mathrm{req}}(k)$ 是一个整数。例如，一个包含三种情况的输出必须如下所示\n$[[\\overline{B}(k_{1}),N_{\\mathrm{req}}(k_{1})],[\\overline{B}(k_{2}),N_{\\mathrm{req}}(k_{2})],[\\overline{B}(k_{3}),N_{\\mathrm{req}}(k_{3})]]$\n在单行上。",
            "solution": "该问题已经过验证，被认为是有效的。它具有科学依据，问题设定良好、客观，并包含得出唯一且有意义解所需的所有必要信息。分析过程如下。\n\n问题的核心是计算由相邻伞形采样窗口产生的概率分布之间的统计重叠度。在以 $x_{0}^{(i)}$ 为中心的窗口 $i$ 中，总势能是基础平均力势 (PMF) $U_{0}(x)$ 和谐波偏置势 $U_{b}^{(i)}(x)$ 的和：\n$$\nU_{i}(x) = U_{0}(x) + U_{b}^{(i)}(x) = \\frac{1}{2} k_{0} (x - x_{c})^{2} + \\frac{1}{2} k (x - x_{0}^{(i)})^{2}\n$$\n这是关于反应坐标 $x$ 的二次函数。在正则系综中，$x$ 的概率分布由 $p_{i}(x) \\propto \\exp(-\\beta U_{i}(x))$ 给出，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$。由于 $U_{i}(x)$ 是 $x$ 的二次函数，因此得到的分布 $p_{i}(x)$ 是一个高斯（正态）分布。\n\n为了确定此高斯分布的参数，我们对 $U_{i}(x)$ 进行配方：\n$$\n\\begin{aligned}\nU_{i}(x) = \\frac{1}{2} [k_{0}(x^2 - 2xx_{c} + x_{c}^2) + k(x^2 - 2xx_{0}^{(i)} + (x_{0}^{(i)})^2)] \\\\\n= \\frac{1}{2} [(k_{0}+k)x^2 - 2(k_{0}x_{c} + kx_{0}^{(i)})x + (k_{0}x_{c}^2 + k(x_{0}^{(i)})^2)]\n\\end{aligned}\n$$\n这可以写成标准形式 $\\frac{1}{2}K(x-\\mu)^2 + C$。通过比较系数，我们确定了有效弹簧常数 $K = k_{0} + k$ 和分布的均值 $\\mu_{i}$：\n$$\n\\mu_{i} = \\frac{k_{0}x_{c} + kx_{0}^{(i)}}{k_{0} + k}\n$$\n窗口 $i$ 的概率分布为 $p_{i}(x) \\propto \\exp(-\\beta \\frac{1}{2}(k_{0}+k)(x-\\mu_{i})^2)$。将指数与高斯分布的标准形式 $-\\frac{(x-\\mu)^2}{2\\sigma^2}$ 进行比较，我们得到方差 $\\sigma_{i}^2$：\n$$\n\\frac{1}{2\\sigma_{i}^2} = \\frac{\\beta(k_{0}+k)}{2} \\implies \\sigma_{i}^2 = \\frac{1}{\\beta(k_{0}+k)}\n$$\n注意，方差（我们称之为 $\\sigma^2$）与窗口索引 $i$ 无关；对于给定的弹簧常数 $k$，所有窗口的方差都是相同的。因此，$p_{i}(x)$ 是一个正态分布 $\\mathcal{N}(x; \\mu_{i}, \\sigma^2)$。\n\n相邻窗口 $i$ 和 $i+1$ 之间的统计重叠度由巴氏系数给出，$B_{i,i+1} = \\int_{-\\infty}^{\\infty} \\sqrt{p_{i}(x)p_{i+1}(x)} dx$。对于两个均值分别为 $\\mu_{i}$、$\\mu_{i+1}$ 且方差同为 $\\sigma^2$ 的高斯分布，该积分有一个已知的解析解：\n$$\nB_{i,i+1} = \\exp\\left(-\\frac{(\\mu_{i} - \\mu_{i+1})^2}{8\\sigma^2}\\right)\n$$\n我们需要计算相邻窗口均值之间的差异。设 $\\Delta x_{0} = x_{0}^{(i+1)} - x_{0}^{(i)}$ 为相邻窗口中心之间的间距。\n$$\n\\mu_{i} - \\mu_{i+1} = \\frac{k_{0}x_{c} + kx_{0}^{(i)}}{k_{0} + k} - \\frac{k_{0}x_{c} + kx_{0}^{(i+1)}}{k_{0} + k} = \\frac{k(x_{0}^{(i)} - x_{0}^{(i+1)})}{k_{0} + k} = -\\frac{k\\,\\Delta x_{0}}{k_{0} + k}\n$$\n将此结果和 $\\sigma^2$ 的表达式代入 $B_{i,i+1}$ 的公式中：\n$$\nB_{i,i+1} = \\exp\\left(-\\frac{\\left(-\\frac{k\\,\\Delta x_{0}}{k_{0} + k}\\right)^2}{8 \\left(\\frac{1}{\\beta(k_{0}+k)}\\right)}\\right) = \\exp\\left(-\\frac{k^2 (\\Delta x_{0})^2}{(k_{0} + k)^2} \\frac{\\beta(k_{0}+k)}{8}\\right)\n$$\n这可以简化为重叠度的最终表达式，它取决于 $k$ 和 $\\Delta x_{0}$：\n$$\nB_{i,i+1} = \\exp\\left(- \\frac{\\beta k^2 (\\Delta x_{0})^2}{8(k_{0} + k)}\\right)\n$$\n由于窗口中心是均匀分布的，对于所有相邻的对 $i, i+1$，$\\Delta x_{0}$ 是一个常数，因此对于给定的 $k$ 和窗口数量，$B_{i,i+1}$ 也是一个常数。\n\n**任务 1：计算平均重叠度 $\\overline{B}(k)$**\n对于在区间 $[0, L]$ 上的固定窗口数 $N_{\\mathrm{fix}}=5$，窗口中心为 $x_0^{(i)} = \\frac{i-1}{N_{\\mathrm{fix}}-1}L$，其中 $i=1, \\dots, 5$。间距是恒定的：$\\Delta x_{0} = L/(N_{\\mathrm{fix}}-1)$。由于所有相邻对的重叠度 $B_{i,i+1}$ 都相等，因此平均重叠度 $\\overline{B}(k)$ 就等于这个共同的值。\n$$\n\\overline{B}(k) = B_{i,i+1} = \\exp\\left(- \\frac{\\beta k^2 (L/(N_{\\mathrm{fix}}-1))^2}{8(k_{0} + k)}\\right)\n$$\n\n**任务 2：计算所需的窗口数 $N_{\\mathrm{req}}(k)$**\n我们需要找到最小整数 $N \\geq 2$，使得相邻窗口的重叠度至少为 $B_{\\min}=0.3$。对于 $N$ 个均匀分布的窗口，间距为 $\\Delta x_{0} = L/(N-1)$。条件是：\n$$\n\\exp\\left(- \\frac{\\beta k^2 (L/(N-1))^2}{8(k_{0} + k)}\\right) \\geq B_{\\min}\n$$\n求解 $N$：\n$$\n- \\frac{\\beta k^2 L^2}{8(k_{0} + k)(N-1)^2} \\geq \\ln(B_{\\min})\n$$\n由于 $B_{\\min}  1$，$\\ln(B_{\\min})$ 是负数。两边乘以 $-1$ 会反转不等号：\n$$\n\\frac{\\beta k^2 L^2}{8(k_{0} + k)(N-1)^2} \\leq -\\ln(B_{\\min})\n$$\n分离出 $(N-1)^2$：\n$$\n(N-1)^2 \\geq \\frac{\\beta k^2 L^2}{8(k_{0} + k) [-\\ln(B_{\\min})]}\n$$\n由于 $N \\geq 2$，$N-1$ 是正数，所以我们可以取平方根：\n$$\nN-1 \\geq \\sqrt{\\frac{\\beta k^2 L^2}{8(k_{0} + k) [-\\ln(B_{\\min})]}} = \\frac{kL\\sqrt{\\beta}}{\\sqrt{8(k_{0} + k) [-\\ln(B_{\\min})]}}\n$$\n$$\nN \\geq 1 + \\frac{kL\\sqrt{\\beta}}{\\sqrt{8(k_{0} + k) [-\\ln(B_{\\min})]}}\n$$\n由于 $N$ 必须是整数，$N_{\\mathrm{req}}(k)$ 是等式右侧值的上取整。\n$$\nN_{\\mathrm{req}}(k) = \\left\\lceil 1 + \\frac{kL\\sqrt{\\beta}}{\\sqrt{8(k_{0} + k) [-\\ln(B_{\\min})]}} \\right\\rceil\n$$\n这些推导出的解析表达式在提供的程序中实现，用于计算给定测试套件中弹簧常数 $k \\in \\{1.0, 10.0, 200.0\\}$ kJ/(mol·nm$^2$) 所需的值，并使用 $k_0 = 25.0$ kJ/(mol·nm$^2$)、$L=1.0$ nm、$T=300.0$ K、$k_{\\mathrm{B}} = 0.008314462618$ kJ/(mol·K)、$N_{\\mathrm{fix}}=5$ 和 $B_{\\min} = 0.3$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes overlap metrics for umbrella sampling based on an analytical model.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    k0 = 25.0  # kJ/(mol·nm^2)\n    L = 1.0  # nm\n    T = 300.0  # K\n    kB = 0.008314462618  # kJ/(mol·K)\n    beta = 1.0 / (kB * T)  # mol/kJ\n    N_fix = 5  # Fixed number of windows for task 1\n    B_min = 0.3  # Target minimum overlap for task 2\n\n    # Test cases for the harmonic spring constant k in kJ/(mol·nm^2)\n    test_cases_k = [1.0, 10.0, 200.0]\n\n    def calculate_average_overlap(k):\n        \"\"\"\n        Task 1: Computes the average adjacent-window overlap for N_fix=5 windows.\n        \n        Args:\n            k (float): The umbrella spring constant in kJ/(mol·nm^2).\n        \n        Returns:\n            float: The average Bhattacharyya coefficient.\n        \"\"\"\n        if N_fix  2:\n            # Overlap is not defined for less than 2 windows.\n            return 0.0\n            \n        delta_x0 = L / (N_fix - 1)\n        \n        # Argument of the exponential function for the Bhattacharyya coefficient\n        exponent_arg = -(beta * k**2 * delta_x0**2) / (8 * (k0 + k))\n        \n        # For evenly spaced windows, the average overlap is equal to any single\n        # adjacent-pair overlap.\n        b_avg = np.exp(exponent_arg)\n        \n        return b_avg\n\n    def calculate_required_windows(k):\n        \"\"\"\n        Task 2: Computes the minimum number of windows to ensure overlap >= B_min.\n\n        Args:\n            k (float): The umbrella spring constant in kJ/(mol·nm^2).\n\n        Returns:\n            int: The minimum required number of windows.\n        \"\"\"\n        if B_min = 0 or B_min > 1:\n            raise ValueError(\"B_min must be in (0, 1].\")\n        \n        # If the overlap condition is trivially met (B_min=1), it would require\n        # infinite windows unless k=0, which is not a tested case. Return based on formula.\n        # But here B_min=0.3 so -log(B_min) is well-defined and positive.\n\n        # Term under the square root in the derived formula for N\n        radicand = (beta * k**2 * L**2) / (8 * (k0 + k) * (-np.log(B_min)))\n        \n        # The minimum (non-integer) number of windows required\n        n_float = 1.0 + np.sqrt(radicand)\n        \n        # The number of windows must be an integer, so we take the ceiling.\n        # The formula inherently ensures N>=2 since k>0 and sqrt term is positive.\n        n_req = int(np.ceil(n_float))\n        \n        return n_req\n\n    results = []\n    for k in test_cases_k:\n        b_bar = calculate_average_overlap(k)\n        n_req = calculate_required_windows(k)\n        results.append((b_bar, n_req))\n\n    # Format the output as specified: [[B(k1),N_req(k1)],[B(k2),N_req(k2)],...]\n    # Using f-string formatting to control decimal places and structure.\n    output_parts = [f\"[{res[0]:.6f},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在牢固掌握 PMF 基础和采样设计之后，我们现在转向一个全面的计算工作流程。这项总结性练习  将指导你完成一个完整的流程，使用伞形采样和加权直方图分析方法（WHAM）来计算结合自由能。你将生成合成的偏置数据，应用迭代的 WHAM 算法来重建无偏的 PMF，同时考虑几何校正，并最终计算标准态热力学性质，这与前沿研究所采用的过程如出一辙。",
            "id": "3838259",
            "problem": "要求您设计一个计算方案，使用伞形采样结合加权直方图分析方法 (WHAM)，来估算配体-受体沿标量径向分离坐标的结合平均力势 (PMF)。配体-受体的分离距离是一个以纳米为单位的标量坐标 $r$。三维空间中的径向度量引入了一个雅可比因子 $4\\pi r^2$，在计算 PMF 时必须明确考虑该因子。最终目标是计算标准态结合自由能。\n\n从以下基本原理出发：\n\n- 对于能量为 $U(x)$ 的坐标 $x$，其正则系综玻尔兹曼分布指出，概率密度与 $\\exp(-\\beta U(x))$ 成正比，其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是温度。\n- 对于三维径向坐标 $r$（无角度偏置），其度量因子为 $4\\pi r^2$，因此当 $G(r)$ 是排除了几何熵项的 PMF 时，关于标量 $r$ 的概率密度与 $4\\pi r^2 \\exp(-\\beta G(r))$ 成正比。\n- 伞形采样在窗口 $i$ 中施加一个谐波偏置：$U_i^\\mathrm{bias}(r) = \\tfrac{1}{2} k_i (r - r_i)^2$，其中力常数为 $k_i$，中心为 $r_i$。\n- 加权直方图分析方法 (WHAM) 通过强制实现全局分布与窗口归一化之间的自洽性，将来自多个窗口的带偏置的直方图组合成一个单一的无偏置分布。\n\n您的程序必须：\n\n1. 通过从已知的底层 PMF $G_\\mathrm{true}(r)$ 采样，为每个窗口构建合成的伞形采样直方图（以使问题自包含且可测试）。在所有测试用例中，用于生成数据的合成 PMF 是一个莫尔斯型函数\n   $$G_\\mathrm{true}(r) = D\\left(\\exp\\big(-2 a (r - r_0)\\big) - 2 \\exp\\big(-a (r - r_0)\\big)\\right),$$\n   其中 $D$ 是深度参数，单位为 $\\mathrm{kJ/mol}$，$a$ 是范围参数，单位为 $\\mathrm{nm}^{-1}$，$r_0$ 是最小值位置，单位为 $\\mathrm{nm}$。温度必须为 $T = 300$ $\\mathrm{K}$，玻尔兹曼常数必须为 $k_\\mathrm{B} = 0.008314462618$ $\\mathrm{kJ/(mol\\cdot K)}$，因此 $\\beta$ 的单位是 $(\\mathrm{kJ/mol})^{-1}$。$r$ 的网格必须是均匀的，其中 $r_\\mathrm{min} = 0.05$ $\\mathrm{nm}$，$r_\\mathrm{max} = 1.50$ $\\mathrm{nm}$，bin 宽度 $\\Delta r = 0.01$ $\\mathrm{nm}$。\n\n2. 对于每个窗口 $i$ 和以 $r_j$ 为中心的每个 bin，使用与 $4\\pi r_j^2 \\exp\\big(-\\beta\\big(G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)\\big)\\big)$ 成正比的带偏置的径向概率密度来构建期望的带偏置直方图计数，并在网格上进行归一化，使得窗口 $i$ 中的总计数等于指定的每个窗口的样本量 $N_i$。\n\n3. 实现加权直方图分析方法 (WHAM)，以从窗口直方图集及其谐波偏置中迭代地恢复网格上的全局无偏置概率密度 $\\hat{p}(r)$。不要使用任何快捷公式。从上述原理推导更新规则：\n   - 无偏置分布必须与由偏置引起的重加权因子的倒数和窗口归一化加权的窗口直方图总和保持一致。\n   - 必须更新每个窗口的归一化常数，以便全局分布能重加权回每个窗口的带偏置系综的归一化。\n\n   迭代直至窗口自由能收敛到一个严格的容差，即两次迭代之间所有窗口归一化常数的最大变化小于 $10^{-10}$ 能量单位。\n\n4. 通过明确地并入 $4\\pi r^2$ 因子，将无偏置的标量概率密度 $\\hat{p}(r)$ 转换为排除雅可比因子的 PMF $G(r)$。PMF 必须进行平移，使其在体相区域（此处定义为高 r 尾部）趋近于零。使用 $r \\in [1.30, 1.50]$ $\\mathrm{nm}$ 的体相范围，并强制 $G(r)$ 在此范围内的平均值为零。\n\n5. 通过在结合区域 $[0, r_c]$ 上积分结合常数来计算标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$：\n   - 计算径向结合常数 $K = \\int_0^{r_c} \\exp\\big(-\\beta G(r)\\big)\\,4\\pi r^2\\,dr$，单位为 $\\mathrm{nm}^3$。\n   - 使用标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$（在 $1$ $\\mathrm{M}$ 时）将其转换为无量纲的标准态平衡常数：$K^\\circ = K / V^\\circ$。\n   - 报告结合自由能 $\\Delta G_\\mathrm{bind}^\\circ = -\\beta^{-1} \\ln K^\\circ$，单位为 $\\mathrm{kJ/mol}$。\n\n您的程序必须实现上述步骤，并为以下测试套件生成结果。对于每种情况，请使用指定的窗口集、底层 PMF 参数、每个窗口的计数以及结合区域截断值 $r_c$。在每种情况下，伞形窗口的中心 $r_i$ 按指定均匀间隔分布，且具有相同的力常数 $k_i$：\n\n- 测试用例 1（通用情况）：\n  - 窗口中心：$r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 1200$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 50000$。\n  - 底层 PMF 参数：$D = 10$ $\\mathrm{kJ/mol}$，$a = 15$ $\\mathrm{nm}^{-1}$，$r_0 = 0.30$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.45$ $\\mathrm{nm}$。\n\n- 测试用例 2（弱结合边缘情况）：\n  - 窗口中心：$r_i \\in \\{0.20, 0.30, 0.40, \\dots, 1.20\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 900$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 30000$。\n  - 底层 PMF 参数：$D = 4$ $\\mathrm{kJ/mol}$，$a = 12$ $\\mathrm{nm}^{-1}$，$r_0 = 0.32$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.45$ $\\mathrm{nm}$。\n\n- 测试用例 3（强结合，更宽覆盖范围）：\n  - 窗口中心：$r_i \\in \\{0.15, 0.25, 0.35, \\dots, 1.35\\}$ $\\mathrm{nm}$，步长 $0.10$ $\\mathrm{nm}$。\n  - 力常数：$k_i = 1500$ $\\mathrm{kJ/(mol\\cdot nm^2)}$。\n  - 每个窗口的计数：$N_i = 60000$。\n  - 底层 PMF 参数：$D = 20$ $\\mathrm{kJ/mol}$，$a = 22$ $\\mathrm{nm}^{-1}$，$r_0 = 0.28$ $\\mathrm{nm}$。\n  - 结合区域截断值：$r_c = 0.40$ $\\mathrm{nm}$。\n\n角度单位在此不适用。所有能量以 $\\mathrm{kJ/mol}$ 表示，所有长度以 $\\mathrm{nm}$ 表示。您的程序必须生成单行输出，其中包含测试套件的三个结合自由能，形式为方括号括起来的逗号分隔列表，每个值四舍五入到三位小数（例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。",
            "solution": "目标是使用加权直方图分析方法 (WHAM) 从合成的伞形采样数据中计算平均力势 (PMF)，并随后计算标准态结合自由能。该过程包括几个步骤：生成合成的带偏置直方图，应用 WHAM 算法恢复无偏置概率分布，将此分布转换为 PMF，最后对 PMF 进行积分以获得结合自由能。\n\n首先，我们建立理论框架。沿着一维反应坐标 $r$ 的 PMF（表示为 $G(r)$）通过玻尔兹曼关系与平衡概率密度 $P(r)$ 相关联。对于三维空间中的径向坐标，体积元为 $4\\pi r^2 dr$，这在概率密度中引入了一个雅可比因子。在 $r$ 和 $r+dr$ 之间找到系统的概率 $P(r)dr$ 由以下公式给出：\n$$P(r) \\propto 4\\pi r^2 \\exp(-\\beta G(r))$$\n其中 $\\beta = 1/(k_\\mathrm{B} T)$，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。此处定义的 PMF $G(r)$ 代表了自由能剖面，其中不包括由 $4\\pi r^2$ 项所体现的几何熵贡献。\n\n伞形采样通过在每个模拟窗口 $i$ 中添加一个偏置势（通常是谐波势）来增强高能区域的采样。偏置势由 $U_i^\\mathrm{bias}(r) = \\frac{1}{2} k_i (r - r_i)^2$ 给出，其中 $k_i$ 是力常数，$r_i$ 是窗口 $i$ 的势能中心。在带偏置的模拟中，观测到的概率密度 $P_i^\\mathrm{bias}(r)$ 受此势能的调制：\n$$P_i^\\mathrm{bias}(r) \\propto 4\\pi r^2 \\exp(-\\beta [G(r) + U_i^\\mathrm{bias}(r)])$$\n\n加权直方图分析方法 (WHAM) 是一种稳健的统计技术，用于组合来自多个带偏置模拟（窗口）的数据，以计算沿反应坐标的无偏置概率分布。它通过求解一组自洽方程来确定最佳组合。设 $N_{ij}$ 为从窗口 $i$ 在坐标 bin $j$ 中观测到的样本数，$N_i = \\sum_j N_{ij}$ 为窗口 $i$ 中的总样本数。WHAM 方程将处于 bin $j$ 的无偏置概率 $P_j$ 与特定于窗口的自由能偏移量 $f_i$ 联系起来：\n$$\n\\begin{cases}\nP_j = \\left( \\sum_{k=1}^{M} N_{kj} \\right) \\left/ \\left( \\sum_{k=1}^{M} N_k \\exp(\\beta f_k) \\exp(-\\beta U_{kj}) \\right) \\right. \\\\\n\\exp(-\\beta f_i) = \\sum_{j=1}^{N_\\mathrm{bins}} P_j \\exp(-\\beta U_{ij})\n\\end{cases}\n$$\n此处，$M$ 是窗口数，$N_\\mathrm{bins}$ 是坐标 bin 的数量，$U_{ij} = U_i^\\mathrm{bias}(r_j)$ 是窗口 $i$ 的偏置势在 bin $j$ 中心处的值。概率 $P_j$ 的定义取决于一个全局归一化常数，通常被归一化以使 $\\sum_j P_j = 1$。自由能 $f_i$ 仅是相对定义的，因此通常将其中一个设置为零（例如 $f_1=0$）以获得唯一解。这些方程通过迭代求解，直到 $f_i$ 的值收敛。\n\n算法流程如下：\n1.  **系统设置和数据生成**：\n    - 定义物理常数 $\\beta = 1/(k_\\mathrm{B}T)$ 和 $r$ 值的离散网格 $r_j$，从 $r_\\mathrm{min}$ 到 $r_\\mathrm{max}$，bin 宽度为 $\\Delta r$。\n    - 对于每个测试用例，真实的底层 PMF $G_\\mathrm{true}(r)$ 由莫尔斯势定义：$G_\\mathrm{true}(r) = D(e^{-2a(r-r_0)} - 2e^{-a(r-r_0)})$。\n    - 对于每个窗口 $i$，生成一个合成直方图 $N_{ij}$。bin $j$ 中的期望计数值与带偏置的概率密度成正比：$N_{ij} \\propto N_i \\cdot 4\\pi r_j^2 \\exp(-\\beta[G_\\mathrm{true}(r_j) + U_i^\\mathrm{bias}(r_j)])$。计数被归一化，使得 $\\sum_j N_{ij} = N_i$。\n\n2.  **WHAM 迭代**：\n    - 初始化窗口自由能，例如，对所有 $i$ 设置 $f_i = 0$。\n    - 迭代直到任何 $f_i$ 的最大变化小于一个容差 ($10^{-10}$)：\n      a. 使用当前的 $f_i$ 值计算所有 bin 的无偏置概率 $P_j$。这需要计算每个 bin $j$ 的分母项 $D_j = \\sum_{k=1}^M N_k \\exp(\\beta f_k - \\beta U_{kj})$，以及每个 bin 的总计数 $C_j = \\sum_{k=1}^M N_{kj}$。然后未归一化的概率为 $\\tilde{P}_j = C_j / D_j$。最后，进行归一化，使得 $\\sum_j P_j = 1$。\n      b. 使用更新后的概率 $P_j$ 计算一组新的自由能 $f_i^\\mathrm{new}$：$f_i^\\mathrm{new} = -\\beta^{-1} \\ln\\left(\\sum_j P_j \\exp(-\\beta U_{ij})\\right)$。\n      c. 为防止数值漂移，平移新的自由能，例如，通过减去第一个自由能的值：$f_i^\\mathrm{new} \\leftarrow f_i^\\mathrm{new} - f_i^\\mathrm{new}[0]$。\n      d. 更新 $f_i \\leftarrow f_i^\\mathrm{new}$ 并检查收敛性。\n\n3.  **PMF 重建**：\n    - 一旦获得收敛的无偏置概率 $P_j$，就可以计算 PMF $G(r_j)$。从 $P_j \\propto 4\\pi r_j^2 \\exp(-\\beta G(r_j))$，我们可以写出 $G(r_j) = -\\beta^{-1} \\ln(P_j/r_j^2) + \\text{constant}$。对于 $P_j=0$ 的 bin，$G(r_j)$ 为无穷大。\n    - PMF 通过一个加性常数进行平移，使其在体相区域（定义为 $r \\in [1.30, 1.50]$ nm）的平均值为零。这将参考态设置为未结合态。\n\n4.  **结合自由能计算**：\n    - 标准态结合自由能 $\\Delta G_\\mathrm{bind}^\\circ$ 由结合常数 $K$ 确定。径向结合常数在定义的结合体积上进行积分：\n      $$K = \\int_0^{r_c} 4\\pi r^2 \\exp(-\\beta G(r)) dr$$\n      该积分通过对截至截断值 $r_c$ 的网格 bin 求和来进行数值近似：$K \\approx \\sum_{j: r_j \\le r_c} 4\\pi r_j^2 \\exp(-\\beta G(r_j)) \\Delta r$。\n    - 标准态平衡常数 $K^\\circ$ 通过除以标准态体积 $V^\\circ = 1.66053906660$ $\\mathrm{nm}^3$（相当于 $1$ M 标准浓度）获得：$K^\\circ = K/V^\\circ$。\n    - 最后，结合自由能计算如下：\n      $$\\Delta G_\\mathrm{bind}^\\circ = -k_\\mathrm{B} T \\ln(K^\\circ) = -\\beta^{-1} \\ln(K^\\circ)$$\n\n整个方案针对所提供的三个测试用例中的每一个都进行了实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the standard-state binding free energy for three test cases using WHAM.\n    \"\"\"\n\n    # --- Global Parameters and Constants ---\n    T = 300.0  # Temperature in K\n    K_B = 0.008314462618  # Boltzmann constant in kJ/(mol*K)\n    BETA = 1.0 / (K_B * T)  # In (kJ/mol)^-1\n    V_STANDARD = 1.66053906660  # Standard state volume in nm^3 (for 1 M)\n\n    # --- Grid setup ---\n    R_MIN = 0.05  # nm\n    R_MAX = 1.50  # nm\n    DR = 0.01  # nm\n    r_grid = np.arange(R_MIN, R_MAX + DR / 2.0, DR)\n    num_bins = len(r_grid)\n\n    # --- Bulk region definition for PMF shifting ---\n    BULK_MIN = 1.30\n    BULK_MAX = 1.50\n\n    # --- WHAM convergence criterion ---\n    WHAM_TOLERANCE = 1e-10\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 1200.0,\n            \"N_i\": 50000,\n            \"D\": 10.0,\n            \"a\": 15.0,\n            \"r0\": 0.30,\n            \"rc\": 0.45,\n        },\n        # Test Case 2\n        {\n            \"window_centers\": np.arange(0.20, 1.20 + 0.05, 0.10),\n            \"k\": 900.0,\n            \"N_i\": 30000,\n            \"D\": 4.0,\n            \"a\": 12.0,\n            \"r0\": 0.32,\n            \"rc\": 0.45,\n        },\n        # Test Case 3\n        {\n            \"window_centers\": np.arange(0.15, 1.35 + 0.05, 0.10),\n            \"k\": 1500.0,\n            \"N_i\": 60000,\n            \"D\": 20.0,\n            \"a\": 22.0,\n            \"r0\": 0.28,\n            \"rc\": 0.40,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        window_centers = case[\"window_centers\"]\n        k = case[\"k\"]\n        N_i_val = case[\"N_i\"]\n        D = case[\"D\"]\n        a = case[\"a\"]\n        r0 = case[\"r0\"]\n        rc = case[\"rc\"]\n\n        num_windows = len(window_centers)\n        \n        # --- 1. Construct Synthetic Histograms ---\n        \n        # True PMF (Morse potential)\n        g_true = D * (np.exp(-2 * a * (r_grid - r0)) - 2 * np.exp(-a * (r_grid - r0)))\n        \n        histograms = np.zeros((num_windows, num_bins))\n        biases_matrix = np.zeros((num_windows, num_bins))\n        N_i_array = np.full(num_windows, N_i_val, dtype=float)\n\n        for i in range(num_windows):\n            r_center = window_centers[i]\n            # Harmonic bias potential for window i\n            u_bias = 0.5 * k * (r_grid - r_center)**2\n            biases_matrix[i, :] = u_bias\n            \n            # Biased energy\n            biased_energy = g_true + u_bias\n            \n            # Biased probability distribution including Jacobian\n            # Prop to 4*pi*r^2 * exp(-beta * E_biased)\n            unnorm_prob = (4 * np.pi * r_grid**2) * np.exp(-BETA * biased_energy)\n            \n            # Normalize probability for this window\n            norm_factor = np.sum(unnorm_prob)\n            if norm_factor == 0:\n                # This case shouldn't happen with the given parameters\n                # but good practice to handle.\n                norm_prob = np.zeros_like(unnorm_prob)\n            else:\n                norm_prob = unnorm_prob / norm_factor\n\n            # Generate histogram counts\n            histograms[i, :] = N_i_val * norm_prob\n            \n        # --- 3. Implement WHAM ---\n        f_i = np.zeros(num_windows)  # Initialize window free energies\n        \n        # Pre-compute terms that don't change in the loop\n        total_counts_per_bin = np.sum(histograms, axis=0) # Numerator of P_j\n        exp_minus_beta_U = np.exp(-BETA * biases_matrix) # exp(-beta*U_ij)\n        \n        for iteration in range(10000): # Max iterations to prevent infinite loop\n            f_old = f_i.copy()\n            \n            # Denominator of P_j\n            exp_beta_f = np.exp(BETA * f_i)\n            weighted_N = N_i_array * exp_beta_f\n            \n            # Sum over windows k for each bin j\n            den_P = weighted_N @ exp_minus_beta_U\n            \n            with np.errstate(divide='ignore', invalid='ignore'):\n                P_unnormalized = total_counts_per_bin / den_P\n            \n            P_unnormalized[np.isnan(P_unnormalized)] = 0.0\n\n            # Normalize probabilities\n            P = P_unnormalized / np.sum(P_unnormalized)\n            \n            # Update free energies f_i\n            with np.errstate(divide='ignore'):\n              log_arg = P @ exp_minus_beta_U.T\n            \n            f_new = -1.0 / BETA * np.log(log_arg)\n            f_new[np.isinf(f_new)] = f_i[np.isinf(f_new)] # Keep old if log_arg is 0\n\n            # Shift to prevent drift\n            f_new -= f_new[0]\n            f_i = f_new\n\n            # Check for convergence\n            max_change = np.max(np.abs(f_i - f_old))\n            if max_change  WHAM_TOLERANCE:\n                break\n        \n        # --- 4. Convert Probability to PMF and Shift ---\n        with np.errstate(divide='ignore'):\n             # G = -k_B*T * (ln(P) - ln(4*pi*r^2*dr))\n             # The constant term ln(4*pi*dr) will be absorbed into the shifting constant\n             G = -1.0 / BETA * (np.log(P) - 2.0 * np.log(r_grid))\n\n        G[np.isneginf(G)] = np.inf # Bins with P=0 have infinite free energy\n        \n        # Shift PMF so bulk region (high r) is zero\n        bulk_mask = (r_grid >= BULK_MIN)  (r_grid = BULK_MAX)\n        G_bulk = G[bulk_mask]\n        \n        finite_G_bulk = G_bulk[np.isfinite(G_bulk)]\n        if len(finite_G_bulk) > 0:\n            shift = np.mean(finite_G_bulk)\n            G -= shift\n        \n        # --- 5. Compute Standard-State Binding Free Energy ---\n        bound_mask = r_grid = rc\n        \n        # Integrand for association constant K\n        integrand = np.exp(-BETA * G) * (4 * np.pi * r_grid**2)\n        \n        # Numerical integration (sum over bins)\n        K = np.sum(integrand[bound_mask]) * DR\n\n        # Standard-state equilibrium constant and free energy\n        if K > 0 and V_STANDARD > 0:\n            K_standard = K / V_STANDARD\n            delta_G_bind = -1.0 / BETA * np.log(K_standard)\n        else:\n            delta_G_bind = np.inf # Should not happen\n\n        results.append(round(delta_G_bind, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}