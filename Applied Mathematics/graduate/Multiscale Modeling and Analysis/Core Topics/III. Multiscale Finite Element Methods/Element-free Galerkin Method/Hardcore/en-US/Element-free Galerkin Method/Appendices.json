{
    "hands_on_practices": [
        {
            "introduction": "The patch test is an essential benchmark for validating any numerical method used in computational mechanics. This first exercise guides you through a one-dimensional patch test, which serves to verify that your Moving Least Squares (MLS) shape functions can exactly reproduce a linear displacement field, a critical property for convergence. This practice will also provide direct insight into how the accuracy of the background numerical integration scheme affects the consistency of the Element-Free Galerkin (EFG) formulation .",
            "id": "3754048",
            "problem": "Construct a one-dimensional Element-Free Galerkin (EFG) patch test for a linear elastic bar using a Moving Least Squares (MLS) approximation and verify the patch test under an imposed linear displacement field. The bar has length $L$, cross-sectional area $A$, and Young’s modulus $E$, all treated as dimensionless constants for this test. The program must assemble the Galerkin residual under the imposed field using background Gauss–Legendre integration and quantify how numerical integration accuracy affects the residual.\n\nYou must derive and implement the following from first principles.\n\n1) Fundamental base and weak form. Start from the one-dimensional linear elasticity equilibrium in strong form with no body force,\n$$(A E u'(x))' = 0 \\quad \\text{on } x \\in (0,L),$$\nand the principle of virtual work (weak form),\n$$\\int_0^L A E u'(x) \\, \\delta u'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\delta u(x) \\right]_{x=0}^{x=L} = 0,$$\nwhere $\\sigma(x) = E u'(x)$ is the Cauchy stress and $\\delta u(x)$ is an arbitrary admissible virtual displacement. In the Galerkin discretization with trial field $u_h(x)$ and test functions $\\phi_i(x)$, the residual at node $i$ is\n$$r_i = \\int_0^L \\phi_i'(x) \\, A E \\, u_h'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L}.$$\n\n2) Imposed patch field. Impose a linear displacement field\n$$u_h(x) = a + b x,$$\nwhere $a$ and $b$ are constants. Then $u_h'(x) = b$ and the exact stress is constant $\\sigma(x) = E b$. With exact integration, the weak form reduces by integration by parts to an identity, and the exact residual satisfies $r_i = 0$ for all $i$. Any nonzero $r_i$ in the computation arises from numerical integration error or approximation inconsistency.\n\n3) Moving Least Squares (MLS) shape functions for the EFG method. Let the nodes be uniformly spaced points $x_i$ with $i=0,\\dots,N-1$ over $[0,L]$. Use a linear polynomial basis $p(x) = [1, x]^T$. Define the weight for node $i$ at position $x$ as\n$$w_i(x) = W\\!\\left(q_i(x)\\right), \\quad q_i(x) = \\frac{|x - x_i|}{d},$$\nwith a compactly supported quartic spline weight\n$$W(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1,\\\\\n0, & q > 1,\n\\end{cases}$$\nand its derivative for $0 \\le q \\le 1$ given by\n$$W'(q) = -12 q + 24 q^2 - 12 q^3.$$\nThe support radius $d$ is the same for all nodes and is set as a multiple of the uniform nodal spacing. Define the MLS moment matrix and vectors as\n$$M(x) = \\sum_{i=0}^{N-1} w_i(x) \\, p(x_i) \\, p(x_i)^T, \\quad m_i(x) = w_i(x) \\, p(x_i).$$\nAssuming $M(x)$ is invertible, the MLS shape function for node $i$ is\n$$\\phi_i(x) = p(x)^T M(x)^{-1} m_i(x).$$\nThe derivative is obtained by differentiating with respect to $x$,\n$$\\phi_i'(x) = p'(x)^T M(x)^{-1} m_i(x) + p(x)^T \\left(-M(x)^{-1} M'(x) M(x)^{-1}\\right) m_i(x) + p(x)^T M(x)^{-1} m_i'(x),$$\nwhere\n$$p'(x) = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad M'(x) = \\sum_{i=0}^{N-1} w_i'(x) \\, p(x_i) \\, p(x_i)^T, \\quad m_i'(x) = w_i'(x) \\, p(x_i),$$\nand\n$$w_i'(x) = W'(q_i(x)) \\cdot \\frac{d}{dx} q_i(x), \\quad \\frac{d}{dx} q_i(x) = \\frac{\\operatorname{sign}(x - x_i)}{d} \\text{ for } x \\ne x_i, \\text{ and } 0 \\text{ at } x = x_i.$$\n\n4) Background integration. Partition $[0,L]$ into uniform background cells aligned with the nodal intervals. On each cell, perform Gauss–Legendre quadrature with a specified number of points per cell. For quadrature points $x_g$ with weights $w_g$ on a cell of length $\\Delta x$, approximate\n$$\\int_{x_\\ell}^{x_r} \\phi_i'(x) \\, dx \\approx \\sum_g \\phi_i'(x_g) \\, w_g \\, \\frac{\\Delta x}{2},$$\nand likewise for the full volume integral with the constant factor $A E b$.\n\n5) Boundary term. The boundary contribution is computed exactly by evaluating the MLS shape functions at $x=0$ and $x=L$,\n$$\\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L} = A \\, E \\, b \\, \\left( \\phi_i(L) - \\phi_i(0) \\right).$$\n\n6) Residual vector and norms. Assemble the residual vector $r \\in \\mathbb{R}^N$ with entries $r_i$ as above. Report the Euclidean norm\n$$\\| r \\|_2 = \\left( \\sum_{i=0}^{N-1} r_i^2 \\right)^{1/2}.$$\n\nYour program must implement the above, using the following fixed parameters common to all tests unless otherwise specified: bar length $L = 1$, area $A = 1$, modulus $E = 1$, imposed field parameters $a = 0.3$ and $b = 0.7$. The nodal spacing is uniform on $[0,L]$. The MLS support radius is $d = \\alpha \\, \\Delta x$, where $\\Delta x = L / (N - 1)$ and $\\alpha$ is a specified factor per test.\n\nTest suite. Your program must evaluate and print the Euclidean norm $\\| r \\|_2$ for each of the following three parameter sets:\n\n- Test 1 (underintegration): number of nodes $N = 11$, support factor $\\alpha = 2.5$, number of Gauss–Legendre points per cell $n_g = 1$.\n- Test 2 (adequate integration): number of nodes $N = 11$, support factor $\\alpha = 2.5$, number of Gauss–Legendre points per cell $n_g = 3$.\n- Test 3 (refined discretization and integration): number of nodes $N = 21$, support factor $\\alpha = 2.0$, number of Gauss–Legendre points per cell $n_g = 5$.\n\nFinal output format. Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be a floating-point number representing $\\| r \\|_2$ for the corresponding test case. No units are required because all parameters are dimensionless in this setup.",
            "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information for a unique solution. It describes a standard patch test for the Element-Free Galerkin (EFG) method, a recognized technique in computational mechanics, applied to the fundamental problem of 1D linear elasticity. All equations, parameters, and procedures are consistent with established literature on the subject.\n\n### Step 1: Problem Statement Validation\n\n**Extracted Givens:**\n- **Governing Equation (Strong Form):** $(A E u'(x))' = 0$ on $x \\in (0,L)$.\n- **Principle of Virtual Work (Weak Form):** $\\int_0^L A E u'(x) \\, \\delta u'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\delta u(x) \\right]_{x=0}^{x=L} = 0$, with $\\sigma(x) = E u'(x)$.\n- **Galerkin Residual:** $r_i = \\int_0^L \\phi_i'(x) \\, A E \\, u_h'(x) \\, dx - \\left[ A \\, \\sigma(x) \\, \\phi_i(x) \\right]_{x=0}^{x=L}$.\n- **Imposed Displacement Field:** $u_h(x) = a + b x$, leading to $u_h'(x) = b$ and $\\sigma(x) = E b$.\n- **MLS Nodal Basis:** A linear polynomial basis $p(x) = [1, x]^T$.\n- **MLS Weight Function:** A quartic spline $W(q) = 1 - 6 q^2 + 8 q^3 - 3 q^4$ for $q \\in [0, 1]$, with $q_i(x) = |x - x_i|/d$.\n- **Weight Function Derivative:** $W'(q) = -12 q + 24 q^2 - 12 q^3$.\n- **MLS Moment Matrix:** $M(x) = \\sum_{i=0}^{N-1} w_i(x) \\, p(x_i) \\, p(x_i)^T$.\n- **MLS Shape Function:** $\\phi_i(x) = p(x)^T M(x)^{-1} (w_i(x) \\, p(x_i))$.\n- **Shape Function Derivative:** A specified formula involving derivatives of $p(x)$, $M(x)$, and $w_i(x)$.\n- **Numerical Integration:** Gauss-Legendre quadrature on uniform background cells.\n- **Boundary Term:** Computed as $A \\, E \\, b \\, \\left( \\phi_i(L) - \\phi_i(0) \\right)$.\n- **Output Metric:** Euclidean norm of the residual vector, $\\| r \\|_2 = ( \\sum_{i=0}^{N-1} r_i^2 )^{1/2}$.\n- **Fixed Parameters:** $L = 1$, $A = 1$, $E = 1$, $a = 0.3$, $b = 0.7$.\n- **Test Cases:**\n    1. $N = 11$, $\\alpha = 2.5$, $n_g = 1$.\n    2. $N = 11$, $\\alpha = 2.5$, $n_g = 3$.\n    3. $N = 21$, $\\alpha = 2.0$, $n_g = 5$.\n\n**Validation Verdict:**\nThe problem is valid. It is a scientifically sound specification for a standard numerical verification procedure (the patch test) in computational mechanics. The mathematical formulation of the EFG method is correct. The problem is self-contained, with all necessary parameters and definitions provided. It is objective and well-posed, leading to a unique and meaningful numerical result for each test case.\n\n### Step 2: Solution Derivation and Implementation Plan\n\nThe objective is to compute the residual vector $r$ for an EFG discretization under an imposed linear displacement field. The non-zero magnitude of this residual will quantify the error introduced by the numerical quadrature of the weak form.\n\n**1. Residual Equation for the Patch Test**\nSubstituting the imposed linear field $u_h(x) = a + b x$ into the Galerkin residual expression gives $u_h'(x) = b$ and $\\sigma(x) = E u_h'(x) = E b$. The residual for node $i$ becomes:\n$$r_i = \\int_0^L \\phi_i'(x) \\, A E b \\, dx - \\left[ A (E b) \\phi_i(x) \\right]_{x=0}^{x=L}$$\nSince $A$, $E$, and $b$ are constants, they can be factored out:\n$$r_i = A E b \\left( \\int_0^L \\phi_i'(x) \\, dx - (\\phi_i(L) - \\phi_i(0)) \\right)$$\nBy the Fundamental Theorem of Calculus, the exact integral $\\int_0^L \\phi_i'(x) \\, dx$ is equal to $\\phi_i(L) - \\phi_i(0)$. Therefore, if the integration were performed exactly, the residual $r_i$ would be zero for all $i$. Any computed non-zero residual is a direct measure of the numerical integration error.\n\n**2. Moving Least Squares (MLS) Shape Functions**\nThe core of the EFG method is the construction of MLS shape functions $\\phi_i(x)$ and their derivatives $\\phi_i'(x)$. For a given evaluation point $x$, the procedure is as follows:\n- Identify the set of \"active\" nodes $\\{x_j\\}$ whose support domains $|x - x_j| \\le d$ contain the point $x$.\n- Use a linear basis $p(x) = [1, x]^T$.\n- Construct the $2 \\times 2$ moment matrix $M(x)$ and its derivative $M'(x)$:\n$$M(x) = \\sum_{j \\text{ active}} W\\left(\\frac{|x - x_j|}{d}\\right) p(x_j) p(x_j)^T$$\n$$M'(x) = \\sum_{j \\text{ active}} W'\\left(\\frac{|x - x_j|}{d}\\right) \\frac{\\operatorname{sign}(x - x_j)}{d} p(x_j) p(x_j)^T$$\n- For each node $i$, the shape function $\\phi_i(x)$ and its derivative $\\phi_i'(x)$ are non-zero only if $i$ is an active node. For such a node, we define the vector $m_i(x) = w_i(x) p(x_i)$ and its derivative $m_i'(x) = w_i'(x) p(x_i)$, where $w_i(x)$ is the weight function.\n- The shape function is then:\n$$\\phi_i(x) = p(x)^T M(x)^{-1} m_i(x)$$\n- The derivative is found using the product and chain rules:\n$$\\phi_i'(x) = p'(x)^T M(x)^{-1} m_i(x) + p(x)^T \\left( \\frac{d}{dx} M(x)^{-1} \\right) m_i(x) + p(x)^T M(x)^{-1} m_i'(x)$$\nwhere $\\frac{d}{dx} M(x)^{-1} = -M(x)^{-1} M'(x) M(x)^{-1}$.\n\n**3. Numerical Integration of the Residual**\nThe integral part of the residual is approximated using Gauss-Legendre quadrature. The domain $[0, L]$ is divided into $N-1$ background cells, coinciding with the nodal intervals $[x_j, x_{j+1}]$. For each cell, the integral is approximated as a weighted sum over $n_g$ Gauss points.\nFor a cell $[x_L, x_R]$ of length $\\Delta x = x_R - x_L$, the quadrature points $x_{gk}$ and weights $w_{gk}$ are mapped from the standard interval $[-1, 1]$ (with points $\\hat{x}_k$ and weights $\\hat{w}_k$):\n$$x_{gk} = x_L + \\frac{\\hat{x}_k + 1}{2} \\Delta x$$\n$$w_{gk} = \\hat{w}_k \\frac{\\Delta x}{2}$$\nThe integral for $r_i$ is then approximated as:\n$$\\int_0^L \\phi_i'(x) \\, dx \\approx \\sum_{j=0}^{N-2} \\sum_{k=1}^{n_g} \\phi_i'(x_{gk}) \\cdot w_{gk}$$\nwhere $x_{gk}$ are the Gauss points in the $j$-th cell.\n\n**4. Assembling the Final Residual**\nFor each node $i=0, \\dots, N-1$, the residual component $r_i$ is calculated by:\n1.  Computing the boundary terms $\\phi_i(0)$ and $\\phi_i(L)$ using the MLS shape function formula.\n2.  Computing the numerical integral as described above.\n3.  Combining these parts:\n$$r_i = A E b \\left( \\left( \\sum_{j=0}^{N-2} \\sum_{k=1}^{n_g} \\phi_i'(x_{gk}) \\cdot w_{gk} \\right) - (\\phi_i(L) - \\phi_i(0)) \\right)$$\nFinally, the Euclidean norm of the resulting vector $r = [r_0, r_1, \\dots, r_{N-1}]^T$ is computed to provide a single scalar measure of the overall error for each test case. An increase in the number of Gauss points $n_g$ is expected to decrease the value of $\\|r\\|_2$, demonstrating convergence towards the exact result of zero.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef quartic_spline_W(q):\n    \"\"\"Computes the quartic spline weight function W(q).\"\"\"\n    q_abs = np.abs(q)\n    if q_abs >= 1.0:\n        return 0.0\n    return 1.0 - 6.0 * q_abs**2 + 8.0 * q_abs**3 - 3.0 * q_abs**4\n\ndef quartic_spline_W_prime(q):\n    \"\"\"Computes the derivative of the quartic spline weight function W'(q).\"\"\"\n    q_abs = np.abs(q)\n    if q_abs >= 1.0:\n        return 0.0\n    return -12.0 * q_abs + 24.0 * q_abs**2 - 12.0 * q_abs**3\n\ndef compute_mls_shape_functions(x, nodes, d):\n    \"\"\"\n    Computes the MLS shape functions phi_i(x) and their derivatives dphi_i/dx\n    at a point x for all nodes.\n    \"\"\"\n    N = len(nodes)\n    p_x = np.array([1.0, x])\n    dp_x = np.array([0.0, 1.0])\n    \n    phis = np.zeros(N)\n    dphis = np.zeros(N)\n\n    active_indices = [i for i, xi in enumerate(nodes) if np.abs(x - xi) < d]\n\n    if len(active_indices) < 2:\n        # Not enough nodes for a 2x2 M matrix to be invertible\n        return phis, dphis\n    \n    M = np.zeros((2, 2))\n    M_prime = np.zeros((2, 2))\n\n    # Construct M(x) and M'(x)\n    for i in active_indices:\n        xi = nodes[i]\n        p_xi = np.array([1.0, xi])\n        p_xi_outer = np.outer(p_xi, p_xi)\n        \n        q = np.abs(x - xi) / d\n        wi = quartic_spline_W(q)\n        \n        dq_dx = np.sign(x - xi) / d if x != xi else 0.0\n        wi_prime = quartic_spline_W_prime(q) * dq_dx\n        \n        M += wi * p_xi_outer\n        M_prime += wi_prime * p_xi_outer\n\n    # The moment matrix M must be invertible\n    if np.linalg.det(M) < 1e-12:\n        return phis, dphis\n        \n    M_inv = np.linalg.inv(M)\n    M_inv_prime = -M_inv @ M_prime @ M_inv\n\n    # Compute shape functions and their derivatives for active nodes\n    for i in active_indices:\n        xi = nodes[i]\n        p_xi = np.array([1.0, xi])\n        \n        q = np.abs(x - xi) / d\n        wi = quartic_spline_W(q)\n        \n        dq_dx = np.sign(x - xi) / d if x != xi else 0.0\n        wi_prime = quartic_spline_W_prime(q) * dq_dx\n        \n        m_i = wi * p_xi\n        m_i_prime = wi_prime * p_xi\n\n        phis[i] = p_x @ M_inv @ m_i\n        \n        term1 = dp_x @ M_inv @ m_i\n        term2 = p_x @ M_inv_prime @ m_i\n        term3 = p_x @ M_inv @ m_i_prime\n        dphis[i] = term1 + term2 + term3\n        \n    return phis, dphis\n\n\ndef run_efg_patch_test(N, alpha, n_g):\n    \"\"\"\n    Runs the 1D EFG patch test for a given set of parameters.\n    \"\"\"\n    # Fixed parameters\n    L, A, E = 1.0, 1.0, 1.0\n    a, b = 0.3, 0.7\n\n    # Discretization parameters\n    nodes = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    d = alpha * dx\n\n    # Gauss-Legendre quadrature points and weights for the standard interval [-1, 1]\n    gauss_points, gauss_weights = leggauss(n_g)\n\n    # Calculate boundary terms: A*E*b * (phi_i(L) - phi_i(0))\n    phis_at_0, _ = compute_mls_shape_functions(0.0, nodes, d)\n    phis_at_L, _ = compute_mls_shape_functions(L, nodes, d)\n    boundary_terms = A * E * b * (phis_at_L - phis_at_0)\n\n    # Calculate volume integral term using numerical quadrature\n    volume_integrals = np.zeros(N)\n    for j in range(N - 1):\n        x_left, x_right = nodes[j], nodes[j+1]\n        cell_length = x_right - x_left\n        \n        for k in range(n_g):\n            gp = gauss_points[k]\n            gw = gauss_weights[k]\n            \n            # Map Gauss point from [-1, 1] to [x_left, x_right]\n            x_eval = x_left + (gp + 1.0) / 2.0 * cell_length\n            \n            _, dphis_at_x_eval = compute_mls_shape_functions(x_eval, nodes, d)\n            \n            # Add contribution to the integral for each node i\n            integrand = dphis_at_x_eval * A * E * b\n            volume_integrals += integrand * gw * (cell_length / 2.0)\n\n    # Compute residuals\n    residuals = volume_integrals - boundary_terms\n    \n    # Return the Euclidean norm of the residual vector\n    return np.linalg.norm(residuals)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # (N, alpha, n_g)\n    test_cases = [\n        (11, 2.5, 1),  # Test 1\n        (11, 2.5, 3),  # Test 2\n        (21, 2.0, 5),  # Test 3\n    ]\n\n    results = []\n    for N, alpha, n_g in test_cases:\n        norm_r = run_efg_patch_test(N, alpha, n_g)\n        results.append(norm_r)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the foundational 1D verification, this practice extends the patch test to two-dimensional plane stress problems. You will derive and implement the strain-displacement matrix, or $B$-matrix, which forms the crucial link between the nodal displacement parameters and the continuum strain field. By demonstrating that your 2D EFG implementation can precisely reproduce a constant strain state, you will confirm that it satisfies a necessary condition for convergence in general elasticity analysis .",
            "id": "3754044",
            "problem": "You are to construct the strain-displacement matrix in the Element-Free Galerkin (EFG) method and verify the constant strain patch test for two-dimensional plane stress. Start from the small-strain kinematics and the definition of the displacement approximation in EFG with Moving Least Squares (MLS) shape functions.\n\nUse the following fundamental base:\n- Small-strain tensor in two dimensions with engineering shear: given a displacement field $\\mathbf{u} = [u, v]^{\\top}$, the engineering strain vector is $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^{\\top}$ with\n$$\n\\epsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\epsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}.\n$$\n- The Element-Free Galerkin (EFG) method approximates $u(\\mathbf{x})$ and $v(\\mathbf{x})$ via a linear combination of shape functions $\\{\\phi_I(\\mathbf{x})\\}$ constructed by the Moving Least Squares (MLS) procedure: \n$$\nu^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I, \\quad v^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I,\n$$\nwhere $N$ is the number of nodes, $(u_I, v_I)$ are nodal displacement degrees of freedom, and $\\phi_I(\\mathbf{x})$ are MLS shape functions built from a linear polynomial basis $p(\\mathbf{x}) = [1, x, y]^{\\top}$ and a radially symmetric weight function.\n\nTask A (derivation): Derive the node-wise strain-displacement matrix $B_I(\\mathbf{x})$ for two-dimensional plane stress in terms of the spatial gradient $\\nabla \\phi_I(\\mathbf{x}) = [\\partial \\phi_I/\\partial x, \\partial \\phi_I/\\partial y]^{\\top}$ using only the small-strain definition and the EFG approximation above. Your derivation must not assume any specific formula for $B_I(\\mathbf{x})$ in advance.\n\nTask B (implementation): Implement a program that:\n- Constructs the Moving Least Squares (MLS) shape functions $\\phi_I(\\mathbf{x})$ and their gradients $\\nabla \\phi_I(\\mathbf{x})$ at arbitrary points $\\mathbf{x} = (x,y)$ using:\n  - Linear polynomial basis $p(\\mathbf{x}) = [1, x, y]^{\\top}$,\n  - Gaussian weight function centered at node $I$ with dilation parameter $d$: \n  $$\n  w_I(\\mathbf{x}) = \\exp\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{x}_I\\|^2}{d^2}\\right).\n  $$\n- Uses the derived $B_I(\\mathbf{x})$ to compute the engineering strain $\\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x})$ from nodal displacements $\\{(u_I, v_I)\\}$ by \n$$\n\\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x}) = \\sum_{I=1}^{N} B_I(\\mathbf{x}) \\begin{bmatrix} u_I \\\\ v_I \\end{bmatrix}.\n$$\n- Verifies the constant strain patch test: given a target constant engineering strain vector $\\boldsymbol{\\epsilon}^* = [\\epsilon_{xx}^*, \\epsilon_{yy}^*, \\gamma_{xy}^*]^{\\top}$, construct the exact linear displacement field\n$$\nu^*(x,y) = \\epsilon_{xx}^* x + \\tfrac{1}{2}\\gamma_{xy}^* y, \\quad v^*(x,y) = \\tfrac{1}{2}\\gamma_{xy}^* x + \\epsilon_{yy}^* y,\n$$\nassign nodal displacements $(u_I, v_I) = (u^*(x_I, y_I), v^*(x_I, y_I))$, and evaluate the maximum absolute error\n$$\nE_{\\max} = \\max_{\\mathbf{x} \\in \\mathcal{Q}} \\left\\| \\hat{\\boldsymbol{\\epsilon}}(\\mathbf{x}) - \\boldsymbol{\\epsilon}^* \\right\\|_{\\infty}\n$$\nover a set of sample points $\\mathcal{Q}$ in the domain. Declare the patch test passed if $E_{\\max} \\le \\text{tol}$ for a given tolerance $\\text{tol}$.\n\nImplementation specifics:\n- Domain: the unit square $[0,1]\\times[0,1]$ without units.\n- Nodes: either a uniform grid or a mildly perturbed grid as specified below.\n- Basis: linear $p(\\mathbf{x}) = [1, x, y]^{\\top}$.\n- Weight: Gaussian, with dilation parameter $d$ as specified in each test.\n- Numerical differentiation of shape functions is not allowed; you must derive and implement the analytical gradient $\\nabla \\phi_I(\\mathbf{x})$ by differentiating the MLS expressions with respect to $x$ and $y$.\n- Ill-conditioning handling: If the $3\\times 3$ MLS moment matrix $A(\\mathbf{x})$ is singular or numerically ill-conditioned at a sample point, declare the patch test failed for that test case.\n\nTest suite:\nProvide four test cases; for each, compute the boolean result of the patch test (true if passed, false if failed). Use the following parameter sets:\n\n- Test case $1$ (happy path, uniform nodes):\n  - Nodes: uniform grid of $n \\times n$ with $n = 5$ on $[0,1]\\times[0,1]$,\n  - Jitter amplitude: $0$,\n  - Dilation: $d = 0.35$,\n  - Target strain: $\\boldsymbol{\\epsilon}^* = [0.01, -0.02, 0.003]^{\\top}$,\n  - Sample points $\\mathcal{Q}$: the nine points with coordinates $(x,y) \\in \\{0.25, 0.5, 0.75\\}\\times\\{0.25, 0.5, 0.75\\}$,\n  - Tolerance: $\\text{tol} = 10^{-8}$.\n\n- Test case $2$ (irregular nodes):\n  - Nodes: $n \\times n$ with $n = 5$, each node perturbed by independent uniform jitter in $[-0.04, 0.04]$ added to both $x$ and $y$,\n  - Dilation: $d = 0.30$,\n  - Target strain: $\\boldsymbol{\\epsilon}^* = [0.01, -0.02, 0.003]^{\\top}$,\n  - Sample points $\\mathcal{Q}$: same nine points as in test case $1$,\n  - Tolerance: $\\text{tol} = 10^{-8}$.\n\n- Test case $3$ (boundary evaluation):\n  - Nodes: uniform grid of $n \\times n$ with $n = 5$,\n  - Jitter amplitude: $0$,\n  - Dilation: $d = 0.25$,\n  - Target strain: $\\boldsymbol{\\epsilon}^* = [0.02, 0.01, -0.004]^{\\top}$,\n  - Sample points $\\mathcal{Q}$: four near-boundary points $(0.05,0.05)$, $(0.95,0.95)$, $(0.05,0.95)$, $(0.95,0.05)$,\n  - Tolerance: $\\text{tol} = 10^{-8}$.\n\n- Test case $4$ (edge case, expected to fail due to near-singularity):\n  - Nodes: uniform grid of $n \\times n$ with $n = 7$,\n  - Jitter amplitude: $0$,\n  - Dilation: $d = 0.05$,\n  - Target strain: $\\boldsymbol{\\epsilon}^* = [0.01, 0.01, 0.0]^{\\top}$,\n  - Sample points $\\mathcal{Q}$: the nine points with coordinates $(x,y) \\in \\{0.25, 0.5, 0.75\\}\\times\\{0.25, 0.5, 0.75\\}$,\n  - Tolerance: $\\text{tol} = 10^{-8}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four tests above, for example, \"[true,true,true,false]\". Each entry must be the lowercase Python boolean literal \"true\" or \"false\".",
            "solution": "The problem requires the derivation of the strain-displacement matrix $B_I(\\mathbf{x})$ for the Element-Free Galerkin (EFG) method and its implementation to verify the constant strain patch test in two dimensions under plane stress conditions.\n\n### Part A: Derivation of the Strain-Displacement Matrix $B_I(\\mathbf{x})$\n\nThe derivation begins with the fundamental definitions of small-strain kinematics and the EFG displacement approximation.\n\n1.  **Small-Strain Kinematics**:\n    The engineering strain vector $\\boldsymbol{\\epsilon}$ in two dimensions is defined in terms of the gradients of the displacement field $\\mathbf{u}(\\mathbf{x}) = [u(x,y), v(x,y)]^{\\top}$ as:\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} \\\\ \\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} \\end{bmatrix}\n    $$\n    This can be expressed using a differential operator matrix $\\mathbf{L}$:\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial}{\\partial y} \\\\ \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial x} \\end{bmatrix} \\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\mathbf{L} \\mathbf{u}(\\mathbf{x})\n    $$\n\n2.  **Element-Free Galerkin (EFG) Displacement Approximation**:\n    In the EFG method, the displacement field $\\mathbf{u}(\\mathbf{x})$ is approximated by a function $\\mathbf{u}^h(\\mathbf{x})$ constructed from nodal degrees of freedom $\\mathbf{d}_I = [u_I, v_I]^{\\top}$ and Moving Least Squares (MLS) shape functions $\\phi_I(\\mathbf{x})$.\n    The approximate displacement components $u^h(\\mathbf{x})$ and $v^h(\\mathbf{x})$ at a point $\\mathbf{x}=(x,y)$ are given by:\n    $$\n    u^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I\n    $$\n    $$\n    v^h(\\mathbf{x}) = \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I\n    $$\n    where $N$ is the number of nodes in the domain of influence of point $\\mathbf{x}$.\n\n3.  **Derivation of Strain**:\n    To find the strain tensor corresponding to the EFG approximation, we substitute $u^h$ and $v^h$ into the strain-displacement relations.\n    For the normal strain in the $x$-direction, $\\epsilon_{xx}$:\n    $$\n    \\epsilon_{xx}(\\mathbf{x}) = \\frac{\\partial u^h}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I \\right) = \\sum_{I=1}^{N} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} u_I\n    $$\n    For the normal strain in the $y$-direction, $\\epsilon_{yy}$:\n    $$\n    \\epsilon_{yy}(\\mathbf{x}) = \\frac{\\partial v^h}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I \\right) = \\sum_{I=1}^{N} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} v_I\n    $$\n    For the shear strain, $\\gamma_{xy}$:\n    $$\n    \\gamma_{xy}(\\mathbf{x}) = \\frac{\\partial u^h}{\\partial y} + \\frac{\\partial v^h}{\\partial x} = \\frac{\\partial}{\\partial y} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) u_I \\right) + \\frac{\\partial}{\\partial x} \\left( \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) v_I \\right) = \\sum_{I=1}^{N} \\left( \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} u_I + \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} v_I \\right)\n    $$\n\n4.  **Assembling the Strain-Displacement Matrix**:\n    We now assemble these three strain components into a single vector equation. We can rewrite the summations to group terms by node $I$.\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\begin{bmatrix} \\epsilon_{xx} \\\\ \\epsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\sum_{I=1}^{N} \\begin{bmatrix} \\frac{\\partial \\phi_I}{\\partial x} u_I \\\\ \\frac{\\partial \\phi_I}{\\partial y} v_I \\\\ \\frac{\\partial \\phi_I}{\\partial y} u_I + \\frac{\\partial \\phi_I}{\\partial x} v_I \\end{bmatrix}\n    $$\n    Factoring out the nodal displacement vector $\\mathbf{d}_I = [u_I, v_I]^{\\top}$ for each node $I$ gives:\n    $$\n    \\boldsymbol{\\epsilon}(\\mathbf{x}) = \\sum_{I=1}^{N} \\begin{bmatrix} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} \\\\ \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} & \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} \\end{bmatrix} \\begin{bmatrix} u_I \\\\ v_I \\end{bmatrix}\n    $$\n    This is of the form $\\boldsymbol{\\epsilon}(\\mathbf{x}) = \\sum_{I=1}^{N} B_I(\\mathbf{x}) \\mathbf{d}_I$. By direct comparison, the strain-displacement matrix for node $I$, denoted $B_I(\\mathbf{x})$, is:\n    $$\n    B_I(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} \\\\ \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial y} & \\frac{\\partial \\phi_I(\\mathbf{x})}{\\partial x} \\end{bmatrix}\n    $$\n    This derivation successfully obtains the $B_I$ matrix using only the provided fundamental definitions. The crucial components are the spatial gradients of the MLS shape functions, $\\nabla \\phi_I(\\mathbf{x}) = [\\partial \\phi_I / \\partial x, \\partial \\phi_I / \\partial y]^{\\top}$.\n\n### Part B: Calculation of MLS Shape Function Gradients\n\nTo implement the derived $B_I$ matrix, we must find the analytical expressions for the gradients of the MLS shape functions.\n\n1.  **MLS Shape Function Definition**:\n    The MLS shape function $\\phi_I(\\mathbf{x})$ is defined implicitly by the relation:\n    $$\n    \\sum_{I=1}^{N} \\phi_I(\\mathbf{x}) f_I = \\mathbf{p}^{\\top}(\\mathbf{x}) \\mathbf{A}^{-1}(\\mathbf{x}) \\sum_{I=1}^{N} w_I(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) f_I\n    $$\n    where $\\mathbf{p}(\\mathbf{x})=[1, x, y]^{\\top}$ is the basis vector, $w_I(\\mathbf{x})$ is the weight function for node $I$ at point $\\mathbf{x}$, and $\\mathbf{A}(\\mathbf{x})$ is the moment matrix:\n    $$\n    \\mathbf{A}(\\mathbf{x}) = \\sum_{I=1}^{N} w_I(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) \\mathbf{p}^{\\top}(\\mathbf{x}_I)\n    $$\n    From this, we identify the shape function for node $I$:\n    $$\n    \\phi_I(\\mathbf{x}) = \\mathbf{p}^{\\top}(\\mathbf{x}) \\mathbf{A}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_I) w_I(\\mathbf{x})\n    $$\n\n2.  **Shape Function Gradient**:\n    To find the gradient $\\nabla \\phi_I(\\mathbf{x})$, we differentiate the expression for $\\phi_I(\\mathbf{x})$ with respect to the coordinates of $\\mathbf{x}$. Let's use the subscript notation for partial derivatives, e.g., $\\phi_{I,j} = \\partial \\phi_I / \\partial x_j$. Applying the product rule:\n    $$\n    \\phi_{I,j}(\\mathbf{x}) = \\left(\\mathbf{p}_{,j}^{\\top}\\mathbf{A}^{-1} + \\mathbf{p}^{\\top}\\mathbf{A}_{,j}^{-1}\\right) \\mathbf{p}_I w_I + \\left(\\mathbf{p}^{\\top}\\mathbf{A}^{-1}\\mathbf{p}_I\\right) w_{I,j}\n    $$\n    Here, we used the shorthand $\\mathbf{p}_I = \\mathbf{p}(\\mathbf{x}_I)$. We need the derivative of the inverse moment matrix, $\\mathbf{A}_{,j}^{-1}$. Using the identity $\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{I}$ and differentiating, we get $\\mathbf{A}_{,j}\\mathbf{A}^{-1} + \\mathbf{A}\\mathbf{A}_{,j}^{-1} = \\mathbf{0}$, which leads to:\n    $$\n    \\mathbf{A}_{,j}^{-1} = -\\mathbf{A}^{-1}\\mathbf{A}_{,j}\\mathbf{A}^{-1}\n    $$\n    The derivative of the moment matrix $\\mathbf{A}_{,j}$ is:\n    $$\n    \\mathbf{A}_{,j}(\\mathbf{x}) = \\sum_{K=1}^{N} w_{K,j}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_K) \\mathbf{p}^{\\top}(\\mathbf{x}_K)\n    $$\n    Substituting these expressions back into the formula for $\\phi_{I,j}$ provides the complete analytical gradient required for the implementation. The implementation will follow this derivation to compute the numerical values of the shape function gradients at each sample point. The patch test is passed if the implemented EFG approximation can reproduce a constant strain field to within a specified numerical tolerance, which is a direct consequence of the linear polynomial reproduction property of the chosen MLS basis.",
            "answer": "```python\nimport numpy as np\n\ndef run_patch_test(n_grid, jitter, d_dilation, target_strain, sample_points, tol):\n    \"\"\"\n    Performs the constant strain patch test for a given set of parameters.\n\n    Args:\n        n_grid (int): The grid size (n x n) for nodes.\n        jitter (float): The maximum amplitude of random perturbation for node positions.\n        d_dilation (float): Dilation parameter for the Gaussian weight function.\n        target_strain (np.array): The target constant strain vector [eps_xx, eps_yy, gamma_xy].\n        sample_points (np.array): Points at which to evaluate the strain.\n        tol (float): The tolerance for passing the patch test.\n\n    Returns:\n        bool: True if the patch test is passed, False otherwise.\n    \"\"\"\n    # 1. Generate nodal coordinates\n    if jitter > 0:\n        # Use a fixed seed for reproducible jitter\n        np.random.seed(42) \n        grid_pts = np.linspace(0, 1, n_grid)\n        x_coords, y_coords = np.meshgrid(grid_pts, grid_pts)\n        nodes = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n        nodes += np.random.uniform(-jitter, jitter, nodes.shape)\n        # Ensure nodes stay within the [0, 1] domain for this specific case\n        nodes = np.clip(nodes, 0, 1)\n    else:\n        grid_pts = np.linspace(0, 1, n_grid)\n        x_coords, y_coords = np.meshgrid(grid_pts, grid_pts)\n        nodes = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    num_nodes = nodes.shape[0]\n\n    # 2. Define exact linear displacement field and get nodal displacements\n    eps_xx, eps_yy, gam_xy = target_strain\n    u_exact = lambda x, y: eps_xx * x + 0.5 * gam_xy * y\n    v_exact = lambda x, y: 0.5 * gam_xy * x + eps_yy * y\n\n    nodal_displacements = np.array([\n        [u_exact(x_I, y_I), v_exact(x_I, y_I)] for x_I, y_I in nodes\n    ])\n\n    # 3. Loop over sample points\n    for x_eval, y_eval in sample_points:\n        x_pt = np.array([x_eval, y_eval])\n\n        # 4. Calculate MLS quantities at the evaluation point\n        \n        # 4.1 Weights and their gradients\n        w = np.zeros(num_nodes)\n        w_grad = np.zeros((num_nodes, 2))\n        for i, node_i in enumerate(nodes):\n            r_vec = x_pt - node_i\n            r_sq = np.dot(r_vec, r_vec)\n            w[i] = np.exp(-r_sq / (d_dilation**2))\n            w_grad[i, :] = w[i] * (-2.0 / (d_dilation**2)) * r_vec\n\n        # 4.2 Basis vectors p(x_I) for all nodes\n        p_nodes = np.hstack([np.ones((num_nodes, 1)), nodes])  # N x 3\n\n        # 4.3 Moment matrix A and its gradient\n        A = np.zeros((3, 3))\n        A_grad_x = np.zeros((3, 3))\n        A_grad_y = np.zeros((3, 3))\n        for i in range(num_nodes):\n            pi = p_nodes[i, :].reshape(3, 1)\n            A += w[i] * (pi @ pi.T)\n            A_grad_x += w_grad[i, 0] * (pi @ pi.T)\n            A_grad_y += w_grad[i, 1] * (pi @ pi.T)\n\n        # 4.4 Check for ill-conditioning\n        if np.linalg.cond(A) > 1e12:\n            return False  # Test fails due to ill-conditioning\n\n        try:\n            A_inv = np.linalg.inv(A)\n        except np.linalg.LinAlgError:\n            return False # Test fails if matrix is singular\n\n        # 4.5 Basis vector at eval point and its gradient\n        p_eval = np.array([1, x_eval, y_eval])\n        p_grad_x = np.array([0, 1, 0])\n        p_grad_y = np.array([0, 0, 1])\n\n        # 4.6 Calculate shape function gradients\n        # Use intermediate vectors c and c_grad for clarity, as in derivation\n        c = p_eval @ A_inv  # 1x3 row vector\n        c_grad_x = (p_grad_x - c @ A_grad_x) @ A_inv\n        c_grad_y = (p_grad_y - c @ A_grad_y) @ A_inv\n\n        phi_grad = np.zeros((num_nodes, 2))\n        for i in range(num_nodes):\n            pi = p_nodes[i, :]\n            term1 = c @ pi\n            phi_grad[i, 0] = (c_grad_x @ pi) * w[i] + term1 * w_grad[i, 0]\n            phi_grad[i, 1] = (c_grad_y @ pi) * w[i] + term1 * w_grad[i, 1]\n\n        # 5. Compute approximate strain using B_I matrices\n        strain_approx = np.zeros(3)\n        for i in range(num_nodes):\n            phi_ix, phi_iy = phi_grad[i, :]\n            ui, vi = nodal_displacements[i, :]\n            \n            # Strain contribution from node I: B_I @ d_I\n            strain_approx[0] += phi_ix * ui                 # eps_xx\n            strain_approx[1] += phi_iy * vi                 # eps_yy\n            strain_approx[2] += phi_iy * ui + phi_ix * vi   # gamma_xy\n            \n        # 6. Check error\n        error = np.abs(strain_approx - target_strain)\n        if np.max(error) > tol:\n            return False  # Test fails due to excessive error\n\n    # If all sample points pass\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n_grid\": 5, \"jitter\": 0, \"d_dilation\": 0.35,\n            \"target_strain\": np.array([0.01, -0.02, 0.003]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 5, \"jitter\": 0.04, \"d_dilation\": 0.30,\n            \"target_strain\": np.array([0.01, -0.02, 0.003]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 5, \"jitter\": 0, \"d_dilation\": 0.25,\n            \"target_strain\": np.array([0.02, 0.01, -0.004]),\n            \"sample_points\": np.array([[0.05, 0.05], [0.95, 0.95], [0.05, 0.95], [0.95, 0.05]]),\n            \"tol\": 1e-8\n        },\n        {\n            \"n_grid\": 7, \"jitter\": 0, \"d_dilation\": 0.05,\n            \"target_strain\": np.array([0.01, 0.01, 0.0]),\n            \"sample_points\": np.array([[x, y] for x in [0.25, 0.5, 0.75] for y in [0.25, 0.5, 0.75]]),\n            \"tol\": 1e-8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        passed = run_patch_test(\n            n_grid=case[\"n_grid\"],\n            jitter=case[\"jitter\"],\n            d_dilation=case[\"d_dilation\"],\n            target_strain=case[\"target_strain\"],\n            sample_points=case[\"sample_points\"],\n            tol=case[\"tol\"]\n        )\n        results.append(str(passed).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the key advantages of meshfree methods is their flexibility in modeling complex geometries without the burden of mesh generation. This practice addresses a subtle but important challenge that arises in non-convex domains, where the standard radial support for MLS shape functions can lead to inaccuracies. You will implement a visibility correction to ensure the approximation remains local, preventing nodes from incorrectly influencing the solution from \"around a corner,\" and thereby preserving the method's reproduction properties in geometrically complex settings .",
            "id": "3754042",
            "problem": "Consider the Element-Free Galerkin (EFG) method, which constructs approximations using Moving Least Squares (MLS) shape functions. Let the computational domain be the L-shaped polygon defined by the outer rectangle $[0,1] \\times [0,1]$ with the upper-right quadrant $[0.5,1] \\times [0.5,1]$ removed. The boundary of the domain consists of line segments connecting the vertices $(0,0) \\rightarrow (1,0) \\rightarrow (1,0.5) \\rightarrow (0.5,0.5) \\rightarrow (0.5,1) \\rightarrow (0,1) \\rightarrow (0,0)$ in order. Within this domain, place nodes on the uniform Cartesian grid with spacing $0.1$ and exclude any nodes in the removed quadrant.\n\nThe MLS construction employs a linear polynomial basis $\\mathbf{p}(x,y) = [1, x, y]^{\\top}$ and a compactly supported spline weight function $w(r)$ of the normalized distance $r = \\| \\mathbf{x} - \\mathbf{x}_i \\|/d$, where $\\mathbf{x} = (x,y)$ is the evaluation point, $\\mathbf{x}_i$ is a node, and $d$ is the support radius. The weight is defined by\n$$\nw(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4r), & 0 \\le r \\le 1,\\\\\n0, & r > 1.\n\\end{cases}\n$$\nFor a given evaluation point $\\mathbf{x}$, form the matrix $\\mathbf{P}$ whose $i$-th row is $\\mathbf{p}(x_i,y_i)^{\\top}$ for nodes with nonzero weight, and the diagonal matrix $\\mathbf{W}$ whose $i$-th diagonal entry is $w(\\|\\mathbf{x}-\\mathbf{x}_i\\|/d)$. The MLS moment matrix is $\\mathbf{M}(\\mathbf{x}) = \\mathbf{P}^{\\top} \\mathbf{W} \\mathbf{P}$. The MLS shape function vector at $\\mathbf{x}$, collecting $N_i(\\mathbf{x})$ for each contributing node $i$, is defined by\n$$\n\\mathbf{N}(\\mathbf{x}) = \\mathbf{p}(x,y)^{\\top} \\mathbf{M}(\\mathbf{x})^{-1} \\mathbf{P}^{\\top} \\mathbf{W}.\n$$\nIn practice, $\\mathbf{M}(\\mathbf{x})^{-1}$ may be computed by a numerically stable pseudoinverse if $\\mathbf{M}(\\mathbf{x})$ is ill-conditioned.\n\nIntroduce a visibility correction appropriate for concave domains: a node at $\\mathbf{x}_i$ is considered invisible to $\\mathbf{x}$, and its weight is set to zero, if the open line segment connecting $\\mathbf{x}$ and $\\mathbf{x}_i$ intersects any boundary segment of the domain. The uncorrected case uses standard radial weights with no visibility modification.\n\nFor a given linear field $u(x,y) = a x + b y + c$, define the discrete MLS approximation at $\\mathbf{x}$ by\n$$\nu_h(\\mathbf{x}) = \\sum_{i} N_i(\\mathbf{x})\\, u(\\mathbf{x}_i),\n$$\nwhere the sum runs over nodes with nonzero weight (after applying visibility rules if specified). Quantify the pointwise reproduction error of the linear field by the absolute error\n$$\ne(\\mathbf{x};a,b,c) = \\left| u_h(\\mathbf{x}) - u(\\mathbf{x}) \\right|.\n$$\n\nImplement a program that:\n- Constructs the described L-shaped domain and node set.\n- Computes MLS shape functions $\\mathbf{N}(\\mathbf{x})$ at specified evaluation points with and without visibility corrections.\n- Computes the reproduction error $e(\\mathbf{x};a,b,c)$ for a set of test cases.\n- Uses a support radius $d$ specified in each test case, with the above weight function.\n- Uses the linear basis $\\mathbf{p}(x,y) = [1,x,y]^{\\top}$ and computes $\\mathbf{M}(\\mathbf{x})^{-1}$ via a pseudoinverse when needed.\n- Ensures that only nodes with nonzero weight contribute to $\\mathbf{P}$ and $\\mathbf{W}$.\n\nTest Suite:\n1. Evaluation point $\\mathbf{x} = (0.45, 0.55)$, coefficients $(a,b,c) = (1, 2, 3)$, support radius $d = 0.25$.\n2. Evaluation point $\\mathbf{x} = (0.55, 0.45)$, coefficients $(a,b,c) = (-0.5, 1, -1)$, support radius $d = 0.25$.\n3. Evaluation point $\\mathbf{x} = (0.20, 0.20)$, coefficients $(a,b,c) = (1.2, -0.7, 0.3)$, support radius $d = 0.25$.\n4. Evaluation point $\\mathbf{x} = (0.495, 0.495)$, coefficients $(a,b,c) = (0, 1, 0)$, support radius $d = 0.20$.\n\nFor each test case, compute the reproduction error $e(\\mathbf{x};a,b,c)$ for both scenarios:\n- Without visibility corrections (standard radial weights).\n- With visibility corrections (weights set to zero for invisible nodes).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$[\\text{error\\_no\\_visibility\\_case1}, \\text{error\\_visibility\\_case1}, \\text{error\\_no\\_visibility\\_case2}, \\text{error\\_visibility\\_case2}, \\text{error\\_no\\_visibility\\_case3}, \\text{error\\_visibility\\_case3}, \\text{error\\_no\\_visibility\\_case4}, \\text{error\\_visibility\\_case4}]$.\nExpress each number as a decimal rounded to six places.",
            "solution": "The problem is valid. It presents a well-posed, scientifically-grounded computational task within the field of meshfree methods, specifically the Element-Free Galerkin (EFG) method. All necessary data, definitions, and boundary conditions are provided, and the problem is free of contradictions or ambiguities.\n\nThe core of the problem is to verify the linear reproduction property of the Moving Least Squares (MLS) approximation. This property, fundamental to the EFG method's accuracy, states that if the MLS basis functions can represent a certain class of polynomials (in this case, linear polynomials), then the MLS approximation will exactly reproduce any function from that class. The task is to compute the pointwise approximation error for a linear field $u(x,y) = ax+by+c$ and confirm that this error is, as theoretically predicted, zero (or numerically indistinguishable from zero). This verification is to be performed under two conditions: a standard MLS implementation and one modified with a visibility-based weighting scheme appropriate for a non-convex domain.\n\nThe solution is implemented in the following sequence of steps:\n\n**1. Domain Discretization and Node Generation**\nThe computational domain is an L-shaped polygon, formed by removing the upper-right quadrant $[0.5, 1] \\times [0.5, 1]$ from the unit square $[0, 1] \\times [0, 1]$. The problem specifies a uniform Cartesian grid of nodes with a spacing of $h=0.1$. We generate a grid of points $(x_i, y_j) = (i \\cdot 0.1, j \\cdot 0.1)$ for integers $i, j \\in \\{0, 1, \\dots, 10\\}$. A point is included in the node set if it falls within the L-shaped domain, meaning it satisfies the condition $(x_i \\le 0.5) \\lor (y_j \\le 0.5)$. This procedure generates a total of $96$ nodes. The boundary of the domain is defined by six line segments connecting the vertices $(0,0)$, $(1,0)$, $(1,0.5)$, $(0.5,0.5)$, $(0.5,1)$, and $(0,1)$, and back to $(0,0)$.\n\n**2. Moving Least Squares (MLS) Approximation**\nAt any evaluation point $\\mathbf{x}=(x,y)$, the MLS approximation is constructed using a weighted least-squares fit over a set of nearby nodes.\n\n**Weight Function:** A node $\\mathbf{x}_i$ influences the approximation at $\\mathbf{x}$ if it lies within a circular support domain of radius $d$ centered at $\\mathbf{x}$. The influence is quantified by a weight function $w(r)$, where $r = \\| \\mathbf{x} - \\mathbf{x}_i \\| / d$ is the normalized distance. The problem specifies a quartic spline weight function:\n$$\nw(r) =\n\\begin{cases}\n(1 - r)^4 (1 + 4r), & 0 \\le r \\le 1,\\\\\n0, & r > 1.\n\\end{cases}\n$$\n\n**Basis Functions:** The approximation is built upon a linear polynomial basis, given by the vector $\\mathbf{p}(x,y) = [1, x, y]^{\\top}$.\n\n**Shape Function Construction:** For a given evaluation point $\\mathbf{x}$, we first identify all \"contributing nodes\" that lie within its support domain (and are visible, if visibility correction is applied). Let there be $k$ such nodes. We form two matrices:\n- The basis matrix $\\mathbf{P}$, a $k \\times 3$ matrix where the $i$-th row is $\\mathbf{p}(\\mathbf{x}_i)^{\\top} = [1, x_i, y_i]$.\n- The weight matrix $\\mathbf{W}$, a $k \\times k$ diagonal matrix where the $i$-th diagonal entry is $W_{ii} = w(\\| \\mathbf{x} - \\mathbf{x}_i \\|/d)$.\n\nThe $3 \\times 3$ moment matrix $\\mathbf{M}(\\mathbf{x})$ is then constructed:\n$$\n\\mathbf{M}(\\mathbf{x}) = \\mathbf{P}^{\\top} \\mathbf{W}(\\mathbf{x}) \\mathbf{P}\n$$\nThis matrix can be ill-conditioned or singular if too few nodes are inside the support domain. To ensure numerical stability, its inverse is computed using the Moore-Penrose pseudoinverse, $\\mathbf{M}(\\mathbf{x})^+$.\n\nThe vector of MLS shape functions $\\mathbf{N}(\\mathbf{x})$ for the $k$ contributing nodes is calculated as:\n$$\n\\mathbf{N}(\\mathbf{x}) = \\mathbf{p}(\\mathbf{x})^{\\top} \\mathbf{M}(\\mathbfx)^+ \\mathbf{P}^{\\top} \\mathbf{W}(\\mathbf{x})\n$$\nThe $i$-th component of this vector, $N_i(\\mathbf{x})$, is the shape function value associated with the $i$-th contributing node.\n\n**3. Visibility Correction**\nThe L-shaped domain is non-convex (concave). In such domains, a node $\\mathbf{x}_i$ might be geometrically close to $\\mathbf{x}$ but lie \"around a corner.\" Including such nodes can pollute the local approximation. The visibility correction addresses this by setting a node's weight to zero if it is deemed \"invisible\" from $\\mathbf{x}$. A node $\\mathbf{x}_i$ is invisible if the open line segment connecting $\\mathbf{x}$ and $\\mathbf{x}_i$ intersects any of the domain's boundary segments. This requires a geometric test for the intersection of two open line segments. For any two segments, defined by endpoints $(\\mathbf{p}_1, \\mathbf{p}_2)$ and $(\\mathbf{p}_3, \\mathbf{p}_4)$, we can solve the vector equation $\\mathbf{p}_1 + t(\\mathbf{p}_2-\\mathbf{p}_1) = \\mathbf{p}_3 + u(\\mathbf{p}_4-\\mathbf{p}_3)$ for parameters $t$ and $u$. An intersection of the open segments occurs if and only if a unique solution exists with $t \\in (0,1)$ and $u \\in (0,1)$.\n\n**4. Linear Field Reproduction and Error Calculation**\nThe MLS approximation $u_h(\\mathbf{x})$ of a function $u(\\mathbf{x})$ is given by a linear combination of the function values at the contributing nodes:\n$$\nu_h(\\mathbf{x}) = \\sum_{i=1}^{k} N_i(\\mathbf{x}) u(\\mathbf{x}_i) = \\mathbf{N}(\\mathbf{x}) \\cdot \\mathbf{u}\n$$\nwhere $\\mathbf{u}$ is the vector of nodal values $u(\\mathbf{x}_i)$. For a linear field $u(\\mathbf{x}) = ax+by+c$, a key property of the MLS approximation with a linear basis is that $u_h(\\mathbf{x})$ should be identical to $u(\\mathbf{x})$, provided $\\mathbf{M}(\\mathbf{x})$ is invertible.\nThe pointwise reproduction error is defined as:\n$$\ne(\\mathbf{x}; a, b, c) = |u_h(\\mathbf{x}) - u(\\mathbf{x})|\n$$\nTheoretically, this error should be zero. The implementation will calculate this error for the given test cases, and we anticipate a result on the order of machine precision due to floating-point arithmetic. This holds true even with the visibility correction, as long as a sufficient number of nodes (at least 3, for a linear basis) remain visible within the support domain to ensure $\\mathbf{M}(\\mathbf{x})$ is not rank-deficient.\n\nThe program iterates through each test case, computing the error twice: once without and once with the visibility correction, and formats the results as requested.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Element-Free Galerkin reproduction error problem.\n    \"\"\"\n    \n    # 1. Domain Definition and Node Generation\n    h = 0.1\n    grid_coords = np.arange(0, 1.0 + h/2, h)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    nodes = np.array([\n        [x, y] for x, y in zip(xx.flatten(), yy.flatten())\n        if not (x > 0.5 + 1e-9 and y > 0.5 + 1e-9)\n    ])\n\n    boundaries = [\n        (np.array([0.0, 0.0]), np.array([1.0, 0.0])),\n        (np.array([1.0, 0.0]), np.array([1.0, 0.5])),\n        (np.array([1.0, 0.5]), np.array([0.5, 0.5])),\n        (np.array([0.5, 0.5]), np.array([0.5, 1.0])),\n        (np.array([0.5, 1.0]), np.array([0.0, 1.0])),\n        (np.array([0.0, 1.0]), np.array([0.0, 0.0]))\n    ]\n    \n    def segments_intersect(p1, p2, p3, p4):\n        \"\"\"\n        Checks if the open line segment (p1, p2) intersects (p3, p4).\n        \"\"\"\n        v1 = p2 - p1\n        v2 = p4 - p3\n        \n        # Using numpy.linalg.solve for clarity and stability\n        A = np.array([[v1[0], -v2[0]], [v1[1], -v2[1]]])\n        b = p3 - p1\n        \n        # Determinant check\n        det = A[0,0]*A[1,1] - A[0,1]*A[1,0]\n        if np.abs(det) < 1e-12:  # Parallel or collinear lines\n            return False\n            \n        try:\n            # t, u = np.linalg.solve(A, b)\n            # Manual solve is faster for 2x2\n            t = (b[0] * A[1,1] - b[1] * A[0,1]) / det\n            u = (b[1] * A[0,0] - b[0] * A[1,0]) / det\n        except np.linalg.LinAlgError:\n            return False # Should not happen due to det check\n\n        # Check for intersection in the open interval (0, 1)\n        tol = 1e-9\n        return (tol < t < 1.0 - tol) and (tol < u < 1.0 - tol)\n\n    def is_visible(x_eval, x_node, boundaries):\n        \"\"\"\n        Checks if a node is visible from the evaluation point.\n        \"\"\"\n        for p3, p4 in boundaries:\n            if segments_intersect(x_eval, x_node, p3, p4):\n                return False\n        return True\n\n    def weight_function(r):\n        \"\"\"\n        Computes the quartic spline weight function.\n        \"\"\"\n        if 0 <= r <= 1:\n            return (1 - r)**4 * (1 + 4*r)\n        return 0.0\n\n    def compute_reproduction_error(x_eval, d, abc, nodes, boundaries, use_visibility):\n        \"\"\"\n        Computes the MLS reproduction error for a linear field.\n        \"\"\"\n        x_eval = np.array(x_eval)\n        a, b, c = abc\n\n        contrib_nodes = []\n        contrib_weights = []\n\n        for node_i in nodes:\n            dist = np.linalg.norm(x_eval - node_i)\n            \n            if dist >= d:\n                continue\n\n            if use_visibility:\n                if not is_visible(x_eval, node_i, boundaries):\n                    continue\n            \n            r = dist / d\n            w = weight_function(r)\n            if w > 0:\n                contrib_nodes.append(node_i)\n                contrib_weights.append(w)\n        \n        contrib_nodes = np.array(contrib_nodes)\n        num_contrib = len(contrib_nodes)\n        \n        # Need at least 3 nodes for a well-posed linear fit\n        if num_contrib < 3:\n            # This case implies the approximation fails.\n            # Theoretical error is undefined, but practically we might get a large error.\n            # For this problem, it should reproduce 0, so any failure is non-zero.\n            u_exact = a * x_eval[0] + b * x_eval[1] + c\n            return np.abs(0 - u_exact) if u_exact != 0 else 1.0 # Return a non-zero error\n\n        # Construct matrices P and W\n        P = np.ones((num_contrib, 3))\n        P[:, 1] = contrib_nodes[:, 0]\n        P[:, 2] = contrib_nodes[:, 1]\n        \n        W = np.diag(contrib_weights)\n\n        # Moment matrix and its pseudoinverse\n        M = P.T @ W @ P\n        try:\n            M_inv = np.linalg.pinv(M, rcond=1e-15)\n        except np.linalg.LinAlgError:\n            return 1.0 # Should not occur with pinv\n            \n        # Basis vector at evaluation point\n        p_eval = np.array([1, x_eval[0], x_eval[1]])\n\n        # Shape function vector\n        N = p_eval.T @ M_inv @ P.T @ W\n\n        # Nodal values of the linear field\n        u_nodes = a * contrib_nodes[:, 0] + b * contrib_nodes[:, 1] + c\n\n        # MLS approximation and exact value\n        u_h = np.dot(N, u_nodes)\n        u_exact = a * x_eval[0] + b * x_eval[1] + c\n        \n        # Absolute error\n        error = np.abs(u_h - u_exact)\n        return error\n\n    # Test Suite\n    test_cases = [\n        {'x': (0.45, 0.55), 'abc': (1, 2, 3), 'd': 0.25},\n        {'x': (0.55, 0.45), 'abc': (-0.5, 1, -1), 'd': 0.25},\n        {'x': (0.20, 0.20), 'abc': (1.2, -0.7, 0.3), 'd': 0.25},\n        {'x': (0.495, 0.495), 'abc': (0, 1, 0), 'd': 0.20}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Without visibility corrections\n        error_no_vis = compute_reproduction_error(\n            case['x'], case['d'], case['abc'], nodes, boundaries, use_visibility=False)\n        results.append(f\"{error_no_vis:.6f}\")\n\n        # With visibility corrections\n        error_vis = compute_reproduction_error(\n            case['x'], case['d'], case['abc'], nodes, boundaries, use_visibility=True)\n        results.append(f\"{error_vis:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}