{
    "hands_on_practices": [
        {
            "introduction": "广义多尺度有限元方法 (GMsFEM) 分为离线和在线两个阶段。在构建了离线多尺度基函数之后，关键的在线步骤是组装全局粗尺度系统。本练习提供了这个组装过程的具体动手实践，演示了如何将细尺度刚度和质量双线性形式投影到给定的基函数上，以形成粗尺度矩阵。掌握这一步对于在多尺度背景下应用任何预先计算的基函数都是至关重要的。",
            "id": "3764627",
            "problem": "您的任务是在广义多尺度有限元方法 (GMsFEM) 中构建全局粗化矩阵。从一个多边形域上的二阶椭圆问题的标准对称强制双线性形式开始。刚度双线性形式为 $a(u,v)=\\int_{\\Omega}\\kappa(\\mathbf{x})\\,\\nabla u(\\mathbf{x})\\cdot\\nabla v(\\mathbf{x})\\,d\\mathbf{x}$，质量双线性形式为 $s(u,v)=\\int_{\\Omega}\\tilde{\\kappa}(\\mathbf{x})\\,u(\\mathbf{x})\\,v(\\mathbf{x})\\,d\\mathbf{x}$，其中 $\\kappa(\\mathbf{x})$ 和 $\\tilde{\\kappa}(\\mathbf{x})$ 是分片常数且严格为正。设 $\\{\\Phi_i\\}_{i=1}^{N_b}$ 为一组广义多尺度有限元方法 (GMsFEM) 意义下的离线基函数，每个基函数表示为一个协调三角剖分上的全局连续分片线性函数，$N_b$ 是离线基函数的数量。\n\n您的目标是：\n- 构建全局粗化刚度矩阵 $A_H\\in\\mathbb{R}^{N_b\\times N_b}$，其元素为 $A_{ij}=a(\\Phi_i,\\Phi_j)$。\n- 构建全局粗化质量矩阵 $M_H\\in\\mathbb{R}^{N_b\\times N_b}$，其元素为 $M_{ij}=s(\\Phi_i,\\Phi_j)$。\n- 实现两种组装路径：\n  - 一种是直接在整个域 $\\Omega$ 上的全局组装，\n  - 另一种是基于邻域的组装，该方法对 $\\Omega$ 的一个给定划分（划分为不相交的粗邻域或粗块，每个粗邻域都是若干三角形的并集）进行贡献求和。\n\n使用以下数学上精确且自包含的数据、离散化和测试套件。对于三角形上的分片线性函数和分片常数权重，所有计算在单元级别上必须是精确的。\n\n基本假设和数据：\n- 域和网格：设 $\\Omega=[0,1]^2$。考虑 $\\Omega$ 的一个协调三角剖分，该剖分通过将其细分为 $2\\times 2$ 个全等的正方形，并沿每个正方形从其左下节点到右上节点的对角线进行分割而形成。细网格节点是 $3\\times 3$ 的张量积点，坐标为 $(i/2,j/2)$，其中 $i\\in\\{0,1,2\\}$ 且 $j\\in\\{0,1,2\\}$，通过映射 $n(i,j)=3j+i$ 以行主序进行索引。节点索引和坐标如下：\n  - 节点 $0$：$(0,0)$，\n  - 节点 $1$：$(1/2,0)$，\n  - 节点 $2$：$(1,0)$，\n  - 节点 $3$：$(0,1/2)$，\n  - 节点 $4$：$(1/2,1/2)$，\n  - 节点 $5$：$(1,1/2)$，\n  - 节点 $6$：$(0,1)$，\n  - 节点 $7$：$(1/2,1)$，\n  - 节点 $8$：$(1,1)$。\n  这 $8$ 个三角形 $T_m$（局部顶点排序与正面积一致）由以下全局节点索引列表给出：\n  - $T_0=[0,1,4]$,\n  - $T_1=[0,4,3]$,\n  - $T_2=[1,2,5]$,\n  - $T_3=[1,5,4]$,\n  - $T_4=[3,4,7]$,\n  - $T_5=[3,7,6]$,\n  - $T_6=[4,5,8]$,\n  - $T_7=[4,8,7]$.\n  四个粗正方形为 $S_{00}=\\{T_0,T_1\\}$，$S_{10}=\\{T_2,T_3\\}$，$S_{01}=\\{T_4,T_5\\}$，$S_{11}=\\{T_6,T_7\\}$。\n\n- 离线基函数：设 $N_b=3$，并通过在 $9$ 个网格节点上的节点值来定义全局连续分片线性函数 $\\{\\Phi_i\\}_{i=1}^3$：\n  - 基函数 $\\Phi_1$（左条带）：$\\Phi_1$ 在 $x=0$ 的节点（节点 $0,3,6$）处等于 $1$，在 $x=1/2$（节点 $1,4,7$）和 $x=1$（节点 $2,5,8$）的节点处等于 $0$。因此，其在节点 $[0,1,2,3,4,5,6,7,8]$ 上的节点值为 $[1,0,0,1,0,0,1,0,0]$。\n  - 基函数 $\\Phi_2$（右条带）：$\\Phi_2$ 在 $x=1$ 的节点（节点 $2,5,8$）处等于 $1$，在 $x=1/2$（节点 $1,4,7$）和 $x=0$（节点 $0,3,6$）的节点处等于 $0$。因此，其节点值为 $[0,0,1,0,0,1,0,0,1]$。\n  - 基函数 $\\Phi_3$（中心帽函数）：$\\Phi_3$ 在中心节点 $4$ 处等于 $1$，在所有其他节点处等于 $0$。因此，其节点值为 $[0,0,0,0,1,0,0,0,0]$。\n\n- 用于组装的粗邻域：使用划分 $\\Omega$ 的不相交的粗邻域，每个邻域定义为一组三角形：\n  - 邻域集 $\\mathcal{P}_1=\\{\\{T_0,T_1,T_4,T_5\\},\\{T_2,T_3,T_6,T_7\\}\\}$（两个邻域：左半部分和右半部分）。\n  - 邻域集 $\\mathcal{P}_2=\\{\\{T_0,T_1\\},\\{T_2,T_3\\},\\{T_4,T_5\\},\\{T_6,T_7\\}\\}$（四个邻域：每个粗正方形）。\n  下面的测试套件将使用这两组集合。\n\n- 单元积分要求：对于每个三角形 $T$，任何 $\\Phi_i$ 的限制都是仿射的，因此 $\\nabla \\Phi_i$ 在 $T$ 上是常数。在每个三角形上，对分片线性函数和分片常数 $\\kappa$ 和 $\\tilde{\\kappa}$ 使用精确的逐单元积分。在三角形级别上不允许有数值积分近似误差。您可以假设，对于一个顶点为 $(x_\\ell,y_\\ell)$、线性函数 $u$ 的节点值为 $u_\\ell$ 的三角形，其上的梯度是求解仿射拟合的唯一常向量 $\\nabla u$，其面积是精确的多边形面积。\n\n测试套件：\n对于以下三个测试用例中的每一个，使用全局组装（对所有三角形 $T_0,\\dots,T_7$ 的单元贡献求和）和基于邻域的组装（对邻域限制的单元贡献求和，然后再跨邻域求和）来构建 $A_H$ 和 $M_H$。对于每个测试用例，报告以下输出：\n- 一个布尔值，指示全局组装的矩阵是否在绝对容差 $10^{-12}$ 内与基于邻域组装的矩阵逐元素相等。\n- 一个布尔值，指示 $A_H$ 是否在绝对容差 $10^{-12}$ 内对称。\n- 一个布尔值，指示 $M_H$ 是否在绝对容差 $10^{-12}$ 内对称。\n- $A_H$ 的最小特征值。\n- $M_H$ 的最小特征值。\n- $A_H$ 和 $M_H$ 的全局组装和邻域组装之间的最大绝对逐元素差异，即两个矩阵差异的最大值。\n\n使用以下三组参数集：\n- 情况1：对所有三角形，$\\kappa(T)=1$；对所有三角形，$\\tilde{\\kappa}(T)=1$；邻域 $\\mathcal{P}_1$。\n- 情况2：对于 $S_{00}\\cup S_{01}$ 中的三角形，$\\kappa(T)=10$；对于 $S_{10}\\cup S_{11}$ 中的三角形，$\\kappa(T)=1$；对所有三角形，$\\tilde{\\kappa}(T)=1$；邻域 $\\mathcal{P}_2$。\n- 情况3：棋盘式对比度，对于 $S_{00}\\cup S_{11}$ 中的三角形，$\\kappa(T)=1000$；对于 $S_{10}\\cup S_{01}$ 中的三角形，$\\kappa(T)=1$；$\\tilde{\\kappa}(T)=\\kappa(T)$；邻域 $\\mathcal{P}_2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述顺序提供六个量值的列表。例如，输出应如下所示：\n\"[[bool,bool,bool,float,float,float],[bool,bool,bool,float,float,float],[bool,bool,bool,float,float,float]]\"\n所有布尔值都应不加引号，所有浮点数都应为标准十进制表示。不应打印任何附加文本。",
            "solution": "该问题被评估为有效，因为它在科学上基于偏微分方程的数值分析，特别是广义多尺度有限元方法 (GMsFEM)。这是一个适定的、客观的、自包含的计算任务，提供了所有必要的数据和定义。\n\n目标是为一组给定的 GMsFEM 基函数 $\\{\\Phi_i\\}_{i=1}^{3}$ 构建粗化刚度矩阵 $A_H$ 和质量矩阵 $M_H$。这些矩阵的元素由双线性形式 $A_{ij} = a(\\Phi_i, \\Phi_j)$ 和 $M_{ij} = s(\\Phi_i, \\Phi_j)$ 定义，其中\n$$ a(u,v)=\\int_{\\Omega}\\kappa(\\mathbf{x})\\,\\nabla u(\\mathbf{x})\\cdot\\nabla v(\\mathbf{x})\\,d\\mathbf{x} $$\n$$ s(u,v)=\\int_{\\Omega}\\tilde{\\kappa}(\\mathbf{x})\\,u(\\mathbf{x})\\,v(\\mathbf{x})\\,d\\mathbf{x} $$\n域 $\\Omega = [0,1]^2$ 被划分为一个由 $8$ 个三角形组成的协调三角剖分，记为 $\\{T_k\\}_{k=0}^7$。系数 $\\kappa(\\mathbf{x})$ 和 $\\tilde{\\kappa}(\\mathbf{x})$ 在此三角剖分上是分片常数。基函数 $\\Phi_i$ 是全局连续且分片线性的。\n\n有限元方法的核心原理是通过对网格中每个单元（三角形）的贡献求和来计算全局积分。\n对于刚度矩阵，由于 $\\kappa$ 在每个三角形 $T_k$ 上是常数（设为 $\\kappa_k$），并且分片线性基函数 $\\nabla\\Phi_i, \\nabla\\Phi_j$ 的梯度在 $T_k$ 上也是常向量，积分可简化为：\n$$ A_{ij} = \\sum_{k=0}^{7} \\int_{T_k} \\kappa(\\mathbf{x}) \\nabla\\Phi_i \\cdot \\nabla\\Phi_j \\,d\\mathbf{x} = \\sum_{k=0}^{7} \\kappa_k \\left( \\nabla\\Phi_i|_{T_k} \\cdot \\nabla\\Phi_j|_{T_k} \\right) \\text{Area}(T_k) $$\n对于质量矩阵，必须计算两个线性函数乘积在三角形上的积分：\n$$ M_{ij} = \\sum_{k=0}^{7} \\int_{T_k} \\tilde{\\kappa}(\\mathbf{x}) \\Phi_i \\Phi_j \\,d\\mathbf{x} = \\sum_{k=0}^{7} \\tilde{\\kappa}_k \\int_{T_k} \\Phi_i \\Phi_j \\,d\\mathbf{x} $$\n\n计算过程如下：\n1.  **逐单元计算**：对于网格中的每个三角形 $T_k$，我们计算其对全局矩阵的局部贡献。设 $T_k$ 的顶点为 $\\mathbf{p}_1=(x_1, y_1)$、$\\mathbf{p}_2=(x_2, y_2)$ 和 $\\mathbf{p}_3=(x_3, y_3)$。\n    -   三角形的面积计算公式为 $\\text{Area}(T_k) = \\frac{1}{2}|x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$。\n    -   对于任何基函数 $\\Phi_i$，其在 $T_k$ 上的限制是一个由其在三个顶点上的值（比如 $(u_1, u_2, u_3)$）定义的仿射函数。其常梯度 $\\nabla\\Phi_i|_{T_k}$ 使用从局部 $P_1$ 有限元基函数 $\\lambda_m$ 导出的公式计算：$\\nabla\\Phi_i|_{T_k} = \\sum_{m=1}^3 u_m \\nabla\\lambda_m$。局部基函数的梯度是众所周知的：$\\nabla \\lambda_1 = \\frac{1}{2\\text{Area}(T_k)}\\begin{pmatrix} y_2-y_3 \\\\ x_3-x_2 \\end{pmatrix}$，对于 $\\nabla \\lambda_2, \\nabla \\lambda_3$ 依此类推。\n    -   则在 $T_k$ 上，对 $(\\Phi_i, \\Phi_j)$ 的单元刚度贡献为 $A_{ij}^{(k)} = \\kappa_k (\\nabla\\Phi_i|_{T_k} \\cdot \\nabla\\Phi_j|_{T_k}) \\text{Area}(T_k)$。\n    -   对于单元质量贡献，将在 $T_k$ 上 $\\Phi_i$ 和 $\\Phi_j$ 的节点值收集到向量 $\\mathbf{u}_i$ 和 $\\mathbf{u}_j$ 中。该积分为 $\\int_{T_k} \\Phi_i \\Phi_j \\,d\\mathbf{x} = \\mathbf{u}_i^T \\mathbf{M}_{\\text{elem}}^{(k)} \\mathbf{u}_j$，其中 $\\mathbf{M}_{\\text{elem}}^{(k)}$ 是线性三角形单元的标准单元质量矩阵：\n        $$ \\mathbf{M}_{\\text{elem}}^{(k)} = \\frac{\\text{Area}(T_k)}{12} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\n        因此，单元质量贡献为 $M_{ij}^{(k)} = \\tilde{\\kappa}_k \\cdot \\mathbf{u}_i^T \\mathbf{M}_{\\text{elem}}^{(k)} \\mathbf{u}_j$。\n\n2.  **组装**：通过对这些逐单元的贡献求和来组装全局矩阵 $A_H$ 和 $M_H$。\n    -   **全局组装**：对所有三角形 $k=0, \\dots, 7$ 进行 $A_{ij}$ 和 $M_{ij}$ 的求和。\n    -   **基于邻域的组装**：所有三角形的集合被划分为不相交的邻域 $\\mathcal{P} = \\{\\omega_m\\}$。对于每个邻域 $\\omega_m$，通过仅对 $\\omega_m$ 中的三角形贡献求和来组装局部矩阵 $A_H^{\\omega_m}$ 和 $M_H^{\\omega_m}$。最终的全局矩阵通过对邻域矩阵求和得到：$A_H = \\sum_m A_H^{\\omega_m}$ 和 $M_H = \\sum_m M_H^{\\omega_m}$。由于邻域构成了三角剖分的一个不相交划分，该结果必须与全局组装的结果相同，只存在浮点运算的微小差异。\n\n3.  **分析**：对于每个测试用例，在通过两种方法构建矩阵后，计算以下量值：\n    -   两种组装方法得到的矩阵的逐元素相等性，与 $10^{-12}$ 的容差进行比较。同时报告最大绝对差异。\n    -   结果矩阵 $A_H$ 和 $M_H$ 的对称性，也与容差进行比较。由于双线性形式 $a(\\cdot,\\cdot)$ 和 $s(\\cdot,\\cdot)$ 是对称的，所以结果矩阵必须是对称的。\n    -   $A_H$ 和 $M_H$ 的最小特征值。由于基函数是线性无关的，且系数 $\\kappa, \\tilde{\\kappa}$ 严格为正，预期两个矩阵都是正定的，因此具有正特征值。我们使用对称矩阵的特征值求解器。\n\n该实现精确地遵循这些步骤，对指定的三个测试用例使用给定的网格、基函数以及材料/邻域参数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef solve():\n    \"\"\"\n    Main solver function to orchestrate the GMsFEM matrix assembly and analysis.\n    \"\"\"\n    node_coords = np.array([\n        (0.0, 0.0), (0.5, 0.0), (1.0, 0.0),\n        (0.0, 0.5), (0.5, 0.5), (1.0, 0.5),\n        (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)\n    ])\n    triangles = np.array([\n        [0, 1, 4], [0, 4, 3], [1, 2, 5], [1, 5, 4],\n        [3, 4, 7], [3, 7, 6], [4, 5, 8], [4, 8, 7]\n    ])\n    phi_nodal_values = np.array([\n        [1, 0, 0, 1, 0, 0, 1, 0, 0],  # Phi_1\n        [0, 0, 1, 0, 0, 1, 0, 0, 1],  # Phi_2\n        [0, 0, 0, 0, 1, 0, 0, 0, 0],  # Phi_3\n    ]).T # Shape (num_nodes, num_basis_funcs) = (9, 3)\n\n    S_map = {\n        'S00': [0, 1], 'S10': [2, 3], \n        'S01': [4, 5], 'S11': [6, 7]\n    }\n\n    test_cases = [\n        {\n            'kappa': {t: 1.0 for t in range(8)},\n            'ktilde': {t: 1.0 for t in range(8)},\n            'neighborhoods': [[0, 1, 4, 5], [2, 3, 6, 7]]\n        },\n        {\n            'kappa': {t: 10.0 if t in S_map['S00'] + S_map['S01'] else 1.0 for t in range(8)},\n            'ktilde': {t: 1.0 for t in range(8)},\n            'neighborhoods': [S_map['S00'], S_map['S10'], S_map['S01'], S_map['S11']]\n        },\n        {\n            'kappa': {t: 1000.0 if t in S_map['S00'] + S_map['S11'] else 1.0 for t in range(8)},\n            'ktilde': {t: 1000.0 if t in S_map['S00'] + S_map['S11'] else 1.0 for t in range(8)},\n            'neighborhoods': [S_map['S00'], S_map['S10'], S_map['S01'], S_map['S11']]\n        }\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        A_global, M_global = assemble_matrices(\n            range(8), case_params['kappa'], case_params['ktilde'], \n            node_coords, triangles, phi_nodal_values\n        )\n\n        A_neigh = np.zeros_like(A_global)\n        M_neigh = np.zeros_like(M_global)\n        for neighborhood in case_params['neighborhoods']:\n            A_omega, M_omega = assemble_matrices(\n                neighborhood, case_params['kappa'], case_params['ktilde'], \n                node_coords, triangles, phi_nodal_values\n            )\n            A_neigh += A_omega\n            M_neigh += M_omega\n        \n        tol = 1e-12\n        discrepancy_A = np.max(np.abs(A_global - A_neigh))\n        discrepancy_M = np.max(np.abs(M_global - M_neigh))\n        max_discrepancy = max(discrepancy_A, discrepancy_M)\n\n        assembly_equal = max_discrepancy = tol\n        A_symmetric = np.max(np.abs(A_global - A_global.T)) = tol\n        M_symmetric = np.max(np.abs(M_global - M_global.T)) = tol\n        \n        # Use eigvalsh for symmetric matrices\n        min_eig_A = np.min(eigvalsh(A_global))\n        min_eig_M = np.min(eigvalsh(M_global))\n\n        case_result = [\n            assembly_equal,\n            A_symmetric,\n            M_symmetric,\n            min_eig_A,\n            min_eig_M,\n            max_discrepancy\n        ]\n        all_results.append(case_result)\n\n    # Format output exactly as requested\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef assemble_matrices(triangle_indices, kappa_map, ktilde_map, node_coords, triangles, phi_nodal_values):\n    \"\"\"\n    Assembles coarse stiffness and mass matrices over a given set of triangles.\n    \"\"\"\n    num_basis_funcs = phi_nodal_values.shape[1]\n    A_H = np.zeros((num_basis_funcs, num_basis_funcs))\n    M_H = np.zeros((num_basis_funcs, num_basis_funcs))\n\n    # Element mass matrix for a reference triangle of area 1\n    elem_mass_ref = (1/12) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    for tri_idx in triangle_indices:\n        node_indices = triangles[tri_idx]\n        p1, p2, p3 = node_coords[node_indices]\n        \n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        # Matrix B for gradient calculation: [grad(lambda1), grad(lambda2), grad(lambda3)]\n        # where lambda_i are P1 nodal basis functions.\n        B_matrix = (0.5 / area) * np.array([\n            [p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]],\n            [p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]]\n        ])\n\n        # Get local nodal values for all basis functions on this triangle\n        local_phi_vals = phi_nodal_values[node_indices, :] # Shape (3, num_basis_funcs)\n        \n        # Compute gradients of all basis functions on this triangle\n        # Gradients are columns of shape (2, num_basis_funcs)\n        phi_grads = B_matrix @ local_phi_vals\n\n        # Stiffness matrix contribution\n        kappa = kappa_map[tri_idx]\n        elem_A = kappa * (phi_grads.T @ phi_grads) * area\n        A_H += elem_A\n\n        # Mass matrix contribution\n        ktilde = ktilde_map[tri_idx]\n        elem_M_local_basis = area * elem_mass_ref\n        elem_M = ktilde * (local_phi_vals.T @ elem_M_local_basis @ local_phi_vals)\n        M_H += elem_M\n\n    return A_H, M_H\n\nsolve()\n```"
        },
        {
            "introduction": "GMsFEM 的有效性取决于离线基函数的质量，而这些基函数是通过求解局部谱问题得到的。设计这些谱问题的一个关键方面是为瑞利商 (Rayleigh quotient) 的分母选择内积，这通常是一个加权的质量矩阵。本练习使用一个简化的一维模型，来探索不同的权重选择如何影响谱问题识别重要物理特征（如高导通通道）的能力，并使其对材料属性的高对比度具有鲁棒性。",
            "id": "3764650",
            "problem": "考虑非均匀椭圆问题，$-\\nabla \\cdot (k \\nabla u) = f$，它是在有界域 $\\Omega \\subset \\mathbb{R}^d$ 上给定，并带有适当的边界条件。这是广义多尺度有限元方法（GMsFEM）的典型出发点。其中，$k(x) \\ge c_0  0$ 是一个可测系数，可以具有高度非均匀性和高对比度。在GMsFEM中，局部基函数是通过在粗糙邻域 $\\omega \\subset \\Omega$ 上设定的一个谱问题来选择的。标准的能量双线性形式是 $a_\\omega(u,v) = \\int_\\omega k \\,\\nabla u \\cdot \\nabla v$，质量双线性形式是 $s_\\omega(u,v) = \\int_\\omega \\tilde{k} \\, u v$，其中选择了一个权重 $\\tilde{k}(x)  0$。广义特征值问题表述为：寻找 $(\\lambda, \\phi)$，使得对于某个适当的快照空间中的所有 $v$，$a_\\omega(\\phi,v) = \\lambda \\, s_\\omega(\\phi,v)$ 都成立。$\\tilde{k}$ 的选择影响瑞利商 $\\mathcal{R}(u) = \\dfrac{a_\\omega(u,u)}{s_\\omega(u,u)}$ 的排序和缩放，从而影响主要多尺度特征（如高传导通道）的识别。\n\n为了从第一性原理出发进行推理，考虑一个一维粗糙邻域 $\\omega = [0,H]$，其系数为分段常数\n$$\nk(x) = \n\\begin{cases}\nk_H,  x \\in [0, H/2], \\\\\nk_L,  x \\in (H/2, H],\n\\end{cases}\n$$\n其中 $k_H \\gg k_L  0$ 代表一个高对比度配置。设 $u_\\delta$ 是一个连续的分段线性试探函数，定义为在 $[0, H/2 - \\delta]$ 上 $u_\\delta(x) = 1$，然后在 $[H/2 - \\delta, H/2 + \\delta]$ 上从 $1$ 线性递减到 $0$，在 $[H/2 + \\delta, H]$ 上 $u_\\delta(x) = 0$，其中 $0  \\delta \\ll H$ 是一个固定的常数。这个函数模拟了一个连通性主导模式，该模式主要支撑在 $\\omega$ 的高传导率半区，并在界面处有一个窄的过渡层。使用 $a_\\omega(u,u) = \\int_\\omega k |\\nabla u|^2$ 和 $s_\\omega(u,u) = \\int_\\omega \\tilde{k} \\, u^2$，分析在不同 $\\tilde{k}$ 选择下瑞利商 $\\mathcal{R}(u_\\delta)$ 的缩放规律，并确定哪种选择能促进对主导模式的对比度鲁棒识别（即，当 $k_H/k_L \\to \\infty$ 时，特征值缩放不发生恶化）。你的推理应基于上述定义以及对指定 $u_\\delta$ 的积分所做的科学合理的近似。\n\n在 $s_\\omega(u,v) = \\int_\\omega \\tilde{k} \\, u v$ 中，$\\tilde{k}$ 的哪种选择能最鲁棒地促进对连通性模式的对比度无关的谱选择？\n\nA. $\\tilde{k}(x) \\equiv 1$ (标准 $L^2$ 内积)。\n\nB. $\\tilde{k}(x) \\equiv k(x)$ (系数加权的 $L^2$ 内积)。\n\nC. $\\tilde{k}(x) \\equiv k(x)^{-1}$ (系数倒数加权的 $L^2$ 内积)。\n\nD. $\\tilde{k}(x) \\equiv \\bar{k}_\\omega$ (等于 $k$ 在 $\\omega$ 上粗糙平均值的常数)。",
            "solution": "这个问题要求确定在质量双线性形式 $s_\\omega(u,v) = \\int_\\omega \\tilde{k} \\, u v$ 中，权重函数 $\\tilde{k}(x)$ 的哪种选择能使连通性主导模式的谱选择对于系数 $k(x)$ 的对比度具有鲁棒性。这种鲁棒性定义为，当对比度 $k_H/k_L$ 趋于无穷大时，相应特征值（由瑞利商 $\\mathcal{R}(u)$ 近似）的缩放规律与该对比度无关。我们将针对每个提议的 $\\tilde{k}(x)$ 选择，分析给定试探函数 $u_\\delta(x)$ 的瑞利商。\n\n分析基于一维粗糙邻域 $\\omega = [0,H]$，其系数为\n$$\nk(x) = \n\\begin{cases}\nk_H,  x \\in [0, H/2] \\\\\nk_L,  x \\in (H/2, H]\n\\end{cases}\n$$\n其中 $k_H \\gg k_L  0$。试探函数 $u_\\delta(x)$ 是连续且分段线性的，定义如下：\n$$\nu_\\delta(x) = \n\\begin{cases}\n1,  x \\in [0, H/2 - \\delta] \\\\\n\\frac{H/2 + \\delta - x}{2\\delta},  x \\in (H/2 - \\delta, H/2 + \\delta) \\\\\n0,  x \\in [H/2 + \\delta, H]\n\\end{cases}\n$$\n其中参数 $0  \\delta \\ll H$。\n\n瑞利商为 $\\mathcal{R}(u_\\delta) = \\dfrac{a_\\omega(u_\\delta, u_\\delta)}{s_\\omega(u_\\delta, u_\\delta)}$。我们首先计算分子 $a_\\omega(u_\\delta, u_\\delta)$，然后对每种情况计算分母 $s_\\omega(u_\\delta, u_\\delta)$。\n\n**1. 分子（能量项）的计算**\n\n$u_\\delta(x)$ 的导数仅在过渡区间内非零：\n$$\nu'_\\delta(x) = \n\\begin{cases}\n-\\frac{1}{2\\delta},  x \\in (H/2 - \\delta, H/2 + \\delta) \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n能量双线性形式为 $a_\\omega(u,u) = \\int_0^H k(x) (u'(x))^2 \\, dx$。对于 $u_\\delta$，这变为：\n$$\na_\\omega(u_\\delta, u_\\delta) = \\int_{H/2 - \\delta}^{H/2 + \\delta} k(x) \\left(-\\frac{1}{2\\delta}\\right)^2 \\, dx\n$$\n由于 $k(x)$ 是分段常数，我们在 $x=H/2$ 处分割积分：\n$$\na_\\omega(u_\\delta, u_\\delta) = \\frac{1}{4\\delta^2} \\left[ \\int_{H/2 - \\delta}^{H/2} k_H \\, dx + \\int_{H/2}^{H/2 + \\delta} k_L \\, dx \\right]\n$$\n$$\na_\\omega(u_\\delta, u_\\delta) = \\frac{1}{4\\delta^2} \\left[ k_H \\cdot \\delta + k_L \\cdot \\delta \\right] = \\frac{k_H + k_L}{4\\delta}\n$$\n这个表达式是精确的。\n\n**2. 分母（质量项）的计算**\n\n质量双线性形式为 $s_\\omega(u,u) = \\int_0^H \\tilde{k}(x) (u(x))^2 \\, dx$。我们需要对给定的函数 $u_\\delta$ 计算这个值。积分为：\n$$\ns_\\omega(u_\\delta, u_\\delta) = \\int_0^{H/2-\\delta} \\tilde{k}(x) (1)^2 \\, dx + \\int_{H/2-\\delta}^{H/2+\\delta} \\tilde{k}(x) \\left(\\frac{H/2 + \\delta - x}{2\\delta}\\right)^2 \\, dx\n$$\n由于 $\\delta \\ll H$，函数 $u_\\delta(x)$ 主要支撑在长度为 $O(H)$ 的区间 $[0, H/2]$ 上。过渡区域 $[H/2-\\delta, H/2+\\delta]$ 对积分的贡献是 $O(\\delta)$ 阶。区域 $[0, H/2-\\delta]$ 的贡献是 $O(H)$ 阶。对于渐近分析，一个标准且合理的方法是通过考虑 $u_\\delta$ 变为一个在 $[0, H/2]$ 上等于 $1$ 且在 $(H/2, H]$ 上等于 $0$ 的阶跃函数的极限来近似 $s_\\omega(u_\\delta, u_\\delta)$。这得到：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} \\tilde{k}(x) (1)^2 \\, dx\n$$\n这种近似对于计算质量积分中的主阶项是有效的，因为修正项是关于 $H$ 的低阶项。我们现在分析每个选项。\n\n**A. $\\tilde{k}(x) \\equiv 1$**\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} 1 \\, dx = \\frac{H}{2}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H/2} = \\frac{k_H + k_L}{2\\delta H}\n$$\n当 $k_H \\to \\infty$ 时，$\\mathcal{R}(u_\\delta)$ 的缩放级别为 $O(k_H)$。这依赖于对比度。\n**结论：不正确。** 这个选择对对比度不鲁棒。\n\n**B. $\\tilde{k}(x) \\equiv k(x)$**\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} k(x) \\, dx = \\int_0^{H/2} k_H \\, dx = k_H \\frac{H}{2}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{k_H H/2} = \\frac{k_H + k_L}{2\\delta H k_H} = \\frac{1 + k_L/k_H}{2\\delta H}\n$$\n当 $k_H \\to \\infty$（因此 $k_L/k_H \\to 0$）时，瑞利商趋于一个常数值：\n$$\n\\lim_{k_H/k_L \\to \\infty} \\mathcal{R}(u_\\delta) = \\frac{1}{2\\delta H}\n$$\n这个缩放规律与对比度无关。这是一个很有希望的候选者。\n\n**C. $\\tilde{k}(x) \\equiv k(x)^{-1}$**\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} k(x)^{-1} \\, dx = \\int_0^{H/2} k_H^{-1} \\, dx = \\frac{H}{2k_H}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H/(2k_H)} = \\frac{2k_H(k_H + k_L)}{4\\delta H} = \\frac{k_H^2 + k_H k_L}{2\\delta H}\n$$\n当 $k_H \\to \\infty$ 时，$\\mathcal{R}(u_\\delta)$ 的缩放级别为 $O(k_H^2)$。这高度依赖于对比度。\n**结论：不正确。**\n\n**D. $\\tilde{k}(x) \\equiv \\bar{k}_\\omega$**\n首先，我们计算平均值 $\\bar{k}_\\omega$：\n$$\n\\bar{k}_\\omega = \\frac{1}{H}\\int_0^H k(x) \\, dx = \\frac{1}{H} \\left( k_H \\frac{H}{2} + k_L \\frac{H}{2} \\right) = \\frac{k_H + k_L}{2}\n$$\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} \\bar{k}_\\omega \\, dx = \\bar{k}_\\omega \\frac{H}{2} = \\frac{H(k_H+k_L)}{4}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H(k_H + k_L)/4} = \\frac{1}{\\delta H}\n$$\n这个缩放规律也与对比度无关。这是另一个有希望的候选者。\n\n**区分 B 和 D**\n\n选项 B 和 D 都导致试探函数 $u_\\delta$ 的特征值与对比度无关。然而，目标是*选择*连通性模式。这意味着谱问题应该能够区分“重要”模式（如 $u_\\delta$）和“不重要”模式。在这种情况下，一个不重要的模式将是主要支撑在低传导率区域的模式。\n\n让我们定义第二个试探函数 $w_\\delta(x) = u_\\delta(H-x)$，它主要支撑在低传导率一侧 $[H/2, H]$。它的导数在相同的过渡区间 $(H/2-\\delta, H/2+\\delta)$ 上是 $w'_\\delta(x) = 1/(2\\delta)$。\n能量项是相同的：$a_\\omega(w_\\delta, w_\\delta) = \\frac{k_H+k_L}{4\\delta}$。\n质量项使用相同的近似，为 $s_\\omega(w_\\delta, w_\\delta) \\approx \\int_{H/2}^H \\tilde{k}(x) \\, dx$。\n一个鲁棒的选择方法应该为这个模式 $w_\\delta$ 分配一个大的特征值。\n\n- 对于选项 B，$\\tilde{k}(x) = k(x)$：\n$$\ns_\\omega(w_\\delta, w_\\delta) \\approx \\int_{H/2}^H k_L \\, dx = k_L \\frac{H}{2}\n$$\n$$\n\\mathcal{R}(w_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{k_L H/2} = \\frac{k_H/k_L + 1}{2\\delta H}\n$$\n当 $k_H/k_L \\to \\infty$ 时，$\\mathcal{R}(w_\\delta) \\to \\infty$。这个模式被分配了一个大的、发散的特征值，有效地将其从所选基中移除。这是期望的行为。\n\n- 对于选项 D，$\\tilde{k}(x) = \\bar{k}_\\omega$：\n$$\ns_\\omega(w_\\delta, w_\\delta) \\approx \\int_{H/2}^H \\bar{k}_\\omega \\, dx = \\bar{k}_\\omega \\frac{H}{2} = \\frac{H(k_H+k_L)}{4}\n$$\n$$\n\\mathcal{R}(w_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H(k_H+k_L)/4} = \\frac{1}{\\delta H}\n$$\n这个特征值很小，并且与 $\\mathcal{R}(u_\\delta)$ 具有相同的、与对比度无关的值。这个选择未能区分连通性模式和被困在低传导率区域的模式。\n\n**关于选项的结论**\n- 选项 A 给出与对比度相关的特征值。**不正确。**\n- 选项 B 为连通性模式给出一个小的、与对比度无关的特征值，为非连通性模式给出一个大的、与对比度相关的特征值。这提供了出色的谱分离。**正确。**\n- 选项 C 给出与对比度强相关的特征值。**不正确。**\n- 选项 D 为连通性模式和非连通性模式都给出一个小的、与对比度无关的特征值，未能将它们分离开。**不正确。**\n\n因此，选择 $\\tilde{k}(x) = k(x)$ 最能鲁棒地促进对比度无关的谱选择。它为支撑在高传导率区域的模式分配小特征值，为支撑在低传导率区域的模式分配大特征值，从而实现了分离问题主导特征的目标。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "最后的这个练习将前面练习中的概念整合到一个完整的 GMsFEM 端到端实现中。您将为一个具有高对比度系数的一维问题构建一个求解器，从生成快照空间、求解局部谱问题到组装最终解。通过系统地改变特征值阈值和过采样大小等关键参数，本练习可以对 GMsFEM 的收敛性质进行数值验证，从而让您对精度和计算成本之间的权衡有直接的认识。",
            "id": "3764604",
            "problem": "考虑在多尺度建模中出现的一维二阶椭圆边值问题，该问题定义在单位区间 $[0,1]$ 上：求解 $u \\in H_0^1(0,1)$ 使得\n$$\n- \\frac{d}{dx}\\Big(a(x)\\, \\frac{du}{dx}\\Big) = f(x) \\quad \\text{in } (0,1), \\qquad u(0)=0,\\; u(1)=0,\n$$\n其中 $a(x)$ 是一个空间变化的正系数，$f(x)$ 是一个给定的源项。其弱形式为：求解 $u \\in H_0^1(0,1)$ 使得\n$$\n\\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n由该双线性形式诱导的能量范数定义为\n$$\n\\| w \\|_{a} := \\Big( \\int_0^1 a(x)\\, |w'(x)|^2\\, dx \\Big)^{1/2}.\n$$\n为了数值验证广义多尺度有限元法 (GMsFEM) 的误差估计，请设计并实现一个程序，该程序使用标准协调线性有限元在均匀细网格上近似计算一个细尺度参考解 $u_h$，并比较归一化能量误差\n$$\nE(\\tau,L) := \\frac{\\| u_h - u_{\\mathrm{ms}}(\\tau,L) \\|_{a}}{\\| u_h \\|_{a}}\n$$\n作为用于构造多尺度空间的局部谱特征值阈值 $\\tau$ 和过采样大小 $L$ 的函数。\n\n该程序必须遵循以下规范。\n\n- 细尺度离散化：\n  - 使用具有 $N_f$ 个单元的均匀细网格，其中 $N_f$ 必须选择为 $N_f = 400$。令细网格尺寸为 $h = 1/N_f$。使用标准分片线性有限元和一维单元公式，组装全局细尺度刚度矩阵 $K_h$ 和右端向量 $F_h$。通过消除线性系统中的边界自由度，强施加狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n  - 使用 $f(x) = 1$ 和系数\n    $$\n    a(x) =\n    \\begin{cases}\n    10^{-3},   x \\in [0.15, 0.30),\\\\\n    10^{3},   x \\in [0.45, 0.55),\\\\\n    10^{-2},   x \\in [0.80, 0.90),\\\\\n    1,   \\text{其他}.\n    \\end{cases}\n    $$\n- 粗网格和单位分解：\n  - 定义一个具有 $N_c$ 个单元的均匀粗网格，其中 $N_c$ 必须选择为 $N_c = 20$。令粗网格节点位于 $x_i = i/N_c$，其中整数 $i \\in \\{0,1,\\dots,N_c\\}$。对于每个内部粗网格节点索引 $i \\in \\{1,2,\\dots,N_c-1\\}$，定义支集在 $[x_{i-1},x_{i+1}]$ 上的标准粗尺度单位分解帽子函数 $\\chi_i(x)$，其表达式为\n    $$\n    \\chi_i(x) =\n    \\begin{cases}\n    \\dfrac{x - x_{i-1}}{1/N_c},   x \\in [x_{i-1}, x_i], \\\\[12pt]\n    \\dfrac{x_{i+1} - x}{1/N_c},  x \\in [x_i, x_{i+1}], \\\\[12pt]\n    0,  \\text{其他}.\n    \\end{cases}\n    $$\n  - 在细网格节点上计算 $\\chi_i(x)$ 的值，以形成离散的单位分解向量。\n- 局部快照空间和过采样：\n  - 对于每个内部粗网格节点索引 $i$，定义其基本粗邻域 $\\omega_i = [x_{i-1}, x_{i+1}]$。大小为 $L$ 的过采样邻域为 $\\omega_i^{(L)} = [x_{i-(1+L)}, x_{i+(1+L)}] \\cap [0,1]$，其中 $L$ 计算每侧增加的额外粗网格层数。在离散意义上，将 $\\omega_i^{(L)}$ 映射到相应的连续细网格节点集。\n  - 在 $\\omega_i^{(L)}$上，将局部快照空间 $S_i$ 定义为求解\n    $$\n    -\\frac{d}{dx}\\Big(a(x)\\, \\frac{ds}{dx}\\Big) = 0 \\quad \\text{in } \\omega_i^{(L)},\n    $$\n    的两个一维调和延拓所生成的空间，其中第一个快照的边界条件为 $s(a)=1, s(b)=0$，第二个快照的边界条件为 $s(a)=0, s(b)=1$，且 $[a,b] = \\omega_i^{(L)}$。在一维情况下，这些快照可以通过 $a(x)\\, s'(x)$ 的常数性来刻画，这意味着\n    $$\n    s_{\\mathrm{left}}(x) = 1 - \\frac{\\int_{a}^{x} \\frac{1}{a(\\xi)}\\, d\\xi}{\\int_{a}^{b} \\frac{1}{a(\\xi)}\\, d\\xi}, \\qquad\n    s_{\\mathrm{right}}(x) = \\frac{\\int_{a}^{x} \\frac{1}{a(\\xi)}\\, d\\xi}{\\int_{a}^{b} \\frac{1}{a(\\xi)}\\, d\\xi}.\n    $$\n    这些函数必须使用细尺度系数在细网格上进行离散化。\n- 局部谱分解和基函数选择：\n  - 对于每个内部粗网格节点 $i$，通过将全局细尺度矩阵限制在过采样邻域的自由度上，在 $\\omega_i^{(L)}$ 上组装局部刚度矩阵 $A_i$ 和加权质量矩阵 $M_i$。在快照空间 $S_i$ 上定义局部广义特征值问题\n    $$\n    A_i\\, \\psi = \\lambda\\, M_i\\, \\psi,\n    $$\n    其中 $\\psi$ 在快照基中表示。按非递减的特征值 $\\lambda$ 对特征对进行排序。给定一个阈值 $\\tau  0$，选择所有满足 $\\lambda \\le \\tau$ 的局部模态，并对每个选定的模态，通过乘以单位分解函数来构造全局连续多尺度基函数，即\n    $$\n    \\Phi_{i,m}(x) = \\chi_i(x)\\, \\psi_{i,m}(x),\n    $$\n    其中 $\\psi_{i,m}$ 是在 $\\omega_i^{(L)}$ 上的第 $m$ 个选定模态。\n- 全局粗尺度多尺度解：\n  - 将全局多尺度空间 $V_{\\mathrm{ms}}(\\tau,L)$ 组装为所有内部粗网格节点上选定的 $\\Phi_{i,m}$ 所生成的空间。通过将细尺度刚度矩阵和载荷向量投影到 $V_{\\mathrm{ms}}(\\tau,L)$ 上，形成降维伽辽金系统，求解多尺度系数，并在细网格上重构全局连续多尺度解 $u_{\\mathrm{ms}}(\\tau,L)$。如果对于任何粗网格节点都没有选择任何局部模态（即多尺度空间是平凡的），则设 $u_{\\mathrm{ms}}(\\tau,L) \\equiv 0$。\n- 误差量化：\n  - 使用由组装好的细尺度刚度矩阵诱导的离散能量范数，计算归一化能量误差 $E(\\tau,L)$。\n\n在单个程序中实现以上步骤，并评估以下五个测试用例，这些用例改变了特征值阈值 $\\tau$ 和过采样大小 $L$：\n- 测试用例 1：$\\tau = 10^{-1}$, $L = 1$。\n- 测试用例 2：$\\tau = 10^{-8}$, $L = 1$。\n- 测试用例 3：$\\tau = 10^{6}$, $L = 1$。\n- 测试用例 4：$\\tau = 10^{-1}$, $L = 3$。\n- 测试用例 5：$\\tau = 10^{-1}$, $L = 0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应测试用例的 $E(\\tau,L)$ 的浮点数值。不涉及物理单位，也不出现角度；输出是无单位的纯实数。程序必须无需外部输入即可按原样运行。",
            "solution": "该问题陈述是一个有效且适定的数值分析任务。它要求实现一个广义多尺度有限元法 (GMsFEM)，以求解一个具有高对比度、分片常数系数的一维二阶椭圆边值问题。该问题为算法提供了一套完整且一致的规范，包括离散化参数、局部空间和算子的定义，以及基函数选择的标准。该问题科学上基于有限元方法和多尺度分析的既有理论。所有必需的数据和条件均已提供，不存在会妨碍获得唯一数值解的矛盾或模糊之处。因此，我们着手进行求解。\n\n问题的核心是构造一组能够捕捉由快速变化的系数 $a(x)$ 引起的解的小尺度特征的特殊基函数，然后在一个伽辽金框架下使用这些基函数在粗网格上求解该问题。此多尺度解 $u_{\\mathrm{ms}}$ 的误差将与一个标准的细尺度有限元解 $u_h$ 进行比较。\n\n该过程可以分解为以下主要步骤：\n\n**1. 细尺度参考解**\n\n首先，我们通过在非常精细的网格上使用标准的协调线性有限元法 (FEM) 求解问题，来建立一个“基准”或参考解。问题是\n$$\n- \\frac{d}{dx}\\Big(a(x)\\, \\frac{du}{dx}\\Big) = f(x) \\quad \\text{for } x \\in (0,1),\n$$\n带有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。其弱形式为：对所有测试函数 $v \\in H_0^1(0,1)$，求解 $u \\in H_0^1(0,1)$ 使得：\n$$\nB(u,v) = L(v) \\quad \\text{where} \\quad B(u,v) = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx \\quad \\text{and} \\quad L(v) = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\n我们用一个由 $N_f=400$ 个尺寸为 $h=1/N_f$ 的单元组成的均匀网格来离散化区域 $[0,1]$。解 $u(x)$ 由 $u_h(x) = \\sum_{j=1}^{N_f-1} U_j \\phi_j(x)$ 近似，其中 $\\phi_j$ 是标准的分片线性（“帽子”）基函数，$U_j$ 是未知的节点值。这导出了线性方程组：\n$$\nK_h U_h = F_h,\n$$\n其中 $K_h$ 是 $(N_f-1) \\times (N_f-1)$ 的全局刚度矩阵，$F_h$ 是大小为 $N_f-1$ 的全局载荷向量。其项由 $(K_h)_{ij} = B(\\phi_j, \\phi_i)$ 和 $(F_h)_i = L(\\phi_i)$ 给出。我们求解该系统以找到节点值向量 $U_h$，它代表了我们的参考解 $u_h$。该解的能量 $\\|u_h\\|_a^2 = U_h^T K_h U_h$ 将作为误差的归一化因子。\n\n**2. 粗网格和单位分解**\n\n我们定义一个具有 $N_c=20$ 个单元的均匀粗网格，节点位于 $x_i = i/N_c$。对于每个内部粗网格节点 $i \\in \\{1, \\dots, N_c-1\\}$，我们定义一个单位分解 (PU) 函数 $\\chi_i(x)$。根据规定，这些是标准的粗尺度线性有限元基函数。每个 $\\chi_i(x)$ 仅在粗邻域 $\\omega_i = [x_{i-1}, x_{i+1}]$ 上非零。这些 PU 函数将用于局部化多尺度基函数。\n\n**3. GMsFEM 基函数构造**\n\n这是该方法的核心部分。对于每个内部粗网格节点 $i$，我们构造一组局部多尺度基函数。\n\n**a. 过采样和快照空间：**\n为了减轻问题局部化带来的人为边界效应，我们通过在基本邻域 $\\omega_i$ 的每侧扩展 $L$ 个粗单元层来定义一个过采样邻域 $\\omega_i^{(L)}$。在这个区域 $\\omega_i^{(L)}$ 上，我们定义一个“快照”空间 $S_i$。这个空间应包含能够很好地近似该局部区域内真实解行为的函数。问题规定了一个由两个调和延拓生成的快照空间，这两个调和延拓是在 $\\omega_i^{(L)}$ 上求解齐次问题 $- (a(x) s')' = 0$ 的解，并在 $\\omega_i^{(L)}$ 的边界上分别施加狄利克雷边界条件 $(1,0)$ 和 $(0,1)$。这些函数自然地包含了关于系数 $a(x)$ 局部变化的信息。\n\n**b. 局部谱问题：**\n快照空间通常是过大的。为了找到其中最主导的模态，我们求解一个局部广义特征值问题。对于每个邻域 $\\omega_i^{(L)}$，我们在快照基中寻找原始微分算子的特征函数 $\\psi \\in S_i$，这些特征函数被限制在该区域内。这可以表示为：\n$$\nA_i \\psi = \\lambda M_i \\psi,\n$$\n其中 $A_i$ 和 $M_i$ 分别是与双线性形式 $\\int_{\\omega_i^{(L)}} a(x) u'v' dx$ 和 $\\int_{\\omega_i^{(L)}} a(x) uv dx$ 相关联的刚度矩阵和质量矩阵，并投影到快照基上。特征值 $\\lambda$ 表示特征函数的能量与其加权 $L^2$ 范数之比。小特征值对应于“低能量”且相对于能量范数变化缓慢的模态；这些是为获得良好全局近似而最需要捕捉的模态。\n\n**c. 基函数选择和局部化：**\n给定一个阈值 $\\tau  0$，我们选择所有其对应特征值 $\\lambda_{i,m}$ 满足 $\\lambda_{i,m} \\le \\tau$ 的特征函数 $\\psi_{i,m}$。然后通过将这些选定的局部函数乘以相应的单位分解函数 $\\chi_i(x)$ 来进行局部化：\n$$\n\\Phi_{i,m}(x) = \\chi_i(x) \\psi_{i,m}(x).\n$$\n这确保了所得到的全局基函数 $\\Phi_{i,m}$ 是连续的，并且具有与 PU 函数相同的局部支集。\n\n**4. 全局多尺度解**\n\n多尺度空间 $V_{\\mathrm{ms}}$ 由所有内部粗网格节点上选定的基函数 $\\{\\Phi_{i,m}\\}$ 生成。我们寻求一个近似解 $u_{\\mathrm{ms}} \\in V_{\\mathrm{ms}}$。通过将伽辽金原理应用于此空间，我们将原始的细尺度问题投影到多尺度基上：\n$$\nK_{\\mathrm{ms}} U_{\\mathrm{ms}} = F_{\\mathrm{ms}},\n$$\n其中，粗尺度多尺度刚度矩阵和载荷向量通过投影形成：$K_{\\mathrm{ms}} = R_{\\mathrm{ms}}^T K_h R_{\\mathrm{ms}}$ 和 $F_{\\mathrm{ms}} = R_{\\mathrm{ms}}^T F_h$。这里，$R_{\\mathrm{ms}}$ 是一个矩阵，其列是基函数 $\\Phi_{i,m}$ 在细网格上的离散表示。在求解这个小系统得到系数 $U_{\\mathrm{ms}}$ 之后，我们通过 $u_{\\mathrm{ms}} = R_{\\mathrm{ms}} U_{\\mathrm{ms}}$ 在细网格上重构全局解。\n\n**5. 误差计算**\n\n最后，我们计算能量范数下的相对误差，以量化在给定参数集 $(\\tau, L)$ 下多尺度近似的精度：\n$$\nE(\\tau,L) = \\frac{\\| u_h - u_{\\mathrm{ms}}(\\tau,L) \\|_{a}}{\\| u_h \\|_{a}} = \\sqrt{\\frac{(U_h - U_{\\mathrm{ms}})^T K_h (U_h - U_{\\mathrm{ms}})}{U_h^T K_h U_h}}.\n$$\n这个归一化误差衡量了 GMsFEM 解在能量方面对参考解的近似程度。我们期望误差会随着过采样大小 $L$ 的增大和谱阈值 $\\tau$ 的增大（这会包含更多的基函数）而减小。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the GMsFEM procedure to solve a 1D elliptic problem and computes\n    the normalized energy error for several test cases.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. Global Setup and Fine-Scale Problem\n    # --------------------------------------------------------------------------\n    N_f = 400  # Number of fine elements\n    N_c = 20   # Number of coarse elements\n    f_val = 1.0  # Source term f(x)\n\n    h = 1.0 / N_f\n    x_fine = np.linspace(0, 1, N_f + 1)\n    x_coarse = np.linspace(0, 1, N_c + 1)\n    \n    # Define coefficient a(x)\n    def get_a(x_coords):\n        a = np.ones_like(x_coords, dtype=float)\n        a[np.logical_and(x_coords >= 0.15, x_coords  0.30)] = 1e-3\n        a[np.logical_and(x_coords >= 0.45, x_coords  0.55)] = 1e3\n        a[np.logical_and(x_coords >= 0.80, x_coords  0.90)] = 1e-2\n        return a\n\n    fine_elem_midpoints = x_fine[:-1] + h / 2.0\n    a_vals = get_a(fine_elem_midpoints)\n\n    # Assemble full fine-scale matrices (pre-BCs)\n    num_nodes_fine = N_f + 1\n    K_h_full = np.zeros((num_nodes_fine, num_nodes_fine))\n    M_a_full = np.zeros((num_nodes_fine, num_nodes_fine))\n    F_h_full = np.zeros(num_nodes_fine)\n\n    for k in range(N_f):\n        # Element stiffness matrix\n        ke = (a_vals[k] / h) * np.array([[1, -1], [-1, 1]])\n        K_h_full[k:k+2, k:k+2] += ke\n        \n        # Element a-weighted mass matrix\n        me = (a_vals[k] * h / 6.0) * np.array([[2, 1], [1, 2]])\n        M_a_full[k:k+2, k:k+2] += me\n        \n        # Element load vector\n        fe = (f_val * h / 2.0) * np.array([1, 1])\n        F_h_full[k:k+2] += fe\n\n    # Apply strong Dirichlet BCs\n    interior_nodes_slice = slice(1, -1)\n    K_h = K_h_full[interior_nodes_slice, interior_nodes_slice]\n    F_h = F_h_full[interior_nodes_slice]\n\n    # Solve for fine-scale reference solution\n    u_h_vec = np.linalg.solve(K_h, F_h)\n    \n    energy_ref_sq = u_h_vec.T @ K_h @ u_h_vec\n    if energy_ref_sq == 0:\n        # Avoid division by zero, though unlikely for this problem\n        energy_ref_sq = 1.0\n\n    # --------------------------------------------------------------------------\n    # 2. Loop over Test Cases\n    # --------------------------------------------------------------------------\n    test_cases = [\n        (1e-1, 1),\n        (1e-8, 1),\n        (1e6, 1),\n        (1e-1, 3),\n        (1e-1, 0),\n    ]\n\n    results = []\n    \n    # Pre-compute integrals for snapshot functions\n    g_vals = 1.0 / a_vals\n    integral_g_from_0 = np.zeros(num_nodes_fine)\n    integral_g_from_0[1:] = np.cumsum(g_vals * h)\n\n    # Pre-compute partition of unity functions\n    H = 1.0 / N_c\n    chi_functions = []\n    for i in range(1, N_c):\n        x_rel_left = (x_fine - x_coarse[i-1]) / H\n        x_rel_right = (x_coarse[i+1] - x_fine) / H\n        chi_i = np.maximum(0, np.minimum(x_rel_left, x_rel_right))\n        chi_functions.append(chi_i)\n\n    for tau, L in test_cases:\n        R_ms_cols = []\n        \n        # ----------------------------------------------------------------------\n        # 3. Construct Multiscale Basis for each Coarse Neighborhood\n        # ----------------------------------------------------------------------\n        for i in range(1, N_c): # Loop over interior coarse nodes\n            # Define oversampled neighborhood omega_i^(L)\n            i_start = max(0, i - (1 + L))\n            i_end = min(N_c, i + (1 + L))\n            \n            # Map to fine node indices\n            fine_elem_per_coarse = N_f // N_c\n            start_node_idx = i_start * fine_elem_per_coarse\n            end_node_idx = i_end * fine_elem_per_coarse\n            fine_indices_in_omega = np.arange(start_node_idx, end_node_idx + 1)\n            \n            # Compute snapshot functions\n            den = integral_g_from_0[end_node_idx] - integral_g_from_0[start_node_idx]\n            if den == 0: continue\n            \n            num = integral_g_from_0[fine_indices_in_omega] - integral_g_from_0[start_node_idx]\n            s_right = num / den\n            s_left = 1.0 - s_right\n            \n            R_i = np.vstack((s_left, s_right)).T\n\n            # Extract local matrices\n            ix_ = np.ix_(fine_indices_in_omega, fine_indices_in_omega)\n            K_loc = K_h_full[ix_]\n            M_loc = M_a_full[ix_]\n\n            # Project onto snapshot space\n            A_tilde = R_i.T @ K_loc @ R_i\n            M_tilde = R_i.T @ M_loc @ R_i\n            \n            # Solve local spectral problem\n            try:\n                lambdas, evecs = eigh(A_tilde, M_tilde)\n            except np.linalg.LinAlgError:\n                continue\n\n            # Select and form global basis functions\n            chi_i = chi_functions[i-1]\n            for m in range(len(lambdas)):\n                if lambdas[m] = tau:\n                    psi_loc = R_i @ evecs[:, m]\n                    psi_glob = np.zeros(num_nodes_fine)\n                    psi_glob[fine_indices_in_omega] = psi_loc\n                    \n                    # Multiply by partition of unity\n                    Phi = psi_glob * chi_i\n                    \n                    # Store interior part of basis vector\n                    R_ms_cols.append(Phi[interior_nodes_slice])\n\n        # ----------------------------------------------------------------------\n        # 4. Solve Global Multiscale Problem  Compute Error\n        # ----------------------------------------------------------------------\n        if not R_ms_cols:\n            u_ms_vec = np.zeros(N_f - 1)\n        else:\n            R_ms_int = np.array(R_ms_cols).T\n            \n            # Form and solve coarse system\n            K_ms = R_ms_int.T @ K_h @ R_ms_int\n            F_ms = R_ms_int.T @ F_h\n            \n            U_ms = np.linalg.solve(K_ms, F_ms)\n            \n            # Reconstruct fine-scale solution\n            u_ms_vec = R_ms_int @ U_ms\n\n        # Compute normalized energy error\n        error_vec = u_h_vec - u_ms_vec\n        energy_error_sq = error_vec.T @ K_h @ error_vec\n        normalized_error = np.sqrt(energy_error_sq / energy_ref_sq)\n        results.append(normalized_error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}