{
    "hands_on_practices": [
        {
            "introduction": "在任何有限元方法（包括广义多尺度有限元方法 GMsFEM）中，一个核心步骤是利用基函数组装全局矩阵。本练习提供了一组预先计算好的多尺度基函数，要求您实现粗尺度刚度矩阵和质量矩阵的组装过程。这个实践旨在巩固您对基函数和双线性形式如何转化为一个可解的线性系统的理解，这是 GMsFEM 计算流程中的一个基本环节。",
            "id": "3764627",
            "problem": "您的任务是在广义多尺度有限元方法（GMsFEM）中构建全局粗糙矩阵。从多边形域上二阶椭圆问题的标准对称强制双线性形式开始。刚度双线性形式为 $a(u,v)=\\int_{\\Omega}\\kappa(\\mathbf{x})\\,\\nabla u(\\mathbf{x})\\cdot\\nabla v(\\mathbf{x})\\,d\\mathbf{x}$，质量双线性形式为 $s(u,v)=\\int_{\\Omega}\\tilde{\\kappa}(\\mathbf{x})\\,u(\\mathbf{x})\\,v(\\mathbf{x})\\,d\\mathbf{x}$，其中 $\\kappa(\\mathbf{x})$ 和 $\\tilde{\\kappa}(\\mathbf{x})$ 是分片常数且严格为正。设 $\\{\\Phi_i\\}_{i=1}^{N_b}$ 是广义多尺度有限元方法（GMsFEM）意义下的一组离线基函数，每个基函数在协调三角剖分上表示为全局连续的分片线性函数，其中 $N_b$ 是离线基函数的数量。\n\n您的目标是：\n- 构建全局粗糙刚度矩阵 $A_H\\in\\mathbb{R}^{N_b\\times N_b}$，其元素为 $A_{ij}=a(\\Phi_i,\\Phi_j)$。\n- 构建全局粗糙质量矩阵 $M_H\\in\\mathbb{R}^{N_b\\times N_b}$，其元素为 $M_{ij}=s(\\Phi_i,\\Phi_j)$。\n- 实现两种组装路径：\n  - 一种是直接在整个域 $\\Omega$ 上的全局组装，\n  - 另一种是基于邻域的组装，该方法对 $\\Omega$ 的一个给定划分（划分为不相交的粗糙邻域或粗糙块）上的贡献求和，每个邻域是三角形的并集。\n\n使用以下数学上精确且自洽的数据、离散化和测试套件。对于分片线性函数和三角形上的分片常数权重，所有计算在单元级别上必须是精确的。\n\n基本假设和数据：\n- 域和网格：设 $\\Omega=[0,1]^2$。考虑 $\\Omega$ 的一个协调三角剖分，该剖分通过将其细分为 $2\\times 2$ 个全等的正方形，并沿每个正方形从其左下节点到右上节点的对角线进行分割而形成。细网格节点是 $3\\times 3$ 的张量积点，坐标为 $(i/2,j/2)$，$i\\in\\{0,1,2\\}$ 且 $j\\in\\{0,1,2\\}$，通过映射 $n(i,j)=3j+i$ 按行主序索引。节点索引和坐标如下：\n  - 节点 $0$: $(0,0)$，\n  - 节点 $1$: $(1/2,0)$，\n  - 节点 $2$: $(1,0)$，\n  - 节点 $3$: $(0,1/2)$，\n  - 节点 $4$: $(1/2,1/2)$，\n  - 节点 $5$: $(1,1/2)$，\n  - 节点 $6$: $(0,1)$，\n  - 节点 $7$: $(1/2,1)$，\n  - 节点 $8$: $(1,1)$。\n  $8$ 个三角形 $T_m$（其局部顶点排序与正面积一致）由以下全局节点索引列表给出：\n  - $T_0=[0,1,4]$,\n  - $T_1=[0,4,3]$,\n  - $T_2=[1,2,5]$,\n  - $T_3=[1,5,4]$,\n  - $T_4=[3,4,7]$,\n  - $T_5=[3,7,6]$,\n  - $T_6=[4,5,8]$,\n  - $T_7=[4,8,7]$.\n  四个粗糙正方形为 $S_{00}=\\{T_0,T_1\\}$, $S_{10}=\\{T_2,T_3\\}$, $S_{01}=\\{T_4,T_5\\}$, $S_{11}=\\{T_6,T_7\\}$。\n\n- 离线基函数：设 $N_b=3$，并通过在 $9$ 个网格节点上的节点值来定义全局连续的分片线性函数 $\\{\\Phi_i\\}_{i=1}^3$：\n  - 基函数 $\\Phi_1$（左条带）：$\\Phi_1$ 在 $x=0$ 的节点（节点 $0,3,6$）上等于 $1$，在 $x=1/2$（节点 $1,4,7$）和 $x=1$（节点 $2,5,8$）的节点上等于 $0$。因此其在节点 $[0,1,2,3,4,5,6,7,8]$ 上的节点值为 $[1,0,0,1,0,0,1,0,0]$。\n  - 基函数 $\\Phi_2$（右条带）：$\\Phi_2$ 在 $x=1$ 的节点（节点 $2,5,8$）上等于 $1$，在 $x=1/2$（节点 $1,4,7$）和 $x=0$（节点 $0,3,6$）的节点上等于 $0$。因此其节点值为 $[0,0,1,0,0,1,0,0,1]$。\n  - 基函数 $\\Phi_3$（中心帽函数）：$\\Phi_3$ 在中心节点 $4$ 处等于 $1$，在所有其他节点处等于 $0$。因此其节点值为 $[0,0,0,0,1,0,0,0,0]$。\n\n- 用于组装的粗糙邻域：使用划分 $\\Omega$ 的不相交的粗糙邻域，每个邻域定义为一组三角形：\n  - 邻域集 $\\mathcal{P}_1=\\{\\{T_0,T_1,T_4,T_5\\},\\{T_2,T_3,T_6,T_7\\}\\}$（两个邻域：左半部分和右半部分）。\n  - 邻域集 $\\mathcal{P}_2=\\{\\{T_0,T_1\\},\\{T_2,T_3\\},\\{T_4,T_5\\},\\{T_6,T_7\\}\\}$（四个邻域：每个粗糙正方形）。\n  这两个集合都将在下面的测试套件中使用。\n\n- 单元积分要求：对于每个三角形 $T$，任何 $\\Phi_i$ 的限制都是仿射的，因此 $\\nabla \\Phi_i$ 在 $T$ 上是常数。对每个三角形上的分片线性函数和分片常数 $\\kappa$ 和 $\\tilde{\\kappa}$ 使用精确的单元积分。在三角形级别上不允许有数值积分近似误差。您可以假设，对于一个顶点为 $(x_\\ell,y_\\ell)$ 且线性函数 $u$ 的节点值为 $u_\\ell$ 的三角形，该三角形上的梯度是求解仿射拟合的唯一常数向量 $\\nabla u$，其面积是精确的多边形面积。\n\n测试套件：\n为以下三个测试案例中的每一个构建 $A_H$ 和 $M_H$，同时使用全局组装（对所有三角形 $T_0,\\dots,T_7$ 的单元贡献求和）和基于邻域的组装（对邻域限制的单元贡献求和，然后再跨邻域求和）。对于每个测试案例，报告以下输出：\n- 一个布尔值，指示全局组装的矩阵是否在绝对容差 $10^{-12}$ 内与基于邻域组装的矩阵逐项相等。\n- 一个布尔值，指示 $A_H$ 是否在绝对容差 $10^{-12}$ 内对称。\n- 一个布尔值，指示 $M_H$ 是否在绝对容差 $10^{-12}$ 内对称。\n- $A_H$ 的最小特征值。\n- $M_H$ 的最小特征值。\n- $A_H$ 和 $M_H$ 的全局组装与邻域组装之间的最大绝对逐项差异，即两个矩阵中的最大值。\n\n使用以下三组参数：\n- 案例1：对所有三角形 $\\kappa(T)=1$ 且 $\\tilde{\\kappa}(T)=1$；邻域 $\\mathcal{P}_1$。\n- 案例2：对于 $S_{00}\\cup S_{01}$ 中的三角形 $\\kappa(T)=10$，对于 $S_{10}\\cup S_{11}$ 中的三角形 $\\kappa(T)=1$；对所有三角形 $\\tilde{\\kappa}(T)=1$；邻域 $\\mathcal{P}_2$。\n- 案例3：棋盘式对比度，对于 $S_{00}\\cup S_{11}$ 中的三角形 $\\kappa(T)=1000$，对于 $S_{10}\\cup S_{01}$ 中的三角形 $\\kappa(T)=1$；$\\tilde{\\kappa}(T)=\\kappa(T)$；邻域 $\\mathcal{P}_2$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例按上述顺序提供六个量值的列表。例如，输出应如下所示：\n\"[[bool,bool,bool,float,float,float],[bool,bool,bool,float,float,float],[bool,bool,bool,float,float,float]]\"\n所有布尔值都应不加引号，所有浮点数都应为标准十进制表示。不应打印任何额外文本。",
            "solution": "该问题被评估为有效，因为它在科学上基于偏微分方程的数值分析，特别是广义多尺度有限元方法（GMsFEM）。这是一个适定、客观且自洽的计算任务，提供了所有必要的数据和定义。\n\n目标是为一组给定的 GMsFEM 基函数 $\\{\\Phi_i\\}_{i=1}^{3}$ 构建粗糙刚度矩阵 $A_H$ 和质量矩阵 $M_H$。这些矩阵的元素由双线性形式 $A_{ij} = a(\\Phi_i, \\Phi_j)$ 和 $M_{ij} = s(\\Phi_i, \\Phi_j)$ 定义，其中\n$$ a(u,v)=\\int_{\\Omega}\\kappa(\\mathbf{x})\\,\\nabla u(\\mathbf{x})\\cdot\\nabla v(\\mathbf{x})\\,d\\mathbf{x} $$\n$$ s(u,v)=\\int_{\\Omega}\\tilde{\\kappa}(\\mathbf{x})\\,u(\\mathbf{x})\\,v(\\mathbf{x})\\,d\\mathbf{x} $$\n域 $\\Omega = [0,1]^2$ 被划分为一个由 $8$ 个三角形组成的协调三角剖分，记为 $\\{T_k\\}_{k=0}^7$。系数 $\\kappa(\\mathbf{x})$ 和 $\\tilde{\\kappa}(\\mathbf{x})$ 在此三角剖分上是分片常数。基函数 $\\Phi_i$ 是全局连续且分片线性的。\n\n有限元方法的核心原理是通过对网格中每个单元（三角形）的贡献求和来计算全局积分。\n对于刚度矩阵，由于 $\\kappa$ 在每个三角形 $T_k$ 上是常数（设为 $\\kappa_k$），并且分片线性基函数的梯度 $\\nabla\\Phi_i, \\nabla\\Phi_j$ 在 $T_k$ 上也是常数向量，因此积分简化为：\n$$ A_{ij} = \\sum_{k=0}^{7} \\int_{T_k} \\kappa(\\mathbf{x}) \\nabla\\Phi_i \\cdot \\nabla\\Phi_j \\,d\\mathbf{x} = \\sum_{k=0}^{7} \\kappa_k \\left( \\nabla\\Phi_i|_{T_k} \\cdot \\nabla\\Phi_j|_{T_k} \\right) \\text{Area}(T_k) $$\n对于质量矩阵，必须计算两个线性函数乘积在三角形上的积分：\n$$ M_{ij} = \\sum_{k=0}^{7} \\int_{T_k} \\tilde{\\kappa}(\\mathbf{x}) \\Phi_i \\Phi_j \\,d\\mathbf{x} = \\sum_{k=0}^{7} \\tilde{\\kappa}_k \\int_{T_k} \\Phi_i \\Phi_j \\,d\\mathbf{x} $$\n\n计算过程如下：\n1.  **单元计算**：对于网格中的每个三角形 $T_k$，我们计算其对全局矩阵的局部贡献。设 $T_k$ 的顶点为 $\\mathbf{p}_1=(x_1, y_1)$，$\\mathbf{p}_2=(x_2, y_2)$ 和 $\\mathbf{p}_3=(x_3, y_3)$。\n    -   三角形的面积计算为 $\\text{Area}(T_k) = \\frac{1}{2}|x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$。\n    -   对于任何基函数 $\\Phi_i$，其在 $T_k$ 上的限制是由其在三个顶点上的值（例如 $(u_1, u_2, u_3)$）定义的仿射函数。其常数梯度 $\\nabla\\Phi_i|_{T_k}$ 使用从局部 $P_1$ 有限元基函数 $\\lambda_m$ 导出的公式计算：$\\nabla\\Phi_i|_{T_k} = \\sum_{m=1}^3 u_m \\nabla\\lambda_m$。局部基函数的梯度是众所周知的：$\\nabla \\lambda_1 = \\frac{1}{2\\text{Area}(T_k)}\\begin{pmatrix} y_2-y_3 \\\\ x_3-x_2 \\end{pmatrix}$，对于 $\\nabla \\lambda_2, \\nabla \\lambda_3$ 依次类推。\n    -   在 $T_k$ 上对 $(\\Phi_i, \\Phi_j)$ 的单元刚度贡献为 $A_{ij}^{(k)} = \\kappa_k (\\nabla\\Phi_i|_{T_k} \\cdot \\nabla\\Phi_j|_{T_k}) \\text{Area}(T_k)$。\n    -   对于单元质量贡献，将在 $T_k$ 上 $\\Phi_i$ 和 $\\Phi_j$ 的节点值收集在向量 $\\mathbf{u}_i$ 和 $\\mathbf{u}_j$ 中。积分由 $\\int_{T_k} \\Phi_i \\Phi_j \\,d\\mathbf{x} = \\mathbf{u}_i^T \\mathbf{M}_{\\text{elem}}^{(k)} \\mathbf{u}_j$ 给出，其中 $\\mathbf{M}_{\\text{elem}}^{(k)}$ 是线性三角形单元的标准单元质量矩阵：\n        $$ \\mathbf{M}_{\\text{elem}}^{(k)} = \\frac{\\text{Area}(T_k)}{12} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\n        因此，单元质量贡献为 $M_{ij}^{(k)} = \\tilde{\\kappa}_k \\cdot \\mathbf{u}_i^T \\mathbf{M}_{\\text{elem}}^{(k)} \\mathbf{u}_j$。\n\n2.  **组装**：通过对这些单元贡献求和来组装全局矩阵 $A_H$ 和 $M_H$。\n    -   **全局组装**：对 $A_{ij}$ 和 $M_{ij}$ 的求和是在所有三角形 $k=0, \\dots, 7$ 上进行的。\n    -   **基于邻域的组装**：所有三角形的集合被划分为不相交的邻域 $\\mathcal{P} = \\{\\omega_m\\}$。对于每个邻域 $\\omega_m$，通过仅对 $\\omega_m$ 中的三角形的贡献求和来组装局部矩阵 $A_H^{\\omega_m}$ 和 $M_H^{\\omega_m}$。然后通过对邻域矩阵求和来形成最终的全局矩阵：$A_H = \\sum_m A_H^{\\omega_m}$ 和 $M_H = \\sum_m M_H^{\\omega_m}$。由于邻域构成了三角剖分的一个不相交划分，因此该结果必须与全局组装的结果相同，只存在浮点运算的细节差异。\n\n3.  **分析**：对于每个测试案例，在通过两种方法构建矩阵后，计算以下量值：\n    -   两种组装方法得到的矩阵的逐项相等性，对照 $10^{-12}$ 的容差进行检查。同时报告最大绝对差异。\n    -   所得矩阵 $A_H$ 和 $M_H$ 的对称性，也对照容差进行检查。双线性形式 $a(\\cdot,\\cdot)$ 和 $s(\\cdot,\\cdot)$ 是对称的，因此所得矩阵必须是对称的。\n    -   $A_H$ 和 $M_H$ 的最小特征值。由于基函数是线性无关的，且系数 $\\kappa, \\tilde{\\kappa}$ 严格为正，因此两个矩阵都应是正定的，从而具有正特征值。我们使用对称矩阵的特征值求解器。\n\n该实现精确地遵循了针对指定的三个测试案例的这些步骤，使用了给定的网格、基函数以及材料/邻域参数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef solve():\n    \"\"\"\n    Main solver function to orchestrate the GMsFEM matrix assembly and analysis.\n    \"\"\"\n    node_coords = np.array([\n        (0.0, 0.0), (0.5, 0.0), (1.0, 0.0),\n        (0.0, 0.5), (0.5, 0.5), (1.0, 0.5),\n        (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)\n    ])\n    triangles = np.array([\n        [0, 1, 4], [0, 4, 3], [1, 2, 5], [1, 5, 4],\n        [3, 4, 7], [3, 7, 6], [4, 5, 8], [4, 8, 7]\n    ])\n    phi_nodal_values = np.array([\n        [1, 0, 0, 1, 0, 0, 1, 0, 0],  # Phi_1\n        [0, 0, 1, 0, 0, 1, 0, 0, 1],  # Phi_2\n        [0, 0, 0, 0, 1, 0, 0, 0, 0],  # Phi_3\n    ]).T # Shape (num_nodes, num_basis_funcs) = (9, 3)\n\n    S_map = {\n        'S00': [0, 1], 'S10': [2, 3], \n        'S01': [4, 5], 'S11': [6, 7]\n    }\n\n    test_cases = [\n        {\n            'kappa': {t: 1.0 for t in range(8)},\n            'ktilde': {t: 1.0 for t in range(8)},\n            'neighborhoods': [[0, 1, 4, 5], [2, 3, 6, 7]]\n        },\n        {\n            'kappa': {t: 10.0 if t in S_map['S00'] + S_map['S01'] else 1.0 for t in range(8)},\n            'ktilde': {t: 1.0 for t in range(8)},\n            'neighborhoods': [S_map['S00'], S_map['S10'], S_map['S01'], S_map['S11']]\n        },\n        {\n            'kappa': {t: 1000.0 if t in S_map['S00'] + S_map['S11'] else 1.0 for t in range(8)},\n            'ktilde': {t: 1000.0 if t in S_map['S00'] + S_map['S11'] else 1.0 for t in range(8)},\n            'neighborhoods': [S_map['S00'], S_map['S10'], S_map['S01'], S_map['S11']]\n        }\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        A_global, M_global = assemble_matrices(\n            range(8), case_params['kappa'], case_params['ktilde'], \n            node_coords, triangles, phi_nodal_values\n        )\n\n        A_neigh = np.zeros_like(A_global)\n        M_neigh = np.zeros_like(M_global)\n        for neighborhood in case_params['neighborhoods']:\n            A_omega, M_omega = assemble_matrices(\n                neighborhood, case_params['kappa'], case_params['ktilde'], \n                node_coords, triangles, phi_nodal_values\n            )\n            A_neigh += A_omega\n            M_neigh += M_omega\n        \n        tol = 1e-12\n        discrepancy_A = np.max(np.abs(A_global - A_neigh))\n        discrepancy_M = np.max(np.abs(M_global - M_neigh))\n        max_discrepancy = max(discrepancy_A, discrepancy_M)\n\n        assembly_equal = max_discrepancy <= tol\n        A_symmetric = np.max(np.abs(A_global - A_global.T)) <= tol\n        M_symmetric = np.max(np.abs(M_global - M_global.T)) <= tol\n        \n        # Use eigvalsh for symmetric matrices\n        min_eig_A = np.min(eigvalsh(A_global))\n        min_eig_M = np.min(eigvalsh(M_global))\n\n        case_result = [\n            assembly_equal,\n            A_symmetric,\n            M_symmetric,\n            min_eig_A,\n            min_eig_M,\n            max_discrepancy\n        ]\n        all_results.append(case_result)\n\n    # Format output exactly as requested\n    print(repr(all_results).replace(\" \", \"\"))\n\ndef assemble_matrices(triangle_indices, kappa_map, ktilde_map, node_coords, triangles, phi_nodal_values):\n    \"\"\"\n    Assembles coarse stiffness and mass matrices over a given set of triangles.\n    \"\"\"\n    num_basis_funcs = phi_nodal_values.shape[1]\n    A_H = np.zeros((num_basis_funcs, num_basis_funcs))\n    M_H = np.zeros((num_basis_funcs, num_basis_funcs))\n\n    # Element mass matrix for a reference triangle of area 1\n    elem_mass_ref = (1/12) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    for tri_idx in triangle_indices:\n        node_indices = triangles[tri_idx]\n        p1, p2, p3 = node_coords[node_indices]\n        \n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        \n        # Matrix B for gradient calculation: [grad(lambda1), grad(lambda2), grad(lambda3)]\n        # where lambda_i are P1 nodal basis functions.\n        B_matrix = (0.5 / area) * np.array([\n            [p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]],\n            [p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]]\n        ])\n\n        # Get local nodal values for all basis functions on this triangle\n        local_phi_vals = phi_nodal_values[node_indices, :] # Shape (3, num_basis_funcs)\n        \n        # Compute gradients of all basis functions on this triangle\n        # Gradients are columns of shape (2, num_basis_funcs)\n        phi_grads = B_matrix @ local_phi_vals\n\n        # Stiffness matrix contribution\n        kappa = kappa_map[tri_idx]\n        elem_A = kappa * (phi_grads.T @ phi_grads) * area\n        A_H += elem_A\n\n        # Mass matrix contribution\n        ktilde = ktilde_map[tri_idx]\n        elem_M_local_basis = area * elem_mass_ref\n        elem_M = ktilde * (local_phi_vals.T @ elem_M_local_basis @ local_phi_vals)\n        M_H += elem_M\n\n    return A_H, M_H\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了如何使用基函数之后，下一个合乎逻辑的问题是如何有效地构造它们。本练习深入探讨了 GMsFEM 的核心：局部谱问题。通过一个简化的一维高对比度示例，您将通过解析推导来探索质量矩阵中不同权重函数的选择如何影响特征值，从而揭示为何特定的选择对于确保方法对材料属性的高对比度具有鲁棒性至关重要。",
            "id": "3764650",
            "problem": "考虑异构椭圆问题，这是广义多尺度有限元方法（GMsFEM）的典型起点。该问题由有界域 $\\Omega \\subset \\mathbb{R}^d$ 上的 $-\\nabla \\cdot (k \\nabla u) = f$ 给出，并带有适当的边界条件，其中 $k(x) \\ge c_0 > 0$ 是一个可测系数，可以具有高度非均质性和高对比度。在 GMsFEM 中，局部基函数是通过在粗网格邻域 $\\omega \\subset \\Omega$ 上设定的一个谱问题来选择的。标准能量双线性形式为 $a_\\omega(u,v) = \\int_\\omega k \\,\\nabla u \\cdot \\nabla v$，质量双线性形式为 $s_\\omega(u,v) = \\int_\\omega \\tilde{k} \\, u v$，其中权重 $\\tilde{k}(x) > 0$ 可供选择。广义特征值问题表述为：寻找 $(\\lambda, \\phi)$ 使得对于适当快照空间中的所有 $v$，都有 $a_\\omega(\\phi,v) = \\lambda \\, s_\\omega(\\phi,v)$。$\\tilde{k}$ 的选择影响瑞利商 $\\mathcal{R}(u) = \\dfrac{a_\\omega(u,u)}{s_\\omega(u,u)}$ 的排序和缩放，从而影响主要多尺度特征（如高传导率通道）的识别。\n\n为了从第一性原理出发进行推理，考虑一个一维粗网格邻域 $\\omega = [0,H]$，其系数为分段常数\n$$\nk(x) = \n\\begin{cases}\nk_H, & x \\in [0, H/2], \\\\\nk_L, & x \\in (H/2, H],\n\\end{cases}\n$$\n其中 $k_H \\gg k_L > 0$ 代表一种高对比度配置。令 $u_\\delta$ 是一个连续的分段线性试探函数，定义为：在 $[0, H/2 - \\delta]$ 上 $u_\\delta(x) = 1$，然后在 $[H/2 - \\delta, H/2 + \\delta]$ 上从 $1$ 线性递减到 $0$，在 $[H/2 + \\delta, H]$ 上 $u_\\delta(x) = 0$，其中 $0 < \\delta \\ll H$ 是一个固定的很小的数。这个函数模拟了一个连通性主导的模态，主要支撑在 $\\omega$ 的高传导率半区，并在界面处有一个狭窄的过渡层。使用 $a_\\omega(u,u) = \\int_\\omega k |\\nabla u|^2$ 和 $s_\\omega(u,u) = \\int_\\omega \\tilde{k} \\, u^2$，分析在不同 $\\tilde{k}$ 选择下瑞利商 $\\mathcal{R}(u_\\delta)$ 的缩放行为，并确定哪种选择能促进主导模态的对比度鲁棒识别（即，当 $k_H/k_L \\to \\infty$ 时，特征值缩放不发生退化）。您的推理应基于上述定义和对指定 $u_\\delta$ 的积分的科学合理近似。\n\n在 $s_\\omega(u,v) = \\int_\\omega \\tilde{k} \\, u v$ 中，$\\tilde{k}$ 的哪种选择能最鲁棒地促进连通性模态的对比度无关谱选择？\n\nA. $\\tilde{k}(x) \\equiv 1$ （标准 $L^2$ 内积）。\n\nB. $\\tilde{k}(x) \\equiv k(x)$ （系数加权的 $L^2$ 内积）。\n\nC. $\\tilde{k}(x) \\equiv k(x)^{-1}$ （逆系数加权的 $L^2$ 内积）。\n\nD. $\\tilde{k}(x) \\equiv \\bar{k}_\\omega$ （等于 $k$ 在 $\\omega$ 上的粗网格平均值的常数）。",
            "solution": "该问题要求确定在质量双线性形式 $s_\\omega(u,v) = \\int_\\omega \\tilde{k} \\, u v$ 中，权重函数 $\\tilde{k}(x)$ 的哪种选择能使连通性主导模态的谱选择对系数 $k(x)$ 的对比度具有鲁棒性。这种鲁棒性定义为：当对比度 $k_H/k_L$ 趋近于无穷大时，相应特征值（由瑞利商 $\\mathcal{R}(u)$ 近似）的缩放行为与对比度无关。我们将对给定的试探函数 $u_\\delta(x)$，分析每种提议的 $\\tilde{k}(x)$ 选择下的瑞利商。\n\n分析基于一维粗网格邻域 $\\omega = [0,H]$，其系数为\n$$\nk(x) = \n\\begin{cases}\nk_H, & x \\in [0, H/2] \\\\\nk_L, & x \\in (H/2, H]\n\\end{cases}\n$$\n其中 $k_H \\gg k_L > 0$。试探函数 $u_\\delta(x)$ 是连续的分段线性函数，定义为：\n$$\nu_\\delta(x) = \n\\begin{cases}\n1, & x \\in [0, H/2 - \\delta] \\\\\n\\frac{H/2 + \\delta - x}{2\\delta}, & x \\in (H/2 - \\delta, H/2 + \\delta) \\\\\n0, & x \\in [H/2 + \\delta, H]\n\\end{cases}\n$$\n其中参数 $0 < \\delta \\ll H$ 很小。\n\n瑞利商为 $\\mathcal{R}(u_\\delta) = \\dfrac{a_\\omega(u_\\delta, u_\\delta)}{s_\\omega(u_\\delta, u_\\delta)}$。我们首先计算分子 $a_\\omega(u_\\delta, u_\\delta)$，然后对每种情况计算分母 $s_\\omega(u_\\delta, u_\\delta)$。\n\n**1. 分子（能量项）的计算**\n\n$u_\\delta(x)$ 的导数仅在过渡区间内非零：\n$$\nu'_\\delta(x) = \n\\begin{cases}\n-\\frac{1}{2\\delta}, & x \\in (H/2 - \\delta, H/2 + \\delta) \\\\\n0, & \\text{其他区域}\n\\end{cases}\n$$\n能量双线性形式为 $a_\\omega(u,u) = \\int_0^H k(x) (u'(x))^2 \\, dx$。对于 $u_\\delta$，这变为：\n$$\na_\\omega(u_\\delta, u_\\delta) = \\int_{H/2 - \\delta}^{H/2 + \\delta} k(x) \\left(-\\frac{1}{2\\delta}\\right)^2 \\, dx\n$$\n由于 $k(x)$ 是分段常数，我们在 $x=H/2$ 处将积分分开：\n$$\na_\\omega(u_\\delta, u_\\delta) = \\frac{1}{4\\delta^2} \\left[ \\int_{H/2 - \\delta}^{H/2} k_H \\, dx + \\int_{H/2}^{H/2 + \\delta} k_L \\, dx \\right]\n$$\n$$\na_\\omega(u_\\delta, u_\\delta) = \\frac{1}{4\\delta^2} \\left[ k_H \\cdot \\delta + k_L \\cdot \\delta \\right] = \\frac{k_H + k_L}{4\\delta}\n$$\n这个表达式是精确的。\n\n**2. 分母（质量项）的计算**\n\n质量双线性形式为 $s_\\omega(u,u) = \\int_0^H \\tilde{k}(x) (u(x))^2 \\, dx$。我们需要对给定的函数 $u_\\delta$ 计算这个值。积分为：\n$$\ns_\\omega(u_\\delta, u_\\delta) = \\int_0^{H/2-\\delta} \\tilde{k}(x) (1)^2 \\, dx + \\int_{H/2-\\delta}^{H/2+\\delta} \\tilde{k}(x) \\left(\\frac{H/2 + \\delta - x}{2\\delta}\\right)^2 \\, dx\n$$\n由于 $\\delta \\ll H$，函数 $u_\\delta(x)$ 主要支撑在长度为 $O(H)$ 的区间 $[0, H/2]$ 上。过渡区域 $[H/2-\\delta, H/2+\\delta]$ 对积分的贡献是 $O(\\delta)$ 阶。区域 $[0, H/2-\\delta]$ 的贡献是 $O(H)$ 阶。对于渐近分析，一个标准且合理的做法是通过考虑 $u_\\delta$ 变为在 $[0, H/2]$ 上等于 $1$、在 $(H/2, H]$ 上等于 $0$ 的阶跃函数时的极限来近似 $s_\\omega(u_\\delta, u_\\delta)$。这得到：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} \\tilde{k}(x) (1)^2 \\, dx\n$$\n这个近似在计算质量积分的主阶项时是有效的，因为修正项是关于 $H$ 的低阶项。我们现在分析每个选项。\n\n**A. $\\tilde{k}(x) \\equiv 1$**\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} 1 \\, dx = \\frac{H}{2}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H/2} = \\frac{k_H + k_L}{2\\delta H}\n$$\n当 $k_H \\to \\infty$ 时，$\\mathcal{R}(u_\\delta)$ 的缩放行为是 $O(k_H)$。这依赖于对比度。\n**结论：不正确。** 该选择对对比度不鲁棒。\n\n**B. $\\tilde{k}(x) \\equiv k(x)$**\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} k(x) \\, dx = \\int_0^{H/2} k_H \\, dx = k_H \\frac{H}{2}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{k_H H/2} = \\frac{k_H + k_L}{2\\delta H k_H} = \\frac{1 + k_L/k_H}{2\\delta H}\n$$\n当 $k_H \\to \\infty$（因此 $k_L/k_H \\to 0$）时，瑞利商趋于一个常数值：\n$$\n\\lim_{k_H/k_L \\to \\infty} \\mathcal{R}(u_\\delta) = \\frac{1}{2\\delta H}\n$$\n这种缩放行为与对比度无关。这是一个很有希望的选项。\n\n**C. $\\tilde{k}(x) \\equiv k(x)^{-1}$**\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} k(x)^{-1} \\, dx = \\int_0^{H/2} k_H^{-1} \\, dx = \\frac{H}{2k_H}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H/(2k_H)} = \\frac{2k_H(k_H + k_L)}{4\\delta H} = \\frac{k_H^2 + k_H k_L}{2\\delta H}\n$$\n当 $k_H \\to \\infty$ 时，$\\mathcal{R}(u_\\delta)$ 的缩放行为是 $O(k_H^2)$。这高度依赖于对比度。\n**结论：不正确。**\n\n**D. $\\tilde{k}(x) \\equiv \\bar{k}_\\omega$**\n首先，我们计算平均值 $\\bar{k}_\\omega$：\n$$\n\\bar{k}_\\omega = \\frac{1}{H}\\int_0^H k(x) \\, dx = \\frac{1}{H} \\left( k_H \\frac{H}{2} + k_L \\frac{H}{2} \\right) = \\frac{k_H + k_L}{2}\n$$\n质量项为：\n$$\ns_\\omega(u_\\delta, u_\\delta) \\approx \\int_0^{H/2} \\bar{k}_\\omega \\, dx = \\bar{k}_\\omega \\frac{H}{2} = \\frac{H(k_H+k_L)}{4}\n$$\n瑞利商为：\n$$\n\\mathcal{R}(u_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H(k_H + k_L)/4} = \\frac{1}{\\delta H}\n$$\n这种缩放行为也与对比度无关。这是另一个很有希望的选项。\n\n**区分 B 和 D**\n\n选项 B 和 D 都使得测试函数 $u_\\delta$ 的特征值与对比度无关。然而，目标是*选择*连通性模态。这意味着谱问题应该能够区分“重要”模态（如 $u_\\delta$）和“不重要”模态。在这种情况下，一个不重要的模态是主要支撑在低传导率区域的模态。\n\n让我们定义第二个测试函数 $w_\\delta(x) = u_\\delta(H-x)$，它主要支撑在低传导率一侧 $[H/2, H]$。它的导数在相同的过渡区间 $(H/2-\\delta, H/2+\\delta)$ 上为 $w'_\\delta(x) = 1/(2\\delta)$。\n能量项是相同的：$a_\\omega(w_\\delta, w_\\delta) = \\frac{k_H+k_L}{4\\delta}$。\n使用相同的近似，质量项为 $s_\\omega(w_\\delta, w_\\delta) \\approx \\int_{H/2}^H \\tilde{k}(x) \\, dx$。\n一个鲁棒的选择方法应该为这个模态 $w_\\delta$ 赋予一个大的特征值。\n\n- 对于选项 B，$\\tilde{k}(x) = k(x)$：\n$$\ns_\\omega(w_\\delta, w_\\delta) \\approx \\int_{H/2}^H k_L \\, dx = k_L \\frac{H}{2}\n$$\n$$\n\\mathcal{R}(w_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{k_L H/2} = \\frac{k_H/k_L + 1}{2\\delta H}\n$$\n当 $k_H/k_L \\to \\infty$ 时，$\\mathcal{R}(w_\\delta) \\to \\infty$。该模态被赋予一个大的、发散的特征值，从而有效地将其从所选基中剔除。这是期望的行为。\n\n- 对于选项 D，$\\tilde{k}(x) = \\bar{k}_\\omega$：\n$$\ns_\\omega(w_\\delta, w_\\delta) \\approx \\int_{H/2}^H \\bar{k}_\\omega \\, dx = \\bar{k}_\\omega \\frac{H}{2} = \\frac{H(k_H+k_L)}{4}\n$$\n$$\n\\mathcal{R}(w_\\delta) \\approx \\frac{(k_H + k_L)/(4\\delta)}{H(k_H+k_L)/4} = \\frac{1}{\\delta H}\n$$\n这个特征值很小，并且与 $\\mathcal{R}(u_\\delta)$ 具有相同的、与对比度无关的值。这个选择未能区分连通性模态和被困在低传导率区域的模态。\n\n**关于选项的结论**\n- 选项 A 给出与对比度相关的特征值。**不正确。**\n- 选项 B 为连通性模态给出一个小的、与对比度无关的特征值，并为非连通性模态给出一个大的、与对比度相关的特征值。这提供了极好的谱分离。**正确。**\n- 选项 C 给出与对比度强相关的特征值。**不正确。**\n- 选项 D 为连通性和非连通性模态都给出了小的、与对比度无关的特征值，未能将它们分离开。**不正确。**\n\n因此，选择 $\\tilde{k}(x) = k(x)$ 最能鲁棒地促进对比度无关的谱选择。它为支撑在高传导率区域的模态赋予小特征值，为支撑在低传导率区域的模态赋予大特征值，从而实现了隔离问题主要特征的目标。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "这最后一个实践将前面练习中的概念整合到一个完整的数值实验中。您将为一个一维问题实现 GMsFEM 的完整流程：定义快照空间，求解局部谱问题以选择基函数，组装并求解全局粗化系统，最后验证方法的精度。这个综合性练习展示了理论选择（如特征值阈值和过采样）与方法的实际性能之间的相互作用。",
            "id": "3764604",
            "problem": "考虑多尺度建模中出现的一维二阶椭圆边值问题，该问题定义在单位区间 $[0,1]$ 上：求 $u \\in H_0^1(0,1)$，使得\n$$\n- \\frac{d}{dx}\\Big(a(x)\\, \\frac{du}{dx}\\Big) = f(x) \\quad \\text{in } (0,1), \\qquad u(0)=0,\\; u(1)=0,\n$$\n其中 $a(x)$ 是一个空间变化的正常数系数，$f(x)$ 是一个给定的源项。其弱形式为：求 $u \\in H_0^1(0,1)$，使得\n$$\n\\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n由该双线性形式诱导的能量范数定义为\n$$\n\\| w \\|_{a} := \\Big( \\int_0^1 a(x)\\, |w'(x)|^2\\, dx \\Big)^{1/2}.\n$$\n为数值验证广义多尺度有限元方法 (GMsFEM) (Generalized Multiscale Finite Element Method) 的误差估计，设计并实现一个程序，该程序使用标准协调线性有限元近似在均匀细网格上计算一个细尺度参考解 $u_h$，并比较归一化能量误差\n$$\nE(\\tau,L) := \\frac{\\| u_h - u_{\\mathrm{ms}}(\\tau,L) \\|_{a}}{\\| u_h \\|_{a}}\n$$\n该误差是用于构建多尺度空间的局部谱特征值阈值 $\\tau$ 和过采样大小 $L$ 的函数。\n\n该程序必须遵循以下规范。\n\n- 细尺度离散化：\n  - 使用包含 $N_f$ 个单元的均匀细网格，其中 $N_f$ 必须选择为 $N_f = 400$。令细网格尺寸为 $h = 1/N_f$。使用标准的分片线性有限元和一维单元公式，组装全局细尺度刚度矩阵 $K_h$ 和右端向量 $F_h$。通过消除线性系统中的边界自由度来强加狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n  - 使用 $f(x) = 1$ 和系数\n    $$\n    a(x) =\n    \\begin{cases}\n    10^{-3}, & x \\in [0.15, 0.30),\\\\\n    10^{3}, & x \\in [0.45, 0.55),\\\\\n    10^{-2}, & x \\in [0.80, 0.90),\\\\\n    1, & \\text{otherwise}.\n    \\end{cases}\n    $$\n- 粗网格和单位分解：\n  - 定义一个包含 $N_c$ 个单元的均匀粗网格，其中 $N_c$ 必须选择为 $N_c = 20$。令粗网格节点位于 $x_i = i/N_c$，其中整数 $i \\in \\{0,1,\\dots,N_c\\}$。对于每个内部粗网格节点索引 $i \\in \\{1,2,\\dots,N_c-1\\}$，定义支撑在 $[x_{i-1},x_{i+1}]$ 上的标准粗网格单位分解帽子函数 $\\chi_i(x)$，其表达式为\n    $$\n    \\chi_i(x) =\n    \\begin{cases}\n    \\dfrac{x - x_{i-1}}{1/N_c}, & x \\in [x_{i-1}, x_i], \\\\\n    \\dfrac{x_{i+1} - x}{1/N_c}, & x \\in [x_i, x_{i+1}], \\\\\n    0, & \\text{otherwise}.\n    \\end{cases}\n    $$\n  - 在细网格节点上计算 $\\chi_i(x)$ 的值，以形成离散的单位分解向量。\n- 局部快照空间和过采样：\n  - 对于每个内部粗网格节点索引 $i$，定义其基本粗邻域 $\\omega_i = [x_{i-1}, x_{i+1}]$。大小为 $L$ 的过采样邻域为 $\\omega_i^{(L)} = [x_{i-(1+L)}, x_{i+(1+L)}] \\cap [0,1]$，其中 $L$ 是每侧增加的额外粗网格层数。在离散形式下，将 $\\omega_i^{(L)}$ 映射到相应的连续细网格节点集。\n  - 在 $\\omega_i^{(L)}$ 上，将局部快照空间 $S_i$ 定义为求解以下方程的两个一维调和延拓的张成空间\n    $$\n    -\\frac{d}{dx}\\Big(a(x)\\, \\frac{ds}{dx}\\Big) = 0 \\quad \\text{in } \\omega_i^{(L)},\n    $$\n    对于第一个快照，边界条件为 $s(a)=1, s(b)=0$；对于第二个快照，边界条件为 $s(a)=0, s(b)=1$，其中 $[a,b] = \\omega_i^{(L)}$。在一维情况下，这些快照可以通过 $a(x)\\, s'(x)$ 的常数特性来表征，这意味着\n    $$\n    s_{\\mathrm{left}}(x) = 1 - \\frac{\\int_{a}^{x} \\frac{1}{a(\\xi)}\\, d\\xi}{\\int_{a}^{b} \\frac{1}{a(\\xi)}\\, d\\xi}, \\qquad\n    s_{\\mathrm{right}}(x) = \\frac{\\int_{a}^{x} \\frac{1}{a(\\xi)}\\, d\\xi}{\\int_{a}^{b} \\frac{1}{a(\\xi)}\\, d\\xi}.\n    $$\n    这些必须使用细尺度系数在细网格上进行离散化。\n- 局部谱分解与基函数选择：\n  - 对于每个内部粗网格节点 $i$，通过将全局细尺度矩阵限制在过采样邻域中的自由度上，来组装 $\\omega_i^{(L)}$ 上的局部刚度矩阵 $A_i$ 和加权质量矩阵 $M_i$。在快照空间 $S_i$ 上定义局部广义特征值问题\n    $$\n    A_i\\, \\psi = \\lambda\\, M_i\\, \\psi,\n    $$\n    其中 $\\psi$ 在快照基中表示。按特征值 $\\lambda$ 的非递减顺序对特征对进行排序。给定一个阈值 $\\tau > 0$，选择所有满足 $\\lambda \\le \\tau$ 的局部模态，并对每个选定的模态，通过乘以单位分解函数来形成全局连续多尺度基函数，即\n    $$\n    \\Phi_{i,m}(x) = \\chi_i(x)\\, \\psi_{i,m}(x),\n    $$\n    其中 $\\psi_{i,m}$ 是在 $\\omega_i^{(L)}$ 上的第 $m$ 个选定模态。\n- 全局粗尺度多尺度解：\n  - 将所有内部粗网格节点上选定的 $\\Phi_{i,m}$ 的张成空间作为全局多尺度空间 $V_{\\mathrm{ms}}(\\tau,L)$。通过将细尺度刚度和载荷投影到 $V_{\\mathrm{ms}}(\\tau,L)$ 上来形成降维伽辽金系统，求解多尺度系数，并在细网格上重构全局连续多尺度解 $u_{\\mathrm{ms}}(\\tau,L)$。如果对于任何粗网格节点都没有选择局部模态（即多尺度空间是平凡的），则设 $u_{\\mathrm{ms}}(\\tau,L) \\equiv 0$。\n- 误差量化：\n  - 使用由组装的细尺度刚度矩阵诱导的离散能量范数计算归一化能量误差 $E(\\tau,L)$。\n\n在单个程序中实现上述过程，并评估以下五个测试用例，这些用例改变了特征值阈值 $\\tau$ 和过采样大小 $L$：\n- 测试用例 1：$\\tau = 10^{-1}$，$L = 1$。\n- 测试用例 2：$\\tau = 10^{-8}$，$L = 1$。\n- 测试用例 3：$\\tau = 10^{6}$，$L = 1$。\n- 测试用例 4：$\\tau = 10^{-1}$，$L = 3$。\n- 测试用例 5：$\\tau = 10^{-1}$，$L = 0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应测试用例的 $E(\\tau,L)$ 的浮点值。不涉及物理单位，也不出现角度；输出是无单位的纯实数。程序必须能够直接运行，无需外部输入。",
            "solution": "该问题陈述是一个有效且适定的数值分析任务。它要求实现广义多尺度有限元方法 (GMsFEM) 来求解一个具有高对比度、分片常数系数的一维二阶椭圆边值问题。该问题为算法提供了一套完整且一致的规范，包括离散化参数、局部空间和算子的定义，以及基函数的选择标准。该问题在科学上植根于成熟的有限元方法和多尺度分析理论。所有必需的数据和条件均已提供，不存在会妨碍唯一数值解的矛盾或歧义。因此，我们着手求解。\n\n问题的核心是构建一套特殊的基函数，这些基函数能够捕捉由快速变化的系数 $a(x)$ 引起的解的小尺度特征，然后在一个伽辽金框架中使用这些基函数在粗网格上求解问题。之后，将此多尺度解 $u_{\\mathrm{ms}}$ 的误差与标准的细尺度有限元解 $u_h$ 进行比较。\n\n该过程可分解为以下主要步骤：\n\n**1. 细尺度参考解**\n\n首先，我们通过在一个非常精细的网格上使用标准协调线性有限元方法 (FEM) 求解该问题，来建立一个“基准真相”或参考解。问题是\n$$\n- \\frac{d}{dx}\\Big(a(x)\\, \\frac{du}{dx}\\Big) = f(x) \\quad \\text{for } x \\in (0,1),\n$$\n边界条件为齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。其弱形式是：求 $u \\in H_0^1(0,1)$，使得对于所有测试函数 $v \\in H_0^1(0,1)$：\n$$\nB(u,v) = L(v) \\quad \\text{where} \\quad B(u,v) = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx \\quad \\text{and} \\quad L(v) = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\n我们用一个包含 $N_f=400$ 个单元、尺寸为 $h=1/N_f$ 的均匀网格对区域 $[0,1]$ 进行离散化。解 $u(x)$ 由 $u_h(x) = \\sum_{j=1}^{N_f-1} U_j \\phi_j(x)$ 近似，其中 $\\phi_j$ 是标准的分片线性（“帽子”）基函数，$U_j$ 是未知的节点值。这导出了线性方程组：\n$$\nK_h U_h = F_h,\n$$\n其中 $K_h$ 是 $(N_f-1) \\times (N_f-1)$ 的全局刚度矩阵，$F_h$ 是大小为 $N_f-1$ 的全局载荷向量。其元素由 $(K_h)_{ij} = B(\\phi_j, \\phi_i)$ 和 $(F_h)_i = L(\\phi_i)$ 给出。我们求解此系统以找到节点值向量 $U_h$，它代表我们的参考解 $u_h$。此解的能量 $\\|u_h\\|_a^2 = U_h^T K_h U_h$ 将用作误差的归一化因子。\n\n**2. 粗网格和单位分解**\n\n我们定义一个包含 $N_c=20$ 个单元的均匀粗网格，节点位于 $x_i = i/N_c$。对于每个内部粗网格节点 $i \\in \\{1, \\dots, N_c-1\\}$，我们定义一个单位分解 (PU) 函数 $\\chi_i(x)$。根据规范，这些是标准的粗尺度线性有限元基函数。每个 $\\chi_i(x)$ 仅在粗邻域 $\\omega_i = [x_{i-1}, x_{i+1}]$ 上非零。这些单位分解函数将用于局部化多尺度基函数。\n\n**3. GMsFEM 基函数构造**\n\n这是该方法的核心部分。对于每个内部粗网格节点 $i$，我们构造一组局部多尺度基函数。\n\n**a. 过采样与快照空间：**\n为了减轻问题局部化带来的人为边界效应，我们通过在基本邻域 $\\omega_i$ 的每侧扩展 $L$ 个粗单元层来定义一个过采样邻域 $\\omega_i^{(L)}$。在这个区域 $\\omega_i^{(L)}$ 上，我们定义一个“快照”空间 $S_i$。该空间应包含能很好地近似真实解在该局部区域内行为的函数。问题指定了一个由两个调和延拓张成的快照空间，这两个调和延拓是在 $\\omega_i^{(L)}$ 上求解齐次问题 $- (a(x) s')' = 0$ 的解，其在 $\\omega_i^{(L)}$ 的边界上满足狄利克雷边界条件 $(1,0)$ 和 $(0,1)$。这些函数自然地包含了关于系数 $a(x)$ 局部变化的信息。\n\n**b. 局部谱问题：**\n快照空间通常是超大的。为了找到其中最主要的模态，我们求解一个局部广义特征值问题。对于每个邻域 $\\omega_i^{(L)}$，我们寻找函数 $\\psi \\in S_i$，这些函数是原始微分算子在该域上受限并以快照基表示的特征函数。这可以写成以下形式：\n$$\nA_i \\psi = \\lambda M_i \\psi,\n$$\n其中 $A_i$ 和 $M_i$ 分别是与双线性形式 $\\int_{\\omega_i^{(L)}} a(x) u'v' dx$ 和 $\\int_{\\omega_i^{(L)}} a(x) uv dx$ 相关联并投影到快照基上的刚度矩阵和质量矩阵。特征值 $\\lambda$ 表示特征函数能量与其加权 $L^2$ 范数之比。小特征值对应于“低能量”且相对于能量范数变化缓慢的模态；这些是为获得良好全局近似而需要捕捉的最重要的模态。\n\n**c. 基函数选择与局部化：**\n给定一个阈值 $\\tau > 0$，我们选择所有其对应特征值 $\\lambda_{i,m}$ 满足 $\\lambda_{i,m} \\le \\tau$ 的特征函数 $\\psi_{i,m}$。然后，通过将这些选定的局部函数乘以相应的单位分解函数 $\\chi_i(x)$ 来进行局部化：\n$$\n\\Phi_{i,m}(x) = \\chi_i(x) \\psi_{i,m}(x).\n$$\n这确保了最终的全局基函数 $\\Phi_{i,m}$ 是连续的，并且与单位分解函数具有相同的局部支撑。\n\n**4. 全局多尺度解**\n\n多尺度空间 $V_{\\mathrm{ms}}$ 由所有内部粗网格节点上选定的所有基函数 $\\{\\Phi_{i,m}\\}$ 张成。我们寻求一个近似解 $u_{\\mathrm{ms}} \\in V_{\\mathrm{ms}}$。通过在该空间上应用伽辽金原理，我们将原始的细尺度问题投影到多尺度基上：\n$$\nK_{\\mathrm{ms}} U_{\\mathrm{ms}} = F_{\\mathrm{ms}},\n$$\n其中，粗尺度多尺度刚度矩阵和载荷向量通过投影形成：$K_{\\mathrm{ms}} = R_{\\mathrm{ms}}^T K_h R_{\\mathrm{ms}}$ 和 $F_{\\mathrm{ms}} = R_{\\mathrm{ms}}^T F_h$。这里，$R_{\\mathrm{ms}}$ 是一个矩阵，其列是基函数 $\\Phi_{i,m}$ 在细网格上的离散表示。在求解这个小型系统得到系数 $U_{\\mathrm{ms}}$ 后，我们通过 $u_{\\mathrm{ms}} = R_{\\mathrm{ms}} U_{\\mathrm{ms}}$ 在细网格上重构全局解。\n\n**5. 误差计算**\n\n最后，我们计算能量范数下的相对误差，以量化给定参数集 $(\\tau, L)$ 下多尺度近似的精度：\n$$\nE(\\tau,L) = \\frac{\\| u_h - u_{\\mathrm{ms}}(\\tau,L) \\|_{a}}{\\| u_h \\|_{a}} = \\sqrt{\\frac{(U_h - U_{\\mathrm{ms}})^T K_h (U_h - U_{\\mathrm{ms}})}{U_h^T K_h U_h}}.\n$$\n这个归一化误差衡量了 GMsFEM 解在能量方面对参考解的近似程度。我们预期误差会随着过采样大小 $L$ 的增大和谱阈值 $\\tau$ 的增大（即包含更多基函数）而减小。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the GMsFEM procedure to solve a 1D elliptic problem and computes\n    the normalized energy error for several test cases.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. Global Setup and Fine-Scale Problem\n    # --------------------------------------------------------------------------\n    N_f = 400  # Number of fine elements\n    N_c = 20   # Number of coarse elements\n    f_val = 1.0  # Source term f(x)\n\n    h = 1.0 / N_f\n    x_fine = np.linspace(0, 1, N_f + 1)\n    x_coarse = np.linspace(0, 1, N_c + 1)\n    \n    # Define coefficient a(x)\n    def get_a(x_coords):\n        a = np.ones_like(x_coords, dtype=float)\n        a[np.logical_and(x_coords >= 0.15, x_coords < 0.30)] = 1e-3\n        a[np.logical_and(x_coords >= 0.45, x_coords < 0.55)] = 1e3\n        a[np.logical_and(x_coords >= 0.80, x_coords < 0.90)] = 1e-2\n        return a\n\n    fine_elem_midpoints = x_fine[:-1] + h / 2.0\n    a_vals = get_a(fine_elem_midpoints)\n\n    # Assemble full fine-scale matrices (pre-BCs)\n    num_nodes_fine = N_f + 1\n    K_h_full = np.zeros((num_nodes_fine, num_nodes_fine))\n    M_a_full = np.zeros((num_nodes_fine, num_nodes_fine))\n    F_h_full = np.zeros(num_nodes_fine)\n\n    for k in range(N_f):\n        # Element stiffness matrix\n        ke = (a_vals[k] / h) * np.array([[1, -1], [-1, 1]])\n        K_h_full[k:k+2, k:k+2] += ke\n        \n        # Element a-weighted mass matrix\n        me = (a_vals[k] * h / 6.0) * np.array([[2, 1], [1, 2]])\n        M_a_full[k:k+2, k:k+2] += me\n        \n        # Element load vector\n        fe = (f_val * h / 2.0) * np.array([1, 1])\n        F_h_full[k:k+2] += fe\n\n    # Apply strong Dirichlet BCs\n    interior_nodes_slice = slice(1, -1)\n    K_h = K_h_full[interior_nodes_slice, interior_nodes_slice]\n    F_h = F_h_full[interior_nodes_slice]\n\n    # Solve for fine-scale reference solution\n    u_h_vec = np.linalg.solve(K_h, F_h)\n    \n    energy_ref_sq = u_h_vec.T @ K_h @ u_h_vec\n    if energy_ref_sq == 0:\n        # Avoid division by zero, though unlikely for this problem\n        energy_ref_sq = 1.0\n\n    # --------------------------------------------------------------------------\n    # 2. Loop over Test Cases\n    # --------------------------------------------------------------------------\n    test_cases = [\n        (1e-1, 1),\n        (1e-8, 1),\n        (1e6, 1),\n        (1e-1, 3),\n        (1e-1, 0),\n    ]\n\n    results = []\n    \n    # Pre-compute integrals for snapshot functions\n    g_vals = 1.0 / a_vals\n    integral_g_from_0 = np.zeros(num_nodes_fine)\n    integral_g_from_0[1:] = np.cumsum(g_vals * h)\n\n    # Pre-compute partition of unity functions\n    H = 1.0 / N_c\n    chi_functions = []\n    for i in range(1, N_c):\n        x_rel_left = (x_fine - x_coarse[i-1]) / H\n        x_rel_right = (x_coarse[i+1] - x_fine) / H\n        chi_i = np.maximum(0, np.minimum(x_rel_left, x_rel_right))\n        chi_functions.append(chi_i)\n\n    for tau, L in test_cases:\n        R_ms_cols = []\n        \n        # ----------------------------------------------------------------------\n        # 3. Construct Multiscale Basis for each Coarse Neighborhood\n        # ----------------------------------------------------------------------\n        for i in range(1, N_c): # Loop over interior coarse nodes\n            # Define oversampled neighborhood omega_i^(L)\n            i_start = max(0, i - (1 + L))\n            i_end = min(N_c, i + (1 + L))\n            \n            # Map to fine node indices\n            fine_elem_per_coarse = N_f // N_c\n            start_node_idx = i_start * fine_elem_per_coarse\n            end_node_idx = i_end * fine_elem_per_coarse\n            fine_indices_in_omega = np.arange(start_node_idx, end_node_idx + 1)\n            \n            # Compute snapshot functions\n            den = integral_g_from_0[end_node_idx] - integral_g_from_0[start_node_idx]\n            if den == 0: continue\n            \n            num = integral_g_from_0[fine_indices_in_omega] - integral_g_from_0[start_node_idx]\n            s_right = num / den\n            s_left = 1.0 - s_right\n            \n            R_i = np.vstack((s_left, s_right)).T\n\n            # Extract local matrices\n            ix_ = np.ix_(fine_indices_in_omega, fine_indices_in_omega)\n            K_loc = K_h_full[ix_]\n            M_loc = M_a_full[ix_]\n\n            # Project onto snapshot space\n            A_tilde = R_i.T @ K_loc @ R_i\n            M_tilde = R_i.T @ M_loc @ R_i\n            \n            # Solve local spectral problem\n            try:\n                lambdas, evecs = eigh(A_tilde, M_tilde)\n            except np.linalg.LinAlgError:\n                continue\n\n            # Select and form global basis functions\n            chi_i = chi_functions[i-1]\n            for m in range(len(lambdas)):\n                if lambdas[m] <= tau:\n                    psi_loc = R_i @ evecs[:, m]\n                    psi_glob = np.zeros(num_nodes_fine)\n                    psi_glob[fine_indices_in_omega] = psi_loc\n                    \n                    # Multiply by partition of unity\n                    Phi = psi_glob * chi_i\n                    \n                    # Store interior part of basis vector\n                    R_ms_cols.append(Phi[interior_nodes_slice])\n\n        # ----------------------------------------------------------------------\n        # 4. Solve Global Multiscale Problem & Compute Error\n        # ----------------------------------------------------------------------\n        if not R_ms_cols:\n            u_ms_vec = np.zeros(N_f - 1)\n        else:\n            R_ms_int = np.array(R_ms_cols).T\n            \n            # Form and solve coarse system\n            K_ms = R_ms_int.T @ K_h @ R_ms_int\n            F_ms = R_ms_int.T @ F_h\n            \n            U_ms = np.linalg.solve(K_ms, F_ms)\n            \n            # Reconstruct fine-scale solution\n            u_ms_vec = R_ms_int @ U_ms\n\n        # Compute normalized energy error\n        error_vec = u_h_vec - u_ms_vec\n        energy_error_sq = error_vec.T @ K_h @ error_vec\n        normalized_error = np.sqrt(energy_error_sq / energy_ref_sq)\n        results.append(normalized_error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}