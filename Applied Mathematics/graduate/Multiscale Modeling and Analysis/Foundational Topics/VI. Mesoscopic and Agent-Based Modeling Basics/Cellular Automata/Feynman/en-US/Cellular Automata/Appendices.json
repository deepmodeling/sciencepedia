{
    "hands_on_practices": [
        {
            "introduction": "The foundation of studying cellular automata is a clear and unambiguous language for defining their rules. The Wolfram rule numbering system provides a compact and standardized method for classifying the behavior of elementary (1D, binary, nearest-neighbor) automata. This first exercise provides practice in the fundamental skill of translating a set of local, descriptive rules—in this case, from a hypothetical model of gene regulation—into a precise Wolfram rule number, a crucial first step for any analysis or simulation. ",
            "id": "1421566",
            "problem": "A systems biologist is developing a simplified one-dimensional model to study the dynamics of gene expression in a line of adjacent cells. The state of each cell is binary: `1` represents an \"expressed\" gene, and `0` represents a \"repressed\" gene. The state of a cell at the next time step is determined by its current state and the states of its immediate left and right neighbors. This collection of three cells (left, center, right) is called the neighborhood.\n\nThe system updates according to the following set of local rules:\n*   If a cell and both its neighbors are expressed (`111`), the central cell becomes repressed in the next step due to resource competition.\n*   If a central cell has two expressed neighbors but is itself repressed (`101`), it becomes expressed in the next step due to strong external signals.\n*   If a central cell is expressed and has exactly one expressed neighbor (either `110` or `011`), it remains expressed.\n*   If a central cell is expressed but both of its neighbors are repressed (`010`), it becomes repressed due to lack of support.\n*   In all other cases, the central cell will be in a repressed state (`0`) in the next time step.\n\nThe behavior of such a system can be described by an integer known as the Wolfram rule number. This number is the decimal representation of an 8-bit binary string. The binary string is constructed by listing the outcomes (the next state of the central cell) for all eight possible neighborhood configurations. The outcomes are ordered according to the neighborhood's value when treated as a 3-bit binary number, from largest (`111`) to smallest (`000`).\n\nCalculate the Wolfram rule number that describes this model of gene regulation.",
            "solution": "We enumerate all eight neighborhoods from largest to smallest, $111,110,101,100,011,010,001,000$, and determine the next state of the central cell using the given rules.\n\n- For $111$: by the first rule, the central cell becomes repressed, so output $0$.\n- For $110$: the central cell is expressed with exactly one expressed neighbor, so it remains expressed, output $1$.\n- For $101$: the central cell is repressed with two expressed neighbors, so it becomes expressed, output $1$.\n- For $100$: no special rule applies, so by the last rule the output is $0$.\n- For $011$: the central cell is expressed with exactly one expressed neighbor, so it remains expressed, output $1$.\n- For $010$: the central cell is expressed with both neighbors repressed, so it becomes repressed, output $0$.\n- For $001$: no special rule applies, so by the last rule the output is $0$.\n- For $000$: no special rule applies, so by the last rule the output is $0$.\n\nThus the ordered output bits from $111$ to $000$ are $0,1,1,0,1,0,0,0$, giving the 8-bit binary string $01101000$.\n\nInterpreting this as a binary number, its decimal value is\n$$0\\cdot 2^{7}+1\\cdot 2^{6}+1\\cdot 2^{5}+0\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+0\\cdot 2^{1}+0\\cdot 2^{0}=64+32+8=104.$$\n\nTherefore, the Wolfram rule number is $104$.",
            "answer": "$$\\boxed{104}$$"
        },
        {
            "introduction": "Beyond simple definitions, the true power of cellular automata lies in their capacity for emergent complexity, where simple local interactions generate intricate global patterns. This exercise moves from rule definition to dynamic analysis, exploring the evolution of the famous \"Rule 90\". By starting from a single active cell, you will uncover a deep and elegant connection between the automaton's behavior and the structure of Pascal's triangle, providing a classic example of how complex, self-organizing structures can arise from elementary foundations. ",
            "id": "1666375",
            "problem": "An elementary cellular automaton consists of a one-dimensional grid of cells, indexed by integers, where each cell can be in one of two states: 0 (off) or 1 (on). The system evolves in discrete time steps. The state of a cell at position $i$ at time $t+1$, denoted $S_{t+1}(i)$, is determined by the states of specific cells at time $t$.\n\nFor this particular automaton, the update rule is given by the sum modulo 2 of the states of the cell at position $i-1$ and the cell at position $i+1$ at the previous time step. That is:\n$$S_{t+1}(i) = [S_t(i-1) + S_t(i+1)] \\pmod 2$$\nNote that a cell's own state at time $t$ does not directly influence its state at $t+1$.\n\nThe automaton starts at time $t=0$ with a single cell at position $i=0$ in state 1, and all other cells are in state 0.\n\nCalculate the total number of cells in state 1 across the entire grid at time $t=99$.",
            "solution": "We consider the elementary cellular automaton with update rule\n$$\nS_{t+1}(i) = \\left[S_{t}(i-1) + S_{t}(i+1)\\right] \\bmod 2,\n$$\nand initial condition $S_{0}(0)=1$ with $S_{0}(i)=0$ for all $i \\neq 0$. Because updates only use neighbors, after $t$ steps only positions $i$ with $|i| \\le t$ and with $t+i$ even can be nonzero. \n\nWe claim the explicit formula\n$$\nS_{t}(i) \\equiv \\binom{t}{\\frac{t+i}{2}} \\pmod{2} \\quad \\text{for } t+i \\text{ even, and } S_{t}(i)=0 \\text{ otherwise}.\n$$\nThis is proved by induction on $t$. For $t=0$, only $i=0$ satisfies $t+i$ even, and $\\binom{0}{0}=1$, matching $S_{0}(0)=1$ and $S_{0}(i)=0$ otherwise. Assume it holds for time $t$. For time $t+1$ and any $i$, set $m=\\frac{t+1+i}{2}$. Then\n$$\nS_{t+1}(i) \\equiv S_{t}(i-1) + S_{t}(i+1) \\pmod{2}.\n$$\nIf $t+1+i$ is odd, then both $t+(i-1)$ and $t+(i+1)$ are odd, so by the induction hypothesis both terms are zero and $S_{t+1}(i)=0$, consistent with the claim. If $t+1+i$ is even, then $t+(i-1)=2(m-1)$ and $t+(i+1)=2m$, so by the induction hypothesis,\n$$\nS_{t}(i-1) \\equiv \\binom{t}{m-1} \\pmod{2}, \\qquad S_{t}(i+1) \\equiv \\binom{t}{m} \\pmod{2}.\n$$\nHence, using Pascal's identity,\n$$\nS_{t+1}(i) \\equiv \\binom{t}{m-1} + \\binom{t}{m} \\equiv \\binom{t+1}{m} \\pmod{2},\n$$\nwhich is exactly the claimed form with $m=\\frac{t+1+i}{2}$. This completes the induction, so the formula holds for all $t$.\n\nTherefore, the number of cells in state $1$ at time $t$ equals the number of odd binomial coefficients in row $t$ of Pascal's triangle, that is, the number of $k$ with $0 \\le k \\le t$ such that $\\binom{t}{k}$ is odd. By Lucas's theorem, $\\binom{t}{k}$ is odd if and only if, in binary, each $1$-bit of $k$ occurs only where $t$ also has a $1$-bit. Thus the number of such $k$ equals $2^{s_{2}(t)}$, where $s_{2}(t)$ is the number of $1$-bits in the binary expansion of $t$.\n\nFor $t=99$, write $99=64+32+2+1$, so in binary $99$ has $4$ ones. Hence $s_{2}(99)=4$, and the total number of ones at time $t=99$ is\n$$\n2^{s_{2}(99)} = 2^{4} = 16.\n$$",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "Bridging the gap between theoretical concepts and practical application requires moving from the abstraction of infinite lattices to the reality of finite computational domains. This computational exercise addresses the critical issue of boundary conditions, which dictate how a finite automaton behaves at its edges. You will implement a CA simulator to quantitatively investigate how different boundary conditions—periodic, fixed, and absorbing—influence pattern persistence and propagation, developing essential skills for using CAs as robust modeling tools for real-world systems. ",
            "id": "3104945",
            "problem": "You will implement and analyze a one-dimensional, binary Elementary Cellular Automaton (ECA) to investigate how boundary conditions affect pattern persistence and propagation. The automaton evolves on a finite lattice of length $N$ with time horizon $T$ and state vector $\\mathbf{s}(t) \\in \\{0,1\\}^N$ for discrete time $t \\in \\{0,1,2,\\dots,T\\}$. The local update rule is defined by a Wolfram rule number $R \\in \\{0,1,\\dots,255\\}$, which maps each neighborhood $\\left(s_{i-1}(t), s_i(t), s_{i+1}(t)\\right)$ to $s_i(t+1)$. The $8$ neighborhood patterns are indexed as integers $b \\in \\{0,1,\\dots,7\\}$ using $b = 4 s_{i-1} + 2 s_i + s_{i+1}$, and the next state is given by the $b$-th bit of $R$, i.e., $s_i(t+1) = \\left\\lfloor \\dfrac{R}{2^b} \\right\\rfloor \\bmod 2$.\n\nBoundary conditions specify how to handle neighbors outside the lattice:\n- Periodic: indices wrap around modulo $N$.\n- Fixed: the left ghost neighbor and the right ghost neighbor take fixed values $b_L, b_R \\in \\{0,1\\}$, respectively.\n- Absorbing: the update uses fixed ghost neighbors $b_L = 0$ and $b_R = 0$ as in the fixed case, and then the boundary cells are forcibly set to $0$ at each time step, i.e., $s_0(t+1) \\leftarrow 0$ and $s_{N-1}(t+1) \\leftarrow 0$.\n\nInitial conditions are either a single central seed or the zero state:\n- Single central seed: $s_i(0) = 1$ if $i = \\left\\lfloor \\dfrac{N}{2} \\right\\rfloor$ and $s_i(0) = 0$ otherwise.\n- Zero state: $s_i(0) = 0$ for all $i$.\n\nDefine the following quantitative metrics to assess persistence and propagation:\n- Pattern persistence $P$: the count of time indices $t \\in \\{0,1,\\dots,T\\}$ for which $\\sum_{i=0}^{N-1} s_i(t) > 0$. Thus $P \\in \\{0,1,\\dots,T+1\\}$.\n- Propagation distance $D$: let $x_0 = \\left\\lfloor \\dfrac{N}{2} \\right\\rfloor$. For each $t$, define the set of active indices $A(t) = \\{ i \\in \\{0,\\dots,N-1\\} \\mid s_i(t) = 1 \\}$. If $A(t)$ is empty, its contribution to $D$ is $0$. Otherwise define a distance function $d(i,x_0)$ by\n  - Periodic: $d(i,x_0) = \\min\\left( |i - x_0|, N - |i - x_0| \\right)$.\n  - Fixed or absorbing: $d(i,x_0) = |i - x_0|$.\n  Then $D = \\max_{t \\in \\{0,\\dots,T\\}} \\max_{i \\in A(t)} d(i,x_0)$, with the convention that the maximum over an empty set is $0$.\n- Propagation speed $V$: $V = \\dfrac{D}{T}$ for $T > 0$, and $V = 0$ for $T = 0$.\n\nTask. Write a complete, runnable program that:\n- Implements the ECA evolution for a given rule $R$, lattice size $N$, time horizon $T$, boundary condition type, and initial condition.\n- Computes the metrics $P$, $D$, and $V$ as defined above.\n- Runs the following test suite and reports the metrics for each case.\n\nUse the Wolfram rule $R = 170$ (which corresponds to a pure shift-left dynamics) in all cases below.\n\nTest Suite:\n1. Case $1$: periodic boundary; $N = 21$, $T = 7$; initial condition is a single central seed.\n2. Case $2$: fixed boundary with $b_L = 0$, $b_R = 0$; $N = 21$, $T = 7$; initial condition is a single central seed.\n3. Case $3$: absorbing boundary; $N = 21$, $T = 7$; initial condition is a single central seed.\n4. Case $4$: fixed boundary with $b_L = 0$, $b_R = 0$; $N = 21$, $T = 15$; initial condition is a single central seed.\n5. Case $5$: absorbing boundary; $N = 21$, $T = 15$; initial condition is a single central seed.\n6. Case $6$: periodic boundary; $N = 13$, $T = 9$; initial condition is the zero state.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, in the exact order of the test cases. Each test case result must be the list $[P,D,V]$, where $P$ and $D$ are integers, and $V$ is a decimal rounded to six digits after the decimal point.\n- For example, a valid overall output format for two cases would be: $[[P_1,D_1,V_1],[P_2,D_2,V_2]]$ with $V_1$ and $V_2$ shown with exactly six digits after the decimal point.\n\nNo physical units are involved in this problem. Angles are not used. All ratios must be reported as decimals as specified. The final answer must be a complete, runnable program that performs the simulation and prints the required single-line output in the specified format, with $V$ rounded to six decimal places.",
            "solution": "The problem requires the implementation and analysis of a one-dimensional, binary Elementary Cellular Automaton (ECA). The core of the task is to simulate the automaton's evolution under specified rules, boundary conditions, and initial conditions, and then to compute a set of defined metrics: pattern persistence $P$, propagation distance $D$, and propagation speed $V$.\n\nFirst, we must formalize the ECA update rule. The state of a cell $s_i$ at time $t+1$ is determined by the states of its neighbors $(s_{i-1}, s_i, s_{i+1})$ at time $t$. The problem specifies a Wolfram rule number $R$. The neighborhood configuration is mapped to an integer index $b = 4s_{i-1} + 2s_i + s_{i+1}$. The new state is the $b$-th bit of the binary representation of $R$, given by $s_i(t+1) = \\lfloor R / 2^b \\rfloor \\bmod 2$.\n\nThe problem mandates the use of rule $R=170$ for all test cases. In binary, $R=170$ is $10101010_2$. Let's analyze this rule. The 8 bits of the rule correspond to the outcomes for neighborhoods indexed 7 down to 0.\n- Neighborhood index $b$: 7(111), 6(110), 5(101), 4(100), 3(011), 2(010), 1(001), 0(000)\n- Rule 170 output bit:   1,     0,     1,     0,     1,     0,     1,     0\nA key observation is that the output bit is 1 if and only if the neighborhood index $b$ is odd. The index $b = 4s_{i-1} + 2s_i + s_{i+1}$ is odd if and only if its least significant bit, which corresponds to the state of the right neighbor $s_{i+1}$, is 1. Thus, the next state of cell $i$ is independent of its own state and its left neighbor's state. The rule simplifies to a much more direct relationship:\n$$ s_i(t+1) = s_{i+1}(t) $$\nThis means the state of any cell at the next time step is simply the current state of its right neighbor. This describes a pure left-shift dynamic: the entire pattern on the grid moves one cell to the left at each time step. This crucial insight simplifies the analysis of the system's dynamics.\n\nThe simulation will proceed as follows:\n1.  Initialize the lattice $\\mathbf{s}(0)$ of size $N$ according to the specified initial condition (single central seed or zero state). The central index is $x_0 = \\lfloor N/2 \\rfloor$.\n2.  Store the history of states, starting with $\\mathbf{s}(0)$.\n3.  Iterate for $t$ from $0$ to $T-1$ to generate states $\\mathbf{s}(1), \\dots, \\mathbf{s}(T)$.\n4.  In each step, a new state vector $\\mathbf{s}(t+1)$ is computed from $\\mathbf{s}(t)$. For each cell $i \\in \\{0, \\dots, N-1\\}$, we determine its neighborhood $(s_{i-1}, s_i, s_{i+1})$ based on the current state $\\mathbf{s}(t)$ and the boundary conditions.\n    -   **Periodic BC**: Indices are taken modulo $N$. For example, the right neighbor of cell $N-1$ is cell $0$.\n    -   **Fixed BC**: For cell $0$, the left neighbor state is a fixed value $b_L$. For cell $N-1$, the right neighbor state is $b_R$.\n    -   **Absorbing BC**: This is a special case of Fixed BC with $b_L=0, b_R=0$, but with an additional rule: after computing $\\mathbf{s}(t+1)$, the boundary cells are forcibly set to zero: $s_0(t+1) \\leftarrow 0$ and $s_{N-1}(t+1) \\leftarrow 0$.\n5.  With the neighborhood determined, the update rule for Rule 170 is applied.\n6.  After the simulation completes, the metrics are calculated from the stored history of $T+1$ states.\n\n**Metric Calculation:**\n-   **Pattern Persistence ($P$)**: Iterate through the stored states $\\mathbf{s}(0), \\dots, \\mathbf{s}(T)$. Count how many of these states are not the zero vector (i.e., $\\sum_i s_i(t) > 0$).\n-   **Propagation Distance ($D$)**: First, identify the center $x_0 = \\lfloor N/2 \\rfloor$. For each time step $t$, find the set of active cells $A(t) = \\{i \\mid s_i(t) = 1\\}$. If $A(t)$ is non-empty, calculate the maximum distance of any active cell from the center, $D_t = \\max_{i \\in A(t)} d(i, x_0)$. The distance function $d(i, x_0)$ depends on the boundary condition type:\n    -   Periodic: $d(i, x_0) = \\min(|i - x_0|, N - |i - x_0|)$.\n    -   Fixed/Absorbing: $d(i, x_0) = |i - x_0|$.\n    The final metric $D$ is the maximum of these distances over all time: $D = \\max_{t \\in \\{0, \\dots, T\\}} D_t$. If all states are zero, $D=0$.\n-   **Propagation Speed ($V$)**: Defined as $V=D/T$ for $T>0$ and $V=0$ for $T=0$.\n\nThe implementation will consist of a primary simulation function that takes all parameters, executes the evolution, and calculates the metrics. This function will be called for each of the six test cases specified. The results will be aggregated and printed in the required format. The use of NumPy arrays for state vectors will provide an efficient implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(R, N, T, bc_type, ic_type, bL=0, bR=0):\n    \"\"\"\n    Runs a 1D Elementary Cellular Automaton simulation and computes metrics.\n    \n    Args:\n        R (int): Wolfram rule number (0-255).\n        N (int): Lattice size.\n        T (int): Time horizon.\n        bc_type (str): Boundary condition type ('periodic', 'fixed', 'absorbing').\n        ic_type (str): Initial condition type ('single_seed', 'zero_state').\n        bL (int): Fixed value for the left ghost cell.\n        bR (int): Fixed value for the right ghost cell.\n        \n    Returns:\n        tuple[int, int, float]: A tuple containing (P, D, V).\n    \"\"\"\n\n    # 1. Initialize the automaton\n    x0 = N // 2\n    \n    # Initial Condition\n    if ic_type == 'single_seed':\n        s = np.zeros(N, dtype=np.int8)\n        s[x0] = 1\n    elif ic_type == 'zero_state':\n        s = np.zeros(N, dtype=np.int8)\n    else:\n        raise ValueError(\"Invalid initial condition type\")\n        \n    history = [s.copy()]\n    \n    # Pre-compute the rule map from the rule number R\n    # rule_map[b] gives the output for neighborhood index b\n    rule_map = np.array([(R >> i)  1 for i in range(8)], dtype=np.int8)\n\n    # 2. Evolve the automaton for T steps\n    for t in range(T):\n        s_current = history[-1]\n        s_next = np.zeros(N, dtype=np.int8)\n        \n        for i in range(N):\n            # Determine neighborhood based on boundary conditions\n            if i == 0:\n                s_left = bL if bc_type in ['fixed', 'absorbing'] else s_current[N-1]\n            else:\n                s_left = s_current[i-1]\n            \n            s_center = s_current[i]\n            \n            if i == N - 1:\n                s_right = bR if bc_type in ['fixed', 'absorbing'] else s_current[0]\n            else:\n                s_right = s_current[i+1]\n            \n            # Calculate neighborhood index b\n            b = (s_left  2) | (s_center  1) | s_right\n            \n            # Apply the rule\n            s_next[i] = rule_map[b]\n\n        # Apply post-update rule for absorbing boundary conditions\n        if bc_type == 'absorbing':\n            s_next[0] = 0\n            s_next[N-1] = 0\n            \n        history.append(s_next)\n        \n    # 3. Compute Metrics\n    \n    # Pattern Persistence P\n    P = sum(1 for state in history if np.sum(state) > 0)\n    \n    # Propagation Distance D\n    max_d = 0\n    for t in range(T + 1):\n        state = history[t]\n        active_indices = np.where(state == 1)[0]\n        \n        if active_indices.size > 0:\n            if bc_type == 'periodic':\n                distances = np.minimum(np.abs(active_indices - x0), N - np.abs(active_indices - x0))\n            else: # fixed or absorbing\n                distances = np.abs(active_indices - x0)\n            \n            current_max_d = np.max(distances)\n            if current_max_d > max_d:\n                max_d = current_max_d\n    D = int(max_d)\n\n    # Propagation Speed V\n    V = D / T if T > 0 else 0.0\n    \n    return [P, D, V]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # The Wolfram rule R=170 is used in all cases.\n    R = 170\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: periodic boundary; N = 21, T = 7; single central seed.\n        {'N': 21, 'T': 7, 'bc_type': 'periodic', 'ic_type': 'single_seed'},\n        # Case 2: fixed boundary with bL=0, bR=0; N = 21, T = 7; single central seed.\n        {'N': 21, 'T': 7, 'bc_type': 'fixed', 'ic_type': 'single_seed', 'bL': 0, 'bR': 0},\n        # Case 3: absorbing boundary; N = 21, T = 7; single central seed.\n        {'N': 21, 'T': 7, 'bc_type': 'absorbing', 'ic_type': 'single_seed'},\n        # Case 4: fixed boundary with bL=0, bR=0; N = 21, T = 15; single central seed.\n        {'N': 21, 'T': 15, 'bc_type': 'fixed', 'ic_type': 'single_seed', 'bL': 0, 'bR': 0},\n        # Case 5: absorbing boundary; N = 21, T = 15; single central seed.\n        {'N': 21, 'T': 15, 'bc_type': 'absorbing', 'ic_type': 'single_seed'},\n        # Case 6: periodic boundary; N = 13, T = 9; zero state.\n        {'N': 13, 'T': 9, 'bc_type': 'periodic', 'ic_type': 'zero_state'},\n    ]\n\n    results = []\n    for params in test_cases:\n        p, d, v = run_simulation(R=R, **params)\n        # Format V to six decimal places for the output string\n        results.append(f\"[{p},{d},{v:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(results)}]]\")\n\nsolve()\n```"
        }
    ]
}