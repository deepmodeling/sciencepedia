{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在解决任何SPH（平滑粒子流体动力学）模拟中的一个基本步骤：校准平滑长度$h$。该参数通过控制粒子相互作用的尺度，在离散的粒子表示与连续的流体属性之间架起了一座桥梁。通过这项实践 ，您将从第一性原理出发，推导平滑长度$h$、目标邻居数$N_n$、粒子质量$m$以及流体密度$\\rho$之间的重要关系，从而掌握初始化SPH模型的关键技能。",
            "id": "3806998",
            "problem": "考虑一个在三维 (3D) 空间中，由光滑粒子流体动力学（SPH, Smoothed Particle Hydrodynamics）建模的均匀、不可压缩流体。该流体具有恒定的质量密度 $\\rho$，并被离散化为质量为 $m$ 的等质量粒子。SPH 核函数是径向对称的，并在 $|\\mathbf{r}| \\leq 2h$ 内具有紧支集，其中 $h$ 是光滑长度。在多尺度建模中，光滑长度 $h$ 通常被校准以在核函数支集内达到一个目标期望邻居数 $N_n$。假设粒子分布是统计上均匀的，并且期望邻居数定义为粒子数密度在核函数支集域上的积分。从第一性原理出发——即对于均匀粒子分布，数密度的定义为 $\\rho/m$，以及核函数在三维空间中支集域的几何测度——推导能实现目标邻居数 $N_n = 60$ 的光滑长度 $h$ 的闭式表达式。将您的最终结果表示为 $m$ 和 $\\rho$ 的符号函数。以米为单位表示光滑长度。无需进行四舍五入。",
            "solution": "用户要求在光滑粒子流体动力学 (SPH) 的背景下推导光滑长度 $h$。\n\n### 第 1 步：提取已知条件\n- 流体是均匀、不可压缩的，且处于三维空间中。\n- 质量密度为常数 $\\rho$。\n- 流体被离散化为质量为 $m$ 的等质量粒子。\n- SPH 核函数是径向对称的，并在半径 $2h$ 内具有紧支集，即对于 $|\\mathbf{r}| \\leq 2h$。\n- 粒子分布是统计上均匀的。\n- 数密度定义为 $\\rho/m$。\n- 期望邻居数 $N_n$ 是粒子数密度在核函数支集域上的积分。\n- 目标期望邻居数为 $N_n = 60$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题陈述在计算流体动力学原理，特别是 SPH 方法上具有科学依据。诸如“光滑长度”、“核函数支集”、“质量密度”和“数密度”等所有术语在该领域都是标准术语。这些量之间的关系是初始化 SPH 模拟的一个基本方面。该问题是适定的，提供了推导光滑长度 $h$ 的唯一符号表达式所需的所有必要信息——数密度的定义、核函数支集的几何形状以及目标邻居数。问题是客观的，没有歧义或矛盾。因此，该问题被认为是有效的。\n\n### 第 3 步：推导\n推导过程从所提供的定义开始。\n\n首先，我们确定粒子数密度，记为 $n$。对于一个由质量为 $m$ 的粒子组成的、具有均匀质量密度 $\\rho$ 的介质，单位体积内的粒子数量（数密度）由下式给出：\n$$n = \\frac{\\rho}{m}$$\n这一关系已在问题陈述中给出。\n\n接下来，我们确定核函数支集域的体积。问题指明核函数在 $|\\mathbf{r}| \\leq 2h$ 内具有紧支集。在三维空间中，这个区域是一个以原点为中心、半径为 $R = 2h$ 的球体。半径为 $R$ 的球体体积 $V$ 由以下公式给出：\n$$V = \\frac{4}{3}\\pi R^3$$\n将 $R = 2h$ 代入此公式，我们得到支集域的体积：\n$$V = \\frac{4}{3}\\pi (2h)^3 = \\frac{4}{3}\\pi (8h^3) = \\frac{32\\pi}{3}h^3$$\n\n问题将期望邻居数 $N_n$ 定义为粒子数密度在核函数支集域上的积分。由于假定粒子分布是统计上均匀的，因此数密度 $n$ 在整个体积 $V$ 中是恒定的。因此，积分简化为恒定的数密度与粒子邻域体积的乘积：\n$$N_n = \\int_V n \\, dV = n \\int_V dV = nV$$\n\n现在，我们将 $n$ 和 $V$ 的表达式代入此方程：\n$$N_n = \\left(\\frac{\\rho}{m}\\right) \\left(\\frac{32\\pi}{3}h^3\\right)$$\n这个方程将邻居数 $N_n$ 与光滑长度 $h$ 以及物理参数 $m$ 和 $\\rho$ 联系起来。我们的目标是求解 $h$。\n$$N_n = \\frac{32\\pi\\rho}{3m} h^3$$\n\n为了求出 $h$，我们重新整理方程：\n$$h^3 = N_n \\frac{3m}{32\\pi\\rho}$$\n$$h = \\left(\\frac{3m N_n}{32\\pi\\rho}\\right)^{1/3}$$\n\n问题指定了目标邻居数为 $N_n = 60$。我们将这个值代入 $h$ 的表达式中：\n$$h = \\left(\\frac{3m(60)}{32\\pi\\rho}\\right)^{1/3} = \\left(\\frac{180m}{32\\pi\\rho}\\right)^{1/3}$$\n\n最后，我们简化数值分数 $\\frac{180}{32}$。分子和分母都可以被 $4$ 整除：\n$$\\frac{180}{32} = \\frac{180 \\div 4}{32 \\div 4} = \\frac{45}{8}$$\n\n将这个简化后的分数代回 $h$ 的表达式中，我们得到最终的闭式表达式：\n$$h = \\left(\\frac{45m}{8\\pi\\rho}\\right)^{1/3}$$\n该表达式给出了在均匀三维 SPH 粒子分布中，为达到 60 的期望邻居数所需的光滑长度 $h$，它是粒子质量 $m$ 和流体密度 $\\rho$ 的函数。",
            "answer": "$$\\boxed{\\left(\\frac{45m}{8\\pi\\rho}\\right)^{1/3}}$$"
        },
        {
            "introduction": "SPH作为一种插值方法的精度高度依赖于粒子的空间分布。这个动手编程练习  让您能够定量地研究均匀流体中基本SPH密度求和的误差。通过比较高度有序的粒子晶格与无序的“玻璃态”排列，您将对SPH求和误差的本质获得实践性的理解，并明白为何一定程度的无序排列通常有利于提高计算精度。",
            "id": "2439536",
            "problem": "要求您定量评估粒子无序度对二维空间中均匀、可压缩流体的平滑粒子流体动力学（SPH）密度估计精度的影响。考虑一种流体，其占据一个边长为 $L=1$、面积为 $A=L^2=1$ 的周期性单位正方形区域。该流体具有以无量纲单位表示的恒定表面密度 $\\rho_0=1$。该区域分布着 $N$ 个等质量粒子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，总质量为 $M=\\rho_0 A=1$，因此每个粒子的质量为 $m=M/N=1/N$。\n\n对于任意粒子 $i$，其 SPH 密度估计定义为\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\n其中 $\\|\\cdot\\|_\\mathrm{per}$ 表示单位环面上的最小镜像周期距离，$W(r,h)$ 是二维空间中标准的 SPH 三次样条核函数，其紧支集为 $2h$，平滑长度为 $h$。平滑长度必须选择为\n$$\nh = \\eta \\,\\Delta, \\quad \\text{with} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\n其中 $\\eta=1.2$ 为一个固定常数。\n\n对于每个指定的 $N$ 值，必须考虑两种不同的粒子排列方式：\n\n- 晶格排列：在具有周期性边界的单位正方形内，粒子放置在大小为 $\\sqrt{N}\\times\\sqrt{N}$ 的规则正方形晶格上。\n- 类玻璃体排列：粒子放置在基数为 2 和 3 的二维 Halton 序列的前 $N$ 个点上，即对于 $k=1,2,\\ldots,N$，其位置为 $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$，其中 $\\phi_b(k)$ 是基数为 $b$ 的根倒数函数。\n\n对于每种排列方式和每个 $N$ 值，计算以下无量纲误差度量，以比较 SPH 密度估计值 $\\{\\rho_i\\}$ 与精确的均匀密度 $\\rho_0$：\n- 平均绝对相对误差，\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- 均方根相对误差，\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- 最大相对误差，\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\n在整个计算过程中严格使用无量纲单位，并将所有误差值表示为小数值（而非百分比）。对于每个误差度量，将结果四舍五入到六位小数。\n\n测试套件：\n对以下有序的测试用例列表评估三元组 $\\big[E_1,E_2,E_\\infty\\big]$，其中每个用例指定一个配对 $(N,\\text{排列方式})$：\n- $(N=\\;100,\\;\\text{晶格})$\n- $(N=\\;100,\\;\\text{类玻璃体})$\n- $(N=\\;256,\\;\\text{晶格})$\n- $(N=\\;256,\\;\\text{类玻璃体})$\n- $(N=\\;441,\\;\\text{晶格})$\n- $(N=\\;441,\\;\\text{类玻璃体})$\n\n在所有核函数评估中，对所有两两间距采用单位正方环面上的最小镜像周期距离。对于晶格排列中的每个 $N$，假设 $N$ 是一个完全平方数，以便晶格为 $\\sqrt{N}\\times\\sqrt{N}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果。每个内部列表按指定顺序对应一个测试用例，并包含按 $\\big[E_1,E_2,E_\\infty\\big]$ 顺序排列的三个四舍五入后的误差值。例如：\n\"[ [e11,e12,e13],[e21,e22,e23],... ]\"\n确保数值四舍五入到六位小数，并且除了这一行之外没有任何附加文本。在所有计算和输出中使用无量纲单位。",
            "solution": "问题陈述已经过验证，并被确定为科学上合理、良定且完整。它构成了计算物理学领域评估平滑粒子流体动力学（SPH）方法精度的一个标准数值实验。任务是计算二维粒子分布的密度误差。将采用如下的直接计算方法。\n\nSPH 方法的核心是通过对一组离散粒子进行求和来表示连续场 $A(\\mathbf{r})$。对于密度场 $\\rho$，这表示为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{j} m_j W\\left(\\left\\|\\mathbf{r} - \\mathbf{r}_j\\right\\|,\\, h\\right)\n$$\n其中 $m_j$ 和 $\\mathbf{r}_j$ 分别是粒子 $j$ 的质量和位置，$W$ 是一个平滑核函数，其特征宽度为 $h$，即平滑长度。问题将位于位置 $\\mathbf{r}_i$ 的粒子 $i$ 的 SPH 密度估计指定为：\n$$\n\\rho_i = \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right)\n$$\n区域是一个二维单位正方形，具有周期性边界条件，面积 $A=1$，总质量 $M=1$。流体具有恒定的参考表面密度 $\\rho_0=1$。因此，对于 $N$ 个粒子，每个粒子的质量为 $m = M/N = 1/N$。距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$ 是单位环面上的最小镜像距离，对于位移矢量 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y)$，其计算方式为 $\\sqrt{(\\Delta x - \\text{round}(\\Delta x))^2 + (\\Delta y - \\text{round}(\\Delta y))^2}$。\n\n平滑长度 $h$ 与平均粒子间距 $\\Delta$ 相关。对于一个面积为 $A=1$、包含 $N$ 个粒子的二维区域，平均间距为 $\\Delta = \\sqrt{A/N} = 1/\\sqrt{N}$。平滑长度设置为 $h = \\eta \\Delta$，其中常数 $\\eta = 1.2$。\n\n核函数 $W(r, h)$ 是二维标准三次样条函数，仅在 $r \\le 2h$ 时非零。其解析形式为：\n$$\nW(r,h) = \\frac{10}{7\\pi h^2} \\times \\begin{cases} 1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3  0 \\le q \\le 1 \\\\ \\frac{1}{4}(2-q)^3  1  q \\le 2 \\\\ 0  q > 2 \\end{cases}\n$$\n其中 $q = r/h$ 是归一化距离。\n\n该分析需要两种粒子构型：\n1.  **晶格排列**：粒子被放置在均匀的 $\\sqrt{N} \\times \\sqrt{N}$ 网格上。对于 $i,j \\in \\{0, 1, \\dots, \\sqrt{N}-1\\}$，粒子 $(i,j)$ 的坐标取为 $(\\frac{i+0.5}{\\sqrt{N}}, \\frac{j+0.5}{\\sqrt{N}})$。这确保了晶格在单位区域内居中。\n2.  **类玻璃体排列**：粒子被放置在基数为 2 和 3 的二维 Halton 序列的前 $N$ 个点上。第 $k$ 个粒子（$k=1, \\dots, N$）的位置是 $\\mathbf{r}_k = (\\phi_2(k), \\phi_3(k))$，其中 $\\phi_b(k)$ 是基数为 $b$ 的根倒数函数。\n\n对于每种构型和指定的 $N$ 值，使用三种误差度量将 SPH 估计的密度 $\\{\\rho_i\\}_{i=1}^N$ 与精确密度 $\\rho_0=1$ 进行比较：\n-   平均绝对相对误差：$E_1 = \\frac{1}{N}\\sum_{i=1}^N |\\rho_i-1|$\n-   均方根相对误差：$E_2 = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (\\rho_i-1)^2}$\n-   最大相对误差：$E_\\infty = \\max_{1\\le i\\le N} |\\rho_i-1|$\n\n计算步骤如下：\n1.  对于由 $(N, \\text{排列方式})$ 指定的每个测试用例，生成粒子位置 $\\{\\mathbf{r}_i\\}$。\n2.  对于所有 $i,j \\in \\{1, \\dots, N\\}$，计算两两周期距离矩阵 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$。为提高效率，此计算被矢量化。\n3.  对所有粒子对评估核函数 $W(d_{ij}, h)$，创建一个核函数值矩阵。\n4.  通过对核函数矩阵的第 $i$ 行求和，并乘以粒子质量 $m=1/N$，来计算每个粒子 $\\rho_i$ 的密度。\n5.  从计算出的密度矢量中计算误差度量 $E_1, E_2, E_\\infty$。\n6.  按要求将最终误差值四舍五入到六位小数。\n\n整个过程使用 `numpy` 库在 Python 中实现，以高效地处理数组操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k > 0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q > 1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值模拟有时会表现出非物理的人为现象，理解这些现象是进行稳健建模的关键。本实践  深入探讨了SPH中经典的“配对不稳定性”，在这种不稳定性中，处于张力下的粒子（尤其是在规则网格上）会形成非物理的配对。您将通过编程实现一个定量指标来诊断这种不稳定性，并亲身体验如何通过引入粒子位置的轻微随机性或选择更稳定的平滑核函数来抑制它。",
            "id": "2439482",
            "problem": "您需要形式化并计算平滑粒子流体动力学 (SPH) 中配对不稳定性的一个定量指标，并演示随机初始粒子位置如何抑制这种不稳定性。考虑一个长度为 $L$ 的一维周期性域，其中包含 $N$ 个相同质量为 $m$ 的粒子，其位置为 $x_i \\in [0,L)$，$i \\in \\{0,1,\\dots,N-1\\}$。距离使用环上的最小镜像约定来测量，即对于任意粒子对 $(i,j)$，有符号间距为 $s_{ij} = x_i - x_j - L \\,\\mathrm{round}((x_i - x_j)/L)$，标量粒子间距为 $r_{ij} = |s_{ij}|$。\n\n将粒子 $i$ 处的 SPH 密度定义为\n$$\n\\rho_i = \\sum_{j=0}^{N-1} m \\, W(r_{ij}, h),\n$$\n其中 $W(r,h)$ 是一个具有平滑长度 $h0$ 的紧支集核函数。设压力在空间上均匀且恒定，其值为 $P_0  0$（张力）。粒子 $i$ 处的 SPH 压力梯度加速度定义为\n$$\na_i(\\mathbf{x}) = -\\sum_{\\substack{j=0\\\\ j\\neq i}}^{N-1} m \\left(\\frac{P_0}{\\rho_i^2} + \\frac{P_0}{\\rho_j^2}\\right) \\frac{\\partial}{\\partial x_i} W(r_{ij}, h),\n$$\n其中 $\\mathbf{x} = (x_0,\\dots,x_{N-1})$ 且 $\\frac{\\partial}{\\partial x_i} W(r_{ij}, h) = \\frac{\\mathrm{d}W}{\\mathrm{d}r}(r_{ij}, h)\\, \\mathrm{sign}(s_{ij})$，约定 $\\mathrm{sign}(0)=0$。\n\n对于给定的粒子构型 $\\mathbf{x}$，将加速度场的雅可比矩阵 $J(\\mathbf{x})$ 定义为其元素 $J_{ik}(\\mathbf{x}) = \\frac{\\partial a_i}{\\partial x_k}(\\mathbf{x})$。考虑分量为 $u_i = (-1)^i$ 的交替配对模态向量 $\\mathbf{u}\\in \\mathbb{R}^N$。配对增长指标是瑞利商\n$$\n\\lambda(\\mathbf{x}) = \\frac{\\mathbf{u}^\\top J(\\mathbf{x}) \\,\\mathbf{u}}{\\mathbf{u}^\\top \\mathbf{u}}。\n$$\n$\\lambda(\\mathbf{x})$ 的正值表示交替模态呈指数增长（配对不稳定性），而负值表示恢复响应（配对被抑制）。对于此任务，您必须在指定的构型和核函数下评估 $\\lambda(\\mathbf{x})$。\n\n使用以下在支撑域 $r \\in [0, 2h)$ 内的一维核函数：\n\n- 一维三次样条 (Monaghan–Lattanzio $M4$)：\n$$ W(r,h) = \\frac{\\alpha_1}{h} \\, f(q), \\quad q=\\frac{r}{h}, \\quad \\alpha_1=\\frac{2}{3}, $$\n其中\n$$\nf(q) = \n\\begin{cases}\n1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q  1, \\\\\n\\frac{1}{4}(2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n以及\n$$\n\\frac{\\mathrm{d}W}{\\mathrm{d}r}(r,h) = \\frac{\\alpha_1}{h^2} \\, f'(q), \\quad\nf'(q) =\n\\begin{cases}\n-3 q + \\frac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\frac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n\n- 一维 Wendland $C^2$ 核函数：\n$$ W(r,h) = \\frac{\\beta_1}{h} \\, g(q), \\quad q=\\frac{r}{h}, \\quad \\beta_1=\\frac{5}{8}, $$\n其中\n$$\ng(q) =\n\\begin{cases}\n\\left(1 - \\frac{q}{2}\\right)^4 (1 + 2q),  0 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n以及\n$$\n\\frac{\\mathrm{d}W}{\\mathrm{d}r}(r,h) = \\frac{\\beta_1}{h^2} \\, g'(q), \\quad\ng'(q) = -2\\left(1 - \\frac{q}{2}\\right)^3 (1 + 2q) + 2\\left(1 - \\frac{q}{2}\\right)^4, \\quad 0 \\le q  2,\n$$\n且对于 $q \\ge 2$，$g'(q)=0$。\n\n所有量都是无量纲的；您必须将最终输出报告为不带单位的实数。\n\n测试套件。设 $N = 64$，$L = 1$，$m = 1$，$h = \\eta \\Delta$，其中 $\\Delta = L/N$ 且 $\\eta = 1.2$。设恒定压力为 $P_0 = -1$。考虑以下三种 $\\mathbf{x}$ 的构型：\n\n- 情况 A（规则格点，三次样条）：$x_i = i \\Delta$，$i \\in \\{0,\\dots,N-1\\}$，核函数为如上定义的三次样条。\n\n- 情况 B（随机抖动，三次样条）：$x_i = \\mathrm{mod}\\!\\left(i \\Delta + \\xi_i, L\\right)$，其中 $\\xi_i$ 是从区间 $\\left[-\\alpha \\Delta, \\alpha \\Delta\\right]$（$\\alpha = 0.25$）中均匀抽取的独立随机数，使用固定的伪随机数生成器种子 $12345$ 以确保结果是确定性的，核函数为如上定义的三次样条。\n\n- 情况 C（规则格点，Wendland $C^2$）：$x_i = i \\Delta$，$i \\in \\{0,\\dots,N-1\\}$，核函数为如上定义的 Wendland $C^2$。\n\n您的任务是编写一个完整的程序，计算上述三种情况下各自的 $\\lambda(\\mathbf{x})$。由于 $J(\\mathbf{x})$ 是通过加速度对位置的导数定义的，您必须确定一种数值上一致的方法，来评估在每个指定构型下 $J(\\mathbf{x})$ 对向量 $\\mathbf{u}$ 的作用，并由此根据瑞利商的定义计算标量 $\\lambda(\\mathbf{x})$。使用交替模态分量 $u_i = (-1)^i$，$i \\in \\{0,\\dots,N-1\\}$。确保您选择的任何数值离散化都遵循周期性域和上述核函数定义。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\lambda(\\text{情况 A}), \\lambda(\\text{情况 B}), \\lambda(\\text{情况 C})]$。将每个结果表示为十进制实数。为保证可复现性，如果您使用任何伪随机数，请使用上面指定的种子值 $12345$ 初始化生成器。最终答案不需要物理单位。",
            "solution": "问题陈述经审查后确认有效。这是一个计算物理学中适定（well-posed）的问题，提供了所有必要的定义、参数和明确的目标。它没有科学上的不准确、矛盾或含糊之处。任务是通过一个指定的定量指标来分析平滑粒子流体动力学（SPH）中的配对不稳定性，这是该领域的标准程序。\n\n核心任务是计算配对增长指标 $\\lambda(\\mathbf{x})$，其定义为瑞利商：\n$$\n\\lambda(\\mathbf{x}) = \\frac{\\mathbf{u}^\\top J(\\mathbf{x}) \\,\\mathbf{u}}{\\mathbf{u}^\\top \\mathbf{u}}\n$$\n此处，$\\mathbf{x} = (x_0, \\dots, x_{N-1})$ 是粒子位置向量，$\\mathbf{u}$ 是交替配对模态向量，其分量为 $u_i = (-1)^i$，$J(\\mathbf{x})$ 是加速度场的雅可比矩阵，$J_{ik} = \\partial a_i / \\partial x_k$。分母就是 $\\mathbf{u}^\\top \\mathbf{u} = \\sum_{i=0}^{N-1} ((-1)^i)^2 = N$。\n\n对 $N \\times N$ 的雅可比矩阵 $J(\\mathbf{x})$ 进行直接的解析推导和实现将会极其复杂且计算效率低下。一种更优越且在数值上标准的方法是，在不显式构造 $J(\\mathbf{x})$ 的情况下，计算雅可比矩阵对向量 $\\mathbf{u}$ 的作用，即矩阵-向量乘积 $J(\\mathbf{x})\\mathbf{u}$。\n\n乘积 $(J\\mathbf{u})_i = \\sum_{k=0}^{N-1} J_{ik} u_k = \\sum_{k=0}^{N-1} \\frac{\\partial a_i}{\\partial x_k} u_k$ 表示加速度场 $\\mathbf{a}(\\mathbf{x})$ 的第 $i$ 个分量在向量 $\\mathbf{u}$ 方向上的方向导数。这可以用有限差分格式进行数值逼近。我们采用二阶中心差分以获得更高的精度：\n$$\nJ(\\mathbf{x})\\mathbf{u} \\approx \\frac{\\mathbf{a}(\\mathbf{x} + \\epsilon \\mathbf{u}) - \\mathbf{a}(\\mathbf{x} - \\epsilon \\mathbf{u})}{2\\epsilon}\n$$\n其中 $\\epsilon$ 是一个小的标量微扰步长。选择 $\\epsilon = 10^{-7}$，这个值足够小，可以确保对导数的良好逼近，同时又足够大，可以避免因浮点数算术精度限制而引起的灾难性抵消。\n\n因此，对于给定的构型 $\\mathbf{x}$，计算 $\\lambda(\\mathbf{x})$ 的过程如下：\n1. 构造微扰后的位置向量 $\\mathbf{x}^+ = \\mathbf{x} + \\epsilon \\mathbf{u}$ 和 $\\mathbf{x}^- = \\mathbf{x} - \\epsilon \\mathbf{u}$。\n2. 计算加速度向量 $\\mathbf{a}^+ = \\mathbf{a}(\\mathbf{x}^+)$ 和 $\\mathbf{a}^- = \\mathbf{a}(\\mathbf{x}^-)$。\n3. 计算雅可比-向量乘积的数值逼近 $\\mathbf{v} = (\\mathbf{a}^+ - \\mathbf{a}^-) / (2\\epsilon)$。\n4. 计算瑞利商 $\\lambda(\\mathbf{x}) = (\\mathbf{u}^\\top \\mathbf{v}) / N$。\n\n对于任意位置向量 $\\mathbf{x}$，计算加速度向量 $\\mathbf{a}(\\mathbf{x})$ 是核心计算步骤。它需要：\na. 使用公式 $\\rho_i = \\sum_{j} m W(r_{ij}, h)$ 计算每个粒子 $i$ 的 SPH 密度 $\\rho_i$。\nb. 使用公式 $a_i = -\\sum_{j \\neq i} m (P_0/\\rho_i^2 + P_0/\\rho_j^2) \\frac{\\partial W}{\\partial x_i}(r_{ij}, h)$ 计算每个粒子 $i$ 的 SPH 加速度 $a_i$。\n\n所有成对的粒子相互作用都使用长度为 $L$ 的周期性域的最小镜像约定来处理。为提高效率，密度和加速度的计算使用 NumPy 进行矢量化，避免在 Python 中使用显式循环。这涉及构建成对间距 $s_{ij}$、距离 $r_{ij}$ 和核函数值的 $N \\times N$ 矩阵。\n\n这三个测试案例旨在说明配对不稳定性的性质：\n- **情况 A**：使用三次样条核函数的规则格点。已知这种构型在张力（$P_0  0$）下是数值不稳定的，我们预期 $\\lambda  0$，表示配对模态的指数增长。\n- **情况 B**：使用三次样条核函数的随机扰动格点。引入的无序性预计会破坏不稳定模态的相干性，从而抑制不稳定性。我们预期 $\\lambda$ 会显著减小，理想情况下变为负值。\n- **情况 C**：使用 Wendland $C^2$ 核函数的规则格点。这种核函数被设计为具有更优的稳定性。我们预期即使在规则格点上，它也能防止不稳定性，从而导致 $\\lambda  0$。\n\n实现将遵循这一经过验证的数值策略，为三种指定情况分别计算 $\\lambda$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef W_cubic(r, h):\n    \"\"\"\n    Computes the 1D cubic spline kernel value.\n    \"\"\"\n    alpha1 = 2.0 / 3.0\n    q = r / h\n    vals = np.zeros_like(q)\n    \n    mask1 = (q = 0)  (q  1)\n    q1 = q[mask1]\n    vals[mask1] = 1.0 - 1.5 * q1**2 + 0.75 * q1**3\n    \n    mask2 = (q = 1)  (q  2)\n    q2 = q[mask2]\n    vals[mask2] = 0.25 * (2.0 - q2)**3\n    \n    return (alpha1 / h) * vals\n\ndef dWdr_cubic(r, h):\n    \"\"\"\n    Computes the derivative of the 1D cubic spline kernel with respect to r.\n    \"\"\"\n    alpha1 = 2.0 / 3.0\n    q = r / h\n    vals = np.zeros_like(q)\n    \n    mask1 = (q = 0)  (q  1)\n    q1 = q[mask1]\n    vals[mask1] = -3.0 * q1 + (9.0 / 4.0) * q1**2\n    \n    mask2 = (q = 1)  (q  2)\n    q2 = q[mask2]\n    vals[mask2] = -0.75 * (2.0 - q2)**2\n    \n    return (alpha1 / h**2) * vals\n\ndef W_wendland(r, h):\n    \"\"\"\n    Computes the 1D C2 Wendland kernel value.\n    \"\"\"\n    beta1 = 5.0 / 8.0\n    q = r / h\n    vals = np.zeros_like(q)\n    mask = (q = 0)  (q  2)\n    q_masked = q[mask]\n    vals[mask] = (1.0 - q_masked / 2.0)**4 * (1.0 + 2.0 * q_masked)\n    return (beta1 / h) * vals\n\ndef dWdr_wendland(r, h):\n    \"\"\"\n    Computes the derivative of the 1D C2 Wendland kernel with respect to r.\n    \"\"\"\n    beta1 = 5.0 / 8.0\n    q = r / h\n    vals = np.zeros_like(q)\n    mask = (q = 0)  (q  2)\n    q_masked = q[mask]\n    term1 = 1.0 - q_masked / 2.0\n    vals[mask] = -2.0 * term1**3 * (1.0 + 2.0 * q_masked) + 2.0 * term1**4\n    return (beta1 / h**2) * vals\n\ndef calculate_acceleration(x, m, L, h, P0, kernel_W, kernel_dWdr):\n    \"\"\"\n    Calculates the SPH acceleration for a given particle configuration.\n    \"\"\"\n    N = len(x)\n    \n    x_col = x.reshape(N, 1)\n    dx_matrix = x_col - x\n    s_matrix = dx_matrix - L * np.round(dx_matrix / L)\n    r_matrix = np.abs(s_matrix)\n    \n    W_matrix = kernel_W(r_matrix, h)\n    rho = m * np.sum(W_matrix, axis=1)\n    \n    dWdr_matrix = kernel_dWdr(r_matrix, h)\n    sign_s_matrix = np.sign(s_matrix)\n    dW_dx_matrix = dWdr_matrix * sign_s_matrix\n    \n    rho_sq_inv_col = (1.0 / rho**2).reshape(N, 1)\n    pressure_term_matrix = P0 * (rho_sq_inv_col + rho_sq_inv_col.T)\n    \n    summand_matrix = m * pressure_term_matrix * dW_dx_matrix\n    np.fill_diagonal(summand_matrix, 0.0)\n    \n    acc = -np.sum(summand_matrix, axis=1)\n    return acc\n\ndef compute_lambda(x, u, m, L, h, P0, kernel_W, kernel_dWdr):\n    \"\"\"\n    Computes the pairing growth indicator lambda using finite differences.\n    \"\"\"\n    N = len(x)\n    eps = 1e-7  # Finite difference step\n    \n    x_plus = x + eps * u\n    x_minus = x - eps * u\n    \n    acc_plus = calculate_acceleration(x_plus, m, L, h, P0, kernel_W, kernel_dWdr)\n    acc_minus = calculate_acceleration(x_minus, m, L, h, P0, kernel_W, kernel_dWdr)\n    \n    # Jacobian-vector product J*u\n    v = (acc_plus - acc_minus) / (2.0 * eps)\n    \n    # Rayleigh quotient\n    lambda_val = np.dot(u, v) / N\n    return lambda_val\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1),\n        # (Parameter set 2),\n        # ...\n    ]\n    \n    # Problem parameters\n    N = 64\n    L = 1.0\n    m = 1.0\n    P0 = -1.0\n    eta = 1.2\n    alpha = 0.25\n    seed = 12345\n    \n    Delta = L / N\n    h = eta * Delta\n    \n    # Alternating pairing mode vector\n    u = np.power(-1.0, np.arange(N))\n    \n    # Case A: Regular lattice, cubic spline\n    x_A = np.arange(N) * Delta\n    \n    # Case B: Random jitter, cubic spline\n    rng = np.random.default_rng(seed)\n    xi = rng.uniform(-alpha * Delta, alpha * Delta, size=N)\n    x_B = np.mod(np.arange(N) * Delta + xi, L)\n    \n    # Case C: Regular lattice, Wendland C2\n    x_C = np.arange(N) * Delta\n\n    kernels_cubic = (W_cubic, dWdr_cubic)\n    kernels_wendland = (W_wendland, dWdr_wendland)\n\n    case_definitions = [\n        (x_A, kernels_cubic),\n        (x_B, kernels_cubic),\n        (x_C, kernels_wendland),\n    ]\n\n    results = []\n    for x, (kernel_W, kernel_dWdr) in case_definitions:\n        lambda_val = compute_lambda(x, u, m, L, h, P0, kernel_W, kernel_dWdr)\n        results.append(lambda_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}