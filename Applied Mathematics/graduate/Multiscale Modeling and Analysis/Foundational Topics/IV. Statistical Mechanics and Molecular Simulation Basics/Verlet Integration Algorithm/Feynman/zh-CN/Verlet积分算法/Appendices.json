{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在建立对Verlet算法的基础理解。您将直接从泰勒级数展开推导出两种常见的变体——速度Verlet和位置Verlet算法，并加以实现，同时比较它们的计算成本。这项实践旨在巩固算法的数学形式与其在中的实际实现之间的联系。",
            "id": "3831352",
            "problem": "您正在对一个在一维空间中、在保守力作用下演化的单个经典粒子进行建模。其基本依据是牛顿第二定律和运动学定义：一个质量为 $m$ 的粒子遵循 $m \\, \\ddot{x}(t) = f(x(t))$，其中 $x(t)$ 是位置，$\\dot{x}(t)$ 是速度，$\\ddot{x}(t)$ 是加速度，$f(x)$ 是作为位置函数的力（单位为牛顿）。速度由 $\\dot{x}(t) = v(t)$ 定义，加速度由 $\\ddot{x}(t) = a(t)$ 定义。您将设计一个步长为 $h$ 秒的离散时间更新算法，该算法将时间 $t_n$ 的状态 $(x_n, v_n)$ 映射到时间 $t_{n+1} = t_n + h$ 的状态 $(x_{n+1}, v_{n+1})$。\n\n任务：\n1. 从所述基本依据出发，推导一个二阶精度的辛算法，该算法仅使用在位置 $x_n$ 和 $x_{n+1}$ 处形式为 $f(x)$ 的力求值来更新 $(x_n, v_n)$。然后为单个粒子实现该算法的一个步长。\n2. 同时推导一个二阶精度的纯位置算法，该算法使用 $x_n$、$x_{n-1}$ 和在 $x_n$ 处的单次力求值来更新 $x_{n+1}$。由于给定的是 $(x_n, v_n)$ 而不是 $x_{n-1}$，您必须通过一个使用 $v_n$ 和在 $x_n$ 处的加速度的二阶相容后向展开来近似 $x_{n-1}$。实现该算法的一个步长以计算 $x_{n+1}$。\n3. 对每种算法，将计算成本定义为生成下一个状态所需的力函数 $f(x)$ 的调用次数。通过报告每一步中对 $f(x)$ 的调用次数，比较速度更新算法与纯位置算法的每步计算成本。\n\n实现要求：\n- 加速度为 $a(x) = f(x)/m$，其中 $m$ 的单位是千克。\n- 您的程序必须实现两种单步更新方法：\n  - 一种速度更新方法，从 $(x_n, v_n)$ 生成 $(x_{n+1}, v_{n+1})$。\n  - 一种纯位置方法，通过对 $x_{n-1}$ 的二阶相容近似，从 $(x_n, v_n)$ 生成 $x_{n+1}$。\n- 您必须以数值方式计算每种方法每步对 $f(x)$ 的调用次数。\n\n测试套件：\n针对以下测试用例实现上述要求。所有量都必须使用国际单位制 (SI)。位置单位为米，速度单位为米/秒，时间步长单位为秒，质量单位为千克，力单位为牛顿。\n- 情况 A（理想路径，线性恢复力）：$m = 1.0$，$h = 0.01$，$x_n = 1.0$，$v_n = 0.0$，$f(x) = -k x$，$k = 4.0$。\n- 情况 B（非线性双势阱，中等步长）：$m = 2.0$，$h = 0.05$，$x_n = 0.5$，$v_n = 0.1$，$f(x) = -a x^3 + b x$，$a = 10.0$，$b = 2.0$。\n- 情况 C（氩的刚性短程 Lennard-Jones 势，小步长）：$m = 6.63 \\times 10^{-26}$，$h = 1.0 \\times 10^{-14}$，$x_n = 4.0 \\times 10^{-10}$，$v_n = 0.0$，$f(x) = -\\frac{d}{dx} \\left( 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{x}\\right)^{12} - \\left(\\frac{\\sigma}{x}\\right)^6 \\right] \\right)$，其中 $\\epsilon = 1.65 \\times 10^{-21}$ 且 $\\sigma = 3.4 \\times 10^{-10}$。\n- 情况 D（边界情况，零力）：$m = 1.0$，$h = 0.1$，$x_n = 2.0$，$v_n = -0.3$，$f(x) = 0$。\n\n要求输出：\n- 对每个测试用例，执行恰好一步速度更新算法以获得 $(x_{n+1}, v_{n+1})$，并计算所用力求值的次数 $N_{\\mathrm{vel}}$。\n- 对相同的测试用例，执行恰好一步纯位置算法（使用从 $(x_n, v_n)$ 推导出的二阶相容 $x_{n-1}$ 近似）以获得 $x_{n+1}$，并计算所用力求值的次数 $N_{\\mathrm{pos}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是 $[x_{n+1}^{\\mathrm{vel}}, v_{n+1}^{\\mathrm{vel}}, x_{n+1}^{\\mathrm{pos}}, N_{\\mathrm{vel}}, N_{\\mathrm{pos}}]$ 形式的列表，其中位置单位为米，速度单位为米/秒（两者均为浮点数），$N_{\\mathrm{vel}}$ 和 $N_{\\mathrm{pos}}$ 为整数。例如，总输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "问题要求为一维经典粒子推导并实现两种离散时间积分算法。该粒子遵循牛顿第二定律 $m \\ddot{x}(t) = f(x(t))$，其中 $m$ 是质量，$x(t)$ 是位置，$f(x)$ 是一个保守力。加速度为 $a(t) = \\ddot{x}(t) = f(x(t))/m$。我们已知时间 $t_n$ 时的状态 $(x_n, v_n)$ 和时间步长 $h$，需要求解时间 $t_{n+1} = t_n + h$ 时的状态。\n\n### 第 1 部分：速度更新辛算法\n\n第一个任务是推导一个二阶精度的辛算法，该算法使用在位置 $x_n$ 和 $x_{n+1}$ 处的力求值将 $(x_n, v_n)$ 更新为 $(x_{n+1}, v_{n+1})$。满足这些标准的一个标准算法是**速度 Verlet 算法**。\n\n我们首先写出位置 $x(t_{n+1})$ 在时间 $t_n$ 附近的泰勒级数展开：\n$$x(t_n+h) = x(t_n) + h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + O(h^3)$$\n在离散表示法中，设 $x_n = x(t_n)$，$v_n = \\dot{x}(t_n)$ 和 $a_n = \\ddot{x}(t_n) = f(x_n)/m$，这成为位置更新规则：\n$$x_{n+1} = x_n + h v_n + \\frac{h^2}{2} a_n$$\n这个方程使用时间 $t_n$ 的可用信息来提供新位置 $x_{n+1}$。局部误差为 $O(h^3)$，导致全局误差为 $O(h^2)$，从而使该方法达到二阶精度。\n\n接下来，我们需要一个速度 $v_{n+1}$ 的更新规则。一个简单的前向欧拉步，$v_{n+1} = v_n + h a_n$，只有一阶精度。为了达到二阶精度，我们可以用端点 $a_n$ 和 $a_{n+1}$ 处加速度的平均值来近似区间 $[t_n, t_{n+1}]$ 上的加速度。\n$$v_{n+1} = v_n + h \\left( \\frac{a_n + a_{n+1}}{2} \\right) + O(h^3)$$\n这是速度更新的梯形法则。由于我们已经计算出 $x_{n+1}$，我们现在可以对这个新位置的力进行求值，以得到 $a_{n+1} = f(x_{n+1})/m$。\n\n完整的算法按以下步骤进行：\n1.  给定 $(x_n, v_n)$。\n2.  计算当前位置的加速度：$a_n = f(x_n)/m$。这是**第一次力求值**。\n3.  更新位置：$x_{n+1} = x_n + h v_n + \\frac{1}{2}h^2 a_n$。\n4.  计算新位置的加速度：$a_{n+1} = f(x_{n+1})/m$。这是**第二次力求值**。\n5.  更新速度：$v_{n+1} = v_n + \\frac{h}{2} (a_n + a_{n+1})$。\n\n该算法将 $(x_n, v_n)$ 更新为 $(x_{n+1}, v_{n+1})$，是二阶精度的、辛的（它保持相空间面积元 $dx \\wedge dv$），并使用在 $x_n$ 和 $x_{n+1}$ 处的力求值。每步的计算成本，定义为力求值的次数，是 $N_{\\mathrm{vel}} = 2$。\n\n### 第 2 部分：纯位置算法\n\n第二个任务是推导一个二阶精度的算法，该算法仅使用 $x_n$，$x_{n-1}$ 和在 $x_n$ 处的单次力求值来更新位置 $x_{n+1}$。这就是**位置 Verlet 算法**。我们从 $x(t)$ 在 $t_n$ 附近的两个泰勒展开式开始：\n$$x(t_n + h) = x(t_n) + h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + \\frac{h^3}{6} \\dddot{x}(t_n) + O(h^4)$$\n$$x(t_n - h) = x(t_n) - h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) - \\frac{h^3}{6} \\dddot{x}(t_n) + O(h^4)$$\n将这两个方程相加可以消去奇数次幂的导数项：\n$$x(t_n+h) + x(t_n-h) = 2 x(t_n) + h^2 \\ddot{x}(t_n) + O(h^4)$$\n在离散形式下，即为 $x_{n+1} + x_{n-1} = 2x_n + h^2 a_n$。重新整理后得到更新规则：\n$$x_{n+1} = 2x_n - x_{n-1} + h^2 a_n$$\n该算法是二阶精度的（局部截断误差为 $O(h^4)$），并且每步只需要一次力求值，$a_n = f(x_n)/m$。\n\n然而，问题指定初始状态以 $(x_n, v_n)$ 的形式给出，而不是 $(x_n, x_{n-1})$。因此，我们必须使用可用数据为前一个位置 $x_{n-1}$ 找到一个“二阶相容”的近似。我们使用 $x(t_n-h)$ 在 $t_n$ 附近的后向泰勒展开：\n$$x(t_n - h) = x(t_n) - h \\dot{x}(t_n) + \\frac{h^2}{2} \\ddot{x}(t_n) + O(h^3)$$\n在离散表示法中，这转化为对 $x_{n-1}$ 的近似：\n$$x_{n-1} \\approx x_n - h v_n + \\frac{h^2}{2} a_n$$\n这个近似是“二阶相容”的，因为它的误差是 $O(h^3)$，这足以保证单步的整体二阶精度不被降低。\n\n现在，我们将这个 $x_{n-1}$ 的表达式代入位置 Verlet 更新规则中：\n$$x_{n+1} = 2x_n - \\left(x_n - h v_n + \\frac{h^2}{2} a_n\\right) + h^2 a_n$$\n$$x_{n+1} = 2x_n - x_n + h v_n - \\frac{h^2}{2} a_n + h^2 a_n$$\n$$x_{n+1} = x_n + h v_n + \\frac{h^2}{2} a_n$$\n在给定的特定引导条件下，这是纯位置算法的最终更新规则。\n\n该算法按以下步骤进行：\n1.  给定 $(x_n, v_n)$。\n2.  计算当前位置的加速度：$a_n = f(x_n)/m$。这是**唯一的力求值**。\n3.  更新位置：$x_{n+1} = x_n + h v_n + \\frac{1}{2}h^2 a_n$。\n\n该算法生成 $x_{n+1}$，是二阶精度的，并且需要一次力求值。每步的计算成本是 $N_{\\mathrm{pos}} = 1$。\n\n### 第 3 部分：计算成本比较\n\n- 速度更新算法（速度 Verlet）每时间步需要**两次**力求值来计算 $(x_{n+1}, v_{n+1})$。\n- 纯位置算法（引导的位置 Verlet）每时间步需要**一次**力求值来计算 $x_{n+1}$。\n\n因此，速度更新算法的每步计算成本为 $N_{\\mathrm{vel}} = 2$，而纯位置算法的成本为 $N_{\\mathrm{pos}} = 1$。值得注意的是，在两种推导出的方法中，位置更新步骤是相同的。速度 Verlet 方法中额外的力调用是为了获得速度 $v_{n+1}$ 的二阶精度更新。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares two numerical integration algorithms\n    for a single particle in one dimension.\n    \"\"\"\n\n    def make_force_counter(f):\n        \"\"\"Wraps a force function to count its calls.\"\"\"\n        count = 0\n        def wrapped_f(x):\n            nonlocal count\n            count += 1\n            return f(x)\n        \n        def get_count():\n            return count\n        \n        def reset_count():\n            nonlocal count\n            count = 0\n        \n        return wrapped_f, get_count, reset_count\n\n    def velocity_update_step(m, h, xn, vn, f_counter_tuple):\n        \"\"\"\n        Performs one step of the Velocity Verlet algorithm.\n        Returns (x_{n+1}, v_{n+1}, num_force_calls).\n        \"\"\"\n        force_func, get_count, reset_count = f_counter_tuple\n        reset_count()\n        \n        # 1. Calculate acceleration at xn\n        an = force_func(xn) / m\n        \n        # 2. Update position\n        x_n_plus_1 = xn + h * vn + 0.5 * h**2 * an\n        \n        # 3. Calculate acceleration at x_{n+1}\n        a_n_plus_1 = force_func(x_n_plus_1) / m\n        \n        # 4. Update velocity\n        v_n_plus_1 = vn + 0.5 * h * (an + a_n_plus_1)\n        \n        n_vel = get_count()\n        \n        return x_n_plus_1, v_n_plus_1, n_vel\n\n    def position_only_step(m, h, xn, vn, f_counter_tuple):\n        \"\"\"\n        Performs one step of the bootstrapped Position Verlet algorithm.\n        Returns (x_{n+1}, num_force_calls).\n        \"\"\"\n        force_func, get_count, reset_count = f_counter_tuple\n        reset_count()\n        \n        # 1. Calculate acceleration at xn\n        an = force_func(xn) / m\n        \n        # 2. Update position (derived from substituting x_{n-1} approx)\n        x_n_plus_1 = xn + h * vn + 0.5 * h**2 * an\n        \n        n_pos = get_count()\n        \n        return x_n_plus_1, n_pos\n\n    test_cases = [\n        # Case A: Linear restoring force\n        {\n            \"m\": 1.0, \"h\": 0.01, \"xn\": 1.0, \"vn\": 0.0,\n            \"force_func\": lambda x: -4.0 * x\n        },\n        # Case B: Nonlinear double-well\n        {\n            \"m\": 2.0, \"h\": 0.05, \"xn\": 0.5, \"vn\": 0.1,\n            \"force_func\": lambda x: -10.0 * x**3 + 2.0 * x\n        },\n        # Case C: Lennard-Jones for Argon\n        {\n            \"m\": 6.63e-26, \"h\": 1.0e-14, \"xn\": 4.0e-10, \"vn\": 0.0,\n            \"force_func\": (lambda epsilon, sigma: \n                lambda x: (24 * epsilon / x) * (2 * (sigma / x)**12 - (sigma / x)**6)\n            )(1.65e-21, 3.4e-10)\n        },\n        # Case D: Zero force\n        {\n            \"m\": 1.0, \"h\": 0.1, \"xn\": 2.0, \"vn\": -0.3,\n            \"force_func\": lambda x: 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, xn, vn = case[\"m\"], case[\"h\"], case[\"xn\"], case[\"vn\"]\n        f_counter_tuple = make_force_counter(case[\"force_func\"])\n        \n        # Perform velocity-update step\n        x_vel, v_vel, N_vel = velocity_update_step(m, h, xn, vn, f_counter_tuple)\n\n        # Perform position-only step\n        x_pos, N_pos = position_only_step(m, h, xn, vn, f_counter_tuple)\n\n        # Collect results for the case\n        case_result = [x_vel, v_vel, x_pos, N_vel, N_pos]\n        results.append(case_result)\n\n    # The `str()` of a list formats it with brackets, which matches the requirement.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实现了算法之后，我们现在来探讨其最著名的特性：卓越的长期能量守恒性。通过将速度Verlet方法与标准的龙格-库塔（Runge-Kutta）积分器进行比较，本练习将展示辛几何性质的实际效果——Verlet算法产生的有界、振荡的能量误差，相对于非辛方法产生的系统性漂移。这个练习揭示了为何Verlet是长时间分子模拟的首选积分器。",
            "id": "3831336",
            "problem": "考虑一个由牛顿第二定律支配的一维谐振子，其位置 $x(t)$ 和速度 $v(t) = \\dot{x}(t)$ 根据 $m \\ddot{x}(t) = -k x(t)$ 演化，其中质量 $m$ 和劲度系数 $k$ 均为正值。其总能量（哈密顿量）为 $H(x,v) = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$，在精确的连续时间动力学中是一个守恒量。角频率为 $\\omega = \\sqrt{k/m}$，单位为弧度/秒。\n\n你的任务是设计并实现一个完整的、可运行的程序，使用从第一性原理推导出的三种不同时间步进方法对谐振子进行数值积分：\n- 速度 Verlet 算法，一种辛方法。\n- 显式二阶 Runge-Kutta 方法（中点法），简写为二阶 Runge-Kutta (RK2)。\n- 显式四阶 Runge-Kutta 方法，简写为四阶 Runge-Kutta (RK4)。\n\n仅从常微分方程 (ODE) $m \\ddot{x}(t) = -k x(t)$、其状态空间表述 $y(t) = (x(t), v(t))$、连续时间导数 $\\frac{d}{dt}$ 以及总能量 $H(x,v)$ 的基本定义出发，在不使用任何外部积分库的情况下实现这三种方法。每种方法都必须使用恒定的时间步长 $\\Delta t$ 向前推进，在演化 $(x,v)$ 的同时，在每个时间步计算能量 $H$。\n\n对于每种方法，通过计算以下两个指标来量化其长时间能量行为：\n1. 最终相对能量漂移 $\\delta_E = \\frac{H(T) - H(0)}{H(0)}$，以小数形式表示（无单位）。\n2. 轨迹上的最大绝对相对能量偏差 $\\Delta_E^{\\max} = \\max_{0 \\le t \\le T} \\frac{\\left|H(t) - H(0)\\right|}{H(0)}$，以小数形式表示（无单位）。\n\n使用以下科学上一致的测试套件，该套件用于探测多尺度和稳定性边界。所有物理量必须采用国际单位制 (SI)：质量单位为千克 (kg)，劲度系数单位为牛顿/米 (N/m)，时间单位为秒 (s)，角度单位为弧度 (rad)，能量单位为焦耳 (J)。要求的结果是无量纲的小数。\n\n定义三个测试用例，参数为 $(m, k, x_0, v_0, \\Delta t, T)$，其中 $x_0$ 表示初始位置（单位：米），$v_0$ 表示初始速度（单位：米/秒）：\n- 测试用例 A（理想路径，中等时间步长，长时间）：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.05\\,\\mathrm{s}, 1000\\,\\mathrm{s})$。\n- 测试用例 B（接近显式方法的稳定性边界）：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 1.9\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n- 测试用例 C（快速振荡器，较小时间步长，长时间以探测多尺度）：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 100\\,\\mathrm{N/m}, 0.1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.02\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n\n对于每个测试用例，计算所有三种方法的两个指标。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例必须按顺序 $[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]$ 提供一个六元列表，其中上标表示方法（速度 Verlet、RK2、RK4）。最终输出是由三个六元列表组成的列表，即 $[[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]_\\mathrm{A}, [\\cdots]_\\mathrm{B}, [\\cdots]_\\mathrm{C}]$，每个数值条目都以小数表示。\n\n不允许任何外部输入。程序必须可直接运行，且必须直接根据常微分方程和能量的定义来实现这三种积分器。除了数值计算，你还必须在附带的解决方案中，从第一性原理出发，推导辛性决定长时间能量行为的定性原因，特别是解释为什么速度 Verlet 算法通常在长时间内表现出有界的、振荡的能量误差，而显式 Runge-Kutta 方法会累积漂移。你的推导必须从谐振子的哈密顿结构开始，并使用诸如面积保持和后向误差分析等经过充分检验的结论，而不能在问题陈述本身中引入简便公式。",
            "solution": "用户提供的问题是计算物理领域中一个适定且有科学依据的练习，具体涉及多尺度建模与分析。它要求对一个典范哈密顿系统——谐振子——的几种数值积分方案进行比较。\n\n### 问题验证\n\n**第一步：提取已知条件**\n- **控制方程**：谐振子的牛顿第二定律：$m \\ddot{x}(t) = -k x(t)$。\n- **状态变量**：位置 $x(t)$，速度 $v(t) = \\dot{x}(t)$。\n- **系统参数**：质量 $m > 0$，劲度系数 $k > 0$。\n- **守恒量（哈密顿量）**：总能量 $H(x,v) = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$。\n- **导出量**：角频率 $\\omega = \\sqrt{k/m}$。\n- **数值方法**：速度 Verlet、显式二阶 Runge-Kutta（中点法）(RK2) 和显式四阶 Runge-Kutta (RK4)。\n- **时间步进**：恒定时间步长 $\\Delta t$，总积分时间 $T$。\n- **度量指标**：\n    1. 最终相对能量漂移：$\\delta_E = \\frac{H(T) - H(0)}{H(0)}$。\n    2. 最大绝对相对能量偏差：$\\Delta_E^{\\max} = \\max_{0 \\le t \\le T} \\frac{\\left|H(t) - H(0)\\right|}{H(0)}$。\n- **测试套件**：\n    - **用例 A**：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.05\\,\\mathrm{s}, 1000\\,\\mathrm{s})$。\n    - **用例 B**：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 1\\,\\mathrm{N/m}, 1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 1.9\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n    - **用例 C**：$(m, k, x_0, v_0, \\Delta t, T) = (1\\,\\mathrm{kg}, 100\\,\\mathrm{N/m}, 0.1\\,\\mathrm{m}, 0\\,\\mathrm{m/s}, 0.02\\,\\mathrm{s}, 100\\,\\mathrm{s})$。\n- **输出格式**：一个包含三个列表的列表，每个列表包含六个十进制值：$[\\delta_E^{\\mathrm{VV}}, \\delta_E^{\\mathrm{RK2}}, \\delta_E^{\\mathrm{RK4}}, \\Delta_E^{\\max,\\mathrm{VV}}, \\Delta_E^{\\max,\\mathrm{RK2}}, \\Delta_E^{\\max,\\mathrm{RK4}}]$，分别对应每个测试用例。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据**：该问题建立在谐振子这一物理学基石模型之上。所有方程和定义都是标准且正确的。\n- **适定性**：该问题是一个二阶常微分方程的初值问题，是适定的。所有初始条件和参数都已指定。\n- **客观性**：问题使用精确、无歧义的数学和科学语言陈述。\n- **完整性**：提供了实现数值方法和计算所需指标的全部必要信息。所要求的方法（速度 Verlet、RK2 中点法、RK4）都是标准方法，可以从第一性原理推导。\n- **一致性与可行性**：参数选择在物理上是一致的（国际单位制），并且其选择旨在突出重要的数值现象，例如接近稳定性边界时的行为。\n\n**第三步：结论与行动**\n此问题有效。它是数值分析和计算物理领域中一个定义明确、科学上合理的问题。将提供完整的解决方案。\n\n### 解决方案与推导\n\n问题的核心是理解辛数值积分器与非辛数值积分器在长期能量行为上的定性差异。这种差异可以通过这两类方法各自保持的基本几何性质来解释。\n\n**1. 哈密顿表述与辛结构**\n\n谐振子的动力学可以在哈密顿框架内得到优雅的描述。我们定义广义坐标为 $q = x$，广义动量为 $p = mv$。系统的状态是二维相空间中的一个点 $z = (q, p)^T$。代表总能量的哈密顿量为：\n$$H(q, p) = \\frac{p^2}{2m} + \\frac{1}{2} k q^2$$\n系统的时间演化由哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -kq $$\n这些方程与原始的牛顿方程等价，因为 $\\dot{p} = m \\ddot{q}$，从而得到 $m\\ddot{q} = -kq$。用矩阵形式表示，这些方程可写为 $\\dot{z} = J \\nabla H(z)$，其中 $J$ 是辛矩阵：\n$$ J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} $$\n从时间 $t_0$ 到 $t_1$ 的精确时间演化，被称为流映射 $\\phi_{t_1 - t_0}$，具有一个关键性质：它是一个**辛映射**。如果一个映射 $\\phi$ 的雅可比矩阵 $M = \\frac{\\partial \\phi}{\\partial z}$ 满足条件 $M^T J M = J$，则该映射是辛映射。对于二维系统，其直接推论是相空间面积守恒。哈密顿系统的流保持相空间的几何结构。\n\n**2. 作为映射的数值积分器**\n\n一个具有恒定时间步长 $\\Delta t$ 的单步数值积分器是一个映射 $\\Phi_{\\Delta t}$，它近似于精确的流，将状态从时间 $t_n$ 的 $z_n$ 演化到时间 $t_{n+1}$ 的 $z_{n+1}$：\n$$ z_{n+1} = \\Phi_{\\Delta t}(z_n) $$\n- 如果一个数值积分器的映射 $\\Phi_{\\Delta t}$ 对于任何哈密顿系统都是精确辛的，则称其为**辛积分器**。\n- 如果其映射不是辛的，则称其为**非辛积分器**。\n\n**3. 速度 Verlet 算法：一种辛积分器**\n\n速度 Verlet 算法由泰勒级数展开推导而来。对于一个具有位置 $x$ 和加速度 $a(x)$ 的通用系统，其更新规则如下：\n1. 更新位置：$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a(x_n) (\\Delta t)^2$。\n2. 计算新位置处的加速度：$a_{n+1} = a(x_{n+1})$。对于我们的系统，$a(x) = - (k/m) x$。\n3. 使用加速度的对称平均值更新速度：$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$。\n\n可以证明这个两步过程是一个辛映射。它可以通过将更简单、可解的哈密顿量的精确流进行复合来构造，从而保证其辛性。这一性质是其卓越长期稳定性的根源。\n\n**4. Runge-Kutta 方法：非辛积分器**\n\n显式 Runge-Kutta 方法是通用的常微分方程求解器。我们将问题表述为一阶常微分方程组：令 $y(t) = (x(t), v(t))^T$，函数 $f(y)$ 为：\n$$ \\frac{dy}{dt} = f(y) = \\begin{pmatrix} v \\\\ -(k/m)x \\end{pmatrix} $$\n\n**RK2 (中点法)**：\n其更新规则为 $y_{n+1} = y_n + \\Delta t \\, f(y_n + \\frac{\\Delta t}{2} k_1)$，其中 $k_1 = f(y_n)$。\n1. 计算中间步：$(x_{n+1/2}, v_{n+1/2}) = (x_n + \\frac{\\Delta t}{2} v_n, v_n - \\frac{\\Delta t}{2} \\frac{k}{m} x_n)$。\n2. 在中点处计算导数：$(k_{2x}, k_{2v}) = (v_{n+1/2}, - \\frac{k}{m} x_{n+1/2})$。\n3. 更新状态：$(x_{n+1}, v_{n+1}) = (x_n + \\Delta t \\, k_{2x}, v_n + \\Delta t \\, k_{2v})$。\n\n**RK4 方法**：\n其更新规则为 $y_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)$。四个阶段如下：\n1. $k_1 = f(y_n)$。\n2. $k_2 = f(y_n + \\frac{\\Delta t}{2} k_1)$。\n3. $k_3 = f(y_n + \\frac{\\Delta t}{2} k_2)$。\n4. $k_4 = f(y_n + \\Delta t k_3)$。\n\n一般来说，显式 Runge-Kutta 方法不是辛的。它们对应的映射 $\\Phi_{\\Delta t}$ 不满足条件 $M^T J M = J$。这些方法被设计为在一定阶数上匹配泰勒级数展开，优先考虑局部精度而非保持几何结构。\n\n**5. 长期能量行为：辛性的作用**\n\n长期行为的深刻差异源于**后向误差分析**。该理论指出，由数值积分器生成的一系列点 $\\{z_n\\}$ 可以被看作是一个*修正*微分方程在时间点 $t_n$ 上的精确解采样。\n\n- **对于辛积分器（速度 Verlet）**：数值轨迹精确地守恒一个**修正哈密顿量**（或称影子哈密顿量）$\\tilde{H}$。这个影子哈密顿量是关于 $\\Delta t$ 的一个幂级数，并且接近原始哈密顿量 $H$：\n  $$ \\tilde{H}(q, p) = H(q, p) + (\\Delta t)^2 H_2(q, p) + (\\Delta t)^4 H_4(q, p) + \\dots $$\n  请注意，对于像 Verlet 这样的对称积分器，$\\Delta t$ 的奇次幂项是缺失的。由于数值解守恒 $\\tilde{H}$（即 $\\tilde{H}(z_n) = \\text{常数}$），原始能量 $H(z_n)$ 不会系统性地漂移。相反，它必须围绕其初始值振荡，因为轨迹被限制在 $\\tilde{H}$ 的一个等值集上，而这个等值集是真实能量曲面的一个轻微扭曲版本。这解释了使用 Verlet 算法时观察到的有界的、振荡的能量误差，从而确保了卓越的长期能量稳定性。\n\n- **对于非辛积分器（RK2, RK4）**：不存在守恒的修正哈密顿量。数值解所遵循的修正微分方程不具备哈密顿形式。在哈密顿意义上，其流具有非零散度，这通常表现为一个耗散项或反耗散项。对于应用于谐振子的显式 RK 方法，该项通常是反耗散的，导致能量系统性地漂移，通常是增加。\n  $$ \\frac{d H(z(t))}{dt} \\approx (\\Delta t)^p C(z(t)) \\neq 0 $$\n  其中 $p$ 是方法的阶数。这种缓慢但持续的漂移会在长时间积分中累积，导致能量守恒的完全破坏，即使该方法（例如 RK4）的局部截断误差可能非常小。\n\n总之，像速度 Verlet 这样的辛积分器是为哈密顿系统专门构建的。通过保持相空间的几何结构，它们保证了长期的稳定性和有界的能量误差，使其在力学和分子动力学的长时间模拟中表现更优越。而像 Runge-Kutta 这样的非辛方法，尽管在短期积分中具有高精度，却未能保持这种关键的几何结构，从而导致长期的能量漂移。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using three different numerical integrators\n    and computes energy drift and deviation metrics for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path, moderate time step\n        # (m, k, x0, v0, dt, T)\n        (1.0, 1.0, 1.0, 0.0, 0.05, 1000.0),\n        # Case B: Near stability boundary\n        (1.0, 1.0, 1.0, 0.0, 1.9, 100.0),\n        # Case C: Fast oscillator, smaller time step\n        (1.0, 100.0, 0.1, 0.0, 0.02, 100.0),\n    ]\n\n    all_results = []\n\n    def energy(m, k, x, v):\n        \"\"\"Calculates the total energy (Hamiltonian).\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * x**2\n\n    for m, k, x0, v0, dt, T in test_cases:\n        n_steps = int(T / dt)\n        \n        # Initial states\n        x_vv, v_vv = x0, v0\n        x_rk2, v_rk2 = x0, v0\n        x_rk4, v_rk4 = x0, v0\n\n        # Initial energy\n        h0 = energy(m, k, x0, v0)\n        \n        if h0 == 0:\n            # Avoid division by zero, although not expected with given test cases.\n            # Set metrics to NaN or handle as an error. For this problem, h0 > 0.\n            # Using nan for robustness in case of other, future test cases.\n            case_results = [np.nan] * 6\n            all_results.append(case_results)\n            continue\n            \n        # Initialize max deviation metrics\n        max_dev_vv, max_dev_rk2, max_dev_rk4 = 0.0, 0.0, 0.0\n\n        # --- Integration Loop ---\n        for _ in range(n_steps):\n            # 1. Velocity Verlet\n            a_n = -k * x_vv / m\n            x_vv_new = x_vv + v_vv * dt + 0.5 * a_n * dt**2\n            a_n1 = -k * x_vv_new / m\n            v_vv_new = v_vv + 0.5 * (a_n + a_n1) * dt\n            x_vv, v_vv = x_vv_new, v_vv_new\n            h_vv = energy(m, k, x_vv, v_vv)\n            max_dev_vv = max(max_dev_vv, abs(h_vv - h0) / h0)\n\n            # 2. RK2 (Midpoint)\n            k1_x = v_rk2\n            k1_v = -k * x_rk2 / m\n            x_mid = x_rk2 + 0.5 * dt * k1_x\n            v_mid = v_rk2 + 0.5 * dt * k1_v\n            \n            k2_x = v_mid\n            k2_v = -k * x_mid / m\n            \n            x_rk2 += dt * k2_x\n            v_rk2 += dt * k2_v\n            h_rk2 = energy(m, k, x_rk2, v_rk2)\n            max_dev_rk2 = max(max_dev_rk2, abs(h_rk2 - h0) / h0)\n\n            # 3. RK4\n            def f(x_in, v_in):\n                return np.array([v_in, -k * x_in / m])\n\n            y_rk4 = np.array([x_rk4, v_rk4])\n            k1 = f(y_rk4[0], y_rk4[1])\n            k2 = f(y_rk4[0] + 0.5 * dt * k1[0], y_rk4[1] + 0.5 * dt * k1[1])\n            k3 = f(y_rk4[0] + 0.5 * dt * k2[0], y_rk4[1] + 0.5 * dt * k2[1])\n            k4 = f(y_rk4[0] + dt * k3[0], y_rk4[1] + dt * k3[1])\n            \n            y_rk4 += (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            x_rk4, v_rk4 = y_rk4[0], y_rk4[1]\n            \n            h_rk4 = energy(m, k, x_rk4, v_rk4)\n            max_dev_rk4 = max(max_dev_rk4, abs(h_rk4 - h0) / h0)\n\n        # --- Calculate final metrics ---\n        # Final relative energy drift\n        delta_e_vv = (energy(m, k, x_vv, v_vv) - h0) / h0\n        delta_e_rk2 = (energy(m, k, x_rk2, v_rk2) - h0) / h0\n        delta_e_rk4 = (energy(m, k, x_rk4, v_rk4) - h0) / h0\n\n        case_results = [\n            delta_e_vv, delta_e_rk2, delta_e_rk4,\n            max_dev_vv, max_dev_rk2, max_dev_rk4\n        ]\n        all_results.append(case_results)\n\n    # Format the output string exactly as required\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "任何模拟的一个关键方面是选择一个能确保数值稳定性的时间步长。这项高级实践将Verlet算法的稳定性与模拟系统的物理特性，特别是其最快的振动模式，联系起来。您将学习如何对一个粗粒化聚合物模型进行正交模态分析，以计算最大允许时间步长，这是多尺度建模中的一项基本技能。",
            "id": "3831326",
            "problem": "考虑一个一维粗粒化聚合物，其模型为沿 $x$ 轴排列的 $N$ 个珠子组成的链条。第一个和最后一个珠子被固定在它们的平衡位置上，不能移动。这些珠子通过谐振键连接，并含有一个惩罚曲率的弯曲项。设珠子位置为 $x_1,\\dots,x_N$，其中 $x_1$ 和 $x_N$ 是固定的。自由度为 $x_2,\\dots,x_{N-1}$。总有效势能为\n$$\nV(x) = \\frac{1}{2}\\sum_{i=1}^{N-1} k_i\\left[(x_{i+1}-x_i) - r_i\\right]^2 + \\frac{1}{2}\\sum_{i=2}^{N-1} k_\\theta \\left(x_{i+1} - 2 x_i + x_{i-1}\\right)^2,\n$$\n其中 $k_i$ 是以 $\\mathrm{N/m}$ 为单位的键刚度，$r_i$ 是以 $\\mathrm{m}$ 为单位的平衡间距，$k_\\theta$ 是以 $\\mathrm{N/m}$ 为单位的弯曲刚度。假设系统在一个构型下进行线性化，该构型满足 $x_{i+1}-x_i = r_i$ 且曲率项最小（因此 Hessian 矩阵仅取决于刚度，而不取决于 $r_i$）。设珠子质量为 $m_1,\\dots,m_N$，单位为原子质量单位 (amu)，其中 $m_{\\mathrm{amu}} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$。\n\n您必须从第一性原理出发，推导如何获得保证该系统 Verlet 积分算法线性稳定的最大时间步长 $\\Delta t_{\\max}$。推导应从 Newton 第二定律和小振荡的线性化开始。利用以下事实：稳定性极限由线性化系统的最高角频率控制，并由有效势能的质量加权 Hessian 矩阵的谱决定。\n\n您的程序必须：\n- 通过在线性化点对键合项和弯曲项的贡献求和，为自由变量 $x_2,\\dots,x_{N-1}$ 构建 Hessian 矩阵 $H \\in \\mathbb{R}^{(N-2)\\times(N-2)}$。\n- 将质量从原子质量单位转换为千克，为自由变量构建对角质量矩阵 $M \\in \\mathbb{R}^{(N-2)\\times(N-2)}$，并构造质量加权 Hessian 矩阵 $A = M^{-1/2} H M^{-1/2}$。\n- 计算最大角频率 $\\omega_{\\max} = \\sqrt{\\lambda_{\\max}}$，其中 $\\lambda_{\\max}$ 是 $A$ 的最大特征值。\n- 根据应用于此系统的 Verlet 方法的线性稳定性条件，利用 $A$ 的谱特性确定 $\\Delta t_{\\max}$。\n\n物理单位和输出要求：\n- 最终答案必须以飞秒 ($\\mathrm{fs}$) 表示，并四舍五入到小数点后四位。\n- 在此一维设置中，角度单位（如果出现任何中间角度）不适用。\n- 最终输出格式必须是单行，包含用方括号括起来的逗号分隔列表，例如，“[12.3456,7.8901]”。\n\n测试套件：\n使用以下四个测试用例，每个用例由 $(N,\\{m_i\\}_{i=1}^N,\\{k_i\\}_{i=1}^{N-1},k_\\theta)$ 指定。\n\n1. 正常路径，均匀质量和键：\n   - $N=6$\n   - $m = [72,\\,72,\\,72,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,100,\\,100,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n2. 非均匀质量，中心有一个轻珠子：\n   - $N=6$\n   - $m = [72,\\,72,\\,10,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,100,\\,100,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n3. 局部刚度非均匀性：\n   - $N=6$\n   - $m = [72,\\,72,\\,72,\\,72,\\,72,\\,72]$ amu\n   - $k = [100,\\,1000,\\,1000,\\,100,\\,100]$ $\\mathrm{N/m}$\n   - $k_\\theta = 5$ $\\mathrm{N/m}$\n\n4. 边界尺寸链：\n   - $N=4$\n   - $m = [50,\\,50,\\,50,\\,50]$ amu\n   - $k = [80,\\,80,\\,80]$ $\\mathrm{N/m}$\n   - $k_\\theta = 2$ $\\mathrm{N/m}$\n\n实现细节：\n- 对于键对 $H$ 的贡献，将固定的端点 $x_1$ 和 $x_N$ 视为固定。得到的自由变量的键 Hessian 矩阵是三对角的：对于刚度为 $k_i$ 的珠子 $i$ 和 $i+1$ 之间的键，\n  - 如果两个珠子都是自由的，则将 $k_i$ 添加到对角线上相应的 $2\\times 2$ 块中，并将 $-k_i$ 添加到非对角线上。\n  - 如果一个珠子被固定而另一个是自由的，则将 $k_i$ 添加到自由珠子的对角线元素上。\n- 对于弯曲贡献，使用作用于整个链条索引 $i=2,\\dots,N-1$ 的二阶差分算子，然后限制在自由变量上。得到的自由变量上的弯曲 Hessian 矩阵是五对角的，其系数由二阶差分模板确定；请从第一性原理精确实现这些系数，无需临时调整。\n\n您的程序应生成一行输出，其中包含测试套件的四个 $\\Delta t_{\\max}$ 值（单位为飞秒），四舍五入到小数点后四位，并格式化为方括号括起来的逗号分隔列表（例如，“[26.1234,23.9876,19.5432,35.0000]”）。",
            "solution": "该问题要求从第一性原理出发，推导应用于一维聚合物链模型的 Verlet 积分算法的最大稳定时间步长 $\\Delta t_{\\max}$。\n\n该系统由 $N$ 个珠子组成，其位置为 $x_1, \\dots, x_N$，质量为 $m_1, \\dots, m_N$。两端的珠子 $x_1$ 和 $x_N$ 是固定的。$N-2$ 个自由珠子（索引为 $j=2, \\dots, N-1$）的动力学由 Newton 第二定律决定：\n$$\nm_j \\ddot{x}_j = F_j = -\\frac{\\partial V}{\\partial x_j}\n$$\n其中 $V$ 是系统的总势能。势能由谐振键项和弯曲能量项之和给出：\n$$\nV(x) = V_{\\text{bond}} + V_{\\text{bend}} = \\frac{1}{2}\\sum_{i=1}^{N-1} k_i\\left[(x_{i+1}-x_i) - r_i\\right]^2 + \\frac{1}{2}\\sum_{i=2}^{N-1} k_\\theta \\left(x_{i+1} - 2 x_i + x_{i-1}\\right)^2\n$$\n\n我们考虑围绕稳定平衡构型 $\\mathbf{x}^{(0)}$ 的小振荡 $\\delta x_j(t) = x_j(t) - x_j^{(0)}$。在平衡状态下，每个珠子上的合力为零，$F_j(\\mathbf{x}^{(0)}) = 0$。对于小位移，珠子 $j$ 上的力可以通过 Taylor 展开得到，保留 $\\delta x$ 的一阶项：\n$$\nF_j(\\mathbf{x}) \\approx F_j(\\mathbf{x}^{(0)}) + \\sum_{k=2}^{N-1} \\left. \\frac{\\partial F_j}{\\partial x_k} \\right|_{\\mathbf{x}^{(0)}} \\delta x_k = -\\sum_{k=2}^{N-1} \\left. \\frac{\\partial^2 V}{\\partial x_j \\partial x_k} \\right|_{\\mathbf{x}^{(0)}} \\delta x_k\n$$\n二阶导数矩阵 $H_{jk} = \\frac{\\partial^2 V}{\\partial x_j \\partial x_k}$ 是 Hessian 矩阵。问题指出，线性化是在一个构型下进行的，该构型中键长处于其平衡值 $(x_{i+1}-x_i) = r_i$，且链是直的，这使得弯曲项最小化。在这种情况下，Hessian 矩阵的分量与粒子位置无关，仅取决于刚度常数 $k_i$ 和 $k_\\theta$。\n\n自由变量的运动方程成为一个线性常微分方程组：\n$$\nm_j \\ddot{\\delta x}_j = -\\sum_{k=2}^{N-1} H_{jk} \\delta x_k\n$$\n这可以写成位移的 $(N-2)$ 维向量 $\\delta\\mathbf{x} = (\\delta x_2, \\dots, \\delta x_{N-1})^T$ 的矩阵形式：\n$$\nM \\ddot{\\delta\\mathbf{x}} = -H \\delta\\mathbf{x}\n$$\n其中 $M$ 是自由珠子的对角质量矩阵，其元素为 $M_{jj} = m_{j+1}$，$j=1,\\dots,N-2$。\n\nHessian 矩阵 $H$ 是键势和弯曲势贡献的总和，$H = H^{\\text{bond}} + H^{\\text{bend}}$。设 $(N-2)\\times(N-2)$ Hessian 矩阵的索引为 $\\alpha, \\beta \\in \\{1, \\dots, N-2\\}$，对应于粒子 $j=\\alpha+1$ 和 $k=\\beta+1$。\n\n键项的贡献为 $H^{\\text{bond}}_{\\alpha\\beta} = \\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_{\\alpha+1} \\partial x_{\\beta+1}}$。\n$$\n\\frac{\\partial V_{\\text{bond}}}{\\partial x_j} = k_j(x_{j+1}-x_j-r_j) - k_{j-1}(x_j-x_{j-1}-r_{j-1})\n$$\n二阶导数为：\n$$\n\\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_j^2} = k_j + k_{j-1}\n$$\n$$\n\\frac{\\partial^2 V_{\\text{bond}}}{\\partial x_j \\partial x_{j+1}} = -k_j\n$$\n考虑到固定边界（$x_1$ 和 $x_N$ 不是变量），我们为自由变量组装三对角键 Hessian 矩阵 $H^{\\text{bond}}$。对于矩阵索引 $\\alpha, \\beta \\in \\{1, \\dots, N-2\\}$：\n- 对角元素：$H^{\\text{bond}}_{\\alpha,\\alpha} = k_{\\alpha} + k_{\\alpha+1}$\n- 非对角元素：$H^{\\text{bond}}_{\\alpha,\\alpha+1} = H^{\\text{bond}}_{\\alpha+1,\\alpha} = -k_{\\alpha+1}$\n\n弯曲项的贡献是 $H^{\\text{bend}}_{\\alpha\\beta} = \\frac{\\partial^2 V_{\\text{bend}}}{\\partial x_{\\alpha+1} \\partial x_{\\beta+1}}$。令 $d_i = x_{i+1} - 2x_i + x_{i-1}$。\n$$\n\\frac{\\partial V_{\\text{bend}}}{\\partial x_j} = k_\\theta \\sum_{i=2}^{N-1} d_i \\frac{\\partial d_i}{\\partial x_j} = k_\\theta \\sum_{i=2}^{N-1} d_i (\\delta_{i,j-1} - 2\\delta_{i,j} + \\delta_{i,j+1})\n$$\n由于 Hessian 矩阵是在直链构型（其中 $d_i = 0$）下计算的，二阶导数简化为：\n$$\nH_{jk}^{\\text{bend}} = \\frac{\\partial^2 V_{\\text{bend}}}{\\partial x_j \\partial x_k} = k_\\theta \\sum_{i=2}^{N-1} \\frac{\\partial d_i}{\\partial x_j} \\frac{\\partial d_i}{\\partial x_k}\n$$\n计算此和可以得到一个五对角矩阵，其在主体部分的模板为 $[k_\\theta, -4k_\\theta, 6k_\\theta, -4k_\\theta, k_\\theta]$。在自由变量矩阵的边界处（索引 $\\alpha=1$ 和 $\\alpha=N-2$），由于固定节点 $x_1$ 和 $x_N$，该模式会发生改变。\n- 对角元素：对于 $\\alpha=2,\\dots,N-3$，$H^{\\text{bend}}_{\\alpha,\\alpha} = 6k_\\theta$。对于边界，$H^{\\text{bend}}_{1,1} = 5k_\\theta$ 且 $H^{\\text{bend}}_{N-2,N-2} = 5k_\\theta$。\n- 非对角元素：$H^{\\text{bend}}_{\\alpha,\\alpha\\pm 1} = -4k_\\theta$ 且 $H^{\\text{bend}}_{\\alpha,\\alpha\\pm 2} = k_\\theta$。\n\n为了求解该方程组，我们引入质量加权坐标 $\\mathbf{y} = M^{1/2} \\delta\\mathbf{x}$，其中 $M^{1/2}$ 是一个对角矩阵，其元素为 $\\sqrt{m_{j+1}}$。方程转换为：\n$$\n\\ddot{\\mathbf{y}} = - (M^{-1/2} H M^{-1/2}) \\mathbf{y} = -A \\mathbf{y}\n$$\n矩阵 $A = M^{-1/2} H M^{-1/2}$ 是质量加权 Hessian 矩阵。它是实对称矩阵。其特征值 $\\lambda_i$ 是系统简正模式角频率的平方，即 $\\lambda_i = \\omega_i^2$。$A$ 的元素由 $A_{\\alpha\\beta} = H_{\\alpha\\beta} / \\sqrt{m_{\\alpha+1}m_{\\beta+1}}$ 给出。\n\n对于单个谐振子 $\\ddot{z} = -\\omega^2 z$，位置-Verlet 积分器由 $z(t+\\Delta t) = 2z(t) - z(t-\\Delta t) - \\omega^2 (\\Delta t)^2 z(t)$ 给出。此数值方案稳定的充分必要条件是时间步长 $\\Delta t$ 满足条件 $|\\omega \\Delta t| \\le 2$。对于耦合振子系统，稳定性由系统中的最高频率 $\\omega_{\\max}$ 决定。因此，稳定性条件为：\n$$\n\\omega_{\\max} \\Delta t \\le 2\n$$\n因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}}\n$$\n最高频率对应于质量加权 Hessian 矩阵的最大特征值，$\\omega_{\\max} = \\sqrt{\\lambda_{\\max}(A)}$。最大时间步长的最终公式为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\sqrt{\\lambda_{\\max}(A)}}\n$$\n具体步骤是：构建 Hessian 矩阵 $H$，形成质量加权 Hessian 矩阵 $A$，找到其最大特征值 $\\lambda_{\\max}$，然后计算 $\\Delta t_{\\max}$。必须使用提供的常数 $m_{\\mathrm{amu}} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$ 将质量从原子质量单位 (amu) 转换为千克，以确保所有单位都在国际单位制 (SI) 中。最终以秒为单位的结果再转换为飞秒 ($1\\ \\text{fs} = 10^{-15}\\ \\text{s}$)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the maximum stable timestep for a 1D polymer model using Verlet integration.\n    \"\"\"\n    m_amu_const = 1.66053906660e-27  # kg/amu\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 72, 72, 72, 72],\n            \"k\": [100, 100, 100, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 10, 72, 72, 72],\n            \"k\": [100, 100, 100, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 6,\n            \"m\": [72, 72, 72, 72, 72, 72],\n            \"k\": [100, 1000, 1000, 100, 100],\n            \"k_theta\": 5,\n        },\n        {\n            \"N\": 4,\n            \"m\": [50, 50, 50, 50],\n            \"k\": [80, 80, 80],\n            \"k_theta\": 2,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        masses_amu = case[\"m\"]\n        bond_stiffnesses = case[\"k\"]\n        bending_stiffness = case[\"k_theta\"]\n\n        n_dof = N - 2\n        \n        if n_dof == 0:\n            results.append(float('inf'))\n            continue\n\n        # Initialize the Hessian matrix for the free variables\n        H = np.zeros((n_dof, n_dof))\n\n        # 1. Assemble the bond contribution to the Hessian\n        # DOF indices alpha = 0 to n_dof-1 correspond to particles 2 to N-1.\n        # Bond stiffness k_i (bond_stiffnesses[i-1]) connects particles i and i+1.\n        for i in range(1, N): # Iterate through bonds 1 to N-1\n            k = bond_stiffnesses[i-1]\n            p1_idx, p2_idx = i, i+1\n            \n            # Convert particle index to DOF index (-2)\n            dof1, dof2 = p1_idx - 2, p2_idx - 2\n            \n            if dof1 >= 0 and dof1  n_dof:\n                H[dof1, dof1] += k\n            if dof2 >= 0 and dof2  n_dof:\n                H[dof2, dof2] += k\n            if (dof1 >= 0 and dof1  n_dof) and (dof2 >= 0 and dof2  n_dof):\n                H[dof1, dof2] -= k\n                H[dof2, dof1] -= k\n\n        # 2. Assemble the bending contribution to the Hessian (symmetrically)\n        # The stencil is [1, -4, 6, -4, 1] * k_theta in the bulk.\n        if bending_stiffness != 0 and n_dof > 0:\n            for i in range(n_dof):\n                # Diagonal contribution\n                H[i, i] += 6 * bending_stiffness\n                # Off-diagonal (i, i+1)\n                if i + 1  n_dof:\n                    H[i, i + 1] -= 4 * bending_stiffness\n                    H[i + 1, i] -= 4 * bending_stiffness\n                # Off-diagonal (i, i+2)\n                if i + 2  n_dof:\n                    H[i, i + 2] += bending_stiffness\n                    H[i + 2, i] += bending_stiffness\n            \n            # Correct the diagonal elements at the boundaries due to fixed ends\n            H[0, 0] -= bending_stiffness\n            if n_dof > 1:\n                H[n_dof - 1, n_dof - 1] -= bending_stiffness\n\n        # 3. Construct the mass matrix and the mass-weighted Hessian\n        free_masses_amu = np.array(masses_amu[1:N-1])\n        free_masses_kg = free_masses_amu * m_amu_const\n        \n        M_inv_sqrt_diag = 1.0 / np.sqrt(free_masses_kg)\n        A = np.outer(M_inv_sqrt_diag, M_inv_sqrt_diag) * H\n\n        # 4. Compute the largest eigenvalue of A\n        # Since A is symmetric, eigvalsh is efficient and guarantees real eigenvalues.\n        eigenvalues = np.linalg.eigvalsh(A)\n        lambda_max = np.max(eigenvalues)\n\n        # 5. Calculate the maximum stable timestep\n        if lambda_max > 1e-9: # Add a small threshold for stability\n            omega_max = np.sqrt(lambda_max)\n            dt_max_s = 2.0 / omega_max\n            dt_max_fs = dt_max_s * 1e15\n            results.append(round(dt_max_fs, 4))\n        else:\n            results.append(float('inf'))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}