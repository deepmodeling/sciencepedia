{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering the Minimum Image Convention is to implement it for the simplest case: a cubic simulation box. This exercise guides you through the process of calculating the shortest displacement vector between two particles by applying the nearest-image logic component-wise. To deepen your understanding, you will also develop a method to identify which of the 27 neighboring image cells contains the 'closest' particle, providing a concrete link between the algorithm and the underlying geometry of periodic space .",
            "id": "2413998",
            "problem": "You are given a three-dimensional cubic simulation cell of side length $L$ with Periodic Boundary Conditions (PBC). For any pair of particle positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ in this cell, the Minimum Image Convention (MIC) defines the physically relevant separation as the shortest vector between $\\mathbf{r}_i$ and any periodic image of $\\mathbf{r}_j$. Formally, define the infinite set of images of $\\mathbf{r}_j$ as $\\{\\mathbf{r}_j + \\mathbf{n}L \\mid \\mathbf{n} \\in \\mathbb{Z}^3\\}$. The MIC displacement $\\mathbf{d}_{ij}$ is the unique vector $\\mathbf{r}_j' - \\mathbf{r}_i$ with $\\mathbf{r}_j' = \\mathbf{r}_j + \\mathbf{n}L$ that minimizes the Euclidean norm among all integer triplets $\\mathbf{n} \\in \\mathbb{Z}^3$. The MIC scalar distance is $d_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2$. To make the choice unique when a component lies exactly at a half box length, require each component of $\\mathbf{d}_{ij}$ to be the unique representative in the half-open interval $[-L/2, L/2)$ congruent to $(\\mathbf{r}_j - \\mathbf{r}_i)$ modulo $L$.\n\nDefine an integer cell code $c \\in \\{0,1,\\dots,26\\}$ that encodes which of the $27$ image cells the selected image $\\mathbf{r}_j'$ resides in relative to the primary (central) cell of the simulation box containing $\\mathbf{r}_j$. Let $\\mathbf{n} = (n_x,n_y,n_z) \\in \\{-1,0,1\\}^3$ be the unique integer offset satisfying $\\mathbf{r}_j' = \\mathbf{r}_j + \\mathbf{n}L$ for the MIC choice above, and define the code by\n$$\nc \\;=\\; (n_x + 1)\\cdot 9 \\;+\\; (n_y + 1)\\cdot 3 \\;+\\; (n_z + 1).\n$$\nWith this encoding, the central cell $(0,0,0)$ maps to $c=13$, the $(-1,-1,-1)$ cell maps to $c=0$, and the $(+1,+1,+1)$ cell maps to $c=26$.\n\nTask: Write a complete program that, for each test case specified below, computes and returns a list containing the three components of the MIC displacement vector $\\mathbf{d}_{ij}$ (in the same length units as $L$ and the coordinates), the MIC scalar distance $d_{ij}$ (same length unit), and the integer cell code $c$ as defined above. All coordinates are given in the primary cell with each component in $[0, L)$, $L$ is strictly positive, and angles are not involved.\n\nUse the following test suite, where each case is a triple $(L,\\mathbf{r}_i,\\mathbf{r}_j)$ with $L$ in arbitrary length units and positions in the same units:\n- Case 1: $L=30.0$, $\\mathbf{r}_i=(1.0,\\,2.0,\\,3.0)$, $\\mathbf{r}_j=(4.0,\\,6.0,\\,15.0)$.\n- Case 2: $L=10.0$, $\\mathbf{r}_i=(9.9,\\,5.0,\\,5.0)$, $\\mathbf{r}_j=(0.2,\\,5.0,\\,5.0)$.\n- Case 3: $L=10.0$, $\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$, $\\mathbf{r}_j=(5.0,\\,0.0,\\,0.0)$.\n- Case 4: $L=10.0$, $\\mathbf{r}_i=(1.0,\\,1.0,\\,1.0)$, $\\mathbf{r}_j=(8.0,\\,8.0,\\,8.0)$.\n- Case 5: $L=6.0$, $\\mathbf{r}_i=(0.1,\\,5.9,\\,3.0)$, $\\mathbf{r}_j=(5.9,\\,0.1,\\,3.0)$.\n- Case 6: $L=12.0$, $\\mathbf{r}_i=(6.0,\\,6.0,\\,6.0)$, $\\mathbf{r}_j=(6.0,\\,6.0,\\,6.0)$.\n- Case 7: $L=7.5$, $\\mathbf{r}_i=(7.4,\\,7.4,\\,7.4)$, $\\mathbf{r}_j=(0.0,\\,0.0,\\,0.0)$.\n\nFinal output format: Your program should produce a single line of output containing the results for the $7$ cases as a comma-separated list of lists enclosed in square brackets. For each case, output a list in the form $[d_x, d_y, d_z, d, c]$ where $d_x$, $d_y$, $d_z$, and $d$ are decimal numbers with exactly six digits after the decimal point, and $c$ is an integer. For example, the overall structure must be\n\"[ [d_x1,d_y1,d_z1,d1,c1], [d_x2,d_y2,d_z2,d2,c2], ... ]\"\nwith no extra whitespace requirements beyond commas and brackets, and numbers expressed in the same length unit as $L$ and the coordinates.",
            "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded. It presents a standard task from computational physics: the application of the Minimum Image Convention (MIC) for pairs of particles in a cubic simulation cell under Periodic Boundary Conditions (PBC). The task is to compute the MIC displacement vector $\\mathbf{d}_{ij}$, the corresponding scalar distance $d_{ij}$, and an integer cell code $c$ that identifies the periodic image used.\n\nThe fundamental principle of the MIC is to find the shortest possible separation vector between a particle $i$ at position $\\mathbf{r}_i$ and any periodic image of a particle $j$ at position $\\mathbf{r}_j$. The set of all images of particle $j$ is given by $\\{\\mathbf{r}_j + \\mathbf{n}L \\mid \\mathbf{n} \\in \\mathbb{Z}^3\\}$, where $L$ is the side length of the cubic cell and $\\mathbf{n} = (n_x, n_y, n_z)$ is an integer vector representing the translation by integer multiples of the box vector. The MIC displacement is $\\mathbf{d}_{ij} = \\mathbf{r}_j' - \\mathbf{r}_i$, where $\\mathbf{r}_j'$ is the specific image of $\\mathbf{r}_j$ that minimizes the Euclidean norm $\\|\\mathbf{r}_j' - \\mathbf{r}_i \\|_2$.\n\nThis minimization is most efficiently performed component-wise. First, we compute the raw displacement vector in the primary cell:\n$$\n\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i = (\\Delta x, \\Delta y, \\Delta z)\n$$\nwhere each component $\\Delta k$ lies in the interval $(-L, L)$, since particle coordinates are in $[0, L)$. The MIC requires finding the image of $\\mathbf{r}_j$ that is \"closest\" to $\\mathbf{r}_i$. This is equivalent to mapping each component $\\Delta k$ of the raw displacement vector to its unique counterpart $d_k$ in the half-open interval $[-L/2, L/2)$, as specified.\n\nThe algorithmic procedure to find the component $d_k$ of the MIC displacement vector $\\mathbf{d}_{ij}$ from the raw component $\\Delta k$ is as follows:\n$$\nd_k = \\Delta k - L \\cdot \\text{round}(\\frac{\\Delta k}{L})\n$$\nwhere the rounding function must be handled carefully. A more explicit and robust method, which correctly handles the boundary condition specified by the interval $[-L/2, L/2)$, is to apply corrections based on conditional checks:\n1.  Initialize $d_k = \\Delta k$.\n2.  If $d_k \\ge L/2$, subtract $L$: $d_k \\leftarrow d_k - L$. This maps values in $[L/2, L)$ to $[-L/2, 0)$.\n3.  If $d_k  -L/2$, add $L$: $d_k \\leftarrow d_k + L$. This maps values in $(-L, -L/2)$ to $(0, L/2)$.\n\nThis procedure correctly ensures that each component $d_k$ of the final displacement vector $\\mathbf{d}_{ij} = (d_x, d_y, d_z)$ lies within the required interval $[-L/2, L/2)$. For a value of precisely $L/2$, the first condition is met, and the component becomes $L/2 - L = -L/2$, which is correct.\n\nOnce the MIC displacement vector $\\mathbf{d}_{ij}$ is determined, we can find the integer offset vector $\\mathbf{n}=(n_x, n_y, n_z)$ that was implicitly used. The relationship is given by:\n$$\n\\mathbf{d}_{ij} = (\\mathbf{r}_j - \\mathbf{r}_i) + \\mathbf{n} L = \\Delta\\mathbf{r} + \\mathbf{n} L\n$$\nFrom this, the vector $\\mathbf{n}$ can be calculated component-wise:\n$$\nn_k = \\frac{d_k - \\Delta k}{L}\n$$\nSince $d_k$ is obtained from $\\Delta k$ by adding or subtracting an integer multiple of $L$ (specifically, $0$, $1$, or $-1$ times $L$), the value of $n_k$ will be an integer, which should be obtained by rounding the result of the division to handle potential floating-point inaccuracies. For the specified MIC, each $n_k$ will be an element of $\\{-1, 0, 1\\}$.\n\nWith the integer vector $\\mathbf{n}=(n_x, n_y, n_z)$ known, the cell code $c$ is computed using the provided formula, which represents a mapping from a base-$3$ number system (using digits $0, 1, 2$) to an integer:\n$$\nc = (n_x + 1) \\cdot 9 + (n_y + 1) \\cdot 3 + (n_z + 1)\n$$\nHere, $(n_x+1, n_y+1, n_z+1)$ are the digits in base $3$, each in $\\{0, 1, 2\\}$.\n\nFinally, the MIC scalar distance $d_{ij}$ is the Euclidean norm (length) of the MIC displacement vector $\\mathbf{d}_{ij}$:\n$$\nd_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2 = \\sqrt{d_x^2 + d_y^2 + d_z^2}\n$$\n\nThe solution will proceed by applying this algorithm to each test case provided in the problem statement. Numerical results will be formatted to six decimal places for floating-point values as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes MIC displacement, distance, and cell code for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, r_i, r_j)\n        (30.0, (1.0, 2.0, 3.0), (4.0, 6.0, 15.0)),\n        (10.0, (9.9, 5.0, 5.0), (0.2, 5.0, 5.0)),\n        (10.0, (0.0, 0.0, 0.0), (5.0, 0.0, 0.0)),\n        (10.0, (1.0, 1.0, 1.0), (8.0, 8.0, 8.0)),\n        (6.0, (0.1, 5.9, 3.0), (5.9, 0.1, 3.0)),\n        (12.0, (6.0, 6.0, 6.0), (6.0, 6.0, 6.0)),\n        (7.5, (7.4, 7.4, 7.4), (0.0, 0.0, 0.0)),\n    ]\n\n    results = []\n    for L, r_i_tuple, r_j_tuple in test_cases:\n        # Convert tuples to numpy arrays for vector operations\n        r_i = np.array(r_i_tuple, dtype=np.float64)\n        r_j = np.array(r_j_tuple, dtype=np.float64)\n\n        # 1. Calculate the raw displacement vector\n        delta_r = r_j - r_i\n\n        # 2. Apply Minimum Image Convention to get d_ij\n        # The components must be in [-L/2, L/2).\n        # A simple and robust way is to correct components outside this range.\n        d_ij = np.copy(delta_r)\n        half_L = L / 2.0\n        \n        # Vectorized implementation of the conditional logic:\n        # If a component is = L/2, subtract L.\n        # If a component is  -L/2, add L.\n        d_ij[d_ij = half_L] -= L\n        d_ij[d_ij  -half_L] += L\n\n        # 3. Calculate the scalar distance\n        d = np.linalg.norm(d_ij)\n\n        # 4. Calculate the integer offset vector 'n'\n        # n = (d_ij - delta_r) / L. Round to nearest integer to handle float precision.\n        n = np.rint((d_ij - delta_r) / L).astype(int)\n\n        # 5. Calculate the cell code 'c'\n        nx, ny, nz = n\n        c = (nx + 1) * 9 + (ny + 1) * 3 + (nz + 1)\n\n        # Store the results for this case\n        results.append([d_ij[0], d_ij[1], d_ij[2], d, c])\n\n    # Format the final output string as per the problem specification\n    formatted_results = []\n    for res in results:\n        dx, dy, dz, dist, code = res\n        s = f\"[{dx:.6f},{dy:.6f},{dz:.6f},{dist:.6f},{code}]\"\n        formatted_results.append(s)\n\n    # Print the final comma-separated list of lists\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While cubic boxes are simple to conceptualize, many advanced simulations, such as those studying materials under shear stress, require non-orthogonal, or triclinic, cells. This practice challenges you to generalize the MIC algorithm from the orthogonal to the triclinic case, a crucial skill for developing flexible and robust simulation codes. You will learn to use fractional coordinates and matrix transformations to correctly handle periodicity in these more complex geometries .",
            "id": "2414062",
            "problem": "You are asked to implement the Minimum Image Convention (MIC) for a general triclinic (non-orthogonal) periodic simulation box. The MIC defines, for any pair of points, the unique representative of their displacement in the central periodic image of the simulation cell. The simulation box is specified by a full-rank lattice matrix $H \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the three Bravais lattice vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$ in Cartesian coordinates. For any two points with Cartesian position vectors $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^3$, the raw displacement is $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Under periodic boundary conditions, periodic images differ by lattice translations $H \\mathbf{n}$ with $\\mathbf{n} \\in \\mathbb{Z}^3$. The MIC seeks the displacement $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ that lies in the central image of the simulation cell, obtained by a suitable integer lattice translation.\n\nStart from the fundamental definition of periodic boundary conditions: two Cartesian position vectors $\\mathbf{r}$ and $\\mathbf{r}'$ represent the same physical point if and only if $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$ for some $\\mathbf{n} \\in \\mathbb{Z}^3$. Use this to derive a numerically stable and general algorithm to compute $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ for a triclinic box by working in fractional coordinates $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$ and reducing $\\mathbf{s}$ into a central parallelepiped of fractional space. Explicitly state how half-integer ties are handled when reducing fractional components, and justify your choice so that the reduced fractional components each lie in a half-open interval of length $1$.\n\nYour program must implement the derived algorithm and apply it to the following test suite. In each case, $H$ is given by its columns and the positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ are given in Cartesian coordinates. Your code must compute, for each case, the MIC displacement vector $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ in Cartesian coordinates and its Euclidean norm $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$.\n\nTest suite (each matrix and vector is in Cartesian components):\n\n- Case $1$ (orthogonal cube):\n  - $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 2, 3)$,\n  - $\\mathbf{r}_j = (9, 9, 9)$.\n- Case $2$ (triclinic shear I):\n  - $\\mathbf{a} = (10, 0, 0)$, $\\mathbf{b} = (2, 8, 0)$, $\\mathbf{c} = (1, 1, 6)$,\n  - $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (1, 1, 1)$,\n  - $\\mathbf{r}_j = (9, 7, 5)$.\n- Case $3$ (boundary tie-handling):\n  - $\\mathbf{a} = (8, 0, 0)$, $\\mathbf{b} = (1, 7, 0)$, $\\mathbf{c} = (2, 1, 9)$,\n  - $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$,\n  - Let $\\mathbf{s} = (0.5, -0.5, 0.5)$ and define $\\mathbf{r} = H \\mathbf{s}$,\n  - $\\mathbf{r}_i = (0, 0, 0)$,\n  - $\\mathbf{r}_j = \\mathbf{r}$.\n- Case $4$ (triclinic shear II):\n  - $\\mathbf{a} = (5, 0, 0)$, $\\mathbf{b} = (4, 5, 0)$, $\\mathbf{c} = (3, 2, 5)$,\n  - $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$,\n  - $\\mathbf{r}_i = (4.9, 0.1, 0.1)$,\n  - $\\mathbf{r}_j = (0.2, 4.9, 0.2)$.\n\nFinal output specification:\n- For each case, output a list of four real numbers: the three Cartesian components of $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ followed by its Euclidean norm $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$.\n- Round each real number to $6$ decimal places.\n- Your program should produce a single line of output containing the results for the four cases as a Python-style list of lists, for example: $[\\,[x_1,y_1,z_1,n_1],[x_2,y_2,z_2,n_2],[x_3,y_3,z_3,n_3],[x_4,y_4,z_4,n_4]\\,]$.",
            "solution": "The problem presented is to formulate and implement a general algorithm for computing the minimum image convention (MIC) displacement vector in a triclinic periodic system. This is a fundamental task in computational physics, particularly in molecular dynamics and Monte Carlo simulations. The problem statement is scientifically sound, well-posed, and provides sufficient information for a unique solution.\n\nFirst, we establish the theoretical foundation. A triclinic simulation cell is defined by three linearly independent lattice vectors, $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, which form the columns of a lattice matrix $H = [\\mathbf{a}, \\mathbf{b}, \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$. Due to periodic boundary conditions, a point with Cartesian position vector $\\mathbf{r}$ has an infinite number of equivalent periodic images given by $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$, where $\\mathbf{n} = (n_1, n_2, n_3)^T$ is any vector of integers, $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\nThe displacement vector from a point $\\mathbf{r}_i$ to a point $\\mathbf{r}_j$ is also not unique. The raw displacement is $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. Any equivalent displacement is given by $\\Delta \\mathbf{r}' = \\mathbf{r}_j' - \\mathbf{r}_i = (\\mathbf{r}_j + H\\mathbf{n}) - \\mathbf{r}_i = \\Delta \\mathbf{r} + H\\mathbf{n}$ for some $\\mathbf{n} \\in \\mathbb{Z}^3$. The minimum image convention seeks to find the unique representative of this set of vectors, denoted $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$, that is \"closest\" to the origin. In a general triclinic cell, this means finding the vector that lies within the central Wigner-Seitz cell, which is the locus of points in space closer to the origin lattice point than to any other lattice point.\n\nDirectly minimizing the norm $\\|\\Delta \\mathbf{r} + H\\mathbf{n}\\|_2$ over all $\\mathbf{n} \\in \\mathbb{Z}^3$ is computationally complex. A more robust and efficient method, as suggested by the problem, is to operate in fractional (or scaled) coordinates. A Cartesian vector $\\mathbf{v}$ is transformed into fractional coordinates $\\mathbf{s}$ by the linear transformation $\\mathbf{s} = H^{-1} \\mathbf{v}$. The components of $\\mathbf{s}$ express $\\mathbf{v}$ as a linear combination of the lattice vectors.\n\nLet us apply this to the displacement vector:\n$$\n\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} (\\mathbf{r}_j - \\mathbf{r}_i)\n$$\nAn arbitrary periodic image of the displacement, $\\Delta \\mathbf{r} - H\\mathbf{n}$, is transformed to fractional coordinates as:\n$$\nH^{-1} (\\Delta \\mathbf{r} - H\\mathbf{n}) = H^{-1} \\Delta \\mathbf{r} - H^{-1}H\\mathbf{n} = \\mathbf{s} - \\mathbf{n}\n$$\nThis demonstrates that moving between periodic images in Cartesian space is equivalent to shifting the fractional coordinate vector by an integer vector. The problem is now reduced to finding an integer vector $\\mathbf{n}$ such that the components of the reduced fractional vector, $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\mathbf{n}$, lie within a central unit cell in fractional space. The standard choice for this central cell is the range $[-0.5, 0.5]$ for each component.\n\nTo map an arbitrary fractional coordinate component $s_k$ to its central image $s_{k, \\mathrm{MIC}}$, we must find an integer $n_k$ such that $s_{k, \\mathrm{MIC}} = s_k - n_k \\in [-0.5, 0.5)$. The choice of a half-open interval, such as $[-0.5, 0.5)$, is crucial to ensure a unique mapping and resolve ambiguity when a component is exactly on a boundary (a half-integer). An integer $n_k$ that satisfies this is the nearest integer to $s_k$. This can be computed algorithmically. A standard and numerically stable method to find $n_k$ and perform the reduction is:\n$$\ns_{k, \\mathrm{MIC}} = s_k - \\lfloor s_k + 0.5 \\rfloor\n$$\nThis operation correctly handles the tie-breaking for half-integer values. For example, if $s_k = 2.5$, then $s_{k, \\mathrm{MIC}} = 2.5 - \\lfloor 2.5 + 0.5 \\rfloor = 2.5 - \\lfloor 3.0 \\rfloor = 2.5 - 3 = -0.5$. If $s_k = -1.5$, then $s_{k, \\mathrm{MIC}} = -1.5 - \\lfloor -1.5 + 0.5 \\rfloor = -1.5 - \\lfloor -1.0 \\rfloor = -1.5 - (-1) = -0.5$. This consistently maps the upper boundary $0.5$ to the lower boundary $-0.5$, ensuring that the reduced fractional components $s_{k, \\mathrm{MIC}}$ all lie in the half-open interval $[-0.5, 0.5)$. This choice is justified by its computational simplicity and its guarantee of a unique result for any floating-point input.\n\nThe complete algorithm is as follows:\n$1$. Calculate the raw displacement vector in Cartesian coordinates: $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$.\n$2$. Convert $\\Delta \\mathbf{r}$ to fractional coordinates: $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$. This requires computing the inverse of the lattice matrix $H$.\n$3$. Apply the minimum image condition in fractional space by reducing each component $s_k$ to the interval $[-0.5, 0.5)$: $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\lfloor \\mathbf{s} + 0.5 \\rfloor$, where the operations are performed element-wise.\n$4$. Convert the reduced fractional vector back to Cartesian coordinates: $\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}}$.\n$5$. Compute the Euclidean norm of the final vector: $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(\\Delta \\mathbf{r}_{\\mathrm{MIC}}) \\cdot (\\Delta \\mathbf{r}_{\\mathrm{MIC}})}$.\n\nThis algorithm is universally applicable to any periodic cell described by a full-rank matrix $H$, including orthogonal, and general triclinic forms. We now apply this to the specified test cases.\n\nCase $1$: $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$, $\\mathbf{r}_i = (1, 2, 3)$, $\\mathbf{r}_j = (9, 9, 9)$.\n$\\Delta \\mathbf{r} = (8, 7, 6)$.\n$H^{-1} = \\begin{bmatrix} 0.1  0  0 \\\\ 0  0.1  0 \\\\ 0  0  0.1 \\end{bmatrix}$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = (0.8, 0.7, 0.6)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.8 - 1, 0.7 - 1, 0.6 - 1) = (-0.2, -0.3, -0.4)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-2, -3, -4)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-2)^2+(-3)^2+(-4)^2} = \\sqrt{29} \\approx 5.385165$.\n\nCase $2$: $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$, $\\mathbf{r}_i = (1, 1, 1)$, $\\mathbf{r}_j = (9, 7, 5)$.\n$\\Delta \\mathbf{r} = (8, 6, 4)$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (0.6, 0.666667, 0.666667)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.6 - 1, 0.666667 - 1, 0.666667 - 1) = (-0.4, -0.333333, -0.333333)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5, -3, -2)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5)^2+(-3)^2+(-2)^2} = \\sqrt{38} \\approx 6.164414$.\n\nCase $3$: $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$, $\\mathbf{r}_i = (0, 0, 0)$, $\\mathbf{r}_j = H(0.5, -0.5, 0.5)^T$.\n$\\Delta \\mathbf{r} = \\mathbf{r}_j$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} \\mathbf{r}_j = (0.5, -0.5, 0.5)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.5 - \\lfloor 1.0 \\rfloor, -0.5 - \\lfloor 0.0 \\rfloor, 0.5 - \\lfloor 1.0 \\rfloor) = (-0.5, -0.5, -0.5)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5.5, -4.0, -4.5)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5.5)^2+(-4)^2+(-4.5)^2} = \\sqrt{66.5} \\approx 8.154753$.\n\nCase $4$: $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$, $\\mathbf{r}_i = (4.9, 0.1, 0.1)$, $\\mathbf{r}_j = (0.2, 4.9, 0.2)$.\n$\\Delta \\mathbf{r} = (-4.7, 4.8, 0.1)$.\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (-1.7136, 0.952, 0.02)$.\n$\\mathbf{s}_{\\mathrm{MIC}} = (-1.7136 - \\lfloor -1.2136 \\rfloor, 0.952 - \\lfloor 1.452 \\rfloor, 0.02 - \\lfloor 0.52 \\rfloor) = (0.2864, -0.048, 0.02)$.\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (1.3, -0.2, 0.1)$.\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{1.3^2+(-0.2)^2+0.1^2} = \\sqrt{1.74} \\approx 1.319091$.\n\nThe implementation will follow this derived procedure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Minimum Image Convention displacement for a series of test cases\n    in triclinic periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"r_i\": np.array([1.0, 2.0, 3.0]),\n            \"r_j\": np.array([9.0, 9.0, 9.0])\n        },\n        {\n            \"H\": np.array([\n                [10.0, 2.0, 1.0],\n                [0.0, 8.0, 1.0],\n                [0.0, 0.0, 6.0]\n            ]),\n            \"r_i\": np.array([1.0, 1.0, 1.0]),\n            \"r_j\": np.array([9.0, 7.0, 5.0])\n        },\n        {\n            \"H\": np.array([\n                [8.0, 1.0, 2.0],\n                [0.0, 7.0, 1.0],\n                [0.0, 0.0, 9.0]\n            ]),\n            \"r_i\": np.array([0.0, 0.0, 0.0]),\n            \"r_j\": np.dot(\n                np.array([\n                    [8.0, 1.0, 2.0],\n                    [0.0, 7.0, 1.0],\n                    [0.0, 0.0, 9.0]\n                ]),\n                np.array([0.5, -0.5, 0.5])\n            )\n        },\n        {\n            \"H\": np.array([\n                [5.0, 4.0, 3.0],\n                [0.0, 5.0, 2.0],\n                [0.0, 0.0, 5.0]\n            ]),\n            \"r_i\": np.array([4.9, 0.1, 0.1]),\n            \"r_j\": np.array([0.2, 4.9, 0.2])\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        H = case[\"H\"]\n        r_i = case[\"r_i\"]\n        r_j = case[\"r_j\"]\n\n        # Step 1: Calculate the raw displacement vector in Cartesian coordinates.\n        delta_r = r_j - r_i\n\n        # Step 2: Convert delta_r to fractional coordinates.\n        H_inv = np.linalg.inv(H)\n        s = H_inv @ delta_r\n\n        # Step 3: Apply the minimum image condition in fractional space.\n        # This maps each component to the interval [-0.5, 0.5).\n        # s_mic = s - n, where n is the nearest integer vector to s.\n        # This is equivalent to s_mic = s - round(s).\n        # A numerically stable way to implement rounding to the nearest integer\n        # with a consistent tie-breaking rule (x.5 - x-1) is s - floor(s + 0.5)\n        s_mic = s - np.floor(s + 0.5)\n\n        # Step 4: Convert the reduced fractional vector back to Cartesian coordinates.\n        delta_r_mic = H @ s_mic\n\n        # Step 5: Compute the Euclidean norm of the final vector.\n        norm_mic = np.linalg.norm(delta_r_mic)\n\n        # Format the result for the final output string.\n        result_vector = [\n            delta_r_mic[0],\n            delta_r_mic[1],\n            delta_r_mic[2],\n            norm_mic\n        ]\n        \n        # Round each number to 6 decimal places and format as a string list.\n        formatted_vector = [f\"{val:.6f}\" for val in result_vector]\n        results_as_strings.append(f\"[{','.join(formatted_vector)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In practice, the MIC is almost always used in conjunction with a finite interaction cutoff radius, $r_c$, for computational efficiency. However, this simplification is only valid if the simulation cell is large enough relative to $r_c$. This advanced exercise asks you to derive and implement a computational test for the so-called \"half-box condition,\" which ensures that no particle is erroneously counted as interacting with two different periodic images of another particle. Mastering this concept is essential for setting up physically meaningful and artifact-free molecular simulations .",
            "id": "3780156",
            "problem": "Consider a three-dimensional periodic domain represented by a Bravais lattice with cell matrix $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the three linearly independent cell vectors. Under periodic boundary conditions, two points in $\\mathbb{R}^{3}$ that differ by a lattice vector $\\mathbf{A}\\mathbf{m}$ with $\\mathbf{m} \\in \\mathbb{Z}^{3}$ are identified. For any pair of particle positions $\\mathbf{x}_i, \\mathbf{x}_j \\in \\mathbb{R}^{3}$, define the raw separation vector $\\mathbf{r} = \\mathbf{x}_j - \\mathbf{x}_i$. The set of all periodic images of this separation is $\\{\\mathbf{r} + \\mathbf{A}\\mathbf{m} : \\mathbf{m} \\in \\mathbb{Z}^{3}\\}$. The Minimum Image Convention (MIC) chooses, for computations of pairwise interactions, the image with smallest Euclidean norm, that is, the image $\\mathbf{r} + \\mathbf{A}\\mathbf{m}^\\ast$ such that $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}^\\ast \\rVert$ is minimized over all $\\mathbf{m} \\in \\mathbb{Z}^{3}$. In multiscale modeling and analysis, one often truncates pair interactions beyond a cutoff radius $r_c  0$ and assumes that the MIC is unambiguous for all separations whose MIC distance is less than $r_c$. The so-called \"half-box condition\" is a sufficient geometric condition intended to ensure that, for any pair of particles, there is at most one periodic image of their separation vector within the ball of radius $r_c$ centered at the origin, thereby avoiding double counting of interactions.\n\nStarting only from the core definitions of Euclidean norm $\\lVert \\cdot \\rVert$, lattice periodicity, and the triangle inequality, derive a computational criterion to detect when a given lattice $\\mathbf{A}$ and cutoff $r_c$ admit a violation of the half-box condition in the following sense: there exists a raw separation $\\mathbf{r}$ such that there are at least two distinct lattice translations $\\mathbf{m}_1 \\neq \\mathbf{m}_2$ with both $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}_1 \\rVert  r_c$ and $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}_2 \\rVert  r_c$. Your program must implement this criterion by exhaustively searching nonzero lattice vectors $\\mathbf{A}\\mathbf{m}$ with integer components in a bounded range and return whether a violation can occur \"in principle\" based purely on lattice geometry and $r_c$. Treat equality on the boundary conservatively: if the geometric condition is met exactly at equality, regard it as a violation.\n\nImplement the following algorithmic tasks:\n1. For each test case, enumerate all integer vectors $\\mathbf{m} = (m_1,m_2,m_3) \\in \\mathbb{Z}^{3}$ with each component in the range $[-2,2]$ and $\\mathbf{m} \\neq \\mathbf{0}$, compute the lattice vector $\\mathbf{A}\\mathbf{m}$, and its Euclidean norm $\\lVert \\mathbf{A}\\mathbf{m} \\rVert$.\n2. Compute the minimal nonzero lattice-vector length $d_{\\min} = \\min_{\\mathbf{m} \\neq \\mathbf{0}} \\lVert \\mathbf{A}\\mathbf{m} \\rVert$ over the enumerated range.\n3. Determine the boolean result \"violation\" for the test case, defined to be $\\text{True}$ if and only if there exists at least one nonzero lattice vector in the enumerated set whose length is less than or equal to $2 r_c$ (equivalently, if $2 r_c \\ge d_{\\min}$ over the enumerated set), and $\\text{False}$ otherwise.\n4. Also compute the integer \"multiplicity count\" for the test case, defined to be the number of distinct nonzero lattice vectors in the enumerated set whose length is less than or equal to $2 r_c$. This multiplicity count quantifies, in a worst-case geometric sense, how many distinct lattice translations could contribute to multiple images within the cutoff.\n\nAll lengths in the input are given in consistent arbitrary units (for example, nanometers), and angles are specified in degrees. No angles appear in the outputs; the outputs are dimensionless booleans and integers. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[\\text{violation}, \\text{multiplicity}]$ for the corresponding test case. For example, the output line should look like $[[\\text{True},6],[\\text{False},0],\\dots]$ with no spaces after commas.\n\nUse the following test suite, designed to probe a general case, boundary conditions, orthorhombic anisotropy, and a triclinic geometry:\n- Test case $1$ (general \"happy path\"): $\\mathbf{A} = \\operatorname{diag}(10,10,10)$, $r_c = 4.9$.\n- Test case $2$ (boundary case at equality): $\\mathbf{A} = \\operatorname{diag}(10,10,10)$, $r_c = 5.0$.\n- Test case $3$ (orthorhombic anisotropy, safe): $\\mathbf{A} = \\operatorname{diag}(10,9,8)$, $r_c = 3.9$.\n- Test case $4$ (orthorhombic anisotropy, violation): $\\mathbf{A} = \\operatorname{diag}(10,9,8)$, $r_c = 4.1$.\n- Test case $5$ (triclinic oblique cell, violation): $\\mathbf{A}$ has columns $\\mathbf{a} = (10,0,0)$, $\\mathbf{b} = (10\\cos 30^\\circ, 10\\sin 30^\\circ, 0)$, $\\mathbf{c} = (0,0,10)$, $r_c = 3.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element being a two-element list $[\\text{violation}, \\text{multiplicity}]$ for each test case, in the same order as listed above. For instance, your program should print something like $[[\\text{False},0],[\\text{True},6],[\\text{False},0],[\\text{True},2],[\\text{True},2]]$ if those are the computed results.",
            "solution": "The problem asks for a computational criterion to determine if a given Bravais lattice, defined by its cell matrix $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$, and an interaction cutoff radius $r_c  0$ are susceptible to a violation of the half-box condition. A violation is defined to occur if there exists a raw particle separation vector $\\mathbf{r} \\in \\mathbb{R}^3$ for which at least two distinct periodic images of the separation lie within the cutoff sphere. That is, there exist two distinct integer vectors $\\mathbf{m}_1, \\mathbf{m}_2 \\in \\mathbb{Z}^3$ such that the corresponding image vectors, $\\mathbf{r}'_1 = \\mathbf{r} + \\mathbf{A}\\mathbf{m}_1$ and $\\mathbf{r}'_2 = \\mathbf{r} + \\mathbf{A}\\mathbf{m}_2$, both satisfy the condition $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ and $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$, where $\\lVert \\cdot \\rVert$ is the Euclidean norm and equality is treated as a violation.\n\nTo derive a criterion that depends only on the lattice geometry and $r_c$, we analyze the relationship between the two image vectors. Their difference is a non-zero lattice vector, $\\mathbf{L} = \\mathbf{r}'_2 - \\mathbf{r}'_1 = (\\mathbf{r} + \\mathbf{A}\\mathbf{m}_2) - (\\mathbf{r} + \\mathbf{A}\\mathbf{m}_1) = \\mathbf{A}(\\mathbf{m}_2 - \\mathbf{m}_1)$. We define $\\mathbf{m} = \\mathbf{m}_2 - \\mathbf{m}_1$, which is a non-zero integer vector since $\\mathbf{m}_1 \\neq \\mathbf{m}_2$. The length of this lattice vector $\\mathbf{L}$ can be bounded using the triangle inequality: $\\lVert \\mathbf{L} \\rVert = \\lVert \\mathbf{r}'_2 - \\mathbf{r}'_1 \\rVert \\le \\lVert \\mathbf{r}'_2 \\rVert + \\lVert -\\mathbf{r}'_1 \\rVert = \\lVert \\mathbf{r}'_2 \\rVert + \\lVert \\mathbf{r}'_1 \\rVert$. By substituting the conditions for a violation, $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ and $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$, we obtain the necessary condition $\\lVert \\mathbf{L} \\rVert \\le r_c + r_c = 2r_c$. This shows that for a violation to occur, there must exist at least one non-zero lattice vector $\\mathbf{L} = \\mathbf{A}\\mathbf{m}$ with a length less than or equal to $2r_c$.\n\nThis condition is also sufficient. Suppose there exists a non-zero integer vector $\\mathbf{m}$ such that the corresponding lattice vector $\\mathbf{L} = \\mathbf{A}\\mathbf{m}$ has a norm $\\lVert \\mathbf{L} \\rVert \\le 2r_c$. We can then construct a specific raw separation vector $\\mathbf{r} = -\\mathbf{L}/2$. For this $\\mathbf{r}$, consider the two periodic images corresponding to the integer vectors $\\mathbf{0}$ and $\\mathbf{m}$. The first image is $\\mathbf{r}'_1 = \\mathbf{r} + \\mathbf{A}\\mathbf{0} = -\\mathbf{L}/2$, and the second is $\\mathbf{r}'_2 = \\mathbf{r} + \\mathbf{A}\\mathbf{m} = -\\mathbf{L}/2 + \\mathbf{L} = \\mathbf{L}/2$. The norms of these two images are identical: $\\lVert \\mathbf{r}'_1 \\rVert = \\lVert \\mathbf{r}'_2 \\rVert = \\lVert \\mathbf{L} \\rVert / 2$. Since we assumed $\\lVert \\mathbf{L} \\rVert \\le 2r_c$, it follows that $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ and $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$. This confirms the existence of two distinct images within the cutoff sphere, thereby constituting a violation.\n\nTherefore, a violation of the half-box condition is possible if and only if there exists a non-zero integer vector $\\mathbf{m} \\in \\mathbb{Z}^3$ such that $\\lVert \\mathbf{A}\\mathbf{m} \\rVert \\le 2r_c$. This is a purely geometric condition on the lattice and the cutoff radius. The problem is reduced to a search for such a lattice vector. The standard \"half-box condition\" for well-behaved simulations is $d_{\\min}  2r_c$, where $d_{\\min} = \\min_{\\mathbf{m} \\in \\mathbb{Z}^3, \\mathbf{m}\\neq\\mathbf{0}} \\lVert \\mathbf{A}\\mathbf{m} \\rVert$. Our task is to detect a violation, which corresponds to $d_{\\min} \\le 2r_c$.\n\nThe prescribed algorithm implements a direct search based on this criterion within a limited search space. For each test case $(\\mathbf{A}, r_c)$, we enumerate all non-zero integer vectors $\\mathbf{m}=(m_1, m_2, m_3)$ with each component $m_i$ in the range [-$2$,$2$]. This finite search space comprises $5^3 - 1 = 124$ vectors. For each such $\\mathbf{m}$, we compute the lattice vector $\\mathbf{v} = \\mathbf{A}\\mathbf{m}$ and its Euclidean norm $\\lVert \\mathbf{v} \\rVert$. This norm is then compared to the threshold $2r_c$. The boolean `violation` result is set to `True` if at least one lattice vector is found to satisfy $\\lVert \\mathbf{v} \\rVert \\le 2r_c$, and `False` otherwise. The integer `multiplicity count` is the total number of distinct non-zero integer vectors $\\mathbf{m}$ in the search range for which this condition holds. This count quantifies the number of short lattice vectors that could cause violations. The implementation uses the `numpy` library for all linear algebra operations.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the problem of checking for half-box condition violations for a given\n    set of lattice matrices and cutoff radii.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Each tuple contains:\n    # 1. A function to generate the lattice matrix A.\n    # 2. The cutoff radius rc.\n    test_cases = [\n        (lambda: np.diag([10.0, 10.0, 10.0]), 4.9),\n        (lambda: np.diag([10.0, 10.0, 10.0]), 5.0),\n        (lambda: np.diag([10.0, 9.0, 8.0]), 3.9),\n        (lambda: np.diag([10.0, 9.0, 8.0]), 4.1),\n        (lambda: np.array([\n            [10.0, 10.0 * np.cos(np.deg2rad(30)), 0.0],\n            [0.0, 10.0 * np.sin(np.deg2rad(30)), 0.0],\n            [0.0, 0.0, 10.0]\n        ]), 3.0),\n    ]\n\n    # The range for integer vector components m_i.\n    m_range = range(-2, 3)\n    \n    # Generate all integer vectors m in the search cube, excluding the zero vector.\n    m_vectors = [\n        np.array(m, dtype=int) for m in itertools.product(m_range, repeat=3) if not all(c == 0 for c in m)\n    ]\n\n    results = []\n    \n    for A_func, rc in test_cases:\n        A = A_func()\n        threshold = 2.0 * rc\n        \n        multiplicity = 0\n        \n        for m in m_vectors:\n            # Compute the lattice vector v = A * m\n            v = A @ m\n            \n            # Compute the Euclidean norm of v\n            norm_v = np.linalg.norm(v)\n            \n            # Check if the norm is within the violation threshold\n            # Floating point comparisons are handled carefully by the problem's\n            # clear \"less than or equal to\" directive.\n            if norm_v = threshold:\n                multiplicity += 1\n\n        violation = multiplicity  0\n        results.append([violation, multiplicity])\n    \n    # Format the output string as per the problem specification.\n    # e.g., [[False,0],[True,6],[False,0],[True,2],[True,2]]\n    # str(list).replace(' ', '') is used to remove spaces from the default list string representation.\n    output_str = f\"[{','.join([str(res).replace(' ', '') for res in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}