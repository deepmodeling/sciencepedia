{
    "hands_on_practices": [
        {
            "introduction": "我们将从最常见的情景——立方晶胞——开始我们的实践。这个练习旨在帮助你实现最小镜像约定（MIC）的核心算法。你不仅要计算最短距离矢量，还要确定这个最短矢量所对应的周期性镜像是哪一个，从而加深对周期性边界条件几何本质的理解。",
            "id": "2413998",
            "problem": "给定一个边长为 $L$ 的三维立方模拟单元，该单元具有周期性边界条件 (PBC)。对于该单元中的任意一对粒子位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$，最小镜像约定 (MIC) 将物理相关的分离定义为 $\\mathbf{r}_i$ 与 $\\mathbf{r}_j$ 的任意周期性镜像之间的最短向量。形式上，$\\mathbf{r}_j$ 的镜像无限集合定义为 $\\{\\mathbf{r}_j + \\mathbf{n}L \\mid \\mathbf{n} \\in \\mathbb{Z}^3\\}$。MIC 位移 $\\mathbf{d}_{ij}$ 是唯一的向量 $\\mathbf{r}_j' - \\mathbf{r}_i$，其中 $\\mathbf{r}_j' = \\mathbf{r}_j + \\mathbf{n}L$，它在所有整数三元组 $\\mathbf{n} \\in \\mathbb{Z}^3$ 中使欧几里得范数最小。MIC 标量距离为 $d_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2$。为了在分量恰好位于半箱长处时使选择唯一，要求 $\\mathbf{d}_{ij}$ 的每个分量都是与 $(\\mathbf{r}_j - \\mathbf{r}_i)$ 模 $L$ 同余的、在半开区间 $[-L/2,\\,L/2)$ 内的唯一代表。\n\n定义一个整数单元格代码 $c \\in \\{0,1,\\dots,26\\}$，它编码了所选镜像 $\\mathbf{r}_j'$ 相对于包含 $\\mathbf{r}_j$ 的模拟盒子主（中心）单元格所在的27个镜像单元格中的哪一个。设 $\\mathbf{n} = (n_x,n_y,n_z) \\in \\{-1,0,1\\}^3$ 是满足上述 MIC 选择的 $\\mathbf{r}_j' = \\mathbf{r}_j + \\mathbf{n}L$ 的唯一整数偏移量，并将代码定义为\n$$\nc \\;=\\; (n_x + 1)\\cdot 9 \\;+\\; (n_y + 1)\\cdot 3 \\;+\\; (n_z + 1).\n$$\n通过这种编码，中心单元格 $(0,0,0)$ 映射到 $c=13$，(-1,-1,-1) 单元格映射到 $c=0$，而 (+1,+1,+1) 单元格映射到 $c=26$。\n\n任务：编写一个完整的程序，对下面指定的每个测试用例，计算并返回一个列表，其中包含 MIC 位移向量 $\\mathbf{d}_{ij}$ 的三个分量（单位与 $L$ 和坐标的长度单位相同）、MIC 标量距离 $d_{ij}$（长度单位相同）以及如上定义的整数单元格代码 $c$。所有坐标都在主单元格中给出，每个分量都在 $[0,\\,L)$ 范围内，$L$ 严格为正，且不涉及角度。\n\n使用以下测试套件，其中每个用例都是一个三元组 $(L,\\mathbf{r}_i,\\mathbf{r}_j)$，$L$ 的单位是任意长度单位，位置的单位与之相同：\n- 用例 1: $L=30.0$，$\\mathbf{r}_i=(1.0,\\,2.0,\\,3.0)$，$\\mathbf{r}_j=(4.0,\\,6.0,\\,15.0)$。\n- 用例 2: $L=10.0$，$\\mathbf{r}_i=(9.9,\\,5.0,\\,5.0)$，$\\mathbf{r}_j=(0.2,\\,5.0,\\,5.0)$。\n- 用例 3: $L=10.0$，$\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$，$\\mathbf{r}_j=(5.0,\\,0.0,\\,0.0)$。\n- 用例 4: $L=10.0$，$\\mathbf{r}_i=(1.0,\\,1.0,\\,1.0)$，$\\mathbf{r}_j=(8.0,\\,8.0,\\,8.0)$。\n- 用例 5: $L=6.0$，$\\mathbf{r}_i=(0.1,\\,5.9,\\,3.0)$，$\\mathbf{r}_j=(5.9,\\,0.1,\\,3.0)$。\n- 用例 6: $L=12.0$，$\\mathbf{r}_i=(6.0,\\,6.0,\\,6.0)$，$\\mathbf{r}_j=(6.0,\\,6.0,\\,6.0)$。\n- 用例 7: $L=7.5$，$\\mathbf{r}_i=(7.4,\\,7.4,\\,7.4)$，$\\mathbf{r}_j=(0.0,\\,0.0,\\,0.0)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含7个用例的结果，形式为用方括号括起来的、逗号分隔的列表的列表。对于每个用例，输出一个形式为 $[d_x, d_y, d_z, d, c]$ 的列表，其中 $d_x$、$d_y$、$d_z$ 和 $d$ 是小数点后恰好有六位数字的小数，$c$ 是一个整数。例如，整体结构必须是\n\"[ [d_x1,d_y1,d_z1,d1,c1], [d_x2,d_y2,d_z2,d2,c2], ... ]\"\n，除了逗号和方括号外没有额外的空白要求，并且数字的长度单位与 $L$ 和坐标的单位相同。",
            "solution": "问题陈述已经过验证，被认为是合理、适定且有科学依据的。它提出了一个计算物理学中的标准任务：在周期性边界条件 (PBC) 下，对立方模拟单元中的粒子对应用最小镜像约定 (MIC)。该任务是计算 MIC 位移向量 $\\mathbf{d}_{ij}$、相应的标量距离 $d_{ij}$ 以及一个标识所用周期性镜像的整数单元格代码 $c$。\n\nMIC 的基本原理是找到位于位置 $\\mathbf{r}_i$ 的粒子 $i$ 与位于位置 $\\mathbf{r}_j$ 的粒子 $j$ 的任意周期性镜像之间的最短可能分离向量。粒子 $j$ 的所有镜像集合由 $\\{\\mathbf{r}_j + \\mathbf{n}L \\mid \\mathbf{n} \\in \\mathbb{Z}^3\\}$ 给出，其中 $L$ 是立方单元的边长，$\\mathbf{n} = (n_x, n_y, n_z)$ 是一个整数向量，表示按盒子向量整数倍的平移。MIC 位移是 $\\mathbf{d}_{ij} = \\mathbf{r}_j' - \\mathbf{r}_i$，其中 $\\mathbf{r}_j'$ 是 $\\mathbf{r}_j$ 的一个特定镜像，它使欧几里得范数 $\\|\\mathbf{r}_j' - \\mathbf{r}_i \\|_2$ 最小化。\n\n这种最小化最有效的方法是逐分量执行。首先，我们计算主单元格中的原始位移向量：\n$$\n\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i = (\\Delta x, \\Delta y, \\Delta z)\n$$\n其中每个分量 $\\Delta k$ 都在区间 $(-L, L)$ 内，因为粒子坐标在 $[0, L)$ 内。MIC 要求找到离 $\\mathbf{r}_i$ “最近”的 $\\mathbf{r}_j$ 的镜像。这等同于按规定将原始位移向量的每个分量 $\\Delta k$ 映射到半开区间 $[-L/2, L/2)$ 内其唯一的对应项 $d_k$。\n\n从原始分量 $\\Delta k$ 找到 MIC 位移向量 $\\mathbf{d}_{ij}$ 的分量 $d_k$ 的算法过程如下：\n$$\nd_k = \\Delta k - L \\cdot \\text{round}(\\frac{\\Delta k}{L})\n$$\n其中四舍五入函数必须小心处理。一种更明确和稳健的方法是，根据条件检查应用校正，该方法能正确处理由区间 $[-L/2, L/2)$ 指定的边界条件：\n1.  初始化 $d_k = \\Delta k$。\n2.  如果 $d_k \\ge L/2$，则减去 $L$：$d_k \\leftarrow d_k - L$。这将 $[L/2, L)$ 中的值映射到 $[-L/2, 0)$。\n3.  如果 $d_k  -L/2$，则加上 $L$：$d_k \\leftarrow d_k + L$。这将 $(-L, -L/2)$ 中的值映射到 $(0, L/2)$。\n\n此过程正确地确保最终位移向量 $\\mathbf{d}_{ij} = (d_x, d_y, d_z)$ 的每个分量 $d_k$ 都位于所需区间 $[-L/2, L/2)$ 内。对于恰好为 $L/2$ 的值，第一个条件被满足，分量变为 $L/2 - L = -L/2$，这是正确的。\n\n一旦确定了 MIC 位移向量 $\\mathbf{d}_{ij}$，我们就可以找到被隐式使用的整数偏移向量 $\\mathbf{n}=(n_x, n_y, n_z)$。关系由以下公式给出：\n$$\n\\mathbf{d}_{ij} = (\\mathbf{r}_j - \\mathbf{r}_i) + \\mathbf{n} L = \\Delta\\mathbf{r} + \\mathbf{n} L\n$$\n由此，可以逐分量计算向量 $\\mathbf{n}$：\n$$\nn_k = \\frac{d_k - \\Delta k}{L}\n$$\n由于 $d_k$ 是通过对 $\\Delta k$ 加上或减去 $L$ 的整数倍（具体来说是 $0$、$1$ 或 $-1$ 倍 $L$）得到的，因此 $n_k$ 的值将是一个整数。这个整数应通过对除法结果进行四舍五入来获得，以处理潜在的浮点不精确性。对于指定的 MIC，每个 $n_k$ 将是 $\\{-1, 0, 1\\}$ 中的一个元素。\n\n已知整数向量 $\\mathbf{n}=(n_x, n_y, n_z)$ 后，使用提供的公式计算单元格代码 $c$。该公式表示从一个三进制数系统（使用数字 $0, 1, 2$）到整数的映射：\n$$\nc = (n_x + 1) \\cdot 9 + (n_y + 1) \\cdot 3 + (n_z + 1)\n$$\n此处，$(n_x+1, n_y+1, n_z+1)$ 是三进制下的数字，每个数字都在 $\\{0, 1, 2\\}$ 中。\n\n最后，MIC 标量距离 $d_{ij}$ 是 MIC 位移向量 $\\mathbf{d}_{ij}$ 的欧几里得范数（长度）：\n$$\nd_{ij} = \\lVert \\mathbf{d}_{ij} \\rVert_2 = \\sqrt{d_x^2 + d_y^2 + d_z^2}\n$$\n\n解决方案将通过对问题陈述中提供的每个测试用例应用此算法来继续。数值结果将按要求格式化为六位小数的浮点值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes MIC displacement, distance, and cell code for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, r_i, r_j)\n        (30.0, (1.0, 2.0, 3.0), (4.0, 6.0, 15.0)),\n        (10.0, (9.9, 5.0, 5.0), (0.2, 5.0, 5.0)),\n        (10.0, (0.0, 0.0, 0.0), (5.0, 0.0, 0.0)),\n        (10.0, (1.0, 1.0, 1.0), (8.0, 8.0, 8.0)),\n        (6.0, (0.1, 5.9, 3.0), (5.9, 0.1, 3.0)),\n        (12.0, (6.0, 6.0, 6.0), (6.0, 6.0, 6.0)),\n        (7.5, (7.4, 7.4, 7.4), (0.0, 0.0, 0.0)),\n    ]\n\n    results = []\n    for L, r_i_tuple, r_j_tuple in test_cases:\n        # Convert tuples to numpy arrays for vector operations\n        r_i = np.array(r_i_tuple, dtype=np.float64)\n        r_j = np.array(r_j_tuple, dtype=np.float64)\n\n        # 1. Calculate the raw displacement vector\n        delta_r = r_j - r_i\n\n        # 2. Apply Minimum Image Convention to get d_ij\n        # The components must be in [-L/2, L/2).\n        # A simple and robust way is to correct components outside this range.\n        d_ij = np.copy(delta_r)\n        half_L = L / 2.0\n        \n        # Vectorized implementation of the conditional logic:\n        # If a component is >= L/2, subtract L.\n        # If a component is  -L/2, add L.\n        d_ij[d_ij >= half_L] -= L\n        d_ij[d_ij  -half_L] += L\n\n        # 3. Calculate the scalar distance\n        d = np.linalg.norm(d_ij)\n\n        # 4. Calculate the integer offset vector 'n'\n        # n = (d_ij - delta_r) / L. Round to nearest integer to handle float precision.\n        n = np.rint((d_ij - delta_r) / L).astype(int)\n\n        # 5. Calculate the cell code 'c'\n        nx, ny, nz = n\n        c = (nx + 1) * 9 + (ny + 1) * 3 + (nz + 1)\n\n        # Store the results for this case\n        results.append([d_ij[0], d_ij[1], d_ij[2], d, c])\n\n    # Format the final output string as per the problem specification\n    formatted_results = []\n    for res in results:\n        dx, dy, dz, dist, code = res\n        s = f\"[{dx:.6f},{dy:.6f},{dz:.6f},{dist:.6f},{code}]\"\n        formatted_results.append(s)\n\n    # Print the final comma-separated list of lists\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理系统的模拟需要在非正交的（三斜）晶胞中进行，这使得直接在笛卡尔坐标系中应用最小镜像约定变得复杂。这个练习将指导你学习一种更通用且强大的方法：通过将问题转换到分数坐标系来解决。掌握这种方法后，你将能够为任何形状的周期性晶胞实现最小镜像约定。",
            "id": "2414062",
            "problem": "要求您为通用的三斜（非正交）周期性模拟晶胞实现最小镜像约定（Minimum Image Convention, MIC）。对于任意点对，MIC在其模拟晶胞的中心周期性镜像中定义了其位移的唯一代表。该模拟晶胞由一个满秩晶格矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 指定，其列向量是在笛卡尔坐标系下的三个Bravais晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$。对于任意两个笛卡尔坐标位置矢量 $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^3$，原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。在周期性边界条件下，周期性镜像之间相差一个晶格平移量 $H \\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。MIC旨在通过一个合适的整数晶格平移，找到位于模拟晶胞中心镜像内的位移 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$。\n\n从周期性边界条件的基本定义出发：两个笛卡尔位置矢量 $\\mathbf{r}$ 和 $\\mathbf{r}'$ 代表同一个物理点，当且仅当存在某个 $\\mathbf{n} \\in \\mathbb{Z}^3$ 使得 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$。利用此定义，通过在分数坐标 $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$ 中进行运算，并将 $\\mathbf{s}$ 约化到分数坐标空间中的中心平行六面体内，来推导一个用于计算三斜晶胞 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的数值稳定且通用的算法。明确说明在约化分数坐标分量时如何处理半整数的临界情况，并论证您的选择，以确保约化后的每个分数坐标分量都位于一个长度为1的半开区间内。\n\n您的程序必须实现所推导的算法，并将其应用于以下测试集。在每个案例中，$H$ 由其列向量给出，位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以笛卡尔坐标给出。您的代码必须为每个案例计算出笛卡尔坐标下的MIC位移矢量 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 及其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n\n测试集（每个矩阵和矢量均使用笛卡尔分量表示）：\n\n- 案例 $1$（正交立方体）：\n  - $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$，\n  - $\\mathbf{r}_i = (1, 2, 3)$，\n  - $\\mathbf{r}_j = (9, 9, 9)$。\n- 案例 $2$（三斜剪切 I）：\n  - $\\mathbf{a} = (10, 0, 0)$，$\\mathbf{b} = (2, 8, 0)$，$\\mathbf{c} = (1, 1, 6)$，\n  - $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$，\n  - $\\mathbf{r}_i = (1, 1, 1)$，\n  - $\\mathbf{r}_j = (9, 7, 5)$。\n- 案例 $3$（边界临界情况处理）：\n  - $\\mathbf{a} = (8, 0, 0)$，$\\mathbf{b} = (1, 7, 0)$，$\\mathbf{c} = (2, 1, 9)$，\n  - $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$，\n  - 令 $\\mathbf{s} = (0.5, -0.5, 0.5)$ 并定义 $\\mathbf{r} = H \\mathbf{s}$，\n  - $\\mathbf{r}_i = (0, 0, 0)$，\n  - $\\mathbf{r}_j = \\mathbf{r}$。\n- 案例 $4$（三斜剪切 II）：\n  - $\\mathbf{a} = (5, 0, 0)$，$\\mathbf{b} = (4, 5, 0)$，$\\mathbf{c} = (3, 2, 5)$，\n  - $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$，\n  - $\\mathbf{r}_i = (4.9, 0.1, 0.1)$，\n  - $\\mathbf{r}_j = (0.2, 4.9, 0.2)$。\n\n最终输出规范：\n- 对于每个案例，输出一个包含四个实数的列表：$\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的三个笛卡尔分量，后跟其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n- 将每个实数四舍五入到6位小数。\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为Python风格的列表的列表，例如： $[\\,[x_1,y_1,z_1,n_1],[x_2,y_2,z_2,n_2],[x_3,y_3,z_3,n_3],[x_4,y_4,z_4,n_4]\\,]$。",
            "solution": "本问题要求为三斜周期性系统中的最小镜像约定（MIC）位移矢量制定并实现一个通用算法。这是计算物理学中的一项基本任务，尤其是在分子动力学和蒙特卡洛模拟中。问题陈述在科学上是合理的、定义明确的，并为得出唯一解提供了充分信息。\n\n首先，我们建立理论基础。一个三斜模拟晶胞由三个线性无关的晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义，它们构成了晶格矩阵 $H = [\\mathbf{a}, \\mathbf{b}, \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$ 的列。由于周期性边界条件，一个笛卡尔位置矢量为 $\\mathbf{r}$ 的点具有无限多个等效的周期性镜像，由 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$ 给出，其中 $\\mathbf{n} = (n_1, n_2, n_3)^T$ 是任意整数矢量，$\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n从点 $\\mathbf{r}_i$ 到点 $\\mathbf{r}_j$ 的位移矢量也非唯一。原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。任意等效位移由 $\\Delta \\mathbf{r}' = \\mathbf{r}_j' - \\mathbf{r}_i = (\\mathbf{r}_j + H\\mathbf{n}) - \\mathbf{r}_i = \\Delta \\mathbf{r} + H\\mathbf{n}$ 给出，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。最小镜像约定旨在找到这组矢量中唯一的代表，记为 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$，该代表是“最接近”原点的。在一个通用的三斜晶胞中，这意味着找到位于中心Wigner-Seitz原胞内的矢量，该原胞是空间中比其他任何晶格点都更接近原点晶格点的点的轨迹。\n\n对所有 $\\mathbf{n} \\in \\mathbb{Z}^3$ 直接最小化范数 $\\|\\Delta \\mathbf{r} + H\\mathbf{n}\\|_2$ 在计算上是复杂的。正如问题所建议的，一种更稳健、更高效的方法是在分数（或缩放）坐标中进行操作。一个笛卡尔矢量 $\\mathbf{v}$ 通过线性变换 $\\mathbf{s} = H^{-1} \\mathbf{v}$ 转换为分数坐标 $\\mathbf{s}$。$\\mathbf{s}$ 的分量将 $\\mathbf{v}$ 表示为晶格矢量的线性组合。\n\n让我们将此应用于位移矢量：\n$$\n\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} (\\mathbf{r}_j - \\mathbf{r}_i)\n$$\n位移的任意周期性镜像 $\\Delta \\mathbf{r} - H\\mathbf{n}$ 转换到分数坐标如下：\n$$\nH^{-1} (\\Delta \\mathbf{r} - H\\mathbf{n}) = H^{-1} \\Delta \\mathbf{r} - H^{-1}H\\mathbf{n} = \\mathbf{s} - \\mathbf{n}\n$$\n这表明，在笛卡尔空间中在周期性镜像之间移动等效于将分数坐标矢量平移一个整数矢量。问题现在简化为找到一个整数矢量 $\\mathbf{n}$，使得约化后的分数矢量 $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\mathbf{n}$ 的分量位于分数空间中的中心单位晶胞内。该中心晶胞的标准选择是每个分量的范围为 $[-0.5, 0.5]$。\n\n为了将任意分数坐标分量 $s_k$ 映射到其中心镜像 $s_{k, \\mathrm{MIC}}$，我们必须找到一个整数 $n_k$ 使得 $s_{k, \\mathrm{MIC}} = s_k - n_k \\in [-0.5, 0.5)$。选择一个半开区间，如 $[-0.5, 0.5)$，对于确保唯一映射和解决分量恰好在边界（半整数）上的歧义至关重要。满足此条件的整数 $n_k$ 是最接近 $s_k$ 的整数。这可以通过算法计算。一种找到 $n_k$ 并执行约化的标准且数值稳定的方法是：\n$$\ns_{k, \\mathrm{MIC}} = s_k - \\lfloor s_k + 0.5 \\rfloor\n$$\n此操作正确处理了半整数值的临界情况。例如，如果 $s_k = 2.5$，则 $s_{k, \\mathrm{MIC}} = 2.5 - \\lfloor 2.5 + 0.5 \\rfloor = 2.5 - \\lfloor 3.0 \\rfloor = 2.5 - 3 = -0.5$。如果 $s_k = -1.5$，则 $s_{k, \\mathrm{MIC}} = -1.5 - \\lfloor -1.5 + 0.5 \\rfloor = -1.5 - \\lfloor -1.0 \\rfloor = -1.5 - (-1) = -0.5$。这将上边界 $0.5$ 一致地映射到下边界 $-0.5$，确保约化后的所有分数分量 $s_{k, \\mathrm{MIC}}$ 都位于半开区间 $[-0.5, 0.5)$ 内。这一选择的合理性在于其计算简单性，以及它能保证对任何浮点输入都得到唯一结果。\n\n完整的算法如下：\n$1$. 在笛卡尔坐标系中计算原始位移矢量：$\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。\n$2$. 将 $\\Delta \\mathbf{r}$ 转换为分数坐标：$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$。这需要计算晶格矩阵 $H$ 的逆。\n$3$. 在分数空间中应用最小镜像条件，将每个分量 $s_k$ 约化到区间 $[-0.5, 0.5)$：$\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\lfloor \\mathbf{s} + 0.5 \\rfloor$，其中运算是逐元素执行的。\n$4$. 将约化后的分数矢量转换回笛卡尔坐标：$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}}$。\n$5$. 计算最终矢量的欧几里得范数：$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(\\Delta \\mathbf{r}_{\\mathrm{MIC}}) \\cdot (\\Delta \\mathbf{r}_{\\mathrm{MIC}})}$。\n\n该算法普遍适用于由满秩矩阵 $H$ 描述的任何周期性晶胞，包括正交和一般三斜形式。现在我们将其应用于指定的测试案例。\n\n案例 $1$：$H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$，$\\mathbf{r}_i = (1, 2, 3)$，$\\mathbf{r}_j = (9, 9, 9)$。\n$\\Delta \\mathbf{r} = (8, 7, 6)$。\n$H^{-1} = \\begin{bmatrix} 0.1  0  0 \\\\ 0  0.1  0 \\\\ 0  0  0.1 \\end{bmatrix}$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = (0.8, 0.7, 0.6)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.8 - 1, 0.7 - 1, 0.6 - 1) = (-0.2, -0.3, -0.4)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-2, -3, -4)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-2)^2+(-3)^2+(-4)^2} = \\sqrt{29} \\approx 5.385165$。\n\n案例 $2$：$H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$，$\\mathbf{r}_i = (1, 1, 1)$，$\\mathbf{r}_j = (9, 7, 5)$。\n$\\Delta \\mathbf{r} = (8, 6, 4)$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (0.6, 0.666667, 0.666667)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.6 - 1, 0.666667 - 1, 0.666667 - 1) = (-0.4, -0.333333, -0.333333)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5, -3, -2)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5)^2+(-3)^2+(-2)^2} = \\sqrt{38} \\approx 6.164414$。\n\n案例 $3$：$H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$，$\\mathbf{r}_i = (0, 0, 0)$，$\\mathbf{r}_j = H(0.5, -0.5, 0.5)^T$。\n$\\Delta \\mathbf{r} = \\mathbf{r}_j$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} \\mathbf{r}_j = (0.5, -0.5, 0.5)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.5 - \\lfloor 1.0 \\rfloor, -0.5 - \\lfloor 0.0 \\rfloor, 0.5 - \\lfloor 1.0 \\rfloor) = (-0.5, -0.5, -0.5)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5.5, -4.0, -4.5)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5.5)^2+(-4)^2+(-4.5)^2} = \\sqrt{66.5} \\approx 8.154753$。\n\n案例 $4$：$H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$，$\\mathbf{r}_i = (4.9, 0.1, 0.1)$，$\\mathbf{r}_j = (0.2, 4.9, 0.2)$。\n$\\Delta \\mathbf{r} = (-4.7, 4.8, 0.1)$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (-1.7136, 0.952, 0.02)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (-1.7136 - \\lfloor -1.2136 \\rfloor, 0.952 - \\lfloor 1.452 \\rfloor, 0.02 - \\lfloor 0.52 \\rfloor) = (0.2864, -0.048, 0.02)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (1.3, -0.2, 0.1)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{1.3^2+(-0.2)^2+0.1^2} = \\sqrt{1.74} \\approx 1.319091$。\n\n实现将遵循此推导过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Minimum Image Convention displacement for a series of test cases\n    in triclinic periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"r_i\": np.array([1.0, 2.0, 3.0]),\n            \"r_j\": np.array([9.0, 9.0, 9.0])\n        },\n        {\n            \"H\": np.array([\n                [10.0, 2.0, 1.0],\n                [0.0, 8.0, 1.0],\n                [0.0, 0.0, 6.0]\n            ]),\n            \"r_i\": np.array([1.0, 1.0, 1.0]),\n            \"r_j\": np.array([9.0, 7.0, 5.0])\n        },\n        {\n            \"H\": np.array([\n                [8.0, 1.0, 2.0],\n                [0.0, 7.0, 1.0],\n                [0.0, 0.0, 9.0]\n            ]),\n            \"r_i\": np.array([0.0, 0.0, 0.0]),\n            \"r_j\": np.dot(\n                np.array([\n                    [8.0, 1.0, 2.0],\n                    [0.0, 7.0, 1.0],\n                    [0.0, 0.0, 9.0]\n                ]),\n                np.array([0.5, -0.5, 0.5])\n            )\n        },\n        {\n            \"H\": np.array([\n                [5.0, 4.0, 3.0],\n                [0.0, 5.0, 2.0],\n                [0.0, 0.0, 5.0]\n            ]),\n            \"r_i\": np.array([4.9, 0.1, 0.1]),\n            \"r_j\": np.array([0.2, 4.9, 0.2])\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        H = case[\"H\"]\n        r_i = case[\"r_i\"]\n        r_j = case[\"r_j\"]\n\n        # Step 1: Calculate the raw displacement vector in Cartesian coordinates.\n        delta_r = r_j - r_i\n\n        # Step 2: Convert delta_r to fractional coordinates.\n        H_inv = np.linalg.inv(H)\n        s = H_inv @ delta_r\n\n        # Step 3: Apply the minimum image condition in fractional space.\n        # This maps each component to the interval [-0.5, 0.5).\n        # s_mic = s - n, where n is the nearest integer vector to s.\n        # This is equivalent to s_mic = s - round(s).\n        # A numerically stable way to implement rounding to the nearest integer\n        # with a consistent tie-breaking rule (x.5 -> x-1) is s - floor(s + 0.5)\n        s_mic = s - np.floor(s + 0.5)\n\n        # Step 4: Convert the reduced fractional vector back to Cartesian coordinates.\n        delta_r_mic = H @ s_mic\n\n        # Step 5: Compute the Euclidean norm of the final vector.\n        norm_mic = np.linalg.norm(delta_r_mic)\n\n        # Format the result for the final output string.\n        result_vector = [\n            delta_r_mic[0],\n            delta_r_mic[1],\n            delta_r_mic[2],\n            norm_mic\n        ]\n        \n        # Round each number to 6 decimal places and format as a string list.\n        formatted_vector = [f\"{val:.6f}\" for val in result_vector]\n        results_as_strings.append(f\"[{','.join(formatted_vector)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分子模拟中，为了提高计算效率，通常会为粒子间的相互作用设定一个截断半径$r_c$。然而，这引入了一个必须满足的关键条件，即“半晶胞条件”，以确保每个粒子对的相互作用只被计算一次。这个练习将让你从基本原理出发，推导并实现一个判据，用于检测给定的晶格和截断半径是否可能违反此条件，这对于确保模拟的物理正确性至关重要。",
            "id": "3780156",
            "problem": "考虑一个三维周期性域，它由一个布拉维晶格表示，其晶胞矩阵为 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$，该矩阵的列是三个线性无关的晶胞向量。在周期性边界条件下，$\\mathbb{R}^{3}$ 中相差一个晶格矢量 $\\mathbf{A}\\mathbf{m}$（其中 $\\mathbf{m} \\in \\mathbb{Z}^{3}$）的两个点被视为同一点。对于任意一对粒子位置 $\\mathbf{x}_i, \\mathbf{x}_j \\in \\mathbb{R}^{3}$，定义原始分离矢量 $\\mathbf{r} = \\mathbf{x}_j - \\mathbf{x}_i$。该分离矢量的所有周期性镜像的集合为 $\\{\\mathbf{r} + \\mathbf{A}\\mathbf{m} : \\mathbf{m} \\in \\mathbb{Z}^{3}\\}$。最小镜像约定 (Minimum Image Convention, MIC) 为了计算对相互作用，会选择具有最小欧几里得范数的镜像，即镜像 $\\mathbf{r} + \\mathbf{A}\\mathbf{m}^\\ast$，使得 $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}^\\ast \\rVert$ 在所有 $\\mathbf{m} \\in \\mathbb{Z}^{3}$ 上最小。在多尺度建模与分析中，人们通常会截断超出截断半径 $r_c  0$ 的对相互作用，并假设对于所有 MIC 距离小于 $r_c$ 的分离矢量，MIC 是无歧义的。所谓的“半箱条件”是一个充分的几何条件，旨在确保对于任意一对粒子，其分离矢量在以原点为中心、半径为 $r_c$ 的球体内最多只有一个周期性镜像，从而避免相互作用的重复计算。\n\n仅从欧几里得范数 $\\lVert \\cdot \\rVert$、晶格周期性和三角不等式的核心定义出发，推导一个计算判据，以检测给定的晶格 $\\mathbf{A}$ 和截断半径 $r_c$ 何时会违反半箱条件。违反的定义如下：存在一个原始分离矢量 $\\mathbf{r}$，使得存在至少两个不同的晶格平移 $\\mathbf{m}_1 \\neq \\mathbf{m}_2$，同时满足 $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}_1 \\rVert  r_c$ 和 $\\lVert \\mathbf{r} + \\mathbf{A}\\mathbf{m}_2 \\rVert  r_c$。你的程序必须通过在一个有界范围内穷举搜索具有整数分量的非零晶格矢量 $\\mathbf{A}\\mathbf{m}$ 来实现此判据，并仅根据晶格几何和 $r_c$ 返回一个违规是否“原则上”可能发生。对边界上的相等情况采取保守处理：如果几何条件在相等时恰好满足，则将其视为一次违规。\n\n实现以下算法任务：\n1. 对于每个测试用例，枚举所有整数矢量 $\\mathbf{m} = (m_1,m_2,m_3) \\in \\mathbb{Z}^{3}$，其中每个分量都在范围 $[-2,2]$ 内且 $\\mathbf{m} \\neq \\mathbf{0}$，计算晶格矢量 $\\mathbf{A}\\mathbf{m}$ 及其欧几里得范数 $\\lVert \\mathbf{A}\\mathbf{m} \\rVert$。\n2. 在枚举的范围内，计算最小的非零晶格矢量长度 $d_{\\min} = \\min_{\\mathbf{m} \\neq \\mathbf{0}} \\lVert \\mathbf{A}\\mathbf{m} \\rVert$。\n3. 确定测试用例的布尔结果“violation”，当且仅当枚举集合中存在至少一个非零晶格矢量，其长度小于或等于 $2 r_c$（等价地，在枚举集合上 $2 r_c \\ge d_{\\min}$）时，该结果定义为 $\\text{True}$，否则为 $\\text{False}$。\n4. 同时计算测试用例的整数“multiplicity count”（重数计数），其定义为枚举集合中长度小于或等于 $2 r_c$ 的不同非零晶格矢量的数量。这个重数计数从最坏情况的几何意义上量化了有多少个不同的晶格平移可能导致在截断半径内出现多个镜像。\n\n输入中的所有长度均以一致的任意单位（例如，纳米）给出，角度以度为单位指定。输出中不出现角度；输出是无量纲的布尔值和整数。你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是对应测试用例的一个双元素列表 $[\\text{violation}, \\text{multiplicity}]$。例如，输出行应类似于 $[[\\text{True},6],[\\text{False},0],\\dots]$，逗号后没有空格。\n\n使用以下测试套件，其设计旨在探究一般情况、边界条件、正交各向异性以及三斜几何：\n- 测试用例 1 (一般的“理想情况”)：$\\mathbf{A} = \\operatorname{diag}(10,10,10)$，$r_c = 4.9$。\n- 测试用例 2 (相等时的边界情况)：$\\mathbf{A} = \\operatorname{diag}(10,10,10)$，$r_c = 5.0$。\n- 测试用例 3 (正交各向异性，安全)：$\\mathbf{A} = \\operatorname{diag}(10,9,8)$，$r_c = 3.9$。\n- 测试用例 4 (正交各向异性，违规)：$\\mathbf{A} = \\operatorname{diag}(10,9,8)$，$r_c = 4.1$。\n- 测试用例 5 (三斜斜晶胞，违规)：$\\mathbf{A}$ 的列向量为 $\\mathbf{a} = (10,0,0)$、$\\mathbf{b} = (10\\cos 30^\\circ, 10\\sin 30^\\circ, 0)$ 和 $\\mathbf{c} = (0,0,10)$，$r_c = 3.0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应每个测试用例的一个双元素列表 $[\\text{violation}, \\text{multiplicity}]$，顺序与上面列出的一致。例如，如果计算结果是这些，你的程序应该打印出类似 $[[\\text{False},0],[\\text{True},6],[\\text{False},0],[\\text{True},2],[\\text{True},2]]$ 的内容。",
            "solution": "问题要求提供一个计算判据，以确定由其晶胞矩阵 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ 定义的给定布拉维晶格和一个相互作用截断半径 $r_c  0$ 是否容易违反半箱条件。违规的定义是：存在一个原始粒子分离矢量 $\\mathbf{r} \\in \\mathbb{R}^3$，其至少有两个不同的周期性镜像位于截断球体内。也就是说，存在两个不同的整数矢量 $\\mathbf{m}_1, \\mathbf{m}_2 \\in \\mathbb{Z}^3$，使得对应的镜像矢量 $\\mathbf{r}'_1 = \\mathbf{r} + \\mathbf{A}\\mathbf{m}_1$ 和 $\\mathbf{r}'_2 = \\mathbf{r} + \\mathbf{A}\\mathbf{m}_2$ 都满足条件 $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$，其中 $\\lVert \\cdot \\rVert$ 是欧几里得范数，且相等情况被视为违规。\n\n为了推导一个仅依赖于晶格几何和 $r_c$ 的判据，我们分析这两个镜像矢量之间的关系。它们的差是一个非零晶格矢量，$\\mathbf{L} = \\mathbf{r}'_2 - \\mathbf{r}'_1 = (\\mathbf{r} + \\mathbf{A}\\mathbf{m}_2) - (\\mathbf{r} + \\mathbf{A}\\mathbf{m}_1) = \\mathbf{A}(\\mathbf{m}_2 - \\mathbf{m}_1)$。我们定义 $\\mathbf{m} = \\mathbf{m}_2 - \\mathbf{m}_1$，由于 $\\mathbf{m}_1 \\neq \\mathbf{m}_2$，$\\mathbf{m}$ 是一个非零整数矢量。这个晶格矢量 $\\mathbf{L}$ 的长度可以用三角不等式来界定：$\\lVert \\mathbf{L} \\rVert = \\lVert \\mathbf{r}'_2 - \\mathbf{r}'_1 \\rVert \\le \\lVert \\mathbf{r}'_2 \\rVert + \\lVert -\\mathbf{r}'_1 \\rVert = \\lVert \\mathbf{r}'_2 \\rVert + \\lVert \\mathbf{r}'_1 \\rVert$。通过代入违规条件 $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$，我们得到必要条件 $\\lVert \\mathbf{L} \\rVert \\le r_c + r_c = 2r_c$。这表明，要发生违规，必须存在至少一个长度小于或等于 $2r_c$ 的非零晶格矢量 $\\mathbf{L} = \\mathbf{A}\\mathbf{m}$。\n\n这个条件也是充分的。假设存在一个非零整数矢量 $\\mathbf{m}$，使得对应的晶格矢量 $\\mathbf{L} = \\mathbf{A}\\mathbf{m}$ 的范数 $\\lVert \\mathbf{L} \\rVert \\le 2r_c$。然后我们可以构造一个特定的原始分离矢量 $\\mathbf{r} = -\\mathbf{L}/2$。对于这个 $\\mathbf{r}$，考虑对应于整数矢量 $\\mathbf{0}$ 和 $\\mathbf{m}$ 的两个周期性镜像。第一个镜像是 $\\mathbf{r}'_1 = \\mathbf{r} + \\mathbf{A}\\mathbf{0} = -\\mathbf{L}/2$，第二个是 $\\mathbf{r}'_2 = \\mathbf{r} + \\mathbf{A}\\mathbf{m} = -\\mathbf{L}/2 + \\mathbf{L} = \\mathbf{L}/2$。这两个镜像的范数是相同的：$\\lVert \\mathbf{r}'_1 \\rVert = \\lVert \\mathbf{r}'_2 \\rVert = \\lVert \\mathbf{L} \\rVert / 2$。由于我们假设 $\\lVert \\mathbf{L} \\rVert \\le 2r_c$，因此可得 $\\lVert \\mathbf{r}'_1 \\rVert \\le r_c$ 和 $\\lVert \\mathbf{r}'_2 \\rVert \\le r_c$。这证实了在截断球体内存在两个不同的镜像，从而构成违规。\n\n因此，当且仅当存在一个非零整数矢量 $\\mathbf{m} \\in \\mathbb{Z}^3$ 使得 $\\lVert \\mathbf{A}\\mathbf{m} \\rVert \\le 2r_c$ 时，才可能违反半箱条件。这是一个纯粹关于晶格和截断半径的几何条件。问题简化为寻找这样一个晶格矢量。对于行为良好的模拟，标准的“半箱条件”是 $d_{\\min}  2r_c$，其中 $d_{\\min} = \\min_{\\mathbf{m} \\in \\mathbb{Z}^3, \\mathbf{m}\\neq\\mathbf{0}} \\lVert \\mathbf{A}\\mathbf{m} \\rVert$。我们的任务是检测违规，这对应于 $d_{\\min} \\le 2r_c$。\n\n指定的算法基于此判据在一个有限的搜索空间内实现了一个直接搜索。对于每个测试用例 $(\\mathbf{A}, r_c)$，我们枚举所有非零整数矢量 $\\mathbf{m}=(m_1, m_2, m_3)$，其中每个分量 $m_i$ 的范围为 [-$2$,$2$]。这个有限的搜索空间包含 $5^3 - 1 = 124$ 个矢量。对于每个这样的 $\\mathbf{m}$，我们计算晶格矢量 $\\mathbf{v} = \\mathbf{A}\\mathbf{m}$ 及其欧几里得范数 $\\lVert \\mathbf{v} \\rVert$。然后将此范数与阈值 $2r_c$ 进行比较。如果发现至少有一个晶格矢量满足 $\\lVert \\mathbf{v} \\rVert \\le 2r_c$，则布尔值 `violation` 结果设置为 `True`，否则设置为 `False`。整数 `multiplicity count`（重数计数）是搜索范围内满足此条件的非零整数矢量 $\\mathbf{m}$ 的总数。此计数用于量化可能导致违规的短晶格矢量的数量。该实现使用 `numpy` 库进行所有线性代数运算。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the problem of checking for half-box condition violations for a given\n    set of lattice matrices and cutoff radii.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Each tuple contains:\n    # 1. A function to generate the lattice matrix A.\n    # 2. The cutoff radius rc.\n    test_cases = [\n        (lambda: np.diag([10.0, 10.0, 10.0]), 4.9),\n        (lambda: np.diag([10.0, 10.0, 10.0]), 5.0),\n        (lambda: np.diag([10.0, 9.0, 8.0]), 3.9),\n        (lambda: np.diag([10.0, 9.0, 8.0]), 4.1),\n        (lambda: np.array([\n            [10.0, 10.0 * np.cos(np.deg2rad(30)), 0.0],\n            [0.0, 10.0 * np.sin(np.deg2rad(30)), 0.0],\n            [0.0, 0.0, 10.0]\n        ]).T, 3.0),\n    ]\n\n    # The range for integer vector components m_i.\n    m_range = range(-2, 3)\n    \n    # Generate all integer vectors m in the search cube, excluding the zero vector.\n    m_vectors = [\n        np.array(m, dtype=int) for m in itertools.product(m_range, repeat=3) if not all(c == 0 for c in m)\n    ]\n\n    results = []\n    \n    for A_func, rc in test_cases:\n        A = A_func()\n        threshold = 2.0 * rc\n        \n        multiplicity = 0\n        \n        for m in m_vectors:\n            # Compute the lattice vector v = A * m\n            v = A @ m\n            \n            # Compute the Euclidean norm of v\n            norm_v = np.linalg.norm(v)\n            \n            # Check if the norm is within the violation threshold\n            # Floating point comparisons are handled carefully by the problem's\n            # clear \"less than or equal to\" directive.\n            if norm_v = threshold:\n                multiplicity += 1\n\n        violation = multiplicity > 0\n        results.append([violation, multiplicity])\n    \n    # Format the output string as per the problem specification.\n    # e.g., [[False,0],[True,6],[False,0],[True,2],[True,2]]\n    # str(list).replace(' ', '') is used to remove spaces from the default list string representation.\n    output_str = f\"[{','.join([str(res).replace(' ', '', 1).replace(' ', '') for res in results])}]\"\n    print(output_str)\n\n```"
        }
    ]
}