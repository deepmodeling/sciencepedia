{
    "hands_on_practices": [
        {
            "introduction": "在NPT系综中，除了粒子坐标，模拟盒的体积也是一个动态变量。为了确保模拟能够正确地抽样该系综的平衡态分布，我们必须为体积变化的试探移动设计一个满足细致平衡条件的接收准则。这个练习  将引导你从第一性原理出发，运用Metropolis-Hastings算法推导在对数体积空间中进行均匀抽样时的接收概率，这有助于你深入理解状态概率密度、提议概率以及坐标变换的雅可比行列式在蒙特卡洛模拟中的核心作用。",
            "id": "320670",
            "problem": "在等压等温（NPT）系综的蒙特卡洛模拟中，除了粒子坐标外，模拟盒子的体积 $V$ 也是一个涨落变量。系统的一个状态由体积 $V$ 和一组标度化粒子坐标 $\\mathbf{s}^N$ 描述，其中 $\\mathbf{s}_i \\in [0, 1)^3$ 通过 $\\mathbf{r}_i = L \\mathbf{s}_i$（$V=L^3$）与真实坐标 $\\mathbf{r}_i$ 相关联。系统处于状态 $(\\mathbf{s}^N, V)$ 的平衡概率密度 $\\pi(\\mathbf{s}^N, V)$ 由下式给出：\n$$\n\\pi(\\mathbf{s}^N, V) \\propto V^N \\exp\\left[-\\beta\\left(U(\\mathbf{s}^N, V) + PV\\right)\\right]\n$$\n此处，$N$ 是粒子数，$P$ 是恒定的外压，$\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆温度，$U(\\mathbf{s}^N, V)$ 是系统在真实粒子位置 $\\mathbf{r}^N = V^{1/3}\\mathbf{s}^N$ 处计算的势能。\n\nNPT模拟中一种常见的蒙特卡洛移动是各向同性体积改变，其中系统尝试从一个旧状态 $o = (\\mathbf{s}^N, V_o)$ 跃迁到一个新状态 $n = (\\mathbf{s}^N, V_n)$。注意，在此移动过程中，标度化坐标 $\\mathbf{s}^N$ 保持不变。这种移动的接受概率由 Metropolis-Hastings 准则给出：\n$$\nA(o \\to n) = \\min\\left(1, \\frac{\\pi(n)}{\\pi(o)}\\frac{g(n \\to o)}{g(o \\to n)}\\right)\n$$\n其中 $g(i \\to j)$ 是从状态 $i$ 生成状态 $j$ 的提议概率。\n\n考虑一种特定的体积改变提议方案，其中新体积 $V_n$ 是通过对体积的*对数*进行随机扰动，从旧体积 $V_o$ 生成的。具体来说，从一个对称概率分布 $f(\\xi)$（即 $f(\\xi) = f(-\\xi)$）中抽取一个随机数 $\\xi$，新体积由关系式 $\\ln V_n = \\ln V_o + \\xi$ 决定。\n\n推导这种特定体积移动的接受概率的参数。该参数是 $\\min(1, \\cdot)$ 函数内的第二项。用初始和最终体积（$V_o, V_n$）、势能变化 $\\Delta U = U(\\mathbf{s}^N, V_n) - U(\\mathbf{s}^N, V_o)$、体积变化 $\\Delta V = V_n - V_o$、粒子数 $N$、压力 $P$ 和逆温度 $\\beta$ 来表示你的最终答案。",
            "solution": "1. 平衡权重比  \n$$\n\\frac{\\pi(n)}{\\pi(o)}\n=\\frac{V_n^N\\exp\\bigl[-\\beta\\bigl(U_n+P\\,V_n\\bigr)\\bigr]}{V_o^N\\exp\\bigl[-\\beta\\bigl(U_o+P\\,V_o\\bigr)\\bigr]}\n=\\Bigl(\\frac{V_n}{V_o}\\Bigr)^N\\exp\\bigl[-\\beta\\bigl(\\Delta U+P\\,\\Delta V\\bigr)\\bigr].\n$$\n\n2. 提议概率  \n对于 $\\ln V_n=\\ln V_o+\\xi$ 和对称的 $f(\\xi)$，\n$$\ng(o\\to n)=f(\\xi)\\Bigl|\\frac{d\\xi}{dV_n}\\Bigr|=f(\\xi)\\frac1{V_n},\\qquad\ng(n\\to o)=f(-\\xi)\\frac1{V_o}=f(\\xi)\\frac1{V_o}.\n$$\n因此\n$$\n\\frac{g(n\\to o)}{g(o\\to n)}=\\frac{1/V_o}{1/V_n}=\\frac{V_n}{V_o}.\n$$\n\n3. 接受率  \n$$\n\\frac{\\pi(n)}{\\pi(o)}\\frac{g(n\\to o)}{g(o\\to n)}\n=\\Bigl(\\frac{V_n}{V_o}\\Bigr)^N\\exp\\bigl[-\\beta(\\Delta U+P\\Delta V)\\bigr]\\times\\frac{V_n}{V_o}\n=\\Bigl(\\frac{V_n}{V_o}\\Bigr)^{N+1}\\exp\\bigl[-\\beta(\\Delta U+P\\Delta V)\\bigr].\n$$",
            "answer": "$$\\boxed{\\left(\\frac{V_n}{V_o}\\right)^{N+1}\\exp\\!\\left[-\\beta\\bigl(\\Delta U+P\\,\\Delta V\\bigr)\\right]}$$"
        },
        {
            "introduction": "真实世界的分子并非简单的质点，它们具有特定的结构和刚性或半刚性的键。在NPT模拟中对这类系统进行体积缩放时，简单地按比例调整所有原子坐标会破坏这些内部约束。因此，我们需要一种既能改变系统体积，又能保持分子内部几何形状不变的特殊坐标更新方案。这个高级练习  挑战你为包含刚性分子的系统推导正确的接收准则，并设计和实现一个保持约束的坐标更新算法。完成这个练习将让你掌握处理多原子分子和维持复杂系统完整性的关键技术。",
            "id": "3783187",
            "problem": "您需要设计并实现一个程序，该程序在保持完整刚性键约束和周期性边界条件的同时，模拟恒定粒子数、压强和温度 (NPT) 系综中的各向同性体积改变试验。目标是在盒子缩放后构建一种保持约束的坐标更新方法，该方法能保证在周期性边界条件下刚性键仍然得到精确满足，并计算与该试验相关的广义 Metropolis 接受指数，同时考虑强制执行约束所需的任何附加能量项。\n\n从统计力学和约束动力学中的以下基础出发：\n- 等温等压系综 (NPT) 由构型空间和体积上的概率密度定义，该概率密度与焓的玻尔兹曼因子成正比，其构型空间测度在坐标变换下会发生改变。\n- 完整约束将构型限制在由等式关系指定的流形上，并且约束平衡测度包含一个与约束流形相关的度规行列式因子。\n- 在各向同性盒子缩放中，边长为 $L$ 的立方体盒子的线性尺寸按因子 $\\gamma$ 进行缩放，因此新的边长为 $L' = \\gamma L$，体积变换为 $V' = \\gamma^{3} V$。\n- 对于刚性分子集合，一个物理上一致的选择是仅缩放质心，并保持内坐标（例如，刚性键长）不变，从而在体积移动后精确地强制执行约束。\n\n您的任务是：\n1. 基于上述基础，推导一个 Metropolis 试验的接受指数。该试验提议通过因子 $\\gamma$ 进行各向同性盒子缩放，并使用一种保持约束的规则来更新位置，其中只有刚性基团的质心被缩放，而内坐标保持不变。您必须明确地考虑：\n   - 势能的变化量 $\\Delta U$。\n   - 抵抗压强所做的机械功 $\\Delta W = p\\,\\Delta V$。\n   - 因缩放刚性基团的平移自由度而引起的构型空间测度的变化。\n   - 强制执行完整约束所需的任何额外贡献（例如，度规行列式项），以及这些项在指定的更新下是否发生变化。\n   接受指数必须用温度 $T$、玻尔兹曼常数 $k_{\\mathrm{B}}$、压强 $p$、初始和最终体积 $V$ 和 $V'$，以及独立平移的刚性基团（例如，分子）的数量 $M$ 来表示。不要假设为点粒子；将刚性基团视为基本平移实体。\n\n2. 构建一个算法，在给定一组原子位置、一个刚性基团列表（每个基团由其原子的索引指定）和一组刚性键（具有固定长度的原子索引对）的情况下，通过因子 $\\gamma$ 执行各向同性盒子重缩放，并更新位置，以使得：\n   - 移动后刚性键仍然被精确满足。\n   - 立方体盒子中的周期性边界条件得以保持，在检查约束时使用最小镜像约定。\n   您的方法必须科学上合理且数值上稳健，避免不切实际的假设。\n\n3. 在一个完整的、可运行的程序中实现推导出的接受指数和保持约束的更新方法。程序必须为每个测试用例计算接受指数，并验证所有刚性键在容差范围内均得到满足。\n\n使用以下具有指定参数和单位的测试套件。所有能量单位为焦耳（$\\mathrm{J}$），压强为帕斯卡（$\\mathrm{Pa}$），长度为米（$\\mathrm{m}$），体积为立方米（$\\mathrm{m^3}$），温度为开尔文（$\\mathrm{K}$）。不使用角度。将最终程序输出表示为不带单位的十进制浮点数。\n\n- 测试用例 1（正常路径）：\n  - 温度 $T = 300$。\n  - 玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}$。\n  - 压强 $p = 1.0\\times 10^{5}$。\n  - 初始立方体盒边长 $L = 5.0\\times 10^{-9}$，因此 $V = L^{3}$。\n  - 各向同性缩放因子 $\\gamma = 1.02$，因此 $L' = \\gamma L$ 且 $V' = L'^{3}$。\n  - 两个刚性双原子分子 ($M = 2$)，每个键长为 $1.0\\times 10^{-10}$。\n  - 势能变化 $\\Delta U = -2.0\\times 10^{-21}$。\n\n- 测试用例 2（体积减小）：\n  - 几何结构和常数与测试用例 1 相同，但 $\\gamma = 0.98$ 且 $\\Delta U = 1.5\\times 10^{-21}$。\n\n- 测试用例 3（恒等移动边界）：\n  - 几何结构和常数与测试用例 1 相同，但 $\\gamma = 1.00$ 且 $\\Delta U = 0.0$。\n\n- 测试用例 4（混合组成和不同的压强/温度）：\n  - 温度 $T = 310$。\n  - 玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}$。\n  - 压强 $p = 5.0\\times 10^{5}$。\n  - 初始立方体盒边长 $L = 6.0\\times 10^{-9}$，因此 $V = L^{3}$。\n  - 各向同性缩放因子 $\\gamma = 1.05$，因此 $L' = \\gamma L$ 且 $V' = L'^{3}$。\n  - 一个具有两个长度为 $1.0\\times 10^{-10}$ 的刚性键的刚性三原子基团和一个自由原子，总共提供 $M = 2$ 个平移实体。\n  - 势能变化 $\\Delta U = -1.0\\times 10^{-21}$。\n\n对于每个测试用例，您的程序必须：\n- 在各向同性盒子缩放后执行保持约束的位置更新。\n- 验证所有指定的刚性键在最小镜像约定下，在 $\\mathrm{m}$ 为单位的 $1.0\\times 10^{-12}$ 容差范围内均得到满足。\n- 计算在任务 1 中推导出的接受指数。\n- 将所有测试用例的接受指数收集到一个列表中。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是十进制浮点数。不得打印任何其他文本。",
            "solution": "该问题要求推导 NPT（等温等压）系综中刚性分子系统各向同性体积变化的 Metropolis-Hastings 接受指数，并实现一个相应的保持约束的坐标更新算法。\n\n### 1. 接受指数的推导\n\n从旧状态 `o` 到新状态 `n` 的试验移动的 Metropolis-Hastings 接受概率由以下公式给出：\n$$\nA(o \\rightarrow n) = \\min\\left(1, \\frac{\\mathcal{P}(n) T(n \\rightarrow o)}{\\mathcal{P}(o) T(o \\rightarrow n)}\\right)\n$$\n其中 $\\mathcal{P}(x)$ 是状态 $x$ 的概率，$T(x \\rightarrow y)$ 是从 $x$ 提议移动到 $y$ 的转移概率。接受指数是该比值的自然对数，即 $X = \\ln\\left(\\frac{\\mathcal{P}(n) T(n \\rightarrow o)}{\\mathcal{P}(o) T(o \\rightarrow n)}\\right)$。\n\n**NPT 系综中的状态概率**\n在 NPT 系综中，一个微观状态由粒子坐标 $\\mathbf{r}^N$ 和系统体积 $V$ 定义。概率密度与焓 $H = U(\\mathbf{r}^N) + pV$ 的玻尔兹曼因子成正比。对于一个由 $M$ 个独立平移的刚性基团（例如，分子或自由原子）组成的系统，与体积缩放移动相关的坐标是这些基团的质心 (COM)，即 $\\{\\mathbf{R}_k\\}_{k=1}^M$。每个基团的内坐标不受所提议移动的影响。\n\n这样一个系统在 NPT 系综中的配分函数由下式给出：\n$$\n\\Delta(N, p, T) \\propto \\int dV \\exp(-\\beta pV) \\int_V d\\mathbf{R}^M \\int d\\mathbf{\\Omega}^M \\exp(-\\beta U(\\{\\mathbf{R}_k\\}, \\{\\mathbf{\\Omega}_k\\}))\n$$\n其中 $\\beta = 1/(k_{\\mathrm{B}}T)$，$\\{\\mathbf{R}_k\\}$ 是 $M$ 个质心坐标，$\\{\\mathbf{\\Omega}_k\\}$ 是取向/内坐标。积分元 $d\\mathbf{r}^N$ 可以分离为平移和内部部分，$d\\mathbf{r}^N = d\\mathbf{R}^M d\\mathbf{\\Omega}^M$（不计常数）。\n\n观察到微观状态 $(\\{\\mathbf{R}_k\\}, \\{\\mathbf{\\Omega}_k\\}, V)$ 的概率与被积函数成正比：\n$$\n\\mathcal{P}(\\{\\mathbf{R}_k\\}, \\{\\mathbf{\\Omega}_k\\}, V) d\\mathbf{R}^M d\\mathbf{\\Omega}^M dV \\propto \\exp(-\\beta(U + pV)) d\\mathbf{R}^M d\\mathbf{\\Omega}^M dV\n$$\n\n**试验移动和坐标变换**\n试验移动包括：\n1.  将盒子体积从 $V$ 缩放到 $V' = \\gamma^3 V$，其中 $\\gamma$ 是一个缩放因子。这意味着盒子边长从 $L$ 缩放到 $L' = \\gamma L$。\n2.  缩放 $M$ 个刚性基团的质心坐标：$\\mathbf{R}_k \\rightarrow \\mathbf{R}_k' = \\gamma \\mathbf{R}_k$。\n3.  保持内坐标（因此也包括取向 $\\mathbf{\\Omega}_k$）不变。\n\n该移动旨在保持每个刚性基团内部的完整约束。由于内部键矢量是由原子相对于质心的位置差定义的，而这些位置差不被缩放，因此键长保持不变。因此，与这些内部约束相关的任何度规行列式因子（Fixman 势）也保持不变，并在接受比中被抵消。\n\n**变换的雅可比行列式**\n概率密度之比取决于坐标变换的雅可比行列式。微分体积元变换如下：\n$$\nd\\mathbf{R}'^M = \\left| \\frac{\\partial \\mathbf{R}'^M}{\\partial \\mathbf{R}^M} \\right| d\\mathbf{R}^M\n$$\n由于对于 $M$ 个基团中的每一个，都有 $\\mathbf{R}_k' = \\gamma \\mathbf{R}_k$，该变换是对一个 $3M$ 维向量的缩放，缩放因子为 $\\gamma$。雅可比行列式为：\n$$\n\\left| \\frac{\\partial \\mathbf{R}'^M}{\\partial \\mathbf{R}^M} \\right| = \\det(\\gamma \\mathbf{I}_{3M}) = \\gamma^{3M}\n$$\n其中 $\\mathbf{I}_{3M}$ 是 $3M \\times 3M$ 的单位矩阵。元素 $d\\mathbf{\\Omega}^M$ 和 $dV$ 是独立的积分变量。\n\n**组合接受比**\n状态概率之比为：\n$$\n\\frac{\\mathcal{P}(n)}{\\mathcal{P}(o)} = \\frac{\\exp(-\\beta(U' + pV')) d\\mathbf{R}'^M d\\mathbf{\\Omega}'^M dV'}{\\exp(-\\beta(U + pV)) d\\mathbf{R}^M d\\mathbf{\\Omega}^M dV}\n$$\n代入 $d\\mathbf{R}'^M = \\gamma^{3M} d\\mathbf{R}^M$ 并注意到 $d\\mathbf{\\Omega}'^M = d\\mathbf{\\Omega}^M$：\n$$\n\\frac{\\mathcal{P}(n)}{\\mathcalP(o)} = \\exp(-\\beta(\\Delta U + p \\Delta V)) \\gamma^{3M}\n$$\n其中 $\\Delta U = U' - U$ 且 $\\Delta V = V' - V$。\n\n因子 $\\gamma^{3M}$ 可以用体积重新表示：\n$$\nV' = \\gamma^3 V \\implies \\gamma^3 = \\frac{V'}{V} \\implies \\gamma^{3M} = \\left(\\frac{V'}{V}\\right)^M = \\exp\\left(M \\ln\\left(\\frac{V'}{V}\\right)\\right)\n$$\n假设体积变化的提议概率是对称的（例如，从围绕 $\\ln V$ 的对称分布中提议 $\\ln V'$），则转移概率比 $T(n \\rightarrow o)/T(o \\rightarrow n)$ 为 1。\n接受指数 $X$ 是上述比值的对数：\n$$\nX = \\ln\\left( \\exp(-\\beta(\\Delta U + p \\Delta V)) \\exp\\left(M \\ln\\left(\\frac{V'}{V}\\right)\\right) \\right)\n$$\n$$\nX = -\\frac{\\Delta U + p(V' - V)}{k_{\\mathrm{B}}T} + M \\ln\\left(\\frac{V'}{V}\\right)\n$$\n这是接受指数的最终表达式。它正确地依赖于 $M$，即独立平移的刚性基团的数量，而不是原子总数 $N$。\n\n### 2. 保持约束的坐标更新算法\n\n该算法在各向同性体积缩放后更新原子位置，同时保持刚性键长和周期性边界条件 (PBC)。\n\n**输入：**\n-   初始原子位置：$\\{\\mathbf{r}_i\\}_{i=1}^N$。\n-   初始立方体盒边长：$L$。\n-   缩放因子：$\\gamma$。\n-   刚性基团列表，其中每个基团是一个原子索引列表。\n-   刚性键列表（用于验证）。\n-   原子质量（如果非均匀，否则可忽略）。假设质量均匀，则质心为几何中心。\n\n**算法：**\n1.  计算新的盒子边长 $L' = \\gamma L$。\n2.  为新的原子位置 $\\mathbf{r}'$ 创建一个数组。\n3.  对于每个刚性基团 $k \\in \\{1, \\dots, M\\}$：\n    a.  **展开坐标**：为了正确计算可能被周期性边界条件分割的分子的质心 (COM)，必须将其原子置于一个连续的表示中。\n        i.   在基团中选择一个参考原子，例如第一个原子，其位置为 $\\mathbf{r}_{\\text{ref}}$。\n        ii.  对于基团中的每个其他原子 $j$，计算位移矢量 $\\mathbf{d}_j = \\mathbf{r}_j - \\mathbf{r}_{\\text{ref}}$。\n        iii. 对 $\\mathbf{d}_j$ 应用关于旧盒子长度 $L$ 的最小镜像约定。最小镜像位移为 $\\mathbf{d}_{j, \\text{mic}} = \\mathbf{d}_j - L \\cdot \\text{round}(\\mathbf{d}_j / L)$。\n        iv.  原子 $j$ 的展开位置为 $\\mathbf{r}_{j,\\text{unwrapped}} = \\mathbf{r}_{\\text{ref}} + \\mathbf{d}_{j, \\text{mic}}$。参考原子的展开位置即为其原始位置。\n    b.  **计算质心**：计算展开后原子位置的质心 $\\mathbf{R}_k$。对于均匀质量：$\\mathbf{R}_k = \\frac{1}{N_k} \\sum_{j \\in \\text{group } k} \\mathbf{r}_{j, \\text{unwrapped}}$，其中 $N_k$ 是基团 $k$ 中的原子数。\n    c.  **缩放质心**：计算新的质心位置：$\\mathbf{R}_k' = \\gamma \\mathbf{R}_k$。\n    d.  **更新原子位置**：对于基团中的每个原子 $j$：\n        i.   找到其相对于旧质心的位置矢量：$\\mathbf{u}_j = \\mathbf{r}_{j, \\text{unwrapped}} - \\mathbf{R}_k$。\n        ii.  新的展开位置为 $\\mathbf{r}'_{j, \\text{unwrapped}} = \\mathbf{R}_k' + \\mathbf{u}_j$。\n        iii. **重新包裹坐标**：将新的展开位置折叠回新的周期性盒子中：$\\mathbf{r}'_j = \\mathbf{r}'_{j, \\text{unwrapped}} - L' \\cdot \\text{floor}(\\mathbf{r}'_{j, \\textunwrapped} / L')$。存储 $\\mathbf{r}'_j$。\n\n4.  对所有基团重复此过程。集合 $\\{\\mathbf{r}'_j\\}$ 是最终的坐标集。\n\n**验证：**\n为验证该算法，对于原子 $i$ 和 $j$ 之间每个指定的原始长度为 $d_{ij}$ 的刚性键：\n1.  获取新位置 $\\mathbf{r}'_i$ 和 $\\mathbf{r}'_j$。\n2.  计算新的位移矢量 $\\mathbf{v}' = \\mathbf{r}'_i - \\mathbf{r}'_j$。\n3.  使用新盒子长度 $L'$ 对 $\\mathbf{v}'$ 应用最小镜像约定，得到 $\\mathbf{v}'_{\\text{mic}}$。\n4.  计算新的键长 $d'_{ij} = ||\\mathbf{v}'_{\\text{mic}}||$。\n5.  确认 $|d'_{ij} - d_{ij}|$ 小于一个很小的数值容差。所有键都应通过此检查。\n\n此过程确保刚性基团的内部结构被完美保留，而其质心随盒子一起缩放，从而满足 NPT 移动的前提条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing the NPT acceptance exponent for rigid bodies\n    and verifying the constraint-preserving coordinate update algorithm.\n    \"\"\"\n    \n    # Define physical constant\n    KB = 1.380649e-23  # Boltzmann constant in J/K\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 300.0,\n            \"p\": 1.0e5,\n            \"L\": 5.0e-9,\n            \"gamma\": 1.02,\n            \"M\": 2,\n            \"delta_U\": -2.0e-21,\n            \"groups\": [[0, 1], [2, 3]],\n            \"bonds\": [(0, 1), (2, 3)],\n            \"bond_lengths\": {(0, 1): 1.0e-10, (2, 3): 1.0e-10}\n        },\n        {\n            \"T\": 300.0,\n            \"p\": 1.0e5,\n            \"L\": 5.0e-9,\n            \"gamma\": 0.98,\n            \"M\": 2,\n            \"delta_U\": 1.5e-21,\n            \"groups\": [[0, 1], [2, 3]],\n            \"bonds\": [(0, 1), (2, 3)],\n            \"bond_lengths\": {(0, 1): 1.0e-10, (2, 3): 1.0e-10}\n        },\n        {\n            \"T\": 300.0,\n            \"p\": 1.0e5,\n            \"L\": 5.0e-9,\n            \"gamma\": 1.00,\n            \"M\": 2,\n            \"delta_U\": 0.0,\n            \"groups\": [[0, 1], [2, 3]],\n            \"bonds\": [(0, 1), (2, 3)],\n            \"bond_lengths\": {(0, 1): 1.0e-10, (2, 3): 1.0e-10}\n        },\n        {\n            \"T\": 310.0,\n            \"p\": 5.0e5,\n            \"L\": 6.0e-9,\n            \"gamma\": 1.05,\n            \"M\": 2,\n            \"delta_U\": -1.0e-21,\n            \"groups\": [[0, 1, 2], [3]],\n            \"bonds\": [(0, 1), (0, 2)],\n            \"bond_lengths\": {(0, 1): 1.0e-10, (0, 2): 1.0e-10}\n        }\n    ]\n\n    results = []\n    \n    # --- Helper functions for coordinate manipulation and verification ---\n\n    def minimum_image_vector(vec, box_length):\n        \"\"\"Applies minimum image convention to a vector.\"\"\"\n        return vec - box_length * np.round(vec / box_length)\n\n    def generate_initial_coords(case):\n        \"\"\"Generates a sample initial configuration for verification.\"\"\"\n        L = case[\"L\"]\n        num_atoms = sum(len(g) for g in case[\"groups\"])\n        coords = np.zeros((num_atoms, 3))\n\n        if case[\"M\"] == 2 and len(case[\"groups\"][0]) == 2: # Diatomic cases\n            d = case[\"bond_lengths\"][(0, 1)]\n            # Mol 1\n            com1 = np.array([0.25 * L, 0.5 * L, 0.5 * L])\n            coords[0] = com1 - np.array([d/2, 0, 0])\n            coords[1] = com1 + np.array([d/2, 0, 0])\n            # Mol 2\n            com2 = np.array([0.75 * L, 0.5 * L, 0.5 * L])\n            coords[2] = com2 - np.array([0, d/2, 0])\n            coords[3] = com2 + np.array([0, d/2, 0])\n        elif case[\"M\"] == 2 and len(case[\"groups\"][0]) == 3: # Triatomic + atom case\n            d = case[\"bond_lengths\"][(0, 1)]\n            # Triatomic group at a corner\n            coords[0] = np.array([0.75 * L, 0.75 * L, 0.75 * L])\n            coords[1] = coords[0] + np.array([d, 0, 0])\n            coords[2] = coords[0] + np.array([0, d, 0])\n            # Free atom\n            coords[3] = np.array([0.25 * L, 0.25 * L, 0.25 * L])\n        \n        return coords\n\n    def update_positions(coords, L, gamma, groups):\n        \"\"\"Performs a constraint-preserving coordinate update.\"\"\"\n        L_new = gamma * L\n        new_coords = np.zeros_like(coords)\n\n        for group in groups:\n            # 1. Unwrap coordinates for the group\n            ref_idx = group[0]\n            unwrapped_group_coords = np.zeros((len(group), 3))\n            unwrapped_group_coords[0] = coords[ref_idx]\n            \n            for i, atom_idx in enumerate(group[1:]):\n                disp_vec = coords[atom_idx] - coords[ref_idx]\n                mic_disp = minimum_image_vector(disp_vec, L)\n                unwrapped_group_coords[i+1] = coords[ref_idx] + mic_disp\n\n            # 2. Calculate COM (geometric center)\n            com = np.mean(unwrapped_group_coords, axis=0)\n\n            # 3. Scale COM\n            new_com = gamma * com\n\n            # 4. Update atomic positions\n            for i, atom_idx in enumerate(group):\n                relative_pos = unwrapped_group_coords[i] - com\n                new_unwrapped_pos = new_com + relative_pos\n                \n                # 5. Rewrap into new box\n                new_coords[atom_idx] = new_unwrapped_pos - L_new * np.floor(new_unwrapped_pos / L_new)\n        \n        return new_coords\n\n    def verify_bonds(coords, L, bonds, bond_lengths, tolerance):\n        \"\"\"Verifies that bond lengths are preserved to within tolerance.\"\"\"\n        for i, j in bonds:\n            disp_vec = coords[i] - coords[j]\n            mic_disp = minimum_image_vector(disp_vec, L)\n            new_length = np.linalg.norm(mic_disp)\n            original_length = bond_lengths.get((i, j)) or bond_lengths.get((j, i))\n            \n            if abs(new_length - original_length) > tolerance:\n                raise ValueError(\n                    f\"Bond constraint violated for bond ({i},{j}). \"\n                    f\"Expected: {original_length:.4e}, Found: {new_length:.4e}, \"\n                    f\"Error: {abs(new_length - original_length):.4e}\"\n                )\n\n    # --- Main loop to process each test case ---\n    for case in test_cases:\n        T, p, L, gamma, M, delta_U = case[\"T\"], case[\"p\"], case[\"L\"], case[\"gamma\"], case[\"M\"], case[\"delta_U\"]\n        \n        # --- Task 2/3: Algorithm Verification ---\n        initial_coords = generate_initial_coords(case)\n        new_coords = update_positions(initial_coords, L, gamma, case[\"groups\"])\n        verify_bonds(new_coords, L * gamma, case[\"bonds\"], case[\"bond_lengths\"], tolerance=1.0e-12)\n        \n        # --- Task 1/3: Exponent Calculation ---\n        V = L**3\n        V_prime = (gamma * L)**3\n        \n        # Handle the case gamma = 1 to avoid floating point issues in log\n        if gamma == 1.0:\n            log_term = 0.0\n        else:\n            log_term = M * np.log(V_prime / V)\n            \n        energy_term = -(delta_U + p * (V_prime - V)) / (KB * T)\n        \n        acceptance_exponent = energy_term + log_term\n        results.append(acceptance_exponent)\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "NPT系综模拟的一个强大应用是计算系统的宏观性质，特别是压力 $p$ 与平均体积 $\\langle V \\rangle$ 之间的关系，即状态方程（EOS）。这个性质不仅是表征物质特性的基本工具，也是连接不同尺度模型的桥梁。这个实践  将引导你应用NPT模拟的结果来解决一个多尺度建模中的核心问题：如何校准一个粗粒化（CG）模型的参数，使其能够准确再现更精确的原子级别模型的状态方程。通过构建和求解一个加权最小二乘问题，你将学习如何将模拟数据转化为可操作的见解，从而系统地优化和验证CG模型，这是计算物理和化学领域一项至关重要的技能。",
            "id": "3783189",
            "problem": "您的任务是为粗粒化 (CG) 模型制定并实施一个校准程序，以便在恒定粒子数、压强和温度 (NPT) 系综下的蒙特卡洛模拟能够再现指定压强范围内的原子尺度状态方程 (EOS)。从 NPT 系综的基本性质出发，推导出一个基于原理的最小二乘法公式，用于匹配平均体积作为压强函数的关系。然后，实现一个程序，该程序在给定参考状态方程数据的情况下，通过求解一个加权最小二乘问题来估计 CG 参数。\n\n推导校准方法时必须使用以下科学设定：\n\n- 在 NPT 系综中，对于一个包含 $N$ 个粒子、绝对温度为 $T$、外部压强为 $p$ 的系统，其具有坐标 $\\mathbf{R}$ 和体积 $V$ 的微观态的概率密度，在不考虑归一化的情况下，正比于 $\\exp\\left[-\\beta\\left(U(\\mathbf{R};\\boldsymbol{\\theta}) + p\\,V\\right)\\right]\\,V^{N}$，其中 $U$ 是由 $\\boldsymbol{\\theta}$ 参数化的 CG 模型的构型能，$\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n- 状态方程由固定 $N$ 和 $T$ 条件下的系综平均体积 $\\langle V \\rangle$ 与压强 $p$ 之间的关系定义，可写作 $\\langle V\\rangle(p)$。\n- 在 NPT 系综中的蒙特卡洛 (MC) 模拟会为每个施加的压强 $p$ 产生一个 $\\langle V\\rangle(p)$ 的估计量 $\\widehat{V}(p)$，该估计量会因有限采样而波动。\n\n以此为基础，推导出一个最小二乘目标函数，通过将模型预测的 $\\langle V\\rangle_{\\mathrm{CG}}(p;\\boldsymbol{\\theta})$ 与在一组离散压强 $\\{p_i\\}_{i=1}^M$ 上的参考原子尺度状态方程 $\\langle V\\rangle_{\\mathrm{ref}}(p)$ 进行匹配，来估计 CG 参数 $\\boldsymbol{\\theta}$。此推导必须是第一性原理的，从 NPT 分布和统计估计出发，不使用简便公式。\n\n对于数值实现，考虑在一个物理上合理的压强窗口内，使用以下两种 $\\langle V\\rangle_{\\mathrm{CG}}(p;\\boldsymbol{\\theta})$ 的参数化代理模型：\n\n1. 指数压缩性模型：$\\langle V\\rangle_{\\mathrm{CG}}(p;\\boldsymbol{\\theta}) = \\theta_0 \\exp\\left(-\\theta_1 \\left(p - p_{\\mathrm{ref}}\\right)\\right)$，其中 $\\theta_0$ 的单位是 $\\mathrm{nm}^3$，$\\theta_1$ 的单位是 $\\mathrm{bar}^{-1}$，$p_{\\mathrm{ref}}$ 是一个单位为 $\\mathrm{bar}$ 的固定参考压强。\n2. 二次多项式模型：$\\langle V\\rangle_{\\mathrm{CG}}(p;\\boldsymbol{\\theta}) = \\theta_0 - \\theta_1 p + \\theta_2 p^2$，其中 $\\theta_0$ 的单位是 $\\mathrm{nm}^3$，$\\theta_1$ 的单位是 $\\mathrm{nm}^3/\\mathrm{bar}$，$\\theta_2$ 的单位是 $\\mathrm{nm}^3/\\mathrm{bar}^2$。\n\n假设在各压强 $p_i$ 处的参考值 $\\widehat{V}_i$ 连同逐点的标准差 $\\sigma_i$ 一并提供，标准差用于量化单位为 $\\mathrm{nm}^3$ 的测量不确定度。使用权重为 $w_i = 1/\\sigma_i^2$ 的加权最小二乘公式，通过最小化 $\\langle V\\rangle_{\\mathrm{CG}}(p_i;\\boldsymbol{\\theta})$ 和 $\\widehat{V}_i$ 之间经不确定度归一化的残差平方和，来估计每个模型的参数 $\\boldsymbol{\\theta}$。\n\n您的程序必须实现以下功能：\n\n- 一个适用于两种参数化模型的加权最小二乘求解器。对于指数模型，使用对数变换 $\\ln \\widehat{V}_i = \\ln \\theta_0 - \\theta_1 \\left(p_i - p_{\\mathrm{ref}}\\right)$ 将问题转化为一个关于 $(\\ln \\theta_0, \\theta_1)$ 的权重为 $w_i$ 的线性最小二乘问题。对于二次模型，直接求解关于 $(\\theta_0, \\theta_1, \\theta_2)$ 的线性加权最小二乘系统。\n- 一个固定的包含三种情况的测试套件，每种情况指定 $(p_i, \\widehat{V}_i, \\sigma_i)$ 和模型类型，使用以下数据集。压强单位必须是 $\\mathrm{bar}$，体积单位必须是 $\\mathrm{nm}^3$。标准差单位必须是 $\\mathrm{nm}^3$。\n\n测试套件：\n- 情况 A (理想情况，指数模型)：$p_{\\mathrm{ref}} = 1$ $\\mathrm{bar}$；压强 $[0, 50, 100, 150, 200]$ $\\mathrm{bar}$；真实参数 $\\theta_0 = 10.0$ $\\mathrm{nm}^3$, $\\theta_1 = 0.002$ $\\mathrm{bar}^{-1}$；参考体积计算为 $\\widehat{V}_i = \\theta_0 \\exp\\left(-\\theta_1\\left(p_i - p_{\\mathrm{ref}}\\right)\\right)$；所有 $i$ 的标准差 $\\sigma_i = 0.01$ $\\mathrm{nm}^3$。\n- 情况 B (边界覆盖，二次模型)：压强 $[0, 250, 500]$ $\\mathrm{bar}$；真实参数 $(\\theta_0, \\theta_1, \\theta_2) = (12.0, 0.01, 10^{-5})$，单位如上定义；参考体积计算为 $\\widehat{V}_i = \\theta_0 - \\theta_1 p_i + \\theta_2 p_i^2$；所有 $i$ 的标准差 $\\sigma_i = 0.01$ $\\mathrm{nm}^3$。\n- 情况 C (边缘情况，指数模型，最少数据点)：$p_{\\mathrm{ref}} = 1$ $\\mathrm{bar}$；压强 $[1, 2]$ $\\mathrm{bar}$；真实参数 $\\theta_0 = 9.9$ $\\mathrm{nm}^3$, $\\theta_1 = 0.005$ $\\mathrm{bar}^{-1}$；参考体积计算为 $\\widehat{V}_i = \\theta_0 \\exp\\left(-\\theta_1\\left(p_i - p_{\\mathrm{ref}}\\right)\\right)$；所有 $i$ 的标准差 $\\sigma_i = 0.01$ $\\mathrm{nm}^3$。\n\n实现要求：\n- 使用数值线性代数确定性地求解加权最小二乘问题。不要执行任何随机采样。\n- 对于指数模型，返回参数 $(\\theta_0, \\theta_1)$，其中 $\\theta_0$ 的单位为 $\\mathrm{nm}^3$，$\\theta_1$ 的单位为 $\\mathrm{bar}^{-1}$。对于二次模型，返回 $(\\theta_0, \\theta_1, \\theta_2)$，单位如上定义。\n- 在输出字符串中，所有输出参数均表示为不带单位的浮点数，但您必须确保代码内部遵循物理单位。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个列表元素本身应为一个 Python 风格的列表，表示一个情况的参数向量，顺序为情况 A、情况 B、情况 C。例如：$[\\,[\\theta_{0}^{(A)},\\theta_{1}^{(A)}],\\,[\\theta_{0}^{(B)},\\theta_{1}^{(B)},\\theta_{2}^{(B)}],\\,[\\theta_{0}^{(C)},\\theta_{1}^{(C)}]\\,]$。\n\n预期的输出类型是浮点数列表。必须有三个列表元素，对应于三种情况。",
            "solution": "目标是通过确保粗粒化 (CG) 模型的状态方程 $\\langle V \\rangle_{\\mathrm{CG}}(p; \\boldsymbol{\\theta})$ 能够再现从更基础的原子尺度模型获得的一组参考数据点 $\\{ (p_i, \\widehat{V}_i, \\sigma_i) \\}_{i=1}^M$，来确定该模型的参数 $\\boldsymbol{\\theta}$。值 $\\widehat{V}_i$ 表示在压强 $p_i$ 下的估计平均体积，$\\sigma_i$ 是此估计的标准差，用以量化其统计不确定性。校准过程将通过最小化 CG 模型预测与参考数据之间经过适当加权的平方差之和来执行。\n\n此程序的原理基础是最大似然估计 (MLE) 方法。我们假设每个数据点 $\\widehat{V}_i$ 是从一个以真实潜在平均体积 $\\langle V \\rangle_{\\mathrm{ref}}(p_i)$ 为中心、标准差为 $\\sigma_i$ 的概率分布中抽取的独立测量值。援引中心极限定理（该定理适用于通过长时模拟计算出的平均值），我们将此分布建模为高斯（正态）分布：$\\widehat{V}_i \\sim \\mathcal{N}(\\langle V \\rangle_{\\mathrm{ref}}(p_i), \\sigma_i^2)$。\n\n目标是找到参数 $\\boldsymbol{\\theta}$，使得 CG 模型能最好地逼近参考系统，即 $\\langle V \\rangle_{\\mathrm{CG}}(p; \\boldsymbol{\\theta}) \\approx \\langle V \\rangle_{\\mathrm{ref}}(p)$。因此，我们可以用 CG 模型重述我们观测数据的统计模型：$\\widehat{V}_i \\sim \\mathcal{N}(\\langle V \\rangle_{\\mathrm{CG}}(p_i; \\boldsymbol{\\theta}), \\sigma_i^2)$。在给定模型下，观测到单个数据点 $\\widehat{V}_i$ 的概率密度为：\n$$ P(\\widehat{V}_i | \\boldsymbol{\\theta}) = \\frac{1}{\\sqrt{2\\pi\\sigma_i^2}} \\exp\\left( -\\frac{(\\widehat{V}_i - \\langle V\\rangle_{\\mathrm{CG}}(p_i; \\boldsymbol{\\theta}))^2}{2\\sigma_i^2} \\right) $$\n由于测量是独立的，观测到整个数据集 $\\{\\widehat{V}_i\\}$ 的总似然是各个概率的乘积：\n$$ \\mathcal{L}(\\boldsymbol{\\theta}) = \\prod_{i=1}^M P(\\widehat{V}_i | \\boldsymbol{\\theta}) = \\prod_{i=1}^M \\frac{1}{\\sqrt{2\\pi\\sigma_i^2}} \\exp\\left( -\\frac{(\\widehat{V}_i - \\langle V\\rangle_{\\mathrm{CG}}(p_i; \\boldsymbol{\\theta}))^2}{2\\sigma_i^2} \\right) $$\n为了找到最优参数 $\\boldsymbol{\\theta}$，我们最大化此似然函数。在数学上等价且数值上更稳定的是最大化似然函数的对数（即对数似然 $\\ln\\mathcal{L}$）：\n$$ \\ln \\mathcal{L}(\\boldsymbol{\\theta}) = \\sum_{i=1}^M \\left( -\\frac{1}{2}\\ln(2\\pi\\sigma_i^2) - \\frac{(\\widehat{V}_i - \\langle V\\rangle_{\\mathrm{CG}}(p_i; \\boldsymbol{\\theta}))^2}{2\\sigma_i^2} \\right) $$\n关于 $\\boldsymbol{\\theta}$ 最大化 $\\ln \\mathcal{L}(\\boldsymbol{\\theta})$ 等价于最小化其中依赖于 $\\boldsymbol{\\theta}$ 的项。这引出了对目标函数 $\\chi^2(\\boldsymbol{\\theta})$ 的最小化：\n$$ \\min_{\\boldsymbol{\\theta}} \\chi^2(\\boldsymbol{\\theta}) = \\min_{\\boldsymbol{\\theta}} \\sum_{i=1}^M \\frac{(\\widehat{V}_i - \\langle V\\rangle_{\\mathrm{CG}}(p_i; \\boldsymbol{\\theta}))^2}{\\sigma_i^2} = \\min_{\\boldsymbol{\\theta}} \\sum_{i=1}^M w_i (\\widehat{V}_i - \\langle V\\rangle_{\\mathrm{CG}}(p_i; \\boldsymbol{\\theta}))^2 $$\n其中 $w_i = 1/\\sigma_i^2$ 是权重。这即是加权最小二乘 (WLS) 问题的定义。它表明，当数据点具有独立且已知方差的高斯分布误差时，WLS 是进行参数拟合的统计上严谨的方法。\n\n现在我们将此 WLS 框架应用于指定的两个参数化模型。\n\n**1. 二次多项式模型**\n\n该模型由 $\\langle V\\rangle_{\\mathrm{CG}}(p;\\boldsymbol{\\theta}) = \\theta_0 - \\theta_1 p + \\theta_2 p^2$ 给出，其中 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2)$。该模型对其参数是线性的。我们可以将所有数据点的方程组表示为矩阵形式 $\\mathbf{y} \\approx \\mathbf{A}\\mathbf{c}$，我们的目标是找到使加权平方误差最小化的系数向量 $\\mathbf{c}$。\n让我们定义一个标准多项式基：\n$$ V(p) = c_0 \\cdot 1 + c_1 \\cdot p + c_2 \\cdot p^2 $$\n与模型比较，我们有关系式 $c_0 = \\theta_0$，$c_1 = -\\theta_1$ 和 $c_2 = \\theta_2$。\nWLS 问题是找到 $\\mathbf{c} = (c_0, c_1, c_2)^T$ 以最小化 $\\sum_{i=1}^M w_i (\\widehat{V}_i - (c_0 + c_1 p_i + c_2 p_i^2))^2$。\n这可以用矩阵代数写成最小化 $\\|\\mathbf{W}^{1/2}(\\mathbf{y} - \\mathbf{A}\\mathbf{c})\\|_2^2$，其中：\n- $\\mathbf{y}$ 是观测体积的列向量，$\\mathbf{y}_i = \\widehat{V}_i$。\n- $\\mathbf{A}$ 是设计矩阵，其第 $i$ 行为 $(1, p_i, p_i^2)$。\n- $\\mathbf{W}$ 是权重的对角矩阵，$\\mathbf{W}_{ii} = w_i = 1/\\sigma_i^2$。\n\n此 WLS 问题通过将其转换为一个标准的非加权最小二乘问题来进行数值求解。我们定义一个缩放后的系统 $\\mathbf{y}' = \\mathbf{A}'\\mathbf{c}$，其中 $\\mathbf{A}' = \\mathbf{W}^{1/2}\\mathbf{A}$ 且 $\\mathbf{y}' = \\mathbf{W}^{1/2}\\mathbf{y}$。这可以通过将 $\\mathbf{A}$ 的第 $i$ 行和 $\\mathbf{y}$ 的第 $i$ 个元素乘以 $\\sqrt{w_i} = 1/\\sigma_i$ 来实现。然后可以使用数值线性代数找到 $\\mathbf{c}$ 的标准最小二乘解，其正规方程为 $(\\mathbf{A}'^T \\mathbf{A}')\\mathbf{c} = \\mathbf{A}'^T \\mathbf{y}'$。解出 $\\mathbf{c} = (c_0, c_1, c_2)^T$ 后，我们恢复模型参数为 $\\theta_0=c_0$，$\\theta_1=-c_1$ 和 $\\theta_2=c_2$。\n\n**2. 指数压缩性模型**\n\n模型为 $\\langle V\\rangle_{\\mathrm{CG}}(p;\\boldsymbol{\\theta}) = \\theta_0 \\exp\\left(-\\theta_1 \\left(p - p_{\\mathrm{ref}}\\right)\\right)$，其中 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1)$。该模型在 $\\theta_1$ 上是非线性的。按照建议，我们通过取自然对数将其线性化：\n$$ \\ln \\langle V\\rangle_{\\mathrm{CG}} = \\ln \\theta_0 - \\theta_1 (p - p_{\\mathrm{ref}}) $$\n让我们为线性问题定义一组新参数，$c_0 = \\ln \\theta_0$ 和 $c_1 = \\theta_1$。令转换后的目标变量为 $y'_i = \\ln \\widehat{V}_i$。模型变为：\n$$ y'_i \\approx c_0 - c_1 (p_i - p_{\\mathrm{ref}}) = c_0 \\cdot 1 + c_1 \\cdot (-(p_i - p_{\\mathrm{ref}})) $$\n这是一个关于参数 $\\mathbf{c} = (c_0, c_1)^T$ 的线性模型。\n\n关键在于，将因变量从 $\\widehat{V}_i$ 转换为 $\\ln \\widehat{V}_i$ 也会改变误差分布。我们必须传播不确定度，以便为新的线性问题定义正确的权重。对于一个函数 $f(x)$，其不确定度为 $\\sigma_x$，则 $f$ 的不确定度为 $\\sigma_f \\approx |f'(x)| \\sigma_x$。这里，我们的函数是 $f(V) = \\ln V$，所以 $f'(V) = 1/V$。因此，变量 $y'_i = \\ln \\widehat{V}_i$ 的标准差 $\\sigma'_{i}$ 为：\n$$ \\sigma'_{i} \\approx \\left| \\frac{d(\\ln V)}{dV} \\bigg|_{V=\\widehat{V}_i} \\right| \\sigma_i = \\frac{\\sigma_i}{\\widehat{V}_i} $$\n线性化 WLS 问题的新权重 $w'_i$ 是新方差的倒数：\n$$ w'_i = \\frac{1}{(\\sigma'_{i})^2} = \\left(\\frac{\\widehat{V}_i}{\\sigma_i}\\right)^2 $$\n线性化指数模型的 WLS 问题是找到 $\\mathbf{c} = (\\ln\\theta_0, \\theta_1)^T$ 以最小化 $\\sum_{i=1}^M w'_i (\\ln\\widehat{V}_i - (\\ln\\theta_0 - \\theta_1(p_i-p_{\\text{ref}})))^2$。\n我们通过建立线性系统 $\\mathbf{y}' \\approx \\mathbf{A}\\mathbf{c}$ 来解决此问题，其中：\n- $\\mathbf{y}'$ 是元素为 $\\mathbf{y}'_i = \\ln\\widehat{V}_i$ 的列向量。\n- $\\mathbf{A}$ 是设计矩阵，其第 $i$ 行为 $(1, -(p_i-p_{\\text{ref}}))$。\n- $\\mathbf{c}$ 是参数向量 $(c_0, c_1)^T = (\\ln \\theta_0, \\theta_1)^T$。\n\nWLS 解是通过将 $\\mathbf{A}$ 和 $\\mathbf{y}'$ 的第 $i$ 行乘以 $\\sqrt{w'_i} = \\widehat{V}_i/\\sigma_i$ 并求解得到的标准最小二乘问题来找到的。一旦找到系数向量 $\\mathbf{c}=(c_0, c_1)^T$，我们就可以恢复原始模型参数为 $\\theta_0 = \\exp(c_0)$ 和 $\\theta_1 = c_1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_exponential(p, V, sigma, p_ref):\n    \"\"\"\n    Solves for the parameters of the exponential model using weighted least-squares\n    on the logarithmic form of the model.\n    Model: V(p) = theta0 * exp(-theta1 * (p - p_ref))\n    Linearized model: ln(V) = ln(theta0) - theta1 * (p - p_ref)\n    Let c0 = ln(theta0), c1 = theta1.\n    ln(V) = c0 - c1 * (p - p_ref) = c0 * 1 + c1 * -(p - p_ref)\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    V = np.asarray(V, dtype=float)\n    sigma = np.asarray(sigma, dtype=float)\n\n    # Dependent variable for the linear model\n    y_prime = np.log(V)\n\n    # Design matrix for the linear model: y' = A.c\n    # where columns of A are basis functions: 1 and -(p - p_ref)\n    A = np.vstack([np.ones_like(p), -(p - p_ref)]).T\n\n    # Weights for the linearized problem, derived from error propagation:\n    # sigma_lnV = sigma_V / V\n    # w_lnV = 1 / sigma_lnV^2 = (V / sigma)^2\n    # We apply sqrt(w) to A and y to perform WLS.\n    w_sqrt = V / sigma\n    \n    # Scale system for WLS: (w_sqrt * A) c = (w_sqrt * y_prime)\n    A_w = A * w_sqrt[:, np.newaxis]\n    y_w = y_prime * w_sqrt\n\n    # Solve the ordinary least-squares problem on the weighted system\n    c, _, _, _ = np.linalg.lstsq(A_w, y_w, rcond=None)\n    \n    c0, c1 = c\n\n    # Recover original parameters\n    theta0 = np.exp(c0)\n    theta1 = c1\n    \n    return [theta0, theta1]\n\ndef solve_quadratic(p, V, sigma):\n    \"\"\"\n    Solves for the parameters of the quadratic model using weighted least-squares.\n    Model: V(p) = theta0 - theta1*p + theta2*p^2\n    Let's fit to V(p) = c0 + c1*p + c2*p^2\n    Then: theta0=c0, theta1=-c1, theta2=c2\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    V = np.asarray(V, dtype=float)\n    sigma = np.asarray(sigma, dtype=float)\n\n    y = V\n\n    # Design matrix from polynomial basis functions: 1, p, p^2\n    # np.vander with increasing=True gives columns p^0, p^1, p^2, ...\n    A = np.vander(p, N=3, increasing=True)\n    \n    # Weights for WLS: w = 1 / sigma^2\n    # We apply sqrt(w) = 1/sigma to A and y\n    w_sqrt = 1.0 / sigma\n    \n    # Scale system for WLS: (w_sqrt * A) c = (w_sqrt * y)\n    A_w = A * w_sqrt[:, np.newaxis]\n    y_w = y * w_sqrt\n    \n    # Solve the ordinary least-squares problem for coefficients c = (c0, c1, c2)\n    c, _, _, _ = np.linalg.lstsq(A_w, y_w, rcond=None)\n    \n    c0, c1, c2 = c\n\n    # Recover model parameters\n    theta0 = c0\n    theta1 = -c1\n    theta2 = c2\n    \n    return [theta0, theta1, theta2]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Case A: happy path, exponential\n    p_a = np.array([0, 50, 100, 150, 200], dtype=float)\n    theta0_a_true, theta1_a_true = 10.0, 0.002\n    p_ref_a = 1.0\n    V_a = theta0_a_true * np.exp(-theta1_a_true * (p_a - p_ref_a))\n    sigma_a = np.full_like(p_a, 0.01)\n    test_cases.append({\n        'model': 'exponential',\n        'p': p_a,\n        'V': V_a,\n        'sigma': sigma_a,\n        'p_ref': p_ref_a\n    })\n\n    # Case B: boundary coverage, quadratic\n    p_b = np.array([0, 250, 500], dtype=float)\n    theta0_b_true, theta1_b_true, theta2_b_true = 12.0, 0.01, 1.0e-5\n    V_b = theta0_b_true - theta1_b_true * p_b + theta2_b_true * p_b**2\n    sigma_b = np.full_like(p_b, 0.01)\n    test_cases.append({\n        'model': 'quadratic',\n        'p': p_b,\n        'V': V_b,\n        'sigma': sigma_b\n    })\n\n    # Case C: edge case, exponential with minimal points\n    p_c = np.array([1, 2], dtype=float)\n    theta0_c_true, theta1_c_true = 9.9, 0.005\n    p_ref_c = 1.0\n    V_c = theta0_c_true * np.exp(-theta1_c_true * (p_c - p_ref_c))\n    sigma_c = np.full_like(p_c, 0.01)\n    test_cases.append({\n        'model': 'exponential',\n        'p': p_c,\n        'V': V_c,\n        'sigma': sigma_c,\n        'p_ref': p_ref_c\n    })\n\n    results = []\n    for case in test_cases:\n        if case['model'] == 'exponential':\n            params = solve_exponential(case['p'], case['V'], case['sigma'], case['p_ref'])\n        elif case['model'] == 'quadratic':\n            params = solve_quadratic(case['p'], case['V'], case['sigma'])\n        results.append(params)\n\n    # Format output as a string representation of a list of lists.\n    # The str() function on a list provides the required spacing.\n    # Ex: str([1.2, 3.4]) -> '[1.2, 3.4]'\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}