{
    "hands_on_practices": [
        {
            "introduction": "The first critical step in any Particle Mesh method is projecting the continuous particle positions and charges onto a discrete grid. The Cloud-In-Cell (CIC) scheme is a popular and straightforward method that guarantees charge conservation. This foundational exercise  will guide you through deriving the CIC interpolation weights from a few basic principles, providing an intuitive understanding of how a 'particle' becomes a 'cloud' on the computational mesh.",
            "id": "3849522",
            "problem": "A key step in the Particle Mesh Ewald (PME) method is the assignment of point charges to a mesh to obtain a smooth mesh charge density suitable for solving Poisson’s equation in Fourier space. Consider a three-dimensional uniform Cartesian mesh with spacings $\\Delta x$, $\\Delta y$, and $\\Delta z$ along the $x$, $y$, and $z$ axes, respectively. A particle of charge $q$ is located at position $\\mathbf{r} = (x,y,z)$ inside a single mesh cell bounded by node indices $(i,j,k)$ at the lower-near-left corner and $(i+1,j+1,k+1)$ at the upper-far-right corner. Define the fractional offsets\n$$\nu_x = \\frac{x - x_i}{\\Delta x}, \\quad u_y = \\frac{y - y_j}{\\Delta y}, \\quad u_z = \\frac{z - z_k}{\\Delta z},\n$$\nwhere $x_i = i \\,\\Delta x$, $y_j = j \\,\\Delta y$, and $z_k = k \\,\\Delta z$, and assume $u_x,u_y,u_z \\in [0,1)$.\n\nStarting from first principles appropriate for multiscale materials simulation and mesh-based interpolation, use only the following fundamental requirements to derive the Cloud-In-Cell (CIC) charge assignment weights to the eight nearest mesh nodes:\n- Conservation of charge: the sum of assigned fractions equals one.\n- Locality: only the eight nearest nodes of the containing cell receive nonzero weight.\n- Linear consistency in one dimension: when restricting to a single axis, the assignment reduces to linear interpolation between the two adjacent nodes.\n- Tensor-product separability on a Cartesian grid: the three-dimensional assignment is the product of one-dimensional assignments along each axis.\n\nDerive explicit analytical expressions for the eight dimensionless weights $w_{n}$, $n=1,\\dots,8$, corresponding to the nodes ordered as\n$$\n(i,j,k),\\ (i+1,j,k),\\ (i,j+1,k),\\ (i+1,j+1,k),\\ (i,j,k+1),\\ (i+1,j,k+1),\\ (i,j+1,k+1),\\ (i+1,j+1,k+1).\n$$\nExpress your final answer as a single row vector containing the eight $w_n$ in this order, in terms of $u_x$, $u_y$, and $u_z$. Do not include units. The final answer must be a single analytical expression.",
            "solution": "The problem is scientifically grounded, well-posed, objective, and contains all necessary information to derive the requested charge assignment weights. It is therefore deemed valid and a solution is provided.\n\nThe derivation proceeds from the given fundamental requirements. We first establish the form of the one-dimensional interpolation weights and then extend them to three dimensions using the principle of tensor-product separability.\n\nThe requirement of linear consistency in one dimension states that the assignment reduces to linear interpolation. Consider the $x$-axis. A particle with fractional coordinate $u_x \\in [0,1)$ lies between grid nodes at integer indices $i$ and $i+1$. Let $W_i(u_x)$ and $W_{i+1}(u_x)$ be the dimensionless weights assigned to nodes $i$ and $i+1$ respectively. For linear interpolation, the weights must be linear functions of $u_x$.\nWhen the particle is located exactly at node $i$, its fractional coordinate is $u_x=0$. All of the particle's charge must be assigned to node $i$. This gives the boundary conditions $W_i(0) = 1$ and $W_{i+1}(0) = 0$.\nWhen the particle is located exactly at node $i+1$, its fractional coordinate is $u_x=1$. All of the particle's charge must be assigned to node $i+1$. This gives the boundary conditions $W_i(1) = 0$ and $W_{i+1}(1) = 1$.\nThe unique linear function for $W_i(u_x)$ that satisfies the conditions $W_i(0) = 1$ and $W_i(1) = 0$ is:\n$$\nW_i(u_x) = 1 - u_x\n$$\nThe unique linear function for $W_{i+1}(u_x)$ that satisfies the conditions $W_{i+1}(0) = 0$ and $W_{i+1}(1) = 1$ is:\n$$\nW_{i+1}(u_x) = u_x\n$$\nThese are the one-dimensional Cloud-In-Cell (CIC) weights. We verify charge conservation in one dimension: the sum of the weights is $W_i(u_x) + W_{i+1}(u_x) = (1 - u_x) + u_x = 1$. This is consistent with the charge conservation requirement.\n\nNext, we use the requirement of tensor-product separability on a Cartesian grid to construct the three-dimensional weights. The weight assigned to a node is the product of the one-dimensional weights for each coordinate. The particle is located in the cell with its lower-near-left corner at node $(i,j,k)$. The eight nodes of this cell are indexed by $(i+l, j+m, k+p)$ where $l, m, p \\in \\{0,1\\}$.\nThe fractional coordinates are $u_x$, $u_y$, and $u_z$. The weight $w_{i+l,j+m,k+p}$ assigned to node $(i+l,j+m,k+p)$ is given by:\n$$\nw_{i+l,j+m,k+p} = W_l(u_x) W_m(u_y) W_p(u_z)\n$$\nwhere we have generalized the one-dimensional weight functions as $W_0(u) = 1-u$ for the \"lower\" node and $W_1(u) = u$ for the \"upper\" node along any given axis.\nSubstituting these gives the general formula for the weight assigned to node $(i+l,j+m,k+p)$:\n$$\nw_{i+l,j+m,k+p} = (1-u_x)^{1-l} (u_x)^l (1-u_y)^{1-m} (u_y)^m (1-u_z)^{1-p} (u_z)^p\n$$\nThe locality requirement is satisfied by construction, as only the eight nodes of the cell (for which $l,m,p \\in \\{0,1\\}$) receive non-zero weights. All other nodes in the system receive zero weight.\nThe total charge conservation is also guaranteed by the tensor product structure:\n$$\n\\sum_{l=0}^{1} \\sum_{m=0}^{1} \\sum_{p=0}^{1} w_{i+l,j+m,k+p} = \\left( \\sum_{l=0}^{1} W_l(u_x) \\right) \\left( \\sum_{m=0}^{1} W_m(u_y) \\right) \\left( \\sum_{p=0}^{1} W_p(u_z) \\right)\n$$\nSince each sum in parentheses equals $1$, the total sum of all eight weights is $1 \\times 1 \\times 1 = 1$.\n\nWe now list the explicit expressions for the eight weights $w_n$ for $n=1, \\dots, 8$, corresponding to the specified node ordering.\nFor node $(i,j,k)$, we have $(l,m,p)=(0,0,0)$, so the weight is $w_1 = W_0(u_x)W_0(u_y)W_0(u_z) = (1-u_x)(1-u_y)(1-u_z)$.\nFor node $(i+1,j,k)$, we have $(l,m,p)=(1,0,0)$, so the weight is $w_2 = W_1(u_x)W_0(u_y)W_0(u_z) = u_x(1-u_y)(1-u_z)$.\nFor node $(i,j+1,k)$, we have $(l,m,p)=(0,1,0)$, so the weight is $w_3 = W_0(u_x)W_1(u_y)W_0(u_z) = (1-u_x)u_y(1-u_z)$.\nFor node $(i+1,j+1,k)$, we have $(l,m,p)=(1,1,0)$, so the weight is $w_4 = W_1(u_x)W_1(u_y)W_0(u_z) = u_x u_y (1-u_z)$.\nFor node $(i,j,k+1)$, we have $(l,m,p)=(0,0,1)$, so the weight is $w_5 = W_0(u_x)W_0(u_y)W_1(u_z) = (1-u_x)(1-u_y)u_z$.\nFor node $(i+1,j,k+1)$, we have $(l,m,p)=(1,0,1)$, so the weight is $w_6 = W_1(u_x)W_0(u_y)W_1(u_z) = u_x(1-u_y)u_z$.\nFor node $(i,j+1,k+1)$, we have $(l,m,p)=(0,1,1)$, so the weight is $w_7 = W_0(u_x)W_1(u_y)W_1(u_z) = (1-u_x)u_y u_z$.\nFor node $(i+1,j+1,k+1)$, we have $(l,m,p)=(1,1,1)$, so the weight is $w_8 = W_1(u_x)W_1(u_y)W_1(u_z) = u_x u_y u_z$.\n\nThese eight expressions constitute the derived Cloud-In-Cell assignment weights. They represent the fraction of the particle's charge $q$ that is assigned to each of the eight surrounding grid nodes.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-u_x)(1-u_y)(1-u_z) & u_x(1-u_y)(1-u_z) & (1-u_x)u_y(1-u_z) & u_x u_y (1-u_z) & (1-u_x)(1-u_y)u_z & u_x(1-u_y)u_z & (1-u_x)u_y u_z & u_x u_y u_z\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Having understood how to assign charges to the mesh, we now build the core computational engine of the PME method. This practice  involves implementing the complete reciprocal-space workflow, from charge assignment and Fast Fourier Transforms (FFTs) to calculating the potential and differentiating it in Fourier space to find the electric field. By completing this exercise, you will have a working PME code that efficiently calculates long-range electrostatic forces, the primary goal of the method.",
            "id": "3282499",
            "problem": "You are to implement a simplified three-dimensional Particle Mesh Ewald (PME) method using the Fast Fourier Transform (FFT) to evaluate long-range electrostatic forces in a periodic cubic domain. The goal is to compute particle forces arising from the reciprocal-space (long-range) component only, under periodic boundary conditions and dimensionless units. The implementation must be fully self-contained and strictly use the Fast Fourier Transform (FFT) as the computational accelerator.\n\nThe computational domain is a periodic cube with side length $L=1$. All positions are given in reduced coordinates within $[0,1)$, all charges are dimensionless, and forces must be returned in dimensionless units. No physical unit conversion is required or permitted. Angle units are not applicable in this setting.\n\nYou must start from foundational principles and definitions of the discrete Fourier transform and Poisson’s equation, but the problem statement does not provide any shortcut formulas for the PME implementation. Your approach must be derived from first principles: map charges to a mesh, compute the potential in reciprocal space via FFTs and a screened Green’s function, differentiate in Fourier space to obtain the electric field, transform back to real space, and interpolate forces at particle locations.\n\nAlgorithmic specification:\n- The domain is a periodic cube of side length $L=1$ discretized on a uniform grid with $N \\times N \\times N$ points.\n- Use Cloud-In-Cell (CIC) charge assignment to place particle charges onto the mesh.\n- Use a three-dimensional Fast Fourier Transform (FFT) to transform the mesh charge density to reciprocal space.\n- Apply a screened reciprocal-space Green’s function characterized by a positive screening parameter $\\alpha$ to compute the long-range potential. The zero mode $\\mathbf{k}=\\mathbf{0}$ must be set to zero to enforce neutrality of the periodic cell.\n- Compute the electric field by differentiating the potential in reciprocal space.\n- Use the inverse FFT to return to real space and interpolate the electric field at particle positions using the same CIC weights. The force on particle $i$ is $q_i$ times the interpolated electric field at its position.\n- Use strictly dimensionless quantities throughout.\n\nTest suite:\nImplement your program to run exactly the following four test cases without any user input. For each case, $N$ denotes the grid size, $\\alpha$ denotes the screening parameter, $q_i$ are particle charges, and $\\mathbf{r}_i$ are particle positions in reduced coordinates in the unit cube.\n1. Happy path case: $N=16$, $\\alpha=3.5$, two particles with charges $[1.0,-1.0]$ at positions $\\mathbf{r}_1=[0.25,0.25,0.25]$, $\\mathbf{r}_2=[0.75,0.75,0.75]$.\n2. Boundary placement case: $N=16$, $\\alpha=2.5$, three particles with charges $[1.0,-0.5,0.5]$ at positions $\\mathbf{r}_1=[0.99,0.01,0.5]$, $\\mathbf{r}_2=[0.1,0.9,0.1]$, $\\mathbf{r}_3=[0.4,0.4,0.95]$.\n3. Edge case with zero charges: $N=8$, $\\alpha=2.0$, four particles with charges $[0.0,0.0,0.0,0.0]$ at positions $\\mathbf{r}_1=[0.2,0.3,0.4]$, $\\mathbf{r}_2=[0.6,0.2,0.1]$, $\\mathbf{r}_3=[0.8,0.8,0.8]$, $\\mathbf{r}_4=[0.1,0.7,0.9]$.\n4. Symmetric arrangement case: $N=32$, $\\alpha=3.0$, four particles with charges $[1.0,1.0,-1.0,-1.0]$ at positions $\\mathbf{r}_1=[0.25,0.25,0.5]$, $\\mathbf{r}_2=[0.75,0.25,0.5]$, $\\mathbf{r}_3=[0.25,0.75,0.5]$, $\\mathbf{r}_4=[0.75,0.75,0.5]$.\n\nRequired output:\nFor each test case, output a list of particle force vectors, where each force vector is a list of three floating-point numbers $[F_x,F_y,F_z]$ in dimensionless units. Aggregate the four per-case lists into a single list. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, where each element is itself a list of force vectors (for example, $[[[F_{x,1},F_{y,1},F_{z,1}],\\ldots],\\ldots]$).\n\nYour implementation must:\n- Use only the Python standard library and the NumPy library.\n- Be deterministic and require no input.\n- Handle periodic boundary conditions consistently in both charge assignment and field interpolation.\n- Use three-dimensional FFTs to compute the reciprocal-space solution.",
            "solution": "The problem requires the implementation of a simplified three-dimensional Particle Mesh Ewald (PME) method to compute the long-range component of electrostatic forces on a set of charged particles within a periodic cubic domain. The solution must be derived from foundational principles.\n\n### 1. Foundational Principles: Electrostatics in Reciprocal Space\n\nThe fundamental relationship between the electrostatic potential $\\phi(\\mathbf{r})$ and the charge density $\\rho(\\mathbf{r})$ is given by Poisson's equation. In the dimensionless units specified for this problem, we write:\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})\n$$\nThe electric field $\\mathbf{E}(\\mathbf{r})$ is the negative gradient of the potential:\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})\n$$\nThe system is defined in a cubic box of side length $L=1$ with periodic boundary conditions. Such problems are naturally handled using Fourier series, which for computational purposes become Discrete Fourier Transforms (DFTs). A function $f(\\mathbf{r})$ on the periodic domain can be represented by its Fourier coefficients $\\tilde{f}(\\mathbf{k})$:\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) e^{i\\mathbf{k} \\cdot \\mathbf{r}}\n$$\nwhere the wave vectors $\\mathbf{k}$ are discrete due to periodicity: $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z) = 2\\pi(n_x, n_y, n_z)$ since $L=1$, and $n_x, n_y, n_z$ are integers.\n\nIn Fourier space, the gradient operator $\\nabla$ transforms into multiplication by $i\\mathbf{k}$, and the Laplacian $\\nabla^2$ transforms into multiplication by $-|\\mathbf{k}|^2$. Applying the Fourier transform to the governing equations yields their algebraic counterparts:\n$$\n-|\\mathbf{k}|^2 \\tilde{\\phi}(\\mathbf{k}) = -\\tilde{\\rho}(\\mathbf{k}) \\implies \\tilde{\\phi}(\\mathbf{k}) = \\frac{\\tilde{\\rho}(\\mathbf{k})}{|\\mathbf{k}|^2}\n$$\n$$\n\\tilde{\\mathbf{E}}(\\mathbf{k}) = -i\\mathbf{k} \\tilde{\\phi}(\\mathbf{k})\n$$\n\n### 2. The Particle Mesh Ewald (PME) Method\n\nThe PME method provides an efficient way to calculate long-range forces by solving for a smoothed potential on a grid. The core idea of the Ewald split is to replace point charges with a superposition of two distributions: a localized one for short-range interactions (not part of this problem) and a smooth, long-ranged one for reciprocal-space calculation. The smooth distribution is typically a Gaussian cloud for each particle.\n\nThe effect of this smoothing in reciprocal space is the introduction of a damping factor into the potential calculation. The \"screened reciprocal-space Green's function\" specified in the problem combines the $1/|\\mathbf{k}|^2$ term from Poisson's equation with a Gaussian factor dependent on the screening parameter $\\alpha$. The Fourier-space potential is thus calculated as:\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\nwhere $\\tilde{\\rho}(\\mathbf{k})$ is the Fourier transform of the charge density on the grid and $\\tilde{G}(\\mathbf{k})$ is the PME reciprocal-space kernel (or Green's function):\n$$\n\\tilde{G}(\\mathbf{k}) = \\frac{\\exp(-|\\mathbf{k}|^2 / (4\\alpha^2))}{|\\mathbf{k}|^2}\n$$\nFor $\\mathbf{k} = \\mathbf{0}$, the denominator $|\\mathbf{k}|^2$ is zero, leading to a singularity. This term corresponds to the average potential of the system. For a system with overall charge neutrality in a periodic box, this term's contribution to the force is zero. The problem mandates setting the $\\mathbf{k}=\\mathbf{0}$ mode to zero, which is the standard procedure. Thus, we define $\\tilde{G}(\\mathbf{0}) = 0$.\n\n### 3. Discretization and Algorithmic Steps\n\nThe continuous fields are discretized on a uniform $N \\times N \\times N$ grid. Continuous Fourier transforms are replaced by DFTs, which are computed efficiently using the Fast Fourier Transform (FFT) algorithm. Let the grid spacing be $h = L/N = 1/N$.\n\n#### Step 1: Charge Assignment\nParticle charges, which are delta functions in the continuous representation, must be transferred to the discrete grid. The Cloud-in-Cell (CIC) or trilinear interpolation scheme is used. For a particle $i$ with charge $q_i$ at reduced position $\\mathbf{r}_i = (u_i, v_i, w_i) \\in [0,1)^3$, its scaled coordinates are $\\mathbf{s}_i = N\\mathbf{r}_i$. The integer part of $\\mathbf{s}_i$ identifies the primary grid cell, $\\mathbf{n}_i = (\\lfloor s_{ix} \\rfloor, \\lfloor s_{iy} \\rfloor, \\lfloor s_{iz} \\rfloor)$, and the fractional part gives the displacement within that cell, $\\mathbf{d}_i = \\mathbf{s}_i - \\mathbf{n}_i$.\n\nThe charge $q_i$ is distributed to the $8$ corners of the cell containing $\\mathbf{s}_i$. The charge assigned to a corner at offset $(\\delta_x, \\delta_y, \\delta_z)$ from $\\mathbf{n}_i$ (where $\\delta_j \\in \\{0,1\\}$) is:\n$$\n\\Delta\\rho = q_i \\cdot W_x(\\delta_x) \\cdot W_y(\\delta_y) \\cdot W_z(\\delta_z)\n$$\nwhere the weighting factors are $W_j(\\delta_j) = (1-d_{ij})^{1-\\delta_j} d_{ij}^{\\delta_j}$. This procedure is performed for all particles, accumulating charges on the grid $\\rho_{\\text{grid}}$. Grid indices are taken modulo $N$ to enforce periodicity.\n\n#### Step 2: Fourier Transform of Charge Density\nThe gridded charge density $\\rho_{\\text{grid}}$ is transformed to reciprocal space using a 3D FFT:\n$$\n\\tilde{\\rho}(\\mathbf{k}) = \\text{FFT3D}[\\rho_{\\text{grid}}]\n$$\n\n#### Step 3: Reciprocal Space Calculation\nThe potential and electric field are computed in Fourier space.\nFirst, the grid of discrete wave vectors $\\mathbf{k} = 2\\pi(n_x, n_y, n_z)$ is constructed, where $n_x, n_y, n_z$ are the integer frequencies corresponding to the FFT grid indices.\nThen, the Green's function $\\tilde{G}(\\mathbf{k})$ is computed for all $\\mathbf{k}$, with $\\tilde{G}(\\mathbf{0})=0$.\nThe potential is found by element-wise multiplication:\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\nThe electric field components are then calculated:\n$$\n\\tilde{E}_x(\\mathbf{k}) = -i k_x \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_y(\\mathbf{k}) = -i k_y \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_z(\\mathbf{k}) = -i k_z \\tilde{\\phi}(\\mathbf{k})\n$$\n\n#### Step 4: Inverse Fourier Transform\nThe electric field on the grid, $\\mathbf{E}_{\\text{grid}}$, is obtained by applying the inverse 3D FFT to each component of $\\tilde{\\mathbf{E}}(\\mathbf{k})$:\n$$\n\\mathbf{E}_{\\text{grid}}(\\mathbf{r}) = \\text{iFFT3D}[\\tilde{\\mathbf{E}}(\\mathbf{k})]\n$$\nThe result of the iFFT will be a complex array; the physical field is its real part.\n\n#### Step 5: Force Interpolation and Calculation\nTo find the force on each particle, the electric field must be interpolated from the grid back to the particle's position. For consistency and to ensure momentum conservation (i.e., $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$), the same CIC interpolation scheme used for charge assignment is applied. The electric field at particle $i$'s position $\\mathbf{r}_i$ is a weighted average of the field values at the $8$ surrounding grid points:\n$$\n\\mathbf{E}(\\mathbf{r}_i) = \\sum_{\\text{8 neighbors } \\mathbf{g}} \\mathbf{E}_{\\text{grid}}(\\mathbf{g}) \\cdot W(\\mathbf{r}_i, \\mathbf{g})\n$$\nwhere the weights $W$ are the same trilinear weights from Step 1.\nFinally, the force on particle $i$ is calculated as:\n$$\n\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)\n$$\nThis process is repeated for all particles and for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list_no_spaces(item):\n    \"\"\"\n    Recursively formats a nested list or numpy array into a string\n    with no spaces, as per the strict output format requirement.\n    \"\"\"\n    if isinstance(item, (list, np.ndarray)):\n        return \"[\" + \",\".join(format_list_no_spaces(x) for x in item) + \"]\"\n    return str(item)\n\ndef solve_pme_case(N, alpha, charges, positions):\n    \"\"\"\n    Computes reciprocal-space electrostatic forces for one test case.\n    \"\"\"\n    # Box length L=1 is assumed throughout.\n    L = 1.0\n    \n    # Step 1: Charge Assignment (CIC)\n    rho = np.zeros((N, N, N), dtype=float)\n    num_particles = len(charges)\n    # Store particle info for interpolation later\n    particle_info = []\n\n    for i in range(num_particles):\n        q_i = charges[i]\n        r_i = np.array(positions[i]) # Reduced coordinates [0, 1)\n\n        s_i = r_i * N\n        n_i = np.floor(s_i).astype(int)\n        d_i = s_i - n_i\n\n        particle_info.append({'n': n_i, 'd': d_i})\n\n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n                    \n                    weight = wx * wy * wz\n                    rho[z_idx, y_idx, x_idx] += q_i * weight\n    \n    # Step 2: FFT of charge density\n    rho_k = np.fft.fftn(rho)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wave vectors k\n    kx_int = np.fft.fftfreq(N) * N\n    ky_int = np.fft.fftfreq(N) * N\n    kz_int = np.fft.fftfreq(N) * N\n    \n    kx = 2 * np.pi * kx_int / L\n    ky = 2 * np.pi * ky_int / L\n    kz = 2 * np.pi * kz_int / L\n    \n    kz_grid, ky_grid, kx_grid = np.meshgrid(kz, ky, kx, indexing='ij')\n\n    k_squared = kx_grid**2 + ky_grid**2 + kz_grid**2\n    \n    # Calculate reciprocal Green's function G_k\n    G_k = np.zeros((N, N, N), dtype=float)\n    # Avoid division by zero at k=0\n    non_zero_k = k_squared != 0\n    G_k[non_zero_k] = np.exp(-k_squared[non_zero_k] / (4 * alpha**2)) / k_squared[non_zero_k]\n    # k=0 mode is explicitly set to 0. It is already 0 from initialization.\n\n    # Calculate potential and field in Fourier space\n    phi_k = G_k * rho_k\n    \n    Ex_k = -1j * kx_grid * phi_k\n    Ey_k = -1j * ky_grid * phi_k\n    Ez_k = -1j * kz_grid * phi_k\n\n    # Step 4: Inverse FFT to get E-field on the grid\n    Ex_grid = np.real(np.fft.ifftn(Ex_k))\n    Ey_grid = np.real(np.fft.ifftn(Ey_k))\n    Ez_grid = np.real(np.fft.ifftn(Ez_k))\n\n    # Step 5 & 6: Force Interpolation and Calculation\n    forces = []\n    for i in range(num_particles):\n        q_i = charges[i]\n        n_i = particle_info[i]['n']\n        d_i = particle_info[i]['d']\n        \n        E_interp = np.zeros(3, dtype=float)\n        \n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n\n                    weight = wx * wy * wz\n                    E_interp[0] += Ex_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[1] += Ey_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[2] += Ez_grid[z_idx, y_idx, x_idx] * weight\n        \n        force_i = q_i * E_interp\n        forces.append(force_i.tolist())\n    \n    return forces\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 16, \"alpha\": 3.5, \"charges\": [1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.25], [0.75, 0.75, 0.75]]\n        },\n        {\n            \"N\": 16, \"alpha\": 2.5, \"charges\": [1.0, -0.5, 0.5],\n            \"positions\": [[0.99, 0.01, 0.5], [0.1, 0.9, 0.1], [0.4, 0.4, 0.95]]\n        },\n        {\n            \"N\": 8, \"alpha\": 2.0, \"charges\": [0.0, 0.0, 0.0, 0.0],\n            \"positions\": [[0.2, 0.3, 0.4], [0.6, 0.2, 0.1], [0.8, 0.8, 0.8], [0.1, 0.7, 0.9]]\n        },\n        {\n            \"N\": 32, \"alpha\": 3.0, \"charges\": [1.0, 1.0, -1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.5], [0.75, 0.25, 0.5], [0.25, 0.75, 0.5], [0.75, 0.75, 0.5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_pme_case(case[\"N\"], case[\"alpha\"], case[\"charges\"], case[\"positions\"])\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "A robust PME implementation is not only about getting the right answer but also understanding the sources and magnitudes of its inherent numerical errors. This advanced practice  focuses on a key artifact: the spurious self-force that arises from the grid-based discretization. By computing this error as a function of the mesh size $M$ and the Ewald screening parameter $\\alpha$, you will gain practical insight into tuning PME parameters for optimal accuracy and performance in real-world simulations.",
            "id": "3792344",
            "problem": "Consider a single point charge of magnitude $q$ located at position $\\mathbf{r} \\in [0,L)^3$ in a three-dimensional cubic domain of edge length $L$ with periodic boundary conditions. The electrostatic potential $\\phi(\\mathbf{x})$ satisfies Poisson's equation $-\\nabla^2 \\phi(\\mathbf{x}) = \\rho(\\mathbf{x})$ where $\\rho(\\mathbf{x})$ is the charge density. The particle mesh Ewald (PME) method is a multiscale approach in which long-range interactions are computed in reciprocal space after assigning charges to a mesh. The Ewald splitting introduces a screening parameter $\\alpha > 0$ that separates the interaction into short-range and long-range parts. In reciprocal space, the long-range contribution to the potential is proportional to $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (4 \\alpha^2)) / \\lVert \\mathbf{k} \\rVert^2$ where $\\mathbf{k}$ is a wavevector. The PME uses charge assignment onto a mesh of size $M \\times M \\times M$ via a smooth interpolation kernel; we will use a cubic B-spline (order $p=4$). To compute the electric field $\\mathbf{E}(\\mathbf{x}) = -\\nabla \\phi(\\mathbf{x})$, we employ second-order central finite differences on the mesh and then interpolate the field back to the particle location using the same interpolation weights.\n\nFor a single charge, the exact net force due to interactions with its periodic images should be zero by symmetry. However, discretization choices (finite mesh size, assignment window, and finite-difference differentiation) introduce a spurious self-force. Your task is to compute the magnitude of this spurious PME force error for a single charge as a function of the Ewald screening parameter $\\alpha$ and the mesh size $M$.\n\nUse the following scientifically sound modeling assumptions:\n- The domain is cubic with edge length $L = 1$ (dimensionless length units).\n- The particle has charge $q = 1$ (dimensionless charge units).\n- Charge assignment to the mesh uses the one-dimensional cubic B-spline weights $w_0(u) = \\frac{1}{6}(1-u)^3$, $w_1(u) = \\frac{1}{6}(3u^3 - 6u^2 + 4)$, $w_2(u) = \\frac{1}{6}(-3u^3 + 3u^2 + 3u + 1)$, $w_3(u) = \\frac{1}{6}u^3$, where $u \\in [0,1)$ is the fractional coordinate within the base mesh cell. In three dimensions, the assignment weight is the product of the weights along each axis over the four nearest mesh nodes per axis.\n- The reciprocal-space Green's function is $G(\\mathbf{k};\\alpha) = 4\\pi \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) / \\lVert \\mathbf{k} \\rVert^2$ for $\\mathbf{k} \\neq \\mathbf{0}$ and $G(\\mathbf{0};\\alpha) = 0$.\n- To correct for the smoothing introduced by cubic B-spline assignment and gathering, use the deconvolution factor $S(\\mathbf{k}) = \\left[\\frac{\\sin(k_x h / 2)}{k_x h / 2}\\right]^p \\left[\\frac{\\sin(k_y h / 2)}{k_y h / 2}\\right]^p \\left[\\frac{\\sin(k_z h / 2)}{k_z h / 2}\\right]^p$ with $p=4$ and mesh spacing $h = L/M$. Divide the reciprocal-space influence by $S(\\mathbf{k})^2$.\n- Compute the potential on the mesh by inverse Fourier transform of $H(\\mathbf{k};\\alpha) \\hat{\\rho}(\\mathbf{k})$, where $H(\\mathbf{k};\\alpha) = G(\\mathbf{k};\\alpha) / S(\\mathbf{k})^2$ and $\\hat{\\rho}(\\mathbf{k})$ is the discrete Fourier transform of the assigned charge density.\n- Compute the mesh electric field by second-order central finite differences of the potential in each direction with spacing $h$. Interpolate the mesh field back to the particle position using the same cubic B-spline weights. The force on the particle is $\\mathbf{F} = q \\mathbf{E}(\\mathbf{r})$.\n- Define the PME force error magnitude as $\\varepsilon(\\alpha,M) = \\lVert \\mathbf{F} \\rVert_2$.\n\nImplement the above algorithm exactly and compute $\\varepsilon(\\alpha,M)$ for the following test suite of parameter values (all positions are in dimensionless length units within the unit cube):\n1. $\\alpha = 2.5$, $M = 16$, $\\mathbf{r} = (0.234, 0.567, 0.789)$.\n2. $\\alpha = 3.5$, $M = 32$, $\\mathbf{r} = (0.234, 0.567, 0.789)$.\n3. $\\alpha = 1.0$, $M = 16$, $\\mathbf{r} = (0.234, 0.567, 0.789)$.\n4. $\\alpha = 4.5$, $M = 64$, $\\mathbf{r} = (0.234, 0.567, 0.789)$.\n5. $\\alpha = 2.5$, $M = 32$, $\\mathbf{r} = (0.5, 0.5, 0.5)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots,result_5]$). Each $result_i$ must be a floating-point number equal to $\\varepsilon(\\alpha,M)$ for the corresponding test case, expressed in dimensionless force units. No other text should be printed.",
            "solution": "The user has provided a valid, well-posed problem statement. It is scientifically grounded in the principles of computational electrostatics, specifically the Particle Mesh Ewald (PME) method, and provides a clear, self-contained, and formalizable algorithm for calculating the spurious self-force on a single charge in a periodic system. The problem is objective and its parameters are feasible for computation. I will proceed with a full solution.\n\nThe problem asks for the computation of the spurious self-force experienced by a single charge in a periodic domain, as calculated by the Particle Mesh Ewald (PME) method. This force is an artifact of the discretization inherent in the method—namely, the use of a finite mesh for charge assignment, potential calculation, and field differentiation. For a single charge in a cubic periodic box, the true force from its own periodic images is zero by symmetry. The non-zero force calculated by the PME algorithm is therefore a direct measure of the method's error for a given set of parameters ($\\alpha$, $M$).\n\nThe calculation follows a precise sequence of steps, which we will detail below. The domain is a cube of side length $L=1$ and the particle has charge $q=1$.\n\n### Principle-Based Design\n\nThe PME algorithm is a hybrid-space method that splits the electrostatic potential calculation into a short-range part, computed in real space, and a long-range part, computed in reciprocal (Fourier) space. This problem focuses exclusively on the reciprocal-space contribution to the force, which is where the mesh-based errors predominantly arise. The algorithm can be broken down into the following steps:\n\n**1. Charge Assignment**\n\nThe first step is to transfer the charge of the continuous point particle, located at $\\mathbf{r}$, onto a discrete grid of size $M \\times M \\times M$. This is an interpolation process. The problem specifies using a cubic B-spline kernel of order $p=4$.\n\nLet the mesh spacing be $h = L/M$. The particle's position in scaled mesh coordinates is $\\mathbf{s} = \\mathbf{r} / h$. We find the base mesh index $\\mathbf{i} = \\lfloor \\mathbf{s} \\rfloor$ and the fractional coordinates $\\mathbf{u} = \\mathbf{s} - \\mathbf{i}$, where each component $u_x, u_y, u_z$ is in $[0, 1)$.\n\nThe charge $q$ is distributed among a stencil of $p^3 = 4^3 = 64$ grid points surrounding the particle's position. The weight for a grid point at relative offset $(j_x, j_y, j_z)$ from the base index $\\mathbf{i}$ (where $j_x, j_y, j_z \\in \\{0, 1, 2, 3\\}$) is the product of 1D B-spline weights: $W_{j_x,j_y,j_z} = w_{j_x}(u_x) w_{j_y}(u_y) w_{j_z}(u_z)$. The 1D weights $w_j(u)$ for $j \\in \\{0,1,2,3\\}$ are given as:\n$$w_0(u) = \\frac{1}{6}(1-u)^3$$\n$$w_1(u) = \\frac{1}{6}(3u^3 - 6u^2 + 4)$$\n$$w_2(u) = \\frac{1}{6}(-3u^3 + 3u^2 + 3u + 1)$$\n$$w_3(u) = \\frac{1}{6}u^3$$\nThe charge on a grid node at index $\\mathbf{n} = (\\mathbf{i} + \\mathbf{j}) \\pmod M$ is $\\rho_{mesh}(\\mathbf{n}) = q \\cdot W_{j_x,j_y,j_z}$. This creates a grid-based representation of the charge density, $\\rho_{mesh}$.\n\n**2. Reciprocal Space Potential Calculation**\n\nWith the charge density on the grid, we move to reciprocal space using the Fast Fourier Transform (FFT) to solve for the potential.\n$$ \\hat{\\rho}(\\mathbf{k}) = \\text{FFT}(\\rho_{mesh}) $$\nHere, $\\mathbf{k}$ is a reciprocal lattice vector, $\\mathbf{k} = (2\\pi m_x/L, 2\\pi m_y/L, 2\\pi m_z/L)$, where $m_x, m_y, m_z$ are integer frequency indices.\n\nIn reciprocal space, the Poisson equation $-\\nabla^2 \\phi = \\rho$ becomes $\\lVert \\mathbf{k} \\rVert^2 \\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k})$. The reciprocal space Green's function for the long-range part of the PME potential is given, which includes the Ewald screening factor:\n$$ G(\\mathbf{k};\\alpha) = \\frac{4\\pi \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)}{\\lVert \\mathbf{k} \\rVert^2} \\quad (\\text{for } \\mathbf{k} \\neq \\mathbf{0}), \\quad G(\\mathbf{0};\\alpha) = 0 $$\nThe charge assignment and subsequent force interpolation act as convolutions, which in Fourier space correspond to multiplication by the Fourier transform of the B-spline kernel, denoted $S(\\mathbf{k})$. To counteract this smoothing effect, a deconvolution is performed by dividing by $S(\\mathbf{k})$ for each operation (assignment and interpolation). The problem specifies division by $S(\\mathbf{k})^2$.\n$$ S(\\mathbf{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\frac{\\sin(k_i h / 2)}{k_i h / 2} \\right]^p $$\nwith $p=4$. The limit of the sinc function $(\\sin x / x)$ is $1$ as $x \\to 0$.\n\nThe reciprocal-space potential on the grid is thus computed as:\n$$ \\hat{\\phi}_{mesh}(\\mathbf{k}) = H(\\mathbf{k};\\alpha) \\hat{\\rho}(\\mathbf{k}) = \\frac{G(\\mathbf{k};\\alpha)}{S(\\mathbf{k})^2} \\hat{\\rho}(\\mathbf{k}) $$\n\n**3. Real Space Field Calculation**\n\nThe potential on the real-space grid, $\\phi_{mesh}$, is obtained by applying the inverse FFT:\n$$ \\phi_{mesh} = \\text{IFFT}(\\hat{\\phi}_{mesh}(\\mathbf{k})) $$\nFrom the gridded potential, the electric field $\\mathbf{E} = -\\nabla\\phi$ is approximated using a second-order central finite difference scheme. For the x-component at grid node $\\mathbf{n}=(n_x, n_y, n_z)$:\n$$ E_x(\\mathbf{n}) = - \\frac{\\phi_{mesh}(n_x+1, n_y, n_z) - \\phi_{mesh}(n_x-1, n_y, n_z)}{2h} $$\nAnalogous expressions apply for $E_y$ and $E_z$. Periodic boundary conditions are applied to the grid indices.\n\n**4. Force Interpolation (Gathering)**\n\nThe final step is to find the force on the particle at its original position $\\mathbf{r}$. This is done by interpolating the electric field from the grid back to the particle's location, a process often called \"gathering\". The same B-spline interpolation kernel used for charge assignment is used here.\nThe force $\\mathbf{F} = (F_x, F_y, F_z)$ is given by:\n$$ F_x = q \\sum_{j_x, j_y, j_z=0}^{p-1} w_{j_x}(u_x) w_{j_y}(u_y) w_{j_z}(u_z) E_x((\\mathbf{i} + \\mathbf{j}) \\pmod M) $$\nand similarly for $F_y$ and $F_z$.\n\n**5. Spurious Force Error**\n\nThe resulting force vector $\\mathbf{F}$ is the spurious self-force. Its magnitude is calculated as the Euclidean norm:\n$$ \\varepsilon(\\alpha, M) = \\lVert \\mathbf{F} \\rVert_2 = \\sqrt{F_x^2 + F_y^2 + F_z^2} $$\nThis value quantifies the systematic error introduced by the PME grid for a single particle. Implementing this multi-step algorithm for each set of given parameters allows for the precise determination of this error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to calculate and print the spurious PME force error for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (alpha, M, r_vec)\n        (2.5, 16, np.array([0.234, 0.567, 0.789])),\n        (3.5, 32, np.array([0.234, 0.567, 0.789])),\n        (1.0, 16, np.array([0.234, 0.567, 0.789])),\n        (4.5, 64, np.array([0.234, 0.567, 0.789])),\n        (2.5, 32, np.array([0.5, 0.5, 0.5])),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, M, r_vec = case\n        force_magnitude = compute_pme_force_error(alpha, M, r_vec)\n        results.append(force_magnitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\n\ndef get_bspline_weights(u):\n    \"\"\"\n    Computes the 1D cubic B-spline (p=4) weights for a fractional coordinate u in [0,1).\n    \"\"\"\n    w = np.zeros(4)\n    w[0] = (1.0 - u)**3 / 6.0\n    w[1] = (3.0 * u**3 - 6.0 * u**2 + 4.0) / 6.0\n    w[2] = (-3.0 * u**3 + 3.0 * u**2 + 3.0 * u + 1.0) / 6.0\n    w[3] = u**3 / 6.0\n    return w\n\ndef compute_pme_force_error(alpha, M, r_vec):\n    \"\"\"\n    Computes the spurious PME self-force for a single particle.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    q = 1.0\n    p = 4\n    h = L / M\n\n    # Step 1: Charge Assignment\n    rho_mesh = np.zeros((M, M, M), dtype=float)\n    s_vec = r_vec / h  # Scaled coordinates\n    i_vec = np.floor(s_vec).astype(int)\n    u_vec = s_vec - i_vec\n\n    weights_x = get_bspline_weights(u_vec[0])\n    weights_y = get_bspline_weights(u_vec[1])\n    weights_z = get_bspline_weights(u_vec[2])\n\n    for jx in range(p):\n        for jy in range(p):\n            for jz in range(p):\n                weight = weights_x[jx] * weights_y[jy] * weights_z[jz]\n                nx = (i_vec[0] + jx) % M\n                ny = (i_vec[1] + jy) % M\n                nz = (i_vec[2] + jz) % M\n                rho_mesh[nx, ny, nz] += q * weight\n\n    # Step 2: Forward FFT\n    rho_hat = np.fft.fftn(rho_mesh)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wavevectors k\n    m_vals = np.fft.fftfreq(M) * M\n    mx, my, mz = np.meshgrid(m_vals, m_vals, m_vals, indexing='ij')\n\n    kx = 2.0 * np.pi * mx / L\n    ky = 2.0 * np.pi * my / L\n    kz = 2.0 * np.pi * mz / L\n    k_sq = kx**2 + ky**2 + kz**2\n    \n    # Calculate G(k)\n    G_k = np.zeros((M, M, M), dtype=float)\n    non_zero_k = k_sq > 1e-12\n    G_k[non_zero_k] = 4.0 * np.pi * np.exp(-k_sq[non_zero_k] / (4.0 * alpha**2)) / k_sq[non_zero_k]\n\n    # Calculate S(k)\n    sinc_arg_x = kx * h / 2.0\n    sinc_arg_y = ky * h / 2.0\n    sinc_arg_z = kz * h / 2.0\n    \n    # Use np.sinc for sinc(x) = sin(pi*x)/(pi*x)\n    sx = np.sinc(sinc_arg_x / np.pi)**p\n    sy = np.sinc(sinc_arg_y / np.pi)**p\n    sz = np.sinc(sinc_arg_z / np.pi)**p\n    S_k_sq = (sx * sy * sz)**2\n    \n    # Avoid division by zero for S_k_sq, though it should be 1 at k=0\n    S_k_sq[S_k_sq < 1e-12] = 1.0\n\n    H_k = G_k / S_k_sq\n    phi_hat = H_k * rho_hat\n\n    # Step 4: Inverse FFT for potential\n    phi_mesh = np.fft.ifftn(phi_hat).real\n\n    # Step 5: Finite Difference for Electric Field\n    Ex_mesh = -0.5 * (np.roll(phi_mesh, -1, axis=0) - np.roll(phi_mesh, 1, axis=0)) / h\n    Ey_mesh = -0.5 * (np.roll(phi_mesh, -1, axis=1) - np.roll(phi_mesh, 1, axis=1)) / h\n    Ez_mesh = -0.5 * (np.roll(phi_mesh, -1, axis=2) - np.roll(phi_mesh, 1, axis=2)) / h\n\n    # Step 6: Interpolate Field (Gathering)\n    Fx, Fy, Fz = 0.0, 0.0, 0.0\n    for jx in range(p):\n        for jy in range(p):\n            for jz in range(p):\n                weight = weights_x[jx] * weights_y[jy] * weights_z[jz]\n                nx = (i_vec[0] + jx) % M\n                ny = (i_vec[1] + jy) % M\n                nz = (i_vec[2] + jz) % M\n                Fx += weight * Ex_mesh[nx, ny, nz]\n                Fy += weight * Ey_mesh[nx, ny, nz]\n                Fz += weight * Ez_mesh[nx, ny, nz]\n    \n    force_vec = q * np.array([Fx, Fy, Fz])\n    \n    # Step 7: Compute Force Error Magnitude\n    force_magnitude = np.linalg.norm(force_vec)\n\n    return force_magnitude\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}