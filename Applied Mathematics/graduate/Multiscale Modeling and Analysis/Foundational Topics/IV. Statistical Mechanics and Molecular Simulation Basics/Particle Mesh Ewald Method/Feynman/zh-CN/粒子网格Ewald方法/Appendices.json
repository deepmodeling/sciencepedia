{
    "hands_on_practices": [
        {
            "introduction": "PME方法的第一步是将离散的点电荷“分配”到规则的网格上，从而创建一个平滑的电荷密度场，以便在傅里叶空间中求解。这个练习将指导您从电荷守恒和线性插值等基本原理出发，推导出“云中粒子”(Cloud-In-Cell, CIC)电荷分配方案的权重。通过这个过程，您将深入理解插值方案在多尺度模拟中的核心作用及其数学构造。",
            "id": "3849522",
            "problem": "粒子网格埃瓦尔德（PME）方法中的一个关键步骤是将点电荷分配到网格上，以获得适合在傅里叶空间中求解泊松方程的光滑网格电荷密度。考虑一个三维均匀笛卡尔网格，其沿 $x$、$y$ 和 $z$ 轴的间距分别为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。一个电荷为 $q$ 的粒子位于位置 $\\mathbf{r} = (x,y,z)$，处在一个由左下近角节点索引 $(i,j,k)$ 和右上远角节点索引 $(i+1,j+1,k+1)$ 界定的单个网格单元内。定义分数偏移量\n$$\nu_x = \\frac{x - x_i}{\\Delta x}, \\quad u_y = \\frac{y - y_j}{\\Delta y}, \\quad u_z = \\frac{z - z_k}{\\Delta z},\n$$\n其中 $x_i = i \\,\\Delta x$，$y_j = j \\,\\Delta y$，$z_k = k \\,\\Delta z$，并假设 $u_x,u_y,u_z \\in [0,1)$。\n\n从适用于多尺度材料模拟和基于网格的插值的第一性原理出发，仅使用以下基本要求来推导对八个最近网格节点的电荷云（Cloud-In-Cell, CIC）电荷分配权重：\n- 电荷守恒：分配的分数之和等于一。\n- 局域性：只有包含单元的八个最近节点获得非零权重。\n- 一维线性一致性：当限制在单根轴上时，分配简化为两个相邻节点之间的线性插值。\n- 笛卡尔网格上的张量积可分性：三维分配是沿每个轴的一维分配的乘积。\n\n推导八个无量纲权重 $w_{n}$（$n=1,\\dots,8$）的显式解析表达式，这些权重对应于按以下顺序排列的节点：\n$$\n(i,j,k),\\ (i+1,j,k),\\ (i,j+1,k),\\ (i+1,j+1,k),\\ (i,j,k+1),\\ (i+1,j,k+1),\\ (i,j+1,k+1),\\ (i+1,j+1,k+1).\n$$\n将最终答案表示为一个包含按此顺序排列的八个 $w_n$ 的单行向量，用 $u_x$、$u_y$ 和 $u_z$ 表示。不包含单位。最终答案必须是单个解析表达式。",
            "solution": "该问题具有科学依据，提法恰当，客观，并包含推导所需电荷分配权重的所有必要信息。因此，该问题被认为是有效的，并提供解答。\n\n推导过程从给定的基本要求出发。我们首先确定一维插值权重的形式，然后使用张量积可分性原理将其扩展到三维。\n\n一维线性一致性要求指出，分配简化为线性插值。考虑 $x$ 轴。一个分数坐标为 $u_x \\in [0,1)$ 的粒子位于整数索引为 $i$ 和 $i+1$ 的网格节点之间。设 $W_i(u_x)$ 和 $W_{i+1}(u_x)$ 分别是分配给节点 $i$ 和 $i+1$ 的无量纲权重。对于线性插值，权重必须是 $u_x$ 的线性函数。\n当粒子恰好位于节点 $i$ 时，其分数坐标为 $u_x=0$。粒子的所有电荷都必须分配给节点 $i$。这给出了边界条件 $W_i(0) = 1$ 和 $W_{i+1}(0) = 0$。\n当粒子恰好位于节点 $i+1$ 时，其分数坐标为 $u_x=1$。粒子的所有电荷都必须分配给节点 $i+1$。这给出了边界条件 $W_i(1) = 0$ 和 $W_{i+1}(1) = 1$。\n满足条件 $W_i(0) = 1$ 和 $W_i(1) = 0$ 的唯一线性函数 $W_i(u_x)$ 是：\n$$\nW_i(u_x) = 1 - u_x\n$$\n满足条件 $W_{i+1}(0) = 0$ 和 $W_{i+1}(1) = 1$ 的唯一线性函数 $W_{i+1}(u_x)$ 是：\n$$\nW_{i+1}(u_x) = u_x\n$$\n这些是一维的电荷云（CIC）权重。我们验证一维的电荷守恒：权重之和为 $W_i(u_x) + W_{i+1}(u_x) = (1 - u_x) + u_x = 1$。这与电荷守恒的要求一致。\n\n接下来，我们使用笛卡尔网格上的张量积可分性要求来构建三维权重。分配给一个节点的权重是每个坐标的一维权重的乘积。粒子位于其左下近角为节点 $(i,j,k)$ 的单元中。该单元的八个节点由 $(i+l, j+m, k+p)$ 索引，其中 $l, m, p \\in \\{0,1\\}$。\n分数坐标为 $u_x$，$u_y$ 和 $u_z$。分配给节点 $(i+l,j+m,k+p)$ 的权重 $w_{i+l,j+m,k+p}$ 由下式给出：\n$$\nw_{i+l,j+m,k+p} = W_l(u_x) W_m(u_y) W_p(u_z)\n$$\n其中，我们将一维权重函数推广为：对于任意给定轴上的“下”节点，$W_0(u) = 1-u$；对于“上”节点，$W_1(u) = u$。\n代入这些可得分配给节点 $(i+l,j+m,k+p)$ 的权重通用公式：\n$$\nw_{i+l,j+m,k+p} = (1-u_x)^{1-l} (u_x)^l (1-u_y)^{1-m} (u_y)^m (1-u_z)^{1-p} (u_z)^p\n$$\n局域性要求通过构造得到满足，因为只有单元的八个节点（其中 $l,m,p \\in \\{0,1\\}$）获得非零权重。系统中的所有其他节点权重为零。\n总电荷守恒也由张量积结构保证：\n$$\n\\sum_{l=0}^{1} \\sum_{m=0}^{1} \\sum_{p=0}^{1} w_{i+l,j+m,k+p} = \\left( \\sum_{l=0}^{1} W_l(u_x) \\right) \\left( \\sum_{m=0}^{1} W_m(u_y) \\right) \\left( \\sum_{p=0}^{1} W_p(u_z) \\right)\n$$\n由于括号中的每个和都等于 $1$，所以所有八个权重的总和是 $1 \\times 1 \\times 1 = 1$。\n\n我们现在列出对应于指定节点顺序的八个权重 $w_n$（$n=1, \\dots, 8$）的显式表达式。\n对于节点 $(i,j,k)$，我们有 $(l,m,p)=(0,0,0)$，所以权重为 $w_1 = W_0(u_x)W_0(u_y)W_0(u_z) = (1-u_x)(1-u_y)(1-u_z)$。\n对于节点 $(i+1,j,k)$，我们有 $(l,m,p)=(1,0,0)$，所以权重为 $w_2 = W_1(u_x)W_0(u_y)W_0(u_z) = u_x(1-u_y)(1-u_z)$。\n对于节点 $(i,j+1,k)$，我们有 $(l,m,p)=(0,1,0)$，所以权重为 $w_3 = W_0(u_x)W_1(u_y)W_0(u_z) = (1-u_x)u_y(1-u_z)$。\n对于节点 $(i+1,j+1,k)$，我们有 $(l,m,p)=(1,1,0)$，所以权重为 $w_4 = W_1(u_x)W_1(u_y)W_0(u_z) = u_x u_y (1-u_z)$。\n对于节点 $(i,j,k+1)$，我们有 $(l,m,p)=(0,0,1)$，所以权重为 $w_5 = W_0(u_x)W_0(u_y)W_1(u_z) = (1-u_x)(1-u_y)u_z$。\n对于节点 $(i+1,j,k+1)$，我们有 $(l,m,p)=(1,0,1)$，所以权重为 $w_6 = W_1(u_x)W_0(u_y)W_1(u_z) = u_x(1-u_y)u_z$。\n对于节点 $(i,j+1,k+1)$，我们有 $(l,m,p)=(0,1,1)$，所以权重为 $w_7 = W_0(u_x)W_1(u_y)W_1(u_z) = (1-u_x)u_y u_z$。\n对于节点 $(i+1,j+1,k+1)$，我们有 $(l,m,p)=(1,1,1)$，所以权重为 $w_8 = W_1(u_x)W_1(u_y)W_1(u_z) = u_x u_y u_z$。\n\n这八个表达式构成了推导出的电荷云分配权重。它们表示分配给周围八个网格节点中每一个的粒子电荷 $q$ 的分数。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-u_x)(1-u_y)(1-u_z) & u_x(1-u_y)(1-u_z) & (1-u_x)u_y(1-u_z) & u_x u_y (1-u_z) & (1-u_x)(1-u_y)u_z & u_x(1-u_y)u_z & (1-u_x)u_y u_z & u_x u_y u_z\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了电荷分配的理论后，下一步是构建PME方法的核心计算引擎。本练习将引导您编写一个简化的PME程序，利用快速傅里叶变换(FFT)在倒易空间中高效计算长程力。这个实践将连接起从电荷分配、傅里叶变换、泊松方程求解到力插值的完整算法链条，是理解PME工作流程的关键一步。",
            "id": "3282499",
            "problem": "您需要使用快速傅里叶变换 (FFT) 实现一个简化的三维粒子网格 Ewald (PME) 方法，以在周期性立方体区域中计算长程静电力。目标是在周期性边界条件和无量纲单位下，仅计算由倒易空间（长程）分量产生的粒子间作用力。实现必须是完全自包含的，并严格使用快速傅里叶变换 (FFT) 作为计算加速器。\n\n计算区域是一个边长为 $L=1$ 的周期性立方体。所有位置均以 $[0,1)$ 范围内的简约坐标给出，所有电荷都是无量纲的，并且力必须以无量纲单位返回。不需要也不允许进行物理单位转换。在此设置中不适用角度单位。\n\n您必须从离散傅里叶变换和泊松方程的基本原理和定义出发，但问题陈述并未提供任何用于 PME 实现的快捷公式。您的方法必须从第一性原理推导得出：将电荷映射到网格上，通过 FFT 和一个屏蔽格林函数在倒易空间中计算势，在傅里叶空间中微分以获得电场，变换回实空间，并在粒子位置上插值计算力。\n\n算法规范：\n- 区域是一个边长为 $L=1$ 的周期性立方体，离散化为 $N \\times N \\times N$ 个点的均匀网格。\n- 使用 Cloud-In-Cell (CIC) 电荷分配方案将粒子电荷放置到网格上。\n- 使用三维快速傅里叶变换 (FFT) 将网格电荷密度转换到倒易空间。\n- 应用一个由正屏蔽参数 $\\alpha$ 表征的屏蔽倒易空间格林函数来计算长程势。零模式 $\\mathbf{k}=\\mathbf{0}$ 必须设置为零，以强制周期性单元的电中性。\n- 通过在倒易空间中对势进行微分来计算电场。\n- 使用逆 FFT 返回到实空间，并使用相同的 CIC 权重在粒子位置上插值电场。粒子 $i$ 上的力是 $q_i$ 乘以其位置处的插值电场。\n- 在整个过程中严格使用无量纲量。\n\n测试套件：\n实现您的程序，使其无需任何用户输入即可精确运行以下四个测试用例。对于每个用例，$N$ 表示网格大小，$\\alpha$ 表示屏蔽参数，$q_i$ 是粒子电荷，$\\mathbf{r}_i$ 是单位立方体中以简约坐标表示的粒子位置。\n1. 正常路径用例：$N=16$，$\\alpha=3.5$，两个粒子，电荷为 $[1.0,-1.0]$，位置为 $\\mathbf{r}_1=[0.25,0.25,0.25]$，$\\mathbf{r}_2=[0.75,0.75,0.75]$。\n2. 边界放置用例：$N=16$，$\\alpha=2.5$，三个粒子，电荷为 $[1.0,-0.5,0.5]$，位置为 $\\mathbf{r}_1=[0.99,0.01,0.5]$，$\\mathbf{r}_2=[0.1,0.9,0.1]$，$\\mathbf{r}_3=[0.4,0.4,0.95]$。\n3. 零电荷边缘用例：$N=8$，$\\alpha=2.0$，四个粒子，电荷为 $[0.0,0.0,0.0,0.0]$，位置为 $\\mathbf{r}_1=[0.2,0.3,0.4]$，$\\mathbf{r}_2=[0.6,0.2,0.1]$，$\\mathbf{r}_3=[0.8,0.8,0.8]$，$\\mathbf{r}_4=[0.1,0.7,0.9]$。\n4. 对称布置用例：$N=32$，$\\alpha=3.0$，四个粒子，电荷为 $[1.0,1.0,-1.0,-1.0]$，位置为 $\\mathbf{r}_1=[0.25,0.25,0.5]$，$\\mathbf{r}_2=[0.75,0.25,0.5]$，$\\mathbf{r}_3=[0.25,0.75,0.5]$，$\\mathbf{r}_4=[0.75,0.75,0.5]$。\n\n所需输出：\n对于每个测试用例，输出一个粒子力向量列表，其中每个力向量是一个包含三个浮点数 $[F_x,F_y,F_z]$ 的列表，单位为无量纲。将四个用例的列表聚合到一个单一列表中。您的程序应生成单行输出，其中包含一个用方括号括起来且无空格的逗号分隔列表形式的结果，其中每个元素本身就是一个力向量列表（例如，$[[[F_{x,1},F_{y,1},F_{z,1}],\\ldots],\\ldots]$）。\n\n您的实现必须：\n- 仅使用 Python 标准库和 NumPy 库。\n- 是确定性的，并且不需要任何输入。\n- 在电荷分配和场插值中一致地处理周期性边界条件。\n- 使用三维 FFT 计算倒易空间解。",
            "solution": "问题要求实现一种简化的三维粒子网格 Ewald (PME) 方法，用于计算周期性立方体区域内一组带电粒子所受静电力的长程分量。该解决方案必须从基本原理推导得出。\n\n### 1. 基本原理：倒易空间中的静电学\n\n静电势 $\\phi(\\mathbf{r})$ 和电荷密度 $\\rho(\\mathbf{r})$ 之间的基本关系由泊松方程给出。在本问题指定的无量纲单位中，我们写作：\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})\n$$\n电场 $\\mathbf{E}(\\mathbf{r})$ 是势的负梯度：\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})\n$$\n系统定义在一个边长为 $L=1$ 且具有周期性边界条件的立方体盒子中。这类问题很自然地使用傅里叶级数处理，出于计算目的，傅里叶级数变为离散傅里叶变换 (DFT)。周期性区域上的函数 $f(\\mathbf{r})$ 可以由其傅里叶系数 $\\tilde{f}(\\mathbf{k})$ 表示：\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) e^{i\\mathbf{k} \\cdot \\mathbf{r}}\n$$\n其中波矢 $\\mathbf{k}$ 由于周期性而是离散的：$\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z) = 2\\pi(n_x, n_y, n_z)$ (因为 $L=1$)，其中 $n_x, n_y, n_z$ 是整数。\n\n在傅里叶空间中，梯度算子 $\\nabla$ 变换为乘以 $i\\mathbf{k}$，拉普拉斯算子 $\\nabla^2$ 变换为乘以 $-|\\mathbf{k}|^2$。对控制方程应用傅里叶变换，得到其代数对应形式：\n$$\n-|\\mathbf{k}|^2 \\tilde{\\phi}(\\mathbf{k}) = -\\tilde{\\rho}(\\mathbf{k}) \\implies \\tilde{\\phi}(\\mathbf{k}) = \\frac{\\tilde{\\rho}(\\mathbf{k})}{|\\mathbf{k}|^2}\n$$\n$$\n\\tilde{\\mathbf{E}}(\\mathbf{k}) = -i\\mathbf{k} \\tilde{\\phi}(\\mathbf{k})\n$$\n\n### 2. 粒子网格 Ewald (PME) 方法\n\nPME 方法通过在网格上求解一个平滑的势，提供了一种计算长程力的高效方法。Ewald 分解的核心思想是将点电荷替换为两个分布的叠加：一个用于短程相互作用的局域分布（不属于本问题范畴），以及一个用于倒易空间计算的平滑长程分布。这个平滑分布通常是每个粒子对应的一个高斯云。\n\n这种平滑化在倒易空间中的效果是在势的计算中引入一个阻尼因子。问题中指定的“屏蔽倒易空间格林函数”将来自泊松方程的 $1/|\\mathbf{k}|^2$ 项与一个依赖于屏蔽参数 $\\alpha$ 的高斯因子相结合。因此，傅里叶空间中的势计算如下：\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\n其中 $\\tilde{\\rho}(\\mathbf{k})$ 是网格上电荷密度的傅里叶变换，而 $\\tilde{G}(\\mathbf{k})$ 是 PME 倒易空间核（或格林函数）：\n$$\n\\tilde{G}(\\mathbf{k}) = \\frac{\\exp(-|\\mathbf{k}|^2 / (4\\alpha^2))}{|\\mathbf{k}|^2}\n$$\n对于 $\\mathbf{k} = \\mathbf{0}$，分母 $|\\mathbf{k}|^2$ 为零，导致奇异性。该项对应于系统的平均势。对于在周期性盒子中整体呈电中性的系统，该项对力的贡献为零。问题强制要求将 $\\mathbf{k}=\\mathbf{0}$ 模式设置为零，这是标准流程。因此，我们定义 $\\tilde{G}(\\mathbf{0}) = 0$。\n\n### 3. 离散化和算法步骤\n\n连续场在均匀的 $N \\times N \\times N$ 网格上进行离散化。连续傅里叶变换被离散傅里叶变换 (DFT) 替代，而 DFT 则通过快速傅里叶变换 (FFT) 算法高效计算。设网格间距为 $h = L/N = 1/N$。\n\n#### 步骤 1：电荷分配\n粒子电荷在连续表示中是狄拉克δ函数，必须被转移到离散网格上。这里使用 Cloud-in-Cell (CIC) 或三线性插值方案。对于一个电荷为 $q_i$、简约位置为 $\\mathbf{r}_i = (u_i, v_i, w_i) \\in [0,1)^3$ 的粒子 $i$，其缩放坐标为 $\\mathbf{s}_i = N\\mathbf{r}_i$。$\\mathbf{s}_i$ 的整数部分确定了其所在的主网格单元，$\\mathbf{n}_i = (\\lfloor s_{ix} \\rfloor, \\lfloor s_{iy} \\rfloor, \\lfloor s_{iz} \\rfloor)$，而小数部分则给出了在该单元内的位移，$\\mathbf{d}_i = \\mathbf{s}_i - \\mathbf{n}_i$。\n\n电荷 $q_i$ 被分配到包含 $\\mathbf{s}_i$ 的单元的 8 个角点上。分配给距 $\\mathbf{n}_i$ 偏移量为 $(\\delta_x, \\delta_y, \\delta_z)$（其中 $\\delta_j \\in \\{0,1\\}$）的角点的电荷为：\n$$\n\\Delta\\rho = q_i \\cdot W_x(\\delta_x) \\cdot W_y(\\delta_y) \\cdot W_z(\\delta_z)\n$$\n其中权重因子为 $W_j(\\delta_j) = (1-d_{ij})^{1-\\delta_j} d_{ij}^{\\delta_j}$。对所有粒子执行此过程，在网格 $\\rho_{\\text{grid}}$ 上累积电荷。网格索引对 $N$ 取模以强制周期性。\n\n#### 步骤 2：电荷密度的傅里叶变换\n网格化的电荷密度 $\\rho_{\\text{grid}}$ 使用三维 FFT 变换到倒易空间：\n$$\n\\tilde{\\rho}(\\mathbf{k}) = \\text{FFT3D}[\\rho_{\\text{grid}}]\n$$\n\n#### 步骤 3：倒易空间计算\n在傅里叶空间中计算势和电场。\n首先，构建离散波矢 $\\mathbf{k} = 2\\pi(n_x, n_y, n_z)$ 的网格，其中 $n_x, n_y, n_z$ 是对应于 FFT 网格索引的整数频率。\n然后，计算所有 $\\mathbf{k}$ 的格林函数 $\\tilde{G}(\\mathbf{k})$，并设置 $\\tilde{G}(\\mathbf{0})=0$。\n通过逐元素相乘来求得势：\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\n然后计算电场分量：\n$$\n\\tilde{E}_x(\\mathbf{k}) = -i k_x \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_y(\\mathbf{k}) = -i k_y \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_z(\\mathbf{k}) = -i k_z \\tilde{\\phi}(\\mathbf{k})\n$$\n\n#### 步骤 4：傅里叶逆变换\n通过对 $\\tilde{\\mathbf{E}}(\\mathbf{k})$ 的每个分量应用三维逆 FFT，可以得到网格上的电场 $\\mathbf{E}_{\\text{grid}}$：\n$$\n\\mathbf{E}_{\\text{grid}}(\\mathbf{r}) = \\text{iFFT3D}[\\tilde{\\mathbf{E}}(\\mathbf{k})]\n$$\niFFT 的结果将是一个复数数组；物理场是其结果的实部。\n\n#### 步骤 5：力的插值和计算\n为了求得每个粒子上的力，必须将电场从网格插值回粒子所在的位置。为保持一致性并确保动量守恒（即 $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$），应使用与电荷分配相同的 CIC 插值方案。粒子 $i$ 位置 $\\mathbf{r}_i$ 处的电场是其周围 8 个网格点上场值的加权平均：\n$$\n\\mathbf{E}(\\mathbf{r}_i) = \\sum_{\\text{8 neighbors } \\mathbf{g}} \\mathbf{E}_{\\text{grid}}(\\mathbf{g}) \\cdot W(\\mathbf{r}_i, \\mathbf{g})\n$$\n其中权重 $W$ 与步骤 1 中的三线性权重相同。\n最后，粒子 $i$ 上的力计算如下：\n$$\n\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)\n$$\n对所有粒子和每个提供的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list_no_spaces(item):\n    \"\"\"\n    Recursively formats a nested list or numpy array into a string\n    with no spaces, as per the strict output format requirement.\n    \"\"\"\n    if isinstance(item, (list, np.ndarray)):\n        return \"[\" + \",\".join(format_list_no_spaces(x) for x in item) + \"]\"\n    return str(item)\n\ndef solve_pme_case(N, alpha, charges, positions):\n    \"\"\"\n    Computes reciprocal-space electrostatic forces for one test case.\n    \"\"\"\n    # Box length L=1 is assumed throughout.\n    L = 1.0\n    \n    # Step 1: Charge Assignment (CIC)\n    rho = np.zeros((N, N, N), dtype=float)\n    num_particles = len(charges)\n    # Store particle info for interpolation later\n    particle_info = []\n\n    for i in range(num_particles):\n        q_i = charges[i]\n        r_i = np.array(positions[i]) # Reduced coordinates [0, 1)\n\n        s_i = r_i * N\n        n_i = np.floor(s_i).astype(int)\n        d_i = s_i - n_i\n\n        particle_info.append({'n': n_i, 'd': d_i})\n\n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n                    \n                    weight = wx * wy * wz\n                    rho[z_idx, y_idx, x_idx] += q_i * weight\n    \n    # Step 2: FFT of charge density\n    rho_k = np.fft.fftn(rho)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wave vectors k\n    kx_int = np.fft.fftfreq(N) * N\n    ky_int = np.fft.fftfreq(N) * N\n    kz_int = np.fft.fftfreq(N) * N\n    \n    kx = 2 * np.pi * kx_int / L\n    ky = 2 * np.pi * ky_int / L\n    kz = 2 * np.pi * kz_int / L\n    \n    kz_grid, ky_grid, kx_grid = np.meshgrid(kz, ky, kx, indexing='ij')\n\n    k_squared = kx_grid**2 + ky_grid**2 + kz_grid**2\n    \n    # Calculate reciprocal Green's function G_k\n    G_k = np.zeros((N, N, N), dtype=float)\n    # Avoid division by zero at k=0\n    non_zero_k = k_squared != 0\n    G_k[non_zero_k] = np.exp(-k_squared[non_zero_k] / (4 * alpha**2)) / k_squared[non_zero_k]\n    # k=0 mode is explicitly set to 0. It is already 0 from initialization.\n\n    # Calculate potential and field in Fourier space\n    phi_k = G_k * rho_k\n    \n    Ex_k = -1j * kx_grid * phi_k\n    Ey_k = -1j * ky_grid * phi_k\n    Ez_k = -1j * kz_grid * phi_k\n\n    # Step 4: Inverse FFT to get E-field on the grid\n    Ex_grid = np.real(np.fft.ifftn(Ex_k))\n    Ey_grid = np.real(np.fft.ifftn(Ey_k))\n    Ez_grid = np.real(np.fft.ifftn(Ez_k))\n\n    # Step 5: Force Interpolation and Calculation\n    forces = []\n    for i in range(num_particles):\n        q_i = charges[i]\n        n_i = particle_info[i]['n']\n        d_i = particle_info[i]['d']\n        \n        E_interp = np.zeros(3, dtype=float)\n        \n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n\n                    weight = wx * wy * wz\n                    E_interp[0] += Ex_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[1] += Ey_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[2] += Ez_grid[z_idx, y_idx, x_idx] * weight\n        \n        force_i = q_i * E_interp\n        forces.append(force_i.tolist())\n    \n    return forces\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 16, \"alpha\": 3.5, \"charges\": [1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.25], [0.75, 0.75, 0.75]]\n        },\n        {\n            \"N\": 16, \"alpha\": 2.5, \"charges\": [1.0, -0.5, 0.5],\n            \"positions\": [[0.99, 0.01, 0.5], [0.1, 0.9, 0.1], [0.4, 0.4, 0.95]]\n        },\n        {\n            \"N\": 8, \"alpha\": 2.0, \"charges\": [0.0, 0.0, 0.0, 0.0],\n            \"positions\": [[0.2, 0.3, 0.4], [0.6, 0.2, 0.1], [0.8, 0.8, 0.8], [0.1, 0.7, 0.9]]\n        },\n        {\n            \"N\": 32, \"alpha\": 3.0, \"charges\": [1.0, 1.0, -1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.5], [0.75, 0.25, 0.5], [0.25, 0.75, 0.5], [0.75, 0.75, 0.5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_pme_case(case[\"N\"], case[\"alpha\"], case[\"charges\"], case[\"positions\"])\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "任何数值方法都有其固有的误差，PME也不例外，一个典型的例子是“伪自相互作用力”，即粒子由于与网格的相互作用而感受到一个本不应存在的力。这个练习要求您实现一个程序来量化这种由离散化引起的系统误差，并分析它如何依赖于PME的关键参数（Ewald分离参数 $\\alpha$ 和网格大小 $M$）。通过探索这种误差的来源，您将能更深刻地理解在实际模拟中如何权衡计算精度与效率。",
            "id": "3792344",
            "problem": "考虑一个大小为 $q$ 的单点电荷，位于一个边长为 $L$ 的三维立方域 $\\mathbf{r} \\in [0,L)^3$ 中，该区域具有周期性边界条件。静电势 $\\phi(\\mathbf{x})$ 满足泊松方程 $-\\nabla^2 \\phi(\\mathbf{x}) = \\rho(\\mathbf{x})$，其中 $\\rho(\\mathbf{x})$ 是电荷密度。粒子网格埃瓦尔德 (PME) 方法是一种多尺度方法，其中长程相互作用是在将电荷分配到网格上后，在倒易空间中计算的。埃瓦尔德分解引入了一个屏蔽参数 $\\alpha > 0$，它将相互作用分为短程和长程部分。在倒易空间中，势的长程贡献与 $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (4 \\alpha^2)) / \\lVert \\mathbf{k} \\rVert^2$ 成正比，其中 $\\mathbf{k}$ 是一个波矢。PME 使用一个平滑的插值核将电荷分配到一个大小为 $M \\times M \\times M$ 的网格上；我们将使用三次B样条（阶数 $p=4$）。为了计算电场 $\\mathbf{E}(\\mathbf{x}) = -\\nabla \\phi(\\mathbf{x})$，我们在网格上采用二阶中心有限差分，然后使用相同的插值权重将场插值回粒子位置。\n\n对于单个电荷，由于与其周期性镜像的相互作用而产生的精确合力，根据对称性应为零。然而，离散化选择（有限的网格尺寸、分配窗口和有限差分微分）会引入一个伪自作用力。您的任务是计算这个伪 PME 力误差的大小，作为埃瓦尔德屏蔽参数 $\\alpha$ 和网格尺寸 $M$ 的函数。\n\n使用以下科学上合理的建模假设：\n- 域是边长为 $L = 1$ 的立方体（无量纲长度单位）。\n- 粒子电荷为 $q = 1$（无量纲电荷单位）。\n- 向网格分配电荷使用一维三次B样条权重 $w_0(u) = \\frac{1}{6}(1-u)^3$，$w_1(u) = \\frac{1}{6}(3u^3 - 6u^2 + 4)$，$w_2(u) = \\frac{1}{6}(-3u^3 + 3u^2 + 3u + 1)$，$w_3(u) = \\frac{1}{6}u^3$，其中 $u \\in [0,1)$ 是基础网格单元内的分数坐标。在三维中，分配权重是每个轴上四个最近网格节点的各轴权重之积。\n- 倒易空间格林函数为 $G(\\mathbf{k};\\alpha) = 4\\pi \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) / \\lVert \\mathbf{k} \\rVert^2$（对于 $\\mathbf{k} \\neq \\mathbf{0}$）和 $G(\\mathbf{0};\\alpha) = 0$。\n- 为校正三次B样条分配和收集引入的平滑效应，使用反卷积因子 $S(\\mathbf{k}) = \\left[\\frac{\\sin(k_x h / 2)}{k_x h / 2}\\right]^p \\left[\\frac{\\sin(k_y h / 2)}{k_y h / 2}\\right]^p \\left[\\frac{\\sin(k_z h / 2)}{k_z h / 2}\\right]^p$，其中 $p=4$，网格间距 $h = L/M$。将倒易空间影响除以 $S(\\mathbf{k})^2$。\n- 通过对 $H(\\mathbf{k};\\alpha) \\hat{\\rho}(\\mathbf{k})$ 进行傅里叶逆变换来计算网格上的势，其中 $H(\\mathbf{k};\\alpha) = G(\\mathbf{k};\\alpha) / S(\\mathbf{k})^2$，$\\hat{\\rho}(\\mathbf{k})$ 是分配的电荷密度的离散傅里叶变换。\n- 通过势在每个方向上以间距 $h$ 的二阶中心有限差分来计算网格电场。使用相同的三次B样条权重将网格场插值回粒子位置。作用在粒子上的力为 $\\mathbf{F} = q \\mathbf{E}(\\mathbf{r})$。\n- 将 PME 力误差大小定义为 $\\varepsilon(\\alpha,M) = \\lVert \\mathbf{F} \\rVert_2$。\n\n请精确实现上述算法，并为以下参数值的测试套件计算 $\\varepsilon(\\alpha,M)$（所有位置均在单位立方体内的无量纲长度单位中）：\n1. $\\alpha = 2.5$, $M = 16$, $\\mathbf{r} = (0.234, 0.567, 0.789)$。\n2. $\\alpha = 3.5$, $M = 32$, $\\mathbf{r} = (0.234, 0.567, 0.789)$。\n3. $\\alpha = 1.0$, $M = 16$, $\\mathbf{r} = (0.234, 0.567, 0.789)$。\n4. $\\alpha = 4.5$, $M = 64$, $\\mathbf{r} = (0.234, 0.567, 0.789)$。\n5. $\\alpha = 2.5$, $M = 32$, $\\mathbf{r} = (0.5, 0.5, 0.5)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,\\dots,result_5]$）。每个 $result_i$ 必须是一个浮点数，等于相应测试用例的 $\\varepsilon(\\alpha,M)$，以无量纲力单位表示。不应打印任何其他文本。",
            "solution": "用户提供了一个有效且适定的问题陈述。该问题在科学上基于计算静电学的原理，特别是粒子网格埃瓦尔德 (PME) 方法，并为计算周期性系统中单个电荷的伪自作用力提供了一个清晰、独立且可形式化的算法。该问题是客观的，其参数对于计算是可行的。我将继续提供完整的解决方案。\n\n该问题要求计算单个电荷在周期性域中，通过粒子网格埃瓦尔德 (PME) 方法计算时所受到的伪自作用力。这个力是该方法固有的离散化（即使用有限网格进行电荷分配、势计算和场微分）所产生的 artifact。对于立方周期性盒子中的单个电荷，根据对称性，其自身周期性镜像产生的真实力为零。因此，PME 算法计算出的非零力直接衡量了该方法在一组给定参数（$\\alpha$, $M$）下的误差。\n\n计算遵循一个精确的步骤序列，我们将在下面详细说明。域是一个边长为 $L=1$ 的立方体，粒子电荷为 $q=1$。\n\n### 基于原理的设计\n\nPME 算法是一种混合空间方法，它将静电势的计算分为两部分：在实空间中计算的短程部分，以及在倒易（傅里叶）空间中计算的长程部分。此问题专门关注对力的倒易空间贡献，这主要是网格误差产生的地方。该算法可分解为以下步骤：\n\n**1. 电荷分配**\n\n第一步是将位于 $\\mathbf{r}$ 处的连续点粒子的电荷转移到大小为 $M \\times M \\times M$ 的离散网格上。这是一个插值过程。问题指定使用阶数为 $p=4$ 的三次B样条核。\n\n设网格间距为 $h = L/M$。粒子在缩放网格坐标中的位置为 $\\mathbf{s} = \\mathbf{r} / h$。我们找到基础网格索引 $\\mathbf{i} = \\lfloor \\mathbf{s} \\rfloor$ 和分数坐标 $\\mathbf{u} = \\mathbf{s} - \\mathbf{i}$，其中每个分量 $u_x, u_y, u_z$ 都在 $[0, 1)$ 内。\n\n电荷 $q$ 分布在粒子位置周围的 $p^3 = 4^3 = 64$ 个网格点的模板上。相对于基础索引 $\\mathbf{i}$，偏移量为 $(j_x, j_y, j_z)$（其中 $j_x, j_y, j_z \\in \\{0, 1, 2, 3\\}$）的网格点的权重是1D B样条权重的乘积：$W_{j_x,j_y,j_z} = w_{j_x}(u_x) w_{j_y}(u_y) w_{j_z}(u_z)$。对于 $j \\in \\{0,1,2,3\\}$ 的1D权重 $w_j(u)$ 如下：\n$$w_0(u) = \\frac{1}{6}(1-u)^3$$\n$$w_1(u) = \\frac{1}{6}(3u^3 - 6u^2 + 4)$$\n$$w_2(u) = \\frac{1}{6}(-3u^3 + 3u^2 + 3u + 1)$$\n$$w_3(u) = \\frac{1}{6}u^3$$\n索引为 $\\mathbf{n} = (\\mathbf{i} + \\mathbf{j}) \\pmod M$ 的网格节点上的电荷为 $\\rho_{mesh}(\\mathbf{n}) = q \\cdot W_{j_x,j_y,j_z}$。这创建了电荷密度的基于网格的表示，$\\rho_{mesh}$。\n\n**2. 倒易空间势计算**\n\n有了网格上的电荷密度后，我们使用快速傅里叶变换 (FFT) 移动到倒易空间来求解势。\n$$ \\hat{\\rho}(\\mathbf{k}) = \\text{FFT}(\\rho_{mesh}) $$\n这里，$\\mathbf{k}$ 是一个倒易晶格矢量，$\\mathbf{k} = (2\\pi m_x/L, 2\\pi m_y/L, 2\\pi m_z/L)$，其中 $m_x, m_y, m_z$ 是整数频率指数。\n\n在倒易空间中，泊松方程 $-\\nabla^2 \\phi = \\rho$ 变为 $\\lVert \\mathbf{k} \\rVert^2 \\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k})$。问题给出了PME势的长程部分的倒易空间格林函数，其中包含了埃瓦尔德屏蔽因子：\n$$ G(\\mathbf{k};\\alpha) = \\frac{4\\pi \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)}{\\lVert \\mathbf{k} \\rVert^2} \\quad (\\text{对于 } \\mathbf{k} \\neq \\mathbf{0}), \\quad G(\\mathbf{0};\\alpha) = 0 $$\n电荷分配和随后的力插值起着卷积的作用，这在傅里叶空间中对应于与B样条核的傅里叶变换相乘，记为 $S(\\mathbf{k})$。为了抵消这种平滑效应，通过对每个操作（分配和插值）除以 $S(\\mathbf{k})$ 来执行反卷积。问题指定除以 $S(\\mathbf{k})^2$。\n$$ S(\\mathbf{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\frac{\\sin(k_i h / 2)}{k_i h / 2} \\right]^p $$\n其中 $p=4$。当 $x \\to 0$ 时，sinc 函数 $(\\sin x / x)$ 的极限为 $1$。\n\n因此，网格上的倒易空间势计算如下：\n$$ \\hat{\\phi}_{mesh}(\\mathbf{k}) = H(\\mathbf{k};\\alpha) \\hat{\\rho}(\\mathbf{k}) = \\frac{G(\\mathbf{k};\\alpha)}{S(\\mathbf{k})^2} \\hat{\\rho}(\\mathbf{k}) $$\n\n**3. 实空间场计算**\n\n通过应用傅里叶逆变换 (IFFT) 获得实空间网格上的势 $\\phi_{mesh}$：\n$$ \\phi_{mesh} = \\text{IFFT}(\\hat{\\phi}_{mesh}(\\mathbf{k})) $$\n从网格化势中，使用二阶中心有限差分方案近似电场 $\\mathbf{E} = -\\nabla\\phi$。对于网格节点 $\\mathbf{n}=(n_x, n_y, n_z)$ 处的x分量：\n$$ E_x(\\mathbf{n}) = - \\frac{\\phi_{mesh}(n_x+1, n_y, n_z) - \\phi_{mesh}(n_x-1, n_y, n_z)}{2h} $$\n类似表达式适用于 $E_y$ 和 $E_z$。周期性边界条件应用于网格索引。\n\n**4. 力插值（收集）**\n\n最后一步是找到作用在粒子原始位置 $\\mathbf{r}$ 上的力。这是通过将电场从网格插值回粒子位置来完成的，这个过程通常称为“收集”。这里使用与电荷分配相同的B样条插值核。\n力 $\\mathbf{F} = (F_x, F_y, F_z)$ 由下式给出：\n$$ F_x = q \\sum_{j_x, j_y, j_z=0}^{p-1} w_{j_x}(u_x) w_{j_y}(u_y) w_{j_z}(u_z) E_x((\\mathbf{i} + \\mathbf{j}) \\pmod M) $$\n$F_y$ 和 $F_z$ 也是如此。\n\n**5. 伪力误差**\n\n得到的力矢量 $\\mathbf{F}$ 是伪自作用力。其大小计算为欧几里得范数：\n$$ \\varepsilon(\\alpha, M) = \\lVert \\mathbf{F} \\rVert_2 = \\sqrt{F_x^2 + F_y^2 + F_z^2} $$\n这个值量化了PME网格对单个粒子引入的系统误差。为每组给定的参数实施这个多步骤算法，可以精确确定这个误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to calculate and print the spurious PME force error for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (alpha, M, r_vec)\n        (2.5, 16, np.array([0.234, 0.567, 0.789])),\n        (3.5, 32, np.array([0.234, 0.567, 0.789])),\n        (1.0, 16, np.array([0.234, 0.567, 0.789])),\n        (4.5, 64, np.array([0.234, 0.567, 0.789])),\n        (2.5, 32, np.array([0.5, 0.5, 0.5])),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, M, r_vec = case\n        force_magnitude = compute_pme_force_error(alpha, M, r_vec)\n        results.append(force_magnitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\n\ndef get_bspline_weights(u):\n    \"\"\"\n    Computes the 1D cubic B-spline (p=4) weights for a fractional coordinate u in [0,1).\n    \"\"\"\n    w = np.zeros(4)\n    w[0] = (1.0 - u)**3 / 6.0\n    w[1] = (3.0 * u**3 - 6.0 * u**2 + 4.0) / 6.0\n    w[2] = (-3.0 * u**3 + 3.0 * u**2 + 3.0 * u + 1.0) / 6.0\n    w[3] = u**3 / 6.0\n    return w\n\ndef compute_pme_force_error(alpha, M, r_vec):\n    \"\"\"\n    Computes the spurious PME self-force for a single particle.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    q = 1.0\n    p = 4\n    h = L / M\n\n    # Step 1: Charge Assignment\n    rho_mesh = np.zeros((M, M, M), dtype=float)\n    s_vec = r_vec / h  # Scaled coordinates\n    i_vec = np.floor(s_vec).astype(int)\n    u_vec = s_vec - i_vec\n\n    weights_x = get_bspline_weights(u_vec[0])\n    weights_y = get_bspline_weights(u_vec[1])\n    weights_z = get_bspline_weights(u_vec[2])\n\n    for jx in range(p):\n        for jy in range(p):\n            for jz in range(p):\n                weight = weights_x[jx] * weights_y[jy] * weights_z[jz]\n                nx = (i_vec[0] + jx) % M\n                ny = (i_vec[1] + jy) % M\n                nz = (i_vec[2] + jz) % M\n                rho_mesh[nx, ny, nz] += q * weight\n\n    # Step 2: Forward FFT\n    rho_hat = np.fft.fftn(rho_mesh)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wavevectors k\n    m_vals = np.fft.fftfreq(M) * M\n    mx, my, mz = np.meshgrid(m_vals, m_vals, m_vals, indexing='ij')\n\n    kx = 2.0 * np.pi * mx / L\n    ky = 2.0 * np.pi * my / L\n    kz = 2.0 * np.pi * mz / L\n    k_sq = kx**2 + ky**2 + kz**2\n    \n    # Calculate G(k)\n    G_k = np.zeros((M, M, M), dtype=float)\n    non_zero_k = k_sq > 1e-12\n    G_k[non_zero_k] = 4.0 * np.pi * np.exp(-k_sq[non_zero_k] / (4.0 * alpha**2)) / k_sq[non_zero_k]\n\n    # Calculate S(k)\n    sinc_arg_x = kx * h / 2.0\n    sinc_arg_y = ky * h / 2.0\n    sinc_arg_z = kz * h / 2.0\n    \n    # Use np.sinc for sinc(x) = sin(pi*x)/(pi*x)\n    sx = np.sinc(sinc_arg_x / np.pi)**p\n    sy = np.sinc(sinc_arg_y / np.pi)**p\n    sz = np.sinc(sinc_arg_z / np.pi)**p\n    S_k_sq = (sx * sy * sz)**2\n    \n    # Avoid division by zero for S_k_sq, though it should be 1 at k=0\n    S_k_sq[S_k_sq  1e-12] = 1.0\n\n    H_k = G_k / S_k_sq\n    phi_hat = H_k * rho_hat\n\n    # Step 4: Inverse FFT for potential\n    phi_mesh = np.fft.ifftn(phi_hat).real\n\n    # Step 5: Finite Difference for Electric Field\n    Ex_mesh = -0.5 * (np.roll(phi_mesh, -1, axis=0) - np.roll(phi_mesh, 1, axis=0)) / h\n    Ey_mesh = -0.5 * (np.roll(phi_mesh, -1, axis=1) - np.roll(phi_mesh, 1, axis=1)) / h\n    Ez_mesh = -0.5 * (np.roll(phi_mesh, -1, axis=2) - np.roll(phi_mesh, 1, axis=2)) / h\n\n    # Step 6: Interpolate Field (Gathering)\n    Fx, Fy, Fz = 0.0, 0.0, 0.0\n    for jx in range(p):\n        for jy in range(p):\n            for jz in range(p):\n                weight = weights_x[jx] * weights_y[jy] * weights_z[jz]\n                nx = (i_vec[0] + jx) % M\n                ny = (i_vec[1] + jy) % M\n                nz = (i_vec[2] + jz) % M\n                Fx += weight * Ex_mesh[nx, ny, nz]\n                Fy += weight * Ey_mesh[nx, ny, nz]\n                Fz += weight * Ez_mesh[nx, ny, nz]\n    \n    force_vec = q * np.array([Fx, Fy, Fz])\n    \n    # Step 7: Compute Force Error Magnitude\n    force_magnitude = np.linalg.norm(force_vec)\n\n    return force_magnitude\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}