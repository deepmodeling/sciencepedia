{
    "hands_on_practices": [
        {
            "introduction": "这项练习将揭开速度Verlet算法的神秘面纱。我们将从哈密顿量的斯特朗分裂（Strang splitting）这一抽象概念出发，通过对简谐振子的逐步推导，展示它如何自然地导出我们所熟悉的速度Verlet更新方程。这个实践揭示了该算法与哈密顿力学几何结构之间的深刻联系。",
            "id": "3831013",
            "problem": "考虑一维谐振子，其哈密顿量为 $H(q,p)=\\frac{p^{2}}{2m}+\\frac{1}{2}m\\omega^{2}q^{2}$，其中 $m>0$ 且 $\\omega>0$。令 $T(p)=\\frac{p^{2}}{2m}$ 和 $V(q)=\\frac{1}{2}m\\omega^{2}q^{2}$ 分别表示动能和势能。从哈密顿方程和由 $T$ 和 $V$ 生成的精确流的定义出发，构造一个时间步长 $h>0$ 上的对称 Strang 分裂，\n$$\\Phi_{h}=\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right)\\circ\\exp\\!\\left(hL_{T}\\right)\\circ\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right),$$\n其中 $L_{T}$ 和 $L_{V}$ 是与 $T$ 和 $V$ 相关联的刘维尔算子。在变量 $(q,v)$ 中进行计算，其中 $v=p/m$。通过显式地复合精确子流，推导出将 $(q^{n},v^{n})$ 映到 $(q^{n+1},v^{n+1})$ 的线性单步映射，并将其表示为 $2\\times 2$ 矩阵 $A(h,\\omega)$，使得\n$$\\begin{pmatrix}q^{n+1}\\\\ v^{n+1}\\end{pmatrix}=A(h,\\omega)\\begin{pmatrix}q^{n}\\\\ v^{n}\\end{pmatrix}.$$\n通过直接比较复合的子步骤，得出结论：此更新与谐振子的标准速度 Verlet 方法一致，但在推导中不要引用该方法的任何现有公式。你的最终答案应该是闭式矩阵 $A(h,\\omega)$。",
            "solution": "该问题要求使用哈密顿流的对称 Strang 分裂方法，为一维谐振子推导其单步积分映射。最终结果必须表示为一个 $2 \\times 2$ 矩阵，并且推导过程必须证明该方法等价于速度 Verlet 算法。\n\n### 步骤 1：问题验证\n\n给出的问题陈述是：\n“考虑一维谐振子，其哈密顿量为 $H(q,p)=\\frac{p^{2}}{2m}+\\frac{1}{2}m\\omega^{2}q^{2}$，其中 $m>0$ 且 $\\omega>0$。令 $T(p)=\\frac{p^{2}}{2m}$ 和 $V(q)=\\frac{1}{2}m\\omega^{2}q^{2}$ 分别表示动能和势能。从哈密顿方程和由 $T$ 和 $V$ 生成的精确流的定义出发，构造一个时间步长 $h>0$ 上的对称 Strang 分裂，\n$$\\Phi_{h}=\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right)\\circ\\exp\\!\\left(hL_{T}\\right)\\circ\\exp\\!\\left(\\tfrac{h}{2}L_{V}\\right),$$\n其中 $L_{T}$ 和 $L_{V}$ 是与 $T$ 和 $V$ 相关联的刘维尔算子。在变量 $(q,v)$ 中进行计算，其中 $v=p/m$。通过显式地复合精确子流，推导出将 $(q^{n},v^{n})$ 映到 $(q^{n+1},v^{n+1})$ 的线性单步映射，并将其表示为 $2\\times 2$ 矩阵 $A(h,\\omega)$，使得\n$$\\begin{pmatrix}q^{n+1}\\\\ v^{n+1}\\end{pmatrix}=A(h,\\omega)\\begin{pmatrix}q^{n}\\\\ v^{n}\\end{pmatrix}.$$\n通过直接比较复合的子步骤，得出结论：此更新与谐振子的标准速度 Verlet 方法一致，但在推导中不要引用该方法的任何现有公式。你的最终答案应该是闭式矩阵 $A(h,\\omega)$。”\n\n该问题具有科学依据、是适定、客观且自洽的。它描述了计算物理和几何积分中的一个标准过程（Strang 分裂），并将其应用于一个基本模型系统（谐振子）。所有术语都得到了清晰的定义，任务是一个直接的形式推导。该问题是有效的。\n\n### 步骤 2：子流的推导\n\n我们给定的哈密顿量为 $H(q,p) = T(p) + V(q)$，其中 $T(p) = \\frac{p^2}{2m}$ 且 $V(q) = \\frac{1}{2}m\\omega^2q^2$。我们在相空间坐标 $(q,v)$ 中进行计算，其中 $v=p/m$。\n\n首先，我们求出与动能部分 $T$ 对应的精确流。其动力学由哈密顿量 $H_T = T(p)$ 的哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial T}{\\partial p} = \\frac{p}{m} = v $$\n$$ \\dot{p} = -\\frac{\\partial T}{\\partial q} = 0 $$\n由于 $v=p/m$，我们也有 $\\dot{v} = \\dot{p}/m = 0$。\n将这些方程在一个时间间隔 $\\Delta t$ 上从初始状态 $(q_0, v_0)$ 积分，得到：\n$v(\\Delta t) = v_0$\n$q(\\Delta t) = q_0 + \\int_0^{\\Delta t} v(t') dt' = q_0 + v_0 \\Delta t$。\n因此，流映射 $\\exp(\\Delta t L_T)$ 为：\n$$ \\exp(\\Delta t L_T) : (q_0, v_0) \\mapsto (q_0 + v_0 \\Delta t, v_0) $$\n\n接下来，我们求出势能部分 $V$ 的精确流。其动力学由哈密顿量 $H_V = V(q)$ 的哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial V}{\\partial p} = 0 $$\n$$ \\dot{p} = -\\frac{\\partial V}{\\partial q} = -m\\omega^2 q $$\n将这些方程在一个时间间隔 $\\Delta t$ 上从初始状态 $(q_0, p_0)$ 积分，得到：\n$q(\\Delta t) = q_0$\n$p(\\Delta t) = p_0 + \\int_0^{\\Delta t} (-m\\omega^2 q(t')) dt' = p_0 - m\\omega^2 q_0 \\Delta t$。\n用速度 $v=p/m$ 表示，更新为：\n$v(\\Delta t) = \\frac{p(\\Delta t)}{m} = \\frac{p_0 - m\\omega^2 q_0 \\Delta t}{m} = v_0 - \\omega^2 q_0 \\Delta t$。\n因此，流映射 $\\exp(\\Delta t L_V)$ 为：\n$$ \\exp(\\Delta t L_V) : (q_0, v_0) \\mapsto (q_0, v_0 - \\omega^2 q_0 \\Delta t) $$\n\n### 步骤 3：Strang 分裂的复合\n\nStrang 分裂积分器 $\\Phi_h$ 通过复合三个子步骤，将状态从时间 $t_n$ 的 $(q^n, v^n)$ 推进到时间 $t_{n+1} = t_n + h$ 的 $(q^{n+1}, v^{n+1})$：\n$$ \\Phi_h = \\exp\\left(\\frac{h}{2}L_V\\right) \\circ \\exp(h L_T) \\circ \\exp\\left(\\frac{h}{2}L_V\\right) $$\n我们将这些映射依次应用于初始状态 $(q^n, v^n)$。\n\n1.  **第一个半步（势能）：** 将 $\\exp\\left(\\frac{h}{2}L_V\\right)$ 应用于 $(q^n, v^n)$。\n    设中间状态为 $(q', v')$。使用 $L_V$ 的流，其中 $\\Delta t = h/2$：\n    $q' = q^n$\n    $v' = v^n - \\omega^2 q^n \\frac{h}{2}$\n    这一步使用从初始位置导出的力，在半个时间步长内更新速度。\n\n2.  **完整一步（动能）：** 将 $\\exp(h L_T)$ 应用于中间状态 $(q', v')$。\n    设新状态为 $(q'', v'')$。使用 $L_T$ 的流，其中 $\\Delta t = h$：\n    $q'' = q' + v' h$\n    $v'' = v'$\n    代入 $q'$ 和 $v'$ 的表达式：\n    $q'' = q^n + \\left(v^n - \\omega^2 q^n \\frac{h}{2}\\right) h = q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n$\n    $v'' = v^n - \\omega^2 q^n \\frac{h}{2}$\n    这一步使用半步速度 $v'$ 在一个完整时间步长内更新位置。\n\n3.  **第二个半步（势能）：** 将 $\\exp\\left(\\frac{h}{2}L_V\\right)$ 应用于 $(q'', v'')$。\n    最终状态为 $(q^{n+1}, v^{n+1})$。使用 $L_V$ 的流，其中 $\\Delta t = h/2$：\n    $q^{n+1} = q''$\n    $v^{n+1} = v'' - \\omega^2 q'' \\frac{h}{2}$\n    代入 $q''$ 和 $v''$ 的表达式：\n    $q^{n+1} = q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) q^n + h v^n$\n    $v^{n+1} = \\left(v^n - \\frac{\\omega^2 h}{2} q^n\\right) - \\omega^2 \\left(q^n + v^n h - \\frac{\\omega^2 h^2}{2} q^n\\right) \\frac{h}{2}$\n    简化 $v^{n+1}$ 的表达式：\n    $v^{n+1} = v^n - \\frac{\\omega^2 h}{2} q^n - \\frac{\\omega^2 h}{2} q^n - \\frac{\\omega^2 h^2}{2} v^n + \\frac{\\omega^4 h^3}{4} q^n$\n    $v^{n+1} = \\left(-\\omega^2 h + \\frac{\\omega^4 h^3}{4}\\right) q^n + \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) v^n$\n\n这一系列操作与速度 Verlet 算法完全对应。步骤 1 计算了半步速度 $v' = v^{n+1/2}$。步骤 2 使用该半步速度将位置更新为 $q^{n+1}$。步骤 3 使用新位置 $q^{n+1}$ 处的力，将速度从 $v^{n+1/2}$ 更新到其最终值 $v^{n+1}$。通过 Strang 分裂从第一性原理进行的推导，得出了速度 Verlet 方法，而未预先假设其形式。\n\n### 步骤 4：矩阵表示\n\n单步更新是一个从 $(q^n, v^n)$ 到 $(q^{n+1}, v^{n+1})$ 的线性映射：\n$$ q^{n+1} = \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right) q^n + h v^n $$\n$$ v^{n+1} = \\left(-\\omega^2 h + \\frac{1}{4}\\omega^4 h^3\\right) q^n + \\left(1 - \\frac{1}{2}\\omega^2 h^2\\right) v^n $$\n这可以写成矩阵形式：\n$$ \\begin{pmatrix} q^{n+1} \\\\ v^{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2  h \\\\ -\\omega^2 h + \\frac{1}{4}\\omega^4 h^3  1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} \\begin{pmatrix} q^n \\\\ v^n \\end{pmatrix} $$\n因此，矩阵 $A(h, \\omega)$ 是：\n$$ A(h, \\omega) = \\begin{pmatrix} 1 - \\frac{1}{2}\\omega^2 h^2  h \\\\ -\\omega^2 h + \\frac{1}{4}\\omega^4 h^3  1 - \\frac{1}{2}\\omega^2 h^2 \\end{pmatrix} $$\n我们可以对左下角元素进行因式分解，将其写为 $-\\omega^2 h \\left(1 - \\frac{1}{4}\\omega^2 h^2\\right)$。但这不会进一步简化最终表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 h^2  h \\\\\n-\\omega^2 h + \\frac{1}{4}\\omega^4 h^3  1 - \\frac{1}{2}\\omega^2 h^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Verlet方法通常以两种形式出现：位置Verlet和速度Verlet。这项练习通过要求你推导这两种形式，证明它们在生成位置轨迹上的等价性，并通过代码进行验证，从而将理论与实践联系起来。这将帮助你建立实现这些积分器和理解它们之间关系的信心。",
            "id": "3831017",
            "problem": "给定一个离散时间积分代码，该代码使用 Störmer–Verlet 方法的位置形式（通常称为位置 Verlet）来推进具有可分哈密顿量的系统的位置。您的任务是从第一性原理出发，系统地推导 Verlet 方法的速度形式（速度 Verlet），实现两种算法，并验证对于可分哈密顿量，两种方法产生的位置序列在浮点舍入误差范围内是相同的。\n\n从以下适用于多尺度力学系统的基础理论出发：\n- 牛顿第二定律：对于由索引 $i$ 标记的每个自由度，其位置为 $q_i(t)$，速度为 $v_i(t)$，质量为 $m_i  0$，有\n$$m_i \\frac{\\mathrm{d}^2 q_i}{\\mathrm{d} t^2} = F_i(q(t)),$$\n其中 $F_i(q) = -\\frac{\\partial V(q)}{\\partial q_i}$ 是从势能 $V(q)$ 推导出的保守力。\n- 可分哈密顿量：系统哈密顿量为\n$$H(q,p) = T(p) + V(q), \\quad T(p) = \\sum_i \\frac{p_i^2}{2 m_i},$$\n其中 $p_i = m_i v_i$。加速度完全由 $q$ 决定，通过\n$$a_i(q) = \\frac{\\mathrm{d} v_i}{\\mathrm{d} t} = \\frac{1}{m_i} F_i(q) = -\\frac{1}{m_i} \\frac{\\partial V(q)}{\\partial q_i}。$$\n- 运动学关系：速度是位置的时间导数，\n$$v_i(t) = \\frac{\\mathrm{d} q_i}{\\mathrm{d} t}。$$\n\n仅使用这些基本事实和标准的二阶精度时间离散化，您必须：\n1. 从加速度的二阶中心差分近似推导出位置 Verlet 使用的位置更新递推关系，展示它如何在一个均匀时间网格 $t_n = t_0 + n \\Delta t$（步长 $\\Delta t  0$）上推进位置 $q_n$。\n2. 构建一个具有相同形式精度的基于速度的更新方法，该方法使用 $q_n$ 和 $v_n$，并证明它对应于速度 Verlet 方法。更新的表达式应纯粹用上述基本理论所定义的量（来自势能的力、质量、位置和速度）来表示，不得借助任何未从基础理论推导出的外部公式。\n3. 证明如果初始条件一致匹配（具体来说，在位置 Verlet 方法中选择 $q_1$ 的方式与 $q_0$ 和 $v_0$ 一致），那么对于任何可分哈密顿量，只要使用相同的 $\\Delta t$ 和相同的力评估，位置 Verlet 和速度 Verlet 产生的位置序列 $\\{q_n\\}$ 对所有 $n$ 在舍入误差范围内都是相同的。您的证明必须通过递推关系和基本事实进行直接论证，而不援引任何外部定理。\n\n实现要求：\n- 所有变量都是无量纲的；不使用物理单位。\n- 实现两个积分器：\n  - 一个位置 Verlet 积分器，它使用中心差分递推来推进位置 $\\{q_n\\}$，并在 $t_0$ 时使用运动学关系来设置与 $q_0$ 和 $v_0$ 一致的 $q_1$。\n  - 一个速度 Verlet 积分器，它在相同的时间网格上推进 $(q_n, v_n)$。\n- 对于每个测试用例，模拟 $N$ 步，从位置 Verlet 和速度 Verlet 分别产生序列 $\\{q_n^{\\mathrm{pv}}\\}_{n=0}^N$ 和 $\\{q_n^{\\mathrm{vv}}\\}_{n=0}^N$。计算差异\n$$d = \\max_{0 \\le n \\le N} \\left\\| q_n^{\\mathrm{vv}} - q_n^{\\mathrm{pv}} \\right\\|_\\infty,$$\n和尺度\n$$Q = \\max_{0 \\le n \\le N} \\max\\left(1, \\left\\| q_n^{\\mathrm{vv}} \\right\\|_\\infty, \\left\\| q_n^{\\mathrm{pv}} \\right\\|_\\infty \\right)。$$\n使用双精度浮点数的机器精度，记为 $\\epsilon_{\\mathrm{mach}}$。对于每个测试，返回谓词的布尔值\n$$d \\le 100 \\, \\epsilon_{\\mathrm{mach}} \\, Q。$$\n- 您的程序不能要求任何输入，并且必须产生单行输出，将所有测试的结果聚合为一个用方括号括起来的逗号分隔列表（例如，“[true,false,true]”）。\n\n测试套件：\n实现以下五个可分哈密顿量测试用例。所有质量、位置、速度和参数都是无量纲的，且势能仅是位置的函数。\n- 测试 1（一维谐振子，理想路径）：一个自由度，质量 $m = 1$，势能 $V(q) = \\tfrac{1}{2} k q^2$，其中 $k = 1$。使用 $\\Delta t = 0.01$, $N = 2000$，初始条件 $q_0 = 1$, $v_0 = 0$。\n- 测试 2（自由粒子，零力边缘情况）：一个自由度，质量 $m = 0.75$，势能 $V(q) = 0$。使用 $\\Delta t = 0.05$, $N = 200$，初始条件 $q_0 = 1.234$, $v_0 = -0.5$。\n- 测试 3（二维刚柔谐振系统，多尺度覆盖）：两个自由度，质量 $(m_x, m_y) = (1, 1)$，势能 $V(q_x, q_y) = \\tfrac{1}{2} k_x q_x^2 + \\tfrac{1}{2} k_y q_y^2$，其中 $(k_x, k_y) = (1000, 1)$。使用 $\\Delta t = 0.001$, $N = 5000$，初始条件 $(q_{0,x}, q_{0,y}) = (1, 1)$, $(v_{0,x}, v_{0,y}) = (0, 0)$。\n- 测试 4（二维四次可分势，非线性覆盖）：两个自由度，质量 $(m_x, m_y) = (1.5, 0.8)$，势能 $V(q_x, q_y) = \\tfrac{1}{4} \\alpha_x q_x^4 + \\tfrac{1}{4} \\alpha_y q_y^4$，其中 $(\\alpha_x, \\alpha_y) = (3, 2)$。使用 $\\Delta t = 0.0005$, $N = 10000$，初始条件 $(q_{0,x}, q_{0,y}) = (0.1, -0.2)$, $(v_{0,x}, v_{0,y}) = (0.3, 0)$。\n- 测试 5（接近稳定性边界的一维谐振子，边界情况）：一个自由度，质量 $m = 1$，势能 $V(q) = \\tfrac{1}{2} k q^2$，其中 $k = 1$。使用 $\\Delta t = 1.9$, $N = 50$，初始条件 $q_0 = 0.5$, $v_0 = 1$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[true,true,true,true,true]”）。",
            "solution": "所提出的问题在科学上是合理的、自洽的且适定的。它要求推导、证明和实现两种基础的、二阶精度的数值积分方案，这些方案在分子动力学和计算科学的其他领域中被广泛使用。该问题基于经典力学和数值分析的基本原理。所有提供的数据、条件和测试用例都是一致的，并允许一个唯一且可验证的解。因此，我们可以着手解决。\n\n目标是对于具有可分哈密顿量的系统，从第一性原理推导位置 Verlet 和速度 Verlet 积分算法，然后证明并数值验证在一致的初始化下，它们生成的位置序列是相同的。\n\n提供的基本原理是：\n对于位置 $q_i(t)$、速度 $v_i(t)$ 和质量 $m_i  0$ 的牛顿第二定律：\n$$m_i \\frac{\\mathrm{d}^2 q_i}{\\mathrm{d} t^2} = F_i(q(t))$$\n力 $F_i(q)$ 是保守力，由势能 $V(q)$ 导出，使得 $F_i(q) = -\\frac{\\partial V(q)}{\\partial q_i}$。\n加速度 $a_i(q)$ 仅是位置的函数：\n$$a_i(q) = \\frac{1}{m_i} F_i(q) = -\\frac{1}{m_i} \\frac{\\partial V(q)}{\\partial q_i}$$\n运动学关系为 $v_i(t) = \\frac{\\mathrm{d} q_i}{\\mathrm{d} t}$。我们将使用矢量表示法，其中 $q(t)$ 是所有位置的矢量，$a(q)$ 是加速度的矢量。时间网格是均匀的，步长为 $\\Delta t$，其中 $t_n = t_0 + n \\Delta t$，我们记作 $q_n \\equiv q(t_n)$。\n\n**1. 位置 Verlet 算法的推导**\n\n位置 Verlet 算法，也称为 Störmer–Verlet 方法，源于对位置二阶时间导数的二阶精度有限差分近似。$q(t)$ 在时间 $t_n$ 的二阶导数的中心差分近似为：\n$$ \\frac{\\mathrm{d}^2 q}{\\mathrm{d}t^2}\\bigg|_{t=t_n} = \\frac{q(t_n + \\Delta t) - 2q(t_n) + q(t_n - \\Delta t)}{(\\Delta t)^2} + O((\\Delta t)^2) $$\n代入我们的记法 $q_n = q(t_n)$，这变为：\n$$ a(q_n) \\approx \\frac{q_{n+1} - 2q_n + q_{n-1}}{(\\Delta t)^2} $$\n其中 $a(q_n)$ 是时间 $t_n$ 的加速度。由于哈密顿量是可分的，加速度仅取决于位置 $q_n$。忽略 $O((\\Delta t)^2)$ 误差项并重新整理方程以求解未来位置 $q_{n+1}$，我们得到位置 Verlet 递推关系：\n$$ q_{n+1} = 2q_n - q_{n-1} + a(q_n) (\\Delta t)^2 $$\n这是一种两步法，因为它需要前两个时间步 $t_n$ 和 $t_{n-1}$ 的位置来计算下一个时间步 $t_{n+1}$ 的位置。它的主循环中没有显式地包含速度。\n\n**2. 速度 Verlet 算法的构建**\n\n我们寻求构建一个具有相同形式精度 $O((\\Delta t)^2)$ 的算法，该算法同时传播位置 $q_n$ 和速度 $v_n$。我们从位置 $q(t_{n+1})$ 在时间 $t_n$ 附近的泰勒级数展开开始：\n$$ q(t_{n+1}) = q(t_n) + \\frac{\\mathrm{d}q}{\\mathrm{d}t}\\bigg|_{t_n} \\Delta t + \\frac{1}{2} \\frac{\\mathrm{d}^2q}{\\mathrm{d}t^2}\\bigg|_{t_n} (\\Delta t)^2 + O((\\Delta t)^3) $$\n使用记法 $q_n$、$v_n = \\frac{\\mathrm{d}q}{\\mathrm{d}t}\\big|_{t_n}$ 和 $a(q_n) = \\frac{\\mathrm{d}^2q}{\\mathrm{d}t^2}\\big|_{t_n}$，我们通过截断级数得到位置更新规则：\n$$ q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a(q_n) (\\Delta t)^2 $$\n此更新在 $\\Delta t$ 上是二阶精度的。接下来，我们需要一个对速度 $v_{n+1}$ 的更新。一个简单的前向欧拉更新，$v_{n+1} = v_n + a(q_n) \\Delta t$，只有一阶精度。为了达到与位置更新一致的二阶精度，我们可以使用梯形法则来积分从 $t_n$ 到 $t_{n+1}$ 的加速度：\n$$ v_{n+1} = v_n + \\int_{t_n}^{t_{n+1}} a(q(t)) \\mathrm{d}t \\approx v_n + \\frac{\\Delta t}{2} [a(q(t_n)) + a(q(t_{n+1}))] $$\n这给出了速度更新规则：\n$$ v_{n+1} = v_n + \\frac{\\Delta t}{2} [a(q_n) + a(q_{n+1})] $$\n此更新是隐式二阶精度的。完整的速度 Verlet 算法由三个步骤组成，以从 $(q_n, v_n)$ 前进到 $(q_{n+1}, v_{n+1})$：\n1.  计算新位置：$q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a(q_n) (\\Delta t)^2$。\n2.  使用新计算的位置 $q_{n+1}$ 计算新加速度 $a(q_{n+1})$。\n3.  计算新速度：$v_{n+1} = v_n + \\frac{\\Delta t}{2} [a(q_n) + a(q_{n+1})]$。\n这是一种单步法，只需要时间 $t_n$ 的状态信息即可进行下一步。\n\n**3. 位置等价性证明**\n\n现在我们将通过归纳法证明，在精确算术和一致初始化的假设下，由位置 Verlet (PV) 和速度 Verlet (VV) 算法生成的位置序列 $\\{q_n\\}$ 是相同的。设 $\\{q_n^{\\mathrm{pv}}\\}$ 是来自位置 Verlet 的序列，$\\{(q_n^{\\mathrm{vv}}, v_n^{\\mathrm{vv}})\\}$ 是来自速度 Verlet 的序列。\n\n递推关系为：\n(PV) $q_{n+1}^{\\mathrm{pv}} = 2q_n^{\\mathrm{pv}} - q_{n-1}^{\\mathrm{pv}} + a(q_n^{\\mathrm{pv}}) (\\Delta t)^2$\n(VV-q) $q_{n+1}^{\\mathrm{vv}} = q_n^{\\mathrm{vv}} + v_n^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a(q_n^{\\mathrm{vv}}) (\\Delta t)^2$\n(VV-v) $v_{n+1}^{\\mathrm{vv}} = v_n^{\\mathrm{vv}} + \\frac{\\Delta t}{2} [a(q_n^{\\mathrm{vv}}) + a(q_{n+1}^{\\mathrm{vv}})]$\n\n**初始化（基础情况）：**\n系统从 $(q_0, v_0)$ 开始。我们设置 $q_0^{\\mathrm{pv}} = q_0^{\\mathrm{vv}} = q_0$。PV 算法需要两个初始位置，$q_0$ 和 $q_1$。我们必须一致地选择 $q_1^{\\mathrm{pv}}$。最一致的选择是使用与 VV 算法相同的第一步。对第一步（$n=0$）使用 (VV-q)：\n$$ q_1^{\\mathrm{vv}} = q_0^{\\mathrm{vv}} + v_0^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a(q_0^{\\mathrm{vv}}) (\\Delta t)^2 = q_0 + v_0 \\Delta t + \\frac{1}{2} a(q_0) (\\Delta t)^2 $$\n我们设置 $q_1^{\\mathrm{pv}} = q_1^{\\mathrm{vv}}$。因此，对于 $n=0$ 和 $n=1$，序列是相同的。\n\n**归纳假设：**\n假设对于所有满足 $0 \\le k \\le n$ 的整数 $k$，都有 $q_k^{\\mathrm{pv}} = q_k^{\\mathrm{vv}}$，其中 $n \\ge 1$。我们将这个共同位置记为 $q_k$。因此，$a(q_k^{\\mathrm{pv}}) = a(q_k^{\\mathrm{vv}})$，我们记为 $a_k$。\n\n**归纳步骤：**\n我们必须证明 $q_{n+1}^{\\mathrm{pv}} = q_{n+1}^{\\mathrm{vv}}$。\n从第 $n$ 步的 VV 位置更新，我们有：\n$$ q_{n+1}^{\\mathrm{vv}} = q_n + v_n^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2 \\quad (\\dagger)$$\n我们需要仅用位置来表示 $v_n^{\\mathrm{vv}} \\Delta t$ 这一项。从上一步（从 $n-1$ 到 $n$）的 VV 速度更新：\n$$ v_n^{\\mathrm{vv}} = v_{n-1}^{\\mathrm{vv}} + \\frac{\\Delta t}{2} [a_{n-1} + a_n] $$\n从上一步的 VV 位置更新：\n$$ q_n = q_{n-1} + v_{n-1}^{\\mathrm{vv}} \\Delta t + \\frac{1}{2} a_{n-1} (\\Delta t)^2 $$\n重新整理此式以解出 $v_{n-1}^{\\mathrm{vv}} \\Delta t$：\n$$ v_{n-1}^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 $$\n现在，将 $v_n^{\\mathrm{vv}}$ 的表达式乘以 $\\Delta t$：\n$$ v_n^{\\mathrm{vv}} \\Delta t = v_{n-1}^{\\mathrm{vv}} \\Delta t + \\frac{(\\Delta t)^2}{2} [a_{n-1} + a_n] $$\n代入 $v_{n-1}^{\\mathrm{vv}} \\Delta t$ 的表达式：\n$$ v_n^{\\mathrm{vv}} \\Delta t = \\left( q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 \\right) + \\frac{(\\Delta t)^2}{2} [a_{n-1} + a_n] $$\n$$ v_n^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} - \\frac{1}{2} a_{n-1} (\\Delta t)^2 + \\frac{1}{2} a_{n-1} (\\Delta t)^2 + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ v_n^{\\mathrm{vv}} \\Delta t = q_n - q_{n-1} + \\frac{1}{2} a_n (\\Delta t)^2 \\quad (\\ddagger) $$\n这个关于 $v_n^{\\mathrm{vv}} \\Delta t$ 的表达式是一个关键的中间结果，它代表了一个有限差分速度。现在，将 $(\\ddagger)$ 代回 $q_{n+1}^{\\mathrm{vv}}$ 的方程 $(\\dagger)$ 中：\n$$ q_{n+1}^{\\mathrm{vv}} = q_n + \\left( q_n - q_{n-1} + \\frac{1}{2} a_n (\\Delta t)^2 \\right) + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ q_{n+1}^{\\mathrm{vv}} = 2q_n - q_{n-1} + a_n (\\Delta t)^2 $$\n根据归纳假设，$q_n = q_n^{\\mathrm{pv}}$ 和 $q_{n-1} = q_{n-1}^{\\mathrm{pv}}$，所以我们可以写成：\n$$ q_{n+1}^{\\mathrm{vv}} = 2q_n^{\\mathrm{pv}} - q_{n-1}^{\\mathrm{pv}} + a(q_n^{\\mathrm{pv}}) (\\Delta t)^2 $$\n这正是递推关系 (PV)。因此，$q_{n+1}^{\\mathrm{vv}} = q_{n+1}^{\\mathrm{pv}}$。\n根据数学归纳法原理，在给定一致初始化的情况下，位置序列对于所有 $n \\ge 0$ 都是相同的。在数值计算中，这种同一性在浮点舍入误差的累积范围内成立。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # --- Acceleration Functions for Test Cases ---\n    \n    def accel_sho(q, m, params):\n        k = params['k']\n        return -k * q / m\n\n    def accel_free_particle(q, m, params):\n        # The acceleration is zero for a free particle (V=0).\n        # We need to return an array of the same shape as q.\n        return np.zeros_like(q)\n\n    def accel_stiff_soft(q, m, params):\n        k = params['k']\n        return -k * q / m\n        \n    def accel_quartic(q, m, params):\n        alpha = params['alpha']\n        return -alpha * q**3 / m\n\n    # --- Numerical Integrators ---\n\n    def position_verlet(accel_func, q0, v0, dt, N, m, params):\n        dim = q0.shape[0]\n        q_history = np.zeros((N + 1, dim))\n        q_history[0] = q0\n\n        # Consistent initialization for the first step\n        a0 = accel_func(q0, m, params)\n        q1 = q0 + v0 * dt + 0.5 * a0 * dt**2\n        q_history[1] = q1\n\n        for n in range(1, N):\n            q_n = q_history[n]\n            q_prev = q_history[n-1]\n            a_n = accel_func(q_n, m, params)\n            q_next = 2 * q_n - q_prev + a_n * dt**2\n            q_history[n+1] = q_next\n        \n        return q_history\n\n    def velocity_verlet(accel_func, q0, v0, dt, N, m, params):\n        dim = q0.shape[0]\n        q_history = np.zeros((N + 1, dim))\n        v_history = np.zeros((N + 1, dim))\n        \n        q_history[0] = q0\n        v_history[0] = v0\n\n        for n in range(N):\n            q_n = q_history[n]\n            v_n = v_history[n]\n            \n            a_n = accel_func(q_n, m, params)\n            \n            # Position update\n            q_next = q_n + v_n * dt + 0.5 * a_n * dt**2\n            \n            # New acceleration\n            a_next = accel_func(q_next, m, params)\n            \n            # Velocity update\n            v_next = v_n + 0.5 * (a_n + a_next) * dt\n            \n            q_history[n+1] = q_next\n            v_history[n+1] = v_next\n            \n        return q_history\n\n    # --- Test Suite ---\n\n    test_cases = [\n        # Test 1: 1D Harmonic Oscillator\n        {\n            \"name\": \"1D SHO\",\n            \"accel_func\": accel_sho,\n            \"q0\": np.array([1.0]),\n            \"v0\": np.array([0.0]),\n            \"dt\": 0.01,\n            \"N\": 2000,\n            \"m\": np.array([1.0]),\n            \"params\": {\"k\": np.array([1.0])}\n        },\n        # Test 2: 1D Free Particle\n        {\n            \"name\": \"1D Free Particle\",\n            \"accel_func\": accel_free_particle,\n            \"q0\": np.array([1.234]),\n            \"v0\": np.array([-0.5]),\n            \"dt\": 0.05,\n            \"N\": 200,\n            \"m\": np.array([0.75]),\n            \"params\": {}\n        },\n        # Test 3: 2D Stiff-Soft Harmonic System\n        {\n            \"name\": \"2D Stiff-Soft\",\n            \"accel_func\": accel_stiff_soft,\n            \"q0\": np.array([1.0, 1.0]),\n            \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.001,\n            \"N\": 5000,\n            \"m\": np.array([1.0, 1.0]),\n            \"params\": {\"k\": np.array([1000.0, 1.0])}\n        },\n        # Test 4: 2D Quartic Potential\n        {\n            \"name\": \"2D Quartic\",\n            \"accel_func\": accel_quartic,\n            \"q0\": np.array([0.1, -0.2]),\n            \"v0\": np.array([0.3, 0.0]),\n            \"dt\": 0.0005,\n            \"N\": 10000,\n            \"m\": np.array([1.5, 0.8]),\n            \"params\": {\"alpha\": np.array([3.0, 2.0])}\n        },\n        # Test 5: 1D SHO near stability boundary\n        {\n            \"name\": \"1D SHO Stability Boundary\",\n            \"accel_func\": accel_sho,\n            \"q0\": np.array([0.5]),\n            \"v0\": np.array([1.0]),\n            \"dt\": 1.9,\n            \"N\": 50,\n            \"m\": np.array([1.0]),\n            \"params\": {\"k\": np.array([1.0])}\n        }\n    ]\n\n    results = []\n    epsilon_mach = np.finfo(float).eps\n\n    for case in test_cases:\n        q_pv = position_verlet(\n            case[\"accel_func\"], case[\"q0\"], case[\"v0\"], case[\"dt\"], \n            case[\"N\"], case[\"m\"], case[\"params\"]\n        )\n        q_vv = velocity_verlet(\n            case[\"accel_func\"], case[\"q0\"], case[\"v0\"], case[\"dt\"], \n            case[\"N\"], case[\"m\"], case[\"params\"]\n        )\n\n        # Compute the discrepancy d\n        d = np.max(np.abs(q_vv - q_pv))\n        \n        # Compute the scale Q\n        max_q_vv = np.max(np.abs(q_vv))\n        max_q_pv = np.max(np.abs(q_pv))\n        Q = np.max([1.0, max_q_vv, max_q_pv])\n\n        # Test the predicate\n        is_equivalent = d = 100 * epsilon_mach * Q\n        results.append(str(is_equivalent).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "为什么我们选择速度Verlet算法，而不是像四阶龙格-库塔（RK4）这样通常被认为“更精确”的积分器？这个实践通过直接比较给出了答案。通过对保守系统进行长时间模拟，你将观察并量化辛Verlet方法优越的能量守恒特性，从而证明其在分子动力学和其他长期模拟中的关键优势。",
            "id": "3831042",
            "problem": "考虑一个保守力学系统，其广义坐标表示为 $x \\in \\mathbb{R}^d$，质量为 $m \\in \\mathbb{R}_{0}$，并拥有一个光滑的势能函数 $V:\\mathbb{R}^d \\to \\mathbb{R}$。该系统的动力学遵循牛顿第二定律 $m \\,\\ddot{x}(t) = -\\nabla V(x(t))$，并且在精确轨迹上哈密顿量 $H(x,v) = \\tfrac{1}{2} m \\lVert v \\rVert^2 + V(x)$ 是守恒的，其中 $v=\\dot{x}$。您将比较在相同时间步长下，速度 Verlet 算法和四阶经典 Runge–Kutta (RK4) 积分器对保守力学系统产生的数值能量行为。本问题中的所有量都是无量纲的，因此不使用物理单位。\n\n从上述基本定律和算法定义出发，实现这两种积分器，以在步长为 $\\Delta t$ 的均匀时间网格上对状态 $(x,v)$ 进行演化。对于每条轨迹，计算在时间 $t_n = n \\Delta t$（$n = 0,1,\\dots,N$）的能量时间序列 $E_n = \\tfrac{1}{2} m \\lVert v_n \\rVert^2 + V(x_n)$。定义能量误差为 $e_n = E_n - E_0$。对于每种积分器和每个测试，计算在整条轨迹 $\\{t_n\\}_{n=0}^N$ 上的以下能量统计量：\n\n- 线性漂移斜率 $s$，定义为 $e_n$ 相对于 $t_n$ 的最小二乘线性拟合的斜率系数。\n- 均方根误差 $r = \\sqrt{\\tfrac{1}{N+1} \\sum_{n=0}^N e_n^2}$。\n- 最大绝对误差 $M = \\max_{0 \\le n \\le N} |e_n|$。\n\n您的程序必须针对相同的 $\\Delta t$ 实现两种积分器，并为每个测试用例生成包含六个浮点数的列表 $[s_{\\mathrm{RK4}}, s_{\\mathrm{VV}}, r_{\\mathrm{RK4}}, r_{\\mathrm{VV}}, M_{\\mathrm{RK4}}, M_{\\mathrm{VV}}]$。\n\n使用以下包含三个测试的测试套件。每个测试都指定了 $d$、$V(x)$、$\\nabla V(x)$、$m$、初始条件 $(x_0,v_0)$、时间步长 $\\Delta t$ 和步数 $N$：\n\n- 测试 1 (非谐振子，理想路径): $d=1$，$V(x) = \\tfrac{1}{2} k x^2 + \\tfrac{1}{4} \\alpha x^4$，其中 $k = 1$，$\\alpha = 0.1$，$m = 1$，$(x_0,v_0) = (1,0)$，$\\Delta t = 0.1$，$N = 5000$。\n- 测试 2 (接近大步长稳定性边界的谐振子): $d=1$，$V(x) = \\tfrac{1}{2} k x^2$，其中 $k = 1$，$m = 1$，$(x_0,v_0) = (1,0)$，$\\Delta t = 1.9$，$N = 600$。\n- 测试 3 (双时间尺度解耦的刚柔振子): $d=2$，$V(x) = \\tfrac{1}{2} k_x x_1^2 + \\tfrac{1}{2} k_y x_2^2$，其中 $k_x = 1$，$k_y = 100$，$m = 1$，$(x_0,v_0) = ((1,0.1),(0,0))$，$\\Delta t = 0.02$，$N = 10000$。\n\n所有计算都应以无量纲形式进行。不使用角度。您的程序应生成单行输出，其中包含按测试顺序排列的结果，格式为无空格、逗号分隔的列表的列表。也就是说，最终输出必须是与以下格式完全一致的单行：\n$[[s_{\\mathrm{RK4}}^{(1)},s_{\\mathrm{VV}}^{(1)},r_{\\mathrm{RK4}}^{(1)},r_{\\mathrm{VV}}^{(1)},M_{\\mathrm{RK4}}^{(1)},M_{\\mathrm{VV}}^{(1)}],[s_{\\mathrm{RK4}}^{(2)},s_{\\mathrm{VV}}^{(2)},r_{\\mathrm{RK4}}^{(2)},r_{\\mathrm{VV}}^{(2)},M_{\\mathrm{RK4}}^{(2)},M_{\\mathrm{VV}}^{(2)}],[s_{\\mathrm{RK4}}^{(3)},s_{\\mathrm{VV}}^{(3)},r_{\\mathrm{RK4}}^{(3)},r_{\\mathrm{VV}}^{(3)},M_{\\mathrm{RK4}}^{(3)},M_{\\mathrm{VV}}^{(3)}]]$。\n\n基于第一性原理，解释在保守系统中观察到的两种积分器之间的任何差异为何出现。您的解释必须从牛顿第二定律和哈密顿系统的定义开始，并且不得在没有论证的情况下引用现成结果。您的推导必须避免为问题陈述中的目标能量统计量提供快捷公式。最终的程序必须是自包含的，并且不需要任何输入。答案是如上定义的浮点数，并且必须严格按照指定的单行输出格式显示。",
            "solution": "该问题要求对用于保守力学系统的速度 Verlet (VV) 和四阶 Runge-Kutta (RK4) 数值积分方案进行对比分析。分析的核心在于理解每种算法的结构如何与哈密顿动力学的底层几何特性相互作用。\n\n由运动方程 $m\\ddot{x} = -\\nabla V(x)$ 描述的保守力学系统是一个哈密顿系统。通过定义广义坐标 $x$ 和广义动量 $p = m\\dot{x} = mv$，其动力学可以从哈密顿函数 $H(x,p) = T(p) + V(x)$ 导出，其中 $T(p) = \\frac{1}{2m}\\lVert p \\rVert^2$ 是动能，$V(x)$ 是势能。其运动方程的哈密顿形式为：\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} = v\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\nabla V(x)\n$$\n这些一阶常微分方程 (ODEs) 在 $(x, p)$ 的 $2d$ 维相空间中定义了一个流。精确哈密顿流的一个基本性质是它是**辛的 (symplectic)**。如果一个从相空间到其自身的映射 $\\Phi$ 的雅可比矩阵 $J$ 保持标准的辛形式，即 $J^T \\Omega J = \\Omega$，那么该映射就是辛的，其中 $\\Omega = \\begin{pmatrix} 0  I_d \\\\ -I_d  0 \\end{pmatrix}$ 且 $I_d$ 是 $d \\times d$ 的单位矩阵。对于生成一个离散映射 $\\Phi_{\\Delta t}$ 以在时间步长 $\\Delta t$ 内近似真实流的数值积分器而言，这一性质至关重要。\n\n一个数值积分器是辛的，其直接而深刻的推论是它能精确地保守一个邻近的“影子”哈密顿量 $H_{\\Delta t}$。对于一个 k 阶方法，这个影子哈密顿量是原始哈密顿量的一个微扰，即 $H_{\\Delta t}(x,p) = H(x,p) + O(\\Delta t^k)$。因此，尽管数值轨迹不保持在原始哈密顿量 $H$ 的能量面上，但它被完美地限制在影子哈密顿量 $H_{\\Delta t}$ 的一个能量面上。这意味着沿数值轨迹计算的真实能量 $E_n = H(x_n, v_n)$ 会在其初始值附近表现出有界振荡，但不会表现出系统性的长期漂移。\n\n**速度 Verlet 积分器**\n速度 Verlet 算法由以下从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的更新步骤定义：\n\\begin{enumerate}\n    \\item 更新位置: $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a(x_n) (\\Delta t)^2$，其中 $a(x) = -\\frac{1}{m}\\nabla V(x)$。\n    \\item 计算新加速度: $a_{n+1} = a(x_{n+1})$。\n    \\item 更新速度: $v_{n+1} = v_n + \\frac{1}{2}(a_n + a_{n+1})\\Delta t$。\n\\end{enumerate}\n该积分器是**辛积分器**家族的一员。其辛性质可以通过将其视为几个更简单的、精确可解的哈密顿流的特定复合来理解。完整的哈密顿算子可以分解为 $\\mathcal{L}_H = \\mathcal{L}_T + \\mathcal{L}_V$，其中 $\\mathcal{L}_T$ 控制仅在动能作用下的运动（速度恒定，位置变化），而 $\\mathcal{L}_V$ 控制仅在势能作用下的运动（位置恒定，动量变化）。精确的流算子是 $e^{\\Delta t \\mathcal{L}_H}$。速度 Verlet 算法对应于此算子的一个二阶对称 Strang 分裂：\n$$\n\\Phi_{\\Delta t}^{\\text{VV}} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{L}_V} \\circ e^{\\Delta t \\mathcal{L}_T} \\circ e^{\\frac{\\Delta t}{2}\\mathcal{L}_V}\n$$\n复合中的每个算子都对应于哈密顿量一部分的精确流，因此是辛的。辛映射的复合也是辛的。由于速度 Verlet 算法是辛的，它具有出色的长期能量守恒性质。能量误差 $e_n = E_n - E_0$ 将对所有 $n$ 保持有界，表现为振荡。因此，对于任何稳定的时间步长，线性漂移斜率 $s_{\\mathrm{VV}}$ 预计将接近于零，仅受浮点精度的限制。\n\n**四阶经典 Runge-Kutta (RK4) 积分器**\nRK4 方法是一种用于形如 $\\dot{y} = f(t,y)$ 的常微分方程的通用显式积分器。对于我们的系统 $y=(x,v)$，有 $f(x,v) = (v, a(x))$。其更新规则为：\n$$\ny_{n+1} = y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中\n\\begin{align*}\nk_1 = f(x_n, v_n) \\\\\nk_2 = f(x_n + \\frac{\\Delta t}{2} k_{1x}, v_n + \\frac{\\Delta t}{2} k_{1v}) \\\\\nk_3 = f(x_n + \\frac{\\Delta t}{2} k_{2x}, v_n + \\frac{\\Delta t}{2} k_{2v}) \\\\\nk_4 = f(x_n + \\Delta t k_{3x}, v_n + \\Delta t k_{3v})\n\\end{align*}\nRK4 被设计为对广泛的函数 $f$ 都具有高精度，其局部截断误差为 $O(\\Delta t^5)$。然而，对于一般的哈密顿系统，它**不是**一个辛积分器。该方法不保持相空间的辛结构，因此不存在守恒的影子哈密顿量。这种数值方法引入了一种有效的耗散（或反耗散）形式，导致数值能量随时间系统性地漂移。尽管由于该方法的高阶性质，对于小的时间步长 $\\Delta t$ 来说，这种漂移可能非常小，但它是累积的。在长时间积分后，这种长期漂移会变得显著，并导致定性上不正确的物理行为。因此，我们预计线性漂移斜率 $s_{\\mathrm{RK4}}$ 会是一个很小但明显非零的值。\n\n**能量统计量的预期差异**\n- **线性漂移 ($s$)**: 我们预测，由于其能量误差的有界性，$s_{\\mathrm{VV}} \\approx 0$；而由于能量的长期漂移，$s_{\\mathrm{RK4}} \\neq 0$。\n- **均方根误差 ($r$) 和最大误差 ($M$)**: 对于小的时间步长 $\\Delta t$ 和短模拟时间，RK4 更高的精度阶数可能会导致其 $r$ 和 $M$ 小于二阶的 VV。然而，对于长时间模拟，RK4 能量的长期漂移最终会占主导地位，可能导致其 $r$ 和 $M$ 大于 VV。这些测试用例旨在探索这些行为，特别是在长时间积分（测试 1、测试 3）和边界附近稳定性（测试 2）的背景下。刚性系统（测试 3）进一步凸显了在存在许多快速振荡的长时程积分中，辛积分的结构性优势。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the integrator comparison for all test cases.\n    \"\"\"\n    \n    # Test 1: Anharmonic oscillator\n    def V1(x, k=1.0, alpha=0.1):\n        return 0.5 * k * x[0]**2 + 0.25 * alpha * x[0]**4\n    def gradV1(x, k=1.0, alpha=0.1):\n        return np.array([k * x[0] + alpha * x[0]**3])\n\n    # Test 2: Harmonic oscillator near stability boundary\n    def V2(x, k=1.0):\n        return 0.5 * k * x[0]**2\n    def gradV2(x, k=1.0):\n        return np.array([k * x[0]])\n\n    # Test 3: Stiff-soft decoupled oscillator\n    def V3(x, k_vec=np.array([1.0, 100.0])):\n        return 0.5 * np.sum(k_vec * x**2)\n    def gradV3(x, k_vec=np.array([1.0, 100.0])):\n        return k_vec * x\n\n    test_cases = [\n        {\n            \"d\": 1, \"m\": 1.0, \"V\": V1, \"gradV\": gradV1,\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 0.1, \"N\": 5000\n        },\n        {\n            \"d\": 1, \"m\": 1.0, \"V\": V2, \"gradV\": gradV2,\n            \"x0\": np.array([1.0]), \"v0\": np.array([0.0]),\n            \"dt\": 1.9, \"N\": 600\n        },\n        {\n            \"d\": 2, \"m\": 1.0, \"V\": V3, \"gradV\": gradV3,\n            \"x0\": np.array([1.0, 0.1]), \"v0\": np.array([0.0, 0.0]),\n            \"dt\": 0.02, \"N\": 10000\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        d, m, V, gradV, x0, v0, dt, N = case.values()\n\n        def accel(x):\n            return -gradV(x) / m\n\n        # Run Velocity Verlet\n        x_hist_vv, v_hist_vv = integrate_vv(x0, v0, dt, N, accel)\n        \n        # Run RK4\n        x_hist_rk4, v_hist_rk4 = integrate_rk4(x0, v0, dt, N, accel)\n\n        # Calculate statistics\n        results_vv = compute_energy_stats(x_hist_vv, v_hist_vv, dt, m, V)\n        results_rk4 = compute_energy_stats(x_hist_rk4, v_hist_rk4, dt, m, V)\n        \n        s_vv, r_vv, M_vv = results_vv\n        s_rk4, r_rk4, M_rk4 = results_rk4\n\n        all_results.append([s_rk4, s_vv, r_rk4, r_vv, M_rk4, M_vv])\n\n    # Format and print the final output as a single line\n    output_str = f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in all_results)}]\"\n    print(output_str)\n\ndef integrate_vv(x0, v0, dt, N, accel):\n    \"\"\"\n    Integrates the system using the Velocity Verlet algorithm.\n    \"\"\"\n    d = len(x0)\n    x_hist = np.zeros((N + 1, d))\n    v_hist = np.zeros((N + 1, d))\n    \n    x, v = np.copy(x0), np.copy(v0)\n    x_hist[0], v_hist[0] = x, v\n    \n    a = accel(x)\n    \n    for i in range(1, N + 1):\n        x_new = x + v * dt + 0.5 * a * dt**2\n        a_new = accel(x_new)\n        v_new = v + 0.5 * (a + a_new) * dt\n        \n        x, v, a = x_new, v_new, a_new\n        x_hist[i], v_hist[i] = x, v\n        \n    return x_hist, v_hist\n\ndef integrate_rk4(x0, v0, dt, N, accel):\n    \"\"\"\n    Integrates the system using the classical 4th-order Runge-Kutta method.\n    \"\"\"\n    d = len(x0)\n    x_hist = np.zeros((N + 1, d))\n    v_hist = np.zeros((N + 1, d))\n    \n    x, v = np.copy(x0), np.copy(v0)\n    x_hist[0], v_hist[0] = x, v\n    \n    for i in range(1, N + 1):\n        v1 = v\n        a1 = accel(x)\n        \n        v2 = v + 0.5 * dt * a1\n        a2 = accel(x + 0.5 * dt * v1)\n        \n        v3 = v + 0.5 * dt * a2\n        a3 = accel(x + 0.5 * dt * v2)\n        \n        v4 = v + dt * a3\n        a4 = accel(x + dt * v3)\n        \n        x_new = x + (dt / 6.0) * (v1 + 2*v2 + 2*v3 + v4)\n        v_new = v + (dt / 6.0) * (a1 + 2*a2 + 2*a3 + a4)\n        \n        x, v = x_new, v_new\n        x_hist[i], v_hist[i] = x, v\n        \n    return x_hist, v_hist\n\ndef compute_energy_stats(x_hist, v_hist, dt, m, V):\n    \"\"\"\n    Computes energy statistics (s, r, M) for a given trajectory.\n    \"\"\"\n    N = len(x_hist) - 1\n    \n    # Compute energy time series\n    KE = 0.5 * m * np.sum(v_hist**2, axis=1)\n    PE = np.array([V(x) for x in x_hist])\n    E = KE + PE\n    \n    # Compute energy error\n    E0 = E[0]\n    e_n = E - E0\n    \n    # Compute statistics\n    # 1. Linear drift slope (s)\n    t_n = np.arange(N + 1) * dt\n    lin_reg_result = linregress(t_n, e_n)\n    s = lin_reg_result.slope\n    \n    # 2. Root-mean-square error (r)\n    r = np.sqrt(np.mean(e_n**2))\n    \n    # 3. Maximum absolute error (M)\n    M = np.max(np.abs(e_n))\n    \n    return s, r, M\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}