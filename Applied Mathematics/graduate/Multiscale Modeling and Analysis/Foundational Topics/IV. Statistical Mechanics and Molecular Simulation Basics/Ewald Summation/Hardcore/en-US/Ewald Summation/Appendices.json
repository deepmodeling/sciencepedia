{
    "hands_on_practices": [
        {
            "introduction": "Before diving into the complexities of the Ewald method, it is crucial to understand why it is necessary. This first practice demonstrates the problem that Ewald summation is designed to solve: the failure of simple truncation schemes for long-range interactions in periodic systems . By directly comparing the energy calculated with a naive potential cutoff to the correct energy from an Ewald sum, you will gain a tangible appreciation for the conditional convergence of the lattice sum and the significant errors introduced by improper handling of periodic electrostatics.",
            "id": "2391007",
            "problem": "You must write a complete, runnable program that, for a small set of explicitly specified periodic charge configurations, quantifies the discrepancy between a naive spherical cutoff of the Coulomb potential and the fully periodic energy obtained by Ewald summation. All systems are three-dimensional, use cubic periodic boundary conditions (PBC), and are electrically neutral.\n\nUse reduced electrostatic units where the Coulomb constant is set to unity, that is, the energy unit is defined so that the pairwise Coulomb interaction between two charges of magnitude $1$ at separation $r$ is $1/r$. All energies must be expressed in these reduced energy units as floating-point numbers.\n\nDefinitions to be used by your program:\n\n- The cubic simulation cell has side length $L$ and volume $V = L^3$.\n- There are $N$ point charges with values $q_i$ located at positions $\\mathbf{r}_i$ with $i \\in \\{1,\\dots,N\\}$ inside the primary cell.\n- The naive cutoff energy uses the minimum-image convention with a spherical cutoff $r_c = L/2$ and includes only the pairwise interactions $q_i q_j / r_{ij}$ for $ij$ with $r_{ij}r_c$, where $r_{ij}$ is the minimum-image distance between $\\mathbf{r}_i$ and $\\mathbf{r}_j$. Ignore all self-terms and any contributions from images outside the primary cell.\n- The Ewald summation energy corresponds to the three-dimensional Ewald decomposition of the infinite periodic Coulomb sum under fully periodic (tin-foil) boundary conditions. Use the following fixed numerical parameters for all cases:\n  - Splitting parameter $\\alpha = 5/L$.\n  - Real-space sum: include all lattice vectors $\\mathbf{n}=(n_x,n_y,n_z)$ with integer components $n_x,n_y,n_z \\in \\{-5,-4,\\dots,4,5\\}$, but retain only those terms whose real-space separation satisfies $\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert  r_{\\mathrm{real}}$, with $r_{\\mathrm{real}} = L/2$. Exclude the singular term with $i=j$ and $\\mathbf{n}=\\mathbf{0}$.\n  - Reciprocal-space sum: include all nonzero reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ with integer triplets $\\mathbf{m}=(m_x,m_y,m_z)$ where $m_x,m_y,m_z \\in \\{-6,-5,\\dots,5,6\\}$ and $\\mathbf{m}\\neq \\mathbf{0}$.\n  - Self-energy correction: subtract $\\alpha/\\sqrt{\\pi}\\,\\sum_{i=1}^N q_i^2$.\n  - Do not include any additional surface or dipole corrections beyond the tin-foil limit.\n- Your program must compute, for each test case, the absolute error $\\Delta E = \\lvert E_{\\mathrm{cut}} - E_{\\mathrm{Ewald}} \\rvert$.\n\nTest suite to be implemented exactly as follows. Each case is a separate computation:\n\n- Case A (happy path, moderate box): $L=10.0$, $N=2$, charges $[+1,-1]$, positions $\\mathbf{r}_1=(1.0,1.0,1.0)$, $\\mathbf{r}_2=(5.9,1.0,1.0)$.\n- Case B (edge case, smaller box, stronger periodic effects): $L=8.0$, $N=2$, charges $[+1,-1]$, positions $\\mathbfr_1=(1.0,1.0,1.0)$, $\\mathbf{r}_2=(4.8,1.0,1.0)$.\n- Case C (symmetry and cancellation test, four-charge neutral cluster): $L=6.0$, $N=4$, charges $[+1,+1,-1,-1]$, positions $\\mathbf{r}_1=(1.0,1.0,1.0)$, $\\mathbf{r}_2=(4.0,1.0,1.0)$, $\\mathbf{r}_3=(1.0,4.0,1.0)$, $\\mathbf{r}_4=(4.0,4.0,1.0)$.\n\nFinal output format requirement:\n\n- Your program must produce a single line containing a list with the three absolute errors for Cases A, B, and C, in that order, formatted as a comma-separated list enclosed in square brackets, for example, $[\\Delta E_A,\\Delta E_B,\\Delta E_C]$.",
            "solution": "The problem requires a quantitative comparison between two methods for computing the electrostatic potential energy of a periodic system of point charges: a naive summation truncated at a spherical cutoff radius and the rigorous Ewald summation technique. The discrepancy, defined as the absolute difference in the calculated energies, $\\Delta E = |E_{\\mathrm{cut}} - E_{\\mathrm{Ewald}}|$, will be computed for three specified configurations. All calculations will be performed in reduced electrostatic units where the Coulomb constant is $1$.\n\nFirst, we define the energy based on a naive real-space cutoff, $E_{\\mathrm{cut}}$. In a system with periodic boundary conditions (PBC) in a cubic cell of side length $L$, the interaction between two particles $i$ and $j$ is calculated using their minimum-image distance. The minimum-image displacement vector $\\Delta\\mathbf{r}_{ij}$ between particles at positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ is given by applying the nearest image convention to each component $\\Delta r_{\\alpha}$ of the vector $\\mathbf{r}_i - \\mathbf{r}_j$:\n$$\n\\Delta r_{\\alpha, \\text{mic}} = \\Delta r_{\\alpha} - L \\cdot \\text{round}\\left(\\frac{\\Delta r_{\\alpha}}{L}\\right)\n$$\nThe minimum-image distance is then $r_{ij} = \\lVert \\Delta\\mathbf{r}_{ij, \\text{mic}} \\rVert$. The cutoff energy $E_{\\mathrm{cut}}$ is the sum over all unique pairs of particles whose minimum-image distance is less than a specified cutoff radius $r_c$. The problem defines $r_c = L/2$. The energy is thus:\n$$\nE_{\\mathrm{cut}} = \\sum_{1 \\le i  j \\le N} \\frac{q_i q_j}{r_{ij}} \\quad \\text{for } r_{ij}  r_c\n$$\nThis method is computationally simple but physically incorrect for long-range interactions like the Coulomb potential, as it omits interactions beyond the cutoff and improperly truncates interactions at the cutoff boundary, violating the periodicity of the potential.\n\nNext, we define the energy using the Ewald summation method, $E_{\\mathrm{Ewald}}$. This is the correct approach for calculating electrostatic energies in periodic systems under tin-foil (conducting) boundary conditions. The method splits the slowly converging sum $\\sum_{\\mathbf{n}} \\frac{1}{|\\mathbf{r}+\\mathbf{n}L|}$ into two rapidly converging series: one in real space and one in reciprocal space. This is achieved by adding and subtracting a Gaussian charge distribution of opposite sign centered on each point charge. The total potential energy is the sum of three terms: the real-space energy $E_{\\text{real}}$, the reciprocal-space energy $E_{\\text{recip}}$, and a self-energy correction $E_{\\text{self}}$.\n\n$E_{\\mathrm{Ewald}} = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}}$\n\nThe real-space component accounts for the short-range interactions, screened by the complementary Gaussian distributions. Its form is:\n$$\nE_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}{'} q_i q_j \\frac{\\text{erfc}(\\alpha |\\mathbf{r}_{ij} + \\mathbf{n}L|)}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\nHere, $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, $\\mathbf{n}$ is a lattice vector of integer components, $\\alpha$ is the splitting parameter that controls the convergence of the two sums, and $\\text{erfc}$ is the complementary error function. The prime on the summation indicates that the term for $i=j$ is excluded when $\\mathbf{n}=\\mathbf{0}$. The problem specifies a finite sum over lattice vectors where components $n_x, n_y, n_z$ are in the set $\\{-5, \\dots, 5\\}$, and an additional cutoff condition where only terms satisfying $|\\mathbf{r}_{ij} + \\mathbf{n}L|  r_{\\mathrm{real}} = L/2$ are included. The splitting parameter is fixed at $\\alpha = 5/L$.\n\nThe reciprocal-space component accounts for the long-range part of the interaction. It is a sum over the reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$, where $\\mathbf{m}$ is a vector of integer components. Its form is:\n$$\nE_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} |S(\\mathbf{k})|^2\n$$\nwhere $V=L^3$ is the cell volume, $k = |\\mathbf{k}|$, and $S(\\mathbf{k})$ is the structure factor, defined as:\n$$\nS(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\nThe sum is over all nonzero reciprocal lattice vectors defined by integer triplets $\\mathbf{m}=(m_x, m_y, m_z)$ with components in the set $\\{-6, \\dots, 6\\}$. The neutrality of the systems, $\\sum_j q_j = 0$, ensures that $S(\\mathbf{k}=0)=0$, correctly handling the singularity at $\\mathbf{k}=\\mathbf{0}$.\n\nThe self-energy term, $E_{\\text{self}}$, subtracts the artifactual interaction of each Gaussian charge cloud with the point charge it is centered on. It is given by:\n$$\nE_{\\text{self}} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2\n$$\nThis term is necessary to correct for adding the Gaussian screening charges.\n\nThe implementation will proceed by constructing functions for each energy calculation, $E_{\\mathrm{cut}}$ and $E_{\\mathrm{Ewald}}$, according to these precise definitions and the specified numerical parameters. The absolute difference $\\Delta E$ is then computed for each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef calculate_E_cut(charges, positions, L):\n    \"\"\"\n    Calculates the naive cutoff energy using the minimum-image convention.\n    \"\"\"\n    N = len(charges)\n    rc = L / 2.0\n    energy = 0.0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            rij_vec = positions[i] - positions[j]\n            # Apply minimum image convention\n            rij_vec_mic = rij_vec - L * np.round(rij_vec / L)\n            rij = np.linalg.norm(rij_vec_mic)\n\n            if rij  rc:\n                energy += charges[i] * charges[j] / rij\n    \n    return energy\n\ndef calculate_E_ewald(charges, positions, L):\n    \"\"\"\n    Calculates the Ewald summation energy with specified parameters.\n    \"\"\"\n    N = len(charges)\n    V = L**3\n    alpha = 5.0 / L\n    \n    # 1. Real-space energy\n    E_real = 0.0\n    r_real_cut = L / 2.0\n    n_range = np.arange(-5, 6)\n    \n    n_vectors = []\n    for nx in n_range:\n        for ny in n_range:\n            for nz in n_range:\n                n_vectors.append(np.array([nx, ny, nz]))\n    \n    for i in range(N):\n        for j in range(N):\n            rij_vec = positions[i] - positions[j]\n            for n_vec in n_vectors:\n                if i == j and np.all(n_vec == 0):\n                    continue\n                \n                dist_vec = rij_vec + n_vec * L\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist  r_real_cut:\n                    E_real += charges[i] * charges[j] * erfc(alpha * dist) / dist\n    \n    E_real *= 0.5\n\n    # 2. Reciprocal-space energy\n    E_recip = 0.0\n    m_range = np.arange(-6, 7)\n    \n    m_vectors = []\n    for mx in m_range:\n        for my in m_range:\n            for mz in m_range:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m_vectors.append(np.array([mx, my, mz]))\n    \n    for m_vec in m_vectors:\n        k_vec = (2.0 * np.pi / L) * m_vec\n        k_sq = np.dot(k_vec, k_vec)\n        \n        # Calculate structure factor S(k)\n        # S(k) = sum_j q_j * exp(-i * k.r_j)\n        # |S(k)|^2 = (Re(S))^2 + (Im(S))^2\n        # Re(S) = sum_j q_j * cos(k.r_j)\n        # Im(S) = -sum_j q_j * sin(k.r_j)\n        \n        S_k_real = 0.0\n        S_k_imag = 0.0\n        for j in range(N):\n            k_dot_rj = np.dot(k_vec, positions[j])\n            S_k_real += charges[j] * np.cos(k_dot_rj)\n            S_k_imag += charges[j] * np.sin(k_dot_rj)\n        \n        # Note: sin part corresponds to -Im(S), so |S|^2 = S_k_real^2 + S_k_imag^2\n        S_k_sq = S_k_real**2 + S_k_imag**2\n        \n        E_recip += (1.0 / k_sq) * np.exp(-k_sq / (4.0 * alpha**2)) * S_k_sq\n    \n    E_recip *= (2.0 * np.pi / V)\n\n    # 3. Self-energy correction\n    q_sq_sum = np.sum(np.square(charges))\n    E_self = -(alpha / np.sqrt(np.pi)) * q_sq_sum\n    \n    return E_real + E_recip + E_self\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case A: L=10.0, N=2, q=[+1,-1], r1=(1,1,1), r2=(5.9,1,1)\n        {\n            \"L\": 10.0,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [5.9, 1.0, 1.0]])\n        },\n        # Case B: L=8.0, N=2, q=[+1,-1], r1=(1,1,1), r2=(4.8,1,1)\n        {\n            \"L\": 8.0,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [4.8, 1.0, 1.0]])\n        },\n        # Case C: L=6.0, N=4, q=[+1,+1,-1,-1], r1=(1,1,1), r2=(4,1,1), r3=(1,4,1), r4=(4,4,1)\n        {\n            \"L\": 6.0,\n            \"charges\": np.array([1.0, 1.0, -1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [4.0, 1.0, 1.0], [1.0, 4.0, 1.0], [4.0, 4.0, 1.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        charges = case[\"charges\"]\n        positions = case[\"positions\"]\n\n        E_cut = calculate_E_cut(charges, positions, L)\n        E_ewald = calculate_E_ewald(charges, positions, L)\n        \n        delta_E = np.abs(E_cut - E_ewald)\n        results.append(delta_E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once an Ewald summation is implemented, a critical step is to verify its correctness. A key feature of the method is that the total energy must be independent of the Ewald splitting parameter $\\alpha$, which is a purely mathematical construct used to partition the calculation. This exercise guides you through a fundamental validation test: demonstrating this $\\alpha$-independence numerically . By showing that the energy remains constant for different values of $\\alpha$ while adjusting cutoffs to maintain a consistent error budget, you will build confidence in your implementation and deepen your understanding of the roles of the real and reciprocal space sums.",
            "id": "3756016",
            "problem": "You are tasked with designing and implementing a numerical validation test for the Ewald summation in a three-dimensional cubic periodic system, focusing on demonstrating the independence of the total electrostatic energy from the Ewald splitting parameter. The Ewald summation is used to compute the pairwise Coulomb energy of a collection of point charges under Periodic Boundary Conditions (PBC), by splitting the computation into a short-range real-space sum and a long-range reciprocal-space sum. Your validation must compare total Ewald energies as the Gaussian screening parameter $\\alpha$ varies, under the constraint that truncation errors in the real-space and reciprocal-space sums are kept approximately constant across different $\\alpha$ values.\n\nStart from the following base: the electrostatic energy of $N$ point charges $\\{q_i\\}$ at positions $\\{\\mathbf{r}_i\\}$ interacting via the Coulomb potential in a periodically replicated cubic cell of side length $L$ is conditionally convergent and must be regularized. The Ewald method achieves this by introducing a Gaussian screening that yields two complementary sums (real-space and reciprocal-space), plus a self-energy correction. Under conducting boundary conditions (tin-foil boundary), there is no shape-dependent surface term. It is a widely accepted fact that for Gaussian screening, the truncation tails of the real-space and reciprocal-space sums are exponentially small and can be controlled by choosing consistent cutoffs. In reduced units, set $4\\pi\\varepsilon_0 = 1$ so that energies are dimensionless.\n\nDesign a program that:\n1. Implements the total Ewald energy per simulation cell for neutral charge configurations (i.e., $\\sum_i q_i = 0$), using a three-dimensional cubic cell of side length $L$, with PBC and conducting boundary conditions. The implementation must consist of:\n   - A real-space sum over pairwise images $\\mathbf{r}_{ij} + \\mathbf{n}L$ truncated at a real-space radius $r_c$, where $\\mathbf{n}\\in\\mathbb{Z}^3$, $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$, and $\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert \\le r_c$.\n   - A reciprocal-space sum over wavevectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ with $\\mathbf{m}\\in\\mathbb{Z}^3$, truncated at $\\lVert \\mathbf{k} \\rVert \\le k_{\\max}$, and excluding $\\mathbf{k}=\\mathbf{0}$.\n   - A self-energy correction for the Gaussian screening.\n2. Ensures a consistent tail error across different $\\alpha$ by choosing cutoffs $r_c$ and $k_{\\max}$ from a single dimensionless parameter $s  0$ according to the following error-control design choice grounded in the asymptotics of the complementary error function and Gaussian damping:\n   - Maintain $\\alpha r_c = s$ and $\\frac{k_{\\max}}{2\\alpha} = s$ for each $\\alpha$ tested. This keeps the exponential damping factors $\\operatorname{erfc}(\\alpha r)$ and $\\exp(-\\lVert \\mathbf{k} \\rVert^2/(4\\alpha^2))$ at comparable magnitudes $\\exp(-s^2)$ near the truncation boundaries, which yields a nearly constant truncation error budget across $\\alpha$.\n3. Validates $\\alpha$-independence by computing the total energy for several $\\alpha$ values while using the above cutoffs with fixed $s$, and then reporting the spread of the energy values within each test system as the maximum minus minimum energy.\n\nUse the following test suite with dimensionless quantities (lengths in the same units as $L$, energies dimensionless):\n- System parameters are identical across tests except for $\\alpha$. Use a cubic cell of side $L = 10$.\n- Use $s = 2.0$ for all tests. This corresponds to an approximate truncation tail scale of $\\exp(-s^2) = \\exp(-4)$, providing a consistent error budget across $\\alpha$.\n- Test Set $\\mathcal{A}$ (happy path): six charges with neutrality,\n  charges $\\mathbf{q} = [1.0, -1.0, 0.5, -0.5, 0.75, -0.75]$,\n  positions $\\mathbf{r} = [[1.0, 2.5, 3.3], [4.0, 5.5, 6.1], [7.2, 1.1, 8.8], [2.4, 8.7, 0.9], [9.5, 3.3, 2.2], [0.2, 7.7, 5.5]]$.\n- Test Set $\\mathcal{B}$ (symmetry edge case): two opposite charges,\n  charges $\\mathbf{q} = [1.0, -1.0]$,\n  positions $\\mathbf{r} = [[2.0, 2.0, 2.0], [8.0, 8.0, 8.0]]$.\n- Test Set $\\mathcal{C}$ (near-field dipoles): four charges forming two dipoles,\n  charges $\\mathbf{q} = [1.0, -1.0, 1.0, -1.0]$,\n  positions $\\mathbf{r} = [[1.0, 1.0, 1.0], [1.8, 1.0, 1.0], [7.0, 7.0, 7.0], [7.9, 7.0, 7.0]]$.\n- For each test set, evaluate energies at $\\alpha \\in \\{0.25, 0.6, 1.2\\}$ with $r_c = s/\\alpha$ and $k_{\\max} = 2\\alpha s$.\n\nYour program must produce a single line of output consisting of the energy spreads for the three test sets, in the format $[x_1, x_2, x_3]$, where each $x_i$ is a floating-point number equal to the maximum minus minimum of the energies across the three $\\alpha$ values for the corresponding test set. Energies and spreads are dimensionless and must be computed in reduced units with $4\\pi\\varepsilon_0 = 1$. The final print must produce only that line, with no additional text. Angle units do not apply. Percentages do not apply. The output type is a list of floats.\n\nYour implementation must be complete and self-contained, using any modern programming language. In the final answer, provide executable Python code adhering to the specified runtime environment. The code must not require any user input or external resources.",
            "solution": "The user-provided problem statement has been analyzed and is deemed valid. It is a scientifically grounded, well-posed, and objective problem in the field of computational physics. It requests the implementation and validation of the Ewald summation method, a standard and fundamental algorithm for computing electrostatic energies in periodic systems. All parameters, physical conditions, and test cases are specified unambiguously.\n\nThe solution proceeds as follows. First, the theoretical foundation of the Ewald summation method is established, detailing the mathematical expressions for the total electrostatic energy. Second, the algorithmic implementation based on these expressions is described, including the specific cutoff scheme designed to ensure consistent accuracy across different summation parameters.\n\nThe total electrostatic energy $E$ of a periodic system of $N$ point charges $\\{q_i\\}$ at positions $\\{\\mathbf{r}_i\\}$ in a cubic cell of side length $L$, under conducting boundary conditions and overall charge neutrality ($\\sum_i q_i = 0$), is calculated using the Ewald method. This method splits the conditionally convergent Coulomb sum into three absolutely convergent terms: a real-space sum ($E_{real}$), a reciprocal-space sum ($E_{recip}$), and a self-energy correction ($E_{self}$). In reduced units where the Coulomb constant $1/(4\\pi\\varepsilon_0)$ is unity, the total energy is $E = E_{real} + E_{recip} + E_{self}$.\n\nThe splitting is achieved by adding and subtracting a set of screening Gaussian charge distributions centered on each point charge. The parameter $\\alpha$ controls the width of these Gaussians: a larger $\\alpha$ corresponds to a narrower, more localized Gaussian.\n\n1.  **Real-Space Energy ($E_{real}$)**: This term accounts for the short-range interactions. It is the sum of interactions between charge pairs, screened by the complementary error function, $\\mathrm{erfc}(x)$. The sum is performed over all charge pairs $(i, j)$ and all periodic lattice vectors $\\mathbf{n}L$, where $\\mathbf{n} \\in \\mathbb{Z}^3$. The term for a charge interacting with itself in the primary cell ($\\mathbf{n}=\\mathbf{0}$, $i=j$) is excluded. The sum is truncated at a cutoff radius $r_c$.\n    $$\n    E_{real} = \\frac{1}{2} \\sideset{}{'}\\sum_{i,j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3, \\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert \\le r_c} q_i q_j \\frac{\\mathrm{erfc}(\\alpha \\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert)}{\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert}\n    $$\n    where $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, and the prime on the sum indicates the exclusion of the $(i=j, \\mathbf{n}=\\mathbf{0})$ term.\n\n2.  **Reciprocal-Space Energy ($E_{recip}$)**: This term accounts for the long-range interactions. It is a sum over reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ for $\\mathbf{m} \\in \\mathbb{Z}^3$. The $\\mathbf{k}=\\mathbf{0}$ term is excluded due to overall charge neutrality. The sum is truncated at a cutoff magnitude $k_{\\max}$.\n    $$\n    E_{recip} = \\frac{2\\pi}{L^3} \\sum_{\\mathbf{k} \\neq \\mathbf{0}, \\lVert\\mathbf{k}\\rVert \\le k_{\\max}} \\frac{\\exp(-\\lVert\\mathbf{k}\\rVert^2 / (4\\alpha^2))}{\\lVert\\mathbf{k}\\rVert^2} |S(\\mathbf{k})|^2\n    $$\n    Here, $S(\\mathbf{k})$ is the structure factor, defined as:\n    $$\n    S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}_j)\n    $$\n    The squared magnitude is $|S(\\mathbf{k})|^2 = (\\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j))^2 + (\\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j))^2$.\n\n3.  **Self-Energy Correction ($E_{self}$)**: This term subtracts the artifact of each charge interacting with its own screening Gaussian distribution.\n    $$\n    E_{self} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^{N} q_i^2\n    $$\n\nThe parameter $\\alpha$ is unphysical; the total energy $E$ must be independent of its value, provided the cutoffs $r_c$ and $k_{\\max}$ are sufficiently large. The problem specifies a robust method to ensure consistent accuracy by linking the cutoffs to $\\alpha$ via a single parameter $s=2.0$. The cutoffs are set as $r_c = s/\\alpha$ and $k_{\\max} = 2\\alpha s$. This choice ensures that the dominant trailing terms in both sums, which scale approximately as $\\exp(-(\\alpha r_c)^2) = \\exp(-s^2)$ and $\\exp(-k_{\\max}^2 / (4\\alpha^2)) = \\exp(-s^2)$, are of comparable magnitude regardless of the chosen $\\alpha$.\n\nThe validation procedure involves computing the total energy $E$ for each test system at three different $\\alpha$ values ($\\{0.25, 0.6, 1.2\\}$) using the specified cutoff scheme. For each system, the spread of the computed energies (maximum minus minimum) is calculated. A small spread indicates a correct implementation and demonstrates the $\\alpha$-independence of the method.\n\nThe implementation will proceed by creating separate functions for each of the three energy components. The real-space sum iterates over charge pairs and relevant lattice image vectors up to $r_c$. The reciprocal-space sum iterates over reciprocal lattice vectors up to $k_{\\max}$. The self-energy is a direct sum over the charges. These components are then summed to yield the total energy for a given set of parameters. This process is repeated for all test cases and $\\alpha$ values to compute the final energy spreads.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom itertools import product\nimport math\n\ndef ewald_summation(charges, positions, L, alpha, s):\n    \"\"\"\n    Computes the total Ewald electrostatic energy for a periodic system.\n\n    This function implements the Ewald summation for a charge-neutral system of N point\n    charges in a cubic periodic box of side length L, assuming conducting\n    (tin-foil) boundary conditions. The energy is calculated in reduced units\n    where 4*pi*epsilon_0 = 1.\n\n    The total energy is the sum of three components:\n    1. Real-space sum for short-range interactions.\n    2. Reciprocal-space sum for long-range interactions.\n    3. Self-energy correction.\n\n    The Ewald splitting parameter `alpha` is used to define the cutoffs `rc` and `kmax`\n    via a single dimensionless parameter `s` to ensure consistent accuracy.\n\n    Args:\n        charges (np.ndarray): 1D array of charge values, shape (N,).\n        positions (np.ndarray): 2D array of particle positions, shape (N, 3).\n        L (float): Side length of the cubic simulation box.\n        alpha (float): Ewald splitting parameter.\n        s (float): Dimensionless parameter controlling the cutoffs.\n\n    Returns:\n        float: The total electrostatic energy.\n    \"\"\"\n    # Define cutoffs based on alpha and s\n    rc = s / alpha\n    kmax = 2 * s * alpha\n\n    # --- Real-space energy calculation ---\n    e_real = 0.0\n    N = len(charges)\n    n_max_real = math.ceil(rc / L)\n\n    for i in range(N):\n        for j in range(i, N):\n            r_ij = positions[i] - positions[j]\n            q_i_q_j = charges[i] * charges[j]\n            \n            if i == j:  # Self-interaction with periodic images\n                for n_vec in product(range(-n_max_real, n_max_real + 1), repeat=3):\n                    if all(c == 0 for c in n_vec):\n                        continue\n                    dist_vec = L * np.array(n_vec, dtype=float)\n                    dist = np.linalg.norm(dist_vec)\n                    if dist = rc:\n                        e_real += 0.5 * charges[i]**2 * erfc(alpha * dist) / dist\n            else:  # Interaction between distinct particles and their images\n                for n_vec in product(range(-n_max_real, n_max_real + 1), repeat=3):\n                    dist_vec = r_ij + L * np.array(n_vec, dtype=float)\n                    dist = np.linalg.norm(dist_vec)\n                    if dist  1e-9 and dist = rc: # dist  0 check for safety\n                        e_real += q_i_q_j * erfc(alpha * dist) / dist\n\n    # --- Reciprocal-space energy calculation ---\n    e_recip = 0.0\n    volume = L**3\n    m_max_recip = math.ceil(kmax * L / (2 * np.pi))\n\n    for m_vec in product(range(-m_max_recip, m_max_recip + 1), repeat=3):\n        if all(c == 0 for c in m_vec):\n            continue\n        \n        k_vec = (2 * np.pi / L) * np.array(m_vec, dtype=float)\n        k_sq = np.dot(k_vec, k_vec)\n\n        if np.sqrt(k_sq) = kmax:\n            # Structure factor S(k)\n            k_dot_r = np.dot(positions, k_vec)  # (N, 3) dot (3,) - (N,)\n            s_real = np.sum(charges * np.cos(k_dot_r))\n            s_imag = np.sum(charges * np.sin(k_dot_r))\n            s_k_sq = s_real**2 + s_imag**2\n            \n            e_recip += (np.exp(-k_sq / (4 * alpha**2)) / k_sq) * s_k_sq\n            \n    e_recip *= (2 * np.pi / volume)\n\n    # --- Self-energy correction ---\n    e_self = - (alpha / np.sqrt(np.pi)) * np.sum(charges**2)\n\n    return e_real + e_recip + e_self\n\ndef solve():\n    \"\"\"\n    Main function to run the validation test for the Ewald summation.\n    \"\"\"\n    L = 10.0\n    s = 2.0\n    alpha_values = [0.25, 0.6, 1.2]\n\n    test_cases = [\n        {\n            \"charges\": np.array([1.0, -1.0, 0.5, -0.5, 0.75, -0.75]),\n            \"positions\": np.array([\n                [1.0, 2.5, 3.3], [4.0, 5.5, 6.1], [7.2, 1.1, 8.8],\n                [2.4, 8.7, 0.9], [9.5, 3.3, 2.2], [0.2, 7.7, 5.5]\n            ])\n        },\n        {\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([\n                [2.0, 2.0, 2.0], [8.0, 8.0, 8.0]\n            ])\n        },\n        {\n            \"charges\": np.array([1.0, -1.0, 1.0, -1.0]),\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0], [1.8, 1.0, 1.0],\n                [7.0, 7.0, 7.0], [7.9, 7.0, 7.0]\n            ])\n        }\n    ]\n\n    spreads = []\n    for case in test_cases:\n        energies = []\n        for alpha in alpha_values:\n            energy = ewald_summation(\n                case[\"charges\"], case[\"positions\"], L, alpha, s\n            )\n            energies.append(energy)\n        \n        spread = max(energies) - min(energies)\n        spreads.append(spread)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, spreads))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a validated Ewald implementation in hand, the focus shifts from correctness to practical performance. The choice of the splitting parameter $\\alpha$ presents a critical trade-off: a large $\\alpha$ speeds up the real-space sum but slows down the reciprocal-space sum, and vice versa. This practice challenges you to find the optimal $\\alpha$ that minimizes the total computation time for a given accuracy . By setting up and solving an optimization problem based on simplified cost models, you will develop an essential skill for tuning molecular simulations for maximum efficiency.",
            "id": "2390963",
            "problem": "Consider a three-dimensional system of $N$ identical point charges of magnitude $q$ in a cubic, periodically replicated simulation box of edge length $L$, with number density $\\rho=N/L^3$. The electrostatic interaction is evaluated using the classical Ewald splitting with parameter $\\alpha0$, which decomposes the potential into a real-space part truncated at a real-space cutoff $r_c$ and a reciprocal-space part truncated at a wavevector magnitude cutoff $k_c$. Let the target absolute root-mean-square force error tolerance be $\\varepsilon0$. Assume that the real-space and reciprocal-space truncation errors are controlled by the following sufficient envelope conditions:\n- Real-space error condition: $\\operatorname{erfc}(\\alpha r_c) \\le \\varepsilon_r$.\n- Reciprocal-space error condition: $\\exp(-(k_c/(2\\alpha))^2) \\le \\varepsilon_k$.\nImpose the error allocation constraint $\\varepsilon_r=\\varepsilon_k=\\varepsilon/2$.\n\nAssume the following computational cost model (measured in time units that are arbitrary but consistent across real- and reciprocal-space parts):\n- Real-space evaluation cost $T_r$: proportional to the number of particle pairs within the cutoff. Model this as\n$$\nT_r = c_r\\, N\\, \\rho\\, \\frac{4\\pi}{3}\\, r_c^3,\n$$\nwhere $c_r0$ is the average real-space cost coefficient per pair in the same time units.\n- Reciprocal-space evaluation cost $T_k$: proportional to the number of wavevectors with $|\\mathbf{k}|\\le k_c$. Model this as\n$$\nT_k = c_k\\, N\\, \\frac{L^3}{6\\pi^2}\\, k_c^3,\n$$\nwhere $c_k0$ is the average reciprocal-space cost coefficient per mode in the same time units.\n\nDefine the total computation time as $T_{\\text{tot}}(\\alpha)=T_r+T_k$, where $r_c$ and $k_c$ are taken to be the smallest cutoffs that satisfy the respective error conditions for the given $\\alpha$ and error allocations.\n\nYour task is to determine, for each parameter set in the test suite below, the value of the Ewald splitting parameter $\\alpha^\\star$ that minimizes $T_{\\text{tot}}(\\alpha)$ under the stated model and constraints. Express each answer as a floating-point number (unitless).\n\nTest suite (each case is a tuple $(N,\\rho,\\varepsilon,c_r,c_k)$):\n- Case $1$: $(1000,\\,1.0,\\,10^{-4},\\,1.0,\\,1.0)$\n- Case $2$: $(8,\\,0.5,\\,10^{-3},\\,1.0,\\,1.0)$\n- Case $3$: $(10000,\\,1.0,\\,10^{-8},\\,1.0,\\,1.0)$\n- Case $4$: $(2000,\\,1.0,\\,10^{-5},\\,2.0,\\,0.5)$\n\nFinal output format: Your program should produce a single line of output containing a list with the optimal $\\alpha$ for each case in the order listed, rounded to six decimal places, as a comma-separated list enclosed in square brackets (e.g., $[0.123456,0.234567,0.345678,0.456789]$). No other output should be produced.",
            "solution": "The problem statement has been analyzed and found to be valid. It is a well-posed optimization problem grounded in the established theory of Ewald summation in computational physics. The givens are complete, consistent, and scientifically sound. I will now proceed to the formal derivation of the solution.\n\nThe objective is to find the Ewald splitting parameter $\\alpha^\\star$ that minimizes the total computational time $T_{\\text{tot}}(\\alpha) = T_r(\\alpha) + T_k(\\alpha)$. The costs $T_r$ and $T_k$ depend on $\\alpha$ through the real-space cutoff $r_c$ and reciprocal-space cutoff $k_c$. Our first step is to express these cutoffs as explicit functions of $\\alpha$.\n\nWe are given that $r_c$ and $k_c$ are the smallest values satisfying their respective error conditions. This directive implies that we should treat the inequalities as equalities.\n\nFor the real-space cutoff $r_c$, the condition is:\n$$\n\\operatorname{erfc}(\\alpha r_c) = \\varepsilon_r = \\frac{\\varepsilon}{2}\n$$\nSolving for the product $\\alpha r_c$ yields:\n$$\n\\alpha r_c = \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)\n$$\nwhere $\\operatorname{erfcinv}$ is the inverse complementary error function. Therefore, $r_c$ is determined as a function of $\\alpha$:\n$$\nr_c(\\alpha) = \\frac{1}{\\alpha} \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)\n$$\n\nFor the reciprocal-space cutoff $k_c$, the condition is:\n$$\n\\exp\\left(-\\left(\\frac{k_c}{2\\alpha}\\right)^2\\right) = \\varepsilon_k = \\frac{\\varepsilon}{2}\n$$\nTaking the natural logarithm of both sides gives:\n$$\n-\\left(\\frac{k_c}{2\\alpha}\\right)^2 = \\ln\\left(\\frac{\\varepsilon}{2}\\right)\n$$\nRearranging for $k_c$:\n$$\n\\left(\\frac{k_c}{2\\alpha}\\right)^2 = -\\ln\\left(\\frac{\\varepsilon}{2}\\right) = \\ln\\left(\\frac{2}{\\varepsilon}\\right)\n$$\n$$\nk_c(\\alpha) = 2\\alpha \\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)}\n$$\n\nNow we substitute these expressions for $r_c(\\alpha)$ and $k_c(\\alpha)$ into the given cost models.\n\nThe real-space cost $T_r$ is:\n$$\nT_r(\\alpha) = c_r N \\rho \\frac{4\\pi}{3} r_c(\\alpha)^3 = c_r N \\rho \\frac{4\\pi}{3} \\left( \\frac{1}{\\alpha} \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3 = \\frac{A}{\\alpha^3}\n$$\nwhere a constant $A$ is defined as:\n$$\nA = c_r N \\rho \\frac{4\\pi}{3} \\left( \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3\n$$\n\nThe reciprocal-space cost $T_k$ is:\n$$\nT_k(\\alpha) = c_k N \\frac{L^3}{6\\pi^2} k_c(\\alpha)^3\n$$\nUsing the definition of number density, $\\rho = N/L^3$, we have $L^3 = N/\\rho$. Substituting this and the expression for $k_c(\\alpha)$:\n$$\nT_k(\\alpha) = c_k N \\frac{N/\\rho}{6\\pi^2} \\left( 2\\alpha \\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)} \\right)^3 = c_k \\frac{N^2}{\\rho} \\frac{8\\alpha^3}{6\\pi^2} \\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2} = B \\alpha^3\n$$\nwhere a constant $B$ is defined as:\n$$\nB = c_k \\frac{N^2}{\\rho} \\frac{4}{3\\pi^2} \\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2}\n$$\n\nThe total computational cost as a function of $\\alpha$ is thus:\n$$\nT_{\\text{tot}}(\\alpha) = \\frac{A}{\\alpha^3} + B \\alpha^3\n$$\n\nTo find the minimum of $T_{\\text{tot}}(\\alpha)$, we compute its derivative with respect to $\\alpha$ and set it to zero:\n$$\n\\frac{d T_{\\text{tot}}}{d \\alpha} = \\frac{d}{d\\alpha} \\left( A\\alpha^{-3} + B \\alpha^3 \\right) = -3A\\alpha^{-4} + 3B\\alpha^2 = 0\n$$\nThis leads to:\n$$\n3B\\alpha^2 = 3A\\alpha^{-4}\n$$\n$$\nB\\alpha^6 = A\n$$\n$$\n\\alpha^6 = \\frac{A}{B}\n$$\n\nThe optimal parameter $\\alpha^\\star$ is therefore:\n$$\n\\alpha^\\star = \\left(\\frac{A}{B}\\right)^{1/6}\n$$\nSubstituting the expressions for $A$ and $B$:\n$$\n\\frac{A}{B} = \\frac{c_r N \\rho \\frac{4\\pi}{3} \\left( \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3}{c_k \\frac{N^2}{\\rho} \\frac{4}{3\\pi^2} \\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2}} = \\frac{c_r}{c_k} \\frac{N}{N^2} \\frac{\\rho}{\\rho^{-1}} \\frac{4\\pi/3}{4/(3\\pi^2)} \\frac{\\left( \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3}{\\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2}}\n$$\nSimplifying the terms:\n$$\n\\frac{A}{B} = \\frac{c_r}{c_k} \\frac{\\rho^2}{N} \\pi^3 \\left( \\frac{\\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)}{\\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)}} \\right)^3\n$$\nTaking the sixth root gives the final expression for the optimal Ewald parameter:\n$$\n\\alpha^\\star = \\left( \\frac{c_r}{c_k} \\frac{\\rho^2 \\pi^3}{N} \\right)^{1/6} \\left( \\frac{\\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)}{\\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)}} \\right)^{1/2}\n$$\nThis equation is implemented to compute the value of $\\alpha^\\star$ for each provided test case. The numerical calculation requires the evaluation of the inverse complementary error function, which is available in standard scientific computing libraries.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfcinv\n\ndef solve():\n    \"\"\"\n    Calculates the optimal Ewald splitting parameter alpha* for a set of test cases\n    based on a simplified cost model for real and reciprocal space computations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (N, rho, epsilon, c_r, c_k)\n    test_cases = [\n        (1000.0, 1.0, 1e-4, 1.0, 1.0),\n        (8.0, 0.5, 1e-3, 1.0, 1.0),\n        (10000.0, 1.0, 1e-8, 1.0, 1.0),\n        (2000.0, 1.0, 1e-5, 2.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, rho, eps, cr, ck = case\n        \n        # The derived formula for the optimal alpha is:\n        # alpha_star = (cr/ck * rho^2 * pi^3 / N)^(1/6) * sqrt(erfcinv(eps/2) / sqrt(ln(2/eps)))\n\n        # Calculate the first term of the formula\n        term1_base = (cr / ck) * (rho**2 * np.pi**3) / N\n        term1 = term1_base**(1.0 / 6.0)\n        \n        # Calculate the second term of the formula\n        # X corresponds to erfcinv(epsilon / 2)\n        X = erfcinv(eps / 2.0)\n        # Y corresponds to sqrt(ln(2 / epsilon))\n        Y = np.sqrt(np.log(2.0 / eps))\n        term2 = np.sqrt(X / Y)\n        \n        # Combine terms to get the final alpha_star\n        alpha_star = term1 * term2\n        \n        results.append(alpha_star)\n\n    # Format the output as a comma-separated list of floating-point numbers\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}