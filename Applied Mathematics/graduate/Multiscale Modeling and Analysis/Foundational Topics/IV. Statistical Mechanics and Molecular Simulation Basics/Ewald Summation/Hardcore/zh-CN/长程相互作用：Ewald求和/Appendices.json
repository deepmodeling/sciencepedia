{
    "hands_on_practices": [
        {
            "introduction": "在研究周期性系统中的静电相互作用时，一个自然而然的问题是：我们是否可以像处理短程相互作用那样，简单地使用一个截断半径来计算库仑力？这个实践练习将引导你通过具体的编程实现来回答这个问题。通过直接比较朴素截断法与精确的埃瓦尔德求和法 () 的计算结果，你将定量地理解为何对于长程库仑相互作用，简单的截断是不可行的，从而深刻认识到埃瓦尔德求和法在模拟离子和极性系统中的必要性。",
            "id": "2391007",
            "problem": "您必须编写一个完整的、可运行的程序，针对一小组明确指定的周期性电荷构型，量化库仑势的朴素球形截断与通过 Ewald 求和得到的完全周期性能量之间的差异。所有系统都是三维的，使用立方周期性边界条件 (PBC)，并且是电中性的。\n\n使用约化静电单位，其中库仑常数设为1，即能量单位的定义使得两个电荷量为 $1$ 的电荷在距离为 $r$ 时的库仑相互作用能为 $1/r$。所有能量都必须以这些约化能量单位表示为浮点数。\n\n您的程序需要使用的定义：\n\n- 立方模拟盒子的边长为 $L$，体积为 $V = L^3$。\n- 在原胞内部有 $N$ 个点电荷，其电荷值为 $q_i$，位置为 $\\mathbf{r}_i$，$i \\in \\{1,\\dots,N\\}$。\n- 朴素截断能使用最小镜像约定，球形截断半径为 $r_c = L/2$，并且仅包括满足 $r_{ij} < r_c$ 的粒子对。",
            "solution": "该问题要求对计算周期性点电荷体系静电势能的两种方法进行定量比较：一种是在球形截断半径处截断的朴素求和法，另一种是严谨的 Ewald 求和技术。我们将为三个指定的构型计算其差异，该差异定义为计算出的能量的绝对差值 $\\Delta E = |E_{\\mathrm{cut}} - E_{\\mathrm{Ewald}}|$。所有计算都将在约化静电单位下进行，其中库仑常数为 $1$。\n\n首先，我们定义基于朴素实空间截断的能量 $E_{\\mathrm{cut}}$。在一个边长为 $L$ 的立方盒子且具有周期性边界条件 (PBC) 的体系中，两个粒子 $i$ 和 $j$ 之间的相互作用是通过它们的最小镜像距离来计算的。位于位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的粒子间的最小镜像位移矢量 $\\Delta\\mathbf{r}_{ij}$ 是通过对矢量 $\\mathbf{r}_i - \\mathbf{r}_j$ 的每个分量 $\\Delta r_{\\alpha}$ 应用最近镜像约定得到的：\n$$\n\\Delta r_{\\alpha, \\text{mic}} = \\Delta r_{\\alpha} - L \\cdot \\text{round}\\left(\\frac{\\Delta r_{\\alpha}}{L}\\right)\n$$\n最小镜像距离即为 $r_{ij} = \\lVert \\Delta\\mathbf{r}_{ij, \\text{mic}} \\rVert$。截断能 $E_{\\mathrm{cut}}$ 是对所有最小镜像距离小于指定截断半径 $r_c$ 的唯一粒子对的求和。问题定义 $r_c = L/2$。因此能量为：\n$$\nE_{\\mathrm{cut}} = \\sum_{1 \\le i < j \\le N} \\frac{q_i q_j}{r_{ij}} \\quad \\text{for } r_{ij} < r_c\n$$\n对于像库仑势这样的长程相互作用，这种方法在计算上很简单，但在物理上是不正确的，因为它忽略了截断半径之外的相互作用，并在截断边界处不恰当地截断了相互作用，从而破坏了势的周期性。\n\n接下来，我们使用 Ewald 求和法定义能量 $E_{\\mathrm{Ewald}}$。这是在锡箔（导电）边界条件下计算周期性体系中静电能的正确方法。该方法将慢收敛级数 $\\sum_{\\mathbf{n}} \\frac{1}{|\\mathbf{r}+\\mathbf{n}L|}$ 分裂为两个快速收敛的级数：一个在实空间，一个在倒易空间。这是通过在每个点电荷上加上和减去一个符号相反的高斯电荷分布来实现的。总势能是三项之和：实空间能 $E_{\\text{real}}$、倒易空间能 $E_{\\text{recip}}$ 和自能校正 $E_{\\text{self}}$。\n\n$E_{\\mathrm{Ewald}} = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}}$\n\n实空间分量考虑了短程相互作用，这些相互作用被互补的高斯分布所屏蔽。其形式为：\n$$\nE_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}{'} q_i q_j \\frac{\\text{erfc}(\\alpha |\\mathbf{r}_{ij} + \\mathbf{n}L|)}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\n此处，$\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$，$\\mathbf{n}$ 是一个具有整数分量的晶格矢量，$\\alpha$ 是控制两个和收敛性的分裂参数，$\\text{erfc}$ 是互补误差函数。求和符号上的撇号表示当 $\\mathbf{n}=\\mathbf{0}$ 时，排除 $i=j$ 的项。问题指定了一个对晶格矢量的有限求和，其中分量 $n_x, n_y, n_z$ 属于集合 $\\{-5, \\dots, 5\\}$，并附加了一个截断条件，即只包括满足 $|\\mathbf{r}_{ij} + \\mathbf{n}L| < r_{\\mathrm{real}} = L/2$ 的项。分裂参数固定为 $\\alpha = 5/L$。\n\n倒易空间分量考虑了相互作用的长程部分。它是对倒易晶格矢量 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ 的求和，其中 $\\mathbf{m}$ 是一个整数分量矢量。其形式为：\n$$\nE_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} |S(\\mathbf{k})|^2\n$$\n其中 $V=L^3$ 是盒子体积，$k = |\\mathbf{k}|$，$S(\\mathbf{k})$ 是结构因子，定义为：\n$$\nS(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\n求和遍历所有由整数三元组 $\\mathbf{m}=(m_x, m_y, m_z)$（其分量在集合 $\\{-6, \\dots, 6\\}$ 中）定义的非零倒易晶格矢量。体系的电中性 $\\sum_j q_j = 0$ 确保了 $S(\\mathbf{k}=0)=0$，从而正确处理了在 $\\mathbf{k}=\\mathbf{0}$ 处的奇异性。\n\n自能项 $E_{\\text{self}}$ 减去了每个高斯电荷云与其中心点电荷之间的人为相互作用。它由下式给出：\n$$\nE_{\\text{self}} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2\n$$\n这一项是为了校正因添加高斯屏蔽电荷而引入的误差所必需的。\n\n实现将根据这些精确的定义和指定的数值参数，为每种能量计算（$E_{\\mathrm{cut}}$ 和 $E_{\\mathrm{Ewald}}$）构建函数。然后为提供的三个测试用例中的每一个计算绝对差值 $\\Delta E$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef calculate_E_cut(charges, positions, L):\n    \"\"\"\n    Calculates the naive cutoff energy using the minimum-image convention.\n    \"\"\"\n    N = len(charges)\n    rc = L / 2.0\n    energy = 0.0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            rij_vec = positions[i] - positions[j]\n            # Apply minimum image convention\n            rij_vec_mic = rij_vec - L * np.round(rij_vec / L)\n            rij = np.linalg.norm(rij_vec_mic)\n\n            if rij < rc:\n                energy += charges[i] * charges[j] / rij\n    \n    return energy\n\ndef calculate_E_ewald(charges, positions, L):\n    \"\"\"\n    Calculates the Ewald summation energy with specified parameters.\n    \"\"\"\n    N = len(charges)\n    V = L**3\n    alpha = 5.0 / L\n    \n    # 1. Real-space energy\n    E_real = 0.0\n    r_real_cut = L / 2.0\n    n_range = np.arange(-5, 6)\n    \n    n_vectors = []\n    for nx in n_range:\n        for ny in n_range:\n            for nz in n_range:\n                n_vectors.append(np.array([nx, ny, nz]))\n    \n    for i in range(N):\n        for j in range(N):\n            rij_vec = positions[i] - positions[j]\n            for n_vec in n_vectors:\n                if i == j and np.all(n_vec == 0):\n                    continue\n                \n                dist_vec = rij_vec + n_vec * L\n                dist = np.linalg.norm(dist_vec)\n                \n                if dist < r_real_cut:\n                    E_real += charges[i] * charges[j] * erfc(alpha * dist) / dist\n    \n    E_real *= 0.5\n\n    # 2. Reciprocal-space energy\n    E_recip = 0.0\n    m_range = np.arange(-6, 7)\n    \n    m_vectors = []\n    for mx in m_range:\n        for my in m_range:\n            for mz in m_range:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m_vectors.append(np.array([mx, my, mz]))\n    \n    for m_vec in m_vectors:\n        k_vec = (2.0 * np.pi / L) * m_vec\n        k_sq = np.dot(k_vec, k_vec)\n        \n        # Calculate structure factor S(k)\n        # S(k) = sum_j q_j * exp(-i * k.r_j)\n        # |S(k)|^2 = (Re(S))^2 + (Im(S))^2\n        # Re(S) = sum_j q_j * cos(k.r_j)\n        # Im(S) = -sum_j q_j * sin(k.r_j)\n        \n        S_k_real = 0.0\n        S_k_imag = 0.0\n        for j in range(N):\n            k_dot_rj = np.dot(k_vec, positions[j])\n            S_k_real += charges[j] * np.cos(k_dot_rj)\n            S_k_imag += charges[j] * np.sin(k_dot_rj)\n        \n        # Note: sin part corresponds to -Im(S), so |S|^2 = S_k_real^2 + S_k_imag^2\n        S_k_sq = S_k_real**2 + S_k_imag**2\n        \n        E_recip += (1.0 / k_sq) * np.exp(-k_sq / (4.0 * alpha**2)) * S_k_sq\n    \n    E_recip *= (2.0 * np.pi / V)\n\n    # 3. Self-energy correction\n    q_sq_sum = np.sum(np.square(charges))\n    E_self = -(alpha / np.sqrt(np.pi)) * q_sq_sum\n    \n    return E_real + E_recip + E_self\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case A: L=10.0, N=2, q=[+1,-1], r1=(1,1,1), r2=(5.9,1,1)\n        {\n            \"L\": 10.0,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [5.9, 1.0, 1.0]])\n        },\n        # Case B: L=8.0, N=2, q=[+1,-1], r1=(1,1,1), r2=(4.8,1,1)\n        {\n            \"L\": 8.0,\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [4.8, 1.0, 1.0]])\n        },\n        # Case C: L=6.0, N=4, q=[+1,+1,-1,-1], r1=(1,1,1), r2=(4,1,1), r3=(1,4,1), r4=(4,4,1)\n        {\n            \"L\": 6.0,\n            \"charges\": np.array([1.0, 1.0, -1.0, -1.0]),\n            \"positions\": np.array([[1.0, 1.0, 1.0], [4.0, 1.0, 1.0], [1.0, 4.0, 1.0], [4.0, 4.0, 1.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        charges = case[\"charges\"]\n        positions = case[\"positions\"]\n\n        E_cut = calculate_E_cut(charges, positions, L)\n        E_ewald = calculate_E_ewald(charges, positions, L)\n        \n        delta_E = np.abs(E_cut - E_ewald)\n        results.append(delta_E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确认了埃瓦尔德求和法的必要性之后，下一步是深入理解其内在机制。该方法引入了一个非物理的屏蔽参数 $\\alpha$，它将一个缓收敛的求和分解为两个速收敛的级数（一个在实空间，一个在倒易空间）。一个关键的理论保证是，只要两个级数都得到充分收敛，最终计算出的总能量与 $\\alpha$ 的具体选择无关。通过完成这项实践 ()，你将通过数值实验来验证这一基本性质，这不仅能加深你对埃瓦尔德方法数学技巧的理解，也是检验任何埃瓦尔德求和程序正确性的黄金标准。",
            "id": "3756016",
            "problem": "您的任务是为三维立方周期性系统中的Ewald求和设计并实现一个数值验证测试，重点是证明总静电能与Ewald分裂参数无关。Ewald求和用于计算在周期性边界条件（PBC）下点电荷集合的对库仑能量，其方法是将计算分解为一个短程实空间求和与一个长程倒易空间求和。您的验证必须在实空间和倒易空间求和的截断误差在不同 $\\,\\alpha\\,$ 值下保持近似恒定的约束下，比较总Ewald能量随高斯屏蔽参数 $\\,\\alpha\\,$ 变化的情况。\n\n从以下基础开始：在一个边长为 $\\,L\\,$ 的周期性复制立方晶胞中，$\\,N\\,$ 个位于位置 $\\,\\{\\mathbf{r}_i\\}\\,$ 的点电荷 $\\,\\{q_i\\}\\,$ 通过库仑势相互作用的静电能是条件收敛的，必须进行正则化。Ewald方法通过引入一个高斯屏蔽来实现这一点，从而产生两个互补的求和（实空间和倒易空间），外加一个自能修正项。在导电边界条件（锡箔边界）下，不存在依赖于形状的表面项。一个广为接受的事实是，对于高斯屏蔽，实空间和倒易空间求和的截断尾部是指数级小的，并且可以通过选择一致的截断值来控制。在约化单位中，设 $\\,4\\pi\\varepsilon_0 = 1\\,$，从而使能量无量纲。\n\n设计一个程序，该程序：\n1. 实现电中性构型（即 $\\,\\sum_i q_i = 0\\,$）在模拟单元中的总Ewald能量，使用边长为 $\\,L\\,$ 的三维立方晶胞，并采用PBC和导电边界条件。该实现必须包括：\n   - 一个在实空间半径 $\\,r_c\\,$ 内截断的、对成对镜像 $\\,\\mathbf{r}_{ij} + \\mathbf{n}L\\,$ 的实空间求和，其中 $\\,\\mathbf{n}\\in\\mathbb{Z}^3\\,$，$\\,\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i\\,$，且 $\\,\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert \\le r_c\\,$。\n   - 一个对波矢 $\\,\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}\\,$（其中 $\\,\\mathbf{m}\\in\\mathbb{Z}^3\\,$）的倒易空间求和，在 $\\,\\lVert \\mathbf{k} \\rVert \\le k_{\\max}\\,$ 处截断，并排除 $\\,\\mathbf{k}=\\mathbf{0}\\,$。\n   - 针对高斯屏蔽的自能修正。\n2. 通过根据以下基于互补误差函数和高斯阻尼渐近行为的误差控制设计选择，从单个无量纲参数 $\\,s > 0\\,$ 中选择截断值 $\\,r_c\\,$ 和 $\\,k_{\\max}\\,$，以确保在不同 $\\,\\alpha\\,$ 下具有一致的尾部误差：\n   - 对每个测试的 $\\,\\alpha\\,$，保持 $\\,\\alpha r_c = s\\,$ 和 $\\,\\frac{k_{\\max}}{2\\alpha} = s\\,$。这使得指数阻尼因子 $\\,\\mathrm{erfc}(\\alpha r)\\,$ 和 $\\,\\exp\\!\\big(-\\lVert \\mathbf{k} \\rVert^2/(4\\alpha^2)\\big)\\,$ 在截断边界附近的量级与 $\\,\\exp(-s^2)\\,$ 相当，从而在不同 $\\,\\alpha\\,$ 之间产生近似恒定的截断误差预算。\n3. 通过使用上述截断值和固定的 $\\,s\\,$ 计算几个 $\\,\\alpha\\,$ 值下的总能量，来验证 $\\,\\alpha\\,$ 无关性，然后报告每个测试系统中能量值的离散度（最大能量减去最小能量）。\n\n使用以下具有无量纲量的测试套件（长度单位与 $\\,L\\,$ 相同，能量无量纲）：\n- 除 $\\,\\alpha\\,$ 外，所有测试的系统参数均相同。使用边长为 $\\,L = 10\\,$ 的立方晶胞。\n- 对所有测试使用 $\\,s = 2.0\\,$。这对应于近似的截断尾部尺度 $\\,\\exp(-s^2) = \\exp(-4)\\,$，从而在不同 $\\,\\alpha\\,$ 之间提供了一致的误差预算。\n- 测试集 $\\,\\mathcal{A}\\,$ (理想情况)：六个电荷，保持电中性，\n  电荷 $\\,\\mathbf{q} = [\\,1.0,\\,-1.0,\\,0.5,\\,-0.5,\\,0.75,\\,-0.75\\,]\\,$,\n  位置 $\\,\\mathbf{r} = [\\,[\\,1.0,\\,2.5,\\,3.3\\,],\\,[\\,4.0,\\,5.5,\\,6.1\\,],\\,[\\,7.2,\\,1.1,\\,8.8\\,],\\,[\\,2.4,\\,8.7,\\,0.9\\,],\\,[\\,9.5,\\,3.3,\\,2.2\\,],\\,[\\,0.2,\\,7.7,\\,5.5\\,]\\,]\\,$.\n- 测试集 $\\,\\mathcal{B}\\,$ (对称性边界情况)：两个相反电荷，\n  电荷 $\\,\\mathbf{q} = [\\,1.0,\\,-1.0\\,]\\,$,\n  位置 $\\,\\mathbf{r} = [\\,[\\,2.0,\\,2.0,\\,2.0\\,],\\,[\\,8.0,\\,8.0,\\,8.0\\,]\\,]\\,$.\n- 测试集 $\\,\\mathcal{C}\\,$ (近场偶极子)：形成两个偶极子的四个电荷，\n  电荷 $\\,\\mathbf{q} = [\\,1.0,\\,-1.0,\\,1.0,\\,-1.0\\,]\\,$,\n  位置 $\\,\\mathbf{r} = [\\,[\\,1.0,\\,1.0,\\,1.0\\,],\\,[\\,1.8,\\,1.0,\\,1.0\\,],\\,[\\,7.0,\\,7.0,\\,7.0\\,],\\,[\\,7.9,\\,7.0,\\,7.0\\,]\\,]\\,$.\n- 对于每个测试集，在 $\\,\\alpha \\in \\{\\,0.25,\\,0.6,\\,1.2\\,\\}\\,$ 处评估能量，并使用 $\\,r_c = s/\\alpha\\,$ 和 $\\,k_{\\max} = 2\\alpha s\\,$。\n\n您的程序必须生成单行输出，包含三个测试集的能量离散度，格式为 $\\,\\big[\\,x_1, x_2, x_3\\,\\big]\\,$，其中每个 $\\,x_i\\,$ 是对应测试集在三个 $\\,\\alpha\\,$ 值下能量的最大值减去最小值的浮点数。能量和离散度是无量纲的，必须在 $\\,4\\pi\\varepsilon_0 = 1\\,$ 的约化单位中计算。最终的打印输出必须只包含该行，无任何附加文本。角度单位不适用。百分比不适用。输出类型为浮点数列表。\n\n您的实现必须是完整且自包含的，可使用任何现代编程语言。在最终答案中，提供遵循指定运行时环境的可执行Python代码。代码不得需要任何用户输入或外部资源。",
            "solution": "已对用户提供的问题陈述进行分析，并认定其有效。这是一个计算物理领域中科学上合理、定义明确且客观的问题。它要求实现和验证Ewald求和方法，这是一种用于计算周期性系统中静电能的标准基础算法。所有参数、物理条件和测试用例都已明确无误地指定。\n\n解决方案按以下步骤进行。首先，建立Ewald求和方法的理论基础，详细说明总静电能的数学表达式。其次，描述基于这些表达式的算法实现，包括为确保不同求和参数下精度一致而设计的特定截断方案。\n\n在一个边长为L的立方晶胞中，对于一个由N个点电荷 $\\{q_i\\}$（位于位置 $\\{\\mathbf{r}_i\\}$）组成的周期性系统，在导电边界条件和整体电中性（$\\sum_i q_i = 0$）下，其总静电能 $E$ 使用Ewald方法计算。该方法将条件收敛的库仑求和分解为三个绝对收敛的项：实空间求和（$E_{real}$）、倒易空间求和（$E_{recip}$）和自能修正（$E_{self}$）。在库仑常数 $1/(4\\pi\\varepsilon_0)$ 为1的约化单位中，总能量为 $E = E_{real} + E_{recip} + E_{self}$。\n\n这种分解是通过在每个点电荷上加上和减去一组屏蔽高斯电荷分布来实现的。参数 $\\alpha$ 控制这些高斯分布的宽度：较大的 $\\alpha$ 对应于更窄、更局域化的高斯分布。\n\n1.  **实空间能量 ($E_{real}$)**：该项解释了短程相互作用。它是电荷对之间相互作用的总和，由互补误差函数 $\\mathrm{erfc}(x)$ 屏蔽。求和遍及所有电荷对 $(i, j)$ 和所有周期性晶格矢量 $\\mathbf{n}L$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。电荷在原胞中与自身的相互作用项（$\\mathbf{n}=\\mathbf{0}$，$i=j$）被排除在外。求和在截断半径 $r_c$ 处截断。\n    $$\n    E_{real} = \\frac{1}{2} \\sideset{}{'}\\sum_{i,j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3, \\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert \\le r_c} q_i q_j \\frac{\\mathrm{erfc}(\\alpha \\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert)}{\\lVert \\mathbf{r}_{ij} + \\mathbf{n}L \\rVert}\n    $$\n    其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$，求和符号上的撇号表示排除 $(i=j, \\mathbf{n}=\\mathbf{0})$ 项。\n\n2.  **倒易空间能量 ($E_{recip}$)**：该项解释了长程相互作用。它是对倒易晶格矢量 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$（其中 $\\mathbf{m} \\in \\mathbb{Z}^3$）的求和。由于整体电中性，$\\mathbf{k}=\\mathbf{0}$ 项被排除。求和在截断大小 $k_{\\max}$ 处截断。\n    $$\n    E_{recip} = \\frac{2\\pi}{L^3} \\sum_{\\mathbf{k} \\neq \\mathbf{0}, \\lVert\\mathbf{k}\\rVert \\le k_{\\max}} \\frac{\\exp(-\\lVert\\mathbf{k}\\rVert^2 / (4\\alpha^2))}{\\lVert\\mathbf{k}\\rVert^2} |S(\\mathbf{k})|^2\n    $$\n    这里，$S(\\mathbf{k})$ 是结构因子，定义为：\n    $$\n    S(\\mathbf{k}) = \\sum_{j=1}^{N} q_j \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}_j)\n    $$\n    其模的平方为 $|S(\\mathbf{k})|^2 = (\\sum_j q_j \\cos(\\mathbf{k}\\cdot\\mathbf{r}_j))^2 + (\\sum_j q_j \\sin(\\mathbf{k}\\cdot\\mathbf{r}_j))^2$。\n\n3.  **自能修正 ($E_{self}$)**：该项减去每个电荷与其自身屏蔽高斯分布相互作用所产生的人为影响。\n    $$\n    E_{self} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^{N} q_i^2\n    $$\n\n参数 $\\alpha$ 是非物理的；只要截断值 $r_c$ 和 $k_{\\max}$ 足够大，总能量 $E$ 必须与其值无关。问题指定了一种鲁棒的方法，通过单个参数 $s=2.0$ 将截断值与 $\\alpha$ 联系起来，以确保一致的精度。截断值设为 $r_c = s/\\alpha$ 和 $k_{\\max} = 2\\alpha s$。这一选择确保了两个求和中的主要尾项（其尺度近似为 $\\exp(-(\\alpha r_c)^2) = \\exp(-s^2)$ 和 $\\exp(-k_{\\max}^2 / (4\\alpha^2)) = \\exp(-s^2)$）无论选择何种 $\\alpha$ 都具有可比的量级。\n\n验证过程包括使用指定的截断方案，为每个测试系统在三个不同的 $\\alpha$ 值（$\\{0.25, 0.6, 1.2\\}$）下计算总能量 $E$。对于每个系统，计算所计算能量的离散度（最大值减去最小值）。一个小的离散度表明实现正确，并证明了该方法的 $\\alpha$ 无关性。\n\n实现将通过为三个能量分量分别创建函数来进行。实空间求和遍历电荷对和直至 $r_c$ 的相关晶格镜像矢量。倒易空间求和遍历直至 $k_{\\max}$ 的倒易晶格矢量。自能是对电荷的直接求和。然后将这些分量相加以得出给定参数集下的总能量。对所有测试用例和 $\\alpha$ 值重复此过程，以计算最终的能量离散度。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom itertools import product\nimport math\n\ndef ewald_summation(charges, positions, L, alpha, s):\n    \"\"\"\n    Computes the total Ewald electrostatic energy for a periodic system.\n\n    This function implements the Ewald summation for a charge-neutral system of N point\n    charges in a cubic periodic box of side length L, assuming conducting\n    (tin-foil) boundary conditions. The energy is calculated in reduced units\n    where 4*pi*epsilon_0 = 1.\n\n    The total energy is the sum of three components:\n    1. Real-space sum for short-range interactions.\n    2. Reciprocal-space sum for long-range interactions.\n    3. Self-energy correction.\n\n    The Ewald splitting parameter `alpha` is used to define the cutoffs `rc` and `kmax`\n    via a single dimensionless parameter `s` to ensure consistent accuracy.\n\n    Args:\n        charges (np.ndarray): 1D array of charge values, shape (N,).\n        positions (np.ndarray): 2D array of particle positions, shape (N, 3).\n        L (float): Side length of the cubic simulation box.\n        alpha (float): Ewald splitting parameter.\n        s (float): Dimensionless parameter controlling the cutoffs.\n\n    Returns:\n        float: The total electrostatic energy.\n    \"\"\"\n    # Define cutoffs based on alpha and s\n    rc = s / alpha\n    kmax = 2 * s * alpha\n\n    # --- Real-space energy calculation ---\n    e_real = 0.0\n    N = len(charges)\n    n_max_real = math.ceil(rc / L)\n\n    for i in range(N):\n        for j in range(i, N):\n            r_ij = positions[i] - positions[j]\n            q_i_q_j = charges[i] * charges[j]\n            \n            if i == j:  # Self-interaction with periodic images\n                for n_vec in product(range(-n_max_real, n_max_real + 1), repeat=3):\n                    if all(c == 0 for c in n_vec):\n                        continue\n                    dist_vec = L * np.array(n_vec, dtype=float)\n                    dist = np.linalg.norm(dist_vec)\n                    if dist = rc:\n                        e_real += 0.5 * charges[i]**2 * erfc(alpha * dist) / dist\n            else:  # Interaction between distinct particles and their images\n                for n_vec in product(range(-n_max_real, n_max_real + 1), repeat=3):\n                    dist_vec = r_ij + L * np.array(n_vec, dtype=float)\n                    dist = np.linalg.norm(dist_vec)\n                    if dist  1e-9 and dist = rc: # dist > 0 check for safety\n                        e_real += q_i_q_j * erfc(alpha * dist) / dist\n\n    # --- Reciprocal-space energy calculation ---\n    e_recip = 0.0\n    volume = L**3\n    m_max_recip = math.ceil(kmax * L / (2 * np.pi))\n\n    for m_vec in product(range(-m_max_recip, m_max_recip + 1), repeat=3):\n        if all(c == 0 for c in m_vec):\n            continue\n        \n        k_vec = (2 * np.pi / L) * np.array(m_vec, dtype=float)\n        k_sq = np.dot(k_vec, k_vec)\n\n        if np.sqrt(k_sq) = kmax:\n            # Structure factor S(k)\n            k_dot_r = np.dot(positions, k_vec)  # (N, 3) dot (3,) -> (N,)\n            s_real = np.sum(charges * np.cos(k_dot_r))\n            s_imag = np.sum(charges * np.sin(k_dot_r))\n            s_k_sq = s_real**2 + s_imag**2\n            \n            e_recip += (np.exp(-k_sq / (4 * alpha**2)) / k_sq) * s_k_sq\n            \n    e_recip *= (2 * np.pi / volume)\n\n    # --- Self-energy correction ---\n    e_self = - (alpha / np.sqrt(np.pi)) * np.sum(charges**2)\n\n    return e_real + e_recip + e_self\n\ndef solve():\n    \"\"\"\n    Main function to run the validation test for the Ewald summation.\n    \"\"\"\n    L = 10.0\n    s = 2.0\n    alpha_values = [0.25, 0.6, 1.2]\n\n    test_cases = [\n        {\n            \"charges\": np.array([1.0, -1.0, 0.5, -0.5, 0.75, -0.75]),\n            \"positions\": np.array([\n                [1.0, 2.5, 3.3], [4.0, 5.5, 6.1], [7.2, 1.1, 8.8],\n                [2.4, 8.7, 0.9], [9.5, 3.3, 2.2], [0.2, 7.7, 5.5]\n            ])\n        },\n        {\n            \"charges\": np.array([1.0, -1.0]),\n            \"positions\": np.array([\n                [2.0, 2.0, 2.0], [8.0, 8.0, 8.0]\n            ])\n        },\n        {\n            \"charges\": np.array([1.0, -1.0, 1.0, -1.0]),\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0], [1.8, 1.0, 1.0],\n                [7.0, 7.0, 7.0], [7.9, 7.0, 7.0]\n            ])\n        }\n    ]\n\n    spreads = []\n    for case in test_cases:\n        energies = []\n        for alpha in alpha_values:\n            energy = ewald_summation(\n                case[\"charges\"], case[\"positions\"], L, alpha, s\n            )\n            energies.append(energy)\n        \n        spread = max(energies) - min(energies)\n        spreads.append(spread)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, spreads))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了埃瓦尔德求和法的原理和正确性之后，我们转向一个核心的实际问题：如何高效地执行计算？屏蔽参数 $\\alpha$ 的选择直接决定了计算在实空间和倒易空间的工作量分配，从而影响总计算成本。一个大的 $\\alpha$ 值会加速实空间部分的收敛，但会减慢倒易空间部分，反之亦然。这项练习 () 将理论付诸实践，要求你基于给定的计算成本模型，推导出在特定精度要求下能够最小化总计算时间的最佳参数 $\\alpha^{\\star}$。这对于进行大规模分子动力学模拟，平衡计算精度与效率，是一项至关重要的技能。",
            "id": "2390963",
            "problem": "考虑一个三维系统，其中包含 $N$ 个大小为 $q$ 的相同点电荷，它们位于边长为 $L$、数密度为 $\\rho=N/L^3$ 的立方周期性重复模拟盒子中。静电相互作用使用经典的 Ewald 分裂方法进行评估，该方法使用参数 $\\alpha0$ 将势分解为在实空间截断半径 $r_c$ 处截断的实空间部分和在波矢大小截断值 $k_c$ 处截断的倒空间部分。设目标绝对均方根力误差容限为 $\\varepsilon0$。假设实空间和倒空间的截断误差由以下充分的包络条件控制：\n- 实空间误差条件：$\\operatorname{erfc}(\\alpha r_c) \\le \\varepsilon_r$。\n- 倒空间误差条件：$\\exp\\!\\big(-(k_c/(2\\alpha))^2\\big) \\le \\varepsilon_k$。\n施加误差分配约束 $\\varepsilon_r=\\varepsilon_k=\\varepsilon/2$。\n\n假设以下计算成本模型（以任意但实空间和倒空间部分一致的时间单位度量）：\n- 实空间评估成本 $T_r$：与截断半径内的粒子对数量成正比。模型如下\n$$\nT_r = c_r\\, N\\, \\rho\\, \\frac{4\\pi}{3}\\, r_c^3,\n$$\n其中 $c_r0$ 是以相同时间单位表示的每个粒子对的平均实空间成本系数。\n- 倒空间评估成本 $T_k$：与 $|\\mathbf{k}|\\le k_c$ 的波矢数量成正比。模型如下\n$$\nT_k = c_k\\, N\\, \\frac{L^3}{6\\pi^2}\\, k_c^3,\n$$\n其中 $c_k0$ 是以相同时间单位表示的每个模式的平均倒空间成本系数。\n\n将总计算时间定义为 $T_{\\text{tot}}(\\alpha)=T_r+T_k$，其中 $r_c$ 和 $k_c$ 被取为在给定的 $\\alpha$ 和误差分配下满足相应误差条件的最小截断值。\n\n您的任务是，对于下面测试集中的每个参数集，确定在所述模型和约束条件下使 $T_{\\text{tot}}(\\alpha)$ 最小化的 Ewald 分裂参数 $\\alpha^\\star$ 的值。将每个答案表示为一个浮点数（无单位）。\n\n测试集（每个案例是一个元组 $(N,\\rho,\\varepsilon,c_r,c_k)$）：\n- 案例 1：$(1000,\\,1.0,\\,10^{-4},\\,1.0,\\,1.0)$\n- 案例 2：$(8,\\,0.5,\\,10^{-3},\\,1.0,\\,1.0)$\n- 案例 3：$(10000,\\,1.0,\\,10^{-8},\\,1.0,\\,1.0)$\n- 案例 4：$(2000,\\,1.0,\\,10^{-5},\\,2.0,\\,0.5)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个列表，按所列顺序包含每个案例的最优 $\\alpha$，四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表（例如，$\\texttt{[0.123456,0.234567,0.345678,0.456789]}$）。不应产生其他输出。",
            "solution": "问题陈述已经过分析，并被证实是有效的。这是一个适定优化问题，其基础是计算物理学中既定的 Ewald 求和理论。给定条件是完整、一致且科学上合理的。我现在将开始进行解的正式推导。\n\n目标是找到使总计算时间 $T_{\\text{tot}}(\\alpha) = T_r(\\alpha) + T_k(\\alpha)$ 最小化的 Ewald 分裂参数 $\\alpha^\\star$。成本 $T_r$ 和 $T_k$ 通过实空间截断半径 $r_c$ 和倒空间截断值 $k_c$ 依赖于 $\\alpha$。我们的第一步是将这些截断值表示为 $\\alpha$ 的显式函数。\n\n给定条件是 $r_c$ 和 $k_c$ 是满足各自误差条件的最小值。这个指令意味着我们应该将不等式视为等式。\n\n对于实空间截断半径 $r_c$，条件是：\n$$\n\\operatorname{erfc}(\\alpha r_c) = \\varepsilon_r = \\frac{\\varepsilon}{2}\n$$\n求解乘积 $\\alpha r_c$ 可得：\n$$\n\\alpha r_c = \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)\n$$\n其中 $\\operatorname{erfcinv}$ 是逆互补误差函数。因此，$r_c$ 被确定为 $\\alpha$ 的函数：\n$$\nr_c(\\alpha) = \\frac{1}{\\alpha} \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)\n$$\n\n对于倒空间截断值 $k_c$，条件是：\n$$\n\\exp\\left(-\\left(\\frac{k_c}{2\\alpha}\\right)^2\\right) = \\varepsilon_k = \\frac{\\varepsilon}{2}\n$$\n对两边取自然对数可得：\n$$\n-\\left(\\frac{k_c}{2\\alpha}\\right)^2 = \\ln\\left(\\frac{\\varepsilon}{2}\\right)\n$$\n对 $k_c$ 进行整理：\n$$\n\\left(\\frac{k_c}{2\\alpha}\\right)^2 = -\\ln\\left(\\frac{\\varepsilon}{2}\\right) = \\ln\\left(\\frac{2}{\\varepsilon}\\right)\n$$\n$$\nk_c(\\alpha) = 2\\alpha \\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)}\n$$\n\n现在我们将 $r_c(\\alpha)$ 和 $k_c(\\alpha)$ 的这些表达式代入给定的成本模型。\n\n实空间成本 $T_r$ 为：\n$$\nT_r(\\alpha) = c_r N \\rho \\frac{4\\pi}{3} r_c(\\alpha)^3 = c_r N \\rho \\frac{4\\pi}{3} \\left( \\frac{1}{\\alpha} \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3 = \\frac{A}{\\alpha^3}\n$$\n其中常数 $A$ 定义为：\n$$\nA = c_r N \\rho \\frac{4\\pi}{3} \\left( \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3\n$$\n\n倒空间成本 $T_k$ 为：\n$$\nT_k(\\alpha) = c_k N \\frac{L^3}{6\\pi^2} k_c(\\alpha)^3\n$$\n使用数密度的定义 $\\rho = N/L^3$，我们有 $L^3 = N/\\rho$。代入此式和 $k_c(\\alpha)$ 的表达式：\n$$\nT_k(\\alpha) = c_k N \\frac{N/\\rho}{6\\pi^2} \\left( 2\\alpha \\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)} \\right)^3 = c_k \\frac{N^2}{\\rho} \\frac{8\\alpha^3}{6\\pi^2} \\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2} = B \\alpha^3\n$$\n其中常数 $B$ 定义为：\n$$\nB = c_k \\frac{N^2}{\\rho} \\frac{4}{3\\pi^2} \\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2}\n$$\n\n因此，总计算成本作为 $\\alpha$ 的函数为：\n$$\nT_{\\text{tot}}(\\alpha) = \\frac{A}{\\alpha^3} + B \\alpha^3\n$$\n\n为了找到 $T_{\\text{tot}}(\\alpha)$ 的最小值，我们计算它关于 $\\alpha$ 的导数并将其设为零：\n$$\n\\frac{d T_{\\text{tot}}}{d \\alpha} = \\frac{d}{d\\alpha} \\left( A\\alpha^{-3} + B \\alpha^3 \\right) = -3A\\alpha^{-4} + 3B\\alpha^2 = 0\n$$\n这导致：\n$$\n3B\\alpha^2 = 3A\\alpha^{-4}\n$$\n$$\nB\\alpha^6 = A\n$$\n$$\n\\alpha^6 = \\frac{A}{B}\n$$\n\n因此，最优参数 $\\alpha^\\star$ 为：\n$$\n\\alpha^\\star = \\left(\\frac{A}{B}\\right)^{1/6}\n$$\n代入 A 和 B 的表达式：\n$$\n\\frac{A}{B} = \\frac{c_r N \\rho \\frac{4\\pi}{3} \\left( \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3}{c_k \\frac{N^2}{\\rho} \\frac{4}{3\\pi^2} \\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2}} = \\frac{c_r}{c_k} \\frac{N}{N^2} \\frac{\\rho}{\\rho^{-1}} \\frac{4\\pi/3}{4/(3\\pi^2)} \\frac{\\left( \\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right) \\right)^3}{\\left( \\ln\\left(\\frac{2}{\\varepsilon}\\right) \\right)^{3/2}}\n$$\n化简各项：\n$$\n\\frac{A}{B} = \\frac{c_r}{c_k} \\frac{\\rho^2}{N} \\pi^3 \\left( \\frac{\\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)}{\\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)}} \\right)^3\n$$\n取六次方根得到最优 Ewald 参数的最终表达式：\n$$\n\\alpha^\\star = \\left( \\frac{c_r}{c_k} \\frac{\\rho^2 \\pi^3}{N} \\right)^{1/6} \\left( \\frac{\\operatorname{erfcinv}\\left(\\frac{\\varepsilon}{2}\\right)}{\\sqrt{\\ln\\left(\\frac{2}{\\varepsilon}\\right)}} \\right)^{1/2}\n$$\n该方程被实现用于计算每个给定测试案例的 $\\alpha^\\star$ 值。数值计算需要评估逆互补误差函数，该函数在标准科学计算库中可用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfcinv\n\ndef solve():\n    \"\"\"\n    Calculates the optimal Ewald splitting parameter alpha* for a set of test cases\n    based on a simplified cost model for real and reciprocal space computations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (N, rho, epsilon, c_r, c_k)\n    test_cases = [\n        (1000.0, 1.0, 1e-4, 1.0, 1.0),\n        (8.0, 0.5, 1e-3, 1.0, 1.0),\n        (10000.0, 1.0, 1e-8, 1.0, 1.0),\n        (2000.0, 1.0, 1e-5, 2.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, rho, eps, cr, ck = case\n        \n        # The derived formula for the optimal alpha is:\n        # alpha_star = (cr/ck * rho^2 * pi^3 / N)^(1/6) * sqrt(erfcinv(eps/2) / sqrt(ln(2/eps)))\n\n        # Calculate the first term of the formula\n        term1_base = (cr / ck) * (rho**2 * np.pi**3) / N\n        term1 = term1_base**(1.0 / 6.0)\n        \n        # Calculate the second term of the formula\n        # X corresponds to erfcinv(epsilon / 2)\n        X = erfcinv(eps / 2.0)\n        # Y corresponds to sqrt(ln(2 / epsilon))\n        Y = np.sqrt(np.log(2.0 / eps))\n        term2 = np.sqrt(X / Y)\n        \n        # Combine terms to get the final alpha_star\n        alpha_star = term1 * term2\n        \n        results.append(alpha_star)\n\n    # Format the output as a comma-separated list of floating-point numbers\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}