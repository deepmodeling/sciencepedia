{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在解决计算代码验证中的一个基本问题：如何将解析导数与数值导数进行核对。你将学习如何使用有限差分法来估算原子间作用力，并将其与 DFT 直接计算出的力进行比较。这项实践  强调了在截断误差（随位移减小）和舍入/数值不确定性（随位移增大）之间的权衡，让你亲身体会如何为数值微分选择一个最优的步长。",
            "id": "3739730",
            "problem": "您的目标是通过将从密度泛函理论 (DFT) 计算出的解析力与通过原子对称位移获得的有限差分估计值进行比较，来验证解析力的准确性。设总能量是单个笛卡尔坐标的函数，表示为 $E(R)$，其力为 $F(R) = -\\partial E/\\partial R$。假设 $E(R)$ 是光滑的，并且由于有限的自洽场 (SCF) 收敛容差和数值舍入，每次 DFT 能量评估都存在一个有效不确定性 $\\delta E$。考虑一个典型的共价模式，其曲率 $E''(R) \\approx 10\\,\\text{eV}/\\text{\\AA}^2$，特征长度尺度 $L \\approx 1\\,\\text{\\AA}$，因此 $|E'''(R)|$ 的量级为 $E''(R)/L$。对于充分收敛的 SCF 计算，取 $\\delta E \\approx 10^{-6}\\,\\text{eV}$。\n\n您将沿 $R$ 方向使用位移 $\\pm h$ 对总能量进行对称有限差分，以估计力的大小，并将其与 DFT 解析力进行比较。选择一个合适的量级 $h$，以平衡来自泰勒展开的截断误差和舍入/SCF 不确定性，并为光滑的 $E(R)$ 证明解析力与有限差分估计值之差随 $h$ 变化的预期标度关系。\n\n哪个选项最能满足这些标准？\n\nA. 选择 $h \\approx 0.01\\,\\text{\\AA}$，通过平衡一个随 $h^2$ 变化的截断项和一个随 $1/h$ 变化的舍入项，并使用 $|E'''(R)| \\sim E''(R)/L$。当 $\\delta E \\approx 10^{-6}\\,\\text{eV}$ 且 $|E'''(R)| \\sim 10\\,\\text{eV}/\\text{\\AA}^3$ 时，平衡得出 $h_{\\mathrm{opt}} \\sim \\left(3\\delta E/|E'''(R)|\\right)^{1/3}$，对于光滑的 $E(R)$，解析力与有限差分力之间的不匹配度随 $h^2$ 变化。\n\nB. 选择 $h \\approx 0.1\\,\\text{\\AA}$ 以使位移远大于任何舍入误差，并预期解析力与有限差分力之间的不匹配度随 $h$ 线性变化，因为 $E(R)$ 是光滑的。\n\nC. 选择 $h \\approx \\sqrt{\\epsilon_{\\mathrm{mach}}}\\,L \\sim 10^{-8}\\,\\text{\\AA}$，其中 $\\epsilon_{\\mathrm{mach}}$ 是机器精度，并预期对于光滑的 $E(R)$，不匹配度随 $h^4$ 变化。\n\nD. 通过令一个随 $h^2$ 变化的截断项等于一个随 $h$ 变化的舍入项来选择 $h$（得出 $h \\sim \\delta E/|E'''(R)|$），并预期对于光滑的 $E(R)$，不匹配度与 $h$ 无关。",
            "solution": "用户希望我验证一个关于密度泛函理论 (DFT) 中力的数值计算的问题陈述，然后解决它。\n\n### 问题验证\n\n首先，我将根据指定协议验证问题陈述。\n\n**步骤 1：提取已知条件**\n-   总能量是单个笛卡尔坐标的函数，$E(R)$。\n-   力定义为 $F(R) = -\\partial E/\\partial R$。\n-   假设函数 $E(R)$ 是光滑的。\n-   每次能量评估存在一个有效不确定性 $\\delta E$，其中 $\\delta E \\approx 10^{-6}\\,\\text{eV}$。\n-   对于一个典型的共价模式，曲率为 $E''(R) \\approx 10\\,\\text{eV}/\\text{\\AA}^2$。\n-   一个特征长度尺度为 $L \\approx 1\\,\\text{\\AA}$。\n-   能量的三阶导数估计为 $|E'''(R)| \\sim E''(R)/L$。\n-   力将使用位移为 $\\pm h$ 的对称有限差分格式进行估计。\n-   任务是选择一个合适的 $h$ 量级，以平衡截断误差和不确定性误差，并证明误差的标度关系。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题在数值分析和计算物理学原理方面有坚实的基础。通过有限差分估计来验证解析导数是量子化学和材料科学软件开发与验证中的一个标准且关键的程序。泰勒级数展开、截断误差和舍入/数值误差等概念是此过程的基础。为 $\\delta E$、$E''(R)$ 和 $L$ 提供的物理值对于分子或固态系统的 DFT 计算是切合实际的。\n-   **适定性**：该问题是适定的。它要求通过平衡两个相互竞争的误差源来推导最佳步长 $h$，这是数值微分中的一个经典问题。可以从第一性原理推导出一个唯一且有意义的解。\n-   **客观性**：该问题使用清晰、精确、客观的语言陈述。所有量都已定义，并且它们之间的关系也已指明。\n\n**结论与行动**\n问题陈述具有科学合理性、适定性和客观性。它没有违反任何无效标准。因此，该问题是**有效的**，我将继续进行解答。\n\n### 解答推导\n\n该问题要求我们分析使用对称有限差分近似计算力 $F(R)$ 时的误差。解析力为 $F_{\\text{analytic}}(R) = -E'(R)$，其中撇号表示对 $R$ 求导。\n\n$E(R)$ 一阶导数的对称（或中心）有限差分公式为：\n$$\nE'_{\\text{FD}}(R) = \\frac{E(R+h) - E(R-h)}{2h}\n$$\n因此，有限差分力为：\n$$\nF_{\\text{FD}}(R) = - \\frac{E(R+h) - E(R-h)}{2h}\n$$\n\n我们必须分析两个主要的误差来源：截断误差和舍入/不确定性误差。\n\n**1. 截断误差**\n\n截断误差源于用有限步长 $h$ 近似导数。我们可以通过围绕 $R$ 对 $E(R+h)$ 和 $E(R-h)$ 进行泰勒级数展开来量化此误差。由于 $E(R)$ 是光滑的，我们可以写出：\n$$\nE(R+h) = E(R) + E'(R)h + \\frac{1}{2}E''(R)h^2 + \\frac{1}{6}E'''(R)h^3 + \\frac{1}{24}E''''(R)h^4 + O(h^5)\n$$\n$$\nE(R-h) = E(R) - E'(R)h + \\frac{1}{2}E''(R)h^2 - \\frac{1}{6}E'''(R)h^3 + \\frac{1}{24}E''''(R)h^4 - O(h^5)\n$$\n用第一个展开式减去第二个展开式得到：\n$$\nE(R+h) - E(R-h) = 2E'(R)h + \\frac{1}{3}E'''(R)h^3 + O(h^5)\n$$\n将此代入 $F_{\\text{FD}}(R)$ 的表达式中：\n$$\nF_{\\text{FD}}(R) = - \\frac{2E'(R)h + \\frac{1}{3}E'''(R)h^3 + O(h^5)}{2h} = -E'(R) - \\frac{1}{6}E'''(R)h^2 - O(h^4)\n$$\n有限差分力与解析力 ($F_{\\text{analytic}}(R) = -E'(R)$) 之差即为截断误差 $\\varepsilon_{\\text{trunc}}$：\n$$\n\\varepsilon_{\\text{trunc}}(h) = F_{\\text{FD}}(R) - F_{\\text{analytic}}(R) = - \\frac{1}{6}E'''(R)h^2 - O(h^4)\n$$\n主阶截断误差的大小为 $|\\varepsilon_{\\text{trunc}}(h)| \\approx \\frac{1}{6}|E'''(R)|h^2$。此误差随 $h^2$ 变化。\n\n**2. 舍入/不确定性误差**\n\n每次计算的能量 $E_{\\text{comp}}$ 都有一个不确定性 $\\delta E$。计算出的能量为 $E_{\\text{comp}}(R+h) = E(R+h) + \\delta E_1$ 和 $E_{\\text{comp}}(R-h) = E(R-h) + \\delta E_2$，其中 $|\\delta E_1|, |\\delta E_2| \\le \\delta E$。由这种不确定性引起的有限差分力的误差 $\\varepsilon_{\\text{round}}$ 为：\n$$\n\\varepsilon_{\\text{round}}(h) = - \\frac{(E(R+h) + \\delta E_1) - (E(R-h) + \\delta E_2)}{2h} - F_{\\text{FD}}(R) = - \\frac{\\delta E_1 - \\delta E_2}{2h}\n$$\n此误差的最坏情况大小发生在各个误差相加造成最大影响时，即 $\\delta E_1 \\approx -\\delta E_2 \\approx \\delta E$。\n$$\n|\\varepsilon_{\\text{round}}(h)| \\le \\frac{|\\delta E_1| + |\\delta E_2|}{2h} \\approx \\frac{2\\delta E}{2h} = \\frac{\\delta E}{h}\n$$\n此误差随 $1/h$ 变化。\n\n**3. 最佳步长**\n\n为了找到最佳步长 $h_{\\text{opt}}$，我们必须平衡截断误差（随 $h$ 减小而减小）和舍入误差（随 $h$ 减小而增大）。我们最小化总误差的大小 $|\\varepsilon_{\\text{total}}(h)|$，它约等于两个误差分量大小之和：\n$$\n|\\varepsilon_{\\text{total}}(h)| \\approx |\\varepsilon_{\\text{trunc}}(h)| + |\\varepsilon_{\\text{round}}(h)| = \\frac{1}{6}|E'''(R)|h^2 + \\frac{\\delta E}{h}\n$$\n为了找到最小值，我们对 $h$ 求导并令其结果为零：\n$$\n\\frac{d}{dh} |\\varepsilon_{\\text{total}}(h)| = \\frac{1}{3}|E'''(R)|h - \\frac{\\delta E}{h^2} = 0\n$$\n$$\n\\frac{1}{3}|E'''(R)|h = \\frac{\\delta E}{h^2} \\implies h^3 = \\frac{3\\delta E}{|E'''(R)|}\n$$\n$$\nh_{\\text{opt}} = \\left( \\frac{3\\delta E}{|E'''(R)|} \\right)^{1/3}\n$$\n\n现在，我们代入给定的数值：\n-   $\\delta E \\approx 10^{-6}\\,\\text{eV}$\n-   $|E'''(R)| \\sim E''(R)/L \\approx (10\\,\\text{eV}/\\text{\\AA}^2) / (1\\,\\text{\\AA}) = 10\\,\\text{eV}/\\text{\\AA}^3$\n\n将这些值代入 $h_{\\text{opt}}$ 的表达式中：\n$$\nh_{\\text{opt}} \\approx \\left( \\frac{3 \\times 10^{-6}\\,\\text{eV}}{10\\,\\text{eV}/\\text{\\AA}^3} \\right)^{1/3} = (3 \\times 10^{-7}\\,\\text{\\AA}^3)^{1/3} = (0.3 \\times 10^{-6}\\,\\text{\\AA}^3)^{1/3}\n$$\n$$\nh_{\\text{opt}} \\approx (0.3)^{1/3} \\times 10^{-2}\\,\\text{\\AA}\n$$\n由于 $(0.6)^3 = 0.216$ 且 $(0.7)^3 = 0.343$，我们有 $(0.3)^{1/3} \\approx 0.67$。\n$$\nh_{\\text{opt}} \\approx 0.67 \\times 10^{-2}\\,\\text{\\AA} = 0.0067\\,\\text{\\AA}\n$$\n该值的数量级为 $0.01\\,\\text{\\AA}$。\n\n在没有舍入误差的情况下，“解析力与有限差分力之间的不匹配度” 正是截断误差，我们已经证明对于光滑函数和对称差分格式，该误差随 $h^2$ 变化。\n\n### 逐项分析\n\n**A. 选择 $h \\approx 0.01\\,\\text{\\AA}$，通过平衡一个随 $h^2$ 变化的截断项和一个随 $1/h$ 变化的舍入项，并使用 $|E'''(R)| \\sim E''(R)/L$。当 $\\delta E \\approx 10^{-6}\\,\\text{eV}$ 且 $|E'''(R)| \\sim 10\\,\\text{eV}/\\text{\\AA}^3$ 时，平衡得出 $h_{\\mathrm{opt}} \\sim \\left(3\\delta E/|E'''(R)|\\right)^{1/3}$，对于光滑的 $E(R)$，解析力与有限差分力之间的不匹配度随 $h^2$ 变化。**\n\n-   **$h$ 的选择**：我们计算出的 $h_{\\mathrm{opt}} \\approx 0.0067\\,\\text{\\AA}$，确实约为 $0.01\\,\\text{\\AA}$。\n-   **误差平衡**：该选项正确地指出，平衡是在随 $h^2$ 变化的截断误差和随 $1/h$ 变化的舍入误差之间进行的。\n-   **最佳 $h$ 公式**：公式 $h_{\\mathrm{opt}} \\sim (3\\delta E/|E'''(R)|)^{1/3}$ 正是我们推导出的结果。系数 3 是由误差项中的常数和微分得出的，不像一些更简单的数量级估计可能会忽略它。\n-   **不匹配度标度关系**：不匹配度随 $h^2$ 变化的说法是正确的，因为这对应于对称差分格式截断误差的主导项。\n-   **结论**：**正确**。该选项准确描述了分析的各个方面：误差的标度关系、最佳步长的推导、$h$ 的数值估计以及截断误差的标度关系。\n\n**B. 选择 $h \\approx 0.1\\,\\text{\\AA}$ 以使位移远大于任何舍入误差，并预期解析力与有限差分力之间的不匹配度随 $h$ 线性变化，因为 $E(R)$ 是光滑的。**\n\n-   **$h$ 的选择**：该值比最佳 $h$ 大一个数量级。当 $h=0.1\\,\\text{\\AA}$ 时，截断误差（$\\propto h^2$）将远大于舍入误差（$\\propto 1/h$），因此这不是一个平衡的选择。\n-   **不匹配度标度关系**：误差随 $h$ 线性变化的论断是不正确的。对于光滑函数的对称有限差分，主阶截断误差随 $h^2$ 变化。线性标度关系是单边（前向或后向）差分格式的特征。\n-   **结论**：**不正确**。\n\n**C. 选择 $h \\approx \\sqrt{\\epsilon_{\\mathrm{mach}}}\\,L \\sim 10^{-8}\\,\\text{\\AA}$，其中 $\\epsilon_{\\mathrm{mach}}$ 是机器精度，并预期对于光滑的 $E(R)$，不匹配度随 $h^4$ 变化。**\n\n-   **$h$ 的选择**：这种方法有缺陷。不确定性的主要来源是 SCF 收敛容差 $\\delta E \\approx 10^{-6}\\,\\text{eV}$，它比与机器精度 $\\epsilon_{\\text{mach}}$（对于双精度通常为 $\\sim 10^{-16}$）相关的误差大许多数量级。$h$ 的选择必须基于 $\\delta E$，而不是 $\\epsilon_{\\text{mach}}$。步长 $h \\sim 10^{-8}\\,\\text{\\AA}$ 会导致灾难性的舍入误差，因为 $|\\varepsilon_{\\text{round}}| \\approx 10^{-6}/10^{-8} = 100\\,\\text{eV}/\\text{\\AA}$。\n-   **不匹配度标度关系**：误差随 $h^4$ 变化的论断是不正确的。$h^4$ 的标度关系需要更高阶的有限差分公式（例如，五点模板），而不是所描述的简单对称差分。\n-   **结论**：**不正确**。\n\n**D. 通过令一个随 $h^2$ 变化的截断项等于一个随 $h$ 变化的舍入项来选择 $h$（得出 $h \\sim \\delta E/|E'''(R)|$），并预期对于光滑的 $E(R)$，不匹配度与 $h$ 无关。**\n\n-   **误差平衡**：此选项错误地指出舍入误差随 $h$ 变化。正如我们推导的，它随 $1/h$ 变化。这是分析中的一个根本性错误。\n-   **最佳 $h$ 公式**：由于不正确的标度关系，推导 $h$ 的整个前提都是错误的。\n-   **不匹配度标度关系**：不匹配度与 $h$ 无关的论断也是不正确的。截断误差是 $h$ 的函数，具体来说随 $h^2$ 变化。\n-   **结论**：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在代码实现得到验证后，实践中要获得准确的结果就需要进行仔细的收敛性测试。本练习  介绍了一种系统性方法，用于厘清周期性固体的 DFT 计算中的主要误差来源：基组不完备性（Pulay 误差）、布里渊区采样（k 点误差）和不完全的自洽性。通过执行受控的参数扫描，你将学会对每种误差贡献进行建模和量化，这是任何严谨的计算研究都必须掌握的关键技能。",
            "id": "3739734",
            "problem": "要求您设计并实现一个有原则的、程序化的收敛性测试，以在使用原子中心基组计算的周期性固体中，将基组不完备性导致的 Pulay 力误差与布里渊区采样（k 点）误差和自洽残余误差分离开来。基本背景是密度泛函理论 (DFT)，其中总 Born–Oppenheimer 能量取决于电子密度和原子核位置，而力是通过该能量对原子坐标的负梯度得到的。\n\n从基本原理出发：\n- Born–Oppenheimer 能量泛函为 $E[n; \\{\\mathbf{R}_I\\}]$，其中 $n(\\mathbf{r})$ 是电子密度，$\\{\\mathbf{R}_I\\}$ 是原子核坐标。\n- 沿 $\\alpha$ 方向作用于原子 $I$ 的力是 $F_{I,\\alpha} = -\\frac{\\partial E[n; \\{\\mathbf{R}_I\\}]}{\\partial R_{I,\\alpha}}$，在密度泛函理论 (DFT) 的 Kohn–Sham 方程的稳态解处进行求值。\n- Hellmann–Feynman 定理给出了在基组完备且电子态完全收敛时的力。对于依赖于 $\\{\\mathbf{R}_I\\}$ 的原子中心基组，由于基组对位置的依赖性，力的表达式中会出现额外的项（通常称为 Pulay 项）。在周期性固体中，布里渊区积分通过有限数量的 $k$ 点进行近似，而不完全的自洽会引入残余误差。\n- 在收敛性分析中，可以独立地改变：基组大小（控制 Pulay 误差）、$k$ 点数量（控制采样误差）和自洽容差（控制残余误差）。通过将其中两个参数保持在接近收敛的极限值，同时改变第三个参数，可以分离出力的误差对该第三个参数的主导依赖关系。这种分离依赖于这样一个假设：在主导阶上，这三个误差源是可加的，并且每个误差源都对其自身的参数呈单调关系。\n\n我们为您提供了在三次独立的参数扫描下，对单个原子分力 $F$ 进行的合成但科学上一致的测量力，单位为电子伏特每埃 (eV/Å)。每次扫描都在另外两个参数保持在接近收敛值的情况下进行。您的任务是使用这些扫描来估计控制每个误差源的主导系数，然后，对于几个通用参数设置，计算 Pulay 误差、k 点误差和自洽贡献在总力误差中的分离大小（单位为 eV/Å）。您必须设计一种源自上述原理的方法：从力作为泛函导数的定义出发，从基组依赖性中识别出 Pulay 项，并使用受控的参数扫描来分离和拟合每个误差源的主导标度行为；不要依赖于预先指定完整力表达式的目标公式。\n\n所有角度（如果出现）必须以弧度处理，但本任务仅使用线性力。\n\n使用以下数据。每个数字都是测量的力，单位为 eV/Å。所有参数都是为一个沿坐标轴的分力 $F$ 定义的，力的单位是 eV/Å。\n\n参考的近收敛配置：\n- 基组大小 $S_{\\mathrm{ref}} = 240$，k 点数量 $N_{k,\\mathrm{ref}} = 40$，自洽容差 $t_{\\mathrm{ref}} = 10^{-7}$，测量的力 $F_{\\mathrm{ref}} = -0.479999968$。\n\n基组扫描（固定 $N_k = 40$ 和 $t = 10^{-7}$，改变 $S$）：\n- $S = 60$， $F = -0.467999968$。\n- $S = 120$， $F = -0.475999968$。\n- $S = 240$， $F = -0.479999968$。\n\nK 点扫描（固定 $S = 240$ 和 $t = 10^{-7}$，改变 $N_k$）：\n- $N_k = 10$， $F = -0.431999968$。\n- $N_k = 20$， $F = -0.463999968$。\n- $N_k = 40$， $F = -0.479999968$。\n\n自洽扫描（固定 $S = 240$ 和 $N_k = 40$，改变 $t$）：\n- $t = 10^{-3}$， $F = -0.47968$。\n- $t = 10^{-5}$， $F = -0.4799968$。\n- $t = 10^{-7}$， $F = -0.479999968$。\n\n对于以下四个通用测试案例，您必须计算每个案例中分离出的误差大小：Pulay 分量、k 点分量和自洽分量，均以 eV/Å 为单位。请以浮点数形式呈现您的答案。测试案例如下：\n\n- 测试案例 1：$S = 120$，$N_k = 20$，$t = 10^{-5}$，测量的力 $F = -0.4599968$。\n- 测试案例 2：$S = 240$，$N_k = 40$，$t = 10^{-7}$，测量的力 $F = -0.479999968$。\n- 测试案例 3：$S = 240$，$N_k = 10$，$t = 10^{-7}$，测量的力 $F = -0.431999968$。\n- 测试案例 4：$S = 60$，$N_k = 40$，$t = 10^{-7}$，测量的力 $F = -0.467999968$。\n\n您的程序必须：\n- 使用三次扫描，基于从上述原理推导出的收敛性测试，通过受控扫描分离每个依赖关系并拟合其自身参数的主导单调标度行为，来估计控制每个误差源的主导系数。\n- 根据这些估计和提供的近收敛参考值，估计底层的收敛力 $F^\\star$，然后计算每个测试案例的 Pulay、k 点和自洽误差的大小。\n- 将每个测试案例的所有三个误差大小以 eV/Å 为单位表示，并四舍五入到 $9$ 位小数。\n- 输出单行内容，包含一个用方括号括起来的逗号分隔列表，其中测试案例 1 的浮点数三元组后跟着测试案例 2 的三元组，然后是测试案例 3 和测试案例 4。例如，格式为 $[e_{P,1},e_{k,1},e_{s,1},e_{P,2},e_{k,2},e_{s,2},e_{P,3},e_{k,3},e_{s,3},e_{P,4},e_{k,4},e_{s,4}]$。\n\n您的程序必须是自包含的，不需要用户输入，并产生确切所需的单行输出。所有报告的大小都必须以 eV/Å 为单位。",
            "solution": "该问题要求设计并实现一种方法，用于分离密度泛函理论 (DFT) 对周期性固体进行力计算时的三种主要误差来源：基组不完备性 (Pulay) 误差、布里渊区采样 ($k$ 点) 误差和自洽残余误差。该解决方案必须从基本原理推导，并应用于提供的合成数据。\n\n**1. 理论阐述与误差建模**\n\n总 Born-Oppenheimer 能量 $E$ 是电子密度 $n(\\mathbf{r})$ 的泛函，也是原子核坐标 $\\{\\mathbf{R}_I\\}$ 的函数。作用于原子 $I$、方向为 $\\alpha$ 的力由全导数给出：\n$$\nF_{I,\\alpha} = -\\frac{d E}{d R_{I,\\alpha}}\n$$\n在实际使用原子中心基组的 DFT 计算中，存在多种误差源，导致计算出的力 $F$ 与真实的、完全收敛的力 $F^\\star$（即在无限基组、无限密集 $k$ 点网格和完美自洽条件下获得的力）不符。我们假设，对于足够小的误差，计算出的力与真实力之间的总偏差是每个误差源的主导误差贡献的加和。\n\n令 $S$ 为基组大小，$N_k$ 为 $k$ 点数量，$t$ 为自洽收敛容差。计算出的力可以表示为：\n$$\nF(S, N_k, t) \\approx F^\\star + \\Delta F_{\\text{Pulay}}(S) + \\Delta F_{k}(N_k) + \\Delta F_{\\text{scf}}(t)\n$$\n其中 $F^\\star$ 是在极限 $S \\to \\infty$、$N_k \\to \\infty$ 和 $t \\to 0$ 下的精确力。$\\Delta F$ 项代表来自每个来源的误差。为了继续，我们必须基于 DFT 算法的数值分析，为这些误差项建立具有物理动机的函数形式。\n\n- **基组不完备性 (Pulay) 误差**：由于不完备的原子中心基组（这导致了 Pulay 力）所引起的误差，通常随着基组大小 $S$ 的增加而减小。对此收敛性的一个标准且简单的模型是逆幂律。我们假设一个主导阶的依赖关系：\n  $$ \\Delta F_{\\text{Pulay}}(S) = \\frac{C_S}{S} $$\n  其中 $C_S$ 是一个常系数。\n\n- **布里渊区采样 ($k$ 点) 误差**：通过对有限数量 $k$ 点（$N_k$）的离散求和来近似布里渊区积分所产生的误差，通常也遵循逆幂律。我们将其建模为：\n  $$ \\Delta F_{k}(N_k) = \\frac{C_k}{N_k} $$\n  其中 $C_k$ 是一个常系数。\n\n- **自洽 (SCF) 残余误差**：由于在有限容差 $t$（例如，能量或密度的容差）处终止自洽场 (SCF) 循环而导致的力误差，对于小的 $t$，通常预期与容差本身成正比。因此，我们将此误差建模为：\n  $$ \\Delta F_{\\text{scf}}(t) = C_t \\cdot t $$\n  其中 $C_t$ 是一个比例常数。\n\n结合这些项，我们对计算力的综合模型是：\n$$\nF(S, N_k, t) = F^\\star + \\frac{C_S}{S} + \\frac{C_k}{N_k} + C_t \\cdot t\n$$\n我们的任务是确定四个未知参数：系数 $C_S$、$C_k$、$C_t$ 和真实力 $F^\\star$。\n\n**2. 通过受控扫描确定参数**\n\n问题提供了来自三个参数扫描的数据，其中一个参数在变化，而另外两个参数保持在接近收敛的值（$S_{\\mathrm{ref}}=240$，$N_{k,\\mathrm{ref}}=40$，$t_{\\mathrm{ref}}=10^{-7}$）。这种实验设计允许分离和拟合每个系数。\n\n**a. 基组扫描（$S$ 变化，$N_k=40$，$t=10^{-7}$）：**\n在此扫描中，力由 $F(S) = \\left( F^\\star + \\frac{C_k}{N_{k,\\mathrm{ref}}} + C_t \\cdot t_{\\mathrm{ref}} \\right) + \\frac{C_S}{S}$ 给出。这是 $F$ 和 $x_S = 1/S$ 之间的线性关系。这条线的斜率是 $C_S$。\n数据点为 $(S, F)$：$(60, -0.467999968)$、$(120, -0.475999968)$ 和 $(240, -0.479999968)$。\n就 $(1/S, F)$ 而言，它们是 $(1/60, -0.467999968)$、$(1/120, -0.475999968)$ 和 $(1/240, -0.479999968)$。\n对 $F$ versus $1/S$ 进行线性拟合，得到斜率：\n$$\nC_S = \\frac{-0.479999968 - (-0.467999968)}{1/240 - 1/60} = \\frac{-0.012}{-0.0125} = 0.96\n$$\n\n**b. K 点扫描（$N_k$ 变化，$S=240$，$t=10^{-7}$）：**\n在这里，力为 $F(N_k) = \\left( F^\\star + \\frac{C_S}{S_{\\mathrm{ref}}} + C_t \\cdot t_{\\mathrm{ref}} \\right) + \\frac{C_k}{N_k}$。这是 $F$ 和 $x_k = 1/N_k$ 之间的线性关系。斜率给出了 $C_k$。\n数据点为 $(N_k, F)$：$(10, -0.431999968)$、$(20, -0.463999968)$ 和 $(40, -0.479999968)$。\n就 $(1/N_k, F)$ 而言，它们是 $(1/10, -0.431999968)$、$(1/20, -0.463999968)$ 和 $(1/40, -0.479999968)$。\n对 $F$ versus $1/N_k$ 进行线性拟合，得到斜率：\n$$\nC_k = \\frac{-0.479999968 - (-0.431999968)}{1/40 - 1/10} = \\frac{-0.048}{-0.075} = 0.64\n$$\n\n**c. 自洽扫描（$t$ 变化，$S=240$，$N_k=40$）：**\n在这里，力为 $F(t) = \\left( F^\\star + \\frac{C_S}{S_{\\mathrm{ref}}} + \\frac{C_k}{N_{k,\\mathrm{ref}}} \\right) + C_t \\cdot t$。这是 $F$ 和 $x_t=t$ 之间的线性关系，斜率为 $C_t$。\n数据点为 $(t, F)$：$(10^{-3}, -0.47968)$、$(10^{-5}, -0.4799968)$ 和 $(10^{-7}, -0.479999968)$。\n对 $F$ versus $t$ 进行线性拟合，得到斜率：\n$$\nC_t = \\frac{-0.479999968 - (-0.47968)}{10^{-7} - 10^{-3}} \\approx \\frac{-0.000319968}{-0.0009999} \\approx 0.32\n$$\n\n**3. 确定完全收敛的力 $F^\\star$**\n\n确定系数后，我们可以使用任何数据点找到真实力 $F^\\star$。最可靠的点是参考配置本身（$S=240, N_k=40, t=10^{-7}, F=-0.479999968$），因为它对所有扫描都是共同的。\n$$\nF(240, 40, 10^{-7}) = F^\\star + \\frac{0.96}{240} + \\frac{0.64}{40} + 0.32 \\cdot 10^{-7}\n$$\n$$\n-0.479999968 = F^\\star + 0.004 + 0.016 + 0.000000032\n$$\n$$\n-0.479999968 = F^\\star + 0.020000032\n$$\n求解 $F^\\star$：\n$$\nF^\\star = -0.479999968 - 0.020000032 = -0.5\n$$\n完全收敛的力估计为 $F^\\star = -0.5$ eV/Å。\n\n**4. 计算测试案例的误差大小**\n\n给定参数集 $(S, N_k, t)$ 的每个误差分量的大小由相应误差项的绝对值给出。由于所有系数都是正的，它们是：\n- Pulay 误差大小：$e_P(S) = |\\Delta F_{\\text{Pulay}}(S)| = \\frac{0.96}{S}$\n- K 点误差大小：$e_k(N_k) = |\\Delta F_{k}(N_k)| = \\frac{0.64}{N_k}$\n- SCF 误差大小：$e_s(t) = |\\Delta F_{\\text{scf}}(t)| = 0.32 \\cdot t$\n\n我们将这些公式应用于四个测试案例。\n\n- **测试案例 1**：$S = 120, N_k = 20, t = 10^{-5}$\n  $e_P = 0.96/120 = 0.008$ eV/Å\n  $e_k = 0.64/20 = 0.032$ eV/Å\n  $e_s = 0.32 \\times 10^{-5} = 0.0000032$ eV/Å\n\n- **测试案例 2**：$S = 240, N_k = 40, t = 10^{-7}$\n  $e_P = 0.96/240 = 0.004$ eV/Å\n  $e_k = 0.64/40 = 0.016$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n- **测试案例 3**：$S = 240, N_k = 10, t = 10^{-7}$\n  $e_P = 0.96/240 = 0.004$ eV/Å\n  $e_k = 0.64/10 = 0.064$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n- **测试案例 4**：$S = 60, N_k = 40, t = 10^{-7}$\n  $e_P = 0.96/60 = 0.016$ eV/Å\n  $e_k = 0.64/40 = 0.016$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n这些值四舍五入到 $9$ 位小数后将构成最终输出。对每个测试案例（包括初始拟合中未使用的案例）的总力的成功预测，验证了加性误差模型和导出的系数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of separating DFT force error components.\n    \n    The method is as follows:\n    1.  Assume the total force F is a sum of the true force F* and additive\n        error contributions from basis size (S), k-points (Nk), and SCF\n        tolerance (t): F = F* + C_S/S + C_k/Nk + C_t*t.\n    2.  Use the provided parameter sweeps to find the coefficients C_S, C_k,\n        and C_t via linear regression. For example, in the S-sweep, F is a\n        linear function of 1/S, and the slope is C_S.\n    3.  Calculate the true force F* using the reference configuration and the\n        determined coefficients.\n    4.  For each test case, calculate the magnitude of each error component\n        using the derived formulas: e_P = |C_S/S|, e_k = |C_k/Nk|, e_s = |C_t*t|.\n    5.  Format and print the results as required.\n    \"\"\"\n\n    # --- Data from the problem statement ---\n\n    # Reference configuration\n    S_ref, Nk_ref, t_ref = 240, 40, 1e-7\n    F_ref = -0.479999968\n\n    # Basis sweep data (vary S)\n    basis_sweep = {\n        60: -0.467999968,\n        120: -0.475999968,\n        240: -0.479999968,\n    }\n\n    # K-point sweep data (vary Nk)\n    kpoint_sweep = {\n        10: -0.431999968,\n        20: -0.463999968,\n        40: -0.479999968,\n    }\n\n    # Self-consistency sweep data (vary t)\n    scf_sweep = {\n        1e-3: -0.47968,\n        1e-5: -0.4799968,\n        1e-7: -0.479999968,\n    }\n\n    # Test cases for which to compute error components\n    test_cases = [\n        # (S, Nk, t, measured_F) - measured_F is for verification\n        (120, 20, 1e-5, -0.4599968),\n        (240, 40, 1e-7, -0.479999968),\n        (240, 10, 1e-7, -0.431999968),\n        (60, 40, 1e-7, -0.467999968),\n    ]\n\n    # --- Step 1: Determine error coefficients from sweeps ---\n\n    # Basis sweep: Fit F vs 1/S\n    s_vals = np.array(list(basis_sweep.keys()))\n    f_vals_s = np.array(list(basis_sweep.values()))\n    x_s = 1.0 / s_vals\n    # polyfit returns [slope, intercept] for deg=1\n    C_S, _ = np.polyfit(x_s, f_vals_s, 1)\n\n    # K-point sweep: Fit F vs 1/Nk\n    nk_vals = np.array(list(kpoint_sweep.keys()))\n    f_vals_nk = np.array(list(kpoint_sweep.values()))\n    x_nk = 1.0 / nk_vals\n    C_k, _ = np.polyfit(x_nk, f_vals_nk, 1)\n\n    # SCF sweep: Fit F vs t\n    t_vals = np.array(list(scf_sweep.keys()))\n    f_vals_t = np.array(list(scf_sweep.values()))\n    x_t = t_vals\n    C_t, _ = np.polyfit(x_t, f_vals_t, 1)\n\n    # --- Step 2: Calculate the fully converged force F_star ---\n    # This step is not strictly necessary for calculating error components but\n    # provides a complete model and allows for verification.\n    # F_star = F_ref - (C_S/S_ref + C_k/Nk_ref + C_t*t_ref)\n\n    # --- Step 3: Calculate error components for test cases ---\n\n    results = []\n    for case in test_cases:\n        S, Nk, t, _ = case\n\n        # Calculate the magnitude of each error component.\n        # Since all coefficients C are positive, we don't need abs().\n        e_pulay = C_S / S\n        e_kpoint = C_k / Nk\n        e_scf = C_t * t\n\n        results.extend([e_pulay, e_kpoint, e_scf])\n    \n    # --- Step 4: Format and print the final output ---\n    \n    # Format each result to 9 decimal places as a string\n    formatted_results = [f\"{r:.9f}\" for r in results]\n    \n    # Join into a single comma-separated string enclosed in brackets\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "具备了准确可靠地计算应力的能力后，我们便可以预测各种材料的性质。本练习  展示了如何超越线性弹性范围，以确定材料的高阶常数。你将把通过 DFT 计算的应力-应变数据拟合到一个从弹性能量展开式推导出的非线性模型，从而提取二阶和三阶弹性常数。",
            "id": "3739717",
            "problem": "要求您形式化并实现一种方法，通过在线性范围之外进行拟合，从密度泛函理论 (DFT) 的应力-应变数据中计算三阶弹性常数，并评估所施加的应变范围是否保持在弹性域内。推导和算法必须从第一性原理出发：弹性势能的定义以及应力与能量对应变的导数之间的关系。您不能假设或使用问题陈述中直接给出的任何捷径公式；相反，您必须在您的解法中从基本原理推导出相关函数形式。\n\n您将考虑一个单模态形变路径，其中单个小应变分量 $e$ 发生变化，而相应的柯西应力 $\\sigma$（单位为吉帕斯卡）通过 DFT 计算得出。从弹性势能密度对小应变张量的三阶展开式可知，单模态路径下的应力响应可以表示为一个以 $e$ 为变量的零截距多项式，其系数是二阶和三阶弹性常数的组合。您的任务是拟合这些应力-应变数据，以推断所选模态的有效二阶常数和有效三阶常数，然后根据下文定义的准则判断给定的应变范围是否是弹性的。\n\n弹性域判定规则：将拟合切线模量定义为从您的拟合模型中获得的 $d\\sigma/de$。如果以下两个条件都成立，则所提供应变范围内的响应被认为是弹性的：\n- 在整个测试区间内切线模量为正，即 $\\min\\{d\\sigma/de \\text{ 在最小应变处}, d\\sigma/de \\text{ 在最大应变处}\\} > 0$。\n- 平均相对拟合误差 $\\bar{r}$ 不大于预设阈值 $r_{\\max}$，其中\n$$\n\\bar{r} = \\frac{1}{N}\\sum_{i=1}^{N} \\frac{\\left|\\sigma^{\\text{fit}}(e_i) - \\sigma_i\\right|}{\\max\\left(|\\sigma_i|, s_0\\right)},\n$$\n其中 $N$ 是样本数，$\\sigma^{\\text{fit}}(e_i)$ 是样本 $i$ 处的拟合应力，$\\sigma_i$ 是给定的应力数据点，$s_0$ 是一个小的正数标度以避免除以零。使用 $r_{\\max} = 10^{-6}$ 和 $s_0 = 10^{-8}\\,\\mathrm{GPa}$。\n\n输出规格：\n- 对于每个测试用例，计算单模态路径的有效二阶弹性常数（单位为吉帕斯卡）和有效三阶弹性常数（单位为吉帕斯卡），四舍五入到 $3$ 位小数，以及根据上述规则得出的弹性域布尔值。\n- 您的程序应生成单行输出，其中包含测试套件的结果列表，该列表为逗号分隔且包含在方括号内，每个用例都表示为其自身的方括号列表。例如，对于三个用例，输出格式必须为\n$[\\,[c2_1,c3_1,\\text{boolean}_1],[c2_2,c3_2,\\text{boolean}_2],[c2_3,c3_3,\\text{boolean}_3]\\,]$\n其中 $c2_k$ 和 $c3_k$ 是浮点数（单位为吉帕斯卡），四舍五入到 $3$ 位小数，而 $\\text{boolean}_k$ 为 $True$ 或 $False$。\n\n物理单位：\n- 应力 $\\sigma$ 以 $\\mathrm{GPa}$ 为单位提供，并且必须以 $\\mathrm{GPa}$ 为单位处理和报告。\n- 应变 $e$ 是无量纲的。\n- 所有报告的弹性常数都必须以 $\\mathrm{GPa}$ 为单位表示，并四舍五入到 $3$ 位小数。\n\n测试套件：\n为以下三个 DFT 数据集提供解法。每个数据集由成对的 $\\{(e_i, \\sigma_i)\\}$ 组成，分别以应变和应力数组的形式列出。\n\n- 用例 $1$（中等正应变，切线模量递减但在范围内仍为正）：\n  - 应变样本：$[\\,0.0,\\,0.002,\\,0.004,\\,0.006,\\,0.008,\\,0.010\\,]$\n  - 应力样本（单位 $\\mathrm{GPa}$）：$[\\,0.0,\\,0.398,\\,0.792,\\,1.182,\\,1.568,\\,1.950\\,]$\n\n- 用例 $2$（较大应变，切线模量在上界附近变为非正）：\n  - 应变样本：$[\\,0.0,\\,0.004,\\,0.008,\\,0.010,\\,0.012\\,]$\n  - 应力样本（单位 $\\mathrm{GPa}$）：$[\\,0.0,\\,0.480,\\,0.720,\\,0.750,\\,0.720\\,]$\n\n- 用例 $3$（对称小应变，包括压缩和拉伸，切线模量递增）：\n  - 应变样本：$[\\, -0.005,\\, -0.003,\\, -0.001,\\, 0.001,\\, 0.003,\\, 0.005\\, ]$\n  - 应力样本（单位 $\\mathrm{GPa}$）：$[\\, -0.34375,\\, -0.20775,\\, -0.06975,\\, 0.07025,\\, 0.21225,\\, 0.35625\\, ]$\n\n算法要求：\n- 拟合一个与三阶弹性理论一致的以 $e$ 为变量的零截距多项式。模型必须被约束为没有常数项；仅允许存在与 $e$ 和 $e^2$ 成正比的项。\n- 使用线性最小二乘法来确定系数。\n- 从第一性原理推导拟合系数如何映射到给定路径的有效二阶和三阶弹性常数。\n- 计算拟合切线模量 $d\\sigma/de$，并使用每个数据集中的最小和最大 $e$ 值，以及平均相对误差 $\\bar{r}$（其中 $r_{\\max} = 10^{-6}$ 和 $s_0 = 10^{-8}\\,\\mathrm{GPa}$），来评估弹性域判定规则。\n\n您的程序必须生成单行输出，其中包含结果，结果为逗号分隔的列表并包含在方括号内，每个用例表示为其自己的方括号列表，且无空格，例如：$[[c2_1,c3_1,boolean_1],[c2_2,c3_2,boolean_2],[c2_3,c3_3,boolean_3]]$。",
            "solution": "该问题是有效的。它在科学上基于连续介质弹性理论，作为一个线性最小二乘拟合问题被良好地提出，并且所有数据和准则都得到了客观和完整的规定。\n\n这个问题的核心是将应力-应变数据的多项式拟合系数与材料的弹性常数联系起来。这种关系必须从基本原理推导出来，即弹性势能密度的泰勒级数展开。\n\n令 $U$ 为材料的弹性势能密度。对于由单个应变参数 $e$ 描述的形变过程，能量密度可以围绕零应变状态 ($e=0$) 展开为泰勒级数：\n$$\nU(e) = U(0) + \\left.\\frac{\\partial U}{\\partial e}\\right|_{e=0} e + \\frac{1}{2!} \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0} e^2 + \\frac{1}{3!} \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0} e^3 + \\mathcal{O}(e^4)\n$$\n按照惯例，未形变状态的能量 $U(0)$ 设为 $0$。能量对应变的一阶导数是应力，因此 $\\left.\\frac{\\partial U}{\\partial e}\\right|_{e=0}$ 是参考状态下的应力，根据参考状态的定义，该应力也为零。因此，展开式简化为：\n$$\nU(e) = \\frac{1}{2} \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0} e^2 + \\frac{1}{6} \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0} e^3 + \\mathcal{O}(e^4)\n$$\n根据定义，在零应变下计算的能量密度的二阶和三阶导数是给定应变路径的有效二阶和三阶弹性常数。我们分别将它们表示为 $C_2^{\\text{eff}}$ 和 $C_3^{\\text{eff}}$。\n$$\nC_2^{\\text{eff}} \\equiv \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0}\n$$\n$$\nC_3^{\\text{eff}} \\equiv \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0}\n$$\n将这些定义代入能量展开式中，得到：\n$$\nU(e) = \\frac{1}{2} C_2^{\\text{eff}} e^2 + \\frac{1}{6} C_3^{\\text{eff}} e^3 + \\mathcal{O}(e^4)\n$$\n与应变分量 $e$ 共轭的柯西应力分量 $\\sigma$ 由能量密度对应变的导数给出：\n$$\n\\sigma(e) = \\frac{\\partial U(e)}{\\partial e}\n$$\n对能量展开式求导，我们得到应力-应变关系：\n$$\n\\sigma(e) = \\frac{\\partial}{\\partial e} \\left( \\frac{1}{2} C_2^{\\text{eff}} e^2 + \\frac{1}{6} C_3^{\\text{eff}} e^3 + \\mathcal{O}(e^4) \\right) = C_2^{\\text{eff}} e + \\frac{1}{2} C_3^{\\text{eff}} e^2 + \\mathcal{O}(e^3)\n$$\n这个推导表明，到三阶弹性理论，应力 $\\sigma$ 是应变 $e$ 的一个零截距二次函数。问题要求将 DFT 计算的应力-应变数据拟合到模型 $\\sigma^{\\text{fit}}(e) = a e + b e^2$。通过将我们推导出的关系式与此拟合模型的各项进行比较，我们建立了拟合系数（$a$，$b$）与物理弹性常数之间的映射关系：\n$$\na = C_2^{\\text{eff}}\n$$\n$$\nb = \\frac{1}{2} C_3^{\\text{eff}} \\implies C_3^{\\text{eff}} = 2b\n$$\n由于应变 $e$ 是无量纲的，$C_2^{\\text{eff}}$ 和 $C_3^{\\text{eff}}$ 的单位都将是应力单位，即 $\\mathrm{GPa}$。\n\n算法流程如下：\n1. 对于每组包含 $N$ 个数据对 $\\{(e_i, \\sigma_i)\\}$ 的数据集，我们建立一个线性系统来找到系数 $a$ 和 $b$，以最小化平方差之和 $\\sum_{i=1}^{N} (\\sigma_i - (a e_i + b e_i^2))^2$。这是一个线性最小二乘问题。我们可以将其写成矩阵形式 $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$，其中：\n    $$\n    \\mathbf{A} = \\begin{pmatrix} e_1  e_1^2 \\\\ e_2  e_2^2 \\\\ \\vdots  \\vdots \\\\ e_N  e_N^2 \\end{pmatrix}, \\quad\n    \\mathbf{x} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad\n    \\mathbf{y} = \\begin{pmatrix} \\sigma_1 \\\\ \\sigma_2 \\\\ \\vdots \\\\ \\sigma_N \\end{pmatrix}\n    $$\n    $\\mathbf{x}$ 的最小二乘解是 $(\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$。\n\n2. 一旦系数 $a$ 和 $b$ 被确定，我们就计算有效弹性常数：$C_2^{\\text{eff}} = a$ 和 $C_3^{\\text{eff}} = 2b$。\n\n3. 接下来，我们使用指定的两部分规则来评估应变范围是否在弹性域内。\n    a.  **切线模量的正性**：拟合的切线模量为 $d\\sigma^{\\text{fit}}/de = a + 2be$。我们必须验证在整个应变区间 $[e_{\\min}, e_{\\max}]$ 上 $d\\sigma^{\\text{fit}}/de > 0$。由于切线模量是 $e$ 的线性函数，其在区间上的最小值必定出现在某个端点上。因此，我们检查 $a + 2be_{\\min} > 0$ 和 $a + 2be_{\\max} > 0$ 是否成立。\n    b.  **平均相对拟合误差**：我们计算平均相对误差 $\\bar{r}$：\n        $$\n        \\bar{r} = \\frac{1}{N}\\sum_{i=1}^{N} \\frac{\\left|\\sigma^{\\text{fit}}(e_i) - \\sigma_i\\right|}{\\max\\left(|\\sigma_i|, s_0\\right)}\n        $$\n        其中 $\\sigma^{\\text{fit}}(e_i) = a e_i + b e_i^2$，$s_0 = 10^{-8}\\,\\mathrm{GPa}$，$N$ 是数据点的数量。该误差不得超过阈值 $r_{\\max} = 10^{-6}$。\n\n4. 关于该域是否为弹性的最终判定是这两个条件的逻辑与：$(\\text{模量正性}) \\land (\\bar{r} \\le r_{\\max})$。\n\n将此流程应用于所提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes effective second- and third-order elastic constants from stress-strain\n    data, and assesses if the strain range is elastic based on specified criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.0, 0.002, 0.004, 0.006, 0.008, 0.010]),\n            np.array([0.0, 0.398, 0.792, 1.182, 1.568, 1.950])\n        ),\n        (\n            np.array([0.0, 0.004, 0.008, 0.010, 0.012]),\n            np.array([0.0, 0.480, 0.720, 0.750, 0.720])\n        ),\n        (\n            np.array([-0.005, -0.003, -0.001, 0.001, 0.003, 0.005]),\n            np.array([-0.34375, -0.20775, -0.06975, 0.07025, 0.21225, 0.35625])\n        )\n    ]\n\n    r_max = 1e-6\n    s_0 = 1e-8\n\n    results = []\n    \n    for strain_samples, stress_samples in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # 1. Set up and solve the linear least-squares problem.\n        # The model is sigma = a*e + b*e^2.\n        # This is a linear system A*x = sigma, where x = [a, b]^T.\n        design_matrix_A = np.vstack([strain_samples, strain_samples**2]).T\n        \n        # Solve for coefficients [a, b]\n        coeffs, _, _, _ = np.linalg.lstsq(design_matrix_A, stress_samples, rcond=None)\n        a, b = coeffs\n        \n        # 2. Compute elastic constants from fitted coefficients.\n        # From derivation: c2_eff = a, c3_eff = 2*b.\n        c2_eff = a\n        c3_eff = 2 * b\n        \n        # 3. Apply the elastic-domain decision rule.\n        \n        # Condition 1: Positivity of the tangent modulus.\n        # Tangent modulus d(sigma)/de = a + 2*b*e.\n        # Check at the boundaries of the strain interval.\n        e_min, e_max = np.min(strain_samples), np.max(strain_samples)\n        tangent_modulus_at_emin = a + 2 * b * e_min\n        tangent_modulus_at_emax = a + 2 * b * e_max\n        is_modulus_positive = (tangent_modulus_at_emin > 0) and (tangent_modulus_at_emax > 0)\n        \n        # Condition 2: Mean relative fitting error.\n        sigma_fit = a * strain_samples + b * (strain_samples**2)\n        \n        # Denominator for relative error calculation, avoiding division by zero.\n        denominator = np.maximum(np.abs(stress_samples), s_0)\n        relative_errors = np.abs(sigma_fit - stress_samples) / denominator\n        mean_relative_error = np.mean(relative_errors)\n        \n        is_error_low = mean_relative_error = r_max\n        \n        # Combine both conditions for the final verdict.\n        is_elastic = is_modulus_positive and is_error_low\n        \n        # 4. Store the results rounded to 3 decimal places.\n        result_case = [round(c2_eff, 3), round(c3_eff, 3), is_elastic]\n        results.append(result_case)\n\n    # Final print statement in the exact required format.\n    # e.g. [[c2_1,c3_1,boolean_1],[c2_2,c3_2,boolean_2],[c2_3,c3_3,boolean_3]]\n    # str(list) adds spaces, so we remove them.\n    result_strings = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}