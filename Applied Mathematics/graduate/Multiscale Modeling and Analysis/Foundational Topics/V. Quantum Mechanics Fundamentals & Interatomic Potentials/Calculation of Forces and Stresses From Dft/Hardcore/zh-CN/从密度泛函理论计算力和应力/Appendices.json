{
    "hands_on_practices": [
        {
            "introduction": "DFT计算的可靠性是进行任何有意义的材料模拟的前提。为了获得精确的力和应力，我们必须仔细控制计算中的数值参数，并理解它们对结果的影响。本练习  将指导你通过系统性的收敛性测试，来分离和量化几种主要的误差来源：原子中心基组不完备性（Pulay误差）、布里渊区$k$点取样和自洽场（SCF）收敛不充分。掌握这种方法对于进行严谨的DFT计算和正确解读计算结果至关重要。",
            "id": "3739734",
            "problem": "您需要设计并实现一个有原则的、程序化的收敛性测试，以在使用原子中心基组计算的周期性固体中，区分基组不完备性导致的Pulay力误差、布里渊区采样（k点）误差以及自洽残差。基本背景是密度泛函理论（DFT），其中总Born–Oppenheimer能量取决于电子密度和原子核位置，而力是通过该能量对原子坐标的负梯度得到的。\n\n从基本原理出发：\n- Born–Oppenheimer能量泛函为 $E[n; \\{\\mathbf{R}_I\\}]$，其中 $n(\\mathbf{r})$ 是电子密度，$\\{\\mathbf{R}_I\\}$ 是原子核坐标。\n- 在密度泛函理论（DFT）的Kohn–Sham方程的稳态解处，原子 $I$ 在方向 $\\alpha$ 上的力为 $F_{I,\\alpha} = -\\frac{\\partial E[n; \\{\\mathbf{R}_I\\}]}{\\partial R_{I,\\alpha}}$。\n- 当基组完备且电子态完全收敛时，Hellmann–Feynman定理给出了力。对于依赖于 $\\{\\mathbf{R}_I\\}$ 的原子中心基组，由于基组对位置的依赖性，力中会出现额外的项（通常称为Pulay项）。在周期性固体中，布里渊区积分通过有限数量的 $k$ 点进行近似，而不完全的自洽会引入残差。\n- 在收敛性分析中，可以独立地改变：基组大小（控制Pulay误差）、$k$ 点数量（控制采样误差）和自洽收敛容限（控制残差）。通过将其中两个参数固定在接近收敛的极限值，同时改变第三个参数，可以分离出力的误差对该参数的主要依赖关系。这种分离依赖于一个假设，即三个误差源在主导阶上是可加的，并且每个误差源都对其自身的参数单调。\n\n我们为您提供了一系列合成但科学上一致的力的测量值，单位为电子伏特每埃（eV/Å），这些数据是针对单个原子分力 $F$ 在三次独立的参数扫描下得到的，每次扫描时，另外两个参数都保持在接近收敛的值。您的任务是利用这些扫描数据来估计主导每个误差源的主导系数，然后，针对几个通用参数设置，计算Pulay、k点和自洽对总力误差的贡献的大小，单位为eV/Å。您必须设计一个源自上述原理的方法：从力作为泛函导数的定义出发，从基组依赖性中识别出Pulay项，并使用受控的参数扫描来分离和拟合每个误差源的主导标度关系；不要依赖于预先指定的全力的完整表达式公式。\n\n所有角度（如果出现）都必须以弧度处理，但本任务仅使用线性力。\n\n使用以下数据。每个数字都是测得的力，单位为eV/Å。所有参数都是为一个沿坐标轴的分力 $F$ 定义的，力的单位是eV/Å。\n\n参考近收敛配置：\n- 基组大小 $S_{\\mathrm{ref}} = 240$，k点数 $N_{k,\\mathrm{ref}} = 40$，自洽收敛容限 $t_{\\mathrm{ref}} = 10^{-7}$，测得的力 $F_{\\mathrm{ref}} = -0.479999968$。\n\n基组扫描（改变 $S$，固定 $N_k = 40$ 和 $t = 10^{-7}$）：\n- $S = 60$, $F = -0.467999968$。\n- $S = 120$, $F = -0.475999968$。\n- $S = 240$, $F = -0.479999968$。\n\nK点扫描（改变 $N_k$，固定 $S = 240$ 和 $t = 10^{-7}$）：\n- $N_k = 10$, $F = -0.431999968$。\n- $N_k = 20$, $F = -0.463999968$。\n- $N_k = 40$, $F = -0.479999968$。\n\n自洽扫描（改变 $t$，固定 $S = 240$ 和 $N_k = 40$）：\n- $t = 10^{-3}$, $F = -0.47968$。\n- $t = 10^{-5}$, $F = -0.4799968$。\n- $t = 10^{-7}$, $F = -0.479999968$。\n\n对于以下四个通用测试用例，您必须为每个用例计算分离出的误差大小：Pulay分量、k点分量和自洽分量，均以eV/Å为单位。请以浮点数形式给出您的答案。测试用例如下：\n\n- 测试用例 1：$S = 120$, $N_k = 20$, $t = 10^{-5}$，测得的力 $F = -0.4599968$。\n- 测试用例 2：$S = 240$, $N_k = 40$, $t = 10^{-7}$，测得的力 $F = -0.479999968$。\n- 测试用例 3：$S = 240$, $N_k = 10$, $t = 10^{-7}$，测得的力 $F = -0.431999968$。\n- 测试用例 4：$S = 60$, $N_k = 40$, $t = 10^{-7}$，测得的力 $F = -0.467999968$。\n\n您的程序必须：\n- 基于上述原理，使用三次扫描来估计主导每个误差源的主导系数，通过受控扫描分离每个依赖关系并拟合其主导的单调标度关系。\n- 根据这些估计和提供的近收敛参考值，估算底层的收敛力 $F^\\star$，然后为每个测试用例计算Pulay、k点和自洽误差的大小。\n- 以eV/Å为单位表示每个测试用例的所有三个误差大小，四舍五入到9位小数。\n- 输出单行，包含一个用方括号括起来的逗号分隔列表，其中测试用例1的浮点数三元组后跟着测试用例2的三元组，然后是测试用例3和4的三元组。例如，格式为 $[e_{P,1},e_{k,1},e_{s,1},e_{P,2},e_{k,2},e_{s,2},e_{P,3},e_{k,3},e_{s,3},e_{P,4},e_{k,4},e_{s,4}]$。\n\n您的程序必须是自包含的，不需要用户输入，并产生确切所需的单行输出。所有报告的大小必须以eV/Å为单位。",
            "solution": "该问题要求设计并实现一种方法，以分离周期性固体密度泛函理论（DFT）力计算中的三种主要误差源：基组不完备性（Pulay）误差、布里渊区采样（$k$点）误差和自洽残差。解决方案必须源自基本原理，并应用于提供的合成数据。\n\n**1. 理论公式与误差建模**\n\n总Born-Oppenheimer能量 $E$ 是电子密度 $n(\\mathbf{r})$ 的泛函，也是原子核坐标 $\\{\\mathbf{R}_I\\}$ 的函数。原子 $I$ 在方向 $\\alpha$ 上的力由全导数给出：\n$$\nF_{I,\\alpha} = -\\frac{d E}{d R_{I,\\alpha}}\n$$\n在采用原子中心基组的实际DFT计算中，存在多种误差源，导致计算出的力 $F$ 与完全收敛的真实力 $F^\\star$（在无限基组、无限密集k点网格和完美自洽下获得）不符。我们假设，对于足够小的误差，计算出的力与真实力之间的总偏差是来自每个误差源的主导误差贡献的加和。\n\n设 $S$ 为基组大小，$N_k$ 为 $k$ 点数量，$t$ 为自洽收敛容限。计算出的力可以表示为：\n$$\nF(S, N_k, t) \\approx F^\\star + \\Delta F_{\\text{Pulay}}(S) + \\Delta F_{k}(N_k) + \\Delta F_{\\text{scf}}(t)\n$$\n其中 $F^\\star$ 是在极限 $S \\to \\infty$、$N_k \\to \\infty$ 和 $t \\to 0$ 下的精确力。$\\Delta F$ 项代表来自各种来源的误差。为了继续，我们必须基于DFT算法的数值分析，为这些误差项建立符合物理动机的函数形式。\n\n- **基组不完备性（Pulay）误差**：由不完备的原子中心基组引起的误差，这导致了Pulay力，通常随着基组大小 $S$ 的增加而减小。一个标准且简单的收敛模型是反比幂定律。我们假设其主导阶依赖关系为：\n  $$ \\Delta F_{\\text{Pulay}}(S) = \\frac{C_S}{S} $$\n  其中 $C_S$ 是一个常数系数。\n\n- **布里渊区采样（$k$点）误差**：用有限数量的 $k$ 点 $N_k$ 上的离散和来近似布里渊区积分所产生的误差，通常也遵循反比幂定律。我们将其建模为：\n  $$ \\Delta F_{k}(N_k) = \\frac{C_k}{N_k} $$\n  其中 $C_k$ 是一个常数系数。\n\n- **自洽（SCF）残差**：由于在有限容限 $t$（例如，对能量或密度）处终止自洽场（SCF）循环而产生的力误差，对于小的 $t$ 值，通常预期与容限本身成正比。因此，我们将此误差建模为：\n  $$ \\Delta F_{\\text{scf}}(t) = C_t \\cdot t $$\n  其中 $C_t$ 是一个比例常数。\n\n结合这些项，我们计算力的综合模型是：\n$$\nF(S, N_k, t) = F^\\star + \\frac{C_S}{S} + \\frac{C_k}{N_k} + C_t \\cdot t\n$$\n我们的任务是确定四个未知参数：系数 $C_S$、$C_k$、$C_t$ 和真实力 $F^\\star$。\n\n**2. 从受控扫描中确定参数**\n\n问题提供了来自三个参数扫描的数据，其中一个参数在变化，而另外两个参数则固定在接近收敛的值（$S_{\\mathrm{ref}}=240$, $N_{k,\\mathrm{ref}}=40$, $t_{\\mathrm{ref}}=10^{-7}$）。这种实验设计允许我们分离并拟合每个系数。\n\n**a. 基组扫描（$S$ 变化，$N_k=40$, $t=10^{-7}$）：**\n在此扫描中，力由 $F(S) = \\left( F^\\star + \\frac{C_k}{N_{k,\\mathrm{ref}}} + C_t \\cdot t_{\\mathrm{ref}} \\right) + \\frac{C_S}{S}$ 给出。这是 $F$ 和 $x_S = 1/S$ 之间的线性关系。这条线的斜率是 $C_S$。\n数据点为 $(S, F)$: $(60, -0.467999968)$, $(120, -0.475999968)$, 和 $(240, -0.479999968)$。\n以 $(1/S, F)$ 表示，这些点是 $(1/60, -0.467999968)$, $(1/120, -0.475999968)$, 和 $(1/240, -0.479999968)$。\n对 $F$ 与 $1/S$ 进行线性拟合，得到斜率：\n$$\nC_S = \\frac{-0.479999968 - (-0.467999968)}{1/240 - 1/60} = \\frac{-0.012}{-0.0125} = 0.96\n$$\n\n**b. K点扫描（$N_k$ 变化，$S=240$, $t=10^{-7}$）：**\n此处，力为 $F(N_k) = \\left( F^\\star + \\frac{C_S}{S_{\\mathrm{ref}}} + C_t \\cdot t_{\\mathrm{ref}} \\right) + \\frac{C_k}{N_k}$。这是 $F$ 和 $x_k = 1/N_k$ 之间的线性关系。斜率给出 $C_k$。\n数据点为 $(N_k, F)$: $(10, -0.431999968)$, $(20, -0.463999968)$, 和 $(40, -0.479999968)$。\n以 $(1/N_k, F)$ 表示，这些点是 $(1/10, -0.431999968)$, $(1/20, -0.463999968)$, 和 $(1/40, -0.479999968)$。\n对 $F$ 与 $1/N_k$ 进行线性拟合，得到斜率：\n$$\nC_k = \\frac{-0.479999968 - (-0.431999968)}{1/40 - 1/10} = \\frac{-0.048}{-0.075} = 0.64\n$$\n\n**c. 自洽扫描（$t$ 变化，$S=240$, $N_k=40$）：**\n此处，力为 $F(t) = \\left( F^\\star + \\frac{C_S}{S_{\\mathrm{ref}}} + \\frac{C_k}{N_{k,\\mathrm{ref}}} \\right) + C_t \\cdot t$。这是 $F$ 和 $x_t=t$ 之间的线性关系，斜率为 $C_t$。\n数据点为 $(t, F)$: $(10^{-3}, -0.47968)$, $(10^{-5}, -0.4799968)$, 和 $(10^{-7}, -0.479999968)$。\n对 $F$ 与 $t$ 进行线性拟合，得到斜率：\n$$\nC_t = \\frac{-0.4799968 - (-0.479999968)}{10^{-5} - 10^{-7}} = \\frac{3.168 \\times 10^{-6}}{9.9 \\times 10^{-6}} = 0.32\n$$\n\n**3. 确定完全收敛力 $F^\\star$**\n\n确定系数后，我们可以使用任何数据点来找到真实力 $F^\\star$。最可靠的点是参考配置本身（$S=240, N_k=40, t=10^{-7}, F=-0.479999968$），因为它在所有扫描中都是共同的。\n$$\nF(240, 40, 10^{-7}) = F^\\star + \\frac{0.96}{240} + \\frac{0.64}{40} + 0.32 \\cdot 10^{-7}\n$$\n$$\n-0.479999968 = F^\\star + 0.004 + 0.016 + 0.000000032\n$$\n$$\n-0.479999968 = F^\\star + 0.020000032\n$$\n解出 $F^\\star$：\n$$\nF^\\star = -0.479999968 - 0.020000032 = -0.5\n$$\n完全收敛的力估计为 $F^\\star = -0.5$ eV/Å。\n\n**4. 计算测试用例的误差大小**\n\n对于给定的参数集 $(S, N_k, t)$，每个误差分量的大小由相应误差项的绝对值给出。由于所有系数都是正的，它们是：\n- Pulay误差大小：$e_P(S) = |\\Delta F_{\\text{Pulay}}(S)| = \\frac{0.96}{S}$\n- K点误差大小：$e_k(N_k) = |\\Delta F_{k}(N_k)| = \\frac{0.64}{N_k}$\n- SCF误差大小：$e_s(t) = |\\Delta F_{\\text{scf}}(t)| = 0.32 \\cdot t$\n\n我们将这些公式应用于四个测试用例。\n\n- **测试用例 1**: $S = 120, N_k = 20, t = 10^{-5}$\n  $e_P = 0.96/120 = 0.008$ eV/Å\n  $e_k = 0.64/20 = 0.032$ eV/Å\n  $e_s = 0.32 \\times 10^{-5} = 0.0000032$ eV/Å\n\n- **测试用例 2**: $S = 240, N_k = 40, t = 10^{-7}$\n  $e_P = 0.96/240 = 0.004$ eV/Å\n  $e_k = 0.64/40 = 0.016$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n- **测试用例 3**: $S = 240, N_k = 10, t = 10^{-7}$\n  $e_P = 0.96/240 = 0.004$ eV/Å\n  $e_k = 0.64/10 = 0.064$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n- **测试用例 4**: $S = 60, N_k = 40, t = 10^{-7}$\n  $e_P = 0.96/60 = 0.016$ eV/Å\n  $e_k = 0.64/40 = 0.016$ eV/Å\n  $e_s = 0.32 \\times 10^{-7} = 0.000000032$ eV/Å\n\n这些值在四舍五入到9位小数后，将构成最终输出。对每个测试用例（包括那些未用于初始拟合的用例）总力的成功预测，验证了加性误差模型和推导出的系数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of separating DFT force error components.\n    \n    The method is as follows:\n    1.  Assume the total force F is a sum of the true force F* and additive\n        error contributions from basis size (S), k-points (Nk), and SCF\n        tolerance (t): F = F* + C_S/S + C_k/Nk + C_t*t.\n    2.  Use the provided parameter sweeps to find the coefficients C_S, C_k,\n        and C_t via linear regression. For example, in the S-sweep, F is a\n        linear function of 1/S, and the slope is C_S.\n    3.  Calculate the true force F* using the reference configuration and the\n        determined coefficients.\n    4.  For each test case, calculate the magnitude of each error component\n        using the derived formulas: e_P = |C_S/S|, e_k = |C_k/Nk|, e_s = |C_t*t|.\n    5.  Format and print the results as required.\n    \"\"\"\n\n    # --- Data from the problem statement ---\n\n    # Reference configuration\n    S_ref, Nk_ref, t_ref = 240, 40, 1e-7\n    F_ref = -0.479999968\n\n    # Basis sweep data (vary S)\n    basis_sweep = {\n        60: -0.467999968,\n        120: -0.475999968,\n        240: -0.479999968,\n    }\n\n    # K-point sweep data (vary Nk)\n    kpoint_sweep = {\n        10: -0.431999968,\n        20: -0.463999968,\n        40: -0.479999968,\n    }\n\n    # Self-consistency sweep data (vary t)\n    scf_sweep = {\n        1e-3: -0.47968,\n        1e-5: -0.4799968,\n        1e-7: -0.479999968,\n    }\n\n    # Test cases for which to compute error components\n    test_cases = [\n        # (S, Nk, t, measured_F) - measured_F is for verification\n        (120, 20, 1e-5, -0.4599968),\n        (240, 40, 1e-7, -0.479999968),\n        (240, 10, 1e-7, -0.431999968),\n        (60, 40, 1e-7, -0.467999968),\n    ]\n\n    # --- Step 1: Determine error coefficients from sweeps ---\n\n    # Basis sweep: Fit F vs 1/S\n    s_vals = np.array(list(basis_sweep.keys()))\n    f_vals_s = np.array(list(basis_sweep.values()))\n    x_s = 1.0 / s_vals\n    # polyfit returns [slope, intercept] for deg=1\n    C_S, _ = np.polyfit(x_s, f_vals_s, 1)\n\n    # K-point sweep: Fit F vs 1/Nk\n    nk_vals = np.array(list(kpoint_sweep.keys()))\n    f_vals_nk = np.array(list(kpoint_sweep.values()))\n    x_nk = 1.0 / nk_vals\n    C_k, _ = np.polyfit(x_nk, f_vals_nk, 1)\n\n    # SCF sweep: Fit F vs t\n    t_vals = np.array(list(scf_sweep.keys()))\n    f_vals_t = np.array(list(scf_sweep.values()))\n    x_t = t_vals\n    C_t, _ = np.polyfit(x_t, f_vals_t, 1)\n\n    # --- Step 2: Calculate the fully converged force F_star ---\n    # This step is not strictly necessary for calculating error components but\n    # provides a complete model and allows for verification.\n    # F_star = F_ref - (C_S/S_ref + C_k/Nk_ref + C_t*t_ref)\n\n    # --- Step 3: Calculate error components for test cases ---\n\n    results = []\n    for case in test_cases:\n        S, Nk, t, _ = case\n\n        # Calculate the magnitude of each error component.\n        # Since all coefficients C are positive, we don't need abs().\n        e_pulay = C_S / S\n        e_kpoint = C_k / Nk\n        e_scf = C_t * t\n\n        results.extend([e_pulay, e_kpoint, e_scf])\n    \n    # --- Step 4: Format and print the final output ---\n    \n    # Format each result to 9 decimal places as a string\n    formatted_results = [f\"{r:.9f}\" for r in results]\n    \n    # Join into a single comma-separated string enclosed in brackets\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在获得了可靠的应力计算方法后，我们可以利用它们来揭示材料的内禀属性。虽然线性弹性（胡克定律）是众所周知的，但材料在较大形变下的行为则由非线性弹性所描述。本练习  演示了如何通过拟合DFT计算得到的非线性应力-应变曲线，从而提取超越线性响应的三阶弹性常数，这对于理解材料的非谐效应和建立更精确的力学模型至关重要。",
            "id": "3739717",
            "problem": "要求您形式化并实现一个方法，通过对超线性区进行拟合，从密度泛函理论（DFT）的应力-应变数据中计算三阶弹性常数，并评估所施加的应变范围是否保持在弹性域内。推导和算法必须从第一性原理出发：即弹性势能的定义以及应力与能量对应变的导数之间的关系。您不能假设或使用问题陈述中直接给出的任何捷径公式；相反，您必须在解题方案中从基本原理推导出相关的函数形式。\n\n您将考虑一个单一模式的形变路径，其中只有一个小应变分量 $e$ 发生变化，而相应的 Cauchy 应力 $\\sigma$（单位为吉帕斯卡）是通过 DFT 计算得出的。从弹性势能密度对小应变张量的三阶展开式可知，单一模式路径下的应力响应可以表示为一个关于 $e$ 的零截距多项式，其系数是二阶和三阶弹性常数的组合。您的任务是拟合这些应力-应变数据，以推断出所选模式的有效二阶常数和有效三阶常数，然后根据下文定义的标准判断给定的应变范围是否是弹性的。\n\n弹性域判定规则：将从您的拟合模型中获得的切线模量定义为 $d\\sigma/de$。如果以下两个条件均成立，则所提供应变范围内的响应被认为是弹性的：\n- 在整个测试区间内，切线模量为正，即 $\\min\\{d\\sigma/de \\text{ 在最小应变处}, d\\sigma/de \\text{ 在最大应变处}\\} > 0$。\n- 平均相对拟合误差 $\\bar{r}$ 不大于预设阈值 $r_{\\max}$，其中\n$$\n\\bar{r} = \\frac{1}{N}\\sum_{i=1}^{N} \\frac{\\left|\\sigma^{\\text{fit}}(e_i) - \\sigma_i\\right|}{\\max\\left(|\\sigma_i|, s_0\\right)},\n$$\n其中 $N$ 是样本数，$\\sigma^{\\text{fit}}(e_i)$ 是样本 $i$ 处的拟合应力，$\\sigma_i$ 是给定的应力数据点，$s_0$ 是一个小的正常数，用以避免除以零。使用 $r_{\\max} = 10^{-6}$ 和 $s_0 = 10^{-8}\\,\\mathrm{GPa}$。\n\n输出规范：\n- 对于每个测试用例，计算单一模式路径的有效二阶常数（单位为吉帕斯卡）和有效三阶常数（单位为吉帕斯卡），四舍五入到小数点后3位，并根据上述规则得出弹性域布尔值。\n- 您的程序应生成单行输出，其中包含测试套件的结果列表，该列表为用方括号括起来的逗号分隔列表，每个用例表示为其自己的方括号列表。例如，对于三个用例，输出格式必须是\n$[\\,[c2_1,c3_1,\\text{boolean}_1],[c2_2,c3_2,\\text{boolean}_2],[c2_3,c3_3,\\text{boolean}_3]\\,]$\n其中 $c2_k$ 和 $c3_k$ 是浮点数（单位为吉帕斯卡），四舍五入到小数点后3位，而 $\\text{boolean}_k$ 是 $True$ 或 $False$。\n\n物理单位：\n- 应力 $\\sigma$ 以 $\\mathrm{GPa}$ 为单位提供，并且必须以 $\\mathrm{GPa}$ 为单位进行处理和报告。\n- 应变 $e$ 是无量纲的。\n- 所有报告的弹性常数都必须以 $\\mathrm{GPa}$ 为单位表示，并四舍五入到小数点后3位。\n\n测试套件：\n为以下三个 DFT 数据集提供解决方案。每个数据集包含数对 $\\{(e_i, \\sigma_i)\\}$，分别以应变和应力数组的形式列出。\n\n- 案例1（中等正应变，切线模量递减但在范围内为正）：\n  - 应变样本： $[\\,0.0,\\,0.002,\\,0.004,\\,0.006,\\,0.008,\\,0.010\\,]$\n  - 应力样本（GPa）： $[\\,0.0,\\,0.398,\\,0.792,\\,1.182,\\,1.568,\\,1.950\\,]$\n\n- 案例2（较大应变，切线模量在上界附近变为非正）：\n  - 应变样本： $[\\,0.0,\\,0.004,\\,0.008,\\,0.010,\\,0.012\\,]$\n  - 应力样本（GPa）： $[\\,0.0,\\,0.480,\\,0.720,\\,0.750,\\,0.720\\,]$\n\n- 案例3（对称小应变，包括压缩和拉伸，切线模量递增）：\n  - 应变样本： $[\\, -0.005,\\, -0.003,\\, -0.001,\\, 0.001,\\, 0.003,\\, 0.005\\, ]$\n  - 应力样本（GPa）： $[\\, -0.34375,\\, -0.20775,\\, -0.06975,\\, 0.07025,\\, 0.21225,\\, 0.35625\\, ]$\n\n算法要求：\n- 拟合一个与三阶弹性理论一致的、关于 $e$ 的零截距多项式。模型必须被约束为没有常数项；只能存在与 $e$ 和 $e^2$ 成正比的项。\n- 使用线性最小二乘法来确定系数。\n- 从第一性原理推导拟合系数如何映射到给定路径的有效二阶和三阶弹性常数。\n- 计算拟合的切线模量 $d\\sigma/de$，并使用每个数据集中的最小和最大 $e$ 以及平均相对误差 $\\bar{r}$（其中 $r_{\\max} = 10^{-6}$，$s_0 = 10^{-8}\\,\\mathrm{GPa}$）来评估弹性域判定规则。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个用例表示为其自己的方括号列表，且不含空格，例如：$[[c2_1,c3_1,boolean_1],[c2_2,c3_2,boolean_2],[c2_3,c3_3,boolean_3]]$。",
            "solution": "该问题是有效的。其科学基础是连续介质弹性理论，作为一个线性最小二乘拟合问题，其提法是适定的，并且所有数据和标准都得到了客观和完整的规定。\n\n这个问题的核心是将应力-应变数据的多项式拟合系数与材料的弹性常数联系起来。这种关系必须从基本原理推导出来，即弹性势能密度的泰勒级数展开。\n\n设 $U$ 为材料的弹性势能密度。对于由单一应变参数 $e$ 描述的形变过程，能量密度可以在零应变状态（$e=0$）附近展开为泰勒级数：\n$$\nU(e) = U(0) + \\left.\\frac{\\partial U}{\\partial e}\\right|_{e=0} e + \\frac{1}{2!} \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0} e^2 + \\frac{1}{3!} \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0} e^3 + \\mathcal{O}(e^4)\n$$\n按照惯例，未形变状态的能量 $U(0)$ 设为 $0$。能量对应变的一阶导数是应力，因此 $\\left.\\frac{\\partial U}{\\partial e}\\right|_{e=0}$ 是参考状态下的应力，根据参考状态的定义，该应力也为零。因此，展开式简化为：\n$$\nU(e) = \\frac{1}{2} \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0} e^2 + \\frac{1}{6} \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0} e^3 + \\mathcal{O}(e^4)\n$$\n根据定义，在零应变下计算的能量密度的二阶和三阶导数，即为给定应变路径的有效二阶和三阶弹性常数。我们分别将它们表示为 $C_2^{\\text{eff}}$ 和 $C_3^{\\text{eff}}$。\n$$\nC_2^{\\text{eff}} \\equiv \\left.\\frac{\\partial^2 U}{\\partial e^2}\\right|_{e=0}\n$$\n$$\nC_3^{\\text{eff}} \\equiv \\left.\\frac{\\partial^3 U}{\\partial e^3}\\right|_{e=0}\n$$\n将这些定义代入能量展开式中，得到：\n$$\nU(e) = \\frac{1}{2} C_2^{\\text{eff}} e^2 + \\frac{1}{6} C_3^{\\text{eff}} e^3 + \\mathcal{O}(e^4)\n$$\n与应变分量 $e$ 共轭的 Cauchy 应力分量 $\\sigma$ 由能量密度对应变的导数给出：\n$$\n\\sigma(e) = \\frac{\\partial U(e)}{\\partial e}\n$$\n对能量展开式求导，我们得到应力-应变关系：\n$$\n\\sigma(e) = \\frac{\\partial}{\\partial e} \\left( \\frac{1}{2} C_2^{\\text{eff}} e^2 + \\frac{1}{6} C_3^{\\text{eff}} e^3 + \\mathcal{O}(e^4) \\right) = C_2^{\\text{eff}} e + \\frac{1}{2} C_3^{\\text{eff}} e^2 + \\mathcal{O}(e^3)\n$$\n此推导表明，在三阶弹性理论下，应力 $\\sigma$ 是应变 $e$ 的一个零截距二次函数。问题要求将 DFT 计算的应力-应变数据拟合到模型 $\\sigma^{\\text{fit}}(e) = a e + b e^2$。通过比较我们推导出的关系式与此拟合模型的各项，我们建立了拟合系数（$a$，$b$）与物理弹性常数之间的映射关系：\n$$\na = C_2^{\\text{eff}}\n$$\n$$\nb = \\frac{1}{2} C_3^{\\text{eff}} \\implies C_3^{\\text{eff}} = 2b\n$$\n由于应变 $e$ 是无量纲的，$C_2^{\\text{eff}}$ 和 $C_3^{\\text{eff}}$ 的单位都将是应力单位，即 $\\mathrm{GPa}$。\n\n算法流程如下：\n1.  对于每组包含 $N$ 个数据对 $\\{(e_i, \\sigma_i)\\}$ 的数据集，我们建立一个线性系统来求解系数 $a$ 和 $b$，以最小化平方差之和 $\\sum_{i=1}^{N} (\\sigma_i - (a e_i + b e_i^2))^2$。这是一个线性最小二乘问题。我们可以将其写成矩阵形式 $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$，其中：\n    $$\n    \\mathbf{A} = \\begin{pmatrix} e_1  e_1^2 \\\\ e_2  e_2^2 \\\\ \\vdots  \\vdots \\\\ e_N  e_N^2 \\end{pmatrix}, \\quad\n    \\mathbf{x} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad\n    \\mathbf{y} = \\begin{pmatrix} \\sigma_1 \\\\ \\sigma_2 \\\\ \\vdots \\\\ \\sigma_N \\end{pmatrix}\n    $$\n    $\\mathbf{x}$ 的最小二乘解是 $(\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$。\n\n2.  一旦确定了系数 $a$ 和 $b$，我们就计算有效弹性常数：$C_2^{\\text{eff}} = a$ 和 $C_3^{\\text{eff}} = 2b$。\n\n3.  接下来，我们使用指定的两部分规则来评估应变范围是否在弹性域内。\n    a.  **切线模量的正性**：拟合的切线模量为 $d\\sigma^{\\text{fit}}/de = a + 2be$。我们必须验证在整个应变区间 $[e_{\\min}, e_{\\max}]$ 内是否有 $d\\sigma^{\\text{fit}}/de > 0$。由于切线模量是 $e$ 的线性函数，其在区间上的最小值必定出现在端点之一。因此，我们检查 $a + 2be_{\\min} > 0$ 和 $a + 2be_{\\max} > 0$ 是否成立。\n    b.  **平均相对拟合误差**：我们计算平均相对误差 $\\bar{r}$：\n        $$\n        \\bar{r} = \\frac{1}{N}\\sum_{i=1}^{N} \\frac{\\left|\\sigma^{\\text{fit}}(e_i) - \\sigma_i\\right|}{\\max\\left(|\\sigma_i|, s_0\\right)}\n        $$\n        其中 $\\sigma^{\\text{fit}}(e_i) = a e_i + b e_i^2$，$s_0 = 10^{-8}\\,\\mathrm{GPa}$，$N$ 是数据点的数量。此误差不得超过阈值 $r_{\\max} = 10^{-6}$。\n\n4.  关于域是否为弹性的最终判定是这两个条件的逻辑与：$(\\text{模量正性}) \\land (\\bar{r} \\le r_{\\max})$。\n\n将此流程应用于所提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes effective second- and third-order elastic constants from stress-strain\n    data, and assesses if the strain range is elastic based on specified criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.0, 0.002, 0.004, 0.006, 0.008, 0.010]),\n            np.array([0.0, 0.398, 0.792, 1.182, 1.568, 1.950])\n        ),\n        (\n            np.array([0.0, 0.004, 0.008, 0.010, 0.012]),\n            np.array([0.0, 0.480, 0.720, 0.750, 0.720])\n        ),\n        (\n            np.array([-0.005, -0.003, -0.001, 0.001, 0.003, 0.005]),\n            np.array([-0.34375, -0.20775, -0.06975, 0.07025, 0.21225, 0.35625])\n        )\n    ]\n\n    r_max = 1e-6\n    s_0 = 1e-8\n\n    results = []\n    \n    for strain_samples, stress_samples in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # 1. Set up and solve the linear least-squares problem.\n        # The model is sigma = a*e + b*e^2.\n        # This is a linear system A*x = sigma, where x = [a, b]^T.\n        design_matrix_A = np.vstack([strain_samples, strain_samples**2]).T\n        \n        # Solve for coefficients [a, b]\n        coeffs, _, _, _ = np.linalg.lstsq(design_matrix_A, stress_samples, rcond=None)\n        a, b = coeffs\n        \n        # 2. Compute elastic constants from fitted coefficients.\n        # From derivation: c2_eff = a, c3_eff = 2*b.\n        c2_eff = a\n        c3_eff = 2 * b\n        \n        # 3. Apply the elastic-domain decision rule.\n        \n        # Condition 1: Positivity of the tangent modulus.\n        # Tangent modulus d(sigma)/de = a + 2*b*e.\n        # Check at the boundaries of the strain interval.\n        e_min, e_max = np.min(strain_samples), np.max(strain_samples)\n        tangent_modulus_at_emin = a + 2 * b * e_min\n        tangent_modulus_at_emax = a + 2 * b * e_max\n        is_modulus_positive = (tangent_modulus_at_emin > 0) and (tangent_modulus_at_emax > 0)\n        \n        # Condition 2: Mean relative fitting error.\n        sigma_fit = a * strain_samples + b * (strain_samples**2)\n        \n        # Denominator for relative error calculation, avoiding division by zero.\n        denominator = np.maximum(np.abs(stress_samples), s_0)\n        relative_errors = np.abs(sigma_fit - stress_samples) / denominator\n        mean_relative_error = np.mean(relative_errors)\n        \n        is_error_low = mean_relative_error = r_max\n        \n        # Combine both conditions for the final verdict.\n        is_elastic = is_modulus_positive and is_error_low\n        \n        # 4. Store the results rounded to 3 decimal places.\n        result_case = [round(c2_eff, 3), round(c3_eff, 3), is_elastic]\n        results.append(result_case)\n\n    # Final print statement in the exact required format.\n    # e.g. [[c2_1,c3_1,boolean_1],[c2_2,c3_2,boolean_2],[c2_3,c3_3,boolean_3]]\n    # str(list) adds spaces, so we remove them.\n    result_strings = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "DFT的强大之处不仅在于计算基本性质，还在于能够预测材料中复杂的耦合物理现象。例如，在许多功能材料中，机械应力会响应于外加电场，这种效应被称为电致伸缩。本练习  提出了一个完整的计算方案，用于从DFT计算中提取电致伸缩系数，并深入探讨了如何区分总响应中的纯电子贡献（固离子响应）与包含晶格弛豫的离子贡献（弛豫离子响应），这对于设计和理解介电与压电材料具有重要意义。",
            "id": "3739751",
            "problem": "您需要设计并实现一个完整的计算方案，通过在固定应变下评估应力作为外加电场的函数来提取电致伸缩系数，并在基于密度泛函理论 (DFT) 的多尺度建模背景下，分离电子和离子的贡献。为简单起见，请在一维空间中进行，并使用连续介质热力学描述。从以下基本基础开始：\n\n- 考虑一个在零温度下，处于均匀纵向应变 $\\,\\varepsilon\\,$ 和均匀外加宏观电场 $\\,E\\,$ 下的绝缘晶体。对于单极化模式的描述，电焓密度（单位体积）建模为\n$$\n\\mathcal{G}(\\varepsilon,P;E)=\\tfrac{1}{2} C\\,\\varepsilon^2 \\;-\\; q\\,\\varepsilon\\,P^2 \\;+\\; \\tfrac{1}{2}\\kappa\\,P^2 \\;-\\; E\\,P,\n$$\n其中 $\\,C\\,$ 是纵向弹性模量，$\\,q\\,$ 是电致伸缩耦合常数，$\\,κ\\,$ 是有效逆极化率，$\\,P\\,$ 是宏观极化强度，$\\,E\\,$ 是外加电场。柯西应力为 $\\,\\sigma=\\partial \\mathcal{G}/\\partial \\varepsilon\\,$，在固定的 $\\,P\\,$ 和 $\\,E\\,$ 下。\n\n- 在密度泛函理论 (DFT) 中，绝缘体的总介电极化率 $\\,\\chi_{\\mathrm{tot}}\\,$ 可以分解为电子（钳制离子）部分 $\\,\\chi_{\\mathrm{el}}\\,$ 和离子部分 $\\,\\chi_{\\mathrm{ion}}\\,$，后者源于晶格介导的响应。因此，在线性区域，对于钳制离子情况，$\\,P(E)=\\chi_{\\mathrm{el}}\\,E\\,$；而对于固定 $\\,\\varepsilon\\,$ 的弛豫离子情况，$\\,P(E)=\\chi_{\\mathrm{tot}}\\,E\\,$，其中 $\\,\\chi_{\\mathrm{tot}}=\\chi_{\\mathrm{el}}+\\chi_{\\mathrm{ion}}\\,$。假设在线性区域 $\\,\\kappa=1/\\chi\\,$，这样，通过最小化 $\\,\\mathcal{G}\\,$ 相对于 $\\,P\\,$，可以在相应情况下恢复这些关于 $\\,P(E)\\,$ 的线性关系。\n\n您的程序必须实现以下方案：\n\n1. 对于每个测试用例，在固定应变 $\\,\\varepsilon\\,$ 下生成两个合成的应力-电场数据集：\n   - 一个使用 $\\,P(E)=\\chi_{\\mathrm{el}}\\,E\\,$ 和 $\\,\\sigma(E)=\\partial \\mathcal{G}/\\partial \\varepsilon=C\\,\\varepsilon-q\\,P(E)^2\\,$ 的钳制离子数据集。\n   - 一个使用 $\\,P(E)=\\chi_{\\mathrm{tot}}\\,E\\,$（其中 $\\,\\chi_{\\mathrm{tot}}=\\chi_{\\mathrm{el}}+\\chi_{\\mathrm{ion}}\\,$）和相同应力定义的弛豫离子数据集。\n\n2. 对于每个数据集，在提供的电场值上，对 $\\,\\sigma(E)\\,$ 进行偶次多项式模型 $\\,\\sigma(E)\\approx s_0+s_2\\,E^2\\,$ 的最小二乘拟合。提取钳制离子和弛豫离子数据集的 $\\,s_2\\,$ 值。\n\n3. 根据拟合得到的 $\\,s_2\\,$ 值，使用相应的极化率估计两种情况下的电致伸缩耦合常数 $\\,q\\,$：\n   - 从钳制离子数据集得到 $\\,q_{\\mathrm{el}} = -\\,s_2 / \\chi_{\\mathrm{el}}^2\\,$。\n   - 从弛豫离子数据集得到 $\\,q_{\\mathrm{tot}} = -\\,s_2 / \\chi_{\\mathrm{tot}}^2\\,$。\n\n4. 计算两种情况下的电致伸缩系数 $\\,Q\\,$，公式为 $\\,Q=q/C\\,$。\n\n5. 将可归因于离子贡献的 $\\,E^2\\,$ 应力响应部分量化为小数 $\\,f_{\\mathrm{ion}}=1-(\\chi_{\\mathrm{el}}/\\chi_{\\mathrm{tot}})^2\\,$。\n\n科学和单位要求：\n\n- 将量 $\\,C\\,$, $\\,q\\,$, $\\,\\varepsilon\\,$, $\\,\\chi_{\\mathrm{el}}\\,$ 和 $\\,\\chi_{\\mathrm{ion}}\\,$ 视为每个测试用例给定的标量。\n- 使用国际单位制 (SI)：$\\,C\\,$ 和 $\\,\\sigma\\,$ 的单位是帕斯卡 (Pa)，$\\,E\\,$ 的单位是伏特/米 (V/m)，$\\,P\\,$ 的单位是库仑/平方米 (C/m$^2$)，$\\,\\chi\\,$ 的单位是 C/(V·m)，$\\,q\\,$ 的单位是 Pa·m$^4$/C$^2$，$\\,Q\\,$ 的单位是 m$^4$/C$^2$。\n- 问题中不涉及角度。\n- 所有输出均表示为十进制数。\n\n测试套件：\n\n为以下三个测试用例实现您的程序，每个用例由一个元组 $\\,\\big(C,\\;q,\\;\\varepsilon,\\;\\chi_{\\mathrm{el}},\\;\\chi_{\\mathrm{ion}},\\;E\\_\\mathrm{list}\\big)\\,$ 指定，其中 $\\,E\\_\\mathrm{list}\\,$ 是用于拟合的电场值集合（单位为 V/m）：\n\n- 案例 1 (一般情况): $\\,C=1.6\\times 10^{11}\\,\\mathrm{Pa}$, $\\,q=2.5\\times 10^{9}\\,\\mathrm{Pa\\cdot m^4/C^2}$, $\\,\\varepsilon=8.0\\times 10^{-4}$, $\\,\\chi_{\\mathrm{el}}=6.0\\times 10^{-9}\\,\\mathrm{C/(V\\cdot m)}$, $\\,\\chi_{\\mathrm{ion}}=4.0\\times 10^{-9}\\,\\mathrm{C/(V\\cdot m)}$, $\\,E\\_\\mathrm{list}=\\big[-2.0\\times 10^{8},\\,-1.0\\times 10^{8},\\,0,\\,1.0\\times 10^{8},\\,2.0\\times 10^{8}\\big]\\,$.\n- 案例 2 (无离子响应边界情况): $\\,C=2.0\\times 10^{11}\\,\\mathrm{Pa}$, $\\,q=1.0\\times 10^{9}\\,\\mathrm{Pa\\cdot m^4/C^2}$, $\\,\\varepsilon=1.0\\times 10^{-3}$, $\\,\\chi_{\\mathrm{el}}=1.0\\times 10^{-8}\\,\\mathrm{C/(V\\cdot m)}$, $\\,\\chi_{\\mathrm{ion}}=0.0\\,\\mathrm{C/(V\\cdot m)}$, $\\,E\\_\\mathrm{list}=\\big[-3.0\\times 10^{8},\\,-1.5\\times 10^{8},\\,0,\\,1.5\\times 10^{8},\\,3.0\\times 10^{8}\\big]\\,$.\n- 案例 3 (强离子响应情况): $\\,C=1.2\\times 10^{11}\\,\\mathrm{Pa}$, $\\,q=5.0\\times 10^{9}\\,\\mathrm{Pa\\cdot m^4/C^2}$, $\\,\\varepsilon=5.0\\times 10^{-4}$, $\\,\\chi_{\\mathrm{el}}=4.0\\times 10^{-9}\\,\\mathrm{C/(V\\cdot m)}$, $\\,\\chi_{\\mathrm{ion}}=1.2\\times 10^{-8}\\,\\mathrm{C/(V\\cdot m)}$, $\\,E\\_\\mathrm{list}=\\big[-1.0\\times 10^{8},\\,-5.0\\times 10^{7},\\,0,\\,5.0\\times 10^{7},\\,1.0\\times 10^{8}\\big]\\,$.\n\n最终输出规范：\n\n- 对于每个测试用例，按以下顺序生成一个包含五个浮点数的列表：$[Q_{\\mathrm{el}},\\,Q_{\\mathrm{tot}},\\,q_{\\mathrm{el}},\\,q_{\\mathrm{tot}},\\,f_{\\mathrm{ion}}]$。\n- 您的程序应生成单行输出，其中包含三个按案例排列的结果列表，这些列表聚合在一个大列表中，格式为用方括号括起来的逗号分隔列表。例如：$[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$。",
            "solution": "该问题提出了一个有效且适定的计算方案，用于从模拟的应力-电场数据中确定电致伸缩系数，该方案基于连续介质热力学和固态物理学的原理。验证过程证实了该问题的科学合理性、内部一致性和可行性。因此，我们可以继续详细描述解决方案。\n\n目标是实现一个计算工作流，该工作流基于给定的热力学模型模拟应力数据，然后使用该数据提取物理参数，特别是电致伸缩耦合常数 $q$ 和电致伸缩系数 $Q$。该方案还旨在区分这些效应中的电子（钳制离子）贡献和总（弛豫离子）贡献。\n\n其基础是一维绝缘晶体的电焓密度 $\\mathcal{G}$：\n$$\n\\mathcal{G}(\\varepsilon, P; E) = \\frac{1}{2} C \\varepsilon^2 - q \\varepsilon P^2 + \\frac{1}{2} \\kappa P^2 - E P\n$$\n这里，$\\varepsilon$ 是纵向应变，$P$ 是宏观极化强度，$E$ 是外加宏观电场，$C$ 是弹性模量，$q$ 是电致伸缩耦合常数，而 $\\kappa$ 是有效逆极化率。\n\n柯西应力 $\\sigma$ 定义为在恒定极化强度 $P$ 和电场 $E$ 下，$\\mathcal{G}$ 相对于应变 $\\varepsilon$ 的偏导数：\n$$\n\\sigma = \\left(\\frac{\\partial \\mathcal{G}}{\\partial \\varepsilon}\\right)_{P,E} = C \\varepsilon - q P^2\n$$\n这个核心方程将应力与应变和极化强度联系起来。问题陈述，在线性介电区域，极化强度 $P$ 是电场 $E$ 的函数，由 $P(E) = \\chi E$ 给出，其中 $\\chi$ 是电极化率。\n\n该计算方案包括以下步骤：\n\n**步骤1：生成合成应力数据**\n我们根据给定的电场值列表 $E\\_\\mathrm{list}$ 中的一系列 $E_i$ 值，生成两组应力数据点 $\\sigma(E)$。这是在固定的应变 $\\varepsilon$、弹性模量 $C$ 和耦合常数 $q$ 下完成的。这两个数据集对应于不同的物理条件：\n\n1.  **钳制离子（电子）情况**：离子位置固定。极化响应纯粹是电子的。极化强度由 $P_{\\mathrm{el}}(E) = \\chi_{\\mathrm{el}} E$ 给出，其中 $\\chi_{\\mathrm{el}}$ 是电子极化率。那么应力为：\n    $$\n    \\sigma_{\\mathrm{el}}(E) = C \\varepsilon - q (\\chi_{\\mathrm{el}} E)^2 = C \\varepsilon - q \\chi_{\\mathrm{el}}^2 E^2\n    $$\n\n2.  **弛豫离子（总）情况**：允许离子位置在电场存在下弛豫，从而对极化做出贡献。总极化率为 $\\chi_{\\mathrm{tot}} = \\chi_{\\mathrm{el}} + \\chi_{\\mathrm{ion}}$，其中 $\\chi_{\\mathrm{ion}}$ 是离子贡献。极化强度为 $P_{\\mathrm{tot}}(E) = \\chi_{\\mathrm{tot}} E$，应力为：\n    $$\n    \\sigma_{\\mathrm{tot}}(E) = C \\varepsilon - q (\\chi_{\\mathrm{tot}} E)^2 = C \\varepsilon - q \\chi_{\\mathrm{tot}}^2 E^2\n    $$\n\n对于每个测试用例的参数（$C, q, \\varepsilon, \\chi_{\\mathrm{el}}, \\chi_{\\mathrm{ion}}$）和 $E\\_\\mathrm{list}$，我们计算相应的 $\\sigma_{\\mathrm{el}}(E_i)$ 和 $\\sigma_{\\mathrm{tot}}(E_i)$ 值。\n\n**步骤2：最小二乘拟合**\n$\\sigma_{\\mathrm{el}}(E)$ 和 $\\sigma_{\\mathrm{tot}}(E)$ 的理论形式都是 $E$ 的偶次多项式，具体形式为 $\\sigma(E) = s_0 + s_2 E^2$。该方案要求将生成的数据点 $(\\sigma_i, E_i)$ 拟合到此模型，以提取系数 $s_0$ 和 $s_2$。\n\n对于一组 $N$ 个数据点 $(E_i, \\sigma_i)$，我们寻求找到使残差平方和最小化的 $s_0$ 和 $s_2$。这是一个线性最小二乘问题，可以表示为矩阵形式，即找到最小化 $\\|\\mathbf{A}\\mathbf{s} - \\mathbf{y}\\|^2$ 的向量 $\\mathbf{s} = [s_0, s_2]^T$，其中：\n$$\n\\mathbf{A} = \\begin{pmatrix} 1  E_1^2 \\\\ 1  E_2^2 \\\\ \\vdots  \\vdots \\\\ 1  E_N^2 \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} \\sigma_1 \\\\ \\sigma_2 \\\\ \\vdots \\\\ \\sigma_N \\end{pmatrix}\n$$\n这可以使用标准线性代数库进行计算求解。我们对钳制离子和弛豫离子数据集分别进行此拟合，以获得两组系数：$(s_{0,\\mathrm{el}}, s_{2,\\mathrm{el}})$ 和 $(s_{0,\\mathrm{tot}}, s_{2,\\mathrm{tot}})$。根据步骤1中的方程，我们期望找到 $s_0 = C\\varepsilon$ 和 $s_2 = -q \\chi^2$。由于合成数据完美地遵循模型，拟合将是精确的，仅受浮点精度的限制。\n\n**步骤3：估计电致伸缩耦合常数 $q$**\n从拟合的系数 $s_2$ 中，我们可以反转关系式 $s_2 = -q \\chi^2$ 来估计耦合常数 $q$。\n对于钳制离子情况：\n$$\nq_{\\mathrm{el}} = -\\frac{s_{2,\\mathrm{el}}}{\\chi_{\\mathrm{el}}^2}\n$$\n对于弛豫离子情况：\n$$\nq_{\\mathrm{tot}} = -\\frac{s_{2,\\mathrm{tot}}}{\\chi_{\\mathrm{tot}}^2}\n$$\n由于数据生成和拟合基于一个自洽模型，理论上 $q_{\\mathrm{el}}$ 和 $q_{\\mathrm{tot}}$ 都应该恢复原始输入的 $q$ 值。\n\n**步骤4：计算电致伸缩系数 $Q$**\n电致伸缩系数 $Q$ 定义为 $Q = q/C$。我们使用估计的 $q$ 值计算电子情况和总情况下的 $Q$：\n$$\nQ_{\\mathrm{el}} = \\frac{q_{\\mathrm{el}}}{C} \\quad \\text{和} \\quad Q_{\\mathrm{tot}} = \\frac{q_{\\mathrm{tot}}}{C}\n$$\n与 $q_{\\mathrm{el}} \\approx q_{\\mathrm{tot}} \\approx q$ 的发现一致，我们期望 $Q_{\\mathrm{el}} \\approx Q_{\\mathrm{tot}}$。\n\n**步骤5：量化离子贡献**\n最后一步是计算由离子贡献引起的 $E^2$ 应力响应的分数。总的二次应力系数为 $s_{2,\\mathrm{tot}} \\propto -q\\chi_{\\mathrm{tot}}^2$，而纯电子部分为 $s_{2,\\mathrm{el}} \\propto -q\\chi_{\\mathrm{el}}^2$。离子对总 $E^2$ 响应的分数贡献是纯离子效应与总效应之比。总效应的大小与 $\\chi_{\\mathrm{tot}}^2$ 成正比，纯电子效应的大小与 $\\chi_{\\mathrm{el}}^2$ 成正比。纯粹由离子运动产生的效应的大小与 $\\chi_{\\mathrm{tot}}^2 - \\chi_{\\mathrm{el}}^2$ 成正比。因此，离子分数 $f_{\\mathrm{ion}}$ 为：\n$$\nf_{\\mathrm{ion}} = \\frac{|s_{2,\\mathrm{tot}}| - |s_{2,\\mathrm{el}}|}{|s_{2,\\mathrm{tot}}|} = \\frac{q\\chi_{\\mathrm{tot}}^2 - q\\chi_{\\mathrm{el}}^2}{q\\chi_{\\mathrm{tot}}^2} = 1 - \\left(\\frac{\\chi_{\\mathrm{el}}}{\\chi_{\\mathrm{tot}}}\\right)^2\n$$\n此公式对每个测试用例进行计算。\n\n对提供的三个测试用例中的每一个都实施这个五步方案，并为每个案例记录得到的五元素列表 $[Q_{\\mathrm{el}}, Q_{\\mathrm{tot}}, q_{\\mathrm{el}}, q_{\\mathrm{tot}}, f_{\\mathrm{ion}}]$。最终输出汇总了这些列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the computational protocol to extract electrostriction coefficients\n    from synthetic DFT-based stress vs. electric field data.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (C, q, epsilon, chi_el, chi_ion, E_list)\n    test_cases = [\n        (1.6e11, 2.5e9, 8.0e-4, 6.0e-9, 4.0e-9, np.array([-2.0e8, -1.0e8, 0, 1.0e8, 2.0e8])),\n        (2.0e11, 1.0e9, 1.0e-3, 1.0e-8, 0.0,    np.array([-3.0e8, -1.5e8, 0, 1.5e8, 3.0e8])),\n        (1.2e11, 5.0e9, 5.0e-4, 4.0e-9, 1.2e-8, np.array([-1.0e8, -5.0e7, 0, 5.0e7, 1.0e8]))\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        C, q_input, epsilon, chi_el, chi_ion, E_fields = case\n        \n        # Calculate total susceptibility\n        chi_tot = chi_el + chi_ion\n        \n        # --- Step 1: Generate synthetic stress data ---\n        \n        # Clamped-ion (electronic) stress\n        # sigma_el(E) = C*epsilon - q*(chi_el*E)^2\n        sigma_el = C * epsilon - q_input * (chi_el * E_fields)**2\n        \n        # Relaxed-ion (total) stress\n        # sigma_tot(E) = C*epsilon - q*(chi_tot*E)^2\n        sigma_tot = C * epsilon - q_input * (chi_tot * E_fields)**2\n        \n        # --- Step 2: Least-squares fit to sigma(E) = s0 + s2*E^2 ---\n        \n        E_fields_sq = E_fields**2\n        # Design matrix for the fit: columns are for s0 (constant) and s2 (E^2 term)\n        A = np.vstack([np.ones(len(E_fields_sq)), E_fields_sq]).T\n        \n        # Fit clamped-ion data\n        s0_el, s2_el = np.linalg.lstsq(A, sigma_el, rcond=None)[0]\n        \n        # Fit relaxed-ion data\n        s0_tot, s2_tot = np.linalg.lstsq(A, sigma_tot, rcond=None)[0]\n        \n        # --- Step 3: Estimate electrostrictive coupling constant q ---\n        \n        # From clamped-ion data\n        # s2_el = -q_el * chi_el^2  => q_el = -s2_el / chi_el^2\n        # Handle chi_el=0 case to avoid division by zero, though not in test cases\n        q_el = -s2_el / chi_el**2 if chi_el != 0 else 0.0\n\n        # From relaxed-ion data\n        # s2_tot = -q_tot * chi_tot^2  => q_tot = -s2_tot / chi_tot^2\n        # Handle chi_tot=0 case\n        q_tot = -s2_tot / chi_tot**2 if chi_tot != 0 else 0.0\n        \n        # --- Step 4: Compute electrostriction coefficient Q ---\n        \n        # Q = q/C\n        Q_el = q_el / C\n        Q_tot = q_tot / C\n        \n        # --- Step 5: Quantify ionic contribution fraction ---\n        \n        # f_ion = 1 - (chi_el / chi_tot)^2\n        # Handle chi_tot=0 case\n        f_ion = 1 - (chi_el / chi_tot)**2 if chi_tot != 0 else 0.0\n        \n        # Append the list of five required float values for this case\n        results.append([Q_el, Q_tot, q_el, q_tot, f_ion])\n        \n    # --- Final Output Formatting ---\n    # The formatting requirement is a string representation of a list of lists.\n    # str(list) produces a string like '[item1, item2]', which is desired.\n    # We join these list strings with commas and enclose them in an outer [].\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}