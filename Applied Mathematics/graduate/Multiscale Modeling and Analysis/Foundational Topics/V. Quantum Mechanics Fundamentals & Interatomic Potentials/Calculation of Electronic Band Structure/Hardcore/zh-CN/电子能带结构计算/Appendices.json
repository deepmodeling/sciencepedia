{
    "hands_on_practices": [
        {
            "introduction": "在任何基于平面波基组的计算中，首要任务是确保计算结果对于基组的大小是收敛的。该实践通过一个一维周期性势模型，引导您探索关键的收敛性参数——动能截断能$E_{\\text{cut}}$——如何影响电子能带结构计算的准确性。掌握这项基本技能对于获得可靠且具有物理意义的计算结果至关重要，例如材料的带隙和价带宽度。",
            "id": "3739438",
            "problem": "考虑一个一维周期势模型，该模型旨在定性地模拟硅的电子结构特征，同时在平面波基组下保持计算上的可行性。该系统由质量为 $m_e$ 的电子在晶格常数为 $a$ 的周期势 $V(x)$ 中的单粒子不含时薛定谔方程所描述，表示为 $-\\frac{\\hbar^2}{2 m_e} \\frac{d^2}{dx^2} \\psi(x) + V(x) \\psi(x) = E \\psi(x)$。根据布洛赫定理，本征态可以写成 $\\psi_{n,k}(x) = e^{i k x} u_{n,k}(x)$ 的形式，其中 $u_{n,k}(x)$ 具有晶格的周期性。在平面波基组中展开，会得到一个在倒易空间中的矩阵哈密顿量，其矩阵元由倒易晶格矢量 $G$ 和 $G'$ 索引：\n$$\nH_{G,G'}(k) = \\delta_{G,G'} \\left( \\frac{\\hbar^2}{2 m_e} \\left| k + G \\right|^2 \\right) + V_{G - G'}\n$$\n其中 $V_{q}$ 是周期势的傅里叶分量，$\\delta_{G,G'}$ 是克罗内克 δ 符号。倒易晶格矢量为 $G = n G_0$，其中 $n \\in \\mathbb{Z}$ 且 $G_0 = \\frac{2 \\pi}{a}$。在本问题中，使用一个由两个非零傅里叶分量 $V_{G_0}$ 和 $V_{2 G_0}$ 指定的可移植局域赝势，而其他 $V_{q}$ 均为零。对于所有体积，取 $V_{G_0} = -5.0$ eV 和 $V_{2 G_0} = +1.5$ eV，这构成一个旨在模拟类似于硅的间接带隙打开和有限价带宽度的模型。使用物理常数 $\\frac{\\hbar^2}{2 m_e} = 3.8099819443$ eV·Å$^2$。\n\n为反映平面波基组的截断，施加一个动能截断 $E_{\\text{cut}}$，即只包括那些在 $k = 0$ 时自由电子动能满足 $\\frac{\\hbar^2}{2 m_e} G^2 \\le E_{\\text{cut}}$ 的倒易晶格矢量 $G$。对于每个选定的 $E_{\\text{cut}}$，在第一布里渊区从 $0$ 到 $\\pi/a$ 的均匀波矢 $k$ 网格上构建哈密顿量 $H(k)$，对角化 $H(k)$ 以获得能带能量 $E_n(k)$（按升序排列），并将价带定义为 $n_v = 1$，导带定义为 $n_c = 2$。这种索引方式对应于一个物理假设，即在一维绝缘体的近自由电子近似下，第一和第二能带之间存在一个主带隙。价带宽度为 $W_v = \\max_k E_{n_v}(k) - \\min_k E_{n_v}(k)$，间接带隙为 $\\Delta_{\\text{ind}} = \\min_k E_{n_c}(k) - \\max_k E_{n_v}(k)$，能量以电子伏特表示。\n\n你的任务是计算 $\\Delta_{\\text{ind}}$ 和 $W_v$ 相对于 $E_{\\text{cut}}$ 的收敛性，并通过在不同晶格常数 $a$ 下重复分析来评估赝势在不同体积下的可移植性。使用以下测试组：\n\n- 晶格常数 (单位 Å): $a_1 = 5.43$, $a_2 = 5.30$, $a_3 = 5.60$。\n- 待测试的能量截断 (单位 eV): $E_{\\text{cut}} \\in \\{ 4, 6, 8, 12, 16, 24, 32, 48 \\}$。\n- 参考能量截断 (单位 eV): $E_{\\text{ref}} = 80$。\n- 容差 (单位 eV): 间接带隙为 $\\varepsilon_{\\Delta} = 0.01$，价带宽度为 $\\varepsilon_W = 0.01$。\n- 波矢网格：在 $[0, \\pi/a]$ 范围内均匀采样 $201$ 个 $k$ 点。\n\n对于每个晶格常数 $a$，使用 $E_{\\text{ref}}$ 计算参考值 $\\Delta_{\\text{ind}}^{\\text{ref}}(a)$ 和 $W_v^{\\text{ref}}(a)$。然后，对于测试列表中的每个 $E_{\\text{cut}}$，计算 $\\Delta_{\\text{ind}}(a; E_{\\text{cut}})$ 和 $W_v(a; E_{\\text{cut}})$，并确定满足 $\\left| \\Delta_{\\text{ind}}(a; E_{\\text{cut}}) - \\Delta_{\\text{ind}}^{\\text{ref}}(a) \\right| \\le \\varepsilon_{\\Delta}$ 的最小 $E_{\\text{cut}}$ 和满足 $\\left| W_v(a; E_{\\text{cut}}) - W_v^{\\text{ref}}(a) \\right| \\le \\varepsilon_W$ 的最小 $E_{\\text{cut}}$。如果在给定 $a$ 下，测试列表中的某个属性没有 $E_{\\text{cut}}$ 满足容差，则对该项报告 $-1$。能量和截断的单位是电子伏特 (eV)，距离的单位是埃 (Å)。波矢 $k$ 的单位是倒埃 (Å$^{-1}$)。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含六个数字：在 $a_1$ 处间接带隙的最小 $E_{\\text{cut}}$，在 $a_1$ 处价带宽度的最小 $E_{\\text{cut}}$，然后是 $a_2$ 对应的两个值，最后是 $a_3$ 对应的两个值。例如，输出格式必须像 $[x_1, y_1, x_2, y_2, x_3, y_3]$，其中每个 $x_i$ 和 $y_i$ 都是以 eV 为单位的浮点数。",
            "solution": "该问题要求计算一维周期体系的间接带隙和价带宽度，并研究它们相对于平面波能量截断参数 $E_{\\text{cut}}$ 的收敛性。这是计算材料科学中的一个标准流程，用以确保模拟结果的可靠性。该分析将在三个不同的晶格常数 $a$ 下进行，以评估所提供赝势的可移植性。\n\n这个问题的基础是质量为 $m_e$ 的电子在周期势 $V(x)$ 中的单粒子不含时薛定谔方程：\n$$\n\\left[ -\\frac{\\hbar^2}{2 m_e} \\frac{d^2}{dx^2} + V(x) \\right] \\psi(x) = E \\psi(x)\n$$\n由于势的周期性 $V(x) = V(x+a)$，布洛赫定理指出本征态可以写成 $\\psi_{n,k}(x) = e^{ikx} u_{n,k}(x)$ 的形式，其中 $u_{n,k}(x)$ 是一个具有相同晶格周期性的周期函数，而 $k$ 是限制在第一布里渊区内的波矢，对于一维晶格，该区域为 $[-\\pi/a, \\pi/a]$。\n\n周期函数 $u_{n,k}(x)$ 可以通过倒易晶格矢量 $G = n G_0$（其中 $G_0 = 2\\pi/a$ 且 $n \\in \\mathbb{Z}$）展开成傅里叶级数：\n$$\nu_{n,k}(x) = \\sum_{G} c_{k,G} e^{iGx}\n$$\n将此代入薛定谔方程，会得到一个倒易空间中的本征值问题。哈密顿量变成一个矩阵，其矩阵元由倒易晶格矢量 $G$ 和 $G'$ 索引：\n$$\nH_{G,G'}(k) = \\delta_{G,G'} \\left( \\frac{\\hbar^2}{2 m_e} |k+G|^2 \\right) + V_{G-G'}\n$$\n这里，$\\delta_{G,G'}$ 是克罗内克 δ 符号，$V_{G-G'}$ 是势 $V(x)$ 的傅里叶系数。对于一个物理的实势 $V(x)$，其傅里叶系数必须满足 $V_q = V_{-q}^*$。问题给出了 $V_q$ 的实数值，这意味着 $V_q = V_{-q}$。我们已知两个非零势分量：$V_{G_0} = -5.0 \\text{ eV}$ 和 $V_{2G_0} = +1.5 \\text{ eV}$。因此我们假设 $V_{-G_0} = V_{G_0}$ 且 $V_{-2G_0} = V_{2G_0}$。所有其他分量，包括 $V_0$，都为零。常数 $\\frac{\\hbar^2}{2m_e}$ 给定为 $3.8099819443 \\text{ eV} \\cdot \\text{Å}^2$。\n\n在任何实际计算中，对 $G$ 的无限求和都必须被截断。问题指定了一种动能截断方案：基组只包含那些在 $k=0$ 时自由电子动能低于截断值 $E_{\\text{cut}}$ 的倒易晶格矢量 $G$。\n$$\n\\frac{\\hbar^2}{2 m_e} G^2 \\le E_{\\text{cut}}\n$$\n代入 $G = n G_0 = n \\frac{2\\pi}{a}$，我们可以找到基组的最大整数 $N_{\\text{max}}$：\n$$\nn^2 \\le \\frac{E_{\\text{cut}} a^2}{4\\pi^2 (\\hbar^2 / 2m_e)}\n$$\n因此，$N_{\\text{max}}(a, E_{\\text{cut}}) = \\left\\lfloor \\sqrt{\\frac{E_{\\text{cut}} a^2}{4\\pi^2 (\\hbar^2 / 2m_e)}} \\right\\rfloor$。基组将由 $G_n = nG_0$（其中 $n \\in \\{-N_{\\text{max}}, \\dots, N_{\\text{max}}\\}$）组成。哈密顿矩阵的大小将是 $(2N_{\\text{max}} + 1) \\times (2N_{\\text{max}} + 1)$。为了使问题有意义（即，至少获得两个能带，$n_v=1$ 和 $n_c=2$），矩阵大小必须至少为 $2 \\times 2$，这意味着 $N_{\\text{max}} \\ge 1$。如果所选的 $E_{\\text{cut}}$ 导致 $N_{\\text{max}} < 1$，则不会对该截断值进行计算，因为所需的量是未明确定义的。\n\n计算步骤如下：\n1. 对于每个晶格常数 $a \\in \\{5.43, 5.30, 5.60\\}$ Å：\n    a. 在 $[0, \\pi/a]$ 范围内生成一个包含 $201$ 个波矢 $k$ 的均匀网格。\n    b. 使用一个高的参考截断值 $E_{\\text{ref}} = 80 \\text{ eV}$ 来计算间接带隙的参考值 $\\Delta_{\\text{ind}}^{\\text{ref}}(a)$ 和价带宽度的参考值 $W_v^{\\text{ref}}(a)$。\n    c. 对于每个测试截断值 $E_{\\text{cut}} \\in \\{4, 6, 8, 12, 16, 24, 32, 48\\}$ eV，计算 $\\Delta_{\\text{ind}}(a; E_{\\text{cut}})$ 和 $W_v(a; E_{\\text{cut}})$。这包括：\n        i. 确定给定 $a$ 和 $E_{\\text{cut}}$ 的 $N_{\\text{max}}$。\n        ii. 对网格上的每个 $k$，构建 $(2N_{\\text{max}}+1) \\times (2N_{\\text{max}}+1)$ 的哈密顿矩阵 $H(k)$。该矩阵是厄米矩阵（在本例中是实对称矩阵）。\n        iii. 对角化 $H(k)$ 以获得其本征值，即能带能量 $E_n(k)$。这些值按升序排序。\n        iv. 遍历所有 $k$ 后，价带宽度计算为 $W_v = \\max_k E_1(k) - \\min_k E_1(k)$，间接带隙计算为 $\\Delta_{\\text{ind}} = \\min_k E_2(k) - \\max_k E_1(k)$。\n    d. 找到测试列表中的最小 $E_{\\text{cut}}$，使其相对于参考值的绝对误差在容差范围内：对于带隙，要求 $|\\Delta_{\\text{ind}} - \\Delta_{\\text{ind}}^{\\text{ref}}| \\le \\varepsilon_{\\Delta}$（$\\varepsilon_{\\Delta} = 0.01$ eV）；对于带宽，要求 $|W_v - W_v^{\\text{ref}}| \\le \\varepsilon_W$（$\\varepsilon_W = 0.01$ eV）。如果列表中不存在这样的截断值，则报告 $-1$。\n\n对三个晶格常数中的每一个都重复此过程，最终得出六个关于最小收敛能量截断值的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convergence of indirect band gap and valence bandwidth\n    with respect to the plane-wave energy cutoff for a 1D crystal model.\n    \"\"\"\n    \n    # --- Givens from the problem statement ---\n    \n    # Physical and model parameters\n    HBAR2_2M = 3.8099819443  # eV·Å^2\n    V_G0 = -5.0  # eV\n    V_2G0 = +1.5  # eV\n    \n    # Test suite parameters\n    LATTICE_CONSTANTS = [5.43, 5.30, 5.60]  # in Å\n    ENERGY_CUTOFFS = [4, 6, 8, 12, 16, 24, 32, 48]  # in eV\n    E_REF = 80.0  # in eV\n    EPS_DELTA = 0.01  # Tolerance for indirect gap in eV\n    EPS_W = 0.01  # Tolerance for valence bandwidth in eV\n    K_POINTS = 201\n    \n    # Dictionary of potential components\n    # V_q = V_{-q} because V(x) is real\n    POTENTIAL_FOURIER = {\n        1: V_G0,\n        -1: V_G0,\n        2: V_2G0,\n        -2: V_2G0,\n    }\n\n    def calculate_properties(a, e_cut, k_grid):\n        \"\"\"\n        Calculates band structure properties for a given lattice constant and energy cutoff.\n        \"\"\"\n        g0 = 2 * np.pi / a\n        \n        # Determine the size of the plane-wave basis set\n        n_max_sq = (e_cut * a**2) / (4 * np.pi**2 * HBAR2_2M)\n        n_max = int(np.floor(np.sqrt(n_max_sq)))\n        \n        # The problem requires at least two bands. If basis size  2, properties are undefined.\n        if 2 * n_max + 1  2:\n            return None, None\n            \n        n_values = np.arange(-n_max, n_max + 1)\n        matrix_size = len(n_values)\n        \n        e1_k = np.zeros(len(k_grid))\n        e2_k = np.zeros(len(k_grid))\n        \n        # Construct and diagonalize the Hamiltonian for each k-point\n        for i, k in enumerate(k_grid):\n            H = np.zeros((matrix_size, matrix_size), dtype=np.complex128)\n            \n            # Populate Hamiltonian matrix\n            for row in range(matrix_size):\n                for col in range(matrix_size):\n                    n_row = n_values[row]\n                    n_col = n_values[col]\n                    \n                    # Kinetic energy term (diagonal)\n                    if row == col:\n                        H[row, col] += HBAR2_2M * (k + n_row * g0)**2\n                    \n                    # Potential term (off-diagonal)\n                    n_diff = n_row - n_col\n                    if n_diff in POTENTIAL_FOURIER:\n                        H[row, col] += POTENTIAL_FOURIER[n_diff]\n            \n            # Diagonalize the Hermitian matrix to find eigenvalues (band energies)\n            eigenvalues = np.linalg.eigh(H)[0]\n            \n            # Store the first two bands (sorted by eigh)\n            e1_k[i] = eigenvalues[0]\n            e2_k[i] = eigenvalues[1]\n            \n        # Calculate valence bandwidth and indirect band gap\n        w_v = np.max(e1_k) - np.min(e1_k)\n        delta_ind = np.min(e2_k) - np.max(e1_k)\n        \n        return delta_ind, w_v\n\n    final_results = []\n    \n    for a in LATTICE_CONSTANTS:\n        k_grid = np.linspace(0, np.pi / a, K_POINTS)\n        \n        # 1. Calculate reference values with E_ref\n        delta_ref, w_v_ref = calculate_properties(a, E_REF, k_grid)\n\n        # Storage for results for the current lattice constant\n        cutoff_results = {}\n        \n        # 2. Calculate properties for each test E_cut\n        for e_cut in ENERGY_CUTOFFS:\n            delta, w_v = calculate_properties(a, float(e_cut), k_grid)\n            cutoff_results[e_cut] = (delta, w_v)\n            \n        # 3. Find the minimum E_cut satisfying the convergence criteria\n        min_e_cut_delta = -1.0\n        min_e_cut_w_v = -1.0\n        \n        for e_cut in sorted(cutoff_results.keys()):\n            delta, w_v = cutoff_results[e_cut]\n            \n            if delta is not None:\n                # Check convergence for indirect gap\n                if min_e_cut_delta == -1.0 and abs(delta - delta_ref) = EPS_DELTA:\n                    min_e_cut_delta = float(e_cut)\n                \n                # Check convergence for valence bandwidth\n                if min_e_cut_w_v == -1.0 and abs(w_v - w_v_ref) = EPS_W:\n                    min_e_cut_w_v = float(e_cut)\n\n        final_results.extend([min_e_cut_delta, min_e_cut_w_v])\n        \n    # 4. Format and print the final output\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当模拟表面、界面或二维材料时，我们通常在周期性边界条件下的超晶胞中放置一个平板模型，并用真空层将其与周期性镜像隔开。如果平板存在垂直于其表面的净偶极矩，这种设置会引入伪影，即由周期性镜像产生的非物理静电相互作用，从而影响计算的准确性。本实践将指导您通过求解泊松方程来量化这种伪相互作用，并实现一种偶极校正方案来消除它，这是进行可靠表面和界面计算的一项高级但至关重要的技能。",
            "id": "3739509",
            "problem": "您的任务是构建一个物理上一致的一维谱方法求解器，以量化和比较在平面波表示中周期性重复的平板镜像之间产生的赝静电相互作用，并评估偶极校正在减轻这些赝象方面的有效性。目标是测量在周期性边界条件下，平板能带能量随真空层厚度的收敛情况。\n\n考虑一个长度为 $L_z$ 的一维晶胞，由厚度为 $L_{\\mathrm{sl}}$ 的中心平板和厚度为 $L_{\\mathrm{vac}}$ 的真空层组成，因此 $L_z = L_{\\mathrm{sl}} + L_{\\mathrm{vac}}$。$z$ 轴使用周期性边界条件 (PBCs)。平板内部存在一个有界电荷密度，其净电荷为零，但沿 $z$ 轴的偶极矩不为零，该电荷密度被建模为两个高斯分布之差。您将通过在倒易空间中求解泊松方程来计算静电势，评估平板区域内的平均静电势，并使用此平均势作为均匀能带能量移动的代理。然后，您将实现一个偶极校正，该校正是一个分段线性的外加势，其导数能抵消真空区域中的平均电场，同时保持周期性。\n\n基本原理：\n- 一维泊松方程为 $d^2 V(z)/dz^2 = -\\rho(z)/\\varepsilon_0$，其中 $V(z)$ 是静电势，$\\rho(z)$ 是电荷密度，$\\varepsilon_0$ 是自由空间介电常数。\n- 在周期性边界条件下，倒易空间解将势的 $k=0$ 分量设置为选定的规范（此处为零），对于每个非零波矢 $k$ 得出：$V_k = \\rho_k / (\\varepsilon_0 k^2)$。\n\n规格说明：\n- 使用一个包含 $N$ 个点的离散网格，这些点均匀分布在 $[0, L_z)$ 区间内，网格间距为 $dz = L_z/N$，傅里叶波矢为 $k_n = 2\\pi n/L_z$，通过与这些定义一致的离散傅里叶变换来实现。\n- 将平板区域定义为长度为 $L_{\\mathrm{sl}}$ 的中心区间；真空区域是晶胞内的互补部分。\n- 将电荷密度定义为\n$$\n\\rho(z) = \\rho_0 \\left[\\exp\\left(-\\frac{(z-z_1)^2}{2\\sigma^2}\\right) - \\exp\\left(-\\frac{(z-z_2)^2}{2\\sigma^2}\\right)\\right],\n$$\n其中 $z_1$ 和 $z_2$ 位于平板区域内靠近两个平板表面的位置，$\\sigma$ 是高斯宽度，$\\rho_0$ 设置振幅。这种构造确保了净电荷为零和偶极矩不为零。\n- 通过使用带 PBCs 的倒易空间泊松解来求解势 $V(z)$，并利用微分对应于在傅里叶空间中乘以 $ik$ 的性质，在倒易空间中计算电场 $E(z) = -dV/dz$。\n- 实现一个偶极校正 $V_{\\mathrm{corr}}(z)$，它是一个分段线性函数，其导数在真空区域为常数 $s_{\\mathrm{vac}}$，在平板区域为常数 $s_{\\mathrm{sl}}$，并满足周期性约束 $s_{\\mathrm{vac}} L_{\\mathrm{vac}} + s_{\\mathrm{sl}} L_{\\mathrm{sl}} = 0$。设置 $s_{\\mathrm{vac}}$ 等于真空区域平均电场的负值，即 $s_{\\mathrm{vac}} = -\\langle E \\rangle_{\\mathrm{vac}}$，并从周期性约束确定 $s_{\\mathrm{sl}}$。选择 $V_{\\mathrm{corr}}(0) = 0$ 并减去其空间平均值以固定规范。\n- 对于每组参数，计算总势 $V_{\\mathrm{tot}}(z)$（无偶极校正时等于 $V(z)$，有偶极校正时等于 $V(z)+V_{\\mathrm{corr}}(z)$），然后计算 $V_{\\mathrm{tot}}(z)$ 在平板区域的平均值，记为 $\\langle V_{\\mathrm{slab}} \\rangle$。\n- 使用测试套件中具有偶极校正的最大真空厚度作为参考案例，并为每个测试案例报告绝对偏差 $\\Delta E = \\left|\\langle V_{\\mathrm{slab}} \\rangle - \\langle V_{\\mathrm{slab}} \\rangle_{\\mathrm{ref}}\\right|$。将此偏差视为由赝周期性镜像相互作用引起的均匀能带能量移动。\n\n单位和常数：\n- 使用 $L_{\\mathrm{sl}} = 10\\,\\text{\\AA}$ 和高斯宽度 $\\sigma = 0.5\\,\\text{\\AA}$。\n- 将高斯分布放置在 $z_1 = z_{\\mathrm{center}} - L_{\\mathrm{sl}}/2 + 0.8\\,\\text{\\AA}$ 和 $z_2 = z_{\\mathrm{center}} + L_{\\mathrm{sl}}/2 - 0.8\\,\\text{\\AA}$，其中 $z_{\\mathrm{center}}$ 是晶胞中心。\n- 使用振幅 $\\rho_0 = 10^{-3}\\,\\text{e}/\\text{\\AA}^3$（转换为 $\\text{C}/\\text{m}^3$），元电荷 $e = 1.602176634\\times 10^{-19}\\,\\text{C}$，$1\\,\\text{\\AA} = 10^{-10}\\,\\text{m}$，以及真空介电常数 $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\text{F}/\\text{m}$。\n- 所有能量偏差均以电子伏特 (eV) 表示。对于电荷为 $+e$ 的粒子，1 V 的静电势差对应于 1 eV 的能量差，因此您可以直接将以伏特为单位的势偏差报告为电子伏特。\n\n数值分辨率：\n- 对所有测试案例均使用 $N = 2048$ 个网格点。\n\n测试套件：\n- 测试套件由以下 $(L_{\\mathrm{vac}}, \\text{apply dipole correction})$ 对组成，其中 $L_{\\mathrm{vac}}$ 以 $\\text{\\AA}$ 为单位，布尔值指示是否应用偶极校正：\n    - $(5, \\text{False})$\n    - $(20, \\text{False})$\n    - $(60, \\text{False})$\n    - $(20, \\text{True})$\n    - $(5, \\text{True})$\n    - $(80, \\text{True})$，此项作为参考案例。\n\n输出要求：\n- 对于每个测试案例，计算 $\\Delta E$（单位为 $\\text{eV}$），即平板区域平均势相对于参考案例的绝对差值。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。将每个浮点数四舍五入到六位小数。\n\n此问题不涉及角度。此问题不涉及百分比。\n\n您最终的程序必须是一个完整、可运行的脚本，它能精确地实现上述规格，并且只使用允许的库。",
            "solution": "用户提供了一个问题陈述，要求开发一个一维谱方法求解器，以分析在周期性边界条件下的平板计算中的赝静电相互作用。在尝试给出解决方案之前，需要对该问题进行验证。\n\n### 第 1 步：提取已知条件\n- **系统：** 长度为 $L_z = L_{\\mathrm{sl}} + L_{\\mathrm{vac}}$ 的一维晶胞，具有周期性边界条件 (PBCs)。\n- **几何：** 厚度为 $L_{\\mathrm{sl}}$ 的中心平板，被总厚度为 $L_{\\mathrm{vac}}$ 的真空包围。\n- **离散化：** 在 $[0, L_z)$ 上有 $N$ 个网格点，间距为 $dz = L_z/N$。傅里叶波矢为 $k_n = 2\\pi n/L_z$。\n- **电荷密度：** $\\rho(z) = \\rho_0 \\left[\\exp\\left(-\\frac{(z-z_1)^2}{2\\sigma^2}\\right) - \\exp\\left(-\\frac{(z-z_2)^2}{2\\sigma^2}\\right)\\right]$。其净电荷为零，偶极矩不为零。\n- **物理原理：** 泊松方程 $d^2 V(z)/dz^2 = -\\rho(z)/\\varepsilon_0$。\n- **求解方法：** 倒易空间解 $V_k = \\rho_k / (\\varepsilon_0 k^2)$（对于 $k \\ne 0$），并设 $V_{k=0} = 0$。电场 $E(z) = -dV/dz$ 也在倒易空间中计算。\n- **偶极校正：** 添加一个分段线性势 $V_{\\mathrm{corr}}(z)$。其导数在平板 ($s_{\\mathrm{sl}}$) 和真空 ($s_{\\mathrm{vac}}$) 区域内为常数。\n- **校正约束：**\n    - 周期性：$s_{\\mathrm{vac}} L_{\\mathrm{vac}} + s_{\\mathrm{sl}} L_{\\mathrm{sl}} = 0$。\n    - 场抵消：$s_{\\mathrm{vac}} = -\\langle E \\rangle_{\\mathrm{vac}}$，其中 $\\langle E \\rangle_{\\mathrm{vac}}$ 是真空区域的平均电场。\n    - 规范：$V_{\\mathrm{corr}}(0) = 0$，然后减去其空间平均值。\n- **目标量：** 计算总势 $V_{\\mathrm{tot}}(z)$（无校正时为 $V(z)$，有校正时为 $V(z) + V_{\\mathrm{corr}}(z)$）在平板区域的平均值 $\\langle V_{\\mathrm{slab}} \\rangle$。\n- **参考：** 具有最大真空厚度和偶极校正的案例作为参考。\n- **输出：** 绝对偏差 $\\Delta E = \\left|\\langle V_{\\mathrm{slab}} \\rangle - \\langle V_{\\mathrm{slab}} \\rangle_{\\mathrm{ref}}\\right|$，单位为 eV。\n- **常数与参数：**\n    - $L_{\\mathrm{sl}} = 10\\,\\text{\\AA}$。\n    - $\\sigma = 0.5\\,\\text{\\AA}$。\n    - 高斯中心：$z_1 = z_{\\mathrm{center}} - L_{\\mathrm{sl}}/2 + 0.8\\,\\text{\\AA}$，$z_2 = z_{\\mathrm{center}} + L_{\\mathrm{sl}}/2 - 0.8\\,\\text{\\AA}$。\n    - $\\rho_0 = 10^{-3}\\,\\text{e}/\\text{\\AA}^3$。\n    - $e = 1.602176634\\times 10^{-19}\\,\\text{C}$。\n    - $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\text{F}/\\text{m}$。\n    - $1\\,\\text{\\AA} = 10^{-10}\\,\\text{m}$。\n    - $N = 2048$。\n- **测试套件：** $(L_{\\mathrm{vac}} [\\text{\\AA}], \\text{apply\\_corr})：(5, \\text{False}), (20, \\text{False}), (60, \\text{False}), (20, \\text{True}), (5, \\text{True}), (80, \\text{True})$。最后一个案例是参考案例。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地基于静电学和傅里叶分析的原理，这些是固态物理学和计算材料科学的基石。使用倒易空间泊松求解器、对具有偶极矩的平板进行建模以及实施偶极校正方案，都是第一性原理计算（例如密度泛函理论）中标准且成熟的技术。该问题在科学上是合理的。\n2.  **适定性：** 问题陈述提供了所有必要的物理常数、几何参数、电荷密度定义和数值参数（$N$）。它明确定义了求解泊松方程和构建偶极校正的程序。需要计算的量和用于比较的参考都得到了明确的规定。对于每个测试案例，都存在一个唯一且有意义的解。\n3.  **客观性：** 该问题使用精确的数学和物理语言来表述。它不含主观或基于观点的陈述。\n4.  **完整性与一致性：** 该问题是自洽的。提供的参数和约束足以构建数值求解器。偶极校正的描述虽然在规范固定指令上略有冗余（设置 $V_{\\mathrm{corr}}(0)=0$ 然后减去平均值），但在程序上是一致的，并能导出一个明确定义的势。\n5.  **现实性与可行性：** 物理参数（平板厚度等）对于原子模拟是现实的。数值分辨率（$N=2048$）对于指定的长度尺度和高斯电荷密度的平滑性质是足够的。\n\n### 第 3 步：结论与行动\n该问题是 **有效的**。它是一个源自计算物理学的、适定的、有科学依据的问题，可以使用提供的规格进行数值求解。我现在将着手构建解决方案。\n\n解决方案的开发首先将所有参数设置为国际单位制 (SI)。对于测试套件中定义的每个测试案例，我们构建一维网格和指定的电荷密度。求解器的核心涉及使用快速傅里叶变换 (FFT) 在倒易空间中求解泊松方程。\n\n在周期域 $[0, L_z)$ 上的函数 $f(z)$ 与其傅里叶级数系数 $c_m$ 之间的关系由 $f(z) = \\sum_m c_m e^{i k_m z}$ 给出，其中 $k_m = 2\\pi m/L_z$。在数值上，可以从函数在 $N$ 个网格点上的值 $f_j$ 来近似系数，即 $c_m \\approx \\frac{1}{N} \\text{FFT}(f)_m$。逆操作为 $f_j \\approx N \\times \\text{IFFT}(c)_j$。\n\n遵循此形式，我们对每个测试案例执行以下步骤：\n1.  在网格上计算电荷密度 $\\rho(z)$。\n2.  计算其 FFT，并确定傅里叶级数系数 $c_m^\\rho$。\n3.  使用倒易空间泊松方程 $c_m^V = c_m^\\rho / (\\varepsilon_0 k_m^2)$ 求出势的系数 $c_m^V$，其中 $m=0$ 的分量设置为零以固定规范并确保晶胞平均势为零。\n4.  通过逆 FFT 得到静电势 $V(z)$。\n5.  如果启用偶极校正，则从势的傅里叶系数计算电场 $E(z)$（$c_m^E = -i k_m c_m^V$）。\n6.  计算真空区域的平均电场 $\\langle E \\rangle_{\\mathrm{vac}}$。\n7.  构建分段线性校正势 $V_{\\mathrm{corr}}(z)$。其导数被定义为在真空区域抵消 $\\langle E \\rangle_{\\mathrm{vac}}$，同时保持周期性。该势从其导数积分得到，并减去其平均值以确保其在晶胞上的平均值也为零。\n8.  总势 $V_{\\mathrm{tot}}(z)$ 是 $V(z)$ 与（如果适用）$V_{\\mathrm{corr}}(z)$ 的和。\n9.  计算 $V_{\\mathrm{tot}}(z)$ 在中心平板区域的平均值。该值 $\\langle V_{\\mathrm{slab}} \\rangle$ 代表能量移动。\n\n在为所有测试案例计算出 $\\langle V_{\\mathrm{slab}} \\rangle$ 后，使用参考案例（$(L_{\\mathrm{vac}}=80\\,\\text{\\AA}, \\text{corr}=\\text{True})$）的值来计算所有其他案例的绝对偏差 $\\Delta E$。由于势的单位是伏特 (V)，对于电荷为 $+e$ 的粒子，此偏差在数值上等于以电子伏特 (eV) 为单位的能量移动。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spurious electrostatic interaction for a periodic slab model\n    and assesses the efficacy of a dipole correction.\n    \"\"\"\n    # Define physical constants and problem parameters in SI units\n    e = 1.602176634e-19  # Elementary charge in C\n    eps0 = 8.854187817e-12  # Vacuum permittivity in F/m\n    angstrom = 1e-10  # Angstrom to meter conversion\n\n    L_sl_A = 10.0  # Slab thickness in Angstrom\n    sigma_A = 0.5  # Gaussian width in Angstrom\n    rho0_e_A3 = 1e-3  # Charge density amplitude in e/Angstrom^3\n    N = 2048  # Number of grid points\n\n    L_sl = L_sl_A * angstrom\n    sigma = sigma_A * angstrom\n    rho0 = rho0_e_A3 * e / (angstrom**3)\n\n    test_cases = [\n        (5.0, False),\n        (20.0, False),\n        (60.0, False),\n        (20.0, True),\n        (5.0, True),\n        (80.0, True),  # Reference case\n    ]\n\n    slab_potentials = []\n\n    for L_vac_A, apply_corr in test_cases:\n        # 1. Define Grid and Geometry\n        L_vac = L_vac_A * angstrom\n        Lz = L_sl + L_vac\n        dz = Lz / N\n        z_grid = np.linspace(0, Lz, N, endpoint=False)\n        k_vec = 2 * np.pi * np.fft.fftfreq(N, d=dz)\n\n        # 2. Construct Charge Density\n        z_center = Lz / 2.0\n        gauss_offset = 0.8 * angstrom\n        z1 = z_center - L_sl / 2.0 + gauss_offset\n        z2 = z_center + L_sl / 2.0 - gauss_offset\n        rho_z = rho0 * (np.exp(-(z_grid - z1)**2 / (2 * sigma**2)) -\n                        np.exp(-(z_grid - z2)**2 / (2 * sigma**2)))\n\n        # 3. Solve Poisson Equation in Reciprocal Space\n        rho_k_fft = np.fft.fft(rho_z)\n        c_rho_k = rho_k_fft / N\n\n        c_V_k = np.zeros_like(c_rho_k, dtype=complex)\n        nonzero_k_mask = (k_vec != 0)\n        c_V_k[nonzero_k_mask] = c_rho_k[nonzero_k_mask] / (eps0 * k_vec[nonzero_k_mask]**2)\n\n        # The k=0 component is set to 0, which fixes the cell-average potential to 0.\n        \n        V_z = (N * np.fft.ifft(c_V_k)).real\n        V_total = V_z\n\n        # 4. Apply Dipole Correction if required\n        if apply_corr:\n            # a. Compute Electric Field\n            c_E_k = -1j * k_vec * c_V_k\n            E_z = (N * np.fft.ifft(c_E_k)).real\n\n            # b. Define slab/vacuum regions\n            slab_start = z_center - L_sl / 2.0\n            slab_end = z_center + L_sl / 2.0\n            slab_mask = (z_grid >= slab_start)  (z_grid  slab_end)\n            vac_mask = ~slab_mask\n            \n            # c. Calculate correction potential parameters\n            E_vac_avg = np.mean(E_z[vac_mask])\n            s_vac = -E_vac_avg\n            if L_sl > 0:\n                s_sl = -s_vac * L_vac / L_sl\n            else:\n                s_sl = 0\n\n            # d. Construct correction potential V_corr(z)\n            dV_corr_dz = np.full(N, s_vac)\n            dV_corr_dz[slab_mask] = s_sl\n            \n            # Integrate dV_corr/dz with V_corr(0)=0\n            V_prime_corr = np.cumsum(dV_corr_dz) * dz\n            # The simple cumsum results in V(z_i) = sum_{j=0 to i} f(z_j) dz.\n            # To get V(z_i) = sum_{j=0 to i-1} f(z_j) dz, we roll and set V(0)=0.\n            V_prime_corr = np.roll(V_prime_corr, 1)\n            V_prime_corr[0] = 0.0\n\n            # Subtract mean to enforce a zero-average potential over the cell\n            V_corr = V_prime_corr - np.mean(V_prime_corr)\n\n            V_total = V_z + V_corr\n\n        # 5. Calculate Average Slab Potential\n        slab_mask_avg = (z_grid >= z_center - L_sl / 2.0)  (z_grid  z_center + L_sl / 2.0)\n        V_slab_avg = np.mean(V_total[slab_mask_avg])\n        slab_potentials.append(V_slab_avg)\n\n    # 6. Compute Deviations from Reference Case\n    # The reference is the last case: (80, True)\n    V_slab_ref = slab_potentials[-1]\n    delta_E = [abs(v - V_slab_ref) for v in slab_potentials]\n\n    # 7. Print Final Output\n    print(f\"[{','.join([f'{x:.6f}' for x in delta_E])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "第一性原理计算（如DFT）能够提供精确的电子能带结构，但其高昂的计算成本限制了其在更大尺度模拟（如载流子输运或光学性质）中的直接应用。为了连接不同尺度，我们常常需要构建更简洁的有效模型，例如$k \\cdot p$哈密顿量。本实践将引导您完成一个完整的多尺度参数提取流程：通过将$k \\cdot p$模型的预测结果与“第一性原理”的能带数据进行拟合，来提取有效质量等关键参数，并验证该模型的有效性。这构成了从量子力学细节到宏观材料性质建模的核心技能。",
            "id": "3739491",
            "problem": "您的任务是为计算晶体半导体中高对称点附近的电子能带结构，构建一个完全指定的、多尺度的参数提取和验证工作流程。该多尺度接口介于简化的双带 $k \\cdot p$ 模型和由代表密度泛函理论（DFT）的底层“参考”模型生成的合成能带能量之间。您的目标是通过拟合高对称点附近的能量来恢复 $k \\cdot p$ 参数，并在指定的目标能量窗口内，对照完整（无噪声）的参考能量来验证拟合后的模型。\n\n此任务的基础包括：\n- 布洛赫定理以及作为 $k \\cdot p$ 方法基础的近布里渊区中心展开。\n- 高对称点 $\\Gamma$ 附近的双带各向同性有效哈密顿量，这是一种经过充分检验的标准形式，用于模拟靠近 $\\Gamma$ 点的直接带隙半导体。\n\n建模假设和定义：\n- 您将在导带类和价带类态的 $\\{ \\lvert c \\rangle, \\lvert v \\rangle \\}$ 基中处理双带各向同性 $k \\cdot p$ 哈密顿量，其参考能量零点设在带隙中央。对于波矢大小 $k$（以埃格斯特朗的倒数度量），有效哈密顿量为\n$$\nH(k) \\;=\\;\n\\begin{bmatrix}\n\\frac{E_g}{2} + A_c k^2  P k \\\\\nP k  -\\frac{E_g}{2} - A_v k^2\n\\end{bmatrix},\n$$\n其中 $E_g$（单位：电子伏特）、$A_c$ 和 $A_v$（单位：电子伏特-平方埃格斯特朗）以及 $P$（单位：电子伏特-埃格斯特朗）是待定参数。所有能量必须以电子伏特为单位，所有波矢大小必须以埃格斯特朗的倒数为单位。$H(k)$ 的特征值在每个 $k$ 点定义了两个能带能量；较低的能量是价带 $E_{-}(k)$，较高的能量是导带 $E_{+}(k)$。\n\n- 合成的“DFT”训练数据将通过对具有已知“真实”参数集的 $H(k)$ 进行对角化来生成，然后用规定标准差（单位：电子伏特）的加性独立高斯噪声污染这些能量，以模拟真实的数值或系统性差异。验证将对照“完整DFT”能带结构进行，在本问题中，这是来自相同真实参数集的无噪声数据。\n\n- 拟合必须仅使用 $k = 0$ 附近的小拟合域中的能量，以模仿 $k \\cdot p$ 展开的局域性。验证必须在更宽的域上将拟合模型的预测与完整的无噪声数据进行比较，但仅限于带隙中央周围指定的目标能量窗口内。\n\n您的程序必须实现以下步骤：\n1. 使用指定的真实参数对 $H(k)$ 进行对角化，在区间 $[0, k_{\\mathrm{fit,max}}]$ 的一维 $k$ 值网格上生成训练数据，然后添加具有给定标准差的高斯噪声，使用提供的随机种子以确保可复现性。在每个 $k$ 点，按升序对两个能带能量进行排序。\n2. 通过最小化模型的两个本征能量与拟合网格上带噪声的训练能量之间的最小二乘差，来拟合四个参数 $\\{E_g, A_c, A_v, P\\}$。使用边界条件强制 $E_g \\ge 0$, $A_c \\ge 0$, $A_v \\ge 0$ 和 $P \\ge 0$。\n3. 在 $[0, k_{\\mathrm{val,max}}]$ 区间内一个独立的均匀 $k$ 值网格上，通过与从相同真实参数获得的无噪声参考本征能量进行比较，来验证拟合的模型。将目标能量窗口定义为所有无噪声能带能量相对于中带隙零点的绝对值位于半宽 $W/2$ 内的点，其中 $W$ 是给定的总窗口宽度（单位均为电子伏特）。在验证网格上，计算拟合模型能量与无噪声能量之间的最大绝对误差，仅限于满足能量窗口标准的那些能带点。如果没有点满足能量窗口标准，则将最大绝对误差定义为 $0$。\n4. 对于每个测试用例，返回一个布尔值，指示最大绝对验证误差是否小于或等于指定的容差（单位：电子伏特）。\n\n重要单位和约定：\n- 所有能量均以电子伏特表示。\n- 所有波矢大小均以埃格斯特朗的倒数表示。\n- 此问题不涉及角度；无需指定角度单位。\n\n测试套件和参数：\n对于每个测试用例，提供以下元组：$(E_g^{\\mathrm{true}}, A_c^{\\mathrm{true}}, A_v^{\\mathrm{true}}, P^{\\mathrm{true}}, \\sigma_{\\mathrm{noise}}, k_{\\mathrm{fit,max}}, k_{\\mathrm{val,max}}, W, \\mathrm{seed})$。\n\n您必须在 $[0, k_{\\mathrm{fit,max}}]$ 上使用一个长度为 $N_{\\mathrm{fit}} = 25$ 的均匀拟合 $k$ 值网格，并在 $[0, k_{\\mathrm{val,max}}]$ 上使用一个长度为 $N_{\\mathrm{val}} = 201$ 的均匀验证网格。\n\n使用以下四个测试用例：\n- 案例 1：$(E_g^{\\mathrm{true}}, A_c^{\\mathrm{true}}, A_v^{\\mathrm{true}}, P^{\\mathrm{true}}, \\sigma_{\\mathrm{noise}}, k_{\\mathrm{fit,max}}, k_{\\mathrm{val,max}}, W, \\mathrm{seed}) = (\\,1.6,\\, 3.0,\\, 2.0,\\, 2.5,\\, 1.0\\times 10^{-4},\\, 0.06,\\, 0.30,\\, 2.0,\\, 123\\,)$。\n- 案例 2：$(\\,3.0,\\, 2.0,\\, 1.5,\\, 0.5,\\, 1.0\\times 10^{-4},\\, 0.05,\\, 0.30,\\, 3.2,\\, 456\\,)$。\n- 案例 3：$(\\,0.8,\\, 1.0,\\, 1.2,\\, 3.5,\\, 5.0\\times 10^{-4},\\, 0.04,\\, 0.30,\\, 1.0,\\, 789\\,)$。\n- 案例 4：$(\\,1.2,\\, 2.5,\\, 1.8,\\, 0.0,\\, 1.0\\times 10^{-3},\\, 0.05,\\, 0.30,\\, 1.5,\\, 42\\,)$。\n\n容差：\n- 当且仅当最大绝对验证误差小于或等于 $0.02$ 电子伏特时，一个测试用例才算通过。\n\n算法要求：\n- 目标函数必须在按能量排序后，比较每个 $k$ 点的两个能带。\n- 初始猜测值必须使用基本的小 $k$ 启发式方法从带噪声的训练数据中构建，不得使用任何关于真实参数的“先知”知识：从 $k=0$ 处的能量分离估计 $E_g$，从拟合网格上能带能量对 $k^2$ 的线性拟合估计 $A_c$ 和 $A_v$；如果无法仅从从小 $k$ 数据中推断出 $P$，则用一个小的正常数初始化它。\n- 在每个测试用例中，使用带有指定种子的确定性随机数生成器。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的布尔值逗号分隔列表形式的结果，按测试用例的顺序排列，例如，“[True,False,True,True]”。不允许有其他输出。",
            "solution": "所提出的问题是计算物理学领域中一个有效且定义明确的练习，特别是在多尺度建模和参数提取领域。它要求实现一个工作流程，通过拟合来自参考模型的合成数据来确定简化的 $k \\cdot p$ 模型的参数，然后进行验证步骤。该问题在半导体物理学方面有科学依据，在数学上是完备的，并且在算法上是明确的。我们将提供一个完整的解决方案。\n\n问题的核心是双带各向同性 $k \\cdot p$ 哈密顿量，它描述了高对称点 $\\Gamma$ 附近的电子能带结构。在导带类和价带类态的基 $\\{ \\lvert c \\rangle, \\lvert v \\rangle \\}$ 中，并将能量零点设置在带隙中央，该哈密顿量由以下公式给出：\n$$\nH(k) \\;=\\;\n\\begin{bmatrix}\n\\frac{E_g}{2} + A_c k^2  P k \\\\\nP k  -\\frac{E_g}{2} - A_v k^2\n\\end{bmatrix}\n$$\n在这里，$k$ 是波矢的大小，单位是埃格斯特朗的倒数（$ \\mathrm{\\AA}^{-1} $），$E_g$ 是带隙（单位 $ \\mathrm{eV} $），$A_c$ 和 $A_v$ 是曲率参数（单位 $ \\mathrm{eV} \\cdot \\mathrm{\\AA}^2 $），$P$ 是凯恩动量参数（单位 $ \\mathrm{eV} \\cdot \\mathrm{\\AA} $）。\n\n$H(k)$ 的特征值，记为 $E_{\\pm}(k)$，代表能带。它们可以通过求解特征方程 $\\det(H(k) - E\\mathbb{I}) = 0$ 来找到。这导出了二次方程 $E^2 - \\mathrm{Tr}(H)E + \\det(H) = 0$。迹和行列式为：\n$$\n\\mathrm{Tr}(H) = (A_c - A_v)k^2\n$$\n$$\n\\det(H) = \\left(\\frac{E_g}{2} + A_c k^2\\right)\\left(-\\frac{E_g}{2} - A_v k^2\\right) - (Pk)^2 = -\\frac{E_g^2}{4} - \\left(\\frac{E_g(A_c+A_v)}{2} + P^2\\right)k^2 - A_c A_v k^4\n$$\n使用二次公式 $E = (\\mathrm{Tr}(H) \\pm \\sqrt{\\mathrm{Tr}(H)^2 - 4\\det(H)})/2$ 求解 $E$，可以得到能带的解析表达式：\n$$\nE_{\\pm}(k) = \\frac{(A_c - A_v)k^2}{2} \\pm \\frac{1}{2}\\sqrt{\\left(E_g + (A_c+A_v)k^2\\right)^2 + 4 P^2 k^2}\n$$\n较高的能量 $E_+(k)$ 对应于导带，较低的能量 $E_-(k)$ 对应于价带。这种解析形式计算效率高，将用于计算模型能量。\n\n对于每个测试用例，整个工作流程包括四个主要步骤：\n\n**步骤 1：生成训练数据**\n对于每个测试用例，我们都给定一组“真实”参数 $\\{E_g^{\\mathrm{true}}, A_c^{\\mathrm{true}}, A_v^{\\mathrm{true}}, P^{\\mathrm{true}}\\}$。我们首先在区间 $[0, k_{\\mathrm{fit,max}}]$ 内生成一个包含 $N_{\\mathrm{fit}}=25$ 个波矢大小 $k$ 的均匀网格。使用带有真实参数的 $E_{\\pm}(k)$ 解析公式，我们计算此网格上的无噪声能带能量。然后，为了模拟来自更复杂模型（如密度泛函理论，DFT）的真实数据，我们向每个能量点添加具有指定标准差 $\\sigma_{\\mathrm{noise}}$ 的独立高斯噪声。为确保可复现性，每个案例都使用特定的随机种子。然后将每个 $k$ 点上产生的带噪声的能量按升序排序，以形成训练数据集。\n\n**步骤 2：参数拟合**\n目标是通过将模型的特征值 $E_{\\pm}(k)$ 拟合到带噪声的训练数据，来恢复四个模型参数 $\\{E_g, A_c, A_v, P\\}$。这被表述为一个非线性最小二乘优化问题。要最小化的目标函数是残差平方和：\n$$\n\\chi^2(E_g, A_c, A_v, P) = \\sum_{i=1}^{N_{\\mathrm{fit}}} \\left[ (E_{+}(k_i) - E_{\\mathrm{data},+,i})^2 + (E_{-}(k_i) - E_{\\mathrm{data},-,i})^2 \\right]\n$$\n其中 $E_{\\mathrm{data},\\pm,i}$ 是在波矢 $k_i$ 处的带噪声的训练能量。我们使用支持箱型约束的 L-BFGS-B 算法来强制施加物理边界条件 $E_g \\ge 0$, $A_c \\ge 0$, $A_v \\ge 0$ 和 $P \\ge 0$。\n\n优化的一个关键部分是为参数提供一个良好的初始猜测值。遵循问题的启发式要求：\n- $E_g^{\\mathrm{guess}}$：根据 $k=0$ 处带噪声能带的能量分离来估计，即 $E_g^{\\mathrm{guess}} = E_{\\mathrm{data},+}(k=0) - E_{\\mathrm{data},-}(k=0)$。\n- $A_c^{\\mathrm{guess}}$ 和 $A_v^{\\mathrm{guess}}$：根据能带能量对 $k^2$ 的线性拟合斜率来估计。对于小 $k$，忽略包含 $P$ 的耦合项，我们有 $E_+(k) \\approx \\frac{E_g}{2} + A_c k^2$ 和 $E_-(k) \\approx -\\frac{E_g}{2} - A_v k^2$。我们对上能带的噪声能量与 $k^2$ 进行线性回归以找到斜率，该斜率作为 $A_c^{\\mathrm{guess}}$。类似地，下能带能量对 $k^2$ 的回归斜率的负值提供了 $A_v^{\\mathrm{guess}}$。\n- $P^{\\mathrm{guess}}$：由于这个参数很难从这个简单的近似中直接推断出来，因此它被初始化为一个小的正常数，例如 $1.0$。\n\n**步骤 3：模型验证**\n一旦获得参数 $\\{E_g^{\\mathrm{fit}}, A_c^{\\mathrm{fit}}, A_v^{\\mathrm{fit}}, P^{\\mathrm{fit}}\\}$，就对拟合的模型进行验证。我们在区间 $[0, k_{\\mathrm{val,max}}]$ 内生成一个更精细的、包含 $N_{\\mathrm{val}}=201$ 个波矢的均匀网格。在此网格上，我们计算两组能带结构：\n1. 参考“完整 DFT”能量：$E_{\\pm}^{\\mathrm{true}}(k)$，使用真实参数计算，不含噪声。\n2. 拟合模型能量：$E_{\\pm}^{\\mathrm{fit}}(k)$，使用拟合参数计算。\n\n验证指标是这两组能量之间的最大绝对误差，但仅限于落在指定能量窗口内的点。能量窗口定义为 $|E^{\\mathrm{true}}(k)| \\le W/2$，其中 $W$ 是给定的总窗口宽度。如果验证网格上没有点满足此条件，则最大误差定义为 $0$。否则，它是窗口内所有点 $(k, \\pm)$ 上 $\\max(|E_{\\pm}^{\\mathrm{fit}}(k) - E_{\\pm}^{\\mathrm{true}}(k)|)$ 的值。\n\n**步骤 4：最终判定**\n对于每个测试用例，将计算出的最大绝对验证误差与 $0.02 \\, \\mathrm{eV}$ 的容差进行比较。如果误差小于或等于此容差，则测试用例通过，结果为 `True`；否则为 `False`。最终输出是这些布尔结果的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the multiscale parameter extraction and validation workflow.\n    \"\"\"\n    \n    # Test cases: (E_g_true, Ac_true, Av_true, P_true, sigma_noise, k_fit_max, k_val_max, W, seed)\n    test_cases = [\n        (1.6, 3.0, 2.0, 2.5, 1.0e-4, 0.06, 0.30, 2.0, 123),\n        (3.0, 2.0, 1.5, 0.5, 1.0e-4, 0.05, 0.30, 3.2, 456),\n        (0.8, 1.0, 1.2, 3.5, 5.0e-4, 0.04, 0.30, 1.0, 789),\n        (1.2, 2.5, 1.8, 0.0, 1.0e-3, 0.05, 0.30, 1.5, 42),\n    ]\n\n    # Constants from the problem description\n    N_FIT = 25\n    N_VAL = 201\n    VALIDATION_TOLERANCE = 0.02\n\n    results = []\n\n    def model_energies(k, params):\n        \"\"\"\n        Calculates the two-band k.p model eigenvalues.\n        \n        Args:\n            k (np.ndarray): Array of wavevector magnitudes.\n            params (tuple): A tuple of (E_g, A_c, A_v, P).\n        \n        Returns:\n            np.ndarray: An array of shape (len(k), 2) with sorted energies [E_-, E_+].\n        \"\"\"\n        E_g, A_c, A_v, P = params\n        k_sq = k**2\n        \n        # Using the analytical formula for eigenvalues\n        term1 = (A_c - A_v) * k_sq / 2.0\n        sqrt_term = np.sqrt((E_g + (A_c + A_v) * k_sq)**2 + 4.0 * P**2 * k_sq) / 2.0\n        \n        e_minus = term1 - sqrt_term\n        e_plus = term1 + sqrt_term\n        \n        return np.stack((e_minus, e_plus), axis=-1)\n\n    for case in test_cases:\n        E_g_true, Ac_true, Av_true, P_true, sigma_noise, k_fit_max, k_val_max, W, seed = case\n        true_params = (E_g_true, Ac_true, Av_true, P_true)\n\n        # 1. Generate training data\n        k_fit = np.linspace(0, k_fit_max, N_FIT)\n        E_true_fit = model_energies(k_fit, true_params)\n        \n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=sigma_noise, size=E_true_fit.shape)\n        \n        E_noisy_fit = E_true_fit + noise\n        E_noisy_fit.sort(axis=1) # Sort energies at each k-point\n\n        # 2. Fit the parameters\n        # 2a. Initial guess heuristic\n        E_g_guess = E_noisy_fit[0, 1] - E_noisy_fit[0, 0]\n        \n        k_fit_sq = k_fit**2\n        # Linear fit for Ac: E_c vs k^2\n        polyfit_c = np.polyfit(k_fit_sq, E_noisy_fit[:, 1], 1)\n        A_c_guess = polyfit_c[0]\n        \n        # Linear fit for Av: E_v vs k^2\n        polyfit_v = np.polyfit(k_fit_sq, E_noisy_fit[:, 0], 1)\n        A_v_guess = -polyfit_v[0]\n\n        P_guess = 1.0  # Small positive constant as required\n\n        initial_guess = [E_g_guess, A_c_guess, A_v_guess, P_guess]\n        # Ensure initial guesses for parameters with non-negative bounds are not negative\n        initial_guess = [max(0, val) for val in initial_guess]\n\n        # 2b. Objective function for least-squares minimization\n        def objective_func(p_fit, k_grid, E_data):\n            E_model = model_energies(k_grid, p_fit)\n            # Both model and data energies are sorted by construction\n            return np.sum((E_model - E_data)**2)\n\n        # 2c. Optimization\n        bounds = [(0, None), (0, None), (0, None), (0, None)]\n        opt_result = minimize(\n            fun=objective_func,\n            x0=initial_guess,\n            args=(k_fit, E_noisy_fit),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        fitted_params = opt_result.x\n\n        # 3. Validate the fitted model\n        k_val = np.linspace(0, k_val_max, N_VAL)\n        E_true_val = model_energies(k_val, true_params)\n        E_fitted_val = model_energies(k_val, fitted_params)\n\n        # Identify points within the target energy window\n        E_half_width = W / 2.0\n        within_window_mask = np.abs(E_true_val) = E_half_width\n        \n        if not np.any(within_window_mask):\n            max_abs_error = 0.0\n        else:\n            # Calculate errors only for points within the window\n            abs_errors = np.abs(E_fitted_val - E_true_val)\n            max_abs_error = np.max(abs_errors[within_window_mask])\n            \n        # 4. Compare with tolerance\n        is_pass = max_abs_error = VALIDATION_TOLERANCE\n        results.append(is_pass)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}