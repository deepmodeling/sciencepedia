{
    "hands_on_practices": [
        {
            "introduction": "Before we can analyze how tensor fields change from point to point, we must master how their components behave under a change of basis. This exercise provides fundamental practice in applying the transformation laws for a mixed type-$(1,1)$ tensor, which represents a linear operator . By performing an explicit calculation for a combined rotation and scaling, you will solidify your understanding of the similarity transformation and verify a crucial result: the invariance of the trace, a property that underlies many physical conservation laws.",
            "id": "3814228",
            "problem": "Consider a mixed tensor of type $(1,1)$ in $\\mathbb{R}^{3}$, represented by its components $T^{i}{}_{j}$ in the standard Cartesian basis $\\{\\mathbf{e}_{x}, \\mathbf{e}_{y}, \\mathbf{e}_{z}\\}$. Assume $T$ is the linear operator associated to the pointwise Jacobian of a smooth vector field at a fixed point, so its mixed components transform under similarity when the frame is actively changed by a linear map. In multiscale modeling, suppose the effective linear transformation that acts on the operator is a composition of a macroscale rotation and a microscale anisotropic scaling, specifically $A = S R$, where $R$ is a proper rotation by angle $\\theta$ about the $z$-axis, and $S$ is a diagonal scaling with distinct positive factors in each coordinate direction. Use the following fundamental definitions:\n\n- The transformation of a $(1,1)$ tensor under an invertible linear map $A$ is given by the similarity action $T' = A T A^{-1}$, which in components reads $T'^{i}{}_{j} = A^{i}{}_{k}\\,T^{k}{}_{l}\\,(A^{-1})^{l}{}_{j}$.\n- The rotation matrix about the $z$-axis by angle $\\theta$ in the standard basis is\n$$R = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1\\end{pmatrix}$$,\nand satisfies $R^{-1} = R^{\\top}$.\n- The anisotropic scaling is $S = \\operatorname{diag}(s_{x}, s_{y}, s_{z})$ with $s_{x}, s_{y}, s_{z} > 0$, and its inverse is $S^{-1} = \\operatorname{diag}(s_{x}^{-1}, s_{y}^{-1}, s_{z}^{-1})$.\n\nLet the original tensor $T$ be diagonal in the standard basis, $T = \\operatorname{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$, with $\\lambda_{1}, \\lambda_{2}, \\lambda_{3} \\in \\mathbb{R}$. Compute the explicit components $T'^{i}{}_{j}$ induced by $A = S R$ using only the above fundamental definitions from tensor calculus. Then, directly verify from these component expressions the invariance of the trace under similarity and provide the trace of $T'$ as a single closed-form analytic expression in terms of $\\lambda_{1}, \\lambda_{2}, \\lambda_{3}$, $\\theta$, and $s_{x}, s_{y}, s_{z}$. Your final answer must be that closed-form expression. If any intermediate simplifications are needed, express them symbolically and do not substitute numerical values.",
            "solution": "The problem is to compute the components of a transformed type-$(1,1)$ tensor $T'$ and subsequently find its trace, verifying the trace's invariance under the given similarity transformation. The transformation matrix $A$ is a composition of an anisotropic scaling $S$ and a rotation $R$, given by $A = SR$. The transformation rule for the tensor $T$ is $T' = A T A^{-1}$.\n\nFirst, we establish the matrix representations of the tensors and linear transformations in the standard Cartesian basis of $\\mathbb{R}^{3}$. The original tensor $T$ is given as a diagonal matrix:\n$$T = \\begin{pmatrix} \\lambda_{1} & 0 & 0 \\\\ 0 & \\lambda_{2} & 0 \\\\ 0 & 0 & \\lambda_{3} \\end{pmatrix}$$\nThe rotation matrix $R$ for a rotation by an angle $\\theta$ about the $z$-axis is:\n$$R = \\begin{pmatrix}\\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1\\end{pmatrix}$$\nThe anisotropic scaling matrix $S$ is:\n$$S = \\operatorname{diag}(s_{x}, s_{y}, s_{z}) = \\begin{pmatrix} s_{x} & 0 & 0 \\\\ 0 & s_{y} & 0 \\\\ 0 & 0 & s_{z} \\end{pmatrix}$$\nwhere $s_{x}, s_{y}, s_{z}$ are positive real numbers.\n\nThe composite transformation matrix $A$ is the product $SR$:\n$$A = SR = \\begin{pmatrix} s_{x} & 0 & 0 \\\\ 0 & s_{y} & 0 \\\\ 0 & 0 & s_{z} \\end{pmatrix} \\begin{pmatrix}\\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1\\end{pmatrix} = \\begin{pmatrix} s_{x}\\cos\\theta & -s_{x}\\sin\\theta & 0 \\\\ s_{y}\\sin\\theta & s_{y}\\cos\\theta & 0 \\\\ 0 & 0 & s_{z} \\end{pmatrix}$$\nNext, we determine the inverse transformation matrix $A^{-1} = (SR)^{-1} = R^{-1}S^{-1}$. The inverse of the rotation matrix is its transpose, $R^{-1} = R^{\\top}$, and the inverse of the diagonal scaling matrix is the diagonal matrix of the reciprocal scaling factors.\n$$R^{-1} = R^{\\top} = \\begin{pmatrix}\\cos\\theta & \\sin\\theta & 0 \\\\ -\\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1\\end{pmatrix}$$\n$$S^{-1} = \\operatorname{diag}(s_{x}^{-1}, s_{y}^{-1}, s_{z}^{-1}) = \\begin{pmatrix} s_{x}^{-1} & 0 & 0 \\\\ 0 & s_{y}^{-1} & 0 \\\\ 0 & 0 & s_{z}^{-1} \\end{pmatrix}$$\nTherefore, the inverse transformation matrix $A^{-1}$ is:\n$$A^{-1} = R^{-1}S^{-1} = \\begin{pmatrix}\\cos\\theta & \\sin\\theta & 0 \\\\ -\\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1\\end{pmatrix} \\begin{pmatrix} s_{x}^{-1} & 0 & 0 \\\\ 0 & s_{y}^{-1} & 0 \\\\ 0 & 0 & s_{z}^{-1} \\end{pmatrix} = \\begin{pmatrix} s_{x}^{-1}\\cos\\theta & s_{y}^{-1}\\sin\\theta & 0 \\\\ -s_{x}^{-1}\\sin\\theta & s_{y}^{-1}\\cos\\theta & 0 \\\\ 0 & 0 & s_{z}^{-1} \\end{pmatrix}$$\nTo find the components of the transformed tensor $T'$, we perform the matrix multiplication $T' = A T A^{-1}$. We first compute the intermediate product $AT$:\n$$AT = \\begin{pmatrix} s_{x}\\cos\\theta & -s_{x}\\sin\\theta & 0 \\\\ s_{y}\\sin\\theta & s_{y}\\cos\\theta & 0 \\\\ 0 & 0 & s_{z} \\end{pmatrix} \\begin{pmatrix} \\lambda_{1} & 0 & 0 \\\\ 0 & \\lambda_{2} & 0 \\\\ 0 & 0 & \\lambda_{3} \\end{pmatrix} = \\begin{pmatrix} \\lambda_{1}s_{x}\\cos\\theta & -\\lambda_{2}s_{x}\\sin\\theta & 0 \\\\ \\lambda_{1}s_{y}\\sin\\theta & \\lambda_{2}s_{y}\\cos\\theta & 0 \\\\ 0 & 0 & \\lambda_{3}s_{z} \\end{pmatrix}$$\nNow, we compute the final product $T' = (AT)A^{-1}$:\n$$T' = \\begin{pmatrix} \\lambda_{1}s_{x}\\cos\\theta & -\\lambda_{2}s_{x}\\sin\\theta & 0 \\\\ \\lambda_{1}s_{y}\\sin\\theta & \\lambda_{2}s_{y}\\cos\\theta & 0 \\\\ 0 & 0 & \\lambda_{3}s_{z} \\end{pmatrix} \\begin{pmatrix} s_{x}^{-1}\\cos\\theta & s_{y}^{-1}\\sin\\theta & 0 \\\\ -s_{x}^{-1}\\sin\\theta & s_{y}^{-1}\\cos\\theta & 0 \\\\ 0 & 0 & s_{z}^{-1} \\end{pmatrix}$$\nThe explicit components $T'^{i}{}_{j}$ are found by carrying out the multiplication:\n$T'^{1}{}_{1} = (\\lambda_{1}s_{x}\\cos\\theta)(s_{x}^{-1}\\cos\\theta) + (-\\lambda_{2}s_{x}\\sin\\theta)(-s_{x}^{-1}\\sin\\theta) = \\lambda_{1}\\cos^{2}\\theta + \\lambda_{2}\\sin^{2}\\theta$\n$T'^{1}{}_{2} = (\\lambda_{1}s_{x}\\cos\\theta)(s_{y}^{-1}\\sin\\theta) + (-\\lambda_{2}s_{x}\\sin\\theta)(s_{y}^{-1}\\cos\\theta) = s_{x}s_{y}^{-1}(\\lambda_{1}-\\lambda_{2})\\sin\\theta\\cos\\theta$\n$T'^{1}{}_{3} = 0$\n\n$T'^{2}{}_{1} = (\\lambda_{1}s_{y}\\sin\\theta)(s_{x}^{-1}\\cos\\theta) + (\\lambda_{2}s_{y}\\cos\\theta)(-s_{x}^{-1}\\sin\\theta) = s_{y}s_{x}^{-1}(\\lambda_{1}-\\lambda_{2})\\sin\\theta\\cos\\theta$\n$T'^{2}{}_{2} = (\\lambda_{1}s_{y}\\sin\\theta)(s_{y}^{-1}\\sin\\theta) + (\\lambda_{2}s_{y}\\cos\\theta)(s_{y}^{-1}\\cos\\theta) = \\lambda_{1}\\sin^{2}\\theta + \\lambda_{2}\\cos^{2}\\theta$\n$T'^{2}{}_{3} = 0$\n\n$T'^{3}{}_{1} = 0$\n$T'^{3}{}_{2} = 0$\n$T'^{3}{}_{3} = (\\lambda_{3}s_{z})(s_{z}^{-1}) = \\lambda_{3}$\n\nThe complete matrix of components for the transformed tensor $T'$ is:\n$$ T' = \\begin{pmatrix} \\lambda_{1}\\cos^{2}\\theta + \\lambda_{2}\\sin^{2}\\theta & s_{x}s_{y}^{-1}(\\lambda_{1}-\\lambda_{2})\\sin\\theta\\cos\\theta & 0 \\\\ s_{y}s_{x}^{-1}(\\lambda_{1}-\\lambda_{2})\\sin\\theta\\cos\\theta & \\lambda_{1}\\sin^{2}\\theta + \\lambda_{2}\\cos^{2}\\theta & 0 \\\\ 0 & 0 & \\lambda_{3} \\end{pmatrix} $$\nThe second part of the problem is to compute the trace of $T'$, denoted $\\operatorname{tr}(T')$, and verify its invariance. The trace is the sum of the diagonal components, $\\operatorname{tr}(T') = \\sum_{i=1}^{3} T'^{i}{}_{i}$.\n$$\\operatorname{tr}(T') = T'^{1}{}_{1} + T'^{2}{}_{2} + T'^{3}{}_{3}$$\nSubstituting the expressions for the diagonal components:\n$$\\operatorname{tr}(T') = (\\lambda_{1}\\cos^{2}\\theta + \\lambda_{2}\\sin^{2}\\theta) + (\\lambda_{1}\\sin^{2}\\theta + \\lambda_{2}\\cos^{2}\\theta) + \\lambda_{3}$$\nWe group the terms by the eigenvalues $\\lambda_{i}$:\n$$\\operatorname{tr}(T') = \\lambda_{1}(\\cos^{2}\\theta + \\sin^{2}\\theta) + \\lambda_{2}(\\sin^{2}\\theta + \\cos^{2}\\theta) + \\lambda_{3}$$\nUsing the fundamental trigonometric identity $\\cos^{2}\\theta + \\sin^{2}\\theta = 1$, the expression simplifies:\n$$\\operatorname{tr}(T') = \\lambda_{1}(1) + \\lambda_{2}(1) + \\lambda_{3} = \\lambda_{1} + \\lambda_{2} + \\lambda_{3}$$\nThe trace of the original tensor is $\\operatorname{tr}(T) = \\lambda_{1} + \\lambda_{2} + \\lambda_{3}$. Our direct calculation shows that $\\operatorname{tr}(T') = \\operatorname{tr}(T)$, thereby verifying the invariance of the trace under this similarity transformation. It is notable that the result is independent of both the rotation angle $\\theta$ and the scaling factors $s_{x}, s_{y}, s_{z}$.\n\nThe final requested output is the closed-form analytic expression for the trace of $T'$.",
            "answer": "$$\\boxed{\\lambda_{1} + \\lambda_{2} + \\lambda_{3}}$$"
        },
        {
            "introduction": "Physical laws must be independent of the coordinate system we choose, but their mathematical expression often changes. To properly formulate differential operators like the gradient or divergence in curvilinear coordinates, we need the machinery of the Levi-Civita connection, whose components are the Christoffel symbols. This practice guides you through the essential process of calculating these symbols directly from the metric tensor for the ubiquitous cylindrical coordinate system . Mastering this calculation is a rite of passage for moving beyond Cartesian space and modeling phenomena in geometries that match the real world.",
            "id": "3814218",
            "problem": "In multiscale modeling of axisymmetric media, anisotropic operators often appear in coordinate systems adapted to the geometry. Consider the standard three-dimensional Euclidean space with line element $ds^2 = dx^2 + dy^2 + dz^2$. Introduce cylindrical coordinates $(r,\\theta,z)$ defined by the smooth invertible map $x = r \\cos\\theta$, $y = r \\sin\\theta$, and $z = z$, with $r > 0$ and $\\theta \\in (0,2\\pi)$. Let $g_{ij}$ denote the components of the induced Riemannian metric in the coordinate basis $\\{\\partial_{r},\\partial_{\\theta},\\partial_{z}\\}$, and let $\\Gamma^{i}_{\\;jk}$ denote the Christoffel symbols of the Levi-Civita connection (the unique torsion-free, metric-compatible connection) associated with $g_{ij}$.\n\nStarting from the Euclidean line element and the coordinate transformation given above as the fundamental base, perform the following:\n\n1. Derive the metric components $g_{ij}(r,\\theta,z)$ in cylindrical coordinates by expressing $ds^2$ in terms of $(dr,d\\theta,dz)$ and identify $g_{ij}$.\n2. Using only the defining properties of the Levi-Civita connection (torsion-free and metric-compatibility) as the starting point, compute the Christoffel symbols $\\Gamma^{i}_{\\;jk}$ for the $(r,\\theta,z)$ chart. Do not employ any pre-tabulated formula; instead, derive the expression for $\\Gamma^{i}_{\\;jk}$ from these properties and apply it to the metric found in part 1.\n3. Verify your computed expressions by cross-checking with the derivatives of the metric components via metric-compatibility, that is, by showing $\\nabla_{k} g_{ij} = 0$ for at least two distinct nontrivial index triples $(i,j,k)$ for which $\\partial_{k} g_{ij} \\neq 0$ or for which the Christoffel symbols you found contribute nontrivially.\n4. Report the nonzero Christoffel symbols in the ordered triple $(\\Gamma^{r}_{\\;\\theta\\theta},\\Gamma^{\\theta}_{\\;r\\theta},\\Gamma^{\\theta}_{\\;\\theta r})$ as a single closed-form analytic expression. If any additional symbols appear to be nonzero, justify whether they vanish or not before final reporting.\n\nYour final answer must be a single closed-form analytic expression containing exactly the ordered triple specified above. No rounding is required and no units are involved.",
            "solution": "The problem as stated is a standard, well-posed exercise in differential geometry and is therefore valid. It is scientifically grounded, self-contained, and objective. We shall proceed with the solution by following the four specified tasks. The coordinate system is $(x^1, x^2, x^3) = (r, \\theta, z)$.\n\n**Part 1: Derivation of the metric components $g_{ij}$**\n\nWe begin with the Euclidean line element in Cartesian coordinates $(x,y,z)$, given as $ds^2 = dx^2 + dy^2 + dz^2$. The transformation to cylindrical coordinates $(r,\\theta,z)$ is defined by:\n$$x = r \\cos\\theta$$\n$$y = r \\sin\\theta$$\n$$z = z$$\nWe compute the total differentials of $x$, $y$, and $z$:\n$$dx = \\frac{\\partial x}{\\partial r}dr + \\frac{\\partial x}{\\partial \\theta}d\\theta + \\frac{\\partial x}{\\partial z}dz = (\\cos\\theta)dr - (r\\sin\\theta)d\\theta$$\n$$dy = \\frac{\\partial y}{\\partial r}dr + \\frac{\\partial y}{\\partial \\theta}d\\theta + \\frac{\\partial y}{\\partial z}dz = (\\sin\\theta)dr + (r\\cos\\theta)d\\theta$$\n$$dz = dz$$\nNext, we substitute these expressions into the line element $ds^2$:\n$$ds^2 = ((\\cos\\theta)dr - (r\\sin\\theta)d\\theta)^2 + ((\\sin\\theta)dr + (r\\cos\\theta)d\\theta)^2 + (dz)^2$$\nExpanding the squared terms:\n$$ds^2 = (\\cos^2\\theta dr^2 - 2r\\sin\\theta\\cos\\theta dr d\\theta + r^2\\sin^2\\theta d\\theta^2) + (\\sin^2\\theta dr^2 + 2r\\sin\\theta\\cos\\theta dr d\\theta + r^2\\cos^2\\theta d\\theta^2) + dz^2$$\nWe group the terms by the differentials $dr$, $d\\theta$, and $dz$:\n$$ds^2 = (\\cos^2\\theta + \\sin^2\\theta)dr^2 + (r^2\\sin^2\\theta + r^2\\cos^2\\theta)d\\theta^2 + dz^2$$\nUsing the trigonometric identity $\\sin^2\\theta + \\cos^2\\theta = 1$, we simplify the expression:\n$$ds^2 = (1)dr^2 + r^2(1)d\\theta^2 + dz^2 = dr^2 + r^2 d\\theta^2 + dz^2$$\nThe line element is also defined in terms of the metric tensor $g_{ij}$ as $ds^2 = g_{ij}dx^i dx^j$. By comparing this general form with our derived expression, we identify the components of the metric tensor. Since there are no cross-terms like $dr d\\theta$, the metric is diagonal.\nThe components are:\n$g_{rr} \\equiv g_{11} = 1$\n$g_{\\theta\\theta} \\equiv g_{22} = r^2$\n$g_{zz} \\equiv g_{33} = 1$\nAll off-diagonal components $g_{ij}$ are zero for $i \\neq j$. In matrix form, the metric tensor is:\n$$g_{ij} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & r^2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$$\nThe inverse metric tensor $g^{ij}$ is the matrix inverse of $g_{ij}$:\n$$g^{ij} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & r^{-2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$$\n\n**Part 2: Computation of Christoffel symbols from first principles**\n\nThe Levi-Civita connection $\\nabla$ is defined by two properties: it is torsion-free and metric-compatible.\n$1$. Torsion-free: For any coordinate basis vectors $\\partial_i, \\partial_j$, the commutator is related to the connection coefficients (Christoffel symbols) by $[\\partial_i, \\partial_j] = \\nabla_{\\partial_i}\\partial_j - \\nabla_{\\partial_j}\\partial_i$. Since $[\\partial_i, \\partial_j] = 0$, this implies $\\nabla_{\\partial_i}\\partial_j = \\nabla_{\\partial_j}\\partial_i$. In terms of components, this gives the symmetry property $\\Gamma^k_{ij} = \\Gamma^k_{ji}$.\n$2$. Metric-compatible: The covariant derivative of the metric tensor is zero, $\\nabla_k g_{ij} = 0$. Expanding this gives:\n$$ \\partial_k g_{ij} - \\Gamma^l_{ik} g_{lj} - \\Gamma^l_{jk} g_{il} = 0 \\quad (*)$$\nWe derive the formula for the Christoffel symbols by cyclically permuting the indices $(i, j, k)$ in equation $(*)$:\n$$ \\partial_k g_{ij} = \\Gamma^l_{ik} g_{lj} + \\Gamma^l_{jk} g_{il} \\quad (1) $$\n$$ \\partial_i g_{jk} = \\Gamma^l_{ji} g_{lk} + \\Gamma^l_{ki} g_{jl} \\quad (2) $$\n$$ \\partial_j g_{ki} = \\Gamma^l_{kj} g_{li} + \\Gamma^l_{ij} g_{lk} \\quad (3) $$\nWe then compute the combination $(2) + (3) - (1)$:\n$$ \\partial_i g_{jk} + \\partial_j g_{ki} - \\partial_k g_{ij} = (\\Gamma^l_{ji} g_{lk} + \\Gamma^l_{ki} g_{jl}) + (\\Gamma^l_{kj} g_{li} + \\Gamma^l_{ij} g_{lk}) - (\\Gamma^l_{ik} g_{lj} + \\Gamma^l_{jk} g_{il}) $$\nUsing the symmetry of the Christoffel symbols ($\\Gamma^l_{ab}=\\Gamma^l_{ba}$) and the metric tensor ($g_{ab}=g_{ba}$), we can simplify the right-hand side. The terms $\\Gamma^l_{ki}g_{jl}$ and $-\\Gamma^l_{ik}g_{lj}$ cancel, and the terms $\\Gamma^l_{kj}g_{li}$ and $-\\Gamma^l_{jk}g_{il}$ cancel. We are left with:\n$$ \\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij} = 2 \\Gamma^l_{ij} g_{lk} $$\nMultiplying by the inverse metric component $g^{km}$ and summing over $k$ yields:\n$$ g^{km}(\\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij}) = 2 g^{km} g_{lk} \\Gamma^l_{ij} $$\nUsing the property $g^{km}g_{lk} = \\delta^m_l$, we get:\n$$ g^{km}(\\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij}) = 2 \\delta^m_l \\Gamma^l_{ij} = 2 \\Gamma^m_{ij} $$\nThis gives the explicit formula for the Christoffel symbols, derived from first principles as requested:\n$$ \\Gamma^m_{ij} = \\frac{1}{2} g^{mk} (\\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij}) $$\nNow we apply this formula. The metric components only depend on $r \\equiv x^1$. Therefore, any derivative $\\partial_k g_{ij}$ is zero unless the index $k$ corresponds to $r$. The only non-zero partial derivative of a metric component is:\n$$ \\partial_r g_{\\theta\\theta} = \\partial_1 g_{22} = \\frac{\\partial}{\\partial r}(r^2) = 2r $$\nAll other derivatives $\\partial_k g_{ij}$ are zero. This significantly simplifies the calculation. The term $(\\partial_i g_{jk} + \\partial_j g_{ik} - \\partial_k g_{ij})$ can be non-zero only if one of the derivatives is $\\partial_r g_{\\theta\\theta}$, which requires the indices $(i,j,k)$ to contain one instance of $r$ and two of $\\theta$.\n\nWe calculate the non-zero symbols:\nCase 1: $\\Gamma^m_{\\theta\\theta} \\equiv \\Gamma^m_{22}$\n$$ \\Gamma^m_{22} = \\frac{1}{2} g^{mk} (\\partial_2 g_{2k} + \\partial_2 g_{2k} - \\partial_k g_{22}) = \\frac{1}{2} g^{mk} (2\\partial_\\theta g_{\\theta k} - \\partial_k g_{\\theta\\theta}) $$\nSince no metric component depends on $\\theta$, $\\partial_\\theta g_{\\theta k}=0$.\n$$ \\Gamma^m_{22} = -\\frac{1}{2} g^{mk} (\\partial_k g_{\\theta\\theta}) $$\nThe derivative $\\partial_k g_{\\theta\\theta}$ is non-zero only for $k=1$ (i.e., $k=r$). So we only need to consider the $k=r$ term in the sum.\n$$ \\Gamma^m_{\\theta\\theta} = -\\frac{1}{2} g^{mr} (\\partial_r g_{\\theta\\theta}) = -\\frac{1}{2} g^{mr} (2r) = -r g^{mr} $$\nThe inverse metric component $g^{mr}$ is non-zero only for $m=r$, where $g^{rr}=1$. Thus, the only non-zero symbol is for $m=r$:\n$$ \\Gamma^r_{\\theta\\theta} = -r g^{rr} = -r(1) = -r $$\n\nCase 2: $\\Gamma^m_{r\\theta} \\equiv \\Gamma^m_{12}$\n$$ \\Gamma^m_{12} = \\frac{1}{2} g^{mk} (\\partial_1 g_{2k} + \\partial_2 g_{1k} - \\partial_k g_{12}) $$\nWe have $g_{12}=g_{r\\theta}=0$. $\\partial_2 g_{1k} = \\partial_\\theta g_{rk}=0$ as no component depends on $\\theta$.\n$$ \\Gamma^m_{12} = \\frac{1}{2} g^{mk} (\\partial_1 g_{2k}) = \\frac{1}{2} g^{mk} (\\partial_r g_{\\theta k}) $$\nThe derivative $\\partial_r g_{\\theta k}$ is non-zero only for $k=2$ (i.e., $k=\\theta$). So we only take the $k=\\theta$ term.\n$$ \\Gamma^m_{r\\theta} = \\frac{1}{2} g^{m\\theta} (\\partial_r g_{\\theta\\theta}) = \\frac{1}{2} g^{m\\theta} (2r) = r g^{m\\theta} $$\nThe component $g^{m\\theta}$ is non-zero only for $m=\\theta$, where $g^{\\theta\\theta}=r^{-2}$. Thus, the only non-zero symbol is for $m=\\theta$:\n$$ \\Gamma^\\theta_{r\\theta} = r g^{\\theta\\theta} = r(r^{-2}) = \\frac{1}{r} $$\nBy symmetry of the connection, $\\Gamma^\\theta_{\\theta r} = \\Gamma^\\theta_{r\\theta} = \\frac{1}{r}$. All other Christoffel symbols are zero.\n\n**Part 3: Verification via metric compatibility**\n\nWe must verify $\\nabla_{k} g_{ij} = \\partial_{k} g_{ij} - \\Gamma^{l}_{ik} g_{lj} - \\Gamma^{l}_{jk} g_{il} = 0$ for two non-trivial cases.\n\nVerification 1: $(i,j,k) = (\\theta, \\theta, r)$. This case is non-trivial as $\\partial_r g_{\\theta\\theta} \\neq 0$.\nWe need to show $\\nabla_r g_{\\theta\\theta} = 0$.\n$$ \\partial_r g_{\\theta\\theta} - \\Gamma^l_{\\theta r} g_{l\\theta} - \\Gamma^l_{\\theta r} g_{\\theta l} = 0 $$\n$$ \\partial_r g_{\\theta\\theta} - 2\\Gamma^l_{\\theta r} g_{l\\theta} = 0 $$\nExpanding the sum over $l \\in \\{r, \\theta, z\\}$:\n$$ \\partial_r g_{\\theta\\theta} - 2(\\Gamma^r_{\\theta r} g_{r\\theta} + \\Gamma^\\theta_{\\theta r} g_{\\theta\\theta} + \\Gamma^z_{\\theta r} g_{z\\theta}) = 0 $$\nUsing our computed values and known metric components: $\\Gamma^r_{\\theta r}=0$, $\\Gamma^z_{\\theta r}=0$, $g_{r\\theta}=0$, $g_{z\\theta}=0$. The equation simplifies to:\n$$ \\partial_r g_{\\theta\\theta} - 2 \\Gamma^\\theta_{\\theta r} g_{\\theta\\theta} = 0 $$\nSubstituting the expressions:\n$$ \\frac{\\partial}{\\partial r}(r^2) - 2 \\left(\\frac{1}{r}\\right) (r^2) = 2r - 2r = 0 $$\nThe condition is satisfied.\n\nVerification 2: $(i,j,k) = (r, \\theta, \\theta)$. This case is non-trivial as the Christoffel symbols contribute non-trivially.\nWe need to show $\\nabla_\\theta g_{r\\theta} = 0$.\n$$ \\partial_\\theta g_{r\\theta} - \\Gamma^l_{r\\theta} g_{l\\theta} - \\Gamma^l_{\\theta\\theta} g_{rl} = 0 $$\nSince $g_{r\\theta}=0$, its derivative $\\partial_\\theta g_{r\\theta}$ is also $0$. The condition becomes:\n$$ \\Gamma^l_{r\\theta} g_{l\\theta} + \\Gamma^l_{\\theta\\theta} g_{rl} = 0 $$\nWe expand both sums over $l$:\nFirst term: $\\Gamma^l_{r\\theta} g_{l\\theta} = \\Gamma^r_{r\\theta} g_{r\\theta} + \\Gamma^\\theta_{r\\theta} g_{\\theta\\theta} + \\Gamma^z_{r\\theta} g_{z\\theta}$.\nSubstituting values: $(0)(0) + (\\frac{1}{r})(r^2) + (0)(0) = r$.\nSecond term: $\\Gamma^l_{\\theta\\theta} g_{rl} = \\Gamma^r_{\\theta\\theta} g_{rr} + \\Gamma^\\theta_{\\theta\\theta} g_{r\\theta} + \\Gamma^z_{\\theta\\theta} g_{rz}$.\nSubstituting values: $(-r)(1) + (0)(0) + (0)(0) = -r$.\nPlugging these back into the condition: $r + (-r) = 0$.\nThe condition is satisfied.\n\n**Part 4: Final reported values**\n\nThe non-zero Christoffel symbols are $\\Gamma^{r}_{\\theta\\theta} = -r$ and $\\Gamma^{\\theta}_{r\\theta} = \\Gamma^{\\theta}_{\\theta r} = \\frac{1}{r}$.\nThe problem asks for the ordered triple $(\\Gamma^{r}_{\\;\\theta\\theta},\\Gamma^{\\theta}_{\\;r\\theta},\\Gamma^{\\theta}_{\\;\\theta r})$.\nThis corresponds to the values $(-r, \\frac{1}{r}, \\frac{1}{r})$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -r & \\frac{1}{r} & \\frac{1}{r} \\end{pmatrix} } $$"
        },
        {
            "introduction": "The ultimate goal of learning tensor calculus in this field is to build and analyze models of complex, multiscale systems. This final practice bridges the gap between abstract theory and computational practice by tackling a diffusion problem with a highly heterogeneous tensor coefficient . You will implement a Multiscale Finite Element Method (MsFEM), a powerful technique that relies on the variational formulation of differential operators and the concept of a homogenized effective tensor. This exercise demonstrates how the rigorous language of tensors is not just a theoretical construct, but a practical tool for simulating real-world materials with intricate microstructures.",
            "id": "3814244",
            "problem": "Consider the second-order linear diffusion equation in two spatial dimensions with a spatially varying, symmetric positive-definite tensor coefficient. Let the computational domain be the unit square $\\Omega = [0,1] \\times [0,1]$. The governing equation is\n$$\n-\\nabla \\cdot \\left( A(\\mathbf{x}) \\nabla u(\\mathbf{x}) \\right) = f(\\mathbf{x}) \\quad \\text{in } \\Omega,\n$$\nwith homogeneous Dirichlet boundary condition $u(\\mathbf{x}) = 0$ on $\\partial \\Omega$. The tensor field $A(\\mathbf{x}) \\in \\mathbb{R}^{2 \\times 2}$ is symmetric positive-definite for all $\\mathbf{x} \\in \\Omega$. The source $f(\\mathbf{x})$ is a given scalar function.\n\nFrom tensor calculus and differential operators, the flux is defined as $\\mathbf{q}(\\mathbf{x}) = A(\\mathbf{x}) \\nabla u(\\mathbf{x})$, and the divergence operator applied to the flux yields the governing equation. At advanced graduate level, this problem investigates a Multiscale Finite Element Method (MsFEM) construction that uses local basis functions designed to capture subgrid heterogeneity in $A(\\mathbf{x})$ and produces a piecewise-constant effective tensor on a coarse mesh, then solves a coarse-scale problem and compares it to a fine-scale reference solution.\n\nStarting from the core definitions:\n- The flux is $\\mathbf{q}(\\mathbf{x}) = A(\\mathbf{x}) \\nabla u(\\mathbf{x})$.\n- The divergence of the flux satisfies $-\\nabla \\cdot \\mathbf{q}(\\mathbf{x}) = f(\\mathbf{x})$.\n- Symmetry and positive-definiteness of $A(\\mathbf{x})$ imply well-posedness of the weak form on appropriate function spaces.\n\nYou must implement the following, strictly based on these fundamental definitions and the variational formulation of the diffusion operator, without using any shortcut formulas not derived from these bases:\n\n1. Construct a fine-scale reference solution on a uniform triangular finite element mesh of $\\Omega$, using piecewise linear basis functions on triangles. Assemble the global stiffness matrix by integrating, on each triangle, the bilinear form induced by $A(\\mathbf{x})$ and the gradients of the basis functions, and assemble the load vector for a given $f(\\mathbf{x})$. Apply homogeneous Dirichlet boundary conditions and solve the resulting linear system to obtain the fine-scale nodal solution $u_{\\text{fine}}$.\n\n2. Define a coarse partition of $\\Omega$ into axis-aligned rectangular elements. For each coarse element $K \\subset \\Omega$, construct two local basis functions by solving the following local boundary value problems on a sufficiently resolved local triangular mesh restricted to $K$:\n   - For the first local problem, find $u_K^{(1)}$ on $K$ satisfying $-\\nabla \\cdot \\left( A(\\mathbf{x}) \\nabla u_K^{(1)}(\\mathbf{x}) \\right) = 0$ in $K$ with Dirichlet boundary data $u_K^{(1)}(\\mathbf{x}) = x$ on $\\partial K$.\n   - For the second local problem, find $u_K^{(2)}$ on $K$ satisfying $-\\nabla \\cdot \\left( A(\\mathbf{x}) \\nabla u_K^{(2)}(\\mathbf{x}) \\right) = 0$ in $K$ with Dirichlet boundary data $u_K^{(2)}(\\mathbf{x}) = y$ on $\\partial K$.\n   In both cases, assemble the local stiffness matrix as in the fine-scale case and enforce the nonhomogeneous Dirichlet data by eliminating boundary degrees of freedom. For each solution $u_K^{(i)}$, compute the local average flux vector\n   $$\n   \\overline{\\mathbf{q}}_K^{(i)} = \\frac{1}{|K|} \\int_K A(\\mathbf{x}) \\nabla u_K^{(i)}(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x},\n   $$\n   where $|K|$ is the area of the coarse element $K$. Use the pair $\\left( \\overline{\\mathbf{q}}_K^{(1)}, \\overline{\\mathbf{q}}_K^{(2)} \\right)$ to define a coarse effective tensor $A_K^{\\ast} \\in \\mathbb{R}^{2 \\times 2}$ by taking its columns as these average fluxes:\n   $$\n   A_K^{\\ast} \\, \\mathbf{e}_1 = \\overline{\\mathbf{q}}_K^{(1)}, \\quad A_K^{\\ast} \\, \\mathbf{e}_2 = \\overline{\\mathbf{q}}_K^{(2)},\n   $$\n   where $\\mathbf{e}_1 = (1,0)^{\\top}$ and $\\mathbf{e}_2 = (0,1)^{\\top}$ are the canonical basis vectors of $\\mathbb{R}^2$.\n\n3. Assemble and solve a coarse-scale finite element problem on the coarse mesh using piecewise constant effective tensor $A_K^{\\ast}$ per coarse element:\n   $$\n   -\\nabla \\cdot \\left( A^{\\ast}(\\mathbf{x}) \\nabla U(\\mathbf{x}) \\right) = f(\\mathbf{x}) \\quad \\text{in } \\Omega, \\quad U(\\mathbf{x}) = 0 \\quad \\text{on } \\partial \\Omega,\n   $$\n   where $A^{\\ast}(\\mathbf{x}) = A_K^{\\ast}$ for $\\mathbf{x} \\in K$. Use the same assembly approach as in the fine-scale case, with $A$ replaced by $A^{\\ast}$ per coarse element. Solve to obtain the coarse nodal solution $U_{\\text{coarse}}$.\n\n4. Interpolate the coarse solution $U_{\\text{coarse}}$ onto the fine mesh nodes using bilinear interpolation restricted to each coarse element, resulting in an interpolated coarse solution $U_{\\text{interp}}$ at fine nodes.\n\n5. Compute the discrete $L^2$-norm of the error between the fine-scale solution and the interpolated coarse-scale solution on the fine mesh nodes:\n   $$\n   \\| u_{\\text{fine}} - U_{\\text{interp}} \\|_{L^2(\\Omega)} \\approx \\left( \\sum_{i} \\left( u_{\\text{fine}}(\\mathbf{x}_i) - U_{\\text{interp}}(\\mathbf{x}_i) \\right)^2 \\, \\Delta x \\, \\Delta y \\right)^{1/2},\n   $$\n   where $\\mathbf{x}_i$ are the fine mesh node coordinates and $\\Delta x$, $\\Delta y$ are the uniform fine grid spacings in the $x$ and $y$ directions, respectively.\n\nUse the following test suite of parameterized tensor fields $A(\\mathbf{x})$ and mesh resolutions to exercise different multiscale and anisotropic behaviors:\n\n- Test Case 1 (layered high contrast, diagonal tensor):\n  - Tensor definition: $A(\\mathbf{x}) = \\mathrm{diag}\\left( \\alpha(y), 1 \\right)$, where $\\alpha(y) = 1000$ if $\\sin(8 \\pi y) > 0$ and $\\alpha(y) = 1$ otherwise.\n  - Fine mesh: $40 \\times 40$ partitions of $\\Omega$ (resulting in $(40+1) \\times (40+1)$ nodes).\n  - Coarse mesh: $5 \\times 5$ partitions of $\\Omega$.\n  - Local element mesh: $8 \\times 8$ partitions per coarse element.\n  - Source: $f(\\mathbf{x}) \\equiv 1$.\n\n- Test Case 2 (rotated anisotropy, full tensor with off-diagonal terms):\n  - Tensor definition: $A(\\mathbf{x}) = R(\\theta(\\mathbf{x})) \\, \\mathrm{diag}(1000,1) \\, R(\\theta(\\mathbf{x}))^{\\top}$, where $R(\\theta)$ is the rotation matrix\n    $$\n    R(\\theta) = \\begin{bmatrix} \\cos \\theta & -\\sin \\theta \\\\ \\sin \\theta & \\cos \\theta \\end{bmatrix}\n    $$\n    and $\\theta(\\mathbf{x}) = \\frac{\\pi}{6} \\sin(4 \\pi x) \\cos(4 \\pi y)$.\n  - Fine mesh: $40 \\times 40$ partitions of $\\Omega$.\n  - Coarse mesh: $5 \\times 5$ partitions of $\\Omega$.\n  - Local element mesh: $8 \\times 8$ partitions per coarse element.\n  - Source: $f(\\mathbf{x}) \\equiv 1$.\n\n- Test Case 3 (checkerboard microstructure, diagonal tensor):\n  - Tensor definition: $A(\\mathbf{x}) = \\mathrm{diag}\\left( \\alpha(x,y), 1 \\right)$, where $\\alpha(x,y) = 1000$ if $\\left( \\lfloor 10 x \\rfloor + \\lfloor 10 y \\rfloor \\right)$ is even and $\\alpha(x,y) = 1$ otherwise.\n  - Fine mesh: $40 \\times 40$ partitions of $\\Omega$.\n  - Coarse mesh: $5 \\times 5$ partitions of $\\Omega$.\n  - Local element mesh: $8 \\times 8$ partitions per coarse element.\n  - Source: $f(\\mathbf{x}) \\equiv 1$.\n\nAll quantities are dimensionless; no physical units are required. Angles in the rotation matrix in Test Case 2 must be interpreted in radians.\n\nYour program must implement the described assembly and solution procedures and produce, for each test case, the discrete $L^2$-norm of the error between the fine-scale solution and the interpolated coarse-scale solution, in floating-point format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").",
            "solution": "The problem presented is a well-posed and computationally intensive task in the field of numerical analysis and multiscale modeling. It requires the implementation of a Multiscale Finite Element Method (MsFEM) to solve a second-order elliptic partial differential equation with a highly oscillatory, spatially varying tensor coefficient. The validation process confirms that the problem is scientifically sound, self-contained, and algorithmically detailed. Therefore, I will proceed with a complete solution.\n\nThe core of the problem is the diffusion equation on a domain $\\Omega = [0,1] \\times [0,1]$:\n$$\n-\\nabla \\cdot \\left( A(\\mathbf{x}) \\nabla u(\\mathbf{x}) \\right) = f(\\mathbf{x}) \\quad \\text{in } \\Omega,\n$$\nwith homogeneous Dirichlet boundary conditions $u(\\mathbf{x}) = 0$ on the boundary $\\partial \\Omega$. The tensor $A(\\mathbf{x})$ is symmetric and positive-definite.\n\n### Variational Formulation\nThe Finite Element Method (FEM) is based on the weak or variational formulation of the PDE. We seek a solution $u$ in the Sobolev space $H_0^1(\\Omega)$, which consists of functions with square-integrable first derivatives that are zero on the boundary $\\partial \\Omega$. Multiplying the PDE by a test function $v \\in H_0^1(\\Omega)$ and integrating over the domain $\\Omega$, we get:\n$$\n-\\int_\\Omega v \\left( \\nabla \\cdot (A \\nabla u) \\right) d\\mathbf{x} = \\int_\\Omega v f \\, d\\mathbf{x}.\n$$\nApplying integration by parts (Green's first identity) to the left-hand side yields:\n$$\n\\int_\\Omega (\\nabla v)^T (A \\nabla u) \\, d\\mathbf{x} - \\int_{\\partial \\Omega} v (A \\nabla u) \\cdot \\mathbf{n} \\, dS = \\int_\\Omega v f \\, d\\mathbf{x}.\n$$\nSince the test function $v$ is zero on the boundary $\\partial \\Omega$, the boundary integral vanishes. This leads to the variational problem: Find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\na(u,v) = L(v),\n$$\nwhere the bilinear form $a(u,v)$ and the linear functional $L(v)$ are defined as:\n$$\na(u,v) = \\int_\\Omega (\\nabla v)^T A(\\mathbf{x}) \\nabla u \\, d\\mathbf{x},\n$$\n$$\nL(v) = \\int_\\Omega v(\\mathbf{x}) f(\\mathbf{x}) \\, d\\mathbf{x}.\n$$\n\n### Finite Element Discretization\nWe discretize the domain $\\Omega$ into a mesh of small triangular elements. The solution $u$ is approximated by a piecewise linear function $u_h$ on this mesh:\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N} U_j \\phi_j(\\mathbf{x}),\n$$\nwhere $U_j$ are the unknown nodal values of the solution at the mesh vertices $\\mathbf{x}_j$, and $\\phi_j(\\mathbf{x})$ are the piecewise linear (hat) basis functions, with $\\phi_j(\\mathbf{x}_i) = \\delta_{ij}$ (the Kronecker delta).\n\nSubstituting this approximation into the variational form and choosing the test functions to be the basis functions themselves (Galerkin method, $v = \\phi_i$), we obtain a system of linear equations $K \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U}$ is the vector of nodal values $\\{U_j\\}$. The entries of the global stiffness matrix $K$ and the global load vector $\\mathbf{F}$ are:\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_\\Omega (\\nabla \\phi_i)^T A(\\mathbf{x}) \\nabla \\phi_j \\, d\\mathbf{x},\n$$\n$$\nF_i = L(\\phi_i) = \\int_\\Omega \\phi_i(\\mathbf{x}) f(\\mathbf{x}) \\, d\\mathbf{x}.\n$$\nThese global integrals are computed by summing up contributions from each element. For a single triangular element $T_e$, the element stiffness matrix $K_e$ and load vector $F_e$ have entries:\n$$\nK_{e,ij} = \\int_{T_e} (\\nabla \\phi_j)^T A(\\mathbf{x}) \\nabla \\phi_i \\, d\\mathbf{x},\n$$\n$$\nF_{e,i} = \\int_{T_e} f(\\mathbf{x}) \\phi_i(\\mathbf{x}) \\, d\\mathbf{x}.\n$$\nThe gradients $\\nabla \\phi_i$ are constant on each triangle. The integrals are approximated using numerical quadrature. For simplicity and as is common for linear elements, we use a single-point quadrature at the triangle's centroid $\\mathbf{x}_c$. Let $|T_e|$ be the area of the triangle.\n$$\nK_{e,ij} \\approx |T_e| (\\nabla \\phi_j)^T A(\\mathbf{x}_c) (\\nabla \\phi_i),\n$$\n$$\nF_{e,i} \\approx f(\\mathbf{x}_c) \\int_{T_e} \\phi_i(\\mathbf{x}) \\, d\\mathbf{x} = f(\\mathbf{x}_c) \\frac{|T_e|}{3}.\n$$\nAfter assembling the global matrix and vector, the Dirichlet boundary conditions are applied, and the resulting sparse linear system is solved to find the nodal solution vector $\\mathbf{U}$.\n\n### Multiscale Finite Element Method (MsFEM) Procedure\n\nThe MsFEM procedure involves four main stages after the initial setup.\n\n**1. Fine-Scale Reference Solution:**\nA fine-scale reference solution $u_{\\text{fine}}$ is computed by solving the original problem on a sufficiently fine triangular mesh (e.g., $40 \\times 40$ cells, triangulated). This provides a benchmark against which the multiscale solution is compared. The FEM solver described above is used with the specified tensor $A(\\mathbf{x})$, source term $f(\\mathbf{x}) \\equiv 1$, and homogeneous Dirichlet boundary conditions on $\\partial\\Omega$.\n\n**2. Local Problems and Effective Tensor Computation:**\nThe domain $\\Omega$ is partitioned into a coarser grid of rectangular elements $K$. For each coarse element $K$, we solve two local problems to determine its effective properties. These problems are solved on a refined mesh local to $K$.\nThe goal is to find local basis functions that capture the small-scale oscillations of the solution due to the heterogeneity of $A(\\mathbf{x})$. These functions are solutions to the homogeneous equation within $K$, driven by specific boundary conditions.\n- **Problem 1:** Find $u_K^{(1)}$ such that $-\\nabla \\cdot (A \\nabla u_K^{(1)}) = 0$ in $K$, with boundary condition $u_K^{(1)}(\\mathbf{x}) = x$ for $\\mathbf{x} \\in \\partial K$.\n- **Problem 2:** Find $u_K^{(2)}$ such that $-\\nabla \\cdot (A \\nabla u_K^{(2)}) = 0$ in $K$, with boundary condition $u_K^{(2)}(\\mathbf{x}) = y$ for $\\mathbf{x} \\in \\partial K$.\n\nFor each solution $u_K^{(i)}$, the average flux across the coarse element is computed:\n$$\n\\overline{\\mathbf{q}}_K^{(i)} = \\frac{1}{|K|} \\int_K \\mathbf{q}_K^{(i)}(\\mathbf{x}) \\, d\\mathbf{x} = \\frac{1}{|K|} \\int_K A(\\mathbf{x}) \\nabla u_K^{(i)}(\\mathbf{x}) \\, d\\mathbf{x}.\n$$\nThe integral is computed numerically by summing element-wise contributions on the local mesh. The effective tensor for the coarse element $K$, denoted $A_K^*$, is then defined as the matrix whose columns are these average fluxes:\n$$\nA_K^* = \\begin{bmatrix} \\overline{\\mathbf{q}}_K^{(1)} & \\overline{\\mathbf{q}}_K^{(2)} \\end{bmatrix}.\n$$\nThis tensor represents the homogenized response of the micro-structured material within block $K$.\n\n**3. Coarse-Scale Solution:**\nA coarse-scale problem is formulated on the coarse grid using the computed effective tensors. The governing equation for the coarse-scale solution $U(\\mathbf{x})$ is:\n$$\n-\\nabla \\cdot \\left( A^*(\\mathbf{x}) \\nabla U(\\mathbf{x}) \\right) = f(\\mathbf{x}) \\quad \\text{in } \\Omega,\n$$\nwith $U(\\mathbf{x}) = 0$ on $\\partial \\Omega$. The tensor $A^*(\\mathbf{x})$ is piecewise constant, taking the value $A_K^*$ for all $\\mathbf{x} \\in K$. This coarse problem is solved using the same FEM framework, but on the coarse triangulated mesh, to obtain the nodal solution $U_{\\text{coarse}}$.\n\n**4. Interpolation and Error Computation:**\nThe coarse-scale nodal solution $U_{\\text{coarse}}$ is defined only at the vertices of the coarse grid. To compare it with the fine-scale solution, it is interpolated onto the fine mesh nodes. For any fine node $\\mathbf{x}_{i}$ located within a coarse rectangular element $K$, the value $U_{\\text{interp}}(\\mathbf{x}_i)$ is calculated using bilinear interpolation from the four corner values of $U_{\\text{coarse}}$ on that element $K$.\n\nFinally, the error is quantified by computing the discrete $L^2$-norm of the difference between the fine solution $u_{\\text{fine}}$ and the interpolated coarse solution $U_{\\text{interp}}$:\n$$\n\\| u_{\\text{fine}} - U_{\\text{interp}} \\|_{L^2(\\Omega)} \\approx \\left( \\sum_{i} \\left( u_{\\text{fine}}(\\mathbf{x}_i) - U_{\\text{interp}}(\\mathbf{x}_i) \\right)^2 \\Delta x \\Delta y \\right)^{1/2},\n$$\nwhere the sum is over all nodes $\\mathbf{x}_i$ of the fine mesh, and $\\Delta x, \\Delta y$ are the fine grid spacings. This procedure is executed for each test case specified in the problem statement, yielding a measure of the effectiveness of the MsFEM homogenization for different types of material heterogeneity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef generate_tri_mesh(nx, ny, x_lims, y_lims):\n    \"\"\"\n    Generates a uniform triangulated mesh for a rectangular domain.\n    The domain is defined by x_lims and y_lims.\n    The grid is partitioned into nx by ny rectangles, each split into two triangles.\n    \"\"\"\n    x_start, x_end = x_lims\n    y_start, y_end = y_lims\n    x = np.linspace(x_start, x_end, nx + 1)\n    y = np.linspace(y_start, y_end, ny + 1)\n    \n    nodes_x, nodes_y = np.meshgrid(x, y)\n    nodes = np.vstack([nodes_x.ravel(), nodes_y.ravel()]).T\n    \n    num_nodes = (nx + 1) * (ny + 1)\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n0 = j * (nx + 1) + i       # bottom-left\n            n1 = j * (nx + 1) + i + 1   # bottom-right\n            n2 = (j + 1) * (nx + 1) + i # top-left\n            n3 = (j + 1) * (nx + 1) + i + 1 # top-right\n            elements.append([n0, n1, n3]) # bottom-right triangle\n            elements.append([n0, n3, n2]) # top-left triangle\n    \n    boundary_nodes = set()\n    for i in range(nx + 1):\n        boundary_nodes.add(i)  # bottom\n        boundary_nodes.add(ny * (nx + 1) + i) # top\n    for j in range(ny + 1):\n        boundary_nodes.add(j * (nx + 1)) # left\n        boundary_nodes.add(j * (nx + 1) + nx) # right\n        \n    return nodes, np.array(elements), sorted(list(boundary_nodes))\n\ndef solve_fem(nodes, elements, A_func, f_func, dirichlet_nodes, dirichlet_values):\n    \"\"\"\n    A general-purpose 2D FEM solver for the diffusion equation.\n    \"\"\"\n    num_nodes = len(nodes)\n    stiffness_matrix = lil_matrix((num_nodes, num_nodes), dtype=float)\n    load_vector = np.zeros(num_nodes, dtype=float)\n\n    for el in elements:\n        p = nodes[el]\n        p1, p2, p3 = p[0], p[1], p[2]\n\n        # Element area and basis function gradients\n        area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area  1e-12: continue\n\n        # Gradients of linear basis functions (N_i = a_i + b_i*x + c_i*y)\n        # grad(N_i) = [b_i, c_i]\n        b = np.array([p2[1]-p3[1], p3[1]-p1[1], p1[1]-p2[1]]) / (2*area)\n        c = np.array([p3[0]-p2[0], p1[0]-p3[0], p2[0]-p1[0]]) / (2*area)\n        grads = np.vstack((b, c)).T # shape (3, 2)\n        \n        # Centroid for numerical quadrature\n        centroid = np.mean(p, axis=0)\n        A_val = A_func(centroid[0], centroid[1])\n        \n        # Element stiffness matrix\n        el_stiffness = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                el_stiffness[i, j] = area * (grads[i, :].T @ A_val @ grads[j, :])\n\n        # Element load vector\n        f_val = f_func(centroid[0], centroid[1]) if f_func else 0.0\n        el_load = (area / 3.0) * f_val * np.ones(3)\n\n        # Assemble into global matrices\n        for i in range(3):\n            load_vector[el[i]] += el_load[i]\n            for j in range(3):\n                stiffness_matrix[el[i], el[j]] += el_stiffness[i, j]\n\n    # Apply Dirichlet boundary conditions using submatrix method\n    interior_nodes = np.setdiff1d(np.arange(num_nodes), dirichlet_nodes)\n    \n    K_II = stiffness_matrix[interior_nodes, :][:, interior_nodes]\n    K_ID = stiffness_matrix[interior_nodes, :][:, dirichlet_nodes]\n    \n    F_I = load_vector[interior_nodes]\n    \n    dirichlet_vals_vec = np.array([dirichlet_values.get(n, 0) for n in dirichlet_nodes])\n\n    F_I_hat = F_I - K_ID @ dirichlet_vals_vec\n\n    # Solve for interior nodes\n    u_I = spsolve(K_II.tocsr(), F_I_hat)\n    \n    # Reconstruct full solution vector\n    solution = np.zeros(num_nodes)\n    solution[interior_nodes] = u_I\n    solution[dirichlet_nodes] = dirichlet_vals_vec\n\n    return solution\n\ndef solve_case(case_params):\n    \"\"\"\n    Implements the full MsFEM pipeline for a given test case.\n    \"\"\"\n    A_func = case_params['A_func']\n    f_func = case_params['f_func']\n    n_fine_x, n_fine_y = case_params['fine_mesh']\n    n_coarse_x, n_coarse_y = case_params['coarse_mesh']\n    n_local_x, n_local_y = case_params['local_mesh']\n\n    # 1. Fine-scale reference solution\n    fine_nodes, fine_elements, fine_boundary = generate_tri_mesh(n_fine_x, n_fine_y, [0, 1], [0, 1])\n    fine_dirichlet_vals = {node_idx: 0.0 for node_idx in fine_boundary}\n    u_fine = solve_fem(fine_nodes, fine_elements, A_func, f_func, fine_boundary, fine_dirichlet_vals)\n\n    # 2. Local problems and effective tensor computation\n    coarse_dx, coarse_dy = 1.0 / n_coarse_x, 1.0 / n_coarse_y\n    effective_tensors = {}\n\n    for jc in range(n_coarse_y):\n        for ic in range(n_coarse_x):\n            x_lims = [ic * coarse_dx, (ic + 1) * coarse_dx]\n            y_lims = [jc * coarse_dy, (jc + 1) * coarse_dy]\n            \n            local_nodes, local_elements, local_boundary = generate_tri_mesh(n_local_x, n_local_y, x_lims, y_lims)\n            \n            # Local problem 1: BC u=x\n            dir_vals_1 = {node_idx: local_nodes[node_idx, 0] for node_idx in local_boundary}\n            u_local_1 = solve_fem(local_nodes, local_elements, A_func, None, local_boundary, dir_vals_1)\n            \n            # Local problem 2: BC u=y\n            dir_vals_2 = {node_idx: local_nodes[node_idx, 1] for node_idx in local_boundary}\n            u_local_2 = solve_fem(local_nodes, local_elements, A_func, None, local_boundary, dir_vals_2)\n\n            # Compute average fluxes\n            avg_flux_1 = np.zeros(2)\n            avg_flux_2 = np.zeros(2)\n\n            for el in local_elements:\n                p = local_nodes[el]\n                area = 0.5 * np.abs(p[0,0]*(p[1,1]-p[2,1]) + p[1,0]*(p[2,1]-p[0,1]) + p[2,0]*(p[0,1]-p[1,1]))\n\n                b = np.array([p[1,1]-p[2,1], p[2,1]-p[0,1], p[0,1]-p[1,1]]) / (2*area)\n                c = np.array([p[2,0]-p[1,0], p[0,0]-p[2,0], p[1,0]-p[0,0]]) / (2*area)\n                grads_phi = np.vstack((b, c)).T\n\n                grad_u1 = np.sum(u_local_1[el, np.newaxis] * grads_phi, axis=0)\n                grad_u2 = np.sum(u_local_2[el, np.newaxis] * grads_phi, axis=0)\n\n                centroid = np.mean(p, axis=0)\n                A_val = A_func(centroid[0], centroid[1])\n\n                avg_flux_1 += area * (A_val @ grad_u1)\n                avg_flux_2 += area * (A_val @ grad_u2)\n            \n            coarse_area = coarse_dx * coarse_dy\n            avg_flux_1 /= coarse_area\n            avg_flux_2 /= coarse_area\n\n            effective_tensors[(ic, jc)] = np.column_stack((avg_flux_1, avg_flux_2))\n\n    # 3. Coarse-scale solution\n    coarse_nodes, coarse_elements, coarse_boundary = generate_tri_mesh(n_coarse_x, n_coarse_y, [0, 1], [0, 1])\n    \n    def A_star_func(x, y):\n        ic = min(int(x / coarse_dx), n_coarse_x - 1)\n        jc = min(int(y / coarse_dy), n_coarse_y - 1)\n        return effective_tensors[(ic, jc)]\n    \n    coarse_dirichlet_vals = {node_idx: 0.0 for node_idx in coarse_boundary}\n    U_coarse = solve_fem(coarse_nodes, coarse_elements, A_star_func, f_func, coarse_boundary, coarse_dirichlet_vals)\n\n    # 4. Interpolate coarse solution to fine grid\n    U_interp = np.zeros_like(u_fine)\n    for i in range(len(fine_nodes)):\n        x, y = fine_nodes[i]\n        \n        # Handle boundary case\n        if x == 1.0 or y == 1.0:\n            U_interp[i] = 0.0\n            continue\n            \n        ic = int(x / coarse_dx)\n        jc = int(y / coarse_dy)\n        \n        x_coarse__nodes_idx = [jc*(n_coarse_x+1) + ic, jc*(n_coarse_x+1) + ic + 1,\n                              (jc+1)*(n_coarse_x+1) + ic, (jc+1)*(n_coarse_x+1) + ic + 1]\n\n        x1, y1 = coarse_nodes[x_coarse__nodes_idx[0]]\n        x2, y2 = coarse_nodes[x_coarse__nodes_idx[3]]\n\n        U11 = U_coarse[x_coarse__nodes_idx[0]]\n        U21 = U_coarse[x_coarse__nodes_idx[1]]\n        U12 = U_coarse[x_coarse__nodes_idx[2]]\n        U22 = U_coarse[x_coarse__nodes_idx[3]]\n        \n        # Bilinear interpolation\n        tx = (x - x1) / (x2 - x1)\n        ty = (y - y1) / (y2 - y1)\n        U_interp[i] = (1-tx)*(1-ty)*U11 + tx*(1-ty)*U21 + (1-tx)*ty*U12 + tx*ty*U22\n\n    # 5. Compute L2 error\n    dx, dy = 1.0 / n_fine_x, 1.0 / n_fine_y\n    error_L2 = np.sqrt(np.sum((u_fine - U_interp)**2) * dx * dy)\n\n    return error_L2\n\ndef solve():\n    # Test Case 1\n    def A1_func(x, y):\n        alpha = 1000.0 if np.sin(8 * np.pi * y) > 0 else 1.0\n        return np.array([[alpha, 0.0], [0.0, 1.0]])\n\n    # Test Case 2\n    def A2_func(x, y):\n        theta = (np.pi / 6.0) * np.sin(4 * np.pi * x) * np.cos(4 * np.pi * y)\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        D = np.array([[1000.0, 0.0], [0.0, 1.0]])\n        return R @ D @ R.T\n\n    # Test Case 3\n    def A3_func(x, y):\n        alpha = 1000.0 if (np.floor(10 * x) + np.floor(10 * y)) % 2 == 0 else 1.0\n        return np.array([[alpha, 0.0], [0.0, 1.0]])\n        \n    def f_const(x, y):\n        return 1.0\n\n    test_cases = [\n        {\n            'A_func': A1_func, 'f_func': f_const,\n            'fine_mesh': (40, 40), 'coarse_mesh': (5, 5), 'local_mesh': (8, 8)\n        },\n        {\n            'A_func': A2_func, 'f_func': f_const,\n            'fine_mesh': (40, 40), 'coarse_mesh': (5, 5), 'local_mesh': (8, 8)\n        },\n        {\n            'A_func': A3_func, 'f_func': f_const,\n            'fine_mesh': (40, 40), 'coarse_mesh': (5, 5), 'local_mesh': (8, 8)\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}