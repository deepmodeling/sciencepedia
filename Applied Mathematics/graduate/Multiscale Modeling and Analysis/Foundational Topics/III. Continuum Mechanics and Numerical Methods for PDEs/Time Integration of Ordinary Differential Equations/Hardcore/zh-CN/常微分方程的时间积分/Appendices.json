{
    "hands_on_practices": [
        {
            "introduction": "理解数值方法的稳定性对于常微分方程的积分至关重要，特别是对于多尺度模型中遇到的刚性系统。本练习将引导你推导一个隐式龙格-库塔方法的稳定性函数，这是一个分析数值误差随时间增长或衰减的关键工具。通过检验该函数的性质，你将深入理解 $A$-稳定性和 $L$-稳定性等概念，这些概念决定了一种方法是否适用于刚性问题。",
            "id": "3824469",
            "problem": "考虑常微分方程（ODE）初值问题的线性测试方程 $y'(t)=\\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $y(t)$ 是标量。在多尺度建模的背景下，时间积分格式通过此测试方程的放大因子来评估，该放大因子定义为 $z=h\\lambda$，其中 $h$ 是时间步长。考虑具有以下Butcher表的2级Gauss–Legendre配置Runge–Kutta (RK)方法：\n$$\nA=\\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}-\\frac{\\sqrt{3}}{6}\\\\[6pt]\n\\frac{1}{4}+\\frac{\\sqrt{3}}{6}  \\frac{1}{4}\n\\end{pmatrix},\\quad\n\\mathbf{b}=\\begin{pmatrix}\\frac{1}{2}\\\\[4pt]\\frac{1}{2}\\end{pmatrix},\\quad\n\\mathbf{c}=\\begin{pmatrix}\\frac{1}{2}-\\frac{\\sqrt{3}}{6}\\\\[4pt]\\frac{1}{2}+\\frac{\\sqrt{3}}{6}\\end{pmatrix}.\n$$\n从定义一个应用于测试方程 $y'(t)=\\lambda y(t)$ 的通用Runge–Kutta方法的阶段方程和更新规则出发，推导放大因子（稳定性函数）$R(z)$，使得单步更新满足 $y_{n+1}=R(z)\\,y_n$。然后，讨论 $R(z)$作为 $z\\in\\mathbb{C}$ 的函数的解析性质，包括：\n- 其极点的位置，\n- 在虚轴上的行为，\n- 当 $|z|\\to\\infty$ 时的渐近行为，\n- 该方法是否是 $A$-稳定的以及是否是 $L$-稳定的。\n\n用 $z$ 的闭式解析表达式表示你最终的 $R(z)$。不需要数值舍入。最终答案必须是 $R(z)$ 的单个解析表达式。",
            "solution": "我们从应用于线性测试方程 $y'(t)=\\lambda y(t)$ 的Runge–Kutta (RK)方法的基本定义开始，其中 $z=h\\lambda$。对于一个具有Butcher系数 $A\\in\\mathbb{R}^{s\\times s}$、$\\mathbf{b}\\in\\mathbb{R}^{s}$ 和 $\\mathbf{c}\\in\\mathbb{R}^{s}$ 的 $s$ 阶RK方法，其阶段值 $\\mathbf{K}\\in\\mathbb{C}^{s}$ 由下式定义\n$$\n\\mathbf{K}=\\lambda\\,y_n\\,\\mathbf{1}+z\\,A\\,\\mathbf{K},\n$$\n其中 $\\mathbf{1}\\in\\mathbb{R}^{s}$ 是全一向量，并且我们使用了 $z=h\\lambda$。整理后得到\n$$\n\\left(I-zA\\right)\\mathbf{K}=\\lambda\\,y_n\\,\\mathbf{1},\\quad\\text{所以}\\quad \\mathbf{K}=\\lambda\\,y_n\\,(I-zA)^{-1}\\mathbf{1}.\n$$\nRK更新公式为\n$$\ny_{n+1}=y_n+h\\,\\mathbf{b}^{\\top}\\mathbf{K}=y_n+z\\,\\mathbf{b}^{\\top}(I-zA)^{-1}\\mathbf{1}\\,y_n,\n$$\n因此，放大因子（稳定性函数）为\n$$\nR(z)=1+z\\,\\mathbf{b}^{\\top}(I-zA)^{-1}\\mathbf{1}.\n$$\n现在我们为给定的2阶Gauss–Legendre配置方法计算 $R(z)$。记\n$$\nA=\\begin{pmatrix}\na  b\\\\\nc  a\n\\end{pmatrix},\\quad a=\\frac{1}{4},\\quad b=\\frac{1}{4}-\\frac{\\sqrt{3}}{6},\\quad c=\\frac{1}{4}+\\frac{\\sqrt{3}}{6},\\quad \\mathbf{b}=\\begin{pmatrix}\\frac{1}{2}\\\\[4pt]\\frac{1}{2}\\end{pmatrix}.\n$$\n则\n$$\nI-zA=\\begin{pmatrix}\n1-za  -zb\\\\\n-zc  1-za\n\\end{pmatrix}.\n$$\n一个 $2\\times 2$ 矩阵的逆是\n$$\n(I-zA)^{-1}=\\frac{1}{\\det(I-zA)}\\begin{pmatrix}\n1-za  zb\\\\\nzc  1-za\n\\end{pmatrix},\n$$\n其行列式为\n$$\n\\det(I-zA)=(1-za)^2-z^2\\,bc.\n$$\n计算 $bc$：\n$$\nbc=\\left(\\frac{1}{4}-\\frac{\\sqrt{3}}{6}\\right)\\left(\\frac{1}{4}+\\frac{\\sqrt{3}}{6}\\right)=\\frac{1}{16}-\\left(\\frac{\\sqrt{3}}{6}\\right)^2=\\frac{1}{16}-\\frac{3}{36}=\\frac{1}{16}-\\frac{1}{12}=-\\frac{1}{48}.\n$$\n因此\n$$\n\\det(I-zA)=(1-za)^2+\\frac{z^2}{48}=\\left(1-\\frac{z}{4}\\right)^2+\\frac{z^2}{48}=1-\\frac{z}{2}+\\frac{z^2}{16}+\\frac{z^2}{48}=1-\\frac{z}{2}+\\frac{z^2}{12}.\n$$\n接下来，计算 $(I-zA)^{-1}\\mathbf{1}$：\n$$\n(I-zA)^{-1}\\mathbf{1}=\\frac{1}{\\det(I-zA)}\\begin{pmatrix}\n(1-za)+zb\\\\\nzc+(1-za)\n\\end{pmatrix}.\n$$\n注意 $a-b=\\frac{1}{4}-\\left(\\frac{1}{4}-\\frac{\\sqrt{3}}{6}\\right)=\\frac{\\sqrt{3}}{6}$ 且 $c-a=\\left(\\frac{1}{4}+\\frac{\\sqrt{3}}{6}\\right)-\\frac{1}{4}=\\frac{\\sqrt{3}}{6}$，所以\n$$\n(1-za)+zb=1-z(a-b)=1-z\\frac{\\sqrt{3}}{6},\\qquad zc+(1-za)=1+z(c-a)=1+z\\frac{\\sqrt{3}}{6}.\n$$\n因此\n$$\n(I-zA)^{-1}\\mathbf{1}=\\frac{1}{\\det(I-zA)}\\begin{pmatrix}\n1-\\frac{\\sqrt{3}}{6}z\\\\[4pt]\n1+\\frac{\\sqrt{3}}{6}z\n\\end{pmatrix}.\n$$\n现在乘以 $\\mathbf{b}^{\\top}$：\n$$\n\\mathbf{b}^{\\top}(I-zA)^{-1}\\mathbf{1}=\\frac{1}{\\det(I-zA)}\\left[\\frac{1}{2}\\left(1-\\frac{\\sqrt{3}}{6}z\\right)+\\frac{1}{2}\\left(1+\\frac{\\sqrt{3}}{6}z\\right)\\right]=\\frac{1}{\\det(I-zA)}.\n$$\n因此\n$$\nR(z)=1+z\\,\\frac{1}{\\det(I-zA)}=1+\\frac{z}{1-\\frac{z}{2}+\\frac{z^2}{12}}=\\frac{1-\\frac{z}{2}+\\frac{z^2}{12}+z}{1-\\frac{z}{2}+\\frac{z^2}{12}}=\\frac{1+\\frac{z}{2}+\\frac{z^2}{12}}{1-\\frac{z}{2}+\\frac{z^2}{12}}.\n$$\n这个有理形式是 $\\exp(z)$ 的 $[2/2]$ Padé近似，与该4阶配置方法一致。\n\n我们现在讨论 $R(z)$ 的解析性质：\n\n$1.$ 极点：极点出现在分母为零的地方，\n$$\n1-\\frac{z}{2}+\\frac{z^2}{12}=0\\quad\\Longleftrightarrow\\quad z^2-6z+12=0.\n$$\n根是\n$$\nz=\\frac{6\\pm\\sqrt{36-48}}{2}=3\\pm i\\sqrt{3}.\n$$\n因此，$R(z)$ 是亚纯函数，在 $z=3\\pm i\\sqrt{3}$ 有两个单极点，它们都位于开放右半平面，这意味着它在闭合左半平面是解析的。\n\n$2.$ 在虚轴上的行为：令 $z=i\\omega$，其中 $\\omega\\in\\mathbb{R}$。那么分子和分母是复共轭的，\n$$\n\\text{num}=1+\\frac{i\\omega}{2}-\\frac{\\omega^2}{12},\\qquad \\text{den}=1-\\frac{i\\omega}{2}-\\frac{\\omega^2}{12}=\\overline{\\text{num}},\n$$\n所以\n$$\n|R(i\\omega)|=\\left|\\frac{\\text{num}}{\\text{den}}\\right|=1.\n$$\n在虚轴上的这种单位模特性反映了该方法在振荡问题上的辛性和保能量特性。\n\n$3.$ 当 $|z|\\to\\infty$ 时的渐近性：分子和分母中的最高次项相同，均为 $\\frac{z^2}{12}$，所以\n$$\n\\lim_{|z|\\to\\infty}R(z)=1.\n$$\n因此，该方法不是 $L$-稳定的（$L$-稳定要求沿负实轴 $\\lim_{z\\to -\\infty}R(z)=0$）。\n\n$4.$ $A$-稳定性：如果对于所有满足 $\\Re(z)\\leq 0$ 的 $z$，都有 $|R(z)|\\leq 1$，则该方法是 $A$-稳定的。众所周知，Gauss–Legendre配置RK方法是 $A$-稳定的，对于这个2阶的情况，极点严格位于右半平面，并且在边界 $\\Re(z)=0$ 上有 $|R(i\\omega)|=1$，这表明在虚轴上没有增长。再加上Gauss方法的代数稳定性，这意味着该方法是 $A$-稳定的。然而，如上所述，该方法不是 $L$-稳定的。\n\n最后，我们可以通过级数展开来验证其与 $\\exp(z)$ 的一致性。对分母使用几何级数，\n$$\n\\frac{1}{1-\\frac{z}{2}+\\frac{z^2}{12}}=1+\\frac{z}{2}+\\frac{z^2}{6}+\\frac{z^3}{24}+\\frac{z^4}{120}+O(z^5),\n$$\n并乘以分子 $1+\\frac{z}{2}+\\frac{z^2}{12}$，得到\n$$\nR(z)=1+z+\\frac{z^2}{2}+\\frac{z^3}{6}+\\frac{z^4}{24}+O(z^5),\n$$\n这与 $\\exp(z)$ 的泰勒展开式直到 $z^4$ 项都匹配，与该方法在测试方程上的4阶精度一致。\n\n因此，闭式放大因子为\n$$\nR(z)=\\frac{1+\\frac{z}{2}+\\frac{z^2}{12}}{1-\\frac{z}{2}+\\frac{z^2}{12}}.\n$$",
            "answer": "$$\\boxed{\\frac{1+\\frac{z}{2}+\\frac{z^{2}}{12}}{1-\\frac{z}{2}+\\frac{z^{2}}{12}}}$$"
        },
        {
            "introduction": "许多物理和生物系统，例如化学反应网络，其状态量（如浓度）必须保持非负。本实践问题将我们的焦点从抽象的稳定性转移到确保数值积分器满足这一基本物理约束。通过分析简单的前向欧拉法，你将推导出保证解的正定性的最大允许时间步长，从而提供一个具体的例子，说明了必须如何根据问题本身的结构来调整方法的属性。",
            "id": "3824513",
            "problem": "考虑一个包含 $d$ 种化学物质的封闭反应网络，其非负浓度汇集在向量 $x(t) \\in \\mathbb{R}_{\\ge 0}^{d}$ 中。其动力学由一个自治常微分方程组 (ODEs) 建模：$$\\frac{d x}{d t} = S \\, r(x),$$ 其中 $S \\in \\mathbb{R}^{d \\times L}$ 是化学计量矩阵，$r(x) \\in \\mathbb{R}_{\\ge 0}^{L}$ 是反应速率向量。假设为质量作用动力学，其速率常数为非负，因此每个分量 $r_{\\ell}(x)$ 在非负象限上都是一个光滑非负函数。对于每个物质索引 $i \\in \\{1,\\dots,d\\}$，通过定义以下生成项和消耗项来分解方程右侧：$$p_{i}(x) := \\sum_{\\ell \\, : \\, S_{i \\ell} > 0} S_{i \\ell} \\, r_{\\ell}(x), \\qquad d_{i}(x) := \\sum_{\\ell \\, : \\, S_{i \\ell}  0} \\left(-S_{i \\ell}\\right) \\, r_{\\ell}(x),$$ 使得 $$\\frac{d x_{i}}{d t} = p_{i}(x) - d_{i}(x), \\qquad p_{i}(x) \\ge 0, \\quad d_{i}(x) \\ge 0 \\quad \\text{对所有 } x \\in \\mathbb{R}_{\\ge 0}^{d} \\text{ 成立}。$$ 假设在一个固定时间 $t^{n}$，状态为 $x^{n} := x(t^{n}) \\in \\mathbb{R}_{\\ge 0}^{d}$，满足对所有 $i$ 都有 $x^{n}_{i} \\ge 0$。并且，只要 $x^{n}_{i} > 0$，就存在至少一个反应 $\\ell$ 使得 $S_{i \\ell}  0$ 且 $r_{\\ell}(x^{n}) > 0$（这确保了在活性物质集合上 $d_{i}(x^{n}) > 0$）。\n\n请设计一个显式单步时间积分器，该积分器使用前向欧拉法作为基本模块和自适应步长选择，从 $x^{n}$ 开始，在单个时间步长内保持浓度的非负性。从第一性原理出发，仅使用上述定义，推导出一个最大允许步长 $\\Delta t_{\\max}(x^{n})$ 的闭式表达式，使得前向欧拉更新 $$x^{n+1} = x^{n} + \\Delta t \\, \\left( S \\, r(x^{n}) \\right) = x^{n} + \\Delta t \\, \\left( p(x^{n}) - d(x^{n}) \\right)$$ 对所有物质都保持分量非负。您的最终表达式必须仅依赖于 $S$ 和 $r(x^{n})$，并且在所述假设下必须有效。请将您的最终答案表示为 $\\Delta t_{\\max}(x^{n})$ 的单个解析表达式。无需四舍五入。若出现任何角度，以弧度表示。若出现任何物理单位，最终答案中不带单位。",
            "solution": "目标是找到最大的时间步长 $\\Delta t_{\\max}(x^{n}) > 0$，使得前向欧拉更新能保持所有物质浓度的非负性。时间 $t^n$ 的状态由向量 $x^n \\in \\mathbb{R}_{\\ge 0}^d$ 给出，意味着对所有物质 $i \\in \\{1, \\dots, d\\}$ 都有 $x_i^n \\ge 0$。\n\n前向欧拉法根据以下规则，在一个时间步长 $\\Delta t$ 内将状态从 $x^n$ 更新到 $x^{n+1}$：\n$$x^{n+1} = x^n + \\Delta t \\, S \\, r(x^n)$$\n对每个分量 $i$ 写出此方程，得到：\n$$x_i^{n+1} = x_i^n + \\Delta t \\, (S \\, r(x^n))_i$$\n问题提供了将右侧项 $f_i(x) := (S \\, r(x))_i$ 分解为生成项 $p_i(x)$ 和消耗项 $d_i(x)$ 的方法，使得 $f_i(x) = p_i(x) - d_i(x)$。使用这种分解，分量 $i$ 的更新公式为：\n$$x_i^{n+1} = x_i^n + \\Delta t (p_i(x^n) - d_i(x^n))$$\n保持非负性的条件是，对所有 $i = 1, \\dots, d$ 都有 $x_i^{n+1} \\ge 0$。这产生了一个由 $d$ 个不等式组成的系统：\n$$x_i^n + \\Delta t (p_i(x^n) - d_i(x^n)) \\ge 0 \\qquad \\text{对 } i = 1, \\dots, d$$\n为了找到对 $\\Delta t$ 的约束，我们必须分析每个不等式。\n\n我们对每种物质 $i$ 考虑两种情况：\n\n情况1：物质 $i$ 的净变化率为非负，即 $p_i(x^n) - d_i(x^n) \\ge 0$。\n在这种情况下，由于 $x_i^n \\ge 0$ 且 $\\Delta t > 0$，项 $\\Delta t (p_i(x^n) - d_i(x^n))$ 是非负的。因此，和 $x_i^n + \\Delta t (p_i(x^n) - d_i(x^n))$ 保证为非负。所以，对于任何浓度不减少的物质，非负性条件对任何 $\\Delta t \\ge 0$ 都满足。这种物质对时间步长不施加任何上界。\n\n情况2：物质 $i$ 的净变化率为负，即 $p_i(x^n) - d_i(x^n)  0$。\n在这种情况下，物质 $i$ 的浓度正在减少。可以重新整理不等式以分离出 $\\Delta t$：\n$$\\Delta t (p_i(x^n) - d_i(x^n)) \\ge -x_i^n$$\n由于项 $(p_i(x^n) - d_i(x^n))$ 是负的，用它相除会反转不等号：\n$$\\Delta t \\le \\frac{-x_i^n}{p_i(x^n) - d_i(x^n)}$$\n这可以用消耗项和生成项更直观地写成：\n$$\\Delta t \\le \\frac{x_i^n}{d_i(x^n) - p_i(x^n)}$$\n这个不等式为 $\\Delta t$ 提供了一个上界，以防止物质 $i$ 的浓度变为负值。\n\n我们来分析分母。此情况的条件是 $p_i(x^n) - d_i(x^n)  0$，等价于 $d_i(x^n) > p_i(x^n)$。根据定义，$p_i(x^n) \\ge 0$，因此这意味着 $d_i(x^n) > 0$。所以，分母 $d_i(x^n) - p_i(x^n)$ 是严格为正的，对 $\\Delta t$ 的界是良定义的。\n\n问题指明了是质量作用动力学。这意味着如果一种物质的浓度 $x_i^n = 0$，那么任何以该物质 $i$ 为反应物的反应速率 $r_\\ell(x^n)$ 都必须为零。因此，消耗项 $d_i(x^n)$ 必须为零。在这种情况下，净速率为 $p_i(x^n) - d_i(x^n) = p_i(x^n) \\ge 0$。这意味着浓度为零的物质不能有负的净速率，因此它属于情况1。所以，情况2仅适用于 $x_i^n > 0$ 的物质 $i$。这确保了在情况2中推导出的所有约束的分子 $x_i^n$ 都是严格为正的。\n\n全局时间步长 $\\Delta t$ 必须同时满足所有物质的非负性约束。因此，它必须小于或等于所有推导出的单个上界。最大允许步长 $\\Delta t_{\\max}(x^n)$ 是所有这些上界的最小值。\n情况1中的物质贡献了一个有效的上界 $\\infty$，这并不约束最小值。因此，我们只需要考虑正在被消耗的物质集合（情况2）的最小值。\n\n令浓度减少的物质的索引集合为 $I = \\{i \\in \\{1,\\dots,d\\} \\mid p_i(x^n) - d_i(x^n)  0\\}$。最大允许步长为：\n$$\\Delta t_{\\max}(x^n) = \\min_{i \\in I} \\left\\{ \\frac{x_i^n}{d_i(x^n) - p_i(x^n)} \\right\\}$$\n如果集合 $I$ 为空（即没有物质浓度在减少），则空集上的最小值定义为 $+\\infty$，意味着任何步长都是允许的。\n\n为了用所要求的 $S$ 和 $r(x^n)$ 来表示，我们使用关系 $(S r(x^n))_i = p_i(x^n) - d_i(x^n)$。属于集合 $I$ 的条件是 $(S r(x^n))_i  0$。分母是 $d_i(x^n) - p_i(x^n) = -(p_i(x^n) - d_i(x^n)) = -(S r(x^n))_i$。将这些代入 $\\Delta t_{\\max}(x^n)$ 的表达式中，得到最终形式：\n$$\\Delta t_{\\max}(x^n) = \\min_{i \\,:\\, (S r(x^n))_i  0} \\left\\{ \\frac{x_i^n}{-(S r(x^n))_i} \\right\\}$$\n此表达式是当前状态 $x^n$ 和封装在 $S$ 及速率函数 $r$ 中的反应数据的函数。它提供了保证前向欧拉步不产生负浓度的最大步长。",
            "answer": "$$\\boxed{\\min_{i \\in \\{1, \\dots, d\\} \\,:\\, (S r(x^n))_i  0} \\left\\{ \\frac{-x_i^n}{(S r(x^n))_i} \\right\\}}$$"
        },
        {
            "introduction": "隐式方法是高效求解刚性常微分方程的关键，但这要求在每个时间步内求解一个非线性方程组，通常使用牛顿-拉夫逊方法。这个计算实践要求你实现一个对角隐式龙ge-Kutta（DIRK）格式，并探索一个关键的权衡：重新计算雅可比矩阵的成本与牛顿求解器鲁棒性之间的关系。通过在刚性范德波尔振子上比较两种不同的策略，你将在设计高效可靠的隐式时间积分器方面获得实践经验。",
            "id": "3824480",
            "problem": "考虑一个由向量函数 $f:\\mathbb{R}^2\\to\\mathbb{R}^2$ 定义的常微分方程组，其状态 $u(t)=[x(t),y(t)]^\\top$ 满足初值问题 $u'(t)=f(u(t))$, $u(0)=u_0$，其中 $f(u)$ 的选择旨在表现出多尺度刚性，以反映多尺度建模与分析的背景。基本基础包括常微分方程的定义以及方法线时间积分框架，该框架通过源于不动点条件的一致性隐式时间步进和非线性求解来近似离散时间点上的 $u(t)$。您需要实现一个两阶段且具有刚性精度的对角隐式龙格-库塔（DIRK）单对角格式（也称为单对角隐式龙格-库塔（SDIRK）），并比较在时间步之间重用雅可比矩阵的两种策略。目标是量化雅可比矩阵分解成本与收敛鲁棒性之间的权衡。\n\n设模型为处于刚性区域的 Van der Pol 振子，定义为\n$$\nf\\left(\\begin{bmatrix}x\\\\y\\end{bmatrix}\\right)=\n\\begin{bmatrix}\ny \\\\\n\\mu\\,(1-x^2)\\,y - x\n\\end{bmatrix},\n$$\n其中刚性参数 $\\mu>0$。雅可比矩阵 $J(u)=\\frac{\\partial f}{\\partial u}(u)$ 为\n$$\nJ(x,y)=\n\\begin{bmatrix}\n0  1 \\\\\n-2\\mu x y - 1  \\mu(1-x^2)\n\\end{bmatrix}.\n$$\n\n使用对角系数为 $\\gamma=1-\\frac{1}{\\sqrt{2}}$ 的两阶段二阶刚性精度 SDIRK 格式。其 Butcher 系数为\n$$\nA=\n\\begin{bmatrix}\n\\gamma  0\\\\\n1-\\gamma  \\gamma\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}1-\\gamma\\\\ \\gamma\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\\gamma\\\\ 1\\end{bmatrix},\n$$\n其中 $\\gamma=1-\\frac{1}{\\sqrt{2}}$。\n\n给定从 $t_n$ 到 $t_{n+1}=t_n+h$ 的当前时间步以及当前解 $u_n$，DIRK 阶段方程由阶段值 $Y_i$ 的不动点条件定义：\n$$\nG_i(Y_i)=Y_i - u_n - h\\sum_{j=1}^{i} a_{ij} f(Y_j)=0,\n$$\n对于 $i\\in\\{1,2\\}$，其中 $a_{ij}$ 是 $A$ 的元素。使用牛顿-拉夫逊方法（NR）求解每个阶段方程，该方法围绕迭代点 $Y_i^{(k)}$ 对 $G_i$ 进行线性化并求解\n$$\n\\left[I - h\\,a_{ii}\\,J\\left(Y_i^{(k)}\\right)\\right]\\,\\Delta_i^{(k)} = -G_i\\left(Y_i^{(k)}\\right),\n$$\n然后更新 $Y_i^{(k+1)}=Y_i^{(k)}+\\Delta_i^{(k)}$。使用 $Y_1^{(0)}=u_n$ 和 $Y_2^{(0)}=u_n + h\\,(1-\\gamma)\\,f(Y_1)$ 作为初始猜测。由于具有刚性精度，步长更新为 $u_{n+1}=Y_2$。\n\n实现并比较以下两种跨步雅可比矩阵重用策略：\n\n- 跨步静态重用：在积分开始时，使用初始条件 $u_0$ 计算线性系统矩阵 $M=I - h\\,\\gamma\\,J(u_0)$ 并对其进行一次分解。在所有阶段和所有时间步的所有牛顿求解中重用此单一分解，即使 $J(u)$ 随时间变化也不刷新。将 $M$ 的每次分解记为成本 $1$。将每次使用该分解的三角求解记为成本 $1$ 次求解。此策略模拟了极端重用，以最小化分解成本，但可能以牺牲牛顿收敛鲁棒性为代价。\n\n- 每次牛顿迭代动态重计算：在每个时间步的每个阶段的每次牛顿迭代中，在当前迭代点 $Y_i^{(k)}$ 处计算雅可比矩阵 $J(Y_i^{(k)})$，构建矩阵 $M=I - h\\,\\gamma\\,J(Y_i^{(k)})$，对其进行分解，并求解 $\\Delta_i^{(k)}$。按前述方法计算每次分解和每次求解的成本。此策略模拟了激进的更新，以最大化收敛鲁棒性，但代价是更高的分解成本。\n\n收敛鲁棒性通过至少有一个阶段未能在最大允许牛顿迭代次数内达到牛顿-拉夫逊容差的步数来量化。对于每个时间步和每个阶段，如果在最多 $\\text{max\\_it}$ 次迭代内 $\\|G_i(Y_i^{(k)})\\|_2 \\le \\text{tol}$，则宣布收敛；否则，宣布该步失败。记录最后时间步结束时的欧几里得范数 $\\|G_2(Y_2^{(\\text{final})})\\|_2$ 作为代表性的最终残差。\n\n您必须实现一个完整的程序，该程序：\n- 使用两种策略在具有恒定步长 $h$ 的固定时间网格上积分该系统。\n- 对于每种策略，跟踪并报告雅可比矩阵分解总数、线性求解总数、失败步数总数以及最后一步结束时的最终残差范数。\n- 精确地按照上述定义使用指定的 SDIRK 方法、牛顿-拉夫逊方法和成本核算。\n\n使用以下参数集测试套件，每个集合以 $(\\mu,h,T,\\text{tol},\\text{max\\_it})$ 形式给出，初始条件为 $u_0=[x(0),y(0)]^\\top=[2,0]^\\top$：\n- 测试 $1$: $(\\mu=\\;10,\\;h=\\;0.02,\\;T=\\;2.0,\\;\\text{tol}=\\;10^{-10},\\;\\text{max\\_it}=\\;20)$\n- 测试 $2$: $(\\mu=\\;1000,\\;h=\\;0.001,\\;T=\\;0.1,\\;\\text{tol}=\\;10^{-9},\\;\\text{max\\_it}=\\;20)$\n- 测试 $3$: $(\\mu=\\;1000,\\;h=\\;0.01,\\;T=\\;0.1,\\;\\text{tol}=\\;10^{-9},\\;\\text{max\\_it}=\\;25)$\n- 测试 $4$: $(\\mu=\\;1,\\;h=\\;0.1,\\;T=\\;2.0,\\;\\text{tol}=\\;10^{-10},\\;\\text{max\\_it}=\\;20)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个子列表，其中包含按以下顺序排列的八个条目：\n$[\\text{fact\\_static},\\text{solves\\_static},\\text{fails\\_static},\\text{final\\_res\\_static},\\text{fact\\_dynamic},\\text{solves\\_dynamic},\\text{fails\\_dynamic},\\text{final\\_res\\_dynamic}]$。\n所有条目必须是整数或浮点数类型。例如，输出格式应类似于 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ 的单行。",
            "solution": "目标是实现一个特定的两阶段二阶刚性精度单对角隐式龙格-库塔（SDIRK）方法来求解刚性 Van der Pol 振子问题，并比较在阶段方程的牛顿-拉夫逊求解器中处理雅可比矩阵的两种不同策略的性能。\n\n该常微分方程组（ODEs）由 $u'(t) = f(u(t))$ 给出，状态向量为 $u(t) = [x(t), y(t)]^\\top$。对于 Van der Pol 振子，函数 $f: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 定义为：\n$$\nf\\left(\\begin{bmatrix}x\\\\y\\end{bmatrix}\\right)=\n\\begin{bmatrix}\ny \\\\\n\\mu\\,(1-x^2)\\,y - x\n\\end{bmatrix}\n$$\n其中 $\\mu > 0$ 是一个控制系统刚性的参数。初始条件指定为 $u_0 = u(0) = [2, 0]^\\top$。右端函数 $f$ 的雅可比矩阵 $J(u) = \\frac{\\partial f}{\\partial u}(u)$ 为：\n$$\nJ(x,y)=\n\\begin{bmatrix}\n0  1 \\\\\n-2\\mu x y - 1  \\mu(1-x^2)\n\\end{bmatrix}\n$$\n\n从时间 $t_n$到 $t_{n+1} = t_n + h$ 的数值积分是使用由以下 Butcher 系数定义的两阶段 SDIRK 方法执行的：\n$$\nA=\n\\begin{bmatrix}\n\\gamma  0\\\\\n1-\\gamma  \\gamma\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}1-\\gamma\\\\ \\gamma\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\\gamma\\\\ 1\\end{bmatrix}\n$$\n对角元素为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。阶段值 $Y_1$ 和 $Y_2$ 是以下隐式方程的解：\n$$\nG_1(Y_1) = Y_1 - u_n - h \\gamma f(Y_1) = 0 \\\\\nG_2(Y_2) = Y_2 - u_n - h(1-\\gamma)f(Y_1) - h \\gamma f(Y_2) = 0\n$$\n其中 $u_n$ 是时间 $t_n$ 的解，第二个方程中的 $Y_1$ 是第一阶段收敛后的解。该方法具有刚性精度，因为 $c_2 = 1$ 并且 $A$ 的第二行系数与 $b$ 的系数相匹配。此性质允许一个简单而稳定的更新：$u_{n+1} = Y_2$。\n\n每个阶段方程都是一个非线性代数方程组，使用牛顿-拉夫逊方法求解。对于形如 $Y - C - h \\gamma f(Y) = 0$ 的一般阶段方程，其中 $C$ 代表所有显式项，我们将要求解为零的函数定义为 $F(Y) = Y - C - h \\gamma f(Y)$。牛顿-拉夫逊迭代通过在当前迭代点 $Y^{(k)}$ 处对 $F(Y)$ 进行线性化来进行：\n$$\nF(Y^{(k)}) + F'(Y^{(k)})(Y^{(k+1)} - Y^{(k)}) \\approx 0\n$$\n$F$ 的雅可比矩阵为 $F'(Y) = I - h \\gamma J(Y)$，其中 $I$ 是 $2 \\times 2$ 单位矩阵。记更新量为 $\\Delta^{(k)} = Y^{(k+1)} - Y^{(k)}$，我们在每次迭代中求解以下线性系统以获得 $\\Delta^{(k)}$：\n$$\n\\left[I - h \\gamma J\\left(Y^{(k)}\\right)\\right]\\,\\Delta^{(k)} = -\\left( Y^{(k)} - C - h \\gamma f(Y^{(k)}) \\right)\n$$\n那么下一个迭代点是 $Y^{(k+1)} = Y^{(k)} + \\Delta^{(k)}$。牛顿求解器的初始猜测对于第一阶段是 $Y_1^{(0)} = u_n$，对于第二阶段是 $Y_2^{(0)} = u_n + h(1-\\gamma)f(Y_1)$。迭代持续进行，直到残差的欧几里得范数 $\\|F(Y^{(k)})\\|_2$ 小于或等于指定的容差 `tol`，或者达到最大迭代次数 `max_it`。\n\n问题的核心是在此框架内比较两种雅可比矩阵处理策略：\n\n1.  跨步静态重用：雅可比矩阵仅在初始条件 $u_0$ 处计算一次。线性系统矩阵 $M_{static} = I - h \\gamma J(u_0)$ 在积分开始时形成并进行 LU 分解。然后，这个单一的分解被重用于所有后续的牛顿-拉夫逊求解，涵盖所有阶段和所有时间步。根据问题的成本模型，此策略在整个模拟中产生 $1$ 次分解成本，每次牛顿迭代产生 $1$ 次求解成本（使用 LU 因子进行前向/后向替换）。这种方法最大限度地减少了与分解相关的计算成本，但如果真实的雅可比矩阵 $J(u(t))$ 与 $J(u_0)$ 显著偏离，可能会导致收敛速度慢或失败。\n\n2.  每次牛顿迭代动态重计算：雅可比矩阵 $J(Y_i^{(k)})$ 在每个阶段 $i$ 的每一次牛顿-拉夫逊迭代 $k$ 中重新计算。矩阵 $M^{(k)} = I - h \\gamma J(Y_i^{(k)})$ 被形成、进行 LU 分解，并用于求解更新量 $\\Delta^{(k)}$。这在每一次牛顿迭代中都会产生 $1$ 次分解和 $1$ 次求解的成本。此策略计算成本高昂，但预计将更加鲁棒，提供更快的牛顿收敛速度（通常是二次收敛），因为它使用了非线性系统的最新线性化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef f_vdp(u, mu):\n    \"\"\"Computes the right-hand side of the Van der Pol oscillator ODE.\"\"\"\n    x, y = u\n    return np.array([y, mu * (1.0 - x**2) * y - x])\n\ndef J_vdp(u, mu):\n    \"\"\"Computes the Jacobian of the Van der Pol oscillator ODE.\"\"\"\n    x, y = u\n    return np.array([[0.0, 1.0], [-2.0 * mu * x * y - 1.0, mu * (1.0 - x**2)]])\n\ndef integrate(strategy, u0, mu, h, T, tol, max_it):\n    \"\"\"\n    Integrates the Van der Pol ODE using a 2-stage SDIRK method with a specified\n    Jacobian handling strategy.\n\n    Args:\n        strategy (str): 'static' or 'dynamic'.\n        u0 (np.ndarray): Initial condition [x0, y0].\n        mu (float): Stiffness parameter.\n        h (float): Time step size.\n        T (float): Final time.\n        tol (float): Newton-Raphson convergence tolerance.\n        max_it (int): Maximum Newton iterations per stage.\n\n    Returns:\n        tuple: (total_factorizations, total_solves, total_failed_steps, final_residual_norm)\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    a11 = gamma\n    a21 = 1.0 - gamma\n    a22 = gamma\n\n    u = u0.copy()\n    num_steps = int(round(T / h))\n    I = np.identity(2)\n\n    total_factorizations = 0\n    total_solves = 0\n    total_failed_steps = 0\n    final_residual_norm = 0.0\n    \n    lu, piv = None, None\n    if strategy == 'static':\n        J_u0 = J_vdp(u0, mu)\n        M_static = I - h * a11 * J_u0\n        try:\n            lu, piv = linalg.lu_factor(M_static)\n            total_factorizations += 1\n        except linalg.LinAlgError:\n            # If initial matrix is singular, the static method cannot proceed.\n            return (1, 0, num_steps, np.inf)\n\n    for n in range(num_steps):\n        u_n = u.copy()\n        \n        # --- Stage 1 ---\n        Y1 = u_n.copy()  # Initial guess: Y_1^(0) = u_n\n        s1_converged = False\n        G1 = np.array([np.inf, np.inf])\n        \n        for _ in range(max_it):\n            G1 = Y1 - u_n - h * a11 * f_vdp(Y1, mu)\n            if linalg.norm(G1) = tol:\n                s1_converged = True\n                break\n            \n            try:\n                if strategy == 'static':\n                    delta = linalg.lu_solve((lu, piv), -G1)\n                    total_solves += 1\n                else:  # dynamic\n                    J_Y1 = J_vdp(Y1, mu)\n                    M = I - h * a11 * J_Y1\n                    lu_k, piv_k = linalg.lu_factor(M)\n                    total_factorizations += 1\n                    delta = linalg.lu_solve((lu_k, piv_k), -G1)\n                    total_solves += 1\n                Y1 += delta\n            except linalg.LinAlgError:\n                break  # Newton solver failure, stage fails\n\n        # --- Stage 2 ---\n        u_n_stage2_const = u_n + h * a21 * f_vdp(Y1, mu)\n        Y2 = u_n_stage2_const.copy()  # Initial guess: Y_2^(0)\n        s2_converged = False\n        G2 = np.array([np.inf, np.inf])\n\n        for _ in range(max_it):\n            G2 = Y2 - u_n_stage2_const - h * a22 * f_vdp(Y2, mu)\n            if linalg.norm(G2) = tol:\n                s2_converged = True\n                break\n            \n            try:\n                if strategy == 'static':\n                    delta = linalg.lu_solve((lu, piv), -G2)\n                    total_solves += 1\n                else:  # dynamic\n                    J_Y2 = J_vdp(Y2, mu)\n                    M = I - h * a22 * J_Y2\n                    lu_k, piv_k = linalg.lu_factor(M)\n                    total_factorizations += 1\n                    delta = linalg.lu_solve((lu_k, piv_k), -G2)\n                    total_solves += 1\n                Y2 += delta\n            except linalg.LinAlgError:\n                break # Newton solver failure, stage fails\n\n        if not s1_converged or not s2_converged:\n            total_failed_steps += 1\n        \n        u = Y2\n        \n        if n == num_steps - 1:\n            final_residual_norm = linalg.norm(G2)\n\n    return total_factorizations, total_solves, total_failed_steps, final_residual_norm\n\ndef solve():\n    # Test cases: (mu, h, T, tol, max_it)\n    test_cases = [\n        (10, 0.02, 2.0, 1e-10, 20),\n        (1000, 0.001, 0.1, 1e-9, 20),\n        (1000, 0.01, 0.1, 1e-9, 25),\n        (1, 0.1, 2.0, 1e-10, 20),\n    ]\n\n    results = []\n    for params in test_cases:\n        mu, h, T, tol, max_it = params\n        u0 = np.array([2.0, 0.0])\n\n        fact_s, solves_s, fails_s, res_s = integrate('static', u0, mu, h, T, tol, max_it)\n        fact_d, solves_d, fails_d, res_d = integrate('dynamic', u0, mu, h, T, tol, max_it)\n\n        results.append([fact_s, solves_s, fails_s, res_s, fact_d, solves_d, fails_d, res_d])\n\n    # Final print statement must be a single line with the specified format.\n    print(f\"{results}\")\n\nsolve()\n```"
        }
    ]
}