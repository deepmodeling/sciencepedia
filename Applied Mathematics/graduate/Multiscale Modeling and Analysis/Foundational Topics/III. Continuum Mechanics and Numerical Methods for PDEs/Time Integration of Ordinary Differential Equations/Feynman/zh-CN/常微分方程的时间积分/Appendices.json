{
    "hands_on_practices": [
        {
            "introduction": "在求解常微分方程，特别是多尺度模型中常见的刚性问题时，分析数值方法的稳定性至关重要。稳定性函数 $R(z)$ 是一个核心工具，它描述了数值格式在标准线性测试方程 $y'=\\lambda y$ 上的表现。此练习  将引导你为一个强大的隐式龙格-库塔方法——高斯-勒让德格式——推导其稳定性函数，并分析其关键的解析性质，从而深入理解 A-稳定性和 L-稳定性等概念。",
            "id": "3824469",
            "problem": "考虑常微分方程（ODE）初值问题的线性检验方程 $y'(t)=\\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $y(t)$ 是标量。在多尺度建模背景下，时间积分格式通过此检验方程的放大因子进行评估，放大因子定义为 $z=h\\lambda$，其中 $h$ 是时间步长。考虑具有以下 Butcher 表数据的两级 Gauss–Legendre 配置 Runge–Kutta (RK) 方法：\n$$\nA=\\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}-\\frac{\\sqrt{3}}{6} \\\\[6pt]\n\\frac{1}{4}+\\frac{\\sqrt{3}}{6}  \\frac{1}{4}\n\\end{pmatrix},\\quad\n\\mathbf{b}=\\begin{pmatrix}\\frac{1}{2}\\\\[4pt]\\frac{1}{2}\\end{pmatrix},\\quad\n\\mathbf{c}=\\begin{pmatrix}\\frac{1}{2}-\\frac{\\sqrt{3}}{6}\\\\[4pt]\\frac{1}{2}+\\frac{\\sqrt{3}}{6}\\end{pmatrix}.\n$$\n从应用于检验方程 $y'(t)=\\lambda y(t)$ 的通用 Runge–Kutta 方法的级方程和更新规则出发，推导放大因子（稳定性函数）$R(z)$，使得单步更新满足 $y_{n+1}=R(z)\\,y_n$。然后，讨论 $R(z)$ 作为 $z\\in\\mathbb{C}$ 的函数的解析性质，包括：\n- 其极点的位置，\n- 其在虚轴上的行为，\n- 当 $|z|\\to\\infty$ 时的渐近行为，\n- 该方法是否是 $A$-稳定的以及是否是 $L$-稳定的。\n\n将最终的 $R(z)$ 表示为关于 $z$ 的闭式解析表达式。不需要进行数值舍入。最终答案必须是 $R(z)$ 的单个解析表达式。",
            "solution": "我们从应用于线性检验方程 $y'(t)=\\lambda y(t)$ 的 Runge–Kutta (RK) 方法的基本定义开始，其中 $z=h\\lambda$。对于一个具有 Butcher 系数 $A\\in\\mathbb{R}^{s\\times s}$、$\\mathbf{b}\\in\\mathbb{R}^{s}$ 和 $\\mathbf{c}\\in\\mathbb{R}^{s}$ 的 $s$-级 RK 方法，级值 $\\mathbf{K}\\in\\mathbb{C}^{s}$ 定义为\n$$\n\\mathbf{K}=\\lambda\\,y_n\\,\\mathbf{1}+z\\,A\\,\\mathbf{K},\n$$\n其中 $\\mathbf{1}\\in\\mathbb{R}^{s}$ 是全一向量，并且我们使用了 $z=h\\lambda$。重新整理得到\n$$\n\\left(I-zA\\right)\\mathbf{K}=\\lambda\\,y_n\\,\\mathbf{1},\\quad\\text{so}\\quad \\mathbf{K}=\\lambda\\,y_n\\,(I-zA)^{-1}\\mathbf{1}.\n$$\nRK 更新为\n$$\ny_{n+1}=y_n+h\\,\\mathbf{b}^{\\top}\\mathbf{K}=y_n+z\\,\\mathbf{b}^{\\top}(I-zA)^{-1}\\mathbf{1}\\,y_n,\n$$\n因此放大因子（稳定性函数）为\n$$\nR(z)=1+z\\,\\mathbf{b}^{\\top}(I-zA)^{-1}\\mathbf{1}.\n$$\n我们现在为给定的两级 Gauss–Legendre 配置方法计算 $R(z)$。记\n$$\nA=\\begin{pmatrix}\na  b\\\\\nc  a\n\\end{pmatrix},\\quad a=\\frac{1}{4},\\quad b=\\frac{1}{4}-\\frac{\\sqrt{3}}{6},\\quad c=\\frac{1}{4}+\\frac{\\sqrt{3}}{6},\\quad \\mathbf{b}=\\begin{pmatrix}\\frac{1}{2}\\\\[4pt]\\frac{1}{2}\\end{pmatrix}.\n$$\n则\n$$\nI-zA=\\begin{pmatrix}\n1-za  -zb\\\\\n-zc  1-za\n\\end{pmatrix}.\n$$\n一个 $2\\times 2$ 矩阵的逆是\n$$\n(I-zA)^{-1}=\\frac{1}{\\det(I-zA)}\\begin{pmatrix}\n1-za  zb\\\\\nzc  1-za\n\\end{pmatrix},\n$$\n其行列式为\n$$\n\\det(I-zA)=(1-za)^2-z^2\\,bc.\n$$\n计算 $bc$：\n$$\nbc=\\left(\\frac{1}{4}-\\frac{\\sqrt{3}}{6}\\right)\\left(\\frac{1}{4}+\\frac{\\sqrt{3}}{6}\\right)=\\frac{1}{16}-\\left(\\frac{\\sqrt{3}}{6}\\right)^2=\\frac{1}{16}-\\frac{3}{36}=\\frac{1}{16}-\\frac{1}{12}=-\\frac{1}{48}.\n$$\n因此\n$$\n\\det(I-zA)=(1-za)^2+\\frac{z^2}{48}=\\left(1-\\frac{z}{4}\\right)^2+\\frac{z^2}{48}=1-\\frac{z}{2}+\\frac{z^2}{16}+\\frac{z^2}{48}=1-\\frac{z}{2}+\\frac{z^2}{12}.\n$$\n接下来，计算 $(I-zA)^{-1}\\mathbf{1}$：\n$$\n(I-zA)^{-1}\\mathbf{1}=\\frac{1}{\\det(I-zA)}\\begin{pmatrix}\n(1-za)+zb\\\\\nzc+(1-za)\n\\end{pmatrix}.\n$$\n注意 $a-b=\\frac{1}{4}-\\left(\\frac{1}{4}-\\frac{\\sqrt{3}}{6}\\right)=\\frac{\\sqrt{3}}{6}$ 且 $c-a=\\left(\\frac{1}{4}+\\frac{\\sqrt{3}}{6}\\right)-\\frac{1}{4}=\\frac{\\sqrt{3}}{6}$，所以\n$$\n(1-za)+zb=1-z(a-b)=1-z\\frac{\\sqrt{3}}{6},\\qquad zc+(1-za)=1+z(c-a)=1+z\\frac{\\sqrt{3}}{6}.\n$$\n因此\n$$\n(I-zA)^{-1}\\mathbf{1}=\\frac{1}{\\det(I-zA)}\\begin{pmatrix}\n1-\\frac{\\sqrt{3}}{6}z \\\\[4pt]\n1+\\frac{\\sqrt{3}}{6}z\n\\end{pmatrix}.\n$$\n现在乘以 $\\mathbf{b}^{\\top}$：\n$$\n\\mathbf{b}^{\\top}(I-zA)^{-1}\\mathbf{1}=\\frac{1}{\\det(I-zA)}\\left[\\frac{1}{2}\\left(1-\\frac{\\sqrt{3}}{6}z\\right)+\\frac{1}{2}\\left(1+\\frac{\\sqrt{3}}{6}z\\right)\\right]=\\frac{1}{\\det(I-zA)}.\n$$\n因此\n$$\nR(z)=1+z\\,\\frac{1}{\\det(I-zA)}=1+\\frac{z}{1-\\frac{z}{2}+\\frac{z^2}{12}}=\\frac{1-\\frac{z}{2}+\\frac{z^2}{12}+z}{1-\\frac{z}{2}+\\frac{z^2}{12}}=\\frac{1+\\frac{z}{2}+\\frac{z^2}{12}}{1-\\frac{z}{2}+\\frac{z^2}{12}}.\n$$\n这个有理形式是 $\\exp(z)$ 的 $[2/2]$ Padé 近似，与4阶配置方法一致。\n\n我们现在讨论 $R(z)$ 的解析性质：\n\n$1.$ 极点：当分母为零时出现极点，\n$$\n1-\\frac{z}{2}+\\frac{z^2}{12}=0\\quad\\Longleftrightarrow\\quad z^2-6z+12=0.\n$$\n根为\n$$\nz=\\frac{6\\pm\\sqrt{36-48}}{2}=3\\pm i\\sqrt{3}.\n$$\n因此，$R(z)$ 是亚纯函数，在 $z=3\\pm i\\sqrt{3}$ 处有两个简单极点，它们都位于开放右半平面，这意味着它在闭合左半平面是解析的。\n\n$2.$ 在虚轴上的行为：令 $z=i\\omega$，其中 $\\omega\\in\\mathbb{R}$。那么分子和分母是复共轭的，\n$$\n\\text{num}=1+\\frac{i\\omega}{2}-\\frac{\\omega^2}{12},\\qquad \\text{den}=1-\\frac{i\\omega}{2}-\\frac{\\omega^2}{12}=\\overline{\\text{num}},\n$$\n所以\n$$\n|R(i\\omega)|=\\left|\\frac{\\text{num}}{\\text{den}}\\right|=1.\n$$\n虚轴上的这种单位模特性反映了其在振荡问题上的辛性和保能量特性。\n\n$3.$ 当 $|z|\\to\\infty$ 时的渐近性：分子和分母中的最高次项相同，均为 $\\frac{z^2}{12}$，所以\n$$\n\\lim_{|z|\\to\\infty}R(z)=1.\n$$\n因此，该方法不是 $L$-稳定的（$L$-稳定要求沿负实轴 $\\lim_{z\\to -\\infty}R(z)=0$）。\n\n$4.$ $A$-稳定性：如果对于所有满足 $\\Re(z)\\leq 0$ 的 $z$，都有 $|R(z)|\\leq 1$，则该方法是 $A$-稳定的。已知 Gauss–Legendre 配置 RK 方法是 $A$-稳定的，对于这个两级的情况，极点严格位于右半平面，并且在边界 $\\Re(z)=0$ 上有 $|R(i\\omega)|=1$，表明在虚轴上没有增长。结合 Gauss 方法的代数稳定性，这蕴含了 $A$-稳定性。然而，如上所述，该方法不是 $L$-稳定的。\n\n最后，我们可以通过级数展开来确认与 $\\exp(z)$ 的一致性。对分母使用几何级数，\n$$\n\\frac{1}{1-\\frac{z}{2}+\\frac{z^2}{12}}=1+\\frac{z}{2}+\\frac{z^2}{6}+\\frac{z^3}{24}+\\frac{z^4}{120}+O(z^5),\n$$\n并乘以分子 $1+\\frac{z}{2}+\\frac{z^2}{12}$ 得到\n$$\nR(z)=1+z+\\frac{z^2}{2}+\\frac{z^3}{6}+\\frac{z^4}{24}+O(z^5),\n$$\n与 $\\exp(z)$ 的泰勒展开式的前 $z^4$ 项相匹配，这与该方法在检验方程上具有4阶精度是一致的。\n\n因此，闭式放大因子为\n$$\nR(z)=\\frac{1+\\frac{z}{2}+\\frac{z^2}{12}}{1-\\frac{z}{2}+\\frac{z^2}{12}}.\n$$",
            "answer": "$$\\boxed{\\frac{1+\\frac{z}{2}+\\frac{z^{2}}{12}}{1-\\frac{z}{2}+\\frac{z^{2}}{12}}}$$"
        },
        {
            "introduction": "除了稳定性，一个可靠的数值方法还必须尊重所模拟系统的物理定律。例如，在化学反应网络中，物种的浓度在物理上必须是非负的。此练习  探讨了如何确保这一基本物理约束，要求你从第一性原理出发，为一个简单的显式欧拉法推导出一个为保持解的非负性所需的自适应步长条件。",
            "id": "3824513",
            "problem": "考虑一个具有 $d$ 个化学物种的封闭反应网络，其非负浓度由向量 $x(t) \\in \\mathbb{R}_{\\ge 0}^{d}$ 汇集表示。其动力学由一个自治常微分方程组（ODEs）建模：$$\\frac{d x}{d t} = S \\, r(x),$$ 其中 $S \\in \\mathbb{R}^{d \\times L}$ 是化学计量矩阵，$r(x) \\in \\mathbb{R}_{\\ge 0}^{L}$ 是反应速率向量。假设为具有非负速率常数的质量作用动力学，因此每个分量 $r_{\\ell}(x)$ 在非负象限上是光滑非负函数。对于每个物种索引 $i \\in \\{1,\\dots,d\\}$，通过定义将右端项分解为生成项和消耗项：$$p_{i}(x) := \\sum_{\\ell \\, : \\, S_{i \\ell} > 0} S_{i \\ell} \\, r_{\\ell}(x), \\qquad d_{i}(x) := \\sum_{\\ell \\, : \\, S_{i \\ell}  0} \\left(-S_{i \\ell}\\right) \\, r_{\\ell}(x),$$ 使得 $$\\frac{d x_{i}}{d t} = p_{i}(x) - d_{i}(x), \\qquad p_{i}(x) \\ge 0, \\quad d_{i}(x) \\ge 0 \\quad \\text{for all } x \\in \\mathbb{R}_{\\ge 0}^{d}。$$ 假设在一个固定时间 $t^{n}$，状态为 $x^{n} := x(t^{n}) \\in \\mathbb{R}_{\\ge 0}^{d}$，满足对所有 $i$ 都有 $x^{n}_{i} \\ge 0$，并且只要 $x^{n}_{i} > 0$，就至少存在一个反应 $\\ell$ 使得 $S_{i \\ell}  0$ 且 $r_{\\ell}(x^{n}) > 0$（这确保了在活性物种集合上 $d_{i}(x^{n}) > 0$）。\n\n请设计一个显式单步时间积分器，它使用前向欧拉构建块和自适应步长选择，从 $x^{n}$ 开始，在单个时间步长内保持浓度的非负性。请从第一性原理出发，仅使用上述定义，推导出一个最大允许步长 $\\Delta t_{\\max}(x^{n})$ 的闭式表达式，使得前向欧拉更新 $$x^{n+1} = x^{n} + \\Delta t \\, \\left( S \\, r(x^{n}) \\right) = x^{n} + \\Delta t \\, \\left( p(x^{n}) - d(x^{n}) \\right)$$ 对所有物种都保持逐分量非负。您的最终表达式必须仅依赖于 $S$ 和 $r(x^{n})$，并且在给定的假设下必须有效。请将您的最终答案表示为 $\\Delta t_{\\max}(x^{n})$ 的单一解析表达式。无需四舍五入。如果出现任何角度，请以弧度表示。如果出现任何物理单位，最终答案请不要带单位。",
            "solution": "该问题陈述经评估具有科学依据、是适定且客观的。它清晰、自洽地描述了化学动力学常微分方程数值积分中的一个标准问题。所有定义、变量和假设都经过了形式化陈述且在数学上是一致的。任务是从第一性原理出发，为前向欧拉法推导一个经典的稳定性结果，这是一个有效且有实质意义的问题。关于最终表达式依赖关系的微小歧义，可以通过将其解释为由时间 $t^n$ 可用量构成的表达式来解决，这是标准做法。\n\n目标是找到最大的时间步长 $\\Delta t_{\\max}(x^{n}) > 0$，使得前向欧拉更新能保持所有物种浓度的非负性。时间 $t^n$ 的状态由向量 $x^n \\in \\mathbb{R}_{\\ge 0}^d$ 给出，意味着对所有物种 $i \\in \\{1, \\dots, d\\}$ 都有 $x_i^n \\ge 0$。\n\n前向欧拉法根据以下规则，在一个时间步长 $\\Delta t$ 内将状态从 $x^n$ 更新到 $x^{n+1}$：\n$$x^{n+1} = x^n + \\Delta t \\, S \\, r(x^n)$$\n对每个分量 $i$ 写出此方程，得到：\n$$x_i^{n+1} = x_i^n + \\Delta t \\, (S \\, r(x^n))_i$$\n问题将右端项 $f_i(x) := (S \\, r(x))_i$ 分解为生成项 $p_i(x)$ 和消耗项 $d_i(x)$，使得 $f_i(x) = p_i(x) - d_i(x)$。使用此分解，分量 $i$ 的更新为：\n$$x_i^{n+1} = x_i^n + \\Delta t (p_i(x^n) - d_i(x^n))$$\n保持非负性的条件是，对所有 $i = 1, \\dots, d$ 都有 $x_i^{n+1} \\ge 0$。这产生了一个由 $d$ 个不等式组成的系统：\n$$x_i^n + \\Delta t (p_i(x^n) - d_i(x^n)) \\ge 0 \\qquad \\text{for } i = 1, \\dots, d$$\n为了找到对 $\\Delta t$ 的约束，我们必须分析每个不等式。\n\n我们对每个物种 $i$ 考虑两种情况：\n\n情况1：物种 $i$ 的净变化率非负，即 $p_i(x^n) - d_i(x^n) \\ge 0$。\n在这种情况下，由于 $x_i^n \\ge 0$ 且 $\\Delta t > 0$，项 $\\Delta t (p_i(x^n) - d_i(x^n))$ 是非负的。因此，和 $x_i^n + \\Delta t (p_i(x^n) - d_i(x^n))$ 保证是非负的。因此，对于任何浓度不减少的物种，非负性条件对任何 $\\Delta t \\ge 0$ 都满足。这样的物种对时间步长不施加上界。\n\n情况2：物种 $i$ 的净变化率是负的，即 $p_i(x^n) - d_i(x^n)  0$。\n在这种情况下，物种 $i$ 的浓度正在减少。可以重新整理不等式以分离出 $\\Delta t$：\n$$\\Delta t (p_i(x^n) - d_i(x^n)) \\ge -x_i^n$$\n由于项 $(p_i(x^n) - d_i(x^n))$ 是负的，用它相除会使不等号反向：\n$$\\Delta t \\le \\frac{-x_i^n}{p_i(x^n) - d_i(x^n)}$$\n这可以用消耗项和生成项更直观地写成：\n$$\\Delta t \\le \\frac{x_i^n}{d_i(x^n) - p_i(x^n)}$$\n这个不等式为 $\\Delta t$ 提供了一个上界，以防止物种 $i$ 的浓度变为负值。\n\n我们来分析分母。此情况的条件是 $p_i(x^n) - d_i(x^n)  0$，这等价于 $d_i(x^n) > p_i(x^n)$。由于根据定义 $p_i(x^n) \\ge 0$，这意味着 $d_i(x^n) > 0$。因此，分母 $d_i(x^n) - p_i(x^n)$ 是严格为正的，对 $\\Delta t$ 的界是良定的。\n\n问题指明了质量作用动力学。这意味着如果一个物种的浓度 $x_i^n = 0$，那么任何以物种 $i$ 为反应物的反应速率 $r_\\ell(x^n)$ 都必须为零。因此，消耗项 $d_i(x^n)$ 必须为零。在这种情况下，净速率为 $p_i(x^n) - d_i(x^n) = p_i(x^n) \\ge 0$。这意味着浓度为零的物种不能有负的净速率，所以它属于情况1。因此，情况2仅适用于 $x_i^n > 0$ 的物种 $i$。这确保了在情况2中推导出的所有约束中，分子 $x_i^n$ 都是严格为正的。\n\n全局时间步长 $\\Delta t$ 必须同时满足所有物种的非负性约束。因此，它必须小于或等于所有推导出的单个上界。最大允许步长 $\\Delta t_{\\max}(x^n)$ 是所有这些界的最小值。\n情况1中的物种贡献了一个有效上界 $\\infty$，这不约束最小值。因此，我们只需要考虑正在被消耗的物种集合（情况2）上的最小值。\n\n设浓度减少的物种的索引集合为 $I = \\{i \\in \\{1,\\dots,d\\} \\mid p_i(x^n) - d_i(x^n)  0\\}$。最大允许步长是：\n$$\\Delta t_{\\max}(x^n) = \\min_{i \\in I} \\left\\{ \\frac{x_i^n}{d_i(x^n) - p_i(x^n)} \\right\\}$$\n如果集合 $I$ 为空（即没有物种浓度在减少），则空集上的最小值定义为 $+\\infty$，意味着任何步长都是允许的。\n\n为了用所要求的 $S$ 和 $r(x^n)$ 来表示，我们使用关系式 $(S r(x^n))_i = p_i(x^n) - d_i(x^n)$。属于集合 $I$ 的条件是 $(S r(x^n))_i  0$。分母是 $d_i(x^n) - p_i(x^n) = -(p_i(x^n) - d_i(x^n)) = -(S r(x^n))_i$。\n将这些代入 $\\Delta t_{\\max}(x^n)$ 的表达式中，得到最终形式：\n$$\\Delta t_{\\max}(x^n) = \\min_{i \\,:\\, (S r(x^n))_i  0} \\left\\{ \\frac{x_i^n}{-(S r(x^n))_i} \\right\\}$$\n这个表达式是当前状态 $x^n$ 以及封装在 $S$ 和速率函数 $r$ 中的反应数据的函数。它提供了保证前向欧拉步不会产生负浓度的最大步长。",
            "answer": "$$\\boxed{\\min_{i \\in \\{1, \\dots, d\\} \\,:\\, (S r(x^n))_i  0} \\left\\{ \\frac{-x_i^n}{(S r(x^n))_i} \\right\\}}$$"
        },
        {
            "introduction": "在探讨了稳定性和物理约束等理论性质之后，我们将注意力转向实际的计算实现。虽然隐式方法在处理刚性问题时非常有效，但它们需要在每个时间步求解非线性方程组，这可能带来巨大的计算开销。这个动手编程练习  旨在解决这一核心挑战，要求你实现并比较在求解过程中处理雅可比矩阵的不同策略，并量化计算成本与收敛稳健性之间的权衡。",
            "id": "3824480",
            "problem": "考虑一个由向量函数 $f:\\mathbb{R}^2\\to\\mathbb{R}^2$ 定义的常微分方程组，其状态 $u(t)=[x(t),y(t)]^\\top$ 满足初值问题 $u'(t)=f(u(t))$，$u(0)=u_0$，其中 $f(u)$ 的选择旨在表现出多尺度刚性，以反映多尺度建模与分析的背景。其基础包括常微分方程的定义以及线法时间积分框架，该框架通过源于不动点条件的一致性隐式时间步进和非线性求解，在离散时间点上逼近 $u(t)$。你需要实现一个具有两级和刚性精度的对角隐式龙格-库塔 (DIRK) 单对角格式（也称为单对角隐式龙格-库塔 (SDIRK)），并比较在不同时间步之间重用雅可比矩阵的两种策略。目标是量化雅可比矩阵分解成本与收敛稳健性之间的权衡。\n\n设模型为处于刚性状态的范德波尔振子，定义为\n$$\nf\\left(\\begin{bmatrix}x\\\\y\\end{bmatrix}\\right)=\n\\begin{bmatrix}\ny \\\\\n\\mu\\,(1-x^2)\\,y - x\n\\end{bmatrix},\n$$\n其中刚性参数 $\\mu>0$。雅可比矩阵 $J(u)=\\frac{\\partial f}{\\partial u}(u)$ 为\n$$\nJ(x,y)=\n\\begin{bmatrix}\n0  1 \\\\\n-2\\mu x y - 1  \\mu(1-x^2)\n\\end{bmatrix}.\n$$\n\n使用二级二阶刚性精确的 SDIRK 格式，其对角系数为 $\\gamma=1-\\frac{1}{\\sqrt{2}}$。其 Butcher 系数为\n$$\nA=\n\\begin{bmatrix}\n\\gamma  0\\\\\n1-\\gamma  \\gamma\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}1-\\gamma\\\\ \\gamma\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\\gamma\\\\ 1\\end{bmatrix},\n$$\n其中 $\\gamma=1-\\frac{1}{\\sqrt{2}}$。\n\n给定一个从 $t_n$ 到 $t_{n+1}=t_n+h$ 的当前时间步和当前解 $u_n$，DIRK 级方程由级值 $Y_i$ 的不动点条件定义：\n$$\nG_i(Y_i)=Y_i - u_n - h\\sum_{j=1}^{i} a_{ij} f(Y_j)=0,\n$$\n对于 $i\\in\\{1,2\\}$，其中 $a_{ij}$ 是矩阵 $A$ 的元素。使用牛顿-拉夫逊方法 (NR) 求解每个级方程，该方法将 $G_i$ 在迭代点 $Y_i^{(k)}$ 附近线性化并求解\n$$\n\\left[I - h\\,a_{ii}\\,J\\left(Y_i^{(k)}\\right)\\right]\\,\\Delta_i^{(k)} = -G_i\\left(Y_i^{(k)}\\right),\n$$\n然后更新 $Y_i^{(k+1)}=Y_i^{(k)}+\\Delta_i^{(k)}$。使用 $Y_1^{(0)}=u_n$ 和 $Y_2^{(0)}=u_n + h\\,(1-\\gamma)\\,f(Y_1)$ 作为初始猜测值。由于具有刚性精度，步长更新为 $u_{n+1}=Y_2$。\n\n实现并比较以下两种跨步的雅可比矩阵重用策略：\n\n- 跨步静态重用：在积分开始时，使用初始条件 $u_0$ 计算并分解线性系统矩阵 $M=I - h\\,\\gamma\\,J(u_0)$ 一次。为所有级和所有时间步中的所有牛顿求解重用这单个分解，即使 $J(u)$ 随时间变化也不进行更新。将 $M$ 的每次分解计为成本 1。将每次使用该分解的三角求解计为成本 1 次求解。此策略模拟了极致的重用，以牺牲牛顿法收敛稳健性为代价，最大限度地降低分解成本。\n\n- 每次牛顿迭代动态重计算：在每个时间步的每个级的每次牛顿迭代中，在当前迭代点计算雅可比矩阵 $J(Y_i^{(k)})$，构建 $M=I - h\\,\\gamma\\,J(Y_i^{(k)})$，对其进行分解，并求解 $\\Delta_i^{(k)}$。按前述方式计算每次分解和求解的成本。此策略模拟了积极的更新，以牺牲更高的分解成本为代价，最大限度地提高收敛稳健性。\n\n收敛稳健性通过在最大允许牛顿迭代次数内至少有一个级未能达到牛顿-拉夫逊容差的时间步数来量化。对于每个时间步和每个级，如果在最多 $\\text{max\\_it}$ 次迭代内满足 $\\|G_i(Y_i^{(k)})\\|_2 \\le \\text{tol}$，则声明收敛；否则声明该步失败。将最后时间步结束时的欧几里得范数 $\\|G_2(Y_2^{(\\text{final})})\\|_2$ 记录为代表性的最终残差。\n\n你必须实现一个完整的程序，该程序：\n- 使用两种策略在具有恒定步长 $h$ 的固定时间网格上对系统进行积分。\n- 对每种策略，追踪并报告雅可比矩阵分解的总次数、线性求解的总次数、失败步长的总数以及最后一步结束时的最终残差范数。\n- 精确地按照上述定义使用指定的 SDIRK 方法、牛顿-拉夫逊方法和成本核算。\n\n使用以下参数集测试套件，每个测试用例以 $(\\mu,h,T,\\text{tol},\\text{max\\_it})$ 形式给出，初始条件为 $u_0=[x(0),y(0)]^\\top=[2,0]^\\top$：\n- 测试 1：$(\\mu=\\;10,\\;h=\\;0.02,\\;T=\\;2.0,\\;\\text{tol}=\\;10^{-10},\\;\\text{max\\_it}=\\;20)$\n- 测试 2：$(\\mu=\\;1000,\\;h=\\;0.001,\\;T=\\;0.1,\\;\\text{tol}=\\;10^{-9},\\;\\text{max\\_it}=\\;20)$\n- 测试 3：$(\\mu=\\;1000,\\;h=\\;0.01,\\;T=\\;0.1,\\;\\text{tol}=\\;10^{-9},\\;\\text{max\\_it}=\\;25)$\n- 测试 4：$(\\mu=\\;1,\\;h=\\;0.1,\\;T=\\;2.0,\\;\\text{tol}=\\;10^{-10},\\;\\text{max\\_it}=\\;20)$\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个子列表，包含八个条目，顺序如下：\n$[\\text{fact\\_static},\\text{solves\\_static},\\text{fails\\_static},\\text{final\\_res\\_static},\\text{fact\\_dynamic},\\text{solves\\_dynamic},\\text{fails\\_dynamic},\\text{final\\_res\\_dynamic}]$。\n所有条目必须是整数或浮点数类型。例如，输出格式应类似于 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ 的单行。",
            "solution": "该问题是有效的，因为它在刚性常微分方程的数值分析领域提出了一个适定的、有科学依据且完全指定的任务，而这是多尺度建模的一个核心组成部分。所有必要的数据、方程和评估标准都已提供，没有歧义或矛盾。我们继续进行求解。\n\n目标是实现一个特定的二级二阶刚性精确的单对角隐式龙格-库塔 (SDIRK) 方法来求解刚性范德波尔振子，并比较在级方程的牛顿-拉夫逊求解器中处理雅可比矩阵的两种不同策略的性能。\n\n常微分方程组 (ODE) 由 $u'(t) = f(u(t))$ 给出，状态向量为 $u(t) = [x(t), y(t)]^\\top$。对于范德波尔振子，函数 $f: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 定义为：\n$$\nf\\left(\\begin{bmatrix}x\\\\y\\end{bmatrix}\\right)=\n\\begin{bmatrix}\ny \\\\\n\\mu\\,(1-x^2)\\,y - x\n\\end{bmatrix}\n$$\n其中 $\\mu > 0$ 是一个控制系统刚性的参数。初始条件指定为 $u_0 = u(0) = [2, 0]^\\top$。右端函数的雅可比矩阵 $J(u) = \\frac{\\partial f}{\\partial u}(u)$ 为：\n$$\nJ(x,y)=\n\\begin{bmatrix}\n0  1 \\\\\n-2\\mu x y - 1  \\mu(1-x^2)\n\\end{bmatrix}\n$$\n\n从时间 $t_n$ 到 $t_{n+1} = t_n + h$ 的数值积分使用一个由 Butcher 系数定义的两级 SDIRK 方法：\n$$\nA=\n\\begin{bmatrix}\n\\gamma  0\\\\\n1-\\gamma  \\gamma\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}1-\\gamma\\\\ \\gamma\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\\gamma\\\\ 1\\end{bmatrix}\n$$\n对角元素为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。级值 $Y_1$ 和 $Y_2$ 是以下隐式方程的解：\n$$\nG_1(Y_1) = Y_1 - u_n - h \\gamma f(Y_1) = 0 \\\\\nG_2(Y_2) = Y_2 - u_n - h(1-\\gamma)f(Y_1) - h \\gamma f(Y_2) = 0\n$$\n其中 $u_n$ 是时间 $t_n$ 的解，第二个方程中的 $Y_1$ 是第一级收敛后的解。该方法是刚性精确的，因为 $c_2 = 1$ 且 $A$ 的第二行系数与 $b$ 的系数匹配。这一性质使得步长更新简单而稳定：$u_{n+1} = Y_2$。\n\n每个级方程都是一个使用牛顿-拉夫逊方法求解的非线性代数方程组。对于形如 $Y - C - h \\gamma f(Y) = 0$ 的一般级方程，其中 $C$ 代表所有显式项，我们将要清零的函数定义为 $F(Y) = Y - C - h \\gamma f(Y)$。牛顿-拉夫逊迭代通过在当前迭代点 $Y^{(k)}$ 将 $F(Y)$ 线性化来进行：\n$$\nF(Y^{(k)}) + F'(Y^{(k)})(Y^{(k+1)} - Y^{(k)}) \\approx 0\n$$\n$F$ 的雅可比矩阵是 $F'(Y) = I - h \\gamma J(Y)$，其中 $I$ 是 $2 \\times 2$ 单位矩阵。将更新记为 $\\Delta^{(k)} = Y^{(k+1)} - Y^{(k)}$，我们在每次迭代中求解以下线性系统以得到 $\\Delta^{(k)}$：\n$$\n\\left[I - h \\gamma J\\left(Y^{(k)}\\right)\\right]\\,\\Delta^{(k)} = -\\left( Y^{(k)} - C - h \\gamma f(Y^{(k)}) \\right)\n$$\n下一个迭代点是 $Y^{(k+1)} = Y^{(k)} + \\Delta^{(k)}$。牛顿求解器的初始猜测值是第一级的 $Y_1^{(0)} = u_n$ 和第二级的 $Y_2^{(0)} = u_n + h(1-\\gamma)f(Y_1)$。迭代持续进行，直到残差的欧几里得范数 $\\|F(Y^{(k)})\\|_2$ 小于或等于指定的容差 `tol`，或达到最大迭代次数 `max_it`。\n\n问题的核心是在此框架内比较两种雅可比矩阵处理策略：\n\n1.  **跨步静态重用**：雅可比矩阵仅在初始条件 $u_0$ 下计算一次。线性系统矩阵 $M_{static} = I - h \\gamma J(u_0)$ 在积分开始时构建并进行 LU 分解。这个单一的分解随后被重用于所有时间步中所有级的全部牛顿-拉夫逊求解。根据问题的成本模型，该策略在整个模拟中产生 1 次分解成本和每次牛顿迭代 1 次求解（使用 LU 因子进行前向/后向代入）成本。这种方法最大限度地减少了与分解相关的计算成本，但如果真实的雅可比矩阵 $J(u(t))$ 与 $J(u_0)$ 显著偏离，可能会遭受收敛速度慢或失败的困扰。\n\n2.  **每次牛顿迭代动态重计算**：雅可比矩阵 $J(Y_i^{(k)})$ 在每个级 $i$ 的每一次牛顿-拉夫逊迭代 $k$ 中都会被重新计算。矩阵 $M^{(k)} = I - h \\gamma J(Y_i^{(k)})$ 被构建、进行 LU 分解，并用于求解更新 $\\Delta^{(k)}$。这将在每次牛顿迭代中产生 1 次分解和 1 次求解的成本。这种策略计算成本高昂，但预计会稳健得多，能提供更快的牛顿收敛速度（通常是二次收敛），因为它使用了非线性系统的最新线性化。\n\n算法被实现为以恒定步长 $h$ 从 $t=0$ 到 $T$ 进行时间步进。对于每种策略，我们追踪四个指标：雅可比矩阵分解的总次数、线性求解的总次数、至少一个级未能收敛的时间步总数，以及来自最后一个时间步的最终残差范数 $\\|G_2(Y_2^{(\\text{final})})\\|_2$。最终答案中提供的 Python 代码对指定的测试用例执行了此比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef f_vdp(u, mu):\n    \"\"\"Computes the right-hand side of the Van der Pol oscillator ODE.\"\"\"\n    x, y = u\n    return np.array([y, mu * (1.0 - x**2) * y - x])\n\ndef J_vdp(u, mu):\n    \"\"\"Computes the Jacobian of the Van der Pol oscillator ODE.\"\"\"\n    x, y = u\n    return np.array([[0.0, 1.0], [-2.0 * mu * x * y - 1.0, mu * (1.0 - x**2)]])\n\ndef integrate(strategy, u0, mu, h, T, tol, max_it):\n    \"\"\"\n    Integrates the Van der Pol ODE using a 2-stage SDIRK method with a specified\n    Jacobian handling strategy.\n\n    Args:\n        strategy (str): 'static' or 'dynamic'.\n        u0 (np.ndarray): Initial condition [x0, y0].\n        mu (float): Stiffness parameter.\n        h (float): Time step size.\n        T (float): Final time.\n        tol (float): Newton-Raphson convergence tolerance.\n        max_it (int): Maximum Newton iterations per stage.\n\n    Returns:\n        tuple: (total_factorizations, total_solves, total_failed_steps, final_residual_norm)\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    a11 = gamma\n    a21 = 1.0 - gamma\n    a22 = gamma\n\n    u = u0.copy()\n    num_steps = int(round(T / h))\n    I = np.identity(2)\n\n    total_factorizations = 0\n    total_solves = 0\n    total_failed_steps = 0\n    final_residual_norm = 0.0\n    \n    lu, piv = None, None\n    if strategy == 'static':\n        J_u0 = J_vdp(u0, mu)\n        M_static = I - h * a11 * J_u0\n        try:\n            lu, piv = linalg.lu_factor(M_static)\n            total_factorizations += 1\n        except linalg.LinAlgError:\n            # If initial matrix is singular, the static method cannot proceed.\n            return (1, 0, num_steps, np.inf)\n\n    for n in range(num_steps):\n        u_n = u.copy()\n        \n        # --- Stage 1 ---\n        Y1 = u_n.copy()  # Initial guess: Y_1^(0) = u_n\n        s1_converged = False\n        G1 = np.array([np.inf, np.inf])\n        \n        for _ in range(max_it):\n            G1 = Y1 - u_n - h * a11 * f_vdp(Y1, mu)\n            if linalg.norm(G1) = tol:\n                s1_converged = True\n                break\n            \n            try:\n                if strategy == 'static':\n                    delta = linalg.lu_solve((lu, piv), -G1)\n                    total_solves += 1\n                else:  # dynamic\n                    J_Y1 = J_vdp(Y1, mu)\n                    M = I - h * a11 * J_Y1\n                    lu_k, piv_k = linalg.lu_factor(M)\n                    total_factorizations += 1\n                    delta = linalg.lu_solve((lu_k, piv_k), -G1)\n                    total_solves += 1\n                Y1 += delta\n            except linalg.LinAlgError:\n                break  # Newton solver failure, stage fails\n\n        # --- Stage 2 ---\n        u_n_stage2_const = u_n + h * a21 * f_vdp(Y1, mu)\n        Y2 = u_n_stage2_const.copy()  # Initial guess: Y_2^(0)\n        s2_converged = False\n        G2 = np.array([np.inf, np.inf])\n\n        for _ in range(max_it):\n            G2 = Y2 - u_n_stage2_const - h * a22 * f_vdp(Y2, mu)\n            if linalg.norm(G2) = tol:\n                s2_converged = True\n                break\n            \n            try:\n                if strategy == 'static':\n                    delta = linalg.lu_solve((lu, piv), -G2)\n                    total_solves += 1\n                else:  # dynamic\n                    J_Y2 = J_vdp(Y2, mu)\n                    M = I - h * a22 * J_Y2\n                    lu_k, piv_k = linalg.lu_factor(M)\n                    total_factorizations += 1\n                    delta = linalg.lu_solve((lu_k, piv_k), -G2)\n                    total_solves += 1\n                Y2 += delta\n            except linalg.LinAlgError:\n                break # Newton solver failure, stage fails\n\n        if not s1_converged or not s2_converged:\n            total_failed_steps += 1\n        \n        u = Y2\n        \n        if n == num_steps - 1:\n            final_residual_norm = linalg.norm(G2)\n\n    return total_factorizations, total_solves, total_failed_steps, final_residual_norm\n\ndef solve():\n    # Test cases: (mu, h, T, tol, max_it)\n    test_cases = [\n        (10, 0.02, 2.0, 1e-10, 20),\n        (1000, 0.001, 0.1, 1e-9, 20),\n        (1000, 0.01, 0.1, 1e-9, 25),\n        (1, 0.1, 2.0, 1e-10, 20),\n    ]\n\n    results = []\n    for params in test_cases:\n        mu, h, T, tol, max_it = params\n        u0 = np.array([2.0, 0.0])\n\n        fact_s, solves_s, fails_s, res_s = integrate('static', u0, mu, h, T, tol, max_it)\n        fact_d, solves_d, fails_d, res_d = integrate('dynamic', u0, mu, h, T, tol, max_it)\n\n        results.append([fact_s, solves_s, fails_s, res_s, fact_d, solves_d, fails_d, res_d])\n\n    # Final print statement must be a single line with the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}