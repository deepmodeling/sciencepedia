{
    "hands_on_practices": [
        {
            "introduction": "在有限元分析中，施加狄利克雷（第一类）边界条件是求解过程中的一个基础且关键的步骤。本练习将引导您探索两种主流的施加策略：强约束法与弱约束法。通过为一个典型的泊肃叶流动问题  分别实现这两种方法，您将直接比较代数消除（强施加）与修正变分形式（以尼奇法为代表的弱施加）的差异，并量化它们对能量耗散率这一物理量的影响，从而深入理解弱约束法的灵活性与理论优势。",
            "id": "3732373",
            "problem": "考虑在恒定压力梯度下的直通道中的稳态不可压缩纳维-斯托克斯 (N-S) 方程，在惯性可以忽略的低雷诺数情况下。在此极限下，控制动量平衡简化为斯托克斯问题，对于单向流，则简化为一维标量扩散方程。设轴向速度为 $u(y)$，定义在单位区间 $y \\in [0,1]$ 上。该模型问题为\n$$\n-\\frac{d}{dy}\\left(\\nu(y)\\frac{du}{dy}\\right) = G \\quad \\text{for } y \\in (0,1),\n$$\n并带有无滑移壁面条件\n$$\nu(0) = 0, \\quad u(1) = 0,\n$$\n其中 $\\nu(y) > 0$ 是运动粘度，$G>0$ 是代表无量纲化轴向压力梯度的常数。这种一维简化是层流通道流中斯托克斯极限下不可压缩 N-S 方程的科学一致的特例，它为分析有限元法 (FEM) 中边界条件的施加方式如何影响能量耗散提供了一个典型场景。\n\n你将使用有限元法 (FEM) 对此边值问题进行离散化，在将 $[0,1]$ 均匀划分为 $N$ 个相等子区间的网格上，使用连续分段线性基函数。其弱形式在内部使用标准的双线性项：\n$$\na(u,v) = \\int_0^1 \\nu(y)\\, \\frac{du}{dy}\\, \\frac{dv}{dy}\\, dy,\n$$\n以及线性泛函\n$$\n\\ell(v) = \\int_0^1 G \\, v(y)\\, dy.\n$$\n必须实现两种不同的边界条件施加策略：\n- 本质边界条件的强施加法，其中 $y=0$ 和 $y=1$ 处的节点值被设置为给定值，并从线性系统中消去。\n- Nitsche 型 Dirichlet 边界条件的弱施加法，特化为在 $y=0$ 和 $y=1$ 处的齐次 Dirichlet 数据 $u=0$，并采用对称且一致的格式。对于具有可变系数 $\\nu(y)$ 的扩散算子，Nitsche 双线性形式通过边界项来扩充 $a(u,v)$\n$$\na_{\\text{N}}(u,v) = a(u,v) - \\sum_{y_b \\in \\{0,1\\}} \\nu(y_b)\\, \\left(\\frac{du}{dy}(y_b)\\, n_b\\, v(y_b) + \\frac{dv}{dy}(y_b)\\, n_b\\, u(y_b)\\right) + \\sum_{y_b \\in \\{0,1\\}} \\frac{\\gamma\\, \\nu(y_b)}{h}\\, u(y_b)\\, v(y_b),\n$$\n其中 $n_b$ 是边界点 $y_b$ 处的外单位法向量（因此 $n_0=-1$ 且 $n_1=+1$），$h$ 是网格尺寸，$\\gamma>0$ 是罚参数。对于齐次 Dirichlet 数据，线性泛函保持为 $\\ell(v)$。已知此格式是一致的，并且对于足够大的 $\\gamma$ 是矫顽的；其在一维下的特例可以根据在边界节点处求值的基函数导数，得到可计算的边界贡献项。\n\n对于每个计算出的离散解 $u_h(y)$，定义无量纲粘性能量耗散率\n$$\nD = \\int_0^1 \\nu(y)\\, \\left(\\frac{du_h}{dy}\\right)^2 dy,\n$$\n在完整的不可压缩 N-S 设置中，这可以推广为 $D = 2\\int_{\\Omega} \\nu\\, \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\, d\\Omega$，其中 $\\boldsymbol{\\varepsilon}$ 是对称梯度；在当前的一维简化中，它简化为上述标量形式。最终答案必须以无量纲浮点数的形式报告，不带任何物理单位。\n\n实现一个完整的程序，该程序：\n- 使用单元中点积分法，为具有可变系数 $\\nu(y)$ 的内部双线性形式组装 FEM 刚度矩阵和载荷向量。\n- 通过消除边界自由度并求解简化后的系统来实现强施加法。\n- 通过将带有罚参数 $\\gamma$ 的对称、一致的边界项添加到完整系统中并求解所有节点值来实现 Nitsche 施加法。\n- 通过在每个单元上使用离散梯度，对单元贡献求和来计算 $D$。\n\n使用以下测试套件，其设计旨在探究一系列行为，包括具有已知解析标度律的均匀粘度情况、多尺度非均匀粘度情况，以及具有不同罚参数的粗网格边缘情况：\n- 测试用例 1：均匀粘度 $\\nu(y) = 1$，网格划分数 $N = 32$，压力梯度 $G = 1$，Nitsche 罚参数 $\\gamma = 10$。\n- 测试用例 2：振荡粘度 $\\nu(y) = 1 + 0.4 \\sin(10 \\pi y)$（一个多尺度代理），$N = 64$，$G = 1$，$\\gamma = 10$。\n- 测试用例 3：均匀粘度 $\\nu(y) = 1$，粗网格 $N = 8$，$G = 1$，$\\gamma = 2.5$。\n- 测试用例 4：均匀粘度 $\\nu(y) = 1$，粗网格 $N = 8$，$G = 1$，$\\gamma = 100$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须按顺序包含为每个测试用例的强施加法和 Nitsche 施加法计算的能量耗散率。具体来说，输出格式必须是\n$$\n[\\text{D\\_strong\\_1},\\text{D\\_nitsche\\_1},\\text{D\\_strong\\_2},\\text{D\\_nitsche\\_2},\\text{D\\_strong\\_3},\\text{D\\_nitsche\\_3},\\text{D\\_strong\\_4},\\text{D\\_nitsche\\_4}],\n$$\n其中每个条目都是一个浮点数。不应打印任何额外的文本或单位。",
            "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它在科学上是合理的、适定的和完整的。该问题要求为一个一维斯托克斯流模型实现并比较两种有限元边界条件施加方法。\n\n轴向速度 $u(y)$ 的控制性边值问题是在区域 $y \\in [0,1]$ 上的一个一维扩散方程：\n$$\n-\\frac{d}{dy}\\left(\\nu(y)\\frac{du}{dy}\\right) = G, \\quad \\text{with } u(0) = 0, \\quad u(1) = 0.\n$$\n这里，$\\nu(y) > 0$ 是运动粘度，$G > 0$ 是一个恒定的压力梯度。\n\n为了使用有限元法 (FEM) 解决这个问题，我们首先推导其弱形式。将该方程乘以一个测试函数 $v(y)$（对于标准的伽辽金法，其中 $v(0)=v(1)=0$），并在整个区域上积分，得到：\n$$\n-\\int_0^1 v(y) \\frac{d}{dy}\\left(\\nu(y)\\frac{du}{dy}\\right) dy = \\int_0^1 G v(y) dy.\n$$\n对左侧应用分部积分，我们得到：\n$$\n- \\left[ v(y) \\nu(y) \\frac{du}{dy} \\right]_0^1 + \\int_0^1 \\nu(y) \\frac{du}{dy} \\frac{dv}{dy} dy = \\int_0^1 G v(y) dy.\n$$\n由于测试函数 $v(y)$ 在边界处为零，边界项为零。这导出了标准的弱形式：寻找 $u \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$，\n$$\na(u,v) = \\ell(v),\n$$\n其中双线性形式 $a(u,v)$ 和线性泛函 $\\ell(v)$ 定义为：\n$$\na(u,v) = \\int_0^1 \\nu(y) \\frac{du}{dy} \\frac{dv}{dy} dy, \\quad \\ell(v) = \\int_0^1 G v(y) dy.\n$$\n该问题在一个包含 $N$ 个单元的均匀网格上进行离散化，网格尺寸为 $h=1/N$，节点为 $y_i = i h$，$i=0, \\dots, N$。我们使用连续的分段线性 (P1) 基函数，也称为“帽”函数，记为 $\\phi_i(y)$，其中 $\\phi_i(y_j) = \\delta_{ij}$。近似解 $u_h(y)$ 是这些基函数的线性组合：\n$$\nu_h(y) = \\sum_{j=0}^{N} U_j \\phi_j(y),\n$$\n其中 $U_j$ 是未知的速度节点值。\n\n将 $u_h(y)$ 代入弱形式，并对每个基函数 $i$ 选择 $v(y) = \\phi_i(y)$，可得到一个线性方程组 $KU=F$，其中 $K$ 是刚度矩阵，$F$ 是载荷向量。其各项由 $K_{ij} = a(\\phi_j, \\phi_i)$ 和 $F_i = \\ell(\\phi_i)$ 给出。\n\n问题指定使用单元中点积分进行组装。在一个通用单元 $e_k = [y_{k-1}, y_k]$ 上，局部基函数 $\\phi_{k-1}$ 和 $\\phi_k$ 的导数是常数：$d\\phi_{k-1}/dy = -1/h$ 和 $d\\phi_k/dy = 1/h$。单元刚度矩阵 $K^{(k)}$ 和载荷向量 $F^{(k)}$ 近似为：\n$$\nK^{(k)} \\approx h \\cdot \\nu(y_{k-1/2}) \\begin{pmatrix} (-1/h)^2  (-1/h)(1/h) \\\\ (1/h)(-1/h)  (1/h)^2 \\end{pmatrix} = \\frac{\\nu(y_{k-1/2})}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix},\n$$\n$$\nF^{(k)} \\approx h \\cdot G \\begin{pmatrix} \\phi_{k-1}(y_{k-1/2}) \\\\ \\phi_k(y_{k-1/2}) \\end{pmatrix} = \\frac{Gh}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix},\n$$\n其中 $y_{k-1/2}$ 是单元的中点。这些局部贡献被组装到全局 $(N+1) \\times (N+1)$ 矩阵 $K$ 和向量 $F$ 中。\n\n使用两种方法来施加齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$：\n\n1.  **强施加法**：直接施加条件 $U_0=0$ 和 $U_N=0$。这通过移除全局系统的第一行和最后一行以及第一列和最后一列来实现，从而得到一个用于内部节点值 $U_1, \\dots, U_{N-1}$ 的 $(N-1) \\times (N-1)$ 简化系统。然后，通过在前面和后面附加已知的零边界值来构建解向量。\n\n2.  **Nitsche 方法**：通过扩充双线性形式来弱施加边界条件。原始的弱形式被修改以适用于 P1 函数的整个空间，而不仅仅是那些在边界上为零的函数。所提供的对称 Nitsche 格式为：\n    $$\n    a_{\\text{N}}(u,v) = a(u,v) - \\sum_{y_b \\in \\{0,1\\}} \\nu_b \\left(\\frac{du}{dy} n_b v + \\frac{dv}{dy} n_b u\\right) + \\sum_{y_b \\in \\{0,1\\}} \\frac{\\gamma \\nu_b}{h} u v,\n    $$\n    其中 $n_0=-1$，$n_1=1$，$\\nu_b = \\nu(y_b)$，$\\gamma$ 是一个罚参数。对于齐次条件，线性泛函 $\\ell(v)$ 保持不变。此格式向刚度矩阵 $K$ 添加了项，特别影响了与边界节点（$0, 1$）及其相邻节点（$1, N-1$）相对应的矩阵项。对矩阵项 $K_{ij} = a(\\phi_j, \\phi_i)$ 的修改源自 Nitsche 项：\n    \\begin{itemize}\n        \\item 在 $y=0$ 处：\n            $K_{00} \\gets K_{00} + \\frac{(\\gamma-2)\\nu(0)}{h}$\n            $K_{01} \\gets K_{01} + \\frac{\\nu(0)}{h}$\n            $K_{10} \\gets K_{10} + \\frac{\\nu(0)}{h}$\n        \\item 在 $y=1$ 处：\n            $K_{NN} \\gets K_{NN} + \\frac{(\\gamma-2)\\nu(1)}{h}$\n            $K_{N,N-1} \\gets K_{N,N-1} + \\frac{\\nu(1)}{h}$\n            $K_{N-1,N} \\gets K_{N-1,N} + \\frac{\\nu(1)}{h}$\n    \\end{itemize}\n    然后求解完整的 $(N+1) \\times (N+1)$ 系统。\n\n最后，对于每个计算出的离散解 $u_h(y)$，计算粘性能量耗散率 $D$。它由以下积分定义：\n$$\nD = \\int_0^1 \\nu(y) \\left(\\frac{du_h}{dy}\\right)^2 dy.\n$$\n由于 P1 有限元解的导数 $du_h/dy$ 是分段常数，该积分是每个单元贡献的总和。为了与系统组装保持一致，使用中点积分法，耗散计算如下：\n$$\nD \\approx \\sum_{k=1}^{N} h \\cdot \\nu(y_{k-1/2}) \\left(\\frac{U_k - U_{k-1}}{h}\\right)^2 = \\sum_{k=1}^{N} \\frac{\\nu(y_{k-1/2})}{h} (U_k - U_{k-1})^2.\n$$\n对每个测试用例的强施加法解和 Nitsche 解都执行此计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using FEM with two boundary condition\n    enforcement strategies (Strong and Nitsche's method) and computes the\n    energy dissipation rate for each case.\n    \"\"\"\n    \n    test_cases = [\n        # (nu_func, N, G, gamma)\n        (lambda y: 1.0, 32, 1.0, 10.0),\n        (lambda y: 1.0 + 0.4 * np.sin(10 * np.pi * y), 64, 1.0, 10.0),\n        (lambda y: 1.0, 8, 1.0, 2.5),\n        (lambda y: 1.0, 8, 1.0, 100.0),\n    ]\n\n    results = []\n\n    for nu_func, N, G, gamma in test_cases:\n        h = 1.0 / N\n        nodes = np.linspace(0.0, 1.0, N + 1)\n\n        # Assemble global stiffness matrix K and load vector F\n        K = np.zeros((N + 1, N + 1))\n        F = np.zeros(N + 1)\n\n        for k in range(1, N + 1):\n            # Element nodes are k-1 and k\n            y_mid = nodes[k-1] + h / 2.0\n            nu_mid = nu_func(y_mid)\n\n            # Element stiffness matrix\n            k_elem = (nu_mid / h) * np.array([[1, -1], [-1, 1]])\n\n            # Element load vector\n            f_elem = (G * h / 2.0) * np.array([1, 1])\n\n            # Assemble into global system\n            indices = [k - 1, k]\n            K[np.ix_(indices, indices)] += k_elem\n            F[indices] += f_elem\n\n        # --- Strong Enforcement ---\n        K_strong_int = K[1:N, 1:N]\n        F_strong_int = F[1:N]\n        \n        try:\n            U_strong_int = np.linalg.solve(K_strong_int, F_strong_int)\n            U_strong = np.zeros(N + 1)\n            U_strong[1:N] = U_strong_int\n        except np.linalg.LinAlgError:\n            # Should not happen for this well-posed problem\n            U_strong = np.full(N+1, np.nan)\n\n        # --- Nitsche's Method Enforcement ---\n        K_nitsche = K.copy()\n        nu_0, nu_1 = nu_func(0.0), nu_func(1.0)\n\n        # Modify K for boundary at y=0\n        K_nitsche[0, 0] += (gamma - 2.0) * nu_0 / h\n        K_nitsche[0, 1] += nu_0 / h\n        K_nitsche[1, 0] += nu_0 / h\n\n        # Modify K for boundary at y=1\n        K_nitsche[N, N] += (gamma - 2.0) * nu_1 / h\n        K_nitsche[N, N - 1] += nu_1 / h\n        K_nitsche[N - 1, N] += nu_1 / h\n        \n        F_nitsche = F # For homogeneous BCs, load vector is not modified.\n\n        try:\n            U_nitsche = np.linalg.solve(K_nitsche, F_nitsche)\n        except np.linalg.LinAlgError:\n            U_nitsche = np.full(N+1, np.nan)\n\n        # --- Compute Energy Dissipation Rate D for both methods ---\n        D_strong = 0.0\n        D_nitsche = 0.0\n        for k in range(1, N + 1):\n            y_mid = nodes[k - 1] + h / 2.0\n            nu_mid = nu_func(y_mid)\n            \n            # Strong solution dissipation\n            grad_u_strong_sq = ((U_strong[k] - U_strong[k - 1]) / h) ** 2\n            D_strong += h * nu_mid * grad_u_strong_sq\n            \n            # Nitsche solution dissipation\n            grad_u_nitsche_sq = ((U_nitsche[k] - U_nitsche[k - 1]) / h) ** 2\n            D_nitsche += h * nu_mid * grad_u_nitsche_sq\n\n        results.append(D_strong)\n        results.append(D_nitsche)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从狄利克雷边界转向诺伊曼（第二类）边界条件后，一个特殊且重要的情况是纯诺伊曼问题。这类问题在物理上对应于解在相差一个常数下不唯一的系统，这在有限元离散化后表现为奇异的刚度矩阵。本练习  旨在让您直面这一挑战，通过计算方法识别刚度矩阵的零空间，并设计一个投影预条件子来消除奇异性，从而使问题可解。这个实践将抽象的线性代数概念（如零空间和投影）与具体的物理问题和数值求解技术紧密联系起来。",
            "id": "3732393",
            "problem": "您的任务是构建和分析由一维有限元法（FEM）为纯诺伊曼边界条件的泊松方程所产生的离散拉普拉斯算子。目标是从弱形式出发进行严格推理，在纯诺伊曼边界条件下组装刚度矩阵，识别其零空间，并设计一个能消除常数模态的线性预条件子。您的程序必须实现这些步骤，为几个测试案例计算量化的诊断指标，并生成单行的聚合输出。\n\n从以下基本原理开始。一维域上的纯诺伊曼边界条件的泊松方程为 $- \\dfrac{d}{dx}\\left(k(x)\\dfrac{du}{dx}\\right) = f(x)$，在某个区间上，边界上具有自然边界条件 $k(x)\\dfrac{du}{dx} = g$。有限元法（FEM）使用测试函数 $v(x)$ 构建弱形式，得到双线性形式 $\\int k(x)\\,u'(x)\\,v'(x)\\,dx$ 和线性形式 $\\int f(x)\\,v(x)\\,dx$ 再加上任何一致的边界项。对于齐次诺伊曼边界条件，常数函数 $u(x) = c$ 是一个能量为零的容许函数，因为 $\\dfrac{du}{dx} = 0$。在一个连通域中，这意味着刚度算子是奇异的，并接受常数模态作为其零空间向量。在一个具有 $m$ 个连通分量的不连通域中，零空间的维度为 $m$。\n\n您的程序必须为每个测试案例执行以下操作：\n1. 为每个连通分量，在一个单位长度的区间上使用均匀单元，组装一维线性有限元离散化（采用分段常数扩散系数 $k(x)$）的刚度矩阵 $A$ 和一致质量矩阵 $M$。对于一个有 $n$ 个单元的分量，使用节点 $x_0, x_1, \\dots, x_n$ 且 $x_i = \\dfrac{i}{n}$。在每个单元上使用线性形函数，并采用标准的有限元组装程序来构建 $A$ 和 $M$。\n2. 在纯诺伊曼边界条件下（仅自然边界条件，无狄利克雷约束），通过识别与绝对值小于或等于容差 $\\varepsilon$ 的特征值相对应的特征向量，来计算 $A$ 的零空间基。\n3. 设计一个线性预条件子 $P$ 以消除常数模态。该预条件子必须是一个投影，它能湮灭所有零空间向量，并对其关于 $M$-加权内积的正交补空间起到单位算子的作用。具体来说，将零空间基的列向量视为生成向量，并构造一个投影算子，将任何向量映射到其相对于该生成空间的 $M$-正交补空间中。\n4. 通过计算三个诊断指标来量化预条件子的有效性：\n   - 整数零空间维度 $d$，定义为 $A$ 的特征值中绝对值小于或等于 $\\varepsilon$ 的数量。\n   - 浮点数 $e$，定义为将 $P$ 应用于整个节点集上的全一常数向量（对于不连通域，此向量是每个分量上全一向量的拼接）后所得向量的欧几里得范数。这用于衡量预条件子是否湮灭了全局常数模态。将 $e$ 表示为四舍五入到六位小数的浮点数。\n   - 浮点数 $\\lambda_{\\min}^{+}$，定义为 $P^{\\top} A P$ 的大于容差 $\\varepsilon$ 的最小严格正特征值。将 $\\lambda_{\\min}^{+}$ 表示为四舍五入到六位小数的浮点数。如果不存在严格正特征值，则返回 $0.000000$。\n5. 使用数值容差 $\\varepsilon = 10^{-10}$ 来确定零空间和区分严格正特征值。\n6. 不假设任何外部约束或节点固定。仅应用纯诺伊曼边界条件。\n7. 使用 Numerical Python (NumPy) 库进行所有线性代数计算，并确保对小规模矩阵的数值稳定性。\n\n测试套件规范：\n- 测试案例 1 (连通，理想路径)：单个连通分量，有 $n = 5$ 个单元，所有单元的扩散系数均匀为 $k_e = 1$。这会产生 $6$ 个节点。\n- 测试案例 2 (连通，边界情况)：单个连通分量，有 $n = 1$ 个单元，扩散系数均匀为 $k_e = 1$。这会产生 $2$ 个节点。\n- 测试案例 3 (不连通，多分量边界情况)：两个不连通的分量，第一个有 $n_1 = 3$ 个单元且其所有单元的 $k_e = 1$，第二个有 $n_2 = 2$ 个单元且其所有单元的 $k_e = 1$。按照分量 1、分量 2 的顺序，通过形成两个分量的块对角矩阵来组装全局矩阵。\n- 测试案例 4 (连通，异构多尺度系数)：单个连通分量，有 $n = 4$ 个单元，单元扩散系数从左到右依次为 $k_e \\in \\{10^{-2}, 1, 10, 0.5\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试案例必须按 $[d,e,\\lambda_{\\min}^{+}]$ 的顺序贡献一个三元组，浮点数条目四舍五入到六位小数，且整行中没有任何空格。例如，一个包含两个测试案例的有效输出行格式为 `[[1,0.000000,0.123456],[2,0.000000,0.234567]]`。\n\n您的程序输出必须是包含按上述确切顺序排列的四个测试案例的单行，聚合为 `[[d_1,e_1,\\lambda_{\\min,1}^{+}],[d_2,e_2,\\lambda_{\\min,2}^{+}],[d_3,e_3,\\lambda_{\\min,3}^{+}],[d_4,e_4,\\lambda_{\\min,4}^{+}]]`。",
            "solution": "当前问题要求构建和分析从一维有限元法（FEM）离散化泊松方程（受纯诺伊曼边界条件约束）中导出的离散拉普拉斯算子。分析过程包括组装刚度矩阵和质量矩阵，表征奇异刚度矩阵的零空间，以及设计一个基于投影的预条件子来处理奇异性。\n\n我们从一维泊松方程的弱形式开始，该方程为 $-\\dfrac{d}{dx}\\left(k(x)\\dfrac{du}{dx}\\right) = f(x)$，定义在域 $\\Omega$ 上，边界 $\\partial\\Omega$ 上具有诺伊曼边界条件 $k(x)\\frac{du}{dx} = g$。将方程乘以一个来自合适空间（例如 $H^1(\\Omega)$）的测试函数 $v(x)$ 并在域上积分，得到：\n$$\n-\\int_{\\Omega} v \\dfrac{d}{dx}\\left(k\\dfrac{du}{dx}\\right) dx = \\int_{\\Omega} f v dx\n$$\n对左侧应用分部积分法得到：\n$$\n\\int_{\\Omega} k \\dfrac{du}{dx} \\dfrac{dv}{dx} dx - \\left[v k \\dfrac{du}{dx}\\right]_{\\partial\\Omega} = \\int_{\\Omega} f v dx\n$$\n这可以重排为标准的弱形式：找到 $u \\in H^1(\\Omega)$ 使得对于所有 $v \\in H^1(\\Omega)$，\n$$\na(u,v) = L(v)\n$$\n其中 $a(u,v) = \\int_{\\Omega} k u' v' dx$ 是双线性形式，$L(v) = \\int_{\\Omega} f v dx + [v g]_{\\partial\\Omega}$ 是线性形式。\n\n有限元方法离散化求解空间。我们通过有限和 $u_h(x) = \\sum_{j=1}^{N_{nodes}} U_j \\phi_j(x)$ 来近似 $u(x)$，其中 $U_j$ 是未知的节点值，$\\phi_j(x)$ 是分段多项式基函数（此处为线性“帽”函数）。这将弱形式转化为一个线性方程组 $AU = F$，其中刚度矩阵 $A$ 和质量矩阵 $M$ 的各项由以下公式给出：\n$$\nA_{ij} = a(\\phi_j, \\phi_i) = \\int_{\\Omega} k(x) \\phi'_j(x) \\phi'_i(x) dx\n$$\n$$\nM_{ij} = (\\phi_j, \\phi_i) = \\int_{\\Omega} \\phi_j(x) \\phi_i(x) dx\n$$\n问题指定了在均匀网格上的分段线性基函数。对于一个跨越 $[x_e, x_{e+1}]$、长度为 $h_e = x_{e+1} - x_e$ 且具有常数扩散系数 $k_e$ 的单个单元 $e$，其单元刚度矩阵和质量矩阵为：\n$$\nA^e = \\frac{k_e}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n$$\nM^e = \\frac{h_e}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n全局矩阵 $A$ 和 $M$ 通过对这些单元贡献求和来组装。对于具有多个不连通分量的域，全局矩阵是块对角矩阵，每个块对应一个连通分量。\n\n在纯诺伊曼边界条件下（无狄利克雷约束），刚度矩阵 $A$ 是半正定的并且是奇异的。对于一个连通域，其零空间是一维的，由常数向量 $\\mathbf{1} = [1, 1, \\dots, 1]^T$ 生成，该向量代表常数函数模态 $u(x) = c$。该模态的能量为 $a(c,c) = \\int k (0)^2 dx = 0$。对于一个具有 $m$ 个不连通分量的域，其零空间是 $m$ 维的，由在某个分量上为常数而在其他分量上为零的向量生成。在数值上，我们通过寻找与大小接近于零的特征值（即 $|\\lambda| \\leq \\varepsilon$）相对应的特征向量来识别零空间。\n\n问题要求设计一个作为投影的预条件子 $P$，用以消除 $A$ 的零空间中的向量。具体来说，$P$ 必须将任何向量投影到零空间的 $M$-正交补空间上。设矩阵 $Z$ 的列构成了 $A$ 的零空间 $\\text{Ker}(A)$ 的一个基。到这个零空间上的投影算子是 $P_{null} = Z(Z^T M Z)^{-1}Z^T M$。因此，我们所期望的到 $M$-正交补空间上的投影算子 $P$ 是：\n$$\nP = I - P_{null} = I - Z(Z^T M Z)^{-1}Z^T M\n$$\n该算子满足 $P^2=P$，并且对于任何向量 $v$，向量 $Pv$ 都与 $\\text{Ker}(A)$ 中的任何向量 $M$-正交。\n\n需要计算的诊断指标如下：\n1.  零空间维度 $d = \\dim(\\text{Ker}(A))$，通过计算 $A$ 的特征值中满足 $|\\lambda| \\leq \\varepsilon|$ 的数量得到。\n2.  范数 $e = \\|P \\mathbf{1}\\|_2$，其中 $\\mathbf{1}$ 是全一向量。由于向量 $\\mathbf{1}$ 是每个分量基本零空间模态的和，它必须位于 $\\text{Ker}(A)$ 中。因此，$P\\mathbf{1}$ 在数值上应为零，即 $e \\approx 0$。\n3.  算子 $P^T A P$ 的最小严格正特征值 $\\lambda_{\\min}^+$。我们可以证明这个预处理后的算子实际上与原始刚度矩阵 $A$ 是相同的。\n    证明：$AP = A(I - Z(Z^T M Z)^{-1}Z^T M) = A - (AZ)(Z^T M Z)^{-1}Z^T M$。因为 $Z$ 的列是 $A$ 的零空间向量，所以 $AZ=0$。因此，$AP = A$。\n    类似地，$P^T A = (I - M Z (Z^T M Z)^{-1}Z^T) A = A - M Z (Z^T M Z)^{-1} (Z^T A)$。因为 $A$ 是对称的，所以 $Z^T A = (AZ)^T = 0^T = 0$。因此，$P^T A = A$。\n    结合以上两点，我们得到 $P^T A P = A P = A$。\n    因此，$P^T A P$ 的特征值与 $A$ 的特征值相同。量 $\\lambda_{\\min}^+$ 就是 $A$ 的大于容差 $\\varepsilon$ 的最小特征值。\n\n实现将遵循以下步骤：对每个测试案例，组装 $A$ 和 $M$；计算 $A$ 的特征值和特征向量以找到 $d$、$\\lambda_{\\min}^+$ 和零空间基 $Z$；构造投影算子 $P$；计算 $e$；并格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Test Suite Specification:\n    # A component is defined by (n_elements, k_coeffs_list).\n    test_cases = [\n        # Case 1: 1 component, n=5, k=1\n        [ (5, [1.0, 1.0, 1.0, 1.0, 1.0]) ],\n        \n        # Case 2: 1 component, n=1, k=1\n        [ (1, [1.0]) ],\n        \n        # Case 3: 2 components, (n1=3, k1=1) and (n2=2, k2=1)\n        [ (3, [1.0, 1.0, 1.0]), (2, [1.0, 1.0]) ],\n        \n        # Case 4: 1 component, n=4, heterogeneous k\n        [ (4, [1e-2, 1.0, 10.0, 0.5]) ]\n    ]\n\n    results = []\n    for case in test_cases:\n        d, e, lambda_min_pos = run_test_case(case)\n        # Format the result for the current test case\n        results.append(f\"[{d},{e:.6f},{lambda_min_pos:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_test_case(components):\n    \"\"\"\n    Processes a single test case, which may consist of multiple components.\n    \n    Args:\n        components (list): A list of tuples, where each tuple represents a\n                           connected component as (n_elements, k_coeffs).\n\n    Returns:\n        tuple: A tuple containing the three computed diagnostics (d, e, lambda_min_pos).\n    \"\"\"\n    epsilon = 1e-10\n    \n    list_A = []\n    list_M = []\n    \n    # Assemble matrices for each component\n    for n_elements, k_coeffs in components:\n        num_nodes = n_elements + 1\n        h = 1.0 / n_elements\n        \n        A_comp = np.zeros((num_nodes, num_nodes))\n        M_comp = np.zeros((num_nodes, num_nodes))\n        \n        # Element stiffness matrix\n        # A_e = (k_e / h) * [[1, -1], [-1, 1]]\n        # Element mass matrix\n        # M_e = (h / 6) * [[2, 1], [1, 2]]\n        \n        for i in range(n_elements):\n            k_e = k_coeffs[i]\n            \n            A_e = (k_e / h) * np.array([[1, -1], [-1, 1]])\n            M_e = (h / 6) * np.array([[2, 1], [1, 2]])\n            \n            # Assembly\n            A_comp[i:i+2, i:i+2] += A_e\n            M_comp[i:i+2, i:i+2] += M_e\n            \n        list_A.append(A_comp)\n        list_M.append(M_comp)\n        \n    # Form global block-diagonal matrices from components\n    if not list_A:\n        return 0, 0.0, 0.0\n        \n    A = block_diag(*list_A)\n    M = block_diag(*list_M)\n    \n    num_total_nodes = A.shape[0]\n\n    # Compute eigenvalues and eigenvectors of A\n    eigvals, eigvecs = np.linalg.eigh(A)\n    \n    # Diagnostic 1: Nullspace dimension 'd'\n    nullspace_indices = np.where(np.abs(eigvals) <= epsilon)[0]\n    d = len(nullspace_indices)\n    \n    # Diagnostic 3: Smallest strictly positive eigenvalue 'lambda_min_pos'\n    # Based on the analysis P^T A P = A, the eigenvalues are the same.\n    positive_eigvals = eigvals[eigvals > epsilon]\n    if positive_eigvals.size > 0:\n        lambda_min_pos = np.min(positive_eigvals)\n    else:\n        lambda_min_pos = 0.0\n        \n    # Construct projector P and compute diagnostic 'e'\n    if d == 0:\n        # No nullspace, P is identity, should not happen in these cases.\n        P = np.identity(num_total_nodes)\n    else:\n        Z = eigvecs[:, nullspace_indices]\n        # P = I - Z (Z^T M Z)^-1 Z^T M\n        try:\n            ZMZ = Z.T @ M @ Z\n            ZMZ_inv = np.linalg.inv(ZMZ)\n            P_null = Z @ ZMZ_inv @ Z.T @ M\n            P = np.identity(num_total_nodes) - P_null\n        except np.linalg.LinAlgError:\n            # Fallback in case of numerical instability, though not expected here.\n            P = np.identity(num_total_nodes)\n\n    # Diagnostic 2: Euclidean norm of P applied to the vector of ones\n    ones_vec = np.ones(num_total_nodes)\n    e = np.linalg.norm(P @ ones_vec)\n    \n    return d, e, lambda_min_pos\n\n\nsolve()\n```"
        },
        {
            "introduction": "对于非齐次狄利克雷问题（即边界值不为零），“提升函数”是一种核心的理论与实践工具，它将解分解为一个满足边界条件的部分和另一个在边界上为零的部分。本练习  将这一概念具体化，要求您在一个二维扩散问题中实现并对比两种不同的离散提升策略：简单的边界插值法和更精确的局部求解（离散调和延拓）法。通过分析这两种策略产生的内部残差和能量范数，您将深刻理解提升函数的选择如何影响线性系统的右端项，以及边界数据如何“渗透”到求解域内部，从而影响解的整体一致性。",
            "id": "3732479",
            "problem": "考虑单位正方形域 $\\Omega = (0,1)^2$ (边界为 $\\partial \\Omega$) 上的非均匀扩散问题，其强形式为 $-\\nabla \\cdot (a(\\mathbf{x}) \\nabla u(\\mathbf{x})) = f(\\mathbf{x})$ (在 $\\Omega$ 内)，并带有 Dirichlet 边界条件 $u(\\mathbf{x}) = g(\\mathbf{x})$ (在 $\\partial \\Omega$ 上)。假设 $f(\\mathbf{x}) = 0$，以便专注于边界条件在有限元方法 (FEM) 中的应用。在多尺度背景下，设扩散系数为 $a(\\mathbf{x}) = 1 + \\varepsilon \\sin(20 \\pi x) \\sin(20 \\pi y)$，其中 $\\varepsilon \\in [0,1)$ 控制跨尺度的振荡幅度。\n\n从弱形式出发，定义双线性形式 $A(u,v) = \\int_{\\Omega} a(\\mathbf{x}) \\nabla u(\\mathbf{x}) \\cdot \\nabla v(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x}$，并考虑在 $\\Omega$ 的一个均匀三角剖分上的协调、连续、分片线性有限元空间 $V_h$，其子空间为 $V_h^0 = \\{ v_h \\in V_h : v_h|_{\\partial \\Omega} = 0 \\}$，离散迹为 $\\gamma_h V_h = \\{ v_h|_{\\partial \\Omega} : v_h \\in V_h \\}$。令 $g_h \\in \\gamma_h V_h$ 表示 $g$ 在边界自由度上的节点插值。\n\n将离散提升 $u_{L,h} \\in V_h$ 定义为一个有限元函数，它在 $\\partial \\Omega$ 上施加边界数据 $g_h$，并采用以下两种策略之一将其延拓到内部：\n\n1. 边界插值提升：将边界自由度设置为插值 $g_h$，并将所有内部自由度设置为 $0$。\n2. 局部求解提升：将边界自由度设置为 $g_h$，并通过求解与 $A(\\cdot,\\cdot)$ 相关的齐次离散问题来确定内部自由度，从而使该提升成为关于 $A(\\cdot,\\cdot)$ 的离散调和延拓。\n\n您的任务是实现一个实用的有限元算法，该算法构建两种类型的离散提升，使用形心求积法处理 $a(\\mathbf{x})$ 来组装全局刚度矩阵，并通过为每种提升策略计算以下度量指标，来量化当 $g$ 不在离散迹空间中时对相容性的影响：\n\n- 内部相容性残差范数 $\\| r_h \\|_2$，其中 $r_h$ 是通过将作用在提升上的全局刚度矩阵限制到内部自由度上而获得的内部残差向量。\n- 能量半范数之差 $\\| u_{L,h}^{\\text{interp}} - u_{L,h}^{\\text{local}} \\|_A = \\sqrt{A(u_{L,h}^{\\text{interp}} - u_{L,h}^{\\text{local}}, u_{L,h}^{\\text{interp}} - u_{L,h}^{\\text{local}})}$。\n- 边界迹 $L^2$ 插值误差 $\\| g - g_h \\|_{L^2(\\partial \\Omega)}$，在边界边上使用中点求积进行近似。\n\n在通过将每个方形单元分裂成两个直角三角形构建的均匀三角剖分上实现该算法。使用分片线性基函数，并组装对称正定刚度矩阵 $K$，其元素 $K_{ij} \\approx \\int_{\\Omega} a(\\mathbf{x}) \\nabla \\phi_i(\\mathbf{x}) \\cdot \\nabla \\phi_j(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x}$ 通过 $a(\\mathbf{x}_T)$ 乘以单元常梯度乘积再乘以三角形面积来近似，其中 $\\mathbf{x}_T$ 是三角形的形心。\n\n提供一个包含三个测试用例的测试套件，涵盖各种边界数据和多尺度系数：\n\n- 用例1 (理想路径)：$N = 32$ (每个坐标轴上的区间数)，$\\varepsilon = 0.0$，$g(x,y) = x + y$。\n- 用例2 (一般多尺度)：$N = 32$，$\\varepsilon = 0.5$，$g(x,y) = \\sin(7 \\pi x) + 0.5 \\sin(5 \\pi y)$。\n- 用例3 (边界振荡未解析的边缘情况)：$N = 24$，$\\varepsilon = 0.5$，$g(x,y) = \\sin(25 \\pi x)$。\n\n对于每个用例，计算并返回一个包含四个浮点值的列表：\n- 边界插值提升的内部残差范数，$\\| r_h^{\\text{interp}} \\|_2$。\n- 局部求解提升的内部残差范数，$\\| r_h^{\\text{local}} \\|_2$。\n- 能量半范数之差，$\\| u_{L,h}^{\\text{interp}} - u_{L,h}^{\\text{local}} \\|_A$。\n- 边界迹 $L^2$ 插值误差，$\\| g - g_h \\|_{L^2(\\partial \\Omega)}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个用例由其自己的包含四个数字的列表表示，例如，“[[c1_1,c1_2,c1_3,c1_4],[c2_1,c2_2,c2_3,c2_4],[c3_1,c3_2,c3_3,c3_4]]”。不需要物理单位。不使用角度。如果需要，百分比必须表示为小数，但此处不需要。程序必须是完整的，无需外部输入即可运行，并且必须严格遵守指定的执行环境。",
            "solution": "该问题是适定的、有科学依据的，并为获得唯一、可验证的解提供了所有必要信息。它涉及偏微分方程数值分析中的一个标准课题，具体是在多尺度扩散问题中，有限元方法 (FEM) 对非齐次 Dirichlet 边界条件的处理。问题陈述是有效的。\n\n问题的核心是在单位正方形 $\\Omega = (0,1)^2$ 上求解椭圆型偏微分方程 $-\\nabla \\cdot (a(\\mathbf{x}) \\nabla u(\\mathbf{x})) = 0$，并满足在边界 $\\partial \\Omega$ 上的 Dirichlet 边界条件 $u(\\mathbf{x}) = g(\\mathbf{x})$。分析重点在于由分片线性有限元近似产生的离散格式。\n\n有限元方法的第一步是推导弱形式。我们在一个合适的函数空间（Sobolev 空间，$H^1(\\Omega)$）中寻求一个满足边界条件的解 $u$。解被分解为一个满足边界条件的已知部分和一个在边界上为零的未知部分。我们令 $u = u_0 + u_L$，其中 $u_L$ 是边界数据 $g$ 到域 $\\Omega$ 内的“提升”（即 $u_L|_{\\partial \\Omega} = g$），而 $u_0$ 是必须在边界上为零的未知校正项（即 $u_0 \\in H_0^1(\\Omega)$）。将偏微分方程乘以一个检验函数 $v \\in H_0^1(\\Omega)$ 并进行分部积分，得到弱形式：求 $u = u_0 + u_L$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_{\\Omega} a(\\mathbf{x}) \\nabla u(\\mathbf{x}) \\cdot \\nabla v(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x} = 0\n$$\n代入 $u = u_0 + u_L$ 并利用积分和导数的线性性质，我们得到：\n$$\n\\int_{\\Omega} a(\\mathbf{x}) \\nabla u_0 \\cdot \\nabla v \\, \\mathrm{d}\\mathbf{x} = - \\int_{\\Omega} a(\\mathbf{x}) \\nabla u_L \\cdot \\nabla v \\, \\mathrm{d}\\mathbf{x}\n$$\n这通常用双线性形式 $A(u,v) = \\int_{\\Omega} a(\\mathbf{x}) \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\mathbf{x}$ 来表示：求 $u_0 \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，有 $A(u_0, v) = -A(u_L, v)$。\n\n在有限元背景下，我们用有限维子空间代替无限维空间。我们在 $\\Omega$ 的一个三角剖分上定义一个协调、连续、分片线性的有限元空间 $V_h$。任何函数 $u_h \\in V_h$ 都由其在节点（自由度，或 DOFs）处的值唯一确定。在边界上为零的函数空间是 $V_h^0 = \\{ v_h \\in V_h : v_h|_{\\partial \\Omega} = 0 \\}$。离散解 $u_h \\in V_h$ 被分解为 $u_h = u_{0,h} + u_{L,h}$，其中 $u_{0,h} \\in V_h^0$，$u_{L,h} \\in V_h$ 是边界数据的离散提升。离散边界数据 $g_h$ 是 $g$ 在边界节点上的节点插值。\n\n离散问题变为：求 $u_{0,h} \\in V_h^0$，使得对于所有 $v_h \\in V_h^0$，有 $A(u_{0,h}, v_h) = -A(u_{L,h}, v_h)$。将函数在形函数基 $\\{\\phi_i\\}$ 中展开，这可以转化为一个矩阵系统。设 $\\mathbf{u}$ 为节点值向量。我们将自由度 (DOFs) 划分为内部 ($I$) 和边界 ($B$) 集合。全局刚度矩阵 $K_{ij} = A(\\phi_j, \\phi_i)$ 也相应地进行分块：\n$$\nK = \\begin{pmatrix} K_{II}  K_{IB} \\\\ K_{BI}  K_{BB} \\end{pmatrix}\n$$\n从提升 $\\mathbf{u}_{L}$ 的系数导出的关于内部未知量 $\\mathbf{u}_{0,I}$ ($u_{0,h}$ 的系数) 的线性系统是：\n$$\nK_{II} \\mathbf{u}_{0,I} = -(K_{II} \\mathbf{u}_{L,I} + K_{IB} \\mathbf{u}_{L,B})\n$$\n该问题要求构建和分析离散提升 $u_{L,h}$ 的两种选择：\n\n1.  **边界插值提升 ($u_{L,h}^{\\text{interp}}$):** 这是最简单的选择。我们将内部节点值设为零。系数向量为 $\\mathbf{u}_{\\text{interp},I} = \\mathbf{0}$，而 $\\mathbf{u}_{\\text{interp},B}$ 包含 $g_h$ 在边界节点处的值。\n\n2.  **局部求解提升 ($u_{L,h}^{\\text{local}}$):** 这种提升是边界数据的离散调和延拓。选择内部节点值以满足齐次离散方程。系数向量 $\\mathbf{u}_{\\text{local},B}$ 同样由 $g_h$ 给出，而内部值 $\\mathbf{u}_{\\text{local},I}$ 通过求解使方程内部部分为零的系统得到：$K_{II} \\mathbf{u}_{\\text{local},I} + K_{IB} \\mathbf{u}_{\\text{local},B} = \\mathbf{0}$。这意味着 $\\mathbf{u}_{\\text{local},I} = -K_{II}^{-1} K_{IB} \\mathbf{u}_{\\text{local},B}$。\n\n该算法将计算以下度量指标来比较这些策略：\n\n**度量指标1：内部相容性残差范数 $\\| r_h \\|_2$。**\n内部残差向量是 $r_h = K_{II} \\mathbf{u}_{L,I} + K_{IB} \\mathbf{u}_{L,B}$。\n- 对于插值提升，$\\mathbf{u}_{\\text{interp},I} = \\mathbf{0}$，因此残差衡量了边界数据“污染”内部方程的程度：$r_h^{\\text{interp}} = K_{IB} \\mathbf{u}_{\\text{interp},B}$。我们计算其欧几里得范数 $\\|r_h^{\\text{interp}}\\|_2$。\n- 对于局部求解提升，内部值 $\\mathbf{u}_{\\text{local},I}$ 的定义恰好使该残差为零。因此，根据定义，$r_h^{\\text{local}} = K_{II} \\mathbf{u}_{\\text{local},I} + K_{IB} \\mathbf{u}_{\\text{local},B} = \\mathbf{0}$。其范数为 $\\|r_h^{\\text{local}}\\|_2 = 0$。\n\n**度量指标2：能量半范数之差 $\\| u_{L,h}^{\\text{interp}} - u_{L,h}^{\\text{local}} \\|_A$。**\n该度量指标量化了两种提升在由双线性形式 $A(\\cdot, \\cdot)$ 定义的能量方面的差异。令 $w_h = u_{L,h}^{\\text{interp}} - u_{L,h}^{\\text{local}}$。两种提升的边界值相同 ($g_h$)，因此 $w_h|_{\\partial \\Omega} = 0$，这意味着 $w_h \\in V_h^0$。半范数为 $\\|w_h\\|_A = \\sqrt{A(w_h, w_h)}$。其矩阵形式为 $\\sqrt{\\mathbf{w}^T K \\mathbf{w}}$。系数向量 $\\mathbf{w}$ 在边界自由度上的分量为零。其内部部分为 $\\mathbf{w}_I = \\mathbf{u}_{\\text{interp},I} - \\mathbf{u}_{\\text{local},I} = \\mathbf{0} - \\mathbf{u}_{\\text{local},I} = -\\mathbf{u}_{\\text{local},I}$。能量的平方为 $\\mathbf{w}_I^T K_{II} \\mathbf{w}_I = (-\\mathbf{u}_{\\text{local},I})^T K_{II} (-\\mathbf{u}_{\\text{local},I}) = \\mathbf{u}_{\\text{local},I}^T K_{II} \\mathbf{u}_{\\text{local},I}$。\n\n**度量指标3：边界迹 $L^2$ 插值误差 $\\| g - g_h \\|_{L^2(\\partial \\Omega)}$。**\n这衡量了离散边界数据 $g_h$ (分片线性插值) 对真实边界函数 $g$ 的逼近程度。误差的平方为 $\\int_{\\partial \\Omega} (g - g_h)^2 \\, \\mathrm{d}S$。我们使用中点求积法则在每条边界边（共 $4N$ 条）上近似该积分。在一条长度为 $h$、中点为 $\\mathbf{m}_k$ 的边 $E_k$ 上，其贡献近似为 $(g(\\mathbf{m}_k) - g_h(\\mathbf{m}_k))^2 h$。由于 $g_h$ 在边上是线性的，其在中点的值是其在端点（节点）处值的平均值。\n\n实现过程将通过对单元贡献求和来构建刚度矩阵 K。对于一个节点为 $k,l,m$ 的三角形 $T$，单元刚度矩阵的元素为 $K^T_{ij} = \\int_T a(\\mathbf{x}) \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\mathbf{x}$。使用形心求积，这被近似为 $K^T_{ij} \\approx a(\\mathbf{x}_T) (\\nabla\\phi_i|_T \\cdot \\nabla\\phi_j|_T) \\text{Area}(T)$，其中 $\\mathbf{x}_T$ 是三角形的形心。\n最终算法包括：\n1.  生成网格节点并将其分类为内部或边界节点。\n2.  通过遍历所有三角形来组装稀疏全局刚度矩阵 K。\n3.  将 K 分块为 $K_{II}$ 和 $K_{IB}$。\n4.  计算边界数据向量 $\\mathbf{u}_B$。\n5.  如上所述计算三个度量指标，这涉及为 $\\mathbf{u}_{\\text{local},I}$ 求解一个线性系统。\n对每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the computation for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path): N=32, ε=0.0, g(x,y)=x+y\n        {'N': 32, 'epsilon': 0.0, 'g_func': lambda x, y: x + y},\n        # Case 2 (general multiscale): N=32, ε=0.5, g(x,y)=sin(7πx)+0.5sin(5πy)\n        {'N': 32, 'epsilon': 0.5, 'g_func': lambda x, y: np.sin(7 * np.pi * x) + 0.5 * np.sin(5 * np.pi * y)},\n        # Case 3 (edge case with unresolved boundary): N=24, ε=0.5, g(x,y)=sin(25πx)\n        {'N': 24, 'epsilon': 0.5, 'g_func': lambda x, y: np.sin(25 * np.pi * x)}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_fem_case(case['N'], case['epsilon'], case['g_func'])\n        results.append(case_results)\n\n    # Format output string exactly as required\n    case_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(case_strings)}]\")\n\ndef run_fem_case(N, epsilon, g_func):\n    \"\"\"\n    Performs the full finite element analysis for a single test case.\n\n    Args:\n        N (int): Number of intervals per axis.\n        epsilon (float): Amplitude of oscillation for the diffusion coefficient.\n        g_func (callable): The boundary condition function g(x, y).\n\n    Returns:\n        list: A list of four floating-point values representing the computed metrics.\n    \"\"\"\n    h = 1.0 / N\n    num_nodes = (N + 1)**2\n\n    def a_func(x, y):\n        return 1.0 + epsilon * np.sin(20 * np.pi * x) * np.sin(20 * np.pi * y)\n\n    # 1. Generate mesh and identify DOFs\n    nodes = np.array([(i * h, j * h) for j in range(N + 1) for i in range(N + 1)])\n    \n    interior_dofs = []\n    boundary_dofs = []\n    for j in range(N + 1):\n        for i in range(N + 1):\n            k = j * (N + 1) + i\n            if i == 0 or i == N or j == 0 or j == N:\n                boundary_dofs.append(k)\n            else:\n                interior_dofs.append(k)\n\n    # 2. Assemble global stiffness matrix K\n    K = lil_matrix((num_nodes, num_nodes))\n    \n    for j in range(N):\n        for i in range(N):\n            # Global node indices for the current square cell\n            n1 = j * (N + 1) + i       # bottom-left\n            n2 = j * (N + 1) + i + 1   # bottom-right\n            n3 = (j + 1) * (N + 1) + i # top-left\n            n4 = (j + 1) * (N + 1) + i + 1 # top-right\n            \n            # Triangle 1: (i,j), (i+1,j), (i+1,j+1)\n            # Global indices: n1, n2, n4\n            # Coords: nodes[n1], nodes[n2], nodes[n4]\n            tri1_indices = [n1, n2, n4]\n            tri1_coords = nodes[tri1_indices]\n            Ke1 = assemble_element_stiffness(tri1_coords, a_func)\n            for r_idx, r_glob in enumerate(tri1_indices):\n                for c_idx, c_glob in enumerate(tri1_indices):\n                    K[r_glob, c_glob] += Ke1[r_idx, c_idx]\n\n            # Triangle 2: (i,j), (i+1,j+1), (i,j+1)\n            # Global indices: n1, n4, n3\n            # Coords: nodes[n1], nodes[n4], nodes[n3]\n            tri2_indices = [n1, n4, n3]\n            tri2_coords = nodes[tri2_indices]\n            Ke2 = assemble_element_stiffness(tri2_coords, a_func)\n            for r_idx, r_glob in enumerate(tri2_indices):\n                for c_idx, c_glob in enumerate(tri2_indices):\n                    K[r_glob, c_glob] += Ke2[r_idx, c_idx]\n\n    K = K.tocsc()\n\n    # 3. Partition K\n    K_II = K[np.ix_(interior_dofs, interior_dofs)]\n    K_IB = K[np.ix_(interior_dofs, boundary_dofs)]\n\n    # 4. Compute boundary data vector\n    boundary_nodes_coords = nodes[boundary_dofs]\n    u_B = np.array([g_func(x, y) for x, y in boundary_nodes_coords])\n\n    # 5. Compute metrics\n    # Metric 1: Interior residual norm for boundary-interpolation lifting\n    r_h_interp = K_IB @ u_B\n    res_norm_interp = np.linalg.norm(r_h_interp)\n\n    # Metric 2: Interior residual norm for local-solve lifting\n    res_norm_local = 0.0\n\n    # Metric 3: Energy seminorm difference\n    rhs = -r_h_interp\n    u_local_I = spsolve(K_II, rhs)\n    energy_sq = u_local_I.dot(K_II @ u_local_I)\n    energy_seminorm_diff = np.sqrt(energy_sq)\n\n    # Metric 4: Boundary trace L2 interpolation error\n    error_sq_sum = 0.0\n    # Bottom edge (j=0)\n    for i in range(N):\n        p1 = np.array([i * h, 0])\n        p2 = np.array([(i + 1) * h, 0])\n        pm = (p1 + p2) / 2\n        g_val = g_func(pm[0], pm[1])\n        gh_val = (g_func(p1[0], p1[1]) + g_func(p2[0], p2[1])) / 2\n        error_sq_sum += (g_val - gh_val)**2 * h\n    # Top edge (j=N)\n    for i in range(N):\n        p1 = np.array([i * h, 1])\n        p2 = np.array([(i + 1) * h, 1])\n        pm = (p1 + p2) / 2\n        g_val = g_func(pm[0], pm[1])\n        gh_val = (g_func(p1[0], p1[1]) + g_func(p2[0], p2[1])) / 2\n        error_sq_sum += (g_val - gh_val)**2 * h\n    # Left edge (i=0)\n    for j in range(N):\n        p1 = np.array([0, j * h])\n        p2 = np.array([0, (j + 1) * h])\n        pm = (p1 + p2) / 2\n        g_val = g_func(pm[0], pm[1])\n        gh_val = (g_func(p1[0], p1[1]) + g_func(p2[0], p2[1])) / 2\n        error_sq_sum += (g_val - gh_val)**2 * h\n    # Right edge (i=N)\n    for j in range(N):\n        p1 = np.array([1, j * h])\n        p2 = np.array([1, (j + 1) * h])\n        pm = (p1 + p2) / 2\n        g_val = g_func(pm[0], pm[1])\n        gh_val = (g_func(p1[0], p1[1]) + g_func(p2[0], p2[1])) / 2\n        error_sq_sum += (g_val - gh_val)**2 * h\n        \n    boundary_l2_error = np.sqrt(error_sq_sum)\n\n    return [res_norm_interp, res_norm_local, energy_seminorm_diff, boundary_l2_error]\n\n\ndef assemble_element_stiffness(coords, a_func):\n    \"\"\"\n    Assembles the 3x3 element stiffness matrix for a single triangular element.\n    \n    Args:\n        coords (np.ndarray): A 3x2 array of vertex coordinates.\n        a_func (callable): The diffusion coefficient function a(x,y).\n        \n    Returns:\n        np.ndarray: The 3x3 element stiffness matrix.\n    \"\"\"\n    p1, p2, p3 = coords[0], coords[1], coords[2]\n    area = 0.5 * np.abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\n    # Gradients of basis functions\n    b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n    c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n    \n    centroid = np.mean(coords, axis=0)\n    a_val = a_func(centroid[0], centroid[1])\n    \n    Ke = np.zeros((3, 3))\n    factor = a_val / (4.0 * area)\n    for i in range(3):\n        for j in range(3):\n            Ke[i, j] = factor * (b[i] * b[j] + c[i] * c[j])\n            \n    return Ke\n\n\nsolve()\n```"
        }
    ]
}