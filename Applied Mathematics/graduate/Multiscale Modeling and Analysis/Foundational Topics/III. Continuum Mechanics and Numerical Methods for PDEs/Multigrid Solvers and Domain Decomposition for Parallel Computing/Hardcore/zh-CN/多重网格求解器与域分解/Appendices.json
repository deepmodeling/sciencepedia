{
    "hands_on_practices": [
        {
            "introduction": "多重网格方法的核心在于其光滑子（smoother）能够有效衰减高频误差。本练习将使用局部傅里叶分析（Local Fourier Analysis, LFA）—— 一种分析理想化线性算子的强大工具 —— 来量化这种“光滑”特性。通过为加权雅可比法推导最优松弛参数 $\\omega$，您将深入理解如何设计并分析高效的光滑子。",
            "id": "3783291",
            "problem": "考虑在具有$N$个点的周期性均匀网格上离散化的一维泊松方程，其中网格间距为$h$，$N$很大。离散算子是标准的二阶有限差分拉普拉斯算子，其作用于网格函数$\\{u_{j}\\}$的形式为$A u_{j} = \\frac{1}{h^{2}}(-u_{j-1} + 2 u_{j} - u_{j+1})$。在为区域分解设计的并行双网格多重网格方法中，使用带松弛参数$\\omega \\in (0,1)$的逐点加权雅可比平滑器，该平滑器在每个子域上独立运行（这种局部性可实现高效的并行化）。设加权雅可比迭代的误差传播矩阵为$E = I - \\omega D^{-1} A$，其中$D$是$A$的对角部分。\n\n使用局部傅里叶分析（LFA），其中傅里叶模$e^{\\mathrm{i} \\theta j}$可将周期性网格上的常系数循环算子对角化，从第一性原理推导迭代矩阵$E$的傅里叶符号$\\mu(\\theta)$，然后计算平滑因子$\\rho(\\omega)$，其定义为$|\\mu(\\theta)|$在相对于$2h$粗网格的高频集合（取为$\\theta \\in [\\pi/2,\\pi]$）上的最大值。最后，确定使$\\rho(\\omega)$最小化的$\\omega \\in (0,1)$的值，并将最小化的平滑因子报告为单个实数。不要对最终答案进行四舍五入。",
            "solution": "用户提供了数值分析领域的一个有效问题陈述，具体涉及多重网格方法的分析。该问题具有科学依据，提法恰当且客观。我们将进行形式化的推导。\n\n问题要求对周期性网格上的一维离散泊松方程的加权雅可比平滑器进行分析。分析的核心将使用局部傅里叶分析（LFA）进行。\n\n首先，我们确定加权雅可比迭代的误差传播矩阵$E = I - \\omega D^{-1} A$的组成部分。\n离散算子由下式给出：\n$$A u_{j} = \\frac{1}{h^{2}}(-u_{j-1} + 2 u_{j} - u_{j+1})$$\n由于周期性边界条件，矩阵$A$是循环矩阵。$A$的对角部分（记为$D$）由$u_j$的系数组成。从表达式中可以看出，$A$的对角线元素均为$2/h^2$。因此，$D$是单位矩阵的标量倍，$D = \\frac{2}{h^2} I$。\n$D$的逆是$D^{-1} = \\frac{h^2}{2} I$。\n\n分析过程是通过检验算子对傅里叶模$\\phi_j(\\theta) = e^{\\mathrm{i} \\theta j}$的作用来进行的，其中$\\theta$是角频率。这些模是周期性网格上任何线性常系数算子的特征向量。相应的特征值称为该算子的傅里叶符号。\n\n我们首先推导算子$A$的符号，记为$\\tilde{A}(\\theta)$。\n$$\n\\begin{aligned}\nA \\phi_j(\\theta) = A e^{\\mathrm{i} \\theta j} \\\\\n= \\frac{1}{h^{2}}(-e^{\\mathrm{i} \\theta (j-1)} + 2 e^{\\mathrm{i} \\theta j} - e^{\\mathrm{i} \\theta (j+1)}) \\\\\n= \\frac{e^{\\mathrm{i} \\theta j}}{h^{2}}(-e^{-\\mathrm{i} \\theta} + 2 - e^{\\mathrm{i} \\theta}) \\\\\n= \\frac{e^{\\mathrm{i} \\theta j}}{h^{2}}(2 - (e^{\\mathrm{i} \\theta} + e^{-\\mathrm{i} \\theta}))\n\\end{aligned}\n$$\n使用欧拉公式$\\cos(\\theta) = \\frac{e^{\\mathrm{i} \\theta} + e^{-\\mathrm{i} \\theta}}{2}$，我们得到：\n$$\nA \\phi_j(\\theta) = \\frac{e^{\\mathrm{i} \\theta j}}{h^{2}}(2 - 2\\cos(\\theta)) = \\frac{2}{h^2}(1 - \\cos(\\theta)) e^{\\mathrm{i} \\theta j}\n$$\n使用半角恒等式$1 - \\cos(\\theta) = 2\\sin^2(\\frac{\\theta}{2})$，表达式简化为：\n$$\nA \\phi_j(\\theta) = \\frac{4}{h^2}\\sin^2\\left(\\frac{\\theta}{2}\\right) e^{\\mathrm{i} \\theta j}\n$$\n因此，$A$的傅里叶符号是$\\tilde{A}(\\theta) = \\frac{4}{h^2}\\sin^2(\\frac{\\theta}{2})$。\n\n接下来，我们推导迭代矩阵$E = I - \\omega D^{-1} A$的符号，记为$\\mu(\\theta)$。单位矩阵$I$的符号是$1$。$D^{-1}$的符号是标量$\\frac{h^2}{2}$。\n$$\n\\begin{aligned}\n\\mu(\\theta) = \\tilde{I}(\\theta) - \\omega \\tilde{D}^{-1}(\\theta) \\tilde{A}(\\theta) \\\\\n= 1 - \\omega \\left(\\frac{h^2}{2}\\right) \\left(\\frac{4}{h^2}\\sin^2\\left(\\frac{\\theta}{2}\\right)\\right) \\\\\n= 1 - 2\\omega \\sin^2\\left(\\frac{\\theta}{2}\\right)\n\\end{aligned}\n$$\n这是加权雅可比方法对频率为$\\theta$的模的放大因子。\n\n平滑因子$\\rho(\\omega)$定义为放大因子在高频集合上的最大幅值。对于粗化到间距为$2h$的网格，高频集合为$\\theta \\in [\\frac{\\pi}{2}, \\pi]$。\n$$\n\\rho(\\omega) = \\max_{\\theta \\in [\\pi/2, \\pi]} |\\mu(\\theta)| = \\max_{\\theta \\in [\\pi/2, \\pi]} \\left| 1 - 2\\omega \\sin^2\\left(\\frac{\\theta}{2}\\right) \\right|\n$$\n为了找到这个最大值，我们分析函数$f(\\theta) = \\sin^2(\\frac{\\theta}{2})$在$\\theta \\in [\\frac{\\pi}{2}, \\pi]$上的值域。\n自变量$\\frac{\\theta}{2}$位于区间$[\\frac{\\pi}{4}, \\frac{\\pi}{2}]$内。在此区间内，$\\sin(x)$是一个单调递增函数。\n当$\\theta = \\frac{\\pi}{2}$时，我们有$\\sin^2(\\frac{\\pi}{4}) = (\\frac{\\sqrt{2}}{2})^2 = \\frac{1}{2}$。\n当$\\theta = \\pi$时，我们有$\\sin^2(\\frac{\\pi}{2}) = 1^2 = 1$。\n令$x = \\sin^2(\\frac{\\theta}{2})$。$x$的范围是$[\\frac{1}{2}, 1]$。\n平滑因子的表达式变为：\n$$ \\rho(\\omega) = \\max_{x \\in [1/2, 1]} |1 - 2\\omega x| $$\n函数$g(x) = 1 - 2\\omega x$是$x$的线性函数。其绝对值在闭区间上的最大值必定出现在区间的某个端点。因此，我们计算$|g(x)|$在$x = \\frac{1}{2}$和$x=1$处的值。\n在$x = \\frac{1}{2}$处：$|1 - 2\\omega (\\frac{1}{2})| = |1 - \\omega|$。\n在$x = 1$处：$|1 - 2\\omega (1)| = |1 - 2\\omega|$。\n\n因此，平滑因子是$\\rho(\\omega) = \\max(|1-\\omega|, |1-2\\omega|)$。\n考虑到松弛参数$\\omega$在区间$(0,1)$内，$1-\\omega$项总是正的，所以$|1-\\omega| = 1-\\omega$。\n表达式简化为$\\rho(\\omega) = \\max(1-\\omega, |1-2\\omega|)$。\n\n最后一步是找到使$\\rho(\\omega)$最小化的$\\omega \\in (0,1)$的值。两个连续函数的最大值的最小值通常出现在这两个函数相等的地方。我们令$\\max$函数的两个参数相等：\n$$ 1 - \\omega = |1 - 2\\omega| $$\n我们考虑绝对值项的两种情况：\n情况1：$1 - 2\\omega \\geq 0$，这意味着$\\omega \\leq \\frac{1}{2}$。方程变为$1 - \\omega = 1 - 2\\omega$，得出$\\omega = 0$。这不在指定的域$\\omega \\in (0,1)$内。\n情况2：$1 - 2\\omega  0$，这意味着$\\omega > \\frac{1}{2}$。方程变为$1 - \\omega = -(1 - 2\\omega) = 2\\omega - 1$。\n求解$\\omega$：\n$$ 2 = 3\\omega \\implies \\omega = \\frac{2}{3} $$\n这个值$\\omega = \\frac{2}{3}$在域$(0,1)$内，并且满足条件$\\omega > \\frac{1}{2}$，因此它是最优松弛参数，$\\omega_{opt} = \\frac{2}{3}$。\n\n将$\\omega_{opt}$代入$\\rho(\\omega)$的表达式中，可以找到最小化的平滑因子：\n$$ \\rho_{min} = \\rho\\left(\\frac{2}{3}\\right) = \\max\\left(1-\\frac{2}{3}, \\left|1-2\\left(\\frac{2}{3}\\right)\\right|\\right) $$\n$$ \\rho_{min} = \\max\\left(\\frac{1}{3}, \\left|1-\\frac{4}{3}\\right|\\right) = \\max\\left(\\frac{1}{3}, \\left|-\\frac{1}{3}\\right|\\right) = \\max\\left(\\frac{1}{3}, \\frac{1}{3}\\right) = \\frac{1}{3} $$\n最小平滑因子是$\\frac{1}{3}$。",
            "answer": "$$ \\boxed{\\frac{1}{3}} $$"
        },
        {
            "introduction": "多重网格方法最具吸引力之处在于其最优的计算复杂度，即其求解问题的耗时与未知量数量 $N$ 成正比（$\\mathcal{O}(N)$）。本练习将引导您完成一次经典的 V-型循环（V-cycle）复杂度分析。通过将所有网格层级上的工作量进行求和，您将从理论上证明为何总计算成本最终仅与最细网格上的工作量成正比。",
            "id": "3783295",
            "problem": "考虑一个几何多重网格V循环，该循环应用于一个在方形区域上具有狄利克雷边界条件的二阶椭圆偏微分方程，其离散拉普拉斯算子来自标准的五点有限差分格式。最细层网格是一个均匀的结构化网格，有 $m \\times m$ 个点，其中 $m$ 是偶数且足够大，以至于可以在每个空间方向上以因子2进行粗化，直到一个粗网格只有$\\mathcal{O}(1)$个点。在每一层上，使用标准的按因子2在每个方向上的粗化，一个预平滑和一个后平滑步骤（每个平滑步骤是单次加权雅可比扫描），用于延拓的分段双线性插值，以及用于限制的全加权。假设采用标准的基于残差的粗网格校正。\n\n采纳以下基本建模假设：\n- 第$\\ell$层上的内部未知数数量与$m^{2}/4^{\\ell}$成正比。\n- 在第$\\ell$层上，以下每个核心操作的浮点运算次数都与该层的内部未知数数量成正比：一次平滑扫描、残差形成、限制算子的应用和延拓算子的应用。这些核心操作的比例常数可能不同，但不依赖于$\\ell$。\n- 求解最粗网格问题的成本受一个与层级无关的常数限制（即，当$m \\to \\infty$时，与最细层的成本相比可以忽略不计）。\n- 忽略通信成本以及任何缓存或内存层次结构效应；仅计算浮点算术运算，不计乘法常数因子。\n\n在这些假设下，并考虑到每层恰好一个预平滑和一个后平滑步骤，推导出一个完整V循环的渐进浮点运算次数，表示为关于$m$的解析表达式，不计乘法常数因子。将您的最终答案表示为单个关于$m$的封闭形式表达式，不使用大$\\mathcal{O}$或$\\Theta$符号，且不带单位。",
            "solution": "用户要求我扮演一位严谨的STEM教授，解决一个关于几何多重网格V循环计算成本的问题。\n\n### 第一步：问题验证\n\n首先，我必须仔细验证问题陈述。\n\n**提取的已知条件：**\n- **算法：** 几何多重网格V循环。\n- **方程：** 方形区域上带有狄利克雷边界条件的离散化二阶椭圆偏微分方程（拉普拉斯算子）。\n- **网格层次结构：** 最细的网格是一个$m \\times m$个点的均匀结构化网格。在每个维度上以因子2进行粗化。最粗的网格有$\\mathcal{O}(1)$个点。\n- **多重网格组件：**\n    - 平滑：每层一个预平滑和一个后平滑步骤，使用加权雅可比扫描。\n    - 延拓：分段双线性插值。\n    - 限制：全加权。\n    - 粗网格校正：标准的基于残差的方法。\n- **成本模型假设：**\n    - 第$\\ell$层上的内部未知数数量，记为$N_{\\ell}$，与$m^{2}/4^{\\ell}$成正比。\n    - 在第$\\ell$层上，单次平滑扫描、残差形成、限制和延拓的浮点运算计数均与$N_{\\ell}$成正比。\n    - 对于大的$m$，求解最粗网格问题的成本可以忽略不计。\n    - 只计算浮点运算；通信和内存效应被忽略。\n- **目标：** 推导单个V循环的渐进浮点运算计数，以$m$的封闭形式表达式给出，忽略乘法常数因子，且不使用$\\mathcal{O}$或$\\Theta$符号。\n\n**使用提取的已知条件进行验证：**\n- **科学依据：** 该问题坚实地植根于偏微分方程数值分析的既定理论。多重网格V循环、指定的组件（加权雅可比、双线性插值、全加权）以及成本模型都是科学计算领域中标准且科学上合理的概念。\n- **适定性：** 该问题是适定的。它提供了一个清晰的算法结构和一组精确（尽管是抽象的）的成本假设。目标是推导总复杂度，这是这些前提唯一确定的结果。\n- **客观性：** 问题陈述是客观的，使用了数值分析中常见的精确技术语言。\n- **完备性与一致性：** 该问题是自洽的，其条件是一致的。它为计算复杂度的渐进分析提供了所有必要信息。\n- **可行性：** 该场景是分析多重网格方法效率的标准理想化模型。这种分析是该领域的常见且有效的实践。\n- **结构与平凡性：** 该问题需要一个标准但非平凡的推理过程，涉及对跨多个尺度的工作量进行求和，该过程由一个几何级数建模。它不是结构不良、平凡或故作高深的。\n\n**结论：**\n问题陈述是**有效的**。这是一个数值分析中的标准且适定的问题。我现在将开始求解。\n\n### 第二步：解的推导\n\n设多重网格的层级由$\\ell$索引，其中$\\ell = 0$对应最细的网格，$\\ell = L$对应最粗的网格。问题指定最细层级$\\ell=0$上有一个$m \\times m$个点的均匀网格。\n\n第一个给出的关键假设是，第$\\ell$层上的内部未知数数量，记为$N_{\\ell}$，与$m^{2}/4^{\\ell}$成正比。我们可以将此关系正式表示为：\n$$N_{\\ell} = C_{N} \\frac{m^{2}}{4^{\\ell}}$$\n其中$C_{N}$是某个正的比例常数。这种缩放关系正确地模拟了标准的粗化策略，即在每个空间维度上网格间距加倍，从而在每个连续层级上将未知数数量减少4倍。\n\n一个V循环算法在每个层级上涉及一系列操作。对于任何给定的层级$\\ell$（其中$\\ell \\in \\{0, 1, \\dots, L-1\\}$），操作如下：\n1.  一个预平滑步骤。\n2.  计算残差。\n3.  将残差限制到下一层更粗的网格，即第$\\ell+1$层。\n4.  一个递归步骤，在第$\\ell+1$层上求解误差方程（这构成了V循环的“下降”和“上升”的其余部分）。\n5.  将计算出的校正量从第$\\ell+1$层延拓回第$\\ell$层。\n6.  一个更新步骤，将校正量应用于第$\\ell$层的解。\n7.  一个后平滑步骤。\n\n问题陈述指出，每个基本核心操作——平滑、残差计算、限制和延拓——的成本（以浮点运算为单位）都与该层的未知数数量$N_{\\ell}$成正比。设各自的比例常数为$c_{\\text{smooth}}$, $c_{\\text{resid}}$, $c_{\\text{restrict}}$和$c_{\\text{prolong}}$。解的更新是一个向量加法，其成本也与$N_{\\ell}$成正比，我们可以称这个常数为$c_{\\text{update}}$。\n\n在第$\\ell$层（对于$\\ell  L$）*上*执行的总计算工作量，我们记为$W_{\\ell}$，是在该层局部执行的操作成本之和。这包括一次预平滑扫描和一次后平滑扫描。\n$$W_{\\ell} = (c_{\\text{smooth}} + c_{\\text{resid}} + c_{\\text{restrict}} + c_{\\text{prolong}} + c_{\\text{update}} + c_{\\text{smooth}}) N_{\\ell}$$\n这个表达式可以通过将各种与实现相关的常数合并为一个单一的正定常数$C_{W}$来简化：\n$$W_{\\ell} = C_{W} N_{\\ell}$$\n代入$N_{\\ell}$的表达式，我们得到第$\\ell$层的工作量作为$m$和$\\ell$的函数：\n$$W_{\\ell} = C_{W} \\left(C_{N} \\frac{m^{2}}{4^{\\ell}}\\right) = C \\frac{m^{2}}{4^{\\ell}}$$\n其中$C = C_{W} C_{N}$是一个总的正定常数，它包含了网格和特定计算核心的细节，但与层级$\\ell$和网格大小$m$无关。\n\n一个完整V循环的总工作量$W_{\\text{V-cycle}}$是从$\\ell=0$到$\\ell=L-1$在每一层上执行的工作量之和，再加上在最粗网格上直接求解的成本$W_{\\text{coarse}}$。\n$$W_{\\text{V-cycle}} = \\left( \\sum_{\\ell=0}^{L-1} W_{\\ell} \\right) + W_{\\text{coarse}}$$\n求和仅到$L-1$为止，因为在最粗的层级$\\ell=L$上，执行的是直接求解而不是平滑和递归。\n\n问题陈述指出，最粗网格求解的成本$W_{\\text{coarse}}$受一个与$m$无关的常数限制，因此在$m \\to \\infty$的渐进极限下，与最细层级上的工作量$W_{0} = C m^{2}$相比可以忽略不计。因此，对于大的$m$，我们可以仅用求和来精确地近似总工作量：\n$$W_{\\text{V-cycle}} \\approx \\sum_{\\ell=0}^{L-1} W_{\\ell} = \\sum_{\\ell=0}^{L-1} C \\frac{m^{2}}{4^{\\ell}}$$\n我们可以将与求和索引$\\ell$无关的项提取出来：\n$$W_{\\text{V-cycle}} \\approx C m^{2} \\sum_{\\ell=0}^{L-1} \\left(\\frac{1}{4}\\right)^{\\ell}$$\n该和是一个有限几何级数。由于$m$“足够大”，层级数$L$也很大，有$L \\approx \\log_{2}(m)$。在$m \\to \\infty$的渐进极限下，我们有$L \\to \\infty$。因此，该和可以用相应的无穷几何级数来近似。这个级数的和是一个常数：\n$$\\sum_{\\ell=0}^{\\infty} \\left(\\frac{1}{4}\\right)^{\\ell} = \\frac{1}{1 - \\frac{1}{4}} = \\frac{1}{\\frac{3}{4}} = \\frac{4}{3}$$\n该级数的快速收敛确保了这对于总工作量来说是一个极好的近似。因此，渐进成本为：\n$$W_{\\text{V-cycle}} \\approx C m^{2} \\left(\\frac{4}{3}\\right) = \\frac{4C}{3} m^{2}$$\n这个结果表明，V循环的总工作量与$m^{2}$成正比。比例常数是$\\frac{4}{3}C$，它既包含了V循环的结构（因子$\\frac{4}{3}$），也包含了每个点的操作成本（因子$C$）。\n\n问题要求最终答案是关于$m$的解析表达式，“忽略乘法常数因子”，并明确禁止使用大O或Theta符号。这是一个只提供关于$m$的函数依赖关系的指令。由于整个项$\\frac{4C}{3}$是一个未指定的乘法常数，因此满足所有约束的成本表达式就是剩下的函数部分。",
            "answer": "$$\n\\boxed{m^{2}}\n$$"
        },
        {
            "introduction": "理论分析最终需要通过数值实验进行验证和补充。本练习要求您编写程序，为一个模型问题具体构建出完整的两网格（Two-Grid）迭代矩阵 $E_{\\mathrm{TG}}$。通过计算该矩阵的谱半径 $\\rho(E_{\\mathrm{TG}})$，您将可以直接度量方法的收敛因子，并观察其如何随网格尺寸、松弛参数等设置而变化，从而连接理论与实践。",
            "id": "3783314",
            "problem": "考虑一维泊松边界值问题 $-u''(x)=f(x)$，定义在区间 $(0,1)$ 上，并带有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。使用标准的二阶中心有限差分法，在具有 $n$ 个内部点的均匀网格上对该问题进行离散化，得到线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是离散化产生的对称正定三对角矩阵。\n\n您的任务是构建一个双网格（TG）多重网格误差传播算子，并数值计算其收敛因子，该收敛因子定义为双网格误差传播矩阵的谱半径。使用以下组件：\n\n- 用于前光滑和后光滑的加权雅可比光滑子，松弛参数为 $\\omega$，用作前光滑时应用 $\\nu_1$ 次，用作后光滑时应用 $\\nu_2$ 次。\n- 用于延拓（从粗网格到细网格）的线性插值。\n- 全加权限制（从细网格到粗网格），通过伽辽金粗网格算子 $A_c = R A P$ 进行一致性定义，其中 $P$ 表示延拓矩阵，$R$ 表示限制矩阵。\n\n从以下基本定义和建模假设开始：\n- 对于网格间距为 $h = \\frac{1}{n+1}$ 的均匀网格上带狄利克雷边界条件的一维泊松问题，其离散算子 $A$ 是一个三对角矩阵，其对角线元素为 $\\frac{2}{h^2}$，次对角线和超对角线元素为 $-\\frac{1}{h^2}$。\n- 用于求解 $A u = b$ 的加权雅可比迭代更新公式为 $u^{(k+1)} = u^{(k)} + \\omega D^{-1}(b - A u^{(k)})$，其中 $D$ 是 $A$ 的对角部分。\n- 对于误差 $e^{(k)} = u - u^{(k)}$，加权雅可比误差传播矩阵为 $S = I - \\omega D^{-1} A$。\n- 延拓矩阵 $P \\in \\mathbb{R}^{n \\times n_c}$ 由线性插值给出，其中 $n_c = \\lfloor n/2 \\rfloor$ 是粗网格上的内部点数。具体来说，当这些索引在范围内时，索引为 $j$ 的粗网格变量以权重 $\\frac{1}{2}$、$1$ 和 $\\frac{1}{2}$ 分别映射到细网格索引 $2j-1$、$2j$ 和 $2j+1$。\n- 限制矩阵是全加权算子 $R = \\frac{1}{2} P^\\top$，确保了伽辽金粗网格算子 $A_c = R A P$ 的对称性。\n- 对于一次前光滑和一次后光滑扫描的双网格误差传播算子为\n$$\nE_{\\mathrm{TG}} = S_{\\text{post}}^{\\nu_2} \\left(I - P A_c^{-1} R A\\right) S_{\\text{pre}}^{\\nu_1},\n$$\n其中 $S_{\\text{pre}} = S_{\\text{post}} = S$ 是加权雅可比误差传播矩阵。双网格收敛因子是谱半径 $\\rho(E_{\\mathrm{TG}})$。\n\n实现一个程序，对于给定的参数 $(n, \\omega, \\nu_1, \\nu_2)$，构建 $A$、$P$、$R$、$A_c$ 和 $E_{\\mathrm{TG}}$，并计算 $\\rho(E_{\\mathrm{TG}})$，即 $E_{\\mathrm{TG}}$ 特征值的最大模。计算必须完全是数值的、自包含的，且不需外部输入。\n\n使用以下参数集测试套件来评估计算的不同方面：\n- 情况1：$n=31$, $\\omega=\\frac{2}{3}$, $\\nu_1=1$, $\\nu_2=1$（基准请求配置）。\n- 情况2：$n=3$, $\\omega=\\frac{2}{3}$, $\\nu_1=1$, $\\nu_2=1$（最小的非平凡粗网格）。\n- 情况3：$n=63$, $\\omega=\\frac{2}{3}$, $\\nu_1=1$, $\\nu_2=1$（更大的网格以评估渐进行为）。\n- 情况4：$n=31$, $\\omega=\\frac{1}{2}$, $\\nu_1=1$, $\\nu_2=1$（不同松弛参数的影响）。\n- 情况5：$n=31$, $\\omega=\\frac{2}{3}$, $\\nu_1=2$, $\\nu_2=2$（更强光滑的影响）。\n\n在此公式中，所有计算都是无量纲的；不需要物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，并按上述情况排序。每个结果必须是浮点数，格式化为小数点后恰好六位数字，例如 $[\\rho_1,\\rho_2,\\rho_3,\\rho_4,\\rho_5]$，其中每个 $\\rho_i$ 是对应于情况 $i$ 的计算所得的谱半径。",
            "solution": "问题陈述被评估为有效。它在科学上基于偏微分方程数值分析的原理，是客观的，并提供了一套完整且一致的定义来构建数值解。所有组件——泊松问题、有限差分离散化、加权雅可比光滑子以及双网格循环组件（延拓、限制、伽辽金算子）——都是多重网格方法领域的标准课题。该问题是适定的，要求对一个明确定义的误差传播矩阵进行谱半径的数值计算。\n\n解决方案的步骤是为每个给定的参数集 $(n, \\omega, \\nu_1, \\nu_2)$ 构建双网格分析所需的矩阵。\n\n**步骤1：离散化与细网格算子 $A$**\n一维泊松方程 $-u''(x) = f(x)$ 在 $(0, 1)$ 上，满足 $u(0)=u(1)=0$，在具有 $n$ 个内部点 $x_i = i h$（$i=1, \\dots, n$）的均匀网格上进行离散化，其中网格间距为 $h = \\frac{1}{n+1}$。二阶导数 $u''(x_i)$ 使用二阶中心有限差分进行近似：\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2}\n$$\n将此应用于每个内部点 $x_i$ 的方程，并结合边界条件 $u(x_0)=u_0=0$ 和 $u(x_{n+1})=u_{n+1}=0$，得到线性系统 $A\\mathbf{u} = \\mathbf{b}$。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定三对角矩阵，定义为：\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n2  -1    \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  2\n\\end{pmatrix}\n$$\n对角线元素为 $A_{i,i} = \\frac{2}{h^2}$，次对角线和超对角线元素为 $A_{i,i\\pm1} = -\\frac{1}{h^2}$。\n\n**步骤2：加权雅可比光滑子与误差传播矩阵 $S$**\n用于求解 $A\\mathbf{u}=\\mathbf{b}$ 的加权雅可比方法是一种迭代格式。误差 $\\mathbf{e}^{(k)} = \\mathbf{u} - \\mathbf{u}^{(k)}$ 根据矩阵 $S = I - \\omega D^{-1} A$ 进行传播，其中 $D$ 是 $A$ 的对角部分，$I$ 是单位矩阵，$\\omega$ 是松弛参数。对于我们特定的矩阵 $A$，其对角线是常数：$D = \\frac{2}{h^2} I$。因此，$D^{-1} = \\frac{h^2}{2} I$，光滑子矩阵简化为：\n$$\nS = I - \\omega \\left(\\frac{h^2}{2} I\\right) A = I - \\frac{\\omega h^2}{2} A\n$$\n\n**步骤3：网格间传递算子：延拓 $P$ 与限制 $R$**\n网格传递算子在细网格（有 $n$ 个点）和粗网格（有 $n_c = \\lfloor n/2 \\rfloor$ 个点）之间映射向量。\n延拓（或插值）算子 $P \\in \\mathbb{R}^{n \\times n_c}$ 将粗网格向量映射到细网格向量。问题为 $P$ 指定了一个特定的模板。使用基于0的矩阵索引，其中细网格索引为 $i \\in \\{0, \\dots, n-1\\}$，粗网格索引为 $j \\in \\{0, \\dots, n_c-1\\}$，$P$ 的第 $j$ 列（对应于第 $j$ 个粗网格基向量）在行 $2j$、$2j+1$ 和 $2j+2$ 处有非零项，前提是它们在细网格的边界内。指定的权重分别为 $\\frac{1}{2}$、$1$ 和 $\\frac{1}{2}$。\n$$\n(P \\mathbf{v}_c)_i = \\begin{cases}\n\\frac{1}{2} v_{c,j}  \\text{if } i = 2j \\\\\nv_{c,j}  \\text{if } i = 2j+1 \\\\\n\\frac{1}{2} v_{c,j}  \\text{if } i = 2j+2 \\\\\n\\end{cases}\n$$\n需满足索引在范围内。此结构定义了矩阵 $P$。\n限制算子 $R \\in \\mathbb{R}^{n_c \\times n}$ 将细网格向量映射到粗网格向量。它被定义为延拓算子的缩放转置，以确保伽辽金粗网格算子的对称性：\n$$\nR = \\frac{1}{2} P^\\top\n$$\n\n**步骤4：粗网格算子 $A_c$**\n粗网格算子 $A_c$ 应当在粗网格上近似细网格算子 $A$。伽辽金方法通过网格间传递算子来定义 $A_c$：\n$$\nA_c = R A P = \\left(\\frac{1}{2} P^\\top\\right) A P\n$$\n对于给定的问题，如果 $A$ 是对称正定的，那么 $A_c$ 也将是对称正定且因此可逆。$A_c$ 是一个 $n_c \\times n_c$ 的矩阵。\n\n**步骤5：双网格误差传播算子 $E_{\\mathrm{TG}}$**\n一个双网格V循环包括前光滑、粗网格校正和后光滑。此完整循环的误差传播由以下算子给出：\n$$\nE_{\\mathrm{TG}} = S^{\\nu_2} \\left(I - P A_c^{-1} R A\\right) S^{\\nu_1}\n$$\n在这里，$S^{\\nu_1}$ 表示 $\\nu_1$ 次前光滑步骤的效果。括号中的项代表粗网格校正步骤，该步骤涉及限制残差、在粗网格上求解误差方程 ($A_c e_c = r_c$)，以及将校正量延拓回细网格。$S^{\\nu_2}$ 表示 $\\nu_2$ 次后光滑步骤的效果。\n\n**步骤6：收敛因子计算**\n双网格方法的渐进收敛因子是误差传播算子的谱半径，$\\rho(E_{\\mathrm{TG}})$。谱半径定义为 $E_{\\mathrm{TG}}$ 特征值绝对值的最大值：\n$$\n\\rho(E_{\\mathrm{TG}}) = \\max \\{|\\lambda| : \\lambda \\text{ is an eigenvalue of } E_{\\mathrm{TG}}\\}\n$$\n该值是为每组参数 $(n, \\omega, \\nu_1, \\nu_2)$ 通过构建矩阵 $E_{\\mathrm{TG}}$ 然后求其特征值来数值计算的。\n\n实现将为提供的每个测试用例精确地遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spectral_radius(n, omega, nu1, nu2):\n    \"\"\"\n    Constructs the Two-Grid error-propagation operator and computes its spectral radius.\n\n    Args:\n        n (int): Number of interior grid points on the fine grid.\n        omega (float): Relaxation parameter for the weighted Jacobi smoother.\n        nu1 (int): Number of pre-smoothing steps.\n        nu2 (int): Number of post-smoothing steps.\n\n    Returns:\n        float: The spectral radius of the Two-Grid operator.\n    \"\"\"\n    # Step 1: Construct Fine-Grid Operator A\n    h = 1.0 / (n + 1)\n    diag_val = 2.0 / h**2\n    offdiag_val = -1.0 / h**2\n    \n    A = np.diag(np.full(n, diag_val))\n    A += np.diag(np.full(n - 1, offdiag_val), k=1)\n    A += np.diag(np.full(n - 1, offdiag_val), k=-1)\n\n    # Step 2: Construct Weighted Jacobi Smoother S\n    # D is diag(A), which is a constant diagonal matrix (diag_val * I).\n    # D_inv is (1/diag_val) * I = (h^2 / 2) * I.\n    # S = I - omega * D_inv @ A\n    S = np.identity(n) - omega * (h**2 / 2.0) * A\n\n    # Step 3: Construct Prolongation Operator P\n    n_c = n // 2\n    if n_c == 0:\n        # Trivial case: no coarse grid, so no correction. Factor is rho(S).\n        eigvals_S = np.linalg.eigvals(np.linalg.matrix_power(S, nu1 + nu2))\n        return np.max(np.abs(eigvals_S))\n        \n    P = np.zeros((n, n_c))\n    \n    # Using 0-based indexing for arrays. The problem statement implies a stencil\n    # centered at fine point 2j+1 for coarse point j.\n    # A coarse value at index j (0-based) contributes to fine grid\n    # values at indices 2j, 2j+1, 2j+2.\n    for j in range(n_c):\n        # Contribution to fine grid index 2j\n        if (2 * j)  n:\n            P[2 * j, j] = 0.5\n        # Contribution to fine grid index 2j+1\n        if (2 * j + 1)  n:\n            P[2 * j + 1, j] = 1.0\n        # Contribution to fine grid index 2j+2\n        if (2 * j + 2)  n:\n            P[2 * j + 2, j] = 0.5\n            \n    # Step 4: Construct Restriction Operator R\n    R = 0.5 * P.T\n    \n    # Step 5: Construct Coarse-Grid Operator Ac\n    A_c = R @ A @ P\n    \n    # Step 6: Construct Two-Grid Error Propagation Operator E_TG\n    A_c_inv = np.linalg.inv(A_c)\n    \n    # Coarse-grid correction operator\n    CGC = np.identity(n) - P @ A_c_inv @ R @ A\n    \n    # Smoothing operators\n    S_pre = np.linalg.matrix_power(S, nu1)\n    S_post = np.linalg.matrix_power(S, nu2)\n    \n    E_tg = S_post @ CGC @ S_pre\n    \n    # Step 7: Compute Spectral Radius\n    eigenvalues = np.linalg.eigvals(E_tg)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (n=31, omega=2/3, nu1=1, nu2=1)\n        (31, 2.0/3.0, 1, 1),\n        # Case 2: (n=3, omega=2/3, nu1=1, nu2=1)\n        (3, 2.0/3.0, 1, 1),\n        # Case 3: (n=63, omega=2/3, nu1=1, nu2=1)\n        (63, 2.0/3.0, 1, 1),\n        # Case 4: (n=31, omega=1/2, nu1=1, nu2=1)\n        (31, 0.5, 1, 1),\n        # Case 5: (n=31, omega=2/3, nu1=2, nu2=2)\n        (31, 2.0/3.0, 2, 2)\n    ]\n\n    results = []\n    for params in test_cases:\n        n, omega, nu1, nu2 = params\n        rho = compute_spectral_radius(n, omega, nu1, nu2)\n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    # Format each result to exactly six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}