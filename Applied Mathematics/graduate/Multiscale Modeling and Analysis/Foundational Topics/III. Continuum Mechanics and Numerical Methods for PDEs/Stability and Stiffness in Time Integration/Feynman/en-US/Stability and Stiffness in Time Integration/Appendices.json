{
    "hands_on_practices": [
        {
            "introduction": "Understanding the stability properties of a numerical method is not just about analysis; it is also about design. By imposing desired stability characteristics, we can derive constraints on a method's parameters. This exercise provides foundational practice in this process by asking you to determine the conditions under which a one-parameter family of methods achieves L-stability, a crucial property for effectively damping spurious high-frequency oscillations in stiff systems .",
            "id": "3808530",
            "problem": "Consider the linear test problem $u'(t) = \\lambda u(t)$ with complex stiffness parameter $\\lambda \\in \\mathbb{C}$ and a one-step time integrator whose stability function is rational. The time-step is $h > 0$ and the dimensionless stiffness is $z = h \\lambda$. The discrete propagation of a Fourier mode is governed by $u_{n+1} = R(z) u_{n}$, where $R$ is the stability function. A method is called absolutely stable on a set $S \\subset \\mathbb{C}$ if $|R(z)| \\leq 1$ for all $z \\in S$. A method is called $A$-stable (absolute stability over the left-half complex plane) if $|R(z)| \\leq 1$ for all $z$ with $\\Re(z) \\leq 0$. A method is called $L$-stable if it is $A$-stable and, in addition, $\\lim_{|z|\\to\\infty} R(z) = 0$.\n\nIn multiscale modeling and analysis of stiff systems, high-frequency modes in semi-discrete partial differential equations (for example, those arising from discretized diffusion or reaction operators) correspond to eigenvalues $\\lambda$ with large negative real parts, and the time integrator’s numerical damping of those modes is quantified by the limit of $R(z)$ as $|z| \\to \\infty$. \n\nConsider the one-parameter family of implicit one-step methods with stability function\n$$\nR(z;a) = \\frac{1 + a z}{1 - z},\n$$\nwhere $a \\in \\mathbb{R}$ is a tunable parameter introduced by a consistent algebraic correction to the implicit update. Starting from the definitions above and without assuming any special properties beyond rationality of $R$, derive conditions on $a$ under which the method is $L$-stable. Then, interpret these conditions in terms of numerical damping of high-frequency modes for a semi-discrete linear diffusion operator whose eigenvalues satisfy $\\lambda_{k} = -\\nu k^{2}$ with $\\nu > 0$ and wavenumber $k \\in \\mathbb{R}$. In your derivation, link the behavior of $R(z;a)$ as $|z| \\to \\infty$ to the suppression of high-frequency components (large $|k|$) under time marching. \n\nYour final task is to determine the unique real value of $a$ for which $R(z;a)$ is $L$-stable. Express your answer as a single real number. No rounding is required.",
            "solution": "The problem asks for the unique real value of the parameter $a$ for which the one-step method with stability function $R(z;a) = \\frac{1 + a z}{1 - z}$ is $L$-stable.\n\nAccording to the provided definition, a method is $L$-stable if it satisfies two conditions:\n1. It is $A$-stable, meaning $|R(z;a)| \\leq 1$ for all complex numbers $z$ with non-positive real part, $\\Re(z) \\leq 0$.\n2. The stability function vanishes at infinity, i.e., $\\lim_{|z|\\to\\infty} R(z;a) = 0$.\n\nWe will analyze these two conditions to constrain the value of $a \\in \\mathbb{R}$.\n\nFirst, let us examine the limit condition, as it is algebraically simpler. The stability function is a rational function of $z$:\n$$\nR(z;a) = \\frac{1 + a z}{1 - z}\n$$\nTo evaluate the limit as $|z| \\to \\infty$, we can divide both the numerator and the denominator by $z$:\n$$\nR(z;a) = \\frac{\\frac{1}{z} + a}{\\frac{1}{z} - 1}\n$$\nAs $|z| \\to \\infty$, the term $\\frac{1}{z}$ approaches $0$. Therefore, the limit is:\n$$\n\\lim_{|z|\\to\\infty} R(z;a) = \\lim_{|z|\\to\\infty} \\frac{\\frac{1}{z} + a}{\\frac{1}{z} - 1} = \\frac{0+a}{0-1} = -a\n$$\nThe second condition for $L$-stability requires this limit to be zero.\n$$\n-a = 0\n$$\nThis implies that the only possible value for $a$ that could result in an $L$-stable method is $a=0$.\n\nNow, we must verify if the method is $A$-stable for this specific value, $a=0$. If it is, then $a=0$ is the unique value for which the method is $L$-stable. If it is not $A$-stable for $a=0$, then no value of $a$ can satisfy the $L$-stability criteria.\n\nFor $a=0$, the stability function becomes:\n$$\nR(z;0) = \\frac{1 + (0)z}{1 - z} = \\frac{1}{1 - z}\n$$\nThis is the stability function of the first-order implicit Backward Euler method. To check for $A$-stability, we must verify that $|R(z;0)| \\leq 1$ for all $z \\in \\mathbb{C}$ such that $\\Re(z) \\leq 0$.\n\nLet $z = x + iy$, where $x = \\Re(z)$ and $y = \\Im(z)$. The condition $\\Re(z) \\leq 0$ means $x \\leq 0$. We evaluate the squared magnitude of $R(z;0)$:\n$$\n|R(z;0)|^2 = \\left| \\frac{1}{1 - (x+iy)} \\right|^2 = \\left| \\frac{1}{(1-x) - iy} \\right|^2\n$$\nThe squared magnitude of a complex number $\\alpha + i\\beta$ is $\\alpha^2 + \\beta^2$. Thus,\n$$\n|R(z;0)|^2 = \\frac{1^2}{(1-x)^2 + (-y)^2} = \\frac{1}{(1-x)^2 + y^2}\n$$\nThe $A$-stability condition $|R(z;0)| \\leq 1$ is equivalent to $|R(z;0)|^2 \\leq 1^2 = 1$.\n$$\n\\frac{1}{(1-x)^2 + y^2} \\leq 1\n$$\nSince the denominator $(1-x)^2 + y^2$ is always non-negative (and non-zero, as $z=1$ is not in the left-half plane), we can multiply both sides by it:\n$$\n1 \\leq (1-x)^2 + y^2\n$$\nWe must check if this inequality holds for all $x \\leq 0$ and $y \\in \\mathbb{R}$.\nGiven $x \\leq 0$, it follows that $-x \\geq 0$, and adding $1$ to both sides gives $1-x \\geq 1$.\nSquaring this, we get $(1-x)^2 \\geq 1^2 = 1$.\nSince $y^2$ is always non-negative for any real $y$, we have $y^2 \\geq 0$.\nAdding these two inequalities, we obtain:\n$$\n(1-x)^2 + y^2 \\geq 1 + 0 = 1\n$$\nThis confirms that the inequality $1 \\leq (1-x)^2 + y^2$ holds for all $z$ with $\\Re(z) \\leq 0$. Therefore, the method with $a=0$ is indeed $A$-stable.\n\nSince the method is $A$-stable for $a=0$ and satisfies $\\lim_{|z|\\to\\infty} R(z;0) = 0$, it is $L$-stable by definition. As we showed that the limit condition is only met for $a=0$, this value is unique.\n\nThe interpretation in the context of multiscale modeling is as follows. In a semi-discrete system arising from a diffusion operator, the eigenvalues are of the form $\\lambda_k = -\\nu k^2$ for $\\nu > 0$ and wavenumber $k$. High-frequency modes correspond to large values of $|k|$. The dimensionless stiffness for such a mode is $z_k = h\\lambda_k = -h \\nu k^2$. As the frequency (wavenumber $|k|$) increases, $z_k$ becomes a large-magnitude negative real number, i.e., $z_k \\to -\\infty$.\nThe purpose of a stiff time integrator is not only to be stable for these modes (which $A$-stability guarantees, since $|R(z_k)| \\leq 1$) but also to damp them out effectively, as they often represent non-physical, high-frequency oscillations resulting from the spatial discretization. The amplification factor for a mode after one time step is $|R(z_k)|$. The ideal damping corresponds to an amplification factor of $0$. The $L$-stability condition $\\lim_{|z|\\to\\infty} R(z) = 0$ ensures precisely this behavior: for the highest-frequency (stiffest) components of the solution, the amplification factor approaches zero. In our case, $\\lim_{|z|\\to\\infty} R(z;a) = -a$. Setting $a=0$ ensures that $|R(z_k)| \\to 0$ as $|k| \\to \\infty$, leading to the rapid suppression of these stiff modes, which is a highly desirable property in multiscale simulations. Any non-zero value of $a$ would mean that infinitely stiff modes are damped by a factor of $|-a|=|a|$, not eliminated in one step.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Theoretical stability definitions like A-stability and L-stability come to life when observed in practice. This hands-on coding exercise is designed to bridge theory and numerical experiment by implementing two classic implicit methods, Backward Euler and the Implicit Midpoint rule. By applying them to a benchmark stiff system, you will numerically verify their stability properties and directly observe the practical difference between A-stability and the stronger, more dissipative L-stability .",
            "id": "3808603",
            "problem": "Consider the linear time-invariant ordinary differential equation $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$ and $y(t) \\in \\mathbb{C}$. This scalar linear test equation is the canonical base for assessing numerical stability properties of time-integration methods. In multiscale modeling and analysis, stiffness arises when the system has modes with widely separated decay rates. A simple stiff benchmark that captures this is the diagonal $2 \\times 2$ system $Y'(t) = A Y(t)$ with\n$$\nA = \\begin{pmatrix} \\lambda_s & 0 \\\\ 0 & \\lambda_f \\end{pmatrix}, \\quad \\lambda_s = -1, \\quad \\lambda_f = -1000,\n$$\nand initial condition $Y(0) = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$. The exact solution is $Y(t) = \\begin{pmatrix} e^{\\lambda_s t} \\\\ e^{\\lambda_f t} \\end{pmatrix}$. The slow mode is governed by $\\lambda_s$, and the fast mode is governed by $\\lambda_f$.\n\nTwo candidate one-step methods are to be assessed:\n\n- Backward Euler, defined by $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$.\n- Implicit Midpoint, defined by $y_{n+1} = y_n + h f\\!\\left(t_n + \\frac{h}{2}, \\frac{y_n + y_{n+1}}{2}\\right)$.\n\nTreat both methods as applied to the scalar linear test equation $y' = \\lambda y$ and to the diagonal system above. For the scalar case, the discrete update has the form $y_{n+1} = R(z) y_n$ where $z = h \\lambda$ and $R(z)$ is the method's amplification factor (also called the stability function). Absolute stability (A-stability) requires $\\lvert R(z) \\rvert \\leq 1$ for all $z$ with $\\operatorname{Re}(z) \\leq 0$. The property known as L-stability requires A-stability together with $\\lim_{z \\to -\\infty} R(z) = 0$ along the negative real axis, which ensures rapid decay of very fast modes.\n\nYour task is to write a complete, runnable program that:\n\n1. Derives, implements, and uses the amplification factor $R(z)$ for each method on the scalar linear test equation $y' = \\lambda y$.\n2. Verifies absolute stability (A-stability) for each method on a finite test suite by checking the condition $\\lvert R(z) \\rvert \\leq 1$ at sampled points $z = h \\lambda$ where $h$ and $\\lambda$ are chosen from the sets listed below.\n3. Verifies the L-stability property by testing whether $\\lvert R(z) \\rvert$ is sufficiently small for a very large negative real $z$.\n4. Quantifies how each method amplifies the fast mode of the stiff diagonal system over a single time step by comparing the numerical amplification $\\lvert R(h \\lambda_f) \\rvert$ to the exact one-step amplification $\\lvert e^{h \\lambda_f} \\rvert$, and reports the maximum absolute relative error over the specified step sizes.\n\nUse the following test suite:\n\n- For A-stability sampling, use $\\lambda \\in \\{-1,-10,-100\\}$ and $h \\in \\{0.1, 0.01, 1.0\\}$, giving test points $z = h \\lambda$ on the negative real axis.\n- For L-stability sampling, use $z = -10^6$.\n- For fast-mode error in the stiff diagonal system, use $\\lambda_f = -1000$ and $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$.\n\nYour program must compute and output the following six quantities in this exact order and type:\n\n- A boolean indicating whether Backward Euler is A-stable on the sampled points.\n- A boolean indicating whether Implicit Midpoint is A-stable on the sampled points.\n- A boolean indicating whether Backward Euler satisfies the L-stability check at $z = -10^6$ within a tolerance of $10^{-3}$, i.e., whether $\\lvert R(z) \\rvert \\leq 10^{-3}$.\n- A boolean indicating whether Implicit Midpoint satisfies the same L-stability check at $z = -10^6$.\n- A float equal to the maximum absolute relative error of Backward Euler for the fast mode amplification over $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$, where the relative error is $\\frac{\\lvert R(h \\lambda_f) - e^{h \\lambda_f} \\rvert}{\\lvert e^{h \\lambda_f} \\rvert}$.\n- A float equal to the analogous maximum absolute relative error for Implicit Midpoint.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$). No physical units are involved, and all values are dimensionless. The final outputs must be of the specified fundamental types: booleans and floats, with the floats expressed in decimal form.",
            "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded exercise in the numerical analysis of ordinary differential equations, specifically addressing the concepts of stability and stiffness, which are fundamental to multiscale modeling. All required parameters and definitions are provided, there are no internal contradictions, and the tasks are directly solvable using established principles.\n\nThe solution proceeds in four main steps, aligned with the tasks outlined in the problem statement:\n1. Derivation of the amplification factors for the Backward Euler and Implicit Midpoint methods.\n2. Numerical verification of A-stability for both methods against the provided test suite.\n3. Numerical verification of L-stability properties.\n4. Quantification of the accuracy of each method in amplifying the fast mode of the given stiff system.\n\n**1. Derivation of Amplification Factors**\n\nWe analyze the stability of the numerical methods by applying them to the scalar linear test equation $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$ and $\\operatorname{Re}(\\lambda) \\leq 0$. The numerical solution after one step, $y_{n+1}$, can be written in terms of the previous step, $y_n$, as $y_{n+1} = R(z) y_n$, where $z = h\\lambda$ and $R(z)$ is the amplification factor, also known as the stability function. The properties of $R(z)$ determine the stability of the method.\n\n- **Backward Euler (BE):**\nThe Backward Euler method is defined by $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$. For our test equation, $f(t,y) = \\lambda y$, so this becomes:\n$$\ny_{n+1} = y_n + h (\\lambda y_{n+1})\n$$\nWe solve for $y_{n+1}$:\n$$\ny_{n+1} - h \\lambda y_{n+1} = y_n \\\\\ny_{n+1} (1 - h\\lambda) = y_n \\\\\ny_{n+1} = \\frac{1}{1 - h\\lambda} y_n\n$$\nSubstituting $z = h\\lambda$, the amplification factor for the Backward Euler method is:\n$$\nR_{BE}(z) = \\frac{1}{1-z}\n$$\n\n- **Implicit Midpoint (IM):**\nThe Implicit Midpoint method is defined by $y_{n+1} = y_n + h f\\left(t_n + \\frac{h}{2}, \\frac{y_n + y_{n+1}}{2}\\right)$. For the test equation, this becomes:\n$$\ny_{n+1} = y_n + h \\lambda \\left(\\frac{y_n + y_{n+1}}{2}\\right)\n$$\nWe solve for $y_{n+1}$:\n$$\ny_{n+1} = y_n + \\frac{h\\lambda}{2} y_n + \\frac{h\\lambda}{2} y_{n+1} \\\\\ny_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right) \\\\\ny_{n+1} = \\frac{1 + h\\lambda/2}{1 - h\\lambda/2} y_n\n$$\nSubstituting $z = h\\lambda$, the amplification factor for the Implicit Midpoint method is:\n$$\nR_{IM}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n\n**2. A-Stability Verification**\n\nA method is A-stable if its region of absolute stability, $S = \\{ z \\in \\mathbb{C} : \\lvert R(z) \\rvert \\leq 1 \\}$, contains the entire left half-plane, $\\{ z \\in \\mathbb{C} : \\operatorname{Re}(z) \\leq 0 \\}$. This property is crucial for stiff problems, as it allows the time step $h$ to be chosen based on the desired accuracy for the slow modes, without being constrained by the stability of the rapidly decaying fast modes.\n\nWe are asked to verify this property on a finite set of points on the negative real axis. The test points are $z = h\\lambda$ for $\\lambda \\in \\{-1, -10, -100\\}$ and $h \\in \\{0.1, 0.01, 1.0\\}$. For all these values, $z$ is real and non-positive, so $\\operatorname{Re}(z) \\leq 0$.\n\n- For BE, $R_{BE}(z) = \\frac{1}{1-z}$. For any $z \\leq 0$, we have $1-z \\geq 1$, so $\\lvert R_{BE}(z) \\rvert = \\frac{1}{1-z} \\leq 1$. The condition holds.\n- For IM, $R_{IM}(z) = \\frac{1+z/2}{1-z/2}$. For any $z \\leq 0$, let $z = -x$ where $x \\geq 0$. Then $R_{IM}(-x) = \\frac{1-x/2}{1+x/2}$. The magnitude is $\\lvert R_{IM}(-x) \\rvert = \\left\\lvert \\frac{1-x/2}{1+x/2} \\right\\rvert$. Since $x \\geq 0$, it is clear that $\\lvert 1 - x/2 \\rvert \\leq 1 + x/2$, and thus $\\lvert R_{IM}(z) \\rvert \\leq 1$. The condition also holds.\n\nThe program will confirm this for all specified sample points, so we expect both methods to pass this test.\n\n**3. L-Stability Verification**\n\nL-stability is a stronger condition than A-stability. It requires that a method is A-stable and additionally that its amplification factor satisfies $\\lim_{\\operatorname{Re}(z) \\to -\\infty} \\lvert R(z) \\rvert = 0$. This property is highly desirable for stiff systems because it ensures that very fast, transient components (corresponding to large negative $\\operatorname{Re}(\\lambda)$) are heavily damped by the numerical method, rather than persisting as oscillations.\n\nWe check this property numerically at a single large negative real value, $z = -10^6$, against a tolerance of $10^{-3}$.\n\n- For BE:\n$$\nR_{BE}(-10^6) = \\frac{1}{1 - (-10^6)} = \\frac{1}{1000001} \\approx 10^{-6}\n$$\nSince $10^{-6} \\leq 10^{-3}$, the Backward Euler method passes the L-stability check.\n\n- For IM:\n$$\nR_{IM}(-10^6) = \\frac{1 + (-10^6)/2}{1 - (-10^6)/2} = \\frac{1 - 500000}{1 + 500000} = \\frac{-499999}{500001} \\approx -0.999996\n$$\nThe magnitude $\\lvert R_{IM}(-10^6) \\rvert \\approx 0.999996$, which is not less than or equal to $10^{-3}$. The Implicit Midpoint method is not L-stable, a well-known result. It is A-stable but does not damp stiff components at infinity.\n\n**4. Fast Mode Amplification Error**\n\nThis task quantifies the accuracy of each method in capturing the decay of the fast mode of the stiff system, specified by $\\lambda_f = -1000$. The exact amplification factor over a single time step $h$ is $e^{h \\lambda_f}$. The numerical amplification is $R(h \\lambda_f)$. We compute the maximum absolute relative error over the step sizes $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$. The error is defined as:\n$$\n\\text{Error} = \\frac{\\lvert R(h \\lambda_f) - e^{h \\lambda_f} \\rvert}{\\lvert e^{h \\lambda_f} \\rvert}\n$$\nThe values of $z = h \\lambda_f$ for the three step sizes are $z = -1$, $z = -0.5$, and $z = -0.1$. The program will compute the error for both methods at these three points and report the maximum. The Implicit Midpoint method is a second-order method, while Backward Euler is first-order. We generally expect IM to be more accurate for smaller values of $\\lvert z \\rvert$.\n\nThe implementation will define functions for $R_{BE}(z)$ and $R_{IM}(z)$, then systematically perform the calculations for each of the three verification tasks to produce the six required output values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the stability and accuracy of Backward Euler\n    and Implicit Midpoint methods for stiff ODEs.\n    \"\"\"\n\n    # 1. Define Amplification Factors\n    def r_be(z: complex) -> complex:\n        \"\"\"Amplification factor for Backward Euler.\"\"\"\n        return 1.0 / (1.0 - z)\n\n    def r_im(z: complex) -> complex:\n        \"\"\"Amplification factor for Implicit Midpoint.\"\"\"\n        return (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n    # Test cases from the problem statement\n    a_stability_lambdas = [-1.0, -10.0, -100.0]\n    a_stability_hs = [0.1, 0.01, 1.0]\n    l_stability_z = -1e6\n    l_stability_tol = 1e-3\n    stiff_system_lambda_f = -1000.0\n    stiff_system_hs = [1e-3, 5e-4, 1e-4]\n\n    results = []\n\n    # 2. Verify A-stability on sampled points\n    be_a_stable_checks = []\n    im_a_stable_checks = []\n    for lam in a_stability_lambdas:\n        for h in a_stability_hs:\n            z = h * lam\n            be_a_stable_checks.append(np.abs(r_be(z)) <= 1.0)\n            im_a_stable_checks.append(np.abs(r_im(z)) <= 1.0)\n    \n    # The result is True if all individual checks are True\n    be_is_a_stable = all(be_a_stable_checks)\n    im_is_a_stable = all(im_a_stable_checks)\n    results.extend([be_is_a_stable, im_is_a_stable])\n\n    # 3. Verify L-stability check\n    be_is_l_stable = np.abs(r_be(l_stability_z)) <= l_stability_tol\n    im_is_l_stable = np.abs(r_im(l_stability_z)) <= l_stability_tol\n    results.extend([be_is_l_stable, im_is_l_stable])\n\n    # 4. Quantify fast mode amplification error\n    be_rel_errors = []\n    im_rel_errors = []\n    for h in stiff_system_hs:\n        z = h * stiff_system_lambda_f\n        exact_amp = np.exp(z)\n        \n        # Backward Euler error\n        be_amp = r_be(z)\n        be_rel_err = np.abs(be_amp - exact_amp) / np.abs(exact_amp)\n        be_rel_errors.append(be_rel_err)\n        \n        # Implicit Midpoint error\n        im_amp = r_im(z)\n        im_rel_err = np.abs(im_amp - exact_amp) / np.abs(exact_amp)\n        im_rel_errors.append(im_rel_err)\n\n    max_rel_error_be = max(be_rel_errors)\n    max_rel_error_im = max(im_rel_errors)\n    results.extend([max_rel_error_be, max_rel_error_im])\n\n    # Format output as a comma-separated list of values in square brackets\n    output_str = f\"[{','.join(map(lambda x: str(x).lower() if isinstance(x, bool) else str(x), results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Many multiscale problems feature dynamics that can be split into stiff and non-stiff parts, for which Implicit-Explicit (IMEX) methods are a powerful tool. The stability of these schemes depends on the interplay between the implicit and explicit treatments, defined by a joint stability region. This advanced practice guides you through the process of deriving and implementing the stability analysis for IMEX schemes, providing direct experience with the behavior of these sophisticated methods under various stiffness scenarios .",
            "id": "3808578",
            "problem": "Consider the scalar linear multiscale test equation for a state variable $y(t)$,\n$$\n\\frac{dy}{dt} = A\\,y(t) + B\\,y(t),\n$$\nwhere $A$ represents the stiff component and $B$ represents the nonstiff component. Let the time-step be $h > 0$, and define the nondimensional parameters $z = hA$ and $w = hB$. An Implicit-Explicit (IMEX) method integrates $A\\,y(t)$ implicitly and $B\\,y(t)$ explicitly. Stability in the sense of absolute stability for a one-step method applied to this scalar linear problem is determined by whether the one-step amplification factor $R(z,w)$ satisfies $|R(z,w)| \\leq 1$.\n\nYour task is to construct a benchmark with tunable stiffness splitting and evaluate stability empirically against the theoretical joint stability region in $(hA,hB)$ for two IMEX schemes:\n\n- IMEX Euler (also called Forward-Backward Euler), defined by the one-step update that treats $A$ implicitly and $B$ explicitly.\n- A two-stage, second-order IMEX Runge–Kutta scheme ARS($2,2,2$) (Ascher–Ruuth–Spiteri), specified by its Butcher coefficients as follows. Let $\\gamma = 1 - 1/\\sqrt{2}$. The explicit tableau (for $B$) is\n$$\nA^{\\text{exp}} = \\begin{bmatrix}\n0 & 0 \\\\\n\\gamma & 0\n\\end{bmatrix},\\quad\nb^{\\text{exp}} = \\begin{bmatrix}\n1 - \\gamma \\\\\n\\gamma\n\\end{bmatrix},\\quad\nc^{\\text{exp}} = \\begin{bmatrix}\n0 \\\\\n\\gamma\n\\end{bmatrix},\n$$\nand the implicit tableau (for $A$) is\n$$\nA^{\\text{imp}} = \\begin{bmatrix}\n\\gamma & 0 \\\\\n1 - \\gamma & \\gamma\n\\end{bmatrix},\\quad\nb^{\\text{imp}} = \\begin{bmatrix}\n1 - \\gamma \\\\\n\\gamma\n\\end{bmatrix},\\quad\nc^{\\text{imp}} = \\begin{bmatrix}\n\\gamma \\\\\n1\n\\end{bmatrix}.\n$$\n\nStarting from the fundamental base that the numerical update for a linear problem produces a linear mapping $y^{n+1} = R(z,w)\\,y^n$ at each step, where $R(z,w)$ depends on the method’s coefficients and the values of $z$ and $w$, and that absolute stability requires $|R(z,w)| \\leq 1$, do the following:\n\n- For IMEX Euler, derive the one-step amplification factor $R(z,w)$ for the scalar test equation from first principles of implicit-explicit time-stepping and the definition of the method.\n- For ARS($2,2,2$), express the stage equations for the scalar case and derive a computable formula for $y^{n+1}$ in terms of $y^n$, $z$, and $w$ by successively solving the stage updates using the given Butcher coefficients. You must rely only on the definitions of Runge–Kutta update formulas and linearity of $A\\,y$ and $B\\,y$.\n\nEmpirical stability evaluation is defined by iterating the numerical scheme for $N$ steps starting from $y^0 = 1$ and declaring stability if the magnitude does not grow, i.e., if $|y^N| \\le |y^0| + \\varepsilon$, where $\\varepsilon$ is a small tolerance. The theoretical classification is $|R(z,w)| \\le 1$.\n\nImplement a program that, for each specified test case, computes:\n\n- The theoretical classification of stability ($\\text{True}$ if $|R(z,w)| \\le 1$, otherwise $\\text{False}$).\n- The empirical classification of stability from $N$ steps.\n- A boolean indicating if the empirical classification matches the theoretical classification.\n\nTunable stiffness splitting is controlled by a parameter $\\alpha \\in [0,1]$ with\n$$\nA = \\alpha \\,\\Lambda,\\quad B = (1-\\alpha)\\,\\Lambda,\n$$\nwhere $\\Lambda$ is a base rate that may be real or complex. When a test case directly specifies $A$ and $B$, ignore $\\alpha$.\n\nScientific realism requires that stiffness corresponds to $A$ with large negative real part and that nonstiff dynamics may include moderate real parts or oscillatory parts (purely imaginary $B$). The angle unit for any complex arguments is radians by mathematical convention; however, your outputs will be booleans or real-valued magnitudes with no unit.\n\nUse the following test suite that covers a range of behaviors including happy path stability, boundary conditions, stiffness dominance, nonstiff dominance, and oscillatory nonstiff dynamics. For each case, $h$ is the time-step, $N$ is the number of steps, and $\\varepsilon$ is the tolerance for empirical stability:\n\n- Case $1$: scheme = IMEX Euler, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.001$, $N = 20$, $\\varepsilon = 10^{-8}$.\n- Case $2$: scheme = IMEX Euler, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.004$, $N = 20$, $\\varepsilon = 10^{-8}$.\n- Case $3$: scheme = IMEX Euler, $A = -1000$, $B = 2000$, $h = 0.005$, $N = 5$, $\\varepsilon = 10^{-8}$.\n- Case $4$: scheme = IMEX Euler, $A = -500$, $B = 500$, $h = 0.001$, $N = 1$, $\\varepsilon = 10^{-12}$.\n- Case $5$: scheme = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$.\n- Case $6$: scheme = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.1$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$.\n- Case $7$: scheme = ARS($2,2,2$), $A = -1000$, $B = 500i$, $h = 0.002$, $N = 50$, $\\varepsilon = 10^{-6}$.\n- Case $8$: scheme = ARS($2,2,2$), $A = -1$, $B = 1000$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"), where each result is a boolean stating whether the empirical classification matches the theoretical classification for the corresponding test case, in the same order as listed.\n\nAll mathematical quantities in this problem are unitless. No percentage signs are permitted; all comparisons are boolean. Answers must be computed using the specified numerical schemes and the scalar linear model; do not use any precomputed stability regions or shortcut formulas beyond the derivations from the numerical method definitions.",
            "solution": "We begin with the scalar linear test equation\n$$\n\\frac{dy}{dt} = A\\,y(t) + B\\,y(t),\n$$\nwith constant coefficients $A$ and $B$, and the time-step $h$. We define nondimensional parameters $z = hA$ and $w = hB$. For a one-step method applied to this linear equation, the update generically becomes\n$$\ny^{n+1} = R(z,w)\\,y^n,\n$$\nwhere $R(z,w)$ is the method’s amplification factor. Absolute stability is defined by the condition $|R(z,w)| \\le 1$. To empirically assess stability, we iterate the numerical scheme $N$ steps from $y^0 = 1$ and declare stability if $|y^N| \\le |y^0| + \\varepsilon$, for a small tolerance $\\varepsilon$.\n\nWe must analyze two IMEX schemes: IMEX Euler and the two-stage ARS($2,2,2$).\n\n$1.$ IMEX Euler. The IMEX Euler method treats the stiff term $A\\,y$ implicitly (Backward Euler) and the nonstiff term $B\\,y$ explicitly (Forward Euler), resulting in\n$$\ny^{n+1} = y^n + h\\,B\\,y^n + h\\,A\\,y^{n+1}.\n$$\nRearranging, we obtain\n$$\n(1 - hA)\\,y^{n+1} = (1 + hB)\\,y^n.\n$$\nTherefore, the amplification factor for IMEX Euler is\n$$\nR_{\\text{IE}}(z,w) = \\frac{1 + w}{1 - z}.\n$$\nAbsolute stability is $|R_{\\text{IE}}(z,w)| \\le 1$.\n\n$2.$ ARS($2,2,2$) IMEX Runge–Kutta scheme. The IMEX Runge–Kutta method updates via stages. Denote the stage values by $Y_1$ and $Y_2$. With $A^{\\text{exp}}$ and $A^{\\text{imp}}$ the explicit and implicit coefficient matrices, and with $b^{\\text{exp}}$ and $b^{\\text{imp}}$ the weights, the stage equations for the scalar linear case $f_A(y) = A\\,y$ and $f_B(y) = B\\,y$ are\n$$\nY_i = y^n + h\\,\\sum_{j=1}^{i-1} a^{\\text{exp}}_{ij}\\,B\\,Y_j + h\\,\\sum_{j=1}^{i} a^{\\text{imp}}_{ij}\\,A\\,Y_j,\\quad i=1,2.\n$$\nBecause $a^{\\text{imp}}_{ii}$ is nonzero (diagonally implicit), we solve for each $Y_i$:\n$$\n\\left(1 - h\\,a^{\\text{imp}}_{ii}\\,A\\right) Y_i = y^n + h\\,\\sum_{j=1}^{i-1} a^{\\text{exp}}_{ij}\\,B\\,Y_j + h\\,\\sum_{j=1}^{i-1} a^{\\text{imp}}_{ij}\\,A\\,Y_j.\n$$\nLet $\\gamma = 1 - 1/\\sqrt{2}$. For ARS($2,2,2$), we have\n$$\nA^{\\text{exp}} = \\begin{bmatrix}\n0 & 0 \\\\\n\\gamma & 0\n\\end{bmatrix},\\quad\nA^{\\text{imp}} = \\begin{bmatrix}\n\\gamma & 0 \\\\\n1 - \\gamma & \\gamma\n\\end{bmatrix}.\n$$\nStage $1$:\n$$\n(1 - h\\gamma A)\\,Y_1 = y^n \\quad\\Rightarrow\\quad Y_1 = \\frac{1}{1 - \\gamma z}\\,y^n.\n$$\nStage $2$ uses $a^{\\text{exp}}_{21} = \\gamma$ and $a^{\\text{imp}}_{21} = 1 - \\gamma$:\n$$\n(1 - h\\gamma A)\\,Y_2 = y^n + h\\gamma B\\,Y_1 + h(1 - \\gamma)A\\,Y_1\n\\quad\\Rightarrow\\quad\nY_2 = \\frac{y^n + (\\gamma w + (1-\\gamma) z)\\,Y_1}{1 - \\gamma z}.\n$$\nThe final update is\n$$\ny^{n+1} = y^n + h\\left( b^{\\text{exp}}_1\\,B\\,Y_1 + b^{\\text{exp}}_2\\,B\\,Y_2 + b^{\\text{imp}}_1\\,A\\,Y_1 + b^{\\text{imp}}_2\\,A\\,Y_2 \\right),\n$$\nwith $b^{\\text{exp}} = [1 - \\gamma,\\ \\gamma]^\\top$ and $b^{\\text{imp}} = [1 - \\gamma,\\ \\gamma]^\\top$. Using $z = hA$ and $w = hB$, this simplifies to\n$$\ny^{n+1} = y^n + (1 - \\gamma)(w + z)\\,Y_1 + \\gamma (w + z)\\,Y_2.\n$$\nHence the amplification factor can be computed as\n$$\nR_{\\text{ARS}}(z,w) = \\frac{y^{n+1}}{y^n}\n= 1 + (1 - \\gamma)(w + z)\\,\\frac{1}{1 - \\gamma z} + \\gamma (w + z)\\,\\frac{1 + (\\gamma w + (1-\\gamma) z)\\,\\frac{1}{1 - \\gamma z}}{1 - \\gamma z}.\n$$\nAlthough this expression can be further reduced to a rational function of $z$ and $w$, the essential derivation is the stage-wise solution, using only Runge–Kutta definitions and linearity. For numerical evaluation, it is sufficient and robust to compute $Y_1$ and $Y_2$ and then $y^{n+1}$ explicitly as above.\n\n$3.$ Empirical stability evaluation. For a fixed $(z,w)$, each step of either method multiplies $y^n$ by $R(z,w)$, so\n$$\ny^N = R(z,w)^N\\,y^0,\n$$\nwith $y^0 = 1$. We classify empirical stability by checking if $|y^N| \\le |y^0| + \\varepsilon$. The theoretical classification is $|R(z,w)| \\le 1$.\n\n$4.$ Tunable stiffness splitting. For tests that specify a base rate $\\Lambda$ and splitting parameter $\\alpha \\in [0,1]$, we set\n$$\nA = \\alpha \\Lambda,\\quad B = (1-\\alpha)\\Lambda,\n$$\nso that $A$ carries most stiffness when $\\alpha$ is close to $1$, while $B$ carries more when $\\alpha$ is close to $0$. When $A$ and $B$ are given directly, we use them as-is.\n\n$5.$ Test suite and expected outputs. The test cases supply the scheme, parameters to compute $z$ and $w$, the number of steps $N$, and tolerance $\\varepsilon$. For each, we compute the theoretical classification via $|R(z,w)| \\le 1$, and the empirical classification via iteration for $N$ steps. The program outputs a single line containing the list of booleans indicating whether these two classifications match for each case, in the given order:\n- Case $1$: scheme = IMEX Euler, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.001$, $N = 20$, $\\varepsilon = 10^{-8}$.\n- Case $2$: scheme = IMEX Euler, $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.004$, $N = 20$, $\\varepsilon = 10^{-8}$.\n- Case $3$: scheme = IMEX Euler, $A = -1000$, $B = 2000$, $h = 0.005$, $N = 5$, $\\varepsilon = 10^{-8}$.\n- Case $4$: scheme = IMEX Euler, $A = -500$, $B = 500$, $h = 0.001$, $N = 1$, $\\varepsilon = 10^{-12}$.\n- Case $5$: scheme = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.9$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$.\n- Case $6$: scheme = ARS($2,2,2$), $\\Lambda = -1000$, $\\alpha = 0.1$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$.\n- Case $7$: scheme = ARS($2,2,2$), $A = -1000$, $B = 500i$, $h = 0.002$, $N = 50$, $\\varepsilon = 10^{-6}$.\n- Case $8$: scheme = ARS($2,2,2$), $A = -1$, $B = 1000$, $h = 0.01$, $N = 10$, $\\varepsilon = 10^{-8}$.\n\n$6.$ Algorithmic design:\n- Compute $z$ and $w$ from the given parameters. If a base rate $\\Lambda$ and splitting parameter $\\alpha$ are given, set $A = \\alpha \\Lambda$ and $B = (1 - \\alpha)\\Lambda$. Otherwise, use supplied $A$ and $B$. Then $z = hA$ and $w = hB$.\n- For IMEX Euler, compute $R_{\\text{IE}}(z,w) = (1+w)/(1-z)$.\n- For ARS($2,2,2$), compute $Y_1 = y^n/(1 - \\gamma z)$, $Y_2 = \\big(y^n + (\\gamma w + (1-\\gamma) z)\\,Y_1\\big)/(1 - \\gamma z)$, and then $y^{n+1} = y^n + (1 - \\gamma)(w + z)\\,Y_1 + \\gamma (w + z)\\,Y_2$; set $R_{\\text{ARS}}(z,w) = y^{n+1}/y^n$.\n- Theoretical classification is $|R(z,w)| \\le 1$.\n- Empirical classification is obtained by iterating $y^{n+1} = R(z,w)\\,y^n$ for $N$ steps starting from $y^0 = 1$ and then checking $|y^N| \\le 1 + \\varepsilon$.\n- Output the list of booleans indicating whether empirical and theoretical classifications agree, in the single-line format specified.\n\nThis procedure strictly uses the definitions of IMEX Euler and IMEX Runge–Kutta updates and the linearity of the test equation, without relying on shortcut formulas beyond what is derived from first principles.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef R_imex_euler(z, w):\n    \"\"\"\n    Amplification factor for IMEX (Forward-Backward) Euler:\n    R = (1 + w) / (1 - z)\n    Supports complex z, w.\n    \"\"\"\n    return (1 + w) / (1 - z)\n\ndef R_ars222(z, w):\n    \"\"\"\n    Amplification factor for ARS(2,2,2) IMEX RK scheme for scalar test equation.\n    Uses stage-by-stage computation:\n      Y1 = y^n / (1 - gamma*z)\n      Y2 = (y^n + (gamma*w + (1-gamma)*z)*Y1) / (1 - gamma*z)\n      y^{n+1} = y^n + (1-gamma)*(w+z)*Y1 + gamma*(w+z)*Y2\n    Then R = y^{n+1} / y^n.\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    denom = (1 - gamma * z)\n    # Guard against exact singularity; in practice, this indicates instability or step too large.\n    if denom == 0:\n        return np.inf\n    y_n = 1.0 + 0j  # arbitrary normalization for amplification factor\n    Y1 = y_n / denom\n    Y2 = (y_n + (gamma * w + (1 - gamma) * z) * Y1) / denom\n    y_np1 = y_n + (1 - gamma) * (w + z) * Y1 + gamma * (w + z) * Y2\n    R = y_np1 / y_n\n    return R\n\ndef empirical_classification(R, N, eps):\n    \"\"\"\n    Empirical stability: iterate y_{n+1} = R * y_n for N steps from y0=1.\n    Stable if |y_N| <= 1 + eps.\n    \"\"\"\n    # Fast path: y_N = R**N since linear amplification per step is constant\n    yN = (R ** N) * (1.0 + 0j)\n    return np.abs(yN) <= (1.0 + eps)\n\ndef theoretical_classification(R):\n    \"\"\"\n    Theoretical stability classification: |R| <= 1.\n    \"\"\"\n    if R == np.inf or (isinstance(R, complex) and (np.isinf(R.real) or np.isinf(R.imag))):\n        return False\n    return np.abs(R) <= 1.0\n\ndef compute_R(scheme, z, w):\n    if scheme == \"euler\":\n        return R_imex_euler(z, w)\n    elif scheme == \"ars222\":\n        return R_ars222(z, w)\n    else:\n        raise ValueError(\"Unknown scheme\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict; we compute A,B either from (Lambda, alpha) or directly if provided.\n    test_cases = [\n        # Case 1\n        {\"scheme\": \"euler\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.001, \"N\": 20, \"eps\": 1e-8},\n        # Case 2\n        {\"scheme\": \"euler\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.004, \"N\": 20, \"eps\": 1e-8},\n        # Case 3\n        {\"scheme\": \"euler\", \"A\": -1000.0, \"B\": 2000.0, \"h\": 0.005, \"N\": 5, \"eps\": 1e-8},\n        # Case 4 (borderline)\n        {\"scheme\": \"euler\", \"A\": -500.0, \"B\": 500.0, \"h\": 0.001, \"N\": 1, \"eps\": 1e-12},\n        # Case 5\n        {\"scheme\": \"ars222\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n        # Case 6\n        {\"scheme\": \"ars222\", \"Lambda\": -1000.0, \"alpha\": 0.1, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n        # Case 7 (oscillatory B)\n        {\"scheme\": \"ars222\", \"A\": -1000.0, \"B\": 500.0j, \"h\": 0.002, \"N\": 50, \"eps\": 1e-6},\n        # Case 8 (nonstiff dominance potentially unstable)\n        {\"scheme\": \"ars222\", \"A\": -1.0, \"B\": 1000.0, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme = case[\"scheme\"]\n        h = case[\"h\"]\n        N = case[\"N\"]\n        eps = case[\"eps\"]\n\n        # Determine A and B\n        if \"A\" in case and \"B\" in case:\n            A = case[\"A\"]\n            B = case[\"B\"]\n        elif \"Lambda\" in case and \"alpha\" in case:\n            Lambda = case[\"Lambda\"]\n            alpha = case[\"alpha\"]\n            A = alpha * Lambda\n            B = (1.0 - alpha) * Lambda\n        else:\n            raise ValueError(\"Test case missing parameters for A/B or Lambda/alpha.\")\n\n        # Compute nondimensional parameters\n        z = h * A\n        w = h * B\n\n        # Compute amplification factor and classifications\n        R = compute_R(scheme, z, w)\n        theo = theoretical_classification(R)\n        emp = empirical_classification(R, N, eps)\n\n        # Record whether empirical matches theoretical classification\n        results.append(bool(emp == theo))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x).lower() if isinstance(x, bool) else str(x), results))}]\")\n\nsolve()\n```"
        }
    ]
}