{
    "hands_on_practices": [
        {
            "introduction": "A-稳定性和L-稳定性等抽象概念，在看到它们的实际效果时会变得清晰。第一个练习邀请您实现两种基本的隐式方法——后向欧拉法和隐式中点法，并使用一个简单的刚性基准问题来数值验证它们的稳定性。通过编码，您将直接观察到L-稳定性如何为高度刚性的模式提供卓越的阻尼，这是可靠的多尺度模拟的关键特性 。",
            "id": "3808603",
            "problem": "考虑线性时不变常微分方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $y(t) \\in \\mathbb{C}$。该标量线性测试方程是评估时间积分方法数值稳定性的典型基础。在多尺度建模和分析中，当系统具有衰减率相差悬殊的模态时，就会出现刚性问题。一个能体现此特性的简单刚性基准是对角 $2 \\times 2$ 系统 $Y'(t) = A Y(t)$，其中\n$$\nA = \\begin{pmatrix} \\lambda_s  0 \\\\ 0  \\lambda_f \\end{pmatrix}, \\quad \\lambda_s = -1, \\quad \\lambda_f = -1000,\n$$\n以及初始条件 $Y(0) = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。其精确解为 $Y(t) = \\begin{pmatrix} e^{\\lambda_s t} \\\\ e^{\\lambda_f t} \\end{pmatrix}$。慢模态由 $\\lambda_s$ 控制，快模态由 $\\lambda_f$ 控制。\n\n待评估的两种候选单步方法如下：\n\n- 后向欧拉法 (Backward Euler)，定义为 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$。\n- 隐式中点法 (Implicit Midpoint)，定义为 $y_{n+1} = y_n + h f\\!\\left(t_n + \\frac{h}{2}, \\frac{y_n + y_{n+1}}{2}\\right)$。\n\n将这两种方法应用于标量线性测试方程 $y' = \\lambda y$ 以及上述对角系统。对于标量情况，离散更新的形式为 $y_{n+1} = R(z) y_n$，其中 $z = h \\lambda$，$R(z)$ 是方法的放大因子（也称为稳定性函数）。绝对稳定性（A-稳定性）要求对于所有 $\\operatorname{Re}(z) \\leq 0$ 的 $z$，都有 $\\lvert R(z) \\rvert \\leq 1$。被称为 L-稳定性的属性要求在 A-稳定性的基础上，并且沿负实轴有 $\\lim_{z \\to -\\infty} R(z) = 0$，这确保了极快模态的快速衰减。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n\n1. 对每种方法，针对标量线性测试方程 $y' = \\lambda y$ 推导、实现并使用其放大因子 $R(z)$。\n2. 通过在采样点 $z = h \\lambda$（其中 $h$ 和 $\\lambda$ 从下面列出的集合中选取）检查条件 $\\lvert R(z) \\rvert \\leq 1$，来验证每种方法在有限测试集上的绝对稳定性（A-稳定性）。\n3. 通过测试对于一个非常大的负实数 $z$，$\\lvert R(z) \\rvert$ 是否足够小，来验证 L-稳定性属性。\n4. 通过比较数值放大因子 $\\lvert R(h \\lambda_f) \\rvert$ 与精确的单步放大因子 $\\lvert e^{h \\lambda_f} \\rvert$，量化每种方法在单个时间步长内对刚性对角系统的快模态的放大作用，并报告在指定步长下的最大绝对相对误差。\n\n使用以下测试集：\n\n- 对于 A-稳定性采样，使用 $\\lambda \\in \\{-1,-10,-100\\}$ 和 $h \\in \\{0.1, 0.01, 1.0\\}$，从而在负实轴上得到测试点 $z = h \\lambda$。\n- 对于 L-稳定性采样，使用 $z = -10^6$。\n- 对于刚性对角系统中的快模态误差，使用 $\\lambda_f = -1000$ 和 $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$。\n\n您的程序必须按此确切顺序和类型计算并输出以下六个量：\n\n- 一个布尔值，指示后向欧拉法在采样点上是否是 A-稳定的。\n- 一个布尔值，指示隐式中点法在采样点上是否是 A-稳定的。\n- 一个布尔值，指示后向欧拉法在 $z = -10^6$ 处是否满足 L-稳定性检查（在 $10^{-3}$ 的容差内），即 $\\lvert R(z) \\rvert \\leq 10^{-3}$ 是否成立。\n- 一个布尔值，指示隐式中点法在 $z = -10^6$ 处是否满足相同的 L-稳定性检查。\n- 一个浮点数，等于后向欧拉法在 $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$ 范围内对快模态放大的最大绝对相对误差，其中相对误差为 $\\frac{\\lvert R(h \\lambda_f) - e^{h \\lambda_f} \\rvert}{\\lvert e^{h \\lambda_f} \\rvert}$。\n- 一个浮点数，等于隐式中点法对应的最大绝对相对误差。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$）。不涉及物理单位，所有值都是无量纲的。最终输出必须是指定的基本类型：布尔值和浮点数，其中浮点数以十进制形式表示。",
            "solution": "所述问题是有效的。这是一个适定的、具有科学依据的常微分方程数值分析练习，专门探讨了稳定性和刚性这两个对多尺度建模至关重要的概念。所有必需的参数和定义都已提供，没有内部矛盾，并且任务可以使用既定原则直接解决。\n\n解决方案分四个主要步骤进行，与问题陈述中列出的任务一致：\n1. 推导后向欧拉法 (Backward Euler) 和隐式中点法 (Implicit Midpoint) 的放大因子。\n2. 根据提供的测试集对两种方法的 A-稳定性进行数值验证。\n3. 对 L-稳定性属性进行数值验证。\n4. 量化每种方法在放大给定刚性系统的快模态时的准确性。\n\n**1. 放大因子的推导**\n\n我们通过将数值方法应用于标量线性测试方程 $y'(t) = \\lambda y(t)$（其中 $\\lambda \\in \\mathbb{C}$ 且 $\\operatorname{Re}(\\lambda) \\leq 0$）来分析其稳定性。一步之后的数值解 $y_{n+1}$ 可以用前一步的解 $y_n$ 表示为 $y_{n+1} = R(z) y_n$，其中 $z = h\\lambda$，$R(z)$ 是放大因子，也称为稳定性函数。$R(z)$ 的性质决定了方法的稳定性。\n\n- **后向欧拉法 (BE):**\n后向欧拉法定义为 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$。对于我们的测试方程，$f(t,y) = \\lambda y$，因此方程变为：\n$$\ny_{n+1} = y_n + h (\\lambda y_{n+1})\n$$\n我们求解 $y_{n+1}$：\n$$\ny_{n+1} - h \\lambda y_{n+1} = y_n \\\\\ny_{n+1} (1 - h\\lambda) = y_n \\\\\ny_{n+1} = \\frac{1}{1 - h\\lambda} y_n\n$$\n代入 $z = h\\lambda$，后向欧拉法的放大因子为：\n$$\nR_{BE}(z) = \\frac{1}{1-z}\n$$\n\n- **隐式中点法 (IM):**\n隐式中点法定义为 $y_{n+1} = y_n + h f\\left(t_n + \\frac{h}{2}, \\frac{y_n + y_{n+1}}{2}\\right)$。对于测试方程，这变为：\n$$\ny_{n+1} = y_n + h \\lambda \\left(\\frac{y_n + y_{n+1}}{2}\\right)\n$$\n我们求解 $y_{n+1}$：\n$$\ny_{n+1} = y_n + \\frac{h\\lambda}{2} y_n + \\frac{h\\lambda}{2} y_{n+1} \\\\\ny_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right) \\\\\ny_{n+1} = \\frac{1 + h\\lambda/2}{1 - h\\lambda/2} y_n\n$$\n代入 $z = h\\lambda$，隐式中点法的放大因子为：\n$$\nR_{IM}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n\n**2. A-稳定性验证**\n\n如果一个方法的绝对稳定区域 $S = \\{ z \\in \\mathbb{C} : \\lvert R(z) \\rvert \\leq 1 \\}$ 包含整个左半复平面 $\\{ z \\in \\mathbb{C} : \\operatorname{Re}(z) \\leq 0 \\}$，则该方法是 A-稳定的。此性质对刚性问题至关重要，因为它允许根据慢模态所需的精度来选择时间步长 $h$，而不受快速衰减的快模态稳定性的限制。\n\n我们被要求在负实轴上的一个有限点集上验证此属性。测试点为 $z = h\\lambda$，其中 $\\lambda \\in \\{-1, -10, -100\\}$ 且 $h \\in \\{0.1, 0.01, 1.0\\}$。对于所有这些值，$z$ 都是实数且非正，因此 $\\operatorname{Re}(z) \\leq 0$。\n\n- 对于 BE，$R_{BE}(z) = \\frac{1}{1-z}$。对于任何 $z \\leq 0$，我们有 $1-z \\geq 1$，因此 $\\lvert R_{BE}(z) \\rvert = \\frac{1}{1-z} \\leq 1$。条件成立。\n- 对于 IM，$R_{IM}(z) = \\frac{1+z/2}{1-z/2}$。对于任何 $z \\leq 0$，令 $z = -x$，其中 $x \\geq 0$。则 $R_{IM}(-x) = \\frac{1-x/2}{1+x/2}$。其模为 $\\lvert R_{IM}(-x) \\rvert = \\left\\lvert \\frac{1-x/2}{1+x/2} \\right\\rvert$。由于 $x \\geq 0$，显然有 $\\lvert 1 - x/2 \\rvert \\leq 1 + x/2$，因此 $\\lvert R_{IM}(z) \\rvert \\leq 1$。条件也成立。\n\n程序将对所有指定的采样点确认这一点，因此我们预计两种方法都将通过此测试。\n\n**3. L-稳定性验证**\n\nL-稳定性是比 A-稳定性更强的条件。它要求一个方法是 A-稳定的，并且其放大因子还需满足 $\\lim_{\\operatorname{Re}(z) \\to -\\infty} \\lvert R(z) \\rvert = 0$。此性质对于刚性系统非常理想，因为它能确保非常快速的瞬态分量（对应于大的负 $\\operatorname{Re}(\\lambda)$）被数值方法强烈阻尼，而不是以振荡形式持续存在。\n\n我们在一个大的负实数值 $z = -10^6$ 处，以 $10^{-3}$ 的容差对此属性进行数值检查。\n\n- 对于 BE：\n$$\nR_{BE}(-10^6) = \\frac{1}{1 - (-10^6)} = \\frac{1}{1000001} \\approx 10^{-6}\n$$\n由于 $10^{-6} \\leq 10^{-3}$，后向欧拉法通过了 L-稳定性检查。\n\n- 对于 IM：\n$$\nR_{IM}(-10^6) = \\frac{1 + (-10^6)/2}{1 - (-10^6)/2} = \\frac{1 - 500000}{1 + 500000} = \\frac{-499999}{500001} \\approx -0.999996\n$$\n其模 $\\lvert R_{IM}(-10^6) \\rvert \\approx 0.999996$，不小于或等于 $10^{-3}$。隐式中点法不是 L-稳定的，这是一个众所周知的结果。它是 A-稳定的，但不能在无穷远处阻尼刚性分量。\n\n**4. 快模态放大误差**\n\n此任务量化了每种方法在捕捉由 $\\lambda_f = -1000$ 指定的刚性系统快模态衰减方面的准确性。在单个时间步长 $h$ 内的精确放大因子是 $e^{h \\lambda_f}$。数值放大因子是 $R(h \\lambda_f)$。我们计算在步长 $h \\in \\{10^{-3}, 5 \\cdot 10^{-4}, 10^{-4}\\}$ 下的最大绝对相对误差。误差定义为：\n$$\n\\text{Error} = \\frac{\\lvert R(h \\lambda_f) - e^{h \\lambda_f} \\rvert}{\\lvert e^{h \\lambda_f} \\rvert}\n$$\n对于三种步长，$z = h \\lambda_f$ 的值分别为 $z = -1$，$z = -0.5$ 和 $z = -0.1$。程序将计算这两种方法在这三个点上的误差，并报告最大值。隐式中点法是二阶方法，而后向欧拉法是一阶方法。我们通常期望对于较小的 $\\lvert z \\rvert$ 值，IM 会更准确。\n\n实现将为 $R_{BE}(z)$ 和 $R_{IM}(z)$ 定义函数，然后系统地为三个验证任务中的每一个执行计算，以生成六个所需的输出值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the stability and accuracy of Backward Euler\n    and Implicit Midpoint methods for stiff ODEs.\n    \"\"\"\n\n    # 1. Define Amplification Factors\n    def r_be(z: complex) - complex:\n        \"\"\"Amplification factor for Backward Euler.\"\"\"\n        return 1.0 / (1.0 - z)\n\n    def r_im(z: complex) - complex:\n        \"\"\"Amplification factor for Implicit Midpoint.\"\"\"\n        return (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n    # Test cases from the problem statement\n    a_stability_lambdas = [-1.0, -10.0, -100.0]\n    a_stability_hs = [0.1, 0.01, 1.0]\n    l_stability_z = -1e6\n    l_stability_tol = 1e-3\n    stiff_system_lambda_f = -1000.0\n    stiff_system_hs = [1e-3, 5e-4, 1e-4]\n\n    results = []\n\n    # 2. Verify A-stability on sampled points\n    be_a_stable_checks = []\n    im_a_stable_checks = []\n    for lam in a_stability_lambdas:\n        for h in a_stability_hs:\n            z = h * lam\n            be_a_stable_checks.append(np.abs(r_be(z)) = 1.0)\n            im_a_stable_checks.append(np.abs(r_im(z)) = 1.0)\n    \n    # The result is True if all individual checks are True\n    be_is_a_stable = all(be_a_stable_checks)\n    im_is_a_stable = all(im_a_stable_checks)\n    results.extend([be_is_a_stable, im_is_a_stable])\n\n    # 3. Verify L-stability check\n    be_is_l_stable = np.abs(r_be(l_stability_z)) = l_stability_tol\n    im_is_l_stable = np.abs(r_im(l_stability_z)) = l_stability_tol\n    results.extend([be_is_l_stable, im_is_l_stable])\n\n    # 4. Quantify fast mode amplification error\n    be_rel_errors = []\n    im_rel_errors = []\n    for h in stiff_system_hs:\n        z = h * stiff_system_lambda_f\n        exact_amp = np.exp(z)\n        \n        # Backward Euler error\n        be_amp = r_be(z)\n        be_rel_err = np.abs(be_amp - exact_amp) / np.abs(exact_amp)\n        be_rel_errors.append(be_rel_err)\n        \n        # Implicit Midpoint error\n        im_amp = r_im(z)\n        im_rel_err = np.abs(im_amp - exact_amp) / np.abs(exact_amp)\n        im_rel_errors.append(im_rel_err)\n\n    max_rel_error_be = max(be_rel_errors)\n    max_rel_error_im = max(im_rel_errors)\n    results.extend([max_rel_error_be, max_rel_error_im])\n\n    # Format output as a comma-separated list of values in square brackets\n    # Booleans are converted to lowercase 'true'/'false' by str()\n    # Floats are in standard decimal form\n    output_str = f\"[{','.join(str(r).lower() if isinstance(r, bool) else str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在观察到L-稳定性的实际好处之后，我们现在转向其数学基础。本练习挑战您从一个方法的有理稳定性函数出发，推导出一个方法变得L-稳定所需满足的精确条件。通过分析一个假设的方法族，您将把代数约束 $\\lim_{|z|\\to\\infty} R(z) = 0$ 与阻尼高频数值模式的物理需求联系起来，从而巩固您对方法设计如何直接影响刚性系统性能的理解 。",
            "id": "3808530",
            "problem": "考虑线性测试问题 $u'(t) = \\lambda u(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是一个复刚性参数，以及一个其稳定性函数为有理函数的单步时间积分器。时间步长为 $h  0$，无量纲刚度为 $z = h \\lambda$。傅里叶模式的离散传播由 $u_{n+1} = R(z) u_{n}$ 控制，其中 $R$ 是稳定性函数。如果对于所有 $z \\in S$，都有 $|R(z)| \\leq 1$，则称该方法在集合 $S \\subset \\mathbb{C}$ 上是绝对稳定的。如果对于所有满足 $\\Re(z) \\leq 0$ 的 $z$，都有 $|R(z)| \\leq 1$，则称该方法是 $A$-稳定的（在左半复平面上绝对稳定）。如果一个方法是 $A$-稳定的，并且还满足 $\\lim_{|z|\\to\\infty} R(z) = 0$，则称该方法是 $L$-稳定的。\n\n在刚性系统的多尺度建模和分析中，半离散偏微分方程（例如，由离散化的扩散或反应算子产生）中的高频模式对应于具有较大负实部的特征值 $\\lambda$，而时间积分器对这些模式的数值阻尼由 $R(z)$ 在 $|z| \\to \\infty$ 时的极限来量化。\n\n考虑具有稳定性函数\n$$\nR(z;a) = \\frac{1 + a z}{1 - z},\n$$\n的单参数隐式单步方法族，其中 $a \\in \\mathbb{R}$ 是一个可调参数，通过对隐式更新进行相容的代数修正引入。从上述定义出发，除了 $R$ 的有理函数性质外不作任何特殊假设，推导使该方法为 $L$-稳定的关于 $a$ 的条件。然后，对于一个半离散线性扩散算子，其特征值满足 $\\lambda_{k} = -\\nu k^{2}$（其中 $\\nu  0$，波数 $k \\in \\mathbb{R}$），根据这些条件解释高频模式的数值阻尼。在你的推导中，将 $R(z;a)$ 在 $|z| \\to \\infty$ 时的行为与时间推进过程中对高频分量（大 $|k|$）的抑制联系起来。\n\n你的最终任务是确定使 $R(z;a)$ 成为 $L$-稳定的唯一实数值 $a$。请将你的答案表示为单个实数，无需四舍五入。",
            "solution": "问题要求我们求出参数 $a$ 的唯一实数值，使得具有稳定性函数 $R(z;a) = \\frac{1 + a z}{1 - z}$ 的单步方法是 $L$-稳定的。\n\n根据所给定义，一个方法是 $L$-稳定的，如果它满足两个条件：\n1. 它是 $A$-稳定的，即对于所有实部非正的复数 $z$（$\\Re(z) \\leq 0$），都有 $|R(z;a)| \\leq 1$。\n2. 稳定性函数在无穷远处消失，即 $\\lim_{|z|\\to\\infty} R(z;a) = 0$。\n\n我们将分析这两个条件来约束 $a \\in \\mathbb{R}$ 的值。\n\n首先，我们来研究极限条件，因为它在代数上更简单。稳定性函数是 $z$ 的一个有理函数：\n$$\nR(z;a) = \\frac{1 + a z}{1 - z}\n$$\n为了计算 $|z| \\to \\infty$ 时的极限，我们可以将分子和分母同时除以 $z$：\n$$\nR(z;a) = \\frac{\\frac{1}{z} + a}{\\frac{1}{z} - 1}\n$$\n当 $|z| \\to \\infty$ 时，项 $\\frac{1}{z}$ 趋近于 $0$。因此，极限为：\n$$\n\\lim_{|z|\\to\\infty} R(z;a) = \\lim_{|z|\\to\\infty} \\frac{\\frac{1}{z} + a}{\\frac{1}{z} - 1} = \\frac{0+a}{0-1} = -a\n$$\n$L$-稳定的第二个条件要求这个极限为零。\n$$\n-a = 0\n$$\n这意味着可能使方法成为 $L$-稳定的唯一 $a$ 值是 $a=0$。\n\n现在，我们必须验证当 $a=0$ 这个特定值时，该方法是否是 $A$-稳定的。如果是，那么 $a=0$ 就是使该方法成为 $L$-稳定的唯一值。如果当 $a=0$ 时它不是 $A$-稳定的，那么没有任何 $a$ 值可以满足 $L$-稳定性的标准。\n\n对于 $a=0$，稳定性函数变为：\n$$\nR(z;0) = \\frac{1 + (0)z}{1 - z} = \\frac{1}{1 - z}\n$$\n这是一阶隐式向后欧拉法的稳定性函数。为了检查 $A$-稳定性，我们必须验证对于所有满足 $\\Re(z) \\leq 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z;0)| \\leq 1$。\n\n令 $z = x + iy$，其中 $x = \\Re(z)$ 且 $y = \\Im(z)$。条件 $\\Re(z) \\leq 0$ 意味着 $x \\leq 0$。我们计算 $R(z;0)$ 的模的平方：\n$$\n|R(z;0)|^2 = \\left| \\frac{1}{1 - (x+iy)} \\right|^2 = \\left| \\frac{1}{(1-x) - iy} \\right|^2\n$$\n复数 $\\alpha + i\\beta$ 的模的平方是 $\\alpha^2 + \\beta^2$。因此，\n$$\n|R(z;0)|^2 = \\frac{1^2}{(1-x)^2 + (-y)^2} = \\frac{1}{(1-x)^2 + y^2}\n$$\n$A$-稳定性条件 $|R(z;0)| \\leq 1$ 等价于 $|R(z;0)|^2 \\leq 1^2 = 1$。\n$$\n\\frac{1}{(1-x)^2 + y^2} \\leq 1\n$$\n由于分母 $(1-x)^2 + y^2$ 总是非负的（并且非零，因为 $z=1$ 不在左半平面），我们可以用它乘以不等式两边：\n$$\n1 \\leq (1-x)^2 + y^2\n$$\n我们必须检查这个不等式是否对所有 $x \\leq 0$ 和 $y \\in \\mathbb{R}$ 成立。\n给定 $x \\leq 0$，可得 $-x \\geq 0$，两边同时加 $1$ 得到 $1-x \\geq 1$。\n将其平方，我们得到 $(1-x)^2 \\geq 1^2 = 1$。\n由于对于任何实数 $y$，$y^2$ 总是非负的，我们有 $y^2 \\geq 0$。\n将这两个不等式相加，我们得到：\n$$\n(1-x)^2 + y^2 \\geq 1 + 0 = 1\n$$\n这证实了不等式 $1 \\leq (1-x)^2 + y^2$ 对所有 $\\Re(z) \\leq 0$ 的 $z$ 都成立。因此，当 $a=0$ 时，该方法确实是 $A$-稳定的。\n\n由于该方法在 $a=0$ 时是 $A$-稳定的，并且满足 $\\lim_{|z|\\to\\infty} R(z;0) = 0$，根据定义，它是 $L$-稳定的。由于我们已经证明极限条件仅在 $a=0$ 时满足，所以这个值是唯一的。\n\n在多尺度建模的背景下，其解释如下。在由扩散算子产生的半离散系统中，特征值的形式为 $\\lambda_k = -\\nu k^2$，其中 $\\nu  0$，k为波数。高频模式对应于大的 $|k|$ 值。这种模式的无量纲刚度是 $z_k = h\\lambda_k = -h \\nu k^2$。随着频率（波数 $|k|$）的增加，$z_k$ 变成一个模很大的负实数，即 $z_k \\to -\\infty$。\n刚性时间积分器的目的不仅是对这些模式保持稳定（$A$-稳定性保证了这一点，因为 $|R(z_k)| \\leq 1$），而且还要有效地将它们阻尼掉，因为它们通常代表由空间离散化产生的非物理高频振荡。一个模式在一个时间步长后的放大因子是 $|R(z_k)|$。理想的阻尼对应于放大因子为 $0$。$L$-稳定性条件 $\\lim_{|z|\\to\\infty} R(z) = 0$ 恰好保证了这种行为：对于解的最高频（最刚性）的分量，放大因子趋近于零。在我们的例子中，$\\lim_{|z|\\to\\infty} R(z;a) = -a$。设置 $a=0$ 确保了当 $|k| \\to \\infty$ 时 $|R(z_k)| \\to 0$，从而导致这些刚性模式被快速抑制，这在多尺度模拟中是一个非常理想的属性。任何非零的 $a$ 值都意味着无限刚性的模式将被一个因子 $|-a|=|a|$ 阻尼，而不是在一个步长内被消除。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "许多现实世界的多尺度问题同时包含刚性和非刚性部分，这使得完全隐式方法效率低下。隐式-显式（IMEX）格式通过对每个部分进行适当处理，提供了一种强大的替代方案。在本练习中，您将通过推导两种不同格式的联合放大因子并编写程序来绘制它们的稳定域，从而探索IMEX方法的稳定性，为您提供关于这一重要现代数值技术的实践经验 。",
            "id": "3808578",
            "problem": "考虑状态变量 $y(t)$ 的标量线性多尺度测试方程\n$$\n\\frac{dy}{dt} = A\\,y(t) + B\\,y(t),\n$$\n其中 $A$ 代表刚性分量，$B$ 代表非刚性分量。设时间步长为 $h  0$，并定义无量纲参数 $z = hA$ 和 $w = hB$。隐式-显式（IMEX）方法对 $A\\,y(t)$ 进行隐式积分，对 $B\\,y(t)$ 进行显式积分。对于应用于此标量线性问题的单步法，其绝对稳定性意义上的稳定性取决于单步放大因子 $R(z,w)$ 是否满足 $|R(z,w)| \\leq 1$。\n\n您的任务是构建一个具有可调刚度分裂的基准测试，并针对两种 IMEX 格式，根据理论联合稳定域 $(hA,hB)$ 对稳定性进行经验性评估：\n\n- IMEX 欧拉法（也称为前向-后向欧拉法），由隐式处理 $A$ 和显式处理 $B$ 的单步更新定义。\n- 一个两阶段、二阶的 IMEX 龙格-库塔格式 ARS($2,2,2$) (Ascher–Ruuth–Spiteri)，其布卓系数规定如下。设 $\\gamma = 1 - 1/\\sqrt{2}$。显式表（用于 $B$）为\n$$\nA^{\\text{exp}} = \\begin{bmatrix}\n0  0 \\\\\n\\gamma  0\n\\end{bmatrix},\\quad\nb^{\\text{exp}} = \\begin{bmatrix}\n1 - \\gamma \\\\\n\\gamma\n\\end{bmatrix},\\quad\nc^{\\text{exp}} = \\begin{bmatrix}\n0 \\\\\n\\gamma\n\\end{bmatrix},\n$$\n隐式表（用于 $A$）为\n$$\nA^{\\text{imp}} = \\begin{bmatrix}\n\\gamma  0 \\\\\n1 - \\gamma  \\gamma\n\\end{bmatrix},\\quad\nb^{\\text{imp}} = \\begin{bmatrix}\n1 - \\gamma \\\\\n\\gamma\n\\end{bmatrix},\\quad\nc^{\\text{imp}} = \\begin{bmatrix}\n\\gamma \\\\\n1\n\\end{bmatrix}.\n$$\n\n从线性问题的数值更新在每一步产生线性映射 $y^{n+1} = R(z,w)\\,y^n$ 的基本前提出发，其中 $R(z,w)$ 取决于方法的系数以及 $z$ 和 $w$ 的值，并且绝对稳定性要求 $|R(z,w)| \\leq 1$，请完成以下任务：\n\n- 对于 IMEX 欧拉法，从隐式-显式时间步长的基本原理和该方法的定义出发，推导标量测试方程的单步放大因子 $R(z,w)$。\n- 对于 ARS($2,2,2$)，写出标量情况下的分段方程，并通过使用给定的布卓系数逐次求解分段更新，推导出一个用 $y^n$、$z$ 和 $w$ 表示 $y^{n+1}$ 的可计算公式。您必须仅依赖于龙格-库塔更新公式的定义以及 $A\\,y$ 和 $B\\,y$ 的线性性质。\n\n经验稳定性评估的定义是：从 $y^0 = 1$ 开始迭代数值格式 $N$ 步，如果幅值没有增长，即如果 $|y^N| \\le |y^0| + \\varepsilon$（其中 $\\varepsilon$ 是一个小的容差），则声明为稳定。理论分类是 $|R(z,w)| \\le 1$。\n\n实现一个程序，对每个指定的测试用例计算：\n\n- 稳定性的理论分类（如果 $|R(z,w)| \\le 1$ 则为 $\\text{True}$，否则为 $\\text{False}$）。\n- 从 $N$ 步得到的经验稳定性分类。\n- 一个布尔值，指示经验分类是否与理论分类匹配。\n\n可调刚度分裂由参数 $\\alpha \\in [0,1]$ 控制，其中\n$$\nA = \\alpha \\,\\Lambda,\\quad B = (1-\\alpha)\\,\\Lambda,\n$$\n其中 $\\Lambda$ 是一个可以是实数或复数的基础速率。当测试用例直接指定 $A$ 和 $B$ 时，忽略 $\\alpha$。\n\n科学真实性要求刚性对应于具有大的负实部的 $A$，而非刚性动力学可能包括中等大小的实部或振荡部分（纯虚数 $B$）。根据数学惯例，任何复数参数的角度单位是弧度；然而，您的输出将是布尔值或实数值的幅值，没有单位。\n\n使用以下测试套件，它涵盖了包括理想路径稳定性、边界条件、刚性主导、非刚性主导和振荡性非刚性动力学在内的一系列行为。对于每个案例，$h$ 是时间步长，$N$ 是步数，$\\varepsilon$ 是经验稳定性的容差：\n\n- 案例 1：格式 = IMEX 欧拉法，$\\Lambda = -1000$，$\\alpha = 0.9$，$h = 0.001$，$N = 20$，$\\varepsilon = 10^{-8}$。\n- 案例 2：格式 = IMEX 欧拉法，$\\Lambda = -1000$，$\\alpha = 0.9$，$h = 0.004$，$N = 20$，$\\varepsilon = 10^{-8}$。\n- 案例 3：格式 = IMEX 欧拉法，$A = -1000$，$B = 2000$，$h = 0.005$，$N = 5$，$\\varepsilon = 10^{-8}$。\n- 案例 4：格式 = IMEX 欧拉法，$A = -500$，$B = 500$，$h = 0.001$，$N = 1$，$\\varepsilon = 10^{-12}$。\n- 案例 5：格式 = ARS($2,2,2$)，$\\Lambda = -1000$，$\\alpha = 0.9$，$h = 0.01$，$N = 10$，$\\varepsilon = 10^{-8}$。\n- 案例 6：格式 = ARS($2,2,2$)，$\\Lambda = -1000$，$\\alpha = 0.1$，$h = 0.01$，$N = 10$，$\\varepsilon = 10^{-8}$。\n- 案例 7：格式 = ARS($2,2,2$)，$A = -1000$，$B = 500\\,\\mathrm{i}$，$h = 0.002$，$N = 50$，$\\varepsilon = 10^{-6}$。\n- 案例 8：格式 = ARS($2,2,2$)，$A = -1$，$B = 1000$，$h = 0.01$，$N = 10$，$\\varepsilon = 10^{-8}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”），其中每个结果是一个布尔值，说明相应测试用例的经验分类是否与理论分类匹配，顺序与列表中的顺序相同。\n\n此问题中的所有数学量均无单位。不允许使用百分号；所有比较都是布尔比较。答案必须使用指定的数值格式和标量线性模型计算；除了从数值方法定义推导出的公式外，不要使用任何预先计算的稳定域或简化公式。",
            "solution": "我们从标量线性测试方程开始\n$$\n\\frac{dy}{dt} = A\\,y(t) + B\\,y(t),\n$$\n其中 $A$ 和 $B$ 为常系数，时间步长为 $h$。我们定义无量纲参数 $z = hA$ 和 $w = hB$。对于应用于此线性方程的单步法，更新通常变为\n$$\ny^{n+1} = R(z,w)\\,y^n,\n$$\n其中 $R(z,w)$ 是该方法的放大因子。绝对稳定性由条件 $|R(z,w)| \\le 1$ 定义。为了经验性地评估稳定性，我们从 $y^0 = 1$ 开始迭代数值格式 $N$ 步，如果 $|y^N| \\le |y^0| + \\varepsilon$，则声明为稳定，其中 $\\varepsilon$ 是一个小的容差。\n\n我们必须分析两种 IMEX 格式：IMEX 欧拉法和两阶段的 ARS($2,2,2$)。\n\n$1.$ IMEX 欧拉法。IMEX 欧拉法隐式地处理刚性项 $A\\,y$（后向欧拉法），显式地处理非刚性项 $B\\,y$（前向欧拉法），得到\n$$\ny^{n+1} = y^n + h\\,B\\,y^n + h\\,A\\,y^{n+1}.\n$$\n整理后，我们得到\n$$\n(1 - hA)\\,y^{n+1} = (1 + hB)\\,y^n.\n$$\n因此，IMEX 欧拉法的放大因子是\n$$\nR_{\\text{IE}}(z,w) = \\frac{1 + w}{1 - z}.\n$$\n绝对稳定性要求 $|R_{\\text{IE}}(z,w)| \\le 1$。\n\n$2.$ ARS($2,2,2$) IMEX 龙格-库塔格式。IMEX 龙格-库塔方法通过分段进行更新。用 $Y_1$ 和 $Y_2$ 表示分段值。设 $A^{\\text{exp}}$ 和 $A^{\\text{imp}}$ 分别为显式和隐式系数矩阵，$b^{\\text{exp}}$ 和 $b^{\\text{imp}}$ 为权重，则对于标量线性情况 $f_A(y) = A\\,y$ 和 $f_B(y) = B\\,y$ 的分段方程为\n$$\nY_i = y^n + h\\,\\sum_{j=1}^{i-1} a^{\\text{exp}}_{ij}\\,B\\,Y_j + h\\,\\sum_{j=1}^{i} a^{\\text{imp}}_{ij}\\,A\\,Y_j,\\quad i=1,2.\n$$\n因为 $a^{\\text{imp}}_{ii}$ 非零（对角隐式），我们对每个 $Y_i$ 求解：\n$$\n\\left(1 - h\\,a^{\\text{imp}}_{ii}\\,A\\right) Y_i = y^n + h\\,\\sum_{j=1}^{i-1} a^{\\text{exp}}_{ij}\\,B\\,Y_j + h\\,\\sum_{j=1}^{i-1} a^{\\text{imp}}_{ij}\\,A\\,Y_j.\n$$\n设 $\\gamma = 1 - 1/\\sqrt{2}$。对于 ARS($2,2,2$)，我们有\n$$\nA^{\\text{exp}} = \\begin{bmatrix}\n0  0 \\\\\n\\gamma  0\n\\end{bmatrix},\\quad\nA^{\\text{imp}} = \\begin{bmatrix}\n\\gamma  0 \\\\\n1 - \\gamma  \\gamma\n\\end{bmatrix}.\n$$\n阶段 1：\n$$\n(1 - h\\gamma A)\\,Y_1 = y^n \\quad\\Rightarrow\\quad Y_1 = \\frac{1}{1 - \\gamma z}\\,y^n.\n$$\n阶段 2 使用 $a^{\\text{exp}}_{21} = \\gamma$ 和 $a^{\\text{imp}}_{21} = 1 - \\gamma$：\n$$\n(1 - h\\gamma A)\\,Y_2 = y^n + h\\gamma B\\,Y_1 + h(1 - \\gamma)A\\,Y_1\n\\quad\\Rightarrow\\quad\nY_2 = \\frac{y^n + (\\gamma w + (1-\\gamma) z)\\,Y_1}{1 - \\gamma z}.\n$$\n最终更新为\n$$\ny^{n+1} = y^n + h\\left( b^{\\text{exp}}_1\\,B\\,Y_1 + b^{\\text{exp}}_2\\,B\\,Y_2 + b^{\\text{imp}}_1\\,A\\,Y_1 + b^{\\text{imp}}_2\\,A\\,Y_2 \\right),\n$$\n其中 $b^{\\text{exp}} = [1 - \\gamma,\\ \\gamma]^\\top$ 和 $b^{\\text{imp}} = [1 - \\gamma,\\ \\gamma]^\\top$。使用 $z = hA$ 和 $w = hB$，这可以简化为\n$$\ny^{n+1} = y^n + (1 - \\gamma)(w + z)\\,Y_1 + \\gamma (w + z)\\,Y_2.\n$$\n因此，放大因子可以计算为\n$$\nR_{\\text{ARS}}(z,w) = \\frac{y^{n+1}}{y^n}\n= 1 + (1 - \\gamma)(w + z)\\,\\frac{1}{1 - \\gamma z} + \\gamma (w + z)\\,\\frac{1 + (\\gamma w + (1-\\gamma) z)\\,\\frac{1}{1 - \\gamma z}}{1 - \\gamma z}.\n$$\n尽管这个表达式可以进一步简化为 $z$ 和 $w$ 的有理函数，但核心的推导是分步求解过程，仅使用龙格-库塔定义和线性性质。对于数值计算，显式地计算 $Y_1$ 和 $Y_2$ 然后再计算 $y^{n+1}$ 是足够且稳健的。\n\n$3.$ 经验稳定性评估。对于固定的 $(z,w)$，任一方法的每一步都将 $y^n$ 乘以 $R(z,w)$，所以\n$$\ny^N = R(z,w)^N\\,y^0,\n$$\n其中 $y^0 = 1$。我们通过检查 $|y^N| \\le 1 + \\varepsilon$ 来进行经验稳定性分类。理论分类是 $|R(z,w)| \\le 1$。\n\n$4.$ 可调刚度分裂。对于指定基础速率 $\\Lambda$ 和分裂参数 $\\alpha \\in [0,1]$ 的测试，我们设置\n$$\nA = \\alpha \\Lambda,\\quad B = (1-\\alpha)\\Lambda,\n$$\n这样，当 $\\alpha$ 接近 1 时，$A$ 承载大部分刚性，而当 $\\alpha$ 接近 0 时，$B$ 承载更多。当 $A$ 和 $B$ 直接给出时，我们按原样使用它们。\n\n$5.$ 测试套件和预期输出。测试用例提供了格式、用于计算 $z$ 和 $w$ 的参数、步数 $N$ 以及容差 $\\varepsilon$。对每一个用例，我们通过 $|R(z,w)| \\le 1$ 计算理论分类，并通过迭代 $N$ 步进行经验分类。程序输出单行，其中包含一个布尔值列表，指示每个用例的这两种分类是否匹配，顺序与给定顺序相同：\n- 案例 1：格式 = IMEX 欧拉法，$\\Lambda = -1000$，$\\alpha = 0.9$，$h = 0.001$，$N = 20$，$\\varepsilon = 10^{-8}$。\n- 案例 2：格式 = IMEX 欧拉法，$\\Lambda = -1000$，$\\alpha = 0.9$，$h = 0.004$，$N = 20$，$\\varepsilon = 10^{-8}$。\n- 案例 3：格式 = IMEX 欧拉法，$A = -1000$，$B = 2000$，$h = 0.005$，$N = 5$，$\\varepsilon = 10^{-8}$。\n- 案例 4：格式 = IMEX 欧拉法，$A = -500$，$B = 500$，$h = 0.001$，$N = 1$，$\\varepsilon = 10^{-12}$。\n- 案例 5：格式 = ARS($2,2,2$)，$\\Lambda = -1000$，$\\alpha = 0.9$，$h = 0.01$，$N = 10$，$\\varepsilon = 10^{-8}$。\n- 案例 6：格式 = ARS($2,2,2$)，$\\Lambda = -1000$，$\\alpha = 0.1$，$h = 0.01$，$N = 10$，$\\varepsilon = 10^{-8}$。\n- 案例 7：格式 = ARS($2,2,2$)，$A = -1000$，$B = 500\\,\\mathrm{i}$，$h = 0.002$，$N = 50$，$\\varepsilon = 10^{-6}$。\n- 案例 8：格式 = ARS($2,2,2$)，$A = -1$，$B = 1000$，$h = 0.01$，$N = 10$，$\\varepsilon = 10^{-8}$。\n\n$6.$ 算法设计：\n- 根据给定参数计算 $z$ 和 $w$。如果给定了基础速率 $\\Lambda$ 和分裂参数 $\\alpha$，则设置 $A = \\alpha \\Lambda$ 和 $B = (1 - \\alpha)\\Lambda$。否则，使用提供的 $A$ 和 $B$。然后 $z = hA$ 和 $w = hB$。\n- 对于 IMEX 欧拉法，计算 $R_{\\text{IE}}(z,w) = (1+w)/(1-z)$。\n- 对于 ARS($2,2,2$)，计算 $Y_1 = y^n/(1 - \\gamma z)$，$Y_2 = \\big(y^n + (\\gamma w + (1-\\gamma) z)\\,Y_1\\big)/(1 - \\gamma z)$，然后 $y^{n+1} = y^n + (1 - \\gamma)(w + z)\\,Y_1 + \\gamma (w + z)\\,Y_2$；设置 $R_{\\text{ARS}}(z,w) = y^{n+1}/y^n$。\n- 理论分类是 $|R(z,w)| \\le 1$。\n- 经验分类通过从 $y^0 = 1$ 开始迭代 $y^{n+1} = R(z,w)\\,y^n$ 共 $N$ 步，然后检查 $|y^N| \\le 1 + \\varepsilon$ 获得。\n- 按指定的单行格式输出指示经验分类和理论分类是否一致的布尔值列表。\n\n此过程严格使用 IMEX 欧拉法和 IMEX 龙格-库塔更新的定义以及测试方程的线性性质，不依赖于从基本原理推导之外的任何简化公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef R_imex_euler(z, w):\n    \"\"\"\n    Amplification factor for IMEX (Forward-Backward) Euler:\n    R = (1 + w) / (1 - z)\n    Supports complex z, w.\n    \"\"\"\n    return (1 + w) / (1 - z)\n\ndef R_ars222(z, w):\n    \"\"\"\n    Amplification factor for ARS(2,2,2) IMEX RK scheme for scalar test equation.\n    Uses stage-by-stage computation:\n      Y1 = y^n / (1 - gamma*z)\n      Y2 = (y^n + (gamma*w + (1-gamma)*z)*Y1) / (1 - gamma*z)\n      y^{n+1} = y^n + (1-gamma)*(w+z)*Y1 + gamma*(w+z)*Y2\n    Then R = y^{n+1} / y^n.\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    denom = (1 - gamma * z)\n    # Guard against exact singularity; in practice, this indicates instability or step too large.\n    if denom == 0:\n        return np.inf\n    y_n = 1.0 + 0j  # arbitrary normalization for amplification factor\n    Y1 = y_n / denom\n    Y2 = (y_n + (gamma * w + (1 - gamma) * z) * Y1) / denom\n    y_np1 = y_n + (1 - gamma) * (w + z) * Y1 + gamma * (w + z) * Y2\n    R = y_np1 / y_n\n    return R\n\ndef empirical_classification(R, N, eps):\n    \"\"\"\n    Empirical stability: iterate y_{n+1} = R * y_n for N steps from y0=1.\n    Stable if |y_N| = 1 + eps.\n    \"\"\"\n    # Fast path: y_N = R**N since linear amplification per step is constant\n    yN = (R ** N) * (1.0 + 0j)\n    return np.abs(yN) = (1.0 + eps)\n\ndef theoretical_classification(R):\n    \"\"\"\n    Theoretical stability classification: |R| = 1.\n    \"\"\"\n    if R == np.inf or (isinstance(R, complex) and (np.isinf(R.real) or np.isinf(R.imag))):\n        return False\n    return np.abs(R) = 1.0\n\ndef compute_R(scheme, z, w):\n    if scheme == \"euler\":\n        return R_imex_euler(z, w)\n    elif scheme == \"ars222\":\n        return R_ars222(z, w)\n    else:\n        raise ValueError(\"Unknown scheme\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict; we compute A,B either from (Lambda, alpha) or directly if provided.\n    test_cases = [\n        # Case 1\n        {\"scheme\": \"euler\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.001, \"N\": 20, \"eps\": 1e-8},\n        # Case 2\n        {\"scheme\": \"euler\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.004, \"N\": 20, \"eps\": 1e-8},\n        # Case 3\n        {\"scheme\": \"euler\", \"A\": -1000.0, \"B\": 2000.0, \"h\": 0.005, \"N\": 5, \"eps\": 1e-8},\n        # Case 4 (borderline)\n        {\"scheme\": \"euler\", \"A\": -500.0, \"B\": 500.0, \"h\": 0.001, \"N\": 1, \"eps\": 1e-12},\n        # Case 5\n        {\"scheme\": \"ars222\", \"Lambda\": -1000.0, \"alpha\": 0.9, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n        # Case 6\n        {\"scheme\": \"ars222\", \"Lambda\": -1000.0, \"alpha\": 0.1, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n        # Case 7 (oscillatory B)\n        {\"scheme\": \"ars222\", \"A\": -1000.0, \"B\": 500.0j, \"h\": 0.002, \"N\": 50, \"eps\": 1e-6},\n        # Case 8 (nonstiff dominance potentially unstable)\n        {\"scheme\": \"ars222\", \"A\": -1.0, \"B\": 1000.0, \"h\": 0.01, \"N\": 10, \"eps\": 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme = case[\"scheme\"]\n        h = case[\"h\"]\n        N = case[\"N\"]\n        eps = case[\"eps\"]\n\n        # Determine A and B\n        if \"A\" in case and \"B\" in case:\n            A = case[\"A\"]\n            B = case[\"B\"]\n        elif \"Lambda\" in case and \"alpha\" in case:\n            Lambda = case[\"Lambda\"]\n            alpha = case[\"alpha\"]\n            A = alpha * Lambda\n            B = (1.0 - alpha) * Lambda\n        else:\n            raise ValueError(\"Test case missing parameters for A/B or Lambda/alpha.\")\n\n        # Compute nondimensional parameters\n        z = h * A\n        w = h * B\n\n        # Compute amplification factor and classifications\n        R = compute_R(scheme, z, w)\n        theo = theoretical_classification(R)\n        emp = empirical_classification(R, N, eps)\n\n        # Record whether empirical matches theoretical classification\n        results.append(bool(emp == theo))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}