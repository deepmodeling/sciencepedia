{
    "hands_on_practices": [
        {
            "introduction": "单元刚度矩阵是有限元方法的核心构建块。这个练习将引导你完成一个基本但至关重要的过程：将形函数从一个简单的“参考”单元映射到实际网格中的“物理”单元。通过掌握此计算，包括梯度的雅可比变换，你将深刻理解离散方程组是如何从变分原理中构建出来的 。",
            "id": "3818783",
            "problem": "考虑在有界多边形域 $\\Omega \\subset \\mathbb{R}^{2}$ 中提出的二维空间标量扩散问题，其扩散张量 $A(x)$ 为对称正定。在标准 Galerkin 方法中，有限元法 (FEM) 在一个分片多项式子空间中求解 $u_{h}$，使得对于同一子空间中的所有测试函数 $v_{h}$，涉及 $\\nabla v$ 和 $\\nabla u$ 的双线性形式与载荷项相平衡。在多尺度建模背景下，假设在每个网格单元 $K$ 上，快速振荡的 $A(x)$ 被一个常数的、单元上的有效张量 $\\bar{A}_{K}$ 所取代，该张量通过局部化到 $K$ 的代表性体积元 (RVE) 程序计算得出。\n\n在一个顶点为 $x_{1}=(2,1)$、$x_{2}=(5,2)$ 和 $x_{3}=(3,4)$ 的三角形单元 $K$ 上，考虑通过仿射变换 $F(\\hat{x})=x_{1}+B\\hat{x}$ 将顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的参考三角形 $\\hat{K}=\\{(\\xi,\\eta): \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi+\\eta \\le 1\\}$ 映射到 $K$ 所获得的 $P_{1}$ (线性) 形函数，其中 $B$ 是由边向量构成的 $2\\times 2$ 矩阵。设 $\\hat{\\phi}_{1}$、$\\hat{\\phi}_{2}$、$\\hat{\\phi}_{3}$ 为在参考顶点上满足克罗内克 delta 性质的 $\\hat{K}$ 上的 $P_{1}$ 形函数，并设 $\\phi_{i}=\\hat{\\phi}_{i}\\circ F^{-1}$ 为 $K$ 上的相应形函数。\n\n假设在 $K$ 上，有效扩散张量为常数，由 $\\bar{A}_{K}=\\begin{pmatrix}2  1\\\\ 1  3\\end{pmatrix}$ 给出。从 Galerkin 方法的弱形式定义和 $\\hat{K}$ 上的 $P_{1}$ 形函数定义出发，完成以下任务：\n\n1. 对给定的 $K$，构建 $\\hat{K}$ 上的 $\\hat{\\phi}_{1}$、$\\hat{\\phi}_{2}$、$\\hat{\\phi}_{3}$ 以及仿射映射 $F$ 及其雅可比矩阵 $B$。\n2. 使用 $B$ 推导从 $\\nabla_{\\hat{x}}\\hat{\\phi}_{i}$ 到 $\\nabla_{x}\\phi_{i}$ 的梯度变换法则，并将单元刚度矩阵元 $K_{ij}^{(K)}$ 表示为在参考三角形 $\\hat{K}$ 上的积分。\n3. 对给定的 $K$ 和 $\\bar{A}_{K}$，精确计算该积分以获得特定矩阵元 $K_{12}^{(K)}$。\n\n给出 $K_{12}^{(K)}$ 的精确值作为最终答案，形式为单个实数。不要进行四舍五入。",
            "solution": "首先评估问题的有效性。提取所有给定信息，并分析其一致性、完整性和科学合理性。",
            "answer": "$$\\boxed{-\\frac{5}{8}}$$"
        },
        {
            "introduction": "虽然在简单情况下可以进行解析积分，但实际的有限元分析依赖于数值求积。求积规则的选择不仅关乎精度，更关乎稳定性。本练习通过一个计算实验，探讨了“积分不足”（即使用过少的求积点）如何导致单元无法捕捉某些变形模式，从而产生非物理的、零能量的“沙漏”不稳定性 。这个实践让你直观地理解一个关键的数值问题，并强调了选择合适积分方案的重要性，尤其是在处理弯曲或扭曲单元时。",
            "id": "3134563",
            "problem": "考虑使用伽辽金法求解单个二维等参四边形单元上的标量扩散算子。该边值问题的弱形式由一个双线性形式定义，该形式映射试探函数和检验函数：对于一个标量场 $u(x,y)$ 和检验函数 $v(x,y)$，单元刚度矩阵的项定义为积分\n$$\nK_{ij} \\;=\\; \\int_{\\Omega_e} a(x,y)\\,\\nabla N_i(x,y)\\cdot\\nabla N_j(x,y)\\,\\mathrm{d}\\Omega,\n$$\n其中 $a(x,y)$ 是一个给定的正标量扩散系数，$\\Omega_e$ 是单元的物理域，而 $N_i(x,y)$ 是单元形函数。假设整个单元内 $a(x,y)=1$。从具有局部坐标 $(\\xi,\\eta)$ 的参考正方形 $[-1,1]\\times[-1,1]$ 到物理单元 $(x(\\xi,\\eta),y(\\xi,\\eta))$ 的等参映射，是使用八节点 serendipity 形函数和相应的八个物理节点坐标来定义的。\n\n使用的基本原理：\n- 扩散问题的伽辽金法：刚度矩阵项由上述梯度内积的积分定义。\n- 等参有限元：几何与场近似共享相同的形函数；梯度通过映射的雅可比矩阵进行变换。具体来说，如果 $F(\\xi,\\eta)$ 是映射的雅可比矩阵，则 $\\nabla N_i(x,y) = F(\\xi,\\eta)^{-\\top}\\,\\nabla_{\\xi} N_i(\\xi,\\eta)$ 且 $\\mathrm{d}\\Omega = \\det F(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。\n- 参考域上的数值积分：在 $[-1,1]\\times[-1,1]$ 上的张量积高斯-勒让德法则通过在积分节点处计算被积函数值的加权和来近似积分。\n\n你的任务是构建一个弯曲的八节点 serendipity 四边形单元，并评估减缩积分对单元刚度矩阵稳定性的影响。使用以下几何规格。设角节点物理坐标为\n$$\n(0,0),\\quad(1,0),\\quad(1,1),\\quad(0,1),\n$$\n按逆时针顺序排列。设边中点节点的物理坐标由一个曲率参数 $s\\in[0,1)$ 和一个固定的向内偏移量 $\\delta=0.3$ 定义如下：\n- 底部边中点节点：$(0.5,\\; s\\,\\delta)$。\n- 右侧边中点节点：$(1 - s\\,\\delta,\\; 0.5)$。\n- 顶部边中点节点：$(0.5,\\; 1 - s\\,\\delta)$。\n- 左侧边中点节点：$(s\\,\\delta,\\; 0.5)$。\n当 $s$ 增大时，这种选择会产生一系列越来越尖缩的弯曲单元，同时对于足够小的 $s$ 值，映射的雅可比行列式保持为正。\n\n使用八节点 serendipity 形函数 $N_i(\\xi,\\eta)$ 及其参考梯度 $\\nabla_{\\xi} N_i(\\xi,\\eta)$ 来定义单元刚度矩阵 $K\\in\\mathbb{R}^{8\\times 8}$，并计算几何雅可比矩阵 $F(\\xi,\\eta)$ 及其行列式 $\\det F(\\xi,\\eta)$ 在积分节点处的值。通过使用 $q\\times q$ 阶的张量积高斯-勒让德积分对变换后的被积函数进行数值积分来组装 $K$。\n\n评估两种积分方案：\n- 减缩积分：单点高斯-勒让德积分，即每个方向 $q=1$（节点在 $0$，权重为 $2$）。\n- 精确积分：三点高斯-勒让德积分，即每个方向 $q=3$（节点在 $0$ 权重为 $8/9$，在 $\\pm\\sqrt{3/5}$ 权重为 $5/9$）。\n\n科学真实性要求：\n- 使用梯度的变换法则和行列式因子来确保积分具有物理意义。\n- 确保雅可比行列式在测试案例中保持为正（选择不会导致单元反转的 $s$ 值）。\n\n定量稳定性评估：\n- 对于每种积分方案和每个曲率 $s$，计算 $K$ 的特征值。当施加本质边界条件时，扩散算子的刚度矩阵在全局层面是对称正定(SPD)的，但在没有边界条件的单元层面，它是对称半正定(SPSD)的，并且至少有一个对应于常数模式的零特征值。减缩积分会引入额外的伪近零能量模式（沙漏不稳定性）。将近零模式定义为满足 $\\lambda \\le \\tau\\,\\lambda_{\\max}$ 的任何特征值 $\\lambda$，其中 $\\lambda_{\\max}$ 是 $K$ 的最大特征值，$\\tau=10^{-8}$。\n- 对于每个 $s$，测量减缩积分（$q=1$）和精确积分（$q=3$）之间近零模式数量的差异，即计算 $\\Delta n_{\\text{zero}}(s) = n_{\\text{zero}}^{(q=1)}(s) - n_{\\text{zero}}^{(q=3)}(s)$。\n\n测试套件：\n为以下三个曲率参数计算 $\\Delta n_{\\text{zero}}(s)$：\n- 案例 1：$s=0$（直边单元；基准）。\n- 案例 2：$s=0.3$（中等曲率）。\n- 案例 3：$s=0.44$（接近尖缩但无反转的强曲率）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：\n$$\n[\\Delta n_{\\text{zero}}(0),\\;\\Delta n_{\\text{zero}}(0.3),\\;\\Delta n_{\\text{zero}}(0.44)].\n$$\n每个条目必须是整数。不涉及角度，也不需要物理单位。所有计算都是无量纲的。",
            "solution": "该问题要求分析八节点 serendipity 四边形有限元的数值稳定性，具体是检验积分阶次对单元刚度矩阵特征值的影响。稳定性通过计算由减缩积分引起的伪零能模式（沙漏不稳定性）的数量来评估。\n\n### 基于原理的方法分解\n\n#### 1. 伽辽金法和单元刚度矩阵\n问题的基础是标量扩散问题的伽辽金法。单元刚度矩阵 $K \\in \\mathbb{R}^{8\\times 8}$ 表示试探函数 $u$ 和检验函数 $v$ 的节点值之间的离散关系。对于扩散系数 $a(x,y)$，其项 $K_{ij}$ 由双线性形式给出：\n$$\nK_{ij} = \\int_{\\Omega_e} a(x,y)\\,\\nabla N_i(x,y)\\cdot\\nabla N_j(x,y)\\,\\mathrm{d}\\Omega\n$$\n这里，$N_i$ 是形（或基）函数，$\\Omega_e$ 是单元的物理域，$\\nabla$ 是物理坐标 $(x,y)$ 中的梯度算子。问题指定了常数扩散系数 $a(x,y)=1$。\n\n#### 2. 等参映射\n单元的几何形状由从参考正方形域 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$到物理域 $(x, y) \\in \\Omega_e$ 的等参映射描述。“等参”一词表示用于插值解场的形函数同样用于定义几何形状：\n$$\nx(\\xi, \\eta) = \\sum_{k=1}^{8} N_k(\\xi, \\eta) x_k, \\quad y(\\xi, \\eta) = \\sum_{k=1}^{8} N_k(\\xi, \\eta) y_k\n$$\n其中 $(x_k, y_k)$ 是单元八个节点的物理坐标。此映射需要变换微分算子和积分测度。变换由映射的雅可比矩阵 $F(\\xi, \\eta)$ 控制：\n$$\nF = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\n物理梯度 $\\nabla N_i$ 与参考梯度 $\\nabla_{\\xi} N_i$ 的关系为：\n$$\n\\nabla N_i = F^{-\\top} \\nabla_{\\xi} N_i\n$$\n微分面积元变换为：\n$$\n\\mathrm{d}\\Omega = \\det(F) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n将这些代入刚度矩阵积分，得到一个在参考域上的积分：\n$$\nK_{ij} = \\int_{-1}^{1} \\int_{-1}^{1} \\left( (F^{-\\top} \\nabla_{\\xi} N_i) \\cdot (F^{-\\top} \\nabla_{\\xi} N_j) \\right) \\det(F) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n\n#### 3. 数值积分\n该积分使用 $q \\times q$ 张量积高斯-勒让德积分法则进行数值近似。积分被替换为在离散积分点集 $(\\xi_k, \\eta_l)$ 上以相应权重 $w_k, w_l$ 计算的被积函数值的加权和：\n$$\nK_{ij} \\approx \\sum_{k=1}^{q} \\sum_{l=1}^{q} w_k w_l \\left[ (F^{-\\top} \\nabla_{\\xi} N_i) \\cdot (F^{-\\top} \\nabla_{\\xi} N_j) \\right]_{(\\xi_k, \\eta_l)} \\det(F(\\xi_k, \\eta_l))\n$$\n评估了两种方案：\n- **减缩积分 ($q=1$)**：在 $(\\xi,\\eta)=(0,0)$ 处的一个点，权重为 $w_1 w_1 = 4$。这种方法计算成本低，但已知不精确，并且可能无法检测到某些变形模式，导致单元过于柔性。\n- **精确积分 ($q=3$)**：一个 $3 \\times 3$ 的 9 点网格。该方案可以精确积分最高 5 次的多项式，通常足以计算出此类型单元的稳定刚度矩阵，准确捕捉所有有效变形模式的能量。\n\n#### 4. 通过特征值进行稳定性分析\n对于没有边界条件的单元，其刚度矩阵 $K$ 是对称半正定(SPSD)的。它必须至少有一个零特征值，对应于常数场模式（在弹性中是刚体模式，对于扩散问题是常数值模式），因为常数场的梯度为零，因此应变能为零。\n当积分法则不足以“看到”与某些模式相关的变形时，**沙漏不稳定性**就会出现。这些非物理的、零能量的模式表现为 $K$ 中额外的零（或近零）特征值。\n通过计数有效为零的特征值 $\\lambda$ 的数量来定量评估稳定性，其定义条件为 $\\lambda \\le \\tau \\lambda_{\\max}$，其中 $\\lambda_{\\max}$ 是最大特征值，$\\tau=10^{-8}$ 是一个小容差。\n最终的度量指标 $\\Delta n_{\\text{zero}}(s) = n_{\\text{zero}}^{(q=1)}(s) - n_{\\text{zero}}^{(q=3)}(s)$，用于衡量对于曲率参数为 $s$ 的单元，由减缩积分引入的伪模式数量。\n\n#### 5. 实现策略\n对于每个测试案例 $s$，算法按以下步骤进行：\n1.  根据 $s$ 和固定偏移量 $\\delta=0.3$ 定义八个节点的物理坐标。\n2.  对于每种积分方案（$q=1$ 和 $q=3$）：\n    a. 为 $K$ 初始化一个 $8 \\times 8$ 的零矩阵。\n    b. 遍历所有积分点 $(\\xi_k, \\eta_l)$ 和权重 $w_k w_l$。\n    c. 在每个点上，计算所有 $i=1,\\dots,8$ 的参考梯度 $\\nabla_{\\xi} N_i$。\n    d. 计算雅可比矩阵 $F$ 及其行列式 $\\det(F)$。\n    e. 计算物理梯度 $\\nabla N_i = F^{-\\top} \\nabla_{\\xi} N_i$。\n    f. 形成内积矩阵 $(\\nabla N_i \\cdot \\nabla N_j)$，并将其乘以 $\\det(F)$ 和积分权重的贡献加到 $K$ 中。\n3.  对于每个生成的矩阵 $K^{(q)}$，计算其特征值。\n4.  使用指定的阈值，计数近零特征值的数量 $n_{\\text{zero}}^{(q)}$。\n5.  计算并存储差异 $\\Delta n_{\\text{zero}}$。\n\n此过程在提供的 Python 代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_quadrature_rule(q):\n    \"\"\"\n    Returns tensor-product Gauss-Legendre quadrature points and weights\n    for a [-1, 1] x [-1, 1] domain.\n    \"\"\"\n    if q == 1:\n        points_1d = np.array([0.0])\n        weights_1d = np.array([2.0])\n    elif q == 3:\n        points_1d = np.array([-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)])\n        weights_1d = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n    else:\n        raise ValueError(\"Unsupported quadrature order q.\")\n    \n    quad_points = []\n    quad_weights = []\n    for i in range(q):\n        for j in range(q):\n            quad_points.append([points_1d[j], points_1d[i]])\n            quad_weights.append(weights_1d[j] * weights_1d[i])\n    \n    return np.array(quad_points), np.array(quad_weights)\n\ndef get_serendipity_grads(xi, eta):\n    \"\"\"\n    Computes the reference gradients (dN/dxi, dN/deta) for the 8-node\n    serendipity element at a point (xi, eta).\n    Node ordering: 4 corners, then 4 midsides, counter-clockwise from (-1,-1).\n    \"\"\"\n    grad_N_ref = np.zeros((2, 8))\n    \n    # Corner nodes (indices 0-3 correspond to nodes 1-4)\n    xis = np.array([-1.0, 1.0, 1.0, -1.0])\n    etas = np.array([-1.0, -1.0, 1.0, 1.0])\n    for i in range(4):\n        xi_i, eta_i = xis[i], etas[i]\n        term1 = 1.0 + xi_i * xi\n        term2 = 1.0 + eta_i * eta\n        grad_N_ref[0, i] = 0.25 * xi_i * term2 * (2.0 * xi_i * xi + eta_i * eta)\n        grad_N_ref[1, i] = 0.25 * eta_i * term1 * (xi_i * xi + 2.0 * eta_i * eta)\n\n    # Midside nodes (indices 4-7 correspond to nodes 5-8)\n    # Node 4 (problem node 5): bottom edge\n    grad_N_ref[0, 4] = -xi * (1.0 - eta)\n    grad_N_ref[1, 4] = -0.5 * (1.0 - xi**2)\n    \n    # Node 5 (problem node 6): right edge\n    grad_N_ref[0, 5] = 0.5 * (1.0 - eta**2)\n    grad_N_ref[1, 5] = -eta * (1.0 + xi)\n\n    # Node 6 (problem node 7): top edge\n    grad_N_ref[0, 6] = -xi * (1.0 + eta)\n    grad_N_ref[1, 6] = 0.5 * (1.0 - xi**2)\n\n    # Node 7 (problem node 8): left edge\n    grad_N_ref[0, 7] = -0.5 * (1.0 - eta**2)\n    grad_N_ref[1, 7] = -eta * (1.0 - xi)\n\n    return grad_N_ref\n\ndef compute_n_zero(s, q):\n    \"\"\"\n    Computes the number of near-zero eigenvalues for the stiffness matrix\n    of an element with curvature s, using a q x q quadrature rule.\n    \"\"\"\n    delta = 0.3\n    tau = 1e-8\n    \n    # 1. Define physical node coordinates based on s\n    node_coords = np.zeros((8, 2))\n    node_coords[0, :] = [0.0, 0.0]        # Corner 1\n    node_coords[1, :] = [1.0, 0.0]        # Corner 2\n    node_coords[2, :] = [1.0, 1.0]        # Corner 3\n    node_coords[3, :] = [0.0, 1.0]        # Corner 4\n    \n    s_delta = s * delta\n    node_coords[4, :] = [0.5, s_delta]        # Midside 5 (bottom)\n    node_coords[5, :] = [1.0 - s_delta, 0.5]  # Midside 6 (right)\n    node_coords[6, :] = [0.5, 1.0 - s_delta]  # Midside 7 (top)\n    node_coords[7, :] = [s_delta, 0.5]        # Midside 8 (left)\n\n    # 2. Get quadrature rule\n    quad_points, quad_weights = get_quadrature_rule(q)\n\n    # 3. Assemble elemental stiffness matrix K\n    K = np.zeros((8, 8))\n    for qp, qw in zip(quad_points, quad_weights):\n        xi, eta = qp[0], qp[1]\n        \n        grad_N_ref = get_serendipity_grads(xi, eta)\n        \n        # Jacobian matrix F_ij = dx_i / d(xi_j)\n        F = np.zeros((2, 2))\n        F[0, 0] = np.dot(grad_N_ref[0, :], node_coords[:, 0]) # dx/dxi\n        F[0, 1] = np.dot(grad_N_ref[1, :], node_coords[:, 0]) # dx/deta\n        F[1, 0] = np.dot(grad_N_ref[0, :], node_coords[:, 1]) # dy/dxi\n        F[1, 1] = np.dot(grad_N_ref[1, :], node_coords[:, 1]) # dy/deta\n\n        detF = np.linalg.det(F)\n        if detF = 1e-12:\n            raise ValueError(f\"Non-positive Jacobian determinant found: {detF}\")\n        \n        # Physical gradients B = F^{-T} G, where G = grad_N_ref\n        F_inv = np.linalg.inv(F)\n        B = np.dot(F_inv.T, grad_N_ref)\n        \n        # Contribution to stiffness matrix integrand\n        integrand_matrix = np.dot(B.T, B)\n        \n        K += integrand_matrix * detF * qw\n    \n    # 4. Eigenvalue analysis\n    try:\n        eigenvalues = np.linalg.eigh(K)[0]\n    except np.linalg.LinAlgError:\n        # This case should not be reached with valid inputs\n        return -1\n\n    # Use absolute values for robustness against floating-point noise\n    eigenvalues = np.sort(np.abs(eigenvalues))\n    lambda_max = eigenvalues[-1]\n\n    if lambda_max  1e-12: # Handles case where K is the zero matrix\n        return 8\n    \n    threshold = tau * lambda_max\n    n_zero = np.sum(eigenvalues = threshold)\n    \n    return int(n_zero)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,    # Case 1: Straight-sided element\n        0.3,    # Case 2: Moderate curvature\n        0.44    # Case 3: Strong curvature\n    ]\n\n    results = []\n    for s_param in test_cases:\n        # Calculate number of near-zero modes for each quadrature scheme\n        n_zero_q1 = compute_n_zero(s_param, 1)  # Under-integration\n        n_zero_q3 = compute_n_zero(s_param, 3)  # Accurate integration\n        \n        # Compute the difference\n        delta_n_zero = n_zero_q1 - n_zero_q3\n        results.append(delta_n_zero)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准的Galerkin方法（其中试验空间和测试空间相同）在求解对流主导问题时，可能会产生虚假的数值振荡。本练习介绍了Petrov-Galerkin方法，特别是流线迎风Petrov-Galerkin (SUPG) 技术，它通过修改测试空间，沿流线方向引入数值扩散以稳定解。通过实现和测试该方法，你将看到如何通过对弱形式进行原则性修正，来克服标准Galerkin方法的一个主要局限性，并准确捕捉边界层等尖锐特征 。",
            "id": "3134574",
            "problem": "您的任务是为一维对流扩散边界值问题设计并实现一个 Petrov–Galerkin 离散化方法，并量化当检验函数的迎风量变化时，该格式捕捉出口边界层的效果。该问题以纯数学术语表述，并使用泛函分析和变分法中的标准定义。\n\n考虑微分方程\n$$\n-\\varepsilon\\, u''(x) + a\\, u'(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\n其齐次 Dirichlet 边界条件为\n$$\nu(0) = 0, \\quad u(1) = 0,\n$$\n其中 $a0$ 是一个恒定的对流速度，$\\varepsilon0$ 是一个小的扩散系数，$f(x)$ 是一个给定的源函数。假设在 $[0,1]$ 上有一个包含 $N$ 个相等子区间的均匀网格，其中 $N$ 是一个正整数，并在此网格上采用标准的连续分片线性有限元试探空间。\n\n从基本原理出发，使用加权余量法和变分法，在 Sobolev 空间 $H_0^1(0,1)$ 中推导出一个弱形式，其中 $H_0^1(0,1)=\\{ v \\in H^1(0,1): v(0)=v(1)=0\\}$。在流线方向上使用 Petrov–Galerkin 方法选择检验函数，定义为\n$$\nw = v + \\tau\\, a\\, v',\n$$\n其中 $v$ 遍历相同的连续分片线性试探空间，$v'$ 表示 $v$ 的导数，$\\tau$ 是一个稳定化参数。对于此问题，将 $\\tau$ 参数化为\n$$\n\\tau = \\theta \\,\\frac{h}{2\\,a},\n$$\n其中 $h = \\frac{1}{N}$ 是均匀单元长度，$\\theta \\in [0,1]$ 是一个无量纲迎风因子。$\\theta = 0$ 的情况恢复为不带迎风的标准 Galerkin 方法，而较大的 $\\theta$ 会在检验函数中引入更多的迎风。\n\n在实现时，对于每个测试用例，取 $f(x)$ 为一个常数 $f_0$。使用弱形式直接蕴含的单元积分来组装全局线性系统，在 $x=0$ 和 $x=1$ 处施加齐次 Dirichlet 边界条件，并求解得到的线性系统以获得离散解 $u_h$ 的节点值。\n\n为了量化边界层的捕捉效果，将出口边界层窗口定义为区间\n$$\n\\left[\\,1 - c\\,\\frac{\\varepsilon}{a},\\; 1\\,\\right],\n$$\n其中 $c=4$。在此窗口上，计算相对 $L^2$ 误差\n$$\nE_{\\mathrm{BL}} = \\frac{\\left\\| u_h - u_{\\mathrm{exact}} \\right\\|_{L^2\\left(1 - c\\,\\varepsilon/a,\\; 1\\right)}}{\\left\\| u_{\\mathrm{exact}} \\right\\|_{L^2\\left(1 - c\\,\\varepsilon/a,\\; 1\\right)}},\n$$\n其中 $u_{\\mathrm{exact}}$ 是给定参数下边界值问题的精确解。将 $E_{\\mathrm{BL}}$ 表示为一个浮点数。如果数值计算需要，可以通过在足够细密的网格上使用复合梯形法则来近似计算 $L^2$ 范数。\n\n您的程序必须实现上述由 $\\theta$ 参数化的带检验函数迎风的 Petrov–Galerkin 离散化，求解 $u_h$，并为以下每个测试用例计算 $E_{\\mathrm{BL}}$：\n\n- 情况 1：$\\varepsilon = 1\\times 10^{-3}$，$a = 1$，$f_0 = 1$，$N = 64$，$\\theta = 0$。\n- 情况 2：$\\varepsilon = 1\\times 10^{-3}$，$a = 1$，$f_0 = 1$，$N = 64$，$\\theta = 0.5$。\n- 情况 3：$\\varepsilon = 1\\times 10^{-3}$，$a = 1$，$f_0 = 1$，$N = 64$，$\\theta = 1$。\n- 情况 4：$\\varepsilon = 1\\times 10^{-3}$，$a = 5$，$f_0 = 1$，$N = 64$，$\\theta = 1$。\n- 情况 5：$\\varepsilon = 1\\times 10^{-4}$，$a = 5$，$f_0 = 1$，$N = 128$，$\\theta = 1$。\n- 情况 6：$\\varepsilon = 1\\times 10^{-3}$，$a = 1$，$f_0 = 1$，$N = 16$，$\\theta = 1$。\n\n您的程序应生成单行输出，其中包含六个结果 $[E_{\\mathrm{BL},1},E_{\\mathrm{BL},2},E_{\\mathrm{BL},3},E_{\\mathrm{BL},4},E_{\\mathrm{BL},5},E_{\\mathrm{BL},6}]$，形式为方括号括起来的逗号分隔列表，每个值四舍五入到六位小数，例如 $[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901]$。不涉及物理单位，也未使用角度；所有量均为无量纲实数。",
            "solution": "用户要求为一维对流扩散问题设计并实现一个 Petrov-Galerkin 有限元方法。\n\n### **问题陈述验证**\n\n该问题是一个定义明确的边界值问题，源于计算科学，特别是关于偏微分方程的数值解。\n\n**1. 已知条件提取**：\n-   **微分方程**：$-\\varepsilon\\, u''(x) + a\\, u'(x) = f(x)$，对于 $x \\in (0,1)$。\n-   **边界条件**：$u(0) = 0$，$u(1) = 0$。\n-   **参数**：对流速度 $a0$，扩散系数 $\\varepsilon0$。\n-   **源函数**：$f(x) = f_0$，一个常数。\n-   **离散网格**：在 $[0,1]$ 上的均匀网格，有 $N$ 个子区间，单元长度 $h = 1/N$。\n-   **试探空间 $V_h$**：网格上连续的分片线性函数，在 $x=0$ 和 $x=1$ 处为零。\n-   **检验空间 $W_h$**：由函数 $w = v + \\tau\\, a\\, v'$ 定义，其中 $v \\in V_h$。\n-   **稳定化参数**：$\\tau = \\theta \\,\\frac{h}{2\\,a}$，其中 $\\theta \\in [0,1]$。\n-   **误差量化**：在出口边界层窗口 $[\\,1 - c\\,\\frac{\\varepsilon}{a},\\; 1\\,]$（其中 $c=4$）上的相对 $L^2$ 误差 $E_{\\mathrm{BL}}$。\n-   **测试用例**：提供了六组不同的参数 $(\\varepsilon, a, f_0, N, \\theta)$。\n\n**2. 验证**：\n-   **科学依据**：该问题植根于成熟的对流扩散方程有限元方法理论。所描述的 Petrov-Galerkin 方法，特别是流线迎风 Petrov-Galerkin (SUPG) 格式，是一种标准技术。所有原理均来自数学和计算工程。\n-   **适定性和客观性**：该问题在数学上是精确的，所有术语和目标都有明确定义。给定的微分方程及其边界条件是适定的。得到的数值问题也是适定的。\n-   **完整性**：问题陈述是自洽的，并提供了得出唯一解所需的所有必要数据和定义。\n-   **一致性和可行性**：这些参数对于一个模型问题是物理上合理的，并且所需的计算是完全可行的。弱形式的解释，虽然由于检验函数的导数而需要小心处理，但导出了一个标准的、可实现的 SUPG 格式，这与问题提示中使用单元积分的建议一致。\n\n**3. 结论**：\n该问题有效。\n\n### **方法与推导**\n\n**1. 弱形式**\n\n起点是加权余量陈述：找到 $u_h \\in V_h$，使得\n$$\n\\int_0^1 \\left( -\\varepsilon u_h''(x) + a u_h'(x) - f(x) \\right) w_h(x) \\, dx = 0 \\quad \\forall w_h \\in W_h\n$$\n对二阶导数项应用分部积分得到：\n$$\n\\int_0^1 \\left( \\varepsilon u_h'(x) w_h'(x) + a u_h'(x) w_h(x) \\right) \\, dx - [\\varepsilon u_h'(x) w_h(x)]_0^1 = \\int_0^1 f(x) w_h(x) \\, dx\n$$\n检验函数 $w_h(x) = v_h(x) + \\tau a v_h'(x)$ 是由在边界处为零（$v_h(0)=v_h(1)=0$）的试探函数 $v_h \\in V_h$ 构成的。这确保了 $w_h(0)=w_h(1)=0$，因此边界项 $[\\varepsilon u_h' w_h]_0^1$ 为零。因此，弱形式为：找到 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$：\n$$\n\\int_0^1 \\left( \\varepsilon u_h'(x) w_h'(x) + a u_h'(x) w_h(x) \\right) \\, dx = \\int_0^1 f(x) w_h(x) \\, dx\n$$\n其中 $w_h = v_h + \\tau a v_h'$。代入 $w_h$ 和 $w_h'$ 得到：\n$$\n\\int_0^1 \\left( \\varepsilon u_h'(v_h' + \\tau a v_h'') + a u_h'(v_h + \\tau a v_h') \\right) dx = \\int_0^1 f(v_h + \\tau a v_h') dx\n$$\n由于 $v_h$ 是分片线性的，在每个单元内部 $v_h''$ 为零。通过将积分解释为所有单元上的总和 $\\sum_e \\int_{K_e}$， $v_h''$ 项消失。该格式变为：\n$$\n\\sum_e \\int_{K_e} \\left( (\\varepsilon + \\tau a^2) u_h'v_h' + a u_h'v_h \\right) dx = \\sum_e \\int_{K_e} f(v_h + \\tau a v_h') dx\n$$\n这定义了双线性形式 $B(u_h, v_h)$ 和线性泛函 $L(v_h)$：\n$$\nB(u_h, v_h) = \\int_0^1 \\left( (\\varepsilon + \\tau a^2) u_h'v_h' + a u_h'v_h \\right) dx\n$$\n$$\nL(v_h) = \\int_0^1 f(v_h + \\tau a v_h') dx\n$$\n问题是找到 $u_h = \\sum_{j=1}^{N-1} U_j \\phi_j(x)$，使得对于 $i=1, \\ldots, N-1$ 均有 $B(u_h, \\phi_i) = L(\\phi_i)$，其中 $\\phi_i$ 是标准的线性基（“帽子”）函数。\n\n**2. 单元矩阵和向量**\n\n在一个长度为 $h$ 的通用单元 $K_e = [x_{k-1}, x_k]$ 上，局部基函数是 $\\phi_{k-1}$ 和 $\\phi_k$。单元刚度矩阵 $\\mathbf{K}^e$ 和载荷向量 $\\mathbf{F}^e$ 的大小分别为 $2 \\times 2$ 和 $2 \\times 1$。其各项通过在单元上积分计算得出。使用局部到参考单元的映射，我们发现：\n\n-   **单元刚度矩阵 ($\\mathbf{K}^e$)**：\n    $$\n    \\mathbf{K}^e = \\int_{K_e} \\left[ (\\varepsilon + \\tau a^2) \\begin{pmatrix} \\phi'_{k-1}\\phi'_{k-1}  \\phi'_{k-1}\\phi'_{k} \\\\ \\phi'_{k}\\phi'_{k-1}  \\phi'_{k}\\phi'_{k} \\end{pmatrix} + a \\begin{pmatrix} \\phi'_{k-1}\\phi_{k-1}  \\phi'_{k-1}\\phi_{k} \\\\ \\phi'_{k}\\phi_{k-1}  \\phi'_{k}\\phi_{k} \\end{pmatrix} \\right] dx\n    $$\n    计算积分得到：\n    $$\n    \\mathbf{K}^e = \\frac{\\varepsilon + \\tau a^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} + \\frac{a}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix}\n    $$\n    代入 $\\tau = \\theta h / (2a)$，得到：\n    $$\n    \\mathbf{K}^e = \\left(\\frac{\\varepsilon}{h} + \\frac{a\\theta}{2}\\right) \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} + \\frac{a}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix}\n    $$\n\n-   **单元载荷向量 ($\\mathbf{F}^e$)**：\n    $$\n    F^e_i = \\int_{K_e} f_0 (\\phi_i + \\tau a \\phi_i') dx \\quad \\text{for } i \\in \\{k-1, k\\}\n    $$\n    计算这些积分得到：\n    $$\n    \\mathbf{F}^e = \\frac{f_0 h}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + f_0 \\tau a \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\frac{f_0 h}{2} \\begin{pmatrix} 1-\\theta \\\\ 1+\\theta \\end{pmatrix}\n    $$\n\n**3. 全局系统与求解**\n\n全局刚度矩阵 $\\mathbf{K}$ 和载荷向量 $\\mathbf{F}$ 是通过将所有 $N$ 个单元的贡献相加来组装的。这会产生一个大小为 $(N-1) \\times (N-1)$ 的三对角系统 $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$，用于求解未知的节点值 $\\mathbf{U} = [U_1, \\ldots, U_{N-1}]^T$。\n-   主对角线：$\\mathbf{K}_{i,i} = \\frac{2\\varepsilon}{h} + a\\theta$\n-   上对角线：$\\mathbf{K}_{i,i+1} = -\\frac{\\varepsilon}{h} + \\frac{a}{2}(1-\\theta)$\n-   下对角线：$\\mathbf{K}_{i,i-1} = -\\frac{\\varepsilon}{h} - \\frac{a}{2}(1+\\theta)$\n-   载荷向量：$\\mathbf{F}_i = f_0 h$\n\n求解这个三对角系统以得到 $\\mathbf{U}$。然后，完整的离散解 $u_h$ 由节点值 $[0, U_1, \\ldots, U_{N-1}, 0]$ 表示。\n\n**4. 精确解**\n\n方程 $-\\varepsilon u'' + a u' = f_0$ 在 $u(0)=u(1)=0$ 条件下的精确解可通过求解线性常微分方程的标准方法找到：\n$$\nu_{\\mathrm{exact}}(x) = \\frac{f_0}{a} \\left( x - \\frac{e^{ax/\\varepsilon}-1}{e^{a/\\varepsilon}-1} \\right)\n$$\n对于大的 $a/\\varepsilon$ 值（如本题测试用例中遇到的情况），直接计算此表达式在数值上是不稳定的，因为会发生浮点溢出。通过重写分数可以推导出一个稳定的形式：\n$$\n\\frac{e^{ax/\\varepsilon}-1}{e^{a/\\varepsilon}-1} = e^{a(x-1)/\\varepsilon} \\frac{1 - e^{-ax/\\varepsilon}}{1 - e^{-a/\\varepsilon}}\n$$\n对于大的 $a/\\varepsilon$，$e^{-ax/\\varepsilon}$ 和 $e^{-a/\\varepsilon}$ 项可以忽略不计，使得分数部分约等于 1。该表达式简化为一个高度精确的近似，尤其是在 $x=1$ 附近的边界层内：\n$$\nu_{\\mathrm{exact}}(x) \\approx \\frac{f_0}{a} \\left( x - e^{a(x-1)/\\varepsilon} \\right)\n$$\n这种形式避免了溢出，并用于计算误差。\n\n**5. 误差计算**\n\n相对 $L^2$ 误差在出口边界层窗口 $[x_{start}, 1] = [1 - c\\varepsilon/a, 1]$ 上计算。计算 $L^2$ 范数所需的积分通过在该窗口内的细密点网格上使用复合梯形法则进行数值近似。在这些点上的数值解 $u_h(x)$ 通过在计算出的节点值之间进行线性插值得到。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the Petrov-Galerkin problem for all test cases.\n    \"\"\"\n\n    def setup_and_solve_system(eps, a, f0, N, theta):\n        \"\"\"\n        Assembles and solves the Petrov-Galerkin linear system for the 1D\n        convection-diffusion problem.\n        \n        Args:\n            eps (float): Diffusion coefficient.\n            a (float): Convection speed.\n            f0 (float): Constant source term.\n            N (int): Number of subintervals in the mesh.\n            theta (float): Upwinding parameter.\n\n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Nodal coordinates (x_nodes).\n                - np.ndarray: Nodal solution values (U_full).\n        \"\"\"\n        h = 1.0 / N\n        num_unknowns = N - 1\n\n        # Define tridiagonal matrix components based on derivation\n        diag = (2.0 * eps / h) + a * theta\n        upper = (-eps / h) + (a / 2.0) * (1.0 - theta)\n        lower = (-eps / h) - (a / 2.0) * (1.0 + theta)\n\n        # Assemble the banded matrix for scipy's solver\n        # ab[0,:] = upper diagonal (shifted)\n        # ab[1,:] = main diagonal\n        # ab[2,:] = lower diagonal (shifted)\n        ab = np.zeros((3, num_unknowns))\n        if num_unknowns > 1:\n            ab[0, 1:] = upper\n            ab[2, :-1] = lower\n        ab[1, :] = diag\n        \n        # Assemble the load vector F\n        F = np.full(num_unknowns, f0 * h)\n\n        # Solve the linear system KU = F\n        U = solve_banded((1, 1), ab, F)\n\n        # Construct full solution vector including boundary conditions U(0)=0, U(1)=0\n        U_full = np.concatenate(([0.0], U, [0.0]))\n        x_nodes = np.linspace(0, 1, N + 1)\n        \n        return x_nodes, U_full\n\n    def get_exact_solution_values(x_grid, eps, a, f0):\n        \"\"\"\n        Computes the exact solution on a given grid of points using a\n        numerically stable formulation suitable for large Peclet numbers.\n        \"\"\"\n        # A numerically stable approximation for large a/eps:\n        # u(x) approx (f0/a) * (x - exp(a*(x-1)/eps))\n        # This form is highly accurate in the boundary layer near x=1.\n        term = a * (x_grid - 1.0) / eps\n        exp_term = np.exp(term)\n        return (f0 / a) * (x_grid - exp_term)\n\n    def calculate_relative_error(x_nodes, U_full, eps, a, f0, c):\n        \"\"\"\n        Calculates the relative L2 error in the outflow boundary layer window\n        using a composite trapezoidal rule for integration.\n        \"\"\"\n        x_start = 1.0 - c * eps / a\n        # Ensure the window starts within the domain [0,1]\n        if x_start  0:\n            x_start = 0.0\n\n        # Create a fine grid for numerical integration\n        num_integration_points = 4001\n        x_integration_grid = np.linspace(x_start, 1.0, num_integration_points)\n        \n        # Interpolate the numerical solution u_h onto the integration grid\n        u_h_values = np.interp(x_integration_grid, x_nodes, U_full)\n\n        # Evaluate the exact solution on the integration grid\n        u_exact_values = get_exact_solution_values(x_integration_grid, eps, a, f0)\n        \n        # Define integrands for the L2 norms\n        integrand_numerator = (u_h_values - u_exact_values)**2\n        integrand_denominator = u_exact_values**2\n\n        # Compute integrals using the composite trapezoidal rule (np.trapz)\n        norm_sq_error = np.trapz(integrand_numerator, x=x_integration_grid)\n        norm_sq_exact = np.trapz(integrand_denominator, x=x_integration_grid)\n\n        # Handle the case where the exact solution is zero over the window\n        if norm_sq_exact  1e-16: # Use a small tolerance instead of exact zero\n            return 0.0 if norm_sq_error  1e-16 else np.inf\n\n        return np.sqrt(norm_sq_error / norm_sq_exact)\n\n    def run_case(params):\n        \"\"\"\n        Executes the full pipeline for a single test case.\n        \"\"\"\n        eps, a, f0, N, theta = params\n        c = 4.0\n        \n        # 1. Solve the system to get the numerical solution\n        x_nodes, U_full = setup_and_solve_system(eps, a, f0, N, theta)\n        \n        # 2. Calculate the relative L2 error in the boundary layer\n        error = calculate_relative_error(x_nodes, U_full, eps, a, f0, c)\n        \n        return error\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (1e-3, 1, 1, 64, 0),    # Case 1\n        (1e-3, 1, 1, 64, 0.5),  # Case 2\n        (1e-3, 1, 1, 64, 1),    # Case 3\n        (1e-3, 5, 1, 64, 1),    # Case 4\n        (1e-4, 5, 1, 128, 1),   # Case 5\n        (1e-3, 1, 1, 16, 1),    # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Format the output string as specified\n    formatted_results = ','.join([f\"{r:.6f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}