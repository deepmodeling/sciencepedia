{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Finite Element Method lies in discretizing a continuous problem into a collection of smaller, simpler domains called elements. This exercise focuses on a fundamental step: deriving an element's characteristic matrices from its basis functions. You will calculate the consistent mass matrix for a simple one-dimensional element, which is essential for analyzing dynamic problems like vibrations, providing core practice in evaluating the integrals that emerge from the weak formulation of the governing equations .",
            "id": "2172585",
            "problem": "In the finite element analysis of structures undergoing vibration, the inertia of the elements is represented by a mass matrix. Consider a single one-dimensional, two-noded linear element used to model a segment of a uniform rod. This element has a length $h_e$, a constant mass density $\\rho$, and a uniform cross-sectional area $A$.\n\nA local coordinate system is defined such that the element occupies the domain $x \\in [0, h_e]$, with node 1 at $x=0$ and node 2 at $x=h_e$. The axial displacement field within the element is interpolated from the nodal displacements using the linear functions $N_1(x) = 1 - \\frac{x}{h_e}$ and $N_2(x) = \\frac{x}{h_e}$.\n\nThe entries $M_{ij}$ of the $2 \\times 2$ element mass matrix $\\mathbf{M}$ (where $i, j \\in \\{1, 2\\}$) are determined by the following integral over the element's length:\n$$\nM_{ij} = \\int_{0}^{h_e} \\rho A N_i(x) N_j(x) dx\n$$\nCalculate the element mass matrix $\\mathbf{M}$. Your answer should be a $2 \\times 2$ matrix expressed in terms of $\\rho$, $A$, and $h_e$.",
            "solution": "We use the consistent mass matrix definition for a one-dimensional element:\n$$\nM_{ij}=\\int_{0}^{h_{e}}\\rho A\\,N_{i}(x)N_{j}(x)\\,dx,\\quad i,j\\in\\{1,2\\},\n$$\nwith linear shape functions $N_{1}(x)=1-\\frac{x}{h_{e}}$ and $N_{2}(x)=\\frac{x}{h_{e}}$ on $x\\in[0,h_{e}]$.\n\nCompute each entry:\nFor $M_{11}$,\n$$\nM_{11}=\\int_{0}^{h_{e}}\\rho A\\left(1-\\frac{x}{h_{e}}\\right)^{2}dx\n=\\rho A\\int_{0}^{h_{e}}\\left(1-\\frac{2x}{h_{e}}+\\frac{x^{2}}{h_{e}^{2}}\\right)dx.\n$$\nIntegrating term by term,\n$$\nM_{11}=\\rho A\\left[x-\\frac{x^{2}}{h_{e}}+\\frac{x^{3}}{3h_{e}^{2}}\\right]_{0}^{h_{e}}\n=\\rho A\\left(h_{e}-h_{e}+\\frac{h_{e}}{3}\\right)\n=\\rho A\\frac{h_{e}}{3}.\n$$\n\nFor $M_{12}$,\n$$\nM_{12}=\\int_{0}^{h_{e}}\\rho A\\left(1-\\frac{x}{h_{e}}\\right)\\left(\\frac{x}{h_{e}}\\right)dx\n=\\rho A\\int_{0}^{h_{e}}\\left(\\frac{x}{h_{e}}-\\frac{x^{2}}{h_{e}^{2}}\\right)dx.\n$$\nIntegrating,\n$$\nM_{12}=\\rho A\\left[\\frac{x^{2}}{2h_{e}}-\\frac{x^{3}}{3h_{e}^{2}}\\right]_{0}^{h_{e}}\n=\\rho A\\left(\\frac{h_{e}}{2}-\\frac{h_{e}}{3}\\right)\n=\\rho A\\frac{h_{e}}{6}.\n$$\n\nBy symmetry, $M_{21}=M_{12}=\\rho A\\frac{h_{e}}{6}$, and similarly\n$$\nM_{22}=\\int_{0}^{h_{e}}\\rho A\\left(\\frac{x}{h_{e}}\\right)^{2}dx\n=\\rho A\\int_{0}^{h_{e}}\\frac{x^{2}}{h_{e}^{2}}dx\n=\\rho A\\frac{1}{h_{e}^{2}}\\left[\\frac{x^{3}}{3}\\right]_{0}^{h_{e}}\n=\\rho A\\frac{h_{e}}{3}.\n$$\n\nAssembling the entries gives\n$$\n\\mathbf{M}=\n\\begin{pmatrix}\n\\rho A\\frac{h_{e}}{3} & \\rho A\\frac{h_{e}}{6} \\\\\n\\rho A\\frac{h_{e}}{6} & \\rho A\\frac{h_{e}}{3}\n\\end{pmatrix}\n=\\frac{\\rho A h_{e}}{6}\n\\begin{pmatrix}\n2 & 1 \\\\\n1 & 2\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\frac{\\rho A h_{e}}{6}\\begin{pmatrix}2 & 1 \\\\ 1 & 2\\end{pmatrix}}$$"
        },
        {
            "introduction": "After computing matrices for individual elements, the next crucial step is to assemble them into a single global system representing the entire model. This practice challenges your understanding of the assembly process, which maps local element degrees of freedom to their corresponding global counterparts. By using intentionally scrambled node and element numbering, this problem forces you to move beyond simple sequential logic and master the robust mapping procedure at the heart of every finite element code .",
            "id": "2393853",
            "problem": "A steady one-dimensional heat conduction problem is considered on a straight, prismatic bar with constant thermal conductivity $k$ and constant cross-sectional area $A$. There is no internal heat generation. The bar is discretized using the standard Galerkin finite element method with linear Lagrange shape functions into $4$ elements over $5$ global nodes. The global node identifiers and their positions along the bar are:\n- Node $42$: $x=0.00 \\ \\mathrm{m}$\n- Node $7$: $x=0.35 \\ \\mathrm{m}$\n- Node $13$: $x=0.50 \\ \\mathrm{m}$\n- Node $5$: $x=0.90 \\ \\mathrm{m}$\n- Node $21$: $x=1.20 \\ \\mathrm{m}$\n\nThe element connectivity is intentionally scrambled and given by the following list of two-node elements $(\\text{first node}, \\text{second node})$:\n- Element $17$: $(42,7)$\n- Element $100$: $(13,7)$\n- Element $9$: $(13,5)$\n- Element $23$: $(21,5)$\n\nAssemble the global stiffness matrix for the unconstrained system (that is, before applying any boundary conditions). The rows and columns of the global stiffness matrix are to be ordered according to the node-identifier sequence $(5, \\ 42, \\ 13, \\ 21, \\ 7)$.\n\nMaterial and geometric properties are:\n- Thermal conductivity $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$\n- Cross-sectional area $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$\n\nWhat is the value of the diagonal entry of the assembled global stiffness matrix associated with global node identifier $13$? Express your answer in $\\mathrm{W \\, K^{-1}}$ and round your answer to $4$ significant figures.",
            "solution": "The governing differential equation for steady one-dimensional heat conduction in a prismatic bar with constant thermal conductivity $k$ and cross-sectional area $A$ without internal heat generation is\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\!\\left(k A \\, \\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) \\,=\\, 0.\n$$\nThe standard Galerkin finite element method with linear Lagrange shape functions over a two-node element of length $L_{e}$ produces the element stiffness matrix\n$$\n\\mathbf{K}^{(e)} \\,=\\, \\int_{0}^{L_{e}} k A \\, \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\top} \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) \\, \\mathrm{d}x,\n$$\nwhere $\\mathbf{N} = \\begin{bmatrix} N_{1} & N_{2} \\end{bmatrix}$ are the linear shape functions. For a linear two-node element, the derivatives are constant on the element, $\\frac{\\mathrm{d}N_{1}}{\\mathrm{d}x} = -\\frac{1}{L_{e}}$ and $\\frac{\\mathrm{d}N_{2}}{\\mathrm{d}x} = \\frac{1}{L_{e}}$, so\n$$\n\\mathbf{K}^{(e)} \\,=\\, k A \\int_{0}^{L_{e}} \n\\begin{bmatrix}\n\\frac{1}{L_{e}^{2}} & -\\frac{1}{L_{e}^{2}} \\\\\n-\\frac{1}{L_{e}^{2}} & \\frac{1}{L_{e}^{2}}\n\\end{bmatrix}\n\\mathrm{d}x\n\\,=\\, \\frac{k A}{L_{e}} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}.\n$$\n\nThus, each element contributes $\\frac{k A}{L_{e}}$ to the diagonal entries associated with its two nodes and $-\\frac{k A}{L_{e}}$ to the corresponding off-diagonal couplings. The diagonal entry of the global stiffness matrix associated with a particular global node is the sum of the diagonal contributions from the elements incident on that node.\n\nWe first compute the element lengths from the given node coordinates:\n- Element $17$ connects nodes $(42, 7)$ at $x=0.00 \\ \\mathrm{m}$ and $x=0.35 \\ \\mathrm{m}$, so $L_{17} = |0.35 - 0.00| = 0.35 \\ \\mathrm{m}$.\n- Element $100$ connects nodes $(13, 7)$ at $x=0.50 \\ \\mathrm{m}$ and $x=0.35 \\ \\mathrm{m}$, so $L_{100} = |0.50 - 0.35| = 0.15 \\ \\mathrm{m}$.\n- Element $9$ connects nodes $(13, 5)$ at $x=0.50 \\ \\mathrm{m}$ and $x=0.90 \\ \\mathrm{m}$, so $L_{9} = |0.90 - 0.50| = 0.40 \\ \\mathrm{m}$.\n- Element $23$ connects nodes $(21, 5)$ at $x=1.20 \\ \\mathrm{m}$ and $x=0.90 \\ \\mathrm{m}$, so $L_{23} = |1.20 - 0.90| = 0.30 \\ \\mathrm{m}$.\n\nGlobal node $13$ is incident on elements $100$ and $9$. Therefore, the diagonal entry of the global stiffness matrix associated with node $13$ is\n$$\nK_{(13,13)} \\,=\\, \\frac{k A}{L_{100}} \\,+\\, \\frac{k A}{L_{9}}.\n$$\n\nInsert the given material and geometric properties $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$ and $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$:\n$$\nk A = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}} \\times (2.0 \\times 10^{-3} \\ \\mathrm{m^2}) = 0.36 \\ \\mathrm{W \\, m \\, K^{-1}}.\n$$\nThus,\n$$\nK_{(13,13)} = 0.36 \\ \\mathrm{W \\, m \\, K^{-1}} \\times \\left(\\frac{1}{0.15 \\ \\mathrm{m}} + \\frac{1}{0.40 \\ \\mathrm{m}}\\right).\n$$\nCompute the reciprocal lengths:\n$$\n\\frac{1}{0.15} = \\frac{100}{15} = \\frac{20}{3}, \n\\qquad\n\\frac{1}{0.40} = \\frac{10}{4} = \\frac{5}{2} = 2.5.\n$$\nTherefore,\n$$\nK_{(13,13)} = 0.36 \\left( \\frac{20}{3} + \\frac{5}{2} \\right) \\mathrm{W \\, K^{-1}} = 0.36 \\left( \\frac{40}{6} + \\frac{15}{6} \\right) \\mathrm{W \\, K^{-1}} = 0.36 \\left( \\frac{55}{6} \\right) \\mathrm{W \\, K^{-1}}.\n$$\nMultiply:\n$$\n0.36 \\times \\left( \\frac{55}{6} \\right) = \\frac{19.8}{6} = 3.3.\n$$\n\nHence, the diagonal entry associated with global node $13$ is\n$$\nK_{(13,13)} \\,=\\, 3.3 \\ \\mathrm{W \\, K^{-1}}.\n$$\nRounding to $4$ significant figures yields $3.300 \\ \\mathrm{W \\, K^{-1}}$ as required.",
            "answer": "$$\\boxed{3.300}$$"
        },
        {
            "introduction": "With a firm grasp of element formulation and assembly, you can build a complete FEM program to serve as a numerical laboratory for exploring advanced concepts. This capstone project involves implementing a solver for the Laplace equation to investigate how a domain's geometry impacts solution accuracy and convergence. By comparing a smooth square domain with a non-convex L-shaped domain, you will numerically verify the theoretical predictions about how geometric singularities degrade the finite element approximation, a vital insight for practical engineering and scientific analysis .",
            "id": "3230018",
            "problem": "Implement a complete program that assembles and solves the continuous Galerkin, piecewise linear finite element method for the homogeneous Laplace equation on two planar domains, and uses it to investigate the effect of a re-entrant corner on convergence. Start from the strong form: find $u$ such that $-\\Delta u = 0$ in a bounded, polygonal domain $\\Omega \\subset \\mathbb{R}^2$ with Dirichlet boundary data $u = g$ on $\\partial \\Omega$. Derive the weak form by multiplying by a test function $v$ that vanishes on $\\partial \\Omega$, integrating by parts, and using Green's identity to obtain a coercive bilinear form and a null right-hand side. Discretize with continuous, piecewise linear shape functions on a conforming triangulation of $\\Omega$. Assemble the global stiffness matrix by summing the elementwise contributions, and impose Dirichlet boundary conditions strongly.\n\nConstruct two domains and exact solutions as follows.\n\n- Smooth reference case: $\\Omega_{\\mathrm{sq}} = [0,1]^2$ and $u_{\\mathrm{sq}}(x,y) = x^3 - 3 x y^2$, which is harmonic in $\\mathbb{R}^2$. The boundary data are $g = u_{\\mathrm{sq}}$ on $\\partial \\Omega_{\\mathrm{sq}}$. This case has high regularity.\n\n- Singular L-shaped case: $\\Omega_{\\mathrm{L}} = (-1,1)^2 \\setminus \\big([0,1] \\times (-1,0)\\big)$, which has a re-entrant corner of interior angle $\\omega = 3\\pi/2$ at the origin. Let $\\alpha = \\pi/\\omega = 2/3$. Define polar coordinates $(r,\\theta)$ around the origin by $r = \\sqrt{x^2+y^2}$ and $\\theta = \\operatorname{atan2}(y,x)$ adjusted to the interval $[0, 2\\pi)$ by adding $2\\pi$ if $\\theta  0$. Define $u_{\\mathrm{L}}(x,y) = r^{\\alpha} \\sin(\\alpha \\theta)$, which is harmonic away from the origin and satisfies homogeneous boundary conditions along the rays $\\theta=0$ and $\\theta=3\\pi/2$. Prescribe $g = u_{\\mathrm{L}}$ on $\\partial \\Omega_{\\mathrm{L}}$. All angles must be in radians.\n\nTriangulate each domain by subdividing an axis-aligned rectangular grid into right triangles. For $\\Omega_{\\mathrm{sq}}$, use the uniform grid on $[0,1]^2$ with mesh parameter $h = 1/N$, where $N \\in \\{8,16,32\\}$ is the number of subintervals on each axis, and split each grid square into two triangles along a fixed diagonal. For $\\Omega_{\\mathrm{L}}$, use the uniform grid on $[-1,1]^2$ with $h = 2/N$, $N \\in \\{8,16,32\\}$, form triangles as above, and include only those triangles whose three vertices satisfy the domain predicate $\\neg(x > 0 \\wedge y  0)$; this enforces the L-shape with a re-entrant corner at $(0,0)$.\n\nAssemble the piecewise linear (also called $P_1$) finite element system for $-\\Delta u = 0$ with Dirichlet data $g$ imposed at all boundary nodes. Solve for the nodal values of the discrete solution $u_h$. Estimate the $L^2$-norm and $H^1$-seminorm errors by single-point quadrature on each triangle: on each triangle $K$ with area $|K|$, centroid $x_K$, and constant discrete gradient $\\nabla u_h|_K$, approximate\n- $\\|u - u_h\\|_{L^2(\\Omega)}^2 \\approx \\sum_{K} |K|\\,(u(x_K) - u_h(x_K))^2$, where $u_h(x_K)$ is the value of the piecewise linear $u_h$ at the centroid, and\n- $|u - u_h|_{H^1(\\Omega)}^2 \\approx \\sum_{K} |K|\\,\\|\\nabla u(x_K) - \\nabla u_h|_K\\|_2^2$.\n\nFor $\\Omega_{\\mathrm{sq}}$, use the exact gradient $\\nabla u_{\\mathrm{sq}}(x,y) = \\big(3x^2 - 3y^2,\\,-6xy\\big)$. For $\\Omega_{\\mathrm{L}}$, use polar-gradient relations with $u_r = \\alpha r^{\\alpha-1}\\sin(\\alpha\\theta)$ and $u_{\\theta} = \\alpha r^{\\alpha}\\cos(\\alpha\\theta)$, and the identity $\\nabla u = u_r \\, \\mathbf{e}_r + (1/r)\\,u_{\\theta}\\,\\mathbf{e}_{\\theta}$ where $\\mathbf{e}_r = (\\cos\\theta,\\sin\\theta)$ and $\\mathbf{e}_{\\theta} = (-\\sin\\theta,\\cos\\theta)$; when $r$ is extremely small, set the gradient to zero to avoid numerical overflow.\n\nYour program must compute observed convergence rates using the mesh sizes $h_1$ and $h_2$ associated with refinements $N_1$ and $N_2$ by\n$$\np = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)},\n$$\nwhere $E(h)$ denotes either the $H^1$-seminorm error or the $L^2$-norm error. Use the level pairs $(N_1,N_2) = (8,16)$ and $(16,32)$ for both domains, with $h = 1/N$ on $\\Omega_{\\mathrm{sq}}$ and $h = 2/N$ on $\\Omega_{\\mathrm{L}}$.\n\nTest suite and required outputs:\n- Case $1$: $\\Omega_{\\mathrm{sq}}$, observed $H^1$-seminorm convergence rate between $N=8$ and $N=16$.\n- Case $2$: $\\Omega_{\\mathrm{sq}}$, observed $H^1$-seminorm convergence rate between $N=16$ and $N=32$.\n- Case $3$: $\\Omega_{\\mathrm{sq}}$, observed $L^2$-norm convergence rate between $N=8$ and $N=16$.\n- Case $4$: $\\Omega_{\\mathrm{sq}}$, observed $L^2$-norm convergence rate between $N=16$ and $N=32$.\n- Case $5$: $\\Omega_{\\mathrm{L}}$, observed $H^1$-seminorm convergence rate between $N=8$ and $N=16$.\n- Case $6$: $\\Omega_{\\mathrm{L}}$, observed $H^1$-seminorm convergence rate between $N=16$ and $N=32$.\n- Case $7$: $\\Omega_{\\mathrm{L}}$, observed $L^2$-norm convergence rate between $N=8$ and $N=16$.\n- Case $8$: $\\Omega_{\\mathrm{L}}$, observed $L^2$-norm convergence rate between $N=16$ and $N=32$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered exactly as the eight cases above. Express all eight results as decimal floating-point numbers rounded to three digits after the decimal point, with no spaces. For example, the printed line must look like\n$[0.995,1.002,1.987,2.001,0.661,0.668,1.650,1.672]$\nbut with the actual values computed by your program.",
            "solution": "The problem requires the implementation of a continuous, piecewise linear ($P_1$) Galerkin finite element method (FEM) to solve the two-dimensional Laplace equation $-\\Delta u = 0$ on two different domains, followed by a numerical study of the convergence rates.\n\n\\textbf{1. Variational Formulation}\nThe strong form of the boundary value problem is: find a function $u$ such that\n$$\n\\begin{cases}\n    -\\Delta u = 0  \\text{in } \\Omega \\\\\n    u = g  \\text{on } \\partial\\Omega\n\\end{cases}\n$$\nwhere $\\Omega$ is a bounded, polygonal domain in $\\mathbb{R}^2$ and $g$ is prescribed boundary data. To derive the weak form, we multiply the PDE by a test function $v$ from the Sobolev space $H_0^1(\\Omega)$, which consists of functions in $H^1(\\Omega)$ that vanish on the boundary $\\partial\\Omega$. Integrating over the domain $\\Omega$, we get:\n$$\n-\\int_{\\Omega} (\\Delta u) v \\, d\\mathbf{x} = 0\n$$\nApplying Green's first identity, $\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = -\\int_{\\Omega} (\\Delta u) v \\, d\\mathbf{x} + \\int_{\\partial\\Omega} v (\\nabla u \\cdot \\mathbf{n}) \\, dS$, we obtain:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\partial\\Omega} v (\\nabla u \\cdot \\mathbf{n}) \\, dS\n$$\nSince $v \\in H_0^1(\\Omega)$, its trace on the boundary is zero, i.e., $v|_{\\partial\\Omega} = 0$. Thus, the boundary integral vanishes. The resulting weak formulation is: find $u \\in H^1(\\Omega)$ such that $u|_{\\partial\\Omega} = g$ and for all test functions $v \\in H_0^1(\\Omega)$:\n$$\na(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = 0\n$$\nThe function $a(u,v)$ is a symmetric, coercive, and continuous bilinear form on $H_0^1(\\Omega) \\times H_0^1(\\Omega)$, which guarantees a unique solution to the variational problem.\n\n\\textbf{2. Finite Element Discretization}\nWe partition the domain $\\Omega$ into a conforming triangulation $\\mathcal{T}_h$. The continuous problem is approximated in a finite-dimensional subspace $V_h \\subset H^1(\\Omega)$, consisting of functions that are continuous globally and are linear polynomials on each triangle $K \\in \\mathcal{T}_h$. An arbitrary function $u_h \\in V_h$ can be expressed as a linear combination of nodal basis functions $\\phi_j$:\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_p} U_j \\phi_j(\\mathbf{x})\n$$\nwhere $N_p$ is the number of nodes (vertices) in the mesh, $U_j$ is the nodal value of the solution at node $\\mathbf{x}_j$, and $\\phi_j$ is the \"hat\" function satisfying $\\phi_j(\\mathbf{x}_k) = \\delta_{jk}$ (the Kronecker delta).\n\nThe discrete problem is to find $u_h \\in V_h$ that satisfies the boundary conditions and the weak form for all test functions in a basis for the discrete test space. This leads to a system of linear equations.\n\n\\textbf{3. Assembly of the Linear System}\nWe substitute the expansion for $u_h$ into the weak form and test against each basis function $\\phi_i$ corresponding to an interior node. For each such $i$:\n$$\na(u_h, \\phi_i) = a\\left(\\sum_{j=1}^{N_p} U_j \\phi_j, \\phi_i\\right) = \\sum_{j=1}^{N_p} U_j a(\\phi_j, \\phi_i) = 0\n$$\nThis forms a linear system $A\\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U}$ is the vector of nodal values, $A_{ij} = a(\\phi_i, \\phi_j)$ is the stiffness matrix, and $F_i=0$ is the load vector. The stiffness matrix is assembled by summing contributions from each element:\n$$\nA_{ij} = \\int_{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_{K} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\mathbf{x}\n$$\nFor a $P_1$ triangular element $K$ with vertices $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$, the gradients of the local basis functions are constant. The $3 \\times 3$ element stiffness matrix $A^K$ has entries $A^K_{ij} = (\\nabla \\phi_i|_K \\cdot \\nabla \\phi_j|_K) |K|$, where $|K|$ is the area of the triangle. The gradients are computed using the vertex coordinates, e.g., $\\nabla \\phi_1|_K = \\frac{1}{2|K|} (y_2-y_3, x_3-x_2)$ and its cyclic permutations.\n\n\\textbf{4. Imposition of Dirichlet Boundary Conditions}\nThe problem specifies \"strong\" imposition. We partition the nodes into interior nodes (index set $\\mathcal{I}$) and boundary nodes (index set $\\mathcal{B}$). For boundary nodes $j \\in \\mathcal{B}$, the values $U_j = g(\\mathbf{x}_j)$ are known. For an interior node $i \\in \\mathcal{I}$, the equation is $\\sum_{j \\in \\mathcal{I}} A_{ij} U_j + \\sum_{j \\in \\mathcal{B}} A_{ij} U_j = 0$. We rearrange this to form a reduced system for the unknown interior nodal values $\\mathbf{U}_{\\mathcal{I}}$:\n$$\n\\sum_{j \\in \\mathcal{I}} A_{ij} U_j = -\\sum_{j \\in \\mathcal{B}} A_{ij} g(\\mathbf{x}_j)\n$$\nThis system, $A_{\\mathcal{I}\\mathcal{I}} \\mathbf{U}_{\\mathcal{I}} = \\mathbf{F}_{\\mathcal{I}}$, is solved for $\\mathbf{U}_{\\mathcal{I}}$. $A_{\\mathcal{I}\\mathcal{I}}$ is the submatrix of $A$ for interior-interior interactions, and $\\mathbf{F}_{\\mathcal{I}}$ is the vector of contributions from boundary values.\n\n\\textbf{5. Error Estimation and Convergence}\nThe errors are estimated using a single-point quadrature rule at the centroid $\\mathbf{x}_K$ of each triangle $K$.\nThe squared $L^2$-norm error is approximated as:\n$$\n\\|u - u_h\\|_{L^2(\\Omega)}^2 \\approx \\sum_{K \\in \\mathcal{T}_h} |K|\\,(u(\\mathbf{x}_K) - u_h(\\mathbf{x}_K))^2\n$$\nThe squared $H^1$-seminorm error is approximated as:\n$$\n|u - u_h|_{H^1(\\Omega)}^2 \\approx \\sum_{K \\in \\mathcal{T}_h} |K|\\,\\|\\nabla u(\\mathbf{x}_K) - \\nabla u_h|_K\\|_2^2\n$$\nwhere $u_h(\\mathbf{x}_K)$ is the average of the nodal values at the vertices of $K$, and $\\nabla u_h|_K$ is the constant gradient of the discrete solution on $K$.\n\nThe observed order of convergence $p$ is calculated using errors $E(h_1)$ and $E(h_2)$ from two mesh sizes $h_1$ and $h_2$:\n$$\np = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)}\n$$\nFor the specified refinements $(N_1, N_2) = (8,16)$ and $(16,32)$, the mesh size ratio is $h_1/h_2 = 2$, so $p = \\log_2(E(h_1)/E(h_2))$.\n\n\\textbf{6. Problem Specifics}\nTwo cases are studied:\n- \\textbf{Square Domain}: $\\Omega_{\\mathrm{sq}} = [0,1]^2$ with a smooth, harmonic solution $u_{\\mathrm{sq}}(x,y) = x^3 - 3 x y^2$. Standard FEM theory predicts optimal convergence rates, i.e., $p \\approx 1$ for the $H^1$-seminorm error and $p \\approx 2$ for the $L^2$-norm error.\n- \\textbf{L-shaped Domain}: $\\Omega_{\\mathrm{L}}$ with a re-entrant corner of angle $\\omega = 3\\pi/2$. The exact solution $u_{\\mathrm{L}}(x,y) = r^{\\alpha} \\sin(\\alpha \\theta)$ with $\\alpha=\\pi/\\omega=2/3$ is singular at the origin (its gradient is unbounded). This reduced regularity degrades the convergence of the FEM on a uniform mesh. The theoretical rates are limited by the singularity strength, predicting $p \\approx \\alpha = 2/3$ for the $H^1$-seminorm and often $p \\approx 2\\alpha = 4/3$ for the $L^2$-norm. The numerical experiment will verify these differing convergence behaviors.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to perform the FEM analysis and compute convergence rates.\n    \"\"\"\n    \n    # --- Exact Solutions and Gradients ---\n    def u_sq(x, y):\n        return x**3 - 3 * x * y**2\n\n    def grad_u_sq(x, y):\n        return np.array([3 * x**2 - 3 * y**2, -6 * x * y])\n\n    _alpha = 2.0 / 3.0\n    def u_L(x, y):\n        r = np.sqrt(x**2 + y**2)\n        if r == 0:\n            return 0.0\n        theta = np.arctan2(y, x)\n        if theta  0:\n            theta += 2 * np.pi\n        return r**_alpha * np.sin(_alpha * theta)\n\n    def grad_u_L(x, y):\n        r = np.sqrt(x**2 + y**2)\n        if r  1e-12: # Avoid singularity at the origin\n            return np.array([0.0, 0.0])\n        theta = np.arctan2(y, x)\n        if theta  0:\n            theta += 2 * np.pi\n\n        # Gradient in polar coordinates transformed to Cartesian\n        # u_r = alpha * r**(alpha-1) * sin(alpha*theta)\n        # u_theta = alpha * r**alpha * cos(alpha*theta)\n        # grad_u = u_r * e_r + (1/r) * u_theta * e_theta\n        # e_r = (cos(theta), sin(theta)) = (x/r, y/r)\n        # e_theta = (-sin(theta), cos(theta)) = (-y/r, x/r)\n        # grad_u = (alpha*r**(alpha-1)*sin(alpha*theta))*(x/r,y/r) +\n        #          (alpha*r**(alpha-1)*cos(alpha*theta))*(-y/r,x/r)\n        # grad_u = alpha * r**(alpha-2) * [\n        #    x*sin(alpha*theta) - y*cos(alpha*theta),\n        #    y*sin(alpha*theta) + x*cos(alpha*theta)\n        # ]\n\n        common_factor = _alpha * r**(_alpha - 2)\n        sa = np.sin(_alpha * theta)\n        ca = np.cos(_alpha * theta)\n        \n        grad_x = common_factor * (x * sa - y * ca)\n        grad_y = common_factor * (y * sa + x * ca)\n        \n        return np.array([grad_x, grad_y])\n\n    # --- Mesh Generation ---\n    def generate_mesh(domain_type, N):\n        if domain_type == 'sq':\n            nx = ny = N + 1\n            x = np.linspace(0.0, 1.0, nx)\n            y = np.linspace(0.0, 1.0, ny)\n            nodes = np.array([[xi, yj] for yj in y for xi in x])\n            \n            elements = []\n            for j in range(N):\n                for i in range(N):\n                    p1 = j * nx + i\n                    p2 = j * nx + i + 1\n                    p3 = (j + 1) * nx + i\n                    p4 = (j + 1) * nx + i + 1\n                    elements.append([p1, p2, p4])\n                    elements.append([p1, p4, p3])\n            \n            elements = np.array(elements)\n            num_nodes = len(nodes)\n            boundary_nodes = {i for i in range(num_nodes) if \n                              np.isclose(nodes[i,0], 0.0) or np.isclose(nodes[i,0], 1.0) or\n                              np.isclose(nodes[i,1], 0.0) or np.isclose(nodes[i,1], 1.0)}\n            return nodes, elements, boundary_nodes\n\n        elif domain_type == 'L':\n            nx = ny = N + 1\n            x_coords = np.linspace(-1.0, 1.0, nx)\n            y_coords = np.linspace(-1.0, 1.0, ny)\n            \n            # Generate nodes and elements for the full square [-1,1]^2\n            full_nodes = np.array([[xi, yj] for yj in y_coords for xi in x_coords])\n            full_elements = []\n            for j in range(N):\n                for i in range(N):\n                    p1 = j * nx + i\n                    p2 = j * nx + i + 1\n                    p3 = (j + 1) * nx + i\n                    p4 = (j + 1) * nx + i + 1\n                    full_elements.append([p1, p2, p4])\n                    full_elements.append([p1, p4, p3])\n            \n            # Domain predicate: True if a point is IN the domain\n            domain_predicate = lambda p: not (p[0] > 1e-9 and p[1]  -1e-9)\n\n            # Filter elements based on vertices\n            valid_elements = [elem for elem in full_elements if all(domain_predicate(full_nodes[v]) for v in elem)]\n            \n            # Re-index nodes\n            active_node_indices = sorted(list(set(v for elem in valid_elements for v in elem)))\n            old_to_new_map = {old_idx: new_idx for new_idx, old_idx in enumerate(active_node_indices)}\n            \n            nodes = full_nodes[active_node_indices]\n            elements = np.array([[old_to_new_map[v] for v in elem] for elem in valid_elements])\n            \n            # Identify boundary nodes\n            num_nodes = len(nodes)\n            boundary_nodes = set()\n            for i in range(num_nodes):\n                x, y = nodes[i]\n                if (np.isclose(x, -1.0) or np.isclose(x, 1.0) or\n                    np.isclose(y, -1.0) or np.isclose(y, 1.0) or\n                    (np.isclose(x, 0.0) and y = 0.0) or\n                    (np.isclose(y, 0.0) and x >= 0.0)):\n                    boundary_nodes.add(i)\n\n            return nodes, elements, boundary_nodes\n\n    # --- FEM Solver ---\n    def assemble_and_solve(nodes, elements, boundary_nodes, exact_u_func):\n        num_nodes = len(nodes)\n        interior_nodes = sorted(list(set(range(num_nodes)) - boundary_nodes))\n        \n        # Map global node index to interior node index\n        interior_map = {global_idx: i for i, global_idx in enumerate(interior_nodes)}\n        num_interior = len(interior_nodes)\n\n        A = np.zeros((num_interior, num_interior))\n        F = np.zeros(num_interior)\n        U = np.zeros(num_nodes)\n\n        # Set known boundary values\n        for i in boundary_nodes:\n            U[i] = exact_u_func(nodes[i, 0], nodes[i, 1])\n\n        # Assemble stiffness matrix and load vector\n        for elem in elements:\n            v1, v2, v3 = nodes[elem[0]], nodes[elem[1]], nodes[elem[2]]\n            \n            # Using formula from FEM textbooks for element stiffness matrix\n            area = 0.5 * np.abs(v1[0]*(v2[1]-v3[1]) + v2[0]*(v3[1]-v1[1]) + v3[0]*(v1[1]-v2[1]))\n            \n            b = np.array([v2[1] - v3[1], v3[1] - v1[1], v1[1] - v2[1]])\n            c = np.array([v3[0] - v2[0], v1[0] - v3[0], v2[0] - v1[0]])\n            \n            # Element stiffness matrix\n            ke = (np.outer(b, b) + np.outer(c, c)) / (4.0 * area)\n\n            # Add to global system\n            for i_local in range(3):\n                i_global = elem[i_local]\n                is_i_interior = i_global in interior_map\n\n                for j_local in range(3):\n                    j_global = elem[j_local]\n                    is_j_interior = j_global in interior_map\n                    \n                    if is_i_interior and is_j_interior:\n                        A[interior_map[i_global], interior_map[j_global]] += ke[i_local, j_local]\n                    elif is_i_interior and not is_j_interior:\n                        F[interior_map[i_global]] -= ke[i_local, j_local] * U[j_global]\n        \n        # Solve for interior nodes\n        U_interior = np.linalg.solve(A, F)\n        for i, idx in enumerate(interior_nodes):\n            U[idx] = U_interior[i]\n            \n        return U\n\n    # --- Error Calculation ---\n    def compute_errors(nodes, elements, U_fem, exact_u_func, exact_grad_func):\n        l2_err_sq = 0.0\n        h1_err_sq = 0.0\n\n        for elem in elements:\n            v_indices = elem\n            v_coords = nodes[v_indices]\n            \n            # Centroid and area\n            centroid = np.mean(v_coords, axis=0)\n            area = 0.5 * np.abs(v_coords[0,0]*(v_coords[1,1]-v_coords[2,1]) + \n                                v_coords[1,0]*(v_coords[2,1]-v_coords[0,1]) + \n                                v_coords[2,0]*(v_coords[0,1]-v_coords[1,1]))\n\n            # L2 error term\n            u_exact_centroid = exact_u_func(centroid[0], centroid[1])\n            u_fem_centroid = np.mean(U_fem[v_indices])\n            l2_err_sq += area * (u_exact_centroid - u_fem_centroid)**2\n\n            # H1 error term\n            grad_u_exact_centroid = exact_grad_func(centroid[0], centroid[1])\n\n            b = np.array([v_coords[1,1] - v_coords[2,1], v_coords[2,1] - v_coords[0,1], v_coords[0,1] - v_coords[1,1]])\n            c = np.array([v_coords[2,0] - v_coords[1,0], v_coords[0,0] - v_coords[2,0], v_coords[1,0] - v_coords[0,0]])\n            \n            grad_phi = np.vstack((b, c)) / (2.0 * area) # Gradients of basis functions\n            grad_u_fem = np.dot(grad_phi, U_fem[v_indices])\n            \n            h1_err_sq += area * np.sum((grad_u_exact_centroid - grad_u_fem)**2)\n\n        return np.sqrt(l2_err_sq), np.sqrt(h1_err_sq)\n\n    # --- Convergence Rate Calculation ---\n    def calc_rate(err1, err2, h1, h2):\n        if err1 = 0 or err2 = 0: return 0.0\n        return np.log(err1 / err2) / np.log(h1 / h2)\n\n    # --- Main Loop ---\n    N_levels = [8, 16, 32]\n    all_results = []\n    \n    # Domain specs\n    domains = {\n        'sq': {'func_u': u_sq, 'func_grad': grad_u_sq, 'h_factor': 1.0},\n        'L':  {'func_u': u_L,  'func_grad': grad_u_L,  'h_factor': 2.0}\n    }\n    \n    for domain_name, spec in domains.items():\n        errors = {}\n        h_values = {}\n        for N in N_levels:\n            h = spec['h_factor'] / N\n            h_values[N] = h\n            \n            nodes, elements, bnd_nodes = generate_mesh(domain_name, N)\n            U = assemble_and_solve(nodes, elements, bnd_nodes, spec['func_u'])\n            l2_err, h1_err = compute_errors(nodes, elements, U, spec['func_u'], spec['func_grad'])\n            \n            errors[N] = {'l2': l2_err, 'h1': h1_err}\n            \n        rate_h1_8_16 = calc_rate(errors[8]['h1'], errors[16]['h1'], h_values[8], h_values[16])\n        rate_h1_16_32 = calc_rate(errors[16]['h1'], errors[32]['h1'], h_values[16], h_values[32])\n        all_results.append(rate_h1_8_16)\n        all_results.append(rate_h1_16_32)\n        \n        rate_l2_8_16 = calc_rate(errors[8]['l2'], errors[16]['l2'], h_values[8], h_values[16])\n        rate_l2_16_32 = calc_rate(errors[16]['l2'], errors[32]['l2'], h_values[16], h_values[32])\n        all_results.append(rate_l2_8_16)\n        all_results.append(rate_l2_16_32)\n        \n    formatted_results = [f\"{r:.3f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}