{
    "hands_on_practices": [
        {
            "introduction": "理解有限元方法 (FEM) 的收敛性质是数值分析的基石。此练习将引导您推导一个典型边值问题的 $H^1$ 范数和 $L^2$ 范数误差的收敛阶。通过运用 Céa 引理和 Aubin-Nitsche 对偶论证，您将揭示为什么 $L^2$ 误差通常比能量范数误差收敛得更快，这是 FEM 理论中的一个核心结果 。",
            "id": "3750597",
            "problem": "考虑单位区间上的一维齐次狄利克雷边界值问题：求函数 $u$，使得在 $(0,1)$ 内有 $-u'' = f$，且 $u(0) = u(1) = 0$。其中，右端项 $f$ 的选取使得精确解为\n$$\nu(x) = \\sin(\\pi x) + \\frac{1}{10}\\sin(10\\pi x).\n$$\n该精确解包含一个粗尺度分量 $\\sin(\\pi x)$ 和一个细尺度分量 $\\sin(10\\pi x)$，这是多尺度行为的典型代表。令 $V$ 为在端点处为零且其函数本身及一阶导数均平方可积的索博列夫空间，并令 $a(\\cdot,\\cdot)$ 为与该问题的弱形式相关的对称双线性形式。令 $V_h \\subset V$ 为在步长为 $h$ 的均匀网格上、在端点处为零的连续分片线性函数构成的协调子空间，并令 $u_h \\in V_h$ 表示通过标准有限元方法 (FEM) 获得的伽辽金近似解。\n\n从变分形式以及 $V$ 和 $L^2(0,1)$ 上范数的定义出发，利用协调分片线性元的插值理论以及双线性形式的强制性和有界性，建立当 $h \\to 0$ 时，有限元误差在 $H^1(0,1)$ 范数和 $L^2(0,1)$ 范数下的渐近收敛率。针对给定的 $u$ 显式地构造论证过程，并说明推导收敛率所需的任何正则性要求。您的推导应清楚地说明，在此示例中，为什么 $L^2(0,1)$ 误差比 $H^1(0,1)$ 误差收敛得更快。\n\n当 $h$ 足够小时，误差的主阶行为满足以下关系式，那么精确的指数 $p_{H^1}$ 和 $p_{L^2}$ 是什么？\n$$\n\\|u - u_h\\|_{H^1(0,1)} = \\mathcal{O}(h^{p_{H^1}}) \\quad \\text{和} \\quad \\|u - u_h\\|_{L^2(0,1)} = \\mathcal{O}(h^{p_{L^2}})?\n$$\n请将您的最终答案以包含 $(p_{H^1}, p_{L^2})$ 的行矩阵形式给出。",
            "solution": "该问题要求推导特定一维边界值问题的有限元近似的渐近收敛率。我们将首先验证问题的设置，然后基于标准有限元理论进行推导。\n\n问题表述如下：\n$$\n-u'' = f \\quad \\text{在 } (0,1) \\text{ 内}\n$$\n$$\nu(0) = u(1) = 0\n$$\n精确解由 $u(x) = \\sin(\\pi x) + \\frac{1}{10}\\sin(10\\pi x)$ 给出。由此，我们可以确定强迫函数 $f(x)$：\n$$\nu'(x) = \\pi\\cos(\\pi x) + \\pi\\cos(10\\pi x)\n$$\n$$\nu''(x) = -\\pi^2\\sin(\\pi x) - 100\\pi^2\\sin(10\\pi x)\n$$\n因此，$f(x) = -u''(x) = \\pi^2\\sin(\\pi x) + 100\\pi^2\\sin(10\\pi x)$。函数 $u(x)$ 及其任意阶导数在 $[0,1]$ 上都是连续的，因此是平方可积的。这意味着 $u \\in C^\\infty([0,1])$，进而对于任意整数 $k \\ge 0$ 都有 $u \\in H^k(0,1)$。这种高正则性对于后续分析至关重要。\n\n弱形式是通过将偏微分方程乘以一个检验函数 $v \\in V = H_0^1(0,1)$ 并在定义域 $(0,1)$ 上积分得到的。空间 $H_0^1(0,1)$ 是一个索博列夫空间，其中的函数属于 $L^2(0,1)$，其弱一阶导数属于 $L^2(0,1)$，并且满足齐次狄利克雷边界条件。\n$$\n-\\int_0^1 u''(x)v(x) dx = \\int_0^1 f(x)v(x) dx\n$$\n对左侧进行分部积分可得：\n$$\n\\int_0^1 u'(x)v'(x) dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x)v(x) dx\n$$\n由于 $v \\in H_0^1(0,1)$，有 $v(0)=v(1)=0$，边界项消失。这就得到了弱形式：求 $u \\in V$，使得\n$$\na(u,v) = L(v) \\quad \\forall v \\in V\n$$\n其中双线性形式为 $a(u,v) = \\int_0^1 u'(x)v'(x) dx$，线性泛函为 $L(v) = \\int_0^1 f(x)v(x) dx$。\n\n有限元方法在有限维子空间 $V_h \\subset V$ 中寻求近似解 $u_h$。这里，$V_h$ 是在步长为 $h$ 的均匀网格上，满足 $u_h(0) = u_h(1) = 0$ 的连续分片线性函数空间。伽辽金问题为：求 $u_h \\in V_h$，使得\n$$\na(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h\n$$\n将伽辽金问题从弱形式（使用检验函数 $v_h \\in V_h \\subset V$ 进行计算）中减去，我们得到误差 $e = u - u_h$ 的伽辽金正交性：\n$$\na(u - u_h, v_h) = a(u, v_h) - a(u_h, v_h) = L(v_h) - L(v_h) = 0 \\quad \\forall v_h \\in V_h\n$$\n\n**$H^1(0,1)$ 范数误差分析**\n\n$H^1$ 范数下的误差分析依赖于 Céa 引理。双线性形式 $a(v,v) = \\int_0^1 (v'(x))^2 dx = \\|v'\\|_{L^2}^2$。在空间 $V=H_0^1(0,1)$ 上，庞加莱不等式指出，存在一个常数 $C_P$ 使得 $\\|v\\|_{L^2} \\le C_P \\|v'\\|_{L^2}$。这意味着 $H^1$ 范数 $\\|v\\|_{H^1} = (\\|v\\|_{L^2}^2 + \\|v'\\|_{L^2}^2)^{1/2}$ 等价于由 $a(\\cdot,\\cdot)$ 导出的半范数，即 $\\|v'\\|_{L^2}$。因此，双线性形式 $a(\\cdot,\\cdot)$ 在 $V$ 上是强制的。它也是有界的，因为 $|a(u,v)| = |\\int_0^1 u'v' dx| \\le \\|u'\\|_{L^2}\\|v'\\|_{L^2} \\le \\|u\\|_{H^1}\\|v\\|_{H^1}$。\n\nCéa 引理指出，对于一个强制且有界的双线性形式，伽辽金近似在能量范数下是准最优的。对于我们的问题，这等价于在 $H^1$ 范数下：\n$$\n\\|u - u_h\\|_{H^1} \\le C \\inf_{v_h \\in V_h} \\|u - v_h\\|_{H^1}\n$$\n其中常数 $C$ 与 $h$ 和 $u$ 无关。右边的项是 $u$ 在子空间 $V_h$ 中的最佳逼近误差。这个误差可以由一个特定选择的 $v_h$ 的误差来界定，即 $u$ 的节点插值，记为 $\\Pi_h u$。\n$$\n\\inf_{v_h \\in V_h} \\|u - v_h\\|_{H^1} \\le \\|u - \\Pi_h u\\|_{H^1}\n$$\n对于协调的、分片线性 ($P_1$) 的有限元，标准的插值理论给出了以下估计，前提是解 $u$ 具有足够的正则性（具体来说，$u \\in H^2(0,1)$）：\n$$\n\\|u - \\Pi_h u\\|_{H^1(0,1)} \\le C_I h \\|u\\|_{H^2(0,1)}\n$$\n如前所述，我们的精确解 $u(x) = \\sin(\\pi x) + \\frac{1}{10}\\sin(10\\pi x)$ 属于 $C^\\infty([0,1])$，所以它肯定属于 $H^2(0,1)$。因此，条件得到满足。结合这些不等式，我们得到误差的 $H^1$ 范数的最终估计：\n$$\n\\|u - u_h\\|_{H^1(0,1)} \\le C \\cdot C_I h \\|u\\|_{H^2(0,1)}\n$$\n由于对于给定问题 $\\|u\\|_{H^2(0,1)}$ 是一个固定的常数，误差的行为如下：\n$$\n\\|u - u_h\\|_{H^1(0,1)} = \\mathcal{O}(h^1)\n$$\n这确立了 $H^1$ 范数下收敛率的指数为 $p_{H^1} = 1$。\n\n**$L^2(0,1)$ 范数误差分析**\n\n为了获得 $L^2$ 范数下的收敛率，我们采用 Aubin-Nitsche 对偶论证。令误差为 $e = u - u_h$。我们想要估计 $\\|e\\|_{L^2}$。我们引入一个辅助（对偶）问题：求 $\\phi \\in V = H_0^1(0,1)$，使得\n$$\n-\\phi'' = e \\quad \\text{在 } (0,1) \\text{ 内}\n$$\n边界条件为 $\\phi(0) = \\phi(1) = 0$。该对偶问题的弱形式为：求 $\\phi \\in V$，使得\n$$\na(v, \\phi) = \\int_0^1 v' \\phi' dx = \\int_0^1 e v dx = (e, v)_{L^2} \\quad \\forall v \\in V\n$$\n对于一维问题（或更一般地，对于凸域上的问题），这个椭圆偏微分方程表现出完全的正则性。这意味着对于 $L^2(0,1)$ 中的右端项，解属于 $H^2(0,1)$，并且存在一个常数 $C_R$ 使得：\n$$\n\\|\\phi\\|_{H^2(0,1)} \\le C_R \\|e\\|_{L^2(0,1)}\n$$\n现在，通过在对偶弱形式中设置 $v=e$，我们来表示误差的 $L^2$ 范数的平方：\n$$\n\\|e\\|_{L^2}^2 = (e,e)_{L^2} = a(e, \\phi)\n$$\n利用伽辽金正交性，对于任何 $v_h \\in V_h$，都有 $a(e, v_h) = a(u-u_h, v_h) = 0$。我们可以减去这个零项：\n$$\n\\|e\\|_{L^2}^2 = a(e, \\phi - v_h) \\quad \\forall v_h \\in V_h\n$$\n利用双线性形式的有界性（对导数使用柯西-施瓦茨不等式）：\n$$\n\\|e\\|_{L^2}^2 = \\int_0^1 e'(\\phi - v_h)' dx \\le \\|e'\\|_{L^2} \\|\\phi' - v_h'\\|_{L^2} \\le \\|e\\|_{H^1} \\|\\phi - v_h\\|_{H^1}\n$$\n这个不等式对任何 $v_h \\in V_h$ 都成立。我们做出一个明智的选择，令 $v_h = \\Pi_h \\phi$，即对偶解 $\\phi$ 的分片线性插值。\n$$\n\\|e\\|_{L^2}^2 \\le \\|e\\|_{H^1} \\|\\phi - \\Pi_h \\phi\\|_{H^1}\n$$\n我们对 $\\|\\phi - \\Pi_h \\phi\\|_{H^1}$ 应用插值误差估计。由于椭圆正则性保证了 $\\phi \\in H^2(0,1)$，我们有：\n$$\n\\|\\phi - \\Pi_h \\phi\\|_{H^1} \\le C_I h \\|\\phi\\|_{H^2}\n$$\n将此代入 $\\|e\\|_{L^2}^2$ 的不等式中：\n$$\n\\|e\\|_{L^2}^2 \\le \\|e\\|_{H^1} (C_I h \\|\\phi\\|_{H^2})\n$$\n现在，代入椭圆正则性估计 $\\|\\phi\\|_{H^2} \\le C_R \\|e\\|_{L^2}$：\n$$\n\\|e\\|_{L^2}^2 \\le \\|e\\|_{H^1} (C_I h C_R \\|e\\|_{L^2})\n$$\n假设 $\\|e\\|_{L^2} \\neq 0$，我们可以两边同除以 $\\|e\\|_{L^2}$：\n$$\n\\|e\\|_{L^2} \\le (C_I C_R) h \\|e\\|_{H^1}\n$$\n最后，我们代入 $H^1$ 误差分析的结果，即 $\\|e\\|_{H^1} = \\|u-u_h\\|_{H^1} = \\mathcal{O}(h)$：\n$$\n\\|u - u_h\\|_{L^2} \\le (\\text{const} \\cdot h) \\cdot \\mathcal{O}(h) = \\mathcal{O}(h^2)\n$$\n这确立了 $L^2$ 范数下的收敛率，其指数为 $p_{L^2} = 2$。\n\n在 $L^2$ 范数下更快的收敛速度是对偶论证的直接结果。其核心思想是，误差的 $L^2$ 范数可以与误差的 $H^1$ 范数乘以对偶解的插值误差相关联。这个插值误差引入了一个额外的因子 $h$，导致收敛阶比 $H^1$ 的收敛率高一阶。这关键地依赖于对偶问题的 $H^2$ 正则性，而对于本问题，该正则性是成立的。\n\n当解具有足够的正则性时（如此处所示），所推导出的收敛率 $p_{H^1}=1$ 和 $p_{L^2}=2$ 是二阶椭圆问题连续分片线性有限元近似的标准最优收敛率。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1   2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论上的收敛率虽至关重要，但实际计算中可能会出现数值不稳定现象。本练习聚焦于一种被称为“沙漏”的常见问题，该问题源于单元积分的减缩。您将通过构造一个零能模式来亲手验证这种不稳定性，并分析一种稳定化技术如何通过惩罚这些非物理变形来恢复解的稳定性 。",
            "id": "3750617",
            "problem": "考虑一个定义在方形域上的单一同参双线性四边形单元（通常表示为 $Q_1$）的平面应变线弹性问题，该方形域边长为 $L$，厚度为常数 $t$。材料是均匀的，其 Lamé 参数为 $\\lambda$ 和 $\\mu$。位移场通过有限元方法（FEM）进行近似，使用母正方形 $[-1,1] \\times [-1,1]$ 上的标准双线性形函数 $N_i(\\xi,\\eta)$，并通过 $x = \\frac{L}{2} \\xi$ 和 $y = \\frac{L}{2} \\eta$ 映射到物理坐标。线弹性的弱形式导出单元刚度矩阵为 $K_e = \\int_{\\Omega_e} B^{\\top} D B \\, d\\Omega$，其中 $B$ 是应变-位移矩阵，$D$ 是用 $\\lambda$ 和 $\\mu$ 表示的平面应变弹性矩阵。\n\n在减缩积分下，单元刚度通过在中心 $(\\xi,\\eta)=(0,0)$ 处的单个 Gauss 点近似为 $K_e^{\\mathrm{RI}} = B(0,0)^{\\top} D B(0,0) \\, A$，其中 $A = L^2$ 是单元面积。众所周知，这种欠积分会引入伪零能模式（沙漏模式）。\n\n1. 显式构造一个具有八个分量的节点位移模式 $d = [u_1^x, u_1^y, u_2^x, u_2^y, u_3^x, u_3^y, u_4^x, u_4^y]^{\\top}$，该模式在 $K_e^{\\mathrm{RI}}$ 下产生零应变能，并在 $B(0,0)$ 的层面上验证它是一个零能模式。仅使用双线性形函数及其在 $(0,0)$ 处导数的基本定义，以及上述的同参映射。\n\n2. 为消除沙漏模式，考虑在单元层面添加以下稳定化能：\n$$\nE_s(d) = \\alpha \\, t \\, \\frac{1}{L^2} \\left( \\left(u_1^x - u_2^x + u_3^x - u_4^x\\right)^2 + \\left(u_1^y - u_4^y + u_3^y - u_2^y\\right)^2 \\right),\n$$\n其中 $\\alpha0$ 是一个稳定化参数，其单位的选择使得 $E_s$ 的单位为能量。将相应的稳定化刚度记为 $K_s$，其定义为 $E_s(d) = \\frac{1}{2} d^{\\top} K_s d$。\n\n计算稳定化刚度 $K_e^{\\mathrm{RI}} + K_s$ 在由第1部分中构造的两个伪模式所张成的沙漏子空间上的最小正特征值，并以封闭形式给出。将最终答案表示为关于 $\\alpha$、$t$ 和 $L$ 的符号解析表达式。\n\n最后，从第一性原理出发，简要解释为什么减缩积分会容许您构造的伪模式，以及上述稳定化方法或选择性积分如何通过改变离散算子使得沙漏子空间获得正刚度来解决这个问题。\n\n您的最终答案必须是单个封闭形式的解析表达式。不需要四舍五入，最终表达式中也不应包含单位。",
            "solution": "所提出的问题是有效的，因为它科学地基于连续介质力学和有限元方法（FEM）的原理，是适定的、客观的且自洽的。它代表了计算力学中一个典型问题，即关于欠积分单元中的数值伪影“沙漏”现象及其稳定化。我们开始进行解答。\n\n问题分三部分解决：首先，构造一个伪零能（沙漏）模式；其次，计算稳定化刚度矩阵在沙漏子空间上的特征值；第三，提供一个概念性解释。\n\n**第1部分：零能沙漏模式的构造**\n\n单元内的位移场 $\\{u^x, u^y\\}$ 是通过双线性形函数 $N_i(\\xi, \\eta)$ 从节点位移 $d = [u_1^x, u_1^y, u_2^x, u_2^y, u_3^x, u_3^y, u_4^x, u_4^y]^{\\top}$ 插值得到的：\n$$\nu^x(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) u_i^x \\quad , \\quad u^y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) u_i^y\n$$\n假设母单元 $[-1,1] \\times [-1,1]$ 采用标准的逆时针节点编号：节点1位于 $( -1, -1)$，节点2位于 $(1, -1)$，节点3位于 $(1, 1)$，节点4位于 $(-1, 1)$。形函数为：\n$N_1 = \\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_2 = \\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_3 = \\frac{1}{4}(1+\\xi)(1+\\eta)$, $N_4 = \\frac{1}{4}(1-\\xi)(1+\\eta)$。\n\n从母坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的映射由 $x = \\frac{L}{2} \\xi$ 和 $y = \\frac{L}{2} \\eta$ 给出。此变换的 Jacobian 矩阵是常数：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\frac{L}{2}  0 \\\\ 0  \\frac{L}{2} \\end{pmatrix}\n$$\n逆 Jacobian 矩阵为 $J^{-1} = \\begin{pmatrix} \\frac{2}{L}  0 \\\\ 0  \\frac{2}{L} \\end{pmatrix}$。形函数关于物理坐标的导数可通过链式法则求得：$\\left( \\frac{\\partial N_i}{\\partial x}, \\frac{\\partial N_i}{\\partial y} \\right)^\\top = J^{-1} \\left( \\frac{\\partial N_i}{\\partial \\xi}, \\frac{\\partial N_i}{\\partial \\eta} \\right)^\\top$。\n\n应变-位移矩阵 $B$ 通过 $\\varepsilon = B d$ 将应变向量 $\\varepsilon = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$ 与节点位移向量 $d$ 联系起来。减缩积分在单元中心 $(\\xi, \\eta) = (0,0)$ 处计算 $B$。我们需要 $N_i$ 在该点的导数：\n$$\n\\left. \\frac{\\partial N_1}{\\partial \\xi} \\right|_{(0,0)} = -\\frac{1}{4}, \\quad \\left. \\frac{\\partial N_1}{\\partial \\eta} \\right|_{(0,0)} = -\\frac{1}{4}\n$$\n$$\n\\left. \\frac{\\partial N_2}{\\partial \\xi} \\right|_{(0,0)} = \\frac{1}{4}, \\quad \\left. \\frac{\\partial N_2}{\\partial \\eta} \\right|_{(0,0)} = -\\frac{1}{4}\n$$\n$$\n\\left. \\frac{\\partial N_3}{\\partial \\xi} \\right|_{(0,0)} = \\frac{1}{4}, \\quad \\left. \\frac{\\partial N_3}{\\partial \\eta} \\right|_{(0,0)} = \\frac{1}{4}\n$$\n$$\n\\left. \\frac{\\partial N_4}{\\partial \\xi} \\right|_{(0,0)} = -\\frac{1}{4}, \\quad \\left. \\frac{\\partial N_4}{\\partial \\eta} \\right|_{(0,0)} = \\frac{1}{4}\n$$\n中心点应变向量的分量为：\n$$\n\\varepsilon_{xx}(0,0) = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial x}(0,0) u_i^x = \\frac{2}{L} \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi}(0,0) u_i^x = \\frac{1}{2L}(-u_1^x + u_2^x + u_3^x - u_4^x)\n$$\n$$\n\\varepsilon_{yy}(0,0) = \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial y}(0,0) u_i^y = \\frac{2}{L} \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta}(0,0) u_i^y = \\frac{1}{2L}(-u_1^y - u_2^y + u_3^y + u_4^y)\n$$\n$$\n\\gamma_{xy}(0,0) = \\sum_{i=1}^4 \\left( \\frac{\\partial N_i}{\\partial y}(0,0) u_i^x + \\frac{\\partial N_i}{\\partial x}(0,0) u_i^y \\right) = \\frac{1}{2L}[(-u_1^x - u_2^x + u_3^x + u_4^x) + (-u_1^y + u_2^y + u_3^y - u_4^y)]\n$$\n零能模式是一个非刚体位移向量 $d$，它在积分点处产生零应变，即 $\\varepsilon(0,0) = B(0,0)d=0$。这要求上述所有三个应变分量都为零。\n\n已知典型的沙漏模式与在节点处采样的常数场和线性场正交。让我们构造一个位移模式 $d^h$，其 x-位移在母单元上取与 $\\xi\\eta$ 成比例的值，而 y-位移为零。对于比例因子为1和节点1, 2, 3, 4，$u^x \\propto \\xi\\eta$ 的节点值为 $[1, -1, 1, -1]^\\top$。因此我们测试节点位移向量：\n$$\nd = [1, 0, -1, 0, 1, 0, -1, 0]^{\\top}\n$$\n验证这是一个零能模式：\n$$\n\\varepsilon_{xx}(0,0) \\propto -u_1^x + u_2^x + u_3^x - u_4^x = -1 + (-1) + 1 - (-1) = 0\n$$\n$$\n\\varepsilon_{yy}(0,0) \\propto -u_1^y - u_2^y + u_3^y + u_4^y = 0 \\text{ (因为所有 } u_i^y=0)\n$$\n$$\n\\gamma_{xy}(0,0) \\propto (-u_1^x - u_2^x + u_3^x + u_4^x) + (-u_1^y + u_2^y + u_3^y - u_4^y) = (-1 - (-1) + 1 + (-1)) + 0 = 0\n$$\n中心点的所有三个应变分量均为零。这是一个非刚体运动，因此它是一个伪零能模式。第二个正交的沙漏模式可以类似地为 y-位移构造：$[0, 1, 0, -1, 0, 1, 0, -1]^\\top$。问题要求构造一个这样的模式，我们已经完成了。\n\n**第2部分：稳定化刚度矩阵的特征值**\n\n沙漏子空间 $S$ 由上面确定的两个模式张成。我们定义该子空间的基向量：\n$$\nv_1 = [1, 0, -1, 0, 1, 0, -1, 0]^{\\top}\n$$\n$$\nv_2 = [0, 1, 0, -1, 0, 1, 0, -1]^{\\top}\n$$\n这些向量是正交的，$v_1^{\\top} v_2 = 0$，并且其范数的平方为 $\\|v_1\\|^2 = v_1^{\\top}v_1 = 4$ 和 $\\|v_2\\|^2 = v_2^{\\top}v_2 = 4$。\n\n稳定化刚度矩阵是 $K_{stab} = K_e^{\\mathrm{RI}} + K_s$。我们关心的是它在子空间 $S$ 上的特征值。对于任何向量 $d \\in S$，$d$ 位于 $K_e^{\\mathrm{RI}}$ 的零空间中，这意味着 $K_e^{\\mathrm{RI}}d = 0$。因此，子空间 $S$ 上的特征值问题简化为：\n$$\nK_s d = \\lambda d \\quad \\text{for } d \\in S\n$$\n稳定化能由 $E_s(d) = \\frac{1}{2} d^{\\top} K_s d$ 给出。问题提供了 $E_s(d)$ 的表达式：\n$$\nE_s(d) = \\alpha \\, t \\, \\frac{1}{L^2} \\left( \\left(u_1^x - u_2^x + u_3^x - u_4^x\\right)^2 + \\left(u_1^y - u_4^y + u_3^y - u_2^y\\right)^2 \\right)\n$$\n项 $u_1^y - u_4^y + u_3^y - u_2^y$ 是 $u_1^y - u_2^y + u_3^y - u_4^y$ 的重新排序。这两个分量可以写成与我们基向量的内积：\n$$\nu_1^x - u_2^x + u_3^x - u_4^x = v_1^{\\top} d\n$$\n$$\nu_1^y - u_2^y + u_3^y - u_4^y = v_2^{\\top} d\n$$\n因此，稳定化能为：\n$$\nE_s(d) = \\frac{\\alpha t}{L^2} \\left( (v_1^{\\top} d)^2 + (v_2^{\\top} d)^2 \\right)\n$$\n根据稳定化刚度矩阵的定义 $E_s(d) = \\frac{1}{2} d^{\\top} K_s d$，并代入上面得到的 $E_s$ 表达式，我们有：\n$$\n\\frac{1}{2} d^{\\top} K_s d = \\frac{\\alpha t}{L^2} \\left( (v_1^{\\top} d)^2 + (v_2^{\\top} d)^2 \\right) = d^{\\top} \\left[ \\frac{\\alpha t}{L^2} (v_1 v_1^{\\top} + v_2 v_2^{\\top}) \\right] d\n$$\n由于这对所有 $d$ 都成立，比较二次型可得：\n$$\nK_s = \\frac{2\\alpha t}{L^2} (v_1 v_1^{\\top} + v_2 v_2^{\\top})\n$$\n让我们找出 $K_s$ 对基向量 $v_1$ 和 $v_2$ 的作用。\n$$\nK_s v_1 = \\frac{2\\alpha t}{L^2} (v_1 v_1^{\\top} + v_2 v_2^{\\top}) v_1 = \\frac{2\\alpha t}{L^2} (v_1(v_1^{\\top}v_1) + v_2(v_2^{\\top}v_1))\n$$\n使用 $v_1^{\\top}v_1 = 4$ 和 $v_2^{\\top}v_1 = 0$：\n$$\nK_s v_1 = \\frac{2\\alpha t}{L^2} (v_1 \\cdot 4 + v_2 \\cdot 0) = \\frac{8\\alpha t}{L^2} v_1\n$$\n这表明 $v_1$ 是 $K_s$ 的一个特征向量，其特征值为 $\\lambda_1 = \\frac{8\\alpha t}{L^2}$。\n类似地，对于 $v_2$：\n$$\nK_s v_2 = \\frac{2\\alpha t}{L^2} (v_1 v_1^{\\top} + v_2 v_2^{\\top}) v_2 = \\frac{2\\alpha t}{L^2} (v_1(v_1^{\\top}v_2) + v_2(v_2^{\\top}v_2))\n$$\n使用 $v_1^{\\top}v_2 = 0$ 和 $v_2^{\\top}v_2 = 4$：\n$$\nK_s v_2 = \\frac{2\\alpha t}{L^2} (v_1 \\cdot 0 + v_2 \\cdot 4) = \\frac{8\\alpha t}{L^2} v_2\n$$\n这表明 $v_2$ 是 $K_s$ 的一个特征向量，其特征值为 $\\lambda_2 = \\frac{8\\alpha t}{L^2}$。\n由于子空间 $S$ 的两个基向量都是具有相同特征值的特征向量，因此任何向量 $d \\in S$ 也是具有该特征值的特征向量。沙漏子空间是 $K_s$ 的一个二维特征空间，对应于单一特征值 $\\frac{8\\alpha t}{L^2}$。由于 $\\alpha  0$，该特征值为正。因此，它是 $K_s$ 在 $S$ 上的最小（也是唯一）的正特征值。\n\n**第3部分：概念解释**\n\n减缩积分导致伪零能模式，因为它无法准确地感知某些变形模式。单元的应变能是应变能密度在单元体积上的积分。非零变形应产生正应变能，除非它是刚体运动。数值积分将此积分近似为在少数几个 Gauss 点处被积函数的加权和。对于减缩积分（例如，对于双线性四边形单元使用单点积分），零能量的条件从要求处处应变为零放宽到仅要求在该单点处应变为零。沙漏模式是特殊的变形模式，例如在第1部分中构造的那种，其对应的应变场在单元域上非零，但恰好在用于积分的中心点处为零。数值积分方案对这些模式是“盲目”的，给它们分配了零应变能，这使得（在考虑边界条件后）全局刚度矩阵奇异，并允许解中出现不受控制的、物理上无意义的振荡。\n\n稳定化方法纠正了这一缺陷。问题中描述的方法是一种沙漏控制形式。它的工作原理是向单元的势能中添加一个罚能量项 $E_s$。该项被精心构造，以使其对于所有良好行为的变形模式（刚体运动和常应变状态）为零，但对于伪沙漏模式为正。这是通过创建一个离散算子（例如 $v_1^{\\top} d$）来实现的，该算子测量节点位移中沙漏模式的大小。增加的能量项导致一个附加的刚度矩阵 $K_s$，它在沙漏子空间上是正定的，但在“好”模式的子空间上为零。当加到原始的秩亏减缩积分刚度矩阵 $K_e^{\\mathrm{RI}}$ 上时，组合矩阵 $K_e^{\\mathrm{RI}} + K_s$ 对所有非刚体模式都变为正定，从而恢复了单元的稳定性并消除了伪解。\n\n选择性积分是另一种方法。它涉及对畸变能表达式中的不同项使用不同的求积规则。通常，引起体积“闭锁”的项被欠积分，而控制剪切变形（与沙漏有关）的项被完全积分。这样有选择性地仅加劲必要的变形模式以抑制沙漏，而不会重新引入闭锁，从而提供了一种优雅的解决方案，且无需任意的稳定化参数 $\\alpha$。",
            "answer": "$$\n\\boxed{\\frac{8 \\alpha t}{L^2}}\n$$"
        },
        {
            "introduction": "误差分析的最终目标之一是指导我们进行更高效的计算。本练习将理论付诸实践，要求您构建一个分层基误差估计器，用以实现自适应网格细化。通过编写程序来识别和细化误差最大的单元，您将学会如何利用后验误差指示子来创建能够自动将计算资源集中在最需要区域的智能算法 。",
            "id": "3750568",
            "problem": "考虑在闭区间 $[0,1]$ 上定义的具有齐次狄利克雷边界条件的一维标量椭圆边值问题。设 $\\Omega = [0,1]$，并考虑其弱形式：求 $u \\in H_0^1(\\Omega)$，使得\n$$\n\\int_0^1 \\kappa(x) \\, u'(x) \\, v'(x) \\, dx = \\int_0^1 f(x) \\, v(x) \\, dx \\quad \\text{对于所有 } v \\in H_0^1(\\Omega) \\text{ 成立},\n$$\n其中 $\\kappa(x)$ 是一个一致为正的扩散系数，$f(x)$ 是一个给定的源项。使用有限元法 (FEM)，在一个包含 $N$ 个单元和节点 $x_0=0, x_1, \\dots, x_N=1$ 的均匀网格上，采用连续分片线性（也称为 $P1$）基函数对该问题进行离散化。\n\n对此 $P1$ 离散化，在每个单元上使用一个局部的二次气泡函数，构建一个分层基误差估计器 (HBEE)。具体而言，设 $T = [x_i, x_{i+1}]$ 表示一个长度为 $h = x_{i+1}-x_i$ 的单元，并定义局部层次气泡函数 $\\phi_T(x)$ 为\n$$\n\\phi_T(x) = \\frac{4 (x - x_i) (x_{i+1} - x)}{h^2} \\quad \\text{对于 } x \\in T,\n$$\n且当 $x \\notin T$ 时，$\\phi_T(x) = 0$。单元 $T$ 上的分层估计量由标量 $\\alpha_T$ 决定，该标量通过求解局部层次方程得到\n$$\nd_T \\, \\alpha_T = R_T,\n$$\n其中\n$$\nd_T = \\int_T \\kappa(x) \\, \\left(\\phi_T'(x)\\right)^2 \\, dx,\n\\quad\nR_T = \\int_T f(x) \\, \\phi_T(x) \\, dx - \\int_T \\kappa(x) \\, u_h'(x) \\, \\phi_T'(x) \\, dx,\n$$\n且 $u_h$ 是 $P1$ 有限元解。局部指示器定义为\n$$\n\\eta_T = \\sqrt{\\alpha_T^2 d_T} = \\frac{|R_T|}{\\sqrt{d_T}},\n$$\n单元细化是通过将 $\\eta_T$ 与网格上最大指示器相关的标记阈值进行比较来决定的。\n\n从上述基本弱形式和 $P1$ 空间的定义出发，编写一个程序，该程序能够：\n- 对于给定的 $\\kappa(x)$ 和 $f(x)$，在具有 $N$ 个单元的均匀网格上组装并求解 $P1$ 有限元系统，并强制执行 $u(0) = 0$ 和 $u(1) = 0$。\n- 使用单元气泡函数 $\\phi_T$ 构建 HBEE，并为每个单元计算 $R_T$ 和 $d_T$，在需要时使用数值稳定的求积方法。\n- 计算局部指示器 $\\eta_T$，并标记所有满足 $\\eta_T \\ge \\theta \\cdot \\max_{T'} \\eta_{T'}$ 的单元 $T$ 以进行细化，其中 $\\theta \\in (0,1)$ 是给定的标记分数。\n- 为每个测试用例输出被标记单元的索引列表（使用从零开始的索引，即最左边的单元索引为 $0$）。\n\n使用以下测试套件来验证您的实现。对于每个用例，都指定了 $\\kappa(x)$ 和 $f(x)$，以及单元数 $N$ 和标记分数 $\\theta$。\n\n- 测试用例 1 (多尺度对比度场景):\n  - 域离散化: $N = 8$ 个单元。\n  - 扩散: $\\kappa(x) = \\begin{cases} 1  \\text{若 } x  0.5, \\\\ 100  \\text{若 } x \\ge 0.5. \\end{cases}$\n  - 源项: $f(x) = \\sin(2 \\pi x)$，其中角度以弧度为单位。\n  - 标记分数: $\\theta = 0.4$。\n- 测试用例 2 (带跳跃的分段载荷):\n  - 域离散化: $N = 8$ 个单元。\n  - 扩散: $\\kappa(x) \\equiv 1$。\n  - 源项: $f(x) = \\begin{cases} 0  \\text{若 } x  0.75, \\\\ 10  \\text{若 } x \\ge 0.75. \\end{cases}$\n  - 标记分数: $\\theta = 0.5$。\n- 测试用例 3 (粗网格基线):\n  - 域离散化: $N = 2$ 个单元。\n  - 扩散: $\\kappa(x) \\equiv 1$。\n  - 源项: $f(x) = x$。\n  - 标记分数: $\\theta = 0.3$。\n\n您的程序应生成单行输出，其中包含所有测试用例的细化决策，格式为一个由整数列表组成的逗号分隔列表，并用方括号括起来。例如，输出格式必须完全如下所示：\n$$\n[\\,[i_1,i_2,\\dots],\\,[j_1,j_2,\\dots],\\,[k_1,k_2,\\dots]\\,]\n$$\n其中 $[i_1,i_2,\\dots]$ 是测试用例 1 的索引，$[j_1,j_2,\\dots]$ 是测试用例 2 的索引，$[k_1,k_2,\\dots]$ 是测试用例 3 的索引。如果在某个测试用例中没有单元被标记，则为该用例输出一个空列表。",
            "solution": "用户提供的问题陈述已经过审查并被认为是有效的。这是一个在偏微分方程数值分析领域中的适定问题，具体涉及有限元法 (FEM) 和后验误差估计。该问题具有科学依据、内容自洽，并且所有术语和参数都得到了明确定义。任务是为一个一维椭圆问题实现一个标准的 P1 有限元求解器和一个分层基误差估计器 (HBEE)，并使用它根据指定的标记策略来识别用于自适应网格细化的单元。\n\n解决方案将分三个主要阶段进行开发：\n1.  使用 P1 有限元法对连续问题进行离散化。\n2.  使用分层基方法计算每个单元的后验误差指示器。\n3.  应用 Dörfler 标记策略来标记需要细化的单元。\n\n下文将详细介绍每个阶段。\n\n**1. P1 有限元离散化**\n\n问题以其弱形式陈述：求 $u \\in H_0^1(\\Omega)$，使得对所有 $v \\in H_0^1(\\Omega)$，都有 $a(u,v) = l(v)$ 成立，其中 $\\Omega=[0,1]$，双线性形式为 $a(u,v) = \\int_0^1 \\kappa(x) u'(x) v'(x) dx$，线性泛函为 $l(v) = \\int_0^1 f(x) v(x) dx$。空间 $H_0^1(\\Omega)$ 是索博列夫空间 (Sobolev space)，其中的函数具有平方可积的一阶导数，并在边界 $x=0$ 和 $x=1$ 处为零。\n\n我们用一个包含 $N$ 个单元的均匀网格来离散化区域 $\\Omega$，从而得到 $N+1$ 个节点 $x_i = i/N$（对于 $i=0, \\dots, N$）。单元长度为 $h=1/N$。有限元法在一个有限维子空间 $V_h \\subset H_0^1(\\Omega)$ 中寻求近似解 $u_h$。对于 P1 方法，$V_h$ 是该网格上在 $x=0$ 和 $x=1$ 处为零的连续分片线性函数的空间。$V_h$ 的一组基由“帽子”函数集合 $\\{\\psi_j\\}_{j=1}^{N-1}$ 给出，其中 $\\psi_j(x)$ 是唯一的分片线性函数，满足 $\\psi_j(x_j)=1$ 且当 $k \\ne j$ 时 $\\psi_j(x_k)=0$。\n\n近似解写为这些基函数的线性组合：\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\psi_j(x)\n$$\n其中 $U_j = u_h(x_j)$ 是待确定的未知节点值。伽辽金法 (Galerkin method) 将此展开式代入弱形式，并对每个基函数 $\\psi_i$ 进行测试：\n$$\na\\left(\\sum_{j=1}^{N-1} U_j \\psi_j(x), \\psi_i(x)\\right) = l(\\psi_i(x)) \\quad \\text{对于 } i=1, \\dots, N-1\n$$\n这产生了一个线性方程组 $A \\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ 是未知节点值的向量，刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的各项为：\n$$\nA_{ij} = a(\\psi_j, \\psi_i) = \\int_0^1 \\kappa(x) \\psi_j'(x) \\psi_i'(x) dx\n$$\n$$\nb_i = l(\\psi_i) = \\int_0^1 f(x) \\psi_i(x) dx\n$$\n由于 P1 基函数的局部支集特性，矩阵 $A$ 是对称、正定且三对角的。$A_{ij}$ 和 $b_i$ 的积分是逐单元计算然后组装的。由于 $\\kappa(x)$ 和 $f(x)$ 可能不是多项式，因此采用数值求积（特别是高斯-勒让德求积法）来高精度地计算这些积分。一旦组装完成，就求解系统 $A \\mathbf{U} = \\mathbf{b}$ 以求得 $\\mathbf{U}$。完整的有限元解向量则为 $[0, U_1, \\dots, U_{N-1}, 0]^T$。\n\n**2. 分层基误差估计**\n\n后验误差估计器提供了一种局部测量离散误差的方法。分层基误差估计器 (HBEE) 通过考虑一个更丰富的函数空间来估计误差。在每个单元 $T=[x_i, x_{i+1}]$ 上，我们用一个局部的“气泡”函数 $\\phi_T(x)$ 来扩充 P1 空间，该函数在单元节点处为零，在单元内部不为零。给定的气泡函数是一个二次多项式：\n$$\n\\phi_T(x) = \\frac{4 (x - x_i) (x_{i+1} - x)}{h^2} \\quad \\text{for } x \\in T\n$$\n其导数为 $\\phi_T'(x) = \\frac{4}{h^2}(x_{i+1}+x_i - 2x)$。通过用这些气泡函数来检验计算出的解 $u_h$，并测量其在多大程度上不满足原始弱方程，从而来估计误差。这种不满足程度由残差 $R_T$ 捕捉：\n$$\nR_T = l(\\phi_T) - a(u_h, \\phi_T) = \\int_T f(x) \\phi_T(x) dx - \\int_T \\kappa(x) u_h'(x) \\phi_T'(x) dx\n$$\n$R_T$ 项表示真实误差在气泡函数 $\\phi_T$ 方向上的分量。我们通过求解单元 $T$ 上的一个局部一维问题来找到该误差分量的大小 $\\alpha_T$：\n$$\na(\\alpha_T \\phi_T, \\phi_T) = R_T \\implies \\alpha_T \\left( \\int_T \\kappa(x) (\\phi_T'(x))^2 dx \\right) = R_T\n$$\n这给出了方程 $d_T \\alpha_T = R_T$，其中 $d_T = a(\\phi_T, \\phi_T)$。局部误差指示器 $\\eta_T$ 定义为此误差分量 $\\alpha_T \\phi_T$ 的能量范数：\n$$\n\\eta_T^2 = a(\\alpha_T \\phi_T, \\alpha_T \\phi_T) = \\alpha_T^2 a(\\phi_T, \\phi_T) = \\alpha_T^2 d_T = \\left(\\frac{R_T}{d_T}\\right)^2 d_T = \\frac{R_T^2}{d_T}\n$$\n$$\n\\eta_T = \\frac{|R_T|}{\\sqrt{d_T}}\n$$\n对网格中的每个单元 $T$ 都执行此计算。$R_T$ 和 $d_T$ 的积分也使用高斯-勒让德求积法进行计算。注意，在单元 $T$ 上，P1 解的导数 $u_h'(x)$ 是一个常数。\n\n**3. 自适应标记策略**\n\n一旦所有单元的局部误差指示器 $\\eta_T$ 计算完毕，就必须决定要细化哪些单元。问题指定了 Dörfler 标记策略。该策略旨在细化对总误差贡献最大的那部分单元。如果一个单元 $T$ 的指示器 $\\eta_T$ 大于整个网格中找到的最大指示器的一小部分 $\\theta$，则该单元被标记为需要细化：\n$$\n\\text{标记单元 } T \\text{ 若 } \\eta_T \\ge \\theta \\cdot \\max_{T' \\in \\mathcal{T}} \\eta_{T'}\n$$\n其中 $\\mathcal{T}$ 是网格中所有单元的集合，$\\theta \\in (0,1)$ 是给定的标记分数。这种策略确保计算资源集中在解分辨率较差的区域，例如奇异点、陡峭梯度或问题系数/源项不连续的区域附近。\n\n最终的算法通过为每个提供的测试用例实现这三个阶段来继续进行，生成一个标记为需要细化的、从零开始索引的单元列表。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# The problem statement specifies the following environment:\n# language: Python, version: 3.12\n# libraries:\n# - name: numpy, version: 1.23.5\n# - name: scipy, version: 1.11.4\n#\n# This solution uses only numpy, which is sufficient.\n# The code is runnable as a self-contained script.\n\ndef get_quadrature_points(a, b, n_points=5):\n    \"\"\"\n    Get Gauss-Legendre quadrature points and weights for interval [a, b].\n    \"\"\"\n    points, weights = np.polynomial.legendre.leggauss(n_points)\n    # Map points from [-1, 1] to [a, b]\n    mapped_points = 0.5 * (b - a) * points + 0.5 * (b + a)\n    mapped_weights = 0.5 * (b - a) * weights\n    return mapped_points, mapped_weights\n\ndef integrate(func, a, b, n_points=5):\n    \"\"\"\n    Numerically integrate a function func over [a, b] using Gauss-Legendre quadrature.\n    \"\"\"\n    points, weights = get_quadrature_points(a, b, n_points)\n    func_vals = func(points)\n    return np.sum(func_vals * weights)\n\ndef solve_case(N, kappa_func, f_func, theta):\n    \"\"\"\n    Solves one instance of the FEM problem and returns marked elements.\n    \"\"\"\n    # 1. MESH and FEM SETUP\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    num_dof = N - 1 # Interior nodes only\n\n    if num_dof == 0: # N=1 case, no internal nodes\n        return []\n\n    A = np.zeros((num_dof, num_dof))\n    b = np.zeros(num_dof)\n    \n    # 2. ASSEMBLE STIFFNESS MATRIX A and LOAD VECTOR b\n    # A is tridiagonal: A_ii, A_{i,i-1}, A_{i,i+1}\n    for i in range(1, N): # Global node index of the DOF\n        # Diagonal entry A_{i-1, i-1}\n        # Integral over element T_{i-1} and T_i\n        int_kappa_left = integrate(kappa_func, nodes[i-1], nodes[i])\n        int_kappa_right = integrate(kappa_func, nodes[i], nodes[i+1])\n        A[i-1, i-1] = (1/h**2) * (int_kappa_left + int_kappa_right)\n\n        # Off-diagonal entries\n        if i > 1:\n            A[i-1, i-2] = -(1/h**2) * int_kappa_left\n        if i  N - 1:\n            A[i-1, i] = -(1/h**2) * int_kappa_right\n\n        # Load vector entry b_{i-1}\n        # psi_i(x) on [x_{i-1}, x_i] is (x-x_{i-1})/h\n        # psi_i(x) on [x_i, x_{i+1}] is (x_{i+1}-x)/h\n        def psi_i_left(x): return (x - nodes[i-1]) / h\n        def psi_i_right(x): return (nodes[i+1] - x) / h\n        \n        int_f_psi_left = integrate(lambda x: f_func(x) * psi_i_left(x), nodes[i-1], nodes[i])\n        int_f_psi_right = integrate(lambda x: f_func(x) * psi_i_right(x), nodes[i], nodes[i+1])\n        b[i-1] = int_f_psi_left + int_f_psi_right\n\n    # 3. SOLVE for u_h\n    U_internal = np.linalg.solve(A, b)\n    U_full = np.concatenate(([0], U_internal, [0]))\n\n    # 4. COMPUTE ERROR INDICATORS\n    indicators = np.zeros(N)\n    for i in range(N): # Iterate over elements T_i\n        xi, xi1 = nodes[i], nodes[i+1]\n        \n        # Define local bubble function and its derivative\n        def phi_T(x):\n            return 4 * (x - xi) * (xi1 - x) / h**2\n        def phi_T_prime(x):\n            return (4 / h**2) * (xi1 + xi - 2*x)\n\n        # Compute d_T = integral(kappa * (phi_T')^2) dx\n        d_T_integrand = lambda x: kappa_func(x) * phi_T_prime(x)**2\n        d_T = integrate(d_T_integrand, xi, xi1)\n\n        # Compute R_T = integral(f*phi_T)dx - integral(kappa*u_h'*phi_T')dx\n        f_phi_integral = integrate(lambda x: f_func(x) * phi_T(x), xi, xi1)\n        \n        # u_h' is constant on element T_i\n        u_h_prime_val = (U_full[i+1] - U_full[i]) / h\n        \n        kappa_uhp_phip_integrand = lambda x: kappa_func(x) * u_h_prime_val * phi_T_prime(x)\n        res_integral_part2 = integrate(kappa_uhp_phip_integrand, xi, xi1)\n        \n        R_T = f_phi_integral - res_integral_part2\n        \n        if d_T > 1e-15: # Avoid division by zero\n            eta_T = abs(R_T) / math.sqrt(d_T)\n        else:\n            eta_T = 0.0\n        \n        indicators[i] = eta_T\n\n    # 5. MARK ELEMENTS FOR REFINEMENT\n    marked_elements = []\n    if len(indicators) > 0:\n        max_indicator = np.max(indicators)\n        if max_indicator > 1e-15: # Proceed only if there is non-zero error\n            threshold = theta * max_indicator\n            for i in range(N):\n                if indicators[i] >= threshold:\n                    marked_elements.append(i)\n    \n    return marked_elements\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    # Vectorize functions to handle numpy arrays from quadrature\n    \n    # Test Case 1\n    kappa1 = np.vectorize(lambda x: 100.0 if x >= 0.5 else 1.0)\n    f1 = np.vectorize(lambda x: math.sin(2 * math.pi * x))\n    \n    # Test Case 2\n    kappa2 = np.vectorize(lambda x: 1.0)\n    f2 = np.vectorize(lambda x: 10.0 if x >= 0.75 else 0.0)\n\n    # Test Case 3\n    kappa3 = np.vectorize(lambda x: 1.0)\n    f3 = np.vectorize(lambda x: x)\n\n    test_cases = [\n        {'N': 8, 'kappa': kappa1, 'f': f1, 'theta': 0.4},\n        {'N': 8, 'kappa': kappa2, 'f': f2, 'theta': 0.5},\n        {'N': 2, 'kappa': kappa3, 'f': f3, 'theta': 0.3},\n    ]\n\n    results = []\n    for case in test_cases:\n        marked = solve_case(case['N'], case['kappa'], case['f'], case['theta'])\n        results.append(marked)\n\n    # Format the output string precisely as required: [[1,2],[3],[]]\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}