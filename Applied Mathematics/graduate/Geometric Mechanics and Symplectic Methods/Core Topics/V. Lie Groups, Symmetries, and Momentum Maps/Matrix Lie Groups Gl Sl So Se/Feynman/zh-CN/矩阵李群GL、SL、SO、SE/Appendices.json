{
    "hands_on_practices": [
        {
            "introduction": "理解指数映射是掌握李代数与其李群之间联系的基础。本练习为最简单的非平凡旋转群 $SO(2)$ 提供了一个具体的计算实践，明确展示了斜对称矩阵的李代数如何生成平面旋转群 。掌握这个例子是建立处理更复杂群的直觉所必需的。",
            "id": "3755442",
            "problem": "令 $SO(2)$ 表示特殊正交群 (SO)，其定义为 $SO(2)=\\{R\\in GL(2,\\mathbb{R}) \\mid R^{\\top}R=I,\\ \\det(R)=1\\}$，令 $\\mathfrak{so}(2)$ 表示其李代数，其定义为 $\\mathfrak{so}(2)=\\{X\\in \\mathbb{R}^{2\\times 2} \\mid X^{\\top}=-X\\}$。$X\\in\\mathfrak{so}(2)$ 的矩阵指数定义为 $\\exp(X)=\\sum_{k=0}^{\\infty}\\frac{1}{k!}X^{k}$。在平面几何力学中，一个恒定的角速度由一个斜对称生成元 $X\\in\\mathfrak{so}(2)$ 表示，其在单位时间后的有限旋转由 $\\exp(X)$ 给出。\n\n仅使用上述定义和标准的线性代数知识，完成以下任务：\n- 证明指数映射 $\\exp:\\mathfrak{so}(2)\\to SO(2)$ 是满射的，即对于每一个 $R\\in SO(2)$，都存在一个 $X\\in\\mathfrak{so}(2)$ 使得 $R=\\exp(X)$。\n- 令 $J\\in\\mathfrak{so}(2)$ 为由 $J=\\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}$ 定义的斜对称生成元，并令 $\\theta\\in\\mathbb{R}$。计算矩阵指数 $\\exp(\\theta J)$ 的显式闭式表达式。\n\n你的最终答案必须是 $\\exp(\\theta J)$ 的单一闭式表达式，并尽可能简化。不需要数值近似。",
            "solution": "首先验证问题陈述的正确性和可解性。\n\n### 第 1 步：提取已知条件\n- 特殊正交群 $SO(2)$ 的定义：$SO(2)=\\{R\\in GL(2,\\mathbb{R}) \\mid R^{\\top}R=I,\\ \\det(R)=1\\}$。\n- 其李代数 $\\mathfrak{so}(2)$ 的定义：$\\mathfrak{so}(2)=\\{X\\in \\mathbb{R}^{2\\times 2} \\mid X^{\\top}=-X\\}$。\n- 矩阵指数的定义：$\\exp(X)=\\sum_{k=0}^{\\infty}\\frac{1}{k!}X^{k}$，对于 $X\\in \\mathfrak{so}(2)$。\n- 斜对称生成元 $J$ 的定义：$J=\\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}$。\n- 参数 $\\theta \\in \\mathbb{R}$。\n- 任务 1：证明指数映射 $\\exp:\\mathfrak{so}(2)\\to SO(2)$ 是满射的。\n- 任务 2：计算 $\\exp(\\theta J)$ 的显式闭式表达式。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，因为 $SO(2)$、$\\mathfrak{so}(2)$ 和矩阵指数的定义在李群理论及其在几何力学中的应用中都是标准的。该问题是适定的，具有明确的定义和目标，可以得出一个唯一的计算解和一个标准的满射性证明。术语精确且客观。没有矛盾、缺失信息或不切实际的前提。该问题是其领域内的一个基础练习，并且在数学上是可验证的。\n\n### 第 3 步：结论和行动\n问题有效。将提供一个完整、有理有据的解答。\n\n### 解答\n解答将按照问题陈述的要求分为两个主要部分。首先，我们将计算 $\\exp(\\theta J)$ 的显式表达式，因为这个结果对于第二部分（即满射性的证明）至关重要。\n\n**第 1 部分：计算 $\\exp(\\theta J)$**\n\n我们被要求求出矩阵指数 $\\exp(\\theta J)$ 的闭式表达式，其中 $J = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix}$ 且 $\\theta \\in \\mathbb{R}$。矩阵 $X = \\theta J = \\begin{pmatrix} 0  -\\theta \\\\ \\theta  0 \\end{pmatrix}$ 是 $\\mathfrak{so}(2)$ 的一个元素，因为 $(\\theta J)^{\\top} = \\theta J^{\\top} = \\theta \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} = -\\theta J$。\n\n矩阵指数由幂级数定义：\n$$\n\\exp(\\theta J) = \\sum_{k=0}^{\\infty} \\frac{1}{k!}(\\theta J)^k = \\sum_{k=0}^{\\infty} \\frac{\\theta^k}{k!} J^k\n$$\n为计算此级数，我们首先研究矩阵 $J$ 的幂：\n$J^0 = I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$\n$J^1 = J = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix}$\n$J^2 = J J = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = -I$\n$J^3 = J^2 J = (-I)J = -J$\n$J^4 = J^2 J^2 = (-I)(-I) = I$\n\n$J$ 的幂是周期性的，周期为 $4$：$\\{I, J, -I, -J, \\dots\\}$。现在我们可以展开 $\\exp(\\theta J)$ 的级数：\n$$\n\\exp(\\theta J) = \\frac{\\theta^0}{0!}J^0 + \\frac{\\theta^1}{1!}J^1 + \\frac{\\theta^2}{2!}J^2 + \\frac{\\theta^3}{3!}J^3 + \\frac{\\theta^4}{4!}J^4 + \\dots\n$$\n代入 $J$ 的幂：\n$$\n\\exp(\\theta J) = I + \\theta J - \\frac{\\theta^2}{2!}I - \\frac{\\theta^3}{3!}J + \\frac{\\theta^4}{4!}I + \\dots\n$$\n我们可以将与单位矩阵 $I$ 相关的项和与矩阵 $J$ 相关的项分组：\n$$\n\\exp(\\theta J) = \\left(1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots\\right)I + \\left(\\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots\\right)J\n$$\n括号中的两个级数分别是余弦函数和正弦函数的麦克劳林级数：\n$\\cos(\\theta) = \\sum_{k=0}^{\\infty} \\frac{(-1)^k \\theta^{2k}}{(2k)!} = 1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\dots$\n$\\sin(\\theta) = \\sum_{k=0}^{\\infty} \\frac{(-1)^k \\theta^{2k+1}}{(2k+1)!} = \\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots$\n\n因此，我们可以将 $\\exp(\\theta J)$ 的表达式写成紧凑形式：\n$$\n\\exp(\\theta J) = \\cos(\\theta)I + \\sin(\\theta)J\n$$\n代入 $I$ 和 $J$ 的矩阵表示：\n$$\n\\exp(\\theta J) = \\cos(\\theta)\\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + \\sin(\\theta)\\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} \\cos(\\theta)  0 \\\\ 0  \\cos(\\theta) \\end{pmatrix} + \\begin{pmatrix} 0  -\\sin(\\theta) \\\\ \\sin(\\theta)  0 \\end{pmatrix}\n$$\n这简化为最终的闭式表达式：\n$$\n\\exp(\\theta J) = \\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix}\n$$\n这就完成了问题的第二项任务。\n\n**第 2 部分：满射性证明**\n\n我们必须证明指数映射 $\\exp: \\mathfrak{so}(2) \\to SO(2)$ 是满射的。这意味着对于任意矩阵 $R \\in SO(2)$，都存在一个矩阵 $X \\in \\mathfrak{so}(2)$ 使得 $\\exp(X) = R$。\n\n首先，我们来刻画 $SO(2)$ 中的一个一般元素 $R$。令 $R = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$。其定义性质是 $R^{\\top}R=I$ 和 $\\det(R)=1$。第一个性质意味着：\n$$\nR^{\\top}R = \\begin{pmatrix} a  c \\\\ b  d \\end{pmatrix}\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix} = \\begin{pmatrix} a^2+c^2  ab+cd \\\\ ab+cd  b^2+d^2 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n这给出了条件：$a^2+c^2=1$，$b^2+d^2=1$ 和 $ab+cd=0$。\n条件 $a^2+c^2=1$ 允许我们用一个角度 $\\phi \\in \\mathbb{R}$ 来参数化 $a$ 和 $c$，使得 $a = \\cos(\\phi)$ 且 $c = \\sin(\\phi)$。\n条件 $\\det(R)=ad-bc=1$ 变为 $d\\cos(\\phi) - b\\sin(\\phi)=1$。\n条件 $ab+cd=0$ 变为 $b\\cos(\\phi) + d\\sin(\\phi)=0$。\n我们得到一个关于 $b$ 和 $d$ 的二元线性方程组：\n1) $d\\cos(\\phi) - b\\sin(\\phi)=1$\n2) $d\\sin(\\phi) + b\\cos(\\phi)=0$\n将(1)式乘以 $\\cos(\\phi)$，(2)式乘以 $\\sin(\\phi)$，然后相加，得到：\n$d(\\cos^2(\\phi)+\\sin^2(\\phi)) = \\cos(\\phi) \\implies d=\\cos(\\phi)$。\n将(1)式乘以 $-\\sin(\\phi)$，(2)式乘以 $\\cos(\\phi)$，然后相加，得到：\n$b(\\sin^2(\\phi)+\\cos^2(\\phi)) = -\\sin(\\phi) \\implies b=-\\sin(\\phi)$。\n因此，任何矩阵 $R \\in SO(2)$ 都可以写成标准旋转矩阵的形式：\n$$\nR = \\begin{pmatrix} \\cos(\\phi)  -\\sin(\\phi) \\\\ \\sin(\\phi)  \\cos(\\phi) \\end{pmatrix}\n$$\n对于某个角度 $\\phi \\in \\mathbb{R}$。\n\n现在，我们需要找到一个 $X \\in \\mathfrak{so}(2)$ 使得 $\\exp(X)=R$。$\\mathfrak{so}(2)$ 中的一个一般元素具有形式 $X = \\theta J$，其中 $\\theta \\in \\mathbb{R}$。\n从第 1 部分，我们得到了 $\\exp(\\theta J)$ 的表达式：\n$$\n\\exp(\\theta J) = \\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix}\n$$\n为了实现 $\\exp(X) = R$，我们必须令这两个矩阵相等：\n$$\n\\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix} = \\begin{pmatrix} \\cos(\\phi)  -\\sin(\\phi) \\\\ \\sin(\\phi)  \\cos(\\phi) \\end{pmatrix}\n$$\n通过观察，我们可以通过选择 $\\theta = \\phi$ 来满足这个等式。\n因此，对于任何给定的 $R \\in SO(2)$，它对应于一个角度为 $\\phi$ 的旋转，我们可以选择矩阵 $X = \\phi J \\in \\mathfrak{so}(2)$。这个 $X$ 的指数是\n$$\n\\exp(X) = \\exp(\\phi J) = \\begin{pmatrix} \\cos(\\phi)  -\\sin(\\phi) \\\\ \\sin(\\phi)  \\cos(\\phi) \\end{pmatrix} = R\n$$\n因为对于陪域 $SO(2)$ 中的每一个元素 $R$，我们都在定义域 $\\mathfrak{so}(2)$ 中找到了一个原像 $X$，所以映射 $\\exp: \\mathfrak{so}(2) \\to SO(2)$ 是满射的。证明至此结束。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "矩阵李群不仅是抽象的结构，它们也为解决实际优化问题提供了几何语言。本练习要求您在 $SO(3)$ 中找到与一个任意可逆矩阵最接近的旋转矩阵，这是计算机视觉和机器人学等领域中姿态估计的核心问题 。其解决方案巧妙地将李群的抽象理论与我们熟知的极分解和奇异值分解 (SVD) 联系起来。",
            "id": "3755437",
            "problem": "设 $A \\in \\mathrm{GL}(3)$ 为矩阵\n$$\nA \\;=\\; R S \\,, \\quad R \\;=\\; \\mathrm{diag}(1,\\,1,\\,-1) \\,, \\quad S \\;=\\; \\mathrm{diag}(2,\\,1.5,\\,0.6) \\,,\n$$\n因此 $A = \\mathrm{diag}(2,\\,1.5,\\,-0.6)$ 且 $\\det(A)  0$。这里 $\\mathrm{GL}(n)$ 表示由可逆 $n \\times n$ 矩阵构成的一般线性群。考虑在弗罗贝尼乌斯范数 $\\|\\cdot\\|_{F}$下，寻找特殊正交群 $\\mathrm{SO}(3)$ 中与 $A$ 最接近的矩阵的问题（特殊正交群 $\\mathrm{SO}(3)$ 由行列式为 $+1$ 的 $3 \\times 3$ 实正交矩阵组成）。\n\n从极分解的基本定义出发（对于任何 $A \\in \\mathrm{GL}(n)$，存在唯一的分解 $A = Q S$，其中 $Q \\in \\mathrm{O}(n)$ 且 $S$ 是对称正定矩阵，$\\mathrm{O}(n)$ 是正交群），执行以下步骤：\n\n1. 通过极分解，仅使用极分解的定义和弗罗贝尼乌斯范数的性质，计算 $A$ 的正交极因子 $Q$ 和正定因子 $S$。\n\n2. 使用计算出的极因子和奇异值分解（奇异值分解 (SVD) 将 $A$写作 $A = U \\Sigma V^{\\top}$，其中 $U, V \\in \\mathrm{O}(n)$ 且 $\\Sigma$ 是具有正对角元的对角矩阵），确定一个候选矩阵 $\\widehat{Q} \\in \\mathrm{SO}(3)$，它在 $Q \\in \\mathrm{SO}(3)$ 上最小化 $\\|A - Q\\|_{F}$。\n\n3. 通过检查在 $\\mathrm{SO}(3)$ 上的约束最小化的一阶必要条件来验证你的 $\\widehat{Q}$ 的最优性：使用带有约束 $Q^{\\top} Q = I$ 的拉格朗日函数推导平稳性条件，并论证目标函数 $\\|A - Q\\|_{F}^{2}$ 在 $\\widehat{Q}$ 处沿切空间 $T_{\\widehat{Q}} \\mathrm{SO}(3)$ 中所有变分的方向导数都为零。\n\n最后，计算最小平方弗罗贝尼乌斯距离\n$$\n\\min_{Q \\in \\mathrm{SO}(3)} \\|A - Q\\|_{F}^{2}\n$$\n对于给定的 $A$。将你的最终标量答案表示为无舍入的精确值。",
            "solution": "问题要求在弗罗贝尼乌斯范数 $\\|\\cdot\\|_F$ 下，找到特殊正交群 $\\mathrm{SO}(3)$ 中与给定矩阵 $A \\in \\mathrm{GL}(3)$ 最接近的矩阵。给定矩阵为 $A = \\mathrm{diag}(2, 1.5, -0.6)$。我们被要求通过一系列指定步骤来解决这个问题。\n\n1.  **极分解的计算**\n\n问题要求计算 $A$ 的极分解。对于一个可逆矩阵 $A \\in \\mathrm{GL}(n)$，极分解是唯一的因式分解 $A = QP$，其中 $Q \\in \\mathrm{O}(n)$ 是一个正交矩阵，$P$ 是一个对称正定矩阵。\n\n矩阵 $P$ 被定义为 $A^T A$ 的唯一正定平方根，即 $P = \\sqrt{A^T A}$。\n给定矩阵为 $A = \\mathrm{diag}(2, 1.5, -0.6)$。\n由于 $A$ 是一个对角矩阵，它是对称的，所以 $A^T = A$。\n我们计算 $A^T A$：\n$$\nA^T A = A^2 = \\mathrm{diag}(2^2, 1.5^2, (-0.6)^2) = \\mathrm{diag}(4, 2.25, 0.36)\n$$\n矩阵 $P$ 是 $A^T A$ 的平方根。由于 $A^T A$ 是一个对角元为正的对角矩阵，其平方根可以通过对每个对角元取平方根得到：\n$$\nP = \\sqrt{A^T A} = \\mathrm{diag}(\\sqrt{4}, \\sqrt{2.25}, \\sqrt{0.36}) = \\mathrm{diag}(2, 1.5, 0.6)\n$$\n这个矩阵是对称的，并且它的特征值（对角元 $2$, $1.5$, $0.6$）都是正的，所以它是正定的。这个矩阵 $P$ 对应于问题陈述中给出的矩阵 $S$。\n\n然后可以从 $A = QP$ 计算正交因子 $Q$。由于 $P$ 是可逆的，我们有 $Q = AP^{-1}$。\n$P$ 的逆矩阵是：\n$$\nP^{-1} = \\mathrm{diag}(2^{-1}, 1.5^{-1}, 0.6^{-1}) = \\mathrm{diag}(\\frac{1}{2}, \\frac{1}{1.5}, \\frac{1}{0.6}) = \\mathrm{diag}(\\frac{1}{2}, \\frac{2}{3}, \\frac{5}{3})\n$$\n现在我们计算 $Q$：\n$$\nQ = AP^{-1} = \\mathrm{diag}(2, 1.5, -0.6) \\mathrm{diag}(\\frac{1}{2}, \\frac{2}{3}, \\frac{5}{3}) = \\mathrm{diag}(2 \\cdot \\frac{1}{2}, 1.5 \\cdot \\frac{2}{3}, -0.6 \\cdot \\frac{5}{3}) = \\mathrm{diag}(1, 1, -1)\n$$\n这个矩阵 $Q$ 是正交的，因为 $Q^T Q = \\mathrm{diag}(1, 1, -1) \\mathrm{diag}(1, 1, -1) = \\mathrm{diag}(1, 1, 1) = I$。这个矩阵 $Q$ 对应于问题陈述中的矩阵 $R$。\n因此，$A$ 的极因子是 $Q = \\mathrm{diag}(1, 1, -1)$ 和 $P = \\mathrm{diag}(2, 1.5, 0.6)$。\n\n2.  **确定候选矩阵 $\\widehat{Q} \\in \\mathrm{SO}(3)$**\n\n寻找 $\\mathrm{SO}(3)$ 中与 $A$ 最接近的矩阵的问题，等价于对 $\\widehat{Q} \\in \\mathrm{SO}(3)$ 最小化 $\\|A - \\widehat{Q}\\|_F^2$。我们展开平方范数：\n$$\n\\|A - \\widehat{Q}\\|_F^2 = \\mathrm{Tr}((A - \\widehat{Q})^T (A - \\widehat{Q})) = \\mathrm{Tr}(A^T A - A^T \\widehat{Q} - \\widehat{Q}^T A + \\widehat{Q}^T \\widehat{Q})\n$$\n由于 $\\widehat{Q} \\in \\mathrm{SO}(3)$，它是正交的，所以 $\\widehat{Q}^T \\widehat{Q} = I$。迹为 $\\mathrm{Tr}(I)=3$。此外，$\\mathrm{Tr}(\\widehat{Q}^T A) = \\mathrm{Tr}(A^T \\widehat{Q})$。表达式变为：\n$$\n\\|A - \\widehat{Q}\\|_F^2 = \\|A\\|_F^2 - 2 \\mathrm{Tr}(A^T \\widehat{Q}) + 3\n$$\n最小化这个量等价于最大化 $\\mathrm{Tr}(A^T \\widehat{Q})$。\n\n使用 $A$ 的奇异值分解 (SVD) $A = U \\Sigma V^T$，其中 $U, V \\in \\mathrm{O}(3)$ 且 $\\Sigma$ 是奇异值的对角矩阵，$\\mathrm{SO}(3)$ 中最接近的矩阵由公式 $\\widehat{Q} = U J V^T$ 给出，其中 $J = \\mathrm{diag}(1, 1, \\det(UV^T))$。\n\n我们来求 $A = \\mathrm{diag}(2, 1.5, -0.6)$ 的 SVD。奇异值 $(\\sigma_i)$ 是 $A^T A$ 特征值的平方根。我们已经计算出 $A^T A = \\mathrm{diag}(4, 2.25, 0.36)$。奇异值为 $\\sigma_1=2$, $\\sigma_2=1.5$, $\\sigma_3=0.6$。奇异值矩阵是 $\\Sigma = \\mathrm{diag}(2, 1.5, 0.6)$。\n矩阵 $V$ 包含 $A^T A$ 的特征向量。由于 $A^T A$ 是对角的，它的特征向量是标准基向量，所以我们可以设 $V=I$。\n矩阵 $U$ 由关系 $A = U \\Sigma V^T$ 确定。当 $V=I$ 时，这变为 $A = U \\Sigma$。\n$$\n\\mathrm{diag}(2, 1.5, -0.6) = U \\mathrm{diag}(2, 1.5, 0.6)\n$$\n这意味着 $U = \\mathrm{diag}(2/2, 1.5/1.5, -0.6/0.6) = \\mathrm{diag}(1, 1, -1)$。\n这些矩阵是 $U = \\mathrm{diag}(1, 1, -1)$，$\\Sigma = \\mathrm{diag}(2, 1.5, 0.6)$，和 $V=I$。我们注意到 $U$ 和 $V$ 确实是正交的。\n\n从 SVD 中，我们可以识别出极因子：$Q_{polar} = UV^T = \\mathrm{diag}(1,1,-1)I^T = \\mathrm{diag}(1,1,-1)$ 和 $P_{polar} = V \\Sigma V^T = I \\Sigma I^T = \\Sigma$，这与我们在第1部分的结果相符。\n\n为了找到 $\\mathrm{SO}(3)$ 中最接近的矩阵，我们计算 $\\det(UV^T) = \\det(U)\\det(V^T) = (-1)(1) = -1$。\n那么 $J = \\mathrm{diag}(1, 1, \\det(UV^T)) = \\mathrm{diag}(1, 1, -1)$。\n候选矩阵 $\\widehat{Q}$ 是：\n$$\n\\widehat{Q} = U J V^T = \\mathrm{diag}(1, 1, -1) \\mathrm{diag}(1, 1, -1) I^T = \\mathrm{diag}(1, 1, 1) = I\n$$\n单位矩阵 $I$ 属于 $\\mathrm{SO}(3)$，因为 $I^T I = I$ 且 $\\det(I)=1$。因此，我们的候选矩阵是 $\\widehat{Q}=I$。\n\n3.  **最优性验证**\n\n为了验证 $\\widehat{Q}=I$ 是一个最优解，我们检查约束优化的一阶必要条件。如果函数 $f(Q) = \\|A-Q\\|_F^2$ 的梯度在 $Q$ 处与 $\\mathrm{SO}(3)$ 的切空间正交，那么点 $Q \\in \\mathrm{SO}(3)$ 是一个平稳点。这等价于 $f$ 在切空间中所有方向上的方向导数都为零。\n\n在 $\\widehat{Q}=I$ 处 $\\mathrm{SO}(3)$ 的切空间是李代数 $\\mathfrak{so}(3)$，即所有 $3 \\times 3$ 实斜对称矩阵的空间。设 $X \\in \\mathfrak{so}(3)$ 为任意切向量。\n一条在 $\\mathrm{SO}(3)$ 上通过 $I$ 且速度为 $X$ 的曲线由 $\\gamma(t) = \\exp(tX)$ 给出。函数 $f(Q) = \\|A\\|_F^2 - 2 \\mathrm{Tr}(A^T Q) + 3$ 在 $Q=I$ 处沿方向 $X$ 的方向导数是：\n$$\n\\frac{d}{dt} f(\\exp(tX)) \\Big|_{t=0} = \\frac{d}{dt} \\left( \\|A\\|_F^2 - 2\\mathrm{Tr}(A^T \\exp(tX)) + 3 \\right) \\Big|_{t=0}\n$$\n$$\n= -2 \\mathrm{Tr}\\left(A^T \\frac{d}{dt}\\exp(tX)\\Big|_{t=0}\\right) = -2 \\mathrm{Tr}(A^T X)\n$$\n最优性的一阶条件是，对于所有 $X \\in \\mathfrak{so}(3)$，这个导数都为零。\n给定矩阵 $A = \\mathrm{diag}(2, 1.5, -0.6)$ 是对称的，所以 $A^T=A$。条件变为对于所有斜对称矩阵 $X$，$\\mathrm{Tr}(AX) = 0$。\n对于任何对称矩阵 $S$ 和任何斜对称矩阵 $K$，它们的迹积为零：$\\mathrm{Tr}(SK) = \\mathrm{Tr}((SK)^T) = \\mathrm{Tr}(K^T S^T)$。由于 $S^T=S$ 和 $K^T=-K$，这等于 $\\mathrm{Tr}(-KS) = -\\mathrm{Tr}(KS)$。迹的循环性质给出 $\\mathrm{Tr}(KS)=\\mathrm{Tr}(SK)$，所以我们有 $\\mathrm{Tr}(SK) = -\\mathrm{Tr}(SK)$，这意味着 $2\\mathrm{Tr}(SK)=0$，或 $\\mathrm{Tr}(SK)=0$。\n由于我们的矩阵 $A$ 是对称的，且任何 $X \\in \\mathfrak{so}(3)$ 都是斜对称的，条件 $\\mathrm{Tr}(AX) = 0$ 得到满足。这验证了 $\\widehat{Q}=I$ 是一个平稳点。\n对于具有不同奇异值的矩阵 $A$，在 $\\mathrm{SO}(n)$ 中寻找最接近矩阵的问题有唯一的全局解。由于我们的候选解满足一阶必要条件，因此它是最优解。\n\n**最终计算**\n\n最小平方弗罗贝尼乌斯距离是 $\\|A - \\widehat{Q}\\|_F^2$，其中 $\\widehat{Q} = I$。\n我们计算 $\\|A - I\\|_F^2$：\n$$\nA - I = \\mathrm{diag}(2, 1.5, -0.6) - \\mathrm{diag}(1, 1, 1) = \\mathrm{diag}(2-1, 1.5-1, -0.6-1) = \\mathrm{diag}(1, 0.5, -1.6)\n$$\n对角矩阵的弗罗贝尼乌斯范数的平方是其对角元素平方的和：\n$$\n\\|A-I\\|_F^2 = 1^2 + (0.5)^2 + (-1.6)^2 = 1 + 0.25 + 2.56 = 3.81\n$$\n这是一个精确值。\n或者，使用平方范数的表达式：$\\|A-\\widehat{Q}\\|_F^2 = \\|A\\|_F^2 - 2\\mathrm{Tr}(A^T \\widehat{Q}) + 3$。\n$\\|A\\|_F^2 = 2^2 + 1.5^2 + (-0.6)^2 = 4 + 2.25 + 0.36 = 6.61$。\n$\\mathrm{Tr}(A^T \\widehat{Q}) = \\mathrm{Tr}(A^T I) = \\mathrm{Tr}(A) = 2 + 1.5 - 0.6 = 2.9$。\n所以，最小平方距離是 $6.61 - 2(2.9) + 3 = 6.61 - 5.8 + 3 = 3.81$。\n结果是一致的。",
            "answer": "$$\n\\boxed{3.81}\n$$"
        },
        {
            "introduction": "当模拟状态在李群上演化的物理系统（如旋转刚体）时，标准的数值积分器往往无法保持群的几何结构。本练习将指导您使用贝克-坎贝尔-豪斯多夫 (BCH) 公式构建一个二阶李群积分器，这是一种用于复合群元素的精密工具 。这项实践对于在几何力学和机器人学中开发稳健的、保持结构的仿真至关重要。",
            "id": "3755449",
            "problem": "考虑特殊正交群 ($SO(3)$)，其定义为所有满足 $R^{\\top} R = I_3$ 和 $\\det(R) = 1$ 的实 $3 \\times 3$ 矩阵 $R$ 的集合。其李代数 $\\mathfrak{so}(3)$ 由所有 $3 \\times 3$ 实反对称矩阵组成。在几何力学中，刚体姿态的动力学可以建模为 $SO(3)$ 上的一个右不变常微分方程：\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega}(t), \\quad R(0) = I_3,\n$$\n其中 $\\omega(t) \\in \\mathbb{R}^3$ 是随时间变化的体角速度，而 $\\widehat{\\cdot} : \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ 是“帽”同构，对于 $v = (v_1, v_2, v_3)^{\\top}$ 定义为\n$$\n\\widehat{v} = \\begin{bmatrix}\n0  -v_3  v_2 \\\\\nv_3  0  -v_1 \\\\\n-v_2  v_1  0\n\\end{bmatrix}.\n$$\n你需要使用 Baker–Campbell–Hausdorff (BCH) 公式为此方程设计一个二阶精度的李群积分器。Baker–Campbell–Hausdorff (BCH) 公式给出了李代数中指数乘积的对数。对于与小参数 $h$ 线性相关的 $X, Y \\in \\mathfrak{so}(3)$，在步长上截断至二阶，其形式为\n$$\n\\mathrm{BCH}_2(X,Y) = X + Y + \\frac{1}{2}[X,Y],\n$$\n其中 $[X,Y] = XY - YX$ 是矩阵对易子。使用此公式，构建一个单步法，通过单个指数函数在时间步长 $h$ 内将 $R_k \\approx R(t_k)$推进到 $R_{k+1} \\approx R(t_{k+1})$：\n$$\nR_{k+1} = R_k \\exp\\left(\\Omega_k\\right),\n$$\n其中\n$$\n\\Omega_k = \\mathrm{BCH}_2\\!\\left(\\frac{h}{2}\\,\\widehat{\\omega}(t_k),\\,\\frac{h}{2}\\,\\widehat{\\omega}(t_{k+1})\\right).\n$$\n对于足够光滑的 $\\omega(t)$，该方法在步长 $h$ 上应具有全局二阶精度。应用于 $\\mathfrak{so}(3)$ 元素的矩阵指数 $\\exp(\\cdot)$ 应使用罗德里格斯公式实现。令 $\\mathrm{vee}:\\mathfrak{so}(3)\\to\\mathbb{R}^3$ 表示帽映射的逆映射，对于任意 $v \\in \\mathbb{R}^3$，定义 $\\mathfrak{so}(3)$ 上的指数映射为\n$$\n\\exp(\\widehat{v}) = I_3 + \\frac{\\sin \\theta}{\\theta}\\,\\widehat{v} + \\frac{1 - \\cos \\theta}{\\theta^2}\\,\\widehat{v}^2, \\quad \\theta = \\|v\\|.\n$$\n你的程序必须：\n- 在 $SO(3)$ 上实现上述基于 BCH 的二阶积分器。\n- 使用以弧度/秒表示的角速度 $\\omega(t)$。时间 $t$ 以秒为单位。所有角度必须以弧度处理。\n- 对于下面的每个测试用例，使用你的积分器计算最终的旋转矩阵 $R(T)$，并将其与参考解 $R_{\\mathrm{ref}}(T)$进行比较。报告差值的弗罗贝尼乌斯范数：\n$$\n\\varepsilon = \\|R(T) - R_{\\mathrm{ref}}(T)\\|_F.\n$$\n- 参考解 $R_{\\mathrm{ref}}(T)$ 要么是可用的精确解，要么是使用非常小的步长通过相同的基于 BCH 的积分器获得的高分辨率数值解。\n\n使用以下测试套件，每个套件由角速度函数 $\\omega(t)$、最终时间 $T$ 和步数 $N$ 指定：\n1. 边界条件（零运动）：$\\omega(t) = (0, 0, 0)$，$T = 1.0$，$N = 10$。参考解为 $R_{\\mathrm{ref}}(T) = I_3$。\n2. 常数对易情形：$\\omega(t) = (0, 0, 1.0)$，$T = 1.0$，$N = 40$。参考解为精确解 $R_{\\mathrm{ref}}(T) = \\exp\\left(\\widehat{(0,0,1.0)}\\,T\\right)$。\n3. 单轴时变对易情形：$\\omega(t) = (2.0\\,t, 0, 0)$，$T = 1.0$，$N = 100$。由于 $\\widehat{\\omega}(t)$ 始终沿同一轴，精确解为 $R_{\\mathrm{ref}}(T) = \\exp\\left(\\widehat{\\left(\\frac{2.0}{2}T^2, 0, 0\\right)}\\right)$。\n4. 非对易振荡情形：$\\omega(t) = (\\sin t, \\cos t, 0)$，$T = 2\\pi$，$N = 400$。参考解为使用相同基于 BCH 的方法以 $N_{\\mathrm{ref}} = 20000$ 计算得到的高分辨率数值解 $R_{\\mathrm{ref}}(T)$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3,result4]`）。每个结果必须是相应测试用例的 $\\varepsilon$ 的浮点值，以无量纲单位（矩阵范数）表示，并采用完整的 Python 默认浮点格式。不应打印其他任何文本。",
            "solution": "该问题要求为特殊正交群 $SO(3)$ 上的刚体动力学实现一个二阶李群积分器。分析和实现将按以下步骤进行：首先，我们将利用李代数 $\\mathfrak{so}(3)$ 的性质来简化积分器更新步骤的表达式。其次，我们将详细说明如何使用所提供的罗德里格斯公式实现矩阵指数映射，并特别注意数值稳定性。最后，我们将概述要实现的完整算法。\n\n控制常微分方程被给定为 $SO(3)$ 上的一个右不变系统：\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega}(t), \\quad R(0) = I_3\n$$\n其中 $R(t) \\in SO(3)$ 是姿态矩阵，$\\omega(t) \\in \\mathbb{R}^3$ 是体角速度，$\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ 是帽同构。对于向量 $v = (v_1, v_2, v_3)^{\\top} \\in \\mathbb{R}^3$，该映射定义为：\n$$\n\\widehat{v} = \\begin{bmatrix}\n0  -v_3  v_2 \\\\\nv_3  0  -v_1 \\\\\n-v_2  v_1  0\n\\end{bmatrix}\n$$\n李代数 $\\mathfrak{so}(3)$ 是 $3 \\times 3$ 实反对称矩阵的空间。对于任意 $u, v \\in \\mathbb{R}^3$，$\\mathfrak{so}(3)$ 上的矩阵对易子通过恒等式 $[\\widehat{u}, \\widehat{v}] = \\widehat{u \\times v}$ 对应于 $\\mathbb{R}^3$ 中的叉积。\n\n所提出的单步数值积分器使用以下公式将解从时间 $t_k$ 推进到 $t_{k+1} = t_k + h$：\n$$\nR_{k+1} = R_k \\exp(\\Omega_k)\n$$\n增量生成元 $\\Omega_k \\in \\mathfrak{so}(3)$ 使用二阶截断的 Baker–Campbell–Hausdorff (BCH) 公式计算：\n$$\n\\Omega_k = \\mathrm{BCH}_2\\!\\left(\\frac{h}{2}\\,\\widehat{\\omega}(t_k),\\,\\frac{h}{2}\\,\\widehat{\\omega}(t_{k+1})\\right) = X + Y + \\frac{1}{2}[X,Y]\n$$\n其中 $X = \\frac{h}{2}\\,\\widehat{\\omega}(t_k)$ 且 $Y = \\frac{h}{2}\\,\\widehat{\\omega}(t_{k+1})$。\n\n可以推导出一种计算效率更高的 $\\Omega_k$ 形式。令 $\\omega_k = \\omega(t_k)$ 和 $\\omega_{k+1} = \\omega(t_{k+1})$。利用帽映射的线性性质（$\\widehat{\\alpha u + \\beta v} = \\alpha\\widehat{u} + \\beta\\widehat{v}$）和对易子恒等式，我们可以将 $\\Omega_k$ 重写如下：\n$$\n\\Omega_k = \\frac{h}{2}\\widehat{\\omega}_k + \\frac{h}{2}\\widehat{\\omega}_{k+1} + \\frac{1}{2}\\left[\\frac{h}{2}\\widehat{\\omega}_k, \\frac{h}{2}\\widehat{\\omega}_{k+1}\\right]\n$$\n$$\n\\Omega_k = \\frac{h}{2}(\\widehat{\\omega}_k + \\widehat{\\omega}_{k+1}) + \\frac{h^2}{8}[\\widehat{\\omega}_k, \\widehat{\\omega}_{k+1}]\n$$\n$$\n\\Omega_k = \\widehat{\\frac{h}{2}(\\omega_k + \\omega_{k+1})} + \\frac{h^2}{8}\\widehat{(\\omega_k \\times \\omega_{k+1})}\n$$\n$$\n\\Omega_k = \\widehat{\\left( \\frac{h}{2}(\\omega_k + \\omega_{k+1}) + \\frac{h^2}{8}(\\omega_k \\times \\omega_{k+1}) \\right)}\n$$\n这个结果表明矩阵 $\\Omega_k$ 是单个向量的“帽”映射，我们将其记为 $\\delta v_k$：\n$$\n\\delta v_k = \\frac{h}{2}(\\omega_k + \\omega_{k+1}) + \\frac{h^2}{8}(\\omega_k \\times \\omega_{k+1})\n$$\n因此，$\\Omega_k$ 的计算简化为计算向量 $\\delta v_k$ 然后应用帽映射，即 $\\Omega_k = \\widehat{\\delta v_k}$。这避免了为计算对易子而进行的显式矩阵乘法。\n\n下一步是计算矩阵指数 $\\exp(\\Omega_k) = \\exp(\\widehat{\\delta v_k})$。这是通过对一个泛型 $\\widehat{v} \\in \\mathfrak{so}(3)$ 使用罗德里格斯公式来完成的：\n$$\n\\exp(\\widehat{v}) = I_3 + \\frac{\\sin \\theta}{\\theta}\\,\\widehat{v} + \\frac{1 - \\cos \\theta}{\\theta^2}\\,\\widehat{v}^2, \\quad \\theta = \\|v\\|_2\n$$\n直接实现此公式可能会因除以零或灾难性抵消而导致在 $\\theta$ 值较小时出现数值不稳定性。为确保稳健性，我们通过使用系数的泰勒级数展开来处理 $\\theta$ 接近零的情况：\n- 对于 $\\theta \\approx 0$，$\\frac{\\sin \\theta}{\\theta} \\approx 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120}$\n- 对于 $\\theta \\approx 0$，$\\frac{1 - \\cos \\theta}{\\theta^2} \\approx \\frac{1}{2} - \\frac{\\theta^2}{24} + \\frac{\\theta^4}{720}$\n可以使用一个阈值，例如 $\\theta  10^{-8}$，在直接公式和泰勒级数近似之间切换。如果 $\\theta = 0$，则 $v=0$，$\\widehat{v}=0$，且 $\\exp(\\widehat{v}) = I_3$。\n\n完整的积分算法如下：\n1. 初始化 $R_0 = I_3$ 和 $t_0 = 0$。步长为 $h = T/N$。\n2. 对于 $k$ 从 $0$ 到 $N-1$：\n    a. 确定时间点 $t_k = k h$ 和 $t_{k+1} = (k+1)h$。\n    b. 计算角速度 $\\omega_k = \\omega(t_k)$ 和 $\\omega_{k+1} = \\omega(t_{k+1})$。\n    c. 计算增量向量 $\\delta v_k = \\frac{h}{2}(\\omega_k + \\omega_{k+1}) + \\frac{h^2}{8}(\\omega_k \\times \\omega_{k+1})$。\n    d. 使用稳定的罗德里格斯公式计算增量旋转矩阵 $\\Delta R_k = \\exp(\\widehat{\\delta v_k})$。\n    e. 更新姿态：$R_{k+1} = R_k \\Delta R_k$。\n3. 在时间 $T$ 的最终姿态为 $R_N$。\n\n对于每个测试用例，将计算出的 $R(T) = R_N$ 与参考解 $R_{\\mathrm{ref}}(T)$进行比较。误差由差值的弗罗贝尼乌斯范数来量化：\n$$\n\\varepsilon = \\|R(T) - R_{\\mathrm{ref}}(T)\\|_F = \\sqrt{\\sum_{i=1}^3 \\sum_{j=1}^3 (R_{ij}(T) - (R_{\\mathrm{ref}})_{ij}(T))^2}\n$$\n实现将遵循这些原则来解决所提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a second-order Lie group integrator for SO(3) and evaluates it on a test suite.\n    \"\"\"\n\n    def hat(v):\n        \"\"\"\n        Maps a 3D vector to its corresponding 3x3 skew-symmetric matrix.\n        v: A 3-element array-like object.\n        Returns: A 3x3 numpy array.\n        \"\"\"\n        v = np.asarray(v)\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    def exp_so3(v):\n        \"\"\"\n        Computes the matrix exponential for so(3) using Rodrigues' formula.\n        Handles the small-angle case for numerical stability.\n        v: A 3-element array-like object representing the rotation vector.\n        Returns: A 3x3 rotation matrix.\n        \"\"\"\n        v = np.asarray(v)\n        theta = np.linalg.norm(v)\n\n        # Handle the case theta -> 0 to avoid division by zero and loss of precision.\n        # A threshold is used to switch to a Taylor series approximation.\n        if theta  1e-9:\n            # For small theta, use Taylor series for the coefficients.\n            # A = sin(theta)/theta ≈ 1 - theta^2/6 + theta^4/120\n            # B = (1-cos(theta))/theta^2 ≈ 1/2 - theta^2/24 + theta^4/720\n            v_hat = hat(v)\n            theta2 = theta**2\n            theta4 = theta**4\n            A = 1.0 - theta2 / 6.0 + theta4 / 120.0\n            B = 0.5 - theta2 / 24.0 + theta4 / 720.0\n            return np.identity(3) + A * v_hat + B * np.dot(v_hat, v_hat)\n\n        v_hat = hat(v)\n        A = np.sin(theta) / theta\n        B = (1.0 - np.cos(theta)) / (theta**2)\n        return np.identity(3) + A * v_hat + B * np.dot(v_hat, v_hat)\n\n    def run_integration(omega_func, T, N):\n        \"\"\"\n        Performs the numerical integration of the dynamics equation.\n        omega_func: A function that takes time t and returns the angular velocity vector.\n        T: Final time.\n        N: Number of steps.\n        Returns: The final rotation matrix R(T).\n        \"\"\"\n        h = T / N\n        R = np.identity(3)\n        \n        for k in range(N):\n            t_k = k * h\n            t_k_plus_1 = (k + 1) * h\n            \n            omega_k = np.asarray(omega_func(t_k))\n            omega_k_plus_1 = np.asarray(omega_func(t_k_plus_1))\n            \n            # Compute the increment vector delta_v_k based on the BCH formula simplification\n            delta_v_k = (h / 2.0) * (omega_k + omega_k_plus_1) + \\\n                        (h**2 / 8.0) * np.cross(omega_k, omega_k_plus_1)\n            \n            # Compute the incremental rotation and update the orientation\n            delta_R_k = exp_so3(delta_v_k)\n            R = np.dot(R, delta_R_k)\n            \n        return R\n\n    def frobenius_norm_diff(A, B):\n        \"\"\"\n        Computes the Frobenius norm of the difference between two matrices.\n        \"\"\"\n        return np.linalg.norm(A - B, 'fro')\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"omega_func\": lambda t: np.array([0.0, 0.0, 0.0]),\n            \"T\": 1.0, \"N\": 10,\n            \"ref_func\": lambda T, N: np.identity(3)\n        },\n        {\n            \"omega_func\": lambda t: np.array([0.0, 0.0, 1.0]),\n            \"T\": 1.0, \"N\": 40,\n            \"ref_func\": lambda T, N: exp_so3(np.array([0.0, 0.0, 1.0]) * T)\n        },\n        {\n            \"omega_func\": lambda t: np.array([2.0 * t, 0.0, 0.0]),\n            \"T\": 1.0, \"N\": 100,\n            \"ref_func\": lambda T, N: exp_so3(np.array([0.5 * 2.0 * T**2, 0.0, 0.0]))\n        },\n        {\n            \"omega_func\": lambda t: np.array([np.sin(t), np.cos(t), 0.0]),\n            \"T\": 2.0 * np.pi, \"N\": 400,\n            \"ref_func\": lambda T, N: run_integration(lambda t: np.array([np.sin(t), np.cos(t), 0.0]), T, 20000)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run the integrator for the current test case\n        R_T = run_integration(case[\"omega_func\"], case[\"T\"], case[\"N\"])\n        \n        # Compute the reference solution\n        R_ref = case[\"ref_func\"](case[\"T\"], case[\"N\"])\n        \n        # Calculate the Frobenius norm of the error\n        error = frobenius_norm_diff(R_T, R_ref)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}