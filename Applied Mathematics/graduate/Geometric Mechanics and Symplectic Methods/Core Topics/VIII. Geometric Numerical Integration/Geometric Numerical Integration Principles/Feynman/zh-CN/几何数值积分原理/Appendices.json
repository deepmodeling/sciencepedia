{
    "hands_on_practices": [
        {
            "introduction": "理解几何积分原理的第一步是亲身体验辛积分器与非辛积分器在长时间积分中的根本区别。本练习  提供了一个直接的、动手操作的比较，通过对简谐振子这个经典模型进行数值模拟，您将清晰地观察到两种方法在能量守恒方面的显著差异：非辛方法导致的能量长期漂移，与辛方法产生的有界能量误差振荡，从而揭示几何积分器的核心优势。",
            "id": "3743624",
            "problem": "考虑几何力学中的单自由度谐振子，其二次哈密顿量为 $H(q,p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right)$，其中 $q$ 是位形坐标，$p$ 是共轭动量，$\\omega \\ge 0$ 是角频率。其正则运动方程由哈密顿方程 $ \\dot{q} = \\frac{\\partial H}{\\partial p}$ 和 $ \\dot{p} = -\\frac{\\partial H}{\\partial q}$ 给出。目标是构建并比较一种非辛方法和一种辛方法，并量化长时间离散演化过程中的能量行为。本问题中所有量均为无量纲；无需物理单位或角度单位。\n\n从该系统的哈密顿方程出发，实现以下两种时间步长为 $h$ 的单步数值方法：\n- 一种非辛方法：应用于哈密顿方程的显式欧拉法。\n- 一种辛方法：辛欧拉法（半隐式，每个步骤中先更新动量，再更新位置）。\n\n对于给定的初始条件 $(q_0,p_0)$、角频率 $\\omega$ 和时间步长 $h$，将两个离散系统演化 $N = 10^4$ 步。对每种方法和每个测试用例，计算以下定量诊断指标：\n1. 最终相对能量误差，定义为 $(H_N/H_0) - 1$，其中 $H_k = \\frac{1}{2}\\left(p_k^2 + \\omega^2 q_k^2\\right)$ 是第 $k$ 步的离散能量，$H_0$ 是初始能量。\n2. 整个轨迹上的最大相对能量偏差，定义为 $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$。\n\n使用正则二次哈密顿量，并确保离散更新是从上述指定的基本定义和定律推导出来的，不引入任何特殊修改或外部稳定化。\n\n测试套件：\n对以下参数集评估诊断指标，每个参数集都演化 $N = 10^4$ 步：\n- 测试 A（一般情况）：$\\omega = 1.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$。\n- 测试 B（更高频率）：$\\omega = 3.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$。\n- 测试 C（零频率边界情况）：$\\omega = 0.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 1.0$。\n- 测试 D（更小时间步长）：$\\omega = 1.0$, $h = 0.001$, $q_0 = 1.0$, $p_0 = 1.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例应贡献一个包含四个浮点数的列表，顺序为 $[\\text{final\\_rel\\_err\\_non\\_symplectic}, \\text{max\\_rel\\_dev\\_non\\_symplectic}, \\text{final\\_rel\\_err\\_symplectic}, \\text{max\\_rel\\_dev\\_symplectic}]$。因此，最终输出必须类似于 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$，其中每个 $a_i$、$b_i$、$c_i$ 和 $d_i$ 都是浮点数。",
            "solution": "该问题是适定的，有科学依据，并包含了获得唯一解所需的所有信息。所考虑的系统是单自由度谐振子，这是经典力学和几何力学中的一个典范模型。任务是比较非辛积分器（显式欧拉法）与辛积分器（辛欧拉法）的长期能量守恒性质。\n\n首先，我们从指定的哈密顿量推导连续运动方程。哈密顿量由下式给出\n$$ H(q, p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right) $$\n其中 $q$ 是位置，$p$ 是动量，$\\omega$ 是角频率。哈密顿运动方程为\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} \\quad \\text{和} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} $$\n计算 $H$ 的偏导数，我们得到谐振子的特定常微分方程组（ODEs）：\n$$ \\dot{q} = p $$\n$$ \\dot{p} = -\\omega^2 q $$\n这可以写成向量形式 $\\frac{d}{dt}\\mathbf{z} = \\mathbf{f}(\\mathbf{z})$，其中 $\\mathbf{z} = (q, p)^T$。\n\n现在，我们将使用指定的两种数值方法，以时间步长 $h$ 对该系统进行离散化。第 $k$ 个时间步的状态表示为 $(q_k, p_k)$。\n\n**方法1：显式欧拉法（非辛）**\n显式欧拉法是求解常微分方程的一阶显式方法。对于系统 $\\dot{\\mathbf{z}} = \\mathbf{f}(\\mathbf{z})$，其更新规则为 $\\mathbf{z}_{k+1} = \\mathbf{z}_k + h \\mathbf{f}(\\mathbf{z}_k)$。将其应用于我们的系统，得到：\n$$ q_{k+1} = q_k + h \\cdot p_k $$\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\n该方法生成一个离散映射 $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$。该映射的雅可比矩阵为\n$$ M_{EE} = \\begin{pmatrix} 1  h \\\\ -h\\omega^2  1 \\end{pmatrix} $$\n该矩阵的行列式为 $\\det(M_{EE}) = 1 \\cdot 1 - (h)(-h\\omega^2) = 1 + h^2\\omega^2$。由于当 $\\omega > 0$ 和 $h > 0$ 时 $\\det(M_{EE}) > 1$，该映射是非辛的（一个映射是辛的，如果其雅可比矩阵是辛矩阵，这要求行列式为1）。相空间映射的这种体积扩张性质导致数值能量出现系统性的、长期的增长，这是非辛方法应用于保守哈密顿系统时的一个特征缺陷。在长时间尺度上，能量甚至不能近似守恒。\n\n**方法2：辛欧拉法（辛）**\n辛欧拉法是一种一阶半隐式方法。问题指定先更新动量，然后使用更新后的动量更新位置。这对应于以下更新规则：\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\n$$ q_{k+1} = q_k + h \\cdot p_{k+1} $$\n请注意，$q_{k+1}$ 的更新使用了新计算出的动量 $p_{k+1}$，这使得该方法成为半隐式的。该方法生成一个不同的离散映射。其雅可比矩阵为\n$$ M_{SE} = \\begin{pmatrix} 1-h^2\\omega^2  h \\\\ -h\\omega^2  1 \\end{pmatrix} $$\n行列式为 $\\det(M_{SE}) = (1-h^2\\omega^2) \\cdot 1 - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1$。对于二维相空间，行列式为1的映射是保面积的，这是其成为辛映射的必要条件。该方法确实是辛的。辛积分器并不精确守恒真实的哈密顿量 $H$，但它们精确守恒一个邻近的“影子”哈密顿量 $H_h$。此性质确保了能量误差 $(H_k/H_0) - 1$ 在任意长的积分时间内保持有界，表现为在零附近振荡，而没有任何长期漂移。\n\n**诊断与实现**\n对于每个具有初始条件 $(q_0, p_0)$ 和参数 $\\omega$、$h$ 的测试用例，我们使用两种方法将系统演化 $N = 10^4$ 步。在从 $k=0$ 到 $k=N$ 的每一步，我们计算离散能量 $H_k = \\frac{1}{2}(p_k^2 + \\omega^2 q_k^2)$。初始能量为 $H_0$。\n\n所需的诊断指标是：\n1.  **最终相对能量误差**: $(H_N/H_0) - 1$。\n2.  **最大相对能量偏差**: $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$。\n\n对于 $\\omega = 0.0$ 的特殊情况（测试C），哈密顿量简化为 $H(p) = \\frac{1}{2}p^2$，代表一个自由粒子。运动方程为 $\\dot{q} = p$ 和 $\\dot{p} = 0$。在这种情况下，显式欧拉法和辛欧拉法的更新规则变得相同：\n$$ p_{k+1} = p_k $$\n$$ q_{k+1} = q_k + h p_k $$\n由于对所有 $k$ 都有 $p_k = p_0$，能量 $H_k = \\frac{1}{2}p_k^2 = \\frac{1}{2}p_0^2 = H_0$ 被两种方法精确守恒。因此，对于此测试用例，两个诊断值预计都将精确为 $0.0$。\n\n数值实现将模拟两条轨迹，为每条轨迹存储能量历史，然后为每个测试用例计算四个指定的诊断值。结果将经验性地证明辛积分器对于此保守系统的优越长期行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using explicit and symplectic Euler methods,\n    and computes energy conservation diagnostics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, q0, p0).\n    test_cases = [\n        (1.0, 0.01, 1.0, 0.0),   # Test A\n        (3.0, 0.01, 1.0, 0.0),   # Test B\n        (0.0, 0.01, 1.0, 1.0),   # Test C\n        (1.0, 0.001, 1.0, 1.0),  # Test D\n    ]\n\n    N_steps = 10**4\n    all_results = []\n\n    for omega, h, q0, p0 in test_cases:\n        # Initialize states for both methods\n        q_ee, p_ee = q0, p0  # Explicit Euler\n        q_se, p_se = q0, p0  # Symplectic Euler\n\n        # Compute initial energy H0.\n        # Use np.longdouble for precision in intermediate calculations.\n        omega_sq = np.longdouble(omega)**2\n        H0 = 0.5 * (np.longdouble(p0)**2 + omega_sq * np.longdouble(q0)**2)\n        \n        # Handle the case H0=0 to avoid division by zero, though not present in tests.\n        if H0 == 0:\n            H0 = np.finfo(np.longdouble).eps\n\n        # Lists to store the history of relative energy errors |(Hk/H0) - 1|\n        rel_err_history_ee = [0.0]\n        rel_err_history_se = [0.0]\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # --- Explicit Euler Step ---\n            q_ee_old = q_ee\n            q_ee = q_ee + h * p_ee\n            p_ee = p_ee - h * omega_sq * q_ee_old\n\n            # --- Symplectic Euler Step ---\n            p_se = p_se - h * omega_sq * q_se\n            q_se = q_se + h * p_se\n\n            # Calculate energies and relative errors\n            Hk_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n            rel_err_ee = (Hk_ee / H0) - 1.0\n            rel_err_history_ee.append(abs(rel_err_ee))\n\n            Hk_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n            rel_err_se = (Hk_se / H0) - 1.0\n            rel_err_history_se.append(abs(rel_err_se))\n\n        # Calculate final diagnostics for the current test case\n        \n        # Non-symplectic (Explicit Euler) diagnostics\n        # The final error includes its sign, while history stored absolute values.\n        final_H_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n        signed_final_rel_err_ee = (final_H_ee / H0) - 1.0\n        \n        max_rel_dev_ee = max(rel_err_history_ee)\n\n        # Symplectic (Symplectic Euler) diagnostics\n        final_H_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n        signed_final_rel_err_se = (final_H_se / H0) - 1.0\n        \n        max_rel_dev_se = max(rel_err_history_se)\n        \n        case_results = [\n            float(signed_final_rel_err_ee),\n            float(max_rel_dev_ee),\n            float(signed_final_rel_err_se),\n            float(max_rel_dev_se)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # The str() of a list produces the desired \"[f1, f2, ...]\" format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了固定步长辛积分器的优点后，一个自然的问题是如何将其与自适应步长技术相结合以提高计算效率。本练习  探讨了几何积分中一个关键而微妙的问题：您将从第一性原理出发，并通过数值计算来验证，标准的基于局部误差的自适应步长策略会破坏算法的辛结构，导致相空间体积不守恒。这个实践突显了保持几何结构需要整体设计的思想，即不仅积分格式本身，包括步长控制在内的整个算法都必须精心设计。",
            "id": "3743640",
            "problem": "考虑一个哈密顿系统，其相空间为 $\\mathbb{R}^2$，正则坐标为 $(q,p)$，哈密顿量为 $H(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2$，其中 $\\omega > 0$ 是一个固定参数。正则辛形式由常数矩阵 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$ 表示。将步长为 $h > 0$ 的单步隐式中点龙格-库塔（Runge-Kutta (RK)）方法应用于此系统，产生离散更新 $z_{n+1} = z_n + h J \\nabla H\\left( \\tfrac{z_n + z_{n+1}}{2} \\right)$，其中 $z = (q,p)^\\top$。\n\n您将分析基于局部误差的步长自适应性对该方法的辛性和测度保持性的影响。您必须使用的基本依据包括：具有辛形式的哈密顿系统的定义、辛映射（即保持辛形式的映射）的定义，以及上述隐式中点法的定义。除从这些定义推导出的公式外，不要使用任何快捷公式。\n\n任务：\n\n1. 根据基本定义推导应用于给定二次哈密顿量的隐式中点法的线性更新关系，其形式为 $(I - \\tfrac{h}{2} A) z_{n+1} = (I + \\tfrac{h}{2} A) z_n$，其中 $A$ 是线性哈密顿向量场的矩阵。使用此关系构建单步映射 $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$。\n\n2. 从辛映射的定义（保持二形式）出发，解释为什么在固定步长 $h$ 的情况下，单步映射 $F_h$ 是辛的，并因此相对于刘维尔测度是保体积的。然后，考虑一个由基于局部误差的自适应性决定的、依赖于状态的步长 $h(z)$，定义自适应单步映射 $F(z) := F_{h(z)}(z)$，并证明这会破坏辛性条件。您的论证必须从辛映射定义和导数的链式法则出发，且不得假定任何专门的辛RK条件。\n\n3. 通过计算给定相点 $z^\\ast$ 处单步映射的雅可比矩阵 $\\mathrm{D}F(z^\\ast)$ 的行列式，来量化所产生的测度畸变。将该行列式与 $1$ 的绝对偏差，即 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$，作为测度畸变进行报告。您必须通过将有限差分应用于任务1中显式映射的实现，来数值计算 $\\mathrm{D}F(z^\\ast)$。\n\n基于局部误差的自适应模型：\n\n- 对于基准步长 $h_0 > 0$，通过步长加倍定义在 $z$ 处的局部误差估计器：\n  $$ e(z;h_0) := \\left\\| F_{h_0}(z) - F_{h_0/2}\\big( F_{h_0/2}(z) \\big) \\right\\|_2. $$\n- 对于2阶的隐式中点法，使用标准缩放关系 $e(z;h) \\propto h^3$ 来定义自适应步长\n  $$ h_{\\mathrm{adapt}}(z) := \\operatorname{clip}\\left( h_0 \\left( \\frac{\\mathrm{tol}}{\\max(e(z;h_0), \\epsilon)} \\right)^{1/3},\\, h_{\\min},\\, h_{\\max} \\right), $$\n  其中 $\\mathrm{tol} > 0$ 是目标容差，$\\epsilon > 0$ 是一个小的正则化常数，而 $h_{\\min}, h_{\\max}$ 是保持步长有限的界限。函数 $\\operatorname{clip}(x,a,b)$ 返回 $\\min(\\max(x,a),b)$。\n\n实现要求：\n\n- 仅使用所提供的定义，通过求解任务1中的线性系统，为二次哈密顿量精确实现 $F_h$。\n- 使用上述局部误差模型实现自适应映射 $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$。\n- 使用中心有限差分法（扰动为小的 $\\delta > 0$）来近似雅可比矩阵 $\\mathrm{D}F(z^\\ast)$。\n- 计算并返回每个测试用例的测度畸变 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$。\n\n单位与约定：\n\n- 这个纯数学问题不需要物理单位。\n- 此问题不涉及角度。\n\n测试套件与最终输出规范：\n\n使用以下参数和相点生成三个测试用例：\n\n- 共享参数：$\\omega = 1.7$， $h_0 = 0.12$， $h_{\\min} = 10^{-4}$， $h_{\\max} = 0.5$， $\\epsilon = 10^{-16}$，有限差分扰动 $\\delta = 10^{-8}$。\n\n- 测试用例：\n  1. 固定步长映射：在 $z^\\ast = (0.3,-0.7)^\\top$ 处的 $F(z) = F_{h_0}(z)$。\n  2. 中等容差的自适应映射：在 $z^\\ast = (0.3,-0.7)^\\top$ 处，$\\mathrm{tol} = 10^{-6}$。\n  3. 平衡点附近的自适应映射：在 $z^\\ast = (10^{-3},-2\\cdot 10^{-3})^\\top$ 处，$\\mathrm{tol} = 10^{-6}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果是对应测试用例的浮点数测度畸变 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$，顺序如上所示。",
            "solution": "该问题已经过验证，被认为是科学上合理的、适定的和客观的。它展示了几何数值积分领域的一个标准练习，重点是应用于线性哈密顿系统的隐式中点法的性质。所有的定义、参数和任务都得到了清晰和一致的规定。\n\n解决方案按顺序处理这三个任务。\n\n### 任务1：单步映射的推导\n\n该系统由哈密顿量 $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$ 描述，其相空间为 $\\mathbb{R}^2$，状态向量为 $z = (q,p)^\\top$。哈密顿方程需要哈密顿量的梯度。我们计算它为：\n$$\n\\nabla H(z) = \\begin{pmatrix} \\frac{\\partial H}{\\partial q} \\\\ \\frac{\\partial H}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} \\omega^2 q \\\\ p \\end{pmatrix}\n$$\n这可以表示为线性形式 $\\nabla H(z) = K z$，其中 $K$ 是对称矩阵：\n$$\nK = \\begin{pmatrix} \\omega^2  0 \\\\ 0  1 \\end{pmatrix}\n$$\n哈密顿方程由 $\\dot{z} = J \\nabla H(z)$ 给出，其中 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。代入梯度的线性形式，得到一个线性常微分方程组：\n$$\n\\dot{z} = J K z = A z\n$$\n其中线性哈密顿向量场的矩阵 $A$ 为：\n$$\nA = JK = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} \\begin{pmatrix} \\omega^2  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}\n$$\n隐式中点法由离散更新规则定义：\n$$\nz_{n+1} = z_n + h J \\nabla H\\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\n对于这个线性系统，这变为：\n$$\nz_{n+1} = z_n + h A \\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\n我们重新整理此方程以求解 $z_{n+1}$：\n$$\nz_{n+1} = z_n + \\frac{h}{2} A z_n + \\frac{h}{2} A z_{n+1}\n$$\n$$\nz_{n+1} - \\frac{h}{2} A z_{n+1} = z_n + \\frac{h}{2} A z_n\n$$\n$$\n\\left(I - \\frac{h}{2} A\\right) z_{n+1} = \\left(I + \\frac{h}{2} A\\right) z_n\n$$\n这就是所要求的线性更新关系。因此，单步映射 $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 由 $z_{n+1} = F_h(z_n)$ 给出，其中 $F_h$ 是由矩阵 $M_h$ 表示的线性算子：\n$$\nF_h(z) = M_h z, \\quad \\text{其中} \\quad M_h = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right)\n$$\n矩阵 $M_h$ 是矩阵 $\\frac{h}{2}A$ 的凯莱变换。\n\n### 任务2：辛性分析\n\n一个映射 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 被定义为辛映射，如果它的雅可比矩阵 $\\mathrm{D}F$ 保持辛形式 $J$ 不变。即，对于所有 $z$：\n$$\n(\\mathrm{D}F(z))^\\top J (\\mathrm{D}F(z)) = J\n$$\n此性质的一个直接推论是雅可比矩阵的行列式为1，$\\det(\\mathrm{D}F(z)) = 1$。这意味着该映射相对于相空间上的标准刘维尔测度是保体积的。\n\n**固定步长 ($h$)**：\n对于固定步长的隐式中点法，映射为 $F_h(z) = M_h z$。由于此映射是线性的，其雅可比矩阵是常数，且等于矩阵 $M_h$ 本身：$\\mathrm{D}F_h(z) = M_h$。辛性条件变为：\n$$\nM_h^\\top J M_h = J\n$$\n此性质成立的充要条件是矩阵 $A$ 是一个哈密顿矩阵，即它属于李代数 $\\mathfrak{sp}(2,\\mathbb{R})$。其条件是 $A^\\top J + JA = 0$。让我们从基本原理出发验证这一点。当 $A=JK$ 且 $K=K^\\top$ 时：\n$$\nA^\\top J + JA = (JK)^\\top J + J(JK) = K^\\top J^\\top J + J^2 K\n$$\n使用 $J^\\top = -J$ 和 $J^2 = -I$，这变为：\n$$\nK (-J) J + (-I) K = -K J^2 - K = -K(-I) - K = K - K = 0\n$$\n该条件成立。因此，$M_h$ 作为哈密顿矩阵的凯莱变换，是一个辛矩阵。因此，对于任何固定的步长 $h > 0$，映射 $F_h$ 都是辛的。\n\n**自适应步长 ($h(z)$)**：\n当步长依赖于状态 $h=h(z)$ 时，单步映射变为 $F(z) = F_{h(z)}(z) = M_{h(z)} z$。这个映射不再是线性的。我们必须使用乘积法则和链式法则来计算它的雅可比矩阵：\n$$\n\\mathrm{D}F(z) = \\frac{\\partial}{\\partial z} \\left( M_{h(z)} z \\right) = \\left( \\frac{\\partial}{\\partial z} M_{h(z)} \\right) z + M_{h(z)} \\frac{\\partial z}{\\partial z}\n$$\n$\\frac{\\partial z}{\\partial z}$ 项是单位矩阵 $I$。对于第一项，我们应用链式法则：$\\frac{\\partial M_{h(z)}}{\\partial z_j} = \\frac{d M_h}{d h} \\frac{\\partial h}{\\partial z_j}$。这可以用张量表示法更紧凑地写出：\n$$\n\\mathrm{D}F(z) = M_{h(z)} + \\left( \\frac{d M_h}{dh} \\Big|_{h=h(z)} z \\right) \\otimes (\\nabla_z h(z))^\\top\n$$\n其中 $\\otimes$ 表示外积。雅可比矩阵是辛矩阵 $M_{h(z)}$ 和一个秩为1的矩阵之和。这个和通常不是一个辛矩阵。除非第二项为零，即要求 $\\nabla_z h(z)=0$，否则辛性条件被破坏。梯度为零意味着步长 $h$ 是局部常数，这退化为固定步长的情况。因此，对于一个真正的自适应步长，映射 $F(z)$ 不是辛的，且 $\\det(\\mathrm{D}F(z)) \\neq 1$，意味着它不保持相空间体积。\n\n### 任务3：测度畸变的数值量化\n\n为了量化与测度保持性的偏差，我们在给定点 $z^\\ast$ 处计算测度畸变 $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$。雅可比矩阵 $\\mathrm{D}F(z^\\ast)$ 使用中心有限差分法，以一个小的扰动 $\\delta = 10^{-8}$ 进行数值计算。对于一个映射 $F:\\mathbb{R}^2 \\to \\mathbb{R}^2$，其雅可比矩阵 $J_{F}$ 的列可以近似为：\n$$\nJ_{F, \\cdot 1}(z^\\ast) \\approx \\frac{F(z^\\ast + (\\delta, 0)^\\top) - F(z^\\ast - (\\delta, 0)^\\top)}{2\\delta}\n$$\n$$\nJ_{F, \\cdot 2}(z^\\ast) \\approx \\frac{F(z^\\ast + (0, \\delta)^\\top) - F(z^\\ast - (0, \\delta)^\\top)}{2\\delta}\n$$\n自适应步长 $h_{\\mathrm{adapt}}(z)$ 使用所提供的步长加倍误差估计器计算，并且得到的映射 $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$ 被用于有限差分公式。\n\n对于测试用例1（固定步长），映射是 $F(z) = F_{h_0}(z)$。如前所证，此映射是辛的，且 $\\det(\\mathrm{D}F) = 1$。数值计算应该得到一个接近机器精度的畸变，这仅反映了浮点和有限差分近似误差。\n\n对于测试用例2和3（自适应步长），映射是 $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$。由于映射不是辛的，预计会产生非零的畸变。畸变的大小取决于步长函数 $\\nabla_z h(z)$ 在点 $z^\\ast$ 处的梯度。在平衡点 $z=(0,0)^{\\top}$ 附近（测试用例3），误差估计 $e(z;h_0)$ 趋于零，导致未裁剪的自适应步长变得非常大，从而被限制在 $h_{\\max}$。在这个区域，$h(z)$ 近似为常数，所以 $\\nabla_z h(z) \\approx 0$，并且映射是近似辛的。因此，我们预期测试用例3中的测度畸变会比测试用例2中的小。\n\n下面的Python代码实现了这个数值分析。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the measure distortion for the implicit midpoint method under fixed and\n    adaptive step size strategies.\n    \n    This function implements the three test cases specified in the problem:\n    1. Fixed-step size map.\n    2. Adaptive step size map with a moderate tolerance.\n    3. Adaptive step size map near the equilibrium point.\n    \n    The measure distortion is defined as |det(DF) - 1|, where DF is the Jacobian\n    of the one-step map, computed numerically via finite differences.\n    \"\"\"\n\n    # Shared parameters from the problem statement\n    omega = 1.7\n    h0 = 0.12\n    hmin = 1e-4\n    hmax = 0.5\n    epsilon = 1e-16\n    delta = 1e-8\n\n    def F_h(z, h, omega_val):\n        \"\"\"\n        Implements the one-step map F_h for the linear Hamiltonian system.\n        z_next = (I - h/2 * A)^-1 * (I + h/2 * A) * z\n        \"\"\"\n        A = np.array([[0.0, 1.0], [-omega_val**2, 0.0]])\n        I = np.identity(2)\n        \n        # Linear system: (I - h/2 * A) * z_next = (I + h/2 * A) * z\n        mat_lhs = I - (h / 2.0) * A\n        mat_rhs = I + (h / 2.0) * A\n        vec_rhs = mat_rhs @ z\n        \n        return np.linalg.solve(mat_lhs, vec_rhs)\n\n    def h_adapt(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Computes the adaptive step size h(z) based on a local error estimator.\n        \"\"\"\n        # Step-doubling error estimator\n        z_h0 = F_h(z, h0_val, omega_val)\n        z_h0_half = F_h(z, h0_val / 2.0, omega_val)\n        z_h0_half_half = F_h(z_h0_half, h0_val / 2.0, omega_val)\n        error = np.linalg.norm(z_h0 - z_h0_half_half)\n        \n        # Adaptive step size formula\n        h_unclipped = h0_val * (tol_val / max(error, epsilon))**(1.0 / 3.0)\n        \n        # Clip the step size to the specified bounds\n        return np.clip(h_unclipped, hmin, hmax)\n\n    def F_adaptive(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Implements the adaptive one-step map F(z) = F_{h_adapt(z)}(z).\n        \"\"\"\n        h_eff = h_adapt(z, h0_val, tol_val, omega_val)\n        return F_h(z, h_eff, omega_val)\n\n    def compute_jacobian(F_map, z_star, delta_val):\n        \"\"\"\n        Approximates the Jacobian of a map F at z_star using central finite differences.\n        \"\"\"\n        z_star = np.asarray(z_star, dtype=float)\n        \n        # Perturb q (first coordinate)\n        pert_q = np.array([delta_val, 0.0])\n        J_col1 = (F_map(z_star + pert_q) - F_map(z_star - pert_q)) / (2.0 * delta_val)\n        \n        # Perturb p (second coordinate)\n        pert_p = np.array([0.0, delta_val])\n        J_col2 = (F_map(z_star + pert_p) - F_map(z_star - pert_p)) / (2.0 * delta_val)\n        \n        return np.column_stack([J_col1, J_col2])\n\n    test_cases = [\n        # (Case Type, Tolerance, z_star)\n        (\"fixed\", None, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([1e-3, -2e-3]))\n    ]\n    \n    results = []\n    \n    for case_type, tol, z_star in test_cases:\n        if case_type == \"fixed\":\n            # Define a lambda to match the expected signature of compute_jacobian\n            map_func = lambda z: F_h(z, h0, omega)\n        else: # case_type == \"adaptive\"\n            map_func = lambda z: F_adaptive(z, h0, tol, omega)\n            \n        jacobian = compute_jacobian(map_func, z_star, delta)\n        determinant = np.linalg.det(jacobian)\n        distortion = abs(determinant - 1.0)\n        results.append(distortion)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本方法之后，我们转向构建更高阶的辛积分器，并将其应用于更接近实际的非线性系统中。本练习  将引导您实践一种先进的构造技巧，即实现一个四阶组合辛方法，该方法的一个显著特点是包含负时间步长的子步骤。通过将此高阶方法应用于非谐振子，并与标准的二阶方法进行比较，您将深入探究在追求更高精度的同时，必须面对的稳定性等实际问题，以及高级组合算法可能带来的挑战。",
            "id": "3743598",
            "problem": "考虑一个单自由度的非谐振子自主哈密顿系统，其哈密顿量 $H(q,p)$ 定义为\n$$\nH(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4,\n$$\n其中 $q$ 和 $p$ 分别表示正则位置和动量，$\\omega > 0$ 和 $\\alpha \\ge 0$ 是参数。其动力学由哈密顿方程决定\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p}, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial q}.\n$$\n本任务要求从几何力学和辛方法的第一性原理出发，研究高阶组合积分器中负时间子步对此非谐振子的稳定性和辛性的影响。\n\n你必须通过构建由哈密顿量分裂 $H = T + V$ 导出的精确子系统流来构造几何数值积分器，其中\n$$\nT(p) = \\tfrac{1}{2} p^2, \\qquad V(q) = \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4.\n$$\n在此基础上，导出 $T$ 和 $V$ 的精确流，然后设计并实现以下辛方法：\n- 一种对称二阶 Strang 分裂方法，该方法在大小为 $h$ 的单步内组合 $T$ 和 $V$ 的精确流。\n- 一种四阶对称组合方法（最小阶“三级跳”类型），该方法使用实数系数组合二阶方法，其中一个组合系数为负。通过满足达到四阶所需的阶数条件来确定组合系数，并用它们来实现该方法。\n\n对每个积分器，分析以下内容：\n- 辛性（Symplecticity）：使用有限差分法在指定的初始条件下数值近似单步映射的雅可比矩阵 $J$，并计算辛性亏格\n$$\n\\Delta = \\| J^\\top \\Omega J - \\Omega \\|_F,\n$$\n其中 $\\Omega = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$ 是标准辛矩阵，$J^\\top$ 是 $J$ 的转置，$\\|\\cdot\\|_F$ 表示 Frobenius 范数。将 $\\Delta$ 报告为浮点数。\n- 长时间积分下的稳定性（Stability）：对每个积分器，从相同的初始条件出发，使用固定的步长 $h$ 推进动力学 $N$ 步，并评估数值轨迹是否保持有界。通过要求所有步 $k$ 的 $\\max\\{|q_k|, |p_k|\\}$ 不超过阈值 $A_{\\text{thr}} = 10^3$ 来定义有界性。如果未超过阈值且未出现非数值，则将稳定性报告为布尔值 true；否则，报告为 false。\n- 能量行为（Energy behavior）：计算 $N$ 步后的能量比率 $R = H(q_N, p_N)/H(q_0, p_0)$。将 $R$ 报告为浮点数。\n\n此问题中的所有量都是无量纲的，因此无需报告物理单位。此问题中未使用角度。\n\n为以下参数集测试套件实现你的分析，每个参数集指定为 $(\\omega, \\alpha, h, N, q_0, p_0)$：\n- 测试 $1$：$(1.0, 0.1, 0.1, 5000, 1.0, 0.0)$。\n- 测试 $2$：$(1.0, 1.0, 0.3, 4000, 1.0, 0.0)$。\n- 测试 $3$：$(1.0, 5.0, 0.5, 2000, 0.5, 0.0)$。\n- 测试 $4$：$(2.0, 0.5, 0.35, 3000, 1.0, 0.0)$。\n\n对每个测试，生成一对结果三元组，一个用于对称二阶 Strang 方法，另一个用于四阶对称组合方法。每个三元组必须包含：\n- 在 $(q_0, p_0)$ 处单步映射的辛性亏格 $\\Delta$，\n- 稳定性指标，以整数表示（$1$ 表示 true，$0$ 表示 false），\n- $N$ 步后的能量比率 $R$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试，并且是一个包含两个三元组的双元素列表。具体而言，最终输出必须具有以下形式：\n$$\n[\\,[\\Delta_S, s_S, R_S], [\\Delta_Y, s_Y, R_Y],\\,\\ldots\\,]\n$$\n其中下标 $S$ 表示 Strang 方法，下标 $Y$ 表示四阶对称组合方法（具有负组合子步）。确保输出直接打印数值，布尔值按规定编码为整数。",
            "solution": "该问题要求为单自由度非谐振子构建、实现和分析两种辛数值积分器。分析重点是比较一种标准的二阶方法与一种利用负时间子步的四阶组合方法，评估它们各自的辛性、稳定性和能量守恒性质。\n\n### 1. 哈密顿系统与分裂\n\n该系统由自主哈密顿量描述\n$$\nH(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4,\n$$\n其中 $q$ 是位置，$p$ 是动量，$\\omega > 0$ 和 $\\alpha \\ge 0$ 是参数。动力学根据哈密顿方程演化：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial q} = -(\\omega^2 q + 4\\alpha q^3).\n$$\n为了构造几何积分器，哈密顿量被分裂成两个可积部分，$H = T(p) + V(q)$，其中 $T(p)$ 是动能，$V(q)$ 是势能：\n$$\nT(p) = \\tfrac{1}{2} p^2, \\qquad V(q) = \\tfrac{1}{2} \\omega^2 q^2 + \\alpha q^4.\n$$\n\n### 2. 精确子系统流\n\n我们推导精确流，记为 $\\phi_\\tau$，它在分裂哈密顿量的单个部分作用下，将系统推进一个时间间隔 $\\tau$。\n\n**$T(p)$ 下的流：** “动能”子系统由 $\\dot{q} = \\partial T/\\partial p = p$ 和 $\\dot{p} = -\\partial T/\\partial q = 0$ 控制。从初始状态 $(q_0, p_0)$ 积分这些方程得到：\n$p(\\tau) = p_0$\n$q(\\tau) = q_0 + \\int_0^\\tau p(s) ds = q_0 + p_0 \\tau$。\n因此，精确流映射 $\\phi_\\tau^T$ 是一个剪切变换：\n$$\n\\phi_\\tau^T: (q, p) \\mapsto (q + p\\tau, p).\n$$\n\n**$V(q)$ 下的流：** “势能”子系统由 $\\dot{q} = \\partial V/\\partial p = 0$ 和 $\\dot{p} = -\\partial V/\\partial q = -(\\omega^2 q + 4\\alpha q^3)$ 控制。积分这些方程得到：\n$q(\\tau) = q_0$\n$p(\\tau) = p_0 + \\int_0^\\tau -(\\omega^2 q(s) + 4\\alpha q(s)^3) ds = p_0 - (\\omega^2 q_0 + 4\\alpha q_0^3)\\tau$。\n精确流映射 $\\phi_\\tau^V$ 是一个动量更新：\n$$\n\\phi_\\tau^V: (q, p) \\mapsto (q, p - (\\omega^2 q + 4\\alpha q^3)\\tau).\n$$\n对于任何 $\\tau \\in \\mathbb{R}$，$\\phi_\\tau^T$ 和 $\\phi_\\tau^V$ 都是辛映射。\n\n### 3. 积分器构造\n\n辛积分器是通过组合子系统的精确流来构造的。\n\n**A. 二阶 Strang 分裂方法**\nStrang 分裂方法是一种 ABA 形式的对称组合。对于步长 $h$，单步映射 $\\Psi_S(h)$ 由下式给出：\n$$\n\\Psi_S(h) = \\phi_{h/2}^V \\circ \\phi_h^T \\circ \\phi_{h/2}^V.\n$$\n设 $(q_n, p_n)$ 是时刻 $t_n$ 的状态。时刻 $t_{n+1} = t_n + h$ 的状态是 $(q_{n+1}, p_{n+1}) = \\Psi_S(h)(q_n, p_n)$，计算过程如下：\n1. 应用 $V$-流的半步：$p_{n+1/2} = p_n - (\\omega^2 q_n + 4\\alpha q_n^3) \\frac{h}{2}$。\n2. 应用 $T$-流的整步：$q_{n+1} = q_n + p_{n+1/2} h$。\n3. 应用 $V$-流的第二个半步：$p_{n+1} = p_{n+1/2} - (\\omega^2 q_{n+1} + 4\\alpha q_{n+1}^3) \\frac{h}{2}$。\n这个算法与著名的 Velocity Verlet 方法相同。它是对称、显式和辛的。根据其构造，它是一个二阶精度方法（每步误差为 $\\mathcal{O}(h^3)$）。\n\n**B. 四阶对称组合方法**\n更高阶的对称方法可以通过组合一个二阶对称方法来构造。一个四阶方法 $\\Psi_Y(h)$ 可以通过对 Strang 方法 $\\Psi_S(h)$ 进行“三级跳”组合来构建：\n$$\n\\Psi_Y(h) = \\Psi_S(c_1 h) \\circ \\Psi_S(c_2 h) \\circ \\Psi_S(c_1 h).\n$$\n为了使该组合达到 4 阶，实系数 $c_1, c_2$ 必须满足将一个 $p=2$ 的方法组合成一个 $p=4$ 的方法的阶数条件：\n$$\n2c_1 + c_2 = 1, \\qquad 2c_1^3 + c_2^3 = 0.\n$$\n将 $c_2 = 1 - 2c_1$ 代入第二个方程，得到一个关于 $c_1$ 的三次方程：$2c_1^3 + (1 - 2c_1)^3 = 0$，化简为 $6c_1^3 - 12c_1^2 + 6c_1 - 1 = 0$。相关的实数解（它导致了最小阶积分器）是：\n$$\nc_1 = \\frac{1}{2 - 2^{1/3}} \\approx 1.3512, \\qquad c_2 = 1 - 2c_1 = \\frac{-2^{1/3}}{2 - 2^{1/3}} \\approx -1.7024.\n$$\n这种方法通常归功于 Yoshida 或 Suzuki 和 Ruth，其显著特点是有一个负系数 $c_2$。这意味着其中一个子步涉及到时间上的向后积分。虽然这实现了四阶精度，但有效步长 $|c_1 h|$ 和 $|c_2 h|$ 大于 $h$，这可能导致该方法的稳定性域相较于基础的二阶积分器有所缩小。作为辛映射的组合，$\\Psi_Y(h)$ 也是辛的。\n\n### 4. 数值分析\n\n**A. 辛性亏格 ($\\Delta$)**\n如果一个映射 $\\Phi$ 的雅可比矩阵 $J$ 满足 $J^\\top \\Omega J = \\Omega$，其中 $\\Omega = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$，则该映射是辛的。这意味着 $\\det(J) = 1$。数值实现会引入浮点误差。辛性亏格 $\\Delta$ 衡量了与此性质的偏差，并计算为残差矩阵的 Frobenius 范数：\n$$\n\\Delta = \\| J^\\top \\Omega J - \\Omega \\|_F.\n$$\n由于 $J^\\top \\Omega J - \\Omega = (\\det(J)-1) \\Omega$ 对于二维情况成立，此范数可以简化为 $\\sqrt{2}|\\det(J)-1|$。单步映射的雅可比矩阵 $J$ 是在初始条件下使用中心有限差分和一个小扰动来数值计算的。对于一个正确实现的辛积分器，$\\Delta$ 的量级应该与机器精度相当。\n\n**B. 稳定性**\n长期稳定性通过将系统积分 $N$ 步来评估。如果相空间坐标保持有界，即 $\\max_{k \\in [0,N]} \\{|q_k|, |p_k|\\}  A_{\\text{thr}} = 10^3$，则认为轨迹是稳定的。如果轨迹超出此界限或产生非数值（例如 `inf` 或 `nan`），则认为其不稳定。这个测试对于具有负时间步长的方法至关重要，因为这些方法在基础方法稳定的步长 $h$ 下可能表现出不稳定性。\n\n**C. 能量行为**\n辛积分器不守恒精确的哈密顿量 $H$。相反，它们精确守恒一个修正的“影子”哈密顿量 $H_{mod} = H + \\mathcal{O}(h^p)$，其中 $p$ 是方法的阶数。对于稳定的、非共振的轨迹，这导致数值能量 $H(q_k, p_k)$ 在其初始值附近有界地振荡。我们通过 $N$ 步后的比率 $R = H(q_N, p_N) / H(q_0, p_0)$ 来衡量长期能量行为。接近 $1$ 的 $R$ 值表示良好的能量保持性。对于不稳定的轨迹，能量通常无界增长，导致非常大或非数值的 $R$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing symplectic integrators for the anharmonic oscillator.\n    \"\"\"\n    # Define constants for the fourth-order composition method\n    cbrt2 = np.cbrt(2.0)\n    C1_4TH = 1.0 / (2.0 - cbrt2)\n    C2_4TH = -cbrt2 / (2.0 - cbrt2)\n\n    # Stability threshold\n    A_THR = 1000.0\n\n    def hamiltonian(q, p, omega, alpha):\n        \"\"\"Computes the Hamiltonian H(q,p).\"\"\"\n        return 0.5 * p**2 + 0.5 * (omega * q)**2 + alpha * q**4\n\n    def force(q, omega, alpha):\n        \"\"\"Computes the force -dV/dq.\"\"\"\n        return -(omega**2 * q + 4.0 * alpha * q**3)\n\n    def strang_step(q, p, h, omega, alpha):\n        \"\"\"\n        Performs one step of the second-order Strang splitting (Velocity-Verlet) method.\n        \"\"\"\n        p_half = p + force(q, omega, alpha) * h / 2.0\n        q_next = q + p_half * h\n        p_next = p_half + force(q_next, omega, alpha) * h / 2.0\n        return q_next, p_next\n\n    def yoshida4_step(q, p, h, omega, alpha):\n        \"\"\"\n        Performs one step of the fourth-order symmetric composition method.\n        \"\"\"\n        h1 = C1_4TH * h\n        h2 = C2_4TH * h\n        \n        q1, p1 = strang_step(q, p, h1, omega, alpha)\n        q2, p2 = strang_step(q1, p1, h2, omega, alpha)\n        q_next, p_next = strang_step(q2, p2, h1, omega, alpha)\n        \n        return q_next, p_next\n\n    def analyze_integrator(integrator_func, omega, alpha, h, N, q0, p0):\n        \"\"\"\n        Analyzes a given integrator for symplecticity, stability, and energy behavior.\n\n        Returns:\n            A tuple (delta, stability, energy_ratio).\n        \"\"\"\n        # 1. Symplecticity Defect Calculation\n        epsilon = 1e-8\n        \n        # Perturb q to find the first column of the Jacobian\n        q_plus_q, p_plus_q = integrator_func(q0 + epsilon, p0, h, omega, alpha)\n        q_minus_q, p_minus_q = integrator_func(q0 - epsilon, p0, h, omega, alpha)\n        J11 = (q_plus_q - q_minus_q) / (2 * epsilon)\n        J21 = (p_plus_q - p_minus_q) / (2 * epsilon)\n        \n        # Perturb p to find the second column of the Jacobian\n        q_plus_p, p_plus_p = integrator_func(q0, p0 + epsilon, h, omega, alpha)\n        q_minus_p, p_minus_p = integrator_func(q0, p0 - epsilon, h, omega, alpha)\n        J12 = (q_plus_p - q_minus_p) / (2 * epsilon)\n        J22 = (p_plus_p - p_minus_p) / (2 * epsilon)\n        \n        J = np.array([[J11, J12], [J21, J22]])\n        Omega = np.array([[0, 1], [-1, 0]])\n        \n        defect_matrix = J.T @ Omega @ J - Omega\n        delta = np.linalg.norm(defect_matrix, 'fro')\n        \n        # 2. Stability and Energy Ratio Calculation\n        q, p = q0, p0\n        H0 = hamiltonian(q0, p0, omega, alpha)\n        stable = 1  # 1 for true\n        \n        for _ in range(N):\n            q, p = integrator_func(q, p, h, omega, alpha)\n            if not np.isfinite(q) or not np.isfinite(p) or abs(q) > A_THR or abs(p) > A_THR:\n                stable = 0  # 0 for false\n                break\n        \n        HN = hamiltonian(q, p, omega, alpha)\n        \n        # The problem statement ensures H0 > 0.\n        if H0 == 0: H0 = 1e-16 # Avoid division by zero\n        energy_ratio = HN / H0 if np.isfinite(HN) else np.inf\n        \n        return delta, stable, energy_ratio\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.1, 0.1, 5000, 1.0, 0.0),\n        (1.0, 1.0, 0.3, 4000, 1.0, 0.0),\n        (1.0, 5.0, 0.5, 2000, 0.5, 0.0),\n        (2.0, 0.5, 0.35, 3000, 1.0, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, alpha, h, N, q0, p0 = case\n        \n        # Analyze Strang method\n        res_S = analyze_integrator(strang_step, omega, alpha, h, N, q0, p0)\n        \n        # Analyze Yoshida 4th order method\n        res_Y = analyze_integrator(yoshida4_step, omega, alpha, h, N, q0, p0)\n        \n        # Store results as lists of numbers\n        all_results.append([list(res_S), list(res_Y)])\n\n    # Format the output string to match the problem specification exactly.\n    case_strings = []\n    for test_result in all_results:\n        # Use a consistent format for floating point numbers\n        strang_res_str = f\"[{test_result[0][0]:.15e},{int(test_result[0][1])},{test_result[0][2]:.15e}]\"\n        yoshida_res_str = f\"[{test_result[1][0]:.15e},{int(test_result[1][1])},{test_result[1][2]:.15e}]\"\n        case_strings.append(f\"[{strang_res_str},{yoshida_res_str}]\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}