{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of geometric numerical integration is its ability to preserve the qualitative features of a Hamiltonian system over long times. This first practice provides a stark, quantitative illustration of this principle using the harmonic oscillator, the simplest non-trivial conservative system. By comparing the behavior of a standard non-symplectic integrator against a basic symplectic one, you will directly observe the phenomenon of secular energy drift and contrast it with the bounded energy error characteristic of geometric methods. ",
            "id": "3743624",
            "problem": "Consider the one-degree-of-freedom harmonic oscillator in geometric mechanics with quadratic Hamiltonian $H(q,p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right)$, where $q$ is the configuration coordinate, $p$ is the conjugate momentum, and $\\omega \\ge 0$ is the angular frequency. The canonical equations of motion are given by Hamilton's equations $ \\dot{q} = \\frac{\\partial H}{\\partial p}$ and $ \\dot{p} = -\\frac{\\partial H}{\\partial q}$. The goal is to construct and compare a non-symplectic method and a symplectic method, and quantify the energy behavior over a long-time discrete evolution. All quantities in this problem are dimensionless; no physical units or angle units are required.\n\nStarting from Hamilton's equations for this system, implement the following two one-step numerical methods for time step size $h$:\n- A non-symplectic method: the explicit Euler method applied to Hamilton's equations.\n- A symplectic method: the symplectic Euler method (semi-implicit, with momentum update first and position update second at each step).\n\nEvolve both discrete systems for $N = 10^4$ steps from given initial conditions $(q_0,p_0)$ and angular frequency $\\omega$ and time step size $h$. For each method and test case, compute the following quantitative diagnostics:\n1. The final relative energy error, defined as $(H_N/H_0) - 1$, where $H_k = \\frac{1}{2}\\left(p_k^2 + \\omega^2 q_k^2\\right)$ is the discrete energy at step $k$ and $H_0$ is the initial energy.\n2. The maximum relative energy deviation over the entire trajectory, defined as $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$.\n\nUse the canonical quadratic Hamiltonian and ensure the discrete updates are derived from the fundamental definitions and laws specified above, without introducing any ad hoc modifications or external stabilization.\n\nTest Suite:\nEvaluate the diagnostics for the following parameter sets, each evolved for $N = 10^4$ steps:\n- Test A (general case): $\\omega = 1.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$.\n- Test B (higher frequency): $\\omega = 3.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 0.0$.\n- Test C (boundary case of zero frequency): $\\omega = 0.0$, $h = 0.01$, $q_0 = 1.0$, $p_0 = 1.0$.\n- Test D (smaller time step): $\\omega = 1.0$, $h = 0.001$, $q_0 = 1.0$, $p_0 = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case should contribute a list of four floating-point numbers in the order $[\\text{final\\_rel\\_err\\_non\\_symplectic}, \\text{max\\_rel\\_dev\\_non\\_symplectic}, \\text{final\\_rel\\_err\\_symplectic}, \\text{max\\_rel\\_dev\\_symplectic}]$. Thus, the final output must look like $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$, where each $a_i$, $b_i$, $c_i$, and $d_i$ are floats.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information for a unique solution. The system under consideration is the one-degree-of-freedom harmonic oscillator, a canonical model in classical and geometric mechanics. The task is to compare the long-term energy conservation properties of a non-symplectic integrator (explicit Euler) with a symplectic integrator (symplectic Euler).\n\nFirst, we derive the continuous equations of motion from the specified Hamiltonian. The Hamiltonian is given by\n$$ H(q, p) = \\frac{1}{2}\\left(p^2 + \\omega^2 q^2\\right) $$\nwhere $q$ is the position, $p$ is the momentum, and $\\omega$ is the angular frequency. Hamilton's equations of motion are\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} \\quad \\text{and} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} $$\nCalculating the partial derivatives of $H$, we obtain the specific system of ordinary differential equations (ODEs) for the harmonic oscillator:\n$$ \\dot{q} = p $$\n$$ \\dot{p} = -\\omega^2 q $$\nThis can be written in vector form as $\\frac{d}{dt}\\mathbf{z} = \\mathbf{f}(\\mathbf{z})$, where $\\mathbf{z} = (q, p)^T$.\n\nWe will now discretize this system using the two specified numerical methods with a time step size $h$. The state at time step $k$ is denoted by $(q_k, p_k)$.\n\n**Method 1: Explicit Euler (Non-Symplectic)**\nThe explicit Euler method is a first-order, explicit method for solving ODEs. For a system $\\dot{\\mathbf{z}} = \\mathbf{f}(\\mathbf{z})$, the update rule is $\\mathbf{z}_{k+1} = \\mathbf{z}_k + h \\mathbf{f}(\\mathbf{z}_k)$. Applying this to our system yields:\n$$ q_{k+1} = q_k + h \\cdot p_k $$\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\nThis method generates a discrete map $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$. The Jacobian matrix of this map is\n$$ M_{EE} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix} $$\nThe determinant of this matrix is $\\det(M_{EE}) = 1 \\cdot 1 - (h)(-h\\omega^2) = 1 + h^2\\omega^2$. Since $\\det(M_{EE}) > 1$ for $\\omega > 0$ and $h > 0$, the map is not symplectic (a map is symplectic if its Jacobian is a symplectic matrix, which requires determinant of $1$). This volume-expanding nature of the phase space map leads to a systematic, secular increase in the numerical energy, a characteristic flaw of non-symplectic methods when applied to conservative Hamiltonian systems. The energy is not conserved, even approximately, over long time scales.\n\n**Method 2: Symplectic Euler (Symplectic)**\nThe symplectic Euler method is a first-order, semi-implicit method. The problem specifies updating the momentum first, followed by the position using the updated momentum. This corresponds to the following update rules:\n$$ p_{k+1} = p_k + h \\cdot (-\\omega^2 q_k) $$\n$$ q_{k+1} = q_k + h \\cdot p_{k+1} $$\nNote that the update for $q_{k+1}$ uses the newly computed momentum $p_{k+1}$, making the method semi-implicit. This method generates a different discrete map. The Jacobian matrix is\n$$ M_{SE} = \\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix} $$\nThe determinant is $\\det(M_{SE}) = (1-h^2\\omega^2) \\cdot 1 - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1$. A map with a determinant of $1$ for a two-dimensional phase space is area-preserving, a necessary condition for being symplectic. This method is indeed symplectic. Symplectic integrators do not exactly conserve the true Hamiltonian $H$, but they exactly conserve a nearby \"shadow\" Hamiltonian $H_h$. This property ensures that the energy error, $(H_k/H_0) - 1$, remains bounded over arbitrarily long integration times, exhibiting oscillations around zero without any secular drift.\n\n**Diagnostics and Implementation**\nFor each test case with initial conditions $(q_0, p_0)$ and parameters $\\omega$ and $h$, we evolve the system for $N = 10^4$ steps using both methods. At each step $k$, from $k=0$ to $k=N$, we compute the discrete energy $H_k = \\frac{1}{2}(p_k^2 + \\omega^2 q_k^2)$. The initial energy is $H_0$.\n\nThe required diagnostics are:\n1.  **Final relative energy error**: $(H_N/H_0) - 1$.\n2.  **Maximum relative energy deviation**: $\\max_{0 \\le k \\le N}\\left| (H_k/H_0) - 1 \\right|$.\n\nFor the special case where $\\omega = 0.0$ (Test C), the Hamiltonian simplifies to $H(p) = \\frac{1}{2}p^2$, representing a free particle. The equations of motion are $\\dot{q} = p$ and $\\dot{p} = 0$. In this scenario, both the explicit Euler and symplectic Euler update rules become identical:\n$$ p_{k+1} = p_k $$\n$$ q_{k+1} = q_k + h p_k $$\nSince $p_k = p_0$ for all $k$, the energy $H_k = \\frac{1}{2}p_k^2 = \\frac{1}{2}p_0^2 = H_0$ is exactly conserved by both methods. Consequently, both diagnostic values are expected to be exactly $0.0$ for this test case.\n\nThe numerical implementation will simulate both trajectories, store the energy history for each, and then compute the four specified diagnostic values for each test case. The results will empirically demonstrate the superior long-term behavior of the symplectic integrator for this conservative system.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the harmonic oscillator problem using explicit and symplectic Euler methods,\n    and computes energy conservation diagnostics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, h, q0, p0).\n    test_cases = [\n        (1.0, 0.01, 1.0, 0.0),   # Test A\n        (3.0, 0.01, 1.0, 0.0),   # Test B\n        (0.0, 0.01, 1.0, 1.0),   # Test C\n        (1.0, 0.001, 1.0, 1.0),  # Test D\n    ]\n\n    N_steps = 10**4\n    all_results = []\n\n    for omega, h, q0, p0 in test_cases:\n        # Initialize states for both methods\n        q_ee, p_ee = q0, p0  # Explicit Euler\n        q_se, p_se = q0, p0  # Symplectic Euler\n\n        # Compute initial energy H0.\n        # Use np.longdouble for precision in intermediate calculations.\n        omega_sq = np.longdouble(omega)**2\n        H0 = 0.5 * (np.longdouble(p0)**2 + omega_sq * np.longdouble(q0)**2)\n        \n        # Handle the case H0=0 to avoid division by zero, though not present in tests.\n        if H0 == 0:\n            H0 = np.finfo(np.longdouble).eps\n\n        # Lists to store the history of relative energy errors |(Hk/H0) - 1|\n        rel_err_history_ee = [0.0]\n        rel_err_history_se = [0.0]\n\n        # Simulation loop\n        for _ in range(N_steps):\n            # --- Explicit Euler Step ---\n            q_ee_old = q_ee\n            q_ee = q_ee + h * p_ee\n            p_ee = p_ee - h * omega_sq * q_ee_old\n\n            # --- Symplectic Euler Step ---\n            p_se = p_se - h * omega_sq * q_se\n            q_se = q_se + h * p_se\n\n            # Calculate energies and relative errors\n            Hk_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n            rel_err_ee = (Hk_ee / H0) - 1.0\n            rel_err_history_ee.append(abs(rel_err_ee))\n\n            Hk_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n            rel_err_se = (Hk_se / H0) - 1.0\n            rel_err_history_se.append(abs(rel_err_se))\n\n        # Calculate final diagnostics for the current test case\n        \n        # Non-symplectic (Explicit Euler) diagnostics\n        # The final error includes its sign, while history stored absolute values.\n        final_H_ee = 0.5 * (np.longdouble(p_ee)**2 + omega_sq * np.longdouble(q_ee)**2)\n        signed_final_rel_err_ee = (final_H_ee / H0) - 1.0\n        \n        max_rel_dev_ee = max(rel_err_history_ee)\n\n        # Symplectic (Symplectic Euler) diagnostics\n        final_H_se = 0.5 * (np.longdouble(p_se)**2 + omega_sq * np.longdouble(q_se)**2)\n        signed_final_rel_err_se = (final_H_se / H0) - 1.0\n        \n        max_rel_dev_se = max(rel_err_history_se)\n        \n        case_results = [\n            float(signed_final_rel_err_ee),\n            float(max_rel_dev_ee),\n            float(signed_final_rel_err_se),\n            float(max_rel_dev_se)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # The str() of a list produces the desired \"[f1, f2, ...]\" format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While bounded energy error is a key advantage, the benefits of symplectic integration extend to the preservation of more subtle geometric structures in phase space. This exercise moves to a perturbed Hamiltonian system, where the unperturbed action, $J_0$, serves as an adiabatic invariant. You will compare a high-order symplectic integrator against a standard high-order method to quantify their respective abilities to preserve this action, providing insight into why geometric methods excel at capturing the correct long-term dynamics and structure of perturbed systems. ",
            "id": "3743615",
            "problem": "Consider a canonical Hamiltonian system with one degree of freedom, defined by the position $q$ and momentum $p$, governed by Hamilton's equations arising from the Hamiltonian function\n$$\nH(q,p) = H_0(q,p) + \\epsilon U(q),\n$$\nwhere\n$$\nH_0(q,p) = \\tfrac{1}{2} \\left(p^2 + \\omega^2 q^2\\right), \\quad U(q) = \\tfrac{1}{4} q^4,\n$$\nwith frequency parameter $\\omega > 0$ and perturbation strength $\\epsilon \\ge 0$. The canonical equations are\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q - \\epsilon q^3.\n$$\nFor the unperturbed harmonic oscillator with Hamiltonian $H_0(q,p)$, the transformation to action–angle variables yields the action variable\n$$\nJ_0(q,p) = \\frac{p^2 + \\omega^2 q^2}{2\\omega},\n$$\nand a corresponding angle variable\n$$\n\\theta_0(q,p) = \\operatorname{atan2}(\\omega q, p),\n$$\nto be measured in radians. In the absence of perturbation (i.e., when $\\epsilon=0$), the action $J_0$ is conserved under the continuous flow.\n\nYou must write a complete program that, for specified parameter sets, numerically integrates the above canonical system from time $t=0$ to a final time $t=T$ using two schemes:\n- A symplectic scheme based on the Störmer–Verlet (leapfrog) method derived from the splitting $H = T(p) + V(q)$, where $T(p) = \\tfrac{1}{2}p^2$ and $V(q) = \\tfrac{1}{2}\\omega^2 q^2 + \\tfrac{\\epsilon}{4} q^4$. For a time step $h$, the update from $(q_n,p_n)$ to $(q_{n+1},p_{n+1})$ is:\n$$\np_{n+\\tfrac{1}{2}} = p_n - \\tfrac{h}{2}\\,\\frac{\\partial V}{\\partial q}(q_n), \\quad\nq_{n+1} = q_n + h\\,p_{n+\\tfrac{1}{2}}, \\quad\np_{n+1} = p_{n+\\tfrac{1}{2}} - \\tfrac{h}{2}\\,\\frac{\\partial V}{\\partial q}(q_{n+1}),\n$$\nwith the force computed as $-\\dfrac{\\partial V}{\\partial q}(q) = -\\omega^2 q - \\epsilon q^3$.\n- A nonsymplectic explicit Runge–Kutta method of classical order four (RK4) applied to the system $\\dot{q} = p$, $\\dot{p} = -\\omega^2 q - \\epsilon q^3$, using the same time step $h$.\n\nFor each parameter set, do the following:\n1. Integrate the system from $(q(0),p(0)) = (q_0,p_0)$ to time $T$ with both schemes using uniform step size $h$. Use an integer number of steps $N = \\mathrm{round}(T/h)$, so the numerical final time is $t_N = Nh$.\n2. Compute the unperturbed action $J_0$ at the initial state and at the numerical final state for each scheme. The action is\n$$\nJ_0(q,p) = \\frac{p^2 + \\omega^2 q^2}{2\\omega}.\n$$\n3. Quantify the drift of actions as the relative change\n$$\n\\Delta_{\\mathrm{rel}} = \\frac{|J_0(q_N,p_N) - J_0(q_0,p_0)|}{J_0(q_0,p_0)},\n$$\nfor each scheme. Report this drift for the symplectic scheme and for the nonsymplectic scheme.\n\nAngles, when computed, must be expressed in radians. There are no physical units to report for $q$ and $p$; report only the dimensionless relative drifts as floating-point numbers.\n\nImplement the program to cover the following test suite of parameter sets $(\\omega,\\epsilon,q_0,p_0,h,T)$:\n- Case A (happy path, moderate perturbation): $(1.0,\\,0.1,\\,1.0,\\,0.0,\\,0.05,\\,200.0)$.\n- Case B (boundary condition, no perturbation): $(1.0,\\,0.0,\\,1.0,\\,0.0,\\,0.10,\\,100.0)$.\n- Case C (higher frequency, mixed initial state): $(2.0,\\,0.1,\\,0.5,\\,0.5,\\,0.05,\\,200.0)$.\n- Case D (stronger perturbation, smaller step): $(1.0,\\,0.5,\\,1.0,\\,0.0,\\,0.02,\\,200.0)$.\n- Case E (coarser step, moderate perturbation): $(1.0,\\,0.2,\\,1.0,\\,0.0,\\,0.20,\\,200.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must consist of, for each case in order A through E, first the symplectic drift and then the nonsymplectic drift. For example, the output format is\n$$\n[\\Delta_{\\mathrm{symp},A},\\Delta_{\\mathrm{nonsymp},A},\\Delta_{\\mathrm{symp},B},\\Delta_{\\mathrm{nonsymp},B},\\ldots,\\Delta_{\\mathrm{symp},E},\\Delta_{\\mathrm{nonsymp},E}],\n$$\nwith each entry a floating-point number.",
            "solution": "The problem requires a comparison between a symplectic and a non-symplectic numerical integration scheme for a canonical Hamiltonian system. The system under consideration is a perturbed harmonic oscillator, often called a Duffing oscillator, which is a standard model in nonlinear dynamics. Its Hamiltonian is given by $H(q,p) = H_0(q,p) + \\epsilon U(q)$, where $H_0(q,p) = \\tfrac{1}{2}(p^2 + \\omega^2 q^2)$ represents a harmonic oscillator and $\\epsilon U(q) = \\tfrac{\\epsilon}{4}q^4$ is a quartic perturbation. The equations of motion are $\\dot{q} = p$ and $\\dot{p} = -\\omega^2 q - \\epsilon q^3$.\n\nThe core of the problem lies in the principles of geometric numerical integration. Hamiltonian systems possess a geometric structure, specifically a symplectic structure, which their exact flow preserves. Numerical methods that also preserve this structure, known as symplectic integrators, exhibit superior long-term performance. They typically show bounded error in the total energy and other conserved quantities of the exact dynamics, avoiding the secular drift observed in non-symplectic methods.\n\nThe first method, the Störmer–Verlet (or leapfrog) integrator, is a classic example of a symplectic method. It is particularly well-suited for Hamiltonians that are separable into kinetic and potential energy terms, $H(q,p) = T(p) + V(q)$. For the given problem, this separation is $T(p) = \\tfrac{1}{2}p^2$ and $V(q) = \\tfrac{1}{2}\\omega^2 q^2 + \\tfrac{\\epsilon}{4}q^4$. The force is derived from the potential as $F(q) = -\\frac{\\partial V}{\\partial q}(q) = -\\omega^2 q - \\epsilon q^3$. The algorithm advances the system from a state $(q_n, p_n)$ at time $t_n$ to $(q_{n+1}, p_{n+1})$ at time $t_{n+1} = t_n + h$ via a three-step process:\n1. Advance momentum by a half step: $p_{n+\\tfrac{1}{2}} = p_n + \\tfrac{h}{2} F(q_n)$.\n2. Advance position by a full step using the half-step momentum: $q_{n+1} = q_n + h p_{n+\\tfrac{1}{2}}$.\n3. Advance momentum by the second half step using the new position: $p_{n+1} = p_{n+\\tfrac{1}{2}} + \\tfrac{h}{2} F(q_{n+1})$.\nThis method conserves a \"shadow Hamiltonian\" that is close to the original Hamiltonian, leading to excellent long-term energy stability.\n\nThe second method is the classical fourth-order Runge–Kutta (RK4) method. It is a general-purpose, high-accuracy ODE solver but is not symplectic. For a first-order system $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$, where $\\mathbf{y} = [q, p]^T$, the update is given by:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\nwhere\n$$ \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1) $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(t_n + \\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2) $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h\\mathbf{k}_3) $$\nFor our system, $\\mathbf{f}(\\mathbf{y}) = [p, -\\omega^2 q - \\epsilon q^3]^T$. While highly accurate for a single step, RK4 introduces numerical dissipation or anti-dissipation over many steps, causing energy-like quantities to drift systematically.\n\nThe performance of these integrators is evaluated by measuring the relative drift in the unperturbed action, $J_0(q,p) = \\frac{p^2 + \\omega^2 q^2}{2\\omega}$. For the unperturbed system ($\\epsilon = 0$), $J_0$ is proportional to the total energy and is an exact constant of motion. For the perturbed system ($\\epsilon > 0$), the total energy $H$ is conserved, but $J_0$ is not. However, its long-term behavior under numerical integration provides a clear indicator of a method's structural fidelity. We expect the drift in $J_0$ for the Störmer–Verlet method to be significantly smaller and bounded compared to the secular drift produced by RK4, especially over long integration times.\n\nThe solution is implemented by first defining functions for the two integrators. For each test case specified, the system is integrated from the initial conditions $(q_0, p_0)$ over the time interval $[0, T]$ with a step size $h$. The number of steps is $N = \\mathrm{round}(T/h)$. The initial unperturbed action $J_0(q_0, p_0)$ is computed. After integrating for $N$ steps with each method, the final states $(q_N, p_N)$ are used to compute the final action $J_0(q_N, p_N)$, and the relative drift $\\Delta_{\\mathrm{rel}} = |J_{0,N} - J_{0,0}| / J_{0,0}$ is calculated for both schemes. These drift values are collected and formatted for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing symplectic (Störmer-Verlet) and\n    non-symplectic (RK4) integrators for a perturbed Hamiltonian system.\n    \"\"\"\n    \n    # Test cases: (omega, epsilon, q0, p0, h, T)\n    test_cases = [\n        (1.0, 0.1, 1.0, 0.0, 0.05, 200.0), # Case A\n        (1.0, 0.0, 1.0, 0.0, 0.10, 100.0), # Case B\n        (2.0, 0.1, 0.5, 0.5, 0.05, 200.0), # Case C\n        (1.0, 0.5, 1.0, 0.0, 0.02, 200.0), # Case D\n        (1.0, 0.2, 1.0, 0.0, 0.20, 200.0), # Case E\n    ]\n\n    results = []\n    \n    # Define force function F(q) = -dV/dq\n    def force(q, omega, epsilon):\n        return -omega**2 * q - epsilon * q**3\n\n    # Störmer-Verlet integrator\n    def stormer_verlet(q0, p0, h, N, omega, epsilon):\n        q, p = float(q0), float(p0)\n        for _ in range(N):\n            p_half = p + 0.5 * h * force(q, omega, epsilon)\n            q = q + h * p_half\n            p = p_half + 0.5 * h * force(q, omega, epsilon)\n        return q, p\n        \n    # RK4 integrator\n    def rk4(q0, p0, h, N, omega, epsilon):\n        y = np.array([q0, p0], dtype=float)\n        \n        # Define the system of ODEs: dy/dt = f(t, y)\n        def f(t, y_vec, omega_p, epsilon_p):\n            q_val, p_val = y_vec[0], y_vec[1]\n            return np.array([p_val, force(q_val, omega_p, epsilon_p)])\n\n        for _ in range(N):\n            # The system is autonomous, so t is a dummy variable\n            k1 = f(0, y, omega, epsilon)\n            k2 = f(0, y + 0.5 * h * k1, omega, epsilon)\n            k3 = f(0, y + 0.5 * h * k2, omega, epsilon)\n            k4 = f(0, y + h * k3, omega, epsilon)\n            y = y + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        \n        return y[0], y[1]\n\n    # Unperturbed action function J0(q, p)\n    def compute_J0(q, p, omega):\n        return (p**2 + omega**2 * q**2) / (2 * omega)\n\n    for case in test_cases:\n        omega, epsilon, q0, p0, h, T = case\n        \n        N = int(round(T / h))\n        \n        J0_initial = compute_J0(q0, p0, omega)\n\n        # Handle the edge case of J0_initial being zero\n        if J0_initial == 0.0:\n            # For this problem, J0_initial is always non-zero.\n            # If it were zero, drift would be 0 if the final state is also (0,0),\n            # or undefined/infinite otherwise. We can define drift as 0.\n            results.extend([0.0, 0.0])\n            continue\n            \n        # Symplectic (Störmer-Verlet) integration\n        q_final_sv, p_final_sv = stormer_verlet(q0, p0, h, N, omega, epsilon)\n        J0_final_sv = compute_J0(q_final_sv, p_final_sv, omega)\n        delta_rel_sv = abs(J0_final_sv - J0_initial) / J0_initial\n        results.append(delta_rel_sv)\n        \n        # Non-symplectic (RK4) integration\n        q_final_rk4, p_final_rk4 = rk4(q0, p0, h, N, omega, epsilon)\n        J0_final_rk4 = compute_J0(q_final_rk4, p_final_rk4, omega)\n        delta_rel_rk4 = abs(J0_final_rk4 - J0_initial) / J0_initial\n        results.append(delta_rel_rk4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A common goal in numerical simulation is to improve efficiency by using an adaptive time step, which is adjusted based on the local dynamics. This practice explores the crucial and often misunderstood interaction between adaptivity and symplecticity. You will prove and numerically demonstrate that making the time step a function of the phase-space position breaks the symplectic property of the integrator, leading to a distortion of phase-space volume that we sought to avoid in the first place. ",
            "id": "3743640",
            "problem": "Consider a Hamiltonian system on the phase space $\\mathbb{R}^2$ with canonical coordinates $(q,p)$ and Hamiltonian $H(q,p) = \\tfrac{1}{2} p^2 + \\tfrac{1}{2} \\omega^2 q^2$, where $\\omega > 0$ is a fixed parameter. The canonical symplectic form is represented by the constant matrix $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$. A one-stage implicit midpoint Runge-Kutta (RK) method with step size $h > 0$ applied to this system produces the discrete update $z_{n+1} = z_n + h J \\nabla H\\left( \\tfrac{z_n + z_{n+1}}{2} \\right)$, where $z = (q,p)^\\top$.\n\nYou will analyze the effect of local error-based step size adaptivity on the symplecticity and measure preservation of this method. The fundamental base you must use consists of: the definition of a Hamiltonian system with symplectic form, the definition of a symplectic map as one that preserves the symplectic form, and the implicit midpoint method definition above. Do not use any shortcut formulas beyond those derivable from these definitions.\n\nTasks:\n\n1. Derive from first principles the linear update relation for the implicit midpoint method applied to the given quadratic Hamiltonian, in the form $(I - \\tfrac{h}{2} A) z_{n+1} = (I + \\tfrac{h}{2} A) z_n$, where $A$ is the matrix of the linear Hamiltonian vector field. Use this to construct the one-step map $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$.\n\n2. Explain from the definition of a symplectic map (preservation of the two-form) why, for fixed $h$, the one-step map $F_h$ is symplectic and therefore volume-preserving with respect to the Liouville measure. Then, considering a state-dependent step size $h(z)$ determined by local error-based adaptivity, define the adaptive one-step map $F(z) := F_{h(z)}(z)$ and show that this breaks the symplecticity condition. Your argument must start from the symplectic map definition and the chain rule for derivatives, and must not assume any specialized symplectic RK conditions.\n\n3. Quantify the resulting measure distortion by computing, at a given phase point $z^\\ast$, the determinant of the Jacobian $\\mathrm{D}F(z^\\ast)$ of the one-step map. Report the absolute deviation of this determinant from $1$, that is, $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$, as the measure distortion. You must compute $\\mathrm{D}F(z^\\ast)$ numerically by finite differences applied to the explicit mapping implementation from Task 1.\n\nLocal error-based adaptivity model:\n\n- For a baseline step size $h_0 > 0$, define the local error estimator at $z$ by step doubling:\n  $$ e(z;h_0) := \\left\\| F_{h_0}(z) - F_{h_0/2}\\big( F_{h_0/2}(z) \\big) \\right\\|_2. $$\n- For the implicit midpoint method of order $2$, use the standard scaling $e(z;h) \\propto h^3$ to define the adaptive step size\n  $$ h_{\\mathrm{adapt}}(z) := \\operatorname{clip}\\left( h_0 \\left( \\frac{\\mathrm{tol}}{\\max(e(z;h_0), \\epsilon)} \\right)^{1/3},\\, h_{\\min},\\, h_{\\max} \\right), $$\n  where $\\mathrm{tol} > 0$ is the target tolerance, $\\epsilon > 0$ is a small regularization constant, and $h_{\\min}, h_{\\max}$ are bounds to keep the step size finite. The function $\\operatorname{clip}(x,a,b)$ returns $\\min(\\max(x,a),b)$.\n\nImplementation requirements:\n\n- Implement $F_h$ exactly for the quadratic Hamiltonian by solving the linear system from Task 1, using only definitions provided.\n- Implement the adaptive map $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$ using the local error model above.\n- Approximate the Jacobian $\\mathrm{D}F(z^\\ast)$ by central finite differences with a small perturbation $\\delta > 0$.\n- Compute and return the measure distortion $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$ for each test case.\n\nUnits and conventions:\n\n- There are no physical units required for this purely mathematical problem.\n- Angles do not appear in this problem.\n\nTest suite and final output specification:\n\nUse the following parameters and phase points to generate three test cases:\n\n- Shared parameters: $\\omega = 1.7$, $h_0 = 0.12$, $h_{\\min} = 10^{-4}$, $h_{\\max} = 0.5$, $\\epsilon = 10^{-16}$, finite difference perturbation $\\delta = 10^{-8}$.\n\n- Test cases:\n  1. Fixed-step map: $F(z) = F_{h_0}(z)$ at $z^\\ast = (0.3,-0.7)^\\top$.\n  2. Adaptive map with moderate tolerance: $\\mathrm{tol} = 10^{-6}$ at $z^\\ast = (0.3,-0.7)^\\top$.\n  3. Adaptive map near equilibrium: $\\mathrm{tol} = 10^{-6}$ at $z^\\ast = (10^{-3},-2\\cdot 10^{-3})^\\top$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is the floating-point measure distortion $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$ for the corresponding test case, in the order shown above.",
            "solution": "The problem is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It presents a standard exercise in the field of geometric numerical integration, focusing on the properties of the implicit midpoint method applied to a linear Hamiltonian system. All definitions, parameters, and tasks are clearly and consistently specified.\n\nThe solution proceeds by addressing the three tasks in sequence.\n\n### Task 1: Derivation of the One-Step Map\n\nThe system is described by the Hamiltonian $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$ on the phase space $\\mathbb{R}^2$ with state vector $z = (q,p)^\\top$. The gradient of the Hamiltonian is required for Hamilton's equations. We compute it as:\n$$\n\\nabla H(z) = \\begin{pmatrix} \\frac{\\partial H}{\\partial q} \\\\ \\frac{\\partial H}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} \\omega^2 q \\\\ p \\end{pmatrix}\n$$\nThis can be expressed in a linear form $\\nabla H(z) = K z$, where $K$ is the symmetric matrix:\n$$\nK = \\begin{pmatrix} \\omega^2 & 0 \\\\ 0 & 1 \\end{pmatrix}\n$$\nHamilton's equations are given by $\\dot{z} = J \\nabla H(z)$, where $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$. Substituting the linear form of the gradient yields a linear system of ordinary differential equations:\n$$\n\\dot{z} = J K z = A z\n$$\nwhere the matrix $A$ of the linear Hamiltonian vector field is:\n$$\nA = JK = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\begin{pmatrix} \\omega^2 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}\n$$\nThe implicit midpoint method is defined by the discrete update rule:\n$$\nz_{n+1} = z_n + h J \\nabla H\\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\nFor this linear system, this becomes:\n$$\nz_{n+1} = z_n + h A \\left( \\frac{z_n + z_{n+1}}{2} \\right)\n$$\nWe rearrange this equation to solve for $z_{n+1}$:\n$$\nz_{n+1} = z_n + \\frac{h}{2} A z_n + \\frac{h}{2} A z_{n+1}\n$$\n$$\nz_{n+1} - \\frac{h}{2} A z_{n+1} = z_n + \\frac{h}{2} A z_n\n$$\n$$\n\\left(I - \\frac{h}{2} A\\right) z_{n+1} = \\left(I + \\frac{h}{2} A\\right) z_n\n$$\nThis is the required linear update relation. The one-step map $F_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$ is thus given by $z_{n+1} = F_h(z_n)$, where $F_h$ is the linear operator represented by the matrix $M_h$:\n$$\nF_h(z) = M_h z, \\quad \\text{with} \\quad M_h = \\left(I - \\frac{h}{2} A\\right)^{-1} \\left(I + \\frac{h}{2} A\\right)\n$$\nThe matrix $M_h$ is the Cayley transform of the matrix $\\frac{h}{2}A$.\n\n### Task 2: Symplecticity Analysis\n\nA map $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$ is defined as symplectic if its Jacobian, $\\mathrm{D}F$, preserves the symplectic form $J$. That is, for all $z$:\n$$\n(\\mathrm{D}F(z))^\\top J (\\mathrm{D}F(z)) = J\n$$\nA direct consequence of this property is that the determinant of the Jacobian is unity, $\\det(\\mathrm{D}F(z)) = 1$. This implies that the map is volume-preserving with respect to the standard Liouville measure on the phase space.\n\n**Fixed Step Size ($h$)**:\nFor the fixed-step implicit midpoint method, the map is $F_h(z) = M_h z$. As this map is linear, its Jacobian is constant and equal to the matrix $M_h$ itself: $\\mathrm{D}F_h(z) = M_h$. The symplecticity condition becomes:\n$$\nM_h^\\top J M_h = J\n$$\nThis property holds if and only if the matrix $A$ is a Hamiltonian matrix, meaning it belongs to the Lie algebra $\\mathfrak{sp}(2,\\mathbb{R})$. The condition for this is $A^\\top J + JA = 0$. Let us verify this from first principles. With $A=JK$ and $K=K^\\top$:\n$$\nA^\\top J + JA = (JK)^\\top J + J(JK) = K^\\top J^\\top J + J^2 K\n$$\nUsing $J^\\top = -J$ and $J^2 = -I$, this becomes:\n$$\nK (-J) J + (-I) K = -K J^2 - K = -K(-I) - K = K - K = 0\n$$\nThe condition holds. Thus, $M_h$, being the Cayley transform of a Hamiltonian matrix, is a symplectic matrix. The map $F_h$ is therefore symplectic for any fixed step size $h > 0$.\n\n**Adaptive Step Size ($h(z)$)**:\nWhen the step size depends on the state, $h=h(z)$, the one-step map becomes $F(z) = F_{h(z)}(z) = M_{h(z)} z$. This map is no longer linear. We must compute its Jacobian using the product and chain rules:\n$$\n\\mathrm{D}F(z) = \\frac{\\partial}{\\partial z} \\left( M_{h(z)} z \\right) = \\left( \\frac{\\partial}{\\partial z} M_{h(z)} \\right) z + M_{h(z)} \\frac{\\partial z}{\\partial z}\n$$\nThe term $\\frac{\\partial z}{\\partial z}$ is the identity matrix $I$. For the first term, we apply the chain rule: $\\frac{\\partial M_{h(z)}}{\\partial z_j} = \\frac{d M_h}{d h} \\frac{\\partial h}{\\partial z_j}$. This can be written more compactly using tensor notation:\n$$\n\\mathrm{D}F(z) = M_{h(z)} + \\left( \\frac{d M_h}{dh} \\Big|_{h=h(z)} z \\right) \\otimes (\\nabla_z h(z))^\\top\n$$\nwhere $\\otimes$ denotes the outer product. The Jacobian is the sum of the symplectic matrix $M_{h(z)}$ and a rank-$1$ matrix. This sum is, in general, not a symplectic matrix. The symplectic condition is violated unless the second term is zero, which requires $\\nabla_z h(z)=0$. A zero gradient implies that the step size $h$ is locally constant, which reduces to the fixed-step case. Therefore, for a genuinely adaptive step size, the map $F(z)$ is not symplectic, and $\\det(\\mathrm{D}F(z)) \\neq 1$, meaning it does not preserve the phase space volume.\n\n### Task 3: Numerical Quantification of Measure Distortion\n\nTo quantify the deviation from measure preservation, we compute the measure distortion $|\\det(\\mathrm{D}F(z^\\ast)) - 1|$ at a given point $z^\\ast$. The Jacobian $\\mathrm{D}F(z^\\ast)$ is computed numerically using central finite differences with a small perturbation $\\delta = 10^{-8}$. For a map $F:\\mathbb{R}^2 \\to \\mathbb{R}^2$, the columns of its Jacobian $J_{F}$ are approximated as:\n$$\nJ_{F, \\cdot 1}(z^\\ast) \\approx \\frac{F(z^\\ast + (\\delta, 0)^\\top) - F(z^\\ast - (\\delta, 0)^\\top)}{2\\delta}\n$$\n$$\nJ_{F, \\cdot 2}(z^\\ast) \\approx \\frac{F(z^\\ast + (0, \\delta)^\\top) - F(z^\\ast - (0, \\delta)^\\top)}{2\\delta}\n$$\nThe adaptive step size $h_{\\mathrm{adapt}}(z)$ is computed using the provided step-doubling error estimator, and the resulting map $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$ is used in the finite difference formula.\n\nFor Test Case 1 (fixed step), the map is $F(z) = F_{h_0}(z)$. As proven, this map is symplectic with $\\det(\\mathrm{D}F) = 1$. The numerical computation should yield a distortion close to machine precision, reflecting only floating-point and finite difference approximation errors.\n\nFor Test Cases 2 and 3 (adaptive step), the map is $F(z) = F_{h_{\\mathrm{adapt}}(z)}(z)$. A non-zero distortion is expected, as the map is not symplectic. The magnitude of the distortion depends on the gradient of the step size function, $\\nabla_z h(z)$, at the point $z^\\ast$. Near the equilibrium $z=(0,0)^{\\top}$ (Test Case 3), the error estimate $e(z;h_0)$ tends to zero, causing the unclipped adaptive step to become very large and thus be capped at $h_{\\max}$. In this region, $h(z)$ is nearly constant, so $\\nabla_z h(z) \\approx 0$, and the map is nearly symplectic. We thus anticipate a smaller measure distortion in Test Case 3 compared to Test Case 2.\n\nThe following Python code implements this numerical analysis.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the measure distortion for the implicit midpoint method under fixed and\n    adaptive step size strategies.\n    \n    This function implements the three test cases specified in the problem:\n    1. Fixed-step size map.\n    2. Adaptive step size map with a moderate tolerance.\n    3. Adaptive step size map near the equilibrium point.\n    \n    The measure distortion is defined as |det(DF) - 1|, where DF is the Jacobian\n    of the one-step map, computed numerically via finite differences.\n    \"\"\"\n\n    # Shared parameters from the problem statement\n    omega = 1.7\n    h0 = 0.12\n    hmin = 1e-4\n    hmax = 0.5\n    epsilon = 1e-16\n    delta = 1e-8\n\n    def F_h(z, h, omega_val):\n        \"\"\"\n        Implements the one-step map F_h for the linear Hamiltonian system.\n        z_next = (I - h/2 * A)^-1 * (I + h/2 * A) * z\n        \"\"\"\n        A = np.array([[0.0, 1.0], [-omega_val**2, 0.0]])\n        I = np.identity(2)\n        \n        # Linear system: (I - h/2 * A) * z_next = (I + h/2 * A) * z\n        mat_lhs = I - (h / 2.0) * A\n        mat_rhs = I + (h / 2.0) * A\n        vec_rhs = mat_rhs @ z\n        \n        return np.linalg.solve(mat_lhs, vec_rhs)\n\n    def h_adapt(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Computes the adaptive step size h(z) based on a local error estimator.\n        \"\"\"\n        # Step-doubling error estimator\n        z_h0 = F_h(z, h0_val, omega_val)\n        z_h0_half = F_h(z, h0_val / 2.0, omega_val)\n        z_h0_half_half = F_h(z_h0_half, h0_val / 2.0, omega_val)\n        error = np.linalg.norm(z_h0 - z_h0_half_half)\n        \n        # Adaptive step size formula\n        h_unclipped = h0_val * (tol_val / max(error, epsilon))**(1.0 / 3.0)\n        \n        # Clip the step size to the specified bounds\n        return np.clip(h_unclipped, hmin, hmax)\n\n    def F_adaptive(z, h0_val, tol_val, omega_val):\n        \"\"\"\n        Implements the adaptive one-step map F(z) = F_{h_adapt(z)}(z).\n        \"\"\"\n        h_eff = h_adapt(z, h0_val, tol_val, omega_val)\n        return F_h(z, h_eff, omega_val)\n\n    def compute_jacobian(F_map, z_star, delta_val):\n        \"\"\"\n        Approximates the Jacobian of a map F at z_star using central finite differences.\n        \"\"\"\n        z_star = np.asarray(z_star, dtype=float)\n        \n        # Perturb q (first coordinate)\n        pert_q = np.array([delta_val, 0.0])\n        J_col1 = (F_map(z_star + pert_q) - F_map(z_star - pert_q)) / (2.0 * delta_val)\n        \n        # Perturb p (second coordinate)\n        pert_p = np.array([0.0, delta_val])\n        J_col2 = (F_map(z_star + pert_p) - F_map(z_star - pert_p)) / (2.0 * delta_val)\n        \n        return np.column_stack([J_col1, J_col2])\n\n    test_cases = [\n        # (Case Type, Tolerance, z_star)\n        (\"fixed\", None, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([0.3, -0.7])),\n        (\"adaptive\", 1e-6, np.array([1e-3, -2e-3]))\n    ]\n    \n    results = []\n    \n    for case_type, tol, z_star in test_cases:\n        if case_type == \"fixed\":\n            # Define a lambda to match the expected signature of compute_jacobian\n            map_func = lambda z: F_h(z, h0, omega)\n        else: # case_type == \"adaptive\"\n            map_func = lambda z: F_adaptive(z, h0, tol, omega)\n            \n        jacobian = compute_jacobian(map_func, z_star, delta)\n        determinant = np.linalg.det(jacobian)\n        distortion = abs(determinant - 1.0)\n        results.append(distortion)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}