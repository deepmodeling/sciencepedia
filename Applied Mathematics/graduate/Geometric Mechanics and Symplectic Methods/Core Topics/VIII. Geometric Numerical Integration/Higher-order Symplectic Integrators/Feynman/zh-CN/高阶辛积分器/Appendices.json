{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础但至关重要的练习开始，它构成了许多显式辛积分器的核心。Strang分裂法是一种为可分哈密顿系统设计的二阶对称辛方法，通过交替求解动能和势能部分的精确流动来近似完整系统的演化。这个练习 () 将指导您为四次势中的粒子推导单步Strang分裂的显式更新公式，从而让您亲手实践这些积分器在算法层面的构建方式。",
            "id": "3746144",
            "problem": "考虑一个质量为 $m$ 的一维粒子，其哈密顿量为 $H(q,p)=T(p)+V(q)$，其中 $T(p)=\\frac{p^{2}}{2m}$ 且 $V(q)=\\frac{\\lambda}{4}q^{4}$，$\\lambda > 0$ 为一个常数。从哈密顿流和哈密顿方程的定义出发，推导由动能子哈密顿量 $T(p)$ 和势能子哈密顿量 $V(q)$ 生成的精确流。然后，通过组合一个 $V$-流的半步、一个 $T$-流的全步以及一个 $V$-流的半步，实现时间步长为 $h > 0$ 的对称二阶分裂（称为 Strang 分裂）的一个步骤。设初始状态在时间 $t=0$ 时为 $(q_{0},p_{0})$。计算并明确给出经过这单步 Strang 分裂后 $(q_{1},p_{1})$ 的更新公式的闭合形式，该公式应仅用 $q_{0}$、$p_{0}$、$m$、$\\lambda$ 和 $h$ 表示。不需要进行四舍五入，最终答案应以符号表达式的形式给出。最终报告的结果必须仅为 $q_{1}$ 和 $p_{1}$ 的解析表达式。",
            "solution": "用户希望我按照以下步骤解决问题：\n1. 验证问题陈述。\n2. 如果有效，则推导解答。\n\n### 步骤 1：提取已知条件\n- **哈密顿量：** $H(q,p) = T(p) + V(q)$\n- **动能：** $T(p) = \\frac{p^{2}}{2m}$\n- **势能：** $V(q) = \\frac{\\lambda}{4}q^{4}$\n- **常数：** $m > 0$，$\\lambda > 0$，$h > 0$\n- **初始状态：** $(q_0, p_0)$ 于时间 $t=0$\n- **任务：** 推导特定 Strang 分裂方案单步的更新公式：组合一个 $V$-流的半步、一个 $T$-流的全步和一个 $V$-流的半步。最终状态为 $(q_1, p_1)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题设置在哈密顿力学和几何数值积分的成熟框架内。哈密顿量描述了一个一维非谐振子，这是一个标准的物理模型。Strang 分裂是一种基础且广泛使用的二阶辛积分方法。问题的前提在物理上和数学上都是合理的。\n- **适定性：** 问题描述清晰。哈密顿量是可分的，这是所述分裂方法的必要条件。所有需要的信息（$H$、初始条件、参数以及流的具体组合）都已提供。推导单步更新公式的任务会得出一个唯一且有意义的结果。\n- **客观性：** 问题使用精确、无歧义的数学和技术语言陈述，不含主观内容。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它具有科学依据、适定且客观。它没有违反任何无效标准。我现在将继续进行解答。\n\n该问题要求为一个状态为 $(q, p)$ 的粒子推导单步更新规则，该粒子在哈密顿量 $H(q,p) = T(p)+V(q) = \\frac{p^2}{2m} + \\frac{\\lambda}{4}q^4$ 的作用下演化。其演化过程使用一个特定的对称分裂方法在一个时间步长 $h$ 上进行近似。\n\n首先，我们必须推导由动能子哈密顿量 $T(p)$ 和势能子哈密顿量 $V(q)$ 生成的精确流。由哈密顿量 $H$ 控制的系统演化由哈密顿方程描述：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p}, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q}\n$$\n\n**动能子哈密顿量 $T(p)$ 的流**\n我们考虑仅由 $H_T = T(p) = \\frac{p^2}{2m}$ 控制的系统。该子系统的哈密顿方程为：\n$$\n\\dot{q} = \\frac{\\partial T}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\frac{p^2}{2m} \\right) = \\frac{p}{m}\n$$\n$$\n\\dot{p} = -\\frac{\\partial T}{\\partial q} = 0\n$$\n为了找到时间间隔 $\\Delta t$ 内的流，我们对这些常微分方程进行积分。从 $t=0$ 时的初始状态 $(q_{\\text{init}}, p_{\\text{init}})$ 开始：\n方程 $\\dot{p} = 0$ 意味着 $p(t)$ 是常数。因此，$p(t) = p_{\\text{init}}$。\n将此代入第一个方程得到 $\\dot{q} = \\frac{p_{\\text{init}}}{m}$。对此随时间积分可得：\n$$\nq(\\Delta t) = q_{\\text{init}} + \\int_0^{\\Delta t} \\frac{p_{\\text{init}}}{m} dt = q_{\\text{init}} + \\frac{p_{\\text{init}}}{m} \\Delta t\n$$\n因此，动能部分的精确流映射 $\\Phi_T^{\\Delta t}$ 为：\n$$\n\\Phi_T^{\\Delta t}(q, p) = \\left(q + \\frac{p}{m} \\Delta t, \\, p\\right)\n$$\n\n**势能子哈密顿量 $V(q)$ 的流**\n接下来，我们考虑仅由 $H_V = V(q) = \\frac{\\lambda}{4}q^4$ 控制的系统。该子系统的哈密顿方程为：\n$$\n\\dot{q} = \\frac{\\partial V}{\\partial p} = 0\n$$\n$$\n\\dot{p} = -\\frac{\\partial V}{\\partial q} = -\\frac{\\partial}{\\partial q} \\left( \\frac{\\lambda}{4}q^4 \\right) = -\\lambda q^3\n$$\n从初始状态 $(q_{\\text{init}}, p_{\\text{init}})$ 开始，在时间间隔 $\\Delta t$ 内对这些方程进行积分：\n方程 $\\dot{q} = 0$ 意味着 $q(t)$ 是常数。因此，$q(t) = q_{\\text{init}}$。\n将此代入第二个方程得到 $\\dot{p} = -\\lambda q_{\\text{init}}^3$。对此随时间积分可得：\n$$\np(\\Delta t) = p_{\\text{init}} + \\int_0^{\\Delta t} (-\\lambda q_{\\text{init}}^3) dt = p_{\\text{init}} - \\lambda q_{\\text{init}}^3 \\Delta t\n$$\n因此，势能部分的精确流映射 $\\Phi_V^{\\Delta t}$ 为：\n$$\n\\Phi_V^{\\Delta t}(q, p) = \\left(q, \\, p - \\lambda q^3 \\Delta t\\right)\n$$\n\n**Strang 分裂步骤**\n问题指定了一个二阶对称分裂方案，该方案由一个 $V$-流的半步、一个 $T$-流的全步和另一个 $V$-流的半步组合而成。步长为 $h$ 的单步算子记为 $\\mathcal{S}_h$，是这些流的复合，从右到左依次应用：\n$$\n\\mathcal{S}_h = \\Phi_V^{h/2} \\circ \\Phi_T^h \\circ \\Phi_V^{h/2}\n$$\n这是 Strang 分裂的一种有效形式，常用于位置-Verlet (position-Verlet) 或蛙跳 (leapfrog) 积分方案。设步骤开始时的状态为 $(q_0, p_0)$。经过一个步骤后的状态 $(q_1, p_1)$ 由 $\\mathcal{S}_h(q_0, p_0)$ 给出。我们通过依次应用这些映射来计算它。\n\n1.  **第一个 $V$-流半步：** 设 $(q_a, p_a) = \\Phi_V^{h/2}(q_0, p_0)$。时间间隔为 $\\Delta t = h/2$。\n    $$\n    q_a = q_0\n    $$\n    $$\n    p_a = p_0 - \\lambda q_0^3 \\frac{h}{2}\n    $$\n\n2.  **$T$-流全步：** 设 $(q_b, p_b) = \\Phi_T^h(q_a, p_a)$。时间间隔为 $\\Delta t = h$。\n    $$\n    q_b = q_a + \\frac{p_a}{m} h\n    $$\n    $$\n    p_b = p_a\n    $$\n    代入 $(q_a, p_a)$ 的表达式：\n    $$\n    q_b = q_0 + \\frac{h}{m} \\left(p_0 - \\frac{\\lambda h}{2} q_0^3 \\right) = q_0 + \\frac{h p_0}{m} - \\frac{\\lambda h^2}{2m} q_0^3\n    $$\n    $$\n    p_b = p_0 - \\frac{\\lambda h}{2} q_0^3\n    $$\n\n3.  **第二个 $V$-流半步：** 最终状态为 $(q_1, p_1) = \\Phi_V^{h/2}(q_b, p_b)$。时间间隔为 $\\Delta t = h/2$。\n    $$\n    q_1 = q_b\n    $$\n    $$\n    p_1 = p_b - \\lambda q_b^3 \\frac{h}{2}\n    $$\n    代入 $(q_b, p_b)$ 的表达式：\n    对于 $q_1$：\n    $$\n    q_1 = q_b = q_0 + \\frac{h p_0}{m} - \\frac{\\lambda h^2}{2m} q_0^3\n    $$\n    对于 $p_1$：\n    $$\n    p_1 = \\left(p_0 - \\frac{\\lambda h}{2} q_0^3\\right) - \\frac{\\lambda h}{2} \\left(q_0 + \\frac{h p_0}{m} - \\frac{\\lambda h^2}{2m} q_0^3\\right)^3\n    $$\n\n这些就是 $(q_1, p_1)$ 的显式闭合形式更新公式，仅用初始状态 $(q_0, p_0)$ 和系统参数 $m, \\lambda, h$ 表示。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nq_{0} + \\frac{h p_{0}}{m} - \\frac{\\lambda h^{2} q_{0}^{3}}{2m} \\\\\np_{0} - \\frac{\\lambda h}{2} q_{0}^{3} - \\frac{\\lambda h}{2} \\left( q_{0} + \\frac{h p_{0}}{m} - \\frac{\\lambda h^{2} q_{0}^{3}}{2m} \\right)^{3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然二阶方法（如Strang分裂）很有用，但为了在给定步长下获得更高精度，我们通常需要更高阶的积分器。一个强大而优雅的技术是通过组合一个基础的二阶对称方法来构造更高阶的方法。这个练习 () 深入探讨了这一构造背后的理论，要求您推导将二阶核组合成四阶积分器所需的代数条件，并求解著名的Forest-Ruth/Yoshida算法的系数。",
            "id": "3746170",
            "problem": "考虑一个辛流形上的哈密顿系统，其哈密顿量为 $H = A + B + C$，其中 $A$，$B$ 和 $C$ 是光滑函数，它们关联的哈密顿向量场生成的流可以被精确计算。设 $L_{A}$，$L_{B}$ 和 $L_{C}$ 是相应的李导数算子，因此时间 $h$ 内的精确流为 $\\exp\\!\\big(h(L_{A} + L_{B} + L_{C})\\big)$。通过在回文序列中组合精确子流来定义对称二阶核 $S_{2}(h)$\n$$\nS_{2}(h) \\equiv \\exp\\!\\big(\\tfrac{h}{2} L_{A}\\big)\\,\\exp\\!\\big(\\tfrac{h}{2} L_{B}\\big)\\,\\exp\\!\\big(h L_{C}\\big)\\,\\exp\\!\\big(\\tfrac{h}{2} L_{B}\\big)\\,\\exp\\!\\big(\\tfrac{h}{2} L_{A}\\big).\n$$\n您需要构建一个对称四阶辛积分器，它由 $S_{2}$ 在缩放时间步长下的组合构成：\n$$\n\\Phi(h) \\equiv \\prod_{i=1}^{s} S_{2}(\\gamma_{i} h),\n$$\n其中组合按回文顺序进行，待定实系数为 $\\gamma_{i}$。从 Baker–Campbell–Hausdorff 展开式以及 $S_{2}(h)$ 是一个对称二阶方法这一事实出发，推导对于任意 $A$，$B$ 和 $C$，$\\Phi(h)$ 达到四阶精度时系数 $\\{\\gamma_{i}\\}_{i=1}^{s}$ 所需满足的充要代数条件。然后，限定在最小的非平凡回文情况 $s=3$ 且 $\\gamma_{1}=\\gamma_{3}$，求解这些条件以得出一组显式的有效系数。\n\n您的最终答案必须是三元组 $(\\gamma_{1},\\gamma_{2},\\gamma_{3})$ 的单一闭式表达式，写成行矩阵的形式。不需要数值四舍五入，也不涉及物理单位。如果存在角度，请用弧度表示。最终答案中不要报告任何不等式或方程式；只报告系数三元组。",
            "solution": "该问题是有效的。这是一个适定且标准的问题，属于几何数值积分领域，具体是关于从一个基本的对称二阶核构建高阶辛积分器。所有术语都有正式定义，且问题是自洽的。\n\n设 $L_H = L_A + L_B + L_C$ 是与完整哈密顿量 $H$ 相关联的李导数算子。步长为 $h$ 的精确时间演化由算子 $\\exp(h L_H)$ 给出。\n所提供的二阶核 $S_2(h)$ 是一种对称方法。如果一个方法 $\\Psi(h)$ 满足 $\\Psi(h)\\Psi(-h) = \\text{Id}$，则称其为对称的，这意味着它表示为单个算子的指数形式 $\\Psi(h) = \\exp(L_{\\Psi}(h))$ 时，其李级数展开式 $L_{\\Psi}(h)$ 仅包含 $h$ 的奇次幂。\n由于 $S_2(h)$ 是一个二阶方法，其有效李算子 $L_{S_2}(h)$ 必须与精确算子在 $h^2$ 阶之前保持一致。因此，我们可以将其展开式写为：\n$$\nL_{S_2}(h) = h L_H + K_3 h^3 + K_5 h^5 + \\mathcal{O}(h^7)\n$$\n其中 $K_3, K_5, \\ldots$ 是表示为 $L_A$，$L_B$ 和 $L_C$ 的嵌套李括号的算子。为使该方法真正是二阶而非更高阶，对于任意选择的 $A, B, C$，$K_3$ 必须非零。\n\n四阶积分器 $\\Phi(h)$ 是通过组合 $s$ 个这样的二阶核（使用缩放的时间步长 $\\gamma_i h$）来构建的：\n$$\n\\Phi(h) = \\prod_{i=1}^{s} S_2(\\gamma_i h) = S_2(\\gamma_1 h) S_2(\\gamma_2 h) \\cdots S_2(\\gamma_s h)\n$$\n将此乘积中的每一项表示为指数映射，我们得到：\n$$\n\\Phi(h) = \\exp(L_{S_2}(\\gamma_1 h)) \\exp(L_{S_2}(\\gamma_2 h)) \\cdots \\exp(L_{S_2}(\\gamma_s h))\n$$\n为了找到满足 $\\Phi(h) = \\exp(L_{\\Phi}(h))$ 的单个有效李算子 $L_{\\Phi}(h)$，我们应用 Baker–Campbell–Hausdorff (BCH) 公式。到主导阶，BCH 公式给出：\n$$\nL_{\\Phi}(h) = \\sum_{i=1}^{s} L_{S_2}(\\gamma_i h) + \\frac{1}{2} \\sum_{1 \\le i  j \\le s} [L_{S_2}(\\gamma_i h), L_{S_2}(\\gamma_j h)] + \\ldots\n$$\n代入 $L_{S_2}(h)$ 的展开式：\n$$\nL_{S_2}(\\gamma_i h) = (\\gamma_i h) L_H + K_3 (\\gamma_i h)^3 + \\mathcal{O}(h^5)\n$$\n求和项变为：\n$$\n\\sum_{i=1}^{s} L_{S_2}(\\gamma_i h) = \\sum_{i=1}^{s} \\left( \\gamma_i h L_H + \\gamma_i^3 h^3 K_3 \\right) + \\mathcal{O}(h^5) = h \\left(\\sum_{i=1}^{s} \\gamma_i\\right) L_H + h^3 \\left(\\sum_{i=1}^{s} \\gamma_i^3\\right) K_3 + \\mathcal{O}(h^5)\n$$\n对易子项 $[L_{S_2}(\\gamma_i h), L_{S_2}(\\gamma_j h)]$ 通常是 $\\mathcal{O}(h^2)$ 阶的，但其主导项为 $[\\gamma_i h L_H, \\gamma_j h L_H] = \\gamma_i \\gamma_j h^2 [L_H, L_H] = 0$。对易子中的下一项是 $\\mathcal{O}(h^4)$ 阶的，因此它们不影响最终算子的 $\\mathcal{O}(h^3)$ 项。\n因此，组合方法的李算子为：\n$$\nL_{\\Phi}(h) = h \\left(\\sum_{i=1}^{s} \\gamma_i\\right) L_H + h^3 \\left(\\sum_{i=1}^{s} \\gamma_i^3\\right) K_3 + \\mathcal{O}(h^5)\n$$\n为了使 $\\Phi(h)$ 成为一个四阶方法，其李算子 $L_{\\Phi}(h)$ 必须与精确算子 $h L_H$ 在 $h^4$ 阶项之前都一致。这导致了对系数 $\\gamma_i$ 的两个条件：\n1.  **相容性（1阶正确性）：** $h L_H$ 项的系数必须为 $1$。\n    $$ \\sum_{i=1}^{s} \\gamma_i = 1 $$\n2.  **4阶正确性：** $h^3 K_3$ 误差项的系数必须为零。\n    $$ \\sum_{i=1}^{s} \\gamma_i^3 = 0 $$\n这些就是充要代数条件。\n\n现在，我们针对最小的非平凡回文情况 $s=3$ 且 $\\gamma_1 = \\gamma_3$ 求解这些条件。这两个条件变成了一个关于两个未知数 $\\gamma_1$ 和 $\\gamma_2$ 的方程组：\n1.  $2\\gamma_1 + \\gamma_2 = 1$\n2.  $2\\gamma_1^3 + \\gamma_2^3 = 0$\n\n从第一个方程，我们用 $\\gamma_1$ 表示 $\\gamma_2$：\n$$ \\gamma_2 = 1 - 2\\gamma_1 $$\n将此代入第二个方程：\n$$ 2\\gamma_1^3 + (1 - 2\\gamma_1)^3 = 0 $$\n这个方程可以重排为：\n$$ (1 - 2\\gamma_1)^3 = -2\\gamma_1^3 $$\n由于问题规定 $\\gamma_i$ 是实系数，我们可以对两边取实数立方根：\n$$ 1 - 2\\gamma_1 = (-2)^{\\frac{1}{3}} \\gamma_1 = -\\sqrt[3]{2} \\gamma_1 $$\n现在我们求解 $\\gamma_1$：\n$$ 1 = 2\\gamma_1 - \\sqrt[3]{2}\\gamma_1 = \\gamma_1(2 - \\sqrt[3]{2}) $$\n$$ \\gamma_1 = \\frac{1}{2 - \\sqrt[3]{2}} $$\n根据回文条件，我们得到 $\\gamma_3$：\n$$ \\gamma_3 = \\gamma_1 = \\frac{1}{2 - \\sqrt[3]{2}} $$\n最后，我们使用关系式 $\\gamma_2 = 1 - 2\\gamma_1$ 求出 $\\gamma_2$：\n$$ \\gamma_2 = 1 - 2 \\left( \\frac{1}{2 - \\sqrt[3]{2}} \\right) = \\frac{(2 - \\sqrt[3]{2}) - 2}{2 - \\sqrt[3]{2}} = \\frac{-\\sqrt[3]{2}}{2 - \\sqrt[3]{2}} $$\n因此，显式的有效系数集是三元组 $(\\gamma_1, \\gamma_2, \\gamma_3)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2 - \\sqrt[3]{2}} & \\frac{-\\sqrt[3]{2}}{2 - \\sqrt[3]{2}} & \\frac{1}{2 - \\sqrt[3]{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论知识最终需要通过实际应用来巩固，这个综合性练习旨在将前面的概念付诸实践。开普勒问题是测试数值积分器的经典非平凡基准，因为它具有奇异性和多个守恒量。在这个顶点练习 () 中，您将为开普勒问题实现前一个练习中推导的四阶分裂法，并将其性能与另一种强大的四阶辛方法——隐式高斯配点法——进行比较，从而深入理解不同类型辛积分器在实际物理问题中的实现复杂度和长期保真度。",
            "id": "3746162",
            "problem": "考虑平面开普勒问题的典范哈密顿系统，该系统采用无量纲单位，引力参数等于$1$。哈密顿量为$H(q,p) = \\tfrac{1}{2}\\lVert p \\rVert^{2} - \\lVert q \\rVert^{-1}$，其中$q \\in \\mathbb{R}^{2}$且$p \\in \\mathbb{R}^{2}$。哈密顿方程为$ \\dot{q} = \\partial H / \\partial p$和$ \\dot{p} = - \\partial H / \\partial q$。由此得到的常微分方程为$ \\dot{q} = p$和$ \\dot{p} = - q / \\lVert q \\rVert^{3}$。当出现角度时，必须以弧度为单位进行解释，并且所有量均为无量纲。\n\n从典范哈密顿系统和配点龙格-库塔方法的基本定义出发，推导用于一般自治系统$ \\dot{y} = f(y)$的两级高斯配点法（这是一种四阶保辛的隐式龙格-库塔方法）。然后，将此方法应用于由$ f(q,p) = (p, - q / \\lVert q \\rVert^{3})$定义的开普勒矢量场，并使用牛顿迭代法求解其阶方程，其中开普勒矢量场的雅可比矩阵通过解析推导得出。另外，通过将可分哈密顿量$H = T(p) + V(q)$的三个二阶对称Strang分裂步组合成一个四阶方法（这是由Hiroshi Yoshida提出的标准四阶组合方法），构建一个四阶保辛分裂积分器。通过在每个子步中使用$T$和$V$的精确流，为开普勒问题实现这种分裂方法。\n\n使用这两种积分器，根据以下初始条件和数值参数，模拟多个轨道周期内的长期能量行为。轨道为椭圆形，半长轴$a = 1$，因此轨道周期为$T_{\\mathrm{orbit}} = 2\\pi$。每种情况都在近拱点进行初始化，初始条件为$q(0) = (1 - e, 0)$和$p(0) = (0, \\sqrt{(1+e)/(1-e)})$，这使得对于所有离心率$e$，能量均为$H = -\\tfrac{1}{2}$。对于每种情况，使用步长$h$积分$N_{\\mathrm{per}}$个周期，并为每个积分器计算整个模拟过程中的最大绝对能量偏差，\n$$\nE_{\\max} = \\max_{0 \\le t \\le N_{\\mathrm{per}} T_{\\mathrm{orbit}}} \\left| H(q(t),p(t)) - H(q(0),p(0)) \\right|.\n$$\n为确保在相似计算成本下进行公平比较，每种情况下两种方法使用相同的步长$h$。所有报告的能量偏差必须以无量纲能量单位表示。\n\n测试套件包含以下四种情况：\n- 情况$1$：$e = 0$，$h = 0.05$，$N_{\\mathrm{per}} = 10$。\n- 情况$2$：$e = 0.1$，$h = 0.05$，$N_{\\mathrm{per}} = 10$。\n- 情况$3$：$e = 0.6$，$h = 0.02$，$N_{\\mathrm{per}} = 10$。\n- 情况$4$：$e = 0.9$，$h = 0.005$，$N_{\\mathrm{per}} = 10$。\n\n您的程序必须实现这两种积分器，对所有四种情况运行它们，并按顺序为每种情况输出高斯配点法和四阶分裂方法的最大绝对能量偏差。最终输出必须是单行文本，包含一个由四个序对$[E_{\\max}^{\\mathrm{Gauss}}, E_{\\max}^{\\mathrm{Split}}]$组成的列表，每个序对应一种情况，并按上述顺序排列。最终输出格式必须严格为方括号括起来的逗号分隔列表，例如，$[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}],[x_{4},y_{4}]]$，其中每个$x_{i}$和$y_{i}$都是浮点数，表示情况$i$的无量纲能量单位的能量偏差。",
            "solution": "用户提供了一个科学上合理、适定且完整的问题。我现在将进行形式化的推导和求解。\n\n该问题要求推导、实现并比较两种用于平面开普勒问题的四阶保辛数值积分器。哈密顿量为$H(q,p) = \\frac{1}{2}\\lVert p \\rVert^{2} - \\lVert q \\rVert^{-1}$，其中$q, p \\in \\mathbb{R}^{2}$。运动方程为$\\dot{q} = p$和$\\dot{p} = -q/\\lVert q \\rVert^3$。我们用一个向量$y = (q_x, q_y, p_x, p_y)^T \\in \\mathbb{R}^4$来表示系统状态。该系统是一个形式为$\\dot{y} = f(y)$的自治常微分方程（ODE）。\n\n### 第一部分：两级高斯配点法\n\n#### 配点龙格-库塔方法的一般推导\n配点法通过一个$s$次多项式$u(\\tau)$来近似$\\dot{y} = f(y)$在大小为$h = t_{n+1} - t_n$的时间步$[t_n, t_{n+1}]$上的解。该多项式受以下条件约束：\n1.  它在时间步开始时与解匹配：$u(t_n) = y_n$。\n2.  它在$s$个不同的配点$t_n + c_i h$（其中$i=1, \\dots, s$，$c_i \\in [0, 1]$为配点节点）处满足微分方程。\n    $$ \\dot{u}(t_n + c_i h) = f(u(t_n + c_i h)) $$\n数值解在时间步结束时被定义为$y_{n+1} = u(t_{n+1})$。\n\n我们将阶导数定义为$k_i = \\dot{u}(t_n + c_i h)$。多项式$\\dot{u}(t_n + \\tau h)$的次数为$s-1$，并穿过点$(c_i, k_i)$。我们可以使用拉格朗日基多项式$L_j(\\tau) = \\prod_{l \\neq j} \\frac{\\tau - c_l}{c_j - c_l}$来表示它：\n$$ \\dot{u}(t_n + \\tau h) = \\sum_{j=1}^s k_j L_j(\\frac{\\tau-t_n}{h}) $$\n从$t_n$到$t_n + \\tau h$积分，得到多项式$u$本身：\n$$ u(t_n + \\tau h) = y_n + h \\int_0^\\tau \\sum_{j=1}^s k_j L_j(\\sigma) d\\sigma = y_n + h \\sum_{j=1}^s k_j \\int_0^\\tau L_j(\\sigma) d\\sigma $$\n阶值为$Y_i = u(t_n + c_i h)$。配点条件$k_i = f(Y_i)$变为：\n$$ Y_i = y_n + h \\sum_{j=1}^s k_j \\int_0^{c_i} L_j(\\sigma) d\\sigma $$\n$$ k_i = f(Y_i) = f\\left(y_n + h \\sum_{j=1}^s a_{ij} k_j\\right) \\quad \\text{其中 } a_{ij} = \\int_0^{c_i} L_j(\\sigma) d\\sigma $$\n最终的更新为$y_{n+1} = u(t_n+h)$：\n$$ y_{n+1} = y_n + h \\sum_{j=1}^s k_j \\int_0^1 L_j(\\sigma) d\\sigma = y_n + h \\sum_{j=1}^s b_j k_j \\quad \\text{其中 } b_j = \\int_0^1 L_j(\\sigma) d\\sigma $$\n这是一个$s$级龙格-库塔方法的标准形式。\n\n#### 两级高斯-勒让德方法 ($s=2$)\n高斯-勒让德方法是一类配点方法，其配点$c_i$是移位到区间$[0,1]$上的勒让德多项式$P_s(x)$的根。对于$s=2$，我们使用$P_2(2x-1)$的根。勒让德多项式为$P_2(z) = \\frac{1}{2}(3z^2-1)$。$P_2(2x-1) = 6x^2-6x+1$的根是：\n$$ c_{1,2} = \\frac{6 \\pm \\sqrt{36-24}}{12} = \\frac{1}{2} \\pm \\frac{\\sqrt{12}}{12} = \\frac{1}{2} \\pm \\frac{\\sqrt{3}}{6} $$\n这两点的拉格朗日基多项式为$L_1(\\sigma) = \\frac{\\sigma-c_2}{c_1-c_2}$和$L_2(\\sigma) = \\frac{\\sigma-c_1}{c_2-c_1}$。计算$a_{ij}$和$b_i$的积分，得到Butcher表：\n$$\n\\begin{array}{c|cc}\nc_1 & a_{11} & a_{12} \\\\\nc_2 & a_{21} & a_{22} \\\\\n\\hline\n& b_1 & b_2\n\\end{array}\n=\n\\begin{array}{c|cc}\n\\frac{1}{2} - \\frac{\\sqrt{3}}{6} & \\frac{1}{4} & \\frac{1}{4} - \\frac{\\sqrt{3}}{6} \\\\\n\\frac{1}{2} + \\frac{\\sqrt{3}}{6} & \\frac{1}{4} + \\frac{\\sqrt{3}}{6} & \\frac{1}{4} \\\\\n\\hline\n& \\frac{1}{2} & \\frac{1}{2}\n\\end{array}\n$$\n该方法的阶数为$2s=4$。一个龙格-库塔方法是保辛的，如果$b_i > 0$且元素为$M_{ij} = b_i a_{ij} + b_j a_{ji} - b_i b_j$的矩阵$M$为零矩阵。对于两级高斯方法，$b_1=b_2=1/2$，并且很容易验证对于所有$i,j \\in \\{1,2\\}$都有$M_{ij}=0$，因此该方法是保辛的。\n\n#### 针对开普勒问题的实现\n阶方程为阶导数$K_1, K_2 \\in \\mathbb{R}^4$构成了一个非线性方程组：\n$$ K_1 = f\\left(y_n + h(a_{11}K_1 + a_{12}K_2)\\right) $$\n$$ K_2 = f\\left(y_n + h(a_{21}K_1 + a_{22}K_2)\\right) $$\n我们使用牛顿法求解这个关于$(K_1, K_2)$的$8$维系统。设$Z = (K_1^T, K_2^T)^T \\in \\mathbb{R}^8$。我们寻求函数$G(Z)=0$的一个根：\n$$ G(Z) = \\begin{pmatrix} K_1 - f(y_n + h(a_{11}K_1 + a_{12}K_2)) \\\\ K_2 - f(y_n + h(a_{21}K_1 + a_{22}K_2)) \\end{pmatrix} $$\n牛顿迭代为$Z_{k+1} = Z_k - J_G(Z_k)^{-1} G(Z_k)$。雅可比矩阵$J_G = \\partial G / \\partial Z$是一个$8 \\times 8$的分块矩阵：\n$$ J_G = \\begin{pmatrix} I_4 - h a_{11} J_f(Y_1) & -h a_{12} J_f(Y_1) \\\\ -h a_{21} J_f(Y_2) & I_4 - h a_{22} J_f(Y_2) \\end{pmatrix} $$\n其中$Y_1 = y_n + h(a_{11}K_1 + a_{12}K_2)$，$Y_2 = y_n + h(a_{21}K_1 + a_{22}K_2)$，$I_4$是$4 \\times 4$的单位矩阵，而$J_f(y)$是开普勒矢量场$f(y)$的雅可比矩阵。\n\n矢量场为$f(q, p) = (p, -q/r^3)$，其中$r = \\lVert q \\rVert$。雅可比矩阵$J_f(y) = \\partial f / \\partial y$为：\n$$ J_f(q, p) = \\begin{pmatrix} \\partial \\dot{q} / \\partial q & \\partial \\dot{q} / \\partial p \\\\ \\partial \\dot{p} / \\partial q & \\partial \\dot{p} / \\partial p \\end{pmatrix} = \\begin{pmatrix} 0_{2 \\times 2} & I_{2 \\times 2} \\\\ A_{qp} & 0_{2 \\times 2} \\end{pmatrix} $$\n非平凡块是$A_{qp} = \\partial(-q/r^3)/\\partial q$。其分量为：\n$$ (A_{qp})_{ij} = \\frac{\\partial}{\\partial q_j}\\left(-\\frac{q_i}{r^3}\\right) = -\\frac{\\delta_{ij}}{r^3} - q_i(-3r^{-4})\\frac{\\partial r}{\\partial q_j} = -\\frac{\\delta_{ij}}{r^3} + \\frac{3q_i q_j}{r^5} $$\n写成矩阵形式，$A_{qp} = \\frac{3}{r^5}qq^T - \\frac{1}{r^3}I_{2 \\times 2}$。一旦牛顿迭代收敛以求得$K_1, K_2$，状态就更新为：$y_{n+1} = y_n + \\frac{h}{2}(K_1 + K_2)$。\n\n### 第二部分：四阶保辛分裂方法\n\n#### 分裂方法的一般理论\n对于一个可分的哈密顿量$H(q,p) = T(p) + V(q)$，哈密顿方程可以分裂成两个可精确求解的子系统：\n1.  $\\dot{q} = \\partial T / \\partial p$, $\\dot{p} = 0$，其精确流为$\\phi_t^T$。\n2.  $\\dot{q} = 0$, $\\dot{p} = -\\partial V / \\partial q$，其精确流为$\\phi_t^V$。\n\n通过组合这些精确流，可以构建一个保辛积分器。Strang分裂提供了一个二阶对称积分器：\n$$ S_2(h) = \\phi_{h/2}^V \\circ \\phi_h^T \\circ \\phi_{h/2}^V $$\n该方法是对称的（$S_2(-h) = S_2(h)^{-1}$）并且是保辛的。\n\n#### Yoshida四阶组合法\n通过组合一个二阶对称方法$S_2$的三个步骤，可以创建一个四阶方法：\n$$ S_4(h) = S_2(\\gamma_1 h) \\circ S_2(\\gamma_2 h) \\circ S_2(\\gamma_1 h) $$\n为了使该组合达到四阶精度，系数$\\gamma_i$必须满足$2\\gamma_1 + \\gamma_2 = 1$和$2\\gamma_1^3 + \\gamma_2^3 = 0$。解为：\n$$ \\gamma_1 = \\frac{1}{2 - \\sqrt[3]{2}}, \\quad \\gamma_2 = -\\frac{\\sqrt[3]{2}}{2 - \\sqrt[3]{2}} $$\n将组合$S_4(h)$用基本流$\\phi^T$和$\\phi^V$展开：\n$$ S_4(h) = [\\phi_{\\gamma_1 h/2}^V \\circ \\phi_{\\gamma_1 h}^T \\circ \\phi_{\\gamma_1 h/2}^V] \\circ [\\phi_{\\gamma_2 h/2}^V \\circ \\phi_{\\gamma_2 h}^T \\circ \\phi_{\\gamma_2 h/2}^V] \\circ [\\phi_{\\gamma_1 h/2}^V \\circ \\phi_{\\gamma_1 h}^T \\circ \\phi_{\\gamma_1 h/2}^V] $$\n通过合并相邻的$\\phi^V$步（$\\phi_{t_1}^V \\circ \\phi_{t_2}^V = \\phi_{t_1+t_2}^V$），我们得到一个交替的漂移步和踢动步序列。\n\n#### 针对开普勒问题的实现\n对于开普勒哈密顿量，我们有$T(p) = \\frac{1}{2}\\lVert p \\rVert^2$和$V(q) = -1/\\lVert q \\rVert$。精确流为：\n-   $\\phi_t^T(q,p) = (q+tp, p)$，这对应于位置的线性漂移（对$q$的“踢动”）。\n-   $\\phi_t^V(q,p) = (q, p - t(q/\\lVert q \\rVert^3))$，这对应于动量上的一个冲量（对$p$的“漂移”）。\n\n组合$S_4(h)$产生了一个7级算法，通常称为Forest-Ruth方法。设一步为$(q,p) \\to (q_{new}, p_{new})$。该算法由用于动量更新的系数$c_i$和用于位置更新的系数$d_i$定义：$p \\leftarrow p + c_i h F(q)$, $q \\leftarrow q + d_1 h M^{-1}p$, $p \\leftarrow p + c_2 h F(q)$等，其中$F(q) = -\\nabla V(q) = -q/\\lVert q \\rVert^3$。一个大小为$h$的步长的操作序列是：\n1. $p \\leftarrow p - c_1 h \\frac{q}{\\lVert q \\rVert^3}$\n2. $q \\leftarrow q + d_1 h p$\n3. $p \\leftarrow p - c_2 h \\frac{q}{\\lVert q \\rVert^3}$\n4. $q \\leftarrow q + d_2 h p$\n5. $p \\leftarrow p - c_3 h \\frac{q}{\\lVert q \\rVert^3}$\n6. $q \\leftarrow q + d_3 h p$\n7. $p \\leftarrow p - c_4 h \\frac{q}{\\lVert q \\rVert^3}$\n\n系数由$\\gamma_i$推导得出：\n- 位置更新系数：$d_1 = \\gamma_1$, $d_2 = \\gamma_2$, $d_3 = \\gamma_1$。注意$\\sum d_i = 1$。\n- 动量更新系数：$c_1 = \\gamma_1/2$, $c_2 = (\\gamma_1+\\gamma_2)/2$, $c_3 = c_2$, $c_4 = c_1$。注意$\\sum c_i = 1$。这对应于组合$\\phi_{c_1 h}^V \\circ \\phi_{d_1 h}^T \\circ \\phi_{c_2 h}^V \\circ \\phi_{d_2 h}^T \\circ \\phi_{c_3 h}^V \\circ \\phi_{d_3 h}^T \\circ \\phi_{c_4 h}^V$。此方法是显式的，易于实现，并且是构造保辛的。\n\n两种积分器都将用于模拟指定的轨道，并将计算最大绝对能量偏差$\\max_t |H(q(t), p(t)) - H(q(0), p(0))|$作为性能的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef H_kepler(y):\n    \"\"\"Computes the Hamiltonian for the Kepler problem.\"\"\"\n    q = y[:2]\n    p = y[2:]\n    r = np.linalg.norm(q)\n    return 0.5 * np.dot(p, p) - 1.0 / r\n\ndef f_kepler(y):\n    \"\"\"Computes the vector field for the Kepler problem.\"\"\"\n    q = y[:2]\n    p = y[2:]\n    r = np.linalg.norm(q)\n    f_val = np.zeros(4)\n    f_val[:2] = p\n    f_val[2:] = -q / (r**3)\n    return f_val\n\ndef Jf_kepler(y):\n    \"\"\"Computes the Jacobian of the Kepler vector field.\"\"\"\n    q = y[:2]\n    r = np.linalg.norm(q)\n    r5 = r**5\n    \n    A_qp = (3.0 / r5) * np.outer(q, q)\n    A_qp[0, 0] -= 1.0 / (r**3)\n    A_qp[1, 1] -= 1.0 / (r**3)\n    \n    Jf = np.zeros((4, 4))\n    Jf[0, 2] = 1.0\n    Jf[1, 3] = 1.0\n    Jf[2:, :2] = A_qp\n    return Jf\n\ndef gauss_step(y_n, h):\n    \"\"\"Performs one step of the 2-stage Gauss collocation method.\"\"\"\n    # Butcher tableau for 2-stage Gauss method\n    sqrt3 = np.sqrt(3.0)\n    a11 = 0.25\n    a12 = 0.25 - sqrt3 / 6.0\n    a21 = 0.25 + sqrt3 / 6.0\n    a22 = 0.25\n    \n    # Newton's method for stage equations\n    # Initial guess for stages K1, K2\n    K1 = f_kepler(y_n)\n    K2 = f_kepler(y_n)\n    \n    tol = 1e-15\n    max_iter = 10\n    \n    for _ in range(max_iter):\n        Y1 = y_n + h * (a11 * K1 + a12 * K2)\n        Y2 = y_n + h * (a21 * K1 + a22 * K2)\n        \n        G1 = K1 - f_kepler(Y1)\n        G2 = K2 - f_kepler(Y2)\n        G = np.concatenate((G1, G2))\n        \n        if np.linalg.norm(G)  tol:\n            break\n            \n        Jf1 = Jf_kepler(Y1)\n        Jf2 = Jf_kepler(Y2)\n        \n        # Assemble the 8x8 Jacobian J_G\n        I4 = np.identity(4)\n        J_G11 = I4 - h * a11 * Jf1\n        J_G12 = -h * a12 * Jf1\n        J_G21 = -h * a21 * Jf2\n        J_G22 = I4 - h * a22 * Jf2\n        J_G = np.block([[J_G11, J_G12], [J_G21, J_G22]])\n        \n        delta_Z = np.linalg.solve(J_G, -G)\n        \n        K1 += delta_Z[:4]\n        K2 += delta_Z[4:]\n\n    # Final update\n    y_n1 = y_n + h * 0.5 * (K1 + K2)\n    return y_n1\n\ndef yoshida_step(y_n, h):\n    \"\"\"Performs one step of the 4th-order Yoshida splitting method.\"\"\"\n    q = y_n[:2].copy()\n    p = y_n[2:].copy()\n\n    # Yoshida coefficients\n    gamma1 = 1.0 / (2.0 - 2.0**(1.0/3.0))\n    gamma2 = 1.0 - 2.0 * gamma1\n\n    # Coefficients for position and momentum updates\n    c1 = gamma1 / 2.0\n    c2 = (gamma1 + gamma2) / 2.0\n    c3 = c2\n    c4 = c1\n\n    d1 = gamma1\n    d2 = gamma2\n    d3 = d1\n\n    # Sequence of updates (Forest-Ruth algorithm)\n    # Step 1\n    p -= c1 * h * (q / np.linalg.norm(q)**3)\n    # Step 2\n    q += d1 * h * p\n    # Step 3\n    p -= c2 * h * (q / np.linalg.norm(q)**3)\n    # Step 4\n    q += d2 * h * p\n    # Step 5\n    p -= c3 * h * (q / np.linalg.norm(q)**3)\n    # Step 6\n    q += d3 * h * p\n    # Step 7\n    p -= c4 * h * (q / np.linalg.norm(q)**3)\n    \n    return np.concatenate((q, p))\n\ndef solve():\n    \"\"\"Main function to run simulations and produce the final output.\"\"\"\n    test_cases = [\n        {'e': 0.0, 'h': 0.05, 'N_per': 10},\n        {'e': 0.1, 'h': 0.05, 'N_per': 10},\n        {'e': 0.6, 'h': 0.02, 'N_per': 10},\n        {'e': 0.9, 'h': 0.005, 'N_per': 10},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        e = case['e']\n        h = case['h']\n        N_per = case['N_per']\n\n        # Initial conditions at periapsis\n        q0 = np.array([1.0 - e, 0.0])\n        p0 = np.array([0.0, np.sqrt((1.0 + e) / (1.0 - e))])\n        y0 = np.concatenate((q0, p0))\n        \n        H0 = H_kepler(y0)\n        \n        t_final = N_per * 2.0 * np.pi\n        n_steps = int(round(t_final / h))\n\n        # --- Gauss Collocation Method ---\n        y_gauss = y0.copy()\n        max_dev_gauss = 0.0\n        for _ in range(n_steps):\n            y_gauss = gauss_step(y_gauss, h)\n            H_n = H_kepler(y_gauss)\n            max_dev_gauss = max(max_dev_gauss, abs(H_n - H0))\n\n        # --- Yoshida Splitting Method ---\n        y_yoshida = y0.copy()\n        max_dev_yoshida = 0.0\n        for _ in range(n_steps):\n            y_yoshida = yoshida_step(y_yoshida, h)\n            H_n = H_kepler(y_yoshida)\n            max_dev_yoshida = max(max_dev_yoshida, abs(H_n - H0))\n            \n        results.append([max_dev_gauss, max_dev_yoshida])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{g:e},{s:e}]\" for g, s in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}