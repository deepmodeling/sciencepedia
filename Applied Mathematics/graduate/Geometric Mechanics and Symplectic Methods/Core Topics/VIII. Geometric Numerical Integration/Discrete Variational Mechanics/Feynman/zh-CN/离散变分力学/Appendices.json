{
    "hands_on_practices": [
        {
            "introduction": "掌握了离散拉格朗日量和离散变分原理的核心思想后，首要的实践任务是从一个给定的连续系统出发，推导出其离散运动方程。这个练习将引导你对一个经典的物理系统——单摆——进行离散化，并从第一性原理出发，推导其离散欧拉-拉格朗日方程。通过这个过程，你将把抽象的变分原理转化为一个具体的时间步进算法，这是进行任何数值模拟的基础。",
            "id": "3739701",
            "problem": "考虑一个简单的单摆，其广義坐标为 $\\theta$，质量为 $m$，长度为 $\\ell$，重力加速度为 $g$。其连续拉格朗日量为 $L(\\theta,\\dot{\\theta})=\\tfrac{1}{2} m \\ell^{2} \\dot{\\theta}^{2}-m g \\ell (1-\\cos \\theta)$。设时间步长固定为 $h>0$，并通过中点求积定义离散拉格朗日量\n$$\nL_{d}(\\theta_{k},\\theta_{k+1};h)=h\\,L\\!\\left(\\tfrac{\\theta_{k}+\\theta_{k+1}}{2},\\tfrac{\\theta_{k+1}-\\theta_{k}}{h}\\right).\n$$\n从离散哈密顿原理（由 $L_{d}$ 构建的离散作用量和的平稳性）出发，并且只使用第一性原理，推导该系统的离散欧拉-拉格朗日方程。然后，使用这些方程得到将 $\\theta$ 从 $(\\theta_{k-1},\\theta_{k})$ 对推进到 $\\theta_{k+1}$ 的单步更新关系。\n\n最后，通过将三角非线性项线性化到主导阶（关于中点值的小角度近似），得出一个关于 $(\\theta_{k-1},\\theta_{k},h,g,\\ell)$ 的 $\\theta_{k+1}$ 的显式解析表达式。所有角度均以弧度为单位。将你的最终结果表示为单个封闭形式表达式；无需数值四舍五入。",
            "solution": "此问题是有效的，因为它在科学上基于离散变分力学，是适定的、客观的，并且包含了推导出唯一解而无矛盾所需的所有必要信息。\n\n第一步是从离散哈密顿原理推导离散欧拉-拉格朗日（DEL）方程。离散作用量 $S_d$ 是离散拉格朗日量 $L_d$ 在一系列离散构型 $(\\theta_0, \\theta_1, \\ldots, \\theta_N)$ 上的和：\n$$\nS_d[\\{\\theta_k\\}_{k=0}^N] = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\n哈密顿原理要求作用量对于路径的变分 $\\delta\\theta_k$ 是平稳的，且端点固定，即 $\\delta\\theta_0 = \\delta\\theta_N = 0$。\n$$\n\\delta S_d = \\delta \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h) = \\sum_{k=0}^{N-1} \\delta L_d(\\theta_k, \\theta_{k+1}; h) = 0\n$$\n使用链式法则计算 $L_d$ 的变分：\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1} \\right) = 0\n$$\n我们将和式分开，并对第二项进行重新索引：\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1}\n$$\n让我们通过设置 $j = k+1$ 来重新索引第二个和式。该和式变为 $\\sum_{j=1}^{N} \\frac{\\partial L_d(\\theta_{j-1}, \\theta_j)}{\\partial \\theta_j} \\delta\\theta_j$。将索引重新命名为 $k$：\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=1}^{N} \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\delta\\theta_k\n$$\n我们提取 $k=0$ 和 $k=N$ 处的边界项，这些项因 $\\delta\\theta_0 = \\delta\\theta_N = 0$ 而消失。这留下了 $k=1, \\dots, N-1$ 的项：\n$$\n\\delta S_d = \\sum_{k=1}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} + \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\right) \\delta\\theta_k = 0\n$$\n由于变分 $\\delta\\theta_k$ 对于 $k \\in \\{1, \\dots, N-1\\}$ 是任意的，括号中的项必须为零。这就得到了离散欧拉-拉格朗日（DEL）方程：\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\n其中 $D_1$ 和 $D_2$ 分别表示关于 $L_d$ 的第一个和第二个参数的偏导数。\n\n接下来，我们为简单单摆构建具体的离散拉格朗日量 $L_d$。连续拉格朗日量为 $L(\\theta, \\dot{\\theta}) = \\frac{1}{2} m \\ell^2 \\dot{\\theta}^2 - mg\\ell(1-\\cos\\theta)$。使用中点求积法则 $L_d(\\theta_k, \\theta_{k+1}; h) = hL\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}, \\frac{\\theta_{k+1}-\\theta_k}{h}\\right)$：\n$$\nL_d(\\theta_k, \\theta_{k+1}) = h \\left[ \\frac{1}{2} m \\ell^2 \\left(\\frac{\\theta_{k+1}-\\theta_k}{h}\\right)^2 - mg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right) \\right]\n$$\n$$\nL_d(\\theta_k, \\theta_{k+1}) = \\frac{m\\ell^2}{2h}(\\theta_{k+1}-\\theta_k)^2 - hmg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right)\n$$\n现在我们为DEL方程计算所需的偏导数。\n对于项 $D_1 L_d(\\theta_k, \\theta_{k+1}) = \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k}$：\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_{k+1}-\\theta_k)(-1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\cdot \\frac{1}{2} \\right) = -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\n$$\n对于项 $D_2 L_d(\\theta_{k-1}, \\theta_k) = \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k}$：\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_k-\\theta_{k-1})(1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\cdot \\frac{1}{2} \\right) = \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right)\n$$\n将这些代入DEL方程 $D_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0$：\n$$\n\\left[ \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\right] + \\left[ -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\n合并同类项：\n$$\n\\frac{m\\ell^2}{h}(-\\theta_{k+1} + 2\\theta_k - \\theta_{k-1}) - \\frac{hmg\\ell}{2}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\n乘以 $-h/(m\\ell^2)$ 并重新整理，得到更新关系：\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\n问题要求使用小角度近似 $\\sin(x) \\approx x$ 来线性化这个关系。将此应用于正弦项：\n$$\n\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\approx \\frac{\\theta_{k-1}+\\theta_k}{2}\n\\quad \\text{和} \\quad\n\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\approx \\frac{\\theta_k+\\theta_{k+1}}{2}\n$$\n将这些近似值代入更新方程：\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\frac{\\theta_{k-1}+\\theta_k}{2} + \\frac{\\theta_k+\\theta_{k+1}}{2} \\right] = 0\n$$\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{4\\ell}(\\theta_{k-1} + 2\\theta_k + \\theta_{k+1}) = 0\n$$\n为了找到 $\\theta_{k+1}$ 的显式表达式，我们根据 $\\theta_{k+1}$、$\\theta_k$ 和 $\\theta_{k-1}$ 收集项：\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) + \\theta_k\\left(-2 + \\frac{2gh^2}{4\\ell}\\right) + \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = 0\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = - \\theta_k\\left(-2 + \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = \\theta_k\\left(2 - \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\n最后，我们求解 $\\theta_{k+1}$：\n$$\n\\theta_{k+1} = \\frac{\\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1}}{1 + \\frac{gh^2}{4\\ell}}\n$$\n为了简化这个表达式并消除嵌套分数，我们将分子和分母同乘以 $4\\ell$：\n$$\n\\theta_{k+1} = \\frac{4\\ell \\left[ \\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1} \\right]}{4\\ell \\left(1 + \\frac{gh^2}{4\\ell}\\right)} = \\frac{(8\\ell - 2gh^2)\\theta_k - (4\\ell + gh^2)\\theta_{k-1}}{4\\ell + gh^2}\n$$\n这就是 $\\theta_{k+1}$ 的最终封闭形式表达式。",
            "answer": "$$\n\\boxed{\\frac{(8\\ell - 2gh^{2})\\theta_{k} - (4\\ell + gh^{2})\\theta_{k-1}}{4\\ell + gh^{2}}}\n$$"
        },
        {
            "introduction": "变分积分方法的核心优势在于其能够精确保持系统的几何结构，特别是辛结构。虽然我们从理论上证明了这一点，但通过数值实验来亲手验证这一性质，能够极大地加深理解。这个练习要求你编写程序，通过计算不同积分方法（包括变分积分器和非变分积分器）的雅可比矩阵，来检验它们是否满足辛条件 $J(z)^{\\top} S J(z) = S$。这个实践不仅能让你具体地“看到”辛结构的保持，还能让你直观地对比不同数值方法的长期行为差异。",
            "id": "3739657",
            "problem": "考虑一个力学系统，其构型变量为 $q \\in \\mathbb{R}^{n}$，动量为 $p \\in \\mathbb{R}^{n}$，质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 为对称正定矩阵，刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 为对称半正定矩阵。其连续时间拉格朗日量为 $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$，这对应于一个线性谐振子。在离散变分力学中，我们构造一个离散拉格朗日量 $L_{d}(q_{k}, q_{k+1}; h)$，它在大小为 $h > 0$ 的时间步长上近似拉格朗日量沿短轨迹段的作用量积分，并应用离散的欧拉-拉格朗日方程，以获得从离散状态 $z_{k} = (q_{k}, p_{k})$ 到 $z_{k+1} = (q_{k+1}, p_{k+1})$ 的更新映射。对于余切丛上的这类变分积分器，其诱导的离散辛二形式与正则辛二形式一致。\n\n令 $z = (q, p) \\in \\mathbb{R}^{2n}$ 表示当前状态，并令 $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$ 表示由给定时间离散化产生的单步更新映射。正则辛矩阵为\n$$\nS = \\begin{bmatrix}\n0  I_{n} \\\\\n-I_{n}  0\n\\end{bmatrix} \\in \\mathbb{R}^{2n \\times 2n},\n$$\n其中 $I_{n}$ 是 $n \\times n$ 单位矩阵。一个可微映射 $\\Phi_{h}$ 对于正则二形式是辛的，当且仅当其雅可比矩阵 $J(z) = D\\Phi_{h}(z)$ 满足\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\n对于定义域中的所有 $z$。\n\n你的任务是设计一个程序，通过有限差分计算更新映射的雅可比矩阵，来数值验证辛性，并检查对于应用于谐振子的几种离散时间积分器，离散辛形式是否被保持。使用以下积分器：\n- 位置 Verlet（也称为 Störmer–Verlet）变分积分器。\n- 辛欧拉方法（半隐式 A 型：先更新动量，再更新位置）。\n- 显式欧拉方法（完全显式；通常不是辛方法）。\n- 隐式中点法（一种辛 Runge–Kutta 方法）。\n\n验证必须按以下步骤进行：\n1. 为每个积分器实现映射 $z = (q,p)$ 到 $z^{+} = (q^{+}, p^{+})$ 的函数 $\\Phi_{h}$，使用一致的单位，其中 $q$ 的单位是米， $p$ 的单位是千克·米/秒， $M$ 的单位是千克， $K$ 的单位是牛顿/米， $h$ 的单位是秒。不涉及角量。\n2. 在指定状态 $z$ 周围，使用中心有限差分和一个小的扰动 $\\varepsilon > 0$ 来数值计算雅可比矩阵 $J(z)$：\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon},\n$$\n其中 $e_{i}$ 是 $\\mathbb{R}^{2n}$ 中的第 $i$ 个标准基向量，$J_{:,i}$ 表示 $J$ 的第 $i$ 列。\n3. 评估辛性残差\n$$\nE(z) = J(z)^{\\top} S \\, J(z) - S\n$$\n及其 Frobenius 范数 $\\lVert E(z) \\rVert_{F}$，它是一个非负实数。一个很小的值表示辛形式得以保持。通过检查 $\\lVert E(z) \\rVert_{F} \\leq \\tau$（其中 $\\tau$ 为容差）将其转换为布尔决策。\n\n设计程序以运行以下测试套件，其中 $n$ 是自由度数，$M = \\operatorname{diag}(m_{1}, \\dots, m_{n})$ 且质量 $m_{i} > 0$，$K = \\operatorname{diag}(k_{1}, \\dots, k_{n})$ 且刚度 $k_{i} \\geq 0$，$z$ 是计算雅可比矩阵所围绕的状态。指定 $h$ 的单位为秒，$m_{i}$ 的单位为千克，$k_{i}$ 的单位为牛顿/米：\n- 测试 1 (正常情况，辛方法): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (q, p) = (0.3, -0.7)$。\n- 测试 2 (非辛方法参考): 显式 Euler, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$。\n- 测试 3 (一阶辛方法): 辛 Euler, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$。\n- 测试 4 (多维，辛方法): 隐式中点法, $n = 2$, $m = (1.0, 2.0)$, $k = (3.0, 5.0)$, $h = 0.05$, $z = (q_{1}, q_{2}, p_{1}, p_{2}) = (0.1, -0.2, 0.3, -0.4)$。\n- 测试 5 (接近稳定性边界的大步长，辛积分器): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 1.0$, $h = 1.9$, $z = (0.2, 0.1)$。\n- 测试 6 (边缘情况：零刚度自由粒子，辛积分器): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 0.0$, $h = 0.5$, $z = (1.0, -0.5)$。\n\n使用有限差分步长 $\\varepsilon = 10^{-8}$ 和决策容差 $\\tau = 10^{-10}$。对于每个测试，计算辛性条件是否在容差范围内成立的布尔决策。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5,result6]\"）。每个元素应为字面值 \"True\" 或 \"False\"，对应于相应测试的布尔决策。",
            "solution": "该问题要求对应用于线性谐振子的几种标准时间步进格式的辛性进行数值验证。该问题是有效的，在经典力学和几何数值积分方面有科学依据，并且信息完备、定义明确，可以得到唯一的、可验证的解。\n\n该力学系统由构型 $q \\in \\mathbb{R}^{n}$ 和动量 $p \\in \\mathbb{R}^{n}$ 描述。其连续时间动力学由拉格朗日量 $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$ 控制，其中 $M$ 是对称正定质量矩阵，$K$ 是对称半正定刚度矩阵。相应的哈密顿量为 $H(q,p) = \\frac{1}{2} p^{\\top} M^{-1} p + \\frac{1}{2} q^{\\top} K q$。哈密顿形式的运动方程为：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = M^{-1} p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -K q\n$$\n数值积分器定义了一个单步更新映射 $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$，它在一个时间步长 $h > 0$ 上近似了系统的流。该映射将时间 $t_k$ 的状态 $z_k = (q_k, p_k)$ 映射到时间 $t_{k+1} = t_k + h$ 的状态 $z_{k+1} = (q_{k+1}, p_{k+1})$。如果映射 $\\Phi_h$ 保持了正则辛二形式，则称其为辛映射。这等价于其雅可比矩阵 $J(z) = D\\Phi_{h}(z)$ 满足以下条件：\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\n对于定义域中的所有状态 $z$，其中 $S$ 是正则辛矩阵 $S = \\begin{bmatrix} 0  I_{n} \\\\ -I_{n}  0 \\end{bmatrix}$。\n\n我们将为四种不同的积分器实现更新映射，然后数值验证此属性。设 $q_k, p_k$ 为一步开始时的状态，$q_{k+1}, p_{k+1}$ 为结束时的状态。\n\n1.  **位置 Verlet (Störmer–Verlet) 积分器**：这是一个二阶、对称且辛的积分器。其更新规则由一个三阶段过程给出：\n    $$\n    p_{k+1/2} = p_k - \\frac{h}{2} K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1/2}\n    $$\n    $$\n    p_{k+1} = p_{k+1/2} - \\frac{h}{2} K q_{k+1}\n    $$\n\n2.  **辛 Euler (A 型) 积分器**：一个一阶、非对称但辛的积分器。“A 型”的名称意味着首先使用旧位置更新动量，然后使用新动量更新位置。\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1}\n    $$\n\n3.  **显式 Euler 积分器**：这是最简单的一阶积分器。它通常不是辛的。两个新的状态变量都仅使用旧的状态变量来计算。\n    $$\n    q_{k+1} = q_k + h M^{-1} p_k\n    $$\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    注意，与辛欧拉方法不同，$q$ 和 $p$ 的更新顺序是独立的。\n\n4.  **隐式中点法**：一种二阶、对称且辛的隐式 Runge-Kutta 方法。它通过在时间和状态的中点处评估向量场来定义。\n    $$\n    q_{k+1} = q_k + h M^{-1} \\left( \\frac{p_k + p_{k+1}}{2} \\right)\n    $$\n    $$\n    p_{k+1} = p_k - h K \\left( \\frac{q_k + q_{k+1}}{2} \\right)\n    $$\n    这构成了关于 $(q_{k+1}, p_{k+1})$ 的一个线性方程组。通过代换和重新整理，我们可以推导出一个显式过程。首先，求解 $q_{k+1}$：\n    $$\n    \\left( I + \\frac{h^2}{4} M^{-1} K \\right) q_{k+1} = \\left( I - \\frac{h^2}{4} M^{-1} K \\right) q_k + h M^{-1} p_k\n    $$\n    然后，直接计算 $p_{k+1}$：\n    $$\n    p_{k+1} = p_k - \\frac{h}{2} K(q_k + q_{k+1})\n    $$\n\n数值验证过程如下：\n首先，对于每个积分器，我们定义从 $z_k = (q_k, p_k)$ 计算 $z_{k+1} = (q_{k+1}, p_{k+1})$ 的映射 $\\Phi_h$。其次，我们使用中心有限差分公式对其 $2n$ 个列中的每一列，在给定状态 $z$ 处数值近似雅可比矩阵 $J(z)$：\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon}\n$$\n其中 $e_i$ 是第 $i$ 个标准基向量，$\\varepsilon$ 是一个小的扰动，给定为 $\\varepsilon = 10^{-8}$。第三，我们计算辛性残差矩阵 $E(z) = J(z)^{\\top} S J(z) - S$。最后，我们评估其 Frobenius 范数 $\\lVert E(z) \\rVert_{F}$，并检查它是否低于指定的容差 $\\tau = 10^{-10}$。低于此容差的范数表明，在数值测试的精度范围内，该积分器保持了辛结构。程序将对问题陈述中指定的每个测试用例执行此过程。",
            "answer": "```python\nimport numpy as np\n\ndef verlet_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Position Verlet integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_half = p - (h / 2.0) * (K @ q)\n    q_new = q + h * (M_inv @ p_half)\n    p_new = p_half - (h / 2.0) * (K @ q_new)\n    return np.concatenate((q_new, p_new))\n\ndef symplectic_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Symplectic Euler (Type A) integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_new = p - h * (K @ q)\n    q_new = q + h * (M_inv @ p_new)\n    return np.concatenate((q_new, p_new))\n\ndef explicit_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Explicit Euler integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    q_new = q + h * (M_inv @ p)\n    p_new = p - h * (K @ q)\n    return np.concatenate((q_new, p_new))\n\ndef implicit_midpoint_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Implicit Midpoint integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    I_n = np.identity(n)\n    \n    # Solve for q_new from the linear system:\n    # (I + (h^2/4) * M_inv @ K) @ q_new = (I - (h^2/4) * M_inv @ K) @ q + h * M_inv @ p\n    A = I_n + (h**2 / 4.0) * (M_inv @ K)\n    rhs = (I_n - (h**2 / 4.0) * (M_inv @ K)) @ q + h * (M_inv @ p)\n    q_new = np.linalg.solve(A, rhs)\n    \n    # Compute p_new explicitly using the found q_new\n    p_new = p - (h / 2.0) * (K @ (q + q_new))\n    return np.concatenate((q_new, p_new))\n\ndef compute_jacobian(phi, z, h, M_inv, K, n, eps):\n    \"\"\"\n    Computes the Jacobian of the integrator map phi using central finite differences.\n    \"\"\"\n    dim = 2 * n\n    J = np.zeros((dim, dim))\n    for i in range(dim):\n        e_i = np.zeros(dim)\n        e_i[i] = 1.0\n        z_plus = phi(z + eps * e_i, h, M_inv, K, n)\n        z_minus = phi(z - eps * e_i, h, M_inv, K, n)\n        J[:, i] = (z_plus - z_minus) / (2.0 * eps)\n    return J\n\ndef check_symplecticity(J, n, tau):\n    \"\"\"\n    Checks if the Jacobian J satisfies the symplecticity condition.\n    \"\"\"\n    dim = 2 * n\n    I_n = np.identity(n)\n    S = np.block([\n        [np.zeros((n, n)), I_n],\n        [-I_n, np.zeros((n, n))]\n    ])\n    \n    residual = J.T @ S @ J - S\n    norm = np.linalg.norm(residual, 'fro')\n    \n    return norm = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify symplecticity.\n    \"\"\"\n    \n    test_cases = [\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Explicit Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Symplectic Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Implicit Midpoint', 'n': 2, 'm': np.array([1.0, 2.0]), 'k': np.array([3.0, 5.0]), 'h': 0.05, 'z': np.array([0.1, -0.2, 0.3, -0.4])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([1.0]), 'h': 1.9, 'z': np.array([0.2, 0.1])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([0.0]), 'h': 0.5, 'z': np.array([1.0, -0.5])},\n    ]\n\n    integrators = {\n        'Verlet': verlet_step,\n        'Symplectic Euler': symplectic_euler_step,\n        'Explicit Euler': explicit_euler_step,\n        'Implicit Midpoint': implicit_midpoint_step,\n    }\n    \n    eps = 1e-8\n    tau = 1e-10\n    \n    results = []\n    \n    for case in test_cases:\n        n = case['n']\n        h = case['h']\n        z = case['z']\n        \n        M = np.diag(case['m'])\n        K = np.diag(case['k'])\n        # Handle division by zero for mass if it occurs, though not in test cases.\n        m_inv_diag = np.zeros_like(case['m'], dtype=float)\n        non_zero_m = case['m'] != 0\n        m_inv_diag[non_zero_m] = 1.0 / case['m'][non_zero_m]\n        M_inv = np.diag(m_inv_diag)\n\n        phi = integrators[case['name']]\n        \n        J = compute_jacobian(phi, z, h, M_inv, K, n, eps)\n        is_symplectic = check_symplecticity(J, n, tau)\n        \n        results.append(str(is_symplectic))\n        \n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "理论上的完美性质在实际计算中会遇到有限精度算法的挑战。即使一个积分器在数学上是完美的辛方法，计算机的舍入误差会如何影响其长期保结构特性？这个练习将挑战你对这些实际问题的深刻理解，引导你分析舍入误差对辛性和动量守恒的影响。通过辨析一系列关于后向误差分析、误差累积行为以及误差控制技术的论述，你将建立起在有限精度环境下对几何积分器鲁棒性的批判性认识，这是从理论走向实际应用的关键一步。",
            "id": "3739694",
            "problem": "考虑一个定义在位形流形 $Q$ 上的离散变分积分器，其由离散拉格朗日量 $L_d(q_k,q_{k+1};h)$ 和时间步长 $h0$ 定义。离散 Euler–Lagrange (DEL) 方程为\n$$\nD_2 L_d(q_{k-1},q_k;h) + D_1 L_d(q_k,q_{k+1};h) = 0,\n$$\n该方程隐式地定义了一个单步映射 $\\Phi_h:(q_{k-1},q_k)\\mapsto(q_k,q_{k+1})$。$Q\\times Q$ 上相关的离散 Poincaré–Cartan 二维形式 $\\Omega_d$ 是一个离散 Poincaré–Cartan 一维形式的外微分，而精确变分更新 $\\Phi_h$ 是辛的，因为它在拉回作用下保持 $\\Omega_d$ 不变。如果 $L_d$ 在作用于 $Q$ 的李群 $G$ 下不变，那么根据离散版本的 Noether 定理，一个离散动量映射 $J_d(q_{k-1},q_k)\\in\\mathfrak{g}^\\ast$ 会沿着 DEL 方程的解精确保守，其中 $\\mathfrak{g}$ 是 $G$ 的李代数。\n\n现在假设 DEL 方程在一台浮点机上求解，其机器精度为 $\\epsilon_{\\mathrm{mach}}0$，并且线性与非线性代数求解在数值线性代数的标准意义下是后向稳定的。将实现的映射记为 $\\widetilde{\\Phi}_h$，它因舍入误差而与 $\\Phi_h$ 不同。你可以将基本浮点运算 $\\mathrm{fl}(a\\ \\mathrm{op}\\ b)$ 建模为 $(a\\ \\mathrm{op}\\ b)(1+\\delta)$，其中 $|\\delta|\\le c\\,\\epsilon_{\\mathrm{mach}}$，$c$ 是一个与条件数相关的常数。\n\n关于舍入误差对辛性和动量守恒的影响，以及在有限精度下保持结构的技术，以下哪些陈述是正确的？\n\nA. 因为 $\\Phi_h$ 是由离散变分原理定义的，任何浮点实现 $\\widetilde{\\Phi}_h$ 对于同一个离散二维形式 $\\Omega_d$ 都是精确辛的，因此不会因舍入误差而导致长期行为的退化。\n\nB. 在温和的正则性假设和求解的后向稳定性下，第 $k$ 步计算出的更新可以被解释为某个微扰离散拉格朗日量 $L_d^{(k)}=L_d+\\delta L_d^{(k)}$（其中 $\\|\\delta L_d^{(k)}\\|=\\mathcal{O}(\\epsilon_{\\mathrm{mach}})$）的精确 DEL 更新；因此，每一步的单步映射对于一个依赖于步长的二维形式 $\\Omega_d^{(k)}$ 是辛的，但多步复合后只是近辛的。如果 $L_d$ 是 $G$ 不变的，离散动量 $J_d$ 在有限精度下将不再精确保守，并且在舍入误差的标准独立性和无偏性理想化假设下，其误差在 $N$ 步后表现为大小为 $\\mathcal{O}(\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}})$ 的随机游走。\n\nC. 在每步之后，通过在约束 $J_d(q_{k-1},q_k)=\\mu$（对于给定的 $\\mu\\in\\mathfrak{g}^\\ast$）下最小化位形空间中一个修正量的欧几里得范数来进行投影，总能得到一个精确保持离散二维形式 $\\Omega_d$ 的辛方法。\n\nD. 一种控制动量漂移的保结构方法是，使用一个拉格朗日乘子来强制施加约束 $J_d(q_{k-1},q_k)=\\mu$，从而增广离散变分原理，并求解得到的约束 DEL 方程（这是诸如 SHAKE/RATTLE (Reduced And Truncated Time-step Leapfrog) 等约束算法的一种离散模拟）；所得到的映射在约束流形上是辛的，并在求解器容差和舍入误差范围内保持动量水平集。\n\nE. 使用时间对称（自伴）的离散拉格朗日量以获得对称变分积分器，并结合算术的对称实现以及在力或梯度累加中使用补偿求和，可以减少舍入带来的系统性偏差。在有限精度和无偏舍入的情况下，这通常能防止不变量出现随时间线性漂移，而是导致误差表现为鞅，其方差与步数成正比；补偿求和会减小方差常数，但不能改变 $\\mathcal{O}(\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}})$ 的标度律。\n\n选择所有适用的选项。",
            "solution": "问题陈述是对离散变分积分器在有限精度运算下行为的有效探究。它在几何数值积分和数值分析领域具有科学依据，是适定的，并使用了精确、客观的术语。所有概念——例如离散拉格朗日量 $L_d$、离散 Euler-Lagrange (DEL) 方程、通过离散 Poincaré–Cartan 二维形式 $\\Omega_d$ 实现的辛性，以及产生动量映射 $J_d$ 的离散 Noether 定理——都是标准的且陈述正确。引入浮点误差模型也是分析数值算法的标准方法。因此，该问题适合进行严谨的科学分析。\n\n我们现在将评估给出的每个陈述。\n\n**对 A 的分析：**\n该陈述声称“任何浮点实现 $\\widetilde{\\Phi}_h$ 对于同一个离散二维形式 $\\Omega_d$ 都是精确辛的”。这根本上是错误的。变分积分器的辛性证明依赖于离散 Euler-Lagrange (DEL) 方程的精确满足：\n$$\nD_2 L_d(q_{k-1},q_k;h) + D_1 L_d(q_k,q_{k+1};h) = 0.\n$$\n浮点实现涉及计算函数 $D_1 L_d$ 和 $D_2 L_d$ 并使用有限精度算术求解得到的（通常是非线性的）关于 $q_{k+1}$ 的代数方程。设数值计算出的序列为 $\\{\\tilde{q}_k\\}$。由于每次算术运算中的舍入误差，计算出的值 $(\\tilde{q}_{k-1}, \\tilde{q}_k, \\tilde{q}_{k+1})$ 不会精确满足 DEL 方程。相反，它们满足一个微扰方程：\n$$\nD_2 L_d(\\tilde{q}_{k-1},\\tilde{q}_k;h) + D_1 L_d(\\tilde{q}_k,\\tilde{q}_{k+1};h) = \\tau_k,\n$$\n其中 $\\tau_k$ 是一个量级为 $\\mathcal{O}(\\epsilon_{\\mathrm{mach}})$ 的残差项。由于 DEL 方程没有被精确满足，辛性的推导就失败了。实现的映射 $\\widetilde{\\Phi}_h$ 并不保持原始的离散二维形式 $\\Omega_d$。因此，“不会因舍入误差而导致长期行为的退化”这一说法也是错误的。舍入误差是长时间模拟中误差增长的主要来源，尽管对于辛方法，其对类能量量的影响是有界的，这与非辛方法中看到的线性漂移形成对比。\n\n对 A 的结论：**错误**。\n\n**对 B 的分析：**\n该陈述将后向误差分析的概念应用于变分积分器。后向误差分析的核心思想是，虽然数值方法不能精确求解原始问题，但它可能精确求解一个轻微扰动的问题。对于变分积分器，如果 DEL 方程的数值求解器是后向稳定的，那么从初始值 $\\tilde{q}_{k-1}$ 计算出的步 $(\\tilde{q}_k, \\tilde{q}_{k+1})$ 可以被证明是对应于一个微扰离散拉格朗日量 $L_d^{(k)} = L_d + \\delta L_d^{(k)}$ 的微扰 DEL 方程的精确解。扰动 $\\delta L_d^{(k)}$ 是非结构化的，其大小在机器精度量级，即 $\\|\\delta L_d^{(k)}\\| = \\mathcal{O}(\\epsilon_{\\mathrm{mach}})$。\n由于计算出的步是拉格朗日量 $L_d^{(k)}$ 的精确演化，因此它是精确辛的，但这是相对于相应的微扰二维形式 $\\Omega_d^{(k)} = -d\\Theta_d^{(k)}$ 而言，其中 $\\Theta_d^{(k)}$ 是与 $L_d^{(k)}$ 相关的离散 Poincaré-Cartan 一维形式。由于舍入误差的随机性，扰动 $\\delta L_d^{(k)}$（以及 $\\Omega_d^{(k)}$）在每一步都不同，因此多步的复合不保持任何单一的辛形式。然而，它是“近辛的”，因为每个 $\\Omega_d^{(k)}$ 都接近于 $\\Omega_d$。\n对于动量守恒，如果原始的 $L_d$ 是 $G$ 不变的，那么微扰的拉格朗日量 $L_d^{(k)}$ 通常将不再是 $G$ 不变的，因为浮点误差破坏了对称性。这意味着相关的动量映射 $J_d$ 不再守恒。每步动量的变化量级为 $\\mathcal{O}(\\epsilon_{\\mathrm{mach}})$。将每步的舍入误差理想化为独立的、零均值的随机变量，那么 $N$ 步后动量的总误差会按照随机游走的方式累积。因此，误差的标准差以 $\\mathcal{O}(\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}})$ 的速度增长。这整个描述是现代理解几何积分器在有限精度下长期行为的基石。\n\n对 B 的结论：**正确**。\n\n**对 C 的分析：**\n该陈述描述了一种投影方法。其过程是：1. 用积分器 $\\widetilde{\\Phi}_h$ 走一步，得到一个漂离了动量水平集的状态 $(\\tilde{q}_k, \\tilde{q}_{k+1})$；2. 通过寻找一个最小修正，将此状态投影回约束流形 $J_d^{-1}(\\mu)$。虽然这种投影方法用于施加约束，但投影步本身通常不是一个关于 $\\Omega_d$ 的辛映射。一个近辛映射（积分器步）与一个非辛映射（投影）的复合会得到一个非辛的总体映射。因此，尽管这个过程从构造上保证了动量守恒，但它牺牲了底层积分器的辛性。声称所得到的方法“精确保持离散二维形式 $\\Omega_d$”是错误的。\n\n对 C 的结论：**错误**。\n\n**对 D 的分析：**\n该陈述建议在变分原理内部将动量守恒定律作为约束来施加。这是通过使用一个拉格朗日乘子 $\\lambda_k$（在李代数的对偶空间中）创建一个增广离散拉格朗日量来实现的：\n$$\nL_{d, \\text{aug}}(q_k, q_{k+1}, \\lambda_k) = L_d(q_k, q_{k+1}) + \\langle \\lambda_k, J_d(q_k, q_{k+1}) - \\mu \\rangle.\n$$\n寻找作用量和 $\\sum_k L_{d, \\text{aug}}$ 关于 $q_k$ 和 $\\lambda_k$ 变分的驻点，会得到一组约束 DEL 方程。得到的积分器是像 RATTLE 这样的连续约束算法的离散模拟。这是一种保结构的方法。这样一个约束变分系统的流是辛的，但不是在原始空间 $Q \\times Q$上，而是在由 $J_d(q_{k-1}, q_k) = \\mu$ 定义的约束流形上。这是辛约化理论的一个结果。在有限精度实现中，动量约束将在非线性求解器的容差和计算约束函数时的舍入误差范围内得到满足，这比无约束方法的 $\\mathcal{O}(\\sqrt{N})$ 漂移行为要稳定得多。该陈述准确地描述了这种方法及其性质。\n\n对 D 的结论：**正确**。\n\n**对 E 的分析：**\n该陈述深入探讨了误差传播与减缓的细节。一个时间对称（或自伴）的离散拉格朗日量，例如 $L_d(q_k, q_{k+1}) = L_d(q_{k+1}, q_k)$，会产生一个对称变分积分器。对称积分器具有优越的长期行为，其中一个关键方面是它们如何处理舍入误差。如果一个对称方法的实现本身也是对称的（例如，仔细处理运算顺序），并且舍入是无偏的（如 IEEE-754 标准的“舍入到最近的偶数”），那么可以避免舍入中的系统性偏差。在这种情况下，守恒量的误差不再表现出随时间的线性漂移，而是表现为鞅，其方差通常随步数 $N$ 线性增长。因此，误差的大小（标准差）以 $\\mathcal{O}(\\sqrt{N})$ 的速度增长。\n补偿求和（例如 Kahan 求和）是一种计算和 $\\sum_i x_i$ 的技术，其精度远高于朴素求和。当用于累加力或梯度（它们是粒子或元素上的求和）时，它能减少每一步产生的舍入误差的量级。在误差的随机游走模型中，这会减小每步随机增量的方差。这导致误差增长定律 $C\\sqrt{N}\\,\\epsilon_{\\mathrm{mach}}$ 中的常数 $C$ 变小。然而，它并不能改变基本的 $\\sqrt{N}$ 标度律，该标度律源于许多小的、近似独立的误差的累积。该陈述正确地捕捉了这种微妙的行为。\n\n对 E 的结论：**正确**。",
            "answer": "$$\\boxed{BDE}$$"
        }
    ]
}