{
    "hands_on_practices": [
        {
            "introduction": "掌握离散变分力学的核心在于亲手实践其基本原理。这项练习将指导你从一个经典的物理系统——单摆——的连续拉格朗日量出发，通过中点求积法则构造离散拉格朗日量，并从第一性原理推导出离散欧拉-拉格朗日方程。这个过程不仅能让你熟悉离散化的基本流程，还能锻炼你将连续理论转化为可计算的离散映射的能力()。",
            "id": "3739701",
            "problem": "考虑一个单摆，其广义坐标为 $\\theta$，质量为 $m$，长度为 $\\ell$，重力加速度为 $g$。其连续拉格朗日量为 $L(\\theta,\\dot{\\theta})=\\tfrac{1}{2} m \\ell^{2} \\dot{\\theta}^{2}-m g \\ell (1-\\cos \\theta)$。设时间步长固定为 $h>0$，并通过中点求积定义离散拉格朗日量\n$$\nL_{d}(\\theta_{k},\\theta_{k+1};h)=h\\,L\\!\\left(\\tfrac{\\theta_{k}+\\theta_{k+1}}{2},\\tfrac{\\theta_{k+1}-\\theta_{k}}{h}\\right).\n$$\n从离散哈密顿原理（由 $L_{d}$ 构成的离散作用量和的平稳性）出发，并且只使用第一性原理，推导该系统的离散欧拉-拉格朗日方程。然后，使用这些方程得到将 $\\theta$ 从 $(\\theta_{k-1},\\theta_{k})$ 对推进到 $\\theta_{k+1}$ 的单步更新关系。\n\n最后，通过对三角非线性进行主阶线性化（关于中点值的小角度近似），得出一个关于 $(\\theta_{k-1},\\theta_{k},h,g,\\ell)$ 的 $\\theta_{k+1}$ 的显式解析表达式。所有角度均以弧度为单位。将最终结果表示为单个封闭形式的表达式；不需要进行数值舍入。",
            "solution": "该问题是有效的，因为它在科学上基于离散变分力学，是适定的、客观的，并且包含了推导出唯一解而无矛盾所需的所有信息。\n\n第一步是从离散哈密顿原理推导离散欧拉-拉格朗日（DEL）方程。离散作用量 $S_d$ 是离散拉格朗日量 $L_d$ 在一系列离散位形 $(\\theta_0, \\theta_1, \\ldots, \\theta_N)$ 上的和：\n$$\nS_d[\\{\\theta_k\\}_{k=0}^N] = \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h)\n$$\n哈密顿原理要求作用量对于路径的变分 $\\delta\\theta_k$ 是平稳的，且端点固定，即 $\\delta\\theta_0 = \\delta\\theta_N = 0$。\n$$\n\\delta S_d = \\delta \\sum_{k=0}^{N-1} L_d(\\theta_k, \\theta_{k+1}; h) = \\sum_{k=0}^{N-1} \\delta L_d(\\theta_k, \\theta_{k+1}; h) = 0\n$$\n对 $L_d$ 的变分使用链式法则：\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1} \\right) = 0\n$$\n我们将和式分开，并对第二项进行重新索引：\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_{k+1}} \\delta\\theta_{k+1}\n$$\n我们通过令 $j = k+1$ 来重新索引第二个和式。该和式变为 $\\sum_{j=1}^{N} \\frac{\\partial L_d(\\theta_{j-1}, \\theta_j)}{\\partial \\theta_j} \\delta\\theta_j$。将索引重新命名为 $k$：\n$$\n\\delta S_d = \\sum_{k=0}^{N-1} \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} \\delta\\theta_k + \\sum_{k=1}^{N} \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\delta\\theta_k\n$$\n我们提取 $k=0$ 和 $k=N$ 处的边界项，由于 $\\delta\\theta_0 = \\delta\\theta_N = 0$，这些项为零。剩下的是 $k=1, \\dots, N-1$ 的项：\n$$\n\\delta S_d = \\sum_{k=1}^{N-1} \\left( \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k} + \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k} \\right) \\delta\\theta_k = 0\n$$\n由于变分 $\\delta\\theta_k$ 对于 $k \\in \\{1, \\dots, N-1\\}$ 是任意的，因此括号中的项必须为零。这就得出了离散欧拉-拉格朗日（DEL）方程：\n$$\nD_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0\n$$\n其中 $D_1$ 和 $D_2$ 分别表示对 $L_d$ 的第一个和第二个自变量的偏导数。\n\n接下来，我们为单摆构建具体的离散拉格朗日量 $L_d$。连续拉格朗日量为 $L(\\theta, \\dot{\\theta}) = \\frac{1}{2} m \\ell^2 \\dot{\\theta}^2 - mg\\ell(1-\\cos\\theta)$。使用中点求积法则 $L_d(\\theta_k, \\theta_{k+1}; h) = hL\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}, \\frac{\\theta_{k+1}-\\theta_k}{h}\\right)$：\n$$\nL_d(\\theta_k, \\theta_{k+1}) = h \\left[ \\frac{1}{2} m \\ell^2 \\left(\\frac{\\theta_{k+1}-\\theta_k}{h}\\right)^2 - mg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right) \\right]\n$$\n$$\nL_d(\\theta_k, \\theta_{k+1}) = \\frac{m\\ell^2}{2h}(\\theta_{k+1}-\\theta_k)^2 - hmg\\ell\\left(1-\\cos\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\\right)\n$$\n现在我们为 DEL 方程计算所需的偏导数。\n对于项 $D_1 L_d(\\theta_k, \\theta_{k+1}) = \\frac{\\partial L_d(\\theta_k, \\theta_{k+1})}{\\partial \\theta_k}$：\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_{k+1}-\\theta_k)(-1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\cdot \\frac{1}{2} \\right) = -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right)\n$$\n对于项 $D_2 L_d(\\theta_{k-1}, \\theta_k) = \\frac{\\partial L_d(\\theta_{k-1}, \\theta_k)}{\\partial \\theta_k}$：\n$$\n\\frac{\\partial L_d}{\\partial \\theta_k} = \\frac{m\\ell^2}{2h} \\cdot 2(\\theta_k-\\theta_{k-1})(1) - hmg\\ell \\left( \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\cdot \\frac{1}{2} \\right) = \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right)\n$$\n将这些代入 DEL 方程 $D_2 L_d(\\theta_{k-1}, \\theta_k) + D_1 L_d(\\theta_k, \\theta_{k+1}) = 0$：\n$$\n\\left[ \\frac{m\\ell^2}{h}(\\theta_k-\\theta_{k-1}) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\right] + \\left[ -\\frac{m\\ell^2}{h}(\\theta_{k+1}-\\theta_k) - \\frac{hmg\\ell}{2}\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\n合并同类项：\n$$\n\\frac{m\\ell^2}{h}(-\\theta_{k+1} + 2\\theta_k - \\theta_{k-1}) - \\frac{hmg\\ell}{2}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\n乘以 $-h/(m\\ell^2)$ 并重新整理，得到更新关系：\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) + \\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\right] = 0\n$$\n问题要求使用小角度近似 $\\sin(x) \\approx x$ 对此关系进行线性化。将此应用于正弦项：\n$$\n\\sin\\left(\\frac{\\theta_{k-1}+\\theta_k}{2}\\right) \\approx \\frac{\\theta_{k-1}+\\theta_k}{2}\n\\quad \\text{和} \\quad\n\\sin\\left(\\frac{\\theta_k+\\theta_{k+1}}{2}\\right) \\approx \\frac{\\theta_k+\\theta_{k+1}}{2}\n$$\n将这些近似值代入更新方程：\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{2\\ell}\\left[ \\frac{\\theta_{k-1}+\\theta_k}{2} + \\frac{\\theta_k+\\theta_{k+1}}{2} \\right] = 0\n$$\n$$\n(\\theta_{k+1} - 2\\theta_k + \\theta_{k-1}) + \\frac{gh^2}{4\\ell}(\\theta_{k-1} + 2\\theta_k + \\theta_{k+1}) = 0\n$$\n为了找到 $\\theta_{k+1}$ 的显式表达式，我们根据 $\\theta_{k+1}$、$\\theta_k$ 和 $\\theta_{k-1}$ 收集项：\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) + \\theta_k\\left(-2 + \\frac{2gh^2}{4\\ell}\\right) + \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = 0\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = - \\theta_k\\left(-2 + \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\n$$\n\\theta_{k+1}\\left(1 + \\frac{gh^2}{4\\ell}\\right) = \\theta_k\\left(2 - \\frac{gh^2}{2\\ell}\\right) - \\theta_{k-1}\\left(1 + \\frac{gh^2}{4\\ell}\\right)\n$$\n最后，我们解出 $\\theta_{k+1}$：\n$$\n\\theta_{k+1} = \\frac{\\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1}}{1 + \\frac{gh^2}{4\\ell}}\n$$\n为了简化此表达式并消除嵌套分数，我们将分子和分母同乘以 $4\\ell$：\n$$\n\\theta_{k+1} = \\frac{4\\ell \\left[ \\left(2 - \\frac{gh^2}{2\\ell}\\right)\\theta_k - \\left(1 + \\frac{gh^2}{4\\ell}\\right)\\theta_{k-1} \\right]}{4\\ell \\left(1 + \\frac{gh^2}{4\\ell}\\right)} = \\frac{(8\\ell - 2gh^2)\\theta_k - (4\\ell + gh^2)\\theta_{k-1}}{4\\ell + gh^2}\n$$\n这就是 $\\theta_{k+1}$ 的最终封闭形式表达式。",
            "answer": "$$\n\\boxed{\\frac{(8\\ell - 2gh^{2})\\theta_{k} - (4\\ell + gh^{2})\\theta_{k-1}}{4\\ell + gh^{2}}}\n$$"
        },
        {
            "introduction": "变分积分器的一个显著优势是在长时间模拟中能够近乎完美地保持能量。这项练习通过研究简谐振子，将理论分析与数值实现相结合，深入探讨了这一现象的根源()。你将首先推导出一个与隐式中点法等价的辛积分器，然后运用向后误差分析计算其修正哈密顿量，最后通过编程来亲眼观察和量化由该修正哈密顿量所预测的能量在数值模拟中的振荡行为。",
            "id": "3739710",
            "problem": "考虑一个质量为 $m$、刚度为 $k$ 的一维谐振子，其拉格朗日量为 $L(q,\\dot{q})=\\tfrac{1}{2}m\\dot{q}^{2}-\\tfrac{1}{2}k q^{2}$。在离散变分力学中，对于一个固定的时间步长 $h>0$，中点离散拉格朗日量 $L_{d}$ 定义为 $L_{d}(q_{k},q_{k+1};h)=h\\,L\\!\\left(\\tfrac{q_{k}+q_{k+1}}{2},\\tfrac{q_{k+1}-q_{k}}{h}\\right)$。通过对离散作用量和 $\\sum_{k}L_{d}(q_{k},q_{k+1};h)$ 关于 $q_{k}$ 取平稳值，可以得到离散欧拉-拉格朗日方程。使用离散勒让德变换，可以得到一个在 $(q,p)$ 上的辛单步映射，该映射与应用于正则哈密顿系统 $H(q,p)=\\tfrac{p^{2}}{2m}+\\tfrac{k}{2}q^{2}$ 的隐式中点格式相吻合。修正哈密顿量是一个形式哈密顿量 $H_{h}(q,p)$，其精确时间-$h$ 流与离散辛映射相匹配，局部误差为 $O(h^{3})$，并且它有一个渐近展开式 $H_{h}=H+h^{2}H_{2}+O(h^{4})$。\n\n您的任务是：\n1. 仅从连续拉格朗日量 $L(q,\\dot{q})$、中点离散拉格朗日量 $L_{d}(q_{k},q_{k+1};h)$ 和离散变分原理的定义出发，推导出离散欧拉-拉格朗日方程以及相关的辛 $(q,p)$ 更新。证明所得到的方法是正则方程 $\\dot{q}=\\tfrac{p}{m}$ 和 $\\dot{p}=-kq$ 的隐式中点离散化。\n2. 使用后向误差分析原理，计算将基于中点的 $L_{d}$ 应用于谐振子时，修正哈密顿量 $H_{h}(q,p)$ 直至 $O(h^{2})$ 的项。根据 $H(q,p)$ 的结构，解释 $O(h^{2})$ 修正项 $H_{2}$ 是零还是非零，并说明原因。\n3. 实现一个程序，对于给定的参数 $(m,k,h,q_{0},p_{0},N)$，应用推导出的辛 $(q,p)$ 更新进行 $N$ 步计算，并计算离散轨迹相对于精确哈密顿量 $H(q,p)$ 的归一化能量振荡幅度。将归一化幅度定义为 $\\frac{\\max_{0\\leq n\\leq N}H(q_{n},p_{n})-\\min_{0\\leq n\\leq N}H(q_{n},p_{n})}{\\frac{1}{N+1}\\sum_{n=0}^{N}H(q_{n},p_{n})}$，这是一个无量纲量。\n4. 报告以下参数值测试套件的结果：\n   - 情况A（一般稳定步长）：$(m,k,h,q_{0},p_{0},N)=(1,1,0.1,1,0,200)$。\n   - 情况B（大时间步长）：$(m,k,h,q_{0},p_{0},N)=(2,8,1.5,0.7,-0.3,150)$。\n   - 情况C（弱弹簧，相对于频率的大步长）：$(m,k,h,q_{0},p_{0},N)=(1,10^{-3},1.0,1.2,0.0,100)$。\n   - 情况D（刚性振子）：$(m,k,h,q_{0},p_{0},N)=(5,50,0.3,0.2,1.0,400)$。\n您的程序应生成单行输出，其中包含情况 A–D 的结果，形式为一个用方括号括起来的逗号分隔列表（例如，$[r_{A},r_{B},r_{C},r_{D}]$），其中每个 $r_{\\cdot}$ 是一个浮点数，表示该情况下的归一化能量振荡幅度。由于报告的量是无量纲的，因此不需要物理单位。",
            "solution": "首先对用户提供的问题进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n-   一维谐振子的连续拉格朗日量：$L(q,\\dot{q})=\\tfrac{1}{2}m\\dot{q}^{2}-\\tfrac{1}{2}k q^{2}$\n-   质量 $m$，刚度 $k$。\n-   固定时间步长 $h>0$。\n-   中点离散拉格朗日量：$L_{d}(q_{k},q_{k+1};h)=h\\,L\\!\\left(\\tfrac{q_{k}+q_{k+1}}{2},\\tfrac{q_{k+1}-q_{k}}{h}\\right)$\n-   离散变分原理：离散作用量和 $\\sum_{k}L_{d}(q_{k},q_{k+1};h)$ 关于 $q_k$ 的平稳性。\n-   连续哈密顿量：$H(q,p)=\\tfrac{p^{2}}{2m}+\\tfrac{k}{2}q^{2}$\n-   正则哈密顿方程：$\\dot{q}=\\tfrac{p}{m}$ 和 $\\dot{p}=-kq$。\n-   修正哈密顿量定义：$H_{h}(q,p)$ 是一个形式哈密顿量，其精确时间-$h$ 流与离散辛映射相匹配。\n-   修正哈密顿量的渐近展开：$H_{h}=H+h^{2}H_{2}+O(h^{4})$。\n-   归一化能量振荡幅度的定义：$\\frac{\\max_{0\\leq n\\leq N}H(q_{n},p_{n})-\\min_{0\\leq n\\leq N}H(q_{n},p_{n})}{\\frac{1}{N+1}\\sum_{n=0}^{N}H(q_{n},p_{n})}$\n-   实现的测试用例：\n    -   情况 A：$(m,k,h,q_{0},p_{0},N)=(1,1,0.1,1,0,200)$。\n    -   情况 B：$(m,k,h,q_{0},p_{0},N)=(2,8,1.5,0.7,-0.3,150)$。\n    -   情况 C：$(m,k,h,q_{0},p_{0},N)=(1,10^{-3},1.0,1.2,0.0,100)$。\n    -   情况 D：$(m,k,h,q_{0},p_{0},N)=(5,50,0.3,0.2,1.0,400)$。\n\n### 第 2 步：使用提取的已知条件进行验证\n-   **科学上成立**：该问题是几何数值积分和离散变分力学中一个标准的、成熟的课题，重点关注谐振子的基本模型。所有定义和原理都是正确且是该领域的核心内容。该问题在科学上是合理的。\n-   **良定的**：问题陈述清晰，包含了所有必要的定义、参数和目标。任务以逻辑顺序指定，导向唯一的数学推导和可验证的数值结果。\n-   **客观的**：语言是形式化的、数学的，没有任何主观或含糊的陈述。\n\n该问题没有表现出任何列举的缺陷（例如，科学上不合理、不完整、含糊不清）。这是一个来自计算力学领域的、良定的、科学上成立的问题。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供一个完整的、有理有据的解答。\n\n---\n\n### 第 1 部分：离散更新的推导及确认为隐式中点格式\n\n连续拉格朗日量由 $L(q, \\dot{q}) = \\frac{1}{2}m\\dot{q}^2 - \\frac{1}{2}kq^2$ 给出。中点离散拉格朗日量 $L_d$ 是通过在位置中点 $\\frac{q_k+q_{k+1}}{2}$ 处评估 $L$ 并对速度使用有限差分 $\\frac{q_{k+1}-q_k}{h}$ 来构造的。\n$$L_d(q_k, q_{k+1}; h) = h L\\left(\\frac{q_k+q_{k+1}}{2}, \\frac{q_{k+1}-q_k}{h}\\right)$$\n代入 $L$ 的表达式：\n$$L_d(q_k, q_{k+1}; h) = h \\left[ \\frac{1}{2}m\\left(\\frac{q_{k+1}-q_k}{h}\\right)^2 - \\frac{1}{2}k\\left(\\frac{q_k+q_{k+1}}{2}\\right)^2 \\right] = \\frac{m}{2h}(q_{k+1}-q_k)^2 - \\frac{kh}{8}(q_k+q_{k+1})^2$$\n离散作用量和为 $S_d = \\sum_{k=0}^{N-1} L_d(q_k, q_{k+1}; h)$。离散欧拉-拉格朗日 (DEL) 方程由平稳作用量原理 $\\delta S_d = 0$ 导出，对于内部点 $q_k$，这意味着涉及 $q_k$ 的项关于 $q_k$ 的偏导数之和必须为零。\n$$\\frac{\\partial}{\\partial q_k} \\left( L_d(q_{k-1}, q_k; h) + L_d(q_k, q_{k+1}; h) \\right) = 0$$\n这等价于标准形式 $D_2 L_d(q_{k-1}, q_k) + D_1 L_d(q_k, q_{k+1}) = 0$，其中 $D_i$ 表示对第 $i$ 个参数的偏导数。我们来计算这些导数：\n$$D_1 L_d(q_k, q_{k+1}) = \\frac{\\partial L_d}{\\partial q_k} = \\frac{m}{h}(q_{k+1}-q_k)(-1) - \\frac{kh}{4}(q_k+q_{k+1}) = -\\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$$\n$$D_2 L_d(q_{k-1}, q_k) = \\frac{\\partial L_d}{\\partial q_k} = \\frac{m}{h}(q_k-q_{k-1})(1) - \\frac{kh}{4}(q_{k-1}+q_k) = \\frac{m}{h}(q_k-q_{k-1}) - \\frac{kh}{4}(q_{k-1}+q_k)$$\n将这两个表达式相加并设为零，得到 DEL 方程：\n$$\\frac{m}{h}(q_k - q_{k-1}) - \\frac{kh}{4}(q_{k-1}+q_k) - \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1}) = 0$$\n整理各项得到二阶差分方程：\n$$m\\frac{q_{k+1}-2q_k+q_{k-1}}{h} - \\frac{kh}{4}(q_{k+1} + 2q_k + q_{k-1}) = 0$$\n为了找到单步 $(q,p)$ 更新，我们使用离散勒让德变换，它定义了区间 $[q_k, q_{k+1}]$ 的动量 $p_k$ 和 $p_{k+1}$：\n$$p_k := -D_1 L_d(q_k, q_{k+1}) = \\frac{m}{h}(q_{k+1}-q_k) + \\frac{kh}{4}(q_k+q_{k+1})$$\n$$p_{k+1} := D_2 L_d(q_k, q_{k+1}) = \\frac{m}{h}(q_{k+1}-q_k) - \\frac{kh}{4}(q_k+q_{k+1})$$\n这里，$p_k$ 是区间开始时的动量，$p_{k+1}$ 是结束时的动量。我们可以将其表示为一个从 $(q_k, p_k)$到 $(q_{k+1}, p_{k+1})$ 的映射。对这两个动量方程求和与求差可得：\n$$p_k + p_{k+1} = \\frac{2m}{h}(q_{k+1}-q_k) \\implies \\frac{q_{k+1}-q_k}{h} = \\frac{1}{m}\\frac{p_k+p_{k+1}}{2}$$\n$$p_k - p_{k+1} = \\frac{kh}{2}(q_k+q_{k+1}) \\implies \\frac{p_{k+1}-p_k}{h} = -k\\frac{q_k+q_{k+1}}{2}$$\n这些方程恰好是应用于正则哈密顿系统 $\\dot{q} = p/m$ 和 $\\dot{p} = -kq$ 的隐式中点格式，其中区间 $(t_k, t_{k+1})$ 中点的状态被近似为端点状态的平均值。\n\n为了推导显式辛映射 $(q_k, p_k) \\mapsto (q_{k+1}, p_{k+1})$，我们可以将隐式系统写成矩阵形式：\n$$\n\\begin{pmatrix} 1 & -\\frac{h}{2m} \\\\ \\frac{kh}{2} & 1 \\end{pmatrix}\n\\begin{pmatrix} q_{k+1} \\\\ p_{k+1} \\end{pmatrix}\n=\n\\begin{pmatrix} 1 & \\frac{h}{2m} \\\\ -\\frac{kh}{2} & 1 \\end{pmatrix}\n\\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}\n$$\n对左侧矩阵求逆，得到显式更新规则。左侧矩阵的行列式为 $1 + \\frac{kh^2}{4m}$。\n$$\n\\begin{pmatrix} q_{k+1} \\\\ p_{k+1} \\end{pmatrix}\n=\n\\frac{1}{1 + \\frac{kh^2}{4m}}\n\\begin{pmatrix} 1 & \\frac{h}{2m} \\\\ -\\frac{kh}{2} & 1 \\end{pmatrix}\n\\begin{pmatrix} 1 & \\frac{h}{2m} \\\\ -\\frac{kh}{2} & 1 \\end{pmatrix}\n\\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}\n=\n\\frac{1}{1 + \\frac{kh^2}{4m}}\n\\begin{pmatrix} 1 - \\frac{kh^2}{4m} & \\frac{h}{m} \\\\ -kh & 1 - \\frac{kh^2}{4m} \\end{pmatrix}\n\\begin{pmatrix} q_k \\\\ p_k \\end{pmatrix}\n$$\n\n### 第 2 部分：修正哈密顿量的计算\n\n对于一个对称的数值方法，后向误差分析保证了数值解位于一个修正系统的精确轨迹上，该系统的哈密顿量 $H_h$ 具有一个以 $h$ 的偶次幂展开的渐近级数：$H_h = H + h^2 H_2 + h^4 H_4 + \\dots$。\n线性哈密顿系统为 $\\dot{\\mathbf{z}} = A\\mathbf{z}$，其中 $\\mathbf{z}=(q,p)^T$ 且 $A = J S = \\begin{pmatrix} 0 & 1/m \\\\ -k & 0 \\end{pmatrix}$。数值映射是凯莱变换 $\\Psi_h = (I - \\frac{h}{2}A)^{-1}(I + \\frac{h}{2}A)$。修正系统是 $\\dot{\\mathbf{z}} = A_h \\mathbf{z}$，其中精确流 $\\exp(hA_h) = \\Psi_h$。这意味着 $hA_h = \\log(\\Psi_h) = 2 \\operatorname{arctanh}(\\frac{h}{2}A)$。\n使用级数展开 $\\operatorname{arctanh}(x) = x + \\frac{x^3}{3} + \\frac{x^5}{5} + \\dots$，我们得到：\n$$A_h = \\frac{2}{h}\\left(\\frac{hA}{2} + \\frac{1}{3}\\left(\\frac{hA}{2}\\right)^3 + O(h^5)\\right) = A + \\frac{h^2}{12}A^3 + O(h^4)$$\n我们计算 $A^2$ 和 $A^3$：\n$$A^2 = \\begin{pmatrix} 0 & 1/m \\\\ -k & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1/m \\\\ -k & 0 \\end{pmatrix} = \\begin{pmatrix} -k/m & 0 \\\\ 0 & -k/m \\end{pmatrix} = -\\frac{k}{m}I = -\\omega^2 I$$\n其中 $\\omega = \\sqrt{k/m}$ 是自然频率。\n$$A^3 = A^2 A = -\\omega^2 I A = -\\omega^2 A$$\n将此代入 $A_h$ 的展开式中：\n$$A_h = A + \\frac{h^2}{12}(-\\omega^2 A) + O(h^4) = \\left(1 - \\frac{\\omega^2 h^2}{12}\\right)A + O(h^4)$$\n修正系统矩阵 $A_h$ 与原始矩阵 $A$ 成正比。修正哈密顿量 $H_h$ 是对应于 $A_h = J S_h$ 的二次型。因此，$S_h = (1 - \\frac{\\omega^2 h^2}{12})S + O(h^4)$。修正哈密顿量是 $H_h(\\mathbf{z}) = \\frac{1}{2}\\mathbf{z}^T S_h \\mathbf{z}$：\n$$H_h = \\left(1 - \\frac{\\omega^2 h^2}{12}\\right) \\frac{1}{2}\\mathbf{z}^T S \\mathbf{z} + O(h^4) = \\left(1 - \\frac{\\omega^2 h^2}{12}\\right)H + O(h^4)$$\n$$H_h = H - \\frac{\\omega^2 h^2}{12}H + O(h^4) = H - h^2 \\frac{k}{12m}\\left(\\frac{p^2}{2m} + \\frac{k}{2}q^2\\right) + O(h^4)$$\n因此，$O(h^2)$ 的修正项是：\n$$H_2(q,p) = -\\frac{k}{12m}\\left(\\frac{p^2}{2m} + \\frac{k}{2}q^2\\right)$$\n此项是**非零的**。原因在于隐式中点格式是一种二阶精度的方法，并非谐振子的精确求解器。数值解的频率 $\\tilde{\\omega} = \\frac{2}{h}\\arctan(\\frac{\\omega h}{2})$ 与真实频率 $\\omega$ 相差一个 $O(h^2)$ 的量级。这种频率误差是 $O(h^3)$ 局部截断误差的一种表现，对于对称方法，它对应于一个守恒量（即修正哈密顿量 $H_h$）中 $O(h^2)$ 的扰动。原始哈密顿量 $H$ 的二次结构是特殊的，导致 $A^3$ 与 $A$ 成正比，从而使 $H_2$ 与 $H$ 成正比。对于非二次型的哈密顿量，$H_2$ 通常会具有与 $H$ 不同的函数形式。\n\n### 第 3 部分：实现策略\n\n程序将为给定的测试用例实现推导出的辛更新映射。对于每个用例 $(m,k,h,q_0,p_0,N)$：\n1.  用 $(q_0, p_0)$ 初始化一个轨迹。\n2.  预先计算更新矩阵的系数以优化循环：\n    -   `denom` = $1 + \\frac{kh^2}{4m}$\n    -   `c11` = `c22` = $(1 - \\frac{kh^2}{4m}) / \\text{denom}$\n    -   `c12` = $(\\frac{h}{m}) / \\text{denom}$\n    -   `c21` = $(-kh) / \\text{denom}$\n3.  迭代 $N$ 次，在每一步 $n$ 使用矩阵乘法从 $(q_n, p_n)$ 计算 $(q_{n+1}, p_{n+1})$：\n    -   $q_{n+1} = c_{11} q_n + c_{12} p_n$\n    -   $p_{n+1} = c_{21} q_n + c_{22} p_n$\n    -   存储新状态。\n4.  在完成包含 $N+1$ 个点（从 $n=0$到 $N$）的轨迹后，为每个点计算精确哈密顿量 $H(q_n, p_n) = \\frac{p_n^2}{2m} + \\frac{k}{2}q_n^2$。\n5.  计算整个轨迹上这些哈密顿量值的最大值、最小值和平均值。\n6.  使用提供的公式计算归一化的能量振荡幅度。\n7.  最终输出将是所有测试用例的这些幅度的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete variational mechanics problem for the harmonic oscillator.\n    \n    This function implements the symplectic integrator derived from the midpoint\n    discrete Lagrangian for a 1D harmonic oscillator. It then computes the\n    normalized energy oscillation amplitude for several test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general stable step)\n        {'m': 1.0, 'k': 1.0, 'h': 0.1, 'q0': 1.0, 'p0': 0.0, 'N': 200},\n        # Case B (large time step)\n        {'m': 2.0, 'k': 8.0, 'h': 1.5, 'q0': 0.7, 'p0': -0.3, 'N': 150},\n        # Case C (weak spring, large step relative to frequency)\n        {'m': 1.0, 'k': 1e-3, 'h': 1.0, 'q0': 1.2, 'p0': 0.0, 'N': 100},\n        # Case D (stiff oscillator)\n        {'m': 5.0, 'k': 50.0, 'h': 0.3, 'q0': 0.2, 'p0': 1.0, 'N': 400},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k, h, q0, p0, N = case['m'], case['k'], case['h'], case['q0'], case['p0'], case['N']\n\n        # Initialize arrays to store the trajectory\n        q_traj = np.zeros(N + 1)\n        p_traj = np.zeros(N + 1)\n        q_traj[0] = q0\n        p_traj[0] = p0\n\n        # Pre-compute the coefficients of the symplectic update matrix\n        # (q_next) = 1/(1+kh^2/4m) * ( (1-kh^2/4m)  h/m   ) * (q_curr)\n        # (p_next)                   ( -kh          1-kh^2/4m )   (p_curr)\n        \n        # Denominator term\n        denom = 1.0 + (k * h**2) / (4.0 * m)\n        \n        # Matrix elements\n        c11 = (1.0 - (k * h**2) / (4.0 * m)) / denom\n        c12 = (h / m) / denom\n        c21 = (-k * h) / denom\n        c22 = c11 # The (2,2) element is the same as (1,1)\n\n        # Propagate the system for N steps\n        for n in range(N):\n            q_curr = q_traj[n]\n            p_curr = p_traj[n]\n            \n            q_next = c11 * q_curr + c12 * p_curr\n            p_next = c21 * q_curr + c22 * p_curr\n            \n            q_traj[n+1] = q_next\n            p_traj[n+1] = p_next\n\n        # Calculate the exact Hamiltonian H(q,p) along the discrete trajectory\n        # H(q,p) = p^2/(2m) + k*q^2/2\n        hamiltonian_values = (p_traj**2) / (2.0 * m) + (k * q_traj**2) / 2.0\n        \n        # Compute the normalized energy oscillation amplitude\n        max_H = np.max(hamiltonian_values)\n        min_H = np.min(hamiltonian_values)\n        avg_H = np.mean(hamiltonian_values)\n        \n        # The denominator avg_H is guaranteed to be positive for non-zero initial conditions\n        # since H is a sum of squares. Handle the theoretical case of avg_H = 0.\n        if avg_H == 0.0:\n            normalized_amplitude = 0.0\n        else:\n            normalized_amplitude = (max_H - min_H) / avg_H\n        \n        results.append(normalized_amplitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个数值方法的理论属性必须通过严谨的测试来验证。这项实践为你提供了一个验证几何积分器核心特性——辛性——的计算工具()。你将为多个知名积分器（包括辛方法和非辛方法）编写代码，通过计算更新映射的雅可比矩阵，并检验其是否保持了辛结构，从而在实践中区分结构保持算法与传统算法的根本不同。",
            "id": "3739657",
            "problem": "考虑一个机械系统，其位形变量为 $q \\in \\mathbb{R}^{n}$，动量为 $p \\in \\mathbb{R}^{n}$，质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 为对称正定矩阵，刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 为对称半正定矩阵。其连续时间拉格朗日量为 $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$，这对应于一个线性谐振子。在离散变分力学中，我们构造一个离散拉格朗日量 $L_{d}(q_{k}, q_{k+1}; h)$，它在一个大小为 $h > 0$ 的时间步长上近似拉格朗日量沿短轨迹段的作用量积分，然后应用离散欧拉-拉格朗日方程，以获得从离散状态 $z_{k} = (q_{k}, p_{k})$ 到 $z_{k+1} = (q_{k+1}, p_{k+1})$ 的更新映射。对于余切丛上的此类变分积分器，其诱导的离散辛二形式与典范辛二形式重合。\n\n令 $z = (q, p) \\in \\mathbb{R}^{2n}$ 表示当前状态，并令 $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$ 表示由给定时间离散化产生的单步更新映射。典范辛矩阵为\n$$\nS = \\begin{bmatrix}\n0 & I_{n} \\\\\n-I_{n} & 0\n\\end{bmatrix} \\in \\mathbb{R}^{2n \\times 2n},\n$$\n其中 $I_{n}$ 是 $n \\times n$ 单位矩阵。一个可微映射 $\\Phi_{h}$ 相对于典范二形式是辛的，当且仅当其雅可比矩阵 $J(z) = D\\Phi_{h}(z)$ 对于域中所有 $z$ 满足\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\n\n您的任务是设计一个程序，通过有限差分计算更新映射的雅可比矩阵，来数值验证其辛性，并检查对于应用于谐振子的几种离散时间积分器，离散辛形式是否得以保持。使用以下积分器：\n- 位置Verlet（也称Störmer–Verlet）变分积分器。\n- 辛欧拉方法（半隐式A型：先更新动量，再更新位置）。\n- 显式欧拉方法（完全显式；这通常不是辛方法）。\n- 隐式中点法（一种辛龙格-库塔方法）。\n\n验证过程必须遵循以下步骤：\n1. 将每个积分器的 $\\Phi_{h}$ 实现为一个函数，该函数将 $z = (q,p)$ 映射到 $z^{+} = (q^{+}, p^{+})$。使用一致的单位，其中 $q$ 的单位是米， $p$ 的单位是千克·米/秒， $M$ 的单位是千克， $K$ 的单位是牛顿/米， $h$ 的单位是秒。不涉及角度量。\n2. 在指定状态 $z$ 周围，使用一个小的微扰 $\\varepsilon > 0$，通过中心有限差分数值计算雅可比矩阵 $J(z)$:\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon},\n$$\n其中 $e_{i}$ 是 $\\mathbb{R}^{2n}$ 中的第 $i$ 个标准基向量， $J_{:,i}$ 表示 $J$ 的第 $i$ 列。\n3. 计算辛性残差\n$$\nE(z) = J(z)^{\\top} S \\, J(z) - S\n$$\n及其弗罗贝尼乌斯范数 $\\lVert E(z) \\rVert_{F}$，其值为一个非负实数。一个很小的值表示辛形式得以保持。通过检查 $\\lVert E(z) \\rVert_{F} \\leq \\tau$（其中 $\\tau$ 是一个容差），将其转换为一个布尔决策。\n\n设计程序以运行以下测试套件，其中 $n$ 是自由度数，$M = \\operatorname{diag}(m_{1}, \\dots, m_{n})$ 的质量 $m_{i} > 0$，$K = \\operatorname{diag}(k_{1}, \\dots, k_{n})$ 的刚度 $k_{i} \\geq 0$，$z$ 是计算雅可比矩阵所围绕的状态。指定 $h$ 的单位为秒，$m_{i}$ 的单位为千克，$k_{i}$ 的单位为牛顿/米：\n- 测试 1 (正常情况，辛方法): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (q, p) = (0.3, -0.7)$。\n- 测试 2 (非辛方法参考): 显式欧拉, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$。\n- 测试 3 (一阶辛方法): 辛欧拉, $n = 1$, $m_{1} = 1.0$, $k_{1} = 4.0$, $h = 0.1$, $z = (0.3, -0.7)$。\n- 测试 4 (多维，辛方法): 隐式中点, $n = 2$, $m = (1.0, 2.0)$, $k = (3.0, 5.0)$, $h = 0.05$, $z = (q_{1}, q_{2}, p_{1}, p_{2}) = (0.1, -0.2, 0.3, -0.4)$。\n- 测试 5 (接近稳定性边界的大步长，辛积分器): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 1.0$, $h = 1.9$, $z = (0.2, 0.1)$。\n- 测试 6 (边界情况：零刚度自由粒子，辛积分器): Verlet, $n = 1$, $m_{1} = 1.0$, $k_{1} = 0.0$, $h = 0.5$, $z = (1.0, -0.5)$。\n\n使用有限差分步长 $\\varepsilon = 10^{-8}$ 和判定容差 $\\tau = 10^{-10}$。对于每个测试，计算辛性条件是否在容差范围内成立的布尔决策。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5,result6]”）。每个元素应为字面量“True”或“False”，对应于相应测试的布尔决策。",
            "solution": "该问题要求对应用于线性谐振子的几种标准时间步进格式的辛性进行数值验证。该问题是有效的，其科学基础是经典力学和几何数值积分，并且是适定的，提供了所有必要信息以获得唯一、可验证的解。\n\n该机械系统由位形 $q \\in \\mathbb{R}^{n}$ 和动量 $p \\in \\mathbb{R}^{n}$ 描述。其连续时间动力学由拉格朗日量 $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\top} M \\dot{q} - \\tfrac{1}{2} q^{\\top} K q$ 控制，其中 $M$ 是对称正定质量矩阵，$K$ 是对称半正定刚度矩阵。相应的哈密顿量为 $H(q,p) = \\frac{1}{2} p^{\\top} M^{-1} p + \\frac{1}{2} q^{\\top} K q$。哈密顿形式的运动方程为：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = M^{-1} p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -K q\n$$\n数值积分器定义了一个单步更新映射 $\\Phi_{h}: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$，它在一个时间步长 $h > 0$ 内近似系统的流。此映射将时间 $t_k$ 时的状态 $z_k = (q_k, p_k)$ 变为时间 $t_{k+1} = t_k + h$ 时的状态 $z_{k+1} = (q_{k+1}, p_{k+1})$。如果映射 $\\Phi_h$ 保持典范辛二形式，则称其为辛映射。这等价于其雅可比矩阵 $J(z) = D\\Phi_{h}(z)$ 对于域中所有状态 $z$ 满足条件：\n$$\nJ(z)^{\\top} S \\, J(z) = S\n$$\n其中 $S$ 是典范辛矩阵 $S = \\begin{bmatrix} 0 & I_{n} \\\\ -I_{n} & 0 \\end{bmatrix}$。\n\n我们将为四种不同的积分器实现更新映射，然后数值验证此性质。设 $q_k, p_k$ 为一个步长开始时的状态，$q_{k+1}, p_{k+1}$ 为结束时的状态。\n\n1.  **位置Verlet (Störmer–Verlet) 积分器**: 这是一种二阶、对称且辛的积分器。其更新规则通过一个三阶段过程给出：\n    $$\n    p_{k+1/2} = p_k - \\frac{h}{2} K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1/2}\n    $$\n    $$\n    p_{k+1} = p_{k+1/2} - \\frac{h}{2} K q_{k+1}\n    $$\n\n2.  **辛欧拉 (A型) 积分器**: 一种一阶、非对称但辛的积分器。“A型”的名称意味着首先使用旧位置更新动量，然后使用新动量更新位置。\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n    $$\n    q_{k+1} = q_k + h M^{-1} p_{k+1}\n    $$\n\n3.  **显式欧拉积分器**: 这是最简单的一阶积分器。它通常不是辛的。两个新状态变量都仅使用旧状态变量计算。注意，与辛欧拉方法不同，$q$ 和 $p$ 的更新顺序是独立的。\n    $$\n    q_{k+1} = q_k + h M^{-1} p_k\n    $$\n    $$\n    p_{k+1} = p_k - h K q_k\n    $$\n\n4.  **隐式中点法**: 一种二阶、对称且辛的隐式龙格-库塔方法。它通过在时间和状态的中点评估向量场来定义。\n    $$\n    q_{k+1} = q_k + h M^{-1} \\left( \\frac{p_k + p_{k+1}}{2} \\right)\n    $$\n    $$\n    p_{k+1} = p_k - h K \\left( \\frac{q_k + q_{k+1}}{2} \\right)\n    $$\n    这构成了一个关于 $(q_{k+1}, p_{k+1})$ 的线性方程组。通过代入和重新整理，我们可以推导出一个显式过程。首先，求解 $q_{k+1}$：\n    $$\n    \\left( I + \\frac{h^2}{4} M^{-1} K \\right) q_{k+1} = \\left( I - \\frac{h^2}{4} M^{-1} K \\right) q_k + h M^{-1} p_k\n    $$\n    然后，直接计算 $p_{k+1}$：\n    $$\n    p_{k+1} = p_k - \\frac{h}{2} K(q_k + q_{k+1})\n    $$\n\n数值验证过程如下：\n首先，对于每个积分器，我们定义一个映射 $\\Phi_h$，该映射从 $z_k = (q_k, p_k)$ 计算出 $z_{k+1} = (q_{k+1}, p_{k+1})$。其次，我们使用中心有限差分公式，在给定状态 $z$ 处数值近似其雅可比矩阵 $J(z)$ 的 $2n$ 个列：\n$$\nJ_{:,i}(z) \\approx \\frac{\\Phi_{h}(z + \\varepsilon e_{i}) - \\Phi_{h}(z - \\varepsilon e_{i})}{2\\varepsilon}\n$$\n其中 $e_i$ 是第 $i$ 个标准基向量，$\\varepsilon$ 是一个小的微扰，给定为 $\\varepsilon = 10^{-8}$。第三，我们计算辛性残差矩阵 $E(z) = J(z)^{\\top} S J(z) - S$。最后，我们计算其弗罗贝尼乌斯范数 $\\lVert E(z) \\rVert_{F}$，并检查它是否低于指定的容差 $\\tau = 10^{-10}$。低于此容差的范数表明，在该数值测试的精度范围内，积分器保持了辛结构。程序将对问题陈述中指定的每个测试用例执行此过程。",
            "answer": "```python\nimport numpy as np\n\ndef verlet_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Position Verlet integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_half = p - (h / 2.0) * (K @ q)\n    q_new = q + h * (M_inv @ p_half)\n    p_new = p_half - (h / 2.0) * (K @ q_new)\n    return np.concatenate((q_new, p_new))\n\ndef symplectic_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Symplectic Euler (Type A) integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    p_new = p - h * (K @ q)\n    q_new = q + h * (M_inv @ p_new)\n    return np.concatenate((q_new, p_new))\n\ndef explicit_euler_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Explicit Euler integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    q_new = q + h * (M_inv @ p)\n    p_new = p - h * (K @ q)\n    return np.concatenate((q_new, p_new))\n\ndef implicit_midpoint_step(z, h, M_inv, K, n):\n    \"\"\"\n    Performs one step of the Implicit Midpoint integrator.\n    \n    Args:\n        z (np.ndarray): Current state [q, p].\n        h (float): Time step.\n        M_inv (np.ndarray): Inverse of mass matrix.\n        K (np.ndarray): Stiffness matrix.\n        n (int): Number of degrees of freedom.\n        \n    Returns:\n        np.ndarray: Next state [q+, p+].\n    \"\"\"\n    q, p = z[:n], z[n:]\n    I_n = np.identity(n)\n    \n    # Solve for q_new from the linear system:\n    # (I + (h^2/4) * M_inv @ K) @ q_new = (I - (h^2/4) * M_inv @ K) @ q + h * M_inv @ p\n    A = I_n + (h**2 / 4.0) * (M_inv @ K)\n    rhs = (I_n - (h**2 / 4.0) * (M_inv @ K)) @ q + h * (M_inv @ p)\n    q_new = np.linalg.solve(A, rhs)\n    \n    # Compute p_new explicitly using the found q_new\n    p_new = p - (h / 2.0) * (K @ (q + q_new))\n    return np.concatenate((q_new, p_new))\n\ndef compute_jacobian(phi, z, h, M_inv, K, n, eps):\n    \"\"\"\n    Computes the Jacobian of the integrator map phi using central finite differences.\n    \"\"\"\n    dim = 2 * n\n    J = np.zeros((dim, dim))\n    for i in range(dim):\n        e_i = np.zeros(dim)\n        e_i[i] = 1.0\n        z_plus = phi(z + eps * e_i, h, M_inv, K, n)\n        z_minus = phi(z - eps * e_i, h, M_inv, K, n)\n        J[:, i] = (z_plus - z_minus) / (2.0 * eps)\n    return J\n\ndef check_symplecticity(J, n, tau):\n    \"\"\"\n    Checks if the Jacobian J satisfies the symplecticity condition.\n    \"\"\"\n    dim = 2 * n\n    I_n = np.identity(n)\n    S = np.block([\n        [np.zeros((n, n)), I_n],\n        [-I_n, np.zeros((n, n))]\n    ])\n    \n    residual = J.T @ S @ J - S\n    norm = np.linalg.norm(residual, 'fro')\n    \n    return norm = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify symplecticity.\n    \"\"\"\n    \n    test_cases = [\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Explicit Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Symplectic Euler', 'n': 1, 'm': np.array([1.0]), 'k': np.array([4.0]), 'h': 0.1, 'z': np.array([0.3, -0.7])},\n        {'name': 'Implicit Midpoint', 'n': 2, 'm': np.array([1.0, 2.0]), 'k': np.array([3.0, 5.0]), 'h': 0.05, 'z': np.array([0.1, -0.2, 0.3, -0.4])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([1.0]), 'h': 1.9, 'z': np.array([0.2, 0.1])},\n        {'name': 'Verlet', 'n': 1, 'm': np.array([1.0]), 'k': np.array([0.0]), 'h': 0.5, 'z': np.array([1.0, -0.5])},\n    ]\n\n    integrators = {\n        'Verlet': verlet_step,\n        'Symplectic Euler': symplectic_euler_step,\n        'Explicit Euler': explicit_euler_step,\n        'Implicit Midpoint': implicit_midpoint_step,\n    }\n    \n    eps = 1e-8\n    tau = 1e-10\n    \n    results = []\n    \n    for case in test_cases:\n        n = case['n']\n        h = case['h']\n        z = case['z']\n        \n        M = np.diag(case['m'])\n        K = np.diag(case['k'])\n        # Handle division by zero for mass if it occurs, though not in test cases.\n        m_inv_diag = np.zeros_like(case['m'], dtype=float)\n        non_zero_m = case['m'] != 0\n        m_inv_diag[non_zero_m] = 1.0 / case['m'][non_zero_m]\n        M_inv = np.diag(m_inv_diag)\n\n        phi = integrators[case['name']]\n        \n        J = compute_jacobian(phi, z, h, M_inv, K, n, eps)\n        is_symplectic = check_symplecticity(J, n, tau)\n        \n        results.append(str(is_symplectic))\n        \n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}