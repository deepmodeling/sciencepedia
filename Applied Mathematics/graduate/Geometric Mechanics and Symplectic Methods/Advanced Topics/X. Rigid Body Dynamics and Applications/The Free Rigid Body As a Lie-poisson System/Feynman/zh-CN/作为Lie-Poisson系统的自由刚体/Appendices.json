{
    "hands_on_practices": [
        {
            "introduction": "在本实践中，我们将探讨惯性张量在不同坐标系下的表示。通过在一个非主轴坐标系中推导哈密顿量，我们可以直观地看到坐标选择如何引入耦合项，并理解通过正交变换将系统恢复到其标准对角形式的重要性。这项练习  强化了对刚体动力学中坐标系不变性和哈密顿量物理意义的理解。",
            "id": "3776139",
            "problem": "将自由刚体视为特殊正交群（SO(3)）的李代数的对偶（记为 $\\mathfrak{so}(3)^{*}$）上的一个哈密顿系统。$\\mathfrak{so}(3)^{*}$ 上的规范李-泊松结构生成了物体角动量 $\\,\\Pi \\in \\mathbb{R}^{3}\\,$ 的动力学，其哈密顿量 $\\,H(\\Pi)\\,$ 由物体的惯性张量决定。物体动能为 $\\,T = \\frac{1}{2}\\,\\Omega \\cdot I\\,\\Omega\\,$，其中 $\\,I\\,$ 是一个对称、正定的惯性张量，而 $\\,\\Pi = I\\,\\Omega$ 定义了物体角动量。通过一个固定的旋转 $\\,R \\in \\mathrm{SO}(3)$ 来旋转主轴标架，可以得到一个非主轴物体标架，这通常会使得 $\\,I\\,$ 在旋转后的标架中非对角化，并耦合 $\\,\\Omega\\,$ 和 $\\,\\Pi\\,$ 的分量。\n\n从 $\\mathfrak{so}(3)^{*}$ 上的李-泊松结构、动能以及 $\\mathrm{SO}(3)$ 在 $\\mathbb{R}^{3}$ 上的旋转作用的基本定义出发，推导在旋转后的（非主轴）标架中，非对角惯性张量如何改变哈密顿量 $\\,H(\\Pi)\\,$ 和运动方程。然后说明如何通过一个正交变换回到主轴，使 $\\,I\\,$ 对角化，并恢复哈密顿量和李-泊松方程的标准形式。\n\n具体来说，假设刚体在其主轴标架中的主转动惯量为 $\\,I_{1} = 2\\,\\mathrm{kg\\,m^{2}},\\,I_{2} = 1\\,\\mathrm{kg\\,m^{2}},\\,I_{3} = 3\\,\\mathrm{kg\\,m^{2}}\\,$。考虑通过绕第三主轴旋转角度 $\\,\\theta = \\pi/4\\,$ 弧度得到的非主轴物体标架。令 $\\,R\\,$ 表示旋转矩阵，$\\,D = \\mathrm{diag}(I_{1},I_{2},I_{3})\\,$ 表示主轴中的对角惯性张量。运用第一性原理：\n\n- 求出旋转后标架中的惯性张量 $\\,I\\,$。\n- 在旋转后标架中表示哈密顿量 $\\,H(\\Pi) = \\frac{1}{2}\\,\\Pi \\cdot I^{-1}\\,\\Pi\\,$，并解释由非对角元引起的耦合。\n- 确定将哈密顿量和运动方程恢复到主轴中标准对角形式的正交变换。\n- 对于在旋转后标架中的初始物体角动量 $\\,\\Pi_{0} = (1,\\,2,\\,3)\\,$，计算其动能 $\\,H(\\Pi_{0})\\,$。\n\n用焦耳表示最终能量，并将答案四舍五入到四位有效数字。整个过程中角度必须以弧度处理。",
            "solution": "该问题是有效的，因为它科学地基于几何力学的原理，问题陈述清晰，提供了所有必要信息，并且是客观陈述的。\n\n该问题要求分析自由刚体在非主轴参考系中的运动。我们首先建立通用框架，然后进行具体计算。\n\n### 通用框架：自由刚体的李-泊松动力学\n\n自由刚体的位形空间是特殊正交群 $\\mathrm{SO}(3)$。相空间是其余切丛 $T^*\\mathrm{SO}(3)$。通过哈密顿约化过程，该系统可以在 $\\mathrm{SO}(3)$ 的李代数的对偶（记为 $\\mathfrak{so}(3)^*$)上进行描述。我们可以通过标准的向量叉积将 $\\mathfrak{so}(3)^*$ 等同于 $\\mathbb{R}^3$。这个约化相空间上的变量是物体角动量 $\\Pi \\in \\mathbb{R}^3$。\n\n动力学由李-泊松括号决定。对于 $\\mathfrak{so}(3)^*$ 上的任意两个光滑函数 $F(\\Pi)$ 和 $G(\\Pi)$，它们的括号由下式给出：\n$$\n\\{F, G\\}(\\Pi) = -\\Pi \\cdot (\\nabla F(\\Pi) \\times \\nabla G(\\Pi))\n$$\n其中 $\\nabla$ 是关于 $\\Pi$ 各分量的梯度。角动量向量 $\\Pi$ 的运动方程由 $\\dot{\\Pi} = \\{\\Pi, H\\}$ 给出，其中 $H(\\Pi)$ 是系统的哈密顿量。这得到了向量形式的欧拉方程：\n$$\n\\dot{\\Pi} = -\\Pi \\times \\nabla H(\\Pi)\n$$\n自由刚体的哈密顿量是其动能 $T$。动能用角速度 $\\Omega$ 表示为 $T = \\frac{1}{2}\\Omega \\cdot (I\\Omega)$，其中 $I$ 是对称、正定的惯性张量。物体角动量 $\\Pi$ 与角速度 $\\Omega$ 的关系为 $\\Pi = I\\Omega$。由此，我们可以写出 $\\Omega = I^{-1}\\Pi$。将此代入能量表达式，得到用 $\\Pi$ 表示的哈密顿量：\n$$\nH(\\Pi) = \\frac{1}{2}(I^{-1}\\Pi) \\cdot (I(I^{-1}\\Pi)) = \\frac{1}{2}(I^{-1}\\Pi) \\cdot \\Pi = \\frac{1}{2}\\Pi^T I^{-1} \\Pi\n$$\n哈密顿量的梯度为 $\\nabla H(\\Pi) = I^{-1}\\Pi = \\Omega$。因此，运动方程变为：\n$$\n\\dot{\\Pi} = -\\Pi \\times (I^{-1}\\Pi) = -\\Pi \\times \\Omega\n$$\n这是刚体欧拉方程的无坐标形式。\n\n### 变换到非主轴标架\n\n在主轴标架中，惯性张量是对角的，$I = D = \\mathrm{diag}(I_1, I_2, I_3)$。哈密顿量具有标准的简单形式：\n$$\nH(\\Pi) = \\frac{1}{2}\\left(\\frac{\\Pi_1^2}{I_1} + \\frac{\\Pi_2^2}{I_2} + \\frac{\\Pi_3^2}{I_3}\\right)\n$$\n考虑通过对主轴标架应用一个旋转 $R \\in \\mathrm{SO}(3)$ 得到的一个新的物体固定标架。让主轴标架中的坐标用撇号（例如 $\\Pi'$）表示，而新（旋转后）标架中的坐标不用撇号。新标架中的向量 $v$ 与其在主轴标架中的表示 $v'$ 的关系是 $v = Rv'$。惯性张量根据规则 $I = RDR^T$ 进行变换。因此，其逆变换为 $I^{-1} = (RDR^T)^{-1} = R D^{-1} R^T$。\n\n在旋转后的标架中，哈密顿量为 $H(\\Pi) = \\frac{1}{2}\\Pi^T I^{-1} \\Pi$。代入变换后的逆惯性张量：\n$$\nH(\\Pi) = \\frac{1}{2}\\Pi^T (R D^{-1} R^T) \\Pi = \\frac{1}{2}(R^T \\Pi)^T D^{-1} (R^T \\Pi)\n$$\n由于向量变换关系为 $\\Pi = R\\Pi'$，我们有 $\\Pi' = R^T \\Pi$。这表明新坐标系中的哈密顿量在数值上等于主轴坐标系中的哈密顿量，$H(\\Pi) = H(\\Pi')$，因为能量是标量不变量。然而，当用 $\\Pi$ 的分量（即 $\\Pi_1, \\Pi_2, \\Pi_3$）表示时，哈密顿量将包含交叉项，因为 $I^{-1} = R D^{-1} R^T$ 通常不是一个对角矩阵。这些交叉项代表了因选择非主轴而引起的耦合。运动方程 $\\dot{\\Pi} = -\\Pi \\times (I^{-1}\\Pi)$ 将明确地反映这种耦合。\n\n要恢复哈密顿量和运动方程的标准对角形式，必须执行一个回到主轴的坐标正交变换。这个变换正是 $\\Pi' = R^T \\Pi$。算子是矩阵 $R^T$。在这个新的坐标系 $\\Pi'$ 中，哈密顿量是 $H(\\Pi') = \\frac{1}{2}(\\Pi')^T D^{-1} \\Pi'$，这是对角的，运动方程也变为标准的欧拉方程。\n\n### 具体计算\n\n给定的主转动惯量为：$I_1 = 2\\,\\mathrm{kg\\,m^2}$，$I_2 = 1\\,\\mathrm{kg\\,m^2}$，以及 $I_3 = 3\\,\\mathrm{kg\\,m^2}$。主轴标架中的对角惯性张量是：\n$$\nD = \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 3 \\end{pmatrix}\n$$\n非主轴标架是通过绕第三主轴旋转 $\\theta = \\pi/4$ 得到的。旋转矩阵 $R$ 是：\n$$\nR = R_z(\\pi/4) = \\begin{pmatrix} \\cos(\\pi/4) & -\\sin(\\pi/4) & 0 \\\\ \\sin(\\pi/4) & \\cos(\\pi/4) & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1/\\sqrt{2} & -1/\\sqrt{2} & 0 \\\\ 1/\\sqrt{2} & 1/\\sqrt{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\n**1. 旋转后标架中的惯性张量 $I$**\n旋转后标架中的惯性张量 $I$ 计算为 $I = RDR^T$:\n$$\nI = \\begin{pmatrix} \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 \\\\ \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 3 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\\\ -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n$$\nI = \\begin{pmatrix} \\frac{2}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 \\\\ \\frac{2}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\\\ 0 & 0 & 3 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\\\ -\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{2}{2}+\\frac{1}{2} & \\frac{2}{2}-\\frac{1}{2} & 0 \\\\ \\frac{2}{2}-\\frac{1}{2} & \\frac{2}{2}+\\frac{1}{2} & 0 \\\\ 0 & 0 & 3 \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{2} & \\frac{1}{2} & 0 \\\\ \\frac{1}{2} & \\frac{3}{2} & 0 \\\\ 0 & 0 & 3 \\end{pmatrix}\n$$\n\n**2. 旋转后标架中的哈密顿量 $H(\\Pi)$**\n为了求哈密顿量，我们首先需要 $I^{-1}$。由于 $I$ 是块对角的，我们可以对块求逆。左上角的 $2 \\times 2$ 块是 $\\begin{pmatrix} 3/2 & 1/2 \\\\ 1/2 & 3/2 \\end{pmatrix}$，其行列式是 $(3/2)^2 - (1/2)^2 = 9/4 - 1/4 = 2$。其逆矩阵是 $\\frac{1}{2}\\begin{pmatrix} 3/2 & -1/2 \\\\ -1/2 & 3/2 \\end{pmatrix} = \\begin{pmatrix} 3/4 & -1/4 \\\\ -1/4 & 3/4 \\end{pmatrix}$。右下角元素 $3$ 的逆是 $1/3$。所以：\n$$\nI^{-1} = \\begin{pmatrix} \\frac{3}{4} & -\\frac{1}{4} & 0 \\\\ -\\frac{1}{4} & \\frac{3}{4} & 0 \\\\ 0 & 0 & \\frac{1}{3} \\end{pmatrix}\n$$\n哈密顿量是 $H(\\Pi) = \\frac{1}{2}\\Pi^T I^{-1} \\Pi$:\n$$\nH(\\Pi) = \\frac{1}{2} \\left( \\begin{pmatrix} \\Pi_1 & \\Pi_2 & \\Pi_3 \\end{pmatrix} \\begin{pmatrix} \\frac{3}{4} & -\\frac{1}{4} & 0 \\\\ -\\frac{1}{4} & \\frac{3}{4} & 0 \\\\ 0 & 0 & \\frac{1}{3} \\end{pmatrix} \\begin{pmatrix} \\Pi_1 \\\\ \\Pi_2 \\\\ \\Pi_3 \\end{pmatrix} \\right) = \\frac{1}{2} \\left( \\frac{3}{4}\\Pi_1^2 - \\frac{1}{2}\\Pi_1\\Pi_2 + \\frac{3}{4}\\Pi_2^2 + \\frac{1}{3}\\Pi_3^2 \\right)\n$$\n$$\nH(\\Pi) = \\frac{3}{8}\\Pi_1^2 + \\frac{3}{8}\\Pi_2^2 - \\frac{1}{4}\\Pi_1\\Pi_2 + \\frac{1}{6}\\Pi_3^2\n$$\n项 $-\\frac{1}{4}\\Pi_1\\Pi_2$ 是因选择非主轴坐标系而引起的耦合项。\n\n**3. 回到主轴的正交变换**\n将哈密顿量对角化的正交变换是将坐标从旋转后的标架变换回主轴标架的变换。该变换由 $\\Pi' = R^T \\Pi$ 给出，其中 $R$ 是前面定义的旋转矩阵。因此，变换矩阵是：\n$$\nR^T = \\begin{pmatrix} 1/\\sqrt{2} & 1/\\sqrt{2} & 0 \\\\ -1/\\sqrt{2} & 1/\\sqrt{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\n**4. 动能计算**\n给定旋转后标架中的初始角动量 $\\Pi_0 = (1, 2, 3)$。我们使用为旋转后标架推导的哈密顿量来计算动能 $H(\\Pi_0)$。\n$$\nH(\\Pi_0) = \\frac{3}{8}(1)^2 + \\frac{3}{8}(2)^2 - \\frac{1}{4}(1)(2) + \\frac{1}{6}(3)^2\n$$\n$$\nH(\\Pi_0) = \\frac{3}{8} + \\frac{3}{8}(4) - \\frac{2}{4} + \\frac{9}{6} = \\frac{3}{8} + \\frac{12}{8} - \\frac{1}{2} + \\frac{3}{2}\n$$\n$$\nH(\\Pi_0) = \\frac{15}{8} + 1 = \\frac{15}{8} + \\frac{8}{8} = \\frac{23}{8}\n$$\n数值为 $23/8 = 2.875$。鉴于转动惯量的单位是国际单位制，能量的单位是焦耳。问题要求将答案四舍五入到四位有效数字。值 $2.875$ 已经有四位有效数字。\n\n作为验证，我们可以将 $\\Pi_0$ 变换到主轴标架，并使用对角化的哈密顿量：\n$$\n\\Pi'_0 = R^T \\Pi_0 = \\begin{pmatrix} 1/\\sqrt{2} & 1/\\sqrt{2} & 0 \\\\ -1/\\sqrt{2} & 1/\\sqrt{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} (1+2)/\\sqrt{2} \\\\ (-1+2)/\\sqrt{2} \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 3/\\sqrt{2} \\\\ 1/\\sqrt{2} \\\\ 3 \\end{pmatrix}\n$$\n在主轴标架中的能量是：\n$$\nH(\\Pi'_0) = \\frac{1}{2}\\left(\\frac{(\\Pi'_{0,1})^2}{I_1} + \\frac{(\\Pi'_{0,2})^2}{I_2} + \\frac{(\\Pi'_{0,3})^2}{I_3}\\right) = \\frac{1}{2}\\left(\\frac{(3/\\sqrt{2})^2}{2} + \\frac{(1/\\sqrt{2})^2}{1} + \\frac{3^2}{3}\\right)\n$$\n$$\nH(\\Pi'_0) = \\frac{1}{2}\\left(\\frac{9/2}{2} + \\frac{1/2}{1} + \\frac{9}{3}\\right) = \\frac{1}{2}\\left(\\frac{9}{4} + \\frac{1}{2} + 3\\right) = \\frac{1}{2}\\left(\\frac{9}{4} + \\frac{2}{4} + \\frac{12}{4}\\right) = \\frac{1}{2}\\left(\\frac{23}{4}\\right) = \\frac{23}{8}\n$$\n结果吻合，证实了计算的正确性。最终能量是 $2.875\\,\\mathrm{J}$。",
            "answer": "$$\\boxed{2.875}$$"
        },
        {
            "introduction": "理论分析揭示了自由刚体系统的两个守恒量：哈密顿量（能量）和卡西米尔不变量（角动量大小的平方）。这个计算实践  旨在通过数值方法验证这些守恒定律，并比较通用数值积分器（如四阶龙格-库塔法）与几何积分器（如隐式中点法）在保持这些不变量方面的表现。通过这个练习，你将亲身体会到几何积分在长时间模拟中保持系统内在结构方面的优越性。",
            "id": "3776121",
            "problem": "考虑在体坐标系中描述的自由刚体，它是一个在特殊正交李代数 $so(3)^{\\ast}$ 的对偶空间上的李-泊松系统。设 $M \\in \\mathbb{R}^{3}$ 表示体角动量，并设正定惯性张量为对角矩阵，其主转动惯量为 $I_{1}, I_{2}, I_{3} > 0$。哈密顿量（动能）为 $H(M) = \\tfrac{1}{2} M \\cdot \\mathbb{I}^{-1} M$，其中 $\\mathbb{I}^{-1} = \\mathrm{diag}(I_{1}^{-1}, I_{2}^{-1}, I_{3}^{-1})$。李-泊松运动方程是欧拉方程\n$$\n\\dot{M} \\;=\\; M \\times \\mathbb{I}^{-1} M,\n$$\n其中 $\\times$ 是欧几里得叉积。本体极迹是 $M(t)$ 在角动量球面上描绘的路径，从解析上看，它位于余伴随轨道（一个球面）和能量椭球的交线上。\n\n任务：\n- 在总时间区间 $[0,T]$ 上，使用固定时间步长 $\\Delta t$，为上述系统实现两个时间积分器：\n  1. 经典的显式四阶龙格-库塔方法。\n  2. 隐式中点法，在每一步中使用牛顿法求解至指定公差，通过为中点 $M_{\\mathrm{mid}} = \\tfrac{1}{2}(M_{n}+M_{n+1})$ 构建隐式残差来求解。\n- 对于每个计算出的轨迹，数值评估其不变量：\n  - Casimir 不变量 $C(M) = \\tfrac{1}{2} \\lVert M \\rVert^{2}$，\n  - 能量 $H(M) = \\tfrac{1}{2} M \\cdot \\mathbb{I}^{-1} M$，\n  并报告在整个积分区间内，每个不变量与其初始值的最大相对偏差。具体来说，如果 $Q(t)$ 表示 $C$ 或 $H$，且 $Q(0) = Q_{0} > 0$，则计算 $\\max_{n} \\lvert Q(M_{n}) - Q_{0} \\rvert / Q_{0}$，其中 $M_{n}$ 是离散状态。\n- 系统是无量纲化的；将所有要求报告的量作为无单位的实数。\n\n使用以下参数集测试套件，每个参数集由 $(I_{1}, I_{2}, I_{3}; M_{0}; T; \\Delta t)$ 给出，其中 $M_{0}$ 表示初始条件 $M(0)$，$T$ 是最终时间，$\\Delta t$ 是固定步长：\n- 测试 1（球形陀螺，边界情况）：$(1.0,\\,1.0,\\,1.0;\\ (1.0,\\,0.0,\\,0.0);\\ 10.0;\\ 0.05)$。\n- 测试 2（近对称）：$(1.0,\\,1.05,\\,2.0;\\ (1.0,\\,0.2,\\,0.1);\\ 50.0;\\ 0.01)$。\n- 测试 3（非对称）：$(1.0,\\,2.0,\\,3.0;\\ (1.0,\\,0.3,\\,0.4);\\ 50.0;\\ 0.01)$。\n- 测试 4（主轴上的初始条件，边界情况）：$(1.0,\\,2.0,\\,4.0;\\ (1.0,\\,0.0,\\,0.0);\\ 20.0;\\ 0.02)$。\n\n您的程序必须对每个测试用例和每个积分器，计算 Casimir 不变量和能量与它们初始值的最大相对偏差。对于每个测试用例，按以下顺序返回包含四个浮点数的列表：\n- 显式龙格-库塔方法中 $C$ 的最大相对偏差，\n- 显式龙格-库塔方法中 $H$ 的最大相对偏差，\n- 隐式中点法中 $C$ 的最大相对偏差，\n- 隐式中点法中 $H$ 的最大相对偏差。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的、逗号分隔的列表的列表。例如：\n  - $[\\,[r_{1}, r_{2}, r_{3}, r_{4}],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$.\n- 所有数值输出必须是实数（浮点数）。不应打印其他任何文本。\n\n注意：角度没有显式出现，因此不需要角度单位。所有量都是无量纲化的，因此没有单位。",
            "solution": "用户在几何数值积分领域提供了一个定义明确的问题，该问题应用于自由刚体的经典力学。该问题在科学上是合理的，数学上是明确的，并包含了解决它所需的所有必要信息。因此，该问题被认为是**有效的**。\n\n任务是实现并比较两种用于自由刚体欧拉方程的数值积分器：标准的显式四阶龙格-库塔方法 (RK4) 和隐式中点法。比较标准是系统两个关键不变量的数值保持性：总动能（哈密顿量 $H$）和角动量矢量范数的平方（Casimir 不变量 $C$）。\n\n体坐标系中角动量矢量 $M$ 的运动方程由李-泊松方程给出：\n$$\n\\dot{M} \\;=\\; M \\times (\\mathbb{I}^{-1} M)\n$$\n其中 $\\mathbb{I}^{-1} = \\mathrm{diag}(I_1^{-1}, I_2^{-1}, I_3^{-1})$ 是对角惯性张量的逆。设 $f(M) = M \\times (\\mathbb{I}^{-1} M)$ 表示此常微分方程 (ODE) 的右侧。\n\n需要监测的两个不变量是：\n1.  Casimir 函数, $C(M) = \\frac{1}{2} \\lVert M \\rVert^2$。\n2.  哈密顿函数, $H(M) = \\frac{1}{2} M \\cdot \\mathbb{I}^{-1} M$。\n\n对于一个数值计算出的轨迹 $M_0, M_1, \\ldots, M_N$，积分器的性能通过每个不变量与初始值的最大相对偏差来衡量：\n$$\n\\text{Error}_Q = \\max_{n=0,\\dots,N} \\frac{\\lvert Q(M_n) - Q(M_0) \\rvert}{Q(M_0)}\n$$\n其中 $Q$ 代表 $C$ 或 $H$。\n\n### 数值积分器的实现\n\n**1. 显式四阶龙格-库塔 (RK4)**\n这是一种标准、显式、多步的方法。给定时间 $t_n$ 时的状态 $M_n$，时间 $t_{n+1} = t_n + \\Delta t$ 时的状态 $M_{n+1}$ 计算如下：\n$$\n\\begin{aligned}\nk_1 = \\Delta t \\cdot f(M_n) \\\\\nk_2 = \\Delta t \\cdot f(M_n + \\tfrac{1}{2} k_1) \\\\\nk_3 = \\Delta t \\cdot f(M_n + \\tfrac{1}{2} k_2) \\\\\nk_4 = \\Delta t \\cdot f(M_n + k_3) \\\\\nM_{n+1} = M_n + \\tfrac{1}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nRK4 是一种通用积分器，并非为保持此特定系统的几何结构而设计，因此我们预计它会在不变量上表现出漂移。\n\n**2. 隐式中点法**\n这是一种单步隐式龙格-库塔方法，以其优异的几何保持特性（包括辛性）而闻名。更新规则如下：\n$$\nM_{n+1} = M_n + \\Delta t \\cdot f\\left(\\frac{M_n + M_{n+1}}{2}\\right)\n$$\n这个方程关于 $M_{n+1}$ 是隐式的，必须在每个时间步求解。我们可以将其表述为一个残差函数 $R(X)=0$ 的求根问题，其中 $X$ 是我们对 $M_{n+1}$ 的候选解：\n$$\nR(X) = X - M_n - \\Delta t \\cdot f\\left(\\frac{M_n + X}{2}\\right) = 0\n$$\n根据要求，这个非线性系统使用牛顿法求解。从一个初始猜测 $X_0 = M_n$ 开始，我们通过 $X_{k+1} = X_k + \\delta_k$ 迭代地改进解，其中修正量 $\\delta_k$ 通过求解线性系统得到：\n$$\nJ_R(X_k) \\delta_k = -R(X_k)\n$$\n此迭代需要雅可比矩阵 $J_R(X) = \\frac{\\partial R}{\\partial X}$。它由下式给出：\n$$\nJ_R(X) = I - \\frac{\\Delta t}{2} J_f\\left(\\frac{M_n+X}{2}\\right)\n$$\n其中 $I$ 是 $3 \\times 3$ 单位矩阵，$J_f(M)$ 是函数 $f(M)$ 的雅可比矩阵。函数 $f(M) = M \\times (\\mathbb{I}^{-1} M)$ 的雅可比矩阵可以推导为：\n$$\nJ_f(M) = \\hat{M} \\mathbb{I}^{-1} - \\widehat{(\\mathbb{I}^{-1}M)}\n$$\n其中 $\\hat{v}$ 表示与向量 $v$ 叉积对应的斜对称矩阵。迭代持续进行，直到残差的范数 $\\lVert R(X_k) \\rVert$ 小于指定的公差（例如 $10^{-12}$）。\n\n隐式中点法被期望是该系统的一个几何积分器。实际上，对于任何二次哈密顿量，在没有浮点和非线性求解器误差的情况下，它能精确地保持所有二次不变量。由于 $C(M)$ 和 $H(M)$ 都是 $M$ 的二次函数，我们预计隐式中点法将以非常高的精度保持它们，仅受求解器公差和机器精度的限制。\n\n### 求解过程\n对于每个给定的测试用例：\n1.  将状态 $M$ 初始化为 $M_0$，并计算不变量的初始值 $C_0$ 和 $H_0$。\n2.  使用 RK4 积分器，以时间步长 $\\Delta t$ 从 $t=0$ 模拟到 $t=T$，并存储整个轨迹。\n3.  计算 RK4 轨迹上 $C$ 和 $H$ 的最大相对偏差。\n4.  使用隐式中点积分器重复模拟。\n5.  计算隐式中点轨迹上 $C$ 和 $H$ 的最大相对偏差。\n6.  收集该测试用例的四个偏差值。\n7.  处理完所有测试用例后，将收集到的结果格式化为指定的单个字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rigid body Euler equations problem by implementing and comparing\n    RK4 and implicit midpoint integrators.\n    \"\"\"\n    test_cases = [\n        # (I1, I2, I3), M0, T, dt\n        ((1.0, 1.0, 1.0), (1.0, 0.0, 0.0), 10.0, 0.05),\n        ((1.0, 1.05, 2.0), (1.0, 0.2, 0.1), 50.0, 0.01),\n        ((1.0, 2.0, 3.0), (1.0, 0.3, 0.4), 50.0, 0.01),\n        ((1.0, 2.0, 4.0), (1.0, 0.0, 0.0), 20.0, 0.02),\n    ]\n\n    def f(M, inv_I):\n        \"\"\" The right-hand side of Euler's equation: M x (I^-1 M) \"\"\"\n        return np.cross(M, inv_I * M)\n\n    def C(M):\n        \"\"\" Casimir invariant: 0.5 * ||M||^2 \"\"\"\n        return 0.5 * np.dot(M, M)\n\n    def H(M, inv_I):\n        \"\"\" Hamiltonian (kinetic energy): 0.5 * M . (I^-1 M) \"\"\"\n        return 0.5 * np.dot(M, inv_I * M)\n\n    def hat(v):\n        \"\"\" Maps a 3-vector to its corresponding skew-symmetric matrix. \"\"\"\n        return np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n\n    def integrate_rk4(M0, T, dt, inv_I):\n        \"\"\" Integrates the system using the explicit 4th-order Runge-Kutta method. \"\"\"\n        num_steps = int(round(T / dt))\n        M_traj = [M0]\n        M_n = M0.copy()\n        \n        for _ in range(num_steps):\n            k1 = dt * f(M_n, inv_I)\n            k2 = dt * f(M_n + 0.5 * k1, inv_I)\n            k3 = dt * f(M_n + 0.5 * k2, inv_I)\n            k4 = dt * f(M_n + k3, inv_I)\n            M_n += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            M_traj.append(M_n.copy())\n            \n        return np.array(M_traj)\n\n    def integrate_midpoint(M0, T, dt, inv_I):\n        \"\"\" Integrates the system using the implicit midpoint method with Newton's solver. \"\"\"\n        num_steps = int(round(T / dt))\n        M_traj = [M0]\n        M_n = M0.copy()\n\n        identity = np.identity(3)\n        inv_I_mat = np.diag(inv_I)\n        newton_tol = 1e-13\n        newton_max_iter = 20\n\n        for _ in range(num_steps):\n            X = M_n.copy()  # Initial guess for M_{n+1}\n            for _ in range(newton_max_iter):\n                M_mid = 0.5 * (M_n + X)\n                residual = X - M_n - dt * f(M_mid, inv_I)\n\n                if np.linalg.norm(residual)  newton_tol:\n                    break\n                \n                # Jacobian of f\n                v_mid = inv_I * M_mid\n                Jf = hat(M_mid) @ inv_I_mat - hat(v_mid)\n                \n                # Jacobian of the residual for Newton's method\n                J_R = identity - (dt / 2.0) * Jf\n                \n                delta_X = np.linalg.solve(J_R, -residual)\n                X += delta_X\n            \n            M_n = X\n            M_traj.append(M_n.copy())\n\n        return np.array(M_traj)\n\n    all_results = []\n    for I_tup, M0_tup, T, dt in test_cases:\n        I = np.array(I_tup)\n        inv_I = 1.0 / I\n        M0 = np.array(M0_tup)\n\n        C0 = C(M0)\n        H0 = H(M0, inv_I)\n\n        # Runge-Kutta 4\n        traj_rk4 = integrate_rk4(M0, T, dt, inv_I)\n        max_dev_C_rk4 = np.max(np.abs([C(M) for M in traj_rk4] - C0)) / C0 if C0 != 0 else 0.0\n        max_dev_H_rk4 = np.max(np.abs([H(M, inv_I) for M in traj_rk4] - H0)) / H0 if H0 != 0 else 0.0\n\n        # Implicit Midpoint\n        traj_midpoint = integrate_midpoint(M0, T, dt, inv_I)\n        max_dev_C_mid = np.max(np.abs([C(M) for M in traj_midpoint] - C0)) / C0 if C0 != 0 else 0.0\n        max_dev_H_mid = np.max(np.abs([H(M, inv_I) for M in traj_midpoint] - H0)) / H0 if H0 != 0 else 0.0\n\n        all_results.append([max_dev_C_rk4, max_dev_H_rk4, max_dev_C_mid, max_dev_H_mid])\n    \n    # Format the final output string exactly as requested in the template\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "刚体的李-泊松动力学描述了角动量 $M(t)$ 在李代数对偶空间 $\\mathfrak{so}(3)^*$ 上的演化，但这并未直接给出刚体在空间中的姿态。这个实践  关注于关键的“重构”问题：即如何从已知的 $M(t)$ 恢复出姿态矩阵 $R(t) \\in \\mathrm{SO}(3)$。通过使用一个保结构积分方案，我们将确保计算出的姿态矩阵始终停留在 $\\mathrm{SO}(3)$ 流形上，并数值验证其正交性和单位行列式性质。",
            "id": "3776170",
            "problem": "将自由刚体视为特殊正交李代数对偶上的一个李-泊松系统，该对偶空间是 $\\mathfrak{so}(3)$ 的对偶空间，记为 $\\mathfrak{so}(3)^{\\ast}$。设体角动量为 $M(t) \\in \\mathbb{R}^{3}$，体角速度为 $\\omega(t) \\in \\mathbb{R}^{3}$。惯性张量是一个正定对角矩阵 $I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$，其中 $I_{i}  0$。自由刚体的哈密顿量为 $H(M) = \\tfrac{1}{2} M \\cdot I^{-1} M$。体角动量的李-泊松运动方程为常微分方程 (ODE) $\\dot{M}(t) = M(t) \\times I^{-1} M(t)$，其中 $\\times$ 表示向量叉积。\n\n定义重构矩阵 $R(t) \\in \\mathrm{SO}(3)$（3维特殊正交群），该矩阵将体坐标系映射到空间坐标系。重构由常微分方程 $\\dot{R}(t) = R(t) \\widehat{\\omega}(t)$ 给出，初始条件为 $R(0) = R_{0} \\in \\mathrm{SO}(3)$，其中 $\\widehat{\\omega}(t) \\in \\mathfrak{so}(3)$ 是通过帽子映射与 $\\omega(t)$ 相关联的斜对称矩阵，该映射定义为对任意 $v \\in \\mathbb{R}^{3}$ 都有 $\\widehat{\\omega} v = \\omega \\times v$。\n\n你的任务是：\n- 使用标准ODE求解器，在有限时间区间 $[0, T]$ 上对 $M(t)$ 的李-泊松常微分方程进行数值积分，其中 $\\omega(t) = I^{-1} M(t)$，每个测试用例中都指定了 $M(0)$。\n- 根据数值求解得到的 $M(t)$，通过积分 $\\dot{R}(t) = R(t) \\widehat{\\omega}(t)$，在一个均匀时间网格上计算重构 $R(t)$。积分采用保结构步长 $R_{k+1} = R_{k} \\exp\\!\\big(\\Delta t\\, \\widehat{\\omega}(t_{k})\\big)$，其中 $\\exp$ 表示矩阵指数，$\\Delta t$ 是以秒为单位的均匀时间步长，角度以弧度为单位。\n- 沿着时间网格，通过计算 $R(t)^{\\top} R(t)$ 与单位矩阵的最大弗罗贝尼乌斯范数偏差，以及 $\\det(R(t))$ 与 $1$ 的最大绝对偏差，来验证 $R(t)$ 的正交性和行列式为1的性质。\n\n使用以下参数值测试套件。每个测试用例提供 $(I_{1}, I_{2}, I_{3})$、$M(0)$、$R(0)$、最终时间 $T$（秒）和均匀时间步长 $\\Delta t$（秒）。所有角度均以弧度为单位。单位矩阵记为 $I_{3 \\times 3}$。\n- 测试用例 1（非对称刚体，一般运动）：$(I_{1}, I_{2}, I_{3}) = (2.0, 1.5, 1.0)$；$M(0) = (0.9, 0.2, 0.7)$；$R(0) = I_{3 \\times 3}$；$T = 5.0$；$\\Delta t = 0.005$。\n- 测试用例 2（球形陀螺，角动量恒定）：$(I_{1}, I_{2}, I_{3}) = (1.0, 1.0, 1.0)$；$M(0) = (0.0, 0.0, 2.0)$；$R(0) = I_{3 \\times 3}$；$T = 10.0$；$\\Delta t = 0.01$。\n- 测试用例 3（对称陀螺，非平凡进动）：$(I_{1}, I_{2}, I_{3}) = (1.0, 1.0, 0.5)$；$M(0) = (0.5, 0.5, 1.0)$；$R(0) = I_{3 \\times 3}$；$T = 8.0$；$\\Delta t = 0.008$。\n\n设 $\\varepsilon = 10^{-8}$ 为容差阈值。对每个测试用例，计算两个布尔值：\n- $b_{\\mathrm{orth}}$：若 $\\max_{k} \\| R(t_{k})^{\\top} R(t_{k}) - I_{3 \\times 3} \\|_{F} \\le \\varepsilon$ 则为真，否则为假。\n- $b_{\\det}$：若 $\\max_{k} |\\det(R(t_{k})) - 1| \\le \\varepsilon$ 则为真，否则为假。\n\n你的程序应生成单行输出，其中包含三个测试用例的结果，形式为方括号内的逗号分隔列表，顺序为 $[b_{\\mathrm{orth}}^{(1)}, b_{\\det}^{(1)}, b_{\\mathrm{orth}}^{(2)}, b_{\\det}^{(2)}, b_{\\mathrm{orth}}^{(3)}, b_{\\det}^{(3)}]$。\n\n所有物理单位必须一致：$T$ 和 $\\Delta t$ 以秒为单位；$\\omega$ 以弧度/秒为单位；$R$ 是无量纲的。最终的布尔值是无量纲的。不允许有其他输出。",
            "solution": "用户提示在几何力学领域提出了一个有效且适定的问题。该问题有科学依据，内部一致，并包含进行唯一、可验证求解所需的所有信息。问题要求对自由刚体的运动进行数值模拟（这是一个经典课题），并验证与保结构数值积分器相关的性质。\n\n自由刚体的运动可以在一个体固定坐标系中描述。系统的状态由体角动量 $M(t) \\in \\mathbb{R}^{3}$ 给出。作为哈密顿量 $H$ 的转动动能由下式给出：\n$$\nH(M) = \\frac{1}{2} M \\cdot \\omega = \\frac{1}{2} M^{\\top} I^{-1} M\n$$\n其中 $\\omega(t) \\in \\mathbb{R}^{3}$ 是体角速度，$I$ 是对角正定惯性张量，$I = \\mathrm{diag}(I_{1}, I_{2}, I_{3})$。角动量和角速度之间的关系是 $M = I \\omega$，或 $\\omega = I^{-1} M$。\n\n体角动量的动力学由自由刚体的欧拉方程所支配，该方程可以表示为向量形式：\n$$\n\\dot{M}(t) = M(t) \\times \\omega(t)\n$$\n代入 $\\omega = I^{-1} M$，我们得到李代数 $\\mathfrak{so}(3)$ 对偶上的李-泊松方程，该对偶通过标准向量叉积与 $\\mathbb{R}^{3}$ 等同。\n$$\n\\dot{M}(t) = M(t) \\times (I^{-1} M(t))\n$$\n这是一个关于 $M(t)$ 的一阶非线性常微分方程 (ODE)。给定一个初始条件 $M(0)$，其轨迹可以通过数值积分确定。我们将采用一个高质量的自适应求解器，例如 `scipy.integrate.solve_ivp` 中实现的龙格-库塔-费尔伯格方法 (RK45)，以在指定的均匀时间网格上获得 $M(t)$ 的精确解。\n\n物体在空间中的姿态由一个旋转矩阵 $R(t) \\in \\mathrm{SO}(3)$ 描述，该矩阵将向量从体固定坐标系映射到空间固定（惯性）坐标系。$R(t)$ 的演化由重构方程给出：\n$$\n\\dot{R}(t) = R(t) \\widehat{\\omega}(t)\n$$\n其中 $\\widehat{\\omega}(t)$ 是通过帽子映射与向量 $\\omega(t)$ 对应的斜对称矩阵，其定义为对于任何向量 $v \\in \\mathbb{R}^{3}$ 都有 $\\widehat{\\omega}v = \\omega \\times v$。对于 $\\omega = (\\omega_1, \\omega_2, \\omega_3)$，该矩阵为：\n$$\n\\widehat{\\omega} = \\begin{pmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{pmatrix}\n$$\n这种形式的矩阵构成了李代数 $\\mathfrak{so}(3)$。\n\n为了积分重构方程，我们被指示使用一种特定的保结构数值方法。用均匀步长 $\\Delta t$ 将时间离散化，即 $t_k = k \\Delta t$，旋转矩阵的更新规则由李-欧拉方法给出：\n$$\nR_{k+1} = R_k \\exp(\\Delta t \\, \\widehat{\\omega}(t_k))\n$$\n这里，$\\exp$ 表示矩阵指数。该方法的一个关键性质是它是保结构的。李代数 $\\mathfrak{so}(3)$ 中任何矩阵（即任何 $3 \\times 3$ 斜对称矩阵）的指数是李群 $\\mathrm{SO}(3)$ 中的一个矩阵（即一个 $3 \\times 3$ 特殊正交矩阵）。集合 $\\mathrm{SO}(3)$ 在矩阵乘法下构成一个群。因此，如果 $R_k \\in \\mathrm{SO}(3)$ 且 $\\exp(\\Delta t \\, \\widehat{\\omega}(t_k)) \\in \\mathrm{SO}(3)$，它们的乘积 $R_{k+1}$ 也必须在 $\\mathrm{SO}(3)$ 中。此性质确保，从解析上看， $R(t)$ 的数值解在每一步都保持在旋转矩阵流形上。因此，对于任何由该方法生成的 $R_k$，它都应满足 $\\mathrm{SO}(3)$ 矩阵的性质：\n1.  正交性: $R_k^{\\top} R_k = I_{3 \\times 3}$。\n2.  单位行列式: $\\det(R_k) = 1$。\n\n最后的任务是数值验证这两个性质。对于每个测试用例，我们将执行模拟并计算在整个时间网格上的以下最大偏差：\n-   正交性误差的最大弗罗贝尼乌斯范数：$\\max_{k} \\| R(t_{k})^{\\top} R(t_{k}) - I_{3 \\times 3} \\|_{F}$。\n-   行列式与1的最大绝对偏差：$\\max_{k} |\\det(R(t_{k})) - 1|$。\n\n然后，这些最大偏差将与一个小的容差 $\\varepsilon = 10^{-8}$ 进行比较。由于浮点表示和算术误差，计算出的偏差预计不为零，但会非常小，远在给定容差范围内。如果各自的偏差小于或等于 $\\varepsilon$，布尔值 $b_{\\mathrm{orth}}$ 和 $b_{\\det}$ 将被设置为真。\n\n每个测试用例的总体算法如下：\n1.  定义惯性张量 $I$、其逆 $I^{-1}$、初始动量 $M(0)$、初始姿态 $R(0)$、最终时间 $T$ 和时间步长 $\\Delta t$。\n2.  建立从 $0$ 到 $T$ 的均匀时间网格 $t_k$。\n3.  定义李-泊松常微分方程 $\\dot{M} = M \\times (I^{-1} M)$，并使用 `scipy.integrate.solve_ivp` 在时间网格上求解 $M(t_k)$。\n4.  计算角速度轨迹 $\\omega(t_k) = I^{-1} M(t_k)$。\n5.  用 $R(0)$ 初始化一个数组以存储 $R(t)$ 的历史记录。\n6.  使用矩阵指数积分器，根据 $R(t_k)$ 和 $\\omega(t_k)$ 迭代计算 $R(t_{k+1})$。将使用 `scipy.linalg.expm` 来完成此操作。\n7.  遍历计算出的 $R(t_k)$ 矩阵序列，计算每一步的正交性和行列式偏差，并跟踪最大值。\n8.  将最大偏差与 $\\varepsilon$ 进行比较，以确定最终的布尔值 $b_{\\mathrm{orth}}$ 和 $b_{\\det}$。\n此过程适用于所提供的所有三个测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define test cases as per the problem statement.\n    # Each tuple contains: (I1, I2, I3), M0, R0, T, dt\n    test_cases = [\n        (np.array([2.0, 1.5, 1.0]), np.array([0.9, 0.2, 0.7]), np.eye(3), 5.0, 0.005),\n        (np.array([1.0, 1.0, 1.0]), np.array([0.0, 0.0, 2.0]), np.eye(3), 10.0, 0.01),\n        (np.array([1.0, 1.0, 0.5]), np.array([0.5, 0.5, 1.0]), np.eye(3), 8.0, 0.008)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        I_diag, M0, R0, T, dt = case\n        results = run_simulation(I_diag, M0, R0, T, dt)\n        all_results.extend(results)\n\n    # Format and print the final output as a single line.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_simulation(I_diag, M0, R0, T, dt):\n    \"\"\"\n    Performs the rigid body simulation and verification for a single test case.\n\n    Args:\n        I_diag (np.ndarray): Principal moments of inertia (I1, I2, I3).\n        M0 (np.ndarray): Initial body angular momentum.\n        R0 (np.ndarray): Initial orientation matrix.\n        T (float): Final time for the simulation.\n        dt (float): Uniform time step.\n\n    Returns:\n        tuple[bool, bool]: A tuple containing b_orth and b_det.\n    \"\"\"\n    epsilon = 1e-8\n    I_inv_diag = 1.0 / I_diag\n\n    # Step 1: Define and solve the Lie-Poisson equation for M(t)\n    def lie_poisson_ode(t, M):\n        omega = I_inv_diag * M\n        return np.cross(M, omega)\n\n    # Create the uniform time grid\n    num_steps = int(round(T / dt))\n    t_grid = np.linspace(0, T, num_steps + 1)\n\n    sol = solve_ivp(lie_poisson_ode, (0, T), M0, t_eval=t_grid, rtol=1e-12, atol=1e-12)\n    M_hist = sol.y.T\n\n    # Step 2: Compute omega(t) from M(t)\n    omega_hist = M_hist * I_inv_diag\n\n    # Step 3: Integrate the reconstruction equation for R(t)\n    def hat_map(v):\n        return np.array([\n            [0, -v[2], v[1]],\n            [v[2], 0, -v[0]],\n            [-v[1], v[0], 0]\n        ])\n\n    R_hist = [R0]\n    R_current = R0.copy()\n    for k in range(num_steps):\n        omega_k = omega_hist[k]\n        omega_hat_k = hat_map(omega_k)\n        \n        # Use matrix exponential for structure-preserving integration\n        R_next = R_current @ expm(dt * omega_hat_k)\n        R_hist.append(R_next)\n        R_current = R_next\n\n    # Step 4: Verify orthogonality and determinant properties\n    max_orth_dev = 0.0\n    max_det_dev = 0.0\n    I_3x3 = np.eye(3)\n\n    for Rk in R_hist:\n        # Orthogonality check\n        orth_error_matrix = Rk.T @ Rk - I_3x3\n        orth_dev = np.linalg.norm(orth_error_matrix, 'fro')\n        if orth_dev > max_orth_dev:\n            max_orth_dev = orth_dev\n\n        # Determinant check\n        det_dev = abs(np.linalg.det(Rk) - 1.0)\n        if det_dev > max_det_dev:\n            max_det_dev = det_dev\n\n    # Step 5: Compare against tolerance to get boolean results\n    b_orth = max_orth_dev = epsilon\n    b_det = max_det_dev = epsilon\n\n    return b_orth, b_det\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}