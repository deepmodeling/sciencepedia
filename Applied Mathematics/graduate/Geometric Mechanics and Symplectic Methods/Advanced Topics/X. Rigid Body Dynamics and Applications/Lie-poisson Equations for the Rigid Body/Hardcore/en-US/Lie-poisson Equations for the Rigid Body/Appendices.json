{
    "hands_on_practices": [
        {
            "introduction": "The first step in appreciating any new formalism is to connect it back to familiar territory. This exercise provides that crucial link for the Lie-Poisson description of rigid body motion. Here, you will directly apply the definition of the Lie-Poisson bracket to the rigid body Hamiltonian to derive the time evolution for a component of the angular momentum, demonstrating how this abstract geometric structure precisely recovers the classical Euler's equations. ",
            "id": "647224",
            "problem": "The dynamics of a free rigid body can be described in a Hamiltonian framework on the dual of the Lie algebra of rotations, $\\mathfrak{so}(3)^*$. We can identify this dual space with $\\mathbb{R}^3$, where the coordinates $(L_1, L_2, L_3)$ represent the components of the angular momentum vector in a frame fixed to the body (the body frame).\n\nThe Poisson structure on the space of smooth functions $F, G \\in C^\\infty(\\mathfrak{so}(3)^*)$ is given by the Lie-Poisson bracket:\n$$\n\\{F, G\\}(\\mathbf{L}) = - \\sum_{i,j,k=1}^3 \\epsilon_{ijk} L_k \\frac{\\partial F}{\\partial L_i} \\frac{\\partial G}{\\partial L_j}\n$$\nwhere $\\epsilon_{ijk}$ is the Levi-Civita symbol. This bracket is determined by the fundamental bracket relations $\\{L_i, L_j\\} = -\\epsilon_{ijk} L_k$.\n\nThe Hamiltonian for a free rigid body, expressed in terms of the body-frame angular momentum components, is given by its kinetic energy:\n$$\nH(L_1, L_2, L_3) = \\frac{1}{2}\\left(\\frac{L_1^2}{I_1} + \\frac{L_2^2}{I_2} + \\frac{L_3^2}{I_3}\\right)\n$$\nwhere $I_1, I_2, I_3$ are the principal moments of inertia of the body.\n\nThe time evolution of any observable $F$ is governed by Hamilton's equation, $\\frac{dF}{dt} = \\{F, H\\}$. Using the provided definitions, derive the explicit expression for the time evolution of the first component of the angular momentum, which corresponds to calculating the Lie-Poisson bracket $\\{L_1, H\\}$.",
            "solution": "We use the Lie-Poisson bracket \n$$\\{F,G\\}(\\mathbf L)=-\\sum_{i,j,k}\\epsilon_{ijk}L_k\\frac{\\partial F}{\\partial L_i}\\frac{\\partial G}{\\partial L_j},$$ \nand Hamilton's equation $\\dot F=\\{F,H\\}$. Thus\n$$\\{L_1,H\\}=-\\sum_{j,k=1}^3\\epsilon_{1jk}L_k\\frac{\\partial H}{\\partial L_j}.$$\nSince \n$$\\frac{\\partial H}{\\partial L_j}=\\frac{L_j}{I_j},\\quad j=1,2,3,$$ \nonly $j=2,3$ contribute. We have\n$$\\{L_1,H\\}=-\\bigl(\\epsilon_{123}L_3\\frac{L_2}{I_2}+\\epsilon_{132}L_2\\frac{L_3}{I_3}\\bigr)\n=-\\Bigl(L_3\\frac{L_2}{I_2}-L_2\\frac{L_3}{I_3}\\Bigr)\n=L_2L_3\\Bigl(\\frac1{I_3}-\\frac1{I_2}\\Bigr).$$\nNoting $\\frac1{I_3}-\\frac1{I_2}=\\frac{I_2-I_3}{I_2I_3}$ gives the final result.",
            "answer": "$$\\boxed{\\frac{I_2-I_3}{I_2I_3}L_2L_3}$$"
        },
        {
            "introduction": "The power of a theoretical framework is often best revealed when applied to special, symmetric cases. In this practice, you will analyze the spherical top, a rigid body with three equal principal moments of inertia, $I_1 = I_2 = I_3$. By applying the Lie-Poisson equations of motion, you will discover why the dynamics become remarkably simple, leading to a constant angular momentum vector in the body frame and providing clear physical insight rooted in the system's geometric structure. ",
            "id": "3776190",
            "problem": "Consider the free rigid body in body coordinates modeled as a Hamiltonian system on the dual of the Lie algebra of the Special Orthogonal Group in three dimensions (SO(3)), denoted $\\mathfrak{so}(3)^{\\ast} \\simeq \\mathbb{R}^{3}$. The Lie-Poisson bracket on $\\mathfrak{so}(3)^{\\ast}$ is defined by\n$$\n\\{F,H\\}(M) \\;=\\; -\\, M \\cdot \\big(\\nabla F(M) \\times \\nabla H(M)\\big),\n$$\nfor sufficiently smooth functions $F,H:\\mathbb{R}^{3}\\to\\mathbb{R}$, where $\\cdot$ is the Euclidean inner product and $\\times$ is the vector cross product. The Hamiltonian for the free rigid body with inertia tensor $\\mathbb{I} = \\operatorname{diag}(I_{1},I_{2},I_{3})$ is the kinetic energy expressed in body variables,\n$$\nH(M) \\;=\\; \\tfrac{1}{2}\\, \\Omega \\cdot M \\;=\\; \\tfrac{1}{2}\\, M \\cdot \\mathbb{I}^{-1} M,\n$$\nwhere $M \\in \\mathbb{R}^{3}$ is the body angular momentum and $\\Omega = \\mathbb{I}^{-1}M$ is the body angular velocity. The equations of motion are given by the Lie-Poisson dynamics $\\dot{F}(M)=\\{F,H\\}(M)$ for all observables $F$.\n\nAnalyze the special case of the spherical top with $I_{1}=I_{2}=I_{3}=I>0$. Starting from the Lie-Poisson structure and the kinetic energy Hamiltonian above, derive the reduced equations of motion for $M(t)$, compute the Hamiltonian flow on $\\mathfrak{so}(3)^{\\ast}$, and interpret the resulting motion in terms of attitude dynamics on $\\mathrm{SO}(3)$ and the polhode curve in the body frame. In particular, characterize the uniformity of the rotation and explain why the polhode is trivial.\n\nProvide your final answer as the uniform body angular velocity vector expressed solely in terms of the initial body angular momentum $M_{0}$ and the scalar inertia $I$. Report only the final analytic expression for this vector; do not include any intermediate steps or an equality sign in your final answer. No rounding is required, and no units should be included in the final answer.",
            "solution": "The state of the system is the body angular momentum vector $M \\in \\mathfrak{so}(3)^{\\ast} \\simeq \\mathbb{R}^{3}$. The dynamics of any observable $F(M)$ is governed by the Lie-Poisson equation $\\dot{F} = \\{F,H\\}$, where the bracket is given by $\\{F,H\\}(M) = - M \\cdot (\\nabla F(M) \\times \\nabla H(M))$. We wish to find the specific equations of motion for the components of the angular momentum vector itself. Let $M = (M_1, M_2, M_3)$. We choose the observables to be the coordinate functions $F_i(M) = M_i$ for $i=1,2,3$. The gradient of such a function is simply the standard basis vector in $\\mathbb{R}^{3}$, i.e., $\\nabla F_i(M) = e_i$.\n\nThe Hamiltonian for the free rigid body is $H(M) = \\frac{1}{2} M \\cdot \\mathbb{I}^{-1} M$. Its gradient with respect to $M$ is\n$$\n\\nabla H(M) = \\mathbb{I}^{-1} M\n$$\nBy definition, this is the body angular velocity vector, $\\Omega = \\mathbb{I}^{-1} M$.\n\nSubstituting these gradients into the Lie-Poisson bracket formula to find the time evolution of the $i$-th component of angular momentum, $\\dot{M}_i = \\{M_i, H\\}$, we get:\n$$\n\\dot{M}_i(M) = - M \\cdot ( \\nabla M_i \\times \\nabla H ) = - M \\cdot ( e_i \\times \\Omega )\n$$\nUsing the scalar triple product identity $a \\cdot (b \\times c) = c \\cdot (a \\times b)$, we can rewrite this as:\n$$\n\\dot{M}_i = - \\Omega \\cdot ( M \\times e_i )\n$$\nUsing the identity again, $c \\cdot (a \\times b) = b \\cdot (c \\times a)$:\n$$\n\\dot{M}_i = e_i \\cdot (\\Omega \\times M)\n$$\nThis equation states that the $i$-th component of the vector $\\dot{M}$ is equal to the $i$-th component of the vector $\\Omega \\times M$. Therefore, we can write the full vector equation of motion as:\n$$\n\\dot{M} = \\Omega \\times M\n$$\nThis is precisely Euler's equation for the motion of a free rigid body in the body-fixed frame.\n\nWe now specialize to the case of a spherical top, for which the principal moments of inertia are equal: $I_1 = I_2 = I_3 = I$. The inertia tensor is a scalar multiple of the identity matrix, $\\mathbb{I} = I \\cdot \\mathbf{1}$, where $\\mathbf{1}$ is the $3 \\times 3$ identity matrix. Its inverse is $\\mathbb{I}^{-1} = \\frac{1}{I} \\mathbf{1}$.\n\nThe relationship between the body angular velocity $\\Omega$ and the body angular momentum $M$ becomes:\n$$\n\\Omega = \\mathbb{I}^{-1} M = \\frac{1}{I} M\n$$\nThis shows that for a spherical top, the angular velocity and angular momentum vectors are always parallel.\n\nSubstituting this expression for $\\Omega$ into Euler's equation, we find the reduced equations of motion for $M(t)$:\n$$\n\\dot{M} = \\left(\\frac{1}{I} M\\right) \\times M = \\frac{1}{I} (M \\times M)\n$$\nSince the cross product of any vector with itself is the zero vector, $M \\times M = 0$, the equation of motion simplifies to:\n$$\n\\dot{M}(t) = 0\n$$\nIntegrating this trivial differential equation with respect to time gives the Hamiltonian flow on $\\mathfrak{so}(3)^{\\ast}$:\n$$\nM(t) = M_0\n$$\nwhere $M_0 = M(0)$ is the constant initial body angular momentum vector. This means that for a spherical top, the angular momentum vector is fixed in the body frame.\n\nConsequently, the body angular velocity vector $\\Omega(t)$ is also constant in the body frame:\n$$\n\\Omega(t) = \\frac{1}{I} M(t) = \\frac{1}{I} M_0\n$$\nLet us denote this constant vector as $\\Omega_0 = \\frac{1}{I} M_0$. The rotation is uniform as the angular velocity vector $\\Omega(t) = \\Omega_0$ is constant. The motion in the body frame is trivial. In the space frame, the orientation matrix $R(t)$ evolves according to the kinematic equation $\\dot{R} = R \\hat{\\Omega}$, where $\\hat{\\Omega}$ is the skew-symmetric matrix corresponding to $\\Omega$. Since $\\Omega = \\Omega_0$ is constant, this equation describes a steady rotation about the fixed body axis $\\Omega_0$ with constant angular speed $|\\Omega_0|$. The spatial angular momentum $m = R M$ is conserved, as $\\dot{m} = \\dot{R} M_0 + R \\dot{M}_0 = (R \\hat{\\Omega}_0) M_0 + 0 = R(\\Omega_0 \\times M_0) = R((\\frac{1}{I}M_0)\\times M_0) = 0$. This implies that the axis of rotation is also fixed in space.\n\nThe polhode is the curve traced by the tip of the angular velocity vector $\\Omega$ on the surface of the inertia ellipsoid, defined by the conservation of energy $2H = \\Omega \\cdot \\mathbb{I}\\Omega = \\text{constant}$. For the spherical top, this equation becomes $I(\\Omega_1^2+\\Omega_2^2+\\Omega_3^2) = I |\\Omega|^2 = \\text{constant}$. The polhode is also constrained by the conservation of the magnitude of angular momentum, $|M|^2 = \\text{constant}$, which for the spherical top implies $I^2 |\\Omega|^2 = \\text{constant}$. Both conservation laws thus constrain $\\Omega$ to lie on a sphere of constant radius. However, our direct integration of the equations of motion showed a stronger result: $\\Omega(t) = \\Omega_0$ is a constant vector. The \"curve\" traced by the tip of a constant vector is a single point. Therefore, the polhode is trivial; it degenerates to a single fixed point in the body frame.\n\nThe uniform body angular velocity vector, expressed in terms of the initial body angular momentum $M_0$ and the scalar inertia $I$, is the constant vector $\\frac{M_0}{I}$.",
            "answer": "$$\\boxed{\\frac{M_{0}}{I}}$$"
        },
        {
            "introduction": "Beyond analytical solutions, the true test of a mechanical framework in the modern era lies in its computational performance. This practice dives into the field of geometric integration, a key application of the Lie-Poisson formulation. You will implement and compare a standard numerical integrator with a structure-preserving Lie-Poisson method, observing firsthand the superior long-term energy conservation of the geometric approach, a critical advantage for accurate physical simulations. ",
            "id": "3776216",
            "problem": "Consider the free rigid body formulated as a Lie-Poisson system on the dual of the special orthogonal group in three dimensions, denoted $\\mathfrak{so}(3)^{\\ast}$. Let the body angular momentum be $M=(M_{1},M_{2},M_{3})\\in\\mathbb{R}^{3}$, and assume the inertia tensor is diagonal with principal moments of inertia $I=(I_{1},I_{2},I_{3})$ where each $I_{k}>0$. The Hamiltonian is $H(M)=\\frac{1}{2}\\,M\\cdot I^{-1}M=\\frac{1}{2}\\left(\\frac{M_{1}^{2}}{I_{1}}+\\frac{M_{2}^{2}}{I_{2}}+\\frac{M_{3}^{2}}{I_{3}}\\right)$, and the Lie-Poisson bracket on $\\mathfrak{so}(3)^{\\ast}$ is defined by $\\{F,G\\}(M)=-M\\cdot\\left(\\nabla F(M)\\times\\nabla G(M)\\right)$ for smooth functions $F,G$. The induced Hamiltonian dynamics are the rigid body equations\n$$\n\\dot{M}=\\{M,H\\}(M)=M\\times\\Omega,\\quad\\text{with}\\quad\\Omega=I^{-1}M,\n$$\nwhere $\\times$ is the cross product and $\\Omega$ is the angular velocity in body coordinates.\n\nYour task is to write a complete, runnable program that:\n- Implements two time-integration methods for $\\dot{M}=M\\times I^{-1}M$:\n  1. A simple explicit Euler method consistent with the above evolution equation.\n  2. A Lie-Poisson preserving method constructed by splitting the Hamiltonian into coordinate components $H_{k}(M)=\\frac{1}{2}\\frac{M_{k}^{2}}{I_{k}}$ for $k\\in\\{1,2,3\\}$, integrating each subflow exactly, and composing them via a Strang splitting. The exact subflows are rigid rotations generated by the constant angular velocity associated to each $H_{k}$; angles must be computed and applied in radians.\n- For each method and each test case, evolves the system over a specified time horizon and quantifies energy drift by computing:\n  1. The final absolute energy error, $\\left|H(M(T))-H(M(0))\\right|$, where $T$ is the final time.\n  2. The maximum absolute energy deviation, $\\max_{0\\leq t\\leq T}\\left|H(M(t))-H(M(0))\\right|$.\n- Uses dimensionless parameters and returns all requested quantities as floating-point numbers.\n\nDesign the program to run the following test suite. For each case, use the given inertia $I$, initial momentum $M(0)$, time step $\\Delta t$, and number of steps $N$; the total integration time is $T=N\\,\\Delta t$. All rotation angles must be handled in radians.\n\n- Test case $1$: $I=(1.0,2.0,3.0)$, $M(0)=(0.5,0.4,0.3)$, $\\Delta t=0.005$, $N=40000$.\n- Test case $2$: $I=(1.0,1.0,1.0)$, $M(0)=(0.3,-0.2,0.4)$, $\\Delta t=0.010$, $N=30000$.\n- Test case $3$: $I=(1.5,2.5,3.5)$, $M(0)=(1.0,0.0,0.0)$, $\\Delta t=0.200$, $N=1000$.\n- Test case $4$: $I=(0.8,1.1,1.3)$, $M(0)=(0.7,0.6,0.5)$, $\\Delta t=0.050$, $N=8000$.\n\nOutput specification:\n- For each test case, produce a list with four floating-point numbers in the order $[\\text{final\\_error\\_Euler},\\text{max\\_deviation\\_Euler},\\text{final\\_error\\_LP},\\text{max\\_deviation\\_LP}]$, where $\\text{LP}$ denotes the Lie-Poisson preserving splitting method.\n- Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists, with no spaces, enclosed in square brackets. For example, an output for two cases should look like $[[a_{1},b_{1},c_{1},d_{1}],[a_{2},b_{2},c_{2},d_{2}]]$.\n\nAll quantities are dimensionless, and all angles must be treated in radians. The answers for each test case must be floats. The program must be self-contained, produce the single-line output exactly in the specified format, and require no user input or external files.",
            "solution": "### Solution Derivation\n\nThe dynamics of the free rigid body are governed by the Euler equations:\n$$ \\dot{M} = M \\times \\Omega, \\quad \\text{where} \\quad \\Omega=I^{-1}M = \\left(\\frac{M_1}{I_1}, \\frac{M_2}{I_2}, \\frac{M_3}{I_3}\\right) $$\n\n**Method 1: Explicit Euler Method**\nThis is a standard first-order numerical integration scheme. Given a state $M^n$ at time $t_n$, the state $M^{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is approximated by:\n$$ M^{n+1} = M^n + \\Delta t \\cdot \\dot{M}^n = M^n + \\Delta t \\cdot (M^n \\times (I^{-1}M^n)) $$\nThis method is simple to implement but is not designed to preserve the geometric structures of the system. In particular, it does not conserve the Hamiltonian $H(M)$ (energy) or the Casimir function $C(M) = \\|M\\|^2$ (the squared norm of the angular momentum). The energy error is expected to grow over time, a phenomenon known as secular drift.\n\n**Method 2: Lie-Poisson Splitting Method**\nThis is a geometric integrator, designed to preserve certain qualitative features of the exact flow. The method is constructed by splitting the Hamiltonian and composing the exact flows of the simpler sub-systems.\n\n1.  **Hamiltonian Splitting**: The Hamiltonian is additively split into three components, one for each principal axis:\n    $$ H(M) = H_1(M) + H_2(M) + H_3(M), \\quad \\text{where} \\quad H_k(M) = \\frac{1}{2}\\frac{M_k^2}{I_k} $$\n\n2.  **Sub-System Dynamics**: For each sub-Hamiltonian $H_k$, the dynamics are given by the Lie-Poisson bracket:\n    $$ \\dot{M} = \\{M, H_k\\}(M) = M \\times \\nabla_M H_k(M) $$\n    The gradient of each $H_k$ is simple:\n    $$ \\nabla_M H_1 = \\frac{M_1}{I_1}e_1, \\quad \\nabla_M H_2 = \\frac{M_2}{I_2}e_2, \\quad \\nabla_M H_3 = \\frac{M_3}{I_3}e_3 $$\n    where $e_k$ is the standard basis vector. The equation of motion for the $k$-th sub-system is:\n    $$ \\dot{M} = M \\times \\left(\\frac{M_k}{I_k}e_k\\right) $$\n    For this sub-system, the component $M_k$ is constant, since $\\dot{M}_k = e_k \\cdot \\dot{M} = e_k \\cdot (M \\times (\\frac{M_k}{I_k}e_k)) = 0$. Consequently, the term $\\frac{M_k}{I_k}e_k$ is a constant vector. The equation describes a pure rotation of the vector $M$ about the fixed axis $e_k$ with a constant angular velocity $\\frac{M_k}{I_k}$.\n\n3.  **Exact Sub-Flows**: The exact solution (flow) for the $k$-th sub-system over a time interval $\\Delta t$, denoted $\\phi_{H_k}^{\\Delta t}$, is a rotation of the momentum vector $M$ around the axis $e_k$ by an angle $\\alpha_k = \\frac{M_k}{I_k}\\Delta t$. This can be implemented using standard rotation matrices. For example, for $k=1$, the rotation is:\n    $$ \\phi_{H_1}^{\\Delta t}(M) = R_1\\left(\\frac{M_1}{I_1}\\Delta t\\right) M, \\quad \\text{where} \\quad R_1(\\alpha) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{pmatrix} $$\n    Similar rotation matrices $R_2(\\alpha)$ and $R_3(\\alpha)$ apply for the other sub-systems.\n\n4.  **Strang Splitting Composition**: To approximate the flow of the full Hamiltonian $H$, we use a second-order symmetric composition, known as Strang splitting. A single step of the integrator from $t_n$ to $t_n+\\Delta t$ is given by:\n    $$ M^{n+1} = \\left( \\phi_{H_1}^{\\Delta t/2} \\circ \\phi_{H_2}^{\\Delta t/2} \\circ \\phi_{H_3}^{\\Delta t} \\circ \\phi_{H_2}^{\\Delta t/2} \\circ \\phi_{H_1}^{\\Delta t/2} \\right) M^n $$\n    This means we apply a sequence of five rotations. It is crucial that the angle for each rotation is calculated using the momentum vector component from the *result* of the previous rotation. Because each step is a rotation, the norm $\\|M\\|$ is exactly conserved by this numerical method. Consequently, the Casimir invariant is preserved, and the integrator is Lie-Poisson. The Hamiltonian $H$ is not generally a Casimir, so it will not be exactly conserved, but the error is expected to remain bounded over long integration times, showing no secular drift.\n\nFor the special test cases where the exact solution is a fixed point (Case 2: spherical top, Case 3: rotation about a principal axis), both methods are expected to yield zero or machine-precision errors. The spherical top is particularly interesting, as the total Hamiltonian flow is trivial ($\\dot{M}=0$), but the individual split flows are not. The perfect cancellation in the Lie-Poisson method for this case is a testament to its geometric properties, as it exactly conserves the Hamiltonian $H \\propto \\|M\\|^2$ which is built from the conserved quantity $\\|M\\|$.\n\nThe program will implement these two methods, run the simulations for the given test cases, and calculate the specified error metrics to demonstrate these properties.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the rigid body dynamics problem.\n    It runs simulations for predefined test cases using two different\n    numerical integrators and prints the energy error metrics.\n    \"\"\"\n\n    test_cases = [\n        # I, M(0), dt, N\n        ((1.0, 2.0, 3.0), (0.5, 0.4, 0.3), 0.005, 40000),\n        ((1.0, 1.0, 1.0), (0.3, -0.2, 0.4), 0.010, 30000),\n        ((1.5, 2.5, 3.5), (1.0, 0.0, 0.0), 0.200, 1000),\n        ((0.8, 1.1, 1.3), (0.7, 0.6, 0.5), 0.050, 8000),\n    ]\n\n    results = []\n    for I_tuple, M0_tuple, dt, N in test_cases:\n        I = np.array(I_tuple, dtype=float)\n        M0 = np.array(M0_tuple, dtype=float)\n        I_inv = 1.0 / I\n\n        def hamiltonian(M, inv_I):\n            \"\"\"Computes the Hamiltonian (energy) of the rigid body.\"\"\"\n            return 0.5 * np.sum(M**2 * inv_I)\n\n        # --- 1. Explicit Euler Method ---\n        M_e = M0.copy()\n        H0 = hamiltonian(M_e, I_inv)\n        max_deviation_euler = 0.0\n        \n        for _ in range(N):\n            M_dot = np.cross(M_e, M_e * I_inv)\n            M_e += dt * M_dot\n            current_H = hamiltonian(M_e, I_inv)\n            deviation = abs(current_H - H0)\n            if deviation > max_deviation_euler:\n                max_deviation_euler = deviation\n        \n        final_error_euler = abs(hamiltonian(M_e, I_inv) - H0)\n\n        # --- 2. Lie-Poisson Splitting Method ---\n        def lie_poisson_step(M_current, inv_I, step_t):\n            \"\"\"Performs one step of the Lie-Poisson Strang splitting integrator.\"\"\"\n            M = M_current.copy()\n            \n            # phi_H1(dt/2)\n            angle1 = M[0] * inv_I[0] * step_t / 2.0\n            c1, s1 = np.cos(angle1), np.sin(angle1)\n            R1 = np.array([[1.0, 0.0, 0.0], [0.0, c1, -s1], [0.0, s1, c1]])\n            M = R1 @ M\n\n            # phi_H2(dt/2)\n            angle2 = M[1] * inv_I[1] * step_t / 2.0\n            c2, s2 = np.cos(angle2), np.sin(angle2)\n            R2 = np.array([[c2, 0.0, s2], [0.0, 1.0, 0.0], [-s2, 0.0, c2]])\n            M = R2 @ M\n\n            # phi_H3(dt)\n            angle3 = M[2] * inv_I[2] * step_t\n            c3, s3 = np.cos(angle3), np.sin(angle3)\n            R3 = np.array([[c3, -s3, 0.0], [s3, c3, 0.0], [0.0, 0.0, 1.0]])\n            M = R3 @ M\n\n            # phi_H2(dt/2)\n            angle2_rev = M[1] * inv_I[1] * step_t / 2.0\n            c2_rev, s2_rev = np.cos(angle2_rev), np.sin(angle2_rev)\n            R2_rev = np.array([[c2_rev, 0.0, s2_rev], [0.0, 1.0, 0.0], [-s2_rev, 0.0, c2_rev]])\n            M = R2_rev @ M\n\n            # phi_H1(dt/2)\n            angle1_rev = M[0] * inv_I[0] * step_t / 2.0\n            c1_rev, s1_rev = np.cos(angle1_rev), np.sin(angle1_rev)\n            R1_rev = np.array([[1.0, 0.0, 0.0], [0.0, c1_rev, -s1_rev], [0.0, s1_rev, c1_rev]])\n            M = R1_rev @ M\n\n            return M\n\n        M_lp = M0.copy()\n        # H0 is the same as for Euler\n        max_deviation_lp = 0.0\n        \n        for _ in range(N):\n            M_lp = lie_poisson_step(M_lp, I_inv, dt)\n            current_H = hamiltonian(M_lp, I_inv)\n            deviation = abs(current_H - H0)\n            if deviation > max_deviation_lp:\n                max_deviation_lp = deviation\n        \n        final_error_lp = abs(hamiltonian(M_lp, I_inv) - H0)\n        \n        # Collect results for the current test case\n        case_results = [\n            final_error_euler, \n            max_deviation_euler,\n            final_error_lp,\n            max_deviation_lp\n        ]\n        results.append(case_results)\n\n    # Format the output string to match the specification \"[ [r1,r2,...],[...],... ]\"\n    # with no spaces.\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_string = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}