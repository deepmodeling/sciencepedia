{
    "hands_on_practices": [
        {
            "introduction": "The full Euler equations for a rigid body can be challenging to solve analytically due to their nonlinear nature. A crucial step in understanding complex dynamics is to first master simplified, exactly solvable models. This practice explores the foundational case of a spherical rotor, where the inertia tensor is isotropic. By working through this problem , you will see how this symmetry causes the gyroscopic term to vanish, leading to a straightforward solution and offering a clear illustration of the work-energy principle in a rotating system.",
            "id": "3773474",
            "problem": "Consider a free rigid body whose attitude is described by a curve $R(t)$ in the Special Orthogonal group (SO(3)), with body angular velocity $\\omega(t)\\in\\mathbb{R}^{3}$ defined by the kinematic relation $\\dot{R}(t)=R(t)\\,\\widehat{\\omega}(t)$, where $\\widehat{\\omega}$ is the skew-symmetric matrix associated to $\\omega$ via the isomorphism $\\mathbb{R}^{3}\\cong\\mathfrak{so}(3)$. The body angular momentum is $M(t)\\in\\mathbb{R}^{3}$ and is related to $\\omega$ by the inertia operator $I:\\mathbb{R}^{3}\\to\\mathbb{R}^{3}$ via $M=I\\,\\omega$. Suppose the body is spherical with $I=\\lambda\\,\\mathbf{1}$ for some constant $\\lambda0$, and is subjected to a constant body torque $\\tau\\in\\mathbb{R}^{3}$ (that is, $\\tau$ is constant in body coordinates). Let the initial conditions be $R(0)=R_{0}\\in\\mathrm{SO}(3)$ and $M(0)=M_{0}\\in\\mathbb{R}^{3}$.\n\nStarting from the Lagrange-d'Alembert principle for a left-invariant kinetic energy on $\\mathrm{SO}(3)$ with work term due to a body torque, and using the identification $\\mathfrak{so}(3)\\cong\\mathbb{R}^{3}$ with the vector cross product, derive the body-fixed evolution equation for $M(t)$ under a body torque, and then solve it explicitly in the spherical case. In your analysis, explain why the coadjoint term vanishes for a spherical inertia, characterize the resulting $\\omega(t)$, describe how the kinetic energy evolves in time, and discuss the structure of $R(t)$ both in general and in the special case when $M_{0}$ and $\\tau$ are colinear.\n\nYour final answer must be the explicit closed-form expression for $M(t)$ in terms of $M_{0}$, $\\tau$, and $t$. No numerical evaluation is required, and no units should be reported in the final answer.",
            "solution": "This problem requires the derivation and solution of the equations of motion for a spherical rigid body subject to a constant body-fixed torque, starting from the Lagrange-d'Alembert principle within the framework of geometric mechanics.\n\nFirst, we validate the problem statement.\nThe givens are:\n- The configuration space is the Special Orthogonal group, $R(t) \\in \\mathrm{SO}(3)$.\n- The body angular velocity is $\\omega(t) \\in \\mathbb{R}^3$.\n- The kinematic equation is $\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t)$, where $\\widehat{\\cdot}: \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ is the hat map defining the Lie algebra isomorphism.\n- The body angular momentum is $M(t) \\in \\mathbb{R}^3$, related to $\\omega(t)$ by the inertia operator $I$ via $M=I\\,\\omega$.\n- The body is spherical, so $I = \\lambda \\mathbf{1}$ for a scalar $\\lambda  0$.\n- There is a constant body-fixed torque $\\tau \\in \\mathbb{R}^3$.\n- The initial conditions are $R(0)=R_0$ and $M(0)=M_0$.\n\nThe problem is scientifically grounded in classical and geometric mechanics, is well-posed as an initial value problem, and is stated using objective, formal language. It is self-contained and consistent. Therefore, the problem is valid.\n\nWe begin by applying the Lagrange-d'Alembert principle. The system's Lagrangian is its kinetic energy, as there is no potential energy. For a rigid body, the kinetic energy is a left-invariant quadratic form on the tangent bundle $T\\mathrm{SO}(3)$. In body coordinates, this is given by:\n$$\nT = \\frac{1}{2} \\langle \\omega, I\\omega \\rangle\n$$\nHere, $\\langle \\cdot, \\cdot \\rangle$ denotes the standard inner product on $\\mathbb{R}^3$. The Lagrange-d'Alembert principle for a system with external forces is:\n$$\n\\delta \\int_{t_1}^{t_2} T(\\omega) \\, dt + \\int_{t_1}^{t_2} \\mathcal{W}(\\delta q) \\, dt = 0\n$$\nwhere $\\mathcal{W}$ is the virtual work done by non-conservative forces. A variation of the trajectory $R(t)$ can be expressed in the body frame by a curve $\\eta(t) \\in \\mathbb{R}^3$ such that the infinitesimal displacement is $\\delta R = R(t)\\widehat{\\eta}(t)$. The virtual work done by the body-fixed torque $\\tau$ for such a virtual displacement is $\\mathcal{W} = \\langle \\tau, \\eta \\rangle$. Note that $\\eta$ represents the virtual angular velocity of the displacement. The principle is thus:\n$$\n\\int_{t_1}^{t_2} \\left[ \\delta T(\\omega) + \\langle \\tau, \\eta \\rangle \\right] dt = 0\n$$\nThe variation of the kinetic energy is:\n$$\n\\delta T = \\frac{1}{2} \\delta \\langle \\omega, I\\omega \\rangle = \\langle \\delta\\omega, I\\omega \\rangle = \\langle M, \\delta\\omega \\rangle\n$$\nThe variation of the angular velocity, $\\delta\\omega$, is related to the variation parameter $\\eta$ by the formula for variations on Lie groups (the Euler-Poincaré variation formula):\n$$\n\\delta\\omega = \\dot{\\eta} + \\omega \\times \\eta\n$$\nSubstituting these into the principle gives:\n$$\n\\int_{t_1}^{t_2} \\left[ \\langle M, \\dot{\\eta} + \\omega \\times \\eta \\rangle + \\langle \\tau, \\eta \\rangle \\right] dt = 0\n$$\nWe integrate the term $\\langle M, \\dot{\\eta} \\rangle$ by parts:\n$$\n\\int_{t_1}^{t_2} \\langle M, \\dot{\\eta} \\rangle dt = \\left[ \\langle M, \\eta \\rangle \\right]_{t_1}^{t_2} - \\int_{t_1}^{t_2} \\langle \\dot{M}, \\eta \\rangle dt\n$$\nThe boundary term vanishes because variations $\\eta$ are taken to be zero at the endpoints, i.e., $\\eta(t_1) = \\eta(t_2) = 0$. Using the cyclic property of the scalar triple product, $\\langle M, \\omega \\times \\eta \\rangle = \\langle \\eta, M \\times \\omega \\rangle$. The integral becomes:\n$$\n\\int_{t_1}^{t_2} \\left[ - \\langle \\dot{M}, \\eta \\rangle + \\langle M \\times \\omega, \\eta \\rangle + \\langle \\tau, \\eta \\rangle \\right] dt = 0\n$$\n$$\n\\int_{t_1}^{t_2} \\langle -\\dot{M} + M \\times \\omega + \\tau, \\eta \\rangle dt = 0\n$$\nSince this must hold for any arbitrary smooth variation $\\eta(t)$ that vanishes at the endpoints, the expression inside the inner product must be zero. This yields the Euler-Poincaré equation for a rigid body with an external body torque:\n$$\n\\dot{M} = M \\times \\omega + \\tau\n$$\nThis equation, often written as $\\dot{M} + \\omega \\times M = \\tau$, is the general evolution equation for the body angular momentum $M$. The term $M \\times \\omega$ comes from the non-commutativity of rotations and is related to the coadjoint action of the Lie group on the dual of its Lie algebra.\n\nNow we specialize to the given spherical body. The inertia operator is $I = \\lambda \\mathbf{1}$, where $\\lambda  0$ is a constant. The relationship between momentum $M$ and angular velocity $\\omega$ becomes:\n$$\nM = I\\omega = \\lambda\\mathbf{1}\\omega = \\lambda\\omega\n$$\nThis implies that $\\omega = \\frac{1}{\\lambda}M$. For a spherical body, the body angular momentum and angular velocity are always parallel.\n\nWe substitute this relationship into the evolution equation:\n$$\n\\dot{M} = M \\times \\left(\\frac{1}{\\lambda}M\\right) + \\tau\n$$\nThe cross product of any vector with a scalar multiple of itself is zero: $M \\times (\\frac{1}{\\lambda}M) = \\frac{1}{\\lambda}(M \\times M) = 0$. The coadjoint term $M\\times \\omega$ vanishes precisely because of this collinearity, which is a unique feature of the spherical inertia tensor. Physically, a spherical body has no preferred axes of rotation, so there are no internal gyroscopic torques generated by the body's motion.\n\nThe evolution equation for the spherical body thus simplifies dramatically to:\n$$\n\\dot{M}(t) = \\tau\n$$\nSince the body torque $\\tau$ is given as constant, this is a simple first-order vector ordinary differential equation. We can integrate it directly with respect to time from $t=0$ to a general time $t$:\n$$\n\\int_{0}^{t} \\dot{M}(s) ds = \\int_{0}^{t} \\tau ds\n$$\n$$\nM(t) - M(0) = \\tau t\n$$\nUsing the initial condition $M(0) = M_0$, we find the explicit solution for the body angular momentum:\n$$\nM(t) = M_0 + t\\tau\n$$\n\nWe can now characterize $\\omega(t)$, the kinetic energy $T(t)$, and the attitude $R(t)$.\nThe angular velocity is $\\omega(t) = \\frac{1}{\\lambda}M(t)$, so:\n$$\n\\omega(t) = \\frac{1}{\\lambda}(M_0 + t\\tau)\n$$\nThe body angular velocity vector $\\omega(t)$ starts at $\\omega_0 = M_0/\\lambda$ and increases linearly with time in the constant direction of $\\tau$. The tip of the $\\omega(t)$ vector traces a straight line in the body frame.\n\nThe kinetic energy is $T = \\frac{1}{2}\\langle \\omega, M \\rangle = \\frac{1}{2\\lambda}\\|M\\|^2$. The evolution of the kinetic energy is:\n$$\nT(t) = \\frac{1}{2\\lambda} \\|M_0 + t\\tau\\|^2 = \\frac{1}{2\\lambda} \\langle M_0 + t\\tau, M_0 + t\\tau \\rangle\n$$\n$$\nT(t) = \\frac{1}{2\\lambda} \\left( \\|M_0\\|^2 + 2t\\langle M_0, \\tau \\rangle + t^2\\|\\tau\\|^2 \\right)\n$$\nThe kinetic energy is a quadratic function of time. Its rate of change is $\\dot{T}(t) = \\frac{1}{\\lambda} (\\langle M_0, \\tau \\rangle + t\\|\\tau\\|^2)$. This is equal to the power input from the torque, $P(t) = \\langle \\tau, \\omega(t) \\rangle = \\langle \\tau, \\frac{1}{\\lambda}(M_0 + t\\tau) \\rangle = \\frac{1}{\\lambda}(\\langle \\tau, M_0 \\rangle + t\\|\\tau\\|^2)$, which confirms the work-energy theorem.\n\nFinally, we discuss the structure of the attitude matrix $R(t)$. It is the solution to the kinematic initial value problem:\n$$\n\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t), \\quad R(0) = R_0\n$$\nIn the general case, the matrix generator $\\widehat{\\omega}(t) = \\frac{1}{\\lambda}(\\widehat{M_0} + t\\widehat{\\tau})$ is time-dependent. The solution cannot be written as a simple matrix exponential because the matrices $\\widehat{\\omega}(t_1)$ and $\\widehat{\\omega}(t_2)$ do not commute for different times $t_1, t_2$, unless $M_0$ and $\\tau$ are collinear. The commutator is $[\\widehat{\\omega}(t_1), \\widehat{\\omega}(t_2)] = \\widehat{\\omega(t_1)} \\times \\widehat{\\omega(t_2)} = \\frac{1}{\\lambda^2}(t_1-t_2)\\widehat{M_0 \\times \\tau} \\neq 0$. The formal solution involves a time-ordered exponential, which does not generally have a simple closed form.\n\nIn the special case where $M_0$ and $\\tau$ are collinear (i.e., they are parallel or one is zero), the vector $M_0 \\times \\tau = 0$, so the commutator $[\\widehat{\\omega}(t_1), \\widehat{\\omega}(t_2)]$ is zero. In this case, the matrix exponential can be used:\n$$\nR(t) = R_0 \\exp\\left( \\int_0^t \\widehat{\\omega}(s) ds \\right)\n$$\nThe integrated angular velocity is:\n$$\n\\theta(t) = \\int_0^t \\omega(s) ds = \\int_0^t \\frac{1}{\\lambda}(M_0 + s\\tau) ds = \\frac{1}{\\lambda}\\left( tM_0 + \\frac{1}{2}t^2\\tau \\right)\n$$\nSince $M_0$ and $\\tau$ are collinear, $\\theta(t)$ is a vector that always points along their common direction. The solution is $R(t) = R_0 \\exp(\\widehat{\\theta(t)})$, which represents a rotation from the initial orientation $R_0$ about a fixed axis in the body frame (the direction of $\\tau$), with the angle of rotation being $\\|\\theta(t)\\|$, a quadratic function of time.\n\nThe problem asks for the explicit closed-form expression for $M(t)$. As derived above, this is a linear function of time.",
            "answer": "$$\n\\boxed{M(t) = M_{0} + t\\tau}\n$$"
        },
        {
            "introduction": "While analytical solutions provide deep insight, most real-world rigid body problems require numerical integration. This practice guides you through the essential process of translating the body-fixed Euler equations into a computational algorithm . By implementing and comparing both the component-wise and the compact vector forms of the equations, you will not only see the dynamics unfold in simulation but also gain practical experience in computational mechanics and appreciate the nuances of numerical implementation.",
            "id": "3773475",
            "problem": "Consider a freely rotating rigid body observed in its body frame, where the angular velocity is denoted by $\\boldsymbol{\\omega}(t)$ and the body-frame angular momentum is $\\mathbf{L}(t)=\\mathbf{I}\\boldsymbol{\\omega}(t)$. Here $\\mathbf{I}$ is the inertia tensor in the body frame, taken to be diagonal with respect to the principal axes as $\\mathbf{I}=\\mathrm{diag}(I_{1},I_{2},I_{3})$, and $\\boldsymbol{\\tau}(t)$ is the externally applied torque in the body frame. Starting from the balance of angular momentum and the kinematics of rotating frames, derive the body-fixed equations of motion for $\\boldsymbol{\\omega}(t)$ in two equivalent forms: (i) a componentwise set of ordinary differential equations (ODEs) aligned with the principal axes, and (ii) a compact vector form involving a cross product. Then implement both forms and numerically integrate them over time for the numerical test suite below. Quantitatively compare the two implementations by computing, for each test case, the maximum absolute componentwise difference between the angular velocities produced by the two integrations over the entire time interval.\n\nYour derivation must begin from fundamental laws and definitions only, such as the balance of angular momentum in the spatial frame and the transformation law for time derivatives between spatial and body frames. Do not assume or quote the target componentwise or cross product formulas; derive them from first principles.\n\nNumerical details and units:\n- Inertia parameters $I_{1}$, $I_{2}$, $I_{3}$ are given in $\\mathrm{kg}\\cdot\\mathrm{m}^{2}$.\n- Torque $\\boldsymbol{\\tau}(t)$ is in $\\mathrm{N}\\cdot\\mathrm{m}$.\n- Angular velocity $\\boldsymbol{\\omega}(t)$ is in $\\mathrm{rad/s}$.\n- Time $t$ is in $\\mathrm{s}$, and angles are in radians.\n\nIntegration requirements:\n- Use a standard numerical ODE integrator to compute $\\boldsymbol{\\omega}(t)$ for both formulations over the specified intervals with identical time sampling.\n- For each test case, sample the solution at $1001$ uniformly spaced time points on the closed interval $[0,T]$.\n- For each test case, compute the scalar quantity\n$$\n\\Delta = \\max_{0\\leq k \\leq 1000} \\max_{j\\in\\{1,2,3\\}} \\left|\\omega^{(\\mathrm{comp})}_{j}(t_{k}) - \\omega^{(\\mathrm{vec})}_{j}(t_{k})\\right|,\n$$\nwhere $\\boldsymbol{\\omega}^{(\\mathrm{comp})}(t)$ is the solution obtained from the componentwise ODEs and $\\boldsymbol{\\omega}^{(\\mathrm{vec})}(t)$ is the solution obtained from the vector cross product formulation. Express $\\Delta$ in $\\mathrm{rad/s}$, rounded to six significant figures.\n\nTest suite:\n- Case A (general anisotropic inertia, free rigid body):\n  - $\\mathbf{I}=\\mathrm{diag}(2.0,1.5,1.0)\\ \\mathrm{kg}\\cdot\\mathrm{m}^{2}$,\n  - $\\boldsymbol{\\tau}(t)=\\mathbf{0}\\ \\mathrm{N}\\cdot\\mathrm{m}$,\n  - $\\boldsymbol{\\omega}(0)=\\begin{bmatrix}2.0\\\\0.8\\\\-1.2\\end{bmatrix}\\ \\mathrm{rad/s}$,\n  - $T=2.5\\ \\mathrm{s}$.\n- Case B (constant torque about the third axis):\n  - $\\mathbf{I}=\\mathrm{diag}(3.0,2.0,1.0)\\ \\mathrm{kg}\\cdot\\mathrm{m}^{2}$,\n  - $\\boldsymbol{\\tau}(t)=\\begin{bmatrix}0.0\\\\0.0\\\\0.2\\end{bmatrix}\\ \\mathrm{N}\\cdot\\mathrm{m}$,\n  - $\\boldsymbol{\\omega}(0)=\\begin{bmatrix}0.1\\\\-0.2\\\\0.0\\end{bmatrix}\\ \\mathrm{rad/s}$,\n  - $T=5.0\\ \\mathrm{s}$.\n- Case C (near-symmetric in the first two axes, sinusoidal torque about the first axis):\n  - $\\mathbf{I}=\\mathrm{diag}(1.0,1.01,2.0)\\ \\mathrm{kg}\\cdot\\mathrm{m}^{2}$,\n  - $\\boldsymbol{\\tau}(t)=\\begin{bmatrix}0.5\\sin(2\\pi t)\\\\0.0\\\\0.0\\end{bmatrix}\\ \\mathrm{N}\\cdot\\mathrm{m}$,\n  - $\\boldsymbol{\\omega}(0)=\\begin{bmatrix}0.0\\\\1.0\\\\0.0\\end{bmatrix}\\ \\mathrm{rad/s}$,\n  - $T=3.0\\ \\mathrm{s}$.\n- Case D (isotropic inertia, free rigid body):\n  - $\\mathbf{I}=\\mathrm{diag}(1.5,1.5,1.5)\\ \\mathrm{kg}\\cdot\\mathrm{m}^{2}$,\n  - $\\boldsymbol{\\tau}(t)=\\mathbf{0}\\ \\mathrm{N}\\cdot\\mathrm{m}$,\n  - $\\boldsymbol{\\omega}(0)=\\begin{bmatrix}0.5\\\\-0.5\\\\1.0\\end{bmatrix}\\ \\mathrm{rad/s}$,\n  - $T=4.0\\ \\mathrm{s}$.\n\nProgram output specification:\n- Your program should produce a single line of output containing the results for Cases A–D as a comma-separated list enclosed in square brackets, with each entry equal to the value of $\\Delta$ for that case in $\\mathrm{rad/s}$, rounded to six significant figures (for example, $\\left[1.23456\\mathrm{e}{-7},3.21000\\mathrm{e}{-8},\\dots\\right]$). The output must have the format: $\\left[\\Delta_{A},\\Delta_{B},\\Delta_{C},\\Delta_{D}\\right]$ with no additional text.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of classical rigid body dynamics, is well-posed with sufficient information for a unique solution, and is expressed in objective, formal language. The task involves a standard derivation of the Euler equations of motion followed by a numerical implementation and comparison, which is a standard exercise in computational mechanics.\n\n### Part 1: Derivation of the Body-Fixed Euler Equations\n\nOur derivation begins from two fundamental principles: the law of conservation of angular momentum as observed in an inertial frame, and the kinematic relationship for the time derivative of a vector between a rotating and an inertial frame.\n\nLet $S$ denote an inertial reference frame (the \"space\" frame) and $B$ denote a non-inertial reference frame fixed to the rotating body (the \"body\" frame). Let $\\mathbf{A}$ be an arbitrary vector. The time derivative of $\\mathbf{A}$ as observed in the space frame, $(\\frac{d\\mathbf{A}}{dt})_S$, is related to its time derivative as observed in the body frame, $(\\frac{d\\mathbf{A}}{dt})_B$, by the transport theorem:\n$$\n\\left(\\frac{d\\mathbf{A}}{dt}\\right)_S = \\left(\\frac{d\\mathbf{A}}{dt}\\right)_B + \\boldsymbol{\\omega} \\times \\mathbf{A}\n$$\nHere, $\\boldsymbol{\\omega}$ is the angular velocity vector of the body frame $B$ relative to the space frame $S$. For the remainder of this derivation, all vectors ($\\boldsymbol{\\omega}$, angular momentum $\\mathbf{L}$, torque $\\boldsymbol{\\tau}$) are expressed by their components in the body frame $B$, unless explicitly noted otherwise. The term $(\\frac{d\\mathbf{A}}{dt})_B$ represents the rate of change of the components of the vector $\\mathbf{A}$ in the body frame's basis, which we will denote with a dot, e.g., $\\dot{\\mathbf{A}}$.\n\nThe fundamental law of rotational dynamics (Newton's second law for rotation) states that the time rate of change of the angular momentum vector, $\\mathbf{L}_S$, in the inertial frame is equal to the net external torque, $\\boldsymbol{\\tau}_S$, applied to the body, as observed in the same inertial frame.\n$$\n\\left(\\frac{d\\mathbf{L}}{dt}\\right)_S = \\boldsymbol{\\tau}_S\n$$\nWe now apply the transport theorem to the angular momentum vector $\\mathbf{L}$:\n$$\n\\left(\\frac{d\\mathbf{L}}{dt}\\right)_S = \\dot{\\mathbf{L}} + \\boldsymbol{\\omega} \\times \\mathbf{L}\n$$\nThe torque vector $\\boldsymbol{\\tau}$ transforms between frames like any other vector. If $R(t)$ is the rotation matrix from the body frame to the space frame, then $\\boldsymbol{\\tau}_S(t) = R(t)\\boldsymbol{\\tau}(t)$. Equating the two expressions for $(\\frac{d\\mathbf{L}}{dt})_S$ and expressing the torque in body frame components yields:\n$$\n\\dot{\\mathbf{L}} + \\boldsymbol{\\omega} \\times \\mathbf{L} = \\boldsymbol{\\tau}\n$$\nThis is the general form of Euler's equations of motion in the body frame.\n\nThe angular momentum $\\mathbf{L}$ in the body frame is related to the angular velocity $\\boldsymbol{\\omega}$ by the inertia tensor $\\mathbf{I}$ (also in the body frame): $\\mathbf{L} = \\mathbf{I}\\boldsymbol{\\omega}$. Since the body frame is fixed to the body, the inertia tensor $\\mathbf{I}$ is constant in this frame. Therefore, its time derivative is zero, and we have $\\dot{\\mathbf{L}} = \\frac{d}{dt}(\\mathbf{I}\\boldsymbol{\\omega}) = \\mathbf{I}\\frac{d\\boldsymbol{\\omega}}{dt} = \\mathbf{I}\\dot{\\boldsymbol{\\omega}}$.\n\nSubstituting this into the general form gives:\n$$\n\\mathbf{I}\\dot{\\boldsymbol{\\omega}} + \\boldsymbol{\\omega} \\times (\\mathbf{I}\\boldsymbol{\\omega}) = \\boldsymbol{\\tau}\n$$\nThis is the desired **compact vector form (ii)** of the Euler equations. To obtain an ODE for $\\dot{\\boldsymbol{\\omega}}$, we can rearrange it as $\\dot{\\boldsymbol{\\omega}} = \\mathbf{I}^{-1} \\left( \\boldsymbol{\\tau} - \\boldsymbol{\\omega} \\times (\\mathbf{I}\\boldsymbol{\\omega}) \\right)$.\n\nTo derive the **componentwise form (i)**, we align the body frame's axes with the principal axes of inertia. In this basis, the inertia tensor $\\mathbf{I}$ is diagonal:\n$$\n\\mathbf{I} = \\begin{pmatrix} I_1  0  0 \\\\ 0  I_2  0 \\\\ 0  0  I_3 \\end{pmatrix}\n$$\nLet $\\boldsymbol{\\omega} = (\\omega_1, \\omega_2, \\omega_3)^T$ and $\\boldsymbol{\\tau} = (\\tau_1, \\tau_2, \\tau_3)^T$. We compute the terms in the vector equation.\nFirst, $\\mathbf{I}\\boldsymbol{\\omega} = (I_1\\omega_1, I_2\\omega_2, I_3\\omega_3)^T$.\nNext, the cross product term:\n$$\n\\boldsymbol{\\omega} \\times (\\mathbf{I}\\boldsymbol{\\omega}) = \\begin{pmatrix} \\omega_1 \\\\ \\omega_2 \\\\ \\omega_3 \\end{pmatrix} \\times \\begin{pmatrix} I_1\\omega_1 \\\\ I_2\\omega_2 \\\\ I_3\\omega_3 \\end{pmatrix} = \\begin{pmatrix} \\omega_2(I_3\\omega_3) - \\omega_3(I_2\\omega_2) \\\\ \\omega_3(I_1\\omega_1) - \\omega_1(I_3\\omega_3) \\\\ \\omega_1(I_2\\omega_2) - \\omega_2(I_1\\omega_1) \\end{pmatrix} = \\begin{pmatrix} (I_3 - I_2)\\omega_2\\omega_3 \\\\ (I_1 - I_3)\\omega_1\\omega_3 \\\\ (I_2 - I_1)\\omega_1\\omega_2 \\end{pmatrix}\n$$\nThe term $\\mathbf{I}\\dot{\\boldsymbol{\\omega}} = (I_1\\dot{\\omega}_1, I_2\\dot{\\omega}_2, I_3\\dot{\\omega}_3)^T$.\nSubstituting these into the vector equation $\\mathbf{I}\\dot{\\boldsymbol{\\omega}} + \\boldsymbol{\\omega} \\times (\\mathbf{I}\\boldsymbol{\\omega}) = \\boldsymbol{\\tau}$, we obtain the three component equations:\n$$\n\\begin{cases}\nI_1 \\dot{\\omega}_1 + (I_3 - I_2)\\omega_2\\omega_3 = \\tau_1 \\\\\nI_2 \\dot{\\omega}_2 + (I_1 - I_3)\\omega_1\\omega_3 = \\tau_2 \\\\\nI_3 \\dot{\\omega}_3 + (I_2 - I_1)\\omega_1\\omega_2 = \\tau_3\n\\end{cases}\n$$\nIsolating the time derivatives $\\dot{\\omega}_j$ gives the explicit system of first-order ODEs:\n$$\n\\begin{cases}\n\\dot{\\omega}_1 = \\frac{1}{I_1}\\left(\\tau_1 + (I_2 - I_3)\\omega_2\\omega_3\\right) \\\\\n\\dot{\\omega}_2 = \\frac{1}{I_2}\\left(\\tau_2 + (I_3 - I_1)\\omega_1\\omega_3\\right) \\\\\n\\dot{\\omega}_3 = \\frac{1}{I_3}\\left(\\tau_3 + (I_1 - I_2)\\omega_1\\omega_2\\right)\n\\end{cases}\n$$\nThis is the desired componentwise form (i).\n\n### Part 2: Numerical Implementation Plan\n\nThe numerical part of the problem requires solving the initial value problem for $\\dot{\\boldsymbol{\\omega}} = f(t, \\boldsymbol{\\omega})$ for each of the four test cases using both formulations.\n\n1.  **ODE Solvers:** We will implement two distinct functions for the right-hand side (RHS) of the ODE system $\\dot{\\boldsymbol{\\omega}} = f(t, \\boldsymbol{\\omega})$, corresponding to the two derived forms.\n    *   `euler_comp_rhs(t, w, I, tau_func)`: This function will implement the componentwise equations directly, taking the state vector `w`$=(\\omega_1, \\omega_2, \\omega_3)$, inertia tensor `I`$=(I_1, I_2, I_3)$, and a function `tau_func(t)` for the torque as input.\n    *   `euler_vec_rhs(t, w, I, tau_func)`: This function will implement the compact vector form $\\dot{\\boldsymbol{\\omega}} = \\mathbf{I}^{-1} \\left( \\boldsymbol{\\tau} - \\boldsymbol{\\omega} \\times (\\mathbf{I}\\boldsymbol{\\omega}) \\right)$. It will use NumPy's vector and matrix operations (`np.cross`, element-wise multiplication and division) for a concise implementation.\n\n2.  **Integration:** For each test case, we will use the `scipy.integrate.solve_ivp` function, which is a robust, adaptive-step ODE solver.\n    *   We will call `solve_ivp` twice, once for each RHS function (`euler_comp_rhs` and `euler_vec_rhs`), but with identical initial conditions $\\boldsymbol{\\omega}(0)$, time interval $[0, T]$, and integration tolerances.\n    *   To minimize numerical errors stemming from the integrator itself and to isolate the floating-point differences between the two RHS implementations, we will use strict relative and absolute tolerances (e.g., `rtol=1e-13`, `atol=1e-13`).\n    *   The solution will be evaluated at $1001$ uniformly spaced time points $t_k$ in $[0, T]$ using the `t_eval` argument of `solve_ivp`.\n\n3.  **Comparison:** After obtaining the two solution trajectories, $\\boldsymbol{\\omega}^{(\\mathrm{comp})}(t_k)$ and $\\boldsymbol{\\omega}^{(\\mathrm{vec})}(t_k)$, we will compute the required discrepancy metric $\\Delta$:\n    $$\n    \\Delta = \\max_{0\\leq k \\leq 1000} \\max_{j\\in\\{1,2,3\\}} \\left|\\omega^{(\\mathrm{comp})}_{j}(t_{k}) - \\omega^{(\\mathrm{vec})}_{j}(t_{k})\\right|\n    $$\n    This is equivalent to finding the maximum absolute value in the element-wise difference of the two solution arrays.\n\n4.  **Output:** The calculated $\\Delta$ for each of the four cases will be formatted to six significant figures in scientific notation and printed as a comma-separated list enclosed in square brackets.\n\nThis procedure will be encapsulated in a Python script adhering to the specified environment and output format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef euler_comp_rhs(t, w, I, tau_func):\n    \"\"\"\n    Computes the RHS of the Euler equations in component-wise form.\n    dot(w) = f(t, w)\n    \"\"\"\n    I1, I2, I3 = I\n    w1, w2, w3 = w\n    tau = tau_func(t)\n    tau1, tau2, tau3 = tau\n\n    dw1_dt = (tau1 + (I2 - I3) * w2 * w3) / I1\n    dw2_dt = (tau2 + (I3 - I1) * w1 * w3) / I2\n    dw3_dt = (tau3 + (I1 - I2) * w1 * w2) / I3\n\n    return np.array([dw1_dt, dw2_dt, dw3_dt])\n\ndef euler_vec_rhs(t, w, I_vec, tau_func):\n    \"\"\"\n    Computes the RHS of the Euler equations in vector form.\n    dot(w) = I_inv * (tau - w x (I*w))\n    \"\"\"\n    tau = tau_func(t)\n    # Since I is diagonal, I*w is element-wise multiplication\n    Iw = I_vec * w\n    # I_inv is also diagonal, so I_inv * vector is element-wise division\n    dw_dt = (tau - np.cross(w, Iw)) / I_vec\n    return dw_dt\n\ndef format_to_6_sf(n):\n    \"\"\"\n    Formats a number to 6 significant figures in scientific notation.\n    e.g., 1.234567e-8 - 1.23457e-08.\n    The precision for 'e' format is (number of significant figures - 1).\n    \"\"\"\n    if n == 0.0:\n        return \"0.00000e+00\"\n    return f\"{n:.5e}\"\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run simulations, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"I\": np.array([2.0, 1.5, 1.0]),\n            \"tau_func\": lambda t: np.zeros(3),\n            \"w0\": np.array([2.0, 0.8, -1.2]),\n            \"T\": 2.5,\n        },\n        {\n            \"name\": \"B\",\n            \"I\": np.array([3.0, 2.0, 1.0]),\n            \"tau_func\": lambda t: np.array([0.0, 0.0, 0.2]),\n            \"w0\": np.array([0.1, -0.2, 0.0]),\n            \"T\": 5.0,\n        },\n        {\n            \"name\": \"C\",\n            \"I\": np.array([1.0, 1.01, 2.0]),\n            \"tau_func\": lambda t: np.array([0.5 * np.sin(2.0 * np.pi * t), 0.0, 0.0]),\n            \"w0\": np.array([0.0, 1.0, 0.0]),\n            \"T\": 3.0,\n        },\n        {\n            \"name\": \"D\",\n            \"I\": np.array([1.5, 1.5, 1.5]),\n            \"tau_func\": lambda t: np.zeros(3),\n            \"w0\": np.array([0.5, -0.5, 1.0]),\n            \"T\": 4.0,\n        },\n    ]\n\n    results = []\n    num_points = 1001\n    # Use tight tolerances to minimize integrator error and isolate\n    # floating-point differences between the two RHS function implementations.\n    rtol = 1e-13\n    atol = 1e-13\n\n    for case in test_cases:\n        I = case['I']\n        tau_func = case['tau_func']\n        w0 = case['w0']\n        T = case['T']\n        \n        t_span = [0, T]\n        t_eval = np.linspace(0, T, num_points)\n\n        # Integrate component-wise formulation\n        sol_comp = solve_ivp(\n            euler_comp_rhs, t_span, w0, args=(I, tau_func),\n            t_eval=t_eval, rtol=rtol, atol=atol, method='RK45'\n        )\n        omega_comp = sol_comp.y\n        \n        # Integrate vector formulation\n        sol_vec = solve_ivp(\n            euler_vec_rhs, t_span, w0, args=(I, tau_func),\n            t_eval=t_eval, rtol=rtol, atol=atol, method='RK45'\n        )\n        omega_vec = sol_vec.y\n\n        # Calculate the maximum absolute componentwise difference\n        delta = np.max(np.abs(omega_comp - omega_vec))\n        \n        results.append(delta)\n\n    # Format results as specified\n    formatted_results = [format_to_6_sf(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Solving the Euler equations gives us the angular velocity $\\omega(t)$, but this is only half the story; determining the body's orientation $R(t)$ requires integrating the kinematic equations on the Lie group $\\mathrm{SO}(3)$. Standard numerical methods fail to preserve the rotational structure, leading to unphysical results. This advanced practice introduces you to the world of geometric integration by having you implement a powerful, structure-preserving algorithm known as a commutator-free Magnus integrator , a vital tool for accurate attitude reconstruction in fields from aerospace engineering to robotics.",
            "id": "3773466",
            "problem": "Implement a commutator-free Magnus integrator of order four for attitude reconstruction on the Special Orthogonal group in three dimensions, denoted by $\\mathrm{SO}(3)$, and quantify its effectiveness when the body angular velocity $\\omega(t)$ contains high-frequency components. The starting point is the attitude kinematics written as a right-invariant ordinary differential equation (ODE) on the Lie group:\n$$\n\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t), \\quad R(0) = I_{3},\n$$\nwhere $R(t) \\in \\mathrm{SO}(3)$ is the rotation matrix, $I_{3}$ is the identity matrix, and $\\widehat{\\cdot} : \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ denotes the standard “hat” isomorphism from vectors to the Lie algebra of skew-symmetric matrices given by\n$$\n\\widehat{\\omega} = \\begin{bmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{bmatrix}.\n$$\nThe task is to:\n- Derive and implement a commutator-free Magnus method of order four on $\\mathrm{SO}(3)$ for this reconstruction problem using the two-nodes Gauss-Legendre scheme. Over a step of size $h$ from $t_k$ to $t_{k+1}=t_k+h$, define\n$$\nc_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}, \\quad c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6},\n$$\n$$\n\\omega_1 = \\omega(t_k + c_1 h), \\quad \\omega_2 = \\omega(t_k + c_2 h),\n$$\nand the two algebra increments as vectors (using linearity of the hat map):\n$$\nv_1 = \\frac{h}{4}\\,(\\omega_1 + \\omega_2) + \\frac{\\sqrt{3}\\,h}{12}\\,(\\omega_1 - \\omega_2), \\quad\nv_2 = \\frac{h}{4}\\,(\\omega_1 + \\omega_2) - \\frac{\\sqrt{3}\\,h}{12}\\,(\\omega_1 - \\omega_2).\n$$\nThen advance with\n$$\nR_{k+1} = R_k \\,\\exp\\!\\big(\\widehat{v}_1\\big)\\,\\exp\\!\\big(\\widehat{v}_2\\big),\n$$\nwhere $\\exp$ is the matrix exponential on $\\mathfrak{so}(3)$ implemented via the Rodrigues formula:\n$$\n\\exp\\!\\big(\\widehat{v}\\big) = I_3 + \\frac{\\sin\\theta}{\\theta}\\,\\widehat{v} + \\frac{1-\\cos\\theta}{\\theta^2}\\,\\widehat{v}^2, \\quad \\theta = \\|v\\|_2.\n$$\n- Use as a reference solution a high-accuracy numerical integration of the matrix ODE with stringent tolerances, and with a maximum step selected relative to the dominant frequency, to approximate the exact flow $R(t)$ at the final time $T$.\n- Quantify the method’s effectiveness for high-frequency $\\omega(t)$ by the final attitude error angle (in radians) between the commutator-free Magnus solution and the reference solution. For $R_{\\mathrm{cf}}$ and $R_{\\mathrm{ref}}$ at time $T$, compute\n$$\nE = R_{\\mathrm{cf}}^{\\top} R_{\\mathrm{ref}}, \\qquad\n\\theta_{\\mathrm{err}} = \\arccos\\!\\left(\\frac{\\mathrm{trace}(E)-1}{2}\\right),\n$$\nwhere the argument of $\\arccos$ must be numerically clamped to the interval $[-1,1]$.\n- Implement $\\omega(t)$ as a smooth, bounded function with tunable high-frequency content:\n$$\n\\omega(t) = \\begin{bmatrix}\n\\alpha \\sin(\\Omega t) \\\\\n\\beta \\cos(\\Omega t) \\\\\n\\gamma + \\delta \\sin(2\\Omega t)\n\\end{bmatrix}.\n$$\n\nImplementation requirements:\n- Use the Rodrigues formula for the exponential map on $\\mathfrak{so}(3)$ with numerically stable series for small $\\theta$.\n- The reference integrator must use stringent tolerances and a maximum step that is a small fraction of the period $2\\pi/\\Omega$ when $\\Omega gt; 0$. If $\\Omega = 0$, set the maximum step relative to the main step size $h$.\n\nAngle unit requirement:\n- All angles must be expressed in radians.\n\nTest suite:\nFor each parameter tuple $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h)$, integrate from $t=0$ to $t=T$ with the commutator-free Magnus method and compute the final-angle error $\\theta_{\\mathrm{err}}$ in radians against the reference solution. Use the following five cases:\n- Case A (moderate frequency): $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 10.0, 1.0, 0.01)$.\n- Case B (higher frequency, same step): $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 50.0, 1.0, 0.01)$.\n- Case C (high frequency, same step, shorter horizon): $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 200.0, 0.5, 0.01)$.\n- Case D (constant angular velocity): $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.05)$.\n- Case E (high frequency, reduced step): $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 200.0, 0.5, 0.002)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order A through E, where each entry is the final-angle error $\\theta_{\\mathrm{err}}$ in radians rounded to eight decimals. For example, an output with three cases should look like $[0.00012345,0.01234567,0.00123456]$. No additional text should be printed.",
            "solution": "The user wants to implement and validate a fourth-order commutator-free Magnus integrator for attitude dynamics on the special orthogonal group $\\mathrm{SO}(3)$.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The right-invariant attitude kinematics ODE is $\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t)$.\n- **Initial Condition**: $R(0) = I_{3}$, the $3 \\times 3$ identity matrix.\n- **State and Group**: The attitude matrix $R(t)$ belongs to the Special Orthogonal group $\\mathrm{SO}(3)$.\n- **Lie Algebra Isomorphism**: The \"hat\" map $\\widehat{\\cdot} : \\mathbb{R}^3 \\to \\mathfrak{so}(3)$ is defined as $\\widehat{\\omega} = \\begin{bmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{bmatrix}$.\n- **Integrator Scheme**: A commutator-free Magnus method of order four.\n    - **Quadrature Nodes**: $c_1 = \\frac{1}{2} - \\frac{\\sqrt{3}}{6}$, $c_2 = \\frac{1}{2} + \\frac{\\sqrt{3}}{6}$.\n    - **Velocity Samples**: $\\omega_1 = \\omega(t_k + c_1 h)$, $\\omega_2 = \\omega(t_k + c_2 h)$.\n    - **Algebra Increments**:\n        $v_1 = \\frac{h}{4}\\,(\\omega_1 + \\omega_2) + \\frac{\\sqrt{3}\\,h}{12}\\,(\\omega_1 - \\omega_2)$\n        $v_2 = \\frac{h}{4}\\,(\\omega_1 + \\omega_2) - \\frac{\\sqrt{3}\\,h}{12}\\,(\\omega_1 - \\omega_2)$\n    - **Update Rule**: $R_{k+1} = R_k \\,\\exp\\!\\big(\\widehat{v}_1\\big)\\,\\exp\\!\\big(\\widehat{v}_2\\big)$.\n- **Exponential Map**: The matrix exponential from $\\mathfrak{so}(3)$ to $\\mathrm{SO}(3)$ is given by the Rodrigues formula: $\\exp\\!\\big(\\widehat{v}\\big) = I_3 + \\frac{\\sin\\theta}{\\theta}\\,\\widehat{v} + \\frac{1-\\cos\\theta}{\\theta^2}\\,\\widehat{v}^2$, where $\\theta = \\|v\\|_2$.\n- **Error Metric**: The final attitude error angle is $\\theta_{\\mathrm{err}} = \\arccos\\!\\left(\\frac{\\mathrm{trace}(R_{\\mathrm{cf}}^{\\top} R_{\\mathrm{ref}})-1}{2}\\right)$, with numerical clamping of the `arccos` argument.\n- **Angular Velocity Function**: $\\omega(t) = [\\alpha \\sin(\\Omega t), \\beta \\cos(\\Omega t), \\gamma + \\delta \\sin(2\\Omega t)]^\\top$.\n- **Reference Solution**: To be computed via high-accuracy numerical integration with stringent tolerances and a small maximum step size relative to the characteristic period of $\\omega(t)$.\n- **Test Cases**:\n    - A: $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 10.0, 1.0, 0.01)$\n    - B: $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 50.0, 1.0, 0.01)$\n    - C: $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 200.0, 0.5, 0.01)$\n    - D: $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.05)$\n    - E: $(\\alpha,\\beta,\\gamma,\\delta,\\Omega,T,h) = (2.0, 1.0, 0.2, 0.5, 200.0, 0.5, 0.002)$\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Groundedness**: The problem is firmly rooted in the field of geometric numerical integration, a sub-discipline of computational science and applied mathematics. The equations for attitude kinematics, the properties of the Lie group $\\mathrm{SO}(3)$ and its Lie algebra $\\mathfrak{so}(3)$, Magnus expansions, and commutator-free methods are standard and well-established theories.\n- **Well-Posedness**: The problem describes an initial value problem for an ordinary differential equation on a manifold. Given a smooth, bounded angular velocity function $\\omega(t)$, a unique solution $R(t)$ exists for all time. The task to implement a specific numerical algorithm and quantify its error against a high-accuracy reference solution is a well-defined problem in numerical analysis.\n- **Objectivity**: The problem is stated using precise mathematical terminology and definitions. All parameters and test cases are specified unambiguously.\n\nThe problem does not exhibit any of the invalidity flaws:\n1.  **Scientific Unsoundness**: The physics and mathematics are correct.\n2.  **Non-Formalizable/Irrelevant**: The problem is a direct and formal application of geometric integration theory to the body-fixed Euler-kinematic equations.\n3.  **Incomplete/Contradictory**: All necessary formulas and parameters are provided and are mutually consistent.\n4.  **Unrealistic/Infeasible**: The setup is for a numerical experiment, and all parameters are well within feasible computational limits.\n5.  **Ill-Posed/Poorly Structured**: The problem is clearly structured, and a unique, meaningful numerical result is expected.\n6.  **Trivial/Tautological**: The task requires implementing a non-trivial numerical method, including the careful handling of the exponential map and comparison against a reference, which is a substantive exercise. The chosen integrator is known to be exact for constant velocity fields, which is tested in Case D, but it is not trivial for time-varying fields.\n7.  **Outside Scientific Verifiability**: The results are computationally deterministic and can be independently verified.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete and reasoned solution will be provided.\n\n### Principle-Based Design\nThe solution to the attitude kinematics equation $\\dot{R}(t) = R(t)\\,\\widehat{\\omega}(t)$ must respect the geometric structure of the configuration space, which is the Lie group $\\mathrm{SO}(3)$. This means the numerical solution $R_k$ at any step should remain a rotation matrix, i.e., $R_k^\\top R_k = I_3$ and $\\det(R_k) = 1$. Conventional numerical methods, such as Runge-Kutta schemes applied to the $9$ components of $R$, fail to preserve this structure, leading to drift from $\\mathrm{SO}(3)$ and accumulation of errors.\n\nGeometric integrators are designed to overcome this deficiency. The Magnus series provides a way to express the exact solution over a step $h$ as $R(t_k+h) = R(t_k)\\exp(\\Omega_k)$, where $\\Omega_k \\in \\mathfrak{so}(3)$ is an infinite series of integrals of nested commutators of $\\widehat{\\omega}(t)$. A practical approach is to truncate this series. However, calculating commutators is computationally expensive.\n\nThe problem specifies a *commutator-free* Magnus integrator. These methods approximate the Magnus series $\\Omega_k$ to a certain order by using a weighted sum of Lie algebra elements evaluated at specific quadrature points within the interval $[t_k, t_k+h]$. The specific formulation provided corresponds to a fourth-order method based on the two-point Gauss-Legendre quadrature rule. This method avoids commutators entirely and approximates the solution by a composition of two exponentials, $R_{k+1} = R_k \\exp(\\widehat{v_1})\\exp(\\widehat{v_2})$. This is also known as a splitting method, where the increments $v_1$ and $v_2$ are constructed such that their composition cancels error terms up to the desired order.\n\nThe core of the implementation is the exponential map $\\exp: \\mathfrak{so}(3) \\to \\mathrm{SO}(3)$. For a Lie algebra element $\\widehat{v}$, the exponential map is equivalent to a rotation around the axis $v/\\|v\\|_2$ by an angle $\\theta = \\|v\\|_2$. This is computed efficiently and robustly using the Rodrigues formula. To avoid numerical instability (division by zero) for small angles $\\theta$, we use Taylor series expansions for the coefficients $\\sin(\\theta)/\\theta$ and $(1-\\cos\\theta)/\\theta^2$.\n\nTo assess the integrator's performance, especially under high-frequency forcing, its output $R_{\\mathrm{cf}}$ is compared against a high-fidelity reference solution $R_{\\mathrm{ref}}$. This reference is generated using a standard adaptive-step Runge-Kutta method (`scipy.integrate.solve_ivp` with 'RK45') applied to the flattened $9$-dimensional system, but with very stringent error tolerances and a maximum step size much smaller than the characteristic time scales of the problem.\n\nThe error is quantified by the angle of the relative rotation matrix $E = R_{\\mathrm{cf}}^\\top R_{\\mathrm{ref}}$, which represents the rotation needed to align the computed frame with the reference frame. This angle is extracted using the trace formula $\\theta_{\\mathrm{err}} = \\arccos((\\mathrm{trace}(E)-1)/2)$, with care taken to clamp the argument to $[-1, 1]$ to prevent `NaN` values from floating-point inaccuracies.\n\nThe implementation will proceed by defining helper functions for the hat map and the exponential map, functions for the angular velocity and the integrator logic, and a function to compute the reference solution. These components are then orchestrated to run the specified test cases and produce the final error report.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a fourth-order commutator-free Magnus integrator \n    for attitude dynamics on SO(3).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, beta, gamma, delta, Omega, T, h)\n        (2.0, 1.0, 0.2, 0.5, 10.0, 1.0, 0.01),    # Case A\n        (2.0, 1.0, 0.2, 0.5, 50.0, 1.0, 0.01),    # Case B\n        (2.0, 1.0, 0.2, 0.5, 200.0, 0.5, 0.01),   # Case C\n        (0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.05),    # Case D\n        (2.0, 1.0, 0.2, 0.5, 200.0, 0.5, 0.002),  # Case E\n    ]\n\n    # Pre-calculate constants for efficiency and clarity\n    I_3x3 = np.identity(3)\n    c1_node = 0.5 - np.sqrt(3) / 6.0\n    c2_node = 0.5 + np.sqrt(3) / 6.0\n    sqrt3_div_12 = np.sqrt(3) / 12.0\n\n    def hat(v):\n        \"\"\"Maps a vector in R^3 to its skew-symmetric matrix in so(3).\"\"\"\n        return np.array([\n            [0.0, -v[2], v[1]],\n            [v[2], 0.0, -v[0]],\n            [-v[1], v[0], 0.0]\n        ])\n\n    def exp_so3(v):\n        \"\"\"\n        Computes the matrix exponential from so(3) to SO(3) via Rodrigues' formula.\n        Uses Taylor series for small angles to ensure numerical stability.\n        \"\"\"\n        theta = np.linalg.norm(v)\n        hat_v = hat(v)\n\n        if theta  1e-9:  # Threshold for small angle approximation\n            theta2 = theta * theta\n            theta4 = theta2 * theta2\n            A = 1.0 - theta2 / 6.0 + theta4 / 120.0  # Taylor for sin(t)/t\n            B = 0.5 - theta2 / 24.0 + theta4 / 720.0 # Taylor for (1-cos(t))/t^2\n        else:\n            A = np.sin(theta) / theta\n            B = (1.0 - np.cos(theta)) / (theta * theta)\n        \n        return I_3x3 + A * hat_v + B * (hat_v @ hat_v)\n\n    def omega_func(t, alpha, beta, gamma, delta, Omega):\n        \"\"\"Calculates the body angular velocity vector at time t.\"\"\"\n        return np.array([\n            alpha * np.sin(Omega * t),\n            beta * np.cos(Omega * t),\n            gamma + delta * np.sin(2.0 * Omega * t)\n        ])\n\n    def cf4_integrator(params):\n        \"\"\"\n        Implements the 4th-order commutator-free Magnus integrator.\n        \"\"\"\n        alpha, beta, gamma, delta, Omega, T, h = params\n        \n        R = np.copy(I_3x3)\n        time_steps = np.arange(0, T, h)\n        \n        for t_k in time_steps:\n            # Sample omega at Gauss-Legendre quadrature nodes\n            omega1 = omega_func(t_k + c1_node * h, alpha, beta, gamma, delta, Omega)\n            omega2 = omega_func(t_k + c2_node * h, alpha, beta, gamma, delta, Omega)\n            \n            # Calculate Lie algebra increments v1, v2 as per the problem statement\n            v_sum = omega1 + omega2\n            v_diff = omega1 - omega2\n            \n            term1 = (h / 4.0) * v_sum\n            term2 = (h * sqrt3_div_12) * v_diff\n            \n            v1 = term1 + term2\n            v2 = term1 - term2\n            \n            # Update rotation matrix by composing exponentials\n            E1 = exp_so3(v1)\n            E2 = exp_so3(v2)\n            R = R @ E1 @ E2\n            \n        return R\n\n    def reference_integrator(params):\n        \"\"\"\n        Computes the high-accuracy reference solution using scipy.integrate.solve_ivp.\n        \"\"\"\n        alpha, beta, gamma, delta, Omega, T, h = params\n        \n        # Define the right-hand side of the ODE: d(vec(R))/dt = vec(R @ hat(omega))\n        def rhs(t, y):\n            R = y.reshape((3, 3))\n            omega_t = omega_func(t, alpha, beta, gamma, delta, Omega)\n            R_dot = R @ hat(omega_t)\n            return R_dot.flatten()\n\n        y0 = I_3x3.flatten()\n        t_span = [0.0, T]\n        \n        # Set max_step for the reference solver to ensure high accuracy\n        if Omega > 1e-9:\n            max_step = (2.0 * np.pi / Omega) / 100.0\n        else: # For the constant velocity case (Omega=0), base it on h\n            max_step = h / 100.0\n\n        sol = solve_ivp(\n            rhs, \n            t_span, \n            y0, \n            method='RK45', \n            rtol=1e-12, \n            atol=1e-14, \n            max_step=max_step\n        )\n        \n        # Reshape final state vector back to a 3x3 matrix\n        R_final = sol.y[:, -1].reshape((3, 3))\n        return R_final\n\n    def calculate_angle_error(R_computed, R_reference):\n        \"\"\"\n        Calculates the angle of the relative error rotation matrix.\n        \"\"\"\n        # Relative rotation matrix\n        E = R_computed.T @ R_reference\n        trace_E = np.trace(E)\n        \n        # Clamp argument to arccos to handle potential floating-point inaccuracies\n        # The argument should be in [-1, 1] for a valid rotation matrix.\n        arg = np.clip((trace_E - 1.0) / 2.0, -1.0, 1.0)\n        \n        theta_err = np.arccos(arg)\n        return theta_err\n    \n    # Process all test cases and store results\n    final_results = []\n    for case_params in test_cases:\n        # Compute the solution from the commutator-free integrator\n        R_cf = cf4_integrator(case_params)\n        \n        # Compute the high-accuracy reference solution\n        R_ref = reference_integrator(case_params)\n        \n        # Calculate the final angle error and append to results\n        error = calculate_angle_error(R_cf, R_ref)\n        final_results.append(f\"{error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}