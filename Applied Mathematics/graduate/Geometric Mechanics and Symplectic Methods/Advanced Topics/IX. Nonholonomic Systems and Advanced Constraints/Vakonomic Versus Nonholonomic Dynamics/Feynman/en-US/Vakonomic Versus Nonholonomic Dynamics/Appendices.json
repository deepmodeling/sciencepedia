{
    "hands_on_practices": [
        {
            "introduction": "To see the practical divergence between nonholonomic and vakonomic dynamics, there is no substitute for a direct comparison. In this exercise, we will apply both the Lagrange–d’Alembert principle and the vakonomic variational principle to an identical mechanical system subject to a linear velocity constraint . By explicitly deriving and comparing the resulting accelerations, you will observe firsthand how these two frameworks can yield fundamentally different physical predictions from the same initial state.",
            "id": "3783683",
            "problem": "Consider a mechanical system with configuration space $Q=\\mathbb{R}^{3}$, coordinates $q=(q_{1},q_{2},q_{3})$, and kinetic energy determined by a constant positive-definite mass matrix taken to be the identity for simplicity. The Lagrangian is $L(q,\\dot q)=\\tfrac{1}{2}\\dot q^{T}\\dot q$, and the system is subject to a linear velocity constraint of full rank given by $A(q)\\dot q=0$, where the single constraint one-form $a(q)\\in\\mathbb{R}^{3}$ is\n$$\na(q)=\\big(q_{2},\\,-q_{1},\\,1\\big).\n$$\nTwo distinct constrained variational principles are considered:\n- the nonholonomic Lagrange–d’Alembert principle, and\n- the vakonomic (variational axiomatic) principle, in which one augments the action by the multiplier term $\\lambda(t)\\,a(q)\\cdot\\dot q$ with $\\lambda(t)$ a scalar function.\n\nStarting from first principles (Hamilton’s principle for unconstrained dynamics and the Lagrange–d’Alembert principle for nonholonomic dynamics), derive the equations of motion under each principle for general $q,\\dot q$, and then evaluate the resulting accelerations at the configuration $q=(1,0,0)$ with a velocity $\\dot q=(u,v,v)$, where $u$ and $v$ are real numbers chosen to satisfy the constraint $a(q)\\cdot\\dot q=0$ at $q=(1,0,0)$.\n\nCompute:\n1. The nonholonomic acceleration vector $\\ddot q_{\\mathrm{nh}}$ at $q=(1,0,0)$ and $\\dot q=(u,v,v)$.\n2. The vakonomic acceleration vector $\\ddot q_{\\mathrm{vak}}$ at the same state, expressing your result in terms of the vakonomic multiplier $\\lambda(t)$ and its time derivative $\\dot\\lambda(t)$ as needed, and then use the time derivative of the constraint to eliminate $\\dot\\lambda(t)$ in favor of $\\lambda(t)$, $u$, and $v$.\n3. The difference $\\Delta\\ddot q=\\ddot q_{\\mathrm{vak}}-\\ddot q_{\\mathrm{nh}}$ at this state, expressed purely in terms of $\\lambda(t)$, $u$, and $v$.\n\nYour final answer must be the single vector expression for $\\Delta\\ddot q$ as a closed-form analytic expression. Express the final vector as a row matrix.",
            "solution": "The unconstrained Euler–Lagrange equations for $L(q,\\dot q)=\\tfrac{1}{2}\\dot q^{T}\\dot q$ are\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot q}\\right)-\\frac{\\partial L}{\\partial q}=0\n\\;\\;\\Longrightarrow\\;\\;\n\\ddot q=0,\n$$\nsince the mass matrix is the identity and there is no potential.\n\nThe system is subject to the linear velocity constraint $A(q)\\dot q=0$ where $A(q)$ is $1\\times 3$ with row $a(q)=(q_{2},-q_{1},1)$. At $q=(1,0,0)$, one has $a(q)=(0,-1,1)$, so the constraint $a(q)\\cdot\\dot q=0$ implies $-\\dot q_{2}+\\dot q_{3}=0$, which is satisfied by $\\dot q=(u,v,v)$ for any real $u,v$.\n\nNonholonomic dynamics (Lagrange–d’Alembert):\nFor an ideal linear velocity constraint $A(q)\\dot q=0$, the nonholonomic equations with multiplier $\\mu(t)\\in\\mathbb{R}$ read\n$$\n\\ddot q = A(q)^{T}\\mu,\n$$\ntogether with the kinematic constraint and its compatibility (obtained by differentiating $A(q)\\dot q=0$):\n$$\nA(q)\\dot q=0,\\qquad A(q)\\ddot q+\\dot A(q)\\dot q=0.\n$$\nHere $\\dot A(q)\\dot q$ denotes the time derivative of $A(q)$ multiplied by $\\dot q$. With $a(q)=(q_{2},-q_{1},1)$, its time derivative is\n$$\n\\dot a(q)=\\left(\\dot q_{2},\\,-\\dot q_{1},\\,0\\right),\n$$\nand for $m=1$ the compatibility reduces to\n$$\na(q)\\cdot\\ddot q+\\dot a(q)\\cdot\\dot q=0.\n$$\nUsing $\\ddot q = a(q)^{T}\\mu$ gives\n$$\n\\mu\\,\\big(a(q)\\cdot a(q)\\big) + \\dot a(q)\\cdot\\dot q = 0\n\\;\\;\\Longrightarrow\\;\\;\n\\mu = -\\frac{\\dot a(q)\\cdot\\dot q}{|a(q)|^{2}}.\n$$\nAt the chosen state, $a(q)=(0,-1,1)$ so $|a(q)|^{2}=2$, and $\\dot a(q)=(v,-u,0)$, hence\n$$\n\\dot a(q)\\cdot\\dot q = v\\,u + (-u)\\,v + 0\\cdot v = 0,\n$$\nwhich yields $\\mu=0$. Therefore,\n$$\n\\ddot q_{\\mathrm{nh}} = a(q)^{T}\\mu = 0.\n$$\n\nVakonomic dynamics:\nIn the vakonomic formulation, the augmented Lagrangian is $\\mathcal{L}(q,\\dot q,\\lambda)=L(q,\\dot q)+\\lambda\\,a(q)\\cdot\\dot q$. The Euler–Lagrange equations for $q$ are\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\dot q}\\right) - \\frac{\\partial \\mathcal{L}}{\\partial q} = 0.\n$$\nCompute the necessary derivatives:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\dot q} = \\dot q + \\lambda\\,a(q),\\qquad\n\\frac{d}{dt}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\dot q}\\right) = \\ddot q + \\lambda\\,\\dot a(q) + \\dot\\lambda\\,a(q),\n$$\nand\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial q} = \\lambda\\,\\frac{\\partial}{\\partial q}\\big(a(q)\\cdot\\dot q\\big) = \\lambda\\,B(q,\\dot q),\n$$\nwhere the vector $B(q,\\dot q)$ has components\n$$\nB_{k}(q,\\dot q) = \\frac{\\partial}{\\partial q_{k}}\\big(a(q)\\cdot\\dot q\\big) = \\sum_{i=1}^{3}\\frac{\\partial a_{i}}{\\partial q_{k}}\\,\\dot q_{i}.\n$$\nIn matrix form, if $D(q)=\\partial a/\\partial q$ is the $3\\times 3$ Jacobian with entries $D_{ik}=\\partial a_{i}/\\partial q_{k}$, then $B(q,\\dot q)=D(q)^{T}\\dot q$ and $\\dot a(q)=D(q)\\dot q$. Thus the vakonomic equation is\n$$\n\\ddot q + \\lambda\\,\\dot a(q) + \\dot\\lambda\\,a(q) - \\lambda\\,B(q,\\dot q) = 0\n\\;\\;\\Longrightarrow\\;\\;\n\\ddot q_{\\mathrm{vak}} = -\\lambda\\,\\dot a(q) - \\dot\\lambda\\,a(q) + \\lambda\\,B(q,\\dot q).\n$$\nIn addition, the constraint $a(q)\\cdot\\dot q=0$ holds for all time; differentiating gives the kinematic compatibility\n$$\na(q)\\cdot\\ddot q + \\dot a(q)\\cdot\\dot q = 0.\n$$\nSubstitute $\\ddot q_{\\mathrm{vak}}$ to obtain an expression for $\\dot\\lambda$:\n$$\na(q)\\cdot\\big(-\\lambda\\,\\dot a(q) - \\dot\\lambda\\,a(q) + \\lambda\\,B(q,\\dot q)\\big) + \\dot a(q)\\cdot\\dot q = 0,\n$$\nwhich simplifies to\n$$\n-\\dot\\lambda\\,|a(q)|^{2} + \\lambda\\big(a(q)\\cdot B(q,\\dot q) - a(q)\\cdot \\dot a(q)\\big) + \\dot a(q)\\cdot\\dot q = 0,\n$$\nand hence\n$$\n\\dot\\lambda = \\frac{\\lambda\\big(a(q)\\cdot B(q,\\dot q) - a(q)\\cdot \\dot a(q)\\big) + \\dot a(q)\\cdot\\dot q}{|a(q)|^{2}}.\n$$\n\nEvaluation at $q=(1,0,0)$ and $\\dot q=(u,v,v)$:\nCompute the Jacobian $D(q)=\\partial a/\\partial q$ for $a(q)=(q_{2},-q_{1},1)$:\n$$\nD(q)=\\begin{pmatrix}\n\\frac{\\partial a_{1}}{\\partial q_{1}} & \\frac{\\partial a_{1}}{\\partial q_{2}} & \\frac{\\partial a_{1}}{\\partial q_{3}} \\\\\n\\frac{\\partial a_{2}}{\\partial q_{1}} & \\frac{\\partial a_{2}}{\\partial q_{2}} & \\frac{\\partial a_{2}}{\\partial q_{3}} \\\\\n\\frac{\\partial a_{3}}{\\partial q_{1}} & \\frac{\\partial a_{3}}{\\partial q_{2}} & \\frac{\\partial a_{3}}{\\partial q_{3}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 & 1 & 0\\\\\n-1 & 0 & 0\\\\\n0 & 0 & 0\n\\end{pmatrix}.\n$$\nThus at any $(q,\\dot q)$,\n$$\n\\dot a(q)=D(q)\\dot q=\\big(\\dot q_{2},\\,-\\dot q_{1},\\,0\\big),\\qquad\nB(q,\\dot q)=D(q)^{T}\\dot q=\\big(-\\dot q_{2},\\,\\dot q_{1},\\,0\\big).\n$$\nAt $(q,\\dot q)=\\big((1,0,0),(u,v,v)\\big)$,\n$$\na(q)=(0,-1,1),\\quad |a(q)|^{2}=2,\\quad \\dot a(q)=(v,-u,0),\\quad B(q,\\dot q)=(-v,u,0).\n$$\nMoreover,\n$$\n\\dot a(q)\\cdot\\dot q = v\\,u + (-u)\\,v + 0\\cdot v = 0,\\qquad\na(q)\\cdot B(q,\\dot q) = (0)(-v) + (-1)(u) + (1)(0) = -u,\n$$\nand\n$$\na(q)\\cdot \\dot a(q) = (0)(v) + (-1)(-u) + (1)(0) = u.\n$$\nTherefore,\n$$\na(q)\\cdot B(q,\\dot q) - a(q)\\cdot \\dot a(q) = -u - u = -2u,\n$$\nand the multiplier evolution is\n$$\n\\dot\\lambda = \\frac{\\lambda(-2u) + 0}{2} = -\\lambda\\,u.\n$$\nSubstitute into the vakonomic acceleration:\n$$\n\\ddot q_{\\mathrm{vak}} = -\\lambda\\,(v,-u,0)\\;-\\;\\dot\\lambda\\,(0,-1,1)\\;+\\;\\lambda\\,(-v,u,0).\n$$\nUsing $\\dot\\lambda=-\\lambda u$,\n$$\n-\\dot\\lambda\\,(0,-1,1) = \\lambda u\\,(0,-1,1) = (0,-\\lambda u,\\lambda u),\n$$\nso\n$$\n\\ddot q_{\\mathrm{vak}} = (-\\lambda v,\\,\\lambda u,\\,0) + (0,-\\lambda u,\\,\\lambda u) + (-\\lambda v,\\,\\lambda u,\\,0)\n= \\big(-2\\lambda v,\\;\\lambda u,\\;\\lambda u\\big).\n$$\n\nComparison:\nWe found $\\ddot q_{\\mathrm{nh}}=0$ and $\\ddot q_{\\mathrm{vak}}=(-2\\lambda v,\\lambda u,\\lambda u)$. Hence the difference at the specified state is\n$$\n\\Delta\\ddot q \\;=\\; \\ddot q_{\\mathrm{vak}} - \\ddot q_{\\mathrm{nh}} \\;=\\; \\big(-2\\lambda v,\\;\\lambda u,\\;\\lambda u\\big).\n$$\nThis is expressed purely in terms of the vakonomic multiplier $\\lambda(t)$ and the velocity components $u$ and $v$ at the state $q=(1,0,0)$, $\\dot q=(u,v,v)$.",
            "answer": "$$\\boxed{\\begin{pmatrix}-2\\lambda v & \\lambda u & \\lambda u\\end{pmatrix}}$$"
        },
        {
            "introduction": "Beyond the equations of motion, the treatment of conserved quantities like energy reveals profound differences between dynamical principles. While ideal nonholonomic constraints are defined to do no work, the same is not true for their vakonomic counterparts. This problem  presents a compelling counterexample: a system with a time-independent Lagrangian and constraint for which you will show that mechanical energy is not conserved along vakonomic trajectories, directly calculating the power supplied by the vakonomic \"constraint force.\"",
            "id": "3783676",
            "problem": "Consider a mechanical system on the plane with configuration coordinates $x$ and $y$, mass $m$, and mechanical Lagrangian $L_0 = \\tfrac{1}{2} m \\left( \\dot{x}^2 + \\dot{y}^2 \\right)$, with no explicit time dependence and no potential energy. Impose the following time-independent affine velocity constraint\n$$\n\\dot{y} - b\\,x = 0,\n$$\nwhere $b$ is a nonzero constant. Treat the constraint vakonomically by augmenting the Lagrangian with a Lagrange multiplier $\\lambda$, that is, consider the augmented Lagrangian\n$$\nL_{\\mathrm{v}} = L_0 + \\lambda \\left( \\dot{y} - b\\,x \\right).\n$$\nUsing the Euler–Lagrange (EL) equations derived from $L_{\\mathrm{v}}$ for the variables $x$, $y$, and $\\lambda$, obtain the vakonomic equations of motion and use them to compute the time derivative of the mechanical energy\n$$\nE = \\tfrac{1}{2} m \\left( \\dot{x}^2 + \\dot{y}^2 \\right)\n$$\nalong vakonomic trajectories. Your derivation must start from the foundational definitions of the EL equations and of $E$, and proceed by direct differentiation and substitution, without invoking any pre-packaged energy balance identities. Show explicitly that this system provides a counterexample in which vakonomic dynamics lead to nonconservation of mechanical energy due to work performed by the multiplier term. Express your final answer as a single closed-form analytic expression for $\\dot{E}$ in terms of $x$, $\\dot{x}$, $\\lambda$, $\\dot{\\lambda}$, and $b$. No units are required. Do not round; provide the exact analytic expression.",
            "solution": "The system is described by the augmented Lagrangian $L_{\\mathrm{v}}$, which incorporates the mechanical Lagrangian $L_0 = \\tfrac{1}{2} m \\left( \\dot{x}^{2} + \\dot{y}^{2} \\right)$ and the affine velocity constraint $\\dot{y} - b\\,x = 0$ using a Lagrange multiplier $\\lambda$. The augmented Lagrangian is given by\n$$\nL_{\\mathrm{v}}(x, \\dot{x}, y, \\dot{y}, \\lambda) = \\tfrac{1}{2} m \\left( \\dot{x}^{2} + \\dot{y}^{2} \\right) + \\lambda \\left( \\dot{y} - b\\,x \\right).\n$$\nThe vakonomic equations of motion are the Euler-Lagrange (EL) equations for the variables $x$, $y$, and the multiplier $\\lambda$, which is treated as a configuration variable in the vakonomic formalism. The general form of the EL equation for a coordinate $q_i$ is\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L_{\\mathrm{v}}}{\\partial \\dot{q_i}}\\right) - \\frac{\\partial L_{\\mathrm{v}}}{\\partial q_i} = 0.\n$$\nWe derive the equation for each variable.\n\nFor the coordinate $x$:\nThe partial derivatives of $L_{\\mathrm{v}}$ are\n$$\n\\frac{\\partial L_{\\mathrm{v}}}{\\partial \\dot{x}} = m\\dot{x}\n$$\n$$\n\\frac{\\partial L_{\\mathrm{v}}}{\\partial x} = -b\\lambda\n$$\nSubstituting these into the EL equation yields the first equation of motion:\n$$\n\\frac{d}{dt}(m\\dot{x}) - (-b\\lambda) = 0 \\implies m\\ddot{x} = -b\\lambda.\n$$\n\nFor the coordinate $y$:\nThe partial derivatives of $L_{\\mathrm{v}}$ are\n$$\n\\frac{\\partial L_{\\mathrm{v}}}{\\partial \\dot{y}} = m\\dot{y} + \\lambda\n$$\n$$\n\\frac{\\partial L_{\\mathrm{v}}}{\\partial y} = 0\n$$\nSubstituting these into the EL equation yields the second equation of motion:\n$$\n\\frac{d}{dt}(m\\dot{y} + \\lambda) - 0 = 0 \\implies m\\ddot{y} + \\dot{\\lambda} = 0 \\implies m\\ddot{y} = -\\dot{\\lambda}.\n$$\n\nFor the multiplier $\\lambda$:\nThe vakonomic formalism treats $\\lambda$ as a coordinate. Since $L_{\\mathrm{v}}$ does not depend on $\\dot{\\lambda}$, the term $\\frac{d}{dt}(\\frac{\\partial L_{\\mathrm{v}}}{\\partial \\dot{\\lambda}})$ is zero. The EL equation for $\\lambda$ thus simplifies to $\\frac{\\partial L_{\\mathrm{v}}}{\\partial \\lambda} = 0$.\n$$\n\\frac{\\partial L_{\\mathrm{v}}}{\\partial \\lambda} = \\dot{y} - b\\,x\n$$\nThis yields the third equation of motion, which is the constraint equation itself:\n$$\n\\dot{y} - b\\,x = 0.\n$$\nThe full set of vakonomic equations of motion is therefore:\n1. $m\\ddot{x} = -b\\lambda$\n2. $m\\ddot{y} = -\\dot{\\lambda}$\n3. $\\dot{y} = b\\,x$\n\nNext, we compute the time derivative of the mechanical energy $E$, which is defined as\n$$\nE = \\tfrac{1}{2} m \\left( \\dot{x}^{2} + \\dot{y}^{2} \\right).\n$$\nDifferentiating $E$ with respect to time $t$ using the chain rule gives\n$$\n\\dot{E} = \\frac{dE}{dt} = \\frac{d}{dt} \\left[ \\tfrac{1}{2} m \\left( \\dot{x}^{2} + \\dot{y}^{2} \\right) \\right] = \\tfrac{1}{2} m \\left( 2\\dot{x}\\ddot{x} + 2\\dot{y}\\ddot{y} \\right) = m\\ddot{x}\\dot{x} + m\\ddot{y}\\dot{y}.\n$$\nNow, we substitute the expressions for $m\\ddot{x}$ and $m\\ddot{y}$ from the equations of motion (1) and (2) into the expression for $\\dot{E}$:\n$$\n\\dot{E} = (-b\\lambda)\\dot{x} + (-\\dot{\\lambda})\\dot{y} = -b\\lambda\\dot{x} - \\dot{\\lambda}\\dot{y}.\n$$\nThe problem requires the final expression to be in terms of $x$, $\\dot{x}$, $\\lambda$, $\\dot{\\lambda}$, and $b$. Our current expression contains $\\dot{y}$, which we can eliminate using the constraint equation (3), $\\dot{y} = b\\,x$. Substituting this into the expression for $\\dot{E}$ gives:\n$$\n\\dot{E} = -b\\lambda\\dot{x} - \\dot{\\lambda}(b\\,x).\n$$\nRearranging the terms, we obtain the final expression for the rate of change of mechanical energy:\n$$\n\\dot{E} = -b\\lambda\\dot{x} - bx\\dot{\\lambda}.\n$$\nThis result is not identically zero, demonstrating that in vakonomic dynamics, the effective \"constraint force\" can perform work, leading to the non-conservation of mechanical energy. This is a fundamental distinction from nonholonomic dynamics governed by the principle of d'Alembert, where ideal constraints perform no work by definition. The derived expression is the power, or rate of work, supplied by the vakonomic constraint.",
            "answer": "$$\n\\boxed{-b\\lambda\\dot{x} - bx\\dot{\\lambda}}\n$$"
        },
        {
            "introduction": "At a deeper mathematical level, Hamiltonian dynamics are characterized by the Poisson bracket, an algebraic structure satisfying the Jacobi identity. This exercise invites you to investigate whether nonholonomic dynamics shares this foundational property by implementing a numerical version of the nonholonomic bracket . By computing the Jacobiator for a specific set of observables, you will quantify the failure of the Jacobi identity, uncovering a key reason why nonholonomic systems resist a standard Poisson-geometric formulation.",
            "id": "3783697",
            "problem": "Consider a phase space of dimension $n=4$ with coordinates $x=(q_1,q_2,p_1,p_2)\\in\\mathbb{R}^4$ and the canonical Poisson tensor $$J=\\begin{bmatrix}0&0&1&0\\\\0&0&0&1\\\\-1&0&0&0\\\\0&-1&0&0\\end{bmatrix}.$$ Let observables be smooth scalar functions $f:\\mathbb{R}^4\\to\\mathbb{R}$. A nonholonomic constraint is modeled as a linear constraint on velocities $v\\in T_x\\mathbb{R}^4$ given by $$C(x)\\,v=0,$$ where $C(x)$ is an $m\\times 4$ matrix depending on the state $x$ and $m\\le 4$. Using the Euclidean metric, the orthogonal projector onto the constraint distribution (the nullspace of $C(x)$) is $$\\Pi(x)=I_4 - C(x)^\\top\\left(C(x)\\,C(x)^\\top\\right)^+ C(x),$$ where $(\\cdot)^+$ denotes the Moore–Penrose pseudoinverse (MPP). Define the nonholonomic bracket of observables $f$ and $g$ at $x$ by $$\\{f,g\\}_{\\text{nh}}(x)=\\nabla f(x)^\\top\\,\\Pi(x)\\,J\\,\\Pi(x)\\,\\nabla g(x),$$ where $\\nabla f$ and $\\nabla g$ are gradients with respect to $x$.\n\nIn the continuous theory, the Jacobi identity for a bracket is expressed by the vanishing of the cyclic sum $$\\mathcal{J}(f,g,h)(x)=\\{f,\\{g,h\\}_{\\text{nh}}\\}_{\\text{nh}}(x)+\\{g,\\{h,f\\}_{\\text{nh}}\\}_{\\text{nh}}(x)+\\{h,\\{f,g\\}_{\\text{nh}}\\}_{\\text{nh}}(x).$$ For the nonholonomic bracket above, $\\Pi(x)$ generally depends on $x$, which can cause a failure of the Jacobi identity. To quantify this failure numerically, implement a discrete nonholonomic bracket using numerical central differences to approximate gradients:\n- For any observable $\\phi:\\mathbb{R}^4\\to\\mathbb{R}$ and a chosen step size $\\varepsilon>0$, approximate its gradient by\n$$\\left[\\nabla \\phi(x)\\right]_i\\approx\\frac{\\phi(x+\\varepsilon e_i)-\\phi(x-\\varepsilon e_i)}{2\\varepsilon},\\quad i=1,\\dots,4,$$\nwhere $e_i$ is the $i$-th standard basis vector in $\\mathbb{R}^4$.\n- Use this discrete gradient within the definition of $\\{f,g\\}_{\\text{nh}}(x)$, and wherever nested brackets appear, treat $\\{g,h\\}_{\\text{nh}}$ as a function of $x$ whose gradient is again approximated numerically in the same way.\n\nStarting only from the definitions above and the canonical tensor $J$, implement a program that:\n1. Defines the three observables\n$$f(q_1,q_2,p_1,p_2)=q_1^2+p_1 q_2,\\quad g(q_1,q_2,p_1,p_2)=q_2 p_2+p_1^2,\\quad h(q_1,q_2,p_1,p_2)=q_1 p_2 - q_2^3.$$\n2. Implements the projector $\\Pi(x)$ using the Moore–Penrose pseudoinverse.\n3. Implements the discrete nonholonomic bracket $\\{f,g\\}_{\\text{nh}}(x)$.\n4. Implements the discrete Jacobi failure measure\n$$\\Delta(f,g,h;x)=\\left|\\mathcal{J}(f,g,h)(x)\\right|,$$\ncomputed using the discrete bracket and discrete gradients as described.\n\nUse the central difference step size $\\varepsilon=10^{-6}$ and evaluate $\\Delta(f,g,h;x)$ at the fixed point $$x^\\ast=(0.3,-0.2,1.0,-0.5).$$ For the following five test cases of state-dependent linear constraints $C(x)$, compute the single scalar result $\\Delta(f,g,h;x^\\ast)$ for each case:\n- Test 1 (no constraints): $C(x)$ is the $0\\times 4$ empty matrix (so $\\Pi(x)=I_4$).\n- Test 2 (single state-dependent constraint): $$C(x)=\\begin{bmatrix}q_1 & 0 & 0 & 1\\end{bmatrix}.$$\n- Test 3 (two state-dependent constraints): $$C(x)=\\begin{bmatrix}q_1 & q_2 & 0 & 0\\\\ 0 & 0 & 1 & p_1\\end{bmatrix}.$$\n- Test 4 (dependent constraints): $$C(x)=\\begin{bmatrix}q_1 & 0 & 0 & 0\\\\ 2 q_1 & 0 & 0 & 0\\end{bmatrix}.$$\n- Test 5 (full constraints): $$C(x)=\\begin{bmatrix}1 & 0 & 0 & 0\\\\ 0 & q_1^2+1 & 0 & 0\\\\ 0 & 0 & q_2^2+1 & 0\\\\ 0 & 0 & 0 & 1\\end{bmatrix}.$$\n\nYour program should produce a single line of output containing the five results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5]\"). No physical units or angles are involved; all quantities are dimensionless real numbers. The output elements must be floats. The implementation must be self-contained and rely only on the definitions and numerical scheme given here, without any external input or files.",
            "solution": "The problem requires the numerical computation of the failure of the Jacobi identity for a specific nonholonomic bracket. The solution involves a careful implementation of nested numerical differentiation and matrix algebra, following the definitions provided.\n\nThe core of the problem lies in evaluating the Jacobiator, defined as the cyclic sum:\n$$\n\\mathcal{J}(f,g,h)(x) = \\{f,\\{g,h\\}_{\\text{nh}}\\}_{\\text{nh}}(x) + \\{g,\\{h,f\\}_{\\text{nh}}\\}_{\\text{nh}}(x) + \\{h,\\{f,g\\}_{\\text{nh}}\\}_{\\text{nh}}(x)\n$$\nThe final result is the magnitude of this quantity, $\\Delta(f,g,h;x) = |\\mathcal{J}(f,g,h)(x)|$, evaluated at the specific point $x^\\ast=(0.3,-0.2,1.0,-0.5)$.\n\nThe overall algorithm is structured as follows:\n1. Implement the fundamental building blocks: the observables $f$, $g$, $h$; the canonical Poisson tensor $J$; and the functions for generating the constraint matrices $C(x)$ for each test case.\n2. Create a function to compute the numerical gradient of any given observable $\\phi:\\mathbb{R}^4\\to\\mathbb{R}$ at a point $x$. This is done using the central difference formula with a step size $\\varepsilon=10^{-6}$:\n$$\n[\\nabla \\phi(x)]_i = \\frac{\\phi(x+\\varepsilon e_i)-\\phi(x-\\varepsilon e_i)}{2\\varepsilon}\n$$\nwhere $e_i$ is the $i$-th standard basis vector in $\\mathbb{R}^4$.\n3. Create a function to compute the orthogonal projector $\\Pi(x)$ onto the nullspace of the constraint matrix $C(x)$. The definition is:\n$$\n\\Pi(x)=I_4 - C(x)^\\top\\left(C(x)\\,C(x)^\\top\\right)^+ C(x)\n$$\nThe Moore–Penrose pseudoinverse (MPP), denoted by $(\\cdot)^+$, is essential here, as the matrix $C(x)C(x)^\\top$ can be singular or even empty (for the $m=0$ case). The MPP provides a robust way to handle all cases. For the case where $C(x)$ is an empty $0\\times 4$ matrix, its product with its transpose is a $0\\times 0$ matrix, and the entire term $C^\\top(\\dots)^+C$ evaluates to the $4\\times 4$ zero matrix, correctly yielding $\\Pi(x)=I_4$.\n4. Implement the nonholonomic bracket $\\{A,B\\}_{\\text{nh}}(x)$ for any two observables $A$ and $B$. This function takes two callable functions representing the observables, a point $x$, and the constraint function $C(x)$. It calculates their gradients using the numerical gradient function, computes the projector $\\Pi(x)$, and assembles the final result according to the definition:\n$$\n\\{A,B\\}_{\\text{nh}}(x)=\\nabla A(x)^\\top\\,\\Pi(x)\\,J\\,\\Pi(x)\\,\\nabla B(x)\n$$\n5. Address the nested structure of the Jacobiator. A term like $\\{f,\\{g,h\\}_{\\text{nh}}\\}_{\\text{nh}}(x)$ requires treating the inner bracket, $\\phi_{gh}(x) = \\{g,h\\}_{\\text{nh}}(x)$, as a new observable. To compute the outer bracket, we need the gradient of $\\phi_{gh}(x)$. This is achieved by applying the numerical gradient function to $\\phi_{gh}$. This means that for each evaluation point required by the central difference formula (e.g., $x+\\varepsilon e_i$), the entire inner bracket $\\{g,h\\}_{\\text{nh}}$ must be re-computed. This nested calculation is implemented by defining intermediate functions for the inner brackets (e.g., `phi_gh(x_arg)`) which are then passed as observable arguments to the `nonholonomic_bracket` function.\n\n6. For each of the five test cases, the Jacobiator $\\mathcal{J}(f,g,h)(x^\\ast)$ is computed by summing its three cyclic terms, and the absolute value is taken.\n\nTwo special cases serve as sanity checks for the implementation:\n-   **Test Case 1** (no constraints): $\\Pi(x)=I_4$. The bracket simplifies to the canonical Poisson bracket, $\\{f,g\\}_{\\text{nh}} = \\nabla f^\\top J \\nabla g$. Since the canonical bracket satisfies the Jacobi identity, $\\mathcal{J}(f,g,h)$ is analytically zero. The numerical result should be a very small number, close to machine precision, reflecting the accuracy of the numerical differentiation.\n-   **Test Case 5** (full constraints): The constraint matrix $C(x)$ is invertible. This means the allowed velocity space (its nullspace) is trivial, containing only the zero vector. The projector onto this space is the zero matrix, $\\Pi(x)=0$. Consequently, $\\{A,B\\}_{\\text{nh}}(x) = 0$ for any observables $A$ and $B$. This makes every term in the Jacobiator zero, so $\\mathcal{J}(f,g,h)$ is again analytically zero. The numerical result should also be close to zero.\n\nThe non-zero results for Test Cases 2, 3, and 4 demonstrate the fundamental property of nonholonomic dynamics: the bracket associated with the system via this projection method generally fails to be a Poisson bracket because the Jacobi identity is not satisfied. This failure is directly linked to the state-dependency of the projector $\\Pi(x)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the failure of the Jacobi identity for a nonholonomic bracket\n    for five different constraint scenarios.\n    \"\"\"\n    # Define problem constants and parameters.\n    EPS = 1e-6\n    X_STAR = np.array([0.3, -0.2, 1.0, -0.5])\n    J_MAT = np.array([\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0]\n    ])\n\n    # Define the three observables as functions.\n    def f_obs(x):\n        q1, q2, p1, p2 = x\n        return q1**2 + p1 * q2\n\n    def g_obs(x):\n        q1, q2, p1, p2 = x\n        return q2 * p2 + p1**2\n\n    def h_obs(x):\n        q1, q2, p1, p2 = x\n        return q1 * p2 - q2**3\n\n    def numerical_gradient(phi, x, eps):\n        \"\"\"Computes the gradient of a scalar function phi using central differences.\"\"\"\n        grad = np.zeros_like(x, dtype=float)\n        for i in range(len(x)):\n            x_plus = x.copy()\n            x_plus[i] += eps\n            x_minus = x.copy()\n            x_minus[i] -= eps\n            grad[i] = (phi(x_plus) - phi(x_minus)) / (2 * eps)\n        return grad\n\n    def get_projector(C_mat):\n        \"\"\"Computes the orthogonal projector Pi from a constraint matrix C.\"\"\"\n        if C_mat.shape[0] == 0:\n            return np.identity(4)\n        else:\n            CC_t = C_mat @ C_mat.T\n            # Use Moore-Penrose pseudoinverse for robustness\n            CC_t_pinv = np.linalg.pinv(CC_t)\n            return np.identity(4) - C_mat.T @ CC_t_pinv @ C_mat\n\n    def nonholonomic_bracket(obs_A, obs_B, x, C_func, eps, J_mat):\n        \"\"\"Computes the nonholonomic bracket {A, B}_nh at point x.\"\"\"\n        grad_A = numerical_gradient(obs_A, x, eps)\n        grad_B = numerical_gradient(obs_B, x, eps)\n\n        C_mat = C_func(x)\n        Pi = get_projector(C_mat)\n\n        PiJPi = Pi @ J_mat @ Pi\n        return grad_A.T @ PiJPi @ grad_B\n\n    # Define the five constraint matrix functions for the test cases.\n    def C1_func(x): # Test 1: No constraints\n        return np.empty((0, 4))\n    \n    def C2_func(x): # Test 2: Single state-dependent constraint\n        q1, _, _, _ = x\n        return np.array([[q1, 0, 0, 1.0]])\n\n    def C3_func(x): # Test 3: Two state-dependent constraints\n        q1, q2, p1, _ = x\n        return np.array([[q1, q2, 0, 0], [0, 0, 1.0, p1]])\n\n    def C4_func(x): # Test 4: Dependent constraints\n        q1, _, _, _ = x\n        return np.array([[q1, 0, 0, 0], [2 * q1, 0, 0, 0]])\n\n    def C5_func(x): # Test 5: Full constraints\n        q1, q2, _, _ = x\n        return np.array([\n            [1.0, 0, 0, 0],\n            [0, q1**2 + 1, 0, 0],\n            [0, 0, q2**2 + 1, 0],\n            [0, 0, 0, 1.0]\n        ])\n\n    test_cases = [C1_func, C2_func, C3_func, C4_func, C5_func]\n    results = []\n\n    for C_func in test_cases:\n        # Define inner observables for Jacobiator. These are functions that compute\n        # the inner brackets at a given point x_arg. They capture the current C_func.\n        def phi_gh(x_arg):\n            return nonholonomic_bracket(g_obs, h_obs, x_arg, C_func, EPS, J_MAT)\n\n        def phi_hf(x_arg):\n            return nonholonomic_bracket(h_obs, f_obs, x_arg, C_func, EPS, J_MAT)\n\n        def phi_fg(x_arg):\n            return nonholonomic_bracket(f_obs, g_obs, x_arg, C_func, EPS, J_MAT)\n\n        # Compute the three terms of the Jacobiator at X_STAR.\n        # This involves passing the inner bracket functions (phi_gh, etc.)\n        # as observables to the outer bracket calculation.\n        term1 = nonholonomic_bracket(f_obs, phi_gh, X_STAR, C_func, EPS, J_MAT)\n        term2 = nonholonomic_bracket(g_obs, phi_hf, X_STAR, C_func, EPS, J_MAT)\n        term3 = nonholonomic_bracket(h_obs, phi_fg, X_STAR, C_func, EPS, J_MAT)\n\n        jacobiator_failure = term1 + term2 + term3\n        results.append(abs(jacobiator_failure))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}