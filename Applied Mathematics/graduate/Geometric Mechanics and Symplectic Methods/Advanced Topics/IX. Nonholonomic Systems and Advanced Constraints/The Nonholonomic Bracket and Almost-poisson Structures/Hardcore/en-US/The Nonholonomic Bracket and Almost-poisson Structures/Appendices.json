{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a foundational exercise in computing the nonholonomic bracket directly from its definition. Starting with a simple kinetic energy system and a linear nonholonomic constraint, you will trace the process from the velocity-level constraint to its representation on the phase space, and then solve for the nonholonomic vector field to find the bracket of two functions (). This step-by-step calculation reinforces the geometric underpinnings of the nonholonomic bracket.",
            "id": "3780341",
            "problem": "Consider a mechanical system with configuration manifold $Q=\\mathbb{R}^{3}$ and Cartesian coordinates $(x,y,z)$. The Lagrangian is the kinetic energy $L=\\tfrac{1}{2} m \\left(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2}\\right)$. Impose a linear nonholonomic velocity constraint given by the one-form $\\omega=\\mathrm{d}z - x\\,\\mathrm{d}y$, i.e., the admissible velocities satisfy $\\dot{z}-x\\,\\dot{y}=0$. Let $\\tau:T^{*}Q\\to Q$ be the canonical projection and equip $T^{*}Q$ with the canonical symplectic two-form $\\Omega = \\mathrm{d}x\\wedge \\mathrm{d}p_{x} + \\mathrm{d}y\\wedge \\mathrm{d}p_{y} + \\mathrm{d}z\\wedge \\mathrm{d}p_{z}$ in the canonical coordinates $(x,y,z,p_{x},p_{y},p_{z})$. Using the Legendre transform induced by the kinetic energy metric, identify the constraint submanifold $M\\subset T^{*}Q$ and the constraint distribution $C\\subset T(T^{*}Q)|_{M}$ defined by $C=\\{v\\in T(T^{*}Q)|_{M}\\mid T\\tau(v)\\in D\\}$, where $D=\\ker\\omega\\subset TQ$. Denote by $\\Omega_{C}$ the restriction of $\\Omega$ to $C$. For any smooth function $f\\in C^{\\infty}(M)$, let $Y_{f}\\in\\Gamma(C)$ be the unique section satisfying the defining relation of the nonholonomic almost-Poisson structure,\n$$\n\\iota_{Y_{f}}\\,\\Omega_{C}= \\mathrm{d}f\\big|_{C}.\n$$\nDefine the nonholonomic bracket on $C^{\\infty}(M)$ by\n$$\n\\{f,g\\}_{\\mathrm{nh}} := \\Omega_{C}(Y_{g}, Y_{f}).\n$$\nStarting only from these definitions, compute the explicit analytic expression of the nonholonomic bracket $\\{z, p_{y}\\}_{\\mathrm{nh}}$ as a function on $M$, expressed in terms of the canonical coordinates. Provide your final expression in simplest closed form. No rounding is required.",
            "solution": "The problem asks for the computation of the nonholonomic bracket $\\{z, p_y\\}_{\\mathrm{nh}}$ for a system defined on the configuration manifold $Q=\\mathbb{R}^{3}$ with a specific nonholonomic constraint. The calculation proceeds by first characterizing the geometric structures involved, namely the constraint submanifold and the constraint distribution, and then applying the given definitions for the nonholonomic vector fields and the bracket itself.\n\nFirst, we identify the constraint submanifold $M \\subset T^{*}Q$. The Lagrangian is given by the kinetic energy $L=\\tfrac{1}{2} m \\left(\\dot{x}^{2}+\\dot{y}^{2}+\\dot{z}^{2}\\right)$. The Legendre transform maps velocities $(\\dot{x}, \\dot{y}, \\dot{z}) \\in TQ$ to momenta $(p_x, p_y, p_z) \\in T^*Q$ via the relations $p_i = \\frac{\\partial L}{\\partial \\dot{q}^i}$.\n$$\np_x = m\\dot{x}, \\quad p_y = m\\dot{y}, \\quad p_z = m\\dot{z}\n$$\nThe nonholonomic constraint is given on the velocities as $\\dot{z} - x\\dot{y} = 0$. We translate this into a condition on the momenta:\n$$\n\\frac{p_z}{m} - x \\frac{p_y}{m} = 0 \\implies p_z - xp_y = 0\n$$\nThis equation defines the constraint submanifold $M \\subset T^*Q$. Let $\\phi(x,y,z,p_x,p_y,p_z) = p_z - xp_y$. Then $M = \\{ (q,p) \\in T^*Q \\mid \\phi(q,p) = 0 \\}$.\n\nNext, we characterize the constraint distribution $C \\subset T(T^*Q)|_{M}$. A vector $V \\in T_p(T^*Q)$ at a point $p \\in M$ belongs to the subspace $C_p$ if it satisfies two conditions. Let $V$ be expressed in local coordinates as:\n$$\nV = v_x \\frac{\\partial}{\\partial x} + v_y \\frac{\\partial}{\\partial y} + v_z \\frac{\\partial}{\\partial z} + \\dot{p}_x \\frac{\\partial}{\\partial p_x} + \\dot{p}_y \\frac{\\partial}{\\partial p_y} + \\dot{p}_z \\frac{\\partial}{\\partial p_z}\n$$\nThe first condition is that its projection to $TQ$ lies in the distribution $D = \\ker\\omega$, where $\\omega = \\mathrm{d}z - x\\,\\mathrm{d}y$. The projection is $T\\tau(V) = v_x \\frac{\\partial}{\\partial x} + v_y \\frac{\\partial}{\\partial y} + v_z \\frac{\\partial}{\\partial z}$. The condition $T\\tau(V) \\in D$ means $\\omega(T\\tau(V)) = 0$, which gives:\n$$\n(\\mathrm{d}z - x\\,\\mathrm{d}y)\\left(v_x \\frac{\\partial}{\\partial x} + v_y \\frac{\\partial}{\\partial y} + v_z \\frac{\\partial}{\\partial z}\\right) = v_z - xv_y = 0 \\quad (1)\n$$\nThe second condition is that $V$ must be tangent to the manifold $M$. This means that $V$ must annihilate the defining function of $M$, i.e., $V(\\phi) = 0$.\n$$\nV(\\phi) = V(p_z - xp_y) = \\dot{p}_z - \\left(v_x p_y + x \\dot{p}_y\\right) = 0 \\implies \\dot{p}_z - x\\dot{p}_y - v_x p_y = 0 \\quad (2)\n$$\nThus, $C_p$ is the subspace of $T_p(T^*Q)$ whose vector components satisfy equations $(1)$ and $(2)$.\n\nThe nonholonomic bracket is defined as $\\{f, g\\}_{\\mathrm{nh}} := \\Omega_C(Y_g, Y_f)$, where for any function $h \\in C^\\infty(M)$, the vector field $Y_h \\in \\Gamma(C)$ is defined by the relation $\\iota_{Y_h} \\Omega_C = \\mathrm{d}h|_C$. This means that for any vector field $W \\in \\Gamma(C)$, we have $\\Omega(Y_h, W) = \\mathrm{d}h(W)$.\nWe wish to compute $\\{z, p_y\\}_{\\mathrm{nh}}$. Let $f=z$ and $g=p_y$.\n$$\n\\{z, p_y\\}_{\\mathrm{nh}} = \\Omega_C(Y_{p_y}, Y_z)\n$$\nUsing the definition of $Y_{p_y}$, we have $\\Omega_C(Y_{p_y}, Y_z) = \\mathrm{d}p_y(Y_z)$. Our task reduces to finding the vector field $Y_z$ and then applying the one-form $\\mathrm{d}p_y$ to it.\n\nLet $Y_z$ be a vector field in $\\Gamma(C)$:\n$$\nY_z = A_x \\frac{\\partial}{\\partial x} + A_y \\frac{\\partial}{\\partial y} + A_z \\frac{\\partial}{\\partial z} + B_x \\frac{\\partial}{\\partial p_x} + B_y \\frac{\\partial}{\\partial p_y} + B_z \\frac{\\partial}{\\partial p_z}\n$$\nSince $Y_z \\in \\Gamma(C)$, its components must satisfy the constraint equations $(1)$ and $(2)$:\n$$\nA_z - xA_y = 0 \\quad (A)\n$$\n$$\nB_z - xB_y - A_x p_y = 0 \\quad (B)\n$$\nThe defining relation for $Y_z$ is $\\Omega(Y_z, W) = \\mathrm{d}z(W)$ for any $W \\in \\Gamma(C)$. Let $W$ be an arbitrary vector in $C_p$ with components $(w_x, w_y, w_z, \\dot{p}_x, \\dot{p}_y, \\dot{p}_z)$.\nThe left side is $\\Omega(Y_z, W) = (A_x\\dot{p}_x - B_x w_x) + (A_y\\dot{p}_y - B_y w_y) + (A_z\\dot{p}_z - B_z w_z)$.\nThe right side is $\\mathrm{d}z(W) = w_z$.\nUsing the constraint equations on $W$, $w_z = xw_y$ and $\\dot{p}_z = x\\dot{p}_y + w_x p_y$, we can substitute them into the expanded form of $\\Omega(Y_z, W)$:\n$$\n(A_x\\dot{p}_x - B_x w_x) + (A_y\\dot{p}_y - B_y w_y) + (A_z(x\\dot{p}_y + w_x p_y) - B_z(xw_y)) = xw_y\n$$\nWe collect terms based on the independent components of $W$, which we can choose as $w_x, w_y, \\dot{p}_x, \\dot{p}_y$:\n$$\nw_x(-B_x + A_z p_y) + w_y(-B_y - xB_z - x) + \\dot{p}_x(A_x) + \\dot{p}_y(A_y + xA_z) = 0\n$$\nSince this must hold for any choice of $w_x, w_y, \\dot{p}_x, \\dot{p}_y$, the coefficients must be zero:\n$$\n\\begin{cases}\n-B_x + A_z p_y = 0 & (i) \\\\\n-B_y - xB_z - x = 0 & (ii) \\\\\nA_x = 0 & (iii) \\\\\nA_y + xA_z = 0 & (iv)\n\\end{cases}\n$$\nWe now solve this linear system along with equations $(A)$ and $(B)$.\nFrom $(iii)$, we have $A_x=0$.\nSubstituting $A_x=0$ into $(B)$ gives $B_z - xB_y = 0$, so $B_z = xB_y$.\nSubstituting this into $(ii)$ gives $-B_y - x(xB_y) - x = 0$, which simplifies to $-B_y(1+x^2) = x$, so $B_y = -\\frac{x}{1+x^2}$.\nThen $B_z = xB_y = -\\frac{x^2}{1+x^2}$.\nFrom $(iv)$, we have $A_y = -xA_z$.\nSubstituting this into $(A)$ gives $A_z - x(-xA_z) = 0$, which is $A_z(1+x^2)=0$. Since $1+x^2 \\neq 0$, we must have $A_z=0$.\nThen $A_y = -xA_z = 0$.\nFinally, from $(i)$, $B_x = A_z p_y = 0 \\cdot p_y = 0$.\n\nThe components of $Y_z$ are:\n$A_x=0$, $A_y=0$, $A_z=0$\n$B_x=0$, $B_y=-\\frac{x}{1+x^2}$, $B_z=-\\frac{x^2}{1+x^2}$\nSo the vector field $Y_z$ is:\n$$\nY_z = -\\frac{x}{1+x^2} \\frac{\\partial}{\\partial p_y} - \\frac{x^2}{1+x^2} \\frac{\\partial}{\\partial p_z}\n$$\nNow we can compute the nonholonomic bracket:\n$$\n\\{z, p_y\\}_{\\mathrm{nh}} = \\mathrm{d}p_y(Y_z) = \\mathrm{d}p_y \\left( -\\frac{x}{1+x^2} \\frac{\\partial}{\\partial p_y} - \\frac{x^2}{1+x^2} \\frac{\\partial}{\\partial p_z} \\right)\n$$\nApplying the one-form $\\mathrm{d}p_y$ to the vector field $Y_z$ extracts the coefficient of the $\\frac{\\partial}{\\partial p_y}$ component.\n$$\n\\{z, p_y\\}_{\\mathrm{nh}} = -\\frac{x}{1+x^2}\n$$\nThis is the explicit analytic expression for the nonholonomic bracket as a function on $M$ (specifically, a function of the coordinate $x$).",
            "answer": "$$\\boxed{-\\frac{x}{1+x^{2}}}$$"
        },
        {
            "introduction": "The failure of the Jacobi identity is the defining characteristic of an almost-Poisson structure, distinguishing it from the true Poisson structure of unconstrained Hamiltonian systems. This exercise provides an explicit bivector $\\Pi$ and asks you to compute its Jacobiator for the coordinate functions (). A non-zero result serves as a direct and tangible confirmation of the \"almost\" nature of the bracket, a consequence of the underlying non-integrable constraints.",
            "id": "3780342",
            "problem": "Consider a mechanical system with configuration manifold $Q = \\mathbb{R}^{3}$ and global coordinates $(x,y,z)$. Assume nonholonomic constraints lead, after reduction, to an almost-Poisson bracket on $C^{\\infty}(Q)$ determined by a bivector field $\\Pi$ in the following coordinate form:\n$$\n\\Pi(x,y,z) \\;=\\; x\\,\\partial_{x}\\wedge\\partial_{y} \\;+\\; y\\,\\partial_{y}\\wedge\\partial_{z} \\;+\\; z\\,\\partial_{z}\\wedge\\partial_{x}.\n$$\nBy definition, the associated bracket of smooth functions $f,g \\in C^{\\infty}(Q)$ is\n$$\n\\{f,g\\}(x,y,z) \\;=\\; \\Pi(df,dg) \\;=\\; x\\left(\\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial y} - \\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial x}\\right) \\;+\\; y\\left(\\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial z} - \\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial y}\\right) \\;+\\; z\\left(\\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial x} - \\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial z}\\right).\n$$\nThe Jacobiator $J$ of this bracket is the trilinear map on $C^{\\infty}(Q)$ defined by\n$$\nJ(f,g,h) \\;=\\; \\{f,\\{g,h\\}\\} \\;+\\; \\{g,\\{h,f\\}\\} \\;+\\; \\{h,\\{f,g\\}\\}.\n$$\nUsing coordinate techniques and computational verification starting only from these definitions, compute the value of the Jacobiator $J(x,y,z)$ at the point $(x,y,z)=(1,1,1)$. Express your final answer as a real number. No rounding is needed.",
            "solution": "The problem requires the computation of the Jacobiator $J(f,g,h)$ for the specific functions $f=x$, $g=y$, and $h=z$, evaluated at the point $(x,y,z) = (1,1,1)$. The Jacobiator is defined as:\n$$\nJ(f,g,h) \\;=\\; \\{f,\\{g,h\\}\\} \\;+\\; \\{g,\\{h,f\\}\\} \\;+\\; \\{h,\\{f,g\\}\\}\n$$\nThe almost-Poisson bracket is given by the formula:\n$$\n\\{f,g\\} \\;=\\; x\\left(\\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial y} - \\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial x}\\right) \\;+\\; y\\left(\\frac{\\partial f}{\\partial y}\\frac{\\partial g}{\\partial z} - \\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial y}\\right) \\;+\\; z\\left(\\frac{\\partial f}{\\partial z}\\frac{\\partial g}{\\partial x} - \\frac{\\partial f}{\\partial x}\\frac{\\partial g}{\\partial z}\\right)\n$$\nWe are asked to compute $J(x,y,z)$, which is shorthand for $J(f=x, g=y, h=z)$. The expression to evaluate is:\n$$\nJ(x,y,z) \\;=\\; \\{x, \\{y,z\\}\\} \\;+\\; \\{y, \\{z,x\\}\\} \\;+\\; \\{z, \\{x,y\\}\\}\n$$\nThe calculation proceeds in two stages. First, we compute the inner brackets $\\{y,z\\}$, $\\{z,x\\}$, and $\\{x,y\\}$.\n\nStep 1: Compute the inner brackets.\n\n1a. Calculation of $\\{y,z\\}$:\nLet $f = y$ and $g = z$. The partial derivatives are $\\frac{\\partial f}{\\partial y} = 1$ and $\\frac{\\partial g}{\\partial z} = 1$, with all others being zero.\nSubstituting these into the bracket formula:\n$$\n\\{y,z\\} = x\\left(0\\right) + y\\left((1)(1) - (0)(0)\\right) + z\\left(0\\right) = y\n$$\n\n1b. Calculation of $\\{z,x\\}$:\nLet $f = z$ and $g = x$. The partial derivatives are $\\frac{\\partial f}{\\partial z} = 1$ and $\\frac{\\partial g}{\\partial x} = 1$.\nSubstituting these into the bracket formula:\n$$\n\\{z,x\\} = x\\left(0\\right) + y\\left(0\\right) + z\\left((1)(1) - (0)(0)\\right) = z\n$$\n\n1c. Calculation of $\\{x,y\\}$:\nLet $f = x$ and $g = y$. The partial derivatives are $\\frac{\\partial f}{\\partial x} = 1$ and $\\frac{\\partial g}{\\partial y} = 1$.\nSubstituting these into the bracket formula:\n$$\n\\{x,y\\} = x\\left((1)(1) - (0)(0)\\right) + y\\left(0\\right) + z\\left(0\\right) = x\n$$\nTo summarize the results from Step 1:\n$$\n\\{y,z\\} = y, \\quad \\{z,x\\} = z, \\quad \\{x,y\\} = x\n$$\n\nStep 2: Compute the outer brackets and sum them.\nNow we substitute the results from Step 1 into the expression for the Jacobiator:\n$$\nJ(x,y,z) = \\{x, \\{y,z\\}\\} + \\{y, \\{z,x\\}\\} + \\{z, \\{x,y\\}\\}\n$$\n$$\nJ(x,y,z) = \\{x, y\\} + \\{y, z\\} + \\{z, x\\}\n$$\nWe have already computed these brackets in Step 1. We substitute their values again:\n$$\nJ(x,y,z) = x + y + z\n$$\nThis is the general expression for the Jacobiator $J(x,y,z)$.\n\nStep 3: Evaluate the Jacobiator at the given point.\nThe problem requires the value of the Jacobiator at the point $(x,y,z)=(1,1,1)$.\n$$\nJ(1,1,1) = 1 + 1 + 1 = 3\n$$\nThe value of the Jacobiator $J(x,y,z)$ at the point $(1,1,1)$ is $3$. The non-zero result confirms that the given bivector $\\Pi$ defines an almost-Poisson structure that is not a true Poisson structure, as the Jacobi identity is not satisfied for the coordinate functions.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "Building on the previous exercises, this final practice delves into the systematic framework of nonholonomic reduction theory and symbolic computation. You will design an algorithm to compute the structure functions $c_{ij}^k(q)$ that encode the non-integrability of the constraint distribution and define the reduced nonholonomic bracket (). This task bridges the gap between theoretical geometry—Lie brackets of vector fields and metric projections—and its practical implementation, providing a powerful tool to analyze complex systems with symmetries like the rolling disk.",
            "id": "3759692",
            "problem": "Consider a mechanical system with configuration manifold given by the product of smooth manifolds, modeled as a coordinate chart with $n$ local coordinates $q = (q^1,\\dots,q^n)$. Let the Lagrangian be of mechanical type $L(q,\\dot{q}) = \\tfrac{1}{2} \\dot{q}^{\\mathsf{T}} M(q) \\dot{q} - V(q)$, where $M(q)$ is a positive-definite mass matrix, and $V(q)$ is a potential. Let there be linear nonholonomic (velocity-dependent, non-integrable) constraints $A(q) \\dot{q} = 0$ of constant rank $m$, defining the constraint distribution $\\mathcal{D}(q) = \\ker A(q) \\subset T_q Q$ of dimension $d = n - m$. Assume a free and proper symmetry group action by the Special Euclidean group in two dimensions $\\operatorname{SE(2)}$ or a subgroup thereof, with the constraints and Lagrangian invariant under the symmetry.\n\nDefine a local basis of vector fields $\\{X_i(q)\\}_{i=1}^d$ spanning $\\mathcal{D}(q)$, with each $X_i(q)$ expressed in the coordinate basis as $X_i(q) = \\sum_{k=1}^n X_i^k(q) \\tfrac{\\partial}{\\partial q^k}$. Denote by $[X_i,X_j]$ the Lie bracket of vector fields. The reduced nonholonomic bracket on the cotangent bundle of the shape space associated to the distribution and symmetry can be expressed in terms of the structure functions $c_{ij}^k(q)$ defined by the projection of $[X_i,X_j]$ onto $\\mathcal{D}(q)$ with respect to the kinetic energy metric given by $M(q)$. Specifically, let $P_{\\mathcal{D}}(q)$ be the metric orthogonal projector onto $\\mathcal{D}(q)$, and define $c_{ij}^k(q)$ by the equation $P_{\\mathcal{D}}(q)[X_i,X_j] = \\sum_{k=1}^d c_{ij}^k(q) X_k(q)$. Then the almost-Poisson nonholonomic bracket on quasi-coordinates $(q^i,p_i)$ adapted to the frame $\\{X_i\\}$ is given by:\n- $\\{q^i,q^j\\}_{\\mathrm{nh}} = 0$,\n- $\\{q^i,p_j\\}_{\\mathrm{nh}} = \\delta^i_j$,\n- $\\{p_i,p_j\\}_{\\mathrm{nh}} = -\\sum_{k=1}^d c_{ij}^k(q) p_k$,\nwhere $\\delta^i_j$ is the Kronecker delta.\n\nYour task is to design and implement an algorithm that, given the constraint basis $\\{X_i\\}$, the mass matrix $M(q)$, and symmetry data indicating which coordinates are reduced out, computes the reduced nonholonomic bracket structure functions $c_{ij}^k(q)$ symbolically through differentiation and projection, and evaluates them at specified states. You must validate the algorithm on the rolling disk example reduced by planar translations, where the configuration is $q = (x,y,\\theta,\\phi)$ with $x$ and $y$ the planar coordinates, $\\theta$ the heading angle, and $\\phi$ the spin angle, both angles in radians. The no-slip constraints are encoded by the distribution basis\n$$\nX_1(q) = \\frac{\\partial}{\\partial \\theta},\\quad\nX_2(q) = \\frac{\\partial}{\\partial \\phi} + R \\cos(\\theta) \\frac{\\partial}{\\partial x} + R \\sin(\\theta) \\frac{\\partial}{\\partial y},\n$$\nwhich is invariant under planar translations (the symmetry subgroup of $\\operatorname{SE(2)}$ acting by $(x,y) \\mapsto (x+a,y+b)$ for $(a,b)\\in\\mathbb{R}^2$). Use a diagonal mass matrix $M(q) = \\operatorname{diag}(m_x,m_y,I_\\theta,I_\\phi)$ with positive constants $m_x$, $m_y$, $I_\\theta$, $I_\\phi$, and radius $R>0$. The reduced bracket after translation symmetry restricts to the shape variables $(\\theta,\\phi)$ and their associated momenta $(p_\\theta,p_\\phi)$.\n\nAlgorithmic requirements:\n- Represent each basis vector field $X_i(q)$ by its coordinate components $X_i^k(q)$ and its Jacobian $\\partial X_i^k / \\partial q^\\ell$ for all indices $k,\\ell$.\n- Compute the Lie bracket $[X_i,X_j]$ using the definition $[X_i,X_j]^k(q) = \\sum_{\\ell=1}^n \\left( X_i^\\ell(q) \\frac{\\partial X_j^k}{\\partial q^\\ell}(q) - X_j^\\ell(q) \\frac{\\partial X_i^k}{\\partial q^\\ell}(q) \\right)$.\n- Project $[X_i,X_j]$ onto $\\mathcal{D}(q)$ with respect to the kinetic metric induced by $M(q)$ using the $M(q)$-orthogonal projector onto $\\operatorname{span}\\{X_1(q),\\dots,X_d(q)\\}$:\n$$\nP_{\\mathcal{D}}(q) = X(q) \\left(X(q)^{\\mathsf{T}} M(q) X(q)\\right)^{-1} X(q)^{\\mathsf{T}} M(q),\n$$\nwhere $X(q)$ is the $n\\times d$ matrix whose columns are the vectors $X_i(q)$.\n- Solve for the coefficients $c_{ij}^k(q)$ from the identity $P_{\\mathcal{D}}(q)[X_i,X_j] = \\sum_{k=1}^d c_{ij}^k(q) X_k(q)$ by expressing the projection in the basis $\\{X_k(q)\\}$ using the metric Gram matrix $G(q) = X(q)^{\\mathsf{T}} M(q) X(q)$ and inner products:\n$$\nc_{ij}(q) = G(q)^{-1} X(q)^{\\mathsf{T}} M(q) [X_i,X_j](q),\n$$\nwhere $c_{ij}(q)$ is the $d$-vector with components $c_{ij}^k(q)$.\n\nInstructions for physical units and angles:\n- All angles must be in radians.\n- The mass matrix entries $m_x$, $m_y$ are in kilograms, $I_\\theta$, $I_\\phi$ are moments of inertia in kilogram-meter squared, and $R$ is in meters. Since the outputs are dimensionless structure functions $c_{ij}^k(q)$, you do not need to scale units in the output.\n\nTest suite:\n- Case $1$ (Rolling disk, baseline): $R = 1$, $m_x = 1$, $m_y = 1$, $I_\\theta = 1$, $I_\\phi = 1$, state $q = (x,y,\\theta,\\phi) = (0,0,0,0)$.\n- Case $2$ (Rolling disk, nontrivial angle): $R = 1$, $m_x = 2$, $m_y = 3$, $I_\\theta = 0.5$, $I_\\phi = 0.75$, state $q = (x,y,\\theta,\\phi) = (1,-1,\\pi/4,1)$.\n- Case $3$ (Toy anholonomic frame on $\\mathbb{R}^2$): $q = (q^1,q^2)$, $X_1 = \\tfrac{\\partial}{\\partial q^1}$, $X_2 = \\mathrm{e}^{q^1} \\tfrac{\\partial}{\\partial q^2}$, $M = \\operatorname{diag}(1,1)$, state $q = (0,0)$.\n- Case $4$ (Toy anholonomic frame on $\\mathbb{R}^2$ with coupling): $q = (q^1,q^2)$, $X_1 = \\tfrac{\\partial}{\\partial q^1} + q^2 \\tfrac{\\partial}{\\partial q^2}$, $X_2 = \\tfrac{\\partial}{\\partial q^2}$, $M = \\operatorname{diag}(1,1)$, state $q = (0,1)$.\n\nFor each case, compute the pair $\\left(c_{12}^1(q), c_{12}^2(q)\\right)$ evaluated at the specified state (using the appropriate dimension $d$ for the frame). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each case reported as a list of two floating-point numbers, in the order of the cases above, for example $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$.",
            "solution": "The core of the problem is to compute the structure functions $c_{ij}^k(q)$ using the provided formula:\n$$\nc_{ij}(q) = G(q)^{-1} X(q)^{\\mathsf{T}} M(q) [X_i,X_j](q),\n$$\nwhere $G(q) = X(q)^{\\mathsf{T}} M(q) X(q)$ is the metric Gram matrix. The vector $c_{ij}(q)$ contains the components $c_{ij}^k(q)$.\n\nThe implemented algorithm proceeds as follows for each test case:\n1. For the specified pair of basis vectors $(X_1, X_2)$, compute their Lie bracket $[X_1, X_2]$ using the coordinate formula.\n2. Construct the basis matrix $X(q)$ whose columns are the vectors $X_1(q)$ and $X_2(q)$.\n3. Construct the mass matrix $M(q)$.\n4. Compute the Gram matrix $G(q) = X(q)^{\\mathsf{T}} M(q) X(q)$.\n5. Compute the vector of inner products $b = X(q)^{\\mathsf{T}} M(q) [X_1, X_2](q)$.\n6. Solve the linear system $G(q) c_{12}(q) = b$ for the coefficient vector $c_{12}(q)$.\n7. Evaluate the components $(c_{12}^1, c_{12}^2)$ at the specified state $q$.\n\n**Validation of Test Cases:**\n\n**Rolling Disk (Cases 1 & 2):**\nThe basis vectors are $X_1 = \\partial_\\theta$ and $X_2 = R \\cos\\theta \\partial_x + R \\sin\\theta \\partial_y + \\partial_\\phi$. Their Lie bracket is $[X_1, X_2] = -R\\sin\\theta\\partial_x + R\\cos\\theta\\partial_y$. Let $w = [X_1, X_2]$.\nThe coefficients are found by solving $Gc=b$, where $b_k = \\langle X_k, w \\rangle_M$.\n$$\nb_1 = \\langle X_1, w \\rangle_M = X_1^{\\mathsf{T}} M w = 0 \\quad (\\text{as } X_1 \\text{ and } w \\text{ are M-orthogonal for a diagonal metric)}\n$$\n$$\nb_2 = \\langle X_2, w \\rangle_M = X_2^{\\mathsf{T}} M w = -m_x R^2 \\cos\\theta \\sin\\theta + m_y R^2 \\sin\\theta \\cos\\theta = R^2 \\sin\\theta \\cos\\theta (m_y - m_x)\n$$\nThe Gram matrix $G$ is diagonal since $\\langle X_1, X_2 \\rangle_M = 0$:\n$G_{11} = I_\\theta$ and $G_{22} = m_x R^2\\cos^2\\theta + m_y R^2\\sin^2\\theta + I_\\phi$.\nSolving for $c$ gives $c_{12}^1 = b_1/G_{11} = 0$ and $c_{12}^2 = b_2/G_{22} = \\frac{R^2 \\sin\\theta \\cos\\theta (m_y - m_x)}{m_x R^2\\cos^2\\theta + m_y R^2\\sin^2\\theta + I_\\phi}$.\n- **Case 1:** $m_x = m_y = 1$. The term $(m_y-m_x)$ is zero, so $b_2=0$ and $c_{12}^2=0$. Result: $(0.0, 0.0)$.\n- **Case 2:** $m_x \\neq m_y$. The term $(m_y-m_x)$ is non-zero, so $c_{12}^2 \\neq 0$. The algorithm computes this non-zero value.\n\n**Toy Anholonomic Frame on $\\mathbb{R}^2$ (Case 3):**\n$X_1 = \\partial_1$, $X_2 = e^{q^1}\\partial_2$, $M=I$. The Lie bracket is $[X_1, X_2] = e^{q^1}\\partial_2 = X_2$.\nThe basis is orthogonal with $M=I$, so we can read the coefficients by inspection: $[X_1, X_2] = 0 \\cdot X_1 + 1 \\cdot X_2$.\nResult: $(0.0, 1.0)$.\n\n**Toy Anholonomic Frame on $\\mathbb{R}^2$ with Coupling (Case 4):**\n$X_1 = \\partial_1 + q^2\\partial_2$, $X_2 = \\partial_2$, $M=I$. The Lie bracket is $[X_1, X_2] = -\\partial_2 = -X_2$.\nSince $[X_1, X_2]$ is a multiple of a basis vector, we can write $[X_1, X_2] = 0 \\cdot X_1 - 1 \\cdot X_2$. Although the basis is not orthogonal, in this simple case where the result lies along one basis vector, the coefficients are still evident. The general algorithm confirms this.\nResult: $(0.0, -1.0)$.\n\nThe algorithm implemented in the provided code correctly follows the general procedure, using matrix operations to solve for the coefficients, which is robust for both orthogonal and non-orthogonal bases. The numerical outputs are calculated based on this rigorous method.\nThe expected outputs are:\n- Case 1: $[0.0, 0.0]$\n- Case 2: $[0.0, \\approx 0.1538]$\n- Case 3: $[0.0, 1.0]$\n- Case 4: $[0.0, -1.0]$\n\nThe final program prints these results in the required single-line format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lie_bracket(Xi, JXi, Xj, JXj):\n    \"\"\"\n    Compute the Lie bracket [Xi, Xj] in coordinate components.\n    Xi, Xj: vectors of length n representing the components X_i^k(q), X_j^k(q).\n    JXi, JXj: Jacobians of Xi, Xj w.r.t. q, shape (n, n), where entry (k, l) = d X^k / d q^l.\n    Returns: vector w of length n, the components of [Xi, Xj].\n    \"\"\"\n    # [Xi, Xj]^k = sum_l Xi^l * d Xj^k / d q^l - Xj^l * d Xi^k / d q^l\n    # We can implement this via matrix-vector products across columns of Jacobians.\n    # Take columns of JXj: each column l is d Xj / d q^l (vector of length n).\n    # Then sum_l Xi[l] * JXj[:, l] -> n-vector. Similarly for the second term.\n    term1 = JXj @ Xi  # sum_l Xi[l] * JXj[:, l]\n    term2 = JXi @ Xj  # sum_l Xj[l] * JXi[:, l]\n    return term1 - term2\n\ndef project_coefficients(w, X_basis, M):\n    \"\"\"\n    Project the vector w onto the span of columns of X_basis using the M-inner product,\n    and return the coefficients c solving P_D w = sum_k c_k X_k.\n    X_basis: n x d matrix whose columns are the basis vectors X_k(q).\n    M: n x n positive-definite mass matrix.\n    Returns: c: d-vector of coefficients.\n    \"\"\"\n    # Gram matrix G = X^T M X\n    G = X_basis.T @ M @ X_basis\n    # Right-hand side b = X^T M w\n    b = X_basis.T @ M @ w\n    # Solve G c = b\n    c = np.linalg.solve(G, b)\n    return c\n\n# Rolling disk frame on Q=R^2 x S^1 x S^1 with q=(x,y,theta,phi)\ndef rolling_disk_frame(q, R, M_diag):\n    \"\"\"\n    Returns basis vectors X1, X2 and their Jacobians at state q for the rolling disk.\n    q: array-like of length 4: [x, y, theta, phi]\n    R: radius\n    M_diag: diagonal entries of mass matrix [m_x, m_y, I_theta, I_phi]\n    \"\"\"\n    x, y, theta, phi = q\n    n = 4\n    # X1 = d/d theta\n    X1 = np.array([0.0, 0.0, 1.0, 0.0])\n    # Jacobian of X1 is zero (constant components)\n    JX1 = np.zeros((n, n))\n    # X2 = d/d phi + R cos(theta) d/d x + R sin(theta) d/d y\n    X2 = np.array([R * np.cos(theta), R * np.sin(theta), 0.0, 1.0])\n    JX2 = np.zeros((n, n))\n    # Derivatives with respect to theta affect x and y components\n    JX2[0, 2] = -R * np.sin(theta)  # d (R cos theta) / d theta\n    JX2[1, 2] = R * np.cos(theta)   # d (R sin theta) / d theta\n    # Mass matrix M\n    M = np.diag(M_diag)\n    return X1, JX1, X2, JX2, M\n\n# Toy frame 1 on R^2: X1 = d/d q1, X2 = e^{q1} d/d q2\ndef toy_frame_exp(q):\n    \"\"\"\n    q: array-like of length 2: [q1, q2]\n    Returns X1, JX1, X2, JX2, M for toy frame with exponential scaling.\n    \"\"\"\n    q1, q2 = q\n    n = 2\n    X1 = np.array([1.0, 0.0])\n    JX1 = np.zeros((n, n))\n    X2 = np.array([0.0, np.exp(q1)])\n    JX2 = np.zeros((n, n))\n    # d X2^2 / d q1 = e^{q1}\n    JX2[1, 0] = np.exp(q1)\n    M = np.eye(n)\n    return X1, JX1, X2, JX2, M\n\n# Toy frame 2 on R^2: X1 = d/d q1 + q2 d/d q2, X2 = d/d q2\ndef toy_frame_coupled(q):\n    \"\"\"\n    q: array-like of length 2: [q1, q2]\n    Returns X1, JX1, X2, JX2, M for toy frame with coupling.\n    \"\"\"\n    q1, q2 = q\n    n = 2\n    X1 = np.array([1.0, q2])\n    JX1 = np.zeros((n, n))\n    # d X1^2 / d q2 = 1\n    JX1[1, 1] = 1.0\n    X2 = np.array([0.0, 1.0])\n    JX2 = np.zeros((n, n))\n    M = np.eye(n)\n    return X1, JX1, X2, JX2, M\n\ndef compute_c12(frame_data):\n    \"\"\"\n    Given frame data returning (X1, JX1, X2, JX2, M), compute (c12^1, c12^2).\n    \"\"\"\n    X1, JX1, X2, JX2, M = frame_data\n    # Compute commutator [X1, X2]\n    w = lie_bracket(X1, JX1, X2, JX2)\n    # Build basis matrix X = [X1, X2]\n    X_basis = np.column_stack((X1, X2))\n    # Project and get coefficients\n    c12 = project_coefficients(w, X_basis, M)\n    # Return as two floats\n    return float(c12[0]), float(c12[1])\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: Rolling disk, baseline\n    R1 = 1.0\n    M_diag1 = [1.0, 1.0, 1.0, 1.0]\n    q1 = np.array([0.0, 0.0, 0.0, 0.0])\n    frame1 = rolling_disk_frame(q1, R1, M_diag1)\n\n    # Case 2: Rolling disk, nontrivial angle\n    R2 = 1.0\n    M_diag2 = [2.0, 3.0, 0.5, 0.75]\n    q2 = np.array([1.0, -1.0, np.pi/4.0, 1.0])\n    frame2 = rolling_disk_frame(q2, R2, M_diag2)\n\n    # Case 3: Toy anholonomic frame on R^2\n    q3 = np.array([0.0, 0.0])\n    frame3 = toy_frame_exp(q3)\n\n    # Case 4: Toy anholonomic frame on R^2 with coupling\n    q4 = np.array([0.0, 1.0])\n    frame4 = toy_frame_coupled(q4)\n\n    test_cases = [frame1, frame2, frame3, frame4]\n\n    results = []\n    for frame in test_cases:\n        c1, c2 = compute_c12(frame)\n        # Format each case result as [c1,c2]\n        results.append([c1, c2])\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists\n    print(f\"[{','.join(['[' + ','.join(map(str, r)) + ']' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}