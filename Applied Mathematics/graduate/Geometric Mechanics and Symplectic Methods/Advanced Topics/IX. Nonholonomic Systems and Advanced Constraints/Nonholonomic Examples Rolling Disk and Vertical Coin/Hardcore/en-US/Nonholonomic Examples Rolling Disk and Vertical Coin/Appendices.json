{
    "hands_on_practices": [
        {
            "introduction": "To begin our hands-on exploration, we first must understand how nonholonomic constraints manifest themselves in the language of dynamics. While we often think of constraints in terms of positions (holonomic), the rolling disk introduces constraints on velocities. This exercise  challenges you to apply the Lagrange–d’Alembert principle to determine the forces that arise to enforce these velocity constraints, revealing precisely how they cause the planar momenta, which would otherwise be conserved, to change over time.",
            "id": "3759503",
            "problem": "Consider a uniform, upright, thin disk (the “vertical coin”) of mass $m$ and radius $R$ rolling on a horizontal plane. Let $(x,y) \\in \\mathbb{R}^2$ denote the planar position of the disk’s center, and let $\\theta \\in \\mathbb{R}/2\\pi\\mathbb{Z}$ denote the in-plane orientation (heading) of the disk’s diameter, measured from the $x$-axis. Let $\\phi \\in \\mathbb{R}/2\\pi\\mathbb{Z}$ denote the spin angle of the disk about its symmetry axis. The configuration space is the Special Euclidean Group in two dimensions times a circle, $\\mathrm{SE}(2)\\times S^{1}$. The kinetic energy is given by\n$$\nT=\\frac{1}{2}m\\big(\\dot{x}^{2}+\\dot{y}^{2}\\big)+\\frac{1}{2}I_{\\theta}\\dot{\\theta}^{2}+\\frac{1}{2}I_{\\phi}\\dot{\\phi}^{2},\n$$\nwhere $I_{\\theta}$ and $I_{\\phi}$ are the appropriate moments of inertia about the axes associated with $\\theta$ and $\\phi$, respectively. There is no $x$–$y$ potential energy, since the horizontal plane constrains vertical motion and gravity is balanced by the normal reaction.\n\nAssume the nonholonomic no-slip constraint that forbids lateral (sideways) slip of the coin:\n$$\n\\dot{x}\\sin\\theta-\\dot{y}\\cos\\theta=0.\n$$\nThis is a linear nonholonomic (velocity-dependent, non-integrable) constraint defining the allowable velocity distribution $D \\subset TQ$. The nonholonomic dynamics are governed by the Lagrange–d’Alembert principle: the equations of motion are the Euler–Lagrange equations with generalized forces equal to the constraint reaction forces, which lie in the annihilator $D^{\\circ}$ of the constraint distribution.\n\nStarting from the Lagrange–d’Alembert principle and the constraint above, derive the evolution equations for the planar translation momenta\n$$\np_{x}=\\frac{\\partial T}{\\partial \\dot{x}}=m\\dot{x},\\qquad p_{y}=\\frac{\\partial T}{\\partial \\dot{y}}=m\\dot{y},\n$$\nin the presence of the no-slip constraint, and show explicitly how the constraint forces modify their rates of change. Express your final answer for $\\big(\\dot{p}_{x},\\dot{p}_{y}\\big)$ in terms of the Lagrange multiplier $\\lambda$ associated with the no-slip constraint and the orientation $\\theta$.\n\nProvide your final answer as a single analytic expression for the two components together, using a row matrix. If you were to substitute numerical values, express each component in Newtons.",
            "solution": "The problem is valid. It presents a standard, well-posed scenario in nonholonomic mechanics that is scientifically sound and internally consistent. We can proceed with the derivation.\n\nThe dynamics of the system are governed by the Lagrange–d’Alembert principle. The Lagrangian $L$ of the system is equal to its kinetic energy $T$, as the potential energy is zero. The kinetic energy is given as:\n$$\nL = T = \\frac{1}{2}m\\big(\\dot{x}^{2}+\\dot{y}^{2}\\big)+\\frac{1}{2}I_{\\theta}\\dot{\\theta}^{2}+\\frac{1}{2}I_{\\phi}\\dot{\\phi}^{2}\n$$\nThe system is subject to a single nonholonomic constraint:\n$$\nC(q, \\dot{q}) = \\dot{x}\\sin\\theta - \\dot{y}\\cos\\theta = 0\n$$\nThis constraint is a Pfaffian constraint of the form $\\sum_{i} \\omega_i(q)\\dot{q}^i = 0$. For our system with generalized coordinates $q = (x, y, \\theta, \\phi)$, the corresponding constraint one-form is:\n$$\n\\omega = \\sin\\theta \\, dx - \\cos\\theta \\, dy + 0 \\, d\\theta + 0 \\, d\\phi\n$$\nThe Lagrange–d’Alembert principle states that the equations of motion are given by:\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}^i}\\right) - \\frac{\\partial L}{\\partial q^i} = Q_i\n$$\nwhere $Q_i$ are the generalized constraint forces. These forces are determined by the constraint one-form and a Lagrange multiplier, $\\lambda$. The total constraint force covector (one-form) is $\\lambda \\omega$. The generalized force $Q_i$ is the coefficient of $dq^i$ in this covector.\nThus, for our coordinates, the generalized constraint forces are:\n$$\nQ_x = \\lambda \\sin\\theta\n$$\n$$\nQ_y = -\\lambda \\cos\\theta\n$$\n$$\nQ_\\theta = 0\n$$\n$$\nQ_\\phi = 0\n$$\nThe problem asks for the evolution equations for the planar translation momenta, $p_x$ and $p_y$. We derive these by applying the Lagrange–d’Alembert principle to the coordinates $x$ and $y$.\n\nFor the $x$ coordinate:\nThe generalized momentum conjugate to $x$ is defined as $p_x = \\frac{\\partial L}{\\partial \\dot{x}}$.\n$$\np_x = \\frac{\\partial}{\\partial \\dot{x}} \\left( \\frac{1}{2}m\\big(\\dot{x}^{2}+\\dot{y}^{2}\\big)+\\frac{1}{2}I_{\\theta}\\dot{\\theta}^{2}+\\frac{1}{2}I_{\\phi}\\dot{\\phi}^{2} \\right) = m\\dot{x}\n$$\nThe Lagrangian does not depend explicitly on $x$, so $\\frac{\\partial L}{\\partial x} = 0$. The coordinate $x$ is cyclic. In the absence of constraints, its conjugate momentum would be conserved.\nThe equation of motion for $x$ is:\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{x}}\\right) - \\frac{\\partial L}{\\partial x} = Q_x\n$$\nSubstituting the calculated terms:\n$$\n\\frac{d}{dt}(p_x) - 0 = \\lambda \\sin\\theta\n$$\n$$\n\\dot{p}_x = \\lambda \\sin\\theta\n$$\nThis equation shows that the rate of change of the $x$-momentum is equal to the $x$-component of the constraint force.\n\nFor the $y$ coordinate:\nSimilarly, the generalized momentum conjugate to $y$ is $p_y = \\frac{\\partial L}{\\partial \\dot{y}}$.\n$$\np_y = \\frac{\\partial}{\\partial \\dot{y}} \\left( \\frac{1}{2}m\\big(\\dot{x}^{2}+\\dot{y}^{2}\\big)+\\frac{1}{2}I_{\\theta}\\dot{\\theta}^{2}+\\frac{1}{2}I_{\\phi}\\dot{\\phi}^{2} \\right) = m\\dot{y}\n$$\nThe Lagrangian does not depend explicitly on $y$, so $\\frac{\\partial L}{\\partial y} = 0$. The coordinate $y$ is also cyclic.\nThe equation of motion for $y$ is:\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{y}}\\right) - \\frac{\\partial L}{\\partial y} = Q_y\n$$\nSubstituting the calculated terms:\n$$\n\\frac{d}{dt}(p_y) - 0 = -\\lambda \\cos\\theta\n$$\n$$\n\\dot{p}_y = -\\lambda \\cos\\theta\n$$\nThis equation shows that the rate of change of the $y$-momentum is equal to the $y$-component of the constraint force.\n\nThe vector $(\\dot{p}_x, \\dot{p}_y)$ represents the constraint force acting on the center of mass of the disk, required to enforce the no-slip condition. This force vector is $(\\lambda \\sin\\theta, -\\lambda\\cos\\theta)$, which is perpendicular to the disk's heading direction $(\\cos\\theta, \\sin\\theta)$, as expected for a force preventing lateral motion.\n\nThe evolution equations for the planar translation momenta are therefore:\n$$\n\\dot{p}_x = \\lambda \\sin\\theta\n$$\n$$\n\\dot{p}_y = -\\lambda \\cos\\theta\n$$\nAs requested, we express the result for $(\\dot{p}_x, \\dot{p}_y)$ as a single expression.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\lambda\\sin\\theta & -\\lambda\\cos\\theta\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Now that we have seen how constraints generate forces, we shift our focus to kinematics and control. A fascinating feature of nonholonomic systems is that even though instantaneous motion is restricted, a sequence of allowed motions can be used to reach any configuration. This exercise  delves into this concept of controllability by using the powerful tool of Lie brackets to demonstrate how steering and rolling maneuvers can be combined to generate motion in directions that are instantaneously forbidden.",
            "id": "3759469",
            "problem": "Consider the vertical rolling disk, modeled as a homogeneous disk of radius $r$ rolling without slipping on a horizontal plane. The configuration manifold is $Q = \\mathbb{R}^{2} \\times S^{1} \\times S^{1}$ with coordinates $(x,y,\\theta,\\phi)$, where $(x,y)$ is the position of the contact point on the plane, $\\theta$ is the body yaw (heading), and $\\phi$ is the spin (roll) angle of the disk. The rolling without slipping constraint implies that the instantaneous velocity of the contact point on the plane vanishes. Starting from the kinematic form of the no-slip constraints and the definition of velocity as the time derivative of position, derive the driftless control-affine system $\\dot{q} = u_{1} X_{1}(q) + u_{2} X_{2}(q)$ governing the disk, where $q = (x,y,\\theta,\\phi)$ and $u_{1},u_{2}$ are admissible controls. Then, impose a hard saturation on the spin rate so that $u_{1}$ is constrained to lie in the closed interval $[-s,s]$ for a given $s \\ge 0$ while $u_{2}$ remains unconstrained. Using only first principles (in particular, the rolling constraints, the definition of Lie bracket of vector fields, and the Lie Algebra Rank Condition), compute the scalar four-volume coefficient\n$$\n\\Delta = \\det\\begin{pmatrix}\nX_{1} & X_{2} & [X_{1},X_{2}] & [X_{2},[X_{1},X_{2}]]\n\\end{pmatrix},\n$$\ninterpreting the columns as the components of these vector fields expressed in the coordinate basis $(\\partial_{x},\\partial_{y},\\partial_{\\theta},\\partial_{\\phi})$ at an arbitrary configuration $(x,y,\\theta,\\phi)$. Your tasks are:\n- Derive $X_{1}$ and $X_{2}$ from the constraints, and compute $[X_{1},X_{2}]$ and $[X_{2},[X_{1},X_{2}]]$.\n- Evaluate the determinant $\\Delta$ analytically in terms of $r$ and $\\theta$.\n- Explain, in terms of the Lie Algebra Rank Condition and the structure of admissible controls, how saturating $u_{1}$ affects small-time local accessibility and delineate the condition on $s$ under which accessibility is lost.\n\nExpress your final reported value as the exact closed-form expression for $\\Delta$. No numerical rounding is required, and no physical units should be included in the final expression. Angles, if they appear, should be treated in radians.",
            "solution": "The problem is first validated and found to be well-posed, scientifically sound, and internally consistent. We may proceed with the solution.\n\nThe configuration of the vertical rolling disk is described by the state vector $q = (x, y, \\theta, \\phi) \\in \\mathbb{R}^{2} \\times S^{1} \\times S^{1}$, where $(x,y)$ are the coordinates of the contact point on the horizontal plane, $\\theta$ is the yaw angle (heading), and $\\phi$ is the spin angle of the disk. The disk has a radius $r$.\n\nThe rolling-without-slipping constraint dictates the velocity of the contact point $(\\dot{x}, \\dot{y})$. The velocity vector must be parallel to the direction of the disk's plane, which is given by the unit vector $(\\cos\\theta, \\sin\\theta)$. The magnitude of this velocity is determined by the rate of rolling, which is $r \\dot{\\phi}$. Combining these, we obtain the nonholonomic constraint equations:\n$$\n\\dot{x} = r \\dot{\\phi} \\cos\\theta\n$$\n$$\n\\dot{y} = r \\dot{\\phi} \\sin\\theta\n$$\nThese two equations describe the motion of the contact point. The evolution of the orientation angles $\\theta$ and $\\phi$ is governed by their respective angular velocities, the yaw rate $\\dot{\\theta}$ and the spin rate $\\dot{\\phi}$. These angular velocities are the natural control inputs for the system. We define the controls as $u_{1} = \\dot{\\phi}$ (spin rate) and $u_{2} = \\dot{\\theta}$ (yaw rate).\n\nSubstituting these controls into the kinematic equations, we can express the system dynamics in state-space form $\\dot{q} = f(q, u)$:\n$$\n\\dot{x} = r u_{1} \\cos\\theta\n$$\n$$\n\\dot{y} = r u_{1} \\sin\\theta\n$$\n$$\n\\dot{\\theta} = u_{2}\n$$\n$$\n\\dot{\\phi} = u_{1}\n$$\nThis system is in the driftless control-affine form $\\dot{q} = u_{1} X_{1}(q) + u_{2} X_{2}(q)$. By collecting the terms multiplying $u_{1}$ and $u_{2}$, we identify the control vector fields $X_{1}$ and $X_{2}$:\n$$\nX_{1}(q) = \\begin{pmatrix} r\\cos\\theta \\\\ r\\sin\\theta \\\\ 0 \\\\ 1 \\end{pmatrix} \\quad , \\quad X_{2}(q) = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\nIn the coordinate basis $(\\partial_{x}, \\partial_{y}, \\partial_{\\theta}, \\partial_{\\phi})$, these vector fields are:\n$$\nX_{1} = r\\cos\\theta \\, \\partial_{x} + r\\sin\\theta \\, \\partial_{y} + \\partial_{\\phi}\n$$\n$$\nX_{2} = \\partial_{\\theta}\n$$\nNext, we compute the required Lie brackets. The Lie bracket $[X, Y]$ of two vector fields $X$ and $Y$ can be computed using the formula $[X,Y] = (\\nabla Y)X - (\\nabla X)Y$, where $\\nabla$ is the Jacobian operator with respect to the state $q$.\n\nThe Jacobian of $X_{1}$ with respect to $q=(x,y,\\theta,\\phi)$ is:\n$$\n\\nabla X_{1} = \\frac{\\partial X_{1}}{\\partial q} = \\begin{pmatrix}\n\\partial_{x}X_{1x} & \\partial_{y}X_{1x} & \\partial_{\\theta}X_{1x} & \\partial_{\\phi}X_{1x} \\\\\n\\partial_{x}X_{1y} & \\partial_{y}X_{1y} & \\partial_{\\theta}X_{1y} & \\partial_{\\phi}X_{1y} \\\\\n\\partial_{x}X_{1\\theta} & \\partial_{y}X_{1\\theta} & \\partial_{\\theta}X_{1\\theta} & \\partial_{\\phi}X_{1\\theta} \\\\\n\\partial_{x}X_{1\\phi} & \\partial_{y}X_{1\\phi} & \\partial_{\\theta}X_{1\\phi} & \\partial_{\\phi}X_{1\\phi}\n\\end{pmatrix} = \\begin{pmatrix}\n0 & 0 & -r\\sin\\theta & 0 \\\\\n0 & 0 & r\\cos\\theta & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{pmatrix}\n$$\nThe vector field $X_{2}$ is constant, so its Jacobian is the zero matrix: $\\nabla X_{2} = \\mathbf{0}$.\n\nThe first Lie bracket is $[X_{1}, X_{2}]$:\n$$\n[X_{1}, X_{2}] = (\\nabla X_{2})X_{1} - (\\nabla X_{1})X_{2} = \\mathbf{0} \\cdot X_{1} - (\\nabla X_{1})X_{2} = -(\\nabla X_{1})X_{2}\n$$\n$$\n[X_{1}, X_{2}] = - \\begin{pmatrix}\n0 & 0 & -r\\sin\\theta & 0 \\\\\n0 & 0 & r\\cos\\theta & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = - \\begin{pmatrix} -r\\sin\\theta \\\\ r\\cos\\theta \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} r\\sin\\theta \\\\ -r\\cos\\theta \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\nThis vector field corresponds to an infinitesimal sideways motion, generated by alternating steering and rolling. Let us denote this a $X_{3} = [X_{1}, X_{2}]$.\n\nThe second required Lie bracket is $[X_{2}, [X_{1}, X_{2}]] = [X_{2}, X_{3}]$.\n$$\n[X_{2}, X_{3}] = (\\nabla X_{3})X_{2} - (\\nabla X_{2})X_{3} = (\\nabla X_{3})X_{2} - \\mathbf{0} \\cdot X_{3} = (\\nabla X_{3})X_{2}\n$$\nFirst, we compute the Jacobian of $X_{3}$:\n$$\n\\nabla X_{3} = \\frac{\\partial X_{3}}{\\partial q} = \\begin{pmatrix}\n0 & 0 & r\\cos\\theta & 0 \\\\\n0 & 0 & -(-r\\sin\\theta) & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{pmatrix} = \\begin{pmatrix}\n0 & 0 & r\\cos\\theta & 0 \\\\\n0 & 0 & r\\sin\\theta & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{pmatrix}\n$$\nNow we compute the bracket:\n$$\n[X_{2}, [X_{1}, X_{2}]] = \\begin{pmatrix}\n0 & 0 & r\\cos\\theta & 0 \\\\\n0 & 0 & r\\sin\\theta & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} r\\cos\\theta \\\\ r\\sin\\theta \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\nThis yields a new vector field, say $X_{4}$, representing forward motion without changing the spin angle $\\phi$.\n\nNow we compute the scalar four-volume coefficient $\\Delta$. This is the determinant of the matrix whose columns are the four vector fields we have determined: $X_{1}$, $X_{2}$, $[X_{1}, X_{2}]$, and $[X_{2}, [X_{1}, X_{2}]]$.\n$$\n\\Delta = \\det \\begin{pmatrix} X_{1} & X_{2} & [X_{1},X_{2}] & [X_{2},[X_{1},X_{2}]] \\end{pmatrix}\n$$\n$$\n\\Delta = \\det \\begin{pmatrix}\nr\\cos\\theta & 0 & r\\sin\\theta & r\\cos\\theta \\\\\nr\\sin\\theta & 0 & -r\\cos\\theta & r\\sin\\theta \\\\\n0 & 1 & 0 & 0 \\\\\n1 & 0 & 0 & 0\n\\end{pmatrix}\n$$\nWe compute the determinant via cofactor expansion. Expanding along the second column, which has only one non-zero entry at position $(3,2)$:\n$$\n\\Delta = (-1)^{3+2} \\cdot 1 \\cdot \\det \\begin{pmatrix}\nr\\cos\\theta & r\\sin\\theta & r\\cos\\theta \\\\\nr\\sin\\theta & -r\\cos\\theta & r\\sin\\theta \\\\\n1 & 0 & 0\n\\end{pmatrix} = - \\det \\begin{pmatrix}\nr\\cos\\theta & r\\sin\\theta & r\\cos\\theta \\\\\nr\\sin\\theta & -r\\cos\\theta & r\\sin\\theta \\\\\n1 & 0 & 0\n\\end{pmatrix}\n$$\nNext, we expand the $3 \\times 3$ determinant along its third row:\n$$\n\\Delta = - \\left( (-1)^{3+1} \\cdot 1 \\cdot \\det \\begin{pmatrix}\nr\\sin\\theta & r\\cos\\theta \\\\\n-r\\cos\\theta & r\\sin\\theta\n\\end{pmatrix} \\right) = - \\left( 1 \\cdot ((r\\sin\\theta)(r\\sin\\theta) - (r\\cos\\theta)(-r\\cos\\theta)) \\right)\n$$\n$$\n\\Delta = - (r^{2}\\sin^{2}\\theta + r^{2}\\cos^{2}\\theta) = -r^{2}(\\sin^{2}\\theta + \\cos^{2}\\theta)\n$$\n$$\n\\Delta = -r^{2}\n$$\nThe determinant is a constant value $-r^{2}$, independent of the configuration $(x,y,\\theta,\\phi)$.\n\nFinally, we analyze small-time local accessibility (STLA). The Lie Algebra Rank Condition (LARC) states that a driftless system is STLA from a point $q$ if the Lie algebra generated by its control vector fields spans the tangent space at $q$. The dimension of our configuration manifold $Q$ is $4$. The Lie algebra is spanned by the control fields and all their iterated brackets. We have found a set of $4$ vectors, $\\{X_{1}, X_{2}, [X_{1},X_{2}], [X_{2},[X_{1},X_{2}]]\\}$, whose linear independence is determined by the determinant $\\Delta$.\nSince $r$ is a physical radius, $r>0$, which implies $\\Delta = -r^{2} \\neq 0$. Thus, these four vector fields are linearly independent at every point $q$ and span the tangent space $T_{q}Q$. The Lie algebra generated by $\\{X_{1}, X_{2}\\}$ has rank $4$ everywhere.\n\nFor a system with control constraints, STLA is guaranteed by the LARC if the set of admissible control values $U$ contains the origin in its interior. Here, the control set is $U = [-s, s] \\times \\mathbb{R}$.\n\nCase 1: $s > 0$. The control set for $u_{1}$ is the interval $[-s, s]$, which contains $0$ as an interior point. The control set for $u_{2}$ is $\\mathbb{R}$, which also contains $0$ in its interior. Since the origin $(0,0)$ is an interior point of the control domain $U$ and the LARC is satisfied (rank is $4$), the system is small-time locally accessible. The saturation on $u_{1}$ limits the speed of maneuvers but does not eliminate the ability to move in all directions of the configuration space.\n\nCase 2: $s = 0$. The constraint becomes $u_{1}=0$. The control system degenerates to $\\dot{q} = u_{2} X_{2}(q)$. The only available control vector field is $X_{2}$. The Lie algebra generated by $\\{X_{2}\\}$ is simply $\\text{span}\\{X_{2}\\}$ (since $[X_2, X_2]=0$), which is a $1$-dimensional space. The rank of the Lie algebra is $1$, which is less than the manifold dimension of $4$. The LARC is violated. From any initial state, the system can only change its $\\theta$ coordinate, while $x, y,$ and $\\phi$ remain fixed. The system is not STLA.\n\nTherefore, small-time local accessibility is lost if and only if the saturation limit $s$ is exactly zero.\n\nThe question asks for the analytical expression for $\\Delta$.\n$$\n\\Delta = -r^{2}\n$$\nThis is the final analytical expression required.",
            "answer": "$$\\boxed{-r^{2}}$$"
        },
        {
            "introduction": "Having explored the analytical dynamics and control of the rolling disk, the final step is to bring these concepts to life through computation. Simulating nonholonomic systems accurately requires special numerical methods that respect the underlying geometric structure of the problem. This computational practice  guides you through the design and implementation of a structure-preserving integrator, a robust algorithm that enforces the velocity constraints at each discrete step, ensuring the simulation remains physically plausible and numerically stable over long periods.",
            "id": "3759448",
            "problem": "Implement, justify, and evaluate a structure-preserving time-stepping method for the nonholonomic vertical coin. The vertical coin is idealized as a thin rigid disk of radius $R$ rolling without slip on a horizontal plane. Its configuration variables are $q = (x, y, \\psi, \\phi)$, where $x$ and $y$ are the Cartesian coordinates of the center of the coin, $\\psi$ is the yaw angle (heading) of the coin in radians, and $\\phi$ is the spin angle (rotation about the coin’s symmetry axis) in radians. The coin’s velocity is $v = (\\dot{x}, \\dot{y}, \\dot{\\psi}, \\dot{\\phi})$. The Lagrangian is purely kinetic, $L(q, v) = T(v)$, with the kinetic energy specified by the diagonal mass matrix\n$$\nM = \\mathrm{diag}(m, m, I_{\\psi}, I_{\\phi}),\n$$\nso that\n$$\nT(v) = \\frac{1}{2} v^{\\mathsf{T}} M v = \\frac{1}{2} \\left( m \\dot{x}^{2} + m \\dot{y}^{2} + I_{\\psi} \\dot{\\psi}^{2} + I_{\\phi} \\dot{\\phi}^{2} \\right).\n$$\nAssume there is no potential energy and no external forces. The nonholonomic rolling constraints are linear in velocity and given by\n$$\n\\dot{x} - R \\dot{\\phi} \\cos \\psi = 0, \\quad \\dot{y} - R \\dot{\\phi} \\sin \\psi = 0,\n$$\nwhich define a constraint distribution $D(q) \\subset T_{q}Q$ as the set of velocities $v$ satisfying the above equalities at configuration $q$.\n\nStarting from first principles of mechanics (Newton’s laws and the Lagrange–d’Alembert principle), design and implement a time-stepping method that:\n- Enforces the nonholonomic constraints at each step in a way that is consistent with the constraint distribution $D(q)$ evaluated at an appropriate discrete configuration (use the midpoint configuration to define the constraints).\n- Is structure-preserving in the sense that it maintains the constraint distribution $D(q)$ to numerical precision and approximately conserves the kinetic energy when there are no external forces.\n\nYour method must be self-consistent and derived from a valid mechanical principle; do not use ad hoc corrections. In particular, you must treat the constraints at the velocity level and justify how they are enforced within your integrator. Angles must be treated in radians. All physical units must be specified and respected: $x$ and $y$ in meters, $R$ in meters, $m$ in kilograms, $I_{\\psi}$ and $I_{\\phi}$ in kilogram-square meters, time in seconds, angular quantities in radians, velocities in meters per second or radians per second, and energy in Joules.\n\nFor evaluation, define the following metrics for each simulation:\n- The maximum constraint violation magnitude over all steps,\n$$\n\\max_{n} \\left\\| A(q_{n+\\frac{1}{2}}) \\, v_{n+1} \\right\\|,\n$$\nwhere $A(q)$ is the $2 \\times 4$ matrix encoding the constraints so that $A(q) v = \\begin{bmatrix}\\dot{x} - R \\dot{\\phi} \\cos \\psi \\\\ \\dot{y} - R \\dot{\\phi} \\sin \\psi \\end{bmatrix}$, $q_{n+\\frac{1}{2}} = q_{n} + \\frac{h}{2} v_{n}$ is the midpoint configuration used to evaluate the constraints, $h$ is the time step in seconds, and $\\|\\cdot\\|$ is the Euclidean norm with units of meters per second.\n- The energy drift,\n$$\n\\Delta T = T(v_{\\mathrm{final}}) - T(v_{\\mathrm{init}}),\n$$\nin Joules, where $T$ is the kinetic energy, $v_{\\mathrm{init}}$ is the first post-projection velocity after performing one constraint-preserving step from the given initial condition, and $v_{\\mathrm{final}}$ is the velocity at the last time step.\n\nImplement your method and evaluate it on the following test suite. In each case, angles are in radians, and all other quantities are in the specified physical units.\n\nTest case $1$ (typical parameters, moderate step size):\n- $m = 1.0 \\, \\mathrm{kg}$, $R = 0.3 \\, \\mathrm{m}$, $I_{\\psi} = 0.12 \\, \\mathrm{kg \\, m^{2}}$, $I_{\\phi} = 0.045 \\, \\mathrm{kg \\, m^{2}}$.\n- $h = 0.01 \\, \\mathrm{s}$, $\\text{steps} = 1000$.\n- Initial configuration $q_{0} = (0.0 \\, \\mathrm{m}, 0.0 \\, \\mathrm{m}, 0.7 \\, \\mathrm{rad}, 0.0 \\, \\mathrm{rad})$.\n- Initial angular velocities $\\dot{\\phi}_{0} = 5.0 \\, \\mathrm{rad/s}$, $\\dot{\\psi}_{0} = 0.5 \\, \\mathrm{rad/s}$; set $\\dot{x}_{0} = R \\dot{\\phi}_{0} \\cos \\psi_{0}$ and $\\dot{y}_{0} = R \\dot{\\phi}_{0} \\sin \\psi_{0}$.\n\nTest case $2$ (small time step, initial constraint violation to be corrected):\n- $m = 0.8 \\, \\mathrm{kg}$, $R = 0.25 \\, \\mathrm{m}$, $I_{\\psi} = 0.10 \\, \\mathrm{kg \\, m^{2}}$, $I_{\\phi} = 0.03 \\, \\mathrm{kg \\, m^{2}}$.\n- $h = 10^{-4} \\, \\mathrm{s}$, $\\text{steps} = 5000$.\n- Initial configuration $q_{0} = (0.0 \\, \\mathrm{m}, 0.0 \\, \\mathrm{m}, 1.2 \\, \\mathrm{rad}, 0.0 \\, \\mathrm{rad})$.\n- Initial velocities $\\dot{x}_{0} = 0.1 \\, \\mathrm{m/s}$, $\\dot{y}_{0} = 0.0 \\, \\mathrm{m/s}$, $\\dot{\\psi}_{0} = -2.0 \\, \\mathrm{rad/s}$, $\\dot{\\phi}_{0} = 3.0 \\, \\mathrm{rad/s}$.\n\nTest case $3$ (large time step to probe energy behavior):\n- $m = 1.2 \\, \\mathrm{kg}$, $R = 0.35 \\, \\mathrm{m}$, $I_{\\psi} = 0.20 \\, \\mathrm{kg \\, m^{2}}$, $I_{\\phi} = 0.06 \\, \\mathrm{kg \\, m^{2}}$.\n- $h = 0.1 \\, \\mathrm{s}$, $\\text{steps} = 300$.\n- Initial configuration $q_{0} = (0.0 \\, \\mathrm{m}, 0.0 \\, \\mathrm{m}, 0.2 \\, \\mathrm{rad}, 0.0 \\, \\mathrm{rad})$.\n- Initial angular velocities $\\dot{\\phi}_{0} = 4.0 \\, \\mathrm{rad/s}$, $\\dot{\\psi}_{0} = 1.5 \\, \\mathrm{rad/s}$; set $\\dot{x}_{0} = R \\dot{\\phi}_{0} \\cos \\psi_{0}$ and $\\dot{y}_{0} = R \\dot{\\phi}_{0} \\sin \\psi_{0}$.\n\nTest case $4$ (high yaw rate, moderate step size):\n- $m = 0.9 \\, \\mathrm{kg}$, $R = 0.28 \\, \\mathrm{m}$, $I_{\\psi} = 0.15 \\, \\mathrm{kg \\, m^{2}}$, $I_{\\phi} = 0.04 \\, \\mathrm{kg \\, m^{2}}$.\n- $h = 0.02 \\, \\mathrm{s}$, $\\text{steps} = 800$.\n- Initial configuration $q_{0} = (0.0 \\, \\mathrm{m}, 0.0 \\, \\mathrm{m}, 1.0 \\, \\mathrm{rad}, 0.0 \\, \\mathrm{rad})$.\n- Initial angular velocities $\\dot{\\phi}_{0} = 3.0 \\, \\mathrm{rad/s}$, $\\dot{\\psi}_{0} = 10.0 \\, \\mathrm{rad/s}$; set $\\dot{x}_{0} = R \\dot{\\phi}_{0} \\cos \\psi_{0}$ and $\\dot{y}_{0} = R \\dot{\\phi}_{0} \\sin \\psi_{0}$.\n\nYour program must:\n- Implement the specified structure-preserving method.\n- For each test case, simulate the system and compute the two metrics: the maximum constraint violation magnitude in $\\mathrm{m/s}$ and the energy drift in $\\mathrm{J}$, as defined above.\n- Produce a single line of output containing the results aggregated as a comma-separated list enclosed in square brackets, where each test case contributes a list of two floats $[\\text{max\\_violation}, \\Delta T]$. The final format must be\n$$\n\\big[ [\\text{case1\\_max\\_violation}, \\text{case1\\_energy\\_drift}], [\\text{case2\\_max\\_violation}, \\text{case2\\_energy\\_drift}], [\\text{case3\\_max\\_violation}, \\text{case3\\_energy\\_drift}], [\\text{case4\\_max\\_violation}, \\text{case4\\_energy\\_drift}] \\big].\n$$\nAngles must be in radians, energies in Joules, and constraint violation magnitudes in meters per second.",
            "solution": "The problem requires the design and implementation of a structure-preserving time-stepping method for the nonholonomic dynamics of a vertical rolling coin. The method must be derived from first principles and correctly handle the nonholonomic constraints.\n\n### Principle-Based Derivation of the Integrator\n\nThe dynamics of the system are governed by the Lagrange–d’Alembert principle. The Lagrangian is purely kinetic, $L(q, \\dot{q}) = T(\\dot{q}) = \\frac{1}{2}\\dot{q}^{\\mathsf{T}} M \\dot{q}$, and does not depend on the configuration $q$. The system is subject to linear velocity constraints of the form $A(q)\\dot{q} = 0$. The equations of motion are:\n$$\n\\begin{cases}\nM\\ddot{q} = A(q)^{\\mathsf{T}} \\lambda \\\\\nA(q)\\dot{q} = 0\n\\end{cases}\n$$\nwhere $\\lambda$ is a vector of Lagrange multipliers representing the constraint forces.\n\nTo construct a structure-preserving numerical integrator, we discretize these equations in a way that respects the underlying geometric structure. We seek a scheme $(q_n, v_n) \\mapsto (q_{n+1}, v_{n+1})$ over a time step $h$. The problem specifies that the constraints must be evaluated at the explicit midpoint configuration $q_{n+\\frac{1}{2}} = q_n + \\frac{h}{2}v_n$.\n\nA robust and symmetric discretization, analogous to the RATTLE algorithm for holonomic systems, is formulated as follows:\n1.  **Momentum Update**: The differential equation for momentum, $M\\dot{v} = A(q)^{\\mathsf{T}}\\lambda$, is discretized using a finite difference centered at $t_{n+\\frac{1}{2}}$:\n    $$\n    M \\frac{v_{n+1} - v_n}{h} = A(q_{n+\\frac{1}{2}})^{\\mathsf{T}} \\lambda_{n+1}\n    $$\n2.  **Constraint Enforcement**: The nonholonomic constraint $A(q)v = 0$ is enforced on the new velocity $v_{n+1}$ using the constraint matrix evaluated at the midpoint configuration $q_{n+\\frac{1}{2}}$:\n    $$\n    A(q_{n+\\frac{1}{2}}) v_{n+1} = 0\n    $$\n3.  **Position Update**: The position is updated using a symmetric, second-order accurate trapezoidal rule, which implicitly uses the average velocity over the interval:\n    $$\n    \\frac{q_{n+1} - q_n}{h} = \\frac{v_n + v_{n+1}}{2} \\implies q_{n+1} = q_n + \\frac{h}{2}(v_n + v_{n+1})\n    $$\n\nThis set of equations defines the integrator. Given $(q_n, v_n)$, we first find $(q_{n+1}, v_{n+1})$ by solving for the velocity $v_{n+1}$ and the multiplier $\\lambda_{n+1}$. The momentum update and constraint enforcement equations form a coupled linear system for $(v_{n+1}, \\lambda_{n+1})$:\n$$\n\\begin{pmatrix} M & -h A(q_{n+\\frac{1}{2}})^{\\mathsf{T}} \\\\ A(q_{n+\\frac{1}{2}}) & 0 \\end{pmatrix}\n\\begin{pmatrix} v_{n+1} \\\\ \\lambda_{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix} M v_n \\\\ 0 \\end{pmatrix}\n$$\nFrom the first row, we express $v_{n+1}$ in terms of $\\lambda_{n+1}$:\n$$\nv_{n+1} = v_n + h M^{-1} A(q_{n+\\frac{1}{2}})^{\\mathsf{T}} \\lambda_{n+1}\n$$\nSubstituting this into the second row yields an equation for $\\lambda_{n+1}$:\n$$\nA(q_{n+\\frac{1}{2}}) \\left( v_n + h M^{-1} A(q_{n+\\frac{1}{2}})^{\\mathsf{T}} \\lambda_{n+1} \\right) = 0\n$$\n$$\nh \\left( A(q_{n+\\frac{1}{2}}) M^{-1} A(q_{n+\\frac{1}{2}})^{\\mathsf{T}} \\right) \\lambda_{n+1} = -A(q_{n+\\frac{1}{2}}) v_n\n$$\nLet's define the $2 \\times 2$ Gram matrix $G(q) = A(q) M^{-1} A(q)^{\\mathsf{T}}$. The equation becomes:\n$$\nh G(q_{n+\\frac{1}{2}}) \\lambda_{n+1} = -A(q_{n+\\frac{1}{2}}) v_n\n$$\nSolving for $\\lambda_{n+1}$ gives:\n$$\n\\lambda_{n+1} = -\\frac{1}{h} G(q_{n+\\frac{1}{2}})^{-1} A(q_{n+\\frac{1}{2}}) v_n\n$$\nSubstituting this back into the expression for $v_{n+1}$, we get the final velocity update rule:\n$$\nv_{n+1} = v_n - M^{-1} A(q_{n+\\frac{1}{2}})^{\\mathsf{T}} G(q_{n+\\frac{1}{2}})^{-1} A(q_{n+\\frac{1}{2}}) v_n\n$$\nThis can be written as $v_{n+1} = P_{q_{n+1/2}}(v_n)$, where $P_q$ is an operator that projects a velocity vector onto the constraint subspace defined by $A(q)$ with respect to the kinetic energy inner product defined by $M$.\n\n### Algorithmic Implementation Steps\n\nFor each time step, given $(q_n, v_n)$:\n1.  Calculate the midpoint configuration: $q_{n+\\frac{1}{2}} = q_n + \\frac{h}{2}v_n$. Let $\\psi_{n+\\frac{1}{2}}$ be the yaw angle from $q_{n+\\frac{1}{2}}$.\n2.  Construct the constraint matrix $A(\\psi_{n+\\frac{1}{2}})$ and the Gram matrix $G(\\psi_{n+\\frac{1}{2}}) = A(\\psi_{n+\\frac{1}{2}}) M^{-1} A(\\psi_{n+\\frac{1}{2}})^{\\mathsf{T}}$. The matrix $M^{-1} = \\mathrm{diag}(1/m, 1/m, 1/I_{\\psi}, 1/I_{\\phi})$ is diagonal.\n    The Gram matrix is:\n    $$\n    G(\\psi) = \\begin{bmatrix} \\frac{1}{m} + \\frac{R^2}{I_{\\phi}} \\cos^2 \\psi & \\frac{R^2}{I_{\\phi}} \\cos \\psi \\sin \\psi \\\\ \\frac{R^2}{I_{\\phi}} \\cos \\psi \\sin \\psi & \\frac{1}{m} + \\frac{R^2}{I_{\\phi}} \\sin^2 \\psi \\end{bmatrix}\n    $$\n3.  Compute the inverse $G(\\psi_{n+\\frac{1}{2}})^{-1}$.\n4.  Calculate the Lagrange multiplier $\\lambda_{n+1}$ using the formula derived above.\n5.  Update the velocity to $v_{n+1} = v_n + h M^{-1} A(\\psi_{n+\\frac{1}{2}})^{\\mathsf{T}} \\lambda_{n+1}$.\n6.  By construction, the new velocity satisfies $A(\\psi_{n+\\frac{1}{2}})v_{n+1} = 0$ up to floating point precision. The constraint violation metric $\\max_n \\|A(q_{n+1/2})v_{n+1}\\|$ is calculated at this stage.\n7.  Update the configuration to $q_{n+1} = q_n + \\frac{h}{2}(v_n + v_{n+1})$.\n\n### Structure-Preserving Properties\n\n*   **Constraint Preservation**: The algorithm is a projection method that explicitly enforces the constraint $A(q_{n+\\frac{1}{2}})v_{n+1}=0$ at each step. The metric $\\max_n \\|A(q_{n+1/2})v_{n+1}\\|$ is therefore expected to be close to machine epsilon.\n*   **Energy Behavior**: The change in kinetic energy per step is $\\Delta T_n = T(v_{n+1}) - T(v_n)$. A detailed calculation shows $\\Delta T_n = -\\frac{1}{2} (A_h v_n)^{\\mathsf{T}} G_h^{-1} (A_h v_n)$, where the subscript $h$ denotes evaluation at $q_{n+1/2}$. The term $A_h v_n$ represents the violation of the midpoint constraint by the velocity $v_n$. If $v_n$ satisfies the constraint at $q_n$ (i.e., $A(q_n)v_n=0$), then $A_h v_n$ is of order $O(h)$. This makes the energy error per step $\\Delta T_n = O(h^2)$, and the total energy drift over a fixed time interval is $O(h)$. This indicates approximate energy conservation for small $h$, as required.\n\n### Initial Conditions\nFor test cases where the initial velocity $v_0$ is given to satisfy the constraints, $A(q_0)v_0 = 0$. For Test Case 2, $v_0$ is inconsistent. The procedure specified for calculating energy drift is to use $v_1$ (the velocity after the first full step) as the initial velocity for energy calculations, i.e., $\\Delta T = T(v_{\\text{final}}) - T(v_1)$. This handles the initial inconsistency without requiring a separate projection step before the simulation begins.\n\nThe implementation will now follow this derived algorithm.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a structure-preserving time-stepping method \n    for the nonholonomic vertical coin.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"m\": 1.0, \"R\": 0.3, \"I_psi\": 0.12, \"I_phi\": 0.045,\n            \"h\": 0.01, \"steps\": 1000,\n            \"q0\": np.array([0.0, 0.0, 0.7, 0.0]),\n            \"v0_params\": {\"phi_dot\": 5.0, \"psi_dot\": 0.5, \"inconsistent\": False},\n        },\n        {\n            \"m\": 0.8, \"R\": 0.25, \"I_psi\": 0.10, \"I_phi\": 0.03,\n            \"h\": 1e-4, \"steps\": 5000,\n            \"q0\": np.array([0.0, 0.0, 1.2, 0.0]),\n            \"v0_params\": {\"v0_vec\": np.array([0.1, 0.0, -2.0, 3.0]), \"inconsistent\": True},\n        },\n        {\n            \"m\": 1.2, \"R\": 0.35, \"I_psi\": 0.20, \"I_phi\": 0.06,\n            \"h\": 0.1, \"steps\": 300,\n            \"q0\": np.array([0.0, 0.0, 0.2, 0.0]),\n            \"v0_params\": {\"phi_dot\": 4.0, \"psi_dot\": 1.5, \"inconsistent\": False},\n        },\n        {\n            \"m\": 0.9, \"R\": 0.28, \"I_psi\": 0.15, \"I_phi\": 0.04,\n            \"h\": 0.02, \"steps\": 800,\n            \"q0\": np.array([0.0, 0.0, 1.0, 0.0]),\n            \"v0_params\": {\"phi_dot\": 3.0, \"psi_dot\": 10.0, \"inconsistent\": False},\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # The str() representation of a list includes the required spaces.\n    print(f\"[{', '.join(map(str, results))}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \"\"\"\n    m, R, I_psi, I_phi = params[\"m\"], params[\"R\"], params[\"I_psi\"], params[\"I_phi\"]\n    h, steps = params[\"h\"], params[\"steps\"]\n    \n    q = np.copy(params[\"q0\"])\n    \n    # Set initial velocity\n    v0_params = params[\"v0_params\"]\n    if v0_params[\"inconsistent\"]:\n        v = np.copy(v0_params[\"v0_vec\"])\n    else:\n        psi0 = q[2]\n        phi_dot0 = v0_params[\"phi_dot\"]\n        psi_dot0 = v0_params[\"psi_dot\"]\n        x_dot0 = R * phi_dot0 * np.cos(psi0)\n        y_dot0 = R * phi_dot0 * np.sin(psi0)\n        v = np.array([x_dot0, y_dot0, psi_dot0, phi_dot0])\n\n    M_inv_diag = np.array([1/m, 1/m, 1/I_psi, 1/I_phi])\n    \n    max_violation_mag = 0.0\n    T_init = 0.0\n    \n    for i in range(steps):\n        # 1. Compute midpoint configuration for constraint evaluation\n        q_mid = q + (h / 2.0) * v\n        psi_mid = q_mid[2]\n        cos_psi_mid = np.cos(psi_mid)\n        sin_psi_mid = np.sin(psi_mid)\n\n        # 2. Compute G(q_mid)^-1\n        c_val = R**2 / I_phi\n        det_G = (1/m) * (1/m + c_val)\n        inv_det_G = 1.0 / det_G\n\n        G_inv = np.zeros((2, 2))\n        G_inv[0, 0] = (1/m + c_val * sin_psi_mid**2) * inv_det_G\n        G_inv[0, 1] = (-c_val * cos_psi_mid * sin_psi_mid) * inv_det_G\n        G_inv[1, 0] = G_inv[0, 1]\n        G_inv[1, 1] = (1/m + c_val * cos_psi_mid**2) * inv_det_G\n        \n        # 3. Compute constraint violation of v_n at midpoint: A(q_mid) @ v_n\n        A_v = np.array([\n            v[0] - R * v[3] * cos_psi_mid,\n            v[1] - R * v[3] * sin_psi_mid\n        ])\n\n        # 4. Calculate Lagrange multipliers\n        lambda_val = - (1/h) * (G_inv @ A_v)\n\n        # 5. Update velocity\n        v_next = np.copy(v)\n        # Force from lambda on x,y\n        v_next[0] += h * M_inv_diag[0] * lambda_val[0]\n        v_next[1] += h * M_inv_diag[1] * lambda_val[1]\n        # Force from lambda on phi\n        v_next[3] += h * M_inv_diag[3] * (-R * cos_psi_mid * lambda_val[0] - R * sin_psi_mid * lambda_val[1])\n\n        # 6. Calculate constraint violation for the new velocity v_next\n        violation_vec = np.array([\n            v_next[0] - R * v_next[3] * cos_psi_mid,\n            v_next[1] - R * v_next[3] * sin_psi_mid\n        ])\n        current_violation_mag = np.linalg.norm(violation_vec)\n        if current_violation_mag > max_violation_mag:\n            max_violation_mag = current_violation_mag\n\n        # 7. Update configuration\n        q_next = q + (h/2.0) * (v + v_next)\n        \n        # Handle energy calculation as per problem spec\n        if i == 0:\n            T_init = 0.5 * (m*v_next[0]**2 + m*v_next[1]**2 + I_psi*v_next[2]**2 + I_phi*v_next[3]**2)\n            \n        # Update state for next iteration\n        q = q_next\n        v = v_next\n\n    # After the loop, v is v_final\n    T_final = 0.5 * (m*v[0]**2 + m*v[1]**2 + I_psi*v[2]**2 + I_phi*v[3]**2)\n    energy_drift = T_final - T_init\n\n    return [max_violation_mag, energy_drift]\n\nsolve()\n```"
        }
    ]
}