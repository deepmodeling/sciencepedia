{"hands_on_practices": [{"introduction": "A cornerstone of physics is that a model must respect the symmetries of the system it describes. For molecules containing identical atoms, this includes invariance to the permutation of those atoms. This exercise makes this abstract principle concrete by demonstrating the unphysical consequences of violating it, providing a deep intuition for why robust NNP architectures are carefully designed to be permutation-invariant [@problem_id:2908410].", "problem": "In the Born–Oppenheimer (BO) approximation for the hydrogen molecular cation $\\mathrm{H}_3^+$, the exact potential energy surface (PES) $E_{\\mathrm{BO}}(\\{\\mathbf{R}_i\\})$ is invariant under any permutation of the positions $\\{\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3\\}$ of the three identical hydrogen nuclei. Consider instead a learned neural network potential (NNP) that violates permutation invariance by using atom-indexed linear contributions on translation-invariant but index-ordered descriptors. Specifically, for nuclear positions $\\{\\mathbf{R}_i\\}_{i=1}^3 \\subset \\mathbb{R}^3$, define centered coordinates $\\mathbf{s}_i = \\mathbf{R}_i - \\frac{1}{3}\\sum_{j=1}^3 \\mathbf{R}_j$, and let the predicted energy be\n$$\nE_{\\boldsymbol{\\theta}}(\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3) = b + \\sum_{i=1}^{3} \\mathbf{u}_i \\cdot \\mathbf{s}_i,\n$$\nwhere $b \\in \\mathbb{R}$ is a scalar bias and $\\mathbf{u}_i \\in \\mathbb{R}^3$ are independent, atom-indexed weight vectors, $\\mathbf{u}_i = (u_{ix},u_{iy},u_{iz})$. This model is translation-invariant by construction but not permutation-invariant unless $\\mathbf{u}_1=\\mathbf{u}_2=\\mathbf{u}_3$.\n\nConsider the equilateral geometry of side length $R>0$ in the plane $z=0$ with the following lab-frame coordinates:\n$$\n\\mathbf{R}_1 = (0,0,0),\\quad \\mathbf{R}_2 = (R,0,0),\\quad \\mathbf{R}_3 = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right).\n$$\nDefine the two physically identical but differently labeled inputs: geometry $\\mathcal{G}_A$ uses the labeling $(1,2,3)$ as given, while geometry $\\mathcal{G}_B$ is obtained by permuting labels $1 \\leftrightarrow 2$, i.e., $(2,1,3)$. Because $\\mathrm{H}_3^+$ has three identical nuclei, $E_{\\mathrm{BO}}$ must satisfy $E_{\\mathrm{BO}}(\\mathcal{G}_A)=E_{\\mathrm{BO}}(\\mathcal{G}_B)$. However, the model $E_{\\boldsymbol{\\theta}}$ need not.\n\nStarting from the permutation symmetry of the BO Hamiltonian and the definition of $E_{\\boldsymbol{\\theta}}$ above, derive the closed-form analytic expression for the predicted degeneracy splitting\n$$\n\\Delta E \\equiv E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B)\n$$\nin terms of $R$ and the weight components $u_{ix},u_{iy},u_{iz}$. Express your final answer as a single simplified analytic expression. Do not numerically evaluate or round your result. No units are required for the final expression.", "solution": "The problem is subjected to validation before proceeding.\n\nStep 1: Extracted Givens.\n- The system is the hydrogen molecular cation $\\mathrm{H}_3^+$.\n- The Born-Oppenheimer (BO) potential energy surface (PES) is $E_{\\mathrm{BO}}(\\{\\mathbf{R}_i\\})$.\n- $E_{\\mathrm{BO}}$ is invariant under any permutation of the positions $\\{\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3\\}$.\n- A learned neural network potential (NNP) is defined as $E_{\\boldsymbol{\\theta}}(\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3) = b + \\sum_{i=1}^{3} \\mathbf{u}_i \\cdot \\mathbf{s}_i$.\n- $b \\in \\mathbb{R}$ is a scalar bias.\n- $\\mathbf{u}_i \\in \\mathbb{R}^3$ are independent, atom-indexed weight vectors, $\\mathbf{u}_i = (u_{ix},u_{iy},u_{iz})$.\n- The centered coordinates are $\\mathbf{s}_i = \\mathbf{R}_i - \\frac{1}{3}\\sum_{j=1}^3 \\mathbf{R}_j$.\n- The model is translation-invariant but not necessarily permutation-invariant.\n- An equilateral geometry of side length $R>0$ is given in the plane $z=0$ with coordinates: $\\mathbf{R}_1 = (0,0,0)$, $\\mathbf{R}_2 = (R,0,0)$, $\\mathbf{R}_3 = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right)$.\n- Geometry $\\mathcal{G}_A$ corresponds to the labeling $(1,2,3)$ as given.\n- Geometry $\\mathcal{G}_B$ corresponds to the labeling $(2,1,3)$, obtained by permuting labels $1 \\leftrightarrow 2$.\n- The objective is to derive the expression for the degeneracy splitting $\\Delta E \\equiv E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B)$.\n\nStep 2: Validation.\nThe problem is scientifically grounded, well-posed, and objective. It utilizes standard concepts from quantum chemistry (Born-Oppenheimer approximation, potential energy surfaces, permutation symmetry) and machine learning (neural network potentials, input features). The model presented, while simple, is a valid mathematical construct used to demonstrate the consequences of broken symmetry, a critical topic in the field. All terms are defined without ambiguity, the required information is complete, and the premises are consistent. The problem is a formalizable and verifiable mathematical exercise, not a trivial or ill-posed question.\n\nStep 3: Verdict.\nThe problem is valid. A solution will be provided.\n\nThe objective is to compute the degeneracy splitting $\\Delta E$, defined as:\n$$\n\\Delta E \\equiv E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B)\n$$\nThe energy predicted by the model for a given set of atomic positions $\\{\\mathbf{R}_1, \\mathbf{R}_2, \\mathbf{R}_3\\}$ is:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathbf{R}_1,\\mathbf{R}_2,\\mathbf{R}_3) = b + \\sum_{i=1}^{3} \\mathbf{u}_i \\cdot \\mathbf{s}_i\n$$\nwhere $\\mathbf{s}_i = \\mathbf{R}_i - \\mathbf{R}_{\\text{COM}}$ are the centered coordinates, and $\\mathbf{R}_{\\text{COM}} = \\frac{1}{3}\\sum_{j=1}^3 \\mathbf{R}_j$ is the center of the nuclei. The weight vectors $\\mathbf{u}_i$ are indexed by the atom label.\n\nFirst, we calculate the energy for geometry $\\mathcal{G}_A$. The coordinates are $\\mathbf{R}_1^{(A)} = (0,0,0)$, $\\mathbf{R}_2^{(A)} = (R,0,0)$, and $\\mathbf{R}_3^{(A)} = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right)$.\nThe center of positions is:\n$$\n\\mathbf{R}_{\\text{COM}} = \\frac{1}{3}\\left[ (0,0,0) + (R,0,0) + \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right) \\right] = \\frac{1}{3}\\left(\\frac{3R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right) = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right)\n$$\nThe centered coordinates for $\\mathcal{G}_A$ are:\n$$\n\\mathbf{s}_1^{(A)} = \\mathbf{R}_1^{(A)} - \\mathbf{R}_{\\text{COM}} = (0,0,0) - \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(-\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right)\n$$\n$$\n\\mathbf{s}_2^{(A)} = \\mathbf{R}_2^{(A)} - \\mathbf{R}_{\\text{COM}} = (R,0,0) - \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right)\n$$\n$$\n\\mathbf{s}_3^{(A)} = \\mathbf{R}_3^{(A)} - \\mathbf{R}_{\\text{COM}} = \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{2}, 0\\right) - \\left(\\frac{R}{2}, \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(0, \\frac{\\sqrt{3}R}{2} - \\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(0, \\frac{\\sqrt{3}R}{3}, 0\\right)\n$$\nThe energy for $\\mathcal{G}_A$ is therefore:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) = b + \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\n$$\nNext, we consider geometry $\\mathcal{G}_B$, which is obtained by permuting the labels $1 \\leftrightarrow 2$ of $\\mathcal{G}_A$. The coordinates for $\\mathcal{G}_B$ are $\\mathbf{R}_1^{(B)} = \\mathbf{R}_2^{(A)}$, $\\mathbf{R}_2^{(B)} = \\mathbf{R}_1^{(A)}$, and $\\mathbf{R}_3^{(B)} = \\mathbf{R}_3^{(A)}$. The set of position vectors is identical, so the center $\\mathbf{R}_{\\text{COM}}$ is unchanged. The centered coordinates are calculated as $\\mathbf{s}_i^{(B)} = \\mathbf{R}_i^{(B)} - \\mathbf{R}_{\\text{COM}}$.\n$$\n\\mathbf{s}_1^{(B)} = \\mathbf{R}_1^{(B)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{R}_2^{(A)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{s}_2^{(A)}\n$$\n$$\n\\mathbf{s}_2^{(B)} = \\mathbf{R}_2^{(B)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{R}_1^{(A)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{s}_1^{(A)}\n$$\n$$\n\\mathbf{s}_3^{(B)} = \\mathbf{R}_3^{(B)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{R}_3^{(A)} - \\mathbf{R}_{\\text{COM}} = \\mathbf{s}_3^{(A)}\n$$\nThe model's weights $\\mathbf{u}_i$ are fixed to the atom indices, not their positions. Thus, the energy for $\\mathcal{G}_B$ is:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathcal{G}_B) = b + \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(B)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(B)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(B)}\n$$\nSubstituting the relations found above:\n$$\nE_{\\boldsymbol{\\theta}}(\\mathcal{G}_B) = b + \\mathbf{u}_1 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\n$$\nNow we compute the splitting $\\Delta E$:\n$$\n\\Delta E = E_{\\boldsymbol{\\theta}}(\\mathcal{G}_A) - E_{\\boldsymbol{\\theta}}(\\mathcal{G}_B) = \\left(b + \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\\right) - \\left(b + \\mathbf{u}_1 \\cdot \\mathbf{s}_2^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_3 \\cdot \\mathbf{s}_3^{(A)}\\right)\n$$\nThe bias $b$ and the term for atom $3$ cancel, leaving:\n$$\n\\Delta E = \\mathbf{u}_1 \\cdot \\mathbf{s}_1^{(A)} + \\mathbf{u}_2 \\cdot \\mathbf{s}_2^{(A)} - \\mathbf{u}_1 \\cdot \\mathbf{s}_2^{(A)} - \\mathbf{u}_2 \\cdot \\mathbf{s}_1^{(A)}\n$$\nThis expression can be rearranged by grouping the weight vectors:\n$$\n\\Delta E = (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot \\mathbf{s}_1^{(A)} - (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot \\mathbf{s}_2^{(A)}\n$$\n$$\n\\Delta E = (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot (\\mathbf{s}_1^{(A)} - \\mathbf{s}_2^{(A)})\n$$\nWe now compute the vector difference $(\\mathbf{s}_1^{(A)} - \\mathbf{s}_2^{(A)})$:\n$$\n\\mathbf{s}_1^{(A)} - \\mathbf{s}_2^{(A)} = \\left(-\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right) - \\left(\\frac{R}{2}, -\\frac{\\sqrt{3}R}{6}, 0\\right) = \\left(-\\frac{R}{2} - \\frac{R}{2}, -\\frac{\\sqrt{3}R}{6} + \\frac{\\sqrt{3}R}{6}, 0 - 0\\right) = (-R, 0, 0)\n$$\nFinally, we compute the dot product:\n$$\n\\Delta E = (u_{1x}-u_{2x}, u_{1y}-u_{2y}, u_{1z}-u_{2z}) \\cdot (-R, 0, 0)\n$$\n$$\n\\Delta E = (u_{1x}-u_{2x})(-R) + (u_{1y}-u_{2y})(0) + (u_{1z}-u_{2z})(0)\n$$\n$$\n\\Delta E = -R(u_{1x}-u_{2x}) = R(u_{2x}-u_{1x})\n$$\nThis is the final closed-form expression for the predicted degeneracy splitting. It shows that the violation of permutation invariance for this specific permutation and geometry depends only on the side length $R$ and the difference in the $x$-components of the weight vectors associated with the permuted atoms. For a permutation-invariant potential, $\\mathbf{u}_1 = \\mathbf{u}_2$, which correctly implies $\\Delta E = 0$.", "answer": "$$\n\\boxed{R(u_{2x} - u_{1x})}\n$$", "id": "2908410"}, {"introduction": "Having established the importance of physical symmetries, we now turn to the practical task of building invariant representations. This exercise focuses on implementing descriptors that encode local atomic environments and, crucially, computing their derivatives with respect to atomic positions. Mastering this step is essential for developing energy-conserving force fields, as forces are obtained via the chain rule, which requires these descriptor Jacobians [@problem_id:2908378].", "problem": "You are given three-dimensional molecular configurations and a fixed radial cutoff. For each configuration, construct neighbor lists under the fixed cutoff and evaluate the sensitivity of a smooth, local, radial descriptor used in neural network potential energy surfaces by computing Jacobians with respect to atomic coordinates. You must compute both analytic Jacobians from first principles and numerical Jacobians by central finite differences, and then report, for each configuration, the total number of undirected neighbor pairs and the maximum absolute discrepancy between analytic and numerical Jacobians across all atoms, all descriptor components, and all coordinate directions.\n\nFundamental base and definitions:\n- Let there be $N$ atoms with positions $\\{\\mathbf{R}_i\\}_{i=1}^N$, where $\\mathbf{R}_i \\in \\mathbb{R}^3$ are given in ångström units ($\\mathrm{\\AA}$).\n- For a fixed cutoff radius $R_{\\mathrm{c}}$, define the pairwise distance $R_{ij} = \\lVert \\mathbf{R}_i - \\mathbf{R}_j \\rVert_2$. An undirected neighbor pair $\\{i,j\\}$ is present if and only if $R_{ij} \\le R_{\\mathrm{c}}$.\n- Define the smooth cutoff function $f_{\\mathrm{c}}(R)$ by\n$$\nf_{\\mathrm{c}}(R) = \n\\begin{cases}\n\\frac{1}{2}\\left(\\cos\\left(\\pi R / R_{\\mathrm{c}}\\right) + 1\\right), & \\text{if } R \\le R_{\\mathrm{c}}, \\\\\n0, & \\text{if } R > R_{\\mathrm{c}}.\n\\end{cases}\n$$\nAngles are to be interpreted in radians, and $\\pi$ denotes the circle constant in radians.\n- Define a radial density-like atomic descriptor for atom $I$ as a vector $\\mathcal{D}_I \\in \\mathbb{R}^{M}$ with components\n$$\n\\mathcal{D}_{I,k} = \\sum_{\\substack{J=1\\\\ J \\ne I}}^{N} g_k(R_{IJ}) \\, f_{\\mathrm{c}}(R_{IJ}),\n$$\nwhere $g_k$ are smooth radial functions. In this problem, take $M=3$ and\n$$\ng_k(R) = \\exp\\!\\left(-\\eta_k \\left(R - R_{s,k}\\right)^2\\right),\n$$\nwith parameters\n$$\n(\\eta_1, R_{s,1}) = (1.0, 0.0), \\quad\n(\\eta_2, R_{s,2}) = (0.5, 1.0), \\quad\n(\\eta_3, R_{s,3}) = (0.2, 2.0).\n$$\n\nAnalytic Jacobian to be derived and computed:\n- For each ordered atom pair $(I,J)$ and each Cartesian component $\\alpha \\in \\{x,y,z\\}$, define the Jacobian entries\n$$\n\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}},\n$$\nand assemble them into a matrix in which the descriptor index $k \\in \\{1,2,3\\}$ spans rows and the coordinate index $\\alpha$ spans columns. You must use only fundamental vector calculus and the chain rule to obtain an exact expression in terms of $R_{IJ}$, the unit vector $\\hat{\\mathbf{r}}_{IJ} = (\\mathbf{R}_I - \\mathbf{R}_J)/R_{IJ}$, and derivatives with respect to $R$.\n\nNumerical Jacobian by central finite differences:\n- For a step size $\\varepsilon$, approximate\n$$\n\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}}\n\\approx \\frac{\\mathcal{D}_{I,k}\\left(\\mathbf{R}_{J,\\alpha} + \\varepsilon\\right) - \\mathcal{D}_{I,k}\\left(\\mathbf{R}_{J,\\alpha} - \\varepsilon\\right)}{2\\varepsilon}.\n$$\nUse $\\varepsilon = 10^{-6}\\ \\mathrm{\\AA}$.\n\nTest suite:\nUse a single fixed cutoff $R_{\\mathrm{c}} = 1.5\\ \\mathrm{\\AA}$ and the following three configurations, each given as an array of positions in $\\mathrm{\\AA}$:\n1. Configuration A ($N=3$): $\\left[(0,0,0),\\ (1.0,0,0),\\ (0,1.4,0)\\right]$.\n2. Configuration B ($N=2$): $\\left[(0,0,0),\\ (1.5,0,0)\\right]$.\n3. Configuration C ($N=1$): $\\left[(0,0,0)\\right]$.\n\nWhat to compute for each configuration:\n1. Build the neighbor list under the rule $R_{ij} \\le R_{\\mathrm{c}}$, and compute the total number of undirected neighbor pairs (each pair counted once, irrespective of direction).\n2. Compute analytic Jacobians $\\partial \\mathcal{D}_I / \\partial \\mathbf{R}_J$ for all $I,J$ using only first principles and the stated definitions.\n3. Compute numerical Jacobians by central finite differences using the specified $\\varepsilon$.\n4. Compute, for the configuration, the maximum absolute discrepancy\n$$\nE_{\\max} = \\max_{I,J,k,\\alpha} \\left| \\left( \\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}} \\right)_{\\mathrm{analytic}} - \\left( \\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}} \\right)_{\\mathrm{numeric}} \\right|.\n$$\n\nRequired final output:\nYour program must produce a single line of output containing the results for all configurations in the order A, B, C, aggregated as a comma-separated list enclosed in square brackets. For each configuration, output first the integer number of undirected neighbor pairs, then the floating-point $E_{\\max}$ value. Thus the output must contain $6$ entries in total and look like\n$[N_A, E_{\\max,A}, N_B, E_{\\max,B}, N_C, E_{\\max,C}]$,\nwhere $N_A$, $N_B$, $N_C$ are integers, and the three floating-point values must be formatted in scientific notation with six significant figures. Angles must be in radians and distances in ångström ($\\mathrm{\\AA}$). No other text should be printed. The answer for each configuration is fully quantifiable as an integer and a float, respectively.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of computational chemistry, specifically in the domain of machine learning interatomic potentials. The problem is well-posed, with all necessary parameters, functions, and data explicitly defined, ensuring that a unique and meaningful solution can be computed. The language is objective and mathematically precise, free from ambiguity or subjective claims.\n\nWe proceed with the solution, which involves deriving the analytic Jacobian of the given atomic descriptor, implementing its computation, implementing a numerical Jacobian via finite differences for verification, and applying these to the specified test cases.\n\n**1. Analytic Jacobian Derivation**\n\nThe atomic descriptor for a central atom $I$ is given by a vector $\\mathcal{D}_I \\in \\mathbb{R}^{M}$ with components:\n$$\n\\mathcal{D}_{I,k} = \\sum_{\\substack{J'=1\\\\ J' \\ne I}}^{N} g_k(R_{IJ'}) \\, f_{\\mathrm{c}}(R_{IJ'})\n$$\nwhere $k \\in \\{1, 2, 3\\}$. For convenience, we define the composite function $G_k(R) = g_k(R) f_{\\mathrm{c}}(R)$. The descriptor component is then $\\mathcal{D}_{I,k} = \\sum_{J' \\ne I} G_k(R_{IJ'})$. We are tasked with computing the Jacobian matrix elements $\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}}$, where $I$ and $J$ index atoms and $\\alpha \\in \\{x, y, z\\}$ indexes a Cartesian coordinate.\n\nWe apply the chain rule:\n$$\n\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}} = \\sum_{\\substack{J'=1\\\\ J' \\ne I}}^{N} \\frac{\\partial G_k(R_{IJ'})}{\\partial R_{J,\\alpha}} = \\sum_{\\substack{J'=1\\\\ J' \\ne I}}^{N} \\frac{dG_k(R)}{dR}\\bigg|_{R=R_{IJ'}} \\frac{\\partial R_{IJ'}}{\\partial R_{J,\\alpha}}\n$$\nThe derivative of the interatomic distance $R_{IJ'} = \\lVert \\mathbf{R}_I - \\mathbf{R}_{J'} \\rVert_2$ with respect to a coordinate $R_{J,\\alpha}$ depends on the index $J$.\nLet $\\mathbf{r}_{IJ'} = \\mathbf{R}_I - \\mathbf{R}_{J'}$. Then $R_{IJ'} = \\sqrt{\\mathbf{r}_{IJ'} \\cdot \\mathbf{r}_{IJ'}}$. The derivative is $\\frac{\\partial R_{IJ'}}{\\partial R_{J,\\alpha}} = \\frac{1}{R_{IJ'}} \\sum_{\\beta} (R_{I,\\beta} - R_{J',\\beta}) \\frac{\\partial(R_{I,\\beta} - R_{J',\\beta})}{\\partial R_{J,\\alpha}}$.\n\nWe distinguish two cases for the index $J$:\n\n**Case 1: $J = I$ (Derivative with respect to the central atom's coordinate)**\nIn this case, $\\frac{\\partial(R_{I,\\beta} - R_{J',\\beta})}{\\partial R_{I,\\alpha}} = \\delta_{\\alpha\\beta}$.\nThe derivative of the distance becomes:\n$$\n\\frac{\\partial R_{IJ'}}{\\partial R_{I,\\alpha}} = \\frac{R_{I,\\alpha} - R_{J',\\alpha}}{R_{IJ'}} = \\hat{r}_{IJ',\\alpha}\n$$\nwhere $\\hat{\\mathbf{r}}_{IJ'} = (\\mathbf{R}_I - \\mathbf{R}_{J'})/R_{IJ'}$ is the unit vector. The Jacobian elements are:\n$$\n\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{I,\\alpha}} = \\sum_{\\substack{J' = 1 \\\\ J' \\ne I}}^{N} \\frac{dG_k(R)}{dR}\\bigg|_{R=R_{IJ'}} \\hat{r}_{IJ',\\alpha}\n$$\n\n**Case 2: $J \\neq I$ (Derivative with respect to another atom's coordinate)**\nThe term $\\frac{\\partial R_{IJ'}}{\\partial R_{J,\\alpha}}$ is non-zero only if $J' = J$. For other terms where $J' \\neq J$, the derivative is zero. Therefore, the sum collapses to a single term:\n$$\n\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}} = \\frac{dG_k(R)}{dR}\\bigg|_{R=R_{IJ}} \\frac{\\partial R_{IJ}}{\\partial R_{J,\\alpha}}\n$$\nHere, $\\frac{\\partial(R_{I,\\beta} - R_{J,\\beta})}{\\partial R_{J,\\alpha}} = -\\delta_{\\alpha\\beta}$, which gives:\n$$\n\\frac{\\partial R_{IJ}}{\\partial R_{J,\\alpha}} = -\\frac{R_{I,\\alpha} - R_{J,\\alpha}}{R_{IJ}} = -\\hat{r}_{IJ,\\alpha}\n$$\nSo, for $J \\neq I$, the Jacobian elements are:\n$$\n\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}} = - \\frac{dG_k(R)}{dR}\\bigg|_{R=R_{IJ}} \\hat{r}_{IJ,\\alpha}\n$$\nThe derivative $\\frac{dG_k(R)}{dR}$ is zero if $R > R_{\\mathrm{c}}$. If $R \\le R_{\\mathrm{c}}$, we use the product rule:\n$$\n\\frac{dG_k(R)}{dR} = \\frac{dg_k(R)}{dR} f_{\\mathrm{c}}(R) + g_k(R) \\frac{df_{\\mathrm{c}}(R)}{dR}\n$$\nThe derivatives of the component functions are:\n$$\n\\frac{dg_k(R)}{dR} = -2\\eta_k(R - R_{s,k}) \\exp\\!\\left(-\\eta_k(R - R_{s,k})^2\\right) = -2\\eta_k(R - R_{s,k}) g_k(R)\n$$\n$$\n\\frac{df_{\\mathrm{c}}(R)}{dR} = -\\frac{\\pi}{2 R_{\\mathrm{c}}} \\sin\\left(\\frac{\\pi R}{R_{\\mathrm{c}}}\\right)\n$$\nCombining these yields the final expression for the derivative for $R \\le R_{\\mathrm{c}}$:\n$$\n\\frac{dG_k(R)}{dR} = g_k(R) \\left[ -2\\eta_k(R - R_{s,k}) f_{\\mathrm{c}}(R) - \\frac{\\pi}{2 R_{\\mathrm{c}}} \\sin\\left(\\frac{\\pi R}{R_{\\mathrm{c}}}\\right) \\right]\n$$\n\n**2. Numerical Jacobian Calculation**\n\nThe numerical Jacobian is approximated using the central finite difference formula with a small step size $\\varepsilon = 10^{-6}\\ \\mathrm{\\AA}$:\n$$\n\\left(\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}}\\right)_{\\text{numeric}} \\approx \\frac{\\mathcal{D}_{I,k}(\\mathbf{R}_{J,\\alpha} + \\varepsilon) - \\mathcal{D}_{I,k}(\\mathbf{R}_{J,\\alpha} - \\varepsilon)}{2\\varepsilon}\n$$\nHere, $\\mathcal{D}_{I,k}(\\mathbf{R}_{J,\\alpha} \\pm \\varepsilon)$ signifies that the descriptor for atom $I$ is re-evaluated after perturbing the $\\alpha$-coordinate of atom $J$ by $\\pm\\varepsilon$. This requires two full descriptor evaluations for each Jacobian element $(I,J,k,\\alpha)$.\n\n**3. Algorithmic Strategy**\n\nFor each configuration provided, the following steps are executed:\n1.  **Neighbor List Construction**: The distance matrix for all pairs of atoms $\\{i,j\\}$ is computed. The number of undirected pairs satisfying $R_{ij} \\le R_{\\mathrm{c}}$ is counted.\n2.  **Analytic Jacobian Computation**: A $4$-dimensional tensor of shape $(N, N, M, 3)$ is allocated to store the analytic Jacobians $\\frac{\\partial \\mathcal{D}_{I,k}}{\\partial R_{J,\\alpha}}$. It is populated by iterating through all indices $I, J, k, \\alpha$ and applying the expressions derived above.\n    - An auxiliary function to compute $\\frac{dG_k(R)}{dR}$ is implemented, which handles the case $R > R_{\\mathrm{c}}$ by returning $0$.\n3.  **Numerical Jacobian Computation**: A second tensor of the same shape is allocated for the numerical Jacobians. It is populated by iterating through $I, J, \\alpha$ and applying the finite difference formula. This requires a helper function that takes a full set of atomic coordinates and computes the descriptor vector $\\mathcal{D}_I$.\n4.  **Discrepancy Calculation**: The maximum absolute element-wise difference between the analytic and numerical Jacobian tensors is found. This value is $E_{\\max}$.\n5.  **Result Aggregation**: The computed number of neighbor pairs and $E_{\\max}$ are stored.\n\n**4. Analysis of Test Cases**\n\n- **Configuration A ($N=3$):** Contains two neighbor pairs $\\{ (0,1), (0,2) \\}$ since $R_{01}=1.0\\ \\mathrm{\\AA} \\le 1.5\\ \\mathrm{\\AA}$ and $R_{02}=1.4\\ \\mathrm{\\AA} \\le 1.5\\ \\mathrm{\\AA}$, while $R_{12} \\approx 1.72\\ \\mathrm{\\AA} > 1.5\\ \\mathrm{\\AA}$. A small non-zero discrepancy $E_{\\max, A}$ is expected due to the approximation error of the finite difference method, which is typically of order $O(\\varepsilon^2)$.\n- **Configuration B ($N=2$):** Contains one neighbor pair $\\{ (0,1) \\}$ with distance $R_{01}=1.5\\ \\mathrm{\\AA} = R_{\\mathrm{c}}$. This is a special boundary case. The cutoff function $f_{\\mathrm{c}}(R)$ and its first derivative $f'_{\\mathrm{c}}(R)$ are both zero at $R=R_{\\mathrm{c}}$. This makes the analytic Jacobian zero. However, the function's second derivative is discontinuous at $R=R_{\\mathrm{c}}$. The numerical finite difference method probes points on either side of the boundary, leading to a non-zero estimate. The resulting error is expected to be of order $O(\\varepsilon)$, which is significantly larger than in Configuration A.\n- **Configuration C ($N=1$):** With only one atom, no pairs exist, so the number of neighbors is $0$. The sum in the descriptor definition is empty, making the descriptor $\\mathcal{D}_I$ and all its derivatives identically zero. Both analytic and numerical Jacobians will be zero, resulting in $E_{\\max, C} = 0.0$.\n\nThis comprehensive approach ensures correctness and verifies the implementation against known numerical analysis principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing descriptor Jacobians for given molecular configurations.\n    \"\"\"\n    \n    # --- Define parameters and constants ---\n    RC = 1.5  # Cutoff radius in Angstrom\n    EPSILON = 1e-6  # Step size for finite differences in Angstrom\n    PARAMS = [\n        # (eta_k, R_s_k) for k=1,2,3\n        (1.0, 0.0),\n        (0.5, 1.0),\n        (0.2, 2.0),\n    ]\n    M = len(PARAMS) # Number of descriptor components\n\n    # --- Define base functions and their derivatives ---\n\n    def fc(R, Rc):\n        \"\"\"Smooth cutoff function.\"\"\"\n        if R > Rc:\n            return 0.0\n        return 0.5 * (np.cos(np.pi * R / Rc) + 1.0)\n\n    def dfc_dR(R, Rc):\n        \"\"\"Derivative of the smooth cutoff function.\"\"\"\n        if R > Rc:\n            return 0.0\n        return -0.5 * (np.pi / Rc) * np.sin(np.pi * R / Rc)\n\n    def gk(R, eta, Rs):\n        \"\"\"Gaussian radial basis function.\"\"\"\n        return np.exp(-eta * (R - Rs)**2)\n\n    def dgk_dR(R, eta, Rs):\n        \"\"\"Derivative of the Gaussian radial basis function.\"\"\"\n        return -2.0 * eta * (R - Rs) * gk(R, eta, Rs)\n\n    def Gk(R, Rc, eta, Rs):\n        \"\"\"Combined descriptor function G_k(R) = g_k(R) * f_c(R).\"\"\"\n        if R > Rc:\n            return 0.0\n        return gk(R, eta, Rs) * fc(R, Rc)\n\n    def dGk_dR(R, Rc, eta, Rs):\n        \"\"\"Derivative of the combined descriptor function G_k(R).\"\"\"\n        if R > Rc:\n            return 0.0\n        val_fc = fc(R, Rc)\n        val_dfc = dfc_dR(R, Rc)\n        val_gk = gk(R, eta, Rs)\n        val_dgk = dgk_dR(R, eta, Rs)\n        return val_dgk * val_fc + val_gk * val_dfc\n\n    def compute_descriptor(coords, i_atom, Rc, params):\n        \"\"\"Computes the descriptor vector D_I for atom i_atom.\"\"\"\n        desc = np.zeros(len(params))\n        pos_i = coords[i_atom]\n        for j_atom in range(len(coords)):\n            if i_atom == j_atom:\n                continue\n            \n            pos_j = coords[j_atom]\n            dist_vec = pos_i - pos_j\n            dist = np.linalg.norm(dist_vec)\n            \n            if dist = Rc:\n                for k in range(len(params)):\n                    eta_k, Rs_k = params[k]\n                    desc[k] += Gk(dist, Rc, eta_k, Rs_k)\n        return desc\n\n    # --- Test case configurations ---\n    test_cases = [\n        np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.4, 0.0]]),\n        np.array([[0.0, 0.0, 0.0], [1.5, 0.0, 0.0]]),\n        np.array([[0.0, 0.0, 0.0]]),\n    ]\n    \n    results = []\n\n    for coords in test_cases:\n        N = coords.shape[0]\n        \n        # --- 1. Compute number of neighbor pairs ---\n        num_neighbor_pairs = 0\n        if N > 1:\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(coords[i] - coords[j])\n                    if dist = RC:\n                        num_neighbor_pairs += 1\n        \n        if N = 1:\n            results.extend([0, 0.0])\n            continue\n            \n        # --- 2. Compute analytic and numerical Jacobians ---\n        analytic_jac = np.zeros((N, N, M, 3))\n        numeric_jac = np.zeros((N, N, M, 3))\n\n        # Analytic Jacobian\n        for I in range(N):\n            for J_neighbor in range(N):\n                if I == J_neighbor:\n                    continue\n                \n                R_vec = coords[I] - coords[J_neighbor]\n                R_norm = np.linalg.norm(R_vec)\n                \n                if R_norm > RC:\n                    continue\n\n                R_hat = R_vec / R_norm\n                \n                dG_dR_vec = np.zeros(M)\n                for k in range(M):\n                    eta_k, Rs_k = PARAMS[k]\n                    dG_dR_vec[k] = dGk_dR(R_norm, RC, eta_k, Rs_k)\n                \n                # Contribution to dD_I / dR_J for J != I\n                analytic_jac[I, J_neighbor, :, :] = -np.outer(dG_dR_vec, R_hat)\n                \n                # Contribution to dD_I / dR_I\n                analytic_jac[I, I, :, :] += np.outer(dG_dR_vec, R_hat)\n\n        # Numerical Jacobian\n        for I in range(N):\n            for J in range(N):\n                for alpha in range(3):\n                    coords_plus = coords.copy()\n                    coords_plus[J, alpha] += EPSILON\n                    desc_plus = compute_descriptor(coords_plus, I, RC, PARAMS)\n                    \n                    coords_minus = coords.copy()\n                    coords_minus[J, alpha] -= EPSILON\n                    desc_minus = compute_descriptor(coords_minus, I, RC, PARAMS)\n                    \n                    numeric_jac[I, J, :, alpha] = (desc_plus - desc_minus) / (2 * EPSILON)\n\n        # --- 3. Compute maximum discrepancy ---\n        max_discrepancy = np.max(np.abs(analytic_jac - numeric_jac))\n        \n        results.extend([num_neighbor_pairs, max_discrepancy])\n\n    # --- 4. Format and print the final output ---\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i % 2 == 0: # Integer number of pairs\n            formatted_results.append(str(res))\n        else: # Float E_max\n            formatted_results.append(f\"{res:.5e}\")\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2908378"}, {"introduction": "With an understanding of physical constraints and input representations, we can now assemble the full model. This practice guides you through one complete forward pass of a message-passing neural network, a state-of-the-art architecture for atomistic potentials. By implementing the flow of information from atomic features to total energy, you will gain a mechanistic understanding of how these networks capture complex many-body interactions in a physically-grounded way [@problem_id:2908437].", "problem": "You are asked to implement one deterministic forward pass of a single-layer message-passing network to approximate an atomistic potential energy surface under the Born–Oppenheimer approximation. The model should be a simple translationally and rotationally invariant architecture that maps nuclear geometry to a scalar total energy by pooling per-atom contributions. The mathematical design is constrained by the following foundations: (1) under the Born–Oppenheimer approximation, the potential energy surface depends only on nuclear coordinates and charges; (2) invariance to global translations and rotations is enforced by using only pairwise interatomic distances; (3) the total energy is the sum of per-atom contributions. You must implement the complete computation using the prescribed scalar and tensor operations with the provided numerical parameters, and return a single-line output with all intermediate messages, updated features, and the pooled energy for each test case.\n\nModel and computation to implement:\n- Atom types are represented by an embedding map from atomic number to an initial hidden feature vector of dimension $d_h = 2$.\n- Messages are computed for every ordered pair of distinct atoms using a distance-based filter and an elementwise nonlinearity.\n- The aggregate of incoming messages updates each atom’s hidden state by a gated transformation of the concatenated current hidden features and the summed messages.\n- Atomwise energy contributions are read out linearly from the updated features, and the total energy is the sum across atoms.\n\nAll mathematical entities used below are defined in LaTeX and must be followed exactly.\n\nDefinitions and parameters:\n- Hidden feature dimension: $d_h = 2$.\n- Initial embeddings (dimensionless):\n  - Hydrogen $\\left(Z = 1\\right)$: $\\mathbf{h}_{\\mathrm{H}} = \\begin{bmatrix} 0.40 \\\\ -0.10 \\end{bmatrix}$.\n  - Carbon $\\left(Z = 6\\right)$: $\\mathbf{h}_{\\mathrm{C}} = \\begin{bmatrix} 0.00 \\\\ 0.50 \\end{bmatrix}$.\n  - Oxygen $\\left(Z = 8\\right)$: $\\mathbf{h}_{\\mathrm{O}} = \\begin{bmatrix} 0.80 \\\\ 0.20 \\end{bmatrix}$.\n- Directed message from atom $j$ to atom $i$:\n  - Let $\\mathbf{h}_j \\in \\mathbb{R}^{2}$ be the current hidden feature of atom $j$.\n  - Linear message pre-activation: $\\mathbf{z}_{j} = \\mathbf{W}_m \\mathbf{h}_j + \\mathbf{b}_m$, where\n    $$\\mathbf{W}_m = \\begin{bmatrix} 0.60  -0.20 \\\\ 0.15  0.30 \\end{bmatrix}, \\quad \\mathbf{b}_m = \\begin{bmatrix} 0.05 \\\\ -0.05 \\end{bmatrix}.$$\n  - Nonlinearity: $\\phi(\\cdot) = \\tanh(\\cdot)$ applied elementwise, so $\\tilde{\\mathbf{m}}_{j} = \\phi(\\mathbf{z}_{j})$.\n  - Distance between atoms $i$ and $j$ with positions $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^{3}$ in ångström is $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$.\n  - Radial filter (Gaussian): $f(r) = \\exp\\!\\left(-\\dfrac{(r - \\mu)^2}{2 \\sigma^2}\\right)$ with $\\mu = 1.00$ ångström and $\\sigma = 0.50$ ångström.\n  - Directed message: $\\mathbf{m}_{i \\leftarrow j} = f(r_{ij}) \\cdot \\tilde{\\mathbf{m}}_{j}$.\n- Message aggregation for atom $i$: $\\mathbf{m}_i = \\sum_{j \\neq i} \\mathbf{m}_{i \\leftarrow j}$.\n- Update rule for atom $i$:\n  - Concatenate $\\mathbf{h}_i$ and $\\mathbf{m}_i$ to form $\\mathbf{u}_i = \\begin{bmatrix} \\mathbf{h}_i \\\\ \\mathbf{m}_i \\end{bmatrix} \\in \\mathbb{R}^{4}$.\n  - Linear update: $\\mathbf{q}_i = \\mathbf{W}_u \\mathbf{u}_i + \\mathbf{b}_u$, where\n    $$\\mathbf{W}_u = \\begin{bmatrix} 0.50  0.10  0.20  -0.30 \\\\ -0.40  0.25  0.10  0.15 \\end{bmatrix}, \\quad \\mathbf{b}_u = \\begin{bmatrix} 0.00 \\\\ 0.10 \\end{bmatrix}.$$\n  - Nonlinear updated features: $\\mathbf{h}_i' = \\phi(\\mathbf{q}_i)$ with $\\phi = \\tanh$ elementwise.\n- Atomwise energy readout and pooling:\n  - Readout weights and bias: $\\mathbf{v} = \\begin{bmatrix} 1.50 \\\\ -0.50 \\end{bmatrix}$ and $c = -0.20$.\n  - Atomwise energy: $e_i = \\mathbf{v}^\\top \\mathbf{h}_i' + c$ in electronvolts.\n  - Total energy: $E = \\sum_i e_i$ in electronvolts.\n\nConstraints:\n- Include all directed messages for $i \\neq j$ (no self-messages).\n- Use the provided parameters exactly.\n- Use hyperbolic tangent for all $\\tanh$ operations.\n- All distances must be computed in ångström and the total energy must be reported in electronvolts.\n\nRequired outputs for each test case:\n- A flattened list of all directed message components in the fixed order: iterate atoms $i$ by ascending index, and for each $i$ iterate senders $j$ by ascending index with $j \\neq i$; within each directed message vector, list components by ascending component index.\n- A flattened list of the updated features $\\mathbf{h}_i'$ by ascending atom index and ascending component index.\n- The scalar total energy $E$.\n- Round all floating-point outputs to $6$ decimal places.\n\nFinal output format:\n- Your program must produce a single line containing a JSON-like representation (without spaces) of a list of per-case results.\n- Each per-case result is a list of three elements: the flattened directed messages list, the flattened updated features list, and the scalar energy.\n- For example, a valid output line has the form: $[\\;[[m\\_1,\\dots],[h\\_1,\\dots],E\\_1],\\;[[m\\_2,\\dots],[h\\_2,\\dots],E\\_2]\\;]$ with all numbers rounded as specified.\n\nTest suite:\n- Case $1$ (linear triatomic): atoms $\\left[ Z_1, Z_2, Z_3 \\right] = \\left[ 1, 6, 8 \\right]$, positions in ångström\n  $$\\mathbf{r}_1 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}, \\quad \\mathbf{r}_2 = \\begin{bmatrix} 1.10 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}, \\quad \\mathbf{r}_3 = \\begin{bmatrix} 2.30 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}.$$\n- Case $2$ (diatomic hydrogen): atoms $\\left[ Z_1, Z_2 \\right] = \\left[ 1, 1 \\right]$, positions\n  $$\\mathbf{r}_1 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}, \\quad \\mathbf{r}_2 = \\begin{bmatrix} 0.74 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}.$$\n- Case $3$ (single oxygen): atoms $\\left[ Z_1 \\right] = \\left[ 8 \\right]$, position\n  $$\\mathbf{r}_1 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\\\ 0.00 \\end{bmatrix}.$$\n\nAngle units are not involved. Energies must be expressed in electronvolts. Your program should produce a single line of output containing the results as a JSON-like list with no spaces, where each element corresponds to one test case in the order listed above, and each test case is represented by a list containing: the flattened directed messages, the flattened updated features, and the scalar total energy, all rounded to $6$ decimal places.", "solution": "The problem statement is valid. It presents a well-defined, self-contained computational task based on established principles in computational chemistry, specifically the construction of a neural network potential energy surface. All necessary parameters, initial conditions, and mathematical operations are specified unambiguously. The task is to implement a single forward pass of a simple message-passing neural network for three given molecular systems.\n\nThe solution is developed by methodically implementing the prescribed sequence of operations for each test case. The overall process for a given system of $N$ atoms is as follows:\n1.  Initialize the hidden feature vector $\\mathbf{h}_i \\in \\mathbb{R}^{d_h}$ for each atom $i$ based on its atomic number $Z_i$.\n2.  Compute all directed messages $\\mathbf{m}_{i \\leftarrow j}$ for $i, j \\in \\{1,\\dots,N\\}$, $i \\neq j$.\n3.  Aggregate incoming messages for each atom $i$ to obtain $\\mathbf{m}_i$.\n4.  Update the hidden feature vector of each atom from $\\mathbf{h}_i$ to $\\mathbf{h}_i'$.\n5.  Read out the atomic energy contribution $e_i$ from each updated feature vector $\\mathbf{h}_i'$.\n6.  Sum the atomic energies to obtain the total potential energy $E = \\sum_i e_i$.\n\nThe provided parameters are:\n- Hidden feature dimension: $d_h = 2$.\n- Initial embeddings: $\\mathbf{h}_{\\mathrm{H}} = \\begin{bmatrix} 0.40 \\\\ -0.10 \\end{bmatrix}$, $\\mathbf{h}_{\\mathrm{C}} = \\begin{bmatrix} 0.00 \\\\ 0.50 \\end{bmatrix}$, $\\mathbf{h}_{\\mathrm{O}} = \\begin{bmatrix} 0.80 \\\\ 0.20 \\end{bmatrix}$.\n- Message linear layer: $\\mathbf{W}_m = \\begin{bmatrix} 0.60  -0.20 \\\\ 0.15  0.30 \\end{bmatrix}$, $\\mathbf{b}_m = \\begin{bmatrix} 0.05 \\\\ -0.05 \\end{bmatrix}$.\n- Update linear layer: $\\mathbf{W}_u = \\begin{bmatrix} 0.50  0.10  0.20  -0.30 \\\\ -0.40  0.25  0.10  0.15 \\end{bmatrix}$, $\\mathbf{b}_u = \\begin{bmatrix} 0.00 \\\\ 0.10 \\end{bmatrix}$.\n- Energy readout: $\\mathbf{v} = \\begin{bmatrix} 1.50 \\\\ -0.50 \\end{bmatrix}$, $c = -0.20$.\n- Radial filter: $\\mu = 1.00$ Å, $\\sigma = 0.50$ Å.\n- Nonlinearity: $\\phi(x) = \\tanh(x)$.\n\nThe computation proceeds with the following detailed steps.\n\n**Step 1: Message Generation**\nFor each ordered pair of distinct atoms $(i, j)$, a directed message $\\mathbf{m}_{i \\leftarrow j}$ is computed. This message depends on the sending atom's feature vector $\\mathbf{h}_j$ and the distance between the atoms $r_{ij}$.\n\nFirst, a \"base\" message $\\tilde{\\mathbf{m}}_j$ is created from the sender's current features $\\mathbf{h}_j$. This involves a linear transformation followed by an elementwise hyperbolic tangent nonlinearity, $\\phi(\\cdot) = \\tanh(\\cdot)$.\n$$\n\\mathbf{z}_{j} = \\mathbf{W}_m \\mathbf{h}_j + \\mathbf{b}_m\n$$\n$$\n\\tilde{\\mathbf{m}}_{j} = \\phi(\\mathbf{z}_{j})\n$$\nThis base message is then modulated by a radial filter function $f(r_{ij})$ which depends on the interatomic distance $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$. The filter is a Gaussian function centered at $\\mu$ with standard deviation $\\sigma$.\n$$\nf(r_{ij}) = \\exp\\!\\left(-\\frac{(r_{ij} - \\mu)^2}{2 \\sigma^2}\\right)\n$$\nThe final directed message from atom $j$ to atom $i$ is the product of the filter value and the base message.\n$$\n\\mathbf{m}_{i \\leftarrow j} = f(r_{ij}) \\cdot \\tilde{\\mathbf{m}}_{j}\n$$\nAll computed directed messages $\\mathbf{m}_{i \\leftarrow j}$ are collected and flattened into a list as specified by the output format.\n\n**Step 2: Message Aggregation**\nFor each atom $i$, the incoming messages from all other atoms $j$ are summed to form a single aggregated message vector $\\mathbf{m}_i \\in \\mathbb{R}^{d_h}$.\n$$\n\\mathbf{m}_i = \\sum_{j \\neq i} \\mathbf{m}_{i \\leftarrow j}\n$$\nIf an atom has no neighbors (e.g., a single-atom system), this sum is empty and evaluates to the zero vector, $\\mathbf{m}_i = \\mathbf{0}$.\n\n**Step 3: Feature Update**\nThe hidden feature vector $\\mathbf{h}_i$ of each atom is updated to $\\mathbf{h}_i'$ using its current features and the aggregated message $\\mathbf{m}_i$. First, $\\mathbf{h}_i$ and $\\mathbf{m}_i$ are concatenated to form a vector $\\mathbf{u}_i \\in \\mathbb{R}^{2 d_h}$.\n$$\n\\mathbf{u}_i = \\begin{bmatrix} \\mathbf{h}_i \\\\ \\mathbf{m}_i \\end{bmatrix}\n$$\nThis concatenated vector is then passed through another linear transformation and elementwise nonlinearity to produce the updated feature vector $\\mathbf{h}_i'$.\n$$\n\\mathbf{q}_i = \\mathbf{W}_u \\mathbf{u}_i + \\mathbf{b}_u\n$$\n$$\n\\mathbf{h}_i' = \\phi(\\mathbf{q}_i)\n$$\nThe components of all updated feature vectors $\\mathbf{h}_i'$ are collected and flattened into a second list.\n\n**Step 4: Energy Readout and Pooling**\nThe final step is to compute the total potential energy $E$. This is done by first assigning a scalar energy contribution $e_i$ to each atom based on its updated feature vector $\\mathbf{h}_i'$. A linear readout maps $\\mathbf{h}_i'$ to $e_i$.\n$$\ne_i = \\mathbf{v}^\\top \\mathbf{h}_i' + c\n$$\nThe total potential energy of the system is the sum of all atomic energy contributions.\n$$\nE = \\sum_i e_i\n$$\nThe total energy $E$ is the final output value for the given atomic configuration.\n\nThese steps are executed for each of the three test cases provided. For the single-atom case (Case 3), the message generation and aggregation steps result in zero messages, and the update is based solely on the initial atomic features, which is a correct and consistent outcome of the defined model. All numerical results are rounded to $6$ decimal places before being formatted into the final output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single forward pass of a message-passing neural network for potential energy.\n    \"\"\"\n    # Define model parameters\n    params = {\n        'h_dim': 2,\n        'embeddings': {\n            1: np.array([0.40, -0.10]),  # Hydrogen (Z=1)\n            6: np.array([0.00, 0.50]),  # Carbon (Z=6)\n            8: np.array([0.80, 0.20]),  # Oxygen (Z=8)\n        },\n        'W_m': np.array([[0.60, -0.20], [0.15, 0.30]]),\n        'b_m': np.array([0.05, -0.05]),\n        'mu': 1.00,\n        'sigma': 0.50,\n        'W_u': np.array([[0.50, 0.10, 0.20, -0.30], [-0.40, 0.25, 0.10, 0.15]]),\n        'b_u': np.array([0.00, 0.10]),\n        'v': np.array([1.50, -0.50]),\n        'c': -0.20,\n    }\n\n    # Define test cases\n    test_cases = [\n        {\n            'Z': [1, 6, 8],\n            'R': np.array([\n                [0.00, 0.00, 0.00],\n                [1.10, 0.00, 0.00],\n                [2.30, 0.00, 0.00]\n            ])\n        },\n        {\n            'Z': [1, 1],\n            'R': np.array([\n                [0.00, 0.00, 0.00],\n                [0.74, 0.00, 0.00]\n            ])\n        },\n        {\n            'Z': [8],\n            'R': np.array([\n                [0.00, 0.00, 0.00]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Zs = case['Z']\n        Rs = case['R']\n        num_atoms = len(Zs)\n\n        # 1. Initialize features\n        h_initial = np.array([params['embeddings'][Z] for Z in Zs])\n\n        # 2. Message Generation and Aggregation\n        all_messages_flat = []\n        aggregated_messages = np.zeros_like(h_initial)\n        \n        # Pre-compute base messages for all atoms\n        base_messages = {}\n        for j in range(num_atoms):\n            z_j = params['W_m'] @ h_initial[j] + params['b_m']\n            m_tilde_j = np.tanh(z_j)\n            base_messages[j] = m_tilde_j\n\n        for i in range(num_atoms):\n            for j in range(num_atoms):\n                if i == j:\n                    continue\n                \n                # Distance\n                r_ij = np.linalg.norm(Rs[i] - Rs[j])\n                \n                # Radial filter\n                f_r = np.exp(-((r_ij - params['mu'])**2) / (2 * params['sigma']**2))\n\n                # Directed message\n                m_i_j = f_r * base_messages[j]\n                \n                # Collect for output\n                all_messages_flat.extend(m_i_j.tolist())\n\n                # Aggregate\n                aggregated_messages[i] += m_i_j\n\n        # 3. Feature Update\n        h_updated = np.zeros_like(h_initial)\n        all_updated_features_flat = []\n        \n        for i in range(num_atoms):\n            u_i = np.concatenate([h_initial[i], aggregated_messages[i]])\n            q_i = params['W_u'] @ u_i + params['b_u']\n            h_prime_i = np.tanh(q_i)\n            h_updated[i] = h_prime_i\n            all_updated_features_flat.extend(h_prime_i.tolist())\n\n        # 4. Energy Readout\n        total_energy = 0.0\n        if num_atoms > 0:\n            atomic_energies = h_updated @ params['v'] + params['c']\n            total_energy = np.sum(atomic_energies)\n\n        results.append([all_messages_flat, all_updated_features_flat, total_energy])\n\n    # Format output as specified\n    def format_case(case_result):\n        msg_list_str = f\"[{','.join([f'{m:.6f}' for m in case_result[0]])}]\"\n        feat_list_str = f\"[{','.join([f'{h:.6f}' for h in case_result[1]])}]\"\n        energy_str = f'{case_result[2]:.6f}'\n        return f\"[{msg_list_str},{feat_list_str},{energy_str}]\"\n    \n    all_cases_str = [format_case(case) for case in results]\n    final_output = f\"[{','.join(all_cases_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2908437"}]}