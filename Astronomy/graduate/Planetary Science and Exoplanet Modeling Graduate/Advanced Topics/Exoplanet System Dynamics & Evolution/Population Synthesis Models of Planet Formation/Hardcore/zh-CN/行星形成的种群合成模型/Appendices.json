{
    "hands_on_practices": [
        {
            "introduction": "行星群体合成模型的核心任务之一是追踪原行星盘的演化及其对行星形成的影响。水分雪线的位置是决定行星最终水含量的关键因素，它随着星盘的冷却而向内移动。这项练习将帮助你将一个关键的物理过程——雪线的动态演化——转化为对行星最终组成的定量预测，这是构建任何合成模型中成分模块的基础 。",
            "id": "4172891",
            "problem": "考虑一个被动和粘滞加热的原行星盘，其中心平面温度在半径和时间上遵循一个可分离的幂律，这与辐射平衡和衰减的吸积加热相一致。设中心平面温度为 $T(r,t) = T_{0} \\left(\\frac{t}{t_{0}}\\right)^{-\\alpha} \\left(\\frac{r}{r_{0}}\\right)^{-q}$，其中 $r$ 是到恒星的距离，$t$ 是时间，$T_{0}$ 是在半径 $r_{0}$ 和时间 $t_{0}$ 处的参考温度，$\\alpha$ 和 $q$ 是正常数。水雪线 $r_{\\mathrm{snow}}(t)$ 由条件 $T\\!\\left(r_{\\mathrm{snow}}(t), t\\right) = T_{\\mathrm{freeze}}$ 隐式定义，其中 $T_{\\mathrm{freeze}}$ 是水冰的升华温度。\n\n一个位于半径为 $r_{p}$ 的固定圆形轨道上的行星核，在一个吸积时期 $t \\in [t_{1}, t_{2}]$ 内吸积固体。瞬时固体吸积权重为 $W(t) = W_{0} \\exp\\!\\left(-\\frac{t}{\\tau}\\right)$，模拟了因径向漂移和凝聚导致的固体供应减少，其中 $W_{0}$ 是一个归一化常数，$\\tau$ 是一个衰减时间尺度。假设在任何时刻 $t$，在 $r_{p}$ 处吸积的固体是富含挥发物的当且仅当 $r_{p} > r_{\\mathrm{snow}}(t)$，否则是贫挥发物的。吸积固体质量中来自挥发物的分数由下式定义\n$$\nF_{\\mathrm{out}} = \\frac{\\displaystyle \\int_{t_{1}}^{t_{2}} W(t)\\, H\\!\\big(r_{p} - r_{\\mathrm{snow}}(t)\\big)\\, dt}{\\displaystyle \\int_{t_{1}}^{t_{2}} W(t)\\, dt},\n$$\n其中 $H(x)$ 是 Heaviside 阶跃函数。使用以下参数，这些参数被选为早期粘滞主导盘的代表值：$T_{0} = 240\\,\\mathrm{K}$，$T_{\\mathrm{freeze}} = 170\\,\\mathrm{K}$，$r_{0} = 1\\,\\mathrm{天文单位\\ (AU)}$，$t_{0} = 0.5\\,\\mathrm{百万年\\ (Myr)}$，$\\alpha = 1$，$q = \\frac{1}{2}$，$r_{p} = 2\\,\\mathrm{AU}$，$t_{1} = 0.3\\,\\mathrm{Myr}$，$t_{2} = 1.8\\,\\mathrm{Myr}$，以及 $\\tau = 0.6\\,\\mathrm{Myr}$。\n\n从所给的温度定律和雪线的定义出发，推导 $r_{\\mathrm{snow}}(t)$ 的显式解析表达式、满足 $r_{\\mathrm{snow}}(t_{\\times}) = r_{p}$ 的穿越时间 $t_{\\times}$，以及由此得到的 $F_{\\mathrm{out}}$ 表达式。然后，对给定参数，数值计算 $F_{\\mathrm{out}}$。将最终数值答案四舍五入至四位有效数字，并以无单位的小数形式表示。",
            "solution": "该问题表述清晰，有科学依据，并为得到唯一解提供了所有必要信息。我们按要求进行推导。\n\n首先，我们推导水雪线半径 $r_{\\mathrm{snow}}(t)$ 的解析表达式。雪线由条件 $T(r_{\\mathrm{snow}}(t), t) = T_{\\mathrm{freeze}}$ 定义。代入给定的温度分布，我们得到：\n$$\nT_{0} \\left(\\frac{t}{t_{0}}\\right)^{-\\alpha} \\left(\\frac{r_{\\mathrm{snow}}(t)}{r_{0}}\\right)^{-q} = T_{\\mathrm{freeze}}\n$$\n我们解此方程以求得 $r_{\\mathrm{snow}}(t)$。首先，我们分离出包含半径的项：\n$$\n\\left(\\frac{r_{\\mathrm{snow}}(t)}{r_{0}}\\right)^{-q} = \\frac{T_{\\mathrm{freeze}}}{T_{0}} \\left(\\frac{t}{t_{0}}\\right)^{\\alpha}\n$$\n接下来，我们将两边都取 $-\\frac{1}{q}$ 次幂：\n$$\n\\frac{r_{\\mathrm{snow}}(t)}{r_{0}} = \\left( \\frac{T_{\\mathrm{freeze}}}{T_{0}} \\left(\\frac{t}{t_{0}}\\right)^{\\alpha} \\right)^{-\\frac{1}{q}} = \\left(\\frac{T_{0}}{T_{\\mathrm{freeze}}}\\right)^{\\frac{1}{q}} \\left(\\frac{t}{t_{0}}\\right)^{-\\frac{\\alpha}{q}}\n$$\n因此，雪线半径作为时间函数的显式解析表达式为：\n$$\nr_{\\mathrm{snow}}(t) = r_{0} \\left(\\frac{T_{0}}{T_{\\mathrm{freeze}}}\\right)^{\\frac{1}{q}} \\left(\\frac{t}{t_{0}}\\right)^{-\\frac{\\alpha}{q}}\n$$\n\n其次，我们确定穿越时间 $t_{\\times}$，即雪线半径等于行星轨道半径 $r_p$ 的时刻。这由条件 $r_{\\mathrm{snow}}(t_{\\times}) = r_{p}$ 定义。使用上面推导出的 $r_{\\mathrm{snow}}(t)$ 表达式：\n$$\nr_{0} \\left(\\frac{T_{0}}{T_{\\mathrm{freeze}}}\\right)^{\\frac{1}{q}} \\left(\\frac{t_{\\times}}{t_{0}}\\right)^{-\\frac{\\alpha}{q}} = r_{p}\n$$\n我们求解 $t_{\\times}$。我们首先分离出包含 $t_{\\times}$ 的项：\n$$\n\\left(\\frac{t_{\\times}}{t_{0}}\\right)^{-\\frac{\\alpha}{q}} = \\frac{r_{p}}{r_{0}} \\left(\\frac{T_{0}}{T_{\\mathrm{freeze}}}\\right)^{-\\frac{1}{q}}\n$$\n现在，我们将两边都取 $-\\frac{q}{\\alpha}$ 次幂：\n$$\n\\frac{t_{\\times}}{t_{0}} = \\left(\\frac{r_{p}}{r_{0}}\\right)^{-\\frac{q}{\\alpha}} \\left(\\frac{T_{0}}{T_{\\mathrm{freeze}}}\\right)^{\\frac{1}{\\alpha}}\n$$\n因此，穿越时间的显式解析表达式为：\n$$\nt_{\\times} = t_{0} \\left(\\frac{r_{p}}{r_{0}}\\right)^{-\\frac{q}{\\alpha}} \\left(\\frac{T_{0}}{T_{\\mathrm{freeze}}}\\right)^{\\frac{1}{\\alpha}}\n$$\n\n第三，我们推导挥发物来源分数 $F_{\\mathrm{out}}$ 的表达式。其公式由下式给出：\n$$\nF_{\\mathrm{out}} = \\frac{\\displaystyle \\int_{t_{1}}^{t_{2}} W(t)\\, H\\!\\big(r_{p} - r_{\\mathrm{snow}}(t)\\big)\\, dt}{\\displaystyle \\int_{t_{1}}^{t_{2}} W(t)\\, dt}\n$$\nHeaviside 阶跃函数 $H(x)$ 在 $x > 0$ 时为 $1$，在 $x \\le 0$ 时为 $0$。Heaviside 函数的自变量是 $r_{p} - r_{\\mathrm{snow}}(t)$。因此，$H(r_{p} - r_{\\mathrm{snow}}(t)) = 1$ 当且仅当 $r_{p} > r_{\\mathrm{snow}}(t)$。\n由于 $\\alpha > 0$ 且 $q > 0$，$r_{\\mathrm{snow}}(t)$ 表达式中的指数 $-\\frac{\\alpha}{q}$ 为负，这意味着 $r_{\\mathrm{snow}}(t)$ 是时间 $t$ 的单调递减函数。盘冷却，雪线向内移动。\n时间 $t_{\\times}$ 是指 $r_{p} = r_{\\mathrm{snow}}(t_{\\times})$ 的时刻。因此，对于 $t > t_{\\times}$，我们有 $r_{\\mathrm{snow}}(t)  r_{\\mathrm{snow}}(t_{\\times}) = r_{p}$，所以 $r_{p} > r_{\\mathrm{snow}}(t)$。反之，对于 $t  t_{\\times}$，我们有 $r_{\\mathrm{snow}}(t) > r_p$。\n这意味着在积分区间 $[t_1, t_2]$ 内，Heaviside 函数在 $t > t_{\\times}$ 时取值为 $1$，在 $t \\le t_{\\times}$ 时取值为 $0$。\n\n$F_{\\mathrm{out}}$ 的分子是从雪线以外吸积的质量的积分。该积分仅在 $[t_1, t_2]$ 区间内且 $t > t_{\\times}$ 的时间段内非零。因此，分子的积分范围是从 $\\max(t_{1}, t_{\\times})$ 到 $t_{2}$。分母是从 $t_{1}$ 到 $t_{2}$ 积分的总吸积质量。\n我们必须首先计算 $t_{\\times}$ 的值，以便与 $t_1$ 和 $t_2$ 进行比较。使用给定参数：$t_{0} = 0.5\\,\\mathrm{Myr}$，$r_{p} = 2\\,\\mathrm{AU}$，$r_{0} = 1\\,\\mathrm{AU}$，$T_{0} = 240\\,\\mathrm{K}$，$T_{\\mathrm{freeze}} = 170\\,\\mathrm{K}$，$\\alpha = 1$ 以及 $q = \\frac{1}{2}$。\n$$\nt_{\\times} = (0.5\\,\\mathrm{Myr}) \\left(\\frac{2\\,\\mathrm{AU}}{1\\,\\mathrm{AU}}\\right)^{-\\frac{1/2}{1}} \\left(\\frac{240\\,\\mathrm{K}}{170\\,\\mathrm{K}}\\right)^{\\frac{1}{1}} = 0.5 \\times (2)^{-\\frac{1}{2}} \\times \\frac{24}{17} = \\frac{0.5 \\times 24}{17\\sqrt{2}} = \\frac{12}{17\\sqrt{2}}\\,\\mathrm{Myr}\n$$\n数值上，$t_{\\times} \\approx 0.4991\\,\\mathrm{Myr}$。吸积时期由 $t_1 = 0.3\\,\\mathrm{Myr}$ 和 $t_2 = 1.8\\,\\mathrm{Myr}$ 给出。由于 $t_1  t_{\\times}  t_2$，行星在从 $t_1$ 到 $t_{\\times}$ 的时间内吸积贫挥发物物质，在从 $t_{\\times}$ 到 $t_2$ 的时间内吸积富含挥发物物质。\n分子的积分变为 $\\int_{t_{\\times}}^{t_{2}} W(t) \\, dt$。所以，$F_{\\mathrm{out}}$ 为：\n$$\nF_{\\mathrm{out}} = \\frac{\\displaystyle \\int_{t_{\\times}}^{t_{2}} W(t) \\, dt}{\\displaystyle \\int_{t_{1}}^{t_{2}} W(t) \\, dt}\n$$\n代入 $W(t) = W_0 \\exp(-t/\\tau)$：\n$$\n\\int W(t) \\, dt = \\int W_{0} \\exp(-t/\\tau) \\, dt = -W_{0} \\tau \\exp(-t/\\tau) + C\n$$\n分子为：\n$$\n\\int_{t_{\\times}}^{t_{2}} W_{0} \\exp(-t/\\tau) \\, dt = \\left[-W_{0} \\tau \\exp(-t/\\tau)\\right]_{t_{\\times}}^{t_{2}} = W_{0} \\tau \\left(\\exp(-t_{\\times}/\\tau) - \\exp(-t_{2}/\\tau)\\right)\n$$\n分母为：\n$$\n\\int_{t_{1}}^{t_{2}} W_{0} \\exp(-t/\\tau) \\, dt = \\left[-W_{0} \\tau \\exp(-t/\\tau)\\right]_{t_{1}}^{t_{2}} = W_{0} \\tau \\left(\\exp(-t_{1}/\\tau) - \\exp(-t_{2}/\\tau)\\right)\n$$\n通过消去 $W_{0}\\tau$ 项，$F_{\\mathrm{out}}$ 的比值可简化为：\n$$\nF_{\\mathrm{out}} = \\frac{\\exp(-t_{\\times}/\\tau) - \\exp(-t_{2}/\\tau)}{\\exp(-t_{1}/\\tau) - \\exp(-t_{2}/\\tau)}\n$$\n这就是 $F_{\\mathrm{out}}$ 的最终解析表达式。\n\n最后，我们对 $F_{\\mathrm{out}}$ 进行数值计算。参数如下：\n$t_{1} = 0.3\\,\\mathrm{Myr}$\n$t_{2} = 1.8\\,\\mathrm{Myr}$\n$\\tau = 0.6\\,\\mathrm{Myr}$\n$t_{\\times} = \\frac{12}{17\\sqrt{2}}\\,\\mathrm{Myr}$\n我们计算指数的无量纲比值：\n$t_{1}/\\tau = \\frac{0.3}{0.6} = 0.5$\n$t_{2}/\\tau = \\frac{1.8}{0.6} = 3.0$\n$t_{\\times}/\\tau = \\frac{12/(17\\sqrt{2})}{0.6} = \\frac{20}{17\\sqrt{2}} = \\frac{10\\sqrt{2}}{17} \\approx 0.8319105$\n将这些值代入 $F_{\\mathrm{out}}$ 的表达式：\n$$\nF_{\\mathrm{out}} = \\frac{\\exp\\left(-\\frac{10\\sqrt{2}}{17}\\right) - \\exp(-3)}{\\exp(-0.5) - \\exp(-3)}\n$$\n使用计算器：\n$\\exp(-0.5) \\approx 0.60653066$\n$\\exp(-3) \\approx 0.04978707$\n$\\exp\\left(-\\frac{10\\sqrt{2}}{17}\\right) \\approx \\exp(-0.8319105) \\approx 0.43521268$\n$$\nF_{\\mathrm{out}} = \\frac{0.43521268 - 0.04978707}{0.60653066 - 0.04978707} = \\frac{0.38542561}{0.55674359} \\approx 0.692298\n$$\n四舍五入到四位有效数字，结果是 $0.6923$。",
            "answer": "$$\n\\boxed{0.6923}\n$$"
        },
        {
            "introduction": "一个复杂的群体合成模型由许多相互关联的物理模块组成，确保其整体正确性至关重要。本练习强调了在科学计算中进行严谨软件测试的必要性 。你将构建一个测试框架，用于验证代码是否遵守基本的物理守恒定律，以及是否正确地实现了关键物理过程（如行星迁移和吸积）之间的状态转换，这是保证模型鲁棒性和科学有效性的根本。",
            "id": "4172872",
            "problem": "您需要实现一个最小化的、自包含的行星族群合成测试框架，该框架用于验证简化的行星形成物理学中的基本守恒定律和区间转换。该程序必须为一个简化的“合成代码”构建单元测试和集成测试，该代码具备以下功能：牛顿引力下的保守双体轨道动力学、盘驱动迁移区间的分类，以及卵石吸积区间的分类。其目标是测试该实现在没有非保守力的情况下是否遵守能量和角动量守恒，以及是否根据广泛使用的标准在迁移和吸积区间之间正确转换。\n\n所有计算必须使用国际单位制（SI）。您的程序的最终输出必须是布尔值，指示每个测试用例的通过或失败。您的程序必须生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $\\left[\\text{True},\\text{False},\\dots\\right]$。\n\n需要实现的科学基础：\n- 保守双体动力学：一个质量为 $M_p$ 的行星围绕一个质量为 $M_*$ 的固定恒星在牛顿引力下运动。加速度由 $\\mathbf{a}(t) = - \\dfrac{G M_*}{\\lVert \\mathbf{r}(t) \\rVert^3} \\mathbf{r}(t)$ 给出，其中 $G$ 是引力常数，$\\mathbf{r}(t)$ 是行星的位置向量，$\\lVert \\cdot \\rVert$ 表示欧几里得范数。单位行星质量的比轨道能量为 $E(t) = \\dfrac{1}{2} \\lVert \\mathbf{v}(t) \\rVert^2 - \\dfrac{G M_*}{\\lVert \\mathbf{r}(t) \\rVert}$，单位行星质量的角动量大小为 $L(t) = \\lVert \\mathbf{r}(t) \\times \\mathbf{v}(t) \\rVert$。在纯粹保守的引力双体模型中（中心质量固定，无外部力矩），$E(t)$ 和 $L(t)$ 是常数。\n- 盘模型和迁移区间：在轨道半径 $r$ 处，定义盘表面密度 $\\Sigma$（单位 $\\mathrm{kg}\\,\\mathrm{m}^{-2}$）、标高比 $h = H/r$（其中 $H$ 是压力标高）以及无量纲的Shakura–Sunyaev黏度参数 $\\alpha$。开普勒角频率为 $\\Omega = \\sqrt{\\dfrac{G M_*}{r^3}}$，开普勒速度为 $v_K = r \\Omega$，声速为 $c_s = h r \\Omega$，运动黏度为 $\\nu = \\alpha c_s H = \\alpha h^2 r^2 \\Omega$。盘驱动的迁移区间为：\n  - I型：适用于无量纲质量比 $q = \\dfrac{M_p}{M_*}$ 低于间隙打开阈值时。使用简化的时标\n  $$t_{\\mathrm{I}} = \\left(\\dfrac{M_*}{M_p}\\right) \\left(\\dfrac{M_*}{\\Sigma r^2}\\right) \\left(\\dfrac{H}{r}\\right)^2 \\dfrac{1}{\\Omega} = \\left(\\dfrac{M_*}{M_p}\\right) \\left(\\dfrac{M_*}{\\Sigma r^2}\\right) h^2 \\dfrac{1}{\\Omega}。$$\n  - II型：适用于打开间隙时。使用黏滞时标\n  $$t_{\\mathrm{II}} = \\dfrac{r^2}{\\nu} = \\dfrac{1}{\\alpha h^2 \\Omega}。$$\n  - 间隙打开阈值：使用广泛应用的条件\n  $$q_{\\mathrm{gap}} = 40 \\,\\alpha \\, h^2。$$\n  如果 $q \\ge q_{\\mathrm{gap}}$，则分类为II型；否则分类为I型。\n- 卵石吸积区间和转换：定义邦迪半径 $R_{\\mathrm{B}} = \\dfrac{G M_p}{c_s^2}$ 和希尔半径 $R_{\\mathrm{H}} = r \\left(\\dfrac{M_p}{3 M_*}\\right)^{1/3}$。当 $R_{\\mathrm{B}}  R_{\\mathrm{H}}$ 时，将卵石吸积区间分类为邦迪（Bondi）区间；当 $R_{\\mathrm{B}} \\ge R_{\\mathrm{H}}$ 时，分类为希尔（Hill）区间。满足 $R_{\\mathrm{B}} = R_{\\mathrm{H}}$ 的转换行星质量 $M_{\\mathrm{BH}}$ 由下式给出\n$$\\left(\\dfrac{G M_{\\mathrm{BH}}}{c_s^2}\\right)^3 = r^3 \\left(\\dfrac{M_{\\mathrm{BH}}}{3 M_*}\\right) \\quad \\Rightarrow \\quad M_{\\mathrm{BH}} = \\sqrt{\\dfrac{r^3 c_s^6}{3 G^3 M_*}}。$$\n\n程序要求：\n- 为保守双体动力学实现一个时间积分器（例如，速度Verlet格式），并计算相对偏差 $\\delta_E = \\dfrac{\\max_t \\lvert E(t) - E(0) \\rvert}{\\lvert E(0) \\rvert}$ 和 $\\delta_L = \\dfrac{\\max_t \\lvert L(t) - L(0) \\rvert}{\\lvert L(0) \\rvert}$。\n- 实现函数，在给定 $M_*$、$M_p$、$r$、$\\alpha$、$h$ 和 $\\Sigma$ 的情况下，使用上述公式返回迁移区间分类（I型或II型）和相应的时标 $t_{\\mathrm{mig}}$。\n- 实现函数，在给定 $M_*$、$M_p$、$r$ 和 $h$ 的情况下，使用 $R_{\\mathrm{B}}$ 和 $R_{\\mathrm{H}}$ 的比较返回卵石吸积区间分类（邦迪或希尔），并计算用于边界测试的 $M_{\\mathrm{BH}}$。\n- 实现一个简单的迁移演化更新，将半长轴 $a$ 视为在局部指数漂移近似 $a_{n+1} = a_n \\left(1 - \\dfrac{\\Delta t}{t_{\\mathrm{mig}}}\\right)$（对于 $\\Delta t \\ll t_{\\mathrm{mig}}$）下演化，以验证在选定参数下I型迁移的单调向内迁移。不使用角度；无需指定角度单位。\n\n测试套件和参数值：\n在SI单位制下使用以下常量和参数：\n- $G = 6.67430 \\times 10^{-11} \\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。\n- $M_\\odot = 1.98847 \\times 10^{30} \\,\\mathrm{kg}$（太阳质量）。\n- $M_\\oplus = 5.9722 \\times 10^{24} \\,\\mathrm{kg}$（地球质量）。\n- $\\mathrm{au} = 1.495978707 \\times 10^{11} \\,\\mathrm{m}$（天文单位）。\n\n定义共享的盘和轨道参数：\n- $M_* = 1 \\, M_\\odot$。\n- $r = 1 \\,\\mathrm{au}$。\n- $h = 0.03$。\n- $\\alpha = 10^{-3}$。\n- $\\Sigma = 5000 \\,\\mathrm{kg}\\,\\mathrm{m}^{-2}$。\n\n定义轨道积分参数：\n- 在半径 $r$ 处以切向速度 $v_0 = \\sqrt{\\dfrac{G M_*}{r}}$ 初始化一个圆形轨道，初始位置沿 $x$ 轴。\n- 轨道周期 $P = 2\\pi \\sqrt{\\dfrac{r^3}{G M_*}}$。\n- 使用 $\\Delta t = \\dfrac{P}{5000}$，$N = 5000$ 步。\n- 能量容差：$\\varepsilon_E = 10^{-5}$；角动量容差：$\\varepsilon_L = 10^{-8}$。\n\n构建以下测试，每个测试返回一个布尔值：\n- 测试 $1$ (能量守恒)：使用 $M_p = 1 \\, M_\\oplus$，积分 $N$ 步，如果 $\\delta_E \\le \\varepsilon_E$ 则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $2$ (角动量守恒)：使用 $M_p = 1 \\, M_\\oplus$，积分 $N$ 步，如果 $\\delta_L \\le \\varepsilon_L$ 则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $3$ (迁移区间，低质量)：使用 $M_p = 5 \\, M_\\oplus$，计算 $q$ 和 $q_{\\mathrm{gap}}$，如果分类为I型且 $t_{\\mathrm{mig}} = t_{\\mathrm{I}}$，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $4$ (迁移区间，高质量)：使用 $M_p = 50 \\, M_\\oplus$，如果分类为II型且 $t_{\\mathrm{mig}} = t_{\\mathrm{II}}$，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $5$ (迁移区间，边界)：计算 $M_{\\mathrm{gap}} = q_{\\mathrm{gap}} M_*$，并在 $M_p = M_{\\mathrm{gap}}$ 时，如果分类为II型且 $t_{\\mathrm{mig}} = t_{\\mathrm{II}}$，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $6$ (吸积区间，邦迪)：计算 $c_s = h r \\Omega$ 和 $M_{\\mathrm{BH}}$；设置 $M_p = \\dfrac{1}{2} M_{\\mathrm{BH}}$，如果分类为邦迪，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $7$ (吸积区间，希尔)：设置 $M_p = 2 M_{\\mathrm{BH}}$，如果分类为希尔，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $8$ (吸积区间，边界)：设置 $M_p = M_{\\mathrm{BH}}$，如果分类为希尔（对希尔区间使用 $\\ge$），则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 测试 $9$ (迁移漂移的积分，单调向内I型)：使用 $M_p = 5 \\, M_\\oplus$ 和I型时标 $t_{\\mathrm{I}}$，通过 $a_{n+1} = a_n \\left(1 - \\dfrac{\\Delta t_{\\mathrm{mig}}}{t_{\\mathrm{I}}}\\right)$ 更新 $a$ 共 $N_{\\mathrm{mig}} = 100$ 步，其中 $\\Delta t_{\\mathrm{mig}} = \\dfrac{t_{\\mathrm{I}}}{1000}$。如果序列 $\\{a_n\\}$ 严格单调递减，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，按测试 $1$ 到 $9$ 的顺序排列，例如 $\\left[\\text{True},\\text{True},\\dots\\right]$。不得打印任何额外文本。",
            "solution": "该问题陈述是一个有效、定义明确且具有科学依据的请求，旨在为一个简化的行星族群合成模型创建一个测试框架。它提供了所有必要的物理常数、模型方程和测试用例参数，没有内部矛盾或含糊之处。所描述的物理学——牛顿双体动力学、标准的I型/II型迁移模型以及邦迪/希尔卵石吸积区间——是行星科学中标准（尽管是简化的）的概念。因此，该问题适合进行正式求解。\n\n该解决方案将作为一个单一、自包含的Python程序实现，其结构分为几个逻辑组件：\n1.  **全局常量和参数**：所有物理常数（$G$、$M_\\odot$、$M_\\oplus$、$\\mathrm{au}$）和共享的模拟参数（$M_*$、$r$、$h$、$\\alpha$、$\\Sigma$）将在程序开头以SI单位定义，以保证清晰性和易于修改。\n\n2.  **核心物理实现**：\n    *   **双体轨道动力学**：将实现一个函数，采用速度Verlet积分格式来求解运动方程 $\\mathbf{a}(t) = -G M_* \\mathbf{r}(t) / \\lVert \\mathbf{r}(t) \\rVert^3$。选择这种辛积分器是因为其出色的稳定性和守恒特性，这对于测试1和2至关重要。模拟将以三维方式跟踪行星的位置 $\\mathbf{r}(t)$ 和速度 $\\mathbf{v}(t)$。在每个时间步，将计算并存储比轨道能量 $E(t) = \\frac{1}{2}\\lVert\\mathbf{v}\\rVert^2 - G M_*/\\lVert\\mathbf{r}\\rVert$ 和比角动量大小 $L(t) = \\lVert\\mathbf{r} \\times \\mathbf{v}\\rVert$。模拟将运行一个完整的轨道周期。\n    *   **迁移区间和时标**：一个函数将实现用于分类盘驱动迁移的逻辑。它将计算行星-恒星质量比 $q = M_p/M_*$ 和间隙打开阈值参数 $q_{\\mathrm{gap}} = 40 \\alpha h^2$。基于比较 $q \\ge q_{\\mathrm{gap}}$，它将返回区间（I型或II型）和相应的迁移时标 $t_{\\mathrm{I}} = (\\frac{M_*}{M_p}) (\\frac{M_*}{\\Sigma r^2}) h^2 \\frac{1}{\\Omega}$ 或 $t_{\\mathrm{II}} = \\frac{1}{\\alpha h^2 \\Omega}$，其中 $\\Omega = \\sqrt{G M_*/r^3}$。\n    *   **卵石吸积区间**：另一个函数将对卵石吸积区间进行分类。它将计算声速 $c_s = h r \\Omega$、邦迪半径 $R_{\\mathrm{B}} = G M_p / c_s^2$ 和希尔半径 $R_{\\mathrm{H}} = r (M_p / (3 M_*))^{1/3}$。如果 $R_{\\mathrm{B}} \\ge R_{\\mathrm{H}}$，则区间为“希尔”（Hill），否则为“邦迪”（Bondi）。该函数还将计算 $R_{\\mathrm{B}} = R_{\\mathrm{H}}$ 时的转换质量 $M_{\\mathrm{BH}}$。\n\n3.  **测试套件实现**：将为问题陈述中指定的每个测试用例创建九个独立的函数。\n    *   **测试1和2（守恒）**：这些测试将调用轨道动力学模拟器。然后，它们将计算模拟过程中能量（$\\delta_E$）和角动量（$\\delta_L$）相对于其初始值的最大相对偏差。如果这些偏差在指定的容差 $\\varepsilon_E = 10^{-5}$ 和 $\\varepsilon_L = 10^{-8}$ 之内，则测试通过。\n    *   **测试3、4、5（迁移）**：这些测试将使用具有特定行星质量（$5 M_\\oplus$、$50 M_\\oplus$ 以及计算出的间隙打开质量 $M_{\\mathrm{gap}}$）的迁移分类函数，以验证在每种情况（低质量、高质量和边界）下都能识别出正确的区间和时标。\n    *   **测试6、7、8（吸积）**：这些测试将首先计算邦迪-希尔转换质量 $M_{\\mathrm{BH}}$。然后，它们将使用相对于此阈值的质量（$0.5 M_{\\mathrm{BH}}$、$2 M_{\\mathrm{BH}}$ 和 $M_{\\mathrm{BH}}$）的吸积分类函数，以确认它能正确识别邦迪和希尔区间，包括边界条件。\n    *   **测试9（迁移漂移）**：此测试将使用提供的一阶衰减模型 $a_{n+1} = a_n (1 - \\Delta t_{\\mathrm{mig}}/t_{\\mathrm{I}})$ 模拟半长轴 $a$ 的演化。如果得到的 $a$ 值序列是严格单调递减的，则测试通过，从而证实预期的向内漂移。\n\n4.  **主执行逻辑**：一个最终的 `solve()` 函数将协调所有九个测试的执行，将其布尔结果收集到一个列表中，并按指定的逗号分隔格式（用方括号括起来）将此列表打印到标准输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the population synthesis model test suite.\n    \"\"\"\n\n    # --- Scientific Constants (SI units) ---\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    M_SOLAR = 1.98847e30  # kg\n    M_EARTH = 5.9722e24  # kg\n    AU = 1.495978707e11  # m\n\n    # --- Shared Disk and Orbit Parameters (SI units) ---\n    M_STAR = 1.0 * M_SOLAR\n    R_ORBIT = 1.0 * AU\n    H_R = 0.03  # aspect ratio h = H/r\n    ALPHA = 1.0e-3  # Shakura-Sunyaev viscosity parameter\n    SIGMA = 5000.0  # kg m^-2\n\n    # --- Orbital Integration Parameters ---\n    ORBIT_PERIOD = 2.0 * np.pi * np.sqrt(R_ORBIT**3 / (G * M_STAR))\n    DT = ORBIT_PERIOD / 5000.0\n    N_STEPS = 5000\n    TOLERANCE_E = 1.0e-5\n    TOLERANCE_L = 1.0e-8\n\n    # --- Pre-computed derived quantities ---\n    OMEGA_K = np.sqrt(G * M_STAR / R_ORBIT**3)  # Keplerian angular frequency\n    V_K = R_ORBIT * OMEGA_K  # Keplerian speed\n    C_S = H_R * R_ORBIT * OMEGA_K  # Sound speed\n\n    # --- Physics Helper Functions ---\n\n    def run_two_body_simulation(m_p):\n        \"\"\"\n        Integrates a two-body orbit using velocity Verlet and checks conservation.\n        Returns relative energy and angular momentum deviations.\n        \"\"\"\n        # Initial conditions for a circular orbit\n        r = np.array([R_ORBIT, 0.0, 0.0])\n        v = np.array([0.0, V_K, 0.0])\n\n        def get_accel(pos_vec):\n            r_norm = np.linalg.norm(pos_vec)\n            return -G * M_STAR * pos_vec / r_norm**3\n\n        energies = []\n        ang_momenta = []\n\n        a = get_accel(r)\n\n        for _ in range(N_STEPS):\n            # Calculate and store E and L for the current state (r, v)\n            r_norm = np.linalg.norm(r)\n            v_norm_sq = np.dot(v, v)\n            energy = 0.5 * v_norm_sq - G * M_STAR / r_norm\n            ang_momentum = np.linalg.norm(np.cross(r, v))\n            energies.append(energy)\n            ang_momenta.append(ang_momentum)\n\n            # Velocity Verlet steps\n            v_half = v + 0.5 * a * DT\n            r = r + v_half * DT\n            a = get_accel(r)\n            v = v_half + 0.5 * a * DT\n        \n        E0 = energies[0]\n        L0 = ang_momenta[0]\n\n        max_delta_E_abs = np.max(np.abs(np.array(energies) - E0))\n        max_delta_L_abs = np.max(np.abs(np.array(ang_momenta) - L0))\n\n        delta_E = max_delta_E_abs / np.abs(E0)\n        delta_L = max_delta_L_abs / np.abs(L0) if L0 != 0 else 0\n        \n        return delta_E, delta_L\n\n    def get_migration_regime(m_p):\n        q = m_p / M_STAR\n        q_gap = 40.0 * ALPHA * H_R**2\n        \n        if q >= q_gap:\n            timescale = 1.0 / (ALPHA * H_R**2 * OMEGA_K)\n            return \"Type II\", timescale\n        else:\n            timescale = (M_STAR / m_p) * (M_STAR / (SIGMA * R_ORBIT**2)) * (H_R**2) / OMEGA_K\n            return \"Type I\", timescale\n\n    def get_accretion_regime(m_p):\n        r_bondi = G * m_p / C_S**2\n        r_hill = R_ORBIT * (m_p / (3.0 * M_STAR))**(1.0/3.0)\n        \n        if r_bondi >= r_hill:\n            return \"Hill\"\n        else:\n            return \"Bondi\"\n\n    # --- Test Functions ---\n\n    def test_1_energy_conservation():\n        delta_e, _ = run_two_body_simulation(1.0 * M_EARTH)\n        return delta_e = TOLERANCE_E\n\n    def test_2_ang_mom_conservation():\n        _, delta_l = run_two_body_simulation(1.0 * M_EARTH)\n        return delta_l = TOLERANCE_L\n\n    def test_3_migration_low_mass():\n        m_p = 5.0 * M_EARTH\n        regime, t_mig = get_migration_regime(m_p)\n        _, t_I = get_migration_regime(m_p) # ensures comparison is with the calculated value\n        return regime == \"Type I\" and t_mig == t_I\n\n    def test_4_migration_high_mass():\n        m_p = 50.0 * M_EARTH\n        regime, t_mig = get_migration_regime(m_p)\n        _, t_II = get_migration_regime(m_p) # ensures comparison is with the calculated value\n        return regime == \"Type II\" and t_mig == t_II\n\n    def test_5_migration_boundary():\n        q_gap = 40.0 * ALPHA * H_R**2\n        m_gap = q_gap * M_STAR\n        regime, t_mig = get_migration_regime(m_gap)\n        _, t_II = get_migration_regime(m_gap)\n        return regime == \"Type II\" and t_mig == t_II\n    \n    def test_6_accretion_bondi():\n        m_bh_sq = (R_ORBIT**3 * C_S**6) / (3 * G**3 * M_STAR)\n        m_bh = np.sqrt(m_bh_sq)\n        m_p = 0.5 * m_bh\n        return get_accretion_regime(m_p) == \"Bondi\"\n\n    def test_7_accretion_hill():\n        m_bh_sq = (R_ORBIT**3 * C_S**6) / (3 * G**3 * M_STAR)\n        m_bh = np.sqrt(m_bh_sq)\n        m_p = 2.0 * m_bh\n        return get_accretion_regime(m_p) == \"Hill\"\n\n    def test_8_accretion_boundary():\n        m_bh_sq = (R_ORBIT**3 * C_S**6) / (3 * G**3 * M_STAR)\n        m_bh = np.sqrt(m_bh_sq)\n        m_p = m_bh\n        return get_accretion_regime(m_p) == \"Hill\"\n\n    def test_9_migration_drift():\n        m_p = 5.0 * M_EARTH\n        _, t_I = get_migration_regime(m_p)\n        \n        n_mig_steps = 100\n        dt_mig = t_I / 1000.0\n        \n        a_vals = [R_ORBIT]\n        current_a = R_ORBIT\n        \n        for _ in range(n_mig_steps):\n            current_a = current_a * (1.0 - dt_mig / t_I)\n            a_vals.append(current_a)\n        \n        a_vals = np.array(a_vals)\n        return np.all(np.diff(a_vals)  0)\n\n    # --- Execute Tests and Print Results ---\n    results = [\n        test_1_energy_conservation(),\n        test_2_ang_mom_conservation(),\n        test_3_migration_low_mass(),\n        test_4_migration_high_mass(),\n        test_5_migration_boundary(),\n        test_6_accretion_bondi(),\n        test_7_accretion_hill(),\n        test_8_accretion_boundary(),\n        test_9_migration_drift(),\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}