{
    "hands_on_practices": [
        {
            "introduction": "A central question in planetary dynamics is how to predict the long-term stability of a system from its current architecture. This exercise provides a hands-on opportunity to explore the connection between orbital spacing and dynamical history by analyzing mock exoplanet data. You will use the normalized separation in mutual Hill radii, denoted by $\\Delta$, a key theoretical metric for stability, to test the hypothesis that dynamically packed systems are more likely to exhibit high eccentricities—a tell-tale sign of past scattering events . This practice will sharpen your skills in applying theoretical concepts to observational data and performing statistical analysis to validate physical hypotheses.",
            "id": "4169797",
            "problem": "You are given sets of planetary pairs from exoplanet systems. For each pair, the host star mass, planet masses, semi-major axes, and eccentricities are specified. Your task is to compute the normalized separation in mutual Hill radii, denoted by $\\Delta$, for each pair and to test, at the dataset level, whether systems with $\\Delta \\le 10$ exhibit higher eccentricities consistent with past scattering compared to systems with $\\Delta > 10$. The test must be performed using a statistically sound, distribution-free method.\n\nFoundational base:\n- Use Newtonian gravity and the Hill sphere concept to derive the mutual Hill radius. For two planets with masses $m_1$ and $m_2$ orbiting a star of mass $M_\\star$, at semi-major axes $a_1$ and $a_2$ (with $a_2 > a_1$), the mutual Hill radius $R_{\\mathrm{H}}$ is given by\n$$\nR_{\\mathrm{H}} = \\frac{a_1+a_2}{2} \\left(\\frac{m_1 + m_2}{3 M_\\star}\\right)^{1/3}.\n$$\n- The normalized separation is\n$$\n\\Delta = \\frac{a_2 - a_1}{R_{\\mathrm{H}}}.\n$$\n- The pair-level eccentricity metric $e_{\\mathrm{pair}}$ is defined as the larger of the two eccentricities: $e_{\\mathrm{pair}} = \\max(e_1, e_2)$.\n\nStatistical test:\n- Partition the planet pairs into two groups: $\\mathcal{G}_{\\mathrm{small}} = \\{ \\text{pairs} : \\Delta \\le 10 \\}$ and $\\mathcal{G}_{\\mathrm{large}} = \\{ \\text{pairs} : \\Delta > 10 \\}$.\n- Use the one-sided Mann–Whitney U (MWU) test to test whether the distribution of $e_{\\mathrm{pair}}$ in $\\mathcal{G}_{\\mathrm{small}}$ tends to be larger than that in $\\mathcal{G}_{\\mathrm{large}}$. Report a boolean per dataset: return $\\mathrm{True}$ if both the MWU $p$-value is smaller than $0.05$ and the mean of $e_{\\mathrm{pair}}$ in $\\mathcal{G}_{\\mathrm{small}}$ is greater than the mean in $\\mathcal{G}_{\\mathrm{large}}$; otherwise return $\\mathrm{False}$. If either group is empty, return $\\mathrm{False}$.\n\nUnits:\n- $M_\\star$ must be in Solar masses.\n- $m_1$ and $m_2$ must be in Earth masses.\n- $a_1$ and $a_2$ must be in astronomical units (AU).\n- Eccentricities $e_1$ and $e_2$ are dimensionless numbers.\n- There are no angles in this problem.\n\nImplementation requirements:\n- Convert planet masses from Earth masses to Solar masses using $1\\,M_{\\oplus} = 3.003\\times 10^{-6}\\,M_{\\odot}$ before evaluating $R_{\\mathrm{H}}$.\n- For each dataset, compute all $\\Delta$ and $e_{\\mathrm{pair}}$ values, perform the MWU test, and generate the boolean output as specified.\n\nTest suite:\n- Dataset 1 (mixture, expected to show higher eccentricities in $\\mathcal{G}_{\\mathrm{small}}$):\n  - $(M_\\star, m_1, m_2, a_1, a_2, e_1, e_2) = (1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20)$\n  - $(1.0, 100.0, 80.0, 0.5, 0.62, 0.12, 0.15)$\n  - $(1.0, 5.0, 5.0, 0.3, 0.6, 0.03, 0.02)$\n  - $(1.0, 10.0, 12.0, 1.0, 2.5, 0.04, 0.05)$\n  - $(1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n  - $(1.0, 20.0, 30.0, 0.9, 1.8, 0.06, 0.08)$\n- Dataset 2 (boundary-included $\\Delta \\approx 10$, expected not to show higher eccentricities in $\\mathcal{G}_{\\mathrm{small}}$):\n  - $(1.0, 5.0, 5.0, 0.8925, 1.1075, 0.02, 0.03)$\n  - $(1.0, 5.0, 10.0, 0.5, 0.7, 0.10, 0.09)$\n  - $(1.0, 20.0, 20.0, 1.0, 1.18, 0.04, 0.04)$\n  - $(1.0, 10.0, 10.0, 0.2, 0.45, 0.08, 0.10)$\n  - $(1.0, 30.0, 40.0, 3.0, 3.25, 0.05, 0.07)$\n- Dataset 3 (varying host mass, expected to show higher eccentricities in $\\mathcal{G}_{\\mathrm{small}}$):\n  - $(0.8, 300.0, 200.0, 1.0, 1.3, 0.25, 0.22)$\n  - $(0.8, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n  - $(0.8, 100.0, 80.0, 0.5, 0.62, 0.15, 0.12)$\n  - $(0.8, 10.0, 10.0, 0.2, 0.45, 0.03, 0.04)$\n  - $(0.8, 20.0, 30.0, 0.9, 1.8, 0.06, 0.07)$\n- Dataset 4 (edge case: all pairs have $\\Delta > 10$, so $\\mathcal{G}_{\\mathrm{small}}$ is empty; must return $\\mathrm{False}$):\n  - $(1.0, 5.0, 6.0, 0.3, 0.9, 0.12, 0.08)$\n  - $(1.2, 8.0, 7.0, 1.5, 3.0, 0.14, 0.10)$\n  - $(0.9, 4.0, 5.0, 0.1, 0.3, 0.05, 0.07)$\n\nFinal output format:\n- Your program should produce a single line of output containing the boolean results for the four datasets as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$. The output values are pure booleans and have no units.",
            "solution": "The problem statement has been critically validated and is deemed to be self-contained, scientifically grounded, and well-posed. All data, formulas, and procedures are provided, allowing for a unique and verifiable solution. We shall proceed with the analysis.\n\nThe objective is to determine, for several datasets of exoplanet pairs, whether systems with small orbital separations exhibit statistically significant higher eccentricities, a potential signature of past dynamical scattering events. This involves calculating the normalized separation $\\Delta$ in mutual Hill radii and a pair-wise eccentricity metric $e_{\\mathrm{pair}}$, followed by a statistical comparison between two groups of systems.\n\nThe methodology is as follows:\n\n1.  For each planetary pair $(M_\\star, m_1, m_2, a_1, a_2, e_1, e_2)$, we first compute the pair-level eccentricity metric, $e_{\\mathrm{pair}}$, which is defined as the maximum of the two planetary eccentricities:\n    $$e_{\\mathrm{pair}} = \\max(e_1, e_2)$$\n\n2.  Next, we calculate the normalized separation $\\Delta$. This requires the mutual Hill radius, $R_{\\mathrm{H}}$. The planet masses, given in Earth masses ($M_{\\oplus}$), must be converted to Solar masses ($M_{\\odot}$) using the provided relation: $1\\,M_{\\oplus} = 3.003 \\times 10^{-6}\\,M_{\\odot}$. Let the masses in Solar units be $M_{1, \\odot}$ and $M_{2, \\odot}$.\n    The mutual Hill radius is then:\n    $$R_{\\mathrm{H}} = \\frac{a_1+a_2}{2} \\left(\\frac{M_{1, \\odot} + M_{2, \\odot}}{3 M_\\star}\\right)^{1/3}$$\n\n3.  With $R_{\\mathrm{H}}$, the normalized separation $\\Delta$ is calculated as:\n    $$\\Delta = \\frac{a_2 - a_1}{R_{\\mathrm{H}}}$$\n\n4.  Based on the value of $\\Delta$, each pair is assigned to one of two groups:\n    -   $\\mathcal{G}_{\\mathrm{small}} = \\{ \\text{pairs} : \\Delta \\le 10 \\}$\n    -   $\\mathcal{G}_{\\mathrm{large}} = \\{ \\text{pairs} : \\Delta > 10 \\}$\n    The set of $e_{\\mathrm{pair}}$ values corresponding to these groups will be denoted as $E_{\\mathrm{small}}$ and $E_{\\mathrm{large}}$, respectively.\n\n5.  The core of the analysis is a statistical test. The problem specifies a boolean output for each dataset based on a two-part condition. A result of $\\mathrm{True}$ is returned if and only if both of the following conditions are met:\n    -   The arithmetic mean of the eccentricities in the small-separation group is strictly greater than that of the large-separation group: $\\mathrm{mean}(E_{\\mathrm{small}}) > \\mathrm{mean}(E_{\\mathrm{large}})$.\n    -   A one-sided Mann-Whitney U (MWU) test, which tests the alternative hypothesis that the distribution of $E_{\\mathrm{small}}$ is stochastically larger than that of $E_{\\mathrm{large}}$, yields a $p$-value strictly less than $0.05$.\n\n6.  As a boundary condition, if either $\\mathcal{G}_{\\mathrm{small}}$ or $\\mathcal{G}_{\\mathrm{large}}$ is empty for a given dataset, the result for that dataset is immediately $\\mathrm{False}$.\n\nLet us perform a detailed analysis for Dataset 1 to illustrate the procedure. The dataset consists of 6 planetary pairs.\n\n-   Pair 1: $(1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20)$\n    $m_1 + m_2 = 500.0\\,M_\\oplus = 1.5015 \\times 10^{-3}\\,M_\\odot$.\n    $R_{\\mathrm{H}} = \\frac{0.9+1.3}{2} (\\frac{1.5015 \\times 10^{-3}}{3 \\times 1.0})^{1/3} \\approx 0.0873\\,\\text{AU}$.\n    $\\Delta = \\frac{1.3-0.9}{0.0873} \\approx 4.58$. Since $\\Delta \\le 10$, this pair belongs to $\\mathcal{G}_{\\mathrm{small}}$.\n    $e_{\\mathrm{pair}} = \\max(0.15, 0.20) = 0.20$.\n\n-   Pair 5: $(1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30)$\n    $m_1 + m_2 = 560.0\\,M_\\oplus = 1.68168 \\times 10^{-3}\\,M_\\odot$.\n    $R_{\\mathrm{H}} = \\frac{5.0+5.3}{2} (\\frac{1.68168 \\times 10^{-3}}{3 \\times 1.0})^{1/3} \\approx 0.3040\\,\\text{AU}$.\n    $\\Delta = \\frac{5.3-5.0}{0.3040} \\approx 0.99$. Since $\\Delta \\le 10$, this pair belongs to $\\mathcal{G}_{\\mathrm{small}}$.\n    $e_{\\mathrm{pair}} = \\max(0.35, 0.30) = 0.35$.\n\nApplying this procedure to all pairs in Dataset 1 yields the following partition:\n-   $E_{\\mathrm{small}} = \\{0.20, 0.15, 0.35\\}$ from pairs with $\\Delta \\approx \\{4.58, 3.71, 0.99\\}$.\n-   $E_{\\mathrm{large}} = \\{0.03, 0.05, 0.08\\}$ from pairs with $\\Delta \\approx \\{30.71, 30.62, 19.10\\}$.\n\nNow, we apply the decision criteria:\n-   $\\mathrm{mean}(E_{\\mathrm{small}}) = (0.20+0.15+0.35)/3 \\approx 0.233$.\n-   $\\mathrm{mean}(E_{\\mathrm{large}}) = (0.03+0.05+0.08)/3 \\approx 0.053$.\nThe condition $\\mathrm{mean}(E_{\\mathrm{small}}) > \\mathrm{mean}(E_{\\mathrm{large}})$ is satisfied.\n\n-   Next, we perform the one-sided Mann-Whitney U test on $E_{\\mathrm{small}}$ and $E_{\\mathrm{large}}$. For these two samples of size $n_1=3$ and $n_2=3$, the data are perfectly separated by rank, which represents the most extreme possible outcome. The number of ways to arrange the 6 combined samples is $\\binom{6}{3} = 20$. The observed extreme case occurs only once. Therefore, the exact one-tailed $p$-value for this most-extreme outcome is $p = 1/20 = 0.05$.\n\nThe decision rule requires the $p$-value to be strictly smaller than $0.05$. Since our calculated $p$-value is $0.05$, the condition $p < 0.05$ is not met. Consequently, the result for Dataset 1 is $\\mathrm{False}$.\n\nA crucial insight here is that for certain small sample sizes, it is mathematically impossible to achieve a $p$-value less than the conventional significance level of $\\alpha = 0.05$. For sample sizes $(3, 3)$, the minimum possible $p$-value is $0.05$. For Dataset 3, with sample sizes $(3, 2)$, the minimum possible $p$-value is $1/\\binom{5}{2} = 0.1$. In these cases, the null hypothesis can never be rejected at the specified significance level, regardless of how separated the data are. This lack of statistical power is a direct consequence of the small number of data points.\n\nThe final boolean results for all datasets are derived by strict adherence to the specified procedure.\n-   **Dataset 1:** Result is $\\mathrm{False}$ ($p=0.05$, not $< 0.05$).\n-   **Dataset 2:** Result is $\\mathrm{False}$ (mean condition fails: $0.047 \\ngtr 0.1$).\n-   **Dataset 3:** Result is $\\mathrm{False}$ ($p=0.1$, not $< 0.05$).\n-   **Dataset 4:** Result is $\\mathrm{False}$ ($\\mathcal{G}_{\\mathrm{small}}$ is empty).\n\nTherefore, based on a rigorous application of the stated rules, none of the datasets meet the criteria for a $\\mathrm{True}$ outcome.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import mannwhitneyu\n\ndef solve():\n    \"\"\"\n    Main function to process datasets and print results.\n    \"\"\"\n    \n    # Conversion constant from Earth mass to Solar mass.\n    M_EARTH_TO_SOLAR = 3.003e-6\n\n    # Test suite of four datasets.\n    # Each tuple represents a planetary pair:\n    # (M_star, m1, m2, a1, a2, e1, e2)\n    # M_star in Solar masses, m1/m2 in Earth masses, a1/a2 in AU.\n    test_suite = [\n        # Dataset 1\n        [\n            (1.0, 300.0, 200.0, 0.9, 1.3, 0.15, 0.20),\n            (1.0, 100.0, 80.0, 0.5, 0.62, 0.12, 0.15),\n            (1.0, 5.0, 5.0, 0.3, 0.6, 0.03, 0.02),\n            (1.0, 10.0, 12.0, 1.0, 2.5, 0.04, 0.05),\n            (1.0, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30),\n            (1.0, 20.0, 30.0, 0.9, 1.8, 0.06, 0.08),\n        ],\n        # Dataset 2\n        [\n            (1.0, 5.0, 5.0, 0.8925, 1.1075, 0.02, 0.03),\n            (1.0, 5.0, 10.0, 0.5, 0.7, 0.10, 0.09),\n            (1.0, 20.0, 20.0, 1.0, 1.18, 0.04, 0.04),\n            (1.0, 10.0, 10.0, 0.2, 0.45, 0.08, 0.10),\n            (1.0, 30.0, 40.0, 3.0, 3.25, 0.05, 0.07),\n        ],\n        # Dataset 3\n        [\n            (0.8, 300.0, 200.0, 1.0, 1.3, 0.25, 0.22),\n            (0.8, 260.0, 300.0, 5.0, 5.3, 0.35, 0.30),\n            (0.8, 100.0, 80.0, 0.5, 0.62, 0.15, 0.12),\n            (0.8, 10.0, 10.0, 0.2, 0.45, 0.03, 0.04),\n            (0.8, 20.0, 30.0, 0.9, 1.8, 0.06, 0.07),\n        ],\n        # Dataset 4\n        [\n            (1.0, 5.0, 6.0, 0.3, 0.9, 0.12, 0.08),\n            (1.2, 8.0, 7.0, 1.5, 3.0, 0.14, 0.10),\n            (0.9, 4.0, 5.0, 0.1, 0.3, 0.05, 0.07),\n        ],\n    ]\n\n    def process_dataset(dataset):\n        \"\"\"\n        Processes a single dataset of planetary pairs.\n        \"\"\"\n        e_pair_small = []\n        e_pair_large = []\n\n        for pair in dataset:\n            m_star, m1_earth, m2_earth, a1, a2, e1, e2 = pair\n\n            # Convert planet masses to Solar masses\n            m1_solar = m1_earth * M_EARTH_TO_SOLAR\n            m2_solar = m2_earth * M_EARTH_TO_SOLAR\n            \n            # Calculate mutual Hill radius\n            mass_ratio_term = (m1_solar + m2_solar) / (3 * m_star)\n            r_hill = ((a1 + a2) / 2) * (mass_ratio_term**(1/3))\n\n            # Calculate normalized separation, avoiding division by zero\n            if r_hill == 0:\n                # This case shouldn't happen with given data but is good practice\n                delta = float('inf')\n            else:\n                delta = (a2 - a1) / r_hill\n            \n            # Calculate pair-level eccentricity\n            e_pair = max(e1, e2)\n\n            # Partition the pair into groups based on delta\n            if delta <= 10:\n                e_pair_small.append(e_pair)\n            else:\n                e_pair_large.append(e_pair)\n        \n        # If either group is empty, the result is False\n        if not e_pair_small or not e_pair_large:\n            return False\n\n        # Convert lists to numpy arrays for mean calculation\n        e_small_np = np.array(e_pair_small)\n        e_large_np = np.array(e_pair_large)\n\n        # Check if the mean of the small group is greater than the large group\n        mean_condition = np.mean(e_small_np) > np.mean(e_large_np)\n        \n        # Perform one-sided Mann-Whitney U test\n        # alternative='greater' tests if x is stochastically larger than y\n        try:\n            _, p_value = mannwhitneyu(e_small_np, e_large_np, alternative='greater')\n        except ValueError:\n            # This can happen if all values in one sample are the same,\n            # though not the case with the given test data.\n            return False\n\n        # The p-value must be strictly less than 0.05\n        p_value_condition = p_value < 0.05\n\n        # Return True only if both conditions are met\n        return mean_condition and p_value_condition\n\n    results = [process_dataset(ds) for ds in test_suite]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When a planetary system becomes dynamically unstable, planets undergo a series of close encounters that dramatically reshape the system's architecture. This exercise delves into the physics governing the two primary end-states of this violent evolution: physical collision or ejection of a planet from the system. By combining the concepts of the Hill radius, gravitational focusing, and encounter cross-sections, you will derive a fundamental scaling law that predicts how the relative probability of collision versus ejection depends on the planet's semi-major axis . This practice is crucial for building physical intuition about the processes that sculpt the final diversity of planetary system architectures.",
            "id": "4169856",
            "problem": "Consider two equal-mass planets of mass $M_p$ and physical radius $R_p$ orbiting a star of mass $M_*$ on initially nearly circular, coplanar orbits with semi-major axis $a$. The planets undergo dynamical instability and repeated close encounters, during which either a physical collision (merger) can occur or one planet can be ejected from the system. Assume Newtonian gravity, point-mass stars and planets except for the finite planetary radii $R_p$, and that the relative speed at infinity for planet-planet hyperbolic encounters is comparable to a characteristic speed set by the local dynamics. Let the mutual Hill radius be defined in the usual way for two equal-mass planets, and assume that the distribution of encounter impact parameters is approximately uniform over the area of the mutual Hill sphere. Treat the per-encounter probability of ejection conditioned on entering the strong-scattering regime as independent of $a$ when expressed in Hill units, and neglect tidal dissipation, gas drag, and additional bodies. Using only first principles and well-tested facts (Newton’s laws, Keplerian orbital scalings, the mutual Hill radius definition, and classical gravitational focusing in two-body hyperbolic encounters), determine how the ratio of the probability of collision to the probability of ejection, $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$, scales with $a$. Which option best captures both the scaling and the physical interpretation of how finite planetary radii and physical collisions reduce the ejection probability at small $a$ compared to large $a$ where collisions are rarer?\n\nA. $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$ scales approximately as $\\left(\\dfrac{R_p}{a}\\right)^2$ multiplied by a gravitational focusing factor that grows linearly with $a$, namely\n$$\\frac{P_{\\mathrm{coll}}}{P_{\\mathrm{ej}}}\\ \\propto\\ \\left(\\frac{R_c}{R_H}\\right)^2\\left[1+\\frac{v_{\\mathrm{esc}}^2}{v_H^2}\\right]\\ =\\ \\left(\\frac{R_c}{a\\left(\\dfrac{2M_p}{3M_*}\\right)^{1/3}}\\right)^2\\left[1+\\left(\\frac{3}{2}\\right)^{2/3}\\frac{2a\\,M_p^{1/3}}{R_c\\,M_*^{1/3}}\\right],$$\nwith $R_c\\approx 2R_p$, $R_H=a\\left(\\dfrac{2M_p}{3M_*}\\right)^{1/3}$, $v_{\\mathrm{esc}}^2=\\dfrac{2GM_p}{R_c}$, and $v_H^2=\\dfrac{GM_*}{a}\\left(\\dfrac{2M_p}{3M_*}\\right)^{2/3}$. Therefore, $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$ decreases with increasing $a$ roughly as $a^{-2}$ at small $a$ and as $a^{-1}$ when gravitational focusing dominates, implying that collisions are relatively common at small $a$ and suppress ejections, whereas at large $a$ collisions are rarer and ejections are more probable.\n\nB. $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$ is independent of $a$ because encounter dynamics are scale-free in Hill units, so finite planetary radii do not alter the outcome statistics across different $a$.\n\nC. $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$ increases with $a$ since gravitational focusing strengthens at large $a$, making collisions increasingly more likely than ejections as $a$ grows.\n\nD. $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$ decreases exponentially with $a$ due to Keplerian shear exponentially suppressing small impact parameters at larger $a$, which overwhelms any gravitational focusing effects.",
            "solution": "The problem asks for the scaling of the ratio of collision probability to ejection probability, $P_{\\mathrm{coll}}/P_{\\mathrm{ej}}$, with respect to the semi-major axis $a$. We are given that the per-encounter probability of ejection, $P_{\\mathrm{ej}}$, can be treated as a constant independent of $a$. Thus, we need to determine the scaling of the per-encounter collision probability, $P_{\\mathrm{coll}}$.\n$$ \\frac{P_{\\mathrm{coll}}}{P_{\\mathrm{ej}}} \\propto P_{\\mathrm{coll}} $$\nThe problem assumes that encounters are uniformly distributed over the cross-sectional area of the mutual Hill sphere. The probability of a collision is therefore the ratio of the collision cross-section, $\\sigma_{\\mathrm{coll}}$, to the encounter cross-section, which is the area of the Hill sphere, $\\sigma_{\\mathrm{int}} = \\pi R_H^2$.\n$$ P_{\\mathrm{coll}} = \\frac{\\sigma_{\\mathrm{coll}}}{\\sigma_{\\mathrm{int}}} = \\frac{\\sigma_{\\mathrm{coll}}}{\\pi R_H^2} $$\nThe collision cross-section is enhanced by gravitational focusing. For two planets to collide, their centers must approach within the collision radius $R_c = 2R_p$. The gravitationally focused cross-section is given by:\n$$ \\sigma_{\\mathrm{coll}} = \\pi R_c^2 \\left(1 + \\frac{v_{\\mathrm{esc, rel}}^2}{v_{\\infty}^2}\\right) $$\nHere, $v_{\\infty}$ is the relative encounter velocity at large separation, and $v_{\\mathrm{esc, rel}}$ is the escape velocity from the combined two-planet system at contact. The escape velocity term is $v_{\\mathrm{esc, rel}}^2 = 2G(M_p+M_p)/R_c = 4GM_p/R_c$. The problem's assumption is that the characteristic encounter velocity $v_{\\infty}$ is the Hill velocity, $v_H$, which is the orbital speed at the edge of the Hill sphere.\n\nLet's find the scaling of the key quantities with $a$:\n1.  **Mutual Hill Radius ($R_H$):** For two equal-mass planets, $R_H = a \\left(\\frac{2M_p}{3M_*}\\right)^{1/3}$. Since $M_p$ and $M_*$ are constants, $R_H \\propto a$. The encounter area $\\sigma_{\\mathrm{int}} = \\pi R_H^2 \\propto a^2$.\n2.  **Hill Velocity ($v_H$):** The Hill velocity is $v_H = R_H \\Omega$, where $\\Omega = \\sqrt{GM_*/a^3}$ is the Keplerian orbital frequency.\n    $$ v_H^2 = R_H^2 \\Omega^2 = \\left(a \\left(\\frac{2M_p}{3M_*}\\right)^{1/3}\\right)^2 \\left(\\frac{GM_*}{a^3}\\right) = a^2 \\left(\\frac{2M_p}{3M_*}\\right)^{2/3} \\frac{GM_*}{a^3} \\propto \\frac{a^2}{a^3} = a^{-1} $$\n3.  **Escape Velocity ($v_{\\mathrm{esc, rel}}$):** The escape velocity term depends on the planet masses and their physical radii, $v_{\\mathrm{esc, rel}}^2 = 4GM_p/R_c$. These are independent of the orbital semi-major axis $a$, so $v_{\\mathrm{esc, rel}}^2$ is constant.\n4.  **Collision Cross-Section ($\\sigma_{\\mathrm{coll}}$):** The collision radius $R_c=2R_p$ is also constant. Substituting the scalings into the cross-section formula:\n    $$ \\sigma_{\\mathrm{coll}} \\propto R_c^2 \\left(1 + \\frac{v_{\\mathrm{esc, rel}}^2}{v_H^2}\\right) \\propto 1 \\cdot \\left(1 + \\frac{\\text{constant}}{a^{-1}}\\right) \\propto (1 + C \\cdot a) $$\n    where $C$ is a constant.\n\nNow, we combine these to find the scaling of $P_{\\mathrm{coll}}$:\n$$ P_{\\mathrm{coll}} \\propto \\frac{\\sigma_{\\mathrm{coll}}}{\\sigma_{\\mathrm{int}}} \\propto \\frac{1 + C \\cdot a}{a^2} = a^{-2} + C \\cdot a^{-1} $$\nThis function describes how the collision probability changes with $a$.\n-   For **small $a$**, the gravitational focusing term ($C \\cdot a$) is small. The $a^{-2}$ term dominates, so $P_{\\mathrm{coll}} \\propto a^{-2}$. This is the \"geometric\" regime where collisions are determined by the ratio of physical size to Hill sphere size.\n-   For **large $a$**, the gravitational focusing term is large. The $C \\cdot a^{-1}$ term dominates, so $P_{\\mathrm{coll}} \\propto a^{-1}$. This is the \"focusing\" regime where encounters are slow and gravity effectively pulls the planets together.\n\nIn both regimes, the ratio $P_{\\mathrm{coll}}/P_{\\mathrm{ej}} \\propto P_{\\mathrm{coll}}$ is a **decreasing function of $a$**. This means collisions are relatively more likely in inner planetary systems (small $a$), while ejections become relatively more dominant in outer systems (large $a$).\n\nLet's evaluate the options:\n-   **A:** This option correctly derives the scaling as proportional to $(R_c/R_H)^2 (1 + v_{\\mathrm{esc}}^2/v_H^2)$. It correctly identifies the limiting behaviors ($a^{-2}$ and $a^{-1}$) and provides the correct physical interpretation: collisions are more common at small $a$, suppressing ejections, while at large $a$ ejections are more probable relative to the now-rarer collisions.\n-   **B:** Incorrect. The introduction of a fixed physical scale ($R_p$) breaks the scale-invariance of pure gravity in Hill units. The ratio $R_p/R_H$ is not constant.\n-   **C:** Incorrect. It correctly states that focusing strengthens with $a$, but wrongly concludes this makes the overall collision probability increase. The growth of the encounter area ($R_H^2 \\propto a^2$) outpaces the growth of the focused cross-section ($\\sigma_{\\mathrm{coll}} \\propto a$), so the probability decreases.\n-   **D:** Incorrect. The derived scaling is a power law, not exponential. The effects of Keplerian shear are already included in the definition of the Hill sphere and Hill velocity.\n\nTherefore, option A provides the correct formula, scaling, and physical interpretation.\n$$\\boxed{A}$$",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Numerical simulations are an indispensable tool for studying the chaotic and non-linear dynamics of planet-planet scattering. However, the accuracy of these simulations hinges on a robust integration scheme that can handle the extreme changes in velocity and acceleration during close encounters and pericenter passages. This exercise guides you through the design and implementation of an adaptive time-stepping algorithm, a cornerstone of modern N-body codes, to ensure the conservation of energy, a critical measure of numerical fidelity . By developing a scheme based on physical timescales, you will gain practical experience in the computational techniques required to accurately model the evolution of dynamically unstable systems.",
            "id": "4169745",
            "problem": "You are tasked with constructing and assessing an adaptive time-stepping scheme for a planar three-body system consisting of a central star and two planets that mutually interact gravitationally. The scientific goal is to avoid artificial energy drift during close planet–planet encounters and around pericenter passages, a common challenge in studies of planet–planet scattering and dynamical instabilities. Your program must implement an algorithm that evaluates timestep criteria relative to pericenter passage and encounter scales and uses substepping to ensure numerical robustness.\n\nFundamental bases permitted for derivations and algorithm design include Newton’s laws of motion, Newtonian gravity, kinematics, and well-tested orbital element relations for two-body motion under a central potential.\n\nUse the following definitions and constraints:\n\n- Units: length in astronomical units (AU), mass in solar masses, time in years, velocity in AU/year, and angle in radians. The gravitational constant is $G = 4\\pi^2$ in these units.\n- Central star of mass $M_\\star$ is fixed at the origin and does not move. The two planets, with masses $m_1$ and $m_2$, move under the gravitational potential of the star and their mutual gravitational interaction.\n- Let $\\mathbf{r}_i$ and $\\mathbf{v}_i$ denote the position and velocity of planet $i$ relative to the star, with $i \\in \\{1,2\\}$. Pairwise separation and relative speed are $r_{12} = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$ and $v_{\\mathrm{rel}} = \\|\\mathbf{v}_2 - \\mathbf{v}_1\\|$.\n- Use the velocity Verlet scheme for integration. Over a base interval of size $\\Delta t_{\\max}$, design an adaptive substepping scheme as follows:\n  1. For each planet $i$, compute the osculating two-body elements with the star using the instantaneous state $(\\mathbf{r}_i,\\mathbf{v}_i)$, assuming a point-mass potential of the star. The specific orbital energy is $\\varepsilon_i = \\frac{1}{2}\\|\\mathbf{v}_i\\|^2 - \\frac{G M_\\star}{\\|\\mathbf{r}_i\\|}$, the specific angular momentum magnitude is $L_i = \\|\\mathbf{r}_i \\times \\mathbf{v}_i\\|$, the eccentricity is $e_i = \\sqrt{1 + \\frac{2 \\varepsilon_i L_i^2}{(G M_\\star)^2}}$, and the semimajor axis is $a_i = -\\frac{G M_\\star}{2\\varepsilon_i}$ for bound motion where $\\varepsilon_i < 0$. Define the pericenter distance $q_i = a_i(1-e_i)$ and the pericenter speed $v_{\\mathrm{peri},i} = \\sqrt{G M_\\star \\left(\\frac{2}{q_i} - \\frac{1}{a_i}\\right)}$. The pericenter passage timescale is $t_{\\mathrm{peri},i} = \\frac{q_i}{v_{\\mathrm{peri},i}}$. If $\\varepsilon_i \\ge 0$ or $e_i \\ge 1$ (unbound or parabolic/hyperbolic), replace $t_{\\mathrm{peri},i}$ by the local dynamical timescale $t_{\\mathrm{dyn},i} = \\sqrt{\\frac{\\|\\mathbf{r}_i\\|^3}{G M_\\star}}$.\n  2. Define the encounter timescale $t_{\\mathrm{enc}} = \\frac{r_{12}}{\\max(v_{\\mathrm{rel}}, \\delta_v)}$, with a small floor $\\delta_v$ to avoid division by zero.\n  3. Define an acceleration timescale for each planet $t_{\\mathrm{acc},i} = \\frac{\\|\\mathbf{v}_i\\|}{\\|\\mathbf{a}_i\\|}$, where $\\mathbf{a}_i$ is the total acceleration from the star and the other planet.\n  4. The target substep is\n     $$\\Delta t_{\\mathrm{target}} = \\min\\left(\\eta_{\\mathrm{peri}} \\min_i t_{\\mathrm{peri},i},\\ \\eta_{\\mathrm{enc}} t_{\\mathrm{enc}},\\ \\eta_{\\mathrm{acc}} \\min_i t_{\\mathrm{acc},i},\\ \\Delta t_{\\mathrm{step}}\\right),$$\n     where $\\Delta t_{\\mathrm{step}}$ is the current base step size (equal to $\\Delta t_{\\max}$ except possibly for the last partial step) and $\\eta_{\\mathrm{peri}}, \\eta_{\\mathrm{enc}}, \\eta_{\\mathrm{acc}}$ are dimensionless safety factors strictly between $0$ and $1$.\n  5. If $\\Delta t_{\\mathrm{target}} < \\Delta t_{\\mathrm{step}}$, perform $N_{\\mathrm{sub}} = \\left\\lceil \\frac{\\Delta t_{\\mathrm{step}}}{\\Delta t_{\\mathrm{target}}} \\right\\rceil$ substeps of size $\\Delta t_{\\mathrm{sub}} = \\frac{\\Delta t_{\\mathrm{step}}}{N_{\\mathrm{sub}}}$. Otherwise, perform a single step of size $\\Delta t_{\\mathrm{step}}$.\n\nThe gravitational acceleration of planet $i$ is\n$$\n\\mathbf{a}_i = -\\frac{G M_\\star}{\\|\\mathbf{r}_i\\|^3}\\mathbf{r}_i + \\sum_{j\\ne i} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}.\n$$\n\nDefine the total energy of the two-planet system as\n$$\nE = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 - \\sum_{i=1}^{2} \\frac{G M_\\star m_i}{\\|\\mathbf{r}_i\\|} - \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|}.\n$$\nCompute the fractional energy drift $\\delta = \\frac{|E(T) - E(0)|}{|E(0)|}$, which is dimensionless.\n\nImplement two integration modes:\n- A constant-timestep mode that uses fixed $\\Delta t_{\\max}$ with no substepping.\n- The adaptive substepping mode described above.\n\nSimulate each test case below twice (constant and adaptive), and for each case output a list $[\\delta_{\\mathrm{const}}, \\delta_{\\mathrm{adapt}}, b]$, where $b$ is a boolean indicating whether the adaptive mode both reduces drift by at least a factor of $10$ relative to constant mode and achieves absolute drift at or below a specified threshold. The results for all cases must be aggregated into a single line printed as a comma-separated list enclosed in square brackets, with each case’s result itself enclosed in square brackets, for example, $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$.\n\nAngle unit requirement: if angles arise, measure them in radians.\n\nExpress any magnetic or physical quantities strictly in the units specified above. All outputs are dimensionless floats or booleans as defined.\n\nTest suite and parameters to cover happy path, encounter-driven adaptivity, and pericenter-driven adaptivity:\n\n- Case A (well-separated, near-circular orbits):\n  - $M_\\star = 1$.\n  - $m_1 = 1\\times 10^{-3}$, $m_2 = 3\\times 10^{-4}$.\n  - Initial positions and velocities: $\\mathbf{r}_1(0) = (1, 0)$, $\\mathbf{v}_1(0) = (0, 2\\pi)$; $\\mathbf{r}_2(0) = (1.8, 0)$, $\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{1.8}}\\right)$.\n  - Total simulated time $T = 5$.\n  - Base step $\\Delta t_{\\max} = 0.01$.\n  - Safety factors $\\eta_{\\mathrm{peri}} = 0.05$, $\\eta_{\\mathrm{enc}} = 0.05$, $\\eta_{\\mathrm{acc}} = 0.2$.\n  - Threshold for boolean decision $= 1\\times 10^{-6}$.\n\n- Case B (close co-orbital separation to trigger encounter refinement):\n  - $M_\\star = 1$.\n  - $m_1 = 1\\times 10^{-3}$, $m_2 = 1\\times 10^{-3}$.\n  - Initial positions and velocities: $\\mathbf{r}_1(0) = (1.00, 0)$, $\\mathbf{v}_1(0) = (0, 2\\pi)$; $\\mathbf{r}_2(0) = (1.05, 0)$, $\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{1.05}}\\right)$.\n  - Total simulated time $T = 0.5$.\n  - Base step $\\Delta t_{\\max} = 0.01$.\n  - Safety factors $\\eta_{\\mathrm{peri}} = 0.05$, $\\eta_{\\mathrm{enc}} = 0.05$, $\\eta_{\\mathrm{acc}} = 0.2$.\n  - Threshold for boolean decision $= 1\\times 10^{-6}$.\n\n- Case C (high-eccentricity pericenter passage refinement):\n  - $M_\\star = 1$.\n  - $m_1 = 3\\times 10^{-6}$, $m_2 = 1\\times 10^{-3}$.\n  - For planet $1$, target osculating values $a_1 = 0.5$, $e_1 = 0.8$ so $q_1 = 0.1$. Initialize at pericenter: $\\mathbf{r}_1(0) = (0.1, 0)$ and $\\mathbf{v}_1(0) = (0, v_{\\mathrm{peri},1})$ where $v_{\\mathrm{peri},1} = \\sqrt{G M_\\star \\left(\\frac{2}{q_1} - \\frac{1}{a_1}\\right)}$.\n  - For planet $2$, initialize far and circular: $\\mathbf{r}_2(0) = (5, 0)$, $\\mathbf{v}_2(0) = \\left(0, \\frac{2\\pi}{\\sqrt{5}}\\right)$.\n  - Total simulated time $T = 1$.\n  - Base step $\\Delta t_{\\max} = 0.01$.\n  - Safety factors $\\eta_{\\mathrm{peri}} = 0.05$, $\\eta_{\\mathrm{enc}} = 0.05$, $\\eta_{\\mathrm{acc}} = 0.2$.\n  - Threshold for boolean decision $= 1\\times 10^{-6}$.\n\nYour program should produce a single line of output containing the results for Case A, Case B, and Case C as a comma-separated list enclosed in square brackets, where each case result is a list $[\\delta_{\\mathrm{const}}, \\delta_{\\mathrm{adapt}}, b]$ with the boolean $b$ as defined above. The booleans should be printed in lower-case form expected by Python (i.e., true or false).",
            "solution": "We begin from Newton’s second law and Newtonian gravitation for point masses. Let the central star of mass $M_\\star$ be fixed at the origin and two planets of masses $m_1$ and $m_2$ move under a combined potential comprising the star–planet and planet–planet interactions. The planar motion is sufficient, so we work in two spatial dimensions.\n\nThe acceleration of planet $i$ is given by\n$$\n\\mathbf{a}_i = -\\frac{G M_\\star}{\\|\\mathbf{r}_i\\|^3}\\mathbf{r}_i + \\sum_{j\\ne i} G m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\|\\mathbf{r}_j - \\mathbf{r}_i\\|^3}.\n$$\nThis follows directly from Newton’s law of universal gravitation and superposition of forces.\n\nWe integrate using the velocity Verlet scheme, which, for a timestep $\\Delta t$, updates from $(\\mathbf{r}_i^n,\\mathbf{v}_i^n)$ to $(\\mathbf{r}_i^{n+1},\\mathbf{v}_i^{n+1})$ via\n$$\n\\mathbf{v}_i^{n+\\frac{1}{2}} = \\mathbf{v}_i^{n} + \\frac{1}{2}\\mathbf{a}_i^n \\Delta t, \\quad\n\\mathbf{r}_i^{n+1} = \\mathbf{r}_i^{n} + \\mathbf{v}_i^{n+\\frac{1}{2}} \\Delta t, \\quad\n\\mathbf{a}_i^{n+1} = \\mathbf{a}_i(\\mathbf{r}_1^{n+1},\\mathbf{r}_2^{n+1}), \\quad\n\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^{n+\\frac{1}{2}} + \\frac{1}{2}\\mathbf{a}_i^{n+1}\\Delta t.\n$$\nThis integrator is second-order accurate and time-reversible with good energy behavior for constant timesteps. However, with close encounters or near-pericenter segments where accelerations and velocities vary rapidly, a fixed timestep can induce significant numerical energy drift.\n\nWe design an adaptive substepping scheme consistent with the problem statement. The core idea is to preserve a nearly constant top-level timestep $\\Delta t_{\\max}$ over the majority of the evolution to avoid large, frequent changes that break the near-symplectic nature of velocity Verlet, but allow refinement when a local timescale demands smaller steps. We therefore compute at the beginning of each base interval $\\Delta t_{\\mathrm{step}}$ the following timescales:\n\n1. Pericenter passage timescale for each planet $i$ relative to the star. We obtain osculating elements from instantaneous positions and velocities treating the star–planet interaction as a two-body problem. This is a widely used physical approximation in celestial mechanics under weak perturbations. The specific energy is $\\varepsilon_i = \\frac{1}{2}\\|\\mathbf{v}_i\\|^2 - \\frac{G M_\\star}{\\|\\mathbf{r}_i\\|}$ and the specific angular momentum magnitude is $L_i = \\|\\mathbf{r}_i \\times \\mathbf{v}_i\\|$. The eccentricity is \n$$\ne_i = \\sqrt{1 + \\frac{2 \\varepsilon_i L_i^2}{(G M_\\star)^2}},\n$$\nand for bound motion ($\\varepsilon_i<0$) the semimajor axis is $a_i = -\\frac{G M_\\star}{2\\varepsilon_i}$. The pericenter distance is $q_i = a_i(1-e_i)$ and pericenter speed $v_{\\mathrm{peri},i} = \\sqrt{G M_\\star \\left(\\frac{2}{q_i} - \\frac{1}{a_i}\\right)}$. The pericenter timescale is $t_{\\mathrm{peri},i} = \\frac{q_i}{v_{\\mathrm{peri},i}}$, which estimates the time to traverse the pericenter region. If the osculating solution is unbound or degenerate ($\\varepsilon_i\\ge 0$ or $e_i\\ge 1$), we fallback to the local dynamical timescale $t_{\\mathrm{dyn},i} = \\sqrt{\\frac{\\|\\mathbf{r}_i\\|^3}{G M_\\star}}$.\n\n2. Planet–planet encounter timescale $t_{\\mathrm{enc}} = \\frac{r_{12}}{v_{\\mathrm{rel}}}$, where $r_{12} = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$ and $v_{\\mathrm{rel}} = \\|\\mathbf{v}_2 - \\mathbf{v}_1\\|$. If $v_{\\mathrm{rel}}$ is extremely small, set $v_{\\mathrm{rel}}$ to a floor $\\delta_v$ to avoid singular behavior; this ensures that refinement is driven only when actual approach is occurring.\n\n3. Acceleration timescale for each planet $t_{\\mathrm{acc},i} = \\frac{\\|\\mathbf{v}_i\\|}{\\|\\mathbf{a}_i\\|}$, which estimates the time for significant velocity change. This timescale is particularly sensitive during pericenter and close encounters where $|\\mathbf{a}_i|$ is large.\n\nWe combine these with safety factors $\\eta_{\\mathrm{peri}}$, $\\eta_{\\mathrm{enc}}$, and $\\eta_{\\mathrm{acc}}$ to set the target substep:\n$$\n\\Delta t_{\\mathrm{target}} = \\min\\left(\\eta_{\\mathrm{peri}} \\min_i t_{\\mathrm{peri},i},\\ \\eta_{\\mathrm{enc}} t_{\\mathrm{enc}},\\ \\eta_{\\mathrm{acc}} \\min_i t_{\\mathrm{acc},i},\\ \\Delta t_{\\mathrm{step}}\\right).\n$$\nIf $\\Delta t_{\\mathrm{target}}$ is smaller than the current base step $\\Delta t_{\\mathrm{step}}$, we use $N_{\\mathrm{sub}} = \\left\\lceil \\Delta t_{\\mathrm{step}} / \\Delta t_{\\mathrm{target}} \\right\\rceil$ substeps with size $\\Delta t_{\\mathrm{sub}} = \\Delta t_{\\mathrm{step}} / N_{\\mathrm{sub}}$. Otherwise, we perform one velocity Verlet update with $\\Delta t_{\\mathrm{step}}$. This substepping preserves a near-constant outer step while achieving local refinement. Compared to arbitrary variable timesteps, substepping within fixed base intervals reduces the potential breaking of time symmetry and mitigates energy drift.\n\nTo measure energy behavior, we compute the total energy\n$$\nE = \\sum_{i=1}^{2} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 - \\sum_{i=1}^{2} \\frac{G M_\\star m_i}{\\|\\mathbf{r}_i\\|} - \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|}\n$$\nat $t=0$ and $t=T$ and report the fractional drift $\\delta = \\frac{|E(T) - E(0)|}{|E(0)|}$. We run both the constant timestep mode and the adaptive substepping mode on each case. The boolean output for each case is $b = \\left(\\delta_{\\mathrm{adapt}} \\le \\mathrm{threshold}\\right) \\wedge \\left(\\delta_{\\mathrm{adapt}} \\le \\delta_{\\mathrm{const}} / 10\\right)$, quantifying both absolute control and relative improvement.\n\nWe now justify the timescales and their role:\n\n- The pericenter timescale $t_{\\mathrm{peri}}$ arises because near pericenter the velocity peaks due to conservation of angular momentum and energy in an inverse-square law potential. Rapid changes in position necessitate smaller timesteps to accurately capture curvature and avoid large integration errors.\n- The encounter timescale $t_{\\mathrm{enc}}$ is the advection time of the separation by the relative speed. Since close encounters cause strong mutual accelerations and sharp deflections, $\\eta_{\\mathrm{enc}} t_{\\mathrm{enc}}$ sets a refinement when $r_{12}$ becomes small or $v_{\\mathrm{rel}}$ is significant.\n- The acceleration timescale $t_{\\mathrm{acc}}$ derives from $v = \\mathrm{d}x/\\mathrm{d}t$ and $\\mathrm{d}v/\\mathrm{d}t = a$. If $|\\mathbf{a}|$ is large, velocities change rapidly, and reducing $\\Delta t$ keeps the local truncation error $O(\\Delta t^3)$ of velocity Verlet bounded.\n\nSafety factors $\\eta$ enforce a margin so that the substep is a conservative fraction of the smallest relevant timescale, reducing oscillations in refinement and ensuring stability.\n\nFor the three test cases:\n\n- Case A provides a happy path with weak mutual perturbations, near-circular motion, and large separations. Energy drift should be intrinsically small, and adaptivity yields comparable or slightly improved performance.\n- Case B tests encounter-driven adaptivity by placing two Jupiter-mass planets at nearly co-orbital radii and aligned azimuths. This promptly induces strong mutual interactions. Without adaptivity, fixed timesteps can accumulate error; adaptivity refines through encounters.\n- Case C tests pericenter-driven adaptivity with a high-eccentricity Earth-mass planet initialized at pericenter and an outer Jupiter-mass planet far away. The pericenter timescale is short, requiring refinement to avoid large energy errors.\n\nThe program implements these principles, computes the required outputs, and prints the aggregate list on a single line as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants in AU, yr, solar masses\nG = 4.0 * np.pi**2  # AU^3 / (yr^2 * M_sun)\n\ndef accel_planets(r, m, Mstar):\n    \"\"\"\n    Compute accelerations on two planets due to the fixed star and mutual gravity.\n    r: array shape (2, 2) of positions [ [x1,y1], [x2,y2] ]\n    m: array shape (2,) masses of planets\n    Mstar: scalar star mass\n    Returns accelerations array shape (2, 2)\n    \"\"\"\n    a = np.zeros_like(r)\n    for i in range(2):\n        ri = r[i]\n        ri_norm = np.linalg.norm(ri)\n        # Star contribution\n        if ri_norm > 0:\n            a[i] += -(G * Mstar / (ri_norm**3)) * ri\n        # Mutual planet-planet contribution\n        j = 1 - i\n        rij = r[j] - ri\n        d = np.linalg.norm(rij)\n        if d > 0:\n            a[i] += G * m[j] * rij / (d**3)\n    return a\n\ndef total_energy(r, v, m, Mstar):\n    \"\"\"\n    Compute total energy (kinetic + potential) of two planets in the fixed star potential and mutual interaction.\n    \"\"\"\n    # Kinetic\n    K = 0.0\n    for i in range(2):\n        K += 0.5 * m[i] * np.dot(v[i], v[i])\n    # Potential with star\n    U_star = 0.0\n    for i in range(2):\n        ri_norm = np.linalg.norm(r[i])\n        if ri_norm > 0:\n            U_star += -G * Mstar * m[i] / ri_norm\n    # Mutual potential\n    rij = r[1] - r[0]\n    d = np.linalg.norm(rij)\n    U_pp = -G * m[0] * m[1] / d if d > 0 else 0.0\n    return K + U_star + U_pp\n\ndef osculating_elements_star(ri, vi, Mstar):\n    \"\"\"\n    Compute osculating semimajor axis a and eccentricity e for a planet relative to the star,\n    treating the motion as a two-body problem with a fixed central mass Mstar.\n    Returns (a, e, bound) where bound is True if epsilon < 0 and e < 1.\n    \"\"\"\n    r = np.linalg.norm(ri)\n    v2 = np.dot(vi, vi)\n    mu = G * Mstar\n    eps = 0.5 * v2 - mu / r  # specific energy\n    # Specific angular momentum magnitude (2D cross product -> z-component)\n    h = abs(ri[0] * vi[1] - ri[1] * vi[0])\n    e_arg = 1.0 + (2.0 * eps * h**2) / (mu**2)\n    # Numerical safety: clamp tiny negatives due to roundoff\n    e_arg = max(e_arg, 0.0)\n    e = np.sqrt(e_arg)\n    bound = (eps < 0.0) and (e < 1.0)\n    if bound:\n        a = -mu / (2.0 * eps)\n    else:\n        a = np.nan\n    return a, e, bound\n\ndef pericenter_timescale(ri, vi, Mstar):\n    \"\"\"\n    Compute pericenter passage timescale t_peri for a planet relative to the star.\n    If unbound, return local dynamical timescale sqrt(r^3 / (G Mstar)).\n    \"\"\"\n    a, e, bound = osculating_elements_star(ri, vi, Mstar)\n    r = np.linalg.norm(ri)\n    mu = G * Mstar\n    if bound:\n        q = a * (1.0 - e)\n        # v_peri = sqrt(mu * (2/q - 1/a))\n        v_peri = np.sqrt(mu * (2.0 / q - 1.0 / a))\n        t_peri = q / v_peri\n        return t_peri\n    else:\n        return np.sqrt(r**3 / mu)\n\ndef encounter_timescale(r1, v1, r2, v2, v_floor=1e-10):\n    \"\"\"\n    Encounter timescale t_enc = r12 / max(v_rel, v_floor)\n    \"\"\"\n    rij = r2 - r1\n    r12 = np.linalg.norm(rij)\n    vrel = np.linalg.norm(v2 - v1)\n    vrel = max(vrel, v_floor)\n    return r12 / vrel\n\ndef acceleration_timescale(vi, ai, a_floor=1e-15):\n    \"\"\"\n    Acceleration timescale t_acc = |v| / max(|a|, a_floor)\n    \"\"\"\n    vnorm = np.linalg.norm(vi)\n    anorm = max(np.linalg.norm(ai), a_floor)\n    return vnorm / anorm\n\ndef integrate_system(m, Mstar, r0, v0, T, dt_max, adapt, etas):\n    \"\"\"\n    Integrate the two-planet system for time T with base step dt_max.\n    If adapt is True, perform substepping according to timescales and safety factors etas=(eta_peri, eta_enc, eta_acc).\n    Returns fractional energy drift delta.\n    \"\"\"\n    r = r0.copy()\n    v = v0.copy()\n    E0 = total_energy(r, v, m, Mstar)\n    # Number of base steps\n    n_steps = int(np.ceil(T / dt_max))\n    t = 0.0\n    for step in range(n_steps):\n        # Handle last partial base step\n        dt_step = dt_max if (t + dt_max) <= T else (T - t)\n        if adapt:\n            # Compute accelerations at start of base step\n            a = accel_planets(r, m, Mstar)\n            # Timescales\n            t_peri1 = pericenter_timescale(r[0], v[0], Mstar)\n            t_peri2 = pericenter_timescale(r[1], v[1], Mstar)\n            t_enc = encounter_timescale(r[0], v[0], r[1], v[1])\n            t_acc1 = acceleration_timescale(v[0], a[0])\n            t_acc2 = acceleration_timescale(v[1], a[1])\n            eta_peri, eta_enc, eta_acc = etas\n            dt_target = min(eta_peri * min(t_peri1, t_peri2),\n                            eta_enc * t_enc,\n                            eta_acc * min(t_acc1, t_acc2),\n                            dt_step)\n            # Substeps\n            Nsub = int(np.ceil(dt_step / dt_target)) if dt_target > 0 else 1\n            dt_sub = dt_step / Nsub\n            # Perform substeps with velocity Verlet\n            for _ in range(Nsub):\n                a = accel_planets(r, m, Mstar)\n                v_half = v + 0.5 * a * dt_sub\n                r = r + v_half * dt_sub\n                a_new = accel_planets(r, m, Mstar)\n                v = v_half + 0.5 * a_new * dt_sub\n        else:\n            # Single velocity Verlet step of size dt_step\n            a = accel_planets(r, m, Mstar)\n            v_half = v + 0.5 * a * dt_step\n            r = r + v_half * dt_step\n            a_new = accel_planets(r, m, Mstar)\n            v = v_half + 0.5 * a_new * dt_step\n        t += dt_step\n    ET = total_energy(r, v, m, Mstar)\n    delta = abs(ET - E0) / abs(E0) if E0 != 0 else float('inf')\n    return float(delta)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    Mstar_A = 1.0\n    m_A = np.array([1e-3, 3e-4], dtype=float)\n    r1_A = np.array([1.0, 0.0], dtype=float)\n    v1_A = np.array([0.0, 2.0*np.pi], dtype=float)\n    r2_A = np.array([1.8, 0.0], dtype=float)\n    v2_A = np.array([0.0, 2.0*np.pi/np.sqrt(1.8)], dtype=float)\n    T_A = 5.0\n    dt_max_A = 0.01\n    etas_A = (0.05, 0.05, 0.2)\n    threshold_A = 1e-6\n\n    # Case B\n    Mstar_B = 1.0\n    m_B = np.array([1e-3, 1e-3], dtype=float)\n    r1_B = np.array([1.00, 0.0], dtype=float)\n    v1_B = np.array([0.0, 2.0*np.pi], dtype=float)\n    r2_B = np.array([1.05, 0.0], dtype=float)\n    v2_B = np.array([0.0, 2.0*np.pi/np.sqrt(1.05)], dtype=float)\n    T_B = 0.5\n    dt_max_B = 0.01\n    etas_B = (0.05, 0.05, 0.2)\n    threshold_B = 1e-6\n\n    # Case C\n    Mstar_C = 1.0\n    m_C = np.array([3e-6, 1e-3], dtype=float)\n    # Planet 1 at pericenter for a=0.5, e=0.8 -> q=0.1\n    q1_C = 0.1\n    a1_C = 0.5\n    vperi1_C = np.sqrt(G * Mstar_C * (2.0/q1_C - 1.0/a1_C))\n    r1_C = np.array([q1_C, 0.0], dtype=float)\n    v1_C = np.array([0.0, vperi1_C], dtype=float)\n    # Planet 2 far, circular at 5 AU\n    r2_C = np.array([5.0, 0.0], dtype=float)\n    v2_C = np.array([0.0, 2.0*np.pi/np.sqrt(5.0)], dtype=float)\n    T_C = 1.0\n    dt_max_C = 0.01\n    etas_C = (0.05, 0.05, 0.2)\n    threshold_C = 1e-6\n\n    test_cases = [\n        # Each case: (Mstar, masses, r_init, v_init, T, dt_max, etas, threshold)\n        (Mstar_A, m_A, np.vstack([r1_A, r2_A]), np.vstack([v1_A, v2_A]), T_A, dt_max_A, etas_A, threshold_A),\n        (Mstar_B, m_B, np.vstack([r1_B, r2_B]), np.vstack([v1_B, v2_B]), T_B, dt_max_B, etas_B, threshold_B),\n        (Mstar_C, m_C, np.vstack([r1_C, r2_C]), np.vstack([v1_C, v2_C]), T_C, dt_max_C, etas_C, threshold_C),\n    ]\n\n    results = []\n    for (Mstar, masses, r_init, v_init, T, dt_max, etas, threshold) in test_cases:\n        # Constant timestep integration\n        delta_const = integrate_system(masses, Mstar, r_init.copy(), v_init.copy(), T, dt_max, adapt=False, etas=etas)\n        # Adaptive substepping integration\n        delta_adapt = integrate_system(masses, Mstar, r_init.copy(), v_init.copy(), T, dt_max, adapt=True, etas=etas)\n        improved = (delta_adapt <= threshold) and (delta_adapt <= (delta_const / 10.0))\n        results.append([delta_const, delta_adapt, improved])\n\n    # Final print statement in the exact required format.\n    # Python prints booleans as True/False; convert to lowercase 'true'/'false' for strict formatting.\n    def elem_to_str(x):\n        if isinstance(x, bool):\n            return 'true' if x else 'false'\n        else:\n            return str(x)\n    out = \"[\" + \",\".join(\"[\" + \",\".join(elem_to_str(e) for e in case) + \"]\" for case in results) + \"]\"\n    print(out)\n\nsolve()\n```"
        }
    ]
}