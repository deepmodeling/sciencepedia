{
    "hands_on_practices": [
        {
            "introduction": "任何大气反演都始于一个正向模型，该模型将温度和成分等物理参数与可观测的光谱联系起来。这项基础练习将指导您从第一性原理（特别是流体静力学平衡和理想气体定律）出发，推导透射光谱的解析表达式。通过推导有效凌星半径 $R(\\lambda)$ 的过程，您将对大气属性如何塑造我们观测到的信号，以及为何简化假设既有用又存在局限性，获得核心理解。",
            "id": "4154218",
            "problem": "在贝叶斯推断框架内对一颗系外行星大气进行透射光谱学建模，其中正向模型将成分和热力学参数映射到随波长变化的凌星半径。考虑一个球对称大气层，该大气层是等温的，并在恒定引力加速度 $g$ 下处于静流体平衡状态。设参考半径 $R_{0}$ 定义在参考压力 $P_{0}$ 处，在该压力下，大气在更低的高度变得不透明。假设理想气体定律成立，其中玻尔兹曼常数为 $k_{B}$，单位粒子平均质量 $\\mu$ 均匀，并且存在一种单一吸收性物质，其体积混合比 $\\xi$ 为常数，吸收截面 $\\sigma_{\\lambda}$ 与温度和压力无关。设恒星半径为 $R_{\\star}$，并假设薄大气层极限 $H \\ll R_{0}$，其中 $H$ 是等温静流体条件下的压力标高。\n\n仅从静流体平衡 $dP/dr = -\\rho g$、理想气体定律 $P = n k_{B} T$ 以及沿撞击参数为 $b$ 的光线穿过临边的弦光学深度积分的定义出发，\n$$\n\\tau_{\\lambda}(b) = \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n\\!\\left(\\sqrt{b^{2}+x^{2}}\\right) \\, dx,\n$$\n推导由掩食面积条件定义的、在 $H/R_{0}$ 的主导阶上有效的、随波长变化的有效凌星半径 $R(\\lambda)$ 的解析表达式\n$$\n\\pi R^{2}(\\lambda) = \\pi R_{0}^{2} + 2 \\pi \\int_{0}^{\\infty} \\left[1 - \\exp\\!\\left(-\\tau_{\\lambda}(R_{0}+z)\\right)\\right] (R_{0}+z) \\, dz.\n$$\n将 $R(\\lambda)$ 的最终闭合形式结果用 $R_{0}$、$P_{0}$、$T$、$\\mu$、$g$、$\\xi$、$\\sigma_{\\lambda}$ 和基本常数表示，并使用参考高度上的大气数密度 $n_{0} = P_{0}/(k_{B} T)$。您可以假设并使用薄临边近似，即在切点附近，对于 $|x| \\ll b$，$b \\approx R_{0}+z$，半径满足 $r \\approx b + x^{2}/(2b)$。该表达式应包括 $H/R_{0}$ 中的所有主导阶项，包括临边积分产生的任何常数。\n\n最后，列举至少四个在大气反演中使用的等温、静流体、单物质弦光学深度近似的有科学依据的局限性，并讨论在哪些情况下，所推导的正向模型会引入有偏的推断。\n\n请仅提供 $R(\\lambda)$ 的单个闭合形式解析表达式作为您的最终答案。最终答案中不要包含任何单位。无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据、适定、客观，并为系外行星大气科学领域的标准推导提供了一个完整且一致的设置。\n\n推导过程分三个主要阶段进行：首先，在给定假设下确定大气数密度分布 $n(r)$；其次，计算弦光学深度 $\\tau_{\\lambda}(b)$；第三，将其代入有效凌星半径 $R(\\lambda)$ 的定义中，并将积分计算到主导阶。\n\n**1. 大气密度分布**\n\n我们从球对称大气在恒定引力加速度 $g$ 下的静流体平衡方程开始：\n$$\n\\frac{dP}{dr} = -\\rho g\n$$\n其中 $P$ 是压力，$r$ 是距离行星中心的径向距离，$\\rho$ 是质量密度。密度通过 $\\rho = n\\mu$ 与数密度 $n$ 和单位粒子平均质量 $\\mu$ 相关。代入此式得到：\n$$\n\\frac{dP}{dr} = -n\\mu g\n$$\n假设大气遵循理想气体定律 $P = n k_B T$，其中 $k_B$ 是玻尔兹曼常数，$T$ 是恒定温度。我们可以将数密度表示为 $n = P/(k_B T)$。将其代入静流体平衡方程，得到：\n$$\n\\frac{dP}{dr} = -\\frac{P}{k_B T}\\mu g\n$$\n这是一个关于 $P(r)$ 的一阶线性常微分方程。我们可以重新整理以分离变量：\n$$\n\\frac{dP}{P} = -\\frac{\\mu g}{k_B T} dr\n$$\n我们将压力标高 $H$ 定义为压力变化 $e$ 倍的特征垂直长度尺度。对于等温大气，它是一个常数：\n$$\nH = \\frac{k_B T}{\\mu g}\n$$\n将 $H$ 代入微分方程，得到：\n$$\n\\frac{dP}{P} = -\\frac{1}{H} dr\n$$\n我们将此方程从参考层面 $(R_0, P_0)$ 积分到任意层面 $(r, P(r))$：\n$$\n\\int_{P_0}^{P(r)} \\frac{dP'}{P'} = \\int_{R_0}^{r} -\\frac{1}{H} dr'\n$$\n$$\n\\ln\\left(\\frac{P(r)}{P_0}\\right) = -\\frac{r-R_0}{H}\n$$\n解出 $P(r)$，我们得到压力分布：\n$$\nP(r) = P_0 \\exp\\left(-\\frac{r-R_0}{H}\\right)\n$$\n由于 $n = P/(k_B T)$ 且 $T$ 是常数，数密度分布遵循相同的指数形式：\n$$\nn(r) = \\frac{P_0}{k_B T} \\exp\\left(-\\frac{r-R_0}{H}\\right) = n_0 \\exp\\left(-\\frac{r-R_0}{H}\\right)\n$$\n其中 $n_0 = P_0/(k_B T)$ 是参考半径 $R_0$ 处的数密度。\n\n**2. 弦光学深度**\n\n沿撞击参数为 $b$ 的光线穿过大气临边的弦光学深度 $\\tau_{\\lambda}(b)$ 由以下积分给出：\n$$\n\\tau_{\\lambda}(b) = \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n(r) \\, dx\n$$\n这里，$x$ 是沿光线的坐标，$x=0$ 处为最近点。径向距离 $r$ 通过 $r = \\sqrt{b^2 + x^2}$ 与 $b$ 和 $x$ 相关。将密度分布代入积分：\n$$\n\\tau_{\\lambda}(b) = \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n_0 \\exp\\left(-\\frac{\\sqrt{b^2 + x^2} - R_0}{H}\\right) \\, dx\n$$\n问题指定在切点附近对径向距离使用薄临边近似，该近似在 $|x| \\ll b$ 时有效：\n$$\nr = \\sqrt{b^2 + x^2} = b\\sqrt{1 + (x/b)^2} \\approx b\\left(1 + \\frac{x^2}{2b^2}\\right) = b + \\frac{x^2}{2b}\n$$\n这个近似是有效的，因为由于标高 $H$ 很小，被积函数中的指数项在远离 $x=0$ 时迅速减小，所以积分的主要贡献来自 $|x|$ 很小的区域。将这个 $r$ 的近似代入：\n$$\n\\tau_{\\lambda}(b) \\approx \\int_{-\\infty}^{+\\infty} \\xi \\, \\sigma_{\\lambda} \\, n_0 \\exp\\left(-\\frac{b + x^2/(2b) - R_0}{H}\\right) \\, dx\n$$\n我们可以将指数中不依赖于 $x$ 的项分离出来：\n$$\n\\tau_{\\lambda}(b) \\approx \\xi \\, \\sigma_{\\lambda} \\, n_0 \\exp\\left(-\\frac{b - R_0}{H}\\right) \\int_{-\\infty}^{+\\infty} \\exp\\left(-\\frac{x^2}{2bH}\\right) \\, dx\n$$\n剩下的积分是标准的高斯积分，形式为 $\\int_{-\\infty}^{+\\infty} \\exp(-ax^2)dx = \\sqrt{\\pi/a}$。在我们的例子中，$a = 1/(2bH)$，所以积分计算结果为 $\\sqrt{2\\pi bH}$。这给出了弦光学深度：\n$$\n\\tau_{\\lambda}(b) \\approx \\xi \\, \\sigma_{\\lambda} \\, n_0 \\sqrt{2\\pi bH} \\exp\\left(-\\frac{b - R_0}{H}\\right)\n$$\n\n**3. 有效凌星半径**\n\n有效凌星半径 $R(\\lambda)$ 由总掩食面积定义：\n$$\n\\pi R^{2}(\\lambda) = \\pi R_{0}^{2} + 2 \\pi \\int_{0}^{\\infty} \\left[1 - \\exp(-\\tau_{\\lambda}(R_{0}+z))\\right] (R_{0}+z) \\, dz\n$$\n这里，积分变量是参考不透明层面 $R_0$ 以上的高度 $z$，撞击参数为 $b = R_0 + z$。我们首先代入 $b=R_0+z$ 的 $\\tau_{\\lambda}(b)$ 表达式：\n$$\n\\tau_{\\lambda}(R_0+z) \\approx \\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi (R_0+z)H} \\exp\\left(-\\frac{(R_0+z)-R_0}{H}\\right) = \\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi (R_0+z)H} \\exp\\left(-\\frac{z}{H}\\right)\n$$\n在薄大气层极限 ($H \\ll R_0$) 下，被积函数仅在 $z/R_0$ 值较小时才显著。因此，我们可以做主导阶近似，即在随 $z$ 缓慢变化的项中，$(R_0+z) \\approx R_0$。这适用于积分中的因子 $(R_0+z)$ 和光学深度表达式中的 $\\sqrt{R_0+z}$ 项。由此可得：\n$$\n\\pi (R^2(\\lambda) - R_0^2) \\approx 2\\pi R_0 \\int_{0}^{\\infty} \\left[1 - \\exp\\left(-\\left(\\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi R_0 H}\\right) \\exp(-z/H)\\right)\\right] dz\n$$\n我们将参考高度 $z=0$（掠过 $R_0$）处的光学深度定义为 $\\tau_0(\\lambda)$：\n$$\n\\tau_0(\\lambda) = \\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi R_0 H}\n$$\n积分变为：\n$$\nR^2(\\lambda) - R_0^2 \\approx 2R_0 \\int_{0}^{\\infty} \\left[1 - \\exp\\left(-\\tau_0(\\lambda) \\exp(-z/H)\\right)\\right] dz\n$$\n为了求解这个积分，我们进行换元。令 $u = \\tau_0(\\lambda) \\exp(-z/H)$。则 $du = -\\frac{1}{H} \\tau_0(\\lambda) \\exp(-z/H) dz = -\\frac{u}{H} dz$，这意味着 $dz = -\\frac{H}{u} du$。积分限从 $z \\in [0, \\infty)$ 变为 $u \\in [\\tau_0(\\lambda), 0]$。\n$$\n\\int_{0}^{\\infty} \\dots dz = \\int_{\\tau_0(\\lambda)}^{0} [1 - \\exp(-u)] \\left(-\\frac{H}{u}\\right) du = H \\int_{0}^{\\tau_0(\\lambda)} \\frac{1-\\exp(-u)}{u} du\n$$\n这个积分定义了指数积分函数 $\\text{Ein}(x) = \\int_0^x \\frac{1-e^{-t}}{t} dt$。对于大自变量，这是一个合理的假设，因为定义凌星半径的光学深度通常很大，该函数有渐近展开 $\\text{Ein}(x) \\approx \\gamma + \\ln(x)$，其中 $\\gamma \\approx 0.5772$ 是 Euler-Mascheroni 常数。这个常数由积分产生，必须包含在内。\n因此，该积分的计算结果为 $H(\\gamma + \\ln(\\tau_0(\\lambda)))$。\n将其代回 $R^2(\\lambda)$ 的表达式中：\n$$\nR^2(\\lambda) - R_0^2 \\approx 2R_0 H (\\gamma + \\ln(\\tau_0(\\lambda)))\n$$\n$$\nR^2(\\lambda) \\approx R_0^2 \\left[1 + \\frac{2H}{R_0}(\\gamma + \\ln(\\tau_0(\\lambda)))\\right]\n$$\n取平方根并使用一阶二项式近似 $(1+x)^{1/2} \\approx 1 + x/2$（对于小的 $x = \\frac{2H}{R_0}(\\dots)$），这在薄大气层极限 $H \\ll R_0$ 下是有效的：\n$$\nR(\\lambda) \\approx R_0 \\left[1 + \\frac{1}{2} \\frac{2H}{R_0}(\\gamma + \\ln(\\tau_0(\\lambda)))\\right] = R_0 + H(\\gamma + \\ln(\\tau_0(\\lambda)))\n$$\n最后，我们代入 $H$、$n_0$ 和 $\\tau_0(\\lambda)$ 的表达式，得到 $R(\\lambda)$ 的最终闭合形式结果：\n$$\nR(\\lambda) = R_0 + H \\left(\\gamma + \\ln\\left(\\xi \\sigma_{\\lambda} n_0 \\sqrt{2\\pi R_0 H}\\right)\\right)\n$$\n$$\nR(\\lambda) = R_0 + \\frac{k_B T}{\\mu g} \\left(\\gamma + \\ln\\left(\\xi \\sigma_{\\lambda} \\frac{P_0}{k_B T} \\sqrt{2\\pi R_0 \\frac{k_B T}{\\mu g}}\\right)\\right)\n$$\n该表达式用指定的物理参数和基本常数给出了随波长变化的有效凌星半径。\n\n**模型的局限性**\n\n推导出的正向模型虽然在解析上很方便，但依赖于几个强有力的简化。在真实的行星大气中，若不满足这些假设，可能会在从观测数据中反演的参数中引入显著的偏差。四个突出的局限性是：\n\n1.  **等温假设：** 真实的行星大气表现出随高度变化的温度-压力剖面，这是由辐射加热/冷却和动力学过程引起的。等温模型为整个大气层指定一个单一温度 $T$，导致标高 $H$ 为常数。实际上，$H$ 是高度的函数，$H(r)$。例如，具有逆温的平流层会使大气在高海拔处的膨胀程度超过等温模型的预测。用等温模型拟合来自这种大气的数据将导致有偏的反演结果，可能高估吸收物丰度或错误地表征参考压力水平。\n\n2.  **恒定体积混合比 ($\\xi$)：** 该模型假设吸收性物质在整个大气中是均匀混合的。实际上，由于光化学（例如，高海拔处的恒星紫外辐射导致分子解离）、凝结（例如，在冷阱处形成水冰云）和扩散分离（较轻的物质在大气顶部富集）等过程，混合比会随高度变化。对具有垂直变化成分的大气使用恒定$\\xi$模型，将导致反演出的丰度是一个复杂的高度加权平均值，可能不代表任何特定的大气层，从而使我们对行星大气化学的理解产生偏差。\n\n3.  **与压力和温度无关的截面 ($\\sigma_{\\lambda}$):** 分子的吸收截面不是恒定的；它取决于当地的温度和压力。这些效应会使谱线展宽，改变其形状。压力（或碰撞）展宽在较低、较稠密的大气区域占主导地位，而热（多普勒）展宽在较高、较热、较稀薄的区域更为显著。通过忽略谱线展宽，该模型错误地表示了光谱特征的形状。这可能导致反演的温度剖面和丰度出现显著误差，因为该模型无法正确解释强吸收线翼部所包含的信息。\n\n4.  **忽略云和霾：** 该模型仅考虑了气体吸收。真实的系外行星大气经常含有气溶胶，例如云（凝结物）或光化学霾。这些粒子提供了一个重要的不透明度来源，其通常是波长的平滑函数，并且可以掩盖某一高度以下的气体吸收特征。在存在气溶胶时忽略它们，会迫使反演模型错误地解释减弱的光谱特征，通常导致严重低估气体丰度，以及反演出的温度剖面被错误地变得平坦（更接近等温）。这是大气反演中一个众所周知的简并性问题。",
            "answer": "$$\\boxed{R_0 + \\frac{k_B T}{\\mu g} \\left(\\gamma + \\ln\\left(\\xi \\sigma_{\\lambda} \\frac{P_0}{k_B T} \\sqrt{2\\pi R_0 \\frac{k_B T}{\\mu g}}\\right)\\right)}$$"
        },
        {
            "introduction": "贝叶斯推断的一个关键优势是它能够量化地比较相互竞争的科学假设，例如系外行星大气中是否含有云。本练习从理论转向对反演输出的实际解读，您将使用贝叶斯证据（即边缘似然 $Z$）来计算贝叶斯因子 $K$。您将学习如何评估一个模型相对于另一个模型的证据强度，并探究先验假设对结论的关键影响。",
            "id": "4154220",
            "problem": "在一个系外行星反演背景下，您正在比较两种相互竞争的大气云模型，分别表示为 $M_A$ 和 $M_B$。在贝叶斯模型比较中，核心量是边缘似然（也称为贝叶斯证据）$Z_A$ 和 $Z_B$，它们是似然函数在 $M_A$ 和 $M_B$ 的参数空间上由先验加权的积分。嵌套采样提供了这些证据的对数 $\\ln Z_A$ 和 $\\ln Z_B$ 的数值估计。模型间的贝叶斯因子 $K$ 通过证据之比定义，并在与先验模型概率结合时决定后验比。您的任务是，从第一性原理出发，确定如何以数值稳定的方式从 $\\ln Z_A$ 和 $\\ln Z_B$ 计算贝叶斯因子 $K$，并使用一个校准标度来评估证据强度。您还必须通过检查对先验进行小的、科学上合理的改变是否会导致证据强度分类的变化来评估先验敏感性。\n\n使用的起点和定义：\n- 贝叶斯定理和模型 $M$ 的边缘似然定义：$Z = \\int L(d \\mid \\theta, M)\\,\\pi(\\theta \\mid M)\\,\\mathrm{d}\\theta$，其中 $L$ 是数据 $d$ 的似然，$\\pi$ 是模型 $M$ 下参数 $\\theta$ 的先验。\n- $M_A$ 和 $M_B$ 之间的贝叶斯因子 $K$ 是边缘似然 $Z_A$ 和 $Z_B$ 的比率。您必须推导出如何从 $\\ln Z_A$ 和 $\\ln Z_B$ 计算 $K$，而不会在 $\\ln Z$ 值量级很大时造成数值精度损失以及中间过程的上溢或下溢。\n\n证据强度校准：\n- 使用普遍采用的基于 $2 \\ln K$ 的 Kass 和 Raftery 校准标度，对支持 $M_A$ 反对 $M_B$ 的证据强度进行分类。将 $2 \\ln K$ 的区间映射到整数代码 $S$ 如下：\n    - 如果 $2 \\ln K  2$，则 $S = 0$ (勉强一提)。\n    - 如果 $2 \\ln K \\in [2, 6)$，则 $S = 1$ (正面)。\n    - 如果 $2 \\ln K \\in [6, 10)$，则 $S = 2$ (强)。\n    - 如果 $2 \\ln K \\ge 10$，则 $S = 3$ (非常强)。\n\n先验敏感性评估：\n- 对于每个测试用例，都提供了在修改后的先验（例如，先验宽度略微加宽或收紧，但仍是科学上合理的）下计算的第二组 $\\ln Z_A'$ 和 $\\ln Z_B'$。确定当从 $(\\ln Z_A', \\ln Z_B')$ 而不是 $(\\ln Z_A, \\ln Z_B)$ 计算时，分类代码 $S$ 是否发生变化。定义一个布尔标志 $\\text{sensitive}$，如果 $S$ 发生变化，则为 $\\text{True}$，否则为 $\\text{False}$。\n\n测试套件：\n对于每个测试用例，输入为 $(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B')$，其中带撇号的值表示在修改后的先验下的值。使用以下测试用例：\n1. $(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (120.0, 116.0, 119.5, 116.2)$\n2. $(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (10.0, 9.0, 9.9, 9.0)$\n3. $(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (50.0, 50.0, 50.0, 50.0)$\n4. $(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (210.0, 207.0, 208.5, 206.1)$\n\n要求：\n- 推导并实现从 $\\ln Z_A$ 和 $\\ln Z_B$ 数值稳定地计算 $K$ 的方法。\n- 计算基准先验 $(\\ln Z_A, \\ln Z_B)$ 下的 $2 \\ln K$ 和相应的分类代码 $S$。\n- 计算修改后先验 $(\\ln Z_A', \\ln Z_B')$ 的分类代码 $S'$，如果 $S' \\ne S$，则将布尔标志 $\\text{sensitive}$ 设置为 $\\text{True}$，否则为 $\\text{False}$。\n- 您的程序必须处理所有测试用例，并生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是一个内部列表，格式为 $[K, S, \\text{sensitive}]$。例如，整体输出应类似于 $[[K_1,S_1,\\text{sensitive}_1],[K_2,S_2,\\text{sensitive}_2],\\ldots]$。\n- 所有计算都是无量纲的；此问题中不适用任何物理单位。",
            "solution": "我们从贝叶斯定理和模型 $M$ 的边缘似然（贝叶斯证据）的定义开始，\n$$\nZ = \\int L(d \\mid \\theta, M)\\,\\pi(\\theta \\mid M)\\,\\mathrm{d}\\theta,\n$$\n其中 $L$ 是在参数 $\\theta$ 和模型 $M$ 给定下数据 $d$ 的似然，$\\pi$ 是 $M$ 下 $\\theta$ 的先验分布。在 $M_A$ 和 $M_B$ 之间的贝叶斯模型比较中，贝叶斯因子 $K$ 定义为\n$$\nK = \\frac{Z_A}{Z_B}。\n$$\n嵌套采样产生证据对数值的估计，即 $\\ln Z_A$ 和 $\\ln Z_B$。为了以数值稳定的方式计算 $K$，我们利用在对数空间中工作可以避免上溢或下溢的事实。取 $K$ 的自然对数，\n$$\n\\ln K = \\ln Z_A - \\ln Z_B。\n$$\n对这个差值取指数，可以直接得到 $K$，而无需单独计算 $Z_A$ 或 $Z_B$：\n$$\nK = \\exp(\\ln Z_A - \\ln Z_B)。\n$$\n这种方法是数值稳定的，因为它避免了分别对大的 $\\ln Z$ 值取指数后再相除，那可能导致上溢或下溢；相反，它对差值 $\\ln Z_A - \\ln Z_B$ 取指数，在比较实际模型时，这个差值的量级通常是适中的。\n\n为了评估证据强度，我们使用基于 $2 \\ln K$ 的 Kass 和 Raftery 校准标度。我们通过以下方式定义分类代码 $S$：\n- 如果 $2 \\ln K  2$，则 $S = 0$ (勉强一提)。\n- 如果 $2 \\ln K \\in [2, 6)$，则 $S = 1$ (正面)。\n- 如果 $2 \\ln K \\in [6, 10)$，则 $S = 2$ (强)。\n- 如果 $2 \\ln K \\ge 10$，则 $S = 3$ (非常强)。\n\n先验敏感性是通过比较在基准先验 $(\\ln Z_A, \\ln Z_B)$ 和修改后先验 $(\\ln Z_A', \\ln Z_B')$ 下的分类来评估的。具体来说，我们计算\n$$\n\\ln K = \\ln Z_A - \\ln Z_B, \\quad 2 \\ln K = 2(\\ln Z_A - \\ln Z_B),\n$$\n并从校准标度中获得 $S$。同样地，我们计算\n$$\n\\ln K' = \\ln Z_A' - \\ln Z_B', \\quad 2 \\ln K' = 2(\\ln Z_A' - \\ln Z_B'),\n$$\n并从同一标度获得 $S'$。然后将先验敏感性标志设置为\n$$\n\\text{sensitive} = (S' \\ne S)。\n$$\n\n现在我们将此程序应用于测试套件：\n\n测试用例 $1$：$(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (120.0, 116.0, 119.5, 116.2)$。\n- 基准：$\\ln K = 120.0 - 116.0 = 4.0$，因此 $K = \\exp(4.0) \\approx 54.5981500331$，且 $2 \\ln K = 2 \\times 4.0 = 8.0$。分类为 $S = 2$ (强)。\n- 修改后：$\\ln K' = 119.5 - 116.2 = 3.3$，因此 $2 \\ln K' = 6.6$，分类为 $S' = 2$ (强)。\n- 敏感性：$\\text{sensitive} = \\text{False}$ 因为 $S' = S$。\n\n测试用例 $2$：$(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (10.0, 9.0, 9.9, 9.0)$。\n- 基准：$\\ln K = 10.0 - 9.0 = 1.0$, $K = \\exp(1.0) \\approx 2.7182818285$, $2 \\ln K = 2.0$。分类为 $S = 1$ (正面)。\n- 修改后：$\\ln K' = 9.9 - 9.0 = 0.9$, $2 \\ln K' = 1.8$。分类为 $S' = 0$ (勉强一提)。\n- 敏感性：$\\text{sensitive} = \\text{True}$ 因为 $S' \\ne S$。\n\n测试用例 $3$：$(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (50.0, 50.0, 50.0, 50.0)$。\n- 基准：$\\ln K = 50.0 - 50.0 = 0.0$, $K = \\exp(0.0) = 1.0$, $2 \\ln K = 0.0$。分类为 $S = 0$ (勉强一提)。\n- 修改后：$\\ln K' = 0.0$, $2 \\ln K' = 0.0$, $S' = 0$ (勉强一提)。\n- 敏感性：$\\text{sensitive} = \\text{False}$。\n\n测试用例 $4$：$(\\ln Z_A, \\ln Z_B, \\ln Z_A', \\ln Z_B') = (210.0, 207.0, 208.5, 206.1)$。\n- 基准：$\\ln K = 210.0 - 207.0 = 3.0$, $K = \\exp(3.0) \\approx 20.0855369232$, $2 \\ln K = 6.0$。分类为 $S = 2$ (强)。\n- 修改后：$\\ln K' = 208.5 - 206.1 = 2.4$, $2 \\ln K' = 4.8$。分类为 $S' = 1$ (正面)。\n- 敏感性：$\\text{sensitive} = \\text{True}$。\n\n算法设计：\n- 对于每个测试用例，计算 $\\Delta = \\ln Z_A - \\ln Z_B$ 并设置 $K = \\exp(\\Delta)$。\n- 计算 $T = 2 \\Delta$ 并根据上述区间对 $S$ 进行分类。\n- 使用带撇号的值重复此过程以获得 $S'$，并将布尔标志设置为 $S' \\ne S$ 是否成立。\n- 将输出聚合为一个内部列表 $[K, S, \\text{sensitive}]$ 的列表，并在单行上打印整个列表。\n\n此过程将核心的贝叶斯原理与数值稳定的计算和对证据强度的校准解释相结合，并通过分类变化提供了一个具体的先验敏感性指标。",
            "answer": "```python\nimport numpy as np\n\ndef classify_strength(two_ln_K: float) -> int:\n    \"\"\"\n    Map 2 ln K to Kass-Raftery strength codes:\n    0: bare mention (2)\n    1: positive [2,6)\n    2: strong [6,10)\n    3: very strong (>=10)\n    \"\"\"\n    if two_ln_K  2.0:\n        return 0\n    elif two_ln_K  6.0:\n        return 1\n    elif two_ln_K  10.0:\n        return 2\n    else:\n        return 3\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each tuple: (lnZ_A, lnZ_B, lnZ_A_mod, lnZ_B_mod)\n    test_cases = [\n        (120.0, 116.0, 119.5, 116.2),\n        (10.0, 9.0, 9.9, 9.0),\n        (50.0, 50.0, 50.0, 50.0),\n        (210.0, 207.0, 208.5, 206.1),\n    ]\n\n    results_strs = []\n    for lnZ_A, lnZ_B, lnZ_A_mod, lnZ_B_mod in test_cases:\n        # Numerically stable Bayes factor: K = exp(lnZ_A - lnZ_B)\n        delta = lnZ_A - lnZ_B\n        K = float(np.exp(delta))\n        two_ln_K = 2.0 * delta\n        S = classify_strength(two_ln_K)\n\n        # Modified priors\n        delta_mod = lnZ_A_mod - lnZ_B_mod\n        two_ln_K_mod = 2.0 * delta_mod\n        S_mod = classify_strength(two_ln_K_mod)\n\n        sensitive = (S_mod != S)\n\n        # Format inner result as [K,S,sensitive]\n        # Use default float formatting and boolean string conversion\n        results_strs.append(f\"[{K},{S},{sensitive}]\")\n\n    # Final print statement in the exact required format: a single line\n    print(f\"[{','.join(results_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了分析现有数据，贝叶斯推断还是一个用于规划未来观测以最大化科学回报的强大工具。这项高级练习通过计算预期信息增益（EIG）来介绍贝叶斯实验设计的概念。通过为不同的潜在仪器配置评估EIG，您将学习如何量化地确定哪种观测策略能最好地约束我们感兴趣的参数，例如云特性和分子丰度。",
            "id": "4154230",
            "problem": "您的任务是为系外行星透射光谱学中的仪器模式设计一个基于贝斯叶斯推断大气反演的算法推荐器。考虑一个等温、静水平衡的大气，其中谱带平均凌星深度是根据比尔-朗伯吸收定律和路径几何在名义状态附近的线性化来建模的。反演参数是云顶压力和分子混合比。具体来说，定义参数向量为 $$\\boldsymbol{\\theta} \\in \\mathbb{R}^3,$$，其分量为 $$\\boldsymbol{\\theta} = [\\log_{10} P_c,\\ \\log_{10} X_{\\mathrm{H_2O}},\\ \\log_{10} X_{\\mathrm{CH_4}}],$$ 均为无单位量。仪器模式 $$m$$ 的测量模型是正演模型的线性高斯近似：$$\\mathbf{y}_m = \\mathbf{A}_m \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}_m,$$，其中 $$\\mathbf{A}_m$$ 是由辐射传输在名义反演点周围的一阶泰勒展开导出的灵敏度矩阵，而 $$\\boldsymbol{\\varepsilon}_m \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$$ 是协方差为 $$\\boldsymbol{\\Sigma}_{\\mathrm{n},m}$$ 的零均值高斯测量噪声。假设高斯先验为 $$\\boldsymbol{\\theta} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}_{\\mathrm{p}})$$。\n\n从 Bayes 定理和微分熵的定义出发，计算每种仪器模式的期望信息增益 (EIG)，即在线性高斯假设下，观测到 $$\\mathbf{y}_m$$ 后 $$\\boldsymbol{\\theta}$$ 熵的期望减少量。使用自然对数，以便 EIG 以奈特 (nats) 为单位表示。然后为每个测试用例推荐具有最大 EIG 的模式。\n\n您的程序必须以数值稳定的方式实现计算，尽可能避免显式矩阵求逆。请使用 Cholesky 分解和线性求解。最终程序必须输出一行，其中包含所有测试用例的所有结果，结果以逗号分隔，并用方括号括起来，具体格式如下。\n\n测试套件：\n\n测试用例 $$1$$ (理想情况，具有对角噪声的多个通道)：\n- 先验均值 $$\\boldsymbol{\\mu}_1 = [-2.0,\\ -4.0,\\ -5.0]$$。\n- 先验协方差 $$\\boldsymbol{\\Sigma}_{\\mathrm{p},1} = \\begin{bmatrix} 0.30  0.08  0.02 \\\\ 0.08  0.50  0.10 \\\\ 0.02  0.10  0.40 \\end{bmatrix}.$$\n- 模式 $$0$$：\n  - $$\\mathbf{A}_{0} = \\begin{bmatrix} -0.8  1.2  0.1 \\\\ -0.5  0.9  0.5 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([400,\\ 625]).$$\n- 模式 $$1$$：\n  - $$\\mathbf{A}_{1} = \\begin{bmatrix} -0.7  1.0  0.2 \\\\ -0.6  0.4  1.1 \\\\ -0.2  0.7  0.3 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([225,\\ 225,\\ 225]).$$\n- 模式 $$2$$：\n  - $$\\mathbf{A}_{2} = \\begin{bmatrix} -0.9  1.1  0.3 \\\\ -0.4  0.8  0.6 \\\\ -0.3  0.5  0.4 \\\\ -0.1  0.2  0.1 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},2} = \\operatorname{diag}([625,\\ 625,\\ 625,\\ 625]).$$\n\n测试用例 $$2$$ (边界情况，具有极高噪声的模式)：\n- 先验均值 $$\\boldsymbol{\\mu}_2 = [-1.5,\\ -3.8,\\ -5.2]$$。\n- 先验协方差 $$\\boldsymbol{\\Sigma}_{\\mathrm{p},2} = \\begin{bmatrix} 1.0  0.2  0.0 \\\\ 0.2  1.2  0.1 \\\\ 0.0  0.1  0.8 \\end{bmatrix}.$$\n- 模式 $$0$$ (极高噪声)：\n  - $$\\mathbf{A}_{0} = \\begin{bmatrix} -0.5  0.9  0.4 \\\\ -0.4  0.7  0.3 \\\\ -0.3  0.6  0.2 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([10000,\\ 10000,\\ 10000]).$$\n- 模式 $$1$$ (更高精度，更少通道)：\n  - $$\\mathbf{A}_{1} = \\begin{bmatrix} -0.6  1.1  0.0 \\\\ -0.2  0.4  1.2 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([100,\\ 144]).$$\n\n测试用例 $$3$$ (跨通道相关噪声)：\n- 先验均值 $$\\boldsymbol{\\mu}_3 = [-2.2,\\ -4.1,\\ -5.1]$$。\n- 先验协方差 $$\\boldsymbol{\\Sigma}_{\\mathrm{p},3} = \\begin{bmatrix} 0.4  0.05  0.05 \\\\ 0.05  0.6  0.0 \\\\ 0.05  0.0  0.5 \\end{bmatrix}.$$\n- 模式 $$0$$：\n  - $$\\mathbf{A}_{0} = \\begin{bmatrix} -0.6  0.8  0.6 \\\\ -0.1  0.2  1.0 \\\\ -0.4  0.7  0.1 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\begin{bmatrix} 400  120  150 \\\\ 120  900  75 \\\\ 150  75  625 \\end{bmatrix}.$$\n- 模式 $$1$$：\n  - $$\\mathbf{A}_{1} = \\begin{bmatrix} -0.8  0.9  0.3 \\\\ -0.3  0.5  0.9 \\\\ -0.2  0.4  0.2 \\end{bmatrix}.$$\n  - $$\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\begin{bmatrix} 225  75  0 \\\\ 75  400  0 \\\\ 0  0  225 \\end{bmatrix}.$$\n\n您的任务：\n- 对于每个测试用例，在线性高斯反演近似下，使用自然 logarithms 计算每个候选仪器模式的 EIG（以奈特为单位）。\n- 推荐该测试用例中 EIG 最大的模式作为最佳模式。\n- 最终输出必须是一行，包含一个用方括号括起来的逗号分隔列表。对于测试用例 $$1$$，列出模式 $$0$$、模式 $$1$$ 和模式 $$2$$ 的 EIG 值，后跟最佳模式的整数索引（使用从 $$0$$ 开始的索引）。对于测试用例 $$2$$，列出模式 $$0$$ 和模式 $$1$$ 的 EIG 值，后跟最佳索引。对于测试用例 $$3$$，列出模式 $$0$$ 和模式 $$1$$ 的 EIG 值，后跟最佳索引。总体输出按顺序连接这些部分，结果为 $$[EIG_{1,0},EIG_{1,1},EIG_{1,2},i_1,EIG_{2,0},EIG_{2,1},i_2,EIG_{3,0},EIG_{3,1},i_3]$$，其中 $$EIG_{t,m}$$ 是测试用例 $$t$$ 和模式 $$m$$ 的 EIG，$$i_t$$ 是测试用例 $$t$$ 的推荐模式索引。\n\n所有 EIG 值都是无单位的，并且必须以奈特 (nats) 表示。不需要进行物理单位转换。不出现角度。不出现百分比。",
            "solution": "所述问题是为系外行星透射光谱学中的仪器模式设计一个推荐器。推荐标准是在大气反演问题的线性高斯近似下，在贝叶斯框架内计算出的期望信息增益 (EIG)。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **参数向量**：$$\\boldsymbol{\\theta} \\in \\mathbb{R}^3$$，表示 $$[\\log_{10} P_c,\\ \\log_{10} X_{\\mathrm{H_2O}},\\ \\log_{10} X_{\\mathrm{CH_4}}]$$。\n- **先验分布**：假设参数服从高斯先验分布，$$\\boldsymbol{\\theta} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}_{\\mathrm{p}})$$。\n- **测量模型（似然）**：对于每个仪器模式 $$m$$，测量向量 $$\\mathbf{y}_m$$ 被建模为参数的线性函数加上加性高斯噪声：$$\\mathbf{y}_m = \\mathbf{A}_m \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}_m$$，其中 $$\\boldsymbol{\\varepsilon}_m \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$$。这将似然定义为 $$p(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y}_m; \\mathbf{A}_m \\boldsymbol{\\theta}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$$。\n- **目标**：计算每个模式的期望信息增益 (EIG)，定义为观测到 $$\\mathbf{y}_m$$ 后 $$\\boldsymbol{\\theta}$$ 熵的期望减少量。结果应以奈特 (nats) 为单位（使用自然对数）。推荐 EIG 最大的模式。\n- **数值约束**：实现时应避免显式矩阵求逆，并使用 Cholesky 分解以保证数值稳定性。\n\n- **测试用例 1**：\n    - $$\\boldsymbol{\\mu}_1 = [-2.0,\\ -4.0,\\ -5.0]$$。\n    - $$\\boldsymbol{\\Sigma}_{\\mathrm{p},1} = \\begin{bmatrix} 0.30  0.08  0.02 \\\\ 0.08  0.50  0.10 \\\\ 0.02  0.10  0.40 \\end{bmatrix}$$。\n    - 模式 $$0$$：$$\\mathbf{A}_{0} = \\begin{bmatrix} -0.8  1.2  0.1 \\\\ -0.5  0.9  0.5 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([400,\\ 625])$$。\n    - 模式 $$1$$：$$\\mathbf{A}_{1} = \\begin{bmatrix} -0.7  1.0  0.2 \\\\ -0.6  0.4  1.1 \\\\ -0.2  0.7  0.3 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([225,\\ 225,\\ 225])$$。\n    - 模式 $$2$$：$$\\mathbf{A}_{2} = \\begin{bmatrix} -0.9  1.1  0.3 \\\\ -0.4  0.8  0.6 \\\\ -0.3  0.5  0.4 \\\\ -0.1  0.2  0.1 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},2} = \\operatorname{diag}([625,\\ 625,\\ 625,\\ 625])$$。\n\n- **测试用例 2**：\n    - $$\\boldsymbol{\\mu}_2 = [-1.5,\\ -3.8,\\ -5.2]$$。\n    - $$\\boldsymbol{\\Sigma}_{\\mathrm{p},2} = \\begin{bmatrix} 1.0  0.2  0.0 \\\\ 0.2  1.2  0.1 \\\\ 0.0  0.1  0.8 \\end{bmatrix}$$。\n    - 模式 $$0$$：$$\\mathbf{A}_{0} = \\begin{bmatrix} -0.5  0.9  0.4 \\\\ -0.4  0.7  0.3 \\\\ -0.3  0.6  0.2 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\operatorname{diag}([10000,\\ 10000,\\ 10000])$$。\n    - 模式 $$1$$：$$\\mathbf{A}_{1} = \\begin{bmatrix} -0.6  1.1  0.0 \\\\ -0.2  0.4  1.2 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\operatorname{diag}([100,\\ 144])$$。\n\n- **测试用例 3**：\n    - $$\\boldsymbol{\\mu}_3 = [-2.2,\\ -4.1,\\ -5.1]$$。\n    - $$\\boldsymbol{\\Sigma}_{\\mathrm{p},3} = \\begin{bmatrix} 0.4  0.05  0.05 \\\\ 0.05  0.6  0.0 \\\\ 0.05  0.0  0.5 \\end{bmatrix}$$。\n    - 模式 $$0$$：$$\\mathbf{A}_{0} = \\begin{bmatrix} -0.6  0.8  0.6 \\\\ -0.1  0.2  1.0 \\\\ -0.4  0.7  0.1 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},0} = \\begin{bmatrix} 400  120  150 \\\\ 120  900  75 \\\\ 150  75  625 \\end{bmatrix}$$。\n    - 模式 $$1$$：$$\\mathbf{A}_{1} = \\begin{bmatrix} -0.8  0.9  0.3 \\\\ -0.3  0.5  0.9 \\\\ -0.2  0.4  0.2 \\end{bmatrix}$$，$$\\boldsymbol{\\Sigma}_{\\mathrm{n},1} = \\begin{bmatrix} 225  75  0 \\\\ 75  400  0 \\\\ 0  0  225 \\end{bmatrix}$$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在贝叶斯统计和大气科学领域有坚实的科学基础。使用线性高斯模型是不确定性量化和实验设计中一种标准且有效的近似方法。期望信息增益（互信息）的概念是贝叶斯实验设计的基石。该问题是适定的，所有必要的数学对象（矩阵、向量）都有定义，并且它们的维度对于所需的矩阵运算是一致的。测试用例中提供的数据，包括协方差矩阵，在物理和数学上看起来都是合理的（例如，对称，并且经检查是正定的）。问题是客观的，没有歧义。它要求计算一个特定的、可推导的量。它没有违反任何无效性标准。\n\n**步骤 3：结论与行动**\n\n问题是有效的。将提供完整的解决方案。\n\n### 解法推導\n\n仪器模式 $$m$$ 的期望信息增益 (EIG) 是参数向量 $$\\boldsymbol{\\theta}$$ 和数据向量 $$\\mathbf{y}_m$$ 之间的互信息，记为 $$I(\\boldsymbol{\\theta}; \\mathbf{y}_m)$$。它衡量由于观测而导致的参数熵的期望减少量。一个方便的互信息恒等式是：\n$$\nI(\\boldsymbol{\\theta}; \\mathbf{y}_m) = H(\\mathbf{y}_m) - H(\\mathbf{y}_m | \\boldsymbol{\\theta})\n$$\n其中 $$H(\\cdot)$$ 表示微分熵。我们将计算右侧的每一项。\n\n**1. 条件熵 $$H(\\mathbf{y}_m | \\boldsymbol{\\theta})$$**\n\n给定参数的数据的条件分布由测量模型指定：$$p(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y}_m; \\mathbf{A}_m \\boldsymbol{\\theta}, \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$$。\n协方差为 $$\\boldsymbol{\\Sigma}$$ 的 $$d$$ 维多元高斯分布的微分熵由 $$\\frac{1}{2} \\ln \\det(2 \\pi e \\boldsymbol{\\Sigma})$$ 给出。此表达式仅取决于协方差，而不取决于均值。对于 $$p(\\mathbf{y}_m|\\boldsymbol{\\theta})$$，协方差是 $$\\boldsymbol{\\Sigma}_{\\mathrm{n},m}$$。因此，该条件分布的熵相对于 $$\\boldsymbol{\\theta}$$ 是常数。因此，对 $$p(\\boldsymbol{\\theta})$$ 的期望是平凡的。设 $$d_m$$ 为 $$\\mathbf{y}_m$$ 的维数。\n$$\nH(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\mathbb{E}_{p(\\boldsymbol{\\theta})} \\left[ H(p(\\mathbf{y}_m|\\boldsymbol{\\theta})) \\right] = H(p(\\mathbf{y}_m|\\boldsymbol{\\theta})) = \\frac{d_m}{2} \\ln(2 \\pi e) + \\frac{1}{2} \\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m})\n$$\n\n**2. 边缘熵 $$H(\\mathbf{y}_m)$**\n\n为了找到数据边缘分布 $$p(\\mathbf{y}_m)$$ 的熵，我们必须首先推导出这个分布。它是通过对参数上的联合分布进行积分得到的：$$p(\\mathbf{y}_m) = \\int p(\\mathbf{y}_m | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta}) d\\boldsymbol{\\theta}$$。\n鉴于先验 $$p(\\boldsymbol{\\theta}) = \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}_{\\mathrm{p}})$$ 和似然 $$p(\\mathbf{y}_m | \\boldsymbol{\\theta})$$ 都是高斯分布，边缘分布 $$p(\\mathbf{y}_m)$$ 也是高斯分布。其均值和协方差如下：\n- **均值**：$$\\mathbb{E}[\\mathbf{y}_m] = \\mathbb{E}[\\mathbf{A}_m \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}_m] = \\mathbf{A}_m \\mathbb{E}[\\boldsymbol{\\theta}] + \\mathbb{E}[\\boldsymbol{\\varepsilon}_m] = \\mathbf{A}_m \\boldsymbol{\\mu} + \\mathbf{0} = \\mathbf{A}_m \\boldsymbol{\\mu}$$。\n- **协方差**：使用全协方差定律，并注意到 $$\\boldsymbol{\\theta}$$ 和 $$\\boldsymbol{\\varepsilon}_m$$ 的独立性：\n$$\n\\operatorname{Cov}(\\mathbf{y}_m) = \\mathbb{E}[\\operatorname{Cov}(\\mathbf{y}_m|\\boldsymbol{\\theta})] + \\operatorname{Cov}(\\mathbb{E}[\\mathbf{y}_m|\\boldsymbol{\\theta}]) = \\mathbb{E}[\\boldsymbol{\\Sigma}_{\\mathrm{n},m}] + \\operatorname{Cov}(\\mathbf{A}_m \\boldsymbol{\\theta}) = \\boldsymbol{\\Sigma}_{\\mathrm{n},m} + \\mathbf{A}_m \\operatorname{Cov}(\\boldsymbol{\\theta}) \\mathbf{A}_m^T = \\boldsymbol{\\Sigma}_{\\mathrm{n},m} + \\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T\n$$\n所以，$$p(\\mathbf{y}_m) = \\mathcal{N}(\\mathbf{y}_m; \\mathbf{A}_m \\boldsymbol{\\mu}, \\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m})$$。\n这个边缘分布的熵是：\n$$\nH(\\mathbf{y}_m) = \\frac{d_m}{2} \\ln(2 \\pi e) + \\frac{1}{2} \\ln \\det(\\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m})\n$$\n\n**3. 期望信息增益 (EIG)**\n\n将 $$H(\\mathbf{y}_m)$$ 和 $$H(\\mathbf{y}_m | \\boldsymbol{\\theta})$$ 的表达式代入互信息恒等式，常数项 $$\\frac{d_m}{2} \\ln(2 \\pi e)$$ 被抵消：\n$$\n\\text{EIG}_m = I(\\boldsymbol{\\theta}; \\mathbf{y}_m) = H(\\mathbf{y}_m) - H(\\mathbf{y}_m | \\boldsymbol{\\theta}) = \\frac{1}{2} \\left[ \\ln \\det(\\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m}) - \\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m}) \\right]\n$$\n这是 EIG 的最终公式，按要求以奈特表示。值得注意的是，它与先验均值 $$\\boldsymbol{\\mu}$$ 无关。\n\n### 数值实现\n\n为了按照要求以数值稳定的方式计算 EIG 并避免显式矩阵求逆，我们利用 Cholesky 分解的性质。对于一个对称正定矩阵 $$\\mathbf{S}$$，其 Cholesky 分解为 $$\\mathbf{S} = \\mathbf{L}\\mathbf{L}^T$$，其中 $$\\mathbf{L}$$ 是一个下三角矩阵。$$\\mathbf{S}$$ 的行列式为 $$\\det(\\mathbf{S}) = (\\det(\\mathbf{L}))^2 = (\\prod_i L_{ii})^2$$。因此，对数行列式为：\n$$\n\\ln \\det(\\mathbf{S}) = 2 \\sum_i \\ln(L_{ii})\n$$\n这种方法避免了在乘以许多小数或大数时可能发生的数值下溢或上溢。\n\n计算每个模式 $$m$$ 的 EIG 的算法如下：\n1.  构建边缘数据协方差矩阵 $$\\mathbf{M}_m = \\mathbf{A}_m \\boldsymbol{\\Sigma}_{\\mathrm{p}} \\mathbf{A}_m^T + \\boldsymbol{\\Sigma}_{\\mathrm{n},m}$$。\n2.  计算 $$\\mathbf{M}_m$$ 的 Cholesky 分解 $$\\mathbf{M}_m = \\mathbf{L}_{\\mathbf{M}} \\mathbf{L}_{\\mathbf{M}}^T$$。\n3.  计算噪声协方差矩阵 $$\\boldsymbol{\\Sigma}_{\\mathrm{n},m}$$ 的 Cholesky 分解 $$\\boldsymbol{\\Sigma}_{\\mathrm{n},m} = \\mathbf{L}_{\\mathbf{n}} \\mathbf{L}_{\\mathbf{n}}^T$$。\n4.  计算对数行列式：\n    - $$\\ln \\det(\\mathbf{M}_m) = 2 \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{M}}))$$\n    - $$\\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m}) = 2 \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{n}}))$$\n5.  计算 EIG：\n    $$\n    \\text{EIG}_m = \\frac{1}{2} (\\ln \\det(\\mathbf{M}_m) - \\ln \\det(\\boldsymbol{\\Sigma}_{\\mathrm{n},m})) = \\left( \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{M}})) \\right) - \\left( \\sum_i \\ln(\\text{diag}(\\mathbf{L}_{\\mathbf{n}})) \\right)\n    $$\n此过程应用于每个测试用例中的每个模式。选择具有最大 EIG 的模式作为最佳选择。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the instrument mode recommendation problem by calculating\n    Expected Information Gain (EIG) for each mode in each test case.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"Sigma_p\": np.array([\n                [0.30, 0.08, 0.02],\n                [0.08, 0.50, 0.10],\n                [0.02, 0.10, 0.40]\n            ]),\n            \"modes\": [\n                { # Mode 0\n                    \"A\": np.array([\n                        [-0.8, 1.2, 0.1],\n                        [-0.5, 0.9, 0.5]\n                    ]),\n                    \"Sigma_n\": np.diag([400., 625.])\n                },\n                { # Mode 1\n                    \"A\": np.array([\n                        [-0.7, 1.0, 0.2],\n                        [-0.6, 0.4, 1.1],\n                        [-0.2, 0.7, 0.3]\n                    ]),\n                    \"Sigma_n\": np.diag([225., 225., 225.])\n                },\n                { # Mode 2\n                    \"A\": np.array([\n                        [-0.9, 1.1, 0.3],\n                        [-0.4, 0.8, 0.6],\n                        [-0.3, 0.5, 0.4],\n                        [-0.1, 0.2, 0.1]\n                    ]),\n                    \"Sigma_n\": np.diag([625., 625., 625., 625.])\n                }\n            ]\n        },\n        # Test Case 2\n        {\n            \"Sigma_p\": np.array([\n                [1.0, 0.2, 0.0],\n                [0.2, 1.2, 0.1],\n                [0.0, 0.1, 0.8]\n            ]),\n            \"modes\": [\n                { # Mode 0\n                    \"A\": np.array([\n                        [-0.5, 0.9, 0.4],\n                        [-0.4, 0.7, 0.3],\n                        [-0.3, 0.6, 0.2]\n                    ]),\n                    \"Sigma_n\": np.diag([10000., 10000., 10000.])\n                },\n                { # Mode 1\n                    \"A\": np.array([\n                        [-0.6, 1.1, 0.0],\n                        [-0.2, 0.4, 1.2]\n                    ]),\n                    \"Sigma_n\": np.diag([100., 144.])\n                }\n            ]\n        },\n        # Test Case 3\n        {\n            \"Sigma_p\": np.array([\n                [0.4, 0.05, 0.05],\n                [0.05, 0.6, 0.0],\n                [0.05, 0.0, 0.5]\n            ]),\n            \"modes\": [\n                { # Mode 0\n                    \"A\": np.array([\n                        [-0.6, 0.8, 0.6],\n                        [-0.1, 0.2, 1.0],\n                        [-0.4, 0.7, 0.1]\n                    ]),\n                    \"Sigma_n\": np.array([\n                        [400., 120., 150.],\n                        [120., 900., 75.],\n                        [150., 75., 625.]\n                    ])\n                },\n                { # Mode 1\n                    \"A\": np.array([\n                        [-0.8, 0.9, 0.3],\n                        [-0.3, 0.5, 0.9],\n                        [-0.2, 0.4, 0.2]\n                    ]),\n                    \"Sigma_n\": np.array([\n                        [225., 75., 0.],\n                        [75., 400., 0.],\n                        [0., 0., 225.]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    def calculate_eig(Sigma_p, A_m, Sigma_n_m):\n        \"\"\"\n        Calculates the Expected Information Gain (EIG) for a given mode.\n        \n        Args:\n            Sigma_p (np.ndarray): Prior covariance matrix.\n            A_m (np.ndarray): Sensitivity matrix for the mode.\n            Sigma_n_m (np.ndarray): Noise covariance matrix for the mode.\n            \n        Returns:\n            float: The EIG in nats.\n        \"\"\"\n        # Form the marginal data covariance matrix: M = A * Sigma_p * A.T + Sigma_n\n        M_m = A_m @ Sigma_p @ A_m.T + Sigma_n_m\n        \n        # Calculate log-determinants using Cholesky factorization for stability\n        try:\n            L_M = np.linalg.cholesky(M_m)\n            L_n = np.linalg.cholesky(Sigma_n_m)\n        except np.linalg.LinAlgError:\n            # This case should not be reached with the given valid problem data.\n            return -np.inf\n\n        # log(det(S)) = 2 * sum(log(diag(L))) where S = L*L.T\n        log_det_M = 2 * np.sum(np.log(np.diag(L_M)))\n        log_det_n = 2 * np.sum(np.log(np.diag(L_n)))\n        \n        # EIG = 0.5 * (log_det_M - log_det_n)\n        eig = 0.5 * (log_det_M - log_det_n)\n        \n        return eig\n\n    final_results = []\n    for case in test_cases:\n        Sigma_p = case[\"Sigma_p\"]\n        modes = case[\"modes\"]\n        \n        eigs_for_case = []\n        for mode in modes:\n            A_m = mode[\"A\"]\n            Sigma_n_m = mode[\"Sigma_n\"]\n            eig = calculate_eig(Sigma_p, A_m, Sigma_n_m)\n            eigs_for_case.append(eig)\n            \n        optimal_mode_index = np.argmax(eigs_for_case)\n        \n        final_results.extend(eigs_for_case)\n        final_results.append(optimal_mode_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}