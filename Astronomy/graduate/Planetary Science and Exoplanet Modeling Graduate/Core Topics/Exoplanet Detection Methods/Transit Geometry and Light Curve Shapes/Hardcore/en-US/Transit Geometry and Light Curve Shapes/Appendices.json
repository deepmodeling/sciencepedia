{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any transit light curve model lies in the simple geometry of two overlapping circles. In this first practice, you will build a robust computational model from first principles for a uniformly bright star, which forms the basis for all more complex transit calculations. This exercise emphasizes the importance of correctly partitioning the problem into distinct geometric cases and implementing safeguards for numerical stability, a crucial skill for any computational scientist .",
            "id": "4186773",
            "problem": "You are tasked with deriving from first principles and implementing an efficient, numerically stable algorithm to compute the normalized stellar flux during a planetary transit for arbitrary projected separation values. The algorithm must partition geometry into three cases: no overlap, partial overlap, and full overlap, and must ensure numerical stability near the case boundaries. The star is modeled as a uniformly bright, circular disk of unit radius, and the planet is modeled as a uniformly opaque circular disk with radius given by the planet-to-star radius ratio.\n\nStarting point and definitions (fundamental base):\n- The observed flux from a star with specific intensity $I(\\mu)$ is the surface integral of $I(\\mu)$ over the visible stellar disk. For a uniformly bright star, $I(\\mu) = I_0$ where $I_0$ is a constant, and the normalized flux equals the fraction of the unobscured stellar area.\n- Let the stellar radius be $R_\\star = 1$ (defining the unit length), and the planet-to-star radius ratio be $p = R_p / R_\\star$, where $R_p$ is the planet radius. Let the projected separation between the centers of the star and planet, in units of $R_\\star$, be $z \\ge 0$.\n- The normalized flux $F$ during transit is defined as $F = 1 - A_{\\text{overlap}} / \\pi$, where $A_{\\text{overlap}}$ is the area of intersection of two circles of radii $1$ and $p$ whose centers are separated by distance $z$. This relation follows from the definition of normalized flux for a uniformly bright disk, since the unobscured stellar area is $\\pi$.\n\nTasks:\n1. Derive expressions for the overlap area $A_{\\text{overlap}}$ based on Euclidean geometry by partitioning into three cases, expressed in terms of $z$ and $p$:\n   - No overlap: $z \\ge 1 + p$.\n   - Full overlap (one circle contained within the other): $z \\le |1 - p|$.\n   - Partial overlap: $|1 - p|  z  1 + p$.\n   Your derivation must start from the definition of normalized flux as an area integral and reduce to analytic forms for $A_{\\text{overlap}}$ in each case without introducing untested assumptions.\n2. Design the algorithm to compute $F(z, p)$ by evaluating $A_{\\text{overlap}}$ efficiently for arbitrary $z$ and $p$, ensuring numerical stability near the boundaries $z = 1 + p$ and $z = |1 - p|$. Your algorithm must:\n   - Avoid division by zero.\n   - Clip arguments to inverse trigonometric functions to their domains (e.g., $[-1, 1]$).\n   - Clamp small negative values under square roots to $0$.\n   - Employ tolerance thresholds for boundary decisions to avoid oscillations due to floating-point rounding.\n3. Implement the algorithm in a program that takes no input, computes the fluxes for the test suite below, and prints the results in the required format.\n\nTest suite:\nCompute the normalized flux $F$ for the following $(p, z)$ pairs, where $p$ and $z$ are dimensionless:\n- Case covering no overlap, partial overlap, full overlap, and boundary proximity:\n  - $(p, z) = (\\,$ $0.1$ $\\,,$ $\\,$ $2.0$ $\\,)$\n  - $(p, z) = (\\,$ $0.1$ $\\,,$ $\\,$ $1.1$ $\\,)$\n  - $(p, z) = (\\,$ $0.1$ $\\,,$ $\\,$ $1.099999999999$ $\\,)$\n  - $(p, z) = (\\,$ $0.1$ $\\,,$ $\\,$ $0.9$ $\\,)$\n  - $(p, z) = (\\,$ $0.1$ $\\,,$ $\\,$ $0.900000000001$ $\\,)$\n  - $(p, z) = (\\,$ $0.1$ $\\,,$ $\\,$ $0.899999999999$ $\\,)$\n  - $(p, z) = (\\,$ $1.0$ $\\,,$ $\\,$ $0.0$ $\\,)$\n  - $(p, z) = (\\,$ $1.0$ $\\,,$ $\\,$ $1.9999$ $\\,)$\n  - $(p, z) = (\\,$ $0.0$ $\\,,$ $\\,$ $0.5$ $\\,)$\n  - $(p, z) = (\\,$ $0.5$ $\\,,$ $\\,$ $1.5$ $\\,)$\n\nRequired output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[$$result_1$$,$$result_2$$,$$\\dots$$]$).\n- Each result must be a floating-point number representing the normalized flux $F$ for the corresponding test case, computed using the algorithm described above.\n\nConstraints:\n- Use the circle intersection geometry only; do not use numerical pixelation or Monte Carlo integration.\n- Ensure that the implementation is efficient and numerically stable near $z = 1 + p$ and $z = |1 - p|$.",
            "solution": "The problem is evaluated as scientifically grounded, well-posed, and objective, meeting all criteria for a valid problem statement. It presents a standard problem in exoplanet transit modeling based on fundamental Euclidean geometry.\n\nThe normalized stellar flux $F$ for a uniformly bright star of unit radius ($R_\\star = 1$) is given by the fraction of the visible stellar disk that is not obscured by the transiting planet. The total area of the stellar disk is $A_\\star = \\pi R_\\star^2 = \\pi$. If $A_{\\text{overlap}}$ is the area of the stellar disk hidden by the planet, the normalized flux is $F = (A_\\star - A_{\\text{overlap}}) / A_\\star = 1 - A_{\\text{overlap}} / \\pi$.\n\nOur task is to derive the analytic expression for $A_{\\text{overlap}}$, which is the area of intersection of two circles: the star with radius $r_1 = 1$, and the planet with radius $r_2 = p$. The distance between their centers is $z$.\n\nLet the star's center be at the origin $(0, 0)$ of a Cartesian coordinate system. Let the planet's center be at $(z, 0)$. The equations of the two circles are $x^2 + y^2 = 1^2$ and $(x-z)^2 + y^2 = p^2$.\n\nThe area of intersection of two circles can be calculated as the sum of the areas of two circular segments, one from each circle, that are defined by their common chord.\n\nFirst, we find the $x$-coordinate of the common chord by solving for the intersection points of the two circles:\n$$y^2 = 1 - x^2$$\n$$(x-z)^2 + (1-x^2) = p^2 \\implies x^2 - 2xz + z^2 + 1 - x^2 = p^2$$\n$$1 - 2xz + z^2 = p^2 \\implies x = \\frac{1 + z^2 - p^2}{2z}$$\nThis $x$ value defines the position of the vertical chord common to both circles. This expression is only physically meaningful when the circles intersect partially, and $z > 0$.\n\nThe area of a circular segment of a circle with radius $r$, cut by a chord at a distance $d$ from its center, is given by $A_{\\mathrm{seg}} = r^2 \\arccos(d/r) - d\\sqrt{r^2 - d^2}$.\n\nFor the star (radius $r_1=1$), the distance to the chord is $d_1 = x = \\frac{1 + z^2 - p^2}{2z}$.\nFor the planet (radius $r_2=p$), the distance to the chord is $d_2 = |z-x| = z - x = z - \\frac{1 + z^2 - p^2}{2z} = \\frac{2z^2 - 1 - z^2 + p^2}{2z} = \\frac{p^2 + z^2 - 1}{2z}$.\n\nThe total overlap area is the sum of the two segment areas: $A_{\\text{overlap}} = A_{\\text{seg},1} + A_{\\text{seg},2}$.\n$$A_{\\mathrm{seg},1} = 1^2 \\arccos\\left(\\frac{d_1}{1}\\right) - d_1 \\sqrt{1^2 - d_1^2}$$\n$$A_{\\mathrm{seg},2} = p^2 \\arccos\\left(\\frac{d_2}{p}\\right) - d_2 \\sqrt{p^2 - d_2^2}$$\n\nThe term under the square root can be simplified. The half-length of the chord, $y = \\sqrt{1-d_1^2}$, can be expressed as:\n$$y = \\sqrt{1 - \\left(\\frac{1+z^2-p^2}{2z}\\right)^2} = \\frac{1}{2z}\\sqrt{4z^2 - (1+z^2-p^2)^2}$$\nThe argument of the square root is a difference of squares:\n$$4z^2 - (1+z^2-p^2)^2 = (2z - (1+z^2-p^2))(2z + (1+z^2-p^2))$$\n$$= (2z - 1 - z^2 + p^2)(2z + 1 + z^2 - p^2)$$\n$$= (p^2 - (z-1)^2)((z+1)^2 - p^2)$$\n$$= (p-z+1)(p+z-1)(z-p+1)(z+p+1)$$\nThis term is guaranteed to be non-negative when a non-degenerate triangle with sides $1$, $p$, and $z$ can be formed, which corresponds to the partial overlap case. The term $\\sqrt{p^2-d_2^2}$ simplifies to the same chord half-length $y$.\n\nSubstituting $d_1$ and $d_2$ into the segment area formulas:\n$A_{\\text{overlap}} = \\arccos(d_1) - d_1 y + p^2\\arccos(d_2/p) - d_2 y = \\arccos(d_1) + p^2\\arccos(d_2/p) - (d_1+d_2)y$.\nSince $d_1+d_2 = z$, we have:\n$A_{\\text{overlap}} = \\arccos(d_1) + p^2\\arccos(d_2/p) - z \\cdot y$.\n$A_{\\text{overlap}} = \\arccos\\left(\\frac{1+z^2-p^2}{2z}\\right) + p^2 \\arccos\\left(\\frac{p^2+z^2-1}{2pz}\\right) - \\frac{1}{2}\\sqrt{(-z+p+1)(z+p-1)(z-p+1)(z+p+1)}$.\n\nThis formula is valid for the partial overlap case. We now analyze the three distinct geometric cases as a function of $p$ and $z$.\n\n**1. No Overlap: $z \\ge 1 + p$**\nThe circles do not intersect or are externally tangent. The distance between centers is greater than or equal to the sum of the radii.\n$$A_{\\text{overlap}} = 0$$\nThe normalized flux is $F = 1 - 0/\\pi = 1$.\n\n**2. Full Overlap (Containment): $z \\le |1 - p|$**\nOne circle is entirely contained within the other, or they are internally tangent. The distance between centers is less than or equal to the difference of the radii. The overlap area is the area of the smaller circle.\n- If $p \\le 1$ (planet smaller than or same size as the star), the smaller circle is the planet. The condition is $z \\le 1-p$.\n  $$A_{\\text{overlap}} = \\pi p^2$$\n  The flux is $F = 1 - (\\pi p^2)/\\pi = 1 - p^2$.\n- If $p > 1$ (planet larger than the star), the smaller circle is the star. The condition is $z \\le p-1$.\n  $$A_{\\text{overlap}} = \\pi (1)^2 = \\pi$$\n  The flux is $F = 1 - \\pi/\\pi = 0$.\n\n**3. Partial Overlap: $|1 - p|  z  1 + p$**\nThe circles intersect at two points. The overlap area is given by the formula derived above:\n$$A_{\\text{overlap}} = \\arccos\\left(\\frac{1+z^2-p^2}{2z}\\right) + p^2 \\arccos\\left(\\frac{p^2+z^2-1}{2pz}\\right) - \\frac{1}{2}\\sqrt{(-z+p+1)(z+p-1)(z-p+1)(z+p+1)}$$\nThe flux is $F = 1 - A_{\\text{overlap}}/\\pi$.\n\n**Algorithm Design and Numerical Stability**\nThe algorithm directly implements the three cases. Careful implementation is required to ensure numerical stability at the boundaries between cases ($z = 1+p$ and $z = |1-p|$), where arguments to inverse trigonometric functions approach $\\pm 1$ and arguments to square roots approach $0$.\n\n- **Case Logic**: The algorithm must first check the boundary conditions to select the correct formula:\n  1. If $z \\ge 1 + p$, use the 'No Overlap' formula.\n  2. If $z \\le |1 - p|$, use the 'Full Overlap' formula, branching on whether $p \\le 1$ or $p > 1$.\n  3. Otherwise, use the 'Partial Overlap' formula.\n\n- **Avoiding Division by Zero**:\n  - The partial overlap formula contains $z$ and $p$ in denominators.\n  - If $z=0$, this falls into the full overlap case ($0 \\le |1-p|$ for $p \\ne 1$), so the partial overlap formula is not used.\n  - If $p=0$, the planet has zero radius, so $A_{\\text{overlap}}=0$ and $F=1$. This can be handled as a special case at the beginning of the algorithm.\n\n- **Numerical Precision at Boundaries**:\n  - Near the boundaries, floating-point inaccuracies can cause the arguments to `arccos` to fall slightly outside the valid domain of $[-1, 1]$. To prevent `NaN` results, these arguments must be clamped to the range $[-1, 1]$.\n  - Similarly, the argument of the square root, which is mathematically guaranteed to be non-negative in the partial overlap regime, can become a small negative number due to rounding errors near the boundaries. This argument must be clamped to be non-negative (e.g., `max(0.0, arg)`).\n\nThe full algorithm proceeds as follows:\nInput parameters $p \\ge 0$ and $z \\ge 0$.\n1. Handle the trivial case: if $p=0$, return $F=1$.\n2. Compare $z$ with $1+p$ and $|1-p|$ to determine the geometric case.\n3. Apply the corresponding formula for $A_{\\text{overlap}}$.\n4. For the partial overlap case, apply the numerical clamping safeguards described above before evaluating `arccos` and `sqrt`.\n5. Compute the final normalized flux $F = 1 - A_{\\text{overlap}}/\\pi$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized stellar flux for a set of test cases\n    based on the geometric model of a planetary transit.\n    \"\"\"\n\n    test_cases = [\n        # (p, z) pairs\n        (0.1, 2.0),\n        (0.1, 1.1),\n        (0.1, 1.099999999999),\n        (0.1, 0.9),\n        (0.1, 0.900000000001),\n        (0.1, 0.899999999999),\n        (1.0, 0.0),\n        (1.0, 1.9999),\n        (0.0, 0.5),\n        (0.5, 1.5),\n    ]\n\n    results = []\n    for p, z in test_cases:\n        flux = compute_flux(p, z)\n        results.append(flux)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_flux(p, z):\n    \"\"\"\n    Computes the normalized stellar flux for a planetary transit.\n\n    The star is a uniformly bright disk of unit radius. The planet is a\n    uniformly opaque disk.\n\n    Args:\n        p (float): The planet-to-star radius ratio (Rp / R*).\n        z (float): The projected separation between centers in units of R*.\n\n    Returns:\n        float: The normalized stellar flux F.\n    \"\"\"\n    # Trivial case: zero-radius planet. Flux is always 1.\n    if p == 0.0:\n        return 1.0\n\n    # Ensure z is non-negative, as per definition.\n    z = abs(z)\n\n    # Case 1: No overlap. The circles are separate.\n    # z = 1 + p\n    if z = 1.0 + p:\n        return 1.0\n\n    # Case 2: Full overlap. One circle is contained within the other.\n    # z = |1 - p|\n    if z = abs(1.0 - p):\n        if p = 1.0:\n            # The planet is fully within the star.\n            return 1.0 - p**2\n        else:\n            # The star is fully occulted by the larger planet.\n            return 0.0\n\n    # Case 3: Partial overlap.\n    # |1 - p|  z  1 + p\n    # The division-by-zero for z=0 is avoided by the full overlap case.\n    # The division-by-zero for p=0 is avoided by the initial check.\n    \n    # Arguments for the arccos functions\n    c1_arg = (1.0 + z**2 - p**2) / (2.0 * z)\n    c2_arg = (p**2 + z**2 - 1.0) / (2.0 * p * z)\n\n    # Clamp arguments to the valid domain of arccos: [-1, 1] for stability.\n    c1_arg = np.clip(c1_arg, -1.0, 1.0)\n    c2_arg = np.clip(c2_arg, -1.0, 1.0)\n\n    # Angles of the circular sectors\n    k1 = np.arccos(c1_arg)\n    k0 = np.arccos(c2_arg)\n\n    # The argument of the square root is proportional to the area of the\n    # triangle with sides 1, p, and z. This form is numerically stable.\n    sqrt_arg = (-z + p + 1.0) * (z + p - 1.0) * (z - p + 1.0) * (z + p + 1.0)\n    \n    # Clamp argument to be non-negative for sqrt.\n    sqrt_arg = np.maximum(0.0, sqrt_arg)\n    \n    # Overlap area formula for partial transit\n    A_overlap = k1 + p**2 * k0 - 0.5 * np.sqrt(sqrt_arg)\n    \n    # Normalized flux\n    F = 1.0 - A_overlap / np.pi\n    \n    return F\n\nsolve()\n```"
        },
        {
            "introduction": "Idealized transit models assume we can measure stellar flux instantaneously, but real observations are made over finite exposure times, which averages, or \"smears,\" the true light curve. This practice explores the consequences of this fundamental observational constraint by deriving the systematic timing error it introduces for key transit events. By working through this first-order correction, you will gain a deeper understanding of how instrumental effects are modeled and corrected in high-precision data analysis .",
            "id": "4186706",
            "problem": "Consider a transiting exoplanet observed by a photometric instrument that performs finite-duration integrations. Let the true, instantaneous stellar flux during transit be a differentiable function of time, denoted by $F_{\\mathrm{true}}(t)$. Define a specific contact time $t_{c}$ (for example, first contact) implicitly by the condition $F_{\\mathrm{true}}(t_{c}) = F_{c}$, where $F_{c}$ is a chosen reference flux level associated with that contact from transit geometry (for instance, the level at which the stellar limb is just touched by the planetary disk, as defined by the transit model including limb darkening).\n\nThe instrument reports for each exposure a single timestamp $t_{s}$ equal to the start-of-exposure time, and a measured flux that is the average over the exposure window of duration $\\Delta t$. Thus the measured flux is\n$$\nF_{\\mathrm{obs}}(t_{s}) = \\frac{1}{\\Delta t} \\int_{t_{s}}^{t_{s} + \\Delta t} F_{\\mathrm{true}}(\\tau)\\, d\\tau.\n$$\nThe measured contact time $t_{\\mathrm{meas}}$ is defined operationally as the timestamp $t_{s}$ at which the reported $F_{\\mathrm{obs}}(t_{s})$ first equals the reference level $F_{c}$.\n\nStarting from the above definitions and the transit light-curve geometry near contact, assume that near $t_{c}$ the function $F_{\\mathrm{true}}(t)$ can be approximated to leading order by a linear expansion,\n$$\nF_{\\mathrm{true}}(t) \\approx F_{c} + S\\,(t - t_{c}),\n$$\nwhere $S = \\left.\\frac{d F_{\\mathrm{true}}}{dt}\\right|_{t = t_{c}}$ is finite and nonzero, and higher-order curvature terms are neglected. Using only this local approximation and the finite-exposure averaging definition, derive the first-order correction $\\delta t = t_{\\mathrm{meas}} - t_{c}$ in terms of the cadence $\\Delta t$.\n\nExpress your final answer as a single closed-form analytic expression in seconds. No numerical substitution is required and no rounding is required.",
            "solution": "The problem asks for the first-order correction $\\delta t = t_{\\mathrm{meas}} - t_{c}$ between the measured contact time and the true contact time, given the effects of a finite exposure duration $\\Delta t$. We are provided with the definitions of the observed flux, the true contact time, the measured contact time, and a linear approximation for the true flux near the contact point.\n\nThe observed flux $F_{\\mathrm{obs}}(t_{s})$ is defined as the time-average of the true flux $F_{\\mathrm{true}}(t)$ over an exposure interval of duration $\\Delta t$ starting at time $t_{s}$:\n$$F_{\\mathrm{obs}}(t_{s}) = \\frac{1}{\\Delta t} \\int_{t_{s}}^{t_{s} + \\Delta t} F_{\\mathrm{true}}(\\tau)\\, d\\tau.$$\nNear the true contact time $t_{c}$, the true flux is approximated by a linear function:\n$$F_{\\mathrm{true}}(t) \\approx F_{c} + S\\,(t - t_{c}),$$\nwhere $F_{c} = F_{\\mathrm{true}}(t_{c})$ is the reference flux at the contact time, and $S = \\left.\\frac{d F_{\\mathrm{true}}}{dt}\\right|_{t = t_{c}}$ is the slope of the light curve at that instant, which is assumed to be finite and non-zero.\n\nTo find the observed flux, we substitute the linear approximation of $F_{\\mathrm{true}}(t)$ into the integral definition of $F_{\\mathrm{obs}}(t_{s})$:\n$$F_{\\mathrm{obs}}(t_{s}) \\approx \\frac{1}{\\Delta t} \\int_{t_{s}}^{t_{s} + \\Delta t} \\left[ F_{c} + S\\,(\\tau - t_{c}) \\right] d\\tau.$$\nWe can evaluate this integral by separating the terms:\n$$F_{\\mathrm{obs}}(t_{s}) = \\frac{1}{\\Delta t} \\left( \\int_{t_{s}}^{t_{s} + \\Delta t} F_{c}\\,d\\tau + \\int_{t_{s}}^{t_{s} + \\Delta t} S\\,(\\tau - t_{c})\\,d\\tau \\right).$$\nThe first part of the integral is:\n$$\\int_{t_{s}}^{t_{s} + \\Delta t} F_{c}\\,d\\tau = F_{c} [\\tau]_{t_{s}}^{t_{s} + \\Delta t} = F_{c} ((t_{s} + \\Delta t) - t_{s}) = F_{c} \\Delta t.$$\nThe second part of the integral is:\n$$S \\int_{t_{s}}^{t_{s} + \\Delta t} (\\tau - t_{c})\\,d\\tau = S \\left[ \\frac{\\tau^2}{2} - t_{c}\\tau \\right]_{t_{s}}^{t_{s} + \\Delta t} = S \\left( \\left(\\frac{(t_{s} + \\Delta t)^2}{2} - t_{c}(t_{s} + \\Delta t)\\right) - \\left(\\frac{t_{s}^2}{2} - t_{c}t_{s}\\right) \\right).$$\nExpanding and simplifying the terms:\n$$S \\left( \\frac{t_{s}^2 + 2t_{s}\\Delta t + (\\Delta t)^2 - t_{s}^2}{2} - t_{c}(t_{s} + \\Delta t - t_{s}) \\right) = S \\left( \\frac{2t_{s}\\Delta t + (\\Delta t)^2}{2} - t_{c}\\Delta t \\right)$$\n$$= S \\left( t_{s}\\Delta t + \\frac{(\\Delta t)^2}{2} - t_{c}\\Delta t \\right) = S \\Delta t \\left( (t_{s} - t_{c}) + \\frac{\\Delta t}{2} \\right).$$\nSubstituting these results back into the expression for $F_{\\mathrm{obs}}(t_{s})$:\n$$F_{\\mathrm{obs}}(t_{s}) = \\frac{1}{\\Delta t} \\left( F_{c}\\Delta t + S \\Delta t \\left( (t_{s} - t_{c}) + \\frac{\\Delta t}{2} \\right) \\right) = F_{c} + S \\left( (t_{s} - t_{c}) + \\frac{\\Delta t}{2} \\right).$$\nThis equation relates the measured flux at a start time $t_{s}$ to the parameters of the transit model. A useful check of this result is to recognize that the time-average of a linear function over an interval is equal to the function's value at the midpoint of the interval. Our result is equivalent to $F_{\\mathrm{obs}}(t_s) = F_{\\mathrm{true}}(t_s + \\frac{\\Delta t}{2})$, which confirms the integration.\n\nThe measured contact time $t_{\\mathrm{meas}}$ is defined as the specific start-of-exposure time $t_{s}$ for which the observed flux $F_{\\mathrm{obs}}(t_s)$ equals the reference flux $F_{c}$. We find $t_{\\mathrm{meas}}$ by setting $t_s = t_{\\mathrm{meas}}$ and $F_{\\mathrm{obs}}(t_{\\mathrm{meas}}) = F_{c}$:\n$$F_{c} = F_{c} + S \\left( (t_{\\mathrm{meas}} - t_{c}) + \\frac{\\Delta t}{2} \\right).$$\nSubtracting $F_c$ from both sides yields:\n$$0 = S \\left( (t_{\\mathrm{meas}} - t_{c}) + \\frac{\\Delta t}{2} \\right).$$\nSince the slope $S$ is specified to be non-zero, we can divide both sides by $S$:\n$$0 = (t_{\\mathrm{meas}} - t_{c}) + \\frac{\\Delta t}{2}.$$\nThe problem asks for the correction $\\delta t = t_{\\mathrm{meas}} - t_{c}$. Rearranging the equation to solve for this quantity, we obtain:\n$$\\delta t = t_{\\mathrm{meas}} - t_{c} = -\\frac{\\Delta t}{2}.$$\nThis result shows that, to first order, the measured contact time (timestamped at the start of the exposure) precedes the true contact time by half the exposure duration. This timing offset is a direct consequence of averaging the flux over the exposure interval and is independent of the slope of the light curve, as long as the linear approximation holds.",
            "answer": "$$\\boxed{-\\frac{\\Delta t}{2}}$$"
        },
        {
            "introduction": "Transit light curves are not just geometric shadows; they are rich with information about stellar physics, including the effects of rapid rotation. This advanced exercise simulates a realistic research scenario where you must disentangle the subtle signature of gravity darkening from the dominant effect of limb darkening. By fitting a model to synthetic data and analyzing the parameter covariance, you will learn to quantify statistical degeneracies, a critical step in assessing the true constraining power of observational data .",
            "id": "4186712",
            "problem": "You are to implement, fit, and analyze a physically consistent small-planet transit light curve model that includes both limb darkening and gravity darkening, and then quantify the degeneracy between the gravity darkening amplitude and the limb darkening coefficients by computing parameter correlation coefficients from the covariance matrix of a nonlinear least-squares fit to synthetic data.\n\nBegin from the following fundamental base, definitions, and approximations:\n\n1. The star is a circular disk of unit radius with specific intensity modeled by a quadratic limb darkening law. Let the cosine of the angle between the local surface normal and the line of sight be denoted by $\\mu$, which for a point at projected radial coordinate $r$ satisfies $\\mu = \\sqrt{1 - r^2}$ for $r \\le 1$, and the quadratic limb darkening law be\n$$\nI_{\\mathrm{LD}}(\\mu; u_1, u_2) = 1 - u_1\\,(1-\\mu) - u_2\\,(1-\\mu)^2,\n$$\nwhere $u_1$ and $u_2$ are the limb darkening coefficients.\n\n2. Gravity darkening is approximated as a linear brightness gradient across the stellar disk, aligned with an axis that is rotated by an angle $\\phi$ (in radians) with respect to the sky-projected impact parameter axis. Define the rotated coordinate\n$y' = y\\cos\\phi + x\\sin\\phi$,\nand let the gravity darkening factor be $(1 + A\\,y')$, where $A$ is the gravity darkening amplitude. The full specific intensity is then\n$$\nI(x,y; u_1,u_2,A,\\phi) = I_{\\mathrm{LD}}(\\mu; u_1,u_2)\\,\\bigl(1 + A\\,y'\\bigr).\n$$\nAssume parameters are such that $I(x,y) \\ge 0$ everywhere on the stellar disk.\n\n3. In the small-planet approximation, a planet of radius ratio $k$ transiting along a straight chord at impact parameter $b$ blocks a fraction of the stellar flux proportional to the local specific intensity at the planet center. If the average disk-integrated intensity is $I_{\\mathrm{avg}}(u_1, u_2)$, the observed relative flux at time $t$ is modeled as\n$$\nF(t) = 1 - \\delta(t), \\quad \\delta(t) = \n\\begin{cases}\n\\dfrac{k^2\\, I(x_p(t), y_p(t); u_1,u_2,A,\\phi)}{I_{\\mathrm{avg}}(u_1, u_2)},  \\text{if } r_p(t) \\le 1, \\\\ [6pt]\n0,  \\text{if } r_p(t)  1,\n\\end{cases}\n$$\nwhere $(x_p(t), y_p(t))$ are the projected planet center coordinates and $r_p(t)=\\sqrt{x_p(t)^2+y_p(t)^2}$. For this problem, take the planet trajectory to be linear with $x_p(t) = t$ and $y_p(t) = b$; all quantities are expressed in units of stellar radii, and $t$ is a dimensionless parameter.\n\n4. The disk-averaged intensity for the quadratic limb darkening law has the analytic normalization\n$$\nI_{\\mathrm{avg}}(u_1, u_2) = 1 - \\frac{u_1}{3} - \\frac{u_2}{6}.\n$$\nBecause $y'$ is an odd function over the symmetric stellar disk and $I_{\\mathrm{LD}}$ depends only on $r$, the average of $I_{\\mathrm{LD}}(\\mu)\\,y'$ over the disk is zero. Consequently, $I_{\\mathrm{avg}}$ is independent of $A$.\n\nSynthetic data generation and fitting protocol:\n\n- Generate a uniform grid of $N=800$ samples for $t$ in the interval $[-1.5, 1.5]$.\n- For each test case parameter set $\\{k, b, u_1, u_2, A, \\phi\\}$, compute the noiseless model flux $F(t)$ as above.\n- Add independent Gaussian noise with standard deviation $\\sigma = 1\\times 10^{-4}$ to obtain the synthetic observation vector.\n- Fit the parameters $\\theta = (u_1, u_2, A)$ by nonlinear least squares to the synthetic data, holding $k$, $b$, and $\\phi$ fixed. Use Gaussian weights with the known $\\sigma$ and assume absolute variance is known (that is, treat $\\sigma$ as the true standard deviation).\n- From the resulting parameter covariance matrix $\\mathbf{C}$, compute the Pearson correlation coefficients\n$$\n\\rho_{A,u_1} = \\frac{C_{A,u_1}}{\\sqrt{C_{A,A}\\,C_{u_1,u_1}}}, \\quad\n\\rho_{A,u_2} = \\frac{C_{A,u_2}}{\\sqrt{C_{A,A}\\,C_{u_2,u_2}}}.\n$$\nThese quantify the degeneracy between gravity darkening amplitude $A$ and each limb darkening coefficient $u_1$ and $u_2$.\n\nAngle specification: express angles $\\phi$ in radians. All other quantities are dimensionless.\n\nYour program must implement this protocol and produce the correlation coefficients for each of the following four test cases:\n\n- Case 1 (general well-constrained path): $k = 0.10$, $b = 0.20$, $u_1 = 0.40$, $u_2 = 0.20$, $A = 0.10$, $\\phi = 0.50$.\n- Case 2 (near-grazing transit): $k = 0.05$, $b = 0.80$, $u_1 = 0.50$, $u_2 = 0.10$, $A = 0.15$, $\\phi = 1.00$.\n- Case 3 (central transit with misalignment): $k = 0.12$, $b = 0.00$, $u_1 = 0.30$, $u_2 = 0.25$, $A = 0.05$, $\\phi = 0.30$.\n- Case 4 (no gravity darkening, testing identifiability): $k = 0.08$, $b = 0.60$, $u_1 = 0.45$, $u_2 = 0.15$, $A = 0.00$, $\\phi = 0.70$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list of four lists, each inner list containing the two correlation coefficients $[\\rho_{A,u_1}, \\rho_{A,u_2}]$ for the corresponding test case.\n- Express each correlation coefficient as a decimal rounded to three digits after the decimal point.\n- The exact output should be of the form\n$$\n[\\,[\\rho_{A,u_1}^{(1)},\\rho_{A,u_2}^{(1)}],[\\rho_{A,u_1}^{(2)},\\rho_{A,u_2}^{(2)}],[\\rho_{A,u_1}^{(3)},\\rho_{A,u_2}^{(3)}],[\\rho_{A,u_1}^{(4)},\\rho_{A,u_2}^{(4)}]\\,]\n$$\nwith no additional whitespace or text beyond this single line.\n\nDesign notes for coverage:\n\n- The test suite covers a general case, a boundary condition near grazing ($b$ close to $1$), a central transit where chord symmetry can interact with the gravity gradient, and a case with $A=0$ to assess identifiability and degeneracy when gravity darkening is absent.\n- The answers for each case are two floats per case, forming a list of lists as specified.",
            "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the principles of exoplanet transit modeling, mathematically well-posed, objective, and contains all necessary information to proceed with a unique computational solution. The task is to implement a specific physical model for a transit light curve, generate synthetic data, perform a nonlinear least-squares fit, and analyze the resulting parameter degeneracies via the covariance matrix.\n\n### Principle-Based Solution Design\n\nThe core of the problem is to quantify the statistical degeneracy between model parameters describing two distinct physical effects: limb darkening and gravity darkening. The solution is executed by implementing the specified models and analysis protocol.\n\n#### 1. Transit Light Curve Model\n\nThe model for the observed relative stellar flux $F(t)$ during a transit is constructed based on the provided physical approximations.\n\n**Specific Intensity, $I(x,y)$**: The brightness at any point $(x,y)$ on the projected stellar disk is a product of the limb darkening intensity $I_{\\mathrm{LD}}$ and a gravity darkening factor. The star's radius is normalized to $R_*=1$.\n\n-   **Limb Darkening**: A quadratic limb darkening law is used, which describes the decrease in brightness from the center to the edge (limb) of the star. It is a function of $\\mu = \\sqrt{1-r^2}$, where $r = \\sqrt{x^2+y^2}$ is the projected radial distance from the star's center.\n    $$ I_{\\mathrm{LD}}(\\mu; u_1, u_2) = 1 - u_1(1-\\mu) - u_2(1-\\mu)^2 $$\n    Here, $u_1$ and $u_2$ are the limb darkening coefficients.\n\n-   **Gravity Darkening**: This effect, where a rapidly rotating star is brighter at its poles than its equator, is approximated as a linear brightness gradient across the stellar disk. The gradient's orientation is given by an angle $\\phi$ relative to the transit chord's perpendicular axis.\n    $$ y' = y\\cos\\phi + x\\sin\\phi $$\n    The gravity darkening multiplicative factor is $(1 + A y')$, where $A$ is the amplitude of the effect.\n\n-   **Full Intensity**: The combined specific intensity is:\n    $$ I(x,y; u_1, u_2, A, \\phi) = I_{\\mathrm{LD}}(\\mu; u_1, u_2) \\times (1 + A y') $$\n\n**Flux Model**: In the small-planet approximation, the planet is treated as a point that blocks an amount of light proportional to its area ($\\pi (k R_*)^2 = \\pi k^2$) and the local specific intensity at its center, $(x_p(t), y_p(t))$. The planet's trajectory is a straight line defined by $x_p(t)=t$ and $y_p(t)=b$, where $b$ is the impact parameter.\n\nThe fractional drop in flux, $\\delta(t)$, is the light blocked by the planet normalized by the total flux of the star. The total flux is the disk-averaged specific intensity, $I_{\\mathrm{avg}}$, multiplied by the disk area $\\pi R_*^2 = \\pi$.\n$$ \\delta(t) = \\frac{\\pi k^2 I(x_p(t), y_p(t))}{\\pi I_{\\mathrm{avg}}} = \\frac{k^2 I(x_p(t), y_p(t))}{I_{\\mathrm{avg}}} $$\nThe average intensity, $I_{\\mathrm{avg}}$, for the quadratic limb darkening model is given by the integral of $I(x,y)$ over the unit disk, divided by the area $\\pi$. As stated, the gravity darkening term averages to zero over the disk, so $I_{\\mathrm{avg}}$ only depends on the limb darkening coefficients:\n$$ I_{\\mathrm{avg}}(u_1, u_2) = 1 - \\frac{u_1}{3} - \\frac{u_2}{6} $$\nThe final model for the relative flux at time $t$ is $F(t) = 1 - \\delta(t)$, where $\\delta(t)$ is non-zero only when the planet is on the stellar disk, i.e., when $r_p(t) = \\sqrt{t^2+b^2} \\le 1$.\n\n#### 2. Synthetic Data Generation and Fitting\n\nFor each test case, we follow a defined protocol:\n1.  **Model Evaluation**: A time grid of $N=800$ points is created from $t=-1.5$ to $t=1.5$. The noiseless flux model $F(t)$ is computed at these points using the true parameters $\\{k, b, u_1, u_2, A, \\phi\\}$.\n2.  **Noise Injection**: Synthetic \"observed\" data is created by adding independent Gaussian noise with a standard deviation of $\\sigma = 1 \\times 10^{-4}$ to the noiseless flux values.\n3.  **Nonlinear Least-Squares Fit**: The `scipy.optimize.curve_fit` function is used to fit the model to the synthetic data. This function finds the parameters that minimize the weighted sum of squared residuals ($\\chi^2$).\n    -   The parameters to be fitted are $\\theta = (u_1, u_2, A)$.\n    -   The parameters $k$, $b$, and $\\phi$ are held constant during the fit. This is achieved by creating a model function `model(t, u1, u2, A)` for each case, which internally uses the fixed values of $k$, $b$, and $\\phi$. A factory function is an elegant way to generate these specialized model functions.\n    -   The true parameter values are used as the initial guess for the fit (`p0`).\n    -   Crucially, `curve_fit` is provided with the known noise standard deviation via the `sigma` argument, and `absolute_sigma=True` is set. This ensures the returned covariance matrix is correctly scaled and represents the true parameter uncertainties.\n\n#### 3. Parameter Correlation Analysis\n\nThe primary output of the `curve_fit` routine, besides the best-fit parameters, is the covariance matrix $\\mathbf{C}$. This matrix quantifies the uncertainties in the fitted parameters and the correlations between them. For a parameter vector $\\theta = (u_1, u_2, A)$, the covariance matrix is a $3 \\times 3$ matrix where the diagonal elements $C_{ii}$ are the variances ($\\sigma_i^2$) of the parameters and the off-diagonal elements $C_{ij}$ are the covariances between parameters $i$ and $j$.\n\nThe Pearson correlation coefficient $\\rho_{ij}$, which measures the linear correlation between two parameters, is calculated by normalizing the covariance:\n$$ \\rho_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii} C_{jj}}} $$\nThe problem requires computing the correlations between the gravity darkening amplitude $A$ and each of the limb darkening coefficients, $u_1$ and $u_2$. With our parameter ordering $(u_1, u_2, A)$ corresponding to indices $(0, 1, 2)$, the required correlations are:\n$$ \\rho_{A,u_1} = \\frac{C_{2,0}}{\\sqrt{C_{2,2} C_{0,0}}} \\quad \\text{and} \\quad \\rho_{A,u_2} = \\frac{C_{2,1}}{\\sqrt{C_{2,2} C_{1,1}}} $$\nThese values are calculated from the `pcov` matrix returned by `scipy.optimize.curve_fit`. The final results are rounded to three decimal places and formatted as specified. The analysis is repeated for all four test cases, which probe different transit geometries and physical conditions to explore how these affect parameter degeneracies. For instance, a central transit ($b=0$) is expected to show minimal correlation between the symmetric limb darkening terms and the antisymmetric gravity darkening term, while the case with $A=0$ tests the identifiability of a non-existent signal.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements the full pipeline to model, fit, and analyze transit light curves\n    with limb and gravity darkening, and computes parameter correlations.\n    \"\"\"\n    # Set a random seed for reproducibility of the noise generation.\n    np.random.seed(42)\n\n    # Global parameters for the simulation\n    N_SAMPLES = 800\n    T_SPAN = [-1.5, 1.5]\n    NOISE_STD = 1e-4\n\n    # Test cases: (k, b, u1_true, u2_true, A_true, phi)\n    test_cases = [\n        (0.10, 0.20, 0.40, 0.20, 0.10, 0.50),  # Case 1\n        (0.05, 0.80, 0.50, 0.10, 0.15, 1.00),  # Case 2\n        (0.12, 0.00, 0.30, 0.25, 0.05, 0.30),  # Case 3\n        (0.08, 0.60, 0.45, 0.15, 0.00, 0.70),  # Case 4\n    ]\n\n    t_grid = np.linspace(T_SPAN[0], T_SPAN[1], N_SAMPLES)\n    \n    all_results = []\n\n    for case in test_cases:\n        k_fix, b_fix, u1_true, u2_true, A_true, phi_fix = case\n\n        # A factory function to create a model for `curve_fit` with fixed parameters k, b, phi\n        def create_model_function(k, b, phi):\n            def model(t, u1, u2, A):\n                x_p = t\n                y_p = b\n                r_p_sq = x_p**2 + y_p**2\n                \n                flux = np.ones_like(t, dtype=float)\n                # Mask for time points where the planet is on the stellar disk\n                in_transit_mask = r_p_sq = 1.0\n                \n                if not np.any(in_transit_mask):\n                    return flux\n                \n                # Select only the in-transit data for calculation\n                t_in = t[in_transit_mask]\n                r_p_sq_in = r_p_sq[in_transit_mask]\n                \n                mu = np.sqrt(1.0 - r_p_sq_in)\n                I_ld = 1.0 - u1 * (1.0 - mu) - u2 * (1.0 - mu)**2\n                \n                # In-transit planet coordinates\n                x_p_in = t_in\n                y_p_in = b # scalar a priori\n                \n                # Rotated coordinate for gravity darkening\n                yp_rot = y_p_in * np.cos(phi) + x_p_in * np.sin(phi)\n                \n                I_full = I_ld * (1.0 + A * yp_rot)\n                \n                I_avg = 1.0 - u1 / 3.0 - u2 / 6.0\n                \n                # Flux drop in small-planet approximation\n                delta = k**2 * I_full / I_avg if I_avg != 0 else 0\n                \n                flux[in_transit_mask] = 1.0 - delta\n                return flux\n            \n            return model\n\n        # Create the model function for the current test case\n        model_to_fit = create_model_function(k_fix, b_fix, phi_fix)\n\n        # Generate synthetic observational data\n        true_flux = model_to_fit(t_grid, u1_true, u2_true, A_true)\n        noise = np.random.normal(0, NOISE_STD, size=N_SAMPLES)\n        observed_flux = true_flux + noise\n\n        # Perform nonlinear least-squares fit\n        initial_guess = [u1_true, u2_true, A_true]\n        \n        try:\n            # Provide sigma and set absolute_sigma=True for correctly scaled covariance\n            popt, pcov = curve_fit(\n                model_to_fit,\n                t_grid,\n                observed_flux,\n                p0=initial_guess,\n                sigma=np.full_like(t_grid, NOISE_STD),\n                absolute_sigma=True\n            )\n            \n            # The order of parameters in the fit is (u1, u2, A), indices (0, 1, 2)\n            C_u1_u1 = pcov[0, 0]\n            C_u2_u2 = pcov[1, 1]\n            C_A_A = pcov[2, 2]\n            \n            C_A_u1 = pcov[2, 0] # Covariance between A and u1\n            C_A_u2 = pcov[2, 1] # Covariance between A and u2\n            \n            # Calculate Pearson correlation coefficients\n            rho_A_u1 = 0.0\n            if C_A_A  0 and C_u1_u1  0:\n                rho_A_u1 = C_A_u1 / np.sqrt(C_A_A * C_u1_u1)\n            \n            rho_A_u2 = 0.0\n            if C_A_A  0 and C_u2_u2  0:\n                rho_A_u2 = C_A_u2 / np.sqrt(C_A_A * C_u2_u2)\n\n            case_results = [\"{:.3f}\".format(rho_A_u1), \"{:.3f}\".format(rho_A_u2)]\n        \n        except RuntimeError:\n            # This handles cases where the fit fails to converge, though not expected here\n            case_results = [\"0.000\", \"0.000\"]\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required, with no extra spaces.\n    output_parts = []\n    for res_pair in all_results:\n        output_parts.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    final_string = f\"[{','.join(output_parts)}]\"\n    print(final_string)\n\nsolve()\n```"
        }
    ]
}