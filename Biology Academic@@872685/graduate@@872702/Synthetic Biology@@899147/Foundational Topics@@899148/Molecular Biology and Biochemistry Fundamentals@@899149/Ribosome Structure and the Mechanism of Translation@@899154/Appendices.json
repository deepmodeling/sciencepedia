{"hands_on_practices": [{"introduction": "When designing a synthetic gene, maximizing the overall speed of translation is a common goal. However, ensuring a smooth and consistent rate of ribosome movement along the mRNA is equally crucial for preventing traffic jams and improving protein folding. This exercise challenges you to optimize a gene's codon usage not for maximum speed, but to minimize the *variance* of per-codon elongation times, a key principle in designing robustly expressed proteins [@problem_id:2770668].", "problem": "You are tasked with designing a program that, for a fixed amino acid sequence, selects one synonymous codon at each position to minimize the variability of ribosomal elongation times across the sequence, given a host Transfer Ribonucleic Acid (tRNA) pool and constraints on guanine-cytosine (GC) content. The program must compute the minimal achievable population variance of per-codon elongation times, in seconds squared, under the specified GC-content bounds.\n\nScientific foundation and modeling assumptions:\n- The Central Dogma of molecular biology implies that an amino acid sequence is encoded by a set of synonymous codons with differing kinetic properties.\n- Translation elongation time for a codon is inversely proportional to the effective decoding availability of its cognate tRNA species in the host. For each codon $c$, let the effective availability be $A(c)$ in $\\mathrm{s}^{-1}$. The elongation time is modeled as $t(c) = 1 / A(c)$ in $\\mathrm{s}$.\n- For a sequence of length $N$ codons, choosing codon $c_p$ at position $p \\in \\{1,\\dots,N\\}$ yields elongation times $t_p = t(c_p)$ and population variance\n$$\n\\mathrm{Var} = \\frac{1}{N} \\sum_{p=1}^{N} \\left(t_p - \\bar{t}\\right)^2, \\quad \\text{where } \\bar{t} = \\frac{1}{N} \\sum_{p=1}^{N} t_p.\n$$\n- The GC fraction constraint is applied to the entire coding sequence: if $\\mathrm{GC}(c)$ counts the occurrences of $G$ or $C$ in codon $c$ (an integer in $\\{0,1,2,3\\}$), then the total GC fraction is\n$$\nf_{\\mathrm{GC}} = \\frac{1}{3N} \\sum_{p=1}^{N} \\mathrm{GC}(c_p),\n$$\nand must satisfy $L \\le f_{\\mathrm{GC}} \\le U$, inclusive.\n\nAllowed codon sets and host-effective availabilities:\n- Amino acid Alanine ($\\mathrm{A}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{GCU}$: $9.0$\n  - $\\mathrm{GCC}$: $13.0$\n  - $\\mathrm{GCA}$: $8.0$\n  - $\\mathrm{GCG}$: $11.0$\n- Amino acid Lysine ($\\mathrm{K}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{AAA}$: $12.0$\n  - $\\mathrm{AAG}$: $8.0$\n- Amino acid Threonine ($\\mathrm{T}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{ACU}$: $7.0$\n  - $\\mathrm{ACC}$: $12.0$\n  - $\\mathrm{ACA}$: $6.0$\n  - $\\mathrm{ACG}$: $10.0$\n- Amino acid Glycine ($\\mathrm{G}$): allowed codons and availabilities $A(c)$ in $\\mathrm{s}^{-1}$\n  - $\\mathrm{GGU}$: $8.0$\n  - $\\mathrm{GGC}$: $14.0$\n  - $\\mathrm{GGA}$: $7.0$\n  - $\\mathrm{GGG}$: $12.0$\n\nFundamental base and constraints to use in your derivation and design:\n- Fixed amino acid sequence: the amino acid at position $p$ is given; you must choose one codon from the allowed set for that amino acid.\n- Elongation time per codon: $t(c) = 1/A(c)$, in $\\mathrm{s}$.\n- Objective: minimize the population variance $\\mathrm{Var}$ defined above.\n- Constraint: $L \\le f_{\\mathrm{GC}} \\le U$, where $f_{\\mathrm{GC}}$ is defined above.\n- If no assignment satisfies the GC constraint, report infeasibility by returning $-1.0$.\n\nAngle units are not involved. Physical units are required for times and variances. Express the output variances in $\\mathrm{s}^2$, each rounded to exactly $6$ decimal places.\n\nInput is embedded in the program; no external input is used. Your implementation must compute the minimal variance by exhaustive search over the finite discrete set of synonymous codon assignments that satisfy the GC constraint.\n\nTest suite:\nFor each test case, you are given an amino acid sequence (as a string over the alphabet $\\{\\mathrm{A},\\mathrm{K},\\mathrm{T},\\mathrm{G}\\}$), and GC bounds $[L,U]$.\n\n- Test case $1$:\n  - Amino acid sequence: $\\mathrm{\"AKTAGT\"}$ (length $N=6$).\n  - GC bounds: $L=0.45$, $U=0.60$.\n- Test case $2$:\n  - Amino acid sequence: $\\mathrm{\"KTTKTT\"}$ (length $N=6$).\n  - GC bounds: $L=0.50$, $U=0.50$.\n- Test case $3$:\n  - Amino acid sequence: $\\mathrm{\"ATAGTG\"}$ (length $N=6$).\n  - GC bounds: $L=0.70$, $U=0.75$.\n- Test case $4$:\n  - Amino acid sequence: $\\mathrm{\"AAGAGG\"}$ (length $N=6$).\n  - GC bounds: $L=0.20$, $U=0.30$.\n\nYour program should compute, for each test case, the minimal achievable population variance $\\mathrm{Var}$ in $\\mathrm{s}^2$ among all synonymous-codon assignments satisfying the GC constraint, or $-1.0$ if no feasible assignment exists. Round each result to exactly $6$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4}]$), where each result is a floating-point number formatted to exactly $6$ decimal places.\n\nImplementation notes:\n- Use the definitions above directly; do not introduce any other formulas.\n- The GC-count per codon $\\mathrm{GC}(c)$ is the number of characters in $\\{G,C\\}$ in the codon string $c$.\n- The computational method must be exact over the finite search space for these small test cases.", "solution": "The problem requires the minimization of the population variance of ribosomal elongation times for a given amino acid sequence, subject to a constraint on the overall guanine-cytosine (GC) content. This constitutes a constrained optimization problem over a discrete search space.\n\nLet the amino acid sequence be of length $N$. For each position $p \\in \\{1, \\dots, N\\}$, the amino acid $AA_p$ is specified. Let $C_p$ be the set of synonymous codons that encode $AA_p$. The task is to choose one codon $c_p \\in C_p$ for each position to form a coding sequence $(c_1, c_2, \\dots, c_N)$.\n\nThe objective function to be minimized is the population variance of elongation times, given by:\n$$\n\\mathrm{Var}(t_1, \\dots, t_N) = \\frac{1}{N} \\sum_{p=1}^{N} \\left(t_p - \\bar{t}\\right)^2\n$$\nwhere $t_p = 1/A(c_p)$ is the elongation time for the chosen codon $c_p$, and $\\bar{t} = \\frac{1}{N} \\sum_{p=1}^{N} t_p$ is the mean elongation time. $A(c_p)$ is the given effective availability of the cognate tRNA for codon $c_p$.\n\nThe optimization is subject to a constraint on the total GC fraction of the coding sequence:\n$$\nL \\le f_{\\mathrm{GC}} \\le U\n$$\nwhere $L$ and $U$ are the lower and upper bounds, respectively, and\n$$\nf_{\\mathrm{GC}} = \\frac{1}{3N} \\sum_{p=1}^{N} \\mathrm{GC}(c_p)\n$$\nThe term $\\mathrm{GC}(c_p)$ represents the number of guanine or cytosine bases in codon $c_p$. This constraint can be equivalently expressed in terms of the total GC count, $\\mathrm{GC}_{\\text{total}} = \\sum_{p=1}^{N} \\mathrm{GC}(c_p)$. Since $\\mathrm{GC}_{\\text{total}}$ must be an integer, the constraint becomes:\n$$\n\\lceil 3NL \\rceil \\le \\mathrm{GC}_{\\text{total}} \\le \\lfloor 3NU \\rfloor\n$$\nThis integer-based formulation avoids potential floating-point precision issues.\n\nThe search space is the set of all possible coding sequences, formed by the Cartesian product $C_1 \\times C_2 \\times \\dots \\times C_N$. The size of this space is $\\prod_{p=1}^{N} |C_p|$. For the given problem parameters, the sequence length is small ($N=6$) and the number of synonymous codons for any amino acid is also small ($|C_p| \\in \\{2, 4\\}$). This results in a search space size that is computationally tractable for an exhaustive search, as specified in the problem statement.\n\nThe algorithm proceeds as follows:\n1.  **Data Preparation**: For each amino acid specified in the problem ('A', 'K', 'T', 'G'), we tabulate the corresponding synonymous codons, their elongation times $t(c) = 1/A(c)$, and their GC counts $\\mathrm{GC}(c)$.\n2.  **Generate All Candidates**: An iterative process generates every possible combination of synonymous codons, one for each position in the input amino acid sequence. This is equivalent to exploring every element of the Cartesian product of the sets of synonymous codons.\n3.  **Constraint Filtering**: For each generated candidate codon sequence:\n    a. The total GC count $\\mathrm{GC}_{\\text{total}}$ is computed by summing the GC counts of the individual codons.\n    b. The candidate sequence is considered 'feasible' if and only if its $\\mathrm{GC}_{\\text{total}}$ lies within the pre-calculated integer bounds $[\\lceil 3NL \\rceil, \\lfloor 3NU \\rfloor]$.\n4.  **Optimization**:\n    a. For each feasible candidate sequence, the list of corresponding elongation times $(t_1, \\dots, t_N)$ is assembled.\n    b. The population variance of these times is computed. The formula $\\mathrm{Var} = E[t^2] - (E[t])^2$ is used, where $E[\\cdot]$ denotes the sample mean.\n    c. This variance is compared against the minimum variance found so far among all previously evaluated feasible candidates. The minimum is updated if the current variance is lower.\n5.  **Result Formulation**: After all candidate sequences have been evaluated, if one or more feasible sequences were found, the final result is the minimum variance recorded. If no candidate sequence satisfied the GC constraint, the problem is infeasible, and the result is reported as $-1.0$.\n\nThis exhaustive search guarantees finding the global minimum of the variance under the given constraints, as it evaluates every single valid configuration. The implementation will use Python's `itertools.product` to systematically generate all codon combinations and `numpy.var` for an efficient and accurate calculation of the population variance.", "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the codon optimization problem for a series of test cases.\n    \"\"\"\n\n    # Define codon data: {AA: [(codon, availability, gc_count), ...]}\n    # Elongation time t(c) = 1/A(c) will be calculated from availability.\n    CODON_DATA_RAW = {\n        'A': [('GCU', 9.0), ('GCC', 13.0), ('GCA', 8.0), ('GCG', 11.0)],\n        'K': [('AAA', 12.0), ('AAG', 8.0)],\n        'T': [('ACU', 7.0), ('ACC', 12.0), ('ACA', 6.0), ('ACG', 10.0)],\n        'G': [('GGU', 8.0), ('GGC', 14.0), ('GGA', 7.0), ('GGG', 12.0)],\n    }\n\n    def gc_count(codon_str):\n        return codon_str.count('G') + codon_str.count('C')\n\n    # Pre-process data into a more usable format: {AA: [(time, gc_count), ...]}\n    CODON_DATA = {\n        aa: [(1.0 / avail, gc_count(codon)) for codon, avail in codons]\n        for aa, codons in CODON_DATA_RAW.items()\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"seq\": \"AKTAGT\", \"L\": 0.45, \"U\": 0.60},\n        {\"seq\": \"KTTKTT\", \"L\": 0.50, \"U\": 0.50},\n        {\"seq\": \"ATAGTG\", \"L\": 0.70, \"U\": 0.75},\n        {\"seq\": \"AAGAGG\", \"L\": 0.20, \"U\": 0.30},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        L = case[\"L\"]\n        U = case[\"U\"]\n        \n        N = len(seq)\n        total_bases = 3 * N\n\n        # Calculate integer GC count bounds.\n        # min_gc <= total_gc <= max_gc\n        min_gc_total = np.ceil(total_bases * L)\n        max_gc_total = np.floor(total_bases * U)\n\n        # Get the lists of (time, gc_count) tuples for each AA in the sequence.\n        codon_choices_per_pos = [CODON_DATA[aa] for aa in seq]\n\n        # Generate all possible combinations of codons for the sequence.\n        all_codon_combinations = product(*codon_choices_per_pos)\n\n        min_variance = float('inf')\n        found_feasible = False\n\n        for combo in all_codon_combinations:\n            # combo is a tuple of (time, gc_count) pairs for the whole sequence.\n            \n            # Calculate total GC count for the current combination.\n            total_gc = sum(item[1] for item in combo)\n\n            # Check if the GC content constraint is satisfied.\n            if min_gc_total <= total_gc <= max_gc_total:\n                found_feasible = True\n                \n                # Extract elongation times for the feasible combination.\n                times = [item[0] for item in combo]\n                \n                # Calculate population variance.\n                # numpy.var computes population variance by default (ddof=0).\n                variance = np.var(times)\n\n                # Update the minimum variance found so far.\n                if variance < min_variance:\n                    min_variance = variance\n\n        if found_feasible:\n            results.append(f\"{min_variance:.6f}\")\n        else:\n            results.append(f\"{-1.0:.6f}\")\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2770668"}, {"introduction": "The expression level of a gene is not static; it is dynamically regulated by the cell's physiological state. Cellular stress, for instance, can significantly alter the availability of charged tRNAs, creating bottlenecks for specific codons. In this practice, you will use Michaelis-Menten kinetics to model how stress-induced changes in tRNA charging can reprogram the translational efficiency of genes with different codon biases, a fundamental concept in understanding and engineering cellular responses [@problem_id:2770734].", "problem": "You are modeling how transfer RNA (tRNA) charging dynamics under stress alter ribosome elongation and thereby protein output for genes with different codon compositions. Use the following foundational starting points, which you must explicitly and rigorously deploy to derive your algorithm: (i) the Central Dogma of Molecular Biology states that translation produces protein by ribosomes decoding codons on messenger RNA (mRNA), one amino acid per codon, (ii) each elongation step requires a cognate aminoacyl-tRNA (charged tRNA) delivered as part of a ternary complex, and (iii) ribosome catalysis of peptide bond formation and decoding is a saturable process with respect to the concentration of cognate ternary complex and is well described by Michaelis–Menten kinetics. Assume that the availability of ternary complex for codon class $i$ is proportional to the charged fraction $f_i$ of the corresponding tRNA pool. Treat any overall proportionality constant as canceling in ratios and therefore unnecessary to estimate.\n\nDefinitions for this problem:\n- There are $3$ codon classes indexed by $i \\in \\{1,2,3\\}$. For a given gene, let $n_i$ be the count of codons of class $i$, so that total length is $L = \\sum_{i=1}^{3} n_i$ codons.\n- Baseline charged fractions are $f_i^{(0)} \\in (0,1]$. Under a specified stress, the charged fractions change multiplicatively by stress scalings $s_i > 0$ and are capped at full charging: $f_i^{(s)} = \\min\\{1,\\; f_i^{(0)} \\cdot s_i\\}$. No renormalization across classes is performed.\n- At codon class $i$, the ribosome’s elongation turnover rate is a saturable function of the cognate ternary complex concentration proportional to the charged fraction. Let $k_{\\text{cat}}$ be the maximal turnover rate (in $\\mathrm{s}^{-1}$) and $K_M$ be the Michaelis constant (in arbitrary concentration units normalized so that charged fractions can be used as proportional surrogates); the initiation overhead per translation event is a constant time $t_{\\text{init}}$ (in $\\mathrm{s}$) independent of elongation dynamics.\n- For a gene with counts $\\{n_i\\}$ and charged fractions $\\{f_i\\}$ realized in a condition (baseline or stress), the total elongation time is the sum of per-codon dwell times over all codons, and the protein production rate per mRNA, $R$, is the reciprocal of the sum of initiation time and total elongation time.\n- The metric to report for each test case is the fold-change in protein output between stress and baseline for the specified gene and condition, defined as $\\rho = R^{(s)} / R^{(0)}$, a dimensionless quantity.\n\nYour tasks:\n- Starting only from the principles above, derive an explicit algorithm to compute $\\rho$ for any provided parameter set.\n- Implement this algorithm in a program that evaluates the following test suite. For each test case, compute the fold-change $\\rho$ and round the reported value to $6$ decimal places. There are no physical units in the reported fold-change. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0.923451,1.102300,1.000000,0.750000]\").\n\nConstants and test suite:\n- In all test cases, there are $3$ codon classes with codon counts $(n_1,n_2,n_3)$ as given, baseline charged fractions $(f_1^{(0)},f_2^{(0)},f_3^{(0)})$ as given, and stress scalings $(s_1,s_2,s_3)$ as given. Use $k_{\\text{cat}}$ and $K_M$ as given with initiation time $t_{\\text{init}}$.\n- Test case $1$ (balanced composition, moderate stress shifting charging away from class $3$ and slightly toward class $2$): $(n_1,n_2,n_3) = (100, 100, 100)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.6, 1.05, 0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n- Test case $2$ (gene enriched in the stress-depleted class $3$): $(n_1,n_2,n_3) = (60, 40, 300)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.6, 1.05, 0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n- Test case $3$ (gene enriched in the slightly favored class $2$): $(n_1,n_2,n_3) = (60, 300, 40)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.6, 1.05, 0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n- Test case $4$ (boundary case with zero usage of class $1$, severe depletion of classes $1$ and $3$, and strong increase of class $2$ that must be capped at full charging): $(n_1,n_2,n_3) = (0, 200, 200)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.05, 1.5, 0.05)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.05$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n\nFinal output format:\n- Your program must print exactly one line: a single list literal of the four rounded fold-change values in the order of the test cases, formatted as a comma-separated list enclosed in square brackets.", "solution": "The problem statement is subjected to rigorous validation before any attempt at a solution.\n\n### Step 1: Extract Givens\n\nThe following data, definitions, and conditions are explicitly provided:\n- **Codon Classes**: $3$ classes indexed by $i \\in \\{1,2,3\\}$.\n- **Gene Composition**: For a given gene, $n_i$ is the count of codons of class $i$. Total length is $L = \\sum_{i=1}^{3} n_i$.\n- **Baseline Charged Fractions**: $f_i^{(0)} \\in (0,1]$.\n- **Stress-induced Charged Fractions**: $f_i^{(s)} = \\min\\{1,\\; f_i^{(0)} \\cdot s_i\\}$, where $s_i > 0$ are stress scalings. No renormalization occurs.\n- **Elongation Kinetics**: The ribosome's elongation turnover rate for codon class $i$ is described by Michaelis-Menten kinetics, where the concentration of the cognate ternary complex is proportional to the charged fraction $f_i$.\n- **Kinetic Parameters**: $k_{\\text{cat}}$ is the maximal turnover rate (in $\\mathrm{s}^{-1}$), and $K_M$ is the Michaelis constant.\n- **Initiation Time**: A constant overhead time $t_{\\text{init}}$ (in $\\mathrm{s}$) is required for each translation event.\n- **Total Elongation Time**: The sum of per-codon dwell times over all codons.\n- **Protein Production Rate**: For a gene with codon counts $\\{n_i\\}$ and charged fractions $\\{f_i\\}$, the rate per mRNA, $R$, is the reciprocal of the sum of initiation time and total elongation time.\n- **Metric**: The fold-change in protein output, $\\rho = R^{(s)} / R^{(0)}$, where $R^{(s)}$ and $R^{(0)}$ are the rates under stress and baseline conditions, respectively.\n- **Test Case 1**: $(n_1,n_2,n_3) = (100, 100, 100)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.6, 1.05, 0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n- **Test Case 2**: $(n_1,n_2,n_3) = (60, 40, 300)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.6, 1.05, 0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n- **Test Case 3**: $(n_1,n_2,n_3) = (60, 300, 40)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.6, 1.05, 0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n- **Test Case 4**: $(n_1,n_2,n_3) = (0, 200, 200)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7, 0.8, 0.9)$, $(s_1,s_2,s_3) = (0.05, 1.5, 0.05)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.05$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the specified criteria:\n1.  **Scientifically Grounded**: The problem is founded on the Central Dogma of Molecular Biology and employs the Michaelis-Menten model to describe enzyme kinetics. This is a standard and well-established framework in biophysics and molecular systems biology for modeling translation elongation. The assumptions are scientifically sound and do not violate fundamental principles.\n2.  **Well-Posed**: The problem provides all necessary definitions, constants, and parameters to compute a unique solution. The relationships between variables are explicitly defined. The constraints on parameters ($f_i^{(0)} \\in (0,1]$, $s_i > 0$) prevent mathematical singularities like division by zero.\n3.  **Objective**: The problem is stated in precise, quantitative terms. The objective is to compute a specific, numerically defined metric ($\\rho$) based on a clearly articulated model. It is free from subjective or ambiguous language.\n4.  **Completeness and Consistency**: The setup is both complete and self-consistent. There are no missing parameters for the test cases, nor are there contradictory constraints.\n5.  **Realism**: While a simplification of the true biological complexity, the model is a plausible and frequently used representation of translation dynamics. The parameter values are within realistic biophysical ranges.\n\nThe problem does not exhibit any of the listed flaws. It is a straightforward biophysical modeling task.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be derived and implemented.\n\n### Derivation of the Algorithm\n\nThe objective is to compute the fold-change in protein production rate, $\\rho = R^{(s)} / R^{(0)}$. This requires deriving an expression for the rate $R$ from the given principles.\n\n$1$. The protein production rate, $R$, is defined as the reciprocal of the total time required to synthesize a single polypeptide chain. This total time, $T_{\\text{total}}$, is the sum of a constant initiation time, $t_{\\text{init}}$, and the total elongation time, $T_{\\text{elong}}$.\n$$ R = \\frac{1}{T_{\\text{total}}} = \\frac{1}{t_{\\text{init}} + T_{\\text{elong}}} $$\n\n$2$. The total elongation time, $T_{\\text{elong}}$, is the sum of the individual times required to translate each codon in the mRNA sequence. For a gene with $n_i$ codons of class $i$, this is:\n$$ T_{\\text{elong}} = \\sum_{i=1}^{3} n_i \\cdot \\tau_i $$\nwhere $\\tau_i$ is the average dwell time, or processing time, for a single codon of class $i$.\n\n$3$. The dwell time $\\tau_i$ is the reciprocal of the elongation rate for class $i$, which we denote as $k_i$.\n$$ \\tau_i = \\frac{1}{k_i} $$\nThe problem states that this elongation rate follows Michaelis-Menten kinetics with respect to the concentration of the cognate ternary complex. The concentration of this complex is assumed to be proportional to the charged tRNA fraction, $f_i$. The Michaelis-Menten equation for the rate $k_i$ is:\n$$ k_i = k_{\\text{cat}} \\frac{[S]}{K_M + [S]} $$\nwhere $[S]$ represents the substrate concentration. We substitute $f_i$ for $[S]$, as per the problem's explicit normalization rule.\n$$ k_i = k_{\\text{cat}} \\frac{f_i}{K_M + f_i} $$\nThis rate has units of $\\mathrm{s}^{-1}$, so the dwell time $\\tau_i$ is correctly in units of seconds.\n\n$4$. Substituting the expression for $k_i$ into the equation for $\\tau_i$:\n$$ \\tau_i = \\frac{1}{k_{\\text{cat}} \\frac{f_i}{K_M + f_i}} = \\frac{K_M + f_i}{k_{\\text{cat}} \\cdot f_i} $$\n\n$5$. Now, substitute this expression for $\\tau_i$ back into the formula for the total elongation time, $T_{\\text{elong}}$:\n$$ T_{\\text{elong}}(\\{f_i\\}, \\{n_i\\}) = \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i}{k_{\\text{cat}} \\cdot f_i} \\right) $$\nThe dependence on the sets of charged fractions $\\{f_i\\}$ and codon counts $\\{n_i\\}$ is now explicit.\n\n$6$. The total time to synthesize one protein is therefore:\n$$ T_{\\text{total}}(\\{f_i\\}, \\{n_i\\}) = t_{\\text{init}} + \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i}{k_{\\text{cat}} \\cdot f_i} \\right) $$\n\n$7$. We must compute this total time for two conditions: baseline (0) and stress (s).\n- For the baseline condition, the charged fractions are $\\{f_i^{(0)}\\}$. The total time is:\n$$ T_{\\text{total}}^{(0)} = t_{\\text{init}} + \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i^{(0)}}{k_{\\text{cat}} \\cdot f_i^{(0)}} \\right) $$\n- For the stress condition, the charged fractions $\\{f_i^{(s)}\\}$ are calculated as $f_i^{(s)} = \\min\\{1, f_i^{(0)} \\cdot s_i\\}$. The total time is:\n$$ T_{\\text{total}}^{(s)} = t_{\\text{init}} + \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i^{(s)}}{k_{\\text{cat}} \\cdot f_i^{(s)}} \\right) $$\n\n$8$. The respective protein production rates are $R^{(0)} = 1 / T_{\\text{total}}^{(0)}$ and $R^{(s)} = 1 / T_{\\text{total}}^{(s)}$. The required fold-change, $\\rho$, is the ratio of these rates:\n$$ \\rho = \\frac{R^{(s)}}{R^{(0)}} = \\frac{1 / T_{\\text{total}}^{(s)}}{1 / T_{\\text{total}}^{(0)}} = \\frac{T_{\\text{total}}^{(0)}}{T_{\\text{total}}^{(s)}} $$\n\nThis is the final, explicit formula for the algorithm. The implementation will calculate $T_{\\text{total}}^{(0)}$ and $T_{\\text{total}}^{(s)}$ for each test case and then compute their ratio.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the fold-change in protein output between stress and baseline conditions\n    for a series of test cases based on a Michaelis-Menten model of ribosome elongation.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries for clarity.\n    # Each dictionary contains all parameters for one test case.\n    test_cases = [\n        {\n            \"n\": np.array([100, 100, 100]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.6, 1.05, 0.4]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.2,\n            \"t_init\": 0.5\n        },\n        {\n            \"n\": np.array([60, 40, 300]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.6, 1.05, 0.4]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.2,\n            \"t_init\": 0.5\n        },\n        {\n            \"n\": np.array([60, 300, 40]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.6, 1.05, 0.4]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.2,\n            \"t_init\": 0.5\n        },\n        {\n            \"n\": np.array([0, 200, 200]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.05, 1.5, 0.05]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.05,\n            \"t_init\": 0.5\n        }\n    ]\n\n    results = []\n\n    def calculate_total_time(n, f, k_cat, K_M, t_init):\n        \"\"\"\n        Helper function to calculate the total time for protein synthesis.\n        \"\"\"\n        # Calculate per-codon dwell time tau_i = (K_M + f_i) / (k_cat * f_i)\n        # The problem constraints ensure f_i > 0, so no division by zero.\n        # Vectorized calculation for efficiency.\n        tau = (K_M + f) / (k_cat * f)\n        \n        # Calculate total elongation time T_elong = sum(n_i * tau_i)\n        T_elong = np.sum(n * tau)\n        \n        # Return total time: initiation + elongation\n        return t_init + T_elong\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        n, f0, s = case[\"n\"], case[\"f0\"], case[\"s\"]\n        k_cat, K_M, t_init = case[\"k_cat\"], case[\"K_M\"], case[\"t_init\"]\n\n        # Calculate charged fractions under stress, capped at 1.0\n        fs = np.minimum(1.0, f0 * s)\n        \n        # Calculate total synthesis time for baseline condition\n        total_time_0 = calculate_total_time(n, f0, k_cat, K_M, t_init)\n        \n        # Calculate total synthesis time for stress condition\n        total_time_s = calculate_total_time(n, fs, k_cat, K_M, t_init)\n        \n        # The fold-change rho is the ratio of rates, which is the inverse ratio of total times.\n        # rho = R_s / R_0 = (1 / total_time_s) / (1 / total_time_0) = total_time_0 / total_time_s\n        rho = total_time_0 / total_time_s\n        \n        results.append(rho)\n\n    # Format the final output as a comma-separated list of values rounded to 6 decimal places,\n    # enclosed in square brackets. Using f-string formatting to ensure 6 decimal places.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2770734"}, {"introduction": "The components of the translation machinery form a tightly interconnected system where resources are finite and shared among all active genes. Perturbing one component, such as overexpressing a specific tRNA, can have complex and non-intuitive effects on the entire proteome. This final practice integrates these concepts into a global model, challenging you to predict how tRNA overexpression reallocates ribosomal resources, impacting not only the overall protein synthesis flux but also the fidelity of translation across thousands of genes [@problem_id:2770659].", "problem": "You are asked to formalize and compute the effect of overexpressing a specific transfer RNA (tRNA) on global ribosome translation dynamics by applying a principled kinetic model of codon decoding. Your program must implement the following principled model, derive the required quantities from first principles, and produce numerical predictions for a provided test suite. All final outputs are dimensionless decimal numbers as floats.\n\nFundamental base and modeling assumptions:\n- The Central Dogma establishes that messenger RNA (mRNA) is translated by ribosomes, which decode codons using transfer RNA (tRNA) molecules carrying amino acids.\n- In a minimal kinetic model of decoding, the codon recognition step can be approximated by mass-action proportionality: the rate of successfully decoding a codon is proportional to the concentration (abundance) of cognate tRNA that can correctly pair with that codon. Near-cognate tRNA that can form non-Watson–Crick or wobble-like pairs may occasionally be (incorrectly) accepted with much lower probability.\n- We treat each codon’s decoding as an effective first-order process with an effective rate that is a weighted sum of cognate and near-cognate tRNA abundances. The near-cognate contribution is down-weighted by a penalty factor.\n\nDefinitions:\n- Let there be $N_c$ codon types indexed by $c \\in \\{0,1,\\dots,N_c-1\\}$ and $N_t$ tRNA species indexed by $t \\in \\{0,1,\\dots,N_t-1\\}$.\n- For each codon $c$, let $C_c$ be the set of cognate tRNA indices and $N_c$ be the set of near-cognate tRNA indices. Let $p \\in (0,1)$ be the near-cognate penalty, modeled as a multiplicative factor on near-cognate contributions.\n- Let $a \\in \\mathbb{R}_{+}^{N_t}$ be the baseline tRNA abundance vector. Overexpress a specific tRNA $t^\\star$ by a factor $f \\ge 1$ to obtain a modified vector $a'$. Two modes are considered:\n  - No normalization: $a'_t = a_t$ for $t \\ne t^\\star$ and $a'_{t^\\star} = f \\, a_{t^\\star}$.\n  - Normalization to conserve total tRNA mass: compute $\\tilde{a}$ as above and then rescale to conserve the total abundance, $a'' = \\tilde{a} \\cdot \\frac{\\sum_{t} a_t}{\\sum_{t} \\tilde{a}_t}$. Use $a''$ as the modified vector.\n- The effective decoding rate for codon $c$ under tRNA vector $x$ is\n  $$ r_c(x) = k_e \\left( \\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t \\right), $$\n  where $k_e$ is a constant kinetic proportionality factor. For this problem, set $k_e = 1$ in arbitrary units, so that rates and times are internally consistent but final outputs are dimensionless quantities.\n- The dwell time for codon $c$ is $\\tau_c(x) = 1 / r_c(x)$.\n- Consider $G$ genes, each gene $g \\in \\{1,\\dots,G\\}$ is a sequence of codon indices $\\{c_i^{(g)}\\}_{i=1}^{L_g}$, where $L_g$ is the number of codons in gene $g$. The elongation time for gene $g$ is\n  $$ T_g(x) = \\sum_{i=1}^{L_g} \\tau_{c_i^{(g)}}(x). $$\n- Gene $g$ has an initiation rate $k_{\\mathrm{init},g}$ (in $\\mathrm{s}^{-1}$). The initiation waiting time is $\\tau_{\\mathrm{init},g} = 1 / k_{\\mathrm{init},g}$. A simple cycle-time approximation gives the mean time per completed protein for gene $g$ as\n  $$ \\tau_{\\mathrm{cycle},g}(x) = \\tau_{\\mathrm{init},g} + T_g(x). $$\n  The mean synthesis rate for gene $g$ is then\n  $$ J_g(x) = \\frac{1}{\\tau_{\\mathrm{cycle},g}(x)}. $$\n- The total proteome synthesis flux under $x$ is\n  $$ S(x) = \\sum_{g=1}^{G} J_g(x). $$\n- The near-cognate incorporation probability for codon $c$ under $x$ is\n  $$ P_{\\mathrm{nc},c}(x) = \\frac{p \\sum_{t \\in N_c} x_t}{\\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t}, $$\n  with the convention that if the denominator is $0$ then $P_{\\mathrm{nc},c}(x) = 0$.\n- The expected near-cognate count per translation of gene $g$ is\n  $$ E_g(x) = \\sum_{i=1}^{L_g} P_{\\mathrm{nc},c_i^{(g)}}(x). $$\n- The proteome-weighted near-cognate fraction is\n  $$ F(x) = \\frac{\\sum_{g=1}^{G} J_g(x)\\, E_g(x)}{\\sum_{g=1}^{G} J_g(x)\\, L_g}. $$\n\nTask:\n- For each parameter set in the test suite below, compute the baseline metrics with $x = a$ and the perturbed metrics with $x =$ modified vector after overexpressing $t^\\star$ by factor $f$ under the specified normalization mode. Report the two fold-changes:\n  - $S$-fold-change $= S(x_{\\mathrm{pert}}) / S(x_{\\mathrm{base}})$.\n  - $F$-fold-change $= F(x_{\\mathrm{pert}}) / F(x_{\\mathrm{base}})$.\n- All outputs are dimensionless decimal floats.\n\nShared model constants and structures for all tests:\n- Number of codons $N_c = 5$ with indices $c \\in \\{0,1,2,3,4\\}$.\n- Number of tRNA species $N_t = 3$ with indices $t \\in \\{0,1,2\\}$.\n- Cognate and near-cognate sets by codon:\n  - $C_0 = \\{0\\}$, $N_0 = \\{1\\}$.\n  - $C_1 = \\{0\\}$, $N_1 = \\{1\\}$.\n  - $C_2 = \\{1\\}$, $N_2 = \\{0\\}$.\n  - $C_3 = \\{2\\}$, $N_3 = \\varnothing$.\n  - $C_4 = \\{2\\}$, $N_4 = \\{0\\}$.\n- Genes and initiation rates:\n  - $G = 3$ genes.\n  - Gene $1$: codon sequence $\\{0,1,2,0,1,2,3,4\\}$ of length $L_1 = 8$, with $k_{\\mathrm{init},1} = 0.5\\,\\mathrm{s}^{-1}$.\n  - Gene $2$: codon sequence $\\{3,3,4,4,3,4\\}$ of length $L_2 = 6$, with $k_{\\mathrm{init},2} = 0.8\\,\\mathrm{s}^{-1}$.\n  - Gene $3$: codon sequence $\\{2,2,2,0,1,0,1\\}$ of length $L_3 = 7$, with $k_{\\mathrm{init},3} = 0.3\\,\\mathrm{s}^{-1}$.\n- Baseline tRNA abundance vector $a = [30, 15, 10]$ in arbitrary abundance units.\n\nTest suite (each test defines $(t^\\star, f, \\text{normalize}, p)$):\n- Test $1$: $t^\\star = 1$, $f = 1$, $\\text{normalize} = \\text{False}$, $p = 0.02$.\n- Test $2$: $t^\\star = 1$, $f = 3$, $\\text{normalize} = \\text{True}$, $p = 0.02$.\n- Test $3$: $t^\\star = 1$, $f = 3$, $\\text{normalize} = \\text{False}$, $p = 0.02$.\n- Test $4$: $t^\\star = 0$, $f = 10$, $\\text{normalize} = \\text{True}$, $p = 0.10$.\n\nYour program must:\n- Implement the model exactly as specified above.\n- For each test, compute the two fold-changes $S$-fold-change and $F$-fold-change relative to the baseline $x = a$ for that test’s $p$ and normalization setting (note that when $f=1$, the fold-changes should be exactly $1$).\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n  $$[S\\text{-fold}_1, F\\text{-fold}_1, S\\text{-fold}_2, F\\text{-fold}_2, S\\text{-fold}_3, F\\text{-fold}_3, S\\text{-fold}_4, F\\text{-fold}_4].$$\n- Each float should be rounded to $6$ decimal places.", "solution": "The problem statement presents a valid and well-posed challenge in computational systems biology. It requires the implementation of a kinetic model of ribosome translation to quantitatively assess the impact of tRNA overexpression on global protein synthesis efficiency and accuracy. The model is constructed from first principles commonly used in the field, such as mass-action kinetics for codon decoding and a simple cycle-time approximation for protein synthesis rates. All necessary parameters, definitions, and functions are provided without ambiguity or contradiction. The problem is scientifically grounded, objective, and self-contained, thus permitting a direct and rigorous solution.\n\nWe will proceed by first formalizing the calculation of all quantities defined in the model. The primary objective is to compute two metrics: the total proteome synthesis flux, denoted by $S(x)$, and the proteome-weighted near-cognate fraction, $F(x)$, where $x$ represents the vector of tRNA abundances. These metrics will be calculated for a baseline tRNA abundance vector $a$ and a perturbed vector $x_{\\text{pert}}$, which results from overexpressing a specific tRNA.\n\n**1. Foundational Quantities: Decoding Rate and Dwell Time**\nThe rate of decoding a codon $c$ depends on the concentrations of its cognate tRNAs (set $C_c$) and near-cognate tRNAs (set $N_c$). Given the kinetic proportionality constant $k_e = 1$ and near-cognate penalty $p$, the effective decoding rate $r_c(x)$ is:\n$$ r_c(x) = \\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t $$\nThe mean time required to decode codon $c$, which is the dwell time $\\tau_c(x)$, is the reciprocal of this rate, a standard assumption for a process following first-order kinetics:\n$$ \\tau_c(x) = \\frac{1}{r_c(x)} $$\nThe provided tRNA abundances are strictly positive, ensuring that $r_c(x) > 0$ and $\\tau_c(x)$ is a finite, positive value for all codons that have at least one cognate or near-cognate tRNA.\n\n**2. Gene-Level Metrics: Elongation Time and Synthesis Rate**\nFor a gene $g$, defined by a sequence of codons $\\{c_i^{(g)}\\}_{i=1}^{L_g}$, the total time for a ribosome to synthesize the polypeptide chain, known as the elongation time $T_g(x)$, is the sum of the dwell times for each codon in its sequence:\n$$ T_g(x) = \\sum_{i=1}^{L_g} \\tau_{c_i^{(g)}}(x) $$\nThe synthesis of a complete protein involves both initiation and elongation. The mean cycle time, $\\tau_{\\mathrm{cycle},g}(x)$, is the sum of the initiation waiting time, $\\tau_{\\mathrm{init},g} = 1/k_{\\mathrm{init},g}$, and the elongation time:\n$$ \\tau_{\\mathrm{cycle},g}(x) = \\tau_{\\mathrm{init},g} + T_g(x) $$\nThe rate of protein synthesis for gene $g$, $J_g(x)$, which represents the protein production flux, is the reciprocal of the cycle time:\n$$ J_g(x) = \\frac{1}{\\tau_{\\mathrm{cycle},g}(x)} $$\n\n**3. Proteome-Level Metrics: Total Flux and Error Fraction**\nThe total proteome synthesis flux, $S(x)$, is the aggregate of the synthesis rates from all genes in the system:\n$$ S(x) = \\sum_{g=1}^{G} J_g(x) $$\nTranslation is not perfectly accurate. The probability of incorporating an incorrect amino acid due to a near-cognate tRNA at codon $c$, $P_{\\mathrm{nc},c}(x)$, is the ratio of the near-cognate decoding rate to the total decoding rate:\n$$ P_{\\mathrm{nc},c}(x) = \\frac{p \\sum_{t \\in N_c} x_t}{\\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t} = p \\cdot \\tau_c(x) \\sum_{t \\in N_c} x_t $$\nThe expected number of such errors during a single translation of gene $g$, $E_g(x)$, is the sum of these probabilities across the gene's sequence:\n$$ E_g(x) = \\sum_{i=1}^{L_g} P_{\\mathrm{nc},c_i^{(g)}}(x) $$\nThe global measure of translation infidelity, the proteome-weighted near-cognate fraction $F(x)$, is the total rate of near-cognate incorporations across all genes divided by the total rate of all codon incorporations. This is formulated as:\n$$ F(x) = \\frac{\\sum_{g=1}^{G} J_g(x)\\, E_g(x)}{\\sum_{g=1}^{G} J_g(x)\\, L_g} $$\nThis quantity represents the average error probability per codon, weighted by the expression level and length of each gene.\n\n**4. tRNA Abundance Perturbation**\nThe problem analyzes the system's response to overexpressing a specific tRNA, $t^\\star$, by a factor $f \\ge 1$. The baseline state is defined by the tRNA abundance vector $x_{\\text{base}} = a$. The perturbed state vector, $x_{\\text{pert}}$, is generated in one of two ways:\n- **No Normalization:** The abundance of tRNA $t^\\star$ is increased, while others remain constant:\n  $$ (x_{\\text{pert}})_t = \\begin{cases} f \\cdot a_{t^\\star} & \\text{if } t = t^\\star \\\\ a_t & \\text{if } t \\ne t^\\star \\end{cases} $$\n- **Normalization:** An intermediate vector, $\\tilde{a}$, is first created as above. Then, all components are rescaled to conserve the total tRNA mass of the baseline state, $\\sum_t a_t$:\n  $$ x_{\\text{pert}} = \\tilde{a} \\cdot \\frac{\\sum_{t} a_t}{\\sum_{t} \\tilde{a}_t} $$\n\n**5. Computational Strategy**\nFor each test case specified by $(t^\\star, f, \\text{normalize}, p)$, the following steps are executed:\n1.  The baseline metrics, $S(x_{\\text{base}})$ and $F(x_{\\text{base}})$, are computed using $x_{\\text{base}} = a$ and the value of $p$ from the test case.\n2.  The perturbed tRNA vector, $x_{\\text{pert}}$, is calculated based on the given $t^\\star$, $f$, and normalization mode.\n3.  The perturbed metrics, $S(x_{\\text{pert}})$ and $F(x_{\\text{pert}})$, are computed using this new vector and the same $p$.\n4.  The final results are the fold-changes: $S\\text{-fold} = S(x_{\\text{pert}}) / S(x_{\\text{base}})$ and $F\\text{-fold} = F(x_{\\text{pert}}) / F(x_{\\text{base}})$. Division by zero is not an issue, as baseline metrics will be non-zero given the problem parameters.\n\nFor Test $1$, where $f=1$, the perturbation is null ($x_{\\text{pert}} = x_{\\text{base}}$), correctly yielding fold-changes of $1.0$. This provides a necessary sanity check for the implementation. The numerical results for all test cases are computed by the provided program.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the kinetic model of translation to compute the effects of tRNA overexpression.\n    \"\"\"\n    # --- Shared Model Constants and Structures ---\n    N_c = 5  # Number of codon types\n    N_t = 3  # Number of tRNA species\n    G = 3    # Number of genes\n\n    # Cognate and near-cognate sets (0-indexed)\n    cognate_sets = [[0], [0], [1], [2], [2]]\n    near_cognate_sets = [[1], [1], [0], [], [0]]\n\n    # Gene definitions\n    genes = [\n        {'seq': np.array([0, 1, 2, 0, 1, 2, 3, 4]), 'k_init': 0.5},\n        {'seq': np.array([3, 3, 4, 4, 3, 4]), 'k_init': 0.8},\n        {'seq': np.array([2, 2, 2, 0, 1, 0, 1]), 'k_init': 0.3}\n    ]\n    gene_lengths = np.array([len(g['seq']) for g in genes])\n    k_init_inv = np.array([1.0 / g['k_init'] for g in genes])\n    gene_sequences = [g['seq'] for g in genes]\n\n    # Baseline tRNA abundance vector\n    a_base = np.array([30.0, 15.0, 10.0])\n    total_trna_base = np.sum(a_base)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (t_star, f, normalize, p)\n        (1, 1.0, False, 0.02),\n        (1, 3.0, True, 0.02),\n        (1, 3.0, False, 0.02),\n        (0, 10.0, True, 0.10)\n    ]\n\n    # Pre-calculate sums for cognate and near-cognate tRNA indices\n    # This avoids repeated lookups and allows for vectorized calculations\n    cognate_masks = np.zeros((N_c, N_t), dtype=bool)\n    near_cognate_masks = np.zeros((N_c, N_t), dtype=bool)\n    for c in range(N_c):\n        if cognate_sets[c]:\n            cognate_masks[c, cognate_sets[c]] = True\n        if near_cognate_sets[c]:\n            near_cognate_masks[c, near_cognate_sets[c]] = True\n    \n    def calculate_metrics(x, p):\n        \"\"\"\n        Calculates all model metrics for a given tRNA vector x and penalty p.\n        \"\"\"\n        # 1. Codon decoding rates and probabilities\n        cognate_sums = cognate_masks @ x\n        near_cognate_sums = near_cognate_masks @ x\n\n        r_c = cognate_sums + p * near_cognate_sums\n        \n        # Handle division by zero, although not expected here\n        tau_c = np.divide(1.0, r_c, out=np.zeros_like(r_c), where=r_c!=0)\n        \n        rate_of_nc_incorp = p * near_cognate_sums\n        p_nc_c = np.divide(rate_of_nc_incorp, r_c, out=np.zeros_like(r_c), where=r_c!=0)\n\n        # 2. Gene-level metrics\n        T_g = np.array([np.sum(tau_c[seq]) for seq in gene_sequences])\n        tau_cycle_g = k_init_inv + T_g\n        J_g = 1.0 / tau_cycle_g\n        E_g = np.array([np.sum(p_nc_c[seq]) for seq in gene_sequences])\n\n        # 3. Proteome-level metrics\n        S = np.sum(J_g)\n        \n        F_numerator = np.sum(J_g * E_g)\n        F_denominator = np.sum(J_g * gene_lengths)\n        \n        F = F_numerator / F_denominator if F_denominator != 0 else 0.0\n        \n        return S, F\n\n    results = []\n    \n    for t_star, f, normalize, p in test_cases:\n        # Calculate baseline metrics for the current test's p\n        S_base, F_base = calculate_metrics(a_base, p)\n\n        # Generate perturbed tRNA vector\n        x_pert = np.copy(a_base)\n        x_pert[t_star] *= f\n\n        if normalize:\n            total_trna_pert = np.sum(x_pert)\n            if total_trna_pert != 0:\n                x_pert *= (total_trna_base / total_trna_pert)\n        \n        # Calculate perturbed metrics\n        S_pert, F_pert = calculate_metrics(x_pert, p)\n\n        # Compute and append fold-changes\n        S_fold = S_pert / S_base if S_base != 0 else 0.0\n        F_fold = F_pert / F_base if F_base != 0 else 0.0\n        \n        results.extend([S_fold, F_fold])\n\n    # Format output to 6 decimal places and print\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2770659"}]}