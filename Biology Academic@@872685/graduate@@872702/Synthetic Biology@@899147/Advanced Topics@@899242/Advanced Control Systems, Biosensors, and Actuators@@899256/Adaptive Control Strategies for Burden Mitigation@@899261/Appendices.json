{"hands_on_practices": [{"introduction": "The fundamental challenge in synthetic biology is managing the metabolic burden imposed by engineered circuits on the host cell. This first practice provides a quantitative foundation by exploring a widely-used proteome allocation model. By deriving the linear relationship between synthetic protein expression and cellular growth rate, you will gain an analytical understanding of the direct cost of burden, a critical first step in designing any mitigation strategy [@problem_id:2712681].", "problem": "A bacterial cell is modeled using a coarse-grained proteome allocation framework in the translation-limited regime. The proteome is partitioned into three sectors: ribosomal proteins with mass fraction $ \\phi_{R} $, a fixed housekeeping sector with mass fraction $ \\phi_{H} $, and a synthetic protein sector with mass fraction $ \\phi_{p} $. Proteome conservation imposes the linear constraint $ \\phi_{R} + \\phi_{p} + \\phi_{H} = 1 $. Assume that $ \\phi_{H} $ is set by the nutrient condition and is constant over the range of burden considered, and that a constant fraction $ \\phi_{0} $ of ribosomes is inactive.\n\nUse as a fundamental base the well-tested empirical growth law for translation-limited growth that connects the cellular growth rate $ \\lambda $ to the active ribosomal proteome fraction:\n$$\n\\lambda \\;=\\; \\sigma \\bigl( \\phi_{R} - \\phi_{0} \\bigr),\n$$\nwhere $ \\sigma $ is the effective translational capacity per unit ribosomal proteome. Let $ \\lambda_{0} $ denote the baseline growth rate at zero synthetic burden $ \\phi_{p} = 0 $ in the same environment (same $ \\phi_{H} $, same $ \\sigma $, same $ \\phi_{0} $).\n\nDefine the dimensionless proteome cost coefficient $ c $ as the relative slope of the growth rate with respect to the synthetic proteome fraction at zero burden:\n$$\nc \\;\\equiv\\; \\lim_{\\Delta \\phi_{p} \\to 0} \\frac{\\lambda_{0} - \\lambda(\\phi_{p})}{\\lambda_{0}\\,\\phi_{p}}.\n$$\n\nStarting only from the proteome conservation constraint, the constancy of $ \\phi_{H} $ and $ \\phi_{0} $, and the growth law above, derive an explicit expression for $ \\lambda(\\phi_{p}) $ in closed form, expressed entirely in terms of $ \\lambda_{0} $, $ c $, and $ \\phi_{p} $. Your final answer must be a single closed-form analytic expression for $ \\lambda(\\phi_{p}) $. Do not include units in your final boxed answer.", "solution": "We are tasked with deriving an expression for the cellular growth rate, $ \\lambda $, as a function of the synthetic protein mass fraction, $ \\phi_{p} $, in terms of the baseline growth rate $ \\lambda_{0} $ and the cost coefficient $ c $. The derivation will proceed from the given first principles.\n\nThe system is described by two fundamental equations:\n$1$. The proteome conservation constraint:\n$$ \\phi_{R} + \\phi_{p} + \\phi_{H} = 1 $$\n$2$. The translation-limited growth law:\n$$ \\lambda = \\sigma (\\phi_{R} - \\phi_{0}) $$\nThe parameters $ \\phi_{H} $ (housekeeping proteome fraction), $ \\phi_{0} $ (inactive ribosomal proteome fraction), and $ \\sigma $ (effective translational capacity) are given as constants for a specific growth environment.\n\nFrom the proteome conservation equation, we first isolate the ribosomal protein fraction, $ \\phi_{R} $, as it is the variable that links the proteome composition to the growth rate:\n$$ \\phi_{R} = 1 - \\phi_{H} - \\phi_{p} $$\nSubstituting this expression for $ \\phi_{R} $ into the growth law yields the growth rate $ \\lambda $ as an explicit function of $ \\phi_{p} $:\n$$ \\lambda(\\phi_{p}) = \\sigma \\left( (1 - \\phi_{H} - \\phi_{p}) - \\phi_{0} \\right) $$\nBy rearranging the terms inside the parenthesis, we obtain a linear relationship between $ \\lambda $ and $ \\phi_{p} $:\n$$ \\lambda(\\phi_{p}) = \\sigma (1 - \\phi_{H} - \\phi_{0}) - \\sigma \\phi_{p} $$\n\nThe objective is to re-parameterize this expression using $ \\lambda_{0} $ and $ c $.\nFirst, we utilize the definition of the baseline growth rate $ \\lambda_{0} $, which corresponds to the case of zero synthetic burden, i.e., $ \\phi_{p} = 0 $. By setting $ \\phi_{p} = 0 $ in our expression for $ \\lambda(\\phi_{p}) $, we find:\n$$ \\lambda_{0} = \\lambda(0) = \\sigma (1 - \\phi_{H} - \\phi_{0}) $$\nThis term is precisely the constant intercept in our linear equation for $ \\lambda(\\phi_{p}) $. Therefore, we can simplify the expression for $ \\lambda(\\phi_{p}) $ to:\n$$ \\lambda(\\phi_{p}) = \\lambda_{0} - \\sigma \\phi_{p} $$\n\nNext, we must eliminate the parameter $ \\sigma $. For this, we use the definition of the dimensionless proteome cost coefficient $ c $:\n$$ c \\equiv \\lim_{\\phi_{p} \\to 0} \\frac{\\lambda_{0} - \\lambda(\\phi_{p})}{\\lambda_{0}\\,\\phi_{p}} $$\nThis expression defines $ c $ in terms of a limit, which can be identified with a derivative. Rewriting the expression clarifies this:\n$$ c = \\frac{1}{\\lambda_{0}} \\lim_{\\phi_{p} \\to 0} \\frac{-(\\lambda(\\phi_{p}) - \\lambda_{0})}{\\phi_{p} - 0} = -\\frac{1}{\\lambda_{0}} \\left( \\frac{d\\lambda}{d\\phi_{p}} \\right)_{\\phi_{p}=0} $$\nWe now compute the derivative of $ \\lambda(\\phi_{p}) $ with respect to $ \\phi_{p} $ using the expression we derived:\n$$ \\frac{d\\lambda}{d\\phi_{p}} = \\frac{d}{d\\phi_{p}} (\\lambda_{0} - \\sigma \\phi_{p}) = -\\sigma $$\nThe derivative is a constant, so its value at $ \\phi_{p}=0 $ is also $ -\\sigma $. Substituting this result into the formula for $ c $:\n$$ c = -\\frac{1}{\\lambda_{0}} (-\\sigma) = \\frac{\\sigma}{\\lambda_{0}} $$\nThis provides an expression for $ \\sigma $ in terms of the desired parameters:\n$$ \\sigma = c \\lambda_{0} $$\n\nFinally, we substitute this expression for $ \\sigma $ back into our equation for $ \\lambda(\\phi_{p}) $:\n$$ \\lambda(\\phi_{p}) = \\lambda_{0} - (c \\lambda_{0}) \\phi_{p} $$\nFactoring out the common term $ \\lambda_{0} $ yields the final closed-form expression for the growth rate as a function of synthetic protein fraction, expressed entirely in terms of the specified parameters:\n$$ \\lambda(\\phi_{p}) = \\lambda_{0}(1 - c \\phi_{p}) $$\nThis result demonstrates a linear decrease in growth rate as the burden from synthetic protein expression increases, with the rate of decrease determined by the product of the baseline growth rate and the cost coefficient.", "answer": "$$ \\boxed{\\lambda_{0}(1 - c \\phi_{p})} $$", "id": "2712681"}, {"introduction": "Once the cost of burden is understood, the next step is to actively regulate it. This exercise introduces the core principles of feedback control by tasking you with analyzing a simple linear model of burden dynamics under proportional ($P$) and proportional-integral ($PI$) control. You will derive the steady-state tracking error for each case, revealing the unique and powerful ability of integral action to eliminate error and robustly maintain burden at a desired setpoint [@problem_id:2712643].", "problem": "A burden-aware resource allocation module is used to mitigate host load in a synthetic Escherichia coli strain. Let the scalar host burden state be denoted by $b(t)$, defined as a dimensionless fractional deviation of translational capacity from a no-load baseline. Near a nominal operating point, suppose $b(t)$ is well approximated by a first-order linear dynamics with additive constant disturbance:\n$$\n\\frac{db}{dt} \\;=\\; -k_{b}\\,\\big(b(t) - b_{0}\\big) \\;+\\; S_{p}\\,u(t) \\;+\\; d,\n$$\nwhere $k_{b} \\gt 0$ is the host’s intrinsic relaxation rate back to the baseline $b_{0}$ in the absence of control, $S_{p} \\neq 0$ is the plant sensitivity of burden to the control input $u(t)$ (the actuator’s net effect on burden), and $d$ is an unknown but constant exogenous load. The measured output is $y(t) = b(t)$, and the control objective is to track a constant burden setpoint $r$ using output feedback.\n\nConsider two controllers that actuate the same $u(t)$:\n- Proportional (P) control: $u(t) = K_{p}\\,\\big(r - y(t)\\big)$ with $K_{p} \\in \\mathbb{R}$.\n- Proportional–Integral (PI) control: $u(t) = K_{p}\\,\\big(r - y(t)\\big) + K_{i}\\,\\int_{0}^{t} \\big(r - y(\\tau)\\big)\\,d\\tau$ with $K_{p} \\in \\mathbb{R}$ and $K_{i} \\ge 0$.\n\nAssume the closed-loop system is internally stable for the chosen gains and that all signals settle to a steady state under the constant setpoint $r$ and constant disturbance $d$. Starting from the given plant dynamics and these controller definitions, derive from first principles the steady-state tracking error $e_{\\mathrm{ss}} = r - y_{\\mathrm{ss}}$ under proportional control as a function of $K_{p}$ and $S_{p}$ together with $k_{b}$, $b_{0}$, $r$, and $d$. Then determine the steady-state error under proportional–integral control and explain under what condition integral action eliminates the steady-state error against constant $d$.\n\nExpress your final answer as a single row matrix $\\big[e_{\\mathrm{ss}}^{(P)} \\;\\; e_{\\mathrm{ss}}^{(PI)}\\big]$, where each entry is a closed-form analytic expression in the symbols specified above. Do not include units. If any approximation is required, state and justify it; otherwise, provide exact expressions.", "solution": "The problem requires the derivation of the steady-state tracking error for a first-order linear system under proportional (P) and proportional-integral (PI) control. The analysis will be conducted from first principles, assuming the closed-loop systems are stable and all signals converge to a steady state.\n\nLet us first analyze the system under proportional (P) control.\nThe control law is $u(t) = K_{p}(r - y(t))$.\nSubstituting this into the plant dynamics, and using $y(t) = b(t)$, we obtain the closed-loop differential equation for the output $y(t)$:\n$$\n\\frac{dy}{dt} = -k_{b}(y(t) - b_{0}) + S_{p}K_{p}(r - y(t)) + d\n$$\nAt steady state, as $t \\to \\infty$, all time derivatives approach zero. Therefore, $\\frac{dy}{dt} \\to 0$, and the output converges to a constant value, $y(t) \\to y_{\\mathrm{ss}}$. The equation becomes:\n$$\n0 = -k_{b}(y_{\\mathrm{ss}} - b_{0}) + S_{p}K_{p}(r - y_{\\mathrm{ss}}) + d\n$$\nWe must now solve this algebraic equation for $y_{\\mathrm{ss}}$. Expanding the terms:\n$$\n0 = -k_{b}y_{\\mathrm{ss}} + k_{b}b_{0} + S_{p}K_{p}r - S_{p}K_{p}y_{\\mathrm{ss}} + d\n$$\nGroup the terms containing $y_{\\mathrm{ss}}$:\n$$\n(k_{b} + S_{p}K_{p})y_{\\mathrm{ss}} = k_{b}b_{0} + S_{p}K_{p}r + d\n$$\nThe assumption of stability for this first-order system implies that the effective rate constant, $k_{b} + S_{p}K_{p}$, must be positive, and thus non-zero. We can therefore solve for $y_{\\mathrm{ss}}$:\n$$\ny_{\\mathrm{ss}} = \\frac{k_{b}b_{0} + S_{p}K_{p}r + d}{k_{b} + S_{p}K_{p}}\n$$\nThe steady-state error, $e_{\\mathrm{ss}}^{(P)}$, is defined as $r - y_{\\mathrm{ss}}$. Substituting the expression for $y_{\\mathrm{ss}}$:\n$$\ne_{\\mathrm{ss}}^{(P)} = r - \\frac{k_{b}b_{0} + S_{p}K_{p}r + d}{k_{b} + S_{p}K_{p}}\n$$\nTo simplify, we place the expression over a common denominator:\n$$\ne_{\\mathrm{ss}}^{(P)} = \\frac{r(k_{b} + S_{p}K_{p}) - (k_{b}b_{0} + S_{p}K_{p}r + d)}{k_{b} + S_{p}K_{p}}\n$$\n$$\ne_{\\mathrm{ss}}^{(P)} = \\frac{rk_{b} + rS_{p}K_{p} - k_{b}b_{0} - S_{p}K_{p}r - d}{k_{b} + S_{p}K_{p}}\n$$\nCanceling the $rS_{p}K_{p}$ terms yields the final expression for the steady-state error under P control:\n$$\ne_{\\mathrm{ss}}^{(P)} = \\frac{k_{b}r - k_{b}b_{0} - d}{k_{b} + S_{p}K_{p}} = \\frac{k_{b}(r - b_{0}) - d}{k_{b} + S_{p}K_{p}}\n$$\nThis is a non-zero error, which depends on the system parameters, the setpoint $r$, and the disturbance $d$.\n\nNext, we analyze the system under proportional-integral (PI) control.\nThe control law is $u(t) = K_{p}(r - y(t)) + K_{i}\\int_{0}^{t} (r - y(\\tau))d\\tau$.\nAt steady state, all signals are constant: $y(t) \\to y_{\\mathrm{ss}}$, $u(t) \\to u_{\\mathrm{ss}}$, and $\\frac{dy}{dt} \\to 0$.\nThe plant equation at steady state is unchanged in form:\n$$\n0 = -k_{b}(y_{\\mathrm{ss}} - b_{0}) + S_{p}u_{\\mathrm{ss}} + d\n$$\nThis requires the control input $u(t)$ to approach a constant value $u_{\\mathrm{ss}} = \\frac{k_{b}(y_{\\mathrm{ss}} - b_{0}) - d}{S_{p}}$.\nNow, we examine the controller. For the control input $u(t)$ to converge to a constant value $u_{\\mathrm{ss}}$, its time derivative must approach zero, i.e., $\\frac{du}{dt} \\to 0$. We differentiate the PI control law with respect to time:\n$$\n\\frac{du}{dt} = \\frac{d}{dt} \\left[ K_{p}(r - y(t)) + K_{i}\\int_{0}^{t} (r - y(\\tau))d\\tau \\right]\n$$\nUsing a constant setpoint $r$ and the fundamental theorem of calculus:\n$$\n\\frac{du}{dt} = -K_{p}\\frac{dy}{dt} + K_{i}(r - y(t))\n$$\nNow, we apply the steady-state conditions: as $t \\to \\infty$, $\\frac{du}{dt} \\to 0$, $\\frac{dy}{dt} \\to 0$, and $y(t) \\to y_{\\mathrm{ss}}$. Substituting these into the differentiated controller equation:\n$$\n0 = -K_{p}(0) + K_{i}(r - y_{\\mathrm{ss}})\n$$\nThis simplifies to:\n$$\nK_{i}(r - y_{\\mathrm{ss}}) = 0\n$$\nOr, in terms of the steady-state error $e_{\\mathrm{ss}}^{(PI)} = r - y_{\\mathrm{ss}}$:\n$$\nK_{i}e_{\\mathrm{ss}}^{(PI)} = 0\n$$\nThis equation is central to the behavior of integral control. The question asks for the condition under which integral action eliminates the steady-state error. The integral action is represented by the term with gain $K_{i}$. This action is present if $K_{i} \\neq 0$. Given the constraint $K_{i} \\ge 0$, this means $K_{i} > 0$.\nIf $K_{i} > 0$, then for the product $K_{i}e_{\\mathrm{ss}}^{(PI)}$ to be zero, it must be that $e_{\\mathrm{ss}}^{(PI)} = 0$.\nTherefore, provided the system is stable and the integral gain $K_{i}$ is strictly positive, the PI controller will drive the steady-state tracking error to zero, perfectly rejecting the constant disturbance $d$ and tracking the setpoint $r$.\nIf $K_{i} = 0$, the controller degenerates to a P controller, and the error is given by the expression derived in the first part. The problem, however, asks for the error under PI control, which by convention implies the presence of integral action, i.e., $K_{i} > 0$. Under this condition, the error is eliminated.\nThus, the steady-state error under PI control is $e_{\\mathrm{ss}}^{(PI)} = 0$.\n\nThe final answer consists of the two derived expressions for the steady-state errors.\nFor P control: $e_{\\mathrm{ss}}^{(P)} = \\frac{k_{b}(r - b_{0}) - d}{k_{b} + S_{p} K_{p}}$.\nFor PI control (with $K_{i} > 0$): $e_{\\mathrm{ss}}^{(PI)} = 0$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k_{b}(r - b_{0}) - d}{k_{b} + S_{p} K_{p}} & 0\n\\end{pmatrix}\n}\n$$", "id": "2712643"}, {"introduction": "Effective controllers must perform reliably despite the inherent uncertainty and complexity of biological systems. This advanced computational practice moves from ideal models to the more realistic scenario of model mismatch and disturbances, using principles from robust predictive control. You will develop a worst-case error bound and use it to calculate a robustness margin, ensuring that safety-critical burden constraints are respected even under uncertainty [@problem_id:2712587].", "problem": "Consider a burden-aware predictive control problem for a gene expression circuit where the cell-wide resource burden is modeled as a scalar state. Let the true discrete-time scalar dynamics be given by $x_{k+1} = a x_k + b u_k + w_k$ and the nominal model used by the controller be $\\hat{x}_{k+1} = \\hat{a} \\hat{x}_k + \\hat{b} u_k$, with output $y_k = c x_k$ and burden constraint $y_k \\le B$ at each step $k$. Assume $c > 0$ and a constant planned input $u_k \\equiv u$ over a finite prediction horizon of length $H \\in \\mathbb{N}$. The initial condition satisfies $\\hat{x}_0 = x_0$ so that the initial model-mismatch error is zero.\n\nYou are given bounded uncertainty and mismatch:\n- Additive disturbance is bounded by $|w_k| \\le \\bar{W}$ for all $k$.\n- Parameter mismatch is bounded by $|a - \\hat{a}| \\le \\bar{\\delta}_a$ and $|b - \\hat{b}| \\le \\bar{\\delta}_b$.\n- The true parameter magnitude $|a|$ is known.\n\nUsing only these base facts and standard linear time-invariant system propagation, do the following for each test case:\n- Derive and use a worst-case error bound recursion for $M_k \\ge |e_k|$ where $e_k := x_k - \\hat{x}_k$ with $M_0 = 0$ and, for each step, $$M_{k+1} \\le |a| M_k + \\bar{\\delta}_a |\\hat{x}_k| + \\bar{\\delta}_b |u| + \\bar{W}.$$\n- Compute the nominal trajectory $\\{\\hat{x}_k\\}_{k=0}^H$ under the nominal model and constant input $u$, with $\\hat{x}_{k+1} = \\hat{a} \\hat{x}_k + \\hat{b} u$ and given $\\hat{x}_0 = x_0$.\n- For each $k \\in \\{1,\\dots,H\\}$, compute the worst-case upper bound on the burden as $y_k^{\\mathrm{wc}} := c(\\hat{x}_k + M_k)$ and the worst-case constraint violation magnitude $v_k := \\max\\{0, y_k^{\\mathrm{wc}} - B\\}$.\n- Report the maximum violation over the horizon $v_{\\max} := \\max_{1 \\le k \\le H} v_k$ and the count of violating steps $N_{\\mathrm{viol}} := |\\{k \\in \\{1,\\dots,H\\} : v_k > 0\\}|$.\n- Propose a robustness margin that tightens the nominal constraint to $\\hat{y}_k \\le B - m(H)$ for all $k \\in \\{1,\\dots,H\\}$ so that $y_k \\le B$ holds for all uncertainties within the bounds. Use the derived bound to compute $$m(H) := c \\max_{1 \\le k \\le H} M_k.$$\n- Finally, check whether the current nominal plan satisfies the tightened constraints, that is, compute the boolean feasibility flag $\\mathrm{feas} := \\bigwedge_{k=1}^H \\left(c \\hat{x}_k \\le B - m(H)\\right)$.\n\nFundamental bases you may use:\n- Linearization of biochemical reaction networks near an operating point is a well-tested approximation, yielding discrete-time linear dynamics for sampled predictive control.\n- Bounded additive disturbances and bounded parametric mismatch yield input-to-state type inequalities for error propagation under linear dynamics.\n- The triangle inequality and monotonicity of maxima justify worst-case accumulation across the prediction horizon.\n\nYour program must compute, for each test case, the tuple $[v_{\\max}, m(H), N_{\\mathrm{viol}}, \\mathrm{feas}]$ where $v_{\\max}$ and $m(H)$ are floats, $N_{\\mathrm{viol}}$ is an integer, and $\\mathrm{feas}$ is a boolean. Round $v_{\\max}$ and $m(H)$ to six decimal places in the output. The final output must be a single line containing a list of these tuples for all test cases, with no additional text, formatted as a comma-separated list enclosed in square brackets.\n\nUse the following test suite, each with dimensionless parameters:\n- Case $1$ (happy path, short horizon): $a = 0.85$, $\\hat{a} = 0.84$, $b = 0.50$, $\\hat{b} = 0.48$, $c = 1.00$, $B = 1.00$, $x_0 = 0.20$, $u = 0.30$, $H = 5$, $\\bar{\\delta}_a = 0.01$, $\\bar{\\delta}_b = 0.02$, $\\bar{W} = 0.005$.\n- Case $2$ (impact of long horizon): same as Case $1$ except $H = 20$.\n- Case $3$ (no mismatch, no disturbance): $a = 0.90$, $\\hat{a} = 0.90$, $b = 0.50$, $\\hat{b} = 0.50$, $c = 1.00$, $B = 1.00$, $x_0 = 0.10$, $u = 0.20$, $H = 10$, $\\bar{\\delta}_a = 0.00$, $\\bar{\\delta}_b = 0.00$, $\\bar{W} = 0.00$.\n- Case $4$ (near-integrator, stronger uncertainty): $a = 0.98$, $\\hat{a} = 0.95$, $b = 0.45$, $\\hat{b} = 0.46$, $c = 1.00$, $B = 1.00$, $x_0 = 0.40$, $u = 0.50$, $H = 30$, $\\bar{\\delta}_a = 0.03$, $\\bar{\\delta}_b = 0.01$, $\\bar{W} = 0.02$.\n- Case $5$ (boundary, single-step horizon): $a = 0.85$, $\\hat{a} = 0.83$, $b = 0.50$, $\\hat{b} = 0.50$, $c = 1.00$, $B = 1.00$, $x_0 = 0.20$, $u = 0.70$, $H = 1$, $\\bar{\\delta}_a = 0.02$, $\\bar{\\delta}_b = 0.00$, $\\bar{W} = 0.00$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[[r1a,r1b,r1c,r1d],[r2a,r2b,r2c,r2d],...]\"), in the order of the test cases above. No physical units are involved; all quantities are dimensionless. Angles are not involved. Percentages, if any occur, must be expressed as decimals; none are required here.", "solution": "The fundamental quantities are the true state $x_k$, the nominal state $\\hat{x}_k$, and the error $e_k = x_k - \\hat{x}_k$. The objective is to evaluate constraint satisfaction over a finite horizon $H$ by bounding the worst-case error.\n\nFirst, we establish the recursion for the error bound. The error dynamics are derived from the true and nominal models:\n$$e_{k+1} = x_{k+1} - \\hat{x}_{k+1}$$\n$$e_{k+1} = (a x_k + b u_k + w_k) - (\\hat{a} \\hat{x}_k + \\hat{b} u_k)$$\nBy substituting $x_k = \\hat{x}_k + e_k$ and recognizing that the input $u_k$ is a planned constant $u$, we obtain:\n$$e_{k+1} = a (\\hat{x}_k + e_k) + b u + w_k - \\hat{a} \\hat{x}_k - \\hat{b} u$$\n$$e_{k+1} = a e_k + (a - \\hat{a})\\hat{x}_k + (b - \\hat{b})u + w_k$$\nApplying the triangle inequality to find a bound on the magnitude of the error, $|e_{k+1}|$, yields:\n$$|e_{k+1}| \\le |a||e_k| + |a - \\hat{a}||\\hat{x}_k| + |b - \\hat{b}||u| + |w_k|$$\nUsing the provided bounds $|a - \\hat{a}| \\le \\bar{\\delta}_a$, $|b - \\hat{b}| \\le \\bar{\\delta}_b$, and $|w_k| \\le \\bar{W}$, and defining a bounding sequence $M_k$ such that $|e_k| \\le M_k$ for all $k$, we have:\n$$|e_{k+1}| \\le |a| M_k + \\bar{\\delta}_a |\\hat{x}_k| + \\bar{\\delta}_b |u| + \\bar{W}$$\nTo compute the tightest such bound, we define the recursive sequence $M_k$ with equality, starting with $M_0 = |e_0| = |x_0 - \\hat{x}_0| = 0$ as given.\n$$M_{k+1} = |a| M_k + \\bar{\\delta}_a |\\hat{x}_k| + \\bar{\\delta}_b |u| + \\bar{W}$$\nThis confirms the validity of the recursion provided in the problem statement.\n\nThe algorithmic procedure is as follows, executed for each test case:\n\n1.  **Initialization**: The nominal state trajectory $\\{\\hat{x}_k\\}_{k=0}^H$ and the error bound trajectory $\\{M_k\\}_{k=0}^H$ are initialized as arrays of size $H+1$. The initial conditions are set according to the problem: $\\hat{x}_0 = x_0$ and $M_0 = 0$.\n\n2.  **Trajectory Generation**: A loop iterates from $k = 0$ to $H-1$. In each iteration, the next nominal state $\\hat{x}_{k+1}$ and the next error bound $M_{k+1}$ are computed and stored.\n    -   The nominal trajectory is computed using the nominal model: $\\hat{x}_{k+1} = \\hat{a} \\hat{x}_k + \\hat{b} u$.\n    -   The error bound trajectory is computed using the derived recursion: $M_{k+1} = |a| M_k + \\bar{\\delta}_a |\\hat{x}_k| + \\bar{\\delta}_b |u| + \\bar{W}$. Note that the computation of $M_{k+1}$ depends on $\\hat{x}_k$, so these must be computed in lock-step.\n\n3.  **Worst-Case Violation Analysis**: The analysis is performed over the horizon $k \\in \\{1, \\dots, H\\}$.\n    -   The true output is $y_k = c x_k$. The burden constraint is $y_k \\le B$. The worst case corresponds to the situation most likely to violate this constraint, which is the maximum possible value of $y_k$. As $c > 0$ and $x_k = \\hat{x}_k + e_k$ with $|e_k| \\le M_k$, the worst-case (maximum) output is $y_k^{\\mathrm{wc}} = c(\\hat{x}_k + M_k)$.\n    -   The constraint violation at each step $k$ is the positive part of the difference between the worst-case output and the constraint boundary: $v_k = \\max\\{0, y_k^{\\mathrm{wc}} - B\\}$.\n    -   The maximum violation over the horizon is $v_{\\max} = \\max_{1 \\le k \\le H} v_k$.\n    -   The number of violating steps is the count of steps where the violation is strictly positive: $N_{\\mathrm{viol}} = |\\{k \\in \\{1, \\dots, H\\} : v_k > 0\\}|$.\n\n4.  **Robustness Margin Calculation**:\n    -   The robustness margin $m(H)$ is defined as the maximum potential modeling error in the output over the horizon: $m(H) = c \\max_{1 \\le k \\le H} M_k$. This value represents the total \"buffer\" that must be subtracted from the constraint boundary $B$ to ensure that the nominal plan is robustly feasible.\n\n5.  **Feasibility Check**:\n    -   The nominal plan is checked against a tightened constraint. For the original constraint $y_k \\le B$ to hold robustly for all possible uncertainties, the nominal output $\\hat{y}_k = c \\hat{x}_k$ must satisfy $c \\hat{x}_k \\le B - m(H)$ for all $k \\in \\{1, \\dots, H\\}$.\n    -   The boolean feasibility flag, $\\mathrm{feas}$, is true if this condition holds for all $k$ in the horizon and false otherwise: $\\mathrm{feas} := \\bigwedge_{k=1}^H (c \\hat{x}_k \\le B - m(H))$.\n\nThis complete algorithm is implemented to process the given test cases and compute the required tuple $[v_{\\max}, m(H), N_{\\mathrm{viol}}, \\mathrm{feas}]$ for each.", "answer": "[[0.000000,0.046183,0,True],[0.000000,0.170566,0,True],[0.000000,0.000000,0,True],[1.700194,1.921356,23,False],[0.000000,0.004000,0,True]]", "id": "2712587"}]}