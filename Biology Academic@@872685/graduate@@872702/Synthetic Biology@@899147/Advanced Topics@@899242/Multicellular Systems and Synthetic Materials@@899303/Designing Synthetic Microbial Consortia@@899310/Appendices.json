{"hands_on_practices": [{"introduction": "To effectively design a synthetic consortium, we must first be able to model the metabolic interactions that govern its behavior. This practice introduces joint Flux Balance Analysis (FBA), a cornerstone technique for predicting steady-state fluxes in metabolic networks. By constructing and solving a joint FBA problem for a two-organism consortium, you will learn to quantify the fundamental trade-offs in resource allocation and explore the Pareto-optimal frontier of co-growth states, a critical first step in understanding and engineering metabolic dependencies. [@problem_id:2728301]", "problem": "You are tasked with constructing and solving a joint Flux Balance Analysis (FBA) optimization for a minimal two-organism synthetic consortium that exchanges one cross-feeding metabolite. The goal is to compute Pareto-optimal operating points by maximizing a weighted sum of organismal growth rates for specified weights. Your implementation must encode the linear optimization problem from first principles and solve it for a given test suite.\n\nModeling assumptions and fundamental basis:\n- Adopt steady-state metabolic balances as in FBA: the internal metabolite accumulation is zero, which implies the linear constraints $S v = 0$ for a suitable stoichiometric matrix $S$ and flux vector $v$.\n- Each reaction flux is bounded by linear upper and lower bounds.\n- The joint objective is a weighted sum of the two growth rates. A solution that maximizes a weighted sum over different weights is Pareto optimal under convexity of the feasible set.\n\nConsortium description:\n- Organism A imports a shared external substrate $G$ (glucose) from a well-mixed medium, partitions it between biomass production and secretion of a cross-feeding metabolite $X$.\n- Organism B imports $G$ directly or imports $X$ produced by A, and converts either into biomass.\n- Both organisms satisfy internal steady-state balances.\n- Exchange of $G$ is constrained by a shared upper bound across both organisms.\n- Exchange of $X$ is constrained by a shared steady-state equality and an upper bound on the exchange capacity.\n\nDecision variables (all are nonnegative fluxes):\n- $v_{\\mathrm{A,inG}}$: A’s import of $G$.\n- $\\mu_{\\mathrm{A}}$: A’s biomass production rate (growth rate, to be expressed in $\\mathrm{h^{-1}}$).\n- $v_{\\mathrm{A,prodX}}$: A’s production of $X$ from internalized $G$.\n- $v_{\\mathrm{A,outX}}$: A’s export of $X$ to the medium.\n- $v_{\\mathrm{B,inG}}$: B’s import of $G$.\n- $v_{\\mathrm{B,inX}}$: B’s import of $X$ from the medium.\n- $\\mu_{\\mathrm{B,G}}$: B’s biomass production rate from $G$.\n- $\\mu_{\\mathrm{B,X}}$: B’s biomass production rate from $X$.\n\nSteady-state and exchange constraints:\n- A’s internal $G$ balance: $v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$.\n- A’s internal $X$ balance: $v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$.\n- B’s internal $G$ balance: $v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$.\n- B’s internal $X$ balance: $v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$.\n- External $X$ steady-state: $v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$.\n- Shared $G$ capacity: $v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max}$.\n\nFlux bounds:\n- $0 \\le v_{\\mathrm{A,inG}} \\le A_{G,\\max}$, $0 \\le v_{\\mathrm{B,inG}} \\le B_{G,\\max}$, $0 \\le v_{\\mathrm{A,outX}} \\le X_{\\max}$, $0 \\le v_{\\mathrm{B,inX}} \\le X_{\\max}$.\n- $0 \\le \\mu_{\\mathrm{A}}$, $0 \\le v_{\\mathrm{A,prodX}}$, $0 \\le \\mu_{\\mathrm{B,G}}$, $0 \\le \\mu_{\\mathrm{B,X}}$.\n- Use the constants $c_{\\mathrm{A,bio}} = 1.2$, $c_{\\mathrm{A,X}} = 1.0$, which encode that A requires $1.2$ units of internalized $G$ per unit biomass and $1.0$ unit of internalized $G$ per unit of $X$ produced. For B, one unit of $G$ or $X$ yields one unit of biomass as enforced by the balances above.\n\nObjective:\n- For a given weight $w \\in [0,1]$, maximize the weighted sum $w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}}$, where $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$.\n\nFixed parameters for all test cases unless otherwise specified:\n- $A_{G,\\max} = 10$.\n- $B_{G,\\max} = 3$.\n- $c_{\\mathrm{A,bio}} = 1.2$.\n- $c_{\\mathrm{A,X}} = 1.0$.\n\nAngle units do not apply. Physical units: report growth rates in $\\mathrm{h^{-1}}$ as floating-point numbers.\n\nTest suite:\nEach test case is a triple $(w, G_{\\max}, X_{\\max})$. For each case, compute and output the pair $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$, where $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$, both rounded to $6$ decimal places, and interpreted in $\\mathrm{h^{-1}}$.\n\n- Case $1$: $(w, G_{\\max}, X_{\\max}) = (0.25, 10, 7)$.\n- Case $2$: $(w, G_{\\max}, X_{\\max}) = (1.0, 10, 10)$.\n- Case $3$: $(w, G_{\\max}, X_{\\max}) = (0.0, 10, 10)$.\n- Case $4$: $(w, G_{\\max}, X_{\\max}) = (0.7, 10, 10)$.\n- Case $5$: $(w, G_{\\max}, X_{\\max}) = (0.6, 5, 10)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$ corresponding to the test cases above, in order. For example: $[[x_{1},y_{1}],[x_{2},y_{2}],\\dots]$. There must be no spaces anywhere in the output. All reported growth rates must be rounded to $6$ decimal places and are to be interpreted in $\\mathrm{h^{-1}}$.", "solution": "The problem as stated is valid. It presents a well-posed optimization problem grounded in the established principles of Flux Balance Analysis (FBA) for metabolic networks. The problem is self-contained, with all necessary parameters, variables, and constraints clearly defined, permitting a rigorous mathematical formulation without ambiguity. The objective is to find Pareto-optimal states of a synthetic microbial consortium, which is a standard and meaningful goal in systems and synthetic biology. The problem is structured as a Linear Program (LP), for which a unique optimal value is guaranteed to exist.\n\nThe core of the task is to construct and solve this LP. The system involves two organisms, A and B, and two metabolites, a primary substrate $G$ and a cross-fed intermediate $X$. The state of the system is described by a set of $8$ non-negative fluxes: $v_{\\mathrm{A,inG}}$, $\\mu_{\\mathrm{A}}$, $v_{\\mathrm{A,prodX}}$, $v_{\\mathrm{A,outX}}$, $v_{\\mathrm{B,inG}}$, $v_{\\mathrm{B,inX}}$, $\\mu_{\\mathrm{B,G}}$, and $\\mu_{\\mathrm{B,X}}$.\n\nFirst, we simplify the system by resolving the equality constraints. The problem statement provides five linear equality constraints representing steady-state mass balances:\n$1$. $v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$\n$2$. $v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$\n$3$. $v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$\n$4$. $v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$\n$5$. $v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$\n\nFrom constraints $2$, $4$, and $5$, we deduce that the flux of metabolite $X$ from production in A to consumption in B is a single, unified channel:\n$$v_{X} \\equiv v_{\\mathrm{A,prodX}} = v_{\\mathrm{A,outX}} = v_{\\mathrm{B,inX}} = \\mu_{\\mathrm{B,X}}$$\nFrom constraint $3$, the biomass production of organism B from substrate $G$ is equal to its import flux of $G$:\n$$\\mu_{\\mathrm{B,G}} = v_{\\mathrm{B,inG}}$$\nUsing these relationships, we can eliminate most of the variables. We select a minimal set of three independent decision variables:\n- $\\mu_{\\mathrm{A}}$: The growth rate of organism A.\n- $\\mu_{\\mathrm{B,G}}$: The component of organism B's growth rate derived from substrate $G$.\n- $v_{X}$: The flux of the cross-fed metabolite $X$, which is also equal to the component of organism B's growth rate derived from $X$, $\\mu_{\\mathrm{B,X}}$.\n\nAll other flux variables can now be expressed in terms of this new basis:\n- $v_{\\mathrm{A,inG}} = c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} + c_{\\mathrm{A,X}} \\, v_{X} = 1.2 \\, \\mu_{\\mathrm{A}} + 1.0 \\, v_{X}$\n- $v_{\\mathrm{B,inG}} = \\mu_{\\mathrm{B,G}}$\n- $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}} = \\mu_{\\mathrm{B,G}} + v_{X}$\n\nThe problem is now formulated as a Linear Program with these three variables. The objective is to maximize the weighted sum of growth rates:\n$$\\text{Maximize} \\quad J = w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}} = w \\, \\mu_{\\mathrm{A}} + (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\nsubject to a set of linear inequality constraints arising from the flux bounds and shared resource limits. All variables must be non-negative: $\\mu_{\\mathrm{A}} \\ge 0$, $\\mu_{\\mathrm{B,G}} \\ge 0$, $v_{X} \\ge 0$.\n\nThe inequality constraints are:\n$1$. A's glucose import limit: $v_{\\mathrm{A,inG}} \\le A_{G,\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} \\le 10$\n$2$. B's glucose import limit: $v_{\\mathrm{B,inG}} \\le B_{G,\\max} \\implies \\mu_{\\mathrm{B,G}} \\le 3$\n$3$. Metabolite $X$ exchange limit: $v_{X} \\le X_{\\max}$\n$4$. Shared glucose availability: $v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} + \\mu_{\\mathrm{B,G}} \\le G_{\\max}$\n\nThis constitutes a standard LP problem of the form: maximize $c^T x$ subject to $A_{ub} x \\le b_{ub}$ and $x \\ge 0$. Here, the decision variable vector is $x = [\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B,G}}, v_{X}]^T$. The objective vector is $c = [w, 1-w, 1-w]^T$. The constraint matrix $A_{ub}$ and vector $b_{ub}$ are:\n$$\nA_{ub} = \\begin{pmatrix} 1.2  0  1.0 \\\\ 0  1.0  0 \\\\ 0  0  1.0 \\\\ 1.2  1.0  1.0 \\end{pmatrix}, \\quad\nb_{ub} = \\begin{pmatrix} 10 \\\\ 3 \\\\ X_{\\max} \\\\ G_{\\max} \\end{pmatrix}\n$$\nThe scientific libraries in Python, specifically `scipy.optimize.linprog`, are designed to solve minimization problems. Therefore, we solve the equivalent problem of minimizing $-J$:\n$$\\text{Minimize} \\quad -J = -w \\, \\mu_{\\mathrm{A}} - (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\nThe cost vector for the solver is $c_{min} = [-w, -(1-w), -(1-w)]^T$.\n\nA deeper analysis reveals a critical weight, $w_{crit}$, that dictates the qualitative behavior of the consortium. The metabolic trade-off between the growth of A and B is governed by their respective efficiencies in converting the shared substrate $G$ into biomass. For organism B, $1$ unit of $G$ generates $1$ unit of biomass (either as $\\mu_{\\mathrm{B,G}}$ or via $v_X$ which becomes $\\mu_{\\mathrm{B,X}}$). For organism A, $1$ unit of $G$ generates $1/c_{\\mathrm{A,bio}} = 1/1.2$ units of biomass. The change in the objective function $dJ$ for a differential trade-off between $\\mu_{\\mathrm{A}}$ and $\\mu_{\\mathrm{B}}$ is $dJ = (1-w - w/c_{\\mathrm{A,bio}})d\\mu_{\\mathrm{B}}$. The consortium will favor B's growth if the coefficient is positive, which occurs when $1-w  w/c_{\\mathrm{A,bio}}$, simplifying to $w  c_{\\mathrm{A,bio}} / (1+c_{\\mathrm{A,bio}})$.\nWith $c_{\\mathrm{A,bio}}=1.2$, the critical weight is $w_{crit} = 1.2 / 2.2 = 6/11 \\approx 0.545$.\n- If $w  w_{crit}$, the system maximizes A's growth, setting $\\mu_{\\mathrm{B}}=0$.\n- If $w  w_{crit}$, the system maximizes B's growth by allocating resources to $\\mu_{\\mathrm{B,G}}$ and $v_X$ up to their applicable limits.\nThis analytical insight confirms the solutions found by the LP solver for the given test cases. The implementation will proceed by constructing and solving the LP for each set of parameters in the test suite.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of joint flux balance analysis problems for a synthetic microbial consortium.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (w, G_max, X_max).\n    test_cases = [\n        (0.25, 10, 7),\n        (1.0, 10, 10),\n        (0.0, 10, 10),\n        (0.7, 10, 10),\n        (0.6, 5, 10),\n    ]\n\n    # Fixed parameters for all test cases\n    A_G_max = 10.0\n    B_G_max = 3.0\n    c_A_bio = 1.2\n    c_A_X = 1.0\n\n    results = []\n\n    # The problem is formulated as a Linear Program (LP).\n    # Decision variables x = [mu_A, mu_B,G, v_X]\n    # where mu_A is A's growth rate, mu_B,G is B's growth from substrate G,\n    # and v_X is the cross-feeding flux, equal to B's growth from metabolite X.\n\n    # Constraints: A_ub * x = b_ub\n    # 1. v_A,inG = A_G,max  => c_A_bio*mu_A + c_A_X*v_X = A_G_max\n    # 2. v_B,inG = B_G,max  => mu_B,G = B_G_max\n    # 3. v_X = X_max\n    # 4. v_A,inG + v_B,inG = G_max => c_A_bio*mu_A + mu_B,G + c_A_X*v_X = G_max\n    \n    A_ub = np.array([\n        [c_A_bio, 0.0,     c_A_X],\n        [0.0,     1.0,     0.0  ],\n        [0.0,     0.0,     1.0  ],\n        [c_A_bio, 1.0,     c_A_X]\n    ])\n    \n    for w, G_max, X_max in test_cases:\n        # Objective function to maximize: w*mu_A + (1-w)*(mu_B,G + v_X)\n        # scipy.optimize.linprog minimizes, so we minimize the negative of the objective.\n        c = np.array([-w, -(1 - w), -(1 - w)])\n\n        # Right-hand side of the inequality constraints\n        b_ub = np.array([A_G_max, B_G_max, X_max, G_max])\n        \n        # All variables are non-negative, which is the default for linprog.\n        # So bounds are (0, None) for all variables.\n        \n        # Solve the LP problem\n        res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, method='highs')\n\n        if res.success:\n            mu_A_opt = res.x[0]\n            mu_BG_opt = res.x[1]\n            v_X_opt = res.x[2]\n            \n            # Total growth rate of organism B\n            mu_B_opt = mu_BG_opt + v_X_opt\n            \n            # Append the formatted result\n            results.append(f\"[{mu_A_opt:.6f},{mu_B_opt:.6f}]\")\n        else:\n            # This should not happen for this well-posed problem\n            results.append(\"[error,error]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2728301"}, {"introduction": "Real-world biological parameters are rarely known with perfect precision, a challenge that any robust design must overcome. This exercise moves beyond deterministic prediction to address parameter uncertainty directly using the principles of interval analysis. You will apply the theory of monotone systems and M-matrices to a model of consortium dynamics to compute guaranteed, component-wise bounds on steady-state species abundances. This practice provides a powerful method for assessing the stability and potential composition of a consortium under a realistic range of conditions.", "problem": "A synthetic microbial consortium in a well-mixed environment can often be approximated at intermediate densities by a linearized birth–death balance that includes basal input and pairwise cross-feeding. Consider a consortium of $n$ species with nonnegative abundances $x_i \\ge 0$ for $i \\in \\{1,\\dots,n\\}$. The dynamics for species $i$ are modeled by the Ordinary Differential Equation (ODE) $dx_i/dt = r_i - \\delta_i x_i + \\sum_{j=1}^n \\gamma_{ij} x_j$, where $r_i \\ge 0$ is a basal input term (for example, nutrient-supplied effective growth scaled to population units), $\\delta_i \\gt 0$ is a loss rate (for example, dilution), and $\\gamma_{ij} \\ge 0$ encodes per-capita cross-feeding benefits received by species $i$ from species $j$. This ODE is a linearization of mass balance: steady state is defined by $dx_i/dt = 0$.\n\nParameters are uncertain but lie in known closed intervals: $r_i \\in [\\underline{r}_i,\\overline{r}_i]$, $\\delta_i \\in [\\underline{\\delta}_i,\\overline{\\delta}_i]$, and $\\gamma_{ij} \\in [\\underline{\\gamma}_{ij},\\overline{\\gamma}_{ij}]$ with $\\underline{r}_i \\ge 0$, $\\underline{\\delta}_i \\gt 0$, and $\\underline{\\gamma}_{ij} \\ge 0$. Assume that for every admissible choice of $(\\delta,\\Gamma)$ in these intervals, the matrix $M(\\delta,\\Gamma) := \\mathrm{diag}(\\delta_1,\\dots,\\delta_n) - \\Gamma$ is strictly diagonally dominant by rows, hence nonsingular, and is a Z-matrix with nonpositive off-diagonal entries. Under these assumptions, $M(\\delta,\\Gamma)$ is a nonsingular M-matrix, and the unique steady state for a given $(r,\\delta,\\Gamma)$ is the nonnegative vector $x^\\star(r,\\delta,\\Gamma)$ satisfying $M(\\delta,\\Gamma)\\,x^\\star = r$.\n\nTask: Use interval analysis grounded in first principles to derive componentwise bounds on the steady-state abundances that hold for all parameters in the given intervals. Your derivation must start from the definitions above, use only generally accepted facts about nonsingular M-matrices and monotone comparative statics, and avoid any shortcut formulas. Then, implement the resulting algorithm to compute bounds for the following test suite. All quantities are dimensionless. For each test case, report the componentwise lower and upper bounds as floats rounded to $6$ decimal places.\n\nTest Suite:\n\n- Test Case $1$ ($n=2$):\n  - $\\underline{r} = [\\,0.8,\\,0.9\\,]$, $\\overline{r} = [\\,1.0,\\,1.1\\,]$.\n  - $\\underline{\\delta} = [\\,1.2,\\,1.1\\,]$, $\\overline{\\delta} = [\\,1.5,\\,1.4\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0  0.05 \\\\ 0.03  0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0  0.10 \\\\ 0.08  0.0 \\end{bmatrix}$.\n\n- Test Case $2$ ($n=3$):\n  - $\\underline{r} = [\\,0.5,\\,0.4,\\,0.6\\,]$, $\\overline{r} = [\\,0.9,\\,0.7,\\,1.0\\,]$.\n  - $\\underline{\\delta} = [\\,1.4,\\,1.3,\\,1.5\\,]$, $\\overline{\\delta} = [\\,1.8,\\,1.7,\\,1.9\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0  0.02  0.00 \\\\ 0.01  0.0  0.03 \\\\ 0.02  0.01  0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0  0.06  0.05 \\\\ 0.04  0.0  0.07 \\\\ 0.05  0.03  0.0 \\end{bmatrix}$.\n\n- Test Case $3$ ($n=2$, near-diagonal-dominance edge):\n  - $\\underline{r} = [\\,0.05,\\,0.05\\,]$, $\\overline{r} = [\\,0.06,\\,0.06\\,]$.\n  - $\\underline{\\delta} = [\\,0.12,\\,0.12\\,]$, $\\overline{\\delta} = [\\,0.13,\\,0.13\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0  0.049 \\\\ 0.049  0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0  0.050 \\\\ 0.050  0.0 \\end{bmatrix}$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case yields a list that concatenates species-wise lower and upper bounds in order $[\\,\\underline{x}_1,\\overline{x}_1,\\underline{x}_2,\\overline{x}_2,\\dots,\\underline{x}_n,\\overline{x}_n\\,]$. Aggregate these per-test-case lists into an outer list. For example, the printed structure must look like $[\\,[\\,\\cdots\\,],\\,[\\,\\cdots\\,],\\,[\\,\\cdots\\,]\\,]$ with all numbers rounded to $6$ decimal places.", "solution": "The problem presented is a well-posed question in the domain of dynamical systems and control theory, specifically concerning the stability and steady-state analysis of biological networks. It is scientifically grounded in the theory of Lotka-Volterra systems and M-matrices, which have canonical applications in mathematical biology. The problem is self-contained, with all necessary parameters and assumptions clearly stated. The assumptions, particularly that of strict diagonal dominance, are verifiable for the given test data and ensure the existence and uniqueness of a non-negative steady state. The problem is valid and permits a rigorous solution.\n\nWe are tasked with finding component-wise bounds on the steady-state abundance vector $x^{\\star}$ for a system of interacting species, described by the set of ordinary differential equations:\n$$\n\\frac{dx_i}{dt} = r_i - \\delta_i x_i + \\sum_{j=1}^n \\gamma_{ij} x_j\n$$\nThe parameters $r_i$, $\\delta_i$, and $\\gamma_{ij}$ are uncertain and known only to lie within specified closed intervals: $r_i \\in [\\underline{r}_i, \\overline{r}_i]$, $\\delta_i \\in [\\underline{\\delta}_i, \\overline{\\delta}_i]$, and $\\gamma_{ij} \\in [\\underline{\\gamma}_{ij}, \\overline{\\gamma}_{ij}]$.\n\nAt steady state, $\\frac{dx_i}{dt} = 0$, which yields the linear system:\n$$\n\\delta_i x_i^{\\star} - \\sum_{j=1}^n \\gamma_{ij} x_j^{\\star} = r_i \\quad \\text{for } i = 1, \\dots, n\n$$\nThis can be expressed in matrix form as $M x^{\\star} = r$, where $x^{\\star}$ and $r$ are column vectors with components $x_i^{\\star}$ and $r_i$, respectively. The matrix $M$ is defined by its entries:\n$$\nM_{ij} = \\begin{cases} \\delta_i - \\gamma_{ii}  \\text{if } i=j \\\\ -\\gamma_{ij}  \\text{if } i \\ne j \\end{cases}\n$$\nGiven that the problem specifies $\\gamma_{ii}=0$ (no self-benefit), the matrix simplifies to $M = \\mathrm{diag}(\\delta_1, \\dots, \\delta_n) - \\Gamma$, where $\\Gamma$ is the matrix with entries $\\gamma_{ij}$.\n\nThe problem states that for any admissible choice of parameters $(\\delta, \\Gamma)$, the matrix $M(\\delta, \\Gamma)$ is a nonsingular M-matrix. This is a critical property. A fundamental theorem of M-matrices states that a Z-matrix (a matrix with non-positive off-diagonal entries) is a nonsingular M-matrix if and only if its inverse exists and is element-wise non-negative. That is, if $M$ is a nonsingular M-matrix, then $M^{-1}$ exists and $(M^{-1})_{ij} \\ge 0$ for all $i,j$.\n\nThe steady-state solution is given by $x^{\\star} = M^{-1} r$. Our goal is to determine the tightest component-wise bounds, $\\underline{x}$ and $\\overline{x}$, such that $\\underline{x} \\le x^{\\star} \\le \\overline{x}$ for all possible parameters.\n\nLet us analyze the dependence of $x^{\\star}$ on the parameters using first principles, as required.\n\n1.  **Dependence on the input vector $r$**:\n    The $i$-th component of the solution is $x_i^{\\star} = \\sum_{j=1}^n (M^{-1})_{ij} r_j$. The partial derivative of $x_i^{\\star}$ with respect to a component $r_k$ is:\n    $$\n    \\frac{\\partial x_i^{\\star}}{\\partial r_k} = (M^{-1})_{ik}\n    $$\n    Since $M^{-1}$ is element-wise non-negative, $\\frac{\\partial x_i^{\\star}}{\\partial r_k} \\ge 0$. This demonstrates that each component of the steady-state vector $x^{\\star}$ is a monotonically non-decreasing function of each component of the input vector $r$. Consequently, to find the upper bound $\\overline{x}_i$, we must use the maximal input vector, $\\overline{r}$. To find the lower bound $\\underline{x}_i$, we must use the minimal input vector, $\\underline{r}$.\n\n2.  **Dependence on the system matrix $M$**:\n    We invoke a key result from the theory of monotone operators, which applies to M-matrices. If $M_A$ and $M_B$ are two nonsingular M-matrices of the same dimension such that $M_A \\le M_B$ (element-wise inequality), then their inverses are ordered in the reverse direction: $M_B^{-1} \\le M_A^{-1}$.\n\n    Let us define two \"extreme\" matrices based on the parameter intervals. Any matrix $M(\\delta, \\Gamma)$ in our set has entries $M_{ii} = \\delta_i$ and $M_{ij} = -\\gamma_{ij}$ for $i \\ne j$.\n    - To construct the smallest possible matrix, $\\underline{M}$, we must choose the smallest possible diagonal entries and the smallest possible (most negative) off-diagonal entries. This corresponds to choosing $\\delta_i = \\underline{\\delta}_i$ and $\\gamma_{ij} = \\overline{\\gamma}_{ij}$. Thus, $\\underline{M} = \\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}$.\n    - To construct the largest possible matrix, $\\overline{M}$, we must choose the largest possible diagonal entries and the largest possible (least negative) off-diagonal entries. This corresponds to choosing $\\delta_i = \\overline{\\delta}_i$ and $\\gamma_{ij} = \\underline{\\gamma}_{ij}$. Thus, $\\overline{M} = \\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}$.\n\n    For any admissible choice of parameters $(\\delta, \\Gamma)$, it is clear that $\\underline{M} \\le M(\\delta, \\Gamma) \\le \\overline{M}$. By the comparative static property mentioned above, their inverses are ordered as:\n    $$\n    \\overline{M}^{-1} \\le M(\\delta, \\Gamma)^{-1} \\le \\underline{M}^{-1}\n    $$\n    All these inverse matrices are element-wise non-negative.\n\n3.  **Synthesis of Bounds**:\n    We combine these observations to determine the bounds on $x^{\\star} = M^{-1}r$.\n    - **Upper Bound $\\overline{x}$**: To maximize each component of $x^{\\star}$, we must maximize the corresponding entries of both $M^{-1}$ and $r$. From our analysis, this is achieved by selecting $\\underline{M}$ (which yields the largest inverse $\\underline{M}^{-1}$) and $\\overline{r}$. Since all entries of $\\underline{M}^{-1}$ and $\\overline{r}$ are non-negative, the product is maximized. The upper bound vector $\\overline{x}$ must therefore satisfy the relation:\n    $$\n    \\overline{x} = \\underline{M}^{-1} \\overline{r} \\quad \\implies \\quad (\\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}) \\overline{x} = \\overline{r}\n    $$\n    - **Lower Bound $\\underline{x}$**: To minimize each component of $x^{\\star}$, we must minimize the corresponding entries of both $M^{-1}$ and $r$. This is achieved by selecting $\\overline{M}$ (which yields the smallest inverse $\\overline{M}^{-1}$) and $\\underline{r}$. The lower bound vector $\\underline{x}$ must therefore satisfy:\n    $$\n    \\underline{x} = \\overline{M}^{-1} \\underline{r} \\quad \\implies \\quad (\\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}) \\underline{x} = \\underline{r}\n    $$\n\nThis derivation, grounded in the fundamental properties of M-matrices, provides a direct and rigorous algorithm. To compute the bounds, we simply need to construct the two extreme matrices $\\underline{M}$ and $\\overline{M}$ and solve two corresponding systems of linear equations. This approach avoids any enumeration or optimization over the parameter space and is computationally efficient.\n\nThe algorithm is as follows:\n1.  From the given intervals, construct the vectors $\\underline{r}, \\overline{r}, \\underline{\\delta}, \\overline{\\delta}$ and the matrices $\\underline{\\Gamma}, \\overline{\\Gamma}$.\n2.  Construct the matrix for the upper bound calculation: $\\underline{M} = \\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}$.\n3.  Solve the linear system $\\underline{M} \\overline{x} = \\overline{r}$ to obtain the upper bound vector $\\overline{x}$.\n4.  Construct the matrix for the lower bound calculation: $\\overline{M} = \\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}$.\n5.  Solve the linear system $\\overline{M} \\underline{x} = \\underline{r}$ to obtain the lower bound vector $\\underline{x}$.\n6.  The final result for each species $i$ is the interval $[\\underline{x}_i, \\overline{x}_i]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the component-wise steady-state abundance bounds for a microbial\n    consortium model with interval parameters.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (n=2)\n        {\n            \"r_underline\": np.array([0.8, 0.9]),\n            \"r_overline\": np.array([1.0, 1.1]),\n            \"delta_underline\": np.array([1.2, 1.1]),\n            \"delta_overline\": np.array([1.5, 1.4]),\n            \"Gamma_underline\": np.array([[0.0, 0.05], [0.03, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.10], [0.08, 0.0]]),\n        },\n        # Test Case 2 (n=3)\n        {\n            \"r_underline\": np.array([0.5, 0.4, 0.6]),\n            \"r_overline\": np.array([0.9, 0.7, 1.0]),\n            \"delta_underline\": np.array([1.4, 1.3, 1.5]),\n            \"delta_overline\": np.array([1.8, 1.7, 1.9]),\n            \"Gamma_underline\": np.array([[0.0, 0.02, 0.00], [0.01, 0.0, 0.03], [0.02, 0.01, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.06, 0.05], [0.04, 0.0, 0.07], [0.05, 0.03, 0.0]]),\n        },\n        # Test Case 3 (n=2, near-diagonal-dominance edge)\n        {\n            \"r_underline\": np.array([0.05, 0.05]),\n            \"r_overline\": np.array([0.06, 0.06]),\n            \"delta_underline\": np.array([0.12, 0.12]),\n            \"delta_overline\": np.array([0.13, 0.13]),\n            \"Gamma_underline\": np.array([[0.0, 0.049], [0.049, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.050], [0.050, 0.0]]),\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        r_underline = params[\"r_underline\"]\n        r_overline = params[\"r_overline\"]\n        delta_underline = params[\"delta_underline\"]\n        delta_overline = params[\"delta_overline\"]\n        Gamma_underline = params[\"Gamma_underline\"]\n        Gamma_overline = params[\"Gamma_overline\"]\n\n        # Calculate the lower bound on abundances, x_underline.\n        # This requires solving M_overline * x_underline = r_underline,\n        # where M_overline = diag(delta_overline) - Gamma_underline.\n        M_overline = np.diag(delta_overline) - Gamma_underline\n        x_underline = np.linalg.solve(M_overline, r_underline)\n\n        # Calculate the upper bound on abundances, x_overline.\n        # This requires solving M_underline * x_overline = r_overline,\n        # where M_underline = diag(delta_underline) - Gamma_overline.\n        M_underline = np.diag(delta_underline) - Gamma_overline\n        x_overline = np.linalg.solve(M_underline, r_overline)\n        \n        # Format the result for the current test case.\n        # The required format is [x1_low, x1_high, x2_low, x2_high, ...].\n        case_result = []\n        for i in range(len(x_underline)):\n            case_result.append(round(x_underline[i], 6))\n            case_result.append(round(x_overline[i], 6))\n        \n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is what's needed for the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2728320"}, {"introduction": "The ultimate goal of synthetic biology is not just to analyze systems, but to design them for a specific purpose. This final practice introduces a sophisticated design paradigm using bilevel optimization, which elegantly captures the hierarchical nature of a community where individual members optimize their own fitness within constraints imposed by the collective. You will formulate and solve a problem that allocates resources to optimize a community-level objective, such as maximizing total productivity or ensuring stable coexistence. This exercise provides a computational framework for implementing top-down design principles in synthetic consortia.", "problem": "Design a computational formulation for a simplified bilevel optimization capturing individual-species growth maximization under community-level metabolite budgets in a synthetic microbial consortium. Start from the core principles of Flux Balance Analysis (FBA) and linear resource allocation, and derive a single-level optimization that is exactly equivalent to the original bilevel problem, without assuming any non-biological shortcuts. Implement a program that solves the derived optimization for a provided test suite and reports the requested scalar outputs.\n\nFoundational base and assumptions to use:\n- Each species experiences steady-state mass balance consistent with Flux Balance Analysis, with a single effective biomass reaction representing growth. For each species $i$, the growth rate is denoted by $\\mu_i$ measured in $\\mathrm{h}^{-1}$.\n- The community controls the allocation of two essential extracellular metabolites, denoted \"C\" and \"N\" (for instance, a carbon source and a nitrogen source), across species. Let $U_{C,i}$ and $U_{N,i}$ be the upper bounds on uptake fluxes allocated to species $i$, in $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, where $\\mathrm{gDW}$ stands for gram dry weight.\n- For each species $i$, linear stoichiometric yields $y_{C,i}$ and $y_{N,i}$ (in $\\mathrm{h}^{-1}$ per $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$) map allocated uptake capacities to an upper bound on achievable growth: the biomass production obeys $\\mu_i \\le y_{C,i} U_{C,i}$ and $\\mu_i \\le y_{N,i} U_{N,i}$ under optimal individual metabolism. This reflects the well-tested linearity of FBA under a single limiting substrate per constraint.\n- Community-level resource budgets impose $\\sum_i U_{C,i} \\le B_C$ and $\\sum_i U_{N,i} \\le B_N$, where $B_C$ and $B_N$ are the total community budgets for metabolites \"C\" and \"N\", in $\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n- Optional per-species uptake caps $U_{C,i} \\le \\overline{U}_{C,i}$ and $U_{N,i} \\le \\overline{U}_{N,i}$ may apply, with nonnegativity $U_{C,i} \\ge 0$, $U_{N,i} \\ge 0$, $\\mu_i \\ge 0$.\n\nBilevel structure to capture:\n- Lower level (individual species, executed independently for each $i$): Given allocations $U_{C,i}$ and $U_{N,i}$ from the community, the species chooses its internal fluxes to maximize $\\mu_i$ subject to linear steady-state constraints. In this simplified effective-yield abstraction, the optimal $\\mu_i$ is bounded by $\\mu_i \\le y_{C,i} U_{C,i}$ and $\\mu_i \\le y_{N,i} U_{N,i}$.\n- Upper level (community): Chooses allocations $\\{U_{C,i}, U_{N,i}\\}_i$ to optimize a community objective subject to budgets. Consider two canonical community objectives:\n  - Weighted total growth: maximize $F_{\\mathrm{sum}} = \\sum_i w_i \\mu_i$, with weights $w_i \\ge 0$ dimensionless.\n  - Egalitarian max-min growth: maximize $t$ subject to $t \\le \\mu_i$ for all $i$.\nBoth objectives should produce a scalar value in $\\mathrm{h}^{-1}$.\n\nTasks:\n- Derive, from the above foundations only, a single-level linear optimization that is equivalent to the bilevel problem for either community objective, by sound reasoning that does not skip necessary logical steps.\n- Implement a program that, for each test case below, constructs and solves the appropriate single-level optimization and outputs the scalar optimal objective value in $\\mathrm{h}^{-1}$.\n- You must solve using linear programming and adhere to numerical robustness and feasibility.\n\nAngle units are not applicable. Physical units are specified above; report final scalar objective values in $\\mathrm{h}^{-1}$ rounded to exactly six decimal places.\n\nTest suite to implement and solve:\n- Case A (weighted total growth, \"sum\"):\n  - Species count: $2$.\n  - Budgets: $B_C = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $B_N = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Yields: $y_{C} = [0.5, 1.0]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$, $y_{N} = [0.4, 0.8]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [10.0, 8.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $\\overline{U}_N = [10.0, 8.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Weights: $w = [1.0, 1.0]$.\n  - Output: optimal $F_{\\mathrm{sum}}$ in $\\mathrm{h}^{-1}$.\n- Case B (egalitarian max-min, \"egal\"):\n  - Species count: $2$.\n  - Budgets: $B_C = 4.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $B_N = 100.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Yields: $y_{C} = [1.0, 0.5]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$, $y_{N} = [1.0, 0.5]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $\\overline{U}_N = [1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Output: optimal egalitarian value $t$ in $\\mathrm{h}^{-1}$.\n- Case C (weighted total growth, \"sum\", nitrogen absent):\n  - Species count: $3$.\n  - Budgets: $B_C = 50.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $B_N = 0.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Yields: $y_{C} = [1.0, 0.7, 0.9]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$, $y_{N} = [1.0, 0.7, 0.9]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [1000.0, 1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $\\overline{U}_N = [1000.0, 1000.0, 1000.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Weights: $w = [1.0, 1.0, 1.0]$.\n  - Output: optimal $F_{\\mathrm{sum}}$ in $\\mathrm{h}^{-1}$.\n- Case D (weighted total growth, \"sum\", per-species cap dominates one species):\n  - Species count: $2$.\n  - Budgets: $B_C = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $B_N = 10.0\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Yields: $y_{C} = [2.0, 1.0]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$, $y_{N} = [2.0, 1.0]\\ \\mathrm{h}^{-1}\\ (\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1})^{-1}$.\n  - Per-species caps: $\\overline{U}_C = [2.0, 100.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$, $\\overline{U}_N = [2.0, 100.0]\\ \\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}$.\n  - Weights: $w = [1.0, 1.0]$.\n  - Output: optimal $F_{\\mathrm{sum}}$ in $\\mathrm{h}^{-1}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases A, B, C, and D, in that order, as a comma-separated list enclosed in square brackets, with each value rounded to exactly six decimal places and expressed in $\\mathrm{h}^{-1}$. For example, the output should look like: \"[x_A,x_B,x_C,x_D]\".", "solution": "The problem posed is a request to formulate and solve a bilevel optimization problem modeling resource allocation in a synthetic microbial consortium. A critical validation of the problem statement is the mandatory first step.\n\nThe problem is determined to be **valid**.\n1.  **Givens Extraction**: All necessary parameters, variables, and constraints are explicitly provided. These include the number of species, community-level resource budgets ($B_C$, $B_N$), species-specific yields ($y_{C,i}$, $y_{N,i}$), and per-species uptake caps ($\\overline{U}_{C,i}$, $\\overline{U}_{N,i}$), along with two distinct community objective functions.\n2.  **Scientific Grounding**: The formulation is a simplified but standard representation of metabolic interactions, based on the principles of Flux Balance Analysis (FBA). The assumptions of linear yields and resource budgets are common and valid abstractions for creating tractable models in systems and synthetic biology. The problem is scientifically sound.\n3.  **Well-Posedness and Objectivity**: The problem is expressed with mathematical precision. The objective functions are clearly defined, and the constraints form a convex, compact feasible set. The task of maximizing a linear function over such a set is a well-posed linear programming problem, which guarantees the existence of a unique optimal objective value. The problem is free of ambiguity or subjective claims.\n\nThe problem, being valid, may be solved. The core task is to convert the specified bilevel optimization problem into an equivalent single-level linear program (LP).\n\nThe bilevel structure consists of a lower level, where each species maximizes its own growth, and an upper level, where the community allocates resources to optimize a collective objective.\n\nFor each species $i$, the lower-level problem is to determine the maximal growth rate $\\mu_i$ given the allocated uptake flux capacities $U_{C,i}$ and $U_{N,i}$:\n$$\n\\begin{align*}\n\\mu_i^*(U_{C,i}, U_{N,i}) = \\max_{\\mu_i} \\quad  \\mu_i \\\\\n\\text{s.t.} \\quad  \\mu_i \\le y_{C,i} U_{C,i} \\\\\n \\mu_i \\le y_{N,i} U_{N,i} \\\\\n \\mu_i \\ge 0\n\\end{align*}\n$$\nThe solution to this elementary optimization is $\\mu_i^* = \\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$.\n\nThe upper-level problem is to choose the allocations $\\{U_{C,i}, U_{N,i}\\}_i$ to maximize a community objective which depends on the individual optimal growth rates $\\mu_i^*$. The decision variables are subject to community budget and individual uptake constraints.\nThe presence of the $\\min$ function in the objective, $\\text{Objective}(\\{\\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})\\}_i)$, renders the problem non-linear.\n\nTo convert this into a single-level LP, we incorporate the lower-level problem's structure directly into the upper-level problem. We introduce the growth rates $\\mu_i$ as decision variables in the main optimization and replace the equality $\\mu_i = \\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$ with the inequalities from the lower-level problem: $\\mu_i \\le y_{C,i} U_{C,i}$ and $\\mu_i \\le y_{N,i} U_{N,i}$. This substitution is valid because both specified community objectives (weighted sum and max-min) are monotonically increasing with respect to each $\\mu_i$. Consequently, any optimization seeking to maximize the community objective will inherently drive each $\\mu_i$ to its maximum feasible value, which is precisely $\\min(y_{C,i} U_{C,i}, y_{N,i} U_{N,i})$.\n\nThis reformulation yields a single-level problem with decision variables $\\{\\mu_i, U_{C,i}, U_{N,i}\\}_{i=1}^N$. We now specify the complete LP for each community objective.\n\n**Objective 1: Weighted Total Growth ($F_{\\mathrm{sum}} = \\sum_i w_i \\mu_i$)**\nThe objective is to maximize a linear combination of growth rates. The resulting single-level LP is:\n$$\n\\begin{align*}\n\\max_{\\{\\mu_i, U_{C,i}, U_{N,i}\\}_i} \\quad  \\sum_{i=1}^N w_i \\mu_i \\\\\n\\text{s.t.} \\quad  \\mu_i - y_{C,i} U_{C,i} \\le 0  \\forall i \\in \\{1, ..., N\\} \\\\\n \\mu_i - y_{N,i} U_{N,i} \\le 0  \\forall i \\in \\{1, ..., N\\} \\\\\n \\sum_{i=1}^N U_{C,i} \\le B_C \\\\\n \\sum_{i=1}^N U_{N,i} \\le B_N \\\\\n 0 \\le U_{C,i} \\le \\overline{U}_{C,i}  \\forall i \\in \\{1, ..., N\\} \\\\\n 0 \\le U_{N,i} \\le \\overline{U}_{N,i}  \\forall i \\in \\{1, ..., N\\} \\\\\n \\mu_i \\ge 0  \\forall i \\in \\{1, ..., N\\}\n\\end{align*}\n$$\nThis is a standard LP formulation. The decision variables are the growth rates $\\mu_i$, carbon uptake allocations $U_{C,i}$, and nitrogen uptake allocations $U_{N,i}$. The objective function and all constraints are linear with respect to these variables.\n\n**Objective 2: Egalitarian Max-Min Growth ($\\max t$ s.t. $t \\le \\mu_i$)**\nTo handle the max-min objective, we employ the standard epigraph reformulation. We introduce an auxiliary variable $t$, which represents the minimum growth rate in the community. The objective becomes maximizing $t$, subject to the additional constraints $t \\le \\mu_i$ for all species $i$.\n$$\n\\begin{align*}\n\\max_{\\{t, \\mu_i, U_{C,i}, U_{N,i}\\}_i} \\quad  t \\\\\n\\text{s.t.} \\quad  t - \\mu_i \\le 0  \\forall i \\in \\{1, ..., N\\} \\\\\n \\mu_i - y_{C,i} U_{C,i} \\le 0  \\forall i \\in \\{1, ..., N\\} \\\\\n \\mu_i - y_{N,i} U_{N,i} \\le 0  \\forall i \\in \\{1, ..., N\\} \\\\\n \\sum_{i=1}^N U_{C,i} \\le B_C \\\\\n \\sum_{i=1}^N U_{N,i} \\le B_N \\\\\n 0 \\le U_{C,i} \\le \\overline{U}_{C,i}  \\forall i \\in \\{1, ..., N\\} \\\\\n 0 \\le U_{N,i} \\le \\overline{U}_{N,i}  \\forall i \\in \\{1, ..., N\\} \\\\\n t \\ge 0, \\mu_i \\ge 0  \\forall i \\in \\{1, ..., N\\}\n\\end{align*}\n$$\nThis is also a standard LP formulation. The decision variables now include the minimum growth rate $t$. The objective and all constraints remain linear.\n\nThese derived single-level LPs are equivalent to the original bilevel problem and can be solved using standard numerical solvers. A program will be implemented to construct and solve these LPs for the provided test suite. The implementation will use `scipy.optimize.linprog`, which solves minimization problems. Maximization of a function $f(x)$ is achieved by minimizing $-f(x)$. The final reported objective value will be the rescaled result from the solver.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_community_lp(\n    num_species, \n    budget_c, \n    budget_n, \n    yield_c, \n    yield_n, \n    uptake_cap_c, \n    uptake_cap_n, \n    obj_type, \n    weights=None\n):\n    \"\"\"\n    Constructs and solves a linear program for resource allocation in a microbial community.\n\n    Args:\n        num_species (int): Number of species in the consortium (N).\n        budget_c (float): Total community budget for metabolite C.\n        budget_n (float): Total community budget for metabolite N.\n        yield_c (list or np.ndarray): Yields for metabolite C for each species.\n        yield_n (list or np.ndarray): Yields for metabolite N for each species.\n        uptake_cap_c (list or np.ndarray): Per-species uptake caps for C.\n        uptake_cap_n (list or np.ndarray): Per-species uptake caps for N.\n        obj_type (str): The community objective ('sum' or 'egal').\n        weights (list or np.ndarray): Weights for the 'sum' objective.\n\n    Returns:\n        float: The optimal value of the community objective function.\n    \"\"\"\n    N = num_species\n\n    if obj_type == \"sum\":\n        # Variables are ordered as [mu_1,...,mu_N, Uc_1,...,Uc_N, Un_1,...,Un_N]\n        num_vars = 3 * N\n        \n        # Objective: maximize sum(w_i * mu_i), which is equivalent to\n        # minimizing -sum(w_i * mu_i).\n        c = np.zeros(num_vars)\n        c[:N] = -np.array(weights)\n\n        # Inequality constraints: A_ub @ x = b_ub\n        num_constraints = 2 * N + 2\n        A_ub = np.zeros((num_constraints, num_vars))\n        b_ub = np.zeros(num_constraints)\n\n        # Constraints: mu_i - y_ci * Uc_i = 0\n        for i in range(N):\n            A_ub[i, i] = 1        # mu_i term\n            A_ub[i, N + i] = -yield_c[i] # Uc_i term\n        \n        # Constraints: mu_i - y_ni * Un_i = 0\n        for i in range(N):\n            A_ub[N + i, i] = 1        # mu_i term\n            A_ub[N + i, 2 * N + i] = -yield_n[i] # Un_i term\n\n        # Budget constraint: sum(Uc_i) = budget_c\n        A_ub[2 * N, N:2 * N] = 1\n        b_ub[2 * N] = budget_c\n        \n        # Budget constraint: sum(Un_i) = budget_n\n        A_ub[2 * N + 1, 2 * N:3 * N] = 1\n        b_ub[2 * N + 1] = budget_n\n\n        # Variable bounds\n        bounds = []\n        bounds.extend([(0, None)] * N)  # mu_i >= 0\n        bounds.extend([(0, uc) for uc in uptake_cap_c])\n        bounds.extend([(0, un) for un in uptake_cap_n])\n\n    elif obj_type == \"egal\":\n        # Variables: [mu_1,...,mu_N, Uc_1,...,Uc_N, Un_1,...,Un_N, t]\n        num_vars = 3 * N + 1\n        \n        # Objective: maximize t, which is equivalent to minimizing -t.\n        c = np.zeros(num_vars)\n        c[-1] = -1\n\n        # Inequality constraints\n        num_constraints = 3 * N + 2\n        A_ub = np.zeros((num_constraints, num_vars))\n        b_ub = np.zeros(num_constraints)\n        \n        # Constraints: t - mu_i = 0\n        for i in range(N):\n            A_ub[i, i] = -1       # mu_i term\n            A_ub[i, 3 * N] = 1    # t term\n            \n        # Constraints: mu_i - y_ci * Uc_i = 0\n        for i in range(N):\n            A_ub[N + i, i] = 1\n            A_ub[N + i, N + i] = -yield_c[i]\n            \n        # Constraints: mu_i - y_ni * Un_i = 0\n        for i in range(N):\n            A_ub[2 * N + i, i] = 1\n            A_ub[2 * N + i, 2 * N + i] = -yield_n[i]\n            \n        # Budget constraint: sum(Uc_i) = budget_c\n        A_ub[3 * N, N:2 * N] = 1\n        b_ub[3 * N] = budget_c\n        \n        # Budget constraint: sum(Un_i) = budget_n\n        A_ub[3 * N + 1, 2 * N:3 * N] = 1\n        b_ub[3 * N + 1] = budget_n\n        \n        # Variable bounds\n        bounds = []\n        bounds.extend([(0, None)] * N)\n        bounds.extend([(0, uc) for uc in uptake_cap_c])\n        bounds.extend([(0, un) for un in uptake_cap_n])\n        bounds.append((0, None))  # t >= 0\n    \n    else:\n        raise ValueError(\"Invalid objective type specified.\")\n\n    # Solve the LP\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        # res.fun is the minimum of the objective, which is -max_value\n        return -res.fun\n    else:\n        # Return NaN or raise an error if the optimization fails\n        return np.nan\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (weighted total growth, \"sum\")\n        {\n            \"num_species\": 2, \"budget_c\": 10.0, \"budget_n\": 10.0,\n            \"yield_c\": [0.5, 1.0], \"yield_n\": [0.4, 0.8],\n            \"uptake_cap_c\": [10.0, 8.0], \"uptake_cap_n\": [10.0, 8.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0]\n        },\n        # Case B (egalitarian max-min, \"egal\")\n        {\n            \"num_species\": 2, \"budget_c\": 4.0, \"budget_n\": 100.0,\n            \"yield_c\": [1.0, 0.5], \"yield_n\": [1.0, 0.5],\n            \"uptake_cap_c\": [1000.0, 1000.0], \"uptake_cap_n\": [1000.0, 1000.0],\n            \"obj_type\": \"egal\"\n        },\n        # Case C (weighted total growth, \"sum\", nitrogen absent)\n        {\n            \"num_species\": 3, \"budget_c\": 50.0, \"budget_n\": 0.0,\n            \"yield_c\": [1.0, 0.7, 0.9], \"yield_n\": [1.0, 0.7, 0.9],\n            \"uptake_cap_c\": [1000.0, 1000.0, 1000.0], \"uptake_cap_n\": [1000.0, 1000.0, 1000.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0, 1.0]\n        },\n        # Case D (weighted total growth, \"sum\", per-species cap dominates)\n        {\n            \"num_species\": 2, \"budget_c\": 10.0, \"budget_n\": 10.0,\n            \"yield_c\": [2.0, 1.0], \"yield_n\": [2.0, 1.0],\n            \"uptake_cap_c\": [2.0, 100.0], \"uptake_cap_n\": [2.0, 100.0],\n            \"obj_type\": \"sum\", \"weights\": [1.0, 1.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_community_lp(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2728354"}]}