{"hands_on_practices": [{"introduction": "The long-term stability of any engineered function is fundamentally constrained by its fitness landscape—the vast network of possible mutations and their effects on performance. This exercise uses the classic N–K model to explore this concept computationally [@problem_id:2738940]. By building these landscapes and counting the number of viable mutational paths, you will gain a quantitative understanding of how epistasis (the interaction between genetic parts, represented by $K$) shapes evolutionary trajectories and determines whether an engineered function is robust or fragile in the face of mutation.", "problem": "You are asked to formalize and compute the accessibility of mutational paths that preserve an engineered function’s activity under selection on a randomized N–K fitness landscape, where $N$ is the number of loci and $K$ is the number of epistatic partners per locus. The goal is to connect the ruggedness of the landscape (as $K$ increases) to the number of activity-preserving, selection-consistent mutational paths from a specified engineered starting genotype to the global fitness maximum.\n\nFundamental base:\n- The N–K fitness landscape model assigns to each genotype a fitness computed as the mean of $N$ local contributions, where each locus $i$ contributes a value that depends on the state of locus $i$ and $K$ epistatic partner loci. Each locus has an independent lookup table mapping its $(K+1)$-bit local configuration to a contribution value in the closed interval $[0,1]$. For a genotype $g \\in \\{0,1\\}^N$, its fitness $W(g)$ is the arithmetic mean of the $N$ contributions.\n- Under Darwinian selection, accessible mutational steps are those that do not decrease the selected trait. Here, to directly tie selection to engineered function, assume that the engineered function’s activity is proportional to the fitness $W(g)$ and that viability requires a minimum activity level $A$ (viability threshold), so only genotypes with $W(g) \\ge A$ are considered to preserve function. Selection-consistent paths enforce non-decreasing $W$ along the sequence of mutations.\n\nDefinitions you must implement precisely:\n1. Landscape construction. For given $N$ and $K$ with $0 \\le K \\le N-1$, for each locus $i \\in \\{0,\\dots,N-1\\}$:\n   - Choose $K$ distinct partner loci from $\\{0,\\dots,N-1\\}\\setminus\\{i\\}$ uniformly at random without replacement. The ordered interaction set for $i$ is defined as the list with $i$ first, followed by the partners in strictly increasing order.\n   - Draw a table of size $2^{K+1}$ of independent realizations from a continuous distribution on $[0,1]$ (use the uniform distribution on $[0,1]$) that maps every $(K+1)$-bit local configuration to a contribution in $[0,1]$.\n   - For a genotype $g$, the index for locus $i$’s table is computed by reading the bits of $g$ at the positions in the ordered interaction set for $i$ as a binary number with the first listed locus as the most significant bit. The fitness is $W(g)=\\frac{1}{N}\\sum_{i=0}^{N-1} c_i(g)$, where $c_i(g)$ is the table lookup for locus $i$ at $g$’s local configuration.\n\n2. Starting and target genotypes. Let the engineered starting genotype be $g_0=(0,0,\\dots,0) \\in \\{0,1\\}^N$. Let the target genotype $g^\\star$ be the unique genotype that maximizes the lexicographically ordered pair $(W(g), \\mathrm{index}(g))$, where $\\mathrm{index}(g)$ is the integer formed by interpreting $g$ as a binary number with bit $0$ as the least significant bit. That is, $g^\\star$ is the genotype of maximal fitness, with ties broken in favor of the larger binary index.\n\n3. Mutational path and accessibility under selection with activity preservation. A mutational path from $g_0$ to $g^\\star$ is a sequence of single-locus flips that transforms $g_0$ into $g^\\star$ by flipping each of the loci in which $g_0$ and $g^\\star$ differ exactly once, in some order, without back-mutations. Let $D=\\{i \\in \\{0,\\dots,N-1\\} : g_0[i]\\ne g^\\star[i]\\}$ and let $H=|D|$. The path thus has exactly $H$ steps.\n   - Activity preservation requires that every intermediate genotype $g$ on the path satisfies $W(g)\\ge A$, where $A\\in(0,1)$ is a fixed viability threshold.\n   - Selection consistency requires that along the path, the sequence of fitness values is non-decreasing under the following strict ordering to avoid ambiguity at ties: for two consecutive genotypes $g \\to g'$, the step is allowed if either $W(g')>W(g)$ or $W(g')=W(g)$ and $\\mathrm{index}(g')>\\mathrm{index}(g)$. This induces an acyclic direction on potential steps, ensuring well-defined counting of allowed paths.\n\n4. Accessibility metric. The accessibility of mutational paths that preserve activity under selection is defined as the count of distinct mutational paths from $g_0$ to $g^\\star$ that satisfy both the activity preservation and selection consistency conditions above. If $H=0$, the count is $1$ if $W(g_0)\\ge A$ and $0$ otherwise.\n\nYour task:\n- For each test case, construct the N–K landscape with the specified random seed, compute $g^\\star$, and then compute the accessibility count as defined above.\n- Use exact integer counts as outputs.\n\nTest suite:\nProvide results for the following parameter sets, each formatted as $(N,K,\\text{seed},A)$:\n- Case $1$: $(6,0,7,0.5)$.\n- Case $2$: $(6,5,7,0.5)$.\n- Case $3$: $(8,0,123,0.5)$.\n- Case $4$: $(8,3,123,0.5)$.\n- Case $5$: $(8,7,123,0.5)$.\n- Case $6$ (edge case with stringent viability): $(7,6,99,0.9)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $i$-th entry must be the accessibility count for Case $i$, in order from Case $1$ to Case $6$, for example, $[x_1,x_2,x_3,x_4,x_5,x_6]$ where each $x_i$ is an integer.", "solution": "The problem is validated as scientifically grounded, objective, and computationally tractable. It poses a well-defined task in computational evolutionary biology, specifically the analysis of mutational accessibility on a rugged fitness landscape. The N–K model is a canonical tool for such investigations. The problem statement is self-contained, with all parameters, conditions, and definitions specified unambiguously. The inclusion of a random seed and precise tie-breaking rules ensures a unique, reproducible solution.\n\nA solution is constructed through a systematic, principle-based algorithm comprising four main stages:\n1.  **Landscape Generation**: The N–K fitness landscape is constructed according to the specified parameters $(N, K)$ and a given random seed.\n2.  **Fitness Space Evaluation**: The fitness for every genotype in the space $\\{0,1\\}^N$ is computed and stored.\n3.  **Target Genotype Identification**: The globally optimal genotype $g^\\star$ is identified.\n4.  **Path Enumeration**: The number of accessible, activity-preserving mutational paths from the starting genotype $g_0$ to $g^\\star$ is counted using dynamic programming.\n\nEach stage is detailed below.\n\n**1. Landscape Generation**\nFor a given number of loci $N$ and epistasis level $K$, the landscape is defined by the fitness contributions of each locus. For each locus $i \\in \\{0, \\dots, N-1\\}$:\n-   A set of $K$ unique epistatic partners is chosen uniformly at random from the other $N-1$ loci. The ordered interaction set for locus $i$ is a list containing $i$ itself as the first element (most significant bit), followed by its $K$ partners sorted in increasing order.\n-   A contribution table, a vector of size $2^{K+1}$, is generated. Its entries are independent random variates drawn from a uniform distribution on $[0,1]$. This table maps each of the $2^{K+1}$ possible local genetic configurations for the interaction set to a fitness contribution.\nThe use of a fixed pseudo-random number generator seed ensures that this construction is deterministic and reproducible.\n\n**2. Fitness Space Evaluation**\nThe fitness of a genotype $g \\in \\{0,1\\}^N$ is defined as the arithmetic mean of the contributions from all $N$ loci:\n$$W(g) = \\frac{1}{N} \\sum_{i=0}^{N-1} c_i(g)$$\nwhere $c_i(g)$ is the contribution of locus $i$. To find $c_i(g)$, the states of the loci in the interaction set for $i$ are extracted from $g$. These $K+1$ bits are interpreted as a binary integer, which serves as the index into the contribution table for locus $i$. Given the small values of $N$ in the test suite (maximum of $8$), it is efficient to pre-compute and store the fitness values for all $2^N$ genotypes in an array, indexed by the integer representation of the genotypes.\n\n**3. Target Genotype Identification**\nThe target of evolution is the genotype $g^\\star$ that is globally optimal. According to the problem, $g^\\star$ is the unique genotype that maximizes the lexicographically ordered pair $(W(g), \\mathrm{index}(g))$. The term $\\mathrm{index}(g)$ denotes the integer value of the binary genotype string $g$, with the bit at position $0$ as the least significant bit. This tie-breaking rule ensures a unique target is always found. The pre-computed fitness array is scanned to identify this $g^\\star$.\n\n**4. Path Enumeration via Dynamic Programming**\nThe core of the problem is to count the number of valid mutational paths from the starting genotype $g_0 = (0, \\dots, 0)$ to the target $g^\\star$. A path is a sequence of single-bit flips, one for each locus where $g_0$ and $g^\\star$ differ. Let $D$ be the set of loci where $g_0$ and $g^\\star$ differ, and let $H = |D|$ be the Hamming distance. We are counting the number of permutations of these $H$ mutations that form a valid path.\n\nA path is valid if it meets two criteria at every step:\n-   **Activity Preservation**: For every intermediate genotype $g_{path}$ on the path, its fitness must be above or equal to the viability threshold, $W(g_{path}) \\ge A$.\n-   **Selection Consistency**: For each step $g \\to g'$, the fitness must not decrease. A strict ordering is imposed to handle fitness ties: the step is allowed if $W(g') > W(g)$, or if $W(g') = W(g)$ and $\\mathrm{index}(g') > \\mathrm{index}(g)$.\n\nThis path-counting problem is solved efficiently using dynamic programming. Let $dp(g)$ be the number of valid paths from $g_0$ to any genotype $g$ on the sub-hypercube spanned by $g_0$ and $g^\\star$.\n\n-   **Base Case**: The process starts at $g_0$. If $W(g_0) < A$, no path is possible, and the count is $0$. Otherwise, $dp(g_0) = 1$. For all other genotypes $g$, $dp(g)$ is initialized to $0$.\n\n-   **Recurrence Relation**: The number of paths to a genotype $g_{next}$ is the sum of the paths to all its valid immediate predecessors. The DP proceeds by iterating through genotypes in increasing order of their Hamming distance from $g_0$. For a genotype $g_{curr}$ at distance $d$, we consider all potential successor genotypes $g_{next}$ at distance $d+1$ (formed by flipping a single bit in $g_{curr}$ that belongs to the set $D$). If the step $g_{curr} \\to g_{next}$ is valid (satisfies both activity preservation and selection consistency), we update the path count for $g_{next}$:\n    $$dp(g_{next}) \\gets dp(g_{next}) + dp(g_{curr})$$\n\n-   **Final Result**: After iterating through all Hamming distances up to $H-1$, the value $dp(g^\\star)$ will hold the total number of valid mutational paths from $g_0$ to $g^\\star$. If $g_0 = g^\\star$ (i.e., $H=0$), the count is $1$ if $W(g_0) \\ge A$ and $0$ otherwise. This logic is implemented to compute the required accessibility metric for each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mutational path accessibility problem for the given test suite.\n    \"\"\"\n\n    class AccessibilityCalculator:\n        \"\"\"\n        Encapsulates the logic for solving one instance of the N-K landscape problem.\n        \"\"\"\n        def __init__(self, N, K, seed, A):\n            self.N = N\n            self.K = K\n            self.A = A\n            self.rng = np.random.default_rng(seed)\n            self.interaction_sets = {}\n            self.contribution_tables = {}\n            self.fitness_vals = np.zeros(2**self.N)\n\n        def _generate_landscape(self):\n            \"\"\"Constructs the N-K landscape: interaction sets and contribution tables.\"\"\"\n            all_loci = np.arange(self.N)\n            for i in range(self.N):\n                if self.K > 0:\n                    other_loci = np.delete(all_loci, i)\n                    partners = self.rng.choice(other_loci, size=self.K, replace=False)\n                    partners.sort()\n                    self.interaction_sets[i] = [i] + list(partners)\n                else:\n                    self.interaction_sets[i] = [i]\n                \n                table_size = 2**(self.K + 1)\n                self.contribution_tables[i] = self.rng.uniform(0.0, 1.0, size=table_size)\n\n        def _compute_all_fitnesses(self):\n            \"\"\"Pre-computes and stores the fitness for all 2^N genotypes.\"\"\"\n            num_genotypes = 2**self.N\n            for g_idx in range(num_genotypes):\n                total_contribution = 0.0\n                for i in range(self.N):\n                    interaction_set = self.interaction_sets[i]\n                    \n                    table_idx = 0\n                    for locus_pos in interaction_set:\n                        bit = (g_idx >> locus_pos) & 1\n                        table_idx = (table_idx << 1) | bit\n                    \n                    total_contribution += self.contribution_tables[i][table_idx]\n                \n                self.fitness_vals[g_idx] = total_contribution / self.N\n            \n        def _find_target_genotype(self):\n            \"\"\"Finds the target genotype g_star by maximizing (W(g), index(g)).\"\"\"\n            best_fitness = -1.0\n            g_star_idx = -1\n            \n            num_genotypes = 2**self.N\n            for g_idx in range(num_genotypes):\n                fitness = self.fitness_vals[g_idx]\n                if fitness > best_fitness:\n                    best_fitness = fitness\n                    g_star_idx = g_idx\n                elif fitness == best_fitness:\n                    if g_idx > g_star_idx:\n                        g_star_idx = g_idx\n            return g_star_idx\n\n        def compute_accessibility(self):\n            \"\"\"Calculates the number of accessible, activity-preserving paths.\"\"\"\n            self._generate_landscape()\n            self._compute_all_fitnesses()\n            \n            g0_idx = 0\n            g_star_idx = self._find_target_genotype()\n            \n            diff_mask = g0_idx ^ g_star_idx \n            diff_indices = [i for i in range(self.N) if (diff_mask >> i) & 1]\n            H = len(diff_indices)\n            \n            if H == 0:\n                return 1 if self.fitness_vals[g0_idx] >= self.A else 0\n                \n            if self.fitness_vals[g0_idx] < self.A:\n                return 0\n                \n            dp = np.zeros(2**self.N, dtype=np.int64)\n            dp[g0_idx] = 1\n            \n            genotypes_by_dist = [[] for _ in range(H + 1)]\n            for g_idx in range(2**self.N):\n                if (g_idx & ~diff_mask) == 0:\n                    dist = bin(g_idx).count('1')\n                    genotypes_by_dist[dist].append(g_idx)\n                    \n            for d in range(H):\n                for g_curr_idx in genotypes_by_dist[d]:\n                    if dp[g_curr_idx] == 0:\n                        continue\n                    \n                    f_curr = self.fitness_vals[g_curr_idx]\n                    \n                    for bit_to_flip in diff_indices:\n                        if not ((g_curr_idx >> bit_to_flip) & 1):\n                            g_next_idx = g_curr_idx | (1 << bit_to_flip)\n                            \n                            f_next = self.fitness_vals[g_next_idx]\n                            \n                            is_viable = (f_next >= self.A)\n                            is_selection_consistent = (f_next > f_curr) or \\\n                                                      (f_next == f_curr and g_next_idx > g_curr_idx)\n\n                            if is_viable and is_selection_consistent:\n                                dp[g_next_idx] += dp[g_curr_idx]\n\n            return dp[g_star_idx]\n\n    test_cases = [\n        (6, 0, 7, 0.5),\n        (6, 5, 7, 0.5),\n        (8, 0, 123, 0.5),\n        (8, 3, 123, 0.5),\n        (8, 7, 123, 0.5),\n        (7, 6, 99, 0.9),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, K, seed, A = params\n        calculator = AccessibilityCalculator(N, K, seed, A)\n        result = calculator.compute_accessibility()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2738940"}, {"introduction": "Many synthetic biology applications rely on engineered cells that secrete public goods, a strategy notoriously vulnerable to the rise of non-producing 'cheaters'. This exercise moves from abstract landscapes to a concrete biophysical model of this evolutionary arms race within a microbial microcolony [@problem_id:2738997]. By implementing a model that accounts for diffusion, cell density, and private versus shared benefits, you will calculate the 'cheater takeover time' and see firsthand how physical structure can create ecological niches that protect cooperative systems from collapse.", "problem": "Consider a clonal microcolony of engineered producer cells interspersed with cheater cells that do not produce a diffusible public-good molecule. The microcolony is approximated as a disk of radius $R$ (in $\\mu\\mathrm{m}$) and uniform areal cell density $\\rho$ (in cells $\\mu\\mathrm{m}^{-2}$). Each producer emits molecules at a rate $q$ (in molecule-units $\\mathrm{h}^{-1}$). Molecules experience three competing first-order hazards: (i) self-uptake by the emitting producer at rate $k_s$ (in $\\mathrm{h}^{-1}$), (ii) uptake by other cells in the neighborhood at a per-cell rate $k_u$ (in $\\mathrm{h}^{-1}$ per neighboring cell), and (iii) diffusive escape out of the colony at a size-dependent rate $k_e(R)$ (in $\\mathrm{h}^{-1}$). The interaction range is finite due to diffusion and decay, and is summarized by an effective diffusion length $L$ (in $\\mu\\mathrm{m}$), beyond which uptake is negligible. The escape rate scales with the colony’s surface-to-volume ratio as $k_e(R) = k_{e0}\\, (L/R)$, where $k_{e0}$ (in $\\mathrm{h}^{-1}$) is a constant prefactor. The effective number of neighbors within interaction range is given by\n$$\nN(R) = \\max\\!\\left(0,\\, \\rho\\, \\pi\\, \\min(R^2, L^2) - 1\\right).\n$$\nUnder these assumptions, the total competing hazard rate for a molecule emitted by a producer is\n$$\nH(R) = k_s + k_u\\, N(R) + k_{e0}\\, \\frac{L}{R}.\n$$\nFor a given emitted molecule, the probability of capture by the emitter is $k_s/H(R)$, while the probability of capture by any particular other cell is $k_u/H(R)$ (by symmetry of the per-cell uptake hazard). Let the translation from captured molecule-units to per-capita Malthusian growth-rate increment be $\\alpha$ (in $\\mathrm{h}^{-1}$ per molecule-unit $\\mathrm{h}^{-1}$). Producers pay a constant production cost $c$ (in $\\mathrm{h}^{-1}$). Let the per-capita Malthusian growth rates of producers and cheaters be $w_P$ and $w_C$, respectively. Assuming random mixing within the colony, and that uptake hazards are memoryless and additive, the difference in growth rates simplifies to\n$$\nw_C - w_P \\equiv \\Delta w(R) = c - \\alpha q\\, \\frac{k_s - k_u}{H(R)}.\n$$\nLet $x(t)$ be the fraction of producers at time $t$ (in $\\mathrm{h}$), evolving under frequency dynamics driven by the fitness difference according to the ordinary differential equation (ODE) $dx/dt = x(1 - x)(w_P - w_C) = -x(1 - x)\\, \\Delta w(R)$. Define the initial producer fraction $x_0 \\in (0,1)$ and a producer threshold $x_f \\in (0,1)$ that encodes cheater takeover at target cheater fraction $1 - x_f$. The time to cheater takeover, $T(R)$ (in $\\mathrm{h}$), is then\n$$\nT(R) =\n\\begin{cases}\n+\\infty, & \\text{if } \\Delta w(R) \\le 0,\\\\[6pt]\n\\displaystyle \\frac{1}{\\Delta w(R)} \\ln\\!\\left(\\frac{x_0 (1 - x_f)}{x_f (1 - x_0)}\\right), & \\text{if } \\Delta w(R) > 0.\n\\end{cases}\n$$\n\nUsing only the definitions and relationships above, implement a program that computes the cheater takeover time $T(R)$ for the following parameter set, which is scientifically plausible for bacterial microcolonies:\n\n- $\\rho = 0.01$ (cells $\\mu\\mathrm{m}^{-2}$),\n- $L = 30$ ($\\mu\\mathrm{m}$),\n- $k_s = 0.5$ ($\\mathrm{h}^{-1}$),\n- $k_u = 0.05$ ($\\mathrm{h}^{-1}$ per cell),\n- $k_{e0} = 0.02$ ($\\mathrm{h}^{-1}$),\n- $q = 100$ (molecule-units $\\mathrm{h}^{-1}$),\n- $\\alpha = 0.001$ ($\\mathrm{h}^{-1}$ per molecule-unit $\\mathrm{h}^{-1}$),\n- $c = 0.03$ ($\\mathrm{h}^{-1}$),\n- $x_0 = 0.99$,\n- $x_f = 0.1$.\n\nYour program must evaluate the test suite of microcolony radii\n$$\nR \\in \\{\\, 8,\\, 20,\\, 26,\\, 30,\\, 100 \\,\\}\\ \\text{in}\\ \\mu\\mathrm{m}.\n$$\nFor each test case, compute $T(R)$ in hours, rounded to three decimal places for finite values. If $\\Delta w(R) \\le 0$, output $+\\infty$. The final output format must be a single line containing a Python-style list of the five results in the same order as the test suite, for example $[t_1,t_2,t_3,t_4,t_5]$, where each $t_i$ is either a float or $+\\infty$ represented as the IEEE floating-point infinity. No other text should be printed.", "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, and self-contained. It presents a standard, albeit simplified, mathematical model from theoretical biology concerning the evolutionary dynamics of cooperation and cheating. All parameters, variables, and functional relationships are explicitly defined, permitting a direct and unambiguous calculation. We shall proceed with the solution.\n\nThe objective is to compute the cheater takeover time, $T(R)$, for a set of microcolony radii $R$. The computation follows a sequence of steps derived from the definitions provided in the problem statement.\n\nFirst, we must determine the effective number of neighbors, $N(R)$, for a cell within a colony of radius $R$. This is given by the formula:\n$$\nN(R) = \\max\\!\\left(0,\\, \\rho\\, \\pi\\, \\min(R^2, L^2) - 1\\right)\n$$\nHere, $\\rho$ is the areal cell density and $L$ is the effective diffusion length. This function accounts for the geometry of interaction, which is limited by either the colony size (for $R \\le L$) or the diffusion length (for $R > L$). The term '$-1$' subtracts the producer cell itself.\n\nSecond, we calculate the total competing hazard rate, $H(R)$, for a molecule emitted by a producer. This rate is the sum of the rates of three mutually exclusive events: self-uptake, uptake by neighbors, and diffusive escape. The formula is:\n$$\nH(R) = k_s + k_u\\, N(R) + k_{e0}\\, \\frac{L}{R}\n$$\nwhere $k_s$ is the self-uptake rate, $k_u$ is the per-cell uptake rate by neighbors, and $k_e(R) = k_{e0} (L/R)$ is the size-dependent escape rate.\n\nThird, we compute the difference in Malthusian growth rates between cheaters and producers, $\\Delta w(R)$. This quantity determines the direction and speed of selection. It is defined as:\n$$\n\\Delta w(R) = c - \\alpha q\\, \\frac{k_s - k_u}{H(R)}\n$$\nIn this expression, $c$ is the fixed cost of production. The second term represents the net private benefit to a producer, scaled by the production rate $q$ and the conversion factor $\\alpha$. The term $k_s - k_u$ reflects the difference between the self-serving capture hazard, $k_s$, and the socially available capture hazard, $k_u$. If $\\Delta w(R) > 0$, cheaters have a higher growth rate and will increase in frequency. If $\\Delta w(R) \\le 0$, producers are evolutionarily stable or neutral against cheaters.\n\nFinally, we calculate the time to cheater takeover, $T(R)$. The dynamics follow the standard replicator equation, for which the time to transit from an initial producer fraction $x_0$ to a final fraction $x_f$ is given by:\n$$\nT(R) =\n\\begin{cases}\n+\\infty, & \\text{if } \\Delta w(R) \\le 0, \\\\\n\\displaystyle \\frac{1}{\\Delta w(R)} \\ln\\!\\left(\\frac{x_0 (1 - x_f)}{x_f (1 - x_0)}\\right), & \\text{if } \\Delta w(R) > 0.\n\\end{cases}\n$$\nThe logarithmic term is a constant for fixed $x_0$ and $x_f$. If selection favors producers ($\\Delta w(R) < 0$) or is neutral ($\\Delta w(R) = 0$), the cheater fraction does not grow to fixation, and the takeover time is defined as infinite.\n\nThe implementation will use the following specified parameter values:\n-   $\\rho = 0.01 \\text{ cells}\\,\\mu\\mathrm{m}^{-2}$\n-   $L = 30 \\,\\mu\\mathrm{m}$\n-   $k_s = 0.5 \\,\\mathrm{h}^{-1}$\n-   $k_u = 0.05 \\,\\mathrm{h}^{-1}$ per cell\n-   $k_{e0} = 0.02 \\,\\mathrm{h}^{-1}$\n-   $q = 100$ molecule-units $\\mathrm{h}^{-1}$\n-   $\\alpha = 0.001 \\,\\mathrm{h}^{-1}$ per molecule-unit $\\mathrm{h}^{-1}$\n-   $c = 0.03 \\,\\mathrm{h}^{-1}$\n-   $x_0 = 0.99$\n-   $x_f = 0.1$\n\nThe program will iterate through the test suite of radii $R \\in \\{8, 20, 26, 30, 100\\}$ $\\mu$m. For each value of $R$, it will execute the four steps outlined above. If the result for $T(R)$ is finite, it will be rounded to three decimal places. If infinite, it will be represented by the IEEE $754$ standard for infinity. The final output is an ordered list of these results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the cheater takeover time T(R) for a range of microcolony radii.\n    \"\"\"\n    \n    # Define the parameters from the problem statement.\n    params = {\n        'rho': 0.01,    # cells µm⁻²\n        'L': 30.0,      # µm\n        'k_s': 0.5,     # h⁻¹\n        'k_u': 0.05,    # h⁻¹ per cell\n        'k_e0': 0.02,   # h⁻¹\n        'q': 100.0,     # molecule-units h⁻¹\n        'alpha': 0.001, # h⁻¹ per molecule-unit h⁻¹\n        'c': 0.03,      # h⁻¹\n        'x_0': 0.99,    # initial producer fraction\n        'x_f': 0.1,     # final producer fraction\n    }\n\n    # Define the test suite of microcolony radii.\n    radii = [8.0, 20.0, 26.0, 30.0, 100.0]  # in µm\n\n    results = []\n\n    # Pre-calculate the constant logarithmic term for T(R).\n    # This term is derived from the solution to the replicator ODE.\n    log_term = math.log(\n        (params['x_0'] * (1 - params['x_f'])) / \n        (params['x_f'] * (1 - params['x_0']))\n    )\n\n    for R in radii:\n        # Step 1: Calculate the effective number of neighbors, N(R).\n        # The interaction area is the minimum of the colony area and diffusion area.\n        min_R_L_sq = min(R**2, params['L']**2)\n        N_R = max(0.0, params['rho'] * math.pi * min_R_L_sq - 1.0)\n\n        # Step 2: Calculate the total competing hazard rate, H(R).\n        # This is the sum of self-uptake, neighbor uptake, and escape hazards.\n        # A check for R=0 is good practice, although not required by the test cases.\n        if R == 0:\n            # The escape rate would be infinite, making H(R) infinite.\n            # This implies any secreted molecule is instantly lost.\n            H_R = float('inf')\n        else:\n            H_R = params['k_s'] + params['k_u'] * N_R + params['k_e0'] * params['L'] / R\n        \n        # Step 3: Calculate the fitness difference between cheaters and producers, Δw(R).\n        # This determines the direction of selection.\n        if H_R == 0:\n             # Avoid division by zero; physically H(R) is always positive.\n             # This case implies Δw -> -inf, so producers are strongly favored.\n             delta_w_R = -float('inf')\n        else:\n            net_private_benefit = (params['alpha'] * params['q'] * \n                                  (params['k_s'] - params['k_u'])) / H_R\n            delta_w_R = params['c'] - net_private_benefit\n\n        # Step 4: Calculate the cheater takeover time, T(R).\n        if delta_w_R <= 0:\n            # If cheaters are not favored, takeover time is infinite.\n            T_R = float('inf')\n        else:\n            # If cheaters are favored, calculate the finite takeover time.\n            T_R = (1 / delta_w_R) * log_term\n            # Round to three decimal places as required.\n            T_R = round(T_R, 3)\n\n        results.append(T_R)\n    \n    # Final print statement in the exact required format.\n    # The string representation of float('inf') is 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2738997"}, {"introduction": "The evolutionary story doesn't always end with a simple win for producers or cheaters. Sometimes, engineered parts can be co-opted, or \"repurposed,\" by the host organism for its own benefit. This final practice challenges you to analyze a more complex and realistic evolutionary scenario by calculating the stable equilibrium of a three-type population, exploring how the possibility of repurposing can dramatically alter the fate of an engineered function [@problem_id:2739051]. This exercise highlights the importance of considering the host's own evolutionary incentives when designing synthetic circuits for long-term deployment.", "problem": "Consider an asexual, well-mixed microbial population in which an engineered function can either be maintained as designed, lost, or repurposed by the host for native benefit. There are exactly $3$ heritable genotypes: the engineered-function producer $P$, the engineered-function cheater $C$ that has lost the function, and the repurposer $R$ that retains the engineered function while mutationally reconfiguring regulation to provide a native host benefit. The population is large enough that stochastic drift is negligible, and generations overlap. Assume the infinite-population, continuous-time selection–mutation limit with mass-action reproduction.\n\nEach genotype $i \\in \\{P,C,R\\}$ has a constant Malthusian fitness $w_i$ that depends on a cost of producing the engineered function and, for the repurposer, a host-native benefit:\n- $w_P = 1 - c$\n- $w_C = 1$\n- $w_R = 1 - c_r + b$\n\nwhere $c \\in (0,1)$ and $c_r \\in (0,1)$ are the costs paid by $P$ and $R$, respectively, and $b \\ge 0$ is the host-native benefit realized only by $R$.\n\nMutations occur at reproduction. Let $Q$ be the $3 \\times 3$ row-stochastic mutation matrix with entries $Q_{j i}$ equal to the probability that an offspring of a parent of type $j$ is of type $i$. Off-diagonal entries are given as small forward or back mutation rates and the diagonal entries are set to ensure each row sums to $1$.\n\nYou must compute, for each test case below, the asymptotic genotype composition at the globally attracting fixed point of the standard selection–mutation dynamics in this setting. From that composition, compute the equilibrium fraction of function-bearing genotypes,\n$$\nF^\\star = x_P^\\star + x_R^\\star,\n$$\nwhere $x_P^\\star$ and $x_R^\\star$ are the equilibrium frequencies of $P$ and $R$, respectively. Report $F^\\star$ rounded to exactly $6$ decimal places as a real number in $[0,1]$.\n\nTest suite parameterization. For each case, you are given $(c, c_r, b)$ and the off-diagonal mutation rates $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C})$. Construct $Q$ by placing these rates in the corresponding off-diagonal positions and setting each diagonal $Q_{j j} = 1 - \\sum_{i \\ne j} Q_{j i}$. Use the following $5$ cases:\n\n- Case $1$ (no repurposing benefit):\n  - $(c, c_r, b) = (0.05, 0.05, 0.0)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- Case $2$ (repurposing strongly beneficial):\n  - $(c, c_r, b) = (0.05, 0.05, 0.08)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- Case $3$ (repurposing marginally beneficial, net neutral relative to $C$):\n  - $(c, c_r, b) = (0.05, 0.05, 0.05)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- Case $4$ (repurposing not beneficial enough given higher cost):\n  - $(c, c_r, b) = (0.10, 0.08, 0.05)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)$\n\n- Case $5$ (repurposing beneficial but mutation pressure toward loss is high):\n  - $(c, c_r, b) = (0.05, 0.05, 0.08)$\n  - $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C}) = (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.01)$\n\nYour program must produce a single line of output containing the $5$ results as a comma-separated list enclosed in square brackets, in the same order as the cases above, for example, $[0.123456,0.234567,0.345678,0.456789,0.567890]$. All numbers in the output must be rounded to exactly $6$ decimal places and must be decimals in $[0,1]$ (no percentage signs).", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n\nThe problem defines a system of three genotypes: Producer ($P$), Cheater ($C$), and Repurposer ($R$). Their dynamics are governed by continuous-time selection-mutation in a well-mixed, asexual population of infinite size.\n\nThe Malthusian fitnesses $w_i$ for $i \\in \\{P, C, R\\}$ are given by:\n- $w_P = 1 - c$\n- $w_C = 1$\n- $w_R = 1 - c_r + b$\n\nwhere $c \\in (0,1)$, $c_r \\in (0,1)$, and $b \\ge 0$.\n\nMutation is described by a $3 \\times 3$ row-stochastic matrix $Q$, where $Q_{ji}$ is the probability of an offspring from a parent of type $j$ being of type $i$. Off-diagonal entries $Q_{ji}$ for $i \\ne j$ are given by mutation rates $u_{j \\to i}$. Diagonal entries are $Q_{jj} = 1 - \\sum_{i \\ne j} Q_{ji}$.\n\nThe objective is to compute the equilibrium fraction of function-bearing genotypes, $F^\\star = x_P^\\star + x_R^\\star$, where $x_P^\\star$ and $x_R^\\star$ are the equilibrium frequencies of genotypes $P$ and $R$.\n\nFive test cases are provided with specific values for $(c, c_r, b)$ and the six off-diagonal mutation rates $(u_{P\\to C}, u_{P\\to R}, u_{C\\to P}, u_{C\\to R}, u_{R\\to P}, u_{R\\to C})$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is analyzed against the specified validation criteria.\n\n- **Scientifically Grounded:** The model is an instance of the standard replicator-mutator equation, a fundamental and well-established framework in theoretical population genetics and evolutionary dynamics. It is scientifically sound.\n- **Well-Posed:** The dynamics described are known to possess a unique, globally attracting fixed point (equilibrium). This is guaranteed by the Perron-Frobenius theorem applied to the matrix governing the dynamics, as explained in the solution. The problem is therefore well-posed.\n- **Objective:** The problem is formulated using precise mathematical language and objective parameters, free of any subjective or ambiguous terminology.\n\nThe problem does not exhibit any of the listed flaws (Scientific Unsoundness, Non-Formalizable, Incomplete Setup, Unrealistic, Ill-Posed, Pseudo-Profound, or Outside Verifiability). All necessary parameters are provided, the model is standard and solvable, and the request is for a specific, computable quantity.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. A full solution will be provided.\n\n**Solution Derivation**\n\nLet the frequencies of the three genotypes be denoted by the vector $\\mathbf{x} = [x_P, x_C, x_R]^T$. The continuous-time selection-mutation dynamics are described by the system of ordinary differential equations:\n$$\n\\frac{dx_i}{dt} = \\sum_{j \\in \\{P,C,R\\}} x_j w_j Q_{ji} - \\bar{w} x_i\n$$\nwhere $\\bar{w} = \\sum_{k \\in \\{P,C,R\\}} x_k w_k$ is the mean fitness of the population.\n\nAt equilibrium, the frequencies are constant, so $\\frac{dx_i}{dt} = 0$ for all $i$. This leads to the system of equations:\n$$\n\\bar{w} x_i^\\star = \\sum_{j \\in \\{P,C,R\\}} x_j^\\star w_j Q_{ji}\n$$\nwhere $\\mathbf{x}^\\star = [x_P^\\star, x_C^\\star, x_R^\\star]^T$ is the equilibrium frequency vector.\n\nTo express this in matrix form, let $W$ be the diagonal matrix of fitnesses:\n$$\nW = \\begin{pmatrix} w_P & 0 & 0 \\\\ 0 & w_C & 0 \\\\ 0 & 0 & w_R \\end{pmatrix}\n$$\nThe equilibrium equation can be written as:\n$$\n\\bar{w} \\mathbf{x}^\\star = (Q^T W) \\mathbf{x}^\\star\n$$\nThis is a right-eigenvector equation. The equilibrium frequency vector $\\mathbf{x}^\\star$ is the right eigenvector of the matrix $M = Q^T W$, and the mean fitness at equilibrium, $\\bar{w}$, is the corresponding eigenvalue.\n\nThe matrix $M$ is constructed as:\n$$\nM = Q^T W = \n\\begin{pmatrix}\nQ_{PP} & Q_{CP} & Q_{RP} \\\\\nQ_{PC} & Q_{CC} & Q_{RC} \\\\\nQ_{PR} & Q_{CR} & Q_{RR}\n\\end{pmatrix}\n\\begin{pmatrix}\nw_P & 0 & 0 \\\\\n0 & w_C & 0 \\\\\n0 & 0 & w_R\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nQ_{PP}w_P & Q_{CP}w_C & Q_{RP}w_R \\\\\nQ_{PC}w_P & Q_{CC}w_C & Q_{RC}w_R \\\\\nQ_{PR}w_P & Q_{CR}w_C & Q_{RR}w_R\n\\end{pmatrix}\n$$\n\nSince all fitnesses $w_i > 0$ and all mutation rates $u_{j \\to i} > 0$, all entries of the mutation matrix $Q$ are strictly positive. Consequently, all entries of the matrix $M$ are strictly positive. By the Perron-Frobenius theorem for positive matrices, $M$ has a unique largest real eigenvalue, which is simple and positive. This is the Perron-Frobenius eigenvalue, $\\lambda_{PF}$. The corresponding eigenvector is unique up to scaling and can be chosen to have all positive components.\n\nThis eigenvector represents the stable genotype composition of the population. The computational procedure is as follows:\n1. For each test case, construct the fitness vector $\\mathbf{w} = [w_P, w_C, w_R]^T$ and the mutation matrix $Q$.\n2. Form the matrix $M = Q^T \\text{diag}(\\mathbf{w})$.\n3. Compute the eigenvalues and right eigenvectors of $M$.\n4. Identify the eigenvector corresponding to the Perron-Frobenius (largest real) eigenvalue.\n5. Normalize this eigenvector by dividing each component by their sum, yielding the equilibrium frequency vector $\\mathbf{x}^\\star$.\n6. Calculate the final quantity $F^\\star = x_P^\\star + x_R^\\star$.\n7. Report $F^\\star$ rounded to $6$ decimal places.\n\nThis procedure will be implemented for each of the five provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the equilibrium fraction of function-bearing genotypes\n    for a series of test cases based on a replicator-mutator model.\n    \"\"\"\n\n    # Define the 5 test cases from the problem statement.\n    # Each case is a tuple: ((c, c_r, b), (mutation_rates))\n    # mutation_rates = (u_PC, u_PR, u_CP, u_CR, u_RP, u_RC)\n    test_cases = [\n        # Case 1 (no repurposing benefit)\n        ((0.05, 0.05, 0.0), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 2 (repurposing strongly beneficial)\n        ((0.05, 0.05, 0.08), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 3 (repurposing marginally beneficial, net neutral relative to C)\n        ((0.05, 0.05, 0.05), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 4 (repurposing not beneficial enough given higher cost)\n        ((0.10, 0.08, 0.05), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.0001)),\n        # Case 5 (repurposing beneficial but mutation pressure toward loss is high)\n        ((0.05, 0.05, 0.08), (0.0001, 0.00001, 0.000001, 0.000001, 0.00001, 0.01)),\n    ]\n\n    results = []\n    for params in test_cases:\n        fitness_params, mutation_rates = params\n        c, c_r, b = fitness_params\n        \n        # Calculate Malthusian fitnesses for P, C, R\n        w = np.array([1 - c, 1.0, 1 - c_r + b])\n\n        # Unpack mutation rates\n        u_PC, u_PR, u_CP, u_CR, u_RP, u_RC = mutation_rates\n        \n        # Construct the 3x3 row-stochastic mutation matrix Q\n        # Q[j, i] is the probability of parent j producing offspring i\n        Q = np.array([\n            [1 - u_PC - u_PR, u_PC, u_PR],  # Parent P (j=0) to P, C, R (i=0,1,2)\n            [u_CP, 1 - u_CP - u_CR, u_CR],  # Parent C (j=1) to P, C, R (i=0,1,2)\n            [u_RP, u_RC, 1 - u_RP - u_RC]   # Parent R (j=2) to P, C, R (i=0,1,2)\n        ])\n        \n        # Construct the governing matrix M = Q^T W\n        W = np.diag(w)\n        M = Q.T @ W\n        \n        # Find the eigenvalues and right eigenvectors of M\n        eigenvalues, eigenvectors = np.linalg.eig(M)\n        \n        # The Perron-Frobenius eigenvalue is the largest real eigenvalue.\n        # Its corresponding eigenvector gives the stable state.\n        pf_index = np.argmax(eigenvalues.real)\n        pf_eigenvector = eigenvectors[:, pf_index].real\n        \n        # Normalize the eigenvector to get frequencies (sum to 1).\n        # The vector can have an arbitrary sign, so we use its absolute value.\n        x_star = np.abs(pf_eigenvector) / np.sum(np.abs(pf_eigenvector))\n        \n        x_P_star, x_C_star, x_R_star = x_star\n        \n        # Calculate the total fraction of function-bearing genotypes\n        F_star = x_P_star + x_R_star\n        \n        # Round to exactly 6 decimal places and store\n        results.append(f\"{F_star:.6f}\")\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2739051"}]}