{"hands_on_practices": [{"introduction": "Designing a genetically recoded organism is a complex engineering task that requires balancing multiple objectives. This exercise introduces a powerful method for tackling the core design problem of sense codon compression: formulating it as an integer linear program (ILP). By framing the goal of minimizing the number of active sense codons as an optimization problem, you will learn to systematically select a codon set that both creates a genetic firewall and satisfies the cell's demand for every amino acid, providing a foundational skill in computational synthetic biology.", "problem": "You are tasked with formulating and solving a minimal-sense-codon compression problem as an Integer Linear Program (ILP) for genetic firewalling. The biological basis is the Central Dogma of molecular biology, which states that deoxyribonucleic acid (DNA) is transcribed to ribonucleic acid (RNA) and translated to protein. Translation uses the canonical mapping from codon triplets to amino acids. Sense codon compression reduces redundancy in the genetic code by retaining a subset of sense codons while ensuring that all amino acids required by a given set of coding sequences remain encodable after recoding. The goal is to minimize the number of retained sense codons while ensuring full amino acid coverage across all given coding sequences, under practical per-codon usage limits (capacities) and optional forbidden codons that cannot be retained (for example, because they are reassigned to a noncanonical amino acid to enforce a genetic firewall).\n\nFormally define:\n- Let $\\mathcal{S}$ be a set of coding sequences over the alphabet $\\{A, C, G, T\\}$, each with length divisible by $3$ and containing no stop codons in-frame.\n- Let $\\mathcal{C}$ be the set of all sense codons in the Standard Genetic Code (stop codons excluded).\n- Let $G: \\mathcal{C} \\to \\mathcal{A}$ be the canonical mapping from codons to amino acids, where $\\mathcal{A}$ is the set of standard amino acids represented by one-letter codes.\n- For each amino acid $a \\in \\mathcal{A}$, define $\\mathcal{C}(a) = \\{c \\in \\mathcal{C} \\mid G(c) = a\\}$.\n- For each amino acid $a$, define the total demand $d_a$ as the total number of occurrences of $a$ across all sequences in $\\mathcal{S}$ when translated via $G$.\n- For each codon $c \\in \\mathcal{C}$, define an integer capacity $k_c \\in \\mathbb{Z}_{\\ge 0}$ representing the maximum allowed usage of codon $c$ across the entire recoding task (motivated by translational supply-demand balance and design constraints to avoid problematic motifs).\n- Let $\\mathcal{F} \\subseteq \\mathcal{C}$ be the set of forbidden codons that cannot be retained.\n\nPose the following Integer Linear Program (ILP) to select retained sense codons:\n- Decision variables: for each codon $c \\in \\mathcal{C}$, let $x_c \\in \\{0,1\\}$ indicate whether $c$ is retained.\n- Objective: minimize $\\sum_{c \\in \\mathcal{C}} x_c$.\n- Constraints:\n  1. For each amino acid $a$ that appears at least once in the translations of $\\mathcal{S}$, ensure coverage by capacities:\n     $$\\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a.$$\n  2. For each forbidden codon $c \\in \\mathcal{F}$, enforce $x_c = 0$.\n  3. For all $c \\in \\mathcal{C}$, enforce $x_c \\in \\{0,1\\}$.\n\nInterpretation: After choosing the retained codons, all coding sequences can be recoded so that every occurrence of an amino acid $a$ is rewritten using retained codons from $\\mathcal{C}(a)$ without exceeding per-codon usage capacities. This corresponds to sense codon compression compatible with the observed proteome while enhancing genetic firewalling by minimizing retained codons.\n\nYour task is to write a complete, runnable program that:\n- Computes the optimal objective value of the ILP above for each of the specified test cases.\n- If the ILP is infeasible, it must return $-1$ for that test case.\n\nNote: Although the problem is posed as an Integer Linear Program (ILP), you are free to exploit any structural properties to solve it algorithmically, provided the returned value is the true optimum.\n\nUse the Standard Genetic Code (DNA codons) for all sense codons, excluding stop codons. Angles are not involved. No physical units are involved. All outputs must be integers. \n\nTest Suite:\nFor each test case below, you are given:\n- A list of coding DNA sequences $\\mathcal{S}$, each in-frame and length divisible by $3$.\n- A base capacity $K_0$ applied to any codon not explicitly overridden.\n- A dictionary of per-codon capacity overrides $\\{(c, k_c)\\}$ that supersede $K_0$ when provided.\n- A set of forbidden codons $\\mathcal{F}$.\n\nYour program must compute the optimal value of $\\sum_{c \\in \\mathcal{C}} x_c$ for each case or $-1$ if infeasible.\n\n- Test case $1$:\n  - $\\mathcal{S} = [\\text{\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\"}, \\text{\"ATGCTTACCGCAGGCAGA\"}]$\n  - $K_0 = 2$\n  - Overrides: none\n  - $\\mathcal{F} = \\varnothing$\n- Test case $2$:\n  - $\\mathcal{S} = [\\text{\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"}]$\n  - $K_0 = 3$\n  - Overrides: none\n  - $\\mathcal{F} = \\{\\text{\"GGG\"}\\}$\n- Test case $3$:\n  - $\\mathcal{S} = [\\text{\"ATGCTGCTGCTGCTGCTG\"}]$\n  - $K_0 = 2$\n  - Overrides: $\\{(\\text{\"CTG\"}, 4)\\}$\n  - $\\mathcal{F} = \\{\\text{\"TTA\"}, \\text{\"TTG\"}, \\text{\"CTT\"}, \\text{\"CTC\"}, \\text{\"CTA\"}\\}$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the test cases in the order given (e.g., `[result_1,result_2,result_3]`). Each `result_i` must be an integer, with infeasible cases denoted by -1.", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded in molecular biology, mathematically well-posed as an Integer Linear Program (ILP), and provides a complete, unambiguous, and consistent set of definitions and data.\n\nThe problem is to find the optimal value of an ILP designed for sense codon compression. The objective is to minimize the total number of retained sense codons, subject to constraints that ensure all required amino acids remain encodable up to their specified demands, considering per-codon capacities and a set of forbidden codons.\n\nLet the decision variables be $x_c \\in \\{0, 1\\}$ for each sense codon $c \\in \\mathcal{C}$, where $x_c=1$ if codon $c$ is retained and $x_c=0$ otherwise. The ILP is formulated as:\n\nMinimize:\n$$ \\sum_{c \\in \\mathcal{C}} x_c $$\n\nSubject to:\n1. For each amino acid $a \\in \\mathcal{A}$ with demand $d_a > 0$: \n   $$ \\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a $$\n2. For each forbidden codon $c \\in \\mathcal{F}$:\n   $$ x_c = 0 $$\n3. For all $c \\in \\mathcal{C}$:\n   $$ x_c \\in \\{0, 1\\} $$\n\nHere, $\\mathcal{C}(a)$ is the set of codons encoding amino acid $a$, $d_a$ is the total demand for amino acid $a$, and $k_c$ is the usage capacity of codon $c$.\n\nA critical structural property of this ILP is its decomposability. The objective function is a sum over all codons, which can be partitioned by the amino acid they encode:\n$$ \\sum_{c \\in \\mathcal{C}} x_c = \\sum_{a \\in \\mathcal{A}} \\left( \\sum_{c \\in \\mathcal{C}(a)} x_c \\right) $$\nThe constraints for a given amino acid $a$ involve only the decision variables $\\{x_c \\mid c \\in \\mathcal{C}(a)\\}$. These variables do not appear in the constraints for any other amino acid $a' \\neq a$. This independence allows the global optimization problem to be decomposed into a set of smaller, independent subproblems, one for each amino acid $a \\in \\mathcal{A}$ with a non-zero demand $d_a$.\n\nFor each such amino acid $a$, we must solve the following subproblem: find the minimum number of codons from $\\mathcal{C}(a)$ to retain, denoted by $N_a$, such that the demand $d_a$ is satisfied. The subproblem is:\n\nMinimize:\n$$ N_a = \\sum_{c \\in \\mathcal{C}(a)} x_c $$\n\nSubject to:\n$$ \\sum_{c \\in \\mathcal{C}(a) \\setminus \\mathcal{F}} k_c \\, x_c \\ge d_a $$\n$$ x_c \\in \\{0, 1\\} \\text{ for } c \\in \\mathcal{C}(a) \\setminus \\mathcal{F} $$\n\nThe total optimal number of codons for the original problem is then simply the sum of the optimal solutions to these subproblems: $\\sum_{a \\mid d_a > 0} N_a$. If any subproblem is infeasible, the entire problem is infeasible.\n\nEach subproblem is equivalent to the following: given a set of available (non-forbidden) codons for amino acid $a$, each with a specific capacity $k_c$, select the smallest possible subset of these codons whose capacities sum to at least $d_a$. This is a variant of the change-making or unbounded knapsack problem, but with a unit cost for each item.\n\nThis subproblem possesses an optimal greedy solution. To minimize the number of selected codons, one must prioritize those with the highest capacity. The algorithm is as follows:\n1. Consider the set of available codons for amino acid $a$, which is $\\mathcal{C}(a) \\setminus \\mathcal{F}$.\n2. Sort these codons in descending order of their capacities $k_c$.\n3. Sequentially select codons from this sorted list, accumulating their capacities, until the total capacity sum is greater than or equal to the demand $d_a$.\n4. The number of codons selected is the minimum required for amino acid $a$, which is $N_a$.\n5. If the sum of capacities of all available codons for $a$ is less than $d_a$, the subproblem is infeasible.\n\nThe optimality of this greedy strategy can be proven by an exchange argument. Assume a greedy solution $G$ is suboptimal and an optimal solution $O$ exists with fewer codons, $|O| < |G|$. Let the codons be ordered by decreasing capacity. The greedy choice ensures that for any $j \\le |O|$, the capacity of the $j$-th codon in the greedy sequence is greater than or equal to the capacity of the $j$-th codon in the optimal sequence. This implies that the cumulative capacity of the first $|O|$ codons chosen by the greedy algorithm is at least as large as the total capacity of the optimal solution, which itself must be $\\ge d_a$. Therefore, the greedy algorithm would have terminated with at most $|O|$ codons, contradicting the assumption that $|G| > |O|$. Thus, the greedy approach is optimal.\n\nThe overall algorithm is as follows:\n1. For each test case, first parse the input sequences $\\mathcal{S}$ to compute the total demand $d_a$ for each amino acid $a$.\n2. Construct the capacity map $k_c$ for all sense codons based on the base capacity $K_0$ and any specified overrides.\n3. For each amino acid $a$ with $d_a > 0$:\n    a. Identify the set of available codons $\\mathcal{C}(a) \\setminus \\mathcal{F}$ and their corresponding capacities.\n    b. If the total capacity of all available codons is less than $d_a$, the problem is infeasible. Mark the result as $-1$ and terminate for this case.\n    c. Otherwise, apply the greedy selection strategy described above to determine the minimum number of codons $N_a$.\n4. The total objective value is the sum of all $N_a$ over all amino acids with $d_a > 0$.\n\nThis principled, decomposition-based approach correctly and efficiently solves the given ILP.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the codon compression problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the Standard Genetic Code (DNA codons to amino acids)\n    # Stop codons (TAA, TAG, TGA) are excluded.\n    codon_to_aa = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H',\n        'CAA': 'Q', 'CAG': 'Q', 'AAT': 'N', 'AAC': 'N',\n        'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D',\n        'GAA': 'E', 'GAG': 'E', 'TGT': 'C', 'TGC': 'C',\n        'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', \n        'CGG': 'R', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', \n        'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', \n        'GGG': 'G'\n    }\n\n    # Pre-compute the mapping from amino acids to their codons\n    aa_to_codons = defaultdict(list)\n    for codon, aa in codon_to_aa.items():\n        aa_to_codons[aa].append(codon)\n\n    # All sense codons\n    all_sense_codons = list(codon_to_aa.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": [\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\", \"ATGCTTACCGCAGGCAGA\"],\n            \"K0\": 2,\n            \"overrides\": {},\n            \"F\": set()\n        },\n        {\n            \"S\": [\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"],\n            \"K0\": 3,\n            \"overrides\": {},\n            \"F\": {\"GGG\"}\n        },\n        {\n            \"S\": [\"ATGCTGCTGCTGCTGCTG\"],\n            \"K0\": 2,\n            \"overrides\": {\"CTG\": 4},\n            \"F\": {\"TTA\", \"TTG\", \"CTT\", \"CTC\", \"CTA\"}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sequences = case[\"S\"]\n        k0 = case[\"K0\"]\n        overrides = case[\"overrides\"]\n        forbidden_codons = case[\"F\"]\n\n        # Step 1: Compute amino acid demands (d_a)\n        demands = defaultdict(int)\n        full_sequence = \"\".join(sequences)\n        for i in range(0, len(full_sequence), 3):\n            codon = full_sequence[i:i+3]\n            if codon in codon_to_aa:\n                aa = codon_to_aa[codon]\n                demands[aa] += 1\n        \n        # Step 2: Compute codon capacities (k_c)\n        capacities = {c: k0 for c in all_sense_codons}\n        capacities.update(overrides)\n\n        # Step 3: Solve subproblem for each amino acid\n        total_retained_codons = 0\n        is_infeasible = False\n        \n        for aa, demand in demands.items():\n            if demand == 0:\n                continue\n\n            # Get available codons and their capacities for the current amino acid\n            available_codon_capacities = []\n            for codon in aa_to_codons[aa]:\n                if codon not in forbidden_codons:\n                    available_codon_capacities.append(capacities[codon])\n            \n            # Check for instant infeasibility\n            if sum(available_codon_capacities) < demand:\n                is_infeasible = True\n                break\n            \n            # Sort capacities in descending order for greedy selection\n            available_codon_capacities.sort(reverse=True)\n            \n            # Greedily select codons\n            capacity_sum = 0\n            codons_for_aa = 0\n            for cap in available_codon_capacities:\n                capacity_sum += cap\n                codons_for_aa += 1\n                if capacity_sum >= demand:\n                    break\n            \n            total_retained_codons += codons_for_aa\n\n        if is_infeasible:\n            results.append(-1)\n        else:\n            results.append(total_retained_codons)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2772541"}, {"introduction": "Once a minimal codon set is chosen, implementing it requires changing thousands of nucleotides across the genome, a process that can have unintended consequences. This practice explores how to quantify the \"off-target\" effects of codon substitutions on functional sequence motifs, such as Shine-Dalgarno-like sequences, which are critical for translation initiation. You will compare a probabilistic model of disruption with the actual outcome, providing a practical framework for assessing the risks associated with genome-wide recoding.", "problem": "You are to formalize and compute the disruption of fixed-length sequence motifs caused by genome-wide synonymous codon substitutions, as used in sense codon compression for genetic firewalling. Begin from the Central Dogma of Molecular Biology and the definition of the genetic code: a coding sequence is a string over the alphabet $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T} \\}$ whose length is a multiple of $3$, parsed into codons of length $3$ that specify amino acids. In sense codon compression, all synonymous codons for a given amino acid are mapped to a single representative codon, inducing nucleotide substitutions across the coding sequence without changing the encoded protein. A fixed motif is a $k$-mer, an exact string of length $k$ over $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T} \\}$ whose occurrences are counted anywhere along the sequence, allowing overlaps. Motifs of interest include Shineâ€“Dalgarno-like (SD-like) sequences (e.g., $\\mathrm{AGGAGG}$), which can be deleterious if inadvertently created or beneficial if removed; here you will focus on disruptions (losses) of pre-existing motif occurrences caused by codon compression.\n\nYour task is to compute, for each provided test case, three quantities:\n- The expected number of disrupted motif occurrences, under a first-principles independence model in which each nucleotide position independently changes with probability $p$, where $p$ is the empirically measured fraction of nucleotides that change under the supplied codon mapping. If the original sequence has $N$ occurrences of the motif and the motif length is $k$, then the expected number of disrupted occurrences is\n$$\nE = N \\left( 1 - (1 - p)^k \\right),\n$$\nwhich follows from the complement event that none of the $k$ positions in an occurrence is altered.\n- A combinatorial upper bound on the number of disrupted motif occurrences that depends only on the number of changed nucleotide positions and the motif length. Let $c$ be the total count of nucleotide positions that change after applying the mapping to all codons in the sequence, and let $k$ be the motif length. Each changed nucleotide position can belong to at most $k$ distinct $k$-mers (by sliding-window enumeration). Therefore, the total number of motif occurrences that could possibly be disrupted is upper-bounded by\n$$\nU = \\min\\left(N, c \\cdot k\\right).\n$$\n- The actual number of disrupted motif occurrences $D$ when the supplied codon mapping is applied deterministically to the provided sequence. A motif occurrence in the original sequence is counted as disrupted if any nucleotide within its $k$ positions is altered by the mapping.\n\nYou must implement a program that, for each test case, performs the following:\n- Parse the original sequence (length $n$ nucleotides with $n$ divisible by $3$) into codons of length $3$.\n- Apply the provided codon-to-codon map to each codon to obtain the recoded sequence.\n- Compute $c$ as the number of nucleotide positions that differ between the original and recoded sequences, and set $p = c/n$.\n- Compute $N$ as the count of occurrences of the motif (exact string matches of length $k$) in the original sequence, allowing overlaps.\n- Compute $E$ as defined above, using the empirically measured $p$; report $E$ as a floating-point number rounded to exactly $6$ decimal places.\n- Compute $U = \\min(N, c \\cdot k)$ as an integer.\n- Compute $D$ as the number of motif occurrences in the original sequence that overlap at least one changed nucleotide position, as an integer.\n\nAssumptions and definitions:\n- All codon mappings preserve amino acid identity in principle, but you need not verify amino acid semantics; you must simply apply the provided codon-to-codon map to every codon present in the sequence. You may assume the map is defined for every codon that appears in the sequence.\n- Motif occurrences are found on the given strand only; reverse complements are not considered.\n- All quantities are unitless. Angles are not involved.\n- Report the expected value $E$ rounded to exactly $6$ decimal places; integers $U$ and $D$ must be exact.\n\nTest suite:\nProvide code that evaluates the following five test cases.\n\n- Case $1$ (SD-like motif, multiple changes):\n    - Sequence: $\\mathrm{ATGAGGAGGTTTCCGAGGAGGATC}$.\n    - Motif: $\\mathrm{AGGAGG}$, so $k = 6$.\n    - Codon map: $\\mathrm{ATG} \\mapsto \\mathrm{ATG}$, $\\mathrm{AGG} \\mapsto \\mathrm{CGT}$, $\\mathrm{TTT} \\mapsto \\mathrm{TTT}$, $\\mathrm{CCG} \\mapsto \\mathrm{CCG}$, $\\mathrm{ATC} \\mapsto \\mathrm{ATC}$.\n\n- Case $2$ (identity mapping, no changes):\n    - Sequence: $\\mathrm{ATGATGATG}$.\n    - Motif: $\\mathrm{ATG}$, so $k = 3$.\n    - Codon map: identity on $\\{\\mathrm{ATG}\\}$.\n\n- Case $3$ (maximal change at every position):\n    - Sequence: $\\mathrm{AAAAAAAAAAAA}$.\n    - Motif: $\\mathrm{A}$, so $k = 1$.\n    - Codon map: $\\mathrm{AAA} \\mapsto \\mathrm{CCC}$.\n\n- Case $4$ (no motif present, arbitrary mapping with no effect on present codons):\n    - Sequence: $\\mathrm{GCTGCTGCT}$.\n    - Motif: $\\mathrm{TTT}$, so $k = 3$.\n    - Codon map: $\\mathrm{GCT} \\mapsto \\mathrm{GCT}$.\n\n- Case $5$ (changes do not overlap motif occurrences):\n    - Sequence: $\\mathrm{AAAGAACGTAAA}$.\n    - Motif: $\\mathrm{AAA}$, so $k = 3$.\n    - Codon map: $\\mathrm{AAA} \\mapsto \\mathrm{AAA}$, $\\mathrm{GAA} \\mapsto \\mathrm{GAA}$, $\\mathrm{CGT} \\mapsto \\mathrm{CGA}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a three-element list $[E,U,D]$ in this order. The float $E$ must be printed with exactly $6$ decimal places. For example, the overall output format is\n\"[[E1,U1,D1],[E2,U2,D2],...]\" with no spaces.\n\nThe final output must strictly adhere to this format and be produced with a single print statement. No user input should be read; all data are embedded in the program.", "solution": "The problem posed is a well-defined computational exercise in bioinformatics, grounded in the principles of molecular biology, specifically protein biosynthesis and genetic engineering. It requires the quantification of sequence motif disruption resulting from sense codon compression, a technique used in synthetic biology. The problem is scientifically sound, internally consistent, and provides all necessary data and definitions for a unique solution. Therefore, it is deemed valid.\n\nThe solution is developed by methodically implementing the procedures specified in the problem statement. The core of the problem is to compare an original DNA coding sequence with a recoded sequence, generated by applying a given codon-to-codon mapping, and to analyze the impact of the resulting nucleotide changes on the occurrences of a specified short sequence motif (a $k$-mer).\n\nWe must compute three quantities for each test case: the expected number of disrupted motifs ($E$), a combinatorial upper bound on disruptions ($U$), and the actual number of disruptions ($D$).\n\nThe logical steps for the computation for a single test case are as follows:\n\n1.  **Sequence Recoding and Identification of Changes**:\n    The original DNA sequence, a string of length $n$ over the alphabet $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$, is first parsed into a list of non-overlapping codons of length $3$. The provided codon map is then applied to each codon in this list to generate a new list of recoded codons. These are concatenated to form the recoded sequence. By comparing the original and recoded sequences nucleotide by nucleotide, we identify the set of all positions where a substitution has occurred. The total number of such positions is denoted by $c$.\n    The empirical probability of a single nucleotide change, $p$, is then calculated as the ratio of changed positions to the total sequence length:\n    $$p = \\frac{c}{n}$$\n\n2.  **Motif Enumeration**:\n    The number of occurrences of the specified motif, a $k$-mer, in the original sequence is counted. This count, denoted by $N$, allows for overlapping occurrences. This is achieved by iterating through the sequence with a sliding window of length $k$ and testing for an exact match with the motif at each position. We also record the starting indices of all occurrences, as this information is crucial for calculating the actual disruption count, $D$.\n\n3.  **Calculation of Expected Disruptions ($E$)**:\n    The expected number of disrupted motifs, $E$, is calculated based on a probabilistic model where each nucleotide position changes independently with probability $p$. For a single motif occurrence of length $k$, the probability that it remains unchanged is the probability that none of its $k$ constituent nucleotides are altered. Under the independence assumption, this probability is $(1 - p)^k$. The complementary probability, that at least one nucleotide is altered (i.e., the motif occurrence is disrupted), is $1 - (1 - p)^k$. By linearity of expectation, the total expected number of disruptions across all $N$ occurrences is:\n    $$E = N \\left( 1 - (1 - p)^k \\right)$$\n    The result must be reported as a floating-point number rounded to six decimal places.\n\n4.  **Calculation of the Upper Bound ($U$)**:\n    A combinatorial upper bound, $U$, on the number of disrupted motifs is computed. Each of the $c$ changed nucleotide positions can affect at most $k$ distinct $k$-mer occurrences (one starting at each of the $k$ positions from $i-k+1$ to $i$, where $i$ is the position of the change). Thus, the total number of affected occurrences cannot exceed $c \\cdot k$. Furthermore, the number of disrupted motifs cannot exceed the total number of motifs present, $N$. Therefore, the upper bound is the minimum of these two values:\n    $$U = \\min(N, c \\cdot k)$$\n\n5.  **Calculation of Actual Disruptions ($D$)**:\n    The actual number of disrupted motifs, $D$, is determined by direct observation. We iterate through each of the $N$ motif occurrences found in the original sequence. For each occurrence, we check if any of its constituent nucleotide positions (from its start index to its end index) corresponds to a position where a change occurred during recoding. An occurrence is counted as disrupted if there is at least one such overlap. This is implemented by finding the set of all changed nucleotide indices and, for each motif occurrence, checking for a non-empty intersection between its set of spanned indices and the set of changed indices. The total count of such disrupted occurrences gives the value of $D$.\n\nThis complete algorithm is applied to each of the five test cases provided, and the results are aggregated into the specified output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the motif disruption problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (SD-like motif, multiple changes)\n        {\n            \"sequence\": \"ATGAGGAGGTTTCCGAGGAGGATC\",\n            \"motif\": \"AGGAGG\",\n            \"codon_map\": {\n                \"ATG\": \"ATG\", \"AGG\": \"CGT\", \"TTT\": \"TTT\", \n                \"CCG\": \"CCG\", \"ATC\": \"ATC\"\n            }\n        },\n        # Case 2 (identity mapping, no changes)\n        {\n            \"sequence\": \"ATGATGATG\",\n            \"motif\": \"ATG\",\n            \"codon_map\": {\"ATG\": \"ATG\"}\n        },\n        # Case 3 (maximal change at every position)\n        {\n            \"sequence\": \"AAAAAAAAAAAA\",\n            \"motif\": \"A\",\n            \"codon_map\": {\"AAA\": \"CCC\"}\n        },\n        # Case 4 (no motif present, no changes)\n        {\n            \"sequence\": \"GCTGCTGCT\",\n            \"motif\": \"TTT\",\n            \"codon_map\": {\"GCT\": \"GCT\"}\n        },\n        # Case 5 (changes do not overlap motif occurrences)\n        {\n            \"sequence\": \"AAAGAACGTAAA\",\n            \"motif\": \"AAA\",\n            \"codon_map\": {\"AAA\": \"AAA\", \"GAA\": \"GAA\", \"CGT\": \"CGA\"}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        seq = case[\"sequence\"]\n        motif = case[\"motif\"]\n        codon_map = case[\"codon_map\"]\n        \n        n = len(seq)\n        k = len(motif)\n\n        if n == 0:\n            results.append([0.0, 0, 0])\n            continue\n\n        # Step 1: Recode sequence\n        original_codons = [seq[i:i+3] for i in range(0, n, 3)]\n        recoded_codons = [codon_map[codon] for codon in original_codons]\n        recoded_seq = \"\".join(recoded_codons)\n\n        # Step 2: Compute c and p\n        changed_indices = {i for i in range(n) if seq[i] != recoded_seq[i]}\n        c = len(changed_indices)\n        p = c / n\n\n        # Step 3: Compute N\n        motif_starts = [i for i in range(n - k + 1) if seq[i:i+k] == motif]\n        N = len(motif_starts)\n        \n        if N == 0:\n            results.append([0.0, 0, 0])\n            continue\n\n        # Step 4: Compute E\n        E = N * (1 - (1 - p)**k)\n\n        # Step 5: Compute U\n        U = min(N, c * k)\n\n        # Step 6: Compute D\n        disrupted_count = 0\n        for start_pos in motif_starts:\n            motif_indices = set(range(start_pos, start_pos + k))\n            if not motif_indices.isdisjoint(changed_indices):\n                disrupted_count += 1\n        D = disrupted_count\n\n        results.append([E, U, D])\n\n    # Final print statement in the exact required format.\n    # e.g., [[E1,U1,D1],[E2,U2,D2],...]\n    result_str = \",\".join([f\"[{e:.6f},{u},{d}]\" for e, u, d in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2772551"}, {"introduction": "The consequences of codon compression extend beyond the genome sequence to the dynamics of protein synthesis itself. Replacing rare codons with more common ones can accelerate translation, but this removes the natural \"pauses\" that may be critical for correct protein folding. In this exercise [@problem_id:2772556], you will use a kinetic model to quantify how changes in translation speed can affect the probability of co-translational misfolding, connecting genetic design choices to their ultimate impact on the proteome's integrity.", "problem": "You are modeling co-translational folding in the context of sense codon compression for genetic firewalling. Sense codon compression modifies transfer ribonucleic acid (tRNA) abundances and codon usage, which can accelerate translation through regions that previously contained slow codons. You will quantify how such acceleration changes the probability of misfolding using a minimal two-state kinetic model. The fundamental base is the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein), and the well-tested kinetic description that a first-order process with constant rate $k$ over a time $t$ has a transition probability $1 - e^{-k t}$.\n\nModel assumptions and definitions:\n- Consider a single critical slow-codon window of length $L$ codons where, during translation, the nascent chain can nucleate the correct native fold. Let the translation rate in this window be $r$ codons per second, so the dwell time in the window is $T = L / r$ seconds.\n- Within this window, formation of a productive folding nucleus is modeled as a Poisson process with rate $k_f$ in $\\text{s}^{-1}$, giving a probability $p_{\\text{nuc}} = 1 - e^{-k_f T}$ that the nucleus forms before the ribosome exits the window.\n- At the end of the window, if the nucleus formed, the protein still misfolds with a small probability $\\beta$ (dimensionless, between $0$ and $1$). If the nucleus did not form by the end of the window, the protein commits to a misfolded state with probability $\\alpha$ (dimensionless, between $0$ and $1$).\n- The misfolding probability at the end of translation for a single window under translation rate $r$ is therefore a function of $L$, $r$, $k_f$, $\\alpha$, and $\\beta$.\n\nYour task:\n- For each test case, compute the change in misfolding probability $\\Delta R$ due to accelerating translation through the formerly slow region, defined as $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$, where $R_{\\text{before}}$ uses the original translation rate $r_{\\text{before}}$ in the window and $R_{\\text{after}}$ uses the accelerated translation rate $r_{\\text{after}}$. All rates $r$ are in codons per second, $k_f$ is in $\\text{s}^{-1}$, and $L$ is in codons. The output is dimensionless. Express each $\\Delta R$ as a decimal rounded to six places.\n\nInput parameters for each test case are given as a tuple $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta)$.\n\nTest suite:\n1. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (15, 5, 15, 0.3, 0.8, 0.02)$\n2. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (20, 10, 10, 0.25, 0.7, 0.05)$\n3. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (30, 3, 12, 0.4, 0.9, 0.01)$\n4. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (5, 8, 18, 0.05, 0.85, 0.02)$\n5. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (0, 6, 12, 0.5, 0.6, 0.0)$\n\nProgram requirements:\n- Implement a function that, for each test case, computes $R_{\\text{before}}$ and $R_{\\text{after}}$ under the two-state model described above, and returns $\\Delta R$ rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must have exactly six digits after the decimal point.\n\nNote: You must not read any input. Use the test suite defined above inside the program.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- A critical folding window of length $L$ codons.\n- Translation rate in the window: $r$ codons/s.\n- Dwell time in the window: $T = L / r$ seconds.\n- Folding nucleus formation rate: $k_f$ in $\\text{s}^{-1}$.\n- Probability of nucleation within time $T$: $p_{\\text{nuc}} = 1 - e^{-k_f T}$.\n- Misfolding probability if nucleus forms: $\\beta$.\n- Misfolding probability if nucleus does not form: $\\alpha$.\n- The task is to compute the change in misfolding probability, $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$, where $R_{\\text{before}}$ and $R_{\\text{after}}$ are the total misfolding probabilities corresponding to translation rates $r_{\\text{before}}$ and $r_{\\text{after}}$.\n- Input parameters are provided as a tuple $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta)$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the criteria for validity.\n\n- **Scientifically Grounded:** The problem is valid. It uses a simplified but standard kinetic model based on first-order rate processes, which are fundamental to chemical and biological kinetics. The premise that translation speed (modulated by codon usage) affects co-translational protein folding is a well-established concept in molecular biology. The formula for a first-order process probability, $1 - e^{-kt}$, is correct.\n- **Well-Posed:** The problem is valid. All necessary parameters ($L$, $r_{\\text{before}}$, $r_{\\text{after}}$, $k_f$, $\\alpha$, $\\beta$) are provided for each test case. The objective is clearly defined, and a unique, stable, and meaningful numerical solution can be derived from the given model.\n- **Objective:** The problem is valid. It is formulated using precise, quantitative, and objective language, free of ambiguity or subjective claims.\n\nThe problem formulation is self-contained, consistent, and scientifically sound. The test cases, including the edge case of $L=0$ in test case 5, are valid and serve to test the robustness of the derived model.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. We proceed to the solution.\n\nThe objective is to derive an analytical expression for the total misfolding probability, $R$, as a function of the given parameters, and then use it to compute the change, $\\Delta R$.\n\nThe total misfolding probability, $R$, can be determined using the law of total probability. There are two mutually exclusive pathways to the final state: either the folding nucleus forms within the dwell time $T$, or it does not.\n\nLet $N$ be the event that the folding nucleus forms within time $T$. The probability of this event is given as $P(N) = p_{\\text{nuc}}$.\nLet $N^c$ be the complementary event that the nucleus does not form. Its probability is $P(N^c) = 1 - p_{\\text{nuc}}$.\n\nLet $M$ be the event that the protein misfolds. The problem provides the conditional probabilities:\n- The probability of misfolding given that the nucleus has formed is $P(M|N) = \\beta$.\n- The probability of misfolding given that the nucleus has not formed is $P(M|N^c) = \\alpha$.\n\nAccording to the law of total probability, the total probability of misfolding $R = P(M)$ is:\n$$R = P(M|N)P(N) + P(M|N^c)P(N^c)$$\nSubstituting the known probabilities:\n$$R = \\beta \\cdot p_{\\text{nuc}} + \\alpha \\cdot (1 - p_{\\text{nuc}})$$\nWe are given $p_{\\text{nuc}} = 1 - e^{-k_f T}$. Substituting this expression into the equation for $R$:\n$$R = \\beta(1 - e^{-k_f T}) + \\alpha(1 - (1 - e^{-k_f T}))$$\n$$R = \\beta(1 - e^{-k_f T}) + \\alpha(e^{-k_f T})$$\n$$R = \\beta - \\beta e^{-k_f T} + \\alpha e^{-k_f T}$$\nThis simplifies to:\n$$R = \\beta + (\\alpha - \\beta)e^{-k_f T}$$\nThe dwell time $T$ is defined as $T = L/r$. The total misfolding probability as a function of the primary parameters is therefore:\n$$R(L, r, k_f, \\alpha, \\beta) = \\beta + (\\alpha - \\beta)e^{-k_f L / r}$$\n\nWe are tasked with finding the change in misfolding probability, $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$.\n$R_{\\text{before}}$ is the misfolding probability with the original translation rate $r_{\\text{before}}$:\n$$R_{\\text{before}} = \\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{before}}}$$\n$R_{\\text{after}}$ is the misfolding probability with the accelerated translation rate $r_{\\text{after}}$:\n$$R_{\\text{after}} = \\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{after}}}$$\n\nThe change, $\\Delta R$, is the difference:\n$$\\Delta R = \\left(\\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{after}}}\\right) - \\left(\\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{before}}}\\right)$$\nThe term $\\beta$ cancels out, yielding the final expression for $\\Delta R$:\n$$\\Delta R = (\\alpha - \\beta)\\left(e^{-k_f L / r_{\\text{after}}} - e^{-k_f L / r_{\\text{before}}}\\right)$$\n\nThis expression is physically intuitive. The sign of $\\Delta R$ depends on two factors: the sign of $(\\alpha - \\beta)$ and the sign of the term in parentheses. An accelerated translation rate means $r_{\\text{after}} > r_{\\text{before}}$. For a non-zero window length $L>0$, this implies that the dwell time decreases, $L/r_{\\text{after}} < L/r_{\\text{before}}$. Because the argument of the exponential function is negative, this leads to $e^{-k_f L / r_{\\text{after}}} > e^{-k_f L / r_{\\text{before}}}$. Consequently, the term in parentheses is positive.\nTherefore, if $\\alpha > \\beta$ (misfolding is more probable when nucleation fails), accelerating translation increases the overall misfolding probability ($\\Delta R > 0$). This is because less time is available for the protective folding nucleus to form. Conversely, if $\\alpha < \\beta$, acceleration would decrease misfolding. If $\\alpha=\\beta$, translation speed has no effect on the final misfolding outcome in this model.\n\nThe algorithm for the solution is to apply this final derived formula to each test case provided. For edge cases where $L=0$ or $r_{\\text{after}} = r_{\\text{before}}$, the term in parentheses becomes $e^0 - e^0 = 0$ or the terms are identical, resulting in $\\Delta R = 0$, which is correct.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the co-translational folding misfolding probability problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, r_before, r_after, k_f, alpha, beta)\n    test_cases = [\n        (15, 5, 15, 0.3, 0.8, 0.02),\n        (20, 10, 10, 0.25, 0.7, 0.05),\n        (30, 3, 12, 0.4, 0.9, 0.01),\n        (5, 8, 18, 0.05, 0.85, 0.02),\n        (0, 6, 12, 0.5, 0.6, 0.0)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, r_before, r_after, k_f, alpha, beta = case\n\n        # The change in misfolding probability is given by the formula:\n        # Delta_R = (alpha - beta) * (exp(-k_f * L / r_after) - exp(-k_f * L / r_before))\n        # This formula is derived from the total probability of misfolding R, which is:\n        # R = beta + (alpha - beta) * exp(-k_f * L / r)\n\n        # Handle edge cases for clarity and efficiency, although the general formula is robust.\n        # If L=0 or rates are the same, dwell times are equal or zero, so no change.\n        if L == 0 or r_before == r_after:\n            delta_R = 0.0\n        # The rates r must be non-zero for dwell time T = L/r to be meaningful.\n        # The problem statement givens do not include zero rates, so we don't need to handle DivisionByZeroError.\n        else:\n            term_alpha_beta_diff = alpha - beta\n            \n            exponent_before = -k_f * L / r_before\n            exponent_after = -k_f * L / r_after\n            \n            exp_diff = np.exp(exponent_after) - np.exp(exponent_before)\n            \n            delta_R = term_alpha_beta_diff * exp_diff\n\n        # Format the result to exactly six decimal places as a string.\n        results.append(f\"{delta_R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2772556"}]}