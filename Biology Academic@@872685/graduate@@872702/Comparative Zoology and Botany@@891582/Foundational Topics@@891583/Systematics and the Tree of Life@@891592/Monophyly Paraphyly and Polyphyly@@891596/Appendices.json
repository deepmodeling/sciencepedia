{"hands_on_practices": [{"introduction": "Before we can interpret the evolutionary history of characters on a tree, we must first have a rigorous command of the tree's topology itself. This exercise hones your ability to work with the formal, combinatorial definitions of phylogenetic groups. You will be asked to classify all possible subsets of taxa based on a specific, and intentionally non-standard, set of definitions, forcing you to reason from first principles rather than relying on textbook conventions [@problem_id:2591344]. This practice is invaluable for developing the precision required to understand and critique the foundational axioms of different phylogenetic methods.", "problem": "Consider the rooted phylogenetic tree $\\mathcal{T}$ on the leaf set $L=\\{A,B,C,D,E\\}$ given in Newick form by $\\mathcal{T}=((A,(B,C)),(D,E))$. Treat $\\mathcal{T}$ as a strictly bifurcating (binary), rooted tree. For any node $v$ of $\\mathcal{T}$, let $L(v)$ denote the set of descendant leaves of $v$.\n\nUsing precise, formal criteria grounded in the standard combinatorial formalization of phylogenetic groups on rooted trees:\n- A subset $S \\subseteq L$ is monophyletic (a clade) if there exists a node $v$ with $S=L(v)$.\n- A subset $S \\subseteq L$ is paraphyletic if it is convex but not monophyletic, where convex on a rooted tree means there exists a node $v$ whose set of children is $\\{v_{1},\\dots,v_{k}\\}$ with corresponding child clusters $L(v_{1}),\\dots,L(v_{k})$, and $S$ can be written as a union of some but not all of these child clusters.\n- A subset $S \\subseteq L$ is polyphyletic if it is not convex.\n\nEnumerate all monophyletic leaf subsets of $L$ for $\\mathcal{T}$ and, by appeal to the above definitions, label every non-monophyletic subset as paraphyletic or polyphyletic, justifying each classification by structural arguments on $\\mathcal{T}$. Let $M$ be the total number of monophyletic (clade) subsets, $P$ the total number of paraphyletic subsets, and $Q$ the total number of polyphyletic subsets, each counted over all non-empty subsets of $L$.\n\nCompute the single scalar\n$$\nS \\;=\\; 3M \\;+\\; 5P \\;+\\; 7Q\\,.\n$$\nProvide an exact value for $S$ with no rounding.", "solution": "The problem will be validated against the specified criteria before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Leaf Set**: $L = \\{A, B, C, D, E\\}$.\n- **Phylogenetic Tree**: A strictly bifurcating, rooted tree $\\mathcal{T}$ given in Newick form by $\\mathcal{T}=((A,(B,C)),(D,E))$.\n- **Descendant Leaves**: For any node $v$ of $\\mathcal{T}$, $L(v)$ denotes the set of descendant leaves of $v$.\n- **Monophyletic Definition**: A subset $S \\subseteq L$ is monophyletic (a clade) if there exists a node $v$ with $S=L(v)$.\n- **Paraphyletic Definition**: A subset $S \\subseteq L$ is paraphyletic if it is convex but not monophyletic.\n- **Convexity Definition**: A subset $S$ is convex on a rooted tree if there exists a node $v$ whose set of children is $\\{v_1, \\dots, v_k\\}$ with corresponding child clusters $L(v_1), \\dots, L(v_k)$, and $S$ can be written as a union of some but not all of these child clusters.\n- **Polyphyletic Definition**: A subset $S \\subseteq L$ is polyphyletic if it is not convex.\n- **Quantities to Count**: $M$ is the total number of non-empty monophyletic subsets. $P$ is the total number of non-empty paraphyletic subsets. $Q$ is the total number of non-empty polyphyletic subsets.\n- **Task**: Compute the scalar $S = 3M + 5P + 7Q$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in combinatorial phylogenetics. It is well-posed, providing a specific tree and precise, albeit non-standard, definitions for the required classifications. The language is objective and unambiguous. The definitions are self-contained and do not lead to internal contradictions, although they may produce results that differ from what standard definitions in the literature would yield. This is not a flaw; it is a feature of the problem to test adherence to provided axiomatic definitions. The problem is solvable and requires rigorous application of the given rules. It is not trivial, as it requires careful interpretation of these rules.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A complete, reasoned solution will be provided.\n\n### Solution\nThe task is to classify all non-empty subsets of the leaf set $L=\\{A,B,C,D,E\\}$ for the tree $\\mathcal{T}=((A,(B,C)),(D,E))$ and then compute a weighted sum of the counts of each category.\n\nFirst, we must visualize the structure of the rooted binary tree $\\mathcal{T}$. The Newick string $\\mathcal{T}=((A,(B,C)),(D,E))$ defines the following topology: The root, let us call it $r$, has two children. The first child, $v_1$, is the most recent common ancestor (MRCA) of $\\{A,B,C\\}$. The second child, $v_2$, is the MRCA of $\\{D,E\\}$. The node $v_1$ has two children: the leaf $A$ and an internal node $v_3$, which is the MRCA of $\\{B,C\\}$. The node $v_3$ has children $B$ and $C$. The node $v_2$ has children $D$ and $E$. The leaves are the terminal nodes $A, B, C, D, E$.\n\nThe total number of non-empty subsets of $L$ is $2^{|L|} - 1 = 2^5 - 1 = 31$. These $31$ subsets must be classified.\n\n**1. Enumeration of Monophyletic Subsets ($M$)**\nA subset $S$ is monophyletic if it is the set of all descendant leaves of some node $v$ in $\\mathcal{T}$, i.e., $S=L(v)$. We enumerate these sets for every node in the tree (including the leaves themselves, which are terminal nodes).\n- For the leaf nodes: $L(A) = \\{A\\}$, $L(B) = \\{B\\}$, $L(C) = \\{C\\}$, $L(D) = \\{D\\}$, $L(E) = \\{E\\}$.\n- For the internal node $v_3 = \\text{MRCA}(B,C)$: $L(v_3) = \\{B,C\\}$.\n- For the internal node $v_2 = \\text{MRCA}(D,E)$: $L(v_2) = \\{D,E\\}$.\n- For the internal node $v_1 = \\text{MRCA}(A,B,C)$: $L(v_1) = \\{A,B,C\\}$.\n- For the root node $r = \\text{MRCA}(A,B,C,D,E)$: $L(r) = \\{A,B,C,D,E\\}$.\n\nThere are $5$ singleton clades, $3$ non-trivial proper clades, and $1$ clade for the entire tree. The set of all monophyletic subsets is $\\mathcal{M} = \\{\\{A\\}, \\{B\\}, \\{C\\}, \\{D\\}, \\{E\\}, \\{B,C\\}, \\{D,E\\}, \\{A,B,C\\}, \\{A,B,C,D,E\\}\\}$.\nThe total number of monophyletic subsets is $M = |\\mathcal{M}| = 9$.\n\n**2. Analysis of Paraphyletic Subsets ($P$)**\nA subset is paraphyletic if it is convex but not monophyletic. We must first identify all convex sets according to the problem's definition.\nA subset $S$ is convex if there exists a node $v$ with children $\\{v_1, \\dots, v_k\\}$ such that $S$ is a union of a proper non-empty subset of the child clusters $\\{L(v_1), \\dots, L(v_k)\\}$.\nSince $\\mathcal{T}$ is a strictly bifurcating tree, any internal node $v$ has exactly two children, $v_{c1}$ and $v_{c2}$. Therefore, a set $S$ is convex if for some internal node $v$, $S=L(v_{c1})$ or $S=L(v_{c2})$.\nLet's list all such sets for each internal node of $\\mathcal{T}$:\n- For node $v_3$ (children $B,C$): The convex sets generated are $L(B)=\\{B\\}$ and $L(C)=\\{C\\}$.\n- For node $v_2$ (children $D,E$): The convex sets generated are $L(D)=\\{D\\}$ and $L(E)=\\{E\\}$.\n- For node $v_1$ (children $A,v_3$): The convex sets generated are $L(A)=\\{A\\}$ and $L(v_3)=\\{B,C\\}$.\n- For the root node $r$ (children $v_1,v_2$): The convex sets generated are $L(v_1)=\\{A,B,C\\}$ and $L(v_2)=\\{D,E\\}$.\n\nThe complete set of convex subsets, $\\mathcal{C}$, is the union of all such generated sets:\n$\\mathcal{C} = \\{\\{A\\}, \\{B\\}, \\{C\\}, \\{D\\}, \\{E\\}, \\{B,C\\}, \\{D,E\\}, \\{A,B,C\\}\\}$.\nBy definition, a set is paraphyletic if it is in $\\mathcal{C}$ but not in $\\mathcal{M}$.\nUpon inspection, every set in $\\mathcal{C}$ is a set of descendants of some node, and thus is monophyletic. Specifically, $\\mathcal{C}$ is a proper subset of $\\mathcal{M}$ (it contains all monophyletic sets except the full set $L(r)$).\nTherefore, there are no sets which are convex but not monophyletic. The set of paraphyletic subsets is empty.\nThe number of paraphyletic subsets is $P=0$.\n\n**3. Analysis of Polyphyletic Subsets ($Q$)**\nThe problem directs us to classify every non-monophyletic subset as either paraphyletic or polyphyletic.\nThe total number of non-empty subsets is $31$.\nThe number of monophyletic subsets is $M=9$.\nThe number of non-monophyletic subsets is $31 - 9 = 22$.\nThese $22$ subsets must be partitioned into paraphyletic and polyphyletic sets.\nNumber of paraphyletic subsets, $P$, is $0$.\nTherefore, all $22$ non-monophyletic subsets must be polyphyletic.\nSo, the number of polyphyletic subsets is $Q=22$.\n\nThis is consistent with the provided definition of a polyphyletic set as \"not convex\". A non-monophyletic set must be classified as polyphyletic if it is not convex. As established, any convex set is monophyletic. Consequently, any non-monophyletic set must be non-convex, and is therefore polyphyletic by definition. This confirms that all $22$ non-monophyletic sets are polyphyletic.\n\n**4. Computation of the Scalar $S$**\nWe are given the values $M=9$, $P=0$, and $Q=22$. We substitute these into the expression for $S$:\n$$ S = 3M + 5P + 7Q $$\n$$ S = 3(9) + 5(0) + 7(22) $$\n$$ S = 27 + 0 + 154 $$\n$$ S = 181 $$\nThe calculation is straightforward. The final value for $S$ is $181$.", "answer": "$$\n\\boxed{181}\n$$", "id": "2591344"}, {"introduction": "Phylogenetic groups are not just abstract topological features; they are hypotheses supported or refuted by character evidence. This problem transitions from pure topology to the complexities of character-based inference, using the principle of Maximum Parsimony ($MP$). It presents a scenario where the most parsimonious mapping of a character is not unique, leading to a profound ambiguity in interpretation [@problem_id:2591308]. Engaging with this exercise will reveal how a single character pattern can support conflicting evolutionary histories—in this case, paraphyly versus polyphyly—a crucial insight for any scientist evaluating character data on a phylogeny.", "problem": "A rooted phylogenetic tree on five terminal taxa is given by the fully parenthesized representation $(((A,B),(C,D)),E)$, with $E$ as the outgroup. Consider a single, unordered, binary morphological character with observed tip states: $A=1$, $B=1$, $C=1$, $D=0$, $E=0$. Using outgroup polarization, the principle of Maximum Parsimony (MP), and the definitions of monophyly, paraphyly, and polyphyly grounded in the Most Recent Common Ancestor (MRCA), determine which classificatory statement about the set of taxa with state $1$ is best supported by the tree and character mapping.\n\nBase concepts to use:\n- A monophyletic group (clade) is a set of taxa that includes a common ancestor and all of its descendants.\n- A paraphyletic group includes a common ancestor and some, but not all, of its descendants.\n- A polyphyletic group is assembled from taxa whose most recent common ancestor is not itself included in the group defined by the character state, typically requiring multiple independent origins of the defining state.\n- Under Maximum Parsimony, the preferred character mapping minimizes the total number of state changes on the tree, with gains and losses of equal cost unless otherwise specified, and outgroup rooting polarizes the ancestral state at the root.\n\nWhich option is best supported?\n\nA. The set $\\{A,B,C\\}$ is monophyletic on the given rooted tree.\n\nB. The set $\\{A,B,C\\}$ is paraphyletic under all equally parsimonious reconstructions.\n\nC. The set $\\{A,B,C\\}$ is polyphyletic under all equally parsimonious reconstructions.\n\nD. The set $\\{A,B,C\\}$ is non-monophyletic; both paraphyly and polyphyly are possible under equally parsimonious mappings with a minimum of $2$ changes.", "solution": "The problem statement will be validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Tree Topology**: A rooted phylogenetic tree on five terminal taxa given by the Newick format $(((A,B),(C,D)),E)$.\n- **Outgroup**: Taxon $E$ is the designated outgroup.\n- **Character Data**: A single, unordered, binary morphological character with the following observed states at the tips: $S(A)=1$, $S(B)=1$, $S(C)=1$, $S(D)=0$, $S(E)=0$.\n- **Group of Interest**: The set of taxa with state $1$, which is $\\{A,B,C\\}$.\n- **Methodology**: Maximum Parsimony (MP), with outgroup polarization used to infer the root state.\n- **Definitions**:\n    - **Monophyletic**: Includes a common ancestor and all of its descendants.\n    - **Paraphyletic**: Includes a common ancestor and some, but not all, of its descendants.\n    - **Polyphyletic**: The Most Recent Common Ancestor (MRCA) of the group's members does not possess the defining character state, implying multiple independent origins.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the principles of phylogenetic systematics, a core discipline in comparative biology. The concepts of phylogenetic trees, character mapping, maximum parsimony, and the classification of groups (monophyly, paraphyly, polyphyly) are standard and accurately represented.\n- **Well-Posedness**: The problem is well-posed. The tree topology is unambiguous, character states are explicitly provided, the analytical method (MP with outgroup polarization) is specified, and the question is precise. This setup ensures that a unique and logical solution can be derived.\n- **Objectivity**: The problem statement is objective and devoid of subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, self-contained, and well-posed. It is valid. A solution will now be derived.\n\n### Derivation of Solution\nThe task is to determine the phylogenetic status (monophyletic, paraphyletic, or polyphyletic) of the set of taxa possessing character state $1$, which is the set $\\{A,B,C\\}$. This requires mapping the character evolution onto the provided tree topology under the principle of Maximum Parsimony.\n\nThe tree topology $(((A,B),(C,D)),E)$ can be visualized. Let us denote the internal nodes (ancestors) as follows:\n- $v_{AB} = \\text{MRCA}(A, B)$\n- $v_{CD} = \\text{MRCA}(C, D)$\n- $v_{ABCD} = \\text{MRCA}(A, B, C, D)$\n- $v_{Root} = \\text{MRCA}(A, B, C, D, E)$\n\nThe character states are $S(A)=1$, $S(B)=1$, $S(C)=1$, $S(D)=0$, $S(E)=0$.\n\n**1. Determine the Parsimony Score**\nWe use the Fitch algorithm (or equivalent logic) to find the minimum number of state changes (the parsimony score, $L$).\nThe bottom-up pass assigns a set of possible states to each internal node:\n- For $v_{AB}$, children have states $\\{1\\}$ and $\\{1\\}$. Intersection is $\\{1\\}$. State set is $\\{1\\}$.\n- For $v_{CD}$, children have states $\\{1\\}$ and $\\{0\\}$. Intersection is empty. Union is $\\{0,1\\}$. State set is $\\{0,1\\}$. This step adds $1$ to the score.\n- For $v_{ABCD}$, children are $v_{AB}$ with state set $\\{1\\}$ and $v_{CD}$ with state set $\\{0,1\\}$. Intersection is $\\{1\\}$. State set is $\\{1\\}$.\n- For $v_{Root}$, children are $v_{ABCD}$ with state set $\\{1\\}$ and $E$ with state set $\\{0\\}$. Intersection is empty. Union is $\\{0,1\\}$. State set is $\\{0,1\\}$. This step adds $1$ to the score.\n\nThe total minimum number of changes (parsimony score) is $L = 1 + 1 = 2$.\n\n**2. Reconstruct Ancestral States for all Most Parsimonious Reconstructions (MPRs)**\nWe need to find all assignments of states to internal nodes that result in exactly $2$ changes. The problem mandates \"outgroup polarization,\" which means the state of the outgroup, $S(E)=0$, determines the state at the root. Thus, we must set $S(v_{Root})=0$.\n\nWe now analyze the possible state assignments for the other internal nodes that are consistent with $S(v_{Root})=0$ and $L=2$.\n\n**Scenario 1: The \"Paraphyly\" Reconstruction (DELTRAN-like optimization)**\nThis scenario posits a single origin of state $1$ followed by a reversal.\n- $S(v_{Root}) = 0$.\n- For state $1$ to appear in the ingroup $\\{A,B,C,D\\}$, it must originate on the branch leading to $v_{ABCD}$. So, $S(v_{ABCD})=1$. This is change #1: $0 \\to 1$.\n- For the clade $(A,B)$, with $S(A)=1$ and $S(B)=1$, the most parsimonious assignment for their ancestor is $S(v_{AB})=1$. This involves no additional changes from its parent $v_{ABCD}$.\n- For the clade $(C,D)$, with parent $v_{ABCD}$ having state $1$, we consider $v_{CD}$. To satisfy the states of its children $S(C)=1$ and $S(D)=0$, we can set $S(v_{CD})=1$. This involves no change from its parent $v_{ABCD}$. The state $0$ in taxon $D$ must then be explained by a reversal on the terminal branch leading to $D$. This is change #2: $1 \\to 0$.\n- **Summary of MPR 1**: A single gain of state $1$ on the branch leading to $v_{ABCD}$, and a single loss (reversal) of state $1$ on the branch leading to $D$. The total number of changes is $2$.\n- **Interpretation**: The MRCA of the group $\\{A,B,C\\}$ is $v_{ABCD}$. In this reconstruction, $S(v_{ABCD})=1$. The group $\\{A,B,C\\}$ is formed from an ancestor with state $1$ ($v_{ABCD}$), but excludes one of that ancestor's descendants ($D$), which lost the character. This is the definition of a **paraphyletic** group.\n\n**Scenario 2: The \"Polyphyly\" Reconstruction (ACCTRAN-like optimization)**\nThis scenario posits multiple independent origins of state $1$.\n- $S(v_{Root}) = 0$.\n- Let us assume state $1$ does not arise on the branch leading to $v_{ABCD}$. We set $S(v_{ABCD})=0$. This involves no change from the root.\n- To explain $S(A)=1$ and $S(B)=1$, state $1$ must originate on the branch leading to their ancestor, $v_{AB}$. So, $S(v_{AB})=1$. This is change #1: $0 \\to 1$ on the branch $v_{ABCD} \\to v_{AB}$.\n- For clade $(C,D)$, its parent $v_{ABCD}$ has state $0$. We can set $S(v_{CD})=0$ to match its child $D$ and its parent. This involves no change.\n- To explain $S(C)=1$, state $1$ must originate independently on the terminal branch leading to $C$. This is change #2: $0 \\to 1$ on the branch $v_{CD} \\to C$.\n- **Summary of MPR 2**: Two independent gains (parallelisms) of state $1$: one on the branch to $v_{AB}$ and one on the branch to $C$. The total number of changes is $2$.\n- **Interpretation**: The MRCA of the group $\\{A,B,C\\}$ is $v_{ABCD}$. In this reconstruction, $S(v_{ABCD})=0$. The defining character state ($1$) is absent in the group's most recent common ancestor. The group is defined by a trait that evolved convergently. This is the definition of a **polyphyletic** group.\n\n**Conclusion of Analysis**\nThere are two equally parsimonious reconstructions, each requiring a minimum of $2$ changes. One reconstruction implies the group $\\{A,B,C\\}$ is paraphyletic. The other implies the group $\\{A,B,C\\}$ is polyphyletic. In neither case is the group monophyletic, as the full clade descended from $v_{ABCD}$ is $\\{A,B,C,D\\}$. Therefore, the phylogenetic status of the group $\\{A,B,C\\}$ is ambiguous under maximum parsimony.\n\n### Evaluation of Options\n\n**A. The set $\\{A,B,C\\}$ is monophyletic on the given rooted tree.**\nThis is incorrect. The Most Recent Common Ancestor of $\\{A,B,C\\}$ is $v_{ABCD}$, whose complete set of descendants is $\\{A,B,C,D\\}$. The group $\\{A,B,C\\}$ excludes taxon $D$, thus it is not monophyletic.\n\n**B. The set $\\{A,B,C\\}$ is paraphyletic under all equally parsimonious reconstructions.**\nThis is incorrect. While one MPR supports paraphyly, there exists another equally parsimonious reconstruction (MPR 2) that supports polyphyly. The statement \"under all\" is false.\n\n**C. The set $\\{A,B,C\\}$ is polyphyletic under all equally parsimonious reconstructions.**\nThis is incorrect. While one MPR supports polyphyly, there exists another equally parsimonious reconstruction (MPR 1) that supports paraphyly. The statement \"under all\" is false.\n\n**D. The set $\\{A,B,C\\}$ is non-monophyletic; both paraphyly and polyphyly are possible under equally parsimonious mappings with a minimum of $2$ changes.**\nThis statement is fully consistent with our analysis.\n- The set is indeed non-monophyletic.\n- There are two equally parsimonious scenarios (MPRs), one implying paraphyly and the other polyphyly.\n- The minimum number of changes is correctly stated as $2$.\nThis option is the most accurate and complete description of the situation.", "answer": "$$\\boxed{D}$$", "id": "2591308"}, {"introduction": "Modern phylogenetics operates on a massive scale, with trees containing thousands or millions of taxa. This requires us to translate our conceptual understanding of phylogenetic principles into efficient computational procedures. This problem challenges you to design an algorithm that can rapidly determine if a given set of taxa forms a monophyletic group, leveraging pre-computed tree data structures to achieve optimal performance [@problem_id:2591273]. By bridging the gap between abstract theory and practical implementation, this exercise solidifies the definition of monophyly and provides a window into the algorithmic engine that drives large-scale comparative biology.", "problem": "You are given one or more rooted trees representing hypothesized phylogenies in comparative zoology and botany. A subset of leaves $S$ is monophyletic (forms a clade) if and only if there exists a node $v$ in the tree such that the set of descendant leaves of $v$ is exactly $S$. Using only fundamental definitions from phylogenetics and rooted tree theory, design a program that implements an $O(|S|)$-time decision procedure per query to determine whether a given subset of leaves $S$ is monophyletic, assuming an $O(1)$-time lowest common ancestor (LCA) query data structure obtained via preprocessing. Your procedure must be derived from the following base principles:\n\n- Rooted tree basics: Every node has a unique path to the root. A node $u$ is an ancestor of a node $v$ if and only if $u$ lies on the unique path from $v$ to the root.\n- Leaves are nodes with outdegree $0$. The leaf set of a node $v$ is the set of all leaves that are descendants of $v$.\n- A subset $S$ of leaves is monophyletic if and only if there exists a node $v$ whose leaf set equals $S$.\n- The lowest common ancestor (LCA) of nodes $x$ and $y$, denoted $\\mathrm{LCA}(x,y)$, is the unique node that is an ancestor of both $x$ and $y$ and has maximal depth.\n\nYour program must preprocess each rooted tree to support $O(1)$-time $\\mathrm{LCA}$ queries via a standard Euler tour plus range minimum query construction, and maintain, for every node $v$, the number of descendant leaves in the subtree rooted at $v$. For each query subset $S$, your decision routine must run in $O(|S|)$ time and may use only the following constant-time operations derived from preprocessing: $\\mathrm{LCA}$ queries, ancestor checks using discovery/finish times, and reading precomputed descendant leaf counts.\n\nThe required final output is a single line containing the results for all test cases as a comma-separated list enclosed in square brackets. Each result must be a boolean. No physical units or angles are involved.\n\nUse the following test suite, which includes a variety of cases (happy path, boundary cases, and edge cases). Each tree is specified by its adjacency list of children for each node index. All node indices are integers starting at $0$, and the root is node $0$ in every tree.\n\nTree $\\mathcal{T}_1$ adjacency (parent $\\to$ ordered list of children):\n- Node $0$: children $[1,2]$\n- Node $1$: children $[3,4]$\n- Node $2$: children $[5,6]$\n- Node $3$: children $[7,8]$\n- Node $4$: children $[9]$\n- Node $5$: children $[10,11]$\n- Node $6$: children $[12]$\n- Nodes $7,8,9,10,11,12$: children $[]$\n\nIn $\\mathcal{T}_1$, the leaves are nodes $[7,8,9,10,11,12]$. Evaluate the following subsets:\n- $S^{(1)}_1 = [7,8]$\n- $S^{(1)}_2 = [10,11]$\n- $S^{(1)}_3 = [7,8,9]$\n- $S^{(1)}_4 = [7,10]$\n- $S^{(1)}_5 = [7]$\n- $S^{(1)}_6 = [7,8,9,10]$\n- $S^{(1)}_7 = [7,8,9,10,11,12]$\n\nTree $\\mathcal{T}_2$ adjacency (parent $\\to$ ordered list of children):\n- Node $0$: children $[1,2,3]$\n- Node $1$: children $[4,5]$\n- Node $2$: children $[6]$\n- Node $3$: children $[7,8]$\n- Node $4$: children $[9,10]$\n- Node $5$: children $[11]$\n- Node $6$: children $[12,13]$\n- Node $7$: children $[14]$\n- Node $8$: children $[15]$\n- Nodes $9,10,11,12,13,14,15$: children $[]$\n\nIn $\\mathcal{T}_2$, the leaves are nodes $[9,10,11,12,13,14,15]$. Evaluate the following subsets:\n- $S^{(2)}_1 = [9,10]$\n- $S^{(2)}_2 = [12,13]$\n- $S^{(2)}_3 = [14,15]$\n- $S^{(2)}_4 = [9,10,12]$\n- $S^{(2)}_5 = [9,11]$\n- $S^{(2)}_6 = [9,10,11,12,13,14,15]$\n\nDecision rule to implement, derived from the base principles: For a given subset $S$ of leaves in a tree, let $L = \\mathrm{LCA}$ of all nodes in $S$. Decide that $S$ is monophyletic if and only if both of the following conditions hold:\n- Every element of $S$ is a descendant of $L$.\n- The number of descendant leaves of $L$ equals $|S|$.\n\nYour program should produce a single line of output containing the results for all $13$ queries above, as a comma-separated list enclosed in square brackets (for example, $[ \\dots ]$). The elements must be booleans in the same order as listed above across $\\mathcal{T}_1$ followed by $\\mathcal{T}_2$.", "solution": "The problem statement is subjected to validation and is deemed valid. It is scientifically grounded in the principles of phylogenetics and graph theory, well-posed with clear inputs and a required output format, and objective in its formulation. All provided definitions and constraints are self-contained and consistent. We may therefore proceed with the derivation and implementation of a solution.\n\nThe problem requires a decision procedure to determine if a given subset of leaves $S$ in a rooted tree is monophyletic. A set $S$ is defined as monophyletic if there exists a node $v$ such that the set of all leaf descendants of $v$ is precisely $S$. The procedure must operate in $O(|S|)$ time, leveraging precomputed data structures that provide $O(1)$ time for Lowest Common Ancestor (LCA) queries, ancestor checks, and lookups of descendant leaf counts.\n\nThe solution is structured into two phases: a one-time preprocessing phase for each tree, and a query phase for each subset $S$.\n\n**1. Preprocessing Phase**\n\nThe goal of this phase is to compute all necessary information about the tree structure to support fast queries. For a tree with $N$ nodes, this phase runs once per tree.\n\n**1.1. Tree Traversal and Data Collection**\nA single Depth-First Search (DFS) traversal from the root node is sufficient to collect several key metrics for each node $u$:\n- **Depth $d(u)$**: The distance from the root to $u$.\n- **Discovery and Finish Times ($t_{in}(u)$, $t_{out}(u)$)**: These are timestamps from a global timer, recorded upon first visiting $u$ and after visiting all of $u$'s descendants, respectively. They allow for an ancestor check in $O(1)$ time: a node $u$ is an ancestor of a node $v$ if and only if $t_{in}(u) \\le t_{in}(v)$ and $t_{out}(u) \\ge t_{out}(v)$.\n- **Euler Tour**: An array storing the sequence of nodes visited during the DFS traversal, including revisits when backtracking. The Euler tour of a tree with $N$ nodes has a length of $2N-1$. We also maintain a parallel array storing the depth of each node in the tour sequence.\n- **First Visit Index $f(u)$**: The index of the first occurrence of node $u$ in the Euler tour.\n\n**1.2. Descendant Leaf Count**\nFor each node $u$, we must compute the number of leaves in the subtree rooted at $u$, denoted $c_{leaf}(u)$. This is achieved via a post-order traversal (which can be integrated into the same initial DFS). The logic is as follows:\n- If node $u$ is a leaf, $c_{leaf}(u) = 1$.\n- If node $u$ is not a leaf, $c_{leaf}(u) = \\sum_{v \\in \\text{children}(u)} c_{leaf}(v)$.\n\n**1.3. Lowest Common Ancestor (LCA) Precomputation**\nThe problem of finding the LCA of two nodes $u$ and $v$ can be reduced to a Range Minimum Query (RMQ) problem on the Euler tour. The LCA of $u$ and $v$ is the node with the minimum depth in the Euler tour between the first visit to $u$ and the first visit to $v$.\nTo answer RMQ in $O(1)$ time, we construct a sparse table data structure on the array of depths from the Euler tour. Let the length of the Euler tour be $M = 2N-1$. The sparse table $ST$ of size $M \\times \\lfloor \\log_2 M \\rfloor$ is precomputed in $O(M \\log M)$ time. $ST[i][j]$ stores the index of the minimum element in the depth tour in the range $[i, i + 2^j - 1]$. With this table, an RMQ query, and thus an LCA query, takes $O(1)$ time.\n\nThe total preprocessing time complexity is dominated by the sparse table construction, which is $O(N \\log N)$.\n\n**2. Query Phase**\n\nFor each given subset of leaves $S$, we apply the specified decision rule. The procedure must complete in $O(|S|)$ time.\n\n**2.1. Handling Base Cases**\n- If $S$ is an empty set, it cannot be monophyletic, as there is no node whose set of descendant leaves is empty (leaves themselves are descendants). The result is **False**.\n- If $|S|=1$, say $S = \\{s_1\\}$, the set is trivially monophyletic. The node $v$ is $s_1$ itself. The LCA of $\\{s_1\\}$ is $s_1$. The number of leaves descendant from $s_1$ is $1$, which equals $|S|$. The result is **True**.\n\n**2.2. Decision Procedure for $|S|  1$**\n\nThe decision rule to be implemented is: a set $S$ is monophyletic if and only if both of the following conditions hold for $L = \\mathrm{LCA}(S)$:\n1. Every element of $S$ is a descendant of $L$.\n2. The number of descendant leaves of $L$, $c_{leaf}(L)$, equals $|S|$.\n\nThe algorithm proceeds as follows:\n1.  **Compute $L = \\mathrm{LCA}(S)$**: The LCA of a set of nodes $\\{s_1, s_2, \\dots, s_k\\}$ can be computed iteratively: $L = \\mathrm{LCA}(\\mathrm{LCA}(\\dots \\mathrm{LCA}(s_1, s_2), \\dots), s_k)$. As each pairwise LCA query is $O(1)$, this step takes $O(|S|)$ time.\n2.  **Verify Condition 1**: Iterate through each node $s \\in S$ and check if $L$ is an ancestor of $s$ using the precomputed $t_{in}$ and $t_{out}$ times. This check is $O(1)$ for each node, totaling $O(|S|)$ for the set. Note that by the definition of $\\mathrm{LCA}(S)$, this condition is guaranteed to be true if $L$ is computed correctly. However, per the strict problem specification, this check must be explicitly implemented.\n3.  **Verify Condition 2**: Compare the precomputed descendant leaf count for $L$, $c_{leaf}(L)$, with the size of the set, $|S|$. This is an $O(1)$ operation.\n\nIf both conditions are met, the set $S$ is monophyletic; otherwise, it is not. The total time complexity for the query is dominated by the calculation of $L$ and the ancestor checks, resulting in an overall complexity of $O(|S|)$, which meets the problem's requirement.\n\nThis concludes the logical design of the algorithm. The final step is its implementation.", "answer": "```python\nimport numpy as np\nimport math\n\nclass Phylogeny:\n    \"\"\"\n    Represents a rooted tree and provides methods for phylogenetic analysis.\n    Preprocessing is done upon initialization to support fast queries.\n    \"\"\"\n    def __init__(self, adj_dict, root):\n        # Determine the number of nodes from the adjacency list\n        all_nodes = set(adj_dict.keys())\n        for children in adj_dict.values():\n            for child in children:\n                all_nodes.add(child)\n        self.num_nodes = max(all_nodes) + 1 if all_nodes else 0\n        if self.num_nodes == 0:\n            return\n\n        self.adj = [[] for _ in range(self.num_nodes)]\n        for parent, children in adj_dict.items():\n            self.adj[parent] = children\n\n        self.root = root\n        \n        # Data structures for preprocessing\n        self.tin = np.zeros(self.num_nodes, dtype=int)\n        self.tout = np.zeros(self.num_nodes, dtype=int)\n        self.depth = np.zeros(self.num_nodes, dtype=int)\n        self.first_visit = np.zeros(self.num_nodes, dtype=int)\n        self.euler_tour = []\n        self.depth_tour = []\n        self.leaf_count = np.zeros(self.num_nodes, dtype=int)\n        \n        # Perform traversals to populate data structures\n        self.time = 0\n        self._dfs_precompute(self.root, 0)\n        self._dfs_leaf_count(self.root)\n        \n        # Build sparse table for RMQ/LCA\n        self._preprocess_lca()\n\n    def _dfs_precompute(self, u, d):\n        \"\"\"\n        Performs a DFS to compute discovery/finish times, depth, and Euler tour.\n        \"\"\"\n        self.tin[u] = self.time\n        self.time += 1\n        self.depth[u] = d\n        self.first_visit[u] = len(self.euler_tour)\n        self.euler_tour.append(u)\n        self.depth_tour.append(d)\n\n        for v in self.adj[u]:\n            self._dfs_precompute(v, d + 1)\n            self.euler_tour.append(u)\n            self.depth_tour.append(d)\n        \n        self.tout[u] = self.time\n        self.time += 1\n\n    def _dfs_leaf_count(self, u):\n        \"\"\"\n        Performs a post-order traversal to compute descendant leaf counts.\n        \"\"\"\n        if not self.adj[u]:  # Node is a leaf\n            self.leaf_count[u] = 1\n            return\n\n        count = 0\n        for v in self.adj[u]:\n            self._dfs_leaf_count(v)\n            count += self.leaf_count[v]\n        self.leaf_count[u] = count\n\n    def _preprocess_lca(self):\n        \"\"\"\n        Builds a sparse table for O(1) Range Minimum Queries on the Euler tour depths.\n        \"\"\"\n        tour_len = len(self.euler_tour)\n        if tour_len == 0:\n            return\n        \n        max_log = int(math.log2(tour_len)) + 1\n        self.st_indices = np.zeros((tour_len, max_log), dtype=int)\n        self.st_indices[:, 0] = np.arange(tour_len)\n        \n        for j in range(1, max_log):\n            for i in range(tour_len - (1  j) + 1):\n                idx1 = self.st_indices[i, j - 1]\n                idx2 = self.st_indices[i + (1  (j - 1)), j - 1]\n                if self.depth_tour[idx1]  self.depth_tour[idx2]:\n                    self.st_indices[i, j] = idx1\n                else:\n                    self.st_indices[i, j] = idx2\n\n    def _query_rmq_idx(self, start, end):\n        \"\"\"\n        Queries the sparse table for the index of the minimum depth in a given range.\n        \"\"\"\n        length = end - start + 1\n        k = int(math.log2(length))\n        idx1 = self.st_indices[start, k]\n        idx2 = self.st_indices[end - (1  k) + 1, k]\n        if self.depth_tour[idx1]  self.depth_tour[idx2]:\n            return idx1\n        else:\n            return idx2\n\n    def lca(self, u, v):\n        \"\"\"\n        Returns the Lowest Common Ancestor of nodes u and v in O(1).\n        \"\"\"\n        if u == v:\n            return u\n        u_visit, v_visit = self.first_visit[u], self.first_visit[v]\n        if u_visit > v_visit:\n            u_visit, v_visit = v_visit, u_visit\n        \n        min_depth_tour_idx = self._query_rmq_idx(u_visit, v_visit)\n        return self.euler_tour[min_depth_tour_idx]\n\n    def is_ancestor(self, u, v):\n        \"\"\"\n        Checks if node u is an ancestor of node v in O(1).\n        \"\"\"\n        return self.tin[u] = self.tin[v] and self.tout[u] >= self.tout[v]\n\n    def is_monophyletic(self, S):\n        \"\"\"\n        Determines if a subset of leaves S is monophyletic in O(|S|).\n        \"\"\"\n        if not S:\n            return False\n            \n        if len(S) == 1:\n            return True\n            \n        # Compute LCA of the entire set S\n        lca_of_s = S[0]\n        for i in range(1, len(S)):\n            lca_of_s = self.lca(lca_of_s, S[i])\n        \n        # Condition 1: Every element of S must be a descendant of the LCA.\n        # This is guaranteed by LCA definition but checked for strict adherence.\n        for node in S:\n            if not self.is_ancestor(lca_of_s, node):\n                return False\n        \n        # Condition 2: The number of descendant leaves of the LCA must equal |S|.\n        if self.leaf_count[lca_of_s] != len(S):\n            return False\n            \n        return True\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the monophyly check for each.\n    \"\"\"\n    test_cases = [\n        {\n            \"adj\": {0: [1, 2], 1: [3, 4], 2: [5, 6], 3: [7, 8], 4: [9], 5: [10, 11], 6: [12]},\n            \"root\": 0,\n            \"queries\": [\n                [7, 8], [10, 11], [7, 8, 9], [7, 10], [7], [7, 8, 9, 10], [7, 8, 9, 10, 11, 12]\n            ]\n        },\n        {\n            \"adj\": {0: [1, 2, 3], 1: [4, 5], 2: [6], 3: [7, 8], 4: [9, 10], 5: [11], 6: [12, 13], 7: [14], 8: [15]},\n            \"root\": 0,\n            \"queries\": [\n                [9, 10], [12, 13], [14, 15], [9, 10, 12], [9, 11], [9, 10, 11, 12, 13, 14, 15]\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        tree = Phylogeny(case[\"adj\"], case[\"root\"])\n        for query_set in case[\"queries\"]:\n            results.append(tree.is_monophyletic(query_set))\n\n    # Format output as a single comma-separated list of booleans in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2591273"}]}