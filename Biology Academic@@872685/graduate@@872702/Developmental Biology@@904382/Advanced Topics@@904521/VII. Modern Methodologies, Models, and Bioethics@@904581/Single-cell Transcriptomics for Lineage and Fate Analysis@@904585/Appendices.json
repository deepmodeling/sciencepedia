{"hands_on_practices": [{"introduction": "The journey from a raw sequencing file to meaningful biological insight begins with a critical gateway: quality control (QC). This step is essential for filtering out data from dead or stressed cells, empty droplets, or technical artifacts like multiplets, which can obscure true developmental trajectories. In this first practice, you will implement the core QC metrics used universally in single-cell transcriptomics analysis, learning to assess cellular health and data quality based on transcriptional output [@problem_id:2672354].", "problem": "You are given the task of implementing quality control for single-cell ribonucleic acid sequencing (scRNA-seq) counts at the single-cell level to support lineage and fate analysis. Base your reasoning on two foundational principles: (i) the Central Dogma of molecular biology, where messenger ribonucleic acid (mRNA) abundance reflects gene expression, and (ii) the design of unique molecular identifiers (UMIs) in scRNA-seq, which count captured transcript molecules and yield nonnegative integer counts per gene per cell. For each cell, you will be given a vector of nonnegative integer counts for a fixed set of genes and the indices of mitochondrial genes. Quality control relies on the following definitions grounded in well-tested practice: total UMI counts, number of detected genes, mitochondrial fraction, and zero fraction. These metrics are proxies for cell viability, complexity, and potential stress that would bias lineage and fate reconstruction.\n\nGiven a vector of counts $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$ with $x_i \\in \\mathbb{Z}_{\\ge 0}$, a set of mitochondrial gene indices $\\mathcal{M} \\subseteq \\{1,2,\\dots,N\\}$, and thresholds $c_{\\min}$, $c_{\\max}$, $g_{\\min}$, $f_{\\mathrm{mt},\\max}$, $f_{0,\\max}$, and $k_{\\min}$, define:\n- Total UMI count $T = \\sum_{i=1}^{N} x_i$.\n- Number of detected genes $G = \\left|\\{ i \\in \\{1,\\dots,N\\} : x_i \\ge k_{\\min} \\}\\right|$.\n- Mitochondrial fraction $f_{\\mathrm{mt}} = \\begin{cases} \\dfrac{\\sum_{i \\in \\mathcal{M}} x_i}{T}, & \\text{if } T > 0 \\\\ 0, & \\text{if } T = 0 \\end{cases}$.\n- Zero fraction $f_0 = \\dfrac{\\left|\\{ i \\in \\{1,\\dots,N\\} : x_i = 0 \\}\\right|}{N}$.\n\nA cell passes quality control if and only if all of the following hold simultaneously:\n- $c_{\\min} \\le T \\le c_{\\max}$,\n- $G \\ge g_{\\min}$,\n- $f_{\\mathrm{mt}} \\le f_{\\mathrm{mt},\\max}$,\n- $f_0 \\le f_{0,\\max}$.\n\nAll fractional quantities must be expressed as decimals. For reporting, round $f_{\\mathrm{mt}}$ and $f_0$ to four decimal places.\n\nYour program must compute, for each test case, the tuple $[T, G, f_{\\mathrm{mt}}, f_0, P]$ where $P$ is a boolean indicating whether the cell passes quality control as defined above. Use inclusive inequalities exactly as stated. If $T = 0$, use $f_{\\mathrm{mt}} = 0$ by definition above, and evaluate pass/fail by the same rules.\n\nTest Suite:\nUse the following five test cases. Each case provides $(\\mathbf{x}, \\mathcal{M}, c_{\\min}, c_{\\max}, g_{\\min}, f_{\\mathrm{mt},\\max}, f_{0,\\max}, k_{\\min})$. The gene index convention for $\\mathcal{M}$ is $0$-based in the input vectors, but interpret it consistently as the positions within $\\mathbf{x}$.\n\n1. Case A (happy path):\n   - $\\mathbf{x} = [\\, 2, 3, 4, 5, 6, 0, 0, 1, 2, 3 \\,]$\n   - $\\mathcal{M} = \\{ 0, 1 \\}$\n   - $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$, $k_{\\min} = 1$\n\n2. Case B (boundary inclusivity at $c_{\\min}$ and $f_{\\mathrm{mt},\\max}$):\n   - $\\mathbf{x} = [\\, 2, 2, 8, 4, 4, 0, 0, 0, 0, 0 \\,]$\n   - $\\mathcal{M} = \\{ 0, 1 \\}$\n   - $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$, $k_{\\min} = 1$\n\n3. Case C (failure due to elevated mitochondrial fraction):\n   - $\\mathbf{x} = [\\, 10, 0, 4, 4, 4, 4, 0, 2, 1, 1 \\,]$\n   - $\\mathcal{M} = \\{ 0, 1 \\}$\n   - $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$, $k_{\\min} = 1$\n\n4. Case D (edge case with no detected molecules):\n   - $\\mathbf{x} = [\\, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\,]$\n   - $\\mathcal{M} = \\{ 0, 1 \\}$\n   - $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$, $k_{\\min} = 1$\n\n5. Case E (boundary inclusivity at $c_{\\max}$ and $f_{\\mathrm{mt},\\max}$):\n   - $\\mathbf{x} = [\\, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 \\,]$\n   - $\\mathcal{M} = \\{ 0, 1 \\}$\n   - $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$, $k_{\\min} = 1$\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of five elements, one per test case in the order A through E. Each element must be the list $[T, G, f_{\\mathrm{mt}}, f_0, P]$ with $f_{\\mathrm{mt}}$ and $f_0$ rounded to four decimal places as decimals, and $P$ as a boolean. The entire output must be printed as a single Python-style list on one line, for example:\n[[T_A,G_A,fmt_A,f0_A,P_A],[T_B,G_B,fmt_B,f0_B,P_B],...]", "solution": "The problem presented is a well-defined and computationally tractable task that is fundamental to the analysis of single-cell transcriptomics data. It is scientifically grounded in the established principles of molecular biology and bioinformatics quality control. The provided definitions are precise and the constraints are unambiguous. Therefore, the problem is valid and we proceed to its rigorous solution.\n\nThe objective is to implement an algorithm for quality control of individual cells based on their messenger ribonucleic acid (mRNA) expression profiles, which are quantified using unique molecular identifiers (UMIs). We are given, for each cell, a count vector $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$ where $x_i \\in \\mathbb{Z}_{\\ge 0}$ is the UMI count for gene $i$. We must compute four quality metrics and use them to determine if a cell passes a set of predefined thresholds.\n\nThe metrics are defined as follows:\n1.  Total UMI count, $T$: This metric reflects the total number of mRNA molecules captured from a cell. It is a proxy for cell size and sequencing library quality. A very low $T$ may indicate a dead cell or failed capture, while a very high $T$ may indicate a multiplet (two or more cells captured as one). It is computed as the sum of all gene counts:\n    $$T = \\sum_{i=1}^{N} x_i$$\n2.  Number of detected genes, $G$: This metric represents the transcriptional complexity of a cell. A higher $G$ suggests a more transcriptionally active and complex cell. We define a gene as \"detected\" if its count $x_i$ is at least $k_{\\min}$. For this problem, $k_{\\min} = 1$. The metric is the cardinality of the set of detected genes:\n    $$G = \\left|\\{ i \\in \\{1,\\dots,N\\} : x_i \\ge k_{\\min} \\}\\right|$$\n3.  Mitochondrial fraction, $f_{\\mathrm{mt}}$: This is the proportion of total UMIs that map to mitochondrial genes. An elevated $f_{\\mathrm{mt}}$ is a common indicator of cellular stress or apoptosis, as stressed cells tend to have compromised cytoplasmic mRNA and a relative abundance of mitochondrial transcripts. Given a set of mitochondrial gene indices $\\mathcal{M}$, it is computed as:\n    $$f_{\\mathrm{mt}} = \\begin{cases} \\dfrac{\\sum_{i \\in \\mathcal{M}} x_i}{T}, & \\text{if } T > 0 \\\\ 0, & \\text{if } T = 0 \\end{cases}$$\n4.  Zero fraction, $f_0$: This metric is the proportion of genes with zero observed counts. While scRNA-seq data is inherently sparse, an extremely high zero fraction, especially in conjunction with low $T$ and $G$, might indicate a poor-quality cell. It is calculated as:\n    $$f_0 = \\dfrac{\\left|\\{ i \\in \\{1,\\dots,N\\} : x_i = 0 \\}\\right|}{N}$$\n    where $N$ is the total number of genes in the vector $\\mathbf{x}$.\n\nA cell is deemed to pass quality control, denoted by a boolean value $P=\\text{True}$, if and only if all four of the following conditions are simultaneously satisfied:\n-   $c_{\\min} \\le T \\le c_{\\max}$\n-   $G \\ge g_{\\min}$\n-   $f_{\\mathrm{mt}} \\le f_{\\mathrm{mt},\\max}$\n-   $f_0 \\le f_{0,\\max}$\n\nWe will now apply this procedure to each of the five specified test cases. For all cases, the total number of genes is $N=10$, and the threshold for gene detection is $k_{\\min}=1$. The indices in $\\mathcal{M}$ are $0$-based.\n\nCase A:\n-   $\\mathbf{x} = [2, 3, 4, 5, 6, 0, 0, 1, 2, 3]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   Thresholds: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$.\n-   $T = 2+3+4+5+6+0+0+1+2+3 = 26$.\n-   $G = |\\{i | x_i \\ge 1\\}| = 8$.\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 2+3 = 5$.\n-   $f_{\\mathrm{mt}} = 5 / 26 \\approx 0.192307...$.\n-   $f_0 = 2 / 10 = 0.2$.\n-   Conditions check:\n    1. $20 \\le 26 \\le 1000 \\implies \\text{True}$.\n    2. $8 \\ge 5 \\implies \\text{True}$.\n    3. $0.1923... \\le 0.2 \\implies \\text{True}$.\n    4. $0.2 \\le 0.6 \\implies \\text{True}$.\n-   All conditions pass. $P = \\text{True}$.\n-   Result: $[26, 8, 0.1923, 0.2000, \\text{True}]$.\n\nCase B:\n-   $\\mathbf{x} = [2, 2, 8, 4, 4, 0, 0, 0, 0, 0]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   Thresholds: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$.\n-   $T = 2+2+8+4+4 = 20$.\n-   $G = |\\{i | x_i \\ge 1\\}| = 5$.\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 2+2 = 4$.\n-   $f_{\\mathrm{mt}} = 4 / 20 = 0.2$.\n-   $f_0 = 5 / 10 = 0.5$.\n-   Conditions check:\n    1. $20 \\le 20 \\le 1000 \\implies \\text{True}$.\n    2. $5 \\ge 5 \\implies \\text{True}$.\n    3. $0.2 \\le 0.2 \\implies \\text{True}$.\n    4. $0.5 \\le 0.6 \\implies \\text{True}$.\n-   All conditions pass. $P = \\text{True}$.\n-   Result: $[20, 5, 0.2000, 0.5000, \\text{True}]$.\n\nCase C:\n-   $\\mathbf{x} = [10, 0, 4, 4, 4, 4, 0, 2, 1, 1]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   Thresholds: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$.\n-   $T = 10+0+4+4+4+4+0+2+1+1 = 30$.\n-   $G = |\\{i | x_i \\ge 1\\}| = 8$.\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 10+0 = 10$.\n-   $f_{\\mathrm{mt}} = 10 / 30 \\approx 0.333333...$.\n-   $f_0 = 2 / 10 = 0.2$.\n-   Conditions check:\n    1. $20 \\le 30 \\le 1000 \\implies \\text{True}$.\n    2. $8 \\ge 5 \\implies \\text{True}$.\n    3. $0.3333... \\le 0.2 \\implies \\text{False}$.\n    4. $0.2 \\le 0.6 \\implies \\text{True}$.\n-   One condition fails. $P = \\text{False}$.\n-   Result: $[30, 8, 0.3333, 0.2000, \\text{False}]$.\n\nCase D:\n-   $\\mathbf{x} = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   Thresholds: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$.\n-   $T = 0$.\n-   $G = |\\{i | x_i \\ge 1\\}| = 0$.\n-   $f_{\\mathrm{mt}} = 0$ (by definition as $T=0$).\n-   $f_0 = 10 / 10 = 1.0$.\n-   Conditions check:\n    1. $20 \\le 0 \\le 1000 \\implies \\text{False}$.\n    2. $0 \\ge 5 \\implies \\text{False}$.\n    3. $0 \\le 0.2 \\implies \\text{True}$.\n    4. $1.0 \\le 0.6 \\implies \\text{False}$.\n-   Multiple conditions fail. $P = \\text{False}$.\n-   Result: $[0, 0, 0.0000, 1.0000, \\text{False}]$.\n\nCase E:\n-   $\\mathbf{x} = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]$\n-   $\\mathcal{M} = \\{0, 1\\}$\n-   Thresholds: $c_{\\min} = 20$, $c_{\\max} = 1000$, $g_{\\min} = 5$, $f_{\\mathrm{mt},\\max} = 0.2$, $f_{0,\\max} = 0.6$.\n-   $T = 10 \\times 100 = 1000$.\n-   $G = |\\{i | x_i \\ge 1\\}| = 10$.\n-   $\\sum_{i \\in \\mathcal{M}} x_i = x_0 + x_1 = 100+100 = 200$.\n-   $f_{\\mathrm{mt}} = 200 / 1000 = 0.2$.\n-   $f_0 = 0 / 10 = 0.0$.\n-   Conditions check:\n    1. $20 \\le 1000 \\le 1000 \\implies \\text{True}$.\n    2. $10 \\ge 5 \\implies \\text{True}$.\n    3. $0.2 \\le 0.2 \\implies \\text{True}$.\n    4. $0.0 \\le 0.6 \\implies \\text{True}$.\n-   All conditions pass. $P = \\text{True}$.\n-   Result: $[1000, 10, 0.2000, 0.0000, \\text{True}]$.\n\nThe implementation will follow this logic precisely, ensuring correct handling of data types and floating point comparisons.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scRNA-seq quality control problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        ([2, 3, 4, 5, 6, 0, 0, 1, 2, 3], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case B (boundary inclusivity at c_min and fmt_max)\n        ([2, 2, 8, 4, 4, 0, 0, 0, 0, 0], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case C (failure due to elevated mitochondrial fraction)\n        ([10, 0, 4, 4, 4, 4, 0, 2, 1, 1], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case D (edge case with no detected molecules)\n        ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1),\n        # Case E (boundary inclusivity at c_max and fmt_max)\n        ([100, 100, 100, 100, 100, 100, 100, 100, 100, 100], {0, 1}, 20, 1000, 5, 0.2, 0.6, 1)\n    ]\n\n    def process_cell(x_list, M_set, c_min, c_max, g_min, fmt_max, f0_max, k_min):\n        \"\"\"\n        Processes a single cell's count vector to determine its quality metrics and pass/fail status.\n        \"\"\"\n        # Convert inputs to NumPy arrays for efficient computation.\n        x = np.array(x_list, dtype=np.int64)\n        N = len(x)\n\n        # 1. Total UMI count (T)\n        T = np.sum(x)\n\n        # 2. Number of detected genes (G)\n        G = np.sum(x >= k_min)\n\n        # 3. Mitochondrial fraction (f_mt)\n        # Handle the T=0 case as per problem definition.\n        if T > 0:\n            mt_counts = np.sum(x[list(M_set)])\n            f_mt = mt_counts / T\n        else:\n            f_mt = 0.0\n\n        # 4. Zero fraction (f_0)\n        # N will be > 0 based on problem constraints (non-empty x vector)\n        f_0 = np.sum(x == 0) / N\n\n        # 5. Quality control decision (P)\n        pass_T = (c_min <= T <= c_max)\n        pass_G = (G >= g_min)\n        pass_fmt = (f_mt <= fmt_max)\n        pass_f0 = (f_0 <= f0_max)\n        P = all([pass_T, pass_G, pass_fmt, pass_f0])\n\n        # For reporting, round fractional quantities to four decimal places.\n        rounded_f_mt = round(f_mt, 4)\n        rounded_f_0 = round(f_0, 4)\n        \n        # In Python, round(0.2, 4) is 0.2, not 0.2000. The desired output\n        # format is Python's default representation, so `round` is sufficient.\n\n        return [int(T), int(G), rounded_f_mt, rounded_f_0, P]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        x_val, M_val, c_min_val, c_max_val, g_min_val, fmt_max_val, f0_max_val, k_min_val = case\n        \n        # Process the cell and store the result\n        result = process_cell(x_val, M_val, c_min_val, c_max_val, g_min_val, fmt_max_val, f0_max_val, k_min_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() of a list produces the required [item1, item2, ...] format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2672354"}, {"introduction": "After ensuring each cell in our dataset is of high quality, the next challenge is to identify which genes carry the most information about cellular identity and state transitions. In this exercise, you will implement a principled statistical method to select Highly Variable Genes (HVGs), moving beyond simple measures of expression to find genes whose variability is greater than expected by chance [@problem_id:2672352]. This feature selection is fundamental for reducing noise and computational complexity, enabling the robust inference of lineage relationships in downstream analyses.", "problem": "You are tasked with formalizing and implementing a principled, model-based selection of highly variable genes (HVGs) for single-cell ribonucleic acid sequencing (scRNA-seq) data, suitable for lineage and fate analysis in developmental biology. Base your reasoning on foundational principles: the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein), the stochastic nature of transcriptional bursting leading to overdispersed count data, and well-tested count models for sequencing data such as the Poisson and Negative Binomial distributions. Your solution must derive an algorithm from these principles without relying on prepackaged formulas.\n\nStart from these widely accepted bases:\n- In droplet-based scRNA-seq, the observed unique molecular identifier counts for gene $g$ in cell $i$, denoted $Y_{gi}$, arise from a sampling process whose mean scales with cell-specific library size $L_i$ and gene-specific expression $\\theta_g$. Under a Poisson sampling model, $\\operatorname{Var}(Y_{gi}) \\approx \\mathbb{E}[Y_{gi}]$, and under a Negative Binomial model, $\\operatorname{Var}(Y_{gi}) \\approx \\mathbb{E}[Y_{gi}] + \\phi_g \\mathbb{E}[Y_{gi}]^2$ for dispersion $\\phi_g \\ge 0$.\n- To compare genes across cells with heterogeneous library sizes, counts should be normalized by a per-cell factor.\n- The variance of expression increases with the mean due to both sampling noise and biological variability; thus, a fair HVG definition requires removing the mean–variance dependence to highlight genes whose variability exceeds expectation.\n\nDefine and implement the following HVG statistic from first principles:\n1. For a count matrix with $G$ genes and $C$ cells, compute the per-cell library size $L_i = \\sum_{g=1}^{G} Y_{gi}$.\n2. Perform counts-per-ten-thousand normalization: $U_{gi} = \\dfrac{10000 \\cdot Y_{gi}}{L_i}$ for each cell $i$ where $L_i > 0$. If any $L_i = 0$, define $L_i \\leftarrow 1$ for the purpose of this normalization to avoid division by zero.\n3. Apply a variance-stabilizing log-transform: $Z_{gi} = \\log\\!\\big(1 + U_{gi}\\big)$, where $\\log$ denotes the natural logarithm with base $e$.\n4. For each gene $g$, compute the empirical mean $m_g = \\dfrac{1}{C} \\sum_{i=1}^{C} Z_{gi}$ and empirical unbiased variance $v_g = \\dfrac{1}{C-1} \\sum_{i=1}^{C} \\big(Z_{gi} - m_g\\big)^2$.\n5. Fit a global ordinary least squares linear trend of variance on mean across genes: $v_g \\approx a + b \\, m_g$. Estimate $a$ and $b$ by minimizing $\\sum_{g=1}^{G} \\big(v_g - (a + b m_g)\\big)^2$. Derive the closed-form solution $b = \\dfrac{\\operatorname{Cov}(m,v)}{\\operatorname{Var}(m)}$ and $a = \\bar{v} - b \\, \\bar{m}$, where $\\bar{m}$ and $\\bar{v}$ are the across-gene means and $\\operatorname{Cov}$ and $\\operatorname{Var}$ are the across-gene covariance and variance. If $\\operatorname{Var}(m) = 0$, define $b \\leftarrow 0$ and $a \\leftarrow \\bar{v}$.\n6. For each gene $g$, compute the residual $e_g = v_g - (a + b m_g)$ and the mean squared error $\\mathrm{MSE} = \\dfrac{1}{G-2} \\sum_{g=1}^{G} e_g^2$ (valid for $G \\ge 3$). If $\\mathrm{MSE} = 0$, define the standardized residual for all genes as $0$.\n7. Define the standardized residual $z_g = \\dfrac{e_g}{\\sqrt{\\mathrm{MSE}}}$ for $\\mathrm{MSE} > 0$. The HVG ranking score is $z_g$. Higher $z_g$ indicates variability exceeding the fitted expectation.\n8. To select the top $K$ HVGs, sort genes by descending $z_g$. In the event of ties in $z_g$, break ties by ascending gene index (zero-based). If $K > G$, return all $G$ genes in that order.\n\nYour task is to implement a program that applies this pipeline to the following test suite. Each test case provides a count matrix and a selection parameter $K$. Gene indices are zero-based. All numeric entries below are raw counts $Y_{gi}$.\n\nTest case $1$ (happy path, heterogeneous library sizes):\n- Matrix with $G = 5$ genes and $C = 6$ cells:\n  - Gene $0$: $[10, 10, 10, 10, 10, 10]$\n  - Gene $1$: $[1, 2, 3, 4, 5, 6]$\n  - Gene $2$: $[0, 10, 0, 20, 0, 30]$\n  - Gene $3$: $[0, 0, 1, 0, 0, 0]$\n  - Gene $4$: $[5, 5, 8, 6, 5, 4]$\n- Select top $K = 2$ HVGs.\n\nTest case $2$ (boundary: zero-variance and all-zero gene present):\n- Matrix with $G = 3$ and $C = 4$:\n  - Gene $0$: $[0, 0, 0, 0]$\n  - Gene $1$: $[0, 5, 0, 10]$\n  - Gene $2$: $[3, 3, 3, 3]$\n- Select top $K = 1$ HVG.\n\nTest case $3$ (edge: identical genes to exercise tie-break rule):\n- Matrix with $G = 4$ and $C = 3$:\n  - Gene $0$: $[1, 0, 1]$\n  - Gene $1$: $[1, 0, 1]$\n  - Gene $2$: $[0, 2, 4]$\n  - Gene $3$: $[0, 0, 0]$\n- Select top $K = 2$ HVGs.\n\nTest case $4$ (edge: request more HVGs than available):\n- Matrix with $G = 4$ and $C = 4$:\n  - Gene $0$: $[1, 2, 1, 2]$\n  - Gene $1$: $[5, 5, 5, 5]$\n  - Gene $2$: $[0, 0, 10, 0]$\n  - Gene $3$: $[3, 0, 0, 0]$\n- Select top $K = 5$ HVGs.\n\nYour program must implement the pipeline exactly as defined above and produce a single line of output containing a list of the selected gene index lists for the test cases in order. The output format must be a single line string of the form \"[[i0,i1,...],[j0,j1,...],...]\" with no spaces, where each inner list contains the selected zero-based gene indices for that test case in sorted order by the prescribed HVG ranking rule. No physical units are involved. Angles are not involved. Percentages must not be used anywhere. Ensure all computations follow the definitions above exactly, including using the natural logarithm and unbiased variance with denominator $C-1$.", "solution": "The problem requires the formalization and implementation of a statistical method for identifying highly variable genes (HVGs) from single-cell ribonucleic acid sequencing (scRNA-seq) count data. The approach must be derived from foundational principles of molecular biology and statistics.\n\nThe central challenge in identifying biologically significant gene expression heterogeneity is to distinguish it from technical noise and other confounding factors. The expression of a gene is a stochastic process. As stated, the Central Dogma describes the flow of genetic information from deoxyribonucleic acid (DNA) to ribonucleic acid (RNA) to protein. Transcription, the synthesis of RNA from a DNA template, occurs in stochastic bursts. This intrinsic randomness, combined with the technical noise from reverse transcription, amplification, and sequencing, leads to observed count data ($Y_{gi}$) that are highly variable.\n\nA key observation in sequencing data is that a gene's expression variance is strongly dependent on its mean expression level. This mean-variance relationship is a fundamental property of count distributions like the Poisson, where $\\operatorname{Var}(Y) = \\mathbb{E}[Y]$, and the Negative Binomial, where $\\operatorname{Var}(Y) = \\mathbb{E}[Y] + \\phi \\mathbb{E}[Y]^2$. Furthermore, droplet-based scRNA-seq experiments produce cells with varying library sizes ($L_i$), which is the total number of molecules detected in a cell. A gene's observed count $Y_{gi}$ in cell $i$ is proportional to both its intrinsic expression level $\\theta_g$ and the cell's library size $L_i$. To meaningfully compare gene expression across cells, this library size effect must be neutralized.\n\nThe prescribed algorithm addresses these challenges systematically, as detailed below.\n\n1.  **Library Size Calculation**:\n    The first step is to quantify the total sequencing depth for each cell. The library size for cell $i$, denoted $L_i$, is the sum of counts for all genes within that cell:\n    $$ L_i = \\sum_{g=1}^{G} Y_{gi} $$\n    where $Y_{gi}$ is the raw count for gene $g$ in cell $i$, $G$ is the total number of genes, and $C$ is the total number of cells.\n\n2.  **Counts-Per-Million Style Normalization**:\n    To make gene expression values comparable across cells with different library sizes, we normalize the raw counts. The problem specifies a \"counts-per-ten-thousand\" normalization. The normalized expression value $U_{gi}$ is calculated for each gene $g$ in each cell $i$:\n    $$ U_{gi} = \\frac{10000 \\cdot Y_{gi}}{L_i} $$\n    This scaling transforms the counts to a common scale, conceptually representing the number of molecules that would have been observed for that gene if the library size were exactly $10000$. The problem correctly specifies that if a library size $L_i$ is $0$, it should be set to $1$ to prevent division by zero, resulting in $U_{gi} = 0$ for all genes in that cell.\n\n3.  **Variance-Stabilizing Transformation**:\n    Even after normalization, the variance of $U_{gi}$ still depends on its mean. To mitigate this, a variance-stabilizing transformation is applied. The problem specifies the logarithm transform, which is common for count-like data:\n    $$ Z_{gi} = \\log(1 + U_{gi}) $$\n    The addition of $1$ prevents taking the logarithm of zero. This transformation compresses the data range and makes the variance more independent of the mean, although often a residual trend remains.\n\n4.  **Empirical Mean and Variance Estimation**:\n    After transformation, we quantify the expression level and variability for each gene across all $C$ cells. For each gene $g$, we compute its empirical mean, $m_g$, and its empirical unbiased sample variance, $v_g$:\n    $$ m_g = \\frac{1}{C} \\sum_{i=1}^{C} Z_{gi} $$\n    $$ v_g = \\frac{1}{C-1} \\sum_{i=1}^{C} (Z_{gi} - m_g)^2 $$\n    The use of the denominator $C-1$ for the variance provides an unbiased estimate of the population variance.\n\n5.  **Modeling the Mean-Variance Trend**:\n    The core of the method is to model the remaining relationship between the variance $v_g$ and the mean $m_g$. This trend represents the expected level of variance for a gene given its average expression level. By fitting a model to this trend, we can identify genes whose variance significantly exceeds this expectation. The problem specifies an ordinary least squares (OLS) linear model:\n    $$ v_g \\approx a + b \\, m_g $$\n    The parameters $a$ and $b$ are estimated by minimizing the sum of squared residuals across all genes, $\\sum_{g=1}^{G} (v_g - (a + b m_g))^2$. The closed-form solutions for the OLS estimators are:\n    $$ b = \\frac{\\operatorname{Cov}(m,v)}{\\operatorname{Var}(m)} \\quad \\text{and} \\quad a = \\bar{v} - b \\, \\bar{m} $$\n    Here, $\\bar{m}$ and $\\bar{v}$ are the means of $m_g$ and $v_g$ across all genes, and $\\operatorname{Var}(m)$ and $\\operatorname{Cov}(m,v)$ are the variance and covariance calculated across the set of $(m_g, v_g)$ pairs for all genes. Specifically, $\\operatorname{Var}(m) = \\frac{1}{G}\\sum_{g=1}^{G}(m_g - \\bar{m})^2$ and $\\operatorname{Cov}(m,v) = \\frac{1}{G}\\sum_{g=1}^{G}(m_g - \\bar{m})(v_g - \\bar{v})$. If $\\operatorname{Var}(m) = 0$, which occurs if all genes have the same mean expression $m_g$, the slope $b$ is undefined; the problem specifies setting $b \\leftarrow 0$ and $a \\leftarrow \\bar{v}$ in this situation.\n\n6.  **Calculating Standardized Residuals**:\n    A gene's deviation from the expected trend is captured by its residual, $e_g$:\n    $$ e_g = v_g - (a + b m_g) $$\n    A large positive residual indicates that a gene is more variable than expected for its expression level. To make these residuals comparable across different datasets, they are standardized. This requires an estimate of the error variance from the regression. The Mean Squared Error (MSE) provides this:\n    $$ \\mathrm{MSE} = \\frac{1}{G-2} \\sum_{g=1}^{G} e_g^2 $$\n    The denominator $G-2$ is used because two parameters ($a$ and $b$) were estimated from the data, which is a standard adjustment for obtaining an unbiased estimate of the error variance (assuming $G \\ge 3$). The standardized residual, $z_g$, which serves as the final HVG score, is then:\n    $$ z_g = \\frac{e_g}{\\sqrt{\\mathrm{MSE}}} $$\n    If $\\mathrm{MSE} = 0$, all residuals are $0$, so all $z_g$ are defined as $0$.\n\n7.  **Ranking and Selection**:\n    The final step is to select the top $K$ HVGs. Genes are ranked in descending order of their standardized residual score $z_g$. A higher $z_g$ signifies greater evidence for biologically interesting variability. The problem specifies that ties in $z_g$ must be resolved by choosing the gene with the lower (ascending) zero-based index. If the requested number of genes $K$ is greater than the total number of genes $G$, all genes are returned in their ranked order.\n\nThis principled pipeline provides a robust and interpretable method for feature selection in scRNA-seq analysis, grounded in statistical models of count data and designed to isolate biological signal from technical noise.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the HVG selection pipeline on all test cases.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [10, 10, 10, 10, 10, 10],\n                [1, 2, 3, 4, 5, 6],\n                [0, 10, 0, 20, 0, 30],\n                [0, 0, 1, 0, 0, 0],\n                [5, 5, 8, 6, 5, 4]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [0, 0, 0, 0],\n                [0, 5, 0, 10],\n                [3, 3, 3, 3]\n            ]),\n            1\n        ),\n        (\n            np.array([\n                [1, 0, 1],\n                [1, 0, 1],\n                [0, 2, 4],\n                [0, 0, 0]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [1, 2, 1, 2],\n                [5, 5, 5, 5],\n                [0, 0, 10, 0],\n                [3, 0, 0, 0]\n            ]),\n            5\n        )\n    ]\n\n    results = []\n    for Y, K in test_cases:\n        selected_indices = find_hvgs(Y, K)\n        results.append(selected_indices)\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join([str(res) for res in results])}]\".replace(\" \", \"\"))\n\ndef find_hvgs(Y, K):\n    \"\"\"\n    Implements the highly variable gene (HVG) selection pipeline.\n\n    Args:\n        Y (np.ndarray): A GxC count matrix (G genes, C cells).\n        K (int): The number of top HVGs to select.\n\n    Returns:\n        list: A list of the top K gene indices, sorted by HVG score.\n    \"\"\"\n    if Y.shape[0] == 0 or Y.shape[1] == 0:\n        return []\n\n    G, C = Y.shape\n\n    # Step 1: Compute per-cell library size\n    L = Y.sum(axis=0, dtype=np.float64)\n\n    # Step 2: Perform counts-per-ten-thousand normalization\n    # Handle L_i = 0 case\n    L[L == 0] = 1\n    # Use broadcasting for normalization\n    U = (10000.0 * Y) / L[np.newaxis, :]\n\n    # Step 3: Apply a variance-stabilizing log-transform\n    Z = np.log1p(U)\n\n    # Step 4: Compute empirical mean and unbiased variance for each gene\n    # The problem implies C > 1, so ddof=1 is safe.\n    if C <= 1:\n        # Cannot compute variance, return empty list or handle as per a more\n        # complete specification. For this problem, C > 1 is guaranteed by tests.\n        return list(range(G))[:K]\n        \n    m = Z.mean(axis=1)\n    v = Z.var(axis=1, ddof=1)\n\n    # Step 5: Fit a global OLS linear trend\n    if G == 0:\n        return []\n\n    m_bar = m.mean()\n    v_bar = v.mean()\n\n    # Use population variance (ddof=0) for the 'm' vector as per standard OLS derivation.\n    m_var = m.var(ddof=0)\n\n    if m_var == 0:\n        b = 0.0\n        a = v_bar\n    else:\n        # Use population covariance (ddof=0). np.cov returns a 2x2 matrix.\n        cov_mv = np.cov(m, v, ddof=0)[0, 1]\n        b = cov_mv / m_var\n        a = v_bar - b * m_bar\n    \n    # Step 6 & 7: Compute standardized residuals\n    # The problem implies G >= 3 for MSE calculation.\n    if G < 3:\n        # The z-score calculation is not well-defined.\n        # However, the test cases all have G >= 3.\n        # Fallback to sorting by raw residual if needed. For this problem, we follow spec.\n        e = v - (a + b * m)\n        z = e # Use raw residual if G < 3, no standardization possible\n    else:\n        e = v - (a + b * m)\n        mse_sum_sq = np.sum(e**2)\n        mse = mse_sum_sq / (G - 2)\n        \n        if mse == 0:\n            z = np.zeros(G)\n        else:\n            z = e / np.sqrt(mse)\n\n    # Step 8: Select top K HVGs\n    gene_indices = np.arange(G)\n\n    # Sort by descending z-score, breaking ties with ascending gene index.\n    # We can create a list of tuples (z_score, gene_index) and sort.\n    # The key (-z, idx) implements the desired sorting order.\n    sorted_genes = sorted(zip(z, gene_indices), key=lambda x: (-x[0], x[1]))\n    \n    # Extract the sorted indices\n    sorted_indices = [idx for score, idx in sorted_genes]\n\n    # Return the top K, or all G if K > G.\n    return sorted_indices[:K]\n\nsolve()\n```", "id": "2672352"}, {"introduction": "With a clean, feature-selected dataset, we can move from describing developmental processes to modeling the mechanisms that drive them. This final practice challenges you to build a biophysical model from first principles, integrating cell-cell communication signals with intrinsic factors to predict cell fate decisions [@problem_id:2672375]. By translating transcriptomic data into the parameters of a mechanistic model based on ligand-receptor binding and thermodynamic principles, you will gain hands-on experience in one of the most advanced applications of single-cell analysis: testing quantitative hypotheses about developmental logic.", "problem": "You are modeling how cell–cell communication measured from Single-cell RNA sequencing (scRNA-seq) data influences a binary fate decision in a developing tissue. Start from the following fundamental bases: (i) the Central Dogma of Molecular Biology, which implies that under steady-state conditions the expected protein output rate can be approximated as proportional to messenger ribonucleic acid (mRNA) abundance; (ii) elementary ligand–receptor binding with reversible mass-action kinetics at equilibrium; and (iii) a two-state thermodynamic choice between fates whose probability follows a Boltzmann distribution with an energy difference that is linear in upstream signals. From these bases, derive a minimal, testable model that maps scRNA-seq-derived ligand and receptor levels to a dimensionless probability of choosing fate-$1$ over fate-$0$ for a single receiver cell. The model must be constructed as follows, without using any external information beyond what is specified here:\n\n1) Use the proportionality implied by steady-state Central Dogma to map mean ligand mRNA abundance to an estimated extracellular ligand concentration. Concretely, for each ligand species $a$, let the estimated concentration be $S_a = \\alpha_a \\cdot \\bar{m}_a$, where $\\bar{m}_a$ is the mean mRNA count per sender cell and $\\alpha_a$ is a provided proportionality constant in nanomolar per count (nM/count). Units: $S_a$ must be in nanomolar (nM).\n\n2) For each ligand–receptor pair $a$ with equilibrium dissociation constant $K_{d,a}$ (in nM), derive the fraction of receptors in the bound state at equilibrium from reversible binding under the law of mass action. Then, define an effective pathway signal contribution by scaling the occupancy with a receptor capacity parameter $r_a$ that is proportional to receptor mRNA abundance: $r_a = \\beta_a \\cdot R_a$, where $R_a$ is the receptor mRNA count and $\\beta_a$ is a provided proportionality constant (dimensionless per count). Allow the contribution of each pathway to be activating or inhibitory via a provided sign $s_a \\in \\{+1,-1\\}$.\n\n3) Assume the net decision variable (a linear predictor) for the fate choice is the sum of a baseline term, the signed pathway contributions, and a cell-intrinsic transcription factor contribution. Explicitly, combine the pathway terms additively and include a scalar coefficient multiplying the transcription factor level.\n\n4) From a two-state thermodynamic argument for fate selection at fixed effective temperature, derive the mapping from the decision variable to the probability of fate-$1$ as a dimensionless number in the open interval $(0,1)$.\n\nYour program must implement the above derivations and compute the fate-$1$ probability for each of the following five test cases. All numerical inputs appear below; do not introduce any additional parameters. Express all concentrations in nanomolar (nM), and all final probabilities as decimals rounded to six digits after the decimal point. No angles appear in this problem. The final program output must be a single line containing a comma-separated list enclosed in square brackets.\n\nTest suite (each case provides arrays and scalars; all numbers are given explicitly):\n\n- Case A (typical mixed signaling):\n  - Mean ligand mRNA per sender: $\\bar{m} = [\\,50,\\,30\\,]$\n  - Ligand-to-concentration proportionality: $\\alpha = [\\,0.2,\\,0.1\\,]$ (nM/count)\n  - Dissociation constants: $K_d = [\\,5,\\,2\\,]$ (nM)\n  - Receptor mRNA in receiver: $R = [\\,100,\\,80\\,]$\n  - Receptor capacity proportionality: $\\beta = [\\,0.01,\\,0.01\\,]$ (dimensionless/count)\n  - Pathway signs: $s = [\\,+1,\\,-1\\,]$\n  - Baseline: $b_0 = 0$\n  - Transcription factor level: $T = 0$\n  - Transcription factor coefficient: $\\gamma = 0.5$\n\n- Case B (no ligand; intrinsic bias dominates):\n  - $\\bar{m} = [\\,0\\,]$\n  - $\\alpha = [\\,0.5\\,]$ (nM/count)\n  - $K_d = [\\,1\\,]$ (nM)\n  - $R = [\\,50\\,]$\n  - $\\beta = [\\,0.02\\,]$ (dimensionless/count)\n  - $s = [\\,+1\\,]$\n  - $b_0 = -1$\n  - $T = 1$\n  - $\\gamma = 2$\n\n- Case C (saturating activating ligand):\n  - $\\bar{m} = [\\,1000\\,]$\n  - $\\alpha = [\\,1.0\\,]$ (nM/count)\n  - $K_d = [\\,1\\,]$ (nM)\n  - $R = [\\,200\\,]$\n  - $\\beta = [\\,0.02\\,]$ (dimensionless/count)\n  - $s = [\\,+1\\,]$\n  - $b_0 = -2$\n  - $T = 0$\n  - $\\gamma = 1$\n\n- Case D (strong inhibition dominates):\n  - $\\bar{m} = [\\,20,\\,60\\,]$\n  - $\\alpha = [\\,0.3,\\,0.3\\,]$ (nM/count)\n  - $K_d = [\\,3,\\,6\\,]$ (nM)\n  - $R = [\\,60,\\,120\\,]$\n  - $\\beta = [\\,0.02,\\,0.015\\,]$ (dimensionless/count)\n  - $s = [\\,+1,\\,-1\\,]$\n  - $b_0 = -0.5$\n  - $T = 0$\n  - $\\gamma = 0$\n\n- Case E (balanced inputs, boundary probability):\n  - $\\bar{m} = [\\,10,\\,10\\,]$\n  - $\\alpha = [\\,1,\\,1\\,]$ (nM/count)\n  - $K_d = [\\,10,\\,10\\,]$ (nM)\n  - $R = [\\,100,\\,100\\,]$\n  - $\\beta = [\\,0.01,\\,0.01\\,]$ (dimensionless/count)\n  - $s = [\\,+1,\\,-1\\,]$\n  - $b_0 = 0$\n  - $T = 0$\n  - $\\gamma = 0$\n\nRequirements for computation and output:\n\n- For each case, compute $S_a = \\alpha_a \\cdot \\bar{m}_a$ in nanomolar.\n- From reversible binding at equilibrium, use the mass-action result to compute the bound fraction for each $a$ and scale it by $r_a = \\beta_a \\cdot R_a$ and sign $s_a$ to form a single linear predictor by summation together with the baseline and transcription factor term. Then map this predictor to a dimensionless probability of fate-$1$ using the two-state thermodynamic argument.\n- Round each probability to six digits after the decimal point and output a single line: a comma-separated list enclosed in square brackets, ordered as $[\\,\\text{Case A},\\,\\text{Case B},\\,\\text{Case C},\\,\\text{Case E}\\,]$.", "solution": "The problem requires the derivation and implementation of a minimal model for a binary cell fate decision, based on fundamental principles of molecular biology and statistical thermodynamics. The model must map single-cell transcriptomics data (ligand and receptor mRNA counts) to a fate probability. The problem statement is scientifically grounded, well-posed, and contains all necessary information for a unique solution. We proceed with the derivation.\n\nThe derivation follows the four specified steps.\n\nStep 1: Ligand Concentration Estimation\nThe problem postulates that, at steady state, the extracellular concentration of a ligand, $S_a$, is proportional to the mean mRNA abundance of that ligand, $\\bar{m}_a$, in the sending cell population. The proportionality constant is $\\alpha_a$.\n$$ S_a = \\alpha_a \\cdot \\bar{m}_a $$\nThe units are consistent: $\\alpha_a$ is given in (nM/count) and $\\bar{m}_a$ is in counts, yielding $S_a$ in nanomolar (nM), which is chemically correct.\n\nStep 2: Pathway Signal Contribution from Ligand-Receptor Binding\nThe interaction between a ligand $L$ and a free receptor $R_{free}$ to form a bound complex $LR_{bound}$ is described by the reversible reaction $L + R_{free} \\rightleftharpoons LR_{bound}$. According to the law of mass action at equilibrium, the dissociation constant $K_{d,a}$ for a given ligand-receptor pair $a$ is defined as:\n$$ K_{d,a} = \\frac{[L_a][R_{free,a}]}{[LR_{bound,a}]} $$\nHere, $[L_a]$ is the ligand concentration, which we have modeled as $S_a$. The fraction of bound receptors, $\\theta_a$, is the ratio of the concentration of bound receptors to the total receptor concentration, $[R_{tot,a}] = [R_{free,a}] + [LR_{bound,a}]$. By rearranging the equilibrium equation to solve for $[R_{free,a}]$ and substituting into the total receptor expression, we derive the classic Hill-Langmuir equation for receptor occupancy:\n$$ [R_{tot,a}] = \\frac{K_{d,a}[LR_{bound,a}]}{S_a} + [LR_{bound,a}] = [LR_{bound,a}] \\left( \\frac{K_{d,a}}{S_a} + 1 \\right) $$\n$$ \\theta_a = \\frac{[LR_{bound,a}]}{[R_{tot,a}]} = \\frac{S_a}{K_{d,a} + S_a} $$\nThis fraction $\\theta_a$ is a dimensionless quantity representing the extent of receptor activation. The problem states that the effective signal contribution of pathway $a$, which we denote $C_a$, is this occupancy scaled by a receptor capacity parameter $r_a = \\beta_a \\cdot R_a$ and a sign $s_a \\in \\{+1, -1\\}$ indicating activation or inhibition. The parameter $r_a$ is itself proportional to the receptor mRNA count $R_a$ with proportionality constant $\\beta_a$. Thus, the contribution of pathway $a$ is:\n$$ C_a = s_a \\cdot r_a \\cdot \\theta_a = s_a \\cdot (\\beta_a \\cdot R_a) \\cdot \\left( \\frac{S_a}{K_{d,a} + S_a} \\right) $$\n\nStep 3: Net Decision Variable\nThe net decision variable, denoted as $X$, is a linear predictor that integrates all upstream signals. It is defined as the sum of a baseline bias $b_0$, the contributions from all ligand-receptor pathways, and a term for an intrinsic cell state represented by a transcription factor level $T$ with a coefficient $\\gamma$.\n$$ X = b_0 + \\sum_a C_a + \\gamma \\cdot T $$\nSubstituting the expressions for $C_a$ and $S_a$, we obtain the complete form of the decision variable:\n$$ X = b_0 + \\sum_a \\left[ s_a \\cdot (\\beta_a \\cdot R_a) \\cdot \\left( \\frac{\\alpha_a \\cdot \\bar{m}_a}{K_{d,a} + \\alpha_a \\cdot \\bar{m}_a} \\right) \\right] + \\gamma \\cdot T $$\n\nStep 4: Mapping to Fate Probability\nThe final step is to map the decision variable $X$ to the probability of choosing fate-$1$, denoted $P(1)$. The problem specifies a two-state thermodynamic argument. Let the two fates, fate-$0$ and fate-$1$, have effective free energies $E_0$ and $E_1$. According to statistical mechanics, the probability of occupying a state is proportional to its Boltzmann factor, $e^{-E/k_B T_{eff}}$, where $k_B T_{eff}$ is the effective thermal energy. The probability of fate-$1$ is therefore:\n$$ P(1) = \\frac{e^{-E_1/k_B T_{eff}}}{e^{-E_0/k_B T_{eff}} + e^{-E_1/k_B T_{eff}}} = \\frac{1}{1 + e^{(E_1 - E_0)/k_B T_{eff}}} $$\nThe problem states that the energy difference, $\\Delta E = E_1 - E_0$, is linear in the upstream signals. The most direct and standard interpretation in such models is to equate the dimensionless energy difference $-\\Delta E/k_B T_{eff}$ with the linear predictor $X$. This identification is common and forms the basis of logistic regression models.\n$$ -\\frac{E_1 - E_0}{k_B T_{eff}} \\equiv X $$\nA positive $X$ corresponds to $E_1 < E_0$, making fate-$1$ energetically more favorable, thus increasing $P(1)$. This is consistent with activating signals ($s_a=+1$) increasing $X$. The probability $P(1)$ is then given by the standard logistic (sigmoid) function:\n$$ P(1) = \\frac{1}{1 + e^{-X}} $$\nThis function correctly maps the real-valued decision variable $X$ to the required open interval $(0, 1)$.\n\nWe now apply this complete model to the provided test cases.\n\nCase A: $\\bar{m} = [50, 30]$, $\\alpha = [0.2, 0.1]$, $K_d = [5, 2]$, $R = [100, 80]$, $\\beta = [0.01, 0.01]$, $s = [+1, -1]$, $b_0 = 0$, $T = 0$, $\\gamma = 0.5$.\n$S_1 = 0.2 \\cdot 50 = 10$. $S_2 = 0.1 \\cdot 30 = 3$.\n$C_1 = +1 \\cdot (0.01 \\cdot 100) \\cdot \\frac{10}{5+10} = 1 \\cdot \\frac{10}{15} \\approx 0.666667$.\n$C_2 = -1 \\cdot (0.01 \\cdot 80) \\cdot \\frac{3}{2+3} = -0.8 \\cdot \\frac{3}{5} = -0.48$.\n$X = 0 + 0.666667 - 0.48 + 0 = 0.186667$.\n$P(1) = \\frac{1}{1 + e^{-0.186667}} \\approx 0.546520$.\n\nCase B: $\\bar{m} = [0]$, $\\alpha = [0.5]$, $K_d = [1]$, $R = [50]$, $\\beta = [0.02]$, $s = [+1]$, $b_0 = -1$, $T = 1$, $\\gamma = 2$.\n$S_1 = 0.5 \\cdot 0 = 0$.\n$C_1 = +1 \\cdot (0.02 \\cdot 50) \\cdot \\frac{0}{1+0} = 0$.\n$X = -1 + 0 + (2 \\cdot 1) = 1$.\n$P(1) = \\frac{1}{1 + e^{-1}} \\approx 0.731059$.\n\nCase C: $\\bar{m} = [1000]$, $\\alpha = [1.0]$, $K_d = [1]$, $R = [200]$, $\\beta = [0.02]$, $s = [+1]$, $b_0 = -2$, $T = 0$, $\\gamma = 1$.\n$S_1 = 1.0 \\cdot 1000 = 1000$.\n$C_1 = +1 \\cdot (0.02 \\cdot 200) \\cdot \\frac{1000}{1+1000} = 4 \\cdot \\frac{1000}{1001} \\approx 3.996004$.\n$X = -2 + 3.996004 + 0 = 1.996004$.\n$P(1) = \\frac{1}{1 + e^{-1.996004}} \\approx 0.880387$.\n\nCase D: $\\bar{m} = [20, 60]$, $\\alpha = [0.3, 0.3]$, $K_d = [3, 6]$, $R = [60, 120]$, $\\beta = [0.02, 0.015]$, $s = [+1, -1]$, $b_0 = -0.5$, $T = 0$, $\\gamma = 0$.\n$S_1 = 0.3 \\cdot 20 = 6$. $S_2 = 0.3 \\cdot 60 = 18$.\n$C_1 = +1 \\cdot (0.02 \\cdot 60) \\cdot \\frac{6}{3+6} = 1.2 \\cdot \\frac{6}{9} = 0.8$.\n$C_2 = -1 \\cdot (0.015 \\cdot 120) \\cdot \\frac{18}{6+18} = -1.8 \\cdot \\frac{18}{24} = -1.35$.\n$X = -0.5 + 0.8 - 1.35 + 0 = -1.05$.\n$P(1) = \\frac{1}{1 + e^{-(-1.05)}} = \\frac{1}{1 + e^{1.05}} \\approx 0.259223$.\n\nCase E: $\\bar{m} = [10, 10]$, $\\alpha = [1, 1]$, $K_d = [10, 10]$, $R = [100, 100]$, $\\beta = [0.01, 0.01]$, $s = [+1, -1]$, $b_0 = 0$, $T = 0$, $\\gamma = 0$.\n$S_1 = 1 \\cdot 10 = 10$. $S_2 = 1 \\cdot 10 = 10$.\n$C_1 = +1 \\cdot (0.01 \\cdot 100) \\cdot \\frac{10}{10+10} = 1 \\cdot 0.5 = 0.5$.\n$C_2 = -1 \\cdot (0.01 \\cdot 100) \\cdot \\frac{10}{10+10} = -1 \\cdot 0.5 = -0.5$.\n$X = 0 + 0.5 - 0.5 + 0 = 0$.\n$P(1) = \\frac{1}{1 + e^{-0}} = \\frac{1}{1+1} = 0.500000$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes cell fate probabilities based on a biophysical model\n    for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: typical mixed signaling\n        {\n            \"m_bar\": [50, 30], \"alpha\": [0.2, 0.1], \"Kd\": [5, 2], \n            \"R\": [100, 80], \"beta\": [0.01, 0.01], \"s\": [1, -1],\n            \"b0\": 0, \"T\": 0, \"gamma\": 0.5\n        },\n        # Case B: no ligand; intrinsic bias dominates\n        {\n            \"m_bar\": [0], \"alpha\": [0.5], \"Kd\": [1],\n            \"R\": [50], \"beta\": [0.02], \"s\": [1],\n            \"b0\": -1, \"T\": 1, \"gamma\": 2\n        },\n        # Case C: saturating activating ligand\n        {\n            \"m_bar\": [1000], \"alpha\": [1.0], \"Kd\": [1],\n            \"R\": [200], \"beta\": [0.02], \"s\": [1],\n            \"b0\": -2, \"T\": 0, \"gamma\": 1\n        },\n        # Case D: strong inhibition dominates\n        {\n            \"m_bar\": [20, 60], \"alpha\": [0.3, 0.3], \"Kd\": [3, 6],\n            \"R\": [60, 120], \"beta\": [0.02, 0.015], \"s\": [1, -1],\n            \"b0\": -0.5, \"T\": 0, \"gamma\": 0\n        },\n        # Case E: balanced inputs, boundary probability\n        {\n            \"m_bar\": [10, 10], \"alpha\": [1, 1], \"Kd\": [10, 10],\n            \"R\": [100, 100], \"beta\": [0.01, 0.01], \"s\": [1, -1],\n            \"b0\": 0, \"T\": 0, \"gamma\": 0\n        }\n    ]\n\n    def calculate_fate_probability(m_bar, alpha, Kd, R, beta, s, b0, T, gamma):\n        \"\"\"\n        Calculates the probability of fate-1 for a single cell based on the derived model.\n        \n        Args:\n            m_bar (list): Mean ligand mRNA per sender.\n            alpha (list): Ligand-to-concentration proportionality.\n            Kd (list): Dissociation constants.\n            R (list): Receptor mRNA in receiver.\n            beta (list): Receptor capacity proportionality.\n            s (list): Pathway signs (+1 or -1).\n            b0 (float): Baseline term.\n            T (float): Transcription factor level.\n            gamma (float): Transcription factor coefficient.\n            \n        Returns:\n            float: The probability of fate-1.\n        \"\"\"\n        # Convert list inputs to numpy arrays for vectorized calculations.\n        m_bar_np = np.asarray(m_bar)\n        alpha_np = np.asarray(alpha)\n        Kd_np = np.asarray(Kd)\n        R_np = np.asarray(R)\n        beta_np = np.asarray(beta)\n        s_np = np.asarray(s)\n\n        # Step 1: Calculate ligand concentrations (S_a)\n        S_a = alpha_np * m_bar_np\n\n        # Step 2: Calculate pathway signal contributions (C_a)\n        # Receptor occupancy fraction (theta_a)\n        # Add a small epsilon to the denominator to prevent division by zero in the\n        # theoretical case where S_a=0 and Kd_np=0, although Kd > 0 in this problem.\n        theta_a = S_a / (Kd_np + S_a)\n        \n        # Receptor capacity (r_a)\n        r_a = beta_np * R_np\n        \n        # Total contribution from all pathways\n        pathway_contributions = s_np * r_a * theta_a\n\n        # Step 3: Calculate the net decision variable (X)\n        X = b0 + np.sum(pathway_contributions) + gamma * T\n        \n        # Step 4: Map the decision variable to a probability using the logistic function\n        probability = 1.0 / (1.0 + np.exp(-X))\n        \n        return probability\n\n    results = []\n    for case in test_cases:\n        prob = calculate_fate_probability(**case)\n        # Round to six digits after the decimal point and format as string.\n        results.append(f\"{prob:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2672375"}]}