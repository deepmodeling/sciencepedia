{"hands_on_practices": [{"introduction": "Understanding how network topology shapes signaling responses is a central goal of systems biology. This first practice focuses on a core motif: a sensitive signaling module embedded in a negative feedback loop. By analytically deriving how feedback alters the effective Hill coefficient and the half-maximal concentration ($EC_{50}$), you will gain fundamental insights into how cells achieve desensitization and tune the dynamic range of their responses. [@problem_id:2605591]", "problem": "A single-input single-output biochemical signaling module displays ultrasensitivity that can be described at steady state by a Hill input-output relation. Let the module receive an effective stimulus $x$ and produce an output $Y$ with maximum $Y_{\\max}$. Define the fractional output $y \\equiv Y/Y_{\\max}$. The ultrasensitive module is described by the Hill function\n$$\ny \\;=\\; \\frac{x^{n}}{K^{n} + x^{n}},\n$$\nwhere $K$ is the half-maximal constant and $n$ is the Hill coefficient. Due to network crosstalk, the output feeds back negatively to the input, reducing the effective stimulus according to\n$$\nx \\;=\\; \\frac{S}{1 + \\gamma y},\n$$\nwhere $S$ is the external stimulus and $\\gamma \\ge 0$ is a dimensionless feedback strength parameter that quantifies the strength of crosstalk-mediated negative feedback on the input.\n\nUsing only the definitions of the Hill function and negative feedback given above, and standard calculus, derive closed-form analytic expressions for the following two quantities under steady-state conditions:\n\n- The effective Hill coefficient $n_{\\mathrm{eff}}$, defined as the local slope of the Hill plot with respect to the external stimulus $S$,\n$$\nn_{\\mathrm{eff}} \\;\\equiv\\; \\left.\\frac{d\\,\\ln\\!\\left(\\frac{y}{1-y}\\right)}{d\\,\\ln S}\\right|_{y=1/2}.\n$$\n\n- The closed-loop half-maximal input $\\mathrm{EC}_{50}^{\\mathrm{(cl)}}$, defined as the value of $S$ that yields $y=1/2$ under feedback.\n\nExpress your final answer as a row matrix containing, in order, the expressions for $n_{\\mathrm{eff}}$ and $\\mathrm{EC}_{50}^{\\mathrm{(cl)}}$ in terms of $n$, $K$, and $\\gamma$. No numerical evaluation is required and no units are needed.", "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information for a complete derivation. The models for ultrasensitivity and negative feedback are standard in the field of biochemical systems analysis. We will proceed to derive the closed-form expressions for the effective Hill coefficient, $n_{\\mathrm{eff}}$, and the closed-loop half-maximal input, $\\mathrm{EC}_{50}^{\\mathrm{(cl)}}$.\n\nFirst, we determine the closed-loop half-maximal input, $\\mathrm{EC}_{50}^{\\mathrm{(cl)}}$. This quantity is defined as the value of the external stimulus, $S$, for which the fractional output, $y$, is equal to $1/2$. We substitute $y=1/2$ into the Hill function describing the module's output:\n$$\n\\frac{1}{2} = \\frac{x^{n}}{K^{n} + x^{n}}\n$$\nAlgebraic manipulation of this equation yields:\n$$\nK^{n} + x^{n} = 2 x^{n}\n$$\n$$\nK^{n} = x^{n}\n$$\nSince both the effective stimulus, $x$, and the half-maximal constant, $K$, are positive real quantities, we can conclude that at half-maximal output, the effective stimulus is equal to the half-maximal constant:\n$$\nx = K\n$$\nNow, we use the equation describing the negative feedback loop, which relates the effective stimulus, $x$, to the external stimulus, $S$, and the fractional output, $y$:\n$$\nx = \\frac{S}{1 + \\gamma y}\n$$\nWe substitute the conditions for half-maximal output, which are $y=1/2$ and $x=K$. The external stimulus, $S$, under these conditions is by definition $\\mathrm{EC}_{50}^{\\mathrm{(cl)}}$.\n$$\nK = \\frac{\\mathrm{EC}_{50}^{\\mathrm{(cl)}}}{1 + \\gamma \\left(\\frac{1}{2}\\right)}\n$$\nSolving for $\\mathrm{EC}_{50}^{\\mathrm{(cl)}}$ gives the first required expression:\n$$\n\\mathrm{EC}_{50}^{\\mathrm{(cl)}} = K \\left(1 + \\frac{\\gamma}{2}\\right)\n$$\n\nSecond, we derive the expression for the effective Hill coefficient, $n_{\\mathrm{eff}}$. It is defined as the local slope of the Hill plot with respect to the external stimulus $S$, evaluated at the point of half-maximal output:\n$$\nn_{\\mathrm{eff}} \\equiv \\left.\\frac{d\\,\\ln\\!\\left(\\frac{y}{1-y}\\right)}{d\\,\\ln S}\\right|_{y=1/2}\n$$\nFirst, let us find a more convenient expression for the term $\\ln(y/(1-y))$. Using the given Hill function $y = x^{n}/(K^{n} + x^{n})$, we have:\n$$\n1-y = 1 - \\frac{x^{n}}{K^{n} + x^{n}} = \\frac{K^{n} + x^{n} - x^{n}}{K^{n} + x^{n}} = \\frac{K^{n}}{K^{n} + x^{n}}\n$$\nThe ratio $y/(1-y)$ is therefore:\n$$\n\\frac{y}{1-y} = \\frac{x^{n}/(K^{n} + x^{n})}{K^{n}/(K^{n} + x^{n})} = \\frac{x^{n}}{K^{n}} = \\left(\\frac{x}{K}\\right)^{n}\n$$\nTaking the natural logarithm of this expression gives a simplified relationship:\n$$\n\\ln\\left(\\frac{y}{1-y}\\right) = n \\ln\\left(\\frac{x}{K}\\right) = n(\\ln x - \\ln K)\n$$\nWe can now substitute this into the definition of $n_{\\mathrm{eff}}$:\n$$\nn_{\\mathrm{eff}} = \\frac{d}{d\\,\\ln S} \\left[ n(\\ln x - \\ln K) \\right]\n$$\nSince $n$ and $K$ are constants, the derivative becomes:\n$$\nn_{\\mathrm{eff}} = n \\frac{d(\\ln x)}{d(\\ln S)}\n$$\nTo evaluate this derivative, we must relate $x$ to $S$. We use the feedback equation $x = S / (1 + \\gamma y)$. Taking the natural logarithm of both sides gives:\n$$\n\\ln x = \\ln S - \\ln(1 + \\gamma y)\n$$\nWe now differentiate this entire equation with respect to $\\ln S$:\n$$\n\\frac{d(\\ln x)}{d(\\ln S)} = \\frac{d(\\ln S)}{d(\\ln S)} - \\frac{d}{d(\\ln S)}[\\ln(1 + \\gamma y)]\n$$\nThe first term on the right is unity. For the second term, we apply the chain rule:\n$$\n\\frac{d(\\ln x)}{d(\\ln S)} = 1 - \\frac{d}{dy}[\\ln(1 + \\gamma y)] \\cdot \\frac{dy}{d(\\ln S)} = 1 - \\frac{\\gamma}{1+\\gamma y} \\frac{dy}{d(\\ln S)}\n$$\nTo find $\\frac{dy}{d(\\ln S)}$, we use the chain rule again, linking $y$ to $S$ via the intermediate variable $x$:\n$$\n\\frac{dy}{d(\\ln S)} = \\frac{dy}{d(\\ln x)} \\frac{d(\\ln x)}{d(\\ln S)}\n$$\nThe term $\\frac{dy}{d(\\ln x)}$ is the local sensitivity of the open-loop module. We have already shown that $\\ln(y/(1-y)) = n \\ln(x/K)$. Differentiating this with respect to $\\ln x$:\n$$\n\\frac{d}{d(\\ln x)}\\left[\\ln y - \\ln(1-y)\\right] = \\frac{d}{d(\\ln x)}[n(\\ln x - \\ln K)]\n$$\n$$\n\\frac{1}{y}\\frac{dy}{d(\\ln x)} - \\frac{1}{1-y}\\left(-\\frac{dy}{d(\\ln x)}\\right) = n\n$$\n$$\n\\frac{dy}{d(\\ln x)}\\left(\\frac{1}{y} + \\frac{1}{1-y}\\right) = n \\implies \\frac{dy}{d(\\ln x)}\\left(\\frac{1-y+y}{y(1-y)}\\right) = n\n$$\nThis gives the well-known result:\n$$\n\\frac{dy}{d(\\ln x)} = n y (1-y)\n$$\nSubstituting this back, we obtain:\n$$\n\\frac{dy}{d(\\ln S)} = n y (1-y) \\frac{d(\\ln x)}{d(\\ln S)}\n$$\nNow we substitute this expression into our equation for $\\frac{d(\\ln x)}{d(\\ln S)}$:\n$$\n\\frac{d(\\ln x)}{d(\\ln S)} = 1 - \\frac{\\gamma}{1+\\gamma y} \\left[ n y (1-y) \\frac{d(\\ln x)}{d(\\ln S)} \\right]\n$$\nLet $A = \\frac{d(\\ln x)}{d(\\ln S)}$ to simplify notation. We can rearrange to solve for $A$:\n$$\nA \\left[1 + \\frac{n \\gamma y (1-y)}{1+\\gamma y}\\right] = 1\n$$\n$$\nA = \\frac{1}{1 + \\frac{n \\gamma y (1-y)}{1+\\gamma y}} = \\frac{1+\\gamma y}{1+\\gamma y + n \\gamma y (1-y)}\n$$\nRecalling that $n_{\\mathrm{eff}} = n A$, we have:\n$$\nn_{\\mathrm{eff}} = n \\left( \\frac{1+\\gamma y}{1+\\gamma y + n \\gamma y (1-y)} \\right)\n$$\nThe problem requires this quantity to be evaluated at $y=1/2$. At this point:\n$$\ny=1/2, \\quad 1-y=1/2, \\quad y(1-y)=1/4\n$$\nSubstituting these values:\n$$\nn_{\\mathrm{eff}} = n \\left( \\frac{1+\\gamma/2}{1+\\gamma/2 + n \\gamma (1/4)} \\right) = n \\left( \\frac{1+\\gamma/2}{1+\\gamma/2 + n\\gamma/4} \\right)\n$$\nTo simplify this expression, we multiply the numerator and denominator of the fraction by $4$:\n$$\nn_{\\mathrm{eff}} = n \\left( \\frac{4(1+\\gamma/2)}{4(1+\\gamma/2) + 4(n\\gamma/4)} \\right) = n \\left( \\frac{4+2\\gamma}{4+2\\gamma+n\\gamma} \\right)\n$$\nThis can be written in a more factored form:\n$$\nn_{\\mathrm{eff}} = \\frac{2n(2+\\gamma)}{4+(n+2)\\gamma}\n$$\nThis is the final expression for the effective Hill coefficient.\nThe final results for the two requested quantities are:\n$\\mathrm{EC}_{50}^{\\mathrm{(cl)}} = K(1 + \\gamma/2)$ and $n_{\\mathrm{eff}} = \\frac{2n(2+\\gamma)}{4+(n+2)\\gamma}$.\nWe will present these in a row matrix as requested.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2n(2+\\gamma)}{4+(n+2)\\gamma} & K\\left(1+\\frac{\\gamma}{2}\\right) \\end{pmatrix}}\n$$", "id": "2605591"}, {"introduction": "Moving from steady-state analysis to dynamic behavior, we now explore how negative feedback can generate complex temporal patterns like oscillations. This computational exercise uses a model of the NF-$\\kappa$B pathway, a canonical example of a biological oscillator, to investigate how stimulus duration controls the number of response pulses. This practice provides hands-on experience in simulating a dynamic system and linking its architecture to its functional output. [@problem_id:2605661]", "problem": "You are given a minimal dynamical model of Nuclear Factor kappa-light-chain-enhancer of activated B cells (NF-$\\kappa$B) signaling with inhibitor of kappa B (I$\\kappa$B) negative feedback and a pulsed inhibitor of kappa B kinase (IKK) input. The model is based on mass-action style kinetics and a Hill-type transcriptional regulation, which are standard in biochemical reaction network modeling. You will implement the model, simulate it for a set of IKK pulse durations, and compute the number of peaks in nuclear NF-$\\kappa$B translocation for each case. Finally, you will justify the observed dependence on pulse duration using a timescale argument.\n\nFundamental base and assumptions:\n- Use ordinary differential equations derived from mass balance and mass-action-like kinetics for species interconversion and degradation.\n- Use a Hill function to represent transcriptional activation of I$\\kappa$B messenger ribonucleic acid (mRNA) by nuclear NF-$\\kappa$B, which is a standard coarse-grained representation of cooperative promoter activation.\n- Conserve total NF-$\\kappa$B abundance at a fixed value and represent sequestration of cytosolic NF-$\\kappa$B by I$\\kappa$B as a reduction in the pool available for nuclear import.\n\nState variables:\n- $N_n(t)$: nuclear NF-$\\kappa$B abundance (arbitrary units).\n- $I_m(t)$: I$\\kappa$B mRNA abundance (arbitrary units).\n- $I(t)$: I$\\kappa$B protein abundance (arbitrary units).\n\nInput:\n- $u(t)$: IKK activity modeled as a rectangular pulse of amplitude $A$ and duration $D$ minutes, where $u(t) = A$ for $0 \\le t \\le D$ and $u(t) = 0$ otherwise.\n\nModel equations:\n- $$\\frac{d I_m}{dt} = k_{\\mathrm{tx}} \\cdot \\frac{N_n(t)^h}{K^h + N_n(t)^h} - k_{\\mathrm{mdeg}} \\cdot I_m(t)$$\n- $$\\frac{d I}{dt} = k_{\\mathrm{tl}} \\cdot I_m(t) - \\left(k_{\\mathrm{deg0}} + k_{\\mathrm{deg1}} \\cdot u(t)\\right) \\cdot I(t)$$\n- $$\\frac{d N_n}{dt} = k_{\\mathrm{in}} \\cdot N_{\\mathrm{free}}(t) - k_{\\mathrm{out}} \\cdot N_n(t)$$\nwith\n- $$N_{\\mathrm{free}}(t) = \\frac{N_{\\mathrm{tot}} - N_n(t)}{1 + \\alpha \\cdot I(t)}$$\nwhich phenomenologically captures cytosolic sequestration of NF-$\\kappa$B by I$\\kappa$B.\n\nParameters to use (time in minutes, all other quantities in consistent arbitrary units):\n- $N_{\\mathrm{tot}} = 1.0$\n- $k_{\\mathrm{in}} = 0.5$\n- $k_{\\mathrm{out}} = 0.05$\n- $\\alpha = 50.0$\n- $k_{\\mathrm{tx}} = 0.5$\n- $K = 0.2$\n- $h = 4$\n- $k_{\\mathrm{mdeg}} = 0.01$\n- $k_{\\mathrm{tl}} = 0.1$\n- $k_{\\mathrm{deg0}} = 0.002$\n- $k_{\\mathrm{deg1}} = 0.01$\n- $A = 1.0$\n\nSimulation protocol:\n- Pre-equilibrate the system under no stimulus by simulating with $u(t) \\equiv 0$ from $t = 0$ to $t = T_{\\mathrm{pre}}$, where $T_{\\mathrm{pre}} = 1000$ minutes. Use any reasonable nonnegative initial condition and take the end state as the steady-state initial condition at $t = 0$ for the pulse simulation.\n- For each pulse duration $D$, simulate the system from $t = 0$ to $t = T_{\\mathrm{sim}}(D)$ with the input $u(t)$ as defined above, where $T_{\\mathrm{sim}}(D) = D + T_{\\mathrm{post}}$ and $T_{\\mathrm{post}} = 360$ minutes. Time is in minutes.\n- Sample the nuclear NF-$\\kappa$B trajectory $N_n(t)$ at a uniform resolution fine enough to detect peaks; a step size of $\\Delta t = 0.5$ minutes is sufficient.\n\nPeak counting:\n- Define a nuclear translocation peak as a local maximum of $N_n(t)$ satisfying a minimum height condition $N_n \\ge N_{\\mathrm{th}}$ and a minimum prominence to avoid counting noise, with $N_{\\mathrm{th}} = 0.15$ and a minimum prominence of $0.05$ (in the same arbitrary units as $N_n$).\n- To avoid counting potential numerical artifacts at the very start of the time course, discard any peaks occurring before $t_{\\mathrm{min}} = 1.0$ minutes.\n- Impose a minimum time between peaks of $\\Delta t_{\\mathrm{min}} = 20$ minutes to reflect the biological refractory period associated with I$\\kappa$B resynthesis.\n\nRequired outputs:\n- For each pulse duration $D$, compute the integer number of peaks in $N_n(t)$ over the interval $t \\in [0, T_{\\mathrm{sim}}(D)]$ according to the criteria above.\n\nTest suite:\n- Use the following IKK pulse durations (in minutes): $[0.0, 5.0, 30.0, 120.0, 480.0]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\"[r_1,r_2,r_3,r_4,r_5]\"$, where each $r_i$ is the integer number of peaks for the corresponding test case in the order given.\n\nDeliverables:\n- A complete program that performs the pre-equilibration, runs the simulations for the specified pulse durations, counts peaks as specified, and prints the single-line output in the exact format above. Include, in comments or documentation, a brief timescale-based justification explaining why increasing the IKK pulse duration $D$ tends to increase the number of nuclear translocation peaks in this negative feedback system. All time quantities must be interpreted in minutes, and the outputs are unitless integers.", "solution": "The problem is subjected to validation.\n\n**Step 1: Extract Givens**\nThe provided information consists of a system of ordinary differential equations (ODEs), parameters, and a simulation protocol.\n- State Variables: $I_m(t)$ (I$\\kappa$B mRNA), $I(t)$ (I$\\kappa$B protein), $N_n(t)$ (nuclear NF-$\\kappa$B).\n- Input Signal: $u(t)$ representing IKK activity, where $u(t) = A$ for $0 \\le t \\le D$ and $u(t) = 0$ otherwise.\n- Model Equations:\n$$ \\frac{d I_m}{dt} = k_{\\mathrm{tx}} \\cdot \\frac{N_n(t)^h}{K^h + N_n(t)^h} - k_{\\mathrm{mdeg}} \\cdot I_m(t) $$\n$$ \\frac{d I}{dt} = k_{\\mathrm{tl}} \\cdot I_m(t) - \\left(k_{\\mathrm{deg0}} + k_{\\mathrm{deg1}} \\cdot u(t)\\right) \\cdot I(t) $$\n$$ \\frac{d N_n}{dt} = k_{\\mathrm{in}} \\cdot N_{\\mathrm{free}}(t) - k_{\\mathrm{out}} \\cdot N_n(t) $$\n- Auxiliary Equation:\n$$ N_{\\mathrm{free}}(t) = \\frac{N_{\\mathrm{tot}} - N_n(t)}{1 + \\alpha \\cdot I(t)} $$\n- Parameters: $N_{\\mathrm{tot}} = 1.0$, $k_{\\mathrm{in}} = 0.5 \\text{ min}^{-1}$, $k_{\\mathrm{out}} = 0.05 \\text{ min}^{-1}$, $\\alpha = 50.0$, $k_{\\mathrm{tx}} = 0.5 \\text{ min}^{-1}$, $K = 0.2$, $h = 4$, $k_{\\mathrm{mdeg}} = 0.01 \\text{ min}^{-1}$, $k_{\\mathrm{tl}} = 0.1 \\text{ min}^{-1}$, $k_{\\mathrm{deg0}} = 0.002 \\text{ min}^{-1}$, $k_{\\mathrm{deg1}} = 0.01 \\text{ min}^{-1}$, $A = 1.0$.\n- Simulation Protocol:\n  - Pre-equilibration: $T_{\\mathrm{pre}} = 1000$ min with $u(t)=0$.\n  - Simulation: For each duration $D$, integrate from $t=0$ to $T_{\\mathrm{sim}}(D) = D + 360$ min.\n  - Time step for sampling: $\\Delta t = 0.5$ min.\n- Peak Counting Criteria:\n  - Minimum height: $N_{\\mathrm{th}} = 0.15$.\n  - Minimum prominence: $0.05$.\n  - Minimum start time: $t_{\\mathrm{min}} = 1.0$ min.\n  - Minimum separation: $\\Delta t_{\\mathrm{min}} = 20$ min.\n- Test Cases for $D$: $[0.0, 5.0, 30.0, 120.0, 480.0]$ minutes.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is analyzed for validity.\n- **Scientific Grounding**: The model is a standard representation of the NF-$\\kappa$B signaling pathway, a canonical example of a biological oscillator driven by a negative feedback loop. The mathematical formulation using mass-action kinetics and a Hill function is a well-established and scientifically sound method in systems biology.\n- **Well-Posedness**: The problem defines a non-autonomous system of first-order ODEs with specified parameters and a procedure for determining initial conditions. The right-hand side of the ODE system is composed of elementary functions that are continuously differentiable (Lipschitz continuous) over the domain of biological interest (non-negative concentrations). This guarantees the existence and uniqueness of a solution for a given initial condition, making it a well-posed initial value problem.\n- **Completeness and Consistency**: The problem is self-contained. All necessary equations, constants, initial/boundary conditions, and analysis procedures are explicitly provided. There are no contradictions. The units are consistent (time in minutes, concentrations in arbitrary units).\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a well-defined, scientifically grounded problem in computational systems biology. I will proceed with the solution.\n\n**Solution Procedure**\n\nThe solution involves three main stages: system pre-equilibration, stimulus-response simulation, and trajectory analysis for peak counting.\n\n1.  **System Pre-equilibration**: To establish the basal, un-stimulated state of the system, we must first find the steady-state concentrations of all species in the absence of the IKK stimulus. This is achieved by solving the system of ODEs with the input $u(t)$ set to zero for all time.\n    The system to be solved is:\n    $$ \\frac{d I_m}{dt} = k_{\\mathrm{tx}} \\frac{N_n^h}{K^h + N_n^h} - k_{\\mathrm{mdeg}} I_m $$\n    $$ \\frac{d I}{dt} = k_{\\mathrm{tl}} I_m - k_{\\mathrm{deg0}} I $$\n    $$ \\frac{d N_n}{dt} = k_{\\mathrm{in}} \\frac{N_{\\mathrm{tot}} - N_n}{1 + \\alpha I} - k_{\\mathrm{out}} N_n $$\n    We integrate this system numerically from a non-negative initial condition (e.g., $[I_m, I, N_n] = [0, 0, 0]$) for a duration $T_{\\mathrm{pre}} = 1000$ minutes. This time is sufficiently long for the system to converge to its fixed point. The state vector at $t = T_{\\mathrm{pre}}$ is then used as the initial condition, $\\vec{y}_0 = [I_m(0), I(0), N_n(0)]$, for the subsequent simulations.\n\n2.  **Stimulus-Response Simulation**: For each pulse duration $D$ in the provided test suite, the full system, including the time-dependent input $u(t)$, is simulated. The ODE system is integrated from $t=0$ to $T_{\\mathrm{sim}}(D) = D + 360$ minutes, starting from the pre-equilibrated state $\\vec{y}_0$. The input $u(t)$ is implemented as a piecewise function:\n    $$ u(t) = \\begin{cases} A, & \\text{if } 0 \\le t \\le D \\\\ 0, & \\text{if } t > D \\end{cases} $$\n    The numerical integration is performed using a robust ODE solver, such as `scipy.integrate.solve_ivp`, with the solution evaluated at uniform time intervals of $\\Delta t = 0.5$ minutes to generate the time series for $N_n(t)$.\n\n3.  **Peak Detection and Counting**: The simulated trajectory of nuclear NF-$\\kappa$B, $N_n(t)$, is analyzed to quantify the number of translocation events. A peak is defined as a local maximum in the $N_n(t)$ signal. We use a standard peak detection algorithm, for example `scipy.signal.find_peaks`, to identify these maxima. The identified peaks are then filtered according to the following strict criteria:\n    - The peak height must be $N_n(t_{\\text{peak}}) \\ge N_{\\mathrm{th}} = 0.15$.\n    - The peak must have a prominence of at least $0.05$. Prominence measures how much a peak stands out from the surrounding signal.\n    - Peaks occurring before $t_{\\mathrm{min}} = 1.0$ minute are discarded to avoid numerical artifacts at the beginning of the simulation.\n    - A minimum temporal separation of $\\Delta t_{\\mathrm{min}} = 20$ minutes between consecutive peaks is enforced. This reflects a biological refractory period.\n    The final count of peaks passing all filters is the result for a given pulse duration $D$.\n\nThis entire procedure is repeated for each value of $D$ in the test suite to generate the final list of results. The justification for the resulting trend is provided in the documentation of the implementation code.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    This program solves a minimal dynamical model of NF-kB signaling to determine\n    the number of nuclear translocation peaks as a function of stimulus duration.\n\n    Timescale-based justification for observed behavior:\n    The NF-kB signaling system modeled here is a classic negative feedback oscillator.\n    1.  Stimulus Onset: The IKK stimulus `u(t)` enhances degradation of the inhibitor `I` (IkB).\n        This frees NF-kB from cytoplasmic sequestration.\n    2.  First Peak: Free NF-kB translocates to the nucleus, causing `N_n` to rise and form a peak.\n    3.  Negative Feedback: High `N_n` transcriptionally upregulates its own inhibitor `I` via an intermediate `I_m` (IkB mRNA).\n        This feedback has an inherent time delay due to the sequential processes of transcription and translation.\n    4.  Repression: As newly synthesized `I` protein accumulates, it sequesters NF-kB in the cytoplasm again,\n        and nuclear export further reduces `N_n`, causing the signal to fall.\n    5.  Sustained Oscillations: If the stimulus duration `D` is long enough to outlast the feedback delay,\n        the IKK activity will degrade the newly synthesized inhibitor, re-initiating the cycle and\n        leading to subsequent peaks. The system's intrinsic oscillatory period is determined by the\n        timescales of transcription, translation, and nuclear transport.\n    6.  Dependence on D: The number of peaks is therefore dependent on the ratio of the stimulus duration `D` to the\n        system's intrinsic feedback period `tau_fb`.\n        - If `D` is very short (shorter than the time to the first peak), no significant response occurs.\n        - If `D` is long enough for one response but shorter than `tau_fb`, one peak is observed.\n        - As `D` increases, it can encompass multiple cycles of `tau_fb`, allowing the system to oscillate\n          and produce a greater number of peaks before the stimulus is removed and the system damps\n          back to its steady state. Thus, the number of peaks is expected to be a non-decreasing\n          function of `D`.\n    \"\"\"\n\n    # Define model parameters\n    params = {\n        'N_tot': 1.0,\n        'k_in': 0.5,\n        'k_out': 0.05,\n        'alpha': 50.0,\n        'k_tx': 0.5,\n        'K': 0.2,\n        'h': 4.0,\n        'k_mdeg': 0.01,\n        'k_tl': 0.1,\n        'k_deg0': 0.002,\n        'k_deg1': 0.01,\n        'A': 1.0,  # Amplitude of u(t)\n    }\n\n    # Simulation and analysis parameters\n    T_pre = 1000.0  # min\n    T_post = 360.0  # min\n    dt = 0.5  # min\n\n    # Peak counting parameters\n    N_th = 0.15\n    prominence = 0.05\n    t_min_peak = 1.0  # min\n    delta_t_min_peak = 20.0  # min\n    \n    # Test suite for pulse durations D\n    test_cases = [0.0, 5.0, 30.0, 120.0, 480.0]\n\n    # --- Step 1: Pre-equilibration ---\n    def odes_pre(t, y, p):\n        I_m, I, N_n = y\n        # No stimulus, u(t) = 0\n        N_free = (p['N_tot'] - N_n) / (1.0 + p['alpha'] * I)\n        \n        dIm_dt = p['k_tx'] * (N_n**p['h']) / (p['K']**p['h'] + N_n**p['h']) - p['k_mdeg'] * I_m\n        dI_dt = p['k_tl'] * I_m - p['k_deg0'] * I\n        dNn_dt = p['k_in'] * N_free - p['k_out'] * N_n\n        \n        return [dIm_dt, dI_dt, dNn_dt]\n\n    y0_initial = [0.0, 0.0, 0.0]\n    sol_pre = solve_ivp(\n        odes_pre,\n        [0, T_pre],\n        y0_initial,\n        args=(params,),\n        dense_output=True\n    )\n    y0_ss = sol_pre.sol(T_pre)\n\n    # --- Step 2 & 3: Simulation and Peak Counting Loop ---\n    \n    def odes_pulse(t, y, p, D):\n        I_m, I, N_n = y\n        \n        u_t = p['A'] if 0 = t = D else 0.0\n        \n        N_free = (p['N_tot'] - N_n) / (1.0 + p['alpha'] * I)\n        \n        dIm_dt = p['k_tx'] * (N_n**p['h']) / (p['K']**p['h'] + N_n**p['h']) - p['k_mdeg'] * I_m\n        dI_dt = p['k_tl'] * I_m - (p['k_deg0'] + p['k_deg1'] * u_t) * I\n        dNn_dt = p['k_in'] * N_free - p['k_out'] * N_n\n        \n        return [dIm_dt, dI_dt, dNn_dt]\n\n    results = []\n    for D in test_cases:\n        T_sim = D + T_post\n        t_eval = np.arange(0, T_sim + dt, dt)\n        \n        sol = solve_ivp(\n            odes_pulse,\n            [0, T_sim],\n            y0_ss,\n            args=(params, D),\n            t_eval=t_eval,\n            method='RK45'\n        )\n        \n        t_traj = sol.t\n        Nn_traj = sol.y[2, :]\n\n        # Peak counting\n        distance_indices = int(delta_t_min_peak / dt)\n        \n        peaks, _ = find_peaks(\n            Nn_traj,\n            height=N_th,\n            prominence=prominence,\n            distance=distance_indices\n        )\n        \n        # Filter peaks by minimum time\n        final_peaks = [p for p in peaks if t_traj[p] >= t_min_peak]\n        \n        num_peaks = len(final_peaks)\n        results.append(num_peaks)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2605661"}, {"introduction": "The ultimate test of a signaling model is its ability to explain experimental data and discriminate between competing hypotheses. This final practice bridges theory and experiment by introducing a powerful statistical method: Bayesian model selection. You will implement a test to determine which of two proposed crosstalk mechanisms is better supported by a dataset from a kinase inhibitor titration, a critical skill for robustly interpreting quantitative biological data. [@problem_id:2605680]", "problem": "Construct a principled model selection test to discriminate between two mechanistic hypotheses of kinase network crosstalk under inhibitor titration, and compute the Bayes factor from integrated likelihoods. Use the following foundations and assumptions.\n\n- Biochemical foundation. Consider a substrate undergoing phosphorylation and dephosphorylation. At a quasi-steady state with low phosphorylation occupancy, the phosphorylated fraction can be approximated by $p \\approx v_{\\text{phos}}/k_{\\text{dephos}}$, where $v_{\\text{phos}}$ is the net phosphorylation rate and $k_{\\text{dephos}}$ is an effective first-order dephosphorylation rate constant. A small-molecule inhibitor reduces active kinase activity, and the inhibitor response of the inhibited kinase is approximated by a Hill function with Hill coefficient $h=1$, leading to an activity modulation factor $x(c) = \\frac{1}{1 + (c/K)^{h}} = \\frac{1}{1 + c/K}$, where $c$ is the inhibitor concentration and $K$ is the half-maximal inhibitory concentration (IC50).\n\n- Competing crosstalk mechanisms mapped to linear-in-parameter models. Under the low-occupancy approximation, define two linear-in-parameter observation models for the measured phosphorylation readout $y_i$ at inhibitor concentration $c_i$:\n  1. Model $\\mathcal{M}_A$ (parallel feedforward crosstalk unaffected by inhibitor): $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$, with $x_i = \\frac{1}{1 + c_i/K}$.\n  2. Model $\\mathcal{M}_B$ (sequestration-like crosstalk that modulates dephosphorylation proportional to inhibitor, captured to first order as an $x_i c_i$ interaction): $y_i = \\beta_1' x_i + \\beta_2' (x_i c_i) + \\varepsilon_i$.\n  In both models, the measurement noise is independent and identically distributed Gaussian: $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ with known variance $\\sigma^2$.\n\n- Bayesian linear model with Gaussian prior. For each model $\\mathcal{M}$ with design matrix $X \\in \\mathbb{R}^{n \\times p}$ and parameter vector $\\theta \\in \\mathbb{R}^{p}$, assume a zero-mean isotropic Gaussian prior $\\theta \\sim \\mathcal{N}(0,\\tau^2 I_p)$ with known variance $\\tau^2$. Given data vector $y \\in \\mathbb{R}^{n}$ and noise variance $\\sigma^2$, the marginal likelihood is\n  $$p(y \\mid X,\\sigma^2,\\tau^2) = \\mathcal{N}\\!\\left(y \\mid 0,\\, C\\right), \\quad C = \\sigma^2 I_n + \\tau^2 X X^\\top,$$\n  which yields the log-marginal likelihood\n  $$\\log p(y \\mid X,\\sigma^2,\\tau^2) = -\\frac{1}{2}\\left(n \\log(2\\pi) + \\log\\det C + y^\\top C^{-1} y\\right).$$\n\n- Bayes factor. For the two models, compute\n  $$\\mathcal{K}_{A/B} = \\frac{p(y \\mid \\mathcal{M}_A)}{p(y \\mid \\mathcal{M}_B)} = \\exp\\!\\left(\\log p(y \\mid X_A,\\sigma^2,\\tau^2) - \\log p(y \\mid X_B,\\sigma^2,\\tau^2)\\right).$$\n\nImplementation requirements.\n\n- Constants and definitions. Use $K = 0.5$ and $h = 1$ in the definition $x_i = \\frac{1}{1 + (c_i/K)^h}$. For model $\\mathcal{M}_A$, the design matrix is $X_A = [\\mathbf{1},\\, x] \\in \\mathbb{R}^{n \\times 2}$. For model $\\mathcal{M}_B$, the design matrix is $X_B = [x,\\, x \\odot c] \\in \\mathbb{R}^{n \\times 2}$, where $\\odot$ denotes elementwise multiplication. Use the same Gaussian prior variance $\\tau^2 = 1.0$ for both models. The noise variance $\\sigma^2$ is provided per test case.\n\n- Numerical method. Compute $\\log p(y \\mid X,\\sigma^2,\\tau^2)$ using the covariance form $C = \\sigma^2 I_n + \\tau^2 X X^\\top$ with a numerically stable method for $\\log\\det C$ and $C^{-1} y$ (for example, Cholesky factorization).\n\n- Final output format. Your program should produce a single line of output containing the Bayes factors $\\mathcal{K}_{A/B}$ for each test case, in order, as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., $[1.234000,0.015923]$). The values must be plain decimals (no scientific notation), and no percentage signs should be used.\n\nTest suite.\n\nFor all test cases, use the same inhibitor concentrations $c = [0.0,\\, 0.1,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0]$ unless otherwise specified. All $y$ values are dimensionless fractions. Each test case provides $(c, y, \\sigma^2)$.\n\n- Test case $1$ (happy path favoring $\\mathcal{M}_A$): $c = [0.0,\\, 0.1,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0]$, $y = [0.71,\\, 0.595,\\, 0.4,\\, 0.305,\\, 0.218,\\, 0.1575454545]$, $\\sigma^2 = 0.0025$.\n\n- Test case $2$ (happy path favoring $\\mathcal{M}_B$): $c = [0.0,\\, 0.1,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0]$, $y = [0.5,\\, 0.4456666667,\\, 0.319,\\, 0.2716666667,\\, 0.217,\\, 0.1838181818]$, $\\sigma^2 = 0.0025$.\n\n- Test case $3$ (edge case: approximately flat data): $c = [0.0,\\, 0.1,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0]$, $y = [0.2,\\, 0.199,\\, 0.201,\\, 0.2,\\, 0.198,\\, 0.202]$, $\\sigma^2 = 0.0025$.\n\n- Test case $4$ (boundary: minimal data points): $c = [0.0,\\, 1.0]$, $y = [0.102,\\, 0.0323333333]$, $\\sigma^2 = 0.0025$.\n\n- Test case $5$ (high noise, still generated from $\\mathcal{M}_A$): $c = [0.0,\\, 0.1,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0]$, $y = [0.63,\\, 0.4966666667,\\, 0.25,\\, 0.2366666667,\\, 0.14,\\, 0.09545454545]$, $\\sigma^2 = 0.01$.\n\nYour program must:\n\n- For each test case, construct $X_A$ and $X_B$ from $c$ using $K = 0.5$ and $h = 1$, and compute $\\mathcal{K}_{A/B}$ with $\\tau^2 = 1.0$ and the provided $\\sigma^2$.\n- Produce a single line as the final output: a list of the five Bayes factors in the order of the test cases, rounded to six decimal places, formatted exactly as $[v_1,v_2,v_3,v_4,v_5]$.", "solution": "The problem requires the implementation of a Bayesian model selection test to discriminate between two competing mechanistic hypotheses, denoted $\\mathcal{M}_A$ and $\\mathcal{M}_B$, describing the response of a phosphorylated substrate to a kinase inhibitor. The metric for model comparison is the Bayes factor, $\\mathcal{K}_{A/B}$, which is the ratio of the marginal likelihoods of the two models.\n\nThe fundamental task is to compute the log-marginal likelihood for a Bayesian linear model with Gaussian priors. The problem provides the formula for the marginal likelihood $p(y \\mid X, \\sigma^2, \\tau^2)$ as a multivariate Gaussian distribution with a covariance matrix $C = \\sigma^2 I_n + \\tau^2 X X^\\top$. The corresponding log-marginal likelihood is:\n$$ \\log p(y \\mid X, \\sigma^2, \\tau^2) = -\\frac{1}{2}\\left(n \\log(2\\pi) + \\log\\det C + y^\\top C^{-1} y\\right) $$\nHere, $y \\in \\mathbb{R}^n$ is the vector of observations, $X \\in \\mathbb{R}^{n \\times p}$ is the model's design matrix, $\\sigma^2$ is the known measurement noise variance, $\\tau^2$ is the known prior variance for the model parameters, $n$ is the number of data points, and $p$ is the number of parameters.\n\nA direct computation involving the $n \\times n$ matrix $C$ can be numerically unstable and inefficient, especially as $n$ grows. Since $p \\ll n$ in our cases ($p=2$), we can use the Woodbury matrix identity and related determinant lemmas to reformulate the problem in terms of $p \\times p$ matrices, which is significantly more efficient and stable.\n\nThe required terms are $\\log\\det C$ and the quadratic form $y^\\top C^{-1} y$.\n\n1.  **Computation of the Log-Determinant**:\n    Using Sylvester's determinant identity, $\\det(I_n + AB) = \\det(I_p + BA)$ for $A \\in \\mathbb{R}^{n \\times p}$ and $B \\in \\mathbb{R}^{p \\times n}$, we can rewrite $\\log\\det C$:\n    $$ \\log\\det C = \\log\\det(\\sigma^2 I_n + \\tau^2 X X^\\top) = \\log\\det\\left((\\sigma^2)^n \\left(I_n + \\frac{\\tau^2}{\\sigma^2} X X^\\top\\right)\\right) $$\n    $$ = n \\log(\\sigma^2) + \\log\\det\\left(I_n + X \\left(\\frac{\\tau^2}{\\sigma^2} X^\\top\\right)\\right) = n \\log(\\sigma^2) + \\log\\det\\left(I_p + \\left(\\frac{\\tau^2}{\\sigma^2} X^\\top\\right) X\\right) $$\n    $$ \\log\\det C = n \\log(\\sigma^2) + \\log\\det\\left(I_p + \\frac{\\tau^2}{\\sigma^2} X^\\top X\\right) $$\n    This calculation only requires the determinant of a $p \\times p$ matrix.\n\n2.  **Computation of the Quadratic Form**:\n    Using the Woodbury matrix identity, the inverse of $C$ is:\n    $$ C^{-1} = (\\sigma^2 I_n + \\tau^2 X X^\\top)^{-1} = \\frac{1}{\\sigma^2}I_n - \\frac{\\tau^2}{\\sigma^2} X (\\sigma^2 I_p + \\tau^2 X^\\top X)^{-1} X^\\top $$\n    The quadratic form $y^\\top C^{-1} y$ becomes:\n    $$ y^\\top C^{-1} y = \\frac{1}{\\sigma^2} y^\\top \\left( I_n - \\tau^2 X Q^{-1} X^\\top \\right) y $$\n    where $Q = \\sigma^2 I_p + \\tau^2 X^\\top X$. This simplifies to:\n    $$ y^\\top C^{-1} y = \\frac{1}{\\sigma^2} \\left( y^\\top y - \\tau^2 (X^\\top y)^\\top Q^{-1} (X^\\top y) \\right) $$\n    This avoids the explicit inversion of the $n \\times n$ matrix $C$, replacing it with solving a small $p \\times p$ linear system $Qv = X^\\top y$.\n\nThe overall procedure for each test case is as follows:\n\nFirst, for a given vector of inhibitor concentrations $c$, we compute the modulated kinase activity vector $x$. With $K=0.5$ and $h=1$, each element $x_i$ is given by $x_i = \\frac{1}{1 + c_i / K}$.\n\nNext, we construct the design matrices for each model:\n-   Model $\\mathcal{M}_A$: $y_i = \\beta_0 + \\beta_1 x_i + \\varepsilon_i$. The design matrix is $X_A = [\\mathbf{1}, x] \\in \\mathbb{R}^{n \\times 2}$.\n-   Model $\\mathcal{M}_B$: $y_i = \\beta_1' x_i + \\beta_2' (x_i c_i) + \\varepsilon_i$. The design matrix is $X_B = [x, x \\odot c] \\in \\mathbb{R}^{n \\times 2}$, where $\\odot$ is the elementwise product.\n\nThen, for each model ($\\mathcal{M}_A$ and $\\mathcal{M}_B$), we compute its log-marginal likelihood, denoted $\\text{LML}_A$ and $\\text{LML}_B$, respectively, using the numerically stable method described above with the prior variance $\\tau^2 = 1.0$ and the test case's specific noise variance $\\sigma^2$ and data $y$.\n\nFinally, the Bayes factor $\\mathcal{K}_{A/B}$ is computed as:\n$$ \\mathcal{K}_{A/B} = \\frac{p(y \\mid \\mathcal{M}_A)}{p(y \\mid \\mathcal{M}_B)} = \\exp(\\text{LML}_A - \\text{LML}_B) $$\nThis procedure is iterated for all five test cases provided.", "answer": "```python\nimport numpy as np\n\ndef calculate_log_marginal_likelihood(y: np.ndarray, X: np.ndarray, sigma_sq: float, tau_sq: float) - float:\n    \"\"\"\n    Computes the log-marginal likelihood for a Bayesian linear model.\n\n    The model is y = Xθ + ε, with prior θ ~ N(0, τ²I) and noise ε ~ N(0, σ²I).\n    The log-marginal likelihood is:\n    log p(y|X,σ²,τ²) = - (n/2)log(2π) - (1/2)log(det(C)) - (1/2)yᵀC⁻¹y\n    where C = σ²I + τ²XXᵀ.\n\n    This function uses the Woodbury matrix identity for efficient and stable computation.\n\n    Args:\n        y: Observation vector (n,).\n        X: Design matrix (n, p).\n        sigma_sq: Variance of the Gaussian noise.\n        tau_sq: Variance of the Gaussian prior on parameters.\n\n    Returns:\n        The log-marginal likelihood.\n    \"\"\"\n    n, p = X.shape\n    \n    # 1. Compute log(det(C)) using the matrix determinant lemma:\n    # log(det(C)) = n*log(σ²) + log(det(I + (τ²/σ²)XᵀX))\n    X_T_X = X.T @ X\n    M = (tau_sq / sigma_sq) * X_T_X\n    log_det_C = n * np.log(sigma_sq) + np.log(np.linalg.det(np.identity(p) + M))\n\n    # 2. Compute yᵀC⁻¹y using the Woodbury matrix identity:\n    # yᵀC⁻¹y = (1/σ²)(yᵀy - τ²(Xᵀy)ᵀ(σ²I + τ²XᵀX)⁻¹(Xᵀy))\n    Q = sigma_sq * np.identity(p) + tau_sq * X_T_X\n    X_T_y = X.T @ y\n    \n    # Solve the linear system Qz = X_T_y for z\n    z = np.linalg.solve(Q, X_T_y)\n    \n    y_T_C_inv_y = (1 / sigma_sq) * (y.T @ y - tau_sq * X_T_y.T @ z)\n\n    # 3. Combine terms for the log-marginal likelihood\n    log_ml = -0.5 * (n * np.log(2 * np.pi) + log_det_C + y_T_C_inv_y)\n    \n    return log_ml\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define constants\n    K = 0.5\n    tau_sq = 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'c': np.array([0.0, 0.1, 0.5, 1.0, 2.0, 5.0]), 'y': np.array([0.71, 0.595, 0.4, 0.305, 0.218, 0.1575454545]), 'sigma_sq': 0.0025},\n        {'c': np.array([0.0, 0.1, 0.5, 1.0, 2.0, 5.0]), 'y': np.array([0.5, 0.4456666667, 0.319, 0.2716666667, 0.217, 0.1838181818]), 'sigma_sq': 0.0025},\n        {'c': np.array([0.0, 0.1, 0.5, 1.0, 2.0, 5.0]), 'y': np.array([0.2, 0.199, 0.201, 0.2, 0.198, 0.202]), 'sigma_sq': 0.0025},\n        {'c': np.array([0.0, 1.0]), 'y': np.array([0.102, 0.0323333333]), 'sigma_sq': 0.0025},\n        {'c': np.array([0.0, 0.1, 0.5, 1.0, 2.0, 5.0]), 'y': np.array([0.63, 0.4966666667, 0.25, 0.2366666667, 0.14, 0.09545454545]), 'sigma_sq': 0.01}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        c, y, sigma_sq = case['c'], case['y'], case['sigma_sq']\n        \n        # Calculate the modulated kinase activity factor x\n        x = 1.0 / (1.0 + c / K)\n        \n        # Construct design matrices for both models\n        # Model A: y = β₀ + β₁x\n        X_A = np.vstack([np.ones_like(x), x]).T\n        \n        # Model B: y = β₁'x + β₂'(xc)\n        X_B = np.vstack([x, x * c]).T\n        \n        # Calculate log-marginal likelihood for Model A\n        lml_A = calculate_log_marginal_likelihood(y, X_A, sigma_sq, tau_sq)\n        \n        # Calculate log-marginal likelihood for Model B\n        lml_B = calculate_log_marginal_likelihood(y, X_B, sigma_sq, tau_sq)\n        \n        # Calculate the Bayes factor K_A/B\n        bayes_factor = np.exp(lml_A - lml_B)\n        \n        results.append(bayes_factor)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2605680"}]}