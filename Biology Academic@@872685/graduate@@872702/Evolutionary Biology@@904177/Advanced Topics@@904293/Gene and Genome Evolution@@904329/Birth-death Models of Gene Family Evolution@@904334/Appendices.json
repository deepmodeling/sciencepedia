{"hands_on_practices": [{"introduction": "Understanding the long-term fate of a gene family is a central question in evolutionary genomics. This exercise guides you through the derivation of the extinction probability, $q_{i}(t)$, a core quantity in any birth-death model. By considering the process over an infinitesimal time step, you will formulate and solve a differential equation that governs this probability, providing a powerful example of how the model's simple rules give rise to complex dynamics [@problem_id:2694516].", "problem": "Consider a continuous-time linear birth-death branching process modeling the size of a gene family. Each gene copy independently duplicates at per-copy rate $\\lambda > 0$ (gene duplication) and is lost at per-copy rate $\\mu > 0$ (gene loss). Assume that these rates are constant over time, that lineages evolve independently conditional on the process history (the branching property), and that there is no origination from outside the family except by duplication. Let $t \\ge 0$ denote time, and suppose the family starts at time $t=0$ with $i \\in \\mathbb{N}$ copies. Define $q_{1}(t)$ as the probability that the gene family is extinct (has size $0$) by time $t$ when starting from a single copy at time $0$.\n\nStarting only from the Markov property of the process and the independence of descendant lineages, derive a closed-form expression for $q_{1}(t)$ under the assumption $\\lambda \\ne \\mu$. Then, using the branching property, express the extinction probability by time $t$ when starting from $i$ copies, $q_{i}(t)$, in terms of $q_{1}(t)$. Provide a single closed-form analytical expression for $q_{i}(t)$ as a function of $\\lambda$, $\\mu$, $t$, and $i$. No numerical evaluation or rounding is required, and no units should be included in the final expression.", "solution": "The problem statement describes a continuous-time linear birth-death process, a standard model in stochastic theory. The problem is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a valid problem of mathematical biology.\n\nLet $N(t)$ denote the number of gene copies at time $t$. We are asked to find the probability of extinction by time $t$, given an initial number of copies $i$, which we denote as $q_{i}(t) = P(N(t) = 0 | N(0) = i)$. The parameters are the per-copy duplication rate $\\lambda > 0$ and the per-copy loss rate $\\mu > 0$, with the constraint $\\lambda \\ne \\mu$.\n\nFirst, we derive the expression for $q_{1}(t)$, the probability of extinction starting from a single copy. We can formulate a differential equation for $q_{1}(t)$ by considering the evolution of the process over an infinitesimally small time interval $\\Delta t$. By the law of total probability, conditioning on the event in the interval $[0, \\Delta t)$:\n$q_{1}(t + \\Delta t) = P(N(t+\\Delta t)=0 | N(0)=1)$.\n\nThe events in $[0, \\Delta t)$ are:\n1.  A duplication occurs with probability $\\lambda \\Delta t + o(\\Delta t)$, resulting in $2$ copies. By the branching property and temporal homogeneity, for the family to be extinct by time $t+\\Delta t$, both independent lineages must go extinct in the remaining time $t$. The probability for this is $(q_1(t))^2$.\n2.  A loss occurs with probability $\\mu \\Delta t + o(\\Delta t)$, resulting in $0$ copies. The family is extinct, so the probability of extinction is $1$.\n3.  No event occurs with probability $1 - (\\lambda + \\mu)\\Delta t + o(\\Delta t)$. The family still has $1$ copy. For this to be extinct by time $t+\\Delta t$, the single lineage must go extinct in the remaining time $t$. The probability is $q_1(t)$.\n\nCombining these possibilities, we write:\n$$ q_{1}(t+\\Delta t) = (\\lambda \\Delta t) [q_{1}(t)]^2 + (\\mu \\Delta t) \\cdot 1 + [1 - (\\lambda + \\mu)\\Delta t] q_{1}(t) + o(\\Delta t) $$\nRearranging the terms:\n$$ \\frac{q_{1}(t+\\Delta t) - q_{1}(t)}{\\Delta t} = \\lambda [q_{1}(t)]^2 - (\\lambda + \\mu) q_{1}(t) + \\mu + \\frac{o(\\Delta t)}{\\Delta t} $$\nTaking the limit as $\\Delta t \\to 0$, we obtain the ordinary differential equation:\n$$ \\frac{dq_{1}}{dt} = \\lambda q_{1}^2 - (\\lambda + \\mu)q_{1} + \\mu $$\nThis is a Riccati equation. The right-hand side is a quadratic in $q_1$, which can be factored. The roots of $\\lambda x^2 - (\\lambda + \\mu)x + \\mu = 0$ are $x=1$ and $x=\\mu/\\lambda$. Thus, the equation is:\n$$ \\frac{dq_{1}}{dt} = \\lambda (q_{1} - 1)(q_{1} - \\frac{\\mu}{\\lambda}) $$\nThe initial condition is that at time $t=0$, the family consists of one copy, so it is not extinct. Therefore, $q_{1}(0) = P(N(0)=0 | N(0)=1) = 0$.\n\nWe solve this separable differential equation:\n$$ \\frac{dq_{1}}{(q_{1} - 1)(q_{1} - \\frac{\\mu}{\\lambda})} = \\lambda dt $$\nUsing partial fraction decomposition on the left side, where $\\frac{1}{(x-1)(x-\\mu/\\lambda)} = \\frac{A}{x-1} + \\frac{B}{x-\\mu/\\lambda}$, we find $A = \\frac{1}{1-\\mu/\\lambda} = \\frac{\\lambda}{\\lambda-\\mu}$ and $B = \\frac{1}{\\mu/\\lambda-1} = \\frac{\\lambda}{\\mu-\\lambda}$. Since $\\lambda \\ne \\mu$, these coefficients are well-defined.\n$$ \\int \\left( \\frac{\\lambda/(\\lambda-\\mu)}{q_{1}-1} - \\frac{\\lambda/(\\lambda-\\mu)}{q_{1}-\\mu/\\lambda} \\right) dq_{1} = \\int \\lambda dt $$\n$$ \\frac{1}{\\lambda-\\mu} \\left[ \\ln|q_{1}-1| - \\ln|q_{1}-\\mu/\\lambda| \\right] = t + C $$\nwhere $C$ is the constant of integration.\n$$ \\ln\\left|\\frac{q_{1}-1}{q_{1}-\\mu/\\lambda}\\right| = (\\lambda - \\mu)t + C' $$\nUsing the initial condition $q_{1}(0) = 0$:\n$$ \\ln\\left|\\frac{0-1}{0-\\mu/\\lambda}\\right| = C' \\implies \\ln\\left|\\frac{\\lambda}{\\mu}\\right| = C' $$\nSince $\\lambda > 0$ and $\\mu > 0$, we have $C' = \\ln(\\lambda/\\mu)$.\nSubstituting $C'$ back:\n$$ \\ln\\left|\\frac{q_{1}-1}{q_{1}-\\mu/\\lambda}\\right| = (\\lambda - \\mu)t + \\ln(\\frac{\\lambda}{\\mu}) $$\nSince $q_{1}(t)$ is a probability for a non-extinct starting state, $0 \\le q_{1}(t)  1$ for finite $t>0$. Therefore, $(q_{1}-1)$ is negative. The term $(q_{1}-\\mu/\\lambda)$ is also negative (as $q_1(t)$ approaches its smaller steady state from $0$), so their ratio is positive. We can remove the absolute value.\n$$ \\frac{q_{1}-1}{q_{1}-\\mu/\\lambda} = \\exp((\\lambda - \\mu)t) \\cdot \\frac{\\lambda}{\\mu} $$\nNow we solve for $q_{1}(t)$:\n$$ \\mu(q_{1}-1) = \\lambda(q_{1}-\\mu/\\lambda)\\exp((\\lambda - \\mu)t) $$\n$$ \\mu q_{1} - \\mu = (\\lambda q_{1} - \\mu)\\exp((\\lambda - \\mu)t) $$\n$$ (\\mu - \\lambda\\exp((\\lambda - \\mu)t))q_{1} = \\mu - \\mu\\exp((\\lambda - \\mu)t) $$\n$$ q_{1}(t) = \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} $$\nThis is the closed-form expression for the extinction probability starting with one copy.\n\nNext, we find the extinction probability $q_{i}(t)$ when starting with $i$ copies. The problem specifies that lineages evolve independently (the branching property). Therefore, starting with $i$ copies at $t=0$ is equivalent to starting $i$ independent birth-death processes, each initiated with a single copy. For the entire family to be extinct at time $t$, each of these $i$ independent lineages must go extinct by time $t$.\nThe probability of this compound event is the product of the individual probabilities:\n$$ q_{i}(t) = P(\\text{lineage } 1 \\text{ extinct}) \\times \\dots \\times P(\\text{lineage } i \\text{ extinct}) $$\n$$ q_{i}(t) = [q_{1}(t)]^i $$\nFinally, we substitute the expression for $q_{1}(t)$ to obtain the single closed-form expression for $q_{i}(t)$:\n$$ q_{i}(t) = \\left( \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} \\right)^i $$\nThis expression gives the probability that a gene family, starting with $i$ members, will be extinct by time $t$, as a function of the duplication rate $\\lambda$, loss rate $\\mu$, time $t$, and initial size $i$.", "answer": "$$\\boxed{\\left( \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} \\right)^{i}}$$", "id": "2694516"}, {"introduction": "Theoretical models are only as good as our ability to apply them correctly to real data, which is often incomplete. This practice confronts a common issue in comparative genomics: ascertainment bias, where analyses are limited to gene families that have survived to the present. You will use the fundamental properties of the birth-death process to calculate the systematic error, or bias, in parameter estimates that arises from this sampling condition, illustrating a critical link between stochastic theory and robust scientific inference [@problem_id:2694480].", "problem": "A gene family evolves along a two-taxon species tree with a single speciation event at time $t$ in the past, producing two descendant lineages of equal length $t$. At the speciation node, the family has exactly one gene copy, and from that point forward each descendant lineage evolves independently as a continuous-time linear birth-death process with per-copy duplication rate $\\lambda$ and per-copy loss rate $\\mu$, with $\\lambda  \\mu$ (a subcritical regime). Gene copy numbers are integer-valued and evolve according to the branching property of linear birth-death processes.\n\nA common ascertainment practice in comparative genomics retains only those families that are present in at least one of the two extant taxa. Suppose we analyze a very large collection of such ascertained families and estimate $\\lambda$ naively by matching the average per-taxon gene count across families to the unconditioned mean of the birth-death process, ignoring the ascertainment. Specifically, let $\\bar{n}$ denote the empirical average of $(N_A + N_B)/2$ over families, where $N_A$ and $N_B$ are the extant copy numbers in the two taxa. The naive estimator of the net growth rate is $\\hat{r}_{\\text{naive}} = \\frac{1}{t} \\ln(\\bar{n})$, and the naive estimator of the duplication rate is $\\hat{\\lambda}_{\\text{naive}} = \\mu + \\hat{r}_{\\text{naive}}$. By contrast, the true duplication rate is $\\lambda$.\n\nStarting from core definitions of the linear birth-death process and the Kolmogorov forward equations, derive the extinction-by-time-$t$ probability $p_0(t)$ for a lineage starting from one copy, and the unconditioned mean $m(t)$ of the copy number at time $t$. Use these to compute the large-sample expectation of the naive estimator under ascertainment that at least one taxon retains the family, and hence obtain the asymptotic bias $\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] - \\lambda$ as a closed-form function of $\\lambda$, $\\mu$, and $t$.\n\nFinally, evaluate this bias numerically for $\\lambda = 0.1$ per million years, $\\mu = 0.3$ per million years, and $t = 10$ million years. Report the numerical value of the bias in per million years, rounded to four significant figures. Do not include units in your final boxed answer.", "solution": "The problem is valid. It is a well-posed question in mathematical evolutionary biology, grounded in the standard theory of birth-death processes and dealing with a common issue in comparative genomics, namely ascertainment bias. All necessary information is provided, and the problem is free of scientific or logical flaws.\n\nThe solution proceeds in several steps:\n1.  Derive the unconditional mean gene family size $m(t)$ and the probability of extinction $p_0(t)$ for a linear birth-death process starting from a single copy.\n2.  Characterize the ascertainment condition and calculate the probability of a family being ascertained.\n3.  Derive the large-sample expectation of the per-taxon gene count $\\bar{n}$ under this ascertainment, which we denote $\\bar{n}_{\\text{cond}}$.\n4.  Substitute this into the formula for the naive estimator $\\hat{\\lambda}_{\\text{naive}}$ to find its large-sample expectation, $\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}]$.\n5.  Calculate the asymptotic bias, $\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] - \\lambda$.\n6.  Evaluate the bias numerically using the provided parameter values.\n\nLet $N(t)$ be the number of gene copies at time $t$ in a single lineage. This process is a linear birth-death process with per-copy duplication (birth) rate $\\lambda$ and per-copy loss (death) rate $\\mu$. The initial condition is $N(0)=1$.\n\n**Step 1: Unconditional Mean and Extinction Probability**\n\nThe mean number of copies, $m(t) = \\mathbb{E}[N(t)]$, evolves according to the differential equation:\n$$\n\\frac{dm(t)}{dt} = (\\lambda - \\mu)m(t)\n$$\nWith the initial condition $m(0)=1$, the solution is:\n$$\nm(t) = \\exp((\\lambda - \\mu)t)\n$$\nThe probability of extinction by time $t$, $p_0(t) = \\mathbb{P}(N(t)=0 | N(0)=1)$, can be found by solving the backward Kolmogorov equation for this probability, which is a Riccati equation:\n$$\n\\frac{dp_0(t)}{dt} = \\mu - (\\lambda+\\mu)p_0(t) + \\lambda p_0(t)^2\n$$\nWith the initial condition $p_0(0)=0$, the solution is:\n$$\np_0(t) = \\frac{\\mu(\\exp((\\lambda - \\mu)t) - 1)}{\\lambda\\exp((\\lambda - \\mu)t) - \\mu}\n$$\nThis is a standard result for the linear birth-death process.\n\n**Step 2: Ascertainment Condition**\n\nLet $N_A$ and $N_B$ be the copy numbers in the two descendant lineages at time $t$. Both lineages start with one copy at time $0$ (the speciation event) and evolve independently for time $t$. A family is ascertained if it is present in at least one taxon, i.e., if the event $\\mathcal{A} = \\{N_A > 0 \\text{ or } N_B > 0\\}$ occurs.\n\nThe complementary event, $\\mathcal{A}^c = \\{N_A = 0 \\text{ and } N_B = 0\\}$, corresponds to the family going extinct in both lineages. Due to independence, the probability of this is:\n$$\n\\mathbb{P}(\\mathcal{A}^c) = \\mathbb{P}(N_A=0) \\mathbb{P}(N_B=0) = p_0(t) \\cdot p_0(t) = p_0(t)^2\n$$\nThe probability of ascertainment is therefore:\n$$\n\\mathbb{P}(\\mathcal{A}) = 1 - \\mathbb{P}(\\mathcal{A}^c) = 1 - p_0(t)^2\n$$\n\n**Step 3: Conditional Mean Gene Count**\n\nThe problem defines $\\bar{n}$ as the empirical average of $\\frac{N_A + N_B}{2}$ across a large collection of ascertained families. In the large-sample limit, $\\bar{n}$ converges to the conditional expectation $\\bar{n}_{\\text{cond}} = \\mathbb{E}\\left[\\frac{N_A + N_B}{2} \\Big| \\mathcal{A}\\right]$. Using the definition of conditional expectation:\n$$\n\\bar{n}_{\\text{cond}} = \\frac{1}{2} \\mathbb{E}[N_A + N_B | \\mathcal{A}] = \\frac{1}{2} \\frac{\\mathbb{E}[(N_A + N_B)\\mathbb{I}(\\mathcal{A})]}{\\mathbb{P}(\\mathcal{A})}\n$$\nwhere $\\mathbb{I}(\\mathcal{A})$ is the indicator function for event $\\mathcal{A}$. The numerator can be simplified:\n$$\n\\mathbb{E}[(N_A + N_B)\\mathbb{I}(\\mathcal{A})] = \\mathbb{E}[N_A + N_B] - \\mathbb{E}[(N_A + N_B)\\mathbb{I}(\\mathcal{A}^c)]\n$$\nThe second term is zero because on the event $\\mathcal{A}^c$, we have $N_A=0$ and $N_B=0$, so $N_A+N_B=0$. The first term is the unconditional expectation:\n$$\n\\mathbb{E}[N_A + N_B] = \\mathbb{E}[N_A] + \\mathbb{E}[N_B] = m(t) + m(t) = 2m(t)\n$$\nTherefore, the numerator is $2m(t)$. Substituting this back into the expression for $\\bar{n}_{\\text{cond}}$:\n$$\n\\bar{n}_{\\text{cond}} = \\frac{1}{2} \\frac{2m(t)}{1 - p_0(t)^2} = \\frac{m(t)}{1 - p_0(t)^2}\n$$\n\n**Step 4: Asymptotic Naive Estimator**\n\nThe naive estimator for the duplication rate is given as $\\hat{\\lambda}_{\\text{naive}} = \\mu + \\frac{1}{t}\\ln(\\bar{n})$. In the large-sample limit, its expectation is found by substituting $\\bar{n}_{\\text{cond}}$ for $\\bar{n}$:\n$$\n\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] = \\mu + \\frac{1}{t} \\ln(\\bar{n}_{\\text{cond}}) = \\mu + \\frac{1}{t} \\ln\\left(\\frac{m(t)}{1 - p_0(t)^2}\\right)\n$$\n\n**Step 5: Asymptotic Bias**\n\nThe asymptotic bias is the difference between the expected value of the estimator and the true value $\\lambda$:\n$$\n\\text{Bias} = \\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] - \\lambda = \\mu - \\lambda + \\frac{1}{t} \\ln\\left(\\frac{m(t)}{1 - p_0(t)^2}\\right)\n$$\nSubstituting the expressions for $m(t)$ and $p_0(t)$:\n$$\n\\text{Bias} = \\mu - \\lambda + \\frac{1}{t} \\ln\\left( \\frac{\\exp((\\lambda - \\mu)t)}{1 - \\left(\\frac{\\mu(\\exp((\\lambda-\\mu)t)-1)}{\\lambda \\exp((\\lambda-\\mu)t)-\\mu}\\right)^2} \\right)\n$$\nThis is the required closed-form expression for the bias.\n\n**Step 6: Numerical Evaluation**\n\nWe are given $\\lambda = 0.1$, $\\mu = 0.3$, and $t = 10$. The units (per million years, million years) are consistent.\nFirst, we compute the exponent:\n$$\n(\\lambda - \\mu)t = (0.1 - 0.3) \\times 10 = -0.2 \\times 10 = -2\n$$\nNext, we compute $p_0(t)$:\n$$\np_0(10) = \\frac{0.3(\\exp(-2)-1)}{0.1\\exp(-2)-0.3}\n$$\nUsing $\\exp(-2) \\approx 0.13533528$:\n$$\np_0(10) \\approx \\frac{0.3(0.13533528 - 1)}{0.1(0.13533528) - 0.3} = \\frac{0.3(-0.86466472)}{0.013533528 - 0.3} = \\frac{-0.259399416}{-0.286466472} \\approx 0.9055113\n$$\nNow we compute the bias. It is simpler to rewrite the bias formula first:\n$$\n\\text{Bias} = \\mu - \\lambda + \\frac{1}{t} \\left[ \\ln(m(t)) - \\ln(1 - p_0(t)^2) \\right]\n$$\n$$\n\\text{Bias} = \\mu - \\lambda + \\frac{1}{t} \\left[ (\\lambda-\\mu)t - \\ln(1 - p_0(t)^2) \\right]\n$$\n$$\n\\text{Bias} = \\mu - \\lambda + (\\lambda - \\mu) - \\frac{1}{t}\\ln(1-p_0(t)^2) = -\\frac{1}{t}\\ln(1-p_0(t)^2)\n$$\nNow we substitute the numerical values:\n$$\np_0(10)^2 \\approx (0.9055113)^2 \\approx 0.8200508\n$$\n$$\n1 - p_0(10)^2 \\approx 1 - 0.8200508 = 0.1799492\n$$\n$$\n\\ln(1 - p_0(10)^2) \\approx \\ln(0.1799492) \\approx -1.715058\n$$\nFinally, we calculate the bias:\n$$\n\\text{Bias} \\approx -\\frac{1}{10} (-1.715058) = 0.1715058\n$$\nRounding to four significant figures, the bias is $0.1715$.", "answer": "$$\\boxed{0.1715}$$", "id": "2694480"}, {"introduction": "The analytical solutions to birth-death models provide deep insights, but many realistic evolutionary scenarios are too complex to solve with pen and paper. This is where computational simulation becomes an indispensable tool. This final practice challenges you to build an exact event-driven simulator for gene family evolution on a phylogenetic tree, translating the core tenets of the continuous-time Markov process into code [@problem_id:2694477]. Mastering this skill allows you to generate your own data, test the assumptions of analytical models, and explore the full range of dynamic behaviors that gene families can exhibit.", "problem": "You are asked to design and implement an exact event-driven simulation of a linear birth–death process for gene copy counts along a rooted bifurcating tree. Each gene copy duplicates independently at a constant per-copy duplication rate $\\lambda \\ge 0$ and is lost independently at a constant per-copy loss rate $\\mu \\ge 0$. The process on the nonnegative integers is a continuous-time Markov chain (CTMC), where if the current copy count is $n \\in \\{0,1,2,\\dots\\}$ then the total event rate is $n(\\lambda + \\mu)$, and the next event is a duplication with probability $\\lambda/(\\lambda+\\mu)$ or a loss with probability $\\mu/(\\lambda+\\mu)$. When $n=0$, the process is absorbed. At a speciation node, the current copy count is passed identically to both descendant branches, and from that point forward the two descendant lineages evolve independently given the node count. Use the memoryless property of the exponential waiting time and the Markov property of the CTMC to justify why, conditioned on the copy count at a node, the descendant branches can be simulated independently and why the node copy count is a sufficient state variable.\n\nYour program must implement the following, starting from first principles as stated above:\n- A function that simulates the CTMC on a single branch of length $t \\ge 0$, starting from an integer initial count $n_0 \\ge 0$, using exact exponential waiting times with rate $n(\\lambda+\\mu)$ and event outcomes chosen with probabilities $\\lambda/(\\lambda+\\mu)$ and $\\mu/(\\lambda+\\mu)$, respectively. If $t=0$ or $n_0=0$, the branch terminates immediately with no events.\n- A recursion that extends this branch simulation to a rooted bifurcating tree: simulate along a root stem of length $t_{\\mathrm{stem}}$, then at each speciation node pass the realized count identically to both children, simulate each child branch independently, and continue until reaching tips. The tip outputs must be the realized copy counts at the terminal times. To ensure reproducibility, use a fixed pseudorandom number generator seed equal to $2025$.\n- A deterministic left-to-right aggregation of tip counts for output, where “left-to-right” means the preorder traversal that visits the left child before the right child at every bifurcation.\n\nYour implementation must be general, but you must demonstrate it on the following test suite of three trees and parameter sets. In each case, report the list of integers of tip counts in left-to-right order as one result for that case.\n\nTest case $1$ (single bifurcation with a zero-length branch):\n- Parameters: $\\lambda=0.6$, $\\mu=0.2$, $n_0=1$.\n- Tree: root stem length $t_{\\mathrm{stem}}=0.5$; then a bifurcation into two tips with branch lengths $0.0$ (left) and $0.7$ (right).\n\nTest case $2$ (unbalanced tree with two bifurcations and loss-dominated dynamics):\n- Parameters: $\\lambda=0.3$, $\\mu=0.7$, $n_0=2$.\n- Tree: root stem length $t_{\\mathrm{stem}}=1.0$; then a bifurcation with left child a tip at branch length $0.4$, and right child an internal node at branch length $0.3$; this internal node bifurcates to two tips with branch lengths $0.5$ (left) and $0.2$ (right).\n\nTest case $3$ (pure-birth Yule dynamics on an unbalanced tree):\n- Parameters: $\\lambda=1.2$, $\\mu=0.0$, $n_0=1$.\n- Tree: root stem length $t_{\\mathrm{stem}}=0.0$; then a bifurcation with left child a tip at branch length $0.4$, and right child an internal node at branch length $0.1$; this internal node bifurcates to two tips with branch lengths $0.2$ (left) and $0.3$ (right).\n\nYour program must be self-contained (no input) and use the fixed random seed $2025$. The required final output is a single line containing a list of the three case results, each itself a list of integers of tip counts in left-to-right order. The format must be a single line, with no spaces, as a string representation of a list of lists, for example: [[a,b],[c,d,e],[f,g,h]]. No physical units are required in the output. The answers for each test case must be lists of integers, and the aggregate output must be a single list containing those three lists in order $1$ through $3$.", "solution": "We begin from the definition of the linear birth–death process on gene copy counts as a continuous-time Markov chain (CTMC) on the state space $\\{0,1,2,\\dots\\}$. If $N(t)$ denotes the number of copies at time $t$, then for $n \\ge 1$ the transition rates are $q_{n,n+1}=n\\lambda$, $q_{n,n-1}=n\\mu$, and $q_{n,n}=-n(\\lambda+\\mu)$, with $q_{0,0}=0$ indicating absorption at zero. Two fundamental properties underlie an exact simulation:\n\n$1.$ Exponential waiting times are memoryless. When the process is in state $n \\ge 1$, the waiting time $\\Delta$ to the next event has the exponential distribution with rate $n(\\lambda+\\mu)$, so $\\Pr(\\Delta  s+t \\mid \\Delta  s)=\\Pr(\\Deltat)$ for $s,t \\ge 0$.\n\n$2.$ Given that an event occurs at the next jump, the type of event is determined independently with probabilities proportional to the rates: duplication with probability $\\lambda/(\\lambda+\\mu)$ and loss with probability $\\mu/(\\lambda+\\mu)$. This follows from the thinning property of competing Poisson processes: the $n$ copies each have two independent exponential clocks of rates $\\lambda$ and $\\mu$ per copy, and the union of all $2n$ clocks yields the total rate $n(\\lambda+\\mu)$; the event type is then chosen by relative rates.\n\nEvent-driven simulation on a single branch of finite length $t \\ge 0$ thus proceeds by iterating the following steps, starting from $N(0)=n_0$: sample an exponential waiting time with rate $N(\\cdot)(\\lambda+\\mu)$; if the waiting time would exceed the remaining branch time, stop and return the current count; otherwise, advance time to the jump and update the count by $+1$ with probability $\\lambda/(\\lambda+\\mu)$ or $-1$ with probability $\\mu/(\\lambda+\\mu)$. If the count hits $0$, the process is absorbed and no further events occur.\n\nTo extend to a bifurcating tree, consider a rooted tree with a root stem of length $t_{\\mathrm{stem}}$ followed by bifurcations. The extension relies on two principles:\n\n$1.$ Markov sufficiency at nodes. For a node occurring at time $s$, the future evolution on the tree below that node depends on the past history only through the state $N(s)$. Formally, for any $u \\ge 0$, the Markov property of the CTMC implies $\\Pr(N(s+u)=k \\mid \\mathcal{F}_s)=\\Pr(N(s+u)=k \\mid N(s))$, where $\\mathcal{F}_s$ is the $\\sigma$-algebra generated by the process up to time $s$. Therefore, the node’s copy count is a sufficient statistic for continuation.\n\n$2.$ Conditional independence of descendant lineages. At a bifurcation time $s$, the set of exponential clocks governing events on the left descendant branch is independent of the set governing the right descendant branch, because they correspond to disjoint sets of copies and disjoint future time intervals. Given $N(s)=n$, the initial state on each descendant branch is $n$, and the two descendant processes are driven by independent Poisson clocks constructed for each branch. Hence, for any measurable functions $f$ and $g$ of the left and right descendant paths, respectively, $\\mathbb{E}[f \\cdot g \\mid N(s)=n]=\\mathbb{E}[f \\mid N(s)=n] \\cdot \\mathbb{E}[g \\mid N(s)=n]$. This validates simulating each branch independently conditioned on the node count and passing the node count identically to both children at the time of speciation.\n\nAlgorithmic design:\n\n$1.$ Single-branch simulator. Given $(n_0, t, \\lambda, \\mu)$, initialize elapsed time $\\tau=0$ and $n=n_0$. If $t=0$ or $n=0$, return $n$. Otherwise, at each step compute the total rate $r=n(\\lambda+\\mu)$, sample $\\delta \\sim \\mathrm{Exponential}(r)$. If $\\tau+\\delta \\ge t$, stop and return $n$. Else set $\\tau \\leftarrow \\tau+\\delta$. Sample a uniform variate $U \\sim \\mathrm{Uniform}(0,1)$; if $U  \\lambda/(\\lambda+\\mu)$, set $n \\leftarrow n+1$; otherwise set $n \\leftarrow n-1$. If $n=0$, stop and return $0$. Repeat.\n\n$2.$ Tree recursion. Given a rooted bifurcating tree specification with a root stem of length $t_{\\mathrm{stem}}$ and, at each internal node, left and right child edges with their branch lengths, proceed as follows. First simulate the single-branch process along the root stem for time $t_{\\mathrm{stem}}$ starting from $n_0$; call the resulting count $n_{\\mathrm{root}}$. At any internal node with incoming count $n_{\\mathrm{in}}$, simulate independently along the left-edge branch length to get a left count at the child endpoint; if the child is a tip, record that count; if the child is itself an internal node, pass the count to both of its children and recurse. Do the analogous simulation for the right child. The preorder traversal that visits the left child before the right child at each bifurcation defines a deterministic left-to-right order of tip counts to report.\n\n$3.$ Randomness and reproducibility. All exponential and uniform random variates are generated by a pseudorandom number generator initialized with seed $2025$. This ensures identical outputs across runs.\n\nCorrectness justification:\n\n- The single-branch simulator implements the exact jump times of the CTMC because exponential waiting times with rate $n(\\lambda+\\mu)$ are sampled at each state $n$, and event types are chosen according to their instantaneous probabilities $\\lambda/(\\lambda+\\mu)$ and $\\mu/(\\lambda+\\mu)$.\n- The Markov sufficiency at nodes follows from the CTMC Markov property: the conditional distribution of future states given the present state does not depend on the past. Thus, the node copy count is sufficient to restart the process on descendant branches.\n- Conditional independence of descendant lineages follows because, given $N(s)=n$, the two descendant processes are driven by independent sets of exponential clocks over disjoint temporal domains and disjoint sets of copies; by construction, their future evolutions are independent conditional on the node state.\n\nEdge cases in the test suite:\n\n- Test case $1$ includes a zero-length branch ($t=0.0$); the simulator must immediately return the incoming node count for that tip.\n- Test case $2$ is loss-dominated ($\\mu\\lambda$), making extinction likely; the simulator must correctly handle absorption at $0$ and propagate zeros to descendant branches when applicable.\n- Test case $3$ is pure birth ($\\mu=0.0$), exercising the case where only duplications occur.\n\nOutput specification:\n\n- For each test case, the result is a list of integers equal to the realized tip copy counts in left-to-right order.\n- The program must print a single line containing a list of the three case results in order $1,2,3$, with no spaces, formatted as [[a,b],[c,d,e],[f,g,h]].\n\nBecause the same fixed seed $2025$ is used and the simulation is exact, the program’s output is deterministic and reproducible for the specified parameters and trees.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_branch(n0, t, lam, mu, rng):\n    \"\"\"\n    Exact event-driven simulation of a linear birth-death process on a single branch.\n\n    Parameters:\n        n0 (int): initial copy count at branch start.\n        t (float): branch length (time).\n        lam (float): per-copy duplication rate.\n        mu (float): per-copy loss rate.\n        rng (np.random.Generator): random number generator.\n\n    Returns:\n        int: copy count at the end of the branch.\n    \"\"\"\n    n = int(n0)\n    if t = 0.0 or n == 0:\n        return n\n    total_rate_per_copy = lam + mu\n    # If total_rate_per_copy == 0, no events can occur; return current n.\n    if total_rate_per_copy == 0.0:\n        return n\n    elapsed = 0.0\n    while n > 0:\n        rate = n * total_rate_per_copy\n        # Sample exponential waiting time with mean 1/rate\n        dt = rng.exponential(1.0 / rate)\n        if elapsed + dt >= t:\n            break\n        elapsed += dt\n        # Decide event type\n        if rng.random()  (lam / total_rate_per_copy):\n            n += 1  # duplication\n        else:\n            n -= 1  # loss\n    return n\n\ndef simulate_tree(tree, n0, lam, mu, rng):\n    \"\"\"\n    Simulate the birth-death process on a bifurcating rooted tree.\n    Tree representation:\n        {\n          'stem_length': float,\n          'left': {'branch_length': float, 'node': internal_or_none},\n          'right': {'branch_length': float, 'node': internal_or_none}\n        }\n    Internal node representation (no stem_length):\n        {\n          'left': {'branch_length': float, 'node': internal_or_none},\n          'right': {'branch_length': float, 'node': internal_or_none}\n        }\n    Tips are represented by {'branch_length': ..., 'node': None}.\n\n    Returns:\n        list[int]: tip counts in left-to-right preorder traversal.\n    \"\"\"\n    # Simulate along the stem to get the count at the root bifurcation\n    n_at_root = simulate_branch(n0, tree['stem_length'], lam, mu, rng)\n\n    tip_counts = []\n\n    def recurse(n_in, internal_node):\n        # Simulate left child\n        left = internal_node['left']\n        n_left_end = simulate_branch(n_in, left['branch_length'], lam, mu, rng)\n        if left['node'] is None:\n            tip_counts.append(n_left_end)\n        else:\n            recurse(n_left_end, left['node'])\n        # Simulate right child\n        right = internal_node['right']\n        n_right_end = simulate_branch(n_in, right['branch_length'], lam, mu, rng)\n        if right['node'] is None:\n            tip_counts.append(n_right_end)\n        else:\n            recurse(n_right_end, right['node'])\n\n    root_internal = {'left': tree['left'], 'right': tree['right']}\n    recurse(n_at_root, root_internal)\n    return tip_counts\n\ndef format_no_space_nested_list(nested):\n    \"\"\"\n    Format a (possibly nested) list into a string with no spaces.\n    \"\"\"\n    if isinstance(nested, list):\n        return \"[\" + \",\".join(format_no_space_nested_list(x) for x in nested) + \"]\"\n    else:\n        return str(nested)\n\ndef build_test_cases():\n    # Test case 1\n    case1_tree = {\n        'stem_length': 0.5,\n        'left':  {'branch_length': 0.0, 'node': None},\n        'right': {'branch_length': 0.7, 'node': None},\n    }\n    case1 = {\n        'lam': 0.6,\n        'mu': 0.2,\n        'n0': 1,\n        'tree': case1_tree\n    }\n\n    # Test case 2\n    # Root -> left tip (0.4), right internal (0.3) -> two tips (0.5, 0.2)\n    case2_internal = {\n        'left':  {'branch_length': 0.5, 'node': None},\n        'right': {'branch_length': 0.2, 'node': None}\n    }\n    case2_tree = {\n        'stem_length': 1.0,\n        'left':  {'branch_length': 0.4, 'node': None},\n        'right': {'branch_length': 0.3, 'node': case2_internal},\n    }\n    case2 = {\n        'lam': 0.3,\n        'mu': 0.7,\n        'n0': 2,\n        'tree': case2_tree\n    }\n\n    # Test case 3\n    # Root -> left tip (0.4), right internal (0.1) -> two tips (0.2, 0.3)\n    case3_internal = {\n        'left':  {'branch_length': 0.2, 'node': None},\n        'right': {'branch_length': 0.3, 'node': None}\n    }\n    case3_tree = {\n        'stem_length': 0.0,\n        'left':  {'branch_length': 0.4, 'node': None},\n        'right': {'branch_length': 0.1, 'node': case3_internal},\n    }\n    case3 = {\n        'lam': 1.2,\n        'mu': 0.0,\n        'n0': 1,\n        'tree': case3_tree\n    }\n\n    return [case1, case2, case3]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    # Fixed seed for reproducibility\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for case in test_cases:\n        lam = case['lam']\n        mu = case['mu']\n        n0 = case['n0']\n        tree = case['tree']\n        tip_counts = simulate_tree(tree, n0, lam, mu, rng)\n        results.append(tip_counts)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_no_space_nested_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "answer": "[[2,1],[1,0,0],[2,1,3]]", "id": "2694477"}]}