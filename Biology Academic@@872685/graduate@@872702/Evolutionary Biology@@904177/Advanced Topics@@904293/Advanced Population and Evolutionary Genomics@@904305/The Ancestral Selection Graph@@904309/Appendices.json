{"hands_on_practices": [{"introduction": "The Ancestral Selection Graph (ASG) provides a powerful backward-in-time perspective on evolution, but its structure is fundamentally derived from the forward-in-time process of selection. This exercise provides direct practice in making this connection [@problem_id:2756036]. By decomposing the drift term of the Wright–Fisher diffusion, you will derive the rates of different types of selection-induced branching events, building a key intuition for how dominance and genic selection manifest in the ancestral process.", "problem": "Consider a large, randomly mating diploid population evolving according to the Wright–Fisher model with two alleles $A$ and $a$. Relative viabilities are given by $w_{AA} = 1 + \\sigma$, $w_{Aa} = 1 + h \\sigma$, and $w_{aa} = 1$, where $0 \\leq h \\leq \\tfrac{1}{2}$ (no overdominance) and $\\sigma$ is a weak selection coefficient on the diffusion time scale. Let $X_{t}$ denote the frequency of allele $A$ at time $t$. Under weak selection scaling, the diffusion generator for $X_{t}$ has drift term $m(x) = \\sigma x(1-x)\\big[h + (1-2h)x\\big]$ and variance term $\\tfrac{1}{2}x(1-x)$.\n\nThe ancestral selection graph (ASG) for this model is a backward-in-time branching–coalescing structure on ancestral gamete lines. In the untyped backward graph, selection manifests as branching events that add potential ancestral lines. Assume the standard dual construction in which each polynomial component $x^{r}(1-x)$ of the drift corresponds to a backward event that samples $r$ extant ancestral gamete lines and proposes $r$ additional potential ancestral lines, occurring at a rate equal to the coefficient of that polynomial per unordered $r$-tuple of lines.\n\nStarting from the diffusion drift $m(x)$, and using only the foundational dual interpretation described above, derive the total instantaneous rate at which selection-induced branching events occur in the diploid ASG when there are $k$ ancestral gamete lines. Express your answer as a closed-form expression in terms of $h$, $\\sigma$, and $k$. No numerical approximation is required, and no units are needed. Your final answer must be a single analytic expression.", "solution": "The problem is valid. It is scientifically grounded in the established theory of population genetics, specifically concerning the Wright–Fisher model, diffusion approximations, and the dual ancestral selection graph (ASG). The problem is well-posed, objective, and contains all necessary information for a unique solution to be derived through rigorous mathematical reasoning. The terminology and parameters are standard in the field.\n\nThe objective is to derive the total instantaneous rate of selection-induced branching events in a diploid ancestral selection graph with $k$ extant ancestral gamete lines. The derivation must proceed from the provided drift term of the governing diffusion process, according to the specified duality principle.\n\nThe forward-in-time evolution of the frequency $X_t$ of allele $A$ is described by a diffusion process with drift coefficient $m(x)$ and variance term $\\frac{1}{2}x(1-x)$. The drift term, which captures the effect of natural selection, is given as:\n$$m(x) = \\sigma x(1-x)\\big[h + (1-2h)x\\big]$$\nwhere $\\sigma$ is the selection coefficient and $h$ is the dominance parameter.\n\nThe problem states the foundational principle of duality between the forward diffusion and the backward-in-time ASG: a polynomial component of the form $c_r x^r(1-x)$ in the drift term $m(x)$ corresponds to a backward-in-time event where $r$ ancestral lines are sampled, and this event occurs at a rate $c_r$ for each unordered $r$-tuple of lines. To find the total rate of branching, we must first decompose the drift polynomial $m(x)$ into the basis of polynomials $\\{x^r(1-x)\\}_{r \\in \\mathbb{N}}$.\n\nExpanding the expression for $m(x)$:\n$$m(x) = \\sigma \\big( hx(1-x) + (1-2h)x^2(1-x) \\big)$$\nThis decomposition reveals two distinct polynomial components:\n$$m(x) = h\\sigma \\cdot x(1-x) + (1-2h)\\sigma \\cdot x^2(1-x)$$\n\nWe analyze each component separately to determine the corresponding event type and its rate in the ASG with $k$ ancestral lines.\n\n1.  The first component is $h\\sigma \\cdot x(1-x)$. This corresponds to the case where $r=1$. The coefficient is $c_1 = h\\sigma$. According to the duality principle, this gives rise to events where a single ancestral line is chosen ($r=1$). The rate of such an event is $c_1$ per unordered $1$-tuple of lines. The number of ways to choose an unordered $1$-tuple of lines from a set of $k$ lines is $\\binom{k}{1} = k$.\n    Therefore, the total rate of these \"unary\" branching events, $R_1(k)$, is:\n    $$R_1(k) = c_1 \\binom{k}{1} = h\\sigma k$$\n\n2.  The second component is $(1-2h)\\sigma \\cdot x^2(1-x)$. This corresponds to the case where $r=2$. The coefficient is $c_2 = (1-2h)\\sigma$. This gives rise to events where a pair of ancestral lines is chosen ($r=2$). The rate of such an event is $c_2$ per unordered $2$-tuple of lines. The number of ways to choose an unordered $2$-tuple of lines from a set of $k$ lines is $\\binom{k}{2} = \\frac{k(k-1)}{2}$.\n    Therefore, the total rate of these \"binary\" branching events, $R_2(k)$, is:\n    $$R_2(k) = c_2 \\binom{k}{2} = (1-2h)\\sigma \\frac{k(k-1)}{2}$$\n    The problem asks for the total instantaneous rate of selection-induced branching. This is the sum of the rates of all types of branching events derived from the drift term. Let this total rate be $R(k)$.\n    $$R(k) = R_1(k) + R_2(k)$$\n    $$R(k) = h\\sigma k + (1-2h)\\sigma \\frac{k(k-1)}{2}$$\n\nTo obtain a simplified closed-form expression, we combine the terms:\n$$R(k) = \\sigma \\left( hk + (1-2h)\\frac{k^2-k}{2} \\right)$$\n$$R(k) = \\frac{\\sigma}{2} \\left( 2hk + (1-2h)(k^2-k) \\right)$$\n$$R(k) = \\frac{\\sigma}{2} \\left( 2hk + k^2 - k - 2hk^2 + 2hk \\right)$$\nCollecting terms by powers of $k$:\n$$R(k) = \\frac{\\sigma}{2} \\left( (1-2h)k^2 + (4h-1)k \\right)$$\n\nThis expression represents the total rate at which branching events, driven by selection, occur in the ancestral selection graph when there are $k$ coexisting ancestral lineages. It correctly incorporates the rates from both genic selection effects (proportional to $k$) and dominance effects (proportional to $k^2$).", "answer": "$$\\boxed{\\frac{\\sigma}{2} \\left( (1-2h)k^2 + (4h-1)k \\right)}$$", "id": "2756036"}, {"introduction": "The basic ASG describes the ancestry at a single selected locus, but real genomes are mosaics of linked sites with different histories. This practice explores how to extend the model to include recombination, leading to the Ancestral Recombination-Selection Graph (ARSG) [@problem_id:2756063]. Starting from the definition of recombination in meiosis, you will derive its rate in the backward-in-time process, revealing how recombination acts to split ancestral lineages and decouple the genealogies of linked loci.", "problem": "Consider a panmictic diploid Wright–Fisher population of constant census size $N$, evolving at two linked loci: a biallelic selected locus $\\mathcal{S}$ with genic selection coefficient $s$ and a biallelic neutral locus $\\mathcal{L}$. The recombination fraction between $\\mathcal{S}$ and $\\mathcal{L}$ per generation (per meiosis) is $r$, where $0<r<\\tfrac{1}{2}$. Time will be measured in coalescent units of $2N$ generations. Work in the standard diffusion limit where $N \\to \\infty$, $s \\to 0$, and $r \\to 0$ with $Ns$ and $Nr$ finite. The ancestral process is represented by the Ancestral Recombination–Selection Graph (ARSG), which combines the branching structure induced by selection when run backward in time with the splitting of ancestral material induced by recombination.\n\nStarting from the Wright–Fisher reproduction mechanism and the definition of recombination in meiosis, derive from first principles the instantaneous rate (hazard) at which a single ancestral lineage that simultaneously carries ancestral material for both loci $\\mathcal{S}$ and $\\mathcal{L}$ splits into two lineages due to recombination when the process is run backward in time and time is scaled in coalescent units. Your derivation must explicitly justify the transition from discrete generations to continuous time under the diffusion scaling, and it must not assume any pre-existing coalescent-with-recombination rate formulas. State your final rate in terms of $N$ and $r$.\n\nIn addition, briefly explain, using the ARSG construction, how recombination events interact with selection-induced branching events to shape the mosaic of local genealogies along the chromosome. The explanation does not contribute to the numerical value, which must be given as a single closed-form analytic expression. Provide the final expression for the recombination-induced split rate per lineage in coalescent time units. No rounding is required, and no units should be included in the final expression.", "solution": "The problem asks for the derivation of the instantaneous rate at which a single ancestral lineage, carrying genetic material for two linked loci $\\mathcal{S}$ and $\\mathcal{L}$, splits into two separate lineages due to recombination. The derivation must be from first principles within the Wright-Fisher model, and the rate must be expressed in coalescent time units.\n\nFirst, we validate the problem statement.\nThe problem is set within the standard framework of theoretical population genetics, utilizing the diploid Wright-Fisher model, coalescent theory, and the Ancestral Recombination-Selection Graph (ARSG). All parameters ($N$, $s$, $r$) and concepts (panmixia, genic selection, recombination, diffusion limit, coalescent time) are well-defined and standard in the field. The question is specific, objective, and scientifically grounded. It asks for a mathematical derivation within a formal model, which is a well-posed problem. There are no contradictions, ambiguities, or factual inaccuracies. The problem is therefore deemed **valid**.\n\nWe now proceed with the derivation from first principles.\n\nLet us consider the process running backward in time, generation by generation. We are tracking a single ancestral lineage at generation $t$, which represents a segment of a chromosome containing both the selected locus $\\mathcal{S}$ and the neutral locus $\\mathcal{L}$. This chromosomal segment was inherited from a single parent in generation $t-1$.\n\nThe parent, being a diploid organism, has two homologous chromosomes. The gamete that transmitted the ancestral segment to the offspring at generation $t$ was produced by meiosis in this parent. The recombination fraction, $r$, is defined as the probability that a gamete produced during meiosis is of a recombinant type with respect to the two loci in question. That is, for a given meiosis, a gamete will carry a chromosome with genetic material from both of the parent's homologous chromosomes at the loci $\\mathcal{S}$ and $\\mathcal{L}$ with probability $r$.\n\nWhen we trace the lineage backward from generation $t$ to $t-1$, we are essentially tracing the origin of the gamete from which it was formed.\nThere are two possibilities for the ancestral material at loci $\\mathcal{S}$ and $\\mathcal{L}$:\n1.  **No recombination:** With probability $1-r$, the gamete was non-recombinant. In this case, the entire segment containing both $\\mathcal{S}$ and $\\mathcal{L}$ was inherited from a single one of the parent's two homologous chromosomes. Looking backward, the single ancestral lineage at $t$ continues as a single ancestral lineage at $t-1$.\n2.  **Recombination:** With probability $r$, the gamete was recombinant. This means a crossover event occurred between loci $\\mathcal{S}$ and $\\mathcal{L}$ during meiosis. As a result, the allele at locus $\\mathcal{S}$ on the gamete's chromosome came from one of the parent's homologous chromosomes, while the allele at locus $\\mathcal{L}$ came from the other. Looking backward, our single lineage at time $t$ has two distinct parental sources at time $t-1$: one for the $\\mathcal{S}$ locus and one for the $\\mathcal{L}$ locus. Thus, the lineage splits into two.\n\nTherefore, the probability that a single lineage, carrying both loci, splits due to recombination in a single backward generation step is precisely $r$. Let's call this probability $P_{\\text{split, gen}} = r$.\n\nThe problem requires the instantaneous rate in continuous time, measured in coalescent units. The transition from a discrete-generation process to a continuous-time process is achieved through the specified diffusion limit, where $N \\to \\infty$ and $r \\to 0$ such that the product $Nr$ remains finite.\n\nIn this limit, the probability of a split in any single generation, $r$, is very small. The process of lineage splitting can be modeled as a Poisson process. Let $R_{\\text{split}}$ be the instantaneous rate of splitting in coalescent time units. One unit of coalescent time corresponds to $2N$ generations in a diploid population of size $N$.\n\nTo find the continuous-time rate, we consider the probability of an event in a small interval of time. Let $\\Delta \\tau$ be a small interval of continuous coalescent time. This corresponds to $\\Delta t = (2N)\\Delta \\tau$ generations. Since $r$ is small, the probability of more than one split event in this short interval is negligible (of order $r^2$ or smaller), and the probability of at least one split is approximately the number of generations multiplied by the per-generation probability:\n$$ P(\\text{split in } \\Delta \\tau) \\approx \\Delta t \\times P_{\\text{split, gen}} = (2N \\Delta \\tau) \\times r $$\nThe instantaneous rate $R_{\\text{split}}$ is defined as the limit of the probability of an event per unit time as the time interval approaches zero:\n$$ R_{\\text{split}} = \\lim_{\\Delta \\tau \\to 0} \\frac{P(\\text{split in } \\Delta \\tau)}{\\Delta \\tau} $$\nSubstituting our expression for the probability:\n$$ R_{\\text{split}} = \\lim_{\\Delta \\tau \\to 0} \\frac{(2N \\Delta \\tau) r}{\\Delta \\tau} = 2Nr $$\nThis derivation is formally justified by the convergence of a Binomial process to a Poisson process. The number of splits for a lineage over $\\tau$ coalescent units (i.e., $t=2N\\tau$ generations) follows a Binomial distribution $B(t,r)$. As $N \\to \\infty$ with $r = \\frac{R_{\\text{split}}}{2N}$, the number of generations $t = 2N\\tau \\to \\infty$ and the probability $r \\to 0$. The expected number of events is $t \\times r = (2N\\tau) \\times \\frac{R_{\\text{split}}}{2N} = R_{\\text{split}}\\tau$. A sequence of Binomial distributions $B(n, p_n)$ with $n \\to \\infty$, $p_n \\to 0$, and $np_n \\to \\lambda$ converges to a Poisson distribution with mean $\\lambda$. In our case, this means the number of splits in a time interval $\\tau$ is Poisson distributed with mean $R_{\\text{split}}\\tau$. This corresponds to a Poisson process with constant rate $R_{\\text{split}} = 2Nr$. The diffusion scaling, which keeps $Nr$ finite, ensures this rate is a well-defined, finite constant.\n\nFinally, we briefly explain the interaction of recombination and selection in the ARSG.\nThe Ancestral Recombination-Selection Graph (ARSG) is a structure that describes the full ancestry of a sample, including coalescence, mutation, recombination, and selection-induced branching events.\n- **Recombination events** (occurring at rate $2Nr$ per lineage for the loci in question) cause ancestral lineages to split. This allows different segments of a chromosome to have different genealogical histories. So, the genealogy at locus $\\mathcal{L}$ can become decoupled from the genealogy at locus $\\mathcal{S}$.\n- **Selection-induced branching events** (for a beneficial allele, occurring at a rate proportional to the selection coefficient, $2Ns$) cause lineages carrying the selected allele to branch into multiple descendant lineages when viewed backward in time. This leads to a rapid coalescence of lineages carrying the beneficial allele, a phenomenon known as a selective sweep, which drastically reduces the time to the most recent common ancestor (TMRCA) around the selected locus.\n\nThe **interaction** between these two processes shapes the \"mosaic\" of local genealogies. Close to the selected locus $\\mathcal{S}$ (small $r$), recombination is infrequent relative to selection and coalescence. Thus, the genealogy at a nearby neutral locus $\\mathcal{L}$ is likely to be heavily influenced by the selective sweep at $\\mathcal{S}$, showing a similarly reduced TMRCA and lower genetic diversity. Farther from $\\mathcal{S}$ (larger $r$), recombination is more likely to have occurred in the history of the sample. A recombination event can move the ancestor of locus $\\mathcal{L}$ onto a different genetic background that is not under selection. This \"escaped\" lineage then evolves according to the standard neutral coalescent, unperturbed by the sweep at $\\mathcal{S}$. Consequently, the local genealogy at a distant locus $\\mathcal{L}$ will appear more like a neutral genealogy with a much older TMRCA. Recombination, therefore, breaks down the genetic \"hitchhiking\" effect, and the scale of this breakdown is determined by the ratio of the recombination rate to the selection strength.", "answer": "$$\n\\boxed{2Nr}\n$$", "id": "2756063"}, {"introduction": "The ASG itself represents a graph of *potential* ancestors, containing more lineages than the true genealogy. The final step in using the ASG is to \"prune\" this structure to recover the realized ancestral history. This practical coding exercise guides you through the implementation of a deterministic pruning algorithm [@problem_id:2756026], forcing you to translate the abstract rules of selection, mutation, and coalescence into a concrete computational procedure that constructs the final genealogical tree.", "problem": "You are given the task of formalizing and implementing a pruning algorithm for the Ancestral Selection Graph (ASG) in a two-type haploid model with selection. The ASG is a backward-in-time branching-coalescing process that encodes potential ancestors, where branching events correspond to selective reproduction. To obtain the realized genealogy of the sample, potential ancestors must be resolved into actual ancestors by assigning types along the graph and pruning non-ancestral branches.\n\nFundamental base:\n- A population consists of two types, encoded as $\\{0,1\\}$, where type $1$ is selectively favored over type $0$.\n- In the ASG, moving backward in time, lineages experience coalescence events (binary mergers) and branching events (splitting into two potential parents: a continuing line and an incoming line).\n- The realized ancestor at a branching event is determined by a deterministic rule based on types at the time of the event: if at least one potential parent is of the favored type $1$, then the favored type is ancestral; in the case of a tie, the continuing line is ancestral. If both are type $0$, the continuing line is ancestral.\n\nYour program must implement the following algorithmic problem.\n\nInputs and definitions to be used:\n- Sample size $n$ at backward time $t=0$ with labeled lineages $\\{0,1,\\dots,n-1\\}$ and initial types $\\tau_i \\in \\{0,1\\}$ for each $i \\in \\{0,\\dots,n-1\\}$.\n- An event list that is strictly ordered by non-decreasing backward time (real numbers), and if two events share the same time, they must be processed in the provided order. Each event is one of:\n  - Coalescence: $\\texttt{['coal', t, i, j, k]}$ meaning that at time $t$ the two active lineages with identifiers $i$ and $j$ coalesce into a single new lineage with identifier $k$.\n  - Branching: $\\texttt{['branch', t, child, c, inc, type\\_c, type\\_inc]}$ meaning that at time $t$ the active lineage with identifier $child$ is replaced by two potential parents: a continuing lineage with identifier $c$ and type $\\tau_c = \\texttt{type\\_c} \\in \\{0,1\\}$ and an incoming lineage with identifier $inc$ and type $\\tau_{inc} = \\texttt{type\\_inc} \\in \\{0,1\\}$. Immediately at this event time, the realized ancestor is chosen deterministically by the rule: the ancestor is $c$ if $\\tau_c \\ge \\tau_{inc}$, otherwise the ancestor is $inc$. The non-ancestral branch is pruned from the set of active lineages at that time.\n  - Mutation: $\\texttt{['mut', t, i, new\\_type]}$ meaning that at time $t$ the active lineage with identifier $i$ instantaneously changes its type to $\\texttt{new\\_type} \\in \\{0,1\\}$. Mutations affect future events but do not retroactively alter past resolutions already made.\n- The set of active lineages is updated event-by-event in increasing time. Coalescence always contributes two realized genealogy edges $(k \\to i)$ and $(k \\to j)$. A branching event contributes one realized edge $(\\text{chosen\\_parent} \\to child)$ and prunes the non-chosen parent immediately.\n\nYour tasks:\n1. Design and implement a pruning algorithm that, given $(n,\\{\\tau_i\\}_{i=0}^{n-1})$ and the event list, produces the realized genealogy as a list of directed edges represented as $[parent, child]$ integer pairs. The algorithm must process events in order, maintain the active lineage set and their current types, apply the deterministic ancestor rule at each branching, and record realized edges accordingly. Finally, return the list of realized edges sorted lexicographically by increasing child and then by increasing parent.\n2. Provide a complexity analysis of your algorithm in terms of $n$ (sample size) and $m$ (number of events). Your analysis should state the time and space complexity in Big-O notation as functions of $n$ and $m$.\n\nTest suite:\nImplement your program to run on the following four cases. For each case, the program must construct the realized genealogy and output the sorted edge list as specified.\n\n- Case A:\n  - Initial sample: $n = 3$, initial types $(\\tau_0,\\tau_1,\\tau_2) = (0,0,1)$.\n  - Events (in order):\n    - $\\texttt{['coal', 1.0, 0, 1, 3]}$.\n    - $\\texttt{['coal', 2.0, 2, 3, 4]}$.\n\n- Case B:\n  - Initial sample: $n = 1$, initial types $(\\tau_0) = (0)$.\n  - Events (in order):\n    - $\\texttt{['branch', 0.5, 0, 1, 2, 0, 1]}$.\n\n- Case C:\n  - Initial sample: $n = 1$, initial types $(\\tau_0) = (1)$.\n  - Events (in order):\n    - $\\texttt{['branch', 0.3, 0, 1, 2, 1, 1]}$.\n\n- Case D:\n  - Initial sample: $n = 2$, initial types $(\\tau_0,\\tau_1) = (0,1)$.\n  - Events (in order):\n    - $\\texttt{['branch', 0.2, 0, 2, 3, 0, 1]}$.\n    - $\\texttt{['branch', 0.4, 1, 4, 5, 1, 0]}$.\n    - $\\texttt{['mut', 0.5, 3, 0]}$.\n    - $\\texttt{['coal', 0.9, 3, 4, 6]}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results of the four cases as a comma-separated list enclosed in square brackets, where each case output is itself a list of realized edges, and each edge is a two-element list $[parent, child]$. The edges within each case must be sorted by increasing child and then by increasing parent. For example, an output with two cases would look like $\\texttt{[[[p\\_1,c\\_1],[p\\_2,c\\_2]],[[p\\_3,c\\_3]]]}$.\n\nAnswer types:\n- For each case, the result is a list of lists of integers. The overall output is a list of these lists.\n\nYour implementation must be fully deterministic and must not use any randomness. No physical units are involved. Angles are not involved. Percentages are not involved.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the theory of the Ancestral SelectionGraph (ASG), is well-posed with a clear, deterministic set of rules, and is entirely objective. All necessary information for a unique solution is provided. We may therefore proceed with the formal solution.\n\nThe task is to implement a pruning algorithm for an ASG to determine the realized genealogy of a sample. The algorithm must simulate the ASG's evolution backward in time, processing a sequence of discrete events—coalescence, branching, and mutation—and applying a deterministic rule to resolve selective branching events.\n\nAn algorithm to achieve this is designed as an event-driven simulation. The state of the system is maintained at each step and updated according to the event being processed. The core state variables are:\n$1$. The set of active lineages, denoted $A$. A lineage is \"active\" if it is a potential ancestor of the initial sample and has not yet coalesced or been pruned.\n$2$. A map of lineage types, denoted $\\tau$. This map stores the type, either $0$ or $1$, for each lineage for which a type has been defined. Type $1$ is selectively favored.\n$3$. A list of realized genealogical edges, denoted $E$. Each edge is a directed pair $[p, c]$ representing that lineage $p$ is the parent of lineage $c$.\n\nThe simulation proceeds as follows:\n\n**Step 1: Initialization**\nAt backward time $t=0$, the system is initialized based on the sample of size $n$.\n- The set of active lineages is initialized to the set of sampled individuals: $A = \\{0, 1, \\dots, n-1\\}$.\n- The lineage type map $\\tau$ is populated with the initial types of the sampled individuals: $\\tau[i] = \\tau_i$ for each $i \\in \\{0, 1, \\dots, n-1\\}$.\n- The list of edges $E$ is initialized as an empty list.\n\n**Step 2: Event Processing Loop**\nThe algorithm iterates through the ordered list of events. For each event, the state variables ($A$, $\\tau$, $E$) are updated according to the event type.\n\n- **Coalescence Event: `['coal', t, i, j, k]`**\n  At time $t$, two active lineages, $i$ and $j$, merge into a single ancestral lineage, $k$.\n  $1$. Lineages $i$ and $j$ cease to be active. They are removed from the set $A$: $A \\leftarrow A \\setminus \\{i, j\\}$.\n  $2$. The new ancestral lineage $k$ becomes active. It is added to the set $A$: $A \\leftarrow A \\cup \\{k\\}$.\n  $3$. Two edges representing this coalescence are added to the genealogy: $E \\leftarrow E \\cup \\{[k, i], [k, j]\\}$.\n  The problem statement does not require a type to be assigned to the new lineage $k$, as the provided test cases show that such lineages do not participate in subsequent type-dependent branching events as the \"child\" lineage.\n\n- **Branching Event: `['branch', t, child, c, inc, type_c, type_inc]`**\n  At time $t$, an active lineage `child` is found to descend from a selective event, creating two potential ancestors: a continuing lineage $c$ with type $\\tau_c = \\texttt{type\\_c}$ and an incoming lineage $inc$ with type $\\tau_{inc} = \\texttt{type\\_inc}$.\n  $1$. The lineage `child` is removed from the active set: $A \\leftarrow A \\setminus \\{\\text{child}\\}$.\n  $2$. The realized ancestor is determined by the deterministic rule: the ancestor is lineage $c$ if $\\tau_c \\ge \\tau_{inc}$, and lineage $inc$ otherwise.\n  $3$. Let the chosen lineage be $\\text{parent}_{\\text{chosen}}$ and its type be $\\tau_{\\text{chosen}}$.\n  $4$. An edge from the chosen parent to the child is added to the genealogy: $E \\leftarrow E \\cup \\{[\\text{parent}_{\\text{chosen}}, \\text{child}]\\}$.\n  $5$. The chosen parent becomes an active lineage: $A \\leftarrow A \\cup \\{\\text{parent}_{\\text{chosen}}\\}$.\n  $6$. The type of the newly active lineage is recorded for future events: $\\tau[\\text{parent}_{\\text{chosen}}] \\leftarrow \\tau_{\\text{chosen}}$. The non-ancestral branch is pruned and never enters the set of active lineages.\n\n- **Mutation Event: `['mut', t, i, new_type]`**\n  At time $t$, an active lineage $i$ undergoes a mutation, changing its type.\n  $1$. The type of lineage $i$ in the map $\\tau$ is updated to $\\texttt{new\\_type}$: $\\tau[i] \\leftarrow \\texttt{new\\_type}$.\n  This change affects the resolution of any subsequent branching events involving lineage $i$ or its descendants, but does not alter resolutions that have already occurred at earlier times.\n\n**Step 3: Finalization**\nAfter all events in the list have been processed, the list of edges $E$ represents the complete realized genealogy.\n- The list $E$ is sorted lexicographically. The primary sorting key is the child identifier (the second element of the pair), and the secondary key is the parent identifier (the first element).\n\n**Complexity Analysis**\nLet $n$ be the initial sample size and $m$ be the total number of events in the input list.\n\n- **Time Complexity:**\n  - Initialization: Populating the set of active lineages $A$ and the type map $\\tau$ takes $O(n)$ time.\n  - Event Processing: The simulation consists of a single loop over the $m$ events. For each event, the operations involve lookups, insertions, and deletions on hash-based data structures (a hash set for $A$ and a hash map for $\\tau$), which take average-case $O(1)$ time. Thus, processing all events takes $O(m)$ time.\n  - Finalization: The number of edges in $E$ is at most $2m$ (two for each coalescence, one for each branch). Sorting this list of edges takes $O(m \\log m)$ time.\n  - The total time complexity is dominated by the initial setup and the final sorting, yielding $O(n + m \\log m)$.\n\n- **Space Complexity:**\n  - The set of active lineages $A$ has a maximum size of $n$. Its space is $O(n)$.\n  - The type map $\\tau$ stores an entry for each distinct lineage identifier created. The number of such lineages is bounded by $n$ plus the new lineages from coalescence ($1$ per event) and branching ($2$ per event), resulting in a total of $O(n+m)$ lineages. The space for $\\tau$ is therefore $O(n+m)$.\n  - The edge list $E$ stores $O(m)$ edges. Its space is $O(m)$.\n  - The total space complexity is the sum of these components, which is $O(n+m)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # numpy is specified but not strictly necessary for this logic.\nimport json\n\ndef list_to_compact_string(obj):\n    \"\"\"\n    Serializes a list-based object into a compact string representation\n    without spaces, similar to json.dumps with separators.\n    \"\"\"\n    if isinstance(obj, list):\n        return '[' + ','.join(list_to_compact_string(item) for item in obj) + ']'\n    else:\n        return str(obj)\n\ndef solve_case(n, initial_types, events):\n    \"\"\"\n    Processes a single test case for ASG pruning.\n\n    Args:\n        n (int): The initial sample size.\n        initial_types (tuple or list): The types of the initial lineages.\n        events (list): A list of events ordered by time.\n\n    Returns:\n        list: The sorted list of realized genealogy edges.\n    \"\"\"\n    active_lineages = set(range(n))\n    lineage_types = {i: t for i, t in enumerate(initial_types)}\n    realized_edges = []\n\n    for event in events:\n        event_type = event[0]\n\n        if event_type == 'coal':\n            _, t, i, j, k = event\n            # Update active lineages\n            active_lineages.remove(i)\n            active_lineages.remove(j)\n            active_lineages.add(k)\n            # Add realized edges\n            realized_edges.append([k, i])\n            realized_edges.append([k, j])\n\n        elif event_type == 'branch':\n            _, t, child, c, inc, type_c, type_inc = event\n            # Remove child from active lineages\n            active_lineages.remove(child)\n\n            # Determine chosen parent based on the rule in the problem description\n            # The rule as described in the prompt is slightly different from standard ASG.\n            # \"the ancestor is c if τc ≥ τinc, otherwise the ancestor is inc\"\n            if type_c >= type_inc:\n                chosen_parent = c\n                chosen_type = type_c\n            else:\n                chosen_parent = inc\n                chosen_type = type_inc\n            \n            # Add realized edge\n            realized_edges.append([chosen_parent, child])\n            \n            # Add chosen parent to active lineages and record its type\n            active_lineages.add(chosen_parent)\n            lineage_types[chosen_parent] = chosen_type\n\n        elif event_type == 'mut':\n            _, t, i, new_type = event\n            # Update the type of the active lineage\n            if i in active_lineages:\n                lineage_types[i] = new_type\n\n    # Sort the realized edges: first by child, then by parent\n    realized_edges.sort(key=lambda edge: (edge[1], edge[0]))\n    \n    return realized_edges\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"n\": 3,\n            \"initial_types\": (0, 0, 1),\n            \"events\": [\n                ['coal', 1.0, 0, 1, 3],\n                ['coal', 2.0, 2, 3, 4],\n            ]\n        },\n        # Case B\n        {\n            \"n\": 1,\n            \"initial_types\": (0,),\n            \"events\": [\n                ['branch', 0.5, 0, 1, 2, 0, 1],\n            ]\n        },\n        # Case C\n        {\n            \"n\": 1,\n            \"initial_types\": (1,),\n            \"events\": [\n                ['branch', 0.3, 0, 1, 2, 1, 1],\n            ]\n        },\n        # Case D\n        {\n            \"n\": 2,\n            \"initial_types\": (0, 1),\n            \"events\": [\n                ['branch', 0.2, 0, 2, 3, 0, 1],\n                ['branch', 0.4, 1, 4, 5, 1, 0],\n                ['mut', 0.5, 3, 0],\n                ['coal', 0.9, 3, 4, 6],\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"n\"], case[\"initial_types\"], case[\"events\"])\n        results.append(result)\n\n    # Use a custom serializer to match the required output format (no spaces)\n    # The expected output is `[[[3,0],[3,1],[4,2],[4,3]],[[2,0]],[[1,0]],[[3,0],[4,1],[6,3],[6,4]]]`\n    final_output_string = list_to_compact_string(results)\n    print(final_output_string)\n\nsolve()\n\n```", "id": "2756026"}]}