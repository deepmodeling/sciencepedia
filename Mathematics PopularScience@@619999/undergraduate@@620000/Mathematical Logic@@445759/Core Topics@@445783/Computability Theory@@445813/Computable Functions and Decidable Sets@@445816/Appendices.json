{"hands_on_practices": [{"introduction": "The theory of computability begins not with complex machinery, but with a simple, elegant idea: building all computable functions from a minimal set of basic building blocks. This exercise takes you back to these first principles, challenging you to construct familiar arithmetic functions like addition and multiplication using only the foundational rules of primitive recursion. By engaging in this formal construction, you will gain a deeper appreciation for how computational complexity is built layer by layer from the ground up, solidifying your understanding of what makes a function \"computable\" in the first place. [@problem_id:3038773]", "problem": "Let $\\mathbb{N}$ denote the set of natural numbers. The class of primitive recursive (PR) functions on $\\mathbb{N}^{k}$ is generated from the initial functions by closure under composition and primitive recursion. The initial functions are the zero function $Z^{n}:\\mathbb{N}^{n}\\to\\mathbb{N}$ defined by $Z^{n}(\\vec{x})=0$, the successor function $S:\\mathbb{N}\\to\\mathbb{N}$ defined by $S(x)=x+1$, and the projection functions $U^{n}_{i}:\\mathbb{N}^{n}\\to\\mathbb{N}$ defined by $U^{n}_{i}(x_{1},\\dots,x_{n})=x_{i}$ for $1\\leq i\\leq n$. Composition takes $f$ and $g_{1},\\dots,g_{m}$ to $C(f,g_{1},\\dots,g_{m})(\\vec{x})=f(g_{1}(\\vec{x}),\\dots,g_{m}(\\vec{x}))$. Primitive recursion takes $g:\\mathbb{N}^{n}\\to\\mathbb{N}$ and $h:\\mathbb{N}^{n+2}\\to\\mathbb{N}$ to the unique $f:\\mathbb{N}^{n+1}\\to\\mathbb{N}$ satisfying\n$$\nf(0,\\vec{x})=g(\\vec{x}),\\quad f(S(y),\\vec{x})=h\\big(y,\\vec{x},f(y,\\vec{x})\\big).\n$$\nStarting only from these fundamental definitions, construct explicit primitive recursion schemes that witness the following three functions are PR:\n- Addition $A:\\mathbb{N}^{2}\\to\\mathbb{N}$, with $A(x,y)=x+y$.\n- Multiplication $M:\\mathbb{N}^{2}\\to\\mathbb{N}$, with $M(x,y)=x\\cdot y$.\n- Truncated subtraction $T:\\mathbb{N}^{2}\\to\\mathbb{N}$, with $T(x,y)=\\max(x-y,0)$.\n\nIn your construction, you may introduce and justify auxiliary PR functions you need (for example, a predecessor function). After completing the constructions, define the composite function\n$$\nF(x,y)\\;=\\;T\\Big(M\\big(x,\\,S(S(y))\\big),\\;A\\big(x,\\,T\\big(y,\\,S(x)\\big)\\big)\\Big),\n$$\nand compute the value $F(3,5)$. Give your final answer as a single real number. No rounding is required.", "solution": "The problem is valid as it is a standard exercise in computability theory, based on the well-defined and mathematically sound principles of primitive recursive functions. All terms are standard and the tasks are unambiguously stated.\n\nWe will construct the required functions explicitly from the initial functions (zero $Z^n$, successor $S$, and projections $U^n_i$) and the operations of composition and primitive recursion. We assume the set of natural numbers is $\\mathbb{N}=\\{0, 1, 2, \\dots\\}$, which is consistent with the base case $f(0,\\vec{x})$ in the definition of primitive recursion.\n\n1.  **Addition: $A(x,y) = x+y$**\n\n    We define addition by recursion on the first argument, $x$.\n    The function $A:\\mathbb{N}^2 \\to \\mathbb{N}$ satisfies the following two equations:\n    $$A(0,y) = y$$\n    $$A(S(x),y) = (x+1)+y = (x+y)+1 = S(A(x,y))$$\n    This is an instance of the primitive recursion scheme $f(0,\\vec{x}) = g(\\vec{x})$ and $f(S(y),\\vec{x}) = h(y, \\vec{x}, f(y,\\vec{x}))$. In our case, the recursion is on $x$, the parameter is $y$, and the function is $A(x,y)$.\n    The scheme for $A(x,y)$ is:\n    -   Base case: $A(0,y) = g(y)$. We have $A(0,y) = y$, so we can define $g:\\mathbb{N} \\to \\mathbb{N}$ as $g(y) = y$. This is the projection function $U^1_1(y)$. The function $U^1_1$ is an initial function and therefore primitive recursive (PR).\n    -   Recursive step: $A(S(x), y) = h(x,y,A(x,y))$. We have $A(S(x),y) = S(A(x,y))$. So we define $h:\\mathbb{N}^3 \\to \\mathbb{N}$ as $h(x,y,z) = S(z)$, where $z$ represents the value of $A(x,y)$. To express this formally, $h(x,y,z) = S(U^3_3(x,y,z))$. This function is a composition of the initial function $S$ and the initial function $U^3_3$, so it is PR.\n    Since both $g=U^1_1$ and $h=S \\circ U^3_3$ are PR, the function $A$ defined by primitive recursion from them is also PR.\n\n2.  **Multiplication: $M(x,y) = x \\cdot y$**\n\n    We define multiplication by recursion on $x$, using the previously established PR function for addition, $A$.\n    The function $M:\\mathbb{N}^2 \\to \\mathbb{N}$ satisfies:\n    $$M(0,y) = 0 \\cdot y = 0$$\n    $$M(S(x),y) = (x+1) \\cdot y = x \\cdot y + y = A(M(x,y), y)$$\n    This fits the primitive recursion scheme for $M(x,y)$:\n    -   Base case: $M(0,y) = g(y)$. We have $M(0,y)=0$. So we define $g:\\mathbb{N} \\to \\mathbb{N}$ as $g(y)=0$. This is the zero function $Z^1(y)$, which is an initial function and hence PR.\n    -   Recursive step: $M(S(x),y) = h(x,y,M(x,y))$. We have $M(S(x),y) = A(M(x,y), y)$. Let $z = M(x,y)$, then we require $h(x,y,z) = A(z,y)$. Formally, this is $h(x,y,z) = A(U^3_3(x,y,z), U^3_2(x,y,z))$. Since $A$ is PR and projection functions are initial, $h$ is obtained by composition from PR functions and is therefore PR.\n    Since both $g=Z^1$ and $h=A \\circ (U^3_3, U^3_2)$ are PR, the function $M$ defined by primitive recursion is also PR.\n\n3.  **Truncated Subtraction: $T(x,y) = \\max(x-y,0)$**\n\n    To define truncated subtraction, we first need an auxiliary function, the predecessor function $P(x) = \\max(x-1,0)$.\n    -   **Auxiliary function: Predecessor $P(x)$**\n        The function $P:\\mathbb{N} \\to \\mathbb{N}$ is defined by recursion on $x$:\n        $$P(0)=0$$\n        $$P(S(x)) = x$$\n        For a unary function, the primitive recursion scheme is $f(0)=c$ and $f(S(x))=h(x,f(x))$.\n        -   Base case: $P(0)=0$. The constant $0$ is given by the zero function $Z^0()$.\n        -   Recursive step: $P(S(x)) = h(x,P(x))$. We have $P(S(x))=x$, so $h(x,z) = x$. This is the projection function $U^2_1(x,z)$.\n        Since the constant $0$ and the function $U^2_1$ are PR, the predecessor function $P$ is PR.\n\n    Now we define truncated subtraction $T(x,y)$, also denoted $x \\dot{-} y$. The recursion must be on the first argument of the function being defined. To recurse on $y$, we define an intermediate function $f(y,x) = x \\dot{-} y$.\n    $$f(0,x) = x \\dot{-} 0 = x$$\n    $$f(S(y),x) = x \\dot{-} (y+1) = P(x \\dot{-} y) = P(f(y,x))$$\n    -   Base case: $f(0,x) = g(x)$. We have $f(0,x)=x$. So $g(x) = U^1_1(x)$, which is PR.\n    -   Recursive step: $f(S(y),x) = h(y,x,f(y,x))$. We have $f(S(y),x) = P(f(y,x))$. Let $z=f(y,x)$, so $h(y,x,z) = P(z) = P(U^3_3(y,x,z))$. Since $P$ is PR and $U^3_3$ is initial, $h$ is PR by composition.\n    Thus, $f(y,x)$ is PR. The desired function is $T(x,y) = x \\dot{-} y = f(y,x)$. We can obtain $T$ from $f$ by swapping arguments, which is a composition: $T(x,y) = f(U^2_2(x,y), U^2_1(x,y))$. Since $f$ and the projection functions are PR, $T$ is PR.\n\n4.  **Evaluation of $F(3,5)$**\n\n    The composite function is given by:\n    $$F(x,y)\\;=\\;T\\Big(M\\big(x,\\,S(S(y))\\big),\\;A\\big(x,\\,T\\big(y,\\,S(x)\\big)\\big)\\Big)$$\n    We need to compute $F(3,5)$. We substitute $x=3$ and $y=5$:\n    $$F(3,5)\\;=\\;T\\Big(M\\big(3,\\,S(S(5))\\big),\\;A\\big(3,\\,T\\big(5,\\,S(3)\\big)\\big)\\Big)$$\n    Let's evaluate the terms inside out.\n    -   $S(3) = 3+1 = 4$.\n    -   $S(5) = 5+1 = 6$.\n    -   $S(S(5)) = S(6) = 6+1 = 7$.\n    Substituting these values gives:\n    $$F(3,5)\\;=\\;T\\Big(M(3, 7),\\;A\\big(3,\\,T(5, 4)\\big)\\Big)$$\n    Now we evaluate the arguments for the outermost function $T$:\n    -   The first argument is $M(3, 7) = 3 \\cdot 7 = 21$.\n    -   The second argument is $A\\big(3,\\,T(5, 4)\\big)$. We first compute $T(5,4)$:\n        $T(5,4) = \\max(5-4, 0) = \\max(1, 0) = 1$.\n        Now we compute $A(3,1)$:\n        $A(3,1) = 3+1 = 4$.\n    So, the second argument is $4$.\n    Finally, we substitute these back into the expression for $F(3,5)$:\n    $$F(3,5) = T(21, 4)$$\n    And we compute the final result:\n    $$T(21, 4) = \\max(21-4, 0) = \\max(17, 0) = 17$$\n    The value of $F(3,5)$ is $17$.", "answer": "$$\\boxed{17}$$", "id": "3038773"}, {"introduction": "Once we can construct functions, a natural next question is how to handle inputs of varying sizes. Turing machines operate on a single tape, and our theory is simplest when functions take a single natural number as input. This practice explores a clever solution: pairing functions, which are computable bijections that losslessly encode a pair of numbers into a single one. Mastering this concept is key to understanding how a single program index $e$ and its input $x$ can be combined into one number, a technique that paves the way for the monumental concept of a Universal Turing Machine. [@problem_id:3038770]", "problem": "Let $\\mathbb{N}=\\{0,1,2,\\dots\\}$. A pairing function is a bijection $\\langle \\cdot,\\cdot\\rangle:\\mathbb{N}^2\\to\\mathbb{N}$. A function $f:\\mathbb{N}^k\\to\\mathbb{N}$ is computable if there is a Turing machine (TM) that halts on every input and outputs $f$’s value; a set $S\\subseteq\\mathbb{N}^k$ is decidable if its characteristic function $\\chi_S:\\mathbb{N}^k\\to\\mathbb{N}$ is computable, and semi-decidable (recursively enumerable) if there is a TM that halts on input $\\vec{x}$ if and only if $\\vec{x}\\in S$. Let $\\{\\varphi_e\\}_{e\\in\\mathbb{N}}$ be a fixed effective enumeration of all partial computable functions $\\varphi_e:\\mathbb{N}\\rightharpoonup\\mathbb{N}$ arising from an effective enumeration of Turing machines and inputs.\n\nSelect all statements that are correct.\n\n- A. The function $\\pi:\\mathbb{N}^2\\to\\mathbb{N}$ defined by $\\pi(x,y)=\\dfrac{(x+y)(x+y+1)}{2}+y$ is a total computable bijection.\n- B. For the function in A, there exist total computable unpairing functions $\\ell,r:\\mathbb{N}\\to\\mathbb{N}$ such that for all $n\\in\\mathbb{N}$, $\\pi(\\ell(n),r(n))=n$.\n- C. Given any computable bijection $\\langle\\cdot,\\cdot\\rangle:\\mathbb{N}^2\\to\\mathbb{N}$, there is a partial computable function $U:\\mathbb{N}\\rightharpoonup\\mathbb{N}$ such that for all $e,x\\in\\mathbb{N}$, whenever $\\varphi_e(x)$ is defined, $U(\\langle e,x\\rangle)=\\varphi_e(x)$. Thus one can code a program index and its input as a single natural number.\n- D. For every $A\\subseteq\\mathbb{N}^2$ and every computable bijection $\\langle\\cdot,\\cdot\\rangle:\\mathbb{N}^2\\to\\mathbb{N}$, the set $C=\\{\\langle x,y\\rangle:(x,y)\\in A\\}\\subseteq\\mathbb{N}$ satisfies: $A$ is decidable if and only if $C$ is decidable; $A$ is semi-decidable if and only if $C$ is semi-decidable.\n- E. The function $\\langle x,y\\rangle=2^x3^y$ is a computable bijection from $\\mathbb{N}^2$ onto $\\mathbb{N}$.\n- F. Let $K=\\{\\langle e,x\\rangle:\\varphi_e(x)\\text{ halts}\\}\\subseteq\\mathbb{N}$. Then $K$ is decidable because one can systematically enumerate all pairs and simulate the corresponding computations.\n\nChoose all that apply.", "solution": "### Problem Validation\n\nI will first validate the problem statement as per the required procedure.\n\n#### Step 1: Extract Givens\n- The set of natural numbers is $\\mathbb{N}=\\{0,1,2,\\dots\\}$.\n- A pairing function is a bijection $\\langle \\cdot,\\cdot\\rangle:\\mathbb{N}^2\\to\\mathbb{N}$.\n- A function $f:\\mathbb{N}^k\\to\\mathbb{N}$ is computable if there is a Turing machine (TM) that halts on every input and outputs $f$’s value. (This defines a total computable function.)\n- A set $S\\subseteq\\mathbb{N}^k$ is decidable if its characteristic function $\\chi_S:\\mathbb{N}^k\\to\\mathbb{N}$ is computable.\n- A set $S\\subseteq\\mathbb{N}^k$ is semi-decidable (recursively enumerable) if there is a TM that halts on input $\\vec{x}$ if and only if $\\vec{x}\\in S$.\n- $\\{\\varphi_e\\}_{e\\in\\mathbb{N}}$ is a fixed effective enumeration of all partial computable functions $\\varphi_e:\\mathbb{N}\\rightharpoonup\\mathbb{N}$.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem statement consists of a set of standard definitions from computability theory, a branch of mathematical logic, followed by several propositions to be evaluated.\n\n- **Scientifically Grounded (Critical):** The definitions of computable functions, decidable sets, semi-decidable sets, pairing functions, and the enumeration of partial computable functions ($\\{\\varphi_e\\}$) are all fundamental and standard in the theory of computation. They are factually and logically sound.\n- **Well-Posed:** The problem asks to determine the correctness of several statements based on the provided definitions. This is a clear and well-defined task with unambiguous true/false answers derivable from the principles of computability theory.\n- **Objective (Critical):** The language is formal, mathematical, and precise. There are no subjective or ambiguous terms.\n- **Completeness and Consistency:** The definitions provided are sufficient to analyze the given options. There are no internal contradictions. For instance, the distinction between a (total) computable function and a partial computable function is standard and correctly handled.\n- **Other Flaws:** The problem does not exhibit any other flaws such as being metaphorical, trivial, or unverifiable. It is a standard academic question in its field.\n\n#### Step 3: Verdict and Action\nThe problem statement is valid. I will now proceed with a full analysis of each option.\n\n### Analysis of Options\n\n#### Option A\nThe statement is: The function $\\pi:\\mathbb{N}^2\\to\\mathbb{N}$ defined by $\\pi(x,y)=\\dfrac{(x+y)(x+y+1)}{2}+y$ is a total computable bijection.\n\n1.  **Totality:** For any $(x,y) \\in \\mathbb{N}^2$, $x+y$ is a natural number. The product of two consecutive integers, $(x+y)(x+y+1)$, is always even. Therefore, the division by $2$ results in an integer. Since $x, y \\ge 0$, this integer is non-negative. Adding $y \\ge 0$ yields a result in $\\mathbb{N}$. Thus, the function is total.\n\n2.  **Computability:** The function $\\pi(x,y)$ is constructed from addition, multiplication, and integer division. These are all primitive recursive operations, and therefore computable by a Turing machine that always halts. The composition of total computable functions is total computable. Hence, $\\pi$ is a computable function.\n\n3.  **Bijectivity:**\n    - **Injectivity:** Let $s = x+y$. The function $T(s) = \\frac{s(s+1)}{2}$ (the $s$-th triangular number) is strictly increasing for $s \\in \\mathbb{N}$. We have $\\pi(x,y) = T(s)+y$. Since $y \\le x+y = s$, we have $T(s) \\le \\pi(x,y) \\le T(s)+s$. Also, $T(s+1) = \\frac{(s+1)(s+2)}{2} = \\frac{s^2+3s+2}{2} = \\frac{s(s+1)}{2} + s+1 = T(s)+s+1$. So, $T(s) \\le \\pi(x,y)  T(s+1)$. This implies that for a given value $n = \\pi(x,y)$, the sum $s=x+y$ is uniquely determined as the integer $s$ such that $T(s) \\le n  T(s+1)$. If $\\pi(x,y) = \\pi(x',y')$, then they must have the same sum $s=x+y = x'+y'$. The equation becomes $T(s)+y = T(s)+y'$, which directly implies $y=y'$. Since $x+y=x'+y'$ and $y=y'$, it follows that $x=x'$. Therefore, $(x,y)=(x',y')$, and the function is injective.\n    - **Surjectivity:** For any $n \\in \\mathbb{N}$, we must find $(x,y) \\in \\mathbb{N}^2$ such that $\\pi(x,y)=n$. As shown above, we can find a unique $s \\in \\mathbb{N}$ such that $T(s) \\le n  T(s+1)$. Let $y = n - T(s)$. Since $n \\ge T(s)$, we have $y \\ge 0$. Let $x = s-y$. To ensure $x \\ge 0$, we need $y \\le s$. From $n  T(s+1) = T(s)+s+1$, we have $n-T(s)  s+1$, which implies $y  s+1$, or $y \\le s$. Thus, $x = s-y \\ge 0$. We have found a pair $(x,y)\\in\\mathbb{N}^2$ for every $n\\in\\mathbb{N}$. The function is surjective.\n\nThis function is the well-known Cantor pairing function. It is indeed a total computable bijection.\nVerdict: **Correct**.\n\n#### Option B\nThe statement is: For the function in A, there exist total computable unpairing functions $\\ell,r:\\mathbb{N}\\to\\mathbb{N}$ such that for all $n\\in\\mathbb{N}$, $\\pi(\\ell(n),r(n))=n$.\n\nThis statement claims that the inverse of the Cantor pairing function $\\pi$ is computable. The inverse function $\\pi^{-1}: \\mathbb{N} \\to \\mathbb{N}^2$ maps $n$ to $(\\ell(n), r(n))$. The computability of $\\pi^{-1}$ is equivalent to the computability of its component functions $\\ell$ and $r$.\n\nFollowing the surjectivity proof for Option A, we can construct algorithms for $\\ell(n)$ and $r(n)$:\n1.  Given $n$, find $s$ such that $\\frac{s(s+1)}{2} \\le n  \\frac{(s+1)(s+2)}{2}$. This can be done by solving $s^2+s-2n \\le 0$ for $s \\in \\mathbb{N}$, which yields $s = \\lfloor \\frac{\\sqrt{8n+1}-1}{2} \\rfloor$. This procedure involves root extraction, multiplication, addition, and the floor function, all of which are computable.\n2.  Once $s$ is found, calculate the triangular number $T_s = \\frac{s(s+1)}{2}$. This is computable.\n3.  Calculate $y = r(n) = n - T_s$. This is computable.\n4.  Calculate $x = \\ell(n) = s - y$. This is computable.\n\nSince each step is computable and defined for all $n \\in \\mathbb{N}$, the functions $\\ell(n)$ and $r(n)$ are total computable functions. By construction, they satisfy $\\pi(\\ell(n), r(n))=n$. This is a general property: any computable bijection between decidable subsets of $\\mathbb{N}^k$ has a computable inverse.\nVerdict: **Correct**.\n\n#### Option C\nThe statement is: Given any computable bijection $\\langle\\cdot,\\cdot\\rangle:\\mathbb{N}^2\\to\\mathbb{N}$, there is a partial computable function $U:\\mathbb{N}\\rightharpoonup\\mathbb{N}$ such that for all $e,x\\in\\mathbb{N}$, whenever $\\varphi_e(x)$ is defined, $U(\\langle e,x\\rangle)=\\varphi_e(x)$.\n\nThis is a statement of the existence of a universal partial computable function, adapted for a single-number input via a pairing function. The existence of such a function is a fundamental result in computability theory (a consequence of the $S_n^m$ theorem and the existence of universal Turing machines).\n\nLet $\\langle\\cdot,\\cdot\\rangle$ be any computable bijection. As established in the analysis of option B, its inverse functions $\\ell(n)$ and $r(n)$, which retrieve the original pair, are total computable.\nWe can define the function $U(n)$ via the following algorithm:\n1.  Given an input $n \\in \\mathbb{N}$, compute the pair $(e,x)$ such that $\\langle e,x \\rangle = n$. This is done by computing $e = \\ell(n)$ and $x = r(n)$. This step is computable and always halts.\n2.  Using a universal Turing machine, simulate the computation of the machine with index $e$ on input $x$, i.e., compute $\\varphi_e(x)$.\n\nThe function $U(n)$ is defined as the result of this process. The process defines a partial computable function because the simulation in step 2 (computing $\\varphi_e(x)$) may not halt. If $\\varphi_e(x)$ is defined (halts), then the simulation terminates and outputs the value of $\\varphi_e(x)$, so $U(\\langle e,x \\rangle) = \\varphi_e(x)$. If $\\varphi_e(x)$ is undefined (does not halt), the simulation for $U(\\langle e,x \\rangle)$ will also not halt, so $U(\\langle e,x \\rangle)$ is also undefined. This matches the required properties for $U$.\nVerdict: **Correct**.\n\n#### Option D\nThe statement is: For every $A\\subseteq\\mathbb{N}^2$ and every computable bijection $\\langle\\cdot,\\cdot\\rangle:\\mathbb{N}^2\\to\\mathbb{N}$, the set $C=\\{\\langle x,y\\rangle:(x,y)\\in A\\}\\subseteq\\mathbb{N}$ satisfies: $A$ is decidable if and only if $C$ is decidable; $A$ is semi-decidable if and only if $C$ is semi-decidable.\n\nThis statement asserts that computability properties (decidability, semi-decidability) are invariant under computable isomorphisms. Let the computable bijection be $f(x,y) = \\langle x,y \\rangle$. Its inverse $f^{-1}(n) = (\\ell(n), r(n))$ is also computable.\n\n1.  **Decidability equivalence:**\n    - ($\\Rightarrow$) Assume $A$ is decidable. Its characteristic function $\\chi_A(x,y)$ is total computable. To decide if $n \\in C$, we can first compute $(x,y) = f^{-1}(n)$ and then compute $\\chi_A(x,y)$. The characteristic function of $C$ is $\\chi_C(n) = \\chi_A(f^{-1}(n))$. Since $f^{-1}$ and $\\chi_A$ are total computable, their composition $\\chi_C$ is also total computable. Thus, $C$ is decidable.\n    - ($\\Leftarrow$) Assume $C$ is decidable. Its characteristic function $\\chi_C(n)$ is total computable. To decide if $(x,y) \\in A$, we can first compute $n=f(x,y)$ and then compute $\\chi_C(n)$. The characteristic function of $A$ is $\\chi_A(x,y) = \\chi_C(f(x,y))$. Since $f$ and $\\chi_C$ are total computable, their composition $\\chi_A$ is also total computable. Thus, $A$ is decidable.\n\n2.  **Semi-decidability equivalence:**\n    - ($\\Rightarrow$) Assume $A$ is semi-decidable. There exists a TM $M_A$ that halts on input $(x,y)$ iff $(x,y) \\in A$. To check if $n \\in C$, we build a machine $M_C$ that on input $n$, first computes $(x,y)=f^{-1}(n)$ and then runs $M_A$ on $(x,y)$. $M_C$ halts iff $f^{-1}(n) \\in A$, which is true iff $n \\in C$. Thus, $C$ is semi-decidable.\n    - ($\\Leftarrow$) Assume $C$ is semi-decidable. There exists a TM $M_C$ that halts on input $n$ iff $n \\in C$. To check if $(x,y) \\in A$, we build a machine $M_A$ that on input $(x,y)$, first computes $n=f(x,y)$ and then runs $M_C$ on $n$. $M_A$ halts iff $f(x,y) \\in C$, which is true iff $(x,y) \\in A$. Thus, $A$ is semi-decidable.\n\nThe statement is a fundamental result concerning computable reductions.\nVerdict: **Correct**.\n\n#### Option E\nThe statement is: The function $\\langle x,y\\rangle=2^x3^y$ is a computable bijection from $\\mathbb{N}^2$ onto $\\mathbb{N}$.\n\n1.  **Computability:** The function involves exponentiation and multiplication, which are computable operations. Thus, the function is computable.\n2.  **Injectivity:** Assume $2^x3^y = 2^{x'}3^{y'}$. By the Fundamental Theorem of Arithmetic (unique prime factorization of integers), we must have $x=x'$ and $y=y'$. The function is injective.\n3.  **Surjectivity:** A bijection must be surjective (onto). We need to check if the range of the function is all of $\\mathbb{N}$. Consider the number $5 \\in \\mathbb{N}$. There are no integers $x,y \\ge 0$ such that $2^x3^y = 5$, since the prime factorization of $5$ is just $5^1$. The range of this function is the set of natural numbers whose prime factorizations only contain primes $2$ and $3$. Since the range is a proper subset of $\\mathbb{N}$, the function is not surjective.\n\nSince the function is not surjective, it is not a bijection. The problem defines a pairing function as a bijection.\nVerdict: **Incorrect**.\n\n#### Option F\nThe statement is: Let $K=\\{\\langle e,x\\rangle:\\varphi_e(x)\\text{ halts}\\}\\subseteq\\mathbb{N}$. Then $K$ is decidable because one can systematically enumerate all pairs and simulate the corresponding computations.\n\nThe set $K$ is the set of codes for pairs $(e,x)$ where the $e$-th Turing machine halts on input $x$. This is the standard formulation of the Halting Problem, often denoted HALT or $K_0$.\nThe problem of deciding membership in $K$ is undecidable. This is one of the most fundamental results in computability theory, first proven by Alan Turing.\n\nThe reasoning provided, \"because one can systematically enumerate all pairs and simulate the corresponding computations,\" describes an algorithm to show that $K$ is *semi-decidable* (recursively enumerable), not decidable.\nA semi-deciding TM for $K$ on input $n$ would be:\n1.  Compute $(e,x)$ such that $n = \\langle e,x \\rangle$.\n2.  Simulate machine $e$ on input $x$.\n3.  If the simulation halts, halt and accept.\n\nThis machine halts if and only if $n \\in K$. However, if $n \\notin K$ (i.e., $\\varphi_e(x)$ does not halt), this machine will run forever. A decider for $K$ must be a total computable function (a TM that halts on *all* inputs), returning $1$ if $n \\in K$ and $0$ otherwise. The non-existence of such a machine is proven by a diagonalization argument. Assuming such a decider exists leads to a logical contradiction.\nTherefore, the statement that $K$ is decidable is false.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{ABCD}$$", "id": "3038770"}, {"introduction": "After establishing what we can compute, we turn to the profound question of what we cannot. Rice's Theorem provides a powerful answer, stating that any non-trivial property of what a program *does* (its semantics) is undecidable. This exercise challenges you to navigate the crucial boundary between a program's structure (its syntax) and its behavior (its semantics). By correctly identifying properties that fall outside the scope of Rice's Theorem, you will develop a sharp intuition for why some problems about programs are solvable while others are fundamentally beyond our algorithmic reach. [@problem_id:3038772]", "problem": "Fix a standard effective encoding of programs for a Turing machine (TM), so that each program is assigned a unique Gödel code in the set of natural numbers $\\mathbb{N}$. For each code $e \\in \\mathbb{N}$, let $\\varphi_e$ denote the partial computable function computed by the TM program with code $e$. A subset $A \\subseteq \\mathbb{N}$ is called decidable if its characteristic function $\\chi_A \\colon \\mathbb{N} \\to \\{0,1\\}$ is computable. A property of programs is called syntactic if it depends only on the representation or description of the program (for example, its length or the presence of a particular symbol in its code), and semantic if it depends only on the extensional behavior of the computed function (for example, the values and domain of $\\varphi_e$).\n\nSelect all options that correctly identify a syntactic property that is decidable and correctly explain why Rice’s theorem does not apply to it. Each option describes a set of indices and a brief justification.\n\nA. $S_{\\text{len}} = \\{ e \\in \\mathbb{N} : \\text{the encoded program with code } e \\text{ has fewer than } 100 \\text{ instructions} \\}$. This property is decidable by parsing the finite code and counting instructions, and Rice’s theorem does not apply because the property depends on program syntax rather than the function $\\varphi_e$.\n\nB. $Z = \\{ e \\in \\mathbb{N} : \\varphi_e(x) = 0 \\text{ for all } x \\in \\mathbb{N} \\}$. This property is decidable by testing inputs, and Rice’s theorem does not apply because the property concerns the program’s syntax.\n\nC. $D_0 = \\{ e \\in \\mathbb{N} : \\varphi_e(0) \\text{ is defined} \\}$. This property is syntactic and decidable by inspecting the code path on input $0$, and Rice’s theorem applies, implying undecidability.\n\nD. $P_{\\text{prime}} = \\{ e \\in \\mathbb{N} : e \\text{ is a prime number} \\}$. This property is decidable using a primality test, and Rice’s theorem does not apply because the property depends only on the numerical Gödel code $e$, not on the extensional behavior of $\\varphi_e$.\n\nE. $T = \\{ e \\in \\mathbb{N} : \\varphi_e \\text{ is total} \\}$. This property is decidable since a program that does not loop must halt on every input, and Rice’s theorem is irrelevant here.\n\nChoose all correct options.", "solution": "The user wants me to identify which options correctly describe a property of Turing machine programs that is syntactic, decidable, and for which Rice's theorem's inapplicability is correctly explained.\n\nFirst, let us establish the core definitions and theorems as provided in the problem statement.\n- A Gödel encoding assigns a unique natural number $e \\in \\mathbb{N}$ to each Turing machine program. $\\varphi_e$ denotes the partial computable function computed by the program with code $e$.\n- A set $A \\subseteq \\mathbb{N}$ is decidable if its characteristic function $\\chi_A: \\mathbb{N} \\to \\{0, 1\\}$ is computable. This means there is an algorithm that, for any input $n \\in \\mathbb{N}$, halts and outputs $1$ if $n \\in A$ and halts and outputs $0$ if $n \\notin A$.\n- A property of programs is **syntactic** if it depends only on the code $e$ itself. Formally, a set of indices $S \\subseteq \\mathbb{N}$ represents a syntactic property if it is not a semantic property.\n- A property of programs is **semantic** if it depends on the function $\\varphi_e$ computed by the program. Formally, a set of indices $S \\subseteq \\mathbb{N}$ represents a semantic property if for any two program codes $e, f \\in \\mathbb{N}$, if $\\varphi_e = \\varphi_f$ (meaning they compute the same partial function), then $e \\in S$ if and only if $f \\in S$.\n- **Rice's Theorem**: Any non-trivial semantic property of partial computable functions is undecidable. A property is non-trivial if there exists at least one computable function that has the property and at least one that does not.\n\nThe task is to find options where the described set of indices $S$ meets three criteria:\n1.  The property defining $S$ is syntactic.\n2.  The set $S$ is decidable.\n3.  The explanation for why Rice's theorem does not apply is correct.\n\nLet us evaluate each option.\n\n**A. $S_{\\text{len}} = \\{ e \\in \\mathbb{N} : \\text{the encoded program with code } e \\text{ has fewer than } 100 \\text{ instructions} \\}$. This property is decidable by parsing the finite code and counting instructions, and Rice’s theorem does not apply because the property depends on program syntax rather than the function $\\varphi_e$.**\n\n1.  **Syntactic Property**: The number of instructions is a feature of the program's description (its code), not the function it computes. It's possible to create two different programs, $p_1$ and $p_2$, with codes $e_1$ and $e_2$, such that $\\varphi_{e_1} = \\varphi_{e_2}$ but $p_1$ has fewer than $100$ instructions and $p_2$ has $100$ or more (e.g., by adding redundant \"no-op\" instructions to $p_1$ to create $p_2$). Therefore, $e_1$ could be in $S_{\\text{len}}$ while $e_2$ is not, even though they compute the same function. This violates the condition for a semantic property, hence the property is syntactic. This part of the statement is correct.\n\n2.  **Decidable Set**: The problem states there is a \"standard effective encoding\". This implies that given a number $e$, we can algorithmically decode it to obtain the representation of the program. Once decoded, counting the number of instructions is a simple parsing task on a finite string or structure. An algorithm can take $e$ as input, decode it, count the instructions, compare the count to $100$, and output $1$ if the count is less than $100$ and $0$ otherwise. This algorithm always halts. Thus, the set $S_{\\text{len}}$ is decidable. This part of the statement is correct.\n\n3.  **Explanation for Rice's Theorem**: The explanation given is that \"Rice’s theorem does not apply because the property depends on program syntax rather than the function $\\varphi_e$\". This is precisely correct. Rice's theorem exclusively applies to non-trivial *semantic* properties. Since this property is syntactic, Rice's theorem is not applicable.\n\n**Verdict on A**: This option correctly identifies a syntactic, decidable property and provides the correct reason for the inapplicability of Rice's theorem. **Correct**.\n\n**B. $Z = \\{ e \\in \\mathbb{N} : \\varphi_e(x) = 0 \\text{ for all } x \\in \\mathbb{N} \\}$. This property is decidable by testing inputs, and Rice’s theorem does not apply because the property concerns the program’s syntax.**\n\n1.  **Syntactic Property**: The property of computing the constant zero function is a property of the function's behavior (its input-output mapping). If $\\varphi_e$ is the constant zero function and $\\varphi_f = \\varphi_e$, then $\\varphi_f$ must also be the constant zero function. So, $e \\in Z \\iff f \\in Z$. This is the definition of a semantic property. The claim that it \"concerns the program's syntax\" is false.\n\n2.  **Decidable Set**: The property \"computes the constant zero function\" is a non-trivial semantic property. The constant zero function is computable, so some programs have this property. The successor function $s(x) = x+1$ is also computable and does not have this property. Therefore, by Rice's theorem, the set $Z$ is undecidable. The claim that it is \"decidable by testing inputs\" is false because one cannot test all infinitely many inputs $x \\in \\mathbb{N}$ in finite time.\n\n3.  **Explanation for Rice's Theorem**: The option claims Rice's theorem does not apply. This is false. Since the property is non-trivial and semantic, Rice's theorem is precisely what proves its undecidability.\n\n**Verdict on B**: This option is incorrect on all three points. The property is semantic and undecidable, and Rice's theorem does apply. **Incorrect**.\n\n**C. $D_0 = \\{ e \\in \\mathbb{N} : \\varphi_e(0) \\text{ is defined} \\}$. This property is syntactic and decidable by inspecting the code path on input $0$, and Rice’s theorem applies, implying undecidability.**\n\n1.  **Syntactic Property**: Whether $\\varphi_e(0)$ halts is a property of the domain of the function $\\varphi_e$. If $\\varphi_e = \\varphi_f$, their domains must be identical. Hence, if $\\varphi_e(0)$ is defined, $\\varphi_f(0)$ must also be defined. This is a semantic property. The claim that it is syntactic is false.\n\n2.  **Decidable Set**: The set $D_0$ is the set of indices for programs that halt on input $0$. This is the Halting Problem for a fixed input, often denoted $K_0$. It is a classic result in computability theory that this set is undecidable. The claim that it is \"decidable by inspecting the code path\" is false; this inspection is precisely the Halting Problem.\n\n3.  **Explanation for Rice's Theorem**: The option makes contradictory claims. It first claims the property is decidable, but then says \"Rice’s theorem applies, implying undecidability.\" While it is true that Rice's theorem applies (the property is non-trivial and semantic) and implies undecidability, this contradicts the initial assertion of decidability. The entire statement is inconsistent.\n\n**Verdict on C**: The option incorrectly identifies the property as syntactic and decidable. Its reasoning is self-contradictory. **Incorrect**.\n\n**D. $P_{\\text{prime}} = \\{ e \\in \\mathbb{N} : e \\text{ is a prime number} \\}$. This property is decidable using a primality test, and Rice’s theorem does not apply because the property depends only on the numerical Gödel code $e$, not on the extensional behavior of $\\varphi_e$.**\n\n1.  **Syntactic Property**: The property of an integer $e$ being prime depends only on the value of $e$ itself. It has no connection to the function $\\varphi_e$ that is computed by the program with code $e$. We can have two programs with codes $e$ and $f$ such that $\\varphi_e = \\varphi_f$, but $e$ is prime and $f$ is composite. This is a property of the index, not the function, and is therefore syntactic. This part of the statement is correct.\n\n2.  **Decidable Set**: The set of prime numbers is a decidable subset of $\\mathbb{N}$. There exist many well-known algorithms (e.g., trial division, Sieve of Eratosthenes, Miller-Rabin test) that can determine in a finite number of steps whether a given number $e$ is prime. This part of the statement is correct.\n\n3.  **Explanation for Rice's Theorem**: The explanation is that Rice's theorem does not apply because the property depends only on the code $e$ and not the function $\\varphi_e$. This is correct. Rice's theorem applies only to semantic properties. Since primality of the index $e$ is a syntactic property, Rice's theorem is irrelevant to its decidability.\n\n**Verdict on D**: This option correctly identifies a syntactic, decidable property and provides the correct reason for the inapplicability of Rice's theorem. **Correct**.\n\n**E. $T = \\{ e \\in \\mathbb{N} : \\varphi_e \\text{ is total} \\}$. This property is decidable since a program that does not loop must halt on every input, and Rice’s theorem is irrelevant here.**\n\n1.  **Syntactic Property**: Totality (halting on all inputs) is a property of the function $\\varphi_e$. If $\\varphi_e = \\varphi_f$ and $\\varphi_e$ is total, then $\\varphi_f$ must also be total. This is a semantic property.\n\n2.  **Decidable Set**: The property of being total is a non-trivial semantic property. The identity function is total, and a function that is undefined everywhere is not. By Rice's theorem, the set $T$ is undecidable. In fact, it is a well-known result that $T$ is not even semi-decidable (it is $\\Pi_2$-complete in the arithmetical hierarchy). The claim that it is decidable is false.\n\n3.  **Explanation for Rice's Theorem**: The option claims Rice's theorem is \"irrelevant here.\" This is false. Since the property is non-trivial and semantic, Rice's theorem is directly relevant and is the standard tool used to prove the undecidability of $T$.\n\n**Verdict on E**: This option is incorrect. The property is semantic and undecidable, and Rice's theorem is directly applicable. **Incorrect**.\n\nIn conclusion, options A and D are the only ones that satisfy all the required conditions.", "answer": "$$\\boxed{AD}$$", "id": "3038772"}]}