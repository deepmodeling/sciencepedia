{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是动手实践。我们从一个理想抛体运动的基础问题开始。这个练习将帮助你巩固对基本运动学方程的理解，并探索在没有空气阻力的情况下，抛射物的水平射程和最大高度之间纯粹由发射角度决定的内在联系。通过推导这个关系，你将更深刻地理解如何将二维运动分解为独立的水平和竖直分量进行分析。[@problem_id:2209981]", "problem": "一家体育分析公司正在为一款新的虚拟现实游戏设计一个逼真的物理引擎。游戏中的一个关键机制涉及从地面以初速度 $v_0$ 和与水平方向成 $\\theta$ 角的发射角抛出一个球。对于一项特定的游戏内挑战，球的轨迹必须满足一个精确的美学条件：球在落回地面之前所经过的总水平距离（其射程 $R$）必须恰好是其最大垂直高度（$H$）的 $n$ 倍。球的发射点和落地点处于同一垂直水平面上。\n\n假设重力加速度为常数 $g$ 且空气阻力可忽略不计，推导出发射角 $\\theta$ 关于无量纲因子 $n$ 的解析表达式。", "solution": "设初速度为 $v_{0}$，发射角为高于水平方向的 $\\theta$。在恒定的向下重力加速度 $g$ 作用下且无空气阻力的情况下，抛射体的运动由以下方程决定\n$$\nx(t)=v_{0}\\cos\\theta\\, t,\\qquad y(t)=v_{0}\\sin\\theta\\, t-\\frac{1}{2}gt^{2}.\n$$\n飞行时间 $T$（返回到发射高度，因此当 $T0$ 时 $y(T)=0$）满足\n$$\n0=v_{0}\\sin\\theta\\, T-\\frac{1}{2}gT^{2}\\quad\\Rightarrow\\quad T=\\frac{2v_{0}\\sin\\theta}{g}.\n$$\n射程 $R$ 是 $t=T$ 时的水平位移：\n$$\nR=x(T)=v_{0}\\cos\\theta\\left(\\frac{2v_{0}\\sin\\theta}{g}\\right)=\\frac{v_{0}^{2}}{g}\\sin(2\\theta).\n$$\n当垂直速度为零时，达到最大高度 $H$。垂直速度为 $v_{y}(t)=v_{0}\\sin\\theta-gt$，因此令 $v_{y}(t_{h})=0$ 可得\n$$\nt_{h}=\\frac{v_{0}\\sin\\theta}{g}.\n$$\n因此，\n$$\nH=y(t_{h})=v_{0}\\sin\\theta\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)-\\frac{1}{2}g\\left(\\frac{v_{0}\\sin\\theta}{g}\\right)^{2}=\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}.\n$$\n条件 $R=nH$ 得出\n$$\n\\frac{v_{0}^{2}}{g}\\sin(2\\theta)=n\\left(\\frac{v_{0}^{2}\\sin^{2}\\theta}{2g}\\right).\n$$\n消去公因式 $\\frac{v_{0}^{2}}{g}$ 并使用 $\\sin(2\\theta)=2\\sin\\theta\\cos\\theta$，\n$$\n\\sin(2\\theta)=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n2\\sin\\theta\\cos\\theta=\\frac{n}{2}\\sin^{2}\\theta\n\\quad\\Rightarrow\\quad\n4\\cos\\theta=n\\sin\\theta.\n$$\n因此，\n$$\n\\cot\\theta=\\frac{n}{4}\\quad\\Rightarrow\\quad \\tan\\theta=\\frac{4}{n}\\quad\\Rightarrow\\quad \\theta=\\arctan\\!\\left(\\frac{4}{n}\\right).\n$$\n对于 $n0$，这在区间 $(0,\\frac{\\pi}{2})$ 内给出了唯一具有物理意义的发射角。", "answer": "$$\\boxed{\\arctan\\!\\left(\\frac{4}{n}\\right)}$$", "id": "2209981"}, {"introduction": "现实世界中的物理系统很少是理想的。下一步，我们引入空气阻力这一重要因素，来探讨它如何改变抛体运动的特性。为了使问题在分析上可解，我们先研究一个简化的一维竖直上抛运动，但考虑了更符合实际的二次方阻力（与速度的平方成正比）。这个练习将揭示一个重要的、非直观的物理现象：在有空气阻力时，物体上升所需的时间与从最高点下落回原点所需的时间并不相等。[@problem_id:2210039]", "problem": "一个质量为 $m$ 的小型传感器包以初速度 $v_0$ 从地面垂直向上发射。在整个飞行过程中，它受到一个大小为 $mg$ 的恒定向下重力以及大气的阻力。阻力的大小被建模为 $F_d = b v^2$，其中 $v$ 是传感器包的瞬时速率， $b$ 是一个恒定的阻力系数。该阻力始终与运动方向相反。\n\n传感器包达到最大高度然后回落到地面。设 $t_{up}$ 为其从地面运动到最大高度所用的时间， $t_{down}$ 为其从最大高度回落到地面所用的时间。\n\n推导比率 $t_{down}/t_{up}$ 的闭式解析表达式。您的最终表达式应该用初始发射速度 $v_0$ 和终端速度 $v_T$ 表示，其中终端速度定义为如果传感器包从很高的高度下落将达到的恒定速度，其表达式为 $v_T = \\sqrt{mg/b}$。", "solution": "让我们将传感器包的运动分为两部分来分析：上升和下降。我们定义向上方向为正方向。\n\n首先，考虑上升过程。作用在传感器包上的力是重力（$mg$，向下）和空气阻力（$bv^2$，也向下，因为它与向上的运动相反）。根据牛顿第二定律，运动方程为：\n$$ m \\frac{dv}{dt} = -mg - bv^2 $$\n我们可以使用终端速度 $v_T = \\sqrt{mg/b}$ 来重写这个方程。这意味着 $b = mg/v_T^2$。将此代入运动方程：\n$$ m \\frac{dv}{dt} = -mg - \\frac{mg}{v_T^2}v^2 = -mg \\left(1 + \\frac{v^2}{v_T^2}\\right) $$\n$$ \\frac{dv}{dt} = -g \\left(1 + \\frac{v^2}{v_T^2}\\right) $$\n为了求出上升时间 $t_{up}$，我们分离变量并进行积分。速度从 $t=0$ 时的 $v_0$ 变为 $t=t_{up}$ 时的 $0$。\n$$ \\int_{v_0}^{0} \\frac{dv}{1 + (v/v_T)^2} = -g \\int_{0}^{t_{up}} dt $$\n让我们进行换元，$u = v/v_T$，则 $dv = v_T du$。$u$ 的积分上下限为从 $v_0/v_T$ 到 $0$。\n$$ \\int_{v_0/v_T}^{0} \\frac{v_T du}{1 + u^2} = -g t_{up} $$\n这个积分是标准形式：$\\int \\frac{du}{1+u^2} = \\arctan(u)$。\n$$ v_T [\\arctan(u)]_{v_0/v_T}^{0} = -g t_{up} $$\n$$ v_T \\left(\\arctan(0) - \\arctan\\left(\\frac{v_0}{v_T}\\right)\\right) = -g t_{up} $$\n$$ -v_T \\arctan\\left(\\frac{v_0}{v_T}\\right) = -g t_{up} $$\n求解 $t_{up}$，我们得到：\n$$ t_{up} = \\frac{v_T}{g} \\arctan\\left(\\frac{v_0}{v_T}\\right) $$\n\n接下来，考虑下降过程。传感器包从最大高度由静止开始下落。在下降过程中，速度是向下的（负的）。此时阻力向上，与向下的运动相反。运动方程为：\n$$ m \\frac{dv}{dt} = -mg + bv^2 $$\n这里，$v$ 是速度分量（在下降过程中为负）。如果我们考虑速率 $s = |v| = -v$，那么 $\\frac{ds}{dt} = -\\frac{dv}{dt}$。用速率 $s \\ge 0$ 表示的方程是：\n$$ m \\left(-\\frac{ds}{dt}\\right) = -mg + bs^2 \\implies m\\frac{ds}{dt} = mg - bs^2 $$\n使用 $v_T = \\sqrt{mg/b}$，我们有：\n$$ \\frac{ds}{dt} = g - \\frac{b}{m}s^2 = g \\left(1 - \\frac{s^2}{v_T^2}\\right) $$\n为了求出下降时间 $t_{down}$，我们需要从下落开始（速率 $s=0$）到刚好落地前的最终速率（我们称之为 $s_f$）进行积分。\n首先，让我们求出这个最终速率 $s_f$。我们可以通过将下落高度与动能变化联系起来做到这一点。最大高度 $y_{max}$ 是在上升过程中达到的。我们可以通过使用链式法则 $dv/dt = (dv/dy)(dy/dt) = v(dv/dy)$ 将速度与位置联系起来，从而求出它。\n对于上升过程：\n$$ mv\\frac{dv}{dy} = -mg - bv^2 $$\n$$ \\int_{v_0}^{0} \\frac{v dv}{g + (b/m)v^2} = -\\frac{1}{m} \\int_0^{y_{max}} m dy = -\\int_0^{y_{max}} dy = -y_{max} $$\n左边的积分可以通过u-换元法求解：$u = g + (b/m)v^2$，所以 $du = (2b/m)v dv$。\n$$ y_{max} = -\\int_{g+(b/m)v_0^2}^{g} \\frac{m}{2b} \\frac{du}{u} = \\frac{m}{2b} [\\ln(u)]_{g}^{g+(b/m)v_0^2} = \\frac{m}{2b} \\left[ \\ln\\left(g + \\frac{b}{m}v_0^2\\right) - \\ln(g) \\right] $$\n$$ y_{max} = \\frac{m}{2b} \\ln\\left(1 + \\frac{b}{mg}v_0^2\\right) = \\frac{v_T^2}{2g} \\ln\\left(1 + \\frac{v_0^2}{v_T^2}\\right) $$\n现在，对于下降过程，我们对速率 $s$ 和下落距离 $y$ 使用相同的链式法则技巧：$ds/dt = (ds/dy)(dy/dt)=s(ds/dy)$。\n$$ ms\\frac{ds}{dy} = mg - bs^2 $$\n$$ \\int_{0}^{s_f} \\frac{s ds}{g - (b/m)s^2} = \\frac{1}{m}\\int_{0}^{y_{max}} m dy = y_{max} $$\n使用类似的u-换元法，$u = g - (b/m)s^2$，$du = - (2b/m)s ds$。\n$$ \\int_{g}^{g-(b/m)s_f^2} -\\frac{m}{2b} \\frac{du}{u} = y_{max} \\implies -\\frac{m}{2b} [\\ln|u|]_g^{g-(b/m)s_f^2} = y_{max} $$\n$$ -\\frac{v_T^2}{2g} \\left[ \\ln\\left|g - \\frac{mg}{v_T^2}s_f^2\\right| - \\ln(g) \\right] = y_{max} $$\n$$ -\\frac{v_T^2}{2g} \\ln\\left(1 - \\frac{s_f^2}{v_T^2}\\right) = y_{max} $$\n令两个 $y_{max}$ 的表达式相等：\n$$ -\\frac{v_T^2}{2g} \\ln\\left(1 - \\frac{s_f^2}{v_T^2}\\right) = \\frac{v_T^2}{2g} \\ln\\left(1 + \\frac{v_0^2}{v_T^2}\\right) $$\n$$ \\ln\\left(\\left(1 - \\frac{s_f^2}{v_T^2}\\right)^{-1}\\right) = \\ln\\left(1 + \\frac{v_0^2}{v_T^2}\\right) $$\n$$ \\frac{1}{1 - s_f^2/v_T^2} = 1 + \\frac{v_0^2}{v_T^2} \\implies 1 - \\frac{s_f^2}{v_T^2} = \\frac{1}{1 + v_0^2/v_T^2} = \\frac{v_T^2}{v_T^2 + v_0^2} $$\n$$ \\frac{s_f^2}{v_T^2} = 1 - \\frac{v_T^2}{v_T^2 + v_0^2} = \\frac{v_0^2}{v_T^2 + v_0^2} \\implies \\frac{s_f}{v_T} = \\frac{v_0}{\\sqrt{v_T^2 + v_0^2}} $$\n现在我们可以通过对下降过程的速度-时间关系从 $s=0$ 到 $s=s_f$ 进行积分来求得 $t_{down}$：\n$$ \\frac{ds}{dt} = g \\left(1 - \\frac{s^2}{v_T^2}\\right) \\implies \\int_{0}^{t_{down}} dt = \\frac{1}{g} \\int_{0}^{s_f} \\frac{ds}{1 - s^2/v_T^2} $$\n我们使用换元法 $u = s/v_T$，所以 $ds = v_T du$。\n$$ t_{down} = \\frac{v_T}{g} \\int_{0}^{s_f/v_T} \\frac{du}{1-u^2} $$\n这个积分是标准形式：$\\int \\frac{du}{1-u^2} = \\arctanh(u)$。\n$$ t_{down} = \\frac{v_T}{g} [\\arctanh(u)]_0^{s_f/v_T} = \\frac{v_T}{g} \\arctanh\\left(\\frac{s_f}{v_T}\\right) $$\n代入 $s_f/v_T$ 的表达式：\n$$ t_{down} = \\frac{v_T}{g} \\arctanh\\left(\\frac{v_0}{\\sqrt{v_T^2 + v_0^2}}\\right) $$\n我们可以使用恒等式 $\\arctanh(x/\\sqrt{1+x^2}) = \\arcsinh(x)$ 来简化这个表达式。令 $x=v_0/v_T$。那么 $x/\\sqrt{1+x^2} = (v_0/v_T) / \\sqrt{1+(v_0/v_T)^2} = (v_0/v_T) / (\\sqrt{v_T^2+v_0^2}/v_T) = v_0/\\sqrt{v_T^2+v_0^2}$。\n所以，这个恒等式可以直接应用。\n$$ t_{down} = \\frac{v_T}{g} \\arcsinh\\left(\\frac{v_0}{v_T}\\right) $$\n最后，我们计算比率 $t_{down}/t_{up}$：\n$$ \\frac{t_{down}}{t_{up}} = \\frac{\\frac{v_T}{g} \\arcsinh\\left(\\frac{v_0}{v_T}\\right)}{\\frac{v_T}{g} \\arctan\\left(\\frac{v_0}{v_T}\\right)} = \\frac{\\arcsinh\\left(\\frac{v_0}{v_T}\\right)}{\\arctan\\left(\\frac{v_0}{v_T}\\right)} $$\n这就是我们得到的比率的最终表达式。", "answer": "$$\\boxed{\\frac{\\arcsinh\\left(\\frac{v_0}{v_T}\\right)}{\\arctan\\left(\\frac{v_0}{v_T}\\right)}}$$", "id": "2210039"}, {"introduction": "许多真实的物理问题由于其复杂性而无法用解析方法（即纸和笔）求解。本章的最后一个练习将带你进入计算物理的领域，解决一个带有二次空气阻力的完整二维抛体运动问题。你将学习并实现一种强大的数值技术——“打靶法”（shooting method），它将一个看似困难的边值问题转化为一个更易于处理的求根问题。通过完成这个练习，你将获得解决复杂物理系统建模的宝贵实践经验，这也是现代科学家和工程师解决实际问题的常用方法。[@problem_id:2430429]", "problem": "一个质量为 $m$ 的二维抛射体以初速度 $v_0$ 从原点发射，发射角 $\\theta$ 是与水平方向的夹角。抛射体在匀定重力加速度 $\\mathbf{g} = (0,-g)$ 下运动，并受到一个二次空气动力阻力，该阻力与速度的平方成正比，方向与瞬时速度相反。使用牛顿第二定律对阻力建模如下。设状态为 $\\mathbf{r}(t) = (x(t),y(t))$ 和 $\\mathbf{v}(t) = (v_x(t),v_y(t))$，其中 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。运动方程为\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\n初始条件为\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\n阻力参数 $k$ 定义为\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\n其中 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A$ 是横截面积。\n\n你的任务是编写一个完整、可运行的程序，对于每个目标点 $(x_T,y_T)$，使用一个求根算法来确定所有能使抛射体在高度 $y = y_T$ 处通过垂直线 $x = x_T$ 的发射角 $\\theta \\in (0,\\tfrac{\\pi}{2})$（严格介于水平和垂直之间）。求根过程必须应用于一个根据第一性原理构建的、关于发射角的标量函数，具体如下。\n\n1. 对于给定的 $\\theta$，定义标量函数\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\n其中 $t^\\star(\\theta)$ 是以速度 $v_0$ 和角度 $\\theta$ 发射的飞行过程中 $x\\big(t^\\star(\\theta)\\big) = x_T$ 的第一个时刻（如果存在）。如果抛射体从未到达 $x_T$（例如，在 $x$ 到达 $x_T$ 之前就以 $y=0$ 落地），则 $F(\\theta)$ 未定义，该 $\\theta$ 不应用于求根的区间括号对。\n\n2. 一个有效的解角 $\\theta^\\star$ 满足 $F(\\theta^\\star) = 0$。你的程序必须系统地搜索区间 $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$（其中 $\\theta_{\\min} = 0.1^\\circ$ 且 $\\theta_{\\max} = 89.9^\\circ$）来检测 $F(\\theta)$ 符号发生改变的子区间，然后对每个检测到的子区间应用一个一维求根算法（例如，区间法）来收敛到一个根。\n\n3. 如果存在多个不同的根，则必须找到并报告 $(0^\\circ,90^\\circ)$ 内的所有这些角度。如果不存在根，则为该情况报告一个空列表。\n\n数值要求和约定：\n\n- 使用上述微分方程和初始条件作为唯一的物理模型；不要代入任何闭合形式的轨迹公式。\n- 实现一个数值常微分方程（ODE）积分器，当 $x(t)$ 首次等于 $x_T$（如果发生）或抛射体在下降时击中地面 $y(t)=0$ 时停止。使用足够紧的公差以可靠地检测穿越。\n- 距离单位必须是米，时间单位是秒，质量单位是千克，空气密度单位是千克/立方米，面积单位是平方米，加速度单位是米/平方秒。角度必须以度为单位报告。\n- 以度为单位报告每个解角，并四舍五入到三位小数。\n- 如果在穿越时刻 $t^\\star$，$|y(t^\\star) - y_T|$ 的值在 $10^{-3}$ 米以内，则该解角是可接受的。你的求根公差应确保达到这个目标精度。\n- 为了可复现性，对所有测试用例使用以下固定的物理参数：$m = 0.145$ 千克，$\\rho = 1.225$ 千克/立方米，$C_d = 0.47$，$A = 0.0042$ 平方米，以及 $g = 9.81$ 米/平方秒。\n\n覆盖不同情况的测试套件：\n\n- 情况1（理想路径，地面目标，预期有两个解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (80.0, 0.0)$ 米。\n- 情况2（高处目标，通常有一或两个解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (60.0, 10.0)$ 米。\n- 情况3（短射程，预期有两个解）：$v_0 = 30.0$ 米/秒，$(x_T,y_T) = (30.0, 0.0)$ 米。\n- 情况4（超出最大射程，预期无解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (200.0, 0.0)$ 米。\n\n程序输入和输出规范：\n\n- 没有外部输入。使用上述确切的常量和测试套件。\n- 你的程序应产生单行输出，其中包含四个情况的结果，格式为用方括号括起来的逗号分隔列表。每个情况的结果必须是一个以度为单位的解角列表，按升序排序并四舍五入到三位小数。如果某个情况没有解，则为该情况输出一个空列表。\n- 例如，要求的整体输出格式类似于 $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$，其中数值条目以十进制形式显示，没有额外的文本。\n\n你的程序必须是完整且可直接运行的，并且必须使用应用于上述定义的 $F(\\theta)$ 的求根算法来为每种情况定位解角。角度必须以度为单位报告。", "solution": "所提出的问题是计算物理学中一个定义明确且标准的练习。它具有科学依据，数学上一致，并且提供了求解所需的所有参数。该物理模型基于牛顿第二定律和二次空气阻力，是在粘性介质中抛射体运动的典型表示。其数值任务是找到使抛射体穿过特定目标点的发射角，这构成一个边值问题。规定的求解方法——打靶法结合标量函数的求根算法——是解决此类问题的一种稳健且适当的技术。因此，该问题是有效的，我们将继续提供一个完整的解决方案。\n\n问题的核心是求解一个耦合一阶常微分方程（ODEs）组。设系统在时间 $t$ 的状态由向量 $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$ 描述。运动方程可以写成 $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$ 的形式，其中函数 $\\mathbf{f}$ 定义为：\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\n$t=0$ 时的初始状态由 $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$ 给出。参数 $\\theta$ 是发射角，这是我们必须确定的。\n\n对于这个系统，轨迹 $\\mathbf{r}(t)$ 的直接解析解不存在。我们必须采用数值方法。问题要求我们找到使轨迹穿过目标点 $(x_T, y_T)$ 的 $\\theta$ 值。这是一个边值问题。我们将使用“打靶法”来解决它，该方法将边值问题转化为一个求根问题。\n\n打靶法的步骤如下：\n1.  我们选择一个试探发射角 $\\theta$。这完全确定了初始条件 $\\mathbf{S}(0)$。\n2.  我们从 $t=0$ 开始随时间向前对 ODE 系统进行数值积分。这个过程即为“打靶”发射抛射体。\n3.  我们监控轨迹以找到抛射体的水平位置 $x(t)$ 首次等于目标水平位置 $x_T$ 的时间 $t^\\star$。\n4.  在这个时间 $t^\\star$，我们计算抛射体的高度 $y(t^\\star)$。\n5.  我们定义一个标量目标函数 $F(\\theta)$，作为抛射体在 $x=x_T$ 处的高度与目标高度 $y_T$ 之间的差值：\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    一个解角 $\\theta^\\star$ 是使 $F(\\theta^\\star) = 0$ 的角。因此，问题简化为寻找函数 $F(\\theta)$ 的根。\n\n为了实现这个方法，我们需要一个稳健的 ODE 积分器。SciPy 库中的 `solve_ivp` 函数是完成此任务的出色工具。`solve_ivp` 的一个关键特性是它能够检测“事件”——即状态和时间的某个函数变为零的条件。我们将利用此特性来精确确定穿越时间 $t^\\star$，而无需积分到固定的最大时间然后进行插值。\n\n我们定义两个终止事件函数：\n1.  `event_reach_x_target(t, S)`：此函数返回 $x(t) - x_T$。当此值为零时，积分器将停止，表示抛射体已到达目标的横坐标。\n2.  `event_hit_ground(t, S)`：此函数返回 $y(t)$。我们配置它仅在 $y(t)$ 减小（即抛射体正在下落）时触发，这表明抛射体在到达 $x=x_T$ 之前已击中地面。\n\n函数 $F(\\theta)$ 是通过为给定的 $\\theta$ 调用 ODE 求解器来构建的。如果积分被 `event_reach_x_target` 事件终止，我们计算并返回 $y(t^\\star) - y_T$。如果积分被 `event_hit_ground` 事件终止，或者在未触发任何事件的情况下达到最大模拟时间，这意味着轨迹射程不足。在这种情况下，对于区间限定的目的，$F(\\theta)$ 函数被认为是未定义的，我们可以返回一个非数值（如 `NaN`，Not a Number）来表示这一点。\n\n要在指定区间 $\\theta \\in [0.1^\\circ, 89.9^\\circ]$ 内找到 $F(\\theta)=0$ 的所有根，我们采用一个两阶段过程：\n1.  **区间搜索**：我们首先将搜索区间离散化为一个精细的角度网格。我们评估网格上每个点的 $F(\\theta)$。通过搜索函数符号改变的相邻网格点 $(\\theta_i, \\theta_{i+1})$（即 $F(\\theta_i) \\cdot F(\\theta_{i+1})  0$），根据介值定理，我们确定了保证至少包含一个根的子区间。正确处理 `NaN` 情况非常重要，因为一个有效的区间要求两端都有定义的数值。\n2.  **求解**：对于找到的每个区间 $[\\theta_a, \\theta_b]$，我们应用一个数值求根算法。在 `scipy.optimize.brentq` 中实现的 Brent 方法是一个非常有效的选择。它结合了二分法的保证收敛性与割线法的更快收敛速度，并且是当已知包含根的区间时进行一维求根的标准方法。求根器的公差将被设定，以确保角度和最终目标高度都达到所需精度。\n\n这种包含数值积分、事件检测、区间搜索和求根的系统性流程将被应用于每个测试用例，以找到所有有效的发射角。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}