{"hands_on_practices": [{"introduction": "维格纳-赛兹原胞不仅是一个优美的几何构造，它首先是一个原胞，因此占据了晶格中每个格点所分配的体积。这项练习将通过一个基础但至关重要的计算来巩固这一核心概念。你将通过体心立方（BCC）晶格的常规晶胞来确定其维格纳-赛兹原胞的体积，从而将抽象的定义与晶格中格点密度的物理现实联系起来 [@problem_id:1823129]。", "problem": "在固态物理学中，晶体结构可以用不同类型的晶胞来描述。体心立方 (BCC) 晶格的常规晶胞是一个边长为 $a$ 的立方体。该晶胞的八个顶点各有一个格点，并在其几何中心处有一个格点。\n\n另一种更基本的描述方法是使用原胞，它是在通过所有晶格矢量进行平移时，能够无重叠、无空隙地填满整个空间的最小体积单元。维格纳-赛兹原胞是原胞的一种标准选择。它被定义为：给定一个格点，其周围空间中离该格点比离任何其他格点都更近的区域。\n\n给定一个由边长为 $a$ 的常规立方晶胞描述的 BCC 晶格，计算其维格纳-赛兹原胞的体积。用包含 $a$ 的符号表达式来表示你的答案。", "solution": "一个原胞的体积等于每个格点所占的体积。对于任何一个体积为 $V_{c}$ 且包含 $N$ 个格点的常规晶胞，其原胞体积为\n$$\nV_{p}=\\frac{V_{c}}{N}.\n$$\n对于边长为 $a$ 的 BCC 常规立方晶胞，其体积为\n$$\nV_{c}=a^{3}.\n$$\n该常规晶胞内的格点数为\n$$\nN=8\\times \\frac{1}{8}+1=2,\n$$\n因为八个顶点上的格点每个贡献 $\\frac{1}{8}$，体心处的格点贡献 $1$。维格纳-赛兹原胞是一种原胞，所以其体积等于 $V_{p}$。因此，\n$$\nV_{\\text{WS}}=V_{p}=\\frac{a^{3}}{2}.\n$$", "answer": "$$\\boxed{\\frac{a^{3}}{2}}$$", "id": "1823129"}, {"introduction": "掌握了体积的概念后，下一步是亲手构建维格纳-赛兹原胞的精确几何形状。这项二维练习提供了一个理想的平台，让你可以从第一性原理出发，应用垂直平分面法来推导中心矩形晶格的维格纳-赛兹原胞。通过这个过程，你将清晰地看到不同近邻格点间的“竞争”如何决定原胞的最终形态，并理解为何其形状会依赖于晶格参数 [@problem_id:3020949]。", "problem": "考虑一个二维中心矩形布拉维晶格，其常规晶胞的边长为 $a$ 和 $b$，与笛卡尔坐标轴对齐，并且每个常规矩形的中心有一个额外的晶格点。该布拉维晶格的一组有效的原胞基矢是 $\\mathbf{u} = \\left(\\frac{a}{2}, \\frac{b}{2}\\right)$ 和 $\\mathbf{v} = \\left(\\frac{a}{2}, -\\frac{b}{2}\\right)$，因此晶格点为 $\\mathbf{R}_{m,n} = m\\,\\mathbf{u} + n\\,\\mathbf{v}$，其中 $m$ 和 $n$ 为整数。位于原点的晶格点的维格纳-赛兹原胞（晶格的沃罗诺伊原胞）定义为平面中所有点 $\\mathbf{r}$ 的集合，这些点到原点的距离小于或等于到任何其他晶格点的距离。\n\n从布拉维晶格和维格纳-赛兹原胞的核心定义出发，使用垂直平分线构造法来：\n- 使用从最近的非零晶格矢量导出的不等式，解释为什么该中心矩形晶格的维格纳-赛兹原胞通常不是一个简单的矩形。\n- 在假设 $a \\geq b$ 的条件下，通过从相关的最近邻矢量确定其顶点的有序坐标，计算维格纳-赛兹原胞的显式多边形形状。从 $x$ 轴上最右边的顶点开始，按逆时针顺序排列顶点。\n\n用一个包含 $a$ 和 $b$ 的单一闭式解析表达式来表示你的最终答案，将六个顶点坐标 $(x_1,y_1),\\dots,(x_6,y_6)$ 的有序列表写在单行中。不需要四舍五入，也不需要单位。", "solution": "该问题要求构造一个二维中心矩形布拉维晶格的维格纳-赛兹原胞并确定其顶点坐标。\n\n### 问题验证\n问题陈述是有效的。它描述了一个标准的物理系统（一个二维布拉维晶格），并要求使用凝聚态物理的既定原理来确定一个明确定义的几何构造（维格纳-赛兹原胞）。所提供的原胞基矢 $\\mathbf{u} = (\\frac{a}{2}, \\frac{b}{2})$ 和 $\\mathbf{v} = (\\frac{a}{2}, -\\frac{b}{2})$ 正确地生成了中心矩形晶格。条件 $a \\geq b$ 是一个有效的约束，确保了最近邻距离的明确排序。任务清晰、客观且可解。\n\n### 解题推导\n\n以原点为中心的维格纳-赛兹原胞是所有点 $\\mathbf{r}=(x, y)$ 的集合，这些点到原点的距离比到任何其他晶格点 $\\mathbf{R}_{m,n} = m\\mathbf{u} + n\\mathbf{v}$ 的距离更近，其中 $m$ 和 $n$ 是不全为零的整数。条件是对于所有非零的 $\\mathbf{R}_{m,n}$，都有 $|\\mathbf{r}| \\leq |\\mathbf{r} - \\mathbf{R}_{m,n}|$。这个不等式等价于 $\\mathbf{r} \\cdot \\mathbf{R}_{m,n} \\leq \\frac{1}{2}|\\mathbf{R}_{m,n}|^2$。维格纳-赛兹原胞的边界是连接原点与最近晶格点的矢量的垂直平分线。\n\n首先，我们必须确定最短的非零晶格矢量 $\\mathbf{R}_{m,n} = (\\frac{a}{2}(m+n), \\frac{b}{2}(m-n))$。其长度的平方是 $|\\mathbf{R}_{m,n}|^2 = \\frac{a^2}{4}(m+n)^2 + \\frac{b^2}{4}(m-n)^2$。\n\n我们来确定最短的矢量：\n1.  对于 $(m,n) = (1,1)$ 或 $(-1,-1)$：$\\mathbf{R} = \\pm(a, 0)$。长度的平方是 $a^2$。\n2.  对于 $(m,n) = (1,-1)$ 或 $(-1,1)$：$\\mathbf{R} = \\pm(0, b)$。长度的平方是 $b^2$。\n3.  对于 $(m,n) = (1,0)$, $(-1,0)$, $(0,1)$, 或 $(0,-1)$：$\\mathbf{R} = (\\pm \\frac{a}{2}, \\pm \\frac{b}{2})$。长度的平方是 $\\frac{a^2}{4} + \\frac{b^2}{4} = \\frac{a^2+b^2}{4}$。\n\n给定 $a \\geq b > 0$，我们比较这些长度的平方：\n-   $b^2 \\leq a^2$。\n-   比较 $\\frac{a^2+b^2}{4}$ 和 $a^2$：$\\frac{a^2+b^2}{4} \\leq a^2 \\iff a^2+b^2 \\leq 4a^2 \\iff b^2 \\leq 3a^2$。因为 $a \\geq b$，所以这个条件总是成立的。\n-   比较 $\\frac{a^2+b^2}{4}$ 和 $b^2$：$\\frac{a^2+b^2}{4} \\leq b^2 \\iff a^2+b^2 \\leq 4b^2 \\iff a^2 \\leq 3b^2$。这个条件在 $a \\leq \\sqrt{3}b$ 时成立。\n\n这个分析表明，定义原胞边界的矢量集合取决于比率 $a/b$。然而，维格纳-赛兹原胞是所有半平面 $\\mathbf{r} \\cdot \\mathbf{R} \\leq \\frac{1}{2}|\\mathbf{R}|^2$ 的交集。原胞的一个边可能由一个不属于绝对最短矢量集合的矢量的平分线形成。\n\n边界线由方程 $\\mathbf{r} \\cdot \\mathbf{R} = \\frac{1}{2}|\\mathbf{R}|^2$ 给出：\n1.  从 $\\mathbf{R} = (\\pm a, 0)$：$\\pm ax = \\frac{1}{2}a^2 \\implies x = \\pm \\frac{a}{2}$。\n2.  从 $\\mathbf{R} = (0, \\pm b)$：$\\pm by = \\frac{1}{2}b^2 \\implies y = \\pm \\frac{b}{2}$。\n3.  从 $\\mathbf{R} = (\\pm \\frac{a}{2}, \\pm \\frac{b}{2})$：对于 $\\mathbf{R} = (\\frac{a}{2}, \\frac{b}{2})$，方程是 $x\\frac{a}{2} + y\\frac{b}{2} = \\frac{1}{2}(\\frac{a^2}{4}+\\frac{b^2}{4}) = \\frac{a^2+b^2}{8}$。这可以简化为 $ax+by = \\frac{a^2+b^2}{4}$。根据对称性，我们有四条这样的线：$ax \\pm by = \\pm\\frac{a^2+b^2}{4}$。\n\n#### 关于非矩形形状的解释\n一个简单的矩形维格纳-赛兹原胞将仅由平面 $x=\\pm a/2$ 和 $y=\\pm b/2$ 定义。这对于简单矩形晶格是成立的。然而，对于中心矩形晶格，我们还必须考虑由中心晶格点施加的约束，这些约束对应于直线 $ax \\pm by = \\pm\\frac{a^2+b^2}{4}$。\n\n我们来检验一下简单矩形的一个角点，例如 $(\\frac{a}{2}, \\frac{b}{2})$，是否满足来自 $\\mathbf{R}=(\\frac{a}{2}, \\frac{b}{2})$ 的平分线的不等式。该不等式为 $ax+by \\leq \\frac{a^2+b^2}{4}$。\n代入该点的坐标：$a(\\frac{a}{2}) + b(\\frac{b}{2}) = \\frac{a^2+b^2}{2}$。\n不等式变为 $\\frac{a^2+b^2}{2} \\leq \\frac{a^2+b^2}{4}$，简化后得到 $2 \\leq 1$。这是错误的。因此，由 $x=\\pm a/2$ 和 $y=\\pm b/2$ 定义的矩形的角被指向常规晶胞中心的矢量的垂直平分线“切掉”了。这种对角的截断导致了一个非简单矩形的多边形形状。对于 $a>b$，它是一个六边形。\n\n#### 六边形原胞顶点的计算\n对于 $a>b$，维格纳-赛兹原胞是一个六边形。它的顶点是与原点和另外两个非共线晶格点等距的点。根据对称性，顶点成组出现。\n六边形的顶点由边界线的交点形成。由于 $a \\geq b$，所以 $b^2 \\leq a^2$，这意味着直线 $y=\\pm b/2$ 形成了边界，而直线 $x=\\pm a/2$ 可能不形成边界。六边形的顶点必须位于条带 $|x| \\le a/2$ 内。任何顶点的最大x坐标将是 $\\frac{a^2+b^2}{4a}$。由于 $\\frac{a^2+b^2}{4a} \\leq \\frac{a}{2}$（因为 $a^2+b^2 \\leq 2a^2 \\iff b^2 \\leq a^2$），原胞总是包含在区域 $|x| \\leq a/2$ 内。因此，对于 $a>b$，直线 $x=\\pm a/2$ 不构成维格纳-赛兹原胞的边界。边界由 $y = \\pm \\frac{b}{2}$ 和 $ax \\pm by = \\pm\\frac{a^2+b^2}{4}$ 形成。\n\n顶点是这些边界线的交点。\n-   **最右侧顶点：** 此顶点位于 $x$ 轴上 $(y=0)$。它与原点以及两个晶格点 $(\\frac{a}{2}, \\frac{b}{2})$ 和 $(\\frac{a}{2}, -\\frac{b}{2})$ 等距。因此，它是直线 $ax+by = \\frac{a^2+b^2}{4}$ 和 $ax-by = \\frac{a^2+b^2}{4}$ 的交点。将这两个方程相加得到 $2ax = \\frac{a^2+b^2}{2}$，从而得出 $x = \\frac{a^2+b^2}{4a}$。该顶点是 $(\\frac{a^2+b^2}{4a}, 0)$。\n\n-   **其他顶点：** 剩余的顶点通过对称性和与其他相关边界线相交来找到。\n    - 第一象限的顶点与原点、$(0,b)$ 和 $(\\frac{a}{2}, \\frac{b}{2})$ 等距。它是平分线 $y=\\frac{b}{2}$ 和 $ax+by = \\frac{a^2+b^2}{4}$ 的交点。将 $y=\\frac{b}{2}$ 代入第二个方程：$ax + b(\\frac{b}{2}) = \\frac{a^2+b^2}{4} \\implies ax = \\frac{a^2-b^2}{4} \\implies x = \\frac{a^2-b^2}{4a}$。该顶点是 $(\\frac{a^2-b^2}{4a}, \\frac{b}{2})$。\n\n六个顶点，从 $x$ 轴上最右边的顶点开始按逆时针顺序排列，分别是：\n\n-   顶点 1：$(\\frac{a^2+b^2}{4a}, 0)$\n-   顶点 2：$ax+by = \\frac{a^2+b^2}{4}$ 和 $y=\\frac{b}{2}$ 的交点，即 $(\\frac{a^2-b^2}{4a}, \\frac{b}{2})$。\n-   顶点 3：与顶点 2 关于 $y$ 轴对称，$(-\\frac{a^2-b^2}{4a}, \\frac{b}{2})$。\n-   顶点 4：与顶点 1 关于原点对称，$(-\\frac{a^2+b^2}{4a}, 0)$。\n-   顶点 5：与顶点 2 关于原点对称，$(-\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$。\n-   顶点 6：与顶点 2 关于 $x$ 轴对称，$(\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$。\n\n坐标的有序列表 $(x_1, y_1), \\dots, (x_6, y_6)$ 是：\n1.  $(\\frac{a^2+b^2}{4a}, 0)$\n2.  $(\\frac{a^2-b^2}{4a}, \\frac{b}{2})$\n3.  $(-\\frac{a^2-b^2}{4a}, \\frac{b}{2})$\n4.  $(-\\frac{a^2+b^2}{4a}, 0)$\n5.  $(-\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$\n6.  $(\\frac{a^2-b^2}{4a}, -\\frac{b}{2})$\n这种六边形形状在 $a>b$ 时有效。在 $a=b$ 的特殊情况下，顶点2和3的坐标变为 $(0, b/2)$，顶点5和6的坐标变为 $(0, -b/2)$。六边形退化为一个顶点在坐标轴上的正方形，这是简单方形晶格的正确维格纳-赛兹原胞。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{a^2+b^2}{4a}  0  \\frac{a^2-b^2}{4a}  \\frac{b}{2}  -\\frac{a^2-b^2}{4a}  \\frac{b}{2}  -\\frac{a^2+b^2}{4a}  0  -\\frac{a^2-b^2}{4a}  -\\frac{b}{2}  \\frac{a^2-b^2}{4a}  -\\frac{b}{2}\n\\end{pmatrix}\n}\n$$", "id": "3020949"}, {"introduction": "在现代凝聚态物理学中，理论概念的价值往往通过其在计算建模中的应用来体现。这项高级练习将引导你从分析推导走向计算实践，解决为三维晶格构建维格纳-赛兹原胞的实际问题。你将设计一个利用晶格点群对称性来优化计算效率的算法，这不仅能加深你对对称性原理的理解，也让你体验到计算物理学家在处理复杂系统时所采用的核心策略 [@problem_id:3020917]。", "problem": "给定一个由三个原胞基矢 $a_1$、$a_2$ 和 $a_3$ 指定的三维布拉维晶格。维格纳-赛兹原胞 (WSC) 定义为点集 $x \\in \\mathbb{R}^3$，其中每个点到原点的距离比到任何其他格点的距离都近。根据基本几何构造，维格纳-赛兹原胞可以写为对每个非零格矢 $R = n_1 a_1 + n_2 a_2 + n_3 a_3$（其中 $n_1$、$n_2$ 和 $n_3$ 为整数）的半空间交集\n$$\n\\{\\, x \\in \\mathbb{R}^3 \\mid x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2 \\,\\}\n$$\n晶格的点群对称性是作用于 $\\mathbb{R}^3$ 的一组旋转 $G$，它将晶格映射到其自身，这意味着对于任何格矢 $R$ 和任何 $g \\in G$，$g R$ 也是一个格矢。如果存在 $g \\in G$ 使得 $R' = g R$，则称两个格矢 $R$ 和 $R'$ 是对称等价的。\n\n您的任务是设计并实现一个完整的、可运行的程序，通过半空间交集来构造给定晶格的维格纳-赛兹原胞，并利用点群对称性，通过将对称等价的格矢分组并通过对称性复制面（半空间）来降低计算成本，同时生成与朴素构造法完全相同的原胞。您的程序必须实现以下两种策略：\n\n- 一种朴素策略，枚举在有界盒子 $[-N,N]^3$ 内具有整数系数 $n_i$ 的所有格矢 $R$，通过径向截断 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 对它们进行筛选，并构造半空间 $x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2$。\n\n- 一种利用对称性的策略，给定截断后相同的候选格矢集，将这些矢量在点群 $G$ 的作用下划分为轨道，为每个轨道选择一个代表，然后通过将所有 $g \\in G$ 应用于这些代表来重构完整的半空间集合，并按容差去重。节省的成本通过轨道代表数与朴素策略中使用的总候选格矢数之比来衡量。\n\n您必须通过求半空间的交集并取所得顶点集的凸包来计算维格纳-赛兹原胞的体积。您必须通过比较每个测试用例中朴素方法和利用对称性方法的体积，并报告它们是否在 $10^{-9}$ 的容差内匹配，来断言利用对称性方法的正确性。\n\n使用以下测试套件，它涵盖了标准的立方布拉维晶格。所有长度均以常规立方晶格常数 $a$ 为单位，所有体积必须以 $a^3$ 为单位报告：\n\n- 测试用例 1（简单立方，SC）：$a_1 = (1,0,0)$，$a_2 = (0,1,0)$，$a_3 = (0,0,1)$，整数边界 $N = 2$，径向截断 $R_{\\text{cut}} = 1.01$。点群 $G$ 是立方体的纯旋转对称群（八面体群），由所有行列式为 $+1$ 且可置换坐标轴并翻转其符号的 $3 \\times 3$ 正交矩阵组成。\n\n- 测试用例 2（体心立方，BCC）：$a_1 = \\tfrac{1}{2} (1,1,-1)$，$a_2 = \\tfrac{1}{2} (1,-1,1)$，$a_3 = \\tfrac{1}{2} (-1,1,1)$，整数边界 $N = 2$，径向截断 $R_{\\text{cut}} = 1.01$。使用相同的点群 $G$。\n\n- 测试用例 3（面心立方，FCC）：$a_1 = \\tfrac{1}{2} (0,1,1)$，$a_2 = \\tfrac{1}{2} (1,0,1)$，$a_3 = \\tfrac{1}{2} (1,1,0)$，整数边界 $N = 2$，径向截断 $R_{\\text{cut}} = 1.01$。使用相同的点群 $G$。\n\n对于每个测试用例 $t$，您的程序必须生成一个列表 $[b_t, v_t, r_t, c_t]$，其中：\n- $b_t$ 是一个布尔值，表示朴素体积和利用对称性体积是否在 $10^{-9}$ 容差内匹配。\n- $v_t$ 是任一方法计算出的维格纳-赛兹原胞体积（它们必须匹配），表示为以 $a^3$ 为单位的浮点数，并四舍五入到 $12$ 位小数。\n- $r_t$ 是一个整数，等于利用对称性方法使用的轨道代表数。\n- $c_t$ 是一个整数，等于朴素方法在应用径向截断和去重后使用的候选格矢数。\n\n您的程序应生成单行输出，包含三个测试用例结果的逗号分隔列表，并用方括号括起来。例如，输出格式必须严格为\n$[ [b_1,v_1,r_1,c_1], [b_2,v_2,r_2,c_2], [b_3,v_3,r_3,c_3] ]$\n逗号和方括号的出现方式必须与所示完全一样。\n\n此问题不涉及角度；无需指定角度单位。所有数值输出必须是无量纲的，体积单位为指定的 $a^3$。程序必须是自包含的，不需要用户输入。\n\n您必须使用的基本假设是以下核心定义和事实：\n- 布拉维晶格是集合 $\\{ n_1 a_1 + n_2 a_2 + n_3 a_3 \\mid n_i \\in \\mathbb{Z} \\}$。\n- 维格纳-赛兹原胞等于晶格关于原点的沃罗诺伊原胞，并且可以通过对所有非零格矢 $R$ 求垂直平分半空间 $x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2$ 的交集来构造。\n- 晶格的点群 $G$ 作用于晶格并保持距离不变，因此它置换维格纳-赛兹原胞的定义半空间。\n- 维格纳-赛兹原胞的体积等于原胞的体积，即 $V_{\\text{prim}} = \\lvert \\det A \\rvert$，其中 $A$ 是一个 $3 \\times 3$ 矩阵，其列为原胞基矢 $a_1$、$a_2$ 和 $a_3$。\n\n您的算法必须推导并证明为什么按点群轨道对格矢进行分组，可以仅计算少量代表面，然后通过对称性生成全套等价面，从而在不改变最终维格纳-赛兹原胞的情况下，减少初始计算量（在轨道代表层面）。", "solution": "用户提供了一个在计算凝聚态物理领域有效、适定且有科学依据的问题。任务是使用两种不同的计算策略——朴素枚举和利用对称性的方法——为几种布拉维晶格构造维格纳-赛兹原胞 (WSC)，并验证两种方法得出相同的结果。\n\n问题的核心在于维格纳-赛兹原胞的几何定义以及应用群论来优化其构造。以布拉维晶格 $\\mathcal{L}$ 的原点为中心的 WSC，是空间中所有点构成的集合，这些点到原点的距离比到任何其他格点 $R \\in \\mathcal{L} \\setminus \\{0\\}$ 的距离都近。这等同于原点的沃罗诺伊原胞。从几何上看，该区域由一系列半空间的交集定义。对于每个非零格矢 $R$，原点和 $R$ 之间的垂直平分面由方程 $x \\cdot R = \\frac{1}{2} \\lVert R \\rVert^2$ 给出。WSC 由所有与原点位于该平面同一侧的点 $x$ 组成，从而得到不等式 $x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2$。因此，WSC 是所有这些半空间的交集：\n$$\nW = \\bigcap_{R \\in \\mathcal{L}\\setminus\\{0\\}} \\{ x \\in \\mathbb{R}^3 \\mid x \\cdot R \\le \\tfrac{1}{2} \\lVert R \\rVert^2 \\}\n$$\n在任何实际计算中，求无限个半空间的交集是不可行的。然而，通常只需要对应于离原点最近的格矢 $R$ 的半空间来定义 WSC 的面。来自更远矢量 $R$ 的半空间是冗余的，因为它们包含了由较近矢量定义的原胞。这证明了仅考虑特定截断半径内（即 $\\lVert R \\rVert \\le R_{\\text{cut}}$）的格矢这一常用计算实践的合理性，这也是“朴素”策略的基础。用于生成格矢 $R = n_1 a_1 + n_2 a_2 + n_3 a_3$ 的整数集 $n_i$ 也被限制在一个盒子内，例如 $n_i \\in [-N, N]$，以确保候选矢量集是有限的。\n\n要展示的主要科学原理是对称性的利用。晶格的点群 $G$ 是所有旋转操作 $g$（由正交矩阵表示）的集合，这些操作使晶格保持不变，即对于任何格矢 $R$，矢量 $gR$ 也是一个格矢。因此，所有格矢的集合 $\\mathcal{L}$ 在 $G$ 的作用下是封闭的。\n\n这种对称性对 WSC 的结构具有深刻的含义。设 $g \\in G$ 是一个对称操作。由于 $g$ 是一个等距变换（一种保距变换），它由一个正交矩阵表示，满足 $(gx) \\cdot (gy) = x \\cdot y$ 和 $\\lVert gx \\rVert = \\lVert x \\rVert$。半空间条件 $x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2$ 在 $g$ 的作用下变换如下：\n令 $x' = gx$ 和 $R' = gR$。$x'$ 位于由 $R'$ 定义的半空间中的条件是 $x' \\cdot R' \\le \\frac{1}{2} \\lVert R' \\rVert^2$。代入变换后的变量，我们得到 $(gx) \\cdot (gR) \\le \\frac{1}{2} \\lVert gR \\rVert^2$。由于正交性，这简化为 $x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2$，这与 $x$ 位于由 $R$ 定义的半空间中的原始条件相同。因此，一个点 $x$ 满足对 $R$ 的半空间条件，当且仅当变换后的点 $gx$ 满足对变换后矢量 $gR$ 的半空间条件。我们可以将其表述为 $g(\\{x \\mid x \\cdot R \\le \\frac{1}{2} \\lVert R \\rVert^2\\}) = \\{y \\mid y \\cdot gR \\le \\frac{1}{2} \\lVert gR \\rVert^2\\}$。\n\nWSC 是所有半空间的交集：$W = \\bigcap_{R \\in \\mathcal{L}\\setminus\\{0\\}} H_R$，其中 $H_R$ 是矢量 $R$ 对应的半空间。对原胞应用群操作 $g$ 得到 $gW = g(\\bigcap_R H_R) = \\bigcap_R (gH_R) = \\bigcap_R H_{gR}$。由于格矢集合 $\\{R\\}$ 在 $G$ 下是不变的，集合 $\\{gR \\mid R \\in \\mathcal{L}\\setminus\\{0\\}\\}$ 与 $\\mathcal{L}\\setminus\\{0\\}$ 是相同的。因此，$\\bigcap_R H_{gR} = \\bigcap_{R'} H_{R'} = W$。这证明了维格纳-赛兹原胞在晶格点群的所有操作下都是不变的 ($gW = W$)。\n\n候选格矢的集合（那些满足 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 的矢量）可以在点群 $G$ 的作用下被划分为不相交的轨道。矢量 $R_i$ 的轨道是集合 $\\mathcal{O}_i = \\{g R_i \\mid g \\in G\\}$。定义 WSC 的所有半空间的集合同样可以根据这些轨道进行划分。利用对称性的策略通过以下方式利用这一点：\n1. 从每个轨道中选择一个代表矢量。\n2. 对于每个代表 $R_i$，生成相应的对称等价半空间的完整集合 $\\{H_{gR_i} \\mid g \\in G\\}$。\n3. 将所有唯一轨道上的这些半空间集合取并集，即可重构出与朴素方法中使用的集合完全相同的相关半空间完整集合。\n\n其优势在于计算效率。我们只需识别唯一的轨道，而无需单独处理每个候选矢量。这些轨道的数量通常远小于候选矢量的总数。对于具有高度对称性的立方晶格，这种减少是显著的。\n\n算法流程如下：\n1. 对于每个测试用例（SC、BCC、FCC），定义原胞基矢 $a_1, a_2, a_3$。\n2. 生成纯八面体群 $O$ 的 24 个旋转矩阵。\n3. 对于整数 $n_i \\in [-N, N]$，生成一个初始的格矢集合 $R = n_1a_1 + n_2a_2 + n_3a_3$。\n4. 筛选这些矢量，仅保留范数 $\\lVert R \\rVert \\le R_{\\text{cut}}$ 的唯一矢量。这就构成了 $c_t$ 个候选矢量的集合。\n5. **朴素方法**：直接使用这 $c_t$ 个候选矢量来定义 $c_t$ 个形式为 $R \\cdot x - \\frac{1}{2} \\lVert R \\rVert^2 \\le 0$ 的半空间。计算这些半空间的交集以找到 WSC 的顶点，然后计算所得凸多面体的体积。\n6. **利用对称性的方法**：\n    a. 将 $c_t$ 个候选矢量在群 $G$ 的作用下划分为轨道。轨道的数量为 $r_t$。\n    b. 从这 $r_t$ 个轨道中，每个轨道选择一个代表矢量。\n    c. 将所有 24 个群操作应用于这 $r_t$ 个代表，以生成一个完整的法向量集合。去重后，该集合将与原始的 $c_t$ 个候选矢量集合相同。\n    d. 根据这个重新生成的集合构造半空间，并像朴素方法一样计算体积。\n7. 验证两种方法得到的体积在 $10^{-9}$ 的容差内一致。WSC 的体积也必须与原胞的理论体积 $V_{\\text{prim}} = |\\det(a_1, a_2, a_3)|$ 一致，对于 SC 是 $1a^3$，对于 BCC 是 $0.5a^3$，对于 FCC 是 $0.25a^3$，其中 $a$ 是常规晶格常数。实现中使用 $a=1$。\n8. 报告每个用例的结果 $[b_t, v_t, r_t, c_t]$，其中 $b_t$ 是布尔匹配状态， $v_t$ 是计算出的体积， $r_t$ 是轨道代表数， $c_t$ 是候选矢量的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import HalfspaceIntersection, ConvexHull\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the Wigner-Seitz cell construction for all test cases.\n    \"\"\"\n\n    def get_octahedral_group():\n        \"\"\"\n        Generates the 24 rotation matrices for the proper octahedral group O.\n        These are the rotational symmetries of a cube.\n        \"\"\"\n        matrices = set()\n        # Permutations of axes\n        for p in itertools.permutations([0, 1, 2]):\n            # Sign flips (even number of negative signs)\n            for signs in itertools.product([-1, 1], repeat=3):\n                if np.prod(signs) == 1:\n                    matrix = np.zeros((3, 3))\n                    matrix[0, p[0]] = signs[0]\n                    matrix[1, p[1]] = signs[1]\n                    matrix[2, p[2]] = signs[2]\n                    # Check determinant just in case (should be sgn(p) * prod(signs))\n                    # but our logic for group O_h is simpler: for any permutation\n                    # and any sign flip, the result is in O_h. For O we need det=+1.\n                    # The combination of permutation and sign flips can be tricky.\n                    # A robust way is to permute columns of I and apply sign flips\n                    # such that det = +1.\n                    # e.g., sgn(p)*prod(s) = 1\n        \n        # A simpler, more direct generation method\n        for p in itertools.permutations([0, 1, 2]):\n            p_matrix = np.eye(3)[:, list(p)]\n            p_sign = np.linalg.det(p_matrix)\n            for signs in itertools.product([-1, 1], repeat=3):\n                s_matrix = np.diag(signs)\n                s_sign = np.prod(signs)\n                if p_sign * s_sign > 0:\n                    matrices.add(tuple((s_matrix @ p_matrix).flatten()))\n\n        # Convert back to list of 3x3 arrays\n        group = [np.array(m).reshape(3, 3) for m in matrices]\n        return group\n\n    def process_case(a_vectors, N, R_cut, tol=1e-9):\n        \"\"\"\n        Processes a single lattice case to compute WSC properties.\n        \"\"\"\n        group = get_octahedral_group()\n        \n        # 1. Generate lattice vectors\n        R_vectors_list = []\n        n_range = range(-N, N + 1)\n        for n1, n2, n3 in itertools.product(n_range, repeat=3):\n            if n1 == 0 and n2 == 0 and n3 == 0:\n                continue\n            R = n1 * a_vectors[0] + n2 * a_vectors[1] + n3 * a_vectors[2]\n            R_vectors_list.append(R)\n\n        # 2. Deduplicate and filter by cutoff\n        unique_vectors_tuples = set()\n        for v in R_vectors_list:\n            # Round to deal with float inaccuracies before adding to set\n            unique_vectors_tuples.add(tuple(np.round(v, int(-np.log10(tol)))))\n\n        candidate_vectors_raw = [np.array(t) for t in unique_vectors_tuples]\n        \n        candidate_vectors = []\n        for R in candidate_vectors_raw:\n            if np.linalg.norm(R) <= R_cut:\n                candidate_vectors.append(R)\n        \n        c_t = len(candidate_vectors)\n\n        # Function to compute volume from a list of vectors\n        def compute_volume_from_vectors(vectors):\n            if not vectors:\n                return 0.0\n            # Define half-spaces: R.x = 0.5 * ||R||^2 -> R.x - 0.5 * ||R||^2 = 0\n            # scipy format: A.x + b = 0, so b is -offset.\n            # Here, scipy wants Ax = b, so A_i is R_i and b_i is 0.5*||R_i||^2\n            halfspaces = []\n            for R in vectors:\n                norm_sq = np.dot(R, R)\n                # Normal vector must point inwards for scipy's HalfspaceIntersection\n                # But ConvexHull works on vertices, which is more robust\n                # halfspaces format for HalfspaceIntersection: [n_x, n_y, n_z, -d]\n                # for plane n.x=d.我们的平面是 R.x = 0.5||R||^2\n                # half-space是 R.x = 0.5||R||^2\n                halfspaces.append(np.append(R, -0.5 * norm_sq))\n            \n            # The origin is always an interior point for the WSC\n            interior_point = np.array([0.0, 0.0, 0.0])\n            \n            try:\n                # HalfspaceIntersection expects Ax + b = 0.\n                # Our R.x = 0.5*norm_sq is R.x - 0.5*norm_sq = 0.\n                # So A_i = R_i and b_i = -0.5*norm_sq.\n                hs = HalfspaceIntersection(np.array(halfspaces), interior_point)\n                vertices = hs.intersections\n                if len(vertices) < 4: return 0.0\n                hull = ConvexHull(vertices)\n                return hull.volume\n            except Exception:\n                return -1.0 # Error indicator\n\n        # 3. Naive method\n        vol_naive = compute_volume_from_vectors(candidate_vectors)\n\n        # 4. Symmetry-exploiting method\n        # Partition into orbits\n        unclassified_vectors = {tuple(np.round(v, int(-np.log10(tol)))) for v in candidate_vectors}\n        representatives = []\n        \n        while unclassified_vectors:\n            rep_tuple = unclassified_vectors.pop()\n            rep_vec = np.array(rep_tuple)\n            representatives.append(rep_vec)\n            \n            orbit_tuples = set()\n            for g in group:\n                transformed_vec = g @ rep_vec\n                orbit_tuples.add(tuple(np.round(transformed_vec, int(-np.log10(tol)))))\n            \n            unclassified_vectors -= orbit_tuples\n            \n        r_t = len(representatives)\n\n        # Reconstruct half-spaces\n        reconstructed_vectors_set = set()\n        for rep in representatives:\n            for g in group:\n                transformed_vec = g @ rep\n                reconstructed_vectors_set.add(tuple(np.round(transformed_vec, int(-np.log10(tol)))))\n        \n        reconstructed_vectors = [np.array(v) for v in reconstructed_vectors_set]\n        \n        vol_symm = compute_volume_from_vectors(reconstructed_vectors)\n\n        # 5. Compare and format results\n        b_t = np.isclose(vol_naive, vol_symm, atol=1e-9)\n        v_t = round(vol_symm, 12)\n        \n        return [b_t, v_t, r_t, c_t]\n\n    test_cases = [\n        # Case 1: Simple Cubic (SC)\n        {'a_vectors': [np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]), np.array([0.0, 0.0, 1.0])], 'N': 2, 'R_cut': 1.01},\n        # Case 2: Body-Centered Cubic (BCC)\n        {'a_vectors': [0.5 * np.array([1.0, 1.0, -1.0]), 0.5 * np.array([1.0, -1.0, 1.0]), 0.5 * np.array([-1.0, 1.0, 1.0])], 'N': 2, 'R_cut': 1.01},\n        # Case 3: Face-Centered Cubic (FCC)\n        {'a_vectors': [0.5 * np.array([0.0, 1.0, 1.0]), 0.5 * np.array([1.0, 0.0, 1.0]), 0.5 * np.array([1.0, 1.0, 0.0])], 'N': 2, 'R_cut': 1.01},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['a_vectors'], case['N'], case['R_cut'])\n        all_results.append(result)\n    \n    # Format the final output string exactly as specified.\n    output_parts = []\n    for res in all_results:\n        b_str = str(res[0]).lower()\n        v_str = f\"{res[1]:.12f}\"\n        r_str = str(res[2])\n        c_str = str(res[3])\n        output_parts.append(f\"[{b_str},{v_str},{r_str},{c_str}]\")\n    \n    # Final print statement must produce a single line.\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "3020917"}]}