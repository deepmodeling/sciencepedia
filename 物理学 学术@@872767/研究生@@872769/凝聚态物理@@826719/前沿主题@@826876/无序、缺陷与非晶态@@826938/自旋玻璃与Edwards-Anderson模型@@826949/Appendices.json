{"hands_on_practices": [{"introduction": "“阻挫” (frustration) 是理解自旋玻璃物理的核心概念。它描述了系统由于存在相互竞争的相互作用，而无法同时满足所有键合能量最低的状态。本练习将让你超越对阻挫的定性描述，通过计算来量化它。你将基于随机耦合的统计分布，亲手计算一个基本格方 (plaquette) 中出现阻挫的概率，这项实践能帮助你从微观层面具体理解无序是如何催生出自旋玻璃标志性的复杂能量景貌的。", "problem": "考虑 Edwards-Anderson 伊辛自旋玻璃，其定义在一个规则格点上，哈密顿量为 $H=-\\sum_{\\langle i j\\rangle} J_{i j} S_{i} S_{j}$，其中伊辛自旋 $S_{i}\\in\\{-1,+1\\}$，最近邻耦合 $J_{i j}$ 为淬火的。一个圈（例如，一个基本格框）被称为阻挫的，当且仅当沿着该圈的耦合 $J_{i j}$ 的乘积为负。设耦合是独立同分布的，遵循双峰定律 $J_{i j}\\in\\{+J,-J\\}$，其中 $\\mathbb{P}(J_{i j}=-J)=p$ 和 $\\mathbb{P}(J_{i j}=+J)=1-p$，且 $J0$。\n\n- 仅使用上述基本定义，计算当 $p=1/2$ 时，方形格点上的一个基本方形格框是阻挫的概率。\n- 然后，将您的结果推广到任意 $z$-正则图（每个顶点的配位数为 $z$）上长度为 $\\ell$ 的简单圈，将阻挫概率表示为 $\\ell$ 和 $p$ 的闭合形式函数。\n\n请以一个依赖于 $\\ell$ 和 $p$ 的单一闭合形式表达式给出您的最终答案，该表达式在 $\\ell=4$ 和 $p=1/2$ 时应简化为您计算的方形格框的值。不需要进行数值计算，也不涉及任何单位。最终答案中不要陈述任何不等式。", "solution": "用户希望我解决一个关于 Edwards-Anderson 自旋玻璃模型中阻挫的问题。\n\n问题验证如下：\n- **第一步：提取已知条件**\n    - 哈密顿量：$H=-\\sum_{\\langle i j\\rangle} J_{i j} S_{i} S_{j}$\n    - 自旋：$S_{i}\\in\\{-1,+1\\}$\n    - 耦合：$J_{i j}$ 是淬火的、独立同分布 (i.i.d.) 的最近邻耦合。\n    - 耦合分布：$J_{i j}$ 遵循双峰分布，$J_{i j}\\in\\{+J,-J\\}$，其中 $J0$。\n    - 耦合概率：$\\mathbb{P}(J_{i j}=-J)=p$ 和 $\\mathbb{P}(J_{i j}=+J)=1-p$。\n    - 阻挫的定义：一个圈是阻挫的，如果沿着该圈的耦合 $J_{i j}$ 的乘积为负。\n    - 任务1：计算当 $p=1/2$ 时，方形格点上的基本方形格框（$\\ell=4$）的阻挫概率。\n    - 任务2：将结果推广到任意 $z$-正则图上长度为 $\\ell$ 的简单圈，将概率表示为 $\\ell$ 和 $p$ 的函数。\n    - 任务3：最终答案必须是依赖于 $\\ell$ 和 $p$ 的单一闭合形式表达式。\n\n- **第二步：使用提取的已知条件进行验证**\n    - 该问题具有科学依据，因为它涉及自旋玻璃理论中的标准概念（Edwards-Anderson 模型、阻挫、双峰无序）。\n    - 该问题是适定的。定义清晰，概率设置完整，可以得到唯一解。关于图是“$z$-正则”的信息是辅助背景；计算仅取决于特定圈的属性（其长度），所有必要信息均已提供。\n    - 该问题是客观的，并使用了精确的科学语言。\n    - 该问题未违反任何无效标准。它是统计物理学中一个标准的、可形式化的问题。\n\n- **第三步：结论与行动**\n    - 问题有效。将提供解答。\n\n问题要求计算格点中的一个圈是阻挫的概率。一个圈被定义为阻挫的，如果沿着其键的淬火随机耦合 $J_{ij}$ 的乘积为负。设该圈为长度为 $\\ell$ 的简单圈，其耦合为 $J_1, J_2, \\dots, J_\\ell$。阻挫的条件是：\n$$ \\prod_{i=1}^{\\ell} J_i  0 $$\n耦合 $J_i$ 是从双峰分布中抽取的独立同分布随机变量：$J_i = +J$ 的概率为 $1-p$，$J_i = -J$ 的概率为 $p$，其中 $J0$。\n\n乘积 $\\prod_{i=1}^{\\ell} J_i$ 的符号由集合 $\\{J_1, \\dots, J_\\ell\\}$ 中负耦合（即值为 $-J$ 的耦合）的数量决定。设圈中有 $k$ 个负耦合。该乘积可以写为：\n$$ \\prod_{i=1}^{\\ell} J_i = (-1)^k J^{\\ell} $$\n由于 $J0$，$J^{\\ell}$ 总是正的。因此，阻挫条件 $\\prod_{i=1}^{\\ell} J_i  0$ 等价于 $(-1)^k = -1$，这意味着负耦合的数量 $k$ 必须是奇数。\n\n我们需要计算 $k$ 为奇数的概率。由于 $\\ell$ 个耦合是独立的，负耦合的数量 $k$ 服从二项分布，参数为 $n=\\ell$（试验次数，即圈中的键数）和 $p$（成功概率，即耦合为负的概率）。其概率质量函数由下式给出：\n$$ \\mathbb{P}(k) = \\binom{\\ell}{k} p^k (1-p)^{\\ell-k} $$\n阻挫概率 $P_{\\text{frust}}$ 是所有可能的奇数 $k$ 值的概率之和：\n$$ P_{\\text{frust}}(\\ell, p) = \\sum_{j=0}^{\\lfloor (\\ell-1)/2 \\rfloor} \\mathbb{P}(k=2j+1) = \\sum_{j=0}^{\\lfloor (\\ell-1)/2 \\rfloor} \\binom{\\ell}{2j+1} p^{2j+1} (1-p)^{\\ell-(2j+1)} $$\n为了找到这个和的闭合形式表达式，我们使用一种涉及二项式定理的标准技巧。考虑 $(a+b)^\\ell$ 和 $(a-b)^\\ell$ 的展开式：\n$$ (a+b)^\\ell = \\sum_{k=0}^{\\ell} \\binom{\\ell}{k} b^k a^{\\ell-k} $$\n$$ (a-b)^\\ell = \\sum_{k=0}^{\\ell} \\binom{\\ell}{k} (-b)^k a^{\\ell-k} = \\sum_{k=0}^{\\ell} (-1)^k \\binom{\\ell}{k} b^k a^{\\ell-k} $$\n从第一个方程中减去第二个方程：\n$$ (a+b)^\\ell - (a-b)^\\ell = \\sum_{k=0}^{\\ell} \\binom{\\ell}{k}b^k a^{\\ell-k}(1 - (-1)^k) $$\n如果 $k$ 是奇数，项 $(1 - (-1)^k)$ 等于 $2$；如果 $k$ 是偶数，则等于 $0$。因此，该和只包括 $k$ 为奇数的项：\n$$ (a+b)^\\ell - (a-b)^\\ell = 2 \\sum_{k \\text{ is odd}} \\binom{\\ell}{k} b^k a^{\\ell-k} $$\n现在，我们设 $a = 1-p$ 和 $b=p$。右侧的和正好就是阻挫概率 $P_{\\text{frust}}(\\ell, p)$：\n$$ ((1-p)+p)^\\ell - ((1-p)-p)^\\ell = 2 \\sum_{k \\text{ is odd}} \\binom{\\ell}{k} p^k (1-p)^{\\ell-k} = 2 P_{\\text{frust}}(\\ell, p) $$\n简化左侧：\n$$ 1^\\ell - (1-2p)^\\ell = 2 P_{\\text{frust}}(\\ell, p) $$\n$$ 1 - (1-2p)^\\ell = 2 P_{\\text{frust}}(\\ell, p) $$\n解出 $P_{\\text{frust}}(\\ell, p)$，我们得到长度为 $\\ell$ 的圈的阻挫概率的一般闭合形式表达式：\n$$ P_{\\text{frust}}(\\ell, p) = \\frac{1}{2} \\left(1 - (1 - 2p)^{\\ell}\\right) $$\n该表达式仅取决于圈的长度 $\\ell$ 和负键的概率 $p$。只要圈是明确定义的，图的配位数 $z$ 就无关紧要。\n\n问题的第一部分要求计算方形格点上基本方形格框在 $p=1/2$ 时的特定情况。方形格框是长度为 $\\ell=4$ 的圈。将 $\\ell=4$ 和 $p=1/2$ 代入我们的一般公式：\n$$ P_{\\text{frust}}(4, 1/2) = \\frac{1}{2} \\left(1 - \\left(1 - 2\\left(\\frac{1}{2}\\right)\\right)^{4}\\right) $$\n$$ P_{\\text{frust}}(4, 1/2) = \\frac{1}{2} \\left(1 - (1 - 1)^{4}\\right) = \\frac{1}{2} \\left(1 - 0^{4}\\right) = \\frac{1}{2} (1 - 0) = \\frac{1}{2} $$\n所要求的最终答案是推广此结果的单一闭合形式表达式。", "answer": "$$\n\\boxed{\\frac{1}{2} \\left(1 - (1 - 2p)^{\\ell}\\right)}\n$$", "id": "3016871"}, {"introduction": "正如我们在上一个练习 ([@problem_id:3016871]) 中所见，Edwards-Anderson模型的核心在于随机的相互作用耦合。这一特性引出了一种深刻的内禀对称性，即局域 $\\mathbb{Z}_{2}$ 规范不变性，它对系统的物理可观测量有着至关重要的影响。这个练习是理解自旋玻璃与传统磁性系统（如铁磁体）根本区别的关键。通过亲手证明哈密顿量的不变性并检验不同物理量的变换行为，你将明白为何总磁化强度不是一个好的序参量，以及为何我们需要像Edwards-Anderson交叠这样更复杂的规范不变量来描述自旋玻璃相。", "problem": "考虑一个 Edwards-Anderson 自旋玻璃模型 (Edwards-Anderson)，其伊辛自旋 $S_i \\in \\{-1,+1\\}$ 定义在一个包含 $N$ 个格点和 $M$ 条边的有限无向图上。其哈密顿量为\n$$\nH[\\{S\\}\\,|\\,\\{J\\}] \\equiv - \\sum_{\\langle i j \\rangle} J_{i j}\\, S_i S_j,\n$$\n其中，耦合常数 $J_{i j} = J_{j i}$ 是淬火随机变量，从一个在 $J_{i j} \\to - J_{i j}$ 变换下对称且支撑在有限区间上的键分布中独立抽取。定义一个与格点相关的变换，其中 $\\epsilon_i \\in \\{-1,+1\\}$ 的作用如下\n$$\nS_i \\to S_i' \\equiv \\epsilon_i S_i, \\qquad J_{i j} \\to J_{i j}' \\equiv \\epsilon_i \\epsilon_j J_{i j}.\n$$\n从哈密顿量、逆温为 $\\beta$ 时的玻尔兹曼权重 $\\exp(-\\beta H)$ 以及配分函数\n$$\nZ[\\{J\\}] \\equiv \\sum_{\\{S\\}} \\exp\\!\\big(-\\beta H[\\{S\\}\\,|\\,\\{J\\}]\\big),\n$$\n的基本定义出发，完成以下任务：\n\n- 明确证明对于任意 $\\{\\epsilon_i\\}$ 的选择，变换后的哈密顿量 $H[\\{S'\\}\\,|\\,\\{J'\\}]$ 等于 $H[\\{S\\}\\,|\\,\\{J\\}]$，并通过适当的求和变量替换推导出 $Z[\\{J'\\}] = Z[\\{J\\}]$。\n\n- 仅使用上述变换规则，不引入任何无根据的简化方法，确定以下可观测量如何变换：磁化强度 $m \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i$，键能量密度 $e_b \\equiv -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j$，以及双副本重叠（Edwards-Anderson 序参量候选者）$q \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)}$，其中上标表示在相同淬火无序 $\\{J\\}$ 下演化的两个独立热副本。\n\n- 推导任何可写为单个单项式\n$$\n\\mathcal{O}(\\{S\\},\\{J\\}) = \\prod_{i=1}^{N} S_i^{a_i} \\prod_{\\langle i j \\rangle} J_{i j}^{b_{i j}},\n$$\n的可观测量的规范不变性的一般选择定则，其中 $a_i$ 和 $b_{i j}$ 为非负整数，该定则用每个格点上指数的奇偶性约束来表示。\n\n你的推导必须从上面提供的定义开始，并清楚地论证每一步。作为最终答案，请给出规范不变的 Edwards-Anderson 序参量的明确解析表达式，用 $N$ 和 2 个副本的自旋变量表示。不需要进行数值计算，也不涉及单位。", "solution": "本问题旨在分析 Edwards-Anderson 自旋玻璃模型的局域规范对称性。分析分为三个部分：证明哈密顿量和配分函数的不变性，确定特定物理可观测量的变换性质，以及推导单项式可观测量规范不变性的一般选择定则。\n\n### 第一部分：哈密顿量和配分函数的不变性\n\nEdwards-Anderson 模型的哈密顿量由下式给出\n$$\nH[\\{S\\}\\,|\\,\\{J\\}] \\equiv - \\sum_{\\langle i j \\rangle} J_{i j}\\, S_i S_j\n$$\n其中 $\\{S\\}$ 表示伊辛自旋 $S_i \\in \\{-1,+1\\}$ 的一种构型，$\\{J\\}$ 是淬火随机耦合 $J_{ij}$ 的一个实现。求和遍及图的所有边 $\\langle ij \\rangle$。\n\n局域规范变换由一组与格点相关的变量 $\\epsilon_i \\in \\{-1,+1\\}$ 定义，它们对自旋和耦合的作用如下：\n$$\nS_i \\to S_i' \\equiv \\epsilon_i S_i\n$$\n$$\nJ_{i j} \\to J_{i j}' \\equiv \\epsilon_i \\epsilon_j J_{i j}\n$$\n\n首先，我们证明哈密顿量的解析表达式在此变换下是不变的。我们将变换后的变量 $S_i'$ 和 $J_{ij}'$ 代入哈密顿量的定义表达式中：\n$$\nH[\\{S'\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} J_{i j}'\\, S_i' S_j'\n$$\n代入变换规则，我们得到：\n$$\nH[\\{S'\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, (\\epsilon_i S_i) (\\epsilon_j S_j)\n$$\n重新整理各项并利用对任意格点 $k$ 都有 $\\epsilon_k^2 = 1$ 的性质：\n$$\nH[\\{S'\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} (\\epsilon_i^2 \\epsilon_j^2) J_{i j}\\, S_i S_j = - \\sum_{\\langle i j \\rangle} (1 \\cdot 1) J_{i j}\\, S_i S_j = - \\sum_{\\langle i j \\rangle} J_{i j}\\, S_i S_j\n$$\n这与原始的哈密顿量表达式 $H[\\{S\\}\\,|\\,\\{J\\}]$ 完全相同。因此，我们证明了 $H[\\{S'\\}\\,|\\,\\{J'\\}] = H[\\{S\\}\\,|\\,\\{J\\}]$。\n\n接下来，我们推导配分函数 $Z[\\{J\\}]$ 的不变性。对于一个耦合为 $\\{J'\\}$ 的系统，其配分函数定义为：\n$$\nZ[\\{J'\\}] \\equiv \\sum_{\\{S\\}} \\exp\\!\\big(-\\beta H[\\{S\\}\\,|\\,\\{J'\\}]\\big)\n$$\n求和遍及所有 $2^N$ 种自旋构型 $\\{S\\}$。指数中的哈密顿量是使用自旋变量 $\\{S\\}$ 和变换后的耦合 $\\{J'\\}$ 计算的：\n$$\nH[\\{S\\}\\,|\\,\\{J'\\}] = - \\sum_{\\langle i j \\rangle} J'_{i j}\\, S_i S_j = - \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, S_i S_j\n$$\n将此代入 $Z[\\{J'\\}]$ 的表达式中：\n$$\nZ[\\{J'\\}] = \\sum_{\\{S\\}} \\exp\\left( \\beta \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, S_i S_j \\right)\n$$\n我们现在对自旋构型的求和进行变量替换。让我们定义一组新的自旋变量 $\\{S'\\}$，使得 $S_i' = \\epsilon_i S_i$。由于 $\\epsilon_i^2 = 1$，其逆变换为 $S_i = \\epsilon_i S_i'$。这个变换是所有自旋构型集合到其自身的一个一一映射。因此，对所有 $\\{S\\}$ 求和等价于对所有 $\\{S'\\}$ 求和。\n将 $S_i = \\epsilon_i S_i'$ 代入 $Z[\\{J'\\}]$ 的表达式中得到：\n$$\nZ[\\{J'\\}] = \\sum_{\\{S'\\}} \\exp\\left( \\beta \\sum_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})\\, (\\epsilon_i S_i') (\\epsilon_j S_j') \\right)\n$$\n化简指数内的各项：\n$$\n(\\epsilon_i \\epsilon_j J_{i j})\\, (\\epsilon_i S_i') (\\epsilon_j S_j') = (\\epsilon_i^2 \\epsilon_j^2) J_{i j} S_i' S_j' = J_{i j} S_i' S_j'\n$$\n$Z[\\{J'\\}]$ 的表达式变为：\n$$\nZ[\\{J'\\}] = \\sum_{\\{S'\\}} \\exp\\left( \\beta \\sum_{\\langle i j \\rangle} J_{i j} S_i' S_j' \\right) = \\sum_{\\{S'\\}} \\exp\\left( -\\beta H[\\{S'\\}\\,|\\,\\{J\\}] \\right)\n$$\n由于 $\\{S'\\}$ 是一个求和哑变量，该表达式恰好是配分函数 $Z[\\{J\\}]$ 的定义。因此，我们证明了 $Z[\\{J'\\}] = Z[\\{J\\}]$。\n\n### 第二部分：可观测量的变换\n\n我们通过将规范变换应用于给定可观测量的定义表达式，来确定它们的变换方式。\n\n1.  **磁化强度, $m$**：\n    磁化强度为 $m \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i$。变换后的可观测量 $m'$ 通过将 $S_i$ 替换为 $S_i' = \\epsilon_i S_i$ 得到：\n    $$\n    m' = \\frac{1}{N} \\sum_{i=1}^{N} S_i' = \\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i S_i\n    $$\n    通常情况下，$m' \\neq m$。磁化强度不是规范不变的。\n\n2.  **键能量密度, $e_b$**：\n    键能量密度为 $e_b \\equiv -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j$。变换后的可观测量 $e_b'$ 为：\n    $$\n    e_b' = -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j}' S_i' S_j'\n    $$\n    在第一部分中，我们已经证明了哈密顿量的表达式是不变的，即 $\\sum_{\\langle i j \\rangle} J_{i j}' S_i' S_j' = \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j$。因此：\n    $$\n    e_b' = -\\frac{1}{M} \\sum_{\\langle i j \\rangle} J_{i j} S_i S_j = e_b\n    $$\n    键能量密度是规范不变的。\n\n3.  **双副本重叠, $q$**：\n    双副本重叠为 $q \\equiv \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)}$。规范变换作用于给定格点 $i$ 的所有物理变量。因此，两个副本的自旋变量变换方式相同：$S_i^{(1)} \\to S_i^{(1)'} \\equiv \\epsilon_i S_i^{(1)}$ 和 $S_i^{(2)} \\to S_i^{(2)'} \\equiv \\epsilon_i S_i^{(2)}$。变换后的可观测量 $q'$ 为：\n    $$\n    q' = \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)'} S_i^{(2)'} = \\frac{1}{N} \\sum_{i=1}^{N} (\\epsilon_i S_i^{(1)}) (\\epsilon_i S_i^{(2)})\n    $$\n    使用 $\\epsilon_i^2=1$：\n    $$\n    q' = \\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2 S_i^{(1)} S_i^{(2)} = \\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)} = q\n    $$\n    双副本重叠是规范不变的。\n\n### 第三部分：规范不变性的一般选择定则\n\n我们考虑一个形如下式的一般单项式可观测量：\n$$\n\\mathcal{O}(\\{S\\},\\{J\\}) = \\prod_{i=1}^{N} S_i^{a_i} \\prod_{\\langle i j \\rangle} J_{i j}^{b_{i j}}\n$$\n其中 $a_i$ 和 $b_{ij}$ 是非负整数。我们寻求使 $\\mathcal{O}$ 规范不变的条件，即 $\\mathcal{O}' = \\mathcal{O}$。变换后的可观测量 $\\mathcal{O}'$ 为：\n$$\n\\mathcal{O}' = \\prod_{i=1}^{N} (S_i')^{a_i} \\prod_{\\langle i j \\rangle} (J_{i j}')^{b_{i j}} = \\prod_{i=1}^{N} (\\epsilon_i S_i)^{a_i} \\prod_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j J_{i j})^{b_{i j}}\n$$\n分离出包含 $\\epsilon_k$ 的因子：\n$$\n\\mathcal{O}' = \\left( \\prod_{i=1}^{N} S_i^{a_i} \\prod_{\\langle i j \\rangle} J_{i j}^{b_{i j}} \\right) \\left( \\prod_{i=1}^{N} \\epsilon_i^{a_i} \\prod_{\\langle i j \\rangle} (\\epsilon_i \\epsilon_j)^{b_{i j}} \\right) = \\mathcal{O} \\left( \\prod_{i=1}^{N} \\epsilon_i^{a_i} \\prod_{\\langle i j \\rangle} \\epsilon_i^{b_{i j}} \\epsilon_j^{b_{i j}} \\right)\n$$\n要使 $\\mathcal{O}'=\\mathcal{O}$，对于任意 $\\{\\epsilon_i\\}$ 的选择，$\\epsilon$ 因子的乘积必须等于 $1$。我们可以通过收集每个格点 $k$ 的指数来重写这个乘积：\n$$\n\\prod_{k=1}^{N} \\epsilon_k^{P_k}\n$$\n对于一个给定的格点 $k$，总指数 $P_k$ 包括来自自旋因子的项 $a_k$，以及来自连接到格点 $k$ 的每条边的贡献。对于每条边 $\\langle k j \\rangle$，因子 $J_{kj}^{b_{kj}}$ 对 $\\epsilon_k$ 的指数贡献了 $b_{kj}$。因此，总指数为：\n$$\nP_k = a_k + \\sum_{j \\in \\mathcal{N}(k)} b_{kj}\n$$\n其中 $\\mathcal{N}(k)$ 是格点 $k$ 的邻居集合。要使乘积 $\\prod_k \\epsilon_k^{P_k}$ 对任意选择的 $\\{\\epsilon_k\\}$ 都等于 $1$，每个指数 $P_k$ 都必须是偶数。这可以通过选择 $\\epsilon_k = -1$ 和所有 $j \\neq k$ 的 $\\epsilon_j = 1$ 来看出，这样就分离出了条件 $(-1)^{P_k} = 1$。\n\n因此，单项式可观测量规范不变的一般选择定则是，对于图中的每个格点 $k$，该格点上自旋的指数与所有连接到该格点的键的指数之和必须是一个偶数：\n$$\na_k + \\sum_{j \\in \\mathcal{N}(k)} b_{kj} \\equiv 0 \\pmod 2 \\quad \\forall k \\in \\{1, \\dots, N\\}\n$$\n双副本重叠 $q$ 是形如 $S_i^{(1)}S_i^{(2)}$ 的单项式之和。这可以看作是更一般化的多副本可观测量的一个特例。对于像 $S_k^{(1)}S_k^{(2)}$ 这样的项，格点 $k$ 上的总自旋指数是 $1+1=2$，所有其他指数都是 $0$。在格点 $k$ 处的条件是 $2+0=2$ (偶数)，在任何其他格点 $i \\neq k$ 处的条件是 $0+0=0$ (偶数)。由于 $q$ 的求和中的每一项本身都是规范不变的，它们的和 $q$ 也是规范不变的，正如在第二部分中所证明的那样。这种结构正是在具有这种局域对称性的系统中，一个良定义的序参量所需要的。\n\n规范不变的 Edwards-Anderson 序参量的明确解析表达式是双副本重叠 $q$，它已被证明是不变的。", "answer": "$$\n\\boxed{\\frac{1}{N} \\sum_{i=1}^{N} S_i^{(1)} S_i^{(2)}}\n$$", "id": "3016817"}, {"introduction": "在理解了阻挫的概念 ([@problem_id:3016871]) 和规范不变性的重要性 ([@problem_id:3016817]) 之后，我们可以将这些知识付诸实践，解决一个重要特例的基态问题。在这个动手编程练习中，你将把“阻挫”这一抽象概念转化为具体的计算任务。你将实现一个算法，它通过识别阻挫格方并求解一个最小权重完美匹配问题，来找出能量最低的畴壁 (domain wall) 构型。这项实践有力地展示了理论物理的洞见如何与计算算法相结合，从而精确地解决非微扰问题，并让你直观地一窥自旋玻璃基态的结构。", "problem": "考虑一个二维的 Edwards-Anderson 自旋玻璃模型，该模型建立在具有自由边界条件的矩形方格晶格上，并具有双峰耦合。设晶格顶点上有 $L \\times M$ 个伊辛自旋，其变量为 $S_i \\in \\{-1,+1\\}$，边上则有最近邻耦合 $J_{ij} \\in \\{-1,+1\\}$。Edwards-Anderson 哈密顿量为 $H = -\\sum_{\\langle i j\\rangle} J_{ij} S_i S_j$，其中求和遍历所有最近邻对。在没有磁场且边界自由的情况下，基态可以通过映射到从对偶晶格导出的平面图上的最小权完美匹配（MWPM）问题来精确计算。本问题的目标是利用阻挫和畴壁的定义，从第一性原理构建该计算过程，并解释对偶平面图上的最小权完美匹配如何得出精确的基态能量。\n\n您必须编写一个完整的程序，该程序为下述每个测试实例，构建相应的平面对偶图，建立与阻挫元胞对应的需求顶点集，分配边权重，并求解相应的最小权完美匹配以获得精确的基态能量。该程序必须是自包含的，且不得读取任何输入。它必须生成单行输出，包含所有测试实例的结果。\n\n推导与方法的基本依据：\n- 使用 Edwards-Anderson 哈密顿量定义 $H = -\\sum_{\\langle i j\\rangle} J_{ij} S_i S_j$。\n- 使用阻挫元胞的定义：对每个基本方面（元胞），计算其四个邻接耦合的乘积；当且仅当该乘积等于 $-1$ 时，元胞是阻挫的。\n- 在对偶晶格上使用宇称论证：未满足边的集合形成一个子图，该子图在阻挫元胞处具有奇数度，在其他地方具有偶数度，这可以表示为连接成对阻挫元胞（以及当阻挫元胞数量为奇数时，可能连接外部面）的路径的并集。\n- 利用以下事实：在 $J_{ij} \\in \\{-1,+1\\}$ 的双峰情况下，对偶图上每条穿过的最近邻边的权重都等于 $1$；因此，对偶网格上的距离是元胞中心之间的曼哈顿距离，而从一个元胞到外部面的距离等于到边界的最小对偶步数加 $1$。\n\n您必须按算法实现以下步骤：\n1. 对每个测试实例，通过计算每个元胞的四个耦合的乘积来计算阻挫元胞集合。用 $N_{\\text{bonds}}$ 表示键的总数，用 $N_{\\text{frust}}$ 表示阻挫元胞的数量。\n2. 如果 $N_{\\text{frust}}$ 为奇数，则包含一个外部面需求顶点，以确保需求顶点的总数为偶数。\n3. 在需求顶点上构建一个完全加权图，其中两个内部元胞之间的权重是它们在元胞网格上坐标之间的曼哈顿距离，一个内部元胞与外部面之间的权重是到任意边界的最小步数加 $1$。\n4. 在这个完全图上求解最小权完美匹配，以获得最小总路径长度 $W$。您的实现必须是精确的；请使用适合小图的方法，例如通过子集上的动态规划来配对顶点以最小化总权重。\n5. 以 $J$ 为单位（其中 $J=1$）计算精确的基态能量，结果为整数。您的程序必须以 $J$ 为单位输出整数能量，不带任何其他单位。能量必须根据上述构造以科学上一致的方式计算。\n\n测试套件：\n对于每种情况，水平耦合由形状为 $L \\times (M-1)$ 的矩阵 $H$ 给出，其中 $H_{r,c}$ 是位于 $(r,c)$ 和 $(r,c+1)$ 的自旋之间的耦合；垂直耦合由形状为 $(L-1) \\times M$ 的矩阵 $V$ 给出，其中 $V_{r,c}$ 是位于 $(r,c)$ 和 $(r+1,c)$ 的自旋之间的耦合。所有条目都在 $\\{-1,+1\\}$ 中。\n\n- 情况 1（小型，一个阻挫元胞）：\n  $L = 2$, $M = 2$,\n  $H = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  -1 \\end{bmatrix}$.\n\n- 情况 2（奇数个阻挫元胞，需要与外部面配对）：\n  $L = 3$, $M = 3$,\n  $H = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\\\ 1  1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  1  -1 \\\\ -1  1  1 \\end{bmatrix}$.\n\n- 情况 3（具有多个阻挫元胞的较大网格）：\n  $L = 4$, $M = 4$,\n  $H = \\begin{bmatrix} 1  -1  1 \\\\ 1  1  -1 \\\\ -1  1  1 \\\\ 1  -1  -1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  -1  1  1 \\\\ 1  1  -1  -1 \\\\ -1  1  1  1 \\end{bmatrix}$.\n\n- 情况 4（具有混合耦合的矩形网格）：\n  $L = 3$, $M = 4$,\n  $H = \\begin{bmatrix} 1  1  -1 \\\\ -1  1  1 \\\\ 1  -1  1 \\end{bmatrix}$,\n  $V = \\begin{bmatrix} 1  -1  1  -1 \\\\ 1  1  -1  1 \\end{bmatrix}$.\n\n答案规范：\n- 对于每种情况，您的程序必须以 $J$ 为单位（其中 $J=1$）输出精确的基态能量，结果为整数。\n- 将四种情况的结果汇总到单行输出中，形式为用方括号括起来的逗号分隔列表，不含空格，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$。\n- 此问题不涉及角度或百分比。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”）。", "solution": "该问题要求计算一个二维 Edwards-Anderson 自旋玻璃模型的基态能量，该模型建立在具有自由边界条件和双峰耦合的矩形晶格上。解决方案基于一个已成熟的方法，即将此特定问题映射到相关图上的最小权完美匹配（MWPM）问题。\n\n该系统由 $L \\times M$ 个伊辛自旋组成，由变量 $S_i \\in \\{-1, +1\\}$ 描述，位于方格晶格的顶点上。相互作用仅限于最近邻，并由耦合 $J_{ij} \\in \\{-1, +1\\}$ 定义。系统的哈密顿量由下式给出\n$$H = -\\sum_{\\langle i j\\rangle} J_{ij} S_i S_j$$\n其中求和遍历所有最近邻对 $\\langle i j\\rangle$。基态对应于使该哈密顿量最小化的自旋构型 $\\{S_i\\}$。\n\n为了找到基态，我们可以分析键能 $\\sigma_{ij} = J_{ij}S_iS_j$。哈密顿量可以重写为 $H = -\\sum \\sigma_{ij}$。如果 $\\sigma_{ij} = +1$，则键 $\\langle ij \\rangle$ 是“满足的”；如果 $\\sigma_{ij} = -1$，则是“未满足的”。当满足的键的数量最大化时，能量被最大化（即 $H$ 被最小化）。设 $N_{\\text{bonds}}$ 为总键数，$N_{\\text{unsat}}$ 为未满足键的数量。能量可以表示为：\n$$E = (N_{\\text{unsat}} \\times (-1) + N_{\\text{sat}} \\times (+1)) \\times (-1) = N_{\\text{sat}} - N_{\\text{unsat}}$$\n由于 $N_{\\text{sat}} = N_{\\text{bonds}} - N_{\\text{unsat}}$，能量变为：\n$$E = (N_{\\text{bonds}} - N_{\\text{unsat}}) - N_{\\text{unsat}} = N_{\\text{bonds}} - 2N_{\\text{unsat}}$$\n因此，最小化能量 $E$ 等价于最小化未满足键的数量 $N_{\\text{unsat}}$。\n\n关键的洞见在于将未满足键的位置与“阻挫”的概念联系起来。一个元胞（晶格的一个基本方格）由其四个角上的自旋以及连接它们的四个键定义。元胞 $p$ 的阻挫由其周围耦合的乘积决定：\n$$P_p = \\prod_{\\langle ij \\rangle \\in \\partial p} J_{ij}$$\n如果 $P_p = -1$，则元胞 $p$ 是阻挫的。对于任意给定的自旋构型 $\\{S_i\\}$，元胞周围的键能乘积为 $\\prod_{\\langle ij \\rangle \\in \\partial p} \\sigma_{ij} = \\prod (J_{ij}S_iS_j) = (\\prod J_{ij})(\\prod S_iS_j)$。由于在元胞边界中每个自旋顶点都是两个键的一部分，因此每个自旋变量在第二个乘积中出现两次，所以 $\\prod S_iS_j = \\prod S_k^2 = 1$。因此，$\\prod \\sigma_{ij} = P_p$。\n如果一个元胞是非阻挫的（$P_p = +1$），它必须被偶数个未满足的键包围。如果它是阻挫的（$P_p = -1$），它必须被奇数个未满足的键包围。\n\n此属性使我们能够在对偶晶格上将问题可视化。对偶晶格的顶点对应于原始晶格中元胞的中心。原始晶格中未满足键的集合在对偶晶格上形成路径和闭环的集合。阻挫元胞是这些路径的端点，因为它们是对偶晶格上唯一可以具有奇数度（入射的未满足键数量为奇数）的顶点。\n\n为了最小化 $N_{\\text{unsat}}$，我们必须找到一种总长度最小的路径构型，将所有阻挫元胞成对连接。这正是一个最小权完美匹配问题。匹配图的顶点是“需求顶点”，由阻挫元胞组成。由于匹配是将顶点两两配对，需求顶点的数量必须是偶数。如果阻挫元胞的数量 $N_{\\text{frust}}$ 是奇数，这意味着其中一条路径必须终止于系统边界。这通过在需求顶点集中添加一个“外部面”顶点来建模。\n\n算法流程如下：\n1.  **识别阻挫元胞**：对于一个给定的 $L \\times M$ 晶格，其水平耦合为 $H$，垂直耦合为 $V$，我们考虑 $(L-1) \\times (M-1)$ 的元胞网格。对于元胞网格坐标为 $(r, c)$（其中 $r \\in [0, L-2]$ 且 $c \\in [0, M-2]$）的每个元胞，我们计算其周围四个键耦合的乘积。如果乘积为 $-1$，则该元胞是阻挫的。我们记录所有阻挫元胞的坐标。\n\n2.  **构建需求顶点**：我们形成一个需求顶点列表。该列表包含所有阻挫元胞的坐标。如果阻挫元胞的数量 $N_{\\text{frust}}$ 为奇数，我们在列表中添加一个虚拟的“外部面”顶点，以确保总数为偶数。\n\n3.  **建立成本矩阵**：我们在需求顶点集上构建一个完全加权图。两个顶点之间边的权重是用未满足键路径连接它们的成本。对于双峰耦合（$J_{ij}=\\pm 1$），此成本就是对偶网格上的路径长度。\n    *   两个内部元胞 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的权重是它们的曼哈顿距离：$w = |r_1 - r_2| + |c_1 - c_2|$。\n    *   一个内部元胞 $(r, c)$ 与外部面顶点之间的权重是到元胞网格边界的最短曼哈顿距离加一。对于一个位于 $(L-1) \\times (M-1)$ 元胞网格上坐标为 $(r, c)$ 的元胞，该权重为 $w = \\min(r, (L-2)-r, c, (M-2)-c) + 1$。\n\n4.  **求解最小权完美匹配**：我们在这个完全图上求解最小权完美匹配问题。对于少量顶点，可以使用基于顶点子集的动态规划算法精确求解。设成本矩阵为 $C$。递归函数 $f(\\text{mask})$ 计算由位掩码表示的顶点子集的最小匹配成本。如果 $i$ 是掩码中索引最小的顶点，则递归关系为：\n    $$f(\\text{mask}) = \\min_{j > i, j \\in \\text{mask}} \\left\\{ C_{ij} + f(\\text{mask} \\setminus \\{i, j\\}) \\right\\}$$\n    匹配的总最小权重 $W$ 是包含所有顶点的初始调用的结果。\n\n5.  **计算基态能量**：从最小权完美匹配得到的最小权重 $W$ 是未满足键的最小可能数量 $N_{\\text{unsat}}^{\\min}$。然后使用前面推导的公式计算基态能量 $E_0$：\n    $$E_0 = 2W - N_{\\text{bonds}}$$\n    其中 $N_{\\text{bonds}} = L(M-1) + (L-1)M$ 是晶格上的总键数。\n\n将此流程应用于每个测试用例，以找到其精确的基态能量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nimport sys\n\n# Set a higher recursion limit for the MWPM solver, although not strictly\n# necessary for the small problem sizes given.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Computes the exact ground-state energy for several 2D Edwards-Anderson\n    spin glass instances using a mapping to a minimum-weight perfect matching problem.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 2, \"M\": 2,\n            \"H\": np.array([[1], [1]]),\n            \"V\": np.array([[1, -1]])\n        },\n        # Case 2\n        {\n            \"L\": 3, \"M\": 3,\n            \"H\": np.array([[1, -1], [-1, 1], [1, 1]]),\n            \"V\": np.array([[1, 1, -1], [-1, 1, 1]])\n        },\n        # Case 3\n        {\n            \"L\": 4, \"M\": 4,\n            \"H\": np.array([[1, -1, 1], [1, 1, -1], [-1, 1, 1], [1, -1, -1]]),\n            \"V\": np.array([[1, -1, 1, 1], [1, 1, -1, -1], [-1, 1, 1, 1]])\n        },\n        # Case 4\n        {\n            \"L\": 3, \"M\": 4,\n            \"H\": np.array([[1, 1, -1], [-1, 1, 1], [1, -1, 1]]),\n            \"V\": np.array([[1, -1, 1, -1], [1, 1, -1, 1]])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, M = case[\"L\"], case[\"M\"]\n        H_couplings, V_couplings = case[\"H\"], case[\"V\"]\n\n        # The number of plaquettes is (L-1) x (M-1)\n        num_plaq_rows, num_plaq_cols = L - 1, M - 1\n\n        frustrated_plaquettes = []\n        if num_plaq_rows > 0 and num_plaq_cols > 0:\n            for r in range(num_plaq_rows):\n                for c in range(num_plaq_cols):\n                    # Bonds for plaquette (r,c) are H(r,c), H(r+1,c), V(r,c), V(r,c+1)\n                    p_prod = (H_couplings[r, c] * H_couplings[r + 1, c] *\n                              V_couplings[r, c] * V_couplings[r, c + 1])\n                    if p_prod == -1:\n                        frustrated_plaquettes.append((r, c))\n\n        demand_nodes = list(frustrated_plaquettes)\n        num_frustrated = len(demand_nodes)\n        \n        # If the number of frustrated plaquettes is odd, add the outer face as a demand node.\n        # We represent the outer face with a special coordinate, e.g., None.\n        outer_face_node = None\n        has_outer_face_node = False\n        if num_frustrated % 2 != 0:\n            demand_nodes.append(outer_face_node)\n            has_outer_face_node = True\n\n        num_demand_nodes = len(demand_nodes)\n        if num_demand_nodes == 0:\n            min_matching_weight = 0\n        else:\n            cost_matrix = np.zeros((num_demand_nodes, num_demand_nodes), dtype=int)\n            for i in range(num_demand_nodes):\n                for j in range(i + 1, num_demand_nodes):\n                    node1 = demand_nodes[i]\n                    node2 = demand_nodes[j]\n                    \n                    is_node1_outer = (node1 is outer_face_node)\n                    is_node2_outer = (node2 is outer_face_node)\n\n                    cost = 0\n                    if is_node1_outer and not is_node2_outer:\n                        # Cost between outer face and an inner plaquette\n                        r, c = node2\n                        cost = min(r, num_plaq_rows - 1 - r, c, num_plaq_cols - 1 - c) + 1\n                    elif not is_node1_outer and is_node2_outer:\n                        # Symmetric case\n                        r, c = node1\n                        cost = min(r, num_plaq_rows - 1 - r, c, num_plaq_cols - 1 - c) + 1\n                    else: # Both are inner plaquettes\n                        r1, c1 = node1\n                        r2, c2 = node2\n                        cost = abs(r1 - r2) + abs(c1 - c2)\n                    \n                    cost_matrix[i, j] = cost_matrix[j, i] = cost\n            \n            # --- Minimum Weight Perfect Matching Solver (DP with memoization) ---\n            memo = {}\n            def solve_mwpm(mask):\n                if mask == 0:\n                    return 0\n                if mask in memo:\n                    return memo[mask]\n\n                min_cost = float('inf')\n                \n                # Find the first vertex `i` in the mask\n                i = 0\n                while not (mask  (1  i)):\n                    i += 1\n                \n                # Pair `i` with every other vertex `j` in the mask\n                for j in range(i + 1, num_demand_nodes):\n                    if mask  (1  j):\n                        new_mask = mask ^ (1  i) ^ (1  j)\n                        current_cost = cost_matrix[i, j] + solve_mwpm(new_mask)\n                        if current_cost  min_cost:\n                            min_cost = current_cost\n                \n                memo[mask] = min_cost\n                return min_cost\n\n            initial_mask = (1  num_demand_nodes) - 1\n            min_matching_weight = solve_mwpm(initial_mask)\n\n        # Calculate total number of bonds\n        num_bonds = L * (M - 1) + (L - 1) * M\n        \n        # Ground state energy E_0 = 2 * N_unsat - N_bonds\n        # where N_unsat_min is the minimum matching weight W.\n        ground_energy = 2 * min_matching_weight - num_bonds\n        results.append(ground_energy)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3016831"}]}