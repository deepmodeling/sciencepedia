{"hands_on_practices": [{"introduction": "一维哈勃模型是理解强关联电子系统的基石。在半满填充和强相互作用极限下，该模型展现了莫特绝缘体行为，其中电荷激发存在能隙，而自旋激发则是无能隙的。这个练习旨在通过计算自旋子速度和电荷能隙的组合，来加深对这种激发模式分离的理解，这是自旋-电荷分离现象的核心体现。通过推导一个无量纲的比值[@problem_id:1199668]，我们不仅能够检验对有效海森堡模型的映射的掌握程度，还能体会到系统在低能下的普适性特征。", "problem": "**标题：一维莫特绝缘体中的自旋子-双占位子动力学**\n\n一维 Hubbard 模型是研究强关联电子系统的基本模型。其哈密顿量为：\n$$ H = -t \\sum_{i=1}^{L} \\sum_{\\sigma=\\uparrow,\\downarrow} (c_{i,\\sigma}^\\dagger c_{i+1,\\sigma} + \\text{h.c.}) + U \\sum_{i=1}^{L} n_{i,\\uparrow} n_{i,\\downarrow} $$\n其中 $c_{i,\\sigma}^\\dagger$ ($c_{i,\\sigma}$) 在格点 $i$ 处产生（湮灭）一个自旋为 $\\sigma$ 的电子，$n_{i,\\sigma} = c_{i,\\sigma}^\\dagger c_{i,\\sigma}$ 是粒子数算符，$t$ 是最近邻跃迁振幅，$U$ 是在位库仑排斥。我们假设晶格间距为 $a$，并使用 $\\hbar=1$ 的单位制。\n\n考虑半填充情况，此时电子数等于格点数。在强耦合极限下，$U \\gg t$，该系统是莫特绝缘体。该状态的特征是存在电荷能隙 $\\Delta_c$（即产生一个电荷激发所需的最小能量），以及称为自旋子的无能隙自旋激发。这种电荷和自旋激发分离且独立的现象是自旋-电荷分离的标志。\n\n这种莫特绝缘体的低能自旋激发可以很好地用自旋-1/2 海森堡反铁磁链的有效哈密顿量来描述。这些自旋子的速度 $v_s$ 可以从这个有效模型中确定。您可以使用一维海森堡模型中已知的自旋子速度结果。\n\n电荷激发涉及创建一个双占位点（双占位子）和一个空位点（空穴子）。产生这样一个双占位子-空穴子对所需的最小能量 $\\Delta_c$ 必须同时考虑在位排斥能 $U$ 和所产生粒子的动能。\n\n在 $U/t \\to \\infty$ 的极限下，计算无量纲量：\n$$ X = \\frac{\\Delta_c v_s}{t^2 a} $$\n给出该量的精确值。", "solution": "1. 在强耦合极限 $U\\gg t$ 下，低能自旋部分映射到交换作用为\n$$J=\\frac{4t^2}{U}\\,. $$\n的自旋‐1/2 海森堡反铁磁链。\n2. 一维海森堡链的精确自旋子速度为\n$$v_s=\\frac{\\pi}{2}\\,J\\,a=\\frac{\\pi}{2}\\,\\frac{4t^2}{U}\\,a=2\\pi\\,\\frac{t^2\\,a}{U}\\,. $$\n3. 在 $U/t\\to\\infty$ 的极限下，电荷能隙主要由在位排斥决定，\n$$\\Delta_c\\to U\\,. $$\n4. 因此，无量纲比值为\n$$\nX=\\frac{\\Delta_c\\,v_s}{t^2\\,a}\n=\\frac{U\\;\\bigl(2\\pi\\,t^2\\,a/U\\bigr)}{t^2\\,a}\n=2\\pi\\,. \n$$", "answer": "$$\\boxed{2\\pi}$$", "id": "1199668"}, {"introduction": "自旋-电荷分离最直接的物理后果体现在系统的谱函数中。当一个电子被注入一维系统时，它不会像费米液体中的准粒子那样保持完整，而是会“分数化”成独立的自旋子和空穴子激发。这个练习将带我们探索在更普适的 Tomonaga-Luttinger 液体理论框架下，这种分数化如何在单粒子谱函数 $A(k, \\omega)$ 中留下独特的印记。通过计算自旋子和空穴子分支的能量差[@problem_id:1199615]，我们可以具体地理解这两种元激发的不同传播速度是如何导致谱权重的分离的。", "problem": "在一维相互作用电子系统中，其低能物理可以用 Tomonaga-Luttinger 液体（TLL）模型来描述。该模型的一个标志是自旋-电荷分离：元激发不再是类电子的准粒子，而是分离的电荷集体模式（空穴子，速度为 $v_c$）和自旋集体模式（自旋子，速度为 $v_s$）。\n\n当一个电子被添加到系统中时，它会分数化为这些基本激发。因此，用于电子添加的单粒子谱函数 $A(k, \\omega)$ 不会呈现出一个尖锐的$\\delta$-函数峰。相反，对于给定的动量 $k$，谱权重会分布在一个连续的能量 $\\omega$ 范围内。\n\n考虑一个费米动量为 $k_F$ 的有自旋 TLL。对于动量 $k$ 大于 $k_F$ 的添加电子，谱函数 $A(k, \\omega)$ 在其 $(\\omega, k)$ 平面上的支撑集边缘处具有幂律奇异性。这些边缘定义了空穴子和自旋子分支的色散关系。鉴于电荷速度大于自旋速度，即 $v_c > v_s$，空穴子分支对应于谱支撑的能量上界，而自旋子分支对应于能量下界。\n\n您的任务是计算在特定动量 $k = \\frac{3}{2} k_F$ 下，空穴子分支（$\\omega_h$）和自旋子分支（$\\omega_s$）之间的能量差 $\\Delta \\omega = \\omega_h(k) - \\omega_s(k)$。请用 $v_c$、$v_s$ 和 $k_F$ 表示您的答案。", "solution": "1. 在有自旋的 TLL 中，对于动量 $kk_F$ 的添加电子，相关的色散关系为\n$$\n\\omega_h(k)=v_c\\,(k-k_F), \n\\quad\n\\omega_s(k)=v_s\\,(k-k_F).\n$$\n2. 能量差为\n$$\n\\Delta\\omega=\\omega_h(k)-\\omega_s(k)\n=(v_c-v_s)\\,(k-k_F).\n$$\n3. 当 $k=\\tfrac32k_F$ 时，有 $k-k_F=\\tfrac12k_F$，所以\n$$\n\\Delta\\omega=(v_c-v_s)\\,\\frac12k_F\n=\\frac12\\,(v_c-v_s)\\,k_F.\n$$", "answer": "$$\\boxed{\\frac12\\,(v_c - v_s)\\,k_F}$$", "id": "1199615"}, {"introduction": "理论分析和谱函数测量为自旋-电荷分离提供了坚实的证据，但数值模拟能够提供一种更直观、更动态的视角。通过模拟一个电子注入量子链后的实时演化过程，我们可以“亲眼看到”电荷和自旋密度是如何以不同的速度分离开来并传播的。这个计算实践[@problem_id:3017411]要求我们利用精确对角化方法来求解一个小尺寸哈勃链的薛定谔方程，从而直接观察和量化自旋与电荷波包的分离。这不仅是一项重要的计算物理技能训练，更是一种加深对多体量子动力学直观理解的有效途径。", "problem": "考虑一个具有开放边界条件的一维 Hubbard 链，该链在 $L$ 个格点的晶格上通过二次量子化进行建模。每个格点包含两种费米子模式，即自旋向上和自旋向下，按模式索引 $m = 2 j + s$ 进行正则排序，其中 $j \\in \\{0, 1, \\dots, L-1\\}$ 标记格点， $s \\in \\{0,1\\}$ 标记自旋，$s=0$ 代表自旋向上，$s=1$ 代表自旋向下。费米子的产生和湮灭算符 $c_m^\\dagger$ 和 $c_m$ 满足正则反对易关系 $\\{c_m, c_n^\\dagger\\} = \\delta_{mn}$ 和 $\\{c_m, c_n\\} = \\{c_m^\\dagger, c_n^\\dagger\\} = 0$。哈密顿量是标准的一维排斥型 Hubbard 模型，\n$$\nH = -t \\sum_{j=0}^{L-2} \\sum_{s=0}^{1} \\left( c_{2j+s}^\\dagger c_{2(j+1)+s} + c_{2(j+1)+s}^\\dagger c_{2j+s} \\right) + U \\sum_{j=0}^{L-1} n_{j\\uparrow} n_{j\\downarrow},\n$$\n其中 $t$ 是最近邻跃迁振幅（设为 $t=1$），$U$ 是在位相互作用强度，且 $n_{j\\uparrow} = c_{2j}^\\dagger c_{2j}$，$n_{j\\downarrow} = c_{2j+1}^\\dagger c_{2j+1}$。单位选取为 $\\hbar = 1$。\n\n要求您模拟在局域电子注入后的幺正时间演化，并通过提取超额电荷密度和自旋密度的空间分离峰值位置来量化自旋-电荷分离。您无需实现完整的演化块十次切分（TEBD）或含时密度矩阵重整化群（DMRG）算法，而是应通过对稀疏哈密顿量进行指数化，在小尺寸链上执行数值精确的时间演化。对于短时间和小型系统，这在概念上与 TEBD 一致。\n\n初始态：准备一个半填充的乘积态 $|\\psi_\\mathrm{init}\\rangle$，每个格点上恰好有一个电子，且自旋交替排列，即偶数格点 $j$ 上为自旋向上，奇数格点 $j$ 上为自旋向下。然后，通过将算符 $c^\\dagger_{2 j_0}$ 作用于 $|\\psi_\\mathrm{init}\\rangle$ 上，在格点 $j_0$ 处注入一个局域的自旋向上电子，并将得到的态 $|\\psi(0)\\rangle$ 归一化。使用固定的时间步长 $\\Delta t$，通过重复应用单步演化 $|\\psi(t+\\Delta t)\\rangle \\approx e^{-i H \\Delta t} |\\psi(t)\\rangle$，将 $|\\psi(0)\\rangle$ 在哈密顿量 $H$ 下演化时间 $T$。在最终时间 $T$ 计算以下局域可观测量：\n- 电荷密度 $n_j(T) = \\langle \\psi(T) | n_{j\\uparrow} + n_{j\\downarrow} | \\psi(T) \\rangle$。\n- z-方向自旋密度 $S^z_j(T) = \\frac{1}{2} \\langle \\psi(T) | n_{j\\uparrow} - n_{j\\downarrow} | \\psi(T) \\rangle$。\n相对于注入前的初始乘积态 $|\\psi_\\mathrm{init}\\rangle$ 定义相应的超额密度：\n$$\n\\Delta n_j(T) = n_j(T) - n_j^\\mathrm{init}, \\quad \\Delta S^z_j(T) = S^z_j(T) - S^{z,\\mathrm{init}}_j.\n$$\n为量化自旋-电荷分离，需确定向右移动的峰值位置。对于 $j  j_0$ 的情况，分别取使 $\\Delta n_j(T)$ 达到最大值的索引 $j$ 和使 $\\Delta S^z_j(T)$ 在正值中达到最大值的索引。如果对于某个可观测量，在右侧没有发现正的超额值，则将其右峰位置定义为 $j_0$。分离度量是这两个峰值位置之差，以晶格格点单位表示：\n$$\n\\Delta x = j^\\ast_\\mathrm{charge}(T) - j^\\ast_\\mathrm{spin}(T).\n$$\n\n使用占据数表象来实现希尔伯特空间，该空间基于 $2L$ 个费米子模式，由 $0$ 到 $2^{2L}-1$ 范围内的整数的位串表示。使用由 $m = 2 j + s$ 指定的正则排序。通过枚举基态并应用源于 Jordan–Wigner 排序的费米子符号规则来构建稀疏哈密顿量。使用数值稳定的稀疏指数作用于向量的方法进行时间演化。根据概率分布 $|\\psi(T)|^2$ 以及数算符在占据数表象中的对角结构来计算密度。\n\n测试套件：\n针对以下三组参数集运行模拟，所有情况均采用跃迁振幅 $t=1$ 和开放边界条件：\n- 情况 A：$L=6$, $U=0$, $T=0.6$, $\\Delta t=0.05$, $j_0=3$。\n- 情况 B：$L=6$, $U=4$, $T=0.6$, $\\Delta t=0.05$, $j_0=3$。\n- 情况 C：$L=6$, $U=8$, $T=0.6$, $\\Delta t=0.05$, $j_0=3$。\n\n您的程序必须输出单行结果，其中包含一个用方括号括起来的、以逗号分隔的三个浮点数列表（例如 $[\\Delta x_A,\\Delta x_B,\\Delta x_C]$），每个浮点数分别对应于相应情况下的分离度量 $\\Delta x$，单位为晶格格点。不允许有任何其他输出。此问题中不涉及角度。以晶格格点单位表示的距离应为纯数（无量纲的晶格位置）。确保数值稳定性，并提供通过标准 Python 浮点数格式化字符串进行四舍五入的结果。", "solution": "用户提供的问题是计算凝聚态物理学中一个提法恰当且有科学依据的练习。它要求模拟一维 Hubbard 模型中的量子动力学，以展示自旋-电荷分离现象。该问题是有效的，因为它是自洽的、客观的，并基于已确立的物理原理。指定的参数和系统尺寸（$L=6$）对于精确对角化方法来说在计算上是可行的。\n\n该解决方案的实现方式是：在占据数表象中表示多体量子系统，将哈密顿量构建为稀疏矩阵，使用矩阵指数函数进行时间演化，最后计算所需的物理可观测量。\n\n### 1. 希尔伯特空间和基矢表示\n该系统由一个包含 $L$ 个格点的晶格组成，每个格点有两个费米子模式，分别对应自旋向上（$s=0$）和自旋向下（$s=1$）。费米子模式的总数为 $2L$。希尔伯特空间是由这 $2L$ 个模式的所有可能占据方式所张成的 Fock 空间。该空间的一个完备基是占据数表象，其中每个基矢态通过指明哪些模式被占据来确定。\n\n对于一个有 $2L$ 个模式的系统，每个基矢态都可以唯一地映射到一个 $2L$ 位的整数，通常称为位掩码（bitmask）。如果模式 $m$ 被占据，该整数的第 $m$ 位就设为 $1$，否则为 $0$。模式索引 $m$ 定义为 $m = 2j + s$，其中 $j \\in \\{0, 1, \\dots, L-1\\}$ 是格点索引。这建立了一个从 $m=0$（格点 $0$，自旋向上）到 $m=2L-1$（格点 $L-1$，自旋向下）的模式正则排序。这个希尔伯特空间的维度是 $2^{2L}$。对于 $L=6$，维度为 $2^{12} = 4096$，这个规模对于直接数值计算是可控的。\n\n### 2. 哈密顿量构建\nHubbard 哈密顿量 $H = H_t + H_U$ 由动能（跃迁）项 $H_t$ 和势能（在位相互作用）项 $H_U$ 组成。\n\n相互作用项为 $H_U = U \\sum_{j=0}^{L-1} n_{j\\uparrow} n_{j\\downarrow}$，其中 $n_{j\\uparrow} = c_{2j}^\\dagger c_{2j}$ 和 $n_{j\\downarrow} = c_{2j+1}^\\dagger c_{2j+1}$ 是数算符。在占据数表象中，数算符是对角的。一个基矢态 $|k\\rangle$（由整数 $k$ 表示）是 $H_U$ 的一个本征态。其对应的本征值是 $U$ 乘以态 $|k\\rangle$ 中双重占据的格点数。因此，$H_U$ 的矩阵表示是对角的，其矩阵元为 $\\langle k | H_U | k \\rangle = U \\sum_{j=0}^{L-1} \\left( (k \\gg 2j) \\ 1 \\right) \\cdot \\left( (k \\gg (2j+1)) \\ 1 \\right)$。\n\n跃迁项为 $H_t = -t \\sum_{j=0}^{L-2} \\sum_{s=0}^{1} \\left( c_{2j+s}^\\dagger c_{2(j+1)+s} + \\text{h.c.} \\right)$。该项是非对角的。像 $c_{m_2}^\\dagger c_{m_1}$ 这样的算符在模式 $m_1$ 中湮灭一个费米子，并在模式 $m_2$ 中产生一个费米子。它将一个模式 $m_1$ 被占据且模式 $m_2$ 为空的基矢态 $|k\\rangle$ 与一个模式 $m_1$ 为空且模式 $m_2$ 被占据的态 $|k'\\rangle$ 连接起来。费米子算符的一个关键方面是 Jordan-Wigner 符号，它源于反对易关系。算符 $c_{m_2}^\\dagger c_{m_1}$ 作用于态 $|k\\rangle$ 时会产生一个符号 $(-1)^P$，其中 $P$ 是 $m_1$ 和 $m_2$ 之间（不包括两端）被占据的模式数量。假设 $m_1  m_2$，该符号由整数 $k$ 在比特位置 $m_1+1$ 和 $m_2-1$ 之间被置为 1 的比特数的奇偶性决定。矩阵元为 $\\langle k' | H_t | k \\rangle = -t \\cdot (-1)^P$。由于哈密顿量是厄米（Hermitian）的，所以 $\\langle k | H_t | k' \\rangle = \\langle k' | H_t | k \\rangle$。\n\n结合这些，我们将完整的哈密顿量 $H$ 构建为一个 $2^{2L} \\times 2^{2L}$ 的稀疏矩阵。\n\n### 3. 初始态和时间演化\n模拟从一个特定的初始态开始。首先，定义一个基准态 $|\\psi_\\mathrm{init}\\rangle$，它是一个半填充的、具有交替自旋模式的乘积态：如果格点索引 $j$ 是偶数，则该格点上有一个自旋向上的电子；如果是奇数，则有一个自旋向下的电子。这对应于我们 Fock 空间中的一个基矢。\n\n用于时间演化的态 $|\\psi(0)\\rangle$ 是通过在格点 $j_0$ 处注入一个自旋向上的电子来创建的。这通过将产生算符 $c_{2j_0}^\\dagger$ 作用于 $|\\psi_\\mathrm{init}\\rangle$ 来实现。由于格点 $j_0$ 上的自旋向上模式初始为空，此操作是良定义的，并产生一个新的、单一基矢的态，该态已经归一化。$|\\psi(0)\\rangle$ 的态矢量表示是一个大小为 $2^{2L}$ 的数组，在与相应位掩码对应的索引处为 $1$，其他位置均为 $0$。\n\n态矢量的时间演化由薛定谔方程决定，即 $|\\psi(t)\\rangle = e^{-iHt} |\\psi(0)\\rangle$（其中 $\\hbar = 1$）。这是通过数值计算得到的。问题指定使用单步传播算子 $e^{-iH\\Delta t}$ 的重复应用，但为了提高数值精度和稳定性，我们通过直接计算完整矩阵指数 $e^{-iHT}$ 对初始态 $|\\psi(0)\\rangle$ 的作用来计算最终态 $|\\psi(T)\\rangle$。`scipy.sparse.linalg.expm_multiply` 函数非常适合此任务，因为它可以在不显式构造稠密矩阵 $e^{-iHT}$ 的情况下计算此作用。\n\n### 4. 可观测量的测量\n在最终时刻 $T$，我们得到态矢量 $|\\psi(T)\\rangle = \\sum_k \\alpha_k |k\\rangle$。一个对角算符 $O$ 的期望值为 $\\langle O \\rangle = \\langle \\psi(T) | O | \\psi(T) \\rangle = \\sum_k |\\alpha_k|^2 \\langle k | O | k \\rangle$。\n电荷密度 $n_j = n_{j\\uparrow} + n_{j\\downarrow}$ 和 z-方向自旋密度 $S^z_j = \\frac{1}{2}(n_{j\\uparrow} - n_{j\\downarrow})$ 在占据数表象中是对角的。它们在时间 $T$ 的期望值是通过对每个基矢态 $|k\\rangle$ 的本征值求和来计算的，并以相应的概率 $|\\alpha_k|^2$ 进行加权。\n\n### 5. 自旋-电荷分离分析\n为了量化自旋-电荷分离，我们首先通过减去初始（注入前）密度来计算超额密度：\n$\\Delta n_j(T) = n_j(T) - n_j^\\mathrm{init}$\n$\\Delta S^z_j(T) = S^z_j(T) - S^{z,\\mathrm{init}}_j$\n\n然后定位这些超额密度在注入点右侧（$j  j_0$）的峰值位置。\n- 对于电荷（$j^\\ast_\\mathrm{charge}$）：如果在 $j  j_0$ 的区域存在任何正的超额电荷 $\\Delta n_j(T)  0$，则峰值是使 $\\Delta n_j(T)$ 最大的索引 $j$。否则，该位置定义为 $j_0$。\n- 对于自旋（$j^\\ast_\\mathrm{spin}$）：如果在 $j  j_0$ 的区域存在任何正的超额自旋 $\\Delta S^z_j(T)  0$，则峰值是在这些正值中使 $\\Delta S^z_j(T)$ 最大的索引 $j$。否则，该位置定义为 $j_0$。\n\n最终的分离度量是这些峰值位置的差值：$\\Delta x = j^\\ast_\\mathrm{charge}(T) - j^\\ast_\\mathrm{spin}(T)$。对所提供的三组参数集中的每一组重复整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import expm_multiply\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: L=6, U=0, t=1, T=0.6, Δt=0.05, j₀=3\n        {'L': 6, 'U': 0, 't': 1, 'T': 0.6, 'dt': 0.05, 'j0': 3},\n        # Case B: L=6, U=4, t=1, T=0.6, Δt=0.05, j₀=3\n        {'L': 6, 'U': 4, 't': 1, 'T': 0.6, 'dt': 0.05, 'j0': 3},\n        # Case C: L=6, U=8, t=1, T=0.6, Δt=0.05, j₀=3\n        {'L': 6, 'U': 8, 't': 1, 'T': 0.6, 'dt': 0.05, 'j0': 3},\n    ]\n\n    results = []\n    for params in test_cases:\n        delta_x = run_simulation(**params)\n        results.append(delta_x)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(L, U, t, T, dt, j0):\n    \"\"\"\n    Performs the simulation for a single set of parameters.\n    \"\"\"\n    num_modes = 2 * L\n    hilbert_dim = 1  num_modes\n\n    # 1. Initial State Preparation\n    # |psi_init>: Alternating spin-up/down product state (half-filling)\n    init_mask = 0\n    for j in range(L):\n        if j % 2 == 0:  # Even site: spin-up\n            init_mask |= (1  (2 * j))\n        else:  # Odd site: spin-down\n            init_mask |= (1  (2 * j + 1))\n\n    # Pre-injection densities for calculating excess densities later\n    n_init = np.ones(L)\n    Sz_init = np.array([0.5 if j % 2 == 0 else -0.5 for j in range(L)])\n\n    # |psi(0)>: Inject one spin-up electron at site j0\n    m_inj = 2 * j0\n    inj_mask = init_mask | (1  m_inj)\n    \n    psi_0 = np.zeros(hilbert_dim, dtype=np.complex128)\n    psi_0[inj_mask] = 1.0\n\n    # 2. Hamiltonian Construction\n    H = lil_matrix((hilbert_dim, hilbert_dim), dtype=float)\n\n    for k in range(hilbert_dim):\n        # On-site interaction term (diagonal)\n        if U != 0:\n            U_term = 0\n            for j in range(L):\n                m_up = 2 * j\n                m_down = 2 * j + 1\n                if ((k >> m_up)  1) and ((k >> m_down)  1):\n                    U_term += U\n            if U_term != 0:\n                H[k, k] = U_term\n\n    # Hopping term (off-diagonal)\n    for j in range(L - 1): # site index\n        for s in range(2): # spin index {0: up, 1: down}\n            m1 = 2 * j + s\n            m2 = 2 * (j + 1) + s\n            \n            for k in range(hilbert_dim):\n                # Check if hop from m1 to m2 is possible in state k\n                if ((k >> m1)  1) and not ((k >> m2)  1):\n                    k_prime = k ^ (1  m1) ^ (1  m2)\n                    \n                    # Jordan-Wigner sign\n                    # Count occupied fermions between m1 and m2\n                    mask = ((1  (m2 - m1 - 1)) - 1)  (m1 + 1)\n                    sub_k = k  mask\n                    parity = bin(sub_k).count('1')\n                    sign = 1 if parity % 2 == 0 else -1\n                    \n                    val = -t * sign\n                    # Since H is built once, fill both symmetric elements\n                    if k  k_prime: # To avoid processing each pair twice\n                        H[k_prime, k] += val\n                        H[k, k_prime] += val\n\n    H_csr = H.tocsr()\n    \n    # 3. Time Evolution\n    num_steps = int(round(T / dt))\n    \n    # Evolve state from t=0 to t=T. expm_multiply can do this in one call\n    # for better accuracy than repeated multiplication.\n    psi_T = expm_multiply(-1j * H_csr, psi_0, start=0, stop=T, num=num_steps + 1)[-1]\n    \n    # 4. Calculate Observables\n    # Pre-calculate observable values for each basis state to vectorize computation\n    n_vals_per_site = np.zeros((L, hilbert_dim), dtype=np.int8)\n    Sz_vals_per_site = np.zeros((L, hilbert_dim), dtype=float)\n\n    for k in range(hilbert_dim):\n        for j in range(L):\n            m_up = 2 * j\n            m_down = 2 * j + 1\n            n_up_k = (k >> m_up)  1\n            n_down_k = (k >> m_down)  1\n            n_vals_per_site[j, k] = n_up_k + n_down_k\n            Sz_vals_per_site[j, k] = 0.5 * (n_up_k - n_down_k)\n            \n    probs = np.abs(psi_T)**2\n    n_T = n_vals_per_site @ probs\n    Sz_T = Sz_vals_per_site @ probs\n    \n    # 5. Excess Densities\n    delta_n = n_T - n_init\n    delta_Sz = Sz_T - Sz_init\n    \n    # 6. Find Peak Positions\n    j_charge_peak = j0\n    j_spin_peak = j0\n    \n    search_indices = np.arange(j0 + 1, L)\n    \n    # Charge peak: find max of delta_n if any value is positive on the right\n    if len(search_indices) > 0:\n        excess_charge_right = delta_n[search_indices]\n        if np.any(excess_charge_right > 0):\n            peak_idx_in_slice = np.argmax(excess_charge_right)\n            j_charge_peak = search_indices[peak_idx_in_slice]\n\n    # Spin peak: find max among positive values of delta_Sz on the right\n    if len(search_indices) > 0:\n        excess_spin_right = delta_Sz[search_indices]\n        positive_spin_mask = excess_spin_right > 0\n        if np.any(positive_spin_mask):\n            positive_spin_values = excess_spin_right[positive_spin_mask]\n            positive_spin_indices = search_indices[positive_spin_mask]\n            peak_idx_in_subset = np.argmax(positive_spin_values)\n            j_spin_peak = positive_spin_indices[peak_idx_in_subset]\n\n    # 7. Separation Measure\n    delta_x = float(j_charge_peak - j_spin_peak)\n    return delta_x\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3017411"}]}