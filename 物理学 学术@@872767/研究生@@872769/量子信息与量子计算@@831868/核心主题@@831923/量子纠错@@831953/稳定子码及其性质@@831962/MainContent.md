## 引言
在[量子计算](@entry_id:142712)的宏伟蓝图中，[量子比特](@entry_id:137928)的脆弱性是实现大规模可靠计算所面临的核心挑战。量子纠错码应运而生，它通过将脆弱的[量子信息](@entry_id:137721)冗余地编码到多比特系统中，为信息抵御环境噪声提供了一道坚固的防线。在众多[量子编码](@entry_id:141173)方案中，[稳定子码](@entry_id:143150)以其优美的[代数结构](@entry_id:137052)和强大的实用性脱颖而出，构成了现代量子纠错理论的基石。然而，其背后深刻的数学原理和复杂的应用机制，往往构成初学者的知识壁垒。

本文旨在系统地揭开[稳定子码](@entry_id:143150)的神秘面纱，为读者构建一个从原理到应用的完整知识体系。我们将通过三个章节的递进式学习，带领读者逐步掌握这一核心工具。
- 在“原理与机制”一章中，我们将建立[稳定子码](@entry_id:143150)的代数形式体系，介绍[辛表示](@entry_id:183193)法这一强大工具，并阐明[错误检测与校正](@entry_id:749079)的底层逻辑。
- 接着，在“应用与[交叉](@entry_id:147634)学科联系”一章中，我们将探讨这些理论在[容错计算](@entry_id:636335)、编码构造以及与凝聚态物理等前沿领域的[交叉](@entry_id:147634)应用，展示其如何催生出[拓扑序](@entry_id:147345)和[分形子](@entry_id:143207)等新奇物理概念。
- 最后，“动手实践”部分将提供精选的计算问题，帮助读者将理论知识转化为解决实际问题的能力。

现在，让我们首先深入其核心，从“原理与机制”开始，探索用于描述[量子态](@entry_id:146142)和错误的全新代数语言。

## 原理与机制

在上一章中，我们介绍了量子纠错的基本概念，即通过将量子信息编码到更大的希尔伯特空间中来防止其受到[退相干](@entry_id:145157)的影响。本章将深入探讨一类功能强大且结构优美的量子纠错码——[稳定子码](@entry_id:143150)（stabilizer codes）。我们将建立一个代数框架，不仅可以系统地描述这些编码，还能清晰地阐明其[错误检测](@entry_id:275069)和校正的机制。这个框架将[多量子比特系统](@entry_id:142942)中的算符、[状态和](@entry_id:193625)错误都转化为一个基于线性代数和群论的简洁语言。

### [稳定子形式体系](@entry_id:146920)：一种用于[量子态](@entry_id:146142)的代数语言

[稳定子形式体系](@entry_id:146920)的核心思想是用一组算符来定义一个[量子态](@entry_id:146142)（或一个[子空间](@entry_id:150286)），而不是直接写出其状态矢量。具体来说，我们寻找那些作用在某个态 $|\psi\rangle$ 上不改变它的算符 $S$，即 $S|\psi\rangle = |\psi\rangle$。这样的算符 $S$ 被称为 $|\psi\rangle$ 的**稳定子（stabilizer）**。

为了构建一个编码空间，我们不能只用一个稳定子，而是需要一组。这组算符必须形成一个特定的[代数结构](@entry_id:137052)。我们考虑的是作用于 $n$ 个[量子比特](@entry_id:137928)上的**[泡利群](@entry_id:136414)（Pauli group）** $\mathcal{P}_n$。这个群由 $n$ 个[量子比特](@entry_id:137928)上[泡利算符](@entry_id:144061) $\{I, X, Y, Z\}$ 的张量积以及相位因子 $\{\pm 1, \pm i\}$ 组成。

一个[稳定子码](@entry_id:143150)的**编码空间（codespace）** $\mathcal{C}$ 是由一个称为**[稳定子群](@entry_id:137216)（stabilizer group）** $\mathcal{S}$ 的[阿贝尔子群](@entry_id:142799)（Abelian subgroup）唯一确定的。这个[子群](@entry_id:146164) $\mathcal{S}$ 是 $\mathcal{P}_n$ 的一个[子群](@entry_id:146164)，其所有元素相互对易，并且不包含 $-I$（其中 $I$ 是 $n$ 比特单位算符）。编码空间 $\mathcal{C}$ 定义为所有[稳定子群](@entry_id:137216)中算符的共同 +1 特征空间：
$$
\mathcal{C} = \{ |\psi\rangle \mid s|\psi\rangle = |\psi\rangle, \forall s \in \mathcal{S} \}
$$
这意味着编码空间中的任何一个态（称为**码字 (codeword)**）都被[稳定子群](@entry_id:137216)中的所有元素所“稳定”。

#### [辛表示](@entry_id:183193)法

为了高效地处理和分析这些多[量子比特](@entry_id:137928)的泡利算符，我们引入一种强大的数学工具——**[辛表示](@entry_id:183193)法（symplectic representation）**。这种方法将一个 $n$ [量子比特](@entry_id:137928)的泡利算符（忽略总体相位）映射到一个长度为 $2n$ 的二进制矢量。

一个 $n$ [量子比特](@entry_id:137928)[泡利算符](@entry_id:144061) $P = P_1 \otimes P_2 \otimes \dots \otimes P_n$ 可以被表示为一个二[进制](@entry_id:634389)矢量 $v = (z_1, z_2, \dots, z_n | x_1, x_2, \dots, x_n)$，通常简写为 $v = (z|x)$。其中，第 $k$ 个[量子比特](@entry_id:137928)上的泡利算符 $P_k$ 决定了比特对 $(z_k, x_k)$ 的值：
- $I \rightarrow (z_k=0, x_k=0)$
- $X \rightarrow (z_k=0, x_k=1)$
- $Z \rightarrow (z_k=1, x_k=0)$
- $Y \rightarrow (z_k=1, x_k=1)$

这个映射的巧妙之处在于，两个[泡利算符](@entry_id:144061)之间的[对易关系](@entry_id:136780)可以通过它们对应的二进制矢量的**辛[内积](@entry_id:158127)（symplectic inner product）**来确定。对于两个矢量 $v_a = (z_a|x_a)$ 和 $v_b = (z_b|x_b)$，它们的辛[内积](@entry_id:158127)定义为：
$$
v_a \odot v_b = z_a \cdot x_b + x_a \cdot z_b \pmod 2
$$
这里的“$\cdot$”是标准的矢量[点积](@entry_id:149019)，所有运算都在模2的意义下进行。辛[内积](@entry_id:158127)的结果揭示了算符的对易性：
- 如果 $v_a \odot v_b = 0$，则算符 $P_a$ 和 $P_b$ 对易 ($P_a P_b = P_b P_a$)。
- 如果 $v_a \odot v_b = 1$，则算符 $P_a$ 和 $P_b$ 反对易 ($P_a P_b = -P_b P_a$)。

例如，考虑一个4[量子比特](@entry_id:137928)系统上的两个泡利算符 $S_1 = Y_1 Z_2 X_3$ 和 $S_2 = X_1 Z_2 Z_4$ [@problem_id:136088]。它们的[辛表示](@entry_id:183193)分别为 $v_1 = (1, 1, 0, 0 | 1, 0, 1, 0)$ 和 $v_2 = (0, 1, 0, 1 | 1, 0, 0, 0)$。计算辛[内积](@entry_id:158127)：
$$
z_1 \cdot x_2 = (1, 1, 0, 0) \cdot (1, 0, 0, 0) = 1
$$
$$
x_1 \cdot z_2 = (1, 0, 1, 0) \cdot (0, 1, 0, 1) = 0
$$
因此，$v_1 \odot v_2 = (1 + 0) \pmod 2 = 1$。这意味着 $S_1$ 和 $S_2$ [反对易](@entry_id:186708)。这个工具是分析[稳定子码](@entry_id:143150)性质的基石。

#### 生成元与编码参数

一个阿贝尔群可以由一个更小的**生成元集合（set of generators）** $\{g_1, g_2, \dots, g_m\}$ 来完整描述。[稳定子群](@entry_id:137216) $\mathcal{S}$ 的任何元素都可以通过这些生成元的乘积得到。为了定义一个唯一的编码空间，这些生成元必须是**相互独立**的，意味着没有任何一个生成元可以由其他生成元的乘积得到（不考虑相位）。

在实践中，我们可能会遇到一个冗余的生成元集合。为了找到独立的生成元数量，我们可以利用[辛表示](@entry_id:183193)法。我们将每个生成元转换为其对应的 $2n$ 位二[进制](@entry_id:634389)矢量，并将这些矢量作为行构成一个矩阵。通过在[有限域](@entry_id:142106) $\mathbb{F}_2$ 上进行高斯消元，我们可以求出这个[矩阵的秩](@entry_id:155507)。这个秩 $m$ 就是独立生成元的数量 [@problem_id:136107]。

独立生成元的数量 $m$ 直接决定了编码的性质。在一个由 $n$ 个[物理量子比特](@entry_id:137570)构成的系统中，如果有 $m$ 个独立的稳定子生成元，那么编码的**逻辑量子比特（logical qubits）**数量 $k$ 由以下关键公式给出：
$$
k = n - m
$$
每个独立的稳定子生成元都会施加一个约束，将[希尔伯特空间](@entry_id:261193)的维度减半。因此，$m$ 个独立生成元将原始的 $2^n$ 维空间约束到了一个 $2^{n-m}$ 维的[子空间](@entry_id:150286)，这个[子空间](@entry_id:150286)正好可以容纳 $k=n-m$ 个逻辑量子比特。例如，在一个 $n=4$ 的系统上，如果给定的一组生成元（可能冗余）经过分析后发现其独立生成元的数量为 $m=3$，那么该编码就编码了 $k = 4 - 3 = 1$ 个[逻辑量子比特](@entry_id:142662) [@problem_id:135992]。

#### 编码空间[投影算符](@entry_id:154142)

从代数定义转向几何图像，我们可以为编码空间 $\mathcal{C}$ 构建一个正交**[投影算符](@entry_id:154142)（projector）**。这个算符可以将任意[量子态](@entry_id:146142)投影到编码空间中。对于一个[稳定子群](@entry_id:137216) $\mathcal{S}$，其对应的[投影算符](@entry_id:154142)为：
$$
P_{\mathcal{C}} = \frac{1}{|\mathcal{S}|} \sum_{s \in \mathcal{S}} s
$$
其中 $|\mathcal{S}|$ 是[稳定子群](@entry_id:137216)的阶（元素的数量）。如果[稳定子群](@entry_id:137216)由 $m$ 个独立的生成元生成，则 $|\mathcal{S}| = 2^m$。

这个投影算符的迹 $\text{Tr}(P_{\mathcal{C}})$ 等于编码空间的维度。利用泡利算符的一个重要性质——任何非单位[泡利算符](@entry_id:144061)的迹都为零（$\text{Tr}(P)=0$ if $P \neq cI$）——我们可以轻松计算这个迹。
$$
\text{Tr}(P_{\mathcal{C}}) = \frac{1}{|\mathcal{S}|} \sum_{s \in \mathcal{S}} \text{Tr}(s) = \frac{1}{|\mathcal{S}|} (\text{Tr}(I) + \sum_{s \in \mathcal{S}, s \neq I} \text{Tr}(s)) = \frac{1}{2^m} (2^n + 0) = 2^{n-m} = 2^k
$$
这再次确认了编码空间的维度是 $2^k$。作为一个具体的例子，考虑一个由 $S_1 = X^{\otimes 4}$ 和 $S_2 = Z^{\otimes 4}$ 生成的 $[[4,2,2]]$ 码 [@problem_id:136073]。这里 $n=4$，有两个独立的生成元（$m=2$），所以[稳定子群](@entry_id:137216) $S = \{I, S_1, S_2, S_1S_2\}$ 的阶为 $|S|=4$。[投影算符](@entry_id:154142)的迹为：
$$
\text{Tr}(P_{\mathcal{C}}) = \frac{1}{4} (\text{Tr}(I) + \text{Tr}(S_1) + \text{Tr}(S_2) + \text{Tr}(S_1 S_2)) = \frac{1}{4} (2^4 + 0 + 0 + 0) = \frac{16}{4} = 4
$$
编码空间的维度是4，这对应于 $k=2$ 个[逻辑量子比特](@entry_id:142662)，与 $k=n-m=4-2=2$ 的公式一致。

### [错误检测与校正](@entry_id:749079)

[稳定子形式体系](@entry_id:146920)最强大的功能在于它提供了一个清晰的[错误检测](@entry_id:275069)和校正框架。

#### [错误检测](@entry_id:275069)机制

假设系统处于一个合法的码字态 $|\psi\rangle \in \mathcal{C}$，此时对于任何稳定子生成元 $S_i$，都有 $S_i|\psi\rangle = |\psi\rangle$。现在，一个错误（可以用一个泡利算符 $E$ 来描述）作用在系统上，使状态变为 $|\psi'\rangle = E|\psi\rangle$。我们如何发现这个错误？

答案是通过测量稳定子生成元的[本征值](@entry_id:154894)。让我们看看测量 $S_i$ 会发生什么：
$$
S_i |\psi'\rangle = S_i E |\psi\rangle
$$
关键在于 $S_i$ 和 $E$ 的对易关系。
- 如果 $S_i$ 与 $E$ 对易 ($S_i E = E S_i$)，则：
  $S_i E |\psi\rangle = E S_i |\psi\rangle = E |\psi\rangle = |\psi'\rangle$。
  测量 $S_i$ 的结果将是 +1，与未发生错误时没有区别。我们称这个错误对于 $S_i$ 是不可见的。
- 如果 $S_i$ 与 $E$ [反对易](@entry_id:186708) ($S_i E = -E S_i$)，则：
  $S_i E |\psi\rangle = -E S_i |\psi\rangle = -E |\psi\rangle = -|\psi'\rangle$。
  测量 $S_i$ 的结果将是 -1。这表明错误后的状态 $|\psi'\rangle$ 成为了 $S_i$ 的一个 -1 [本征态](@entry_id:149904) [@problem_id:1651109]。

这个 -1 的测量结果就像一个警报，告诉我们一个与 $S_i$ 反对易的错误已经发生。

#### 错误伴随式

通过依次测量所有的稳定子生成元 $\{g_1, \dots, g_m\}$，我们会得到一组[本征值](@entry_id:154894) $(\lambda_1, \dots, \lambda_m)$，其中 $\lambda_i \in \{+1, -1\}$。这组测量结果被称为**[错误伴随式](@entry_id:144867)（error syndrome）**。通常，我们将其表示为一个 $m$ 位的二进制矢量 $s = (s_1, \dots, s_m)$，其中 $s_i = 0$ 对应 $\lambda_i = +1$（对易），$s_i = 1$ 对应 $\lambda_i = -1$（[反对易](@entry_id:186708)）。

[错误伴随式](@entry_id:144867) $s$ 完全由错误算符 $E$ 和稳定子生成元 $g_i$ 之间的对易关系决定，与原始的码字态 $|\psi\rangle$ 无关。具体地，$s_i = 1$ 当且仅当 $E$ 与 $g_i$ [反对易](@entry_id:186708)。这可以使用辛[内积](@entry_id:158127)方便地计算：如果 $v_E$ 和 $v_{g_i}$ 分别是 $E$ 和 $g_i$ 的[辛表示](@entry_id:183193)，那么 $s_i = v_E \odot v_{g_i}$。

例如，对于著名的 $[[5,1,3]]$ [完美码](@entry_id:265404)，其稳定子生成元为 $g_1 = XZZXI, g_2 = IXZZX, g_3 = XIXZZ, g_4 = ZXIXZ$（这里省略了张量积符号）。如果发生了一个 $E = X_1 Y_2$ 的错误，我们可以通过计算辛[内积](@entry_id:158127)来确定其4位的伴随式向量 $(m_1, m_2, m_3, m_4)$ [@problem_id:136066]。我们发现 $E$ 与 $g_1, g_2$ 反对易，但与 $g_3, g_4$ 对易，因此[伴随式](@entry_id:144867)为 $(1,1,0,0)$。对于另一个例子，如修改后的 Steane 码上的 $E = Y_1 Z_3$ 错误，也可以通过系统地检查与每个生成元的对易性来计算出[伴随式](@entry_id:144867) [@problem_id:136051]。

#### 从伴随式到校正

错误校正过程就是[错误检测](@entry_id:275069)的逆过程。在测量得到一个非零的错误伴随式后，我们的任务是推断出最有可能发生的是哪个错误 $E$。由于对于一个给定的[稳定子码](@entry_id:143150)，不同的可校正错误会产生不同的错误伴随式，所以[伴随式](@entry_id:144867)就像是错误的“指纹”。

例如，对于 $[[5,1,3]]$ 码，如果我们测量到伴随式为 $s=(1,0,1,0)$，我们可以通过遍历所有可能的单比特[泡利错误](@entry_id:146391)（$X_1, Y_1, Z_1, X_2, \dots, Z_5$）并计算它们各自的伴随式，来寻找匹配项。通过系统地检查，我们会发现只有错误 $E=Z_1$ 能够产生这个特定的[伴随式](@entry_id:144867) [@problem_id:136050]。

一旦我们识别出错误是 $E=Z_1$，校正过程就变得非常简单：只需在系统上再次应用 $E^\dagger$（对于泡利算符，$E^\dagger = E$）。$E^\dagger E |\psi\rangle = I |\psi\rangle = |\psi\rangle$，这样系统就恢复到了原始的编码状态。

需要注意的是，这种唯一对应关系只对“可校正”的错误成立。可能存在多个不同的错误产生相同的伴随式，这种情况称为**简并错误（degenerate errors）**。例如，在 Steane 码中，[单比特错误](@entry_id:165239) $Z_1$ 的伴随式可能与某些特定的双比特错误（如 $Z_2Z_7$, $Z_3Z_6$ 和 $Z_4Z_5$）的[伴随式](@entry_id:144867)完全相同 [@problem_id:136111]。在这种情况下，[纠错](@entry_id:273762)电路会假设发生了权重最低的错误（这里是 $Z_1$）。如果实际发生的错误是高权重的简并错误之一，那么[纠错](@entry_id:273762)操作将会失败，并可能引入一个逻辑错误。

### [稳定子码](@entry_id:143150)的性质与性能

#### 逻辑算符与[编码距离](@entry_id:140606)

[稳定子码](@entry_id:143150)不仅保护了[量子信息](@entry_id:137721)，还为我们提供了一种操作这些信息的方式。**逻辑算符（logical operators）**，如逻辑-X（$\bar{X}$）和逻辑-Z（$\bar{Z}$），是那些作用在编码空间上，扮演着单[量子比特](@entry_id:137928)[泡利门](@entry_id:139600)角色的算符。它们的定义特征是：它们必须与[稳定子群](@entry_id:137216) $\mathcal{S}$ 中的所有算符对易，但它们本身不属于 $\mathcal{S}$。

所有与 $\mathcal{S}$ 对易的泡利算符构成了 $\mathcal{S}$ 在[泡利群](@entry_id:136414) $\mathcal{P}_n$ 中的**[正规化子](@entry_id:145708)（normalizer）**，记为 $N(S)$。$N(S)$ 本身也是一个群，它包含了[稳定子群](@entry_id:137216) $\mathcal{S}$ 和逻辑算符。$N(S)$ 的大小与编码的逻辑量子比特数 $k$ 相关。对于一个 $[[n,k,d]]$ 码，其[正规化子](@entry_id:145708)的大小为 $|N(S)| = 2^{n-k} \cdot 4^{k+1}$。例如，对于 $[[5,1,3]]$ 码，其[稳定子群](@entry_id:137216) $|S|=16$，$k=1$，所以 $|N(S)| = 16 \cdot 4^{1+1} = 256$。若不考虑相位，[正规化子](@entry_id:145708)中逻辑上不等价的算符有 $|N(S)|/|S|/4 = 4^k$ 种，即 $|N(S)| = |S| \cdot 4^k = 16 \cdot 4^1 = 64$ [@problem_id:136054]。对于 $[[4,2,2]]$ 码，$|S|=4$，$k=2$，我们同样可以计算出其[正规化子](@entry_id:145708)大小为 $4 \cdot 4^{2+1} = 256$ [@problem_id:136139]。

一个量子码最重要的性能指标之一是其**[编码距离](@entry_id:140606)（code distance）** $d$。它定义为权重最小的非平凡逻辑算符的权重。一个等价的定义是，距离 $d$ 是指能够将一个码字变为另一个码字或使其与自身正交，但其本身又无法被错误伴随式检测到的最小权重错误的权重。这样的错误算符 $E$ 必须与所有稳定子生成元对易（因此伴随式为零），但又不属于[稳定子群](@entry_id:137216)本身（因此它不是一个平凡操作）。这正是一个逻辑算符的定义。一个距离为 $d$ 的编码可以校正任意权重不超过 $t = \lfloor (d-1)/2 \rfloor$ 的错误。要确定一个码的距离，我们需要找到权重最小的逻辑算符，这通常需要通过巧妙地将一个高权重的逻辑算符与稳定子相乘来降低其权重 [@problem_id:136010]。

#### 编码参数的基本界限

量子纠错码的参数 $[[n,k,d]]$ 并非可以任意组合，它们受到一些基本物理和信息论原理的限制。
其中一个重要的界限是**[量子汉明界](@entry_id:136512)（Quantum Hamming Bound）**。对于一个可以校正最多 $t$ 个错误的非[简并码](@entry_id:271912)，其参数必须满足：
$$
2^k \sum_{j=0}^{t} \binom{n}{j} 3^j \le 2^n
$$
这里的 $\binom{n}{j}$ 是从 $n$ 个[量子比特](@entry_id:137928)中选择 $j$ 个位置的方式数，而 $3^j$ 则代表在每个位置上可能发生的三种[泡利错误](@entry_id:146391)（X, Y, Z）类型。这个不等式本质上说的是，用于区分所有可校正错误状态的空间（左侧）不能超过总的物理[希尔伯特空间](@entry_id:261193)维度（右侧）。我们可以利用这个界限来确定构建特定性能编码所需的最小资源。例如，要构建一个能校正任意单[量子比特](@entry_id:137928)错误（$d=3 \implies t=1$）并编码一个逻辑比特（$k=1$）的码，通过测试不同的 $n$ 值，我们发现满足[量子汉明界](@entry_id:136512)的最小物理比特数是 $n=5$ [@problem_id:136104]。

另一个重要的界限是**[量子辛格尔顿界](@entry_id:141955)（Quantum Singleton Bound）**：
$$
n-k \ge 2(d-1)
$$
能够达到这个界限等号的码被称为**最大距离可分（MDS）码**。

一个非凡的结果是，存在一个唯一的非平凡[稳定子码](@entry_id:143150)，它同时满足[量子汉明界](@entry_id:136512)和[量子辛格尔顿界](@entry_id:141955)的等号，即它既是一个“[完美码](@entry_id:265404)”又是一个[MDS码](@entry_id:272386)。通过联立求解这两个等式，我们可以确定这个特殊的码就是 $[[5,1,3]]$ 码 [@problem_id:168204]，这进一步凸显了五比特码在量子纠错理论中的基础地位。

#### 错误校正的形式化条件

**Knill-Laflamme 条件**为[量子纠错](@entry_id:139596)提供了严格的数学判据。对于一个能校正错误集合 $\{E_a\}$ 的编码空间 $\mathcal{C}$，其投影算符 $P_{\mathcal{C}}$ 必须满足：
$$
P_{\mathcal{C}} E_a^\dagger E_b P_{\mathcal{C}} = c_{ab} P_{\mathcal{C}}
$$
其中 $c_{ab}$ 是一个复数矩阵。对于[稳定子码](@entry_id:143150)，这个条件可以被直观地理解。$E_a^\dagger E_b$ 是一个[泡利算符](@entry_id:144061)。如果它与所有稳定子对易，那么它就是一个逻辑算符（或者稳定子本身），它会将编码空间映射到自身。如果它与某些稳定子反对易，那么它会将编码空间中的任何态映射到与编码空间正交的[子空间](@entry_id:150286)中，此时 $c_{ab}=0$ [@problem_id:136093]。这个条件保证了不同的错误要么将编码空间映射到自身，要么映射到相互正交的“错误[子空间](@entry_id:150286)”，从而使得这些错误可以被区分和校正。

### 重要族群与推广

#### CSS 码

**Calderbank-Shor-Steane (CSS) 码**是一类特别重要的[稳定子码](@entry_id:143150)，它们通过两个经典的二元[线性码](@entry_id:261038) $C_X$ 和 $C_Z$ 构建。构造的前提条件是 $C_Z^\perp \subseteq C_X$，即 $C_Z$ 的对偶码包含于 $C_X$ 中。这保证了X类型和Z类型的稳定子生成元相互对易 [@problem_id:135998]。

- X-型稳定子由 $C_Z$ 的校验矩阵（即 $C_Z^\perp$ 的[生成矩阵](@entry_id:275809)）的行[向量生成](@entry_id:152883)。
- Z-型稳定子由 $C_X$ 的校验矩阵（即 $C_X^\perp$ 的[生成矩阵](@entry_id:275809)）的行向量生成。

如果 $C_X$ 的维度是 $k_X$，$C_Z$ 的维度是 $k_Z$，则[CSS码](@entry_id:143038)编码的逻辑量子比特数为 $k = n - (n-k_X) - (n-k_Z) = k_X + k_Z - n$。如果用 $C_X$ 和 $C_Z$ 的维度（而非其对偶码）表示，则 $k=\dim(C_X) - \dim(C_Z^\perp)$，或者在使用另一种构造方式时，为 $k = n - \dim(C_X) - \dim(C_Z)$ [@problem_id:135998]。

[CSS码](@entry_id:143038)的逻辑算符也有清晰的经典对应关系。例如，逻辑 $\bar{Z}$ 算符对应于形式为 $Z(b)$ 的算符，其中二进制矢量 $b$ 必须属于 $C_X$ 但不属于 $C_Z^\perp$。该逻辑算符的最小权重由 $C_X \setminus C_Z^\perp$ 中码字的最小汉明重量决定 [@problem_id:136062]。

著名的 $[[7,1,3]]$ **Steane 码**就是[CSS码](@entry_id:143038)的一个典型例子，它基于经典的 $[7,4,3]$ [汉明码](@entry_id:276290)构建。通过分析其逻辑[零态](@entry_id:154996) $| \bar{0} \rangle$（即经典[汉明码](@entry_id:276290)所有码字的等幅叠加态），我们可以研究其内蕴的纠缠结构。例如，将一个7比特的 Steane 码逻辑[零态](@entry_id:154996)划分为第一个比特和其余六个比特，其[施密特秩](@entry_id:154893)为2 [@problem_id:136027]，这表明第一个比特与系统的其余部分存在纠缠，这是[量子编码](@entry_id:141173)的典型特征。

#### 超越对易稳定子：高级框架

标准的[稳定子形式体系](@entry_id:146920)要求所有生成元相互对易。然而，通过放宽这一要求，我们可以构建更通用、有时也更具实践优势的编码。

**子系统码 (Subsystem Codes):** 在子系统码中，我们从一组可能互不对易的“检测算符（check operators）”开始，它们生成一个**[规范群](@entry_id:144761)（gauge group）** $G$。真正的[稳定子群](@entry_id:137216) $S$ 被定义为 $G$ 的中心（center），即 $S = Z(G)$。这意味着稳定子是那些与所有规范[群生成元](@entry_id:145790)都对易的元素。逻辑信息被编码在不受任何规范群元素约束的子系统中。这种方法允许使用更简单、权重更低的检测算符。例如，著名的**Bacon-Shor码**就是构建在二维网格上的子系统码，其规范生成元是简单的行X算符和列Z算符。这些行和列算符相互之间可能反对易，但它们的特定乘积（例如，所有偶数行的X算符乘积）可以与所有规范生成元对易，从而形成稳定子 [@problem_id:135977]。这种框架的参数，如编码空间的维度，可以从构成[规范群](@entry_id:144761)的经典码的代数关系中推导出来 [@problem_id:136068]。

**纠缠辅助码 (Entanglement-Assisted Codes, EAQECC):** 另一种推广是允许检测算符反对易，但代价是消耗预先共享的纠缠资源（ebits）。在这种框架下，两个[反对易](@entry_id:186708)的检测算符 $M_i, M_j$ 可以通过消耗一个ebit来转化为有效的对易稳定子。所需ebit的数量 $c$ 取决于检测算符集合的“非对易程度”。具体来说，我们可以构建一个 $s \times s$ 的对易矩阵 $E$（$s$ 是检测算符的数量），其中 $E_{ij}=1$ 如果 $M_i, M_j$ [反对易](@entry_id:186708)，否则为0。所需的ebit数量为 $c = \frac{1}{2}\text{rank}_{\mathbb{F}_2}(E)$。例如，如果我们从一个经典校验矩阵 $H$ 的行向量 $\{h_i\}$ 出发，构建一组检测算符 $\{X(h_i)\} \cup \{Z(h_i)\}$，那么所需的ebit数量可以直接表示为矩阵乘积 $HH^T$ 在 $\mathbb{F}_2$ 上的秩 [@problem_id:136146]。这为设计量子码提供了更大的灵活性，允许使用任意的经典码来构建量子码，而不仅限于满足 $C_Z^\perp \subseteq C_X$ 条件的码。