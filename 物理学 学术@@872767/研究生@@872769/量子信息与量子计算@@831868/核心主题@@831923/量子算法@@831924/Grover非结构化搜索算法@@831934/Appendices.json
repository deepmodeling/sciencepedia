{"hands_on_practices": [{"introduction": "Grover算法的核心威力不仅在于能够“标记”目标态的神谕（oracle），更在于其巧妙的“振幅放大”机制。这一机制的关键是Grover扩散算符，它通过一个称为“平均值反转”的操作来增强目标态的振幅。通过亲手构建这个算符 [@problem_id:1426368] 的矩阵表示，我们可以直观地理解它如何作用于量子态，并为后续分析整个算法的动力学打下坚实的基础。", "problem": "在量子算法的研究中，Grover 算法为搜索无结构数据库提供了显著的加速。该算法的一个关键组成部分是 Grover 扩散算子，通常被描述为“关于平均值的反转”操作。这个用 $G$ 表示的算子，对于放大目标态的振幅至关重要。\n\n考虑一个由 2 个量子比特组成的量子寄存器。该系统的状态可以在一个 4 维希尔伯特空间中描述。Grover 扩散算子 $G$ 由以下表达式定义：\n$$G = 2|s\\rangle\\langle s| - I$$\n其中 $I$ 是单位算子，而 $|s\\rangle$ 是所有计算基态的归一化均匀叠加态。\n\n确定这个 2 量子比特系统的 Grover 扩散算子 $G$ 的矩阵表示。您的表示应在标准计算基中，顺序为 $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$。", "solution": "对于一个 2 量子比特寄存器，希尔伯特空间的维度是 $N=2^{2}=4$。在计算基 $\\{|00\\rangle,|01\\rangle,|10\\rangle,|11\\rangle\\}$ 上的归一化均匀叠加态是\n$$\n|s\\rangle=\\frac{1}{\\sqrt{N}}\\sum_{x\\in\\{00,01,10,11\\}}|x\\rangle=\\frac{1}{2}\\left(|00\\rangle+|01\\rangle+|10\\rangle+|11\\rangle\\right),\n$$\n该叠加态满足 $\\langle s|s\\rangle=1$，因为\n$$\n\\langle s|s\\rangle=\\left(\\frac{1}{2}\\right)^{2}\\sum_{x,y}\\langle x|y\\rangle=\\frac{1}{4}\\cdot 4=1.\n$$\n到 $|s\\rangle$ 上的秩一投影算子是\n$$\n|s\\rangle\\langle s|=\\left(\\frac{1}{2}\\right)^{2}\\sum_{x,y}|x\\rangle\\langle y|=\\frac{1}{4}\\sum_{x,y}|x\\rangle\\langle y|,\n$$\n在有序基 $\\{|00\\rangle,|01\\rangle,|10\\rangle,|11\\rangle\\}$ 中，它是一个每个元素都等于 $\\frac{1}{4}$ 的 $4\\times 4$ 矩阵。因此，\n$$\n2|s\\rangle\\langle s|=\\frac{1}{2}\\begin{pmatrix}\n1  & 1  & 1  & 1\\\\\n1  & 1  & 1  & 1\\\\\n1  & 1  & 1  & 1\\\\\n1  & 1  & 1  & 1\n\\end{pmatrix}.\n$$\n根据定义，Grover 扩散算子是 $G=2|s\\rangle\\langle s|-I$，其中 $I$ 是 $4\\times 4$ 单位矩阵。减去 $I$ 得到\n$$\nG=\\begin{pmatrix}\n\\frac{1}{2}-1  & \\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}-1  & \\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}-1  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}-1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & -\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}  & -\\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}  & -\\frac{1}{2}\n\\end{pmatrix}.\n$$\n这个矩阵作用在 $|s\\rangle$ 上时为 $G|s\\rangle=|s\\rangle$，而在与 $|s\\rangle$ 正交的子空间上作用为 $-I$，实现了关于平均值的反转。", "answer": "$$\\boxed{\\begin{pmatrix}\n-\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & -\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}  & -\\frac{1}{2}  & \\frac{1}{2}\\\\\n\\frac{1}{2}  & \\frac{1}{2}  & \\frac{1}{2}  & -\\frac{1}{2}\n\\end{pmatrix}}$$", "id": "1426368"}, {"introduction": "理论上的量子算法通常假设系统大小是 $2$ 的整数次幂，以便与量子比特的希尔伯特空间完美对应。然而，在解决实际问题时，搜索空间的大小往往是任意的。这个练习 [@problem_id:1426398] 模拟了这样一个更贴近现实的场景，要求我们在一个非 $2$ 的幂次的搜索空间中执行Grover算法。这不仅能让我们完整地应用一次Grover迭代，还能训练我们将具体问题嵌入到更大的量子计算框架中的关键技能。", "problem": "一个量子算法被部署用于在一个包含10个不同候选解的集合中搜索一个唯一的解。该搜索使用Grover算法实现。该量子系统被初始化为表示10个候选解所需的最少数量的量子比特的所有计算基态，以及填充量子比特寄存器所需的任何额外辅助状态的等量叠加态。单次Grover迭代包括一次神谕（oracle）算子的应用（它会翻转被标记解的状态的振幅符号），然后是一次Grover扩散算子的应用。\n\n计算在单次完整的Grover迭代后，测量到与唯一解对应的状态的概率。将最终答案四舍五入到四位有效数字。", "solution": "我们必须使用最少数量的量子比特以二进制表示10个候选解。满足 $2^{n} \\geq 10$ 的最小整数是 $n=4$，因此希尔伯特空间有 $N=2^{4}=16$ 个计算基态。恰好有一个基态被标记，其余的 $N-1=15$ 个状态未被标记。系统被初始化为所有 $N$ 个基态的均匀叠加态：\n$$\n|s\\rangle=\\frac{1}{\\sqrt{N}}\\sum_{x=0}^{N-1}|x\\rangle.\n$$\n定义 $|w\\rangle$ 为被标记的基态（因为只有一个唯一解，所以被标记状态的等量叠加态就是那个基态本身），$|r\\rangle$ 为所有未被标记基态的归一化等量叠加态。那么 $|s\\rangle$ 分解为\n$$\n|s\\rangle=\\sin\\theta\\,|w\\rangle+\\cos\\theta\\,|r\\rangle,\n$$\n其中\n$$\n\\sin\\theta=\\sqrt{\\frac{M}{N}}=\\sqrt{\\frac{1}{16}}=\\frac{1}{4},\\qquad \\cos\\theta=\\sqrt{\\frac{N-M}{N}}=\\sqrt{\\frac{15}{16}},\n$$\n其中 $M=1$ 是被标记状态的数量。\n\n单次Grover迭代（一次神谕算子加一次扩散算子）在由 $\\{|w\\rangle,|r\\rangle\\}$ 张成的二维子空间中实现一个角度为 $2\\theta$ 的旋转。经过 $k$ 次迭代后，状态变为\n$$\n|\\psi_{k}\\rangle=\\sin\\bigl((2k+1)\\theta\\bigr)\\,|w\\rangle+\\cos\\bigl((2k+1)\\theta\\bigr)\\,|r\\rangle.\n$$\n对于一次迭代，$k=1$，所以被标记状态的振幅是 $\\sin(3\\theta)$。使用三倍角恒等式\n$$\n\\sin(3\\theta)=3\\sin\\theta-4\\sin^{3}\\theta,\n$$\n并代入 $\\sin\\theta=\\frac{1}{4}$ 得\n$$\n\\sin(3\\theta)=3\\cdot\\frac{1}{4}-4\\left(\\frac{1}{4}\\right)^{3}=\\frac{3}{4}-\\frac{4}{64}=\\frac{3}{4}-\\frac{1}{16}=\\frac{11}{16}.\n$$\n因此，在一次Grover迭代后测量到被标记状态的概率是\n$$\nP=\\left|\\sin(3\\theta)\\right|^{2}=\\left(\\frac{11}{16}\\right)^{2}=\\frac{121}{256}=0.47265625.\n$$\n四舍五入到四位有效数字得到 $0.4727$。", "answer": "$$\\boxed{0.4727}$$", "id": "1426398"}, {"introduction": "Grover算法并非迭代次数越多越好；过多的迭代反而会使成功概率下降，这种现象通常被称为“过犹不及”。因此，确定最佳迭代次数是有效应用该算法的决定性步骤。本练习 [@problem_id:1426405] 旨在计算在给定搜索空间大小和目标数量的情况下，最大化成功概率所需的最佳迭代次数。通过这个计算，我们将深入理解Grover搜索的周期性，并掌握优化算法性能的核心准则。", "problem": "一个网络安全团队正在使用一台量子计算机来搜索一个密码系统中的漏洞。总搜索空间包含 $N = 2^{10}$ 种可能的配置。由于一个设计缺陷，已知这些配置中恰好有 $M=4$ 个是“弱”配置，如果找到它们，将会危及系统的安全。该团队采用 Grover 搜索算法来寻找这些弱配置中的一个。\n\n在 Grover 算法中，一系列量子操作（统称为一次“Grover 迭代”）被重复地应用于一个量子态上。经过一定次数的迭代后，会进行一次测量。测量到弱配置的概率取决于所执行的迭代次数。\n\n确定该团队应执行的最优 Grover 迭代次数 $k$，以在测量时有最高的概率识别出弱配置。迭代次数必须是整数。", "solution": "设 $N$ 是项目总数，$M$ 是被标记（弱）的项目数。在 Grover 算法中，我们通过以下方式定义角度 $\\theta$：\n$$\n\\sin(\\theta)=\\sqrt{\\frac{M}{N}}.\n$$\n经过 $k$ 次 Grover 迭代后，成功概率为\n$$\nP(k)=\\sin^{2}\\big((2k+1)\\theta\\big).\n$$\n当 $(2k+1)\\theta$ 尽可能接近 $\\frac{\\pi}{2}$ 时，该概率达到最大值，由此得出最优迭代次数为\n$$\nk^{\\ast}=\\left\\lfloor \\frac{\\pi}{4\\theta}-\\frac{1}{2}\\right\\rfloor.\n$$\n对于给定的值 $N=2^{10}$ 和 $M=4$，\n$$\n\\sqrt{\\frac{M}{N}}=\\sqrt{\\frac{4}{2^{10}}}=\\sqrt{\\frac{1}{256}}=\\frac{1}{16},\n$$\n所以\n$$\n\\theta=\\arcsin\\!\\left(\\frac{1}{16}\\right).\n$$\n因此，\n$$\nk^{\\ast}=\\left\\lfloor \\frac{\\pi}{4\\arcsin\\!\\left(\\frac{1}{16}\\right)}-\\frac{1}{2}\\right\\rfloor.\n$$\n为了选择正确的整数，我们进行近似计算。使用 $\\arcsin(x)$ 在 $x=\\frac{1}{16}$ 处的级数展开：\n$$\n\\arcsin(x)=x+\\frac{x^{3}}{6}+\\frac{3x^{5}}{40}+\\frac{5x^{7}}{112}+\\cdots,\n$$\n可得\n$$\n\\theta=\\arcsin\\!\\left(\\frac{1}{16}\\right)\\approx 0.062540761796,\n$$\n因此\n$$\n\\frac{\\pi}{4\\theta}\\approx \\frac{3.141592653589793}{4\\times 0.062540761796}\\approx 12.5581803,\n$$\n于是\n$$\n\\frac{\\pi}{4\\theta}-\\frac{1}{2}\\approx 12.0581803.\n$$\n取底函数得到 $k^{\\ast}=12$。等价地，使用常用近似公式 $k\\approx \\left\\lfloor \\frac{\\pi}{4}\\sqrt{\\frac{N}{M}} \\right\\rfloor$ 可得 $\\left\\lfloor \\frac{\\pi}{4}\\cdot 16 \\right\\rfloor=\\left\\lfloor 4\\pi \\right\\rfloor=12$，这与更精确的计算结果一致。", "answer": "$$\\boxed{12}$$", "id": "1426405"}]}