{"hands_on_practices": [{"introduction": "要掌握数据压缩的实际应用，没有什么比亲手操作一个经典的算法更好的方法了。本练习将引导您逐步完成 Lempel-Ziv-Welch (LZW) 算法的执行过程，这是一个在许多文件格式（如 GIF 和 TIFF）和压缩程序中都曾扮演核心角色的通用压缩方案。通过追踪对一个特定字符串的编码，您将深入了解 LZW 算法如何动态构建其字典，并根据字典的增长情况自适应地编码数据流，从而获得对自适应无损压缩机制的第一手经验。 [@problem_id:53455]", "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。它的操作依赖于为压缩过程中遇到的字符串建立一个字典。\n\nLZW 算法可总结如下：\n1.  用一组单字符字符串初始化字典。\n2.  将 `W`（工作字符串）设置成输入流的第一个字符。\n3.  遍历输入流：\n    a. 读取下一个字符 `K`。\n    b. 如果字符串 `W + K` 存在于字典中，则设置 `W = W + K`。\n    c. 如果 `W + K` 不在字典中，则：\n        i. 输出 `W` 对应的字典编码。\n        ii. 将新字符串 `W + K` 以新编码添加到字典中。\n        iii. 设置 `W = K`。\n4.  输入流耗尽后，输出最后工作字符串 `W` 的编码。\n\n考虑 LZW 的一个具体实现，其规范如下：\n*   初始字典包含 256 个条目，用于 8 位 ASCII 字符。这些字符的编码是其对应的 ASCII 值（0-255）。用于新字典条目的下一个可用编码是 256。\n*   用于表示输出编码的位数由输出时刻的字典大小决定。如果字典包含 $N$ 个条目，则输出编码使用 $\\lceil \\log_2(N) \\rceil$ 位来表示。\n*   待压缩的输入字符串是 `BANANA_BANDANA`。\n\n您的任务是计算最终压缩输出序列中的总位数。", "solution": "输入字符串是“BANANA_BANDANA”。下面逐步模拟 LZW 压缩过程，以确定输出编码和每次输出时的字典大小。字典初始包含 256 个条目（ASCII 字符的 0 到 255）。下一个可用编码是 256。\n\n**逐步模拟：**\n\n1.  用 ASCII 0-255 初始化字典。设置 $ W = $ 第一个字符 `B`。\n2.  读取下一个字符 `A`：“BA” 不在字典中。\n    - 输出 `B` 的编码（66）。\n    - 将 `BA` 以编码 256 添加到字典中。\n    - 设置 $ W = $ `A`。\n    - 输出时的字典大小：256 → 位数 = $ \\lceil \\log_2(256) \\rceil = 8 $。\n3.  读取下一个字符 `N`：“AN” 不在字典中。\n    - 输出 `A` 的编码（65）。\n    - 将 `AN` 以编码 257 添加到字典中。\n    - 设置 $ W = $ `N`。\n    - 输出时的字典大小：257 → 位数 = $ \\lceil \\log_2(257) \\rceil = 9 $（因为 $ 256  257 \\le 512 $）。\n4.  读取下一个字符 `A`：“NA” 不在字典中。\n    - 输出 `N` 的编码（78）。\n    - 将 `NA` 以编码 258 添加到字典中。\n    - 设置 $ W = $ `A`。\n    - 输出时的字典大小：258 → 位数 = 9。\n5.  读取下一个字符 `N`：“A” + “N” = “AN” 在字典中（编码 257）。设置 $ W = $ “AN”。\n6.  读取下一个字符 `A`：“AN” + “A” = “ANA” 不在字典中。\n    - 输出 “AN” 的编码（257）。\n    - 将 “ANA” 以编码 259 添加到字典中。\n    - 设置 $ W = $ `A`。\n    - 输出时的字典大小：259 → 位数 = 9。\n7.  读取下一个字符 `_`（下划线）：“A” + “_” = “A_” 不在字典中。\n    - 输出 `A` 的编码（65）。\n    - 将 `A_` 以编码 260 添加到字典中。\n    - 设置 $ W = $ `_`。\n    - 输出时的字典大小：260 → 位数 = 9。\n8.  读取下一个字符 `B`：“_” + “B” = “_B” 不在字典中。\n    - 输出 `_` 的编码（95，ASCII 值）。\n    - 将 `_B` 以编码 261 添加到字典中。\n    - 设置 $ W = $ `B`。\n    - 输出时的字典大小：261 → 位数 = 9。\n9.  读取下一个字符 `A`：“B” + “A” = “BA” 在字典中（编码 256）。设置 $ W = $ “BA”。\n10. 读取下一个字符 `N`：“BA” + “N” = “BAN” 不在字典中。\n    - 输出 “BA” 的编码（256）。\n    - 将 “BAN” 以编码 262 添加到字典中。\n    - 设置 $ W = $ `N`。\n    - 输出时的字典大小：262 → 位数 = 9。\n11. 读取下一个字符 `D`：“N” + “D” = “ND” 不在字典中。\n    - 输出 `N` 的编码（78）。\n    - 将 `ND` 以编码 263 添加到字典中。\n    - 设置 $ W = $ `D`。\n    - 输出时的字典大小：263 → 位数 = 9。\n12. 读取下一个字符 `A`：“D” + “A” = “DA” 不在字典中。\n    - 输出 `D` 的编码（68）。\n    - 将 `DA` 以编码 264 添加到字典中。\n    - 设置 $ W = $ `A`。\n    - 输出时的字典大小：264 → 位数 = 9。\n13. 读取下一个字符 `N`：“A” + “N” = “AN” 在字典中（编码 257）。设置 $ W = $ “AN”。\n14. 读取下一个字符 `A`：“AN” + “A” = “ANA” 在字典中（编码 259）。设置 $ W = $ “ANA”。输入结束。\n    - 输出 “ANA” 的编码（259）。\n    - 输出时的字典大小：265（因为最后一次添加的编码是 264，此时没有添加新字符串）→ 位数 = $ \\lceil \\log_2(265) \\rceil = 9 $。\n\n**输出编码和位数统计：**\n- 输出 1：66 → 8 位\n- 输出 2：65 → 9 位\n- 输出 3：78 → 9 位\n- 输出 4：257 → 9 位\n- 输出 5：65 → 9 位\n- 输出 6：95 → 9 位\n- 输出 7：256 → 9 位\n- 输出 8：78 → 9 位\n- 输出 9：68 → 9 位\n- 输出 10：259 → 9 位\n\n**总位数计算：**\n- 输出 1：8 位\n- 输出 2 到 10：9 个输出 × 每个 9 位 = 81 位\n- 总位数 = 8 + 81 = 89", "answer": "\\boxed{89}", "id": "53455"}, {"introduction": "现实世界中的通信信道很少是完全静态的；它们的特性，如噪声水平或衰减，会随时间变化。Gilbert-Elliott 模型为这类具有“记忆”的信道提供了一个简洁而有力的数学框架，其中信道在“良好”和“糟糕”等不同状态之间切换。本练习将探讨一个特例，即信道状态确定性地交替变化，通过计算其香农容量，您将学会如何通过对不同状态下的信道容量进行平均，来分析时变信道的性能极限。 [@problem_id:53399]", "problem": "一个两状态的吉尔伯特-艾略特信道是一个有记忆的二元通信信道的模型。该信道可以处于两种状态之一：“好”状态 (G) 或“坏”状态 (B)。\n\n1.  当处于状态 G 时，该信道表现为一个交叉概率为 $p_G$ 的二元对称信道 (BSC)。\n2.  当处于状态 B 时，它表现为一个交叉概率为 $p_B$ 的 BSC。\n\n在时刻 $t$ 的信道状态，记为 $S_t \\in \\{G, B\\}$，根据一个离散时间马尔可夫链进行演变。从时刻 $t$ 的状态到时刻 $t+1$ 的状态的转移由以下概率决定：\n-   $P(S_{t+1}=B | S_t=G) = q_G$：从好状态转移到坏状态的概率。\n-   $P(S_{t+1}=G | S_t=B) = q_B$：从坏状态转移到好状态的概率。\n\n因此，保持在同一状态的概率为 $P(S_{t+1}=G | S_t=G) = 1-q_G$ 和 $P(S_{t+1}=B | S_t=B) = 1-q_B$。\n\n考虑该信道的一个特定实例，其中状态转移是确定性的且总是翻转：$q_G = 1$ 和 $q_B = 1$。好状态和坏状态的交叉概率分别为 $p_G$ 和 $p_B$，其中 $0 \\le p_G, p_B \\le 1/2$。\n\n交叉概率为 $p$ 的 BSC 的容量由 $C_{BSC} = 1 - H(p)$ 给出，其中 $H(p)$ 是二元熵函数 $H(p) = -p \\log_2(p) - (1-p)\\log_2(1-p)$。\n\n求出这个特定的吉尔伯特-艾略特信道的香农容量 $C$。请用应用于参数 $p_G$ 和 $p_B$ 的二元熵函数 $H(\\cdot)$ 来表示你的答案。", "solution": "我们将该信道建模为一个周期为 2 的时变 BSC，其交叉概率在 $p_G$ 和 $p_B$ 之间交替。令 $C_{BSC}(p)=1-H(p)$。\n\n1.  状态 G 下 BSC 的容量\n   $$C_G=C_{BSC}(p_G)=1-H(p_G).$$\n\n2.  状态 B 下 BSC 的容量\n   $$C_B=C_{BSC}(p_B)=1-H(p_B).$$\n\n3.  在连续两次使用中，给定时间索引的条件下，该信道是无记忆的，因此最优输入是在每个时刻独立的、服从伯努利(1/2)分布的随机变量。每次使用的平均互信息是两个容量的平均值：\n   $$C=\\frac{C_G + C_B}{2}\n        =\\frac{(1-H(p_G)) + (1-H(p_B))}{2}.$$\n\n4.  化简得，\n   $$C=1 - \\frac{H(p_G)+H(p_B)}{2}.$$", "answer": "$$\\boxed{1 - \\frac{H(p_G) + H(p_B)}{2}}$$", "id": "53399"}, {"introduction": "速率失真理论优雅地连接了数据压缩（速率 $R$）与信号保真度（失真 $D$），为有损压缩技术设定了根本性的性能边界。前面的练习关注无损压缩和信道容量，而本练习则将我们带入有损压缩的核心领域，处理一个更贴近实际的二维高斯相关信源。您将运用“反向注水”原理，这是一种在信号处理和通信中至关重要的资源分配策略，学习如何根据信源各分量的相关性（通过协方差矩阵的特征值体现）来最优地分配失真预算，从而以最小的比特率实现给定的保真度。 [@problem_id:53350]", "problem": "考虑一个无记忆的二元高斯源，其中每个样本都是二维随机向量 $X = (X_1, X_2)^T$ 的一次独立抽样。向量 $X$ 服从多元正态分布 $\\mathcal{N}(0, \\Sigma)$，其均值为零，协方差矩阵为\n$$\n\\Sigma = \\sigma^2 \\begin{pmatrix} 1  \\rho \\\\ \\rho  1 \\end{pmatrix}\n$$\n其中 $\\sigma^2  0$ 是每个分量的方差，$\\rho$ 是相关系数，满足 $1/2  \\rho  1$。\n\n我们希望压缩此信源并将其重构为 $\\hat{X} = (\\hat{X}_1, \\hat{X}_2)^T$。重构质量由总均方误差（MSE）失真来衡量，定义为 $d(X, \\hat{X}) = E[\\|X - \\hat{X}\\|^2] = E[(X_1 - \\hat{X}_1)^2 + (X_2 - \\hat{X}_2)^2]$。\n\n该信源的率失真函数 $R(D)$ 指定了在给定最大允许平均失真 $D$ 的情况下，可实现的最小速率（单位为比特/二维向量样本）。\n\n计算当总平均失真恰好为 $D = \\sigma^2$ 时，率失真函数 $R(D)$ 的值。", "solution": "对于协方差矩阵为 $\\Sigma$ 的多元高斯源，在均方误差失真标准下，其率失真函数可以通过对 $\\Sigma$ 的特征值进行反向注水算法来找到。协方差矩阵为：\n$$\n\\Sigma = \\sigma^2 \\begin{pmatrix} 1  \\rho \\\\ \\rho  1 \\end{pmatrix}\n$$\n$\\Sigma$ 的特征值 $\\lambda_1$ 和 $\\lambda_2$ 可由特征方程 $\\det(\\Sigma - \\lambda I) = 0$ 求得：\n$$\n\\det\\begin{pmatrix} \\sigma^2 - \\lambda   \\sigma^2 \\rho \\\\ \\sigma^2 \\rho   \\sigma^2 - \\lambda \\end{pmatrix} = (\\sigma^2 - \\lambda)^2 - (\\sigma^2 \\rho)^2 = 0\n$$\n求解得：\n$$\n(\\sigma^2 - \\lambda - \\sigma^2 \\rho)(\\sigma^2 - \\lambda + \\sigma^2 \\rho) = 0\n$$\n因此：\n$$\n\\lambda_1 = \\sigma^2 (1 + \\rho), \\quad \\lambda_2 = \\sigma^2 (1 - \\rho)\n$$\n给定 $1/2  \\rho  1$，可得 $\\lambda_1  \\lambda_2  0$。\n\n率失真函数为：\n$$\nR(D) = \\min_{\\substack{D_1, D_2 \\\\ D_1 + D_2 \\le D}} \\sum_{i=1}^2 \\frac{1}{2} \\log_2 \\left( \\frac{\\lambda_i}{D_i} \\right)\n$$\n约束条件为 $0 \\leq D_i \\leq \\lambda_i$（$i=1,2$）。该最小化可以通过反向注水算法实现，即设置 $D_i = \\min\\{\\lambda_i, \\theta\\}$，其中水位 $\\theta$ 的选择需满足 $D_1 + D_2 = D$。\n\n对于 $D = \\sigma^2$，我们考虑关于 $\\theta$ 的几种情况：\n\n- 如果 $\\theta \\geq \\lambda_1$，那么 $D_1 = \\lambda_1$ 且 $D_2 = \\lambda_2$，所以 $D_1 + D_2 = \\lambda_1 + \\lambda_2 = 2\\sigma^2  \\sigma^2$，这个值太大了。\n- 如果 $\\lambda_2 \\le \\theta  \\lambda_1$，那么 $D_1 = \\theta$ 且 $D_2 = \\lambda_2$。令 $D_1 + D_2 = D$：\n  $$\n  \\theta + \\sigma^2 (1 - \\rho) = \\sigma^2\n  $$\n  解出 $\\theta$：\n  $$\n  \\theta = \\sigma^2 \\rho\n  $$\n  检验条件 $\\lambda_2 \\le \\theta  \\lambda_1$：\n  $$\n  \\sigma^2 (1 - \\rho) \\le \\sigma^2 \\rho  \\sigma^2 (1 + \\rho)\n  $$\n  因为 $\\rho  1/2$，所以 $1 - \\rho  \\rho$ 成立，而 $\\rho  1 + \\rho$ 总是成立的。因此，该条件满足。\n- 如果 $\\theta  \\lambda_2$，那么 $D_1 = \\theta$ 且 $D_2 = \\theta$，所以 $2\\theta = \\sigma^2$ 得到 $\\theta = \\sigma^2 / 2$。但 $\\theta  \\lambda_2$ 意味着 $\\sigma^2 / 2  \\sigma^2 (1 - \\rho)$，即 $\\rho  1/2$，这与 $\\rho > 1/2$ 矛盾。因此，这种情况不成立。\n\n因此，失真分配为 $D_1 = \\sigma^2 \\rho$ 和 $D_2 = \\sigma^2 (1 - \\rho)$。率失真函数为：\n$$\nR(D) = \\frac{1}{2} \\log_2 \\left( \\frac{\\lambda_1}{D_1} \\right) + \\frac{1}{2} \\log_2 \\left( \\frac{\\lambda_2}{D_2} \\right)\n$$\n代入数值：\n$$\nR(D) = \\frac{1}{2} \\log_2 \\left( \\frac{\\sigma^2 (1 + \\rho)}{\\sigma^2 \\rho} \\right) + \\frac{1}{2} \\log_2 \\left( \\frac{\\sigma^2 (1 - \\rho)}{\\sigma^2 (1 - \\rho)} \\right)\n$$\n化简得：\n$$\nR(D) = \\frac{1}{2} \\log_2 \\left( \\frac{1 + \\rho}{\\rho} \\right) + \\frac{1}{2} \\log_2 (1) = \\frac{1}{2} \\log_2 \\left( \\frac{1 + \\rho}{\\rho} \\right)\n$$\n因为 $\\log_2(1) = 0$。", "answer": "$$ \\boxed{\\dfrac{1}{2} \\log_{2} \\left( \\dfrac{1 + \\rho}{\\rho} \\right)} $$", "id": "53350"}]}