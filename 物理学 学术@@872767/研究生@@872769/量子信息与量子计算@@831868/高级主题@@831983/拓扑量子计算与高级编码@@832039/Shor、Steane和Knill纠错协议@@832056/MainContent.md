## 引言
[量子计算](@entry_id:142712)机的强大计算潜力源于其对量子力学原理的精妙利用，但这也使其极易受到环境噪声的干扰，导致计算结果的不可靠。为了克服这一根本性挑战，[量子纠错](@entry_id:139596)（Quantum Error Correction, QEC）应运而生，它通过将单个逻辑量子比特的信息冗余地编码到多个物理量子比特中，从而主动检测并纠正错误。QEC 不仅仅是被动的防护，更是构建可扩展、容错量子计算机的基石。然而，从抽象的理论到可行的协议，需要一套严谨的数学框架和精巧的编码方案。本文旨在系统性地介绍量子纠错领域中最具代表性的几种协议，揭示其背后的深刻原理与实际应用。

在接下来的内容中，我们将分步深入这个复杂而迷人的领域。在“原理与机制”一章中，我们将从 Knill-Laflamme 定理出发，建立量子纠错的普适性条件，并引入强大的[稳定子形式体系](@entry_id:146920)，用以剖析 Shor 码和 Steane 码这两种里程碑式[纠错码](@entry_id:153794)的构造与特性。随后，在“应用与跨学科连接”一章中，我们将展示这些理论如何转化为实现[容错](@entry_id:142190)逻辑门、制备关键[量子态](@entry_id:146142)、以及在不同编码架构间传递信息的具体技术，揭示 QEC 在构建模块化[量子计算](@entry_id:142712)机中的核心作用。最后，“动手实践”部分将通过一系列具体问题，引导读者应用所学知识，解决模拟真实场景中的[误差传播](@entry_id:147381)、纠错失败和性能评估等挑战，从而将理论理解内化为解决实际问题的能力。

## 原理与机制

继前一章对[量子纠错](@entry_id:139596)基本概念的介绍之后，本章将深入探讨[量子纠错码](@entry_id:266787)运作的核心原理与具体机制。我们将首先建立一套判断一个[量子态](@entry_id:146142)[子空间](@entry_id:150286)能否构成一个有效[纠错码](@entry_id:153794)的普适性准则。随后，我们将详细介绍一种极其强大且应用广泛的理论框架——[稳定子形式体系](@entry_id:146920) (stabilizer formalism)，它为构造和分析许多重要的量子纠错码提供了系统性的方法。在此基础上，我们将剖析两种里程碑式的[纠错码](@entry_id:153794)：Shor 码和 Steane 码，并阐明它们的设计哲学与特性。最后，我们将完整地审视纠错流程的每一个环节，从错误诊断（纠错子测量）到恢复操作，并分析在此过程中可能出现的复杂情况，如错误简并性、逻辑错误以及擦除错误。

### [量子纠错](@entry_id:139596)的基本条件：Knill-Laflamme 定理

一个核心问题是：什么样的量子系统能够纠正一组特定的错误？答案由 **Knill-Laflamme 定理** 给出，它为[量子纠错](@entry_id:139596)提供了必要且充分的数学条件。

假设我们希望保护一个由一组[正交基](@entry_id:264024)矢 $\{|\psi_i\rangle\}$ 张成的编码空间 $\mathcal{C}$，使其免受一组错误操作 $\mathcal{E} = \{E_k\}$ 的影响。Knill-Laflamme 条件指出，该编码空间 $\mathcal{C}$ 能够纠正错误集 $\mathcal{E}$ 的充要条件是，对于任意两个逻辑[基矢](@entry_id:199546) $|\psi_i\rangle, |\psi_j\rangle$ 和任意两个错误算符 $E_a, E_b \in \mathcal{E}$，下式恒成立：

$$
\langle \psi_i | E_a^\dagger E_b | \psi_j \rangle = C_{ab} \delta_{ij}
$$

其中，$C_{ab}$ 是一个仅依赖于错误算符 $E_a$ 和 $E_b$ 而与具体逻辑[基矢](@entry_id:199546)无关的复数矩阵（通常称为 “纠错矩阵”），$\delta_{ij}$ 是克罗内克函数。

该条件包含两个层面的深刻含义。首先，当 $i \neq j$ 时，$\delta_{ij} = 0$，这意味着 $E_a^\dagger E_b$ 的作用不会将一个逻辑[基态](@entry_id:150928) $|\psi_j\rangle$ 映射到另一个正交的逻辑[基态](@entry_id:150928) $|\psi_i\rangle$ 的分量上。换言之，错误操作不会混淆不同的逻辑信息。其次，当 $i=j$ 时，矩阵元 $\langle \psi_i | E_a^\dagger E_b | \psi_i \rangle = C_{ab}$ 是一个常数，与具体的逻辑态 $|\psi_i\rangle$ 无关。这意味着对于编码空间中的任意叠加态 $|\psi_L\rangle = \sum_i \alpha_i |\psi_i\rangle$，其在错误作用下的“形变”方式是统一的，与它所携带的逻辑信息（由系数 $\alpha_i$ 决定）无关。这种与逻辑信息无关的特性，使得恢复操作可以统一应用于整个编码空间，从而在不测量（即不破坏）逻辑信息的前提下撤销错误。

让我们通过具体的例子来理解这一定理。考虑 Shor 码，其逻辑[基矢](@entry_id:199546)为 $|0_L\rangle$ 和 $|1_L\rangle$。假设存在两个错误：一个是作用在第一个[物理量子比特](@entry_id:137570)上的[相位翻转错误](@entry_id:142173) $E_a = Z_1$，另一个是作用在第四和第五个[物理量子比特](@entry_id:137570)上的双比特翻转错误 $E_b = X_4 X_5$。为了检验 Knill-Laflamme 条件，我们需要计算 $\langle \psi_i | Z_1 X_4 X_5 | \psi_j \rangle$。由于 $Z_1$ 仅作用于第一个[量子比特](@entry_id:137928)块，而 $X_4 X_5$ 仅作用于第二个[量子比特](@entry_id:137928)块，我们可以分别计算它们在各自块上的期望。对于 Shor 码的构造，可以证明 $\langle A | Z_1 | A \rangle = 0$，其中 $|A\rangle = |000\rangle + |111\rangle$ 是第一个块的未归一化态。因此，整个矩阵元为零，即 $C_{ab} = 0$。这意味着这两个错误 $E_a$ 和 $E_b$ 是可以被区分和纠正的 [@problem_id:133353]。

另一方面，$C_{ab}$ 矩阵的非零元素也具有重要意义。考虑 Steane 码，以及两个简并的（即产生相同纠错子测量结果的）权重-2 错误 $E_a = Z_1 Z_3$ 和 $E_b = Z_5 Z_7$。计算 $E_a^\dagger E_b$ 得到 $Z_1 Z_3 Z_5 Z_7$。这个算符恰好是 Steane 码的一个稳定子生成元 $g_6$。根据定义，编码空间中的任何态（包括逻辑[基矢](@entry_id:199546) $| \overline{0} \rangle$）都是所有稳定子的+1特征态。因此，$\langle \overline{0} | E_a^\dagger E_b | \overline{0} \rangle = \langle \overline{0} | g_6 | \overline{0} \rangle = +1$。由此我们得到 $C_{ab}=1$。这表明，虽然这两个错误无法通过[纠错](@entry_id:273762)子测量区分开，但它们的组合效应对编码空间的作用是一个[稳定子算符](@entry_id:141669)，这种作用可以被看作是平凡的（因为它不改变编码空间），因此这一对简并错误仍然是可纠正的 [@problem_id:133416]。

Knill-Laflamme 条件的一个基本推论是，任何有效的[量子编码](@entry_id:141173)，其逻辑[基矢](@entry_id:199546)必须是严格正交的，即 $\langle \psi_i | \psi_j \rangle = \delta_{ij}$。如果逻辑[基矢](@entry_id:199546)本身不正交，纠错将无从谈起。我们可以通过一个修改版的 Shor 码来阐释这一点。假设我们用一组非正交的单比特态 $|\psi_A\rangle$ 和 $|\psi_B\rangle$ （它们的內积为 $\langle \psi_A | \psi_B \rangle = S \neq 0$）来构造外码。遵循同样的级联构造法，得到的新逻辑态 $|0'_L\rangle$ 和 $|1'_L\rangle$ 将不再正交，它们的內积为 $\langle 0'_L | 1'_L \rangle = S^3$。当 $S \neq 0$ 时，这个非零的交叠意味着逻辑上的“0”和“1”本身就存在混淆，这从根本上破坏了编码的有效性 [@problem_id:133346]。

### [稳定子形式体系](@entry_id:146920)

Knill-Laflamme 定理虽然普适，但在实践中直接验证它对于大规模的错误集和复杂的编码态是极其困难的。**[稳定子形式体系](@entry_id:146920)** (stabilizer formalism) 应运而生，它为一类被称为“[稳定子码](@entry_id:143150)”的重要[量子纠错码](@entry_id:266787)提供了极其高效的描述、构造和分析工具。Shor 码和 Steane 码都是[稳定子码](@entry_id:143150)的杰出代表。

其核心思想是，不再直接描述复杂的编码态本身，而是通过定义一个使其保持不变的算符群——**[稳定子群](@entry_id:137216)** (stabilizer group) $\mathcal{S}$——来间接定义编码空间 $\mathcal{C}$。[稳定子群](@entry_id:137216)是 $n$-[量子比特](@entry_id:137928)[泡利群](@entry_id:136414) $G_n$ 的一个[阿贝尔子群](@entry_id:142799)，且不包含 $-I$。编码空间 $\mathcal{C}$ 被定义为[希尔伯特空间](@entry_id:261193)中所有被 $\mathcal{S}$ 中任意元素 $S$ “稳定”的态 $|\psi\rangle$ 的集合，即：

$$
\mathcal{C} = \{ |\psi\rangle \mid S |\psi\rangle = |\psi\rangle, \forall S \in \mathcal{S} \}
$$

$\mathcal{C}$ 是所有[稳定子算符](@entry_id:141669)的公共+1特征[子空间](@entry_id:150286)。为了方便描述，我们通常不列出[稳定子群](@entry_id:137216)的所有元素，而是给出一个最小的生成元集合 $\{g_1, g_2, \dots, g_{n-k}\}$。这个群的任何元素都可以由这些生成元的乘积得到。对于一个编码 $k$ 个逻辑比特到 $n$ 个物理比特的码，需要 $n-k$ 个独立的生成元。

[稳定子群](@entry_id:137216)的结构本身也蕴含着[纠错码](@entry_id:153794)的重要信息。例如，对于 [[7,1,3]] Steane 码，其[稳定子群](@entry_id:137216)由6个生成元生成，共有 $2^6 = 64$ 个不同的[稳定子算符](@entry_id:141669)（不计相位）。这些[稳定子算符](@entry_id:141669)的**权重**（即其泡利链中非恒等算符的个数）[分布](@entry_id:182848)是码的一个重要特征。例如，在 Steane 码的64个稳定子中，有21个算符的权重恰好为4。这些可以被归类为7个纯X型、7个纯Z型和7个混合Y型算符 [@problem_id:133317]。

在稳定子框架下，作用于编码信息上的操作由**逻辑算符** (logical operators) 实现。一个逻辑算符 $L$ 是一个与所有稳定子 $S \in \mathcal{S}$ 对易（即 $[L, S] = 0$）但本身不属于[稳定子群](@entry_id:137216)的算符（$L \notin \mathcal{S}$）。对于编码单个逻辑比特的码，有一对逻辑[泡利算符](@entry_id:144061) $X_L$ 和 $Z_L$，它们必须满足与物理泡利矩阵相同的[反对易关系](@entry_id:153815)：$X_L Z_L = -Z_L X_L$。

值得注意的是，逻辑算符的表示不是唯一的。任何一个逻辑算符 $L$ 乘以一个稳定子 $S \in \mathcal{S}$ 后得到的 $L \cdot S$ 仍然是一个等价的逻辑算符，因为它在编码空间上的作用效果是相同的。我们可以利用这个特性寻找特定权重或特定支撑集（作用范围）的逻辑算符。例如，对于 Shor 码，一个有效的逻辑 Z 算符可以被构造成 $Z_1 Z_4 Z_7$，其权重为3 [@problem_id:133405]。对于 Steane 码，一个权重为3的逻辑 $Z$ 算符可以是 $Z_1 Z_2 Z_3$，我们可以通过计算验证它确实与所有的X型稳定子生成元对易 [@problem_id:133334]。

寻找特定权重的逻辑算符是一项基本任务。通过对比 Shor 码和 Steane 码，我们可以更深入地理解码的结构差异。对于 Steane 码，其权重为3的逻辑X算符共有7个，这与底层的 [7,4,3] 经典[汉明码](@entry_id:276290)的权重为3的码字一一对应。而对于 Shor 码，其权重为3的逻辑X算符只有3个，分别对应于作用在三个[量子比特](@entry_id:137928)块上的 $X_1X_2X_3$、$X_4X_5X_6$ 和 $X_7X_8X_9$。因此，两者权重为3的逻辑X算符数量之比为 $7/3$ [@problem_id:133349]。

### 典型[纠错码](@entry_id:153794)的构造与特性

#### Shor 码
Shor 码是一个 [[9,1,3]] 码，它巧妙地将两种简单的纠错码级联起来。
1.  **内码 (Inner Code)**：3-[量子比特](@entry_id:137928)**位翻转码** (bit-flip code)，它通过冗余将 $|0\rangle$ 编码为 $|000\rangle$，将 $|1\rangle$ 编码为 $|111\rangle$，可以纠正一个[位翻转错误](@entry_id:147577)（$X$ 错误）。
2.  **外码 (Outer Code)**：3-[量子比特](@entry_id:137928)**相位翻转码** (phase-flip code)，它在哈达玛基下等价于位翻转码，可以将 $|+\rangle$ 编码为 $|+\rangle^{\otimes 3}$，将 $|-\rangle$ 编码为 $|-\rangle^{\otimes 3}$，可以纠正一个[相位翻转错误](@entry_id:142173)（$Z$ 错误）。

将两者级联，Shor 码首先使用相位翻转码，然后对得到的三个[量子比特](@entry_id:137928)分别使用位翻转码。这使得它能够同时纠正任意单个[量子比特](@entry_id:137928)的位翻转、相位翻转以及它们的组合（$Y$ 错误）。其逻辑[基矢](@entry_id:199546) $|0\rangle_L$ 的具体形式为：
$$
|0_L\rangle = \frac{1}{2\sqrt{2}} \left( (|000\rangle + |111\rangle) \otimes (|000\rangle + |111\rangle) \otimes (|000\rangle + |111\rangle) \right)
$$
这个态是8个计算[基矢](@entry_id:199546)的叠加。我们可以分析这些[基矢](@entry_id:199546)的[汉明权重](@entry_id:265886)（比特串中"1"的个数）。例如，[汉明权重](@entry_id:265886)为6的[基矢](@entry_id:199546)有3个，它们分别是 $|000111111\rangle$, $|111000111\rangle$, 和 $|111111000\rangle$ [@problem_id:133402]。

#### Steane 码
Steane 码是一个 [[7,1,3]] 码，是 **CSS (Calderbank-Shor-Steane) 码** 的一个典型例子。CSS 码的精妙之处在于它将[量子纠错码](@entry_id:266787)的构造与经典的线性[纠错码](@entry_id:153794)联系起来。

一个 CSS 码由两个[经典线性码](@entry_id:147544) $C_1[n, k_1, d_1]$ 和 $C_2[n, k_2, d_2]$ 构造，前提是 $C_2 \subseteq C_1$。其稳定子生成元可以直接从 $C_1$ 的校验矩阵 $H_1$ 和 $C_2$ 的校验矩阵 $H_2$ 构造出来。简单来说，X型稳定子由 $H_2$ 的行定义，Z型稳定子由 $H_1$ 的行定义。Steane 码是一个特例，其中 $C_1$ 是 [7,4,3] [汉明码](@entry_id:276290)，$C_2$ 是其对偶码 [7,3,4] 单纯码（simplex code），满足 $C_2 = C_1^\perp \subseteq C_1$。

#### [码距](@entry_id:140606)与 CSS 码的性能
量子码的**[码距](@entry_id:140606)** $d$ 是衡量其[纠错](@entry_id:273762)能力的关键参数，它被定义为权重最小的非平凡逻辑算符的权重。一个[码距](@entry_id:140606)为 $d$ 的码可以检测任意权重小于 $d$ 的错误，并纠正 $\lfloor (d-1)/2 \rfloor$ 个任意[单比特错误](@entry_id:165239)。

对于 CSS 码，其[码距](@entry_id:140606) $d = \min(d_X, d_Z)$，其中 $d_Z$ 和 $d_X$ 分别与经典码的性质有关。不恰当的经典码选择会导致[码距](@entry_id:140606)很小，从而使量子码性能不佳。例如，如果我们选择 $C_1$ 为[汉明码](@entry_id:276290)，但 $C_2$ 只是其对偶码的一个子码，我们可能会构造出一个[码距](@entry_id:140606)为1的量子码，这样的码甚至连一个错误都无法检测 [@problem_id:133359]。

在稳定子框架下，[码距](@entry_id:140606)为 $d$ 意味着任何权重小于 $d$ 的[泡利错误](@entry_id:146391)算符要么与至少一个稳定子生成元[反对易](@entry_id:186708)（因而可被检测），要么其本身就是一个稳定子（平凡错误）。例如，对于[码距](@entry_id:140606)为3的 Steane 码，任何权重为2的泡利-Z错误（形如 $Z_k Z_l$）都必然与至少一个X型稳定子生成元[反对易](@entry_id:186708)，因此是可检测的。这意味着不存在权重为2的不可检测Z错误 [@problem_id:133299]。

除了 Shor 码和 Steane 码，稳定子的思想也启发了其他类型的码，例如 **[Bacon-Shor 码](@entry_id:145442)**。这是一种子系统码，其稳定子由更局域的“规范生成元”(gauge generators)的乘积构成。其逻辑算符通常具有几何特征，例如在一个 $3 \times 3$ 的柱面[晶格](@entry_id:196752)上，逻辑算符可以是跨越整行或整列的泡利串，其最小权重决定了[码距](@entry_id:140606)，此例中[码距](@entry_id:140606)为3 [@problem_id:133308]。

### [纠错](@entry_id:273762)机制的运作

[量子纠错](@entry_id:139596)是一个动态过程，主要包括三个步骤：错误诊断、错误识别和恢复操作。

#### 纠错子测量 (Syndrome Measurement)
错误诊断是通过测量一系列稳定子生成元的[本征值](@entry_id:154894)来完成的，这个测量结果的集合被称为**纠错子** (syndrome)。如果编码态 $|\psi_L\rangle$ 受到错误 $E$ 的作用，变为 $E|\psi_L\rangle$，那么对稳定子 $S$ 的测量结果将取决于 $E$ 和 $S$ 的对易关系：
- 如果 $[E, S] = 0$ (对易)，测量结果为 +1 (无错误信号)。
- 如果 $\{E, S\} = 0$ (反对易)，测量结果为 -1 (有错误信号)。

通过测量所有生成元，我们可以得到一个二[进制](@entry_id:634389)的[纠错](@entry_id:273762)子串，它指向了可能发生的错误类型和位置。例如，在 Shor 码中，如果第五个[量子比特](@entry_id:137928)上发生了一个 $Y_5$ 错误，由于 $Y_5 = iX_5Z_5$，它会与包含 $Z_5$ 的稳定子 ($M_3=Z_4Z_5$, $M_4=Z_5Z_6$) 和包含 $X_5$ 的稳定子 ($M_7, M_8$) 反对易，从而产生一个独特的纠错子信号 [@problem_id:133417]。

#### 测量电路与实现
在实践中，[纠错](@entry_id:273762)子测量通常借助一个[辅助量子比特](@entry_id:144604)（ancilla）来完成，以避免直接测量数据[量子比特](@entry_id:137928)而破坏编码信息。对于一个Z型稳定子 $S_z = \bigotimes_{j \in J} Z_j$，标准测量流程如下：
1.  将辅助比特制备在 $|+\rangle$ 态。
2.  对每一个 $j \in J$，施加一个以数据比特 $j$ 为控制、辅助比特为目标的 CNOT 门。
3.  对辅助比特施加哈达玛门。
4.  在计算基下测量辅助比特。

如果测量结果为 '0'，对应 $S_z$ 的[本征值](@entry_id:154894)为+1；若为 '1'，则对应-1。这个电路的正确性依赖于每一步的精确执行。如果辅助比特被错误地制备在 $|-\rangle$ 态，那么整个电路测量的将不再是 $g_6 = Z_1 Z_3 Z_5 Z_7$，而是 $-g_6$ [@problem_id:133415]。同样，如果在测量过程中数据比特与辅助比特之间发生了意外的相干耦合（例如由 $U_{err} = \exp(-i\frac{\theta}{2} Z_1 \otimes Z_a)$ 描述），即使初始态是完好的，也可能以一定概率（此例中为 $\sin^2(\theta/2)$）得到错误的[纠错](@entry_id:273762)子结果 [@problem_id:133302]。更一般地，对于[非泡利错误](@entry_id:141795)，测量结果可能不再是确定的+1或-1，而是以一定[概率分布](@entry_id:146404)在两者之上 [@problem_id:133372]。

#### 简并性与[逻辑错误](@entry_id:140967)
[纠错](@entry_id:273762)过程中最微妙的挑战来自于**简并性** (degeneracy)，即多个不同的物理错误可能产生完全相同的纠错子。当这种情况发生时，解码器必须根据某种策略（例如，选择权重最小的最可能错误）来猜测实际发生了哪个错误。如果猜错了，恢复操作就可能不完美，甚至引入一个逻辑错误。

其根本原因在于，如果两个错误 $E_a$ 和 $E_b$ 产生相同的[纠错](@entry_id:273762)子，这意味着它们与所有稳定子生成元有相同的对易关系。这等价于算符 $E_a^\dagger E_b$ 与所有稳定子对易。根据定义，这意味着 $E_a^\dagger E_b$ 本身是一个稳定子或一个逻辑算符。

例如，对于构成Shor码的3比特位翻转码，[单比特错误](@entry_id:165239) $E_a=X_1$ 和双比特错误 $E_b=X_2X_3$ 是简并的。它们的乘积 $E_a^\dagger E_b = X_1 X_2 X_3$ 是一个非平凡的逻辑算符（即逻辑X） [@problem_id:133306]。

现在考虑一个完整的[纠错](@entry_id:273762)失败场景：
1.  系统处于 $|\psi_L\rangle$，发生了一个复杂的物理错误 $E = i Y_1 Z_4 Z_7$。
2.  系统测量纠错子，发现其与最简单的[单比特错误](@entry_id:165239) $X_1$ 的[纠错](@entry_id:273762)子完全相同。
3.  解码器假设发生了 $X_1$ 错误，于是施加恢复操作 $C = X_1$。
4.  施加在[量子态](@entry_id:146142)上的净操作是 $R = C \cdot E = X_1 \cdot (i Y_1 Z_4 Z_7)$。经过计算，这个净操作等价于 $-Z_L$，即一个逻辑Z操作（附带一个相位）。物理错误被“纠正”成了一个逻辑错误 [@problem_id:133326]。

然而，并非所有简并错误都会导致[逻辑错误](@entry_id:140967)。在某些情况下，即使解码器猜错了，最终的净操作也可能是一个[稳定子算符](@entry_id:141669)或者恒等算符 $I$，它们对逻辑信息没有影响。例如，对于 Steane 码，一个关联错误 $E = X_1 Z_5$ 产生的纠错子可以被唯一地分解为来自 $X_1$ 的[部分和](@entry_id:162077)来自 $Z_5$ 的部分。最小权重解码器会正确地识别出需要施加 $C=X_1Z_5$ 的校正，从而净操作为 $C \cdot E = (X_1Z_5)(X_1Z_5) = I$，实现了完美纠正 [@problem_id:133322]。

#### 擦除错误 (Erasure Errors)
**擦除错误**是一种特殊的错误，我们不仅知道发生了错误，还确切地知道错误发生在哪一个或哪几个[量子比特](@entry_id:137928)上。这些信息极大增强了我们的纠错能力。当一个[量子比特](@entry_id:137928)被擦除后，我们需要找到作用在剩余未擦除[量子比特](@entry_id:137928)上的新的逻辑算符代表。这可以通过将原逻辑算符乘以适当的稳定子来实现。

例如，如果 Shor 码的第1和第5个[量子比特](@entry_id:137928)被擦除，我们原来的逻辑算符 $Z_L = Z_1 Z_4 Z_7$ 就无法直接使用了，因为它作用在被擦除的[量子比特](@entry_id:137928)1上。为了找到一个等价且只作用于好比特上的新代表，我们可以将 $Z_L$ 乘以稳定子 $S_1 = Z_1 Z_2$。得到的新逻辑算符 $Z'_L = Z_L \cdot S_1 = (Z_1 Z_4 Z_7)(Z_1 Z_2) = Z_2 Z_4 Z_7$。这个新算符的权重仍然是3，且其作用范围不包括被擦除的[量子比特](@entry_id:137928) [@problem_id:133387]。

擦除错误有时会降低码的有效[码距](@entry_id:140606)。例如，当 Steane 码的第7个[量子比特](@entry_id:137928)被擦除后，我们需要重新审视[稳定子群](@entry_id:137216)和逻辑算符。新的[稳定子群](@entry_id:137216)只包含原[稳定子群](@entry_id:137216)中作用在第7比特上为恒等算符的那些元素。在此基础上，我们可以找到新的只作用于前6个[量子比特](@entry_id:137928)的逻辑 Z 算符。可以证明，这种情况下最小权重的逻辑Z算符的权重降为了2，例如 $Z_1Z_6$ [@problem_id:133400]。这表明，擦除一个关键位置的[量子比特](@entry_id:137928)可能会改变码的基本参数。