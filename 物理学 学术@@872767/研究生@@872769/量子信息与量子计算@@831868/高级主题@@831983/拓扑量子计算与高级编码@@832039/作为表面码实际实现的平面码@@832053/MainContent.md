## 引言
[量子计算](@entry_id:142712)的巨大潜力受限于一个根本性挑战：[量子比特](@entry_id:137928)的脆弱性。与经典的比特不同，[量子比特](@entry_id:137928)极易受到环境噪声的干扰，导致计算错误。为了构建可靠的大规模[量子计算](@entry_id:142712)机，必须采用量子纠错（Quantum Error Correction, QEC）技术。在众多QEC方案中，[拓扑量子纠错](@entry_id:141569)码，特别是[表面码](@entry_id:145710)（Surface Code），因其高错误阈值和仅需二维局域相互作用的特点，成为最有前途的实现路径之一。

本文聚焦于[表面码](@entry_id:145710)最实用、最被广泛研究的变体——[平面码](@entry_id:136969)（Planar Code）。[平面码](@entry_id:136969)将[表面码](@entry_id:145710)的抽象拓扑概念转化为在二维[物理量子比特](@entry_id:137570)阵列上的具体实现方案，为构建容错[逻辑量子比特](@entry_id:142662)提供了清晰的蓝图。然而，理解[平面码](@entry_id:136969)如何运作，涉及从[晶格](@entry_id:196752)几何、稳定子代数到经典解码算法等多个层面的知识，构成了一个不小的知识鸿沟。

本文旨在系统地填补这一鸿沟，为读者提供一份关于[平面码](@entry_id:136969)的全面指南。我们将从最基本的构成单元开始，逐步揭示其保护量子信息的精妙机制，并展示如何利用这些机制进行可靠的[量子计算](@entry_id:142712)。通过本文的学习，您将：
*   在“原理与机制”一章中，掌握[平面码](@entry_id:136969)的[晶格结构](@entry_id:145664)、稳定子与逻辑算符的定义，并理解其[纠错](@entry_id:273762)循环的核心：通过测量综合症来探测错误，再利用解码算法进行修正。
*   在“应用与跨学科连接”一章中，探索如何通过格点手术（Lattice Surgery）等技术在[平面码](@entry_id:136969)上实现[逻辑门](@entry_id:142135)，并了解其与凝聚态物理等领域的深刻联系。
*   在“动手实践”部分，通过解决具体问题，加深对错误探测、逻辑算符和解码过程的实际理解。

现在，让我们首先深入探讨[平面码](@entry_id:136969)的核心原理与工作机制。

## 原理与机制

在介绍章节之后，我们现在深入探讨[平面码](@entry_id:136969)作为[表面码](@entry_id:145710)一种实用实现方式的核心原理与工作机制。本章将系统地阐述[平面码](@entry_id:136969)的结构、逻辑信息的编码方式、错误探测与修正的过程，以及其在实际物理系统中实现时所面临的挑战与对策。

### [平面码](@entry_id:136969)的晶格结构

[量子纠错码](@entry_id:266787)的基础在于其将单个[逻辑量子比特](@entry_id:142662)的信息冗余地编码到多个[物理量子比特](@entry_id:137570)的[纠缠态](@entry_id:152310)中。[平面码](@entry_id:136969)通过将[物理量子比特](@entry_id:137570)布置在二维[晶格](@entry_id:196752)上，并利用局域的相互作用来实现这种编码，从而极具实用价值。

#### 数据[量子比特](@entry_id:137928)与稳定子

想象一个二维方格[晶格](@entry_id:196752)。构建[平面码](@entry_id:136969)有两种常见的布局方式。一种是将数据[量子比特](@entry_id:137928)放置在[晶格](@entry_id:196752)的**顶点**上，这通常被称为**旋转[平面码](@entry_id:136969) (rotated planar code)**。另一种则是将数据[量子比特](@entry_id:137928)放置在[晶格](@entry_id:196752)的**边**上，这通常被称为**标准[平面码](@entry_id:136969) (standard planar code)**。尽管几何布局不同，其底层的拓扑原理是相通的。

编码的核心是一组被称为**稳定子 (stabilizers)** 的[厄米算符](@entry_id:153410)。这些算符由作用在部分数据[量子比特](@entry_id:137928)上的泡利算符张量积构成。对于一个理想的、无限大的方格[晶格](@entry_id:196752)，稳定子有两种类型 [@problem_id:109987]：

1.  **顶点算符 (Vertex Operators)** 或 **星形算符 (Star Operators)**：与[晶格](@entry_id:196752)中的每个顶点 $v$ 相关联，通常是 $X$ 型稳定子。它被定义为作用在所有汇集于该顶点的边上的数据[量子比特](@entry_id:137928)的泡利-$X$ 算符的乘积。例如，对于一个位于顶点 $(i,j)$ 的星形算符 $A_v$，其形式为 $A_{i,j} = X_{(i-1/2, j)} X_{(i+1/2, j)} X_{(i, j-1/2)} X_{(i, j+1/2)}$。

2.  **方格算符 (Plaquette Operators)**：与[晶格](@entry_id:196752)中的每个基本方格（或称“面”）$p$ 相关联，通常是 $Z$ 型稳定子。它被定义为作用在构成该方格边界的所有数据[量子比特](@entry_id:137928)上的泡利-$Z$ 算符的乘积。例如，对于中心在 $(i+1/2, j+1/2)$ 的方格算符 $B_p$，其形式为 $B_{(i+1/2, j+1/2)} = Z_{(i+1/2, j)} Z_{(i+1, j+1/2)} Z_{(i+1/2, j+1)} Z_{(i, j+1/2)}$。

这些[稳定子算符](@entry_id:141669)的一个关键性质是它们相互**对易 (commute)**。这意味着我们可以找到一个希尔伯特空间，其中的所有态都是所有[稳定子算符](@entry_id:141669)的共同[本征态](@entry_id:149904)。[平面码](@entry_id:136969)的**码空间 (codespace)** 正是定义为所有[稳定子算符](@entry_id:141669)的共同的 `+1` [本征值](@entry_id:154894)的[子空间](@entry_id:150286)。也就是说，一个[量子态](@entry_id:146142) $|\psi_L\rangle$ 若属于码空间，则对于任意稳定子 $S_k$（无论是顶点算符还是方格算符），都满足 $S_k |\psi_L\rangle = +1 |\psi_L\rangle$。

这个定义有一个直接而重要的推论：对于任何处于码空间中的逻辑态，任何[稳定子算符](@entry_id:141669)的[期望值](@entry_id:153208)都是 `+1`。因此，任意两个稳定子 $S_{Z,i}$ 和 $S_{Z,j}$ 的[乘积的期望值](@entry_id:201037)也必然为 `+1`，即 $\langle S_{Z,i} S_{Z,j} \rangle = 1$，无论它们在[晶格](@entry_id:196752)上相距多远 [@problem_id:109972]。这个性质看似平凡，但它恰恰是码空间定义的直接体现，也是[错误检测](@entry_id:275069)的基础。

#### 几何参数与资源计数

在实际应用中，我们处理的是有限尺寸的[晶格](@entry_id:196752)。一个关键参数是**[码距](@entry_id:140606) (code distance)** $d$，它量化了代码抵抗错误的能力。[码距](@entry_id:140606)通常与[晶格](@entry_id:196752)的线性尺寸成正比。

以一个[码距](@entry_id:140606)为 $d$ 的旋转[平面码](@entry_id:136969)为例，数据[量子比特](@entry_id:137928)可以被看作是[排列](@entry_id:136432)在一个 $d \times d$ 的方形网格的顶点上，总共有 $N_{data} = d^2$ 个数据[量子比特](@entry_id:137928) [@problem_id:110023]。由于[晶格](@entry_id:196752)具有开放边界，位于**内部 (bulk)** 的稳定子和位于**边界 (boundary)** 的稳定子在结构上有所不同。内部的稳定子作用于4个[量子比特](@entry_id:137928)，被称为**权重为4 (weight-4)** 的稳定子。而边界上的稳定子，由于缺少邻居，其权重会更低，通常为2。

我们可以精确地计算不同类型稳定子的数量。在一个 $d \times d$ 的旋转[平面码](@entry_id:136969)中，总共有 $d^2-1$ 个独立的稳定子，其中 $X$ 型和 $Z$ 型各占一半，即各有 $\frac{d^2-1}{2}$ 个。对于 $Z$ 型稳定子，可以通过计算满足 $i+j$ 为偶数的方格 $p_{i,j}$ 的数量来确定。在一个 $(d-1) \times (d-1)$ 的方格阵列中，这样的方格总数是 $\lceil \frac{(d-1)^2}{2} \rceil$。类似地，对应于 $i+j$ 为奇数的 $X$ 型稳定子的数量是 $\lfloor \frac{(d-1)^2}{2} \rfloor$ [@problem_id:109950]。

除了正[方形晶格](@entry_id:204295)，[表面码](@entry_id:145710)的原理也可以推广到其他[二维流形](@entry_id:188198)上，例如使用正三角形进行密铺的[晶格](@entry_id:196752)。在一个边长为 $d$ 个[晶格](@entry_id:196752)单位的等边三角形区域中，总共包含 $d^2$ 个基本三角面。利用[图论中的欧拉公式](@entry_id:273423) $V - E + F = 1$（其中 $V$ 是顶点数，$E$ 是边数，$F$ 是面数），我们可以计算出构成该码的数据[量子比特](@entry_id:137928)总数（即边数 $E$）为 $n = \frac{3d(d+1)}{2}$ [@problem_id:110051]。这表明[表面码](@entry_id:145710)的核心拓扑性质不局限于特定的[晶格](@entry_id:196752)几何。

随着[码距](@entry_id:140606) $d$ 的增加，编码所需的物理资源也会相应增长。例如，在旋转[平面码](@entry_id:136969)中，位于物理边界上的数据[量子比特](@entry_id:137928)数量为 $N_B = 4(d-1)$，而内部的[量子比特](@entry_id:137928)数量为 $N_{int} = (d-2)^2$ [@problem_id:110023]。这些参数的缩放关系对于评估大规模[量子计算](@entry_id:142712)机的资源开销至关重要。

### [逻辑量子比特](@entry_id:142662)

[平面码](@entry_id:136969)的精髓在于它如何利用其拓扑结构来定义和保护[逻辑量子比特](@entry_id:142662)。

#### 逻辑算符与[拓扑性质](@entry_id:141605)

一个**逻辑算符 (Logical Operator)** 是一个作用在数据[量子比特](@entry_id:137928)上、与所有稳定子对易，但本身不能由稳定子乘积生成的算符。在[平面码](@entry_id:136969)中，逻辑算符具有显著的拓扑特征：它们是沿着某种路径延伸的[泡利算符](@entry_id:144061)“链 (string)”。

一个逻辑量子比特由一对逻辑[泡利算符](@entry_id:144061) $X_L$ 和 $Z_L$ 定义。这些算符的形态取决于[晶格](@entry_id:196752)的**边界条件 (boundary conditions)**。例如，在一个矩形[晶格](@entry_id:196752)上，我们可以定义两种边界：“粗糙”边界（rough boundary），其上缺少某种类型的稳定子（如星形算符）；以及“平滑”边界（smooth boundary），其上稳定子结构完整。一个逻辑 $Z_L$ 算符通常是一条连接两个粗糙边界的泡利-$Z$ 链，而逻辑 $X_L$ 算符则是一条连接两个平滑边界的泡利-$X$ 链 [@problem_id:109955]。

逻辑算符的一个根本特征是其拓扑[等价类](@entry_id:156032)。任何一个逻辑算符乘以任意一个稳定子，会得到一个新的、在拓扑上“可变形”的算符，但它在码空间内实现的是完全相同的逻辑操作。这意味着逻辑信息不受算符链的具体路径影响，只受其拓扑性质（即连接哪些边界）的制约。

**[码距](@entry_id:140606) $d$** 在这里有了更深刻的物理解释：它等于最小权重的非平凡逻辑算符的权重。对于一个尺寸为 $d$ 的[平面码](@entry_id:136969)，连接相对边界的[最短路径](@entry_id:157568)长度就是 $d$。因此，任何想实现逻辑操作的算符链，都必须至少作用在 $d$ 个[量子比特](@entry_id:137928)上 [@problem_id:109955]。同样，任何想要破坏逻辑信息的物理错误，也必须形成一条至少长为 $d$ 的链，这使得长距离的纠缠保护成为可能。

#### 逻辑算符的代数关系

逻辑算符 $X_L$ 和 $Z_L$ 必须满足与单[量子比特](@entry_id:137928)[泡利算符](@entry_id:144061)相同的代数关系，特别是[反对易关系](@entry_id:153815)：$X_L Z_L = -Z_L X_L$。在[平面码](@entry_id:136969)中，这个代数关系源于其算符链的拓扑交集。

具体来说，两个泡利算符链 $P_1$ 和 $P_2$ 的[对易关系](@entry_id:136780)取决于它们共同作用的[量子比特](@entry_id:137928)数量。如果它们的支持集（即非平凡作用的[量子比特](@entry_id:137928)集合）相交于 $N$ 个[量子比特](@entry_id:137928)，则它们的关系为 $P_1 P_2 = (-1)^N P_2 P_1$。因此，为了使 $X_L$ 和 $Z_L$ 反对易，它们的路径在[晶格](@entry_id:196752)上必须有奇数个交点。通过精心设计边界条件，可以确保任何连接“粗糙”边界的 $Z_L$ 路径和任何连接“平滑”边界的 $X_L$ 路径都必然相交奇数次 [@problem_id:110026]。

逻辑 $Y_L$ 算符可以通过 $Y_L = i X_L Z_L$ 构建。其权重（即支持集大小）可以通过集合的容斥原理计算：$w(Y_L) = w(X_L) + w(Z_L) - |S_X \cap S_Z|$，其中 $S_X$ 和 $S_Z$ 分别是 $X_L$ 和 $Z_L$ 的支持集。对于由最小权重（即权重为 $d$）的 $X_L$ 和 $Z_L$ 算符构成的 $Y_L$，它们的路径是最短的直线。在 $d \times d$ 的网格上，一条水平直线和一条垂直直线必然且仅相交于一点。因此，$|S_X \cap S_Z|=1$，逻辑 $Y_L$ 的权重为 $d+d-1 = 2d-1$ [@problem_id:110070]。这个结果清晰地展示了逻辑算符的代数、权重和拓扑结构是如何紧密联系在一起的。

### [纠错](@entry_id:273762)机制

[平面码](@entry_id:136969)保护量子信息的核心在于其能够探测并修正物理错误。这个过程分为两个阶段：错误探测（获取综合症）和错误修正（解码）。

#### 错误的产生与探测

当一个物理错误，如单个[泡利算符](@entry_id:144061) $E$（$X, Y$ 或 $Z$），作用在某个数据[量子比特](@entry_id:137928)上时，它可能会与邻近的某些[稳定子算符](@entry_id:141669)**反对易**。根据量子力学原理，如果 $[S, E] = 0$，则 $S$ 的测量结果不变；如果 $\{S, E\} = SE + ES = 0$，则 $S$ 的测量值会从 $+1$ 翻转到 $-1$。

-   一个**泡利-$X$ 错误**作用在一个数据[量子比特](@entry_id:137928)上，它会与其所在的边的两个邻接**方格算符**（$Z$ 型）反对易，因为 $\{X, Z\} = 0$。因此，它会导致这两个方格的[稳定子测量](@entry_id:139265)结果变为 $-1$。
-   一个**泡利-$Z$ 错误**作用在一个数据[量子比特](@entry_id:137928)上，它会与其所在边的两个端点处的**顶点算符**（$X$ 型）反对易，因为 $\{Z, X\} = 0$。它将导致这两个顶点的[稳定子测量](@entry_id:139265)结果变为 $-1$。
-   一个**泡利-$Y$ 错误**，由于 $Y=iXZ$，它既与邻近的 $Z$ 型稳定子[反对易](@entry_id:186708)，也与邻近的 $X$ 型稳定子[反对易](@entry_id:186708)。因此，一个 $Y$ 错误会同时触发其周围的两个方格算符和两个顶点算符，总共四个稳定子的测量值翻转 [@problem_id:109987]。

那些测量结果为 $-1$ 的稳定子的位置被称为**综合症缺陷 (syndrome defects)**，或简称**任意子 (anyons)**。所有缺陷的位置集合构成了**错误综合症 (error syndrome)**。关键在于，单个局域错误只会在其周围产生一对缺陷。

我们可以通过一个具体的 $3 \times 3$ 的微型码来直观理解这个过程。假设中心[量子比特](@entry_id:137928) $q_5$ 发生了一个 $Y_5$ 错误。通过逐一检查 $Y_5$ 与所有四个稳定子生成元（$P_{Z1}, P_{X1}, P_{X2}, P_{Z2}$）的[对易关系](@entry_id:136780)，我们发现 $Y_5$ 与它们全部反对易，因为 $q_5$ 是所有稳定子的公共支持[量子比特](@entry_id:137928)。因此，产生的综合症是所有四个[稳定子测量](@entry_id:139265)值都变为 $-1$ [@problem_id:109980]。

#### [纠错](@entry_id:273762)算法：最小权完美匹配

获得了错误综合症之后，接下来的任务是**解码 (decoding)**，即根据综合症推断出最可能发生的物理错误，并施加一个修正算符。

多个连续的物理错误会形成一条**错误链 (error chain)**。这条链的**端点**恰好就是综合症缺陷产生的位置。因此，[解码问题](@entry_id:264478)可以被重新表述为：给定一组缺陷，找到连接它们的、最可能的错误链。在[物理错误率](@entry_id:138258) $p$ 很低的情况下，“最可能”等价于“权重最小”，即包含最少[单比特错误](@entry_id:165239)的链。

考虑由 $X$ 错误产生的 $Z$ 型综合症。两个缺陷之间的最短错误链长度等于它们在方格[对偶晶格](@entry_id:150046)上的**[曼哈顿距离](@entry_id:141126) (Manhattan distance)**，即 $d = n_x + n_y$，其中 $n_x$ 和 $n_y$ 是它们在两个坐标轴方向上的方格数之差。然而，连接同一对缺陷的[最短路径](@entry_id:157568)可能不止一条。从一个缺陷到另一个相距 $(n_x, n_y)$ 的缺陷，所有最短错误链的数量等于在网格上只允许向右和向上移动的路径数，即组[合数](@entry_id:263553) $\binom{n_x + n_y}{n_x}$ [@problem_id:109927]。这种路径的简并性是解码算法需要考虑的因素。

一个强大而通用的解码算法是**最小权[完美匹配](@entry_id:273916) (Minimum-Weight Perfect Matching, MWPM)**。该算法将[解码问题](@entry_id:264478)转化为一个经典的图论问题。首先，构建一个**综合症图**，其顶点代表所有观测到的缺陷。此外，通常会增加一个虚拟的“边界”顶点，以处理那些只产生单个缺陷的边界错误。然后，图中的任意两个顶点之间都连接一条边，其权重定义为连接这两个缺陷所需的最短错误链的长度（或与之相关的概率的负对数）。MWPM 算法的目标就是找到一种将所有顶点两两配对的方案（一个“完美匹配”），使得所有配对边的总权重最小。找到这个匹配后，对应的错误链就被认为是实际发生的错误，并可据此施加修正。

这个综合症图的规模会随着[码距](@entry_id:140606) $d$ 迅速增长。在一个 $d \times d$ 的[平面码](@entry_id:136969)中，存在 $\frac{d^2-1}{2}$ 个 $Z$ 型稳定子。因此，用于 $Z$ 综合症解码的 MWPM 图（包含一个边界顶点）的顶点数是 $V = \frac{d^2+1}{2}$。由于这是一个[完全图](@entry_id:266483)，其边的总数 $E = \binom{V}{2}$ 将达到 $\frac{d^4-1}{8}$ [@problem_id:109966]。这说明了经典解码部分虽然高效，但其计算复杂度也会随着代码规模而显著增加。

### 容错操作与性能

为了构建一个真正[容错](@entry_id:142190)的[量子计算](@entry_id:142712)机，不仅要能修正数据上的错误，还必须考虑测量过程本身可能引入的错误。

#### 综合症测量电路

稳定子的测量并非直接进行，而是通过一个**[辅助量子比特](@entry_id:144604) (ancilla qubit)** 间接完成。以一个权重为 $k$ 的[稳定子测量](@entry_id:139265)为例，标准电路包括：将辅助比特制备到叠加态，然后依次执行 $k$ 个[受控非门](@entry_id:180955)（CNOT），将辅助比特作为控制位，数据[量子比特](@entry_id:137928)作为目标位，最后再对辅助比特进行测量。

一个完整的综合症测量周期需要对所有 $d^2-1$ 个稳定子进行测量。对于一个[码距](@entry_id:140606)为 $d$ 的旋转[平面码](@entry_id:136969)，存在 $2(d-1)$ 个权重为2的稳定子和 $(d-1)^2$ 个权重为4的稳定子。因此，完成一轮完整的综合症测量所需的 CNOT 门总数为 $2 \times 2(d-1) + 4 \times (d-1)^2 = 4d(d-1)$ [@problem_id:110021]。这个数字表明，即使在静態存储量子信息时，维持其状态也需要大量的门操作，这些操作本身也可能出错。

如果测量电路出现故障，例如一个 CNOT 门被遗漏 [@problem_id:109910]，或者辅助比特在测量过程中自身发生了错误 [@problem_id:110004]，这些故障会传播到数据[量子比特](@entry_id:137928)上，形成有效的多比特错误。例如，在测量一个权重为4的 $X$ 稳定子 $S_X=X_1X_2X_3X_4$ 的过程中，如果辅助比特在第二个和第三个 CNOT 门之间发生了一个 $X$ 错误，这个错误会通过后续的 CNOT 门传播，最终在数据[量子比特](@entry_id:137928)上留下一个等效的 $X_3X_4$ 错误。同样，如果辅助比特的初态制备不完美，例如被制备在 $\cos(\theta)|+\rangle + i\sin(\theta)|-\rangle$ 而非理想的 $|+\rangle$ 态，那么即使数据[量子比特](@entry_id:137928)上确实发生了错误，该测量仍有 $\sin^2\theta$ 的概率会错过这个错误 [@problem_id:109920]。这些例子凸显了设计[容错](@entry_id:142190)电路和解码算法时考虑测量错误的极端重要性。

#### [逻辑错误率](@entry_id:137866)与[纠错阈值](@entry_id:143069)

[平面码](@entry_id:136969)的纠错能力不是无限的。如果[物理错误率](@entry_id:138258) $p$ 过高，多个物理错误可能会串通起来，形成一个与逻辑算符等效的错误链。这种错误链对于稳定子来说是“不可见”的，因为它与所有稳定子都对易，但它会改变[逻辑量子比特](@entry_id:142662)的状态，导致**[逻辑错误](@entry_id:140967) (logical error)**。

一个逻辑错误的发生概率与[码距](@entry_id:140606) $d$ 和[物理错误率](@entry_id:138258) $p$ 相关。导致逻辑错误的最简单方式是发生一个恰好构成最小权重逻辑算符的错误链。例如，在一个[码距](@entry_id:140606)为 $d=3$ 的代码中，一个最小权重的逻辑 $X_L$ 算符由3个物理 $X$ 错误构成。如果每个[量子比特](@entry_id:137928)发生 $X$ 错误的概率为 $p$，那么发生这样一个特定错误链的概率为 $p^3$。如果存在 $N_L$ 种不同的最小权重[逻辑错误](@entry_id:140967)链，那么在 $p$ 很小的情况下，总的[逻辑错误率](@entry_id:137866) $P_L$ 的主导项将是 $P_L \approx N_L \times p^{\lceil d/2 \rceil}$。对于 $d=3$ 的 $3 \times 3$ [平面码](@entry_id:136969)，存在3条这样的垂直链，因此 $P_L \approx 3p^3$ [@problem_id:110078]。这个关系表明，只要 $p$ 足够小，增加[码距](@entry_id:140606) $d$ 就可以指数级地抑制[逻辑错误率](@entry_id:137866)。

然而，这种抑制只在[物理错误率](@entry_id:138258) $p$ 低于某个**[纠错阈值](@entry_id:143069) (error threshold)** $p_c$ 时才有效。当 $p > p_c$ 时，增加[码距](@entry_id:140606)反而会引入更多错误，导致[逻辑错误率](@entry_id:137866)上升。这个阈值的存在，类似于统计物理学中的**[相变](@entry_id:147324) (phase transition)**。

我们可以通过一个简单的 **1D [重复码](@entry_id:267088)**来直观理解这个概念。该码的[纠错](@entry_id:273762)问题可以精确地映射到一个 **1D 随机键伊辛模型 (Random-Bond Ising Model, RBIM)**。在这个模型中，物理错误对应于铁磁键（$J>0$）和反铁磁键（$J0$）的随机[分布](@entry_id:182848)。[纠错](@entry_id:273762)成功的状态对应于模型的铁[磁有序](@entry_id:143206)相，而[纠错](@entry_id:273762)失败对应于顺磁无序相。[相变](@entry_id:147324)点，即阈值，发生在反铁磁键（错误）的概率 $p$ 使得系统无法维持[长程有序](@entry_id:155156)时。对于1D模型，这个[临界点](@entry_id:144653)是当铁磁键和反铁磁键的概率相等时，即 $p_c = 1-p_c$，给出 $p_c=0.5$ [@problem_id:109913]。

对于2D的[平面码](@entry_id:136969)，其阈值现象更为复杂，但与2D伊辛模型的[相变](@entry_id:147324)密切相关。通过更高级的对偶性（如Kramers-Wannier对偶），可以将物理错误概率 $p_v, p_h$ 与[对偶晶格](@entry_id:150046)上[伊辛模型](@entry_id:139066)的[耦合常数](@entry_id:747980) $K_h, K_v$ 联系起来。[逻辑错误率](@entry_id:137866)的指数衰减因子（等效于畴壁的线张力）可以表示为这些耦合常数的函数，从而精确计算[纠错阈值](@entry_id:143069) [@problem_id:109962]。

#### 时空视角下的解码

真实世界中的综合症数据是在时间序列上获得的。测量错误的存在使得[解码问题](@entry_id:264478)变得更加复杂。一个在时间 $t$ 发生的测量错误，会导致在 $(p, t)$ 时刻的综合症翻转，而在下一轮测量 $(p, t+1)$ 时（假设测量恢复正常），综合症会再次翻转。这在[时空图](@entry_id:201317)中表现为一个沿着时间轴的长度为1的边。

因此，一个现代的解码器必须在三维的**[时空图](@entry_id:201317) (spacetime graph)** 上运行MWPM。当解码器看到一个孤立的缺陷时，它必须权衡两种可能性：这个缺陷是一个空间错误链（如一个物理比特错误）的端点，并连接到另一个空间上的缺陷或边界；或者，它是一个时间上的测量错误的端点，并连接到下一个时间步的同位置缺陷。

这个决策取决于两种事件的相对概率。假设物理比特的退相干错误率为 $p$，而测量结果翻转的错误率为 $p_m$。解码器通过比较连接两个时空缺陷的边的权重 $W = -\ln(P_{\text{event}})$ 来做出判断。例如，当 $p/p_m = 3/2$ 时，一个由 $X$ 或 $Y$ 错误（概率为 $2p/3$）导致的最小空间错误的权重，恰好等于一个测量错误（概率为 $p_m$）导致的最小时间错误的权重。这个比率决定了解码器如何“看待”和解释综合症数据 [@problem_id:110060]。

#### 高级主题：相干错误

到目前为止，我们主要讨论了随机的、非相干的[泡利错误](@entry_id:146391)。然而，在实际硬件中，**相干错误 (coherent errors)** 也普遍存在。这类错误通常由系统[哈密顿量](@entry_id:172864)的微小偏差引起，例如微弱的、不想要的 $ZZ$ 相互作用。它们不是随机翻转比特，而是导致[量子态](@entry_id:146142)发生微小的、系统的旋转。

一个形如 $U(\theta) = \exp(-i \theta H_{\text{err}})$ 的相干错误，其中 $H_{\text{err}}$ 是所有相邻[量子比特](@entry_id:137928)间的 $ZZ$ 相互作用之和，会对[逻辑量子比特](@entry_id:142662)产生复杂的影响。尽管 $H_{\text{err}}$ 中的每一项都与 $Z_L$ 对易，但它们可能与 $X_L$ 反对易。这会导致一个原本的逻辑 $X_L$ 算符在错误演化后，不仅保留了 $X_L$ 分量，还可能产生一个 $Z_L$ 分量。这种从一个逻辑[泡利算符](@entry_id:144061)到另一个的“泄漏”可以通过**逻辑过程矩阵 (logical process matrix)** $\chi_L$ 的非对角项来量化。例如，$\chi_{X_L, Z_L}$ 描述了输入 $X_L$ 态在信道作用后变成 $Z_L$ 态的幅度。对于一个由系统性 $ZZ$ 错误构成的信道，可以推导出这个非对角项与[码距](@entry_id:140606) $d$ 和错误角度 $\theta$ 的函数关系，如 $\chi_{X_L, Z_L} = -\frac{1}{2}\sin(2d\theta)$ [@problem_id:109974]。这表明相干错误可能会导致[逻辑量子比特](@entry_id:142662)在布洛赫球上发生旋转，这是设计更高级别[容错协议](@entry_id:144300)时必须解决的又一个挑战。

本章系统地剖析了[平面码](@entry_id:136969)从基本结构到高级[纠错](@entry_id:273762)机制的各个方面。通过理解这些原理，我们能够欣赏到[表面码](@entry_id:145710)如何巧妙地利用二维几何的拓扑特性来抵御局域错误，并为构建可扩展的[容错量子计算机](@entry_id:141244)奠定了坚实的理论基础。