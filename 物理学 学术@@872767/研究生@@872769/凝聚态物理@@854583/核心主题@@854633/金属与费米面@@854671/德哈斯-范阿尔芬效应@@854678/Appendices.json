{"hands_on_practices": [{"introduction": "德哈斯-范阿尔芬 (dHvA) 效应的核心在于翁萨格关系式，它将可测量的磁化振荡周期与材料费米面的几何形状直接联系起来。本练习旨在通过一个二维电子气模型，让您实践如何应用这一基本原理。您将推导出振荡周期与载流子密度之间的关系，从而深刻理解 dHvA 效应如何成为探测电子结构的关键工具 [@problem_id:122328]。", "problem": "德哈斯-范阿尔芬（dHvA）效应指的是金属的磁化率随外加磁场 $B$ 变化的振荡现象。这些振荡在磁场倒数 $1/B$ 上是周期性的。该周期 $\\Delta(1/B)$ 通过翁萨格关系与材料费米面的几何形状有着根本的联系：\n$$\n\\Delta\\left(\\frac{1}{B}\\right) = \\frac{2\\pi e}{\\hbar A_F}\n$$\n其中 $e$ 是基本电荷，$\\hbar$ 是约化普朗克常数，$A_F$ 是k空间中垂直于磁场方向的费米面极端截面积。\n\n考虑一个二维电子气（2DEG），磁场垂直于该气体平面施加。该二维电子气中的电子具有各向同性但非抛物线性的能量色散关系，由下式给出：\n$$\nE(1 + \\alpha E) = \\frac{\\hbar^2 k^2}{2m^*}\n$$\n这里，$E$ 是电子能量，$k$ 是二维波矢的模长，$m^*$ 是导带边有效质量，$\\alpha$ 是一个常数非抛物线性参数。该系统具有一个恒定的、自旋简并的载流子浓度 $n$。\n\n计算该系统的德哈斯-范阿尔芬振荡周期 $\\Delta(1/B)$。用载流子浓度 $n$、基本电荷 $e$ 和约化普朗克常数 $\\hbar$ 来表示你的答案。", "solution": "德哈斯-范阿尔芬振荡周期由翁萨格关系给出：\n\n$$\n\\Delta\\left(\\frac{1}{B}\\right) = \\frac{2\\pi e}{\\hbar A_F}\n$$\n\n其中 $A_F$ 是垂直于磁场方向的费米面极端截面积。对于一个磁场垂直施加于其平面的二维电子气（2DEG），由于色散关系是各向同性的，其费米面是圆形的，而 $A_F$ 是k空间中费米圆盘的面积。\n\n能量色散关系为：\n\n$$\nE(1 + \\alpha E) = \\frac{\\hbar^2 k^2}{2m^*}\n$$\n\n在费米能 $E_F$ 处，该关系变为：\n\n$$\nE_F(1 + \\alpha E_F) = \\frac{\\hbar^2 k_F^2}{2m^*}\n$$\n\n其中 $k_F$ 是费米波矢。载流子浓度 $n$ 是恒定的并且是自旋简并的（简并度 $g = 2$）。单位面积的态密度为：\n\n$$\ng(E) = \\frac{m^*}{\\pi \\hbar^2} (1 + 2\\alpha E)\n$$\n\n载流子浓度为：\n\n$$\nn = \\int_0^{E_F} g(E)  dE = \\frac{m^*}{\\pi \\hbar^2} \\int_0^{E_F} (1 + 2\\alpha E)  dE\n$$\n\n计算该积分：\n\n$$\nn = \\frac{m^*}{\\pi \\hbar^2} \\left[ E + \\alpha E^2 \\right]_0^{E_F} = \\frac{m^*}{\\pi \\hbar^2} (E_F + \\alpha E_F^2)\n$$\n\n使用在 $E_F$ 处的色散关系：\n\n$$\nE_F + \\alpha E_F^2 = \\frac{\\hbar^2 k_F^2}{2m^*}\n$$\n\n代入：\n\n$$\nn = \\frac{m^*}{\\pi \\hbar^2} \\cdot \\frac{\\hbar^2 k_F^2}{2m^*} = \\frac{k_F^2}{2\\pi}\n$$\n\n解出 $k_F^2$：\n\n$$\nk_F^2 = 2\\pi n\n$$\n\n极端截面积 $A_F$ 是费米圆盘的面积：\n\n$$\nA_F = \\pi k_F^2 = \\pi (2\\pi n) = 2\\pi^2 n\n$$\n\n将 $A_F$ 代入翁萨格关系：\n\n$$\n\\Delta\\left(\\frac{1}{B}\\right) = \\frac{2\\pi e}{\\hbar (2\\pi^2 n)} = \\frac{e}{\\pi \\hbar n}\n$$", "answer": "$$ \\boxed{\\dfrac{e}{\\pi \\hbar n}} $$", "id": "122328"}, {"introduction": "dHvA 振荡的频率揭示了费米面的尺寸，而其振幅则包含了关于电子相互作用的更深层次信息。本练习将引导您探索控制振荡振幅的自旋因子，这是 Lifshitz-Kosevich 公式中的一个关键组成部分。通过分析“自旋分裂零点”——基频振荡因自旋效应而消失的特定条件——您将学会如何利用 dHvA 信号来揭示电子有效质量 $m^*$ 和 g 因子 $g$ 等内在属性 [@problem_id:64375]。", "problem": "德哈斯-范阿尔芬 (dHvA) 效应是指金属的磁化率随外加磁场倒数 $1/B$ 变化的周期性振荡。磁化强度的振荡部分可以用 Lifshitz-Kosevich (LK) 公式来描述，该公式将信号表示为关于 $1/B$ 的傅里叶级数：\n$$\n\\tilde{M}(T, B) \\propto \\sum_{p=1}^{\\infty} A_p \\cos\\left(2\\pi p \\frac{F}{B} + \\phi_p\\right)\n$$\n其中，$p$ 是谐波指数，$F$ 是与极端费米面面积相关的 dHvA 频率，$A_p$ 是第 $p$ 次谐波的振幅。此振幅是几个因子的乘积，其中包括一个考虑电子自旋与磁场相互作用（塞曼效应）的项。第 $p$ 次谐波的这个自旋因子 $R_S(p)$ 由下式给出：\n$$\nR_S(p) = \\cos\\left(p \\pi \\frac{g m^*}{2 m_e}\\right)\n$$\n其中 $g$ 是电子的朗德 g 因子，$m^*$ 是其有效质量，$m_e$ 是自由电子质量。\n\n在特定条件下，基波（$p=1$）的贡献可以被完全抑制，这种现象被称为“自旋分裂零点”。对于一个假想的单带金属，求出能导致在其 dHvA 信号中观察到这种自旋分裂零点的有效质量与自由电子质量之比 $m^*/m_e$ 的最小正值。用 g 因子 $g$ 的闭合形式表达式来表示你的答案。", "solution": "问题要求的是德哈斯-范阿尔芬振荡的基波（$p=1$）因自旋因子而消失的条件。\n\n1.  第 $p$ 次谐波的振幅 $A_p$ 与自旋因子 $R_S(p)$ 成正比。基波的完全抵消意味着其振幅 $A_1$ 必须为零。这要求 $p=1$ 时的自旋因子为零。\n$$\nR_S(1) = 0\n$$\n\n2.  基波的自旋因子可以通过在给定公式中设置 $p=1$ 得到：\n$$\nR_S(1) = \\cos\\left(\\pi \\frac{g m^*}{2 m_e}\\right)\n$$\n\n3.  将此表达式设为零，即可得到自旋分裂零点的条件：\n$$\n\\cos\\left(\\pi \\frac{g m^*}{2 m_e}\\right) = 0\n$$\n\n4.  余弦函数在其参数为 $\\pi/2$ 的奇数倍时为零。我们可以将其表示为：\n$$\n\\pi \\frac{g m^*}{2 m_e} = \\left(N + \\frac{1}{2}\\right)\\pi\n$$\n其中 $N$ 是一个整数。\n\n5.  我们可以消去方程两边的因子 $\\pi$：\n$$\n\\frac{g m^*}{2 m_e} = N + \\frac{1}{2}\n$$\n\n6.  我们要求解的是比值 $m^*/m_e$。为此比值求解方程可得：\n$$\n\\frac{m^*}{m_e} = \\frac{2}{g}\\left(N + \\frac{1}{2}\\right) = \\frac{2N+1}{g}\n$$\n\n7.  物理量 $m^*$、$m_e$ 和 $g$ 都是正的物理常数。因此，比值 $m^*/m_e$ 必须为正。这意味着 $2N+1$ 也必须为正。满足此条件的整数 $N$ 为 $N = 0, 1, 2, \\dots$。\n\n8.  问题要求比值 $m^*/m_e$ 的最小非零值。这对应于 $N$ 可能的最小整数值，即 $N=0$。\n\n9.  将 $N=0$ 代入比值的表达式中，得到所需结果：\n$$\n\\left(\\frac{m^*}{m_e}\\right)_{\\min} = \\frac{2(0)+1}{g} = \\frac{1}{g}\n$$\n这是基波 dHvA 谐波被抑制的最小正比值。", "answer": "$$\n\\boxed{\\frac{1}{g}}\n$$", "id": "64375"}, {"introduction": "从理论计算走向实验数据分析是物理学研究的关键一步。本练习模拟了分析真实 dHvA 实验数据的完整流程，要求您编写代码来处理一个包含背景信号和噪声的模拟磁化数据集。您将亲手实践将非均匀磁场数据重采样到均匀的 $1/B$ 网格上、通过多项式拟合去除背景、以及应用窗函数以减少傅里叶变换中的频谱泄漏。这项计算实践旨在将 dHvA 效应的理论知识与实验物理学家日常使用的强大数据处理技术联系起来 [@problem_id:2812572]。", "problem": "您将执行一项基于材料物理学中德哈斯-范阿尔芬 (dHvA) 效应研究的任务。在磁场存在的情况下，由于电子轨道的朗道量子化，磁化响应会表现出在反磁场变量中呈周期性的振荡。目标是通过在反磁场中构建均匀网格、对数据进行切趾以减轻谱泄漏，并计算快速傅里叶变换 (FFT) 来识别主导频率分量，从而从有限窗口的磁化数据集中提取振荡频率。您的程序必须实现完整的处理流程并计算最终的数值答案。\n\n请从以下基本原理开始，不要使用任何关于处理结果的快捷公式：\n- 当改变磁场时，朗道量子化会在热力学量中产生振荡贡献，这些贡献在反磁场变量中是周期性的。因此，任何用于揭示这些周期性的离散傅里叶变换 (DFT) 分析都必须针对反磁场变量执行，因为周期性体现在 $1/B$ 上，而不是 $B$。\n- 离散傅里叶变换要求其自变量（在此情况下为 $x = 1/B$）上的数据是均匀采样的。\n- 对有限长度的时间序列进行加窗（切趾）处理，用于减少因在有限采样区间上隐式乘以矩形窗而产生的谱泄漏。\n\n您的任务是：\n- 给定一个在有限磁场窗口 $[B_{\\min},B_{\\max}]$ 内观测到的磁化数据集 $M(B)$，在反磁场变量 $x = 1/B$ 中构建一个均匀网格，将磁化强度插值到该网格上，去除随 $x$ 缓慢变化的背景趋势，应用一个切趾窗，并计算快速傅里叶变换 (FFT)。\n- 从 FFT 幅度谱中，识别主导的 dHvA 频率。对于每个测试用例，返回所需数量的主导峰值频率。频率必须以特斯拉 (T) 表示，这是德哈斯-范阿尔芬频率的自然单位，因为在 $x=1/B$ 中的傅里叶变换的频率轴单位是周期/特斯拉。频率必须四舍五入到最近的整数（单位为 $\\mathrm{T}$）。\n- 您必须在代码的结构和附带的解决方案中，为每个预处理步骤提供理由：均匀 $1/B$ 网格构建、去趋势和 FFT 前的切趾处理。\n\n数据模型和确定性测试套件：\n- 对于每个测试用例，磁化数据是确定性地生成的，由一个在 $B$ 中缓慢变化的多项式背景、一个在 $1/B$ 中呈周期性的振荡贡献、一个弱振幅包络因子和一个小的确定性伪噪声项相加而成。具体来说，对于索引为 $i \\in \\{0,1,\\dots,N-1\\}$ 的样本，定义\n  - $B_i = \\mathrm{sort}\\left(B_{\\min} + \\frac{B_{\\max} - B_{\\min}}{N-1} \\, i + \\varepsilon \\sin\\!\\left(\\frac{2\\pi i}{N-1}\\right)\\right)$，\n  - $x_i = 1/B_i$，\n  - $M_i = \\underbrace{c_0 + c_1 B_i + c_2 B_i^2}_{\\text{B 中的背景}} + \\underbrace{\\sum_{j=1}^{J} A_j B_i^{-1/2} \\sin\\!\\left(2\\pi \\frac{F_j}{B_i} + \\phi_j\\right)}_{\\text{1/B 中呈周期性的 dHvA 振荡}} + \\underbrace{\\eta_1 \\sin\\!\\left(2\\pi \\frac{B_i}{\\tau_1}\\right) + \\eta_2 \\cos\\!\\left(2\\pi \\frac{B_i}{\\tau_2}\\right)}_{\\text{确定性小伪噪声}}.$\n- 在所有测试用例中，为伪噪声使用以下确定性常数：$\\tau_1 = 1.3\\,\\mathrm{T}$，$\\tau_2 = 0.7\\,\\mathrm{T}$，$\\eta_1 = 0.02$ 和 $\\eta_2 = 0.015$。\n\n为每个测试用例实施以下处理流程：\n- 构建 $x_i = 1/B_i$ 并按 $x_i$ 升序对数据对 $(x_i, M_i)$ 进行排序。\n- 将 $\\{(x_i, M_i)\\}$ 插值到一个覆盖区间 $[x_{\\min}, x_{\\max}]$ 的均匀网格 $\\{x_k\\}$ 上，其中 $x_{\\min} = \\min_i x_i$，$x_{\\max} = \\max_i x_i$。该网格在 $x$ 上必须是均匀的，有 $N_{\\mathrm{grid}} = N$ 个点。使用稳定的分段线性插值。\n- 通过减去一个关于 $x$ 的 $d=2$ 次多项式拟合来对插值序列进行去趋势处理。即，将 $P_2(x) = a_0 + a_1 x + a_2 x^2$ 拟合到插值后的 $M(x)$，并使用 $M_{\\mathrm{detrend}}(x) = M(x) - P_2(x)$。\n- 对去趋势后的数据应用一个切趾（窗）函数 $w(x)$，例如，汉宁窗 $w_k = \\tfrac{1}{2}\\big(1 - \\cos(2\\pi k/(N_{\\mathrm{grid}}-1))\\big)$，其中 $k = 0,\\dots,N_{\\mathrm{grid}}-1$。\n- 使用为均匀采样优化的实数到复数 FFT 计算单边 FFT 幅度谱 $| \\mathcal{F}\\{ M_{\\mathrm{detrend}}(x) w(x) \\} |$，并使用均匀 $x$ 网格的采样间隔 $\\Delta x$ 计算相应的频率轴 $f$（单位为 $\\mathrm{T}$）。对于非负的 $k$，使用 $f_k = \\frac{k}{N_{\\mathrm{grid}} \\Delta x}$。\n- 通过在 FFT 幅度谱中寻找具有足够突显度的局部最大值来识别峰值频率。排除零频分量。为保证数值鲁棒性，您可以忽略相对于所提供磁场窗口而言非常低的频率（例如，低于某个小的下限值）。\n\n测试套件：\n- 共有四个测试用例。对每个用例，指定 $(B_{\\min}, B_{\\max}, N, \\varepsilon, J, \\{F_j\\}_{j=1}^J, \\{A_j\\}_{j=1}^J, \\{\\phi_j\\}_{j=1}^J, c_0, c_1, c_2)$ 以及要返回的主导频率数量。\n  1. 情况A（单频，中等窗口）：$B_{\\min} = 7\\,\\mathrm{T}$, $B_{\\max} = 15\\,\\mathrm{T}$, $N = 601$, $\\varepsilon = 0.02\\,\\mathrm{T}$, $J = 1$, $F_1 = 530\\,\\mathrm{T}$, $A_1 = 1.2$, $\\phi_1 = 0.3$, $c_0 = 0.5$, $c_1 = 0.1$, $c_2 = 0$, 返回 $K=1$ 个主导频率。\n  2. 情况B（双频）：$B_{\\min} = 8\\,\\mathrm{T}$, $B_{\\max} = 20\\,\\mathrm{T}$, $N = 801$, $\\varepsilon = 0.015\\,\\mathrm{T}$, $J = 2$, $(F_1,F_2) = (380\\,\\mathrm{T}, 1050\\,\\mathrm{T})$, $(A_1,A_2) = (1.0, 0.6)$, $(\\phi_1,\\phi_2) = (-0.2, 1.0)$, $(c_0,c_1,c_2) = (-0.3, 0.05, 0.002)$, 返回 $K=2$ 个主导频率。\n  3. 情况C（短窗口，分辨率有限）：$B_{\\min} = 14\\,\\mathrm{T}$, $B_{\\max} = 16\\,\\mathrm{T}$, $N = 401$, $\\varepsilon = 0.005\\,\\mathrm{T}$, $J = 1$, $F_1 = 800\\,\\mathrm{T}$, $A_1 = 1.0$, $\\phi_1 = 0.5$, $(c_0,c_1,c_2) = (0.1, 0.02, -0.0005)$, 返回 $K=1$ 个主导频率。\n  4. 情况D（强背景和伪噪声）：$B_{\\min} = 5\\,\\mathrm{T}$, $B_{\\max} = 10\\,\\mathrm{T}$, $N = 501$, $\\varepsilon = 0.02\\,\\mathrm{T}$, $J = 1$, $F_1 = 600\\,\\mathrm{T}$, $A_1 = 0.6$, $\\phi_1 = -1.0$, $(c_0,c_1,c_2) = (1.0, 0.8, 0.0)$, 返回 $K=1$ 个主导频率。\n\n数值和单位要求：\n- 所有返回的频率都以特斯拉 (T) 表示，并将每个值四舍五入到最近的整数。因为傅里叶变换是针对以 $\\mathrm{T}^{-1}$ 为单位采样的 $x = 1/B$ 执行的，所以频率轴的单位是 $\\mathrm{T}$。\n- 不会出现角度单位。不要返回百分比；所有数字都必须是指定单位下的纯数字。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的整数列表的列表，单位为特斯拉，按测试用例的顺序排列 $[\\text{情况 A}, \\text{情况 B}, \\text{情况 C}, \\text{情况 D}]$。例如，格式必须与以下完全一样\n  - $[[f_A],[f_{B,1},f_{B,2}],[f_C],[f_D]]$\n- 除了方括号括起来、逗号分隔的列表中的空格外，不要包含任何额外的文本或空格。\n\n您的程序必须是一个完整、可运行的实现，它根据上述公式确定性地生成四个数据集，执行处理流程，并以指定格式打印最终的数值结果。代码必须是自包含的，并且不得需要任何用户输入或外部文件。唯一允许使用的库是 Python 标准库、NumPy 和 SciPy。", "solution": "所提出的问题是计算材料物理学中一个有效且定义明确的任务。它要求实现一个标准的数据分析流程，用于从模拟的磁化信号中提取德哈斯-范阿尔芬 (dHvA) 振荡频率。该问题具有科学依据、形式上明确且客观。它没有违反任何无效标准。因此，我将提供一个完整的解决方案。\n\ndHvA效应的核心原理是，在强磁场 $B$ 存在下，电子轨道量子化为朗道能级，导致热力学性质（如磁化强度 $M$）发生振荡。这些振荡的周期性不体现在磁场 $B$ 本身，而是体现在其倒数 $x = 1/B$ 上。这些振荡的频率 $F$（以特斯拉为单位表示）与垂直于磁场的费米面极端截面积成正比。目标是从给定的信号 $M(B)$ 中提取这些频率。\n\n所提供的数据是通过以下模型确定性生成的：\n$$\nM_i = \\underbrace{c_0 + c_1 B_i + c_2 B_i^2}_{\\text{背景}} + \\underbrace{\\sum_{j=1}^{J} A_j B_i^{-1/2} \\sin\\!\\left(2\\pi \\frac{F_j}{B_i} + \\phi_j\\right)}_{\\text{dHvA 振荡}} + \\underbrace{\\eta_1 \\sin\\!\\left(2\\pi \\frac{B_i}{\\tau_1}\\right) + \\eta_2 \\cos\\!\\left(2\\pi \\frac{B_i}{\\tau_2}\\right)}_{\\text{伪噪声}}\n$$\n其中磁场样本 $B_i$ 近似均匀但并非完全均匀。分析流程必须能够稳健地处理非均匀采样、背景信号和有限窗口效应，以准确确定频率 $F_j$。以下步骤详细说明了该方法，并为每个关键处理阶段提供了理由。\n\n**步骤 1：网格变换和重采样**\n\n频率分析的基本工具是傅里叶变换。离散傅里叶变换 (DFT) 及其高效实现——快速傅里叶变换 (FFT)——要求输入信号在其自变量的均匀间隔上采样。dHvA 效应的物理性质决定了磁化的振荡部分在 $x=1/B$ 中是周期性的。因此，傅里叶分析的自变量必须是 $x$。\n\n原始数据以数据对 $(B_i, M_i)$ 的形式提供，其中 $B_i$ 样本的间距不均匀。因此，反磁场中的样本 $x_i = 1/B_i$ 也是非均匀的。为了应用 FFT，我们必须首先将磁化数据重采样到 $x$ 变量的均匀网格上。\n\n流程如下：\n1. 对于每次测量 $(B_i, M_i)$，计算反磁场 $x_i = 1/B_i$。\n2. 由于原始的 $B_i$ 值是排序的，因此得到的 $x_i$ 值将按降序排序。数据对 $(x_i, M_i)$ 按 $x_i$ 升序排序，为插值做准备。\n3. 构建一个新的均匀网格 $\\{x_k\\}_{k=0}^{N_{\\mathrm{grid}}-1}$，跨越数据的整个范围，从 $x_{\\min} = \\min(x_i)$ 到 $x_{\\max} = \\max(x_i)$。此网格上的点数 $N_{\\mathrm{grid}}$ 选择为与原始数据点数 $N$ 相等。网格间距是均匀的：$\\Delta x = (x_{\\max} - x_{\\min}) / (N_{\\mathrm{grid}}-1)$。\n4. 通过对排序后的非均匀数据 $(x_i, M_i)$ 应用分段线性插值，获得该均匀网格上的磁化值 $M(x_k)$。选择此方法是因为其稳定性和计算效率。\n\n**步骤 2：背景扣除（去趋势）**\n\n磁化信号 $M(x)$ 是期望的高频 dHvA 振荡与一个缓慢变化的背景分量的叠加。在所提供的模型中，此背景源于多项式 $c_0 + c_1 B + c_2 B^2$，当视为 $x = 1/B$ 的函数时，它变成了一个非多项式趋势。这个低频趋势，如果不被移除，将在零频及附近主导傅里叶谱。当 FFT 将信号视为周期信号时，此趋势的起始值和结束值之间的不连续性会引入显著的谱泄漏，可能会掩盖较弱的 dHvA 峰。\n\n为了分离振荡分量，必须减去这个背景趋势。这个过程称为去趋势。一种常用且有效的方法是拟合一个低阶多项式到信号 $M(x_k)$ 上，然后从数据中减去这个拟合。问题指定拟合一个关于变量 $x$ 的 $d=2$ 次多项式：\n$$\nP_2(x_k) = a_0 + a_1 x_k + a_2 x_k^2\n$$\n系数 $(a_0, a_1, a_2)$ 通过对插值数据 $M(x_k)$ 进行最小二乘拟合来确定。然后计算去趋势后的信号为：\n$$\nM_{\\mathrm{detrend}}(x_k) = M(x_k) - P_2(x_k)\n$$\n此过程有效地移除了缓慢变化的分量，留下一个围绕零点振荡的信号，这对于后续的傅里叶分析是理想的。\n\n**步骤 3：切趾（加窗）**\n\n分析有限长度的数据段在数学上等同于将一个无限信号乘以一个矩形窗函数，该函数在测量区间 $[x_{\\min}, x_{\\max}]$ 上为 1，在其他地方为 0。这个矩形窗在 $x$ 域中的锐利边缘，会导致在频域中与一个 $\\mathrm{sinc}$ 函数进行卷积。这导致每个真实的谱峰被加宽并伴有大的旁瓣，这种效应被称为谱泄漏。这些旁瓣可能会掩盖附近较弱的峰，或者被误认为是真实的频率。\n\n为了减轻这种情况，将去趋势后的数据乘以一个切趾（或窗）函数 $w(x_k)$，该函数在区间的边界处平滑地衰减到零。这降低了信号截断的锐度，从而以稍微加宽主峰为代价来抑制频谱中的旁瓣。对于这个问题，指定了汉宁窗：\n$$\nw_k = \\frac{1}{2} \\left(1 - \\cos\\left(\\frac{2\\pi k}{N_{\\mathrm{grid}}-1}\\right)\\right) \\quad \\text{对于 } k = 0, \\dots, N_{\\mathrm{grid}}-1\n$$\n加窗后的信号为 $M_{\\mathrm{windowed}}(x_k) = M_{\\mathrm{detrend}}(x_k) \\cdot w_k$。\n\n**步骤 4：傅里叶变换和峰值识别**\n\n经过预处理步骤后，信号已准备好进行傅里叶分析。\n1. 将一维实数到复数的快速傅里叶变换 (FFT) 应用于最终信号 $M_{\\mathrm{windowed}}(x_k)$。\n2. 计算与 FFT 输出相对应的频率轴。频率 $f_k$ 由 $f_k = k / (N_{\\mathrm{grid}} \\Delta x)$ 给出，其中 $\\Delta x$ 是反磁场域中的均匀采样间隔。$f_k$ 的单位是特斯拉 ($\\mathrm{T}$)，因为 $\\Delta x$ 的单位是 $\\mathrm{T}^{-1}$。\n3. 计算复数 FFT 输出的幅度以获得功率谱。\n4. dHvA 频率对应于该幅度谱中明显峰值的位置。通过寻找局部最大值来识别峰值。忽略零频分量（直流偏移），因为它包含了任何未完全减去的背景的残余。同时应用一个低频下限，以避免由去趋势过程的伪影可能引起的伪峰。\n5. 按幅度（突显度）对已识别的峰进行排序，并按每个测试用例的指定，选择前 $K$ 个频率作为结果。然后将这些频率按升序排序并四舍五入到最近的整数。\n\n这个完整的流程确保了从原始磁化数据中稳健且具有物理意义地提取 dHvA 频率。", "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the dHvA analysis for all test cases.\n    \"\"\"\n\n    # Deterministic constants for pseudo-noise\n    tau1 = 1.3\n    tau2 = 0.7\n    eta1 = 0.02\n    eta2 = 0.015\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"name\": \"A\", \"B_min\": 7.0, \"B_max\": 15.0, \"N\": 601, \"epsilon\": 0.02,\n            \"J\": 1, \"F\": [530.0], \"A\": [1.2], \"phi\": [0.3],\n            \"c0\": 0.5, \"c1\": 0.1, \"c2\": 0.0, \"K\": 1\n        },\n        {\n            \"name\": \"B\", \"B_min\": 8.0, \"B_max\": 20.0, \"N\": 801, \"epsilon\": 0.015,\n            \"J\": 2, \"F\": [380.0, 1050.0], \"A\": [1.0, 0.6], \"phi\": [-0.2, 1.0],\n            \"c0\": -0.3, \"c1\": 0.05, \"c2\": 0.002, \"K\": 2\n        },\n        {\n            \"name\": \"C\", \"B_min\": 14.0, \"B_max\": 16.0, \"N\": 401, \"epsilon\": 0.005,\n            \"J\": 1, \"F\": [800.0], \"A\": [1.0], \"phi\": [0.5],\n            \"c0\": 0.1, \"c1\": 0.02, \"c2\": -0.0005, \"K\": 1\n        },\n        {\n            \"name\": \"D\", \"B_min\": 5.0, \"B_max\": 10.0, \"N\": 501, \"epsilon\": 0.02,\n            \"J\": 1, \"F\": [600.0], \"A\": [0.6], \"phi\": [-1.0],\n            \"c0\": 1.0, \"c1\": 0.8, \"c2\": 0.0, \"K\": 1\n        },\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        B_min, B_max = case[\"B_min\"], case[\"B_max\"]\n        epsilon = case[\"epsilon\"]\n        \n        # --- 1. Data Generation ---\n        i = np.arange(N)\n        B_raw = B_min + (B_max - B_min) / (N - 1) * i + epsilon * np.sin(2 * np.pi * i / (N - 1))\n        B = np.sort(B_raw)\n        \n        # Background\n        M = case[\"c0\"] + case[\"c1\"] * B + case[\"c2\"] * B**2\n        \n        # dHvA oscillations\n        dHvA_signal = np.zeros_like(B)\n        for j in range(case[\"J\"]):\n            F, A, phi = case[\"F\"][j], case[\"A\"][j], case[\"phi\"][j]\n            dHvA_signal += A * B**(-0.5) * np.sin(2 * np.pi * F / B + phi)\n        M += dHvA_signal\n        \n        # Pseudo-noise\n        noise = eta1 * np.sin(2 * np.pi * B / tau1) + eta2 * np.cos(2 * np.pi * B / tau2)\n        M += noise\n\n        # --- 2. Processing Pipeline ---\n        \n        # Construct inverse field grid and sort\n        x = 1.0 / B\n        # B is sorted ascending, so x is sorted descending. Reverse to sort ascending.\n        x_sorted = x[::-1]\n        M_sorted = M[::-1]\n\n        # Interpolate onto a uniform grid in x\n        x_min, x_max = x_sorted[0], x_sorted[-1]\n        N_grid = N\n        x_uniform = np.linspace(x_min, x_max, N_grid)\n        M_uniform = np.interp(x_uniform, x_sorted, M_sorted)\n        \n        # Detrend by subtracting a 2nd degree polynomial fit in x\n        poly_coeffs = np.polyfit(x_uniform, M_uniform, 2)\n        poly_fit = np.polyval(poly_coeffs, x_uniform)\n        M_detrended = M_uniform - poly_fit\n        \n        # Apply Hann window (apodization)\n        hann_window = np.hanning(N_grid)\n        M_windowed = M_detrended * hann_window\n        \n        # Compute FFT\n        delta_x = x_uniform[1] - x_uniform[0]\n        fft_freqs = np.fft.rfftfreq(N_grid, d=delta_x)\n        fft_magnitudes = np.abs(np.fft.rfft(M_windowed))\n\n        # --- 3. Peak Identification ---\n        \n        # Find peaks with sufficient prominence, ignoring low frequencies\n        # A low frequency floor is set to avoid spurious peaks from detrending artifacts.\n        min_freq_threshold = 50.0  # In Tesla\n        \n        # Prominence is set relative to the max signal amplitude for robustness\n        prominence = 0.1 * np.max(fft_magnitudes) \n        \n        peak_indices, properties = find_peaks(fft_magnitudes, prominence=prominence)\n        \n        # Filter peaks by frequency threshold\n        valid_peaks = []\n        for p_idx in peak_indices:\n            freq = fft_freqs[p_idx]\n            if freq >= min_freq_threshold:\n                valid_peaks.append({'freq': freq, 'mag': fft_magnitudes[p_idx]})\n        \n        # Sort peaks by magnitude in descending order\n        valid_peaks.sort(key=lambda p: p['mag'], reverse=True)\n        \n        # Select top K frequencies\n        K = case[\"K\"]\n        top_freqs = [p['freq'] for p in valid_peaks[:K]]\n        \n        # Sort frequencies in ascending order for consistent output\n        top_freqs.sort()\n        \n        # Round to the nearest integer\n        result_freqs = [int(round(f)) for f in top_freqs]\n        \n        final_results.append(result_freqs)\n    \n    # Format and print the final output\n    # Use replace to remove spaces from str(list) conversion\n    output_str = f\"[{','.join(map(str, final_results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2812572"}]}