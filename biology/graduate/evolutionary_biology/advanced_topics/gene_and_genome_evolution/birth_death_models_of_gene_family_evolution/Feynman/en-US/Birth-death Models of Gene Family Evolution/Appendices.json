{
    "hands_on_practices": [
        {
            "introduction": "A core question in gene family evolution is understanding the long-term fate of a nascent family. This exercise challenges you to derive one of the most fundamental results for the linear birth-death process: the probability that a gene family goes extinct over a given time period. By working from first principles, you will gain a deeper appreciation for the model's dynamics and the mathematical framework used to describe its stochastic behavior .",
            "id": "2694516",
            "problem": "Consider a continuous-time linear birth-death branching process modeling the size of a gene family. Each gene copy independently duplicates at per-copy rate $\\lambda > 0$ (gene duplication) and is lost at per-copy rate $\\mu > 0$ (gene loss). Assume that these rates are constant over time, that lineages evolve independently conditional on the process history (the branching property), and that there is no origination from outside the family except by duplication. Let $t \\ge 0$ denote time, and suppose the family starts at time $t=0$ with $i \\in \\mathbb{N}$ copies. Define $q_{1}(t)$ as the probability that the gene family is extinct (has size $0$) by time $t$ when starting from a single copy at time $0$.\n\nStarting only from the Markov property of the process and the independence of descendant lineages, derive a closed-form expression for $q_{1}(t)$ under the assumption $\\lambda \\ne \\mu$. Then, using the branching property, express the extinction probability by time $t$ when starting from $i$ copies, $q_{i}(t)$, in terms of $q_{1}(t)$. Provide a single closed-form analytical expression for $q_{i}(t)$ as a function of $\\lambda$, $\\mu$, $t$, and $i$. No numerical evaluation or rounding is required, and no units should be included in the final expression.",
            "solution": "The problem statement describes a continuous-time linear birth-death process, a standard model in stochastic theory. The problem is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It is a valid problem of mathematical biology.\n\nLet $N(t)$ denote the number of gene copies at time $t$. We are asked to find the probability of extinction by time $t$, given an initial number of copies $i$, which we denote as $q_{i}(t) = P(N(t) = 0 | N(0) = i)$. The parameters are the per-copy duplication rate $\\lambda > 0$ and the per-copy loss rate $\\mu > 0$, with the constraint $\\lambda \\ne \\mu$.\n\nFirst, we derive the expression for $q_{1}(t)$, the probability of extinction starting from a single copy. We can formulate a differential equation for $q_{1}(t)$ by considering the evolution of the process over an infinitesimally small time interval $\\Delta t$. By the law of total probability, conditioning on the event in the interval $[0, \\Delta t)$:\n$q_{1}(t + \\Delta t) = P(N(t+\\Delta t)=0 | N(0)=1)$.\n\nThe events in $[0, \\Delta t)$ are:\n1.  A duplication occurs with probability $\\lambda \\Delta t + o(\\Delta t)$, resulting in $2$ copies. By the branching property and temporal homogeneity, for the family to be extinct by time $t+\\Delta t$, both independent lineages must go extinct in the remaining time $t$. The probability for this is $(q_1(t))^2$.\n2.  A loss occurs with probability $\\mu \\Delta t + o(\\Delta t)$, resulting in $0$ copies. The family is extinct, so the probability of extinction is $1$.\n3.  No event occurs with probability $1 - (\\lambda + \\mu)\\Delta t + o(\\Delta t)$. The family still has $1$ copy. For this to be extinct by time $t+\\Delta t$, the single lineage must go extinct in the remaining time $t$. The probability is $q_1(t)$.\n\nCombining these possibilities, we write:\n$$ q_{1}(t+\\Delta t) = (\\lambda \\Delta t) [q_{1}(t)]^2 + (\\mu \\Delta t) \\cdot 1 + [1 - (\\lambda + \\mu)\\Delta t] q_{1}(t) + o(\\Delta t) $$\nRearranging the terms:\n$$ \\frac{q_{1}(t+\\Delta t) - q_{1}(t)}{\\Delta t} = \\lambda [q_{1}(t)]^2 - (\\lambda + \\mu) q_{1}(t) + \\mu + \\frac{o(\\Delta t)}{\\Delta t} $$\nTaking the limit as $\\Delta t \\to 0$, we obtain the ordinary differential equation:\n$$ \\frac{dq_{1}}{dt} = \\lambda q_{1}^2 - (\\lambda + \\mu)q_{1} + \\mu $$\nThis is a Riccati equation. The right-hand side is a quadratic in $q_1$, which can be factored. The roots of $\\lambda x^2 - (\\lambda + \\mu)x + \\mu = 0$ are $x=1$ and $x=\\mu/\\lambda$. Thus, the equation is:\n$$ \\frac{dq_{1}}{dt} = \\lambda (q_{1} - 1)(q_{1} - \\frac{\\mu}{\\lambda}) $$\nThe initial condition is that at time $t=0$, the family consists of one copy, so it is not extinct. Therefore, $q_{1}(0) = P(N(0)=0 | N(0)=1) = 0$.\n\nWe solve this separable differential equation:\n$$ \\frac{dq_{1}}{(q_{1} - 1)(q_{1} - \\frac{\\mu}{\\lambda})} = \\lambda dt $$\nUsing partial fraction decomposition on the left side, where $\\frac{1}{(x-1)(x-\\mu/\\lambda)} = \\frac{A}{x-1} + \\frac{B}{x-\\mu/\\lambda}$, we find $A = \\frac{1}{1-\\mu/\\lambda} = \\frac{\\lambda}{\\lambda-\\mu}$ and $B = \\frac{1}{\\mu/\\lambda-1} = \\frac{\\lambda}{\\mu-\\lambda}$. Since $\\lambda \\ne \\mu$, these coefficients are well-defined.\n$$ \\int \\left( \\frac{\\lambda/(\\lambda-\\mu)}{q_{1}-1} - \\frac{\\lambda/(\\lambda-\\mu)}{q_{1}-\\mu/\\lambda} \\right) dq_{1} = \\int \\lambda dt $$\n$$ \\frac{1}{\\lambda-\\mu} \\left[ \\ln|q_{1}-1| - \\ln|q_{1}-\\mu/\\lambda| \\right] = t + C $$\nwhere $C$ is the constant of integration.\n$$ \\ln\\left|\\frac{q_{1}-1}{q_{1}-\\mu/\\lambda}\\right| = (\\lambda - \\mu)t + C' $$\nUsing the initial condition $q_{1}(0) = 0$:\n$$ \\ln\\left|\\frac{0-1}{0-\\mu/\\lambda}\\right| = C' \\implies \\ln\\left|\\frac{\\lambda}{\\mu}\\right| = C' $$\nSince $\\lambda > 0$ and $\\mu > 0$, we have $C' = \\ln(\\lambda/\\mu)$.\nSubstituting $C'$ back:\n$$ \\ln\\left|\\frac{q_{1}-1}{q_{1}-\\mu/\\lambda}\\right| = (\\lambda - \\mu)t + \\ln(\\frac{\\lambda}{\\mu}) $$\nSince $q_{1}(t)$ is a probability for a non-extinct starting state, $0 \\le q_{1}(t) < 1$ for finite $t>0$. Therefore, $(q_{1}-1)$ is negative. The term $(q_{1}-\\mu/\\lambda)$ is also negative (as $q_1(t)$ approaches its smaller steady state from $0$), so their ratio is positive. We can remove the absolute value.\n$$ \\frac{q_{1}-1}{q_{1}-\\mu/\\lambda} = \\exp((\\lambda - \\mu)t) \\cdot \\frac{\\lambda}{\\mu} $$\nNow we solve for $q_{1}(t)$:\n$$ \\mu(q_{1}-1) = \\lambda(q_{1}-\\mu/\\lambda)\\exp((\\lambda - \\mu)t) $$\n$$ \\mu q_{1} - \\mu = (\\lambda q_{1} - \\mu)\\exp((\\lambda - \\mu)t) $$\n$$ (\\mu - \\lambda\\exp((\\lambda - \\mu)t))q_{1} = \\mu - \\mu\\exp((\\lambda - \\mu)t) $$\n$$ q_{1}(t) = \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} $$\nThis is the closed-form expression for the extinction probability starting with one copy.\n\nNext, we find the extinction probability $q_{i}(t)$ when starting with $i$ copies. The problem specifies that lineages evolve independently (the branching property). Therefore, starting with $i$ copies at $t=0$ is equivalent to starting $i$ independent birth-death processes, each initiated with a single copy. For the entire family to be extinct at time $t$, each of these $i$ independent lineages must go extinct by time $t$.\nThe probability of this compound event is the product of the individual probabilities:\n$$ q_{i}(t) = P(\\text{lineage } 1 \\text{ extinct}) \\times \\dots \\times P(\\text{lineage } i \\text{ extinct}) $$\n$$ q_{i}(t) = [q_{1}(t)]^i $$\nFinally, we substitute the expression for $q_{1}(t)$ to obtain the single closed-form expression for $q_{i}(t)$:\n$$ q_{i}(t) = \\left( \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} \\right)^i $$\nThis expression gives the probability that a gene family, starting with $i$ members, will be extinct by time $t$, as a function of the duplication rate $\\lambda$, loss rate $\\mu$, time $t$, and initial size $i$.",
            "answer": "$$\\boxed{\\left( \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} \\right)^{i}}$$"
        },
        {
            "introduction": "While individual gene families may go extinct, genomes often maintain a diverse repertoire of families, suggesting a balance between gain and loss. This practice explores this equilibrium by analyzing the birth-death-innovation (BDI) model, which incorporates a constant rate of new family origination, $\\nu$. Your task is to derive the stationary distribution of gene family sizes under the condition that losses outpace duplications ($\\lambda \\lt \\mu$), revealing a direct connection between the evolutionary process parameters and a classic statistical distribution .",
            "id": "2694534",
            "problem": "In models of gene family evolution, the birth-death-innovation (BDI) process idealizes the size of a single gene family as a continuous-time Markov chain with state space $\\{0,1,2,\\ldots\\}$. The process has three types of events: gene duplication within the family, gene loss from the family, and innovation (arrival) of a gene into the family from outside sources such as horizontal transfer or de novo origination. Assume the following linear-rate structure: when the family has size $n$, duplications occur at total rate $\\lambda n$, losses occur at total rate $\\mu n$, and innovation occurs at a constant rate $\\nu$, with parameters $\\lambda>0$, $\\mu>0$, and $\\nu>0$. Assume $\\lambda<\\mu$ so that a stationary distribution exists.\n\nStarting from the Kolmogorov forward equations at stationarity and the definition of a birth-death process with immigration, derive the stationary probability mass function $\\pi_n=\\mathbb{P}\\{N=n\\}$, $n\\in\\{0,1,2,\\ldots\\}$, in closed form. Then identify the distributional family and give its parameters in terms of $\\lambda$, $\\mu$, and $\\nu$. Your final answer must be a single exact analytical expression for $\\pi_n$ in terms of $n$, $\\lambda$, $\\mu$, and $\\nu$. You may use the Gamma function $\\Gamma(\\cdot)$ if needed. Do not provide intermediate steps in the final answer. No rounding is required.",
            "solution": "The problem statement is scientifically grounded, well-posed, and provides sufficient information for a unique solution. It describes a linear birth-death process with constant immigration, a standard model in stochastic population dynamics. We will proceed to derive the stationary distribution.\n\nThe size of the gene family, $N$, is a continuous-time Markov chain on the state space $S = \\{0, 1, 2, \\ldots\\}$. The transition rates from state $n \\in S$ are given by:\n- Birth (duplication and innovation): The rate of transition from state $n$ to $n+1$ is $\\lambda_n = \\lambda n + \\nu$ for $n \\ge 0$.\n- Death (loss): The rate of transition from state $n$ to $n-1$ is $\\mu_n = \\mu n$ for $n \\ge 1$, with $\\mu_0 = 0$.\n\nThe parameters $\\lambda, \\mu, \\nu$ are positive real constants. The condition $\\lambda < \\mu$ is given, which ensures that the process is ergodic and a unique stationary distribution $\\pi_n = \\mathbb{P}\\{N=n\\}$ exists.\n\nAt stationarity, the net flow of probability for each state is zero. For a birth-death process, this leads to the detailed balance equations, which state that the flow from state $n$ to $n+1$ equals the flow from state $n+1$ to $n$:\n$$ \\pi_n \\lambda_n = \\pi_{n+1} \\mu_{n+1} \\quad \\text{for } n \\ge 0 $$\nSubstituting the specific rates for this model:\n$$ \\pi_n (\\lambda n + \\nu) = \\pi_{n+1} \\mu (n+1) $$\nThis yields a recurrence relation for the stationary probabilities:\n$$ \\pi_{n+1} = \\pi_n \\frac{\\lambda n + \\nu}{\\mu(n+1)} $$\nWe can solve this recurrence by iteration, expressing each $\\pi_n$ in terms of $\\pi_0$:\n$$ \\pi_n = \\pi_0 \\prod_{k=0}^{n-1} \\frac{\\lambda k + \\nu}{\\mu(k+1)} = \\pi_0 \\frac{1}{n!\\mu^n} \\prod_{k=0}^{n-1} (\\lambda k + \\nu) \\quad \\text{for } n \\ge 1 $$\nThe product in the numerator can be simplified by factoring out $\\lambda$:\n$$ \\prod_{k=0}^{n-1} (\\lambda k + \\nu) = \\lambda^n \\prod_{k=0}^{n-1} \\left(k + \\frac{\\nu}{\\lambda}\\right) $$\nThe term $\\prod_{k=0}^{n-1} (x+k)$ is the rising factorial, or Pochhammer symbol, $(x)_n$. It can be expressed using the Gamma function $\\Gamma(\\cdot)$ as $(x)_n = \\frac{\\Gamma(x+n)}{\\Gamma(x)}$. Let $r = \\nu/\\lambda$. The product becomes:\n$$ \\lambda^n \\left(\\frac{\\nu}{\\lambda}\\right)_n = \\lambda^n \\frac{\\Gamma(n + \\nu/\\lambda)}{\\Gamma(\\nu/\\lambda)} $$\nSubstituting this back into the expression for $\\pi_n$:\n$$ \\pi_n = \\pi_0 \\frac{\\lambda^n}{n!\\mu^n} \\frac{\\Gamma(n + \\nu/\\lambda)}{\\Gamma(\\nu/\\lambda)} = \\pi_0 \\frac{\\Gamma(n + \\nu/\\lambda)}{n! \\Gamma(\\nu/\\lambda)} \\left(\\frac{\\lambda}{\\mu}\\right)^n $$\nThis formula holds for all $n \\ge 0$, since for $n=0$ it correctly simplifies to $\\pi_0 = \\pi_0$.\n\nTo find the normalization constant $\\pi_0$, we use the condition that the sum of all probabilities must be unity:\n$$ \\sum_{n=0}^{\\infty} \\pi_n = 1 $$\n$$ \\pi_0 \\sum_{n=0}^{\\infty} \\frac{\\Gamma(n + \\nu/\\lambda)}{n! \\Gamma(\\nu/\\lambda)} \\left(\\frac{\\lambda}{\\mu}\\right)^n = 1 $$\nThe sum is a form of the generalized binomial series:\n$$ \\sum_{k=0}^{\\infty} \\frac{\\Gamma(k+r)}{k!\\Gamma(r)} x^k = (1-x)^{-r} $$\nThis series converges for $|x| < 1$. In our case, $x = \\lambda/\\mu$ and $r = \\nu/\\lambda$. The problem states $\\lambda<\\mu$, so $0 < \\lambda/\\mu < 1$, which satisfies the convergence criterion. Applying this identity, the sum becomes:\n$$ \\sum_{n=0}^{\\infty} \\pi_n = \\pi_0 \\left(1 - \\frac{\\lambda}{\\mu}\\right)^{-\\nu/\\lambda} = 1 $$\nSolving for $\\pi_0$:\n$$ \\pi_0 = \\left(1 - \\frac{\\lambda}{\\mu}\\right)^{\\nu/\\lambda} $$\nSubstituting this value of $\\pi_0$ back into the expression for $\\pi_n$, we obtain the final closed-form expression for the stationary probability mass function:\n$$ \\pi_n = \\frac{\\Gamma(n + \\nu/\\lambda)}{n! \\Gamma(\\nu/\\lambda)} \\left(\\frac{\\lambda}{\\mu}\\right)^n \\left(1 - \\frac{\\lambda}{\\mu}\\right)^{\\nu/\\lambda} $$\nThis is the probability mass function of the Negative Binomial distribution. It describes the probability of observing $n$ \"failures\" before $r$ \"successes\" in a sequence of independent Bernoulli trials. The parameters of this distribution, in terms of the model parameters $\\lambda, \\mu, \\nu$, are:\n- The number of successes, $r = \\frac{\\nu}{\\lambda}$.\n- The probability of success in a single trial, $p = 1 - \\frac{\\lambda}{\\mu} = \\frac{\\mu-\\lambda}{\\mu}$.\n\nThe final expression provides the required stationary probability mass function.",
            "answer": "$$\\boxed{\\frac{\\Gamma(n + \\frac{\\nu}{\\lambda})}{n! \\Gamma(\\frac{\\nu}{\\lambda})} \\left(\\frac{\\lambda}{\\mu}\\right)^n \\left(1 - \\frac{\\lambda}{\\mu}\\right)^{\\frac{\\nu}{\\lambda}}}$$"
        },
        {
            "introduction": "Analytical solutions provide deep insights, but simulation is essential for exploring complex scenarios and building intuition for stochastic dynamics. In this capstone exercise, you will implement an exact event-driven simulation of gene family evolution across a phylogenetic tree, bringing the theoretical model to life. This practice reinforces the fundamental Markov and memoryless properties of the process and equips you with a powerful tool for generating data and testing evolutionary hypotheses .",
            "id": "2694477",
            "problem": "You are asked to design and implement an exact event-driven simulation of a linear birth–death process for gene copy counts along a rooted bifurcating tree. Each gene copy duplicates independently at a constant per-copy duplication rate $\\lambda \\ge 0$ and is lost independently at a constant per-copy loss rate $\\mu \\ge 0$. The process on the nonnegative integers is a continuous-time Markov chain (CTMC), where if the current copy count is $n \\in \\{0,1,2,\\dots\\}$ then the total event rate is $n(\\lambda + \\mu)$, and the next event is a duplication with probability $\\lambda/(\\lambda+\\mu)$ or a loss with probability $\\mu/(\\lambda+\\mu)$. When $n=0$, the process is absorbed. At a speciation node, the current copy count is passed identically to both descendant branches, and from that point forward the two descendant lineages evolve independently given the node count. Use the memoryless property of the exponential waiting time and the Markov property of the CTMC to justify why, conditioned on the copy count at a node, the descendant branches can be simulated independently and why the node copy count is a sufficient state variable.\n\nYour program must implement the following, starting from first principles as stated above:\n- A function that simulates the CTMC on a single branch of length $t \\ge 0$, starting from an integer initial count $n_0 \\ge 0$, using exact exponential waiting times with rate $n(\\lambda+\\mu)$ and event outcomes chosen with probabilities $\\lambda/(\\lambda+\\mu)$ and $\\mu/(\\lambda+\\mu)$, respectively. If $t=0$ or $n_0=0$, the branch terminates immediately with no events.\n- A recursion that extends this branch simulation to a rooted bifurcating tree: simulate along a root stem of length $t_{\\mathrm{stem}}$, then at each speciation node pass the realized count identically to both children, simulate each child branch independently, and continue until reaching tips. The tip outputs must be the realized copy counts at the terminal times. To ensure reproducibility, use a fixed pseudorandom number generator seed equal to $2025$.\n- A deterministic left-to-right aggregation of tip counts for output, where “left-to-right” means the preorder traversal that visits the left child before the right child at every bifurcation.\n\nYour implementation must be general, but you must demonstrate it on the following test suite of three trees and parameter sets. In each case, report the list of integers of tip counts in left-to-right order as one result for that case.\n\nTest case $1$ (single bifurcation with a zero-length branch):\n- Parameters: $\\lambda=0.6$, $\\mu=0.2$, $n_0=1$.\n- Tree: root stem length $t_{\\mathrm{stem}}=0.5$; then a bifurcation into two tips with branch lengths $0.0$ (left) and $0.7$ (right).\n\nTest case $2$ (unbalanced tree with two bifurcations and loss-dominated dynamics):\n- Parameters: $\\lambda=0.3$, $\\mu=0.7$, $n_0=2$.\n- Tree: root stem length $t_{\\mathrm{stem}}=1.0$; then a bifurcation with left child a tip at branch length $0.4$, and right child an internal node at branch length $0.3$; this internal node bifurcates to two tips with branch lengths $0.5$ (left) and $0.2$ (right).\n\nTest case $3$ (pure-birth Yule dynamics on an unbalanced tree):\n- Parameters: $\\lambda=1.2$, $\\mu=0.0$, $n_0=1$.\n- Tree: root stem length $t_{\\mathrm{stem}}=0.0$; then a bifurcation with left child a tip at branch length $0.4$, and right child an internal node at branch length $0.1$; this internal node bifurcates to two tips with branch lengths $0.2$ (left) and $0.3$ (right).\n\nYour program must be self-contained (no input) and use the fixed random seed $2025$. The required final output is a single line containing a list of the three case results, each itself a list of integers of tip counts in left-to-right order. The format must be a single line, with no spaces, as a string representation of a list of lists, for example: [[a,b],[c,d,e],[f,g,h]]. No physical units are required in the output. The answers for each test case must be lists of integers, and the aggregate output must be a single list containing those three lists in order $1$ through $3$.",
            "solution": "We begin from the definition of the linear birth–death process on gene copy counts as a continuous-time Markov chain (CTMC) on the state space $\\{0,1,2,\\dots\\}$. If $N(t)$ denotes the number of copies at time $t$, then for $n \\ge 1$ the transition rates are $q_{n,n+1}=n\\lambda$, $q_{n,n-1}=n\\mu$, and $q_{n,n}=-n(\\lambda+\\mu)$, with $q_{0,0}=0$ indicating absorption at zero. Two fundamental properties underlie an exact simulation:\n\n$1.$ Exponential waiting times are memoryless. When the process is in state $n \\ge 1$, the waiting time $\\Delta$ to the next event has the exponential distribution with rate $n(\\lambda+\\mu)$, so $\\Pr(\\Delta > s+t \\mid \\Delta > s)=\\Pr(\\Delta>t)$ for $s,t \\ge 0$.\n\n$2.$ Given that an event occurs at the next jump, the type of event is determined independently with probabilities proportional to the rates: duplication with probability $\\lambda/(\\lambda+\\mu)$ and loss with probability $\\mu/(\\lambda+\\mu)$. This follows from the thinning property of competing Poisson processes: the $n$ copies each have two independent exponential clocks of rates $\\lambda$ and $\\mu$ per copy, and the union of all $2n$ clocks yields the total rate $n(\\lambda+\\mu)$; the event type is then chosen by relative rates.\n\nEvent-driven simulation on a single branch of finite length $t \\ge 0$ thus proceeds by iterating the following steps, starting from $N(0)=n_0$: sample an exponential waiting time with rate $N(\\cdot)(\\lambda+\\mu)$; if the waiting time would exceed the remaining branch time, stop and return the current count; otherwise, advance time to the jump and update the count by $+1$ with probability $\\lambda/(\\lambda+\\mu)$ or $-1$ with probability $\\mu/(\\lambda+\\mu)$. If the count hits $0$, the process is absorbed and no further events occur.\n\nTo extend to a bifurcating tree, consider a rooted tree with a root stem of length $t_{\\mathrm{stem}}$ followed by bifurcations. The extension relies on two principles:\n\n$1.$ Markov sufficiency at nodes. For a node occurring at time $s$, the future evolution on the tree below that node depends on the past history only through the state $N(s)$. Formally, for any $u \\ge 0$, the Markov property of the CTMC implies $\\Pr(N(s+u)=k \\mid \\mathcal{F}_s)=\\Pr(N(s+u)=k \\mid N(s))$, where $\\mathcal{F}_s$ is the $\\sigma$-algebra generated by the process up to time $s$. Therefore, the node’s copy count is a sufficient statistic for continuation.\n\n$2.$ Conditional independence of descendant lineages. At a bifurcation time $s$, the set of exponential clocks governing events on the left descendant branch is independent of the set governing the right descendant branch, because they correspond to disjoint sets of copies and disjoint future time intervals. Given $N(s)=n$, the initial state on each descendant branch is $n$, and the two descendant processes are driven by independent Poisson clocks constructed for each branch. Hence, for any measurable functions $f$ and $g$ of the left and right descendant paths, respectively, $\\mathbb{E}[f \\cdot g \\mid N(s)=n]=\\mathbb{E}[f \\mid N(s)=n] \\cdot \\mathbb{E}[g \\mid N(s)=n]$. This validates simulating each branch independently conditioned on the node count and passing the node count identically to both children at the time of speciation.\n\nAlgorithmic design:\n\n$1.$ Single-branch simulator. Given $(n_0, t, \\lambda, \\mu)$, initialize elapsed time $\\tau=0$ and $n=n_0$. If $t=0$ or $n=0$, return $n$. Otherwise, at each step compute the total rate $r=n(\\lambda+\\mu)$, sample $\\delta \\sim \\mathrm{Exponential}(r)$. If $\\tau+\\delta \\ge t$, stop and return $n$. Else set $\\tau \\leftarrow \\tau+\\delta$. Sample a uniform variate $U \\sim \\mathrm{Uniform}(0,1)$; if $U < \\lambda/(\\lambda+\\mu)$, set $n \\leftarrow n+1$; otherwise set $n \\leftarrow n-1$. If $n=0$, stop and return $0$. Repeat.\n\n$2.$ Tree recursion. Given a rooted bifurcating tree specification with a root stem of length $t_{\\mathrm{stem}}$ and, at each internal node, left and right child edges with their branch lengths, proceed as follows. First simulate the single-branch process along the root stem for time $t_{\\mathrm{stem}}$ starting from $n_0$; call the resulting count $n_{\\mathrm{root}}$. At any internal node with incoming count $n_{\\mathrm{in}}$, simulate independently along the left-edge branch length to get a left count at the child endpoint; if the child is a tip, record that count; if the child is itself an internal node, pass the count to both of its children and recurse. Do the analogous simulation for the right child. The preorder traversal that visits the left child before the right child at each bifurcation defines a deterministic left-to-right order of tip counts to report.\n\n$3.$ Randomness and reproducibility. All exponential and uniform random variates are generated by a pseudorandom number generator initialized with seed $2025$. This ensures identical outputs across runs.\n\nCorrectness justification:\n\n- The single-branch simulator implements the exact jump times of the CTMC because exponential waiting times with rate $n(\\lambda+\\mu)$ are sampled at each state $n$, and event types are chosen according to their instantaneous probabilities $\\lambda/(\\lambda+\\mu)$ and $\\mu/(\\lambda+\\mu)$.\n- The Markov sufficiency at nodes follows from the CTMC Markov property: the conditional distribution of future states given the present state does not depend on the past. Thus, the node copy count is sufficient to restart the process on descendant branches.\n- Conditional independence of descendant lineages follows because, given $N(s)=n$, the two descendant processes are driven by independent sets of exponential clocks over disjoint temporal domains and disjoint sets of copies; by construction, their future evolutions are independent conditional on the node state.\n\nEdge cases in the test suite:\n\n- Test case $1$ includes a zero-length branch ($t=0.0$); the simulator must immediately return the incoming node count for that tip.\n- Test case $2$ is loss-dominated ($\\mu>\\lambda$), making extinction likely; the simulator must correctly handle absorption at $0$ and propagate zeros to descendant branches when applicable.\n- Test case $3$ is pure birth ($\\mu=0.0$), exercising the case where only duplications occur.\n\nOutput specification:\n\n- For each test case, the result is a list of integers equal to the realized tip copy counts in left-to-right order.\n- The program must print a single line containing a list of the three case results in order $1,2,3$, with no spaces, formatted as [[a,b],[c,d,e],[f,g,h]].\n\nBecause the same fixed seed $2025$ is used and the simulation is exact, the program’s output is deterministic and reproducible for the specified parameters and trees.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_branch(n0, t, lam, mu, rng):\n    \"\"\"\n    Exact event-driven simulation of a linear birth-death process on a single branch.\n\n    Parameters:\n        n0 (int): initial copy count at branch start.\n        t (float): branch length (time).\n        lam (float): per-copy duplication rate.\n        mu (float): per-copy loss rate.\n        rng (np.random.Generator): random number generator.\n\n    Returns:\n        int: copy count at the end of the branch.\n    \"\"\"\n    n = int(n0)\n    if t <= 0.0 or n == 0:\n        return n\n    total_rate_per_copy = lam + mu\n    # If total_rate_per_copy == 0, no events can occur; return current n.\n    if total_rate_per_copy == 0.0:\n        return n\n    elapsed = 0.0\n    while n > 0:\n        rate = n * total_rate_per_copy\n        # Sample exponential waiting time with mean 1/rate\n        dt = rng.exponential(1.0 / rate)\n        if elapsed + dt >= t:\n            break\n        elapsed += dt\n        # Decide event type\n        if rng.random() < (lam / total_rate_per_copy):\n            n += 1  # duplication\n        else:\n            n -= 1  # loss\n    return n\n\ndef simulate_tree(tree, n0, lam, mu, rng):\n    \"\"\"\n    Simulate the birth-death process on a bifurcating rooted tree.\n    Tree representation:\n        {\n          'stem_length': float,\n          'left': {'branch_length': float, 'node': internal_or_none},\n          'right': {'branch_length': float, 'node': internal_or_none}\n        }\n    Internal node representation (no stem_length):\n        {\n          'left': {'branch_length': float, 'node': internal_or_none},\n          'right': {'branch_length': float, 'node': internal_or_none}\n        }\n    Tips are represented by {'branch_length': ..., 'node': None}.\n\n    Returns:\n        list[int]: tip counts in left-to-right preorder traversal.\n    \"\"\"\n    # Simulate along the stem to get the count at the root bifurcation\n    n_at_root = simulate_branch(n0, tree['stem_length'], lam, mu, rng)\n\n    tip_counts = []\n\n    def recurse(n_in, internal_node):\n        # Simulate left child\n        left = internal_node['left']\n        n_left_end = simulate_branch(n_in, left['branch_length'], lam, mu, rng)\n        if left['node'] is None:\n            tip_counts.append(n_left_end)\n        else:\n            recurse(n_left_end, left['node'])\n        # Simulate right child\n        right = internal_node['right']\n        n_right_end = simulate_branch(n_in, right['branch_length'], lam, mu, rng)\n        if right['node'] is None:\n            tip_counts.append(n_right_end)\n        else:\n            recurse(n_right_end, right['node'])\n\n    root_internal = {'left': tree['left'], 'right': tree['right']}\n    recurse(n_at_root, root_internal)\n    return tip_counts\n\ndef format_no_space_nested_list(nested):\n    \"\"\"\n    Format a (possibly nested) list into a string with no spaces.\n    \"\"\"\n    if isinstance(nested, list):\n        return \"[\" + \",\".join(format_no_space_nested_list(x) for x in nested) + \"]\"\n    else:\n        return str(nested)\n\ndef build_test_cases():\n    # Test case 1\n    case1_tree = {\n        'stem_length': 0.5,\n        'left':  {'branch_length': 0.0, 'node': None},\n        'right': {'branch_length': 0.7, 'node': None},\n    }\n    case1 = {\n        'lam': 0.6,\n        'mu': 0.2,\n        'n0': 1,\n        'tree': case1_tree\n    }\n\n    # Test case 2\n    # Root -> left tip (0.4), right internal (0.3) -> two tips (0.5, 0.2)\n    case2_internal = {\n        'left':  {'branch_length': 0.5, 'node': None},\n        'right': {'branch_length': 0.2, 'node': None}\n    }\n    case2_tree = {\n        'stem_length': 1.0,\n        'left':  {'branch_length': 0.4, 'node': None},\n        'right': {'branch_length': 0.3, 'node': case2_internal},\n    }\n    case2 = {\n        'lam': 0.3,\n        'mu': 0.7,\n        'n0': 2,\n        'tree': case2_tree\n    }\n\n    # Test case 3\n    # Root -> left tip (0.4), right internal (0.1) -> two tips (0.2, 0.3)\n    case3_internal = {\n        'left':  {'branch_length': 0.2, 'node': None},\n        'right': {'branch_length': 0.3, 'node': None}\n    }\n    case3_tree = {\n        'stem_length': 0.0,\n        'left':  {'branch_length': 0.4, 'node': None},\n        'right': {'branch_length': 0.1, 'node': case3_internal},\n    }\n    case3 = {\n        'lam': 1.2,\n        'mu': 0.0,\n        'n0': 1,\n        'tree': case3_tree\n    }\n\n    return [case1, case2, case3]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    # Fixed seed for reproducibility\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for case in test_cases:\n        lam = case['lam']\n        mu = case['mu']\n        n0 = case['n0']\n        tree = case['tree']\n        tip_counts = simulate_tree(tree, n0, lam, mu, rng)\n        results.append(tip_counts)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_no_space_nested_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}