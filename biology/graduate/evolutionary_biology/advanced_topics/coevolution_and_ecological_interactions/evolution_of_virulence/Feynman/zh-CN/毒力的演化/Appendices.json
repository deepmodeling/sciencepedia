{
    "hands_on_practices": [
        {
            "introduction": "在 virulence (毒力) 进化理论中，核心的权衡假说认为，致病性更强的病原体虽然可能导致宿主死亡率升高，但也可能通过更高的载量获得更强的传播能力。本练习旨在通过一个简洁的数学模型，让您亲手推导 virulence 的进化选择梯度 $g(\\alpha)$。您将具体分析症状引发的卧床休息（降低接触率）与增加的致死率（缩短感染期）之间的对抗性选择压力，这是理解 virulence 演化的基础。",
            "id": "2710055",
            "problem": "考虑一个在封闭宿主种群中短期爆发时间尺度下的急性、直接传播的病原体（忽略宿主的出生和自然死亡）。病原体的毒力，用 $\\alpha$ 表示，会增加症状的严重程度并导致卧床休息，从而将人均接触率降低为一个可微函数 $c(\\alpha)$，且满足 $c'(\\alpha) < 0$。假设每次接触的传播概率为一个与 $\\alpha$ 无关的常数 $p$。受感染的宿主以速率 $\\gamma$ 恢复，并以速率 $\\alpha$ 因病死亡而被移除，因此总人均移除率为 $\\gamma + \\alpha$。设 $S(t)$、$I(t)$ 和 $R(t)$ 分别表示易感、染病和恢复宿主的数量，并设 $N = S(t) + I(t) + R(t)$ 为恒定的种群大小。假设在入侵时间尺度上传播是频率依赖的（标准发生率），因此感染力为 $\\lambda(t) = \\frac{c(\\alpha) p}{N} I(t)$。\n\n传染病动力学由以下方程组给出：\n$$\n\\frac{dS}{dt} = - \\frac{c(\\alpha) p}{N} S I, \\quad\n\\frac{dI}{dt} = \\frac{c(\\alpha) p}{N} S I - (\\gamma + \\alpha) I, \\quad\n\\frac{dR}{dt} = \\gamma I.\n$$\n\n从完全易感宿主种群中（即在 $S \\approx N$ 的无病状态下）基本再生数和入侵适应度的定义出发，推导 $\\alpha$ 的选择梯度，该梯度定义为基本再生数的自然对数对 $\\alpha$ 的导数。你的推导必须明确显示症状引起的卧床休息如何通过 $c(\\alpha)$ 体现，以及移除如何通过 $\\gamma + \\alpha$ 发生。请提供最终结果，形式为一个关于 $c(\\alpha)$、$c'(\\alpha)$、$\\gamma$ 和 $\\alpha$ 的单一闭式解析表达式 $g(\\alpha)$。不要引入此处定义之外的任何额外参数。最终答案必须仅为 $g(\\alpha)$ 的表达式，不含任何文字或单位。",
            "solution": "该问题要求推导病原体毒力 $\\alpha$ 的选择梯度 $g(\\alpha)$。选择梯度被定义为病原体入侵适应度的自然对数关于性状 $\\alpha$ 的导数。在流行病入侵完全易感种群的短期时间尺度上，合适的适应度度量是基本再生数 $R_0$。\n\n首先，我们必须推导出基本再生数 $R_0(\\alpha)$ 作为毒力函数的表达式。$R_0$ 被定义为将单个感染个体引入完全易感的种群中所产生的期望二代感染数。在频率依赖模型中，这简化为每个感染个体的传播率与平均感染期持续时间的乘积。\n\n新感染率由项 $\\frac{c(\\alpha) p}{N} S I$ 给出。因此，每个感染个体产生的新感染率为 $\\frac{c(\\alpha) p S}{N}$。在流行病开始时，种群被认为是完全易感的，因此我们取极限 $S \\to N$。在此极限下，每个感染个体的传播率变为 $\\frac{c(\\alpha) p N}{N} = c(\\alpha) p$。\n\n感染者群体的动力学由 $\\frac{dI}{dt} = \\frac{c(\\alpha) p}{N} S I - (\\gamma + \\alpha) I$ 给出。项 $(\\gamma + \\alpha)I$ 表示个体从感染者群体中被移除的总速率，移除方式包括恢复（速率为 $\\gamma$）或因病死亡（速率为 $\\alpha$）。因此，人均移除率为 $\\gamma + \\alpha$。平均感染期持续时间是该速率的倒数，即 $\\frac{1}{\\gamma + \\alpha}$。\n\n结合这些组成部分，基本再生数是传播率与感染期持续时间的乘积：\n$$\nR_0(\\alpha) = (c(\\alpha) p) \\times \\left(\\frac{1}{\\gamma + \\alpha}\\right) = \\frac{c(\\alpha) p}{\\gamma + \\alpha}\n$$\n这个表达式代表了病原体在入侵时的适应度。\n\n问题将选择梯度 $g(\\alpha)$ 定义为 $R_0(\\alpha)$ 的自然对数关于 $\\alpha$ 的导数。\n$$\ng(\\alpha) \\equiv \\frac{d}{d\\alpha} \\ln(R_0(\\alpha))\n$$\n我们将 $R_0(\\alpha)$ 的表达式代入此定义中。\n$$\ng(\\alpha) = \\frac{d}{d\\alpha} \\ln\\left(\\frac{c(\\alpha) p}{\\gamma + \\alpha}\\right)\n$$\n利用对数的性质，我们可以展开表达式以简化微分：\n$$\n\\ln\\left(\\frac{c(\\alpha) p}{\\gamma + \\alpha}\\right) = \\ln(c(\\alpha)) + \\ln(p) - \\ln(\\gamma + \\alpha)\n$$\n现在，我们对此表达式逐项对 $\\alpha$ 求导：\n$$\ng(\\alpha) = \\frac{d}{d\\alpha} \\left[ \\ln(c(\\alpha)) + \\ln(p) - \\ln(\\gamma + \\alpha) \\right]\n$$\n$$\ng(\\alpha) = \\frac{d}{d\\alpha}\\ln(c(\\alpha)) + \\frac{d}{d\\alpha}\\ln(p) - \\frac{d}{d\\alpha}\\ln(\\gamma + \\alpha)\n$$\n我们计算每个导数：\n1.  对于第一项，我们应用链式法则：$\\frac{d}{d\\alpha}\\ln(c(\\alpha)) = \\frac{1}{c(\\alpha)} \\cdot c'(\\alpha) = \\frac{c'(\\alpha)}{c(\\alpha)}$。\n2.  对于第二项，$p$ 是一个关于 $\\alpha$ 的常数，所以其导数为零：$\\frac{d}{d\\alpha}\\ln(p) = 0$。\n3.  对于第三项，我们再次使用链式法则：$\\frac{d}{d\\alpha}\\ln(\\gamma + \\alpha) = \\frac{1}{\\gamma + \\alpha} \\cdot \\frac{d}{d\\alpha}(\\gamma + \\alpha) = \\frac{1}{\\gamma + \\alpha} \\cdot (0 + 1) = \\frac{1}{\\gamma + \\alpha}$。\n\n将这些结果代回 $g(\\alpha)$ 的表达式中：\n$$\ng(\\alpha) = \\frac{c'(\\alpha)}{c(\\alpha)} + 0 - \\frac{1}{\\gamma + \\alpha}\n$$\n这简化为选择梯度的最终闭式表达式：\n$$\ng(\\alpha) = \\frac{c'(\\alpha)}{c(\\alpha)} - \\frac{1}{\\gamma + \\alpha}\n$$\n这个表达式量化了对毒力的净选择压力。项 $\\frac{c'(\\alpha)}{c(\\alpha)}$ 表示通过毒力对接触率的影响而产生的边际适应度变化，而项 $-\\frac{1}{\\gamma + \\alpha}$ 则表示通过毒力对感染期持续时间的影响而产生的边际适应度变化。推导完成。",
            "answer": "$$\n\\boxed{\\frac{c'(\\alpha)}{c(\\alpha)} - \\frac{1}{\\gamma + \\alpha}}\n$$"
        },
        {
            "introduction": "人类的公共卫生干预，特别是大规模疫苗接种，深刻地改变了病原体的选择环境。本练习将带您进入一个更复杂的现代情境，分析一种高 virulence 的疫苗逃逸突变株的入侵条件。通过构建次代矩阵 (next-generation matrix)，您将量化疫苗在不同程度上影响传播和清除时，对病原体进化的选择压力，这对于理解当前全球性传染病的演化动态至关重要。",
            "id": "2710061",
            "problem": "在一个大小归一化为1的均匀混合宿主群体中，考虑一个包含人口统计学因素的易感-感染-移除 (SIR) 模型，其人均速率为 $\\mu$。以覆盖率 $v \\in [0,1]$ 接种一种预防性疫苗，使得比例为 $v$ 的宿主在出生时接种疫苗并终身保持接种状态。疫苗接种通过改变在已接种宿主中发生的感染的传播率和恢复率来影响感染动态。存在两种病原体毒株：一种是常驻的野生型，另一种是毒性更强的稀有突变型。对于感染了毒株 $i \\in \\{w,m\\}$ 的宿主，令 $\\beta_i$ 表示每次接触的传播率，$\\gamma_i$ 表示恢复率，$\\alpha_i$ 表示疾病引起的死亡率（毒性）。假设为均匀的质量作用传播，并且没有共感染或重复感染。\n\n疫苗接种具有两种功效成分，它们以乘法方式作用于宿主体内的传染性和清除率：\n- 在感染野生型的已接种宿主中，有效传播率降低一个因子 $(1 - \\epsilon_{\\beta})$，因此传播率为 $\\beta_w (1 - \\epsilon_{\\beta})$，恢复率增加一个因子 $(1 + \\epsilon_{\\gamma})$，因此恢复率为 $\\gamma_w (1 + \\epsilon_{\\gamma})$。\n- 突变型是一种具有部分逃逸能力的疫苗逃逸变异株。在感染突变型的已接种宿主中，只有比例为 $r_{\\beta} \\in [0,1]$ 的传播阻断效应和比例为 $r_{\\gamma} \\in [0,1]$ 的恢复增强效应起作用。因此，传播率为 $\\beta_m \\bigl(1 - r_{\\beta} \\epsilon_{\\beta}\\bigr)$，恢复率为 $\\gamma_m \\bigl(1 + r_{\\gamma} \\epsilon_{\\gamma}\\bigr)$。\n\n假设人口统计学达到平衡，因此在接种疫苗后的无病平衡点附近，易感人群比例在未接种宿主中为 $S_u = 1 - v$，在已接种宿主中为 $S_v = v$。假设对于每个感染个体，其与各宿主类别的接触是随机的。\n\n使用下一代矩阵框架（基本再生数等于下一代矩阵的谱半径），考虑按疫苗接种状态对感染仓室进行排序，突变型为 $(I_m^u, I_m^v)$，野生型为 $(I_w^u, I_w^v)$。在接种疫苗后的无病平衡点，完整的双毒株下一代矩阵是块对角矩阵，其中一个 $2 \\times 2$ 块用于突变型，另一个 $2 \\times 2$ 块用于野生型。关注突变型块，推导其 $2 \\times 2$ 下一代矩阵的主特征值，该特征值是 $v$, $\\beta_m$, $\\gamma_m$, $\\alpha_m$, $\\mu$, $\\epsilon_{\\beta}$, $\\epsilon_{\\gamma}$, $r_{\\beta}$ 和 $r_{\\gamma}$ 的函数。\n\n作为最终答案，报告此主特征值（作为疫苗覆盖率函数的突变型入侵再生数）的精确闭式解析表达式，仅用上述参数表示。不要提供不等式，也不要进行近似或四舍五入。无需单位。",
            "solution": "该问题要求在一个疫苗接种计划下，推导入侵处于无病平衡点（DFE）群体的突变病原体毒株的下一代矩阵的主特征值。此特征值是突变型的入侵再生数 $R_{0,m}(v)$，是疫苗覆盖率 $v$ 的一个函数。\n\n根据问题陈述，该系统由一个包含人口统计学的 SIR 模型描述。群体按疫苗接种状态（未接种和已接种）和感染状态进行划分。我们关注由下标 $m$ 表示的突变毒株。突变型的感染仓室为 $I_m^u$（未接种感染者）和 $I_m^v$（已接种感染者）。感染动态的状态向量为 $x = (I_m^u, I_m^v)^T$。\n\n下一代矩阵方法要求将在无病平衡点（DFE）的线性化系统动态分解为一个新感染矩阵 $\\mathcal{F}$ 和一个转移矩阵 $\\mathcal{V}$。然后下一代矩阵为 $K = \\mathcal{F} \\mathcal{V}^{-1}$。\n\n首先，我们构建新感染矩阵 $\\mathcal{F}$。元素 $\\mathcal{F}_{ij}$ 表示由仓室 $j$ 中的个体在仓室 $i$ 中产生新感染的速率。在DFE，易感群体由比例为 $S_u = 1-v$ 的未接种个体和比例为 $S_v = v$ 的已接种个体组成。\n来自未接种感染个体（$I_m^u$）的人均传播率为 $\\beta_m$。来自已接种感染个体（$I_m^v$）的人均传播率为 $\\beta_m(1 - r_{\\beta}\\epsilon_{\\beta})$。假设在大小为1的群体中均匀混合，则突变毒株的总感染力为 $\\lambda_m = \\beta_m I_m^u + \\beta_m(1 - r_{\\beta}\\epsilon_{\\beta}) I_m^v$。\n\n未接种类别 $I_m^u$ 中的新感染产生于感染个体与未接种易感者 $S_u$ 之间的接触。其速率为 $\\lambda_m S_u = (\\beta_m I_m^u + \\beta_m(1 - r_{\\beta}\\epsilon_{\\beta}) I_m^v)(1-v)$。\n已接种类别 $I_m^v$ 中的新感染产生于与已接种易感者 $S_v$ 的接触。其速率为 $\\lambda_m S_v = (\\beta_m I_m^u + \\beta_m(1 - r_{\\beta}\\epsilon_{\\beta}) I_m^v)v$。\n根据这些速率，我们可以将矩阵 $\\mathcal{F}$ 写为：\n$$\n\\mathcal{F} = \\begin{pmatrix}\n\\beta_m (1-v) & \\beta_m (1 - r_{\\beta}\\epsilon_{\\beta})(1-v) \\\\\n\\beta_m v & \\beta_m (1 - r_{\\beta}\\epsilon_{\\beta})v\n\\end{pmatrix}\n$$\n\n接下来，我们构建转移矩阵 $\\mathcal{V}$。元素 $\\mathcal{V}_{ij}$ 表示个体通过非感染途径从仓室 $j$ 转移到仓室 $i$ 的速率。对于一个简单的SIR类型模型，该矩阵是对角矩阵，其中 $\\mathcal{V}_{ii}$ 是离开感染仓室 $i$ 的总速率。\n对于一个未接种的感染个体（$I_m^u$），离开该仓室的总速率是自然死亡率 $\\mu$、疾病引起的死亡率 $\\alpha_m$ 和恢复率 $\\gamma_m$ 的总和。因此，离开速率为 $\\mu + \\alpha_m + \\gamma_m$。\n对于一个已接种的感染个体（$I_m^v$），恢复率被修正为 $\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma})$。问题没有指明毒性有任何变化，所以 $\\alpha_m$ 保持不变。总离开速率为 $\\mu + \\alpha_m + \\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma})$。\n因此，矩阵 $\\mathcal{V}$ 为：\n$$\n\\mathcal{V} = \\begin{pmatrix}\n\\gamma_m + \\alpha_m + \\mu & 0 \\\\\n0 & \\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu\n\\end{pmatrix}\n$$\n\n下一代矩阵是 $K = \\mathcal{F}\\mathcal{V}^{-1}$。首先，我们求 $\\mathcal{V}^{-1}$：\n$$\n\\mathcal{V}^{-1} = \\begin{pmatrix}\n\\frac{1}{\\gamma_m + \\alpha_m + \\mu} & 0 \\\\\n0 & \\frac{1}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu}\n\\end{pmatrix}\n$$\n现在，我们计算 $K$：\n$$\nK = \\begin{pmatrix}\n\\beta_m (1-v) & \\beta_m (1 - r_{\\beta}\\epsilon_{\\beta})(1-v) \\\\\n\\beta_m v & \\beta_m (1 - r_{\\beta}\\epsilon_{\\beta})v\n\\end{pmatrix}\n\\begin{pmatrix}\n\\frac{1}{\\gamma_m + \\alpha_m + \\mu} & 0 \\\\\n0 & \\frac{1}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu}\n\\end{pmatrix}\n$$\n$$\nK = \\begin{pmatrix}\n\\frac{\\beta_m (1-v)}{\\gamma_m + \\alpha_m + \\mu} & \\frac{\\beta_m (1 - r_{\\beta}\\epsilon_{\\beta})(1-v)}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu} \\\\\n\\frac{\\beta_m v}{\\gamma_m + \\alpha_m + \\mu} & \\frac{\\beta_m v (1 - r_{\\beta}\\epsilon_{\\beta})}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu}\n\\end{pmatrix}\n$$\n$K$ 的主特征值是其谱半径 $\\rho(K)$。对于一个 $2 \\times 2$ 矩阵 $M = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$，其特征值 $\\lambda$ 是特征方程 $\\lambda^2 - \\text{tr}(M)\\lambda + \\det(M) = 0$ 的解。\n$K$ 的迹是 $\\text{tr}(K) = K_{11} + K_{22}$。\n$K$ 的行列式是 $\\det(K) = K_{11}K_{22} - K_{12}K_{21}$。\n我们来计算行列式：\n$$\nK_{11}K_{22} = \\left( \\frac{\\beta_m (1-v)}{\\gamma_m + \\alpha_m + \\mu} \\right) \\left( \\frac{\\beta_m v (1 - r_{\\beta}\\epsilon_{\\beta})}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu} \\right)\n$$\n$$\nK_{12}K_{21} = \\left( \\frac{\\beta_m (1 - r_{\\beta}\\epsilon_{\\beta})(1-v)}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu} \\right) \\left( \\frac{\\beta_m v}{\\gamma_m + \\alpha_m + \\mu} \\right)\n$$\n我们观察到 $K_{11}K_{22} = K_{12}K_{21}$，这意味着 $\\det(K)=0$。这是新感染矩阵 $\\mathcal{F}$ 的秩-1结构的结果。\n特征方程简化为 $\\lambda^2 - \\text{tr}(K)\\lambda = 0$，其解出的特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = \\text{tr}(K)$。\n由于所有参数都是非负的，$K$ 的所有元素都是非负的，其迹也是非负的。因此，主特征值为 $\\lambda_2 = \\text{tr}(K)$。\n$$\n\\rho(K) = K_{11} + K_{22} = \\frac{\\beta_m (1-v)}{\\gamma_m + \\alpha_m + \\mu} + \\frac{\\beta_m v (1 - r_{\\beta}\\epsilon_{\\beta})}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu}\n$$\n这个表达式是突变毒株的入侵再生数。它是未接种亚群（第一项）和已接种亚群（第二项）中发生的感染所产生的繁殖贡献的总和，并由这些亚群在无病平衡点的各自比例加权。",
            "answer": "$$\n\\boxed{\\frac{\\beta_m(1-v)}{\\gamma_m + \\alpha_m + \\mu} + \\frac{\\beta_m v (1 - r_{\\beta}\\epsilon_{\\beta})}{\\gamma_m(1 + r_{\\gamma}\\epsilon_{\\gamma}) + \\alpha_m + \\mu}}\n$$"
        },
        {
            "introduction": "我们能否超越被动分析，主动利用进化原理来指导疾病管理？这个高级实践将引导您使用适应性动力学 (Adaptive Dynamics) 框架来设计干预策略，以期将病原体从高 virulence 状态引导至低 virulence 状态。通过编写一个计算模型，您将探索如何利用瞬时选择压力，实现对病原体进化轨迹的“驾驭”，这代表了应用进化医学的前沿思维。",
            "id": "2710106",
            "problem": "考虑一个病原体在一个大型宿主种群中演化其毒力性状 $ \\alpha \\in \\mathbb{R}_{\\ge 0} $，基于标准的时间尺度分离假设，即生态动力学相对于进化变化的平衡速度要快得多。在适应性动力学 (AD) 框架下，其典范方程假设性状动力学遵循入侵适应度 $ W(\\alpha; p) $ 相对于 $ \\alpha $ 的梯度上升，并由一个吸收了突变率、突变方差和种群大小的正常数 $ \\kappa $ 进行缩放。具体而言，假设进化动力学由下式给出\n$$\n\\frac{d \\alpha}{dt} \\;=\\; \\kappa \\, g(\\alpha; p(t)), \\quad \\text{其中 } g(\\alpha; p) \\equiv \\frac{\\partial W(\\alpha; p)}{\\partial \\alpha}.\n$$\n假设入侵适应度 $ W(\\alpha; p) $ 可通过基本再生数的对数来近似，\n$$\nW(\\alpha; p) \\;=\\; \\ln R_0(\\alpha; p) \\;=\\; \\ln \\beta(\\alpha; p) \\;-\\; \\ln(\\alpha + \\gamma + d),\n$$\n其中恢复率 $ \\gamma > 0 $ 和背景死亡率 $ d \\ge 0 $ 均为常数。传播率 $ \\beta(\\alpha; p) $ 反映了两种具有相反毒力依赖性的传播途径：一种是社区接触途径，因宿主移动性降低而随毒力增加而下降；另一种是照护者接触途径，因症状驱动的接触强度增加而随毒力增加而上升。设\n$$\n\\beta(\\alpha; p) \\;=\\; \\beta_c \\, (1-p) \\, v(\\alpha)\\, m(\\alpha) \\;+\\; \\beta_h \\, p \\, v(\\alpha)\\, h(\\alpha),\n$$\n其中 $ p \\in [0,1] $ 是一个可控的环境参数 (例如，由干预措施调节的、在照护者环境中发生的接触比例)，$ \\beta_c > 0 $ 和 $ \\beta_h > 0 $ 是特定途径的系数，宿主体内函数和接触函数分别为\n$$\nv(\\alpha) \\;=\\; \\frac{\\alpha}{\\alpha + K}, \\quad\nm(\\alpha) \\;=\\; \\frac{1}{1 + \\alpha/M}, \\quad\nh(\\alpha) \\;=\\; \\frac{\\alpha}{\\alpha + H},\n$$\n其中 $ K>0 $，$ M>0 $ 且 $ H>0 $。组合 $ v(\\alpha) m(\\alpha) $ 产生一个驼峰形的社区接触贡献，而 $ v(\\alpha) h(\\alpha) $ 产生一个递增饱和的照护者接触贡献。\n\n干预措施通过 $ p(t) $ 的时变进行建模，使用单个矩形脉冲：\n$$\np(t) \\;=\\; \\begin{cases}\np_{\\mathrm{hi}}, & 0 \\le t < T,\\\\\np_{\\mathrm{lo}}, & t \\ge T,\n\\end{cases}\n$$\n其中 $ p_{\\mathrm{lo}} $ 是基线环境，$ p_{\\mathrm{hi}} $ 是干预设置。目标是利用脉冲期间的瞬时选择，将系统在基线 $ p_{\\mathrm{lo}} $ 下从一个高毒力吸引盆推向一个低毒力吸引盆。\n\n在固定 $ p $ 下的进化稳定状态 (ESS) $ \\alpha^* $ 满足 $ g(\\alpha^*; p) = 0 $。在上述梯度流下的稳定性由 $ \\partial g/\\partial \\alpha $ 的符号决定：如果 $ \\partial g/\\partial \\alpha < 0 $，则根是局部吸引的 (稳定的)；如果 $ \\partial g/\\partial \\alpha > 0 $，则是排斥的 (不稳定的)。在某些参数体系下，基线 $ p_{\\mathrm{lo}} $ 会出现双稳态，存在两个稳定的ESS (一个低毒力 $ \\alpha_{\\mathrm{L}} $ 和一个高毒力 $ \\alpha_{\\mathrm{H}} $)，由一个不稳定的平衡点 $ \\alpha_{\\mathrm{U}} $ 分隔。从高毒力吸引盆中的一个初始性状 $ \\alpha(0)=\\alpha_0 $ ($ \\alpha_0 > \\alpha_{\\mathrm{U}} $) 开始，在 $ p_{\\mathrm{hi}} $ 下施加一个足够长的脉冲 $ T $，可以将 $ \\alpha(t) $ 移至 $ \\alpha_{\\mathrm{U}} $ 以下，之后基线动力学将驱动 $ \\alpha(t) $ 趋向 $ \\alpha_{\\mathrm{L}} $。\n\n您的任务是：\n- 实现性状动力学 $ d\\alpha/dt = \\kappa \\, g(\\alpha; p(t)) $，其中 $ g(\\alpha;p) = \\partial W/\\partial \\alpha $ 且 $ W(\\alpha;p) = \\ln \\beta(\\alpha;p) - \\ln(\\alpha+\\gamma+d) $。使用可靠的数值微分计算 $ g $，并使用定步长显式龙格-库塔积分器进行时间步进。\n- 给定基线 $ p_{\\mathrm{lo}} $，通过扫描 $ \\alpha \\in [\\alpha_{\\min}, \\alpha_{\\max}] $ 来检查 $ g(\\alpha; p_{\\mathrm{lo}}) $ 的符号变化，并使用稳健的区间法定位根，从而计算所有ESS。通过 $ \\partial g/\\partial \\alpha $ 的数值估计对每个根的稳定性进行分类。\n- 如果基线是双稳态的，具有三个ESS (低毒力稳定、中等不稳定、高毒力稳定)，则将不稳定的平衡点 $ \\alpha_{\\mathrm{U}} $ 定义为吸引盆分离阈值。否则，定义一个目标阈值 $ \\alpha_{\\mathrm{goal}} $ (每个测试案例提供)，代表一个实际的低毒力目标。在双稳态情况下，如果干预后轨迹最终满足 $ \\alpha_{\\text{end}} < \\alpha_{\\mathrm{U}} $ (即进入低毒力盆)，则视为成功；在单稳态情况下，如果 $ \\alpha_{\\text{end}} \\le \\alpha_{\\mathrm{goal}} $，则视为成功。\n- 通过计算能达到成功的最小脉冲持续时间 $ T^{\\star} \\in [0, T_{\\max}] $ (如果存在) 来设计一个方案。使用二分法在指定的容差内对 $ T $ 进行搜索，如果在 $ [0, T_{\\max}] $ 内无法成功，则报告失败为 $ -1.0 $。\n- 对于每个测试的 $ T $，如上所述，使用 $ p(t) $ 将动力学从 $ t=0 $ 积分到 $ t = T + T_{\\mathrm{relax}} $，其中 $ T_{\\mathrm{relax}} $ 是在基线 $ p_{\\mathrm{lo}} $ 下足够长的弛豫时间，以接近脉冲后的吸引盆。使用固定步长 $ \\Delta t $ 进行数值积分，并通过反射或钳位处理下界 $ \\alpha_{\\min} $ 以避免非物理的负值。\n\n在所有测试中使用以下固定模型参数：\n- $ \\beta_c = 3.0 $, $ \\beta_h = 9.0 $,\n- $ K = 0.2 $, $ M = 0.5 $, $ H = 0.1 $,\n- $ \\gamma = 0.3 $, $ d = 0.0 $,\n- $ \\kappa $ 根据测试案例具体指定，\n- $ \\alpha_{\\min} = 10^{-6} $, $ \\alpha_{\\max} = 5.0 $,\n- 数值微分步长 $ \\varepsilon = 10^{-6} $,\n- 时间步长 $ \\Delta t = 0.05 $，弛豫时间 $ T_{\\mathrm{relax}} = 800.0 $,\n- 根扫描分辨率 $ N_{\\alpha} = 1000 $。\n\n要求的输出：\n- 对于每个测试案例，返回区间 $ [0, T_{\\max}] $ 内的最小脉冲持续时间 $ T^{\\star} $ (浮点数)，通过标准字符串格式化进行取整 (无显式取整约束)，如果无法实现则返回 $ -1.0 $。\n\n测试套件 (每个测试案例是一个元组，指定了 $ (\\alpha_0, p_{\\mathrm{lo}}, p_{\\mathrm{hi}}, \\kappa, T_{\\max}, \\alpha_{\\mathrm{goal}}) $):\n- 案例1 (理想路径双稳态，强干预): $ (1.5, 0.25, 0.85, 0.04, 500.0, 0.5) $。\n- 案例2 (干预幅度不足): $ (1.5, 0.25, 0.50, 0.04, 500.0, 0.5) $。\n- 案例3 (接近阈值的初始条件): $ (0.6, 0.25, 0.85, 0.04, 500.0, 0.5) $。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含三个案例的结果，格式为方括号内的逗号分隔列表 (例如，\"[result1,result2,result3]\")。\n- 所有输出必须是使用十进制表示法的实数 (浮点数)。\n\n注：不需要物理单位；所有量均为无量纲或采用任意一致单位。不使用角度。如涉及百分比，必须按已指定的方式表示为 $ [0,1] $ 范围内的小数。",
            "solution": "所提出的问题是一个适定且具有科学依据的进化建模练习。它要求在特定干预情景下分析病原体的毒力进化。任务是确定所需的最小干预持续时间，以将进化轨迹从一个不希望的高毒力平衡引导到一个更温和的低毒力状态。该问题是有效的，并将基于适应性动力学和数值分析的原理构建解决方案。\n\n分析分几个阶段进行：\n1.  进化动力学的公式化。\n2.  进化稳定状态 (ESS) 的识别与稳定性分析。\n3.  脉冲干预下性状轨迹的数值模拟。\n4.  干预持续时间的优化。\n\n毒力性状（表示为 $\\alpha \\in \\mathbb{R}_{\\ge 0}$）的进化动力学由适应性动力学的典范方程控制：\n$$\n\\frac{d \\alpha}{dt} = \\kappa \\, g(\\alpha; p(t))\n$$\n其中 $\\kappa$ 是一个代表进化速度的正常数，$g(\\alpha; p)$ 是选择梯度。该梯度是入侵适应度 $W(\\alpha; p)$ 相对于性状 $\\alpha$ 的偏导数：\n$$\ng(\\alpha; p) \\equiv \\frac{\\partial W(\\alpha; p)}{\\partial \\alpha}\n$$\n入侵适应度定义为基本再生数 $R_0(\\alpha; p)$ 的自然对数：\n$$\nW(\\alpha; p) = \\ln R_0(\\alpha; p) = \\ln \\beta(\\alpha; p) - \\ln(\\alpha + \\gamma + d)\n$$\n此处，$\\beta(\\alpha; p)$ 是依赖于毒力和环境的传播率，$\\gamma$ 是宿主恢复率，$d$ 是背景死亡率。环境由一个控制参数 $p(t)$ 调节。\n\n传播率 $\\beta(\\alpha; p)$ 是两个组分的加权和：社区接触途径和照护者接触途径。\n$$\n\\beta(\\alpha; p) = \\beta_c \\, (1-p) \\, v(\\alpha)\\, m(\\alpha) + \\beta_h \\, p \\, v(\\alpha)\\, h(\\alpha)\n$$\n组分函数定义如下：\n$$\nv(\\alpha) = \\frac{\\alpha}{\\alpha + K}, \\quad m(\\alpha) = \\frac{1}{1 + \\alpha/M}, \\quad h(\\alpha) = \\frac{\\alpha}{\\alpha + H}\n$$\n这些形式为社区传播建模了对毒力的驼峰形依赖关系，并为与照护者相关的传播建模了递增饱和的依赖关系。参数 $p$ 在这两种模式之间转换选择压力。\n\n一个进化稳定状态 (ESS) $\\alpha^*$ 是一个性状值，在该值处选择梯度为零，即 $g(\\alpha^*; p) = 0$。一个ESS的局部稳定性由适应度函数的二阶导数符号决定，等效于 $\\frac{\\partial g}{\\partial \\alpha}$ 在 $\\alpha^*$ 处的符号：\n-   如果 $\\frac{\\partial g}{\\partial \\alpha}(\\alpha^*) < 0$，该ESS是局部稳定的（一个进化吸引子）。\n-   如果 $\\frac{\\partial g}{\\partial \\alpha}(\\alpha^*) > 0$，该ESS是不稳定的（一个进化排斥子）。\n\n对于某些参数值，系统在基线环境 $p_{\\mathrm{lo}}$ 下可以表现出双稳态，意味着存在两个稳定的ESS，$\\alpha_{\\mathrm{L}}$（低毒力）和 $\\alpha_{\\mathrm{H}}$（高毒力），由一个不稳定的ESS $\\alpha_{\\mathrm{U}}$ 分隔。干预策略包括在持续时间 $T$ 内施加一个不同环境 $p_{\\mathrm{hi}}$ 的临时脉冲。\n$$\np(t) = \\begin{cases}\np_{\\mathrm{hi}}, & 0 \\le t < T, \\\\\np_{\\mathrm{lo}}, & t \\ge T.\n\\end{cases}\n$$\n目标是找到最小脉冲持续时间 $T^{\\star}$，该时间足以将性状值 $\\alpha(t)$ 从 $\\alpha_{\\mathrm{H}}$ 的吸引盆（其中 $\\alpha(0) = \\alpha_0 > \\alpha_{\\mathrm{U}}$）推入 $\\alpha_{\\mathrm{L}}$ 的吸引盆。如果在一段长弛豫期结束时的性状值 $\\alpha_{\\mathrm{end}} = \\alpha(T + T_{\\mathrm{relax}})$ 位于低毒力吸引盆内，则视为成功。在双稳态系统中，这意味着 $\\alpha_{\\mathrm{end}} < \\alpha_{\\mathrm{U}}$。如果系统是单稳态的，则成功定义为 $\\alpha_{\\mathrm{end}} \\le \\alpha_{\\mathrm{goal}}$。\n\n实施计划如下：\n\n首先，对于一个给定的具有基线环境 $p_{\\mathrm{lo}}$ 的测试案例，我们必须刻画其进化景观。这通过在 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 范围内数值定位所有ESS来完成。我们在一个精细的 $\\alpha$ 值网格上计算选择梯度 $g(\\alpha; p_{\\mathrm{lo}})$。通过识别符号变化来定位 $g$ 的根，然后使用稳健的数值求根算法（如Brent方法）来精化其位置。每个根 $\\alpha^*$ 的稳定性随后通过数值评估 $\\frac{\\partial g}{\\partial \\alpha}$ 在 $\\alpha^*$ 处的符号来确定。这种分析揭示了系统是否是双稳态的，并识别出分隔吸引盆的不稳定平衡点 $\\alpha_{\\mathrm{U}}$。\n\n其次，我们必须模拟系统在给定脉冲持续时间 $T$ 下的轨迹。$\\alpha(t)$ 的微分方程将进行数值积分。一个定步长的四阶龙格-库塔 (RK4) 方法是合适且标准的选择。积分从 $t=0$ 进行到 $t = T + T_{\\mathrm{relax}}$。对于 $t \\in [0, T)$，参数为 $p = p_{\\mathrm{hi}}$；对于 $t \\in [T, T + T_{\\mathrm{relax}}]$，它恢复为 $p = p_{\\mathrm{lo}}$。RK4积分器每步所需的选择梯度 $g(\\alpha; p)$ 将使用中心有限差分近似法计算 $W(\\alpha; p)$ 的导数，步长为一个很小的 $\\varepsilon$。在积分过程中，通过钳位将性状值约束为不小于 $\\alpha_{\\min}$。\n\n第三，为找到最小的成功脉冲持续时间 $T^{\\star}$，我们在区间 $[0, T_{\\max}]$ 上采用二分法搜索。定义一个函数 `check_success(T)`，它对持续时间为 $T$ 的脉冲执行完整模拟，并在最终状态 $\\alpha_{\\mathrm{end}}$ 满足成功标准时返回真。二分法算法过程如下：\n1. 初始化搜索边界：$T_{\\mathrm{low}} = 0$, $T_{\\mathrm{high}} = T_{\\max}$。\n2. 首先，检查平凡失败情况：如果 `check_success(T_max)` 为假，则在给定范围内不存在解，并且 $T^{\\star} = -1.0$。\n3. 然后，检查平凡成功情况：如果 `check_success(0)` 为真，则不需要干预，并且 $T^{\\star} = 0.0$。\n4. 否则，迭代足够多的次数（例如100次）以达到高精度：\n    a. 设置 $T_{\\mathrm{mid}} = (T_{\\mathrm{low}} + T_{\\mathrm{high}}) / 2$。\n    b. 如果 `check_success(T_mid)` 为真，那么更短的脉冲也可能有效，因此我们更新 $T_{\\mathrm{high}} = T_{\\mathrm{mid}}$。\n    c. 如果 `check_success(T_mid)` 为假，则需要更长的脉冲，因此我们更新 $T_{\\mathrm{low}} = T_{\\mathrm{mid}}$。\n$T_{\\mathrm{high}}$ 的最终值提供了所需最小持续时间 $T^{\\star}$ 的一个紧密上界。此过程应用于每个测试案例以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\n# --- Model Definition ---\n\n# Fixed model parameters provided in the problem statement.\nMODEL_PARAMS = {\n    'beta_c': 3.0, 'beta_h': 9.0,\n    'K': 0.2, 'M': 0.5, 'H': 0.1,\n    'gamma': 0.3, 'd': 0.0,\n    'alpha_min': 1e-6, 'alpha_max': 5.0,\n    'epsilon': 1e-6, # For numerical differentiation\n    'dt': 0.05,\n    'T_relax': 800.0,\n    'N_alpha': 1000 # Root scan resolution\n}\n\ndef v(alpha, K):\n    \"\"\"Component function v(alpha)\"\"\"\n    return alpha / (alpha + K)\n\ndef m(alpha, M):\n    \"\"\"Component function m(alpha)\"\"\"\n    return 1.0 / (1.0 + alpha / M)\n\ndef h(alpha, H):\n    \"\"\"Component function h(alpha)\"\"\"\n    return alpha / (alpha + H)\n\ndef beta(alpha, p, params):\n    \"\"\"Transmission rate beta(alpha, p)\"\"\"\n    term_c = params['beta_c'] * (1 - p) * v(alpha, params['K']) * m(alpha, params['M'])\n    term_h = params['beta_h'] * p * v(alpha, params['K']) * h(alpha, params['H'])\n    return term_c + term_h\n\ndef W(alpha, p, params):\n    \"\"\"Invasion fitness W(alpha, p)\"\"\"\n    # Clamp alpha to avoid log(0) or division by zero issues in beta\n    alpha_clamped = np.maximum(alpha, params['alpha_min'])\n    \n    beta_val = beta(alpha_clamped, p, params)\n    \n    # Check for invalid beta values\n    if np.any(beta_val = 0):\n        # Return a large negative number for fitness to penalize non-physical regions\n        return -np.inf\n        \n    return np.log(beta_val) - np.log(alpha_clamped + params['gamma'] + params['d'])\n\ndef g(alpha, p, params):\n    \"\"\"Selection gradient g(alpha, p) = dW/dalpha, via numerical differentiation.\"\"\"\n    eps = params['epsilon']\n    return (W(alpha + eps/2, p, params) - W(alpha - eps/2, p, params)) / eps\n\ndef dg_dalpha(alpha, p, params):\n    \"\"\"Derivative of selection gradient dg/dalpha for stability analysis.\"\"\"\n    eps = params['epsilon']\n    return (g(alpha + eps/2, p, params) - g(alpha - eps/2, p, params)) / eps\n\n# --- Analysis and Simulation ---\n\ndef find_ess(p, params):\n    \"\"\"Finds and classifies evolutionary steady states (ESS) for a given p.\"\"\"\n    alpha_grid = np.linspace(params['alpha_min'], params['alpha_max'], params['N_alpha'])\n    g_vals = g(alpha_grid, p, params)\n    \n    # Find brackets for roots where g(alpha) changes sign\n    sign_changes = np.where(np.diff(np.sign(g_vals)))[0]\n    \n    ess_points = []\n    for i in sign_changes:\n        a, b = alpha_grid[i], alpha_grid[i+1]\n        try:\n            # Brent's method is robust for root finding within a bracket\n            root = optimize.brentq(g, a, b, args=(p, params))\n            stability_metric = dg_dalpha(root, p, params)\n            if stability_metric  0:\n                stability = 'stable'\n            elif stability_metric > 0:\n                stability = 'unstable'\n            else:\n                stability = 'neutral'\n            ess_points.append({'alpha': root, 'stability': stability})\n        except ValueError:\n            # brentq fails if g(a) and g(b) don't have opposite signs, which can happen with numerical precision issues\n            continue\n            \n    return ess_points\n\ndef run_simulation(alpha0, T_pulse, p_lo, p_hi, kappa, params):\n    \"\"\"Simulates trait dynamics using a fixed-step RK4 integrator.\"\"\"\n    total_time = T_pulse + params['T_relax']\n    num_steps = int(np.ceil(total_time / params['dt']))\n    dt = params['dt'] # Use the fixed time step from params\n    \n    alpha = float(alpha0)\n    t = 0.0\n    \n    for _ in range(num_steps):\n        # Determine current environmental parameter p\n        current_p = p_hi if t  T_pulse else p_lo\n        \n        # RK4 integration step\n        k1 = kappa * g(alpha, current_p, params)\n        k2 = kappa * g(alpha + dt/2 * k1, current_p, params)\n        k3 = kappa * g(alpha + dt/2 * k2, current_p, params)\n        k4 = kappa * g(alpha + dt * k3, current_p, params)\n        \n        alpha_new = alpha + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        \n        # Clamp alpha to prevent non-physical negative values\n        alpha = max(alpha_new, params['alpha_min'])\n        \n        t += dt\n        \n    return alpha\n\n# --- Main Solver Logic ---\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and find the minimal pulse duration.\n    \"\"\"\n    test_cases = [\n        # (alpha0, p_lo, p_hi, kappa, T_max, alpha_goal)\n        (1.5, 0.25, 0.85, 0.04, 500.0, 0.5), # Case 1\n        (1.5, 0.25, 0.50, 0.04, 500.0, 0.5), # Case 2\n        (0.6, 0.25, 0.85, 0.04, 500.0, 0.5), # Case 3\n    ]\n\n    results = []\n\n    for case in test_cases:\n        alpha0, p_lo, p_hi, kappa, T_max, alpha_goal = case\n        \n        # 1. Analyze baseline environment to determine stability and success threshold\n        ess_points = find_ess(p_lo, MODEL_PARAMS)\n        stable_ess = sorted([e['alpha'] for e in ess_points if e['stability'] == 'stable'])\n        unstable_ess = [e['alpha'] for e in ess_points if e['stability'] == 'unstable']\n        \n        is_bistable = (len(stable_ess) == 2 and len(unstable_ess) == 1)\n        \n        if is_bistable:\n            # Unstable point is the basin separator\n            success_threshold = unstable_ess[0]\n        else:\n            # Use the provided goal for monostable or other cases\n            success_threshold = alpha_goal\n\n        # 2. Define success checker function for bisection\n        memo = {}\n        def check_success(T):\n            if T in memo:\n                return memo[T]\n            \n            alpha_end = run_simulation(alpha0, T, p_lo, p_hi, kappa, MODEL_PARAMS)\n            \n            is_successful = False\n            if is_bistable:\n                # For bistable systems, success is crossing to the low-virulence basin\n                if alpha_end  success_threshold:\n                    is_successful = True\n            else:\n                # For monostable, success is reaching the target\n                if alpha_end = success_threshold:\n                    is_successful = True\n            \n            memo[T] = is_successful\n            return is_successful\n\n        # 3. Use bisection to find minimal pulse duration T_star\n        # Check boundaries first\n        if not check_success(T_max):\n            T_star = -1.0\n        elif check_success(0):\n            T_star = 0.0\n        else:\n            # Perform bisection\n            low_T, high_T = 0.0, T_max\n            # 100 iterations give high precision: T_max / 2^100\n            for _ in range(100):\n                mid_T = (low_T + high_T) / 2\n                if check_success(mid_T):\n                    high_T = mid_T\n                else:\n                    low_T = mid_T\n            T_star = high_T\n        \n        results.append(T_star)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\n# Run the solver when the script is executed\nsolve()\n```"
        }
    ]
}