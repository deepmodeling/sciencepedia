{
    "hands_on_practices": [
        {
            "introduction": "本练习将探索定向进化的第一步：构建突变体文库。我们将通过分析两种广泛使用的技术——定点饱和突变和易错PCR——所产生的文库的多样性和质量，来对它们进行比较。这种实践对于学习如何选择和设计诱变策略至关重要，它能帮助你在遗传多样性与非预期结果（如提前出现终止密码子）之间取得平衡。",
            "id": "2701198",
            "problem": "一个基因中的单个活性位点密码子将通过定向进化中使用的两种策略进行多样化：（i）使用NNK或NNS简并性的定点饱和突变，以及（ii）易错聚合酶链式反应（PCR）。此处，NNK和NNS遵循国际纯粹与应用化学联合会（IUPAC）的命名法，其中$N \\in \\{A,C,G,T\\}$，$K \\in \\{G,T\\}$，且$S \\in \\{C,G\\}$。假设使用标准遗传密码（不包括硒代半胱氨酸和吡咯赖氨酸），因此有$20$种蛋白质氨基酸外加终止密码子。假设在每种简并性方案中，对所有允许的三联体进行均匀采样。对于易错PCR，假设每碱基的突变概率$\\mu$很小，并且存在转换/颠换偏好，使得在某个碱基发生突变的条件下，单个转换的发生可能性是每个单个颠换的$\\kappa$倍。因此，在给定碱基发生突变的条件下，转换发生的概率为$\\kappa/(\\kappa+2)$，而每次颠换发生的概率为$1/(\\kappa+2)$。\n\n任务：\n- 仅使用标准遗传密码以及NNK和NNS的定义，通过计算每种氨基酸包含了多少个有义密码子，推导出NNK和NNS文库中单个密码子处的氨基酸频率分布。根据这些计数，确定NNK和NNS方案下的终止密码子比例。\n- 考虑易错PCR作用于单个野生型密码子$AAA$（赖氨酸），并在$\\mu$的一阶上进行计算，忽略密码子内发生两次或更多次突变的事件。使用遗传密码，确定$AAA$处的哪些单核苷酸替换会产生终止密码子，并计算在易错PCR下，在该密码子处引入终止密码子的一阶概率，该概率是$\\mu$和$\\kappa$的函数。\n- 通过将易错PCR的终止密码子引入概率与NNK文库的终止密码子比例相等，求解临界每碱基突变概率$\\mu^{\\ast}$，使得两种终止率相匹配。\n\n请以包含$\\kappa$的单个闭式表达式给出你的最终答案。不需包含单位。无需四舍五入。",
            "solution": "对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- **系统**：基因中的一个单个活性位点密码子。\n- **方法1**：使用NNK或NNS简并性方案进行定点饱和突变。定义已给出：$N \\in \\{A,C,G,T\\}$, $K \\in \\{G,T\\}$, $S \\in \\{C,G\\}$。\n- **方法2**：对野生型密码子$AAA$（赖氨酸）进行易错聚合酶链式反应（epPCR）。\n- **参数**：每碱基突变概率$\\mu$（很小），转换/颠换偏好$\\kappa$。\n- **epPCR的概率**：在发生突变的条件下，转换的概率为$\\frac{\\kappa}{\\kappa+2}$，两种可能的颠换中每一种的概率为$\\frac{1}{\\kappa+2}$。\n- **假设**：\n    - 使用标准遗传密码，包含$20$种蛋白质氨基酸和终止密码子。\n    - 在NNK和NNS方案中，对所有允许的三联体进行均匀采样。\n    - 对于epPCR，计算在$\\mu$的一阶上进行，忽略发生两次或更多次突变的事件。\n- **任务**：\n    1. 推导NNK和NNS文库的氨基酸频率分布和终止密码子比例。\n    2. 计算通过epPCR在$AAA$密码子处引入终止密码子的一阶概率，作为$\\mu$和$\\kappa$的函数。\n    3. 将epPCR终止概率与NNK终止比例相等，求解临界突变概率$\\mu^{\\ast}$。\n\n**第二步：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学性**：该问题基于分子生物学和定向进化中的基本和标准技术，包括简并密码子文库（NNK, NNS）和易错PCR。突变偏好模型（$\\kappa$）是一个标准表示法。该问题具有科学合理性。\n- **良态性**：问题定义清晰，包含所有必要的参数（$\\mu, \\kappa$）、初始条件（野生型密码子$AAA$）和简化假设（$\\mu$的一阶近似）。任务是顺序的，并导向一个唯一的、可确定的$\\mu^{\\ast}$解。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观性或模糊性。\n- **完整性与一致性**：问题是自洽的。它依赖于“标准遗传密码”，这是一项普遍接受的科学信息，而非缺失数据。所有定义和约束都是一致的。\n\n**第三步：结论与行动**\n该问题被判定为**有效**。这是一个在定量生物学中良态的、具有科学基础的问题。将提供完整解答。\n\n解答将分为三部分构建，对应于问题陈述中列出的任务。\n\n**第一部分：NNK和NNS密码子文库分析**\nNNK和NNS简并性方案用于生成密码子文库。\n对于NNK方案，密码子结构是$N_1N_2K_3$，其中$N_1, N_2 \\in \\{A, C, G, T\\}$且$K_3 \\in \\{G, T\\}$。NNK文库中独特的密码子总数为 $4 \\times 4 \\times 2 = 32$。\n标准遗传密码包含三个终止密码子：$TAA$、$TAG$和$TGA$。我们必须确定这些密码子中有哪些存在于NNK文库中。\n- 无法生成以$A$结尾的密码子，因此$TAA$和$TGA$不在NNK文库中。\n- 可以生成以$G$结尾的密码子。对于前缀$TA$，NNK方案生成$TAG$（来自$K_3=G$）和$TAT$（来自$K_3=T$）。密码子$TAG$是一个终止密码子。\n- 没有其他前缀$N_1N_2$可以生成终止密码子。例如，前缀$TG$生成$TGG$（色氨酸）和$TGT$（半胱氨酸）。\n因此，NNK文库只包含一个终止密码子，$TAG$。\n终止密码子比例$F_{\\text{stop, NNK}}$是终止密码子数量与密码子总数的比率：\n$$F_{\\text{stop, NNK}} = \\frac{1}{32}$$\n为求完整，我们分析NNS方案。其结构是$N_1N_2S_3$，其中$S_3 \\in \\{C, G\\}$。密码子总数为$4 \\times 4 \\times 2 = 32$。\n- 终止密码子$TAA$和$TGA$以$A$结尾，因此不在NNS文库中。\n- 终止密码子$TAG$以$G$结尾。它由前缀$TA$在$S_3=G$时生成。\n因此，根据所提供的明确定义，NNS文库也只包含一个终止密码子（$TAG$），其终止密码子比例为$F_{\\text{stop, NNS}} = \\frac{1}{32}$。此任务也要求氨基酸分布，可以通过枚举每种方案的所有$32$个密码子并将它们映射到氨基酸来推导。两种方案都编码了所有$20$种标准氨基酸，但频率有偏。对于最终计算，只需要$F_{\\text{stop, NNK}}$。\n\n**第二部分：易错PCR终止密码子概率**\n我们分析在epPCR条件下，在野生型密码子$AAA$（赖氨酸）处引入终止密码子的情况，精确到每碱基突变概率$\\mu$的一阶。此近似意味着我们只考虑在三碱基密码子内发生单核苷酸替换的事件。发生两次或更多次突变的概率为$O(\\mu^2)$阶，因此被忽略。\n\n所有三个位置的原始碱基都是腺嘌呤（$A$），它是一种嘌呤。$A$的突变可以是转换（$A \\to G$）或颠换（$A \\to C$或$A \\to T$）。\n给定一个碱基发生突变，其为转换的概率是$\\frac{\\kappa}{\\kappa+2}$，其为特定颠换的概率是$\\frac{1}{\\kappa+2}$。在任何给定碱基上发生特定突变的概率是总突变概率$\\mu$与特定碱基变化的条件概率的乘积。\n- 转换$A \\to G$的概率：$P(A \\to G) = \\mu \\cdot \\frac{\\kappa}{\\kappa+2}$\n- 颠换$A \\to C$的概率：$P(A \\to C) = \\mu \\cdot \\frac{1}{\\kappa+2}$\n- 颠换$A \\to T$的概率：$P(A \\to T) = \\mu \\cdot \\frac{1}{\\kappa+2}$\n\n我们检查所有源于$AAA$的可能的单核苷酸替换：\n1.  **位置1的突变**：\n    - $AAA \\to CAA$ (Gln)\n    - $AAA \\to GAA$ (Glu)\n    - $AAA \\to TAA$ (终止)\n    一个终止密码子（$TAA$）由第一个位置的$A \\to T$颠换产生。\n2.  **位置2的突变**：\n    - $AAA \\to ACA$ (Thr)\n    - $AAA \\to AGA$ (Arg)\n    - $AAA \\to ATA$ (Ile)\n    不产生终止密码子。\n3.  **位置3的突变**：\n    - $AAA \\to AAC$ (Asn)\n    - $AAA \\to AAG$ (Lys)\n    - $AAA \\to AAT$ (Asn)\n    不产生终止密码子。\n\n唯一产生终止密码子的单次突变事件是第一个位置的$A \\to T$突变，导致密码子$TAA$。另外两个终止密码子$TAG$和$TGA$需要至少两次突变才能从$AAA$产生，它们的概率是$O(\\mu^2)$阶，因此在一阶近似下被忽略。\n\n引入终止密码子的概率$P_{\\text{stop, epPCR}}$是这一特定事件的概率：位置1发生$A \\to T$突变，而位置2和3不发生突变。\n$$P_{\\text{stop, epPCR}} = P(A_1 \\to T) \\times P(\\text{在 } A_2 \\text{ 处无突变}) \\times P(\\text{在 } A_3 \\text{ 处无突变})$$\n$$P_{\\text{stop, epPCR}} = \\left(\\mu \\frac{1}{\\kappa+2}\\right) \\times (1-\\mu) \\times (1-\\mu)$$\n$$P_{\\text{stop, epPCR}} = \\frac{\\mu}{\\kappa+2} (1 - 2\\mu + \\mu^2)$$\n在$\\mu$的一阶近似下进行计算，意味着我们只保留$\\mu$的线性项。\n$$P_{\\text{stop, epPCR}} \\approx \\frac{\\mu}{\\kappa+2}$$\n\n**第三部分：临界突变概率$\\mu^{\\ast}$的推导**\n问题要求求解临界每碱基突变概率$\\mu^{\\ast}$，此时通过epPCR引入终止密码子的速率等于NNK文库中的终止密码子比例。我们将前几部分推导出的表达式相等：\n$$P_{\\text{stop, epPCR}}(\\mu^{\\ast}) = F_{\\text{stop, NNK}}$$\n$$\\frac{\\mu^{\\ast}}{\\kappa+2} = \\frac{1}{32}$$\n求解$\\mu^{\\ast}$得到最终表达式：\n$$\\mu^{\\ast} = \\frac{\\kappa+2}{32}$$\n该表达式给出了从$AAA$密码子开始的epPCR过程，其产生终止密码子的一阶概率与随机采样的NNK文库中终止密码子的频率相同时所需的每碱基突变率。",
            "answer": "$$\n\\boxed{\\frac{\\kappa+2}{32}}\n$$"
        },
        {
            "introduction": "变体文库创建后，下一步是筛选功能得到改进的个体。这个问题在酶的生化特性和其在活细胞内的进化适应度之间架起了桥梁。你将使用一个定量的“适应度图谱”来计算两种酶变体的相对马尔萨斯增长率，从而阐明催化效率 ($k_{\\text{cat}}/K_M$) 和细胞资源限制 ($r_{\\max}$)等因素如何决定筛选实验的结果。",
            "id": "2701222",
            "problem": "在恒浊器中进行的连续定向进化实验中，宿主细胞的生长与一种工程酶所提供的通量紧密耦合，该酶将一种限制性前体转化为一种必需代谢物。在亚饱和底物浓度下，每个酶分子的有效酶活性与催化效率成正比，因此增加转换数与米氏常数的比率会提高代谢物的供应速率。种群的马尔萨斯增长率（单位时间内）被建模为催化效率的线性函数，直至达到一个反映全局资源限制的生理上限。具体来说，适应度图谱为\n$$\nr = \\min\\!\\big(r_0 + \\beta \\,(k_{\\text{cat}}/K_M), \\, r_{\\max}\\big),\n$$\n其中 $r$ 是以 $\\mathrm{h}^{-1}$ 为单位的马尔萨斯增长率，$r_0$ 是在没有功能性酶的情况下的基线增长率，$\\beta$ 是一个将催化效率转换为增长率的比例常数，$r_{\\max}$ 是在给定环境下的最大可达增长率。此处，$(k_{\\text{cat}}/K_M)$ 的单位是 $\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}$，因此 $\\beta$ 的单位是 $\\mathrm{h}^{-1}\\,\\mu\\mathrm{M}\\,\\mathrm{s}$，而 $r$ 的单位是 $\\mathrm{h}^{-1}$。\n\n两种变体 $\\mathrm{A}$ 和 $\\mathrm{B}$，在选择实验所用的测定条件下测得其动力学参数如下：\n- 变体 $\\mathrm{A}$：$k_{\\text{cat},\\mathrm{A}} = 120\\,\\mathrm{s}^{-1}$，$K_{M,\\mathrm{A}} = 60\\,\\mu\\mathrm{M}$。\n- 变体 $\\mathrm{B}$：$k_{\\text{cat},\\mathrm{B}} = 400\\,\\mathrm{s}^{-1}$，$K_{M,\\mathrm{B}} = 50\\,\\mu\\mathrm{M}$。\n\n环境参数为 $r_0 = 0.15\\,\\mathrm{h}^{-1}$，$\\beta = 0.20\\,\\mathrm{h}^{-1}\\,\\mu\\mathrm{M}\\,\\mathrm{s}$，以及 $r_{\\max} = 0.80\\,\\mathrm{h}^{-1}$。\n\n使用连续时间中相对适应度的定义，即马尔萨斯增长率之比 $w_{\\mathrm{A}/\\mathrm{B}} = r_{\\mathrm{A}}/r_{\\mathrm{B}}$，计算变体 $\\mathrm{A}$ 相对于变体 $\\mathrm{B}$ 的相对适应度。将最终答案表示为四位有效数字的无量纲小数。",
            "solution": "问题陈述已被解析和验证。已知条件如下：\n马尔萨斯增长率$r$（单位为$\\mathrm{h}^{-1}$）的适应度图谱：\n$$\nr = \\min\\!\\big(r_0 + \\beta \\,(k_{\\text{cat}}/K_M), \\, r_{\\max}\\big)\n$$\n变体 $\\mathrm{A}$ 的参数：\n$k_{\\text{cat},\\mathrm{A}} = 120\\,\\mathrm{s}^{-1}$\n$K_{M,\\mathrm{A}} = 60\\,\\mu\\mathrm{M}$\n\n变体 $\\mathrm{B}$ 的参数：\n$k_{\\text{cat},\\mathrm{B}} = 400\\,\\mathrm{s}^{-1}$\n$K_{M,\\mathrm{B}} = 50\\,\\mu\\mathrm{M}$\n\n环境参数：\n$r_0 = 0.15\\,\\mathrm{h}^{-1}$\n$\\beta = 0.20\\,\\mathrm{h}^{-1}\\,\\mu\\mathrm{M}\\,\\mathrm{s}$\n$r_{\\max} = 0.80\\,\\mathrm{h}^{-1}$\n\n相对适应度的定义为 $w_{\\mathrm{A}/\\mathrm{B}} = r_{\\mathrm{A}}/r_{\\mathrm{B}}$。\n\n该问题具有科学依据，是适定的，并包含得出唯一解所需的所有信息。单位在内部是自洽的：乘积 $\\beta \\cdot (k_{\\text{cat}}/K_M)$ 的单位是 $(\\mathrm{h}^{-1}\\,\\mu\\mathrm{M}\\,\\mathrm{s}) \\cdot (\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}) = \\mathrm{h}^{-1}$，这与 $r$、$r_0$ 和 $r_{\\max}$ 的单位一致。因此，该问题是有效的，我们继续进行求解。\n\n求解过程需要根据所提供的适应度图谱，计算每个变体 $r_{\\mathrm{A}}$ 和 $r_{\\mathrm{B}}$ 的马尔萨斯增长率。这首先涉及确定催化效率，其定义为比率 $k_{\\text{cat}}/K_M$。\n\n对于变体 $\\mathrm{A}$，其催化效率为：\n$$\n\\left(\\frac{k_{\\text{cat}}}{K_M}\\right)_{\\mathrm{A}} = \\frac{k_{\\text{cat},\\mathrm{A}}}{K_{M,\\mathrm{A}}} = \\frac{120\\,\\mathrm{s}^{-1}}{60\\,\\mu\\mathrm{M}} = 2.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}\n$$\n然后使用适应度图谱的线性部分计算其潜在增长率：\n$$\nr_{0} + \\beta \\left(\\frac{k_{\\text{cat}}}{K_M}\\right)_{\\mathrm{A}} = 0.15\\,\\mathrm{h}^{-1} + (0.20\\,\\mathrm{h}^{-1}\\,\\mu\\mathrm{M}\\,\\mathrm{s}) \\cdot (2.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}) = 0.15\\,\\mathrm{h}^{-1} + 0.40\\,\\mathrm{h}^{-1} = 0.55\\,\\mathrm{h}^{-1}\n$$\n实际增长率 $r_{\\mathrm{A}}$ 是该值与生理最大值 $r_{\\max}$ 中的较小者。\n$$\nr_{\\mathrm{A}} = \\min(0.55\\,\\mathrm{h}^{-1}, 0.80\\,\\mathrm{h}^{-1}) = 0.55\\,\\mathrm{h}^{-1}\n$$\n\n接下来，我们对变体 $\\mathrm{B}$ 执行相同的计算。其催化效率为：\n$$\n\\left(\\frac{k_{\\text{cat}}}{K_M}\\right)_{\\mathrm{B}} = \\frac{k_{\\text{cat},\\mathrm{B}}}{K_{M,\\mathrm{B}}} = \\frac{400\\,\\mathrm{s}^{-1}}{50\\,\\mu\\mathrm{M}} = 8.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}\n$$\n其潜在增长率为：\n$$\nr_{0} + \\beta \\left(\\frac{k_{\\text{cat}}}{K_M}\\right)_{\\mathrm{B}} = 0.15\\,\\mathrm{h}^{-1} + (0.20\\,\\mathrm{h}^{-1}\\,\\mu\\mathrm{M}\\,\\mathrm{s}) \\cdot (8.0\\,\\mu\\mathrm{M}^{-1}\\,\\mathrm{s}^{-1}) = 0.15\\,\\mathrm{h}^{-1} + 1.60\\,\\mathrm{h}^{-1} = 1.75\\,\\mathrm{h}^{-1}\n$$\n实际增长率 $r_{\\mathrm{B}}$ 是该值与生理最大值 $r_{\\max}$ 中的较小者。在这种情况下，计算出的线性增长率超过了上限。\n$$\nr_{\\mathrm{B}} = \\min(1.75\\,\\mathrm{h}^{-1}, 0.80\\,\\mathrm{h}^{-1}) = 0.80\\,\\mathrm{h}^{-1}\n$$\n\n最后，变体 $\\mathrm{A}$ 相对于变体 $\\mathrm{B}$ 的相对适应度是它们马尔萨斯增长率的比值。\n$$\nw_{\\mathrm{A}/\\mathrm{B}} = \\frac{r_{\\mathrm{A}}}{r_{\\mathrm{B}}} = \\frac{0.55\\,\\mathrm{h}^{-1}}{0.80\\,\\mathrm{h}^{-1}} = \\frac{0.55}{0.80}\n$$\n该计算得出一个无量纲值：\n$$\nw_{\\mathrm{A}/\\mathrm{B}} = 0.6875\n$$\n问题要求答案表示为四位有效数字。计算值 $0.6875$ 恰好有四位有效数字，因此无需进一步舍入。",
            "answer": "$$\n\\boxed{0.6875}\n$$"
        },
        {
            "introduction": "在理解了适应度是如何决定的之后，我们就可以对进化随时间变化的动态过程进行建模。本练习模拟一个连续进化实验（如PACE），以预测一个有益变体如何在群体中占据主导地位。通过推导和应用复制子方程，你将计算到达固定所需的时间，这是评估定向进化活动效率和理解选择力量的关键指标。",
            "id": "2701202",
            "problem": "考虑一个简化的确定性模型，该模型使用一种噬菌粒系统（PACEmid）来进行噬菌体辅助连续进化（Phage-Assisted Continuous Evolution, PACE）。在一个连续培养体系中，存在两个相互竞争的谱系：一个是有益变体，另一个是野生型。设 $x_v(t)$ 和 $x_w(t)$ 分别表示它们在时间 $t$ 的绝对丰度，并设 $p(t) = \\dfrac{x_v(t)}{x_v(t) + x_w(t)}$ 表示有益变体的频率。假设每个谱系 $i \\in \\{v,w\\}$ 都遵循带有稀释的指数增长，即满足\n$$\n\\frac{dx_i}{dt} = m_i(\\sigma)\\, x_i,\n$$\n其中 $m_i(\\sigma) = r_i(\\sigma) - D$ 是净马尔萨斯增长率，$r_i(\\sigma)$ 是内在复制速率，$D$ 是培养池的稀释率，而 $\\sigma \\ge 0$ 是一个由实验者控制的标量选择强度参数。变体的复制速率依赖于 $\\sigma$ 的关系为\n$$\nr_v(\\sigma) = r_0 + k\\,\\sigma,\n$$\n而野生型的复制速率为\n$$\nr_w(\\sigma) = r_0,\n$$\n其中 $r_0 > 0$ 和 $k > 0$ 是常数。假设在所考虑的时间尺度上，突变和随机漂变的影响可以忽略不计，并且系统是充分混合的。\n\n从上述基本定义出发，推导控制 $p(t)$ 的常微分方程，以及变体频率从初始频率 $p_0$ 达到预设目标 $p^\\star$ 所需时间的相应闭式解，该解应表示为 $\\sigma$ 的函数。然后，实现一个程序，对于一组给定的 $\\sigma$ 值，该程序能够 (i) 使用固定步长的显式欧拉积分法对富集轨迹 $p(t)$ 进行数值模拟，并 (ii) 计算达到 $p^\\star$ 的闭式解时间；程序最终应仅输出指定测试集的闭式解时间。\n\n使用以下参数化设置，这在连续进化环境中是科学合理的：\n- 基础复制速率: $r_0 = 0.6$ 每小时。\n- 选择增益系数: $k = 0.2$ 每小时每单位 $\\sigma$。\n- 稀释率: $D = 0.5$ 每小时。\n- 初始变体频率: $p_0 = 10^{-4}$ (无量纲)。\n- 固定阈值: $p^\\star = 0.99$ (无量纲)，解释为实际上的固定。\n- 时间单位: 所有时间必须以小时为单位报告。\n- 模拟积分器步长: $\\Delta t = 0.01$ 小时。\n- 最大模拟时间范围: $T_{\\max} = 10000$ 小时。\n\n任务：\n- 根据给定的增长定律，推导关于 $p(t)$ 的精确微分方程，以及从 $p_0$ 达到 $p^\\star$ 所需时间的闭式表达式，该表达式应为 $\\sigma$ 的函数。不要假设任何未从给定定义中推导出的简化公式。\n- 实现一个程序，对下面测试集中的每个 $\\sigma$ 值执行以下操作：\n  - 使用推导出的 $p(t)$ 动态学和显式欧拉方法模拟富集轨迹 $p(t)$，并检测第一个满足 $p(t) \\ge p^\\star$ 的时间 $t$（如果这在 $T_{\\max}$ 内发生）。在最后一步内使用线性插值来精确估计到达时间。\n  - 使用你推导的公式计算闭式解时间。\n  - 使用闭式解时间作为测试集的最终答案。\n- 如果对于给定的 $\\sigma$，对变体的选择不是有利的（即变体在频率空间中是中性选择的或处于劣势），则将固定时间定义为 $-1.0$（一个表示模型中未发生固定的哨兵值）。\n\n测试集（选择强度值）：\n- $\\sigma = 0.0$\n- $\\sigma = 0.1$\n- $\\sigma = 0.5$\n- $\\sigma = 1.0$\n- $\\sigma = 2.0$\n- $\\sigma = 5.0$\n\n输出规范：\n- 你的程序应生成单行输出，其中包含测试集从 $p_0$ 到达 $p^\\star$ 的闭式解时间，按顺序排列，形式为用方括号括起来的逗号分隔列表。\n- 时间必须四舍五入到 3 位小数并以小时为单位报告。对于模型下不可能发生固定的情况，输出精确的 $-1.0$（带一位小数）来代替时间。\n- 示例格式：$\\texttt{[t_1,t_2,t_3,t_4,t_5,t_6]}$，其中每个 $t_i$ 是如上所述的浮点数。\n\n你的解决方案必须普遍适用且自成一体，仅依赖于所述的数学和算法逻辑。程序没有外部输入；它必须在内部使用上面指定的测试集。",
            "solution": "本问题要求推导连续培养系统中一个有益变体的种群动态，并随后计算该变体达到指定频率所需的时间。我们将首先推导控制变体频率 $p(t)$ 的常微分方程（ODE），并求解该方程以找到达到固定所需时间的闭式表达式。然后，我们将描述如何实现一个程序，用以对一组给定的参数计算这个时间。\n\n首先，我们推导有益变体频率 $p(t)$ 的微分方程。频率定义为：\n$$\np(t) = \\frac{x_v(t)}{x_v(t) + x_w(t)}\n$$\n其中 $x_v(t)$ 和 $x_w(t)$ 分别是变体和野生型谱系的绝对丰度。为了求出 $p(t)$ 的变化率，我们使用商法则对时间 $t$ 求导：\n$$\n\\frac{dp}{dt} = \\frac{\\frac{dx_v}{dt}(x_v + x_w) - x_v\\left(\\frac{dx_v}{dt} + \\frac{dx_w}{dt}\\right)}{(x_v + x_w)^2}\n$$\n问题陈述了丰度遵循带有稀释的指数增长：$\\frac{dx_i}{dt} = m_i(\\sigma) x_i$，对于 $i \\in \\{v, w\\}$，其中 $m_i(\\sigma)$ 是净马尔萨斯增长率。将这些表达式代入导数中可得：\n$$\n\\frac{dp}{dt} = \\frac{(m_v x_v)(x_v + x_w) - x_v(m_v x_v + m_w x_w)}{(x_v + x_w)^2}\n$$\n展开分子，我们得到：\n$$\nm_v x_v^2 + m_v x_v x_w - m_v x_v^2 - m_w x_v x_w = (m_v - m_w)x_v x_w\n$$\n因此，导数简化为：\n$$\n\\frac{dp}{dt} = (m_v - m_w) \\frac{x_v x_w}{(x_v + x_w)^2}\n$$\n我们可以将项 $\\frac{x_v x_w}{(x_v + x_w)^2}$ 表示为 $p$ 的函数。根据定义，$p = \\frac{x_v}{x_v + x_w}$ 且 $1 - p = \\frac{x_w}{x_v + x_w}$。因此，$p(1-p) = \\frac{x_v x_w}{(x_v + x_w)^2}$。这导出了著名的复制子方程（replicator equation）：\n$$\n\\frac{dp}{dt} = (m_v - m_w) p(1-p)\n$$\n项 $s(\\sigma) = m_v - m_w$ 代表选择系数，即净增长率之差。使用给定的表达式 $m_v(\\sigma) = r_v(\\sigma) - D$ 和 $m_w(\\sigma) = r_w(\\sigma) - D$，以及 $r_v(\\sigma) = r_0 + k\\sigma$ 和 $r_w(\\sigma) = r_0$，选择系数为：\n$$\ns(\\sigma) = (r_0 + k\\sigma - D) - (r_0 - D) = k\\sigma\n$$\n因此，控制变体频率的最终常微分方程是：\n$$\n\\frac{dp}{dt} = k\\sigma\\, p(1-p)\n$$\n接下来，我们求解此常微分方程，以求得频率从初始值 $p_0$ 增加到目标值 $p^\\star$ 所需的时间 $T$。该方程是可分离的：\n$$\n\\frac{dp}{p(1-p)} = k\\sigma\\, dt\n$$\n我们将方程两边分别从初始状态 $(t=0, p=p_0)$ 积分到最终状态 $(t=T, p=p^\\star)$：\n$$\n\\int_{p_0}^{p^\\star} \\frac{dp}{p(1-p)} = \\int_0^T k\\sigma\\, dt\n$$\n左边的积分使用部分分式分解法求解，其中 $\\frac{1}{p(1-p)} = \\frac{1}{p} + \\frac{1}{1-p}$。\n$$\n\\int_{p_0}^{p^\\star} \\left(\\frac{1}{p} + \\frac{1}{1-p}\\right) dp = [\\ln(p) - \\ln(1-p)]_{p_0}^{p^\\star} = \\left[\\ln\\left(\\frac{p}{1-p}\\right)\\right]_{p_0}^{p^\\star}\n$$\n计算该定积分可得：\n$$\n\\ln\\left(\\frac{p^\\star}{1-p^\\star}\\right) - \\ln\\left(\\frac{p_0}{1-p_0}\\right) = \\ln\\left(\\frac{p^\\star(1-p_0)}{p_0(1-p^\\star)}\\right)\n$$\n右边的积分即为 $k\\sigma T$。令两边结果相等并求解 $T$，即可得到达到固定所需时间的闭式表达式：\n$$\nT = \\frac{1}{k\\sigma} \\ln\\left(\\frac{p^\\star(1-p_0)}{p_0(1-p^\\star)}\\right)\n$$\n此公式仅在选择对变体有利时有效，即 $s(\\sigma) = k\\sigma > 0$。由于 $k > 0$ 且 $\\sigma \\ge 0$，此条件简化为 $\\sigma > 0$。如果 $\\sigma=0$，选择系数为零，$\\frac{dp}{dt}=0$，频率保持在 $p_0$ 不变。在这种中性情况下，永远不会达到目标 $p^\\star$，对应于无限长的固定时间。根据要求，对于这种情况，我们将报告时间为 $-1.0$。\n\n要实现的程序将对测试集中的每个 $\\sigma$ 值执行两项任务。首先，它使用推导出的闭式公式计算达到固定的时间。其次，为了完整性和遵守问题要求，它使用步长为 $\\Delta t$ 的显式欧拉方法对常微分方程 $\\frac{dp}{dt} = k\\sigma\\, p(1-p)$ 进行数值模拟。更新规则是 $p_{n+1} = p_n + \\Delta t \\cdot k\\sigma \\cdot p_n(1-p_n)$。模拟从 $p(0)=p_0$ 开始，一直进行到 $p(t) \\ge p^\\star$，并通过线性插值来精确化穿越时间。然而，最终输出将只包含根据解析公式计算并按要求四舍五入的时间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the time to fixation for a beneficial variant\n    in a simplified PACEmid model. It computes the closed-form time for a suite of\n    selection stringencies and formats the output as specified.\n    \"\"\"\n    \n    # Define the parameters from the problem statement.\n    # Basal replication rate (per hour)\n    r0 = 0.6\n    # Selection gain coefficient (per hour per unit sigma)\n    k = 0.2\n    # Dilution rate (per hour)\n    D = 0.5\n    # Initial variant frequency (dimensionless)\n    p0 = 1e-4\n    # Fixation threshold (dimensionless)\n    p_star = 0.99\n    # Simulation integrator step size (hours)\n    dt = 0.01\n    # Maximum simulated time horizon (hours)\n    T_max = 10000\n\n    # Test suite of selection stringency values (dimensionless)\n    test_suite_sigmas = [0.0, 0.1, 0.5, 1.0, 2.0, 5.0]\n\n    # List to store the final results (closed-form times)\n    results = []\n\n    # Although the problem requires implementing the numerical simulation,\n    # the final output is based only on the closed-form solution.\n    # The numerical simulation serves as a verification of the analytical derivation.\n    # We will compute both as requested.\n    \n    for sigma in test_suite_sigmas:\n        # The selection coefficient in the frequency dynamics is s = k*sigma\n        selection_coefficient = k * sigma\n        \n        # Case 1: Favorable selection (s > 0)\n        if selection_coefficient > 0:\n            # (ii) Compute the closed-form time to fixation\n            # T = (1/(k*sigma)) * ln( (p_star*(1-p0)) / (p0*(1-p_star)) )\n            log_term_numerator = p_star * (1 - p0)\n            log_term_denominator = p0 * (1 - p_star)\n            closed_form_time = (1 / selection_coefficient) * np.log(log_term_numerator / log_term_denominator)\n            \n            # (i) Numerically simulate the trajectory using explicit Euler method\n            # This part is implemented as per the problem description but its result is not used in the final output.\n            p = p0\n            t = 0.0\n            time_steps = int(T_max / dt)\n            \n            numerical_time = -1.0 # Default value if threshold is not reached\n            found_crossing = False\n            for step in range(1, time_steps + 1):\n                p_prev = p\n                t_prev = t\n                \n                # Update frequency using explicit Euler for dp/dt = s * p * (1-p)\n                p = p + dt * selection_coefficient * p * (1 - p)\n                t = step * dt\n                \n                if p >= p_star:\n                    # Linearly interpolate to find the precise crossing time\n                    if (p - p_prev) > 0:\n                        t_cross = t_prev + dt * (p_star - p_prev) / (p - p_prev)\n                        numerical_time = t_cross\n                    else: # p == p_prev (or floating point issue), unlikely\n                        numerical_time = t\n                    found_crossing = True\n                    break\n            \n            # Append the analytical result to the list for output\n            results.append(closed_form_time)\n\n        # Case 2: Neutral or disadvantageous selection (s <= 0)\n        else:\n            # Fixation is not possible, time is defined as -1.0\n            results.append(-1.0)\n\n    # Format the results for the final output string\n    # Times are rounded to 3 decimal places, or -1.0 for non-fixation cases.\n    output_list = []\n    for time_val in results:\n        if time_val == -1.0:\n            output_list.append(\"-1.0\")\n        else:\n            output_list.append(f\"{time_val:.3f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(output_list)}]\")\n\n# Execute the main function to solve the problem and print the answer.\nsolve()\n```"
        }
    ]
}