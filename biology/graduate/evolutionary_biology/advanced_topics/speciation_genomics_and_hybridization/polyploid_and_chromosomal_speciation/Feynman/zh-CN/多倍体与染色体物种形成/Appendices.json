{
    "hands_on_practices": [
        {
            "introduction": "多倍体的起源通常是一个罕见事件，始于未减数配子的偶然形成。本练习运用基本概率论来为这一基础步骤建模，推导自四倍体的形成速率。通过这项实践，您可以理解减数分裂错误率 ($u$) 和交配系统 ($s$) 等因素如何影响多倍体的初始出现，并揭示在特定假设下，形成率与自交率无关这一令人惊讶的结论。",
            "id": "2744643",
            "problem": "在一个大的、随机交配的、雌雄同体的二倍体植物种群中，考虑单个繁殖季节中合子的形成。每个个体都产生雄性和雌性配子。在配子发生过程中，每个配子独立地发生减数分裂失败而成为未减数配子（倍性为 $2n$）的概率为 $u \\in [0,1]$，而成为减数配子（倍性为 $n$）的概率为 $1-u$。一部分比例为 $s \\in [0,1]$ 的合子通过单个个体的自花受精形成，其余比例为 $1-s$ 的合子通过不同个体间的随机交配形成。假设：\n- 个体内和个体间的配子发生事件是独立的（即使在同一亲本内，雄性和雌性减数分裂也是独立的）。\n- 合子倍性是亲本配子倍性之和。\n- 在此设定中，只有两个未减数配子的结合才能产生同源四倍体 ($4n$) 合子。其他形成 $4n$ 的途径（例如，合子形成后的体细胞加倍）不存在。\n- 此处考虑的所有具有相容倍性等级的合子在形成时都是存活的。\n\n使用减数分裂分离的基本原理和全概率定律，推导新形成的合子中同源四倍体所占的期望比例 $R_{4n}(u,s)$，以 $u$ 和 $s$ 表示。将您的答案表示为关于 $u$ 和 $s$ 的单一封闭形式表达式。不要以百分比形式报告；以 $[0,1]$ 范围内的分数形式提供表达式。不需要数值四舍五入。",
            "solution": "对问题陈述进行验证。\n\n第一步：提取已知条件\n- 种群是大的、随机交配的、雌雄同体的、二倍体的。\n- 合子形成发生在单个繁殖季节内。\n- 每个个体都产生雄性和雌性配子。\n- 未减数 ($2n$) 配子的概率为 $u \\in [0,1]$。\n- 减数 ($n$) 配子的概率为 $1-u$。\n- 一部分比例为 $s \\in [0,1]$ 的合子通过自花受精形成。\n- 一部分比例为 $1-s$ 的合子通过随机交配形成。\n- 配子发生事件在个体内和个体间是独立的。\n- 合子倍性是亲本配子倍性之和。\n- 同源四倍体 ($4n$) 合子仅由两个未减数 ($2n$) 配子结合形成。\n- 所考虑的所有合子在形成时都是存活的。\n\n第二步：使用提取的已知条件进行验证\n该问题具有科学依据，植根于群体遗传学和进化生物学的原理，特别是多倍体的形成。问题提法明确，提供了所有必需的参数（$u$, $s$）和一个清晰的目标。语言客观而精确。诸如减数分裂失败独立性之类的假设被明确陈述，使得问题自洽且一致。该模型是真实生物过程的简化，但没有违反基本原理，也不包含事实上的不健全之处。这是一个可以形式化的问题，需要应用基础概率论。\n\n第三步：结论与行动\n问题被认定为有效。将推导解答。\n\n目标是确定新形成的合子中同源四倍体所占的期望比例，我们将其表示为 $R_{4n}(u,s)$。问题陈述指出，同源四倍体 ($4n$) 合子仅由两个未减数 ($2n$) 配子的融合形成。任何单个配子为未减数的概率给定为 $u$。\n\n我们可以使用全概率定律来解决这个问题。合子的形成可以划分为两个互斥事件：\n1.  自花受精（事件 $S$），其发生概率为 $P(S) = s$。\n2.  异交或随机交配（事件 $O$），其发生概率为 $P(O) = 1-s$。\n\n令 $Z_{4n}$ 为合子是同源四倍体的事件。该事件的总概率是其在不同受精模式下的条件概率之和，并按这些模式的概率加权：\n$$\nR_{4n}(u,s) = P(Z_{4n}) = P(Z_{4n} | S) P(S) + P(Z_{4n} | O) P(O)\n$$\n现在我们必须确定条件概率 $P(Z_{4n} | S)$ 和 $P(Z_{4n} | O)$。\n\n情况1：自花受精（以事件 $S$ 为条件）\n在这种情况下，单个亲本个体提供雄性和雌性两种配子。当且仅当这两个配子都是未减数 ($2n$) 配子时，才会产生 $4n$ 合子。令 $M_{2n}$ 为雄配子未减数的事件， $F_{2n}$ 为雌配子未减数的事件。每个事件的概率为 $P(M_{2n}) = u$ 和 $P(F_{2n}) = u$。\n问题明确指出“即使在同一亲本内，雄性和雌性减数分裂也是独立的”。因此，来自单个自花受精亲本的两个配子都是未减数的概率是它们各自概率的乘积：\n$$\nP(Z_{4n} | S) = P(M_{2n} \\cap F_{2n} | S) = P(M_{2n} | S) \\cdot P(F_{2n} | S) = u \\cdot u = u^{2}\n$$\n\n情况2：异交（以事件 $O$ 为条件）\n在这种情况下，合子由种群中随机选择的两个不同个体产生的配子形成。一个体提供雄配子，另一个体提供雌配子。同样，要形成一个 $4n$ 合子，两个配子都必须是未减数 ($2n$) 配子。\n问题陈述指出配子发生事件在“个体间”是独立的。从任何随机选择的个体中来的配子是未减数的概率为 $u$。因此，来自一个亲本的雄配子是未减数的概率为 $u$，来自另一个亲本的雌配子是未减数的概率也为 $u$。由于它们的独立性，联合概率为：\n$$\nP(Z_{4n} | O) = P(M_{2n} \\cap F_{2n} | O) = P(M_{2n} | O) \\cdot P(F_{2n} | O) = u \\cdot u = u^{2}\n$$\n\n现在，我们将这些条件概率代入全概率公式：\n$$\nR_{4n}(u,s) = P(Z_{4n} | S) \\cdot s + P(Z_{4n} | O) \\cdot (1-s)\n$$\n$$\nR_{4n}(u,s) = u^{2} \\cdot s + u^{2} \\cdot (1-s)\n$$\n将 $u^{2}$ 提出来：\n$$\nR_{4n}(u,s) = u^{2} (s + (1-s))\n$$\n$$\nR_{4n}(u,s) = u^{2} (1)\n$$\n$$\nR_{4n}(u,s) = u^{2}\n$$\n结果表明，在问题所提供的严格独立性假设下，新形成的同源四倍体合子的比例与自交率 $s$ 无关。形成一个 $4n$ 合子的概率仅仅是两个独立的减数分裂失败事件发生的概率，每个对合子有贡献的配子各发生一次，而不管这些配子是来自一个还是两个亲本。",
            "answer": "$$\n\\boxed{u^{2}}\n$$"
        },
        {
            "introduction": "一旦多倍体建立，它们通常会与其二倍体祖先共存并相互作用，形成连接不同倍性水平的“三倍体桥梁”。本练习将群体遗传学模型扩展到混合倍性系统，聚焦于三倍体的形成及其在介导基因流中的作用。这个练习对于理解生殖隔离的动态至关重要，通过量化跨倍性水平的基因流，您可以评估三倍体桥梁如何根据其育性 ($\\phi$) 等参数来加强或打破物种界限。",
            "id": "2744681",
            "problem": "考虑一个同源多倍体植物，其种群中同时存在两种细胞型：二倍体（倍性为 $2x$）和四倍体（倍性为 $4x$）。该种群是大型、随机交配的雌雄同体种群。设成年个体的细胞型频率分别为：$2x$ 的频率为 $f_{2}$，$4x$ 的频率为 $f_{4}$，且 $f_{2}+f_{4}=1$。我们做出以下基本事实和简化假设，这些假设在许多同源多倍体系统中得到了充分支持：\n\n- 在随机交配（配子随机结合）的情况下，$2x$ 和 $4x$ 细胞型之间的异型配对（heterotypic pairings）的期望比例为 $2 f_{2} f_{4}$；同型配对（homotypic pairings）的比例分别为 $f_{2}^{2}$ 和 $f_{4}^{2}$。\n- 二倍体（$2x$）产生单倍体（$x$）配子；四倍体（$4x$）产生二倍体（$2x$）配子；$2x$ 或 $4x$ 均不产生未减数配子。\n- 异型交配 $2x \\times 4x$ 产生能存活至繁殖阶段的三倍体（$3x$）合子；同型交配分别产生 $2x$ 或 $4x$ 的合子。\n- 三倍体的减数分裂是多体式的（polysomic），且同源染色体分离是无偏的。在产生任何存活配子的条件下，一个三倍体产生整倍体 $x$ 配子和 $2x$ 配子的概率相等，均为 $1/2$；非整倍体配子不存活，因此忽略不计。\n- 将三倍体育性参数 $\\phi \\in [0,1]$ 定义为：涉及一个三倍体亲本与一个 $2x$ 或 $4x$ 交配对象的一次交配中，产生任何可存活整倍体合子（计算该交配可能产生的两种整倍体后代）的概率。因此，在一次成功的交配的条件下，后代与交配对象的细胞型相同（即 $3x \\times 2x$ 交配产生 $2x$ 后代，或 $3x \\times 4x$ 交配产生 $4x$ 后代）的概率为 $1/2$。\n\n在此框架下：\n\n1) 在随机交配条件下，推导当前代合子中三倍体所占的期望比例 $R_{3}$，并将其表示为 $f_{2}$ 和 $f_{4}$ 的函数。\n\n2) 仅使用上述假设和参数 $\\phi$，推导通过“三倍体桥”实现的跨倍性基因流对每一代的贡献。这被定义为下一代所有合子中，通过 $3x$ 与 $4x$ 亲本回交而进入 $4x$ 群体（记为 $m_{2\\to 4}$）的比例，以及通过 $3x$ 与 $2x$ 亲本回交而进入 $2x$ 群体（记为 $m_{4\\to 2}$）的比例。假设所考虑的连续两代中细胞型频率近似恒定（因此下一代中三倍体遇到的交配对象按 $f_{2}$ 和 $f_{4}$ 的比例分布），并且每次交配最多产生一个合子。\n\n请用 $f_{2}$、$f_{4}$ 和 $\\phi$ 表示你的最终答案。以单行矩阵的形式，按 $R_{3}$、$m_{2\\to 4}$、$m_{4\\to 2}$ 的顺序提供最终表达式。无需进行数值近似。",
            "solution": "该问题要求推导与共存的二倍体和四倍体细胞型的种群遗传学相关的三个量：三倍体形成的初始速率，以及由这些三倍体介导的倍性水平之间的基因流速率。\n\n问题陈述的验证已经完成。该问题在科学上基于多倍体进化理论，问题设定良好，信息充分且一致，并以客观、正式的语言陈述。其简化假设是理论生物学该领域为获得分析性见解而采用的标准假设。该问题被认定为有效。\n\n以下是详细的推导过程。\n\n**第一部分：三倍体合子的期望比例 ($R_{3}$)**\n\n初始种群由二倍体（$2x$）和四倍体（$4x$）个体组成，其频率分别为 $f_{2}$ 和 $f_{4}$，满足 $f_{2} + f_{4} = 1$。交配通过配子的随机结合发生。\n\n三倍体（$3x$）合子完全由二倍体和四倍体个体之间的异型交配形成。\n一个二倍体个体（$2x$）产生单倍体（$x$）配子。一个四倍体个体（$4x$）产生二倍体（$2x$）配子。一个 $x$ 配子和一个 $2x$ 配子的结合产生一个 $3x$ 合子。\n\n问题陈述指出，种群中异型配对（$2x \\times 4x$）的期望比例为 $2 f_{2} f_{4}$。陈述还指出这些交配会产生三倍体合子。假设这些交配的育性为基准（归一化为1），则新一代合子中三倍体的比例等于产生它们的交配比例。\n\n因此，三倍体合子的期望比例，记为 $R_{3}$，为：\n$$R_{3} = 2 f_{2} f_{4}$$\n\n**第二部分：三倍体桥对基因流的贡献 ($m_{2\\to 4}$ 和 $m_{4\\to 2}$)**\n\n我们被要求推导下一代所有合子中，通过“三倍体桥”构成倍性水平之间基因流的比例。这个过程分两步发生：\n1.  由 $2x \\times 4x$ 交配形成三倍体。\n2.  这些三倍体与亲代的二倍体和四倍体种群进行回交。\n\n需要推导的量是：\n-   $m_{2\\to 4}$：合子中为四倍体（$4x$）且源自二倍体基因库（通过一个 $3x$ 中间体与一个 $4x$ 亲本回交）的比例。\n-   $m_{4\\to 2}$：合子中为二倍体（$2x$）且源自四倍体基因库（通过一个 $3x$ 中间体与一个 $2x$ 亲本回交）的比例。\n\n问题陈述为“下一代所有合子的比例”，这意味着这些量应被解释为相对于种群总合子产量的速率。“细胞型频率近似恒定”的假设使我们可以将基础的 $2x$ 和 $4x$ 种群的总合子产量视为基准，并可将其归一化为 1。这是因为总交配比例为 $f_{2}^{2} + 2f_{2}f_{4} + f_{4}^{2} = (f_{2} + f_{4})^{2} = 1^2 = 1$。如果每次交配产生一个合子，那么合子总数也归一化为 1。因此，$m_{2\\to 4}$ 和 $m_{4\\to 2}$ 是相对于此基准，通过三倍体桥途径产生的额外比例。\n\n让我们计算每个途径的通量。\n\n**$m_{2\\to 4}$ 的计算：**\n该途径代表了来自 $2x$ 基因库的基因进入 $4x$ 基因库。\n1.  必须通过 $2x \\times 4x$ 杂交形成一个三倍体。这些三倍体相对于总合子库的产生速率是 $R_{3} = 2f_{2}f_{4}$。\n2.  这个三倍体个体必须与一个四倍体（$4x$）交配。问题假设在频率恒定的种群中进行随机交配，因此这次交配的概率是 $f_{4}$。\n3.  这次 $3x \\times 4x$ 交配必须是可育的，能产生一个可存活的整倍体合子。这个概率是三倍体育性参数 $\\phi$。\n4.  在一次成功交配的前提下，后代必须是四倍体（$4x$）。一个三倍体产生 $x$ 和 $2x$ 配子的概率相等（均为 $1/2$）。一个四倍体交配对象产生 $2x$ 配子。可能产生的整倍体合子是 $x+2x=3x$ 和 $2x+2x=4x$。这两种情况发生的概率相等。因此，产生一个 $4x$ 合子的条件概率是 $1/2$。\n\n总比例 $m_{2\\to 4}$ 是这些连续事件概率的乘积：\n$$m_{2\\to 4} = (3x \\text{ 形成速率}) \\times (\\text{与 } 4x \\text{ 交配的概率}) \\times (\\text{育性}) \\times (4x \\text{ 后代的概率})$$\n$$m_{2\\to 4} = (2f_{2}f_{4}) \\times (f_{4}) \\times (\\phi) \\times \\left(\\frac{1}{2}\\right)$$\n$$m_{2\\to 4} = f_{2}f_{4}^{2}\\phi$$\n\n**$m_{4\\to 2}$ 的计算：**\n该途径代表了来自 $4x$ 基因库的基因进入 $2x$ 基因库。\n1.  必须通过 $2x \\times 4x$ 杂交形成一个三倍体。产生速率同样为 $R_{3} = 2f_{2}f_{4}$。\n2.  这个三倍体个体必须与一个二倍体（$2x$）交配。在相同假设下，这次交配的概率为 $f_{2}$。\n3.  这次 $3x \\times 2x$ 交配必须是可育的，概率为 $\\phi$。\n4.  在一次成功交配的前提下，后代必须是二倍体（$2x$）。一个三倍体产生 $x$ 和 $2x$ 配子（概率各为 $1/2$）。一个二倍体交配对象产生 $x$ 配子。可能产生的整倍体合子是 $x+x=2x$ 和 $2x+x=3x$。这两种情况发生的概率相等。产生一个 $2x$ 合子的条件概率是 $1/2$。\n\n总比例 $m_{4\\to 2}$ 是这些概率的乘积：\n$$m_{4\\to 2} = (3x \\text{ 形成速率}) \\times (\\text{与 } 2x \\text{ 交配的概率}) \\times (\\text{育性}) \\times (2x \\text{ 后代的概率})$$\n$$m_{4\\to 2} = (2f_{2}f_{4}) \\times (f_{2}) \\times (\\phi) \\times \\left(\\frac{1}{2}\\right)$$\n$$m_{4\\to 2} = f_{2}^{2}f_{4}\\phi$$\n\n所求三个量的最终表达式为：\n-   $R_{3} = 2f_{2}f_{4}$\n-   $m_{2\\to 4} = f_{2}f_{4}^{2}\\phi$\n-   $m_{4\\to 2} = f_{2}^{2}f_{4}\\phi$\n\n这些结果将以单行矩阵的形式呈现。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2f_{2}f_{4} & f_{2}f_{4}^{2}\\phi & f_{2}^{2}f_{4}\\phi \\end{pmatrix} } $$"
        },
        {
            "introduction": "在自然界中识别多倍体物种形成事件，需要整合来自细胞学（染色体计数）和杂交实验（育性）等多方面的证据。这项综合性练习旨在挑战您将关于多倍化的生物学假说转化为一个严谨的、定量的推断流程。这项计算实践连接了理论与应用，通过设计算法来检验特定的进化模式，将您的技能从理论计算提升至数据分析和模型推断的层面，这对于现代进化生物学家至关重要。",
            "id": "2744638",
            "problem": "您会收到若干个独立的测试用例。在每个测试用例中，都有一组由 $i \\in \\{1,\\dots,N\\}$ 索引的种群。对于每个种群 $i$，您会得到一个整数染色体数 $c_i \\in \\mathbb{N}$ 以及一个成对杂交育性对称矩阵 $F \\in [0,1]^{N \\times N}$，其中 $F_{ij}$ 在一个从 $0$ 到 $1$ 的无单位尺度上量化了种群 $i$ 和 $j$ 之间杂交的相对育性（$1$ 表示完全育性，与种群内杂交相同）。目标是实现一个数学上严谨的决策流程，以推断数据是否与多倍体物种形成事件最一致，并排除基于非整倍性或染色体多态性的解释。\n\n需要使用的基本生物学基础：\n- 全基因组复制意味着分化的细胞型之间的染色体数量按整数倍性因子缩放。在数学上，存在一个基数 $g \\in \\mathbb{N}$ 和整数乘数 $m_i \\in \\mathbb{N}$，使得对于每个 $i$ 都有 $c_i \\approx m_i g$。\n- 不同倍性水平之间的杂交育性通常会显著降低，而相同倍性水平内的杂交通常是可育的。因此，预期在共享相同推断乘数 $m_i$ 的组内育性较高，而在具有不同 $m_i$ 的组间育性较低。\n- 非整倍性意味着染色体数量与（本应）相似的基数有微小偏差（例如 $\\pm 1$），且群体间不具有整数倍数结构，通常不伴随由染色体数量引起的强烈、离散的育性分离。\n- 染色体多态性（例如结构重排）尽管染色体数量相同或几乎相同，也可能降低育性，并可能形成一支系内高育性、支系间低育性的模式，即使所有 $c_i$ 都相等（或几乎相等）。\n\n设计并实现一个程序，对每个测试用例应用以下纯粹用数学术语表述的逻辑：\n\n- 通过整数格点近似进行倍性模型拟合：\n  - 对于候选基数 $g \\in \\{2,3,\\dots,\\min_i c_i\\}$，通过 $m_i(g) = \\max\\{1, \\operatorname{round}(c_i / g)\\}$ 定义整数乘数，并通过 $r_i(g) = |c_i - m_i(g)\\,g|$ 定义所有 $i$ 的残差。\n  - 令平均绝对残差为 $\\bar r(g) = \\frac{1}{N} \\sum_{i=1}^N r_i(g)$。\n  - 将最佳拟合基数 $g^\\star$ 定义为候选集上 $\\bar r(g)$ 的一个最小值点。\n  - 如果 $\\bar r(g^\\star) \\le \\delta$ 且推断出的乘数集 $\\{m_i(g^\\star)\\}$ 产生至少两个不同的组，则接受倍性模型的拟合。\n\n- 基于推断出的乘数进行育性分离检验：\n  - 使用由 $m_i(g^\\star)$ 导出的划分，将组内平均育性 $\\mu_{\\mathrm{within}}$ 定义为所有满足 $m_i(g^\\star) = m_j(g^\\star)$ 的无序对 $(i,j)$（其中 $i < j$）的 $F_{ij}$ 的平均值，并将组间平均育性 $\\mu_{\\mathrm{between}}$ 定义为所有满足 $m_i(g^\\star) \\ne m_j(g^\\star)$ 的无序对 $(i,j)$（其中 $i < j$）的 $F_{ij}$ 的平均值。\n  - 如果至少存在一对组内配对和一对组间配对，并且 $\\mu_{\\mathrm{within}} \\ge \\theta_w$ 且 $\\mu_{\\mathrm{between}} \\le \\theta_b$，则接受育性分离。\n\n- 染色体多态性替代方案：\n  - 如果倍性模型拟合失败或育性分离检验失败，检查染色体数量是否几乎相同：$\\max_i c_i - \\min_i c_i \\le 1$。\n  - 如果几乎相同，则确定是否存在一种将种群划分为两个非空组的二分法，该划分能产生与上述阈值相同的组内与组间育性分离。形式上，对于 $\\{1,\\dots,N\\}$ 的所有非平凡二分划 $A$ 和 $B$（其中 $A \\ne \\emptyset$，$B \\ne \\emptyset$，$A \\cup B = \\{1,\\dots,N\\}$，$A \\cap B = \\emptyset$），计算所有在 $A$ 内或在 $B$ 内的无序对的平均育性（合并后的组内平均值），以及一个索引在 $A$ 中另一个在 $B$ 中的所有无序对的平均育性。如果存在至少一种二分划，使得合并后的组内平均值至少为 $\\theta_w$ 且组间平均值至多为 $\\theta_b$，则接受染色体多态性的解释。\n\n- 每个测试用例的最终分类：\n  - 如果倍性模型拟合被接受，并且（基于乘数的）育性分离检验也被接受，则输出 $2$。\n  - 否则，如果染色体多态性替代方案被接受，则输出 $1$。\n  - 否则，输出 $0$（与非整倍性或其他非多倍体解释一致）。\n\n对所有测试用例使用以下固定阈值：\n- 绝对残差容忍度 $\\delta = 1.0$。\n- 组内育性阈值 $\\theta_w = 0.7$。\n- 组间育性阈值 $\\theta_b = 0.2$。\n\n您的程序必须解决以下四个测试用例并汇总其分类结果：\n\n- 测试用例 1：\n  - 染色体数 $c = [\\,14,\\,14,\\,28,\\,28,\\,42,\\,42\\,]$。\n  - 育性矩阵 $F$ 定义为：对于所有 $i$，$F_{ii} = 1$；对于 $c=14$ 的前两个种群的组内配对，$F_{ij} = 0.92$；对于 $c=28$ 的两个种群的组内配对，$F_{ij} = 0.93$；对于 $c=42$ 的两个种群的组内配对，$F_{ij} = 0.91$；对于所有属于不同染色体数群组且 $i \\ne j$ 的配对 $(i,j)$，$F_{ij} = 0.08$。\n\n- 测试用例 2：\n  - 染色体数 $c = [\\,14,\\,15,\\,16,\\,15\\,]$。\n  - 育性矩阵 $F$ 定义为：对于所有 $i$，$F_{ii} = 1$；对于所有 $i \\ne j$，$F_{ij} = 0.5$。\n\n- 测试用例 3：\n  - 染色体数 $c = [\\,14,\\,14,\\,14,\\,14,\\,14,\\,14\\,]$。\n  - 育性矩阵 $F$ 由两个各含三个种群的支系定义：对于前三个索引内和后三个索引内的配对，当 $i \\ne j$ 且在同一支系内时，$F_{ij} = 0.9$；对于跨支系的配对，$F_{ij} = 0.1$；并且 $F_{ii} = 1$。\n\n- 测试用例 4：\n  - 染色体数 $c = [\\,24,\\,24,\\,48,\\,48,\\,49\\,]$。\n  - 育性矩阵 $F$ 定义为：对于所有 $i$，$F_{ii} = 1$；对于 $c=24$ 的两个种群的配对，$F_{ij} = 0.93$；对于 $c=48$ 的两个种群的配对，$F_{ij} = 0.92$；对于 $c=49$ 的种群与两个 $c=48$ 的种群之间的配对，$F_{ij} = 0.72$；对于染色体数为24的群组与染色体数为48或49的群组之间的所有配对，$F_{ij} = 0.08$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为用方括号括起来的逗号分隔列表，例如 $[2,0,1,2]$。输出值必须为整数。\n\n不涉及物理单位。不涉及角度。不得使用百分比；所有育性量均为 $[0,1]$ 范围内的无单位小数。",
            "solution": "该问题要求实现一种分类算法，以确定一组以染色体数量和种种群间育性为特征的种群，是否与多倍体物种形成、染色体多态性或其他进化机制最为一致。决策逻辑以一个带有固定数值阈值的多步骤流程形式提供。分析过程如下。\n\n首先，确认问题陈述的有效性。所有给定条件，包括种群数据（$c_i, F_{ij}$）、生物学前提、算法步骤和数值阈值（$\\delta, \\theta_w, \\theta_b$），都以明确、自洽且科学合理的方式提供。该问题是适定的、客观的，其形式化表述与定量进化生物学直接相关。不存在矛盾或致命的歧义。关于基数 $g^\\star$ 使用“一个最小值点”的指令，在存在多个最小值点时会引入轻微的歧义。必须建立一个确定性的平局打破规则。在此采用的一个合乎情理的选择是，选取能使平均残差最小化的最大候选基数 $g$，这反映了对最基本基因组单元的探索。因此，该问题被认定为有效。\n\n通过将规定的决策流程转化为计算算法来构建解决方案。设 $N$ 为种群数量。染色体数由向量 $c = (c_1, \\dots, c_N)$ 给出，育性矩阵由 $F \\in [0,1]^{N \\times N}$ 给出。\n\n**步骤 1：倍性模型拟合**\n此步骤评估染色体数 $c_i$ 代表基数 $g$ 的整数倍的假设。\n模型拟合度由平均绝对残差 $\\bar{r}(g)$ 量化。对于在整数范围 $\\{2, 3, \\dots, \\min_i c_i\\}$ 内的每个候选基数 $g$，我们计算：\n1.  整数乘数 $m_i(g) = \\max\\{1, \\operatorname{round}(c_i / g)\\}$。$\\operatorname{round}$ 函数将实数映射到最近的整数，其中 .5 将舍入到最近的偶数。$\\max\\{1, \\dots\\}$ 确保乘数至少为 $1$。\n2.  残差 $r_i(g) = |c_i - m_i(g) \\cdot g|$。\n3.  平均绝对残差 $\\bar{r}(g) = \\frac{1}{N} \\sum_{i=1}^N r_i(g)$。\n\n最优基数 $g^\\star$ 定义为 $\\bar{r}(g)$ 的一个最小值点。如果多个 $g$ 值产生相同的最小 $\\bar{r}(g)$，我们选择其中最大的作为 $g^\\star$。\n\n如果满足两个条件，则接受倍性模型：\n1.  最小平均残差不超过容忍度 $\\delta$：$\\bar{r}(g^\\star) \\le \\delta$。对于此问题，$\\delta=1.0$。\n2.  推断的乘数集 $\\{m_i(g^\\star)\\}_{i=1}^N$ 包含至少两个不同的值，这意味着种群间存在倍性差异。\n\n**步骤 2：育性分离检验**\n如果接受倍性模型，我们将检验推断的倍性组是否对应于生殖隔离，如此则由育性矩阵 $F$ 指示。\n使用由乘数 $m_i(g^\\star)$ 导出的种群划分，我们计算两个指标：\n1.  组内平均育性 $\\mu_{\\mathrm{within}}$：在所有种群 $i$ 和 $j$ 具有相同乘数 ($m_i(g^\\star) = m_j(g^\\star)$) 的无序对 $(i,j)$（其中 $i<j$）上 $F_{ij}$ 的平均值。\n2.  组间平均育性 $\\mu_{\\mathrm{between}}$：在所有种群 $i$ 和 $j$ 具有不同乘数 ($m_i(g^\\star) \\ne m_j(g^\\star)$) 的无序对 $(i,j)$（其中 $i<j$）上 $F_{ij}$ 的平均值。\n\n如果至少存在一对用于组内计算的种群和至少一对用于组间计算的种群，并且平均值满足以下条件：$\\mu_{\\mathrm{within}} \\ge \\theta_w$ 和 $\\mu_{\\mathrm{between}} \\le \\theta_b$，则通过育性分离检验。对于此问题，阈值为 $\\theta_w=0.7$ 和 $\\theta_b=0.2$。\n\n如果倍性模型拟合和育性分离检验均被接受，则该案例分类为多倍体物种形成（输出 $2$）。\n\n**步骤 3：染色体多态性替代方案**\n如果未能完全满足多倍体物种形成的准则（即倍性模型拟合或育性检验失败），我们评估一个替代假设：染色体多态性在没有显著改变染色体数目情况下导致生殖隔离。\n仅当所有种群的染色体数几乎相同时才执行此检查，定义条件为 $\\max_i c_i - \\min_i c_i \\le 1$。\n\n如果此条件成立，我们通过搜索所有可能的将种群集划分为两个非空组 $A$ 和 $B$ 的非平凡二分划，来寻找生殖隔离的证据。对于每个二分划 $\\{A, B\\}$，我们计算：\n1.  合并后的组内育性：在所有 $i, j$ 均在 $A$ 中或均在 $B$ 中（$i<j$）的配对 $(i,j)$ 上的 $F_{ij}$ 的平均值。\n2.  组间育性：在所有 $i \\in A$ 和 $j \\in B$ 的配对 $(i,j)$ 上的 $F_{ij}$ 的平均值。\n\n如果存在至少一种二分划，使得合并后的组内平均值至少为 $\\theta_w=0.7$ 且组间平均值至多为 $\\theta_b=0.2$，则接受染色体多态性的解释。分类则为染色体多态性（输出 $1$）。由于种群数量 $N$ 较小，可以穷举搜索所有划分。\n\n**步骤 4：最终分类**\n每个测试用例的最终输出由规则的顺序应用确定：\n- 如果倍性模型和随后的育性检验均通过，结果为 $2$。\n- 否则，如果染色体多态性替代方案被接受，结果为 $1$。\n- 否则，结果为 $0$，表示数据与其他现象（如非整倍性）最为一致，或所提供的模型拟合不佳。\n\n这个全面、分步的过程为每个测试用例提供了基于所提供数据和原则的严谨且客观的分类。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef classify_speciation(c_list, F):\n    \"\"\"\n    Classifies speciation mechanism based on chromosome counts and fertility matrix.\n    \n    Returns:\n        2: Polyploid speciation\n        1: Chromosomal polymorphism\n        0: Other (e.g., aneuploidy)\n    \"\"\"\n    c = np.array(c_list)\n    N = len(c)\n    delta = 1.0\n    theta_w = 0.7\n    theta_b = 0.2\n\n    # Step 1: Ploidy-model fit\n    min_r_bar = float('inf')\n    \n    # Candidate base counts g must be at least 2.\n    # If minimum chromosome count is less than 2, this test cannot be performed.\n    min_c = np.min(c)\n    if min_c  2:\n        g_star = -1\n    else:\n        g_candidates = range(2, min_c + 1)\n        g_minimizers = []\n        for g in g_candidates:\n            # Using np.round which rounds to nearest even for .5 cases\n            m = np.maximum(1, np.round(c / g)).astype(int)\n            r = np.abs(c - m * g)\n            r_bar = np.mean(r)\n            \n            if abs(r_bar - min_r_bar)  1e-9: # Comparing floats\n                g_minimizers.append(g)\n            elif r_bar  min_r_bar:\n                min_r_bar = r_bar\n                g_minimizers = [g]\n\n        g_star = max(g_minimizers) if g_minimizers else -1\n\n    ploidy_model_accepted = False\n    if g_star != -1:\n        m_star = np.maximum(1, np.round(c / g_star)).astype(int)\n        unique_multipliers = np.unique(m_star)\n        if min_r_bar = delta and len(unique_multipliers) > 1:\n            ploidy_model_accepted = True\n\n    # Step 2: Fertility separation test\n    fertility_separation_accepted = False\n    if ploidy_model_accepted:\n        m_star = np.maximum(1, np.round(c / g_star)).astype(int)\n        \n        within_fertilities = []\n        between_fertilities = []\n\n        for i in range(N):\n            for j in range(i + 1, N):\n                if m_star[i] == m_star[j]:\n                    within_fertilities.append(F[i, j])\n                else:\n                    between_fertilities.append(F[i, j])\n        \n        if within_fertilities and between_fertilities:\n            mu_within = np.mean(within_fertilities)\n            mu_between = np.mean(between_fertilities)\n            \n            if mu_within >= theta_w and mu_between = theta_b:\n                fertility_separation_accepted = True\n\n    # Final Classification Rule 1\n    if ploidy_model_accepted and fertility_separation_accepted:\n        return 2\n\n    # Step 3: Chromosomal polymorphism alternative\n    chromo_poly_accepted = False\n    if np.max(c) - np.min(c) = 1:\n        # Generate all non-trivial bipartitions. To avoid duplicates, fix one element (e.g., 0)\n        # in the first set and generate all non-empty, non-full subsets of the rest.\n        other_elements = list(range(1, N))\n        for k in range(len(other_elements) + 1):\n            for subset in itertools.combinations(other_elements, k):\n                set_A_indices = set([0] + list(subset))\n                \n                # Bipartition must be non-trivial\n                if len(set_A_indices) == N or len(set_A_indices) == 0:\n                    continue\n\n                set_B_indices = set(range(N)) - set_A_indices\n                \n                within_fertilities_pooled = []\n                # Pairs within A\n                if len(set_A_indices) > 1:\n                    for i, j in itertools.combinations(set_A_indices, 2):\n                        within_fertilities_pooled.append(F[i, j])\n                # Pairs within B\n                if len(set_B_indices) > 1:\n                    for i, j in itertools.combinations(set_B_indices, 2):\n                        within_fertilities_pooled.append(F[i, j])\n                \n                between_fertilities_pooled = []\n                for i in set_A_indices:\n                    for j in set_B_indices:\n                        between_fertilities_pooled.append(F[i, j])\n\n                if not within_fertilities_pooled or not between_fertilities_pooled:\n                    continue\n\n                mu_within_pooled = np.mean(within_fertilities_pooled)\n                mu_between_pooled = np.mean(between_fertilities_pooled)\n                \n                if mu_within_pooled >= theta_w and mu_between_pooled = theta_b:\n                    chromo_poly_accepted = True\n                    break\n            if chromo_poly_accepted:\n                break\n    \n    # Final Classification Rule 2  3\n    if chromo_poly_accepted:\n        return 1\n    \n    return 0\n\ndef solve():\n    # Define the test cases\n    test_cases = [\n        # Test case 1\n        {\n            \"c\": [14, 14, 28, 28, 42, 42],\n            \"F\": np.array([\n                [1.00, 0.92, 0.08, 0.08, 0.08, 0.08],\n                [0.92, 1.00, 0.08, 0.08, 0.08, 0.08],\n                [0.08, 0.08, 1.00, 0.93, 0.08, 0.08],\n                [0.08, 0.08, 0.93, 1.00, 0.08, 0.08],\n                [0.08, 0.08, 0.08, 0.08, 1.00, 0.91],\n                [0.08, 0.08, 0.08, 0.08, 0.91, 1.00]\n            ])\n        },\n        # Test case 2\n        {\n            \"c\": [14, 15, 16, 15],\n            \"F\": np.array([\n                [1.0, 0.5, 0.5, 0.5],\n                [0.5, 1.0, 0.5, 0.5],\n                [0.5, 0.5, 1.0, 0.5],\n                [0.5, 0.5, 0.5, 1.0]\n            ])\n        },\n        # Test case 3\n        {\n            \"c\": [14, 14, 14, 14, 14, 14],\n            \"F\": np.array([\n                [1.0, 0.9, 0.9, 0.1, 0.1, 0.1],\n                [0.9, 1.0, 0.9, 0.1, 0.1, 0.1],\n                [0.9, 0.9, 1.0, 0.1, 0.1, 0.1],\n                [0.1, 0.1, 0.1, 1.0, 0.9, 0.9],\n                [0.1, 0.1, 0.1, 0.9, 1.0, 0.9],\n                [0.1, 0.1, 0.1, 0.9, 0.9, 1.0]\n            ])\n        },\n        # Test case 4\n        {\n            \"c\": [24, 24, 48, 48, 49],\n            \"F\": np.array([\n                [1.00, 0.93, 0.08, 0.08, 0.08],\n                [0.93, 1.00, 0.08, 0.08, 0.08],\n                [0.08, 0.08, 1.00, 0.92, 0.72],\n                [0.08, 0.08, 0.92, 1.00, 0.72],\n                [0.08, 0.08, 0.72, 0.72, 1.00]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_speciation(case[\"c\"], case[\"F\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}