{
    "hands_on_practices": [
        {
            "introduction": "Mastering tree thinking begins with a solid command of its fundamental vocabulary. This exercise challenges you to apply the precise, set-theoretic definitions of monophyletic, paraphyletic, and polyphyletic groups to a given topology. By working through these classifications , you will sharpen your ability to interpret phylogenetic hypotheses and communicate evolutionary relationships with unambiguous clarity.",
            "id": "2760582",
            "problem": "Consider the rooted phylogenetic tree with leaf set $L=\\{A,B,C,D\\}$ and rooted topology $T=(((A,B),C),D)$, where the root is attached to $D$ and to the internal node whose descendants are $\\{A,B,C\\}$. Use the following standard, tree-based definitions. For any node $v$ in a rooted tree, let $D(v)$ denote the set of descendant leaves of $v$. A subset $S\\subseteq L$ is called monophyletic (a clade) if there exists a node $v$ with $S=D(v)$. A subset $S\\subseteq L$ is called paraphyletic if there exists a node $v$ and a finite collection of its descendant nodes $v_1,\\dots,v_k$ with $k\\ge 1$ such that $S=D(v)\\setminus \\bigcup_{i=1}^k D(v_i)$. A subset $S\\subseteq L$ is called polyphyletic if it cannot be expressed in either of the two forms above relative to the given rooted tree.\n\nUsing only these definitions and the topology $T$, classify each of the following subsets: $\\{A,B\\}$, $\\{A,C\\}$, $\\{A,B,C\\}$, and $\\{B,C,D\\}$.\n\nChoose the single option that correctly classifies all four subsets in the order listed:\n- A. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ paraphyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.\n\n- B. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ polyphyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.\n\n- C. $\\{A,B\\}$ paraphyletic; $\\{A,C\\}$ polyphyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.\n\n- D. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ paraphyletic; $\\{A,B,C\\}$ paraphyletic; $\\{B,C,D\\}$ polyphyletic.\n\n- E. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ monophyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.",
            "solution": "The problem statement is first subjected to validation.\n\n### Step 1: Extract Givens\n-   **Leaf set:** $L=\\{A,B,C,D\\}$\n-   **Rooted topology:** $T=(((A,B),C),D)$\n-   **Root position:** The root is attached to the leaf $D$ and to the internal node whose descendants are $\\{A,B,C\\}$.\n-   **Definition of Monophyletic (clade):** A subset $S\\subseteq L$ is monophyletic if there exists a node $v$ in the tree such that $S=D(v)$, where $D(v)$ is the set of descendant leaves of $v$.\n-   **Definition of Paraphyletic:** A subset $S\\subseteq L$ is paraphyletic if there exists a node $v$ and a finite collection of its descendant nodes $v_1,\\dots,v_k$ with $k\\ge 1$ such that $S=D(v)\\setminus \\bigcup_{i=1}^k D(v_i)$.\n-   **Definition of Polyphyletic:** A subset $S\\subseteq L$ is polyphyletic if it is neither monophyletic nor paraphyletic.\n-   **Task:** Classify the four subsets $\\{A,B\\}$, $\\{A,C\\}$, $\\{A,B,C\\}$, and $\\{B,C,D\\}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem provides a clear, mathematically well-defined structure for a phylogenetic tree and precise, set-theoretic definitions for monophyletic, paraphyletic, and polyphyletic groups. The topology given in Newick format, $(((A,B),C),D)$, is consistent with the description of the root. The problem is self-contained, scientifically grounded in the principles of cladistics, and well-posed. There are no contradictions, ambiguities, or missing information in the problem statement itself. The task is a direct application of the provided definitions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be derived by strictly applying the given definitions to the specified tree topology.\n\n### Derivation of Solution\nFirst, we must precisely understand the structure of the tree $T=(((A,B),C),D)$.\nLet us denote the nodes of the tree:\n-   $l_A, l_B, l_C, l_D$ are the leaf nodes corresponding to taxa $A, B, C, D$.\n-   $v_1$ is the internal node representing the most recent common ancestor (MRCA) of $A$ and $B$.\n-   $v_2$ is the internal node representing the MRCA of $\\{A,B\\}$ and $C$.\n-   $v_3$ is the root node, representing the MRCA of $\\{A,B,C\\}$ and $D$.\n\nThe sets of descendant leaves for each non-leaf node are:\n-   $D(v_1) = \\{A, B\\}$\n-   $D(v_2) = \\{A, B, C\\}$\n-   $D(v_3) = \\{A, B, C, D\\}$\nThe set of all possible monophyletic groups (clades) containing more than one taxon are $\\{A, B\\}$, $\\{A, B, C\\}$, and $\\{A, B, C, D\\}$. The sets $\\{A\\}, \\{B\\}, \\{C\\}, \\{D\\}$ are also trivially monophyletic.\n\nWe now classify each of the four specified subsets using the provided definitions, assuming a precedence of monophyletic over paraphyletic classification.\n\n**1. Classification of the subset $\\{A,B\\}$**\nAccording to the definition, a set is monophyletic if it is the set of all descendant leaves of some node. The set $\\{A,B\\}$ is the set of all descendant leaves of node $v_1$.\nTherefore, $\\{A,B\\}$ is **monophyletic**.\n\n**2. Classification of the subset $\\{A,C\\}$**\n_Is it monophyletic?_ No. There is no node in the tree $T$ for which $\\{A,C\\}$ is the complete set of descendant leaves.\n_Is it paraphyletic?_ A set $S$ is paraphyletic if it can be expressed as $S = D(v) \\setminus \\bigcup_{i=1}^k D(v_i)$.\nLet us select the node $v = v_2$. The descendant leaves are $D(v_2) = \\{A, B, C\\}$.\nTo obtain $\\{A,C\\}$, we must remove the taxon $B$. The taxon $B$ corresponds to the leaf node $l_B$, and its descendant set is $D(l_B) = \\{B\\}$. The node $l_B$ is a descendant of $v_2$.\nWe can set $k=1$ and $v_1 = l_B$. The expression becomes $D(v_2) \\setminus D(l_B) = \\{A, B, C\\} \\setminus \\{B\\} = \\{A,C\\}$.\nThis construction precisely matches the definition of a paraphyletic group.\nTherefore, according to the definitions provided in the problem, the set $\\{A,C\\}$ is **paraphyletic**. It is not polyphyletic, because the definition of polyphyletic applies only to sets that cannot be described as monophyletic or paraphyletic.\n\n**3. Classification of the subset $\\{A,B,C\\}$**\nThe set $\\{A,B,C\\}$ is the set of all descendant leaves of the node $v_2$.\nTherefore, $\\{A,B,C\\}$ is **monophyletic**.\n\n**4. Classification of the subset $\\{B,C,D\\}$**\n_Is it monophyletic?_ No. There is no node in the tree $T$ for which $\\{B,C,D\\}$ is the complete set of descendant leaves.\n_Is it paraphyletic?_ We check if the set can be formed by the subtractive definition.\nLet us select the root node $v = v_3$. The descendant leaves are $D(v_3) = \\{A, B, C, D\\}$.\nTo obtain $\\{B,C,D\\}$, we must remove the taxon $A$. The taxon $A$ corresponds to the leaf node $l_A$, with descendant set $D(l_A) = \\{A\\}$. The node $l_A$ is a descendant of the root node $v_3$.\nWe set $k=1$ and $v_1 = l_A$. The expression becomes $D(v_3) \\setminus D(l_A) = \\{A, B, C, D\\} \\setminus \\{A\\} = \\{B,C,D\\}$.\nThis construction matches the definition of a paraphyletic group.\nTherefore, $\\{B,C,D\\}$ is **paraphyletic**.\n\n**Summary of Classifications:**\n-   $\\{A,B\\}$: monophyletic\n-   $\\{A,C\\}$: paraphyletic\n-   $\\{A,B,C\\}$: monophyletic\n-   $\\{B,C,D\\}$: paraphyletic\n\nThis sequence of classifications is: monophyletic, paraphyletic, monophyletic, paraphyletic.\n\n### Option-by-Option Analysis\n\n-   **A. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ paraphyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.**\n    This option matches our derived classifications for all four subsets.\n    Verdict: **Correct**.\n\n-   **B. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ polyphyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.**\n    This option incorrectly classifies $\\{A,C\\}$ as polyphyletic. As demonstrated, $\\{A,C\\}$ can be constructed according to the problem's definition of a paraphyletic group.\n    Verdict: **Incorrect**.\n\n-   **C. $\\{A,B\\}$ paraphyletic; $\\{A,C\\}$ polyphyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.**\n    This option incorrectly classifies $\\{A,B\\}$. The set $\\{A,B\\}$ is a clade and is therefore monophyletic, not paraphyletic.\n    Verdict: **Incorrect**.\n\n-   **D. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ paraphyletic; $\\{A,B,C\\}$ paraphyletic; $\\{B,C,D\\}$ polyphyletic.**\n    This option incorrectly classifies $\\{A,B,C\\}$ as paraphyletic. It is a clade and therefore monophyletic. It also incorrectly classifies $\\{B,C,D\\}$ as polyphyletic, when it can be constructed as paraphyletic.\n    Verdict: **Incorrect**.\n\n-   **E. $\\{A,B\\}$ monophyletic; $\\{A,C\\}$ monophyletic; $\\{A,B,C\\}$ monophyletic; $\\{B,C,D\\}$ paraphyletic.**\n    This option incorrectly classifies $\\{A,C\\}$ as monophyletic. As established, it is not a clade.\n    Verdict: **Incorrect**.\n\nThe only option that correctly classifies all four subsets according to the provided formal definitions is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "After learning to read a tree, the next step is to understand how trees are inferred from character data. This problem provides a hands-on application of the principle of maximum parsimony, a foundational method in phylogenetics that seeks the evolutionary tree requiring the fewest character state changes. You will use the classic Fitch algorithm to calculate a tree's parsimony score and identify the synapomorphies that provide evidence for its clades .",
            "id": "2760542",
            "problem": "You are given a rooted phylogenetic tree on five taxa with topology (((A,B),(C,D)),E), where the root is the bifurcation between taxon E and the clade containing A, B, C, and D. Consider two independent, equal-weight, binary, unordered morphological characters (two sites) observed at the tips. The observed states are:\n- Site $1$: A has state $1$, B has state $1$, C has state $0$, D has state $0$, E has state $0$.\n- Site $2$: A has state $1$, B has state $0$, C has state $1$, D has state $0$, E has state $0$.\n\nUse the principle of Maximum Parsimony (MP) with unordered, equal-cost changes and apply the Fitch algorithm to compute the parsimony score (the minimum number of state changes on the tree) for each site on the given rooted tree. Based on a minimal-change reconstruction that is consistent with the given root, identify which, if any, clades on this tree are supported by synapomorphies (shared derived states arising on a single branch and retained in all descendants). You may assume that the root state is inferred under MP from the data at the tips.\n\nFinally, report only the total parsimony score across both sites as a single integer. No rounding is required and no units are involved. Explain your reasoning from first principles of parsimony, clades, and synapomorphy identification, without invoking any shortcut formulas or computational tools.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of phylogenetic systematics, specifically Maximum Parsimony (MP). The problem is well-posed, providing a clear tree topology, unambiguous character state data for five taxa at two sites, and a precise set of tasks. The terminology, such as \"clade,\" \"synapomorphy,\" and \"Fitch algorithm,\" is standard in evolutionary biology. The given data is self-contained and sufficient to derive a unique solution for the parsimony score.\n\nThe principle of Maximum Parsimony dictates that the preferred evolutionary hypothesis is the one that requires the minimum number of evolutionary changes (e.g., character state transitions) to explain the observed data. The Fitch algorithm is a two-pass method for calculating this minimum number of changes (the parsimony score) for a given character on a given tree topology.\n\nLet the internal nodes be denoted as follows: $N_1$ is the most recent common ancestor (MRCA) of taxa $A$ and $B$. $N_2$ is the MRCA of taxa $C$ and $D$. $N_3$ is the MRCA of the clade $(A,B,C,D)$. The root of the tree, $R$, is the MRCA of all five taxa, representing the bifurcation between taxon $E$ and the clade $(A,B,C,D)$. The tree topology is $(((A,B)N_1, (C,D)N_2)N_3, E)R$.\n\nWe will apply the Fitch algorithm to each site independently.\n\n**Analysis of Site $1$**\n\nThe observed states at the tips (leaves) of the tree for Site $1$ are: $A:1, B:1, C:0, D:0, E:0$.\n\nThe Fitch algorithm consists of two passes: a bottom-up pass (Phase $1$) to determine the set of possible ancestral states and the parsimony score, and a top-down pass (Phase $2$) to assign specific states to internal nodes.\n\nPhase $1$ (Bottom-up):\nFor each internal node, we compute a set of potential states. If the state sets of its two immediate descendants have a non-empty intersection, the state set of the parent node is this intersection. If the intersection is empty, the state set of the parent node is the union of the descendants' sets, and the parsimony score is incremented by $1$.\n\n1.  Node $N_1$ (ancestor of $A$ and $B$): The state sets are $\\{1\\}$ for $A$ and $\\{1\\}$ for $B$. The intersection is $\\{1\\} \\cap \\{1\\} = \\{1\\}$. So, the state set for $N_1$ is $\\{1\\}$. Score remains $0$.\n2.  Node $N_2$ (ancestor of $C$ and $D$): The state sets are $\\{0\\}$ for $C$ and $\\{0\\}$ for $D$. The intersection is $\\{0\\} \\cap \\{0\\} = \\{0\\}$. So, the state set for $N_2$ is $\\{0\\}$. Score remains $0$.\n3.  Node $N_3$ (ancestor of $N_1$ and $N_2$): The state sets are $\\{1\\}$ for $N_1$ and $\\{0\\}$ for $N_2$. The intersection is $\\{1\\} \\cap \\{0\\} = \\emptyset$. The intersection is empty, so we take the union $\\{1\\} \\cup \\{0\\} = \\{0, 1\\}$ and increment the score. The state set for $N_3$ is $\\{0, 1\\}$. The score is now $1$.\n4.  Node $R$ (Root, ancestor of $N_3$ and $E$): The state sets are $\\{0, 1\\}$ for $N_3$ and $\\{0\\}$ for $E$. The intersection is $\\{0, 1\\} \\cap \\{0\\} = \\{0\\}$. The intersection is not empty, so the state set for the root $R$ is $\\{0\\}$. The score is not incremented.\n\nThe final parsimony score for Site $1$, denoted $S_1$, is the total number of union operations, which is $1$. So, $S_1 = 1$.\n\n**Analysis of Site $2$**\n\nThe observed states at the tips for Site $2$ are: $A:1, B:0, C:1, D:0, E:0$.\n\nPhase $1$ (Bottom-up):\n1.  Node $N_1$ (ancestor of $A$ and $B$): The state sets are $\\{1\\}$ for $A$ and $\\{0\\}$ for $B$. The intersection is empty. Union is $\\{0, 1\\}$. State set for $N_1$ is $\\{0, 1\\}$. Score is incremented to $1$.\n2.  Node $N_2$ (ancestor of $C$ and $D$): The state sets are $\\{1\\}$ for $C$ and $\\{0\\}$ for $D$. The intersection is empty. Union is $\\{0, 1\\}$. State set for $N_2$ is $\\{0, 1\\}$. Score is incremented to $1+1=2$.\n3.  Node $N_3$ (ancestor of $N_1$ and $N_2$): The state sets are $\\{0, 1\\}$ for $N_1$ and $\\{0, 1\\}$ for $N_2$. The intersection is $\\{0, 1\\} \\cap \\{0, 1\\} = \\{0, 1\\}$. The intersection is not empty, so the state set for $N_3$ is $\\{0, 1\\}$. The score is not incremented.\n4.  Node $R$ (Root, ancestor of $N_3$ and $E$): The state sets are $\\{0, 1\\}$ for $N_3$ and $\\{0\\}$ for $E$. The intersection is $\\{0, 1\\} \\cap \\{0\\} = \\{0\\}$. The intersection is not empty, so the state set for the root $R$ is $\\{0\\}$. The score is not incremented.\n\nThe final parsimony score for Site $2$, denoted $S_2$, is $2$.\n\n**Total Parsimony Score**\n\nThe total parsimony score across both sites is the sum of the individual scores:\n$$S_{total} = S_1 + S_2 = 1 + 2 = 3$$\n\n**Synapomorphy Identification**\n\nTo identify synapomorphies, we perform Phase $2$ of the Fitch algorithm (top-down pass) to assign a specific state to each internal node, creating a minimal-change reconstruction. A synapomorphy is a shared derived character state that arose on the stem branch of a clade and is inherited by all members of that clade. The problem states to assume the root state is inferred under MP.\n\nFor Site $1$:\nThe state set for the root $R$ is $\\{0\\}$, so we assign state $0$ to the root.\n-   $R$ has state $0$. Its descendant $E$ also has state $0$ (no change). Its other descendant $N_3$ has state set $\\{0, 1\\}$. Since the parent state $0$ is in this set, we assign $N_3$ the state $0$.\n-   $N_3$ has state $0$. Its descendant $N_2$ has state set $\\{0\\}$, so we must assign $N_2$ the state $0$. Its other descendant $N_1$ has state set $\\{1\\}$. Since the parent state $0$ is not in this set, a state change must occur. We assign $N_1$ the state $1$. This change $0 \\to 1$ occurs on the branch leading from $N_3$ to $N_1$.\nThis single change on the branch leading to the clade $(A,B)$ results in the derived state $1$ being shared by both $A$ and $B$. Thus, state $1$ at Site $1$ is a synapomorphy supporting the clade $(A,B)$.\n\nFor Site $2$:\nThe state set for the root $R$ is $\\{0\\}$, so we assign state $0$ to the root.\n-   $R$ has state $0$. Its descendant $E$ has state $0$. Its other descendant $N_3$ has state set $\\{0, 1\\}$, so we assign $N_3$ the state $0$.\n-   $N_3$ has state $0$. Its descendant $N_1$ has state set $\\{0, 1\\}$, so we can assign $N_1$ the state $0$. Its other descendant $N_2$ has state set $\\{0, 1\\}$, so we can assign $N_2$ the state $0$.\n-   Under this reconstruction (which is one of several equally parsimonious possibilities, e.g., a DELTRAN reconstruction), all internal nodes ($R, N_3, N_2, N_1$) have state $0$. The two required changes are:\n    1.  On the terminal branch to $A$: $0 \\to 1$ (since $N_1$ is $0$).\n    2.  On the terminal branch to $C$: $0 \\to 1$ (since $N_2$ is $0$).\nThese are two independent changes to state $1$. This phenomenon is called homoplasy (specifically, convergence). The state $1$ is not a shared derived character for any clade; it is an autapomorphy for taxon $A$ and an autapomorphy for taxon $C$. Therefore, Site $2$ provides no synapomorphies to support any clades on this tree.\n\nConclusion: Of the characters provided, only Site $1$ provides a synapomorphy, which supports the clade $(A,B)$. The primary question, however, is to report the total parsimony score.\n\nThe total parsimony score across both sites is $3$.",
            "answer": "$$ \\boxed{3} $$"
        },
        {
            "introduction": "Even the most intuitive inference methods have limitations, and an expert phylogeneticist must understand the conditions under which they can be misleading. This advanced computational exercise guides you through simulating the classic phenomenon of long-branch attraction, a scenario where maximum parsimony can incorrectly group unrelated taxa. By building the simulation from first principles , you will gain a powerful and concrete understanding of how specific evolutionary scenarios, such as extreme branch length variation and rate heterogeneity, can systematically bias phylogenetic inference.",
            "id": "2760578",
            "problem": "You must write a complete, runnable program that simulates a $4$-taxon case of long-branch attraction under a model-based data-generating process and then infers the unrooted tree by maximum parsimony. The task is to implement a deterministic simulation and inference pipeline that reveals when two long, non-sister branches are incorrectly inferred as a clade. The problem must be solved from first principles of tree thinking and clade concepts, using only widely accepted definitions and models from evolutionary biology.\n\nUse the following fundamental base:\n- The Jukes–Cantor nucleotide substitution model with stationary base frequencies and homogeneous rates across lineages, where branch length is measured as expected substitutions per site.\n- Gamma-distributed rates across sites with mean $1$ to represent rate heterogeneity.\n- Maximum parsimony (Fitch algorithm) to infer the unrooted $4$-taxon topology by minimizing the total number of implied state changes across sites.\n\nConstruct a rooted version of the unrooted true topology $((A,B),(C,D))$ by placing a root between the two internal nodes so that the total internal path between the clades has length $\\ell_{\\mathrm{int}}$. The rooted implementation should use two internal edges of length $\\ell_{\\mathrm{int}}/2$ from the root to each internal node. External branches are set so that taxa $A$ and $C$ have long branches of length $\\ell_{\\mathrm{long}}$ and taxa $B$ and $D$ have short branches of length $\\ell_{\\mathrm{short}}$. Simulate $n_{\\mathrm{sites}}$ nucleotide sites under the Jukes–Cantor model with per-site rate $r \\sim \\mathrm{Gamma}(\\alpha,\\ \\mathrm{scale}=1/\\alpha)$, independently across sites, so that the mean per-site rate is $1$. For each site, generate a root state from the stationary distribution and propagate states to $A,B,C,D$ along the edges using the Jukes–Cantor transition probabilities with effective branch length $r \\cdot t$ on an edge of length $t$.\n\nInfer the unrooted tree using maximum parsimony via the Fitch algorithm on the three unrooted $4$-taxon topologies:\n- Code $0$: $ab\\mid cd$ (the true split).\n- Code $1$: $ac\\mid bd$ (the long-branch-attraction split if $A$ and $C$ are the long branches).\n- Code $2$: $ad\\mid bc$.\n\nBreak ties, if any, by returning the smallest code among those achieving the minimum parsimony score. Branch lengths are in units of expected substitutions per site and are unitless. Angles are not used. There are no percentages.\n\nImplement your program to run the following test suite. Each test case is a tuple $(\\ell_{\\mathrm{long}}, \\ell_{\\mathrm{short}}, \\ell_{\\mathrm{int}}, \\alpha, n_{\\mathrm{sites}}, \\mathrm{seed})$:\n- Case $1$ (exacerbate long-branch attraction by very long external branches and a very short internal branch, with heterogeneous rates): ($\\ell_{\\mathrm{long}}=2.0$, $\\ell_{\\mathrm{short}}=0.05$, $\\ell_{\\mathrm{int}}=0.02$, $\\alpha=0.3$, $n_{\\mathrm{sites}}=20000$, $\\mathrm{seed}=42$).\n- Case $2$ (mitigate by lengthening the internal branch while keeping long branches and heterogeneous rates): ($\\ell_{\\mathrm{long}}=2.0$, $\\ell_{\\mathrm{short}}=0.05$, $\\ell_{\\mathrm{int}}=0.6$, $\\alpha=0.3$, $n_{\\mathrm{sites}}=20000$, $\\mathrm{seed}=43$).\n- Case $3$ (mitigate by shortening the long branches): ($\\ell_{\\mathrm{long}}=0.5$, $\\ell_{\\mathrm{short}}=0.05$, $\\ell_{\\mathrm{int}}=0.1$, $\\alpha=0.3$, $n_{\\mathrm{sites}}=20000$, $\\mathrm{seed}=44$).\n- Case $4$ (mitigate by making per-site rates nearly constant with a large gamma shape parameter): ($\\ell_{\\mathrm{long}}=2.0$, $\\ell_{\\mathrm{short}}=0.05$, $\\ell_{\\mathrm{int}}=0.2$, $\\alpha=10.0$, $n_{\\mathrm{sites}}=20000$, $\\mathrm{seed}=45$).\n- Case $5$ (boundary, nearly clock-like with equal branch lengths): ($\\ell_{\\mathrm{long}}=0.3$, $\\ell_{\\mathrm{short}}=0.3$, $\\ell_{\\mathrm{int}}=0.3$, $\\alpha=1.0$, $n_{\\mathrm{sites}}=20000$, $\\mathrm{seed}=46$).\n\nYour program must:\n- Simulate the alignments as specified.\n- Compute the parsimony score for each of the three unrooted topologies using the Fitch algorithm.\n- Return, for each test case, the code of the inferred topology ($0$, $1$, or $2$), using the tie-breaking rule above.\n\nFinal output format: Your program should produce a single line of output containing the five integer results in order, as a comma-separated list enclosed in square brackets (e.g., [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]).",
            "solution": "The posed problem is a valid exercise in computational evolutionary biology. It is scientifically grounded, well-posed, and all necessary parameters and methods are specified unambiguously. The task is to simulate sequence evolution under a defined model and then use maximum parsimony to infer the phylogeny, demonstrating the phenomenon of long-branch attraction (LBA). This is a classic problem used to illustrate the statistical inconsistency of parsimony under certain evolutionary scenarios. I will proceed with a full solution.\n\nThe fundamental objective is to determine which of three possible unrooted topologies for four taxa—$A$, $B$, $C$, and $D$—is selected by the maximum parsimony criterion, given a sequence alignment generated under a specific evolutionary model. The true phylogeny is specified as $((A,B),(C,D))$, which implies that $A$ and $B$ form a clade, and $C$ and $D$ form another clade. The three possible unrooted topologies, represented by their bipartitions, are:\n- Topology $0$: $ab|cd$, corresponding to the true tree $((A,B),(C,D))$.\n- Topology $1$: $ac|bd$, corresponding to the tree $((A,C),(B,D))$. This is the LBA tree, where the two long, non-sister branches ($A$ and $C$) are artifactually grouped.\n- Topology $2$: $ad|bc$, corresponding to the tree $((A,D),(B,C))$.\n\nThe simulation is performed on a rooted version of the true tree. The root is placed on the internal branch connecting the $(A,B)$ clade and the $(C,D)$ clade. This internal branch has a total length of $\\ell_{\\mathrm{int}}$, modeled as two segments of length $\\ell_{\\mathrm{int}}/2$ emanating from the root. The terminal branches leading to taxa $A$ and $C$ are long (length $\\ell_{\\mathrm{long}}$), while those to taxa $B$ and $D$ are short (length $\\ell_{\\mathrm{short}}$).\n\nThe evolutionary model for sequence simulation has two main components: the substitution process along branches and the variation of rates across sites.\n\n$1$. **Jukes-Cantor (JC$69$) Nucleotide Substitution Model**: This is the simplest continuous-time Markov model of nucleotide substitution. It assumes equal base frequencies $(\\pi_A = \\pi_C = \\pi_G = \\pi_T = 1/4)$ and an equal rate of change between any two distinct nucleotides. For a branch of length $t$ (measured in expected substitutions per site), the probability of a nucleotide remaining in the same state is given by:\n$$p_{\\text{same}}(t) = \\frac{1}{4} + \\frac{3}{4}e^{-4t}$$\nThe probability of changing to any specific different state is:\n$$p_{\\text{diff}}(t) = \\frac{1}{4} - \\frac{1}{4}e^{-4t}$$\nThe total probability of any change is $1 - p_{\\text{same}}(t) = \\frac{3}{4}(1 - e^{-4t})$.\n\n$2$. **Gamma-Distributed Rates Across Sites**: To model rate heterogeneity, the evolutionary rate at each site is drawn independently from a Gamma distribution. The shape of this distribution is controlled by the parameter $\\alpha$. The distribution is specified as $\\mathrm{Gamma}(\\alpha, \\text{scale}=1/\\alpha)$. This parameterization yields a mean rate of $1$, E$[r] = \\alpha \\cdot (1/\\alpha) = 1$. The variance of the rates is $\\mathrm{Var}[r] = \\alpha \\cdot (1/\\alpha)^2 = 1/\\alpha$. A small $\\alpha$ (e.g., $\\alpha < 1$) implies high rate heterogeneity (some sites evolve very fast, others very slowly), which is known to exacerbate LBA. A large $\\alpha$ (e.g., $\\alpha > 5$) implies that rates are nearly constant across sites. For a branch of length $t$ and a site-specific rate $r$, the effective branch length used in the JC$69$ model is $r \\cdot t$.\n\nThe simulation proceeds site by site for $n_{\\mathrm{sites}}$ sites. For each site:\n- A rate $r$ is drawn from the $\\mathrm{Gamma}(\\alpha, 1/\\alpha)$ distribution.\n- A root nucleotide state is drawn uniformly from $\\{A, C, G, T\\}$.\n- States are propagated down the tree topology $((A,B),(C,D))$. For each branch, a stochastic transition is simulated using the JC$69$ probabilities with the effective branch length. This yields a single column of the $4 \\times n_{\\mathrm{sites}}$ nucleotide alignment.\n\nOnce the alignment is generated, we infer the best topology using maximum parsimony. The principle of maximum parsimony is to find the tree that requires the minimum total number of character-state changes to explain the observed data at the tips. For a $4$-taxon case, this simplifies considerably. We only need to count the occurrences of the three types of parsimony-informative site patterns:\n- Pattern $1$ (supports topology $0$): The states are $x, x, y, y$ for taxa $A, B, C, D$ respectively (where $x \\neq y$). For example, $(A,A,G,G)$. This pattern requires only $1$ change on topology $0$ (on the internal branch), but at least $2$ changes on topologies $1$ and $2$. Let $n_1$ be the count of such sites.\n- Pattern $2$ (supports topology $1$): The states are $x, y, x, y$ for taxa $A, B, C, D$. For example, $(A,G,A,G)$. This pattern requires $1$ change on topology $1$ but at least $2$ on topologies $0$ and $2$. Let $n_2$ be the count of such sites.\n- Pattern $3$ (supports topology $2$): The states are $x, y, y, x$ for taxa $A, B, C, D$. For example, $(A,G,G,A)$. This pattern requires $1$ change on topology $2$ but at least $2$ on the other two. Let $n_3$ be the count of such sites.\n\nAll other site patterns (constant sites like $(A,A,A,A)$ or sites with $3$ or $4$ unique states) are uninformative, as they require the same minimum number of changes on all three topologies.\n\nThe total parsimony scores for the three topologies are:\n- Score(Topology $0$) = $C + n_1 + 2n_2 + 2n_3$\n- Score(Topology $1$) = $C + 2n_1 + n_2 + 2n_3$\n- Score(Topology $2$) = $C + 2n_1 + 2n_2 + n_3$\nwhere $C$ is the total score from all uninformative sites.\n\nTo find the topology with the minimum score, we only need to compare these expressions. It is clear that topology $0$ is favored if $n_1$ is the largest count, topology $1$ if $n_2$ is the largest, and topology $2$ if $n_3$ is the largest. The algorithm is therefore:\n$1$. Count $n_1$, $n_2$, and $n_3$ from the simulated alignment.\n$2$. Find the maximum among these three counts.\n$3$. The inferred topology corresponds to the count that is maximal.\n$4$. If there is a tie for the maximum count, the problem specifies breaking the tie by choosing the topology with the smallest code ($0, 1$, or $2$).\n\nThe implementation will follow this logic precisely, using numerical arrays for efficiency. A deterministic result is ensured for each test case by using the specified random seed.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and inference for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Exacerbate LBA (long branches, short internal, high rate heterogeneity)\n        (2.0, 0.05, 0.02, 0.3, 20000, 42),\n        # Case 2: Mitigate LBA (lengthen internal branch)\n        (2.0, 0.05, 0.6, 0.3, 20000, 43),\n        # Case 3: Mitigate LBA (shorten long branches)\n        (0.5, 0.05, 0.1, 0.3, 20000, 44),\n        # Case 4: Mitigate LBA (reduce rate heterogeneity)\n        (2.0, 0.05, 0.2, 10.0, 20000, 45),\n        # Case 5: Boundary case (nearly clock-like)\n        (0.3, 0.3, 0.3, 1.0, 20000, 46),\n    ]\n\n    results = []\n    for case in test_cases:\n        l_long, l_short, l_int, alpha, n_sites, seed = case\n        inferred_topology = run_simulation_and_inference(\n            l_long, l_short, l_int, alpha, n_sites, seed\n        )\n        results.append(inferred_topology)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation_and_inference(l_long, l_short, l_int, alpha, n_sites, seed):\n    \"\"\"\n    Simulates sequence evolution and infers topology using maximum parsimony.\n\n    Args:\n        l_long (float): Length of long terminal branches (A, C).\n        l_short (float): Length of short terminal branches (B, D).\n        l_int (float): Length of the internal branch.\n        alpha (float): Shape parameter for the Gamma distribution of rates.\n        n_sites (int): Number of sites to simulate.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        int: The code of the inferred topology (0, 1, or 2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # --- 1. Simulation Phase ---\n    # The 4 nucleotide states are represented by integers 0, 1, 2, 3.\n\n    # Generate site-specific rates from a Gamma distribution\n    # Mean rate is 1, variance is 1/alpha.\n    site_rates = rng.gamma(alpha, 1.0 / alpha, n_sites)\n\n    # Generate states for the root of the tree from the stationary distribution (uniform).\n    root_states = rng.integers(0, 4, size=n_sites)\n\n    def propagate_states(parent_states, branch_length, rates, rng_instance):\n        \"\"\"\n        Propagates nucleotide states along a branch using the Jukes-Cantor model.\n        \"\"\"\n        effective_lengths = rates * branch_length\n        # Probability of no change\n        p_same = 0.25 + 0.75 * np.exp(-4.0 * effective_lengths)\n        \n        # Decide which sites will undergo substitution\n        rand_unif = rng_instance.random(size=n_sites)\n        change_indices = rand_unif > p_same\n        \n        child_states = parent_states.copy()\n        num_changes = np.sum(change_indices)\n        \n        if num_changes > 0:\n            # For sites that change, pick a new state different from the parent.\n            # Add a random int from {1, 2, 3} and take modulo 4.\n            offsets = rng_instance.integers(1, 4, size=num_changes)\n            parent_at_change = parent_states[change_indices]\n            child_states[change_indices] = (parent_at_change + offsets) % 4\n            \n        return child_states\n\n    # True topology: ((A,B),(C,D))\n    # Root is placed in the middle of the internal branch.\n    # Root -> N1 (ancestor of A,B) with length l_int/2\n    # Root -> N2 (ancestor of C,D) with length l_int/2\n    states_n1 = propagate_states(root_states, l_int / 2.0, site_rates, rng)\n    states_n2 = propagate_states(root_states, l_int / 2.0, site_rates, rng)\n\n    # N1 -> A (long branch), N1 -> B (short branch)\n    states_A = propagate_states(states_n1, l_long, site_rates, rng)\n    states_B = propagate_states(states_n1, l_short, site_rates, rng)\n\n    # N2 -> C (long branch), N2 -> D (short branch)\n    states_C = propagate_states(states_n2, l_long, site_rates, rng)\n    states_D = propagate_states(states_n2, l_short, site_rates, rng)\n\n    # Combine into a single alignment matrix (4 x n_sites)\n    alignment = np.vstack([states_A, states_B, states_C, states_D])\n\n    # --- 2. Inference Phase (Maximum Parsimony) ---\n    \n    # We count the three types of parsimony-informative site patterns.\n    # n1: supports ab|cd (Topology 0), pattern e.g., (x,x,y,y)\n    # n2: supports ac|bd (Topology 1), pattern e.g., (x,y,x,y)\n    # n3: supports ad|bc (Topology 2), pattern e.g., (x,y,y,x)\n    \n    sA, sB, sC, sD = alignment[0, :], alignment[1, :], alignment[2, :], alignment[3, :]\n\n    # Pattern 1 (ab|cd): A==B and C==D and A!=C\n    n1 = np.sum((sA == sB)  (sC == sD)  (sA != sC))\n    \n    # Pattern 2 (ac|bd): A==C and B==D and A!=B\n    n2 = np.sum((sA == sC)  (sB == sD)  (sA != sB))\n    \n    # Pattern 3 (ad|bc): A==D and B==C and A!=B\n    n3 = np.sum((sA == sD)  (sB == sC)  (sA != sB))\n\n    counts = np.array([n1, n2, n3])\n    \n    # The topology with the highest count of supporting sites has the minimum parsimony score.\n    max_count = np.max(counts)\n    \n    # Find all topologies that achieve this maximum count.\n    best_indices = np.where(counts == max_count)[0]\n    \n    # Apply the tie-breaking rule: return the smallest code (index).\n    return np.min(best_indices)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}