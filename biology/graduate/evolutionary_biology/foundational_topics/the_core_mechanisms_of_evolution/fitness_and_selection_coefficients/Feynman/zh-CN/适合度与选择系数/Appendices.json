{
    "hands_on_practices": [
        {
            "introduction": "掌握自然选择的基本数学原理是研究进化动力学的第一步。本练习将引导你应用赖特适应度 (Wrightian fitness) 的核心定义，在一个简单的单倍体群体中精确计算一代选择后的基因型频率变化。通过这个基础计算，你不仅能巩固对平均适应度 $\\bar{w}$ 和频率更新方程 $p'_i = p_i w_i / \\bar{w}$ 的理解，还能为分析更复杂的进化情景打下坚实的基础 。",
            "id": "2832271",
            "problem": "一个大型、充分混合的无性单倍体种群由三种基因型组成，索引为 $i \\in \\{1,2,3\\}$。在没有突变、迁移或遗传漂变的单一、离散、非重叠世代的生命周期中，每种基因型 $i$ 都具有一个恒定的赖特适应度 $w_i$，该适应度决定了其对下一代贡献的期望值大小。在第 $t$ 代开始时，基因型频率向量为 $(p_1, p_2, p_3)$，且 $p_1 + p_2 + p_3 = 1$。选择通过差异化的生存/繁殖来起作用，因此源自基因型 $i$ 的存活后代的期望数量与 $w_i$ 和基因型 $i$ 的亲代数量的乘积成正比。令 $\\bar{w}$ 表示种群平均适应度（按当前频率加权的各基因型个体平均成功率），并令 $(p_1', p_2', p_3')$ 表示经过选择和归一化后，在第 $t+1$ 代开始时的基因型频率。\n\n在一次特定实验中，第 $t$ 代时三种基因型的适应度为 $w = (1.00, 1.05, 0.98)$，初始频率为 $(p_1, p_2, p_3) = (0.5, 0.3, 0.2)$。严格根据上述定义（即基因型贡献与 $w_i$ 成正比，且频率经归一化后总和必须为 $1$），计算下一代的频率向量 $(p_1', p_2', p_3')$ 和下一代的平均适应度 $\\bar{w}'$。\n\n将最终数值结果以单个行向量 $(p_1', p_2', p_3', \\bar{w}')$ 的形式报告，其中每个条目四舍五入至四位有效数字。条目以普通小数形式表示（无百分号）。不應报告任何其他量。",
            "solution": "该问题提出了一个针对单倍体无性种群的标准的离散时间种群遗传学模型。任务是根据三种基因型的初始频率和适应度值，计算下一代的基因型频率和种群平均适应度。问题陈述具有科学依据、提法明确，并包含了所有必要信息。因此，该问题是有效的。\n\n设第 $t$ 代的种群由三种基因型的频率向量 $\\boldsymbol{p} = (p_1, p_2, p_3)$ 描述，其中 $\\sum_{i=1}^{3} p_i = 1$。相应的赖特适应度由向量 $\\boldsymbol{w} = (w_1, w_2, w_3)$ 给出。问题陈述指出，每种基因型对下一代的期望贡献与其适应度和当前频率成正比。\n\n设第 $t$ 代开始时的总种群大小为 $N$。基因型 $i$ 的个体数量为 $N_i = p_i N$。基因型 $i$ 产生的后代数量，我们记为 $N'_i$，与 $w_i N_i$ 成正比。因此，我们可以写出 $N'_i = C w_i N_i$，其中 $C$ 是对所有基因型都相同的比例常数。\n\n在归一化之前，子代的总个体数量是所有基因型数量的总和：\n$$N' = \\sum_{i=1}^{3} N'_i = \\sum_{i=1}^{3} C w_i N_i = C \\sum_{i=1}^{3} w_i (p_i N) = C N \\sum_{i=1}^{3} w_i p_i$$\n下一代中基因型 $i$ 的频率 $p'_i$ 是其后代数量与总后代数量之比：\n$$p'_i = \\frac{N'_i}{N'} = \\frac{C w_i N_i}{\\sum_{j=1}^{3} C w_j N_j} = \\frac{w_i (p_i N)}{\\sum_{j=1}^{3} w_j (p_j N)}$$\n常数 $C$ 和 $N$ 被约去，得到基本递推关系：\n$$p'_i = \\frac{p_i w_i}{\\sum_{j=1}^{3} p_j w_j}$$\n分母是第 $t$ 代的种群平均适应度，定义为个体适应度的加权平均值：\n$$\\bar{w} = \\sum_{i=1}^{3} p_i w_i$$\n因此，第 $t+1$ 代基因型 $i$ 的频率由下式给出：\n$$p'_i = \\frac{p_i w_i}{\\bar{w}}$$\n第 $t$ 代的给定数据如下：\n- 频率：$(p_1, p_2, p_3) = (0.5, 0.3, 0.2)$\n- 适应度：$(w_1, w_2, w_3) = (1.00, 1.05, 0.98)$\n\n首先，我们计算第 $t$ 代的平均适应度 $\\bar{w}$：\n$$\\bar{w} = p_1 w_1 + p_2 w_2 + p_3 w_3$$\n$$\\bar{w} = (0.5)(1.00) + (0.3)(1.05) + (0.2)(0.98) = 0.500 + 0.315 + 0.196 = 1.011$$\n现在我们可以计算下一代的频率 $(p'_1, p'_2, p'_3)$：\n$$p'_1 = \\frac{p_1 w_1}{\\bar{w}} = \\frac{(0.5)(1.00)}{1.011} = \\frac{0.500}{1.011} \\approx 0.4945598...$$\n$$p'_2 = \\frac{p_2 w_2}{\\bar{w}} = \\frac{(0.3)(1.05)}{1.011} = \\frac{0.315}{1.011} \\approx 0.3115727...$$\n$$p'_3 = \\frac{p_3 w_3}{\\bar{w}} = \\frac{(0.2)(0.98)}{1.011} = \\frac{0.196}{1.011} \\approx 0.1938674...$$\n问题要求将这些值四舍五入到四位有效数字：\n- $p'_1 \\approx 0.4946$\n- $p'_2 \\approx 0.3116$\n- $p'_3 \\approx 0.1939$\n\n接下来，我们必须计算第 $t+1$ 代的种群平均适应度，记为 $\\bar{w}'$。这是使用新计算出的频率 $(p'_1, p'_2, p'_3)$ 来计算的：\n$$\\bar{w}' = p'_1 w_1 + p'_2 w_2 + p'_3 w_3$$\n为避免舍入误差的累积，我们应代入 $p'_i$ 的精确表达式：\n$$\\bar{w}' = \\sum_{i=1}^{3} p'_i w_i = \\sum_{i=1}^{3} \\left(\\frac{p_i w_i}{\\bar{w}}\\right) w_i = \\frac{1}{\\bar{w}} \\sum_{i=1}^{3} p_i w_i^2$$\n我们首先计算总和 $\\sum_{i=1}^{3} p_i w_i^2$：\n$$\\sum_{i=1}^{3} p_i w_i^2 = (0.5)(1.00)^2 + (0.3)(1.05)^2 + (0.2)(0.98)^2$$\n$$\\sum_{i=1}^{3} p_i w_i^2 = (0.5)(1.0000) + (0.3)(1.1025) + (0.2)(0.9604)$$\n$$\\sum_{i=1}^{3} p_i w_i^2 = 0.50000 + 0.33075 + 0.19208 = 1.02283$$\n现在，我们可以求出 $\\bar{w}'$：\n$$\\bar{w}' = \\frac{1.02283}{1.011} \\approx 1.01170128...$$\n四舍五入到四位有效数字，得到：\n- $\\bar{w}' \\approx 1.012$\n\n最终结果是行向量 $(p'_1, p'_2, p'_3, \\bar{w}')$，其中每个条目都四舍五入到四位有效数字。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4946 & 0.3116 & 0.1939 & 1.012\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Fisher 的自然选择基本定理常被简化为“平均适应度永远增加”，但这忽略了基因组的复杂性。本练习通过一个包含上位效应 (epistasis) 和重组 (recombination) 的双位点模型，挑战了这一简单直观的结论。你将通过计算发现，在特定条件下，重组会打破有利的基因组合，反而导致群体的平均适应度下降，这深刻揭示了在多位点系统中理解进化轨迹的复杂性 。",
            "id": "2714095",
            "problem": "考虑一个单倍体双基因座系统，其基因座为 $A/a$ 和 $B/b$。在每一代中，生存力选择发生在重组之前。四种单倍型 $AB$、$Ab$、$aB$ 和 $ab$ 各自具有恒定的特定基因型绝对生存力 $w_{AB}$、$w_{Ab}$、$w_{aB}$ 和 $w_{ab}$，其编码的正上位性如下：$w_{AB} = 1 + s$，$w_{Ab} = 1 - c$，$w_{aB} = 1 - c$ 以及 $w_{ab} = 1 + s$，其中 $s = 0.2$ 且 $c = 0.1$。假设在繁殖过程中发生自由重组，$r = 0.5$。在第 $t$ 代开始时，单倍型频率为 $x_{AB}(t) = 0.49$，$x_{Ab}(t) = 0.01$，$x_{aB}(t) = 0.01$ 以及 $x_{ab}(t) = 0.49$。\n\n将第 $t$ 代开始时的平均绝对适合度定义为 $\\bar{w}_t = \\sum_{h \\in \\{AB, Ab, aB, ab\\}} x_h(t)\\, w_h$，同样地，将下一代开始时的平均绝对适合度定义为 $\\bar{w}_{t+1} = \\sum_{h} x_h(t+1)\\, w_h$，其中 $x_h(t+1)$ 是由第 $t$ 代受选择的配子形成的重组后单倍型频率。仅使用生存力选择、重组和单倍型频率的标准定义，计算在此生命周期下一个世代的平均绝对适合度的精确净变化量 $\\Delta \\bar{w} = \\bar{w}_{t+1} - \\bar{w}_t$。请以单个精确数值（一个简化分数）的形式提供您的最终答案。此外，请在您的解题过程中简要解释此示例如何规避了“选择下平均适合度会增加”这一经典结论所需的假设。",
            "solution": "该问题要求计算单倍体双基因座系统在一个世代内平均绝对适合度的精确净变化量 $\\Delta \\bar{w} = \\bar{w}_{t+1} - \\bar{w}_t$。解答需要遵循指定的生命周期（生存力选择后进行重组）进行分步计算。\n\n首先，我们列出给定的参数和初始条件。\n绝对生存力为：\n$w_{AB} = 1 + s = 1 + 0.2 = 1.2 = \\frac{6}{5}$\n$w_{Ab} = 1 - c = 1 - 0.1 = 0.9 = \\frac{9}{10}$\n$w_{aB} = 1 - c = 1 - 0.1 = 0.9 = \\frac{9}{10}$\n$w_{ab} = 1 + s = 1 + 0.2 = 1.2 = \\frac{6}{5}$\n\n重组率为 $r = 0.5 = \\frac{1}{2}$。\n\n第 $t$ 代开始时的单倍型频率为：\n$x_{AB}(t) = 0.49 = \\frac{49}{100}$\n$x_{Ab}(t) = 0.01 = \\frac{1}{100}$\n$x_{aB}(t) = 0.01 = \\frac{1}{100}$\n$x_{ab}(t) = 0.49 = \\frac{49}{100}$\n\n总频率为 $\\sum_h x_h(t) = \\frac{49}{100} + \\frac{1}{100} + \\frac{1}{100} + \\frac{49}{100} = \\frac{100}{100} = 1$，符合要求。\n\n第一步是计算第 $t$ 代开始时的平均绝对适合度 $\\bar{w}_t$。\n$$ \\bar{w}_t = \\sum_{h} x_h(t) w_h $$\n$$ \\bar{w}_t = x_{AB}(t)w_{AB} + x_{Ab}(t)w_{Ab} + x_{aB}(t)w_{aB} + x_{ab}(t)w_{ab} $$\n$$ \\bar{w}_t = \\left(\\frac{49}{100}\\right)\\left(\\frac{6}{5}\\right) + \\left(\\frac{1}{100}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{1}{100}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{49}{100}\\right)\\left(\\frac{6}{5}\\right) $$\n$$ \\bar{w}_t = 2 \\left[ \\frac{294}{500} + \\frac{9}{1000} \\right] = 2 \\left[ \\frac{588}{1000} + \\frac{9}{1000} \\right] = 2 \\left( \\frac{597}{1000} \\right) = \\frac{1194}{1000} = \\frac{597}{500} $$\n\n接下来，我们计算经过生存力选择后的单倍型频率，记为 $x'_h$。这些是重组前配子库中的频率。\n$$ x'_h = \\frac{x_h(t) w_h}{\\bar{w}_t} $$\n对于 $AB$ 单倍型：\n$$ x'_{AB} = \\frac{(\\frac{49}{100})(\\frac{6}{5})}{\\frac{597}{500}} = \\frac{\\frac{294}{500}}{\\frac{597}{500}} = \\frac{294}{597} = \\frac{98}{199} $$\n根据对称性，$x'_{ab} = x'_{AB} = \\frac{98}{199}$。\n对于 $Ab$ 单倍型：\n$$ x'_{Ab} = \\frac{(\\frac{1}{100})(\\frac{9}{10})}{\\frac{597}{500}} = \\frac{\\frac{9}{1000}}{\\frac{1194}{1000}} = \\frac{9}{1194} = \\frac{3}{398} $$\n根据对称性，$x'_{aB} = x'_{Ab} = \\frac{3}{398}$。\n我们可以检验这些频率之和为 $1$: $2 \\times \\frac{98}{199} + 2 \\times \\frac{3}{398} = \\frac{196}{199} + \\frac{3}{199} = \\frac{199}{199} = 1$。\n\n现在，我们对重组进行建模。第 $t+1$ 代开始时的频率，记为 $x_h(t+1)$，由选择后的频率 $x'_h$ 形成。其递推方程为：\n$x_{AB}(t+1) = x'_{AB} - r D'$\n$x_{Ab}(t+1) = x'_{Ab} + r D'$\n$x_{aB}(t+1) = x'_{aB} + r D'$\n$x_{ab}(t+1) = x'_{ab} - r D'$\n其中 $D'$ 是选择后的连锁不平衡系数：\n$$ D' = x'_{AB} x'_{ab} - x'_{Ab} x'_{aB} = \\left(\\frac{98}{199}\\right)^2 - \\left(\\frac{3}{398}\\right)^2 $$\n为了简化计算，我们注意到 $\\frac{98}{199} = \\frac{196}{398}$。\n$$ D' = \\left(\\frac{196}{398}\\right)^2 - \\left(\\frac{3}{398}\\right)^2 = \\frac{196^2 - 3^2}{398^2} = \\frac{(196-3)(196+3)}{(2 \\times 199)^2} = \\frac{193 \\times 199}{4 \\times 199^2} = \\frac{193}{4 \\times 199} = \\frac{193}{796} $$\n对于相引单倍型，由重组引起的变化是 $-rD'$；对于相斥单倍型，变化是 $+rD'$。当 $r=1/2$ 时：\n$$ rD' = \\frac{1}{2} \\times \\frac{193}{796} = \\frac{193}{1592} $$\n现在我们求出第 $t+1$ 代的频率：\n$$ x_{AB}(t+1) = x'_{AB} - rD' = \\frac{98}{199} - \\frac{193}{1592} = \\frac{98 \\times 8}{199 \\times 8} - \\frac{193}{1592} = \\frac{784 - 193}{1592} = \\frac{591}{1592} $$\n根据对称性，$x_{ab}(t+1) = \\frac{591}{1592}$。\n$$ x_{Ab}(t+1) = x'_{Ab} + rD' = \\frac{3}{398} + \\frac{193}{1592} = \\frac{3 \\times 4}{398 \\times 4} + \\frac{193}{1592} = \\frac{12 + 193}{1592} = \\frac{205}{1592} $$\n根据对称性，$x_{aB}(t+1) = \\frac{205}{1592}$。\n\n接下来，我们计算第 $t+1$ 代开始时的平均绝对适合度 $\\bar{w}_{t+1}$。\n$$ \\bar{w}_{t+1} = \\sum_{h} x_h(t+1) w_h $$\n$$ \\bar{w}_{t+1} = \\left(\\frac{591}{1592}\\right)\\left(\\frac{6}{5}\\right) + \\left(\\frac{205}{1592}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{205}{1592}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{591}{1592}\\right)\\left(\\frac{6}{5}\\right) $$\n$$ \\bar{w}_{t+1} = \\frac{1}{1592} \\left[ 2 \\times 591 \\times \\frac{6}{5} + 2 \\times 205 \\times \\frac{9}{10} \\right] $$\n$$ \\bar{w}_{t+1} = \\frac{1}{1592} \\left[ \\frac{7092}{5} + \\frac{3690}{10} \\right] = \\frac{1}{1592} \\left[ \\frac{7092}{5} + \\frac{1845}{5} \\right] = \\frac{1}{1592} \\left[ \\frac{8937}{5} \\right] = \\frac{8937}{7960} $$\n\n最后，我们计算平均绝对适合度的净变化量 $\\Delta \\bar{w}$。\n$$ \\Delta \\bar{w} = \\bar{w}_{t+1} - \\bar{w}_t = \\frac{8937}{7960} - \\frac{597}{500} $$\n为了对这两个分数进行相减，我们找到一个公分母。$7960 = 40 \\times 199 = 2^3 \\times 5 \\times 199$ 且 $500 = 5 \\times 100 = 2^2 \\times 5^3$。最小公倍数是 $2^3 \\times 5^3 \\times 199 = 199000$。\n$$ \\Delta \\bar{w} = \\frac{8937 \\times (199000/7960)}{199000} - \\frac{597 \\times (199000/500)}{199000} $$\n$$ \\Delta \\bar{w} = \\frac{8937 \\times 25}{199000} - \\frac{597 \\times 398}{199000} $$\n$$ 8937 \\times 25 = 223425 $$\n$$ 597 \\times 398 = 237606 $$\n$$ \\Delta \\bar{w} = \\frac{223425 - 237606}{199000} = \\frac{-14181}{199000} $$\n分子的质因数是 $14181 = 3 \\times 4727$。分母的质因数是 $199000 = 2^3 \\times 5^3 \\times 199$。没有公因数，所以该分数已是最简形式。\n\n平均适合度总是增加的经典结论，通常被视为对费雪自然选择基本定理（Fisher's Fundamental Theorem of Natural Selection）的简化解释，但它并非普遍适用。本例中由于**上位性**和**重组**的相互作用而规避了该结论。\n适合度景观表现出强烈的正上位性：“相引”单倍型 $AB$ 和 $ab$ 的适合度 ($w=1.2$) 显著高于“相斥”单倍型 $Ab$ 和 $aB$ ($w=0.9$)。群体起始时具有正的连锁不平衡 ($D(t) = 0.49^2 - 0.01^2 = 0.24 > 0$)，意味着适合的单倍型过量。选择的作用是进一步富集这些单倍型，这在代内增加了平均适合度。然而，重组的作用是打破这些有利的等位基因组合，从而产生更多适合度较低的相斥单倍型。在这个特定案例中，由重组引起的平均适合度下降幅度大于由选择引起的上升幅度，导致从一代到下一代的平均适合度出现净减少（$\\Delta \\bar{w} < 0$）。这表明，在具有上位性的多基因座系统中，重组可以导致平均适合度下降，使群体远离适合度峰值。",
            "answer": "$$ \\boxed{-\\frac{14181}{199000}} $$"
        },
        {
            "introduction": "将理论模型应用于真实数据是现代进化生物学家的核心技能。本练习将指导你构建一个整合了选择、遗传漂变和测序误差的状态空间模型 (state-space model)，从时间序列等位基因频率数据中推断选择系数 $s$。通过实施一个隐马尔可夫模型 (Hidden Markov Model) 的似然计算方法，你将亲身体验如何从充满噪声的实验数据中量化自然选择的力量，这是连接理论预测与实验验证的关键一步 。",
            "id": "2714110",
            "problem": "你的任务是构建一个结合了 Wright–Fisher 漂变和选择的离散时间状态空间模型，并用它从包含测序错误的等位基因计数时间序列中推断未知的选择系数。你的程序必须实现以下模型和推断过程，然后报告在指定测试集上的结果。\n\n模型设定\n\n- 隐状态：令 $K_t \\in \\{0,1,\\dots,2N_e\\}$ 表示在离散世代 $t$ 时焦点等位基因的潜在计数，其中 $N_e$ 是有效种群大小，$2N_e$ 是二倍体基因拷贝数。\n\n- 选择与繁殖：假设每个世代的焦点等位基因都受到选择系数为 $s$ 的基因选择作用，产生漂变前的等位基因频率\n$$\np^{\\text{sel}}_t = \\frac{p_t (1+s)}{1 + s p_t},\n$$\n其中 $p_t = K_t/(2N_e)$。然后通过抽样（遗传漂变）得到下一代的计数\n$$\nK_{t+1} \\sim \\mathrm{Binomial}\\!\\left(2N_e,\\, p^{\\text{sel}}_t\\right).\n$$\n\n- 带测序错误的观测模型：在每个世代 $t$，你从 $R_t$ 个总读数中观测到焦点等位基因的测序读数计数为 $X_t$，每个读数的对称错误率为 $\\varepsilon$。在测序中将一个读数识别为焦点等位基因的概率是\n$$\nq_t = \\varepsilon + (1 - 2\\varepsilon) p_t.\n$$\n在给定 $K_t$ 的条件下，观测值为\n$$\nX_t \\sim \\mathrm{Binomial}(R_t, q_t).\n$$\n\n- 先验：对初始隐状态使用无信息先验，$K_0 \\sim \\mathrm{Uniform}\\{0,1,\\dots, 2N_e\\}$。\n\n推断目标和方法\n\n- 目标：未知的选择系数 $s$。\n\n- 似然：给定观测计数的 $s$ 的边缘似然是通过对所有隐状态轨迹求和得到的。使用类似于隐马尔可夫模型 (HMM) 中的前向算法来计算该边缘似然：通过 Wright–Fisher (WF) 转移核迭代传播 $K_t$ 的预测分布，并在每个时间点用二项观测似然进行更新。\n\n- 点估计：返回在一个候选值网格上使边缘似然最大化的值 $s^\\star$。\n\n基础理论\n\n- 使用带有选择和用于漂变的二项抽样的经典 Wright–Fisher 模型。\n\n- 对测序计数使用带有对称误判概率 $\\varepsilon$ 的二项模型。\n\n- 所有计算都应以概率和概率质量函数的形式进行，并根据需要通过对数伽马函数进行数值稳定的计算。\n\n测试集\n\n对于以下每种情况，首先使用上述精确的生成模型模拟一个合成时间序列，然后通过网格搜索执行推断以估计 $s$。模拟和推断都必须使用相同的 $N_e$、$\\varepsilon$、读取深度 $\\{R_t\\}$、时间点数 $T$ 和初始等位基因频率 $p_0$。模拟协议如下：\n\n- 初始化 $K_0 \\sim \\mathrm{Binomial}(2N_e, p_0)$。\n\n- 对于 $t = 0,1,\\dots,T-1$：\n    - 生成 $X_t \\sim \\mathrm{Binomial}(R_t, \\varepsilon + (1 - 2\\varepsilon) K_t/(2N_e))$。\n    - 计算 $p^{\\text{sel}}_t = \\frac{(K_t/(2N_e)) (1+s_{\\text{true}})}{1 + s_{\\text{true}} (K_t/(2N_e))}$。\n    - 抽样 $K_{t+1} \\sim \\mathrm{Binomial}(2N_e, p^{\\text{sel}}_t)$。\n\n为确保确定性，每种情况使用一个固定的伪随机种子。然后，给定观测到的 $\\{X_t\\}$ 和 $\\{R_t\\}$，通过在网格 $s \\in \\{-0.200, -0.195, \\dots, 0.200\\}$ 上最大化边缘似然来估计 $s$。\n\n提供以下三种情况的结果：\n\n- 情况 A（理想情况，正选择）：\n    - $N_e = 100$, $s_{\\text{true}} = 0.050$, $\\varepsilon = 0.010$, $p_0 = 0.100$, $T = 7$ 个时间点。\n    - 读取深度：对于所有 $t \\in \\{0,\\dots,6\\}$，$R_t = 120$。\n    - 随机种子：$1337$。\n\n- 情况 B（边界情况，中性）：\n    - $N_e = 80$, $s_{\\text{true}} = 0.000$, $\\varepsilon = 0.020$, $p_0 = 0.500$, $T = 7$ 个时间点。\n    - 按时间的读取深度：$R = [60, 80, 100, 120, 80, 60, 100]$。\n    - 随机种子：$7$。\n\n- 情况 C（负选择，低错误率和可变深度）：\n    - $N_e = 120$, $s_{\\text{true}} = -0.030$, $\\varepsilon = 0.005$, $p_0 = 0.200$, $T = 7$ 个时间点。\n    - 按时间的读取深度：$R = [100, 100, 150, 150, 120, 120, 100]$。\n    - 随机种子：$2021$。\n\n实现细节和输出格式\n\n- 在适当的情况下，通过对数伽马函数对二项概率质量函数进行数值稳定的计算。\n\n- 通过将所有限制在 $[0,1]$ 范围内的概率裁剪到一个小开区间（例如 $[10^{-12}, 1 - 10^{-12}]$）来处理，以避免数值问题。\n\n- 最终输出必须是单行文本，包含一个由三个选定的最大化值 $[s^\\star_A, s^\\star_B, s^\\star_C]$ 组成的逗号分隔列表，每个值都是四舍五入到三位小数的浮点数，并用方括号括起来。\n\n- 此问题不涉及物理单位。\n\n- 此问题不使用角度。\n\n- 可以使用分数或小数；不要使用百分号。\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，“[0.045,0.000,-0.030]”）。",
            "solution": "我们构建一个状态空间模型，其中隐藏的群体遗传过程遵循带选择的 Wright–Fisher 动态，观测过程遵循带对称测序错误的二项抽样。在世代 $t$ 的隐状态是等位基因计数 $K_t \\in \\{0, \\dots, 2N_e\\}$，其对应的等位基因频率为 $p_t = K_t/(2N_e)$。\n\n基本原理与模型构建\n\n1. 带选择的 Wright–Fisher 转移。在选择系数为 $s$ 的基因选择下，焦点等位基因的相对适应度为 $1+s$。漂变前的选择后频率为\n$$\np^{\\text{sel}}_t = \\frac{p_t (1+s)}{1 + s p_t},\n$$\n这是从单倍体或加性二倍体（基因性）情景下的标准生存力选择中推导出来的。漂变通过对 $2N_e$ 个基因拷贝进行二项抽样来建模：\n$$\nK_{t+1} \\mid K_t \\sim \\mathrm{Binomial}\\!\\left(2N_e,\\, p^{\\text{sel}}_t\\right).\n$$\n这在 $\\{0,\\dots,2N_e\\}$ 上定义了一个时齐马尔可夫链，其转移核为\n$$\n\\Pr(K_{t+1} = k' \\mid K_t = k; s) = \\binom{2N_e}{k'} \\left(p^{\\text{sel}}(k; s)\\right)^{k'} \\left(1 - p^{\\text{sel}}(k; s)\\right)^{2N_e - k'},\n$$\n其中 $p^{\\text{sel}}(k; s) = \\frac{(k/(2N_e)) (1+s)}{1 + s (k/(2N_e))}$。\n\n2. 带测序错误的观测模型。给定真实频率 $p_t = K_t/(2N_e)$ 和每个读数的对称错误概率 $\\varepsilon$，单个读数被识别为焦点等位基因的概率为\n$$\nq_t = \\varepsilon + (1 - 2\\varepsilon) p_t,\n$$\n这是因为一个读数正确的概率是 $1-\\varepsilon$，被翻转的概率是 $\\varepsilon$；在双等位基因情况下，这导致了对 $p_t$ 的线性变换。给定在时间 $t$ 的总读数为 $R_t$，观测计数 $X_t$ 的分布为\n$$\nX_t \\mid K_t \\sim \\mathrm{Binomial}(R_t, q_t).\n$$\n\n3. 先验。我们对初始状态使用无信息先验，$K_0 \\sim \\mathrm{Uniform}\\{0,\\dots,2N_e\\}$，这反映了我们对初始等位基因计数缺乏先验知识。该先验既不是转移的共轭先验，也不是观测的共轭先验，但对于通过对状态求和来进行有原则的似然计算已经足够。\n\n通过前向算法计算边缘似然\n\n令 $\\boldsymbol{\\alpha}_t(k) = \\Pr(K_t = k \\mid X_{0:t}; s)$ 表示在结合了时间 $t$ 的观测值后的滤波分布。前向递归过程如下：\n\n- 在 $t=0$ 时初始化：\n$$\n\\tilde{\\alpha}_0(k) = \\Pr(K_0 = k) \\cdot \\Pr(X_0 \\mid K_0 = k; \\varepsilon, R_0),\n$$\n其中对于所有 $k$，$\\Pr(K_0 = k) = 1/(2N_e+1)$。通过 $Z_0 = \\sum_{k} \\tilde{\\alpha}_0(k)$ 进行归一化，得到 $\\boldsymbol{\\alpha}_0(k) = \\tilde{\\alpha}_0(k)/Z_0$。将 $\\log Z_0$ 累加到总对数似然中。\n\n- 对于 $t \\ge 1$ 的归纳步骤：\n    - 预测：\n    $$\n    \\pi_t(k') = \\sum_{k=0}^{2N_e} \\boldsymbol{\\alpha}_{t-1}(k) \\cdot \\Pr(K_t = k' \\mid K_{t-1} = k; s).\n    $$\n    - 用观测值更新：\n    $$\n    \\tilde{\\alpha}_t(k') = \\pi_t(k') \\cdot \\Pr(X_t \\mid K_t = k'; \\varepsilon, R_t),\n    $$\n    随后通过 $Z_t = \\sum_{k'} \\tilde{\\alpha}_t(k')$ 进行归一化并设置 $\\boldsymbol{\\alpha}_t(k') = \\tilde{\\alpha}_t(k')/Z_t$。将 $\\log Z_t$ 累加到总对数似然中。\n\n总边缘对数似然为\n$$\n\\log \\mathcal{L}(s) = \\sum_{t=0}^{T-1} \\log Z_t,\n$$\n因为每个归一化常数 $Z_t$ 对应于在参数 $s$ 下，给定过去观测值的当前观测值 $X_t$ 的预测概率。\n\n数值稳定的计算\n\n- 对于二项概率质量函数 $\\binom{n}{k} p^k (1-p)^{n-k}$，使用对数伽马函数计算 $\\log \\binom{n}{k}$：$\\log \\binom{n}{k} = \\Gamma(n+1) - \\Gamma(k+1) - \\Gamma(n-k+1)$ 以 $\\log \\Gamma(\\cdot)$ 表示，即 $\\mathrm{gammaln}$。\n\n- 在构建转移矩阵的行和发射向量时，在对数空间中计算概率，仅在必要时减去一个合适的偏移量后再取指数，并将 $p$ 和 $q$ 裁剪到 $[10^{-12}, 1 - 10^{-12}]$ 以避免 $\\log 0$。\n\n点估计\n\n- 定义一个候选选择系数的网格 $s \\in \\{-0.200, -0.195, \\dots, 0.200\\}$。\n\n- 对于网格上的每个 $s$，构建转移核并运行前向算法来计算 $\\log \\mathcal{L}(s)$。\n\n- 选择最大似然估计 (MLE) $s^\\star = \\arg\\max_s \\log \\mathcal{L}(s)$。\n\n为测试集进行模拟\n\n对于每种情况，使用相同的模型模拟一个数据集：\n\n- 初始化 $K_0 \\sim \\mathrm{Binomial}(2N_e, p_0)$。\n\n- 对于 $t = 0,\\dots,T-1$:\n    - 生成 $X_t \\sim \\mathrm{Binomial}(R_t, \\varepsilon + (1-2\\varepsilon) K_t/(2N_e))$。\n    - 计算 $p^{\\text{sel}}_t = \\frac{(K_t/(2N_e))(1+s_{\\text{true}})}{1 + s_{\\text{true}} (K_t/(2N_e))}$。\n    - 抽样 $K_{t+1} \\sim \\mathrm{Binomial}(2N_e, p^{\\text{sel}}_t)$。\n\n按规定使用固定的种子以保证可复现性。\n\n算法结构\n\n- 对于每种情况，使用给定的参数和种子生成观测计数。\n\n- 对于每种情况，遍历 $s$ 网格，为每个 $s$ 构建一次转移矩阵，并使用对 $K_0$ 的均匀先验通过前向递归计算边缘对数似然。\n\n- 记录使对数似然最大化的 $s$，并四舍五入到三位小数。\n\n输出\n\n- 生成单行文本，按顺序包含三种情况的三个 MLE，格式为用方括号括起来的逗号分隔列表，例如 $[0.045, 0.000, -0.030]$，每个值都四舍五入到三位小数。\n\n这种方法将 Wright–Fisher 漂变与选择的基本定义以及二项观测噪声整合到一个有原则的隐马尔可夫模型似然中，从而能够从带噪声的等位基因计数时间序列中对选择系数进行一致的推断。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef rng(seed):\n    # Simple wrapper for NumPy Generator for reproducibility\n    return np.random.default_rng(seed)\n\ndef log_binom_coeff(n, k):\n    # log binomial coefficient log(C(n,k))\n    return gammaln(n + 1.0) - gammaln(k + 1.0) - gammaln(n - k + 1.0)\n\ndef build_transition_matrix(Ne, s):\n    \"\"\"\n    Build the (2Ne+1) x (2Ne+1) transition matrix T where\n    T[i, j] = P(K_{t+1} = j | K_t = i; s)\n    Using genic selection and Wright-Fisher sampling.\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    T = np.zeros((S, S), dtype=np.float64)\n    # Precompute log binomial coefficients for columns j\n    j = np.arange(S)\n    logC = log_binom_coeff(twoN, j)\n    # For each row i (state k=i)\n    i = np.arange(S)\n    p = i / twoN\n    # Selection-transformed frequency\n    denom = 1.0 + s * p\n    # Avoid division by zero for s near -1\n    denom = np.clip(denom, 1e-12, np.inf)\n    p_sel = p * (1.0 + s) / denom\n    p_sel = np.clip(p_sel, 1e-12, 1.0 - 1e-12)\n    # Fill each row: Binomial(twoN, p_sel[i]) across all j\n    for idx in range(S):\n        ps = p_sel[idx]\n        # log pmf for all j\n        logpmf = logC + j * np.log(ps) + (twoN - j) * np.log(1.0 - ps)\n        # exponentiate safely (values are well-behaved for twoN up to ~300)\n        row = np.exp(logpmf)\n        # Normalize to avoid small numerical drift\n        row_sum = row.sum()\n        if row_sum <= 0.0 or not np.isfinite(row_sum):\n            # Fallback normalization in extreme edge cases\n            m = np.max(logpmf)\n            row = np.exp(logpmf - m)\n            row_sum = row.sum()\n        T[idx, :] = row / row_sum\n    return T\n\ndef emission_log_probs_vector(Ne, epsilon, R, X):\n    \"\"\"\n    For a single timepoint with observed X out of R, return a vector of\n    log-likelihoods log P(X | K=k) for k in 0..2Ne, with q = eps + (1-2eps)*p\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    k = np.arange(S)\n    p = k / twoN\n    q = epsilon + (1.0 - 2.0 * epsilon) * p\n    q = np.clip(q, 1e-12, 1.0 - 1e-12)\n    # log binomial pmf\n    logC_RX = log_binom_coeff(R, X)\n    loglik = logC_RX + X * np.log(q) + (R - X) * np.log(1.0 - q)\n    return loglik  # shape (S,)\n\ndef forward_loglikelihood(Ne, epsilon, R_list, X_list, s):\n    \"\"\"\n    Compute the marginal log-likelihood log L(s) via the forward algorithm\n    with a uniform prior over K_0.\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    T = build_transition_matrix(Ne, s)\n    # Initial prior over K_0\n    pi = np.full(S, 1.0 / S, dtype=np.float64)\n    logL = 0.0\n    T_steps = len(X_list)\n    for t in range(T_steps):\n        # Emission update\n        loge = emission_log_probs_vector(Ne, epsilon, R_list[t], X_list[t])\n        # Work in linear space via stable exponentiation\n        m = np.max(loge)\n        e = np.exp(loge - m)\n        # alpha_tilde = pi * e\n        alpha_tilde = pi * e\n        Z = alpha_tilde.sum()\n        if Z <= 0.0 or not np.isfinite(Z):\n            # Degenerate; avoid failure by small floor\n            Z = 1e-300\n        logZ = np.log(Z) + m  # account for offset m\n        logL += logZ\n        alpha = alpha_tilde / Z\n        # Prediction to next time (skip after last observation)\n        if t < T_steps - 1:\n            pi = alpha @ T\n            # Numerical safety normalization\n            ssum = pi.sum()\n            if ssum > 0:\n                pi = pi / ssum\n            else:\n                pi = np.full(S, 1.0 / S, dtype=np.float64)\n    return logL\n\ndef simulate_case(Ne, s_true, p0, epsilon, R_list, T, seed):\n    \"\"\"\n    Simulate a dataset:\n    - Initialize K0 ~ Binomial(2Ne, p0)\n    - For t = 0..T-1:\n        - Observe X_t ~ Binomial(R_t, q_t) with q_t = eps + (1-2 eps) * p_t\n        - Compute p_sel and sample K_{t+1} ~ Binomial(2Ne, p_sel)\n    Returns observed counts X_list.\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    gen = rng(seed)\n    K = gen.binomial(twoN, p0)\n    X_list = []\n    for t in range(T):\n        p = K / twoN\n        q = epsilon + (1.0 - 2.0 * epsilon) * p\n        q = np.clip(q, 1e-12, 1.0 - 1e-12)\n        X = gen.binomial(R_list[t], q)\n        X_list.append(int(X))\n        # Selection and drift to next generation\n        denom = 1.0 + s_true * p\n        denom = max(denom, 1e-12)\n        p_sel = p * (1.0 + s_true) / denom\n        p_sel = float(np.clip(p_sel, 1e-12, 1.0 - 1e-12))\n        K = gen.binomial(twoN, p_sel)\n    return X_list\n\ndef estimate_s_MLE(Ne, epsilon, R_list, X_list, s_grid):\n    best_s = None\n    best_logL = -np.inf\n    for s in s_grid:\n        logL = forward_loglikelihood(Ne, epsilon, R_list, X_list, s)\n        if logL > best_logL:\n            best_logL = logL\n            best_s = s\n    return best_s, best_logL\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Ne, s_true, epsilon, p0, T, R_list, seed)\n    test_cases = [\n        (100, 0.050, 0.010, 0.100, 7, [120]*7, 1337),                        # Case A\n        (80,  0.000, 0.020, 0.500, 7, [60, 80, 100, 120, 80, 60, 100], 7),   # Case B\n        (120, -0.030, 0.005, 0.200, 7, [100, 100, 150, 150, 120, 120, 100], 2021),  # Case C\n    ]\n\n    # Grid of s to search\n    s_grid = np.round(np.arange(-0.200, 0.200 + 0.0005, 0.005), 3)  # ensure inclusive endpoint\n\n    results = []\n    for (Ne, s_true, epsilon, p0, T, R_list, seed) in test_cases:\n        # Simulate observed counts\n        X_list = simulate_case(Ne, s_true, p0, epsilon, R_list, T, seed)\n        # Estimate s by MLE on the grid\n        s_hat, _ = estimate_s_MLE(Ne, epsilon, R_list, X_list, s_grid)\n        # Round to three decimals for output\n        results.append(f\"{s_hat:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}