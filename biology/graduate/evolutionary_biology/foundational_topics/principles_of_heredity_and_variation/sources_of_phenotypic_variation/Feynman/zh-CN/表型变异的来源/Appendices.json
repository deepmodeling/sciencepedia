{
    "hands_on_practices": [
        {
            "introduction": "定量遗传学的第一步通常是将观察到的表型方差 ($V_P$) 分解为其组成部分。本练习旨在通过应用核心的狭义遗传力 ($h^2$) 公式，提供一次基础性的计算实践。更重要的是，这个思想实验将揭示为何遗传力并非性状的固有属性，而是依赖于特定的环境背景。",
            "id": "2751927",
            "problem": "在一个宏观环境尽可能保持一致的条件下测量一个数量性状，但存在可测量的微观环境异质性。在此设定下，估计的表型方差为 $V_{P}=10$，加性遗传方差为 $V_{A}=3$，基因型-环境互作方差 (G×E) 为 $V_{G\\times E}=2$。假设显性遗传方差和上位性遗传方差可忽略不计，基因型与环境之间的协方差也可忽略不计，因此除上述方差组分外，没有其他方差组分对 $V_{P}$ 有贡献。\n\n仅使用数量遗传学中关于方差分解和狭义遗传力的基本定义，确定基准设定下的狭义遗传力 $h^{2}$。然后，假设环境异质性增加，使得环境方差 $V_{E}$ 增加 $50$%，而 $V_{A}$ 和 $V_{G\\times E}$ 保持不变。确定在这种更具异质性的环境下的新 $h^{2}$。\n\n将两个答案都表示为无需四舍五入的精确分数。将你的最终结果以单行矩阵的形式提供，其中包含两个条目，按基准设定和异质性增加后的顺序排列，不带单位。",
            "solution": "本题要求计算在两种不同环境条件下的狭义遗传力 $h^{2}$。我们首先陈述数量遗传学中关于表型方差分解的基本原理。\n\n首先，必须验证题目的陈述。\n给定条件如下：\n- 基准总表型方差：$V_{P} = 10$\n- 加性遗传方差：$V_{A} = 3$\n- 基因型-环境互作方差：$V_{G \\times E} = 2$\n- 假设：显性方差 ($V_{D}$) 和上位性方差 ($V_{I}$) 可忽略不计。基因型与环境之间的协方差 ($\\text{Cov}(G, E)$) 可忽略不计。\n- 第二种情景的条件：环境方差 ($V_{E}$) 增加 $50$%。$V_{A}$ 和 $V_{G \\times E}$ 保持不变。\n\n该问题科学地基于数量遗传学的原理，特别是表型方差的分解和遗传力的定义。该问题陈述清晰、客观且自成体系，提供了得出唯一解所需的所有数据和简化假设。数据在数值上是一致的，对于一个理论模型来说是合理的。因此，该问题是有效的，我们可以继续求解。\n\n数量性状的总表型方差 $V_P$ 可分解为其成因组分。综合模型为：\n$$V_P = V_G + V_E + V_{G \\times E} + 2 \\text{Cov}(G, E)$$\n其中 $V_G$ 是遗传方差，$V_E$ 是环境方差，$V_{G \\times E}$ 是由基因型-环境互作引起的方差，$\\text{Cov}(G, E)$ 是遗传效应与环境效应之间的协方差。遗传方差本身是一个和：$V_G = V_A + V_D + V_I$，其中 $V_A$ 是加性方差，$V_D$ 是显性方差，$V_I$ 是上位性方差。\n\n题目陈述提供了简化该模型的约束条件。显性方差和上位性方差可忽略不计，意味着 $V_G \\approx V_A$。基因型-环境协方差可忽略不计，意味着 $2 \\text{Cov}(G, E) \\approx 0$。因此，本题的主导方程变为：\n$$V_P = V_A + V_E + V_{G \\times E}$$\n狭义遗传力 $h^{2}$ 定义为总表型方差中由加性遗传方差贡献的比例：\n$$h^{2} = \\frac{V_A}{V_P}$$\n我们现在将在两种指定条件下求解 $h^{2}$。\n\n第1部分：基准遗传力。\n题目直接提供了基准设定所需的值：\n- $V_A = 3$\n- $V_P = 10$ (为清楚起见，我们将其记为 $V_{P,1}$)\n\n因此，基准狭义遗传力 $h_1^{2}$ 为：\n$$h_1^{2} = \\frac{V_A}{V_{P,1}} = \\frac{3}{10}$$\n为了准备第二部分的计算，我们必须确定基准环境方差 $V_{E,1}$。使用我们简化的方差方程：\n$$V_{P,1} = V_A + V_{E,1} + V_{G \\times E}$$\n代入给定值：\n$$10 = 3 + V_{E,1} + 2$$\n$$10 = 5 + V_{E,1}$$\n求解 $V_{E,1}$ 得：\n$$V_{E,1} = 10 - 5 = 5$$\n\n第2部分：环境异质性增加后的遗传力。\n题目陈述环境方差增加了 $50$%。新的环境方差 $V_{E,2}$ 计算如下：\n$$V_{E,2} = V_{E,1} + (0.50 \\times V_{E,1}) = 1.5 \\times V_{E,1}$$\n$$V_{E,2} = 1.5 \\times 5 = 7.5$$\n根据题目陈述，加性遗传方差和G×E方差保持不变：$V_A = 3$ 且 $V_{G \\times E} = 2$。\n\n新的总表型方差 $V_{P,2}$ 是更新后各组分的总和：\n$$V_{P,2} = V_A + V_{E,2} + V_{G \\times E}$$\n$$V_{P,2} = 3 + 7.5 + 2 = 12.5$$\n使用这个新的总表型方差计算新的狭义遗传力 $h_2^{2}$：\n$$h_2^{2} = \\frac{V_A}{V_{P,2}} = \\frac{3}{12.5}$$\n为了按要求将此结果表示为精确分数，我们将分母从小数形式转换：\n$$h_2^{2} = \\frac{3}{\\frac{25}{2}} = \\frac{3 \\times 2}{25} = \\frac{6}{25}$$\n两个答案是基准遗传力 $h_1^{2} = \\frac{3}{10}$ 和环境异质性增加后的遗传力 $h_2^{2} = \\frac{6}{25}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{3}{10} & \\frac{6}{25} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在理解了方差分量的概念之后，我们的关注点转移到如何设计实验来准确估计它们这一实际挑战。本练习将公共花园实验作为一种强大的工具，引导我们思考实验设计的关键原则，如随机化、区组设计和重复。通过这些设计，我们将能够有效地将遗传方差 ($V_G$) 从环境方差 ($V_E$) 甚至测量误差 ($V_M$) 中分离出来。",
            "id": "2751903",
            "problem": "您正在计划一项对一种克隆水生植物进行的共通花园研究，以量化遗传方差 ($V_G$) 对叶状体面积变异的贡献，同时最小化环境方差 ($V_E$) 并明确估计测量误差方差 ($V_M$)。遗传方差 ($V_G$) 是表型方差中可归因于基因型间可遗传的遗传差异的组分。环境方差 ($V_E$) 是可归因于个体间环境差异的组分。测量误差方差 ($V_M$) 是可归因于测量过程不精确性的组分。您可以使用 $G$ 个作为克隆系维持的独特基因型、一个具有均匀光照和营养液的可控生长室，以及 $b$ 个可能存在微小环境差异的实验台（物理区组）。您可以在每个实验台为每个基因型培养 $r$ 个重复个体，并可以使用相同的成像流程对每个个体进行 $m$ 次叶状体面积的重复测量。\n\n根据数量遗传学和实验设计的基本原理，您的目标是通过在共通花园中尽可能保持 $V_E$ 恒定来分离出 $V_G$，同时规划重复实验，使您能够将 $V_M$ 与个体间的残余微环境变异分开量化。假设如果在每个实验台内将基因型随机化，则实验台之间的任何宏观环境差异都可以用随机区组效应来近似。\n\n以下哪种实验设计和分析计划最有效地实现这些目标，并且在估计 $V_G$、控制 $V_E$ 和量化 $V_M$ 方面是科学上合理的？请选择唯一的最佳选项。\n\nA. 繁殖 $G$ 个克隆基因型。在单个可控生长室中，实施一个包含 $b$ 个实验台的随机完全区组设计：在每个实验台内，为每个基因型放置 $r \\ge 1$ 个完全随机化的个体。在所有实验台中保持相同的营养液和光周期，并每日轮换托盘以减少位置效应。对于每个个体，使用校准过的成像系统在同一天进行 $m \\ge 2$ 次独立的、盲法的基于图像的叶状体面积测量。拟合一个线性混合效应模型，其中包含基因型 ($G$)、区组 ($B$)、嵌套于基因型和区组内的个体 ($I \\mid G,B$) 的随机效应，以及一个代表测量误差的残余项。使用方差组分来估计 $V_G$，一个作为 $V_E$ 一部分的区组组分，一个作为微环境尺度上残余 $V_E$ 的基因型内个体间组分，以及将残余项作为 $V_M$。\n\nB. 通过分组将基因型分配到两个房间：将所有来自种群1的基因型放入房间1，所有来自种群2的基因型放入房间2，名义上保持条件相同，每个基因型生长 $r \\ge 3$ 个重复，每个植株进行 $m=1$ 次测量。使用一个将房间和基因型作为固定因子的固定效应双因素方差分析 (ANOVA) 进行分析，省略任何随机效应。\n\nC. 将每个基因型的所有重复放在同一个实验台上以便于照料（每个基因型一个实验台），每个基因型生长 $r \\ge 10$ 个重复，每个植株进行 $m \\ge 5$ 次重复测量以减少噪声。通过对每个植株的 $m$ 次测量取平均值，然后用单因素方差分析比较基因型均值，并忽略实验台效应。\n\nD. 在土壤和气候形成对比的两个地点建立室外共通花园，以增加环境范围。在每个地点将基因型随机分配到样地，每个基因型每个地点生长 $r \\ge 5$ 个重复，每个植株进行 $m=1$ 次测量，并拟合一个将基因型和地点作为固定效应的模型，以估计跨环境的 $V_G$。\n\nE. 使用来自 $G$ 个半同胞家系的种子，将每个家系的同胞种植在同一个盆中以标准化微环境，在一个实验台上每个家系生长 $r \\ge 5$ 盆，每个植株进行 $m \\ge 2$ 次测量。将家系视为随机效应来估计遗传方差，将残余项视为测量误差，省略任何区组或个体水平的随机效应。\n\n通过选择能够通过控制 $V_E$ 最佳地分离 $V_G$，并包含足以单独量化 $V_M$ 的重复设计的选项来回答，该选择需基于数量遗传学和实验设计基本原理的方差划分逻辑得到证明。",
            "solution": "该问题要求提供一种实验设计和分析方案，用于量化一种克隆水生植物叶状体面积的遗传方差 ($V_G$)，同时最小化环境方差 ($V_E$) 并明确估计测量误差方差 ($V_M$)。首先必须评估问题陈述的有效性。\n\n### 步骤1：提取已知信息\n- **目标：** 量化遗传方差 ($V_G$)。\n- **约束1：** 最小化环境方差 ($V_E$)。\n- **约束2：** 明确估计测量误差方差 ($V_M$)。\n- **提供的定义：**\n    - $V_G$: 表型方差中源于基因型间可遗传的遗传差异的组分。\n    - $V_E$: 表型方差中源于个体间环境差异的组分。\n    - $V_M$: 表型方差中源于测量不精确性的组分。\n- **可用资源：**\n    - $G$ 个独特的克隆基因型。\n    - 一个具有均匀光照和营养液的可控生长室。\n    - $b$ 个可能存在微小环境差异的实验台。\n- **实验杠杆：**\n    - $r$: 每个基因型每个实验台的重复个体数。\n    - $m$: 每个个体的叶状体面积重复测量次数。\n- **假设：** 通过适当的随机化，实验台差异可被视为随机区组效应。\n- **任务：** 从一系列实验设计和分析方案中选择唯一的最佳选项。\n\n### 步骤2：使用提取的已知信息进行验证\n- **科学依据：** 该问题牢固地植根于数量遗传学和实验设计的核心原则。将表型方差划分为遗传和环境组分 ($V_P = V_G + V_E + ...$) 是一个基本概念。使用克隆生物、共通花园实验、区组、随机化和重复是实现此目的的标准、科学上合理的方法论。区分环境方差 ($V_E$) 和测量误差 ($V_M$) 也是生物学实验中一个关键且标准的考虑因素。该问题在科学上是合理的。\n- **提法恰当性：** 目标清晰，约束条件明确。可用资源和实验参数为评估所提出的选项提供了具体基础。根据既定原则，预计在选项中存在一个唯一的最佳解决方案。\n- **客观性：** 问题以精确、客观、技术性的语言陈述，没有歧义或主观性陈述。\n\n### 步骤3：结论与行动\n问题陈述在科学上是合理的、提法恰当且客观的。它不包含任何会使其无效的逻辑矛盾、信息缺失或其他缺陷。因此，我将对这些选项进行全面的解答和分析。\n\n### 从基本原理推导\n测量性状的总表型方差 ($V_P$) 可以被分解为其来源。对于这个特定的实验设置，一个关于在第 $j$ 个区组中第 $i$ 个基因型的第 $k$ 个个体的第 $l$ 次测量的个体测量值 $Y_{ijkl}$ 的综合模型是：\n$$Y_{ijkl} = \\mu + G_i + B_j + I_{k(ij)} + M_{l(ijk)}$$\n其中：\n- $\\mu$ 是叶状体面积的总平均值。\n- $G_i$ 是第 $i$ 个基因型的效应。将基因型视为随机效应，其方差 $\\sigma^2_G$ 对应于总遗传方差 $V_G$，因为我们使用的是克隆。\n- $B_j$ 是第 $j$ 个实验台（区组）的效应。其方差 $\\sigma^2_B$ 是环境方差 $V_E$ 的一个系统性组分。\n- $I_{k(ij)}$ 是第 $k$ 个个体的效应，嵌套于第 $i$ 个基因型和第 $j$ 个区组内。这代表了对该个体的独特微环境效应。其方差 $\\sigma^2_I$ 代表残余或微环境方差，是 $V_E$ 的另一个组分。要估计此项，需要在基因型-区组组合内有个体重复 ($r>1$)。\n- $M_{l(ijk)}$ 是与对第 $ijk$ 个体进行的第 $l$ 次测量相关的误差。其方差 $\\sigma^2_M$ 对应于测量误差方差 $V_M$。要估计此项，需要对每个个体进行重复测量 ($m>1$)。\n\n因此，总表型方差被划分为 $V_P = V_G + V_{E(\\text{block})} + V_{E(\\text{residual})} + V_M$，这对应于 $V_P = \\sigma^2_G + \\sigma^2_B + \\sigma^2_I + \\sigma^2_M$.\n\n一个成功的设计必须：\n1.  **分离 $V_G$**：这需要通过随机化来避免基因型效应与环境效应的混淆。克隆材料允许估计*总* $V_G$。\n2.  **控制 $V_E$**：这通过使用受控的共同环境以及通过区组设计在统计上解释已知的环境异质性来源（例如，实验台）来实现。\n3.  **量化 $V_M$**：这需要对每个植物个体进行 $m \\ge 2$ 次重复、独立的测量。\n\n### 逐项分析\n\n**A. 繁殖 $G$ 个克隆基因型。在单个可控生长室中，实施一个包含 $b$ 个实验台的随机完全区组设计：在每个实验台内，为每个基因型放置 $r \\ge 1$ 个完全随机化的个体。在所有实验台中保持相同的营养液和光周期，并每日轮换托盘以减少位置效应。对于每个个体，使用校准过的成像系统在同一天进行 $m \\ge 2$ 次独立的、盲法的基于图像的叶状体面积测量。拟合一个线性混合效应模型，其中包含基因型 ($G$)、区组 ($B$)、嵌套于基因型和区组内的个体 ($I \\mid G,B$) 的随机效应，以及一个代表测量误差的残余项。使用方差组分来估计 $V_G$，一个作为 $V_E$ 一部分的区组组分，一个作为微环境尺度上残余 $V_E$ 的基因型内个体间组分，以及将残余项作为 $V_M$。**\n\n此选项在方法上无懈可击。\n- **设计：** 它正确地使用了随机完全区组设计，这是控制单一、已知环境异质性来源（实验台）的经典方法。在每个区组*内*对基因型进行随机化，可以防止基因型和区组效应的混淆。使用克隆系可以估计总 $V_G$。使用单个受控房间可以最小化总 $V_E$。设置 $m \\ge 2$ 可以明确量化 $V_M$。设置 $r \\ge 1$ 允许重复，并且如果 $r > 1$，个体间的微环境方差也可以被估计。\n- **分析：** 提议的线性混合效应模型恰好是适用于此结构的正确工具。它正确地指定了基因型 ($\\sigma^2_G \\equiv V_G$)、区组 ($\\sigma^2_B \\subset V_E$) 和个体 ($\\sigma^2_I \\subset V_E$) 的随机效应。在这种包含重复测量的模型中，最终的残余方差对应于个体内方差，即测量误差 $V_M$。此计划实现了所有既定目标。\n**结论：正确**\n\n**B. 通过分组将基因型分配到两个房间：将所有来自种群1的基因型放入房间1，所有来自种群2的基因型放入房间2，名义上保持条件相同，每个基因型生长 $r \\ge 3$ 个重复，每个植株进行 $m=1$ 次测量。使用一个将房间和基因型作为固定因子的固定效应双因素方差分析 (ANOVA) 进行分析，省略任何随机效应。**\n\n此选项存在根本性缺陷。\n- **设计：** 该设计故意将遗传（种群来源）与环境（房间）混淆。任何观察到的房间差异都无法解释。这是糟糕的实验实践。此外，设置 $m=1$ 使得无法将测量误差 ($V_M$) 与个体水平的环境方差 ($V_E$) 分开。\n- **分析：** 固定效应模型不估计像 $V_G$ 这样的方差组分。它只检验特定、固定水平之间的均值差异是否显著。目标是估计一个群体参数 $V_G$，这需要将基因型视为随机效应。\n**结论：不正确**\n\n**C. 将每个基因型的所有重复放在同一个实验台上以便于照料（每个基因型一个实验台），每个基因型生长 $r \\ge 10$ 个重复，每个植株进行 $m \\ge 5$ 次重复测量以减少噪声。通过对每个植株的 $m$ 次测量取平均值，然后用单因素方差分析比较基因型均值，并忽略实验台效应。**\n\n此选项包含关键的设计和分析错误。\n- **设计：** 将一个基因型的所有重复放在单个实验台上是伪重复的教科书式例子。这完全混淆了基因型效应和实验台效应。无法确定是基因型A优于基因型B，还是仅仅是实验台A的环境优于实验台B。\n- **分析：** 在分析中忽略实验台效应加剧了设计缺陷。在分析前对 $m \\ge 5$ 次测量取平均值，阻止了对 $V_M$ 的量化，而这是问题的明确要求。单因素方差分析会错误地将真实遗传方差和实验台方差的总和归因于“基因型”因子。\n**结论：不正确**\n\n**D. 在土壤和气候形成对比的两个地点建立室外共通花园，以增加环境范围。在每个地点将基因型随机分配到样地，每个基因型每个地点生长 $r \\ge 5$ 个重复，每个植株进行 $m=1$ 次测量，并拟合一个将基因型和地点作为固定效应的模型，以估计跨环境的 $V_G$。**\n\n此选项针对的是一个不同的科学问题。\n- **设计：** 既定目标是*最小化* $V_E$。此设计通过使用两个形成对比的室外地点来故意*最大化* $V_E$。这是一个用于研究基因型与环境互作 ($V_{G \\times E}$) 的设计，而不是在受控环境中分离 $V_G$ 的设计。此外，设置 $m=1$ 使得无法量化 $V_M$。\n- **分析：** 与选项B一样，将基因型用作固定效应无法得到方差组分 $V_G$ 的估计值。\n**结论：不正确**\n\n**E. 使用来自 $G$ 个半同胞家系的种子，将每个家系的同胞种植在同一个盆中以标准化微环境，在一个实验台上每个家系生长 $r \\ge 5$ 盆，每个植株进行 $m \\ge 2$ 次测量。将家系视为随机效应来估计遗传方差，将残余项视为测量误差，省略任何区组或个体水平的随机效应。**\n\n此选项在材料选择、设计和分析上都有缺陷。\n- **材料：** 问题明确指出有克隆系可用。使用半同胞家系是不必要的偏离。克隆允许估计*总*遗传方差 ($V_G$)，而半同胞设计通常只允许估计*加性*遗传方差 ($V_A$)，这只是 $V_G$ 的一个组分。\n- **设计：** 将同胞种植在同一个盆中会引入竞争并将其与其他效应混淆；它并没有以有用的方式“标准化”微环境。将所有盆放在单个实验台上，未能考虑生长室内的环境梯度（即未能进行区组设计）。\n- **分析：** 分析方案不正确。一个只包含“家系”效应的模型中的残余方差会混淆家系内个体间的方差（遗传和环境方差的混合）和测量误差。要将这些分开，需要一个“个体”的嵌套随机效应。该方案未能正确划分方差。\n**结论：不正确**\n\n基于这一严谨的分析，选项A是唯一在科学上合理且满足问题陈述中所有特定目标的设计和分析方案。它展示了对数量遗传学实验设计的正确理解。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最后的练习将对基因型-环境互作 ($G \\times E$) 的分析从一个简单的方差分量提升到了一个函数关系——反应规范（reaction norm）。通过推导一个估计量并在代码中实现它，您将获得关于不同基因型如何响应连续环境梯度的第一手建模经验。这是现代进化和生态遗传学研究的一块基石。",
            "id": "2751899",
            "problem": "您获得一个用于模拟跨环境温度的线性反应范数的框架，其中基因型 $i$ 在温度指数 $j$ 的表型被模拟为\n$$\ny_{ij} = \\mu + g_i + \\beta_i T_j + \\epsilon_{ij},\n$$\n其中 $g_i$ 是基因型特异性与总体均值 $\\mu$ 的偏差，$\\beta_i$ 是基因型特异性斜率（反应范数），$T_j$是指数 $j$ 处的温度值，$\\epsilon_{ij}$ 是一个独立的残差。假设如下：\n- $g_i \\sim \\mathcal N(0,\\sigma_g^2)$ 在 $i$ 之间独立，\n- $\\beta_i \\sim \\mathcal N(0,\\sigma_\\beta^2)$ 在 $i$ 之间独立，且与 $g_i$ 独立，\n- $\\epsilon_{ij} \\sim \\mathcal N(0,\\sigma_\\epsilon^2)$ 在 $i$ 和 $j$ 之间独立，且与 $g_i$ 和 $\\beta_i$ 独立，\n- 所有基因型共享同一组温度 $\\{T_j\\}_{j=1}^{J}$，其中 $J \\ge 3$。\n\n您的任务是，仅使用以下原理，从适用于线性模型和方差分解的第一性原理推导并实现一个斜率的基因型间方差 $\\sigma_\\beta^2$ 的估计量：\n- 在每个基因型内跨温度拟合直线的普通最小二乘 (OLS) 回归的基本性质，\n- 全期望定律和全方差定律，\n- 跨基因型的残差方差的无偏合并。\n\n推导一个矩估计量，该估计量通过校正由残差 $\\epsilon_{ij}$ 贡献的期望抽样方差，来修正估计斜率的基因型间样本方差。在一个程序中实现这个估计量，该程序：\n- 使用指定的参数和随机种子模拟模型下的数据集，\n- 对每个基因型，跨 $j$ 拟合一条 OLS 直线 $y_{ij} \\sim a_i + b_i T_j$，\n- 合并基因型内残差平方和以估计 $\\sigma_\\epsilon^2$，\n- 计算估计斜率 $\\{b_i\\}$ 的基因型间样本方差，\n- 减去期望抽样方差项，以获得 $\\sigma_\\beta^2$ 的估计量。\n\n需遵守的设计细节：\n- 在一个测试用例中，对所有基因型使用相同的温度向量。\n- 不要截断负估计值；报告无偏的矩估计值，该值在小样本中可能为负。\n- 最终输出应四舍五入到 $6$ 位小数。\n\n测试套件。对于以下每个参数集，模拟数据并返回 $\\sigma_\\beta^2$ 的估计值。为保证可复现性，请对每个用例使用给定的随机种子。每个用例指定元组 $(\\text{seed}, N, \\mu, \\sigma_g, \\sigma_\\beta, \\sigma_\\epsilon, \\mathbf T)$，其中 $N$ 是基因型数量，$\\mathbf T$ 是所有基因型共享的温度列表。\n\n- 用例 1: $(12345, 80, 1.0, 0.5, 0.2, 0.3, [-1.0, 0.0, 1.0])$。\n- 用例 2: $(24680, 60, 0.0, 1.0, 0.0, 0.2, [-1.0, 0.0, 1.0, 2.0])$。\n- 用例 3: $(777, 5, 0.5, 0.2, 0.5, 1.0, [-1.0, 0.0, 1.0])$。\n- 用例 4: $(424242, 200, 0.0, 0.5, 0.05, 1.5, [-1.0, 0.0, 1.0])$。\n- 用例 5: $(2023, 100, 2.0, 0.2, 0.1, 0.5, [0.0, 10.0, 20.0, 30.0])$。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果顺序与上述用例相同，每个值四舍五入到 $6$ 位小数（例如，$[0.123456,0.000000,0.500000]$）。不应打印任何其他文本。\n\n约束条件：\n- 仅使用指定的原理实现估计量，不要调用任何黑盒混合模型求解器。\n- 使用 Python 编程语言，且仅使用允许的库。\n- 此任务无需报告物理单位；将所有量视为无单位实数。",
            "solution": "所提出的问题是数量遗传学和统计学中的一个标准问题，具体涉及随机回归混合效应模型的方差分量估计。该问题具有科学依据、定义明确，并且为解决它提供了所有必要的参数和条件。这是一个有效的问题。我们将从第一性原理出发，推导该估计量。\n\n基因型 $i$ 在温度 $j$ 的表型 $y_{ij}$ 的模型由下式给出：\n$$\ny_{ij} = \\mu + g_i + \\beta_i T_j + \\epsilon_{ij}\n$$\n参数和随机变量定义如下：\n- $\\mu$ 是总体平均表型。\n- $g_i$ 是基因型 $i$ 的随机效应，其中 $g_i \\sim \\mathcal{N}(0, \\sigma_g^2)$。\n- $\\beta_i$ 是基因型 $i$ 的随机斜率，代表基因型与环境的交互作用，其中 $\\beta_i \\sim \\mathcal{N}(0, \\sigma_\\beta^2)$。\n- $T_j$ 是第 $j$ 次测量时环境变量（温度）的值。\n- $\\epsilon_{ij}$ 是残差项，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma_\\epsilon^2)$。\n所有随机效应 $g_i$、$\\beta_i$ 和 $\\epsilon_{ij}$ 均假定为相互独立的。\n\n我们的目标是推导斜率方差 $\\sigma_\\beta^2$ 的矩估计量。该策略包括两个阶段。首先，对于每个基因型 $i$，我们对其在所有温度范围内的表型数据拟合一个简单线性回归模型。其次，我们分析第一阶段估计出的斜率的分布，以估计 $\\sigma_\\beta^2$。\n\n**步骤1：基因型内 OLS 回归**\n\n对于单个固定的基因型 $i$，$g_i$ 和 $\\beta_i$ 的真实值是常数。我们可以定义一个基因型特异性截距 $\\alpha_i = \\mu + g_i$。基因型 $i$ 的模型变为：\n$$\ny_{ij} = \\alpha_i + \\beta_i T_j + \\epsilon_{ij}\n$$\n这是一个标准的简单线性回归模型。我们对每个基因型 $i$ 的数据点 $\\{(T_j, y_{ij})\\}_{j=1}^J$ 拟合一条 OLS 直线，其估计方程表示为 $\\hat{y}_{ij} = a_i + b_i T_j$。\n\n斜率的 OLS 估计量 $b_i$ 由以下公式给出：\n$$\nb_i = \\frac{\\sum_{j=1}^{J} (T_j - \\bar{T})(y_{ij} - \\bar{y}_i)}{\\sum_{j=1}^{J} (T_j - \\bar{T})^2}\n$$\n其中 $\\bar{T} = \\frac{1}{J}\\sum_{j=1}^J T_j$。令 $S_{TT} = \\sum_{j=1}^{J} (T_j - \\bar{T})^2$。由于所有基因型共享相同的温度向量 $\\mathbf{T}$，这个量对于所有基因型都是常数。\n\n为了理解 $b_i$ 的性质，我们代入 $y_{ij}$ 的模型：\n$$\nb_i = \\frac{\\sum_{j=1}^{J} (T_j - \\bar{T})(\\alpha_i + \\beta_i T_j + \\epsilon_{ij} - (\\alpha_i + \\beta_i \\bar{T} + \\bar{\\epsilon}_i))}{S_{TT}}\n$$\n其中 $\\bar{\\epsilon}_i = \\frac{1}{J}\\sum_{j=1}^J \\epsilon_{ij}$。截距项 $\\alpha_i$ 被消去。我们剩下：\n$$\nb_i = \\frac{\\beta_i \\sum_{j=1}^{J} (T_j - \\bar{T})(T_j - \\bar{T}) + \\sum_{j=1}^{J} (T_j - \\bar{T})(\\epsilon_{ij} - \\bar{\\epsilon}_i)}{S_{TT}}\n$$\n$$\nb_i = \\frac{\\beta_i \\sum_{j=1}^{J} (T_j - \\bar{T})^2 + \\sum_{j=1}^{J} (T_j - \\bar{T})\\epsilon_{ij}}{S_{TT}} = \\beta_i + \\frac{\\sum_{j=1}^{J} (T_j - \\bar{T})\\epsilon_{ij}}{S_{TT}}\n$$\n这个表达式表明，估计的斜率 $b_i$ 是真实斜率 $\\beta_i$ 与一个依赖于残差 $\\epsilon_{ij}$ 的误差项之和。\n\n**步骤2：使用全方差定律分析估计斜率**\n\n现在我们将 $b_i$ 视为一个随机变量，其随机性既来自基因型的抽样（即 $\\beta_i$ 的随机性），也来自残差（$\\epsilon_{ij}$ 的随机性）。我们使用全方差定律，即 $\\text{Var}(X) = E[\\text{Var}(X|Y)] + \\text{Var}(E[X|Y])$。让我们将其应用于 $b_i$，以真实斜率 $\\beta_i$ 为条件。\n\n首先，我们计算给定 $\\beta_i$ 时 $b_i$ 的条件期望和条件方差：\n条件期望是：\n$$\nE[b_i | \\beta_i] = E\\left[\\beta_i + \\frac{\\sum_{j=1}^{J} (T_j - \\bar{T})\\epsilon_{ij}}{S_{TT}} \\ \\Bigg| \\ \\beta_i \\right] = \\beta_i + \\frac{\\sum_{j=1}^{J} (T_j - \\bar{T})E[\\epsilon_{ij}]}{S_{TT}} = \\beta_i\n$$\n因为 $E[\\epsilon_{ij}] = 0$。这表明 $b_i$ 是 $\\beta_i$ 的一个条件无偏估计量。\n\n条件方差，即斜率估计的抽样方差，是：\n$$\n\\text{Var}(b_i | \\beta_i) = \\text{Var}\\left(\\frac{\\sum_{j=1}^{J} (T_j - \\bar{T})\\epsilon_{ij}}{S_{TT}} \\ \\Bigg| \\ \\beta_i \\right)\n$$\n由于 $\\epsilon_{ij}$ 项的独立性，这变为：\n$$\n\\text{Var}(b_i | \\beta_i) = \\frac{1}{S_{TT}^2} \\sum_{j=1}^{J} (T_j - \\bar{T})^2 \\text{Var}(\\epsilon_{ij}) = \\frac{1}{S_{TT}^2} S_{TT} \\sigma_\\epsilon^2 = \\frac{\\sigma_\\epsilon^2}{S_{TT}}\n$$\n这是对于一个固定基因型，由于残差 $\\epsilon_{ij}$ 导致的估计斜率 $b_i$ 的方差。\n\n现在，我们应用全方差定律来求 $b_i$ 在所有基因型中的总方差：\n$$\n\\text{Var}(b_i) = E[\\text{Var}(b_i | \\beta_i)] + \\text{Var}(E[b_i | \\beta_i])\n$$\n代入我们推导的表达式：\n$$\nE[\\text{Var}(b_i | \\beta_i)] = E\\left[\\frac{\\sigma_\\epsilon^2}{S_{TT}}\\right] = \\frac{\\sigma_\\epsilon^2}{S_{TT}}\n$$\n$$\n\\text{Var}(E[b_i | \\beta_i]) = \\text{Var}(\\beta_i) = \\sigma_\\beta^2\n$$\n因此，估计斜率的总方差是斜率的真实生物学方差与平均抽样方差之和：\n$$\n\\text{Var}(b_i) = \\sigma_\\beta^2 + \\frac{\\sigma_\\epsilon^2}{S_{TT}}\n$$\n\n**步骤3：构建矩估计量**\n\n这个方程为估计 $\\sigma_\\beta^2$ 提供了一条清晰的路径。我们可以将其重新排列为：\n$$\n\\sigma_\\beta^2 = \\text{Var}(b_i) - \\frac{\\sigma_\\epsilon^2}{S_{TT}}\n$$\n我们通过代入右侧各项的估计量来构造 $\\sigma_\\beta^2$ 的估计量。\n\n1.  **$\\text{Var}(b_i)$ 的估计量**：给定一个包含 $N$ 个估计斜率的样本 $\\{b_1, b_2, \\dots, b_N\\}$，其方差的自然无偏估计量是样本方差：\n    $$\n    \\widehat{\\text{Var}(b_i)} = S_b^2 = \\frac{1}{N-1} \\sum_{i=1}^N (b_i - \\bar{b})^2, \\quad \\text{其中} \\quad \\bar{b} = \\frac{1}{N}\\sum_{i=1}^N b_i\n    $$\n\n2.  **$\\sigma_\\epsilon^2$ 的估计量**：问题要求我们合并残差方差。对于每个基因型 $i$，$\\sigma_\\epsilon^2$ 的一个无偏估计是其 OLS 拟合的均方误差，$\\hat{\\sigma}_{\\epsilon,i}^2 = \\text{RSS}_i / (J-2)$，其中 $\\text{RSS}_i = \\sum_{j=1}^J (y_{ij} - (a_i + b_i T_j))^2$ 是残差平方和，$J-2$ 代表自由度。为了获得一个更精确的单一估计，我们跨所有 $N$ 个基因型进行合并：\n    $$\n    \\hat{\\sigma}_\\epsilon^2 = \\frac{\\sum_{i=1}^N \\text{RSS}_i}{\\sum_{i=1}^N (J-2)} = \\frac{\\sum_{i=1}^N \\text{RSS}_i}{N(J-2)}\n    $$\n    这个合并估计量是 $\\sigma_\\epsilon^2$ 的无偏估计。\n\n结合这些部分，我们对 $\\sigma_\\beta^2$ 的矩估计量是：\n$$\n\\hat{\\sigma}_\\beta^2 = S_b^2 - \\frac{\\hat{\\sigma}_\\epsilon^2}{S_{TT}}\n$$\n这个估计量是无偏的，因为 $E[S_b^2] = \\text{Var}(b_i)$ 且 $E[\\hat{\\sigma}_\\epsilon^2] = \\sigma_\\epsilon^2$。在有限样本中，特别是当真实的 $\\sigma_\\beta^2$ 很小或 $N$ 很低时，由于抽样误差，这个估计值可能为负。根据问题说明，这种负值将不被截断。\n\n实现的算法如下：\n1.  对每个测试用例，提取参数 $N, \\mu, \\sigma_g, \\sigma_\\beta, \\sigma_\\epsilon$ 和温度向量 $\\mathbf{T}$。\n2.  设置随机种子以保证可复现性。\n3.  模拟数据：生成 $N$ 个 $g_i \\sim \\mathcal{N}(0, \\sigma_g^2)$ 值，$N$ 个 $\\beta_i \\sim \\mathcal{N}(0, \\sigma_\\beta^2)$ 值，以及 $N \\times J$ 个 $\\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma_\\epsilon^2)$ 值，以构建 $y_{ij}$ 矩阵。\n4.  计算 $S_{TT} = \\sum_{j=1}^J (T_j - \\bar{T})^2$。\n5.  初始化一个用于存放斜率的空列表 `b_list` 和一个变量 `total_rss = 0.0`。\n6.  从 $1$ 到 $N$ 遍历每个基因型 $i$：\n    a. 对 $y_{i\\cdot}$ 关于 $\\mathbf{T}$ 进行 OLS 回归，得到估计的斜率 $b_i$ 和截距 $a_i$。\n    b. 将 $b_i$ 附加到 `b_list` 中。\n    c. 计算残差平方和 $\\text{RSS}_i = \\sum_j (y_{ij} - (a_i + b_i T_j))^2$。\n    d. 将 $\\text{RSS}_i$ 加到 `total_rss` 中。\n7.  计算收集到的斜率的样本方差，$S_b^2 = \\text{Var}(\\text{b\\_list})$。\n8.  计算残差方差的合并估计，$\\hat{\\sigma}_\\epsilon^2 = \\text{total\\_rss} / (N(J-2))$。\n9.  计算最终估计值：$\\hat{\\sigma}_\\beta^2 = S_b^2 - \\hat{\\sigma}_\\epsilon^2 / S_{TT}$。\n10. 存储四舍五入后的结果，并对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations and estimate the variance of slopes.\n    \"\"\"\n    test_cases = [\n        # (seed, N, mu, sigma_g, sigma_beta, sigma_epsilon, T)\n        (12345, 80, 1.0, 0.5, 0.2, 0.3, [-1.0, 0.0, 1.0]),\n        (24680, 60, 0.0, 1.0, 0.0, 0.2, [-1.0, 0.0, 1.0, 2.0]),\n        (777, 5, 0.5, 0.2, 0.5, 1.0, [-1.0, 0.0, 1.0]),\n        (424242, 200, 0.0, 0.5, 0.05, 1.5, [-1.0, 0.0, 1.0]),\n        (2023, 100, 2.0, 0.2, 0.1, 0.5, [0.0, 10.0, 20.0, 30.0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        seed, N, mu, sigma_g, sigma_beta, sigma_epsilon, T_list = case\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Convert temperature list to a numpy array for vectorized operations\n        T = np.array(T_list)\n        J = len(T)\n\n        # 1. Simulate data according to the model\n        # y_ij = mu + g_i + beta_i * T_j + epsilon_ij\n        \n        # Generate random effects for N genotypes\n        g = rng.normal(0, sigma_g, N)\n        beta = rng.normal(0, sigma_beta, N)\n\n        # Generate phenotype data for N genotypes across J temperatures\n        # Epsilon is a matrix of N rows (genotypes) and J columns (temperatures)\n        epsilon = rng.normal(0, sigma_epsilon, (N, J))\n        \n        # Use broadcasting to generate the phenotype matrix y (N x J)\n        # g[:, np.newaxis] reshapes g from (N,) to (N, 1)\n        # beta[:, np.newaxis] reshapes beta from (N,) to (N, 1)\n        # T is (J,)\n        # The expression beta[:, np.newaxis] * T creates a (N, J) matrix\n        y = mu + g[:, np.newaxis] + beta[:, np.newaxis] * T + epsilon\n\n        # 2. Perform OLS regression for each genotype and collect statistics\n        estimated_slopes = []\n        total_rss = 0.0\n\n        for i in range(N):\n            y_i = y[i, :]\n            \n            # Fit a line y = b*T + a. np.polyfit returns [slope, intercept]\n            # This is equivalent to OLS\n            slope, intercept = np.polyfit(T, y_i, 1)\n            estimated_slopes.append(slope)\n            \n            # Calculate predicted values and residuals\n            y_pred = slope * T + intercept\n            residuals = y_i - y_pred\n            \n            # Calculate Residual Sum of Squares (RSS) for this genotype\n            rss_i = np.sum(residuals**2)\n            total_rss += rss_i\n\n        # 3. Calculate components for the estimator of sigma_beta^2\n        \n        # Calculate S_TT = sum((T_j - T_bar)^2)\n        s_tt = np.sum((T - np.mean(T))**2)\n\n        # Calculate the sample variance of the estimated slopes (S_b^2).\n        # ddof=1 for unbiased sample variance (N-1 denominator).\n        s_b_sq = np.var(estimated_slopes, ddof=1)\n        \n        # Calculate the pooled unbiased estimate of residual variance (sigma_epsilon^2).\n        # Degrees of freedom for residuals is N * (J - 2).\n        # J >= 3 is a prerequisite, checked by inspection of test cases.\n        degrees_of_freedom = N * (J - 2)\n        sigma_epsilon_sq_hat = total_rss / degrees_of_freedom\n        \n        # 4. Compute the final estimate for sigma_beta^2\n        # sigma_beta^2_hat = S_b^2 - (sigma_epsilon^2_hat / S_TT)\n        sigma_beta_sq_hat = s_b_sq - (sigma_epsilon_sq_hat / s_tt)\n        \n        results.append(sigma_beta_sq_hat)\n\n    # Final print statement in the exact required format.\n    # We round the values here and then format to ensure 6 decimal places.\n    formatted_results = [f\"{round(r, 6):.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}