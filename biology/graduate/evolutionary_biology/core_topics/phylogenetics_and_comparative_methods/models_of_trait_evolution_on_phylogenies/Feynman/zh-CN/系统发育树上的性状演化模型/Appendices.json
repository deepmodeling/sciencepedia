{
    "hands_on_practices": [
        {
            "introduction": "布朗运动 (Brownian Motion, BM) 模型是系统发育比较方法中的一个基本出发点，它假设性状沿着系统发育树随机漂移。为了在考虑物种间亲缘关系的情况下检验性状间的相关性，系统发育独立比较 (Phylogenetic Independent Contrasts, PICs) 方法应运而生。本练习将引导你从第一性原理出发，推导并应用 PICs 的计算步骤，这是掌握系统发育信号分析和性状关联研究的核心技能。",
            "id": "2735174",
            "problem": "一个连续性状在一个已知的二叉系统发育树上，遵循速率参数为 $\\sigma^{2}$ 的布朗运动过程演化，使得在任何长度为 $t$ 的分支上，性状值的变化服从均值为 $0$、方差为 $\\sigma^{2} t$ 的正态分布，并且在给定祖先状态的条件下，不同分支上的变化是相互独立的。系统发育独立比较 (Phylogenetic Independent Contrasts, PICs) 被定义为每个内部节点处后代性状值的线性组合，该组合 (i) 在布朗运动下均值为 $0$，(ii) 经过缩放以具有相同的期望方差，以及 (iii) 在不同节点间相互独立。从这些原则和多元正态分布的标准性质出发，通过以下步骤推导 PICs 的逐节点构建方法：\n- 从一个内部节点的两个直接后代获得其祖先状态的逆方差加权估计量，以及在系统发育树更高层级中使用的相关传播方差，\n- 展示一个节点的比较值是如何由其两个后代的值及其相关方差形成的，包括后代分支长度的作用。\n\n然后将你的推导应用于以下具有 $4$ 个叶尖的有根系统发育树：\n- 叶尖 $A$ 和 $B$ 在节点 $N_{1}$ 处连接；分支长度分别为 $A$–$N_{1}$ 长 $0.5$，$B$–$N_{1}$ 长 $0.25$。从 $N_{1}$ 到根节点 $R$ 的分支长度为 $0.25$。\n- 叶尖 $C$ 和 $D$ 在节点 $N_{2}$ 处连接；分支长度分别为 $C$–$N_{2}$ 长 $0.5$，$D$–$N_{2}$ 长 $0.25$。从 $N_{2}$ 到根节点 $R$ 的分支长度为 $0.5$。\n- 根节点 $R$ 仅连接到 $N_{1}$ 和 $N_{2}$（$R$ 之上没有分支）。\n\n观测到的叶尖性状值为 $x_{A}=1$，$x_{B}=4$，$x_{C}=2$ 和 $x_{D}=5$。使用你推导出的布朗运动下 PICs 的递归、分支长度加权构建方法，计算在根节点 $R$ 处由其两个直接后代 $N_{1}$ 和 $N_{2}$ 形成的标准化比较值。对于数值计算，取 $\\sigma^{2}=1$。将你的最终数值答案四舍五入到四位有效数字。不要包含单位。",
            "solution": "该问题是有效的，因为它科学地基于性状在布朗运动下演化的既定理论和系统发育独立比较 (PICs) 方法。该问题设定良好、客观，并为获得唯一解提供了所有必要信息。\n\n首先，我们推导在布朗运动 (BM) 模型下逐节点构建 PICs 的通用公式。设一个内部节点 $k$ 有两个直接后代 $i$ 和 $j$，其性状值分别为 $X_i$ 和 $X_j$。节点 $k$ 的祖先状态为 $X_k$。从 $k$ 到 $i$ 和 $j$ 的分支长度分别为 $v_i$ 和 $v_j$。在布朗运动下，性状值之间的关系为：\n$$X_i = X_k + \\epsilon_i, \\quad \\text{其中} \\quad \\epsilon_i \\sim N(0, \\sigma^2 v_i)$$\n$$X_j = X_k + \\epsilon_j, \\quad \\text{其中} \\quad \\epsilon_j \\sim N(0, \\sigma^2 v_j)$$\n随机变量 $\\epsilon_i$ 和 $\\epsilon_j$ 代表沿两个分支的独立演化变化。\n\n祖先状态 $X_k$ 的最佳线性无偏估计量 (BLUE)，在此高斯情境下等同于最大似然估计 (MLE)，是后代状态的逆方差加权平均值。从 $X_k$ 到 $X_i$ 的变化的方差是 $\\sigma^2 v_i$，因此 $X_i$ 的权重与 $1/v_i$ 成正比。$X_k$ 的估计量 $\\hat{X}_k$ 为：\n$$\\hat{X}_k = \\frac{\\frac{1}{\\sigma^2 v_i} X_i + \\frac{1}{\\sigma^2 v_j} X_j}{\\frac{1}{\\sigma^2 v_i} + \\frac{1}{\\sigma^2 v_j}} = \\frac{\\frac{X_i}{v_i} + \\frac{X_j}{v_j}}{\\frac{1}{v_i} + \\frac{1}{v_j}} = \\frac{v_j X_i + v_i X_j}{v_i + v_j}$$\n\n一个标准化的比较值 $C_k$，是 $X_i$ 和 $X_j$ 的线性组合，其期望值为 $0$ 且方差为常数。设 $C_k = a_1 X_i + a_2 X_j$。\n为使期望值为 $0$, $E[C_k] = E[a_1 X_i + a_2 X_j] = (a_1+a_2) E[X_k] = 0$。这要求 $a_1 + a_2 = 0$，因此 $a_2 = -a_1$。比较值必须是 $C_k = a_1(X_i - X_j)$ 的形式。\n该比较值的方差为：\n$$Var(C_k) = a_1^2 Var(X_i - X_j) = a_1^2 Var((X_k + \\epsilon_i) - (X_k + \\epsilon_j)) = a_1^2 Var(\\epsilon_i - \\epsilon_j)$$\n由于 $\\epsilon_i$ 和 $\\epsilon_j$ 是独立的：\n$$Var(C_k) = a_1^2 (Var(\\epsilon_i) + Var(\\epsilon_j)) = a_1^2 (\\sigma^2 v_i + \\sigma^2 v_j) = a_1^2 \\sigma^2 (v_i + v_j)$$\n为了将此方差标准化为 $\\sigma^2$，我们设 $a_1^2 \\sigma^2 (v_i + v_j) = \\sigma^2$，这得到 $a_1 = 1/\\sqrt{v_i + v_j}$。因此，标准化的比较值为：\n$$C_k = \\frac{X_i - X_j}{\\sqrt{v_i + v_j}}$$\n\n为了使不同节点间的比较值相互独立，比较值 $C_k$ 必须与向树的更高层级传递的估计祖先状态 $\\hat{X}_k$ 统计独立。我们通过证明它们的协方差为零来验证这一点。使用基于 $X_k$ 条件下的独立误差项 $\\epsilon_i$ 和 $\\epsilon_j$ 的表达式：\n$$C_k = \\frac{\\epsilon_i - \\epsilon_j}{\\sqrt{v_i + v_j}}$$\n$$\\hat{X}_k - X_k = \\frac{v_j \\epsilon_i + v_i \\epsilon_j}{v_i + v_j}$$\n$$Cov(C_k, \\hat{X}_k - X_k) = \\frac{1}{\\sqrt{v_i+v_j}(v_i+v_j)} Cov(\\epsilon_i - \\epsilon_j, v_j \\epsilon_i + v_i \\epsilon_j)$$\n$$= \\frac{1}{(\\cdot)} [v_j Var(\\epsilon_i) - v_i Var(\\epsilon_j)] = \\frac{1}{(\\cdot)} [v_j(\\sigma^2 v_i) - v_i(\\sigma^2 v_j)] = 0$$\n由于它们是正态变量的线性组合，零协方差意味着独立性。\n\n最后，对于递归算法，我们将值为 $\\hat{X}_k$ 的估计节点 $k$ 视为一个新的叶尖。通向这个新叶尖的分支必须进行调整。设从 $k$ 的父节点（节点 $p$）到 $k$ 的原始分支长度为 $v_{kp}$。$\\hat{X}_k$ 相对于其父节点状态 $X_p$ 的方差定义了新的有效分支长度。\n$$Var(\\hat{X}_k - X_p) = Var(\\hat{X}_k - X_k + X_k - X_p) = Var(\\hat{X}_k - X_k) + Var(X_k - X_p)$$\n这两项是独立的。我们有 $Var(X_k - X_p) = \\sigma^2 v_{kp}$。估计误差的方差是：\n$$Var(\\hat{X}_k - X_k) = Var\\left(\\frac{v_j \\epsilon_i + v_i \\epsilon_j}{v_i + v_j}\\right) = \\frac{v_j^2 Var(\\epsilon_i) + v_i^2 Var(\\epsilon_j)}{(v_i + v_j)^2} = \\frac{v_j^2 \\sigma^2 v_i + v_i^2 \\sigma^2 v_j}{(v_i + v_j)^2} = \\frac{\\sigma^2 v_i v_j (v_i + v_j)}{(v_i + v_j)^2} = \\sigma^2 \\frac{v_i v_j}{v_i + v_j}$$\n所以，$Var(\\hat{X}_k - X_p) = \\sigma^2 v_{kp} + \\sigma^2 \\frac{v_i v_j}{v_i + v_j} = \\sigma^2 \\left(v_{kp} + \\frac{v_i v_j}{v_i + v_j}\\right)$。\n从 $p$ 到 $k$ 的新分支长度，记为 $v'_{kp}$，变为 $v_{kp} + \\frac{v_i v_j}{v_i + v_j}$。项 $\\frac{v_i v_j}{v_i + v_j}$ 代表了由估计产生的传播误差，并被转换成等效的分支长度。\n\n现在我们将此算法应用于给定的系统发育树，其中 $\\sigma^2=1$。\n树的结构是：$((A:0.5, B:0.25)N_1:0.25, (C:0.5, D:0.25)N_2:0.5)R$。\n叶尖值为 $x_A=1$, $x_B=4$, $x_C=2$, $x_D=5$。\n\n步骤 1：处理节点 $N_1$（A, B 的祖先）。\n- 分支长度：$v_A=0.5$, $v_B=0.25$。\n- $N_1$ 处的估计状态：\n$$\\hat{x}_{N_1} = \\frac{x_A/v_A + x_B/v_B}{1/v_A + 1/v_B} = \\frac{1/0.5 + 4/0.25}{1/0.5 + 1/0.25} = \\frac{2 + 16}{2 + 4} = \\frac{18}{6} = 3$$\n- 从根节点 $R$ 到 $N_1$ 的分支长度为 $v_{N_1} = 0.25$。更新后的长度 $v'_{N_1}$ 是：\n$$v'_{N_1} = v_{N_1} + \\frac{v_A v_B}{v_A + v_B} = 0.25 + \\frac{0.5 \\times 0.25}{0.5 + 0.25} = \\frac{1}{4} + \\frac{0.125}{0.75} = \\frac{1}{4} + \\frac{1}{6} = \\frac{3+2}{12} = \\frac{5}{12}$$\n\n步骤 2：处理节点 $N_2$（C, D 的祖先）。\n- 分支长度：$v_C=0.5$, $v_D=0.25$。\n- $N_2$ 处的估计状态：\n$$\\hat{x}_{N_2} = \\frac{x_C/v_C + x_D/v_D}{1/v_C + 1/v_D} = \\frac{2/0.5 + 5/0.25}{1/0.5 + 1/0.25} = \\frac{4 + 20}{2 + 4} = \\frac{24}{6} = 4$$\n- 从根节点 $R$ 到 $N_2$ 的分支长度为 $v_{N_2} = 0.5$。更新后的长度 $v'_{N_2}$ 是：\n$$v'_{N_2} = v_{N_2} + \\frac{v_C v_D}{v_C + v_D} = 0.5 + \\frac{0.5 \\times 0.25}{0.5 + 0.25} = \\frac{1}{2} + \\frac{1}{6} = \\frac{3+1}{6} = \\frac{4}{6} = \\frac{2}{3}$$\n\n步骤 3：处理根节点 $R$（$N_1$, $N_2$ 的祖先）。\n- 算法现在将 $N_1$ 和 $N_2$ 视为值为 $\\hat{x}_{N_1}=3$ 和 $\\hat{x}_{N_2}=4$ 的“叶尖”。\n- 从根节点到这些“叶尖”的分支长度为 $v'_{N_1} = 5/12$ 和 $v'_{N_2} = 2/3$。\n- 在根节点处的标准化比较值为：\n$$C_R = \\frac{\\hat{x}_{N_1} - \\hat{x}_{N_2}}{\\sqrt{v'_{N_1} + v'_{N_2}}}$$\n- 分支长度之和为：\n$$v'_{N_1} + v'_{N_2} = \\frac{5}{12} + \\frac{2}{3} = \\frac{5}{12} + \\frac{8}{12} = \\frac{13}{12}$$\n- 状态之差为 $\\hat{x}_{N_1} - \\hat{x}_{N_2} = 3 - 4 = -1$。\n- 在根节点处的比较值为：\n$$C_R = \\frac{-1}{\\sqrt{13/12}} = -\\sqrt{\\frac{12}{13}}$$\n数值上，这是 $C_R \\approx -0.9607689...$。四舍五入到四位有效数字得到 $-0.9608$。",
            "answer": "$$\\boxed{-0.9608}$$"
        },
        {
            "introduction": "与布朗运动模型不同，奥恩斯坦-乌伦贝克 (Ornstein-Uhlenbeck, OU) 模型引入了稳定选择的概念，即性状会趋向一个最优值 $\\theta$。然而，模型中的选择强度参数 $\\alpha$ 可能较为抽象。本练习通过推导“系统发育半衰期” ($t_{1/2}$) 这一概念，为你提供了一个理解 $\\alpha$ 的直观工具，它衡量了性状期望值回归到最优值一半所需的时间，是解释模型进化时间尺度的关键。",
            "id": "2735167",
            "problem": "在一个总高度为 $T = 12$ Myr 的超度量系统发育树的末端，测量了 $65$ 个物种的一个连续性状。该性状被建模为沿着该树根据Ornstein–Uhlenbeck (OU) 过程演化，该过程由以下随机微分方程 (SDE) 定义：\n$$\ndX_{t} = -\\alpha\\left(X_{t} - \\theta\\right) \\, dt + \\sigma \\, dB_{t},\n$$\n其中 $X_{t}$ 是时间 $t$ 时的性状值，$\\alpha$ 是朝向适应性最适值 $\\theta$ 的稳定选择强度，$\\sigma$ 是随机波动的强度，$B_{t}$ 是标准布朗运动。通过最大似然法将此模型拟合到末端数据，得到估计值 $\\hat{\\alpha} = 0.18$ Myr$^{-1}$。\n\n从上述 OU SDE 定义出发，并仅使用线性SDE解的期望的基本性质，推导系统发育半衰期 $t_{1/2}$ 的表达式，该半衰期定义为与最适值 $\\theta$ 的期望位移减小一半所需的时间。然后计算比率\n$$\nR \\equiv \\frac{t_{1/2}}{T}\n$$\n以评估在树的时间尺度上稳定选择的相对强度。\n\n仅报告 $R$ 的数值作为您的最终答案。将您的答案四舍五入到四位有效数字。最终答案应为无单位（无量纲）的。",
            "solution": "问题要求推导Ornstein–Uhlenbeck (OU) 过程的系统发育半衰期 $t_{1/2}$，并计算一个无量纲比率 $R$。分析必须从定义OU过程的随机微分方程 (SDE) 中所体现的基本原理开始。\n\n给定的SDE是：\n$$\ndX_{t} = -\\alpha(X_{t} - \\theta) \\, dt + \\sigma \\, dB_{t}\n$$\n这里，$X_t$是性状值，$\\alpha > 0$是选择强度，$\\theta$是最适值，$\\sigma$是随机噪声的幅度，$B_t$是标准布朗运动。\n\n为了找到期望轨迹，我们将与最适值的位移定义为 $Y_{t} = X_{t} - \\theta$。由于 $\\theta$ 是一个常数参数，$Y_t$ 的微分是 $dY_t = dX_t$。将此代入原始SDE，得到位移过程的方程：\n$$\ndY_{t} = -\\alpha Y_{t} \\, dt + \\sigma \\, dB_{t}\n$$\n我们关心的是该位移的期望值。我们对整个方程取期望。利用期望算子的线性性质，我们得到：\n$$\nE[dY_{t}] = E[-\\alpha Y_{t} \\, dt + \\sigma \\, dB_{t}] = -\\alpha E[Y_{t}] \\, dt + \\sigma E[dB_{t}]\n$$\n在标准正则性条件下，微分的期望等于期望的微分，即 $E[dY_{t}] = dE[Y_{t}]$。标准布朗运动过程（它模拟了随机游走的极限）的一个基本性质是其增量的期望为零。即 $E[dB_{t}] = 0$。这将平均位移的方程简化为一阶线性齐次常微分方程 (ODE)：\n$$\ndE[Y_{t}] = -\\alpha E[Y_{t}] \\, dt\n$$\n让我们用 $\\mu(t) = E[Y_t]$ 表示期望位移。那么该ODE为：\n$$\n\\frac{d\\mu(t)}{dt} = -\\alpha \\mu(t)\n$$\n这个ODE可以通过分离变量法求解。假设在时间 $t=0$ 时的初始期望位移为 $\\mu(0)$：\n$$\n\\int_{\\mu(0)}^{\\mu(t)} \\frac{1}{u} \\, du = \\int_{0}^{t} -\\alpha \\, ds\n$$\n$$\n[\\ln|u|]_{\\mu(0)}^{\\mu(t)} = [-\\alpha s]_{0}^{t}\n$$\n$$\n\\ln|\\mu(t)| - \\ln|\\mu(0)| = -\\alpha t\n$$\n$$\n\\ln\\left(\\frac{|\\mu(t)|}{|\\mu(0)|}\\right) = -\\alpha t\n$$\n对两边取指数，得到时间 $t$ 时期望位移的解：\n$$\n\\mu(t) = \\mu(0) \\exp(-\\alpha t)\n$$\n用原始过程变量 $X_t$ 表示，即为：\n$$\nE[X_{t} - \\theta] = E[X_{0} - \\theta] \\exp(-\\alpha t)\n$$\n这个方程表明，与最适值的期望位移随时间呈指数衰减。\n\n系统发育半衰期 $t_{1/2}$ 定义为与最适值的期望位移减小一半所需的时间。因此，我们设 $\\mu(t_{1/2}) = \\frac{1}{2} \\mu(0)$：\n$$\n\\frac{1}{2} \\mu(0) = \\mu(0) \\exp(-\\alpha t_{1/2})\n$$\n假设初始期望位移非零，即 $\\mu(0) \\neq 0$，我们可以除以 $\\mu(0)$：\n$$\n\\frac{1}{2} = \\exp(-\\alpha t_{1/2})\n$$\n为了解出 $t_{1/2}$，我们对两边取自然对数：\n$$\n\\ln\\left(\\frac{1}{2}\\right) = -\\alpha t_{1/2}\n$$\n$$\n-\\ln(2) = -\\alpha t_{1/2}\n$$\n这就给出了半衰期的解析表达式：\n$$\nt_{1/2} = \\frac{\\ln(2)}{\\alpha}\n$$\n问题要求计算比率 $R = \\frac{t_{1/2}}{T}$，其中 $T$ 是系统发育树的总高度。我们代入 $t_{1/2}$ 的表达式：\n$$\nR = \\frac{\\ln(2)}{\\alpha T}\n$$\n我们已知估计参数 $\\hat{\\alpha} = 0.18$ Myr$^{-1}$ 和树高 $T = 12$ Myr。使用 $\\hat{\\alpha}$ 代替 $\\alpha$，我们计算 $R$ 的数值：\n$$\nR = \\frac{\\ln(2)}{(0.18 \\text{ Myr}^{-1})(12 \\text{ Myr})} = \\frac{\\ln(2)}{2.16}\n$$\n单位 Myr$^{-1}$ 和 Myr 相互抵消，得到所要求的无量纲比率。计算过程如下：\n$$\nR \\approx \\frac{0.69314718}{2.16} \\approx 0.32090147\n$$\n将此值四舍五入到四位有效数字，得到 $0.3209$。",
            "answer": "$$\\boxed{0.3209}$$"
        },
        {
            "introduction": "将理论模型付诸实践是检验和加深理解的最佳方式。本综合练习旨在指导你从头开始编写一个程序，以模拟在系统发育树上遵循奥恩斯坦-乌伦贝克 (OU) 过程的连续性状演化，其中也包含了布朗运动作为其特殊情况 ($\\alpha \\to 0$)。通过从模型的随机微分方程出发，推导并实现模拟算法，你将巩固对性状演化模型核心机制的理论和实践知识。",
            "id": "2735150",
            "problem": "设计一个程序，该程序在奥恩斯坦-乌伦贝克 (OU) 过程下，模拟一个连续性状沿有根有向系统发育树的分支进行演化。从奥恩斯坦-乌伦贝克过程的基本定义出发，该过程是由标准布朗运动驱动的线性随机微分方程的解。具体来说，使用随机微分方程\n$$\ndX_t = \\alpha \\left(\\theta - X_t\\right)\\,dt + \\sigma\\, dB_t,\n$$\n其中 $X_t$ 是时间 $t$ 时的性状值，$B_t$ 是标准布朗运动，$\\alpha \\ge 0$ 是朝向最适值 $\\theta \\in \\mathbb{R}$ 的稳定性选择强度，$\\sigma \\ge 0$ 是扩散系数。假设一个分支在时间 $0$ 从父节点开始，其值为 $X_0 = x_{\\text{parent}}$，并在时间 $t > 0$ 结束于子节点。\n\n任务 1 (推导): 从上述随机微分方程和伊藤积分的标准结果出发，推导在给定 $X_0 = x_{\\text{parent}}$ 的条件下，$X_t$ 对于任意 $t \\ge 0$ 的条件分布。提供条件均值和条件方差的显式表达式，它们是 $t$、$\\alpha$、$\\sigma$、$\\theta$ 和 $x_{\\text{parent}}$ 的函数。然后，推导当 $\\alpha \\to 0$ 时的连续时间极限，并证明它如何简化为沿分支的布朗运动。你的推导必须证明为什么线性解中的伊藤积分均值为零，并使用伊藤等距计算其方差。\n\n任务 2 (算法设计): 使用任务1中得到的条件分布作为沿分支的转移核，设计一个用于有根树的模拟程序：\n- 树以有向边列表 $(p, c, \\ell)$ 的形式给出，其中 $p$ 是父节点索引，$c$ 是子节点索引，$\\ell \\ge 0$ 是分支长度（从 $p$ 到 $c$ 的时间）。根节点索引及其初始性状值 $x_{\\text{root}}$ 也被提供。\n- 从根节点开始，以任何有效的拓扑顺序遍历树，模拟每个节点上的性状值。对于每条边，使用其父节点的性状值作为条件值，从任务1中推导的条件分布中抽取子节点的值。当 $\\alpha = 0$ 时，使用你推导出的布朗运动极限以避免除以零。当 $\\ell = 0$ 时，证明子节点必须几乎必然等于父节点。\n- 为确保在 $\\alpha$ 非常小且 $\\ell > 0$ 时的数值稳定性，你必须将低于一个很小阈值的 $\\alpha$ 视为零，并退回到布朗运动极限。选择一个适合双精度算术的阈值，并在你的解决方案中证明其合理性。\n\n任务 3 (实现与输出): 在一个程序中实现该模拟，该程序使用一个伪随机数生成器，并为每个测试用例独立设定种子。对于每个分支的转移，抽取一个独立的标准正态变量来构建具有适当方差的正态增量。对于每个测试用例，输出所有尖端（叶）节点的模拟性状值，按节点索引升序排列。将每个报告的浮点数结果四舍五入到小数点后六位。\n\n测试套件:\n使用以下四个测试用例。对于每个测试用例，程序必须将伪随机数生成器重新初始化为指定的种子，模拟树的演化，并按所述收集尖端值。\n\n- 测试用例 1 (单分支，通用 OU):\n  - 参数: $\\alpha = 0.5$, $\\sigma = 1.2$, $\\theta = 2.0$, $x_{\\text{root}} = 0.0$。\n  - 树: 边 $[(0,1,1.0)]$，根节点 $0$。\n  - 种子: $7$。\n  - 此用例的输出: 节点 $1$ 处的单个尖端值，为浮点数，四舍五入到小数点后六位。\n\n- 测试用例 2 (零长度分支，退化检查):\n  - 参数: $\\alpha = 0.7$, $\\sigma = 2.0$, $\\theta = 10.0$, $x_{\\text{root}} = 1.23$。\n  - 树: 边 $[(0,1,0.0)]$，根节点 $0$。\n  - 种子: $11$。\n  - 此用例的输出: 节点 $1$ 处的单个尖端值，为浮点数，四舍五入到小数点后六位。\n\n- 测试用例 3 (小型分叉树，多尖端 OU):\n  - 参数: $\\alpha = 2.0$, $\\sigma = 0.8$, $\\theta = -1.0$, $x_{\\text{root}} = 3.0$。\n  - 树: 边 $[(0,1,0.5),(1,3,0.3),(0,2,0.7),(2,4,0.2)]$，根节点 $0$。\n  - 种子: $13$。\n  - 此用例的输出: 一个包含节点 $[3,4]$ 处两个尖端值的列表，按升序排列，每个值都四舍五入到小数点后六位。\n\n- 测试用例 4 (布朗运动极限，$\\alpha = 0$):\n  - 参数: $\\alpha = 0.0$, $\\sigma = 1.5$, $\\theta = 0.0$, $x_{\\text{root}} = -0.5$。\n  - 树: 边 $[(0,1,0.4),(1,2,0.6)]$，根节点 $0$。\n  - 种子: $17$。\n  - 此用例的输出: 节点 $2$ 处的单个尖端值，为浮点数，四舍五入到小数点后六位。\n\n最终输出格式:\n你的程序应生成单行输出，其中包含四个测试用例的结果，结果为一个逗号分隔的列表，并用方括号括起来。条目必须按照上述测试用例的顺序出现。对于有多个尖端的用例，将其结果报告为一个列表。例如，输出必须类似于\n[float_case1,float_case2,[float_tip3,float_tip4],float_case4]\n其中每个浮点数都四舍五入到小数点后六位，并且不打印任何额外文本。",
            "solution": "问题陈述已经过审查，并被确定为有效。它在科学上是合理的，数学上是适定的，并为一个计算演化生物学中的标准模拟任务提供了完整而明确的规范。因此，我们可以着手解决。\n\n本任务是为奥恩斯坦-乌伦贝克 (OU) 过程推导转移概率核，然后应用它来模拟系统发育树上的性状演化。按照要求，解决方案分为三部分呈现：数学推导、算法设计和实现说明。\n\n### 任务1：条件分布的推导\n\n我们给定奥恩斯坦-乌伦贝克随机微分方程 (SDE)：\n$$\ndX_t = \\alpha (\\theta - X_t) dt + \\sigma dB_t\n$$\n其中 $X_t$ 是时间 $t$ 时的性状值，$\\alpha \\ge 0$ 是选择强度，$\\theta \\in \\mathbb{R}$ 是最适性状值，$\\sigma \\ge 0$ 是扩散速率，$B_t$ 是标准维纳过程（布朗运动）。我们给定的初始条件是 $X_0 = x_{\\text{parent}}$。\n\n为了解这个线性SDE，我们将其重新排列为标准形式：\n$$\ndX_t + \\alpha X_t dt = \\alpha \\theta dt + \\sigma dB_t\n$$\n我们采用积分因子的方法。设积分因子为 $I_t = e^{\\int \\alpha \\,ds} = e^{\\alpha t}$。我们定义一个新过程 $Y_t = X_t I_t = X_t e^{\\alpha t}$。根据伊藤乘积法则，微分 $dY_t$ 为：\n$$\ndY_t = d(X_t e^{\\alpha t}) = (\\alpha X_t e^{\\alpha t}) dt + e^{\\alpha t} dX_t\n$$\n注意，涉及 $(dX_t)^2$ 的二阶项为零，因为 $\\frac{\\partial^2}{\\partial X_t^2} (X_t e^{\\alpha t}) = 0$。代入 $dX_t$ 的表达式：\n$$\ndY_t = \\alpha X_t e^{\\alpha t} dt + e^{\\alpha t} \\left( \\alpha \\theta dt - \\alpha X_t dt + \\sigma dB_t \\right)\n$$\n包含 $X_t$ 的项相互抵消，这正是积分因子的作用。\n$$\ndY_t = \\alpha \\theta e^{\\alpha t} dt + \\sigma e^{\\alpha t} dB_t\n$$\n我们将此表达式从 $s=0$ 积分到 $s=t$：\n$$\n\\int_0^t dY_s = Y_t - Y_0 = \\int_0^t \\alpha \\theta e^{\\alpha s} ds + \\int_0^t \\sigma e^{\\alpha s} dB_s\n$$\n代回 $Y_t = X_t e^{\\alpha t}$ 和 $Y_0 = X_0 e^0 = X_0 = x_{\\text{parent}}$：\n$$\nX_t e^{\\alpha t} - x_{\\text{parent}} = \\alpha \\theta \\left[ \\frac{1}{\\alpha} e^{\\alpha s} \\right]_0^t + \\sigma \\int_0^t e^{\\alpha s} dB_s\n$$\n$$\nX_t e^{\\alpha t} - x_{\\text{parent}} = \\theta (e^{\\alpha t} - 1) + \\sigma \\int_0^t e^{\\alpha s} dB_s\n$$\n通过乘以 $e^{-\\alpha t}$ 来解出 $X_t$：\n$$\nX_t = x_{\\text{parent}} e^{-\\alpha t} + \\theta (1 - e^{-\\alpha t}) + \\sigma e^{-\\alpha t} \\int_0^t e^{\\alpha s} dB_s\n$$\n通过改变积分变量的参考系，可以重写该随机积分：\n$$\nX_t = x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) + \\sigma \\int_0^t e^{-\\alpha(t-s)} dB_s\n$$\n这是 $X_t$ 的形式解。在 $X_0 = x_{\\text{parent}}$ 的条件下，$X_t$ 的分布是正态分布，因为它是确定性部分和伊藤积分（一个高斯过程）之和。我们现在求其条件均值和方差。\n\n**条件均值：**\n条件期望 $E[X_t | X_0 = x_{\\text{parent}}]$ 是：\n$$\nE[X_t | X_0] = E \\left[ x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) + \\sigma \\int_0^t e^{-\\alpha(t-s)} dB_s \\right]\n$$\n根据期望的线性性质，并且因为给定 $X_0$ 时前两项是确定性的：\n$$\nE[X_t | X_0] = x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) + \\sigma E \\left[ \\int_0^t e^{-\\alpha(t-s)} dB_s \\right]\n$$\n伊藤积分的一个基本性质是，对于任何确定性的、平方可积的函数 $f(s)$，其期望为零：$E[\\int_0^t f(s) dB_s] = 0$。被积函数 $e^{-\\alpha(t-s)}$ 是 $s$ 的确定性函数。因此，积分项的期望为 $0$。\n条件均值为：\n$$\n\\mu_t = E[X_t | X_0 = x_{\\text{parent}}] = x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t})\n$$\n\n**条件方差：**\n条件方差是 $\\text{Var}(X_t | X_0 = x_{\\text{parent}})$。确定性项对方差没有贡献。\n$$\nV_t = \\text{Var}(X_t | X_0) = \\text{Var} \\left( \\sigma \\int_0^t e^{-\\alpha(t-s)} dB_s \\right) = \\sigma^2 \\text{Var} \\left( \\int_0^t e^{-\\alpha(t-s)} dB_s \\right)\n$$\n我们使用伊藤等距，它指出 $\\text{Var}(\\int_0^t f(s) dB_s) = E[(\\int_0^t f(s) dB_s)^2] = \\int_0^t E[f(s)^2] ds$。由于我们的被积函数 $f(s) = e^{-\\alpha(t-s)}$ 是确定性的，这简化为 $\\int_0^t f(s)^2 ds$。\n$$\nV_t = \\sigma^2 \\int_0^t \\left( e^{-\\alpha(t-s)} \\right)^2 ds = \\sigma^2 \\int_0^t e^{-2\\alpha(t-s)} ds = \\sigma^2 e^{-2\\alpha t} \\int_0^t e^{2\\alpha s} ds\n$$\n该积分的计算结果为：\n$$\n\\int_0^t e^{2\\alpha s} ds = \\left[ \\frac{1}{2\\alpha} e^{2\\alpha s} \\right]_0^t = \\frac{1}{2\\alpha} (e^{2\\alpha t} - 1)\n$$\n将此结果代回方差的表达式中，对于 $\\alpha > 0$：\n$$\nV_t = \\sigma^2 e^{-2\\alpha t} \\frac{1}{2\\alpha} (e^{2\\alpha t} - 1) = \\frac{\\sigma^2}{2\\alpha} (1 - e^{-2\\alpha t})\n$$\n因此，对于一个长度为 $t$ 的给定分支，条件分布为 $X_t | X_0=x_{\\text{parent}} \\sim \\mathcal{N}(\\mu_t, V_t)$。\n\n**向布朗运动的渐近极限 ($\\alpha \\to 0$)：**\n在极限 $\\alpha \\rightarrow 0$ 下，SDE中的选择项消失，方程变为 $dX_t = \\sigma dB_t$。其解为 $X_t = X_0 + \\sigma B_t$，这是一个漂移为 $0$、初始值为 $X_0$、方差为 $\\sigma^2 t$ 的布朗运动。我们现在证明我们推导出的条件矩收敛于此。\n- **均值极限：**\n$$\n\\lim_{\\alpha \\to 0} \\mu_t = \\lim_{\\alpha \\to 0} \\left( x_{\\text{parent}} e^{-\\alpha t} + \\theta(1 - e^{-\\alpha t}) \\right) = x_{\\text{parent}} \\cdot 1 + \\theta(1-1) = x_{\\text{parent}}\n$$\n这与极限布朗运动的均值相匹配。\n- **方差极限：** $V_t$ 的极限是一个 $0/0$ 的不定形式。我们对 $\\alpha$ 应用洛必达法则。\n$$\n\\lim_{\\alpha \\to 0} V_t = \\lim_{\\alpha \\to 0} \\frac{\\sigma^2(1 - e^{-2\\alpha t})}{2\\alpha} = \\frac{\\sigma^2}{2} \\lim_{\\alpha \\to 0} \\frac{\\frac{d}{d\\alpha}(1 - e^{-2\\alpha t})}{\\frac{d}{d\\alpha}(\\alpha)} = \\frac{\\sigma^2}{2} \\lim_{\\alpha \\to 0} \\frac{2t e^{-2\\alpha t}}{1} = \\sigma^2 t\n$$\n这与极限布朗运动的方差相匹配。因此，当 $\\alpha \\to 0$ 时，奥恩斯坦-乌伦贝克过程正确地收敛到布朗运动。\n\n### 任务2：算法设计\n\n模拟过程通过从根到尖端遍历系统发育树来进行。每个子节点的性状值都是从上面推导的条件正态分布中抽样得出的，其中父节点的性状值作为初始条件 $x_{\\text{parent}}$，分支长度作为时间段 $t$。\n\n**树遍历：** 树被指定为有向边列表 $(p, c, \\ell)$。为确保父节点在其子节点之前被处理，从根节点开始的广度优先搜索 (BFS) 是一种自然且正确的方法。我们可以使用一个以根节点初始化的队列。我们还需要一个数据结构（例如字典）来存储每个节点的模拟性状值。\n\n**模拟步骤：**\n1.  从输入的边列表中构建树的邻接表表示，例如，一个将父节点映射到 (子节点, 长度) 元组列表的字典。\n2.  用根节点索引初始化一个队列，并用根节点的初始性状值初始化一个字典 `trait_values`。\n3.  当队列不为空时：\n    a. 从队列中取出一个父节点 $p$。设其性状值为 $x_p$。\n    b. 对于通过长度为 $\\ell$ 的分支连接到 $p$ 的每个子节点 $c$：\n        i. 计算给定 $X_0=x_p$ 时 $X_\\ell$ 的条件分布参数。\n        ii. 从标准正态分布中抽取一个随机变量 $Z \\sim \\mathcal{N}(0,1)$。\n        iii. 计算子节点的性状值 $x_c = \\mu_\\ell + \\sqrt{V_\\ell} \\cdot Z$。\n        iv. 将 $x_c$ 存储在 `trait_values` 中，并将 $c$ 入队。\n4.  遍历完成后，识别出尖端节点（即不是父节点的节点）。\n5.  提取尖端节点的性状值，并按节点索引排序。\n\n**特殊情况处理：**\n- **零长度分支 ($\\ell = 0$):**\n  如果 $\\ell=0$，均值变为 $\\mu_0 = x_p e^0 + \\theta(1-e^0) = x_p$。方差变为 $V_0 = \\frac{\\sigma^2}{2\\alpha}(1-e^0) = 0$。分布退化为在 $x_p$ 处的一个点质量。因此，$X_0 = x_p$ 几乎必然成立。子节点的值必须设置为与父节点的值相等。不抽取随机数。\n\n- **布朗运动极限 (小 $\\alpha$):**\n  方差的表达式 $V_t = \\frac{\\sigma^2}{2\\alpha}(1-e^{-2\\alpha t})$ 对于小 $\\alpha$ 值，由于灾难性抵消而数值不稳定。虽然像 `expm1` 这样的专用函数可以缓解此问题，但题目要求在 $\\alpha$ 低于一个阈值时，显式切换到布朗运动极限。\n  我们必须选择一个阈值。对于标准的双精度浮点算术，像 $\\alpha_{\\text{thresh}} = 10^{-8}$ 这样的值是合适的。如果提供的 $\\alpha$ 小于此阈值，我们必须使用布朗运动的公式：\n  - 均值: $\\mu_t = x_p$\n  - 方差: $V_t = \\sigma^2 t$\n  这种方法是合理的，因为对于 $\\alpha < 10^{-8}$ 和典型的分支长度 $\\ell \\sim O(1)$，参数 $x = 2\\alpha t$ 足够小，使得泰勒级数近似 $1-e^{-x} \\approx x - x^2/2!$ 非常精确。使用一阶项，$V_t \\approx \\frac{\\sigma^2}{2\\alpha}(2\\alpha t) = \\sigma^2 t$，这正是布朗运动的方差。这种切换可以防止浮点错误，并正确捕捉极限行为。\n\n### 任务3：实现细节\n\n该算法使用 `numpy` 库在 Python 中实现。\n- **数据结构**：树的边被处理成一个邻接表（一个 Python 字典）。节点的性状值也存储在一个字典中。\n- **随机数生成**：对于每个测试用例，使用 `numpy.random.default_rng` 并指定种子来创建一个新的伪随机数生成器。这确保了可复现性。对于每个需要随机分量的分支转移，使用生成器的 `normal()` 方法抽取一个标准正态变量。\n- **查找尖端节点**：尖端节点被识别为所有出现在树定义中但从未作为父节点出现在边列表中的节点。收集这些节点并按其整数索引排序，以确保正确的输出顺序。\n- **输出格式**：收集每个测试用例的结果。使用一个自定义的格式化函数来生成最终的输出字符串，该字符串必须与指定的格式 `[result1,result2,[tipA,tipB],...]` 完全匹配，所有浮点数都四舍五入到小数点后六位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\nimport math\n\n# No other libraries are used. The scipy library listed in the environment\n# description is not necessary for solving this problem.\n\ndef simulate_ou_on_tree(alpha, sigma, theta, x_root, root_node, edges, seed):\n    \"\"\"\n    Simulates trait evolution on a phylogenetic tree under the Ornstein-Uhlenbeck process.\n    \"\"\"\n    # Initialize the pseudorandom number generator for this test case\n    rng = np.random.default_rng(seed)\n    \n    # Store trait values for each node\n    trait_values = {root_node: x_root}\n    \n    # Build adjacency list for easy traversal: parent -> list of (child, length)\n    adj = defaultdict(list)\n    parent_nodes = set()\n    all_nodes = set([root_node])\n    for p, c, l in edges:\n        adj[p].append((c, l))\n        parent_nodes.add(p)\n        all_nodes.add(p)\n        all_nodes.add(c)\n\n    # Simulation using a breadth-first traversal\n    queue = [root_node]\n    \n    # Small alpha threshold for numerical stability\n    ALPHA_THRESHOLD = 1e-8\n\n    while queue:\n        p = queue.pop(0)\n        x_p = trait_values[p]\n        \n        if p in adj:\n            for c, l in adj[p]:\n                x_c = 0.0\n                \n                # Case 1: Zero-length branch, child value equals parent value\n                if l == 0.0:\n                    x_c = x_p\n                # Case 2: Brownian motion limit (alpha is zero or very small)\n                elif alpha < ALPHA_THRESHOLD:\n                    mean = x_p\n                    variance = sigma**2 * l\n                    std_dev = math.sqrt(variance)\n                    # Draw a standard normal variate\n                    z = rng.normal()\n                    x_c = mean + std_dev * z\n                # Case 3: General Ornstein-Uhlenbeck process\n                else:\n                    exp_al = math.exp(-alpha * l)\n                    mean = x_p * exp_al + theta * (1.0 - exp_al)\n                    \n                    # Note on variance calculation:\n                    # 1 - exp(-2*alpha*l) can be written as -expm1(-2*alpha*l) \n                    # for better precision with small arguments. However, our explicit\n                    # thresholding for small alpha makes this optimization redundant.\n                    variance = (sigma**2 / (2.0 * alpha)) * (1.0 - math.exp(-2.0 * alpha * l))\n                    std_dev = math.sqrt(variance)\n                    # Draw a standard normal variate\n                    z = rng.normal()\n                    x_c = mean + std_dev * z\n                \n                trait_values[c] = x_c\n                queue.append(c)\n\n    # Identify tip (leaf) nodes: nodes that are not parents\n    tip_nodes = sorted(list(all_nodes - parent_nodes))\n    \n    # Collect results for tip nodes\n    tip_values = [trait_values[tip] for tip in tip_nodes]\n    \n    if len(tip_values) == 1:\n        return round(tip_values[0], 6)\n    else:\n        return [round(v, 6) for v in tip_values]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the OU simulation problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (single branch, general OU)\n        {\n            \"params\": {\"alpha\": 0.5, \"sigma\": 1.2, \"theta\": 2.0},\n            \"tree\": {\"x_root\": 0.0, \"root_node\": 0, \"edges\": [(0, 1, 1.0)]},\n            \"seed\": 7\n        },\n        # Test case 2 (zero-length branch, degeneracy check)\n        {\n            \"params\": {\"alpha\": 0.7, \"sigma\": 2.0, \"theta\": 10.0},\n            \"tree\": {\"x_root\": 1.23, \"root_node\": 0, \"edges\": [(0, 1, 0.0)]},\n            \"seed\": 11\n        },\n        # Test case 3 (small bifurcating tree, multi-tip OU)\n        {\n            \"params\": {\"alpha\": 2.0, \"sigma\": 0.8, \"theta\": -1.0},\n            \"tree\": {\"x_root\": 3.0, \"root_node\": 0, \"edges\": [(0, 1, 0.5), (1, 3, 0.3), (0, 2, 0.7), (2, 4, 0.2)]},\n            \"seed\": 13\n        },\n        # Test case 4 (Brownian-motion limit, alpha = 0)\n        {\n            \"params\": {\"alpha\": 0.0, \"sigma\": 1.5, \"theta\": 0.0},\n            \"tree\": {\"x_root\": -0.5, \"root_node\": 0, \"edges\": [(0, 1, 0.4), (1, 2, 0.6)]},\n            \"seed\": 17\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = simulate_ou_on_tree(\n            alpha=case[\"params\"][\"alpha\"],\n            sigma=case[\"params\"][\"sigma\"],\n            theta=case[\"params\"][\"theta\"],\n            x_root=case[\"tree\"][\"x_root\"],\n            root_node=case[\"tree\"][\"root_node\"],\n            edges=case[\"tree\"][\"edges\"],\n            seed=case[\"seed\"]\n        )\n        results.append(result)\n\n    # Custom formatter to match the specified output string format\n    def format_result(res):\n        if isinstance(res, list):\n            return f\"[{','.join(f'{x:.6f}' for x in res)}]\"\n        else:\n            return f\"{res:.6f}\"\n\n    formatted_results = [format_result(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}