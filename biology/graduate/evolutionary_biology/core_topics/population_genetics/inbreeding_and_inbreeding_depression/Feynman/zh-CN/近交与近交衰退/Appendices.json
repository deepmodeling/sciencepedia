{
    "hands_on_practices": [
        {
            "introduction": "掌握近交概念的第一步是理解如何从系谱中量化它。近交系数 $F$ 是衡量一个个体中两个等位基因因出自共同祖先而相同的概率。本练习将通过一个经典的圈养繁殖场景，指导你使用 Wright 的路径系数法来计算近交系数，这是理解“因祖同源”（IBD）和分析遗传史的一项基本技能。",
            "id": "1940055",
            "problem": "在一个针对极度濒危的伊比利亚猞猁的圈养繁殖计划中，一只名为“Zara”的新幼崽诞生了。动物园管理员正在评估种群的遗传健康状况，并需要计算这个新个体的近交水平。Zara的父母是“Félix”和“Isabel”。谱系记录显示，Félix的父亲和Isabel的父亲是兄弟。假设他们近期谱系中的所有其他祖先都没有亲缘关系，且自身没有近交。近交系数，用$F$表示，量化了个体中任意给定基因座上的两个等位基因因出自共同祖先而相同的概率。计算Zara的近交系数$F$。将你的答案表示为精确分数。",
            "solution": "个体的近交系数$F$等于一个基因座上的两个等位基因因同源而相同的概率，根据Wright的路径系数法，其计算公式为\n$$\nF=\\sum_{A}( \\frac{1}{2} )^{n_{1}+n_{2}+1}\\left(1+F_{A}\\right),\n$$\n其中，总和是对该个体父母的所有共同祖先$A$求和，$n_{1}$和$n_{2}$是从$A$到每个父母的代数，$F_{A}$是祖先$A$的近交系数。\n\n根据谱系，Félix的父亲和Isabel的父亲是兄弟，所以Félix和Isabel是堂（或表）兄妹。他们唯一的共同祖先是那对兄弟的父母，即他们的祖父母。所有其他祖先都没有亲缘关系且没有近交，因此对于每个共同祖先$A$，我们有$F_{A}=0$。\n\n对于两个共同的祖父母中的每一位：\n- 从$A$到Félix的路径长度为$n_{1}=2$（祖父母 $\\to$ Félix的父亲 $\\to$ Félix）。\n- 从$A$到Isabel的路径长度为$n_{2}=2$（祖父母 $\\to$ Isabel的父亲 $\\to$ Isabel）。\n\n因此，每个共同的祖父母的贡献为\n$$\n( \\frac{1}{2} )^{2+2+1}(1+0)=\\left( \\frac{1}{2} \\right)^{5}=\\frac{1}{32}.\n$$\n有两个这样的祖父母，所以总和是\n$$\nF=2\\times \\frac{1}{32}=\\frac{1}{16}.\n$$\n\n作为一致性检验，堂（或表）兄妹之间的亲缘关系系数是$\\frac{1}{8}$，而血缘系数（当父母没有近交时，该系数等于后代的$F$）是其一半，即$\\frac{1}{16}$，与上述结果相符。",
            "answer": "$$\\boxed{\\frac{1}{16}}$$"
        },
        {
            "introduction": "虽然基于系谱的分析是基础，但在现代遗传学研究中，尤其是在系谱未知或不完整时，我们更多地依赖基因组数据。本练习将介绍一种更为强大的方法，即直接从个体的单核苷酸多态性（SNP）数据中估计其近交水平。通过这个实践，你将学习如何从观测到的纯合性偏离中推导出近交系数的估计量 $F_H$，从而将群体遗传学理论与实际的生物信息学分析联系起来。",
            "id": "2725873",
            "problem": "给定单个个体的基因型数据，这些数据来自一组非连锁的常染色体双等位基因单核苷酸多态性（SNP）位点，以及相应的次要等位基因的群体频率。您的任务是基于纯合性过量（excess homozygosity），从第一性原理出发，推导该个体近交系数的估计量（表示为 $F_H$），并推导和计算其抽样方差，将其表示为位点数量和等位基因频率谱的函数。\n\n基本依据与假设：\n- 考虑 $L$ 个独立位点，索引为 $i \\in \\{1,\\dots,L\\}$，其次要等位基因频率为 $p_i \\in (0,1)$，主要等位基因频率为 $q_i = 1 - p_i$。\n- 在 Hardy–Weinberg 平衡下，一个位点的基因型频率由 $P(\\text{AA}) = q_i^2$、$P(\\text{Aa}) = 2 p_i q_i$ 和 $P(\\text{aa}) = p_i^2$ 给出。\n- 在 Wright 的近交模型下，近交系数为 $F \\in [0,1]$，预期的基因型频率变为 $P(\\text{AA}) = q_i^2 + p_i q_i F$、$P(\\text{Aa}) = 2 p_i q_i (1 - F)$ 和 $P(\\text{aa}) = p_i^2 + p_i q_i F$。\n- 设 $X_i$ 为指示变量，表示个体在位点 $i$ 上是否为纯合子，因此 $X_i \\in \\{0,1\\}$，如果个体是纯合子（$\\text{AA}$ 或 $\\text{aa}$），则 $X_i = 1$；如果是杂合子（$\\text{Aa}$），则 $X_i = 0$。设 $O = \\sum_{i=1}^L X_i$ 是观测到的纯合子数量。\n- 设 $E_0 = \\sum_{i=1}^L \\left(q_i^2 + p_i^2\\right)$ 表示在随机交配（即 $F = 0$）下纯合位点的总预期数量。注意，$L - E_0 = \\sum_{i=1}^L 2 p_i q_i$ 是在随机交配下杂合位点的总预期数量。\n\n推导要求：\n1. 从这些定义和经近交调整的基因型频率出发，推导一个估计量 $F_H$。当模型假设成立时，该估计量是 $F$ 的无偏估计。此估计量必须通过将观测到的纯合性与其在随机交配下的期望值进行比较，并使用预期的杂合性进行适当归一化来构建，且仅能使用上述基本定义。\n2. 在位点独立且以等位基因频率 $p_i$ 为条件的假设下，推导出抽样方差 $\\mathrm{Var}(F_H)$，用 $L$ 和 $\\{p_i\\}_{i=1}^L$ 表示。您的推导应从 $\\mathrm{Var}(O)$ 开始，使用独立指示变量之和的基本性质，然后对常数归一化因子应用方差变换。提供 $\\mathrm{Var}(F_H)$ 作为 $F$ 的函数的通用表达式，然后为了实现，在 $F=0$ 处对其进行评估，以获得仅包含 $\\{p_i\\}_{i=1}^L$ 的封闭形式函数。以小数（而非百分比）报告 $F_H$ 和 $\\mathrm{Var}(F_H)$。\n\n实现任务：\n- 您将实现一个程序，该程序：\n  - 不接受任何输入。\n  - 使用下面提供的测试套件，每个套件包括：\n    - 一个基因型向量 $g = [g_1,\\dots,g_L]$，其中 $g_i \\in \\{0,1,2\\}$，编码次要等位基因的数量（$0$ 表示纯合主要等位基因，$1$ 表示杂合，$2$ 表示纯合次要等位基因）。\n    - 一个相应的次要等位基因频率向量 $p = [p_1,\\dots,p_L]$，其中每个 $p_i \\in (0,1)$。\n  - 对每个测试用例，计算：\n    - 根据您的推导计算 $F_H$。\n    - 在独立性假设下，于 $F=0$ 处评估的解析抽样方差 $\\mathrm{Var}(F_H)$。\n  - 输出一行，其中包含所有测试用例的结果列表，每个结果是一个双元素列表 $[F_H,\\mathrm{Var}(F_H)]$，两个值都四舍五入到六位小数。\n\n测试套件：\n- 测试用例 1（一般混合基因型，中等位点频率谱）：\n  - $g = [0,1,2,1,1,2,0,1,2,0,1,2]$\n  - $p = [0.12,0.35,0.40,0.20,0.50,0.45,0.10,0.30,0.25,0.15,0.05,0.60]$\n- 测试用例 2（边界情况：全部为杂合基因型，中等 $p_i$）：\n  - $g = [1,1,1,1,1,1,1,1,1,1]$\n  - $p = [0.20,0.30,0.40,0.50,0.35,0.25,0.45,0.15,0.55,0.05]$\n- 测试用例 3（边界情况：全部为纯合基因型，对称 $p_i$）：\n  - $g = [0,0,0,2,2,2,0,2]$\n  - $p = [0.50,0.50,0.50,0.50,0.50,0.50,0.50,0.50]$\n- 测试用例 4（边缘情况：偏向稀有等位基因的等位基因频率谱）：\n  - $g = [0,0,0,1,1,0,1,2,0,1]$\n  - $p = [0.01,0.02,0.03,0.05,0.10,0.15,0.20,0.25,0.30,0.40]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身都是 $[F_H,\\mathrm{Var}(F_H)]$形式的双元素列表。值必须四舍五入到六位小数。例如，输出格式为 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$。",
            "solution": "该问题陈述已经过验证，被认为是具有科学依据、问题明确且客观的。它提出了群体遗传学中的一个标准任务，基于 Wright 近交模型和 Hardy-Weinberg 平衡的既定原则。所有定义、变量和常数均已提供，构成一个自洽且一致的问题。不存在逻辑矛盾、事实错误或含糊不清之处。因此，我们可以进行推导和求解。\n\n按照要求，推导过程分为两个不同的部分。\n\n首先，我们推导近交系数的估计量 $F_H$。目标是通过将观测到的纯合位点数 $O$ 与随机交配下预期的数量 $E_0$ 进行比较，来构建 $F$ 的一个无偏估计量。\n\n设 $X_i$ 为指示变量，如果个体在位点 $i$ 上是纯合的，则 $X_i=1$，如果是杂合的，则 $X_i=0$。观测到的纯合位点总数是 $O = \\sum_{i=1}^L X_i$。\n\n$X_i$ 的期望是位点 $i$ 上为纯合子的概率。在 Wright 的近交模型下，系数为 $F$，此概率由两种纯合基因型概率之和给出：\n$$ \\mathbb{E}[X_i|F] = P(\\text{AA}) + P(\\text{aa}) = (q_i^2 + p_i q_i F) + (p_i^2 + p_i q_i F) $$\n$$ \\mathbb{E}[X_i|F] = p_i^2 + q_i^2 + 2 p_i q_i F $$\n其中 $p_i$ 是次要等位基因的频率，$q_i = 1 - p_i$。项 $p_i^2 + q_i^2$ 是在随机交配 ($F=0$) 下位点 $i$ 的纯合概率，而 $2 p_i q_i$ 是相应的杂合概率。\n\n根据期望的线性性质，预期的纯合位点总数 $\\mathbb{E}[O|F]$ 是所有 $L$ 个位点上单个期望的总和：\n$$ \\mathbb{E}[O|F] = \\sum_{i=1}^L \\mathbb{E}[X_i|F] = \\sum_{i=1}^L (p_i^2 + q_i^2 + 2 p_i q_i F) $$\n$$ \\mathbb{E}[O|F] = \\sum_{i=1}^L (p_i^2 + q_i^2) + F \\sum_{i=1}^L (2 p_i q_i) $$\n使用问题中的符号，其中 $E_0 = \\sum_{i=1}^L (p_i^2 + q_i^2)$ 是随机交配下预期的纯合位点数，$L - E_0 = \\sum_{i=1}^L (1 - (p_i^2+q_i^2)) = \\sum_{i=1}^L (2 p_i q_i)$ 是随机交配下预期的杂合位点数，我们可以写出：\n$$ \\mathbb{E}[O|F] = E_0 + F(L - E_0) $$\n该方程将预期的观测纯合性与近交系数 $F$ 联系起来。为了构建 $F$ 的估计量，我们重新整理该方程：\n$$ F(L - E_0) = \\mathbb{E}[O|F] - E_0 $$\n$$ F = \\frac{\\mathbb{E}[O|F] - E_0}{L - E_0} $$\n我们通过用观测值 $O$ 替换其期望 $\\mathbb{E}[O|F]$ 来定义我们的估计量 $F_H$：\n$$ F_H = \\frac{O - E_0}{L - E_0} $$\n为了检查该估计量是否无偏，我们取其期望：\n$$ \\mathbb{E}[F_H] = \\mathbb{E}\\left[\\frac{O - E_0}{L - E_0}\\right] = \\frac{\\mathbb{E}[O] - E_0}{L - E_0} = \\frac{(E_0 + F(L - E_0)) - E_0}{L - E_0} = \\frac{F(L - E_0)}{L - E_0} = F $$\n该估计量确实是无偏的，符合要求。\n\n其次，我们推导 $F_H$ 的抽样方差，记为 $\\mathrm{Var}(F_H)$。鉴于 $E_0$ 和 $L$ 是由已知的等位基因频率决定的常数，$F_H$ 的方差与 $O$ 的方差关系如下：\n$$ \\mathrm{Var}(F_H|F) = \\mathrm{Var}\\left(\\frac{O - E_0}{L - E_0}\\right) = \\frac{1}{(L - E_0)^2} \\mathrm{Var}(O|F) $$\n假设各位点是独立的。因此，和 $O = \\sum_{i=1}^L X_i$ 的方差是各项方差之和：\n$$ \\mathrm{Var}(O|F) = \\sum_{i=1}^L \\mathrm{Var}(X_i|F) $$\n由于 $X_i$ 是一个伯努利指示变量，其成功概率为 $P(X_i=1|F) = p_i^2 + q_i^2 + 2p_iq_iF$，其方差为：\n$$ \\mathrm{Var}(X_i|F) = P(X_i=1|F) \\cdot (1 - P(X_i=1|F)) $$\n项 $1 - P(X_i=1|F)$ 是杂合的概率，$P(X_i=0|F) = 2p_iq_i(1-F)$。因此，\n$$ \\mathrm{Var}(X_i|F) = (p_i^2 + q_i^2 + 2p_iq_iF) \\cdot (2p_iq_i(1-F)) $$\n对所有位点求和得到 $O$ 的方差：\n$$ \\mathrm{Var}(O|F) = \\sum_{i=1}^L (p_i^2 + q_i^2 + 2p_iq_iF)(2p_iq_i(1-F)) $$\n将此代入 $\\mathrm{Var}(F_H|F)$ 的表达式中，并回顾 $L-E_0 = \\sum_{i=1}^L 2p_iq_i$，我们得到方差的通用表达式：\n$$ \\mathrm{Var}(F_H|F) = \\frac{\\sum_{i=1}^L (p_i^2 + q_i^2 + 2p_iq_iF)(2p_iq_i(1-F))}{\\left(\\sum_{i=1}^L 2p_iq_i\\right)^2} $$\n为了实现，我们需要在随机交配的原假设下，即在 $F=0$ 处，评估该方差：\n$$ \\mathrm{Var}(F_H|F=0) = \\frac{\\sum_{i=1}^L (p_i^2 + q_i^2 + 0)(2p_iq_i(1-0))}{\\left(\\sum_{i=1}^L 2p_iq_i\\right)^2} $$\n$$ \\mathrm{Var}(F_H|F=0) = \\frac{\\sum_{i=1}^L (p_i^2 + q_i^2)(2p_iq_i)}{\\left(\\sum_{i=1}^L 2p_iq_i\\right)^2} $$\n这个最终表达式仅是位点数 $L$ 和等位基因频率集合 $\\{p_i\\}_{i=1}^L$ 的函数，并用于计算任务。实现时将通过计算非杂合位点（其中 $g_i \\neq 1$）的数量，从给定的基因型向量 $g$ 中计算出 $O$，并使用等位基因频率向量 $p$ 计算 $E_0$，进而计算出 $F_H$ 和 $\\mathrm{Var}(F_H|F=0)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes an estimator for the inbreeding coefficient (F_H)\n    and its sampling variance based on genotype data and allele frequencies.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"g\": [0,1,2,1,1,2,0,1,2,0,1,2],\n            \"p\": [0.12,0.35,0.40,0.20,0.50,0.45,0.10,0.30,0.25,0.15,0.05,0.60]\n        },\n        {\n            \"g\": [1,1,1,1,1,1,1,1,1,1],\n            \"p\": [0.20,0.30,0.40,0.50,0.35,0.25,0.45,0.15,0.55,0.05]\n        },\n        {\n            \"g\": [0,0,0,2,2,2,0,2],\n            \"p\": [0.50,0.50,0.50,0.50,0.50,0.50,0.50,0.50]\n        },\n        {\n            \"g\": [0,0,0,1,1,0,1,2,0,1],\n            \"p\": [0.01,0.02,0.03,0.05,0.10,0.15,0.20,0.25,0.30,0.40]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        g = np.array(case[\"g\"])\n        p = np.array(case[\"p\"])\n        \n        # Number of loci\n        L = len(g)\n        \n        # 1. Observed number of homozygous loci, O\n        # Genotypes are 0 (hom_major), 1 (het), 2 (hom_minor).\n        # Homozygous loci are those where g_i != 1.\n        O = np.sum(g != 1)\n\n        # 2. Expected number of homozygous loci under random mating, E_0\n        q = 1.0 - p\n        # Expected homozygosity at locus i is p_i^2 + q_i^2\n        expected_hom_per_locus = p**2 + q**2\n        E0 = np.sum(expected_hom_per_locus)\n        \n        # 3. Expected number of heterozygous loci under random mating, L - E_0\n        # This is the denominator for the F_H estimator.\n        # It's equal to sum(2 * p_i * q_i)\n        expected_het_total = L - E0\n        \n        # 4. Compute the inbreeding coefficient estimator F_H\n        # F_H = (Observed_Hom - Expected_Hom) / Expected_Het\n        if expected_het_total == 0:\n            # This case should not happen given p_i in (0,1), but as a safeguard.\n            F_H = np.nan\n        else:\n            F_H = (O - E0) / expected_het_total\n            \n        # 5. Compute the sampling variance Var(F_H) at F=0\n        # Var(F_H|F=0) = [sum_i (p_i^2+q_i^2)(2p_iq_i)] / [sum_i (2p_iq_i)]^2\n        expected_het_per_locus = 2 * p * q\n        \n        var_numerator = np.sum(expected_hom_per_locus * expected_het_per_locus)\n        var_denominator = expected_het_total**2\n        \n        if var_denominator == 0:\n            # Safeguard\n            Var_FH = np.nan\n        else:\n            Var_FH = var_numerator / var_denominator\n            \n        # Append results, rounded to six decimal places\n        results.append([round(F_H, 6), round(Var_FH, 6)])\n\n    # Format the final output string as specified\n    formatted_results = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "近交在进化和保护生物学中的最终重要性在于其对适合度的负面影响，即近交衰退。本练习将带领我们从“测量近交”转向“测量近交的后果”。你将学习一种标准统计方法，通过分析不同近交水平群体的存活数据来估计近交衰退的严重程度（以每个二倍体基因组的致死当量 $B$ 来衡量），这是保护项目管理中的一项关键任务。",
            "id": "2725930",
            "problem": "给定多组个体的分组存活结果，每组具有已知的近交系数 $F$、个体总数 $n$ 和存活者计数 $s$。在进化生物学中，近交衰退的概念通常通过每个二倍体基因组的致死当量（表示为 $B$）来量化，该值衡量存活率随近交的变化。从一个基本原理出发：许多独立的、稀有的有害基因座的存活效应以乘积方式组合，并且有效致死打击的期望数量随着同源等位概率的增加而累加。由此可知，对数转换可将存活因子的乘积转换为和。利用这些原理，推导存活概率的自然对数与近交系数 $F$ 之间的线性关系。然后，通过将观测存活比例的自然对数对 $F$ 进行带截距项的回归，为分组二项数据设计一个 $B$ 的估计量。使用总组别大小 $n$ 作为权重，以解释组间抽样方差的差异。将估计斜率的负值解释为 $B$ 的估计值。\n\n您的程序必须精确实现以下算法：\n- 对于每个具有参数 $(F_i,n_i,s_i)$ 的组 $i$，计算观测存活比例 $p_i = s_i/n_i$。假设所有提供的数据都满足 $0 < p_i < 1$。\n- 对 $y_i = \\ln(p_i)$ 和 $x_i = F_i$ 进行加权最小二乘回归，包含截距项，并使用权重 $w_i = n_i$。即，通过最小化 $\\sum_i w_i\\,(y_i - \\beta_0 - \\beta_1 x_i)^2$ 来估计截距和斜率 $(\\beta_0,\\beta_1)$。\n- 定义 $\\widehat{B} = -\\widehat{\\beta}_1$。\n- 对于每个数据集，以浮点数形式输出 $\\widehat{B}$，四舍五入到 $6$ 位小数。\n\n测试套件：\n提供代码，为以下数据集计算 $\\widehat{B}$。每个数据集是一个 $(F,n,s)$ 三元组的列表。\n\n- 数据集 A:\n  - $(0, 400, 320)$\n  - $(0.0625, 300, 222)$\n  - $(0.125, 350, 230)$\n  - $(0.25, 320, 190)$\n\n- 数据集 B:\n  - $(0, 500, 450)$\n  - $(0.25, 500, 325)$\n  - $(0.5, 500, 250)$\n\n- 数据集 C:\n  - $(0, 40, 36)$\n  - $(0.125, 30, 24)$\n  - $(0.375, 20, 11)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与数据集的顺序相同，例如 $[b_A,b_B,b_C]$，其中每个条目都四舍五入到 $6$ 位小数，且不含任何附加文本。",
            "solution": "我们从一个适用于进化生物学和近交研究的基本依据出发：当存活率等适合度组分反映了许多独立的、稀有的有害等位基因的综合效应时，个体的总体存活率可以模型化为各个基因座存活贡献的乘积。设远交个体的每个基因座对存活的贡献接近于1，并设因自合性（autozygosity）而暴露的有效致死或半致死打击的期望数量与近交系数 $F$ 成正比增加。这与两个经过充分检验的事实相符：同源等位概率（identity by descent）使纯合性（homozygosity）按与 $F$ 成正比的比例增加，以及独立基因座间的乘性适合度意味着适合度的对数在基因座间是可加的。\n\n用 $S(F)$ 表示近交系数为 $F$ 时的存活概率，用 $S(0)$ 表示远交状态下的基线存活概率。如果许多稀有的、主要为隐性的有害等位基因在纯合时各自对存活率造成一个小的乘性降低，那么这些表达出来的有害效应的期望数量将大约与 $F$ 呈线性增加。根据稀有事件定律，暴露的有效致死当量的数量可以用一个泊松随机变量来近似，其均值与 $F$ 成正比。因此，存活概率就是基线存活率乘以出现零次有效致死打击的概率，这就产生了一个指数形式。因此，近交衰退研究中一个标准且经过充分检验的模型是：\n$$\nS(F) = S(0)\\,\\exp(-B\\,F),\n$$\n其中 $B$ 是每个二倍体基因组的致死当量数。取自然对数，我们得到：\n$$\n\\ln S(F) = \\ln S(0) - B\\,F.\n$$\n这表明 $\\ln S(F)$ 与 $F$ 呈线性关系，斜率为 $-B$，截距为 $\\ln S(0)$。\n\n在实践中，我们观察到的是分组二项数据：对于每个具有共同 $F_i$ 的组 $i$，有 $n_i$ 个个体和 $s_i$ 个存活者，从而得到观测比例\n$$\np_i = \\frac{s_i}{n_i}.\n$$\n对于较大的 $n_i$ 和中等的 $p_i$，$\\ln p_i$ 的抽样方差大约与 $n_i$ 成反比，这启发我们在将 $\\ln p_i$ 对 $F_i$ 进行回归时使用 $n_i$ 作为权重。具体来说，定义 $y_i = \\ln(p_i)$，$x_i = F_i$，权重为 $w_i = n_i$。我们寻求 $(\\beta_0,\\beta_1)$ 以最小化加权平方和\n$$\nQ(\\beta_0,\\beta_1) = \\sum_i w_i\\left(y_i - \\beta_0 - \\beta_1 x_i\\right)^2.\n$$\n加权正规方程组可以得到闭式估计量。定义加权和\n$$\nS_0 = \\sum_i w_i,\\quad S_x = \\sum_i w_i x_i,\\quad S_y = \\sum_i w_i y_i,\\quad S_{xx} = \\sum_i w_i x_i^2,\\quad S_{xy} = \\sum_i w_i x_i y_i.\n$$\n只要 $x_i$ 存在变异，行列式 $D = S_0 S_{xx} - S_x^2$ 就为正。加权最小二乘估计量为\n$$\n\\widehat{\\beta}_1 = \\frac{S_0 S_{xy} - S_x S_y}{D},\\qquad \\widehat{\\beta}_0 = \\frac{S_y - \\widehat{\\beta}_1 S_x}{S_0}.\n$$\n根据模型 $\\ln S(F) = \\ln S(0) - B F$，斜率满足 $\\beta_1 = -B$，因此每个二倍体基因组的致死当量数的估计量是\n$$\n\\widehat{B} = -\\widehat{\\beta}_1.\n$$\n\n程序的算法设计：\n- 对于由 $(F_i,n_i,s_i)$ 三元组组成的每个数据集：\n  - 对所有组 $i$ 计算 $p_i = s_i/n_i$。\n  - 计算 $y_i = \\ln(p_i)$ 和 $x_i = F_i$，并设置 $w_i = n_i$。\n  - 累加加权和 $S_0, S_x, S_y, S_{xx}, S_{xy}$。\n  - 计算 $\\widehat{\\beta}_1$，然后计算 $\\widehat{B} = -\\widehat{\\beta}_1$。\n  - 将 $\\widehat{B}$ 四舍五入到 $6$ 位小数。\n- 按数据集的顺序，将三个四舍五入后的 $\\widehat{B}$ 值聚合到一个列表中，并将其以单行、方括号内逗号分隔的形式打印，不含任何额外文本。\n\n科学真实性与测试覆盖范围：\n- 数据集 A 涵盖从 $F=0$ 到 $F=0.25$ 的低到中等近交系数，并具有大样本量；观测到的存活率随 $F$ 下降，与近交衰退一致。\n- 数据集 B 包含高达 $F=0.5$ 的更高近交水平，并具有均衡的大样本量，用于探究更强的衰退机制。\n- 数据集 C 使用较小的样本量来测试加权行为和数值稳定性，同时保持 $0<p_i<1$ 以避免出现未定义的对数。\n\n该方法基于乘性适合度模型和对数的加性行为，产生了一个可解释的斜率，其负值等于每个二倍体基因组的致死当量的估计值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_B_wls(dataset):\n    \"\"\"\n    Estimate B (lethal equivalents per diploid genome) by weighted least squares\n    regression of ln(p_i) on F_i with intercept, weights w_i = n_i.\n\n    dataset: list of tuples (F_i, n_i, s_i)\n    returns: float, estimated B\n    \"\"\"\n    F = np.array([row[0] for row in dataset], dtype=float)\n    n = np.array([row[1] for row in dataset], dtype=float)\n    s = np.array([row[2] for row in dataset], dtype=float)\n\n    # Observed survival proportions\n    p = s / n\n\n    # Numerical safety: assume 0 < p < 1 as guaranteed by the problem statement.\n    # Compute transformed response\n    y = np.log(p)\n    x = F\n    w = n\n\n    # Weighted sums for closed-form WLS with intercept\n    S0 = np.sum(w)\n    Sx = np.sum(w * x)\n    Sy = np.sum(w * y)\n    Sxx = np.sum(w * x * x)\n    Sxy = np.sum(w * x * y)\n\n    D = S0 * Sxx - Sx * Sx\n    if D == 0.0:\n        # Should not happen with varying F; handle gracefully\n        raise ValueError(\"Design matrix is singular; variation in F is required.\")\n\n    beta1 = (S0 * Sxy - Sx * Sy) / D\n    # beta0 = (Sy - beta1 * Sx) / S0  # not needed for B\n\n    B_hat = -beta1\n    return B_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each dataset is a list of (F, n, s) tuples.\n    dataset_A = [\n        (0.0, 400, 320),\n        (0.0625, 300, 222),\n        (0.125, 350, 230),\n        (0.25, 320, 190),\n    ]\n    dataset_B = [\n        (0.0, 500, 450),\n        (0.25, 500, 325),\n        (0.5, 500, 250),\n    ]\n    dataset_C = [\n        (0.0, 40, 36),\n        (0.125, 30, 24),\n        (0.375, 20, 11),\n    ]\n\n    test_cases = [dataset_A, dataset_B, dataset_C]\n\n    results = []\n    for data in test_cases:\n        B_est = estimate_B_wls(data)\n        # Round to 6 decimal places as required\n        results.append(f\"{B_est:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}