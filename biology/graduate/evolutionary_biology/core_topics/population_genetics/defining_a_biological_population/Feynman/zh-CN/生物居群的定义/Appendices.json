{
    "hands_on_practices": [
        {
            "introduction": "在自然界中，种群大小很少保持恒定。种群数量的波动，特别是经历“瓶颈期”（数量急剧减少），对遗传多样性有着不成比例的巨大影响。本练习将引导你从第一性原理出发，理解如何量化这种影响：你将推导并计算在种群大小随时间波动的情况下的近交有效种群大小（$N_e$）。通过这个过程，你将明白为什么 $N_e$ 对小种群规模尤为敏感，以及它为何是比算术平均值更能反映种群遗传动态的关键指标。",
            "id": "2700070",
            "problem": "考虑一个封闭的、随机交配的、二倍体种群，其世代离散不重叠，性别比例恒定，且无突变、迁移或选择。令 $N_t$ 表示第 $t$ 代的普查规模（二倍体个体数量）。将跨越 $T$ 代的近交有效种群规模（记作有效种群规模 ($N_e$)）定义为一个理想 Wright–Fisher 种群的规模，该理想种群在 $T$ 代内累积的总近交程度与具有时变 $N_t$ 的真实种群相同。仅使用二倍体种群的 Wright–Fisher 抽样方案和同源共祖（IBD）的定义，从第一性原理出发，推导出一个关于序列 $\\{N_t\\}_{t=1}^{T}$ 的跨越 $T$ 代的 $N_e$ 的闭式表达式，并假设初始近交系数为 $F_0 = 0$。然后，用 $T = 4$ 和序列 $N_t = \\{100, 1000, 100, 1000\\}$（按此顺序）计算表达式的值。\n\n您的最终数值结果必须以精确的闭式解析表达式给出（不要近似或四舍五入）。在您的演算过程中，用一两句话解释为什么计算出的 $N_e$ 与给定 $N_t$ 值的算术平均值不同。您报告的最终答案必须仅为 $N_e$ 的精确表达式（最终答案中不含解释）。",
            "solution": "该问题在理论群体遗传学框架内是有效且适定的。我们从第一性原理出发进行推导。\n\n令 $F_t$ 为第 $t$ 代的近交系数，定义为随机选择的二倍体个体中，一个位点上的两个等位基因是同源共祖（IBD）的概率。我们考虑的是一个世代离散的种群，第 $t$ 代的近交程度取决于其亲代（第 $t-1$ 代）的普查规模 $N_{t-1}$。\n\n在规模为 $N_{t-1}$ 的二倍体种群的 Wright-Fisher 模型中，基因库中有 $2N_{t-1}$ 个等位基因。为了形成第 $t$ 代的个体，从该基因库中有放回地随机抽取两个配子。这两个配子是 IBD 的条件是以下两种情况之一：\n$1$. 它们是同一个亲代等位基因的拷贝。选中一个特定等位基因的概率是 $\\frac{1}{2N_{t-1}}$，再次选中它的概率也是 $\\frac{1}{2N_{t-1}}$。共有 $2N_{t-1}$ 个这样的等位基因，所以此事件的概率是 $2N_{t-1} \\times (\\frac{1}{2N_{t-1}})^2 = \\frac{1}{2N_{t-1}}$。一个更简单的论证是，一旦第一个配子被选中，第二个配子是同一亲代配子的拷贝的概率是 $\\frac{1}{2N_{t-1}}$。\n$2$. 它们是两个不同亲代等位基因的拷贝，而这两个亲代等位基因本身是 IBD 的。选中两个不同亲代等位基因的概率是 $1 - \\frac{1}{2N_{t-1}}$。根据定义，这两个不同等位基因是 IBD 的概率就是亲代的近交系数 $F_{t-1}$。\n\n结合这两个互斥事件，我们得到近交系数的递推关系：\n$$F_t = \\frac{1}{2N_{t-1}} + \\left(1 - \\frac{1}{2N_{t-1}}\\right) F_{t-1}$$\n处理非同源共祖的概率 $P_t = 1 - F_t$ 更为方便。将 $F_t = 1 - P_t$ 和 $F_{t-1} = 1 - P_{t-1}$ 代入递推关系式，得到：\n$$1 - P_t = \\frac{1}{2N_{t-1}} + \\left(1 - \\frac{1}{2N_{t-1}}\\right) (1 - P_{t-1})$$\n$$1 - P_t = \\frac{1}{2N_{t-1}} + 1 - P_{t-1} - \\frac{1}{2N_{t-1}} + \\frac{P_{t-1}}{2N_{t-1}}$$\n$$-P_t = -P_{t-1} + \\frac{P_{t-1}}{2N_{t-1}}$$\n$$P_t = P_{t-1} \\left(1 - \\frac{1}{2N_{t-1}}\\right)$$\n问题给出了一个种群规模序列 $\\{N_t\\}_{t=1}^{T}$。我们将此序列解释为第 $1, 2, \\ldots, T$ 代的亲代种群规模。因此，从第 $t-1$ 代到第 $t$ 代的变化由种群规模 $N_t$ 决定。采用这种索引方式，递推关系变为 $P_t = P_{t-1} \\left(1 - \\frac{1}{2N_t}\\right)$。\n\n我们可以从初始非同源概率 $P_0$ 开始，将此关系展开到 $T$ 代。\n$$P_T = P_{T-1} \\left(1 - \\frac{1}{2N_T}\\right) = P_{T-2} \\left(1 - \\frac{1}{2N_{T-1}}\\right)\\left(1 - \\frac{1}{2N_T}\\right) = \\dots = P_0 \\prod_{t=1}^{T} \\left(1 - \\frac{1}{2N_t}\\right)$$\n给定初始条件 $F_0 = 0$，我们有 $P_0 = 1 - F_0 = 1$。\n因此，对于规模波动的真实种群，在 $T$ 代后非同源的概率为：\n$$P_T^{\\text{real}} = \\prod_{t=1}^{T} \\left(1 - \\frac{1}{2N_t}\\right)$$\n\n现在，考虑一个规模恒定为 $N_e$ 的理想 Wright-Fisher 种群。该种群从 $P_0=1$ 开始，在 $T$ 代后非同源的概率为：\n$$P_T^{\\text{ideal}} = \\left(1 - \\frac{1}{2N_e}\\right)^T$$\n近交有效种群规模 $N_e$ 被定义为能产生与真实种群相同总累积近交程度的理想种群的规模。这意味着最终的非同源概率必须相同：$P_T^{\\text{real}} = P_T^{\\text{ideal}}$。\n$$\\prod_{t=1}^{T} \\left(1 - \\frac{1}{2N_t}\\right) = \\left(1 - \\frac{1}{2N_e}\\right)^T$$\n我们现在求解 $N_e$。两边取 $T$ 次方根：\n$$\\left[ \\prod_{t=1}^{T} \\left(1 - \\frac{1}{2N_t}\\right) \\right]^{1/T} = 1 - \\frac{1}{2N_e}$$\n整理各项以分离出 $N_e$：\n$$\\frac{1}{2N_e} = 1 - \\left[ \\prod_{t=1}^{T} \\left(1 - \\frac{1}{2N_t}\\right) \\right]^{1/T}$$\n$$N_e = \\frac{1}{2 \\left( 1 - \\left[ \\prod_{t=1}^{T} \\left(1 - \\frac{1}{2N_t}\\right) \\right]^{1/T} \\right)}$$\n这就是跨越 $T$ 代的近交有效种群规模的通用、精确的闭式表达式。\n\n题目要求我们用 $T=4$ 和种群规模序列 $N_1 = 100$, $N_2 = 1000$, $N_3 = 100$ 及 $N_4 = 1000$ 来计算此表达式的值。\n首先，我们计算乘积项：\n$$\\prod_{t=1}^{4} \\left(1 - \\frac{1}{2N_t}\\right) = \\left(1 - \\frac{1}{2(100)}\\right) \\left(1 - \\frac{1}{2(1000)}\\right) \\left(1 - \\frac{1}{2(100)}\\right) \\left(1 - \\frac{1}{2(1000)}\\right)$$\n$$= \\left(1 - \\frac{1}{200}\\right)^2 \\left(1 - \\frac{1}{2000}\\right)^2 = \\left(\\frac{199}{200}\\right)^2 \\left(\\frac{1999}{2000}\\right)^2 = \\left(\\frac{199 \\cdot 1999}{200 \\cdot 2000}\\right)^2$$\n现在，将其代入 $N_e$ 的表达式中：\n$$N_e = \\frac{1}{2 \\left( 1 - \\left[ \\left(\\frac{199 \\cdot 1999}{200 \\cdot 2000}\\right)^2 \\right]^{1/4} \\right)} = \\frac{1}{2 \\left( 1 - \\left(\\frac{199 \\cdot 1999}{200 \\cdot 2000}\\right)^{1/2} \\right)}$$\n简化表达式：\n$$N_e = \\frac{1}{2 \\left( 1 - \\frac{\\sqrt{199 \\cdot 1999}}{\\sqrt{200 \\cdot 2000}} \\right)} = \\frac{1}{2 \\left( 1 - \\frac{\\sqrt{397801}}{\\sqrt{400000}} \\right)} = \\frac{1}{2 \\left( 1 - \\frac{\\sqrt{397801}}{200\\sqrt{10}} \\right)}$$\n$$N_e = \\frac{1}{\\frac{400\\sqrt{10} - 2\\sqrt{397801}}{200\\sqrt{10}}} = \\frac{200\\sqrt{10}}{400\\sqrt{10} - 2\\sqrt{397801}} = \\frac{100\\sqrt{10}}{200\\sqrt{10} - \\sqrt{397801}}$$\n这就是 $N_e$ 的精确解析表达式。\n\n给定种群规模的算术平均值是 $\\bar{N} = \\frac{100+1000+100+1000}{4} = 550$。有效种群规模（约等于调和平均数，$N_e \\approx 181.9$）则小得多。这是因为近交累积速率与种群规模成反比，所以种群规模小的世代（瓶颈）对遗传多样性的总损失贡献不成比例地大，从而将有效规模拉低到远低于算术平均值的水平。",
            "answer": "$$\\boxed{\\frac{100\\sqrt{10}}{200\\sqrt{10} - \\sqrt{397801}}}$$"
        },
        {
            "introduction": "在掌握了单个种群中的遗传漂变概念后，我们将探讨多个种群之间如何产生遗传分化。本练习模拟了两种核心进化力量之间的平衡：遗传漂变（导致种群间差异）和迁移或基因流（使种群趋于同质化）。你将推导在经典的岛屿模型下，固定指数（$F_{ST}$）的著名平衡关系表达式，从而在种群统计过程和可观测的遗传格局之间建立起定量的联系。",
            "id": "2700067",
            "problem": "一个复合种群由 $n = 20$ 个通过对称岛屿模型迁移连接的亚种群组成。每个亚种群都是二倍体，遵循世代不重叠的理想 Wright–Fisher 繁殖模型，并具有恒定的普查规模 $N = 100$。假设有效种群大小等于普查规模，即 $N_{e} = N$。在每一代，每个亚种群中比例为 $m = 0.01$ 的基因拷贝被从整个复合种群的迁入池中抽取的迁入者所取代。考虑一个中性双等位基因座，其在亚种群 $i$ 中的等位基因频率为 $p_i$，在复合种群中的平均频率为 $\\bar{p}$，并假设在迁移和漂变的时间尺度上，选择和突变均可忽略不计。\n\n从固定指数（F-统计量；$F_{ST}$）作为亚种群间等位基因频率的标准化方差的定义出发，\n$$\nF_{ST} \\equiv \\frac{\\operatorname{Var}(p_{i})}{\\bar{p}\\left(1-\\bar{p}\\right)},\n$$\n并仅使用漂变的基本 Wright–Fisher 抽样方差以及迁移下的等位基因频率的线性混合，推导出在多亚种群、弱迁移极限下的岛屿模型平衡表达式 $F_{ST}$。然后根据给定参数计算预期的 $F_{ST}$。\n\n将最终数值答案四舍五入至四位有效数字，并以纯数字形式报告，不带单位。",
            "solution": "该问题要求在岛屿迁移模型下推导平衡固定指数 $F_{ST}$，并随后根据一组特定参数进行计算。推导将从第一性原理出发，即遗传漂变和迁移对等位基因频率的影响。\n\n设 $p_{i,t}$ 为在第 $t$ 代，亚种群 $i$ 中一个中性双等位基因座上某个等位基因的频率。共有 $n$ 个这样的亚种群，每个亚种群的二倍体大小为 $N$。有效种群大小为 $N_e = N$。整个复合种群的平均等位基因频率为 $\\bar{p} = \\frac{1}{n} \\sum_{i=1}^{n} p_{i,t}$。问题指定了“多亚种群极限”（$n \\to \\infty$），这意味着复合种群的平均等位基因频率 $\\bar{p}$ 可以被视为一个恒定参数，因为任何单个亚种群中的随机波动对全局平均值的影响都可以忽略不计。\n\n从第 $t$ 代到第 $t+1$ 代，等位基因频率的变化分两步发生：先迁移，后遗传漂变。\n\n1.  **迁移**：在每一代中，一个亚种群中比例为 $m$ 的基因拷贝被来自复合种群范围迁入池的迁入者所取代。该池中的等位基因频率是 $\\bar{p}$。迁移后亚种群 $i$ 的等位基因频率，记作 $p'_{i,t}$，是迁移前频率 $p_{i,t}$ 和迁入池频率 $\\bar{p}$ 的加权平均值：\n    $$p'_{i,t} = (1-m)p_{i,t} + m\\bar{p}$$\n\n2.  **遗传漂变**：下一代是通过从亚种群的迁移后基因池中抽取 $2N$ 个基因拷贝而形成的。这是一个二项抽样过程（Wright-Fisher 模型）。第 $t+1$ 代的期望等位基因频率为 $E[p_{i,t+1}|p'_{i,t}] = p'_{i,t}$，由抽样引起的方差为 $\\operatorname{Var}(p_{i,t+1}|p'_{i,t}) = \\frac{p'_{i,t}(1-p'_{i,t})}{2N}$。\n\n我们的目标是找到亚种群间等位基因频率的平衡方差 $V_{eq} = \\operatorname{Var}(p_i)$。设 $V_t = \\operatorname{Var}(p_{i,t}) = E[(p_{i,t} - \\bar{p})^2]$，其中期望是对所有亚种群计算的。我们推导 $V_t$ 的递归关系。\n\n下一代的方差为 $V_{t+1} = E[(p_{i,t+1} - \\bar{p})^2]$。我们使用全期望定律，以迁移后频率 $p'_{i,t}$ 为条件：\n$$V_{t+1} = E_{i} \\left[ E \\left[ (p_{i,t+1} - \\bar{p})^2 | p'_{i,t} \\right] \\right]$$\n内部期望是针对随机漂变过程的。我们展开平方项：\n$$E \\left[ (p_{i,t+1} - \\bar{p})^2 | p'_{i,t} \\right] = E \\left[ ((p_{i,t+1} - p'_{i,t}) + (p'_{i,t} - \\bar{p}))^2 | p'_{i,t} \\right]$$\n$$= E[(p_{i,t+1} - p'_{i,t})^2 | p'_{i,t}] + (p'_{i,t} - \\bar{p})^2 + 2(p'_{i,t} - \\bar{p})E[p_{i,t+1} - p'_{i,t} | p'_{i,t}]$$\n第一项是漂变产生的方差：$\\operatorname{Var}(p_{i,t+1}|p'_{i,t}) = \\frac{p'_{i,t}(1-p'_{i,t})}{2N}$。交叉项为零，因为 $E[p_{i,t+1}|p'_{i,t}] = p'_{i,t}$。因此：\n$$E \\left[ (p_{i,t+1} - \\bar{p})^2 | p'_{i,t} \\right] = \\frac{p'_{i,t}(1-p'_{i,t})}{2N} + (p'_{i,t} - \\bar{p})^2$$\n现在，我们对各亚种群间等位基因频率的分布取外部期望：\n$$V_{t+1} = E_{i} \\left[ \\frac{p'_{i,t}(1-p'_{i,t})}{2N} \\right] + E_{i} \\left[ (p'_{i,t} - \\bar{p})^2 \\right]$$\n第二项是迁移后频率的方差 $\\operatorname{Var}(p'_{i,t})$。根据迁移方程，$\\operatorname{Var}(p'_{i,t}) = \\operatorname{Var}((1-m)p_{i,t} + m\\bar{p})$。由于 $\\bar{p}$ 和 $m$ 是常数，因此该项为 $(1-m)^2 \\operatorname{Var}(p_{i,t}) = (1-m)^2 V_t$。\n\n对于第一项，我们需要计算 $E[p'_{i,t}(1-p'_{i,t})]$。我们知道对于任意随机变量 $X$，$E[X(1-X)] = E[X] - E[X^2]$。\n$E[p'_{i,t}] = E[(1-m)p_{i,t} + m\\bar{p}] = (1-m)E[p_{i,t}] + m\\bar{p} = (1-m)\\bar{p} + m\\bar{p} = \\bar{p}$。\n$E[(p'_{i,t})^2] = \\operatorname{Var}(p'_{i,t}) + (E[p'_{i,t}])^2 = (1-m)^2 V_t + \\bar{p}^2$。\n因此，$E[p'_{i,t}(1-p'_{i,t})] = \\bar{p} - ((1-m)^2 V_t + \\bar{p}^2) = \\bar{p}(1-\\bar{p}) - (1-m)^2 V_t$。\n将这些结果代回到 $V_{t+1}$ 的方程中：\n$$V_{t+1} = \\frac{\\bar{p}(1-\\bar{p}) - (1-m)^2 V_t}{2N} + (1-m)^2 V_t$$\n$$V_{t+1} = \\frac{\\bar{p}(1-\\bar{p})}{2N} + V_t (1-m)^2 \\left(1 - \\frac{1}{2N}\\right)$$\n这是亚种群间方差的精确递归关系。在平衡状态下，减少方差的迁移和增加方差的漂变之间达到平衡。我们设 $V_{t+1} = V_t = V_{eq}$，并求解 $V_{eq}$：\n$$V_{eq} = \\frac{\\bar{p}(1-\\bar{p})}{2N} + V_{eq} (1-m)^2 \\left(1 - \\frac{1}{2N}\\right)$$\n$$V_{eq} \\left[ 1 - (1-m)^2 \\left(1 - \\frac{1}{2N}\\right) \\right] = \\frac{\\bar{p}(1-\\bar{p})}{2N}$$\n问题要求在“弱迁移极限”下求解。这意味着迁移率 $m$ 很小（$m \\ll 1$），并且通常亚种群大小 $N$ 很大（$1/N \\ll 1$）。因此我们可以对方括号中的项进行近似。首先，$(1-m)^2 \\approx 1-2m$。\n$$1 - (1-m)^2 \\left(1 - \\frac{1}{2N}\\right) \\approx 1 - (1-2m)\\left(1 - \\frac{1}{2N}\\right)$$\n$$= 1 - \\left(1 - \\frac{1}{2N} - 2m + \\frac{m}{N}\\right) = 2m + \\frac{1}{2N} - \\frac{m}{N}$$\n由于 $m$ 和 $1/N$ 都很小，乘积项 $m/N$ 是一个更小的量级，可以忽略不计。该表达式简化为 $2m + \\frac{1}{2N}$。\n将此代回平衡方程中：\n$$V_{eq} \\left( 2m + \\frac{1}{2N} \\right) \\approx \\frac{\\bar{p}(1-\\bar{p})}{2N}$$\n$$V_{eq} \\left( \\frac{4Nm + 1}{2N} \\right) \\approx \\frac{\\bar{p}(1-\\bar{p})}{2N}$$\n求解 $V_{eq}$：\n$$V_{eq} \\approx \\frac{\\bar{p}(1-\\bar{p})}{4Nm + 1}$$\n固定指数 $F_{ST}$ 定义为标准化方差：\n$$F_{ST} = \\frac{\\operatorname{Var}(p_i)}{\\bar{p}(1-\\bar{p})} = \\frac{V_{eq}}{\\bar{p}(1-\\bar{p})}$$\n代入我们推导出的 $V_{eq}$ 表达式：\n$$F_{ST} \\approx \\frac{1}{4Nm + 1}$$\n这是在弱迁移和弱漂变条件下，无限岛屿模型中 $F_{ST}$ 的经典平衡表达式。亚种群数量 $n$ 没有出现在这个公式中，因为该模型假设 $n$ 足够大，以至于迁入池实际上是无限的，并且其等位基因频率是恒定的。因此，在指定的“多亚种群极限”假设下，所提供的值 $n=20$ 与计算无关。\n\n现在，我们根据给定的参数计算此表达式的值：$N = N_e = 100$ 和 $m = 0.01$。\n$$F_{ST} \\approx \\frac{1}{4 \\times 100 \\times 0.01 + 1} = \\frac{1}{4 + 1} = \\frac{1}{5} = 0.2$$\n问题要求答案四舍五入到四位有效数字。\n$$F_{ST} = 0.2000$$",
            "answer": "$$\\boxed{0.2000}$$"
        },
        {
            "introduction": "最后的这个练习将理论付诸实践，让你应对一个真实的计算生物学挑战。你将设计并实现一个完整的分析流程，以确定一个进行无性繁殖的海草草甸是由一个还是两个独立的种群构成。这项任务不仅需要应用前序练习中的 $F_{ST}$ 概念，还涉及从样本（分株）中识别独特的遗传个体（基因型），并使用置换检验来评估分化程度的统计显著性——这是现代分子生态学研究的基石。",
            "id": "2700015",
            "problem": "给定您一份从一片草甸中采集的二倍体海草分株（ramet）的多位点基因型数据，该草甸被划分为标记为“A”和“B”的两个空间斑块。由于无性繁殖，一些多位点基因型是重复的。您的任务是设计并实现一个算法，该算法能够 (i) 通过将在指定的基因分型错误容限内无法区分的分株进行聚类，来统计不同基因克隆株（genet）的数量；以及 (ii) 在克隆校正后，通过检验斑块间的遗传分化，来评估这些分株是否属于横跨两个斑块的单一互交群体。\n\n您的设计必须仅基于以下进化遗传学的基本定义和经过充分检验的事实：\n- 一个基因克隆株（genet）是一个由一个或多个分株（ramet）代表的无性繁殖谱系；在多位点基因分型下，基因克隆株在操作上可定义为一个分株集群，在允许的基因分型错误容限内，这些分株的多位点基因型是相同的。\n- 一个多位点基因型是一个由无序等位基因对组成的向量，每个位点对应一对无序等位基因。对于一个位点上的二倍体基因型，其等位基因可以用一个无序多重集 $\\{a,b\\}$ 表示，其中 $a$ 和 $b$ 是表示等位基因状态的整数。\n- 当两个分株在某个位点上的无序等位基因对不同时，就发生了一次错配；两个分株之间的多位点距离是存在错配的位点数。如果两个分株的多位点距离小于或等于指定的容限 $e_{\\max}$（以位点数衡量），则认为它们属于同一个基因克隆株。为确保容限下的传递性，将基因克隆株定义为一个无向图中的连通分量，其中顶点是分株，当距离小于或等于 $e_{\\max}$ 时，顶点之间存在一条边。\n- 为了在克隆校正后评估该草甸是否构成横跨两个斑块的单一群体，使用基因多样性（期望杂合度）来量化斑块间的分化。对于一个位点，如果等位基因 $i$ 的频率是 $p_i$，那么基因多样性为 $H = 1 - \\sum_i p_i^2$。设 $H_T$ 为跨斑块合并后的总基因多样性，而 $H_S$ 为斑块内基因多样性的样本量加权平均值。对于一个信息性位点（$H_T > 0$），定义 $F_{ST}^{(\\ell)} = (H_T - H_S)/H_T$。对所有 $H_T > 0$ 的位点上的 $F_{ST}^{(\\ell)}$ 进行平均，以获得多位点 $F_{ST}$。\n- 为检验两个斑块构成单一群体的零假设，通过在克隆校正后的基因克隆株之间随机置换斑块标签，来进行置换检验，以生成多位点 $F_{ST}$ 的零分布。经验 p 值为 $(1 + \\#\\{\\text{permuted } F_{ST} \\ge F_{ST}^{\\text{obs}}\\})/(1 + R)$，其中 $R$ 是置换次数。\n\n您的程序必须：\n- 将每个分株的多位点基因型表示为一个无序等位基因对的列表。每个等位基因是一个整数。两个分株之间的基因型距离是它们的无序等位基因对不同的位点数。\n- 通过使用指定的 $e_{\\max}$ 构建上述定义的图，并计算其连通分量，将分株聚类为基因克隆株。为了在下游分析中进行克隆校正，从每个分量中任意选择一个分株来代表该基因克隆株。\n- 使用上述定义，在克隆校正过的数据集上计算斑块间的多位点 $F_{ST}$，对所有 $H_T > 0$ 的位点进行平均。\n- 执行包含 $R$ 次置换的置换检验，以获得在单一群体零假设下的经验 p 值。使用固定的随机种子以确保结果可复现。\n- 如果经验 p 值大于或等于 $\\alpha$，则判定该草甸构成单一群体。\n\n不涉及角度单位和物理单位。所有报告的比例必须是小数，而不是百分比。报告的 $F_{ST}$ 值需四舍五入到 $6$ 位小数，p 值需四舍五入到 $4$ 位小数。\n\n测试套件。您的程序必须硬编码并分析以下 $4$ 个测试用例。每个测试用例都指定了位点数 $L$、一个包含分株多位点基因型和斑块标签的列表、容限 $e_{\\max}$（以位点数计）、置换次数 $R$、显著性阈值 $\\alpha$ 以及所需的输出。\n\n- 测试用例 1（重复的多位点基因型，低分化）：\n  - $L = 4$。\n  - 分株按顺序列出为 $\\big($基因型, 斑块$\\big)$：\n    1. $([(10,11),(20,20),(31,31),(40,41)], \\text{A})$\n    2. $([(10,11),(20,21),(31,31),(40,41)], \\text{A})$\n    3. $([(10,10),(20,21),(30,31),(40,40)], \\text{A})$\n    4. $([(11,11),(20,21),(31,32),(41,41)], \\text{B})$\n    5. $([(11,11),(20,21),(31,32),(41,41)], \\text{B})$\n    6. $([(10,11),(21,21),(30,30),(41,41)], \\text{B})$\n    7. $([(10,11),(20,21),(31,31),(40,41)], \\text{A})$\n    8. $([(10,11),(20,21),(30,32),(40,41)], \\text{B})$\n    9. $([(10,11),(20,21),(31,31),(40,41)], \\text{A})$\n    10. $([(10,10),(20,20),(31,32),(41,41)], \\text{B})$\n  - $e_{\\max} = 1$。\n  - $R = 499$，$\\alpha = 0.05$。\n  - 输出：基因克隆株数量 $G$、多位点 $F_{ST}$、p 值，以及一个布尔决策。\n\n- 测试用例 2（斑块间存在强分化，基因型重复）：\n  - $L = 4$。\n  - 分株：\n    1. $([(10,10),(20,20),(30,30),(40,40)], \\text{A})$\n    2. $([(10,11),(20,20),(30,30),(40,40)], \\text{A})$\n    3. $([(10,10),(20,20),(30,31),(40,40)], \\text{A})$\n    4. $([(10,10),(20,20),(30,30),(40,40)], \\text{A})$\n    5. $([(12,12),(22,22),(33,33),(43,43)], \\text{B})$\n    6. $([(12,12),(22,22),(33,33),(43,43)], \\text{B})$\n    7. $([(12,12),(22,22),(33,34),(43,43)], \\text{B})$\n    8. $([(12,12),(22,22),(33,33),(43,44)], \\text{B})$\n  - $e_{\\max} = 0$。\n  - $R = 499$，$\\alpha = 0.05$。\n  - 输出：$G$、多位点 $F_{ST}$、p 值、布尔决策。\n\n- 测试用例 3（边缘情况：所有分株在斑块间的基因型完全相同）：\n  - $L = 4$。\n  - 分株：\n    1. $([(5,5),(6,6),(7,7),(8,8)], \\text{A})$\n    2. $([(5,5),(6,6),(7,7),(8,8)], \\text{A})$\n    3. $([(5,5),(6,6),(7,7),(8,8)], \\text{B})$\n    4. $([(5,5),(6,6),(7,7),(8,8)], \\text{B})$\n  - $e_{\\max} = 0$。\n  - $R = 499$，$\\alpha = 0.05$。\n  - 注意：对于任何 $H_T = 0$ 的位点，在计算多位点平均值时将其排除。如果所有位点都是 $H_T = 0$，则按惯例将多位点 $F_{ST}$ 定义为 $0$，并报告 p 值为 $1$。\n  - 输出：$G$、多位点 $F_{ST}$、p 值、布尔决策。\n\n- 测试用例 4（临界情况，小样本量和轻微分化）：\n  - $L = 4$。\n  - 分株：\n    1. $([(100,101),(200,200),(300,301),(400,400)], \\text{A})$\n    2. $([(100,100),(200,201),(300,300),(400,401)], \\text{A})$\n    3. $([(100,101),(200,201),(300,301),(400,401)], \\text{B})$\n    4. $([(100,101),(200,200),(300,301),(400,401)], \\text{B})$\n  - $e_{\\max} = 0$。\n  - $R = 499$，$\\alpha = 0.05$。\n  - 输出：$G$、多位点 $F_{ST}$、p 值、布尔决策。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个测试用例的结果，结果形式为一个逗号分隔的列表，并用方括号括起来。每个测试用例的结果本身必须是一个形式为 $[G, F_{ST}, p, \\text{decision}]$ 的列表，其中 $G$ 是一个整数，$F_{ST}$ 和 $p$ 是按规定四舍五入的浮点数，而 $\\text{decision}$ 是一个布尔值。例如：$[[2,0.012345,0.1234,True],[...],[...],[...]]$.",
            "solution": "所提出的问题是一个定义明确且具有科学依据的计算种群遗传学练习。它要求实施一套分析克隆种群的标准工作流程：首先，在存在体细胞突变或基因分型错误的情况下，从采样的组织（分株）中识别独特的遗传个体（基因克隆株）；其次，通过量化预定义斑块间的遗传分化来评估种群结构。所提供的定义和方法，包括通过图聚类进行基因克隆株识别、Wright 的 F-统计量（$F_{ST}$）的计算，以及使用置换检验进行假设检验，在进化生物学领域都是标准且正确的。该问题是有效的，并且可以通过一个系统的、基于原则的算法来构建解决方案。\n\n根据问题陈述，算法设计被划分为三个主要的逻辑部分。\n\n**I. 基因克隆株识别与克隆校正**\n\n一个基因克隆株（遗传个体）在克隆生物中可能由多个分株代表。由于潜在的基因分型错误或体细胞突变，来自同一基因克隆株的分株可能不具有完全相同的多位点基因型。问题通过定义一个距离容限 $e_{\\max}$ 来解决此问题。\n\n1.  **基因型表示与距离**：每个二倍体多位点基因型是一个无序等位基因对的向量。一个单位点的等位基因对，如 $\\{a, b\\}$，是一个多重集。这对于区分纯合子 $\\{a, a\\}$ 和杂合子 $\\{a, b\\}$ 至关重要。为了便于比较，每个等位基因对被转换为一种规范表示，例如频率图或排序后的元组。在本实现中，使用了多重集表示。两个多位点基因型 $G_1$ 和 $G_2$ 之间的距离 $d(G_1, G_2)$ 定义为它们相应等位基因对不相同的位点数：\n    $$\n    d(G_1, G_2) = \\sum_{l=1}^{L} \\mathbb{I}(G_{1,l} \\neq G_{2,l})\n    $$\n    其中 $L$ 是位点数，$\\mathbb{I}(\\cdot)$ 是指示函数。\n\n2.  **基于图的聚类**：为了识别基因克隆株，我们构建一个无向图 $\\mathcal{G} = (V, E)$，其中顶点集 $V$ 代表采集到的分株集合。当且仅当两个分株 $u$ 和 $v$ 的基因型距离小于或等于指定容限时，即 $d(G_u, G_v) \\le e_{\\max}$，它们之间存在一条边 $(u, v) \\in E$。\n\n3.  **连通分量**：一个基因克隆株在操作上被定义为图 $\\mathcal{G}$ 中的一个连通分量。这个定义正确地确保了传递性：如果分株 A 在遗传上与 B 相近，而 B 与 C 相近，那么无论 A 和 C 之间的直接距离如何，A、B 和 C 都属于同一个基因克隆株。基因克隆株的数量 $G$ 是 $\\mathcal{G}$ 中连通分量的数量。这些分量可以使用标准的图遍历算法（如广度优先搜索（BFS）或深度优先搜索（DFS））找到。\n\n4.  **克隆校正**：对于后续的种群遗传学分析，有必要通过仅包含每个基因克隆株一次来避免伪重复。这是通过克隆校正实现的。从每个识别出的连通分量（基因克隆株）中，任意选择一个代表性分株。后续分析的数据集由这些代表性基因克隆株的基因型和斑块标签组成。\n\n**II. 使用 $F_{ST}$ 量化遗传分化**\n\n统计量 $F_{ST}$ 用于在克隆校正过的数据上测量两个斑块“A”和“B”之间的遗传分化。\n\n1.  **基因多样性**：分析基于基因多样性（期望杂合度）$H$。对于一个给定群体中某个位点，其中等位基因 $i = 1, \\dots, k$ 的频率为 $p_i$，基因多样性为：\n    $$\n    H = 1 - \\sum_{i=1}^{k} p_i^2\n    $$\n    等位基因频率通过统计代表性基因克隆株的二倍体基因型中的等位基因来计算。一个基因型为 $\\{a,b\\}$ 的基因克隆株向基因库贡献一个等位基因 $a$ 和一个等位基因 $b$。\n\n2.  **层级多样性**：我们为每个位点 $\\ell$ 在三个层面上计算基因多样性：\n    -   $H_A^{(\\ell)}$ 和 $H_B^{(\\ell)}$：分别为斑块“A”和斑块“B”内部的基因多样性。\n    -   $H_T^{(\\ell)}$：总基因多样性，由来自两个斑块的所有代表性基因克隆株构成的合并群体中的等位基因频率计算得出。\n    -   $H_S^{(\\ell)}$：亚群基因多样性的平均值，计算为斑块内多样性的加权平均值，权重为每个斑块中的基因克隆株数量（$n_A$ 和 $n_B$）：\n        $$\n        H_S^{(\\ell)} = \\frac{n_A H_A^{(\\ell)} + n_B H_B^{(\\ell)}}{n_A + n_B}\n        $$\n\n3.  **多位点 $F_{ST}$**：单位点 $\\ell$ 的固定指数 $F_{ST}^{(\\ell)}$ 计算为总遗传方差中由斑块间差异引起的部分：\n    $$\n    F_{ST}^{(\\ell)} = \\frac{H_T^{(\\ell)} - H_S^{(\\ell)}}{H_T^{(\\ell)}}\n    $$\n    此计算仅对 $H_T^{(\\ell)} > 0$ 的位点进行，因为在单态位点上无法测量分化。总的多位点 $F_{ST}$ 是所有信息性位点的单位点 $F_{ST}^{(\\ell)}$ 值的算术平均值。如果没有信息性位点（所有 $H_T^{(\\ell)} = 0$），则按惯例将多位点 $F_{ST}$ 定义为 $0$。\n\n**III. 通过置换进行假设检验**\n\n采用置换检验来评估观测到的 $F_{ST}$ 值的统计显著性。零假设 $H_0$ 是，两个斑块的分株都来自一个单一的、随机交配的种群（即不存在显著的遗传结构）。\n\n1.  **观测统计量**：首先，从原始的克隆校正数据计算多位点 $F_{ST}^{\\text{obs}}$。\n\n2.  **生成零分布**：通过模拟 $H_0$ 下的情景来生成 $F_{ST}$ 的零分布。这是通过在代表性基因克隆株之间随机置换斑块标签（“A”或“B”）来实现的。对于 $R$ 次置换中的每一次：\n    -   创建一个具有原始基因型但斑块标签已打乱的新数据集。\n    -   为这个置换后的数据集计算一个多位点 $F_{ST}^{\\text{perm}}$。\n\n3.  **经验 p 值**：经验 p 值是在零假设下观测到大于或等于 $F_{ST}^{\\text{obs}}$ 的 $F_{ST}$ 值的概率。其计算公式为：\n    $$\n    p = \\frac{1 + N_{\\ge}}{1 + R}\n    $$\n    其中 $N_{\\ge}$ 是 $F_{ST}^{\\text{perm}} \\ge F_{ST}^{\\text{obs}}$ 的置换次数。在分子和分母上加 1 是为了防止 p 值为 0，并考虑到观测数据本身也是零假设下的一个可能结果。\n\n4.  **决策**：如果得到的 p 值大于或等于显著性水平 $\\alpha$，则不拒绝零假设。在这种情况下，我们得出结论，数据与两个斑块属于单一互交群体的情况相符。否则，如果 $p < \\alpha$，我们拒绝 $H_0$，并断定斑块之间存在显著的遗传分化。为保证可复现性，用于置换的随机数生成器使用固定的种子进行初始化。",
            "answer": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    \n    # Test case 1 data\n    tc1_ramets = [\n        ([(10, 11), (20, 20), (31, 31), (40, 41)], 'A'),\n        ([(10, 11), (20, 21), (31, 31), (40, 41)], 'A'),\n        ([(10, 10), (20, 21), (30, 31), (40, 40)], 'A'),\n        ([(11, 11), (20, 21), (31, 32), (41, 41)], 'B'),\n        ([(11, 11), (20, 21), (31, 32), (41, 41)], 'B'),\n        ([(10, 11), (21, 21), (30, 30), (41, 41)], 'B'),\n        ([(10, 11), (20, 21), (31, 31), (40, 41)], 'A'),\n        ([(10, 11), (20, 21), (30, 32), (40, 41)], 'B'),\n        ([(10, 11), (20, 21), (31, 31), (40, 41)], 'A'),\n        ([(10, 10), (20, 20), (31, 32), (41, 41)], 'B')\n    ]\n\n    # Test case 2 data\n    tc2_ramets = [\n        ([(10, 10), (20, 20), (30, 30), (40, 40)], 'A'),\n        ([(10, 11), (20, 20), (30, 30), (40, 40)], 'A'),\n        ([(10, 10), (20, 20), (30, 31), (40, 40)], 'A'),\n        ([(10, 10), (20, 20), (30, 30), (40, 40)], 'A'),\n        ([(12, 12), (22, 22), (33, 33), (43, 43)], 'B'),\n        ([(12, 12), (22, 22), (33, 33), (43, 43)], 'B'),\n        ([(12, 12), (22, 22), (33, 34), (43, 43)], 'B'),\n        ([(12, 12), (22, 22), (33, 33), (43, 44)], 'B')\n    ]\n\n    # Test case 3 data\n    tc3_ramets = [\n        ([(5, 5), (6, 6), (7, 7), (8, 8)], 'A'),\n        ([(5, 5), (6, 6), (7, 7), (8, 8)], 'A'),\n        ([(5, 5), (6, 6), (7, 7), (8, 8)], 'B'),\n        ([(5, 5), (6, 6), (7, 7), (8, 8)], 'B')\n    ]\n\n    # Test case 4 data\n    tc4_ramets = [\n        ([(100, 101), (200, 200), (300, 301), (400, 400)], 'A'),\n        ([(100, 100), (200, 201), (300, 300), (400, 401)], 'A'),\n        ([(100, 101), (200, 201), (300, 301), (400, 401)], 'B'),\n        ([(100, 101), (200, 200), (300, 301), (400, 401)], 'B')\n    ]\n\n    test_cases = [\n        {'L': 4, 'ramets': tc1_ramets, 'e_max': 1, 'R': 499, 'alpha': 0.05},\n        {'L': 4, 'ramets': tc2_ramets, 'e_max': 0, 'R': 499, 'alpha': 0.05},\n        {'L': 4, 'ramets': tc3_ramets, 'e_max': 0, 'R': 499, 'alpha': 0.05},\n        {'L': 4, 'ramets': tc4_ramets, 'e_max': 0, 'R': 499, 'alpha': 0.05}\n    ]\n\n    results = []\n    \n    # Use a fixed seed for reproducibility of permutation test\n    RANDOM_SEED = 42\n\n    for case in test_cases:\n        result = _process_test_case(case['L'], case['ramets'], case['e_max'], case['R'], case['alpha'], RANDOM_SEED)\n        results.append(result)\n\n    # Format the final output as a single string\n    output_str = \"[\" + \",\".join([f\"[{G},{fst:.6f},{p:.4f},{str(d)}]\" for G, fst, p, d in results]) + \"]\"\n    print(output_str)\n\ndef _process_test_case(L, ramets, e_max, R, alpha, seed):\n    \"\"\"\n    Processes a single test case from start to finish.\n    \"\"\"\n    canonical_ramets = []\n    for genotype, patch in ramets:\n        # Convert genotypes to a list of Counters for easy comparison of unordered pairs\n        canon_geno = [Counter(g) for g in genotype]\n        canonical_ramets.append((canon_geno, patch))\n    \n    # Step 1: Identify genets and perform clone correction\n    G, clone_corrected_data = _identify_genets(canonical_ramets, e_max, L)\n\n    # Handle special case where Fst cannot be meaningfully computed\n    # If all genets are identical, Ht=0 for all loci where the single genet is homozygous.\n    # The problem specifies Fst=0 and p=1 if all Ht=0.\n    # This occurs here if G=1 and the single genet is homozygous at all loci.\n    is_monomorphic_system = True\n    if len(clone_corrected_data) > 1:\n        first_genotype = clone_corrected_data[0][0]\n        for genotype, _ in clone_corrected_data[1:]:\n            if genotype != first_genotype:\n                is_monomorphic_system = False\n                break\n\n    if is_monomorphic_system:\n         # Check if all loci are homozygous\n         all_homozygous = True\n         if clone_corrected_data:\n             geno = clone_corrected_data[0][0]\n             for locus_geno in geno:\n                 if len(locus_geno) > 1: # More than one unique allele\n                     all_homozygous = False\n                     break\n         if all_homozygous:\n             fst, p_val = 0.0, 1.0\n             decision = p_val >= alpha\n             return [G, fst, p_val, decision]\n\n\n    # Step 2 & 3: Calculate Fst and perform permutation test\n    fst, p_val = _perform_permutation_test(clone_corrected_data, L, R, seed)\n    \n    # Step 4: Make a decision\n    decision = p_val >= alpha\n    \n    return [G, fst, p_val, decision]\n\ndef _calculate_distance(geno1, geno2, L):\n    \"\"\"Calculates the multilocus distance between two canonical genotypes.\"\"\"\n    mismatches = 0\n    for i in range(L):\n        if geno1[i] != geno2[i]:\n            mismatches += 1\n    return mismatches\n\ndef _identify_genets(ramets_data, e_max, L):\n    \"\"\"Identifies genets by finding connected components in the ramet graph.\"\"\"\n    num_ramets = len(ramets_data)\n    adj = [[0] * num_ramets for _ in range(num_ramets)]\n    \n    for i in range(num_ramets):\n        for j in range(i, num_ramets):\n            dist = _calculate_distance(ramets_data[i][0], ramets_data[j][0], L)\n            if dist <= e_max:\n                adj[i][j] = adj[j][i] = 1\n\n    visited = [False] * num_ramets\n    num_genets = 0\n    representatives = []\n    \n    for i in range(num_ramets):\n        if not visited[i]:\n            num_genets += 1\n            # Add the first unvisited ramet of a component as the representative\n            representatives.append(ramets_data[i])\n            \n            # Use BFS to find all ramets in the same component\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head < len(q):\n              u = q[head]\n              head += 1\n              for v in range(num_ramets):\n                  if adj[u][v] and not visited[v]:\n                      visited[v] = True\n                      q.append(v)\n                      \n    return num_genets, representatives\n\ndef _calculate_fst(data, L):\n    \"\"\"Calculates multilocus Fst from clone-corrected data.\"\"\"\n    locus_fsts = []\n    \n    for l in range(L):\n        alleles_A, alleles_B = [], []\n        n_A, n_B = 0, 0\n        \n        for genotype, patch in data:\n            allele_pair = list(genotype[l].elements())\n            if patch == 'A':\n                alleles_A.extend(allele_pair)\n                n_A += 1\n            else:\n                alleles_B.extend(allele_pair)\n                n_B += 1\n        \n        alleles_T = alleles_A + alleles_B\n        \n        if not alleles_T: continue # No data for this locus\n        \n        counts_T = Counter(alleles_T)\n        num_alleles_T = len(alleles_T)\n        if num_alleles_T == 0: continue\n        sum_sq_freq_T = sum((c / num_alleles_T) ** 2 for c in counts_T.values())\n        H_T = 1 - sum_sq_freq_T\n        \n        if H_T > 0:\n            # Calculate H_A\n            num_alleles_A = len(alleles_A)\n            if num_alleles_A > 0:\n                counts_A = Counter(alleles_A)\n                sum_sq_freq_A = sum((c / num_alleles_A) ** 2 for c in counts_A.values())\n                H_A = 1 - sum_sq_freq_A\n            else:\n                H_A = 0\n\n            # Calculate H_B\n            num_alleles_B = len(alleles_B)\n            if num_alleles_B > 0:\n                counts_B = Counter(alleles_B)\n                sum_sq_freq_B = sum((c / num_alleles_B) ** 2 for c in counts_B.values())\n                H_B = 1 - sum_sq_freq_B\n            else:\n                H_B = 0\n            \n            n_T = n_A + n_B\n            if n_T == 0: continue\n            \n            H_S = (n_A * H_A + n_B * H_B) / n_T\n            \n            fst_locus = (H_T - H_S) / H_T\n            locus_fsts.append(fst_locus)\n            \n    if not locus_fsts:\n        return 0.0\n    \n    return np.mean(locus_fsts)\n\ndef _perform_permutation_test(data, L, R, seed):\n    \"\"\"Performs a permutation test to get Fst_obs and p-value.\"\"\"\n    if not data:\n        return 0.0, 1.0\n\n    fst_obs = _calculate_fst(data, L)\n    \n    # If observed Fst is 0 (e.g., all genets identical), p-value is 1.\n    is_obs_zero = np.isclose(fst_obs, 0.0)\n    \n    genotypes = [d[0] for d in data]\n    patch_labels = np.array([d[1] for d in data])\n    \n    rng = np.random.default_rng(seed)\n    \n    ge_count = 0\n    for _ in range(R):\n        permuted_labels = rng.permutation(patch_labels)\n        permuted_data = list(zip(genotypes, permuted_labels))\n        fst_perm = _calculate_fst(permuted_data, L)\n        \n        if fst_perm >= fst_obs or (is_obs_zero and np.isclose(fst_perm, 0.0)):\n             ge_count += 1\n            \n    p_value = (ge_count + 1) / (R + 1)\n    \n    return fst_obs, p_value\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}