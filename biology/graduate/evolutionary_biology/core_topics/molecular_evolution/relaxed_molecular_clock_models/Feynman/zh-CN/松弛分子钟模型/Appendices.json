{
    "hands_on_practices": [
        {
            "introduction": "在深入研究更为复杂的松散分子钟模型之前，掌握严格分子钟的基本原理至关重要。该模型假设进化速率在所有谱系和时间上都是恒定的，这意味着遗传距离与分化时间成正比。通过这个练习，您将练习在理想化的严格时钟假设下计算全局替换率和节点年龄等基本参数，从而巩固松散时钟模型所基于的核心概念。",
            "id": "2749326",
            "problem": "一个四分类单元超度量系统发育树在严格分子钟下关联了分类单元 $A$、$B$、$C$ 和 $D$。其拓扑结构为 $((A,B),(C,D))$，并且该树是超度量的，所有末端到根的总时间 $T$ 均相同。单个校准将根节点（所有四个分类单元的最近共同祖先 (MRCA)）的年龄固定在 $T_{\\mathrm{root}} = 12$ 百万年 (Myr)。沿着从现在到根的每条路径，分支时长（单位：百万年）如下：\n- 对于分类单元 $A$ 和 $B$：从其支系 MRCA 到末端的每个悬挂分支时长为 $7$，从该支系 MRCA 到根的内部分支时长为 $5$。\n- 对于分类单元 $C$ 和 $D$：从其支系 MRCA 到末端的每个悬挂分支时长为 $8$，从该支系 MRCA 到根的内部分支时长为 $4$。\n根据构造，该树是超度量的，因为 $7+5=12$ 和 $8+4=12$。\n\n根据 Jukes-Cantor (JC69) 模型分析的比对结果，估计沿每条完整末端到根路径的校正距离为 $d_{A}=0.84$、$d_{B}=0.84$、$d_{C}=0.84$ 和 $d_{D}=0.84$ 个替换/位点。\n\n假设存在一个严格分子钟，具有单一的全局速率 $r$（单位：替换/位点/百万年），因此在任何谱系上，经过时长 $\\Delta t$ 累积的每位点预期替换数与时间成线性关系，比例常数为 $r$。在 JC69 模型下，校正后的路径距离等于沿该路径累积的每位点预期总替换数。\n\n计算：\n1. 全局速率 $r$（单位：替换/位点/百万年）。\n2. 两个内部节点的年龄（单位：百万年前）：$(A,B)$ 的 MRCA 和 $(C,D)$ 的 MRCA。\n\n按 $\\big(r, \\text{age}_{(A,B)}, \\text{age}_{(C,D)}\\big)$ 的顺序报告你的三个值。将答案四舍五入到三位有效数字。$r$ 的单位为替换/位点/百万年，节点年龄的单位为百万年。在最终报告的元组中不要包含单位。",
            "solution": "**求解过程**\n\n问题要求计算三个值：全局替换速率 $r$，以及两个内部节点的年龄，即支系 $(A,B)$ 和 $(C,D)$ 的最近共同祖先（MRCA）的年龄。\n\n**1. 计算全局速率 $r$**\n在严格分子钟下，沿谱系累积的预期遗传距离 $d$（单位：替换/位点）与时间 $T$（单位：百万年）成正比。比例常数是替换速率 $r$（单位：替换/位点/百万年）。该关系表示为：\n$$d = r \\times T$$\n问题指出，从根到任何末端的总时间为 $T = 12$ 百万年。它还提供了任何根到末端路径对应的校正遗传距离为 $d = 0.84$ 替换/位点。因此，我们可以求解速率 $r$：\n$$r = \\frac{d}{T}$$\n代入给定值：\n$$r = \\frac{0.84}{12} \\text{ 替换/位点/百万年}$$\n$$r = 0.07 \\text{ 替换/位点/百万年}$$\n问题要求答案四舍五入到三位有效数字。用标准科学记数法表示为：\n$$r = 7.00 \\times 10^{-2} \\text{ 替换/位点/百万年}$$\n\n**2. 计算节点年龄**\n在系统发育树中，节点的年龄定义为从该节点到现在的时间。树的末端代表现在，可以设为时间 $0$。\n\n**A. $(A,B)$ 的 MRCA 的年龄**\n问题指出，对于分类单元 $A$ 和 $B$，从它们的 MRCA 到末端的悬挂分支时长为 $7$ 百万年。根据定义，该时长代表了从 MRCA 事件到现在的流逝时间。因此，$(A,B)$ 的 MRCA 的年龄为：\n$$\\text{age}_{(A,B)} = 7 \\text{ 百万年}$$\n这可以使用内部分支信息进行验证。根节点的年龄为 $12$ 百万年。连接根节点与 $(A,B)$ 的 MRCA 的内部分支时长为 $5$ 百万年。节点的年龄是其父节点的年龄减去连接分支的时长：\n$$\\text{age}_{(A,B)} = T_{\\mathrm{root}} - \\Delta t_{\\text{internal}, (A,B)} = 12 - 5 = 7 \\text{ 百万年}$$\n数值是一致的。保留三位有效数字，年龄为 $7.00$ 百万年。\n\n**B. $(C,D)$ 的 MRCA 的年龄**\n同样，对于分类单元 $C$ 和 $D$，从它们的 MRCA 到末端的悬挂分支时长为 $8$ 百万年。该时长就是节点的年龄。\n$$\\text{age}_{(C,D)} = 8 \\text{ 百万年}$$\n使用 $4$ 百万年的内部分支时长进行验证：\n$$\\text{age}_{(C,D)} = T_{\\mathrm{root}} - \\Delta t_{\\text{internal}, (C,D)} = 12 - 4 = 8 \\text{ 百万年}$$\n数值再次一致。保留三位有效数字，年龄为 $8.00$ 百万年。\n\n**最终值**\n按指定顺序 $\\big(r, \\text{age}_{(A,B)}, \\text{age}_{(C,D)}\\big)$ 并四舍五入到三位有效数字的所求值为：\n- $r = 7.00 \\times 10^{-2}$\n- $\\text{age}_{(A,B)} = 7.00$\n- $\\text{age}_{(C,D)} = 8.00$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n7.00 \\times 10^{-2} & 7.00 & 8.00\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "松散分子钟模型，尤其是非相关对数正态 (UCLN) 模型，允许进化速率在整个系统发育树中变化。在实践中，一个关键环节是通过校准先验（calibration priors）整合化石证据。本练习将通过一个编程任务，让您亲身体验不同强度（从宽松到严格）的校准先验如何影响节点年龄和速率等参数的后验估计。通过实现一个简化的最大后验 ($MAP$) 估计，您将深入理解序列数据似然与先验证据之间的权衡，并认识到先验设定在分子定年分析中的决定性作用。",
            "id": "2749338",
            "problem": "在一个不相关对数正态(UCLN)宽松分子钟模型下，我们考虑一个包含$5$个分类单元的有根系统发育树。目标是使用一个简化的枝长观测模型和一个固定的拓扑结构，评估一个对根节点年龄带有软性最大值界限的校准先验如何影响速率和年龄的后验众数。你编写的程序必须通过求解一个约束优化问题，为多种校准设置计算根节点年龄的后验众数（最大后验概率，MAP）和平均分支速率的后验众数。\n\n基本原理如下。\n\n- 替换沿着一个分支的累积量是瞬时速率与所用时间的乘积，因此期望枝长（单位：每位点替换数）等于速率乘以时间。对于速率为 $r_i$、持续时间为 $d_i$ 的单个分支 $i$，其期望长度为 $r_i d_i$。\n- 对于一个枝长持续时间由节点年龄决定的固定拓扑结构，观测到的枝长 $\\{b_i\\}$ 被视为期望长度的带噪声测量值。在多位点近似（中心极限定理）下，使用高斯观测模型：\n  $$b_i \\mid r_i, d_i \\sim \\mathcal{N}(r_i d_i, \\sigma^2),$$\n  其中方差 $\\sigma^2$ 已知并在所有分支上共享。\n- 在不相关对数正态(UCLN)模型下，各分支的特异性速率是独立的，且服从对数正态分布：\n  $$\\log r_i \\sim \\mathcal{N}(\\mu_r, s_r^2),$$\n  对每个分支 $i$ 都独立。\n- 根节点年龄 $t_R$ 有一个对数正态基础先验\n  $$\\log t_R \\sim \\mathcal{N}(\\mu_T, s_T^2),$$ \n  并乘以一个在最大值为 $M$ 处的软性最大值界限惩罚项\n  $$w(t_R; M, k) = \\exp\\!\\big(-k \\cdot \\max(0, t_R - M)\\big),$$ \n  其中 $k$ 控制软性界限的强度。其他内部节点的年龄在由树的顺序约束定义的可行域上具有弥散均匀先验。\n\n树的拓扑结构和参数化。\n\n- 有根二分拓扑结构为 $((A,B),(C,(D,E)))$，根节点为 $R$，内部节点为 $X=\\text{MRCA}(A,B)$，$Y=\\text{MRCA}(D,E)$，$Z=\\text{MRCA}(C,Y)$。\n- 设节点 $R$、$X$、$Z$ 和 $Y$ 的年龄分别为 $t_R$、$t_{AB}$、$t_{CDE}$ 和 $t_{DE}$。叶尖年龄为 $0$。约束条件为\n  $$t_R \\ge t_{AB} \\ge 0,\\quad t_R \\ge t_{CDE} \\ge t_{DE} \\ge 0.$$\n- $8$个分支及其持续时间如下：\n  - 分支1：$R \\to X$，持续时间为 $d_1 = t_R - t_{AB}$。\n  - 分支2：$R \\to Z$，持续时间为 $d_2 = t_R - t_{CDE}$。\n  - 分支3：$X \\to A$，持续时间为 $d_3 = t_{AB} - 0$。\n  - 分支4：$X \\to B$，持续时间为 $d_4 = t_{AB} - 0$。\n  - 分支5：$Z \\to C$，持续时间为 $d_5 = t_{CDE} - 0$。\n  - 分支6：$Z \\to Y$，持续时间为 $d_6 = t_{CDE} - t_{DE}$。\n  - 分支7：$Y \\to D$，持续时间为 $d_7 = t_{DE} - 0$。\n  - 分支8：$Y \\to E$，持续时间为 $d_8 = t_{DE} - 0$。\n\n数据和超参数。\n\n- 观测到的枝长（单位：每位点替换数）固定为\n  $$\\mathbf{b} = (b_1,\\dots,b_8) = (0.0044,\\, 0.0019,\\, 0.0063,\\, 0.0060,\\, 0.0096,\\, 0.0045,\\, 0.0030,\\, 0.00255).$$\n- 观测噪声的标准差为 $\\sigma = 0.0002$（因此方差为 $\\sigma^2 = 4\\times 10^{-8}$）。\n- UCLN速率先验参数为 $\\mu_r = \\log(0.01)$ 和 $s_r = 0.25$。\n- 根节点年龄的基础对数正态先验参数为 $\\mu_T = \\log(1.0) = 0$ 和 $s_T = 0.5$。\n\n后验和优化。\n\n- 设 $\\mathbf{r} = (r_1,\\dots,r_8)$ 和 $\\mathbf{t} = (t_R,t_{AB},t_{CDE},t_{DE})$。后验密度（在不考虑不依赖于变量的归一化常数的情况下）为\n  $$p(\\mathbf{r}, \\mathbf{t} \\mid \\mathbf{b}) \\propto \\left[\\prod_{i=1}^8 \\exp\\!\\left(-\\frac{(b_i - r_i d_i)^2}{2 \\sigma^2}\\right)\\right] \\cdot \\left[\\prod_{i=1}^8 \\frac{1}{r_i} \\exp\\!\\left(-\\frac{(\\log r_i - \\mu_r)^2}{2 s_r^2}\\right)\\right] \\cdot \\frac{1}{t_R}\\exp\\!\\left(-\\frac{(\\log t_R - \\mu_T)^2}{2 s_T^2}\\right)\\cdot w(t_R;M,k),$$\n  其受制于对 $\\mathbf{t}$ 的树顺序约束和对 $\\mathbf{r}$ 的正值约束。你的程序应通过最小化负对数后验，为每个校准设置 $(M,k)$ 计算联合MAP $(\\mathbf{r}^\\star, \\mathbf{t}^\\star)$。\n- 需要最小化的负对数后验（舍去不依赖于参数的加性常数）是\n  $$\\mathcal{L}(\\mathbf{r}, \\mathbf{t}) = \\sum_{i=1}^8 \\frac{(b_i - r_i d_i)^2}{2 \\sigma^2} + \\sum_{i=1}^8 \\left[\\frac{(\\log r_i - \\mu_r)^2}{2 s_r^2} + \\log r_i\\right] + \\left[\\frac{(\\log t_R - \\mu_T)^2}{2 s_T^2} + \\log t_R\\right] + k \\cdot \\max(0, t_R - M),$$\n  约束条件为 $t_R \\ge t_{AB} \\ge 0$, $t_R \\ge t_{CDE} \\ge t_{DE} \\ge 0$ 以及对所有 $i$ 有 $r_i > 0$。\n\n任务。\n\n- 实现一个约束优化，为测试套件中的每个校准对 $(M,k)$ 获得联合MAP。\n- 对于每个MAP解，提取：\n  - 根节点年龄的后验众数 $t_R^\\star$（单位：时间单位），以及\n  - 平均分支速率的后验众数 $\\bar{r}^\\star = \\frac{1}{8}\\sum_{i=1}^8 r_i^\\star$（单位：每位点每时间单位的替换数）。\n- 使用以下校准设置测试套件：\n  - 案例1（宽松界限）：$M = 2.0$，$k = 0.1$。\n  - 案例2（中等界限）：$M = 1.0$，$k = 5.0$。\n  - 案例3（非常紧的界限）：$M = 0.7$，$k = 20.0$。\n\n科学真实性要求。\n\n- 解应遵守所有关于节点年龄的约束，以保持枝长持续时间为非负。\n- 所有年龄必须以时间单位报告，所有速率必须以每位点每时间单位的替换数报告。\n- 不涉及角度。\n- 将任何比率或比例表示为小数。\n\n最终输出规范。\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 对于上述顺序中的每个测试案例 $i$，先输出 $t_R^\\star$（单位：时间单位），然后输出 $\\bar{r}^\\star$（单位：每位点每时间单位的替换数）。\n- 在打印前将每个数值四舍五入到六位小数。\n- 因此，最终输出必须按此顺序包含 $2 \\times 3 = 6$ 个浮点数：$[t_{R,1}^\\star, \\bar{r}_1^\\star, t_{R,2}^\\star, \\bar{r}_2^\\star, t_{R,3}^\\star, \\bar{r}_3^\\star]$。",
            "solution": "我们从一个基本关系出发：沿着一个分支累积的每位点替换数的期望值等于该分支上的瞬时替换速率与所经过时间的乘积。用 $r_i$ 表示分支 $i$ 上的速率，用 $d_i$ 表示分支 $i$ 的持续时间（时间长度）。那么，期望枝长为 $r_i d_i$。我们假设从序列数据比对中测量得到的枝长 $b_i$ 在期望值附近近似服从高斯分布，且所有分支共享方差 $\\sigma^2$：$b_i \\mid r_i, d_i \\sim \\mathcal{N}(r_i d_i, \\sigma^2)$。这种高斯近似的合理性可以通过中心极限定理来证明，该定理应用于标准替换模型下的多位点数据，会为枝长产生近似正态的估计误差。\n\n在不相关对数正态(UCLN)宽松分子钟模型下，各分支的特异性速率是独立的，且 $\\log r_i \\sim \\mathcal{N}(\\mu_r, s_r^2)$。这个先验捕捉了分支间的速率异质性，同时以由 $\\mu_r$ 设定的基准速率尺度为中心。对于时间，我们为根节点年龄 $t_R$ 设置一个基础对数正态先验，$\\log t_R \\sim \\mathcal{N}(\\mu_T, s_T^2)$，这反映了正值支持和乘性变异性。为了在 $M$ 处建立一个软性最大值界限模型，我们将基础先验乘以一个惩罚因子 $w(t_R; M, k) = \\exp\\big(-k \\max(0, t_R - M)\\big)$；当 $t_R \\le M$ 时，惩罚等于 $1$，而当 $t_R > M$ 时，先验密度以速率 $k$ 近似指数衰减。其余内部节点的年龄在由树顺序约束定义的可行集上具有弥散均匀先验。这些约束确保所有分支持续时间为非负：$t_R \\ge t_{AB} \\ge 0$ 和 $t_R \\ge t_{CDE} \\ge t_{DE} \\ge 0$。\n\n通过贝叶斯定理结合似然和先验，可以得到一个与它们乘积成正比的后验密度。舍去不涉及参数的归一化常数后，用于联合MAP估计量的、需要最小化的负对数后验为：\n$$\n\\mathcal{L}(\\mathbf{r}, \\mathbf{t})\n=\n\\sum_{i=1}^8 \\frac{(b_i - r_i d_i)^2}{2 \\sigma^2}\n+ \\sum_{i=1}^8 \\left[\\frac{(\\log r_i - \\mu_r)^2}{2 s_r^2} + \\log r_i\\right]\n+ \\left[\\frac{(\\log t_R - \\mu_T)^2}{2 s_T^2} + \\log t_R\\right]\n+ k \\cdot \\max(0, t_R - M),\n$$\n并受上述 $r_i > 0$ 和年龄约束的限制。第一项缩减了观测值 $b_i$ 与期望值 $r_i d_i$ 之间的预测误差。第二项实现了UCLN先验，包含 $\\log r_i$ 的二次惩罚项和雅可比项 $\\log r_i$。第三项是关于 $t_R$ 的基础对数正态先验及其雅可比项 $\\log t_R$。最后一项是软性界限惩罚，当 $t_R$ 超过 $M$ 时被激活，并由 $k$ 进行缩放。\n\n持续时间 $d_i$ 是节点年龄 $\\mathbf{t} = (t_R, t_{AB}, t_{CDE}, t_{DE})$ 的线性函数：\n- $d_1 = t_R - t_{AB}$，\n- $d_2 = t_R - t_{CDE}$，\n- $d_3 = t_{AB}$，\n- $d_4 = t_{AB}$，\n- $d_5 = t_{CDE}$，\n- $d_6 = t_{CDE} - t_{DE}$，\n- $d_7 = t_{DE}$，\n- $d_8 = t_{DE}$。\n\n算法设计如下。\n\n- 参数化和约束：我们对向量 $(\\log r_1,\\dots,\\log r_8, t_R, t_{AB}, t_{CDE}, t_{DE})$ 进行优化，通过对数参数化使用显式界限 $r_i > 0$，并使用线性不等式约束来强制执行祖先年龄排序，即 $t_R - t_{AB} \\ge \\epsilon$，$t_R - t_{CDE} \\ge \\epsilon$，$t_{CDE} - t_{DE} \\ge \\epsilon$，$t_{AB} \\ge \\epsilon$，$t_{DE} \\ge \\epsilon$，其中 $\\epsilon > 0$ 是一个小量，用以维持持续时间的严格正性。额外的箱式界限将年龄保持在合理的搜索域内。\n- 目标函数评估：对于给定的参数，计算持续时间 $d_i$、速率 $r_i = \\exp(\\log r_i)$，以及具有固定 $\\sigma^2$ 的高斯残差平方和项，然后加上UCLN和基础对数正态惩罚项，以及软性最大值惩罚 $k \\max(0, t_R - M)$。如果任何持续时间为非正，则施加一个大的惩罚以强制可行性。\n- 数值优化：使用约束非线性优化来最小化 $\\mathcal{L}$。诸如序列最小二乘规划(SLSQP)之类的方法可以处理带有线性不等式约束和箱式界限的光滑目标函数。软性界限项在 $t_R = M$ 处连续但非光滑，这在实践中SLSQP可以容忍。\n- 初始化：从接近基准速率和合理的年龄配置开始：对所有 $i$ 有 $\\log r_i \\approx \\log(0.01)$，$t_R \\approx 1.0$，$t_{AB} \\approx 0.6$，$t_{CDE} \\approx 0.8$，$t_{DE} \\approx 0.3$。\n- 输出：在优化器的解 $(\\mathbf{r}^\\star, \\mathbf{t}^\\star)$ 处，计算 $t_R^\\star$ 和 $\\bar{r}^\\star = \\frac{1}{8}\\sum_{i=1}^8 r_i^\\star$。将每个值四舍五入到六位小数。\n\n测试套件案例的解释：\n\n- 案例1，$M=2.0$ 和 $k=0.1$，对 $t_R$ 施加了一个弱的、宽松的上限，因此似然和UCLN先验主要决定 $t_R^\\star$ 和 $\\bar{r}^\\star$。\n- 案例2，$M=1.0$ 和 $k=5.0$，将 $t_R$ 锚定在1.0时间单位附近，如果仅靠似然会偏好一个更大的值，它会将MAP根年龄向下拉，并相应地向上或向下调整 $\\bar{r}^\\star$ 以使 $r_i d_i$ 与观测到的 $b_i$ 协调一致。\n- 案例3，$M=0.7$ 和 $k=20.0$，施加了一个非常紧的软性最大值；优化器必须将 $t_R^\\star$ 压缩到0.7以下或附近，从而抬高了速率以维持 $r_i d_i \\approx b_i$。因此，我们预期相对于更宽松的案例，$t_R^\\star$ 会减小而 $\\bar{r}^\\star$ 会增大。\n\n程序为每个 $(M,k)$ 对实现了此约束MAP估计，并按指定顺序打印包含六个四舍五入值的单行列表。年龄以时间单位报告，速率以每位点每时间单位的替换数报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, Bounds\n\ndef solve():\n    # Data: observed branch lengths (substitutions per site)\n    b = np.array([0.0044, 0.0019, 0.0063, 0.0060, 0.0096, 0.0045, 0.0030, 0.00255], dtype=float)\n    sigma = 0.0002  # observation noise std\n\n    # UCLN prior hyperparameters\n    mu_r = np.log(0.01)\n    s_r = 0.25\n\n    # Root age base lognormal prior parameters\n    mu_T = 0.0  # log(1.0)\n    s_T = 0.5\n\n    # Tree structure: durations from node ages\n    def durations(t):\n        tR, tAB, tCDE, tDE = t\n        d = np.empty(8, dtype=float)\n        d[0] = tR - tAB       # R->X\n        d[1] = tR - tCDE      # R->Z\n        d[2] = tAB            # X->A\n        d[3] = tAB            # X->B\n        d[4] = tCDE           # Z->C\n        d[5] = tCDE - tDE     # Z->Y\n        d[6] = tDE            # Y->D\n        d[7] = tDE            # Y->E\n        return d\n\n    # Soft penalty term for root age: k * max(0, tR - M)\n    def soft_penalty(tR, M, k):\n        excess = tR - M\n        return k * excess if excess > 0.0 else 0.0\n\n    # Negative log posterior (up to additive constant)\n    def neg_log_posterior(x, M, k):\n        # x = [log r_1..log r_8, tR, tAB, tCDE, tDE]\n        y = x[:8]\n        t = x[8:]\n        tR, tAB, tCDE, tDE = t\n        # Enforce basic positivity inside objective to avoid invalid logs\n        if tR <= 0 or tAB <= 0 or tCDE <= 0 or tDE <= 0:\n            return 1e20\n        d = durations(t)\n        # If any duration is non-positive, penalize heavily (constraints should prevent this)\n        if np.any(d <= 0):\n            return 1e20\n        r = np.exp(y)\n        # Likelihood term\n        resid = b - r * d\n        ll_term = 0.5 * np.sum((resid / sigma) ** 2)\n        # UCLN prior on rates: sum_i [ (y_i - mu_r)^2/(2 s_r^2) + y_i ]\n        prior_rates = np.sum(((y - mu_r) ** 2) / (2.0 * s_r ** 2) + y)\n        # Root age base lognormal prior: [(log tR - mu_T)^2/(2 s_T^2) + log tR]\n        prior_root = ((np.log(tR) - mu_T) ** 2) / (2.0 * s_T ** 2) + np.log(tR)\n        # Soft maximum penalty\n        soft = soft_penalty(tR, M, k)\n        return ll_term + prior_rates + prior_root + soft\n\n    # Constraints: enforce tree-order and positivity of durations\n    eps = 1e-6\n    def cons_fun(x):\n        tR, tAB, tCDE, tDE = x[8], x[9], x[10], x[11]\n        # c >= 0\n        return np.array([\n            tR - tAB - eps,\n            tR - tCDE - eps,\n            tCDE - tDE - eps,\n            tAB - eps,\n            tDE - eps\n        ], dtype=float)\n\n    nonlin_con = NonlinearConstraint(cons_fun, lb=0.0, ub=np.inf)\n\n    # Bounds: for log rates and ages\n    y_lower = np.full(8, np.log(1e-5))\n    y_upper = np.full(8, np.log(1.0))  # upper rate bound 1 subs/site/time unit\n    # Ages between tiny positive and 5.0 time units\n    t_lower = np.array([1e-6, 1e-6, 1e-6, 1e-6], dtype=float)\n    t_upper = np.array([5.0, 5.0, 5.0, 5.0], dtype=float)\n    lower_bounds = np.concatenate([y_lower, t_lower])\n    upper_bounds = np.concatenate([y_upper, t_upper])\n    bounds = Bounds(lower_bounds, upper_bounds)\n\n    # Initial guess: log rates near baseline, ages plausible\n    y0 = np.full(8, mu_r)\n    t0 = np.array([1.0, 0.6, 0.8, 0.3], dtype=float)\n    x0 = np.concatenate([y0, t0])\n\n    # Test suite: (M, k) pairs\n    test_cases = [\n        (2.0, 0.1),  # loose\n        (1.0, 5.0),  # moderate\n        (0.7, 20.0)  # very tight\n    ]\n\n    results = []\n    for M, k in test_cases:\n        obj = lambda x: neg_log_posterior(x, M, k)\n        res = minimize(\n            obj,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=[nonlin_con],\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        # If not successful, try a different method or perturb initial guess\n        if not res.success:\n            # Slight perturbation and retry\n            x0_perturb = x0.copy()\n            x0_perturb[:8] += np.random.default_rng(42).normal(scale=0.05, size=8)\n            x0_perturb[8:] += np.array([0.05, -0.05, 0.0, 0.0])\n            res = minimize(\n                obj,\n                x0_perturb,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[nonlin_con],\n                options={'maxiter': 3000, 'ftol': 1e-12, 'disp': False}\n            )\n\n        x_star = res.x\n        y_star = x_star[:8]\n        t_star = x_star[8:]\n        r_star = np.exp(y_star)\n        tR_star = t_star[0]\n        rbar_star = float(np.mean(r_star))\n\n        # Round to six decimals\n        tR_rounded = float(f\"{tR_star:.6f}\")\n        rbar_rounded = float(f\"{rbar_star:.6f}\")\n        results.append(tR_rounded)\n        results.append(rbar_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda v: f'{v:.6f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在贝叶斯框架下应用松散分子钟模型，依赖于如马尔可夫链蒙特卡洛 ($MCMC$) 等复杂算法。然而，确保这些算法高效运行并收敛到正确的后验分布，是一个极具挑战性的任务。这个实践问题聚焦于一个常见难题：$MCMC$ 混合不佳（poor mixing），其典型特征是参数更新的接受率过低。本练习旨在检验您对 $MCMC$ 调优策略的理解，即如何在不改变目标后验分布的前提下，有效提升采样效率。掌握这些调优技术，对于任何使用贝叶斯系统发育软件的研究者来说都是一项至关重要的实践技能，它能帮助您诊断采样问题并实施可靠的解决方案，从而确保进化时间尺度推断的准确性。",
            "id": "2749274",
            "problem": "一位研究人员正在一个固定的树拓扑结构上，使用不相关对数正态 (UCLN) 宽松分子钟模型进行贝叶斯系统发育推断。每个分支特定的替换速率 $r_i$ 都有一个先验分布，即 $\\log r_i \\sim \\mathcal{N}(\\mu, \\sigma^2)$，在各分支间独立同分布。超参数 $\\mu$ 和 $\\sigma$ 被赋予了正常的超先验。参数 $\\theta = (\\{r_i\\}, \\mu, \\sigma, \\ldots)$ 的后验分布通过马尔可夫链蒙特卡洛 (MCMC) 方法进行探索，其中速率参数使用 Metropolis–Hastings 更新。该研究人员观察到，速率更新提议的接受概率非常低（远低于 $0.1$），并且尽管运行了很长时间，$\\{r_i\\}$ 的有效样本量仍然很差。\n\n从贝叶斯推断和马尔可夫链蒙特卡洛的基本原理出发，请确定下列哪些调整是科学上合理的调优方法，能够在不改变目标后验分布的情况下，改善 UCLN 分析中速率参数的混合效果。选择所有适用的选项。\n\nA. 减小速率缩放提议的乘法尺度，使得 $\\log r_i$ 中引起的步长方差更小，目标是达到一个适中的接受率（例如，在 $0.2$ 和 $0.4$ 之间），同时保持先验和似然不变。\n\nB. 通过定义标准化对数速率 $z_i = (\\log r_i - \\mu)/\\sigma$ 来对模型进行重新参数化，并对 $z_i$ 使用对称随机游走提议，同时适当考虑雅可比行列式并对 $(\\mu, \\sigma)$ 进行一致的更新，保持先验和似然不变。\n\nC. 在预烧期（burn-in）使用自适应方案（例如，Robbins–Monro 型自适应）来调整速率更新的提议尺度，以达到目标接受概率，然后在正式运行阶段冻结提议参数。\n\nD. 通过将 $\\sigma^2$ 替换为 $10\\sigma^2$ 来增加 UCLN 的先验方差，以使对 $\\{r_i\\}$ 的更大幅度的提议变化更容易被接受。\n\nE. 增加抽样间隔（例如，每隔 $100$ 个样本保留一个），以降低保存的 $\\{r_i\\}$ 抽样中的自相关性。\n\nF. 为 $(\\log r_i, \\sigma)$ 引入一个联合块更新，使用一个可逆的、近似多元正态的提议，其协方差从一次简短的初步运行中估计然后固定下来，从而使提议与后验相关性对齐。\n\nG. 在整个运行过程中，用幂似然 $L^\\beta$（其中 $\\beta = 0.8$）替换原始似然，从而使提议更频繁地被接受。\n\nH. 采用 Metropolis 耦合马尔可夫链蒙特卡洛（并行退火），使用一系列在逆温度 $\\beta_k < 1$ 下的加热链与冷链交换状态，并只保留来自 $\\beta = 1$ 的冷链的样本。",
            "solution": "问题陈述经验证。\n\n**1. 提取已知条件：**\n- **模型：** 在固定树拓扑结构上，使用不相关对数正态 (UCLN) 宽松分子钟进行贝叶斯系统发育推断。\n- **先验：** 特定分支速率 $r_i$ 来自一个对数正态分布，使得 $\\log r_i \\sim \\mathcal{N}(\\mu, \\sigma^2)$，对于每个分支 $i$ 都是独立的。\n- **超先验：** 超参数 $\\mu$ 和 $\\sigma$ 被赋予了正常的超先验。\n- **推断方法：** 使用马尔可夫链蒙特卡洛 (MCMC) 探索参数 $\\theta = (\\{r_i\\}, \\mu, \\sigma, \\ldots)$ 的后验分布。\n- **更新方案：** 对速率参数 $\\{r_i\\}$ 使用 Metropolis-Hastings 更新。\n- **问题：** 速率更新提议的接受概率非常低（小于 $0.1$），且 $\\{r_i\\}$ 参数的有效样本量 (ESS) 很差。\n- **目标：** 确定科学上合理的 MCMC 调优调整，以在不改变目标后验分布的情况下改善速率参数的混合效果。\n\n**2. 验证：**\n问题陈述具有科学依据，表述清晰且客观。它描述了应用贝叶斯统计学中一个常见而现实的挑战，特别是在系统发育学领域。UCLN 模型、MCMC 推断、Metropolis-Hastings 更新、接受概率和有效样本量都是标准且明确定义的概。目标明确：在确保目标后验分布不变的前提下，提高 MCMC 的混合效率。该问题不包含科学或逻辑上的矛盾，没有缺失关键信息，并且并非无足轻重。\n\n**3. 结论：**\n问题有效。我们可以继续进行解答。\n\n---\n\n这个问题的基本基础是贝叶斯推断，其目标是在给定数据 $D$ 的情况下，描述一组参数 $\\theta$ 的后验分布。该后验由贝叶斯定理给出：\n$$\np(\\theta|D) = \\frac{L(D|\\theta) p(\\theta)}{p(D)} \\propto L(D|\\theta) p(\\theta)\n$$\n其中 $L(D|\\theta)$ 是似然函数，$p(\\theta)$ 是先验分布。\n\nMCMC 方法从此后验分布中生成样本。Metropolis-Hastings 算法作为一种通用的 MCMC 方法，通过从一个提议分布 $q(\\theta'|\\theta^{(t)})$ 中提议一个新状态 $\\theta'$，并以如下概率接受它，来生成一系列状态 $\\theta^{(t)}$：\n$$\n\\alpha(\\theta'|\\theta^{(t)}) = \\min \\left( 1, \\frac{p(\\theta'|D) q(\\theta^{(t)}|\\theta')}{p(\\theta^{(t)}|D) q(\\theta'|\\theta^{(t)})} \\right) = \\min \\left( 1, \\frac{L(D|\\theta') p(\\theta') q(\\theta^{(t)}|\\theta')}{L(D|\\theta^{(t)}) p(\\theta^{(t)}) q(\\theta'|\\theta^{(t)})} \\right)\n$$\n如问题所述，极低的接受概率（远低于 $0.1$）意味着提议的状态 $\\theta'$ 经常被拒绝，因为与当前状态 $\\theta^{(t)}$ 相比，它们落入了后验概率密度低得多的区域。这通常是由于提议分布 $q$ 提议的步长过大，导致对参数空间的探索效率低下，从而导致混合效果差和有效样本量 (ESS) 低。\n\n核心任务是评估所提议的调整，依据是它们是否在*不*改变目标后验分布 $p(\\theta|D)$ 的前提下提高了混合效率。\n\n**A. 减小速率缩放提议的乘法尺度，使得 $\\log r_i$ 中引起的步长方差更小，目标是达到一个适中的接受率（例如，在 $0.2$ 和 $0.4$ 之间），同时保持先验和似然不变。**\n提议分布 $q$ 是 MCMC 算法的人为产物；它不是统计模型（由似然和先验定义）的一部分。修改 $q$ 是“调优”Metropolis-Hastings 采样器的主要机制。对于对称随机游走提议（例如在 $\\log r_i$ 上的提议），极低的接受率表明提议方差（或步长）过大。减小该方差会使提议更小、更局部，从而增加提议状态具有与当前状态相似的后验密度的可能性，进而提高接受率。理论和实证研究表明，许多随机游走 Metropolis 算法的最优接受率在 $0.2-0.4$ 的范围内（例如，在高维情况下为 $0.234$）。此调整直接解决了观察到的问题，而没有改变 $L(D|\\theta)$ 或 $p(\\theta)$。\n结论：**正确**。这是一个标准且必要的 MCMC 调优程序。\n\n**B. 通过定义标准化对数速率 $z_i = (\\log r_i - \\mu)/\\sigma$ 来对模型进行重新参数化，并对 $z_i$ 使用对称随机游走提议，同时适当考虑雅可比行列式并对 $(\\mu, \\sigma)$ 进行一致的更新，保持先验和似然不变。**\n重新参数化是一种技术，它改变 MCMC 采样器操作的变量，而不改变底层模型。在原始参数化中，$\\log r_i$ 的抽样与后验分布中的超参数 $\\mu$ 和 $\\sigma$ 相关。通过定义 $z_i = (\\log r_i - \\mu)/\\sigma$，我们处理的变量的先验是标准正态分布 $z_i \\sim \\mathcal{N}(0, 1)$，且独立于 $\\mu$ 和 $\\sigma$。在 $z_i$ 上提议更新，并通过 $r_i = \\exp(\\mu + \\sigma z_i)$ 转换回 $r_i$，可以打破后验相关性，从而实现更高效的探索。只要后验密度根据新参数被正确地表述（如果具体的 M-H 比率计算需要，这包括考虑变换的雅可比行列式），采样器仍然针对原始感兴趣参数的相同后验分布。短语“保持先验和似然不变”表示概率模型本身没有被修改。\n结论：**正确**。这是改善分层模型中混合效果的一种有效且通常高效的策略。\n\n**C. 在预烧期（burn-in）使用自适应方案（例如，Robbins–Monro 型自适应）来调整速率更新的提议尺度，以达到目标接受概率，然后在正式运行阶段冻结提议参数。**\n这是一种自适应 MCMC。标准的 MCMC 理论要求时间同质的转移核，以保证收敛到唯一的平稳分布。一个自适应算法，其中提议分布 $q$ 根据链的历史而改变，违反了这一要求。然而，如果自适应仅限于初始的预烧期，并且在随后的正式运行中固定提议分布，那么链的正式运行阶段就是一个具有固定转移核的标准马尔可夫链。因此，它会收敛到正确的目标后验。预烧期间的自适应用于自动化选项 A 中描述的调优过程，找到一个接近最优的提议尺度。\n结论：**正确**。这是一种广泛使用的、理论上合理的自动化 MCMC 调优方法。\n\n**D. 通过将 $\\sigma^2$ 替换为 $10\\sigma^2$ 来增加 UCLN 的先验方差，以使对 $\\{r_i\\}$ 的更大幅度的提议变化更容易被接受。**\n此修改涉及更改先验分布 $p(\\theta)$。目标后验分布与似然和先验的乘积 $L(D|\\theta)p(\\theta)$ 成正比。改变先验会从根本上改变模型，从而改变所针对的后验分布。目标是提高对*给定*后验的采样效率，而不是从一个不同的、可能更方便的后验中采样。\n结论：**不正确**。这违反了不改变目标后验分布的基本指令。\n\n**E. 增加抽样间隔（例如，每隔 $100$ 个样本保留一个），以降低保存的 $\\{r_i\\}$ 抽样中的自相关性。**\n抽样间隔（Thinning）是指仅存储链中每 $k$ 个样本中的一个。虽然这降低了*已保存*样本序列中的自相关性并减小了文件大小，但它并不能改善 MCMC 采样器的混合效果。混合是链在每次迭代中如何探索状态空间的一个属性。混合不佳导致高自相关。抽样间隔处理的是症状（自相关的样本），而不是原因（低效的探索）。为了达到给定的 ESS，抽样间隔需要按比例运行更长的时间，因为它在每 $k$ 个样本中丢弃了 $k-1$ 个，从而减少了固定迭代次数下的总信息量。它不提高采样器的效率。\n结论：**不正确**。这并不能改善 MCMC 的混合效果；它是一个后处理步骤，会减少每次 MCMC 迭代的有效样本数。\n\n**F. 为 $(\\log r_i, \\sigma)$ 引入一个联合块更新，使用一个可逆的、近似多元正态的提议，其协方差从一次简短的初步运行中估计然后固定下来，从而使提议与后验相关性对齐。**\n在许多贝叶斯模型中，参数在后验中是相关的。在 UCLN 模型中，特定分支的速率 $r_i$ 与控制整个树上速率方差的参数 $\\sigma$ 相关。在这种情况下，单点更新是低效的。块更新为一组相关参数（例如 $(\\log r_i, \\sigma)$）提议一个联合移动。使用一个协方差结构模仿后验协方差的多元提议分布，可以使采样器沿着后验概率高的方向进行提议，从而对更大胆的移动有更高的接受率。从一次初步运行中估计这个协方差然后将其固定，是构建这样一个高效、固定的提议核的有效方法。这只修改了 $q$，而没有改变 $p(\\theta|D)$。\n结论：**正确**。这是一种通过考虑后验参数相关性来提高混合效率的强大技术。\n\n**G. 在整个运行过程中，用幂似然 $L^\\beta$（其中 $\\beta = 0.8$）替换原始似然，从而使提议更频繁地被接受。**\n这个过程创建了一个“幂后验”$p_\\beta(\\theta|D) \\propto [L(D|\\theta)]^\\beta p(\\theta)$。当逆温度 $\\beta = 0.8$（小于1）时，似然曲面被“压平”了。这降低了后验分布的“峰度”，使采样器更容易接受提议。然而，采样器不再探索真实的后验分布（其中 $\\beta=1$），而是在探索它的一个扭曲版本。这违反了目标后验分布不能改变的条件。\n结论：**不正确**。这改变了目标后验分布。\n\n**H. 采用 Metropolis 耦合马尔可夫链蒙特卡洛（并行退火），使用一系列在逆温度 $\\beta_k < 1$ 下的加热链与冷链交换状态，并只保留来自 $\\beta = 1$ 的冷链的样本。**\nMetropolis 耦合 MCMC (MC³)，或称并行退火，是一种用于复杂后验分布图景的先进 MCMC 技术。它并行运行多条链，每条链都针对一个幂后验 $p_{\\beta_k}(\\theta|D) \\propto [L(D|\\theta)]^{\\beta_k} p(\\theta)$。其中一条链，即“冷链”，其 $\\beta_1 = 1$，针对的是真实的后验分布。其他“加热”的链具有 $\\beta_k < 1$，探索被压平的后验版本，并且可以更容易地穿越低概率区域。该算法允许相邻链之间交换参数状态。这使得冷链能够接收到它自己可能无法到达的参数空间部分的构型，从而极大地改善了全局混合效果。由于样本完全从冷链（$\\beta_1 = 1$）中提取，因此可以保证最终的样本来自正确的目标后验分布。\n结论：**正确**。这是一种复杂而有效的方法，用于改善难以处理的后验分布的混合效果，而不会改变最终的目标分布。",
            "answer": "$$\\boxed{ABCFH}$$"
        }
    ]
}