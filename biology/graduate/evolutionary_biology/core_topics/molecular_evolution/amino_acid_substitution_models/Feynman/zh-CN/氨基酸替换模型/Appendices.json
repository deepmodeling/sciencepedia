{
    "hands_on_practices": [
        {
            "introduction": "氨基酸替换模型通常是对潜在的密码子演化过程的一种简化。这个练习将探讨这种简化在数学上成立所需的精确条件，即“可聚合性”（lumpability）。通过这个实践，你将深入理解氨基酸模型背后的理论基础及其在应用中可能遇到的陷阱，这对于严谨地构建和评判演化模型至关重要。",
            "id": "2691216",
            "problem": "一个关于密码子的连续时间马尔可夫链 (CTMC)，其生成元 (速率矩阵) 为 $Q^{\\mathrm{codon}}$，在有义密码子集合上演化，并遵循从密码子到氨基酸的标准遗传密码映射 $g$，其中每个氨基酸对应一个密码子区块。通过对每个氨基酸区块内的概率求和，可以将密码子状态聚合 (lump) 成氨基酸状态。\n\n任务 1. 从 CTMC 的 Kolmogorov 前向方程和通过对每个氨基酸区块的概率求和得到的区块聚合过程的定义出发，推导聚合过程本身也是一个关于氨基酸的 CTMC 的充分必要条件 (即，$Q^{\\mathrm{codon}}$ 对于由遗传密码导出的划分是强可聚合的)。您的推导必须给出该条件的明确刻画，以区块间密码子层面的速率表示，并给出当条件成立时，以 $Q^{\\mathrm{codon}}$ 的条目表示的氨基酸层面非对角线速率 $\\,\\widehat{q}_{ab}\\,$ 的构造性表达式。\n\n任务 2. 考虑一个科学上合理的玩具子系统，其中包含四个密码子，它们仅通过第三密码子位置的单核苷酸替换相连接：两个赖氨酸密码子 $\\{\\text{AAA}, \\text{AAG}\\}$ 和两个天冬酰胺密码子 $\\{\\text{AAC}, \\text{AAU}\\}$。假设对于任何允许的从核苷酸 $x$ 到核苷酸 $y$ 的第三位置变化，瞬时密码子替换速率等于该位置的基础核苷酸速率 $r_{x\\to y}$，而这四个密码子之间的所有其他变化都是不允许的。非零瞬时速率 (单位为 $\\mathrm{s}^{-1}$) 由以下核苷酸速率指定：\n- $r_{A\\to C} = 3.0 \\times 10^{-1}$, $r_{A\\to U} = 6.0 \\times 10^{-1}$, $r_{A\\to G} = 2.0 \\times 10^{-1}$,\n- $r_{G\\to C} = 4.0 \\times 10^{-1}$, $r_{G\\to U} = 1.0 \\times 10^{-1}$, $r_{G\\to A} = 5.0 \\times 10^{-1}$,\n- $r_{C\\to U} = 7.0 \\times 10^{-1}$, $r_{U\\to C} = 8.0 \\times 10^{-1}$.\n例如，这里从 $\\text{AAA}$ 到 $\\text{AAC}$ 的速率等于 $r_{A\\to C}$，从 $\\text{AAG}$ 到 $\\text{AAU}$ 的速率等于 $r_{G\\to U}$，且对角线元素被设定为使 $Q^{\\mathrm{codon}}$ 的每行之和为 $0$。\n\n使用您在任务 1 中的结果，判断这个四密码子 CTMC 聚合成一个在 $\\{\\text{Lys}, \\text{Asn}\\}$ 上的双态氨基酸 CTMC 是否是强可聚合的。然后，保持除 $r_{G\\to U}$ 外的所有速率不变，计算为恢复该聚合相对于这两个氨基酸的强可聚合性所需的对 $r_{G\\to U}$ 的最小加性调整 $\\Delta$ (即，使得将 $r_{G\\to U}$ 替换为 $r_{G\\to U} + \\Delta$ 后，该聚合对于 $\\{\\text{Lys}, \\text{Asn}\\}$ 这对氨基酸是可聚合的最小实数 $\\Delta$)。将您的最终数值答案四舍五入到四位有效数字。以 $\\mathrm{s}^{-1}$ 表示最终值。",
            "solution": "所提出的问题是有效的。它在科学上基于连续时间马尔可夫链理论及其在分子进化中的应用，其问题设定良好，有足够的信息以得到唯一解，并以客观、正式的语言表述。我们将开始解答。\n\n问题分为两个任务。第一个任务是关于连续时间马尔可夫链强可聚合性条件的理论推导。第二个任务是将此条件应用于一个特定的密码子替换模型。\n\n**任务 1：强可聚合性条件的推导**\n\n设密码子状态由有限集 $S$ 索引。替换概率的演化由一个连续时间马尔可夫链控制，其生成元矩阵为 $Q^{\\mathrm{codon}} = (q_{ij})$，其中当 $i \\neq j$ 时，$q_{ij}$ 是从密码子 $i$到密码子 $j$的瞬时替换速率，对角线元素定义为 $q_{ii} = -\\sum_{j \\neq i} q_{ij}$。设 $p_i(t)$ 是在时间 $t$ 观测到密码子 $i$ 的概率。概率向量 $\\mathbf{p}(t) = (p_i(t))_{i \\in S}$ 的动态由 Kolmogorov 前向方程描述：\n$$\n\\frac{d p_j(t)}{dt} = \\sum_{i \\in S} p_i(t) q_{ij}\n$$\n遗传密码将密码子状态空间 $S$ 划分为不相交的区块 $\\mathcal{A} = \\{A_a, A_b, \\ldots\\}$，其中每个区块 $A_a$ 包含编码氨基酸 $a$ 的所有密码子。在时间 $t$ 处于聚合的氨基酸状态 $b$ 的概率是处于其任何组成密码子状态的概率之和：\n$$\n\\widehat{p}_b(t) = \\sum_{j \\in A_b} p_j(t)\n$$\n当且仅当其动态可以由一组仅涉及聚合概率的前向方程描述时，氨基酸状态上的聚合过程本身才是一个连续时间马尔可夫链：\n$$\n\\frac{d \\widehat{p}_b(t)}{dt} = \\sum_a \\widehat{p}_a(t) \\widehat{q}_{ab}\n$$\n其中 $\\widehat{q}_{ab}$ 是与时间无关的氨基酸替换速率，且该方程对密码子状态上的任何初始概率分布都成立。此性质被称为强可聚合性。\n\n为推导该条件，我们将 $\\widehat{p}_b(t)$ 的表达式对时间 $t$ 求导：\n$$\n\\frac{d \\widehat{p}_b(t)}{dt} = \\frac{d}{dt} \\left( \\sum_{j \\in A_b} p_j(t) \\right) = \\sum_{j \\in A_b} \\frac{d p_j(t)}{dt}\n$$\n代入密码子层面的 Kolmogorov 前向方程：\n$$\n\\frac{d \\widehat{p}_b(t)}{dt} = \\sum_{j \\in A_b} \\left( \\sum_{i \\in S} p_i(t) q_{ij} \\right)\n$$\n我们可以交换求和顺序，并根据氨基酸划分 $\\mathcal{A}$ 对状态 $i \\in S$进行分组：\n$$\n\\frac{d \\widehat{p}_b(t)}{dt} = \\sum_{i \\in S} p_i(t) \\left( \\sum_{j \\in A_b} q_{ij} \\right) = \\sum_a \\sum_{i \\in A_a} p_i(t) \\left( \\sum_{j \\in A_b} q_{ij} \\right)\n$$\n为了使聚合过程是马尔可夫的，时间导数 $\\frac{d \\widehat{p}_b(t)}{dt}$ 必须是聚合概率 $\\widehat{p}_a(t) = \\sum_{k \\in A_a} p_k(t)$ 的线性函数。观察推导出的表达式，这要求乘以 $p_i(t)$ 的项，即从密码子 $i$到密码子区块 $A_b$ 的总速率，对于给定区块 $A_a$ 内的所有密码子 $i$ 都必须相同。如果此条件不成立，$\\widehat{p}_b(t)$ 的演化将依赖于每个区块 $A_a$ 内概率 $p_i(t)$ 的具体分布，而不仅仅是它们的总和，从而违反了聚合过程的马尔可夫性质。\n\n因此，强可聚合性的充分必要条件是：对于任意两个氨基酸区块 $A_a$ 和 $A_b$ (其中 $a \\neq b$)，从单个密码子 $i \\in A_a$到区块 $A_b$ 中所有密码子的速率之和必须是一个常数，该常数仅取决于区块 $A_a$ 和 $A_b$，而与密码子 $i$ 的具体选择无关。形式上：\n$$\n\\sum_{j \\in A_b} q_{ij} = C_{ab} \\quad \\text{for all } i \\in A_a\n$$\n当此条件成立时，这个常数 $C_{ab}$ 正是聚合后的非对角线速率 $\\widehat{q}_{ab}$。我们于是可以写出：\n$$\n\\frac{d \\widehat{p}_b(t)}{dt} = \\sum_a \\sum_{i \\in A_a} p_i(t) \\widehat{q}_{ab} = \\sum_a \\widehat{q}_{ab} \\left(\\sum_{i \\in A_a} p_i(t)\\right) = \\sum_a \\widehat{p}_a(t) \\widehat{q}_{ab}\n$$\n这就是聚合后 CTMC 的前向方程。因此，氨基酸层面非对角线速率 $\\widehat{q}_{ab}$ 的构造性表达式为：\n$$\n\\widehat{q}_{ab} = \\sum_{j \\in A_b} q_{ij} \\quad \\text{for any } i \\in A_a, \\text{ where } a \\neq b\n$$\n\n**任务 2：玩具子系统分析**\n\n我们将上面推导出的条件应用于指定的 4 密码子子系统。\n氨基酸区块是：\n- 赖氨酸 (Lys): $A_{\\text{Lys}} = \\{\\text{AAA}, \\text{AAG}\\}$\n- 天冬酰胺 (Asn): $A_{\\text{Asn}} = \\{\\text{AAC}, \\text{AAU}\\}$\n\n非零密码子替换速率 $q_{i \\to j}$ 由第三位置的基础核苷酸速率 $r_{x \\to y}$ 给出。根据问题陈述，相关速率 (单位为 $\\mathrm{s}^{-1}$) 如下：\n- 从密码子 $\\text{AAA} \\in A_{\\text{Lys}}$ 到区块 $A_{\\text{Asn}}$：\n  $q_{\\text{AAA} \\to \\text{AAC}} = r_{A\\to C} = 3.0 \\times 10^{-1}$\n  $q_{\\text{AAA} \\to \\text{AAU}} = r_{A\\to U} = 6.0 \\times 10^{-1}$\n- 从密码子 $\\text{AAG} \\in A_{\\text{Lys}}$ 到区块 $A_{\\text{Asn}}$：\n  $q_{\\text{AAG} \\to \\text{AAC}} = r_{G\\to C} = 4.0 \\times 10^{-1}$\n  $q_{\\text{AAG} \\to \\text{AAU}} = r_{G\\to U} = 1.0 \\times 10^{-1}$\n\n首先，我们判断该聚合是否是强可聚合的。我们检查从 $A_{\\text{Lys}}$中的每个密码子到区块 $A_{\\text{Asn}}$的总速率是否恒定。\n- 对于密码子 $\\text{AAA} \\in A_{\\text{Lys}}$：\n$$\n\\sum_{j \\in A_{\\text{Asn}}} q_{\\text{AAA} \\to j} = q_{\\text{AAA} \\to \\text{AAC}} + q_{\\text{AAA} \\to \\text{AAU}} = (3.0 \\times 10^{-1}) + (6.0 \\times 10^{-1}) = 9.0 \\times 10^{-1} \\, \\mathrm{s}^{-1}\n$$\n- 对于密码子 $\\text{AAG} \\in A_{\\text{Lys}}$：\n$$\n\\sum_{j \\in A_{\\text{Asn}}} q_{\\text{AAG} \\to j} = q_{\\text{AAG} \\to \\text{AAC}} + q_{\\text{AAG} \\to \\text{AAU}} = (4.0 \\times 10^{-1}) + (1.0 \\times 10^{-1}) = 5.0 \\times 10^{-1} \\, \\mathrm{s}^{-1}\n$$\n由于 $9.0 \\times 10^{-1} \\neq 5.0 \\times 10^{-1}$，对于从赖氨酸区块到天冬酰胺区块的转换，可聚合性条件被违反。因此，这个 4 密码子 CTMC 的聚合不是强可聚合的。\n\n接下来，我们计算恢复强可聚合性所需的对速率 $r_{G\\to U}$ 的最小加性调整 $\\Delta$。速率 $r_{G\\to U}$ 对应于密码子替换速率 $q_{\\text{AAG} \\to \\text{AAU}}$。设新速率为 $r'_{G\\to U} = r_{G\\to U} + \\Delta$，这使得新的密码子速率为 $q'_{\\text{AAG} \\to \\text{AAU}} = (1.0 \\times 10^{-1}) + \\Delta$。所有其他速率保持不变。\n\n从 $A_{\\text{Lys}}$ 到 $A_{\\text{Asn}}$ 转换的可聚合性条件要求总离开速率相等：\n$$\n\\sum_{j \\in A_{\\text{Asn}}} q_{\\text{AAA} \\to j} = \\sum_{j \\in A_{\\text{Asn}}} q'_{\\text{AAG} \\to j}\n$$\n$$\nq_{\\text{AAA} \\to \\text{AAC}} + q_{\\text{AAA} \\to \\text{AAU}} = q_{\\text{AAG} \\to \\text{AAC}} + q'_{\\text{AAG} \\to \\text{AAU}}\n$$\n代入数值和调整后速率的表达式：\n$$\n(3.0 \\times 10^{-1}) + (6.0 \\times 10^{-1}) = (4.0 \\times 10^{-1}) + \\left((1.0 \\times 10^{-1}) + \\Delta\\right)\n$$\n$$\n9.0 \\times 10^{-1} = 5.0 \\times 10^{-1} + \\Delta\n$$\n求解 $\\Delta$：\n$$\n\\Delta = (9.0 \\times 10^{-1}) - (5.0 \\times 10^{-1}) = 4.0 \\times 10^{-1} \\, \\mathrm{s}^{-1}\n$$\n问题要求求最小的 $\\Delta$。由于仅改变 $r_{G\\to U}$ 会得到一个关于 $\\Delta$ 的一元一次方程，解 $\\Delta = 4.0 \\times 10^{-1}$ 是唯一的，因此也是最小的。还必须检查从 $A_{\\text{Asn}}$ 到 $A_{\\text{Lys}}$ 的转换条件。根据提供的非零核苷酸速率列表，从密码子 $\\text{AAC}$ 和 $\\text{AAU}$ 到区块 $A_{\\text{Lys}}$ 的速率均为零，因此从任一密码子出发的速率之和都是 $0$。这部分条件是满足的，并且不受对 $\\Delta$ 的改变的影响。\n\n所需的调整是 $\\Delta = 4.0 \\times 10^{-1}$。问题要求答案四舍五入到四位有效数字。因此，$\\Delta = 0.4000 = 4.000 \\times 10^{-1}$。",
            "answer": "$$\n\\boxed{4.000 \\times 10^{-1}}\n$$"
        },
        {
            "introduction": "在确定模型结构后，下一个关键步骤是从真实的序列数据中估计其参数。这项练习将引导你推导适用于通用时间可逆（General Time-Reversible, GTR）模型的参数的最大似然估计（Maximum Likelihood Estimators, MLEs），这是现代系统发育学软件的核心算法之一。完成此练习将加深你对演化理论和统计推断之间联系的理解。",
            "id": "2691229",
            "problem": "考虑一个氨基酸演化的连续时间马尔可夫链 (CTMC) 模型。该模型建立在一个具有给定分支长度的固定系统发育树上，并使用一个固定的多序列比对，其字母表大小为 $K$（例如，对于标准氨基酸，$K=20$）。假设沿每个分支的替换过程是时间齐次的，并且相对于平稳分布 $\\{\\pi_{i}\\}_{i=1}^{K}$ 是可逆的。瞬时速率矩阵 $Q=\\{q_{ij}\\}$ 通过对称交换率 $\\{r_{ij}\\}_{1 \\le i < j \\le K}$ 进行参数化，其中当 $i \\ne j$ 时，$q_{ij} = r_{ij} \\pi_{j}$，且 $q_{ii} = - \\sum_{j \\ne i} q_{ij}$。设根节点处的过程根据 $\\{\\pi_{i}\\}_{i=1}^{K}$ 分布。\n\n定义以下充分统计量，这些统计量是在给定当前参数值、固定树和比对的情况下，对替换历史的后验分布求期望得到的：\n- 对于每个状态 $i \\in \\{1,\\dots,K\\}$，在所有分支上处于状态 $i$ 的总期望停留时间 $T_{i}$。\n- 对于每个满足 $i \\ne j$ 的有序对 $(i,j)$，在所有分支上从状态 $i$ 到状态 $j$ 的总期望转移数 $N_{ij}$。\n令 $S_{ij} := N_{ij} + N_{ji}$（其中 $i<j$）表示对称化期望转移计数。\n\n从 CTMC 的完整数据对数似然和可逆性参数化出发，根据第一性原理，推导出平稳频率 $\\{\\pi_{i}\\}_{i=1}^{K}$ 和交换率 $\\{r_{ij}\\}_{1 \\le i < j \\le K}$ 的最大似然估计量，用充分统计量 $\\{T_{i}\\}$ 和 $\\{S_{ij}\\}$ 表示。施加可辨识性约束，即 $\\sum_{i=1}^{K} \\pi_{i} = 1$ 且平均替换速率归一化为1，即 $\\sum_{i=1}^{K} \\pi_{i} (-q_{ii}) = 1$。\n\n以闭式表达式的形式报告你最终的估计量，即一个通用的 $\\pi_{i}^{\\ast}$ 和一个通用的 $r_{ij}^{\\ast}$（其中 $i<j$），仅用 $\\{T_{i}\\}$ 和 $\\{S_{ij}\\}$ 表示。不需要数值。你的最终答案必须是单个闭式解析表达式。如果提供多个表达式，请将它们作为单个行矩阵的条目呈现。不需要单位。",
            "solution": "该问题要求推导一个时间可逆的氨基酸替换连续时间马尔可夫模型的平稳频率 $\\{\\pi_{i}\\}$ 和对称交换率 $\\{r_{ij}\\}$ 的最大似然估计量 (MLEs)。给定的是期望充分统计量：每个状态 $i$ 的总停留时间 $T_{i}$，以及每对状态 $(i,j)$ 的总对称化转移计数 $S_{ij}$。\n\n推导从期望完整数据对数似然开始，这是在期望最大化 (EM) 算法的 M 步中需要最大化的目标函数。对于一个特定的演化历史（路径），其完整数据对数似然由下式给出：\n$$ \\ln L(\\text{path}) = \\sum_{i=1}^{K} n_{i}^{\\text{root}} \\ln \\pi_{i} + \\sum_{i \\ne j} n_{ij} \\ln q_{ij} - \\sum_{i=1}^{K} t_{i} \\sum_{j \\ne i} q_{ij} $$\n其中 $n_{i}^{\\text{root}}$ 是根节点状态为 $i$ 的指示变量，$n_{ij}$ 是从状态 $i$ 到状态 $j$ 的转移次数，$t_{i}$ 是在状态 $i$ 中花费的总时间。\n\n需要最大化的目标函数是在给定观测到的比对和当前参数估计的情况下，该对数似然在路径的后验分布上的期望。令 $\\mathcal{Q}$ 表示此函数。\n$$ \\mathcal{Q} = E[\\ln L(\\text{path})] = \\sum_{i=1}^{K} P(i | \\text{root}) \\ln \\pi_{i} + \\sum_{i \\ne j} N_{ij} \\ln q_{ij} - \\sum_{i=1}^{K} T_{i} \\sum_{j \\ne i} q_{ij} $$\n其中 $P(i | \\text{root})$ 是根节点处于状态 $i$ 的后验概率，$N_{ij}$ 和 $T_{i}$ 是问题中定义的期望充分统计量。问题指出，根节点处的过程根据 $\\{\\pi_i\\}$ 分布，这意味着一个平稳和齐次的过程。对于这样的过程，根节点状态 $i$ 的后验概率通过其在整个树上的总体期望频率来估计。状态 $i$ 的总期望时间是 $T_i$，所有状态的总时间是 $\\sum_k T_k$。因此，$P(i | \\text{root})$ 本身由 $T_i / \\sum_k T_k$ 估计。此外，当在整个树上计算总停留时间 $T_i$ 和转移计数 $N_{ij}$ 时，根概率的贡献通常在概念上被合并到这些值中。\n\n我们现在代入速率矩阵 $Q$ 的给定参数化：当 $i \\ne j$ 时，$q_{ij} = r_{ij} \\pi_{j}$，且 $r_{ij} = r_{ji}$。\n$$ \\mathcal{Q} = \\sum_{i} P(i | \\text{root}) \\ln \\pi_i + \\sum_{i \\ne j} N_{ij} (\\ln r_{ij} + \\ln \\pi_{j}) - \\sum_{i=1}^{K} T_{i} \\sum_{j \\ne i} r_{ij} \\pi_{j} $$\n按参数 $\\{\\pi_i\\}$ 和 $\\{r_{ij}\\}$ 对各项进行分组：\n$$ \\mathcal{Q} = \\left[ \\sum_{j=1}^{K} \\left( P(j | \\text{root}) + \\sum_{i \\ne j} N_{ij} \\right) \\ln \\pi_j - \\sum_{j=1}^{K} \\pi_j \\sum_{i \\ne j} T_i r_{ij} \\right] + \\left[ \\sum_{i<j} S_{ij} \\ln r_{ij} \\right] $$\n项 $\\sum_{i,j: i\\ne j} T_i r_{ij} \\pi_j$ 可以重写为 $\\sum_{i<j} r_{ij} (T_i \\pi_j + T_j \\pi_i)$，这将参数耦合在一起。这使得同时进行解析最大化变得困难。\n\n然而，对于齐次平稳模型，一种标准的、有原则的方法是将 $\\{\\pi_i\\}$ 和 $\\{r_{ij}\\}$ 的估计解耦。\n首先，我们求平稳频率 $\\{\\pi_i\\}$ 的最大似然估计量。对于一个齐次平稳过程，根据定义，平稳概率 $\\pi_i$ 是过程在状态 $i$ 中花费的时间的长期比例。在给定状态 $i$ 中的期望总时间 $T_i$ 和所有状态的总时间 $\\sum_k T_k$ 的情况下，该比例的最大似然估计量是这些时间的比值。该估计量也最大化了似然函数中与观测频率相关的部分。\n$$ \\pi_i^{\\ast} = \\frac{T_i}{\\sum_{k=1}^{K} T_k} $$\n该估计量固有地满足约束 $\\sum_{i=1}^K \\pi_i = 1$。\n\n其次，在给定估计量 $\\pi_i^{\\ast}$ 的情况下，我们求解交换率 $\\{r_{ij}\\}$ 的估计量。我们将 $\\mathcal{Q}$ 对 $\\{r_{ij}\\}$ 进行最大化，同时将 $\\{\\pi_i\\}$ 固定为其估计值 $\\pi_i^{\\ast}$。$\\mathcal{Q}$ 中依赖于 $\\{r_{ij}\\}$ 的部分是：\n$$ \\mathcal{Q}(\\{r_{ij}\\}) = \\sum_{i \\ne j} N_{ij} \\ln r_{ij} - \\sum_{i=1}^{K} T_i \\sum_{j \\ne i} r_{ij} \\pi_j^{\\ast} $$\n使用 $r_{ij} = r_{ji}$ 和 $S_{ij} = N_{ij} + N_{ji}$，上式变为：\n$$ \\mathcal{Q}(\\{r_{ij}\\}) = \\sum_{1 \\le i < j \\le K} S_{ij} \\ln r_{ij} - \\sum_{1 \\le i < j \\le K} r_{ij} (T_i \\pi_j^{\\ast} + T_j \\pi_i^{\\ast}) $$\n由于不同 $(i,j)$ 对的项是分开的，我们可以通过求偏导数并将其设为零，来独立地对每个 $r_{ij}$ 进行最大化。对于一个特定的对 $(k,l)$ 且 $k<l$：\n$$ \\frac{\\partial \\mathcal{Q}}{\\partial r_{kl}} = \\frac{S_{kl}}{r_{kl}} - (T_k \\pi_l^{\\ast} + T_l \\pi_k^{\\ast}) = 0 $$\n求解 $r_{kl}$ 得到未缩放的估计量 $\\tilde{r}_{kl}$：\n$$ \\tilde{r}_{kl} = \\frac{S_{kl}}{T_k \\pi_l^{\\ast} + T_l \\pi_k^{\\ast}} $$\n代入 $\\pi_i^{\\ast}$ 的表达式：\n$$ \\tilde{r}_{kl} = \\frac{S_{kl}}{T_k \\frac{T_l}{\\sum_m T_m} + T_l \\frac{T_k}{\\sum_m T_m}} = \\frac{S_{kl} \\sum_{m=1}^{K} T_m}{2 T_k T_l} $$\n\n第三，我们应用平均替换速率为1的归一化约束。平均速率 $\\mu$ 定义为从一个状态替换出去的平均速率，按平稳频率加权：\n$$ \\mu = \\sum_{i=1}^{K} \\pi_i (-q_{ii}) = \\sum_{i=1}^{K} \\pi_i \\sum_{j \\ne i} q_{ij} = \\sum_{i \\ne j} \\pi_i q_{ij} = \\sum_{i \\ne j} \\pi_i (r_{ij} \\pi_j) = \\sum_{1 \\le i < j \\le K} 2 \\pi_i \\pi_j r_{ij} $$\n我们使用未缩放的估计量 $\\pi_i^{\\ast}$ 和 $\\tilde{r}_{ij}$ 计算这个平均速率，称之为 $\\tilde{\\mu}$：\n$$ \\tilde{\\mu} = \\sum_{1 \\le i < j \\le K} 2 \\pi_i^{\\ast} \\pi_j^{\\ast} \\tilde{r}_{ij} = \\sum_{1 \\le i < j \\le K} 2 \\left( \\frac{T_i}{\\sum_m T_m} \\right) \\left( \\frac{T_j}{\\sum_m T_m} \\right) \\left( \\frac{S_{ij} \\sum_m T_m}{2 T_i T_j} \\right) $$\n$$ \\tilde{\\mu} = \\sum_{1 \\le i < j \\le K} \\frac{S_{ij}}{\\sum_m T_m} = \\frac{\\sum_{1 \\le i < j \\le K} S_{ij}}{\\sum_{m=1}^{K} T_m} $$\n为强制执行约束 $\\mu=1$，我们必须缩放速率矩阵 $Q$。这是通过缩放交换率来实现的，因为 $\\pi_i$ 是固定的比例。$r_{ij}$ 的最终最大似然估计量是 $r_{ij}^{\\ast} = \\tilde{r}_{ij} / \\tilde{\\mu}$。\n$$ r_{ij}^{\\ast} = \\frac{\\tilde{r}_{ij}}{\\tilde{\\mu}} = \\frac{ \\frac{S_{ij} \\sum_{m=1}^{K} T_m}{2 T_i T_j} }{ \\frac{\\sum_{1 \\le k < l \\le K} S_{kl}}{\\sum_{m=1}^{K} T_m} } = \\frac{S_{ij} \\left(\\sum_{m=1}^{K} T_m\\right)^2}{2 T_i T_j \\sum_{1 \\le k < l \\le K} S_{kl}} $$\n这些关于 $\\pi_i^{\\ast}$ 和 $r_{ij}^{\\ast}$（其中 $i < j$）的表达式就是所求的闭式最大似然估计量。",
            "answer": "$$ \\boxed{\\pmatrix{ \\frac{T_i}{\\sum_{k=1}^{K} T_k} & \\frac{S_{ij} \\left(\\sum_{k=1}^{K} T_k\\right)^2}{2 T_i T_j \\sum_{1 \\le k < l \\le K} S_{kl}} }} $$"
        },
        {
            "introduction": "一个完整参数化的模型可以用来模拟演化过程，这对于检验假设和生成基准数据集是一个强大的工具。本练习将指导你一步步实现一个序列演化模拟，其中包含了跨位点速率异质性（among-site rate variation, ASRV）这一关键要素。这个实践将帮助你从抽象的数学模型跨越到具体的计算实现，让你能够亲手生成演化数据。",
            "id": "2691283",
            "problem": "设计并实现一个完整的、可运行的程序，该程序在一个连续时间马尔可夫链 (CTMC) 以及跨位点速率变异的伽马加不变 ($\\Gamma+I$) 模型下，模拟氨基酸序列沿着一个固定的有根树的演化过程，然后通过将经验位点速率分布与目标分布进行比较，来验证位点速率混合模型。模拟和验证必须纯粹用数学和算法术语来规定，具体如下。\n\n- 模型基础和定义：\n  - 使用一个基于20个氨基酸状态的CTMC，其生成元矩阵 $Q=\\{q_{ij}\\}_{i,j=1}^{20}$ 由泊松氨基酸模型给出：对于 $i\\neq j$，设置 $q_{ij}=\\frac{1}{19}$，且 $q_{ii}=-1$。这个 $Q$ 矩阵的平稳分布对于所有 $i$ 均为 $\\pi_i=\\frac{1}{20}$，并且平均替换率为 $-\\sum_{i=1}^{20}\\pi_i q_{ii}=1$。\n  - 跨位点速率异质性由独立同分布的位点特异性相对速率乘数 $\\{r_s\\}_{s=1}^L$ 建模，使用伽马加不变混合模型：以概率 $p_I$，速率为 $r_s=0$ (不变位点)，并以概率 $(1-p_I)$，速率 $r_s\\sim \\mathrm{Gamma}(\\alpha,\\theta)$，其中形状参数为 $\\alpha$，尺度参数为 $\\theta=\\frac{1}{\\alpha}$，从而使得 $\\mathbb{E}[r_s]=1$。\n  - 在速率为 $r_s$ 的位点上，沿着长度为 $t$ 的分支进行的模拟遵循CTMC的 Gillespie 算法：当当前状态为 $i$ 时，到下一个替换事件的等待时间服从速率为 $\\lambda_s=r_s(-q_{ii})=r_s$ 的指数分布，在每次事件发生时，从不同于当前状态的19个状态中均匀选择新状态。等价地（由于指数分布的无记忆性和泊松过程的稀疏化性质），在该位点上，长度为 $t$ 的分支上的事件数量服从 $\\mathrm{Poisson}(r_s t)$ 分布；给定 $k$ 个事件，应用 $k$ 次连续的瞬时转换，每次转换时，从不等于当前状态的19个状态中均匀选择新状态。\n  - 长度为 $L$ 的根序列，其每个位点都独立地从平稳分布中抽取 (对于所有 $i$, $\\pi_i=\\frac{1}{20}$)。\n\n- 固定的有根树：\n  - 使用一个有根的分叉树，其叶节点标记为 $A$、$B$、$C$ 和 $D$，内部节点标记为 $R$ (根)、$X$ 和 $Y$。支长（在平均速率为1的情况下，单位为每个位点的预期替换数）如下：\n    - $R\\to X$: $0.2$; $X\\to A$: $0.1$; $X\\to B$: $0.1$,\n    - $R\\to Y$: $0.15$; $Y\\to C$: $0.15$; $Y\\to D$: $0.15$.\n  - CTMC是时间同质的，其生成元矩阵 $Q$ 按上述方式缩放；位点特异性乘数 $r_s$ 乘以每个分支的时间（等价于乘以事件速率）。\n\n- 验证目标：\n  - 每次模拟中，设 $\\widehat{p}_I$ 为不变位点的经验比例，即 $\\widehat{p}_I=\\frac{1}{L}\\sum_{s=1}^L \\mathbf{1}\\{r_s=0\\}$，并报告绝对偏差 $|\\widehat{p}_I-p_I|$。\n  - 对于非不变位点（即 $r_s>0$ 的位点），计算抽样得到的 $\\{r_s:r_s>0\\}$ 的经验累积分布函数 $\\widehat{F}_L(x)$ 与目标伽马累积分布函数 $F_{\\alpha,\\theta}(x)$ 之间的 Kolmogorov–Smirnov (KS) 统计量。其中 $\\alpha$ 如上指定，$\\theta=\\frac{1}{\\alpha}$。KS 统计量为 $\\sup_{x\\ge 0}|\\widehat{F}_L(x)-F_{\\alpha,\\theta}(x)|$。报告此 KS 统计量。\n\n- 计算要求：\n  - 将氨基酸状态表示为 $\\{0,1,\\dots,19\\}$ 中的整数。\n  - 按前述方法，对每个位点、每个分支使用事件驱动模拟（Gillespie）；你可以使用模型所隐含的泊松事件数表示法来高效地实现 Gillespie 动态过程。\n  - 必须通过将根序列沿着树的每个分支向下传播，在每个位点上使用该位点的 $r_s$ 独立进行模拟，从而在所有叶节点 $A$、$B$、$C$ 和 $D$ 处生成序列。\n\n- 测试套件：\n  - 对下面的每组参数，在固定树上模拟一个长度为 $L$ 的序列，并计算两个验证量：$|\\widehat{p}_I-p_I|$ 以及非不变速率上的 KS 统计量。\n  - 使用以下参数集，每组使用其独立的伪随机种子以确保可复现性：\n    1. $(\\alpha,p_I,L,\\text{seed})=(0.5,\\,0.2,\\,5000,\\,12345)$,\n    2. $(\\alpha,p_I,L,\\text{seed})=(5.0,\\,0.0,\\,4000,\\,54321)$,\n    3. $(\\alpha,p_I,L,\\text{seed})=(0.2,\\,0.5,\\,6000,\\,424242)$.\n  - 对每种情况，程序必须：\n    - 根据指定的 $(\\alpha,p_I)$ 和 $\\theta=\\frac{1}{\\alpha}$，按照 $\\Gamma+I$ 混合模型抽样位点速率乘数 $\\{r_s\\}_{s=1}^L$，\n    - 使用 Gillespie 过程，在指定的 CTMC 模型下模拟序列沿树的演化，\n    - 计算并记录两个验证指标。\n\n- 最终输出格式：\n  - 你的程序必须生成单行输出，其中包含三个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。\n  - 每个元素必须是对应于上述参数集顺序的一个双元素列表 $[|\\widehat{p}_I-p_I|,\\ \\text{KS}]$。\n  - 输出中的每个浮点数必须四舍五入到 $10^{-6}$ 的精度（小数点后六位）。\n  - 例如，一个有效的输出格式可能如下所示 `[[0.001234,0.017890],[0.000000,0.012345],[0.000500,0.045600]]`。\n  - 程序必须是自包含的，不需要用户输入，并且只使用指定的库。\n\n除了常规的 CTMC 时间尺度外，不涉及任何物理单位；所有支长都以平均速率为1时的每位点预期替换数为单位。",
            "solution": "题目陈述已经过严格验证，被认为是科学上合理的、定义明确的、客观的。它描述了计算分子演化中的一个标准模拟任务，没有矛盾或含糊之处。为实现一个完整且可复现的解决方案所需的所有必要参数和定义均已提供。我们开始提供解决方案。\n\n本任务是：在一个固定的系统发育树上，根据一个指定的、带有位点速率异质性的连续时间马尔可夫链 (CTMC) 模型，模拟氨基酸序列的演化，然后验证模拟出的位点速率分布。整个过程包括两个主要阶段：第一，从伽马加不变 ($\\Gamma+I$) 混合分布中生成位点特异性演化速率并对其进行验证；第二，根据这些速率模拟序列沿树分支的演化。\n\n**1. 位点速率的生成与验证**\n\n跨位点速率变异的模型是一个混合模型，其中每个位点 $s \\in \\{1, \\dots, L\\}$ 被赋予一个相对速率乘数 $r_s$。\n-   以给定的概率 $p_I$，一个位点是不变的，即其速率为 $r_s = 0$。\n-   以概率 $1 - p_I$，一个位点是可变的，其速率 $r_s$ 从伽马分布中抽取，即 $r_s \\sim \\mathrm{Gamma}(\\alpha, \\theta)$。形状参数为 $\\alpha$，尺度参数设为 $\\theta = 1/\\alpha$，以确保可变速率的均值为 $\\mathbb{E}[r_s | r_s>0] = \\alpha \\theta = 1$。\n\n生成 $L$ 个位点速率的算法如下：\n1.  对每个位点 $s$，从均匀分布 $\\mathrm{Uniform}(0, 1)$ 中抽取一个随机数 $u_s$。\n2.  如果 $u_s < p_I$，则该位点速率设为 $r_s = 0$。\n3.  如果 $u_s \\ge p_I$，则从 $\\mathrm{Gamma}(\\alpha, 1/\\alpha)$ 分布中抽取该位点速率 $r_s$。\n\n生成速率向量 $\\{r_s\\}_{s=1}^L$ 后，计算两个验证指标：\n-   **不变位点比例偏差**：不变位点的经验比例 $\\widehat{p}_I$ 按 $r_s=0$ 的位点所占比例计算。然后计算其与理论概率的绝对偏差 $|\\widehat{p}_I - p_I|$。\n-   **Kolmogorov-Smirnov (KS) 统计量**：对于非不变位点子集（即 $\\{r_s : r_s > 0\\}$），我们将其经验累积分布函数 (CDF) $\\widehat{F}_L(x)$ 与 $\\mathrm{Gamma}(\\alpha, 1/\\alpha)$ 分布的理论 CDF $F_{\\alpha, 1/\\alpha}(x)$ 进行比较。KS 统计量是这两个 CDF 在所有 $x$ 上的最大绝对差：\n    $$ D_n = \\sup_x |\\widehat{F}_L(x) - F_{\\alpha, 1/\\alpha}(x)| $$\n    该统计量量化了抽样得到的可变速率与目标伽马分布的“拟合优度”。\n\n**2. 序列演化模拟**\n\n氨基酸序列的演化被建模为在一个包含 $K=20$ 个状态的集合上的 CTMC。指定的生成元矩阵是泊松模型：$Q = \\{q_{ij}\\}$，其中对于 $i \\neq j$，$q_{ij} = 1/(K-1) = 1/19$，对角线元素为 $q_{ii} = - \\sum_{j \\neq i} q_{ij} = -1$。该模型具有均匀的平稳分布 $\\pi_i = 1/K = 1/20$（对所有状态 $i$）。\n\n模拟从指定树的根节点开始，向下进行到叶节点。\n-   **根序列**：在根节点 $R$ 处初始化一个长度为 $L$ 的序列。每个位点的状态都独立地从平稳分布中抽取，即从代表为整数 $\\{0, 1, \\dots, 19\\}$ 的20个氨基酸状态中进行均匀随机选择。\n-   **沿分支的演化**：对于每个位点，沿长度为 $t$ 的分支的演化是独立模拟的。对于速率为 $r_s$ 的位点 $s$，总支长被缩放为 $t' = r_s t$。在此分支上发生的替换事件数 $k$ 是一个随机变量，从均值为 $\\lambda = t'$ 的泊松分布中抽取，即 $k \\sim \\mathrm{Poisson}(r_s t)$。\n    - 如果 $k=0$，则后代节点的状态与父节点的状态相同。\n    - 如果 $k>0$，我们必须确定 $k$ 次替换后的最终状态。每次替换都会将当前状态变为从其他19个状态中均匀选择的一个新状态。我们可以不按顺序模拟每次跳跃，而是推导出 $k$ 次跳跃后的转移概率。设 $P(\\text{state}_k = i | \\text{state}_0 = j)$ 为从状态 $j$ 开始，经过 $k$ 次跳跃后处于状态 $i$ 的概率。由于模型的对称性，只有两种情况：停留在同一状态（$i=j$）或移动到某个特定的不同状态（$i \\neq j$）。设 $p_k = P(\\text{state}_k = j | \\text{state}_0 = j)$。经过 $k+1$ 步后处于初始状态的概率，取决于第 $k$ 步后不处于初始状态的条件：$p_{k+1} = P(\\text{state}_{k+1}=j | \\text{state}_k \\neq j) P(\\text{state}_k \\neq j | \\text{state}_0=j) = \\frac{1}{19}(1 - p_k)$。当 $p_0=1$ 时，此递推关系解为：\n      $$ p_k = \\frac{1}{20} + \\frac{19}{20} \\left(-\\frac{1}{19}\\right)^k $$\n      最终处于任何一个其他状态 $i \\neq j$ 的概率是 $(1-p_k)/19$。这个解析结果允许进行高效的向量化实现。对于每个发生 $k > 0$ 次事件的位点，我们抽取一个均匀随机数 $u \\in [0, 1)$。如果 $u < p_k$，状态保持不变。否则，它会转换到一个从其他19个状态中均匀选择的新状态。\n\n模拟遍历树结构（$R \\to X \\to \\{A, B\\}$ 和 $R \\to Y \\to \\{C, D\\}$），对六个分支中的每一个使用其指定的长度应用此过程。这样就生成了叶节点 $A、B、C$ 和 $D$ 处的最终序列。\n\n**3. 实现**\n\n实现部分使用 `numpy` 库进行高效的基于数组的计算，特别是用于生成随机数以及对序列和速率数组执行向量化操作。`scipy.stats` 模块用于计算 Kolmogorov-Smirnov 检验 (`kstest`) 所需的伽马分布的理论CDF。模拟逻辑被封装在一个函数中，该函数处理所有测试用例，并为每个用例设置随机种子以确保可复现性。最终结果被格式化为所要求的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and validation for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1): (alpha, p_I, L, seed)\n        (0.5, 0.2, 5000, 12345),\n        # (Parameter set 2)\n        (5.0, 0.0, 4000, 54321),\n        # (Parameter set 3)\n        (0.2, 0.5, 6000, 424242),\n    ]\n\n    NUM_STATES = 20\n    \n    # Fixed tree branch lengths\n    branch_lengths = {\n        'RX': 0.2, 'XA': 0.1, 'XB': 0.1,\n        'RY': 0.15, 'YC': 0.15, 'YD': 0.15\n    }\n\n    results = []\n\n    def simulate_branch(parent_seq, branch_length, site_rates, rng):\n        \"\"\"\n        Simulates sequence evolution along a single branch.\n        \"\"\"\n        L = len(parent_seq)\n        \n        # Calculate Poisson mean for number of events at each site\n        lambdas = site_rates * branch_length\n        num_events = rng.poisson(lam=lambdas)\n        \n        child_seq = parent_seq.copy()\n        \n        # Identify sites where at least one substitution event occurred\n        sites_with_events = np.where(num_events > 0)[0]\n        if sites_with_events.size == 0:\n            return child_seq\n\n        k = num_events[sites_with_events]\n        \n        # Probability of returning to the original state after k substitutions\n        prob_stay = 1/NUM_STATES + ((NUM_STATES-1)/NUM_STATES) * (-1/(NUM_STATES-1))**k\n        \n        # Decide which sites will change state based on prob_stay\n        u = rng.random(size=sites_with_events.size)\n        change_mask = u >= prob_stay\n        \n        indices_to_change = sites_with_events[change_mask]\n        if indices_to_change.size == 0:\n            return child_seq\n\n        initial_states_to_change = parent_seq[indices_to_change]\n        \n        # For sites that change, pick a new state uniformly from the other N-1 states\n        num_to_change = indices_to_change.size\n        # Sample an integer in {0, ..., N-2}\n        new_state_draws = rng.integers(0, NUM_STATES - 1, size=num_to_change)\n        \n        # Map {0, ..., N-2} to {0, ..., N-1} \\ {current_state}\n        child_seq[indices_to_change] = new_state_draws + (new_state_draws >= initial_states_to_change)\n        \n        return child_seq\n\n    for alpha, p_I, L, seed in test_cases:\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate site rates from Gamma+I mixture model\n        rates = np.zeros(L, dtype=np.float64)\n        invariant_mask = rng.random(size=L)  p_I\n        \n        num_invariant = np.sum(invariant_mask)\n        num_variant = L - num_invariant\n        \n        if num_variant > 0:\n            variant_rates = rng.gamma(shape=alpha, scale=1.0/alpha, size=num_variant)\n            rates[~invariant_mask] = variant_rates\n        else:\n            variant_rates = np.array([])\n        \n        # 2. Validate the site rates distribution\n        # Metric 1: Absolute deviation of p_I\n        p_I_hat = num_invariant / L\n        p_I_dev = abs(p_I_hat - p_I)\n        \n        # Metric 2: KS statistic for non-invariant rates\n        if num_variant > 0:\n            # The CDF for the kstest is the Gamma distribution\n            gamma_cdf_func = lambda x: stats.gamma.cdf(x, a=alpha, scale=1.0/alpha)\n            ks_stat, _ = stats.kstest(variant_rates, gamma_cdf_func)\n        else:\n            ks_stat = 0.0\n\n        # 3. Simulate sequence evolution on the tree (as required by the prompt)\n        # Root sequence drawn from stationary distribution (uniform)\n        root_seq = rng.integers(0, NUM_STATES, size=L)\n        \n        # Evolve down the tree from root to leaves\n        seq_X = simulate_branch(root_seq, branch_lengths['RX'], rates, rng)\n        seq_A = simulate_branch(seq_X, branch_lengths['XA'], rates, rng)\n        seq_B = simulate_branch(seq_X, branch_lengths['XB'], rates, rng)\n        \n        seq_Y = simulate_branch(root_seq, branch_lengths['RY'], rates, rng)\n        seq_C = simulate_branch(seq_Y, branch_lengths['YC'], rates, rng)\n        seq_D = simulate_branch(seq_Y, branch_lengths['YD'], rates, rng)\n        # Final leaf sequences are seq_A, seq_B, seq_C, seq_D.\n        \n        results.append([p_I_dev, ks_stat])\n\n    # Final print statement in the exact required format.\n    output_str = \"[\" + \",\".join([f\"[{r[0]:.6f},{r[1]:.6f}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}