{
    "hands_on_practices": [
        {
            "introduction": "从原始基因组数据中量化密码子使用的不均一性，是研究密码子使用偏好性的第一步。相对同义密码子使用度（$RSCU$）是一个基础且广泛使用的标准化指标，用于揭示哪些密码子被优先或回避使用。通过从“所有同义密码子被均等使用”这一零假设出发，从第一性原理推导 $RSCU$ 的计算公式，本练习将加深您对该指标背后统计逻辑的理解，这是进行基因组学分析的一项核心技能 。",
            "id": "2697540",
            "problem": "您正在研究一个原核生物基因组中的密码子使用偏好。对于具有多个同义密码子的氨基酸，研究人员通常使用相对同义密码子使用度（Relative Synonymous Codon Usage, RSCU）来量化其使用模式。考虑一个由索引 $a$ 表示的氨基酸家族，它由 $k_{a}$ 个同义密码子编码。设在一个足够大的编码序列集合中，这些密码子的观测计数为 $x_{a,1}, x_{a,2}, \\ldots, x_{a,k_{a}}$，总数为 $X_{a}=\\sum_{j=1}^{k_{a}} x_{a,j}$。\n\n使用一个零模型，在该模型中，以氨基酸 $a$ 为条件，其 $k_{a}$ 个同义密码子中的每一个都有同等的使用可能性。请基于第一性原理，推导家族 $a$ 中密码子 $i$ 的相对同义密码子使用度（RSCU）的闭合形式表达式，该表达式为其观测计数与零模型下预期计数的比值。然后，解释如何根据相对于均等使用预期的过度使用或使用不足来解释大于 $1$、等于 $1$ 或小于 $1$ 的值。\n\n为了具体检验您的推导，考虑亮氨酸（leucine）（它有 $k_{a}=6$ 个同义密码子）。假设在一个经过整理的基因集中，观测到的计数为 $x_{a,1}=255$、$x_{a,2}=90$、$x_{a,3}=30$、$x_{a,4}=60$、$x_{a,5}=45$ 和 $x_{a,6}=120$，因此 $X_{a}=600$。使用您推导的表达式计算密码子 $1$ 和 $3$ 的RSCU值，并说明在均等使用的零模型下，每个密码子是过度使用、中性使用还是使用不足。不要对这些示例值进行四舍五入。\n\n您最终的方框答案应该是家族 $a$ 中密码子 $i$ 的RSCU的通用闭合形式表达式，仅用 $k_{a}$ 和观测计数 $x_{a,1},\\ldots,x_{a,k_{a}}$ 表示。不需要单位。",
            "solution": "所提出的问题要求基于一个已定义的均等密码子使用零模型，从第一性原理推导相对同义密码子使用度（$RSCU$）指标。这是基因组数据定量分析中的一个标准程序。问题陈述具有科学依据、提法严谨，并包含了解决该问题所需的所有信息。我将开始推导。\n\n让我们用索引 $a$ 表示一个氨基酸家族。这个氨基酸由一组 $k_a$ 个同义密码子编码。在一个大型基因序列集合中，这些密码子的观测计数为 $x_{a,1}, x_{a,2}, \\ldots, x_{a,k_a}$。为该特定氨基酸观测到的密码子总数是这些单个计数的总和：\n$$\nX_a = \\sum_{j=1}^{k_a} x_{a,j}\n$$\n\n零假设（或称零模型）假定，在没有密码子偏好选择压力的情况下，氨基酸 $a$ 的 $k_a$ 个同义密码子中的每一个都将以相等的频率被使用。因此，在给定氨基酸为 $a$ 的条件下，观测到该家族中任何特定密码子 $i$ 的概率为：\n$$\nP(\\text{codon}_i | \\text{amino acid}_a) = \\frac{1}{k_a}\n$$\n\n特定密码子 $i$ 的预期计数，记作 $E[x_{a,i}]$，是该氨基酸家族的总观测数 $X_a$ 乘以在零模型下密码子 $i$ 出现的概率。\n$$\nE[x_{a,i}] = X_a \\cdot P(\\text{codon}_i | \\text{amino acid}_a) = X_a \\cdot \\frac{1}{k_a} = \\frac{X_a}{k_a}\n$$\n在给定氨基酸总实例数为 $X_a$ 的情况下，这个预期计数代表了如果密码子使用在 $k_a$ 个同义选项中完全均等时，我们期望看到密码子 $i$ 的次数。\n\n问题将家族 $a$ 中密码子 $i$ 的相对同义密码子使用度（$RSCU$），我们记作 $RSCU_{a,i}$，定义为其观测计数与此零模型下预期计数的比值。\n$$\nRSCU_{a,i} = \\frac{\\text{Observed Count}}{\\text{Expected Count}} = \\frac{x_{a,i}}{E[x_{a,i}]}\n$$\n代入推导出的预期计数表达式，我们得到：\n$$\nRSCU_{a,i} = \\frac{x_{a,i}}{\\frac{X_a}{k_a}} = \\frac{x_{a,i} \\cdot k_a}{X_a}\n$$\n最后，通过代入 $X_a$ 的定义，我们得到了 $RSCU_{a,i}$ 的闭合形式表达式，它由同义密码子数量 $k_a$ 和观测计数 $x_{a,j}$ 表示：\n$$\nRSCU_{a,i} = \\frac{x_{a,i} \\cdot k_a}{\\sum_{j=1}^{k_a} x_{a,j}}\n$$\n这就是所要求的通用表达式。\n\n$RSCU_{a,i}$ 值的解释是直接的。它是一种标准化的密码子使用度量，直接将观测频率与均等使用模型下预期的频率进行比较。\n- 如果 $RSCU_{a,i} > 1$，意味着观测计数 $x_{a,i}$ 大于预期计数 $\\frac{X_a}{k_a}$。这表明密码子 $i$ 的使用频率高于随机预期的频率，因此被认为是**过度使用**或偏好使用。\n- 如果 $RSCU_{a,i} = 1$，观测计数 $x_{a,i}$ 与预期计数 $\\frac{X_a}{k_a}$ 完全相等。这表明密码子 $i$ 的使用频率与零模型一致，因此被认为是**中性使用**。\n- 如果 $RSCU_{a,i} < 1$，观测计数 $x_{a,i}$ 小于预期计数 $\\frac{X_a}{k_a}$。这表明密码子 $i$ 的使用频率低于随机预期的频率，因此被认为是**使用不足**或非偏好使用。\n\n现在，我们将此推导应用于亮氨酸的具体例子。给定条件如下：\n- 同义密码子数量，$k_a = 6$。\n- 观测计数：$x_{a,1}=255$、$x_{a,2}=90$、$x_{a,3}=30$、$x_{a,4}=60$、$x_{a,5}=45$ 和 $x_{a,6}=120$。\n- 亮氨酸的总计数，$X_a = \\sum_{j=1}^{6} x_{a,j} = 255+90+30+60+45+120 = 600$。\n\n首先，我们根据均等使用的零模型计算任何单个亮氨酸密码子的预期计数：\n$$\nE[x_{a,i}] = \\frac{X_a}{k_a} = \\frac{600}{6} = 100\n$$\n现在，我们计算密码子 $1$ 的 $RSCU$ 值：\n$$\nRSCU_{a,1} = \\frac{x_{a,1}}{E[x_{a,1}]} = \\frac{255}{100} = 2.55\n$$\n由于 $RSCU_{a,1} = 2.55 > 1$，密码子 $1$ 是**过度使用**的。\n\n接下来，我们计算密码子 $3$ 的 $RSCU$ 值：\n$$\nRSCU_{a,3} = \\frac{x_{a,3}}{E[x_{a,3}]} = \\frac{30}{100} = 0.3\n$$\n由于 $RSCU_{a,3} = 0.3 < 1$，密码子 $3$ 是**使用不足**的。\n\n推导出的通用公式为量化与均等密码子使用的偏差提供了一种稳健且标准化的方法，这是研究分子进化以及塑造基因组组成的各种力（如翻译选择）的一个基本方面。",
            "answer": "$$\n\\boxed{\\frac{x_{a,i} \\cdot k_a}{\\sum_{j=1}^{k_a} x_{a,j}}}\n$$"
        },
        {
            "introduction": "在能够度量偏好性之后，下一步便是分析和利用它。本练习将引导您进入合成生物学和计算分析的核心，您将构建一个计算流程，对基因序列进行同义重编码，并预测其对翻译过程的双重影响：通过密码子适应指数（$CAI$）评估对翻译延伸的影响，并通过信使RNA（$mRNA$）的二级结构最小自由能（$MFE$）评估对翻译起始的影响。这项实践突显了看似简单的同义替换如何引发复杂且多方面的生物学后果 。",
            "id": "2697501",
            "problem": "根据分子生物学中心法则，一个编码DNA序列被翻译成蛋白质，并且多个密码子可以编码同一个氨基酸（同义密码子）。在许多生物体中，同义密码子的使用频率并不均等，这种现象被称为密码子使用偏好。两个经过广泛验证的生物学观察构成了本问题的基础：(i) 靠近五撇 ($5'$) 端的信使核糖核酸 (mRNA) 二级结构可以调节翻译起始，以及 (ii) 通常通过相对适应性权重建模的密码子使用偏好，通过影响转运核糖核酸 (tRNA) 的可用性来影响翻译延伸。您的任务是将这些思想形式化为一个计算流程，该流程在给定一个编码序列的情况下，执行同义重编码，并计算简化的最小自由能 (MFE) 模型在 $5'$ 端的变化以及密码子适应指数 (CAI) 的变化，然后推断对起始和延伸的潜在影响。\n\n您必须仅从核心定义和以下规则开始实现以下内容，除了明确指定的公式外，不使用任何快捷公式。\n\n使用的定义和规则：\n- 设输入编码DNA序列为一个字符串 $S$，其字母表为 $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T} \\}$，长度为 $3n$，其中 $n \\geq 1$ 为某个整数，每个三联体都是一个密码子。假设第一个密码子是标准的起始密码子 $\\mathrm{ATG}$。\n- 通过为每个有义密码子 $c$ 分配一个由其鸟嘌呤-胞嘧啶 (GC) 含量衍生的原始偏好 $r(c)$ 来定义宿主密码子偏好模型：设 $\\mathrm{GC}(c)$ 为 $c$ 中 $\\mathrm{G}$ 或 $\\mathrm{C}$ 核苷酸的计数，并设\n$$\nr(c) \\equiv \\exp\\!\\big(\\beta \\, \\mathrm{GC}(c)\\big),\n$$\n其中 $\\beta = \\ln(2)$。\n- 对于每个氨基酸 $a$，设 $\\mathcal{C}(a)$ 为其同义密码子的集合。定义族内归一化权重\n$$\nw(c) \\equiv \\frac{r(c)}{\\max_{c' \\in \\mathcal{C}(a)} r(c')}, \\quad c \\in \\mathcal{C}(a).\n$$\n根据构造，$w(c) \\in (0,1]$ 并且对于氨基酸 $a$ 来说，GC含量最丰富的同义密码子的 $w(c)=1$。\n- 将具有密码子 $(c_1,\\dots,c_n)$ 的编码序列 $S$ 的密码子适应指数 (CAI) 定义为 $w(c_i)$ 的几何平均数：\n$$\n\\mathrm{CAI}(S) \\equiv \\left( \\prod_{i=1}^n w(c_i) \\right)^{1/n}.\n$$\n- 定义在 $S$ 上的同义重编码操作，由指令 $d \\in \\{\\text{optimize},\\ \\text{deoptimize}\\}$ 参数化，该操作通过替换，对于每个氨基酸 $a$，将每个密码子 $c \\in \\mathcal{C}(a)$ 替换为以下项来产生重编码序列 $S^{(d)}$：\n  - 如果 $d=\\text{optimize}$，替换为一个同义密码子 $c^\\star \\in \\arg\\max_{c' \\in \\mathcal{C}(a)} w(c')$；\n  - 如果 $d=\\text{deoptimize}$，替换为一个同义密码子 $c_\\star \\in \\arg\\min_{c' \\in \\mathcal{C}(a)} w(c')$。\n  起始密码子 $\\mathrm{ATG}$ 必须保持不变。单密码子氨基酸（甲硫氨酸和色氨酸）不受任一指令的影响。\n- 定义 $5'$ 窗口的简化RNA折叠能量模型如下。设 $L \\geq 1$ 为核苷酸窗口长度。考虑编码区的头 $L$ 个核苷酸（如果 $L$ 超过序列长度则截断）。将胸腺嘧啶转换为尿嘧啶 ($\\mathrm{T} \\mapsto \\mathrm{U}$) 并使用无最近邻的动态规划模型计算近似的最小自由能 $\\mathrm{MFE}(X_{1:L})$，该模型具有以下碱基对能量：\n  - 沃森-克里克碱基对：$\\mathrm{A}\\!-\\!\\mathrm{U}$ 和 $\\mathrm{U}\\!-\\!\\mathrm{A}$ 贡献 $-2.0$ $\\mathrm{kcal/mol}$；$\\mathrm{G}\\!-\\!\\mathrm{C}$ 和 $\\mathrm{C}\\!-\\!\\mathrm{G}$ 贡献 $-3.0$ $\\mathrm{kcal/mol}$。\n  - 摆动碱基对：$\\mathrm{G}\\!-\\!\\mathrm{U}$ 和 $\\mathrm{U}\\!-\\!\\mathrm{G}$ 贡献 $-1.0$ $\\mathrm{kcal/mol}$。\n  - 发夹环最小长度约束：位置 $i$ 和 $j$ 之间的碱基对仅在 $j - i - 1 \\geq m$ 时被允许，其中 $m=3$。\n  - 不使用额外的环起始罚分或堆积加成。总能量是所选碱基对能量的总和。动态规划必须在满足环长约束的所有有效非交叉配对中找到最小（最负）的能量。\n- 对于任何一对序列 $S$ 和 $S^{(d)}$，定义长度为 $L$ 的 $5'$ 窗口的MFE变化为\n$$\n\\Delta \\mathrm{MFE} \\equiv \\mathrm{MFE}\\big(S^{(d)}_{1:L}\\big) - \\mathrm{MFE}\\big(S_{1:L}\\big),\n$$\n单位为 $\\mathrm{kcal/mol}$，CAI变化为\n$$\n\\Delta \\mathrm{CAI} \\equiv \\mathrm{CAI}\\big(S^{(d)}\\big) - \\mathrm{CAI}\\big(S\\big).\n$$\n- 使用以下阈值推断潜在影响：\n  - 起始影响阈值 $\\tau = 1.0$ $\\mathrm{kcal/mol}$。如果 $\\Delta \\mathrm{MFE} \\leq -\\tau$，则预测翻译起始将变得更加受阻（布尔值 $\\mathrm{True}$），否则为 $\\mathrm{False}$。\n  - 延伸影响阈值 $\\epsilon = 0.005$（无量纲）。如果 $\\Delta \\mathrm{CAI} \\leq -\\epsilon$，则预测翻译延伸将减慢（布尔值 $\\mathrm{True}$），否则为 $\\mathrm{False}$。\n\n输入测试套件：\n提供一个程序，完全按照规定解决以下四个案例。\n- 案例1：$S_1 =$ \"ATGAAA AATGGT TCTGCT GTACCT ACTGAA GATCAA CTGATT TATCAT\"（空格仅为方便阅读而添加；实际序列没有空格），指令 $d_1 = \\text{optimize}$，窗口长度 $L_1 = 45$ 核苷酸。\n- 案例2：$S_2 =$ \"ATGGCC CGCCCC GGCGTG ACCTCC CTGCAG GAGAAC AAGATC TACCAC\"，指令 $d_2 = \\text{deoptimize}$，窗口长度 $L_2 = 60$ 核苷酸。\n- 案例3：$S_3 =$ \"ATG\"，指令 $d_3 = \\text{optimize}$，窗口长度 $L_3 = 30$ 核苷酸。\n- 案例4：$S_4 =$ \"ATGATA AGATTA GAAAAA TTTCAA CTAGAT TGTTAT GGACTA AAATTA\"，指令 $d_4 = \\text{deoptimize}$，窗口长度 $L_4 = 54$ 核苷酸。\n\n在所有情况下，将序列解释为没有空格的连续核苷酸字符串；上面显示中的空格是为了方便人类阅读而分隔密码子。所有能量必须以 $\\mathrm{kcal/mol}$ 为单位计算和报告。所有角度都是无关的。任何小数答案都必须表示为十进制数而不是百分比。\n\n要求输出：\n- 对于每个案例 $i \\in \\{1,2,3,4\\}$，计算列表\n$$\nR_i \\equiv \\big[ \\Delta \\mathrm{MFE}_i,\\ \\Delta \\mathrm{CAI}_i,\\ \\mathrm{initiation\\_hindered}_i,\\ \\mathrm{elongation\\_slowed}_i \\big],\n$$\n其中前两个条目是浮点数，后两个是布尔值。\n- 您的程序应生成单行输出，其中包含所有案例的结果，格式为逗号分隔的列表，并用方括号括起来，每个 $R_i$ 本身也用方括号括起来，并且每个 $R_i$ 中的两个浮点数四舍五入到 $6$ 位小数。例如，一个语法正确但使用占位符数字和布尔值的输出将是 \"[[0.000000,0.000000,False,False],[...],...]\"。实际的数字和布尔值必须是您实现所计算出的值，而不是占位符。\n\n科学现实性和约束：\n- 仅使用指定的定义和常数：$\\beta=\\ln(2)$，碱基对能量 $-3.0$、$-2.0$、$-1.0$ $\\mathrm{kcal/mol}$ 按规定，最小环长 $m=3$，阈值 $\\tau=1.0$ $\\mathrm{kcal/mol}$ 和 $\\epsilon=0.005$。\n- 不要导入任何外部数据；标准遗传密码所需的所有映射（仅限有义密码子）必须在您的程序中编码。",
            "solution": "该问题要求开发一个计算流程，用于分析对一个编码DNA序列 $S$ 进行同义重编码后，对蛋白质翻译的两个关键方面——起始和延伸——产生的影响。该分析基于信使RNA (mRNA) 二级结构稳定性和密码子使用偏好的简化模型。解决方案涉及一个多步骤过程：首先，建立必要的生物分子数据和模型；其次，实现序列重编码、密码子适应指数 (CAI) 计算和最小自由能 (MFE) 估计算法；最后，整合这些组件以计算指定的变化并得出推论。\n\n该过程始于将提供的规则和定义形式化。\n\n**1. 密码子偏好模型和密码子适应指数 (CAI)**\n\n密码子使用偏好的生物学现象通过一个基于鸟嘌呤-胞嘧啶 (GC) 含量的密码子偏好系统进行建模。\n\n-   **遗传密码**：标准遗传密码定义了从 $61$ 个有义密码子到 $20$ 种氨基酸的映射。这些信息必须被编码，包括每种氨基酸 $a$ 的同义密码子集合 $\\mathcal{C}(a)$。\n-   **密码子权重**：对于每个密码子 $c$，其原始偏好 $r(c)$ 计算为 $r(c) = \\exp(\\beta \\cdot \\mathrm{GC}(c))$，其中 $\\mathrm{GC}(c)$ 是密码子中 'G' 或 'C' 核苷酸的数量，$\\beta = \\ln(2)$。这可以简化为 $r(c) = 2^{\\mathrm{GC}(c)}$。对于密码子 $c \\in \\mathcal{C}(a)$，其归一化权重 $w(c)$ 相对于该氨基酸最偏好的同义密码子进行定义：\n    $$\n    w(c) = \\frac{r(c)}{\\max_{c' \\in \\mathcal{C}(a)} r(c')}\n    $$\n    根据此定义，对于其同义密码子家族中具有最高GC含量的密码子，$w(c)$ 达到最大值。\n-   **CAI 计算**：对于一个包含 $n$ 个密码子 $(c_1, c_2, \\dots, c_n)$ 的序列 $S$，其密码子适应指数 (CAI) 是它们权重的几何平均数：\n    $$\n    \\mathrm{CAI}(S) \\equiv \\left( \\prod_{i=1}^n w(c_i) \\right)^{1/n}\n    $$\n    为了数值稳定性，这通常使用对数来计算：$\\mathrm{CAI}(S) = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^n \\ln(w(c_i))\\right)$。\n\n**2. 同义重编码**\n\n同义重编码操作根据指令 $d \\in \\{\\text{optimize}, \\text{deoptimize}\\}$ 修改输入序列 $S$ 以产生新序列 $S^{(d)}$。对于 $S$ 中的每个密码子，它被一个同义密码子替换，该密码子要么最大化（优化）要么最小化（反优化）权重 $w(c)$。由于 $w(c)$ 是 $\\mathrm{GC}(c)$ 的单调函数，这等同于选择具有最高或最低GC含量的同义密码子。在出现平局（多个密码子具有相同的GC含量）的情况下，会应用一个确定性的平局打破规则，例如选择字母顺序靠前的密码子，以确保结果唯一。起始密码子 $\\mathrm{ATG}$ 以及单密码子氨基酸（甲硫氨酸和色氨酸）的密码子保持不变。\n\n**3. RNA二级结构的最小自由能 (MFE)**\n\n影响翻译起始的 $5'$ 端 mRNA 二级结构的稳定性，是使用一个简化的MFE模型来估计的。该模型适用于序列的头 $L$ 个核苷酸（从DNA转换为RNA，即 $\\mathrm{T} \\to \\mathrm{U}$）。MFE 是在所有有效的、非交叉的二级结构（碱基对的集合）中可能的最小能量。总能量是单个碱基对贡献的总和，没有其他能量项。指定的配对能量为：$\\mathrm{G-C}$ ($ -3.0 \\ \\mathrm{kcal/mol}$)，$\\mathrm{A-U}$ ($ -2.0 \\ \\mathrm{kcal/mol}$)，以及 $\\mathrm{G-U}$ 摆动配对 ($ -1.0 \\ \\mathrm{kcal/mol}$)。一个结构约束被强加：一个发夹环必须至少包含 $m=3$ 个未配对的核苷酸，这意味着位置 $i$ 和 $j$ 的碱基之间的配对仅在 $j - i - 1 \\ge 3$ 或 $j \\ge i+4$ 时被允许。\n\n这个问题使用标准的动态规划算法解决，该算法通常归功于 Zuker 和 Stiegler。设 $W(i, j)$ 是从索引 $i$ 到 $j$ 的子序列的MFE。$W(i, j)$ 的值通过考虑位置 $i$ 的碱基的两种可能性来确定：它要么是未配对的，要么它与某个位置 $k$ 的碱基形成配对。这导致了以下递推关系：\n$$\nW(i, j) = \\min \\left( W(i+1, j), \\quad \\min_{k = i+m+1}^{j} \\left( E_{\\text{pair}}(X_i, X_k) + W(i+1, k-1) + W(k+1, j) \\right) \\right)\n$$\n其中 $E_{\\text{pair}}(X_i, X_k)$ 是对 $(X_i, X_k)$ 的能量，仅对于允许的沃森-克里克和摆动配对非零。项 $W(i+1, j)$ 对应于碱基 $i$ 未配对的情况。带有内部最小值的项考虑了碱基 $i$ 的所有可能的配对伙伴 $k$，并受最小环长约束。这种结构的能量是配对能量以及所产生的独立子问题的MFE之和：由该配对包围的区域 $W(i+1, k-1)$，和配对外部的区域 $W(k+1, j)$。基本情况是，如果 $j < i+m+1$，则 $W(i, j) = 0$，因为无法形成有效配对。整个长度为 $N$ 的序列的MFE是 $W(0, N-1)$。这个递推可以通过填充DP表迭代实现，或通过带记忆化的递归实现。\n\n**4. 最终分析**\n\n对于每个测试用例，执行以下步骤：\n1.  解析输入序列 $S$、指令 $d$ 和窗口长度 $L$。\n2.  计算原始序列的CAI，$\\mathrm{CAI}(S)$。\n3.  提取 $5'$ 窗口 $S_{1:L}$ 并计算其MFE，$\\mathrm{MFE}(S_{1:L})$。\n4.  执行同义重编码以获得 $S^{(d)}$。\n5.  计算重编码序列的CAI，$\\mathrm{CAI}(S^{(d)})$。\n6.  提取重编码序列的 $5'$ 窗口 $S^{(d)}_{1:L}$ 并计算其MFE，$\\mathrm{MFE}(S^{(d)}_{1:L})$。\n7.  计算变化量：$\\Delta \\mathrm{MFE} = \\mathrm{MFE}(S^{(d)}_{1:L}) - \\mathrm{MFE}(S_{1:L})$ 和 $\\Delta \\mathrm{CAI} = \\mathrm{CAI}(S^{(d)}) - \\mathrm{CAI}(S)$。\n8.  应用给定阈值确定布尔结果：\n    -   如果 $\\Delta \\mathrm{MFE} \\leq -1.0$，`initiation_hindered` 为 $\\mathrm{True}$。\n    -   如果 $\\Delta \\mathrm{CAI} \\leq -0.005$，`elongation_slowed` 为 $\\mathrm{True}$。\n然后，将所有案例的最终结果格式化为指定的单个列表。",
            "answer": "```python\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the codon usage bias problem by implementing a full computational pipeline\n    for sequence analysis, including recoding, CAI, and MFE calculations.\n    \"\"\"\n\n    # --- Data and Model Setup ---\n\n    GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'CTT': 'L', 'CTC': 'L', \n        'CTA': 'L', 'CTG': 'L', 'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V', 'TCT': 'S', 'TCC': 'S', \n        'TCA': 'S', 'TCG': 'S', 'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'GCT': 'A', 'GCC': 'A', \n        'GCA': 'A', 'GCG': 'A', 'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H', \n        'CAA': 'Q', 'CAG': 'Q', 'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E', 'TGT': 'C', 'TGC': 'C', \n        'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R', 'AGT': 'S', \n        'AGC': 'S', 'AGA': 'R', 'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    AMINO_ACIDS = {}\n    for codon, aa in GENETIC_CODE.items():\n        if aa not in AMINO_ACIDS:\n            AMINO_ACIDS[aa] = []\n        AMINO_ACIDS[aa].append(codon)\n\n    BETA = math.log(2)\n\n    def gc_content(codon):\n        return codon.count('G') + codon.count('C')\n\n    # Precompute codon weights w(c)\n    CODON_WEIGHTS = {}\n    for aa, codons in AMINO_ACIDS.items():\n        if not codons: continue\n        raw_prefs = {c: math.exp(BETA * gc_content(c)) for c in codons}\n        max_raw_pref = max(raw_prefs.values()) if raw_prefs else 1.0\n        for c in codons:\n            CODON_WEIGHTS[c] = raw_prefs[c] / max_raw_pref if max_raw_pref > 0 else 0.0\n\n    # Precompute recoding maps with alphabetical tie-breaking\n    OPTIMIZE_MAP = {}\n    DEOPTIMIZE_MAP = {}\n    for aa, codons in AMINO_ACIDS.items():\n        if len(codons) <= 1:\n            OPTIMIZE_MAP[aa] = codons[0] if codons else None\n            DEOPTIMIZE_MAP[aa] = codons[0] if codons else None\n            continue\n        \n        gc_counts = [(gc_content(c), c) for c in codons]\n        max_gc = max(gc for gc, c in gc_counts)\n        min_gc = min(gc for gc, c in gc_counts)\n        \n        optimal_codons = sorted([c for gc, c in gc_counts if gc == max_gc])\n        deoptimal_codons = sorted([c for gc, c in gc_counts if gc == min_gc])\n        \n        OPTIMIZE_MAP[aa] = optimal_codons[0]\n        DEOPTIMIZE_MAP[aa] = deoptimal_codons[0]\n\n    # --- MFE Calculator Class ---\n    \n    class MFECalculator:\n        def __init__(self):\n            self.pair_energies = {\n                frozenset({'A', 'U'}): -2.0,\n                frozenset({'G', 'C'}): -3.0,\n                frozenset({'G', 'U'}): -1.0,\n            }\n            self.m = 3\n            self.memo = {}\n\n        def get_pair_energy(self, b1, b2):\n            return self.pair_energies.get(frozenset({b1, b2}), 0.0)\n\n        def _calculate_mfe_recursive(self, seq, i, j):\n            if (i, j) in self.memo:\n                return self.memo[(i, j)]\n            if j < i + self.m + 1:\n                return 0.0\n\n            # Case 1: base i is unpaired\n            res = self._calculate_mfe_recursive(seq, i + 1, j)\n\n            # Case 2: base i is paired with k\n            for k in range(i + self.m + 1, j + 1):\n                pe = self.get_pair_energy(seq[i], seq[k])\n                if pe < 0:\n                    energy = pe + self._calculate_mfe_recursive(seq, i + 1, k - 1) + self._calculate_mfe_recursive(seq, k + 1, j)\n                    if energy < res:\n                        res = energy\n            \n            self.memo[(i, j)] = res\n            return res\n\n        def compute_mfe(self, dna_sequence_fragment):\n            self.memo.clear()\n            if not dna_sequence_fragment:\n                return 0.0\n            rna_seq = dna_sequence_fragment.replace('T', 'U')\n            return self._calculate_mfe_recursive(rna_seq, 0, len(rna_seq) - 1)\n    \n    # --- Core Functions ---\n\n    def calculate_cai(dna_sequence):\n        codons = [dna_sequence[i:i+3] for i in range(0, len(dna_sequence), 3)]\n        if not codons:\n            # Defined for n>=1, but as a safe-guard for empty sequences\n            return 1.0\n        \n        log_weights = [math.log(CODON_WEIGHTS[c]) for c in codons if c in CODON_WEIGHTS]\n        return math.exp(sum(log_weights) / len(log_weights))\n\n    def recode_sequence(dna_sequence, directive):\n        codons = [dna_sequence[i:i+3] for i in range(0, len(dna_sequence), 3)]\n        if not codons:\n            return \"\"\n            \n        recoded_codons = []\n        recoding_map = OPTIMIZE_MAP if directive == 'optimize' else DEOPTIMIZE_MAP\n        \n        # Preserve the first codon if it is ATG\n        if codons[0] == 'ATG':\n            recoded_codons.append(codons[0])\n            start_index = 1\n        else:\n            start_index = 0\n            \n        for i in range(start_index, len(codons)):\n            codon = codons[i]\n            aa = GENETIC_CODE.get(codon)\n            if aa:\n                recoded_codons.append(recoding_map[aa])\n        \n        return \"\".join(recoded_codons)\n\n    # --- Main Processing Logic ---\n\n    test_cases = [\n        (\"ATGAAAAATGGTTCTGCTGTACCTACTGAAGATCAACTGATTTATCAT\", \"optimize\", 45),\n        (\"ATGGCCCGCCCCGGCGTGACCTCCCTGCAGGAGAACAAGATCTACCAC\", \"deoptimize\", 60),\n        (\"ATG\", \"optimize\", 30),\n        (\"ATGATAAGATTAGAAAAATTTCAACTAGATTGTTATGGACTAAAATTA\", \"deoptimize\", 54),\n    ]\n\n    results = []\n    mfe_calculator = MFECalculator()\n\n    for s_orig, directive, l_window in test_cases:\n        # 1. Analyze original sequence\n        cai_orig = calculate_cai(s_orig)\n        s_orig_frag = s_orig[:min(len(s_orig), l_window)]\n        mfe_orig = mfe_calculator.compute_mfe(s_orig_frag)\n\n        # 2. Recode and analyze new sequence\n        s_recoded = recode_sequence(s_orig, directive)\n        cai_recoded = calculate_cai(s_recoded)\n        s_recoded_frag = s_recoded[:min(len(s_recoded), l_window)]\n        mfe_recoded = mfe_calculator.compute_mfe(s_recoded_frag)\n        \n        # 3. Compute changes and inferences\n        delta_mfe = mfe_recoded - mfe_orig\n        delta_cai = cai_recoded - cai_orig\n        \n        tau = 1.0\n        epsilon = 0.005\n        \n        initiation_hindered = delta_mfe <= -tau\n        elongation_slowed = delta_cai <= -epsilon\n        \n        results.append([delta_mfe, delta_cai, initiation_hindered, elongation_slowed])\n\n    # Format output\n    output_parts = []\n    for res in results:\n        output_parts.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]},{res[3]}]\")\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "从计算预测到经验验证是科学研究的关键一步，但观察到的表型与基因改造之间的相关性不等于因果性。当一个经过密码子去优化的基因导致生长缺陷时，其背后的机制可能涉及翻译延伸、转录效率或 $mRNA$ 稳定性等多个环节。本练习挑战您像实验生物学家一样思考，设计一套严谨的对照实验，以精准地区分密码子使用对翻译延伸的直接影响与各种潜在的混杂因素，这是该领域研究者必备的批判性思维能力 。",
            "id": "2697535",
            "problem": "您在一种细菌（为具体起见，假设为 *Escherichia coli*）中，对一个必需酶基因的编码序列进行了同义密码子去优化，同时保持启动子和非翻译区不变。您观察到，与在相同基因座表达的野生型编码序列相比，其指数生长速率有所下降。您假设密码子使用偏好通过有限的转运RNA（tRNA）供应来降低翻译延伸速率，但您也知道密码子的改变也可能通过影响转录产出和降解来改变信使RNA（mRNA）的丰度，并可能改变预测的、会阻碍翻译起始的mRNA折叠能。根据基本原理，任何关于密码子使用偏好在翻译中起因果作用的推断，都必须在控制了mRNA丰度、mRNA稳定性和局部mRNA折叠能量学等变量后才能得出。\n\n回想中心法则（DNA $\\to$ RNA $\\to$ 蛋白质）以及对于一个给定的转录本，在稳态下，一个简单的质量作用模型给出 $d[mRNA]/dt = k_{tx} - k_{deg}[mRNA]$，这意味着 $[mRNA]_{\\mathrm{ss}} = k_{tx}/k_{deg}$，而蛋白质的积累则取决于翻译起始和延伸的速率。可测量的替代指标包括：使用反转录定量聚合酶链式反应（RT-qPCR）或RNA测序来测量 $[mRNA]$；使用转录抑制追踪实验来测量 $k_{deg}$；以及预测在与核糖体结合位点（RBS）和起始密码子重叠区域的RNA二级结构的最小自由能（MFE；记为 $\\Delta G$）。\n\n下列哪组实验对照最适合将观察到的生长缺陷解释为密码子使用偏好影响翻译的结果，并且该组实验明确包含了对mRNA丰度、mRNA稳定性和预测折叠能的检测？请选择所有适用选项。\n\nA. 使用外源spike-in RNA进行归一化，通过RT-qPCR测量绝对mRNA丰度；通过rifampicin转录抑制实验估计mRNA半衰期，并拟合 $[mRNA](t) = [mRNA](0)\\,e^{-k_{deg} t}$ 以获得 $k_{deg}$；计算野生型和去优化构建体中跨越Shine–Dalgarno序列、起始密码子和编码区前$+60$个核苷酸窗口的预测 $\\Delta G$；确认启动子和 5' 非翻译区序列相同；通过Western blot或酶活性测定来量化蛋白质产出；通过共表达受限的同源转运RNA集和通过同义回复突变至最优密码子来进行回复实验。\n\nB. 计算密码子适应指数（Codon Adaptation Index）并将其与生长速率比较；测量每单位培养体积的总RNA产量作为mRNA丰度的替代指标；对于稳定性，假设任何密码子去优化的mRNA都必定更不稳定；忽略RNA折叠，因为只有蛋白质编码信息才重要。\n\nC. 在总RNA上样量相等的情况下，使用Northern blot评估mRNA信号；通过actinomycin D处理来估计mRNA半衰期；计算全长mRNA的单一全局MFE；将qPCR数据归一化到一个已知具有应激响应性表达的参考基因；如果Northern信号相似，则推断存在翻译效应。\n\nD. 使用带有External RNA Controls Consortium (ERCC) spike-ins的RNA测序来量化mRNA丰度，以估计每个细胞的绝对转录本数；通过$4$-thiouridine脉冲追踪标记法测量mRNA稳定性，以直接拟合转录本特异性的降解常数 $k_{deg}$；计算RBS、起始密码子附近（$-20$至$+60$个核苷酸）以及编码区前300个核苷酸的局部折叠能 $\\Delta G$；设计一个同义对照，该对照在氨基酸序列、总体鸟嘌呤-胞嘧啶含量以及CpG/UpA双核苷酸频率方面相匹配；确认启动子和非翻译区相同；执行核糖体图谱分析（ribosome profiling）以估计起始和延伸的核糖体密度。\n\nE. 通过RT-qPCR测量mRNA丰度，并用看家基因进行归一化；计算 5' 非翻译区的局部 $\\Delta G$；通过活性测定证明蛋白质水平降低；在没有进行降解测定的情况下，得出翻译受限的结论，理由是已经测量了丰度和折叠。",
            "solution": "问题陈述在分子系统生物学领域提出了一个有效且定义明确的问题。它要求设计出最合适的实验方案，以便在控制已知混杂变量的同时，将同义密码子去优化通过降低翻译延伸而导致的生长缺陷与其建立因果联系。问题的核心在于设计一个能够区分转录（$k_{tx}$）、mRNA稳定性（$k_{deg}$）、翻译起始（受mRNA结构 $\\Delta G$ 影响）和翻译延伸（受密码子使用和tRNA供应量影响）这几方面效应的实验。一个有效的实验方法必须严格测量并解释每一种潜在的效应。\n\n基本关系已经给出。信使RNA的稳态浓度 $[mRNA]_{\\mathrm{ss}}$ 由其合成速率（$k_{tx}$）和降解速率常数（$k_{deg}$）的比值决定：\n$$[mRNA]_{\\mathrm{ss}} = \\frac{k_{tx}}{k_{deg}}$$\n观察到的表型，即蛋白质产量和生长速率的下降，可能是由于 $[mRNA]_{\\mathrm{ss}}$ 的减少（源于较低的 $k_{tx}$ 或较高的 $k_{deg}$），也可能是由于将现有mRNA翻译成蛋白质的效率降低。翻译效率本身可能受限于起始（通常受起始密码子附近的RNA二级结构影响）或延伸（受密码子使用和tRNA供应量影响）。\n\n因此，一个稳健的实验设计必须：\n$1$. 对野生型和去优化的构建体，量化其绝对 $[mRNA]$ 水平。\n$2$. 独立测量mRNA降解速率 $k_{deg}$，以区分转录和稳定性方面的影响。\n$3$. 评估翻译起始区的局部mRNA二级结构。\n$4$. 确认没有引入非预期的序列变化，尤其是在启动子和 5' 非翻译区（UTR）等调控区域。\n$5$. 理想情况下，为假设的机制提供直接证据，例如回复实验或直接测量核糖体活性。\n\n基于这些原则，我们来评估每个选项。\n\nA. 该选项提出了一个全面且方法学上合理的实验方案。\n    - **mRNA丰度**：“使用外源spike-in RNA进行归一化，通过RT-qPCR测量绝对mRNA丰度”是一种精确绝对定量的金标准方法，优于使用可能变化的看家基因进行归一化。\n    - **mRNA稳定性**：“通过rifampicin转录抑制实验估计mRNA半衰期，并拟合 $[mRNA](t) = [mRNA](0)\\,e^{-k_{deg} t}$ 以获得 $k_{deg}$”是测量细菌中mRNA降解速率的经典且正确的方法。\n    - **mRNA折叠**：“计算跨越Shine–Dalgarno序列、起始密码子和编码区前$+60$个核苷酸窗口的预测 $\\Delta G$”正确地聚焦于对翻译起始至关重要的局部二级结构。\n    - **对照**：“确认启动子和 5' 非翻译区序列相同”是一个必要的合理性检查。\n    - **蛋白质产出**：“通过Western blot或酶活性测定来量化蛋白质产出”正确地测量了基因表达的最终结果。\n    - **因果关系**：“通过共表达受限的同源转运RNA集和通过同义回复突变至最优密码子来进行回复实验”为所假设的tRNA受限机制提供了强有力的直接证据。如果过表达稀有密码子对应的tRNA能够挽救该缺陷，则强烈支持该假设。\n该实验设计严谨、全面，并在控制特定混杂因素的同时直接检验了假设。\n结论：**正确**。\n\nB. 这个选项存在严重缺陷，反映了不良的科研实践。\n    - **mRNA丰度**：“测量每单位培养体积的总RNA产量作为mRNA丰度的替代指标”是一个无效的替代指标。总RNA主要由核糖体RNA（>80%）组成，因此该测量对单个mRNA种类的变化不敏感。\n    - **mRNA稳定性**：“假设任何密码子去优化的mRNA都必定更不稳定”是一个未经证实的假设。科学结论必须基于测量，而非假设。\n    - **mRNA折叠**：“忽略RNA折叠，因为只有蛋白质编码信息才重要”在事实上是错误的。RNA结构是基因表达的一个主要非编码决定因素，尤其是在翻译起始方面。\n    - **相关性**：“计算密码子适应指数并将其与生长速率比较”只是建立了相关性，这是研究的起点，而不是证明因果关系所需的对照组。\n该方法从基本原理上就是无效的。\n结论：**错误**。\n\nC. 该选项包含几个方法学上的错误。\n    - **mRNA丰度**：“在总RNA上样量相等的情况下，使用Northern blot评估mRNA信号”是一种定性上可接受但定量上较差的方法，不如带spike-ins的qPCR。\n    - **mRNA稳定性**：“actinomycin D处理”是一种转录抑制剂，但rifampicin是针对细菌RNA聚合酶的标准且更具特异性的抑制剂。对于*E. coli*而言，这是一个次优选择。\n    - **mRNA折叠**：“计算全长mRNA的单一全局MFE”是不正确的。翻译起始受核糖体结合位点附近的局部RNA结构控制，而不是整个分子的全局折叠。\n    - **归一化**：“将qPCR数据归一化到一个已知具有应激响应性表达的参考基因”是根本错误的。归一化需要一个在各种条件下表达稳定的参考基因，因此使用应激响应基因会引入显著的假象并使定量无效。\n这种次优和错误方法的组合使得该设计不可靠。\n结论：**错误**。\n\nD. 这个选项描述了一个最先进且异常严谨的实验方案。\n    - **mRNA丰度**：“使用带有External RNA Controls Consortium (ERCC) spike-ins的RNA测序”提供了绝对的、转录组范围的mRNA丰度量化，代表了此类测量的最高标准。\n    - **mRNA稳定性**：“通过$4$-thiouridine脉冲追踪标记法测量mRNA稳定性”是一种现代、强大的测量RNA降解速率的方法，没有转录抑制药物的多效性副作用。它允许对 $k_{deg}$ 进行转录本特异性的测量。\n    - **mRNA折叠**：“计算RBS、起始密码子附近（$-20$至$+60$个核苷酸）以及编码区前300个核苷酸的局部折叠能 $\\Delta G$”是对相关局部结构的详尽分析。\n    - **对照**：“设计一个...在...方面相匹配的同义对照”是一种精密的对照，它考虑了已知会影响mRNA稳定性和翻译的其他序列特征，从而比简单的野生型比较更精确地分离出密码子选择的效应。\n    - **直接翻译测量**：“执行核糖体图谱分析”是所列技术中最强大的。它通过对核糖体保护的mRNA片段进行测序，直接在体内测量翻译，提供了关于翻译起始（起始位点的核糖体密度）和延伸（沿编码序列的核糖体密度）的数据。它可以直接将核糖体在稀有密码子处的暂停可视化。\n这个设计不仅恰当，而且代表了解决此类问题的方法学前沿。\n结论：**正确**。\n\nE. 这个选项有一个关键的遗漏。\n    - **mRNA丰度**：“通过RT-qPCR测量mRNA丰度，并用看家基因进行归一化”是一种常用但不如使用spike-ins严谨的方法，因为看家基因的表达可能会变化。\n    - **mRNA折叠**：对 $\\Delta G$ 的分析仅限于“5' 非翻译区”，这是不完整的。起始密码子和已被改变的初始编码区的结构也必须被评估。\n    - **关键缺陷**：提议“在没有进行降解测定的情况下，得出翻译受限的结论”是一个致命的逻辑错误。如前所述，$[mRNA]_{\\mathrm{ss}} = k_{tx}/k_{deg}$。在没有首先测量 $k_{deg}$ 以确定变化是否仅仅是由于mRNA稳定性改变的情况下，测得的 $[mRNA]$ 变化不能归因于翻译。省略这一步使得无法区分转录和转录后效应。\n这个设计是不完整的，它所允许得出的结论是没有依据的。\n结论：**错误**。\n\n总而言之，选项A和D都描述了优秀、严谨且恰当的实验设计，以解决该科学问题。选项A代表了一种经典的、稳健的方法，其核心是一个强有力的遗传回复实验。选项D代表了一种现代的、基于组学的方法，它为分子过程提供了更直接、更高分辨率的测量。两者都是有效且正确的选择。",
            "answer": "$$\\boxed{AD}$$"
        }
    ]
}