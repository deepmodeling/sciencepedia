{
    "hands_on_practices": [
        {
            "introduction": "计算细胞生物学中的一项基本任务是实现和检验关于生物过程的竞争性假说。本练习将指导您为三种经典的细胞尺寸控制模型（“sizer”、“adder”和“timer”）构建基于智能体的模拟。通过生成模拟数据并将其与理论预测进行比较，您将培养模型实现和数据驱动模型辨别的实践技能 。",
            "id": "3905570",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，用于在基于智能体的细胞群体建模中比较三种经典的单细胞分裂控制假说：尺寸测量器 (sizer)、加法器 (adder) 和计时器 (timer)。您的程序必须 (i) 从第一性原理出发，推导并模拟每种控制模型在出生和分裂时的预期稳态尺寸分布，(ii) 计算一个定量标准，以识别哪个模型最符合一个在已知参数下生成的单细胞尺寸数据集，以及 (iii) 输出一行包含一组测试用例的预测模型标识符。这三种模型根据细胞在恒定增长率下指数生长时如何决定何时分裂来定义。其基础是标准的生物生长定律和随机分配：\n- 指数增长定律：一个出生尺寸为 $s_b$ 的细胞以恒定增长率 $g$ 进行生长，其尺寸为 $s(t) = s_b \\exp(g t)$。\n- 分裂时的随机分配：当一个细胞在尺寸为 $s_d$ 时分裂，其子细胞的出生尺寸为 $f s_d$ 和 $(1-f) s_d$，其中 $f \\in (0,1)$ 是一个随机分配分数，在每次分裂时从参数为 $(\\alpha,\\beta)$ 的贝塔分布 (Beta distribution) 中独立采样。\n\n分裂控制模型的定义如下：\n- 尺寸测量器 (Sizer)：当细胞尺寸达到一个带噪声的阈值时，细胞分裂，$s_d = S_c \\exp(\\eta)$，其中 $S_c$ 是一个常数，$\\eta \\sim \\mathcal{N}(0,\\sigma_\\eta^2)$ 捕捉了阈值噪声。\n- 加法器 (Adder)：细胞在增加一个带噪声的尺寸增量后分裂，$s_d = s_b + \\Delta$，其中 $\\Delta = \\Delta_0 \\exp(\\eta)$，$\\Delta_0$ 为常数，$\\eta \\sim \\mathcal{N}(0,\\sigma_\\eta^2)$。\n- 计时器 (Timer)：细胞在经过一个带噪声的计时器时长 $T \\sim \\mathcal{N}(T_0,\\sigma_T^2)$ 后，在指数生长下分裂，$s_d = s_b \\exp(g T)$，其中 $T_0$ 是一个恒定的平均分裂时间。\n\n您的任务是从上述基础出发，不使用简化公式，推导每种模型下稳态分布 $p(s_b)$ 和 $p(s_d)$ 的预期形状，然后实现一个基于智能体的模拟来近似这些分布，并计算一个稳健的统计量以从数据集中识别模型。程序必须：\n1. 使用提供的参数模拟一个单细胞谱系，固定代数为 $n_{\\text{gen}}$，以生成两个数组：出生尺寸 $\\{s_b^{(i)}\\}_{i=1}^{n_{\\text{gen}}}$ 和分裂尺寸 $\\{s_d^{(i)}\\}_{i=1}^{n_{\\text{gen}}}$。\n2. 为了识别，计算模拟数据集中 $s_d^{(i)}$ 和 $s_b^{(i)}$ 之间的线性回归斜率 $\\hat{m}$，并将此斜率与每种模型的理论预期斜率进行比较，这些预期斜率是根据 $g$ 和 $T_0$ 定义的。具体来说，预期斜率是：尺寸测量器 $\\approx 0$，加法器 $\\approx 1$，计时器 $\\approx \\exp(g T_0)$。最小化绝对偏差 $|\\hat{m} - m_{\\text{model}}|$ 的模型即为预测的匹配模型。\n3. 对于每个测试用例，返回预测模型的标识符（整数），其中尺寸测量器为 $0$，加法器为 $1$，计时器为 $2$。\n\n不需要物理单位；尺寸单位为任意单位 (a.u.)，时间单位为任意时间单位。不使用角度。所有输出必须是数字。\n\n测试套件：\n使用以下参数集和随机种子来生成数据集。对于每种情况，从初始出生尺寸 $s_b^{(0)} = 0.8$ 开始，模拟一个单细胞谱系的 $n_{\\text{gen}}$ 次分裂。为保证可复现性，请将随机数生成器的种子设置为给定的整数。\n\n- 情况 1 (常规路径，尺寸测量器生成的数据集):\n  - 真实模型：尺寸测量器 ($0$)\n  - $g = 0.02$\n  - $S_c = 1.0$\n  - $\\sigma_\\eta = 0.1$\n  - $\\alpha = 50$, $\\beta = 50$\n  - $T_0 = \\ln(2)/g$ (仅用于定义计时器模型的期望以供比较)\n  - $\\sigma_T = 3.0$\n  - $n_{\\text{gen}} = 3000$\n  - 种子 $= 42$\n\n- 情况 2 (常规路径，加法器生成的数据集):\n  - 真实模型：加法器 ($1$)\n  - $g = 0.02$\n  - $\\Delta_0 = 0.5$\n  - $\\sigma_\\eta = 0.1$\n  - $\\alpha = 50$, $\\beta = 50$\n  - $T_0 = \\ln(2)/g$\n  - $\\sigma_T = 3.0$\n  - $n_{\\text{gen}} = 3000$\n  - 种子 $= 43$\n\n- 情况 3 (边缘案例，计时器生成的具有非对称分配的数据集):\n  - 真实模型：计时器 ($2$)\n  - $g = 0.02$\n  - $T_0 = \\ln(2)/g$\n  - $\\sigma_T = 3.0$\n  - $\\alpha = 5$, $\\beta = 5$\n  - $S_c = 1.0$\n  - $\\Delta_0 = 0.5$\n  - $\\sigma_\\eta = 0.1$\n  - $n_{\\text{gen}} = 3000$\n  - 种子 $= 44$\n\n- 情况 4 (边界案例，加法器生成的具有近乎确定性分裂和对称分配的数据集):\n  - 真实模型：加法器 ($1$)\n  - $g = 0.02$\n  - $\\Delta_0 = 0.7$\n  - $\\sigma_\\eta = 10^{-6}$\n  - $\\alpha = 500$, $\\beta = 500$\n  - $T_0 = \\ln(2)/g$\n  - $\\sigma_T = 3.0$\n  - $n_{\\text{gen}} = 2000$\n  - 种子 $= 45$\n\n实现与输出要求：\n- 您的程序必须是一个单一、独立、可运行的 Python $3.12$ 脚本，仅使用标准库以及 NumPy ($1.23.5$) 和 SciPy ($1.11.4$)（如果需要）。\n- 对于每个测试用例，您必须：\n  1. 在指定的真实模型和参数下通过模拟谱系来生成数据集。\n  2. 计算 $s_d$ 和 $s_b$ 之间的回归斜率 $\\hat{m}$。\n  3. 计算尺寸测量器 ($0$)、加法器 ($1$) 和计时器 ($\\exp(g T_0)$) 的预期斜率。\n  4. 通过最小化 $\\hat{m}$ 与这些预期斜率之间的绝对偏差来预测模型，并返回标识符（$0$、$1$ 或 $2$）。\n- 最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的预测模型标识符，格式为方括号内以逗号分隔的列表（例如，“[$m_1,m_2,m_3,m_4$]”），其中每个 $m_i$ 是 $\\{0,1,2\\}$ 中的一个整数。\n\n您的程序不得要求任何用户输入或外部文件，并且必须使用提供的种子确定性地运行。唯一的输出必须是所需格式的最终模型预测列表。",
            "solution": "所提出的问题是计算生物学领域中一个明确定义的任务，特别是在合成生物学建模领域。它要求实现一个基于智能体的模拟，以区分三种经典的细胞尺寸控制模型。该问题具有科学依据，内容自洽，且算法上已明确规定。所有参数均已提供，目标明确。因此，该问题是有效的，可以制定解决方案。\n\n问题的核心在于理解不同的分裂控制策略如何在细胞出生尺寸 $s_b$ 和分裂尺寸 $s_d$ 之间的可观察相关性中表现出来。我们将首先正式定义模型和模拟框架，然后推导识别标准的理论基础，最后概述算法流程。\n\n**基本原理：细胞生长与分裂**\n\n模拟基于单个细胞谱系的两个基本假设：\n1.  **指数增长：** 一个出生尺寸为 $s_b$ 的细胞随时间 $t$ 以恒定速率 $g$ 指数增长。其尺寸由函数 $s(t) = s_b \\exp(g t)$ 给出。\n2.  **随机分配：** 在尺寸为 $s_d$ 时分裂后，细胞分裂成两个子细胞。我们在谱系中跟踪的子细胞的出生尺寸为 $s_b' = f \\cdot s_d$，其中 $f$ 是一个随机分数。对于每个分裂事件，此分数 $f$ 从贝塔分布 $f \\sim \\text{Beta}(\\alpha, \\beta)$ 中采样。贝塔分布定义在区间 $(0, 1)$ 上，适合用于建模分配比例。参数 $\\alpha$ 和 $\\beta$ 控制分布的形状；当 $\\alpha = \\beta$ 时，发生对称分配（均值为 $0.5$）。\n\n**分裂控制模型**\n\n分裂的决定由三种不同的模型之一控制，每种模型以不同的方式引入随机性。\n\n1.  **尺寸测量器 (Sizer) 模型：** 当细胞尺寸 $s$ 达到特定阈值时触发分裂。该阈值不是固定的，而是受生物噪声的影响。分裂尺寸 $s_d$ 独立于出生尺寸 $s_b$，由以下公式确定：\n    $$s_d = S_c \\exp(\\eta)$$\n    其中 $S_c$ 是一个特征尺寸常数，$\\eta$ 是从正态分布 $\\eta \\sim \\mathcal{N}(0, \\sigma_\\eta^2)$ 中抽取的噪声项。对尺寸使用对数正态分布确保 $s_d$ 始终为正。\n\n2.  **加法器 (Adder) 模型：** 在细胞在其出生尺寸 $s_b$ 的基础上增加了一定尺寸量 $\\Delta$ 后触发分裂。这个增加的尺寸是带噪声的。分裂尺寸由以下公式给出：\n    $$s_d = s_b + \\Delta$$\n    其中增加的尺寸 $\\Delta = \\Delta_0 \\exp(\\eta)$，$\\Delta_0$ 是一个特征尺寸增量，$\\eta \\sim \\mathcal{N}(0, \\sigma_\\eta^2)$ 代表噪声。\n\n3.  **计时器 (Timer) 模型：** 在自出生起经过特定时长 $T$ 后触发分裂。该时长是带噪声的。给定指数增长，分裂尺寸为：\n    $$s_d = s_b \\exp(g T)$$\n    其中分裂时间 $T$ 从正态分布 $T \\sim \\mathcal{N}(T_0, \\sigma_T^2)$ 中抽取， $T_0$ 是平均分裂时间。\n\n**识别标准的推导**\n\n该问题建议使用分裂尺寸 $\\{s_d^{(i)}\\}$ 和出生尺寸 $\\{s_b^{(i)}\\}$ 之间线性回归的斜率作为模型识别的标准。设线性回归模型为 $\\hat{s}_d = \\hat{m} s_b + \\hat{c}$。我们可以为每种情况推导出理论上的预期斜率 $m_{\\text{model}}$。\n\n-   **尺寸测量器 (Sizer)：** 在此模型中，$s_d = S_c \\exp(\\eta)$。分裂尺寸 $s_d$ 的确定与出生尺寸 $s_b$ 无关。因此，在 $s_b$ 和 $s_d$ 之间没有预期的相关性。对由尺寸测量器机制生成的数据进行线性回归，应得到接近于零的斜率。\n    $$m_{\\text{sizer}} \\approx 0$$\n\n-   **加法器 (Adder)：** 该模型由线性关系 $s_d = s_b + \\Delta$ 定义。在 $s_d$ 对 $s_b$ 的回归中，这对应于一条斜率恰好为 $1$、截距等于平均增加尺寸 $\\langle \\Delta \\rangle$ 的直线。噪声项 $\\eta$ 影响截距，而非斜率。因此，预期斜率精确为一。\n    $$m_{\\text{adder}} = 1$$\n\n-   **计时器 (Timer)：** 模型为 $s_d = s_b \\exp(gT)$。$s_d$ 和 $s_b$ 之间的关系是乘法关系。线性回归的斜率 $\\hat{m}$ 由 $\\hat{m} = \\text{Cov}(s_b, s_d) / \\text{Var}(s_b)$ 给出。代入模型方程，我们得到 $\\text{Cov}(s_b, s_b \\exp(gT))$。在稳态下，一代的出生尺寸 $s_b$ 由前一代的分裂时间 $T$ 决定，这引入了复杂的相关性。然而，一个常见且有效的近似是假设同一代中的 $s_b$ 和 $T$ 近似独立。在此假设下，$\\text{Cov}(s_b, s_b \\exp(gT)) \\approx \\text{Var}(s_b) E[\\exp(gT)]$。则斜率为 $m \\approx E[\\exp(gT)]$。对于 $T \\sim \\mathcal{N}(T_0, \\sigma_T^2)$，项 $gT$ 服从正态分布 $gT \\sim \\mathcal{N}(gT_0, g^2\\sigma_T^2)$。所得对数正态变量的期望为 $E[\\exp(gT)] = \\exp(gT_0 + g^2\\sigma_T^2/2)$。问题指定使用更简单的近似，这在噪声较小或作为一阶表征时是有效的：\n    $$m_{\\text{timer}} \\approx \\exp(g T_0)$$\n    对于给定的参数，其中 $gT_0 = \\ln(2)$，此值评估为 $m_{\\text{timer}} \\approx 2$。这个值与 $0$ 和 $1$ 明显不同，使得斜率成为一个稳健的标识符。\n\n**模拟与分析算法**\n\n对于提供的每个测试用例：\n1.  **初始化：** 指定模拟参数（$g$、$S_c$、$\\sigma_\\eta$ 等）、真实模型类型、代数 $n_{\\text{gen}}$ 和随机种子。我们用给定的种子初始化一个随机数生成器。我们创建两个列表来存储出生尺寸序列 $\\{s_b^{(i)}\\}$ 和分裂尺寸序列 $\\{s_d^{(i)}\\}$。模拟从第 $i=0$ 代的第一个细胞开始，其具有指定的初始出生尺寸 $s_b^{(0)} = 0.8$。\n\n2.  **代际循环：** 循环运行 $n_{\\text{gen}}$ 代，从 $i=0$ 到 $n_{\\text{gen}}-1$。在每次迭代 $i$ 中：\n    a. 当前出生尺寸为 $s_b^{(i)}$。\n    b. 根据测试用例的 `true_model`，应用相应的分裂规则来计算分裂尺寸 $s_d^{(i)}$。这涉及从相关的噪声分布（尺寸噪声为 $\\mathcal{N}(0, \\sigma_\\eta^2)$ 或时间噪声为 $\\mathcal{N}(T_0, \\sigma_T^2)$）中采样。\n    c. 记录数据对 $(s_b^{(i)}, s_d^{(i)})$。\n    d. 通过模拟分配来计算下一代的出生尺寸 $s_b^{(i+1)}$。从 $\\text{Beta}(\\alpha, \\beta)$ 中抽取一个随机分数 $f$，并将下一个出生尺寸设置为 $s_b^{(i+1)} = f \\cdot s_d^{(i)}$。\n\n3.  **模型识别：** 模拟完成后：\n    a. 将记录的出生和分裂尺寸列表转换为数值数组。\n    b. 对 $s_d$ 关于 $s_b$ 进行简单线性回归，以计算样本斜率 $\\hat{m}$。\n    c. 计算三个理论斜率：$m_0 = 0$，$m_1 = 1$ 和 $m_2 = \\exp(g T_0)$。\n    d. 计算绝对偏差 $|\\hat{m} - m_0|$、 $|\\hat{m} - m_1|$ 和 $|\\hat{m} - m_2|$。\n    e. 选择与最小偏差相对应的模型作为预测模型。结果是其整数标识符（尺寸测量器为 $0$，加法器为 $1$，计时器为 $2$）。\n\n对四个测试用例中的每一个重复此整个过程，并将生成的标识符列表格式化为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cell division model identification problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (happy path, sizer-generated dataset)\n        {\n            \"true_model\": 0, \"g\": 0.02, \"S_c\": 1.0, \"sigma_eta\": 0.1,\n            \"alpha\": 50, \"beta\": 50, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"delta_0\": 0.5, \"n_gen\": 3000, \"seed\": 42\n        },\n        # Case 2 (happy path, adder-generated dataset)\n        {\n            \"true_model\": 1, \"g\": 0.02, \"delta_0\": 0.5, \"sigma_eta\": 0.1,\n            \"alpha\": 50, \"beta\": 50, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"S_c\": 1.0, \"n_gen\": 3000, \"seed\": 43\n        },\n        # Case 3 (edge case, timer-generated dataset with asymmetric partitioning)\n        {\n            \"true_model\": 2, \"g\": 0.02, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"alpha\": 5, \"beta\": 5, \"S_c\": 1.0, \"delta_0\": 0.5,\n            \"sigma_eta\": 0.1, \"n_gen\": 3000, \"seed\": 44\n        },\n        # Case 4 (boundary case, adder-generated dataset with low noise)\n        {\n            \"true_model\": 1, \"g\": 0.02, \"delta_0\": 0.7, \"sigma_eta\": 1e-6,\n            \"alpha\": 500, \"beta\": 500, \"T_0_factor\": np.log(2), \"sigma_T\": 3.0,\n            \"S_c\": 1.0, \"n_gen\": 2000, \"seed\": 45\n        }\n    ]\n\n    results = []\n    initial_s_b = 0.8\n\n    for case in test_cases:\n        # Set seed for reproducibility\n        np.random.seed(case[\"seed\"])\n\n        # Unpack parameters\n        true_model = case[\"true_model\"]\n        g = case[\"g\"]\n        n_gen = case[\"n_gen\"]\n        alpha = case[\"alpha\"]\n        beta = case[\"beta\"]\n        sigma_eta = case[\"sigma_eta\"]\n        S_c = case[\"S_c\"]\n        delta_0 = case[\"delta_0\"]\n        # T_0 is specified relative to g\n        T_0 = case[\"T_0_factor\"] / g\n        sigma_T = case[\"sigma_T\"]\n\n        s_b_data = []\n        s_d_data = []\n        \n        current_s_b = initial_s_b\n\n        # Simulation loop for a single lineage\n        for _ in range(n_gen):\n            s_b = current_s_b\n            s_d = 0.0\n\n            # Apply the true model to determine division size s_d\n            if true_model == 0:  # Sizer\n                eta = np.random.normal(0, sigma_eta)\n                s_d = S_c * np.exp(eta)\n            elif true_model == 1:  # Adder\n                eta = np.random.normal(0, sigma_eta)\n                s_d = s_b + delta_0 * np.exp(eta)\n            elif true_model == 2:  # Timer\n                T = np.random.normal(T_0, sigma_T)\n                # Ensure time is non-negative\n                if T  0: T = 0\n                s_d = s_b * np.exp(g * T)\n\n            # Store the data for the current generation\n            s_b_data.append(s_b)\n            s_d_data.append(s_d)\n\n            # Calculate birth size for the next generation via partitioning\n            f = np.random.beta(alpha, beta)\n            current_s_b = f * s_d\n\n        # Convert lists to NumPy arrays for analysis\n        s_b_array = np.array(s_b_data)\n        s_d_array = np.array(s_d_data)\n\n        # Perform linear regression to find the slope\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        m_hat = np.polyfit(s_b_array, s_d_array, 1)[0]\n\n        # Define the theoretical slopes for comparison\n        m_sizer = 0.0\n        m_adder = 1.0\n        m_timer = np.exp(g * T_0)\n        \n        theoretical_slopes = [m_sizer, m_adder, m_timer]\n\n        # Calculate deviations and find the model with the minimum deviation\n        deviations = [np.abs(m_hat - m_model) for m_model in theoretical_slopes]\n        predicted_model_id = np.argmin(deviations)\n        \n        results.append(predicted_model_id)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "确保随机模拟的正确性是计算建模中一个关键且不容忽视的挑战。本实践介绍了一种为随机代码创建确定性单元测试的严谨方法，该方法利用固定的随机种子和源于概率论的、有数学依据的容忍区间。掌握这项技术  对于构建可靠且可复现的基于智能体的模型至关重要。",
            "id": "3905541",
            "problem": "要求您通过固定随机种子和定义有数学依据的容差带，为一个随机的基于代理的模型构建确定性单元测试。考虑一个合成生物学建模中的细胞群体单步基于代理的模型（ABM），其中 $N_0$ 个细胞中的每一个都在同步更新中独立地经历三种结果之一：分裂、凋亡（程序性细胞死亡）或无变化。对于每个细胞 $j$，定义一个随机变量 $Y_j$：分裂的取值为 $+1$，概率为 $p_{\\text{div}}$；死亡的取值为 $-1$，概率为 $p_{\\text{die}}$；无变化的取值为 $0$，概率为 $1 - p_{\\text{div}} - p_{\\text{die}}$。其中 $0 \\le p_{\\text{div}} \\le 1$，$0 \\le p_{\\text{die}} \\le 1$，且 $p_{\\text{div}} + p_{\\text{die}} \\le 1$。单次模拟复本中，一步之后的最终细胞数为\n$$\nN_1 = N_0 + \\sum_{j=1}^{N_0} Y_j.\n$$\n您将使用固定的伪随机种子运行 $R$ 次独立复本，计算样本均值 $\\bar{N}_1$，并通过将 $\\bar{N}_1$ 与围绕解析均值的数学上合理的容差带进行比较，来自动接受或拒绝该次运行。对于给定的种子，接受标准必须是确定性的，并且必须使用第一性原理的概率结果来证明其合理性。\n\n使用的基本原理和事实：\n- 每个细胞结果的独立性，以及在 $N_0$ 次试验中，结果为 $(X_{\\text{div}}, X_{\\text{die}}, X_{\\text{stay}})$ 且概率为 $(p_{\\text{div}}, p_{\\text{die}}, 1-p_{\\text{div}}-p_{\\text{die}})$ 的多项式模型。\n- 独立同分布 (i.i.d.) 变量之和的均值和方差，以及适用于样本均值的中心极限定理 (CLT)。\n- 适用于有界独立变量的 Hoeffding 不等式，用以产生非渐近容差界。\n\n推导 $N_1$ 的解析均值和方差，然后为 $R$ 次复本的样本均值推导一个双边容差带，该容差带结合了：\n1. 来自中心极限定理 (CLT) 的正态近似带，使用标准正态分布的 $(1-\\alpha/2)$ 分位数。\n2. 将 Hoeffding 不等式应用于 $R$ 次复本的平均值得到的非渐近带。\n\n形式上，令 $\\mu = \\mathbb{E}[N_1]$ 和 $\\sigma^2 = \\mathrm{Var}(N_1)$ 为单次复本的均值和方差，令 $\\bar{N}_1$ 为 $R$ 次复本的样本均值。定义基于 CLT 的容差带半宽\n$$\nT_{\\mathrm{CLT}}(\\alpha) = z_{1-\\alpha/2}\\sqrt{\\frac{\\sigma^2}{R}},\n$$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。同时定义基于 Hoeffding 不等式的容差带半宽\n$$\nT_{\\mathrm{H}}(\\alpha) = \\sqrt{\\frac{2 N_0 \\ln(2/\\alpha)}{R}}.\n$$\n使用保守的组合容差\n$$\nT(\\alpha) = \\max\\left(T_{\\mathrm{CLT}}(\\alpha), T_{\\mathrm{H}}(\\alpha)\\right).\n$$\n当且仅当满足以下条件时，接受该次运行\n$$\n|\\bar{N}_1 - \\mu| \\le T(\\alpha).\n$$\n所有概率必须表示为小数或分数，不能使用百分号。计数单位为细胞；不涉及其他物理单位。\n\n实现一个程序，该程序：\n- 对于每个测试用例，验证 $p_{\\text{div}} + p_{\\text{die}} \\le 1$ 和 $p_{\\text{div}}, p_{\\text{die}} \\in [0,1]$。如果无效，则对该用例产生布尔值拒绝。\n- 对每个复本，使用给定的固定随机种子，通过对 $N_0$ 个细胞进行多项式采样，生成 $R$ 次复本。\n- 计算 $\\bar{N}_1$, $\\mu$, $\\sigma^2$, $T_{\\mathrm{CLT}}(\\alpha)$, $T_{\\mathrm{H}}(\\alpha)$, $T(\\alpha)$，并返回表示接受的布尔值。\n\n测试套件（每个用例为 $(N_0, p_{\\text{div}}, p_{\\text{die}}, R, \\alpha, \\text{seed})$）：\n1. $(1000, 0.2, 0.1, 800, 0.01, 314159)$\n2. $(50, 0.49, 0.49, 5000, 0.05, 271828)$\n3. $(5, 0.2, 0.1, 10000, 0.001, 123456)$\n4. $(200, 0.0, 0.0, 200, 10^{-6}, 789)$\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”），其中每个结果是一个布尔值，表示相应测试用例是否被接受。",
            "solution": "所提供的问题经评估有效。它在科学上基于概率论和统计学，提法明确且提供了所有必要信息，其表述是客观的。任务是通过推导和应用统计界限，为随机模型构建确定性测试，这在计算科学中是一种合理且标准的做法。我们现在将进行求解，其过程包括三个主要步骤：推导细胞群体数量的解析矩，证明所提供的统计界限的合理性，以及设计计算实现方案。\n\n### 步骤1：最终细胞群体的解析均值和方差\n\n设 $N_0$ 为初始细胞数。对于每个细胞 $j \\in \\{1, \\dots, N_0\\}$，群体数量的变化由一个随机变量 $Y_j$ 表示。该变量以概率 $p_{\\text{div}}$ 取值 $+1$（分裂），以概率 $p_{\\text{die}}$ 取值 $-1$（死亡），以概率 $p_{\\text{stay}} = 1 - p_{\\text{div}} - p_{\\text{die}}$ 取值 $0$（静止）。变量 $Y_j$ 是独立同分布 (i.i.d.) 的。\n\n首先，我们计算单个变量 $Y_j$ 的均值和方差。\n$Y_j$ 的期望值为：\n$$\n\\mathbb{E}[Y_j] = (+1) \\cdot p_{\\text{div}} + (-1) \\cdot p_{\\text{die}} + (0) \\cdot p_{\\text{stay}} = p_{\\text{div}} - p_{\\text{die}}\n$$\n为了求方差，我们首先计算二阶矩 $\\mathbb{E}[Y_j^2]$：\n$$\n\\mathbb{E}[Y_j^2] = (+1)^2 \\cdot p_{\\text{div}} + (-1)^2 \\cdot p_{\\text{die}} + (0)^2 \\cdot p_{\\text{stay}} = p_{\\text{div}} + p_{\\text{die}}\n$$\n$Y_j$ 的方差则由 $\\mathrm{Var}(Y_j) = \\mathbb{E}[Y_j^2] - (\\mathbb{E}[Y_j])^2$ 给出：\n$$\n\\mathrm{Var}(Y_j) = (p_{\\text{div}} + p_{\\text{die}}) - (p_{\\text{div}} - p_{\\text{die}})^2\n$$\n一步之后的最终细胞数 $N_1$ 定义为 $N_1 = N_0 + \\sum_{j=1}^{N_0} Y_j$。\n\n$N_1$ 的解析均值，记为 $\\mu$，使用期望的线性性质推导得出：\n$$\n\\mu = \\mathbb{E}[N_1] = \\mathbb{E}\\left[N_0 + \\sum_{j=1}^{N_0} Y_j\\right] = N_0 + \\sum_{j=1}^{N_0} \\mathbb{E}[Y_j]\n$$\n由于 $Y_j$ 是同分布的，因此对于所有 $j$，$\\mathbb{E}[Y_j]$ 都是相同的：\n$$\n\\mu = N_0 + N_0 \\cdot \\mathbb{E}[Y_j] = N_0 + N_0(p_{\\text{div}} - p_{\\text{die}}) = N_0(1 + p_{\\text{div}} - p_{\\text{die}})\n$$\n$N_1$ 的解析方差，记为 $\\sigma^2$，是利用独立随机变量和的方差性质推导得出的。常数 $N_0$ 对该方差没有贡献。\n$$\n\\sigma^2 = \\mathrm{Var}(N_1) = \\mathrm{Var}\\left(N_0 + \\sum_{j=1}^{N_0} Y_j\\right) = \\mathrm{Var}\\left(\\sum_{j=1}^{N_0} Y_j\\right)\n$$\n由于 $Y_j$ 是独立的：\n$$\n\\sigma^2 = \\sum_{j=1}^{N_0} \\mathrm{Var}(Y_j) = N_0 \\cdot \\mathrm{Var}(Y_j) = N_0 \\left[ (p_{\\text{div}} + p_{\\text{die}}) - (p_{\\text{div}} - p_{\\text{die}})^2 \\right]\n$$\n这些关于 $\\mu$ 和 $\\sigma^2$ 的表达式是单次模拟复本的精确解析矩。\n\n### 步骤2：容差带的推导与合理性证明\n\n该测试将 $R$ 次复本的样本均值 $\\bar{N}_1$ 与解析均值 $\\mu$ 进行比较。容差带由两个来源构建。\n\n中心极限定理 (CLT) 指出，对于大的 $R$，样本均值 $\\bar{N}_1$ 的分布近似为均值为 $\\mu$、方差为 $\\sigma^2/R$ 的正态分布。因此，构建置信区间是合理的。对于显著性水平 $\\alpha$，该区间的半宽为：\n$$\nT_{\\mathrm{CLT}}(\\alpha) = z_{1-\\alpha/2}\\sqrt{\\frac{\\sigma^2}{R}}\n$$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。这是一个标准的渐近结果。\n\n第二个界限是非渐近的，源自 Hoeffding 不等式。所提供的公式 $T_{\\mathrm{H}}(\\alpha) = \\sqrt{\\frac{2 N_0 \\ln(2/\\alpha)}{R}}$ 需要审慎的证明。我们不将 Hoeffding 不等式应用于 $R$ 个复本结果 $N_{1,i}$，而是应用于总共 $N_0 \\times R$ 个单个细胞层面的结果。\n\n设 $Y_{i,j}$ 为复本 $i$ 中细胞 $j$ 的结果。这些是 $N_0 \\times R$ 个独立同分布的随机变量，每个变量都在区间 $[-1, 1]$ 上有界。其范围为 $b-a = 1 - (-1) = 2$。\n设 $\\bar{Y} = \\frac{1}{N_0 R} \\sum_{i=1}^R \\sum_{j=1}^{N_0} Y_{i,j}$ 为所有复本中所有细胞的总平均结果。将 Hoeffding 不等式应用于这 $M = N_0 R$ 个变量的平均值：\n$$\nP(|\\bar{Y} - \\mathbb{E}[\\bar{Y}]| \\ge \\epsilon') \\le 2 \\exp\\left(-\\frac{2M(\\epsilon')^2}{(b-a)^2}\\right) = 2 \\exp\\left(-\\frac{2(N_0 R)(\\epsilon')^2}{2^2}\\right) = 2 \\exp\\left(-\\frac{N_0 R (\\epsilon')^2}{2}\\right)\n$$\n将此概率设为 $\\alpha$ 并求解偏差 $\\epsilon'$：\n$$\n\\alpha = 2 \\exp\\left(-\\frac{N_0 R (\\epsilon')^2}{2}\\right) \\implies \\ln(\\alpha/2) = -\\frac{N_0 R (\\epsilon')^2}{2} \\implies (\\epsilon')^2 = \\frac{2\\ln(2/\\alpha)}{N_0 R}\n$$\n我们感兴趣的偏差是 $|\\bar{N}_1 - \\mu|$。我们可以用 $\\bar{Y}$ 来表示它：\n$$\n\\bar{N}_1 = \\frac{1}{R}\\sum_{i=1}^R N_{1,i} = \\frac{1}{R}\\sum_{i=1}^R \\left(N_0 + \\sum_{j=1}^{N_0} Y_{i,j}\\right) = N_0 + \\frac{1}{R}\\sum_{i=1}^R\\sum_{j=1}^{N_0} Y_{i,j} = N_0 + N_0 \\bar{Y}\n$$\n类似地，$\\mu = N_0 + N_0 \\mathbb{E}[\\bar{Y}]$。因此：\n$$\n|\\bar{N}_1 - \\mu| = |(N_0 + N_0 \\bar{Y}) - (N_0 + N_0 \\mathbb{E}[\\bar{Y}])| = N_0|\\bar{Y} - \\mathbb{E}[\\bar{Y}]|\n$$\n这个量的界，我们称之为 $T_{\\mathrm{H}}(\\alpha)$，是 $N_0 \\epsilon'$：\n$$\nT_{\\mathrm{H}}(\\alpha) = N_0 \\epsilon' = N_0 \\sqrt{\\frac{2\\ln(2/\\alpha)}{N_0 R}} = \\sqrt{N_0^2 \\frac{2\\ln(2/\\alpha)}{N_0 R}} = \\sqrt{\\frac{2 N_0 \\ln(2/\\alpha)}{R}}\n$$\n这个推导证实了问题陈述中提供的公式的正确性。最终的容差 $T(\\alpha) = \\max(T_{\\mathrm{CLT}}(\\alpha), T_{\\mathrm{H}}(\\alpha))$ 是一个保守的选择，确保了该界限对于大样本和小样本都具有鲁棒性。\n\n### 步骤3：算法策略\n\n对于每个测试用例 $(N_0, p_{\\text{div}}, p_{\\text{die}}, R, \\alpha, \\text{seed})$，实现将按以下步骤进行：\n1.  **参数验证**：检查约束条件 $0 \\le p_{\\text{div}} \\le 1$，$0 \\le p_{\\text{die}} \\le 1$，以及 $p_{\\text{div}} + p_{\\text{die}} \\le 1$。如果违反，则拒绝该用例。\n2.  **解析计算**：使用推导出的公式计算 $\\mu$ 和 $\\sigma^2$。\n3.  **随机模拟**：\n    a. 使用给定的 `seed` 初始化一个伪随机数生成器。\n    b. 对于 $R$ 次复本中的每一次，模拟 $N_0$ 个细胞的结果。通过从参数为 $n=N_0$ 和概率为 $[p_{\\text{div}}, p_{\\text{die}}, 1-p_{\\text{div}}-p_{\\text{die}}]$ 的多项式分布中抽取一个大小为 $R$ 的样本，可以高效地完成此操作。\n    c. 对于每个复本的结果 `[n_div, n_die, n_stay]`，计算最终细胞数 $N_1 = N_0 + n_{\\text{div}} - n_{\\text{die}}$。\n    d. 计算 $R$ 个 $N_1$ 值的样本均值 $\\bar{N}_1$。\n4.  **容差计算**：\n    a. 使用 `scipy.stats.norm.ppf` 找到正态分位数 $z_{1-\\alpha/2}$。\n    b. 计算 $T_{\\mathrm{CLT}}(\\alpha)$ 和 $T_{\\mathrm{H}}(\\alpha)$。\n    c. 设置 $T(\\alpha) = \\max(T_{\\mathrm{CLT}}(\\alpha), T_{\\mathrm{H}}(\\alpha))$。\n5.  **接受决策**：评估布尔表达式 $|\\bar{N}_1 - \\mu| \\le T(\\alpha)$。这是该测试用例的结果。\n\n最终输出将是这些布尔结果的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nimport math\n\ndef solve():\n    \"\"\"\n    Executes a series of deterministic unit tests for a stochastic agent-based model\n    of cell population dynamics. For each test case, it simulates the model with a fixed\n    random seed and checks if the sample mean falls within a mathematically justified\n    tolerance band around the analytical mean.\n    \"\"\"\n    test_cases = [\n        (1000, 0.2, 0.1, 800, 0.01, 314159),\n        (50, 0.49, 0.49, 5000, 0.05, 271828),\n        (5, 0.2, 0.1, 10000, 0.001, 123456),\n        (200, 0.0, 0.0, 200, 1e-6, 789),\n    ]\n\n    results = []\n    for case in test_cases:\n        N0, p_div, p_die, R, alpha, seed = case\n\n        # Step 1: Validate input parameters.\n        if not (0 = p_div = 1 and 0 = p_die = 1 and p_div + p_die = 1):\n            results.append(False)\n            continue\n\n        p_stay = 1.0 - p_div - p_die\n\n        # Step 2: Calculate analytical mean (mu) and variance (sigma^2) for one replicate.\n        mu = N0 * (1.0 + p_div - p_die)\n        \n        # Variance of a single cell's outcome Y_j\n        # Var(Y_j) = E[Y_j^2] - (E[Y_j])^2\n        # E[Y_j] = p_div - p_die\n        # E[Y_j^2] = p_div + p_die\n        var_Yj = (p_div + p_die) - (p_div - p_die)**2\n        # Variance of N_1 = N_0 + sum(Y_j) is Var(sum(Y_j)) = N_0 * Var(Y_j)\n        sigma2 = N0 * var_Yj\n\n        # Step 3: Run R replicates of the simulation with a fixed seed.\n        rng = np.random.default_rng(seed)\n        \n        # Generate the number of divisions, deaths, and stays for all R replicates at once.\n        # The result 'counts' is an (R, 3) array.\n        counts = rng.multinomial(N0, [p_div, p_die, p_stay], size=R)\n        \n        # Calculate the final population N1 for each of the R replicates.\n        # N1 = N0 + (number of divisions) - (number of deaths)\n        N1_replicates = N0 + counts[:, 0] - counts[:, 1]\n        \n        # Compute the sample mean over R replicates.\n        N1_bar = np.mean(N1_replicates)\n\n        # Step 4: Calculate the tolerance band T(alpha).\n        # CLT-based tolerance band half-width\n        z_quantile = norm.ppf(1.0 - alpha / 2.0)\n        # Handle case where R is 0 or sigma2 is negative, though not expected here.\n        if R > 0 and sigma2 >= 0:\n            T_clt = z_quantile * math.sqrt(sigma2 / R)\n        else:\n            T_clt = float('inf')\n\n        # Hoeffding-based tolerance band half-width\n        if R > 0 and alpha > 0:\n            T_h = math.sqrt((2.0 * N0 * math.log(2.0 / alpha)) / R)\n        else:\n            T_h = float('inf')\n        \n        # Use the more conservative (larger) of the two bands.\n        T_alpha = max(T_clt, T_h)\n\n        # Step 5: Perform the acceptance test.\n        is_accepted = abs(N1_bar - mu) = T_alpha\n        results.append(is_accepted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.lower() if isinstance(r, bool) else str(r) for r in results]))}]\")\n\nsolve()\n```"
        }
    ]
}