{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的混合模型之前，掌握其随机引擎——随机模拟算法 (Stochastic Simulation Algorithm, SSA)——至关重要。本练习将通过分析一个简单的可逆反应系统，巩固您对 SSA 在每一步所回答的两个基本问题的理解：“下一个反应是哪一个？”以及“它何时发生？”。",
            "id": "3915219",
            "problem": "考虑一个充分混合的合成基因线路模块，该模块被建模为一个双物种转化系统，包含反应 $A \\to B$ 和 $B \\to A$。在一个混合随机-确定性模拟方案中，假设这两个转化反应被指定为随机子集的一部分，并使用随机模拟算法（SSA）进行推进。假设系统体积恒定且足够小，以至于波动不可忽略，并且这两个单分子反应的动力学在化学主方程框架下满足质量作用假设。设反应 $A \\to B$ 的随机速率常数为 $k>0$，反应 $B \\to A$ 的随机速率常数为 $h>0$（单位为分钟的倒数）。在当前离散分子数状态 $(A,B)=(50,10)$ 时，从概念上执行一个SSA步骤，并确定：\n- 下一个反应事件是 $A \\to B$ 的概率，以及\n- 到下一个反应事件的期望等待时间。\n仅使用与化学主方程和充分混合随机动力学中反应事件时间的无记忆性相一致的第一性原理来推导您的表达式。用 $k$ 和 $h$ 的符号形式表示您的最终答案。对于期望等待时间，请以分钟为单位表示该量。在最终的方框答案中不要包含单位。不需要数值取整。",
            "solution": "该问题是有效的，因为它科学地基于随机化学动力学的既定原理，问题设定良好，有唯一可推导的解，并以客观、正式的语言表述。我们可以开始求解。\n\n该问题要求计算与给定化学系统的随机模拟算法（SSA）（也称为 Gillespie 算法）单个步骤相关的两个量。该算法的基础是化学主方程（CME），它描述了系统处于特定状态的概率随时间的演化。SSA提供了一种生成系统状态随时间变化的统计精确轨迹的方法。在SSA的每一步中，都会回答两个关键问题：(1) 下一个反应何时发生？(2) 将是哪个反应？\n\n该系统包含两个物种，$A$ 和 $B$，以及两个单分子反应：\n1. $R_1: A \\to B$，随机速率常数为 $k > 0$。\n2. $R_2: B \\to A$，随机速率常数为 $h > 0$。\n\n系统在任意时刻 $t$ 的状态由各物种的离散分子数定义，由向量 $\\mathbf{X}(t) = (A(t), B(t))$ 给出。我们已知当前状态为 $\\mathbf{x} = (A, B) = (50, 10)$。\n\nSSA的核心是倾向函数 $a_\\mu(\\mathbf{x})$，它是反应 $\\mu$ 的随机速率常数 $c_\\mu$ 与不同反应物组合数 $h_\\mu(\\mathbf{x})$ 的乘积。对于一个充分混合的系统，给定在时间 $t$ 状态为 $\\mathbf{x}$，则 $a_\\mu(\\mathbf{x}) d t$ 是反应 $\\mu$ 在无穷小时间区间 $[t, t+dt)$ 内发生的概率。\n\n对于给定的单分子反应，倾向函数根据质量作用动力学推导如下：\n- 对于 $R_1: A \\to B$，倾向函数 $a_1$ 与反应物 $A$ 的分子数成正比。\n$$a_1(A) = k A$$\n- 对于 $R_2: B \\to A$，倾向函数 $a_2$ 与反应物 $B$ 的分子数成正比。\n$$a_2(B) = h B$$\n\n在当前状态 $(A, B) = (50, 10)$下，我们可以计算出具体的倾向值：\n- $a_1 = k \\cdot 50 = 50k$\n- $a_2 = h \\cdot 10 = 10h$\n\n总倾向 $a_0$ 是所有单个反应倾向的总和。它代表任何反应事件发生的总速率。\n$$a_0 = \\sum_{\\mu=1}^{2} a_\\mu = a_1 + a_2 = 50k + 10h$$\n\n有了这些量，我们就可以解决问题的两个部分了。\n\n首先，我们确定下一个反应事件是 $A \\to B$ 的概率。根据SSA的公式，下一个反应是 $R_\\mu$ 的概率是其单个倾向 $a_\\mu$ 与总倾向 $a_0$ 的比值。这是因为这些反应被视为相互竞争的泊松过程。\n因此，下一个反应是 $R_1$ ($A \\to B$) 的概率为：\n$$P(R_1 \\text{ is next}) = \\frac{a_1}{a_0} = \\frac{50k}{50k + 10h}$$\n这个表达式可以通过从分子和分母中提出因子 $10$ 来简化：\n$$P(R_1 \\text{ is next}) = \\frac{10(5k)}{10(5k + h)} = \\frac{5k}{5k + h}$$\n\n其次，我们确定到下一个反应事件的期望等待时间。从SSA推导出的CME框架的一个基本性质是，下一个反应发生的等待时间 $\\tau$ 是一个随机变量，服从指数分布，其速率参数等于总倾向 $a_0$。等待时间的概率密度函数是 $p(\\tau) = a_0 \\exp(-a_0 \\tau)$。这是底层基元反应的无记忆性的直接结果。\n\n速率参数为 $\\lambda$ 的指数分布的期望值 $E[\\tau]$ 是 $1/\\lambda$。在我们的例子中，速率参数是 $a_0$。因此，到下一个反应事件的期望等待时间是：\n$$E[\\tau] = \\frac{1}{a_0} = \\frac{1}{50k + 10h}$$\n问题指出，速率常数 $k$ 和 $h$ 的单位是分钟的倒数 ($\\text{min}^{-1}$)。因此，倾向 $a_1$、$a_2$ 和 $a_0$ 的单位是 $\\text{min}^{-1}$。所以期望等待时间 $E[\\tau] = 1/a_0$ 的单位将是分钟，符合题目要求。该表达式也可以写成因式分解形式 $\\frac{1}{10(5k+h)}$。为保持一致性，我们在分母中使用未分解的形式。\n\n所要求的两个量是：下一个反应为 $A \\to B$ 的概率，即 $\\frac{5k}{5k+h}$；以及下一个反应的期望等待时间，即 $\\frac{1}{50k+10h}$ 分钟。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{5k}{5k+h} & \\frac{1}{50k+10h} \\end{pmatrix}}$$"
        },
        {
            "introduction": "许多生物系统都包含守恒量，例如特定元素的原子总数。在混合模拟中，识别并利用这些守恒定律是一种强大的策略，它既可以降低模型确定性部分的复杂性，又能提高数值稳定性，我们将在关于蛋白质二聚化的这个练习中对此进行探讨。",
            "id": "3915235",
            "problem": "在一个体积为 $V$ 的充分混合隔室中，一个最小的同源二聚化模块由可逆反应 $2A \\xrightarrow{k_f} A_2$ 和 $A_2 \\xrightarrow{k_r} 2A$ 给出，其中 $k_f$ 是一个双分子正向反应速率常数，$k_r$ 是一个单分子逆向反应速率常数。考虑以浓度 $x_A(t)$ 和 $x_{A_2}(t)$ 表示的确定性描述，以及以分子数 $n_A(t)$ 和 $n_{A_2}(t)$ 表示的随机性描述。\n\n仅使用质量作用定律、化学计量矩阵的定义以及化学主方程（CME）的倾向函数标准形式，完成以下任务：\n\n1.  在充分混合系统中的确定性质​​量作用假设下，推导 $x_A(t)$ 和 $x_{A_2}(t)$ 的常微分方程（ODEs）。\n\n2.  使用化学计量论证，找出一个确定性系统的守恒量，该守恒量对应于单体单元的总数，并通过沿常微分方程的轨迹对其进行微分来证明它是守恒的。\n\n3.  对于随机性描述，写出这两个反应相应的倾向函数，以分子数 $n_A(t)$、$n_{A_2}(t)$ 和体积 $V$ 表示，并阐明宏观速率常数 $k_f$、$k_r$ 与微观倾向常数之间的关系。\n\n4.  在一种将快反应作确定性处理、慢反应作随机性处理的混合随机-确定性模拟方法的背景下，解释如何利用第2部分中的守恒量来降低确定性子系统的维度，并在与一个在较慢时间尺度上扰动 $A$ 或 $A_2$ 的随机模块耦合时，维持数值稳定性和非负性。你的解释应简洁并基于第一性原理，不援引任何特定问题的捷径。\n\n假设任意非负初始条件 $x_A(0)=x_{A,0}$ 和 $x_{A_2}(0)=x_{A_2,0}$。作为最终答案，报告在第2部分中找出的、用 $x_A$ 和 $x_{A_2}$ 表示的总单体守恒浓度的最简符号表达式。最终答案应该是一个没有单位的单一闭式表达式。如果你选择用分子数来表示守恒量，请用 $n_A$ 和 $n_{A_2}$ 书写。只有守恒量的表达式会被作为最终答案评分。",
            "solution": "首先根据所需标准验证问题陈述。\n\n### 步骤1：提取已知条件\n-   **反应**：$2A \\xrightarrow{k_f} A_2$（正向）和 $A_2 \\xrightarrow{k_r} 2A$（逆向）。\n-   **系统**：一个在体积为 $V$ 的充分混合隔室中的最小同源二聚化模块。\n-   **速率常数**：$k_f$ 是双分子正向反应速率常数；$k_r$ 是单分子逆向反应速率常数。\n-   **变量（确定性）**：浓度 $x_A(t)$ 和 $x_{A_2}(t)$。\n-   **变量（随机性）**：分子数 $n_A(t)$ 和 $n_{A_2}(t)$。\n-   **初始条件**：$x_A(0) = x_{A,0} \\geq 0$ 和 $x_{A_2}(0) = x_{A_2,0} \\geq 0$。\n-   **方法论**：质量作用定律、化学计量矩阵的定义以及化学主方程（CME）的倾向函数标准形式。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学基础**：该问题基于化学动力学的基本原理，特别是可逆二聚反应的质量作用定律。这是化学、生物化学和合成生物学中的一个典型模型。确定性ODE、随机倾向函数（CME）和混合模拟等概念在计算系统生物学领域都是标准且完善的。该模型在科学上是合理的。\n-   **良态问题**：问题定义清晰，并提供了执行所要求的推导和解释所需的所有必要信息（反应、速率常数、变量）。问题的每个部分都能从前提中推导出唯一且有意义的答案。\n-   **客观性**：问题以精确、客观和标准的科学语言陈述，没有歧义或主观论断。\n\n### 步骤3：结论与行动\n该问题在科学上合理、良态、客观且完整。它没有违反任何无效标准。因此，该问题被判定为**有效**。下面提供了完整的解答。\n\n***\n\n### 1. 常微分方程（ODEs）的推导\n\n确定性速率方程由质量作用定律推导得出。物种的浓度用 $x_S$ 表示。\n正向反应为 $2A \\xrightarrow{k_f} A_2$。这是一个二级反应，其速率为 $v_f = k_f x_A^2$。\n逆向反应为 $A_2 \\xrightarrow{k_r} 2A$。这是一个一级反应，其速率为 $v_r = k_r x_{A_2}$。\n\n每个物种浓度的变化率是其参与的反应速率的总和，并按其化学计量系数加权（反应物为负，产物为正）。\n\n对于物种 $A$，它在正向反应中被消耗（化学计量系数为-2），在逆向反应中被生成（化学计量系数为+2）。因此，其变化率为：\n$$ \\frac{dx_A}{dt} = (-2) v_f + (+2) v_r = -2 k_f x_A^2 + 2 k_r x_{A_2} $$\n\n对于物种 $A_2$，它在正向反应中被生成（化学计量系数为+1），在逆向反应中被消耗（化学计量系数为-1）。因此，其变化率为：\n$$ \\frac{dx_{A_2}}{dt} = (+1) v_f + (-1) v_r = k_f x_A^2 - k_r x_{A_2} $$\n\n这两个耦合的ODE描述了在确定性极限下浓度的随时间演化。\n\n### 2. 守恒量的确定与证明\n\n守恒量对应于物种浓度的某个线性组合，该组合随时间保持不变。这可以从系统的化学计量关系中找到。设状态向量为 $\\mathbf{x} = \\begin{pmatrix} x_A \\\\ x_{A_2} \\end{pmatrix}$。ODE系统可以写成 $\\frac{d\\mathbf{x}}{dt} = S \\mathbf{v}$，其中 $S$ 是化学计量矩阵，$\\mathbf{v}$ 是反应速率向量。\n\n化学计量矩阵 $S$ 的行对应物种（$A$, $A_2$），列对应反应（正向，逆向）。\n-   正向反应（$2A \\rightarrow A_2$）：变化量为 $\\Delta A = -2$, $\\Delta A_2 = +1$。\n-   逆向反应（$A_2 \\rightarrow 2A$）：变化量为 $\\Delta A = +2$, $\\Delta A_2 = -1$。\n所以，化学计量矩阵是：\n$$ S = \\begin{pmatrix} -2 & 2 \\\\ 1 & -1 \\end{pmatrix} $$\n如果存在一个非零向量 $\\mathbf{c}$ 使得 $\\mathbf{c}^T S = \\mathbf{0}^T$，则存在守恒量。设 $\\mathbf{c} = \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix}$。\n$$ \\mathbf{c}^T S = \\begin{pmatrix} c_1 & c_2 \\end{pmatrix} \\begin{pmatrix} -2 & 2 \\\\ 1 & -1 \\end{pmatrix} = \\begin{pmatrix} -2c_1 + c_2 & 2c_1 - c_2 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 \\end{pmatrix} $$\n这得到单一方程 $-2c_1 + c_2 = 0$，即 $c_2 = 2c_1$。我们可以选择最简单的整数解，$c_1=1$，得到 $c_2=2$。\n因此，守恒量 $C$ 是线性组合 $\\mathbf{c}^T \\mathbf{x}$：\n$$ C = c_1 x_A + c_2 x_{A_2} = x_A + 2x_{A_2} $$\n这个量代表了单体单元的总浓度，无论它们是以自由单体（$A$）形式存在，还是被整合到二聚体（$A_2$）中。\n\n为了证明它是守恒的，我们对 $C(t)$ 关于时间求导，并使用第1部分推导的ODE：\n$$ \\frac{dC}{dt} = \\frac{d}{dt} (x_A + 2x_{A_2}) = \\frac{dx_A}{dt} + 2 \\frac{dx_{A_2}}{dt} $$\n代入导数的表达式：\n$$ \\frac{dC}{dt} = (-2 k_f x_A^2 + 2 k_r x_{A_2}) + 2 (k_f x_A^2 - k_r x_{A_2}) $$\n$$ \\frac{dC}{dt} = -2 k_f x_A^2 + 2 k_r x_{A_2} + 2 k_f x_A^2 - 2 k_r x_{A_2} = 0 $$\n由于 $C$ 的时间导数为零，所以 $C(t)$ 在所有时间上都是常数。其值由初始条件决定：$C = x_A(0) + 2x_{A_2}(0) = x_{A,0} + 2x_{A_2,0}$。\n\n### 3. 随机倾向函数\n\n在随机性描述中，状态由分子数 $n_A$ 和 $n_{A_2}$ 给出。反应 $j$ 的倾向函数 $a_j$ 给出在当前状态下，单位时间内该反应发生的概率。标准形式将宏观速率常数（$k_f, k_r$）与微观倾向联系起来。这种关系取决于反应级数。\n\n对于逆向反应（$A_2 \\xrightarrow{k_r} 2A$），这是一个单分子反应：\n倾向与 $A_2$ 分子的数量成正比。微观倾向常数就是宏观速率常数，$c_r = k_r$。\n$$ a_r(n_{A_2}) = k_r n_{A_2} $$\n\n对于正向反应（$2A \\xrightarrow{k_f} A_2$），这是一个双分子自身反应（同源二聚化）：\n不同 $A$ 分子对的数量由组合公式 $\\binom{n_A}{2} = \\frac{n_A(n_A-1)}{2}$ 给出。倾向与这个数量成正比。微观倾向常数 $c_f$ 与宏观速率常数 $k_f$ 相关。为了找到这个关系，我们在大数极限下（$n_A \\gg 1, n_A(n_A-1) \\approx n_A^2$ 且 $x_A \\approx n_A/V$），将单位体积的平均随机速率与确定性速率等同起来。\n单位体积的确定性速率是 $v_f = k_f x_A^2$。\n反应事件的平均随机速率是 $a_f = c_f \\frac{n_A(n_A-1)}{2}$。单位体积的平均速率是 $a_f/V$。\n将它们等同：$k_f x_A^2 \\approx \\frac{1}{V} \\left( c_f \\frac{n_A^2}{2} \\right)$。\n$k_f \\left(\\frac{n_A}{V}\\right)^2 \\approx \\frac{c_f n_A^2}{2V}$。\n这意味着 $k_f/V^2 \\approx c_f/(2V)$，从而得出 $c_f \\approx 2k_f/V$。这是标准的转换关系。\n因此，正向反应的倾向函数是：\n$$ a_f(n_A) = \\frac{2k_f}{V} \\frac{n_A(n_A-1)}{2} = \\frac{k_f}{V} n_A(n_A-1) $$\n\n### 4. 守恒量在混合模拟中的应用\n\n在混合随机-确定性模拟中，快反应使用确定性ODE建模，慢反应使用随机方法（例如，Gillespie的SSA算法）建模。在这里，快子系统是二聚化-解离平衡。守恒量 $C = x_A + 2x_{A_2}$ 在两个主要方面非常有用：降维和确保数值稳定性。\n\n**降维：**\n确定性子系统由两个关于 $x_A$ 和 $x_{A_2}$ 的耦合ODE组成。守恒量 $C_{tot} = x_A + 2x_{A_2}$ 的存在意味着系统的状态被约束在 $(x_A, x_{A_2})$ 相空间中的一条直线上。我们可以利用这个约束来消去一个变量。例如，我们可以用 $x_{A_2}$ 表示 $x_A$：$x_A = C_{tot} - 2x_{A_2}$。将此代入 $x_{A_2}$ 的ODE，得到一个单一的、独立的ODE：\n$$ \\frac{dx_{A_2}}{dt} = k_f (C_{tot} - 2x_{A_2})^2 - k_r x_{A_2} $$\n通过对这个关于 $x_{A_2}$ 的单一ODE进行积分，可以模拟快的确定性动力学，然后可以通过代数方法恢复 $x_A$。这将确定性系统的维度从二降到一，简化了数值积分并降低了计算成本。\n\n**数值稳定性和非负性：**\n当模拟的慢速、随机部分执行一个反应时（例如，$A$ 的合成或降解），单体单元的总数 $N_{tot} = n_A + 2n_{A_2}$ 会发生变化。这为快速确定性子系统定义了一个新的守恒量值 $C_{tot} = N_{tot}/V$。然后，快部分的ODE积分在这个新的总值约束下进行。\n\n使用代数约束 $x_A = C_{tot} - 2x_{A_2}$ 对于稳定性至关重要。\n1.  **强制物理边界：** 浓度必须是非负的，所以 $x_A \\ge 0$ 和 $x_{A_2} \\ge 0$。约束 $x_A = C_{tot} - 2x_{A_2} \\ge 0$ 意味着 $x_{A_2}$ 有一个上界，即 $x_{A_2} \\le C_{tot}/2$。这意味着单一变量 $x_{A_2}$ 被限制在物理上现实的区间 $[0, C_{tot}/2]$ 内。数值积分器可以显式地强制执行这些边界，防止解产生非物理的负浓度，而这种情况可能因数值误差而发生。\n2.  **防止漂移：** 如果将 $x_A$ 和 $x_{A_2}$ 的两个ODE作为一个耦合系统进行数值积分，微小的数值误差会随时间累积，导致解偏离由 $x_A + 2x_{A_2} = C_{tot}$ 定义的流形。通过将系统重构为一个单一ODE和一个代数约束，守恒定律在每一步都通过构造被精确满足。这消除了一个主要的数值误差源，并确保了模拟的长期稳定性和物理一致性。",
            "answer": "$$\n\\boxed{x_A + 2x_{A_2}}\n$$"
        },
        {
            "introduction": "使用混合方法的一个主要原因是处理“刚性”(stiff) 系统，即系统中某些反应的速率远快于其他反应。传统的显式数值方法在处理此类问题时需要极小的时间步长来维持稳定性，效率低下。本练习将介绍一种强大的分裂隐式技术，它通过隐式处理快速的线性反应，从而允许在不牺牲稳定性的前提下采用更大的时间步长，显著提高模拟效率。",
            "id": "3915266",
            "problem": "要求您实现并分析一种混合随机-确定性模拟方法，该方法用于一个单物种合成生物学模型，此模型包含快速线性降解和慢速离散生产事件。该模型应以常微分方程（ODE）动力学描述其连续部分，以随机模拟算法（SSA）描述其离散事件，并可选择使用化学朗之万方程（CLE）对扩散进行建模。所有量都必须以通用的、单位一致的方式指定，并计算结果。\n\n考虑一个单一分子物种，其拷贝数由状态变量 $x(t)$ 表示，单位为分子数，它在两个过程下演化：\n- 快速线性降解，速率常数为 $k$（单位为 $\\mathrm{s}^{-1}$），确定性地建模为漂移项，并可选择通过CLE扩散项进行随机性建模。\n- 慢速离散出生事件（例如，转录爆发），具有恒定的风险率 $\\lambda$（单位为 $\\mathrm{s}^{-1}$），通过随机模拟算法显式模拟跳跃来进行建模。\n\n您必须在固定时间步长 $\\Delta t$（单位为秒）上实现一个一阶分裂隐式格式，该格式在ODE或CLE部分中隐式处理快速线性降解，同时将SSA事件显式处理为跳跃。具体来说，对于从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个步长，带有一个可选的恒定确定性源 $p$（单位为分子/秒），混合更新定义为\n$$\nx_{n+1} \\;=\\; \\frac{x_n \\;+\\; p\\,\\Delta t \\;+\\; J_n \\;+\\; \\xi_n}{\\,1 + k\\,\\Delta t\\,},\n$$\n其中：\n- $x_n$ 是在 $t_n$ 时的状态。\n- $J_n$ 是在区间 $(t_n, t_{n+1}]$ 内发生的SSA出生事件的整数数量，由具有恒定风险率 $\\lambda$ 的显式SSA模拟生成。\n- $\\xi_n$ 是快速降解的CLE噪声贡献，对于纯ODE情况设为 $0$，对于CLE情况则为一个高斯增量，近似为\n$$\n\\xi_n \\;=\\; \\sqrt{k\\,x_n\\,\\Delta t}\\;\\eta_n,\n$$\n其中 $\\eta_n \\sim \\mathcal{N}(0,1)$ 是独立的标准正态变量。这种处理方式将降解的漂移项隐式处理，而其扩散项则在 $x_n$ 处显式处理。\n\n您的程序必须实现：\n1. 对于线性测试ODE $dx/dt = -k\\,x$，其隐式线性降解的放大因子，在后向欧拉法下为\n$$\nG(k,\\Delta t) \\;=\\; \\frac{1}{1 + k\\,\\Delta t}.\n$$\n2. 确定性分裂隐式格式的线性稳定性测试，当且仅当 $\\lvert G(k,\\Delta t)\\rvert \\le 1$ 时定义为稳定。\n3. 对于CLE变体 $dx = -k\\,x\\,dt + \\sigma(x)\\,dW_t$（其中 $\\sigma(x) = \\sqrt{k\\,x}$）的均方稳定性测试，在分裂隐式时间离散化下，通过要求放大因子的平方满足以下条件来近似\n$$\n\\left(G(k,\\Delta t)\\right)^2  \\le 1,\n$$\n其中临界情况 $\\left(G(k,\\Delta t)\\right)^2 = 1$ 被视为稳定。\n4. 在长度为 $\\Delta t$ 的固定窗口内的一个显式SSA事件计数器，使用直接法：以参数 $\\lambda$ 抽取连续的指数等待时间，并对事件进行计数，直到总和超过 $\\Delta t$。\n5. 在纯ODE设置（$\\xi_n = 0$）下，对混合格式进行保正性测试，验证在给定参数下，如果 $x_n \\ge 0$，则根据分裂隐式更新有 $x_{n+1} \\ge 0$。\n\n从以下基本依据出发：\n- 线性降解下的化学动力学遵循质量作用定律，对于拷贝数 $x$ 的确定性漂移，得到 $dx/dt = -k\\,x$。\n- 随机模拟算法为恒定风险率 $\\lambda$ 实现精确的跳跃计时，通过抽取均值为 $1/\\lambda$ 的指数等待时间。\n- 对于 $dx/dt = f(x)$ 且 $f(x) = -k\\,x$ 的后向欧拉法，得到隐式更新 $x_{n+1} = x_n - k\\,\\Delta t\\,x_{n+1}$，即 $x_{n+1} = x_n/(1+k\\,\\Delta t)$，这定义了放大因子 $G(k,\\Delta t)$。\n- 对于化学朗之万方程，在时间步长 $\\Delta t$ 内，一个倾向函数为 $a(x)$ 的反应的扩散项大小近似为 $\\sqrt{a(x)\\,\\Delta t}$。\n\n您的程序必须为以下测试套件输出结果。所有与时间相关的量都必须以秒为单位处理，分子计数是无量纲的整数或实数。最终输出必须通过固定所使用的任何随机数种子来确定性地计算。\n\n测试套件参数：\n- 测试 1：对于 $k = 10\\,\\mathrm{s}^{-1}$，$\\Delta t = 0.1\\,\\mathrm{s}$，计算并返回放大因子 $G(k,\\Delta t)$ 作为浮点数。\n- 测试 2：对于 $k = 0\\,\\mathrm{s}^{-1}$，$\\Delta t = 3.0\\,\\mathrm{s}$，返回一个布尔值，指示确定性稳定性。\n- 测试 3：对于 $k = -0.5\\,\\mathrm{s}^{-1}$，$\\Delta t = 1.0\\,\\mathrm{s}$，返回一个布尔值，指示确定性稳定性。\n- 测试 4：对于 $k = 5\\,\\mathrm{s}^{-1}$，$\\Delta t = 2.0\\,\\mathrm{s}$，返回一个布尔值，指示CLE变体的均方稳定性。\n- 测试 5：通过模拟混合格式的 $N = 100$ 个步骤来进行保正性检查，使用纯ODE漂移（$\\xi_n = 0$），参数为 $k = 20\\,\\mathrm{s}^{-1}$，$\\Delta t = 0.5\\,\\mathrm{s}$，$p = 0$ 分子/秒，$\\lambda = 0.2\\,\\mathrm{s}^{-1}$，以及初始 $x_0 = 0$ 分子。每一步使用显式SSA来计数跳跃。返回一个布尔值，指示所有模拟的 $x_n$ 值是否均为非负。\n- 测试 6：证明分裂隐式格式允许一个违反线性降解的显式欧拉稳定性的时间步长，但在后向欧拉法下仍保持稳定。对于 $k = 5\\,\\mathrm{s}^{-1}$ 和 $\\Delta t = 1.0\\,\\mathrm{s}$，计算两个布尔值：显式欧拉稳定性判据 $\\lvert 1 - k\\,\\Delta t \\rvert \\le 1$ 和隐式稳定性判据 $\\lvert G(k,\\Delta t)\\rvert \\le 1$，并返回一个布尔值，指示显式欧拉法是否不稳定但分裂隐式格式是稳定的。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），其中 $r_1$ 是一个浮点数，$r_2$ 到 $r_6$ 是布尔值，按上述测试的顺序计算。",
            "solution": "该问题要求实现并分析一种用于单物种合成生物学模型的混合随机-确定性模拟方法。对问题陈述的验证确认了其科学基础扎实、提法恰当且客观。它提供了一个清晰且一致的框架，用于将确定性或随机性连续过程（降解）与离散随机过程（出生事件）相结合。我们将通过系统地处理每个要求的测试用例来继续解决问题。\n\n该模型的核心是拷贝数 $x$ 在一个时间步长 $\\Delta t$ 上的一阶分裂隐式更新规则：\n$$\nx_{n+1} \\;=\\; \\frac{x_n \\;+\\; p\\,\\Delta t \\;+\\; J_n \\;+\\; \\xi_n}{\\,1 + k\\,\\Delta t\\,}\n$$\n其中 $x_n$ 是时间 $t_n$ 的拷贝数，$p$ 是恒定的生产速率，$k$ 是降解速率常数，$J_n$ 是区间内离散出生事件的数量，$\\xi_n$ 是随机变体的噪声项。分母 $1/(1 + k\\,\\Delta t)$ 源于对快速线性降解项 $dx/dt = -k\\,x$ 的隐式（后向欧拉）处理。因此，该线性算子的放大因子为 $G(k, \\Delta t) = 1 / (1 + k\\,\\Delta t)$。\n\n**测试 1：放大因子**\n格式的隐式线性降解部分的放大因子 $G(k, \\Delta t)$ 由以下公式给出：\n$$\nG(k, \\Delta t) \\;=\\; \\frac{1}{1 + k\\,\\Delta t}\n$$\n对于给定的参数 $k = 10\\,\\mathrm{s}^{-1}$ 和 $\\Delta t = 0.1\\,\\mathrm{s}$，我们将这些值代入公式：\n$$\nG(10, 0.1) \\;=\\; \\frac{1}{1 + (10\\,\\mathrm{s}^{-1}) \\cdot (0.1\\,\\mathrm{s})} \\;=\\; \\frac{1}{1 + 1} \\;=\\; 0.5\n$$\n结果是一个无量纲因子 $0.5$。\n\n**测试 2：确定性稳定性**\n确定性分裂隐式格式是稳定的，当且仅当放大因子的绝对值小于或等于一：\n$$\n\\lvert G(k, \\Delta t) \\rvert \\;\\le\\; 1\n$$\n此条件确保任何初始误差或扰动不会在连续的时间步中无限增长。对于参数 $k = 0\\,\\mathrm{s}^{-1}$ 和 $\\Delta t = 3.0\\,\\mathrm{s}$：\n$$\nG(0, 3.0) \\;=\\; \\frac{1}{1 + (0\\,\\mathrm{s}^{-1}) \\cdot (3.0\\,\\mathrm{s})} \\;=\\; \\frac{1}{1 + 0} \\;=\\; 1\n$$\n绝对值为 $\\lvert 1 \\rvert = 1$。由于 $1 \\le 1$，稳定性条件得到满足。该格式是稳定的。结果是 `True`。\n\n**测试 3：确定性稳定性**\n我们再次应用稳定性判据 $\\lvert G(k, \\Delta t) \\rvert \\le 1$。参数为 $k = -0.5\\,\\mathrm{s}^{-1}$ 和 $\\Delta t = 1.0\\,\\mathrm{s}$。负的 $k$ 对应于指数增长，而非降解。让我们在这些条件下测试该格式的数值稳定性：\n$$\nG(-0.5, 1.0) \\;=\\; \\frac{1}{1 + (-0.5\\,\\mathrm{s}^{-1}) \\cdot (1.0\\,\\mathrm{s})} \\;=\\; \\frac{1}{1 - 0.5} \\;=\\; \\frac{1}{0.5} \\;=\\; 2\n$$\n绝对值为 $\\lvert 2 \\rvert = 2$。由于 $2 > 1$，稳定性条件被违反。对于这个参数选择，该格式是不稳定的，这是预料之中的，因为它试图隐式地模拟一个不稳定的增长过程。结果是 `False`。\n\n**测试 4：均方稳定性**\n对于化学朗之万方程（CLE）变体，均方稳定性分析考虑了随机噪声项的影响。为分裂隐式格式提供的条件是：\n$$\n\\left(G(k, \\Delta t)\\right)^2 \\;\\le\\; 1\n$$\n当 $G(k, \\Delta t)$ 为实数时，这等同于确定性稳定性条件 $\\lvert G(k, \\Delta t) \\rvert \\le 1$。对于物理降解过程，$k > 0$ 和 $\\Delta t > 0$，因此 $G(k, \\Delta t)$ 是一个正实数。对于参数 $k = 5\\,\\mathrm{s}^{-1}$ 和 $\\Delta t = 2.0\\,\\mathrm{s}$：\n$$\nG(5, 2.0) \\;=\\; \\frac{1}{1 + (5\\,\\mathrm{s}^{-1}) \\cdot (2.0\\,\\mathrm{s})} \\;=\\; \\frac{1}{1 + 10} \\;=\\; \\frac{1}{11}\n$$\n我们然后对这个值求平方：\n$$\n\\left(\\frac{1}{11}\\right)^2 \\;=\\; \\frac{1}{121}\n$$\n由于 $1/121 \\le 1$，均方稳定性条件得到满足。该格式是稳定的。结果是 `True`。\n\n**测试 5：保正性**\n该问题要求检查状态 $x_n$ 在整个模拟过程中是否保持非负。我们考虑纯ODE情况（$\\xi_n=0, p=0$），此时更新规则简化为：\n$$\nx_{n+1} \\;=\\; \\frac{x_n + J_n}{1 + k\\,\\Delta t}\n$$\n参数为 $k = 20\\,\\mathrm{s}^{-1}$，$\\Delta t = 0.5\\,\\mathrm{s}$，$\\lambda = 0.2\\,\\mathrm{s}^{-1}$，以及 $x_0 = 0$。\n跳跃数 $J_n$ 由随机模拟算法（SSA）确定。根据其性质，$J_n$ 是一个非负整数（$J_n \\ge 0$）。问题指定了非负的物理参数 $k \\ge 0$ 和 $\\Delta t \\ge 0$，这确保了分母 $1+k\\,\\Delta t > 0$。给定初始状态 $x_0 = 0$，第一次更新为 $x_1 = J_0 / (1 + k\\Delta t)$。由于 $J_0 \\ge 0$，因此 $x_1 \\ge 0$。通过归纳法，如果 $x_n \\ge 0$ 且 $J_n \\ge 0$，则分子 $x_n + J_n \\ge 0$。由于分母为正， $x_{n+1}$ 也必须是非负的。因此，在该条件下，该格式保证保持正性。模拟必须证实这一分析结论。对于SSA部分，我们将使用固定的随机种子以确保确定性的结果。检查的结果必须是 `True`。\n\n**测试 6：显式与隐式稳定性**\n该测试凸显了隐式方法的一个关键优势。对于 $dx/dt = -k\\,x$ 的显式欧拉法具有更新规则 $x_{n+1} = x_n - k\\,\\Delta t\\,x_n = (1 - k\\,\\Delta t)x_n$。其稳定性要求放大因子 $1 - k\\,\\Delta t$ 的模不大于 $1$：\n$$\n\\lvert 1 - k\\,\\Delta t \\rvert \\;\\le\\; 1\n$$\n对于隐式格式，条件仍然是 $\\lvert G(k, \\Delta t) \\rvert \\le 1$。\n参数为 $k = 5\\,\\mathrm{s}^{-1}$ 和 $\\Delta t = 1.0\\,\\mathrm{s}$。\n\n显式欧拉稳定性：\n$$\n\\lvert 1 - (5\\,\\mathrm{s}^{-1}) \\cdot (1.0\\,\\mathrm{s}) \\rvert \\;=\\; \\lvert 1 - 5 \\rvert \\;=\\; \\lvert -4 \\rvert \\;=\\; 4\n$$\n由于 $4 > 1$，显式欧拉方法是不稳定的。\n\n隐式（分裂隐式）稳定性：\n$$\n\\lvert G(5, 1.0) \\rvert \\;=\\; \\left\\lvert \\frac{1}{1 + (5\\,\\mathrm{s}^{-1}) \\cdot (1.0\\,\\mathrm{s})} \\right\\rvert \\;=\\; \\left\\lvert \\frac{1}{6} \\right\\rvert \\;=\\; \\frac{1}{6}\n$$\n由于 $1/6 \\le 1$，隐式格式是稳定的。\n\n测试要求判断是否显式格式不稳定“且”隐式格式稳定。两个条件都满足。因此，结果是 `True`。这表明对刚性降解项的隐式处理允许比显式方法大得多的时间步长。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the hybrid\n    stochastic-deterministic simulation method.\n    \"\"\"\n\n    # --- Helper Functions ---\n\n    def compute_G(k, dt):\n        \"\"\"\n        Computes the amplification factor G(k, dt).\n        Test 1.\n        \"\"\"\n        return 1.0 / (1.0 + k * dt)\n\n    def is_det_stable(k, dt):\n        \"\"\"\n        Performs the deterministic linear stability test.\n        Tests 2  3.\n        \"\"\"\n        G = compute_G(k, dt)\n        return abs(G) = 1.0\n\n    def is_msq_stable(k, dt):\n        \"\"\"\n        Performs the mean-square stability test for the CLE variant.\n        Test 4.\n        \"\"\"\n        G = compute_G(k, dt)\n        return G**2 = 1.0\n\n    def ssa_jumps(lambda_val, dt, rng):\n        \"\"\"\n        Counts SSA events in a fixed window using the direct method.\n        Used in Test 5.\n        \n        Args:\n            lambda_val (float): The constant hazard for the jump process.\n            dt (float): The time window length.\n            rng (numpy.random.Generator): The random number generator.\n            \n        Returns:\n            int: The number of jumps that occurred in the interval.\n        \"\"\"\n        if lambda_val == 0:\n            return 0\n        \n        total_time = 0.0\n        jump_count = 0\n        # The scale parameter for np.random.exponential is the mean, which is 1/lambda.\n        scale = 1.0 / lambda_val\n        \n        while True:\n            wait_time = rng.exponential(scale=scale)\n            total_time += wait_time\n            if total_time > dt:\n                break\n            jump_count += 1\n        return jump_count\n\n    def check_positivity(k, dt, p, lambda_val, x0, N, seed=0):\n        \"\"\"\n        Performs the positivity preservation check by simulation.\n        Test 5.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        x = float(x0)\n        \n        denominator = 1.0 + k * dt\n        if denominator == 0:\n            # This case would lead to issues, but is not expected for physical params\n            return False \n\n        for _ in range(N):\n            if x  0:\n                return False  # Positivity violated\n            \n            # Count jumps for the current interval\n            jumps = ssa_jumps(lambda_val, dt, rng)\n            \n            # Update state using the hybrid scheme (pure ODE drift, p=0, xi=0)\n            numerator = x + p * dt + jumps\n            x = numerator / denominator\n\n        # Final check after the loop\n        return x >= 0\n\n    def compare_stability(k, dt):\n        \"\"\"\n        Compares explicit and implicit Euler stability.\n        Test 6.\n        \"\"\"\n        # Explicit Euler stability: abs(1 - k*dt) = 1\n        is_explicit_stable = abs(1.0 - k * dt) = 1.0\n        \n        # Implicit Euler stability (from is_det_stable)\n        is_implicit_stable = is_det_stable(k, dt)\n        \n        # Return True if explicit is unstable AND implicit is stable\n        return (not is_explicit_stable) and is_implicit_stable\n\n    # --- Test Suite Execution ---\n    \n    results = []\n\n    # Test 1: Amplification factor\n    k1, dt1 = 10.0, 0.1\n    results.append(compute_G(k1, dt1))\n\n    # Test 2: Deterministic stability\n    k2, dt2 = 0.0, 3.0\n    results.append(is_det_stable(k2, dt2))\n\n    # Test 3: Deterministic stability\n    k3, dt3 = -0.5, 1.0\n    results.append(is_det_stable(k3, dt3))\n\n    # Test 4: Mean-square stability\n    k4, dt4 = 5.0, 2.0\n    results.append(is_msq_stable(k4, dt4))\n\n    # Test 5: Positivity preservation\n    k5, dt5, p5, lambda5, x0_5, N5 = 20.0, 0.5, 0.0, 0.2, 0.0, 100\n    results.append(check_positivity(k5, dt5, p5, lambda5, x0_5, N5, seed=0))\n\n    # Test 6: Explicit vs. Implicit stability comparison\n    k6, dt6 = 5.0, 1.0\n    results.append(compare_stability(k6, dt6))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}