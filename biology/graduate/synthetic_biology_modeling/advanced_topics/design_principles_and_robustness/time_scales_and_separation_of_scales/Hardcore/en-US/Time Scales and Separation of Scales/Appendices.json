{
    "hands_on_practices": [
        {
            "introduction": "The equations of a biological model often contain a mixture of parameters with different units and magnitudes, obscuring the underlying dynamics. Nondimensionalization is a powerful mathematical technique that clarifies this by recasting the system in terms of dimensionless variables, often revealing a clear separation between fast and slow processes. In this exercise , you will apply this method to a mass-action model of a self-repressing gene circuit to formally identify the small parameter that justifies a singular perturbation approach.",
            "id": "3938690",
            "problem": "A synthetic gene circuit implements protein self-repression through dimer binding to its own promoter. The species are promoter in its free state $D$, promoter bound by a protein dimer $D^{\\ast}$, messenger ribonucleic acid (mRNA) $m$, protein monomer $p$, and protein dimer $s$. The reaction scheme is transcription from the free promoter, translation from mRNA, protein dimerization, and dimer binding to the promoter. Assume mass-action kinetics and promoter conservation $D + D^{\\ast} = N$, with $N$ the total promoter concentration. The ordinary differential equations are\n$$\n\\frac{dm}{dt} = \\alpha D - \\delta_{m} m,\n$$\n$$\n\\frac{dp}{dt} = \\beta m - \\delta_{p} p - 2 k_{d} p^{2} + 2 k_{ud} s,\n$$\n$$\n\\frac{ds}{dt} = k_{d} p^{2} - k_{ud} s - k_{c} s D + k_{uc} D^{\\ast},\n$$\n$$\n\\frac{dD}{dt} = - k_{c} s D + k_{uc} D^{\\ast}, \\quad D^{\\ast} = N - D,\n$$\nwhere $k_{d}$ and $k_{ud}$ are the forward and reverse dimerization rate constants, $k_{c}$ and $k_{uc}$ are the forward and reverse promoter-binding rate constants, $\\alpha$ is the transcription rate constant from free promoter, $\\beta$ is the translation rate constant, and $\\delta_{m}$, $\\delta_{p}$ are mRNA and protein decay rate constants. Consider the slow time scale set by mRNA decay, and define the following dimensional scales that reflect typical steady-state magnitudes on that slow time scale: $M^{\\ast} = \\alpha N / \\delta_{m}$ for $m$, $P^{\\ast} = \\beta M^{\\ast} / \\delta_{p}$ for $p$, $S^{\\ast} = (k_{d}/k_{ud}) (P^{\\ast})^{2}$ for $s$, and use $N$ to scale $D$ and $D^{\\ast}$. Let the dimensionless time be $\\tau = \\delta_{m} t$, and dimensionless variables $\\tilde{m} = m / M^{\\ast}$, $\\tilde{p} = p / P^{\\ast}$, $\\tilde{s} = s / S^{\\ast}$, $\\tilde{D} = D / N$, $\\tilde{D}^{\\ast} = D^{\\ast} / N$.\n\nStarting only from the mass-action model above and these scales, nondimensionalize the system to reveal the hidden small parameter that expresses the separation between the fast promoter-binding and dimerization reactions and the slow transcription dynamics. Identify the singularly perturbed structure in the nondimensional system and extract the dimensionless small parameter $\\epsilon$ as a ratio of the slow mRNA decay rate to a fast molecular timescale. Then, using the parameter values $\\delta_{m} = 0.15 \\,\\mathrm{min}^{-1}$ and $k_{ud} = 150 \\,\\mathrm{min}^{-1}$, compute the numerical value of $\\epsilon$.\n\nRound your answer to three significant figures and express it as a pure number with scientific notation. No units should be included in the final answer.",
            "solution": "The problem requires us to nondimensionalize a system of ordinary differential equations (ODEs) that model a synthetic gene circuit for protein self-repression. The goal is to identify a small dimensionless parameter, $\\epsilon$, that represents the separation of time scales between slow transcriptional dynamics and fast molecular reactions (dimerization and promoter binding). Finally, we must compute the numerical value of this parameter.\n\nThe given dimensional model is:\n$$\n\\frac{dm}{dt} = \\alpha D - \\delta_{m} m\n$$\n$$\n\\frac{dp}{dt} = \\beta m - \\delta_{p} p - 2 k_{d} p^{2} + 2 k_{ud} s\n$$\n$$\n\\frac{ds}{dt} = k_{d} p^{2} - k_{ud} s - k_{c} s D + k_{uc} D^{\\ast}\n$$\n$$\n\\frac{dD}{dt} = - k_{c} s D + k_{uc} D^{\\ast}\n$$\nwith the conservation law $D + D^{\\ast} = N$.\n\nWe are provided with the following dimensionless variables and scales:\nDimensionless time: $\\tau = \\delta_{m} t$\nDimensionless concentrations:\n$\\tilde{m} = m / M^{\\ast}$, where $M^{\\ast} = \\alpha N / \\delta_{m}$\n$\\tilde{p} = p / P^{\\ast}$, where $P^{\\ast} = \\beta M^{\\ast} / \\delta_{p}$\n$\\tilde{s} = s / S^{\\ast}$, where $S^{\\ast} = (k_{d}/k_{ud}) (P^{\\ast})^{2}$\n$\\tilde{D} = D / N$ and $\\tilde{D}^{\\ast} = D^{\\ast} / N$\n\nThe relationship between the time derivatives is found using the chain rule:\n$$\n\\frac{d}{dt} = \\frac{d\\tau}{dt} \\frac{d}{d\\tau} = \\delta_{m} \\frac{d}{d\\tau}\n$$\n\nLet us nondimensionalize each ODE.\n\n1.  **mRNA equation ($m$):**\n    Substitute $m = M^{\\ast}\\tilde{m}$, $D=N\\tilde{D}$, and $d/dt = \\delta_m d/d\\tau$:\n    $$\n    \\delta_{m} \\frac{d(M^{\\ast}\\tilde{m})}{d\\tau} = \\alpha(N\\tilde{D}) - \\delta_{m}(M^{\\ast}\\tilde{m})\n    $$\n    $$\n    \\delta_{m} M^{\\ast} \\frac{d\\tilde{m}}{d\\tau} = \\alpha N \\tilde{D} - \\delta_{m} M^{\\ast} \\tilde{m}\n    $$\n    Divide by $\\delta_{m} M^{\\ast}$:\n    $$\n    \\frac{d\\tilde{m}}{d\\tau} = \\frac{\\alpha N}{\\delta_{m} M^{\\ast}} \\tilde{D} - \\tilde{m}\n    $$\n    Substitute the scale $M^{\\ast} = \\alpha N / \\delta_{m}$:\n    $$\n    \\frac{d\\tilde{m}}{d\\tau} = \\frac{\\alpha N}{\\delta_{m} (\\alpha N / \\delta_{m})} \\tilde{D} - \\tilde{m}\n    $$\n    $$\n    \\frac{d\\tilde{m}}{d\\tau} = \\tilde{D} - \\tilde{m}\n    $$\n    This is the equation for the slow dynamics, with the time derivative having a coefficient of $1$.\n\n2.  **Dimer equation ($s$):**\n    The problem states that dimerization and promoter binding are fast reactions. We expect a small parameter to appear in front of the time derivatives for the species involved in these fast reactions, namely $s$ and $D$. Let's start with $s$.\n    $$\n    \\delta_{m} \\frac{d(S^{\\ast}\\tilde{s})}{d\\tau} = k_{d}(P^{\\ast}\\tilde{p})^{2} - k_{ud}(S^{\\ast}\\tilde{s}) - k_{c}(S^{\\ast}\\tilde{s})(N\\tilde{D}) + k_{uc}(N\\tilde{D}^{\\ast})\n    $$\n    $$\n    \\delta_{m} S^{\\ast} \\frac{d\\tilde{s}}{d\\tau} = k_{d}(P^{\\ast})^{2}\\tilde{p}^{2} - k_{ud}S^{\\ast}\\tilde{s} - k_{c}NS^{\\ast}\\tilde{s}\\tilde{D} + k_{uc}N\\tilde{D}^{\\ast}\n    $$\n    To reveal the singular perturbation structure, we divide by a term representing a fast reaction rate. The problem gives a value for $k_{ud}$, the dimer dissociation rate, suggesting it is the characteristic fast rate constant. Let's divide by $k_{ud}S^{\\ast}$:\n    $$\n    \\frac{\\delta_{m}}{k_{ud}}\\frac{d\\tilde{s}}{d\\tau} = \\frac{k_{d}(P^{\\ast})^{2}}{k_{ud}S^{\\ast}}\\tilde{p}^{2} - \\tilde{s} - \\frac{k_{c}N}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}N}{k_{ud}S^{\\ast}}\\tilde{D}^{\\ast}\n    $$\n    Now, substitute the scale for $s$, $S^{\\ast} = (k_{d}/k_{ud})(P^{\\ast})^{2}$:\n    The coefficient of $\\tilde{p}^2$ becomes $\\frac{k_{d}(P^{\\ast})^{2}}{k_{ud}((k_{d}/k_{ud})(P^{\\ast})^{2})} = 1$.\n    The equation for $\\tilde{s}$ is:\n    $$\n    \\frac{\\delta_{m}}{k_{ud}}\\frac{d\\tilde{s}}{d\\tau} = (\\tilde{p}^{2} - \\tilde{s}) - \\frac{k_{c}N}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}N}{k_{ud}S^{\\ast}}\\tilde{D}^{\\ast}\n    $$\n    This equation has the form $\\epsilon \\frac{d\\tilde{s}}{d\\tau} = f(\\tilde{p}, \\tilde{s}, \\tilde{D}, \\tilde{D}^{\\ast})$, where the dimensionless parameter $\\epsilon$ is given by:\n    $$\n    \\epsilon = \\frac{\\delta_{m}}{k_{ud}}\n    $$\n    This parameter $\\epsilon$ is the ratio of the slow mRNA decay rate ($\\delta_m$) to the fast dimer dissociation rate ($k_{ud}$). As $\\epsilon \\to 0$, the variable $\\tilde{s}$ becomes a fast variable, which rapidly relaxes to a quasi-steady state determined by the algebraic equation $f=0$.\n\n3.  **Promoter equation ($D$):**\n    We can perform a similar analysis for the promoter $D$ to confirm the structure.\n    $$\n    \\delta_{m}\\frac{d(N\\tilde{D})}{d\\tau} = -k_{c}(S^{\\ast}\\tilde{s})(N\\tilde{D}) + k_{uc}(N\\tilde{D}^{\\ast})\n    $$\n    We divide by a fast rate. To be consistent, we can use $k_{ud}$ and see what happens.\n    $$\n    \\frac{\\delta_{m}N}{k_{ud}} \\frac{d\\tilde{D}}{d\\tau} = -\\frac{k_{c}S^{\\ast}N}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}N}{k_{ud}}\\tilde{D}^{\\ast}\n    $$\n    Divide by $N$:\n    $$\n    \\frac{\\delta_{m}}{k_{ud}}\\frac{d\\tilde{D}}{d\\tau} = -\\frac{k_{c}S^{\\ast}}{k_{ud}}\\tilde{s}\\tilde{D} + \\frac{k_{uc}}{k_{ud}}\\tilde{D}^{\\ast}\n    $$\n    This shows that the derivative of $\\tilde{D}$ is also multiplied by $\\epsilon = \\delta_m / k_{ud}$, confirming that $\\tilde{D}$ is also a fast variable. The ratios of fast rate constants $k_c/k_{ud}$ and $k_{uc}/k_{ud}$ are assumed to be of order $1$.\n\nThe analysis has successfully revealed the singularly perturbed structure and identified the small parameter $\\epsilon$. It is the ratio of the characteristic slow rate, $\\delta_m$, to a characteristic fast rate, $k_{ud}$. The problem asks to \"extract the dimensionless small parameter $\\epsilon$ as a ratio of the slow mRNA decay rate to a fast molecular timescale\". This corresponds precisely to our finding. The fast molecular timescale is $\\tau_{fast} = 1/k_{ud}$. The slow timescale is $\\tau_{slow} = 1/\\delta_m$. The ratio is $\\tau_{fast}/\\tau_{slow} = \\delta_m/k_{ud}$.\n\nThe parameter is $\\epsilon = \\frac{\\delta_m}{k_{ud}}$.\n\nWe are given the numerical values:\n$\\delta_{m} = 0.15 \\,\\mathrm{min}^{-1}$\n$k_{ud} = 150 \\,\\mathrm{min}^{-1}$\n\nNow, we compute the value of $\\epsilon$:\n$$\n\\epsilon = \\frac{0.15 \\,\\mathrm{min}^{-1}}{150 \\,\\mathrm{min}^{-1}} = \\frac{0.15}{150} = \\frac{15 \\times 10^{-2}}{15 \\times 10^{1}} = 1 \\times 10^{-3} = 0.001\n$$\nThe problem requires the answer to be rounded to three significant figures and expressed in scientific notation.\n$$\n\\epsilon = 1.00 \\times 10^{-3}\n$$\nThis small value confirms the separation of scales between the slow mRNA dynamics and the fast dimerization/promoter-binding dynamics.",
            "answer": "$$\\boxed{1.00 \\times 10^{-3}}$$"
        },
        {
            "introduction": "An alternative to analytical scaling is to analyze the system's dynamics locally. Near a steady state, any complex dynamic behavior can be decomposed into a set of simpler, fundamental movements called \"dynamical modes,\" each with a characteristic rate. This practice  focuses on this numerical approach, where you will compute the eigenvalues of a linearized gene circuit model to quantify its modal time scales and, importantly, evaluate how sensitive your classification of \"fast\" and \"slow\" is to inevitable uncertainties in the model parameters.",
            "id": "3938670",
            "problem": "Consider a minimal linearized model of a single-gene regulatory circuit around a stable fixed point, where the state vector is $x = [m, p, a]^\\top$ with $m$ the messenger ribonucleic acid (mRNA) level, $p$ the protein level, and $a$ the promoter activity (dimensionless activation state). Near the fixed point, the dynamics can be approximated by a system of ordinary differential equations (ODE, Ordinary Differential Equation) with a constant Jacobian matrix $J(\\theta)$, where the parameter vector is $\\theta = (\\gamma_m, \\gamma_p, \\gamma_a, k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, s_p)$. The Jacobian is defined as\n$$\nJ(\\theta) =\n\\begin{bmatrix}\n-\\gamma_m & 0 & k_{\\mathrm{tx}} \\\\\nk_{\\mathrm{tl}} & -\\gamma_p & 0 \\\\\n0 & s_p & -\\gamma_a\n\\end{bmatrix},\n$$\nwhere $\\gamma_m$ and $\\gamma_p$ are first-order degradation rates of mRNA and protein (in $\\mathrm{s}^{-1}$), $\\gamma_a$ is the promoter relaxation rate (in $\\mathrm{s}^{-1}$), $k_{\\mathrm{tx}}$ is the sensitivity of mRNA production to promoter activity (in $\\mathrm{s}^{-1}$), $k_{\\mathrm{tl}}$ is the sensitivity of protein production to mRNA (in $\\mathrm{s}^{-1}$), and $s_p$ is the local slope of the promoter activity response with respect to protein at the fixed point (in $\\mathrm{s}^{-1}$), typically negative for repression.\n\nA core task in time-scale analysis is to compute the eigenvalues $\\lambda_i$ of $J(\\theta)$ and classify the dynamical modes as \"fast\" or \"slow\" based on the magnitudes of their real parts. Given a threshold $\\tau$ (in $\\mathrm{s}^{-1}$), classify a mode as fast if $|\\operatorname{Re}(\\lambda_i)| \\ge \\tau$ and slow otherwise. The choice of $\\tau$ should be justified by biological time-scale considerations (for example, separating sub-minute processes from multi-minute processes), and sensitivity of this classification to parameter uncertainty must be evaluated.\n\nYou are to implement a program that, for each test case below, performs the following steps:\n1. Compute the eigenvalues of $J(\\theta)$ and extract their real parts (in $\\mathrm{s}^{-1}$).\n2. Classify the modes as fast or slow using the rule above with the test case’s threshold $\\tau$.\n3. Compute the count of fast modes (an integer).\n4. Compute the maximum absolute value of the real parts $\\max_i |\\operatorname{Re}(\\lambda_i)|$ (a float in $\\mathrm{s}^{-1}$).\n5. Evaluate sensitivity to parameter uncertainty: independently perturb each parameter in $\\theta$ by a multiplicative factor $1+\\delta$, where $\\delta$ is sampled uniformly from $[-u, u]$ for the given uncertainty level $u$; perform $N$ independent samples and recompute the fast-mode count for each sample. Report the fraction (a decimal between $0$ and $1$) of samples for which the fast-mode count matches the baseline count computed at the nominal parameters.\n\nScientific realism constraints:\n- Assume $\\gamma_m > 0$, $\\gamma_p > 0$, $\\gamma_a > 0$, $k_{\\mathrm{tx}} \\ge 0$, $k_{\\mathrm{tl}} \\ge 0$, and $s_p \\le 0$.\n- Interpret all rates and eigenvalue real parts in $\\mathrm{s}^{-1}$.\n- The threshold $\\tau$ is given in $\\mathrm{s}^{-1}$ and must be applied to $|\\operatorname{Re}(\\lambda_i)|$.\n\nTest suite:\nFor each test case, the parameters are specified as $(\\gamma_m, \\gamma_p, \\gamma_a, k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, s_p, \\tau, u, N)$, with all rates and $\\tau$ in $\\mathrm{s}^{-1}$, $u$ dimensionless, and $N$ an integer number of samples.\n- Test case 1 (well-separated scales, typical repression):\n  - $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.003, 0.0002, 1.0)$\n  - $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.02, 0.01)$\n  - $s_p = -0.2$\n  - $\\tau = 0.01$, $u = 0.10$, $N = 1000$\n- Test case 2 (near-threshold rates, potentially sensitive classification):\n  - $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.009, 0.008, 0.015)$\n  - $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.02, 0.01)$\n  - $s_p = -0.05$\n  - $\\tau = 0.01$, $u = 0.20$, $N = 1000$\n- Test case 3 (weak coupling limit):\n  - $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.002, 0.0001, 0.05)$\n  - $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.015, 0.008)$\n  - $s_p = 0.0$\n  - $\\tau = 0.01$, $u = 0.10$, $N = 1000$\n- Test case 4 (near-degenerate slow rates, moderate coupling):\n  - $(\\gamma_m, \\gamma_p, \\gamma_a) = (0.0040, 0.0042, 0.30)$\n  - $(k_{\\mathrm{tx}}, k_{\\mathrm{tl}}) = (0.02, 0.02)$\n  - $s_p = -0.10$\n  - $\\tau = 0.01$, $u = 0.25$, $N = 1000$\n\nFinal output format:\nYour program should produce a single line of output containing a comma-separated list of numbers enclosed in square brackets. For each test case in the order given, output the following triple in sequence: the integer count of fast modes, the robust fraction (rounded to six decimal places, as a decimal without a percentage sign), and the maximum absolute real-part eigenvalue (rounded to six decimal places, in $\\mathrm{s}^{-1}$, printed as a plain float without units). Thus, the overall output aggregates the triples for all four test cases into a single flat list, for example, $[\\text{t1\\_fast\\_count}, \\text{t1\\_robust\\_fraction}, \\text{t1\\_max\\_abs\\_real}, \\dots, \\text{t4\\_max\\_abs\\_real}]$.",
            "solution": "The problem is assessed to be **valid**. It is scientifically grounded in the standard principles of linear systems analysis applied to biochemical reaction networks. The model, a linearized representation of a single-gene circuit, is a common and appropriate tool in systems and synthetic biology for studying local dynamics and time scales. All parameters are physically meaningful, and their specified constraints and values are realistic. The tasks—eigenvalue analysis, time-scale classification, and sensitivity analysis—are well-defined, mathematically formalizable, and directly relevant to the topic of *time scales and separation of scales in synthetic biology modeling*. The problem is self-contained, with all necessary data and conditions provided for each test case. There are no contradictions, ambiguities, or ill-posed elements.\n\nThe solution proceeds by implementing a computational analysis for each test case, as specified in the problem statement. This involves two main stages: a baseline analysis at the nominal parameter values and a sensitivity analysis using a Monte Carlo approach.\n\n**1. System Representation**\n\nThe core of the system is the $3 \\times 3$ Jacobian matrix $J(\\theta)$, which describes the linear dynamics of the mRNA concentration ($m$), protein concentration ($p$), and promoter activity ($a$) around a steady state. The parameter vector is $\\theta = (\\gamma_m, \\gamma_p, \\gamma_a, k_{\\mathrm{tx}}, k_{\\mathrm{tl}}, s_p)$.\n\n$$\nJ(\\theta) =\n\\begin{bmatrix}\n-\\gamma_m & 0 & k_{\\mathrm{tx}} \\\\\nk_{\\mathrm{tl}} & -\\gamma_p & 0 \\\\\n0 & s_p & -\\gamma_a\n\\end{bmatrix}\n$$\n\nThe eigenvalues $\\lambda_i$ of this matrix determine the characteristic time scales of the system's modes. The time scale of a mode $i$ is given by $1/|\\operatorname{Re}(\\lambda_i)|$. A large $|\\operatorname{Re}(\\lambda_i)|$ corresponds to a fast-decaying mode (short time scale), while a small $|\\operatorname{Re}(\\lambda_i)|$ corresponds to a slow-decaying mode (long time scale).\n\n**2. Baseline Analysis**\n\nFor each test case, we first perform an analysis using the nominal parameter values provided.\n\n*   **Step 2.1: Eigenvalue Computation**: The Jacobian matrix $J$ is constructed using the nominal parameters. The eigenvalues, $\\lambda_1, \\lambda_2, \\lambda_3$, are then computed numerically. As the matrix is real, the eigenvalues are either real or occur in complex conjugate pairs.\n*   **Step 2.2: Time-Scale Classification**: The real part of each eigenvalue, $\\operatorname{Re}(\\lambda_i)$, is extracted. According to the problem's rule, a mode is classified as \"fast\" if its corresponding absolute real part is greater than or equal to a given threshold $\\tau$, i.e., $|\\operatorname{Re}(\\lambda_i)| \\ge \\tau$. Otherwise, it is classified as \"slow\". The total number of fast modes is counted. This provides the baseline fast-mode count.\n*   **Step 2.3: Maximum Rate**: We compute the maximum absolute value of the real parts of all eigenvalues, $\\max_i |\\operatorname{Re}(\\lambda_i)|$. This value quantifies the fastest dynamic rate in the system.\n\n**3. Sensitivity Analysis**\n\nTo assess the robustness of the time-scale classification to parameter uncertainty, a Monte Carlo simulation is performed. This procedure evaluates how frequently the number of fast modes changes when parameters fluctuate within a given uncertainty range.\n\n*   **Step 3.1: Parameter Perturbation**: For a total of $N$ samples, a new set of perturbed parameters $\\theta'$ is generated. Each nominal parameter $\\theta_j$ is multiplied by a random factor $(1+\\delta_j)$, where $\\delta_j$ is drawn from a uniform distribution over $[-u, u]$. Here, $u$ is the specified fractional uncertainty level. This creates a perturbed parameter vector $\\theta' = \\theta \\odot (1+\\vec{\\delta})$, where $\\odot$ is the element-wise product.\n*   **Step 3.2: Reclassification**: For each of the $N$ perturbed parameter sets $\\theta'$, a new Jacobian matrix $J(\\theta')$ is constructed. Its eigenvalues are computed, and the number of fast modes is determined using the same threshold $\\tau$.\n*   **Step 3.3: Robustness Fraction**: The number of fast modes from each perturbed sample is compared to the baseline fast-mode count (calculated in Step 2.2). The robustness fraction is defined as the fraction of the $N$ samples for which the fast-mode count remains unchanged from the baseline. A fraction close to $1.0$ indicates that the time-scale separation is robust to parameter uncertainty, while a lower fraction suggests the classification is sensitive and may not be a reliable feature of the model.\n\n**4. Implementation**\n\nThe above procedure is implemented in a Python function. `numpy` is used for matrix operations and eigenvalue calculations (`numpy.linalg.eigvals`), as well as for generating random numbers for the sensitivity analysis (`numpy.random.uniform`). The function iterates through each test case, computes the required triple of values (fast-mode count, robustness fraction, and maximum absolute real part), and formats them for the final output as specified. The rounding of floating-point numbers to six decimal places is handled during the formatting of the output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_model_dynamics(gamma_m, gamma_p, gamma_a, k_tx, k_tl, s_p, tau, u, N):\n    \"\"\"\n    Analyzes the dynamics of a single-gene regulatory circuit.\n\n    Args:\n        gamma_m (float): mRNA degradation rate.\n        gamma_p (float): Protein degradation rate.\n        gamma_a (float): Promoter relaxation rate.\n        k_tx (float): Transcription sensitivity.\n        k_tl (float): Translation sensitivity.\n        s_p (float): Promoter response slope.\n        tau (float): Fast/slow mode classification threshold.\n        u (float): Fractional uncertainty level for sensitivity analysis.\n        N (int): Number of samples for sensitivity analysis.\n\n    Returns:\n        tuple: A tuple containing:\n            - int: The number of fast modes at nominal parameters.\n            - float: The fraction of samples with a matching fast-mode count.\n            - float: The maximum absolute real part of the eigenvalues.\n    \"\"\"\n    \n    # --- Part 1: Baseline Analysis ---\n    nominal_params = np.array([gamma_m, gamma_p, gamma_a, k_tx, k_tl, s_p])\n\n    def construct_jacobian(params):\n        gm, gp, ga, ktx, ktl, sp = params\n        return np.array([\n            [-gm, 0, ktx],\n            [ktl, -gp, 0],\n            [0, sp, -ga]\n        ])\n\n    J_nominal = construct_jacobian(nominal_params)\n    eigvals_nominal = np.linalg.eigvals(J_nominal)\n    abs_re_eigvals_nominal = np.abs(np.real(eigvals_nominal))\n    \n    max_abs_real = np.max(abs_re_eigvals_nominal)\n    baseline_fast_count = int(np.sum(abs_re_eigvals_nominal >= tau))\n\n    # --- Part 2: Sensitivity Analysis ---\n    match_count = 0\n    # No random seed for strict adherence to problem, results may have minor statistical fluctuations run-to-run.\n    \n    for _ in range(N):\n        # Generate perturbation factors uniformly from [1-u, 1+u]\n        perturbation_factors = 1.0 + np.random.uniform(-u, u, size=len(nominal_params))\n        \n        # Apply perturbations\n        perturbed_params = nominal_params * perturbation_factors\n        \n        # Construct and analyze perturbed system\n        J_perturbed = construct_jacobian(perturbed_params)\n        eigvals_perturbed = np.linalg.eigvals(J_perturbed)\n        abs_re_eigvals_perturbed = np.abs(np.real(eigvals_perturbed))\n        perturbed_fast_count = int(np.sum(abs_re_eigvals_perturbed >= tau))\n\n        if perturbed_fast_count == baseline_fast_count:\n            match_count += 1\n            \n    robust_fraction = match_count / N\n\n    return (baseline_fast_count, robust_fraction, max_abs_real)\n\ndef solve():\n    \"\"\"\n    Runs the analysis for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (gamma_m, gamma_p, gamma_a, k_tx, k_tl, s_p, tau, u, N)\n        # Test case 1: Well-separated scales, typical repression\n        (0.003, 0.0002, 1.0, 0.02, 0.01, -0.2, 0.01, 0.10, 1000),\n        # Test case 2: Near-threshold rates, potentially sensitive classification\n        (0.009, 0.008, 0.015, 0.02, 0.01, -0.05, 0.01, 0.20, 1000),\n        # Test case 3: Weak coupling limit\n        (0.002, 0.0001, 0.05, 0.015, 0.008, 0.0, 0.01, 0.10, 1000),\n        # Test case 4: Near-degenerate slow rates, moderate coupling\n        (0.0040, 0.0042, 0.30, 0.02, 0.02, -0.10, 0.01, 0.25, 1000)\n    ]\n\n    results = []\n    for params in test_cases:\n        fast_count, robust_frac, max_real = analyze_model_dynamics(*params)\n        results.append(fast_count)\n        results.append(f\"{robust_frac:.6f}\")\n        results.append(f\"{max_real:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Identifying a separation of time scales is not just an analytical exercise; it is an opportunity for computational efficiency. When some parts of a system evolve much faster than others, a standard simulation algorithm wastes resources by updating everything at the rate of the fastest process. This final practice  demonstrates how to exploit this separation by guiding you through the implementation of a hierarchical multirate solver, a sophisticated method that simulates fast and slow components at their own natural paces.",
            "id": "3938614",
            "problem": "You are modeling a simple gene expression module in synthetic biology with clear separation of time scales between promoter switching (fast) and protein accumulation (slow). The promoter has two states, \"OFF\" and \"ON,\" with a probability vector $p(t) = [p_0(t), p_1(t)]^\\top$ satisfying $p_0(t) + p_1(t) = 1$, where $p_1(t)$ is the probability of being \"ON\". Protein concentration is denoted by $x(t)$. The fast module is a two-state continuous-time Markov chain with generator $Q(x)$ whose off-diagonal rates depend on $x(t)$ through repression of the \"ON\" rate. Specifically, for a fixed slow variable $x$, the generator acting on the column vector is $Q(x)^\\top$, where\n$$\nQ(x)^\\top = \\begin{bmatrix}\n- k_{\\mathrm{on}}(x) & k_{\\mathrm{off}} \\\\\nk_{\\mathrm{on}}(x) & - k_{\\mathrm{off}}\n\\end{bmatrix},\n\\quad\nk_{\\mathrm{on}}(x) = \\dfrac{k_{\\mathrm{on},0}}{1 + x/K},\n\\quad\nk_{\\mathrm{off}} > 0,\n$$\nwith $k_{\\mathrm{on},0} > 0$ and $K > 0$. The slow module is governed by an Ordinary Differential Equation (ODE) for protein concentration:\n$$\n\\dfrac{dx}{dt} = \\alpha\\, p_1(t) - \\delta\\, x(t),\n$$\nwith $\\alpha > 0$ and $\\delta > 0$. Initial conditions satisfy $p_0(0) = 1$, $p_1(0) = 0$, and $x(0) = 0$. For fixed $x$, the stationary \"ON\" probability is\n$$\np_1^\\star(x) = \\dfrac{k_{\\mathrm{on}}(x)}{k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}},\n$$\nand the spectral gap (the magnitude of the nonzero eigenvalue of $Q(x)$) is\n$$\n\\gamma(x) = k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}.\n$$\n\nDesign and implement a hierarchical multirate simulation scheme that updates the fast module frequently and the slow module infrequently, using macro-step size $H$ for the slow variable and micro-step size $h$ for the fast promoter. In each macro-step, freeze $x$ and update $p(t)$ over $H$ by performing $m = \\lfloor H/h \\rfloor$ or $m = \\lceil H/h \\rceil$ micro-steps with step size $h_m = H/m$, using the exact update for the two-state Markov chain under constant $x$:\n$$\np_1 \\leftarrow p_1^\\star(x) + \\big(p_1 - p_1^\\star(x)\\big)\\, e^{-\\gamma(x)\\, h_m},\n$$\nand accumulate the time-average of $p_1$ over the macro-step as\n$$\n\\overline{p_1} \\approx \\dfrac{1}{m} \\sum_{j=1}^m p_1^{(j)}.\n$$\nThen update the slow variable by explicit Euler using the averaged production:\n$$\nx \\leftarrow x + H\\left( \\alpha\\, \\overline{p_1} - \\delta\\, x \\right).\n$$\nRepeat this macro-update until the final time $T$.\n\nJustify the accuracy of this hierarchical scheme with an error estimate that depends on the spectral gap. To do so, use the following bound on the final-time error for $x(T)$, obtained by combining fast relaxation and lag due to the slow drift of $x$:\n$$\n\\big|x_{\\mathrm{ref}}(T) - x_{\\mathrm{hier}}(T)\\big| \\le \\sum_{n=0}^{N-1} \\left( b_{\\mathrm{relax}}^{(n)} + b_{\\mathrm{drift}}^{(n)} \\right),\n$$\nwhere $N = \\lfloor T/H \\rfloor$ is the number of macro-steps, and for the $n$-th macro-step starting at $x_n$ and $p_{1,n}$,\n$$\nb_{\\mathrm{relax}}^{(n)} = \\alpha\\, \\dfrac{\\big|p_{1,n} - p_1^\\star(x_n)\\big|}{\\gamma(x_n)} \\left(1 - e^{-\\gamma(x_n)\\, H}\\right),\n$$\nand\n$$\nb_{\\mathrm{drift}}^{(n)} = \\alpha\\, \\dfrac{L(x_n)}{\\gamma(x_n)}\\, H^2\\, \\max\\left\\{ \\left|\\dfrac{dx}{dt}\\right| \\text{ over macro-step } n \\right\\},\n$$\nwith the Lipschitz factor\n$$\nL(x) = \\left| \\dfrac{d p_1^\\star}{dx}(x) \\right| = \\left| \\dfrac{k_{\\mathrm{off}}}{\\big(k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}\\big)^2} \\cdot \\dfrac{d k_{\\mathrm{on}}}{dx}(x) \\right|\n= \\dfrac{k_{\\mathrm{off}}}{\\big(k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}\\big)^2} \\cdot \\dfrac{k_{\\mathrm{on},0}/K}{\\big(1 + x/K\\big)^2}.\n$$\nUse the crude bound $\\max\\{ |dx/dt| \\text{ over macro-step } n \\} \\le \\alpha + \\delta\\, x_n$.\n\nImplement both:\n- A high-accuracy reference integration of the full coupled ODE system for $[p_0(t), p_1(t), x(t)]$ using a standard solver that directly integrates\n$$\n\\dfrac{dp_0}{dt} = -k_{\\mathrm{on}}(x)\\, p_0 + k_{\\mathrm{off}}\\, p_1, \\quad\n\\dfrac{dp_1}{dt} = k_{\\mathrm{on}}(x)\\, p_0 - k_{\\mathrm{off}}\\, p_1, \\quad\n\\dfrac{dx}{dt} = \\alpha\\, p_1 - \\delta\\, x,\n$$\nfrom $t=0$ to $t=T$, and returns $x_{\\mathrm{ref}}(T)$.\n- The hierarchical scheme described above, returning $x_{\\mathrm{hier}}(T)$ and the total bound $\\sum_{n=0}^{N-1} \\left( b_{\\mathrm{relax}}^{(n)} + b_{\\mathrm{drift}}^{(n)} \\right)$.\n\nYour program must compute, for each provided test case, the absolute error at final time,\n$$\n\\mathrm{err} = \\big|x_{\\mathrm{ref}}(T) - x_{\\mathrm{hier}}(T)\\big|,\n$$\nand the theoretical error bound computed as above. No physical units are used; all quantities are dimensionless.\n\nTest Suite:\n- Case A (clear time-scale separation): $k_{\\mathrm{on},0} = 80.0$, $k_{\\mathrm{off}} = 120.0$, $K = 50.0$, $\\alpha = 10.0$, $\\delta = 0.05$, $T = 10.0$, $H = 0.1$, $h = 0.01$.\n- Case B (near-equal scales): $k_{\\mathrm{on},0} = 2.0$, $k_{\\mathrm{off}} = 2.0$, $K = 50.0$, $\\alpha = 5.0$, $\\delta = 0.5$, $T = 5.0$, $H = 0.2$, $h = 0.02$.\n- Case C (strong repression, large separation): $k_{\\mathrm{on},0} = 200.0$, $k_{\\mathrm{off}} = 100.0$, $K = 10.0$, $\\alpha = 20.0$, $\\delta = 0.1$, $T = 8.0$, $H = 0.2$, $h = 0.01$.\n- Case D (minimal spectral gap): $k_{\\mathrm{on},0} = 0.5$, $k_{\\mathrm{off}} = 0.5$, $K = 100.0$, $\\alpha = 1.0$, $\\delta = 0.05$, $T = 4.0$, $H = 0.5$, $h = 0.1$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\mathrm{err}_A,\\mathrm{bound}_A,\\mathrm{err}_B,\\mathrm{bound}_B,\\mathrm{err}_C,\\mathrm{bound}_C,\\mathrm{err}_D,\\mathrm{bound}_D]$, where each entry is a float.",
            "solution": "The problem requires the implementation and comparison of two numerical methods for solving a hybrid stochastic-deterministic model of gene expression. This system is characterized by a separation of time scales: fast switching of a gene's promoter between \"ON\" and \"OFF\" states, and slow accumulation and degradation of the protein product.\n\n### Problem Formulation as a Slow-Fast System\n\nThe state of the system is described by the vector $[p_0(t), p_1(t), x(t)]^\\top$, where $p_0(t)$ and $p_1(t)$ are the probabilities of the promoter being in the OFF and ON states, respectively, and $x(t)$ is the protein concentration. The dynamics are governed by a coupled system of ordinary differential equations (ODEs):\n$$\n\\frac{d}{dt} \\begin{pmatrix} p_0 \\\\ p_1 \\end{pmatrix} = \\begin{bmatrix} -k_{\\mathrm{on}}(x) & k_{\\mathrm{off}} \\\\ k_{\\mathrm{on}}(x) & -k_{\\mathrm{off}} \\end{bmatrix} \\begin{pmatrix} p_0 \\\\ p_1 \\end{pmatrix} = Q(x)^\\top p\n$$\n$$\n\\frac{dx}{dt} = \\alpha p_1(t) - \\delta x(t)\n$$\nThe promoter switching rates, particularly $k_{\\mathrm{on}}(x) = \\frac{k_{\\mathrm{on},0}}{1 + x/K}$, depend on the slow variable $x(t)$, creating a feedback loop. The time-scale separation arises when the promoter switching rates are much larger than the protein dynamics rates, i.e., when the spectral gap $\\gamma(x) = k_{\\mathrm{on}}(x) + k_{\\mathrm{off}}$ is much larger than $\\delta$.\n\nDue to the probability conservation $p_0(t) + p_1(t) = 1$, the fast subsystem can be reduced to a single equation for $p_1(t)$:\n$$\n\\frac{dp_1}{dt} = k_{\\mathrm{on}}(x)(1-p_1) - k_{\\mathrm{off}}p_1 = k_{\\mathrm{on}}(x) - (k_{\\mathrm{on}}(x) + k_{\\mathrm{off}})p_1 = k_{\\mathrm{on}}(x) - \\gamma(x)p_1\n$$\nThe full system to be solved consists of two coupled ODEs for the state vector $[p_1(t), x(t)]^\\top$:\n$$\n\\frac{dp_1}{dt} = k_{\\mathrm{on}}(x) - \\gamma(x)p_1\n$$\n$$\n\\frac{dx}{dt} = \\alpha p_1 - \\delta x\n$$\nwith initial conditions $p_1(0) = 0$ and $x(0) = 0$.\n\n### 1. Reference Solution: Full System Integration\n\nTo obtain a high-accuracy reference solution, $x_{\\mathrm{ref}}(T)$, we directly integrate the coupled two-variable ODE system from $t=0$ to $t=T$. This is achieved using a standard numerical ODE solver, specifically `scipy.integrate.solve_ivp`, with stringent relative and absolute error tolerances (e.g., $10^{-8}$ and $10^{-10}$) to ensure the solution is very close to the true trajectory.\n\n### 2. Hierarchical Multirate Scheme\n\nThis scheme exploits the time-scale separation. The slow variable $x$ is updated with large time steps (macro-steps) of size $H$, while the fast variable $p_1$ is updated with small time steps (micro-steps) of size $h_m$.\n\nThe algorithm proceeds as follows for $N = \\lfloor T/H \\rfloor$ macro-steps:\nLet the state at the beginning of macro-step $n$ (time $t_n$) be $(p_{1,n}, x_n)$.\n\n1.  **Freeze Slow Variable**: Assume $x(t)$ is constant and equal to $x_n$ over the interval $[t_n, t_n+H]$.\n\n2.  **Fast Subsystem Simulation (Micro-steps)**: With $x$ fixed at $x_n$, the ODE for $p_1$ becomes linear with a constant coefficient: $\\frac{dp_1}{dt} = k_{\\mathrm{on}}(x_n) - \\gamma(x_n)p_1$. The exact solution over a time step $h_m$ is used for the micro-updates:\n    $$\n    p_1(t_n + (j+1)h_m) = p_1^\\star(x_n) + \\left(p_1(t_n + jh_m) - p_1^\\star(x_n)\\right) e^{-\\gamma(x_n) h_m}\n    $$\n    where $p_1^\\star(x_n) = k_{\\mathrm{on}}(x_n) / \\gamma(x_n)$ is the stationary \"ON\" probability for the fixed $x_n$.\n    We perform $m = \\text{round}(H/h)$ such updates, starting with $p_{1,n}$, and compute the time average of the resulting $p_1$ values over the macro-step:\n    $$\n    \\overline{p_1} = \\frac{1}{m} \\sum_{j=1}^{m} p_{1}^{(j)}\n    $$\n\n3.  **Slow Variable Update (Macro-step)**: The slow variable $x$ is updated using a single explicit Euler step of size $H$, using the averaged production term from the fast simulation:\n    $$\n    x_{n+1} = x_n + H \\left( \\alpha \\overline{p_1} - \\delta x_n \\right)\n    $$\n    The final value of $p_1$ from the micro-simulations, $p_{1,m}$, becomes the initial condition $p_{1, n+1}$ for the next macro-step.\n\nThe final value $x_N$ is the hierarchical scheme's approximation, $x_{\\mathrm{hier}}(T)$.\n\n### 3. Error Bound Calculation\n\nThe problem provides an a priori error bound that quantifies the accuracy of the hierarchical scheme. The total error at the final time $T$ is bounded by the sum of per-step error contributions over all $N$ macro-steps. For each macro-step $n$, the error contribution has two parts:\n\n1.  **Relaxation Error ($b_{\\mathrm{relax}}^{(n)}$)**: This error arises because the fast variable $p_1$ is not at its quasi-stationary state $p_1^\\star(x_n)$ at the beginning of the macro-step. The term measures the impact of this initial disequilibrium propagating through the slow dynamics.\n    $$\n    b_{\\mathrm{relax}}^{(n)} = \\alpha\\, \\dfrac{\\big|p_{1,n} - p_1^\\star(x_n)\\big|}{\\gamma(x_n)} \\left(1 - e^{-\\gamma(x_n)\\, H}\\right)\n    $$\n    This term is small if the fast system relaxes quickly (large $\\gamma(x_n)$) or if $p_{1,n}$ is already close to $p_1^\\star(x_n)$.\n\n2.  **Drift Error ($b_{\\mathrm{drift}}^{(n)}$)**: This error stems from freezing the slow variable $x$ at $x_n$ during the macro-step, ignoring its drift. This approximation affects the fast dynamics' parameters ($k_{\\mathrm{on}}(x)$, $\\gamma(x)$, $p_1^\\star(x)$), leading to an error.\n    $$\n    b_{\\mathrm{drift}}^{(n)} = \\alpha\\, \\dfrac{L(x_n)}{\\gamma(x_n)}\\, H^2\\, \\max\\left\\{ \\left|\\dfrac{dx}{dt}\\right| \\right\\}\n    $$\n    where $L(x_n)=|dp_1^\\star/dx|_{x=x_n}$ is a measure of the sensitivity of the fast equilibrium to changes in $x$. The term is proportional to $H^2$, as expected for an error caused by a first-order approximation (freezing) of a drifting parameter. We use the provided crude bound $\\max\\{ |dx/dt| \\} \\le \\alpha + \\delta x_n$.\n\nThe total error bound is the sum of these contributions over all steps: $\\sum_{n=0}^{N-1} (b_{\\mathrm{relax}}^{(n)} + b_{\\mathrm{drift}}^{(n)})$. This bound is calculated concurrently with the hierarchical simulation.\n\nThe final implementation will compute both the actual error $\\mathrm{err} = |x_{\\mathrm{ref}}(T) - x_{\\mathrm{hier}}(T)|$ and this theoretical bound for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the gene expression modeling problem for a suite of test cases.\n\n    This function implements a high-accuracy reference solver and a hierarchical multirate\n    solver to model a simple gene expression module with time-scale separation. It computes\n    the absolute error between the two methods and a theoretical error bound for the\n    hierarchical scheme.\n    \"\"\"\n    test_cases = [\n        # Case A: clear time-scale separation\n        {'k_on0': 80.0, 'k_off': 120.0, 'K': 50.0, 'alpha': 10.0, 'delta': 0.05, 'T': 10.0, 'H': 0.1, 'h': 0.01},\n        # Case B: near-equal scales\n        {'k_on0': 2.0, 'k_off': 2.0, 'K': 50.0, 'alpha': 5.0, 'delta': 0.5, 'T': 5.0, 'H': 0.2, 'h': 0.02},\n        # Case C: strong repression, large separation\n        {'k_on0': 200.0, 'k_off': 100.0, 'K': 10.0, 'alpha': 20.0, 'delta': 0.1, 'T': 8.0, 'H': 0.2, 'h': 0.01},\n        # Case D: minimal spectral gap\n        {'k_on0': 0.5, 'k_off': 0.5, 'K': 100.0, 'alpha': 1.0, 'delta': 0.05, 'T': 4.0, 'H': 0.5, 'h': 0.1},\n    ]\n\n    results = []\n\n    # --- Helper functions based on problem definitions ---\n    def k_on(x, k_on0, K):\n        return k_on0 / (1.0 + x / K)\n\n    def gamma_func(x, k_on0, k_off, K):\n        return k_on(x, k_on0, K) + k_off\n\n    def p1_star(x, k_on0, k_off, K):\n        kon = k_on(x, k_on0, K)\n        return kon / (kon + k_off)\n\n    def L_factor(x, k_on0, k_off, K):\n        kon = k_on(x, k_on0, K)\n        gamma_val = kon + k_off\n        d_kon_dx_num = k_on0 / K\n        one_plus_x_K_sq = (1.0 + x / K)**2\n        return (k_off / (gamma_val**2)) * (d_kon_dx_num / one_plus_x_K_sq)\n\n    # --- ODE system for the reference solver ---\n    def ref_ode_system(t, y, params):\n        p1, x = y\n        k_on0, k_off, K, alpha, delta = params\n        \n        kon_val = k_on(x, k_on0, K)\n        gamma_val = kon_val + k_off\n        \n        dp1dt = kon_val - gamma_val * p1\n        dxdt = alpha * p1 - delta * x\n        \n        return [dp1dt, dxdt]\n\n    for case in test_cases:\n        params_tuple = (case['k_on0'], case['k_off'], case['K'], case['alpha'], case['delta'])\n    \n        # 1. High-accuracy reference solution\n        y0 = [0.0, 0.0]  # Initial conditions: p1(0)=0, x(0)=0\n        sol = solve_ivp(\n            ref_ode_system, \n            [0, case['T']], \n            y0, \n            args=(params_tuple,),\n            dense_output=True, \n            rtol=1e-9, \n            atol=1e-12\n        )\n        x_ref_T = sol.sol(case['T'])[1]\n\n        # 2. Hierarchical multirate simulation and error bound calculation\n        p1_h = 0.0\n        x_h = 0.0\n        total_bound = 0.0\n        \n        num_macro_steps = int(np.floor(case['T'] / case['H']))\n        H = case['H']\n        m = int(round(H / case['h']))\n        h_m = H / m\n\n        alpha = case['alpha']\n        delta = case['delta']\n        k_on0 = case['k_on0']\n        k_off = case['k_off']\n        K = case['K']\n        \n        for n in range(num_macro_steps):\n            x_n = x_h\n            p1_n = p1_h\n\n            # Calculate step-dependent quantities based on frozen x_n\n            kon_n = k_on(x_n, k_on0, K)\n            gamma_n = kon_n + k_off\n            p1s_n = kon_n / gamma_n\n            \n            # --- Calculate contribution to error bound for this macro-step ---\n            # Relaxation error term\n            b_relax_n = alpha * np.abs(p1_n - p1s_n) / gamma_n * (1.0 - np.exp(-gamma_n * H))\n            \n            # Drift error term\n            L_n = L_factor(x_n, k_on0, k_off, K)\n            dx_dt_max_bound = alpha + delta * x_n\n            b_drift_n = alpha * (L_n / gamma_n) * (H**2) * dx_dt_max_bound\n            \n            total_bound += b_relax_n + b_drift_n\n\n            # --- Fast subsystem simulation (micro-steps) ---\n            p1_sum = 0.0\n            p1_micro = p1_n\n            exp_term = np.exp(-gamma_n * h_m)\n            \n            for _ in range(m):\n                p1_micro = p1s_n + (p1_micro - p1s_n) * exp_term\n                p1_sum += p1_micro\n            p1_bar = p1_sum / m\n            \n            # --- Slow variable update (macro-step) ---\n            x_h += H * (alpha * p1_bar - delta * x_n)\n            p1_h = p1_micro # Update p1 for the next macro-step\n\n        x_hier_T = x_h\n        \n        # Calculate final error and append results\n        abs_error = np.abs(x_ref_T - x_hier_T)\n        results.extend([abs_error, total_bound])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}