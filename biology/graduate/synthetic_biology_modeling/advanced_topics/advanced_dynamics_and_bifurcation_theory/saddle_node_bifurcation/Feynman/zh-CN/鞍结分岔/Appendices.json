{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在训练识别鞍点分岔的基本技能。通过分析一个简单的二次多项式模型 ，您将练习应用核心的数学条件——即系统状态的变化率及其对状态的导数同时为零——来精确地找到发生分岔的参数值。这项技能是分析更复杂生物系统的基础。",
            "id": "1704303",
            "problem": "一个生物反应器中物种种群密度 $x(t)$ 的简化模型由以下一阶非线性微分方程描述：\n$$\n\\frac{dx}{dt} = r - \\beta x + x^2\n$$\n在此模型中，$x(t)$ 表示非负的种群密度。参数 $r$ 是一个常数，表示物种引入反应器的正速率。$-\\beta x$ 项模拟死亡率，而 $x^2$ 项表示促进种群增长的合作相互作用。系统的长期行为，特别是其平衡态，取决于 $r$ 的值。\n\n已知死亡率系数为 $\\beta = 10$，求系统发生鞍结分岔时引入速率 $r$ 的具体值。",
            "solution": "我们考虑自治微分方程 $\\frac{dx}{dt} = f(x;r)$，其中 $f(x;r) = r - \\beta x + x^{2}$。平衡点满足 $f(x;r)=0$，即：\n$$\nx^{2} - \\beta x + r = 0.\n$$\n当两个平衡点合并成一个二重根时，发生鞍结分岔。其必要条件是以下联立方程组\n$$\nf(x;r) = 0, \\quad \\frac{\\partial f}{\\partial x}(x;r) = 0.\n$$\n计算导数：\n$$\n\\frac{\\partial f}{\\partial x}(x;r) = -\\beta + 2x.\n$$\n令 $\\frac{\\partial f}{\\partial x} = 0$ 可得\n$$\n-\\beta + 2x = 0 \\quad \\Rightarrow \\quad x = \\frac{\\beta}{2}.\n$$\n将此代入 $f(x;r)=0$ 中：\n$$\nr - \\beta \\left(\\frac{\\beta}{2}\\right) + \\left(\\frac{\\beta}{2}\\right)^{2} = 0\n\\;\\;\\Rightarrow\\;\\;\nr - \\frac{\\beta^{2}}{2} + \\frac{\\beta^{2}}{4} = 0\n\\;\\;\\Rightarrow\\;\\;\nr - \\frac{\\beta^{2}}{4} = 0.\n$$\n因此，鞍结分岔发生在\n$$\nr = \\frac{\\beta^{2}}{4}.\n$$\n当 $\\beta = 10$ 时，可得\n$$\nr = \\frac{10^{2}}{4} = 25.\n$$\n分岔点对应的平衡点为 $x = \\beta/2 = 5 \\ge 0$，这与非负性要求一致。",
            "answer": "$$\\boxed{25}$$"
        },
        {
            "introduction": "除了分析现有系统，合成生物学的一个关键技能是设计具有特定行为的生物回路。这个问题  将挑战您进行“逆向工程”，即构建一个最简单的多项式模型，使其在预定的点上展现鞍点分岔。这种“以设计为导向”的思维方式将迫使您更深刻地理解定义分岔的数学条件，并将其视为设计规范而非仅仅是检验标准。",
            "id": "1704286",
            "problem": "考虑一个由常微分方程 $\\frac{dx}{dt} = f(x, r)$ 描述的一维动力系统，其中 $x(t)$ 是系统的状态，$r$ 是一个实值分岔参数。你的任务是构造一个最简单的非平凡多项式函数 $f(x, r)$，使得系统在临界点 $(x_c, r_c) = (5, 1)$ 处经历鞍结分岔。就本题而言，“最简”函数定义为一个关于参数 $r$ 最多是一次、关于状态变量 $x$ 最多是二次的多项式。给出 $f(x, r)$ 的显式形式。",
            "solution": "对于函数 $f(x, r)$，鞍结分岔在点 $(x_c, r_c)$ 处发生，需满足以下条件：\n1.  在临界参数值下，该点是一个不动点：$f(x_c, r_c) = 0$。\n2.  该不动点是非双曲的：$\\frac{\\partial f}{\\partial x}(x_c, r_c) = 0$。\n3.  参数变化会移动不动点分支：$\\frac{\\partial f}{\\partial r}(x_c, r_c) \\neq 0$。\n4.  曲率非零，这将其与叉式分岔等其他分岔区分开来：$\\frac{\\partial^2 f}{\\partial x^2}(x_c, r_c) \\neq 0$。\n\n题目指出，函数 $f(x, r)$ 关于 $r$ 最多是一次的，关于 $x$ 最多是二次的。此类多项式的最一般形式可以方便地通过围绕分岔点 $(x_c, r_c) = (5, 1)$ 中心化来表示：\n$$f(x, r) = c_0 + c_1(r - 1) + c_2(x - 5) + c_3(x - 5)^2 + c_4(r-1)(x-5)$$\n在最简范式中，$c_4(r-1)(x-5)$ 这一项通常被省略，因此我们设 $c_4=0$ 以寻求最简单的多项式。因此，我们的形式是：\n$$f(x, r) = c_0 + c_1(r - 1) + c_2(x - 5) + c_3(x - 5)^2$$\n\n现在，我们应用分岔条件来确定系数 $c_i$。\n\n**条件 1：** $f(5, 1) = 0$。\n将 $x=5$ 和 $r=1$ 代入我们 $f(x, r)$ 的表达式中：\n$$f(5, 1) = c_0 + c_1(1-1) + c_2(5-5) + c_3(5-5)^2 = c_0$$\n因此，我们必须有 $c_0 = 0$。\n\n**条件 2：** $\\frac{\\partial f}{\\partial x}(5, 1) = 0$。\n首先，我们计算 $f$ 关于 $x$ 的偏导数：\n$$\\frac{\\partial f}{\\partial x} = c_2 + 2c_3(x-5)$$\n在 $(x, r) = (5, 1)$ 处求值：\n$$\\frac{\\partial f}{\\partial x}(5, 1) = c_2 + 2c_3(5-5) = c_2$$\n因此，我们必须有 $c_2 = 0$。\n\n当 $c_0=0$ 和 $c_2=0$ 时，我们的函数简化为：\n$$f(x, r) = c_1(r - 1) + c_3(x - 5)^2$$\n\n**条件 3：** $\\frac{\\partial f}{\\partial r}(5, 1) \\neq 0$。\n我们计算 $f$ 关于 $r$ 的偏导数：\n$$\\frac{\\partial f}{\\partial r} = c_1$$\n这是一个常数。该条件要求 $c_1 \\neq 0$。\n\n**条件 4：** $\\frac{\\partial^2 f}{\\partial x^2}(5, 1) \\neq 0$。\n我们计算 $f$ 关于 $x$ 的二阶偏导数：\n$$\\frac{\\partial^2 f}{\\partial x^2} = 2c_3$$\n这也是一个常数。该条件要求 $2c_3 \\neq 0$，即 $c_3 \\neq 0$。\n\n所以我们需要一个形如 $f(x, r) = c_1(r - 1) + c_3(x - 5)^2$ 的函数，其中 $c_1 \\neq 0$ 且 $c_3 \\neq 0$。题目要求的是“最简单的非平凡”函数。这表明我们应该为系数选择最简单的非零整数值。鞍结分岔的典范式通常写作 $\\dot{x} = r - x^2$。为了匹配这种结构，我们可以选择 $c_1 = 1$ 和 $c_3 = -1$。这些是满足非零条件的最简单整数。\n\n通过这些选择，函数变为：\n$$f(x, r) = (1)(r - 1) + (-1)(x - 5)^2 = r - 1 - (x - 5)^2$$\n\n为了将其表示为标准多项式，我们展开平方项：\n$$f(x, r) = r - 1 - (x^2 - 10x + 25)$$\n$$f(x, r) = r - 1 - x^2 + 10x - 25$$\n$$f(x, r) = r - x^2 + 10x - 26$$\n\n该函数满足所有必需的条件，并符合题目说明中“最简”的定义。",
            "answer": "$$\\boxed{r - x^{2} + 10x - 26}$$"
        },
        {
            "introduction": "这个高级练习将我们带入一个与合成生物学直接相关的模型：一个具有希尔型（Hill-type）调控的系统，这在描述基因表达和蛋白质信号转导中非常普遍。这个问题  超越了简单的解析案例，进入了一个分岔点往往无法完全通过解析方法找到的情景。它要求您首先推导出现双稳态的参数条件，然后应用数值方法来精确定位鞍点分岔的确切位置，从而连接理论分析与计算实践的鸿沟。",
            "id": "3925940",
            "problem": "考虑一个标量动力系统，它代表了生物医学系统建模中的一个希尔型调控模型，由常微分方程(ODE) $\\dot{x} = \\mu - \\dfrac{\\alpha}{1 + x^{n}} - \\beta x$ 给出，其中 $x \\geq 0$ 表示一个无量纲的状态变量，$\\mu \\geq 0$ 是一个控制输入，被视为分岔参数，并且 $\\alpha > 0$、$\\beta > 0$ 和 $n \\geq 2$ 是固定常数。从平衡点 ($\\dot{x} = 0$)、由标量ODE中的雅可比矩阵 ($\\dfrac{d\\dot{x}}{dx}$) 决定的线性稳定性、以及当两个平衡点以零本征值和非零二阶导数合并时发生鞍节点分岔的定义出发，推导当 $\\mu$ 变化时，系统展现鞍节点分岔的参数区域条件。用状态 $x$ 和平衡点对被创造或湮灭时的参数值 $\\mu$ 来表示折叠（鞍节点）点。\n\n您的推导必须从一维自治系统的平衡和稳定性的第一性原理开始，并通过刻画函数 $\\dfrac{d\\dot{x}}{dx}$ 在 $x \\geq 0$ 上的极值来确定是否存在某个 $x$ 值，使得平衡条件和零斜率条件同时满足。具体来说，您必须：\n- 仅使用平衡条件 $\\dot{x} = 0$ 和导数条件 $\\dfrac{d\\dot{x}}{dx} = 0$作为基础，并结合在折叠点的非简并条件 $\\dfrac{d^{2}\\dot{x}}{dx^{2}} \\neq 0$ 和参数横截性条件 $\\dfrac{\\partial \\dot{x}}{\\partial \\mu} \\neq 0$。\n- 用 $n$ 来表示斜率函数 $\\dfrac{d\\dot{x}}{dx}$ 在 $x \\geq 0$ 上的全局最大值的位置和大小。\n- 从这个最大值中，获得一个关于 $\\alpha$ 和 $\\beta$ 的阈值条件（作为 $n$ 的函数），该条件决定了是否存在零斜率平衡点。展示当超过此阈值时，如何出现两个不同的折叠点；以及当恰好满足此阈值时，如何出现一个简并的单一折叠点。\n\n实现的算法任务：\n- 对于每组参数 $(n, \\alpha, \\beta)$，通过将 $\\alpha$ 与一个取决于 $x \\geq 0$ 上可達到的最大斜率的阈值进行比较，确定是否存在零斜率平衡点。\n- 如果存在两个折叠点，则通过联立求解 $x \\geq 0$ 上的 $\\dot{x} = 0$ 和 $\\dfrac{d\\dot{x}}{dx} = 0$ 来数值计算它们的近似位置 $x^{\\mathrm{fold}}$。您必须先解出 $\\dfrac{d\\dot{x}}{dx} = 0$ 得到 $x$，然后评估平衡条件以获得相应的参数值 $\\mu^{\\mathrm{fold}} = \\dfrac{\\alpha}{1 + (x^{\\mathrm{fold}})^{n}} + \\beta x^{\\mathrm{fold}}$。如果恰好存在一个简并折叠点，则通过识别斜率达到其最大值且满足 $\\dfrac{d\\dot{x}}{dx} = 0$ 的唯一一点来计算其位置，然后评估相同的平衡公式得到 $\\mu^{\\mathrm{fold}}$。如果不存在折叠点，则不返回任何位置。\n- 您的数值输出必须四舍五入到六位小数。\n\n测试套件：\n对以下四组参数进行评估，每组指定为 $(n,\\alpha,\\beta)$，其中 $n$ 无量纲，$\\alpha$ 无量綱，$\\beta$ 无量綱：\n- 情况 $1$：$(n, \\alpha, \\beta) = (4, 8.0, 1.0)$。\n- 情况 $2$ (边界情况)：$(n, \\alpha, \\beta) = (3, 1.0, 0.8399473665)$。\n- 情况 $3$：$(n, \\alpha, \\beta) = (2, 0.3, 0.5)$。\n- 情况 $4$：$(n, \\alpha, \\beta) = (6, 2.0, 1.2)$。\n\n答案规范与最终输出格式：\n对于每种情况，您的程序必须返回一个包含三项的列表：折叠点的整数计数 $k$ ($k \\in \\{0,1,2\\}$)、四舍五入到六位小数的折叠点状态值列表 $[x^{\\mathrm{fold}}]$（如果 $k = 0$ 则为空列表），以及四舍五入到六位小数的相应参数值列表 $[\\mu^{\\mathrm{fold}}]$（如果 $k = 0$ 则为空列表）。将四种情况的结果汇总到一行输出中，该输出包含一个由方括号括起来的逗号分隔列表，没有空格，例如 $[[k_{1},[x_{1}^{(1)},\\ldots],[\\mu_{1}^{(1)},\\ldots]],[k_{2},\\ldots],[k_{3},\\ldots],[k_{4},\\ldots]]$。",
            "solution": "对动力系统的分析始于确定鞍节点分岔的条件。\n\n**1. 平衡与稳定性**\n该系统由自治常微分方程描述：\n$$\n\\dot{x} = f(x, \\mu) = \\mu - \\frac{\\alpha}{1 + x^n} - \\beta x\n$$\n平衡点，或稳态 $x_s$，是 $\\dot{x} = 0$ 的解，这给出：\n$$\n\\mu = \\frac{\\alpha}{1 + x_s^n} + \\beta x_s\n$$\n该方程表明，平衡值 $x$ 在曲线 $y(x) = \\frac{\\alpha}{1 + x^n} + \\beta x$ 与水平线 $y = \\mu$ 的交点处找到。平衡点的数量取决于此曲线的形状。\n\n平衡点 $x_s$ 的线性稳定性由雅可比矩阵的符号决定，在此标量情况下，即为ODE右侧关于 $x$ 的导数，在 $x_s$ 处求值：\n$$\nJ(x_s) = \\left. \\frac{d\\dot{x}}{dx} \\right|_{x=x_s} = \\frac{\\alpha n x_s^{n-1}}{(1 + x_s^n)^2} - \\beta\n$$\n如果 $J(x_s) < 0$，平衡点是稳定的；如果 $J(x_s) > 0$，则是不稳定的。\n\n**2. 鞍节点分岔条件**\n当参数 $\\mu$ 变化时，两个平衡点（一个稳定，一个不稳定）合并并湮灭时，会发生鞍节点（或折叠）分岔。在分岔点，平衡条件 $\\dot{x} = 0$ 被满足，并且系统的线性化有一个零本征值，即 $J = 0$。因此，一个折叠点 $(x^{\\mathrm{fold}}, \\mu^{\\mathrm{fold}})$ 的条件是：\n1.  $\\mu^{\\mathrm{fold}} - \\dfrac{\\alpha}{1 + (x^{\\mathrm{fold}})^n} - \\beta x^{\\mathrm{fold}} = 0$\n2.  $\\dfrac{\\alpha n (x^{\\mathrm{fold}})^{n-1}}{(1 + (x^{\\mathrm{fold}})^n)^2} - \\beta = 0$\n\n**3. 零斜率条件分析**\n第二个条件为可能发生折叠的状态值 $x^{\\mathrm{fold}}$ 提供了一个方程。让我们分析这个方程：\n$$\n\\beta = \\frac{\\alpha n x^{n-1}}{(1 + x^n)^2}\n$$\n此方程是否存在实数正解 $x$ 取决于 $\\beta$ 的值相对于右侧函数的值域。让我们将此函数定义为：\n$$\nh(x; n, \\alpha) = \\frac{\\alpha n x^{n-1}}{(1 + x^n)^2}\n$$\n我们需要找到 $h(x)$ 在 $x \\ge 0$ 上的最大值。由于 $n \\ge 2$，$h(0) = 0$。对于大的 $x$，$h(x) \\approx \\frac{\\alpha n x^{n-1}}{x^{2n}} = \\frac{\\alpha n}{x^{n+1}} \\to 0$。由于 $h(x)$ 在 $x>0$ 时连续且为正，它必须达到一个全局最大值。我们通过将其导数设为零来找到它，$h'(x) = 0$。\n导数是：\n$$\nh'(x) = \\alpha n \\frac{d}{dx} \\left( \\frac{x^{n-1}}{(1+x^n)^2} \\right) = \\alpha n \\frac{(n-1)x^{n-2}(1+x^n)^2 - x^{n-1} \\cdot 2(1+x^n) \\cdot nx^{n-1}}{(1+x^n)^4}\n$$\n对 $x>0$ 设 $h'(x) = 0$ 要求分子为零：\n$$\n(n-1)x^{n-2}(1+x^n) - 2nx^{2n-2} = 0\n$$\n$$\nx^{n-2} \\left( (n-1)(1+x^n) - 2nx^n \\right) = 0\n$$\n这给出 $(n-1) + (n-1)x^n - 2nx^n = 0$，简化为 $(n-1) - (n+1)x^n = 0$。因此，$h(x)$ 的最大值位置为：\n$$\nx_{\\text{max}} = \\left( \\frac{n-1}{n+1} \\right)^{1/n}\n$$\n$h(x)$ 的最大值，我们定义为 $\\beta$ 的临界阈值，是 $\\beta_{\\text{crit}} = h(x_{\\text{max}})$。令 $x_{\\text{max}}^n = \\frac{n-1}{n+1}$：\n$$\n\\beta_{\\text{crit}} = \\frac{\\alpha n (x_{\\text{max}})^{n-1}}{(1 + x_{\\text{max}}^n)^2} = \\frac{\\alpha n \\left(\\frac{n-1}{n+1}\\right)^{(n-1)/n}}{\\left(1 + \\frac{n-1}{n+1}\\right)^2} = \\frac{\\alpha n \\left(\\frac{n-1}{n+1}\\right)^{(n-1)/n}}{\\left(\\frac{2n}{n+1}\\right)^2}\n$$\n$$\n\\beta_{\\text{crit}} = \\alpha \\frac{n(n+1)^2}{4n^2} \\frac{(n-1)^{(n-1)/n}}{(n+1)^{(n-1)/n}} = \\alpha \\frac{(n-1)^{(n-1)/n}(n+1)^{(n+1)/n}}{4n}\n$$\n\n**4. 折叠点的参数区域条件**\n现在我们可以通过比较 $\\beta$ 和 $\\beta_{\\text{crit}}$ 来建立折叠点存在的条件：\n- 如果 $\\beta > \\beta_{\\text{crit}}$：直线 $y=\\beta$ 在 $h(x)$ 的最大值之上，因此 $\\beta = h(x)$ 没有解。不存在折叠点。系统对所有 $\\mu$ 都是单稳态的。\n- 如果 $\\beta = \\beta_{\\text{crit}}$：直线 $y=\\beta$ 与 $h(x)$ 的峰值相切。在 $x = x_{\\text{max}}$ 处只有一个解。这对应于一个单一的、简并的折叠点（在 $(x, \\mu, \\beta)$ 空间中的一个尖点分岔）。\n- 如果 $0 < \\beta < \\beta_{\\text{crit}}$：直线 $y=\\beta$ 与曲线 $h(x)$ 在两个不同的点相交，一个 $x_1^{\\mathrm{fold}} < x_{\\text{max}}$ 和一个 $x_2^{\\mathrm{fold}} > x_{\\text{max}}$。这产生了两个折叠点。在 $\\mu_1^{\\mathrm{fold}}$ 和 $\\mu_2^{\\mathrm{fold}}$ 之间的 $\\mu$ 区域对应于双稳态（三个平衡点）。\n\n非简并条件 $\\frac{d^2\\dot{x}}{dx^2} \\neq 0$ 等价于 $h'(x) \\neq 0$，这在折叠点处成立，除非 $\\beta = \\beta_{\\text{crit}}$。横截性条件 $\\frac{\\partial \\dot{x}}{\\partial \\mu} = 1 \\neq 0$ 总是满足的。\n\n**5. 算法实现**\n根据上述推导，算法实现步骤如下：\n1.  对于每组参数 $(n, \\alpha, \\beta)$，计算 $x_{\\text{max}} = \\left( \\frac{n-1}{n+1} \\right)^{1/n}$。\n2.  计算临界阈值 $\\beta_{\\text{crit}} = \\frac{\\alpha n (x_{\\text{max}})^{n-1}}{(1 + (x_{\\text{max}}^n)^2}$。\n3.  比较 $\\beta$ 与 $\\beta_{\\text{crit}}$ 以确定折叠点的数量 $k$。\n4.  如果 $k=0$ ($\\beta > \\beta_{\\text{crit}}$)，则不存在折叠点。\n5.  如果 $k=1$ ($\\beta \\approx \\beta_{\\text{crit}}$)，唯一的折叠点在 $x^{\\mathrm{fold}} = x_{\\text{max}}$。\n6.  如果 $k=2$ ($\\beta < \\beta_{\\text{crit}}$)，需要数值求解方程 $h(x) - \\beta = 0$ 的两个根 $x_1^{\\mathrm{fold}}$ 和 $x_2^{\\mathrm{fold}}$。这可以在区间 $(0, x_{\\text{max}})$ 和 $(x_{\\text{max}}, \\infty)$ 中使用求根算法来完成。\n7.  对于找到的每个 $x^{\\mathrm{fold}}$，计算相应的分岔参数值 $\\mu^{\\mathrm{fold}} = \\frac{\\alpha}{1 + (x^{\\mathrm{fold}})^n} + \\beta x^{\\mathrm{fold}}$。\n8.  收集并按题目要求格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Analyzes a Hill-type regulation model for saddle-node bifurcations.\n\n    For each parameter set (n, alpha, beta), the function determines the number\n    of fold points (k) and calculates their locations in state (x_fold) and\n    parameter space (mu_fold).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 8.0, 1.0),            # Case 1: Two fold points\n        (3, 1.0, 0.8399473665),  # Case 2: Boundary case (one degenerate fold point)\n        (2, 0.3, 0.5),            # Case 3: No fold points\n        (6, 2.0, 1.2),            # Case 4: Two fold points\n    ]\n\n    results = []\n    \n    for n, alpha, beta in test_cases:\n        # Constraint from the problem statement n >= 2\n        if n < 2:\n            results.append([0, [], []])\n            continue\n            \n        # 1. Calculate the location of the maximum of the slope-related function h(x)\n        x_max = ((n - 1) / (n + 1))**(1 / n)\n\n        # 2. Calculate the critical threshold beta_crit\n        # beta_crit = h(x_max), where h(x) = alpha * n * x^(n-1) / (1 + x^n)^2\n        h_at_xmax = (alpha * n * x_max**(n - 1)) / (1 + x_max**n)**2\n        beta_crit = h_at_xmax\n\n        # 3. Compare beta with beta_crit to determine the number of fold points k.\n        # Use np.isclose for robust floating-point comparison.\n        if np.isclose(beta, beta_crit):\n            k = 1\n        elif beta > beta_crit:\n            k = 0\n        else: # beta < beta_crit\n            k = 2\n\n        x_folds = []\n        mu_folds = []\n\n        if k == 0:\n            # No fold points\n            pass\n        elif k == 1:\n            # One degenerate fold point at x_max\n            x_fold = x_max\n            mu_fold = alpha / (1 + x_fold**n) + beta * x_fold\n            x_folds.append(x_fold)\n            mu_folds.append(mu_fold)\n        elif k == 2:\n            # Two fold points. Need to find two roots of h(x) - beta = 0.\n            # Define the function whose roots we are seeking.\n            def func_to_solve(x, n_val, alpha_val, beta_val):\n                if x < 0:\n                    return np.nan  # Function is defined for x >= 0\n                return (alpha_val * n_val * x**(n_val - 1)) / (1 + x**n_val)**2 - beta_val\n\n            # Find the first root in the interval (0, x_max)\n            sol1 = root_scalar(func_to_solve, args=(n, alpha, beta), bracket=(1e-9, x_max), method='brentq')\n            x_fold1 = sol1.root\n\n            # Find the second root in the interval (x_max, infinity)\n            # Find a safe upper bound U for the search bracket, where h(U) < beta.\n            # h(U) ~ alpha*n/U^(n+1) for large U. We need alpha*n/U^(n+1) < beta.\n            # U > (alpha*n/beta)^(1/(n+1))\n            upper_bound = ((alpha * n) / beta)**(1 / (n + 1)) + 1\n            sol2 = root_scalar(func_to_solve, args=(n, alpha, beta), bracket=(x_max, upper_bound), method='brentq')\n            x_fold2 = sol2.root\n            \n            # Order the folds by x-value\n            x_folds = sorted([x_fold1, x_fold2])\n\n            for x_f in x_folds:\n                mu_f = alpha / (1 + x_f**n) + beta * x_f\n                mu_folds.append(mu_f)\n                \n        # Round results to six decimal places as required.\n        x_folds_rounded = [round(x, 6) for x in x_folds]\n        mu_folds_rounded = [round(mu, 6) for mu in mu_folds]\n\n        results.append([k, x_folds_rounded, mu_folds_rounded])\n\n    # Final print statement must produce the exact format.\n    # The default str() representation of lists matches the required format.\n    print(f\"[[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}