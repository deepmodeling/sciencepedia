{
    "hands_on_practices": [
        {
            "introduction": "掌握任何一种分岔的第一步都是彻底理解其范式。本练习  将引导你分析跨临界分岔最基本的形式，$\\dot{x} = rx - x^2$。通过确定不动点并分析其随参数 $r$ 变化的稳定性，你将亲手揭示两个不动点分支如何碰撞并交换其稳定性的核心机制。",
            "id": "1724873",
            "problem": "考虑由以下微分方程描述的一维动力系统：\n$$ \\frac{dx}{dt} = rx - x^2 $$\n这里，$x = x(t)$ 代表系统的状态变量，$r$ 是一个实值控制参数。该方程是一种常见分岔类型的范式，可以模拟单个参数同时影响增长和饱和效应的现象。\n\n您的任务是分析该系统的不动点（也称为平衡点）及其线性稳定性，因为参数 $r$ 在实数范围内变化。根据您的分析，下列哪个陈述最准确地描述了系统的行为？\n\nA. 对于 $r  0$，系统在 $x=0$ 处有一个稳定的不动点。对于 $r > 0$，这个不动点变得不稳定，并在 $x=0$ 周围对称地出现两个新的稳定不动点。\n\nB. 对于 $r  0$，系统没有实不动点。在 $r=0$ 时，出现一个不动点，然后在 $r > 0$ 时分裂成一个稳定和一个不稳定的不动点。\n\nC. 对于所有非零的 $r$，系统有两个不动点。对于 $r  0$，位于 $x=0$ 的不动点是不稳定的，而位于 $x=r$ 的不动点是稳定的。对于 $r > 0$，这种稳定性模式颠倒过来。\n\nD. 对于所有非零的 $r$，系统有两个不动点。对于 $r  0$，位于 $x=0$ 的不动点是稳定的，而位于 $x=r$ 的不动点是不稳定的。对于 $r > 0$，这种稳定性模式颠倒过来。\n\nE. 对于所有非零的 $r$ 值，系统总是在 $x=r$ 处有一个稳定的不动点，在 $x=0$ 处有一个不稳定的不动点。",
            "solution": "为了确定对系统行为的正确描述，我们需要找到不动点并分析其稳定性作为参数 $r$ 的函数。该动力系统由 $\\dot{x} = f(x, r)$ 给出，其中 $f(x, r) = rx - x^2$。\n\n**第 1 步：求不动点**\n\n不动点，记为 $x^*$，是使系统处于平衡状态的 $x$ 值，即 $\\dot{x} = 0$。\n我们将给定的微分方程设为零：\n$$ rx^* - (x^*)^2 = 0 $$\n对表达式进行因式分解，我们得到：\n$$ x^*(r - x^*) = 0 $$\n该方程产生两个不动点的解：\n1.  $x_1^* = 0$\n2.  $x_2^* = r$\n\n这两个不动点对任何实数值 $r$ 都存在。注意，当 $r=0$ 时，两个不动点重合，$x_1^* = x_2^* = 0$。对于任何 $r \\ne 0$，存在两个不同的不动点。\n\n**第 2 步：分析不动点的稳定性**\n\n对于一维系统 $\\dot{x} = f(x)$，不动点 $x^*$ 的线性稳定性由导数 $f'(x) = \\frac{df}{dx}$ 在该不动点处的值的符号决定。\n- 如果 $f'(x^*)  0$，该不动点是线性稳定的。\n- 如果 $f'(x^*) > 0$，该不动点是线性不稳定的。\n- 如果 $f'(x^*) = 0$，线性稳定性分析无法得出结论，需要进行高阶分析。这一点通常对应于一个分岔。\n\n首先，我们计算 $f(x, r) = rx - x^2$ 关于 $x$ 的导数：\n$$ f'(x, r) = \\frac{d}{dx}(rx - x^2) = r - 2x $$\n\n现在，我们在每个不动点处计算这个导数的值。\n\n**不动点 $x_1^* = 0$ 的稳定性：**\n我们将 $x=0$ 代入 $f'(x, r)$ 的表达式中：\n$$ f'(0, r) = r - 2(0) = r $$\n$x_1^*=0$ 的稳定性直接取决于 $r$ 的符号：\n- 如果 $r  0$，则 $f'(0, r)  0$，这意味着不动点 $x_1^*=0$ 是**稳定的**。\n- 如果 $r > 0$，则 $f'(0, r) > 0$，这意味着不动点 $x_1^*=0$ 是**不稳定的**。\n- 如果 $r = 0$，则 $f'(0, 0) = 0$，这是分岔点。\n\n**不动点 $x_2^* = r$ 的稳定性：**\n我们将 $x=r$ 代入 $f'(x, r)$ 的表达式中：\n$$ f'(r, r) = r - 2(r) = -r $$\n$x_2^*=r$ 的稳定性取决于 $-r$ 的符号：\n- 如果 $r  0$，则 $-r > 0$，所以 $f'(r, r) > 0$。这意味着不动点 $x_2^*=r$ 是**不稳定的**。\n- 如果 $r > 0$，则 $-r  0$，所以 $f'(r, r)  0$。这意味着不动点 $x_2^*=r$ 是**稳定的**。\n- 如果 $r = 0$，则 $f'(0, 0) = 0$，这是分岔点，此时 $x_2^* = x_1^*$。\n\n**第 3 步：总结结果并选择正确选项**\n\n让我们汇总我们的发现：\n- **对于 $r  0$：** 我们有两个不动点。$x_1^* = 0$ 是稳定的，而 $x_2^* = r$ 是不稳定的。\n- **对于 $r = 0$：** 我们在 $x^*=0$ 处有一个不动点。这是两个不动点相遇的分岔点。\n- **对于 $r > 0$：** 我们有两个不动点。$x_1^* = 0$ 现在是不稳定的，而 $x_2^* = r$ 现在是稳定的。\n\n在分岔点 $r=0$ 处，两个不动点 $x_1^*$ 和 $x_2^*$ 碰撞并交换它们的稳定性。这是跨临界分岔的定义。\n\n现在让我们评估给出的选项：\n- A. 描述的是超临界叉式分岔，这是不正确的。\n- B. 描述的是鞍结分岔，这是不正确的，因为当 $r0$ 时我们有两个不动点。\n- C. 该选项陈述对于 $r0$，$x=0$ 是不稳定的而 $x=r$ 是稳定的。这与我们的发现相反。\n- D. 该选项陈述对于 $r0$，$x=0$ 是稳定的而 $x=r$ 是不稳定的。对于 $r>0$，它陈述 $x=0$ 变得不稳定而 $x=r$ 变得稳定。这与我们的分析完全匹配。\n- E. 该选项声称对于所有 $r$ 都有固定的稳定性角色，这是不正确的，因为稳定性在 $r=0$ 处发生变化。\n\n因此，正确的陈述是 D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "真正理解一个概念不仅在于知道它是什么，还在于知道它不是什么。这个练习  提供了一个表面上相似但本质不同的系统，$\\dot{x} = \\mu x - x^3$，并挑战你识别出它不满足跨临界分岔的精确数学条件。这项实践将深化你对分岔分类背后严格要求的理解，避免在模型分析中出现混淆。",
            "id": "1724860",
            "problem": "考虑一个一维动力系统，由微分方程 $\\dot{x} = f(x, \\mu)$ 定义，其中 $x(t)$ 是状态变量，$\\mu$ 是一个实值参数。系统的一个不动点 $x^*$ 满足 $f(x^*, \\mu) = 0$。当参数 $\\mu$ 穿过某个值 $\\mu_c$ 时，如果系统的定性行为（例如其不动点的数量或稳定性）发生改变，则在参数值 $\\mu_c$ 处发生分岔。\n\n在原点 $(x^*, \\mu_c) = (0, 0)$ 处发生的跨临界分岔的范式由 $\\dot{x} = \\mu x - x^2$ 给出。对于一个通用系统 $\\dot{x} = f(x, \\mu)$，若要在点 $(x^*, \\mu_c)$ 处发生跨临界分岔，则函数 $f(x, \\mu)$ 在该点的偏导数必须满足某些条件。\n\n现在，考虑由以下方程给出的特定系统：\n$$ \\dot{x} = \\mu x - x^3 $$\n可以验证，$x^* = 0$ 对所有 $\\mu$ 值都是一个不动点，并且涉及该不动点的分岔发生在临界参数值 $\\mu_c = 0$ 处。然而，这个分岔不是跨临界分岔。\n\n以下哪个陈述为系统 $\\dot{x} = \\mu x - x^3$ 在 $(x^*, \\mu_c)=(0,0)$ 处的分岔不是跨临界分岔提供了精确的数学原因？设 $f(x, \\mu) = \\mu x - x^3$。\n\nA. 不动点 $x^*=0$ 并非对所有 $\\mu$ 值都存在。\n\nB. 当 $\\mu$ 穿过 $\\mu_c=0$ 时，不动点 $x^*=0$ 的稳定性不发生改变。\n\nC. 偏导数 $\\frac{\\partial f}{\\partial \\mu}$ 在 $(0,0)$ 处的值非零。\n\nD. 二阶偏导数 $\\frac{\\partial^2 f}{\\partial x^2}$ 在 $(0,0)$ 处的值为零。\n\nE. 偏导数 $\\frac{\\partial^2 f}{\\partial x \\partial \\mu}$ 在 $(0,0)$ 处的值为零。",
            "solution": "我们寻求对于系统 $\\dot{x}=f(x,\\mu)=\\mu x - x^3$，在 $(x^{*},\\mu_{c})=(0,0)$ 处跨临界分岔未能满足的精确条件。\n\n对于一维系统 $\\dot{x}=f(x,\\mu)$ 在 $(0,0)$ 处的跨临界分岔，标准的非退化性和横截性条件要求：\n1) $f(0,0)=0$,\n2) $f_{x}(0,0)=0$,\n3) $f_{xx}(0,0)\\neq 0$,\n4) $f_{x\\mu}(0,0)\\neq 0$,\n以及（在许多标准表述中）$f_{\\mu}(0,0)=0$，以便不动点处的主导参数依赖性由混合导数所体现。\n\n计算 $f(x,\\mu)=\\mu x - x^3$ 的必要导数：\n- 在候选分岔点的值：\n$$\nf(0,0)=\\mu\\cdot 0 - 0^3=0.\n$$\n- 关于 $x$ 的一阶导数：\n$$\nf_{x}(x,\\mu)=\\frac{\\partial}{\\partial x}(\\mu x - x^3)=\\mu - 3x^{2},\\quad f_{x}(0,0)=0.\n$$\n- 关于 $x$ 的二阶导数：\n$$\nf_{xx}(x,\\mu)=\\frac{\\partial^{2}}{\\partial x^{2}}(\\mu x - x^3)=-6x,\\quad f_{xx}(0,0)=0.\n$$\n- 混合导数：\n$$\nf_{x\\mu}(x,\\mu)=\\frac{\\partial}{\\partial\\mu}(\\mu - 3x^{2})=1,\\quad f_{x\\mu}(0,0)=1\\neq 0.\n$$\n- 关于 $\\mu$ 的一阶导数：\n$$\nf_{\\mu}(x,\\mu)=\\frac{\\partial}{\\partial\\mu}(\\mu x - x^3)=x,\\quad f_{\\mu}(0,0)=0.\n$$\n\n因此，在 $(0,0)$ 处，条件 $f(0,0)=0$、$f_{x}(0,0)=0$、$f_{x\\mu}(0,0)\\neq 0$ 和 $f_{\\mu}(0,0)=0$ 均得到满足。然而，跨临界分岔的关键非退化性条件 $f_{xx}(0,0)\\neq 0$ 未被满足，因为 $f_{xx}(0,0)=0$。因此，该分岔不是跨临界分岔的精确数学原因是，关于 $x$ 的二阶偏导数在 $(0,0)$ 处为零。\n\n在给出的选项中，这与陈述 D 完全对应。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "在合成生物学建模的实践中，我们很少能处理简单的解析模型。本练习  将理论与计算实践相结合，要求你设计一种数值方法，从模拟数据中检验跨临界分岔的非简并性条件。这个高级练习旨在培养你作为建模者的核心技能：即在面对“黑箱”系统时，能够从数据中提取其动态行为的关键特征。",
            "id": "3939176",
            "problem": "考虑一个一维常微分方程，该方程模拟了一个均匀混合隔间中的稳态细胞密度。其中，状态 $x$ 表示无量纲的细胞密度，参数 $\\mu$ 表示净增殖驱动，二次饱和项源于接触抑制。其动力学由初值问题 $\\frac{dx}{dt} = f(x,\\mu;k)$ 给出，其中函数 $f$ 在 $(x,\\mu)=(0,0)$ 的邻域内是光滑的，并以模拟形式通过一个小的时步增量 $\\Delta t$ 的显式欧拉步长来指定：从 $x(0)=x_0$ 开始，生成 $x(\\Delta t)=x_0 + \\Delta t\\, f(x_0,\\mu;k)$。假设 $k$ 是一个非负实数参数，表示自限制的强度。\n\n在生物医学系统建模中，当两个平衡分支相交并交换稳定性时，会发生跨临界分岔。在 $(x,\\mu)=(0,0)$ 处，一般跨临界分岔的非简并条件要求 $f_{x\\mu}(0,0)\\neq 0$ 和 $f_{xx}(0,0)\\neq 0$，其中下标表示偏导数。你的任务是开发一种数值方法，该方法仅利用上述显式欧拉步长模拟的短时数据，来估计 $f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$，然后使用这些估计值来检验跨临界非简并条件。\n\n从微积分和动力系统的核心定义出发，实现一个算法，该算法：\n- 通过从 $x(0)=x$ 开始模拟一个大小为 $\\Delta t$ 的显式欧拉步，并计算有限差分 $(x(\\Delta t)-x)/\\Delta t$，来估计在指定 $(x,\\mu)$ 处的右侧函数 $f(x,\\mu;k)$。\n- 使用围绕 $(x,\\mu)=(0,0)$ 的小的对称微扰 $h_x$ 和 $h_\\mu$ 进行有限差分，根据在微扰点处估计的 $f(x,\\mu;k)$ 值，数值近似计算 $f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$。\n- 如果对于指定的容差 $\\epsilon>0$，同时满足 $|f_{x\\mu}(0,0)|>\\epsilon$ 和 $|f_{xx}(0,0)|>\\epsilon$，则宣布跨临界非简并性检验通过。\n\n使用以下参数集测试套件 $(k,h_x,h_\\mu,\\Delta t,\\epsilon)$:\n- 情况 1：$k=1.0$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n- 情况 2：$k=0.0$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n- 情况 3：$k=2.5$, $h_x=5\\times 10^{-5}$, $h_\\mu=2\\times 10^{-4}$, $\\Delta t=5\\times 10^{-7}$, $\\epsilon=10^{-6}$。\n- 情况 4：$k=10^{-12}$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n\n假设生物医学模拟器的底层函数 $f$ 与接触限制增殖模型一致，具体来说，在原点邻域内 $f(x,\\mu;k)=\\mu x - k x^2$，但你绝不能使用此闭合形式来计算导数；你必须如上所述，从模拟数据中估计 $f$。\n\n对于每个测试用例，你的程序必须生成一个包含三个值的列表：$f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$ 的数值估计（浮点数），以及一个布尔值，该布尔值指示在容差 $\\epsilon$ 下跨临界非简по性测试是否满足。将所有测试用例的结果汇总到一行输出中，该输出包含一个用方括号括起来的逗号分隔列表，例如，`[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]`，其中每个 $a_i$ 和 $b_i$ 是浮点数，每个 $c_i$ 是布尔值。输出不需要物理单位，且不涉及角度。最终输出格式必须严格为指定的单行格式。",
            "solution": "该问题要求对由常微分方程 $\\frac{dx}{dt} = f(x,\\mu;k)$ 描述的动力学系统，在原点 $(x, \\mu) = (0, 0)$ 处的跨临界分岔的非简并条件进行数值验证。非简并条件由 $f_{x\\mu}(0,0) \\neq 0$ 和 $f_{xx}(0,0) \\neq 0$ 给出，其中下标表示偏导数。函数 $f$ 本身没有以闭合形式给出以供分析；相反，必须通过模拟的显式欧拉步来估计它。\n\n算法方法包括三个主要阶段：首先，为函数 $f(x, \\mu; k)$ 定义一个数值估计器；其次，在该估计器中使用有限差分公式来近似偏导数 $f_{xx}(0,0)$ 和 $f_{x\\mu}(0,0)$；第三，对这些估计导数的绝对值应用一个容差 $\\epsilon$ 来检验非简并条件。\n\n第一阶段是估计函数 $f(x,\\mu;k)$。问题通过一个执行单次显式欧拉步的模拟器来提供对系统动力学的访问。对于初始条件 $x(0) = x_0$，在时间 $\\Delta t$ 时的状态由以下公式给出：\n$$ x(\\Delta t) = x_0 + \\Delta t \\cdot f(x_0, \\mu; k) $$\n通过代数重排这个方程，我们可以为在点 $(x_0, \\mu)$ 处的函数 $f$ 构建一个估计器：\n$$ \\hat{f}(x_0, \\mu; k) = \\frac{x(\\Delta t) - x_0}{\\Delta t} $$\n问题指明，模拟器使用的底层动力学遵循模型 $f(x,\\mu;k) = \\mu x - k x^2$。虽然我们的算法不能使用这个解析形式来计算导数，但我们必须用它来定义模拟器。将其代入欧拉步中，得到：\n$$ x(\\Delta t) = x_0 + \\Delta t (\\mu x_0 - k x_0^2) $$\n这个函数代表了我们用以估计 $f$ 的模拟预言机。\n\n第二阶段是偏导数的数值近似。我们采用中心有限差分公式来估计在分岔点 $(x, \\mu) = (0, 0)$ 处的二阶和混合偏导数，使用小的对称微扰 $h_x$ 和 $h_\\mu$。$f_{xx}(0,0)$ 的近似使用三点中心差分公式：\n$$ f_{xx}(0,0) \\approx \\frac{\\hat{f}(h_x, 0; k) - 2\\hat{f}(0, 0; k) + \\hat{f}(-h_x, 0; k)}{h_x^2} $$\n所需的函数值通过我们的估计器 $\\hat{f}$ 获得：$\\hat{f}(h_x, 0; k)$ 是通过从 $x(0) = h_x$ 且 $\\mu=0$ 进行模拟来计算的；$\\hat{f}(0, 0; k)$ 是从 $x(0) = 0$ 且 $\\mu=0$ 计算的；而 $\\hat{f}(-h_x, 0; k)$ 是从 $x(0) = -h_x$ 且 $\\mu=0$ 计算的。$f_{x\\mu}(0,0)$ 的近似使用四点中心差分公式：\n$$ f_{x\\mu}(0,0) \\approx \\frac{\\hat{f}(h_x, h_\\mu; k) - \\hat{f}(h_x, -h_\\mu; k) - \\hat{f}(-h_x, h_\\mu; k) + \\hat{f}(-h_x, -h_\\mu; k)}{4 h_x h_\\mu} $$\n这需要在 $(x, \\mu)$ 平面中以原点为中心的一个小矩形的四个角点上，对我们的函数估计器 $\\hat{f}$ 进行四次评估。例如，$\\hat{f}(h_x, h_\\mu; k)$ 是通过从初始条件 $x(0) = h_x$ 和参数值 $\\mu = h_\\mu$ 进行模拟来计算的。\n\n第三个也是最后一个阶段是非简并性检验。利用导数的数值估计值，表示为 $\\hat{f}_{xx}(0,0)$ 和 $\\hat{f}_{x\\mu}(0,0)$，根据给定的正容差 $\\epsilon$ 来检验非简并条件。当且仅当以下两个不等式都成立时，检验被宣布为满足：\n$$ |\\hat{f}_{xx}(0,0)| > \\epsilon \\quad \\text{和} \\quad |\\hat{f}_{x\\mu}(0,0)| > \\epsilon $$\n然后将此过程应用于每个提供的测试用例。对于给定的底层函数 $f(x, \\mu; k) = \\mu x - k x^2$，真实导数为 $f_{xx}(0,0) = -2k$ 和 $f_{x\\mu}(0,0) = 1$。我们的数值估计应该非常接近这些解析值，因为有限差分公式对于低次多项式是精确的。非简并性检验实际上变成了一个检查，即 $|-2k| > \\epsilon$ 和 $|1| > \\epsilon$ 是否成立。鉴于 $\\epsilon$ 很小（例如 $10^{-6}$），第二个条件实际上总是满足的，检验的关键在于参数 $k$ 的量级是否足够大。",
            "answer": "```python\nimport numpy as np\n\ndef _hidden_simulator_step(x0, mu, k, dt):\n    \"\"\"\n    This function represents the \"black box\" biomedical simulator.\n    It computes x(t+dt) from x(t) using one explicit Euler step.\n    The problem specifies the underlying ODE is dx/dt = mu*x - k*x**2.\n    The algorithm must treat this as an oracle and not use its internal formula\n    to compute analytical derivatives.\n    \"\"\"\n    f_val = mu * x0 - k * x0**2\n    return x0 + dt * f_val\n\ndef estimate_f(x0, mu, k, dt):\n    \"\"\"\n    Estimates f(x0, mu; k) by simulating one explicit Euler step of size dt\n    from x(0)=x0 and computing the finite difference (x(dt)-x0)/dt,\n    as required by the problem statement.\n    \"\"\"\n    x_at_dt = _hidden_simulator_step(x0, mu, k, dt)\n    f_estimate = (x_at_dt - x0) / dt\n    return f_estimate\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Test suite of parameter sets (k, h_x, h_mu, dt, epsilon)\n    test_cases = [\n        # Case 1: k=1.0, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (1.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        # Case 2: k=0.0, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (0.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        # Case 3: k=2.5, h_x=5x10^-5, h_mu=2x10^-4, dt=5x10^-7, epsilon=10^-6\n        (2.5, 5e-5, 2e-4, 5e-7, 1e-6),\n        # Case 4: k=10^-12, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (1e-12, 1e-4, 1e-4, 1e-6, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h_x, h_mu, dt, epsilon = case\n\n        # Estimate f_xx(0,0) using a central difference formula.\n        # This requires three calls to the f-estimator.\n        f_plus_x = estimate_f(h_x, 0.0, k, dt)\n        f_zero = estimate_f(0.0, 0.0, k, dt)\n        f_minus_x = estimate_f(-h_x, 0.0, k, dt)\n        est_f_xx = (f_plus_x - 2.0 * f_zero + f_minus_x) / (h_x**2)\n\n        # Estimate f_xmu(0,0) using a central difference formula.\n        # This requires four calls to the f-estimator.\n        f_pp = estimate_f(h_x, h_mu, k, dt)   # Point (+h_x, +h_mu)\n        f_pm = estimate_f(h_x, -h_mu, k, dt)  # Point (+h_x, -h_mu)\n        f_mp = estimate_f(-h_x, h_mu, k, dt)  # Point (-h_x, +h_mu)\n        f_mm = estimate_f(-h_x, -h_mu, k, dt) # Point (-h_x, -h_mu)\n        est_f_xmu = (f_pp - f_pm - f_mp + f_mm) / (4.0 * h_x * h_mu)\n\n        # Perform the transcritical nondegeneracy test.\n        is_nondegenerate = abs(est_f_xmu) > epsilon and abs(est_f_xx) > epsilon\n\n        results.append([est_f_xmu, est_f_xx, is_nondegenerate])\n\n    # Format the final output string exactly as specified: [[...],[...],...]\n    # Using str() on a list of lists creates the required formatting.\n    # Capitalized True/False from Python's str() is the standard representation.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}