{
    "hands_on_practices": [
        {
            "introduction": "The stoichiometric matrix, denoted as $S$, is the mathematical heart of a metabolic network model. It systematically encodes the relationships between metabolites and reactions. This first exercise will solidify your understanding of how to translate a simple set of biochemical reactions into this fundamental matrix representation, a skill that is the starting point for any form of stoichiometric modeling .",
            "id": "1445692",
            "problem": "In systems biology, metabolic networks are often represented mathematically to analyze their properties. Consider a simplified, hypothetical linear metabolic pathway within a cell. This pathway is responsible for converting an external nutrient, A, into a valuable product, D, via two intermediate compounds, B and C. The entire process is described by the following three irreversible biochemical reactions, denoted R1, R2, and R3:\n\nReaction R1: $A \\rightarrow B$\nReaction R2: $2B \\rightarrow C$\nReaction R3: $C \\rightarrow D$\n\nYour task is to construct the stoichiometric matrix, $S$, for this metabolic network. The matrix must be organized such that its rows correspond to the metabolites in the order $A, B, C, D$, and its columns correspond to the reactions in the order $R1, R2, R3$. Follow the standard convention where the stoichiometric coefficient for a consumed metabolite (a reactant) is negative, and for a produced metabolite (a product) is positive.",
            "solution": "We define the stoichiometric matrix $S$ such that $S_{i,j}$ is the stoichiometric coefficient of metabolite $i$ in reaction $j$, with negative values for consumed reactants and positive values for produced products. The rows are ordered as $A$, $B$, $C$, $D$, and the columns as $\\text{R1}$, $\\text{R2}$, $\\text{R3}$.\n\nFor reaction $\\text{R1}$, which converts $A$ to $B$, one unit of $A$ is consumed and one unit of $B$ is produced:\n$$\nS_{\\mathrm{A},\\mathrm{R1}}=-1,\\quad S_{\\mathrm{B},\\mathrm{R1}}=1,\\quad S_{\\mathrm{C},\\mathrm{R1}}=0,\\quad S_{\\mathrm{D},\\mathrm{R1}}=0.\n$$\n\nFor reaction $\\text{R2}$, which converts $2B$ to $C$, two units of $B$ are consumed and one unit of $C$ is produced:\n$$\nS_{\\mathrm{A},\\mathrm{R2}}=0,\\quad S_{\\mathrm{B},\\mathrm{R2}}=-2,\\quad S_{\\mathrm{C},\\mathrm{R2}}=1,\\quad S_{\\mathrm{D},\\mathrm{R2}}=0.\n$$\n\nFor reaction $\\text{R3}$, which converts $C$ to $D$, one unit of $C$ is consumed and one unit of $D$ is produced:\n$$\nS_{\\mathrm{A},\\mathrm{R3}}=0,\\quad S_{\\mathrm{B},\\mathrm{R3}}=0,\\quad S_{\\mathrm{C},\\mathrm{R3}}=-1,\\quad S_{\\mathrm{D},\\mathrm{R3}}=1.\n$$\n\nAssembling these entries with rows $(A,B,C,D)$ and columns $(\\text{R1},\\text{R2},\\text{R3})$ gives\n$$\nS=\\begin{pmatrix}\n-1  0  0 \\\\\n1  -2  0 \\\\\n0  1  -1 \\\\\n0  0  1\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-1  0  0 \\\\ 1  -2  0 \\\\ 0  1  -1 \\\\ 0  0  1\\end{pmatrix}}$$"
        },
        {
            "introduction": "To simulate biological objectives like growth, metabolic models require a \"biomass objective function\"—a special pseudo-reaction that consumes metabolic precursors in the precise ratios needed to create one unit of cellular biomass. This advanced practice guides you through the process of deriving the stoichiometry of this reaction from experimental data on macromolecular composition and energetic costs, a critical step in building a predictive growth model .",
            "id": "3917830",
            "problem": "A synthetic bacterium, denoted SynBact-X, is being modeled for Flux Balance Analysis (FBA), and requires a biomass pseudo-reaction that consumes precursor metabolites to produce $1$ gram of dry biomass. The biomass composition is described by macromolecular dry-weight fractions: protein $0.55$, ribonucleic acid (RNA) $0.20$, deoxyribonucleic acid (DNA) $0.03$, lipid $0.12$, cell wall polysaccharide $0.08$, and soluble pools (cofactors and ions) $0.02$. The following assumptions are adopted for reconstruction:\n\n- The biomass pseudo-reaction produces a single abstract product $Biomass$, where the stoichiometric coefficients of consumed precursors are defined as moles of each precursor required per gram dry weight of biomass.\n- The average residue molecular masses for incorporated macromolecular units are: amino acid residue $110$ $\\mathrm{g \\, mol^{-1}}$, ribonucleotide residue $330$ $\\mathrm{g \\, mol^{-1}}$, and deoxyribonucleotide residue $310$ $\\mathrm{g \\, mol^{-1}}$. Lipids and cell wall polysaccharides are treated as separate precursor pools whose energetic polymerization costs are neglected for this calculation.\n- The energetic cost of macromolecular polymerization is counted in adenosine triphosphate (ATP) equivalents: protein incorporation consumes $4$ ATP equivalents per amino acid residue, RNA polymerization consumes $1$ ATP equivalent per ribonucleotide residue, and DNA polymerization consumes $1$ ATP equivalent per deoxyribonucleotide residue. Here, “ATP equivalent” means any high-energy phosphate hydrolysis counted equivalently to ATP; thus, guanosine triphosphate (GTP) hydrolysis during translation is counted toward ATP equivalents.\n\nStarting from the law of conservation of mass and standard stoichiometric definitions, construct the biomass composition entries for protein, RNA, and DNA as moles of incorporated residues per gram dry weight, and from these derive the stoichiometric biomass reaction that consumes the precursor pools $AA\\_{\\mathrm{pool}}$ (amino acid pool), $NTP$ (ribonucleoside triphosphates), and $dNTP$ (deoxyribonucleoside triphosphates), together with the net ATP consumption required for polymerization. Then, compute the net ATP consumption coefficient of the biomass reaction as a single scalar equal to the millimoles of ATP equivalents consumed per gram dry weight.\n\nExpress the final ATP demand in millimoles per gram dry weight. Round your final answer to four significant figures.",
            "solution": "The fundamental task is to construct a portion of the biomass pseudo-reaction for a synthetic bacterium, focusing on the consumption of macromolecular precursors and the associated energetic cost in terms of adenosine triphosphate (ATP) equivalents. The goal is to determine the stoichiometric coefficient for ATP consumption per gram of dry weight (gDW) of biomass produced.\n\nThe stoichiometric coefficient, $\\nu_i$, for a given precursor metabolite $i$ in the biomass reaction is defined as the number of moles of that metabolite required to synthesize $1$ gram of dry biomass. This is derived from the principle of mass conservation. For a macromolecule, the molar quantity of its constituent monomeric units (residues) incorporated into $1$ gDW of biomass is calculated by dividing the mass fraction of the macromolecule ($w_i$, in units of $\\mathrm{g / gDW}$) by the average molecular mass of its incorporated residue ($M_i$, in units of $\\mathrm{g / mol}$).\n\nThe formula for the molar requirement of each residue type is:\n$$ \\nu_i = \\frac{w_i}{M_{i, \\text{residue}}} $$\n\nWe are given the following data:\nMass fractions:\n- Protein ($w_{prot}$): $0.55 \\, \\mathrm{g/gDW}$\n- RNA ($w_{RNA}$): $0.20 \\, \\mathrm{g/gDW}$\n- DNA ($w_{DNA}$): $0.03 \\, \\mathrm{g/gDW}$\n\nAverage residue molecular masses:\n- Amino acid residue ($M_{AA}$): $110 \\, \\mathrm{g \\, mol^{-1}}$\n- Ribonucleotide residue ($M_{NTP}$): $330 \\, \\mathrm{g \\, mol^{-1}}$\n- Deoxyribonucleotide residue ($M_{dNTP}$): $310 \\, \\mathrm{g \\, mol^{-1}}$\n\nFirst, we calculate the moles of each type of residue required to produce $1$ gDW of biomass. These values represent the stoichiometric coefficients for the precursor pools consumed in the biomass reaction.\n\nFor the amino acid pool ($AA_{\\mathrm{pool}}$) consumed for protein synthesis:\n$$ \\nu_{AA} = \\frac{w_{prot}}{M_{AA}} = \\frac{0.55 \\, \\mathrm{g/gDW}}{110 \\, \\mathrm{g \\, mol^{-1}}} = 0.005 \\, \\mathrm{mol/gDW} $$\n\nFor the ribonucleoside triphosphate pool ($NTP$) consumed for RNA synthesis:\n$$ \\nu_{NTP} = \\frac{w_{RNA}}{M_{NTP}} = \\frac{0.20 \\, \\mathrm{g/gDW}}{330 \\, \\mathrm{g \\, mol^{-1}}} = \\frac{2}{3300} \\, \\mathrm{mol/gDW} \\approx 6.06 \\times 10^{-4} \\, \\mathrm{mol/gDW} $$\n\nFor the deoxyribonucleoside triphosphate pool ($dNTP$) consumed for DNA synthesis:\n$$ \\nu_{dNTP} = \\frac{w_{DNA}}{M_{dNTP}} = \\frac{0.03 \\, \\mathrm{g/gDW}}{310 \\, \\mathrm{g \\, mol^{-1}}} = \\frac{3}{31000} \\, \\mathrm{mol/gDW} \\approx 9.68 \\times 10^{-5} \\, \\mathrm{mol/gDW} $$\n\nThe portion of the biomass pseudo-reaction concerning these precursors is:\n$$ \\nu_{AA} \\, AA_{\\mathrm{pool}} + \\nu_{NTP} \\, NTP + \\nu_{dNTP} \\, dNTP + \\dots \\rightarrow 1 \\, \\text{Biomass} $$\nNote that in a formal stoichiometric matrix for FBA, these coefficients for reactants would be negative.\n\nNext, we calculate the energetic cost of polymerization for each macromolecule, measured in moles of ATP equivalents consumed per gDW of biomass. The total ATP consumption, $\\nu_{ATP, \\text{total}}$, is the sum of the ATP consumed for protein, RNA, and DNA synthesis.\n\nThe energetic costs per residue incorporation are given as:\n- Protein synthesis ($E_{prot}$): $4 \\, \\mathrm{mol \\, ATP / mol \\, AA \\, residue}$\n- RNA synthesis ($E_{RNA}$): $1 \\, \\mathrm{mol \\, ATP / mol \\, NTP \\, residue}$\n- DNA synthesis ($E_{DNA}$): $1 \\, \\mathrm{mol \\, ATP / mol \\, dNTP \\, residue}$\n\nThe ATP consumption for each macromolecular synthesis is the product of the moles of residues and the energetic cost per residue:\n$$ \\nu_{ATP, i} = \\nu_i \\times E_i $$\n\nATP for protein synthesis:\n$$ \\nu_{ATP, prot} = \\nu_{AA} \\times E_{prot} = 0.005 \\, \\mathrm{mol/gDW} \\times 4 = 0.02 \\, \\mathrm{mol \\, ATP/gDW} $$\n\nATP for RNA synthesis:\n$$ \\nu_{ATP, RNA} = \\nu_{NTP} \\times E_{RNA} = \\frac{0.20}{330} \\, \\mathrm{mol/gDW} \\times 1 = \\frac{0.20}{330} \\, \\mathrm{mol \\, ATP/gDW} $$\n\nATP for DNA synthesis:\n$$ \\nu_{ATP, DNA} = \\nu_{dNTP} \\times E_{DNA} = \\frac{0.03}{310} \\, \\mathrm{mol/gDW} \\times 1 = \\frac{0.03}{310} \\, \\mathrm{mol \\, ATP/gDW} $$\n\nThe total net ATP consumption in moles per gDW is the sum of these components:\n$$ \\nu_{ATP, \\text{total}} = \\nu_{ATP, prot} + \\nu_{ATP, RNA} + \\nu_{ATP, DNA} $$\n$$ \\nu_{ATP, \\text{total}} = 0.02 + \\frac{0.20}{330} + \\frac{0.03}{310} \\, \\mathrm{mol/gDW} $$\n\nNow, we compute the numerical value:\n$$ \\frac{0.20}{330} \\approx 0.00060606 \\, \\mathrm{mol/gDW} $$\n$$ \\frac{0.03}{310} \\approx 0.00009677 \\, \\mathrm{mol/gDW} $$\n$$ \\nu_{ATP, \\text{total}} \\approx 0.02 + 0.00060606 + 0.00009677 = 0.02070283 \\, \\mathrm{mol/gDW} $$\n\nThe problem requires the final answer expressed in millimoles per gram dry weight ($\\mathrm{mmol/gDW}$). We convert the total ATP consumption from moles to millimoles by multiplying by $1000$:\n$$ C_{ATP} = \\nu_{ATP, \\text{total}} \\times 1000 \\, \\mathrm{mmol/mol} $$\n$$ C_{ATP} = \\left( 0.02 + \\frac{0.20}{330} + \\frac{0.03}{310} \\right) \\times 1000 \\, \\mathrm{mmol/gDW} $$\n$$ C_{ATP} \\approx 0.02070283 \\times 1000 = 20.70283 \\, \\mathrm{mmol/gDW} $$\n\nFinally, we round the result to four significant figures. The fifth significant figure is $2$, so we round down.\n$$ C_{ATP} \\approx 20.70 \\, \\mathrm{mmol/gDW} $$\nThis value represents the net ATP consumption coefficient for the biomass reaction.",
            "answer": "$$\\boxed{20.70}$$"
        },
        {
            "introduction": "For a metabolic model to be physically realistic, every reaction within it must be elementally and charge balanced. Manually checking this for hundreds or thousands of reactions is impractical, making automated curation an essential skill. This hands-on programming challenge involves building a tool to parse reaction formulas, verify their adherence to conservation laws, and propose minimal corrections, ensuring the structural integrity of your reconstructed network .",
            "id": "3917903",
            "problem": "You are given a list of biochemical reactions represented by species chemical formulas with explicit ionic charge annotations in square brackets and initial integer stoichiometric coefficients on the left and right sides. Your task is to write a complete, runnable program that, for each reaction, determines whether it is elementally and charge balanced and then computes a minimal integer adjustment to the stoichiometric coefficients to restore balance if it is not.\n\nFundamental base and definitions to be used:\n- Conservation of mass and charge: In a valid metabolic reaction, the total count of each chemical element and the net ionic charge are conserved between the left-hand side and the right-hand side. This implies that the sum of element counts on the left must equal the sum on the right for all elements, and the sum of charges must match.\n- Stoichiometric matrix representation: Let the set of elements present be denoted by $E$, where each entry corresponds to a unique chemical element (for example, $C$, $H$, $O$, $N$, $P$, $S$) and one additional dimension for ionic charge. For each species $s$, define its composition vector $e(s) \\in \\mathbb{Z}^{|E|}$, where each component gives the count of the corresponding element and the ionic charge. Let $A_L \\in \\mathbb{Z}^{|E| \\times n_L}$ and $A_R \\in \\mathbb{Z}^{|E| \\times n_R}$ be the matrices whose columns are the composition vectors $e(s)$ of the left and right species, respectively. Let $x_L \\in \\mathbb{N}^{n_L}$ and $x_R \\in \\mathbb{N}^{n_R}$ be the stoichiometric coefficient vectors on the left and right. Elemental and charge balance requires\n$$\nA_L x_L = A_R x_R,\n$$\nor equivalently, with $M = [A_L \\;|\\; -A_R]$ and $v = \\begin{bmatrix} x_L \\\\ x_R \\end{bmatrix}$,\n$$\nM v = 0.\n$$\n\nMinimal adjustment criterion:\n- Given an initial integer stoichiometric vector $v_0 = \\begin{bmatrix} x_{L,0} \\\\ x_{R,0} \\end{bmatrix}$, find a balanced integer vector $v^\\ast$ that minimizes $\\sum_i |v^\\ast_i - v_{0,i}|$ subject to $M v^\\ast = 0$ and $v^\\ast_i \\in \\mathbb{N}$ for all $i$. In case of ties (multiple solutions with the same minimum value of $\\sum_i |v^\\ast_i - v_{0,i}|$), choose the one that minimizes $\\sum_i v^\\ast_i$. To ensure computational tractability and reproducibility, restrict the search to the bounded integer box\n$$\nv^\\ast_i \\in [\\max(0, v_{0,i} - B), \\; v_{0,i} + B],\n$$\nwhere $B$ is a nonnegative integer bound provided per test case.\n\nChemical formula parsing rules:\n- A species formula is a string such as \"C6H12O6[0]\" or \"NH4[+1]\". Elements are indicated by a capital letter optionally followed by a lowercase letter (for example, \"C\", \"H\", \"O\", \"N\"). Each element may be followed by a nonnegative integer count; if omitted, the count is $1$. The ionic charge is specified at the end in square brackets as $[+z]$, $[-z]$, or $[0]$ with $z \\in \\mathbb{N}$. The charge contributes as an additional conserved quantity in $E$. Parentheses or nested groups are not used in this problem. If extraneous characters (such as a plus sign) appear outside the square brackets, they must be ignored by the parser.\n- Example: \"H2O[0]\" has counts $H:2$, $O:1$, and charge $0$. \"NH4[+1]\" has counts $N:1$, $H:4$, and charge $+1$.\n\nProgram requirements:\n- For each reaction, parse the species formulas to build $A_L$ and $A_R$, test whether the initial $v_0$ satisfies $M v_0 = 0$, and then, if not balanced, search within the specified bound $B$ for $v^\\ast$ that satisfies $M v^\\ast = 0$ while minimizing the adjustment criterion described above.\n- All computations are to be performed using integers. No floating-point unit conversions are necessary for this problem.\n\nTest suite:\nProvide results for the following four reactions. Each test case specifies left and right species formulas, their initial stoichiometric coefficients, and the bound $B$ for the minimal adjustment search.\n\n- Test case $1$ (general case with elemental imbalance):\n    - Left species formulas: [\"C6H12O6[0]\", \"O2[0]\"]\n    - Right species formulas: [\"CO2[0]\", \"H2O[0]\"]\n    - Initial stoichiometric coefficients: $x_{L,0} = [1, 6]$, $x_{R,0} = [5, 6]$\n    - Bound: $B = 2$\n- Test case $2$ (charge imbalance resolved by adding a proton):\n    - Left species formulas: [\"NH3[0]\", \"H+[+1]\"]\n    - Right species formulas: [\"NH4[+1]\"]\n    - Initial stoichiometric coefficients: $x_{L,0} = [1, 0]$, $x_{R,0} = [1]$\n    - Bound: $B = 1$\n- Test case $3$ (already balanced; boundary condition with zero search radius):\n    - Left species formulas: [\"CO2[0]\", \"H2O[0]\"]\n    - Right species formulas: [\"H2CO3[0]\"]\n    - Initial stoichiometric coefficients: $x_{L,0} = [1, 1]$, $x_{R,0} = [1]$\n    - Bound: $B = 0$\n- Test case $4$ (elemental imbalance resolved by adding water):\n    - Left species formulas: [\"C2H6O[0]\", \"O2[0]\"]\n    - Right species formulas: [\"C2H4O2[0]\", \"H2O[0]\"]\n    - Initial stoichiometric coefficients: $x_{L,0} = [1, 1]$, $x_{R,0} = [1, 0]$\n    - Bound: $B = 1$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each reaction’s result must be encoded as a list of three items:\n    - A boolean indicating whether the initial reaction is balanced.\n    - The adjusted left stoichiometric coefficients as a list of integers, in the same species order as provided.\n    - The adjusted right stoichiometric coefficients as a list of integers, in the same species order as provided.\n- For example, a valid output could look like \"[[true,[1,6],[6,6]],[false,[1,1],[1,1]],[true,[1,1],[1]],[false,[1,1],[1,1]]]\". The actual values must correspond to the computations for the provided test suite, and booleans must print as Python boolean literals (\"True\" or \"False\").",
            "solution": "The problem requires validating and balancing biochemical reactions based on the principles of mass and charge conservation. A computational method is to be developed to parse chemical formulas, construct a stoichiometric representation, check for balance, and find a minimal integer adjustment to the stoichiometric coefficients if the reaction is unbalanced. The solution is designed in a sequence of logical steps.\n\n**1. Parsing Chemical Formulas and Charge**\n\nThe first step is to convert the string representation of each chemical species, such as `\"C6H12O6[0]\"`, into a machine-readable format. Each species $s$ is described by its composition vector, $e(s)$, which contains the counts of each constituent chemical element and its ionic charge.\n\nA parser is designed to process a given formula string. It systematically scans the string to identify element symbols, which consist of a single uppercase letter optionally followed by a lowercase letter. Following each symbol, an integer count is expected; if the count is omitted, it is interpreted as $1$. For example, in `\"H2O\"`, the parser identifies `H` with a count of $2$ and `O` with a count of $1$.\n\nIonic charge is specified in square brackets at the end of the formula, e.g., `\"[+1]\"`, `\"[-2]\"`, or `\"[0]\"`. The parser extracts this integer value. The set of all unique elements across all species in a reaction, augmented with an entry for 'Charge', forms the basis for the composition vectors. For a reaction involving elements $\\{C, H, O\\}$ and charge, the composition vector for water, `H2O[0]`, would be constructed based on an ordered basis like $(C, H, O, \\text{Charge})$, resulting in the vector $[0, 2, 1, 0]^T$.\n\n**2. Stoichiometric Matrix Formulation**\n\nThe principle of conservation mandates that for a balanced reaction, the total count of each element and the total charge must be identical on the reactant (left) and product (right) sides. This can be expressed as a linear system.\n\nLet the set of unique elements and charge be denoted by $E$. For a reaction with $n_L$ reactant species and $n_R$ product species, we define two matrices: $A_L \\in \\mathbb{Z}^{|E| \\times n_L}$ and $A_R \\in \\mathbb{Z}^{|E| \\times n_R}$. The columns of $A_L$ and $A_R$ are the composition vectors $e(s)$ of the left-hand and right-hand species, respectively. Let $x_L \\in \\mathbb{N}^{n_L}$ and $x_R \\in \\mathbb{N}^{n_R}$ be the vectors of stoichiometric coefficients for the reactants and products. The balance condition is:\n$$\nA_L x_L = A_R x_R\n$$\nThis equation states that the total elemental and charge composition of the reactants equals that of the products. It can be rewritten in the form of a homogeneous linear system:\n$$\nA_L x_L - A_R x_R = 0\n$$\nBy defining a composite stoichiometric matrix $M = [A_L \\; | \\; -A_R] \\in \\mathbb{Z}^{|E| \\times (n_L + n_R)}$ and a composite coefficient vector $v = \\begin{bmatrix} x_L \\\\ x_R \\end{bmatrix} \\in \\mathbb{N}^{n_L + n_R}$, the balance equation simplifies to:\n$$\nM v = 0\n$$\nAny integer vector $v$ with non-negative components that satisfies this equation represents a stoichiometrically balanced reaction.\n\n**3. Initial Balance Verification**\n\nGiven a set of initial stoichiometric coefficients, $v_0 = \\begin{bmatrix} x_{L,0} \\\\ x_{R,0} \\end{bmatrix}$, the reaction's initial balance is determined by checking if $M v_0 = 0$. If the result of the matrix-vector multiplication is the zero vector, the reaction is balanced. Otherwise, it is unbalanced.\n\n**4. Minimal Adjustment Search**\n\nIf the initial state $v_0$ is unbalanced, the task is to find an adjusted non-negative integer vector $v^\\ast$ that satisfies the balance condition $M v^\\ast = 0$ and minimizes a specified cost function. The search for $v^\\ast$ is constrained to a bounded integer box defined by a given search radius $B \\ge 0$. For each coefficient $v_i$, the search range is:\n$$\nv_i \\in [\\max(0, v_{0,i} - B), \\, v_{0,i} + B]\n$$\nThis defines a finite, multidimensional grid of candidate vectors $v$. A systematic, exhaustive search is performed over this grid.\n\nFor each candidate vector $v$ within the search box, we first verify if it satisfies the balance condition $Mv=0$. If it does, it is a valid solution. Among all valid solutions, we seek the optimal one, $v^\\ast$, based on a two-tier optimization criterion:\n1.  **Primary Criterion**: Minimize the L1-norm of the adjustment vector, defined as $C_1(v) = \\sum_i |v_i - v_{0,i}|$. This finds the \"closest\" balanced state to the initial state in terms of the sum of absolute changes to coefficients.\n2.  **Secondary Criterion (Tie-breaker)**: If multiple vectors yield the same minimal adjustment distance $C_1$, select the one that minimizes the L1-norm of the solution vector itself, $C_2(v) = \\sum_i v_i$. This favors reactions with smaller overall stoichiometric numbers, promoting simplicity.\n\nThe search algorithm proceeds as follows:\n- Initialize the minimum adjustment distance found so far to infinity.\n- Iterate through every possible integer vector $v$ within the defined search box.\n- For each $v$:\n    - Check if $Mv = 0$. If not, discard $v$.\n    - If balanced, calculate $d_1 = \\sum_i |v_i - v_{0,i}|$.\n    - Compare $d_1$ with the current minimum distance.\n        - If $d_1$ is smaller than the minimum, this $v$ becomes the new best candidate $v^\\ast$. The minimum distance and the tie-breaker value $d_2 = \\sum_i v_i$ are updated.\n        - If $d_1$ is equal to the minimum, calculate $d_2 = \\sum_i v_i$ and compare it with the stored tie-breaker value. If $d_2$ is smaller, $v$ becomes the new best candidate $v^\\ast$.\n\nAfter the search space has been fully explored, the resulting $v^\\ast$ is the minimally adjusted balanced stoichiometric vector. If the initial reaction was already balanced, the adjustment search is bypassed, and the initial vector $v_0$ is considered the final result. The final output is then formatted as a boolean indicating initial balance, followed by the left and right coefficient vectors corresponding to the final state.\n\n```python\nimport numpy as np\nimport re\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"left_species\": [\"C6H12O6[0]\", \"O2[0]\"],\n            \"right_species\": [\"CO2[0]\", \"H2O[0]\"],\n            \"x_L0\": [1, 6],\n            \"x_R0\": [5, 6],\n            \"B\": 2,\n        },\n        {\n            \"left_species\": [\"NH3[0]\", \"H+[+1]\"],\n            \"right_species\": [\"NH4[+1]\"],\n            \"x_L0\": [1, 0],\n            \"x_R0\": [1],\n            \"B\": 1,\n        },\n        {\n            \"left_species\": [\"CO2[0]\", \"H2O[0]\"],\n            \"right_species\": [\"H2CO3[0]\"],\n            \"x_L0\": [1, 1],\n            \"x_R0\": [1],\n            \"B\": 0,\n        },\n        {\n            \"left_species\": [\"C2H6O[0]\", \"O2[0]\"],\n            \"right_species\": [\"C2H4O2[0]\", \"H2O[0]\"],\n            \"x_L0\": [1, 1],\n            \"x_R0\": [1, 0],\n            \"B\": 1,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        is_balanced_initially, final_coeffs_l, final_coeffs_r = process_reaction(\n            case[\"left_species\"], case[\"right_species\"],\n            case[\"x_L0\"], case[\"x_R0\"], case[\"B\"]\n        )\n        # Format the result string for this case as per problem requirements\n        result_str = (\n            f\"[{str(is_balanced_initially)},{str(final_coeffs_l)},\"\n            f\"{str(final_coeffs_r)}]\"\n        ).replace(\" \", \"\")\n        results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n\ndef parse_formula(formula):\n    \"\"\"\n    Parses a chemical formula string into a dictionary of element counts and charge.\n    Example: \"C6H12O6[0]\" -> {'C': 6, 'H': 12, 'O': 6, 'Charge': 0}\n    \"\"\"\n    composition = {}\n    \n    # Extract charge\n    charge_match = re.search(r'\\[([+-]?\\d+)\\]', formula)\n    if charge_match:\n        composition['Charge'] = int(charge_match.group(1))\n        formula = formula[:charge_match.start()]\n    else:\n        # Assume charge 0 if not specified, though problem implies it always is\n        composition['Charge'] = 0\n\n    # Extract elements and their counts\n    element_matches = re.findall(r'([A-Z][a-z]?)(\\d*)', formula)\n    for element, count_str in element_matches:\n        count = int(count_str) if count_str else 1\n        composition[element] = composition.get(element, 0) + count\n        \n    return composition\n\ndef process_reaction(left_species, right_species, x_L0, x_R0, B):\n    \"\"\"\n    Analyzes a single reaction for balance and performs minimal adjustment if needed.\n    \"\"\"\n    all_species = left_species + right_species\n    compositions = [parse_formula(s) for s in all_species]\n\n    # Establish the basis of elements and charge\n    all_elements = set()\n    for comp in compositions:\n        all_elements.update(comp.keys())\n    \n    # Create a consistent order for elements\n    element_order = sorted([el for el in all_elements if el != 'Charge']) + ['Charge']\n    element_map = {el: i for i, el in enumerate(element_order)}\n    num_elements = len(element_order)\n\n    # Build the stoichiometric matrix M\n    num_left = len(left_species)\n    num_right = len(right_species)\n    num_total_species = num_left + num_right\n    M = np.zeros((num_elements, num_total_species), dtype=np.int64)\n\n    for i, comp in enumerate(compositions):\n        for element, count in comp.items():\n            row_idx = element_map[element]\n            sign = 1 if i  num_left else -1\n            M[row_idx, i] = sign * count\n    \n    v0 = np.array(x_L0 + x_R0, dtype=np.int64)\n\n    # Check initial balance\n    is_balanced_initially = np.all(np.dot(M, v0) == 0)\n\n    if is_balanced_initially:\n        return True, x_L0, x_R0\n\n    # If not balanced, search for the minimal adjustment\n    # Define search space for v\n    search_ranges = []\n    for i in range(num_total_species):\n        lower_bound = max(0, v0[i] - B)\n        upper_bound = v0[i] + B\n        search_ranges.append(range(lower_bound, upper_bound + 1))\n\n    best_v = None\n    min_adj_dist = float('inf')\n    min_v_sum = float('inf')\n\n    # Iterate through all candidate vectors in the search box\n    for v_tuple in product(*search_ranges):\n        v = np.array(v_tuple, dtype=np.int64)\n\n        # Check for balance\n        if np.all(np.dot(M, v) == 0):\n            adj_dist = np.sum(np.abs(v - v0))\n            v_sum = np.sum(v)\n\n            if adj_dist  min_adj_dist:\n                min_adj_dist = adj_dist\n                min_v_sum = v_sum\n                best_v = v\n            elif adj_dist == min_adj_dist:\n                if v_sum  min_v_sum:\n                    min_v_sum = v_sum\n                    best_v = v\n\n    final_coeffs_l = list(best_v[:num_left])\n    final_coeffs_r = list(best_v[num_left:])\n\n    return False, final_coeffs_l, final_coeffs_r\n\n# This part is for conceptual execution and is not run in the final environment.\n# if __name__ == \"__main__\":\n#     solve()\n```",
            "answer": "[[False,[1,6],[6,6]],[False,[1,1],[1]],[True,[1,1],[1]],[False,[1,1],[1,1]]]"
        }
    ]
}