{
    "hands_on_practices": [
        {
            "introduction": "中心法则的核心在于遗传信息的高保真传递。然而，这种保真性并非绝对完美，而是由一个多层次的纠错系统来维持，包括DNA聚合酶自身的选择性、即时的校对功能以及复制后的错配修复机制。本练习  引导我们运用基础的概率论原理，将“高保真”这一定性概念转化为对每个细胞分裂周期中预期突变数量的定量预测，从而深刻理解信息完整性是如何在分子层面通过数学法则来保障的。",
            "id": "2965554",
            "problem": "一个真核细胞在每次细胞分裂时会复制一个包含 $3.2 \\times 10^{9}$ 个核苷酸位置的线性基因组。在每个位置，脱氧核糖核酸（DNA）聚合酶以边际概率 $\\epsilon_{\\text{pol}} = 10^{-5}$ 错误地掺入一个核苷酸。在3'端发生错配事件的条件下，外切核酸酶校对机制会尝试移除该错配；校对未能纠正错配的条件概率为 $\\epsilon_{\\text{proof}} = 10^{-2}$。在复制后错配持续存在的条件下，错配修复（MMR）系统会尝试纠正它；错配修复失败的条件概率为 $\\epsilon_{\\text{MMR}} = 10^{-1}$。假设不同位置上的错误事件是独立的，并且在存在错配的情况下，校正失败事件是条件独立的。只有当发生一次错配，并且在下一次复制周期之前两个校正系统都失败时，一个碱基替换才会成为一个固定的突变。\n\n在分子生物学中心法则的框架内，高保真复制维持了信息从DNA到DNA的流动。请仅使用上述定义以及概率和期望的第一性原理，推导一个表达式，用于计算在 $3.2 \\times 10^{9}$ 个位置上每次细胞分裂由复制引起的碱基替换的期望数量。然后，使用给定的参数值对该期望进行数值计算。将每次分裂的最终替换数报告为一个精确的数字（不四舍五入，不带单位）。\n\n最后，根据你的结果和关于具有完整校对和错配修复功能的正常人类体细胞中复制保真度的既有定性知识，用文字简要评估你计算出的数值在生物学上是否合理，并定性地证明你的推理（你的定性评估不会影响数值答案的要求）。",
            "solution": "该问题要求推导并计算在一个复制周期后，基因组中成为固定突变的碱基替换的期望数量。这个数量是由DNA聚合酶引入错误与随后的两个主要修复系统（校对和错配修复）之间相互作用决定的。解决方案的基础在于概率论，特别是对一系列相关事件概率的计算，以及期望线性性质的应用。\n\n设 $N$ 为基因组中的核苷酸位置总数，给定为 $N = 3.2 \\times 10^{9}$。\n一个碱基替换在单个位置上成为固定突变，当且仅当发生以下三个事件序列：初始错配、校对失败以及随后的错配修复失败。我们必须计算这个复合事件的概率。\n\n我们为单个核苷酸位置定义以下事件：\n- $M$：DNA聚合酶错误掺入一个核苷酸的事件。其概率给定为 $P(M) = \\epsilon_{\\text{pol}} = 10^{-5}$。\n- $F_P$：外切核酸酶校对机制未能纠正错配的事件。这是一个条件事件，依赖于错配的发生。问题给出的条件概率为 $P(F_P | M) = \\epsilon_{\\text{proof}} = 10^{-2}$。\n- $F_{MMR}$：错配修复（MMR）系统未能纠正错配的事件。该事件的条件是错配在复制和校对后仍然存在，即以事件 $M \\cap F_P$ 为条件。问题给出的条件概率为 $P(F_{MMR} | M \\cap F_P) = \\epsilon_{\\text{MMR}} = 10^{-1}$。\n\n单个固定替换的概率，我们记为 $\\mu$，是这三个事件交集的概率：$\\mu = P(M \\cap F_P \\cap F_{MMR})$。使用概率的链式法则，我们可以将 $\\mu$ 表示如下：\n$$ \\mu = P(M) \\times P(F_P | M) \\times P(F_{MMR} | M \\cap F_P) $$\n问题陈述提供了等式右侧所有必需的概率。代入给定的符号参数：\n$$ \\mu = \\epsilon_{\\text{pol}} \\cdot \\epsilon_{\\text{proof}} \\cdot \\epsilon_{\\text{MMR}} $$\n这个表达式代表了在一次细胞分裂期间，任何单个核苷酸位置上出现固定突变的概率。\n\n现在，我们必须计算在整个基因组的 $N$ 个位置上，这类突变的总期望数量。设 $X$ 为一个随机变量，表示每次细胞分裂的总替换数。我们可以定义 $N$ 个指示随机变量 $X_1, X_2, \\dots, X_N$，其中如果位置 $i$ 发生固定替换，则 $X_i = 1$，否则 $X_i = 0$。$X_i = 1$ 的概率恰好是上面计算出的 $\\mu$。\n总替换数是这些指示变量的和：$X = \\sum_{i=1}^{N} X_i$。\n\n根据期望的线性性质，随机变量之和的期望值等于它们各自期望值的和：\n$$ E[X] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i] $$\n指示随机变量 $X_i$ 的期望等于它所指示事件的概率：$E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = P(X_i=1) = \\mu$。\n由于假设所有位置的突变概率 $\\mu$ 都是相同的，所以总和可以简化为：\n$$ E[X] = \\sum_{i=1}^{N} \\mu = N \\cdot \\mu $$\n因此，替换数期望的最终表达式为：\n$$ E[X] = N \\cdot \\epsilon_{\\text{pol}} \\cdot \\epsilon_{\\text{proof}} \\cdot \\epsilon_{\\text{MMR}} $$\n我们现在使用给定的参数值进行数值计算：\n$N = 3.2 \\times 10^{9}$\n$\\epsilon_{\\text{pol}} = 10^{-5}$\n$\\epsilon_{\\text{proof}} = 10^{-2}$\n$\\epsilon_{\\text{MMR}} = 10^{-1}$\n\n首先，我们计算单一位点的突变概率 $\\mu$：\n$$ \\mu = (10^{-5}) \\times (10^{-2}) \\times (10^{-1}) = 10^{-5-2-1} = 10^{-8} $$\n这是每个位点、每次复制的突变率。\n\n接下来，我们计算总替换数的期望值 $E[X]$：\n$$ E[X] = (3.2 \\times 10^{9}) \\times (10^{-8}) = 3.2 \\times 10^{9-8} = 3.2 \\times 10^{1} = 32 $$\n因此，每次细胞分裂由复制引起的碱基替换的期望数量为 $32$。\n\n最后，我们评估这个结果的生物学合理性。计算得出的总体突变率 $\\mu = 10^{-8}$ 次突变/碱基对/复制周期是一个教科书级别的值，与人类和其他哺乳动物生殖系突变率的测量结果高度一致。对于一个大小为 $3.2 \\times 10^{9}$ 碱基对的基因组，由此产生的 $32$ 个新突变的期望值也完全在已确立的生物学估计范围内。对人类新生（*de novo*）突变的实证研究表明，这些突变在细胞分裂中累积，每一代会报告数十个新突变。因此，基因组单轮复制产生 $32$ 个突变的期望值是一个科学上合理且可信的数量级。它正确地量化了一个过程的结果，即数量庞大的核苷酸以极高但非完美的保真度被复制。中心法则关于信息从DNA到DNA高保真保存的原则得以维持，但这个计算表明它并非绝对的。",
            "answer": "$$\n\\boxed{32}\n$$"
        },
        {
            "introduction": "从相对静态的DNA蓝图转向动态的基因表达过程，我们首先关注转录产物——信使RNA (mRNA) 的丰度变化。一个简洁而强大的模型将细胞内mRNA的水平视为一个动态平衡：一端是基因持续转录产生的“源”，另一端是mRNA分子不断降解的“汇”。本练习  旨在通过构建并求解一个一阶常微分方程，来描述基因表达的时间动态，这是定量生物学的基石。通过这个模型，我们能够预测系统在响应外界诱导（如转录速率的改变）时的瞬态行为和达到新稳态所需的时间。",
            "id": "3934073",
            "problem": "单个细菌细胞中的一个合成基因由一个诱导型启动子控制，该启动子在加入诱导剂后会增加转录。根据分子生物学的中心法则，基因被转录成信使核糖核酸（mRNA），后者随后被翻译成蛋白质。假设mRNA的产生以一定的转录速率进行，并通过一级过程（化学降解和因生长引起的稀释）被移除，这与质量作用动力学一致。在时间 $t  0$ 时，系统处于诱导前的稳态，转录速率为恒定的 $r_0$。在时间 $t=0$ 时，一个诱导步骤使转录速率瞬间增加到一个新的恒定值 $r_1$。mRNA的有效一级移除速率常数为 $\\delta$，该值不随时间改变。令 $m(t)$ 表示在时间 $t$ 时每个细胞中mRNA分子的数量。\n\n从 $m(t)$ 的守恒定律和质量作用假设出发，推导 $m(t)$ 的动力学模型，并在初始条件为 $m(0)$ 等于诱导前稳态值的条件下，求解 $t \\geq 0$ 时的模型。使用您推导出的解，计算 $m(t)$ 首次达到诱导后稳态值的 $0.95$ 时的时间 $t_{0.95}$。使用参数值 $r_0 = 10\\,\\text{molecules min}^{-1}$、$r_1 = 50\\,\\text{molecules min}^{-1}$ 和 $\\delta = 0.2\\,\\text{min}^{-1}$。\n\n以分钟为单位提供您对 $t_{0.95}$ 的最终答案，并将您的数值结果四舍五入到四位有效数字。",
            "solution": "mRNA分子数 $m(t)$ 的动力学由一个守恒定律控制。$m(t)$ 的变化率是生产速率（转录）和移除速率（降解和稀释）之间的差值。\n基于质量作用动力学，这可以表述为一个微分方程：\n$$\n\\frac{dm(t)}{dt} = \\text{rate of production} - \\text{rate of removal}\n$$\n生产速率是转录速率，是时间的函数 $r(t)$。移除速率是一个一级过程，与当前mRNA分子数成正比，速率常数为 $\\delta$。\n$$\n\\frac{dm(t)}{dt} = r(t) - \\delta m(t)\n$$\n首先，我们必须确定初始条件 $m(0)$。问题指出，在 $t  0$ 时，系统处于诱导前的稳态，转录速率为恒定的 $r_0$。在稳态下，分子数是恒定的，因此 $\\frac{dm}{dt} = 0$。\n$$\n0 = r_0 - \\delta m_{ss,0}\n$$\n其中 $m_{ss,0}$ 是诱导前的稳态分子数。求解 $m_{ss,0}$ 可得：\n$$\nm_{ss,0} = \\frac{r_0}{\\delta}\n$$\n这就是我们的初始条件：$m(0) = m_{ss,0} = \\frac{r_0}{\\delta}$。\n\n对于 $t \\geq 0$，转录速率瞬间增加到 $r_1$。对于 $t \\geq 0$ 的控制微分方程是：\n$$\n\\frac{dm(t)}{dt} = r_1 - \\delta m(t)\n$$\n这是一个一阶线性非齐次常微分方程。我们可以将其重写为：\n$$\n\\frac{dm(t)}{dt} + \\delta m(t) = r_1\n$$\n通解可以通过使用积分因子 $I(t) = \\exp\\left(\\int \\delta \\, dt\\right) = \\exp(\\delta t)$ 来找到。将方程乘以 $I(t)$：\n$$\n\\exp(\\delta t) \\frac{dm(t)}{dt} + \\delta \\exp(\\delta t) m(t) = r_1 \\exp(\\delta t)\n$$\n左边是乘积 $m(t) \\exp(\\delta t)$ 的导数：\n$$\n\\frac{d}{dt} \\left[ m(t) \\exp(\\delta t) \\right] = r_1 \\exp(\\delta t)\n$$\n对两边关于 $t$ 积分：\n$$\nm(t) \\exp(\\delta t) = \\int r_1 \\exp(\\delta t) \\, dt = \\frac{r_1}{\\delta} \\exp(\\delta t) + C\n$$\n其中 $C$ 是积分常数。求解 $m(t)$：\n$$\nm(t) = \\frac{r_1}{\\delta} + C \\exp(-\\delta t)\n$$\n我们使用初始条件 $m(0) = \\frac{r_0}{\\delta}$ 来确定 $C$：\n$$\nm(0) = \\frac{r_1}{\\delta} + C \\exp(-\\delta \\cdot 0) = \\frac{r_1}{\\delta} + C\n$$\n$$\n\\frac{r_0}{\\delta} = \\frac{r_1}{\\delta} + C \\implies C = \\frac{r_0}{\\delta} - \\frac{r_1}{\\delta} = \\frac{r_0 - r_1}{\\delta}\n$$\n将 $C$ 代回 $m(t)$ 的解中，我们得到 $t \\geq 0$ 的完整解：\n$$\nm(t) = \\frac{r_1}{\\delta} + \\left( \\frac{r_0 - r_1}{\\delta} \\right) \\exp(-\\delta t)\n$$\n这就是推导出的 $m(t)$ 动力学的解。\n\n接下来，我们需要计算时间 $t_{0.95}$。这被定义为 $m(t)$ 首次达到诱导后稳态值的 $0.95$ 的时间。诱导后稳态值 $m_{ss,1}$ 是 $m(t)$ 在 $t \\to \\infty$ 时的极限：\n$$\nm_{ss,1} = \\lim_{t \\to \\infty} m(t) = \\lim_{t \\to \\infty} \\left[ \\frac{r_1}{\\delta} + \\left( \\frac{r_0 - r_1}{\\delta} \\right) \\exp(-\\delta t) \\right] = \\frac{r_1}{\\delta}\n$$\n$t_{0.95}$ 的条件是 $m(t_{0.95}) = 0.95 \\times m_{ss,1} = 0.95 \\frac{r_1}{\\delta}$。\n我们将 $m(t)$ 的解设为这个值：\n$$\n\\frac{r_1}{\\delta} + \\left( \\frac{r_0 - r_1}{\\delta} \\right) \\exp(-\\delta t_{0.95}) = 0.95 \\frac{r_1}{\\delta}\n$$\n求解指数项：\n$$\n\\left( \\frac{r_0 - r_1}{\\delta} \\right) \\exp(-\\delta t_{0.95}) = 0.95 \\frac{r_1}{\\delta} - \\frac{r_1}{\\delta} = -0.05 \\frac{r_1}{\\delta}\n$$\n乘以 $\\delta$ 并化简：\n$$\n(r_0 - r_1) \\exp(-\\delta t_{0.95}) = -0.05 r_1\n$$\n$$\n\\exp(-\\delta t_{0.95}) = \\frac{-0.05 r_1}{r_0 - r_1} = \\frac{0.05 r_1}{r_1 - r_0}\n$$\n为了求解 $t_{0.95}$，我们对两边取自然对数：\n$$\n-\\delta t_{0.95} = \\ln\\left( \\frac{0.05 r_1}{r_1 - r_0} \\right)\n$$\n$$\nt_{0.95} = -\\frac{1}{\\delta} \\ln\\left( \\frac{0.05 r_1}{r_1 - r_0} \\right) = \\frac{1}{\\delta} \\ln\\left( \\left(\\frac{0.05 r_1}{r_1 - r_0}\\right)^{-1} \\right) = \\frac{1}{\\delta} \\ln\\left( \\frac{r_1 - r_0}{0.05 r_1} \\right)\n$$\n现在，我们代入给定的参数值：$r_0 = 10\\,\\text{molecules min}^{-1}$，$r_1 = 50\\,\\text{molecules min}^{-1}$，以及 $\\delta = 0.2\\,\\text{min}^{-1}$。\n$$\nt_{0.95} = \\frac{1}{0.2} \\ln\\left( \\frac{50 - 10}{0.05 \\times 50} \\right)\n$$\n$$\nt_{0.95} = 5 \\ln\\left( \\frac{40}{2.5} \\right)\n$$\n$$\nt_{0.95} = 5 \\ln(16)\n$$\n由于 $\\ln(16) = \\ln(2^4) = 4\\ln(2)$，精确的符号解是 $20\\ln(2)$。为了获得数值，我们使用 $\\ln(2) \\approx 0.693147...$。\n$$\nt_{0.95} = 20 \\times \\ln(2) \\approx 13.8629436...\n$$\n问题要求将结果四舍五入到四位有效数字。前四位有效数字是 $1$、$3$、$8$ 和 $6$。随后的数字是 $2$，所以我们向下舍入。\n$$\nt_{0.95} \\approx 13.86\\,\\text{min}\n$$",
            "answer": "$$\n\\boxed{13.86}\n$$"
        },
        {
            "introduction": "在中心法则的最后一步——翻译过程中，分子机器的物理运动和相互作用带来了更丰富的动态行为。核糖体在mRNA链上的移动并非畅通无阻，它们的交通拥堵（即排队）现象可以通过“完全不对称简单排除过程”（TASEP）等统计物理模型来精确刻画。更有趣的是，这种核糖体的占据本身可以形成一道物理屏障，保护mRNA免于降解，从而构成一个精巧的反馈回路。这项高级计算练习  要求我们亲手实现一个随机模拟（Gillespie算法），以探索这一复杂系统的涌现特性，例如核糖体队列如何出乎意料地延长mRNA的寿命，从而将理论模型与现代合成生物学中的计算实践紧密联系起来。",
            "id": "2782553",
            "problem": "您需要实现一个将翻译与信使RNA (mRNA) 衰变耦合的机制模拟，以量化核糖体排队如何改变mRNA的稳定性。使用分子生物学的中心法则作为基础：翻译是核糖体介导的、将mRNA上的密码子解码为多肽的过程，该过程沿mRNA单向进行；而mRNA的衰变由核糖核酸酶执行，核糖核酸酶的接触会受到核糖体占据的阻碍。翻译动力学必须建模为完全非对称简单排斥过程 (TASEP)，这是一个具有单向移动和硬排斥特性的连续时间随机过程。mRNA的衰变必须通过一个风险率（瞬时衰变率）来建模，该风险率是平均核糖体覆盖率（被核糖体保护的密码子比例）的单调递减函数。您的任务是从第一性原理出发，计算有效的mRNA寿命。\n\n需要实现的模型规范：\n- 晶格和粒子：\n  - mRNA包含 $L$ 个密码子位点，标记为 $1,2,\\dots,L$。\n  - 每个核糖体是一个扩展粒子，足迹长度为 $\\ell$ 个密码子。头部位于位置 $p$ ($1 \\le p \\le L - \\ell + 1$) 的核糖体占据密码子 $p, p+1, \\dots, p+\\ell-1$。\n- 动力学：\n  - 当且仅当密码子 $1$ 到 $\\ell$ 为空时，起始以速率 $\\alpha$ (单位 $\\mathrm{s}^{-1}$) 发生；起始过程将一个核糖体放置在头部位置 $p=1$ 处。\n  - 延伸是位点依赖的：每个密码子的延伸速率数组 $\\{k_i\\}_{i=1}^L$ (单位 $\\mathrm{s}^{-1}$) 为每个密码子分配一个速率。头部位于 $p$ 的核糖体，在密码子 $p+\\ell$ 为空（硬排斥）的情况下，尝试以速率 $k_{p+\\ell-1}$ 将其头部前进到 $p+1$。如果 $p = L - \\ell + 1$，尝试前进对应于终止，核糖体以速率 $k_L$ 离开，并清空其整个足迹。\n  - 所有反应都发生在连续时间内，并根据Gillespie随机模拟算法一次执行一个：在任何状态下，枚举所有当前可发生的事件及其速率，从均值为总速率倒数的指数分布中抽取下一个反应时间，并根据事件速率按比例选择哪个事件发生。\n- 覆盖率：\n  - 将瞬时覆盖率 $\\rho(t)$ 定义为在时间 $t$ 当前被任一核糖体占据的密码子比例，即被占据的密码子数除以 $L$。\n  - 将测量窗口内的时间平均覆盖率定义为 $\\bar{\\rho} = \\frac{1}{T_{\\mathrm{meas}}} \\int_{t_0}^{t_0 + T_{\\mathrm{meas}}} \\rho(t)\\, dt$，其中 $t_0$ 是一个预热时间，以使TASEP过程接近稳态，而 $T_{\\mathrm{meas}}$ 是测量窗口的持续时间。\n- 衰变耦合与寿命：\n  - 设基线（未受保护的）衰变速率为 $\\delta_0$ (单位 $\\mathrm{s}^{-1}$)。通过单调、严格为正的映射将衰变与覆盖率耦合\n    $$ \\delta(\\bar{\\rho}) = \\delta_0 \\exp(-\\beta \\bar{\\rho}), $$\n    其中 $\\beta \\ge 0$ 是一个控制核糖体保护强度的无量纲参数。\n  - 假设覆盖过程在比mRNA衰变快得多的时间尺度上达到稳态，则在mRNA的整个寿命期间将 $\\delta(\\bar{\\rho})$ 视为常数。那么，有效的mRNA寿命为\n    $$ \\tau = \\frac{1}{\\delta(\\bar{\\rho})}. $$\n  - 以秒为单位报告 $\\tau$，四舍五入到小数点后 $3$ 位。\n- 模拟协议和单位：\n  - 时间单位使用秒，所有速率单位使用 $\\mathrm{s}^{-1}$。\n  - 使用扩展粒子TASEP的连续时间Gillespie模拟，通过时间平均来估计 $\\bar{\\rho}$。使用 $T_{\\mathrm{warm}} = 40$ 秒的预热时间，然后是 $T_{\\mathrm{meas}} = 160$ 秒的测量窗口（因此总模拟时间 $T_{\\mathrm{total}} = 200$ 秒）。如果没有事件可能发生（总速率为 $0$），系统此后保持静态。\n  - 为保证可复现性，使用固定的随机种子 $0$。\n- 输出格式：\n  - 您的程序应生成单行输出，其中包含下面测试套件的寿命，格式为方括号内以逗号分隔的列表，单位为秒，每个值四舍五入到小数点后 $3$ 位。例如，包含三个结果的输出应类似于“[x1,x2,x3]”，其中 $x_1$、$x_2$ 和 $x_3$ 是四舍五入后的寿命值。\n\n需要实现和评估的测试套件：\n所有案例均使用 $L = 60$ 个密码子和核糖体足迹 $\\ell = 10$ 个密码子。在每个案例中，按如下方式定义 $k_i$ (单位 $\\mathrm{s}^{-1}$)：除非另有说明，对于所有 $i$，$k_i = 10$。在指定慢速区域的案例中，为密码子索引 $i \\in \\{25,26,27,28,29,30\\}$ 设置 $k_i = 1$（这些索引是基于 $1$ 的）。\n- 案例 1 (标准情况，均一延伸，中等起始速率)：$\\alpha = 0.6$，对所有 $i$，$k_i = 10$，$\\delta_0 = 1/300$，$\\beta = 3.0$。\n- 案例 2 (因慢速密码子导致排队，高起始速率)：$\\alpha = 1.0$，$k_i = 10$，但对于 $i \\in \\{25,\\dots,30\\}$，$k_i = 1$，$\\delta_0 = 1/300$，$\\beta = 3.0$。\n- 案例 3 (边界情况，无起始)：$\\alpha = 0.0$，对所有 $i$，$k_i = 10$，$\\delta_0 = 1/300$，$\\beta = 3.0$。\n- 案例 4 (排队情况下衰变敏感性强)：$k_i$ 和 $\\alpha$ 与案例 2 相同，$\\delta_0 = 1/300$，$\\beta = 8.0$。\n- 案例 5 (排队情况下衰变敏感性弱)：$k_i$ 和 $\\alpha$ 与案例 2 相同，$\\delta_0 = 1/300$，$\\beta = 0.5$。\n\n交付内容：\n- 实现上述模型，通过在 $[T_{\\mathrm{warm}}, T_{\\mathrm{warm}} + T_{\\mathrm{meas}}]$ 上进行时间平均来计算 $\\bar{\\rho}$，为每个案例计算 $\\delta(\\bar{\\rho})$ 和 $\\tau = 1/\\delta(\\bar{\\rho})$，并打印一行包含 $5$ 个寿命值的列表，单位为秒，四舍五入到小数点后 $3$ 位，格式为“[v1,v2,v3,v4,v5]”。",
            "solution": "所陈述的问题是有效的。它具有科学依据，定义明确，并且模拟所需的所有参数和动力学规则都得到了清晰的界定。该模型将完全非对称简单排斥过程 (TASEP)——一个用于输运现象的统计物理学经典模型——与一个受生物学启发的、通过核糖体保护来调节mRNA衰变的机制相结合。任务是通过直接随机模拟来计算一个派生量，即有效的mRNA寿命。其方法论源于问题规范。\n\n解决方案的核心是为指定的连续时间马尔可夫过程实现Gillespie随机模拟算法 (SSA)。系统在任何时间 $t$ 的状态完全由mRNA晶格上核糖体的位置集合来描述。在计算上，我们使用一个为晶格上每个核糖体 $j$ 记录其头部整数位置 $\\{p_j\\}$ 的有序列表来表示此状态。这种表示方法能高效地识别可能的动力学事件。\n\n模拟通过迭代执行动力学事件来进行。在每一步，我们首先枚举从当前状态可能发生的所有事件及其相关速率：\n- **起始**：一个新的核糖体可以开始翻译，并将其头部置于位置 $p=1$。该事件仅在所需的整个足迹范围，即密码子 $1$ 到 $\\ell$，都未被占据时才可能发生。如果可能，此事件的速率是恒定的起始速率 $\\alpha$。\n- **前进**：晶格上已有的每个核糖体 $j$（头部位于 $p_j$），可能会前进到 $p_j+1$。此事件代表一步延伸，或者如果 $p_j = L - \\ell + 1$，则代表终止。该事件仅在没有空间位阻时才可能发生。对于足迹为 $\\ell$ 的扩展粒子，从 $p_j$ 移动到 $p_j+1$ 要求位点 $p_j+\\ell$ 未被占据。序列中的下一个核糖体位于位置 $p_{j+1}$，因此该条件等效于 $p_{j+1} > p_j+\\ell$。对于终止，位于 $p_j = L - \\ell+1$ 的核糖体移出晶格，因此其目标位置总被视为空闲。从位置 $p_j$ 前进的速率由位点依赖的延伸速率 $k_{p_j+\\ell-1}$ 给出。\n\n一旦所有可能事件及其速率 $\\{r_i\\}$ 的列表被汇编完成，Gillespie算法按以下步骤进行：\n$1$. 计算任何事件发生的总速率：$R_{\\text{total}} = \\sum_i r_i$。如果 $R_{\\text{total}} = 0$，系统已达到吸收态，模拟时间将前进到测量周期结束。\n$2$. 下一个事件发生前的时间 $\\Delta t$ 从均值为 $1/R_{\\text{total}}$ 的指数分布中抽取，即 $\\Delta t = -(1/R_{\\text{total}}) \\ln(U_1)$，其中 $U_1$ 是来自 $(0,1)$ 上均匀分布的一个随机变量。\n$3$. 以概率 $r_j / R_{\\text{total}}$ 选择事件 $j$ 发生。这通过抽取第二个均匀随机变量 $U_2$ 并选择满足 $\\sum_{i=1}^{j-1} r_i  U_2 R_{\\text{total}} \\le \\sum_{i=1}^{j} r_i$ 的事件 $j$ 来实现。\n$4$. 根据所选事件更新系统状态（添加、移动或移除一个核糖体），并将模拟时间推进 $\\Delta t$。\n\n为了计算时间平均覆盖率 $\\bar{\\rho}$，我们必须评估积分 $\\bar{\\rho} = \\frac{1}{T_{\\mathrm{meas}}} \\int_{T_{\\mathrm{warm}}}^{T_{\\mathrm{warm}} + T_{\\mathrm{meas}}} \\rho(t)\\, dt$。在数值上，这通过累加瞬时覆盖率 $\\rho(t)$ 与系统保持在该状态的持续时间 $\\Delta t$ 的乘积来完成。瞬时覆盖率是 $\\rho(t) = N(t) \\cdot \\ell / L$，其中 $N(t)$ 是mRNA上的核糖体数量。在模拟循环中，对于在时间 $t$ 和 $t+\\Delta t$ 之间发生的每个时间步 $\\Delta t$，我们将贡献 $\\rho(t) \\cdot \\Delta t'$ 添加到一个运行总和中，其中 $\\Delta t'$ 是区间 $[t, t+\\Delta t)$ 落在测量窗口 $[T_{\\mathrm{warm}}, T_{\\mathrm{warm}}+T_{\\mathrm{meas}}]$ 内的部分。\n\n在总时间 $T_{\\mathrm{total}} = T_{\\mathrm{warm}} + T_{\\mathrm{meas}}$ 模拟完成后，时间平均覆盖率计算为 $\\bar{\\rho} = (\\text{累积积分值}) / T_{\\mathrm{meas}}$。\n\n最后，使用提供的公式根据此平均覆盖率确定有效的mRNA寿命 $\\tau$，该公式模拟了核糖体对核糖核酸酶降解的保护作用：\n$$ \\tau = \\frac{1}{\\delta(\\bar{\\rho})} = \\frac{1}{\\delta_0 \\exp(-\\beta \\bar{\\rho})} $$\n对测试套件中指定的每组参数重复整个过程，并使用固定的随机种子以保证可复现性。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(L, l, alpha, k, delta0, beta, Twarm, Tmeas, seed):\n    \"\"\"\n    Runs a single Gillespie simulation of the TASEP model for ribosome traffic.\n\n    Args:\n        L (int): Length of the mRNA lattice in codons.\n        l (int): Footprint of a ribosome in codons.\n        alpha (float): Initiation rate (s^-1).\n        k (list[float]): List of per-codon elongation rates (s^-1).\n        delta0 (float): Baseline mRNA decay rate (s^-1).\n        beta (float): Dimensionless parameter for decay protection.\n        Twarm (float): Warm-up time (s).\n        Tmeas (float): Measurement time (s).\n        seed (int): Seed for the random number generator.\n    \n    Returns:\n        float: The calculated effective mRNA lifetime (tau).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    T_total = Twarm + Tmeas\n\n    time = 0.0\n    ribosome_heads = []  # Stores head positions, kept sorted\n    num_occupied_codons = 0\n    \n    # Using 1-based indexing for k to match problem statement's math notation\n    # k_rates[i] gives the rate for codon i\n    k_rates = np.array([0.0] + k) \n\n    # This stores the integral of rho(t) over the measurement window\n    integrated_rho_Tmeas = 0.0\n\n    while time  T_total:\n        events = []\n        rates = []\n\n        # 1. Enumerate all possible events and their rates\n        \n        # Event: Initiation\n        # Possible if codons 1..l are empty.\n        # This is true if there are no ribosomes, or the first one is at a position > l.\n        can_initiate = not ribosome_heads or ribosome_heads[0] > l\n        if can_initiate and alpha > 0:\n            events.append({'type': 'init', 'data': None})\n            rates.append(alpha)\n\n        # Event: Elongation/Termination for each ribosome\n        for i, p in enumerate(ribosome_heads):\n            # The rate of advancement from position p is determined by codon p + l - 1\n            rate = k_rates[p + l - 1]\n\n            # Hard exclusion rule: check if space ahead is free\n            is_space_ahead = True\n            # Check for collision with the next ribosome\n            if i + 1  len(ribosome_heads):\n                p_next = ribosome_heads[i+1]\n                # Site p+l is occupied if p_next = p+l.\n                if p_next = p + l:\n                    is_space_ahead = False\n            \n            if is_space_ahead and rate > 0:\n                event_type = 'term' if p == L - l + 1 else 'elong'\n                events.append({'type': event_type, 'data': i}) # data is the index of the ribosome\n                rates.append(rate)\n\n        total_rate = sum(rates)\n\n        # 2. Calculate time step for the Gillespie algorithm\n        current_rho = num_occupied_codons / L if L > 0 else 0\n        \n        if total_rate == 0:\n            # Absorbing state, no more events can occur. Advance time to end.\n            dt = T_total - time\n        else:\n            dt = rng.exponential(scale=1.0 / total_rate)\n\n        # 3. Accumulate coverage integral for the measurement window\n        integration_start = max(time, Twarm)\n        integration_end = min(time + dt, T_total)\n        interval_in_meas_window = max(0, integration_end - integration_start)\n        \n        if interval_in_meas_window > 0:\n            integrated_rho_Tmeas += current_rho * interval_in_meas_window\n\n        # 4. Advance time. If past T_total, exit loop.\n        time += dt\n        if time >= T_total:\n            break\n\n        # 5. Select and execute a single event\n        if total_rate > 0:\n            # Choose event proportional to its rate\n            norm_rates = np.array(rates) / total_rate\n            chosen_idx = rng.choice(len(events), p=norm_rates)\n            event = events[chosen_idx]\n            event_type, data = event['type'], event['data']\n\n            if event_type == 'init':\n                p_new = 1\n                ribosome_heads.insert(0, p_new) # keeps the list sorted\n                num_occupied_codons += l\n            \n            elif event_type == 'elong':\n                rib_idx = data\n                ribosome_heads[rib_idx] += 1\n                # num_occupied_codons does not change\n            \n            elif event_type == 'term':\n                rib_idx = data\n                ribosome_heads.pop(rib_idx)\n                num_occupied_codons -= l\n\n    # After simulation, calculate final results from observables\n    if Tmeas > 0:\n        avg_rho = integrated_rho_Tmeas / Tmeas\n    else:\n        avg_rho = 0.0\n\n    if delta0 > 0:\n        delta_eff = delta0 * math.exp(-beta * avg_rho)\n        tau = 1.0 / delta_eff\n    else:\n        tau = float('inf')\n\n    return tau\n\ndef solve():\n    # Define the test cases from the problem statement.\n    L = 60\n    l = 10\n    Twarm = 40.0\n    Tmeas = 160.0\n    seed = 0\n\n    k_uniform = [10.0] * L\n    \n    k_slow_region = [10.0] * L\n    # Slow region from codon 25 to 30 (1-based index)\n    for i in range(25, 31):\n        k_slow_region[i-1] = 1.0\n\n    test_cases = [\n        # Case 1: uniform elongation, moderate initiation\n        {'alpha': 0.6, 'k': k_uniform, 'delta0': 1/300.0, 'beta': 3.0},\n        # Case 2: queueing due to slow codons, high initiation\n        {'alpha': 1.0, 'k': k_slow_region, 'delta0': 1/300.0, 'beta': 3.0},\n        # Case 3: no initiation\n        {'alpha': 0.0, 'k': k_uniform, 'delta0': 1/300.0, 'beta': 3.0},\n        # Case 4: strong decay sensitivity under queueing\n        {'alpha': 1.0, 'k': k_slow_region, 'delta0': 1/300.0, 'beta': 8.0},\n        # Case 5: weak decay sensitivity under queueing\n        {'alpha': 1.0, 'k': k_slow_region, 'delta0': 1/300.0, 'beta': 0.5},\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = run_simulation(L, l, case['alpha'], case['k'], case['delta0'], case['beta'], Twarm, Tmeas, seed)\n        results.append(f\"{tau:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n```"
        }
    ]
}