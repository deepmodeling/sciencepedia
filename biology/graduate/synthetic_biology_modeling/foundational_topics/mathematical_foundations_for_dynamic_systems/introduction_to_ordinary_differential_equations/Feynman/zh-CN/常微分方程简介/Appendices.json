{
    "hands_on_practices": [
        {
            "introduction": "我们将从合成生物学中最基础的模块——组成型基因表达——开始我们的实践。这个系统的动力学行为可以用一个一阶线性常微分方程来精确描述，该方程刻画了分子（如mRNA）在持续生成和一级降解之间的动态平衡。通过解析求解这个方程，你将掌握分析生物分子浓度随时间变化的基本技能，并为理解更复杂的调控网络奠定坚实的基础。",
            "id": "2045672",
            "problem": "在合成生物学领域，工程师们设计和构建新颖的生物回路。考虑其中最简单的一种电路，一个在细菌中实现的“组成型基因表达”模块。在该模块中，一个特定的基因以恒定的速率（记为 $k$）持续转录成信使核糖核酸（mRNA）。同时，mRNA分子被细胞内的酶主动降解。该降解过程被建模为一级反应，意味着降解速率与当前mRNA的浓度 $m(t)$ 成正比。该降解的比例常数为 $\\gamma$。因此，mRNA浓度随时间变化的净速率由以下微分方程决定：\n\n$$\n\\frac{dm}{dt} = k - \\gamma m(t)\n$$\n\n假设 $k$ 和 $\\gamma$ 是正实数常数，求出mRNA浓度 $m(t)$ 的通解。你的答案应为一个包含 $k$、$\\gamma$、$t$ 以及一个积分常数 $C$ 的表达式。",
            "solution": "我们已知关于mRNA浓度的一阶线性常微分方程：\n$$\n\\frac{dm}{dt} = k - \\gamma m(t).\n$$\n将其改写为标准线性形式，得到\n$$\n\\frac{dm}{dt} + \\gamma m(t) = k.\n$$\n这是一个常系数线性常微分方程。适用积分因子法。积分因子为\n$$\n\\mu(t) = \\exp\\left(\\int \\gamma \\, dt\\right) = \\exp(\\gamma t).\n$$\n将微分方程两边同乘以 $\\exp(\\gamma t)$，得到\n$$\n\\exp(\\gamma t)\\frac{dm}{dt} + \\gamma \\exp(\\gamma t) m(t) = k \\exp(\\gamma t).\n$$\n根据乘积法则，左边是 $\\exp(\\gamma t) m(t)$ 的全导数：\n$$\n\\frac{d}{dt}\\big(\\exp(\\gamma t) m(t)\\big) = k \\exp(\\gamma t).\n$$\n对两边关于 $t$ 积分，得到\n$$\n\\exp(\\gamma t) m(t) = \\int k \\exp(\\gamma t)\\, dt + C = \\frac{k}{\\gamma} \\exp(\\gamma t) + C,\n$$\n其中 $C$ 是一个任意积分常数。解出 $m(t)$，得到\n$$\nm(t) = \\frac{k}{\\gamma} + C \\exp(-\\gamma t).\n$$\n这就是通解，其中 $C$ 由给定的初始条件（如果有的话）确定。稳态值为 $\\frac{k}{\\gamma}$，由于 $\\gamma0$，瞬态部分以 $\\exp(-\\gamma t)$ 的形式衰减。",
            "answer": "$$\\boxed{\\frac{k}{\\gamma} + C \\exp(-\\gamma t)}$$"
        },
        {
            "introduction": "接下来，我们将探讨一种在生物网络中普遍存在的调控基序：负反馈自抑制。与线性系统不同，这里的蛋白质生成速率会随着其自身浓度的增加而受到抑制，从而引入了非线性。求解非线性微分方程的完整动态过程通常很复杂，因此，一个核心的分析方法是找出系统的稳态，即系统达到平衡时的状态，这能帮助我们深刻理解负反馈对系统最终行为的决定性影响。",
            "id": "2045681",
            "problem": "在一个细菌体内设计的人工基因回路中，一种特定的蛋白质作为其自身合成的阻遏蛋白。这是一种常见的负反馈基序，称为自我抑制。该蛋白质的浓度（用 $P$ 表示）随时间演变，遵循以下常微分方程，该方程代表了系统动力学的一个简化模型：\n$$\n\\frac{dP}{dt} = \\frac{k}{1+P} - \\gamma P\n$$\n在此模型中，项 $\\frac{k}{1+P}$ 描述了蛋白质的生成速率，该速率随着浓度 $P$ 的增加而受到抑制。项 $-\\gamma P$ 代表蛋白质的一阶降解和稀释。参数 $k$ 和 $\\gamma$ 是正常数，分别代表最大生成速率和降解/稀释速率常数。\n\n假设系统随时间达到一个稳定状态，请找出具有物理意义（即为正值）的稳态蛋白质浓度 $P_{ss}$ 关于参数 $k$ 和 $\\gamma$ 的符号表达式。",
            "solution": "蛋白质的稳态浓度 $P_{ss}$ 是指 $P$ 随时间的变化率为零时的浓度。因此，我们必须令 $\\frac{dP}{dt} = 0$。\n\n从给定的微分方程开始：\n$$\n\\frac{dP}{dt} = \\frac{k}{1+P} - \\gamma P\n$$\n\n在稳态下，我们有：\n$$\n0 = \\frac{k}{1+P_{ss}} - \\gamma P_{ss}\n$$\n\n我们的目标是解这个代数方程以求出 $P_{ss}$。我们可以将方程重排如下：\n$$\n\\gamma P_{ss} = \\frac{k}{1+P_{ss}}\n$$\n\n现在，我们将方程两边同乘以 $(1+P_{ss})$ 以消去分母。这样做是有效的，因为蛋白质浓度 $P_{ss}$ 必须为非负值，所以 $1+P_{ss}$ 严格为正。\n$$\n\\gamma P_{ss} (1+P_{ss}) = k\n$$\n\n展开方程左边可得：\n$$\n\\gamma P_{ss} + \\gamma P_{ss}^2 = k\n$$\n\n为了求解 $P_{ss}$，我们可以将其整理成二次方程的标准形式 $ax^2 + bx + c = 0$，其中我们的变量是 $x = P_{ss}$：\n$$\n\\gamma P_{ss}^2 + \\gamma P_{ss} - k = 0\n$$\n\n我们可以使用二次方程求根公式 $P_{ss} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解这个关于 $P_{ss}$ 的二次方程，其中系数为 $a = \\gamma$，$b = \\gamma$，$c = -k$。\n\n将这些系数代入求根公式：\n$$\nP_{ss} = \\frac{-\\gamma \\pm \\sqrt{(\\gamma)^2 - 4(\\gamma)(-k)}}{2\\gamma}\n$$\n$$\nP_{ss} = \\frac{-\\gamma \\pm \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}\n$$\n\n这为我们提供了稳态浓度的两个可能解：\n1.  $P_{ss,1} = \\frac{-\\gamma + \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}$\n2.  $P_{ss,2} = \\frac{-\\gamma - \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}$\n\n我们必须选择具有物理意义的解。由于蛋白质浓度 $P$ 不能为负，我们需要确定每个解的符号。已知参数 $k$ 和 $\\gamma$ 是正常数。\n\n对于第二个解 $P_{ss,2}$，分子是两项负数（$-\\gamma$ 和 $-\\sqrt{\\gamma^2 + 4\\gamma k}$）之和，因此它显然是负的。分母 $2\\gamma$ 是正的。因此，$P_{ss,2}$ 是一个负值，这在物理上是不可能的。\n\n对于第一个解 $P_{ss,1}$，我们来分析平方根下的项。由于 $k  0$ 和 $\\gamma  0$，项 $4\\gamma k$ 是正的。因此，$\\gamma^2 + 4\\gamma k  \\gamma^2$，取平方根得到 $\\sqrt{\\gamma^2 + 4\\gamma k}  \\sqrt{\\gamma^2} = \\gamma$。这意味着分子 $-\\gamma + \\sqrt{\\gamma^2 + 4\\gamma k}$ 是一个正值。由于分母 $2\\gamma$ 也是正的，所以 $P_{ss,1}$ 是正的。\n\n因此，唯一具有物理意义的稳态浓度是：\n$$\nP_{ss} = \\frac{-\\gamma + \\sqrt{\\gamma^2 + 4\\gamma k}}{2\\gamma}\n$$\n\n该表达式可以通过将分子和分母同除以 $\\gamma$ 来进一步简化：\n$$\nP_{ss} = \\frac{-1 + \\frac{\\sqrt{\\gamma^2 + 4\\gamma k}}{\\gamma}}{2} = \\frac{-1 + \\sqrt{\\frac{\\gamma^2 + 4\\gamma k}{\\gamma^2}}}{2} = \\frac{-1 + \\sqrt{1 + \\frac{4k}{\\gamma}}}{2}\n$$\n这就是正值稳态蛋白质浓度的最终表达式。",
            "answer": "$$ \\boxed{ \\frac{-1 + \\sqrt{1 + \\frac{4k}{\\gamma}}}{2} } $$"
        },
        {
            "introduction": "在现实世界中，许多合成生物学系统的数学模型由于其复杂性而无法求得解析解，此时数值方法便成为不可或缺的工具。本练习将引导你从第一性原理出发，推导并实现前向欧拉法，这是一种基础的数值积分方法。更重要的是，你将深入分析该方法的局部截断误差和稳定性，这些是确保计算模型可靠性和准确性的关键理论支柱。",
            "id": "3916443",
            "problem": "您正在合成生物学中，基于一阶质量作用动力学，对单个基因产物浓度 $x(t)$ 进行建模。在此背景下，控制常微分方程 (ODE) 的形式为 $x'(t) = f(x(t))$，其中 $x'(t)$ 表示 $x(t)$ 的时间导数，$f$ 是一个代表净生成和降解的足够光滑的函数。仅降解的情况是 $x'(t) = -\\lambda x(t)$，其中 $\\lambda  0$，$\\lambda$ 是衰变率，单位为 $\\mathrm{h}^{-1}$（每小时）。生成与降解模型是 $x'(t) = k - \\lambda x(t)$，其中恒定生成速率 $k$ 的单位是浓度每小时，衰变率 $\\lambda$ 的单位是 $\\mathrm{h}^{-1}$。使用导数的定义和光滑性假设，构建一个一阶显式时间步进算法，用于在微小时间增量 $h  0$ 上从 $x(t)$ 近似计算 $x(t+h)$，过程中不使用任何预先给定的更新公式。\n\n从一个有效的数学基础出发，特别是导数的定义 $x'(t) = \\lim_{h \\to 0} \\frac{x(t+h) - x(t)}{h}$、$x(t)$ 的光滑性以及在 $t$ 处的泰勒展开，推导单步局部截断误差 (LTE) 的主阶表达式。LTE 定义为当当前值等于该步的精确解时，在一步中产生的误差。证明对于光滑的 $f$，LTE 与 $O(h^2)$ 同阶，并用 $f$ 及其在当前状态下求值的导数来明确表示主阶系数。仅使用经过充分检验的事实作为基础，例如链式法则和泰勒级数。不要使用或假设任何步进更新公式，而是要推导它们。\n\n然后，分析并陈述所推导的显式方法在应用于衰变模型 $x'(t) = -\\lambda x(t)$（其中 $\\lambda  0$）时的稳定性约束。此处的稳定性意味着，对于大的迭代次数，数值解的量值会单调衰减至零，这与连续动力学的行为一致。确定数值格式中为实现渐近衰减所需的对乘积 $h \\lambda$ 的约束。讨论当乘积 $h \\lambda$ 等于区分衰减与非衰减的极值时的边界情况，并说明根据所述定义，该情况是否应被视为稳定。\n\n您的程序必须为通用的 $f(x)$ 实现所推导的显式方法，并为指定的测试套件计算以下量。所有输出都是无量纲的。如果出现物理参数（例如，单位为 $\\mathrm{h}^{-1}$ 的 $\\lambda$），您必须确保计算中一致地使用它，但最终报告的答案是按规定格式的无单位浮点数或布尔值：\n\n- 对于从 $t = 0$ 和精确初始值 $x(0)$ 开始的单步，计算单步LTE比率，定义为 $\\frac{|x_{\\text{exact}}(h) - x_{\\text{explicit}}(h)|}{h^2}$，其中 $x_{\\text{exact}}(h)$ 是在 $t = h$ 处求值的精确解，$x_{\\text{explicit}}(h)$ 是从 $x(0)$ 开始的显式方法的单步近似值。使用测试套件中两个ODE的精确解公式来计算 $x_{\\text{exact}}(h)$：\n    - 对于 $x'(t) = -\\lambda x(t)$，精确的下一个值是 $x_{\\text{exact}}(h) = x(0) e^{-\\lambda h}$。\n    - 对于 $x'(t) = k - \\lambda x(t)$，精确的下一个值是 $x_{\\text{exact}}(h) = \\frac{k}{\\lambda} + \\left(x(0) - \\frac{k}{\\lambda}\\right) e^{-\\lambda h}$。\n\n- 对于稳定性，根据您为 $h \\lambda$ 推导的约束，计算一个布尔值：如果应用于 $x'(t) = -\\lambda x(t)$ 的显式方法会随着步数增加而单调衰减至零，则该值为 $\\text{True}$，否则为 $\\text{False}$。根据单调衰减的定义，将恰好处于极值的边界情况视为不稳定。\n\n测试套件（每一项都是独立的，程序必须按顺序为每一项输出一个结果）：\n\n1. 纯衰变模型的单步LTE比率，参数为 $x(0) = 1.0$，$\\lambda = 1.0\\,\\mathrm{h}^{-1}$，步长 $h = 0.1\\,\\mathrm{h}$。\n2. 纯衰变模型的单步LTE比率，参数为 $x(0) = 1.0$，$\\lambda = 2.0\\,\\mathrm{h}^{-1}$，步长 $h = 0.05\\,\\mathrm{h}$。\n3. 生成与降解模型的单步LTE比率，参数为 $x(0) = 0.5$，$k = 3.0$（浓度每小时），$\\lambda = 1.0\\,\\mathrm{h}^{-1}$，步长 $h = 0.2\\,\\mathrm{h}$。\n4. 纯衰变模型的稳定性布尔值，参数为 $\\lambda = 0.5\\,\\mathrm{h}^{-1}$ 和 $h = 1.0\\,\\mathrm{h}$。\n5. 纯衰变模型的稳定性布尔值，参数为 $\\lambda = 1.0\\,\\mathrm{h}^{-1}$ 和 $h = 2.0\\,\\mathrm{h}$（边界情况）。\n6. 纯衰变模型的稳定性布尔值，参数为 $\\lambda = 3.0\\,\\mathrm{h}^{-1}$ 和 $h = 0.8\\,\\mathrm{h}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\texttt{[result1,result2,result3,result4,result5,result6]}$）。每个LTE比率必须是浮点数，每个稳定性指标必须是布尔值。不应打印任何额外文本。",
            "solution": "我们从导数的定义和解的光滑性开始。设 $x(t)$ 是常微分方程 (ODE) $x'(t) = f(x(t))$ 的解，其中 $f$ 足够光滑。导数的定义是 $x'(t) = \\lim_{h \\to 0} \\frac{x(t+h) - x(t)}{h}$。对于小的 $h  0$，我们使用光滑函数的一阶泰勒展开来近似 $x(t+h)$：\n$$\nx(t+h) = x(t) + h x'(t) + \\frac{h^2}{2} x''(t) + O(h^3).\n$$\n代入 ODE $x'(t) = f(x(t))$ 得到：\n$$\nx(t+h) = x(t) + h f(x(t)) + \\frac{h^2}{2} x''(t) + O(h^3).\n$$\n为了推导一个简单的显式步进规则，我们在保留一阶项后进行截断，并使用 $x(t+h) \\approx x(t) + h f(x(t))$。这个规则被称为前向（显式）欧拉法，它是直接从导数定义和泰勒级数推导出来的，而无需事先假设。\n\n为了量化从精确值 $x(t)$ 开始时在一步内产生的误差，我们将单步局部截断误差 (LTE) 定义为：\n$$\n\\mathrm{LTE}(h; t) = x(t+h) - \\left[x(t) + h f(x(t))\\right].\n$$\n使用泰勒展开，我们有：\n$$\n\\mathrm{LTE}(h; t) = \\frac{h^2}{2} x''(t) + O(h^3).\n$$\n因此，LTE 与 $O(h^2)$ 同阶，主阶系数为 $\\frac{1}{2} x''(t)$。为了用 $f$ 表示 $x''(t)$，我们应用链式法则：\n$$\nx''(t) = \\frac{d}{dt} x'(t) = \\frac{d}{dt} f\\big(x(t)\\big) = f'\\big(x(t)\\big) \\cdot x'(t) = f'\\big(x(t)\\big) \\cdot f\\big(x(t)\\big).\n$$\n因此，主阶 LTE 是：\n$$\n\\mathrm{LTE}(h; t) = \\frac{h^2}{2} f'\\big(x(t)\\big) f\\big(x(t)\\big) + O(h^3).\n$$\n当 $h \\to 0$ 时，比率 $\\frac{|\\mathrm{LTE}(h; t)|}{h^2}$ 趋向于 $\\left|\\frac{1}{2} f'(x(t)) f(x(t))\\right|$。\n\n现在考虑衰变模型 $x'(t) = -\\lambda x(t)$（其中 $\\lambda  0$）的稳定性。将前向欧拉法应用于此测试方程，得到递推关系：\n$$\nx_{n+1} = x_n + h \\left(-\\lambda x_n\\right) = \\left(1 - h \\lambda\\right) x_n.\n$$\n精确解呈指数衰减：$x(t) = x(0) e^{-\\lambda t}$。为了使数值方法在单调衰减至零的意义上是渐近稳定的，放大因子必须满足：\n$$\n\\left|1 - h \\lambda\\right|  1,\n$$\n这意味着\n$$\n0  h \\lambda  2.\n$$\n如果 $h \\lambda = 2$，则 $1 - h \\lambda = -1$，数值解会在正负号之间以恒定幅值振荡；根据要求单调衰减的既定定义，此边界情况是不稳定的。如果 $h \\lambda > 2$，则 $\\left|1 - h \\lambda\\right| > 1$，导致发散。如果 $h \\lambda \\in (0, 2)$，该方法会产生一个幅值单调递减的序列，与连续衰减的行为一致。\n\n为了计算单步LTE比率 $\\frac{|x_{\\text{exact}}(h) - x_{\\text{explicit}}(h)|}{h^2}$，我们可以使用指定模型的精确解：\n- 对于 $x'(t) = -\\lambda x(t)$，给定 $x(0)$，精确的下一个值是 $x_{\\text{exact}}(h) = x(0) e^{-\\lambda h}$，而显式欧拉法的单步值是 $x_{\\text{explicit}}(h) = x(0) + h \\left(-\\lambda x(0)\\right) = x(0) \\left(1 - \\lambda h\\right)$。LTE 是 $x(0) \\left(e^{-\\lambda h} - (1 - \\lambda h)\\right)$，因此比率为：\n$$\n\\frac{|x_{\\text{exact}}(h) - x_{\\text{explicit}}(h)|}{h^2} = \\frac{x(0) \\left|e^{-\\lambda h} - (1 - \\lambda h)\\right|}{h^2}.\n$$\n当 $h \\to 0$ 时，该比率趋向于 $\\frac{1}{2} \\lambda^2 x(0)$，这与 $\\frac{1}{2} f'(x) f(x)$ 一致，因为 $f(x) = -\\lambda x$ 得到 $f'(x) = -\\lambda$，且 $f'(x) f(x) = \\lambda^2 x$。\n\n- 对于 $x'(t) = k - \\lambda x(t)$，精确的下一个值是 $x_{\\text{exact}}(h) = \\frac{k}{\\lambda} + \\left(x(0) - \\frac{k}{\\lambda}\\right) e^{-\\lambda h}$，而显式欧拉法的单步值是 $x_{\\text{explicit}}(h) = x(0) + h \\left(k - \\lambda x(0)\\right)$。单步LTE比率为：\n$$\n\\frac{\\left|\\frac{k}{\\lambda} + \\left(x(0) - \\frac{k}{\\lambda}\\right) e^{-\\lambda h} - \\left[x(0) + h \\left(k - \\lambda x(0)\\right)\\right]\\right|}{h^2},\n$$\n当 $h \\to 0$ 时，该比率趋向于 $\\left|\\frac{1}{2} x''(0)\\right| = \\left|\\frac{1}{2} \\left(-\\lambda k + \\lambda^2 x(0)\\right)\\right|$，因为 $x''(t) = -\\lambda (k - \\lambda x(t))$。\n\n该程序实现了上面推导的显式欧拉步，并计算：\n- 使用精确解计算指定单步情景的LTE比率。\n- 使用条件 $0  h \\lambda  2$ 计算稳定性布尔值，其中边界 $h \\lambda = 2$ 被视为不稳定。\n\n输出是无量纲的浮点数和布尔值，格式为单行的、用方括号括起来的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef euler_step(x, h, f):\n    \"\"\"\n    One-step forward Euler update for x' = f(x).\n    \"\"\"\n    return x + h * f(x)\n\ndef exact_next_decay(x0, h, lam):\n    \"\"\"\n    Exact next value for x' = -lam * x with initial x(0) = x0.\n    \"\"\"\n    return x0 * np.exp(-lam * h)\n\ndef exact_next_synth_decay(x0, h, k, lam):\n    \"\"\"\n    Exact next value for x' = k - lam * x with initial x(0) = x0.\n    \"\"\"\n    x_ss = k / lam if lam != 0 else np.inf  # steady state; lam>0 in tests\n    return x_ss + (x0 - x_ss) * np.exp(-lam * h)\n\ndef lte_ratio_decay(x0, h, lam):\n    \"\"\"\n    One-step local truncation error ratio for decay model:\n    |x_exact(h) - x_euler(h)| / h^2\n    \"\"\"\n    f = lambda x: -lam * x\n    x_euler = euler_step(x0, h, f)\n    x_exact = exact_next_decay(x0, h, lam)\n    return abs(x_exact - x_euler) / (h * h)\n\ndef lte_ratio_synth_decay(x0, h, k, lam):\n    \"\"\"\n    One-step local truncation error ratio for synthesis-decay model:\n    |x_exact(h) - x_euler(h)| / h^2\n    \"\"\"\n    f = lambda x: k - lam * x\n    x_euler = euler_step(x0, h, f)\n    x_exact = exact_next_synth_decay(x0, h, k, lam)\n    return abs(x_exact - x_euler) / (h * h)\n\ndef stability_monotone_decay(lam, h):\n    \"\"\"\n    Stability boolean for explicit Euler applied to x' = -lam x.\n    Returns True iff 0  h*lam  2 (strict inequality for monotone decay).\n    \"\"\"\n    hl = h * lam\n    return (hl > 0.0) and (hl  2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each entry is a dict describing the case and parameters.\n    test_cases = [\n        # 1) LTE ratio for pure decay: x0=1.0, lam=1.0 h^-1, h=0.1 h\n        {\"type\": \"lte_decay\", \"x0\": 1.0, \"lam\": 1.0, \"h\": 0.1},\n        # 2) LTE ratio for pure decay: x0=1.0, lam=2.0 h^-1, h=0.05 h\n        {\"type\": \"lte_decay\", \"x0\": 1.0, \"lam\": 2.0, \"h\": 0.05},\n        # 3) LTE ratio for synthesis-decay: x0=0.5, k=3.0, lam=1.0 h^-1, h=0.2 h\n        {\"type\": \"lte_synth_decay\", \"x0\": 0.5, \"k\": 3.0, \"lam\": 1.0, \"h\": 0.2},\n        # 4) Stability boolean: lam=0.5 h^-1, h=1.0 h\n        {\"type\": \"stability\", \"lam\": 0.5, \"h\": 1.0},\n        # 5) Stability boolean (boundary): lam=1.0 h^-1, h=2.0 h\n        {\"type\": \"stability\", \"lam\": 1.0, \"h\": 2.0},\n        # 6) Stability boolean: lam=3.0 h^-1, h=0.8 h\n        {\"type\": \"stability\", \"lam\": 3.0, \"h\": 0.8},\n    ]\n\n    results = []\n    for case in test_cases:\n        ctype = case[\"type\"]\n        if ctype == \"lte_decay\":\n            x0 = case[\"x0\"]\n            lam = case[\"lam\"]\n            h = case[\"h\"]\n            result = lte_ratio_decay(x0, h, lam)\n            results.append(result)\n        elif ctype == \"lte_synth_decay\":\n            x0 = case[\"x0\"]\n            k = case[\"k\"]\n            lam = case[\"lam\"]\n            h = case[\"h\"]\n            result = lte_ratio_synth_decay(x0, h, k, lam)\n            results.append(result)\n        elif ctype == \"stability\":\n            lam = case[\"lam\"]\n            h = case[\"h\"]\n            result = stability_monotone_decay(lam, h)\n            results.append(result)\n        else:\n            # Should not occur; include a placeholder to maintain list length\n            results.append(None)\n\n    # Final print statement in the exact required format.\n    # Use repr for booleans; float formatting default is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}