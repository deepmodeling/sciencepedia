{
    "hands_on_practices": [
        {
            "introduction": "对任何生物系统进行建模的第一步，都是将其组分和相互作用转化为精确的数学语言。本练习旨在为遗传拨动开关这个经典系统构建常微分方程 ($ODEs$)，这是在合成生物学中建立和理解任何动态模型的必备基础技能。",
            "id": "2075463",
            "problem": "合成生物学中的一个基础电路是基因触发开关，它表现出双稳态行为。该电路由两个相互阻遏的基因构成。考虑一个包含两个此类基因的系统，即基因1和基因2。\n\n- 基因1编码阻遏蛋白1，其浓度用 $u$ 表示。\n- 基因2编码阻遏蛋白2，其浓度用 $v$ 表示。\n- 基因1的表达被阻遏蛋白2所阻遏。\n- 基因2的表达被阻遏蛋白1所阻遏。\n\n该系统的动力学可以用一对耦合的常微分方程 (ODEs) 来建模。每种阻遏蛋白的产生由一个阻遏型希尔函数描述，而它们的清除则由一个一级降解过程描述。\n\n我们来定义系统的参数：\n- $\\alpha_1$ 和 $\\alpha_2$ 分别是阻遏蛋白1和阻遏蛋白2的最大合成速率。\n- $K_1$ 是引起基因2半最大阻遏的阻遏蛋白1的浓度。\n- $K_2$ 是引起基因1半最大阻遏的阻遏蛋白2的浓度。\n- $n$ 是希尔系数，代表阻遏的协同性，假设两次相互作用的协同性相同。\n- $\\beta$ 是一级降解速率常数，假设两种阻遏蛋白的该常数相同。\n\n下列哪对方程正确地模拟了浓度 $u$ 和 $v$ 的变化率？\n\nA.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 K_2^n}{K_2^n + v^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2 K_1^n}{K_1^n + u^n} - \\beta v\n$$\n\nB.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 K_1^n}{K_1^n + u^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2 K_2^n}{K_2^n + v^n} - \\beta v\n$$\n\nC.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 v^n}{K_2^n + v^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2 u^n}{K_1^n + u^n} - \\beta v\n$$\n\nD.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1}{1 + v^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2}{1 + u^n} - \\beta v\n$$",
            "solution": "具有两个相互阻遏基因的基因触发开关是通过对每种阻遏蛋白的浓度建立质量平衡来进行建模的：浓度变化率等于合成速率减去降解速率。对于浓度为 $u$ 的阻遏蛋白1和浓度为 $v$ 的阻遏蛋白2，其通用形式为\n$$\n\\frac{du}{dt} = \\text{合成速率}_1(v) - \\beta u, \\quad \\frac{dv}{dt} = \\text{合成速率}_2(u) - \\beta v,\n$$\n其中 $\\beta$ 是两种阻遏蛋白共有的一级降解速率常数。\n\n因为每个基因的表达都被另一个基因的蛋白质产物所阻遏，所以合成项由以下形式的阻遏型希尔函数给出：\n$$\n\\text{合成速率}(x) = \\frac{\\alpha K^{n}}{K^{n} + x^{n}},\n$$\n该函数描述了以下特性：当阻遏物浓度 $x=0$ 时，合成速率达到最大值 $\\alpha$；当 $x=K$ 时，合成速率为半最大值 $\\alpha/2$。这里 $K$ 是产生半最大阻遏的阻遏蛋白浓度，$n$ 是希尔系数。\n\n根据问题中给出的参数定义：\n- 基因1（产生 $u$）被阻遏蛋白2（浓度为 $v$）所阻遏，半最大阻遏浓度为 $K_2$，因此\n$$\n\\text{合成速率}_1(v) = \\frac{\\alpha_1 K_2^n}{K_2^n + v^n}.\n$$\n- 基因2（产生 $v$）被阻遏蛋白1（浓度为 $u$）所阻遏，半最大阻遏浓度为 $K_1$，因此\n$$\n\\text{合成速率}_2(u) = \\frac{\\alpha_2 K_1^n}{K_1^n + u^n}.\n$$\n\n将这些项组合起来，得到耦合的常微分方程组为\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 K_2^n}{K_2^n + v^n} - \\beta u, \\quad \\frac{dv}{dt} = \\frac{\\alpha_2 K_1^n}{K_1^n + u^n} - \\beta v,\n$$\n这与选项 A 相匹配。\n\n相比之下，选项 B 错误地将每个基因描述为被自身的蛋白质产物所阻遏（自阻遏）；选项 C 使用了激活型（而非阻遏型）希尔函数形式的分子项；选项 D 忽略了半最大值常数 $K_1$ 和 $K_2$，这种形式只有在对浓度进行无量纲化处理后才适用，而本题并未指明要这样做。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "模型建立后，我们需要分析其行为。一个关键问题是识别系统的稳态并确定其稳定性，这决定了基因线路的长期行为。本练习将引导您对一个对称不动点进行完整的线性稳定性分析，通过计算雅可比矩阵及其特征值，您将掌握分类稳态并预测系统动态的核心技能。",
            "id": "3935272",
            "problem": "考虑一个经典的双基因遗传触发器，其中转录因子$X$抑制$Y$，而$Y$抑制$X$。令$x(t)$和$y(t)$表示由以下常微分方程(ODE)控制的无量纲蛋白质浓度：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1 + y^{n}} \\;-\\; x,\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1 + x^{n}} \\;-\\; y,\n$$\n其中$\\alpha0$是一个无量纲生产能力参数，$n\\geq 1$是抑制作用的希尔协同指数。假设一个对称操作模式，其中$n=2$（协同抑制），并假设系统被调整，以至于存在一个对称不动点$(x^{\\ast},y^{\\ast})$，满足$x^{\\ast}=y^{\\ast}=s$，其中$s=\\frac{1}{2}$。产生此对称不动点的$\\alpha$值的选择必须与常微分方程所蕴含的稳态约束一致。\n\n从基因表达的质量平衡原理（生产减去降解）出发，并使用给定常微分方程中的希尔抑制形式，执行以下操作：\n1. 当$n=2$时，推导$x^{\\ast}=y^{\\ast}=s$必须满足的代数稳态条件。使用此条件确定产生对称不动点$s=\\frac{1}{2}$所对应的$\\alpha$值。\n2. 在不动点$(x^{\\ast},y^{\\ast})=(\\frac{1}{2},\\frac{1}{2})$处构建向量场的雅可比矩阵$J$。\n3. 对于此参数选择，计算$J$的特征值$\\lambda$，并确定$\\text{tr}(J)$和$\\det(J)$的符号。\n4. 根据$\\text{tr}(J)$和$\\det(J)$的符号，将不动点的稳定性分类为结点或鞍点，使用的约定为：稳定结点对应$\\det(J)0$和$\\text{tr}(J)0$，不稳定结点对应$\\det(J)0$和$\\text{tr}(J)0$，鞍点对应$\\det(J)0$。使用稳定性代码$\\sigma$对分类进行编码，定义为：对于稳定结点$\\sigma=1$，对于不稳定结点$\\sigma=0$，对于鞍点$\\sigma=-1$。\n\n以两个特征值和稳定性代码的有序三元组形式$\\left(\\lambda_{1},\\lambda_{2},\\sigma\\right)$提供您的最终答案。无需四舍五入，答案必须是精确值。将最终答案表示为行矩阵。",
            "solution": "该问题的求解步骤如下：\n\n**1. 确定参数 $\\alpha$**\n在不动点 $(x^\\ast, y^\\ast)$ 处，时间导数 $\\frac{dx}{dt}$ 和 $\\frac{dy}{dt}$ 均为零。根据给定的常微分方程，我们得到稳态条件：\n$$ x = \\frac{\\alpha}{1 + y^{n}} \\quad \\text{和} \\quad y = \\frac{\\alpha}{1 + x^{n}} $$\n问题指定了一个对称不动点 $x^\\ast = y^\\ast = s = \\frac{1}{2}$，且希尔系数 $n=2$。将这些值代入任一稳态方程中：\n$$ s = \\frac{\\alpha}{1 + s^{n}} \\implies \\alpha = s(1 + s^{n}) $$\n代入具体数值：\n$$ \\alpha = \\frac{1}{2} \\left(1 + \\left(\\frac{1}{2}\\right)^{2}\\right) = \\frac{1}{2} \\left(1 + \\frac{1}{4}\\right) = \\frac{1}{2} \\cdot \\frac{5}{4} = \\frac{5}{8} $$\n因此，产生该不动点所需的参数值为 $\\alpha = \\frac{5}{8}$。\n\n**2. 构建雅可比矩阵 $J$**\n系统的雅可比矩阵 $J$ 定义为：\n$$ J(x,y) = \\begin{pmatrix} \\frac{\\partial (dx/dt)}{\\partial x}  \\frac{\\partial (dx/dt)}{\\partial y} \\\\ \\frac{\\partial (dy/dt)}{\\partial x}  \\frac{\\partial (dy/dt)}{\\partial y} \\end{pmatrix} $$\n计算各偏导数：\n$$ \\frac{\\partial (dx/dt)}{\\partial x} = -1 $$\n$$ \\frac{\\partial (dx/dt)}{\\partial y} = -\\frac{n\\alpha y^{n-1}}{(1+y^{n})^{2}} $$\n$$ \\frac{\\partial (dy/dt)}{\\partial x} = -\\frac{n\\alpha x^{n-1}}{(1+x^{n})^{2}} $$\n$$ \\frac{\\partial (dy/dt)}{\\partial y} = -1 $$\n在不动点 $(x^\\ast, y^\\ast) = (\\frac{1}{2}, \\frac{1}{2})$ 处，代入 $n=2$ 和 $\\alpha=\\frac{5}{8}$，计算非对角线元素的值：\n$$ \\frac{\\partial (dx/dt)}{\\partial y} \\bigg|_{(\\frac{1}{2},\\frac{1}{2})} = -\\frac{2 \\cdot \\frac{5}{8} \\cdot (\\frac{1}{2})^{1}}{(1+(\\frac{1}{2})^{2})^{2}} = -\\frac{\\frac{5}{8}}{(\\frac{5}{4})^{2}} = -\\frac{5/8}{25/16} = -\\frac{5}{8} \\cdot \\frac{16}{25} = -\\frac{2}{5} $$\n由于对称性，$\\frac{\\partial (dy/dt)}{\\partial x}$ 的值也为 $-\\frac{2}{5}$。因此，雅可比矩阵为：\n$$ J = \\begin{pmatrix} -1  -\\frac{2}{5} \\\\ -\\frac{2}{5}  -1 \\end{pmatrix} $$\n\n**3. 计算特征值、迹和行列式**\n矩阵的迹 (trace) 和行列式 (determinant) 分别为：\n$$ \\text{tr}(J) = -1 + (-1) = -2 $$\n$$ \\det(J) = (-1)(-1) - \\left(-\\frac{2}{5}\\right)\\left(-\\frac{2}{5}\\right) = 1 - \\frac{4}{25} = \\frac{21}{25} $$\n特征值 $\\lambda$ 满足特征方程 $\\det(J - \\lambda I) = 0$，即 $(\\lambda - \\lambda_1)(\\lambda - \\lambda_2) = \\lambda^2 - \\text{tr}(J)\\lambda + \\det(J) = 0$。\n也可以直接求解 $(\\lambda+1)^2 - (-\\frac{2}{5})^2 = 0$，得到 $\\lambda+1 = \\pm \\frac{2}{5}$。\n因此，两个特征值为：\n$$ \\lambda_1 = -1 - \\frac{2}{5} = -\\frac{7}{5} $$\n$$ \\lambda_2 = -1 + \\frac{2}{5} = -\\frac{3}{5} $$\n\n**4. 不动点的分类**\n根据线性稳定性理论，由于 $\\text{tr}(J) = -2  0$ 且 $\\det(J) = \\frac{21}{25}  0$，该不动点是一个**稳定结点**。两个特征值都是负实数，也证实了这一点。\n根据问题定义，稳定结点的稳定性代码为 $\\sigma=1$。\n因此，最终答案的有序三元组为 $(-\\frac{7}{5}, -\\frac{3}{5}, 1)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{7}{5}  -\\frac{3}{5}  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "拨动开关的真正威力在于其在不同状态间切换的能力，这一行为由诱导剂等外部参数控制，其切换点被称为分岔点。本项高级练习将挑战您实现一个用于分岔分析的计算工作流程，通过数值方法精确定位这些关键点，这正是现代计算系统生物学的核心技术。",
            "id": "3935278",
            "problem": "要求您实现并使用一个来自合成生物学的、完全指定的基因触发开关数学模型。目标是在诱导剂浓度上进行参数延拓，通过求解转折点处的雅可比行列式条件来定位鞍结分岔，并跟踪不动点的产生与湮灭。模型和所有计算必须纯粹以无量纲量进行，不含物理单位。模型中不出现角度，因此无需指定角度单位。模型中不出现百分比，因此无需特殊说明。\n\n基因触发开关由两个基因组成，它们的蛋白质产物相互阻遏。您必须使用的基本建模基础结合了分子生物学中心法则（DNA到信使核糖核酸到蛋白质）、源自平衡结合的准稳态阻遏以及一阶降解。令 $x$ 和 $y$ 表示两种蛋白质的无量纲浓度。令 $I$ 表示无量纲诱导剂浓度，它通过有效增加阻遏阈值来降低一种蛋白质对另一种蛋白质的阻遏强度。该模型为：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_x}{1 + \\left(\\dfrac{y}{K_y \\left(1 + \\left(\\dfrac{I}{K_I}\\right)^m\\right)}\\right)^{n}} \\;-\\; \\delta_x \\, x,\n$$\n$$\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_y}{1 + \\left(\\dfrac{x}{K_x}\\right)^{n}} \\;-\\; \\delta_y \\, y.\n$$\n此处，$\\alpha_x$ 和 $\\alpha_y$ 是无量纲最大合成速率，$K_x$ 和 $K_y$ 是无量纲阻遏阈值，$\\delta_x$ 和 $\\delta_y$ 是无量纲一阶降解速率，$n$ 是希尔系数（协同性），$K_I$ 是无量纲诱导剂解离尺度，$m$ 是诱导剂效应的希尔指数。$y$ 对 $x$ 的有效阻遏阈值为 $K_y^{\\mathrm{eff}}(I) = K_y \\left(1 + \\left(\\dfrac{I}{K_I}\\right)^m\\right)$，它使得随着 $I$ 的增加，阻遏作用变弱。\n\n在参数 $I$ 下的一个不动点 $(x^\\ast,y^\\ast)$ 满足：\n$$\nf_1(x,y;I) \\;=\\; \\frac{\\alpha_x}{1 + \\left(\\dfrac{y}{K_y \\left(1 + \\left(\\dfrac{I}{K_I}\\right)^m\\right)}\\right)^{n}} \\;-\\; \\delta_x \\, x \\;=\\; 0,\n$$\n$$\nf_2(x,y;I) \\;=\\; \\frac{\\alpha_y}{1 + \\left(\\dfrac{x}{K_x}\\right)^{n}} \\;-\\; \\delta_y \\, y \\;=\\; 0.\n$$\n向量场 $(f_1,f_2)$ 关于 $(x,y)$ 在 $(x^\\ast,y^\\ast)$ 处的 $2\\times 2$ 雅可比矩阵为：\n$$\nJ(x,y;I) \\;=\\; \n\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial x}  \\frac{\\partial f_1}{\\partial y} \\\\\n\\frac{\\partial f_2}{\\partial x}  \\frac{\\partial f_2}{\\partial y}\n\\end{pmatrix}.\n$$\n关于参数 $I$ 的鞍结分岔发生在一个不动点 $(x^\\ast,y^\\ast)$ 和参数值 $I^\\ast$ 处，其中 $J(x^\\ast,y^\\ast;I^\\ast)$ 的一个特征值为零，等价于 $\\det(J(x^\\ast,y^\\ast;I^\\ast)) = 0$，并且非简并性和横截性条件成立。在此问题中，您必须通过求解耦合系统 $f_1(x,y;I) = 0$、$f_2(x,y;I) = 0$ 和 $\\det(J(x,y;I)) = 0$ 来求解 $(x,y,I)$ 以定位这些点。\n\n您的程序必须实现：\n- 对给定的 $I$，通过求解 $f_1(x,y;I)=0$ 和 $f_2(x,y;I)=0$ 来数值计算不动点 $(x,y)$，使用多个初始猜测以捕获存在多个分支的情况，并拒绝负解。\n- 在不动点处计算雅可比矩阵 $J(x,y;I)$ 及其行列式 $\\det(J(x,y;I))$。\n- 通过求解三方程系统 $\\{f_1=0,f_2=0,\\det(J)=0\\}$ 以求得 $(x,y,I)$，从而检测和精化鞍结分岔。求解时使用从 $I$ 的参数延拓以及从相邻 $I$ 样本之间不动点数量变化中获得的种子点。\n- 通过监测随着 $I$ 增加不动点数量的变化来跟踪不动点的产生或湮灭，并验证每个候选分岔点都位于测试用例指定的 $I$ 区间内。\n\n您的程序必须处理以下参数集的测试套件。对于每个参数集，返回检测到的鞍结分岔处的诱导剂值 $I^\\ast$ 列表，按升序排序并四舍五入到六位小数。所有参数值都是无量纲的。每个测试用例都提供了 $I$ 的搜索区间和网格分辨率。测试套件如下：\n\n- 测试用例 1（对称，强协同性，预期双稳态）：$\\alpha_x = 12$, $\\alpha_y = 12$, $\\delta_x = 1$, $\\delta_y = 1$, $K_x = 1$, $K_y = 1$, $n = 4$, $K_I = 1$, $m = 2$，$I \\in [0,4]$ 在 $61$ 个均匀间隔点上采样，平衡点初始猜测在 $x,y \\in [0,24]$ 范围内使用 $7\\times 7$ 的种子网格进行扫描。\n- 测试用例 2（对称，弱协同性，预期单稳态）：$\\alpha_x = 12$, $\\alpha_y = 12$, $\\delta_x = 1$, $\\delta_y = 1$, $K_x = 1$, $K_y = 1$, $n = 1$, $K_I = 1$, $m = 2$，$I \\in [0,4]$ 在 $61$ 个均匀间隔点上采样，平衡点初始猜测在 $x,y \\in [0,24]$ 范围内使用 $7\\times 7$ 的种子网格进行扫描。\n- 测试用例 3（非对称，中等协同性）：$\\alpha_x = 18$, $\\alpha_y = 9$, $\\delta_x = 1$, $\\delta_y = 1$, $K_x = 1$, $K_y = 1$, $n = 3$, $K_I = 0.5$, $m = 2$，$I \\in [0,3]$ 在 $61$ 个均匀间隔点上采样，平衡点初始猜测在 $x,y \\in [0,36]$ 范围内使用 $7\\times 7$ 的种子网格进行扫描。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目是相应测试用例的鞍结分岔诱导剂值列表。例如，在将每个 $I_{k,j}$ 四舍五入到六位小数后，输出必须类似于 $[\\,[I_{1,1},I_{1,2}],\\,[\\,],\\,[I_{3,1},I_{3,2}]\\,]$。如果某个测试用例没有找到鞍结分岔，则为该用例输出一个空列表。程序必须是确定性和自包含的：它不应需要任何输入或外部文件，并且必须在内部计算所有量。",
            "solution": "该问题的核心任务是为给定的基因触发开关模型实现一个计算工作流程，以定位鞍结分岔点。鞍结分岔标志着系统的稳态（不动点）随着参数（此处为诱导剂浓度 $I$）的变化而产生或消失，是理解系统双稳态行为的关键。\n\n**1. 数学模型与分岔条件**\n系统的动力学由一对耦合的常微分方程描述，代表蛋白质 $x$ 和 $y$ 的浓度变化。不动点 $(x^\\ast, y^\\ast)$ 是系统达到平衡的状态，满足以下两个方程：\n$$ f_1(x^\\ast, y^\\ast; I) = 0 $$\n$$ f_2(x^\\ast, y^\\ast; I) = 0 $$\n鞍结分岔发生在这样一个点 $(x^\\ast, y^\\ast, I^\\ast)$，在该点，系统的一个稳定不动点和一个不稳定不动点（鞍点）合并后消失。在数学上，这对应于系统在该不动点的雅可比矩阵 $J$ 的一个特征值为零。这等价于雅可比矩阵的行列式为零：\n$$ \\det(J(x^\\ast, y^\\ast; I^\\ast)) = 0 $$\n因此，为了定位鞍结分岔点，我们需要求解一个由三个方程组成的非线性方程组，其未知数为 $(x, y, I)$：\n1.  $f_1(x, y; I) = 0$  （x-不动点条件）\n2.  $f_2(x, y; I) = 0$  （y-不动点条件）\n3.  $\\det(J(x, y; I)) = 0$ （分岔条件）\n\n**2. 计算策略**\n由于该方程组没有解析解，我们采用一种数值方法，结合参数延拓和求根算法来求解。\n-   **步骤 1：参数延拓与不动点跟踪。** 我们首先将诱导剂浓度 $I$ 的搜索区间离散化成一系列采样点。对于每个固定的 $I$ 值，我们使用数值求根器（例如 `scipy.optimize.root`）求解两个不动点方程 $f_1=0, f_2=0$。为了找到所有可能的不动点（在双稳态区域可能存在多个解），我们从一个覆盖了状态空间 $(x, y)$ 的网格上的多个初始猜测点开始搜索。\n-   **步骤 2：分岔检测。** 我们沿着 $I$ 值的序列，比较在相邻两个 $I$ 值下找到的物理上有效（非负）的不动点数量。当不动点的数量发生变化时（例如，从3个变为1个），这表明一个鞍结分岔事件发生在这两个 $I$ 值之间。\n-   **步骤 3：分岔点精化。** 一旦检测到分岔发生在一个区间 $[I_{k-1}, I_k]$ 内，我们就利用这个信息来求解完整的三方程系统。我们使用该区间内的不动点坐标以及区间中点作为求解器对 $(x, y, I)$ 的初始猜测。求解这个三方程系统可以得到分岔点 $(x^\\ast, y^\\ast, I^\\ast)$ 的精确位置。\n-   **步骤 4：结果汇总。** 对每个测试用例重复以上过程，收集所有找到的分岔点对应的 $I^\\ast$ 值。最后，对这些值进行排序、去重和格式化，得到最终结果。\n\n为了提高数值稳定性，实际计算中可能会使用行列式条件的对数变换形式，以避免处理可能导致浮点数溢出的高次多项式。该程序化方法能够系统地、精确地识别出控制基因开关行为的关键阈值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases for the genetic toggle switch model.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"alpha_x\": 12.0, \"alpha_y\": 12.0, \"delta_x\": 1.0, \"delta_y\": 1.0,\n            \"K_x\": 1.0, \"K_y\": 1.0, \"n\": 4.0, \"K_I\": 1.0, \"m\": 2.0,\n            \"I_range\": [0.0, 4.0], \"I_points\": 61,\n            \"xy_range\": [0.0, 24.0], \"grid_size\": 7\n        },\n        {\n            \"alpha_x\": 12.0, \"alpha_y\": 12.0, \"delta_x\": 1.0, \"delta_y\": 1.0,\n            \"K_x\": 1.0, \"K_y\": 1.0, \"n\": 1.0, \"K_I\": 1.0, \"m\": 2.0,\n            \"I_range\": [0.0, 4.0], \"I_points\": 61,\n            \"xy_range\": [0.0, 24.0], \"grid_size\": 7\n        },\n        {\n            \"alpha_x\": 18.0, \"alpha_y\": 9.0, \"delta_x\": 1.0, \"delta_y\": 1.0,\n            \"K_x\": 1.0, \"K_y\": 1.0, \"n\": 3.0, \"K_I\": 0.5, \"m\": 2.0,\n            \"I_range\": [0.0, 3.0], \"I_points\": 61,\n            \"xy_range\": [0.0, 36.0], \"grid_size\": 7\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        bifurcation_Is = find_bifurcations_for_case(params)\n        all_results.append(bifurcation_Is)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"[{','.join(f'{val:.6f}' for val in res)}]\" for res in all_results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\ndef find_bifurcations_for_case(params):\n    \"\"\"\n    Finds saddle-node bifurcations for a single set of toggle switch parameters.\n    \"\"\"\n    \n    # Unpack parameters\n    ax, ay = params[\"alpha_x\"], params[\"alpha_y\"]\n    dx, dy = params[\"delta_x\"], params[\"delta_y\"]\n    Kx, Ky = params[\"K_x\"], params[\"K_y\"]\n    n, KI, m = params[\"n\"], params[\"K_I\"], params[\"m\"]\n    I_min, I_max = params[\"I_range\"]\n    I_points = params[\"I_points\"]\n    xy_min, xy_max = params[\"xy_range\"]\n    grid_size = params[\"grid_size\"]\n\n    # Define the system of equations for finding fixed points at a given I\n    def fixed_point_eqs(xy, I):\n        x, y = xy\n        if x  0 or y  0:\n            return [1e6, 1e6] # Penalty for non-physical region\n        \n        Ky_eff = Ky * (1 + (I / KI)**m)\n        f1 = ax / (1 + (y / Ky_eff)**n) - dx * x\n        f2 = ay / (1 + (x / Kx)**n) - dy * y\n        return [f1, f2]\n\n    # Define the system of 3 equations for finding bifurcation points (x, y, I)\n    def bifurcation_eqs(xyI):\n        x, y, I = xyI\n        if x = 0 or y = 0 or I  0:\n            return [1e6, 1e6, 1e6] # Penalty for non-physical/undefined region\n\n        # Equations f1 and f2 (fixed point conditions)\n        f1, f2 = fixed_point_eqs([x, y], I)\n\n        # Equation f3 (log-transformed determinant condition)\n        try:\n           Ky_eff_term = Ky * (1 + (I / KI)**m)\n           lhs = np.log(ax) + np.log(ay) + n * np.log(Kx) + n * np.log(Ky_eff_term)\n           rhs = 2 * np.log(n) + 2 * np.log(dx) + 2 * np.log(dy) + (n + 1) * np.log(x) + (n + 1) * np.log(y)\n           f3 = lhs - rhs\n        except (ValueError, ZeroDivisionError):\n           return [1e6, 1e6, 1e6]\n\n        return [f1, f2, f3]\n\n    # Set up grids for parameter continuation and initial guesses\n    I_grid = np.linspace(I_min, I_max, I_points)\n    guess_grid_x, guess_grid_y = np.meshgrid(\n        np.linspace(xy_min, xy_max, grid_size),\n        np.linspace(xy_min, xy_max, grid_size)\n    )\n    initial_guesses = np.vstack([guess_grid_x.ravel(), guess_grid_y.ravel()]).T\n\n    previous_fps = []\n    found_bifurcation_points = []\n    \n    # Iterate through the inducer concentration grid\n    for i, current_I in enumerate(I_grid):\n        current_fps = []\n        for guess in initial_guesses:\n            sol = root(fixed_point_eqs, guess, args=(current_I,), method='hybr')\n            if sol.success:\n                # Check for physical validity and uniqueness\n                fp = sol.x\n                if fp[0] >= 0 and fp[1] >= 0:\n                    is_unique = True\n                    for existing_fp in current_fps:\n                        if np.allclose(fp, existing_fp, atol=1e-5):\n                            is_unique = False\n                            break\n                    if is_unique:\n                        current_fps.append(fp)\n        \n        # Detect change in number of fixed points\n        if i > 0 and len(current_fps) != len(previous_fps):\n            # A bifurcation likely occurred in [previous_I, current_I]\n            previous_I = I_grid[i-1]\n            \n            # Use fixed points from before and after as (x,y) seeds\n            candidate_xy_guesses = previous_fps + current_fps\n            I_guess = (previous_I + current_I) / 2.0\n            \n            for xy_guess in candidate_xy_guesses:\n                full_guess = [xy_guess[0], xy_guess[1], I_guess]\n                bif_sol = root(bifurcation_eqs, full_guess, method='hybr', tol=1e-9)\n                \n                if bif_sol.success:\n                    x_sol, y_sol, I_sol = bif_sol.x\n                    # Validate solution\n                    if x_sol >= 0 and y_sol >= 0 and I_min = I_sol = I_max:\n                        found_bifurcation_points.append(I_sol)\n\n        previous_fps = current_fps\n\n    # Process and return the final list of bifurcation inducer values\n    if not found_bifurcation_points:\n        return []\n\n    # Sort and remove duplicates\n    unique_bif_Is = []\n    sorted_Is = sorted(found_bifurcation_points)\n    \n    if sorted_Is:\n        unique_bif_Is.append(sorted_Is[0])\n        for I_val in sorted_Is[1:]:\n            if not np.isclose(I_val, unique_bif_Is[-1], atol=1e-5):\n                unique_bif_Is.append(I_val)\n\n    return unique_bif_Is\n\nsolve()\n\n```"
        }
    ]
}