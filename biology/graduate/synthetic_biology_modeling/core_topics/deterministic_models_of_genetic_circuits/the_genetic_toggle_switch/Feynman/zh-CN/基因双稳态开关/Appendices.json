{
    "hands_on_practices": [
        {
            "introduction": "对任何合成生物学回路进行定量分析的第一步都是建立一个可靠的数学模型。这个基础练习  将引导你将相互抑制的生物学机制转化为一组耦合的常微分方程（ODEs）。通过使用希尔函数来描述抑制性相互作用，你将为后续所有分析奠定坚实的数学基础。",
            "id": "2075463",
            "problem": "合成生物学中的一个基础电路是基因触发开关，它表现出双稳态行为。该电路由两个相互抑制的基因构成。考虑一个包含这样两个基因的系统，基因1和基因2。\n\n- 基因1编码阻遏蛋白1，其浓度用 $u$ 表示。\n- 基因2编码阻遏蛋白2，其浓度用 $v$ 表示。\n- 基因1的表达受到阻遏蛋白2的抑制。\n- 基因2的表达受到阻遏蛋白1的抑制。\n\n该系统的动力学可以用一对耦合的常微分方程（ODEs）来建模。每种阻遏蛋白的产生由一个抑制性希尔函数描述，而它们的去除由一个一阶降解过程描述。\n\n让我们定义系统的参数：\n- $\\alpha_1$ 和 $\\alpha_2$ 分别是阻遏蛋白1和阻遏蛋白2的最大合成速率。\n- $K_1$ 是导致基因2半最大抑制的阻遏蛋白1的浓度。\n- $K_2$ 是导致基因1半最大抑制的阻遏蛋白2的浓度。\n- $n$ 是希尔系数，代表抑制的协同性，假设两次相互作用中该值相同。\n- $\\beta$ 是一阶降解速率常数，假设两种阻遏蛋白的该值相同。\n\n下列哪对方程正确地模拟了浓度 $u$ 和 $v$ 的变化率？\n\nA.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 K_2^n}{K_2^n + v^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2 K_1^n}{K_1^n + u^n} - \\beta v\n$$\n\nB.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 K_1^n}{K_1^n + u^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2 K_2^n}{K_2^n + v^n} - \\beta v\n$$\n\nC.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1 v^n}{K_2^n + v^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2 u^n}{K_1^n + u^n} - \\beta v\n$$\n\nD.\n$$\n\\frac{du}{dt} = \\frac{\\alpha_1}{1 + v^n} - \\beta u \\\\\n\\frac{dv}{dt} = \\frac{\\alpha_2}{1 + u^n} - \\beta v\n$$",
            "solution": "具有两个相互抑制基因的基因触发开关是通过每种阻遏蛋白浓度的质量作用平衡来建模的：变化率等于合成减去降解。对于浓度为 $u$ 的阻遏蛋白1和浓度为 $v$ 的阻遏蛋白2，其通用形式为\n$$\n\\frac{du}{dt} = \\text{synthesis}_{1}(v) - \\beta u, \\quad \\frac{dv}{dt} = \\text{synthesis}_{2}(u) - \\beta v,\n$$\n其中 $\\beta$ 是两种阻遏蛋白共有的一阶降解速率常数。\n\n因为每个基因都受到另一个阻遏蛋白的抑制，所以合成项由抑制性希尔函数给出，其形式为\n$$\n\\text{synthesis}(x) = \\frac{\\alpha K^{n}}{K^{n} + x^{n}},\n$$\n该函数满足以下定义特性：当 $x=0$ 时，合成速率达到最大值 $\\alpha$；当 $x=K$ 时，合成速率为半最大值 $\\alpha/2$。这里 $K$ 是产生半最大抑制的阻遏蛋白浓度，$n$ 是希尔系数。\n\n应用参数定义：\n- 基因1（产生 $u$）受到阻遏蛋白2的抑制，其半最大抑制浓度为 $K_{2}$，因此\n$$\n\\text{synthesis}_{1}(v) = \\frac{\\alpha_{1} K_{2}^{n}}{K_{2}^{n} + v^{n}}.\n$$\n- 基因2（产生 $v$）受到阻遏蛋白1的抑制，其半最大抑制浓度为 $K_{1}$，因此\n$$\n\\text{synthesis}_{2}(u) = \\frac{\\alpha_{2} K_{1}^{n}}{K_{1}^{n} + u^{n}}.\n$$\n\n因此，耦合的常微分方程组为\n$$\n\\frac{du}{dt} = \\frac{\\alpha_{1} K_{2}^{n}}{K_{2}^{n} + v^{n}} - \\beta u, \\quad \\frac{dv}{dt} = \\frac{\\alpha_{2} K_{1}^{n}}{K_{1}^{n} + u^{n}} - \\beta v,\n$$\n这与选项A相符。\n\n相比之下，选项B错误地使用了自我抑制；选项C使用了激活型希尔函数的分子 $x^{n}$，而不是抑制型；选项D省略了半最大抑制常数 $K_{1}$ 和 $K_{2}$，并且只有在通过这些常数进行无量纲化之后才适用，而在此并未指明要这样做。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "模型建立后，下一步是找到其稳态并确定它们的稳定性，这对于理解开关的双稳态特性至关重要。本练习  提供了一个进行线性稳定性分析的实践指南，这是动态系统理论中的一项核心技术。通过计算特定不动点处的雅可比矩阵及其特征值，你将学会如何从解析上判断一个状态是稳定的（如“开”或“关”状态）还是不稳定的（如阈值状态）。",
            "id": "3935272",
            "problem": "考虑一个典型的双基因遗传拨动开关，其中转录因子 $X$ 抑制 $Y$，$Y$ 抑制 $X$。设 $x(t)$ 和 $y(t)$ 表示无量纲的蛋白质浓度，其变化由以下常微分方程（ODE）决定\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1 + y^{n}} \\;-\\; x,\\qquad\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1 + x^{n}} \\;-\\; y,\n$$\n其中 $\\alpha>0$ 是一个无量纲的生产能力参数，$n\\geq 1$ 是用于抑制的希尔（Hill）协同指数。假设一个对称的操作体系，其中 $n=2$（协同抑制），并假设系统被调整，使得存在一个对称不动点 $(x^{\\ast},y^{\\ast})$，满足 $x^{\\ast}=y^{\\ast}=s$，其中 $s=\\frac{1}{2}$。强制实现此对称不动点的 $\\alpha$ 的选择必须与常微分方程所蕴含的稳态约束一致。\n\n从基因表达的质量平衡原理（生产减去降解）出发，并使用给定常微分方程中的希尔抑制形式，完成以下任务：\n1. 推导当 $n=2$ 时，$x^{\\ast}=y^{\\ast}=s$ 必须满足的代数稳态条件。使用此条件确定产生对称不动点 $s=\\frac{1}{2}$ 所对应的 $\\alpha$ 值。\n2. 在不动点 $(x^{\\ast},y^{\\ast})=(\\frac{1}{2},\\frac{1}{2})$ 处，构建向量场的雅可比矩阵 $J$。\n3. 对于此参数选择，计算 $J$ 的特征值 $\\lambda$，并确定 $\\text{tr}(J)$ 和 $\\det(J)$ 的符号。\n4. 基于 $\\text{tr}(J)$ 和 $\\det(J)$ 的符号，将不动点的稳定性分类为节点或鞍点。使用的约定是：稳定节点对应于 $\\det(J)>0$ 和 $\\text{tr}(J)<0$，不稳定节点对应于 $\\det(J)>0$ 和 $\\text{tr}(J)>0$，鞍点对应于 $\\det(J)<0$。使用稳定性代码 $\\sigma$ 对分类进行编码，定义为：稳定节点 $\\sigma=1$，不稳定节点 $\\sigma=0$，鞍点 $\\sigma=-1$。\n\n以有序三元组 $\\left(\\lambda_{1},\\lambda_{2},\\sigma\\right)$ 的形式给出您的最终答案，包含两个特征值和稳定性代码。不需要四舍五入，答案必须是精确的。将最终答案表示为行矩阵。",
            "solution": "用户提供了一个典型的遗传拨动开关模型，并要求对一个特定的对称不动点进行稳定性分析。\n\n### 步骤1：问题验证\n\n**1. 提取已知条件**\n-   常微分方程（ODE）系统为：\n    $$ \\frac{dx}{dt} \\;=\\; \\frac{\\alpha}{1 + y^{n}} \\;-\\; x $$\n    $$ \\frac{dy}{dt} \\;=\\; \\frac{\\alpha}{1 + x^{n}} \\;-\\; y $$\n-   参数：$\\alpha>0$（无量纲生产能力）和 $n\\geq 1$（希尔协同指数）。\n-   假设的操作体系：$n=2$。\n-   存在一个对称不动点 $(x^{\\ast},y^{\\ast})$，其中 $x^{\\ast}=y^{\\ast}=s$。\n-   此不动点的具体值为 $s=\\frac{1}{2}$。\n-   任务要求：\n    1.  为给定的不动点推导 $\\alpha$ 的值。\n    2.  在此不动点处构建雅可比矩阵 $J$。\n    3.  计算 $J$ 的特征值 $\\lambda$，并确定 $\\text{tr}(J)$ 和 $\\det(J)$ 的符号。\n    4.  对不动点的稳定性进行分类（稳定节点、不稳定节点或鞍点），并将其编码为 $\\sigma \\in \\{1, 0, -1\\}$。\n-   最终答案应为有序三元组 $(\\lambda_{1}, \\lambda_{2}, \\sigma)$。\n\n**2. 使用提取的已知条件进行验证**\n-   **科学依据**：该问题描述了 Gardner-Collins 拨动开关，这是合成生物学中的一个基础模型。方程表示由生产（通过抑制性希尔函数建模）和一阶降解引起的蛋白质浓度变化。这是一个标准的、科学上合理的模型。\n-   **适定性**：该问题是适定的。它提供了一个常微分方程系统和一个特定的不动点，然后要求进行标准的线性稳定性分析。步骤定义清晰，并提供了求得唯一解所需的所有参数（$n=2$, $s=1/2$）。\n-   **客观性**：问题以精确的数学语言陈述，没有主观性或模糊性。\n-   **完整性与一致性**：问题是自洽的。明确提供了稳定性分类和稳定性代码 $\\sigma$ 的定义。设置中没有矛盾之处。\n-   **可行性**：所需的计算是动力系统分析的标准计算，在数学上是可行的。\n\n**3. 结论与行动**\n问题是有效的。它在科学上合理，数学上适定，并且提供了获得唯一解所需的所有信息。我现在将继续进行求解。\n\n### 步骤2：求解推导\n\n**1. 确定参数 $\\alpha$**\n\n在不动点 $(x^{\\ast}, y^{\\ast})$ 处，时间导数为零：$\\frac{dx}{dt} = 0$ 和 $\\frac{dy}{dt} = 0$。这产生了稳态方程：\n$$ x^{\\ast} = \\frac{\\alpha}{1 + (y^{\\ast})^{n}} $$\n$$ y^{\\ast} = \\frac{\\alpha}{1 + (x^{\\ast})^{n}} $$\n问题指定了一个对称不动点，其中 $x^{\\ast} = y^{\\ast} = s$。将此代入任一个稳态方程，得到 $s$ 必须满足的代数条件：\n$$ s = \\frac{\\alpha}{1 + s^{n}} $$\n给定 $n=2$ 和 $s=\\frac{1}{2}$。我们可以解出支持此不动点的 $\\alpha$ 的具体值：\n$$ \\alpha = s(1 + s^{n}) $$\n代入给定值：\n$$ \\alpha = \\frac{1}{2} \\left(1 + \\left(\\frac{1}{2}\\right)^{2}\\right) = \\frac{1}{2} \\left(1 + \\frac{1}{4}\\right) = \\frac{1}{2} \\left(\\frac{5}{4}\\right) = \\frac{5}{8} $$\n因此，参数值为 $\\alpha = \\frac{5}{8}$。\n\n**2. 构建雅可比矩阵 $J$**\n\n系统的向量场为 $\\mathbf{F}(x,y) = (f(x,y), g(x,y))$，其中：\n$$ f(x,y) = \\frac{\\alpha}{1 + y^{n}} - x $$\n$$ g(x,y) = \\frac{\\alpha}{1 + x^{n}} - y $$\n雅可比矩阵 $J$ 定义为：\n$$ J(x,y) = \\begin{pmatrix} \\frac{\\partial f}{\\partial x} & \\frac{\\partial f}{\\partial y} \\\\ \\frac{\\partial g}{\\partial x} & \\frac{\\partial g}{\\partial y} \\end{pmatrix} $$\n我们计算偏导数：\n$$ \\frac{\\partial f}{\\partial x} = -1 $$\n$$ \\frac{\\partial f}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( \\alpha (1+y^{n})^{-1} \\right) = -\\alpha (1+y^{n})^{-2} (ny^{n-1}) = -\\frac{n\\alpha y^{n-1}}{(1+y^{n})^{2}} $$\n$$ \\frac{\\partial g}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\alpha (1+x^{n})^{-1} \\right) = -\\alpha (1+x^{n})^{-2} (nx^{n-1}) = -\\frac{n\\alpha x^{n-1}}{(1+x^{n})^{2}} $$\n$$ \\frac{\\partial g}{\\partial y} = -1 $$\n现在，我们在不动点 $(x^{\\ast}, y^{\\ast}) = (s,s) = (\\frac{1}{2}, \\frac{1}{2})$ 处，使用 $n=2$ 和 $\\alpha=\\frac{5}{8}$ 来计算雅可比矩阵。由于对称性，非对角线项相等。我们来计算它们的值：\n$$ \\frac{\\partial f}{\\partial y}\\bigg|_{(s,s)} = \\frac{\\partial g}{\\partial x}\\bigg|_{(s,s)} = -\\frac{2 \\left(\\frac{5}{8}\\right) \\left(\\frac{1}{2}\\right)^{2-1}}{\\left(1 + \\left(\\frac{1}{2}\\right)^{2}\\right)^{2}} = -\\frac{\\frac{5}{4} \\cdot \\frac{1}{2}}{\\left(1 + \\frac{1}{4}\\right)^{2}} = -\\frac{\\frac{5}{8}}{\\left(\\frac{5}{4}\\right)^{2}} = -\\frac{\\frac{5}{8}}{\\frac{25}{16}} = -\\frac{5}{8} \\cdot \\frac{16}{25} = -\\frac{2}{5} $$\n在不动点 $(\\frac{1}{2}, \\frac{1}{2})$ 处的雅可比矩阵为：\n$$ J = \\begin{pmatrix} -1 & -\\frac{2}{5} \\\\ -\\frac{2}{5} & -1 \\end{pmatrix} $$\n\n**3. 计算特征值、迹和行列式**\n\n雅可比矩阵的迹是其对角线元素之和：\n$$ \\text{tr}(J) = -1 + (-1) = -2 $$\n雅可比矩阵的行列式为：\n$$ \\det(J) = (-1)(-1) - \\left(-\\frac{2}{5}\\right)\\left(-\\frac{2}{5}\\right) = 1 - \\frac{4}{25} = \\frac{21}{25} $$\n特征值 $\\lambda$ 是特征方程 $\\det(J - \\lambda I) = 0$ 的根：\n$$ \\det \\begin{pmatrix} -1-\\lambda & -\\frac{2}{5} \\\\ -\\frac{2}{5} & -1-\\lambda \\end{pmatrix} = 0 $$\n$$ (-1-\\lambda)^{2} - \\left(-\\frac{2}{5}\\right)^{2} = 0 $$\n$$ (\\lambda + 1)^{2} - \\frac{4}{25} = 0 $$\n$$ (\\lambda + 1)^{2} = \\frac{4}{25} $$\n两边取平方根得到：\n$$ \\lambda + 1 = \\pm \\sqrt{\\frac{4}{25}} = \\pm \\frac{2}{5} $$\n求解两个特征值：\n$$ \\lambda_{1} = -1 - \\frac{2}{5} = -\\frac{5}{5} - \\frac{2}{5} = -\\frac{7}{5} $$\n$$ \\lambda_{2} = -1 + \\frac{2}{5} = -\\frac{5}{5} + \\frac{2}{5} = -\\frac{3}{5} $$\n特征值为 $\\lambda_{1} = -\\frac{7}{5}$ 和 $\\lambda_{2} = -\\frac{3}{5}$。\n\n**4. 不动点的分类**\n\n问题提供了以下分类规则：\n-   稳定节点：$\\det(J)>0$ 且 $\\text{tr}(J)<0$。\n-   不稳定节点：$\\det(J)>0$ 且 $\\text{tr}(J)>0$。\n-   鞍点：$\\det(J)<0$。\n\n在我们的例子中，我们得到 $\\text{tr}(J)=-2 < 0$ 且 $\\det(J)=\\frac{21}{25} > 0$。因此，该不动点是一个**稳定节点**。\n问题定义了稳定性代码 $\\sigma$，其中稳定节点对应 $\\sigma=1$。因此，$\\sigma=1$。\n这与两个特征值都是实数且为负的事实相符。\n\n最终答案是两个特征值和稳定性代码组成的有序三元组：$(\\lambda_{1}, \\lambda_{2}, \\sigma) = (-\\frac{7}{5}, -\\frac{3}{5}, 1)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{7}{5} & -\\frac{3}{5} & 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然解析方法对于理解局部稳定性非常有效，但计算方法对于探索系统在参数变化下的全局行为至关重要。这项高级练习  要求你编写程序，通过数值延拓的方法来绘制基因拨动开关的分岔图。你将学习如何追踪稳态随诱导剂浓度的变化，并精确定位开关翻转状态的鞍结分岔点，从而完整地揭示其迟滞现象。",
            "id": "3935278",
            "problem": "您的任务是实现并使用一个来自合成生物学的、完全指定的基因拨动开关数学模型。目标是对诱导剂浓度进行参数延拓，通过求解转折点处的雅可比行列式条件来定位鞍结分岔，并追踪不动点的产生和消失。模型和所有计算必须纯粹以无量纲量进行构建，不涉及物理单位。模型中不出现角度，因此无需指定角度单位。不出现百分比，因此无需特殊说明。\n\n基因拨动开关由两个基因组成，其蛋白质产物相互抑制。您必须使用的基本建模基础结合了分子生物学中心法则（DNA到信使核糖核酸到蛋白质）、源自平衡结合的准稳态抑制以及一阶降解。令 $x$ 和 $y$ 表示两种蛋白质的无量纲浓度。令 $I$ 为无量纲诱导剂浓度，它通过有效提高抑制阈值来降低一种蛋白质对另一种蛋白质的抑制强度。该模型为：\n$$\n\\frac{dx}{dt} \\;=\\; \\frac{\\alpha_x}{1 + \\left(\\dfrac{y}{K_y \\left(1 + \\left(\\dfrac{I}{K_I}\\right)^m\\right)}\\right)^{n}} \\;-\\; \\delta_x \\, x,\n$$\n$$\n\\frac{dy}{dt} \\;=\\; \\frac{\\alpha_y}{1 + \\left(\\dfrac{x}{K_x}\\right)^{n}} \\;-\\; \\delta_y \\, y.\n$$\n此处，$\\alpha_x$ 和 $\\alpha_y$ 是无量纲的最大合成速率，$K_x$ 和 $K_y$ 是无量纲的抑制阈值，$\\delta_x$ 和 $\\delta_y$ 是无量纲的一阶降解速率，$n$ 是希尔系数（协同性），$K_I$ 是无量纲的诱导剂解离尺度，$m$ 是诱导剂效应的希尔指数。$y$ 对 $x$ 的有效抑制阈值为 $K_y^{\\mathrm{eff}}(I) = K_y \\left(1 + \\left(\\dfrac{I}{K_I}\\right)^m\\right)$，这使得随着 $I$ 的增加，抑制作用减弱。\n\n在参数 $I$ 下，不动点 $(x^\\ast,y^\\ast)$ 满足：\n$$\nf_1(x,y;I) \\;=\\; \\frac{\\alpha_x}{1 + \\left(\\dfrac{y}{K_y \\left(1 + \\left(\\dfrac{I}{K_I}\\right)^m\\right)}\\right)^{n}} \\;-\\; \\delta_x \\, x \\;=\\; 0,\n$$\n$$\nf_2(x,y;I) \\;=\\; \\frac{\\alpha_y}{1 + \\left(\\dfrac{x}{K_x}\\right)^{n}} \\;-\\; \\delta_y \\, y \\;=\\; 0.\n$$\n向量场 $(f_1,f_2)$ 关于 $(x,y)$ 在点 $(x^\\ast,y^\\ast)$ 的 $2\\times 2$ 雅可比矩阵为：\n$$\nJ(x,y;I) = \n\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial x} & \\frac{\\partial f_1}{\\partial y} \\\\\n\\frac{\\partial f_2}{\\partial x} & \\frac{\\partial f_2}{\\partial y}\n\\end{pmatrix}.\n$$\n关于参数 $I$ 的鞍结分岔发生在一个不动点 $(x^\\ast,y^\\ast)$ 和参数值 $I^\\ast$ 处，此时 $J(x^\\ast,y^\\ast;I^\\ast)$ 的一个特征值为零，等价于 $\\det(J(x^\\ast,y^\\ast;I^\\ast)) = 0$，并且非简并性和横截性条件成立。在本问题中，您必须通过求解耦合方程组 $f_1(x,y;I) = 0$、$f_2(x,y;I) = 0$ 和 $\\det(J(x,y;I)) = 0$ 来确定这些点 $(x,y,I)$。\n\n您的程序必须实现：\n- 对于给定的 $I$，通过求解 $f_1(x,y;I)=0$ 和 $f_2(x,y;I)=0$ 来数值计算不动点 $(x,y)$，使用多个初始猜测以捕获可能存在的多分支，并舍弃负值解。\n- 在不动点处计算雅可比矩阵 $J(x,y;I)$ 及其行列式 $\\det(J(x,y;I))$。\n- 通过求解三方程系统 $\\{f_1=0,f_2=0,\\det(J)=0\\}$ 来检测和精化鞍结分岔，求解变量为 $(x,y,I)$，并使用从 $I$ 的参数延拓以及相邻 $I$ 样本间不动点数量变化中获得的种子点。\n- 通过监测随 $I$ 增加时不动点数量的变化来追踪不动点的产生或消失，并验证每个候选分岔点都位于测试用例指定的 $I$ 区间内。\n\n您的程序必须处理以下参数集测试套件。对于每个参数集，返回检测到的鞍结分岔所对应的诱导剂值 $I^\\ast$ 列表，按升序排序并四舍五入到六位小数。所有参数值都是无量纲的。每个测试用例都提供了 $I$ 的搜索区间和网格分辨率。该测试套件是：\n\n- 测试用例 1（对称、强协同性、预期双稳态）：$\\alpha_x = 12$, $\\alpha_y = 12$, $\\delta_x = 1$, $\\delta_y = 1$, $K_x = 1$, $K_y = 1$, $n = 4$, $K_I = 1$, $m = 2$, $I \\in [0,4]$，在 $61$ 个均匀间隔的点上采样，平衡点初始猜测值在 $x,y \\in [0,24]$ 范围内使用 $7\\times 7$ 的种子网格进行扫描。\n- 测试用例 2（对称、弱协同性、预期单稳态）：$\\alpha_x = 12$, $\\alpha_y = 12$, $\\delta_x = 1$, $\\delta_y = 1$, $K_x = 1$, $K_y = 1$, $n = 1$, $K_I = 1$, $m = 2$, $I \\in [0,4]$，在 $61$ 个均匀间隔的点上采样，平衡点初始猜测值在 $x,y \\in [0,24]$ 范围内使用 $7\\times 7$ 的种子网格进行扫描。\n- 测试用例 3（非对称、中等协同性）：$\\alpha_x = 18$, $\\alpha_y = 9$, $\\delta_x = 1$, $\\delta_y = 1$, $K_x = 1$, $K_y = 1$, $n = 3$, $K_I = 0.5$, $m = 2$, $I \\in [0,3]$，在 $61$ 个均匀间隔的点上采样，平衡点初始猜测值在 $x,y \\in [0,36]$ 范围内使用 $7\\times 7$ 的种子网格进行扫描。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个条目是对应测试用例的鞍结分岔诱导剂值列表。例如，输出必须形如 $[\\,[I_{1,1},I_{1,2}],\\,[\\,],\\,[I_{3,1},I_{3,2}]\\,]$，其中每个 $I_{k,j}$ 都四舍五入到六位小数。如果某个测试用例没有找到鞍结分岔，则为该用例输出一个空列表。程序必须是确定性的和自包含的：它不应需要任何输入或外部文件，并且必须在内部计算所有量。",
            "solution": "所提供的问题是计算系统生物学中一个有效且适定的练习，特别是关于基因拨动开关模型的分岔分析。它在科学上基于生物化学动力学和动力系统理论的既定原理。问题陈述是自包含的，提供了所有必要的模型方程、参数和数值步骤，以得出一个唯一的、可验证的解。我们将着手提供一个完整的解决方案。\n\n### 基于原理的设计\n\n核心任务是在基因拨动开关模型的参数空间中识别鞍结分岔。鞍结分岔标志着当一个参数变化时，不动点（稳态）的产生或消失。定位这些点需要求解一组特定的数学条件。\n\n#### 1. 数学模型\n\n该系统的动力学由一对耦合的常微分方程（ODEs）描述，用于无量纲的蛋白质浓度 $x$ 和 $y$。诱导剂浓度 $I$ 充当控制参数。\n\n蛋白质 $x$ 的变化率由其合成速率减去其降解速率给出：\n$$\n\\frac{dx}{dt} = f_1(x,y;I) = \\underbrace{\\frac{\\alpha_x}{1 + \\left(\\frac{y}{K_y^{\\mathrm{eff}}(I)}\\right)^{n}}}_{\\text{x 的合成}} - \\underbrace{\\delta_x x}_{\\text{x 的降解}}\n$$\n$x$ 的合成受到蛋白质 $y$ 的抑制。该项是一个希尔函数，其中 $n$ 是表示协同性的希尔系数。诱导剂 $I$ 通过增加有效抑制阈值 $K_y^{\\mathrm{eff}}(I) = K_y \\left(1 + \\left(\\frac{I}{K_I}\\right)^m\\right)$ 来减弱这种抑制。\n\n类似地，蛋白质 $y$ 的变化率为：\n$$\n\\frac{dy}{dt} = f_2(x,y;I) = \\underbrace{\\frac{\\alpha_y}{1 + \\left(\\frac{x}{K_x}\\right)^{n}}}_{\\text{y 的合成}} - \\underbrace{\\delta_y y}_{\\text{y 的降解}}\n$$\n此处，$y$ 的合成受到蛋白质 $x$ 的抑制，抑制阈值为常数 $K_x$。\n\n#### 2. 不动点与稳定性\n\n系统的一个不动点，或称稳态，是一个浓度对 $(x^\\ast, y^\\ast)$，在此处变化率为零，即 $\\frac{dx}{dt}=0$ 和 $\\frac{dy}{dt}=0$。这些点代表了拨动开关的长期平衡行为。它们通过求解以下非线性代数方程组找到：\n$$\nf_1(x^\\ast, y^\\ast; I) = 0\n$$\n$$\nf_2(x^\\ast, y^\\ast; I) = 0\n$$\n不动点的稳定性决定了系统在受到微小扰动后是否会返回该点。稳定性由在不动点处计算的雅可比矩阵 $J$ 的特征值决定。雅可比矩阵包含速率函数的偏导数：\n$$\nJ(x^\\ast, y^\\ast; I) = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial x} & \\frac{\\partial f_1}{\\partial y} \\\\ \\frac{\\partial f_2}{\\partial x} & \\frac{\\partial f_2}{\\partial y} \\end{pmatrix}_{(x^\\ast, y^\\ast)}\n$$\n\n#### 3. 鞍结分岔条件\n\n当一个不动点以一种特定方式失去其稳定性时，就会发生鞍结分岔。在分岔点 $(x^\\ast, y^\\ast, I^\\ast)$，雅可比矩阵的一个特征值变为零。其一个必要条件是雅可比矩阵的行列式为零：\n$$\n\\det(J(x^\\ast, y^\\ast; I^\\ast)) = 0\n$$\n这个条件与两个不动点方程相结合，形成了一个包含三个未知数 $(x, y, I)$ 的三方程系统，用于定义分岔点：\n$$\n(1) \\quad f_1(x,y;I) = 0\n$$\n$$\n(2) \\quad f_2(x,y;I) = 0\n$$\n$$\n(3) \\quad \\det(J(x,y;I)) = 0\n$$\n计算偏导数并代入不动点条件可以简化行列式方程。推导出了该第三个方程的一个数值上稳健的对数转换版本：\n$$\nf_3(x,y,I) = \\left( \\ln(\\alpha_x) + \\ln(\\alpha_y) + n\\ln(K_x) + n\\ln(K_y) + n\\ln\\left(1 + \\left(\\frac{I}{K_I}\\right)^m\\right) \\right) - \\left( 2\\ln(n) + 2\\ln(\\delta_x) + 2\\ln(\\delta_y) + (n+1)\\ln(x) + (n+1)\\ln(y) \\right) = 0\n$$\n这避免了直接表达式中高次项可能引起的浮点溢出/下溢问题。\n\n#### 4. 数值算法设计\n\n我们将实现一个数值延拓和求根算法，来为每个测试用例定位鞍结分岔。\n\n**第 1 步：参数延拓与不动点追踪**\n我们将诱导剂浓度 $I$ 的指定区间离散化为一个采样点网格。对于网格中的每个 $I$ 值，我们求解二元方程系统 $\\{f_1=0, f_2=0\\}$ 以找到所有物理上现实的不动点 $(x^\\ast \\ge 0, y^\\ast \\ge 0)$。由于可能存在多个不动点（在双稳态区域），我们使用一个 $(x, y)$ 的初始猜测网格和一个数值求根器（`scipy.optimize.root`）来发现所有解。我们收集在每个 $I$ 处找到的唯一不动点。\n\n**第 2 步：分岔检测**\n我们遍历有序的 $I$ 值网格，比较在当前步骤 $I_k$ 找到的不动点数量与上一步骤 $I_{k-1}$ 找到的数量。不动点数量的变化表明在区间 $[I_{k-1}, I_k]$ 内发生了分岔。这一事件为分岔参数 $I^\\ast$ 提供了一个界限，并为状态变量 $(x^\\ast, y^\\ast)$ 提供了候选的初始猜测。\n\n**第 3 步：分岔点精化**\n当在区间 $[I_{k-1}, I_k]$ 中检测到分岔时，我们转而求解三方程系统 $\\{f_1=0, f_2=0, f_3=0\\}$，以求解未知数 $(x,y,I)$。\n- **初始猜测**：求解器的初始猜测至关重要。我们使用在 $I_{k-1}$ 和 $I_k$ 处找到的、参与分岔的不动点作为 $(x,y)$ 的猜测值。$I$ 的一个良好猜测是区间中点 $(I_{k-1} + I_k)/2$。\n- **求解**：我们再次使用 `scipy.optimize.root` 来求解 $(x^\\ast, y^\\ast, I^\\ast)$。\n- **验证**：如果求解成功收敛，并且得到的 $(x^\\ast, y^\\ast, I^\\ast)$ 在物理上是有效的（非负），且 $I^\\ast$ 位于模拟的 $I$ 总体范围内，我们就接受这个解。\n\n**第 4 步：定稿**\n对整个 $I$ 范围内的所有不动点数量变化重复此过程。将找到的分岔诱导剂值 $I^\\ast$ 列表进行去重、升序排序，并按每个测试用例指定的精度进行四舍五入。这样就得出了最终结果。\n\n这种系统化的方法将参数扫描与目标明确的求根相结合，以精确定位系统定性行为发生变化的鞍结分岔点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases for the genetic toggle switch model.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"alpha_x\": 12.0, \"alpha_y\": 12.0, \"delta_x\": 1.0, \"delta_y\": 1.0,\n            \"K_x\": 1.0, \"K_y\": 1.0, \"n\": 4.0, \"K_I\": 1.0, \"m\": 2.0,\n            \"I_range\": [0.0, 4.0], \"I_points\": 61,\n            \"xy_range\": [0.0, 24.0], \"grid_size\": 7\n        },\n        {\n            \"alpha_x\": 12.0, \"alpha_y\": 12.0, \"delta_x\": 1.0, \"delta_y\": 1.0,\n            \"K_x\": 1.0, \"K_y\": 1.0, \"n\": 1.0, \"K_I\": 1.0, \"m\": 2.0,\n            \"I_range\": [0.0, 4.0], \"I_points\": 61,\n            \"xy_range\": [0.0, 24.0], \"grid_size\": 7\n        },\n        {\n            \"alpha_x\": 18.0, \"alpha_y\": 9.0, \"delta_x\": 1.0, \"delta_y\": 1.0,\n            \"K_x\": 1.0, \"K_y\": 1.0, \"n\": 3.0, \"K_I\": 0.5, \"m\": 2.0,\n            \"I_range\": [0.0, 3.0], \"I_points\": 61,\n            \"xy_range\": [0.0, 36.0], \"grid_size\": 7\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        bifurcation_Is = find_bifurcations_for_case(params)\n        all_results.append(bifurcation_Is)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"[{','.join(f'{val:.6f}' for val in res)}]\" for res in all_results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\ndef find_bifurcations_for_case(params):\n    \"\"\"\n    Finds saddle-node bifurcations for a single set of toggle switch parameters.\n    \"\"\"\n    \n    # Unpack parameters\n    ax, ay = params[\"alpha_x\"], params[\"alpha_y\"]\n    dx, dy = params[\"delta_x\"], params[\"delta_y\"]\n    Kx, Ky = params[\"K_x\"], params[\"K_y\"]\n    n, KI, m = params[\"n\"], params[\"K_I\"], params[\"m\"]\n    I_min, I_max = params[\"I_range\"]\n    I_points = params[\"I_points\"]\n    xy_min, xy_max = params[\"xy_range\"]\n    grid_size = params[\"grid_size\"]\n\n    # Define the system of equations for finding fixed points at a given I\n    def fixed_point_eqs(xy, I):\n        x, y = xy\n        if x  0 or y  0:\n            return [1e6, 1e6] # Penalty for non-physical region\n        \n        Ky_eff = Ky * (1 + (I / KI)**m)\n        f1 = ax / (1 + (y / Ky_eff)**n) - dx * x\n        f2 = ay / (1 + (x / Kx)**n) - dy * y\n        return [f1, f2]\n\n    # Define the system of 3 equations for finding bifurcation points (x, y, I)\n    def bifurcation_eqs(xyI):\n        x, y, I = xyI\n        if x = 0 or y = 0 or I  0:\n            return [1e6, 1e6, 1e6] # Penalty for non-physical/undefined region\n\n        # Equations f1 and f2 (fixed point conditions)\n        f1, f2 = fixed_point_eqs([x, y], I)\n\n        # Equation f3 (log-transformed determinant condition)\n        try:\n           Ky_eff_term = Ky * (1 + (I / KI)**m)\n           lhs = np.log(ax) + np.log(ay) + n * np.log(Kx) + n * np.log(Ky_eff_term)\n           rhs = 2 * np.log(n) + 2 * np.log(dx) + 2 * np.log(dy) + (n + 1) * np.log(x) + (n + 1) * np.log(y)\n           f3 = lhs - rhs\n        except (ValueError, ZeroDivisionError):\n           return [1e6, 1e6, 1e6]\n\n        return [f1, f2, f3]\n\n    # Set up grids for parameter continuation and initial guesses\n    I_grid = np.linspace(I_min, I_max, I_points)\n    guess_grid_x, guess_grid_y = np.meshgrid(\n        np.linspace(xy_min, xy_max, grid_size),\n        np.linspace(xy_min, xy_max, grid_size)\n    )\n    initial_guesses = np.vstack([guess_grid_x.ravel(), guess_grid_y.ravel()]).T\n\n    previous_fps = []\n    found_bifurcation_points = []\n    \n    # Iterate through the inducer concentration grid\n    for i, current_I in enumerate(I_grid):\n        current_fps = []\n        for guess in initial_guesses:\n            sol = root(fixed_point_eqs, guess, args=(current_I,), method='hybr')\n            if sol.success:\n                # Check for physical validity and uniqueness\n                fp = sol.x\n                if fp[0] >= 0 and fp[1] >= 0:\n                    is_unique = True\n                    for existing_fp in current_fps:\n                        if np.allclose(fp, existing_fp, atol=1e-5):\n                            is_unique = False\n                            break\n                    if is_unique:\n                        current_fps.append(fp)\n        \n        # Detect change in number of fixed points\n        if i > 0 and len(current_fps) != len(previous_fps):\n            # A bifurcation likely occurred in [previous_I, current_I]\n            previous_I = I_grid[i-1]\n            \n            # Use fixed points from before and after as (x,y) seeds\n            candidate_xy_guesses = previous_fps + current_fps\n            I_guess = (previous_I + current_I) / 2.0\n            \n            for xy_guess in candidate_xy_guesses:\n                full_guess = [xy_guess[0], xy_guess[1], I_guess]\n                bif_sol = root(bifurcation_eqs, full_guess, method='hybr', tol=1e-9)\n                \n                if bif_sol.success:\n                    x_sol, y_sol, I_sol = bif_sol.x\n                    # Validate solution\n                    if x_sol >= 0 and y_sol >= 0 and I_min = I_sol = I_max:\n                        found_bifurcation_points.append(I_sol)\n\n        previous_fps = current_fps\n\n    # Process and return the final list of bifurcation inducer values\n    if not found_bifurcation_points:\n        return []\n\n    # Sort and remove duplicates\n    unique_bif_Is = []\n    sorted_Is = sorted(found_bifurcation_points)\n    \n    if sorted_Is:\n        unique_bif_Is.append(sorted_Is[0])\n        for I_val in sorted_Is[1:]:\n            if not np.isclose(I_val, unique_bif_Is[-1], atol=1e-5):\n                unique_bif_Is.append(I_val)\n\n    return unique_bif_Is\n\nsolve()\n\n```"
        }
    ]
}