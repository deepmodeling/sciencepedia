{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳方式是动手实践。我们从一个基础但至关重要的问题开始，它将帮助你理解灵敏度方程的推导过程。在这个练习中，你将为一个简单的单指数衰减模型推导并求解其灵敏度方程，该模型常用于药代动力学等领域。通过直接对系统状态方程进行微分，你将亲身体验灵敏度动态是如何从原始系统动态中产生的，从而牢固掌握动态灵敏度分析的数学基础。",
            "id": "4385596",
            "problem": "在一个短寿命生物分子的单指数衰减药代动力学模型中，浓度 $x(t)$ 遵循常微分方程 (ODE) $dx/dt=-k\\,x$，并具有患者特定的初始条件 $x(0)=x_{0}(p)$。这里，$k>0$ 是一级消除速率常数，$x_{0}(p)$ 是由患者协变量 $p$ 决定的基线浓度。对于局部参数敏感性分析，将 $k$ 和 $x_{0}$ 视为独立参数。\n\n使用局部敏感性 $S_{x,\\theta}(t)=\\partial x(t)/\\partial \\theta$ 对参数 $\\theta$ 的定义，并从微分的基本运算和应用于状态常微分方程的链式法则出发，完成以下任务：\n\n1. 分别对状态常微分方程关于 $k$ 和 $x_{0}$ 求导，推导出 $S_{x,k}(t)$ 和 $S_{x,x_{0}}(t)$ 的敏感性常微分方程和初始条件。\n2. 求解这些敏感性常微分方程，以获得 $S_{x,k}(t)$ 和 $S_{x,x_{0}}(t)$ 关于 $t$、$k$ 和 $x_{0}$ 的闭式表达式。\n\n请以精确的解析表达式形式提供您的最终答案。不要近似，也不要包含单位。将两个敏感性一起表示为单个行矩阵 $\\bigl[S_{x,k}(t)\\;\\;S_{x,x_{0}}(t)\\bigr]$。",
            "solution": "该问题要求推导并求解单指数衰减模型的敏感性方程。该模型由浓度 $x(t)$ 的常微分方程 (ODE) 描述：\n$$\n\\frac{dx}{dt} = -k\\,x\n$$\n其初始条件为：\n$$\nx(0) = x_{0}\n$$\n敏感性分析的参数是消除速率常数 $k$ 和初始浓度 $x_{0}$。状态 $x(t)$ 对通用参数 $\\theta$ 的局部敏感性定义为 $S_{x,\\theta}(t) = \\frac{\\partial x(t)}{\\partial \\theta}$。\n\n首先，我们求解状态常微分方程。这是一个可分离的一阶线性常微分方程。\n$$\n\\frac{dx}{x} = -k\\,dt\n$$\n对两边积分得到 $\\ln(x) = -kt + C$，其中 $C$ 是积分常数。取指数得到 $x(t) = \\exp(-kt+C) = A \\exp(-kt)$，其中 $A = \\exp(C)$。应用初始条件 $x(0) = x_{0}$，我们得到 $A = x_{0}$。\n因此，状态方程的解为：\n$$\nx(t) = x_{0} \\exp(-kt)\n$$\n$x(t)$ 的这个表达式将用于推导敏感性方程。\n\n**1. 关于 $k$ 的敏感性的推导与求解**\n\n令 $S_{x,k}(t) = \\frac{\\partial x(t)}{\\partial k}$。为了找到控制 $S_{x,k}(t)$ 的常微分方程，我们对状态常微分方程关于 $k$ 求导。我们可以交换关于 $t$ 和 $k$ 的求导顺序：\n$$\n\\frac{d}{dt} S_{x,k}(t) = \\frac{d}{dt}\\left(\\frac{\\partial x}{\\partial k}\\right) = \\frac{\\partial}{\\partial k}\\left(\\frac{dx}{dt}\\right)\n$$\n将此应用于状态常微分方程的右侧，并使用乘法法则：\n$$\n\\frac{\\partial}{\\partial k}(-k\\,x) = -\\left(\\frac{\\partial k}{\\partial k} \\cdot x + k \\cdot \\frac{\\partial x}{\\partial k}\\right) = -(1 \\cdot x + k \\cdot S_{x,k})\n$$\n令结果相等，得到 $S_{x,k}(t)$ 的敏感性常微分方程：\n$$\n\\frac{d S_{x,k}}{dt} = -x - k S_{x,k}\n$$\n代入 $x(t) = x_{0} \\exp(-kt)$ 的解：\n$$\n\\frac{d S_{x,k}}{dt} + k S_{x,k} = -x_{0} \\exp(-kt)\n$$\n$S_{x,k}(t)$ 的初始条件通过对状态初始条件 $x(0) = x_{0}$ 关于 $k$ 求导得到。由于 $x_{0}$ 被视为与 $k$ 无关的独立参数：\n$$\nS_{x,k}(0) = \\frac{\\partial x(0)}{\\partial k} = \\frac{\\partial x_{0}}{\\partial k} = 0\n$$\n我们使用积分因子 $I(t) = \\exp\\left(\\int k \\, dt\\right) = \\exp(kt)$ 求解这个一阶线性非齐次常微分方程。将该常微分方程乘以 $I(t)$：\n$$\n\\exp(kt)\\frac{d S_{x,k}}{dt} + k\\exp(kt) S_{x,k} = -x_{0} \\exp(-kt) \\exp(kt)\n$$\n左侧简化为乘积的导数：\n$$\n\\frac{d}{dt}\\left(S_{x,k}(t) \\exp(kt)\\right) = -x_{0}\n$$\n对 $t$ 积分：\n$$\nS_{x,k}(t) \\exp(kt) = \\int -x_{0} \\, dt = -x_{0}t + C_{1}\n$$\n其中 $C_{1}$ 是积分常数。求解 $S_{x,k}(t)$：\n$$\nS_{x,k}(t) = (-x_{0}t + C_{1}) \\exp(-kt)\n$$\n应用初始条件 $S_{x,k}(0) = 0$：\n$$\n0 = (-x_{0} \\cdot 0 + C_{1}) \\exp(0) \\implies C_{1} = 0\n$$\n因此，关于 $k$ 的敏感性的解为：\n$$\nS_{x,k}(t) = -x_{0} t \\exp(-kt)\n$$\n\n**2. 关于 $x_0$ 的敏感性的推导与求解**\n\n令 $S_{x,x_{0}}(t) = \\frac{\\partial x(t)}{\\partial x_{0}}$。遵循相同的步骤，我们对状态常微分方程关于 $x_{0}$ 求导：\n$$\n\\frac{d}{dt} S_{x,x_{0}}(t) = \\frac{d}{dt}\\left(\\frac{\\partial x}{\\partial x_{0}}\\right) = \\frac{\\partial}{\\partial x_{0}}\\left(\\frac{dx}{dt}\\right)\n$$\n将其应用于右侧：\n$$\n\\frac{\\partial}{\\partial x_{0}}(-k\\,x) = -k \\frac{\\partial x}{\\partial x_{0}} = -k S_{x,x_{0}}\n$$\n这得到了敏感性常微分方程：\n$$\n\\frac{d S_{x,x_{0}}}{dt} = -k S_{x,x_{0}}\n$$\n初始条件通过对 $x(0) = x_{0}$ 关于 $x_{0}$ 求导得到：\n$$\nS_{x,x_{0}}(0) = \\frac{\\partial x(0)}{\\partial x_{0}} = \\frac{\\partial x_{0}}{\\partial x_{0}} = 1\n$$\n$S_{x,x_{0}}(t)$ 的常微分方程是一个简单的指数衰减方程。其解为：\n$$\nS_{x,x_{0}}(t) = S_{x,x_{0}}(0) \\exp(-kt)\n$$\n代入初始条件 $S_{x,x_{0}}(0) = 1$：\n$$\nS_{x,x_{0}}(t) = \\exp(-kt)\n$$\n问题要求将最终答案表示为行矩阵 $\\bigl[S_{x,k}(t)\\;\\;S_{x,x_{0}}(t)\\bigr]$。根据我们的推导，结果是：\n$$\n\\begin{pmatrix} -x_{0} t \\exp(-kt)  \\exp(-kt) \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -x_{0} t \\exp(-kt)  \\exp(-kt) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "参数灵敏度分析的应用远不止于随时间演化的动态系统。在分子建模和材料科学等领域，我们常常关心静态函数（如势能面）的形状如何受其参数影响。这个练习将带你分析莫尔斯势(Morse potential)，这是一个描述双原子分子相互作用的经典模型。通过计算势能对各个物理参数（如解离能、键长）的偏导数，你将学会如何量化参数变化对能量景观的影响，并将抽象的数学导数与具体的物理直觉联系起来。",
            "id": "3738535",
            "problem": "考虑一个在原子尺度上由 Morse 势模拟的双原子相互作用，Morse 势是一种被广泛使用且经过实验验证的函数形式，用于描述键解离和非谐性。势能作为原子间距的函数定义为\n$$\nU(r; D_{e}, a, r_{e}) = D_{e}\\left[1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right]^{2} - D_{e},\n$$\n其中 $r$ 是瞬时距离，$D_{e}$ 是解离能，$a$ 设定了势的曲率和范围，$r_{e}$ 是平衡键长。在多尺度建模和分析中，$U$ 对 $(D_{e}, a, r_{e})$ 的局部参数敏感性量化了校准参数的微小变化如何从较小尺度的模型（例如，分子动力学（MD）或量子化学计算）传播到用于粗粒化或连续介质描述的介观或连续尺度能量景观中。\n\n从上面给出的 Morse 势的定义出发，使用标准微积分和链式法则，推导偏导数 $\\partial U/\\partial D_{e}$、$\\partial U/\\partial a$ 和 $\\partial U/\\partial r_{e}$ 作为 $r$、$D_{e}$、$a$ 和 $r_{e}$ 函数的闭式解析表达式。然后，通过讨论这些导数在三个区域中的相对大小和符号，进行局部敏感性解释：平衡态附近，其中 $\\left|r - r_{e}\\right| \\ll 1/a$；键被压缩时，其中 $r  r_{e}$ 且 $a\\left(r_{e} - r\\right) \\gg 1$；键被拉伸时，其中 $r  r_{e}$ 且 $a\\left(r - r_{e}\\right) \\gg 1$。你的最终答案必须是写成单个行向量的三个偏导数的闭式表达式；不需要数值计算。不需要四舍五入，最终表达式中也不应包含单位。",
            "solution": "Morse 势\n$$\nU(r; D_{e}, a, r_{e}) = D_{e}\\left[1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right]^{2} - D_{e}\n$$\n是一个经过充分检验的函数形式，其参数控制着具有物理解释性的特征：$D_{e}$ 设定了渐近解离能，$a$ 控制了特征范围和曲率，$r_{e}$ 设定了平衡距离。为了计算局部参数敏感性，我们将 $U$ 对每个参数求导，同时将 $r$ 视为固定值。\n\n引入简写\n$$\n\\Delta \\equiv r - r_{e}, \\quad E \\equiv \\exp\\!\\left(-a\\Delta\\right).\n$$\n使用此记法，\n$$\nU = D_{e}\\left(1 - E\\right)^{2} - D_{e}.\n$$\n\n首先，在 $r$、$a$ 和 $r_{e}$ 固定的情况下，对 $D_{e}$ 求导：\n$$\n\\frac{\\partial U}{\\partial D_{e}} = \\left(1 - E\\right)^{2} - 1.\n$$\n展开得到一个等价形式\n$$\n\\frac{\\partial U}{\\partial D_{e}} = -2E + E^{2},\n$$\n这对于渐近解释可能很有用。\n\n其次，对 $a$ 求导。使用链式法则，\n$$\n\\frac{\\partial U}{\\partial a} = D_{e}\\cdot 2\\left(1 - E\\right)\\cdot \\frac{\\partial}{\\partial a}\\left(1 - E\\right).\n$$\n因为\n$$\n\\frac{\\partial E}{\\partial a} = \\frac{\\partial}{\\partial a}\\exp\\!\\left(-a\\Delta\\right) = -\\Delta\\,\\exp\\!\\left(-a\\Delta\\right) = -\\Delta E,\n$$\n我们有\n$$\n\\frac{\\partial}{\\partial a}\\left(1 - E\\right) = -\\frac{\\partial E}{\\partial a} = \\Delta E.\n$$\n因此，\n$$\n\\frac{\\partial U}{\\partial a} = 2D_{e}\\,\\Delta\\,E\\left(1 - E\\right).\n$$\n\n第三，对 $r_{e}$ 求导。注意 $r_{e}$ 仅通过 $\\Delta = r - r_{e}$ 进入表达式，且\n$$\n\\frac{\\partial \\Delta}{\\partial r_{e}} = -1.\n$$\n使用链式法则：\n$$\n\\frac{\\partial U}{\\partial r_{e}} = \\frac{\\partial U}{\\partial \\Delta}\\cdot \\frac{\\partial \\Delta}{\\partial r_{e}}.\n$$\n计算 $\\partial U/\\partial \\Delta$：\n$$\n\\frac{\\partial U}{\\partial \\Delta} = D_{e}\\cdot 2\\left(1 - E\\right)\\cdot \\frac{\\partial}{\\partial \\Delta}\\left(1 - E\\right) = D_{e}\\cdot 2\\left(1 - E\\right)\\cdot aE,\n$$\n因为\n$$\n\\frac{\\partial E}{\\partial \\Delta} = \\frac{\\partial}{\\partial \\Delta}\\exp\\!\\left(-a\\Delta\\right) = -a\\,\\exp\\!\\left(-a\\Delta\\right) = -aE\n$$\n因此\n$$\n\\frac{\\partial}{\\partial \\Delta}\\left(1 - E\\right) = -\\frac{\\partial E}{\\partial \\Delta} = aE.\n$$\n所以，\n$$\n\\frac{\\partial U}{\\partial r_{e}} = \\left[D_{e}\\cdot 2\\left(1 - E\\right)\\cdot aE\\right]\\cdot(-1) = -2aD_{e}\\,E\\left(1 - E\\right).\n$$\n\n这些闭式表达式提供了在任意距离 $r$ 处的局部敏感性：\n$$\n\\frac{\\partial U}{\\partial D_{e}} = \\left(1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right)^{2} - 1,\n$$\n$$\n\\frac{\\partial U}{\\partial a} = 2D_{e}\\left(r - r_{e}\\right)\\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\left[1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right],\n$$\n$$\n\\frac{\\partial U}{\\partial r_{e}} = -2aD_{e}\\,\\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\left[1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right].\n$$\n\n在三个区域中对大小和符号的解释：\n\n1. 在平衡态附近，其中 $\\left|\\Delta\\right| \\ll 1/a$，使用展开式 $\\exp\\!\\left(-a\\Delta\\right) \\approx 1 - a\\Delta + \\frac{1}{2}a^{2}\\Delta^{2}$。那么\n$$\n\\frac{\\partial U}{\\partial D_{e}} \\approx -1 + \\mathcal{O}\\!\\left(\\Delta^{2}\\right),\n$$\n$$\n\\frac{\\partial U}{\\partial a} \\approx 2D_{e}\\,a\\,\\Delta^{2} + \\mathcal{O}\\!\\left(\\Delta^{3}\\right),\n$$\n$$\n\\frac{\\partial U}{\\partial r_{e}} \\approx -2a^{2}D_{e}\\,\\Delta + \\mathcal{O}\\!\\left(\\Delta^{2}\\right).\n$$\n因此，恰好在 $r = r_{e}$ 时，$\\partial U/\\partial D_{e} = -1$，而 $\\partial U/\\partial a = 0$ 且 $\\partial U/\\partial r_{e} = 0$。在局部上，能量最小值对 $D_{e}$ 呈线性敏感，但对 $a$ 或 $r_{e}$ 不敏感，这反映了 $D_{e}$ 控制着平衡点处的垂直位移（势阱深度）。\n\n2. 在键被压缩的情况下，其中 $r  r_{e}$ 且 $x \\equiv a\\left(r_{e} - r\\right) \\gg 1$ 意味着 $\\Delta$ 是一个大的负数，且 $E = \\exp\\!\\left(-a\\Delta\\right) = \\exp\\!\\left(x\\right) \\gg 1$。主导项平衡给出\n$$\n\\frac{\\partial U}{\\partial D_{e}} \\sim E^{2}, \\quad \\frac{\\partial U}{\\partial a} \\sim 2D_{e}\\left|\\Delta\\right|E^{2}, \\quad \\frac{\\partial U}{\\partial r_{e}} \\sim 2aD_{e}E^{2}.\n$$\n由于 Morse 形式所捕捉到的强短程排斥作用，所有三种敏感性都随着压缩而迅速增长。在此区域中，$\\partial U/\\partial a$ 和 $\\partial U/\\partial r_{e}$ 的符号为正，表明在压缩状态下增加 $a$ 或 $r_{e}$ 会增加 $U$。\n\n3. 在键被拉伸的情况下，其中 $r  r_{e}$ 且 $x \\equiv a\\left(r - r_{e}\\right) \\gg 1$ 意味着 $E = \\exp\\!\\left(-x\\right) \\ll 1$。那么\n$$\n\\frac{\\partial U}{\\partial D_{e}} \\to 0, \\quad \\frac{\\partial U}{\\partial a} \\to 0, \\quad \\frac{\\partial U}{\\partial r_{e}} \\to 0.\n$$\n在远离平衡位置的解离尾部，$U \\to 0$ 并且对参数扰动不敏感，这与势能的渐近平坦化相一致。\n\n这些局部敏感性在多尺度参数校准中非常有用：在平衡态附近，主要通过调整 $D_{e}$ 来调节势阱深度，而 $a$ 和 $r_{e}$ 在远离平衡态时，尤其是在压缩状态下，对响应的影响更大。在基于梯度的反问题中，这些导数充当雅可比矩阵（Jacobian）的组成部分，将参数扰动与能量变化联系起来，从而控制着跨尺度的可识别性和条件数。",
            "answer": "$$\\boxed{\\begin{pmatrix}\n\\left(1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right)^{2} - 1  2D_{e}\\left(r - r_{e}\\right)\\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\left[1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right]  -2aD_{e}\\,\\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\left[1 - \\exp\\!\\left(-a\\left(r - r_{e}\\right)\\right)\\right]\n\\end{pmatrix}}$$"
        },
        {
            "introduction": "在真实的科研场景中，大多数生物系统的模型都过于复杂，无法求得解析解。因此，数值方法是进行灵敏度分析不可或缺的工具。这个综合性练习将作为理论与实践的桥梁，指导你为一个经典的基因调控网络——自身抑制回路——实现数值灵敏度分析。你将通过构建并求解一个包含状态变量和所有灵敏度变量的增广常微分方程组，来实践“前向灵敏度分析”这一计算系统生物学中的核心技术。",
            "id": "3917162",
            "problem": "考虑一个最小的合成基因线路，其中单一蛋白质通过与启动子的协同结合来抑制其自身的转录。所涉及的分子种类是信使核糖核酸 (mRNA) 和蛋白质，分别用 $m(t)$ 和 $P(t)$ 表示。在分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质）以及生成过程遵循质量作用动力学和降解过程为一阶降解的假设下，$m(t)$ 和 $P(t)$ 的时间演化由以下常微分方程组建模：\n$$\n\\frac{dm}{dt} = \\frac{\\alpha}{1 + \\left(\\frac{P}{K}\\right)^n} - \\delta_m \\, m,\n\\qquad\n\\frac{dP}{dt} = \\beta \\, m - \\delta_p \\, P,\n$$\n其中 $\\alpha$ 是最大转录速率，$K$ 是抑制解离常数，$n$ 是希尔系数，$\\delta_m$ 是 mRNA 降解速率，$\\beta$ 是翻译速率，$\\delta_p$ 是蛋白质降解速率。所有参数均为严格正值。\n\n要求您在初始条件 $m(0)=0$ 和 $P(0)=0$ 的情况下，对固定最终时间 $T$ 时的蛋白质浓度进行局部参数敏感性分析。对于一个参数 $\\theta$，将 $P(t)$ 相对于 $\\theta$ 的局部敏感性定义为偏导数 $\\frac{\\partial P(t)}{\\partial \\theta}$。将 $t$ 时刻的归一化对数局部敏感性指数定义为\n$$\nS_\\theta(t) = \\frac{\\theta}{P(t)} \\, \\frac{\\partial P(t)}{\\partial \\theta},\n$$\n它是无量纲的。计算六个参数 $\\theta \\in \\{\\alpha, K, n, \\delta_m, \\beta, \\delta_p\\}$ 的 $S_\\theta(T)$。\n\n您的程序必须使用与上述动力学模型一致的原理来数值计算这些敏感性，而不能假设 $m(t)$ 或 $P(t)$ 存在解析闭式解。\n\n所有时间必须以秒为单位表示。分子计数必须以分子为单位处理。归一化敏感性指数 $S_\\theta(T)$ 是无量纲的，并应作为浮点数返回。\n\n使用 $T = 1000$ 秒。使用以下参数集测试套件，每个测试套件以有序元组 $(\\alpha, K, n, \\delta_m, \\beta, \\delta_p)$ 的形式提供，其单位为 $(\\text{分子}\\cdot \\text{s}^{-1}, \\text{分子}, \\text{无量纲}, \\text{s}^{-1}, \\text{s}^{-1}, \\text{s}^{-1})$：\n- 测试用例 1 (一般协同抑制): $(50, 1000, 2, 0.2, 2, 0.05)$。\n- 测试用例 2 (弱协同性与大解离常数): $(50, 10000, 1, 0.2, 2, 0.05)$。\n- 测试用例 3 (强协同性与慢降解): $(200, 500, 4, 0.05, 2, 0.01)$。\n- 测试用例 4 (近乎无抑制的转录，非常大的 $K$): $(50, 1000000, 2, 0.2, 2, 0.05)$。\n\n对于每个测试用例，计算并输出包含六个归一化敏感性的列表 $[S_\\alpha(T), S_K(T), S_n(T), S_{\\delta_m}(T), S_\\beta(T), S_{\\delta_p}(T)]$。\n\n您的程序应生成单行输出，其中包含聚合了所有测试用例结果的、由方括号括起来的逗号分隔列表。其中每个元素对应一个测试用例，并且本身是一个包含六个浮点值的逗号分隔列表。例如，输出格式必须是\n$$\n[\\,[S_\\alpha,S_K,S_n,S_{\\delta_m},S_\\beta,S_{\\delta_p}]_{\\text{case 1}},\\,[\\cdots]_{\\text{case 2}},\\,[\\cdots]_{\\text{case 3}},\\,[\\cdots]_{\\text{case 4}}\\,],\n$$\n以单行形式打印，并带有括号和逗号。",
            "solution": "用户提供了来自合成生物学建模领域的一个有效且适定的问题陈述。任务是为一个基因自抑制线路的标准模型执行局部参数敏感性分析。所有必要的参数、初始条件和定义均已提供，并且该问题具有科学依据。\n\n该问题要求计算在最终时间 $T$ 时，蛋白质浓度 $P(t)$ 的归一化对数局部敏感性指数 $S_\\theta(T)$。该系统由以下常微分方程 (ODE) 描述：\n$$\n\\frac{dm}{dt} = \\frac{\\alpha}{1 + \\left(\\frac{P}{K}\\right)^n} - \\delta_m \\, m\n$$\n$$\n\\frac{dP}{dt} = \\beta \\, m - \\delta_p \\, P\n$$\n初始条件为 $m(0) = 0$ 和 $P(0) = 0$。参数 $\\theta$ 为 $\\alpha, K, n, \\delta_m, \\beta, \\delta_p$。敏感性指数定义为：\n$$\nS_\\theta(t) = \\frac{\\theta}{P(t)} \\, \\frac{\\partial P(t)}{\\partial \\theta}\n$$\n由于通常无法获得 $P(t)$ 的解析解，我们必须数值计算 $P(T)$ 和原始敏感性 $\\frac{\\partial P(T)}{\\partial \\theta}$。用于此目的的标准方法是前向敏感性分析或直接微分法，这与问题的约束一致。这涉及到用描述敏感性自身时间演化的附加 ODE 来扩展原始 ODE 系统。\n\n设状态向量为 $\\mathbf{x}(t) = [m(t), P(t)]^T$。该 ODE 系统可以写成 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, \\boldsymbol{\\theta})$，其中 $\\boldsymbol{\\theta}$ 是参数向量。状态向量关于参数 $\\theta$ 的敏感性为 $\\mathbf{s}_\\theta(t) = \\frac{\\partial \\mathbf{x}(t)}{\\partial \\theta}$。对系统动力学关于 $\\theta$ 进行微分，得到敏感性方程：\n$$\n\\frac{d\\mathbf{s}_\\theta}{dt} = \\frac{d}{dt}\\left(\\frac{\\partial \\mathbf{x}}{\\partial \\theta}\\right) = \\frac{\\partial}{\\partial \\theta}\\left(\\frac{d\\mathbf{x}}{dt}\\right) = \\frac{\\partial}{\\partial \\theta}\\mathbf{f}(\\mathbf{x}, \\boldsymbol{\\theta})\n$$\n应用链式法则，得到关于敏感性的线性非齐次 ODE 组：\n$$\n\\frac{d\\mathbf{s}_\\theta}{dt} = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}} \\mathbf{s}_\\theta + \\frac{\\partial \\mathbf{f}}{\\partial \\theta}\n$$\n此处，$\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ 是原始系统的雅可比矩阵 $\\mathbf{J}$，而 $\\frac{\\partial \\mathbf{f}}{\\partial \\theta}$ 是一个强迫项，表示动力学对参数 $\\theta$ 的直接依赖性。\n\n该系统的雅可比矩阵为：\n$$\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial (dm/dt)}{\\partial m}  \\frac{\\partial (dm/dt)}{\\partial P} \\\\ \\frac{\\partial (dP/dt)}{\\partial m}  \\frac{\\partial (dP/dt)}{\\partial P} \\end{pmatrix} = \\begin{pmatrix} -\\delta_m  -\\frac{\\alpha n P^{n-1}}{K^n \\left(1 + (P/K)^n\\right)^2} \\\\ \\beta  -\\delta_p \\end{pmatrix}\n$$\n强迫项 $\\frac{\\partial \\mathbf{f}}{\\partial \\theta} = \\left[ \\frac{\\partial(dm/dt)}{\\partial \\theta}, \\frac{\\partial(dP/dt)}{\\partial \\theta} \\right]^T$ 必须对 6 个参数中的每一个进行推导：\n\n1.  对于 $\\theta = \\alpha$: $\\frac{\\partial \\mathbf{f}}{\\partial \\alpha} = \\left[ \\frac{1}{1 + (P/K)^n}, \\, 0 \\right]^T$\n2.  对于 $\\theta = K$: $\\frac{\\partial \\mathbf{f}}{\\partial K} = \\left[ \\frac{\\alpha n P^n}{K^{n+1}\\left(1 + (P/K)^n\\right)^2}, \\, 0 \\right]^T$\n3.  对于 $\\theta = n$: $\\frac{\\partial \\mathbf{f}}{\\partial n} = \\left[ -\\frac{\\alpha (P/K)^n \\ln(P/K)}{\\left(1+(P/K)^n\\right)^2}, \\, 0 \\right]^T$。如果 $P=0$，此项为 $0$。\n4.  对于 $\\theta = \\delta_m$: $\\frac{\\partial \\mathbf{f}}{\\partial \\delta_m} = \\left[ -m, \\, 0 \\right]^T$\n5.  对于 $\\theta = \\beta$: $\\frac{\\partial \\mathbf{f}}{\\partial \\beta} = \\left[ 0, \\, m \\right]^T$\n6.  对于 $\\theta = \\delta_p$: $\\frac{\\partial \\mathbf{f}}{\\partial \\delta_p} = \\left[ 0, \\, -P \\right]^T$\n\n我们构建一个包含 $2 + 6 \\times 2 = 14$ 个 ODE 的扩展系统。该扩展系统的状态向量为 $\\mathbf{y}(t) = [m, P, s_{m,\\alpha}, s_{P,\\alpha}, s_{m,K}, s_{P,K}, \\dots, s_{m,\\delta_p}, s_{P,\\delta_p}]^T$，其中 $s_{m,\\theta} = \\partial m / \\partial \\theta$ 且 $s_{P,\\theta} = \\partial P / \\partial \\theta$。原始状态的初始条件是 $m(0)=0$ 和 $P(0)=0$。由于初始状态不依赖于参数，因此初始敏感性全为零：对于所有 $\\theta$，$\\mathbf{s}_\\theta(0) = \\mathbf{0}$。因此，扩展系统的初始条件为 $\\mathbf{y}(0) = \\mathbf{0}$。\n\n每个测试用例的步骤如下：\n1.  使用给定的参数集 $(\\alpha, K, n, \\delta_m, \\beta, \\delta_p)$ 定义包含 14 个 ODE 的扩展系统。\n2.  从初始条件 $\\mathbf{y}(0) = \\mathbf{0}$ 开始，将此系统从 $t=0$ 数值积分到最终时间 $T=1000$ 秒。\n3.  从 $t=T$ 时的解中，提取蛋白质浓度 $P(T)$ 和 6 个原始蛋白质敏感性 $\\frac{\\partial P(T)}{\\partial \\theta}$。\n4.  对于每个参数 $\\theta$，计算归一化敏感性指数 $S_\\theta(T) = \\frac{\\theta}{P(T)} \\frac{\\partial P(T)}{\\partial \\theta}$。\n5.  将这 6 个敏感性指数收集到当前测试用例的列表中。\n\n对所有四个测试用例重复此过程，并将结果聚合为单个列表的列表作为最终输出。实现将使用 `scipy.integrate.solve_ivp` 进行数值积分。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes local parameter sensitivities for a genetic autorepressor circuit model.\n    \"\"\"\n\n    # Final time for integration.\n    T = 1000.0\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (alpha, K, n, delta_m, beta, delta_p).\n    test_cases = [\n        (50.0, 1000.0, 2.0, 0.2, 2.0, 0.05),\n        (50.0, 10000.0, 1.0, 0.2, 2.0, 0.05),\n        (200.0, 500.0, 4.0, 0.05, 2.0, 0.01),\n        (50.0, 1000000.0, 2.0, 0.2, 2.0, 0.05),\n    ]\n\n    all_results = []\n    for params_tuple in test_cases:\n        alpha, K, n, delta_m, beta, delta_p = params_tuple\n\n        def augmented_odes(t, y):\n            \"\"\"\n            Defines the augmented system of 14 ODEs for states and sensitivities.\n            State vector y layout:\n            y[0]: m (mRNA)\n            y[1]: P (Protein)\n            y[2], y[3]: sensitivities to alpha (s_m_alpha, s_P_alpha)\n            y[4], y[5]: sensitivities to K (s_m_K, s_P_K)\n            y[6], y[7]: sensitivities to n (s_m_n, s_P_n)\n            y[8], y[9]: sensitivities to delta_m (s_m_dm, s_P_dm)\n            y[10], y[11]: sensitivities to beta (s_m_beta, s_P_beta)\n            y[12], y[13]: sensitivities to delta_p (s_m_dp, s_P_dp)\n            \"\"\"\n            # Unpack states\n            m, P = y[0], y[1]\n\n            # --- Pre-calculate common terms for efficiency ---\n            # Clamp P to be non-negative to avoid domain errors.\n            P_eff = max(0.0, P)\n\n            ratio_P_K = P_eff / K if K  0 else 0.0\n            \n            try:\n                pow_ratio_P_K = ratio_P_K**n\n            except (ValueError, OverflowError):\n                pow_ratio_P_K = float('inf')\n                \n            denom = 1.0 + pow_ratio_P_K\n            repression_term = 1.0 / denom if denom  0 else 0.0\n\n            # --- Original ODEs for m and P ---\n            dm_dt = alpha * repression_term - delta_m * m\n            dP_dt = beta * m - delta_p * P\n\n            # --- Jacobian elements ---\n            # J = [[J11, J12], [J21, J22]]\n            J11 = -delta_m\n            J21 = beta\n            J22 = -delta_p\n            if P_eff  0 and denom  0:\n                J12 = -alpha * n * pow_ratio_P_K / (K * ratio_P_K * denom**2)\n            else:\n                J12 = 0.0\n\n            # --- Forcing terms (derivatives of f with respect to parameters) ---\n            # dfm_d(theta)\n            dfm_dalpha = repression_term\n            \n            if P_eff  0 and K  0 and denom  0:\n                dfm_dK = alpha * n * pow_ratio_P_K / (K * denom**2)\n            else:\n                dfm_dK = 0.0\n            \n            if P_eff  0 and K  0 and ratio_P_K != 1.0 and denom  0:\n                log_ratio = np.log(ratio_P_K)\n                dfm_dn = -alpha * pow_ratio_P_K * log_ratio / (denom**2)\n            else:\n                dfm_dn = 0.0\n\n            dfm_ddm = -m\n            # dfp_d(theta)\n            dfp_dbeta = m\n            dfp_ddp = -P_eff\n\n            # --- ODEs for sensitivities s' = J*s + F_theta ---\n            derivatives = np.zeros(14)\n            derivatives[0] = dm_dt\n            derivatives[1] = dP_dt\n            \n            # Sensitivity pairs [ds_m/dt, ds_P/dt]\n            sens_pairs = [\n                # (forcing_m, forcing_p) for each parameter\n                (dfm_dalpha, 0.0),          # alpha\n                (dfm_dK, 0.0),              # K\n                (dfm_dn, 0.0),              # n\n                (dfm_ddm, 0.0),             # delta_m\n                (0.0, dfp_dbeta),           # beta\n                (0.0, dfp_ddp),             # delta_p\n            ]\n\n            for i, (fm_force, fp_force) in enumerate(sens_pairs):\n                idx = 2 + 2 * i\n                s_m, s_P = y[idx], y[idx + 1]\n                derivatives[idx] = J11 * s_m + J12 * s_P + fm_force\n                derivatives[idx + 1] = J21 * s_m + J22 * s_P + fp_force\n\n            return derivatives\n\n        # Initial conditions: m(0)=0, P(0)=0, all sensitivities are 0.\n        y0 = np.zeros(14)\n\n        # Integrate the augmented ODE system.\n        solution = solve_ivp(\n            augmented_odes,\n            (0, T),\n            y0,\n            method='RK45',\n            t_eval=[T],\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # Extract results at time T.\n        final_state = solution.y[:, -1]\n        P_T = final_state[1]\n\n        # Raw sensitivities of P(T) wrt each parameter\n        # dP/d(alpha, K, n, delta_m, beta, delta_p)\n        raw_sensitivities = [\n            final_state[3], final_state[5], final_state[7],\n            final_state[9], final_state[11], final_state[13]\n        ]\n        \n        # Calculate normalized sensitivity indices: S_theta = (theta/P) * (dP/dtheta)\n        s_indices = []\n        if P_T  1e-9: # Avoid division by zero\n            params = [alpha, K, n, delta_m, beta, delta_p]\n            for i in range(6):\n                S_theta = (params[i] / P_T) * raw_sensitivities[i]\n                s_indices.append(S_theta)\n        else:\n            s_indices = [0.0] * 6 # P is near zero, sensitivities are ill-defined or zero.\n\n        all_results.append(s_indices)\n\n    # Format the output string as per requirements.\n    case_strings = []\n    for res in all_results:\n        case_strings.append(f\"[{','.join(map(str, res))}]\")\n    \n    # Print the final single-line output.\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}