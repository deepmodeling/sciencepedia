{
    "hands_on_practices": [
        {
            "introduction": "本练习至关重要。我们将从随机过程的第一性原理——化学主方程（Chemical Master Equation, CME）出发，推导平均mRNA分子数如何随时间演化。这项练习将为您建立坚实的数学基础，以理解启动子转换动力学和mRNA稳定性如何共同塑造基因表达的动态过程 。",
            "id": "3921300",
            "problem": "考虑一个用于单个基因转录爆发的最小双态启动子模型。启动子状态 $g(t) \\in \\{0,1\\}$ 在非活性状态 $g=0$ 和活性状态 $g=1$ 之间切换，遵循一个连续时间马尔可夫过程，其转移速率为 $k_{on}$（从 $0$ 到 $1$）和 $k_{off}$（从 $1$ 到 $0$）。当启动子处于活性状态（$g=1$）时，信使核糖核酸（mRNA）分子以速率 $s$ 通过泊松过程合成；当启动子处于非活性状态（$g=0$）时，则不发生合成。每个 mRNA 分子以速率 $\\gamma_m$ 独立降解。令 $m(t)$ 表示时间 $t$ 时的 mRNA 拷贝数，令 $\\langle m \\rangle(t)$ 表示其期望值。\n\n从化学主方程（CME, Chemical Master Equation）出发，推导控制平均 mRNA 拷贝数 $\\langle m \\rangle(t)$ 和启动子活性概率 $P_{on}(t) = \\Pr[g(t)=1]$ 时间演化的封闭方程组。然后，求解该方程组，得到在任意初始条件 $m(0)=m_0$ 和 $P_{on}(0)=p_0$ 下，$\\langle m \\rangle(t)$ 的显式闭式表达式，并假设 $\\gamma_m \\neq k_{on}+k_{off}$。\n\n您的最终答案必须是关于 $t$、$m_0$、$p_0$、$k_{on}$、$k_{off}$、$s$ 和 $\\gamma_m$ 的 $\\langle m \\rangle(t)$ 的单一闭式解析表达式。不要四舍五入；请提供精确表达式。最终表达式中不应包含单位。",
            "solution": "该问题要求推导平均 mRNA 拷贝数 $\\langle m \\rangle(t)$ 和启动子活性概率 $P_{on}(t)$ 的时间演化方程，并求解在给定初始条件下的解。推导必须从化学主方程（CME）开始。\n\n令 $P(m, g, t)$ 为在时间 $t$ 有 $m$ 个 mRNA 分子且启动子处于状态 $g \\in \\{0, 1\\}$ 的概率。反应集合为：\n1. 启动子激活：$G_0 \\xrightarrow{k_{on}} G_1$\n2. 启动子失活：$G_1 \\xrightarrow{k_{off}} G_0$\n3. mRNA 合成（转录）：$G_1 \\xrightarrow{s} G_1 + M$\n4. mRNA 降解：$M \\xrightarrow{\\gamma_m} \\emptyset$\n\n化学主方程描述了概率分布 $P(m, g, t)$ 的时间演化。对于两种启动子状态，CME 分别为：\n对于非活性状态（$g=0$）：\n$$ \\frac{dP(m, 0, t)}{dt} = \\gamma_m(m+1)P(m+1, 0, t) - \\gamma_m m P(m, 0, t) - k_{on} P(m, 0, t) + k_{off} P(m, 1, t) $$\n对于活性状态（$g=1$）：\n$$ \\frac{dP(m, 1, t)}{dt} = \\gamma_m(m+1)P(m+1, 1, t) - \\gamma_m m P(m, 1, t) + s P(m-1, 1, t) - s P(m, 1, t) - k_{off} P(m, 1, t) + k_{on} P(m, 0, t) $$\n这里我们假设 $P(-1, 1, t) = 0$。\n\n首先，我们推导启动子活性概率 $P_{on}(t) = \\Pr[g(t)=1] = \\sum_{m=0}^{\\infty} P(m, 1, t)$ 的方程。我们将第二个 CME 对所有可能的 mRNA 拷贝数 $m$ 求和：\n$$ \\frac{d}{dt} \\sum_{m=0}^{\\infty} P(m, 1, t) = \\sum_{m=0}^{\\infty} \\left[ \\gamma_m(m+1)P(m+1, 1, t) - \\gamma_m m P(m, 1, t) \\right] + \\sum_{m=0}^{\\infty} \\left[ s P(m-1, 1, t) - s P(m, 1, t) \\right] - k_{off} \\sum_{m=0}^{\\infty} P(m, 1, t) + k_{on} \\sum_{m=0}^{\\infty} P(m, 0, t) $$\n前两个和是伸缩级数，其值为 $0$。令 $P_{off}(t) = \\sum_{m=0}^{\\infty} P(m, 0, t)$。由于 $P_{on}(t) + P_{off}(t) = 1$，我们有 $P_{off}(t) = 1 - P_{on}(t)$。该方程简化为：\n$$ \\frac{d P_{on}(t)}{dt} = -k_{off} P_{on}(t) + k_{on} P_{off}(t) = -k_{off} P_{on}(t) + k_{on} (1 - P_{on}(t)) $$\n$$ \\frac{d P_{on}(t)}{dt} = k_{on} - (k_{on} + k_{off}) P_{on}(t) $$\n这是第一个所需的一阶常微分方程（ODE）。\n\n接下来，我们推导平均 mRNA 拷贝数 $\\langle m \\rangle(t) = \\sum_{g \\in \\{0,1\\}} \\sum_{m=0}^{\\infty} m P(m, g, t)$ 的方程。其时间导数为 $\\frac{d\\langle m \\rangle}{dt} = \\sum_{g,m} m \\frac{dP(m, g, t)}{dt}$。我们通过将每个 CME 乘以 $m$ 并对 $m$ 和 $g$ 求和来计算。\n$$ \\frac{d\\langle m \\rangle}{dt} = \\sum_{m=0}^{\\infty} m \\frac{dP(m, 0, t)}{dt} + \\sum_{m=0}^{\\infty} m \\frac{dP(m, 1, t)}{dt} $$\n使用性质 $\\sum_{m} m f(m+1)P(m+1) = \\sum_k (k-1)f(k)P(k)$ 和 $\\sum_m m f(m-1)P(m-1) = \\sum_k (k+1)f(k)P(k)$，我们得到：\n- 对于降解：$\\sum_{m=0}^{\\infty} m [\\gamma_m(m+1)P(m+1,g) - \\gamma_m m P(m,g)] = -\\gamma_m \\sum_{m=0}^{\\infty} m P(m,g) = -\\gamma_m \\langle m \\rangle_g(t)$，其中 $\\langle m \\rangle_g(t) = \\sum_m m P(m,g,t)$。\n- 对于合成：$\\sum_{m=0}^{\\infty} m [sP(m-1,1) - sP(m,1)] = s \\sum_m (m+1)P(m,1) - s\\sum_m m P(m,1) = s \\sum_m P(m,1) = sP_{on}(t)$。\n- 对于切换：当加上两种状态的贡献时， $m(k_{off}P(m,1) - k_{on}P(m,0))$ 和 $m(k_{on}P(m,0) - k_{off}P(m,1))$ 对 $m$ 的求和会相互抵消。\n\n结合两种启动子状态的这些结果：\n$$ \\frac{d\\langle m \\rangle}{dt} = (-\\gamma_m\\langle m \\rangle_0 - k_{on}\\langle m \\rangle_0 + k_{off}\\langle m \\rangle_1) + (sP_{on}(t) - \\gamma_m\\langle m \\rangle_1 - k_{off}\\langle m \\rangle_1 + k_{on}\\langle m \\rangle_0) $$\n$$ \\frac{d\\langle m \\rangle(t)}{dt} = s P_{on}(t) - \\gamma_m (\\langle m \\rangle_0(t) + \\langle m \\rangle_1(t)) $$\n$$ \\frac{d \\langle m \\rangle(t)}{dt} = s P_{on}(t) - \\gamma_m \\langle m \\rangle(t) $$\n这是第二个所需的 ODE。\n\n我们现在求解这个 ODE 方程组：\n1. $\\frac{d P_{on}(t)}{dt} = k_{on} - (k_{on} + k_{off}) P_{on}(t)$\n2. $\\frac{d \\langle m \\rangle(t)}{dt} = s P_{on}(t) - \\gamma_m \\langle m \\rangle(t)$\n\n首先，求解 $P_{on}(t)$。这是一个具有常系数的一阶线性 ODE。初始条件为 $P_{on}(0) = p_0$ 的解是：\n$$ P_{on}(t) = P_{on,ss} + (p_0 - P_{on,ss}) \\exp(-(k_{on}+k_{off})t) $$\n其中 $P_{on,ss} = \\frac{k_{on}}{k_{on}+k_{off}}$ 是稳态概率。所以，\n$$ P_{on}(t) = \\frac{k_{on}}{k_{on}+k_{off}} + \\left(p_0 - \\frac{k_{on}}{k_{on}+k_{off}}\\right) \\exp(-(k_{on}+k_{off})t) $$\n接下来，将此代入 $\\langle m \\rangle(t)$ 的方程中：\n$$ \\frac{d \\langle m \\rangle}{dt} + \\gamma_m \\langle m \\rangle = s \\left[ \\frac{k_{on}}{k_{on}+k_{off}} + \\left(p_0 - \\frac{k_{on}}{k_{on}+k_{off}}\\right) \\exp(-(k_{on}+k_{off})t) \\right] $$\n这是一个形如 $\\frac{dy}{dt} + ay = f(t)$ 的一阶线性 ODE。我们使用积分因子 $I(t) = \\exp(\\gamma_m t)$ 来求解它。\n$$ \\langle m \\rangle(t) = \\exp(-\\gamma_m t) \\left( \\int_0^t \\exp(\\gamma_m \\tau) s P_{on}(\\tau) d\\tau + \\langle m \\rangle(0) \\right) $$\n当 $\\langle m \\rangle(0) = m_0$ 时：\n$$ \\langle m \\rangle(t) = m_0 \\exp(-\\gamma_m t) + s \\exp(-\\gamma_m t) \\int_0^t \\exp(\\gamma_m \\tau) \\left[ \\frac{k_{on}}{k_{on}+k_{off}} + \\left(p_0 - \\frac{k_{on}}{k_{on}+k_{off}}\\right) \\exp(-(k_{on}+k_{off})\\tau) \\right] d\\tau $$\n我们计算这个积分：\n$$ \\int_0^t \\left[ \\frac{k_{on}}{k_{on}+k_{off}} \\exp(\\gamma_m \\tau) + \\left(p_0 - \\frac{k_{on}}{k_{on}+k_{off}}\\right) \\exp((\\gamma_m - k_{on} - k_{off})\\tau) \\right] d\\tau $$\n$$ = \\frac{k_{on}}{k_{on}+k_{off}} \\left[ \\frac{\\exp(\\gamma_m \\tau)}{\\gamma_m} \\right]_0^t + \\left(p_0 - \\frac{k_{on}}{k_{on}+k_{off}}\\right) \\left[ \\frac{\\exp((\\gamma_m - k_{on} - k_{off})\\tau)}{\\gamma_m - k_{on} - k_{off}} \\right]_0^t $$\n该计算依赖于条件 $\\gamma_m \\neq k_{on}+k_{off}$。\n$$ = \\frac{k_{on}}{\\gamma_m(k_{on}+k_{off})} (\\exp(\\gamma_m t) - 1) + \\frac{p_0 - \\frac{k_{on}}{k_{on}+k_{off}}}{\\gamma_m - k_{on} - k_{off}} (\\exp((\\gamma_m - k_{on} - k_{off})t) - 1) $$\n将此代回到 $\\langle m \\rangle(t)$ 的表达式中：\n$$ \\langle m \\rangle(t) = m_0 \\exp(-\\gamma_m t) + s \\exp(-\\gamma_m t) \\left[ \\frac{k_{on}}{\\gamma_m(k_{on}+k_{off})} (\\exp(\\gamma_m t) - 1) + \\frac{p_0 - \\frac{k_{on}}{k_{on}+k_{off}}}{\\gamma_m - k_{on} - k_{off}} (\\exp((\\gamma_m - k_{on} - k_{off})t) - 1) \\right] $$\n分配 $s \\exp(-\\gamma_m t)$ 项：\n$$ \\langle m \\rangle(t) = m_0 \\exp(-\\gamma_m t) + \\frac{s k_{on}}{\\gamma_m(k_{on}+k_{off})} (1 - \\exp(-\\gamma_m t)) + \\frac{s(p_0 - \\frac{k_{on}}{k_{on}+k_{off}})}{\\gamma_m - k_{on} - k_{off}} (\\exp(-(k_{on}+k_{off})t) - \\exp(-\\gamma_m t)) $$\n这就是平均 mRNA 拷贝数 $\\langle m \\rangle(t)$ 的最终闭式表达式。",
            "answer": "$$\\boxed{m_0 \\exp(-\\gamma_m t) + \\frac{s k_{on}}{\\gamma_m(k_{on}+k_{off})}(1-\\exp(-\\gamma_m t)) + \\frac{s \\left(p_0 - \\frac{k_{on}}{k_{on}+k_{off}}\\right)}{\\gamma_m - k_{on} - k_{off}} (\\exp(-(k_{on}+k_{off})t) - \\exp(-\\gamma_m t))}$$"
        },
        {
            "introduction": "基因表达并不仅止于mRNA。本练习将我们的模型扩展至包括蛋白质的合成与降解，使我们能够探索转录爆发如何被过滤并转化为蛋白质水平的波动。通过推导和计算mRNA和蛋白质的法诺因子（Fano factor），您将获得量化和比较中心法则不同阶段噪声的实践经验 。",
            "id": "3921303",
            "problem": "考虑一个转录爆发的双态启动子模型。启动子状态由一个二元变量 $S \\in \\{0,1\\}$ 表示，其中 $S=1$ 表示转录活跃状态 (ON)，$S=0$ 表示非活跃状态 (OFF)。启动子以速率 $k_{\\text{on}}$ 从 OFF 切换到 ON，以速率 $k_{\\text{off}}$ 从 ON 切换到 OFF。当启动子处于 ON 状态时，信使核糖核酸 (mRNA) 分子以速率 $k_{\\text{tx}}$ 进行转录。每个 mRNA 分子以速率 $\\gamma_{m}$ 降解。蛋白质通过 mRNA 翻译合成，每个 mRNA 的速率为 $k_{\\text{tl}}$，并以速率 $\\gamma_{p}$ 降解。令 $M$ 表示 mRNA 的拷贝数，$P$ 表示蛋白质的拷贝数。\n\n从化学主方程 (CME) 和生灭过程的定义出发，推导计算 mRNA 的法诺因子（定义为 $F_{M} = \\operatorname{Var}(M)/\\mathbb{E}[M]$）和蛋白质的法诺因子（定义为 $F_{P} = \\operatorname{Var}(P)/\\mathbb{E}[P]$）所需的稳态一阶矩和二阶矩。利用 CME 在质量作用动力学下意味着 $S$、$M$、$P$ 及其乘积的一阶矩和二阶矩的线性演化方程这一事实。不要使用任何捷径结果；从第一性原理推导所需的矩方程。\n\n实现一个程序，该程序：\n- 通过推导出的矩方程计算稳态法诺因子 $F_{M}$ 和 $F_{P}$。\n- 对于每个测试用例，输出比率 $R = F_{P}/F_{M}$，结果为浮点数，并四舍五入到六位小数。\n\n所有参数都是正实数，表示单位时间内的速率；输出是无量纲的比率，无需指定物理单位。使用以下测试套件，每个测试用例以 $(k_{\\text{on}}, k_{\\text{off}}, k_{\\text{tx}}, \\gamma_{m}, k_{\\text{tl}}, \\gamma_{p})$ 的形式给出：\n1. $(1.0, 1.0, 10.0, 1.0, 5.0, 0.5)$，一个具有中等爆发和蛋白质寿命的通用“理想路径”案例。\n2. $(100.0, 100.0, 10.0, 1.0, 5.0, 0.5)$，一个快速切换的边界案例，其中启动子波动被迅速平均化。\n3. $(0.1, 0.1, 10.0, 1.0, 5.0, 0.05)$，一个具有长蛋白质寿命的慢速切换案例，该案例能强烈过滤 mRNA 爆发。\n4. $(0.1, 0.1, 10.0, 1.0, 5.0, 5.0)$，一个具有短蛋白质寿命的慢速切换案例，该案例能紧密跟踪 mRNA 爆发。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，并四舍五入到六位小数，例如 $[r_{1},r_{2},r_{3},r_{4}]$，其中每个 $r_{i}$ 是第 $i$ 个测试用例的比率 $R$。",
            "solution": "该问题要求从基因表达的双态模型的化学主方程 (CME) 出发，推导信使 RNA (mRNA) 和蛋白质拷贝数的稳态法诺因子，分别为 $F_{M}$ 和 $F_{P}$。随后，必须为几组参数计算比率 $R = F_{P}/F_{M}$。\n\n该系统由状态向量 $(S, M, P)$ 描述，其中 $S \\in \\{0, 1\\}$ 是启动子状态，$M$ 是 mRNA 分子的数量，$P$ 是蛋白质分子的数量。反应及其质量作用倾向性为：\n1.  启动子激活：OFF $\\xrightarrow{k_{\\text{on}}}$ ON。倾向性 $a_1 = k_{\\text{on}}(1-S)$。化学计量变化：$\\Delta S = +1$。\n2.  启动子失活：ON $\\xrightarrow{k_{\\text{off}}}$ OFF。倾向性 $a_2 = k_{\\text{off}}S$。化学计量变化：$\\Delta S = -1$。\n3.  转录：ON $\\xrightarrow{k_{\\text{tx}}}$ ON + mRNA。倾向性 $a_3 = k_{\\text{tx}}S$。化学计量变化：$\\Delta M = +1$。\n4.  mRNA 降解：mRNA $\\xrightarrow{\\gamma_{m}}$ $\\emptyset$。倾向性 $a_4 = \\gamma_{m}M$。化学计量变化：$\\Delta M = -1$。\n5.  翻译：mRNA $\\xrightarrow{k_{\\text{tl}}}$ mRNA + 蛋白质。倾向性 $a_5 = k_{\\text{tl}}M$。化学计量变化：$\\Delta P = +1$。\n6.  蛋白质降解：蛋白质 $\\xrightarrow{\\gamma_{p}}$ $\\emptyset$。倾向性 $a_6 = \\gamma_{p}P$。化学计量变化：$\\Delta P = -1$。\n\n任何函数 $f(S, M, P)$ 的期望值的时间演化由主方程形式主义给出：\n$$\n\\frac{d\\mathbb{E}[f]}{dt} = \\sum_{j} \\mathbb{E}[ a_j \\cdot (f_{\\text{after}} - f_{\\text{before}}) ]\n$$\n其中求和遍及所有反应。对于线性倾向性，这简化为矩的线性常微分方程。我们寻求所有时间导数均为零的稳态解。\n\n**1. 稳态下的一阶矩**\n\n对于任何变量 $X$，其一阶矩动力学为 $\\frac{d\\mathbb{E}[X]}{dt} = \\mathbb{E}[\\text{生成速率}] - \\mathbb{E}[\\text{消耗速率}]$。\n- 对于 $\\mathbb{E}[S]$：$\\frac{d\\mathbb{E}[S]}{dt} = \\mathbb{E}[k_{\\text{on}}(1-S) - k_{\\text{off}}S] = k_{\\text{on}}(1-\\mathbb{E}[S]) - k_{\\text{off}}\\mathbb{E}[S]$。\n令其为零：$k_{\\text{on}} = (k_{\\text{on}} + k_{\\text{off}})\\mathbb{E}[S]$。令 $k_s = k_{\\text{on}} + k_{\\text{off}}$。\n$$ \\mathbb{E}[S] = \\frac{k_{\\text{on}}}{k_{\\text{on}} + k_{\\text{off}}} = \\frac{k_{\\text{on}}}{k_s} $$\n这是启动子处于 ON 状态的稳态概率，记为 $p_{\\text{on}}$。\n\n- 对于 $\\mathbb{E}[M]$：$\\frac{d\\mathbb{E}[M]}{dt} = \\mathbb{E}[k_{\\text{tx}}S - \\gamma_m M] = k_{\\text{tx}}\\mathbb{E}[S] - \\gamma_m\\mathbb{E}[M]$。\n令其为零：\n$$ \\mathbb{E}[M] = \\frac{k_{\\text{tx}}}{\\gamma_m}\\mathbb{E}[S] = \\frac{k_{\\text{tx}}}{\\gamma_m}\\frac{k_{\\text{on}}}{k_s} $$\n\n- 对于 $\\mathbb{E}[P]$：$\\frac{d\\mathbb{E}[P]}{dt} = \\mathbb{E}[k_{\\text{tl}}M - \\gamma_p P] = k_{\\text{tl}}\\mathbb{E}[M] - \\gamma_p\\mathbb{E}[P]$。\n令其为零：\n$$ \\mathbb{E}[P] = \\frac{k_{\\text{tl}}}{\\gamma_p}\\mathbb{E}[M] = \\frac{k_{\\text{tl}}k_{\\text{tx}}}{\\gamma_p\\gamma_m}\\frac{k_{\\text{on}}}{k_s} $$\n\n**2. 协方差和方差动力学**\n我们推导二阶矩的动力学。对于任意两个变量 $X$ 和 $Y$，协方差动力学由下式给出：\n$$ \\frac{d\\operatorname{Cov}(X,Y)}{dt} = \\mathbb{E}[\\text{changes to } XY] - \\frac{d(\\mathbb{E}[X]\\mathbb{E}[Y])}{dt} $$\n该系统的涨落-耗散定理为稳态下的协方差提供了一组线性方程。\n\n- 对于 $\\operatorname{Cov}(S, M)$：动力学为 $\\frac{d\\operatorname{Cov}(S,M)}{dt} = k_{\\text{tx}}\\operatorname{Var}(S) - (k_s + \\gamma_m)\\operatorname{Cov}(S,M)$。\n在稳态下，$(k_s + \\gamma_m)\\operatorname{Cov}(S,M) = k_{\\text{tx}}\\operatorname{Var}(S)$。\n由于 $S$ 是一个二元变量，$S^2=S$，因此 $\\operatorname{Var}(S) = \\mathbb{E}[S^2]-\\mathbb{E}[S]^2 = \\mathbb{E}[S]-\\mathbb{E}[S]^2 = \\mathbb{E}[S](1-\\mathbb{E}[S]) = p_{\\text{on}}(1-p_{\\text{on}})$。\n$\\mathbb{E}[S](1-\\mathbb{E}[S]) = \\frac{k_{\\text{on}}}{k_s}(1 - \\frac{k_{\\text{on}}}{k_s}) = \\frac{k_{\\text{on}}k_{\\text{off}}}{k_s^2}$。\n$$ \\operatorname{Cov}(S,M) = \\frac{k_{\\text{tx}}}{k_s + \\gamma_m}\\operatorname{Var}(S) = \\frac{k_{\\text{tx}}k_{\\text{on}}k_{\\text{off}}}{k_s^2(k_s + \\gamma_m)} $$\n\n- 对于 $\\operatorname{Var}(M)$：动力学为 $\\frac{d\\operatorname{Var}(M)}{dt} = 2k_{\\text{tx}}\\operatorname{Cov}(S,M) - 2\\gamma_m \\operatorname{Var}(M) + k_{\\text{tx}}\\mathbb{E}[S] + \\gamma_m \\mathbb{E}[M]$。\n在稳态下，并使用 $k_{\\text{tx}}\\mathbb{E}[S]=\\gamma_m \\mathbb{E}[M]$，我们得到 $2\\gamma_m \\operatorname{Var}(M) = 2k_{\\text{tx}}\\operatorname{Cov}(S,M) + 2\\gamma_m \\mathbb{E}[M]$。\n$$ \\operatorname{Var}(M) = \\frac{k_{\\text{tx}}}{\\gamma_m}\\operatorname{Cov}(S,M) + \\mathbb{E}[M] $$\n\n**3. mRNA 法诺因子 ($F_M$)**\n法诺因子为 $F_M = \\operatorname{Var}(M) / \\mathbb{E}[M]$。\n$$ F_M = \\frac{1}{\\mathbb{E}[M]} \\left(\\frac{k_{\\text{tx}}}{\\gamma_m}\\operatorname{Cov}(S,M) + \\mathbb{E}[M]\\right) = 1 + \\frac{k_{\\text{tx}}}{\\gamma_m \\mathbb{E}[M]}\\operatorname{Cov}(S,M) $$\n代入 $\\mathbb{E}[M]$ 和 $\\operatorname{Cov}(S,M)$ 的表达式：\n$$ F_M = 1 + \\frac{k_{\\text{tx}}}{\\gamma_m \\frac{k_{\\text{tx}}k_{\\text{on}}}{\\gamma_m k_s}} \\frac{k_{\\text{tx}}k_{\\text{on}}k_{\\text{off}}}{k_s^2(k_s + \\gamma_m)} = 1 + \\frac{k_s}{k_{\\text{on}}} \\frac{k_{\\text{tx}}k_{\\text{on}}k_{\\text{off}}}{k_s^2(k_s + \\gamma_m)} $$\n$$ F_M = 1 + \\frac{k_{\\text{tx}}k_{\\text{off}}}{k_s(k_s + \\gamma_m)} = 1 + \\frac{k_{\\text{tx}}k_{\\text{off}}}{(k_{\\text{on}}+k_{\\text{off}})(k_{\\text{on}}+k_{\\text{off}}+\\gamma_m)} $$\n\n**4. 蛋白质方差和协方差**\n我们对与蛋白质相关的矩遵循相同的步骤。\n- 对于 $\\operatorname{Cov}(S, P)$：动力学为 $\\frac{d\\operatorname{Cov}(S,P)}{dt} = k_{\\text{tl}}\\operatorname{Cov}(S,M) - (k_s + \\gamma_p)\\operatorname{Cov}(S,P)$。\n在稳态下：\n$$ \\operatorname{Cov}(S,P) = \\frac{k_{\\text{tl}}}{k_s + \\gamma_p}\\operatorname{Cov}(S,M) $$\n- 对于 $\\operatorname{Cov}(M, P)$：动力学为 $\\frac{d\\operatorname{Cov}(M,P)}{dt} = k_{\\text{tx}}\\operatorname{Cov}(S,P) + k_{\\text{tl}}\\operatorname{Var}(M) - (\\gamma_m + \\gamma_p)\\operatorname{Cov}(M,P)$。\n在稳态下：\n$$ \\operatorname{Cov}(M,P) = \\frac{k_{\\text{tl}}\\operatorname{Var}(M) + k_{\\text{tx}}\\operatorname{Cov}(S,P)}{\\gamma_m + \\gamma_p} $$\n- 对于 $\\operatorname{Var}(P)$：动力学为 $\\frac{d\\operatorname{Var}(P)}{dt} = 2k_{\\text{tl}}\\operatorname{Cov}(M,P) - 2\\gamma_p \\operatorname{Var}(P) + k_{\\text{tl}}\\mathbb{E}[M] + \\gamma_p \\mathbb{E}[P]$。\n在稳态下，并使用 $k_{\\text{tl}}\\mathbb{E}[M]=\\gamma_p \\mathbb{E}[P]$，我们得到 $2\\gamma_p\\operatorname{Var}(P) = 2k_{\\text{tl}}\\operatorname{Cov}(M,P) + 2\\gamma_p\\mathbb{E}[P]$。\n$$ \\operatorname{Var}(P) = \\frac{k_{\\text{tl}}}{\\gamma_p}\\operatorname{Cov}(M,P) + \\mathbb{E}[P] $$\n\n**5. 蛋白质法诺因子 ($F_P$)**\n法诺因子为 $F_P = \\operatorname{Var}(P) / \\mathbb{E}[P]$。\n$$ F_P = 1 + \\frac{k_{\\text{tl}}}{\\gamma_p \\mathbb{E}[P]}\\operatorname{Cov}(M,P) = 1 + \\frac{1}{\\mathbb{E}[M]}\\operatorname{Cov}(M,P) $$\n代入 $\\operatorname{Cov}(M,P)$ 的表达式：\n$$ F_P = 1 + \\frac{1}{\\mathbb{E}[M]} \\frac{k_{\\text{tl}}\\operatorname{Var}(M) + k_{\\text{tx}}\\operatorname{Cov}(S,P)}{\\gamma_m + \\gamma_p} = 1 + \\frac{k_{\\text{tl}}}{\\gamma_m+\\gamma_p}\\frac{\\operatorname{Var}(M)}{\\mathbb{E}[M]} + \\frac{k_{\\text{tx}}}{\\mathbb{E}[M](\\gamma_m+\\gamma_p)}\\operatorname{Cov}(S,P) $$\n$$ F_P = 1 + \\frac{k_{\\text{tl}}}{\\gamma_m + \\gamma_p}F_M + \\frac{k_{\\text{tx}}}{\\mathbb{E}[M](\\gamma_m + \\gamma_p)} \\frac{k_{\\text{tl}}}{k_s + \\gamma_p}\\operatorname{Cov}(S,M) $$\n我们知道 $(F_M - 1) = \\frac{k_{\\text{tx}}}{\\gamma_m \\mathbb{E}[M]}\\operatorname{Cov}(S,M)$，这意味着 $\\frac{k_{\\text{tx}}\\operatorname{Cov}(S,M)}{\\mathbb{E}[M]} = \\gamma_m(F_M - 1)$。\n将此代入 $F_P$ 的表达式中：\n$$ F_P = 1 + \\frac{k_{\\text{tl}}}{\\gamma_m + \\gamma_p}F_M + \\frac{k_{\\text{tl}}}{(\\gamma_m + \\gamma_p)(k_s + \\gamma_p)} \\gamma_m (F_M-1) $$\n这个最终表达式将 $F_P$ 与 $F_M$ 和系统参数联系起来，为计算提供了直接的途径。\n\n计算步骤如下：\n1. 给定一组参数 $(k_{\\text{on}}, k_{\\text{off}}, k_{\\text{tx}}, \\gamma_{m}, k_{\\text{tl}}, \\gamma_{p})$。\n2. 计算 $k_s = k_{\\text{on}} + k_{\\text{off}}$。\n3. 计算 $F_M = 1 + \\frac{k_{\\text{tx}}k_{\\text{off}}}{k_s(k_s + \\gamma_m)}$。\n4. 计算 $F_P = 1 + \\frac{k_{tl}}{\\gamma_m + \\gamma_p}F_M + \\frac{k_{tl} \\gamma_m}{(\\gamma_m + \\gamma_p)(k_s + \\gamma_p)}(F_M - 1)$。\n5. 计算比率 $R = F_P / F_M$。\n6. 对所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the ratio of protein to mRNA Fano factors for transcriptional bursting.\n\n    The function implements analytical solutions for the stationary Fano factors\n    of mRNA (F_M) and protein (F_P) derived from the Chemical Master Equation\n    for a two-state model of gene expression.\n    \"\"\"\n\n    test_cases = [\n        # (k_on, k_off, k_tx, gamma_m, k_tl, gamma_p)\n        (1.0, 1.0, 10.0, 1.0, 5.0, 0.5),\n        (100.0, 100.0, 10.0, 1.0, 5.0, 0.5),\n        (0.1, 0.1, 10.0, 1.0, 5.0, 0.05),\n        (0.1, 0.1, 10.0, 1.0, 5.0, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_on, k_off, k_tx, gamma_m, k_tl, gamma_p = case\n\n        # Total promoter switching rate\n        k_s = k_on + k_off\n\n        # mRNA Fano Factor (F_M)\n        # Formula: F_M = 1 + (k_tx * k_off) / (k_s * (k_s + gamma_m))\n        f_m = 1.0 + (k_tx * k_off) / (k_s * (k_s + gamma_m))\n\n        # Protein Fano Factor (F_P)\n        # Formula relates F_P to F_M\n        # F_P = 1 + (k_tl / (gamma_m + gamma_p)) * F_M \n        #         + (k_tl * gamma_m / ((gamma_m + gamma_p) * (k_s + gamma_p))) * (F_M - 1)\n        term1 = k_tl / (gamma_m + gamma_p)\n        term2 = (k_tl * gamma_m) / ((gamma_m + gamma_p) * (k_s + gamma_p))\n        \n        f_p = 1.0 + term1 * f_m + term2 * (f_m - 1.0)\n        \n        # Ratio R = F_P / F_M\n        ratio = f_p / f_m\n        \n        results.append(round(ratio, 6))\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当理论模型能够解释实验数据时，它们才最具威力。这最后一个练习通过应对从单细胞mRNA计数（例如来自smFISH实验的数据）中进行参数推斷的挑战，将理论与应用联系起来。您将开发一个数值稳定的算法来计算Beta-泊松混合模型下的数据集似然，这是转录爆发的一种广泛使用的近似方法，为您提供了一个关键的定量生物学工具 。",
            "id": "3921221",
            "problem": "考虑一项合成生物学实验，其中转录由于随机的启动子活性而表现出脉冲性。该实验对每个细胞的信使RNA (mRNA) 进行单分子荧光原位杂交 (smFISH) 计数。假设在一个有限的观察窗口内，转录活动可以如下近似：每个细胞有一个有效的启动子占据分数 $p \\in [0,1]$，描述了启动子处于转录活跃状态的时间比例；在给定 $p$ 的条件下，观察到的 mRNA 计数 $n$ 由一个泊松过程生成，其速率为 $\\lambda(p) = \\lambda_{\\max} \\, p$，其中 $\\lambda_{\\max} > 0$ 是一个在整个窗口内完全活跃的启动子所预期的平均计数。为了捕捉启动子占据率的细胞间异质性，假设 $p$ 服从参数为 $\\alpha > 0$ 和 $\\beta > 0$ 的贝塔分布，即 $p \\sim \\mathrm{Beta}(\\alpha,\\beta)$。\n\n从泊松分布和贝塔分布的定义出发，推导在此贝塔-泊松混合近似下，观测到的 smFISH 计数 $n$ 的边缘似然（概率质量函数）：\n$$\n\\mathbb{P}(N=n \\mid \\alpha,\\beta,\\lambda_{\\max}) \n= \\int_{0}^{1} \\mathbb{P}(N=n \\mid \\lambda_{\\max} p) \\, f_{\\mathrm{Beta}}(p \\mid \\alpha,\\beta) \\, \\mathrm{d}p,\n$$\n其中 $\\mathbb{P}(N=n \\mid \\lambda)$ 是泊松概率质量函数，$f_{\\mathrm{Beta}}(p \\mid \\alpha,\\beta)$ 是贝塔概率密度函数。由此，推导出一个独立计数数据集 $\\{n_i\\}_{i=1}^{M}$ 关于 $(\\alpha,\\beta,\\lambda_{\\max})$ 的对数似然函数。\n\n由于该积分通常没有闭合形式的解，请设计一个数值稳定的算法，使用针对代数端点行为定制的高斯求积来评估对数似然。您的算法应：\n- 使用具有 $K$ 个节点的高斯-雅可比求积来近似在 $p \\in [0,1]$ 上带有贝塔权重 $p^{\\alpha-1}(1-p)^{\\beta-1}$ 的积分。\n- 将 $[-1,1]$ 上的标准高斯-雅可比节点和权重适当地变换到 $[0,1]$。\n- 使用稳定的 log-sum-exp 计算来评估加权积分，以避免在 $\\lambda_{\\max}$ 较大或 $\\alpha$ 或 $\\beta$ 小于 $1$ 时出现数值下溢或上溢。\n- 正确处理 $n=0$ 的情况。\n- 明确指出由有限求积阶数和模型失配（例如，贝塔-泊松近似与伽马-泊松负二项替代方案的对比）引起的潜在近似误差，并采取诸如选择足够大的 $K$ 等保障措施。\n\n本问题中的所有量均为无量纲的计数和概率，因此不需要物理单位。问题不涉及角度。最终的实现必须生成下文测试套件中指定的值。\n\n实现一个完整的程序，该程序：\n1. 定义一个函数，使用用户指定节点数 $K$ 的高斯-雅可比求积返回 $\\log \\mathbb{P}(N=n \\mid \\alpha,\\beta,\\lambda_{\\max})$。\n2. 定义一个函数，为数据集 $\\{n_i\\}$ 返回总对数似然 $\\sum_{i=1}^{M} \\log \\mathbb{P}(N=n_i \\mid \\alpha,\\beta,\\lambda_{\\max})$。\n3. 评估以下测试套件。对于每种情况，计算指定的结果：\n   - 情况 A（一般情况，中等参数）：$\\alpha = 2.2$，$\\beta = 5.5$，$\\lambda_{\\max} = 18.0$，数据集 $\\{0,1,2,3,4,7,12\\}$，求积节点 $K=64$。以浮点数形式返回总对数似然。\n   - 情况 B（边界主导的异质性）：$\\alpha = 0.6$，$\\beta = 0.7$，$\\lambda_{\\max} = 25.0$，数据集 $\\{0,0,1,3,8\\}$，求积节点 $K=128$。以浮点数形式返回总对数似然。\n   - 情况 C（大速率，重尾）：$\\alpha = 3.5$，$\\beta = 1.8$，$\\lambda_{\\max} = 100.0$，数据集 $\\{10,20,40,75\\}$，求积节点 $K=96$。以浮点数形式返回总对数似然。\n   - 情况 D（近似误差指示器）：使用与情况 A 相同的参数和数据集，计算用 $K=16$ 和 $K=64$ 计算的总对数似然之间的绝对差值。以浮点数形式返回此差值。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3,result4]”）。所有四种情况的答案都必须是浮点数。",
            "solution": "该问题要求推导和数值评估贝塔-泊松混合模型的对数似然，该模型常用于描述在存在转录脉冲的情况下，来自单分子实验的信使RNA (mRNA) 计数。\n\n### 1. 边缘似然的理论构建\n\n我们已知，对于单个细胞，给定启动子活跃状态分数 $p$ 的条件下，mRNA 计数 $n$ 服从速率为 $\\lambda(p) = \\lambda_{\\max} p$ 的泊松分布。其概率质量函数 (PMF) 为：\n$$ \\mathbb{P}(N=n \\mid p) = \\frac{(\\lambda_{\\max} p)^n e^{-\\lambda_{\\max} p}}{n!} $$\n启动子占据分数 $p$ 本身是一个随机变量，从参数为 $\\alpha > 0$ 和 $\\beta > 0$ 的贝塔分布中抽取。$p$ 的概率密度函数 (PDF) 是：\n$$ f_{\\mathrm{Beta}}(p \\mid \\alpha,\\beta) = \\frac{p^{\\alpha-1} (1-p)^{\\beta-1}}{B(\\alpha,\\beta)} $$\n其中 $B(\\alpha,\\beta) = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$ 是贝塔函数。\n\n观察到计数 $n$ 的边缘似然 $\\mathbb{P}(N=n)$ 是通过将条件概率对所有可能的 $p$ 值进行积分得到的，并以每个 $p$ 的概率加权：\n$$ \\mathbbP(N=n \\mid \\alpha,\\beta,\\lambda_{\\max}) = \\int_{0}^{1} \\mathbb{P}(N=n \\mid p) \\, f_{\\mathrm{Beta}}(p \\mid \\alpha,\\beta) \\, \\mathrm{d}p $$\n代入 PMF 和 PDF 的定义，我们得到：\n$$ \\mathbb{P}(N=n) = \\int_{0}^{1} \\frac{(\\lambda_{\\max} p)^n e^{-\\lambda_{\\max} p}}{n!} \\frac{p^{\\alpha-1} (1-p)^{\\beta-1}}{B(\\alpha,\\beta)} \\, \\mathrm{d}p $$\n我们可以重新整理这些项，以分离出不依赖于 $p$ 的部分：\n$$ \\mathbb{P}(N=n) = \\frac{\\lambda_{\\max}^n}{n! \\, B(\\alpha,\\beta)} \\int_{0}^{1} p^{n+\\alpha-1} (1-p)^{\\beta-1} e^{-\\lambda_{\\max} p} \\, \\mathrm{d}p $$\n该积分通常没有以初等函数表示的通用闭合形式解，这促使我们按要求使用数值求积方法。\n\n### 2. 使用高斯-雅可比求积的数值算法\n\n问题指导我们使用高斯-雅可比求积，这对于具有类贝塔权重函数的积分是理想的。该方法旨在近似以下形式的积分：\n$$ \\int_{-1}^{1} (1-x)^a (1+x)^b f(x) \\, \\mathrm{d}x \\approx \\sum_{k=1}^{K} w_k f(x_k) $$\n其中 $\\{x_k\\}$ 是求积节点，$\\{w_k\\}$ 是相应的权重，由 $K$、$a$ 和 $b$ 决定。\n\n为应用此方法，我们首先重写边缘似然积分，将贝塔分布的核分离为权重函数 $w(p) = p^{\\alpha-1}(1-p)^{\\beta-1}$。被积函数的剩余部分是一个函数 $h(p)$：\n$$ \\mathbb{P}(N=n) = \\frac{1}{B(\\alpha,\\beta)} \\int_{0}^{1} \\underbrace{\\left( \\frac{(\\lambda_{\\max} p)^n e^{-\\lambda_{\\max} p}}{n!} \\right)}_{h(p)} \\underbrace{p^{\\alpha-1} (1-p)^{\\beta-1}}_{w(p)} \\, \\mathrm{d}p $$\n接下来，我们使用换元法 $p = (x+1)/2$（这意味着 $\\mathrm{d}p = \\mathrm{d}x/2$）将积分域从 $p \\in [0,1]$ 变换到 $x \\in [-1,1]$。积分变为：\n$$ \\int_{0}^{1} h(p) w(p) \\, \\mathrm{d}p = \\int_{-1}^{1} h\\left(\\frac{x+1}{2}\\right) \\left(\\frac{x+1}{2}\\right)^{\\alpha-1} \\left(\\frac{1-x}{2}\\right)^{\\beta-1} \\, \\frac{\\mathrm{d}x}{2} $$\n$$ = \\frac{1}{2^{\\alpha+\\beta-1}} \\int_{-1}^{1} h\\left(\\frac{x+1}{2}\\right) (1-x)^{\\beta-1} (1+x)^{\\alpha-1} \\, \\mathrm{d}x $$\n这现在是参数为 $a = \\beta-1$ 和 $b = \\alpha-1$ 的标准高斯-雅可比求积形式。需要在节点处求值的函数是 $h((x+1)/2)$。设 $\\{x_k\\}$ 和 $\\{w_k\\}$ 是这些参数的 $K$ 点高斯-雅可比节点和权重。积分近似为：\n$$ \\int_{0}^{1} h(p) w(p) \\, \\mathrm{d}p \\approx \\frac{1}{2^{\\alpha+\\beta-1}} \\sum_{k=1}^{K} w_k h\\left(\\frac{x_k+1}{2}\\right) $$\n我们定义变换后的节点 $p_k = (x_k+1)/2$。边缘似然的近似为：\n$$ \\mathbb{P}(N=n) \\approx \\frac{1}{B(\\alpha,\\beta) \\, 2^{\\alpha+\\beta-1}} \\sum_{k=1}^{K} w_k h(p_k) = \\frac{1}{B(\\alpha,\\beta) \\, 2^{\\alpha+\\beta-1}} \\sum_{k=1}^{K} w_k \\frac{(\\lambda_{\\max} p_k)^n e^{-\\lambda_{\\max} p_k}}{n!} $$\n\n### 3. 数值稳定的对数似然计算\n\n直接计算总和可能导致数值下溢，特别是当 $\\lambda_{\\max}$ 很大或概率很小时。我们必须通过处理对数来计算对数似然。单个观测值 $n$ 的对数似然是 $\\log \\mathbb{P}(N=n)$。\n$$ \\log \\mathbb{P}(N=n) \\approx \\log\\left( \\sum_{k=1}^K A_k \\right) \\quad \\text{其中} \\quad A_k = \\frac{w_k}{B(\\alpha,\\beta) \\, 2^{\\alpha+\\beta-1}} \\frac{(\\lambda_{\\max} p_k)^n e^{-\\lambda_{\\max} p_k}}{n!} $$\n我们可以计算每一项的对数，$z_k = \\log A_k$：\n$$ z_k = \\log(w_k) - \\log(B(\\alpha,\\beta)) - (\\alpha+\\beta-1)\\log(2) + n\\log(\\lambda_{\\max}) + n\\log(p_k) - \\lambda_{\\max}p_k - \\log(n!) $$\n对数项 $\\log(B(\\alpha,\\beta))$ 和 $\\log(n!)$ 可以使用对数伽马函数 $\\mathrm{gammaln}$ 可靠地计算：$\\log(B(\\alpha,\\beta)) = \\mathrm{gammaln}(\\alpha) + \\mathrm{gammaln}(\\beta) - \\mathrm{gammaln}(\\alpha+\\beta)$ 和 $\\log(n!) = \\mathrm{gammaln}(n+1)$。\n\n为了计算和的对数，我们使用 log-sum-exp 技巧。设 $M = \\max_{k} \\{z_k\\}$。那么，\n$$ \\log \\mathbb{P}(N=n) \\approx M + \\log\\left( \\sum_{k=1}^K e^{z_k - M} \\right) $$\n这种重新表述防止了对非常小的数进行指数运算，并保持了数值精度。该方法对所有 $n \\ge 0$ 都正确有效。\n\n### 4. 数据集的总对数似然\n\n对于一个包含 $M$ 个计数的独立同分布数据集 $\\{n_i\\}_{i=1}^{M}$，总对数似然 $\\mathcal{L}$ 是各个对数似然之和：\n$$ \\mathcal{L}(\\alpha,\\beta,\\lambda_{\\max} \\mid \\{n_i\\}) = \\sum_{i=1}^{M} \\log \\mathbb{P}(N=n_i \\mid \\alpha,\\beta,\\lambda_{\\max}) $$\n为提高计算效率，我们可以首先找出数据集中的唯一计数，为每个唯一计数计算一次对数似然，然后通过乘以每个计数的频率来计算总和。\n\n### 5. 潜在的误差来源\n\n- **求积近似误差**：只有当函数 $h(p)$ 是一个足够低阶的多项式时，高斯-雅可比求积才能提供精确结果。由于 $h(p)$ 包含指数项，它不是多项式，因此有限的 $K$ 会引入近似误差。近似的准确性随着节点数 $K$ 的增加而提高。问题中的情况 D 旨在通过比较 $K=16$ 和 $K=64$ 的结果来量化此误差。\n- **模型失配误差**：贝塔-泊松模型是一个复杂生物过程的现象学抽象。它可能无法完美捕捉真实的数据生成过程。替代模型，如伽马-泊松模型（其产生负二项分布），可能对给定数据集提供更好或更差的拟合。这是一个模型选择问题，与评估所选模型似然的数值准确性不同。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, gammaln\n\ndef log_prob_n(n, alpha, beta, lambda_max, K):\n    \"\"\"\n    Calculates the log marginal likelihood log P(N=n) for the Beta-Poisson model\n    using K-point Gauss-Jacobi quadrature.\n\n    Parameters:\n        n (int): The mRNA count.\n        alpha (float): Shape parameter > 0 of the Beta distribution.\n        beta (float): Shape parameter > 0 of the Beta distribution.\n        lambda_max (float): Max rate of the Poisson process.\n        K (int): Number of quadrature nodes.\n\n    Returns:\n        float: The log marginal likelihood log P(N=n).\n    \"\"\"\n    # Gauss-Jacobi quadrature is for integrals of the form:\n    # integral from -1 to 1 of (1-x)^a * (1+x)^b * f(x) dx\n    # Our weight function is p^(alpha-1) * (1-p)^(beta-1) on [0,1].\n    # After change of variables p = (x+1)/2, the weight becomes\n    # C * (1+x)^(alpha-1) * (1-x)^(beta-1).\n    # So, we set quadrature parameters a = beta - 1 and b = alpha - 1.\n    a_jacobi = beta - 1.0\n    b_jacobi = alpha - 1.0\n    \n    # Get standard Gauss-Jacobi nodes and weights for the interval [-1, 1]\n    x_k, w_k = roots_jacobi(K, a_jacobi, b_jacobi)\n\n    # Transform nodes from [-1, 1] to p_k in [0, 1]\n    p_k = (x_k + 1.0) / 2.0\n\n    # The full integrand term for the log-sum-exp trick is log(A_k), where\n    # P(N=n) = sum(A_k)\n    # A_k = (w_k / (B(a,b) * 2^(a+b-1))) * ( (lambda_max*p_k)^n * exp(-lambda_max*p_k) / n! )\n    \n    # log of B(alpha, beta)\n    log_beta_func = gammaln(alpha) + gammaln(beta) - gammaln(alpha + beta)\n    \n    # log of n!\n    log_n_factorial = gammaln(n + 1)\n    \n    # log of the Poisson probability component h(p_k)\n    # log(h(p_k)) = n*log(lambda_max) + n*log(p_k) - lambda_max*p_k - log(n!)\n    log_h_pk = n * np.log(lambda_max) + n * np.log(p_k) - lambda_max * p_k - log_n_factorial\n\n    # log of the full term A_k for each k\n    # log(A_k) = log(w_k) - log(B(a,b)) - (a+b-1)log(2) + log(h(p_k))\n    log_A_k = np.log(w_k) - log_beta_func - (alpha + beta - 1.0) * np.log(2.0) + log_h_pk\n    \n    # Stable computation of log(sum(exp(log_A_k)))\n    M = np.max(log_A_k)\n    log_probability = M + np.log(np.sum(np.exp(log_A_k - M)))\n\n    return log_probability\n\ndef total_log_likelihood(data, alpha, beta, lambda_max, K):\n    \"\"\"\n    Computes the total log-likelihood for a dataset under the Beta-Poisson model.\n\n    Parameters:\n        data (np.ndarray): Array of mRNA counts.\n        alpha (float): Shape parameter > 0 of the Beta distribution.\n        beta (float): Shape parameter > 0 of the Beta distribution.\n        lambda_max (float): Max rate of the Poisson process.\n        K (int): Number of quadrature nodes.\n\n    Returns:\n        float: The total log-likelihood.\n    \"\"\"\n    unique_ns, counts = np.unique(data, return_counts=True)\n    total_ll = 0.0\n    \n    for n, count in zip(unique_ns, counts):\n        total_ll += count * log_prob_n(int(n), alpha, beta, lambda_max, K)\n        \n    return total_ll\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem and evaluate test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'alpha': 2.2, 'beta': 5.5, 'lambda_max': 18.0, 'data': np.array([0, 1, 2, 3, 4, 7, 12]), 'K': 64, 'id': 'A'},\n        # Case B\n        {'alpha': 0.6, 'beta': 0.7, 'lambda_max': 25.0, 'data': np.array([0, 0, 1, 3, 8]), 'K': 128, 'id': 'B'},\n        # Case C\n        {'alpha': 3.5, 'beta': 1.8, 'lambda_max': 100.0, 'data': np.array([10, 20, 40, 75]), 'K': 96, 'id': 'C'},\n        # Case D\n        {'alpha': 2.2, 'beta': 5.5, 'lambda_max': 18.0, 'data': np.array([0, 1, 2, 3, 4, 7, 12]), 'K_low': 16, 'K_high': 64, 'id': 'D'}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        if case['id'] in ['A', 'B', 'C']:\n            result = total_log_likelihood(case['data'], case['alpha'], case['beta'], case['lambda_max'], case['K'])\n            results.append(result)\n        elif case['id'] == 'D':\n            ll_low = total_log_likelihood(case['data'], case['alpha'], case['beta'], case['lambda_max'], case['K_low'])\n            ll_high = total_log_likelihood(case['data'], case['alpha'], case['beta'], case['lambda_max'], case['K_high'])\n            result = np.abs(ll_low - ll_high)\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}