{
    "hands_on_practices": [
        {
            "introduction": "为了掌握化学主方程，我们从最简单的随机基因表达模型——生灭过程——开始。这个练习将指导你如何从主方程中推导出矩的动态，并计算稳态下的均值和方差。通过计算一个关键的噪声度量——法诺因子（Fano factor），你将能够把一个抽象的数学结果（法诺因子为 $1$）与一个具体的概率分布（泊松分布）联系起来，为理解更复杂系统中的噪声奠定基础。",
            "id": "1517904",
            "problem": "在一个简化的单细胞内基因表达模型中，一种特定类型的信使RNA（mRNA）分子被生产出来并随后降解。新的mRNA分子的产生是一个随机事件，以恒定的平均速率发生，且该速率与已存在的分子数量无关。这可以被建模为一个零级过程。每个现存mRNA分子的降解也是一个随机事件，每个分子在单位时间内都有相等且独立的概率降解。这可以被建模为一个一级过程。\n\n设 $n$ 为在任何给定时刻细胞内这种特定类型mRNA分子的数量。化学反应为：\n1.  生产：$\\emptyset \\xrightarrow{k_p} \\text{mRNA}$\n2.  降解：$\\text{mRNA} \\xrightarrow{k_d} \\emptyset$\n\n此处，$k_p$ 是单个mRNA分子生产的随机速率常数，$k_d$ 是单个mRNA分子降解的随机速率常数。由于这些反应的随机性，分子数量 $n$ 会随时间波动。\n\n一个衡量这些波动相对于平均分子数的有用指标是法诺因子（Fano factor）$F$，其定义为方差与均值的比率：\n$$F = \\frac{\\sigma^2}{\\mu}$$\n其中 $\\mu = \\langle n \\rangle$ 是分子数的均值，而 $\\sigma^2 = \\langle n^2 \\rangle - \\langle n \\rangle^2$ 是方差。\n\n假设系统已达到稳态，法诺因子的值是多少？这个值对mRNA分子数稳态概率分布的性质有何启示？\n\n从以下选项中选择正确的陈述。\n\nA. 法诺因子为1。这表明mRNA分子数服从泊松分布。\n\nB. 法诺因子为0。这表明mRNA分子数是一个没有波动的固定常数。\n\nC. 法诺因子小于1。这表明mRNA分子数的噪声相对于泊松过程受到抑制（亚泊松分布）。\n\nD. 法诺因子大于1。这表明mRNA分子数的噪声相对于泊松过程被放大（超泊松分布）。\n\nE. 法诺因子取决于比率 $k_p / k_d$。这表明噪声的特性随平均分子数的变化而变化。",
            "solution": "我们将该系统建模为一个生灭过程，其出生（生产）速率恒定，死亡（降解）速率线性。设 $P(n,t)$ 为在时间 $t$ 有 $n$ 个mRNA分子的概率。反应为：\n- 出生：$n \\to n+1$，倾向（propensity）为 $k_{p}$。\n- 死亡：$n \\to n-1$，倾向为 $k_{d} n$。\n\n对于任意函数 $f(n)$，其期望值在化学主方程下的时间演化为\n$$\n\\frac{d}{dt}\\langle f(n)\\rangle=\\left\\langle\\left[f(n+1)-f(n)\\right]k_{p}\\right\\rangle+\\left\\langle\\left[f(n-1)-f(n)\\right]k_{d}n\\right\\rangle.\n$$\n\n一阶矩。取 $f(n)=n$。则 $f(n+1)-f(n)=1$ 且 $f(n-1)-f(n)=-1$，得到\n$$\n\\frac{d}{dt}\\langle n\\rangle=k_{p}-k_{d}\\langle n\\rangle.\n$$\n在稳态下，$\\frac{d}{dt}\\langle n\\rangle=0$，所以均值为\n$$\n\\mu=\\langle n\\rangle=\\frac{k_{p}}{k_{d}}.\n$$\n\n二阶矩。取 $f(n)=n^{2}$。则 $f(n+1)-f(n)=2n+1$ 且 $f(n-1)-f(n)=-2n+1$，得出\n$$\n\\frac{d}{dt}\\langle n^{2}\\rangle=\\left\\langle(2n+1)k_{p}\\right\\rangle+\\left\\langle(-2n+1)k_{d}n\\right\\rangle\n=2k_{p}\\langle n\\rangle+k_{p}-2k_{d}\\langle n^{2}\\rangle+k_{d}\\langle n\\rangle.\n$$\n在稳态下，令左侧为零并代入 $\\mu=\\langle n\\rangle$：\n$$\n0=2k_{p}\\mu+k_{p}-2k_{d}\\langle n^{2}\\rangle+k_{d}\\mu.\n$$\n解出 $\\langle n^{2}\\rangle$：\n$$\n2k_{d}\\langle n^{2}\\rangle=2k_{p}\\mu+k_{p}+k_{d}\\mu.\n$$\n使用 $k_{p}=k_{d}\\mu$，右侧变为 $2k_{d}\\mu^{2}+2k_{d}\\mu$，所以\n$$\n\\langle n^{2}\\rangle=\\mu^{2}+\\mu.\n$$\n因此，方差为\n$$\n\\sigma^{2}=\\langle n^{2}\\rangle-\\langle n\\rangle^{2}=\\mu,\n$$\n而法诺因子为\n$$\nF=\\frac{\\sigma^{2}}{\\mu}=1.\n$$\n\n解释。法诺因子为 $1$ 表明稳态分布的方差等于其均值，这是泊松分布的定义性属性。确实，具有恒定出生率和线性死亡率的线性生灭过程，其稳态分布为泊松分布，均值为 $\\mu=k_{p}/k_{d}$。因此，正确的选项是 $F=1$ 且分布为泊松分布。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "生物网络通常包含非线性反应，例如蛋白质二聚化，这为随机建模带来了独特的挑战。这个练习将探讨一个简单的二聚化反应 $2X \\to Y$，并推导其均值和方差的演化方程。你将亲身发现，与线性系统不同，非线性反应的矩方程是不封闭的——即二阶矩的方程依赖于三阶矩，依此类推。理解这个“矩封闭问题”（moment closure problem）对于认识近似方法（如矩封闭近似）的必要性和局限性至关重要。",
            "id": "1471904",
            "problem": "考虑一个在体积恒定的充分混合体系中发生的不可逆二聚反应 $2X \\to Y$。该体系的状态可由物种 X 的分子数 $n_X$ 来表征。由于化学反应在分子层面上的随机性，$n_X$ 是一个随机变量。单位时间内发生单个二聚事件的概率由倾向函数 $a(n_X) = c \\frac{n_X(n_X-1)}{2}$ 给出，其中 $c$ 是随机速率常数。概率分布 $P(n_X, t)$ 的时间演化由化学主方程所支配。\n\n我们关心 X 分子数的统计性质。设平均分子数为 $\\mu(t) = \\langle n_X \\rangle$，并定义 $k$ 阶中心矩为 $\\mu_k(t) = \\langle (n_X - \\mu)^k \\rangle$。注意方差为 $\\sigma^2 = \\mu_2$。\n\n推导平均值 $\\frac{d\\mu}{dt}$ 和方差 $\\frac{d\\mu_2}{dt}$ 时间演化的常微分方程组。用速率常数 $c$、平均值 $\\mu$、方差 $\\mu_2$ 和三阶中心矩 $\\mu_3$ 来表示你的最终答案。将你的两个表达式以行矩阵的形式给出，其中第一个元素为 $\\frac{d\\mu}{dt}$ 的表达式，第二个元素为 $\\frac{d\\mu_2}{dt}$ 的表达式。",
            "solution": "令 $n \\equiv n_X$，并注意单个反应 $2X \\to Y$ 发生时，$n$ 的变化量为 $\\nu=-2$。倾向为 $a(n)=c\\,\\frac{n(n-1)}{2}$。根据化学主方程 (CME)，对于任意函数 $f(n)$，其期望值的时间演化为\n$$\n\\frac{d\\langle f(n)\\rangle}{dt}=\\left\\langle\\left[f(n+\\nu)-f(n)\\right]a(n)\\right\\rangle.\n$$\n对于平均值，取 $f(n)=n$。于是 $f(n+\\nu)-f(n)=(n-2)-n=-2$，所以\n$$\n\\frac{d\\mu}{dt}=\\frac{d\\langle n\\rangle}{dt}=\\left\\langle(-2)\\,a(n)\\right\\rangle=-2\\left\\langle c\\,\\frac{n(n-1)}{2}\\right\\rangle=-c\\langle n(n-1)\\rangle.\n$$\n使用 $\\langle n(n-1)\\rangle=\\langle n^{2}\\rangle-\\langle n\\rangle=(\\mu_{2}+\\mu^{2})-\\mu$，我们得到\n$$\n\\frac{d\\mu}{dt}=-c\\left(\\mu_{2}+\\mu^{2}-\\mu\\right).\n$$\n\n对于方差 $\\mu_{2}=\\langle(n-\\mu)^{2}\\rangle=\\langle n^{2}\\rangle-\\mu^{2}$，对其求导得到\n$$\n\\frac{d\\mu_{2}}{dt}=\\frac{d\\langle n^{2}\\rangle}{dt}-2\\mu\\frac{d\\mu}{dt}.\n$$\n通过取 $f(n)=n^{2}$ 来计算 $d\\langle n^{2}\\rangle/dt$，于是 $f(n+\\nu)-f(n)=(n-2)^{2}-n^{2}=-4n+4$，因此\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=\\left\\langle(-4n+4)\\,a(n)\\right\\rangle=\\left\\langle(-4n+4)\\,c\\,\\frac{n(n-1)}{2}\\right\\rangle\n=c\\left\\langle(-2n+2)\\,n(n-1)\\right\\rangle.\n$$\n展开 $(-2n+2)\\,n(n-1)=(-2n+2)(n^{2}-n)=-2n^{3}+4n^{2}-2n$ 得到\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=c\\left[-2\\langle n^{3}\\rangle+4\\langle n^{2}\\rangle-2\\langle n\\rangle\\right].\n$$\n将原点矩用中心矩表示：$\\langle n\\rangle=\\mu$，$\\langle n^{2}\\rangle=\\mu_{2}+\\mu^{2}$，以及 $\\langle n^{3}\\rangle=\\mu_{3}+3\\mu\\mu_{2}+\\mu^{3}$。代入后得到\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=c\\left[-2(\\mu_{3}+3\\mu\\mu_{2}+\\mu^{3})+4(\\mu_{2}+\\mu^{2})-2\\mu\\right].\n$$\n使用平均值方程 $\\frac{d\\mu}{dt}=-c(\\mu_{2}+\\mu^{2}-\\mu)$，我们得到\n$$\n\\frac{d\\mu_{2}}{dt}=c\\left[-2\\mu_{3}-6\\mu\\mu_{2}-2\\mu^{3}+4\\mu_{2}+4\\mu^{2}-2\\mu\\right]+2c\\mu(\\mu_{2}+\\mu^{2}-\\mu).\n$$\n合并同类项得到\n$$\n\\frac{d\\mu_{2}}{dt}=c\\left[-2\\mu_{3}-4\\mu\\mu_{2}+4\\mu_{2}+2\\mu^{2}-2\\mu\\right]\n=2c\\left[-\\mu_{3}-2\\mu\\mu_{2}+2\\mu_{2}+\\mu^{2}-\\mu\\right].\n$$\n\n因此，用 $c$、$\\mu$、$\\mu_2$ 和 $\\mu_3$ 表示所求的方程组为\n$$\n\\frac{d\\mu}{dt}=-c\\left(\\mu_{2}+\\mu^{2}-\\mu\\right),\\qquad\n\\frac{d\\mu_{2}}{dt}=c\\left(-2\\mu_{3}-4\\mu\\mu_{2}+4\\mu_{2}+2\\mu^{2}-2\\mu\\right).\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-c\\left(\\mu_{2}+\\mu^{2}-\\mu\\right)  2c\\left(-\\mu_{3}-2\\mu\\mu_{2}+2\\mu_{2}+\\mu^{2}-\\mu\\right)\\end{pmatrix}}$$"
        },
        {
            "introduction": "理论分析和计算模拟是化学主方程建模的两个支柱。本练习旨在通过一个全面的编码任务将两者联系起来：你将为经典的生灭过程实现 Gillespie 随机模拟算法。此外，你还需要推导出均值和方差的精确含时解，并通过运行大量的模拟轨迹来验证你的解析结果是否与计算统计数据相符。这项实践不仅能巩固你对随机动力学理论的理解，还能为你提供一个强大的、可用于分析任何化学反应网络的计算工具。",
            "id": "4392582",
            "problem": "考虑一个单物种基因表达的生灭过程，该过程在化学主方程 (CME) 框架下被建模为一个连续时间、离散状态的马尔可夫跳跃过程。令 $X(t) \\in \\mathbb{N}_0$ 表示在时间 $t$ 的分子拷贝数。该系统有两个反应通道：倾向（propensity）为常数 $a_1(n) = k_b$ 的合成（生成）反应 $X \\to X + 1$，以及倾向为 $a_2(n) = k_d n$ 的降解（消亡）反应 $X \\to X - 1$。初始拷贝数为 $X(0) = x_0$。时间单位为秒，速率单位为 $\\mathrm{s^{-1}}$，拷贝数为无单位的计数值。\n\n您必须仅从 CME 以及期望和方差的定义出发，完成以下任务：\n1. 实现上述生灭过程的 Gillespie 直接随机模拟算法，以生成轨迹 $X(t)$，直至达到固定的终止时间 $T$。\n2. 模拟 $M$ 条独立轨迹，并记录在时间 $T$ 的系综分子数 $\\{X_i(T)\\}_{i=1}^M$。\n3. 计算 $\\{X_i(T)\\}_{i=1}^M$ 的经验均值 $\\hat{m}(T)$ 和经验方差 $\\hat{v}(T)$。\n4. 独立地从 CME 推导出在时间 $T$ 的一阶矩和二阶矩的闭式解，即对于任意非负参数 $k_b$、$k_d$、$x_0$ 和 $T$，推导出精确均值 $m(T)$ 和方差 $v(T)$。\n5. 通过检查均值的绝对相对误差和方差的绝对相对误差是否均小于或等于一个固定的容差 $\\varepsilon$，来验证模拟结果与从 CME 推导出的矩的一致性。即，检查是否满足：\n$$\n\\frac{\\lvert \\hat{m}(T) - m(T) \\rvert}{\\max(m(T), 10^{-12})} \\le \\varepsilon\n\\quad \\text{和} \\quad\n\\frac{\\lvert \\hat{v}(T) - v(T) \\rvert}{\\max(v(T), 10^{-12})} \\le \\varepsilon.\n$$\n\n使用 Gillespie 直接法，其中等待时间为精确的指数分布，反应通道根据倾向进行选择。为了保证可复现性，使用固定的伪随机种子，其值等于 $12345$。每个测试用例使用 $M = 6000$ 条轨迹，容差 $\\varepsilon = 0.05$。\n\n实现您的程序以处理以下涵盖典型行为和边界情况的参数集测试套件。对于每个用例，合成速率 $k_b$ 的单位为 $\\mathrm{s^{-1}}$，降解速率 $k_d$ 的单位为 $\\mathrm{s^{-1}}$，初始计数值 $x_0$ 的单位为分子数，终止时间 $T$ 的单位为秒：\n- 用例 1 (典型情况): $k_b = 5.0$, $k_d = 1.0$, $x_0 = 0$, $T = 3.0$。\n- 用例 2 (无合成): $k_b = 0.0$, $k_d = 0.7$, $x_0 = 50$, $T = 1.5$。\n- 用例 3 (慢降解，长时间): $k_b = 2.0$, $k_d = 0.1$, $x_0 = 0$, $T = 20.0$。\n- 用例 4 (快降解，中等合成): $k_b = 9.0$, $k_d = 3.0$, $x_0 = 0$, $T = 1.0$。\n- 用例 5 (非零初始条件): $k_b = 4.0$, $k_d = 0.5$, $x_0 = 20$, $T = 2.0$。\n- 用例 6 (无降解): $k_b = 1.5$, $k_d = 0.0$, $x_0 = 3$, $T = 4.0$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个条目是一个布尔值，表示相应的用例（按上述顺序列出）是否通过了两个矩的容差检查（例如，“[True,False,True,True,True,False]”）。",
            "solution": "该问题要求从化学主方程 (CME) 推导单物种生灭过程的时间依赖性均值和方差，并使用 Gillespie 直接法通过随机模拟来验证这些解析结果。该问题定义明确，具有科学依据，并为获得完整解提供了所有必要的参数。\n\n### 1. 从化学主方程推导精确矩\n\n该系统包含物种 $X$（其拷贝数为 $n$）的两个反应：\n1.  合成（生成）：$\\emptyset \\xrightarrow{k_b} X$，倾向为 $a_1(n) = k_b$。\n2.  降解（消亡）：$X \\xrightarrow{k_d} \\emptyset$，倾向为 $a_2(n) = k_d n$。\n\n令 $P(n,t)$ 为系统在时间 $t$ 含有 $n$ 个分子的概率。支配 $P(n,t)$ 时间演化的 CME 为：\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\n对于 $n \\ge 1$，当 $n=0$ 时有一个特殊形式：$\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)$。如果我们定义 $P(-1, t)=0$，则该通用形式对所有 $n \\in \\mathbb{N}_0$ 均成立。\n\n#### 1.1. 分子数均值\n\n分子数的均值（或一阶矩）定义为 $m(t) = \\langle n \\rangle(t) = \\sum_{n=0}^{\\infty} n P(n,t)$。均值的时间演化可通过对其求时间导数并利用 CME 得到：\n$$\n\\frac{dm(t)}{dt} = \\sum_{n=0}^{\\infty} n \\frac{dP(n,t)}{dt}\n$$\n代入 CME 并逐项计算总和：\n$$\n\\frac{dm(t)}{dt} = \\sum_{n=0}^{\\infty} n \\left[ k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t) \\right]\n$$\n$$\n\\frac{dm(t)}{dt} = k_b \\sum_{n=1}^{\\infty} n P(n-1,t) + k_d \\sum_{n=0}^{\\infty} n(n+1)P(n+1,t) - k_b \\sum_{n=0}^{\\infty} n P(n,t) - k_d \\sum_{n=0}^{\\infty} n^2 P(n,t)\n$$\n通过对求和项重新索引（例如，在第一个和中令 $j=n-1$），我们得到：\n$$\n\\frac{dm(t)}{dt} = k_b \\sum_{j=0}^{\\infty} (j+1) P(j,t) + k_d \\sum_{j=1}^{\\infty} (j-1)j P(j,t) - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n$$\n\\frac{dm(t)}{dt} = k_b (\\langle n \\rangle + 1) + k_d (\\langle n^2 \\rangle - \\langle n \\rangle) - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n$$\n\\frac{dm(t)}{dt} = k_b \\langle n \\rangle + k_b + k_d \\langle n^2 \\rangle - k_d \\langle n \\rangle - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n这简化为关于均值 $m(t)$ 的一阶线性常微分方程 (ODE)：\n$$\n\\frac{dm(t)}{dt} = k_b - k_d m(t)\n$$\n给定初始条件 $m(0) = X(0) = x_0$，我们可以解这个 ODE。\n- 如果 $k_d > 0$：解为\n  $$\n  m(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t}\n  $$\n- 如果 $k_d = 0$：ODE 变为 $\\frac{dm(t)}{dt} = k_b$，积分得到\n  $$\n  m(t) = x_0 + k_b t\n  $$\n\n#### 1.2. 分子数方差\n\n方差为 $v(t) = \\langle n^2 \\rangle - \\langle n \\rangle^2$。我们首先推导方差的 ODE。方差的时间导数为 $\\frac{dv}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2\\langle n \\rangle \\frac{d\\langle n \\rangle}{dt}$。\n我们需要二阶矩 $\\langle n^2 \\rangle = \\sum_{n=0}^{\\infty} n^2 P(n,t)$ 的 ODE。与均值类似，我们发现：\n$$\n\\frac{d\\langle n^2 \\rangle}{dt} = \\sum_{n=0}^{\\infty} n^2 \\frac{dP(n,t)}{dt} = (2k_b + k_d)m(t) + k_b - 2k_d \\langle n^2 \\rangle\n$$\n将此结果和 $m(t)$ 的 ODE 代入 $\\frac{dv}{dt}$ 的表达式中：\n$$\n\\frac{dv}{dt} = \\left[ (2k_b + k_d)m(t) + k_b - 2k_d \\langle n^2 \\rangle \\right] - 2m(t) (k_b - k_d m(t))\n$$\n$$\n\\frac{dv}{dt} = 2k_b m(t) + k_d m(t) + k_b - 2k_d \\langle n^2 \\rangle - 2k_b m(t) + 2k_d m(t)^2\n$$\n$$\n\\frac{dv}{dt} = k_b + k_d m(t) - 2k_d (\\langle n^2 \\rangle - m(t)^2)\n$$\n这得到了方差 $v(t)$ 的一个 ODE：\n$$\n\\frac{dv(t)}{dt} = k_b + k_d m(t) - 2k_d v(t)\n$$\n在初始条件 $v(0)=0$（因为初始状态 $x_0$ 是确定性的）下，我们可以通过代入 $m(t)$ 的解来求解此 ODE。\n- 如果 $k_d > 0$：\n  $$\n  \\frac{dv}{dt} + 2k_d v = k_b + k_d \\left[ \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t} \\right] = 2k_b + (k_d x_0 - k_b) e^{-k_d t}\n  $$\n  在 $v(0)=0$ 的条件下解这个线性一阶 ODE，得到：\n  $$\n  v(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t} - x_0 e^{-2k_d t}\n  $$\n  这可以方便地改写为：\n  $$\n  v(t) = \\frac{k_b}{k_d}(1 - e^{-k_d t}) + x_0 e^{-k_d t}(1 - e^{-k_d t})\n  $$\n- 如果 $k_d = 0$：方差的 ODE 变为 $\\frac{dv}{dt} = k_b$。在 $v(0)=0$ 的条件下，积分得到\n  $$\n  v(t) = k_b t\n  $$\n\n### 2. 随机模拟与验证\n\nGillespie 的随机模拟算法 (SSA)，特别是直接法，被用来生成马尔可夫过程的精确数值实现。\n\n#### 2.1. 算法\n对于从 $t=0$ 时的 $n=x_0$ 开始的单条轨迹，直到 $t \\ge T$：\n1.  计算倾向：$a_1 = k_b$, $a_2 = k_d n$。\n2.  计算总倾向：$a_{tot} = a_1 + a_2$。\n3.  如果 $a_{tot} = 0$，状态是吸收态。模拟时间推进到 $T$，轨迹结束。\n4.  从均匀分布 $U(0,1)$ 中生成两个随机数 $r_1, r_2$。\n5.  计算到下一次反应的时间：$\\tau = \\frac{1}{a_{tot}} \\ln(\\frac{1}{r_1})$。\n6.  如果 $t+\\tau \\ge T$，轨迹结束；状态保持为 $n$。\n7.  否则，推进时间：$t \\leftarrow t + \\tau$。\n8.  选择反应：如果 $r_2 \\cdot a_{tot}  a_1$，则为合成反应（$n \\leftarrow n+1$）；否则为降解反应（$n \\leftarrow n-1$）。\n9.  从步骤 1 开始重复。\n\n#### 2.2. 验证\n对每个参数集，使用固定的伪随机数生成器种子 $12345$ 以确保可复现性，将此过程重复 $M=6000$ 条独立轨迹。收集最终的分子数系综 $\\{X_i(T)\\}_{i=1}^M$。\n\n从该系综计算经验均值 $\\hat{m}(T)$ 和经验方差 $\\hat{v}(T)$：\n$$\n\\hat{m}(T) = \\frac{1}{M}\\sum_{i=1}^{M} X_i(T) \\qquad \\hat{v}(T) = \\frac{1}{M}\\sum_{i=1}^{M} (X_i(T) - \\hat{m}(T))^2\n$$\n通过将这些经验矩与上面推导出的解析矩 $m(T)$ 和 $v(T)$ 进行比较来检查一致性。如果均值和方差的绝对相对误差都小于或等于容差 $\\varepsilon=0.05$，则检查通过：\n$$\n\\frac{\\lvert \\hat{m}(T) - m(T) \\rvert}{\\max(m(T), 10^{-12})} \\le \\varepsilon\n\\quad \\text{和} \\quad\n\\frac{\\lvert \\hat{v}(T) - v(T) \\rvert}{\\max(v(T), 10^{-12})} \\le \\varepsilon\n$$\n使用 $10^{-12}$ 作为分母的下限，以防止除以零或接近零的值。\n\n实现将对每个测试用例应用这些步骤，生成一个布尔结果，指示一致性检查是否通过。",
            "answer": "```python\nimport numpy as np\n\ndef gillespie_single_trajectory(kb, kd, x0, T, rng):\n    \"\"\"\n    Simulates a single trajectory of the birth-death process using Gillespie's direct method.\n    \n    Args:\n        kb (float): Synthesis rate.\n        kd (float): Degradation rate.\n        x0 (int): Initial molecule count.\n        T (float): Terminal time.\n        rng (np.random.Generator): A numpy random number generator instance.\n        \n    Returns:\n        int: The molecule count at time T.\n    \"\"\"\n    t = 0.0\n    n = int(x0)\n    \n    while t  T:\n        a1 = kb\n        a2 = kd * n\n        a_tot = a1 + a2\n        \n        if a_tot = 1e-12:  # No more reactions can occur\n            break\n            \n        r1 = rng.random()\n        tau = -np.log(r1) / a_tot\n        \n        if t + tau >= T:\n            # Next reaction occurs after T, so state at T is the current state.\n            break\n            \n        t += tau\n        \n        r2 = rng.random()\n        \n        if r2 * a_tot  a1:\n            n += 1  # Synthesis\n        else:\n            n -= 1  # Degradation\n\n    return n\n\ndef run_simulation_ensemble(kb, kd, x0, T, M, rng):\n    \"\"\"\n    Runs an ensemble of Gillespie simulations and computes empirical moments.\n    \n    Args:\n        kb, kd, x0, T: Parameters for the simulation.\n        M (int): Number of trajectories in the ensemble.\n        rng (np.random.Generator): A numpy random number generator instance.\n        \n    Returns:\n        tuple[float, float]: The empirical mean and variance.\n    \"\"\"\n    final_counts = np.zeros(M, dtype=int)\n    for i in range(M):\n        final_counts[i] = gillespie_single_trajectory(kb, kd, x0, T, rng)\n        \n    m_hat = np.mean(final_counts)\n    v_hat = np.var(final_counts)  # ddof=0 is default, correct for empirical variance\n    return m_hat, v_hat\n\ndef calculate_analytical_moments(kb, kd, x0, T):\n    \"\"\"\n    Calculates the exact analytical mean and variance at time T.\n    \n    Args:\n        kb, kd, x0, T: Parameters for the model.\n        \n    Returns:\n        tuple[float, float]: The analytical mean and variance.\n    \"\"\"\n    if kd > 1e-12:  # General case for kd > 0\n        kb_over_kd = kb / kd\n        exp_term = np.exp(-kd * T)\n        \n        m_T = kb_over_kd + (x0 - kb_over_kd) * exp_term\n        \n        # This form is numerically stable and directly derived\n        v_T = kb_over_kd * (1 - exp_term) + x0 * exp_term * (1 - exp_term)\n    else:  # Special case for kd = 0 (Poisson process)\n        m_T = kb * T + x0\n        v_T = kb * T\n        \n    return m_T, v_T\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (kb, kd, x0, T)\n        (5.0, 1.0, 0, 3.0),\n        (0.0, 0.7, 50, 1.5),\n        (2.0, 0.1, 0, 20.0),\n        (9.0, 3.0, 0, 1.0),\n        (4.0, 0.5, 20, 2.0),\n        (1.5, 0.0, 3, 4.0),\n    ]\n    \n    M = 6000\n    epsilon = 0.05\n    seed = 12345\n    \n    results = []\n    \n    for case in test_cases:\n        kb, kd, x0, T = case\n        \n        # Calculate analytical moments\n        m_T, v_T = calculate_analytical_moments(kb, kd, x0, T)\n        \n        # Run stochastic simulation ensemble\n        # A new RNG is created for each case to ensure independent reproducibility\n        rng = np.random.default_rng(seed)\n        m_hat, v_hat = run_simulation_ensemble(kb, kd, x0, T, M, rng)\n        \n        # Verify consistency\n        err_m = np.abs(m_hat - m_T) / max(m_T, 1e-12)\n        err_v = np.abs(v_hat - v_T) / max(v_T, 1e-12)\n        \n        passes_check = (err_m = epsilon) and (err_v = epsilon)\n        results.append(passes_check)\n        \n    # Format and print the final output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}