{
    "hands_on_practices": [
        {
            "introduction": "本练习将探讨随机化学动力学中最基本的模型：简单的生灭过程。通过直接从化学主方程推导其稳态均值和方差，我们将揭示该系统的一个关键特性，及其与一个著名概率分布的联系。这是分析基因表达中内在噪声的一项基本技能。",
            "id": "1517880",
            "problem": "考虑一个简化的模型，该模型描述了细胞内一种以 $X$ 表示的蛋白质的随机产生和降解过程。$X$ 分子通过一个可以用恒定概率速率建模的过程逐个产生。在一个无穷小的时间间隔 $dt$ 内发生单个产生事件的概率由 $k_1 dt$ 给出，其中 $k_1$ 是产生速率常数。同时，在相同的时间间隔 $dt$ 内，每个现有的 $X$ 分子都有一个恒定的概率发生降解。对于每个分子，这个概率由 $k_2 dt$ 给出，其中 $k_2$ 是降解速率常数。因此，如果存在 $n$ 个 $X$ 分子，在时间间隔 $dt$ 内发生一个降解事件的总概率是 $n k_2 dt$。\n\n经过足够长的时间后，系统达到一个统计稳态，此时分子数的概率分布 $P(n)$ 不再随时间变化。对于这个稳态分布，求其方差，定义为 $\\text{Var}(n) = \\langle n^2 \\rangle - \\langle n \\rangle^2$。\n\n请用常数 $k_1$ 和 $k_2$ 将您的答案表示为一个闭式解析表达式。",
            "solution": "我们将该系统建模为一个生灭过程，其出生率为常数 $k_{1}$，每个分子的死亡率为 $k_{2}$。设 $n$ 是分子数。对于任意函数 $f(n)$，化学主方程给出了其期望值的演化过程：\n$$\n\\frac{d\\langle f(n)\\rangle}{dt}=\\left\\langle k_{1}\\left[f(n+1)-f(n)\\right]+n k_{2}\\left[f(n-1)-f(n)\\right]\\right\\rangle.\n$$\n\n首先，选择 $f(n)=n$。使用 $(n+1)-n=1$ 和 $(n-1)-n=-1$，我们得到\n$$\n\\frac{d\\langle n\\rangle}{dt}=\\left\\langle k_{1}\\cdot 1+n k_{2}\\cdot(-1)\\right\\rangle=k_{1}-k_{2}\\langle n\\rangle.\n$$\n在稳态下，$d\\langle n\\rangle/dt=0$，所以\n$$\n\\langle n\\rangle=\\frac{k_{1}}{k_{2}}.\n$$\n\n接下来，选择 $f(n)=n^{2}$。使用 $(n+1)^{2}-n^{2}=2n+1$ 和 $(n-1)^{2}-n^{2}=-2n+1$，我们得到\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=\\left\\langle k_{1}(2n+1)+n k_{2}(-2n+1)\\right\\rangle=2k_{1}\\langle n\\rangle+k_{1}-2k_{2}\\langle n^{2}\\rangle+k_{2}\\langle n\\rangle.\n$$\n重新整理，\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=-2k_{2}\\langle n^{2}\\rangle+(2k_{1}+k_{2})\\langle n\\rangle+k_{1}.\n$$\n在稳态下，$d\\langle n^{2}\\rangle/dt=0$，所以\n$$\n\\langle n^{2}\\rangle=\\frac{(2k_{1}+k_{2})\\langle n\\rangle+k_{1}}{2k_{2}}.\n$$\n代入 $\\langle n\\rangle=k_{1}/k_{2}$ 得\n$$\n\\langle n^{2}\\rangle=\\frac{(2k_{1}+k_{2})(k_{1}/k_{2})+k_{1}}{2k_{2}}=\\frac{2k_1^2/k_2 + k_1+k_{1}}{2k_{2}}=\\frac{k_1^2/k_2 + k_1}{k_2}=\\frac{k_{1}^{2}}{k_{2}^{2}}+\\frac{k_{1}}{k_{2}}.\n$$\n\n因此，方差为\n$$\n\\text{Var}(n)=\\langle n^{2}\\rangle-\\langle n\\rangle^{2}=\\left(\\frac{k_{1}^{2}}{k_{2}^{2}}+\\frac{k_{1}}{k_{2}}\\right)-\\left(\\frac{k_{1}}{k_{2}}\\right)^{2}=\\frac{k_{1}}{k_{2}}.\n$$",
            "answer": "$$\\boxed{\\frac{k_{1}}{k_{2}}}$$"
        },
        {
            "introduction": "真实的生物网络通常包含非线性反应，例如二聚化反应。本练习将演示非线性如何使化学主方程的分析变得复杂，并引出“矩封闭问题”。通过推导二聚化反应的矩方程，我们将揭示为何通常无法获得所有矩的精确解析解，从而阐明了近似方法或数值模拟的必要性。",
            "id": "1471904",
            "problem": "考虑一个不可逆二聚反应 $2X \\to Y$，该反应在一个体积恒定的充分混合系统中发生。系统的状态可以用物种X的分子数来表征，记为 $n_X$。由于化学反应在分子水平上的随机性，$n_X$ 是一个随机变量。单位时间内单个二聚事件发生的概率由倾向函数 $a(n_X) = c \\frac{n_X(n_X-1)}{2}$ 给出，其中 $c$ 是随机速率常数。概率分布 $P(n_X, t)$ 的时间演化由化学主方程控制。\n\n我们关心的是X分子数的统计特性。设分子的平均数为 $\\mu(t) = \\langle n_X \\rangle$，并定义k阶中心矩为 $\\mu_k(t) = \\langle (n_X - \\mu)^k \\rangle$。注意方差为 $\\sigma^2 = \\mu_2$。\n\n推导均值 $\\frac{d\\mu}{dt}$ 和方差 $\\frac{d\\mu_2}{dt}$ 时间演化的常微分方程组。用速率常数 $c$、均值 $\\mu$、方差 $\\mu_2$ 和三阶中心矩 $\\mu_3$ 来表示你的最终答案。将你的两个表达式以行矩阵的形式给出，第一个条目是 $\\frac{d\\mu}{dt}$ 的表达式，第二个条目是 $\\frac{d\\mu_2}{dt}$ 的表达式。",
            "solution": "令 $n \\equiv n_{X}$，并注意单个反应 $2X \\to Y$ 发生时，$n$ 的变化量为 $v=-2$。倾向函数为 $a(n)=c\\,\\frac{n(n-1)}{2}$。根据化学主方程（CME），对于任何函数 $f(n)$，其期望值的时间演化为\n$$\n\\frac{d\\langle f(n)\\rangle}{dt}=\\left\\langle\\left[f(n+v)-f(n)\\right]a(n)\\right\\rangle.\n$$\n对于均值，取 $f(n)=n$。则 $f(n+v)-f(n)=(n-2)-n=-2$，所以\n$$\n\\frac{d\\mu}{dt}=\\frac{d\\langle n\\rangle}{dt}=\\left\\langle(-2)\\,a(n)\\right\\rangle=-2\\left\\langle c\\,\\frac{n(n-1)}{2}\\right\\rangle=-c\\langle n(n-1)\\rangle.\n$$\n使用 $\\langle n(n-1)\\rangle=\\langle n^{2}\\rangle-\\langle n\\rangle=(\\mu_{2}+\\mu^{2})-\\mu$，我们得到\n$$\n\\frac{d\\mu}{dt}=-c\\left(\\mu_{2}+\\mu^{2}-\\mu\\right).\n$$\n\n对于方差 $\\mu_{2}=\\langle(n-\\mu)^{2}\\rangle=\\langle n^{2}\\rangle-\\mu^{2}$，对其求导得到\n$$\n\\frac{d\\mu_{2}}{dt}=\\frac{d\\langle n^{2}\\rangle}{dt}-2\\mu\\frac{d\\mu}{dt}.\n$$\n通过取 $f(n)=n^{2}$ 来计算 $d\\langle n^{2}\\rangle/dt$，所以 $f(n+v)-f(n)=(n-2)^{2}-n^{2}=-4n+4$，因此\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=\\left\\langle(-4n+4)\\,a(n)\\right\\rangle=\\left\\langle(-4n+4)\\,c\\,\\frac{n(n-1)}{2}\\right\\rangle\n=c\\left\\langle(-2n+2)\\,n(n-1)\\right\\rangle.\n$$\n展开 $(-2n+2)\\,n(n-1)=(-2n+2)(n^{2}-n)=-2n^{3}+4n^{2}-2n$ 可得\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=c\\left[-2\\langle n^{3}\\rangle+4\\langle n^{2}\\rangle-2\\langle n\\rangle\\right].\n$$\n用中心矩表示原点矩：$\\langle n\\rangle=\\mu$，$\\langle n^{2}\\rangle=\\mu_{2}+\\mu^{2}$，以及 $\\langle n^{3}\\rangle=\\mu_{3}+3\\mu\\mu_{2}+\\mu^{3}$。代入可得\n$$\n\\frac{d\\langle n^{2}\\rangle}{dt}=c\\left[-2(\\mu_{3}+3\\mu\\mu_{2}+\\mu^{3})+4(\\mu_{2}+\\mu^{2})-2\\mu\\right].\n$$\n使用均值方程 $\\frac{d\\mu}{dt}=-c(\\mu_{2}+\\mu^{2}-\\mu)$，我们得到\n$$\n\\frac{d\\mu_{2}}{dt}=c\\left[-2\\mu_{3}-6\\mu\\mu_{2}-2\\mu^{3}+4\\mu_{2}+4\\mu^{2}-2\\mu\\right]+2c\\mu(\\mu_{2}+\\mu^{2}-\\mu).\n$$\n合并同类项可得\n$$\n\\frac{d\\mu_{2}}{dt}=c\\left[-2\\mu_{3}-4\\mu\\mu_{2}+4\\mu_{2}+2\\mu^{2}-2\\mu\\right].\n$$\n\n因此，用 $c$、$\\mu$、$\\mu_{2}$ 和 $\\mu_{3}$ 表示的所求方程组为\n$$\n\\frac{d\\mu}{dt}=-c\\left(\\mu_{2}+\\mu^{2}-\\mu\\right),\\qquad\n\\frac{d\\mu_{2}}{dt}=c\\left(-2\\mu_{3}-4\\mu\\mu_{2}+4\\mu_{2}+2\\mu^{2}-2\\mu\\right).\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-c\\left(\\mu_{2}+\\mu^{2}-\\mu\\right) & c\\left(-2\\mu_{3}-4\\mu\\mu_{2}+4\\mu_{2}+2\\mu^{2}-2\\mu\\right)\\end{pmatrix}}$$"
        },
        {
            "introduction": "这项综合性练习旨在连接化学主方程的解析理论与计算系统生物学的实践应用。你将亲手实现Gillespie随机模拟算法（SSA）——模拟随机反应网络的主力工具，并用它来验证生灭过程的瞬时解析解。本练习将加深你对抽象主方程与具体分子数量随机轨迹之间联系的理解。",
            "id": "4392582",
            "problem": "考虑一个单物种基因表达的生灭过程，该过程被建模为化学主方程 (CME) 下的连续时间、离散状态的马尔可夫跳跃过程。令 $X(t) \\in \\mathbb{N}_0$ 表示在时间 $t$ 的分子拷贝数。该系统有两个反应通道：合成（出生），其倾向为常数 $a_1(n) = k_b$，产生 $X \\to X + 1$；以及降解（死亡），其倾向为 $a_2(n) = k_d n$，产生 $X \\to X - 1$。初始拷贝数为 $X(0) = x_0$。时间单位为秒，速率单位为 $\\mathrm{s^{-1}}$，拷贝数为无单位的计数。\n\n仅从 CME 以及期望和方差的定义出发，您必须：\n1. 为上述生灭过程实现 Gillespie 直接随机模拟算法，以生成直至固定终止时间 $T$ 的轨迹 $X(t)$。\n2. 模拟 $M$ 条独立轨迹，并记录在时间 $T$ 的系综分子数 $\\{X_i(T)\\}_{i=1}^M$。\n3. 计算 $\\{X_i(T)\\}_{i=1}^M$ 的经验均值 $\\hat{m}(T)$ 和经验方差 $\\hat{v}(T)$。\n4. 从 CME 独立推导在时间 $T$ 的一阶矩和二阶矩的闭式表达式，即对于任意非负参数 $k_b$、$k_d$、$x_0$ 和 $T$ 的精确均值 $m(T)$ 和方差 $v(T)$。\n5. 通过检查均值的绝对相对误差和方差的绝对相对误差是否均小于或等于一个固定的容差 $\\varepsilon$，来验证模拟与 CME 推导出的矩之间的一致性，即是否\n$$\n\\frac{\\lvert \\hat{m}(T) - m(T) \\rvert}{\\max(m(T), 10^{-12})} \\le \\varepsilon\n\\quad \\text{and} \\quad\n\\frac{\\lvert \\hat{v}(T) - v(T) \\rvert}{\\max(v(T), 10^{-12})} \\le \\varepsilon.\n$$\n\n使用 Gillespie 直接法，采用精确的指数等待时间和基于倾向的反应通道选择。为保证可复现性，使用固定的伪随机种子 $12345$。每个测试用例使用 $M = 6000$ 条轨迹，容差 $\\varepsilon = 0.05$。\n\n实现您的程序以处理以下参数集测试套件，涵盖典型行为和边界情况。对于每个用例，合成速率 $k_b$ 的单位为 $\\mathrm{s^{-1}}$，降解速率 $k_d$ 的单位为 $\\mathrm{s^{-1}}$，初始数量 $x_0$ 的单位为分子，终止时间 $T$ 的单位为秒：\n- 用例 1 (典型): $k_b = 5.0$, $k_d = 1.0$, $x_0 = 0$, $T = 3.0$。\n- 用例 2 (无合成): $k_b = 0.0$, $k_d = 0.7$, $x_0 = 50$, $T = 1.5$。\n- 用例 3 (慢降解，长时间): $k_b = 2.0$, $k_d = 0.1$, $x_0 = 0$, $T = 20.0$。\n- 用例 4 (快降解，中等合成): $k_b = 9.0$, $k_d = 3.0$, $x_0 = 0$, $T = 1.0$。\n- 用例 5 (非零初始条件): $k_b = 4.0$, $k_d = 0.5$, $x_0 = 20$, $T = 2.0$。\n- 用例 6 (无降解): $k_b = 1.5$, $k_d = 0.0$, $x_0 = 3$, $T = 4.0$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目都是一个布尔值，按上述顺序列出，指示相应案例是否通过了两个矩的容差检查（例如，“[True,False,True,True,True,False]”）。",
            "solution": "该问题要求从化学主方程 (CME) 推导单物种生灭过程随时间变化的均值和方差，并使用 Gillespie 直接法通过随机模拟来验证这些解析结果。该问题是良定的，有科学依据，并为完整求解提供了所有必要的参数。\n\n### 1. 从化学主方程推导精确矩\n\n该系统包含物种 $X$ 的两个反应，其拷贝数为 $n$：\n1.  合成（出生）：$\\emptyset \\xrightarrow{k_b} X$，倾向为 $a_1(n) = k_b$。\n2.  降解（死亡）：$X \\xrightarrow{k_d} \\emptyset$，倾向为 $a_2(n) = k_d n$。\n\n设 $P(n,t)$ 为系统在时间 $t$ 有 $n$ 个分子的概率。控制 $P(n,t)$ 时间演化的 CME 为：\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\n对于 $n \\ge 1$，对于 $n=0$ 有特殊形式：$\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)$。如果我们定义 $P(-1, t)=0$，则该一般形式对所有 $n \\in \\mathbb{N}_0$ 均成立。\n\n#### 1.1. 平均分子数\n\n分子数的均值（或一阶矩）定义为 $m(t) = \\langle n \\rangle(t) = \\sum_{n=0}^{\\infty} n P(n,t)$。通过求时间导数并使用 CME，可以得到均值的时间演化：\n$$\n\\frac{dm(t)}{dt} = \\sum_{n=0}^{\\infty} n \\frac{dP(n,t)}{dt}\n$$\n代入 CME 并逐项计算求和：\n$$\n\\frac{dm(t)}{dt} = \\sum_{n=0}^{\\infty} n \\left[ k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t) \\right]\n$$\n$$\n\\frac{dm(t)}{dt} = k_b \\sum_{n=1}^{\\infty} n P(n-1,t) + k_d \\sum_{n=0}^{\\infty} n(n+1)P(n+1,t) - k_b \\sum_{n=0}^{\\infty} n P(n,t) - k_d \\sum_{n=0}^{\\infty} n^2 P(n,t)\n$$\n通过对求和重新索引（例如，在第一个和式中令 $j=n-1$），我们得到：\n$$\n\\frac{dm(t)}{dt} = k_b \\sum_{j=0}^{\\infty} (j+1) P(j,t) + k_d \\sum_{j=1}^{\\infty} (j-1)j P(j,t) - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n$$\n\\frac{dm(t)}{dt} = k_b (\\langle n \\rangle + 1) + k_d (\\langle n^2 \\rangle - \\langle n \\rangle) - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n$$\n\\frac{dm(t)}{dt} = k_b \\langle n \\rangle + k_b + k_d \\langle n^2 \\rangle - k_d \\langle n \\rangle - k_b \\langle n \\rangle - k_d \\langle n^2 \\rangle\n$$\n这可以简化为关于均值 $m(t)$ 的一阶线性常微分方程 (ODE)：\n$$\n\\frac{dm(t)}{dt} = k_b - k_d m(t)\n$$\n给定初始条件 $m(0) = X(0) = x_0$，我们可以解此 ODE。\n- 若 $k_d > 0$：解为\n  $$\n  m(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t}\n  $$\n- 若 $k_d = 0$：ODE 变为 $\\frac{dm(t)}{dt} = k_b$，积分为\n  $$\n  m(t) = x_0 + k_b t\n  $$\n\n#### 1.2. 分子数的方差\n\n方差为 $v(t) = \\langle n^2 \\rangle - \\langle n \\rangle^2$。我们首先推导方差的 ODE。方差的时间导数为 $\\frac{dv}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2\\langle n \\rangle \\frac{d\\langle n \\rangle}{dt}$。\n我们需要二阶矩 $\\langle n^2 \\rangle = \\sum_{n=0}^{\\infty} n^2 P(n,t)$ 的 ODE。与均值类似，我们得到：\n$$\n\\frac{d\\langle n^2 \\rangle}{dt} = \\sum_{n=0}^{\\infty} n^2 \\frac{dP(n,t)}{dt} = (2k_b + k_d)m(t) + k_b - 2k_d \\langle n^2 \\rangle\n$$\n将此式和 $m(t)$ 的 ODE 代入 $\\frac{dv}{dt}$ 的表达式中：\n$$\n\\frac{dv}{dt} = \\left[ (2k_b + k_d)m(t) + k_b - 2k_d \\langle n^2 \\rangle \\right] - 2m(t) (k_b - k_d m(t))\n$$\n$$\n\\frac{dv}{dt} = 2k_b m(t) + k_d m(t) + k_b - 2k_d \\langle n^2 \\rangle - 2k_b m(t) + 2k_d m(t)^2\n$$\n$$\n\\frac{dv}{dt} = k_b + k_d m(t) - 2k_d (\\langle n^2 \\rangle - m(t)^2)\n$$\n这就得到了方差 $v(t)$ 的一个 ODE：\n$$\n\\frac{dv(t)}{dt} = k_b + k_d m(t) - 2k_d v(t)\n$$\n在初始条件 $v(0)=0$（因为初始状态 $x_0$ 是确定性的）下，我们可以通过代入 $m(t)$ 的解来解这个 ODE。\n- 若 $k_d > 0$：\n  $$\n  \\frac{dv}{dt} + 2k_d v = k_b + k_d \\left[ \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t} \\right] = 2k_b + (k_d x_0 - k_b) e^{-k_d t}\n  $$\n  在 $v(0)=0$ 的条件下解此一阶线性 ODE，可得：\n  $$\n  v(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) e^{-k_d t} - x_0 e^{-2k_d t}\n  $$\n  这可以方便地改写为：\n  $$\n  v(t) = \\frac{k_b}{k_d}(1 - e^{-k_d t}) + x_0 e^{-k_d t}(1 - e^{-k_d t})\n  $$\n- 若 $k_d = 0$：方差的 ODE 变为 $\\frac{dv}{dt} = k_b$。在 $v(0)=0$ 的条件下，积分为\n  $$\n  v(t) = k_b t\n  $$\n\n### 2. 随机模拟与验证\n\nGillespie 随机模拟算法 (SSA)，特别是其直接法，被用来生成马尔可夫过程的精确数值实现。\n\n#### 2.1. 算法\n对于从 $t=0$ 时 $n=x_0$ 开始的单条轨迹，直到 $t \\ge T$：\n1.  计算倾向：$a_1 = k_b$, $a_2 = k_d n$。\n2.  计算总倾向：$a_{tot} = a_1 + a_2$。\n3.  如果 $a_{tot} = 0$，则状态是吸收态。模拟时间推进到 $T$，轨迹结束。\n4.  从均匀分布 $U(0,1)$ 中生成两个随机数 $r_1, r_2$。\n5.  计算到下一次反应的时间：$\\tau = \\frac{1}{a_{tot}} \\ln(\\frac{1}{r_1})$。\n6.  如果 $t+\\tau \\ge T$，轨迹结束；状态保持为 $n$。\n7.  否则，推进时间：$t \\leftarrow t + \\tau$。\n8.  选择反应：如果 $r_2 \\cdot a_{tot} < a_1$，则为合成 ($n \\leftarrow n+1$)；否则为降解 ($n \\leftarrow n-1$)。\n9.  从步骤 1 重复。\n\n#### 2.2. 验证\n对每个参数集，此过程重复进行 $M=6000$ 次独立轨迹模拟，为保证可复现性使用固定的伪随机数生成器种子 $12345$。收集最终分子数的系综 $\\{X_i(T)\\}_{i=1}^M$。\n\n从该系综计算经验均值 $\\hat{m}(T)$ 和经验方差 $\\hat{v}(T)$：\n$$\n\\hat{m}(T) = \\frac{1}{M}\\sum_{i=1}^{M} X_i(T) \\qquad \\hat{v}(T) = \\frac{1}{M}\\sum_{i=1}^{M} (X_i(T) - \\hat{m}(T))^2\n$$\n通过将这些经验矩与上面推导出的解析矩 $m(T)$ 和 $v(T)$进行比较来检查一致性。如果均值和方差的绝对相对误差都小于或等于容差 $\\varepsilon=0.05$，则检查通过：\n$$\n\\frac{\\lvert \\hat{m}(T) - m(T) \\rvert}{\\max(m(T), 10^{-12})} \\le \\varepsilon\n\\quad \\text{and} \\quad\n\\frac{\\lvert \\hat{v}(T) - v(T) \\rvert}{\\max(v(T), 10^{-12})} \\le \\varepsilon\n$$\n使用值 $10^{-12}$ 作为分母的下限，以防止除以零或接近零的值。\n\n该实现将对每个测试用例应用这些步骤，生成一个布尔结果，指示一致性检查是否通过。",
            "answer": "```python\nimport numpy as np\n\ndef gillespie_single_trajectory(kb, kd, x0, T, rng):\n    \"\"\"\n    Simulates a single trajectory of the birth-death process using Gillespie's direct method.\n    \n    Args:\n        kb (float): Synthesis rate.\n        kd (float): Degradation rate.\n        x0 (int): Initial molecule count.\n        T (float): Terminal time.\n        rng (np.random.Generator): A numpy random number generator instance.\n        \n    Returns:\n        int: The molecule count at time T.\n    \"\"\"\n    t = 0.0\n    n = int(x0)\n    \n    while t  T:\n        a1 = kb\n        a2 = kd * n\n        a_tot = a1 + a2\n        \n        if a_tot = 1e-12:  # No more reactions can occur\n            break\n            \n        r1 = rng.random()\n        tau = -np.log(r1) / a_tot\n        \n        if t + tau >= T:\n            # Next reaction occurs after T, so state at T is the current state.\n            break\n            \n        t += tau\n        \n        r2 = rng.random()\n        \n        if r2 * a_tot  a1:\n            n += 1  # Synthesis\n        else:\n            n -= 1  # Degradation\n\n    return n\n\ndef run_simulation_ensemble(kb, kd, x0, T, M, rng):\n    \"\"\"\n    Runs an ensemble of Gillespie simulations and computes empirical moments.\n    \n    Args:\n        kb, kd, x0, T: Parameters for the simulation.\n        M (int): Number of trajectories in the ensemble.\n        rng (np.random.Generator): A numpy random number generator instance.\n        \n    Returns:\n        tuple[float, float]: The empirical mean and variance.\n    \"\"\"\n    final_counts = np.zeros(M, dtype=int)\n    for i in range(M):\n        final_counts[i] = gillespie_single_trajectory(kb, kd, x0, T, rng)\n        \n    m_hat = np.mean(final_counts)\n    v_hat = np.var(final_counts)  # ddof=0 is default, correct for empirical variance\n    return m_hat, v_hat\n\ndef calculate_analytical_moments(kb, kd, x0, T):\n    \"\"\"\n    Calculates the exact analytical mean and variance at time T.\n    \n    Args:\n        kb, kd, x0, T: Parameters for the model.\n        \n    Returns:\n        tuple[float, float]: The analytical mean and variance.\n    \"\"\"\n    if kd > 1e-12:  # General case for kd > 0\n        kb_over_kd = kb / kd\n        exp_term = np.exp(-kd * T)\n        \n        m_T = kb_over_kd + (x0 - kb_over_kd) * exp_term\n        \n        # This form is numerically stable and directly derived\n        v_T = kb_over_kd * (1 - exp_term) + x0 * exp_term * (1 - exp_term)\n    else:  # Special case for kd = 0 (Poisson process)\n        m_T = kb * T + x0\n        v_T = kb * T\n        \n    return m_T, v_T\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (kb, kd, x0, T)\n        (5.0, 1.0, 0, 3.0),\n        (0.0, 0.7, 50, 1.5),\n        (2.0, 0.1, 0, 20.0),\n        (9.0, 3.0, 0, 1.0),\n        (4.0, 0.5, 20, 2.0),\n        (1.5, 0.0, 3, 4.0),\n    ]\n    \n    M = 6000\n    epsilon = 0.05\n    seed = 12345\n    \n    results = []\n    \n    for case in test_cases:\n        kb, kd, x0, T = case\n        \n        # Calculate analytical moments\n        m_T, v_T = calculate_analytical_moments(kb, kd, x0, T)\n        \n        # Run stochastic simulation ensemble\n        # A new RNG is created for each case to ensure independent reproducibility\n        rng = np.random.default_rng(seed)\n        m_hat, v_hat = run_simulation_ensemble(kb, kd, x0, T, M, rng)\n        \n        # Verify consistency\n        err_m = np.abs(m_hat - m_T) / max(m_T, 1e-12)\n        err_v = np.abs(v_hat - v_T) / max(v_T, 1e-12)\n        \n        passes_check = (err_m = epsilon) and (err_v = epsilon)\n        results.append(passes_check)\n        \n    # Format and print the final output exactly as specified\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\nsolve()\n\n```"
        }
    ]
}