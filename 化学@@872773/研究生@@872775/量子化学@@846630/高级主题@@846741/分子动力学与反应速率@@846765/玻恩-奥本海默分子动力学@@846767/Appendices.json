{"hands_on_practices": [{"introduction": "任何分子动力学模拟的核心都是数值积分器，它根据计算出的作用力来传播原子核的运动。这个练习将重点放在实现玻恩-奥本海默分子动力学（BOMD）的一个基本构件：速度 Verlet 算法。通过使用一个理想化的“神谕”来提供势能和力，我们可以将量子化学计算的复杂性抽象出来，专注于核动力学本身，从而为更复杂的模拟打下坚实的基础。[@problem_id:2451186]", "problem": "实现一个在Born-Oppenheimer分子动力学 (BOMD) 框架下的单原子核时间步。该系统由在牛顿力学下、于基态电子势能面上演化的点状原子核构成。电子势能和力由一个可调用的电子结构预言机提供。所有原子均在一维空间中进行计算。使用原子单位：距离以玻尔 (bohr) 为单位，质量以电子质量为单位，时间以原子时间单位为单位，能量以哈特里 (Hartree) 为单位。对于每个测试用例，返回一个时间步后的总能量（势能加动能），以哈特里 (Hartree) 为单位表示，并四舍五入到八位小数。\n\n定义与要求：\n- 原子核在Born-Oppenheimer势能面上遵循牛顿第二定律：对于索引为 $i$、质量为 $m_i$、位置为 $R_i(t)$、速度为 $v_i(t)$ 且受力为 $F_i(\\mathbf{R}) = -\\partial E(\\mathbf{R})/\\partial R_i$ 的原子，其加速度为 $a_i(t) = F_i(\\mathbf{R}(t))/m_i$。\n- 从 $t$ 到 $t+\\Delta t$ 的一个时间步由以下位置和速度的更新方程定义，其中 $\\Delta t$ 是时间步长，并且必须在时间步结束时计算新位置上的力：\n  1. 使用当前位置、速度和加速度更新位置：\n     $$R_i(t+\\Delta t) = R_i(t) + v_i(t)\\,\\Delta t + \\frac{1}{2}a_i(t)\\,\\Delta t^2.$$\n  2. 在更新后的位置 $F_i(\\mathbf{R}(t+\\Delta t))$ 上计算新的力，以及相应的新加速度 $a_i(t+\\Delta t) = F_i(\\mathbf{R}(t+\\Delta t))/m_i$。\n  3. 使用新旧加速度的平均值更新速度：\n     $$v_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\big(a_i(t) + a_i(t+\\Delta t)\\big)\\,\\Delta t.$$\n- 本问题中使用的电子结构预言机返回以下模型基态势能和力。设键的集合由参数为 $(i,j,k,r_0)$ 的原子对指定。势能是各项谐振子键贡献之和：\n  $$E(\\mathbf{R}) = \\sum_{\\text{bonds }(i,j)} \\frac{1}{2}k\\left(\\lvert R_j - R_i\\rvert - r_0\\right)^2,$$\n  并且由键 $(i,j)$ 作用在原子 $i$ 上的力是该能量的负梯度。在一维情况下，当 $R_j \\ge R_i$ 时，作用在原子 $j$ 上的键力为 $F_j = -k\\left((R_j-R_i)-r_0\\right)$，作用在原子 $i$ 上的力为 $F_i = -F_j$；对于 $R_j  R_i$ 的情况，将 $(R_j-R_i)$ 替换为 $\\lvert R_j-R_i\\rvert$，并根据绝对值的导数确定适当的符号。\n- 在时间步结束时需要报告的总能量为\n  $$E_{\\text{tot}}(t+\\Delta t) = E(\\mathbf{R}(t+\\Delta t)) + \\sum_i \\frac{1}{2} m_i\\, v_i(t+\\Delta t)^2.$$\n\n测试组：\n为以下四个独立的测试用例提供结果。在每个用例中，系统都是一维的，所有数组都按原子索引排序。键列表中的索引是从零开始的。\n\n- 测试用例A（零力，平衡位置静止）：\n  - 原子数：$2$。\n  - 质量：$\\big[m_0, m_1\\big] = \\big[1836, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0)\\big] = \\big[0.0, 1.0\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0)\\big] = \\big[0.0, 0.0\\big]$。\n  - 时间步长：$\\Delta t = 0.05$。\n  - 键：一个键 $(i,j,k,r_0) = (0, 1, 0.5, 1.0)$。\n\n- 测试用例B（双原子拉伸，从静止释放）：\n  - 原子数：$2$。\n  - 质量：$\\big[m_0, m_1\\big] = \\big[1836, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0)\\big] = \\big[0.0, 1.1\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0)\\big] = \\big[0.0, 0.0\\big]$。\n  - 时间步长：$\\Delta t = 0.05$。\n  - 键：一个键 $(i,j,k,r_0) = (0, 1, 0.5, 1.0)$。\n\n- 测试用例C（线性三原子，对称拉伸，中心原子更重）：\n  - 原子数：$3$。\n  - 质量：$\\big[m_0, m_1, m_2\\big] = \\big[1836, 3672, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0), R_2(0)\\big] = \\big[0.0, 1.1, 2.2\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0), v_2(0)\\big] = \\big[0.0, 0.0, 0.0\\big]$。\n  - 时间步长：$\\Delta t = 0.05$。\n  - 键：两个键 $(i,j,k,r_0) \\in \\{(0, 1, 0.7, 1.0), (1, 2, 0.7, 1.0)\\}$。\n\n- 测试用例D（边界情况 $\\Delta t = 0$）：\n  - 原子数：$2$。\n  - 质量：$\\big[m_0, m_1\\big] = \\big[1836, 1836\\big]$。\n  - 初始位置：$\\big[R_0(0), R_1(0)\\big] = \\big[0.0, 1.1\\big]$。\n  - 初始速度：$\\big[v_0(0), v_1(0)\\big] = \\big[0.01, -0.02\\big]$。\n  - 时间步长：$\\Delta t = 0.0$。\n  - 键：一个键 $(i,j,k,r_0) = (0, 1, 0.5, 1.0)$。\n\n你的程序必须：\n- 完全按照上述说明实现时间步进更新。\n- 对每个测试用例，在初始位置（以获得 $E(\\mathbf{R}(0))$ 和 $\\mathbf{F}(\\mathbf{R}(0))$）精确调用一次电子结构预言机，并在更新后的位置（以获得 $E(\\mathbf{R}(\\Delta t))$ 和 $\\mathbf{F}(\\mathbf{R}(\\Delta t))$）精确调用一次。\n- 对每个测试用例，计算 $E_{\\text{tot}}(\\Delta t)$，并以哈特里 (Hartree) 为单位将其四舍五入到八位小数。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含四个结果，以逗号分隔并用方括号括起来，例如 $\\big[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D\\big]$，其中每个条目都是一个以哈特里 (Hartree) 为单位的浮点数，格式化为小数点后八位。", "solution": "该问题已经过验证，被认为是科学上可靠、定义明确且客观的。它提出了一个理论化学领域的标准计算任务。未发现任何缺陷。因此，兹提供一个解决方案。\n\n该问题要求为一个一维点核系统实现Born-Oppenheimer分子动力学 (BOMD) 的单时间步。其动力学由经典牛顿力学在一个由电子结构预言机提供的势能面 (PES) 上支配。所有计算均以原子单位进行。\n\n首先，我们定义物理模型。Born-Oppenheimer近似假设电子和原子核的运动是解耦的。这使得势能面 (PES) $E(\\mathbf{R})$ 的概念得以成立，其中总电子能量是原子核坐标 $\\mathbf{R} = \\{R_i\\}$ 的函数。原子核被视为质量为 $\\{m_i\\}$ 的经典点粒子，根据牛顿第二定律运动，其中作用于每个原子核的力从势能面 (PES) 导出：\n$$\n\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} E(\\mathbf{R}) \\implies F_i(\\mathbf{R}) = -\\frac{\\partial E(\\mathbf{R})}{\\partial R_i}\n$$\n每个原子核的加速度则由 $a_i(t) = F_i(\\mathbf{R}(t)) / m_i$ 给出。\n\n此问题的特定势能面 (PES) 是一系列谐振子键势之和：\n$$\nE(\\mathbf{R}) = \\sum_{\\text{bonds }(i,j)} E_{ij}(R_i, R_j) = \\sum_{\\text{bonds }(i,j)} \\frac{1}{2}k\\left(\\lvert R_j - R_i\\rvert - r_0\\right)^2\n$$\n其中对于每个键 $(i, j)$，$k$ 是力常数，$r_0$ 是平衡键长。由于与原子 $i$ 成键，作用在原子 $j$ 上的力为：\n$$\nF_{j \\leftarrow ij} = -\\frac{\\partial E_{ij}}{\\partial R_j} = -k\\left(\\lvert R_j - R_i\\rvert - r_0\\right) \\frac{\\partial \\lvert R_j - R_i\\rvert}{\\partial R_j} = -k\\left(\\lvert R_j - R_i\\rvert - r_0\\right) \\text{sgn}(R_j - R_i)\n$$\n根据牛顿第三定律，该键作用于原子 $i$ 上的力为 $F_{i \\leftarrow ij} = -F_{j \\leftarrow ij}$。作用于任意给定原子 $i$ 的总力 $F_i$ 是其参与的所有键产生的力的矢量和。\n\n为了将系统从时间 $t$ 传播到 $t+\\Delta t$，需要一个数值积分方案。该问题指定了一种算法，它是著名的速度Verlet积分器的一种形式。单个时间步的步骤如下：\n\n1.  **给定**：在时间 $t$，位置 $\\mathbf{R}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t)$ 是已知的。加速度由当前位置的力计算得出：$\\mathbf{a}(t) = \\mathbf{F}(\\mathbf{R}(t)) / \\mathbf{m}$。\n\n2.  **位置更新**：新位置 $\\mathbf{R}(t+\\Delta t)$ 使用二阶泰勒展开计算：\n    $$\n    R_i(t+\\Delta t) = R_i(t) + v_i(t)\\Delta t + \\frac{1}{2}a_i(t)\\Delta t^2\n    $$\n\n3.  **力/加速度更新**：利用新位置 $\\mathbf{R}(t+\\Delta t)$，使用电子结构预言机重新计算力 $\\mathbf{F}(\\mathbf{R}(t+\\Delta t))$。然后计算新的加速度 $\\mathbf{a}(t+\\Delta t)$：\n    $$\n    a_i(t+\\Delta t) = F_i(\\mathbf{R}(t+\\Delta t)) / m_i\n    $$\n\n4.  **速度更新**：新速度 $\\mathbf{v}(t+\\Delta t)$ 使用旧加速度和新加速度的平均值计算。这一步是速度Verlet算法的特点，并使其具有良好的能量守恒性质。\n    $$\n    v_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\left(a_i(t) + a_i(t+\\Delta t)\\right)\\Delta t\n    $$\n\n最后，计算在时间步 $t+\\Delta t$ 结束时系统的总能量。这是新位置上的势能 $E(\\mathbf{R}(t+\\Delta t))$ 与用新速度计算的动能 $K(\\mathbf{v}(t+\\Delta t))$ 之和：\n$$\nE_{\\text{tot}}(t+\\Delta t) = E(\\mathbf{R}(t+\\Delta t)) + K(\\mathbf{v}(t+\\Delta t)) = E(\\mathbf{R}(t+\\Delta t)) + \\sum_i \\frac{1}{2} m_i v_i(t+\\Delta t)^2\n$$\n该量是每个测试用例所需的输出，四舍五入到八位小数。实现将包含一个用于从给定势能模型计算能量和力的函数，以及一个执行上述步骤的主传播函数。", "answer": "```python\nimport numpy as np\n\ndef compute_energy_and_forces(positions, bonds):\n    \"\"\"\n    Computes the potential energy and forces for a given set of atomic positions.\n    This function acts as the electronic-structure oracle.\n\n    Args:\n        positions (np.ndarray): 1D array of atomic positions.\n        bonds (list): List of bond tuples (i, j, k, r0).\n\n    Returns:\n        tuple: A tuple containing:\n            - potential_energy (float): The total potential energy in Hartree.\n            - forces (np.ndarray): 1D array of forces on each atom in Hartree/bohr.\n    \"\"\"\n    num_atoms = len(positions)\n    potential_energy = 0.0\n    forces = np.zeros(num_atoms, dtype=np.float64)\n\n    for i, j, k, r0 in bonds:\n        pos_i = positions[i]\n        pos_j = positions[j]\n\n        # Calculate bond vector and distance (scalar in 1D)\n        r_ij_vec = pos_j - pos_i\n        r_ij_mag = np.abs(r_ij_vec)\n\n        # Potential energy contribution\n        displacement = r_ij_mag - r0\n        potential_energy += 0.5 * k * displacement**2\n\n        # Force calculation: F = -grad(E) = -k * ( |r| - r0 ) * grad(|r|)\n        # The term grad_j(|r_j - r_i|) is sgn(r_j - r_i), which is r_ij_vec / r_ij_mag\n        if r_ij_mag > 1e-12:  # Avoid division by zero for coincident atoms\n            force_on_j = -k * displacement * (r_ij_vec / r_ij_mag)\n        else:\n            force_on_j = 0.0\n        \n        forces[j] += force_on_j\n        forces[i] -= force_on_j # Newton's third law\n\n    return potential_energy, forces\n\ndef run_timestep(masses, initial_positions, initial_velocities, bonds, dt):\n    \"\"\"\n    Performs a single time-step of Born-Oppenheimer Molecular Dynamics.\n\n    Args:\n        masses (np.ndarray): Array of atomic masses.\n        initial_positions (np.ndarray): Array of initial atomic positions.\n        initial_velocities (np.ndarray): Array of initial atomic velocities.\n        bonds (list): List of bond tuples.\n        dt (float): The time-step duration.\n\n    Returns:\n        float: The total energy (potential + kinetic) after the time-step.\n    \"\"\"\n    masses_arr = np.array(masses, dtype=np.float64)\n    R_t = np.array(initial_positions, dtype=np.float64)\n    v_t = np.array(initial_velocities, dtype=np.float64)\n\n    # Step 0: Calculate forces and accelerations at time t\n    _, F_t = compute_energy_and_forces(R_t, bonds)\n    a_t = F_t / masses_arr\n\n    # Step 1: Update positions to get R(t + dt)\n    R_t_dt = R_t + v_t * dt + 0.5 * a_t * dt**2\n\n    # Step 2: Calculate forces and accelerations at time t + dt\n    E_t_dt, F_t_dt = compute_energy_and_forces(R_t_dt, bonds)\n    a_t_dt = F_t_dt / masses_arr\n\n    # Step 3: Update velocities to get v(t + dt)\n    v_t_dt = v_t + 0.5 * (a_t + a_t_dt) * dt\n\n    # Step 4: Calculate final total energy at t + dt\n    kinetic_energy_final = 0.5 * np.sum(masses_arr * v_t_dt**2)\n    total_energy_final = E_t_dt + kinetic_energy_final\n\n    return total_energy_final\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        { # Case A\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.0],\n            \"initial_velocities\": [0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        },\n        { # Case B\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.1],\n            \"initial_velocities\": [0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        },\n        { # Case C\n            \"masses\": [1836, 3672, 1836],\n            \"initial_positions\": [0.0, 1.1, 2.2],\n            \"initial_velocities\": [0.0, 0.0, 0.0],\n            \"dt\": 0.05,\n            \"bonds\": [(0, 1, 0.7, 1.0), (1, 2, 0.7, 1.0)]\n        },\n        { # Case D\n            \"masses\": [1836, 1836],\n            \"initial_positions\": [0.0, 1.1],\n            \"initial_velocities\": [0.01, -0.02],\n            \"dt\": 0.0,\n            \"bonds\": [(0, 1, 0.5, 1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_timestep(\n            case[\"masses\"],\n            case[\"initial_positions\"],\n            case[\"initial_velocities\"],\n            case[\"bonds\"],\n            case[\"dt\"]\n        )\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451186"}, {"introduction": "在掌握了核心积分器之后，下一步是将其应用于一个完整的、尽管规模很小的化学系统中。这个练习要求您使用一个简化的、但物理上合理的势能面来模拟一个水分子的动力学。您将从头开始构建模拟：根据特定温度设定初始条件，随时间演化系统，并分析轨迹以观察诸如化学键断裂之类的具体事件。这项实践将抽象的算法与具体的化学现象联系起来，展示了 BOMD 如何成为探索分子行为的有力工具。[@problem_id:2451198]", "problem": "您需要实现一个单一水分子的最小 Born–Oppenheimer 分子动力学 (BOMD) 模拟，该模拟在一个近似的基态势能面上进行。Born–Oppenheimer 近似假设，对于每种原子核构型，电子都保持在其瞬时基态上，这产生了一个势能面，原子核在该势能面上遵循牛顿力学进行运动。您的任务是为一个柔性水分子积分其原子核运动方程，总模拟时间为 $1$ 皮秒，并为每个测试用例确定分子是否在该时间内发生解离。\n\n模型和基本原理：\n- 对每个原子核 $i$ 使用牛顿第二定律：$m_i \\,\\dfrac{d^2 \\mathbf{r}_i}{dt^2} = \\mathbf{F}_i$，其中力 $\\mathbf{F}_i = - \\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$。\n- 总势能 $U(\\mathbf{r})$ 是两个 O–H 键的 Morse 键势与一个 H–O–H 角的谐振角势之和：\n  - 对于每个长度为 $r$ 的 O–H 键，使用 $$U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2,$$ 其中 $D_e$ 是键解离能，$a$ 是范围参数，$r_0$ 是平衡键长。\n  - 对于氧原子处的弯曲角 $\\theta$，其平衡值为 $\\theta_0$，使用 $$U_{\\mathrm{bend}}(\\theta) = \\dfrac{1}{2}\\,k_\\theta\\,(\\theta - \\theta_0)^2.$$\n- 使用速度 Verlet 积分法，该方法源自位置和速度的泰勒展开，其公式如下：\n  $$\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\dfrac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2,$$\n  计算新的力 $\\mathbf{F}(t+\\Delta t)$ 和加速度 $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(t+\\Delta t)/m$，然后\n  $$\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\dfrac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t.$$\n\n物理常数和参数：\n- 玻尔兹曼常数 $k_B = 1.380\\,649\\times 10^{-23}$ 焦耳每开尔文。\n- 一电子伏特 $\\mathrm{eV} = 1.602\\,176\\,634\\times 10^{-19}$ 焦耳。\n- 一原子质量单位 $\\mathrm{amu} = 1.660\\,539\\,066\\,60\\times 10^{-27}$ 千克。\n- 质量：$m_{\\mathrm{O}} = 15.999\\,\\mathrm{amu}$，$m_{\\mathrm{H}} = 1.007\\,84\\,\\mathrm{amu}$。\n- 平衡 O–H 键长 $r_0 = 0.096$ 纳米。\n- 平衡 H–O–H 角 $\\theta_0 = 104.5$ 度 (在计算中使用弧度)。\n- Morse 参数：$D_e = 5.5$ 电子伏特，$a = 2.2$ 每埃。\n- 角力常数 $k_\\theta = 75$ 千卡每摩尔每弧度平方。使用前将 $k_\\theta$ 转换为焦耳每弧度平方每分子。\n- 每个测试的总模拟时间 $t_{\\mathrm{total}} = 1$ 皮秒。\n- 使用基于键伸长的解离判据：如果在任何时刻任一 O–H 键长超过 $r_{\\mathrm{cut}} = 2.2\\,r_0$，则宣告分子已解离。\n\n初始化：\n- 将氧原子置于原点。将一个氢原子置于 $(r_0,0,0)$，第二个氢原子置于 $(r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$，以使氧原子处的 H–O–H 角等于 $\\theta_0$。\n- 通过从均值为零、方差为 $\\sigma_i^2 = k_B T / m_i$ 的正态分布中为原子 $i$ 在温度 $T$ 下的每个笛卡尔分量抽样来初始化速度。然后，通过从所有原子的速度中减去质心速度来移除质心线动量。最后，用一个公共标量重新缩放所有速度，使得总动能等于其均分值 $K_{\\mathrm{target}} = \\dfrac{f}{2} k_B T$，其中 $f = 3N - 3$ 是在移除 $N=3$ 个原子的整体平移后剩下的二次自由度数量，因此 $f=6$。使用固定的伪随机种子以使结果具有确定性。\n- 内部计算角度使用弧度。为保证单位一致性，使用米、千克和秒。对所有参数使用给定的转换关系。\n\n力：\n- 对于从 O 到 H 的每个 O–H 键矢量 $\\mathbf{u}$，其长度为 $r=\\|\\mathbf{u}\\|$，沿键的 Morse 力大小为\n  $$\\dfrac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e\\,a\\,e^{-a(r-r_0)}\\left(1 - e^{-a(r-r_0)}\\right),$$\n  作用在氢原子上的力是 $-\\dfrac{dU_{\\mathrm{Morse}}}{dr}\\,\\dfrac{\\mathbf{u}}{r}$，而作用在氧原子上的力与之大小相等、方向相反。\n- 对于弯曲项，设有从 O 到 H 原子的矢量 $\\mathbf{u}$ 和 $\\mathbf{v}$，令 $\\hat{\\mathbf{u}}=\\mathbf{u}/\\|\\mathbf{u}\\|$，$\\hat{\\mathbf{v}}=\\mathbf{v}/\\|\\mathbf{v}\\|$，$\\cos\\theta = \\hat{\\mathbf{u}}\\cdot \\hat{\\mathbf{v}}$，$\\sin\\theta = \\sqrt{1-\\cos^2\\theta}$。$\\theta$ 的梯度为\n  $$\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} = -\\dfrac{1}{\\|\\mathbf{u}\\|}\\,\\dfrac{\\hat{\\mathbf{v}} - \\cos\\theta\\,\\hat{\\mathbf{u}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}} = -\\dfrac{1}{\\|\\mathbf{v}\\|}\\,\\dfrac{\\hat{\\mathbf{u}} - \\cos\\theta\\,\\hat{\\mathbf{v}}}{\\sin\\theta},\\quad\n    \\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_{\\mathrm{O}}} = -\\dfrac{\\partial \\theta}{\\partial \\mathbf{u}} - \\dfrac{\\partial \\theta}{\\partial \\mathbf{v}}.$$\n  角力为 $\\mathbf{F}_i^{(\\mathrm{bend})} = -k_\\theta\\,(\\theta - \\theta_0)\\,\\dfrac{\\partial \\theta}{\\partial \\mathbf{r}_i}$，其中 $i\\in\\{\\mathrm{H}_1, \\mathrm{O}, \\mathrm{H}_2\\}$。\n\n数值细节：\n- 使用速度 Verlet 算法和每个测试用例指定的恒定时间步长 $\\Delta t$（见下文）。计算步数 $n = t_{\\mathrm{total}}/\\Delta t$ 并精确积分这么多步。\n- 使用种子为 $12345$ 的确定性伪随机数生成器进行速度初始化。\n\n测试套件：\n对于下面的每个元组 $(T,\\Delta t)$，其中 $T$ 以开尔文为单位，$\\Delta t$ 以飞秒为单位，运行 $1$ 皮秒的模拟，并返回一个布尔值，指示在所述判据下轨迹中是否发生了离解：\n- 测试 1：$(T=\\;300,\\;\\Delta t=\\;0.2)$。\n- 测试 2：$(T=\\;1000,\\;\\Delta t=\\;0.1)$。\n- 测试 3：$(T=\\;8000,\\;\\Delta t=\\;0.05)$。\n- 测试 4：$(T=\\;20000,\\;\\Delta t=\\;0.05)$。\n- 测试 5：$(T=\\;100000,\\;\\Delta t=\\;0.02)$。\n\n所需输出：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如，“[True,False,False,True,False]”。结果必须与上述测试套件的顺序一致。所有内部计算必须使用国际单位制 (SI) 进行，角度单位为弧度。每个测试的最终答案是一个布尔值。每个测试的总模拟时间为 $1$ 皮秒。", "solution": "所提出的问题是计算化学中的一个标准练习：对一个单一的、柔性的水分子执行 Born-Oppenheimer 分子动力学 (BOMD) 模拟。该问题提法明确，科学上可靠，并包含了获得唯一、确定性解所需的所有信息。我们现在将系统地构建这个解法。\n\n任务的核心是在给定的势能面 (PES) $U(\\mathbf{r})$ 上对三个原子核（一个氧，两个氢）积分牛顿运动方程。原子核被视为经典粒子。对于每个质量为 $m_i$、位置矢量为 $\\mathbf{r}_i$ 的原子核 $i$，其基本方程为：\n$$ m_i \\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r}) $$\n其中 $\\mathbf{r}$ 代表所有原子核坐标的集合 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$。\n\n**1. 势能面**\n\n势能面 $U(\\mathbf{r})$ 决定了作用在原子核上的力。它被近似为内坐标势的和：两个键伸缩项和一个角弯曲项。\n$$ U(\\mathbf{r}) = U_{\\mathrm{Morse}}(r_1) + U_{\\mathrm{Morse}}(r_2) + U_{\\mathrm{bend}}(\\theta) $$\n其中 $r_1$ 和 $r_2$ 是两个 O–H 键的长度，$\\theta$ 是 H–O–H 角。\n\n每个 O–H 键的伸缩由 Morse 势描述，这是一个模拟键解离的现实模型：\n$$ U_{\\mathrm{Morse}}(r) = D_e \\left[1 - e^{-a(r - r_0)}\\right]^2 $$\n这里，$D_e$ 是键解离能，$r_0$ 是平衡键长，$a$ 控制势阱的宽度。由此势产生的、作用在构成化学键的两个原子上的力沿着键矢量方向。对于长度为 $r = \\|\\mathbf{u}\\|$ 的键矢量 $\\mathbf{u} = \\mathbf{r}_{\\mathrm{H}} - \\mathbf{r}_{\\mathrm{O}}$，作用在氢原子上的力是：\n$$ \\mathbf{F}_{\\mathrm{H, Morse}} = -\\nabla_{\\mathbf{r}_{\\mathrm{H}}} U_{\\mathrm{Morse}}(r) = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\partial r}{\\partial \\mathbf{r}_{\\mathrm{H}}} = -\\frac{dU_{\\mathrm{Morse}}}{dr} \\frac{\\mathbf{u}}{r} $$\n其中导数为 $\\frac{dU_{\\mathrm{Morse}}}{dr} = 2 D_e a \\left(1 - e^{-a(r - r_0)}\\right) e^{-a(r - r_0)}$。根据牛顿第三定律，作用在氧原子上的力大小相等，方向相反。\n\nH–O–H 角的弯曲由谐振势模拟：\n$$ U_{\\mathrm{bend}}(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2 $$\n其中 $k_\\theta$ 是角力常数，$\\theta_0$ 是平衡角。力由该势的梯度导出：$\\mathbf{F}_i^{\\mathrm{bend}} = -\\nabla_{\\mathbf{r}_i} U_{\\mathrm{bend}}(\\theta) = -k_\\theta(\\theta - \\theta_0)\\nabla_{\\mathbf{r}_i}\\theta$。问题提供了计算每个原子 $i \\in \\{\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2\\}$ 的角梯度 $\\nabla_{\\mathbf{r}_i}\\theta$ 所需的表达式。这些表达式可直接使用。一个值得注意的特点是梯度分母中的 $\\sin\\theta$ 项，它在线性构型（$\\theta=0$ 或 $\\theta=\\pi$）下会引入数值奇异性。一个稳健的实现必须处理或容忍这种情况。\n\n**2. 数值积分**\n\n为求解运动的微分方程，我们采用指定的速度 Verlet 算法。这是一种时间可逆的辛积分器，具有良好的长期能量守恒特性。给定时间 $t$ 时的位置 $\\mathbf{r}(t)$、速度 $\\mathbf{v}(t)$ 和加速度 $\\mathbf{a}(t) = \\mathbf{F}(t)/m$，时间 $t+\\Delta t$ 时的状态通过两个阶段计算得出：\n$$ \\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\,\\Delta t + \\frac{1}{2}\\,\\mathbf{a}(t)\\,\\Delta t^2 $$\n$$ \\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\,\\big(\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\big)\\,\\Delta t $$\n注意，计算新速度 $\\mathbf{v}(t+\\Delta t)$ 需要加速度 $\\mathbf{a}(t+\\Delta t)$，而这又需要在新计算出的位置 $\\mathbf{r}(t+\\Delta t)$ 处计算力 $\\mathbf{F}(t+\\Delta t)$。\n\n**3. 系统初始化**\n\n模拟从一个确定的初始状态开始。\n- **位置**：氧原子位于原点 $(\\mathbf{r}_{\\mathrm{O}} = \\mathbf{0})$。两个氢原子放置在 $xy$-平面内，以满足平衡键长 $r_0$ 和平衡角 $\\theta_0$：$\\mathbf{r}_{\\mathrm{H}_1} = (r_0, 0, 0)$ 和 $\\mathbf{r}_{\\mathrm{H}_2} = (r_0\\cos\\theta_0, r_0\\sin\\theta_0, 0)$。\n- **速度**：初始速度被设置为对应目标温度 $T$。这包括三个步骤：\n    1. 对于每个原子 $i$ 和每个笛卡尔分量，从 Maxwell-Boltzmann 分布（即均值为 0、方差为 $\\sigma_i^2 = k_B T / m_i$ 的正态分布）中随机抽取一个速度。这通过使用固定种子（$12345$）的伪随机数生成器来执行，以保证可复现性。\n    2. 通过计算质心速度 $\\mathbf{v}_{\\mathrm{CM}} = \\frac{\\sum_i m_i \\mathbf{v}_i}{\\sum_i m_i}$ 并从每个原子的速度矢量中减去它，将系统的总动量设置为零。这确保了分子整体不表现出净平移运动。\n    3. 然后将总动能 $K = \\sum_i \\frac{1}{2} m_i \\|\\mathbf{v}_i'\\|^2$ 进行缩放，以匹配一个特定的目标值 $K_{\\mathrm{target}}$。问题指定 $K_{\\mathrm{target}} = \\frac{f}{2} k_B T$，其中 $f = 3N-3=6$ 是移除平移后 $N=3$ 个原子的内自由度数。所有速度都乘以一个缩放因子 $\\lambda = \\sqrt{K_{\\mathrm{target}}/K}$。此过程是一种恒温方式，用于在所需温度下开始模拟。\n\n**4. 实现与执行**\n\n整个模拟必须在一套一致的单位制下进行。国际单位制 (SI) 是要求的标准：米 (m)、千克 (kg)、秒 (s) 和焦耳 (J)。所有提供的参数在使用前必须相应地进行转换。\n- $m_{\\mathrm{O}}, m_{\\mathrm{H}}$：从 $\\mathrm{amu}$ 转换为 $\\mathrm{kg}$。\n- $r_0$：从 $\\mathrm{nm}$ 转换为 $\\mathrm{m}$。\n- $\\theta_0$：从度转换为弧度。\n- $D_e$：从 $\\mathrm{eV}$ 转换为 $\\mathrm{J}$。\n- $a$：从 $\\mathrm{Å}^{-1}$ 转换为 $\\mathrm{m}^{-1}$。\n- $k_\\theta$：从 $\\mathrm{kcal}\\,\\mathrm{mol}^{-1}\\,\\mathrm{rad}^{-2}$ 转换为 $\\mathrm{J}\\,\\mathrm{rad}^{-2}$。\n- $t_{total}$：从 $\\mathrm{ps}$ 转换为 $\\mathrm{s}$。\n- $\\Delta t$：从 $\\mathrm{fs}$ 转换为 $\\mathrm{s}$。\n\n模拟通过迭代应用速度 Verlet 算法进行，总步数为 $n = t_{\\mathrm{total}}/\\Delta t$。每次位置更新后，检查 O–H 键长 $r_1$ 和 $r_2$ 是否满足解离判据 $r_{\\mathrm{cut}} = 2.2\\,r_0$。如果任一键长超过此截断值，则认为分子已解离，该测试用例的模拟终止，结果记录为 `True`。如果循环完成而未发生解离，结果为 `False`。此逻辑应用于问题陈述中指定的每个测试用例。最终输出是这些布尔结果的列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the BOMD problem for a water molecule.\n    \"\"\"\n    \n    # Global constants in SI units\n    KB = 1.380649e-23  # J/K\n    EV = 1.602176634e-19  # J\n    AMU = 1.66053906660e-27  # kg\n    NA = 6.02214076e23  # mol^-1\n    CAL_TO_J = 4.184\n\n    # Model Parameters in SI units\n    M_O = 15.999 * AMU\n    M_H = 1.00784 * AMU\n    MASSES = np.array([M_O, M_H, M_H])[:, np.newaxis] # Shape (3, 1) for broadcasting\n\n    R0 = 0.096e-9  # m\n    THETA0 = 104.5 * np.pi / 180.0  # rad\n\n    DE = 5.5 * EV  # J\n    A = 2.2e10  # m^-1\n\n    # k_theta conversion: 75 kcal/mol/rad^2 -> J/rad^2\n    K_THETA = 75 * 1000 * CAL_TO_J / NA  # J/rad^2\n\n    RCUT = 2.2 * R0\n\n    T_TOTAL = 1.0e-12  # s (1 picosecond)\n    \n    # Nested function to calculate forces for encapsulation\n    def calculate_forces(r):\n        \"\"\"Calculates forces on all atoms given their positions.\"\"\"\n        r_O, r_H1, r_H2 = r[0], r[1], r[2]\n        forces = np.zeros((3, 3))\n        \n        # Bond vectors\n        u1 = r_H1 - r_O\n        u2 = r_H2 - r_O\n        r1 = np.linalg.norm(u1)\n        r2 = np.linalg.norm(u2)\n        \n        # Handle case where atoms might be at the same position\n        if r1 == 0 or r2 == 0:\n            return forces\n\n        u1_hat = u1 / r1\n        u2_hat = u2 / r2\n        \n        # Morse Forces\n        exp_term1 = np.exp(-A * (r1 - R0))\n        dUm_dr1 = 2 * DE * A * exp_term1 * (1 - exp_term1)\n        \n        exp_term2 = np.exp(-A * (r2 - R0))\n        dUm_dr2 = 2 * DE * A * exp_term2 * (1 - exp_term2)\n        \n        F_H1_morse = -dUm_dr1 * u1_hat\n        F_H2_morse = -dUm_dr2 * u2_hat\n        \n        forces[1] += F_H1_morse\n        forces[2] += F_H2_morse\n        forces[0] -= (F_H1_morse + F_H2_morse)\n        \n        # Angle Bending Forces\n        cos_theta = np.dot(u1_hat, u2_hat)\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        sin_theta = np.sqrt(1 - cos_theta**2)\n        if sin_theta  1e-10:\n            return forces\n\n        dUb_dtheta = K_THETA * (theta - THETA0)\n\n        grad_theta_u1 = (-1.0 / r1) * (u2_hat - cos_theta * u1_hat) / sin_theta\n        grad_theta_u2 = (-1.0 / r2) * (u1_hat - cos_theta * u2_hat) / sin_theta\n        \n        F_H1_bend = -dUb_dtheta * grad_theta_u1\n        F_H2_bend = -dUb_dtheta * grad_theta_u2\n        F_O_bend = -(F_H1_bend + F_H2_bend)\n        \n        forces[0] += F_O_bend\n        forces[1] += F_H1_bend\n        forces[2] += F_H2_bend\n        \n        return forces\n\n    # Nested function to run one simulation\n    def run_simulation(T, dt_fs):\n        \"\"\"Runs one BOMD simulation for given T and dt.\"\"\"\n        dt = dt_fs * 1e-15  # Convert fs to s\n        num_steps = int(round(T_TOTAL / dt))\n        \n        # 1. Initialization\n        r = np.zeros((3, 3))\n        r[1] = [R0, 0, 0]\n        r[2] = [R0 * np.cos(THETA0), R0 * np.sin(THETA0), 0]\n        \n        rng = np.random.default_rng(12345)\n        std_devs = np.sqrt(KB * T / MASSES)\n        v = rng.normal(0, std_devs, size=(3, 3))\n        \n        v_cm = np.sum(v * MASSES, axis=0) / np.sum(MASSES)\n        v -= v_cm\n        \n        K_initial = 0.5 * np.sum(MASSES * v**2)\n        K_target = 0.5 * 6 * KB * T\n        if K_initial > 1e-12: # Avoid division by zero\n            scale_factor = np.sqrt(K_target / K_initial)\n            v *= scale_factor\n            \n        # 2. Dynamics\n        forces = calculate_forces(r)\n        a = forces / MASSES\n        \n        for _ in range(num_steps):\n            r += v * dt + 0.5 * a * dt**2\n            \n            r1 = np.linalg.norm(r[1] - r[0])\n            r2 = np.linalg.norm(r[2] - r[0])\n            if r1 > RCUT or r2 > RCUT:\n                return True\n                \n            forces_new = calculate_forces(r)\n            a_new = forces_new / MASSES\n            \n            v += 0.5 * (a + a_new) * dt\n            \n            a = a_new\n            \n        return False\n\n    test_cases = [\n        (300, 0.2),\n        (1000, 0.1),\n        (8000, 0.05),\n        (20000, 0.05),\n        (100000, 0.02)\n    ]\n    \n    results = []\n    for T, dt_fs in test_cases:\n        result = run_simulation(T, dt_fs)\n        results.append(str(result))\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2451198"}, {"introduction": "运行模拟只是过程的一半；真正的科学洞见来自于对原始轨迹数据的严谨分析。这项高级练习探讨了如何从微观模拟数据中提取宏观热力学性质。通过应用统计力学的基本定理，如能量均分定理、维里定理和涨落公式，您将学习如何计算温度、压力和热容等可与实验相比较的量。此外，这项实践还引入了计算科学中至关重要的一步：评估统计不确定性，这是确保计算结果可靠性和科学严谨性的关键。[@problem_id:2877597]", "problem": "对一个包含 $N$ 个原子的周期性体系进行了一次有限温度 Born-Oppenheimer 分子动力学 (BOMD) 模拟。模拟采用弱耦合的 Nosé–Hoover 温控器在正则系综（粒子数、体积和温度恒定；NVT）中进行采样，该温控器能为原子核的坐标和动量产生正则统计。电子结构已收敛，使得 Pulay 力和 Pulay 应力可以忽略不计（例如，使用具有足够高截断能的平面波基组）。原子核的质心线动量被约束为零。\n\n给定以下统计平稳的轨迹数据和系统参数：\n- 原子数：$N = 20$。\n- 无约束的二次自由度数：$f = 3N - 3$。\n- 周期性晶胞体积：$V = 4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3}$。\n- 时间步长：$\\Delta t = 0.5\\ \\mathrm{fs}$。\n- 保存的步数：$M = 200000$。\n- 原子核的时间平均动能：$\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$。\n- 时间平均维里（位形贡献），定义为 $\\Phi \\equiv \\sum_{i} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i}$，在轨迹上的平均值为：$\\langle \\Phi \\rangle = -2.239000 \\times 10^{-19}\\ \\mathrm{J}$。\n- 从轨迹计算出的总能量（原子核动能加势能）的样本方差：$s_{E}^{2} = 1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}$。\n- 各可观测量（通过分块分析获得）的积分自相关时间：$\\tau_{K} = 0.20\\ \\mathrm{ps}$，$\\tau_{\\Phi} = 0.50\\ \\mathrm{ps}$，以及 $\\tau_{E} = 0.50\\ \\mathrm{ps}$。\n\n假设原子核是经典的，并且温控器对物理的原子核自由度进行了正则分布采样。使用精确的玻尔兹曼常数 $k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n\n任务：\n1) 从经典二次自由度的能量均分定理和热力学温度的定义出发，根据时间平均的原子核动能和无约束的二次自由度数，推导一个用于从 BOMD 轨迹估算温度 $T$ 的估算量。然后计算 $T$ 的数值（单位为 K）。\n\n2) 从维里定理和分子动力学中压强的力学定义出发，根据时间平均动能、时间平均维里 $\\langle \\Phi \\rangle$ 和体积 $V$，推导一个用于估算压强 $P$ 的估算量。然后计算 $P$ 的数值（单位为 Pa）。\n\n3) 从正则系综中定容热容 $C_{V}$ 的定义出发，推导一个使用总能量涨落的估算量。然后，用样本方差 $s_{E}^{2}$ 和温度 $T$ 表示以 $k_{B}$ 为单位的单原子热容 $c_{V} \\equiv C_{V}/(N k_{B})$。计算 $c_{V}$ 的无量纲数值。\n\n4) 讨论（无需代入数值）如何通过使用积分自相关时间确定有效样本量，从而从有限的、时间相关的轨迹中估计第 (1)–(3) 部分中估算量的标准误差（统计不确定度）。写出你将用于基于均值的估算量和基于方差的估算量的标准误差公式，并解释你将如何进行不确定度传播以获得 $c_{V}$ 的不确定度。\n\n以 $k_{B}$ 为单位，给出无量纲的单原子热容 $c_{V}$ 作为最终答案，并四舍五入到四位有效数字。最终的方框答案中不要包含单位；所有中间量必须带有适当的物理单位。", "solution": "所述问题在科学上是合理的、定义清晰的，并包含了完整解答所需的所有信息。我们继续进行这四个任务的推导和计算。\n\n1) 温度 ($T$) 的推导与计算\n\n该体系由经典力学描述，并在正则系综中采样。根据能量均分定理，与每个无约束的二次自由度相关的平均能量为 $\\frac{1}{2} k_{B} T$，其中 $k_{B}$ 是玻尔兹曼常数，$T$ 是热力学温度。\n\n$N$ 个原子核的动能是动量的二次项之和：$K = \\sum_{i=1}^{N} \\frac{|\\mathbf{p}_{i}|^2}{2m_{i}}$。此类项的总数为 $3N$。问题指出质心动量被约束为零，这消除了 3 个平移自由度。因此，动能的无约束二次自由度数为 $f = 3N - 3$。\n\n时间平均的原子核动能 $\\langle K \\rangle$ 必须等于系综平均值。根据能量均分定理：\n$$\n\\langle K \\rangle = \\frac{f}{2} k_{B} T\n$$\n由此，我们推导出温度 $T$ 的估算量：\n$$\nT = \\frac{2 \\langle K \\rangle}{f k_{B}}\n$$\n给定以下数值：\n- 原子数：$N = 20$。\n- 时间平均动能：$\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$。\n- 玻尔兹曼常数：$k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n\n首先，我们计算自由度数：\n$f = 3N - 3 = 3(20) - 3 = 57$。\n\n现在，我们计算温度：\n$$\nT = \\frac{2 \\times (1.180495 \\times 10^{-19}\\ \\mathrm{J})}{57 \\times (1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1})} = \\frac{2.36099 \\times 10^{-19}\\ \\mathrm{J}}{7.8696993 \\times 10^{-22}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}} \\approx 300.011\\ \\mathrm{K}\n$$\n\n2) 压强 ($P$) 的推导与计算\n\n周期性体系中的力学压强 $P$ 由系综平均压强张量 $\\langle \\boldsymbol{\\sigma} \\rangle$ 的迹给出。瞬时压强张量定义为：\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{V} \\left( \\sum_{i=1}^{N} m_{i} \\mathbf{v}_{i} \\otimes \\mathbf{v}_{i} + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\otimes \\mathbf{F}_{i} \\right)\n$$\n其中 $V$ 是体积，$m_i$、$\\mathbf{v}_i$ 和 $\\mathbf{r}_i$ 分别是原子 $i$ 的质量、速度和位置，$\\mathbf{F}_i$ 是所有其他原子对原子 $i$ 的总作用力。符号 $\\otimes$ 表示张量积。\n\n静水压强为 $P = \\frac{1}{3} \\mathrm{Tr}(\\langle \\boldsymbol{\\sigma} \\rangle)$。取瞬时张量的迹：\n$$\n\\mathrm{Tr}(\\boldsymbol{\\sigma}) = \\frac{1}{V} \\left( \\sum_{i=1}^{N} m_{i} |\\mathbf{v}_{i}|^2 + \\sum_{i=1}^{N} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i} \\right)\n$$\n第一项是总动能的两倍，$\\sum_{i} m_{i} |\\mathbf{v}_{i}|^2 = 2K$。第二项是力的维里，即 $\\Phi = \\sum_{i} \\mathbf{r}_{i} \\cdot \\mathbf{F}_{i}$。因此，压强的估算量是此表达式的时间平均值：\n$$\nP = \\frac{1}{3V} \\langle 2K + \\Phi \\rangle = \\frac{2\\langle K \\rangle + \\langle \\Phi \\rangle}{3V}\n$$\n给定：\n- $\\langle K \\rangle = 1.180495 \\times 10^{-19}\\ \\mathrm{J}$。\n- 时间平均维里：$\\langle \\Phi \\rangle = -2.239000 \\times 10^{-19}\\ \\mathrm{J}$。\n- 体积：$V = 4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3}$。\n\n代入这些值：\n$$\nP = \\frac{2(1.180495 \\times 10^{-19}\\ \\mathrm{J}) + (-2.239000 \\times 10^{-19}\\ \\mathrm{J})}{3 \\times (4.0000 \\times 10^{-26}\\ \\mathrm{m}^{3})} = \\frac{1.2199 \\times 10^{-20}\\ \\mathrm{J}}{1.20000 \\times 10^{-25}\\ \\mathrm{m}^{3}} \\approx 1.0166 \\times 10^5\\ \\mathrm{Pa}\n$$\n\n3) 热容 ($c_{V}$) 的推导与计算\n\n定容热容 $C_{V}$ 定义为平均总能量 $\\langle E \\rangle$ 在恒定体积 $V$ 下对温度 $T$ 的偏导数：\n$$\nC_{V} = \\left( \\frac{\\partial \\langle E \\rangle}{\\partial T} \\right)_{V}\n$$\n在正则 (NVT) 系综中，这个导数可以用能量涨落来表示。使用 $\\langle E \\rangle$ 的统计力学定义和关系式 $\\beta = (k_{B}T)^{-1}$：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial T} = \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\frac{d\\beta}{dT} = \\frac{\\partial \\langle E \\rangle}{\\partial \\beta} \\left( -\\frac{1}{k_{B}T^2} \\right)\n$$\n$\\langle E \\rangle$ 对 $\\beta$ 的导数是一个标准结果：\n$$\n\\frac{\\partial \\langle E \\rangle}{\\partial \\beta} = -(\\langle E^2 \\rangle - \\langle E \\rangle^2) = -\\mathrm{Var}(E)\n$$\n结合这些，得到热容的涨落公式：\n$$\nC_{V} = \\frac{\\mathrm{Var}(E)}{k_{B} T^2}\n$$\n问题给出了总能量的样本方差 $s_{E}^{2}$，这是我们对 $\\mathrm{Var}(E)$ 的估算量。因此，$C_{V}$ 的估算量是：\n$$\nC_{V} \\approx \\frac{s_{E}^{2}}{k_{B} T^2}\n$$\n题目要求以 $k_{B}$ 为单位的单原子热容，定义为 $c_{V} \\equiv C_{V}/(N k_{B})$。代入我们对 $C_V$ 的表达式：\n$$\nc_{V} = \\frac{1}{N k_{B}} \\left( \\frac{s_{E}^{2}}{k_{B} T^2} \\right) = \\frac{s_{E}^{2}}{N k_{B}^2 T^2}\n$$\n给定：\n- 总能量的样本方差：$s_{E}^{2} = 1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}$。\n- $N = 20$，$k_{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n- 并且从第 1 部分得到，$T \\approx 300.011\\ \\mathrm{K}$。\n\n我们计算分母 $N k_{B}^2 T^2$：\n$$\nN k_{B}^2 T^2 = 20 \\times (1.380649 \\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1})^2 \\times (300.011\\ \\mathrm{K})^2 \\approx 3.43138 \\times 10^{-40}\\ \\mathrm{J}^2\n$$\n现在我们计算 $c_{V}$ 的无量纲值：\n$$\nc_{V} = \\frac{1.029000 \\times 10^{-39}\\ \\mathrm{J}^{2}}{3.43138 \\times 10^{-40}\\ \\mathrm{J}^2} \\approx 2.9986\n$$\n\n4) 统计误差估计的讨论\n\n$T$、$P$ 和 $C_V$ 的估算量是从有限的、时间相关的轨迹计算出来的。要估计这些量的标准误差 (SE)，必须考虑这种相关性。这里使用有效样本量 $N_{\\text{eff}}$ 的概念。对于一个积分自相关时间为 $\\tau_A$ 的可观测量 $A$，在总模拟时间 $T_{\\text{sim}} = M \\Delta t$ 内进行采样，其有效独立样本数为 $N_{\\text{eff}} = T_{\\text{sim}} / (2\\tau_A)$。\n\n对于基于可观测量 $A$ 的均值的估算量（例如，由 $\\langle K \\rangle$ 得到的 $T$ 和由 $\\langle 2K+\\Phi \\rangle$ 得到的 $P$），均值的标准误差为：\n$$\n\\mathrm{SE}(\\langle A \\rangle) = \\sqrt{\\frac{\\mathrm{Var}(A)}{N_{\\text{eff}}}} = \\sqrt{\\frac{2\\tau_A}{T_{\\text{sim}}}\\mathrm{Var}(A)}\n$$\n其中 $\\mathrm{Var}(A)$ 是可观测量 $A$ 在整个轨迹上的方差。\n\n- 对于温度，$T = \\frac{2\\langle K \\rangle}{f k_{B}}$，其不确定度由 $\\langle K \\rangle$ 传播而来：$\\mathrm{SE}(T) = \\frac{2}{f k_{B}} \\mathrm{SE}(\\langle K \\rangle)$，其中 $\\mathrm{SE}(\\langle K \\rangle) = \\sqrt{\\frac{2\\tau_K}{T_{\\text{sim}}}\\mathrm{Var}(K)}$。\n\n- 对于压强，$P = \\frac{\\langle 2K+\\Phi \\rangle}{3V}$，最好定义一个新的可观测量 $\\Pi = 2K+\\Phi$，并计算其自相关时间 $\\tau_{\\Pi}$ 和方差 $\\mathrm{Var}(\\Pi)$。那么不确定度为：$\\mathrm{SE}(P) = \\frac{1}{3V} \\mathrm{SE}(\\langle \\Pi \\rangle)$，其中 $\\mathrm{SE}(\\langle \\Pi \\rangle) = \\sqrt{\\frac{2\\tau_{\\Pi}}{T_{\\text{sim}}}\\mathrm{Var}(\\Pi)}$。\n\n对于基于方差的估算量（例如，由 $s_E^2$ 得到的 $C_V$），误差分析更为复杂。假设 $E$ 的分布近似为高斯分布，样本方差 $s_E^2$ 的标准误差可以近似为：\n$$\n\\mathrm{SE}(s_E^2) \\approx s_E^2 \\sqrt{\\frac{2}{N_{\\text{eff},E}-1}}\n$$\n其中 $N_{\\text{eff},E} = T_{\\text{sim}} / (2\\tau_E)$。\n\n为了求出 $c_V = \\frac{s_{E}^{2}}{N k_{B}^2 T^2}$ 的标准误差，必须传播来自 $s_E^2$ 和 $T$ 两者的不确定度：\n$$\n\\left(\\frac{\\mathrm{SE}(c_V)}{c_V}\\right)^2 = \\left(\\frac{\\mathrm{SE}(s_E^2)}{s_E^2}\\right)^2 + \\left(-2 \\frac{\\mathrm{SE}(T)}{T}\\right)^2 + 2 \\frac{(-2)}{T s_E^2} \\mathrm{Cov}(s_E^2, T)\n$$\n假设 $T$ 和 $s_E^2$ 的估算量之间的协方差可以忽略不计，相对误差简化为：\n$$\n\\frac{\\mathrm{SE}(c_V)}{c_V} \\approx \\sqrt{\\left(\\frac{\\mathrm{SE}(s_E^2)}{s_E^2}\\right)^2 + 4\\left(\\frac{\\mathrm{SE}(T)}{T}\\right)^2}\n$$\n该公式结合了能量方差和温度的相对不确定度，以估算无量纲热容的最终不确定度。", "answer": "$$\\boxed{2.999}$$", "id": "2877597"}]}