{"hands_on_practices": [{"introduction": "扩散蒙特卡洛 (DMC) 的核心是基于虚时薛定谔方程的一种巧妙的投影技术。本练习将通过一个精确可解的量子谐振子模型，将这一抽象概念具体化。您将亲手推导并数值实现虚时演化算符 $e^{-\\tau H}$ 如何像一个滤波器一样，从一个任意的初始波函数中“投影”出系统的基态，从而深入理解 DMC 方法的根本工作原理 [@problem_id:2885586]。", "problem": "要求您将作为扩散蒙特卡洛 (DMC) 核心的虚时投影原理与一个精确可解的基准模型联系起来。考虑原子单位下的一维谐振子哈密顿量，其中约化普朗克常数和电子质量均设为1。哈密顿量为 $H = -\\tfrac{1}{2}\\tfrac{d^2}{dx^2} + \\tfrac{1}{2}\\,\\omega^2 x^2$，其中频率参数 $\\omega \\gt 0$。虚时演化算符为 $e^{-\\tau H}$（虚时间 $\\tau \\ge 0$），相应的虚时传播子（欧几里得核）$K(x,x';\\tau)$ 定义为 $\\psi(x,\\tau) = \\int_{-\\infty}^{\\infty} K(x,x';\\tau)\\,\\psi(x',0)\\,dx'$。\n\n您的任务如下，请从基本定律和核心定义出发：\n\n- 从含时薛定谔方程和 $H$ 的谱分解开始。使用已知的谐振子本征函数和本征值（这些是经过充分检验的事实），将精确的虚时传播子 $K(x,x';\\tau)$ 推导为求和形式 $\\sum_{n=0}^{\\infty} \\psi_n(x)\\psi_n(x') e^{-\\tau E_n}$，然后进行求和，得到以双曲函数表示的闭合形式核。不要假定核的最终形式；需从谱表示和厄米多项式的生成函数出发进行推导。\n\n- 解释为什么对于任何不与基态正交的平方可积初始函数 $\\psi(x,0)$，当 $\\tau \\to \\infty$ 时，投影 $\\psi(x,\\tau) = \\left(e^{-\\tau H}\\psi\\right)(x)$ 会收敛到基态。将此与扩散蒙特卡洛中使用的原理联系起来。然后解释 DMC 中的固定节点约束，它是一种强制施加选定节面的边界条件。在一维谐振子中，施加一个奇宇称子空间（在 $x=0$ 处有一个节点）是用于获取第一激发态的精确固定节点约束。\n\n- 实现一个数值演示，将精确的虚时传播子应用于指定的初始函数，并测量其收敛性。在均匀网格上将空间离散化，并使用梯形法则近似积分。使用离散网格上的 $L^2$ 范数对波函数进行归一化。\n\n- 全程使用原子单位。最终数值答案无需报告物理单位。不使用角度。所有报告的数字必须四舍五入到六位小数。\n\n测试套件和要求的输出：\n\n使用以下固定的参数和定义。\n\n- 频率：$\\omega = 1$。\n\n- 空间网格：$x \\in [-L,L]$，其中 $L = \\tfrac{6}{\\sqrt{\\omega}}$。使用 $N = 1201$ 个等间距点，因此网格间距为 $\\Delta x = \\tfrac{2L}{N-1}$。\n\n- 网格上的精确参考本征函数（通过离散归一化在网格上归一化为1）：\n  - 基态：$\\psi_0(x) = \\left(\\tfrac{\\omega}{\\pi}\\right)^{1/4} e^{-\\tfrac{1}{2}\\omega x^2}$。\n  - 第一激发态：$\\psi_1(x) = \\sqrt{2\\omega}\\,x\\,\\psi_0(x)$。\n  - 精确能量：$E_0 = \\tfrac{1}{2}\\omega$ 和 $E_1 = \\tfrac{3}{2}\\omega$。\n\n- 初始函数：\n  - 通用初始函数（无固定节点）：$\\psi_{\\mathrm{g}}(x) = e^{-\\tfrac{1}{2}(x-1)^2} + 0.6\\,e^{-\\tfrac{1}{2}(x+1.5)^2}$。\n  - 节点约束的初始函数（奇宇称；第一激发态的精确固定节点）：$\\psi_{\\mathrm{n}}(x) = x\\,e^{-x^2}$。\n\n- 通过精确核 $K(x,x';\\tau)$ 进行传播以获得 $\\psi(x,\\tau) = \\int K(x,x';\\tau)\\,\\psi(x',0)\\,dx'$，并通过梯形法则离散化。传播后，将 $\\psi(x,\\tau)$ 在网格上归一化至单位 $L^2$ 范数。对于节点约束的情况，请注意，奇函数初始函数在偶核函数传播下保持奇性，从而保留了 $x=0$ 处的节点；无需额外强制执行。\n\n- 能量估计量：对于网格上的归一化实波函数 $\\psi(x)$，计算能量估计值\n  $$\n  E[\\psi] \\approx \\frac{\\int \\left[\\tfrac{1}{2} \\left(\\tfrac{d\\psi}{dx}\\right)^2 + \\tfrac{1}{2}\\omega^2 x^2 \\psi(x)^2\\right] dx}{\\int \\psi(x)^2 dx},\n  $$\n  其中导数通过中心差分近似，积分通过梯形法则近似。\n\n计算以下六个量，并按指定顺序将它们作为单个列表输出，每个条目四舍五入到六位小数：\n\n1.  $\\psi_{\\mathrm{g}}$ 在 $\\tau = 0.25$ 下投影后与基态的 $L^2$ 误差：\n   $$\n   \\left\\|\\psi(\\cdot,\\tau) - \\psi_0(\\cdot)\\right\\|_2 \\equiv \\left(\\int \\left[\\psi(x,\\tau) - \\psi_0(x)\\right]^2 dx\\right)^{1/2}。\n   $$\n\n2.  $\\psi_{\\mathrm{g}}$ 在 $\\tau = 1.0$ 下投影后与基态的 $L^2$ 误差。\n\n3.  $\\psi_{\\mathrm{g}}$ 在 $\\tau = 3.0$ 下投影后与基态的 $L^2$ 误差。\n\n4.  $\\psi_{\\mathrm{g}}$ 在 $\\tau = 3.0$ 下投影后相对于 $E_0$ 的绝对能量误差：\n   $$\n   \\left|E[\\psi(\\cdot,\\tau)] - E_0\\right|。\n   $$\n\n5.  $\\psi_{\\mathrm{n}}$ 在 $\\tau = 1.0$ 下投影后与第一激发态的 $L^2$ 误差。\n\n6.  $\\psi_{\\mathrm{n}}$ 在 $\\tau = 3.0$ 下投影后相对于 $E_1$ 的绝对能量误差。\n\n最终输出格式：\n\n您的程序应生成单行输出，包含六个结果，格式为逗号分隔并用方括号括起来的列表（例如，[$r_1,r_2,r_3,r_4,r_5,r_6$]），每个条目四舍五入到六位小数。不应打印其他任何文本。", "solution": "该问题是有效的，因为它基于量子力学原理，具有科学依据，在数学上是适定的，并且客观地陈述了所有必要的参数和定义。我们将按要求进行推导和计算。\n\n首先，我们推导一维量子谐振子的精确虚时传播子。在原子单位（$m=1$, $\\hbar=1$）下，哈密顿量由 $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$ 给出。虚时传播子，或称核 $K(x,x';\\tau)$，根据 $\\psi(x,\\tau) = \\int_{-\\infty}^{\\infty} K(x,x';\\tau)\\,\\psi(x',0)\\,dx'$ 在虚时间 $\\tau \\ge 0$ 内演化波函数 $\\psi(x,0)$。核函数可以通过对哈密顿量 $H$ 的完备本征态 $\\{\\psi_n(x)\\}$ 和本征值 $\\{E_n\\}$ 集进行谱分解来表示：\n$$\nK(x,x';\\tau) = \\langle x| e^{-\\tau H} |x' \\rangle = \\sum_{n=0}^{\\infty} \\langle x|e^{-\\tau H}|\\psi_n\\rangle\\langle\\psi_n|x'\\rangle = \\sum_{n=0}^{\\infty} \\psi_n(x)\\psi_n^*(x') e^{-\\tau E_n}\n$$\n对于谐振子，本征函数是实数，因此 $\\psi_n^*(x') = \\psi_n(x')$。本征值为 $E_n = \\omega(n + \\frac{1}{2})$，归一化的本征函数为 $\\psi_n(x) = \\left(\\frac{\\sqrt{\\omega/\\pi}}{2^n n!}\\right)^{1/2} H_n(\\sqrt{\\omega}x) e^{-\\frac{1}{2}\\omega x^2}$，其中 $H_n(y)$ 是物理学家的厄米多项式。将这些代入求和式中可得：\n$$\nK(x,x';\\tau) = \\sum_{n=0}^{\\infty} \\left[\\left(\\frac{\\sqrt{\\omega/\\pi}}{2^n n!}\\right)^{1/2} H_n(\\sqrt{\\omega}x) e^{-\\frac{1}{2}\\omega x^2}\\right] \\left[\\left(\\frac{\\sqrt{\\omega/\\pi}}{2^n n!}\\right)^{1/2} H_n(\\sqrt{\\omega}x') e^{-\\frac{1}{2}\\omega x'^2}\\right] e^{-\\omega(n+1/2)\\tau}\n$$\n让我们定义无量纲坐标 $y = \\sqrt{\\omega}x$ 和 $y' = \\sqrt{\\omega}x'$，并令 $z = e^{-\\omega\\tau}$。表达式简化为：\n$$\nK(x,x';\\tau) = \\sqrt{\\frac{\\omega}{\\pi}} e^{-\\frac{\\omega\\tau}{2}} e^{-\\frac{1}{2}(y^2+y'^2)} \\sum_{n=0}^{\\infty} \\frac{H_n(y) H_n(y')}{2^n n!} z^n\n$$\n这个求和是一个已知的恒等式，称为厄米多项式的 Mehler 公式：\n$$\n\\sum_{n=0}^{\\infty} \\frac{H_n(y) H_n(y')}{2^n n!} z^n = (1-z^2)^{-1/2} \\exp\\left[\\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right]\n$$\n将此代回核的表达式中：\n$$\nK(x,x';\\tau) = \\sqrt{\\frac{\\omega}{\\pi}} e^{-\\frac{\\omega\\tau}{2}} e^{-\\frac{1}{2}(y^2+y'^2)} (1-z^2)^{-1/2} \\exp\\left[\\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right]\n$$\n我们合并指数项。总指数的宗量变为：\n$$\n-\\frac{\\omega\\tau}{2} - \\frac{1}{2}(y^2+y'^2) + \\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2} = -\\frac{\\omega\\tau}{2} + \\frac{-\\frac{1}{2}(y^2+y'^2)(1-z^2) + 2yy'z - (y^2+y'^2)z^2}{1-z^2}\n$$\n$$\n= -\\frac{\\omega\\tau}{2} + \\frac{-\\frac{1}{2}(y^2+y'^2)(1+z^2) + 2yy'z}{1-z^2}\n$$\n现在，我们用双曲函数表示 $z=e^{-\\omega\\tau}$：$1-z^2 = 1 - e^{-2\\omega\\tau} = 2e^{-\\omega\\tau}\\sinh(\\omega\\tau)$，以及 $1+z^2 = 1 + e^{-2\\omega\\tau} = 2e^{-\\omega\\tau}\\cosh(\\omega\\tau)$。前置因子变为 $\\sqrt{\\frac{\\omega}{\\pi(1-z^2)}} e^{-\\omega\\tau/2} = \\sqrt{\\frac{\\omega}{2\\pi \\sinh(\\omega\\tau)}}$。指数项变为：\n$$\n-\\frac{\\omega\\tau}{2} + \\frac{-\\frac{1}{2}(y^2+y'^2) 2e^{-\\omega\\tau}\\cosh(\\omega\\tau) + 2yy'e^{-\\omega\\tau}}{2e^{-\\omega\\tau}\\sinh(\\omega\\tau)} = -\\frac{\\omega\\tau}{2} - \\frac{(y^2+y'^2)\\cosh(\\omega\\tau) - 2yy'}{2\\sinh(\\omega\\tau)}\n$$\n这似乎过于复杂了。让我们对指数部分采用另一种简化途径，这样可以更直接地得到最终形式。让我们将 Mehler 公式的指数宗量与 $e^{-\\frac{1}{2}(y^2+y'^2)}$ 项结合起来：\n$$\n\\exp\\left(-\\frac{1}{2}(y^2+y'^2)\\right) \\exp\\left(\\frac{2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right) = \\exp\\left(\\frac{-\\frac{1}{2}(y^2+y'^2)(1-z^2) + 2yy'z - (y^2+y'^2)z^2}{1-z^2}\\right)\n$$\n$$\n= \\exp\\left(\\frac{-\\frac{1}{2}(y^2+y'^2) - \\frac{1}{2}(y^2+y'^2)z^2 + 2yy'z}{1-z^2}\\right) = \\exp\\left(\\frac{-\\frac{1}{2}(y^2+y'^2)(1+z^2)+2yy'z}{1-z^2}\\right)\n$$\n代入 $y=\\sqrt{\\omega}x$, $y'=\\sqrt{\\omega}x'$, $z=e^{-\\omega\\tau}$, $1-z^2=e^{-\\omega\\tau}(e^{\\omega\\tau}-e^{-\\omega\\tau})=2e^{-\\omega\\tau}\\sinh(\\omega\\tau)$，以及 $1+z^2=2e^{-\\omega\\tau}\\cosh(\\omega\\tau)$，指数项变为：\n$$\n\\frac{-\\frac{1}{2}\\omega(x^2+x'^2)(2e^{-\\omega\\tau}\\cosh(\\omega\\tau))+2\\omega xx'e^{-\\omega\\tau}}{2e^{-\\omega\\tau}\\sinh(\\omega\\tau)} = -\\frac{\\omega}{2\\sinh(\\omega\\tau)}\\left[(x^2+x'^2)\\cosh(\\omega\\tau) - 2xx'\\right]\n$$\n与前置因子 $\\sqrt{\\frac{\\omega}{2\\pi \\sinh(\\omega\\tau)}}$ 结合，我们得到了闭合形式的传播子：\n$$\nK(x,x';\\tau) = \\left[\\frac{\\omega}{2\\pi \\sinh(\\omega\\tau)}\\right]^{1/2} \\exp\\left\\{ -\\frac{\\omega}{2 \\sinh(\\omega\\tau)} \\left[ (x^2+x'^2)\\cosh(\\omega\\tau) - 2xx' \\right] \\right\\}\n$$\n推导至此完成。\n\n接下来，我们来讨论基态投影原理。任何平方可积的初始态 $\\psi(x,0)$ 均可在 $H$ 的本征基中展开：$\\psi(x,0) = \\sum_{n=0}^{\\infty} c_n \\psi_n(x)$，其中 $c_n = \\int \\psi_n(x)\\psi(x,0)dx$。应用虚时演化算符可得：\n$$\n\\psi(x,\\tau) = e^{-\\tau H} \\psi(x,0) = \\sum_{n=0}^{\\infty} c_n e^{-\\tau E_n} \\psi_n(x) = e^{-\\tau E_0}\\left[c_0\\psi_0(x) + c_1 e^{-\\tau(E_1-E_0)}\\psi_1(x) + \\dots\\right]\n$$\n由于能量本征值是排序的 $E_0  E_1  E_2  \\dots$，对于 $n>0$ 的指数项 $(E_n - E_0)$ 严格为正。当 $\\tau \\to \\infty$ 时，所有 $e^{-\\tau(E_n-E_0)}$ 项都衰减到零，只剩下 $n=0$ 的项。因此，对于任何不与基态正交的初始态（即 $c_0 \\neq 0$），传播后的波函数收敛到基态：$\\lim_{\\tau\\to\\infty} \\psi(x,\\tau) \\propto \\psi_0(x)$。扩散蒙特卡洛 (DMC) 是一种模拟此过程的随机方法。虚时间下的薛定谔方程类似于一个扩散-反应方程，其中波函数由一群“行走粒子”表示。这些行走粒子扩散（由于动能项）并被产生或湮灭（由于势能项）。经过长虚时间后，行走粒子的分布收敛到基态波函数的抽样。对于费米子系统，波函数必须是反对称的，这意味着它必须有节面（$\\psi=0$ 的曲面）。标准的 DMC 无法正确处理这些节面，这导致了“费米子符号问题”。固定节点近似通过将引导试探波函数的节点施加为无限高的势垒来解决这个问题。任何试图穿过节点的行走粒子都将被移除。这个过程会找到与所施加的节面结构相容的最低能量状态。对于一维谐振子，真实基态 $\\psi_0$ 是无节点的。第一激发态 $\\psi_1$ 在 $x=0$ 处有一个节点。通过将系统约束在奇宇称函数上（所有这些函数都在 $x=0$ 处有节点），虚时投影将收敛到能量最低的奇宇称态，即 $\\psi_1$。这是一个精确固定节点计算的实例。\n\n最后，数值实现将问题离散化。空间由在区间 $x \\in [-L, L]$ 内的 $N=1201$ 个点的均匀网格表示，其中 $L=6.0$。传播积分 $\\psi(x_i, \\tau) = \\int K(x_i,x';\\tau)\\psi(x',0)dx'$ 使用梯形法则进行数值计算，这可以表示为对离散化的波函数和核矩阵 $K_{ij}=K(x_i,x_j;\\tau)$ 的矩阵-向量运算。在每个传播步骤之后，得到的波函数在网格上归一化，使得 $\\int |\\psi(x,\\tau)|^2 dx \\approx \\sum_i |\\psi(x_i,\\tau)|^2 \\Delta x = 1.0$。能量通过哈密顿量的期望值来估计，其中动能项 $\\int \\psi (-\\frac{1}{2}\\nabla^2) \\psi dx = \\frac{1}{2}\\int (\\nabla \\psi)^2 dx$ 的导数 $\\nabla\\psi$ 使用中心差分计算，积分使用梯形法则计算。这种设置允许对理论原理进行直接的数值检验。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum harmonic oscillator problem using the exact imaginary-time propagator.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    omega = 1.0\n    L = 6.0 / np.sqrt(omega)\n    N = 1201\n    \n    # Exact energies for reference\n    E0_exact = 0.5 * omega\n    E1_exact = 1.5 * omega\n\n    # Discretize the spatial domain\n    x_grid = np.linspace(-L, L, N)\n    dx = (2 * L) / (N - 1)\n\n    # --- Helper functions ---\n    \n    def normalize(psi, dx_val):\n        \"\"\"Normalizes a wavefunction on the grid using the trapezoidal rule for the L2 norm.\"\"\"\n        norm_sq = np.trapz(psi**2, dx=dx_val)\n        return psi / np.sqrt(norm_sq)\n\n    def l2_error(psi_a, psi_b, dx_val):\n        \"\"\"Calculates the L2 error between two wavefunctions on the grid.\"\"\"\n        return np.sqrt(np.trapz((psi_a - psi_b)**2, dx=dx_val))\n\n    def calculate_energy(psi, x_vals, dx_val, omega_val):\n        \"\"\"Calculates the energy expectation value for a normalized wavefunction.\"\"\"\n        # Use central differences for the derivative\n        dpsi_dx = np.gradient(psi, dx_val)\n        \n        # Kinetic and potential energy integrands\n        kinetic_integrand = 0.5 * dpsi_dx**2\n        potential_integrand = 0.5 * (omega_val**2) * (x_vals**2) * (psi**2)\n        \n        # Calculate total energy using trapezoidal rule\n        energy = np.trapz(kinetic_integrand + potential_integrand, dx=dx_val)\n        return energy\n        \n    def get_propagator_matrix(tau, x_vals, omega_val):\n        \"\"\"Computes the exact propagator matrix K(x_i, x_j; tau).\"\"\"\n        if tau == 0:\n            # Propagator is a Dirac delta, discretized form is 1/dx at i=j\n            return np.identity(len(x_vals)) / dx\n            \n        arg_sinh = omega_val * tau\n        prefactor = np.sqrt(omega_val / (2 * np.pi * np.sinh(arg_sinh)))\n        \n        # Create meshgrid for vectorized calculation\n        # xp_mesh for output coordinate x_i, x_mesh for input coordinate x_j\n        xp_mesh, x_mesh = np.meshgrid(x_vals, x_vals, indexing='ij')\n\n        cosh_term = np.cosh(arg_sinh)\n        \n        exponent = -omega_val / (2 * np.sinh(arg_sinh)) * \\\n                   ((xp_mesh**2 + x_mesh**2) * cosh_term - 2 * xp_mesh * x_mesh)\n        \n        K = prefactor * np.exp(exponent)\n        return K\n\n    def propagate(psi_initial, K_matrix, x_vals):\n        \"\"\"Propagates a wavefunction using the kernel matrix and trapezoidal rule.\"\"\"\n        # Integrand for each output point x_i is K(x_i, x_j)*psi(x_j)\n        integrand = K_matrix * psi_initial[None, :]\n        psi_final = np.trapz(integrand, x=x_vals, axis=1)\n        return psi_final\n\n    # --- Setup of reference and initial states ---\n\n    # Reference eigenfunctions (normalized on the grid)\n    psi0_unnorm = (omega / np.pi)**0.25 * np.exp(-0.5 * omega * x_grid**2)\n    psi0_ref = normalize(psi0_unnorm, dx)\n\n    psi1_unnorm = np.sqrt(2 * omega) * x_grid * psi0_unnorm\n    psi1_ref = normalize(psi1_unnorm, dx)\n\n    # Initial functions\n    psi_g_initial = np.exp(-0.5 * (x_grid - 1.0)**2) + 0.6 * np.exp(-0.5 * (x_grid + 1.5)**2)\n    psi_n_initial = x_grid * np.exp(-x_grid**2)\n\n    results = []\n    \n    # --- Perform calculations for the generic initial function psi_g ---\n    \n    # Task 1: L2 error for psi_g with tau = 0.25\n    tau_g1 = 0.25\n    K_g1 = get_propagator_matrix(tau_g1, x_grid, omega)\n    psi_g_tau1 = propagate(psi_g_initial, K_g1, x_grid)\n    psi_g_tau1_norm = normalize(psi_g_tau1, dx)\n    results.append(l2_error(psi_g_tau1_norm, psi0_ref, dx))\n\n    # Task 2: L2 error for psi_g with tau = 1.0\n    tau_g2 = 1.0\n    K_g2 = get_propagator_matrix(tau_g2, x_grid, omega)\n    psi_g_tau2 = propagate(psi_g_initial, K_g2, x_grid)\n    psi_g_tau2_norm = normalize(psi_g_tau2, dx)\n    results.append(l2_error(psi_g_tau2_norm, psi0_ref, dx))\n\n    # Task 3: L2 error for psi_g with tau = 3.0\n    tau_g3 = 3.0\n    K_g3 = get_propagator_matrix(tau_g3, x_grid, omega)\n    psi_g_tau3 = propagate(psi_g_initial, K_g3, x_grid)\n    psi_g_tau3_norm = normalize(psi_g_tau3, dx)\n    results.append(l2_error(psi_g_tau3_norm, psi0_ref, dx))\n\n    # Task 4: Absolute energy error for psi_g with tau = 3.0\n    energy_g3 = calculate_energy(psi_g_tau3_norm, x_grid, dx, omega)\n    results.append(abs(energy_g3 - E0_exact))\n\n    # --- Perform calculations for the nodal-constrained function psi_n ---\n    \n    # Task 5: L2 error for psi_n with tau = 1.0\n    tau_n1 = 1.0\n    K_n1 = get_propagator_matrix(tau_n1, x_grid, omega)\n    psi_n_tau1 = propagate(psi_n_initial, K_n1, x_grid)\n    psi_n_tau1_norm = normalize(psi_n_tau1, dx)\n    results.append(l2_error(psi_n_tau1_norm, psi1_ref, dx))\n    \n    # Task 6: Absolute energy error for psi_n with tau = 3.0\n    tau_n2 = 3.0\n    K_n2 = get_propagator_matrix(tau_n2, x_grid, omega)\n    psi_n_tau2 = propagate(psi_n_initial, K_n2, x_grid)\n    psi_n_tau2_norm = normalize(psi_n_tau2, dx)\n    energy_n2 = calculate_energy(psi_n_tau2_norm, x_grid, dx, omega)\n    results.append(abs(energy_n2 - E1_exact))\n\n    # Print results in the required format\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2885586"}, {"introduction": "理解了基态投影后，下一个挑战是如何处理费米子体系，这引出了关键的“节固定近似”(fixed-node approximation)。本练习将通过一个简化的二维自由粒子模型，让您直观地模拟该近似在实践中的核心算法。通过追踪单个“行走者”(walker) 的扩散过程，并实现一个“吸收性”的节面边界，您将能够清晰地看到并验证 DMC 算法中防止行走者穿越节点的关键规则 [@problem_id:2885522]。", "problem": "要求您在一个具有平面节点的简单二维情况下，演示扩散蒙特卡洛（DMC）中的固定节点边界条件。在原子单位下进行计算，因此扩散常数为 $D = 1/2$。考虑一个在二维空间中无外势的自由粒子，其在虚时间中的行为由扩散方程描述，该方程源于分布 $f(\\mathbf{R},\\tau)$ 的虚时间 Schrödinger 方程，其中 $\\mathbf{R} = (x,y)$ 且 $\\tau$ 为虚时间。固定节点近似在一个节点流形上施加了一个 Dirichlet 边界条件，此处该流形取为与试探函数 $\\psi_{\\mathrm{T}}(x,y) = x$ 对应的平面 $x=0$。在此设置中，固定节点边界被实现为一个吸收边界：任何试图从 $x0$ 跨越到 $x\\le 0$ 的扩散轨迹都将被移除。\n\n您的任务是：\n- 从虚时间 Schrödinger 方程与扩散之间的基本映射出发，证明独立的行走者在每个时间步长中经历高斯位移。\n- 特化到 $D=1/2$、无漂移、无分支的自由粒子情况，并证明使用时间步长 $\\Delta \\tau$ 进行离散化后，位置按以下公式更新：\n$$\n\\mathbf{R}_{t+1} = \\mathbf{R}_t + \\sqrt{2D\\,\\Delta \\tau}\\,\\boldsymbol{\\xi}_t,\n$$\n其中 $\\boldsymbol{\\xi}_t$ 具有独立的标准正态分量。\n- 解释位于 $x=0$ 的固定节点吸收边界如何映射为以下规则：如果一个当前位于 $x_t0$ 的行走者，其提议的移动导致 $x_{t+1}\\le 0$，则该行走者将从模拟中被移除，并且不再随时间演化。\n- 对于多种时间步长，数值验证当施加吸收边界时，没有任何存活的行走者会停留在禁止区域 $x\\le 0$。同时验证，在没有吸收的情况下，一些行走者确实会最终进入禁止区域。\n\n数学和算法规范：\n- 使用自由粒子的虚时间演化，在原子单位下其简化为 $D=1/2$ 的扩散，并忽略漂移和分支。所有行走者独立移动。\n- 将所有行走者初始化在 $\\mathbf{R}_0 = (x_0,y_0)$，其中 $x_0=1$ 和 $y_0=0$，以使所有行走者都从允许的半平面 $x0$ 开始。\n- 对于位于 $x=0$ 的吸收节点：如果在单个步骤内，一个提议的移动从 $x0$ 跨入 $x\\le 0$，则立即移除该行走者，并将其从后续步骤中排除。\n- 对于非吸收的对照运行：允许相同的移动提议，但从不移除行走者。\n\n每个测试用例需要计算的量：\n- 演化结束时存活的行走者数量 $N_{\\mathrm{surv}}$。\n- 位于禁止区域的存活者数量，$N_{\\mathrm{forb}} = \\#\\{ \\text{存活者 } i : x_i \\le 0\\}$。\n- 在吸收动力学下被移除的行走者数量 $N_{\\mathrm{kill}}$。\n- 尝试跨越的次数 $N_{\\mathrm{cross}}$，定义为提议的步骤中 $x_t0$ 且 $x_{t+1}\\le 0$ 的计数。对于非吸收的对照组，您仍然要检测 $N_{\\mathrm{cross}}$，但不移除行走者。\n\n每个测试用例要输出的验证条件：\n- 具有适中时间步长的吸收边界：验证 $N_{\\mathrm{forb}}=0$。\n- 具有相同参数的非吸收对照组：验证 $N_{\\mathrm{forb}}0$。\n- 具有大时间步长的吸收边界：验证 $N_{\\mathrm{forb}}=0$ 和 $N_{\\mathrm{surv}}  N_{\\mathrm{w}}$。\n- 具有零时间步长的吸收边界：验证 $N_{\\mathrm{forb}}=0$ 和 $N_{\\mathrm{surv}} = N_{\\mathrm{w}}$。", "solution": "问题陈述已经过分析，并被确定为有效。它具有科学依据、是适定的、客观的，并包含构建唯一、可验证解所需的所有必要信息。该问题通过一个典型例子，正确地阐述了固定节点扩散蒙特卡洛方法的一个基本演示。我们现在将继续进行正式的解法。\n\n该问题要求对自由粒子的扩散蒙特卡洛算法进行合理性证明，并对固定节点边界条件进行数值演示。陈述组织如下：首先，建立从虚时间 Schrödinger 方程到扩散方程的映射。其次，推导出行走者位置的离散时间更新规则。第三，解释将固定节点边界条件实现为吸收壁垒的方法。最后，详细说明数值验证的逻辑。\n\n波函数 $\\Psi(\\mathbf{R}, \\tau)$ 的虚时间 Schrödinger 方程（ITSE）为\n$$\n-\\frac{\\partial \\Psi(\\mathbf{R}, \\tau)}{\\partial \\tau} = \\hat{H} \\Psi(\\mathbf{R}, \\tau)\n$$\n其中 $\\mathbf{R}$ 代表所有粒子的坐标，$\\tau$ 是虚时间，$\\hat{H}$ 是哈密顿算符。对于二维空间中质量为 $m$ 的单个自由粒子，$\\mathbf{R}=(x,y)$，在没有势能的情况下，哈密顿量是纯动能的：$\\hat{H} = -\\frac{\\hbar^2}{2m}\\nabla^2$。在原子单位中，$\\hbar=1$ 且电子质量 $m_e=1$。问题指定了一个类似于电子的系统，因此我们设 $m=1$。ITSE 因此变为：\n$$\n\\frac{\\partial \\Psi}{\\partial \\tau} = \\frac{1}{2}\\nabla^2\\Psi\n$$\n该方程在数学上与经典扩散方程是等同的：\n$$\n\\frac{\\partial \\phi}{\\partial t} = D \\nabla^2\\phi\n$$\n通过直接比较，波函数 $\\Psi$ 可以被解释为浓度或概率密度 $\\phi$，虚时间 $\\tau$ 解释为实时间 $t$，扩散常数 $D$ 被确定为 $D = 1/2$。问题指出我们应该忽略漂移项和分支项，这些项会因非恒定势或使用重要性采样试探函数而产生。在这里，我们模拟的是与自由粒子 ITSE 对应的原始扩散过程，其中行走者的分布 $f(\\mathbf{R}, \\tau)$ 直接代表波函数 $\\Psi(\\mathbf{R}, \\tau)$。\n\n对于一个初始位置在 $\\mathbf{R}_t$ 的粒子，在小时间步长 $\\Delta \\tau$ 内的扩散方程的解可以使用其格林函数找到。在时间 $\\tau + \\Delta \\tau$ 时，在位置 $\\mathbf{R}_{t+1}$ 找到该粒子的概率由一个高斯分布给出：\n$$\nP(\\mathbf{R}_{t+1} | \\mathbf{R}_t) = \\frac{1}{4\\pi D \\Delta \\tau} \\exp\\left(-\\frac{|\\mathbf{R}_{t+1} - \\mathbf{R}_t|^2}{4D\\Delta\\tau}\\right)\n$$\n这意味着位移矢量 $\\mathbf{R}_{t+1} - \\mathbf{R}_t$ 是一个二维高斯随机变量。位移的每个分量 $\\Delta x$ 和 $\\Delta y$ 都是从均值为 $0$、方差为 $\\sigma^2 = 2D\\Delta\\tau$ 的正态分布中独立抽取的。可以从这样的分布中生成一个随机变量，方法是取一个标准正态变量 $\\xi$（均值为 $0$，方差为 $1$），然后用标准差 $\\sigma = \\sqrt{2D\\Delta\\tau}$ 对其进行缩放。\n因此，位置矢量 $\\mathbf{R}_t$ 在一个时间步长 $\\Delta \\tau$ 内的更新规则是：\n$$\n\\mathbf{R}_{t+1} = \\mathbf{R}_t + \\sqrt{2D\\Delta\\tau} \\, \\boldsymbol{\\xi}_t\n$$\n其中 $\\boldsymbol{\\xi}_t = (\\xi_x, \\xi_y)$ 是从标准正态分布中抽取的两个独立随机数组成的矢量。这证实了问题陈述中提供的随机更新方程。\n\n固定节点近似是解决量子蒙特卡洛中费米子符号问题的一种方法。它约束模拟的波函数 $\\Psi$ 的节面，使其与所选试探波函数 $\\psi_{\\mathrm{T}}$ 的节面相匹配。节面是波函数为零的点集。对于给定的试探函数 $\\psi_{\\mathrm{T}}(x,y) = x$，节面是平面 $x=0$。然后，模拟被限制在 $\\psi_{\\mathrm{T}}$ 符号恒定的区域内，例如区域 $x0$。在节点上施加的边界条件是，对于所有时间 $\\tau$，都有 $\\Psi(x=0, y, \\tau) = 0$。在扩散过程的背景下，这样的 Dirichlet 边界条件对应于一个完美吸收边界。任何试图跨越此边界的行走者（我们系综中代表分布的一个点）都必须从模拟中移除。\n在离散时间模拟中，当一个位于位置 $\\mathbf{R}_t$（其中 $x_t  0$）的行走者提议移动到 $\\mathbf{R}_{t+1}$（使得 $x_{t+1} \\le 0$）时，就发生了一次跨越事件。算法规则是检测到此类事件并立即移除该行走者。该行走者在任何后续时间步中都不会对总体数量做出贡献。此过程确保存活的行走者群体 $N_{\\mathrm{surv}}$ 始终停留在允许的区域 $x0$ 内。因此，根据构造，禁止区域中的存活行走者数量 $N_{\\mathrm{forb}}$ 必须为零，即 $N_{\\mathrm{forb}} = \\#\\{ \\text{存活者 } i : x_i \\le 0\\} = 0$。\n\n数值测试旨在验证这些性质：\n- 测试 1：在 $x=0$ 处有吸收边界且时间步长适中（$\\Delta \\tau = 0.05$）的情况下，行走者会发生扩散。一些行走者会试图跨越 $x=0$ 并被移除。吸收边界的核心原则决定了没有存活的行走者会最终进入 $x \\le 0$ 区域。因此，我们必须验证 $N_{\\mathrm{forb}} = 0$。\n- 测试 2：这是一个对照实验。参数与测试 1 相同，但吸收功能被关闭。行走者可以自由地跨越 $x=0$ 线扩散。由于初始位置是 $(x_0, y_0)=(1,0)$ 且扩散是无偏的，从统计上看，预计在 $N_{\\mathrm{steps}}=200$ 步之后，一部分行走者会扩散到 $x \\le 0$ 区域。因此，我们必须验证 $N_{\\mathrm{forb}}  0$。\n- 测试 3：此测试使用一个大的时间步长 $\\Delta \\tau = 0.5$。在 $x$ 方向上单步的标准差为 $\\sigma_x = \\sqrt{2D\\Delta\\tau} = \\sqrt{2(1/2)(0.5)} = \\sqrt{0.5} \\approx 0.707$。由于行走者从 $x_0=1$ 开始，单步移动极有可能导致跨越。这将导致大量的行走者被移除。我们必须验证两个条件：吸收边界仍然正常工作（$N_{\\mathrm{forb}}=0$），并且存活者的数量小于初始行走者的数量（$N_{\\mathrm{surv}}  N_{\\mathrm{w}}$）。\n- 测试 4：这是一个时间步长为 $\\Delta \\tau = 0$ 的合理性检查。每一步的位移为 $\\sqrt{2D\\Delta\\tau}\\,\\boldsymbol{\\xi}_t = 0$。所有行走者在全部 $100$ 步中都停留在其初始位置 $(1,0)$。没有行走者移动，因此没有行走者能跨越边界。因此，没有行走者被移除，所有行走者都停留在 $x=1$。我们必须验证 $N_{\\mathrm{forb}}=0$ 和 $N_{\\mathrm{surv}} = N_{\\mathrm{w}}$。\n\n所提供的参数和验证条件是合乎逻辑的，并可作为对所实现的固定节点扩散算法的鲁棒测试。实现将直接遵循这些原则。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(n_w, n_steps, dt, D, absorbing, seed):\n    \"\"\"\n    Runs a 2D diffusion simulation with an optional absorbing boundary at x=0.\n    \"\"\"\n    np.random.seed(seed)\n\n    # All walkers start at (1.0, 0.0)\n    walkers = np.full((n_w, 2), [1.0, 0.0], dtype=np.float64)\n    is_alive = np.ones(n_w, dtype=bool)\n\n    n_kill = 0\n    n_cross = 0\n    \n    # Check for trivial case dt=0 to avoid unnecessary computation\n    if dt == 0:\n        n_surv = n_w\n        # No walkers moved, all are at x=1, so none are in the forbidden region\n        n_forb = 0\n        return n_surv, n_forb, n_kill, n_cross\n\n    step_std_dev = np.sqrt(2 * D * dt)\n\n    for _ in range(n_steps):\n        alive_indices = np.where(is_alive)[0]\n        n_alive_now = len(alive_indices)\n\n        if n_alive_now == 0:\n            break\n\n        # Generate displacements only for living walkers\n        displacements = np.random.standard_normal(size=(n_alive_now, 2)) * step_std_dev\n        \n        # Get old and new positions for currently alive walkers\n        old_positions = walkers[alive_indices]\n        new_positions = old_positions + displacements\n\n        # Detect any attempted crossings from the allowed region (x>0)\n        # to the forbidden region (x=0).\n        # This check is performed for both absorbing and non-absorbing simulations\n        # to consistently count n_cross.\n        crossing_mask = (old_positions[:, 0] > 0)  (new_positions[:, 0] = 0)\n        n_cross += np.sum(crossing_mask)\n\n        if absorbing:\n            # Identify which of the currently alive walkers crossed the boundary\n            walkers_to_kill_indices = alive_indices[crossing_mask]\n            if walkers_to_kill_indices.size > 0:\n                is_alive[walkers_to_kill_indices] = False\n                n_kill += len(walkers_to_kill_indices)\n        \n        # Update positions of all walkers that were alive at the start of the step.\n        # For killed walkers, their positions are updated but they will be\n        # ignored in subsequent steps because is_alive is now False.\n        walkers[alive_indices] = new_positions\n\n    n_surv = np.sum(is_alive)\n    \n    if n_surv > 0:\n        final_survivors_positions = walkers[is_alive]\n        # Count survivors in the forbidden zone x = 0\n        n_forb = np.sum(final_survivors_positions[:, 0] = 0)\n    else:\n        n_forb = 0\n\n    return n_surv, n_forb, n_kill, n_cross\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs simulations, and prints verification results.\n    \"\"\"\n    test_cases = [\n        # (N_w, N_steps, dt, D, absorbing, seed)\n        (5000, 200, 0.05, 0.5, True, 2024),\n        (5000, 200, 0.05, 0.5, False, 2024),\n        (5000, 60, 0.5, 0.5, True, 2025),\n        (5000, 100, 0.0, 0.5, True, 2026),\n    ]\n\n    results = []\n\n    # Test 1: Absorbing boundary, moderate time step\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[0]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb == 0)\n\n    # Test 2: Non-absorbing control\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[1]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb > 0)\n\n    # Test 3: Absorbing boundary, large time step\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[2]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb == 0 and n_surv  n_w)\n\n    # Test 4: Absorbing boundary, zero time step\n    n_w, n_steps, dt, D, absorbing, seed = test_cases[3]\n    n_surv, n_forb, _, _ = run_simulation(n_w, n_steps, dt, D, absorbing, seed)\n    results.append(n_forb == 0 and n_surv == n_w)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2885522"}, {"introduction": "一次成功的 DMC 模拟会产生一系列能量值的时间序列，但这些数据点之间存在着时间上的关联性，并非相互独立。本练习聚焦于从模拟数据中获得可靠结果的关键最后一步：处理序列相关性。您将使用一个真实反映模拟数据的自回归模型，亲手实现“分块方法”(blocking method) 来计算无偏的统计误差。这是任何蒙特卡洛方法实践者都必须掌握的核心技能 [@problem_id:2885597]。", "problem": "考虑量子化学中固定节点基态能量的扩散蒙特卡罗 (DMC) 估计，其中测得的局域能量构成一个相关时间序列。固定节点近似约束了节面，并通过一个恒定偏差来移动渐近平均能量，但不会改变该均值周围涨落的平稳性或自相关结构。因此，核心的统计任务是从相关观测值中估计样本均值的无偏标准误差。\n\n从以下基础出发：\n- 具有有限积分自相关时间的平稳时间序列的样本均值遵循马尔可夫链的中心极限定理：随着样本数量的增加，样本均值的标度化偏差趋向于正态分布，并且样本均值的方差取决于自相关函数。\n- 具有平稳均值和方差的一阶自回归 (AR(1)) 过程是模拟指数衰减时间相关性的一个经过充分检验的模型。\n\n您的程序必须：\n- 使用具有指定参数的 AR(1) 高斯过程生成合成的类 DMC 局域能量轨迹。\n- 计算忽略相关性的朴素均值标准误差。\n- 使用二进制分块（也称重分块）计算分块标准误差，该方法通过对大小为2的幂的连续块进行平均来对序列进行粗粒化，并在满足最小块数约束的条件下选择最大的块大小，从而减少时间相关性带来的偏差。\n\n形式上，令合成的局域能量时间序列由一个 AR(1) 递归定义\n$$\nX_{t} = \\mu + \\rho \\left( X_{t-1} - \\mu \\right) + \\varepsilon_{t}, \\quad \\varepsilon_{t} \\sim \\mathcal{N}\\!\\left(0, \\sigma_{\\varepsilon}^{2}\\right),\n$$\n在其平稳分布中初始化为\n$$\nX_{0} \\sim \\mathcal{N}\\!\\left(\\mu, \\sigma^{2}\\right), \\quad \\sigma_{\\varepsilon}^{2} = \\sigma^{2}\\left(1-\\rho^{2}\\right),\n$$\n其中 $t \\in \\{1,2,\\dots,N-1\\}$，$N$ 是样本总数，$\\mu$ 是固定节点能量偏移（一个恒定均值），$\\sigma$ 是局域能量的平稳标准差，$\\rho \\in (-1,1)$ 控制相关强度。\n\n给定一个实现 $\\{X_{t}\\}_{t=0}^{N-1}$：\n- 朴素标准误差是样本标准差除以 $\\sqrt{N}$，其中样本方差使用无偏除数。\n- 对于分块法，定义块大小 $b \\in \\{2^{0}, 2^{1}, 2^{2}, \\dots\\}$，并且对于每个块大小 $b$，形成 $n_{b} = \\lfloor N/b \\rfloor$ 个大小为 $b$ 的连续块，取其均值，并计算这些块均值的样本方差（使用无偏除数）。块大小为 $b$ 时的分块标准误差是块均值方差除以 $n_{b}$ 的平方根。选择最大的块大小 $b^{\\star}$，使得 $n_{b^{\\star}} \\geq B_{\\min}$，其中 $B_{\\min}$ 是指定的最小块数。将此分块标准误差用作报告的基于分块法的误差棒。\n\n您的程序必须实现上述过程，不得使用任何快捷公式求解答案，并且对于每个测试用例，必须输出以下包含四个浮点数的列表：\n- 朴素均值标准误差。\n- 在 $b^{\\star}$ 和指定的 $B_{\\min}$ 下确定的分块均值标准误差。\n- 朴素标准误差与分块标准误差的比值。\n- 估计的有效样本量，定义为原始序列的无偏样本方差与分块标准误差平方的比值。\n\n所有浮点输出必须四舍五入到小数点后六位。\n\n测试套件：\n使用以下四个参数集，每个参数集以元组 $(N, \\mu, \\sigma, \\rho, \\text{seed}, B_{\\min})$ 的形式给出：\n- 案例 1：$(N=\\;65536,\\; \\mu=\\;-0.5,\\; \\sigma=\\;1.0,\\; \\rho=\\;0.0,\\; \\text{seed}=\\;12345,\\; B_{\\min}=\\;16)$。\n- 案例 2：$(N=\\;65536,\\; \\mu=\\;-0.5,\\; \\sigma=\\;1.0,\\; \\rho=\\;0.8,\\; \\text{seed}=\\;24680,\\; B_{\\min}=\\;16)$。\n- 案例 3：$(N=\\;65536,\\; \\mu=\\;-0.5,\\; \\sigma=\\;1.0,\\; \\rho=\\;0.98,\\; \\text{seed}=\\;13579,\\; B_{\\min}=\\;16)$。\n- 案例 4：$(N=\\;50000,\\; \\mu=\\;-1.0,\\; \\sigma=\\;1.5,\\; \\rho=\\;0.9,\\; \\text{seed}=\\;98765,\\; B_{\\min}=\\;16)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个 Python 风格的列表，每个测试用例对应一个条目，而每个条目本身是按上述顺序排列的四个浮点数的列表。该列表必须打印为用方括号括起来的逗号分隔列表，例如，\n$$\n\\left[\\left[\\text{naive}_{1},\\text{blocked}_{1},\\text{ratio}_{1},\\text{effN}_{1}\\right],\\left[\\text{naive}_{2},\\text{blocked}_{2},\\text{ratio}_{2},\\text{effN}_{2}\\right],\\dots\\right].\n$$\n不需要物理单位。不涉及角度。不得使用百分比；任何分数都必须表示为小数。程序必须完全自包含，不需要任何输入。必须通过提供的种子确保确定性伪随机数生成。所有步骤的计算必须遵循上述定义。", "solution": "所提出的问题是相关时间序列统计分析中一个定义明确的练习，这是处理计算物理和化学中蒙特卡罗模拟数据的基本任务。使用一阶自回归 (AR(1)) 过程来模拟扩散蒙特卡罗 (DMC) 计算中的局域能量涨落是一种标准且具有物理合理性的近似方法。目标是在存在时间相关性的情况下，正确估计平均能量的统计不确定度。这需要超越那些假设数据独立的朴素统计估计量。\n\n对问题陈述的验证证实了其科学基础扎实、数学上适定，并包含了继续进行所需的所有必要信息。该问题既不琐碎也不不适定。因此，可以构建一个严谨的解决方案。\n\n解决方案将遵循统计力学和时间序列分析的原理，分三个阶段进行开发。\n\n首先，我们必须生成合成数据。局域能量时间序列，由随机变量序列 $\\{X_t\\}_{t=0}^{N-1}$ 表示，被建模为一个平稳高斯 AR(1) 过程。其演化由递归关系给出：\n$$\nX_{t} = \\mu + \\rho \\left( X_{t-1} - \\mu \\right) + \\varepsilon_{t}\n$$\n其中 $\\mu$ 是恒定平均能量，$\\rho$ 是连续步骤之间的自相关系数，$\\varepsilon_t$ 是均值为零、方差为 $\\sigma_{\\varepsilon}^2$ 的独立同分布高斯噪声项。为确保过程是平稳的且具有恒定方差 $\\sigma^2 = \\text{Var}(X_t)$，噪声方差必须设置为 $\\sigma_{\\varepsilon}^2 = \\sigma^2(1-\\rho^2)$。模拟始于从平稳分布本身抽取初始状态 $X_0$，该分布是均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布，即 $X_0 \\sim \\mathcal{N}(\\mu, \\sigma^2)$。随后的点 $X_t$（对于 $t \\in \\{1, 2, \\dots, N-1\\}$）通过递归生成。此过程保证了整个生成的序列是来自指定平稳过程的真实样本。\n\n其次，我们计算朴素均值标准误差。该估计量基于 $N$ 个数据点不相关的错误假设。其计算公式为：\n$$\n\\text{SE}_{\\text{naive}} = \\frac{s}{\\sqrt{N}}\n$$\n其中 $s^2$ 是时间序列 $\\{X_t\\}$ 的无偏样本方差：\n$$\ns^2 = \\frac{1}{N-1} \\sum_{t=0}^{N-1} (X_t - \\bar{X})^2\n$$\n此处，$\\bar{X}$ 是序列的样本均值。对于任何正相关 ($\\rho  0$)，该估计量会系统性地低估真实不确定度。\n\n第三，我们实现分块法，这是一种用于处理序列相关的稳健技术。其核心原理是将数据粗粒化为足够大的块，以使块平均值近似不相关。对于一个选定的块大小 $b$，原始序列被分割成 $n_b = \\lfloor N/b \\rfloor$ 个不重叠的块。计算每个块的均值，从而产生一个由 $n_b$ 个块平均值构成的新的、更短的时间序列。\n总均值的方差随后可以从这些块均值的样本方差中估计出来。对于给定的块大小 $b$，其标准误差为：\n$$\n\\text{SE}_{\\text{blocked}}(b) = \\sqrt{\\frac{\\text{var}(\\text{block means})}{n_b}}\n$$\n其中 $\\text{var}(\\text{block means})$ 是 $n_b$ 个块平均值的无偏样本方差。随着块大小 $b$ 的增加，块平均值的相关性降低，$\\text{SE}_{\\text{blocked}}(b)$ 会收敛于均值的真实标准误差。然而，随着 $b$ 的增加，$n_b$ 会减少，导致对方差的统计估计变差。因此，我们必须选择一个最佳的块大小 $b^{\\star}$。问题指定了一个实用准则：$b^{\\star}$ 是形如 $2^k$（其中整数 $k \\ge 0$）的最大块大小，使得块数 $n_{b^{\\star}}$ 至少为指定的最小值 $B_{\\min}$。此过程在减少相关性偏差和维持统计稳定性之间取得了平衡。\n\n最后，我们计算两个派生量来表征相关性的影响。朴素标准误差与分块标准误差的比值 $\\text{SE}_{\\text{naive}} / \\text{SE}_{\\text{blocked}}(b^{\\star})$，量化了朴素公式的低估程度。有效样本量定义为：\n$$\nN_{\\text{eff}} = \\frac{s^2}{(\\text{SE}_{\\text{blocked}}(b^{\\star}))^2}\n$$\n表示能够产生等效统计误差的独立样本数量。对于正相关数据，我们预期 $N_{\\text{eff}}  N$。\n\n该实现将对测试套件中提供的每个参数集执行此完整过程，通过使用指定的伪随机数生成器种子来确保确定性输出。所有数值结果将按要求四舍五入到小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates synthetic DMC local-energy traces using an AR(1) process and\n    computes naive and blocked standard errors of the mean.\n    \"\"\"\n    \n    # Test cases are given as (N, mu, sigma, rho, seed, B_min).\n    test_cases = [\n        (65536, -0.5, 1.0, 0.0, 12345, 16),\n        (65536, -0.5, 1.0, 0.8, 24680, 16),\n        (65536, -0.5, 1.0, 0.98, 13579, 16),\n        (50000, -1.0, 1.5, 0.9, 98765, 16)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, mu, sigma, rho, seed, B_min = case\n\n        # Initialize the pseudorandom number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate the AR(1) time series.\n        # This series emulates correlated local energy data from a DMC simulation.\n        X = np.zeros(N)\n        sigma_eps = sigma * np.sqrt(1.0 - rho**2)\n\n        # Initialize from the stationary distribution.\n        X[0] = rng.normal(loc=mu, scale=sigma)\n        \n        # Generate the rest of the series via the AR(1) recursion.\n        for t in range(1, N):\n            epsilon_t = rng.normal(loc=0.0, scale=sigma_eps)\n            X[t] = mu + rho * (X[t-1] - mu) + epsilon_t\n\n        # Calculate the unbiased sample variance of the original series.\n        # This will be used for both naive error and effective sample size.\n        sample_variance = np.var(X, ddof=1)\n\n        # 1. Compute the naive standard error of the mean.\n        # This estimator ignores correlations and is expected to be inaccurate for rho != 0.\n        naive_se = np.sqrt(sample_variance / N)\n\n        # 2. Compute the blocked standard error of the mean.\n        # This involves reblocking the data with increasing block sizes.\n        blocked_se = -1.0  # Placeholder, will be updated in the loop.\n        k = 0\n        while True:\n            # Block sizes are powers of two.\n            b = 2**k\n            n_b = N // b\n            \n            # Stop if the number of blocks is less than the required minimum.\n            # The result from the previous iteration is the correct one.\n            if n_b  B_min:\n                break\n            \n            # If n_b becomes 1, variance calculation is impossible.\n            # B_min > 1 ensures this path is not taken for the final result.\n            if n_b = 1:\n                # If this is the first iteration (k=0), it means N  B_min\n                # and no valid blocking is possible. Set SE to NaN.\n                if k == 0:\n                    blocked_se = np.nan\n                break\n\n            # Reshape the data into blocks. Leftover data at the end of the series is discarded.\n            num_elements_to_block = n_b * b\n            data_to_block = X[:num_elements_to_block]\n            blocks = data_to_block.reshape((n_b, b))\n            \n            # Compute the means of the blocks.\n            block_means = np.mean(blocks, axis=1)\n            \n            # Compute the unbiased variance of the block means.\n            var_block_means = np.var(block_means, ddof=1)\n            \n            # The standard error of the grand mean, estimated from this blocking level.\n            # This value is updated and stored. The last valid one is used.\n            blocked_se = np.sqrt(var_block_means / n_b)\n            \n            k += 1\n\n        # 3. Compute the ratio of naive to blocked standard error.\n        ratio = naive_se / blocked_se\n        \n        # 4. Compute the effective sample size.\n        effective_n = sample_variance / (blocked_se**2)\n\n        # Collect and round results to six decimal places.\n        result_list = [\n            round(naive_se, 6),\n            round(blocked_se, 6),\n            round(ratio, 6),\n            round(effective_n, 6)\n        ]\n        all_results.append(result_list)\n\n    # Format the final output string to be a compact list of lists.\n    # e.g., [[item1,item2],[item3,item4]]\n    # The map(str, ...) converts each inner list to its string representation.\n    # The ','.join(...) combines them into a single string.\n    # The outer f-string adds the enclosing brackets.\n    final_output_str = f\"[{','.join(map(str, all_results))}]\"\n    final_output_str = final_output_str.replace(\" \", \"\")\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2885597"}]}