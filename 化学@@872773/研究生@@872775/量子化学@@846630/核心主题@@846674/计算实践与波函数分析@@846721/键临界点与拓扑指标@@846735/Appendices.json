{"hands_on_practices": [{"introduction": "本章的实践练习旨在将理论知识应用于解决具体问题。第一个练习是一个基础性的推导，要求您从第一性原理出发，为一个简单、理想化的双原子分子体系验证其键临界点（BCP）的拓扑特性。通过解析地计算电子密度的 Hessian 矩阵及其特征值，您将亲手验证定义 BCP 的 $(3,-1)$ 符号，从而巩固 QTAIM 分析的核心概念 [@problem_id:2876140]。", "problem": "考虑一个沿 $z$ 轴排列的同核双原子分子，其模型由一个柱对称的解析电子密度函数给出：\n$$\n\\rho(x,y,z) \\;=\\; A\\left[\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z-\\frac{R}{2}\\right)^{2}\\right)\\right) \\;+\\; \\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+\\left(z+\\frac{R}{2}\\right)^{2}\\right)\\right)\\right],\n$$\n其中 $A0$、$\\alpha0$ 且 $R0$。使用原子单位制，其中长度单位为玻尔 $a_{0}$，电子密度单位为 $a_{0}^{-3}$，密度的Hessian矩阵元单位为 $a_{0}^{-5}$。使用以下参数值：$A=1.0\\,a_{0}^{-3}$、$\\alpha=1.0\\,a_{0}^{-2}$ 和 $R=2.0\\,a_{0}$。在分子中原子的量子理论 (QTAIM) 中，键临界点 (BCP) 是指电子密度梯度 $\\nabla \\rho(\\mathbf{r})$ 为零，且密度的Hessian矩阵 $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$ 的特征值具有两个垂直于键的负曲率和一个沿着键的正曲率的点。\n\n从临界点和标量场的Hessian矩阵的基本定义出发：\n- 临界点满足 $\\nabla \\rho(\\mathbf{r})=\\mathbf{0}$。\n- Hessian矩阵是元素为 $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$ 的 $3\\times 3$ 矩阵。\n- $H$ 的特征值决定了 $\\rho$ 的局部曲率。\n\n完成以下任务：\n1. 通过对称性和对一阶导数的直接求值，找出给定 $\\rho(x,y,z)$ 沿核间轴的键临界点。\n2. 计算该点的Hessian矩阵 $H_{ij}$。\n3. 确定其三个特征值，并根据它们的符号，从QTAIM的角度确定该点的拓扑类型。\n\n以原子单位制，将有序特征值 $\\lambda_{1}\\le \\lambda_{2}\\le \\lambda_{3}$ 表示为单个行向量。无需四舍五入；请提供精确的符号表达式。", "solution": "我们从定义开始。标量场 $\\rho(\\mathbf{r})$ 的临界点是其梯度 $\\nabla \\rho(\\mathbf{r})=\\mathbf{0}$ 的点。Hessian矩阵 $H$ 是由二阶导数组成的矩阵，其元素为 $H_{ij}=\\partial^{2}\\rho/\\partial x_{i}\\partial x_{j}$。$H$ 的特征值表征了沿主方向的曲率。\n\n第1步：定位键临界点。电子密度为\n$$\n\\rho(x,y,z)=A\\left[\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z-z_{0})^{2}\\right)\\right)+\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z+z_{0})^{2}\\right)\\right)\\right],\n$$\n该函数在变换 $(x,y)\\mapsto(-x,-y)$ 和 $z\\mapsto -z$ 下保持不变，因为两项对称地分布在 $z=\\pm R/2$ 处。根据柱对称性，点 $(x,y,z)=(0,0,0)$ 是一个可能的临界点。我们通过计算一阶导数来验证。\n\n令 $z_{0}=R/2$。定义\n$$\n\\rho_{+}(x,y,z)=A\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z-z_{0})^{2}\\right)\\right),\\quad\n\\rho_{-}(x,y,z)=A\\exp\\!\\left(-\\alpha\\left(x^{2}+y^{2}+(z+z_{0})^{2}\\right)\\right),\n$$\n因此 $\\rho=\\rho_{+}+\\rho_{-}$。一阶导数为\n$$\n\\frac{\\partial \\rho_{\\pm}}{\\partial x}=-2\\alpha x\\,\\rho_{\\pm},\\quad\n\\frac{\\partial \\rho_{\\pm}}{\\partial y}=-2\\alpha y\\,\\rho_{\\pm},\\quad\n\\frac{\\partial \\rho_{+}}{\\partial z}=-2\\alpha (z-z_{0})\\,\\rho_{+},\\quad\n\\frac{\\partial \\rho_{-}}{\\partial z}=-2\\alpha (z+z_{0})\\,\\rho_{-}.\n$$\n在点 $(0,0,0)$ 处，我们有 $x=0$，$y=0$，并且\n$$\n\\left.\\frac{\\partial \\rho}{\\partial x}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial \\rho}{\\partial y}\\right|_{\\mathbf{0}}=0,\n$$\n和\n$$\n\\left.\\frac{\\partial \\rho}{\\partial z}\\right|_{\\mathbf{0}}=-2\\alpha\\left[-z_{0}\\,\\rho_{+}(0,0,0)+z_{0}\\,\\rho_{-}(0,0,0)\\right]=0,\n$$\n因为 $\\rho_{+}(0,0,0)=\\rho_{-}(0,0,0)=A\\exp(-\\alpha z_{0}^{2})$。因此 $\\nabla \\rho(0,0,0)=\\mathbf{0}$，所以 $(0,0,0)$ 是一个临界点。在一个对称的双原子分子中，这就是沿键轴的键临界点。\n\n第2步：计算BCP处的Hessian矩阵。我们计算 $\\rho_{\\pm}$ 的二阶导数。对于 $x$ 和 $y$ 方向，\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x^{2}}=\\frac{\\partial}{\\partial x}\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=-2\\alpha\\,\\rho_{\\pm}+(-2\\alpha x)\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=\\left(-2\\alpha+4\\alpha^{2}x^{2}\\right)\\rho_{\\pm},\n$$\n类似地\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial y^{2}}=\\left(-2\\alpha+4\\alpha^{2}y^{2}\\right)\\rho_{\\pm}.\n$$\n对于 $z$ 方向，\n$$\n\\frac{\\partial^{2}\\rho_{+}}{\\partial z^{2}}\n=\\frac{\\partial}{\\partial z}\\left(-2\\alpha(z-z_{0})\\,\\rho_{+}\\right)\n=-2\\alpha\\,\\rho_{+}+(-2\\alpha)(z-z_{0})\\left(-2\\alpha(z-z_{0})\\,\\rho_{+}\\right)\n=\\left(-2\\alpha+4\\alpha^{2}(z-z_{0})^{2}\\right)\\rho_{+},\n$$\n和\n$$\n\\frac{\\partial^{2}\\rho_{-}}{\\partial z^{2}}\n=\\left(-2\\alpha+4\\alpha^{2}(z+z_{0})^{2}\\right)\\rho_{-}.\n$$\n混合二阶导数为\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x\\,\\partial y}\n=\\frac{\\partial}{\\partial x}\\left(-2\\alpha y\\,\\rho_{\\pm}\\right)\n=(-2\\alpha y)\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=4\\alpha^{2}xy\\,\\rho_{\\pm},\n$$\n$$\n\\frac{\\partial^{2}\\rho_{\\pm}}{\\partial x\\,\\partial z}\n=\\frac{\\partial}{\\partial x}\\left(-2\\alpha(z\\mp z_{0})\\,\\rho_{\\pm}\\right)\n=(-2\\alpha)(z\\mp z_{0})\\left(-2\\alpha x\\,\\rho_{\\pm}\\right)\n=4\\alpha^{2}x(z\\mp z_{0})\\,\\rho_{\\pm},\n$$\n$\\partial^{2}\\rho_{\\pm}/\\partial y\\,\\partial z$ 的情况也类似。\n\n在点 $(0,0,0)$ 处求值，我们有 $x=0$，$y=0$，且 $\\rho_{+}(0,0,0)=\\rho_{-}(0,0,0)=A\\exp(-\\alpha z_{0}^{2})$。因此，\n$$\n\\rho(0,0,0)=\\rho_{+}(0,0,0)+\\rho_{-}(0,0,0)=2A\\exp(-\\alpha z_{0}^{2}).\n$$\n对角线上的二阶导数为\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x^{2}}\\right|_{\\mathbf{0}}\n=\\sum_{\\pm}\\left(-2\\alpha+4\\alpha^{2}x^{2}\\right)\\rho_{\\pm}\\bigg|_{\\mathbf{0}}\n=\\sum_{\\pm}(-2\\alpha)\\rho_{\\pm}(0,0,0)\n=-2\\alpha\\,\\rho(0,0,0),\n$$\n同样地，\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial y^{2}}\\right|_{\\mathbf{0}}\n=-2\\alpha\\,\\rho(0,0,0).\n$$\n对于 $z$，\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial z^{2}}\\right|_{\\mathbf{0}}\n=\\left[\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho_{+}(0,0,0)\\right]+\\left[\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho_{-}(0,0,0)\\right]\n=\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0).\n$$\n所有混合导数在 $(0,0,0)$ 处都为零，因为每一项都包含一个因子 $x$、$y$ 或 $z$，而它们在该点的值为零：\n$$\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x\\,\\partial y}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial^{2}\\rho}{\\partial x\\,\\partial z}\\right|_{\\mathbf{0}}=0,\\quad\n\\left.\\frac{\\partial^{2}\\rho}{\\partial y\\,\\partial z}\\right|_{\\mathbf{0}}=0.\n$$\n因此，在 $(x,y,z)$ 基下，BCP处的Hessian矩阵是对角矩阵：\n$$\nH(0,0,0)=\\begin{pmatrix}\n-2\\alpha\\,\\rho(0,0,0)  0  0 \\\\\n0  -2\\alpha\\,\\rho(0,0,0)  0 \\\\\n0  0  \\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0)\n\\end{pmatrix}.\n$$\n\n第3步：根据指定参数计算特征值及其符号。使用 $A=1.0$、$\\alpha=1.0$ 和 $R=2.0$，我们有 $z_{0}=R/2=1.0$ 且\n$$\n\\rho(0,0,0)=2A\\exp(-\\alpha z_{0}^{2})=2\\exp(-1).\n$$\n因此，\n$$\n\\lambda_{x}=\\left.\\frac{\\partial^{2}\\rho}{\\partial x^{2}}\\right|_{\\mathbf{0}}=-2\\alpha\\,\\rho(0,0,0)=-2\\cdot 1\\cdot 2\\exp(-1)=-4\\exp(-1),\n$$\n$$\n\\lambda_{y}=\\left.\\frac{\\partial^{2}\\rho}{\\partial y^{2}}\\right|_{\\mathbf{0}}=-4\\exp(-1),\n$$\n$$\n\\lambda_{z}=\\left.\\frac{\\partial^{2}\\rho}{\\partial z^{2}}\\right|_{\\mathbf{0}}=\\left(-2\\alpha+4\\alpha^{2}z_{0}^{2}\\right)\\rho(0,0,0)=\\left(-2+4\\cdot 1\\cdot 1\\right)\\cdot 2\\exp(-1)=4\\exp(-1).\n$$\n有序特征值为 $\\lambda_{1}=\\lambda_{x}=-4\\exp(-1)$、$\\lambda_{2}=\\lambda_{y}=-4\\exp(-1)$ 和 $\\lambda_{3}=\\lambda_{z}=4\\exp(-1)$。其中两个为负（横向曲率），一个为正（沿键曲率），这在分子中原子的量子理论意义上确定了一个 $(3,-1)$ 型键临界点。所有值均以原子单位制给出，Hessian矩阵元的单位为 $a_{0}^{-5}$。", "answer": "$$\\boxed{\\begin{pmatrix}-4\\exp(-1)  -4\\exp(-1)  4\\exp(-1)\\end{pmatrix}}$$", "id": "2876140"}, {"introduction": "在掌握了分析模型之后，我们需要从理想情况过渡到实际的计算化学场景，在这些场景中，电子密度通常是在离散的网格上给出的，而非解析表达式。本练习直面这一实际挑战，您将实现一个高阶有限差分格式来近似 Hessian 矩阵，并研究其特征值的计算精度如何依赖于网格间距 [@problem_id:2876043]。这项实践对于培养数值误差的直觉以及理解真实研究中计算成本与精度之间的权衡至关重要。", "problem": "您的任务是构建并测试一个高阶有限差分近似方案，用于计算在分子中原子量子理论（Quantum Theory of Atoms in Molecules）意义下键临界点处的电子密度黑塞矩阵。设电子密度为一个光滑标量场，记作 $\\rho(\\mathbf{r})$，其中 $\\mathbf{r} = (x,y,z)$。其黑塞矩阵是一个 $3 \\times 3$ 矩阵，元素为 $H_{ij}(\\mathbf{r}) = \\partial^2 \\rho(\\mathbf{r}) / \\partial x_i \\partial x_j$，其中 $x_1 = x$，$x_2 = y$，$x_3 = z$。在通常的分类中，键临界点是 $\\rho$ 的一个驻点，其符号差为 $(3,-1)$，即 $\\nabla \\rho(\\mathbf{r}_\\mathrm{bcp}) = \\mathbf{0}$，并且在 $\\mathbf{r}_\\mathrm{bcp}$ 处的黑塞矩阵具有两个负特征值和一个正特征值。\n\n仅从 $\\rho$ 在均匀笛卡尔网格（各方向间距为 $h$）上某点周围的泰勒展开出发，推导一个阶为 $\\mathcal{O}(h^4)$ 的有限差分格式，用以近似该网格上黑塞矩阵的每个元素 $H_{ij}$。该格式必须能同时近似纯二阶导数 $\\partial^2 \\rho / \\partial x_i^2$ 和混合二阶导数 $\\partial^2 \\rho / \\partial x_i \\partial x_j$（当 $i \\neq j$ 时）。\n\n然后，实施该格式，研究两个相同高斯中心连线中点处的黑塞矩阵特征值的收敛性，该点是一个模型键临界点。具体来说，考虑以下解析模型电子密度\n$$\n\\rho_{\\alpha,a}(x,y,z) = \\exp\\!\\big(-\\alpha\\big((x-a)^2 + y^2 + z^2\\big)\\big) + \\exp\\!\\big(-\\alpha\\big((x+a)^2 + y^2 + z^2\\big)\\big),\n$$\n其中参数 $\\alpha \\gt 0$ 且 $a \\gt 0$。在中点 $\\mathbf{r} = (0,0,0)$ 处，该场满足 $\\nabla \\rho_{\\alpha,a}(0,0,0) = \\mathbf{0}$。当 $\\alpha a^2 \\gt \\tfrac{1}{2}$ 时，点 $(0,0,0)$ 具有键临界点的符号差。\n\n您的程序必须：\n- 构建一个以原点为中心、间距为 $h$ 的均匀笛卡尔网格，并仅使用网格点上的函数值 $\\rho_{\\alpha,a}$，通过一个对各元素截断误差为 $\\mathcal{O}(h^4)$ 的格式来近似黑塞矩阵 $H(0,0,0)$。\n- 计算近似黑塞矩阵的三个特征值，并将其与从 $\\rho_{\\alpha,a}$ 在 $(0,0,0)$ 处的解析黑塞矩阵得到的精确特征值进行比较。将给定 $h$ 的标量误差定义为\n$$\nE(h) = \\max_{k \\in \\{1,2,3\\}} \\left| \\lambda_k(h) - \\lambda_k^{\\mathrm{true}} \\right|,\n$$\n其中 $\\lambda_k(h)$ 是数值近似的特征值，$\\lambda_k^{\\mathrm{true}}$ 是精确特征值，两者均按升序排列。\n- 对于下面测试套件中的每一对参数 $(\\alpha,a)$，为一系列间距 $h \\in \\{\\,0.2,\\,0.1,\\,0.05,\\,0.025\\,\\}$ 计算 $E(h)$，并通过对数据点 $\\big(\\log h, \\log E(h)\\big)$ 进行直线拟合，取其斜率来估计观测到的精度阶数 $p$。该估计必须统一使用以 $e$ 为底的对数或以 $10$ 为底的对数进行计算；任一选择均可接受，但必须在所有数据中保持一致。\n- 生成最终输出，为单行文本，包含一个列表，其中含有与下面四个测试案例相对应的四个估计阶数 $p$（浮点数），顺序与列表顺序一致，并四舍五入到三位小数。\n\n测试套件：\n- 案例1：$(\\alpha,a) = (1.2,\\,1.0)$。\n- 案例2：$(\\alpha,a) = (0.8,\\,1.0)$。\n- 案例3：$(\\alpha,a) = (2.0,\\,0.7)$。\n- 案例4：$(\\alpha,a) = (0.55,\\,1.0)$。\n\n注意事项与要求：\n- 所有计算都是无量纲的，因此不需要物理单位。\n- 本问题不涉及角度。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[p_1,p_2,p_3,p_4]$），其中每个 $p_i$ 是相应测试案例的估计阶数。", "solution": "用户提供了一个计算科学领域中有效且适定的问题，要求推导并实现一种数值方法。该问题在科学上基于分子中原子量子理论（QTAIM）和数值分析。所有提供的信息都是自洽的，足以得出一个完整的解决方案。\n\n主要任务是推导并实现一个截断误差为 $\\mathcal{O}(h^4)$ 阶的有限差分格式，用以在间距为 $h$ 的均匀笛卡尔网格上近似标量场 $\\rho(\\mathbf{r})$ 的黑塞矩阵。黑塞矩阵 $H_{ij} = \\partial^2 \\rho / \\partial x_i \\partial x_j$ 是一个对称的 $3 \\times 3$ 矩阵。这要求对纯二阶导数（$\\partial^2 \\rho / \\partial x_i^2$）和混合二阶导数（当 $i \\neq j$ 时为 $\\partial^2 \\rho / \\partial x_i \\partial x_j$）都使用四阶精度的公式。\n\n首先，我们推导纯二阶导数 $\\partial^2 \\rho / \\partial x^2$ 的公式。我们使用 $\\rho(x)$ 在中心点 $x_0$ 周围的泰勒级数展开。设 $\\rho_k = \\rho(x_0 + k h)$。\n$$ \\rho_{+1} = \\rho(x_0+h) = \\rho_0 + h\\rho' + \\frac{h^2}{2}\\rho'' + \\frac{h^3}{6}\\rho''' + \\frac{h^4}{24}\\rho^{(4)} + \\frac{h^5}{120}\\rho^{(5)} + \\frac{h^6}{720}\\rho^{(6)} + \\mathcal{O}(h^7) $$\n$$ \\rho_{-1} = \\rho(x_0-h) = \\rho_0 - h\\rho' + \\frac{h^2}{2}\\rho'' - \\frac{h^3}{6}\\rho''' + \\frac{h^4}{24}\\rho^{(4)} - \\frac{h^5}{120}\\rho^{(5)} + \\frac{h^6}{720}\\rho^{(6)} + \\mathcal{O}(h^7) $$\n将它们相加，我们得到：\n$$ \\rho_{+1} + \\rho_{-1} = 2\\rho_0 + h^2\\rho'' + \\frac{h^4}{12}\\rho^{(4)} + \\frac{h^6}{360}\\rho^{(6)} + \\mathcal{O}(h^8) $$\n为了消除 $\\mathcal{O}(h^2)$ 误差项（即包含 $\\rho^{(4)}$ 的项），我们需要一个更宽的模板。我们对 $\\rho_{\\pm 2} = \\rho(x_0 \\pm 2h)$ 进行展开：\n$$ \\rho_{+2} + \\rho_{-2} = 2\\rho_0 + (2h)^2\\rho'' + \\frac{(2h)^4}{12}\\rho^{(4)} + \\frac{(2h)^6}{360}\\rho^{(6)} + \\mathcal{O}(h^8) = 2\\rho_0 + 4h^2\\rho'' + \\frac{4h^4}{3}\\rho^{(4)} + \\frac{8h^6}{45}\\rho^{(6)} + \\mathcal{O}(h^8) $$\n我们构造这两个和的线性组合以消去 $\\rho^{(4)}$ 项。设和为 $S_1 = \\rho_{+1} + \\rho_{-1}$ 和 $S_2 = \\rho_{+2} + \\rho_{-2}$。我们寻求 $A S_1 + B S_2$，使得 $\\rho^{(4)}$ 的系数为零：$A (\\frac{h^4}{12}) + B (\\frac{4h^4}{3}) = 0$，这得到 $A + 16B = 0$。选择 $A=16, B=-1$：\n$$ 16(\\rho_{+1} + \\rho_{-1}) - (\\rho_{+2} + \\rho_{-2}) = 16(2\\rho_0 + h^2\\rho'') - (2\\rho_0 + 4h^2\\rho'') + \\mathcal{O}(h^6) = 30\\rho_0 + 12h^2\\rho'' + \\mathcal{O}(h^6) $$\n求解 $\\rho''$ 得到五点、四阶精度的中心差分公式：\n$$ \\frac{\\partial^2 \\rho}{\\partial x^2} \\approx \\frac{-\\rho(x_0+2h) + 16\\rho(x_0+h) - 30\\rho(x_0) + 16\\rho(x_0-h) - \\rho(x_0-2h)}{12h^2} $$\n首项误差项为 $-\\frac{h^4}{90}\\rho^{(6)}$，因此该格式确实是 $\\mathcal{O}(h^4)$ 阶的。\n\n接下来，我们推导混合导数 $\\partial^2 \\rho / \\partial x \\partial y$ 的公式。一种提高精度的常用方法是理查森外推法（Richardson extrapolation）。混合导数的标准二阶公式是：\n$$ D_{xy}^{(h)} = \\frac{\\rho(x+h, y+h) - \\rho(x-h, y+h) - \\rho(x+h, y-h) + \\rho(x-h, y-h)}{4h^2} $$\n该近似的误差展开式为 $D_{xy}^{(h)} = \\frac{\\partial^2\\rho}{\\partial x \\partial y} + C_2 h^2 + C_4 h^4 + \\dots$。如果我们也用步长 $2h$ 计算近似值，我们得到 $D_{xy}^{(2h)} = \\frac{\\partial^2\\rho}{\\partial x \\partial y} + C_2 (2h)^2 + C_4 (2h)^4 + \\dots = \\frac{\\partial^2\\rho}{\\partial x \\partial y} + 4C_2 h^2 + 16C_4 h^4 + \\dots$。\n我们可以通过取组合 $\\frac{4 D_{xy}^{(h)} - D_{xy}^{(2h)}}{3}$ 来消除首项误差项 $C_2 h^2$：\n$$ \\frac{4D_{xy}^{(h)} - D_{xy}^{(2h)}}{3} = \\frac{1}{3} \\left( 4\\left(\\frac{\\partial^2\\rho}{\\partial x \\partial y} + C_2 h^2\\right) - \\left(\\frac{\\partial^2\\rho}{\\partial x \\partial y} + 4C_2 h^2\\right) \\right) + \\mathcal{O}(h^4) = \\frac{\\partial^2\\rho}{\\partial x \\partial y} + \\mathcal{O}(h^4) $$\n这给出了九点、四阶精度的公式：\n$$ \\frac{\\partial^2\\rho}{\\partial x \\partial y} \\approx \\frac{1}{3} \\left( 4D_{xy}^{(h)} - D_{xy}^{(2h)} \\right) = \\frac{1}{48h^2} \\left[ 16S_1 - S_2 \\right] $$\n其中 $S_1 = \\rho(h,h) - \\rho(-h,h) - \\rho(h,-h) + \\rho(-h,-h)$ 且 $S_2 = \\rho(2h,2h) - \\rho(-2h,2h) - \\rho(2h,-2h) + \\rho(-2h,-2h)$。\n\n模型电子密度为 $\\rho_{\\alpha,a}(x,y,z) = \\exp(-\\alpha((x-a)^2 + y^2 + z^2)) + \\exp(-\\alpha((x+a)^2 + y^2 + z^2))$。点 $(0,0,0)$ 是一个临界点。由于该函数的高度对称性（$D_{2h}$ 点群对称性），在原点处的黑塞矩阵是对角的。对角元素的解析表达式为：\n$$ H_{11} = \\frac{\\partial^2\\rho}{\\partial x^2}\\bigg|_{(0,0,0)} = 4\\alpha(2\\alpha a^2 - 1)e^{-\\alpha a^2} $$\n$$ H_{22} = \\frac{\\partial^2\\rho}{\\partial y^2}\\bigg|_{(0,0,0)} = -4\\alpha e^{-\\alpha a^2} $$\n$$ H_{33} = \\frac{\\partial^2\\rho}{\\partial z^2}\\bigg|_{(0,0,0)} = -4\\alpha e^{-\\alpha a^2} $$\n精确特征值 $\\lambda_k^{\\mathrm{true}}$ 就是这些对角元素。对于一个键临界点（符号差为 $(3,-1)$），我们需要一个正特征值和两个负特征值。由于 $\\alpha0$，$H_{22}$ 和 $H_{33}$ 总是负的。$H_{11}  0$ 的条件是 $2\\alpha a^2 - 1  0$，即 $\\alpha a^2  \\frac{1}{2}$，所有测试案例都满足这个条件。根据对称性，所有非对角导数在原点处都为零，我们的数值格式也将正确地反映这一点。\n\n数值实现过程如下：对于每组参数 $(\\alpha, a)$ 和每个网格间距 $h$，我们使用推导出的 $\\mathcal{O}(h^4)$ 公式计算数值黑塞矩阵 $H(h)$。对于给定的模型，数值黑塞矩阵也是对角的。我们计算其特征值 $\\lambda_k(h)$ 和相应的真实特征值 $\\lambda_k^{\\mathrm{true}}$。误差定义为 $E(h) = \\max_{k} |\\lambda_k(h) - \\lambda_k^{\\mathrm{true}}|$，其中特征值是排序的。由于公式的截断误差是 $\\mathcal{O}(h^4)$，我们预期特征值的误差也遵循 $E(h) \\approx C h^p$，其中 $p=4$。通过取对数，我们得到 $\\log E(h) \\approx \\log C + p \\log h$。我们通过对数据点 $(\\log h, \\log E(h))$ 进行线性最小二乘拟合并提取斜率来估计观测到的精度阶数 $p$。对每个测试案例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a fourth-order finite difference scheme to approximate the\n    Hessian of a model electron density at a bond critical point, and determines\n    the observed order of accuracy for several test cases.\n    \"\"\"\n\n    def rho(x, y, z, alpha, a):\n        \"\"\"\n        Calculates the model electron density at a point (x, y, z).\n        \"\"\"\n        r_minus_sq = (x - a)**2 + y**2 + z**2\n        r_plus_sq = (x + a)**2 + y**2 + z**2\n        term1 = np.exp(-alpha * r_minus_sq)\n        term2 = np.exp(-alpha * r_plus_sq)\n        return term1 + term2\n\n    def compute_numerical_hessian(alpha, a, h):\n        \"\"\"\n        Computes the Hessian matrix at (0,0,0) using a O(h^4) finite difference scheme.\n        \"\"\"\n        H_num = np.zeros((3, 3))\n        \n        # Central difference formula for pure second derivatives:\n        # f_xx approx (-f(x+2h) + 16f(x+h) - 30f(x) + 16f(x-h) - f(x-2h)) / (12h^2)\n        # The model function rho(x,y,z) is even in all variables with respect to the origin (0,0,0),\n        # so f(-d) = f(d) for any displacement d.\n        \n        rho_0 = rho(0, 0, 0, alpha, a)\n        \n        # H_11 (d^2/dx^2) term\n        rho_h_x = rho(h, 0, 0, alpha, a)\n        rho_2h_x = rho(2*h, 0, 0, alpha, a)\n        # The model is even in x: rho(-x,y,z) = rho(x,y,z)\n        H_num[0, 0] = (-rho_2h_x + 16*rho_h_x - 30*rho_0 + 16*rho_h_x - rho_2h_x) / (12 * h**2)\n        \n        # H_22 (d^2/dy^2) term\n        rho_h_y = rho(0, h, 0, alpha, a)\n        rho_2h_y = rho(0, 2*h, 0, alpha, a)\n        H_num[1, 1] = (-rho_2h_y + 16*rho_h_y - 30*rho_0 + 16*rho_h_y - rho_2h_y) / (12 * h**2)\n\n        # H_33 (d^2/dz^2) term\n        rho_h_z = rho(0, 0, h, alpha, a)\n        rho_2h_z = rho(0, 0, 2*h, alpha, a)\n        H_num[2, 2] = (-rho_2h_z + 16*rho_h_z - 30*rho_0 + 16*rho_h_z - rho_2h_z) / (12 * h**2)\n\n        # Off-diagonal elements are zero due to the symmetry of the model function\n        # at the origin, which the finite difference stencil also respects.\n        \n        return H_num\n\n    def compute_exact_hessian(alpha, a):\n        \"\"\"\n        Computes the analytical Hessian matrix at (0,0,0).\n        \"\"\"\n        H_true = np.zeros((3, 3))\n        exp_term = np.exp(-alpha * a**2)\n        \n        H_true[0, 0] = 4 * alpha * (2 * alpha * a**2 - 1) * exp_term\n        H_true[1, 1] = -4 * alpha * exp_term\n        H_true[2, 2] = -4 * alpha * exp_term\n        \n        return H_true\n\n    # --- Main Calculation Loop ---\n    \n    test_cases = [\n        (1.2, 1.0),\n        (0.8, 1.0),\n        (2.0, 0.7),\n        (0.55, 1.0)\n    ]\n    h_values = np.array([0.2, 0.1, 0.05, 0.025])\n    estimated_orders = []\n\n    for alpha, a in test_cases:\n        # Calculate exact eigenvalues (sorted)\n        H_true = compute_exact_hessian(alpha, a)\n        lambda_true = np.linalg.eigvalsh(H_true)\n        \n        errors = []\n        for h in h_values:\n            # Calculate numerical eigenvalues (sorted)\n            H_num = compute_numerical_hessian(alpha, a, h)\n            lambda_num = np.linalg.eigvalsh(H_num)\n            \n            # Calculate the maximum absolute error in eigenvalues\n            error = np.max(np.abs(lambda_num - lambda_true))\n            errors.append(error)\n            \n        # Estimate the order of accuracy, p, by linear regression on log-log data.\n        # Relationship: log(E) = log(C) + p * log(h)\n        log_h = np.log(h_values)\n        log_E = np.log(np.array(errors))\n        \n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        p, _ = np.polyfit(log_h, log_E, 1)\n        estimated_orders.append(p)\n\n    # Format and print the final output as specified.\n    formatted_results = [f\"{p:.3f}\" for p in estimated_orders]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2876043"}, {"introduction": "在学习了如何计算拓扑指标后，更重要的问题是如何运用它们。QTAIM 理论的真正力量在于将其抽象的拓扑描述符与可触摸的化学性质联系起来。本练习将引导您探索其最著名的应用之一：将 BCP 处的电子密度 $\\rho_b$ 与键能相关联 [@problem_id:2876039]。通过在不同化学家族的数据上建立和测试回归模型，您将获得数据驱动化学分析的实践经验，并学会批判性地评估这类经验关系的普适性和局限性。", "problem": "给定三个化学族，我们已经为您整理了它们的键临界点(BCP)处的电子密度 $ \\rho_b $（单位为电子/玻尔半径^3，即 $\\mathrm{e/bohr^3}$）和参考键能 $ E $（单位为千焦/摩尔，即 $\\mathrm{kJ/mol}$）。在分子中原子的量子理论 (QTAIM) 框架下，键临界点是键径上的一个点，在该点上电子密度 $ \\rho(\\mathbf{r}) $ 的梯度 $ \\nabla \\rho(\\mathbf{r}) $ 为零，且 $ \\rho $ 的黑森矩阵的符号差与键鞍点一致。我们关注将 $ \\rho_b $ 与 $ E $ 相关联的经验性做法，并希望评估这种相关性在不同化学族之间的可迁移性。您的任务是，将此评估形式化为一个数学上适定的回归和误差分析问题，并将其实现为一个程序。\n\n从以下基础开始：\n- 电子密度 $ \\rho(\\mathbf{r}) $ 是空间上的一个标量场，而键临界点是 $ \\rho(\\mathbf{r}) $ 沿着键径的一个驻点。\n- 对于每个化学族内的几条化学键，我们都给出了数据对 $ (\\rho_b, E) $。\n- 经验性的结构-性质模型通常采用幂律形式 $ E = k \\, \\rho_b^{\\alpha} $，其中 $ k  0 $ 和 $ \\alpha $ 是需要从数据中学习的参数。\n- 当指定了线性关系时，用于线性回归的普通最小二乘法是估算参数的一种经过充分检验的程序。\n\n任务：\n1) 采用模型 $ E = k \\, \\rho_b^{\\alpha} $。通过对数变换后的变量应用普通最小二乘法，从训练数据中估算参数 $ k $ 和 $ \\alpha $，即对 $ \\ln E $ 和 $ \\ln \\rho_b $ 进行回归，使得 $ \\ln E = \\ln k + \\alpha \\ln \\rho_b $。使用在变换空间中能最小化残差平方和的唯一最小二乘解。\n2) 将测试集上的均方根误差 (RMSE) 定义为 $ \\mathrm{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (E_i - \\hat{E}_i)^2} $，其中 $ \\hat{E}_i $ 是使用训练好的模型对 $ \\rho_{b,i} $ 预测出的能量，而 $ n $ 是测试点的数量。\n3) 为量化族内预测误差（作为噪声和模型充分性的基线），在一个族内计算留一法交叉验证 (LOOCV) RMSE：对于该族中的每个数据点，使用其余的点来拟合模型，并计算在被留出的那个点上的预测误差平方；汇总所有被留出点的结果，得出 LOOCV RMSE。\n4) 为评估跨族的迁移性，在一个族上训练模型，然后在另一个不同的族上评估 RMSE，无需重新拟合。\n\n数据（每个数据对为 $ (\\rho_b, E) $，其中 $ \\rho_b $ 的单位是 $ \\mathrm{e/bohr^3} $，$ E $ 的单位是 $ \\mathrm{kJ/mol} $）：\n- 共价族 (C)：$[(0.12, 125.2), (0.15, 176.0), (0.18, 227.0), (0.22, 312.0), (0.26, 395.0), (0.30, 497.0), (0.34, 590.0), (0.38, 706.0)]$。\n- 离子/配位族 (I)：$[(0.06, 78.0), (0.08, 111.0), (0.10, 152.0), (0.12, 189.0), (0.14, 235.0), (0.16, 279.0)]$。\n- 氢键族 (H)：$[(0.010, 3.2), (0.015, 5.1), (0.020, 7.4), (0.030, 12.0), (0.040, 16.6), (0.050, 22.3)]$。\n\n测试套件：\n- 跨族 RMSE 情况（训练族 $\\rightarrow$ 测试族）：\n  1) $ \\mathrm{C} \\rightarrow \\mathrm{I} $\n  2) $ \\mathrm{I} \\rightarrow \\mathrm{C} $\n  3) $ \\mathrm{C} \\rightarrow \\mathrm{H} $\n  4) $ \\mathrm{H} \\rightarrow \\mathrm{C} $\n  5) $ \\mathrm{H} \\rightarrow \\mathrm{I} $\n  6) $ \\mathrm{I} \\rightarrow \\mathrm{H} $\n- 族内 LOOCV RMSE 情况：\n  7) $ \\mathrm{C} \\rightarrow \\mathrm{C} $ (LOOCV)\n  8) $ \\mathrm{H} \\rightarrow \\mathrm{H} $ (LOOCV)\n  9) $ \\mathrm{I} \\rightarrow \\mathrm{I} $ (LOOCV)\n\n实现和输出要求：\n- 在变换空间中进行回归时使用自然对数。\n- 所有 RMSE 值必须以 $ \\mathrm{kJ/mol} $ 为单位计算，并以 $ \\mathrm{kJ/mol} $ 为单位报告。\n- 您的程序必须生成单行输出，其中包含与上述测试套件相对应的九个 RMSE 值，按指定顺序排列，四舍五入到三位小数，并以逗号分隔列表的形式用方括号括起来。例如，输出应类似于 $[\\dots]$，其中包含恰好九个十进制格式的数字。\n- 不涉及角度。不涉及百分比。\n\n您的程序必须是一个完整、可运行的实现，它将上述数据硬编码，并在没有外部输入的情况下执行计算。最终的打印输出必须是符合所描述确切格式的单行文本。", "solution": "该问题在科学上是适定的，并为一项属于量子化学和数据分析领域的计算任务提供了完整的指令集。它基于将电子密度的拓扑性质（例如键临界点 ($\\rho_b$) 处的值）与宏观化学性质（如键能 ($E$)）相关联的既定实践。该问题经验证是合理的，下面提供了解决方案。\n\n问题的核心是量化经验性幂律模型 $E = k \\, \\rho_b^{\\alpha}$ 的预测能力和可迁移性，该模型将键能 $E$ 与键临界点处的电子密度 $\\rho_b$ 联系起来。参数 $k$ 和 $\\alpha$ 特定于化学环境，必须通过实验或计算数据来确定。\n\n为了估算这些参数，我们通过对等式两边取自然对数来线性化模型：\n$$ \\ln(E) = \\ln(k \\, \\rho_b^{\\alpha}) = \\ln(k) + \\alpha \\ln(\\rho_b) $$\n这个方程是直线形式 $y = c + m x$，其中变量为 $y = \\ln(E)$ 和 $x = \\ln(\\rho_b)$。直线的斜率是 $m = \\alpha$，y轴截距是 $c = \\ln(k)$。这种变换使我们能够使用普通最小二乘法 (OLS) 来找到 $\\alpha$ 和 $\\ln(k)$ 的最优值，这些值可以最小化 $\\ln(E)$ 的观测值和预测值之间的平方差之和。\n\n对于一个给定的包含 $n$ 个点的训练数据集 $\\{(\\rho_{b,i}, E_i)\\}_{i=1}^n$，我们首先将其转换为一组对数点 $\\{x_i, y_i\\}_{i=1}^n$，其中 $x_i = \\ln(\\rho_{b,i})$ 且 $y_i = \\ln(E_i)$。斜率 $\\alpha$ 和截距 $\\ln(k)$ 的 OLS 解由以下公式给出：\n$$ \\alpha = \\frac{n \\sum_{i=1}^{n} (x_i y_i) - (\\sum_{i=1}^{n} x_i) (\\sum_{i=1}^{n} y_i)}{n \\sum_{i=1}^{n} (x_i^2) - (\\sum_{i=1}^{n} x_i)^2} $$\n$$ \\ln(k) = \\bar{y} - \\alpha \\bar{x} $$\n其中 $\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i$ 和 $\\bar{y} = \\frac{1}{n} \\sum_{i=1}^{n} y_i$ 是样本均值。然后通过取指数求得参数 $k$：$k = e^{\\ln(k)}$。\n\n一旦从训练集中确定了模型参数 $(\\alpha, k)$，我们就可以使用原始的幂律关系来预测任何新的电子密度值 $\\rho_{b,j}$ 对应的能量 $\\hat{E}_j$：\n$$ \\hat{E}_j = k \\, (\\rho_{b,j})^{\\alpha} $$\n模型的性能通过在包含 $N$ 个点的测试集上计算均方根误差 (RMSE) 来评估，其定义为：\n$$ \\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{j=1}^{N} (E_j - \\hat{E}_j)^2} $$\n这个度量标准以能量的原始单位 ($\\mathrm{kJ/mol}$) 提供了预测误差平均大小的度量。\n\n该问题需要两种类型的模型评估：\n$1$. **跨族可迁移性**：这评估了在一个化学族（例如，共价族）上训练的模型预测另一个不同族（例如，离子族）能量的效果。这是对模型普适性的直接测试。该过程包括使用来自训练族的所有数据拟合模型参数 $(\\alpha, k)$，然后计算在整个测试族上的 RMSE。\n\n$2$. **族内预测误差**：这通过留一法交叉验证 (LOOCV) 进行评估。该技术提供了一个稳健的估计，说明模型预测来自*同一族内部*的新数据的效果，可作为模型固有准确性和稳定性的基线。对于一个包含 $n$ 个数据点的族，该过程重复 $n$ 次。在每次迭代 $i$ 中，第 $i$ 个数据点被留作测试点，模型在剩余的 $n-1$ 个点上进行训练。对被留出的点进行预测，得到 $\\hat{E}_i$。最终的 LOOCV RMSE 是基于所有 $n$ 次这样的预测 $\\{ (E_i, \\hat{E}_i) \\}_{i=1}^n$ 计算得出的。\n\n实现将系统地对九个指定的测试用例执行这些计算。将使用为共价族 (C)、离子/配位族 (I) 和氢键族 (H) 提供的数据。回归是在对数变换后的数据上使用 `scipy.stats.linregress` 执行的，它提供了 OLS 的数值稳定实现。然后使用得到的参数来计算定义的预测值和 RMSE 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the QTAIM regression and error analysis problem.\n    \"\"\"\n    # Define the data for the three chemical families.\n    # Each entry is a numpy array of (rho_b, E) pairs.\n    data = {\n        'C': np.array([\n            (0.12, 125.2), (0.15, 176.0), (0.18, 227.0), (0.22, 312.0),\n            (0.26, 395.0), (0.30, 497.0), (0.34, 590.0), (0.38, 706.0)\n        ]),\n        'I': np.array([\n            (0.06, 78.0), (0.08, 111.0), (0.10, 152.0), (0.12, 189.0),\n            (0.14, 235.0), (0.16, 279.0)\n        ]),\n        'H': np.array([\n            (0.010, 3.2), (0.015, 5.1), (0.020, 7.4), (0.030, 12.0),\n            (0.040, 16.6), (0.050, 22.3)\n        ])\n    }\n\n    def fit_model(training_data):\n        \"\"\"\n        Fits the power-law model E = k * rho_b^alpha by linear regression\n        on log-transformed data.\n        \n        Args:\n            training_data (np.ndarray): Array of (rho_b, E) pairs.\n            \n        Returns:\n            tuple: A tuple (alpha, k) representing the model parameters.\n        \"\"\"\n        rho_b = training_data[:, 0]\n        E = training_data[:, 1]\n        \n        log_rho_b = np.log(rho_b)\n        log_E = np.log(E)\n        \n        # OLS on log-transformed data: ln(E) = alpha * ln(rho_b) + ln(k)\n        slope, intercept, _, _, _ = linregress(log_rho_b, log_E)\n        \n        alpha = slope\n        k = np.exp(intercept)\n        \n        return alpha, k\n\n    def predict_E(model, rho_b_values):\n        \"\"\"\n        Predicts bond energies E using a fitted power-law model.\n        \n        Args:\n            model (tuple): A tuple (alpha, k) of model parameters.\n            rho_b_values (np.ndarray): Array of rho_b values.\n            \n        Returns:\n            np.ndarray: Array of predicted E values.\n        \"\"\"\n        alpha, k = model\n        return k * (rho_b_values ** alpha)\n\n    def calculate_rmse(E_true, E_pred):\n        \"\"\"\n        Calculates the Root-Mean-Square Error.\n        \n        Args:\n            E_true (np.ndarray): Array of true energy values.\n            E_pred (np.ndarray): Array of predicted energy values.\n            \n        Returns:\n            float: The RMSE value.\n        \"\"\"\n        return np.sqrt(np.mean((E_true - E_pred)**2))\n\n    def loocv_rmse(family_data):\n        \"\"\"\n        Calculates the Leave-One-Out Cross-Validation RMSE for a family.\n        \n        Args:\n            family_data (np.ndarray): Array of (rho_b, E) pairs for one family.\n            \n        Returns:\n            float: The LOOCV RMSE value.\n        \"\"\"\n        n_points = len(family_data)\n        squared_errors = []\n        \n        for i in range(n_points):\n            # Create leave-one-out training set by deleting the i-th row\n            lo_train_data = np.delete(family_data, i, axis=0)\n            \n            # The left-out point is the test set\n            lo_test_point = family_data[i]\n            \n            # Fit model on the (n-1) training points\n            model = fit_model(lo_train_data)\n            \n            # Predict on the single left-out point\n            rho_b_test = lo_test_point[0]\n            E_true = lo_test_point[1]\n            E_pred = predict_E(model, np.array([rho_b_test]))[0]\n            \n            squared_errors.append((E_true - E_pred)**2)\n            \n        return np.sqrt(np.mean(squared_errors))\n\n    # Define the 9 test cases from the problem statement.\n    test_suite = [\n        # Cross-family RMSE cases (train - test)\n        ('C', 'I'),  # 1\n        ('I', 'C'),  # 2\n        ('C', 'H'),  # 3\n        ('H', 'C'),  # 4\n        ('H', 'I'),  # 5\n        ('I', 'H'),  # 6\n        # Within-family LOOCV RMSE cases\n        ('C', 'C'),  # 7\n        ('H', 'H'),  # 8\n        ('I', 'I')   # 9\n    ]\n\n    results = []\n    for train_fam, test_fam in test_suite:\n        if train_fam == test_fam:\n            # This is an LOOCV case\n            family_data = data[train_fam]\n            rmse = loocv_rmse(family_data)\n        else:\n            # This is a cross-family transferability case\n            train_data = data[train_fam]\n            test_data = data[test_fam]\n            \n            # Fit model on the entire training family\n            model = fit_model(train_data)\n            \n            # Test model on the entire testing family\n            rho_b_test = test_data[:, 0]\n            E_true_test = test_data[:, 1]\n            E_pred_test = predict_E(model, rho_b_test)\n            \n            rmse = calculate_rmse(E_true_test, E_pred_test)\n            \n        results.append(rmse)\n\n    # Format the results to three decimal places and print in the required format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2876039"}]}