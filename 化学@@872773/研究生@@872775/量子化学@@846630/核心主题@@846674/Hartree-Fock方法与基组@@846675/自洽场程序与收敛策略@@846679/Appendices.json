{"hands_on_practices": [{"introduction": "任何Hartree-Fock计算的核心都是自洽场（SCF）循环。这个练习将带你深入这一核心，通过编程实现单次“宏观迭代”来剖析其内部机制。通过亲手构建从密度矩阵$P$到Fock矩阵$F$，再到求解广义本征值问题以获得新轨道和新密度矩阵的过程，你将对作为该方法基础的定点迭代建立起具体而深刻的理解。[@problem_id:2923088]", "problem": "给定模型体系在原子轨道基组下的小型单电子和双电子积分数据。您的任务是，从一个初始密度矩阵出发，实现限制性 Hartree–Fock 自洽场 (RHF-SCF) 方法的一次宏观迭代。请从正交归一分子轨道下的电子能量变分原理，以及限制性闭壳层情况下 Fock 算符的定义出发。推导在非正交原子轨道基组下产生的广义本征值问题，以及从已占据分子轨道构建闭壳层密度矩阵的相应规则。然后，利用这些推导出的关系，执行一次宏观迭代，包括：从初始密度构建 Fock 矩阵，求解广义本征值问题以获得分子轨道，并根据正确的闭壳层轨道占据数更新密度矩阵。最后，使用更新后的密度和相应的 Fock 矩阵计算更新后的电子能量。忽略核排斥能，只报告电子能量。所有量均采用原子单位（能量单位为 Hartree）。\n\n您必须使用的基本原理包括：多电子体系的 Hartree–Fock 变分原理，在非正交基组中通过重叠矩阵表达的分子轨道正交归一性，限制性 Hartree–Fock 形式下的闭壳层电子计数规则，以及根据化学家记法中双电子排斥积分构建的库仑和交换贡献的定义。除了从这些原理推导得出的结论外，您不能假定任何预先指定的简化公式。\n\n细节和约定：\n- 在原子轨道基组中进行计算，使用重叠矩阵 $S$、核心哈密顿矩阵 $H$ 和化学家记法下的电子排斥积分 (ERIs) $(\\mu\\nu|\\lambda\\sigma)$。\n- 使用限制性闭壳层形式：体系有 $N_{\\mathrm{elec}}$ 个电子，全部配对，因此已占据的空间轨道数量为 $N_{\\mathrm{occ}} = N_{\\mathrm{elec}}/2$。\n- ERI 遵循完全的置换对称性：$(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda) = (\\lambda\\sigma|\\mu\\nu)$，未列出的四重索引组其值为 $0$。\n- 索引从零开始：$\\mu,\\nu,\\lambda,\\sigma \\in \\{0,1,\\ldots,n_{\\mathrm{bf}}-1\\}$。\n- 执行一次宏观迭代，步骤如下：\n  1. 从初始密度矩阵 $P^{(0)}$ 出发，利用变分原理和给定的 ERI 所蕴含的库仑和交换项构建方法，构建适用于非正交原子轨道基组下限制性 Hartree–Fock 方法的 Fock 矩阵 $F^{(0)}$。\n  2. 求解广义对称本征值问题 $F^{(0)} C = S C \\varepsilon$，以获得相对于 $S$ 正交归一的分子轨道系数 $C$。\n  3. 确定 $N_{\\mathrm{occ}}$ 个能量最低的已占据轨道，并利用这些轨道在原子轨道基组中构建更新后的闭壳层密度矩阵 $P^{(1)}$。\n  4. 使用 $P^{(1)}$ 构建相应的 Fock 矩阵 $F^{(1)}$，并根据由 $H$、$F^{(1)}$ 和 $P^{(1)}$ 表示的 Hartree–Fock 能量泛函，计算此次宏观迭代后的电子能量，以原子单位 (Hartree) 表示。\n- 您必须将最终能量表示为四舍五入到十位小数的浮点数。\n\n测试套件：\n请实现您的程序以在内部处理以下三个测试用例。对每个用例，按照描述执行恰好一次宏观迭代，并报告最终的电子能量（不包括核排斥能），单位为 Hartree。矩阵以嵌套列表形式给出；所有数字均以原子单位表示，所有索引均从零开始。\n\n用例 A（理想路径，小型 $2\\times 2$ 系统）：\n- 基组大小 $n_{\\mathrm{bf}} = 2$，电子数 $N_{\\mathrm{elec}} = 2$（因此 $N_{\\mathrm{occ}} = 1$）。\n- 重叠矩阵 $S = \\left[\\left[1.0,\\,0.2\\right],\\left[0.2,\\,1.0\\right]\\right]$。\n- 核心哈密顿矩阵 $H = \\left[\\left[-1.0,\\,-0.2\\right],\\left[-0.2,\\,-0.8\\right]\\right]$。\n- 初始密度 $P^{(0)} = \\left[\\left[0.0,\\,0.0\\right],\\left[0.0,\\,0.0\\right]\\right]$。\n- 唯一 ERI 元组列表 $(\\mu,\\nu,\\lambda,\\sigma,\\text{值})$：\n  - $(0,0,0,0,0.70)$,\n  - $(0,0,0,1,0.20)$,\n  - $(0,0,1,1,0.60)$,\n  - $(0,1,0,1,0.30)$,\n  - $(0,1,1,1,0.25)$,\n  - $(1,1,1,1,0.675)$.\n\n用例 B（具有非平凡初始密度的较大型 $3\\times 3$ 系统）：\n- 基组大小 $n_{\\mathrm{bf}} = 3$，电子数 $N_{\\mathrm{elec}} = 4$（因此 $N_{\\mathrm{occ}} = 2$）。\n- 重叠矩阵 $S = \\left[\\left[1.0,\\,0.1,\\,0.0\\right],\\left[0.1,\\,1.0,\\,0.2\\right],\\left[0.0,\\,0.2,\\,1.0\\right]\\right]$。\n- 核心哈密顿矩阵 $H = \\left[\\left[-1.2,\\,-0.1,\\,0.0\\right],\\left[-0.1,\\,-0.9,\\,-0.15\\right],\\left[0.0,\\,-0.15,\\,-0.5\\right]\\right]$。\n- 初始密度 $P^{(0)} = \\left[\\left[1.8,\\,0.1,\\,0.05\\right],\\left[0.1,\\,1.2,\\,0.08\\right],\\left[0.05,\\,0.08,\\,0.0\\right]\\right]$。\n- 唯一 ERI 列表：\n  - $(0,0,0,0,0.80)$,\n  - $(0,0,0,1,0.15)$,\n  - $(0,0,0,2,0.05)$,\n  - $(0,0,1,1,0.60)$,\n  - $(0,0,1,2,0.07)$,\n  - $(0,0,2,2,0.50)$,\n  - $(0,1,0,1,0.20)$,\n  - $(0,1,0,2,0.06)$,\n  - $(0,1,1,2,0.08)$,\n  - $(0,1,1,1,0.18)$,\n  - $(0,1,2,2,0.12),\n  - $(0,2,0,2,0.16)$,\n  - $(0,2,1,2,0.09)$,\n  - $(0,2,2,2,0.14)$,\n  - $(1,1,1,1,0.70)$,\n  - $(1,1,1,2,0.11)$,\n  - $(1,1,2,2,0.55)$,\n  - $(1,2,1,2,0.19)$,\n  - $(1,2,2,2,0.13)$,\n  - $(2,2,2,2,0.65)$.\n\n用例 C（S 矩阵中存在近似线性相关的边缘情况）：\n- 基组大小 $n_{\\mathrm{bf}} = 2$，电子数 $N_{\\mathrm{elec}} = 2$（因此 $N_{\\mathrm{occ}} = 1$）。\n- 重叠矩阵 $S = \\left[\\left[1.0,\\,0.98\\right],\\left[0.98,\\,1.0\\right]\\right]$。\n- 核心哈密顿矩阵 $H = \\left[\\left[-1.0,\\,-0.9\\right],\\left[-0.9,\\,-1.0\\right]\\right]$。\n- 初始密度 $P^{(0)} = \\left[\\left[0.0,\\,0.0\\right],\\left[0.0,\\,0.0\\right]\\right]$。\n- 唯一 ERI 列表：\n  - $(0,0,0,0,0.70)$,\n  - $(0,0,0,1,0.25)$,\n  - $(0,0,1,1,0.68)$,\n  - $(0,1,0,1,0.33)$,\n  - $(0,1,1,1,0.28)$,\n  - $(1,1,1,1,0.72)$.\n\n您的程序必须：\n- 根据所述的对称性，从每个用例的唯一列表重建完整的四索引 ERI 张量，所有未指定的四重索引组均等于 $0$。\n- 按规定为每个用例执行恰好一次 RHF-SCF 宏观迭代。\n- 使用更新后的密度和相应更新的 Fock 矩阵计算最终的电子能量（单位为 Hartree）。\n- 输出单行结果，该行为一个逗号分隔的列表，包含三个能量值，每个值都四舍五入到恰好十位小数，并用方括号括起来，例如 $\\left[\\text{用例A},\\text{用例B},\\text{用例C}\\right]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[结果1,结果2,结果3]”）。", "solution": "所述问题是有效的。它提出了一个计算量子化学中定义明确的任务，该任务基于 Hartree-Fock 近似的基本原理。所有必要的数据和约束都已提供，问题没有科学上的不准确、矛盾或含糊之处。我们将首先进行严谨的推导，然后进行算法实现。\n\n目标是执行限制性 Hartree-Fock (RHF) 自洽场 (SCF) 方法的一次宏观迭代。该方法的基础是变分原理，该原理指出，多电子体系的真实基态能量是哈密顿量期望值的最小值。在 Hartree-Fock 近似中，试探波函数被限制为单个 Slater 行列式。对于具有 $N_{\\mathrm{elec}}$ 个电子的闭壳层体系，这会导出一个依赖于 $N_{\\mathrm{occ}} = N_{\\mathrm{elec}}/2$ 个双占据空间分子轨道 (MO) $\\{\\psi_i\\}$ 的能量泛函。\n\n分子轨道 $\\psi_i$ 通过 LCAO (原子轨道线性组合) 近似，表示为一组 $n_{\\mathrm{bf}}$ 个非正交原子轨道 (AO) $\\{\\chi_\\mu\\}$ 的线性组合：\n$$ \\psi_i = \\sum_{\\mu=1}^{n_{\\mathrm{bf}}} C_{\\mu i} \\chi_\\mu $$\n其中 $C_{\\mu i}$ 是分子轨道系数。AO 基组的非正交性由重叠矩阵 $S$ 描述，其矩阵元为 $S_{\\mu\\nu} = \\langle \\chi_\\mu | \\chi_\\nu \\rangle$。分子轨道被约束为正交归一的，这在 AO 基组中转化为矩阵方程：\n$$ C^T S C = I $$\n其中 $C$ 是分子轨道系数构成的 $n_{\\mathrm{bf}} \\times n_{\\mathrm{bf}}$ 矩阵，$I$ 是单位矩阵。\n\nRHF 形式下的电子能量泛函可以用单电子密度矩阵 $P$ 来表示。在 AO 基组中，闭壳层体系的密度矩阵元定义为：\n$$ P_{\\mu\\nu} = 2 \\sum_{i=1}^{N_{\\mathrm{occ}}} C_{\\mu i} C_{\\nu i} $$\n因子 $2$ 说明了每个空间轨道的双占据情况。\n\n在正交归一性约束下，对能量泛函关于分子轨道系数 $C_{\\mu i}$ 进行最小化，得到 Roothaan-Hall 方程，这是一个广义本征值问题：\n$$ F C = S C \\varepsilon $$\n这里，$F$ 是 Fock 矩阵，$\\varepsilon$ 是分子轨道能量的对角矩阵。Fock 矩阵 $F$ 是有效单电子 Fock 算符在 AO 基组中的矩阵表示。其矩阵元由下式给出：\n$$ F_{\\mu\\nu} = H_{\\mu\\nu} + G_{\\mu\\nu} $$\n其中 $H_{\\mu\\nu} = \\langle \\chi_\\mu | \\hat{h} | \\chi_\\nu \\rangle$ 是核心哈密顿矩阵的矩阵元，代表单个电子的动能和电子-核吸引能。矩阵 $G$ 代表一个电子所感受到的平均双电子势（库仑和交换）。其矩阵元 $G_{\\mu\\nu}$ 由密度矩阵 $P$ 和双电子排斥积分 (ERIs) $(\\mu\\nu|\\lambda\\sigma)$ 构建：\n$$ G_{\\mu\\nu} = \\sum_{\\lambda=0}^{n_{\\mathrm{bf}}-1} \\sum_{\\sigma=0}^{n_{\\mathrm{bf}}-1} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2} (\\mu\\lambda|\\nu\\sigma) \\right] $$\n项 $(\\mu\\nu|\\lambda\\sigma)$ 对应于库仑相互作用，而 $(\\mu\\lambda|\\nu\\sigma)$ 对应于交换相互作用。请注意 ERI 中化学家记法的索引。\n\nSCF 过程是一个迭代过程。从一个对密度矩阵的初始猜测开始，构建 Fock 矩阵，求解 Roothaan-Hall 方程以获得新的分子轨道系数，然后构建新的密度矩阵。重复此过程，直到密度矩阵或能量收敛。本问题要求进行一次这样的迭代。\n\n一次宏观迭代的具体步骤如下：\n1. **构建 Fock 矩阵**：给定初始密度矩阵 $P^{(0)}$，构建初始 Fock 矩阵 $F^{(0)}$。其矩阵元为：\n$$ F_{\\mu\\nu}^{(0)} = H_{\\mu\\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma}^{(0)} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right] $$\n在此步骤之前，必须使用指定的置换对称性规则 $(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda) = (\\lambda\\sigma|\\mu\\nu)$，从提供的唯一积分列表中构建完整的四索引 ERI 张量。\n\n2. **求解广义本征值问题**：求解 Roothaan-Hall 方程 $F^{(0)} C = S C \\varepsilon$。这将得到一组 $n_{\\mathrm{bf}}$ 个轨道能量（本征值 $\\varepsilon_{i}$）和相应的分子轨道系数向量（矩阵 $C$ 的列向量）。本征向量 $C$ 被归一化以满足 $C^T S C = I$。\n\n3. **更新密度矩阵**：将分子轨道按能量升序排列。能量最低的 $N_{\\mathrm{occ}}$ 个轨道是已占据轨道。新的密度矩阵 $P^{(1)}$ 由这些已占据轨道的系数构建：\n$$ P_{\\mu\\nu}^{(1)} = 2 \\sum_{i=1}^{N_{\\mathrm{occ}}} C_{\\mu i} C_{\\nu i} $$\n在矩阵代数中，如果 $C_{\\mathrm{occ}}$ 是一个包含 $C$ 的前 $N_{\\mathrm{occ}}$ 列的 $n_{\\mathrm{bf}} \\times N_{\\mathrm{occ}}$ 矩阵，则 $P^{(1)} = 2 C_{\\mathrm{occ}} C_{\\mathrm{occ}}^T$。\n\n4. **计算最终电子能量**：使用更新后的密度矩阵 $P^{(1)}$ 和由它构建的 Fock 矩阵 $F^{(1)}$ 计算一次迭代后的电子能量。电子能量的公式为：\n$$ E_{\\mathrm{elec}}^{(1)} = \\frac{1}{2} \\sum_{\\mu,\\nu} P_{\\mu\\nu}^{(1)} (H_{\\mu\\nu} + F_{\\mu\\nu}^{(1)}) $$\n其中 $F^{(1)}$ 的计算方式与 $F^{(0)}$ 相同，但使用 $P^{(1)}$：\n$$ F_{\\mu\\nu}^{(1)} = H_{\\mu\\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma}^{(1)} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right] $$\n此计算提供了一次 SCF 步骤后的电子能量，即为所要求的输出。核排斥能是一个常数偏移量，根据问题陈述予以忽略。该过程将对每个指定的测试用例进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the RHF-SCF single iteration.\n    \"\"\"\n    \n    # Case A: 2x2 system, 2 electrons, zero initial density\n    case_a = {\n        \"n_bf\": 2, \"n_elec\": 2,\n        \"S\": [[1.0, 0.2], [0.2, 1.0]],\n        \"H\": [[-1.0, -0.2], [-0.2, -0.8]],\n        \"P0\": [[0.0, 0.0], [0.0, 0.0]],\n        \"eris\": [\n            (0, 0, 0, 0, 0.70), (0, 0, 0, 1, 0.20), (0, 0, 1, 1, 0.60),\n            (0, 1, 0, 1, 0.30), (0, 1, 1, 1, 0.25), (1, 1, 1, 1, 0.675)\n        ]\n    }\n    \n    # Case B: 3x3 system, 4 electrons, non-trivial initial density\n    case_b = {\n        \"n_bf\": 3, \"n_elec\": 4,\n        \"S\": [[1.0, 0.1, 0.0], [0.1, 1.0, 0.2], [0.0, 0.2, 1.0]],\n        \"H\": [[-1.2, -0.1, 0.0], [-0.1, -0.9, -0.15], [0.0, -0.15, -0.5]],\n        \"P0\": [[1.8, 0.1, 0.05], [0.1, 1.2, 0.08], [0.05, 0.08, 0.0]],\n        \"eris\": [\n            (0, 0, 0, 0, 0.80), (0, 0, 0, 1, 0.15), (0, 0, 0, 2, 0.05),\n            (0, 0, 1, 1, 0.60), (0, 0, 1, 2, 0.07), (0, 0, 2, 2, 0.50),\n            (0, 1, 0, 1, 0.20), (0, 1, 0, 2, 0.06), (0, 1, 1, 2, 0.08),\n            (0, 1, 1, 1, 0.18), (0, 1, 2, 2, 0.12), (0, 2, 0, 2, 0.16),\n            (0, 2, 1, 2, 0.09), (0, 2, 2, 2, 0.14), (1, 1, 1, 1, 0.70),\n            (1, 1, 1, 2, 0.11), (1, 1, 2, 2, 0.55), (1, 2, 1, 2, 0.19),\n            (1, 2, 2, 2, 0.13), (2, 2, 2, 2, 0.65)\n        ]\n    }\n    \n    # Case C: 2x2 system with near-linear dependence, 2 electrons\n    case_c = {\n        \"n_bf\": 2, \"n_elec\": 2,\n        \"S\": [[1.0, 0.98], [0.98, 1.0]],\n        \"H\": [[-1.0, -0.9], [-0.9, -1.0]],\n        \"P0\": [[0.0, 0.0], [0.0, 0.0]],\n        \"eris\": [\n            (0, 0, 0, 0, 0.70), (0, 0, 0, 1, 0.25), (0, 0, 1, 1, 0.68),\n            (0, 1, 0, 1, 0.33), (0, 1, 1, 1, 0.28), (1, 1, 1, 1, 0.72)\n        ]\n    }\n    \n    test_cases = [case_a, case_b, case_c]\n    results = []\n\n    for case in test_cases:\n        energy = run_rhf_iteration(\n            case[\"n_bf\"], case[\"n_elec\"], case[\"S\"], case[\"H\"], case[\"P0\"], case[\"eris\"]\n        )\n        results.append(f\"{energy:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef run_rhf_iteration(n_bf, n_elec, S_list, H_list, P0_list, eris_list):\n    \"\"\"\n    Performs one macro-iteration of the RHF-SCF procedure for a given system.\n    \n    Args:\n        n_bf (int): Number of basis functions.\n        n_elec (int): Number of electrons.\n        S_list (list): Overlap matrix.\n        H_list (list): Core Hamiltonian matrix.\n        P0_list (list): Initial density matrix.\n        eris_list (list): List of unique ERIs.\n        \n    Returns:\n        float: The electronic energy after one iteration.\n    \"\"\"\n    \n    # --- Step 0: Setup ---\n    # Convert lists to NumPy arrays for matrix operations.\n    S = np.array(S_list)\n    H = np.array(H_list)\n    P0 = np.array(P0_list)\n    n_occ = n_elec // 2\n\n    # Reconstruct the full 4-index ERI tensor from the unique list\n    # using 8-fold permutational symmetry for real integrals.\n    g = np.zeros((n_bf, n_bf, n_bf, n_bf))\n    for mu, nu, lam, sig, val in eris_list:\n        g[mu, nu, lam, sig] = val\n        g[nu, mu, lam, sig] = val\n        g[mu, nu, sig, lam] = val\n        g[nu, mu, sig, lam] = val\n        g[lam, sig, mu, nu] = val\n        g[sig, lam, mu, nu] = val\n        g[lam, sig, nu, mu] = val\n        g[sig, lam, nu, mu] = val\n        \n    # --- Step 1: Form Fock Matrix F^(0) from P^(0) ---\n    # The two-electron contribution G is built using Einstein summation for efficiency.\n    # F_munu = H_munu + sum_ls P_ls * [ (mn|ls) - 0.5 * (ml|ns) ]\n    # J_munu = sum_ls P_ls * (mn|ls) --> einsum('ls,mnls->mn', P, g)\n    # K_munu = sum_ls P_ls * (ml|ns) --> einsum('ls,mlsn->mn', P, g)\n    J0 = np.einsum('ls,mnls->mn', P0, g, optimize=True)\n    K0 = np.einsum('ls,mlsn->mn', P0, g, optimize=True)\n    G0 = J0 - 0.5 * K0\n    F0 = H + G0\n    \n    # --- Step 2: Solve the generalized eigenvalue problem FC = SCe ---\n    # scipy.linalg.eigh solves the symmetric generalized eigenvalue problem.\n    # It returns eigenvalues sorted in ascending order and corresponding eigenvectors.\n    eps, C = eigh(F0, S)\n    \n    # --- Step 3: Build new density matrix P^(1) ---\n    # The columns of C are the MO coefficients. We take the first n_occ columns\n    # for the occupied orbitals.\n    C_occ = C[:, :n_occ]\n    # P_munu = 2 * sum_{i=occ} C_mui * C_nui\n    P1 = 2.0 * (C_occ @ C_occ.T)\n    \n    # --- Step 4: Compute final electronic energy ---\n    # First, form the updated Fock matrix F^(1) using the new density P^(1).\n    J1 = np.einsum('ls,mnls->mn', P1, g, optimize=True)\n    K1 = np.einsum('ls,mlsn->mn', P1, g, optimize=True)\n    G1 = J1 - 0.5 * K1\n    F1 = H + G1\n    \n    # Calculate the electronic energy using the updated matrices.\n    # E = 0.5 * Tr(P(H+F))\n    # This can be computed efficiently as the sum over the element-wise product.\n    energy = 0.5 * np.sum(P1 * (H + F1))\n    \n    return energy\n\nsolve()\n```", "id": "2923088"}, {"introduction": "基本的SCF迭代过程虽然原理清晰，但对于许多体系而言收敛缓慢甚至发散。本练习将向你介绍一种强大且广泛应用的收敛加速技术——迭代子空间直接求逆（DIIS）方法。通过实现一个DIIS步骤，你将学习如何利用先前迭代的误差信息（残差向量）来“智能”地外推出一个更优的Fock矩阵猜测值，从而更有效地引导计算趋向收敛解。[@problem_id:2923103]", "problem": "要求您实现迭代子空间直接求逆法 (DIIS) 的一个步骤，这是一种常用于量子化学自洽场程序中的收敛加速方法。DIIS 步骤应纯粹用线性代数术语来表述，从以下定义开始：给定一组残差矩阵 $\\{ \\mathbf{r}_i \\}_{i=1}^{m}$ 和相应的类算符矩阵 $\\{ \\mathbf{F}_i \\}_{i=1}^{m}$，确定系数 $\\mathbf{c} = (c_1, \\dots, c_m)^\\top$，使其在满足仿射约束的条件下，最小化残差组合的弗罗贝尼乌斯范数，\n$$\n\\min_{\\mathbf{c}} \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{m} c_i = 1.\n$$\n通过弗罗贝尼乌斯内积定义对称矩阵 $\\mathbf{B} \\in \\mathbb{R}^{m \\times m}$，\n$$\nB_{ij} = \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F = \\mathrm{tr}(\\mathbf{r}_i^\\top \\mathbf{r}_j).\n$$\n为解决潜在的病态问题，使用 Tikhonov 正则化矩阵 $\\mathbf{B}_\\delta = \\mathbf{B} + \\delta \\mathbf{I}$，其中 $\\delta \\ge 0$ 是一个小的标量。系数 $\\mathbf{c}$ 和拉格朗日乘子 $\\lambda$ 应通过求解强制执行仿射和约束的相关线性系统来获得。然后构成外推矩阵\n$$\n\\mathbf{F}_\\mathrm{DIIS} = \\sum_{i=1}^{m} c_i \\mathbf{F}_i.\n$$\n您的任务是编写一个完整的、可运行的程序，对于下面的每个测试用例，从提供的残差计算 $\\mathbf{B}$，应用指定的正则化 $\\delta$，在仿射约束下求解 $\\mathbf{c}$，构建 $\\mathbf{F}_\\mathrm{DIIS}$，并以行主序输出展平的 $\\mathbf{F}_\\mathrm{DIIS}$，每个条目四舍五入到 8 位小数。\n\n该程序必须处理三个独立的测试用例，每个用例包含 $m = 3$ 个先前的迭代和大小为 $2 \\times 2$ 的小型实数矩阵。对于每个用例，输入是列表 $\\{\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3\\}$ 和 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，以及标量 $\\delta$。使用弗罗贝尼乌斯内积构建 $\\mathbf{B}$，通过加上 $\\delta$ 对其对角线进行正则化，求解约束系统以获得 $\\mathbf{c}$，并形成最终的 $\\mathbf{F}_\\mathrm{DIIS}$。\n\n测试套件：\n- 用例 $1$（良态的残差几何）：\n  - $\\mathbf{F}_1 = \\begin{bmatrix} 1.0  0.2 \\\\ 0.2  0.9 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} 0.9  0.1 \\\\ 0.1  0.8 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} 0.85  0.05 \\\\ 0.05  0.75 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 0.05  -0.02 \\\\ -0.02  0.03 \\end{bmatrix}$, $\\mathbf{r}_2 = \\begin{bmatrix} 0.02  -0.01 \\\\ -0.01  0.015 \\end{bmatrix}$, $\\mathbf{r}_3 = \\begin{bmatrix} 0.01  -0.005 \\\\ -0.005  0.007 \\end{bmatrix}$。\n  - $\\delta = 10^{-10}$。\n- 用例 $2$（近似线性相关的残差）：\n  - $\\mathbf{F}_1 = \\begin{bmatrix} -0.5  0.0 \\\\ 0.0  -0.4 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} -0.45  0.0 \\\\ 0.0  -0.35 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} -0.425  0.0 \\\\ 0.0  -0.325 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 10^{-3}  2 \\cdot 10^{-3} \\\\ 2 \\cdot 10^{-3}  4 \\cdot 10^{-3} \\end{bmatrix}$, $\\mathbf{r}_2 = 2 \\mathbf{r}_1$, $\\mathbf{r}_3 = \\tfrac{1}{2} \\mathbf{r}_1$。\n  - $\\delta = 10^{-8}$。\n- 用例 $3$（趋于零的残差；边界行为）：\n  - $\\mathbf{F}_1 = \\begin{bmatrix} 0.3  -0.1 \\\\ -0.1  0.25 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} 0.28  -0.08 \\\\ -0.08  0.22 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} 0.27  -0.07 \\\\ -0.07  0.21 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$, $\\mathbf{r}_2 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$, $\\mathbf{r}_3 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$。\n  - $\\delta = 10^{-6}$。\n\n数值和格式要求：\n- 全程使用实数算术。\n- 用条目 $B_{ij} = \\sum_{a,b} r_i(a,b) \\, r_j(a,b)$ 构建 $\\mathbf{B}$。\n- 在求解 $\\mathbf{c}$ 的约束线性系统之前，将 $\\delta$ 加到 $\\mathbf{B}$ 的对角线上。\n- 计算 $\\mathbf{F}_{\\text{DIIS}} = \\sum_{i=1}^{3} c_i \\mathbf{F}_i$。\n- 对于每个测试用例，输出 $\\mathbf{F}_\\mathrm{DIIS}$ 条目的展平行主序列表，每个条目四舍五入到 8 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个展平列表的结果，以逗号分隔，并用一对单独的方括号括起来。例如，包含三个结果的输出应如下所示：$[\\,[x_{11}, x_{12}, x_{21}, x_{22}],\\,[y_{11}, y_{12}, y_{21}, y_{22}],\\,[z_{11}, z_{12}, z_{21}, z_{22}]\\,]$，其中每个 $x_{ij}$、$y_{ij}$ 和 $z_{ij}$ 都是四舍五入到 8 位小数的浮点数。", "solution": "问题陈述是在线性代数和数值优化方面一个有效且适定的练习，要求实现迭代子空间直接求逆法 (DIIS) 程序的一个步骤。该方法是加速量子化学中自洽场计算收敛的基石。该问题有科学依据，有形式化的规定，并包含唯一解所需的所有数据。我们将进行形式推导和实现。\n\nDIIS 方法的核心是找到先前类 Fock 矩阵 $\\mathbf{F}_i$ 的一个线性组合，该组合最小化相应残差矩阵 $\\mathbf{r}_i$ 线性组合的范数。此组合的系数总和必须为 1，以确保如果所有先前的迭代都是解，则新的迭代也将是解。这被表述为一个约束优化问题。\n\n设 $\\{\\mathbf{r}_i\\}_{i=1}^m$ 为一组 $m$ 个残差矩阵，$\\{\\mathbf{F}_i\\}_{i=1}^m$ 为相应的类算符矩阵集合。我们寻求一个系数向量 $\\mathbf{c} = (c_1, \\dots, c_m)^\\top$ 来求解：\n$$\n\\min_{\\mathbf{c}} \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{m} c_i = 1\n$$\n目标函数是残差线性组合的弗罗贝尼乌斯范数的平方。我们可以使用弗罗贝尼乌斯内积的定义 $\\langle \\mathbf{A}, \\mathbf{B} \\rangle_F = \\mathrm{tr}(\\mathbf{A}^\\top \\mathbf{B})$ 来展开此项。对于实数矩阵，这等价于元素乘积之和。\n$$\nJ(\\mathbf{c}) = \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 = \\left\\langle \\sum_{i=1}^{m} c_i \\mathbf{r}_i, \\sum_{j=1}^{m} c_j \\mathbf{r}_j \\right\\rangle_F = \\sum_{i=1}^{m} \\sum_{j=1}^{m} c_i c_j \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F\n$$\n我们定义一个对称矩阵 $\\mathbf{B} \\in \\mathbb{R}^{m \\times m}$，其元素是残差矩阵的内积：\n$$\nB_{ij} = \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F\n$$\n根据这个定义，目标函数变为关于 $\\mathbf{c}$ 的二次型：\n$$\nJ(\\mathbf{c}) = \\mathbf{c}^\\top \\mathbf{B} \\mathbf{c}\n$$\n约束是线性的：$\\sum_{i=1}^{m} c_i = 1$，可以写成向量形式 $\\mathbf{1}^\\top \\mathbf{c} = 1$，其中 $\\mathbf{1}$ 是一个包含 $m$ 个 1 的列向量。\n\n问题陈述指出，为了处理残差向量之间潜在的线性相关性（这会使 $\\mathbf{B}$ 奇异），我们必须使用 Tikhonov 正则化。这涉及将 $\\mathbf{B}$ 替换为正则化矩阵 $\\mathbf{B}_\\delta$：\n$$\n\\mathbf{B}_\\delta = \\mathbf{B} + \\delta \\mathbf{I}\n$$\n其中 $\\delta \\ge 0$ 是一个小标量，$\\mathbf{I}$ 是 $m \\times m$ 的单位矩阵。优化问题现在是在 $\\mathbf{1}^\\top \\mathbf{c} = 1$ 的约束下最小化 $\\mathbf{c}^\\top \\mathbf{B}_\\delta \\mathbf{c}$。\n\n我们使用拉格朗日乘子法来解决这个问题。该问题的拉格朗日函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(\\mathbf{c}, \\lambda) = \\mathbf{c}^\\top \\mathbf{B}_\\delta \\mathbf{c} - 2\\lambda \\left( \\mathbf{1}^\\top \\mathbf{c} - 1 \\right)\n$$\n其中 $2\\lambda$ 是拉格朗日乘子（因子 2 是为了代数上的方便）。为了找到最小值，我们将 $\\mathcal{L}$ 对 $\\mathbf{c}$ 的梯度和对 $\\lambda$ 的偏导数设为零。\n$$\n\\nabla_{\\mathbf{c}} \\mathcal{L} = 2 \\mathbf{B}_\\delta \\mathbf{c} - 2\\lambda \\mathbf{1} = \\mathbf{0} \\quad \\implies \\quad \\mathbf{B}_\\delta \\mathbf{c} - \\lambda \\mathbf{1} = \\mathbf{0}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = -2 \\left( \\mathbf{1}^\\top \\mathbf{c} - 1 \\right) = 0 \\quad \\implies \\quad \\mathbf{1}^\\top \\mathbf{c} = 1\n$$\n这两个方程构成了一个包含 $m$ 个系数 $c_i$ 和乘子 $\\lambda$ 的 $m+1$ 个线性方程组。我们可以用分块矩阵形式表示该系统：\n$$\n\\begin{pmatrix}\n\\mathbf{B}_\\delta  -\\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{c} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n1\n\\end{pmatrix}\n$$\n其中 $\\mathbf{0}$ 是大小为 $m$ 的零向量。对于问题中给出的特定情况，$m=3$，这是一个 $4 \\times 4$ 的线性系统。只要 $\\mathbf{B}_\\delta$ 是正定的，左侧的矩阵就是可逆的，如果原始残差向量不全为零，则通过 $\\delta > 0$ 可以保证这一点。\n\n计算步骤如下：\n1.  给定残差矩阵 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，构建 $3 \\times 3$ 矩阵 $\\mathbf{B}$，其中 $B_{ij} = \\sum_{k,l} (\\mathbf{r}_i)_{kl} (\\mathbf{r}_j)_{kl}$。\n2.  给定正则化参数 $\\delta$，构成 $\\mathbf{B}_\\delta = \\mathbf{B} + \\delta\\mathbf{I}$。\n3.  构建 $4 \\times 4$ 增广矩阵 $\\mathbf{A}_{\\text{aug}} = \\begin{pmatrix} \\mathbf{B}_\\delta  -\\mathbf{1} \\\\ \\mathbf{1}^\\top  0 \\end{pmatrix}$ 和右侧向量 $\\mathbf{b}_{\\text{aug}} = (0, 0, 0, 1)^\\top$。\n4.  求解线性系统 $\\mathbf{A}_{\\text{aug}} \\mathbf{x} = \\mathbf{b}_{\\text{aug}}$ 以找到解向量 $\\mathbf{x} = (c_1, c_2, c_3, \\lambda)^\\top$。\n5.  提取系数 $\\mathbf{c} = (c_1, c_2, c_3)^\\top$。\n6.  使用矩阵 $\\{\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3\\}$ 计算外推矩阵 $\\mathbf{F}_{\\text{DIIS}}$：\n$$\n\\mathbf{F}_{\\text{DIIS}} = \\sum_{i=1}^3 c_i \\mathbf{F}_i\n$$\n此过程将应用于提供的三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef perform_diis_step(F_matrices, r_matrices, delta):\n    \"\"\"\n    Performs a single step of the DIIS procedure.\n\n    Args:\n        F_matrices (list of np.ndarray): List of operator-like matrices {F_i}.\n        r_matrices (list of np.ndarray): List of residual matrices {r_i}.\n        delta (float): Tikhonov regularization parameter.\n\n    Returns:\n        np.ndarray: The extrapolated matrix F_DIIS.\n    \"\"\"\n    m = len(r_matrices)\n    if m == 0:\n        return np.zeros_like(F_matrices[0]) if F_matrices else np.array([])\n\n    # 1. Construct the B matrix using Frobenius inner products\n    B = np.zeros((m, m))\n    for i in range(m):\n        for j in range(i, m):\n            val = np.sum(r_matrices[i] * r_matrices[j])\n            B[i, j] = val\n            B[j, i] = val\n\n    # 2. Apply Tikhonov regularization\n    B_reg = B + delta * np.identity(m)\n    \n    # 3. Build the augmented linear system\n    # [ B_reg  -1 ] [ c ] = [ 0 ]\n    # [ 1^T     0 ] [ l ]   [ 1 ]\n    aug_A = np.zeros((m + 1, m + 1))\n    aug_A[:m, :m] = B_reg\n    aug_A[:m, m] = -1.0\n    aug_A[m, :m] = 1.0\n\n    aug_b = np.zeros(m + 1)\n    aug_b[m] = 1.0\n    \n    # 4. Solve for coefficients c and Lagrange multiplier\n    try:\n        x = np.linalg.solve(aug_A, aug_b)\n    except np.linalg.LinAlgError:\n        # Fallback for singular matrix (e.g., all residuals are zero)\n        # Return the most recent Fock matrix\n        return F_matrices[-1]\n\n    c = x[:m]\n    \n    # 5. Compute the extrapolated matrix F_DIIS\n    F_diis = np.zeros_like(F_matrices[0], dtype=float)\n    for i in range(m):\n        F_diis += c[i] * F_matrices[i]\n        \n    return F_diis\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the DIIS step calculation.\n    \"\"\"\n    \n    # Test Case 1\n    case1 = {\n        'F_matrices': [\n            np.array([[1.0, 0.2], [0.2, 0.9]]),\n            np.array([[0.9, 0.1], [0.1, 0.8]]),\n            np.array([[0.85, 0.05], [0.05, 0.75]])\n        ],\n        'r_matrices': [\n            np.array([[0.05, -0.02], [-0.02, 0.03]]),\n            np.array([[0.02, -0.01], [-0.01, 0.015]]),\n            np.array([[0.01, -0.005], [-0.005, 0.007]])\n        ],\n        'delta': 1e-10\n    }\n    \n    # Test Case 2\n    r1_case2 = np.array([[1e-3, 2e-3], [2e-3, 4e-3]])\n    case2 = {\n        'F_matrices': [\n            np.array([[-0.5, 0.0], [0.0, -0.4]]),\n            np.array([[-0.45, 0.0], [0.0, -0.35]]),\n            np.array([[-0.425, 0.0], [0.0, -0.325]])\n        ],\n        'r_matrices': [\n            r1_case2,\n            2 * r1_case2,\n            0.5 * r1_case2\n        ],\n        'delta': 1e-8\n    }\n    \n    # Test Case 3\n    case3 = {\n        'F_matrices': [\n            np.array([[0.3, -0.1], [-0.1, 0.25]]),\n            np.array([[0.28, -0.08], [-0.08, 0.22]]),\n            np.array([[0.27, -0.07], [-0.07, 0.21]])\n        ],\n        'r_matrices': [\n            np.array([[0.0, 0.0], [0.0, 0.0]]),\n            np.array([[0.0, 0.0], [0.0, 0.0]]),\n            np.array([[0.0, 0.0], [0.0, 0.0]])\n        ],\n        'delta': 1e-6\n    }\n    \n    test_cases = [case1, case2, case3]\n    all_results = []\n\n    for case in test_cases:\n        F_diis = perform_diis_step(case['F_matrices'], case['r_matrices'], case['delta'])\n        \n        # Flatten in row-major order and format\n        flat_result = [f\"{val:.8f}\" for val in F_diis.flatten('C')]\n        all_results.append(f\"[{','.join(flat_result)}]\")\n        \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2923103"}, {"introduction": "在现实世界的量子化学研究中，我们常常会遇到“困难”体系，例如键长被拉伸的分子，此时简单的SCF程序往往会失效。最后的这个练习将你的角色从一个算法的实现者提升为一名策略的设计者。它挑战你为这类困难体系设计一个稳健的混合计算方案，要求你基于对不同方法（如EDIIS与DIIS）和稳定化技术（如能级移动）优缺点的深刻理解，做出明智的策略选择，从而成功地在具有挑战性的势能面上完成计算。[@problem_id:2923073]", "problem": "对于一个处于拉伸构型的闭壳层双原子分子，进行限制性Hartree–Fock (RHF) 自洽场 (SCF) 计算是公认的挑战，因为存在近简并以及很小的高占据分子轨道-低未占分子轨道 (HOMO–LUMO) 能隙。考虑在一个极化双$\\zeta$基组中，对一个核间距为其平衡键长$2.5$倍的同核双原子分子进行RHF SCF计算。您需要选择一个合适的能量直接迭代子空间反演 (Energy-DIIS, EDIIS) 到直接迭代子空间反演 (DIIS) 的混合方案，该方案需指定切换阈值，并从第一性原理出发证明其选择的合理性。\n\n使用以下基本依据：\n- Hartree–Fock能量泛函 $E[P]$ 在满足Roothaan–Hall方程的驻点密度矩阵 $P$ 处达到最小值；在驻点处，对易子在标准正交度规下为零，等价地，广义残差 $R = F[P] \\, P \\, S - S \\, P \\, F[P]$ 的范数很小，其中 $F[P]$ 是Fock矩阵，$S$ 是重叠矩阵。\n- 变分原理表明，在SCF过程中，如果代理能量模型在局部有效，那么对先前收敛或部分收敛的密度矩阵进行系数非负且和为 $1$ 的凸组合，将产生一个能量非增的序列；能量-DIIS (EDIIS) 实现了这一思想，并且在远离解时具有鲁棒性。\n- DIIS方法通过构建一个基于在线性区域内准确的线性模型的外插Fock或误差向量，来加速接近解时的收敛；当误差向量近似仿射相关且步长不破坏变分结构时，该方法是有效的。\n- 连续迭代之间的均方根 (RMS) 密度变化，记为 $\\Delta_{\\mathrm{RMS}}(P^{(k)},P^{(k-1)})$，以及Pulay残差的范数 $\\lVert R^{(k)} \\rVert$，提供了与驻点接近程度的尺度感知指标；总能量变化 $\\Delta E^{(k)} = E^{(k)} - E^{(k-1)}$ 用于判断单调性和曲率稳定性。\n- 能级移动是一种针对拉伸键的标准稳定化策略，通过在Fock矩阵的虚-虚块上增加一个正常数 $\\lambda$ 来抑制HOMO-LUMO能隙较小时不稳定的轨道旋转；过大的移动会扭曲能量形貌，而过小的移动则无效。\n\n为拉伸键SCF的启动选择最合适的混合方案。每个选项都指定了：初始策略、稳定化方法、切换标准和后期加速方法。选择一个能最好地被变分原理和不动点线性化所证明，并且其使用的阈值与进入局部线性区域一致而又不过度约束切换的选项。\n\nA. 从EDIIS开始，使用大小最大为 $m = 6$ 的凸子空间，密度更新采用 $0.3$ 的中等阻尼因子，并对虚空间施加 $\\lambda = 0.5 \\ \\text{hartree}$ 的能级移动。在此阶段要求能量单调递减。当以下所有条件连续 $3$ 次迭代都满足时切换到DIIS：$\\lVert R \\rVert_{\\mathrm{F}}  10^{-2}$，$\\Delta_{\\mathrm{RMS}}  10^{-3}$，以及 $|\\Delta E|  10^{-4} \\ \\text{hartree}$。切换后，在接下来的 $5$ 次DIIS迭代中将能级移动线性地降至 $\\lambda = 0$，并使用大小为 $m = 8$ 的DIIS子空间，不再使用阻尼。\n\nB. 直接从DIIS开始，使用一个大的子空间 $m = 12$，不使用阻尼或能级移动。如果能量在连续 $2$ 次迭代中增加，则临时启用EDIIS进行 $1$ 次迭代，然后返回DIIS。维持此模式直至收敛。\n\nC. 从EDIIS开始，使用 $0.2$ 的重阻尼和一个大的能级移动 $\\lambda = 3.0 \\ \\text{hartree}$。仅当 $\\lVert R \\rVert_{\\mathrm{F}}  10^{-6}$，$\\Delta_{\\mathrm{RMS}}  10^{-8}$，以及 $|\\Delta E|  10^{-8} \\ \\text{hartree}$ 在 $1$ 次迭代中满足时才切换到DIIS。使用一个小的DIIS子空间 $m = 2$，此后保持能级移动不变。\n\nD. 从EDIIS开始，使用 $\\lambda = 1.0 \\ \\text{hartree}$ 的能级移动。当 $\\lVert R \\rVert_{\\mathrm{F}}  10^{-1}$ 或 $2$ 次迭代之后（以先发生者为准）切换到DIIS。在两个阶段均不强制要求能量单调性。保持能级移动固定，并使用激进的DIIS，参数为 $m = 10$ 且无阻尼。\n\n哪个选项最合适？请给出您的选择。只有一个选项能最好地被所述原理和针对拉伸键SCF的实际阈值设定所支持。", "solution": "该问题要求为在拉伸核间距下的同核双原子分子的限制性Hartree–Fock (RHF) 计算，选择最合适的混合自洽场 (SCF) 收敛方案。这种情况在计算上是具有挑战性的，因为最高占据分子轨道 (HOMO) 和最低未占分子轨道 (LUMO) 存在近简并，导致能隙很小。一个成功的方案必须在计算的初始阶段具有鲁棒性，在最后阶段具有高效率，同时能恰当地管理稳定化技术。评估将基于所提供的第一性原理，包括能量直接迭代子空间反演 (EDIIS) 和直接迭代子空间反演 (DIIS) 的不同作用和适用范围、能级移动的功能以及各种收敛指标的含义。\n\n让我们系统地分析每个选项。\n\n**选项A：** 该方案指定从EDIIS开始，采用适度的能级移动和阻尼，基于物理意义明确的阈值切换到DIIS，然后移除能级移动以收敛到真解。\n*   **初始策略：** 计算从EDIIS开始。根据所提供的原理，EDIIS在远离解时具有鲁棒性，因为它利用变分原理，通过构造密度矩阵的凸组合来保证或促进能量序列非增。对于像拉伸键这样的困难情况，这是正确的初始选择，以确保稳定地向最小值的普适邻域前进。\n*   **稳定化：** 施加了 $\\lambda = 0.5 \\ \\text{hartree}$ 的能级移动。对于具有小HOMO–LUMO能隙的体系，这是一种至关重要的稳定化技术。通过向Fock矩阵的虚-虚块的对角元素添加一个正常数，它有效地增大了能隙，从而抑制了近简并的占据轨道和虚轨道之间原本不稳定的旋转。$0.5 \\ \\text{hartree}$ 的值是一个适中且合理的选择。密度更新采用 $0.3$ 的阻尼因子提供了额外的稳定性。\n*   **切换标准：** 当 $\\lVert R \\rVert_{\\mathrm{F}}  10^{-2}$，$\\Delta_{\\mathrm{RMS}}  10^{-3}$，以及 $|\\Delta E|  10^{-4} \\ \\text{hartree}$ 连续 $3$ 次迭代都满足时，切换到DIIS。Pulay残差的范数 $\\lVert R \\rVert_{\\mathrm{F}}$ 直接度量了Fock矩阵和密度矩阵的非对易性，从而反映了与驻点的接近程度。$10^{-2}$ 的阈值是进入DIIS生效的局部线性区域的一个标准且合理的数值。关于密度矩阵和能量变化的条件为稳定性提供了进一步的确认。要求条件保持 $3$ 次迭代是一个防止过早切换的可靠启发式方法。\n*   **后期加速：** 切换后，该方案将能级移动 $\\lambda$ 线性地降至 $0$。这一点至关重要。能级移动是对问题的一个临时修改。为了收敛到*原始*Hartree–Fock能量泛函的驻点，一旦达到稳定，就必须移除此微扰。使用大小为 $m=8$ 的DIIS子空间对于有效加速是合理的。\n*   **结论：** 该方案是全面、论证充分且科学合理的。它在适当的区域正确地应用了正确的方法 (EDIIS, DIIS)，并正确地使用了稳定化技术（能级移动），包括其必要的移除。\n\n**选项B：** 该方案建议直接从DIIS开始，仅在失败时使用EDIIS作为临时的“救援”机制。\n*   **初始策略：** 对于此问题，从DIIS开始是一个糟糕的选择。DIIS假设误差可以通过线性外插来最小化，这个条件仅在接近解时才成立。在拉伸键计算的初始、高度非线性的阶段，DIIS倾向于采取大的、不稳定的步骤，可能导致能量增加、振荡或完全发散。\n*   **稳定化：** 该方案忽略了能级移动和阻尼。这是一个关键的失败。对于一个具有小HOMO-LUMO能隙的体系，没有稳定化措施的收敛是极不可能的。\n*   **控制逻辑：** 仅在DIIS连续两次迭代失败后才使用一个EDIIS步骤的反应式方法不是一个鲁棒的策略。这表明其初始选择存在根本性缺陷，然后又以低效的方式进行修补。\n*   **结论：** 此方案不适用于该问题。它错误地应用了DIIS方法，并忽略了必要的稳定化技术。\n\n**选项C：** 该方案从一个高度稳定化的EDIIS开始，并使用极其严格的切换标准。\n*   **稳定化：** 它提议使用“$0.2$的重阻尼”和“$\\lambda = 3.0 \\ \\text{hartree}$的大能级移动”。虽然这肯定会稳定计算，但这很可能是过度的。如此大的能级移动会严重扭曲能量形貌，而重阻尼会使进展极其缓慢。\n*   **切换标准：** 切换到DIIS的条件被设定为 $\\lVert R \\rVert_{\\mathrm{F}}  10^{-6}$，$\\Delta_{\\mathrm{RMS}}  10^{-8}$，以及 $|\\Delta E|  10^{-8} \\ \\text{hartree}$。这些是典型的最终收敛值，而不是从全局方法切换到局部方法的标准。DIIS的全部目的是加速从中间点（例如 $\\lVert R \\rVert_{\\mathrm{F}} \\sim 10^{-2}$）到最终解的收敛。等到计算几乎收敛时，切换到DIIS变得毫无意义，整个过程极其低效。\n*   **后期加速：** 使用小的DIIS子空间 $m = 2$ 限制了该方法的有效性。至关重要的是，该方案指定保持能级移动不变。这是一个根本性错误。在非零能级移动下收敛意味着最终结果是一个修正后哈密顿量的驻点，而不是真正的Hartree–Fock解。\n*   **结论：** 该方案不仅效率极低，而且在概念上是错误的，因为它会收敛到一个错误的答案。\n\n**选项D：** 该方案建议非常快速地切换到DIIS，同时保持能级移动。\n*   **切换标准：** “在 $2$ 次迭代之后切换，以先发生者为准”的标准是轻率和武断的。对于一个困难的问题，SCF几乎不可能在仅仅2步之后就进入局部线性区域。这会触发过早地切换到一个激进的DIIS方法，而该方法很可能会失败。\n*   **控制逻辑：** “在两个阶段均不强制要求能量单调性”的指令是有问题的。虽然DIIS本身不保证单调性，但EDIIS的变分性质是其关键优势。在初始阶段不利用这一点是一个糟糕的策略。\n*   **后期加速：** 与选项C一样，保持能级移动固定（$\\lambda = 1.0 \\ \\text{hartree}$）是一个致命缺陷。该方法将收敛到一个微扰问题的解，这是不正确的。\n*   **结论：** 该方案因其危险的切换启发式方法以及未能通过移除能级移动来收敛到正确的物理解决方案而存在缺陷。\n\n**最终裁定：**\n基于对所提供第一性原理的严格分析，选项A是唯一代表了物理上和数值上都合理的策略。它正确地平衡了鲁棒性（从EDIIS开始）、稳定化（适度的能级移动）和效率（DIIS加速），同时通过移除人为的稳定化措施以收敛到真正的RHF解来确保正确性。其他选项包含根本性的概念错误，例如在其有效范围之外应用方法、使用无意义的参数或收敛到不正确的解。\n\n因此，选项A是最合适的选择。", "answer": "$$\\boxed{A}$$", "id": "2923073"}]}