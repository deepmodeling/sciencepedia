{"hands_on_practices": [{"introduction": "在深入探讨转动配分函数本身之前，我们首先需要掌握一个核心参数：特征转动温度 $\\Theta_{rot}$。这个温度标志着从低温量子行为到高温经典行为的过渡，其数值直接决定了在给定温度 $T$ 下有多少转动能级被显著占据。这项练习将引导你从最基本的分子性质（原子质量和键长）出发，亲手计算一个分子的 $\\Theta_{rot}$，从而将微观的分子结构与宏观的统计热力学行为联系起来。", "problem": "在星际分子云的研究中，一氧化碳 (CO) 是一种关键的示踪分子，用于描绘这些广阔区域的结构和动力学。为了精确地建模低温下一氧化碳气体的热学性质，必须首先确定其特征转动温度 $\\Theta_{rot}$。这个温度定义了分子转动能级开始被显著布居的温标。\n\n考虑一个单个、孤立的一氧化碳分子，具体来说是最常见的同位素体 $^{12}$C$^{16}$O。在本次计算中，将此分子视为刚性转子。\n\n已知以下数据：\n- 分子的平衡键长，$r = 1.128 \\times 10^{-10}$ m。\n- 碳-12原子的质量，$m_C = 1.993 \\times 10^{-26}$ kg。\n- 氧-16原子的质量，$m_O = 2.657 \\times 10^{-26}$ kg。\n- 约化普朗克常数，$\\hbar = 1.055 \\times 10^{-34}$ J$\\cdot$s。\n- 玻尔兹曼常数，$k_B = 1.381 \\times 10^{-23}$ J/K。\n\n计算此CO分子的特征转动温度 $\\Theta_{rot}$。结果以开尔文 (K) 为单位，并四舍五入到三位有效数字。", "solution": "对于线性刚性转子，其转动能级为 $E_{J} = \\frac{\\hbar^{2}}{2I}J(J+1)$，因此特征转动温度由 $E_{J} = k_{B}\\Theta_{rot}J(J+1)$ 定义，可得\n$$\n\\Theta_{rot} = \\frac{\\hbar^{2}}{2 I k_{B}}.\n$$\n对于视为刚性转子的双原子分子，其转动惯量为 $I = \\mu r^{2}$，其中约化质量 $\\mu = \\frac{m_{C} m_{O}}{m_{C} + m_{O}}$。使用给定数据，\n$$\n\\mu = \\frac{(1.993 \\times 10^{-26})(2.657 \\times 10^{-26})}{(1.993 \\times 10^{-26}) + (2.657 \\times 10^{-26})}\n= \\frac{5.295401 \\times 10^{-52}}{4.650 \\times 10^{-26}}\n= 1.13880731 \\times 10^{-26}\\ \\text{kg}.\n$$\n于是\n$$\nI = \\mu r^{2} = (1.13880731 \\times 10^{-26})(1.128 \\times 10^{-10})^{2}\n= (1.13880731 \\times 1.272384) \\times 10^{-46}\n= 1.44900020 \\times 10^{-46}\\ \\text{kg}\\,\\text{m}^{2}.\n$$\n代入 $\\Theta_{rot}$ 的表达式中：\n$$\n\\Theta_{rot} = \\frac{(1.055 \\times 10^{-34})^{2}}{2 \\cdot (1.44900020 \\times 10^{-46}) \\cdot (1.381 \\times 10^{-23})}.\n$$\n计算分子和分母：\n$$\n\\hbar^{2} = 1.113025 \\times 10^{-68}, \\quad\n2 I k_{B} = (2.89800040 \\times 10^{-46})(1.381 \\times 10^{-23}) = 4.00213855 \\times 10^{-69}.\n$$\n因此，\n$$\n\\Theta_{rot} = \\frac{1.113025 \\times 10^{-68}}{4.00213855 \\times 10^{-69}} = \\frac{1.113025}{4.00213855} \\times 10 \\approx 2.781.\n$$\n四舍五入到三位有效数字，特征转动温度为 $2.78$ K。", "answer": "$$\\boxed{2.78}$$", "id": "1991123"}, {"introduction": "理解了 $\\Theta_{rot}$ 之后，我们便可以在高温极限下（$T \\gg \\Theta_{rot}$）使用一个简洁的近似公式来计算转动配分函数。然而，当分子包含相同原子核时，必须考虑一个源于量子力学全同性原理的关键修正，即对称数 $\\sigma$。这个练习通过对比异核分子CO ($\\sigma=1$) 和同核分子N$_2$ ($\\sigma=2$)，让你清晰地看到分子对称性如何影响有效的转动能态密度，并最终改变其配分函数的大小。[@problem_id:1991137]", "problem": "考虑两种双原子气体，一氧化碳 (CO) 和氮气 ($^{14}$N$_2$)，它们都处于高温 $T$ 下。在此温度下，对离散转动能级的求和可以很好地近似为一个积分。\n\n一氧化碳的转动常数由 $B_{\\text{CO}} = 1.931 \\text{ cm}^{-1}$ 给出。\n由氮-14同位素组成的双氮分子的转动常数由 $B_{^{14}\\text{N}_2} = 1.998 \\text{ cm}^{-1}$ 给出。\n\n计算单个 $^{14}$N$_2$ 分子的转动配分函数与单个 CO 分子的转动配分函数之比，即 $\\frac{Z_{\\text{rot}}(^{14}\\text{N}_2)}{Z_{\\text{rot}}(\\text{CO})}$。\n\n将您的答案以无量纲数的形式给出，并四舍五入到三位有效数字。", "solution": "对于线性刚性转子，转动能级为 $E_{J} = h c B J(J+1)$，带有对称数 $\\sigma$ 的转动配分函数为\n$$\nZ_{\\text{rot}} = \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} (2J+1) \\exp\\!\\left(-\\frac{h c B}{k_{B} T} J(J+1)\\right).\n$$\n在高温下，用积分代替求和：\n$$\nZ_{\\text{rot}} \\approx \\frac{1}{\\sigma} \\int_{0}^{\\infty} (2J+1) \\exp\\!\\left(-x J(J+1)\\right) \\, dJ,\n$$\n其中 $x = \\frac{h c B}{k_{B} T}$。使用换元法，$u = J(J+1)$，因此 $du = (2J+1)\\, dJ$，积分上下限从 $u=0$ 映至 $u\\to\\infty$，得到\n$$\nZ_{\\text{rot}} \\approx \\frac{1}{\\sigma} \\int_{0}^{\\infty} \\exp(-x u)\\, du = \\frac{1}{\\sigma} \\frac{1}{x} = \\frac{k_{B} T}{\\sigma h c B}.\n$$\n因此，该比值为\n$$\n\\frac{Z_{\\text{rot}}(^{14}\\text{N}_{2})}{Z_{\\text{rot}}(\\text{CO})} = \\frac{\\frac{k_{B} T}{\\sigma_{^{14}\\text{N}_{2}} h c B_{^{14}\\text{N}_{2}}}}{\\frac{k_{B} T}{\\sigma_{\\text{CO}} h c B_{\\text{CO}}}} = \\frac{\\sigma_{\\text{CO}}}{\\sigma_{^{14}\\text{N}_{2}}} \\frac{B_{\\text{CO}}}{B_{^{14}\\text{N}_{2}}}.\n$$\n对于同核分子 $^{14}\\text{N}_{2}$，$\\sigma_{^{14}\\text{N}_{2}}=2$；对于异核分子 CO，$\\sigma_{\\text{CO}}=1$。使用给定的 $B$ 值（单位相同，因此在比值中可以消去），\n$$\n\\frac{Z_{\\text{rot}}(^{14}\\text{N}_{2})}{Z_{\\text{rot}}(\\text{CO})} = \\frac{1}{2} \\frac{1.931}{1.998} \\approx \\frac{1}{2} \\times 0.966467 \\approx 0.483.\n$$\n四舍五入到三位有效数字，比值为 $0.483$。", "answer": "$$\\boxed{0.483}$$", "id": "1991137"}, {"introduction": "尽管高温近似等解析公式在理论分析中非常有用，但它们的适用范围是有限的。为了精确评估这些近似的准确性，或处理近似失效的低温情况，我们必须掌握直接通过数值求和计算配分函数的“精确”方法。这项高级实践要求你编写程序，实现转动配分函数的精确数值求和，并将其与经典的解析近似公式进行直接比较。[@problem_id:2821764] 通过完成这项任务，你将对近似方法的有效边界以及保证数值计算收敛性的策略有更深刻和实际的理解。", "problem": "要求您设计一个程序，使用数值求和与渐近近似的方法，计算并分析气相线性刚性转子的转动配分函数。您的实现必须仅依赖于统计力学的基本定义和经过充分检验的光谱学事实。\n\n您必须使用的基本依据是：\n- 正则（构型）配分函数的定义：对于一组具有简并度 $\\{g_i\\}$ 的分立能级 $\\{E_i\\}$，单分子配分函数为 $q = \\sum_i g_i \\exp(-\\beta E_i)$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$T$ 是以开尔文为单位的绝对温度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n- 对于转动惯量为 $I$ 的线性刚性转子，其量子转动能级为 $E_J = \\dfrac{\\hbar^2}{2 I} J (J+1)$，其中 $J$ 为非负整数，简并度为 $g_J = 2J+1$。等效地，使用以反厘米为单位的光谱学转动常数 $\\tilde{B}$，能级可表示为 $E_J = h c \\tilde{B} J(J+1)$，其中 $h$ 是普朗克常数，$c$ 是光速。定义转动温度 $\\theta_{\\mathrm{rot}} = \\dfrac{h c \\tilde{B}}{k_{\\mathrm{B}}}$，则玻尔兹曼因子为 $\\exp\\!\\big(-\\theta_{\\mathrm{rot}} J(J+1)/T\\big)$。\n- 对于同核线性转子，需引入对称数 $\\sigma$（一个整数，例如，对于两端不可区分的双原子分子，$\\sigma = 2$），即需将转动配分函数除以 $\\sigma$。\n\n任务要求：\n1) 为线性刚性转子的单分子转动配分函数实现一个自适应数值求和方法，\n$$\nq_{\\mathrm{rot}}(T,\\tilde{B},\\sigma) \\;=\\; \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} (2J+1)\\, \\exp\\!\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right),\n$$\n通过在某个依赖于数据的最大值 $J_{\\max}$ 处截断求和来确保收敛。使用以下停止判据：设 $S_N$ 是截至 $J=N$ 的当前部分和，$t_{N+1}=(2(N+1)+1)\\exp\\!\\left[-(\\theta_{\\mathrm{rot}}/T)(N+1)(N+2)\\right]$ 是下一项；当 $t_{N+1}/S_N < \\varepsilon$ 时停止，其中容差 $\\varepsilon = 10^{-12}$。为确保鲁棒性，强制设置一个硬性上限 $J_{\\max}^{\\mathrm{cap}} = 10^6$，如果达到此上限仍未滿足容差要求，则停止计算并使用达到上限时的部分和。返回的 $q_{\\mathrm{rot}}$ 必须是无量纲的，并且您还必须报告所使用的实际终端 $J_{\\max}$ 值（一个整数）。\n\n2) 通过将对 $J$ 的求和替换为对一个连续变量的积分，推导并实现领头的经典高温近似，从而得到以 $T$、$\\tilde{B}$ 和 $\\sigma$ 表示的领头阶表达式 $q_{\\mathrm{cl,lead}}(T,\\tilde{B},\\sigma)$。此外，通过系统性渐近改进（例如，通过欧拉-麦克劳林公式）推导并实现首个修正项，以产生一个改进的近似 $q_{\\mathrm{cl,imp}}(T,\\tilde{B},\\sigma)$。\n\n3) 对每个测试用例，计算：\n- 收敛的数值 $q_{\\mathrm{rot}}$，\n- 领头经典近似 $q_{\\mathrm{cl,lead}}$，\n- 领头近似的相对误差，$\\left|q_{\\mathrm{cl,lead}}-q_{\\mathrm{rot}}\\right|/q_{\\mathrm{rot}}$，\n- 改进近似的相对误差，$\\left|q_{\\mathrm{cl,imp}}-q_{\\mathrm{rot}}\\right|/q_{\\mathrm{rot}}$，\n- 您的求和所使用的终端 $J_{\\max}$。\n\n物理和数值单位及常数：\n- 温度 $T$ 必须以开尔文（K）为单位。\n- 光谱学转动常数 $\\tilde{B}$ 必须以反厘米（$\\mathrm{cm}^{-1}$）为单位。\n- 使用来自可靠CODATA源的精确物理常数 $h$（普朗克常数）、$c$（光速）和 $k_{\\mathrm{B}}$（玻尔兹曼常数）。当使用单位为 $\\mathrm{cm}^{-1}$ 的 $\\tilde{B}$ 计算 $\\theta_{\\mathrm{rot}}=\\dfrac{h c \\tilde{B}}{k_{\\mathrm{B}}}$ 时，确保进行正确的单位转换以获得单位为开尔文的 $\\theta_{\\mathrm{rot}}$。\n\n测试套件：\n计算并报告以下四个参数集的结果，所有计算均使用容差 $\\varepsilon = 10^{-12}$：\n- 情况 A (异核，极低温)：$T = 0.5\\ \\mathrm{K}$，$\\tilde{B} = 2.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 1$。\n- 情况 B (异核，中等温度)：$T = 5.0\\ \\mathrm{K}$，$\\tilde{B} = 2.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 1$。\n- 情况 C (同核，高温)：$T = 300.0\\ \\mathrm{K}$，$\\tilde{B} = 2.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 2$。\n- 情况 D (异核，高温但转动常数较大)：$T = 300.0\\ \\mathrm{K}$，$\\tilde{B} = 10.0\\ \\mathrm{cm}^{-1}$，$\\sigma = 1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的聚合结果，形式为方括号内的一个逗号分隔列表。对于每个用例，按顺序附加五个值\n$[q_{\\mathrm{rot}},\\ q_{\\mathrm{cl,lead}},\\ \\mathrm{relErr}_{\\mathrm{lead}},\\ \\mathrm{relErr}_{\\mathrm{imp}},\\ J_{\\max}]$，\n因此最终行将总共包含 $20$ 个条目。所有的 $q$ 值和相对误差必须报告为无量纲浮点数，$J_{\\max}$ 报告为整数。例如，输出必须看起来像\n$[x_1,x_2,x_3,x_4,x_5,x_6,\\dots,x_{20}]$\n不含任何附加文本。", "solution": "所述问题定义严格、科学合理且内容自洽。它基于统计力学和量子力学的基本原理在分子光谱学中的应用。所有参数、常数和目标都已明确指定。因此，该问题是有效的，我们着手进行求解。\n\n解决方案分为两部分：首先，推导必要的公式；其次，将这些公式实现为一个计算程序。\n\n线性刚性转子的转动配分函数由下式给出：\n$$\nq_{\\mathrm{rot}}(T, \\tilde{B}, \\sigma) = \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} g_J \\exp\\left(-\\frac{E_J}{k_{\\mathrm{B}} T}\\right)\n$$\n其中 $T$ 是绝对温度，$\\sigma$ 是对称数，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，能级 $E_J$ 及其简并度 $g_J$ 由量子力学给出。对于线性刚性转子，其转动能级为 $E_J = h c \\tilde{B} J(J+1)$，简并度为 $g_J = 2J+1$，其中转动量子数 $J = 0, 1, 2, \\dots$。这里，$h$ 是普朗克常数，$c$ 是光速，$\\tilde{B}$ 是光谱学转动常数。\n\n定义特征转动温度 $\\theta_{\\mathrm{rot}} = \\frac{h c \\tilde{B}}{k_{\\mathrm{B}}}$ 会很方便。该参数具有温度单位，代表了转动能级之间的能量间距。使用此定义，配分函数变为：\n$$\nq_{\\mathrm{rot}}(T, \\tilde{B}, \\sigma) = \\frac{1}{\\sigma} \\sum_{J=0}^{\\infty} (2J+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right)\n$$\n\n### 1. 配分函数的数值计算\n\n为了进行数值计算，无穷级数必须被截断。当级数的下一项相对于当前的部分和足够小时，求和将终止。设 $S_N$ 是截至量子数 $J=N$ 的部分和，$t_{N+1}$ 是 $J=N+1$ 的项。\n$$\nS_N = \\sum_{J=0}^{N} (2J+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right)\n$$\n$$\nt_{N+1} = (2(N+1)+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} (N+1)(N+2)\\right)\n$$\n当满足条件 $t_{N+1}/S_N < \\varepsilon$ 时，求和在 $J_{\\max} = N$ 处终止，其中给定容差 $\\varepsilon = 10^{-12}$。为防止计算量过大，强制设置了 $J_{\\max}^{\\mathrm{cap}} = 10^6$ 的硬性上限。最终通过数值计算得到的配分函数为 $q_{\\mathrm{rot}} = S_{J_{\\max}} / \\sigma$。\n\n### 2. 高温渐近近似\n\n在 $T \\gg \\theta_{\\mathrm{rot}}$ 的高温极限下，离散求和可以用积分来近似。\n\n#### 领头阶经典近似\n\n领头阶项 $q_{\\mathrm{cl,lead}}$ 是通过将对 $J$ 的求和替换为从 $J=0$ 到 $J=\\infty$ 的积分得到的：\n$$\nq_{\\mathrm{cl,lead}} = \\frac{1}{\\sigma} \\int_0^\\infty (2J+1) \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} J(J+1)\\right) dJ\n$$\n让我们进行变量替换。令 $x = J(J+1)$。则其微分为 $dx = (2J+1)dJ$。$x$ 的积分限仍为 $0$ 到 $\\infty$。积分简化为一种标准形式：\n$$\nq_{\\mathrm{cl,lead}} = \\frac{1}{\\sigma} \\int_0^\\infty \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} x\\right) dx = \\frac{1}{\\sigma} \\left[ -\\frac{T}{\\theta_{\\mathrm{rot}}} \\exp\\left(-\\frac{\\theta_{\\mathrm{rot}}}{T} x\\right) \\right]_0^\\infty\n$$\n计算积分在上下限的值，得到：\n$$\nq_{\\mathrm{cl,lead}} = \\frac{1}{\\sigma} \\left( 0 - \\left(-\\frac{T}{\\theta_{\\mathrm{rot}}}\\right) \\right) = \\frac{T}{\\sigma \\theta_{\\mathrm{rot}}}\n$$\n这是众所周知​​的转动配分函数的经典近似。\n\n#### 含一阶修正项的改进近似\n\n通过引入来自半经典展开（可通过欧拉-麦克劳林公式推导）的修正项，可以找到一个更精确的近似 $q_{\\mathrm{cl,imp}}$。该公式将离散求和与积分及其导数联系起来：\n$$\n\\sum_{J=0}^{\\infty} f(J) \\approx \\int_{0}^{\\infty} f(x) dx + \\frac{1}{2}f(0) - \\frac{1}{12}f'(0) + \\dots\n$$\n令 $y = \\theta_{\\mathrm{rot}}/T$ 及 $f(J) = (2J+1)\\exp(-y J(J+1))$。我们已经找到了积分项：\n$$\n\\int_{0}^{\\infty} f(x) dx = \\frac{1}{y} = \\frac{T}{\\theta_{\\mathrm{rot}}}\n$$\n接下来，我们计算函数及其在 $J=0$ 处的导数：\n$$\nf(0) = (2(0)+1)\\exp(0) = 1\n$$\n$$\nf'(J) = \\frac{d}{dJ} \\left( (2J+1)e^{-y J(J+1)} \\right) = 2e^{-y J(J+1)} - y(2J+1)^2 e^{-y J(J+1)}\n$$\n$$\nf'(0) = 2e^0 - y(1)^2 e^0 = 2 - y\n$$\n将这些代入欧拉-麦克劳林公式，得到级数和为：\n$$\n\\sum_{J=0}^{\\infty} f(J) \\approx \\frac{1}{y} + \\frac{1}{2}(1) - \\frac{1}{12}(2-y) = \\frac{1}{y} + \\frac{1}{2} - \\frac{1}{6} + \\frac{y}{12} = \\frac{1}{y} + \\frac{1}{3} + \\frac{y}{12}\n$$\n高温极限对应于小的 $y$ 值。级数和关于 $y$ 的展开式为 $\\frac{1}{y} + \\frac{1}{3} + O(y)$。改进近似 $q_{\\mathrm{cl,imp}}$ 包括此展开式的前两项：\n$$\nq_{\\mathrm{cl,imp}} = \\frac{1}{\\sigma} \\left( \\frac{T}{\\theta_{\\mathrm{rot}}} + \\frac{1}{3} \\right) = q_{\\mathrm{cl,lead}} + \\frac{1}{3\\sigma}\n$$\n这提供了对经典结果的一阶量子修正。\n\n### 3. 实现与常数\n\n在计算中，我们使用从 `scipy.constants` 库获得的 CODATA 2018 物理常数值：\n- 普朗克常数, $h \\approx 6.62607015 \\times 10^{-34}$ J s\n- 光速, $c \\approx 2.99792458 \\times 10^{8}$ m/s\n- 玻尔兹曼常数, $k_{\\mathrm{B}} \\approx 1.380649 \\times 10^{-23}$ J/K\n\n转动常数 $\\tilde{B}$ 以 cm$^{-1}$ 为单位给出。为了以开尔文计算 $\\theta_{\\mathrm{rot}}$，$\\tilde{B}$ 必须通过乘以 $100$ 转换为 m$^{-1}$。\n$$\n\\theta_{\\mathrm{rot}}[\\mathrm{K}] = \\frac{h[\\mathrm{J \\cdot s}] \\cdot c[\\mathrm{m/s}] \\cdot (\\tilde{B}[\\mathrm{cm^{-1}}] \\times 100 [\\mathrm{m/cm}])}{k_{\\mathrm{B}}[\\mathrm{J/K}]}\n$$\n相对误差按规定计算：$\\mathrm{relErr}_{\\mathrm{lead}} = |q_{\\mathrm{cl,lead}} - q_{\\mathrm{rot}}| / q_{\\mathrm{rot}}$ 和 $\\mathrm{relErr}_{\\mathrm{imp}} = |q_{\\mathrm{cl,imp}} - q_{\\mathrm{rot}}| / q_{\\mathrm{rot}}$。\n程序将对每个测试用例执行这些计算，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import h, c, k\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the rotational partition function for a linear\n    rigid rotor for a defined set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (T [K], B_tilde [cm^-1], sigma), Case Label\n        (0.5, 2.0, 1),    # Case A\n        (5.0, 2.0, 1),    # Case B\n        (300.0, 2.0, 2),  # Case C\n        (300.0, 10.0, 1)  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        T, B_tilde, sigma = case\n        res_tuple = calculate_rotational_properties(T, B_tilde, sigma)\n        results.extend(res_tuple)\n\n    # Final print statement in the exact required format.\n    # We format floats with a general precision specifier for clarity,\n    # and integers as standard integers.\n    print(f\"[{','.join(f'{val:.12g}' if isinstance(val, float) else str(val) for val in results)}]\")\n\ndef calculate_rotational_properties(T, B_tilde, sigma):\n    \"\"\"\n    Calculates q_rot, q_cl,lead, relative errors, and J_max for a single case.\n\n    Args:\n        T (float): Absolute temperature in Kelvin.\n        B_tilde (float): Rotational constant in cm^-1.\n        sigma (int): Symmetry number.\n\n    Returns:\n        tuple: A tuple containing (q_rot, q_cl_lead, relErr_lead, relErr_imp, J_max).\n    \"\"\"\n    epsilon = 1e-12\n    J_max_cap = 1000000\n\n    # Calculate the characteristic rotational temperature, theta_rot.\n    # B_tilde is in cm^-1, so it's converted to m^-1 by multiplying by 100.\n    theta_rot = (h * c * B_tilde * 100.0) / k\n    theta_rot_over_T = theta_rot / T\n\n    # 1. Numerical summation for q_rot\n    # The sum starts with the J=0 term.\n    current_sum = 1.0  # This is S_0\n    J = 0\n    J_max = 0\n\n    while J < J_max_cap:\n        J_next = J + 1\n        exponent_next = -theta_rot_over_T * (J_next * (J_next + 1))\n        \n        # Check for potential underflow to prevent exp() from returning 0\n        # prematurely, which might affect very low-temperature calculations.\n        # np.exp handles large negative exponents gracefully.\n        term_next = (2.0 * J_next + 1.0) * np.exp(exponent_next)\n\n        # Stopping criterion: t_{N+1} / S_N < epsilon\n        # We stop when the next term is negligible compared to the current sum.\n        if term_next == 0.0 or term_next / current_sum < epsilon:\n            J_max = J  # The sum is converged up to J.\n            break\n        \n        current_sum += term_next\n        J += 1\n    else:  # This 'else' belongs to the 'while' loop.\n        J_max = J_max_cap\n\n    q_rot = current_sum / sigma\n\n    # 2. High-temperature approximations\n    q_cl_lead = (T / theta_rot) / sigma\n    q_cl_imp = q_cl_lead + 1.0 / (3.0 * sigma)\n\n    # 3. Relative errors\n    relErr_lead = np.abs(q_cl_lead - q_rot) / q_rot if q_rot != 0 else 0.0\n    relErr_imp = np.abs(q_cl_imp - q_rot) / q_rot if q_rot != 0 else 0.0\n\n    return q_rot, q_cl_lead, relErr_lead, relErr_imp, J_max\n\nsolve()\n```", "id": "2821764"}]}