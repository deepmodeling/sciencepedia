{"hands_on_practices": [{"introduction": "本练习使用一个精确可解的模型，为重整化群的具体操作提供了一个清晰的介绍。通过对一维谐振子链执行实空间抽取变换，你将显式地积分掉短波长的自由度，从而观察到为剩余变量所导出的新的有效哈密顿量是如何产生的。这个过程直接揭示了RG的核心思想：随着观察尺度的改变，模型参数（此例中为弹簧常数）的重整化。[@problem_id:2801692]", "problem": "一个由相同原子组成的经典一维链模型用于模拟聚合物骨架中的纵向振动。该链由哈密顿量\n$$\nH=\\frac{1}{2}\\sum_{i=1}^{N}\\left[\\frac{p_i^2}{m}+\\kappa\\left(x_{i+1}-x_i\\right)^2\\right],\n$$\n描述，具有周期性边界条件，其中$N$为偶数，$m$是质量，$\\kappa$是最近邻弹簧常数，$x_i$是格点$i$的位移，而$p_i$是其共轭动量。考虑在逆温度$\\beta=1/(k_{\\mathrm{B}}T)$下的正则配分函数：\n$$\nZ=\\int \\prod_{i=1}^{N} dx_i\\,dp_i\\,\\exp\\left(-\\beta H\\right).\n$$\n执行重整化群（RG）的一个实空间抽取步骤，在该步骤中，你将积分掉所有奇数格点上的自由度。仅使用以下基本事实：(i) 对于二次型哈密顿量，正则配分函数是一个相空间高斯积分；(ii) 对一部分变量进行高斯积分，会得到一个关于剩余变量的、与原高斯函数形式相同（不计乘法常数）的函数。假设系统具有平移不变性和周期性边界条件，因此边界项可以忽略，并假设在微观上只存在最近邻谐波相互作用。\n\n在进行任何重标度之前，导出偶数格点的有效粗粒化哈密顿量，然后执行晶格重标度步骤，通过将偶数格点重新标记为长度为$N/2$、晶格间距与原始链相同的链上的最近邻格点，从而恢复原始的晶格间距。在什么假设下，有效哈密顿量能在最近邻位移方面保持相同的谐波函数形式，并带有一个重整化的弹簧常数？明确陈述这些假设。最后，确定经过这单次抽取和重标度步骤后，重整化弹簧常数$\\kappa_{\\mathrm{R}}$的显式封闭形式表达式，该表达式应纯粹用$\\kappa$表示。以$\\kappa_{\\mathrm{R}}$的单个无单位解析表达式的形式给出你的最终答案。", "solution": "所述问题在科学上是合理的、自洽的且提法恰当。这是统计力学中一个用来说明实空间重整化群的标准教学问题。解题过程如下。\n\n系统由哈密顿量描述：\n$$\nH=\\frac{1}{2}\\sum_{i=1}^{N}\\left[\\frac{p_i^2}{m}+\\kappa\\left(x_{i+1}-x_i\\right)^2\\right]\n$$\n在逆温度$\\beta$下的正则配分函数由下式给出：\n$$\nZ=\\int \\prod_{i=1}^{N} dx_i\\,dp_i\\,\\exp\\left(-\\beta H\\right)\n$$\n哈密顿量可以分离为动能项和势能项。对动量$\\{p_i\\}$的积分可以独立于位置$\\{x_i\\}$进行。\n$$\n\\int \\prod_{i=1}^{N} dp_i \\exp\\left(-\\frac{\\beta}{2m}\\sum_{i=1}^{N}p_i^2\\right) = \\left(\\int dp \\exp\\left(-\\frac{\\beta p^2}{2m}\\right)\\right)^N = \\left(\\sqrt{\\frac{2\\pi m}{\\beta}}\\right)^N\n$$\n这部分对配分函数贡献一个常数因子，并且不影响势能参数的重整化。因此，我们可以专注于配分函数的位形部分，它涉及到对位置坐标$\\{x_i\\}$在势能$V = \\frac{1}{2}\\sum_{i=1}^{N}\\kappa(x_{i+1}-x_i)^2$下的积分。\n位形配分函数为：\n$$\nZ_x = \\int \\prod_{i=1}^{N} dx_i \\exp\\left(-\\beta V\\right)\n$$\n重整化群的抽取步骤要求积分掉对应于奇数编号格点的自由度，即$i=1, 3, \\dots, N-1$的$\\{x_i, p_i\\}$。由于奇数格点的动量积分仅贡献一个总的常数，我们只需考虑对奇数格点的位置变量$\\{x_i\\}_{i \\text{ 奇数}}$进行积分。\n\n势能$V$只涉及最近邻相互作用。一个奇数格点$x_k$（其中$k$是奇数）只与其偶数编号的邻居$x_{k-1}$和$x_{k+1}$相互作用。势能中与$x_k$相关的项是$\\frac{\\kappa}{2}(x_k - x_{k-1})^2$和$\\frac{\\kappa}{2}(x_{k+1} - x_k)^2$。因为每个奇数格点只与其直接的偶数邻居耦合，所以对不同奇数格点位置的积分是相互独立的。我们可以将对奇数格点的积分写成每个奇数格点对应积分的乘积：\n$$\n\\int \\prod_{i \\text{ odd}} dx_i \\exp(-\\beta V) = \\int \\prod_{i \\text{ odd}} dx_i \\exp\\left(-\\frac{\\beta \\kappa}{2} \\sum_{j \\text{ all}} (x_{j+1}-x_j)^2\\right) = \\prod_{k \\text{ odd}} \\int dx_k \\exp\\left(-\\frac{\\beta \\kappa}{2} \\left[ (x_k - x_{k-1})^2 + (x_{k+1} - x_k)^2 \\right] \\right)\n$$\n让我们来计算其中一个高斯积分。对于给定的奇数格点$x_k$，指数的宗量是$x_k$的二次函数：\n$$\n-\\frac{\\beta \\kappa}{2} \\left[ (x_k - x_{k-1})^2 + (x_{k+1} - x_k)^2 \\right] = -\\frac{\\beta \\kappa}{2} \\left[ x_k^2 - 2x_k x_{k-1} + x_{k-1}^2 + x_{k+1}^2 - 2x_{k+1}x_k + x_k^2 \\right]\n$$\n$$\n= -\\frac{\\beta \\kappa}{2} \\left[ 2x_k^2 - 2x_k(x_{k-1} + x_{k+1}) + (x_{k-1}^2 + x_{k+1}^2) \\right]\n$$\n为了对$x_k$进行积分，我们对包含$x_k$的项进行配方：\n$$\n2x_k^2 - 2x_k(x_{k-1} + x_{k+1}) = 2\\left[x_k^2 - x_k(x_{k-1} + x_{k+1})\\right] = 2\\left[\\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\left(\\frac{x_{k-1} + x_{k+1}}{2}\\right)^2\\right]\n$$\n将此代回指数的宗量中，得到：\n$$\n-\\frac{\\beta \\kappa}{2} \\left[ 2\\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\frac{1}{2}(x_{k-1} + x_{k+1})^2 + x_{k-1}^2 + x_{k+1}^2 \\right]\n$$\n$$\n= -\\frac{\\beta \\kappa}{2} \\left[ 2\\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 + \\frac{1}{2}(x_{k-1}^2 - 2x_{k-1}x_{k+1} + x_{k+1}^2) \\right]\n$$\n$$\n= -\\beta \\kappa \\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2\n$$\n现在对$x_k$的积分就很直接了：\n$$\n\\int_{-\\infty}^{\\infty} dx_k \\exp\\left[ -\\beta \\kappa \\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right] \n$$\n$$\n= \\exp\\left( - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right) \\int_{-\\infty}^{\\infty} dx_k \\exp\\left[ -\\beta \\kappa \\left(x_k - \\frac{x_{k-1} + x_{k+1}}{2}\\right)^2 \\right]\n$$\n该积分的计算结果是一个常数$\\sqrt{\\pi/(\\beta\\kappa)}$，它与剩余的偶数格点坐标无关。将对所有$N/2$个奇数格点积分得到的所有这些常数合并起来，会得到一个总的常数前置因子。玻尔兹曼因子中依赖于偶数格点坐标的剩余部分定义了有效势$V_{\\text{eff}}$。\n在积分掉所有奇数格点后，偶数格点的新玻尔兹曼因子为：\n$$\n\\exp(-\\beta V_{\\text{eff}}) \\propto \\prod_{k \\text{ odd}} \\exp\\left( - \\frac{\\beta \\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right) = \\exp\\left( - \\beta \\sum_{k \\text{ odd}} \\frac{\\kappa}{4} (x_{k+1} - x_{k-1})^2 \\right)\n$$\n因此，偶数格点$\\{x_2, x_4, \\dots, x_N\\}$的有效势为：\n$$\nV_{\\text{eff}} = \\sum_{k \\text{ odd}} \\frac{\\kappa}{4} (x_{k+1} - x_{k-1})^2 = \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x_{2j+2}-x_{2j})^2\n$$\n其中使用了周期性边界条件（$x_{N+2} = x_2$）。在重标度之前，由$N/2$个偶数编号格点组成的粗粒化系统的有效哈密顿量为：\n$$\nH_{\\text{eff}} = \\sum_{j=1}^{N/2} \\frac{p_{2j}^2}{2m} + \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x_{2j+2}-x_{2j})^2\n$$\n这个有效哈密顿量描述了一个具有$N/2$个格点的新链。在新的、更粗的晶格上，相互作用仍然是谐波的，并且发生在最近邻之间。这种函数形式的保持并非重整化群变换的一般特征。它在这里成立是由于两个关键假设：\n$1$. 原始哈密顿量是关于自由度的二次型（谐波）函数。这使得配分函数成为高斯积分的乘积，而对一部分变量进行积分会产生一个关于剩余变量的新的高斯函数。\n$2$. 原始哈密顿量中的相互作用严格限制在最近邻之间。这确保了积分掉一个奇数格点$x_k$只会它的直接邻居$x_{k-1}$和$x_{k+1}$之间产生一个新的有效相互作用，而这两个邻居在粗粒化晶格上成为最近邻。如果最初存在次近邻或更长程的相互作用，抽取过程将会生成一个复杂得多的、非局域的有效哈密顿量。\n\n现在，我们进行晶格重标度。我们为尺寸为$N/2$的粗粒化晶格定义一套新的坐标：\n$$\nx'_j = x_{2j}, \\quad p'_j = p_{2j} \\quad \\text{for } j=1, 2, \\dots, N/2\n$$\n用这些新变量表示的重标度哈密顿量$H_{\\text{R}}$是：\n$$\nH_{\\text{R}} = \\sum_{j=1}^{N/2} \\frac{(p'_j)^2}{2m} + \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x'_{j+1}-x'_{j})^2\n$$\n问题要求这个重整化的哈密顿量具有与原始哈密顿量相同的函数形式，即：\n$$\nH_{\\text{R}} = \\frac{1}{2} \\sum_{j=1}^{N/2} \\left[ \\frac{(p'_j)^2}{m'} + \\kappa_{\\text{R}} (x'_{j+1}-x'_{j})^2 \\right]\n$$\n在这种情况下，没有对质量进行重标度，所以$m' = m$。我们比较势能项：\n$$\n\\frac{1}{2} \\sum_{j=1}^{N/2} \\kappa_{\\text{R}} (x'_{j+1}-x'_{j})^2 = \\frac{\\kappa}{4} \\sum_{j=1}^{N/2} (x'_{j+1}-x'_{j})^2\n$$\n通过令系数相等，我们找到了重整化弹簧常数$\\kappa_{\\text{R}}$的关系式：\n$$\n\\frac{\\kappa_{\\text{R}}}{2} = \\frac{\\kappa}{4}\n$$\n这得出了重整化弹簧常数的最终表达式：\n$$\n\\kappa_{\\text{R}} = \\frac{\\kappa}{2}\n$$", "answer": "$$\n\\boxed{\\frac{\\kappa}{2}}\n$$", "id": "2801692"}, {"introduction": "本实践将从依赖于具体格子的实空间方法，转向更普适、更强大的动量空间RG。你将把 Wilson 的动量层积分方案应用于典型的 $\\phi^4$ 理论——这是研究临界现象的核心模型。通过积分掉一个薄动量层中的“快”模并进行标度重缩放，你将推导出控制理论耦合常数随标度演化的微分流方程，即β函数，从而直接洞察普适性背后的驱动机制。[@problem_id:2801635]", "problem": "考虑一个单分量实标量序参量场，其欧几里得作用量为 $S[\\phi]=\\int d^d x \\left[\\frac{1}{2}(\\nabla \\phi)^2+\\frac{r}{2}\\phi^2+\\frac{u}{4!}\\phi^4\\right]$，并具有尖锐的紫外动量截断 $|\\mathbf{k}|\\le \\Lambda$。执行一步威尔逊动量壳层重整化群 (RG) 步骤，通过对快模（$\\Lambda/b|\\mathbf{q}|\\le \\Lambda$）进行积分，其中 $b=\\exp(\\ell)$ 且 $\\ell$ 是无穷小量，然后进行标度变换 $x'=x/b$ 和场重标定，选择重标定以保持动能项 $\\frac{1}{2}(\\nabla \\phi)^2$ 的系数不变。使用累积量展开计算至单圈阶，并在递推关系中保留到 $u^2$ 阶的项。\n\n你的推导必须从配分函数 $Z=\\int \\mathcal{D}\\phi\\,\\exp\\!\\left(-S[\\phi]\\right)$ 的路径积分表示、模式分解 $\\phi=\\phi_+\\phi_>$（分为慢模和快模）以及对慢模有效作用量的相关阶次的累积量展开开始。假设对于标量 $\\phi^4$ 理论，在此阶次下不存在波函数重整化。使用以下几何因子的定义：$S_d=2\\pi^{d/2}/\\Gamma(d/2)$ 和 $K_d \\equiv \\frac{S_d}{2(2\\pi)^d}$。定义无量纲耦合 $\\tau \\equiv r/\\Lambda^2$ 和 $g \\equiv K_d\\,u\\,\\Lambda^{d-4}$。在源于传播子分母的单圈壳层积分中，保留对 $\\tau$ 的领头依赖关系。\n\n推导 $u^2$ 阶的微分递推关系（β函数）$d\\tau/d\\ell$ 和 $dg/d\\ell$，并完全用 $d$、$\\tau$ 和 $g$ 表示。将最终答案以包含两个β函数的单个闭式解析行向量形式给出。无需进行数值计算，也不涉及单位。最终答案必须是单个解析表达式。", "solution": "该问题要求使用威尔逊动量壳层积分方案，推导 $d$ 维标量 $\\phi^4$ 理论的单圈重整化群 (RG) β函数。\n\n配分函数由标量场 $\\phi$ 的路径积分给出：\n$$Z = \\int \\mathcal{D}\\phi \\, \\exp(-S[\\phi])$$\n其中欧几里得作用量为\n$$S[\\phi] = \\int d^d x \\left[\\frac{1}{2}(\\nabla \\phi)^2 + \\frac{r}{2}\\phi^2 + \\frac{u}{4!}\\phi^4\\right]$$\n场的动量具有一个尖锐的紫外截断 $|\\mathbf{k}| \\le \\Lambda$。\n\n威尔逊 RG 过程的第一步是将场 $\\phi$ 分解为慢模 $\\phi_$ 和快模 $\\phi_>$。在动量空间中：\n$$\n\\phi(\\mathbf{k}) =\n\\begin{cases}\n\\phi_(\\mathbf{k})  \\text{for } 0 \\le |\\mathbf{k}| \\le \\Lambda/b \\\\\n\\phi_>(\\mathbf{k})  \\text{for } \\Lambda/b  |\\mathbf{k}| \\le \\Lambda\n\\end{cases}\n$$\n其中 $b = \\exp(\\ell)$，$\\ell$ 为无穷小参数。作用量可以分解为依赖于 $\\phi_$ 和 $\\phi_>$ 的部分。\n$$S[\\phi_ + \\phi_>] = S_0[\\phi_] + S_0[\\phi_>] + S_{int}[\\phi_ + \\phi_>] $$\n此处，$S_0[\\phi] = \\int \\frac{d^d k}{(2\\pi)^d} \\frac{1}{2}(k^2+r) |\\phi(\\mathbf{k})|^2$ 是作用量的二次（自由）部分，而 $S_{int}[\\phi] = \\int d^d x \\frac{u}{4!}\\phi^4$ 是相互作用部分。\n\n对快模 $\\phi_>$ 进行积分，得到慢模的有效作用量 $S_{eff}[\\phi_]$：\n$$\\exp(-S_{eff}[\\phi_]) = \\int \\mathcal{D}\\phi_> \\, \\exp(-S[\\phi_ + \\phi_>])$$\n有效作用量可以被系统地计算。在单圈阶，作用量的变化 $\\Delta S = S_{eff}[\\phi_] - S[\\phi_]$ 由具有内部快模传播子和外部慢模场的单圈单粒子不可约 (1PI) 图给出。这等价于计算泛函迹：\n$$\\Delta S[\\phi_] = \\frac{1}{2}\\text{Tr}\\ln\\left(\\frac{\\delta^2 S}{\\delta\\phi_> \\delta\\phi_>}\\right)\\Big|_{\\phi_> = 0} - \\text{const.}$$\n对数中的算符是 $\\frac{\\delta^2 S}{\\delta\\phi_>(x) \\delta\\phi_>(y)} = (-\\nabla^2+r)\\delta^{(d)}(x-y) + \\frac{u}{2}\\phi^2(x)\\delta^{(d)}(x-y) + O(\\phi^4)$。将 $\\phi_$ 视作背景场，这便是\n$$-\\nabla^2 + r + \\frac{u}{2}\\phi_^2(x)$$\n快模的传播子为 $G_>(q) = \\frac{1}{q^2+r}$，其中 $\\Lambda/b  |q| \\le \\Lambda$。\n作用量的变化则为\n$$\\Delta S[\\phi_] = \\frac{1}{2}\\text{Tr}\\ln\\left[ G_>^{-1}\\left(1 + G_> \\frac{u}{2}\\phi_^2\\right) \\right] = \\text{const.} + \\frac{1}{2}\\text{Tr}\\ln\\left(1 + G_> \\frac{u}{2}\\phi_^2\\right)$$\n使用展开式 $\\ln(1+X) \\approx X - \\frac{1}{2}X^2$，我们保留到 $\\phi_^4$ 阶的项。\n$$\\Delta S[\\phi_] \\approx \\frac{1}{2}\\text{Tr}\\left(G_> \\frac{u}{2}\\phi_^2\\right) - \\frac{1}{4}\\text{Tr}\\left( (G_> \\frac{u}{2}\\phi_^2)^2 \\right)$$\n\n第一项修正了质量项 $\\frac{r}{2}\\phi^2$：\n$$\\Delta S_r = \\frac{u}{4}\\text{Tr}(G_> \\phi_^2) = \\frac{u}{4} \\int d^d x \\, \\phi_^2(x) G_>(x,x)$$\n其中 $G_>(x,x) = \\int_{\\Lambda/b|q|\\le\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{1}{q^2+r} \\equiv I_1$。这个在薄动量壳层上的积分是\n$$I_1 = \\int_{\\Lambda/b}^{\\Lambda} \\frac{S_d q^{d-1} dq}{(2\\pi)^d} \\frac{1}{q^2+r}$$\n其中 $S_d = 2\\pi^{d/2}/\\Gamma(d/2)$ 是 $d$ 维单位超球面的表面积。对于无穷小 $\\ell$，$b = e^\\ell \\approx 1+\\ell$，因此壳层宽度为 $\\Lambda - \\Lambda/b \\approx \\Lambda\\ell$。\n$$I_1 \\approx \\frac{S_d \\Lambda^{d-1}}{(2\\pi)^d} \\frac{1}{\\Lambda^2+r} (\\Lambda\\ell) = \\frac{S_d}{(2\\pi)^d} \\frac{\\Lambda^d}{\\Lambda^2(1+r/\\Lambda^2)}\\ell = 2 K_d \\frac{\\Lambda^{d-2}}{1+\\tau}\\ell$$\n使用定义 $K_d = \\frac{S_d}{2(2\\pi)^d}$ 和 $\\tau=r/\\Lambda^2$。作用量中 $\\frac{1}{2}\\phi_^2$ 的系数变化了 $\\Delta r$：\n$$\\frac{\\Delta r}{2} = \\frac{u}{4}I_1 \\implies \\Delta r = \\frac{u}{2}I_1 = u K_d \\frac{\\Lambda^{d-2}}{1+\\tau}\\ell$$\n\n$\\Delta S$ 展开式中的第二项修正了相互作用项 $\\frac{u}{4!}\\phi^4$：\n$$\\Delta S_u = -\\frac{1}{8}\\text{Tr}\\left( (G_> \\frac{u}{2}\\phi_^2)^2 \\right) = -\\frac{u^2}{32}\\text{Tr}(G_> \\phi_^2 G_> \\phi_^2)$$\n为进行局域顶点修正，将 $\\phi_$ 近似为空间常数，这变为\n$$\\Delta S_u \\approx -\\frac{u^2}{32}\\phi_^4 \\int d^dx \\, \\text{Tr}(G_> G_>) = -\\frac{u^2}{32}\\phi_^4 \\int d^dx \\int_{\\Lambda/b|q|\\le\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\left(\\frac{1}{q^2+r}\\right)^2$$\n该积分为 $I_2 \\equiv \\int_{\\Lambda/b|q|\\le\\Lambda} \\frac{d^d q}{(2\\pi)^d} \\frac{1}{(q^2+r)^2}$。在薄壳层上计算：\n$$I_2 \\approx \\frac{S_d \\Lambda^{d-1}}{(2\\pi)^d} \\frac{1}{(\\Lambda^2+r)^2} (\\Lambda\\ell) = 2 K_d \\frac{\\Lambda^{d-4}}{(1+\\tau)^2}\\ell$$\n$\\frac{1}{4!}\\phi_^4$ 的系数变化了 $\\Delta u$。注意，上述计算给出了写作 $-\\frac{u^2}{32}\\phi_^4 \\int d^d x I_2$ 形式的项的修正。对四点函数有贡献的单圈修正有 3 个通道，这对应于图的组合学。来自费曼图的标准结果给出 $\\Delta u = -\\frac{3}{2}u^2 I_2$。\n$$\\Delta u = -\\frac{3}{2}u^2 I_2 = -\\frac{3}{2}u^2 \\left( 2 K_d \\frac{\\Lambda^{d-4}}{(1+\\tau)^2}\\ell \\right) = -3 u^2 K_d \\frac{\\Lambda^{d-4}}{(1+\\tau)^2}\\ell$$\n\nRG 过程的第二步是重标定空间和场，以恢复原始的截断标度 $\\Lambda$ 和正则的动能项。令 $x' = x/b$ 且 $\\phi_(x) = \\zeta^{-1}\\phi'(x')$。\n动能项变换如下：\n$$\\int d^dx \\frac{1}{2}(\\nabla\\phi_)^2 = \\int b^d d^dx' \\frac{1}{2} (b^{-1}\\nabla' (\\zeta^{-1}\\phi'))^2 = b^{d-2}\\zeta^{-2} \\int d^dx' \\frac{1}{2}(\\nabla'\\phi')^2$$\n为保持此项不变，我们必须有 $b^{d-2}\\zeta^{-2} = 1$，这给出 $\\zeta = b^{(d-2)/2}$。质量项和相互作用项变换如下：\n$$\\int d^dx \\, \\frac{r'}{2}\\phi_^2 = \\int b^d d^dx' \\, \\frac{r'}{2}(\\zeta^{-1}\\phi')^2 = b^d \\zeta^{-2} \\int d^dx' \\frac{r'}{2}(\\phi')^2 = b^2 \\int d^dx' \\frac{r'}{2}(\\phi')^2$$\n$$\\int d^dx \\, \\frac{u'}{4!}\\phi_^4 = \\int b^d d^dx' \\, \\frac{u'}{4!}(\\zeta^{-1}\\phi')^4 = b^d \\zeta^{-4} \\int d^dx' \\frac{u'}{4!}(\\phi')^4 = b^{4-d} \\int d^dx' \\frac{u'}{4!}(\\phi')^4$$\n其中 $r'=r+\\Delta r$ 且 $u'=u+\\Delta u$。\n参数的递推关系为：\n$$r(\\ell) = (r+\\Delta r)b^2 = (r+\\Delta r)e^{2\\ell} \\approx (r+\\Delta r)(1+2\\ell) \\approx r + 2r\\ell + \\Delta r$$\n$$u(\\ell) = (u+\\Delta u)b^{4-d} = (u+\\Delta u)e^{(4-d)\\ell} \\approx (u+\\Delta u)(1+(4-d)\\ell) \\approx u + (4-d)u\\ell + \\Delta u$$\n通过取极限 $\\ell \\to 0$ 得到微分流方程：\n$$\\frac{dr}{d\\ell} = \\lim_{\\ell\\to 0}\\frac{r(\\ell)-r}{\\ell} = 2r + \\frac{\\Delta r}{\\ell} = 2r + u K_d \\Lambda^{d-2}(1+\\tau)^{-1}$$\n$$\\frac{du}{d\\ell} = \\lim_{\\ell\\to 0}\\frac{u(\\ell)-u}{\\ell} = (4-d)u + \\frac{\\Delta u}{\\ell} = (4-d)u - 3u^2 K_d \\Lambda^{d-4}(1+\\tau)^{-2}$$\n\n最后，我们推导无量纲耦合 $\\tau = r/\\Lambda^2$ 和 $g=K_d u \\Lambda^{d-4}$ 的β函数。在这些定义中，截断 $\\Lambda$ 被视为一个固定的标度参数。\n$$\\frac{d\\tau}{d\\ell} = \\frac{1}{\\Lambda^2} \\frac{dr}{d\\ell} = \\frac{1}{\\Lambda^2}\\left(2r + u K_d \\Lambda^{d-2}\\frac{1}{1+\\tau}\\right) = 2\\frac{r}{\\Lambda^2} + (u K_d \\Lambda^{d-4})\\frac{1}{1+\\tau}$$\n$$\\frac{d\\tau}{d\\ell} = 2\\tau + \\frac{g}{1+\\tau}$$\n对于耦合 $g$：\n$$\\frac{dg}{d\\ell} = K_d \\Lambda^{d-4} \\frac{du}{d\\ell} = K_d \\Lambda^{d-4} \\left( (4-d)u - 3u^2 K_d \\Lambda^{d-4}\\frac{1}{(1+\\tau)^2} \\right)$$\n$$\\frac{dg}{d\\ell} = (4-d)(K_d u \\Lambda^{d-4}) - 3(K_d u \\Lambda^{d-4})^2\\frac{1}{(1+\\tau)^2}$$\n$$\\frac{dg}{d\\ell} = (4-d)g - \\frac{3g^2}{(1+\\tau)^2}$$\n这些就是所求的 $u^2$ 阶的递推关系。", "answer": "$$\\boxed{\\begin{pmatrix} 2\\tau + \\frac{g}{1+\\tau}  (4-d)g - \\frac{3g^2}{(1+\\tau)^2} \\end{pmatrix}}$$", "id": "2801635"}, {"introduction": "最后的这项实践旨在弥合抽象的RG理论与其在数据分析中的实际应用之间的鸿沟——这是现代研究人员的一项关键技能。你将实施有限尺寸标度分析（RG原理的直接推论），从合成数据中提取高分子链的普适标度指数 $\\nu$。这个计算练习强调了如何处理对标度的修正，并使用如赤池信息准则（Akaike Information Criterion, AICc）等严谨的统计方法来选择最佳的物理模型，从而展示了RG如何为解释数值和实验结果提供一个强大的框架。[@problem_id:2801617]", "problem": "你的任务是编写一个程序，给定一小组合成聚合物数据集，使用重整化群理论中的有限尺寸标度思想，从聚合物的回转半径 $R_g$ 作为链长 $N$ 的函数来估计长链的临界尺寸指数 $\\nu$，同时考虑次领先的有限尺寸修正。其核心物理背景是，稀聚合物溶液中的排除体积相互作用驱动一个重整化群不动点，该不动点设定了渐近标度关系 $R_g \\sim N^{\\nu}$，其修正是由随着 $N$ 增加而衰减的非相关算符控制的。你的算法应该是有原则的，不应依赖于临时的曲线匹配；它应该使用模型选择准则来决定是否需要修正项，如果需要，哪个候选修正指数能最好地解释数据。\n\n使用的基本原理：\n- 聚合物链的回转半径 $R_g$ 的定义是一个特征尺寸，对于长链，由于在重整化群不动点处的标度不变性，$R_g$ 对链长 $N$ 有一个渐进的幂律依赖关系。\n- 广泛使用的有限尺寸标度假设是，领先的标度修正是 $N$ 的一个衰减幂，由一个正的标度修正指数 $\\Delta$ 控制。\n\n你的计算任务：\n1. 对于每个数据集，通过具有单个领先修正的有限尺寸标度形式，根据指定参数构建 $R_g$ 的合成测量值，不添加任何噪声。这为估计器建立了可复现的输入：\n   - $R_g(N) = A\\, N^{\\nu_{\\text{true}}}\\left(1 + B\\, N^{-\\Delta}\\right)$，其中 $A  0$，$B$ 可为正或负，且 $\\Delta  0$。\n2. 仅给定得到的 $\\{(N_i, R_{g,i})\\}$ 数据对，通过比较以下候选模型来估计指数 $\\nu$：\n   - 纯渐近标度：$R_g(N) = A\\, N^{\\nu}$。\n   - 带有一个次领先修正的标度，候选指数为 $\\Delta \\in \\{0.5, 1.0\\}$：$R_g(N) = A\\, N^{\\nu}\\left(1 + B\\, N^{-\\Delta}\\right)$。\n3. 在原始（非对数）空间中对每个候选模型执行非线性最小二乘估计，使用物理上合理的界限（$A  0$，$0  \\nu  1$，以及对 $B$ 的一个宽界限）。通过最小化小样本修正的Akaike信息准则（AICc）来选择偏好的模型，其定义为对于 $n$ 个数据点和 $k$ 个参数\n   $$ \\mathrm{AIC} = n \\ln\\!\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2k,\\quad \\mathrm{AICc} = \\mathrm{AIC} + \\frac{2k(k+1)}{n - k - 1}, $$\n   其中 $\\mathrm{RSS} = \\sum_{i=1}^{n}\\left(R_{g,i}^{\\text{fit}} - R_{g,i}\\right)^2$。如果 $n - k - 1 \\le 0$，则使用 $\\mathrm{AIC}$ 代替 $\\mathrm{AICc}$。\n4. 报告每个数据集的所选模型的 $\\nu$ 估计值，四舍五入到三位小数。\n\n测试套件（完全按照规定构建合成数据集；$N$ 是无量纲的，$R_g$ 的单位是任意一致的，但最终答案中无需报告单位）：\n- 数据集1（具有强修正的一般情况，类似三维排除体积）：\n  - $N \\in \\{20, 40, 80, 160, 320, 640\\}$，$A = 0.35$，$\\nu_{\\text{true}} = 0.588$，$B = 0.8$，$\\Delta = 0.5$。\n- 数据集2（无修正项的边界情况，理想链或theta链）：\n  - $N \\in \\{10, 20, 40, 80, 160, 320\\}$，$A = 0.6$，$\\nu_{\\text{true}} = 0.5$，$B = 0.0$，$\\Delta = 1.0$。\n- 数据集3（具有解析修正的类二维情况）：\n  - $N \\in \\{30, 60, 120, 240, 480\\}$，$A = 0.25$，$\\nu_{\\text{true}} = 0.75$，$B = 0.5$，$\\Delta = 1.0$。\n- 数据集4（具有非常强修正的短链）：\n  - $N \\in \\{12, 18, 26, 38, 58, 86\\}$，$A = 0.4$，$\\nu_{\\text{true}} = 0.588$，$B = 1.2$，$\\Delta = 0.5$。\n- 数据集5（数据点少且无修正的边缘情况）：\n  - $N \\in \\{50, 100, 200, 400\\}$，$A = 0.5$，$\\nu_{\\text{true}} = 0.588$，$B = 0.0$，$\\Delta = 0.5$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含五个估计的 $\\nu$ 值（每个数据集一个），以逗号分隔的列表形式包含在方括号内，每个值四舍五入到三位小数，例如 $[0.588,0.500,0.750,0.590,0.585]$（此示例仅为说明）。\n\n不涉及角度单位。最终数值输出中不需要物理单位。唯一接受的输出是如上所述的浮点数。", "solution": "所提出的问题经过严格验证，被认为是有效的。它构成了一个适定的计算练习，其基础是聚合物统计力学和重整化群理论的基本原理。任务是实现一个有原则的模型选择协议，从合成数据中估计一个普适的临界指数，这是分析模拟和实验结果的标准程序。所有必需的参数和方法都已指定，问题没有科学上的不准确之处或逻辑矛盾。\n\n中心的物理原理是，长柔性聚合物链的特征尺寸，由其回转半径 $R_g$ 量化，随其长度（单体单元数）$N$ 按幂律关系标度。在大的 $N$ 值下，系统由一个重整化群不动点描述，导致普适的标度行为：\n$$ R_g(N) \\sim N^{\\nu} $$\n其中 $\\nu$ 是一个普适临界指数，仅取决于空间维度和相互作用的性质（例如，是否存在排除体积）。对于有限的 $N$，预计会偏离这个渐进定律。这些被称为标度修正，在重整化群框架中由非相关算符控制。领先修正通常呈现为 $N$ 的幂律形式，从而得到以下关于 $R_g(N)$ 标度的假设：\n$$ R_g(N) = A N^{\\nu} \\left(1 + B N^{-\\Delta} + \\dots\\right) $$\n这里，$A$ 是一个非普适振幅，$B$ 是第二个非普适振幅，而 $\\Delta > 0$ 是领先标度修正指数，它也是一个普适量。\n\n任务是获取从此形式生成的合成的、无噪声的数据集 $\\{(N_i, R_{g,i})\\}$，并确定 $\\nu$ 的最佳估计值。这不是通过可能产生误导的天真对数图来完成的，而是通过一个正式的模型比较程序。\n\n具体步骤如下：\n$1$. 对于每个数据集，使用提供的真实参数 $(\\nu_{\\text{true}}, A, B, \\Delta)$ 为 $R_g$ 作为 $N$ 的函数生成合成数据。\n\n$2$. 将三个不同的候选模型拟合到这个合成数据：\n    - 模型 $0$：纯幂律，$R_g(N) = A N^{\\nu}$。该模型有 $k=2$ 个自由参数：$A$ 和 $\\nu$。\n    - 模型 $1$：幂律加上领先修正指数固定为 $\\Delta=0.5$，$R_g(N) = A N^{\\nu} (1 + B N^{-0.5})$。这个模型与三维自避行走相关，有 $k=3$ 个参数：$A$、$\\nu$ 和 $B$。\n    - 模型 $2$：幂律加上领先修正指数固定为 $\\Delta=1.0$，$R_g(N) = A N^{\\nu} (1 + B N^{-1.0})$。这个模型，例如在二维中相关，也有 $k=3$ 个参数：$A$、$\\nu$ 和 $B$。\n\n$3$. 每个模型的参数通过执行非线性最小二乘回归来确定，该回归最小化残差平方和（$\\mathrm{RSS}$）：\n$$ \\mathrm{RSS} = \\sum_{i=1}^{n} \\left( R_{g,i}^{\\text{fit}} - R_{g,i} \\right)^2 $$\n其中 $n$ 是数据点的数量。优化受物理上合理的界限约束，即 $A > 0$ 和 $0  \\nu  1$。\n\n$4$. 通过采用小样本修正的Akaike信息准则（$\\mathrm{AICc}$）来选择最合适的模型。这个准则提供了一种在拟合优度（更低的 $\\mathrm{RSS}$）和模型复杂度（更少的参数数量 $k$）之间进行权衡的正式方法。AIC的定义是：\n$$ \\mathrm{AIC} = n \\ln\\left(\\frac{\\mathrm{RSS}}{n}\\right) + 2k $$\n修正版本 $\\mathrm{AICc}$，对于小样本量 $n$ 更可靠，由下式给出：\n$$ \\mathrm{AICc} = \\mathrm{AIC} + \\frac{2k(k+1)}{n - k - 1} $$\n显示最小 $\\mathrm{AICc}$ 值的模型被选为数据的首选描述。当条件 $n - k - 1 \\le 0$ 对某个候选模型成立时，会出现一个关键细节，因为 $\\mathrm{AICc}$ 中的修正项会变得发散或无定义。在这种情况下，为了进行一致的比较，我们将对该特定数据集的所有被比较模型恢复使用标准的 $\\mathrm{AIC}$。这种情况发生在数据集5，其中 $n=4$，而 $k=3$ 的模型满足 $4-3-1=0$。\n\n$5$. 由于输入数据是从作为候选模型特例的函数中无噪声生成的，因此正确模型（或更复杂的嵌套模型）的 $\\mathrm{RSS}$ 将在数值上为零。在这种情况下，$\\mathrm{AIC}$ 中的对数项变为 $-\\infty$。如果多个模型达到这种完美拟合，将选择具有最小复杂度惩罚（即最小的 $k$ 值）的模型，以维护简约原则。\n\n$6$. 为每个数据集报告的 $\\nu$ 的最终估计值是从所选模型的参数拟合中获得的值。\n\n整个过程在提供的程序中实现。它系统地处理每个数据集，执行模型拟合和选择，并报告得到的指数 $\\nu$ 的最佳估计值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the polymer scaling exponent nu using\n    finite-size scaling and model selection via AICc.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": np.array([20, 40, 80, 160, 320, 640]), \"A\": 0.35,\n            \"nu_true\": 0.588, \"B\": 0.8, \"Delta\": 0.5\n        },\n        {\n            \"N\": np.array([10, 20, 40, 80, 160, 320]), \"A\": 0.6,\n            \"nu_true\": 0.5, \"B\": 0.0, \"Delta\": 1.0\n        },\n        {\n            \"N\": np.array([30, 60, 120, 240, 480]), \"A\": 0.25,\n            \"nu_true\": 0.75, \"B\": 0.5, \"Delta\": 1.0\n        },\n        {\n            \"N\": np.array([12, 18, 26, 38, 58, 86]), \"A\": 0.4,\n            \"nu_true\": 0.588, \"B\": 1.2, \"Delta\": 0.5\n        },\n        {\n            \"N\": np.array([50, 100, 200, 400]), \"A\": 0.5,\n            \"nu_true\": 0.588, \"B\": 0.0, \"Delta\": 0.5\n        },\n    ]\n\n    # Model definitions\n    # Model 0: Pure scaling (k=2)\n    model_0 = lambda N, A, nu: A * N**nu\n    # Model 1: Correction with Delta=0.5 (k=3)\n    model_1 = lambda N, A, nu, B: A * N**nu * (1 + B * N**-0.5)\n    # Model 2: Correction with Delta=1.0 (k=3)\n    model_2 = lambda N, A, nu, B: A * N**nu * (1 + B * N**-1.0)\n    \n    models = [\n        {'func': model_0, 'k': 2, 'name': 'Model 0 (k=2)'},\n        {'func': model_1, 'k': 3, 'name': 'Model 1 (k=3, D=0.5)'},\n        {'func': model_2, 'k': 3, 'name': 'Model 2 (k=3, D=1.0)'}\n    ]\n\n    results_nu = []\n\n    for case in test_cases:\n        N_data = case[\"N\"]\n        A_true, nu_true, B_true, Delta_true = case[\"A\"], case[\"nu_true\"], case[\"B\"], case[\"Delta\"]\n\n        # 1. Generate synthetic data\n        rg_func_true = lambda n: A_true * n**nu_true * (1 + B_true * n**(-Delta_true))\n        Rg_data = rg_func_true(N_data)\n\n        fit_results = []\n        n = len(N_data)\n\n        # Determine if AIC fallback is needed for this dataset\n        use_aic_fallback = any(n - model['k'] - 1 = 0 for model in models)\n\n        for model_spec in models:\n            k = model_spec['k']\n            model_func = model_spec['func']\n            \n            # Set parameter bounds for the nonlinear fitter\n            if k == 2:\n                bounds = ([0, 0], [np.inf, 1.0])\n                # Good initial guess can help convergence, though not strictly necessary here\n                p0 = [1.0, 0.5]\n            else: # k == 3\n                bounds = ([0, 0, -np.inf], [np.inf, 1.0, np.inf])\n                p0 = [1.0, 0.5, 0.0]\n\n            try:\n                popt, _ = curve_fit(model_func, N_data, Rg_data, p0=p0, bounds=bounds, maxfev=10000)\n                \n                Rg_fit = model_func(N_data, *popt)\n                rss = np.sum((Rg_fit - Rg_data)**2)\n\n                # Use a small threshold to handle numerically zero RSS\n                if rss  1e-25:\n                    log_likelihood_term = -np.inf\n                else:\n                    log_likelihood_term = n * np.log(rss / n)\n                \n                aic = log_likelihood_term + 2 * k\n                \n                if use_aic_fallback:\n                    criterion = aic\n                else:\n                    # AICc calculation\n                    correction_term = (2 * k * (k + 1)) / (n - k - 1)\n                    criterion = aic + correction_term\n\n                fit_results.append({'popt': popt, 'criterion': criterion, 'model': model_spec})\n                \n            except RuntimeError:\n                # If fit fails, assign an infinitely bad criterion value\n                fit_results.append({'popt': [np.nan]*k, 'criterion': np.inf, 'model': model_spec})\n\n        # 3. Select the best model (minimum AICc or AIC)\n        best_fit = min(fit_results, key=lambda x: x['criterion'])\n        \n        # 4. Extract estimated nu from the best model\n        # The exponent nu is always the second parameter (index 1)\n        nu_estimated = best_fit['popt'][1]\n        results_nu.append(nu_estimated)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{nu:.3f}\" for nu in results_nu]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2801617"}]}