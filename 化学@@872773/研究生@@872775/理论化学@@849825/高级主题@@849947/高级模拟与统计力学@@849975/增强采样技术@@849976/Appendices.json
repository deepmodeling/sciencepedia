{"hands_on_practices": [{"introduction": "伞形采样是一种沿着预选反应坐标探索自由能形貌的强大技术。然而，其成功与否很大程度上取决于一个关键的设计决策：如何设置偏置势（即“伞”）的位置。本练习将指导你通过一个简化的谐波模型，从第一性原理出发推导相邻“伞窗”之间的最佳间距，确保它们之间有足够的统计重叠，从而将统计力学的理论概念与实际的模拟设计直接联系起来 [@problem_id:2772126]。", "problem": "考虑一个一维反应坐标 $\\xi$，其基础无偏平均力势 (PMF) $W(\\xi)$ 在感兴趣的区域内是局部简谐的，即 $W(\\xi) \\approx \\frac{1}{2}\\kappa(\\xi-\\xi^{\\ast})^{2}$，其中 $\\kappa>0$ 是一个恒定的曲率，$\\xi^{\\ast}$ 是一个固定的参考位置。你计划使用一族简谐偏置势 $U_{i}(\\xi)=\\frac{1}{2}k(\\xi-\\xi_{i})^{2}$ 来进行伞形采样，其中所有窗口共享相同的力常数 $k>0$，并且它们的中心是均匀间隔的，$\\xi_{i+1}-\\xi_{i}=\\Delta$。系统处于温度 $T$下，所有能量均为摩尔能量（每摩尔）。假设在每个伞形窗口内都处于正则平衡，并且 $W(\\xi)$ 的简谐近似在相邻窗口间均成立。\n\n通过巴氏系数 (Bhattacharyya coefficient) $\\mathrm{BC}_{i,i+1}$ 来定义任意两个相邻偏置系综 $i$ 和 $i+1$ 之间的统计重叠，\n$$\n\\mathrm{BC}_{i,i+1} \\equiv \\int_{-\\infty}^{\\infty}\\sqrt{p_{i}(\\xi)\\,p_{i+1}(\\xi)}\\,d\\xi,\n$$\n其中 $p_{i}(\\xi)\\propto \\exp\\!\\big(-\\beta\\,[W(\\xi)+U_{i}(\\xi)]\\big)$ 是窗口 $i$ 中的平衡概率密度，且 $\\beta = (R T)^{-1}$，$R$ 是以 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}$ 为单位的普适气体常数。\n\n仅从玻尔兹曼分布、$W(\\xi)$ 和 $U_{i}(\\xi)$ 的简谐形式以及上述 $\\mathrm{BC}_{i,i+1}$ 的定义出发，推导出一个解析表达式，用于计算当目标重叠 $\\mathrm{BC}_{i,i+1}=1/2$ 时所需的窗口间距 $\\Delta$。然后，使用以下参数计算该间距：\n- $k = 10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}$,\n- $\\kappa = 2.00\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}$,\n- $T = 300.0\\ \\mathrm{K}$,\n- $R = 8.314462618\\times 10^{-3}\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}$.\n\n将你计算出的 $\\Delta$ 的最终数值结果保留四位有效数字，并以纳米为单位表示。", "solution": "该问题已经过验证，被认为是具有科学依据、良定且自洽的。所提供的数据对于推导出唯一解是充分且一致的。我们开始进行推导。\n\n目标是推导出一个窗口间距 $\\Delta$ 的表达式，该间距能使相邻伞形采样窗口之间的统计重叠达到 $\\mathrm{BC}_{i,i+1} = 1/2$，然后计算其数值。\n\n首先，我们描述在第 $i$ 个伞形窗口中系统的平衡概率密度 $p_{i}(\\xi)$。系统在该窗口中经历的总势能是无偏平均力势 $W(\\xi)$ 和偏置势 $U_i(\\xi)$ 的和。\n$$\nV_{i}(\\xi) = W(\\xi) + U_{i}(\\xi)\n$$\n给定 $W(\\xi)$ 和 $U_i(\\xi)$ 的简谐近似：\n$$\nV_{i}(\\xi) = \\frac{1}{2}\\kappa(\\xi-\\xi^{\\ast})^{2} + \\frac{1}{2}k(\\xi-\\xi_{i})^{2}\n$$\n其中 $\\kappa$ 和 $k$ 是力常数，$\\xi^{\\ast}$ 是无偏PMF的最小值点，$\\xi_i$ 是第 $i$ 个偏置势的中心。我们展开二次项：\n$$\nV_{i}(\\xi) = \\frac{1}{2}\\kappa(\\xi^2 - 2\\xi\\xi^{\\ast} + (\\xi^{\\ast})^2) + \\frac{1}{2}k(\\xi^2 - 2\\xi\\xi_i + \\xi_i^2)\n$$\n$$\nV_{i}(\\xi) = \\frac{1}{2}(\\kappa+k)\\xi^2 - (\\kappa\\xi^{\\ast} + k\\xi_i)\\xi + \\frac{1}{2}(\\kappa(\\xi^{\\ast})^2 + k\\xi_i^2)\n$$\n该表达式是关于 $\\xi$ 的一个二次函数，可以通过配方法将其重写为标准的简谐形式。\n$$\nV_{i}(\\xi) = \\frac{1}{2}(\\kappa+k)\\left(\\xi - \\frac{\\kappa\\xi^{\\ast} + k\\xi_i}{\\kappa+k}\\right)^2 + C_i\n$$\n其中 $C_i$ 是一个不依赖于坐标 $\\xi$ 的常数项。因此，每个窗口中的总势是简谐的，其组合力常数为 $k_{tot} = \\kappa+k$，最小值点位于：\n$$\n\\mu_i = \\frac{\\kappa\\xi^{\\ast} + k\\xi_i}{\\kappa+k}\n$$\n平衡概率密度 $p_i(\\xi)$ 遵循玻尔兹曼分布，$p_i(\\xi) \\propto \\exp(-\\beta V_i(\\xi))$，其中 $\\beta = (RT)^{-1}$。由于 $V_i(\\xi)$ 是 $\\xi$ 的二次函数，因此 $p_i(\\xi)$ 是一个高斯（正态）分布：\n$$\np_{i}(\\xi) = \\mathcal{N}(\\xi | \\mu_i, \\sigma_{tot}^2) = \\frac{1}{\\sqrt{2\\pi\\sigma_{tot}^2}}\\exp\\left(-\\frac{(\\xi-\\mu_i)^2}{2\\sigma_{tot}^2}\\right)\n$$\n方差 $\\sigma_{tot}^2$ 对所有窗口都相同，由下式给出：\n$$\n\\sigma_{tot}^2 = \\frac{1}{\\beta k_{tot}} = \\frac{1}{\\beta(\\kappa+k)} = \\frac{RT}{\\kappa+k}\n$$\n接下来，我们计算两个相邻窗口 $i$ 和 $i+1$ 之间的巴氏系数 (Bhattacharyya coefficient) $\\mathrm{BC}_{i,i+1}$。\n$$\n\\mathrm{BC}_{i,i+1} = \\int_{-\\infty}^{\\infty}\\sqrt{p_{i}(\\xi)\\,p_{i+1}(\\xi)}\\,d\\xi\n$$\n被积函数涉及两个具有相同方差 $\\sigma_{tot}^2$ 但不同均值 $\\mu_i$ 和 $\\mu_{i+1}$ 的高斯密度的几何平均值。\n$$\n\\sqrt{p_{i}(\\xi)p_{i+1}(\\xi)} = \\sqrt{\\frac{1}{2\\pi\\sigma_{tot}^2}\\exp\\left(-\\frac{(\\xi-\\mu_i)^2}{2\\sigma_{tot}^2}\\right)\\exp\\left(-\\frac{(\\xi-\\mu_{i+1})^2}{2\\sigma_{tot}^2}\\right)}\n$$\n$$\n= \\frac{1}{\\sqrt{2\\pi\\sigma_{tot}^2}}\\exp\\left(-\\frac{(\\xi-\\mu_i)^2 + (\\xi-\\mu_{i+1})^2}{4\\sigma_{tot}^2}\\right)\n$$\n指数的分子可以重新整理为：\n$$\n(\\xi-\\mu_i)^2 + (\\xi-\\mu_{i+1})^2 = 2\\xi^2 - 2\\xi(\\mu_i+\\mu_{i+1}) + \\mu_i^2+\\mu_{i+1}^2 = 2\\left(\\xi-\\frac{\\mu_i+\\mu_{i+1}}{2}\\right)^2 + \\frac{1}{2}(\\mu_i-\\mu_{i+1})^2\n$$\n将此代回几何平均值的表达式中：\n$$\n\\sqrt{p_{i}(\\xi)p_{i+1}(\\xi)} = \\frac{1}{\\sqrt{2\\pi\\sigma_{tot}^2}}\\exp\\left(-\\frac{2\\left(\\xi-\\frac{\\mu_i+\\mu_{i+1}}{2}\\right)^2 + \\frac{1}{2}(\\mu_i-\\mu_{i+1})^2}{4\\sigma_{tot}^2}\\right)\n$$\n$$\n= \\exp\\left(-\\frac{(\\mu_i-\\mu_{i+1})^2}{8\\sigma_{tot}^2}\\right) \\frac{1}{\\sqrt{2\\pi\\sigma_{tot}^2}}\\exp\\left(-\\frac{\\left(\\xi-\\frac{\\mu_i+\\mu_{i+1}}{2}\\right)^2}{2\\sigma_{tot}^2}\\right)\n$$\n现在我们对 $\\xi$ 进行积分以获得 $\\mathrm{BC}_{i,i+1}$：\n$$\n\\mathrm{BC}_{i,i+1} = \\exp\\left(-\\frac{(\\mu_i-\\mu_{i+1})^2}{8\\sigma_{tot}^2}\\right) \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi\\sigma_{tot}^2}}\\exp\\left(-\\frac{\\left(\\xi-\\frac{\\mu_i+\\mu_{i+1}}{2}\\right)^2}{2\\sigma_{tot}^2}\\right)d\\xi\n$$\n该积分是一个归一化高斯概率密度在其整个定义域上的积分，其值等于 1。因此：\n$$\n\\mathrm{BC}_{i,i+1} = \\exp\\left(-\\frac{(\\mu_i-\\mu_{i+1})^2}{8\\sigma_{tot}^2}\\right)\n$$\n相邻分布的均值之差为：\n$$\n\\mu_{i+1} - \\mu_i = \\frac{\\kappa\\xi^{\\ast} + k\\xi_{i+1}}{\\kappa+k} - \\frac{\\kappa\\xi^{\\ast} + k\\xi_i}{\\kappa+k} = \\frac{k(\\xi_{i+1}-\\xi_i)}{\\kappa+k} = \\frac{k\\Delta}{\\kappa+k}\n$$\n将 $(\\mu_{i+1}-\\mu_i)^2$ 和 $\\sigma_{tot}^2$ 的表达式代入 $\\mathrm{BC}_{i,i+1}$ 的公式中：\n$$\n\\mathrm{BC}_{i,i+1} = \\exp\\left(-\\frac{1}{8} \\left(\\frac{k\\Delta}{\\kappa+k}\\right)^2 \\frac{1}{\\sigma_{tot}^2}\\right) = \\exp\\left(-\\frac{k^2\\Delta^2}{8(\\kappa+k)^2} \\beta(\\kappa+k)\\right)\n$$\n$$\n\\mathrm{BC}_{i,i+1} = \\exp\\left(-\\frac{\\beta k^2 \\Delta^2}{8(\\kappa+k)}\\right)\n$$\n我们给定的条件是重叠必须为 $\\mathrm{BC}_{i,i+1} = 1/2$。\n$$\n\\frac{1}{2} = \\exp\\left(-\\frac{\\beta k^2 \\Delta^2}{8(\\kappa+k)}\\right)\n$$\n对两边取自然对数：\n$$\n\\ln\\left(\\frac{1}{2}\\right) = -\\ln(2) = -\\frac{\\beta k^2 \\Delta^2}{8(\\kappa+k)}\n$$\n$$\n\\ln(2) = \\frac{\\beta k^2 \\Delta^2}{8(\\kappa+k)}\n$$\n现在我们可以求解 $\\Delta^2$：\n$$\n\\Delta^2 = \\frac{8(\\kappa+k)\\ln(2)}{\\beta k^2}\n$$\n代入 $\\beta = (RT)^{-1}$，我们得到窗口间距 $\\Delta$ 的最终解析表达式：\n$$\n\\Delta = \\sqrt{\\frac{8RT(\\kappa+k)\\ln(2)}{k^2}} = \\frac{\\sqrt{8RT(\\kappa+k)\\ln(2)}}{k}\n$$\n最后，我们代入给定的数值：\n$k = 10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}$\n$\\kappa = 2.00\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}$\n$T = 300.0\\ \\mathrm{K}$\n$R = 8.314462618\\times 10^{-3}\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}$\n\n首先，计算乘积 $RT$：\n$RT = (8.314462618\\times 10^{-3}\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{K}^{-1}) \\times (300.0\\ \\mathrm{K}) = 2.4943387854\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}$\n接下来，计算项 $\\kappa+k$：\n$\\kappa+k = 2.00\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2} + 10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2} = 12.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}$\n现在，将这些值代入 $\\Delta$ 的表达式中：\n$$\n\\Delta = \\frac{\\sqrt{8 \\times (2.4943387854\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}) \\times (12.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}) \\times \\ln(2)}}{10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}}\n$$\n$$\n\\Delta = \\frac{\\sqrt{239.456523398\\ \\mathrm{kJ}^2\\ \\mathrm{mol}^{-2}\\ \\mathrm{nm}^{-2} \\times \\ln(2)}}{10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}}\n$$\n$$\n\\Delta = \\frac{\\sqrt{165.9868065\\ \\mathrm{kJ}^2\\ \\mathrm{mol}^{-2}\\ \\mathrm{nm}^{-2}}}{10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}}\n$$\n$$\n\\Delta = \\frac{12.8835959\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-1}}{10.0\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\\ \\mathrm{nm}^{-2}} = 1.28835959\\ \\mathrm{nm}\n$$\n按要求保留四位有效数字，得到：\n$$\n\\Delta \\approx 1.288\\ \\mathrm{nm}\n$$", "answer": "$$\n\\boxed{1.288}\n$$", "id": "2772126"}, {"introduction": "在完成一系列如前一个练习所设计的偏置模拟后，下一步是整合所有收集到的数据，以重建出底层的、无偏置的自由能形貌。本练习提供了一个实际的编程任务，要求你实现加权直方图分析方法（WHAM），这是完成此项任务的基石算法 [@problem_id:2455424]。你将亲手构建一个工具，将原始的模拟输出转化为具有物理意义的自由能曲线，从而掌握从数据到科学洞见的关键一步。", "problem": "配体的内部旋转围绕一个二面角坐标被建模为一个一维周期性坐标 $\\theta \\in [-\\pi,\\pi)$，单位为弧度。该配体位于一个深埋的、近乎对称的结合口袋中，这会产生一个未知的、以热能单位 $k_\\mathrm{B}T$（无量纲）计量的折合平均力势 $u_0(\\theta)$。在没有外部偏置的平衡状态下，概率密度为 $p_0(\\theta) \\propto \\exp\\!\\left(-u_0(\\theta)\\right)$，自由能剖面为 $F(\\theta) = -\\ln p_0(\\theta) + \\text{constant}$，单位为 $k_\\mathrm{B}T$。进行了一组 $M$ 个谐波偏置实验，每个实验施加一个偏置 $u_i(\\theta)$，并从相应的偏置分布 $p_i(\\theta) \\propto \\exp\\!\\left(-[u_0(\\theta)+u_i(\\theta)]\\right)$ 中收集 $N_i$ 个独立的 $\\theta$ 平衡样本。谐波偏置为 $u_i(\\theta) = \\tfrac{k}{2}\\,d(\\theta,\\theta_i)^2$，其刚度 $k$ 的单位为 $k_\\mathrm{B}T/\\mathrm{rad}^2$，其中 $d(\\theta,\\theta_i)$ 是最小镜像角距离，单位为弧度，定义为 $d(\\theta,\\theta_i) = \\mathrm{wrap}(\\theta-\\theta_i)$，而 $\\mathrm{wrap}(x)$ 通过加或减 $2\\pi$ 的倍数将 $x$ 映射到 $(-\\pi,\\pi]$ 区间内。对于每个实验 $i \\in \\{1,\\ldots,M\\}$，将采样得到的角度在一个划分 $[-\\pi,\\pi)$ 的 $B$ 个均匀区间（bin）上形成直方图 $h_{i,j}$。这些区间由 $j \\in \\{0,1,\\ldots,B-1\\}$ 索引，区间宽度为 $\\Delta\\theta = 2\\pi/B$，区间中心为 $\\theta_j = -\\pi + (j+\\tfrac{1}{2})\\Delta\\theta$。计数 $h_{i,j}$ 是窗口 $i$ 中第 $j$ 个区间的样本数。\n\n您的任务是从这些偏置直方图中估计无偏置的自由能剖面 $F(\\theta_j)$（可相差一个加性常数），然后为每个测试用例计算两个标量值：\n- 势垒高度 $\\Delta F_\\mathrm{bar}$，指在 $\\theta \\approx 0$ 和 $\\theta \\approx \\pi$ 附近的两个最低极小值之间的势垒。其定义为从 $\\theta=0$ 到 $\\theta=\\pi$ 的直接路径（即 $\\theta \\in [0,\\pi]$）上 $F(\\theta)$ 的最大值，减去在邻域 $\\theta \\in [-\\pi/3,\\pi/3]$（$\\theta \\approx 0$ 附近）和满足 $|d(\\theta,\\pi)| \\le \\pi/3$ 的 $\\theta$（$\\theta \\approx \\pi$ 附近）内找到的两个极小值中较小的一个。\n- 不对称性 $\\Delta F_\\mathrm{asym} = F_\\mathrm{min}(\\text{近 } \\pi) - F_\\mathrm{min}(\\text{近 } 0)$，其中 $F_\\mathrm{min}(\\text{近 } 0)$ 是 $F(\\theta)$ 在 $\\theta \\in [-\\pi/3,\\pi/3]$ 上的最小值，而 $F_\\mathrm{min}(\\text{近 } \\pi)$ 是 $F(\\theta)$ 在满足 $|d(\\theta,\\pi)| \\le \\pi/3$ 的角度上的最小值。\n\n角度必须以弧度处理。能量和自由能必须以 $k_\\mathrm{B}T$ 为单位（无量纲）处理。最终报告的标量结果是无量纲浮点数。\n\n为使问题完全确定且可测试，您将根据已知的折合势 $u_0(\\theta)$，使用以下构造方法为每个测试用例确定性地生成直方图：\n- 底层的折合势为 $u_0(\\theta) = -\\alpha \\cos(2\\theta) - \\beta \\cos(\\theta)$，其中参数 $(\\alpha,\\beta)$ 已给定。\n- 窗口数量为 $M = 8$，偏置中心为 $\\theta_i = -\\pi + i \\cdot \\frac{\\pi}{4}$，其中 $i \\in \\{0,1,2,3,4,5,6,7\\}$。\n- 区间数量 $B$ 根据每个测试用例指定，区间均匀分布在 $[-\\pi,\\pi)$ 上。\n- 对于每个窗口 $i$，偏置为 $u_i(\\theta) = \\tfrac{k}{2}\\,d(\\theta,\\theta_i)^2$，刚度 $k$ 已指定。\n- 对于每个窗口 $i$，区间 $j$ 的精确期望离散概率为\n$$\np_{i,j} = \\frac{\\exp\\!\\left(-[u_0(\\theta_j) + u_i(\\theta_j)]\\right)}{\\sum_{m=0}^{B-1} \\exp\\!\\left(-[u_0(\\theta_m) + u_i(\\theta_m)]\\right)}.\n$$\n- 直方图计数是通过将期望计数 $N_i p_{i,j}$ 四舍五入为整数来确定性地设置的，以使窗口 $i$ 中的总数恰好为 $N_i$。具体来说，对于每个窗口 $i$，首先计算实数向量 $\\mathbf{e}_i$，其分量为 $e_{i,j} = N_i p_{i,j}$，对每个分量取底以获得整数，然后通过将剩余的 $N_i - \\sum_j \\lfloor e_{i,j}\\rfloor$ 个计数加到具有最大小数部分 $e_{i,j} - \\lfloor e_{i,j}\\rfloor$ 的区间上（若小数部分完全相等，则优先选择 $j$ 较小的区间）来分配这些计数。\n\n您必须实现一个程序，该程序：\n- 使用上述确定性过程构建直方图。\n- 仅使用直方图 $h_{i,j}$、已知的偏置 $u_i(\\theta_j)$、计数 $N_i$ 和区间中心 $\\theta_j$ 来估计无偏置自由能 $F(\\theta_j)$（可相差一个加性常数）。\n- 按定义计算 $\\Delta F_\\mathrm{bar}$ 和 $\\Delta F_\\mathrm{asym}$。\n\n测试套件。实现您的程序以运行以下三个案例并汇总其结果：\n- 案例 1（理想路径，强双峰且近乎对称）：\n  - $\\alpha = 1.5$, $\\beta = 0.1$。\n  - $k = 20$。\n  - $B = 60$。\n  - $(N_0,\\ldots,N_7) = (2000,1500,2500,1800,2200,1600,2400,1700)$。\n- 案例 2（边界情况，近乎平坦的口袋）：\n  - $\\alpha = 0.15$, $\\beta = 0.0$。\n  - $k = 8$。\n  - $B = 60$。\n  - $(N_0,\\ldots,N_7) = (1200,1200,1200,1200,1200,1200,1200,1200)$。\n- 案例 3（不对称情况，极小值顺序相反）：\n  - $\\alpha = 1.6$, $\\beta = -0.3$。\n  - $k = 25$。\n  - $B = 60$。\n  - $(N_0,\\ldots,N_7) = (3000,1800,2200,2000,2600,1800,2400,1600)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含列表的列表形式的三个结果对：\n- 输出必须是表示 $[\\,[\\Delta F_\\mathrm{bar}^{(1)},\\Delta F_\\mathrm{asym}^{(1)}],\\,[\\Delta F_\\mathrm{bar}^{(2)},\\Delta F_\\mathrm{asym}^{(2)}],\\,[\\Delta F_\\mathrm{bar}^{(3)},\\Delta F_\\mathrm{asym}^{(3)}]\\,]$ 的单行字符串，其中上标表示案例编号。\n- 所有角度在内部必须以弧度为单位，报告的值是以 $k_\\mathrm{B}T$ 为单位的浮点数（无量纲）。不应打印任何单位。", "solution": "所提出的问题是计算统计力学中一个明确定义的练习，具体而言，是从一组偏置模拟中重建平均力势（PMF）或自由能剖面。这是分子动力学中的一项标准任务，通常使用加权直方图分析方法（WHAM）或多态贝内特接受率（MBAR）方法来解决。该问题提供了所有必要的数据和一种确定性程序来生成类似模拟的直方图，从而使其成为一个完整且可解的数值问题。\n该问题是有效的，因为它具有科学依据、问题明确且客观。它没有违反任何物理学或数学的基本原理。所有参数和过程都以足够的精度进行了描述，可以得到唯一的解。\n\n我的方法将按如下方式实现该过程：\n1. 对于每个测试用例，首先生成所需的输入数据。这包括将坐标 $\\theta$ 离散化，在此网格上计算真实的底层势 $u_0(\\theta)$ 和偏置势 $u_i(\\theta)$，然后根据精确的偏置概率，使用指定的确定性舍入程序构建直方图 $h_{i,j}$。\n2. 获得直方图 $h_{i,j}$、样本数 $N_i$ 和偏置势 $u_i(\\theta_j)$ 后，下一步是计算无偏置的自由能剖面 $F(\\theta_j)$。我将使用 WHAM 方程，它提供了一组自洽关系来找到自由能剖面的最优估计。方程如下：\n    $$\n    e^{-F_j} = C \\cdot \\frac{\\sum_{i=1}^M h_{i,j}}{\\sum_{i=1}^M N_i e^{f_i - u_{i,j}}}\n    $$\n    $$\n    e^{-f_i} = \\sum_{j=0}^{B-1} e^{-F_j - u_{i,j}}\n    $$\n    在这里，$F_j$ 是区间 $j$ 的自由能，$u_{i,j} = u_i(\\theta_j)$ 是窗口 $i$ 在区间 $j$ 中的偏置势，$f_i$ 是单个模拟的自由能。$C$ 是一个归一化常数。这些方程通过迭代求解，直到 $F_j$ 和 $f_i$ 的值收敛。为确保数值稳定性，涉及指数求和的计算在对数空间中使用 log-sum-exp 技巧进行。\n\n3. 获得收敛的自由能剖面 $F(\\theta_j)$ 后，最后一步是提取所要求的两个标量：势垒高度 $\\Delta F_\\mathrm{bar}$ 和不对称性 $\\Delta F_\\mathrm{asym}$。这需要确定与问题中指定的角度区域相对应的正确索引范围：$\\theta \\in [0,\\pi]$ 用于势垒顶部，$\\theta \\in [-\\pi/3, \\pi/3]$ 用于零点附近的极小值，以及 $|d(\\theta,\\pi)| \\le \\pi/3$ 用于 $\\pi$ 附近的极小值。在这些特定的索引范围内找到剖面 $F(\\theta_j)$ 的极小值和极大值，并根据其定义计算最终的标量。\n\n一个关键部分是正确处理角度 $\\theta$ 的周期性边界条件。必须使用一个函数来计算最小镜像角距离 $d(\\theta, \\phi)$，该函数按规定将差值 $\\theta-\\phi$ 正确地包裹到区间 $(-\\pi, \\pi]$ 中。然后将其平方以计算谐波偏置能。\n\n整个过程封装在一个 Python 脚本中，该脚本处理三个测试用例中的每一个，并按照指定的输出格式将最终结果格式化为单个字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the data generation, analysis, and final output formatting.\n    \"\"\"\n\n    def wrap_to_pi(x):\n        \"\"\"\n        Wraps angle(s) x to the interval (-pi, pi].\n\n        Parameters:\n        x (float or np.ndarray): The angle(s) in radians.\n\n        Returns:\n        float or np.ndarray: The wrapped angle(s).\n        \"\"\"\n        y = np.mod(x, 2 * np.pi)\n        # For an array y, np.where is used for conditional assignment.\n        # if y > pi, it is mapped to y - 2*pi, resulting in the range (-pi, 0).\n        # if y = pi, it is unchanged, giving the range [0, pi].\n        # The combination of these two is (-pi, pi].\n        y = np.where(y > np.pi, y - 2 * np.pi, y)\n        return y\n\n    def process_case(alpha, beta, k, B, N_i):\n        \"\"\"\n        Processes a single test case: generates histograms, runs WHAM, and computes results.\n        \"\"\"\n        # 1. Setup grid and parameters\n        M = 8  # Number of windows\n        delta_theta = 2 * np.pi / B\n        theta_j = -np.pi + (np.arange(B) + 0.5) * delta_theta\n        theta_i_centers = -np.pi + np.arange(M) * np.pi / 4\n\n        # 2. Generate histograms deterministically\n        histograms = np.zeros((M, B), dtype=np.int64)\n        bias_potentials = np.zeros((M, B))\n        \n        # Calculate unbiased potential on the grid\n        u0_j = -alpha * np.cos(2 * theta_j) - beta * np.cos(theta_j)\n\n        for i in range(M):\n            # Calculate bias potential for window i\n            d_theta = wrap_to_pi(theta_j - theta_i_centers[i])\n            ui_j = 0.5 * k * d_theta**2\n            bias_potentials[i, :] = ui_j\n\n            # Calculate total potential and exact probabilities for bin j in window i\n            total_potential = u0_j + ui_j\n            log_probs = -total_potential\n            log_probs -= logsumexp(log_probs)  # Normalize using logsumexp\n            probs = np.exp(log_probs)\n            \n            # Calculate expected counts\n            expected_counts = N_i[i] * probs\n            \n            # Deterministic rounding procedure\n            floored_counts = np.floor(expected_counts)\n            h_ij = floored_counts.astype(np.int64)\n            # Use round() to handle potential float precision issues\n            remainder = int(round(N_i[i] - np.sum(floored_counts)))\n            \n            if remainder > 0:\n                fractional_parts = expected_counts - floored_counts\n                j_indices = np.arange(B)\n                # Sort indices by fractional part (descending) and then index (ascending) to break ties\n                sorted_indices = np.lexsort((j_indices, -fractional_parts))\n                indices_to_increment = sorted_indices[:remainder]\n                h_ij[indices_to_increment] += 1\n            \n            histograms[i, :] = h_ij\n\n        # 3. Reconstruct free energy profile using WHAM\n        F = np.zeros(B)  # Initial guess for free energies\n        N_i_arr = np.array(N_i)\n        total_counts_j = np.sum(histograms, axis=0)\n        \n        # Bins with zero counts will have infinite free energy\n        non_zero_counts = total_counts_j > 0\n        log_total_counts_j = np.full(B, -np.inf)\n        if np.any(non_zero_counts):\n            log_total_counts_j[non_zero_counts] = np.log(total_counts_j[non_zero_counts])\n\n        # WHAM iterative solution\n        max_iter = 10000\n        tolerance = 1e-9\n        for _ in range(max_iter):\n            F_old = F.copy()\n            \n            # Update f_i (dimensionless free energies of each simulation)\n            f = -logsumexp(-F[np.newaxis, :] - bias_potentials, axis=1)\n\n            # Update F_j (unbiased free energy profile)\n            log_sum_exp_term = logsumexp(np.log(N_i_arr)[:, np.newaxis] + f[:, np.newaxis] - bias_potentials, axis=0)\n            F = -log_total_counts_j + log_sum_exp_term\n\n            # Normalize F to prevent drift and handle any infinities\n            finite_F = F[np.isfinite(F)]\n            if finite_F.size > 0:\n                F -= np.min(finite_F)\n            \n            # Check for convergence\n            if np.all(np.isclose(F, F_old, atol=tolerance, rtol=0)):\n                break\n\n        # 4. Analyze the free energy profile F\n        # Define index ranges for analysis using boolean masks\n        range_0_pi_mask = theta_j >= 0\n        range_near_0_mask = (theta_j >= -np.pi/3)  (theta_j = np.pi/3)\n        range_near_pi_mask = (theta_j = -2*np.pi/3) | (theta_j >= 2*np.pi/3)\n\n        # Ensure ranges are not empty before taking min/max\n        if not np.any(range_near_0_mask) or not np.any(range_near_pi_mask) or not np.any(range_0_pi_mask):\n             return [np.nan, np.nan] # Should not happen with B=60\n\n        # Find minima and maxima in the specified ranges\n        F_min_near_0 = np.min(F[range_near_0_mask])\n        F_min_near_pi = np.min(F[range_near_pi_mask])\n        F_barrier_top = np.max(F[range_0_pi_mask])\n\n        # Calculate final scalar quantities\n        delta_F_bar = F_barrier_top - min(F_min_near_0, F_min_near_pi)\n        delta_F_asym = F_min_near_pi - F_min_near_0\n        \n        return [delta_F_bar, delta_F_asym]\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1: happy path, strongly bimodal and nearly symmetric\n        {\n            \"alpha\": 1.5, \"beta\": 0.1, \"k\": 20, \"B\": 60,\n            \"N_i\": [2000, 1500, 2500, 1800, 2200, 1600, 2400, 1700]\n        },\n        # Case 2: boundary case, nearly flat pocket\n        {\n            \"alpha\": 0.15, \"beta\": 0.0, \"k\": 8, \"B\": 60,\n            \"N_i\": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200]\n        },\n        # Case 3: asymmetric case with reversed minimum ordering\n        {\n            \"alpha\": 1.6, \"beta\": -0.3, \"k\": 25, \"B\": 60,\n            \"N_i\": [3000, 1800, 2200, 2000, 2600, 1800, 2400, 1600]\n        }\n    ]\n    \n    results = []\n    for case_params in test_cases:\n        result = process_case(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2455424"}, {"introduction": "副本交换分子动力学（REMD）通过在多个温度下并行模拟系统来有效克服能量壁垒，但其表观上的高效率（如高的交换接受率）有时可能具有误导性。本练习挑战你对一个常见但微妙的失效模式进行批判性思考，即当副本在温度空间中有效穿梭，但构象采样却停滞不前时，背后可能的原因是什么 [@problem_id:2455419]。通过这个诊断性问题，你将培养评估增强采样模拟是否真正有效的关键洞察力。", "problem": "使用复本交换分子动力学（REMD）在显式溶剂中模拟一种蛋白质，其中多个不同温度下的复本交换温度以在扩展系综中维持细致平衡。测量得到所有相邻温度对之间的平均交换接受率一致地高，然而在很长的挂钟时间内，最低温度复本中的蛋白质没有表现出折叠转变，并仍然被困在一个错误折叠的系综中。以下哪项可以合理解释这一结果，且不与观察到的高接受率相矛盾？选择所有适用项。\n\nA. 在显式溶剂中，总势能 $U_\\text{tot}$ 主要由溶剂自由度决定，因此相邻复本在 $U_\\text{tot}$ 上有很强的重叠，容易交换；然而，蛋白质的构象能量 $U_\\text{prot}$ 在不同温度间的重叠很差，因此交换并不能有效转化为对蛋白质构象自由度的加热。\n\nB. 高交换接受率本身就意味着遍历采样；因此，缺乏折叠必定表明Metropolis接受准则的编码存在错误。\n\nC. 交换尝试间隔 $ \\tau_\\text{ex}$ 远小于蛋白质在给定温度下的结构弛豫时间 $ \\tau_\\text{relax}$，因此在温度交换后，构象没有足够的复本内时间在新温度下达到平衡，下一次交换就已发生，这导致了温度空间中的扩散，但没有发生构型势垒的穿越。\n\nD. 因为温度REMD中的Metropolis准则依赖于动能，施加完整约束（例如，键长约束）会人为地提高接受率，同时抑制势垒穿越。\n\nE. 使用超过必要数量的复本总是会通过阻止温度扩散来降低采样效率，这解释了尽管接受率很高但缺乏折叠的现象。", "solution": "现在将对问题陈述进行严格验证。\n\n### 步骤1：提取已知条件\n-   一个蛋白质在显式溶剂中进行模拟。\n-   模拟方法是复本交换分子动力学（REMD）。\n-   存在多个不同温度下的复本。\n-   复本交换温度以在扩展系综中维持细致平衡。\n-   测得的所有相邻温度对之间的平均交换接受率“一致地高”。\n-   在很长的挂钟时间内，最低温度复本中的蛋白质没有表现出折叠转变。\n-   蛋白质仍然被困在一个错误折叠的系综中。\n-   问题要求为这一结果找到一个合理的解释，且该解释不与高接受率相矛盾。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题描述了计算化学中使用一种标准且广泛使用的增强采样技术——复本交换分子动力学（REMD）——的场景。显式溶剂、势能、温度、折叠转变和接受率等概念都是分子动力学和统计力学领域的基础。所呈现的场景——高交换率伴随着差的构象采样——是REMD实际应用中一个已知且经常被讨论的挑战。该问题牢固地建立在已确立的科学原理之上。\n-   **提问清晰**：该问题提问清晰。它提出了一个具体的观察结果（高交换率，差的采样），并要求从一组选项中找出可能的物理原因。可以进行明确的逻辑分析来评估每个提议原因的有效性。\n-   **客观性**：语言在需要时是精确且定量的（例如，“一致地高”的接受率）。它不包含主观或基于观点的陈述。它描述了一个物理观察现象，并要求一个科学的解释。\n\n### 步骤3：结论与行动\n问题陈述在科学上是合理的、提问清晰且客观的。它描述了在一个主要计算方法的应用中一个现实且并非无足轻重的难题。问题是有效的。我们将继续推导解决方案。\n\n问题的核心在于温度空间中的高效随机行走（由“一致地高”的交换接受率表明）与蛋白质构象空间中低效的随机行走（由缺乏折叠转变表明）之间的明显矛盾。\n\n两个复本 $i$ 和 $j$（其逆温度分别为 $\\beta_i = 1/(k_B T_i)$ 和 $\\beta_j = 1/(k_B T_j)$，势能分别为 $U_i$ 和 $U_j$）之间温度交换的接受概率的基本公式由扩展系综的Metropolis准则给出：\n$$ P_{\\text{acc}} = \\min\\left(1, e^{(\\beta_i - \\beta_j)(U_i - U_j)}\\right) = \\min\\left(1, e^{\\Delta\\beta \\Delta U}\\right) $$\n“高”接受率，例如在相邻复本 $i$ 和 $i+1$ 之间（其中 $\\beta_i  \\beta_{i+1}$），意味着指数项 $(\\beta_i - \\beta_{i+1})(U_i - U_{i+1})$ 经常接近于零或为负。这促进了复本在温度空间中的扩散。这种扩散的目的是让一个处于低温的构型能够移动到高温，克服一个势能垒，然后以一个新的构象盆地返回到低温。问题陈述指出，这第二部分——克服构象势垒——并未发生。我们必须分析其原因。\n\n现在，我们评估每个选项。\n\n**A. 在显式溶剂中，总势能 $U_\\text{tot}$ 主要由溶剂自由度决定，因此相邻复本在 $U_\\text{tot}$ 上有很强的重叠，容易交换；然而，蛋白质的构象能量 $U_\\text{prot}$ 在不同温度间的重叠很差，因此交换并不能有效转化为对蛋白质构象自由度的加热。**\n\n这个陈述描述了REMD在显式溶剂中一个众所周知的病态问题。系统的总势能是各项之和：$U_\\text{tot} = U_\\text{protein} + U_\\text{protein-solvent} + U_\\text{solvent-solvent}$。在一个典型的模拟盒子中，溶剂分子的数量远超过蛋白质中的原子数。因此，势能及其涨落主要由溶剂-溶剂相互作用主导。接受概率 $P_\\text{acc}$ 依赖于 $U_\\text{tot}$。相邻温度的总势能分布 $P(U_\\text{tot})$ 可能有显著重叠，这仅仅是由于溶剂能量的巨大涨落，从而导致高接受率。然而，仅溶质（蛋白质）本身的能量分布 $P(U_\\text{protein})$ 在相同的两个温度之间可能重叠很差。在这种情况下，一次交换可能因为溶剂分子的有利构型而被接受，而不是因为蛋白质进入了一个在更高温度下更容易热力学上可及的构象。蛋白质的构象实际上“隐藏”在溶剂巨大的能量景观中。温度随机行走与期望的构象随机行走发生了脱钩。这是一个正确且合理的解释。\n\n**结论：正确**\n\n**B. 高交换接受率本身就意味着遍历采样；因此，缺乏折叠必定表明Metropolis接受准则的编码存在错误。**\n\n这个陈述根本上是错误的。高交换接受率仅仅意味着复本正在有效地穿越温度阶梯。这是实现构象空间遍历采样的必要但不充分条件。遍历性要求系统能够随时间访问所有可及的微观状态。REMD旨在加速这一过程，但高交换率并不能保证其成功。采样构象的失败可能源于物理原因，如选项A和C中所述，而不仅仅是代码中的错误。声称高接受率*意味着*遍历性是一种严重的过度简化，并且在事实上是错误的。\n\n**结论：不正确**\n\n**C. 交换尝试间隔 $ \\tau_\\text{ex}$ 远小于蛋白质在给定温度下的结构弛豫时间 $ \\tau_\\text{relax}$，因此在温度交换后，构象没有足够的复本内时间在新温度下达到平衡，下一次交换就已发生，这导致了温度空间中的扩散，但没有发生构型势垒的穿越。**\n\n这个陈述描述了REMD中另一个经典的低效问题。要使REMD有效，一个交换到更高温度的构象必须有足够的时间进行演化并穿越能量势垒，然后才能交换回较低的温度。这种构象变化的特征时间是弛豫时间 $\\tau_\\text{relax}$。如果交换尝试之间的时间 $\\tau_\\text{ex}$ 远小于 $\\tau_\\text{relax}$（即 $\\tau_\\text{ex} \\ll \\tau_\\text{relax}$），构象就没有足够的时间发生显著变化。系统将在温度空间中快速扩散，但构型将对其各自的温度指数保持“冻结”或“卡住”的状态。温度中的随机行走没有与构象景观的探索有效地耦合。这导致了问题中描述的确切情景：高接受率但没有构象上的进展。\n\n**结论：正确**\n\n**D. 因为温度REMD中的Metropolis准则依赖于动能，施加完整约束（例如，键长约束）会人为地提高接受率，同时抑制势垒穿越。**\n\n这个陈述的前提是错误的。标准的温度REMD接受概率 $P_{\\text{acc}} = \\min(1, \\exp(\\Delta\\beta \\Delta U))$ 明确依赖于*势能*的差异（$\\Delta U$）和逆温度的差异（$\\Delta\\beta$）。它不依赖于复本的动能。在从正则配分函数推导交换概率的过程中，被假定仅是温度和自由度数量的函数的动能项被消掉了。由于其“依赖于动能”的前提是不正确的，整个论点是无效的。\n\n**结论：不正确**\n\n**E. 使用超过必要数量的复本总是会通过阻止温度扩散来降低采样效率，这解释了尽管接受率很高但缺乏折叠的现象。**\n\n这个说法与事实恰恰相反。温度扩散是指给定复本在一组温度中的随机行走。这种扩散的效率受限于相邻温度之间的接受率。对于一个固定的温度范围，增加复本数量意味着相邻复本之间的温差 $\\Delta T$ 会变小。更小的 $\\Delta T$ 会导致相邻复本的势能分布 $P(U)$ 之间有更大的重叠，这反过来会*增加*交换接受率。因此，使用更多的复本通常会*改善*温度扩散，而不是阻止它。虽然使用过多的复本在计算上是浪费的，但它不会“阻止温度扩散”，也无法解释观察到的问题。差的温度扩散是由使用过*少*的复本引起的，这会导致低接受率。\n\n**结论：不正确**\n\n总之，选项A和C提出了两个不同且有充分文献记载的物理原因，解释了为什么REMD模拟可以表现出高交换接受率，却未能增强构象采样。", "answer": "$$\\boxed{AC}$$", "id": "2455419"}]}