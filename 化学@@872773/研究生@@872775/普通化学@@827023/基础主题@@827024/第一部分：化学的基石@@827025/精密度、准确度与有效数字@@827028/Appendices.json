{"hands_on_practices": [{"introduction": "在科学计算中，正确处理有效数字的规则不仅仅是形式上的要求，更是保证结论可靠性的基础。本练习将通过一个接近化学计量的反应场景，生动地展示过早进行数字修约这一常见错误，会如何导致对限制性反应物的错误判断，从而得出错误的产率预测。通过这个实践，你将深刻理解在计算过程中保留额外“保护位”的重要性 [@problem_id:2952416]。", "problem": "一种气相氧化反应通过混合一氧化氮和氧气来进行，其配平的化学方程式如下\n$$2\\,\\text{NO}(g)+\\text{O}_2(g)\\longrightarrow 2\\,\\text{NO}_2(g).$$\n一位化学家通过称量 $m_{\\text{NO}}=30.15603\\,\\mathrm{g}$ 的一氧化氮和 $m_{\\text{O}_2}=16.080595\\,\\mathrm{g}$ 的氧气，制备了接近化学计量比的装料。在所有计算中使用以下摩尔质量：$M_{\\text{NO}}=30.006\\,\\mathrm{g \\cdot mol^{-1}}$ 和 $M_{\\text{O}_2}=31.998\\,\\mathrm{g \\cdot mol^{-1}}$。假设没有副反应，且限量反应物完全消耗。\n\n从化学计量的基本原子守恒基础出发，并遵循有效数字的操作规则，即中间量应保留保护数字，只对最终报告的量进行四舍五入，按以下步骤进行：\n\n1. 使用最佳实践（使用给定数据的全部可用精度，不对中间的摩尔数进行四舍五入），通过从未四舍五入的摩尔数中正确识别限量反应物，确定生成的二氧化氮的理论量 $n_{\\text{NO}_2,\\text{correct}}$（单位：$\\mathrm{mol}$）。\n2. 使用一种旨在说明陷阱的故意不当实践，首先在进行任何比较之前，将每种反应物的计算初始摩尔量四舍五入到恰好 $3$ 位有效数字，然后根据这些四舍五入的摩尔数识别限量反应物，并计算相应预测的产物量 $n_{\\text{NO}_2,\\text{wrong}}$（单位：$\\mathrm{mol}$）。\n3. 计算由过早四舍五入引入的相对差异的大小，\n$$\\delta=\\left|\\frac{n_{\\text{NO}_2,\\text{wrong}}-n_{\\text{NO}_2,\\text{correct}}}{n_{\\text{NO}_2,\\text{correct}}}\\right|.$$\n\n将最终量 $\\delta$ 表示为无量纲小数。将您的最终答案四舍五入到四位有效数字。", "solution": "出发点是配平方程式中蕴含的原子守恒定律。对于一个初始摩尔量为 $n_{\\mathrm{A}}^{0}$ 和 $n_{\\mathrm{B}}^{0}$ 的一般反应 $\\nu_{\\text{A}}\\text{A}+\\nu_{\\text{B}}\\text{B}\\rightarrow \\nu_{\\text{P}}\\text{P}$，可以达到的反应进度 $\\xi$ 受化学计量限制，其中\n$$\\xi=\\min\\!\\left(\\frac{n_{\\text{A}}^{0}}{\\nu_{\\text{A}}},\\frac{n_{\\text{B}}^{0}}{\\nu_{\\text{B}}}\\right),\\quad n_{\\text{P}}=\\nu_{\\text{P}}\\xi,$$\n这反映了产物量受化学计量比例较小的反应物的限制。对于本例，\n$$2\\,\\text{NO}+\\text{O}_2\\rightarrow 2\\,\\text{NO}_2,$$\n因此 $\\nu_{\\text{NO}}=2$，$\\nu_{\\text{O}_2}=1$，且 $\\nu_{\\text{NO}_2}=2$。有效数字的操作规则是在中间步骤中保留所有可用数字，仅对最终报告的量进行四舍五入，以避免因过早四舍五入而引入人为偏差。\n\n步骤 1（最佳实践，不过早四舍五入）：\n- 根据给定的质量和摩尔质量计算初始摩尔量：\n$$n_{\\text{NO}}=\\frac{m_{\\text{NO}}}{M_{\\text{NO}}}=\\frac{30.15603\\,\\mathrm{g}}{30.006\\,\\mathrm{g \\cdot mol^{-1}}}.$$\n因为根据构造，在所示精度下 $30.15603=30.006\\times 1.00500$，所以计算结果为\n$$n_{\\text{NO}}=1.00500\\,\\mathrm{mol}.$$\n类似地，\n$$n_{\\text{O}_2}=\\frac{m_{\\text{O}_2}}{M_{\\text{O}_2}}=\\frac{16.080595\\,\\mathrm{g}}{31.998\\,\\mathrm{g \\cdot mol^{-1}}}\\approx 0.50255\\,\\mathrm{mol},$$\n因为 $31.998\\times 0.50255=16.0805949\\,\\mathrm{g}$，这与 $16.080595\\,\\mathrm{g}$ 在最后一位所示数字上一致。\n- 比较化学计量需求：\n$$2\\,n_{\\text{O}_2}=2\\times 0.50255=1.00510\\,\\text{mol NO 当量}。$$\n我们发现 $n_{\\text{NO}}=1.00500  2\\,n_{\\text{O}_2}=1.00510$，因此在使用未四舍五入的摩尔数时，一氧化氮是（非常轻微的）限量反应物。\n- 因此，生成的二氧化氮的理论摩尔数等于消耗的一氧化氮的摩尔数，即\n$$n_{\\text{NO}_2,\\text{correct}}=n_{\\text{NO}}=1.00500\\,\\mathrm{mol}.$$\n\n步骤 2（不当实践：在识别限量反应物前过早地四舍五入到 $3$ 位有效数字）：\n- 首先将每种反应物的初始摩尔量四舍五入到恰好 $3$ 位有效数字：\n$$n_{\\text{NO, rounded}}=\\text{round}_{3\\,\\text{sf}}(1.00500\\,\\mathrm{mol})=1.01\\,\\mathrm{mol},$$\n$$n_{\\text{O_2, rounded}}=\\text{round}_{3\\,\\text{sf}}(0.50255\\,\\mathrm{mol})=0.503\\,\\mathrm{mol}.$$\n- 基于这些四舍五入的量进行比较：\n$$2\\,n_{\\text{O_2, rounded}}=2\\times 0.503=1.006\\,\\mathrm{mol}.$$\n因为 $1.006  1.01$，四舍五入后的数据会错误地指示氧气是限量反应物。\n- 因此，在这种不当程序下预测的产物量为\n$$n_{\\text{NO}_2,\\text{wrong}}=2\\,n_{\\text{O_2, rounded}}=1.006\\,\\mathrm{mol}.$$\n\n步骤 3（量化由过早四舍五入引入的差异）：\n- 计算相对差异的大小\n$$\\delta=\\left|\\frac{n_{\\text{NO}_2,\\text{wrong}}-n_{\\text{NO}_2,\\text{correct}}}{n_{\\text{NO}_2,\\text{correct}}}\\right|=\\left|\\frac{1.006-1.00500}{1.00500}\\right|=\\frac{0.00100}{1.00500}.$$\n- 进行数值计算，并按要求将最终结果四舍五入到四位有效数字：\n$$\\delta\\approx 9.950248756\\times 10^{-4} \\longrightarrow \\delta=9.950\\times 10^{-4}.$$\n将其写成小数形式，\n$$\\delta=0.0009950,$$\n这有四位有效数字。\n\n此计算表明，在几乎完全符合化学计量的混合物中，过早的四舍五入会颠倒限量反应物的身份，并使预测产率产生 $10^{-3}$ 数量级的偏差，远超过四舍五入单位本身，从而说明了为什么必须将保护数字保留到最后。", "answer": "$$\\boxed{0.0009950}$$", "id": "2952416"}, {"introduction": "实验科学的核心是量化不确定性。当我们使用带有不确定性的测量值来计算新的物理量时，必须能够评估最终结果的不确定性。本练习将指导你应用不确定性传播的标准法则，为一个通过分光光度法测定的化学平衡常数计算其相对不确定性，这对于任何依赖间接测量的化学分析都至关重要 [@problem_id:2952265]。", "problem": "一种溶质在水溶液中的可逆二聚反应在恒定温度下通过分光光度法进行监测，$$2\\,\\mathrm{R} \\rightleftharpoons \\mathrm{P},$$ 其以摩尔浓度表示的平衡常数定义为 $$K = \\frac{c_{\\mathrm{P}}}{\\left(c_{\\mathrm{R}}\\right)^{2}},$$ 其中 $c_{\\mathrm{P}}$ 和 $c_{\\mathrm{R}}$ 分别表示产物和反应物的平衡摩尔浓度。浓度 $c_{\\mathrm{P}}$ 是通过单波长比尔-朗伯法定量的校准吸光度获得的，而 $c_{\\mathrm{R}}$ 是通过单独的多波长拟合获得的；这两种测定在统计上是独立的。将报告的不确定度视为仅由随机效应引起的相对标准不确定度（一个标准差），并假设不确定度足够小，使得一阶线性化有效。相对标准不确定度为 $$u_{r}\\!\\left(c_{\\mathrm{P}}\\right)=5\\% \\quad\\text{and}\\quad u_{r}\\!\\left(c_{\\mathrm{R}}\\right)=2\\%,$$ 其中，根据定义，$$u_{r}(x)=\\frac{u(x)}{x}$$ 且 $u(x)$ 是 $x$ 的标准不确定度。在这些条件下，计算 $K$ 的相对标准不确定度，记为 $u_{r}(K)$。将最终答案四舍五入至 $3$ 位有效数字，并以纯小数形式表示（不带百分号）。最终答案必须是一个实数。", "solution": "题目陈述已经过仔细审查，被认为是科学上合理的、问题提出得当的，并且没有矛盾或含糊之处。其前提是物理上现实的，并且为获得唯一解提供了所有必要信息。该任务是计量学中不确定度传播原理的标准应用，这是实验科学中的一个基本概念。因此，我们开始求解。\n\n问题要求根据推导平衡常数所用的浓度的相对标准不确定度，计算平衡常数 $K$ 的相对标准不确定度 $u_r(K)$。平衡常数 $K$ 由以下函数定义：\n$$K = \\frac{c_{\\mathrm{P}}}{\\left(c_{\\mathrm{R}}\\right)^{2}}$$\n其中 $c_{\\mathrm{P}}$ 是产物的摩尔浓度，$c_{\\mathrm{R}}$ 是反应物的摩尔浓度。问题陈述指出 $c_{\\mathrm{P}}$ 和 $c_{\\mathrm{R}}$ 的测量在统计上是独立的。\n\n对于形式为 $Y = f(X_1, X_2, \\dots, X_n)$ 的一般函数，其中输入量 $X_i$ 是独立的，组合标准不确定度的平方 $u^2(Y)$ 由不确定度传播定律给出：\n$$u^2(Y) = \\sum_{i=1}^{n} \\left(\\frac{\\partial f}{\\partial X_i}\\right)^2 u^2(X_i)$$\n这可以用相对不确定度来表示。对于幂的乘积形式的函数，例如 $Y = C X_1^{a_1} X_2^{a_2} \\cdots X_n^{a_n}$，其中 $C$ 是一个没有不确定度的常数，相对标准不确定度的平方 $u_r^2(Y)$ 简化为各个相对标准不确定度平方的加权和：\n$$u_r^2(Y) = \\left(\\frac{u(Y)}{Y}\\right)^2 = \\sum_{i=1}^{n} a_i^2 \\left(\\frac{u(X_i)}{X_i}\\right)^2 = \\sum_{i=1}^{n} a_i^2 u_r^2(X_i)$$\n平衡常数就是这种形式，可以写成 $K = c_{\\mathrm{P}}^{1} c_{\\mathrm{R}}^{-2}$。变量是 $c_{\\mathrm{P}}$ 和 $c_{\\mathrm{R}}$，对应的指数是 $a_{\\mathrm{P}} = 1$ 和 $a_{\\mathrm{R}} = -2$。\n\n应用相对不确定度传播的简化规则，$K$ 的相对标准不确定度的平方是：\n$$u_r^2(K) = (a_{\\mathrm{P}})^2 u_r^2(c_{\\mathrm{P}}) + (a_{\\mathrm{R}})^2 u_r^2(c_{\\mathrm{R}})$$\n代入指数 $a_{\\mathrm{P}} = 1$ 和 $a_{\\mathrm{R}} = -2$：\n$$u_r^2(K) = (1)^2 u_r^2(c_{\\mathrm{P}}) + (-2)^2 u_r^2(c_{\\mathrm{R}})$$\n$$u_r^2(K) = u_r^2(c_{\\mathrm{P}}) + 4 u_r^2(c_{\\mathrm{R}})$$\n问题给出了以下相对标准不确定度：\n$$u_{r}(c_{\\mathrm{P}}) = 5\\% = 0.05$$\n$$u_{r}(c_{\\mathrm{R}}) = 2\\% = 0.02$$\n我们将这些数值代入导出的方程中：\n$$u_r^2(K) = (0.05)^2 + 4(0.02)^2$$\n计算过程如下：\n$$u_r^2(K) = 0.0025 + 4(0.0004)$$\n$$u_r^2(K) = 0.0025 + 0.0016$$\n$$u_r^2(K) = 0.0041$$\n为了求得相对标准不确定度 $u_r(K)$，我们取该值的平方根：\n$$u_r(K) = \\sqrt{0.0041}$$\n$$u_r(K) \\approx 0.06403124237$$\n问题要求将最终答案四舍五入至 $3$ 位有效数字。第一个非零数字是 $6$，所以三位有效数字是 $6$、$4$ 和 $0$。\n$$u_r(K) = 0.0640$$\n这就是以纯小数形式表示的最终数值答案。", "answer": "$$\\boxed{0.0640}$$", "id": "2952265"}, {"introduction": "虽然不确定性传播的解析方法（如一阶泰勒展开）非常有用，但当模型复杂或数据受到物理约束（例如浓度不能为负）时，其应用会受到限制。蒙特卡洛模拟提供了一种功能强大且灵活的替代方案，能够自然地处理这些复杂情况。本练习将通过一个编程实践，向你展示如何利用蒙特卡洛方法来分析一个受“截断”约束（即测量值必须为非负数）的光谱分析数据，并比较其与理想化非截断模型在结果上的差异 [@problem_id:2952283]。", "problem": "在普通化学中，您正在为一个基于光谱的浓度测定法建模其测量和报告过程，该过程受到一个具有物理意义的删失约束。检测器返回一个经过基线校正的吸光度 $A$，根据吸收物理学和校准流程，该值必须满足 $A \\ge 0$。删失前的噪声可以用均值为 $\\mu_A$、标准差为 $\\sigma_A$ 的正态分布来建模，这是许多仪器噪声源广泛接受的经验模型。分析物的浓度 $c$ 通过遵循比尔-朗伯定律的线性校准与吸光度相关联：$c = A / (\\varepsilon \\, \\ell)$，其中 $\\varepsilon$ 是摩尔吸光系数，$\\ell$ 是光程长度。您将演示蒙特卡洛传播如何通过从正确的截断分布中抽样来直接处理 $A \\ge 0$ 的删失，并且您将展示与未删失模型相比，删失如何影响 $c$ 的均值和中心 $95\\%$ 置信区间。\n\n您可以使用的基本原理：大数定律、期望值和分位数的定义、正态分布的性质以及比尔-朗伯定律。不要使用任何截断正态矩的闭式公式。您必须通过蒙特卡洛抽样进行近似。\n\n使用的定义：\n- 随机变量 $Z$ 的期望值为 $\\mathbb{E}[Z]$。\n- $Z$ 样本的中心 $95\\%$ 置信区间是概率为 $0.025$ 和 $0.975$ 的经验分位数之间的区间。\n- 对于 $A$ 的删失（截断）正态分布，通过从正态分布中抽样并拒绝 $A  0$ 的值来强制执行 $A \\ge 0$；在编程上，您必须直接从截断分布中抽样以避免效率低下。\n- 为了以有效数字报告，设 $m$ 为 $c$ 均值的蒙特卡洛估计，设 $L$ 和 $U$ 为中心 $95\\%$ 置信区间的下界和上界。定义半宽 $h = (U - L)/2$。为了创建一个符合普通化学中常见不确定度报告实践的报告，将 $h$ 四舍五入到一位有效数字，然后将 $m$ 四舍五入到与四舍五入后的 $h$ 相同的小数位。然后，将四舍五入后的区间报告为 $[m - h_{\\mathrm{rounded}}, \\, m + h_{\\mathrm{rounded}}]$。这样产生的值与基于不确定度的有效数字规则一致。所有浓度必须以 $\\mathrm{mol \\cdot L^{-1}}$ 表示。\n\n您的程序必须为每个测试用例执行以下两种蒙特卡洛传播，使用相同的抽样次数 $N$：\n- 未删失模型：从 $\\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽取 $A_{\\mathrm{unc}}$，不强制执行 $A \\ge 0$。\n- 删失模型：从截断到 $A \\ge 0$ 的 $\\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽取 $A_{\\mathrm{cen}}$。\n\n然后通过 $c = A/(\\varepsilon \\, \\ell)$ 转换为浓度以获得样本 $c_{\\mathrm{unc}}$ 和 $c_{\\mathrm{cen}}$。对于每个模型，计算样本均值 $m$、中心 $95\\%$ 置信区间 $[L, U]$、半宽 $h = (U-L)/2$，然后如上定义生成四舍五入后的三元组 $(m_{\\mathrm{rounded}}, L_{\\mathrm{rounded}}, U_{\\mathrm{rounded}})$。\n\n物理单位：\n- 以 $\\mathrm{mol \\cdot L^{-1}}$ 报告和内部计算 $c$，$\\varepsilon$ 的单位为 $\\mathrm{L \\cdot mol^{-1} \\cdot cm^{-1}}$，$\\ell$ 的单位为 $\\mathrm{cm}$，$A$ 无单位。您的最终程序输出必须是代表 $\\mathrm{mol \\cdot L^{-1}}$ 的数值浮点数；不要打印单位。\n\n角度单位不适用。\n\n测试套件：\n每个测试用例使用 $N = 200{,}000$ 次抽样，并使用以下参数集来检验不同的情况。每个用例是一个元组 $(\\mu_A, \\sigma_A, \\varepsilon, \\ell)$。\n- 用例 $1$（远高于删失阈值；删失可忽略不计）：$(\\mu_A = 0.500, \\ \\sigma_A = 0.010, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n- 用例 $2$（接近阈值；删失导致中度偏斜）：$(\\mu_A = 0.050, \\ \\sigma_A = 0.050, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n- 用例 $3$（接近零；强删失效应）：$(\\mu_A = 0.005, \\ \\sigma_A = 0.010, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n- 用例 $4$（负均值；物理约束占主导地位）：$(\\mu_A = -0.002, \\ \\sigma_A = 0.005, \\ \\varepsilon = 12500, \\ \\ell = 1.00)$。\n\n答案规格：\n- 对于每个测试用例，计算两个四舍五入后的三元组 $(m_{\\mathrm{unc}}, L_{\\mathrm{unc}}, U_{\\mathrm{unc}})$ 和 $(m_{\\mathrm{cen}}, L_{\\mathrm{cen}}, U_{\\mathrm{cen}})$，每个都以 $\\mathrm{mol \\cdot L^{-1}}$ 为单位，并根据上述有效数字规则进行四舍五入。\n- 将每个测试用例的结果汇总为一个包含六个浮点数的列表，顺序为：$[m_{\\mathrm{unc}}, L_{\\mathrm{unc}}, U_{\\mathrm{unc}}, m_{\\mathrm{cen}}, L_{\\mathrm{cen}}, U_{\\mathrm{cen}}]$。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个列表，该列表包含按上述顺序排列的四个用例的列表。例如，外部结构必须类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，其中包含数值浮点数。\n\n科学真实性：\n- 使用固定的随机种子以确保结果可复现。\n- 不要假设截断矩有任何闭式形式；通过抽样进行近似。\n- 确保通过从截断正态分布中抽样来实现删失。\n\n您的程序必须只产生指定的单行输出，不得有其他内容。所有数值答案均代表浓度，单位为 $\\mathrm{mol \\cdot L^{-1}}$，并根据所述有效数字规则进行四舍五入。", "solution": "所提出的问题要求在一个常见的分析化学场景中，对一个受物理原因驱动的删失约束进行定量分析。我们需要比较一个理想化的、未删失的测量模型与一个更现实的、删失的模型，在后一个模型中，物理量吸光度不能为负。该比较将使用蒙特卡洛不确定度传播方法进行。所述问题在科学上是合理的，定义明确，并为严格的计算求解提供了所有必要信息。我们将着手处理。\n\n问题的核心在于不确定度如何从一个带噪声的吸光度测量值 $A$ 传播到一个导出的浓度值 $c$。这些量之间的关系由比尔-朗伯定律给出：\n$$ c = \\frac{A}{\\varepsilon \\ell} $$\n为方便起见，我们为每个实验装置定义一个常数 $k = \\varepsilon \\ell$，因此 $c = A/k$。\n\n问题为吸光度测量 $A$ 指定了两种模型：\n\n1.  **未删失模型**：这是一个理想化模型，其中测量噪声被假定为完全高斯分布。我们通过从正态分布 $A_{\\mathrm{unc}} \\sim \\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽样，生成大量的吸光度样本 $\\{A_{\\mathrm{unc}, i}\\}_{i=1}^N$。该模型可能产生非物理的负吸光度值。\n\n2.  **删失模型**：该模型包含了吸光度不能为负的物理约束 $A \\ge 0$。我们通过从相同的正态分布 $\\mathcal{N}(\\mu_A, \\sigma_A^2)$ 中抽样，但将其截断在区间 $[0, \\infty)$ 内，来生成 $N$ 个样本 $\\{A_{\\mathrm{cen}, i}\\}_{i=1}^N$。这是一个根本上非负的测量过程的正确统计表示。在编程上，这是通过从截断正态分布中抽样来实现的，这比朴素的拒绝/接受循环更有效率。\n\n对于这两种模型，每个吸光度样本 $A_i$ 都被转换为浓度样本 $c_i = A_i/k$。这将产生两组浓度样本 $\\{c_{\\mathrm{unc}, i}\\}$ 和 $\\{c_{\\mathrm{cen}, i}\\}$。\n\n根据这些样本，我们按规定进行统计分析。对每一组：\n- 平均浓度 $m$ 被估计为样本均值：$m \\approx \\frac{1}{N} \\sum_{i=1}^{N} c_i$。\n- 中心 $95\\%$ 置信区间 $[L, U]$ 由浓度样本在概率 $p=0.025$ 和 $p=0.975$ 处的经验分位数确定。\n- 基于指定的四舍五入程序构建一个易于报告的区间。计算置信区间的半宽 $h = (U - L)/2$，并将其四舍五入到一位有效数字，得到 $h_{\\mathrm{rounded}}$。然后将均值 $m$ 四舍五入到与 $h_{\\mathrm{rounded}}$ 相同的小数位，得到 $m_{\\mathrm{rounded}}$。最终报告的区间是 $[m_{\\mathrm{rounded}} - h_{\\mathrm{rounded}}, m_{\\mathrm{rounded}} + h_{\\mathrm{rounded}}]$，报告的三元组是 $(m_{\\mathrm{rounded}}, L_{\\mathrm{rounded}}, U_{\\mathrm{rounded}})$。\n\n该实现使用 `numpy` 进行数组操作和随机数生成，使用 `scipy.stats.truncnorm` 从截断正态分布中进行高效抽样。`truncnorm` 的参数来源于问题中的 $\\mu_A$、$\\sigma_A$ 和下截断界 $a=0$。相应的标准化下界是 $\\alpha = (a - \\mu_A) / \\sigma_A = -\\mu_A / \\sigma_A$，而上界是 $\\beta = \\infty$。固定的随机种子确保了蒙特卡洛模拟的可复现性。\n\n所选的测试用例将说明删失的不同影响：\n- **用例 1 ($\\mu_A = 0.500, \\sigma_A = 0.010$)**：这里 $\\mu_A \\gg \\sigma_A$，因此 $A0$ 的概率可以忽略不计。删失和未删失的结果应该几乎相同。\n- **用例 2 ($\\mu_A = 0.050, \\sigma_A = 0.050$)**：当 $\\mu_A = \\sigma_A$ 时，未删失分布中有相当一部分是负值。删失将截去这部分尾部，导致更高的平均浓度和右偏分布。\n- **用例 3 ($\\mu_A = 0.005, \\sigma_A = 0.010$)**：当 $\\mu_A  \\sigma_A$ 时，删失效应更加显著。删失分布的均值将显著移向正值，并且与母正态分布相比，其分布将高度扭曲。\n- **用例 4 ($\\mu_A = -0.002, \\sigma_A = 0.005$)**：真实平均吸光度为负，这种情况可能由于基线过度校正而发生。未删失模型会得出一个非物理的负平均浓度。而删失模型正确反映了物理现实，只产生非负吸光度，从而得到一个具有物理意义的正平均浓度。这个案例凸显了正确物理建模的至关重要性。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import truncnorm\nimport math\n\ndef calculate_and_round(c_samples):\n    \"\"\"\n    Calculates the mean, 95% credible interval, and rounded reporting values.\n    \"\"\"\n    m = np.mean(c_samples)\n    L, U = np.quantile(c_samples, [0.025, 0.975])\n    h = (U - L) / 2.0\n\n    if h == 0:\n        # This case is not expected with N=200,000 but handled for robustness.\n        # If uncertainty is zero or negative, no rounding rule is applicable.\n        return m, m, m\n\n    # Round h to one significant figure\n    power_h = math.floor(math.log10(h)) if h > 0 else 0\n    factor_h = 10**power_h\n    h_rounded = round(h / factor_h) * factor_h\n\n    # If h_rounded becomes 0 (e.g., h=0.04 would round to 0.04).\n    # This logic is robust.\n    \n    # Round m to the same decimal place as h_rounded\n    if h_rounded == 0:\n        # Safeguard for theoretical robustness.\n        m_rounded = m\n    else:\n        # The 'decimal place' is determined by the magnitude of h_rounded's least significant digit\n        power_m_round = math.floor(math.log10(abs(h_rounded)))\n        m_rounded = round(m, -int(power_m_round))\n\n    L_rounded = m_rounded - h_rounded\n    U_rounded = m_rounded + h_rounded\n    \n    return m_rounded, L_rounded, U_rounded\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations and print results.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(0)\n    \n    # Number of Monte Carlo draws\n    N = 200000\n\n    # Test suite: tuples of (mu_A, sigma_A, epsilon, ell)\n    test_cases = [\n        (0.500, 0.010, 12500, 1.00),\n        (0.050, 0.050, 12500, 1.00),\n        (0.005, 0.010, 12500, 1.00),\n        (-0.002, 0.005, 12500, 1.00),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mu_A, sigma_A, epsilon, ell = case\n        k = epsilon * ell\n\n        # Uncensored model\n        A_unc = np.random.normal(loc=mu_A, scale=sigma_A, size=N)\n        c_unc = A_unc / k\n        unc_triple = calculate_and_round(c_unc)\n\n        # Censored model\n        a_std = (0 - mu_A) / sigma_A\n        b_std = np.inf\n        A_cen = truncnorm.rvs(a=a_std, b=b_std, loc=mu_A, scale=sigma_A, size=N)\n        c_cen = A_cen / k\n        cen_triple = calculate_and_round(c_cen)\n\n        # Aggregate results for this case\n        case_results = [*unc_triple, *cen_triple]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    # Using repr() for canonical string representation of floats.\n    output_parts = []\n    for res_list in all_results:\n        output_parts.append(f\"[{','.join(map(repr, res_list))}]\")\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2952283"}]}