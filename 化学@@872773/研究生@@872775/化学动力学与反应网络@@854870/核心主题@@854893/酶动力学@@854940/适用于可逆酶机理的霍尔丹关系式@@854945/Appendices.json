{"hands_on_practices": [{"introduction": "这项实践旨在确立霍尔丹关系式 (Haldane relationship) 的根本地位，它并非一个简单的近似，而是连接动力学与热力学的基本定律。该练习将直接挑战一个常见但可能错误的直觉：即一个强烈倾向于生成产物的反应（即具有很大的平衡常数 $K_{\\mathrm{eq}}$）就意味着其逆向最大反应速率 $V_r$ 可以忽略不计。通过一个直接的计算 [@problem_id:2686032]，你将发现热力学为速率比 $V_r/V_f$ 设定了一个严格的、非零的确定值，从而加深对微观可逆性原理的理解。", "problem": "一个单底物、单产物的酶催化反应是可逆的，并且在准稳态条件和微观可逆性（细致平衡）下，遵循标准的可逆米氏动力学。其宏观动力学参数为正向和反向最大速率 $V_f$ 和 $V_r$（对于总酶浓度 $E_T$，有 $V_f = k_{\\mathrm{cat},f} E_T$ 和 $V_r = k_{\\mathrm{cat},r} E_T$），以及底物和产物的米氏常数，分别为 $K_S$ 和 $K_P$。总化学转化 $S \\rightleftharpoons P$ 的热力学平衡常数（EC）$K_{\\mathrm{eq}}$ 是有限的且很大。不应先验地假设任何“不可逆”近似。\n\n仅从以下原理出发：(i) 在热力学平衡时，对于满足 $P/S = K_{\\mathrm{eq}}$ 的浓度，净反应速率必须为零；(ii) 动力学机制是热力学一致的（微观可逆性），请确定对于此单-单机制，将 $V_r/V_f$ 与 $K_{\\mathrm{eq}}$、$K_S$ 和 $K_P$ 联系起来的最严格的热力学约束。然后，使用 $K_S = 0.5\\,\\mathrm{mM}$，$K_P = 5\\,\\mathrm{mM}$ 和 $K_{\\mathrm{eq}} = 10^5$，评估对于大而有限的 $K_{\\mathrm{eq}}$，常用的近似 $V_r \\approx 0$ 在热力学上是否可容许。如果坚持使用建模容差 $V_r/V_f \\le \\varepsilon$ 作为“证明” $V_r \\approx 0$ 合理性的标准，那么为避免与热力学矛盾，$\\varepsilon$ 必须超过哪个数值？\n\n选择以下最佳陈述。\n\nA. 不。对于任何有限的 $K_{\\mathrm{eq}}$，热力学一致性强制要求一个严格为正的比率 $V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$。当 $K_S = 0.5\\,\\mathrm{mM}$，$K_P = 5\\,\\mathrm{mM}$ 且 $K_{\\mathrm{eq}} = 10^5$ 时，可得 $V_r/V_f = 10^{-4}$。因此 $V_r$ 不能被视为恒等于零；只有在奇异极限 $K_{\\mathrm{eq}} \\to \\infty$（或 $K_P/K_S \\to 0$）下才允许 $V_r = 0$。任何容差都必须满足 $\\varepsilon \\ge 10^{-4}$。\n\nB. 是。由于 $K_{\\mathrm{eq}}$ 很大，不存在独立于浓度的 $V_r/V_f$ 的热力学下界；只需要 $P \\ll K_P$ 就足以证明 $V_r = 0$ 合理。\n\nC. 是。热力学约束是 $V_r/V_f \\le K_{\\mathrm{eq}} (K_P/K_S)$；根据给定的数值，这个上界是 $10^6$，因此反向能力可以被设为零而无损失。\n\nD. 这仅取决于催化速率常数。如果 $k_{\\mathrm{cat},r} \\ll k_{\\mathrm{cat},f}$，那么无论 $K_S$ 和 $K_P$ 为何，$V_r \\approx 0$ 在热力学上都是可容许的。其约束为 $V_r/V_f \\le 1/K_{\\mathrm{eq}}$。", "solution": "该问题陈述在科学上是合理的、提法得当、客观，并包含了推导唯一解所需的所有信息。所涉及的概念——可逆米氏动力学、微观可逆性以及霍尔丹关系——是化学动力学和酶动力学中的基本原理。给定的数值在物理上是合理的。因此，我们可以进行推导。\n\n该问题要求推导可逆单底物、单产物酶反应的动力学参数所受的热力学约束。给定的机制符合标准的可逆米氏动力学。对于反应 $S \\rightleftharpoons P$，在这种条件下的速率定律（$v$）通常表示为：\n$$ v = \\frac{V_f \\frac{[S]}{K_S} - V_r \\frac{[P]}{K_P}}{1 + \\frac{[S]}{K_S} + \\frac{[P]}{K_P}} $$\n这里，$[S]$ 和 $[P]$ 分别是底物和产物的浓度。参数 $V_f$、$V_r$、$K_S$ 和 $K_P$ 分别是正向和反向最大速率以及底物和产物的米氏常数。这些是宏观动力学参数。\n\n问题中陈述的第一个原理是，在热力学平衡时，净反应速率必须为零（$v=0$）。在平衡状态下，底物和产物的浓度（记为 $[S]_{\\mathrm{eq}}$ 和 $[P]_{\\mathrm{eq}}$）是恒定的。在速率方程中令 $v=0$ 可得：\n$$ V_f \\frac{[S]_{\\mathrm{eq}}}{K_S} - V_r \\frac{[P]_{\\mathrm{eq}}}{K_P} = 0 $$\n这必须成立，因为分母总是正的且有限。这个方程可以重排为：\n$$ V_f \\frac{[S]_{\\mathrm{eq}}}{K_S} = V_r \\frac{[P]_{\\mathrm{eq}}}{K_P} $$\n$$ \\frac{V_f}{V_r} = \\frac{[P]_{\\mathrm{eq}}}{[S]_{\\mathrm{eq}}} \\frac{K_S}{K_P} $$\n\n引用的第二个原理是动力学机制必须是热力学一致的。这意味着平衡浓度的比值由总反应 $S \\rightleftharpoons P$ 的热力学平衡常数 $K_{\\mathrm{eq}}$ 给出：\n$$ K_{\\mathrm{eq}} = \\frac{[P]_{\\mathrm{eq}}}{[S]_{\\mathrm{eq}}} $$\n将此定义代入重排后的速率方程，即可得到该机制的霍尔丹关系：\n$$ \\frac{V_f}{V_r} = K_{\\mathrm{eq}} \\frac{K_S}{K_P} $$\n这就是所要求的关系。这是一个直接从第一性原理推导出的等式，因此代表了这些参数之间可能存在的最严格的热力学约束。它不是一个不等式；动力学参数不能取任意值，而是受到总反应热力学的严格约束。\n\n问题要求的是对 $V_r/V_f$ 比率的约束。我们重排霍尔丹关系：\n$$ \\frac{V_r}{V_f} = \\frac{1}{K_{\\mathrm{eq}}} \\frac{K_P}{K_S} $$\n\n现在，我们必须使用给定的数值来计算这个比率：\n- $K_S = 0.5\\,\\mathrm{mM}$\n- $K_P = 5\\,\\mathrm{mM}$\n- $K_{\\mathrm{eq}} = 10^5$\n\n米氏常数的比率是一个无量纲量：\n$$ \\frac{K_P}{K_S} = \\frac{5\\,\\mathrm{mM}}{0.5\\,\\mathrm{mM}} = 10 $$\n将此代入我们关于 $V_r/V_f$ 的表达式中：\n$$ \\frac{V_r}{V_f} = \\frac{10}{10^5} = 10^{-4} $$\n\n这个结果使我们能够评估近似 $V_r \\approx 0$ 的合理性。霍尔丹关系强制规定，对于任何有限的、非零的 $K_{\\mathrm{eq}}$ 和 $K_P/K_S$，比率 $V_r/V_f$ 必须是一个特定的、非零的正值。在这种情况下，$V_r/V_f = 10^{-4}$。因此，将 $V_r$ 恒等于 $0$ 是违反热力学一致性的。近似 $V_r \\approx 0$ 仅在奇异极限下（例如 $K_{\\mathrm{eq}} \\to \\infty$）才严格有效。对于任何大而有限的 $K_{\\mathrm{eq}}$，$V_r$ 必须为非零值。\n\n最后，我们考虑建模容差 $\\varepsilon$，即如果 $V_r/V_f \\le \\varepsilon$，则近似 $V_r \\approx 0$ 被认为是可接受的。为了使模型在热力学上保持一致，所选的这个容差必须能够容纳由霍尔丹关系决定的那个不可协商的值。在我们的例子中，这意味着所选的 $\\varepsilon$ 必须满足：\n$$ \\varepsilon \\ge \\frac{V_r}{V_f} = 10^{-4} $$\n对于给定的参数集，任何 $\\varepsilon  10^{-4}$ 的建模选择都将代表一个热力学上不一致的模型。\n\n我们现在评估每个选项。\n\nA. 不。对于任何有限的 $K_{\\mathrm{eq}}$，热力学一致性强制要求一个严格为正的比率 $V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$。当 $K_S = 0.5\\,\\mathrm{mM}$，$K_P = 5\\,\\mathrm{mM}$ 且 $K_{\\mathrm{eq}} = 10^5$ 时，可得 $V_r/V_f = 10^{-4}$。因此 $V_r$ 不能被视为恒等于零；只有在奇异极限 $K_{\\mathrm{eq}} \\to \\infty$（或 $K_P/K_S \\to 0$）下才允许 $V_r = 0$。任何容差都必须满足 $\\varepsilon \\ge 10^{-4}$。\n该陈述正确地指出了霍尔丹关系为 $V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$。计算结果 $V_r/V_f = 10^{-4}$ 是正确的。对于有限的 $K_{\\mathrm{eq}}$，$V_r$ 不能恒等于零的结论也是正确的。关于容差的条件 $\\varepsilon \\ge 10^{-4}$ 是我们分析的直接结果。该陈述的每一部分都是准确的。\n**结论：正确**\n\nB. 是。由于 $K_{\\mathrm{eq}}$ 很大，不存在独立于浓度的 $V_r/V_f$ 的热力学下界；只需要 $P \\ll K_P$ 就足以证明 $V_r = 0$ 合理。\n这个陈述从根本上是错误的。霍尔丹关系为最大速率之比 $V_r/V_f$ 提供了一个精确值，而不是一个界限。这个值由 $K_{\\mathrm{eq}}$、$K_S$ 和 $K_P$ 决定，与操作浓度 $[S]$ 和 $[P]$ 无关。条件 $[P] \\ll K_P$ 使反向*速率项*（$V_r[P]/K_P$）变小，但它对参数 $V_r$ 本身的值没有影响，而这正是问题所关注的。\n**结论：错误**\n\nC. 是。热力学约束是 $V_r/V_f \\le K_{\\mathrm{eq}} (K_P/K_S)$；根据给定的数值，这个上界是 $10^6$，因此反向能力可以被设为零而无损失。\n所提出的约束 $V_r/V_f \\le K_{\\mathrm{eq}} (K_P/K_S)$ 是不正确的。正确的关系是一个等式，$V_r/V_f = (K_P/K_S)/K_{\\mathrm{eq}}$，这与选项中给出的表达式互为倒数，并且它不是一个不等式。这个选项颠倒了动力学常数和热力学常数之间的关系。基于这个错误前提的后续推理是无效的。\n**结论：错误**\n\nD. 这仅取决于催化速率常数。如果 $k_{\\mathrm{cat},r} \\ll k_{\\mathrm{cat},f}$，那么无论 $K_S$ 和 $K_P$ 为何，$V_r \\approx 0$ 在热力学上都是可容许的。其约束为 $V_r/V_f \\le 1/K_{\\mathrm{eq}}$。\n这个陈述在多个方面都是错误的。比率 $V_r/V_f$ 等于 $k_{\\mathrm{cat},r}/k_{\\mathrm{cat},f}$，但霍尔丹关系表明这个比率并非独立于 $K_S$ 和 $K_P$。声称其可容许性“无论 $K_S$ 和 $K_P$ 为何”是错误的。此外，所提出的约束 $V_r/V_f \\le 1/K_{\\mathrm{eq}}$ 是错误的；它忽略了因子 $K_P/K_S$，并错误地将一个等式表述为不等式。\n**结论：错误**\n\n基于从第一性原理的严格推导，只有选项A是正确的。", "answer": "$$\\boxed{A}$$", "id": "2686032"}, {"introduction": "在热力学一致性原则的基础上，这项实践将解决一个常见的现实挑战：由于测量误差，实验测得的动力学参数往往不能完美地满足霍尔丹关系式。本练习 [@problem_id:2686027] 提供了一种基于计算的实践方法来解决这类不一致问题。你将学习如何运用约束优化技术，找出一组既满足热力学约束又在统计意义上与原始测量值“最接近”的参数，从而将理论认知转化为实际的数据校准能力。", "problem": "假设给定在准稳态近似（QSSA）下一个可逆米氏-门顿酶促反应机理的宏观动力学参数测量值。设正向最大速率为 $V_f$，逆向最大速率为 $V_r$，底物米氏常数为 $K_s$，产物米氏常数为 $K_p$，热力学平衡常数为 $K_{\\mathrm{eq}}$。在微观可逆性和热力学一致性条件下，这些参数之间必须满足一个霍尔丹关系式。从可逆米氏-门顿动力学、准稳态近似的定义，以及热力学平衡时净通量为零且 $K_{\\mathrm{eq}}$ 为平衡活度之比的条件出发，推导出 $V_f$、$V_r$、$K_s$、$K_p$ 和 $K_{\\mathrm{eq}}$ 之间的等式约束。然后，仅使用加权最小二乘法和拉格朗日乘数法的第一性原理，构建一个参数估计问题，通过调整 $V_f$、$V_r$、$K_s$ 和 $K_p$ 来最佳拟合其测量均值，同时精确满足推导出的热力学约束。最后，基于对数空间中的线性误差传播，开发一种计算约束估计值的近似置信区间的方法。\n\n您必须在单个程序中实现以下内容：\n\n- 采用对数参数化 $z = (\\ln V_f,\\ \\ln V_r,\\ \\ln K_s,\\ \\ln K_p)^\\top$，以便隐式处理正性约束。假设为您提供了测量均值 $m = (m_{V_f},\\ m_{V_r},\\ m_{K_s},\\ m_{K_p})$ 及其标准差 $s = (s_{V_f},\\ s_{V_r},\\ s_{K_s},\\ s_{K_p})$。使用一阶误差传播，将每个分量的对数参数的方差近似为 $\\operatorname{Var}(\\ln X) \\approx (s_X/m_X)^2$。\n- 构建并求解对数空间中的加权最小二乘投影问题，该问题在满足霍尔丹关系在对数空间中隐含的单一线性等式约束的条件下，最小化二次型。使用拉格朗日乘数法推导出对数空间中约束估计值的闭式解，然后通过指数化将其转换回原始参数空间。\n- 通过投影掉约束方向，从无约束协方差推导出对数空间中的约束协方差矩阵，然后应用 delta 方法（即通过指数化变换对数空间中的正态区间）计算每个原始参数的双边置信区间。使用与指定置信水平相对应的标准正态分位数。\n\n物理单位：$V_f$ 和 $V_r$ 的单位解释为微摩尔/秒 ($\\mu\\mathrm{M}\\ \\mathrm{s}^{-1}$)，$K_s$ 和 $K_p$ 的单位解释为微摩尔 ($\\mu\\mathrm{M}$)。平衡常数 $K_{\\mathrm{eq}}$ 是无量纲的。您输出的 $V_f$ 和 $V_r$ 应理解为单位 $\\mu\\mathrm{M}\\ \\mathrm{s}^{-1}$，$K_s$ 和 $K_p$ 的单位为 $\\mu\\mathrm{M}$。置信区间必须以相同的单位报告。使用 $0.95$ 的置信水平。\n\n测试套件：您的程序必须处理以下 $3$ 个测试用例。对于每个用例，输入为 $(m_{V_f}, m_{V_r}, m_{K_s}, m_{K_p}, s_{V_f}, s_{V_r}, s_{K_s}, s_{K_p}, K_{\\mathrm{eq}}, \\text{confidence})$。\n\n- 用例 1（接近一致的测量值）：$m_{V_f} = 100$，$m_{V_r} = 25$，$m_{K_s} = 50$，$m_{K_p} = 10$，$s_{V_f} = 5$，$s_{V_r} = 2$，$s_{K_s} = 5$，$s_{K_p} = 1$，$K_{\\mathrm{eq}} = 0.8$，confidence $= 0.95$。\n- 用例 2（不一致的测量值，逆向速率高度精确）：$m_{V_f} = 120$，$m_{V_r} = 30$，$m_{K_s} = 40$，$m_{K_p} = 12$，$s_{V_f} = 6$，$s_{V_r} = 1$，$s_{K_s} = 2$，$s_{K_p} = 3$，$K_{\\mathrm{eq}} = 1.0$，confidence $= 0.95$。\n- 用例 3（一个参数极其精确，其他参数噪声较大）：$m_{V_f} = 80$，$m_{V_r} = 20$，$m_{K_s} = 50$，$m_{K_p} = 25$，$s_{V_f} = 20$，$s_{V_r} = 20$，$s_{K_s} = 20$，$s_{K_p} = 0.1$，$K_{\\mathrm{eq}} = 1.8$，confidence $= 0.95$。\n\n要求的最终输出格式：对于每个测试用例，输出一个列表，其中包含 $4$ 个约束估计值，后跟每个估计值的置信下限和上限，顺序为 $[V_f^\\star, V_r^\\star, K_s^\\star, K_p^\\star, \\mathrm{LCI}(V_f), \\mathrm{UCI}(V_f), \\mathrm{LCI}(V_r), \\mathrm{UCI}(V_r), \\mathrm{LCI}(K_s), \\mathrm{UCI}(K_s), \\mathrm{LCI}(K_p), \\mathrm{UCI}(K_p)]$。您的程序应生成单行输出，其中包含所有用例的结果，格式为方括号内以逗号分隔的列表，每个元素是单个用例的列表（例如：$[ [\\cdots], [\\cdots], [\\cdots] ]$）。\n\n所有计算都必须在您的代码中实现。不允许用户输入；程序必须运行至完成并打印所要求的单行输出。", "solution": "该问题要求推导可逆酶促机理的热力学约束，并将其应用于约束参数估计问题，随后计算调整后参数的置信区间。该方法必须基于第一性原理。\n\n首先，我们为指定的酶促机理推导 Haldane 关系。可逆米氏-门顿机理如下所示：\n$$\nE + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} ES \\underset{k_{-2}}{\\stackrel{k_2}{\\rightleftharpoons}} E + P\n$$\n其中 $E$ 是酶，$S$ 是底物，$P$ 是产物，$ES$ 是酶-底物复合物。微观速率常数为 $k_1, k_{-1}, k_2$ 和 $k_{-2}$。总酶浓度 $[E]_0$ 是恒定的，$[E]_0 = [E] + [ES]$。\n\n在准稳态近似（QSSA）下，假设中间复合物浓度的变化率为零：\n$$\n\\frac{d[ES]}{dt} = k_1[E][S] + k_{-2}[E][P] - (k_{-1} + k_2)[ES] = 0\n$$\n代入 $[E] = [E]_0 - [ES]$ 并求解 $[ES]$ 得：\n$$\n[ES] = \\frac{(k_1[S] + k_{-2}[P])[E]_0}{k_1[S] + k_{-2}[P] + k_{-1} + k_2}\n$$\n净反应速率 $v$ 定义为产物生成速率，即 $v = k_2[ES] - k_{-2}[E][P]$。代入 $[E]$ 和 $[ES]$ 的表达式，得到完整的速率方程：\n$$\nv = \\frac{(k_1 k_2 [S] - k_{-1} k_{-2} [P])[E]_0}{(k_{-1}+k_2) + k_1[S] + k_{-2}[P]}\n$$\n宏观动力学参数是在特定的极限条件下定义的。\n正向最大速率 $V_f$ 是当 $[S] \\to \\infty$ 且 $[P] = 0$ 时的速率。速率方程简化为 $v = \\frac{k_2 [E]_0 [S]}{(k_{-1}+k_2)/k_1 + [S]}$。由此，我们确定：\n$$\nV_f = k_2 [E]_0 \\quad \\text{and} \\quad K_s = \\frac{k_{-1}+k_2}{k_1}\n$$\n逆向最大速率 $V_r$ 是当 $[P] \\to \\infty$ 且 $[S] = 0$ 时速率的绝对值。速率方程变为 $v = \\frac{-k_{-1} [E]_0 [P]}{(k_{-1}+k_2)/k_{-2} + [P]}$，由此我们确定：\n$$\nV_r = k_{-1} [E]_0 \\quad \\text{and} \\quad K_p = \\frac{k_{-1}+k_2}{k_{-2}}\n$$\n在热力学平衡时，净速率 $v=0$。这意味着速率方程的分子必须为零：\n$$\nk_1 k_2 [S]_{eq} - k_{-1} k_{-2} [P]_{eq} = 0\n$$\n热力学平衡常数定义为 $K_{\\mathrm{eq}} = \\frac{[P]_{eq}}{[S]_{eq}}$。因此：\n$$\nK_{\\mathrm{eq}} = \\frac{k_1 k_2}{k_{-1} k_{-2}}\n$$\n现在我们用宏观参数来表示 $K_{\\mathrm{eq}}$。根据它们的定义，我们有以下比率：\n$$\n\\frac{V_f}{V_r} = \\frac{k_2 [E]_0}{k_{-1} [E]_0} = \\frac{k_2}{k_{-1}}\n$$\n$$\n\\frac{K_p}{K_s} = \\frac{(k_{-1}+k_2)/k_{-2}}{(k_{-1}+k_2)/k_1} = \\frac{k_1}{k_{-2}}\n$$\n将这些代入 $K_{\\mathrm{eq}}$ 的表达式，得到 Haldane 关系：\n$$\nK_{\\mathrm{eq}} = \\left(\\frac{k_2}{k_{-1}}\\right) \\left(\\frac{k_1}{k_{-2}}\\right) = \\frac{V_f}{V_r} \\frac{K_p}{K_s}\n$$\n这个基本方程 $\\frac{V_f K_p}{V_r K_s} = K_{\\mathrm{eq}}$ 提供了所需的热力学约束。\n\n接下来，我们构建约束参数估计问题。为了处理动力学参数的正性，我们在对数空间中进行操作。设参数向量为 $p = (V_f, V_r, K_s, K_p)^\\top$。对数变换后的向量为 $z = (\\ln V_f, \\ln V_r, \\ln K_s, \\ln K_p)^\\top$。在此空间中，Haldane 关系变为一个线性等式约束：\n$$\n\\ln V_f - \\ln V_r - \\ln K_s + \\ln K_p = \\ln K_{\\mathrm{eq}}\n$$\n这可以写成 $c^\\top z = d$，其中 $c = (1, -1, -1, 1)^\\top$，$d = \\ln K_{\\mathrm{eq}}$。\n\n给定测量均值 $m = (m_{V_f}, m_{V_r}, m_{K_s}, m_{K_p})^\\top$ 和标准差 $s = (s_{V_f}, s_{V_r}, s_{K_s}, s_{K_p})^\\top$。初始对数参数向量为 $z_0 = \\ln m$。根据一阶误差传播（delta 方法），对数变换后参数的方差为 $\\operatorname{Var}(\\ln X) \\approx (s_X/m_X)^2$。假设测量是独立的，则 $z_0$ 的初始协方差矩阵是对角的：$\\Sigma = \\operatorname{diag}( (s_{V_f}/m_{V_f})^2, \\dots, (s_{K_p}/m_{K_p})^2 )$。问题在于找到向量 $z^*$，使其在满足约束条件的情况下，最小化与 $z_0$ 的加权平方偏差和。这等价于最小化二次型：\n$$\nS(z) = (z - z_0)^\\top \\Sigma^{-1} (z - z_0)\n$$\n约束条件为 $c^\\top z = d$。我们使用拉格朗日乘数 $\\lambda$ 来求解。拉格朗日函数为：\n$$\nL(z, \\lambda) = (z - z_0)^\\top \\Sigma^{-1} (z - z_0) - \\lambda (c^\\top z - d)\n$$\n将关于 $z$ 的梯度设为零，可得：\n$$\n\\nabla_z L = 2 \\Sigma^{-1} (z - z_0) - \\lambda c = 0 \\implies z = z_0 + \\frac{\\lambda}{2} \\Sigma c\n$$\n将此代入约束条件 $c^\\top z = d$：\n$$\nc^\\top (z_0 + \\frac{\\lambda}{2} \\Sigma c) = d \\implies c^\\top z_0 + \\frac{\\lambda}{2} c^\\top \\Sigma c = d\n$$\n求解拉格朗日乘数项：\n$$\n\\frac{\\lambda}{2} = \\frac{d - c^\\top z_0}{c^\\top \\Sigma c}\n$$\n将此代回 $z$ 的表达式，我们得到约束估计值 $z^*$：\n$$\nz^* = z_0 + \\Sigma c \\frac{d - c^\\top z_0}{c^\\top \\Sigma c} = z_0 - \\frac{c^\\top z_0 - d}{c^\\top \\Sigma c} \\Sigma c\n$$\n原始空间中调整后的参数为 $p^* = \\exp(z^*)$。\n\n最后，我们确定置信区间。约束估计值 $z^*$ 是初始估计值 $z_0$ 的线性函数：$z^* = A z_0 + b$，其中 $A = I - \\frac{\\Sigma c c^\\top}{c^\\top \\Sigma c}$。$z^*$ 的协方差矩阵为 $\\Sigma_{z^*} = A \\Sigma A^\\top$。\n$$\n\\Sigma_{z^*} = \\left(I - \\frac{\\Sigma c c^\\top}{c^\\top \\Sigma c}\\right) \\Sigma \\left(I - \\frac{c c^\\top \\Sigma}{c^\\top \\Sigma c}\\right) = \\Sigma - \\frac{\\Sigma c c^\\top \\Sigma}{c^\\top \\Sigma c}\n$$\n$\\Sigma_{z^*}$ 的对角元，记为 $\\sigma^2_{z^*_i}$，是约束对数参数估计值的方差。对数参数 $z^*_i$ 的双边 $(1-\\alpha)$ 置信区间由下式给出：\n$$\n[ z^*_i - q_{1-\\alpha/2} \\sigma_{z^*_i}, \\quad z^*_i + q_{1-\\alpha/2} \\sigma_{z^*_i} ]\n$$\n其中 $q_{1-\\alpha/2}$ 是标准正态分布的相应分位数。对于 $0.95$ 的置信水平，$\\alpha=0.05$ 且 $q_{0.975} \\approx 1.95996$。通过对此区间进行指数化，我们得到原始参数 $p^*_i = \\exp(z^*_i)$ 的置信区间：\n$$\n[ p^*_i \\exp(-q_{1-\\alpha/2} \\sigma_{z^*_i}), \\quad p^*_i \\exp(q_{1-\\alpha/2} \\sigma_{z^*_i}) ]\n$$\n此过程提供了一种完整的、解析推导的方法，用于获得热力学一致的参数估计值及其相关的不确定性。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the constrained parameter estimation problem for a reversible enzyme\n    mechanism according to the Haldane relationship.\n    \"\"\"\n    test_cases = [\n        # Case 1 (near-consistent measurements)\n        (100.0, 25.0, 50.0, 10.0, 5.0, 2.0, 5.0, 1.0, 0.8, 0.95),\n        # Case 2 (inconsistent measurements, reverse velocity highly precise)\n        (120.0, 30.0, 40.0, 12.0, 6.0, 1.0, 2.0, 3.0, 1.0, 0.95),\n        # Case 3 (one parameter extremely precise, others noisy)\n        (80.0, 20.0, 50.0, 25.0, 20.0, 20.0, 20.0, 0.1, 1.8, 0.95),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mVf, mVr, mKs, mKp, sVf, sVr, sKs, sKp, K_eq, confidence = case\n\n        # Vector of measured means and standard deviations\n        m_vec = np.array([mVf, mVr, mKs, mKp])\n        s_vec = np.array([sVf, sVr, sKs, sKp])\n\n        # Step 1: Transform to log-space and determine initial covariance\n        # z0 is the vector of initial log-parameter estimates\n        z0 = np.log(m_vec)\n        \n        # Variances of log-parameters from first-order error propagation\n        # Var(ln(X)) approx (s_X / m_X)^2\n        variances = (s_vec / m_vec)**2\n        \n        # Sigma is the initial diagonal covariance matrix in log-space\n        Sigma = np.diag(variances)\n\n        # Step 2: Define the linear constraint in log-space\n        # The constraint is c.T @ z = d\n        # from ln(Vf) - ln(Vr) - ln(Ks) + ln(Kp) = ln(Keq)\n        c = np.array([1.0, -1.0, -1.0, 1.0])\n        d = np.log(K_eq)\n\n        # Step 3: Solve for the constrained estimates using the derived formula\n        # z_star = z0 - (c.T@z0 - d) / (c.T@Sigma@c) * (Sigma@c)\n        discrepancy = c @ z0 - d\n        c_Sigma_c = c @ Sigma @ c\n        \n        # The adjustment vector that enforces the constraint\n        adjustment = (discrepancy / c_Sigma_c) * (Sigma @ c)\n        \n        # z_star is the constrained log-parameter estimate vector\n        z_star = z0 - adjustment\n\n        # Transform constrained estimates back to the original parameter space\n        p_star = np.exp(z_star)\n\n        # Step 4: Calculate the constrained covariance matrix\n        # Sigma_z_star = Sigma - (Sigma @ c @ c.T @ Sigma) / (c.T @ Sigma @ c)\n        Sigma_c = Sigma @ c\n        # The numerator of the projection matrix is the outer product of (Sigma @ c)\n        proj_numerator = np.outer(Sigma_c, Sigma_c)\n        \n        # Sigma_z_star is the covariance matrix of the constrained estimates\n        Sigma_z_star = Sigma - proj_numerator / c_Sigma_c\n\n        # Step 5: Compute confidence intervals\n        # Variances of constrained log-parameters are the diagonal elements\n        var_z_star = np.diag(Sigma_z_star)\n        \n        # Ensure variances are non-negative due to potential floating point inaccuracies\n        std_z_star = np.sqrt(np.maximum(0, var_z_star))\n\n        # Get the standard normal quantile for the given confidence level\n        q = norm.ppf((1 + confidence) / 2)\n        \n        # Calculate margins of error in log-space\n        log_margins = q * std_z_star\n\n        # Confidence intervals in log-space\n        log_LCI = z_star - log_margins\n        log_UCI = z_star + log_margins\n\n        # Transform confidence intervals back to the original parameter space\n        LCI = np.exp(log_LCI)\n        UCI = np.exp(log_UCI)\n\n        # Step 6: Assemble the results for the current test case\n        case_result = [\n            p_star[0], p_star[1], p_star[2], p_star[3],\n            LCI[0], UCI[0],\n            LCI[1], UCI[1],\n            LCI[2], UCI[2],\n            LCI[3], UCI[3]\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string exactly as specified in the problem\n    case_strings = [f\"[{', '.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{', '.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2686027"}, {"introduction": "最后一项实践将热力学一致性的概念从单个酶提升到代谢网络的系统层面。在生物通路中，多个反应常常相互关联，形成循环。本练习 [@problem_id:2686022] 将阐明，根据细致平衡原理，沿任何闭合循环的所有反应的平衡常数之积必须为1。通过对循环中的每个酶应用霍尔丹关系式，你将构建一个算法来检验整个通路的总体热力学一致性，这是构建可靠的系统生物学模型的关键验证步骤。", "problem": "给定一组排列成化学计量循环的可逆酶催化反应，这些反应在代谢物之间进行。每个反应由单一酶催化，该酶遵循针对单一底物和单一产物的可逆米氏–门登机制。对于每个反应，您都会获得在一致单位下测量的四个宏观动力学参数：正向催化常数（转换数）和底物的正向米氏常数，以及逆向催化常数和产物的逆向米氏常数。这些参数分别表示为 $k_{\\mathrm{cat},f}$（单位 $\\mathrm{s}^{-1}$）、$K_{m,S}$（单位 $\\mu\\mathrm{M}$）、$k_{\\mathrm{cat},r}$（单位 $\\mathrm{s}^{-1}$）和 $K_{m,P}$（单位 $\\mu\\mathrm{M}$）。假设所有 $K_m$ 值使用相同的浓度单位，以使这些参数的比率在量纲上一致，从而得到无量纲的平衡常数。\n\n从化学动力学和反应网络的基本原理出发，具体包括 (i) 催化效率的定义，即在低浓度下反应速率对底物或产物浓度的初始斜率，(ii) 酶-底物和酶-产物复合物的质量作用动力学，以及 (iii) 闭合化学计量循环中的细致平衡热力学约束（对于净化学计量为零的循环，总标准吉布斯自由能变为零），推导出一个关系式，该关系式将单个酶的宏观可逆参数所隐含的标准平衡常数与 $k_{\\mathrm{cat},f}$、$K_{m,S}$、$k_{\\mathrm{cat},r}$ 和 $K_{m,P}$ 联系起来。然后，利用该关系式构建一个算法，该算法对每个化学计量循环，计算沿循环给定反应方向的每个反应所隐含的平衡常数的乘积，并返回一个布尔标志，指示该循环在指定容差内是否热力学一致。将循环不一致性度量定义为该乘积的自然对数的绝对值。如果此度量小于或等于用户指定的容差 $\\tau$（无量纲，以自然对数单位计），则宣布该循环是一致的。\n\n在程序中实现此推导和算法，以评估以下测试套件中的循环，容差为 $\\tau = 0.05$：\n\n- 循环 #1（三个串联反应）：\n  - 反应 1：$(100, 100, 20, 50)$，单位为 $(\\mathrm{s}^{-1},\\mu\\mathrm{M},\\mathrm{s}^{-1},\\mu\\mathrm{M})$。\n  - 反应 2：$(80, 100, 64, 40)$，单位同上。\n  - 反应 3：$(200, 100, 200, 80)$，单位同上。\n- 循环 #2（与循环 #1 相同，但有微小扰动以模拟实验噪声）：\n  - 反应 1：$(100, 100, 20, 50)$。\n  - 反应 2：$(80, 100, 64, 40)$。\n  - 反应 3：$(200, 100, 209.6, 80)$。\n- 循环 #3（引入了大的不一致性）：\n  - 反应 1：$(100, 100, 60, 50)$。\n  - 反应 2：$(80, 100, 64, 40)$。\n  - 反应 3：$(200, 100, 200, 80)$。\n- 循环 #4（使用极端但合理的常数测试数值稳定性）：\n  - 反应 1：$(100, 10, 0.0001, 10)$。\n  - 反应 2：$(50, 10, 50000, 10)$。\n  - 反应 3：$(20, 10, 20000, 10)$。\n- 循环 #5（处于容差边界的临界情况）：\n  - 反应 1：$(100, 100, 20, 50)$。\n  - 反应 2：$(80, 100, 64 \\cdot e^{-0.05}, 40)$，即逆向催化常数乘以 $e^{-\\tau}$。\n  - 反应 3：$(200, 100, 200, 80)$。\n\n所有 $K_m$ 值的单位均为 $\\mu\\mathrm{M}$，所有 $k_{\\mathrm{cat}}$ 值的单位均为 $\\mathrm{s}^{-1}$。每个反应所隐含的标准平衡常数必须是无量纲的。唯一的程序输出应该是一行包含布尔值列表的文本，每个循环对应一个布尔值，按从循环 #1 到循环 #5 的顺序排列。其中每个布尔值为 true 当且仅当该循环的不一致性度量小于或等于 $\\tau$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[True, True, False, True, True]”）。\n\n不需要用户输入。程序必须硬编码上述测试套件和容差 $\\tau = 0.05$，并完全按照规定打印五个循环的布尔结果。", "solution": "所述问题在科学上是合理的、自洽的且定义明确。它提出了一个化学动力学中的标准练习，要求应用基本原理来验证循环反应网络的动力学数据的热力学一致性。所有必要的数据和定义都已提供，没有歧义或矛盾。我们将着手进行形式化的推导和算法构建。\n\n问题的核心依赖于两个基本原理：针对单个可逆酶促反应的霍尔丹关系式，以及应用于化学计量循环的细致平衡原理。\n\n首先，我们必须推导酶的宏观动力学参数与反应的标准平衡常数 $K_{eq}$ 之间的关系。问题指定了一个可逆的米氏-门登机制，用于将单一底物 $S$ 转化为单一产物 $P$ 的反应：$S \\longleftrightarrow P$。该反应由总浓度为 $[E_T]$ 的酶催化，其净速率 $v$ 由以下可逆速率方程给出：\n$$\n\\frac{v}{[E_T]} = \\frac{k_{\\mathrm{cat},f} \\frac{[S]}{K_{m,S}} - k_{\\mathrm{cat},r} \\frac{[P]}{K_{m,P}}}{1 + \\frac{[S]}{K_{m,S}} + \\frac{[P]}{K_{m,P}}}\n$$\n其中 $k_{\\mathrm{cat},f}$ 和 $K_{m,S}$ 分别是底物 $S$ 的正向催化常数和米氏常数，$k_{\\mathrm{cat},r}$ 和 $K_{m,P}$ 是产物 $P$ 相应的逆向参数。\n\n一个关键概念是催化效率，定义为反应速率对反应物浓度的初始斜率。对于正向反应（$S \\to P$），我们设 $[P]=0$ 并考察 $[S] \\to 0$ 时的极限：\n$$\nv_f = [E_T] \\frac{k_{\\mathrm{cat},f} [S] / K_{m,S}}{1 + [S] / K_{m,S}} \\approx [E_T] \\left( \\frac{k_{\\mathrm{cat},f}}{K_{m,S}} \\right) [S]\n$$\n项 $k_{\\mathrm{cat},f}/K_{m,S}$ 表示游离酶将游离底物转化为产物的表观二级速率常数。同样，对于逆向反应（$P \\to S$），设 $[S]=0$ 并取 $[P] \\to 0$ 时的极限，$S$ 的生成速率为：\n$$\nv_r = [E_T] \\frac{k_{\\mathrm{cat},r} [P] / K_{m,P}}{1 + [P] / K_{m,P}} \\approx [E_T] \\left( \\frac{k_{\\mathrm{cat},r}}{K_{m,P}} \\right) [P]\n$$\n项 $k_{\\mathrm{cat},r}/K_{m,P}$ 是逆向反应的催化效率。\n\n在热力学平衡时，净反应速率 $v$ 必须为零。从完整的速率方程可知，此条件意味着分子必须为零：\n$$\nk_{\\mathrm{cat},f} \\frac{[S]_{eq}}{K_{m,S}} - k_{\\mathrm{cat},r} \\frac{[P]_{eq}}{K_{m,P}} = 0\n$$\n其中 $[S]_{eq}$ 和 $[P]_{eq}$ 是平衡浓度。反应的标准平衡常数定义为 $K_{eq} = [P]_{eq} / [S]_{eq}$。重新整理该方程可得到以下关系：\n$$\nK_{eq} = \\frac{[P]_{eq}}{[S]_{eq}} = \\frac{k_{\\mathrm{cat},f} / K_{m,S}}{k_{\\mathrm{cat},r} / K_{m,P}} = \\frac{k_{\\mathrm{cat},f} \\cdot K_{m,P}}{k_{\\mathrm{cat},r} \\cdot K_{m,S}}\n$$\n这就是霍尔丹关系式。它提供了一种从纯粹的动力学测量值计算热力学平衡常数的方法。\n\n其次，我们将细致平衡原理应用于化学计量循环。对于任何闭合的反应环路，总的标准吉布斯自由能变化 $\\Delta G_{cycle}^\\circ$ 必须为零。这是因为吉布斯自由能是一个状态函数。对于由反应 $i=1, 2, ..., n$ 组成的循环，我们有：\n$$\n\\Delta G_{cycle}^\\circ = \\sum_{i=1}^{n} \\Delta G_{i}^\\circ = 0\n$$\n由于反应的标准吉布斯自由能变化通过 $\\Delta G_{i}^\\circ = -RT \\ln K_{eq,i}$ 与其平衡常数相关联，该条件变为：\n$$\n-RT \\sum_{i=1}^{n} \\ln K_{eq,i} = -RT \\ln \\left( \\prod_{i=1}^{n} K_{eq,i} \\right) = 0\n$$\n这意味着对于一个热力学一致的循环，沿循环方向的各反应平衡常数的乘积必须恰好为 1：\n$$\n\\prod_{i=1}^{n} K_{eq,i} = 1\n$$\n由于测量动力学参数时存在实验误差，该乘积很少会精确等于 $1$。问题定义了一个循环不一致性度量来量化这种偏差。它由平衡常数乘积的自然对数的绝对值给出：\n$$\n\\text{Inconsistency Metric} = \\left| \\ln \\left( \\prod_{i=1}^{n} K_{eq,i} \\right) \\right| = \\left| \\sum_{i=1}^{n} \\ln K_{eq,i} \\right|\n$$\n使用对数求和在数值上更优越，因为它避免了在乘以许多可能非常大或非常小的平衡常数时可能出现的上溢或下溢问题。\n\n验证一个循环的算法如下：\n1. 对于给定循环中的每个反应 $i$，使用提供的参数（$k_{\\mathrm{cat},f,i}$、$K_{m,S,i}$、$k_{\\mathrm{cat},r,i}$、$K_{m,P,i}$）通过霍尔丹关系式计算其平衡常数的自然对数：\n$$\n\\ln K_{eq,i} = \\ln \\left( \\frac{k_{\\mathrm{cat},f,i} \\cdot K_{m,P,i}}{k_{\\mathrm{cat},r,i} \\cdot K_{m,S,i}} \\right)\n$$\n2. 将循环中所有反应的这些对数值相加，得到 $\\sum_{i} \\ln K_{eq,i}$。\n3. 取该总和的绝对值，计算不一致性度量。\n4. 将该度量与指定的容差 $\\tau$ 进行比较。如果该度量小于或等于 $\\tau$，则认为该循环是一致的。\n\n所提供的 Python 程序实现了这一精确的算法。它遍历每个指定的循环，为每个循环计算不一致性度量，并将其与容差 $\\tau = 0.05$ 进行比较，以生成最终的布尔一致性标志列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the thermodynamic consistency of enzyme-catalyzed reaction cycles.\n    \"\"\"\n    \n    # Define the tolerance for thermodynamic consistency in natural-log units.\n    tau = 0.05\n\n    # Define the test suite of cycles. Each cycle is a list of reactions,\n    # and each reaction is a tuple of kinetic parameters:\n    # (k_cat_f (s^-1), K_m_S (uM), k_cat_r (s^-1), K_m_P (uM))\n    test_cases = [\n        # Cycle #1: A perfectly consistent cycle.\n        [\n            (100.0, 100.0, 20.0, 50.0),\n            (80.0, 100.0, 64.0, 40.0),\n            (200.0, 100.0, 200.0, 80.0)\n        ],\n        # Cycle #2: A cycle with a small perturbation, still within tolerance.\n        [\n            (100.0, 100.0, 20.0, 50.0),\n            (80.0, 100.0, 64.0, 40.0),\n            (200.0, 100.0, 209.6, 80.0)\n        ],\n        # Cycle #3: A cycle with a large inconsistency.\n        [\n            (100.0, 100.0, 60.0, 50.0),\n            (80.0, 100.0, 64.0, 40.0),\n            (200.0, 100.0, 200.0, 80.0)\n        ],\n        # Cycle #4: A consistent cycle with extreme parameter values to test numerical stability.\n        [\n            (100.0, 10.0, 0.0001, 10.0),\n            (50.0, 10.0, 50000.0, 10.0),\n            (20.0, 10.0, 20000.0, 10.0)\n        ],\n        # Cycle #5: A cycle designed to lie exactly at the tolerance boundary.\n        [\n            (100.0, 100.0, 20.0, 50.0),\n            (80.0, 100.0, 64.0 * np.exp(-tau), 40.0),\n            (200.0, 100.0, 200.0, 80.0)\n        ]\n    ]\n\n    results = []\n    for cycle in test_cases:\n        # Use the sum of logarithms for numerical robustness.\n        # sum(ln(K_eq)) = ln(product(K_eq)).\n        sum_ln_K_eq = 0.0\n\n        for reaction_params in cycle:\n            k_cat_f, K_m_S, k_cat_r, K_m_P = reaction_params\n            \n            # The Haldane relationship provides the equilibrium constant K_eq.\n            # K_eq = (k_cat_f / K_m_S) / (k_cat_r / K_m_P)\n            # This is equivalent to: K_eq = (k_cat_f * K_m_P) / (k_cat_r * K_m_S)\n            \n            # All kinetic parameters must be positive. Division by zero or log of a non-positive\n            # number indicates an unphysical situation that makes the cycle inconsistent.\n            if k_cat_r = 0 or K_m_S = 0 or k_cat_f = 0 or K_m_P = 0:\n                sum_ln_K_eq = float('inf')\n                break\n\n            K_eq = (k_cat_f * K_m_P) / (k_cat_r * K_m_S)\n            \n            if K_eq = 0:\n                sum_ln_K_eq = float('inf')\n                break\n\n            sum_ln_K_eq += np.log(K_eq)\n        \n        # The inconsistency metric is the absolute value of the sum of the logs.\n        inconsistency_metric = abs(sum_ln_K_eq)\n        \n        # A cycle is consistent if the metric is less than or equal to the tolerance.\n        is_consistent = inconsistency_metric = tau\n        results.append(is_consistent)\n\n    # Format the final output as a single line: [True,False,...]\n    # The str() function for booleans produces the required 'True'/'False' capitalization.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2686022"}]}