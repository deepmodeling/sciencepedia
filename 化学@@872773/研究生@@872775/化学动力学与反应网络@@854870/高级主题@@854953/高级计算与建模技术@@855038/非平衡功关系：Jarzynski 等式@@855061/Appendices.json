{"hands_on_practices": [{"introduction": "为了真正理解一个普适的物理定律，一个有效的方法是检验它在特定极限下能否回归到我们熟知的结论。本练习旨在建立非平衡功关系与平衡态热力学之间的桥梁。我们将通过一个具体的模型，即在随时间变化的谐振子势中的过阻尼布朗运动，来推导在无限慢的（准静态）过程中，Jarzynski等式如何自然地简化为功等于自由能变化的经典热力学结果 [@problem_id:2659500]。这个练习将加深你对Jarzynski等式作为平衡态热力学推广的理解。", "problem": "考虑一个单步化学变换的粗粒化反应坐标 $x$，它与一个逆温度为 $\\beta = 1/(k_{B} T)$ 的热库接触，并被建模为一个在时变谐波势 $U(x,t) = \\tfrac{1}{2} k(t) x^{2}$ 中运动的过阻尼布朗粒子。劲度系数 $k(t)$ 根据一个光滑、单调的协议 $k(t) = k_{0} + \\left(k_{1} - k_{0}\\right) s(t/\\tau)$ 被外部控制，其中 $s(0) = 0$, $s(1) = 1$，$s$ 是连续可微且导数有界，$\\tau$ 是总协议时长。该粒子在过阻尼朗之万动力学下演化，其摩擦系数 $\\gamma$ 为常数，并受到满足 $\\langle \\xi(t) \\rangle = 0$ 和 $\\langle \\xi(t) \\xi(t') \\rangle = 2 \\gamma k_{B} T \\, \\delta(t - t')$ 的高斯白噪声 $\\xi(t)$ 的影响。在 $t = 0$ 时，系统被制备在对应于 $k(0) = k_{0}$ 的正则系综平衡分布中。在时间区间 $[0,\\tau]$ 内，由该协议所做的随机功 $W$ 根据随机能量学的惯例定义为 $W = \\int_{0}^{\\tau} \\partial_{t} U\\big(x(t), t\\big) \\, \\mathrm{d}t$。\n\n从基本的统计力学和随机过程原理出发，分析准静态极限 $\\tau \\to \\infty$。\n\n- 推导在此极限下，$x(t)$ 的瞬时分布与瞬时劲度系数 $k(t)$ 下的正则系综平衡分布一致，并且耗散功 $W_{\\mathrm{diss}} \\equiv W - \\Delta F$ 的分布坍缩为在零点的狄拉克δ分布。此处 $\\Delta F \\equiv F(k_{1}) - F(k_{0})$ 是平衡亥姆霍兹自由能差，由 $F(k) = - k_{B} T \\ln Z(k)$ 定义，其中 $Z(k)$ 是劲度系数为 $k$ 时的正则组态配分函数。\n\n- 利用此结果，确定在准静态极限下功的指数平均值 $\\langle \\exp(-\\beta W) \\rangle$ 的精确闭式表达式，该表达式仅用 $k_{0}$ 和 $k_{1}$ 及普适常数表示。将最终答案以单个闭式解析表达式的形式给出。无需四舍五入，最终答案中不应报告任何物理单位。", "solution": "所提出的问题陈述具有科学依据、良定且客观。它描述了非平衡统计力学中的一个典范模型，并要求在准静态极限下推导一个基本结果。该问题是有效的，并允许进行严格的解析求解。\n\n粒子的动力学由过阻尼朗之万方程决定：\n$$\n\\gamma \\frac{\\mathrm{d}x}{\\mathrm{d}t} = -\\frac{\\partial U(x,t)}{\\partial x} + \\xi(t) = -k(t)x(t) + \\xi(t)\n$$\n其中 $\\gamma$ 是摩擦系数，$k(t)$ 是谐波势 $U(x,t) = \\frac{1}{2} k(t) x^{2}$ 的时变劲度系数，$\\xi(t)$ 是高斯白噪声，其相关性为 $\\langle \\xi(t) \\xi(t') \\rangle = 2 \\gamma k_{B} T \\, \\delta(t - t')$。逆温度为 $\\beta = (k_B T)^{-1}$。\n\n概率分布函数 $p(x,t)$ 的演化由相应的福克-普朗克方程描述：\n$$\n\\frac{\\partial p(x,t)}{\\partial t} = \\frac{1}{\\gamma} \\frac{\\partial}{\\partial x} \\left[k(t) x p(x,t)\\right] + \\frac{1}{\\gamma \\beta} \\frac{\\partial^2 p(x,t)}{\\partial x^2}\n$$\n\n问题要求分析准静态极限 $\\tau \\to \\infty$。劲度系数协议为 $k(t) = k_{0} + \\left(k_{1} - k_{0}\\right) s(t/\\tau)$。劲度系数的变化率为 $\\dot{k}(t) = \\frac{k_1 - k_0}{\\tau} s'(t/\\tau)$，对于任何有限的 $t$，当 $\\tau \\to \\infty$ 时该变化率趋近于零。协议的特征时间尺度 $\\tau$ 变得比系统的内在弛豫时间 $\\tau_{\\mathrm{relax}}(t) = \\gamma/k(t)$ 长得多。这种时间尺度的分离 $\\tau \\gg \\tau_{\\mathrm{relax}}(t)$ 意味着系统有足够的时间弛豫到与势的瞬时构型相对应的热平衡状态。\n\n因此，在任何时间 $t \\in [0, \\tau]$，概率分布 $p(x,t)$ 都可以用势 $U(x,t)$ 的正则系综平衡分布来近似：\n$$\np(x,t) \\to p_{\\mathrm{eq}}(x; k(t)) = \\frac{1}{Z(k(t))} \\exp\\left(-\\beta U(x,t)\\right)\n$$\n其中 $Z(k(t))$ 是劲度系数为 $k(t)$ 时的瞬时组态配分函数。这是第一个要求的结果。对于谐波势 $U(x,t) = \\frac{1}{2} k(t) x^2$，配分函数为：\n$$\nZ(k) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{1}{2} \\beta k x^2\\right) \\mathrm{d}x = \\sqrt{\\frac{2\\pi}{\\beta k}}\n$$\n因此，瞬时分布是一个高斯分布：$p_{\\mathrm{eq}}(x; k(t)) = \\sqrt{\\frac{\\beta k(t)}{2\\pi}} \\exp\\left(-\\frac{1}{2} \\beta k(t) x^2\\right)$。\n\n接下来，我们讨论功和耗散功。随机功定义为 $W = \\int_{0}^{\\tau} \\frac{\\partial U}{\\partial t} \\mathrm{d}t$。\n$$\nW = \\int_{0}^{\\tau} \\frac{\\partial}{\\partial t}\\left(\\frac{1}{2} k(t) x(t)^2\\right) \\mathrm{d}t = \\int_{0}^{\\tau} \\frac{1}{2} \\dot{k}(t) x(t)^2 \\mathrm{d}t\n$$\n在准静态极限下，功成为一个确定性量。对于过程的任何单次实现，涨落量 $x(t)^2$ 可以被其瞬时平衡平均值 $\\langle x^2 \\rangle_{k(t)}$ 替代。该平均值使用分布 $p_{\\mathrm{eq}}(x; k(t))$ 计算：\n$$\n\\langle x^2 \\rangle_{k(t)} = \\int_{-\\infty}^{\\infty} x^2 p_{\\mathrm{eq}}(x; k(t)) \\mathrm{d}x = \\frac{1}{\\beta k(t)}\n$$\n这个结果也可以直接从能量均分定理 $\\frac{1}{2}k(t)\\langle x^2 \\rangle_{k(t)} = \\frac{1}{2}k_B T$ 得到。\n\n将此平均值代入功的积分中，得到在准静态（可逆）过程中所做的功 $W_{\\mathrm{qs}}$：\n$$\nW_{\\mathrm{qs}} = \\lim_{\\tau \\to \\infty} W = \\int_{0}^{\\tau} \\frac{1}{2} \\dot{k}(t) \\frac{1}{\\beta k(t)} \\mathrm{d}t\n$$\n这个积分可以通过从 $t$ 到 $k$ 的变量替换来求解：\n$$\nW_{\\mathrm{qs}} = \\frac{1}{2\\beta} \\int_{k(0)}^{k(\\tau)} \\frac{\\mathrm{d}k}{k} = \\frac{1}{2\\beta} [\\ln k]_{k_0}^{k_1} = \\frac{1}{2\\beta} \\ln\\left(\\frac{k_1}{k_0}\\right)\n$$\n\n现在，我们计算平衡亥姆霍兹自由能差 $\\Delta F = F(k_1) - F(k_0)$。自由能为 $F(k) = -k_B T \\ln Z(k) = -\\frac{1}{\\beta} \\ln Z(k)$。\n$$\nF(k) = -\\frac{1}{\\beta} \\ln\\left(\\sqrt{\\frac{2\\pi}{\\beta k}}\\right) = -\\frac{1}{2\\beta} \\ln\\left(\\frac{2\\pi}{\\beta}\\right) + \\frac{1}{2\\beta} \\ln(k)\n$$\n自由能差则为：\n$$\n\\Delta F = F(k_1) - F(k_0) = \\left(C + \\frac{1}{2\\beta} \\ln(k_1)\\right) - \\left(C + \\frac{1}{2\\beta} \\ln(k_0)\\right) = \\frac{1}{2\\beta} \\ln\\left(\\frac{k_1}{k_0}\\right)\n$$\n比较结果，我们发现 $W_{\\mathrm{qs}} = \\Delta F$。由于在准静态极限下，过程的每次实现都产生相同的功值，功的分布 $P(W)$ 坍缩为在该值处的狄拉克δ函数：$P(W) \\to \\delta(W - \\Delta F)$。耗散功为 $W_{\\mathrm{diss}} = W - \\Delta F$。在此极限下，$W_{\\mathrm{diss}} \\to \\Delta F - \\Delta F = 0$。因此，耗散功的分布坍缩为在零点的狄拉克δ函数，$P(W_{\\mathrm{diss}}) \\to \\delta(W_{\\mathrm{diss}})$。这就完成了所要求推导的第二部分。\n\n最后，我们必须确定在此极限下的功的指数平均值 $\\langle \\exp(-\\beta W) \\rangle$。由于功 $W$ 变成了一个确定性量 $W_{\\mathrm{qs}} = \\Delta F$，所以平均值就是函数在该值处的取值：\n$$\n\\lim_{\\tau \\to \\infty} \\langle \\exp(-\\beta W) \\rangle = \\exp(-\\beta W_{\\mathrm{qs}}) = \\exp(-\\beta \\Delta F)\n$$\n这是 Jarzynski 等式的一个特例，它对任何 $\\tau$ 都有效，但在可逆极限下变得平凡。代入推导出的 $\\Delta F$ 表达式：\n$$\n\\exp(-\\beta \\Delta F) = \\exp\\left(-\\beta \\left(\\frac{1}{2\\beta} \\ln\\left(\\frac{k_1}{k_0}\\right)\\right)\\right) = \\exp\\left(-\\frac{1}{2} \\ln\\left(\\frac{k_1}{k_0}\\right)\\right)\n$$\n使用恒等式 $\\exp(a \\ln b) = b^a$，我们得到：\n$$\n\\langle \\exp(-\\beta W) \\rangle_{\\mathrm{qs}} = \\left(\\frac{k_1}{k_0}\\right)^{-1/2} = \\sqrt{\\frac{k_0}{k_1}}\n$$\n这个表达式只依赖于初始和最终的劲度系数参数 $k_0$ 和 $k_1$。", "answer": "$$\n\\boxed{\\sqrt{\\frac{k_{0}}{k_{1}}}}\n$$", "id": "2659500"}, {"introduction": "Jarzynski等式的意义远不止于计算自由能差，它蕴含了关于宏观耗散与微观涨落之间深刻的内在联系。本练习将引导你使用统计物理中的一个强大数学工具——累积量展开，来处理Jarzynski等式。通过对等式进行展开并保留到二阶项，你将推导出在近平衡条件下，平均耗散功与功的方差之间的直接关系 [@problem_id:2659538]，这正是著名的涨落-耗散关系的一种体现。", "problem": "一个等温、充分搅拌的化学反应网络，通过一个随时间变化的协议 $\\lambda(t)$ 被驱动偏离平衡态。该协议调制了与一个化学恒定物种共轭的化学功。该系统初始时在逆温度 $\\beta = 1/(k_{B}T)$ 下，相对于 $\\lambda(0)$ 处的哈密顿量达到平衡。该协议在有限的时间 $\\tau$ 内执行，直至 $\\lambda(\\tau)$。设 $W$ 表示在协议的单次实现过程中对系统所做的随机功，$\\Delta F$ 表示在 $\\lambda(0)$ 和 $\\lambda(\\tau)$ 状态之间对应的平衡亥姆霍兹自由能差。假设非平衡功关系 $\\langle \\exp(-\\beta W)\\rangle=\\exp(-\\beta \\Delta F)$ 成立。\n\n从非平衡功关系出发，仅使用累积量生成函数 $K_{W}(t)=\\ln \\langle \\exp(t W)\\rangle$ 的定义以及前两个累积量等同于均值和方差的认定，对 $K_{W}(-\\beta)$ 进行累积量展开至 $\\beta^{2}$ 阶。在 $\\beta^{2}$ 阶上保持一致，推导一个将耗散功 $W_{\\mathrm{diss}}=\\langle W\\rangle-\\Delta F$ 与 $W$ 的方差联系起来的表达式。明确说明你对更高阶累积量所做的近似。\n\n得到的耗散功 $W_{\\mathrm{diss}}$ 到 $\\beta^{2}$ 阶的解析表达式是什么（用 $\\beta$ 和 $\\mathrm{Var}(W)$ 表示）？请以闭合形式表达式给出你的最终答案。最终的方框答案中不要包含单位。", "solution": "该问题被验证为具有科学依据、提法恰当且客观。这是非平衡统计力学中的一个标准推导。我们可以开始解题。\n\n出发点是给定的非平衡功关系，即 Jarzynski 等式：\n$$\n\\langle \\exp(-\\beta W) \\rangle = \\exp(-\\beta \\Delta F)\n$$\n其中 $W$ 是随机功，$\\Delta F$ 是平衡自由能差，$\\beta = (k_B T)^{-1}$ 是逆温度。尖括号 $\\langle \\cdot \\rangle$ 表示对轨迹系综的平均。\n\n我们已知功 $W$ 的累积量生成函数的定义为：\n$$\nK_W(t) = \\ln \\langle \\exp(t W) \\rangle\n$$\n对 Jarzynski 等式两边取自然对数，我们可以将其与在 $t = -\\beta$ 处求值的累积量生成函数联系起来：\n$$\n\\ln \\langle \\exp(-\\beta W) \\rangle = \\ln(\\exp(-\\beta \\Delta F))\n$$\n$$\nK_W(-\\beta) = -\\beta \\Delta F\n$$\n这个关系是精确的，无需任何近似即成立。\n\n累积量生成函数可以表示为变量 $t$ 的麦克劳林级数，其系数由随机变量 $W$ 的累积量 $\\kappa_n$ 决定：\n$$\nK_W(t) = \\sum_{n=1}^{\\infty} \\frac{\\kappa_n}{n!} t^n = \\frac{\\kappa_1}{1!}t + \\frac{\\kappa_2}{2!}t^2 + \\frac{\\kappa_3}{3!}t^3 + \\dots\n$$\n题目说明前两个累积量等同于均值和方差：\n- 一阶累积量: $\\kappa_1 = \\langle W \\rangle$\n- 二阶累积量: $\\kappa_2 = \\mathrm{Var}(W) = \\langle (W - \\langle W \\rangle)^2 \\rangle$\n\n我们必须对 $K_W(-\\beta)$ 进行累积量展开至 $\\beta^2$ 阶。为此，我们将 $t = -\\beta$ 代入级数展开式，并在二阶项后截断：\n$$\nK_W(-\\beta) = \\frac{\\kappa_1}{1!}(-\\beta) + \\frac{\\kappa_2}{2!}(-\\beta)^2 + \\mathcal{O}(\\beta^3)\n$$\n$$\nK_W(-\\beta) \\approx -\\beta \\kappa_1 + \\frac{\\beta^2}{2} \\kappa_2\n$$\n这里所做的明确近似是忽略所有 $\\beta^3$ 阶及更高阶的项。这可以表述为：\n$$\n\\sum_{n=3}^{\\infty} \\frac{\\kappa_n}{n!} (-\\beta)^n \\approx 0\n$$\n当系统在近平衡条件下被驱动，使得功分布 $P(W)$ 近似为高斯分布时，这个近似在物理上是合理的。对于一个真正的高斯分布，所有 $n \\geq 3$ 的累积量 $\\kappa_n$ 都恒等于零，从而使得该展开式精确成立。\n\n将 $\\kappa_1$ 和 $\\kappa_2$ 的定义代入我们截断的展开式，得到：\n$$\nK_W(-\\beta) \\approx -\\beta \\langle W \\rangle + \\frac{\\beta^2}{2} \\mathrm{Var}(W)\n$$\n现在我们将这个近似表达式与精确关系 $K_W(-\\beta) = -\\beta \\Delta F$ 等同起来：\n$$\n-\\beta \\Delta F \\approx -\\beta \\langle W \\rangle + \\frac{\\beta^2}{2} \\mathrm{Var}(W)\n$$\n题目要求得到耗散功 $W_{\\mathrm{diss}}$ 的表达式，其定义为 $W_{\\mathrm{diss}} = \\langle W \\rangle - \\Delta F$。为了求得此式，我们重新整理上述关系。假设 $\\beta \\neq 0$，我们可以将整个表达式除以 $-\\beta$：\n$$\n\\Delta F \\approx \\langle W \\rangle - \\frac{\\beta}{2} \\mathrm{Var}(W)\n$$\n最后，我们重新整理，将耗散功分离到等式的一边：\n$$\n\\langle W \\rangle - \\Delta F \\approx \\frac{\\beta}{2} \\mathrm{Var}(W)\n$$\n这就得出了耗散功到 $\\beta^2$ 阶的表达式：\n$$\nW_{\\mathrm{diss}} \\approx \\frac{\\beta}{2} \\mathrm{Var}(W)\n$$\n这个结果是涨落耗散定理的一种形式，它将非平衡过程中的平均耗散与所做功的涨落（方差）联系起来。", "answer": "$$\n\\boxed{\\frac{\\beta}{2} \\mathrm{Var}(W)}\n$$", "id": "2659538"}, {"introduction": "理论的生命力在于实践和验证。这个最终的动手练习将挑战你从零开始构建一个随机化学网络的计算机模拟。你将需要根据给定的含时能量函数和满足局域细致平衡条件的跃迁速率，编写程序来生成大量随机轨迹。通过为每条轨迹计算所做的功并执行系综平均，你将亲手完成对Jarzynski等式的数值验证 [@problem_id:2659368]，从而将抽象的理论概念转化为具体可感的计算结果。", "problem": "考虑一个有限状态的连续时间马尔可夫跳跃过程，它代表一个具有时变能量景观的化学反应网络。设状态空间为 $S=\\{0,1,\\dots,N-1\\}$。在时间 $t$，每个状态 $i\\in S$ 具有能量 $E_i(t)$，系统演化为一个时变连续时间马尔可夫链，其生成元为 $\\mathcal{L}_t$，其非对角元素为 $i\\neq j$ 时的转移速率 $k_{ij}(t)$。假设以下基本前提：\n- 正则初始条件：系统在时间 $t=0$ 时处于逆温度 $\\beta>0$ 下的正则平衡分布，即 $p_i(0)=\\exp(-\\beta E_i(0))/Z(0)$，其中 $Z(t)=\\sum_{j=0}^{N-1}\\exp(-\\beta E_j(t))$。\n- 局域细致平衡（LDB）：对于所有 $i\\neq j$ 和时间 $t$，速率满足 $k_{ij}(t)/k_{ji}(t)=\\exp\\big(-\\beta\\big[E_j(t)-E_i(t)\\big]\\big)$。\n- 速率的构建：取一个对称的尝试速率前因子 $\\kappa>0$ 并定义\n$$\nk_{ij}(t)=\\kappa\\,\\exp\\Big(-\\tfrac{\\beta}{2}\\big[E_j(t)-E_i(t)\\big]\\Big),\\quad i\\neq j,\\quad k_{ii}(t)=-\\sum_{j\\neq i}k_{ij}(t).\n$$\n假设只有当前占据态的能量随时间显式变化，即外部协议不改变反应路径，只改变状态能量 $E_i(t)$。对于在 $[0,\\tau]$ 上有有限次跳跃的单条轨迹 $t\\mapsto x_t$，定义与该协议相关的轨迹功为\n$$\nW[x_{\\cdot}]=\\int_{0}^{\\tau}\\partial_t E_{x_t}(t)\\,dt,\n$$\n即实际占据态能量变化率的时间积分。在离散时间下，使用均匀划分 $t_k=k\\Delta t$（其中 $\\Delta t=\\tau/n_{\\mathrm{steps}}$），此功的黎曼近似为\n$$\nW\\approx \\sum_{k=0}^{n_{\\mathrm{steps}}-1}\\Big(E_{x_{t_k}}(t_{k+1})-E_{x_{t_k}}(t_k)\\Big).\n$$\n定义在 $M$ 条独立轨迹上的指数功平均估计量为\n$$\n\\widehat{\\Phi}=\\frac{1}{M}\\sum_{m=1}^{M}\\exp\\big(-\\beta W^{(m)}\\big),\n$$\n以及参考平衡比\n$$\nR=\\frac{Z(\\tau)}{Z(0)}.\n$$\n你的任务是实现一个程序，该程序：\n- 使用上述具有时变速率 $k_{ij}(t)$ 的连续时间马尔可夫链，采样 $M$ 条独立轨迹。采用一个小的均匀时间步长 $\\Delta t$，并在每个时间步内，使用一个跳跃/不跳跃规则，其中对于时间 $t$ 的当前状态 $i$，精确的不跳跃概率为 $\\exp\\big(-r_i(t)\\Delta t\\big)$，此处 $r_i(t)=\\sum_{j\\neq i}k_{ij}(t)$。当在一个时间步内发生跳跃时，根据步长开始时对所有 $j\\neq i$ 与 $k_{ij}(t)$ 成正比的概率选择下一个状态。\n- 使用时间 $t=0$ 时的正则平衡分布来采样初始状态。\n- 使用上述黎曼近似计算每条轨迹的 $W^{(m)}$，然后通过 log-mean-exp 变换以数值稳定的方式计算 $\\log \\widehat{\\Phi}$。\n- 从协议中精确计算 $\\log R=\\log Z(\\tau)-\\log Z(0)$。\n- 对每个测试用例，返回一个布尔值，指示绝对对数差 $|\\log \\widehat{\\Phi}-\\log R|  \\varepsilon$ 是否小于指定的容差。\n\n所有能量都应被视为无量纲，并以玻尔兹曼常数与温度的乘积 $k_{\\mathrm{B}}T$ 等于一的单位报告，因此 $\\beta$ 是无量纲的。所需的输出是布尔值（无单位）。此任务不涉及角度和百分比。\n\n实现以下测试套件。在每种情况下，能量随时间线性变化，$E_i(t)=\\epsilon_i+\\alpha_i t$，参数如下：\n- 测试1（两状态，中等速率斜坡）：\n  - $N=2$, $\\beta=1.0$, $\\kappa=5.0$, $\\tau=1.0$, $n_{\\mathrm{steps}}=1500$, $M=6000$, $\\varepsilon=0.02$,\n  - $\\boldsymbol{\\epsilon}=[0.0,\\,1.0]$, $\\boldsymbol{\\alpha}=[1.0,\\,0.0]$.\n- 测试2（三状态，能量交叉，较冷的热浴）：\n  - $N=3$, $\\beta=2.0$, $\\kappa=4.0$, $\\tau=1.0$, $n_{\\mathrm{steps}}=1500$, $M=7000$, $\\varepsilon=0.03$,\n  - $\\boldsymbol{\\epsilon}=[0.0,\\,0.5,\\,1.0]$, $\\boldsymbol{\\alpha}=[0.5,\\,-0.8,\\,0.3]$.\n- 测试3（四状态，更快淬火，较热的热浴）：\n  - $N=4$, $\\beta=0.5$, $\\kappa=6.0$, $\\tau=0.5$, $n_{\\mathrm{steps}}=1500$, $M=7000$, $\\varepsilon=0.02$,\n  - $\\boldsymbol{\\epsilon}=[0.0,\\,0.2,\\,0.4,\\,0.6]$, $\\boldsymbol{\\alpha}=[2.0,\\,-1.0,\\,0.0,\\,0.5]$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如，“[result1,result2,result3]”。\n- 对于上述测试套件，结果是对应测试的三个布尔值，按给定顺序排列。", "solution": "该问题要求对一个由时变速率控制的有限状态、连续时间马尔可夫跳跃过程进行Jarzynski等式的数值验证。Jarzynski等式指出，对于一个被外部协议驱动脱离平衡的系统，指数化功的统计平均值 $\\langle e^{-\\beta W} \\rangle$ 与相应平衡系综的最终和初始状态之间的平衡自由能差 $\\Delta F$ 相关：$\\langle e^{-\\beta W} \\rangle = e^{-\\beta \\Delta F}$。\n\n首先，必须验证问题陈述。\n**第1步：提取已知信息**\n- 状态空间：$S = \\{0, 1, \\dots, N-1\\}$。\n- 状态能量：$E_i(t) = \\epsilon_i + \\alpha_i t$。\n- 初始条件：$t=0$ 时的正则分布，$p_i(0) = \\exp(-\\beta E_i(0))/Z(0)$，其中 $Z(t) = \\sum_{j=0}^{N-1} \\exp(-\\beta E_j(t))$。\n- 转移速率：对于 $i \\neq j$，$k_{ij}(t) = \\kappa \\exp\\big(-\\frac{\\beta}{2}[E_j(t)-E_i(t)]\\big)$。这满足局域细致平衡：$k_{ij}(t)/k_{ji}(t) = \\exp(-\\beta[E_j(t)-E_i(t)])$。\n- 轨迹功：$W[x_{\\cdot}] = \\int_0^\\tau \\partial_t E_{x_t}(t) dt$。\n- 功的近似：$W \\approx \\sum_{k=0}^{n_{\\mathrm{steps}}-1} (E_{x_{t_k}}(t_{k+1}) - E_{x_{t_k}}(t_k))$，其中 $t_k = k \\Delta t$ 且 $\\Delta t = \\tau/n_{\\mathrm{steps}}$。\n- 估计量：$\\widehat{\\Phi} = \\frac{1}{M} \\sum_{m=1}^M \\exp(-\\beta W^{(m)})$。\n- 参考比率：$R = Z(\\tau)/Z(0)$。\n- 模拟方法：基于不跳跃概率 $\\exp(-r_i(t)\\Delta t)$（其中 $r_i(t) = \\sum_{j \\neq i} k_{ij}(t)$）的离散时间步进跳跃/不跳跃决策。\n- 任务：对于几个测试用例，确定是否有 $|\\log \\widehat{\\Phi} - \\log R|  \\varepsilon$。\n\n**第2步：使用提取的已知信息进行验证**\n该问题具有科学依据，植根于非平衡统计力学的既定原理。Jarzynski等式是该领域的一个基本结果。所指定的模型，一个速率满足局域细致平衡的连续时间马尔可夫过程，是研究此类现象的标准框架。所提供的速率形式，$k_{ij}(t) = \\kappa \\exp(-\\frac{\\beta}{2}[E_j(t)-E_i(t)])$，是一个有效的选择（类似Metropolis），它正确地蕴含了所需的细致平衡条件。功的定义是标准的。用于模拟轨迹和近似功的数值方案是一种标准且有效的方法（用于随机过程的一阶欧拉型方法，也称为tau-leaping）。所有参数都已指定，问题是适定的、客观的且计算上可行的。不存在科学或逻辑上的矛盾。\n\n**第3步：结论与行动**\n问题是有效的。将提供一个合理的解决方案。\n\n**基于原理的解决方案设计**\n\n任务是数值评估Jarzynski等式的两边，在问题的符号体系中即为 $\\widehat{\\Phi} \\approx R$。实现分为三个主要部分：参考值的解析计算，用于估计功分布的随机模拟，以及最终的统计比较。\n\n1.  **解析参考值计算**：Jarzynski等式的右边涉及协议开始和结束时的平衡配分函数 $Z(t)$。自由能变化为 $\\Delta F = F(\\tau) - F(0)$，其中亥姆霍兹自由能为 $F(t) = -\\frac{1}{\\beta}\\log Z(t)$。因此，$e^{-\\beta \\Delta F} = e^{\\log Z(\\tau) - \\log Z(0)} = Z(\\tau)/Z(0) = R$。我们必须计算 $\\log R = \\log Z(\\tau) - \\log Z(0)$。时间 $t$ 的配分函数是 $Z(t) = \\sum_{i=0}^{N-1} \\exp(-\\beta E_i(t))$。给定线性协议 $E_i(t) = \\epsilon_i + \\alpha_i t$，能量 $E_i(0) = \\epsilon_i$ 和 $E_i(\\tau) = \\epsilon_i + \\alpha_i \\tau$ 很容易计算。计算 $Z(t)$ 所需的指数和使用数值稳定的 log-sum-exp 算法来计算，以防止浮点溢出或下溢，这在 $\\beta E_i(t)$ 值较大时至关重要。\n\n2.  **随机轨迹模拟**：左边项 $\\langle e^{-\\beta W} \\rangle$ 通过对 $M$ 条独立随机轨迹进行平均来估计。\n    *   **初始化**：对于 $M$ 条轨迹中的每一条，初始状态 $x(0)$ 从 $t=0$ 时的正则玻尔兹曼分布 $p_i(0) = \\exp(-\\beta E_i(0)) / Z(0)$ 中采样。这确保了系统按定理要求在热平衡状态下开始。\n    *   **时间演化**：使用连续时间马尔可夫过程的离散时间近似来模拟动力学。总时长 $\\tau$ 被划分为 $n_{\\mathrm{steps}}$ 个时长为 $\\Delta t = \\tau/n_{\\mathrm{steps}}$ 的小时间间隔。对于从 $t_k$ 到 $t_{k+1}$ 的每个时间步，系统的状态 $x_{t_k}=i$ 按如下方式演化：\n        a. 从状态 $i$ 到所有其他状态 $j \\neq i$ 的转移速率 $k_{ij}(t_k)$ 是基于时间间隔开始时的能量 $E_j(t_k)$ 计算的。\n        b. 计算总离开速率 $r_i(t_k) = \\sum_{j \\neq i} k_{ij}(t_k)$。\n        c. 作出随机决策：系统以概率 $p_{\\text{no-jump}} = \\exp(-r_i(t_k)\\Delta t)$ 停留在状态 $i$。\n        d. 如果发生跳跃（概率为 $1-p_{\\text{no-jump}}$），则从可能的目标状态集合中选择新状态 $j$，其概率为 $p_{i \\to j} = k_{ij}(t_k) / r_i(t_k)$。\n    对所有 $n_{\\mathrm{steps}}$ 重复此过程，生成一条状态轨迹 $x_{t_0}, x_{t_1}, \\dots, x_{t_{n_{\\mathrm{steps}}-1}}$。\n\n3.  **功的计算与平均**：\n    *   对于每条轨迹 $m$，使用指定的黎曼和计算累积功 $W^{(m)}$。对于线性能量协议，$\\partial_t E_i(t) = \\alpha_i$，功的积分简化为 $W = \\int_0^\\tau \\alpha_{x_t} dt$。黎曼和近似变为 $W^{(m)} \\approx \\sum_{k=0}^{n_{\\mathrm{steps}}-1} \\alpha_{x_{t_k}^{(m)}} \\Delta t$。这是通过对每一步的功增量求和来计算的，功增量取决于该步期间所占据的状态。\n    *   Jarzynski平均的估计量是 $\\widehat{\\Phi} = \\frac{1}{M}\\sum_{m=1}^{M} \\exp(-\\beta W^{(m)})$。其对数 $\\log\\widehat{\\Phi}$ 使用 log-mean-exp 变换计算：$\\log\\widehat{\\Phi} = C + \\log\\left(\\frac{1}{M}\\sum_{m=1}^{M} \\exp(-\\beta W^{(m)} - C)\\right)$，其中 $C = \\max_m(-\\beta W^{(m)})$。这避免了对大数进行指数运算时产生的数值错误。\n\n4.  **实现与验证**：为了提高效率，整个模拟使用 `NumPy` 进行矢量化。我们不是单独遍历 $M$ 条轨迹，而是在一个包含 $M$ 个状态的数组上操作。在每个时间步，轨迹按其当前状态分组，并对每个组以矢量化方式执行速率计算和跳跃决策。最后，将计算出的 $|\\log \\widehat{\\Phi} - \\log R|$ 与容差 $\\varepsilon$ 进行比较，以返回最终的布尔结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef run_simulation(N, beta, kappa, tau, n_steps, M, epsilon_tol, eps_vec, alpha_vec):\n    \"\"\"\n    Runs a single simulation test case to numerically verify the Jarzynski equality.\n\n    Args:\n        N (int): Number of states.\n        beta (float): Inverse temperature.\n        kappa (float): Symmetric rate prefactor.\n        tau (float): Protocol duration.\n        n_steps (int): Number of time steps in the simulation.\n        M (int): Number of trajectories to simulate.\n        epsilon_tol (float): Tolerance for the comparison.\n        eps_vec (list or np.ndarray): Initial energy offsets.\n        alpha_vec (list or np.ndarray): Energy ramp rates.\n\n    Returns:\n        bool: True if the absolute log-difference is within tolerance, False otherwise.\n    \"\"\"\n    eps_vec = np.array(eps_vec, dtype=np.float64)\n    alpha_vec = np.array(alpha_vec, dtype=np.float64)\n\n    # 1. Calculate time step\n    dt = tau / n_steps\n\n    # 2. Calculate the exact reference value log R = log(Z(tau)/Z(0))\n    E0 = eps_vec\n    log_Z0 = logsumexp(-beta * E0)\n    \n    E_tau = eps_vec + alpha_vec * tau\n    log_Z_tau = logsumexp(-beta * E_tau)\n    \n    log_R = log_Z_tau - log_Z0\n\n    # 3. Sample initial states for M trajectories from the canonical distribution at t=0\n    p0 = np.exp(-beta * E0 - log_Z0)\n    p0 /= np.sum(p0)  # Normalize to correct for any floating point inaccuracies\n    initial_states = np.random.choice(N, size=M, p=p0)\n\n    # 4. Simulate M trajectories and compute work for each\n    current_states = initial_states.copy()\n    total_work = np.zeros(M, dtype=np.float64)\n    work_increments_per_step = alpha_vec * dt\n    \n    # Precompute indices of other states for performance\n    other_states_indices = [np.arange(N)[np.arange(N) != i] for i in range(N)]\n\n    for k in range(n_steps):\n        t_k = k * dt\n        \n        # Add work contribution for this step: E_x(t_{k+1}) - E_x(t_k) = alpha_x * dt\n        total_work += work_increments_per_step[current_states]\n        \n        energies_tk = eps_vec + alpha_vec * t_k\n        next_states = current_states.copy()\n\n        # Group trajectories by current state for vectorized rate calculations\n        for i in range(N):\n            in_state_i_mask = (current_states == i)\n            if not np.any(in_state_i_mask):\n                continue\n            \n            count_in_state_i = np.sum(in_state_i_mask)\n            \n            if N > 1:\n                j_neq_i = other_states_indices[i]\n                energy_i = energies_tk[i]\n                energy_j = energies_tk[j_neq_i]\n                \n                rates_ij = kappa * np.exp(-0.5 * beta * (energy_j - energy_i))\n                r_i = np.sum(rates_ij)\n            else:\n                r_i = 0.0\n\n            if r_i > 0:\n                # Decide which trajectories jump based on the no-jump probability\n                no_jump_prob = np.exp(-r_i * dt)\n                random_nums = np.random.rand(count_in_state_i)\n                \n                original_indices = np.where(in_state_i_mask)[0]\n                jumping_trajectories_mask = (random_nums >= no_jump_prob)\n                \n                if np.any(jumping_trajectories_mask):\n                    jumping_indices = original_indices[jumping_trajectories_mask]\n                    num_jumps = len(jumping_indices)\n                    \n                    # Choose next state for trajectories that jump\n                    jump_probs = rates_ij / r_i\n                    chosen_next_states = np.random.choice(j_neq_i, size=num_jumps, p=jump_probs)\n                    next_states[jumping_indices] = chosen_next_states\n        \n        current_states = next_states\n\n    # 5. Compute the log of the exponential work estimator using log-mean-exp transform\n    log_phi_hat_terms = -beta * total_work\n    max_term = np.max(log_phi_hat_terms)\n    log_phi_hat = max_term + np.log(np.mean(np.exp(log_phi_hat_terms - max_term)))\n\n    # 6. Compare with tolerance and return boolean result\n    abs_log_diff = np.abs(log_phi_hat - log_R)\n    return abs_log_diff  epsilon_tol\n\ndef solve():\n    \"\"\"\n    Defines test cases from the problem statement and runs the simulations.\n    \"\"\"\n    test_cases = [\n        # Test 1 (two-state, moderate ramp)\n        {\n            \"N\": 2, \"beta\": 1.0, \"kappa\": 5.0, \"tau\": 1.0, \"n_steps\": 1500, \"M\": 6000, \n            \"epsilon_tol\": 0.02, \"eps_vec\": [0.0, 1.0], \"alpha_vec\": [1.0, 0.0]\n        },\n        # Test 2 (three-state, crossing energies, colder bath)\n        {\n            \"N\": 3, \"beta\": 2.0, \"kappa\": 4.0, \"tau\": 1.0, \"n_steps\": 1500, \"M\": 7000,\n            \"epsilon_tol\": 0.03, \"eps_vec\": [0.0, 0.5, 1.0], \"alpha_vec\": [0.5, -0.8, 0.3]\n        },\n        # Test 3 (four-state, faster quench, hotter bath)\n        {\n            \"N\": 4, \"beta\": 0.5, \"kappa\": 6.0, \"tau\": 0.5, \"n_steps\": 1500, \"M\": 7000,\n            \"epsilon_tol\": 0.02, \"eps_vec\": [0.0, 0.2, 0.4, 0.6], \"alpha_vec\": [2.0, -1.0, 0.0, 0.5]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python's str(bool) produces 'True'/'False' with capitalization.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2659368"}]}