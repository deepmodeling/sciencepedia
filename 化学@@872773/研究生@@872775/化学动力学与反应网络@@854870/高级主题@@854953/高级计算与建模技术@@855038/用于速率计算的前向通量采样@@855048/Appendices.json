{"hands_on_practices": [{"introduction": "本练习是基础性的。它将指导你完成任何前向通量采样 (FFS) 计算中的第一个关键步骤：估算初始通量 $\\Phi_{A,0}$。你将使用随机模拟算法 (SSA) 对一个简单的生灭模型进行模拟，以测量轨迹离开稳定态 $A$ 并穿过第一个界面 $\\lambda_0$ 的速率，这是整个 FFS 方法的基石。[@problem_id:2645590]", "problem": "设计一个程序，通过随机模拟算法（SSA）模拟一个一维生灭化学反应网络，并估算其在前向通量采样（FFS）中的首次穿越通量。从盆地 $A$ 到第一个界面 $\\lambda_{0}$ 的首次穿越通量，记为 $\\Phi_{A,0}$，其定义为：在一种重注入协议下（即在成功首次到达 $\\lambda_{0}$ 或未到达而返回 $A$ 后，将系统在 $A$ 中重新启动），单位 SSA 时间内首次到达 $\\lambda_{0}$ 次数的长时间极限。您必须使用此协议为 $\\Phi_{A,0}$ 实现一个统计上正确的估算器。\n\n使用以下化学动力学模型，其中包含一个物种 $X$，其拷贝数为 $n \\in \\{0,1,2,\\dots\\}$：\n- 生成反应：$\\varnothing \\rightarrow X$，速率常数为 $k_{\\text{b}}$（单位：$\\text{s}^{-1}$），倾向性为 $a_{1}(n) = k_{\\text{b}}$。\n- 消亡反应：$X \\rightarrow \\varnothing$，速率常数为 $k_{\\text{d}}$（单位：$\\text{s}^{-1}$），倾向性为 $a_{2}(n) = k_{\\text{d}} \\, n$。\n\n通过随机模拟算法（SSA）（Gillespie 算法）模拟该连续时间马尔可夫链。在状态 $n$ 时，总倾向性为 $a_{0}(n) = a_{1}(n) + a_{2}(n) = k_{\\text{b}} + k_{\\text{d}} \\, n$。SSA 的等待时间增量是一个速率为 $a_{0}(n)$ 的指数随机变量，反应通道的选择概率与各倾向性成正比。\n\n定义序参数为 $\\lambda(n) = n$。对于给定的整数阈值 $n_{A} \\geq 0$，定义盆地 $A = \\{ n \\,:\\, n \\leq n_{A} \\}$；对于给定的整数 $n_{0}  n_{A}$，定义第一个界面 $\\lambda_{0} = \\{ n \\,:\\, n \\geq n_{0} \\}$。从 $A$ 中开始，运行 SSA 并追踪轨迹离开 $A$ 时开始的“越轨”过程。对于每次越轨，当轨迹到达 $\\lambda_{0}$（计为一次首次到达）或返回到 $A$（计为零次）时，停止该次越轨。无论哪种结果，都根据无约束过程限制在 $A$ 内的稳态分布将系统重新注入到 $A$ 中，然后继续 SSA。累积所有步骤中推进的总 SSA 时间。通量的估算器为\n$$\n\\widehat{\\Phi}_{A,0} \\;=\\; \\frac{N_{\\text{hits}}}{T_{\\text{sim}}},\n$$\n其中 $N_{\\text{hits}}$ 是观测到的首次到达 $\\lambda_{0}$ 的次数，$T_{\\text{sim}}$ 是模拟的总 SSA 时间。对每个案例，以 $\\text{s}^{-1}$ 为单位表示数值答案，并四舍五入到六位有效数字。\n\n对于指定的生灭过程，当 $k_{\\text{d}}  0$ 时，其在 $\\{0,1,2,\\dots\\}$ 上的稳态分布存在，并且是均值为 $\\mu = k_{\\text{b}}/k_{\\text{d}}$ 的泊松分布。因此，限制在 $A$ 内的重注入分布是截断至 $\\{0,1,\\dots,n_{A}\\}$ 的泊松分布，其在该集合上的概率与 $\\mu^{n}/n!$ 成正比。您的程序必须从此截断分布中采样重注入状态。\n\n实现要求：\n- 对每个案例，按照上述定义精确模拟 SSA，总模拟时间为 $T_{\\text{sim}}$，并在每次越轨结束后使用重注入协议。\n- 仅当一次越轨在返回到 $n \\leq n_{A}$ 之前到达任意 $n \\in \\{ n_{0}, n_{0}+1, \\dots \\}$ 时，才将首次到达 $\\lambda_{0}$ 的次数加一。\n- 在所有步骤中连续累积 SSA 时间，包括在 $A$ 中和在越轨过程中所花费的时间。\n- 每个测试案例使用指定的固定随机数生成器种子，以确保确定性输出。\n\n测试套件：\n提供以下四个案例的结果。在每个案例中，报告估算的通量 $\\widehat{\\Phi}_{A,0}$，以 $\\text{s}^{-1}$ 为单位，并四舍五入到六位有效数字。\n\n- 案例 1（正常路径，中等通量）：\n  - $k_{\\text{b}} = 1.0\\ \\text{s}^{-1}$，$k_{\\text{d}} = 0.5\\ \\text{s}^{-1}$，$n_{A} = 1$，$n_{0} = 4$，$T_{\\text{sim}} = 4000.0\\ \\text{s}$，种子 $= 12345$。\n- 案例 2（稀有事件区域，在有限时间内可能计数为零）：\n  - $k_{\\text{b}} = 0.2\\ \\text{s}^{-1}$，$k_{\\text{d}} = 1.0\\ \\text{s}^{-1}$，$n_{A} = 1$，$n_{0} = 5$，$T_{\\text{sim}} = 20000.0\\ \\text{s}$，种子 $= 67890$。\n- 案例 3（边界情况 $n_{0} = n_{A}+1$，离开 $A$ 即等于首次到达）：\n  - $k_{\\text{b}} = 3.0\\ \\text{s}^{-1}$，$k_{\\text{d}} = 1.0\\ \\text{s}^{-1}$，$n_{A} = 2$，$n_{0} = 3$，$T_{\\text{sim}} = 3000.0\\ \\text{s}$，种子 $= 24680$。\n- 案例 4（每个分子的消亡率高于生成率但均值大于1，中等壁垒）：\n  - $k_{\\text{b}} = 5.0\\ \\text{s}^{-1}$，$k_{\\text{d}} = 4.0\\ \\text{s}^{-1}$，$n_{A} = 1$，$n_{0} = 3$，$T_{\\text{sim}} = 6000.0\\ \\text{s}$，种子 $= 13579$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上述案例一致，每个值都四舍五入到六位有效数字，并隐式以 $\\text{s}^{-1}$ 为单位，例如 $\\left[0.123456,0,0.042,0.9\\right]$。", "solution": "问题陈述经过严格验证，被认为是**有效的**。\n\n该问题具有**科学依据**，描述了一个通过经典的随机模拟算法（SSA）模拟的标准一维生灭过程。首次穿越通量的概念及其使用带重注入的暴力模拟进行估算是用于稀有事件模拟的前向通量采样（FFS）方法论的一个基本组成部分。使用截断泊松分布进行重注入与该过程已知的稳态性质相符。\n\n该问题是**适定的**。它为每个案例提供了所有必需的参数（$k_{\\text{b}}$, $k_{\\text{d}}$, $n_A$, $n_0$, $T_{\\text{sim}}$）、初始条件（通过重注入协议）和一个确定性元素（固定的随机数生成器种子），从而确保了计算结果的唯一性和可复现性。\n\n该问题是**客观**且完整的，其定义或要求中没有歧义。所有术语都在化学动力学和随机过程的背景下得到了正式定义。所提供的测试案例合乎逻辑，涵盖了不同的物理机制，包括一个边界情况（$n_0 = n_A+1$）和一个稀有事件场景，使该问题成为对实现正确性的有效测试。\n\n因此，可以构建一个合理的解决方案。\n\n任务是为一个生灭过程估算首次穿越通量 $\\widehat{\\Phi}_{A,0} = N_{\\text{hits}}/T_{\\text{sim}}$。这需要实现一个遵循前向通量采样所定义的特定协议的随机模拟。该模拟将基于 Gillespie 随机模拟算法（SSA）。\n\n算法的核心是一个状态转移循环，该循环一直运行直到累积的总模拟时间达到 $T_{\\text{sim}}$。系统由物种 $X$ 的拷贝数 $n$ 来表征。状态空间被划分为一个盆地区域 $A = \\{n \\mid n \\leq n_A\\}$、一个由第一个界面定义的目标区域 $\\lambda_0 = \\{n \\mid n \\geq n_0\\}$ 以及一个中间区域 $\\{n \\mid n_A  n  n_0\\}$。\n\n模拟逻辑如下：\n\n1.  **初始化**：\n    模拟在时间 $t=0$ 开始，初始到达次数为零（$N_{\\text{hits}}=0$）。初始状态 $n$ 不是一个固定值，而是从一个特定的概率分布中抽取，以确保过程在与重注入协议一致的稳态下开始。这个分布是无约束生灭过程的稳态分布，即均值为 $\\mu = k_{\\text{b}}/k_{\\text{d}}$ 的泊松分布，并截断到盆地 $A$。\n\n2.  **重注入分布采样**：\n    为了从 $\\{0, 1, \\dots, n_A\\}$ 上的截断泊松分布中采样一个状态，我们首先为每个状态 $i \\in A$ 计算未归一化的权重 $w_i = \\mu^i/i!$。将这些权重归一化以获得概率 $p_i$。然后构建累积分布函数（CDF）。通过抽取一个均匀随机数 $u \\in [0, 1)$ 并找到与第一个大于或等于 $u$ 的 CDF 值相对应的状态 $j$ 来采样一个状态（逆变换采样）。\n\n3.  **主模拟循环**：只要当前模拟时间 $t$ 小于 $T_{\\text{sim}}$，循环就继续进行。\n    a.  **SSA 步骤**：在给定状态 $n$，总倾向性为 $a_0(n) = k_{\\text{b}} + k_{\\text{d}}n$。从一个速率为 $a_0(n)$ 的指数分布中抽取一个时间步长 $\\Delta t$。总时间向前推进，$t \\leftarrow t + \\Delta t$。如果新时间超过 $T_{\\text{sim}}$，则终止循环以避免计算超出指定模拟窗口的事件。以与各自倾向性 $k_{\\text{b}}$ 和 $k_{\\text{d}}n$ 成正比的概率选择一个反应（生成，$n \\to n+1$；或消亡，$n \\to n-1$）。\n    b.  **FFS 状态逻辑**：模拟逻辑取决于系统之前是在盆地 $A$ 内部还是在其外部进行“越轨”。\n        i.  如果系统离开盆地（从 $n_{\\text{old}} \\le n_A$ 跃迁到 $n_{\\text{new}} > n_A$），则一次越轨开始。\n        ii. 当轨迹到达界面 $\\lambda_{0}$（$n \\ge n_0$）或返回盆地 $A$（$n \\le n_A$）时，一次越轨结束。\n        iii. 如果越轨以到达 $\\lambda_0$ 结束，则计数器 $N_{\\text{hits}}$ 加一。\n        iv. 在任何越轨终止（到达或返回）之后，系统状态 $n$ 会根据步骤 2 中描述的截断泊松分布立即通过重注入重置到盆地 $A$ 中。然后模拟从这个新状态继续。这种重注入是瞬时的状态重置，不会推进模拟时间。\n\n4.  **最终计算**：一旦模拟循环结束，通量估计值就通过记录的总到达次数除以总模拟时间来计算，即 $\\widehat{\\Phi}_{A,0} = N_{\\text{hits}} / T_{\\text{sim}}$。每个测试案例的结果都四舍五入到六位有效数字。\n\n该算法正确地实现了用于测量首次穿越通量的、基于 FFS 的指定协议。使用带种子的随机数生成器可确保对于给定的测试案例，输出是确定性的和可验证的。", "answer": "```python\nimport numpy as np\nfrom scipy.special import factorial\n\ndef estimate_flux(k_b, k_d, n_A, n_0, T_sim, seed):\n    \"\"\"\n    Estimates the first-crossing flux using SSA and an FFS-style reinjection protocol.\n\n    Args:\n        k_b (float): Birth rate constant.\n        k_d (float): Death rate constant.\n        n_A (int): Threshold for basin A.\n        n_0 (int): Threshold for the first interface.\n        T_sim (float): Total simulation time.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The estimated flux Phi_{A,0}.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    n_hits = 0\n    t_current = 0.0\n\n    # 1. Pre-calculate the reinjection distribution (truncated Poisson)\n    # The unconstrained stationary distribution is Poisson with mean mu.\n    mu = k_b / k_d\n    \n    # Weights for states n = 0, 1, ..., n_A\n    states_A = np.arange(n_A + 1)\n    # Using gammaln for log-factorials is more stable, but for small n_A, direct factorial is fine.\n    # SciPy's factorial handles arrays.\n    weights = np.power(mu, states_A) / factorial(states_A)\n    \n    # Handle the case where all weights are zero (e.g., mu=0, n_A > 0)\n    if np.sum(weights) == 0:\n        # If mu=0, the only state with non-zero weight is n=0.\n        if mu == 0:\n            weights[0] = 1.0\n        else: # Should not happen with positive kb, kd.\n            raise ValueError(\"Could not compute a valid reinjection distribution.\")\n\n    probabilities = weights / np.sum(weights)\n    cdf = np.cumsum(probabilities)\n\n    def reinject():\n        \"\"\"Samples a new state from the truncated Poisson distribution in basin A.\"\"\"\n        u = rng.random()\n        # Find the first index where the cumulative probability is >= u\n        new_n = np.searchsorted(cdf, u, side='left')\n        return new_n\n\n    # 2. Initialization\n    n = reinject()\n    in_excursion = False\n\n    # 3. Main simulation loop\n    while t_current  T_sim:\n        a_birth = k_b\n        # Death propensity is 0 if n=0, preventing n from becoming negative.\n        a_death = k_d * n if n > 0 else 0.0\n        a_total = a_birth + a_death\n\n        if a_total == 0:\n            # System is in an absorbing state, time advances to infinity.\n            # This happens if k_b=0 and n=0. Not expected in test cases.\n            break\n\n        # Generate time step from exponential distribution\n        dt = rng.exponential(1.0 / a_total)\n        \n        t_next = t_current + dt\n        if t_next > T_sim:\n            # This step would cross the T_sim boundary, so we end the simulation here.\n            break\n        \n        t_current = t_next\n        n_old = n\n\n        # Choose reaction\n        if rng.random() * a_total  a_birth:\n            n += 1 # Birth\n        else:\n            n -= 1 # Death\n\n        # 4. FFS Logic: check for excursion start, hit, or return\n        was_in_excursion = in_excursion\n        \n        if not was_in_excursion: # System was in basin A (n_old = n_A)\n            if n > n_A: # Trajectory has just left A, starting an excursion\n                in_excursion = True\n                # Check for an immediate hit (e.g., when n_0 = n_A + 1)\n                if n >= n_0:\n                    n_hits += 1\n                    n = reinject()\n                    in_excursion = False\n        else: # System was in an excursion (n_old > n_A)\n            if n >= n_0: # Excursion hits the target interface\n                n_hits += 1\n                n = reinject()\n                in_excursion = False\n            elif n = n_A: # Excursion returns to the basin\n                # This is a failed excursion, no hit is counted\n                n = reinject()\n                in_excursion = False\n            # else: n_A  n  n_0, excursion continues\n\n    # 5. Final calculation\n    if T_sim == 0:\n        return 0.0\n    \n    flux_estimate = n_hits / T_sim\n    return flux_estimate\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (k_b, k_d, n_A, n_0, T_sim, seed)\n        (1.0, 0.5, 1, 4, 4000.0, 12345),\n        (0.2, 1.0, 1, 5, 20000.0, 67890),\n        (3.0, 1.0, 2, 3, 3000.0, 24680),\n        (5.0, 4.0, 1, 3, 6000.0, 13579),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_b, k_d, n_A, n_0, T_sim, seed = case\n        flux = estimate_flux(k_b, k_d, n_A, n_0, T_sim, seed)\n        # Format to 6 significant digits using 'g' format specifier\n        results.append(f\"{flux:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2645590"}, {"introduction": "理论联系实际往往会遇到意想不到的挑战。本练习旨在解决一个在离散状态系统（例如通过 SSA 模拟的系统）中应用 FFS 时的关键问题：如何正确处理在单步反应中“越过”多个界面的大跳跃。掌握这一点是确保速率计算无偏性的前提，同时也体现了对 FFS 路径计数框架的深刻理解。[@problem_id:2645582]", "problem": "我们使用前向通量采样（FFS）研究一个充分混合的化学反应网络中的稀有跃迁，以估计从区域 $A$ 到区域 $B$ 的跃迁速率。序参数是拷贝数向量 $\\mathbf{n}$ 的一个标量函数 $\\lambda(\\mathbf{n})$，界面由阈值 $\\lambda_0  \\lambda_1  \\lambda_2  \\lambda_3$ 定义，其中 $A = \\{\\lambda \\le \\lambda_0\\}$ 且 $B = \\{\\lambda \\ge \\lambda_3\\}$。动力学过程通过随机模拟算法（SSA）进行模拟，因此 $\\lambda$ 通过离散的反应事件发生变化，这些事件可能在单步反应中使 $\\lambda$ 的增量超过一个界面间距。\n\n我们进行了一项 FFS 研究，界面设在 $\\lambda_0 = 0$、$\\lambda_1 = 2$、$\\lambda_2 = 4$ 和 $\\lambda_3 = 6$。一个被约束在区域 $A$ 内的长时程模拟运行了总时间 $T_A = 10^4$ 个时间单位，产生了 $N_{\\Phi} = 80$ 次对 $\\lambda_1$ 的首次穿越。从存储的 $\\lambda_1$ 首次穿越构型出发，我们启动了 $M_1 = 200$ 次独立的 SSA 尝试。其中，$S_{1,\\text{total}} = 120$ 次在返回区域 $A$ 之前达到了 $\\lambda \\ge \\lambda_2$，$R_1 = 80$ 次首先返回了区域 $A$。在 $S_{1,\\text{total}}$ 次成功事件中，$S_{1,\\text{over}} = 30$ 次“过冲”，即在单步 SSA 反应中直接跃迁到 $\\lambda \\ge \\lambda_3$ 的状态，一次性跳过了 $\\lambda_2$ 和 $\\lambda_3$ 两个阈值，而剩下的 $S_{1,\\text{norm}} = 90$ 次则落在 $\\lambda \\in [\\lambda_2, \\lambda_3)$ 的区间内。\n\n对于下一阶段，我们从 $\\lambda_1 \\to \\lambda_2$ 阶段产生的每个存储的终点构型启动一次尝试（即，该阶段的每次成功对应一次尝试）。对于 $S_{1,\\text{norm}} = 90$ 个 $\\lambda \\in [\\lambda_2,\\lambda_3)$ 的终点，每个终点运行一次 SSA 尝试，得到 $S_{2,\\text{sim}} = 45$ 条在返回区域 $A$ 之前达到 $\\lambda \\ge \\lambda_3$ 的轨迹。对 $S_{1,\\text{over}} = 30$ 个过冲终点的处理方式取决于所采用的界面穿越归属规则。\n\n假设 FFS 估计量由 (i) 从 $A$ 首次穿越 $\\lambda_1$ 的稳态通量和 (ii) 在返回 $A$ 之前到达下一个界面的条件概率（相对于相应的首次穿越系综定义）构成。仅基于这些定义以及马尔可夫跳跃过程中条件概率和通量的标准性质，选择既能正确处理 SSA 中跳过多个界面的过冲事件，又能根据上述数据得出 $A \\to B$ 跃迁速率 $k_{AB}$ 的正确数值估计的选项。\n\n选项：\nA. 将任何从 $\\lambda_1$ 过冲并落在 $\\lambda \\ge \\lambda_3$ 的事件，同时计为穿越所有被跨过界面的成功事件。在估计下一阶段的条件概率时，将这 $S_{1,\\text{over}}$ 个终点从分母中排除，因为它们“已经成功”。采用这种处理方式，速率为 $k_{AB} = 0.004$。\n\nB. 将从 $\\lambda_i$ 的过冲仅计为当前阶段 $i$ 的成功事件，并将其落点构型插入到它新进入的第一个界面（这里是 $\\lambda_2$）的首次穿越系综中。在下一阶段，将这样的构型视为一次零长度尝试，如果它已经满足下一个界面的条件（这里是 $\\lambda \\ge \\lambda_3$），则立即视为成功。采用这种处理方式，速率为 $k_{AB} = 0.003$。\n\nC. 拒绝过冲事件，并重新采样 SSA 步骤，直到落点构型位于区间 $[\\lambda_2,\\lambda_3)$ 内，从而确保每次成功都恰好前进一个界面。采用这种处理方式，速率为 $k_{AB} = 0.0018$。\n\nD. 将每个过冲事件的统计权重平均分配给所有被跨过的界面，并将分数式成功数加到每个界面的估计量中。在下一阶段的分母中保留所有终点。采用这种处理方式，速率为 $k_{AB} = 0.0021$。\n\n选择唯一最佳答案。", "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n提供的明确数据和定义如下：\n- **系统**：一个充分混合的化学反应网络。\n- **过程**：从区域 `$A$` 到区域 `$B$` 的稀有跃迁。\n- **模拟方法**：随机模拟算法 (SSA)。\n- **采样方法**：前向通量采样 (FFS)。\n- **序参数**：一个标量函数 `$\\lambda(\\mathbf{n})$`。\n- **区域和界面**：\n    - 区域 `$A$` 定义为 `$\\{\\lambda \\le \\lambda_0\\}$`。\n    - 区域 `$B$` 定义为 `$\\{\\lambda \\ge \\lambda_3\\}$`。\n    - 界面位于 `$\\lambda_0 = 0$`、`$\\lambda_1 = 2$`、`$\\lambda_2 = 4$` 和 `$\\lambda_3 = 6$`。\n- **阶段 0 数据（从 `$A$` 到 `$\\lambda_1$` 的通量）**：\n    - 在 `$A$` 内约束模拟的总时间：`$T_A = 10^4$` 时间单位。\n    - 首次穿越 `$\\lambda_1$` 的次数：`$N_{\\Phi} = 80$`。\n- **阶段 1 数据（`$\\lambda_1 \\to \\lambda_2$`）**：\n    - 从 `$\\lambda_1$` 穿越构型启动的尝试次数：`$M_1 = 200$`。\n    - 成功的总尝试次数（达到 `$\\lambda \\ge \\lambda_2$`）：`$S_{1,\\text{total}} = 120$`。\n    - 失败的尝试次数（返回 `$A$`）：`$R_1 = 80$`。\n    - 成功事件中，落在 `$[\\lambda_2, \\lambda_3)$` 的正常成功次数：`$S_{1,\\text{norm}} = 90$`。\n    - 成功事件中，落在 `$\\lambda \\ge \\lambda_3$` 的过冲成功次数：`$S_{1,\\text{over}} = 30$`。\n- **阶段 2 数据（`$\\lambda_2 \\to \\lambda_3$`）**：\n    - 从 `$S_{1,\\text{norm}} = 90$` 个正常终点出发，运行 SSA 尝试。\n    - 这些尝试中成功（达到 `$\\lambda \\ge \\lambda_3$`）的次数：`$S_{2,\\text{sim}} = 45$`。\n- **约束**：`$A \\to B$` 跃迁速率 `$k_{AB}$` 的估计量需根据稳态通量和条件概率构建，并基于马尔可夫跳跃过程的标准性质。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基础扎实。FFS 是一种标准且强大的技术，用于研究诸如通过 SSA 模拟的化学反应网络等随机系统中的稀有事件。过冲问题（序参数跳过一个或多个界面）是离散状态或离散时间系统 FFS 实现中一个已知且关键的细节。\n2.  **适定性**：该问题是适定的。只要知道处理过冲的正确算法，它就提供了计算速率所需的所有数值数据。问题明确要求给出正确的处理方法和由此产生的数值估计，这意味着在“直接”FFS 方法的标准框架内存在唯一的正确答案。\n3.  **客观性**：问题以客观、技术性的语言陈述，没有歧义或主观论断。数据内部一致（`$S_{1,\\text{norm}} + S_{1,\\text{over}} = 90 + 30 = 120 = S_{1,\\text{total}}$` 且 `$S_{1,\\text{total}} + R_1 = 120 + 80 = 200 = M_1$`）。\n\n### 步骤 3：结论与处理\n问题陈述在科学上是合理的、自洽的且适定的。它呈现了一个应用 FFS 方法论的标准练习。该问题是**有效的**。我们继续进行求解。\n\n### 解答推导\n前向通量采样方法将跃迁速率 `$k_{AB}$` 估计为离开状态 `$A$` 的初始通量与一系列到达后续界面的条件概率的乘积。对于给定的界面设置，公式为：\n$$ k_{AB} = \\Phi_0 \\times P(\\lambda_2 | \\lambda_1) \\times P(\\lambda_3 | \\lambda_2) $$\n其中 `$\\Phi_0$` 是离开 `$A$` 并首次穿越 `$\\lambda_1$` 的轨迹通量，而 `$P(\\lambda_{i+1} | \\lambda_i)$` 是从一个刚穿越界面 `$\\lambda_i$` 的构型开始的轨迹在返回状态 `$A$` 之前将继续穿越界面 `$\\lambda_{i+1}$` 的条件概率。我们将逐项计算。\n\n**1. 初始通量, `$\\Phi_0$`**\n通量是从状态 `$A$` 首次穿越 `$\\lambda_1$` 的速率。它是根据在 `$A$` 中的长时程模拟估算的。\n$$ \\Phi_0 = \\frac{N_{\\Phi}}{T_A} = \\frac{80}{10^4} = 0.008 $$\n\n**2. 条件概率, `$P_1 = P(\\lambda_2 | \\lambda_1)$`**\n这是从一次 `$\\lambda_1$` 穿越开始的轨迹在返回 `$A$` 之前达到 `$\\lambda \\ge \\lambda_2$` 的概率。数据显示，从 `$M_1 = 200$` 次尝试中，共有 `$S_{1,\\text{total}} = 120$` 次成功。正常成功和过冲成功都满足达到 `$\\lambda \\ge \\lambda_2$` 的要求。\n$$ P_1 = \\frac{S_{1,\\text{total}}}{M_1} = \\frac{120}{200} = 0.6 $$\n\n**3. 条件概率, `$P_2 = P(\\lambda_3 | \\lambda_2)$`**\n这是问题的最关键部分，因为它涉及过冲事件的正确处理。FFS 算法建立在概率的级联乘积之上。`$\\lambda_2 \\to \\lambda_3$` 阶段的起始构型系综由 `$\\lambda_1 \\to \\lambda_2$` 阶段所有成功的终点组成。共有 `$S_{1,\\text{total}} = 120$` 个这样的终点。因此，第二阶段的尝试次数 `$M_2$` 为 `$120$`。\n\n这 `$120$` 个起始构型是：\n- `$S_{1,\\text{norm}} = 90$` 个构型，其 `$\\lambda \\in [\\lambda_2, \\lambda_3)$`。\n- `$S_{1,\\text{over}} = 30$` 个构型，其 `$\\lambda \\ge \\lambda_3$`。\n\n`$\\lambda_2 \\to \\lambda_3$` 阶段的成功次数 `$S_2$` 是这 `$120$` 条轨迹在返回 `$A$` 之前达到 `$\\lambda \\ge \\lambda_3$` 的数量。\n- `$S_{1,\\text{over}} = 30$` 个过冲构型*已经*满足成功标准 `$\\lambda \\ge \\lambda_3$`。它们代表已经到达最终区域 `$B$` 的轨迹。在 `$\\lambda_2 \\to \\lambda_3$` 阶段的背景下，它们是“零长度”的尝试，并且是立即成功的。因此，它们贡献了 `$30$` 次成功。\n- 对于 `$S_{1,\\text{norm}} = 90$` 个正常构型，问题陈述表明进行了模拟，产生了 `$S_{2,\\text{sim}} = 45$` 次成功。\n\n此阶段的总成功次数是两组成功次数的总和：\n$$ S_2 = S_{1,\\text{over}} + S_{2,\\text{sim}} = 30 + 45 = 75 $$\n条件概率 `$P_2$` 则是此阶段总成功次数与总尝试次数的比率：\n$$ P_2 = \\frac{S_2}{M_2} = \\frac{75}{S_{1,\\text{total}}} = \\frac{75}{120} = \\frac{5}{8} = 0.625 $$\n此过程正确地保持了通过界面序列的总概率通量。\n\n**4. 最终速率计算, `$k_{AB}$`**\n现在我们将各部分组合起来，求出总速率常数：\n$$ k_{AB} = \\Phi_0 \\times P_1 \\times P_2 $$\n$$ k_{AB} = 0.008 \\times 0.6 \\times 0.625 $$\n使用分数形式代入不易出错：\n$$ k_{AB} = \\frac{80}{10^4} \\times \\frac{120}{200} \\times \\frac{75}{120} $$\n分子和分母中的 `$120$` 项可以消掉：\n$$ k_{AB} = \\frac{80}{10000} \\times \\frac{75}{200} = \\frac{8 \\times 10}{10^4} \\times \\frac{75}{2 \\times 10^2} = \\frac{8 \\times 75}{2 \\times 10^5} = \\frac{4 \\times 75}{10^5} = \\frac{300}{10^5} = \\frac{3}{1000} = 0.003 $$\n正确计算出的速率是 `$k_{AB} = 0.003$`。\n\n### 逐项分析选项\n\n**A. 将任何从 $\\lambda_1$ 过冲并落在 $\\lambda \\ge \\lambda_3$ 的事件，同时计为穿越所有被跨过界面的成功事件。在估计下一阶段的条件概率时，将这 $S_{1,\\text{over}}$ 个终点从分母中排除，因为它们“已经成功”。采用这种处理方式，速率为 $k_{AB} = 0.004$。**\n所描述的逻辑是有缺陷的。在计算下一阶段概率时从分母中排除成功构型，违反了 FFS 所基于的条件概率原理。`$P(\\lambda_{i+1}|\\lambda_i)$` 的分母必须是前一阶段的总成功次数 `$S_i$`。按照该选项的规定，`$P_2 = S_{2,\\text{sim}} / S_{1,\\text{norm}} = 45/90 = 0.5$`。这将得出 `$k_{AB} = 0.008 \\times 0.6 \\times 0.5 = 0.0024$`，与选项中声称的 `$0.004$` 不符。该选项在算法上不正确，在数值上也不一致。**不正确**。\n\n**B. 将从 $\\lambda_i$ 的过冲仅计为当前阶段 $i$ 的成功事件，并将其落点构型插入到它新进入的第一个界面（这里是 $\\lambda_2$）的首次穿越系综中。在下一阶段，将这样的构型视为一次零长度尝试，如果它已经满足下一个界面的条件（这里是 $\\lambda \\ge \\lambda_3$），则立即视为成功。采用这种处理方式，速率为 $k_{AB} = 0.003$。**\n此选项描述了在直接 FFS 算法中处理过冲的正确、标准流程。过冲是当前阶段的成功事件，其终点被正确地包含在下一阶段的系综中。如果该终点已经满足下一阶段的标准，它将被恰当地计为一次自动成功。我们遵循此逻辑的推导得出了 `$k_{AB} = 0.003$`。该方法的描述是正确的，数值结果也是正确的。**正确**。\n\n**C. 拒绝过冲事件，并重新采样 SSA 步骤，直到落点构型位于区间 $[\\lambda_2,\\lambda_3)$ 内，从而确保每次成功都恰好前进一个界面。采用这种处理方式，速率为 $k_{AB} = 0.0018$。**\n这个过程是不正确的，因为它引入了偏差。因为物理反应步骤“太大”而拒绝并重新采样，从根本上改变了被采样的动力学过程。得到的路径系综和速率估计将不对应于真实系统。此外，如果将“拒绝”误解为“丢弃”，仅考虑 `$S_{1,\\text{norm}}=90$` 次成功来计算 `$P_1$`，会得到 `$P_1 = 90/200 = 0.45$`。再加上 `$P_2 = 45/90 = 0.5$`，得出 `$k_{AB} = 0.008 \\times 0.45 \\times 0.5 = 0.0018$`。虽然数值匹配，但它是从一个无效的过程中推导出来的；丢弃成功路径是一个严重的错误。所提议的方法（“拒绝并重新采样”）不是一个标准的、无偏的 FFS 协议。**不正确**。\n\n**D. 将每个过冲事件的统计权重平均分配给所有被跨过的界面，并将分数式成功数加到每个界面的估计量中。在下一阶段的分母中保留所有终点。采用这种处理方式，速率为 $k_{AB} = 0.0021$。**\n这个提议是一种临时的启发式方法，没有坚实的概率论基础。FFS 基于对离散的、整数数量的成功和失败路径的计数。“分数式成功”或“拆分权重”的概念在标准表述中是不存在的，它破坏了其清晰的概率解释。不可能从任何严格的统计力学原理应用中推导出速率 0.0021。**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2645582"}, {"introduction": "高效的模拟是强大的研究工具。这最后一个练习将我们带入自适应算法的领域，展示了如何在一个 FFS 模拟中优化计算资源的分配，以便在给定的计算成本下获得最精确的速率估计。你将推导并实现一个反馈控制律，该控制律能够动态调整每个界面上的试验次数，这项技术对于解决复杂的高维问题至关重要。[@problem_id:2645571]", "problem": "您正在设计一个用于前向流采样（Forward Flux Sampling, FFS）的自适应采样器，以估计反应网络中从集合 $A$ 到集合 $B$ 的稀有事件率。该速率的 FFS 估计量是初始通量估计值与跨越 $M$ 个界面的步进条件概率的乘积，即 $\\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=1}^{M} \\hat{p}_i$，其中 $\\hat{p}_i$ 是在界面 $i$ 使用 $n_i$ 次独立伯努利试验估计得出的。为了决策在何处增加试验，请专注于界面 $\\{1,\\dots,M\\}$ 的贡献，并在此控制步骤中将初始通量项视为固定值。\n\n您的目标是形式化一个反馈控制律，该控制律在对 $\\ln \\hat{k}_{AB}$ 方差的估计贡献较高的界面上增加试验次数，并推导一个满足成本预算的显式更新规则。您必须基于以下基础进行工作：\n\n- FFS 分解 $\\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=1}^{M} \\hat{p}_i$。\n- 对于具有 $n_i$ 次试验和真实成功概率 $p_i \\in (0,1)$ 的二项估计量 $\\hat{p}_i$，其方差为 $\\mathrm{Var}(\\hat{p}_i) = \\dfrac{p_i (1 - p_i)}{n_i}$。\n- Delta 方法：对于一个平滑函数 $g$，当 $n_i$ 很大时，$\\mathrm{Var}(g(\\hat{p}_i)) \\approx \\left(g'(p_i)\\right)^2 \\mathrm{Var}(\\hat{p}_i)$。\n- 为了控制设计的目的，界面之间采用独立性近似。\n\n任务：\n\n1) 从 $\\hat{k}_{AB}$ 的分解和 delta 方法出发，推导界面 $i$ 对 $\\ln \\hat{k}_{AB}$ 方差贡献的近似表达式（用 $n_i$ 和 $p_i$ 表示），并由此得出 $\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$ 在各界面上的可加近似。\n\n2) 假设在界面 $i$ 执行一次试验的成本为正值 $c_i$，您当前的分配为 $(n_1,\\dots,n_M)$，当前成本预算为 $B = \\sum_{i=1}^{M} c_i n_i$。您获得一笔额外的预算 $B^{+}  0$ 用于分配。构建并解决优化问题，该问题在新的分配 $(n_1^{\\star},\\dots,n_M^{\\star})$ 下最小化近似的 $\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$，并受线性预算约束 $\\sum_{i=1}^{M} c_i n_i^{\\star} = B + B^{+}$ 的限制。请明确地用界面概率 $p_i$、成本 $c_i$ 和总预算 $B + B^{+}$ 表示 $n_i^{\\star}$。\n\n3) 提出一个反馈控制更新，它使用一个步长 $\\beta \\in (0,1]$ 将当前分配与最优目标相融合：\n$$\nn_i^{\\mathrm{new}} \\;=\\; (1 - \\beta)\\, n_i \\;+\\; \\beta\\, n_i^{\\star}.\n$$\n使用您在任务2中得到的 $n_i^{\\star}$ 表达式，给出 $n_i^{\\mathrm{new}}$ 关于 $p_i$、$c_i$、$n_i$、$B$、$B^{+}$ 和 $\\beta$ 的显式闭合形式。解释为什么这个更新会优先在对 $\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$ 估计贡献较高的界面增加试验次数。\n\n4) 实现一个程序，为下述每个测试用例计算 $n_i^{\\mathrm{new}}$。在每个案例中，为了模拟和测试的目的，您可以假设控制律中使用的估计成功概率 $\\hat{p}_i$ 等于给定的 $p_i$。该程序必须：\n\n- 对每个案例，接收向量 $(p_1,\\dots,p_M)$、$(c_1,\\dots,c_M)$、$(n_1,\\dots,n_M)$ 以及标量 $B^{+}$ 和 $\\beta$ 作为输入。\n- 计算 $B = \\sum_{i=1}^{M} c_i n_i$ 和 $B_{\\mathrm{tot}} = B + B^{+}$。\n- 使用 $p_i$ 和 $c_i$ 计算任务2中的目标 $n_i^{\\star}$。\n- 计算任务3中的 $n_i^{\\mathrm{new}}$。\n- 为每个测试用例返回向量 $(n_1^{\\mathrm{new}},\\dots,n_M^{\\mathrm{new}})$。\n\n数值输出必须四舍五入到恰好 $6$ 位小数，并视为无单位的实数。\n\n测试套件：\n\n- 案例1：$M = 3$，$p = (0.2, 0.5, 0.8)$，$c = (1.0, 1.0, 1.0)$，$n = (100.0, 100.0, 100.0)$，$B^{+} = 90.0$，$\\beta = 1.0$。\n- 案例2：$M = 3$，$p = (0.05, 0.4, 0.7)$，$c = (1.0, 2.0, 1.0)$，$n = (10.0, 10.0, 10.0)$，$B^{+} = 90.0$，$\\beta = 1.0$。\n- 案例3：$M = 4$，$p = (0.9, 0.95, 0.6, 0.3)$，$c = (1.0, 1.0, 1.0, 1.0)$，$n = (50.0, 50.0, 50.0, 50.0)$，$B^{+} = 40.0$，$\\beta = 0.5$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内容是每个案例的结果，而每个案例的结果本身也是一个逗号分隔的四舍五入浮点数列表，所有内容都包含在方括号内。具体来说，要求的格式是：\n$$\n\\text{print: } [[n_{1,1}^{\\mathrm{new}},\\dots,n_{1,M_1}^{\\mathrm{new}}],[n_{2,1}^{\\mathrm{new}},\\dots,n_{2,M_2}^{\\mathrm{new}}],[n_{3,1}^{\\mathrm{new}},\\dots,n_{3,M_3}^{\\mathrm{new}}]]\n$$\n不含任何额外的空格或文本。例如，两个案例的有效输出形式为 $[[1.000000,2.000000],[3.000000,4.000000]]$。", "solution": "我们从前向流采样（FFS）分解 $\\hat{k}_{AB} = \\hat{\\Phi}_{A,0} \\prod_{i=1}^{M} \\hat{p}_i$ 开始。取自然对数得到\n$$\n\\ln \\hat{k}_{AB} \\;=\\; \\ln \\hat{\\Phi}_{A,0} \\;+\\; \\sum_{i=1}^{M} \\ln \\hat{p}_i.\n$$\n在初始通量和界面概率估计量之间，以及各界面估计量之间相互独立的近似下，$\\ln \\hat{k}_{AB}$ 的方差近似可加：\n$$\n\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right) \\;\\approx\\; \\mathrm{Var}\\!\\left(\\ln \\hat{\\Phi}_{A,0}\\right) \\;+\\; \\sum_{i=1}^{M} \\mathrm{Var}\\!\\left(\\ln \\hat{p}_i\\right).\n$$\n为控制界面的试验次数，我们将 $\\mathrm{Var}\\!\\left(\\ln \\hat{\\Phi}_{A,0}\\right)$ 视为固定值，并专注于对界面求和的部分。\n\n任务1：对于每个界面 $i$，估计量 $\\hat{p}_i$ 是一个具有 $n_i$ 次试验和成功概率 $p_i \\in (0,1)$ 的二项比例。因此\n$$\n\\mathrm{Var}(\\hat{p}_i) \\;=\\; \\frac{p_i (1 - p_i)}{n_i}.\n$$\n应用 delta 方法，令 $g(x) = \\ln x$，其导数为 $g'(x) = \\dfrac{1}{x}$，\n$$\n\\mathrm{Var}\\!\\left(\\ln \\hat{p}_i\\right) \\;\\approx\\; \\left(g'(p_i)\\right)^2 \\mathrm{Var}(\\hat{p}_i) \\;=\\; \\frac{1}{p_i^2} \\cdot \\frac{p_i (1 - p_i)}{n_i} \\;=\\; \\frac{1 - p_i}{n_i p_i}.\n$$\n因此，各界面对方差的贡献可加和为\n$$\n\\sum_{i=1}^{M} \\mathrm{Var}\\!\\left(\\ln \\hat{p}_i\\right) \\;\\approx\\; \\sum_{i=1}^{M} \\frac{1 - p_i}{n_i p_i}.\n$$\n我们将界面 $i$ 的贡献确定为\n$$\nv_i(n_i, p_i) \\;=\\; \\frac{1 - p_i}{n_i p_i} \\;=\\; \\frac{a_i}{n_i}, \\quad \\text{其中 } a_i \\;=\\; \\frac{1 - p_i}{p_i}.\n$$\n\n任务2：假设在界面 $i$ 进行一次试验的成本为 $c_i  0$，当前分配为 $(n_1,\\dots,n_M)$，预算为 $B = \\sum_{i=1}^{M} c_i n_i$，并且我们收到一笔额外的预算 $B^{+}  0$。设新预算为\n$$\nB_{\\mathrm{tot}} \\;=\\; B \\;+\\; B^{+} \\;=\\; \\sum_{i=1}^{M} c_i n_i^{\\star}.\n$$\n我们寻求 $(n_1^{\\star},\\dots,n_M^{\\star})$ 来最小化近似方差\n$$\n\\min_{n_1^{\\star},\\dots,n_M^{\\star}  0} \\;\\; \\sum_{i=1}^{M} \\frac{a_i}{n_i^{\\star}} \\quad \\text{约束条件为} \\quad \\sum_{i=1}^{M} c_i n_i^{\\star} \\;=\\; B_{\\mathrm{tot}}.\n$$\n构建拉格朗日函数\n$$\n\\mathcal{L}(\\{n_i^{\\star}\\}, \\lambda) \\;=\\; \\sum_{i=1}^{M} \\frac{a_i}{n_i^{\\star}} \\;+\\; \\lambda \\left(\\sum_{i=1}^{M} c_i n_i^{\\star} - B_{\\mathrm{tot}}\\right).\n$$\n对 $n_i^{\\star}$ 的驻点条件得出\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial n_i^{\\star}} \\;=\\; - \\frac{a_i}{(n_i^{\\star})^2} \\;+\\; \\lambda c_i \\;=\\; 0\n\\;\\;\\Rightarrow\\;\\; n_i^{\\star} \\;=\\; \\sqrt{\\frac{a_i}{\\lambda c_i}}.\n$$\n应用约束条件得到\n$$\n\\sum_{i=1}^{M} c_i n_i^{\\star} \\;=\\; \\sum_{i=1}^{M} c_i \\sqrt{\\frac{a_i}{\\lambda c_i}} \\;=\\; \\frac{1}{\\sqrt{\\lambda}} \\sum_{i=1}^{M} \\sqrt{a_i c_i} \\;=\\; B_{\\mathrm{tot}},\n$$\n所以\n$$\n\\sqrt{\\lambda} \\;=\\; \\frac{1}{B_{\\mathrm{tot}}} \\sum_{j=1}^{M} \\sqrt{a_j c_j}.\n$$\n代回后得到\n$$\nn_i^{\\star} \\;=\\; \\frac{B_{\\mathrm{tot}}}{\\sum_{j=1}^{M} \\sqrt{a_j c_j}} \\;\\sqrt{\\frac{a_i}{c_i}}\n\\;=\\; \\frac{B + B^{+}}{\\sum_{j=1}^{M} \\sqrt{\\dfrac{1 - p_j}{p_j} c_j}} \\;\\sqrt{\\frac{1 - p_i}{p_i c_i}}.\n$$\n这个分配方案在 $\\dfrac{1 - p_i}{p_i}$ 较大（即 $p_i$ 较小）且 $c_i$ 较小的界面上增加 $n_i^{\\star}$，这反映了方差减小与成本之间的最优权衡。\n\n任务3：一个自然的反馈控制律使用步长 $\\beta \\in (0,1]$ 将当前分配与目标分配相融合：\n$$\nn_i^{\\mathrm{new}} \\;=\\; (1 - \\beta)\\, n_i \\;+\\; \\beta\\, n_i^{\\star},\n$$\n即\n$\nn_i^{\\mathrm{new}} \\;=\\; (1 - \\beta)\\, n_i \\;+\\; \\beta \\;\\dfrac{B + B^{+}}{\\sum_{j=1}^{M} \\sqrt{\\dfrac{1 - p_j}{p_j} c_j}} \\;\\sqrt{\\dfrac{1 - p_i}{p_i c_i}}.\n$\n因为 $n_i^{\\star}$ 与 $\\sqrt{\\dfrac{1 - p_i}{p_i c_i}}$ 成正比，所以对 $\\mathrm{Var}\\!\\left(\\ln \\hat{k}_{AB}\\right)$ 估计贡献（由 $a_i / n_i$ 量化）较高的界面会获得更多的分配。平方根形式源于线性预算下的凸优化问题，相当于一个具有收益递减的连续背包问题。该更新优先在 $a_i$ 大且 $c_i$ 小的界面增加 $n_i$，步长 $\\beta$ 控制了响应性与稳定性之间的平衡。\n\n实现算法：\n\n- 给定 $(p_i)$、$(c_i)$、$(n_i)$，计算 $B = \\sum_{i=1}^{M} c_i n_i$ 和 $B_{\\mathrm{tot}} = B + B^{+}$。\n- 对所有 $i$ 计算 $a_i = \\dfrac{1 - p_i}{p_i}$ 和 $S = \\sum_{j=1}^{M} \\sqrt{a_j c_j}$。\n- 如果 $S  0$，则设 $n_i^{\\star} = \\dfrac{B_{\\mathrm{tot}}}{S} \\sqrt{\\dfrac{a_i}{c_i}}$；否则，作为一种退化备用方案（在提供的测试中不会发生），将 $B^{+}$ 在试验次数上均匀分配：$\\Delta n_i = \\dfrac{B^{+}}{\\sum_{j=1}^{M} c_j}$ 且 $n_i^{\\star} = n_i + \\Delta n_i$。\n- 更新 $n_i^{\\mathrm{new}} = (1 - \\beta) n_i + \\beta n_i^{\\star}$，然后四舍五入到 $6$ 位小数。\n\n所要求的程序将此过程应用于三个指定的测试用例，并以指定的单行格式输出向量 $(n_i^{\\mathrm{new}})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_updated_counts(p, c, n, delta_budget, beta):\n    p = np.asarray(p, dtype=float)\n    c = np.asarray(c, dtype=float)\n    n = np.asarray(n, dtype=float)\n\n    # Current and total budgets\n    B_old = float(np.dot(c, n))\n    B_total = B_old + float(delta_budget)\n\n    # a_i = (1 - p_i)/p_i\n    # Ensure p in (0,1) to avoid division by zero; assume inputs valid per problem statement.\n    a = (1.0 - p) / p\n\n    # S = sum sqrt(a_i * c_i)\n    # Interfaces with p_i == 1 have a_i == 0 and contribute zero to S.\n    ac = a * c\n    # Guard against tiny negative due to roundoff\n    ac = np.where(ac  0.0, 0.0, ac)\n    sqrt_ac = np.sqrt(ac)\n    S = float(np.sum(sqrt_ac))\n\n    if S > 0.0:\n        # n_i^* = (B_total / S) * sqrt(a_i / c_i)\n        # Note: sqrt(a_i / c_i) = sqrt(a_i * 1/c_i)\n        # Handle c_i > 0 as per problem statement.\n        sqrt_a_over_c = np.sqrt(a / c)\n        n_star = (B_total / S) * sqrt_a_over_c\n    else:\n        # Degenerate fallback (not triggered by provided tests):\n        # Distribute delta_budget evenly in counts so that sum c_i * Δn_i = delta_budget.\n        denom = float(np.sum(c))\n        if denom == 0.0:\n            n_star = n.copy()\n        else:\n            delta_n_each = delta_budget / denom\n            n_star = n + delta_n_each\n\n    # Feedback update\n    n_new = (1.0 - beta) * n + beta * n_star\n\n    # Round to 6 decimals as required\n    n_new = np.round(n_new.astype(float), 6)\n\n    return n_new.tolist()\n\ndef format_list_no_spaces(list_of_lists):\n    # Custom formatter to avoid spaces and enforce 6-decimal floats\n    # Assumes list_of_lists is a list of lists of floats\n    outer_parts = []\n    for inner in list_of_lists:\n        inner_parts = []\n        for x in inner:\n            inner_parts.append(f\"{float(x):.6f}\")\n        outer_parts.append(\"[\" + \",\".join(inner_parts) + \"]\")\n    return \"[\" + \",\".join(outer_parts) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: M=3, p=(0.2,0.5,0.8), c=(1.0,1.0,1.0), n=(100.0,100.0,100.0), B+=90.0, beta=1.0\n    case1 = {\n        \"p\": [0.2, 0.5, 0.8],\n        \"c\": [1.0, 1.0, 1.0],\n        \"n\": [100.0, 100.0, 100.0],\n        \"delta_budget\": 90.0,\n        \"beta\": 1.0\n    }\n    # Case 2: M=3, p=(0.05,0.4,0.7), c=(1.0,2.0,1.0), n=(10.0,10.0,10.0), B+=90.0, beta=1.0\n    case2 = {\n        \"p\": [0.05, 0.4, 0.7],\n        \"c\": [1.0, 2.0, 1.0],\n        \"n\": [10.0, 10.0, 10.0],\n        \"delta_budget\": 90.0,\n        \"beta\": 1.0\n    }\n    # Case 3: M=4, p=(0.9,0.95,0.6,0.3), c=(1.0,1.0,1.0,1.0), n=(50.0,50.0,50.0,50.0), B+=40.0, beta=0.5\n    case3 = {\n        \"p\": [0.9, 0.95, 0.6, 0.3],\n        \"c\": [1.0, 1.0, 1.0, 1.0],\n        \"n\": [50.0, 50.0, 50.0, 50.0],\n        \"delta_budget\": 40.0,\n        \"beta\": 0.5\n    }\n\n    test_cases = [case1, case2, case3]\n\n    results = []\n    for case in test_cases:\n        updated = compute_updated_counts(\n            p=case[\"p\"],\n            c=case[\"c\"],\n            n=case[\"n\"],\n            delta_budget=case[\"delta_budget\"],\n            beta=case[\"beta\"]\n        )\n        results.append(updated)\n\n    # Final print statement in the exact required format: no spaces\n    print(format_list_no_spaces(results))\n\nsolve()\n```", "id": "2645571"}]}