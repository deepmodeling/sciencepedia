{"hands_on_practices": [{"introduction": "在RRKM理论中，准确计算分子的振动能态密度和态和是核心步骤。这个实践将指导你从第一性原理出发，为一个由量子谐振子构成的分子体系，构建一个离散化的直接计数算法。通过实现这个算法[@problem_id:2672869]，你将掌握计算谐振子模型下态和$N(E)$的基本计算方法，这是理解分子内部能量分配统计性质的基石。", "problem": "考虑一个具有 $f$ 个振动自由度的非线性分子，这些自由度被建模为独立的量子谐振子 (HOs)。设爱因斯坦频率（以波数为单位）的集合为 $\\{\\nu_i\\}_{i=1}^{m}$，其中每个不同的频率 $\\nu_i$ 具有整数模式简并度 $g_i \\in \\mathbb{Z}_{\\ge 1}$。总振动模式数为 $f = \\sum_{i=1}^{m} g_i$。一个振动量子态由非负整数 $\\{n_{i,a}\\}$ 指定，其中 $i \\in \\{1,\\dots,m\\}$ 且 $a \\in \\{1,\\dots,g_i\\}$，$n_{i,a}$ 是频率为 $\\nu_i$ 的 $g_i$ 重简并集中第 $a$ 个成员的量子数。\n\n在 Rice–Ramsperger–Kassel–Marcus (RRKM) 理论中，谐振子浴的微正则态总和 $N_{\\mathrm{HO}}(E)$ 是指总振动能量不超过给定能量 $E$ 的不同量子态的数量。使用波数单位，定义 $\\tilde{E} \\equiv E/(hc)$ 并以 $\\mathrm{cm}^{-1}$ 为单位测量所有能量。零点能为\n$$\n\\tilde{E}_0 = \\frac{1}{2} \\sum_{i=1}^{m} g_i \\nu_i,\n$$\n零点以上的激发能为 $\\tilde{E}_{\\mathrm{exc}} = \\tilde{E} - \\tilde{E}_0$。一个态 $\\{n_{i,a}\\}$ 的能量（以 $\\mathrm{cm}^{-1}$ 为单位）为\n$$\n\\tilde{E}(\\{n_{i,a}\\}) = \\sum_{i=1}^{m} \\sum_{a=1}^{g_i} \\left(n_{i,a} + \\frac{1}{2}\\right) \\nu_i.\n$$\n因此，总能量为 $\\tilde{E}$ 时的微正则态总和为\n$$\nN_{\\mathrm{HO}}(\\tilde{E}) = \\#\\left\\{ \\{n_{i,a}\\} \\in \\mathbb{Z}_{\\ge 0}^{f} \\,\\Big|\\, \\sum_{i=1}^{m} \\sum_{a=1}^{g_i} n_{i,a} \\nu_i \\le \\tilde{E} - \\tilde{E}_0 \\right\\}.\n$$\n\n你的任务是为 $N_{\\mathrm{HO}}(\\tilde{E})$ 构建一个离散态数统计算法，该算法需考虑零点能位移和模式简并度。为确保算法完全离散，引入能量箱宽度 $\\Delta \\varepsilon$（以 $\\mathrm{cm}^{-1}$ 为单位），并将每个频率 $\\nu_i$ 映射到一个整数箱权重 $w_i = \\mathrm{round}(\\nu_i / \\Delta \\varepsilon) \\in \\mathbb{Z}_{\\ge 1}$。设以能量箱为单位的激发能为\n$$\nS = \\left\\lfloor \\frac{\\tilde{E} - \\tilde{E}_0}{\\Delta \\varepsilon} \\right\\rfloor.\n$$\n然后将 $N_{\\mathrm{HO}}(\\tilde{E})$ 计算为以下不等式的非负整数解的数量\n$$\n\\sum_{i=1}^{m} \\sum_{a=1}^{g_i} w_i \\, n_{i,a} \\le S,\n$$\n其中 $n_{i,a} \\in \\mathbb{Z}_{\\ge 0}$，并且如果 $\\tilde{E}  \\tilde{E}_0$，则定义 $N_{\\mathrm{HO}}(\\tilde{E}) = 0$。当两个或多个不同模式共享相同频率（即简并度 $g_i > 1$）时，它们必须被视为可区分的振子，贡献组合上不同的量子数分配。\n\n你必须实现一个算法，该算法能够：\n- 根据 $\\{\\nu_i\\}$ 和 $\\{g_i\\}$ 计算 $\\tilde{E}_0$，并适当地移动能量原点。\n- 使用 $\\Delta \\varepsilon$ 将频率和激发能离散化为整数箱权重和能量箱上限 $S$。\n- 计算上述不等式的解的数量，从而得出离散的 $N_{\\mathrm{HO}}(\\tilde{E})$。\n\n所有能量必须以 $\\mathrm{cm}^{-1}$ 为单位进行处理和报告。输出必须为整数。\n\n实现你的程序以评估以下测试套件。对于每种情况，输入包括不同频率的列表、匹配的简并度列表、总能量 $\\tilde{E}$（以 $\\mathrm{cm}^{-1}$ 为单位）以及能量箱宽度 $\\Delta \\varepsilon$（以 $\\mathrm{cm}^{-1}$ 为单位）。\n\n测试套件：\n- 情况 1：$\\{\\nu_i\\} = [1000, 1100, 1200]$，$\\{g_i\\} = [1, 1, 1]$，$\\tilde{E} = 3300$，$\\Delta \\varepsilon = 50$。\n- 情况 2：$\\{\\nu_i\\} = [500, 800]$，$\\{g_i\\} = [2, 1]$，$\\tilde{E} = 2000$，$\\Delta \\varepsilon = 50$。\n- 情况 3：$\\{\\nu_i\\} = [400, 600, 700]$，$\\{g_i\\} = [1, 1, 1]$，$\\tilde{E} = 849$，$\\Delta \\varepsilon = 1$。\n- 情况 4：$\\{\\nu_i\\} = [300]$，$\\{g_i\\} = [4]$，$\\tilde{E} = 1200$，$\\Delta \\varepsilon = 100$。\n- 情况 5：$\\{\\nu_i\\} = [200, 250, 400, 500]$，$\\{g_i\\} = [1, 2, 1, 1]$，$\\tilde{E} = 1800$，$\\Delta \\varepsilon = 50$。\n\n你的程序应产生单行输出，其中包含一个逗号分隔的列表，并用方括号括起来（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应测试用例计算出的整数 $N_{\\mathrm{HO}}(\\tilde{E})$。", "solution": "问题陈述经过验证，被认为是具有科学依据、适定且完整的。它提出了一个基于 Rice–Ramsperger–Kassel–Marcus (RRKM) 理论的化学动力学中的标准计算任务，该任务针对一个独立量子谐振子系统。该问题没有矛盾或歧义，并为其解决提供了所有必要的数据。\n\n核心任务是为一个包含 $f$ 个可区分谐振子的集合计算微正则态总和 $N_{\\mathrm{HO}}(\\tilde{E})$。为了进行数值求解，该问题被离散化。给定一个包含 $m$ 个不同振动频率 $\\{\\nu_i\\}_{i=1}^{m}$（以 $\\mathrm{cm}^{-1}$ 为单位）的集合，以及相应的简并度 $\\{g_i\\}_{i=1}^{m}$。总振子数为 $f = \\sum_{i=1}^{m} g_i$。\n\n首先，我们建立能量参考。总能量以 $\\tilde{E}$（以 $\\mathrm{cm}^{-1}$ 为单位）给出。系统的零点能 (ZPE) 由下式给出：\n$$\n\\tilde{E}_0 = \\frac{1}{2} \\sum_{i=1}^{m} g_i \\nu_i\n$$\n可用于振动激发的能量 $\\tilde{E}_{\\mathrm{exc}}$ 是总能量减去零点能：\n$$\n\\tilde{E}_{\\mathrm{exc}} = \\tilde{E} - \\tilde{E}_0\n$$\n如果 $\\tilde{E}_{\\mathrm{exc}}  0$，则不可能发生激发，态总和 $N_{\\mathrm{HO}}(\\tilde{E})$ 显然为 $0$。\n\n然后使用能量箱宽度 $\\Delta\\varepsilon$ 对问题进行离散化。每个频率 $\\nu_i$ 映射到一个整数权重 $w_i$：\n$$\nw_i = \\mathrm{round}\\left(\\frac{\\nu_i}{\\Delta\\varepsilon}\\right)\n$$\n可用的总激发能被映射为整数个能量箱，即 $S$：\n$$\nS = \\left\\lfloor \\frac{\\tilde{E}_{\\mathrm{exc}}}{\\Delta\\varepsilon} \\right\\rfloor\n$$\n问题因此转化为一个组合任务：求解线性丢番图不等式的非负整数解 $\\{n_{k}\\}_{k=1}^{f}$ 的数量：\n$$\n\\sum_{k=1}^{f} W_k n_k \\le S\n$$\n其中 $\\{W_k\\}_{k=1}^{f}$ 是整数权重的扩展列表，包含了所有 $f$ 个可区分的振子。对于每对 $(\\nu_i, g_i)$，权重 $w_i$ 在此列表中重复 $g_i$ 次。\n\n这个计数问题可以使用动态规划方法高效解决，通常称为 Beyer-Swinehart直接计数算法。该算法迭代计算态密度 $\\rho(j)$，即系统总激发能恰好为 $j$ 个能量箱的方式数。\n\n该算法按以下步骤进行：\n\n1.  初始化一个大小为 $S+1$ 的一维数组 `density`，用于存储 $j \\in \\{0, 1, \\dots, S\\}$ 的态密度 $\\rho(j)$。对于一个零振子系统，只有一个态：能量为零的基态。因此，我们初始化 $\\rho(0) = 1$ 且对于所有 $j > 0$，$\\rho(j) = 0$。\n\n2.  迭代地将 $f$ 个振子逐个添加到系统中。当添加一个权重为 $W$ 的振子时，更新态密度数组。一个总能量为 $j$ 的组合系统状态，可以通过取前一个系统能量为 $j'$ 的状态，并为新振子添加 $n$ 个量子来形成，使得 $j = j' + nW$。新的态密度 $\\rho_{\\text{new}}(j)$ 是旧系统态密度 $\\rho_{\\text{old}}(j')$ 在新振子所有可能贡献上的总和。这导出了递推关系：\n    $$\n    \\rho_{\\text{new}}(j) = \\sum_{n=0}^{\\lfloor j/W \\rfloor} \\rho_{\\text{old}}(j-nW)\n    $$\n    这可以通过关系式 $\\rho_{\\text{new}}(j) = \\rho_{\\text{old}}(j) + \\rho_{\\text{new}}(j-W)$ 更高效地计算。这允许对 `density` 数组进行原位更新：对于给定的权重 $W$，我们从 $W$ 到 $S$ 迭代 $j$，并更新 $\\rho(j)$ 为 $\\rho(j) \\leftarrow \\rho(j) + \\rho(j-W)$。\n\n3.  在遍历所有 $f$ 个振子后，`density` 数组包含了整个系统在从 $0$到 $S$ 每个能级上的最终态密度。\n\n4.  问题要求的是态总和 $N_{\\mathrm{HO}}(\\tilde{E})$，即能量*小于或等于*离散化能量 $S$ 的总态数。这是态密度数组的累积和：\n    $$\n    N_{\\mathrm{HO}}(\\tilde{E}) = \\sum_{j=0}^{S} \\rho(j)\n    $$\n\n对每个测试用例实施此过程以计算最终结果。所有涉及态密度的计算都使用任意精度整数以防止溢出，这是 Python `int` 类型的标准特性。", "answer": "```python\nimport numpy as np\n\ndef calculate_sum_of_states(freqs, degs, E_total, d_eps):\n    \"\"\"\n    Calculates the harmonic oscillator sum of states using a discrete direct-count algorithm.\n\n    Args:\n        freqs (list[float]): List of distinct vibrational frequencies in cm^-1.\n        degs (list[int]): List of degeneracies for each frequency.\n        E_total (float): Total vibrational energy in cm^-1.\n        d_eps (float): Energy bin width in cm^-1.\n\n    Returns:\n        int: The computed discrete sum of states N_HO(E).\n    \"\"\"\n    # Step 1: Calculate Zero-Point Energy (ZPE)\n    E_zpe = 0.5 * sum(g * v for v, g in zip(freqs, degs))\n\n    # Step 2: Calculate excitation energy\n    E_exc = E_total - E_zpe\n    \n    # If excitation energy is negative, no states are accessible above ZPE\n    if E_exc  0:\n        return 0\n\n    # Step 3: Discretize energies\n    S = int(np.floor(E_exc / d_eps))\n\n    # Create the expanded list of integer weights for all f oscillators\n    all_weights = []\n    for v, g in zip(freqs, degs):\n        w = int(round(v / d_eps))\n        # The problem statement implies w >= 1, which holds for test cases.\n        if w > 0:\n            all_weights.extend([w] * g)\n\n    # Step 4: Direct count using Beyer-Swinehart algorithm\n    # Initialize density of states array. Python integers have arbitrary precision.\n    density = [0] * (S + 1)\n    density[0] = 1 # There is one state at zero energy (ground state)\n\n    # Iteratively add each oscillator\n    for w in all_weights:\n        for j in range(w, S + 1):\n            density[j] += density[j - w]\n            \n    # Step 5: The sum of states N(E) is the cumulative sum of the density of states rho(j)\n    total_sum_of_states = sum(density)\n    \n    return total_sum_of_states\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'freqs': [1000, 1100, 1200], 'degs': [1, 1, 1], 'E_total': 3300, 'd_eps': 50},\n        # Case 2\n        {'freqs': [500, 800], 'degs': [2, 1], 'E_total': 2000, 'd_eps': 50},\n        # Case 3\n        {'freqs': [400, 600, 700], 'degs': [1, 1, 1], 'E_total': 849, 'd_eps': 1},\n        # Case 4\n        {'freqs': [300], 'degs': [4], 'E_total': 1200, 'd_eps': 100},\n        # Case 5\n        {'freqs': [200, 250, 400, 500], 'degs': [1, 2, 1, 1], 'E_total': 1800, 'd_eps': 50},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_sum_of_states(\n            case['freqs'],\n            case['degs'],\n            case['E_total'],\n            case['d_eps']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2672869"}, {"introduction": "虽然量子直接计数法精确，但在高能或高维体系下，半经典近似提供了一种高效且富有洞察力的替代方案。本练习将引导你从经典相空间体积的定义出发，推导过渡态的态和$N^\\ddagger(E)$的经典谐振子近似表达式。通过这个过程[@problem_id:2672895]，你不仅能理解量子统计与经典统计力学之间的联系，还将学会如何处理反应路径简并度$g^\\ddagger$对速率常数的影响。", "problem": "给定反应物和过渡态的一组谐振频率（不包括过渡态的单一虚模），以及过渡态区域的可用微正则能量。您的任务是，在经典谐振子近似下，构建过渡态的微正则态总和，记为 $N^\\ddagger(E)$。您必须仅基于基本定义来推导和构建算法：态总和的微正则定义（经典相空间体积除以基本量子相空间单元）、独立谐振模式的可分离性以及频率单位之间的关系。在没有从这些基本原理进行论证的情况下，不得假设或使用任何预先推导的简化表达式。\n\n假设和数据约定：\n- 所有振动模式都是一维谐振子且可分离。\n- 过渡态振动频率不包括沿反应坐标的单一不稳定（虚）模式；仅提供实模式。\n- 能量是相对于过渡态区域的经典阈值测量的，忽略零点能偏移；也就是说，可用能量 $E$ 是非负的，且在经典鞍点之上测量。\n- 频率输入以波数形式提供，单位为反厘米（$\\mathrm{cm^{-1}}$）。相应的以赫兹为单位的线性频率关系为 $ \\nu = c \\, \\tilde{\\nu} $，其中 $ \\nu $ 的单位是 $ \\mathrm{s^{-1}} $，$ c $ 是光速，单位是 $ \\mathrm{cm \\ s^{-1}} $，而 $ \\tilde{\\nu} $ 是波数，单位是 $ \\mathrm{cm^{-1}} $。\n- 微正则可用能量 $E$ 以 $ \\mathrm{kJ \\ mol^{-1}} $ 提供；您必须使用阿伏伽德罗常数将其转换为每分子的焦耳数。\n\n需使用的常量（指定为国际单位制）：\n- 普朗克常数：$ h = 6.62607015 \\times 10^{-34} \\ \\mathrm{J \\ s} $。\n- 光速：$ c = 2.99792458 \\times 10^{10} \\ \\mathrm{cm \\ s^{-1}} $。\n- 阿伏伽德罗常数：$ N_\\mathrm{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}} $。\n\n您必须使用的定义基础：\n- 微正则态总和是总能量小于或等于 $E$ 的所有独立量子态的总数，其计算方法是取能量面所包围的经典相空间体积，然后除以 $s$ 个可分离一维模式的基本量子单元体积 $ h^s $。您必须从此定义出发，利用谐振模式的可分离性和相空间中能量受限区域的几何形状，得到以过渡态振动频率和可用能量 $E$ 表示的 $ N^\\ddagger(E) $ 的工作表达式。\n\n任务：\n1) 仅使用上述基本定义，为一组具有线性频率 $ \\{ \\nu_i^\\ddagger \\}_{i=1}^{s^\\ddagger} $ 的 $ s^\\ddagger $ 个过渡态谐振模式，推导出一个可实现的 $ N^\\ddagger(E) $ 表达式，给定可用能量 $E$（单位为每分子焦耳）和基本常数 $ h $ 和 $ c $。您的推导必须是通用的，独立于任何特定的测试用例值。\n2) 给定反应路径简并度 $ g^\\ddagger $（一个等于不可区分反应路径数量的正整数），确定它如何修正 Rice–Ramsperger–Kassel–Marcus (RRKM) 微正则速率表达式的分子。具体来说，计算 $ g^\\ddagger \\, N^\\ddagger(E) $ 并解释 $ g^\\ddagger $ 是否会影响除分子乘法缩放之外的任何其他因素。\n3) 实现一个程序，对于每个测试用例，使用以下数据计算 $ N^\\ddagger(E) $ 和 $ g^\\ddagger \\, N^\\ddagger(E) $（作为无量纲浮点数）：\n   - 过渡态波数 $ \\tilde{\\nu}_i^\\ddagger $，单位为 $ \\mathrm{cm^{-1}} $。\n   - 可用能量 $ E $，单位为 $ \\mathrm{kJ \\ mol^{-1}} $，需转换为每分子的 $ \\mathrm{J} $。\n   - 反应路径简并度 $ g^\\ddagger $，一个正整数。\n   每个测试用例中也提供了反应物频率，以反映典型的RRKM背景，但在此任务中您只构建分子；不要在任何计算中使用反应物频率。\n4) 将输出表示为具有六位有效数字的实数。\n\n测试套件：\n为以下四个测试用例提供结果。在每个案例中，使用给定的反应物和过渡态波数（单位为 $ \\mathrm{cm^{-1}} $），可用能量（单位为 $ \\mathrm{kJ \\ mol^{-1}} $）和简并度 $ g^\\ddagger $（无量纲）：\n- 测试用例 1：\n  - 反应物：$ [300, 500, 700, 1000, 1200, 1400] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [400, 800, 1200, 1500] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 25.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 1 $。\n- 测试用例 2：\n  - 反应物：$ [250, 400, 600, 900, 1100] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [500, 900, 1100] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 50.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 2 $。\n- 测试用例 3：\n  - 反应物：$ [200, 350, 800] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [300, 450] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 0.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 5 $。\n- 测试用例 4：\n  - 反应物：$ [500, 750, 1000] \\ \\mathrm{cm^{-1}} $。\n  - 过渡态：$ [1000] \\ \\mathrm{cm^{-1}} $。\n  - 可用能量：$ 10.0 \\ \\mathrm{kJ \\ mol^{-1}} $。\n  - 简并度：$ g^\\ddagger = 3 $。\n\n数值和单位要求：\n- 使用 $ E_\\mathrm{molecule} = \\frac{E_\\mathrm{kJ/mol} \\times 10^3}{N_\\mathrm{A}} $ 将 $ E $ 从 $ \\mathrm{kJ \\ mol^{-1}} $ 转换为每分子的焦耳。\n- 通过 $ \\nu_i^\\ddagger = c \\, \\tilde{\\nu}_i^\\ddagger $ 将波数 $ \\tilde{\\nu}_i^\\ddagger $ 转换为线性频率，其中 $ c $ 的单位为 $ \\mathrm{cm \\ s^{-1}} $。\n- 输出是无量纲的态计数，必须报告为四舍五入到六位有效数字的浮点数。\n- 本问题不涉及角度。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的 Python 风格的列表的列表，每个内部列表包含对应测试用例的两个浮点数 $ [N^\\ddagger(E), \\ g^\\ddagger N^\\ddagger(E)] $，顺序与上面列出的一致。例如：$ [[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]] $。", "solution": "该问题要求基于统计力学的基本原理，推导并计算过渡态的经典谐振子态总和 $N^\\ddagger(E)$。对问题陈述的验证证实了其科学上的合理性、问题的良定性，并包含了获得唯一解所需的所有必要信息。我们现在将进行正式的推导和计算。\n\n分析分为两部分。首先，给出了 $N^\\ddagger(E)$ 表达式的严格推导。其次，解释了反应路径简并度 $g^\\ddagger$ 的作用。最后，将这些原理应用于所提供的测试用例。\n\n**1. 态总和 $N^\\ddagger(E)$ 的推导**\n\n该问题要求推导从态总和 $N(E)$ 的基本半经典定义开始，即系统能量小于或等于 $E$ 时可用的量子态数量。这通过可及经典相空间的体积 $\\mathcal{V}(E)$ 除以单个量子态的体积 $h^s$ 来近似，其中 $s$ 是自由度的数量。对于具有 $s^\\ddagger$ 个振动模式的过渡态，这表示为：\n$$\nN^\\ddagger(E) = \\frac{\\mathcal{V}(E)}{h^{s^\\ddagger}}\n$$\n此处，$\\mathcal{V}(E)$ 是在总能量不超过 $E$ 的约束下，对所有坐标 $q_i$ 和共轭动量 $p_i$ 进行积分所定义的相空间体积：\n$$\n\\mathcal{V}(E) = \\int_{H(q,p) \\le E} \\prod_{i=1}^{s^\\ddagger} dq_i dp_i\n$$\n该系统由 $s^\\ddagger$ 个可分离的一维谐振子组成。总经典哈密顿量 $H(q,p)$ 是各个振子能量的总和：\n$$\nH(q,p) = \\sum_{i=1}^{s^\\ddagger} E_i(q_i, p_i) = \\sum_{i=1}^{s^\\ddagger} \\left( \\frac{p_i^2}{2m_i} + \\frac{1}{2} k_i q_i^2 \\right)\n$$\n其中 $m_i$ 和 $k_i$ 分别是模式 $i$ 的有效质量和力常数。单个振子的能量可以用其振动频率 $\\nu_i = \\frac{1}{2\\pi}\\sqrt{k_i/m_i}$ 来表示。能量为 $E_i$ 的单个振子的相空间轨迹是一个椭圆。该椭圆所包围的面积，代表能量*最高达到* $E_i$ 的单个振子的相空间体积，由 $A_i(E_i) = E_i / \\nu_i$ 给出。\n\n为了评估 $\\mathcal{V}(E)$ 的 $2s^\\ddagger$ 维积分，我们将每个模式 $i$ 的坐标从 $(q_i, p_i)$ 转换为能量-角度坐标 $(E_i, \\phi_i)$。一种这样的变换是 $q_i = \\sqrt{2E_i / k_i} \\sin\\phi_i$ 和 $p_i = \\sqrt{2m_i E_i} \\cos\\phi_i$。微分相空间面积元 $dq_i dp_i$ 变换为 $dq_i dp_i = |J| dE_i d\\phi_i$，其中 $J$ 是变换的雅可比行列式。雅可比行列式的计算结果为 $|J| = 1/(2\\pi\\nu_i)$。对角度 $\\phi_i$ 从 $0$ 到 $2\\pi$ 积分得到：\n$$\n\\int_0^{2\\pi} |J| d\\phi_i = \\int_0^{2\\pi} \\frac{1}{2\\pi\\nu_i} d\\phi_i = \\frac{1}{\\nu_i}\n$$\n因此，第 $i$ 个模式的体积元，对其循环坐标积分后，变为 $dE_i / \\nu_i$。总相空间体积积分现在是关于模式能量的积分：\n$$\n\\mathcal{V}(E) = \\int \\dots \\int_{\\sum E_i \\le E, E_i \\ge 0} \\prod_{i=1}^{s^\\ddagger} \\left( \\frac{dE_i}{\\nu_i^\\ddagger} \\right)\n$$\n将常数因子提出：\n$$\n\\mathcal{V}(E) = \\left( \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger} \\right) \\int_{0 \\le E_1, \\dots, E_{s^\\ddagger}; \\sum E_i \\le E} dE_1 \\dots dE_{s^\\ddagger}\n$$\n剩下的积分代表了一个标准的 $s^\\ddagger$ 维单形（一个 $s^\\ddagger$ 维超棱锥）的体积，其顶点位于原点和每个能量轴上的 $(E, 0, \\dots)$、$(0, E, \\dots)$ 等点。这样一个几何图形的体积是一个标准结果，由 $E^{s^\\ddagger} / s^\\ddagger!$ 给出。\n\n将此结果代回，总经典相空间体积为：\n$$\n\\mathcal{V}(E) = \\frac{E^{s^\\ddagger}}{s^\\ddagger!} \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger}\n$$\n最后，将这个 $\\mathcal{V}(E)$ 的表达式代入态总和的定义中，我们得到了过渡态的经典谐振子态总和所需的公式：\n$$\nN^\\ddagger(E) = \\frac{\\mathcal{V}(E)}{h^{s^\\ddagger}} = \\frac{1}{h^{s^\\ddagger}} \\frac{E^{s^\\ddagger}}{s^\\ddagger!} \\prod_{i=1}^{s^\\ddagger} \\frac{1}{\\nu_i^\\ddagger} = \\frac{E^{s^\\ddagger}}{s^\\ddagger! \\prod_{i=1}^{s^\\ddagger} h\\nu_i^\\ddagger}\n$$\n此表达式对 $E \\ge 0$ 有效。如果 $E=0$ 且 $s^\\ddagger > 0$，态总和 $N^\\ddagger(0)$ 为 $0$，因为连续相空间中的单个点体积为零。如果 $s^\\ddagger=0$，则空积为 $1$，$0!=1$，且 $E^0=1$，得到 $N^\\ddagger(E)=1$，这正确地表示了一个没有内部自由度的单一状态。\n\n**2. 反应路径简并度 $g^\\ddagger$ 的作用**\n\nRRKM 理论中的微正则速率常数 $k(E)$ 量化了从反应物态通过过渡态到产物态的速率。速率常数的完整表达式为：\n$$\nk(E) = g^\\ddagger \\frac{N^\\ddagger(E)}{h \\rho(E)}\n$$\n其中 $\\rho(E)$ 是反应物分子的态密度。因子 $g^\\ddagger$，即反应路径简并度，是一个正整数，用于对对称性进行校正。它代表了反应可以进行的、不同的但物理上不可区分的方式的数量。例如，一个自由基从甲烷（$\\mathrm{CH_4}$）中夺取一个氢原子，可以在四个等效的氢原子中的任何一个上发生，因此 $g^\\ddagger=4$。\n\n$g^\\ddagger$ 的作用是核算总通量。$N^\\ddagger(E)$ 是*单个*过渡态结构的态总和。如果存在多个这样的等效结构，则总通量是每个通道通量之和。由于所有通道都不可区分，这等同于将通过一个通道的通量乘以通道数 $g^\\ddagger$。因此，$g^\\ddagger$ 充当 RRKM 表达式分子的一个简单乘法缩放因子。它不改变 $N^\\ddagger(E)$ 本身的计算。需要计算的量是 $g^\\ddagger N^\\ddagger(E)$，它代表了所有等效反应路径上的总态总和。\n\n**3. 实现和计算**\n\n将使用推导出的公式来解决这些测试用例。所需步骤如下：\n- 使用提供的常数：普朗克常数 $h = 6.62607015 \\times 10^{-34} \\ \\mathrm{J \\ s}$，光速 $c = 2.99792458 \\times 10^{10} \\ \\mathrm{cm \\ s^{-1}}$，以及阿伏伽德罗常数 $N_\\mathrm{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$。\n- 通过 $E_\\mathrm{J} = (E_{\\mathrm{kJ/mol}} \\times 1000) / N_\\mathrm{A}$ 将可用能量 $E$ 从 $\\mathrm{kJ \\ mol^{-1}}$ 转换为每分子的焦耳。\n- 通过 $\\nu_i^\\ddagger = c \\tilde{\\nu}_i^\\ddagger$ 将过渡态波数 $\\tilde{\\nu}_i^\\ddagger$（单位 $\\mathrm{cm^{-1}}$）转换为线性频率 $\\nu_i^\\ddagger$（单位 $\\mathrm{s^{-1}}$）。\n- 应用推导的 $N^\\ddagger(E)$ 公式，并按要求乘以 $g^\\ddagger$。最终结果以六位有效数字呈现。根据问题范围，本计算不使用反应物频率。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Calculates the classical harmonic sum of states for the transition state N‡(E)\n    and the product with the reaction path degeneracy g‡N‡(E).\n    \"\"\"\n\n    # Fundamental Constants (SI units, except for c)\n    H_PLANCK = 6.62607015e-34  # J s\n    C_LIGHT = 2.99792458e10   # cm s^-1\n    N_AVOGADRO = 6.02214076e23 # mol^-1\n\n    # Test cases as provided in the problem statement.\n    # Format: (reactant_wavenumbers, ts_wavenumbers, energy_kj_mol, degeneracy)\n    # Reactant wavenumbers are included for context but not used in the calculation.\n    test_cases = [\n        ([300, 500, 700, 1000, 1200, 1400], [400, 800, 1200, 1500], 25.0, 1),\n        ([250, 400, 600, 900, 1100], [500, 900, 1100], 50.0, 2),\n        ([200, 350, 800], [300, 450], 0.0, 5),\n        ([500, 750, 1000], [1000], 10.0, 3),\n    ]\n\n    results = []\n\n    for _, ts_wavenumbers, E_kj_mol, g_ddagger in test_cases:\n        \n        # 1. Determine the number of transition state vibrational modes\n        s_ddagger = len(ts_wavenumbers)\n        \n        # 2. Convert energy from kJ/mol to J/molecule\n        E_joules = (E_kj_mol * 1000) / N_AVOGADRO\n        \n        # 3. Calculate N_ddagger(E) using the derived formula:\n        # N_ddagger(E) = E^s / (s! * product(h*nu_i))\n        \n        if s_ddagger > 0 and E_joules == 0.0:\n            # For E=0 and s>0, the classical phase space volume is zero.\n            N_ddagger = 0.0\n        elif s_ddagger == 0:\n            # Case with no vibrational modes: N(E) = 1 for E >= 0\n            N_ddagger = 1.0\n        else:\n            # Convert wavenumbers (cm^-1) to linear frequencies (s^-1)\n            # and compute the product of h*nu_i\n            # product(h*nu_i) = product(h*c*nu_tilde_i) = (h*c)^s * product(nu_tilde_i)\n            \n            # Using numpy for product calculation for conciseness\n            product_of_wavenumbers = np.prod(ts_wavenumbers)\n            \n            # h*c in J*cm\n            hc_const = H_PLANCK * C_LIGHT \n            \n            product_h_nu = (hc_const ** s_ddagger) * product_of_wavenumbers\n            \n            s_factorial = math.factorial(s_ddagger)\n            \n            numerator = E_joules ** s_ddagger\n            denominator = s_factorial * product_h_nu\n            \n            if denominator == 0:\n                # Should not happen with valid physical inputs\n                N_ddagger = float('inf') if numerator > 0 else 0.0\n            else:\n                N_ddagger = numerator / denominator\n\n        # 4. Calculate g_ddagger * N_ddagger(E)\n        g_N_ddagger = g_ddagger * N_ddagger\n        \n        results.append([N_ddagger, g_N_ddagger])\n\n    # Format the final output string according to the problem specification.\n    # Each value is formatted to 6 significant figures.\n    output_parts = []\n    for pair in results:\n        # Using .6g for 6 significant figures\n        formatted_pair = f\"[{pair[0]:.6g},{pair[1]:.6g}]\"\n        output_parts.append(formatted_pair)\n        \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2672895"}, {"introduction": "理论模型的计算实现需要关注数值方法的稳定性和收敛性，这在科学计算中至关重要。此项高级实践将带你整合之前所学的知识，构建一个完整的RRKM微正则速率常数$k(E)$的计算程序。更重要的是，你将系统地分析能量网格的离散化粒度如何影响计算结果的准确性[@problem_id:2672898]，并学习如何建立一个合理的收敛标准，从而培养对计算结果进行批判性评估的关键技能。", "problem": "你需要编写一个完整、可运行的程序，评估能量的离散化粒度（记作 $\\Delta E$）如何影响微正则振动状态密度 $\\rho(E)$ 和过渡态状态和 $N^\\ddagger(E)$ 的数值估计，然后使用此分析来检验 Rice–Ramsperger–Kassel–Marcus (RRKM) 微正则速率常数 $k(E)$ 的收敛性。你的实现必须基于下述的可分离量子谐振子第一性原理，并且不得依赖任何 $\\rho(E)$ 或 $N^\\ddagger(E)$ 的闭式表达式。\n\n模型和所需计算的基本原理：\n- 考虑一个非线性分子，反应物中有 $s$ 个独立的量子谐振动模式，过渡态中有 $s^\\ddagger=s-1$ 个此类模式（在过渡态不包括反应坐标）。\n- 反应物的振动频率以逆厘米（$\\mathrm{cm^{-1}}$）为单位给出，记为 $\\tilde{\\nu}_i$，其中 $i=1,\\dots,s$。过渡态的振动频率以逆厘米为单位给出，记为 $\\tilde{\\nu}^\\ddagger_j$，其中 $j=1,\\dots,s^\\ddagger$。\n- 每个模式的振动能级是量子谐振子的能级；在本任务中，忽略零点能位移，并将可及能量视为 $h c \\tilde{\\nu}$ 的非负整数倍，其中 $h$ 是 Planck 常数，$c$ 是光速。\n- 微正则振动状态密度 $\\rho(E)$ 是总能量为 $E$ 时单位能量内的状态数，你必须通过将能量离散化为宽度为 $\\Delta E$（单位为 $\\mathrm{cm^{-1}}$）的区间（bin），统计落入每个区间内的构型数量，并用以焦耳为单位的区间宽度进行归一化，来对其进行数值近似。\n- 过渡态状态和 $N^\\ddagger(E)$ 是能量小于或等于 $E$ 的过渡态振动状态总数，通过对各区间的过渡态构型计数进行累加求和得到。\n- 微正则速率常数 $k(E)$ 将在 RRKM 框架内，根据这些状态计数以量纲一致的方式计算，使用 Planck 常数 $h$ 来设定时间尺度。仅可使用数值方法得到的 $\\rho(E)$ 和 $N^\\ddagger(\\cdot)$ 来计算 $k(E)$，并确保最终单位为 $\\mathrm{s^{-1}}$。\n- 完全按照指定值使用以下物理常数：$h = 6.62607015\\times 10^{-34}\\,\\mathrm{J\\,s}$，$c = 2.99792458\\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$。将 $1\\,\\mathrm{cm^{-1}}$ 视为 $100\\,\\mathrm{m^{-1}}$。所有从 $\\mathrm{cm^{-1}}$ 到焦耳的内部转换必须使用 $E\\,[\\mathrm{J}] = h\\,c\\,\\tilde{\\nu}\\,[\\mathrm{m^{-1}}]$。\n\n离散数值模型要求：\n- 通过对各模式进行离散卷积，实现可分离振动的状态计数。\n- 设能量网格为 $E_k = k\\,\\Delta E$（单位为 $\\mathrm{cm^{-1}}$），其中 $k=0,1,\\dots,K$，$K$ 的选择需足够大以覆盖最大相关能量。\n- 对于每个频率为 $\\tilde{\\nu}$ 的模式，其允许的模式能量（忽略零点贡献）为 $n\\,\\tilde{\\nu}$，其中 $n\\ge 0$ 为整数。将每个允许的 $n\\,\\tilde{\\nu}$ 映射到最近的能量区间索引 $k=\\mathrm{round}\\!\\left(\\dfrac{n\\,\\tilde{\\nu}}{\\Delta E}\\right)$，并增加该区间的棒状谱（stick spectrum）值。对所有模式的棒状谱进行卷积，以获得反应物状态的区间计数 $g(E_k)$ 和过渡态状态的区间计数 $g^\\ddagger(E_k)$，直至所需的最大能量。\n- 在目标能量 $E$ 处，通过 $\\rho(E)\\approx g(E_k)/\\Delta E_{\\mathrm{J}}$ 来近似 $\\rho(E)$，其中 $\\Delta E_{\\mathrm{J}}=h\\,c\\,(100\\,\\Delta E)$ 是以焦耳为单位的区间宽度，并使用最近的区间索引 $k=\\mathrm{round}(E/\\Delta E)$。\n- 通过对 $g^\\ddagger(E_k)$ 的各区间进行累加求和来近似 $N^\\ddagger(E)$，同样对目标能量 $E$ 使用最近区间索引。\n- 引入一个经典势垒高度 $E_0$（单位为 $\\mathrm{cm^{-1}}$）。对于总能量为 $E$ 时的速率常数，使用可用的过渡态能量 $E-E_0$。对于 $E  E_0$，速率常数 $k(E)$ 应为零。", "solution": "所给问题要求对 Rice–Ramsperger–Kassel–Marcus (RRKM) 微正则速率常数 $k(E)$ 关于能量离散化网格尺寸 $\\Delta E$ 的收敛性进行数值研究。该问题是适定的，其科学基础根植于统计力学和化学动力学原理，并为获得唯一的、可验证的解提供了所有必要的参数。我们将着手求解。\n\n对于总能量为 $E$ 的分子，RRKM 速率常数的基本表达式为：\n$$\nk(E) = \\frac{N^\\ddagger(E - E_0)}{h \\rho(E)}\n$$\n在此， $h$ 是 Planck 常数，$E_0$ 是反应的经典势垒高度，$\\rho(E)$ 是反应物分子在能量 $E$ 时的振动状态密度，$N^\\ddagger(E - E_0)$ 是过渡态可及振动状态的总数（状态和），其可用能量为高于势垒的 $E - E_0$。\n\n我们的模型将反应物分子视为 $s$ 个可分离量子谐振子的集合，过渡态则为 $s^\\ddagger = s-1$ 个。频率为 $\\tilde{\\nu}$ 的单个谐振子的能量是量子化的，由 $\\epsilon_n = n h c \\tilde{\\nu}$ 给出，其中我们按要求忽略了零点能。分子的总振动能量是各个模式能量的总和：$E = \\sum_{i=1}^s n_i h c \\tilde{\\nu}_i$。\n\n问题的核心是数值计算 $\\rho(E)$ 和 $N^\\ddagger(E)$。禁止使用诸如 Beyer-Swinehart 算法或 Whitten-Rabinovitch 近似等公式进行直接解析计算。相反，我们必须使用基于离散卷积的直接计数法，这是一种针对可分离系统的数值第一性原理方法。\n\n步骤如下：\n\n1.  **能量网格离散化**：我们定义一个具有均匀间距 $\\Delta E$（单位为 $\\mathrm{cm^{-1}}$）的离散能量网格。网格点 $k$ 处的能量为 $E_k = k \\Delta E$。此网格的最大能量 $E_\\mathrm{max}$ 必须选择得足够大，以容纳所有必需的计算，包括最高的评估能量和卷积效应。\n\n2.  **通过卷积进行状态计数**：\n    *   对于频率为 $\\tilde{\\nu}_i$ 的每个独立振动模式 $i$，我们构建一个“棒状谱”（stick spectrum）。这是一个代表能量网格的数组，我们在每个对应于允许能级的区间索引处记下一个计数值 $1$。能量 $\\epsilon = n \\tilde{\\nu}_i$ 的区间索引 $k$ 由最近区间规则确定：$k = \\mathrm{round}(n \\tilde{\\nu}_i / \\Delta E)$。\n    *   反应物在每个能量区间 $k$ 中的总状态数 $g(E_k)$ 是总能量 $E_k$ 在 $s$ 个模式中分配的方式数量。对于可分离模式，这在数学上等价于各个模式棒状谱的离散卷积。我们从一个模式的谱开始，然后迭代地将其与其余模式的谱进行卷积。设 $g_i$ 为模式 $i$ 的棒状谱。总的“简并度”函数为 $g = g_1 * g_2 * \\dots * g_s$，其中 $*$ 表示卷积。结果必须截断至我们能量网格的大小。\n    *   将相同的过程应用于 $s^\\ddagger$ 个过渡态模式，以获得它们的简并度函数 $g^\\ddagger(E_k)$。\n\n3.  **计算 $\\rho(E)$ 和 $N^\\ddagger(E)$**：\n    *   状态密度 $\\rho(E)$ 是单位能量内的状态数。我们通过取其对应区间 $g(E_k)$（其中 $k=\\mathrm{round}(E/\\Delta E)$）的计数值，并除以以焦耳为单位的区间宽度 $\\Delta E_{\\mathrm{J}}$ 来近似能量为 $E$ 时的状态密度。转换关系为 $\\Delta E_{\\mathrm{J}} = h c (100 \\Delta E)$，其中 $\\Delta E$ 的单位是 $\\mathrm{cm^{-1}}$，因子 $100$ 用于将 $\\mathrm{cm^{-1}}$ 转换为 $\\mathrm{m^{-1}}$。\n    $$\n    \\rho(E) \\approx \\frac{g(\\mathrm{round}(E/\\Delta E))}{\\Delta E_{\\mathrm{J}}} = \\frac{g(\\mathrm{round}(E/\\Delta E))}{h c (100 \\Delta E)}\n    $$\n    *   状态和 $N^\\ddagger(E)$ 是能量小于或等于 $E$ 的状态总数。这可以通过对过渡态简并度 $g^\\ddagger$ 累加求和至对应于 $E$ 的区间来近似。\n    $$\n    N^\\ddagger(E) \\approx \\sum_{j=0}^{\\mathrm{round}(E/\\Delta E)} g^\\ddagger(j)\n    $$\n\n4.  **计算速率常数 $k(E)$**：我们将这些数值量代入 RRKM 表达式中。\n    $$\n    k(E) = \\frac{N^\\ddagger(E - E_0)}{h \\rho(E)} \\approx \\frac{\\left( \\sum_{j=0}^{\\mathrm{round}((E-E_0)/\\Delta E)} g^\\ddagger(j) \\right) \\cdot c \\cdot (100 \\Delta E)}{g(\\mathrm{round}(E/\\Delta E))}\n    $$\n    如果 $E  E_0$，则可用能量 $E-E_0$ 为负，意味着没有可及的过渡态，因此 $N^\\ddagger(E-E_0) = 0$ 且 $k(E)=0$。当 $g(\\mathrm{round}(E/\\Delta E))$ 为零时，速率常数形式上是无限的，尽管这在物理上是不现实的，并且对于多原子分子在感兴趣的能量范围内不太可能发生。\n\n5.  **收敛性分析**：最后一步是系统地评估一系列递减粒度 $\\Delta E = \\{200.0, 100.0, 50.0, 25.0, 12.5\\}\\,\\mathrm{cm^{-1}}$ 的速率常数。最细网格 $\\Delta E_\\mathrm{ref} = 12.5\\,\\mathrm{cm^{-1}}$ 的结果作为基准。对于每个较粗的 $\\Delta E$，我们在指定的测试能量 $E$ 范围内计算最大相对偏差 $\\varepsilon(\\Delta E)$。\n    $$\n    \\varepsilon(\\Delta E) = \\max_{E \\in \\text{test set}} \\frac{|k_{\\Delta E}(E) - k_{\\Delta E_\\mathrm{ref}}(E)|}{|k_{\\Delta E_\\mathrm{ref}}(E)|}\n    $$\n    对于 $k_{\\Delta E_\\mathrm{ref}}(E) = 0$ 的情况需要特殊处理。然后，我们将 $\\varepsilon(\\Delta E)$ 与给定的容差 $\\tau$ 对几组 $(\\Delta E, \\tau)$ 进行比较，以确定是否满足收敛判据。整个过程将在一个单一的程序中实现，以产生所需的布尔值输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RRKM convergence problem by numerically computing state densities\n    and sums of states, calculating rate constants, and testing convergence.\n    \"\"\"\n    # Physical Constants\n    H_PLANCK = 6.62607015e-34  # J*s\n    C_SPEED = 2.99792458e8  # m/s\n\n    # Model Parameters\n    NU_REACTANT_CM_INV = [300.0, 400.0, 500.0, 700.0, 900.0, 1100.0]  # cm^-1\n    NU_TS_CM_INV = [200.0, 350.0, 600.0, 800.0, 1000.0]  # cm^-1\n    E0_CM_INV = 1500.0  # cm^-1\n    \n    # Evaluation Parameters\n    EVAL_ENERGIES_CM_INV = [1400.0, 1500.0, 3000.0, 5000.0]\n    DELTA_E_CANDIDATES = [200.0, 100.0, 50.0, 25.0, 12.5]\n    DELTA_E_REF = 12.5\n    E_MAX_CM_INV = 6000.0  # Maximum energy for the grid\n\n    # Test Cases for convergence: (delta_e, tolerance)\n    test_cases = [\n        (200.0, 0.2),\n        (100.0, 0.1),\n        (50.0, 0.05),\n        (25.0, 0.05),\n        (25.0, 0.02),\n        (12.5, 0.02),\n    ]\n\n    def compute_state_counts(frequencies, delta_e, e_max):\n        \"\"\"\n        Computes the binned number of states g(E_k) via convolution.\n        \"\"\"\n        grid_size = int(np.ceil(e_max / delta_e)) + 1\n        \n        # Initialize total counts with the spectrum of the first mode\n        freq_iter = iter(frequencies)\n        try:\n            nu1 = next(freq_iter)\n        except StopIteration: # Handle empty frequency list\n            total_counts = np.zeros(grid_size)\n            total_counts[0] = 1.0\n            return total_counts\n\n        total_counts = np.zeros(grid_size)\n        n = 0\n        while True:\n            energy = n * nu1\n            if energy > e_max:\n                break\n            bin_index = int(np.round(energy / delta_e))\n            if bin_index  grid_size:\n                total_counts[bin_index] += 1\n            n += 1\n\n        # Convolve with remaining modes\n        for nu in freq_iter:\n            mode_counts = np.zeros(grid_size)\n            n = 0\n            while True:\n                energy = n * nu\n                if energy > e_max:\n                    break\n                bin_index = int(np.round(energy / delta_e))\n                if bin_index  grid_size:\n                    mode_counts[bin_index] += 1\n                n += 1\n            \n            total_counts = np.convolve(total_counts, mode_counts)[:grid_size]\n            \n        return total_counts\n\n    def compute_rate_constants(delta_e):\n        \"\"\"\n        Computes RRKM rate constant k(E) for all evaluation energies.\n        \"\"\"\n        g_reactant = compute_state_counts(NU_REACTANT_CM_INV, delta_e, E_MAX_CM_INV)\n        g_ts = compute_state_counts(NU_TS_CM_INV, delta_e, E_MAX_CM_INV)\n        n_ts_cumulative = np.cumsum(g_ts)\n        \n        rates = []\n        for e_cm_inv in EVAL_ENERGIES_CM_INV:\n            if e_cm_inv  E0_CM_INV:\n                rates.append(0.0)\n                continue\n\n            e_avail_cm_inv = e_cm_inv - E0_CM_INV\n\n            # Get reactant density of states term (proportional to g)\n            k_e_reactant = int(np.round(e_cm_inv / delta_e))\n            if k_e_reactant >= len(g_reactant) or g_reactant[k_e_reactant] == 0:\n                # Density of states is zero, rate is infinite (or undefined)\n                # Physically, for E > 0, density should be non-zero for polyatomics\n                rates.append(np.inf)\n                continue\n            \n            g_val = g_reactant[k_e_reactant]\n\n            # Get transition state sum of states\n            k_e_ts = int(np.round(e_avail_cm_inv / delta_e))\n            if k_e_ts  0:\n                 n_ts_val = 0.0\n            elif k_e_ts >= len(n_ts_cumulative):\n                 # Energy is beyond grid, use last available sum of states\n                 n_ts_val = n_ts_cumulative[-1]\n            else:\n                 n_ts_val = n_ts_cumulative[k_e_ts]\n\n            # Calculate rate constant\n            # k(E) = N_ts(E-E0) / (h * rho(E))\n            # rho(E) approx g(E) / (h*c*100*delta_E)\n            # k(E) approx (N_ts * c * 100 * delta_E) / g(E)\n            rate = (n_ts_val * C_SPEED * 100.0 * delta_e) / g_val\n            rates.append(rate)\n        \n        return np.array(rates)\n\n    # Calculate rate constants for all delta_e values\n    k_results = {}\n    for de in DELTA_E_CANDIDATES:\n        k_results[de] = compute_rate_constants(de)\n\n    # Perform convergence analysis\n    k_ref_rates = k_results[DELTA_E_REF]\n    final_booleans = []\n\n    for delta_e_test, tolerance in test_cases:\n        k_test_rates = k_results[delta_e_test]\n        \n        relative_errors = []\n        for k_test, k_ref in zip(k_test_rates, k_ref_rates):\n            if k_ref > 0:\n                rel_err = np.abs(k_test - k_ref) / k_ref\n            elif k_ref == 0 and k_test == 0:\n                rel_err = 0.0\n            else: # k_ref is 0 and k_test > 0\n                rel_err = np.inf\n            relative_errors.append(rel_err)\n        \n        max_rel_err = np.max(relative_errors)\n        is_converged = max_rel_err = tolerance\n        final_booleans.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_booleans))}]\")\n\nsolve()\n```", "id": "2672898"}]}