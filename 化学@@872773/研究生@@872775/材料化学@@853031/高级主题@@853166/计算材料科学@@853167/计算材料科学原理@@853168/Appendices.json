{"hands_on_practices": [{"introduction": "任何精确的模拟都始于坚实的基础。此实践将引导你完成平面波截断能收敛性测试这一基本过程，该参数直接控制着我们计算的精度。通过实施一个系统的协议 ([@problem_id:2475310])，你将学会如何确保所选的基组对于目标精度是充分的，这是获得可靠计算结果不可或缺的一步。", "problem": "要求您形式化、论证并实现一个收敛协议，用于在平面波赝势计算中选择平面波动能截断，目标精度指定为每个原子 $1$ meV。您的实现必须是一个完整的程序。\n\n设计出发点。使用以下在计算材料科学中公认的基本原理和事实：\n- Rayleigh–Ritz 变分原理意味着，在截断基组中的基态总能量随着基组尺寸的增大而单调不增。在平面波基组中，这意味着总能量 $E$ 随着动能截断 $E_{\\text{cut}}$ 的增加而单调不增。\n- 对于保范赝势和超软赝势，每个原子的总能量中的主要截断误差随着平面波动能截断的增加，以幂律形式渐近衰减。与此相符的一个最小模型是\n$$\nE(E_{\\text{cut}}) \\;=\\; E_\\infty \\;+\\; A \\, E_{\\text{cut}}^{-p},\n$$\n其中 $E_\\infty$ 是收敛的每个原子的总能量，$A0$ 表征了赝势的硬度，而 $p0$ 是一个由赝波函数和赝势投影算符的光滑度决定的收敛指数。\n\n要实现的协议。使用上述原理，实现以下收敛协议：\n- 构建一个均匀的截断能网格\n$$\nE_{\\text{cut},k} \\;=\\; E_{\\text{cut},0} \\;+\\; k\\,\\Delta, \\quad k=0,1,\\dots,N,\n$$\n给定起始值 $E_{\\text{cut},0}$、增量 $\\Delta$ 和步数 $N$（因此有 $N\\!+\\!1$ 个网格点）。\n- 对于每个 $k$，使用上述模型计算每个原子的总能量 $E_k = E(E_{\\text{cut},k})$。\n- 定义连续变化的绝对值\n$$\n\\delta_k \\;=\\; \\lvert E_k - E_{k-1} \\rvert,\\quad k=1,2,\\dots,N.\n$$\n- 当且仅当以 $k^\\star$ 结尾的最后 $w$ 个连续变化满足以下条件时，在索引 $k^\\star$ 处宣布收敛：\n$$\n\\delta_j \\le \\tau \\quad \\text{对于所有 } j = k^\\star-w+1,\\dots,k^\\star,\n$$\n其中窗口长度 $w=3$，容差 $\\tau = 0.001$ eV/原子（即 $1$ meV/原子）。\n- 选择满足该标准的最小 $k^\\star$，并报告相应的截断能 $E_{\\text{cut},k^\\star}$。如果在 $k=N$ 之前不存在这样的 $k^\\star$，则报告 -1。\n\n单位和数值要求。\n- 报告所有选定的截断能，单位为 $\\mathrm{eV}$，四舍五入到最接近的整数 $\\mathrm{eV}$。容差 $\\tau$ 为 $0.001$ $\\mathrm{eV}$/原子。\n- 本问题不涉及角度。不使用百分比。\n\n测试套件。您的程序必须评估以下五个测试用例。每个测试用例指定 $(E_\\infty, A, p, E_{\\text{cut},0}, \\Delta, N)$:\n1. $( -10.0, \\; 100.0, \\; 2.0, \\; 200.0, \\; 50.0, \\; 13 )$\n2. $( -5.0, \\; 1000.0, \\; 1.8, \\; 200.0, \\; 50.0, \\; 13 )$\n3. $( -8.0, \\; 5000.0, \\; 1.2, \\; 200.0, \\; 50.0, \\; 13 )$\n4. $( -12.0, \\; 50.0, \\; 2.2, \\; 250.0, \\; 25.0, \\; 20 )$\n5. $( -7.0, \\; 15000.0, \\; 3.0, \\; 200.0, \\; 100.0, \\; 7 )$\n\n$N$ 的解释：有 $N\\!+\\!1$ 个网格点 $k=0,1,\\dots,N$，因此有 $N$ 个连续差值 $\\delta_k$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素是选定的截断能 $E_{\\text{cut},k^\\star}$（单位为 $\\mathrm{eV}$，四舍五入到最接近的整数），如果未在网格内满足标准，则为 -1，其顺序与测试套件的顺序相同。例如，输出应如下所示\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。", "solution": "问题陈述经过严格验证，被认为是科学上合理、定义明确且完整的。它描述了一个确定计算相对于基组参数收敛性的标准数值程序，这是计算材料科学中的一项常见任务。因此，该问题是有效的，并将构建一个解决方案。\n\n该协议建立在使用平面波基组进行量子力学计算的两个核心原理之上。首先，Rayleigh-Ritz 变分原理指出，计算出的基态总能量 $E$ 是真实基态能量的一个上界，并且是基组尺寸的单调不增函数。在平面波基组中，基组尺寸由动能截断 $E_{\\text{cut}}$ 控制。因此，$E(E_{\\text{cut}})$ 必须是单调不增的。\n\n其次，对于此类计算中使用的典型赝势，每个原子的总能量中的截断误差随着截断能的增加呈现出幂律衰减。问题为这种渐近行为提供了一个最小但标准的模型：\n$$\nE(E_{\\text{cut}}) \\;=\\; E_\\infty \\;+\\; A \\, E_{\\text{cut}}^{-p}\n$$\n这里，$E_\\infty$ 代表在无限基组中无法达到的、完全收敛的每个原子的总能量。参数 $A  0$ 取决于赝势的“硬度”（较大的 $A$ 意味着较慢的收敛），而指数 $p  0$ 与赝波函数和赝势投影算符的光滑度有关。为了确认与变分原理的一致性，我们检查 $E$ 对 $E_{\\text{cut}}$ 的导数：\n$$\n\\frac{dE}{dE_{\\text{cut}}} \\;=\\; -p \\, A \\, E_{\\text{cut}}^{-(p+1)}\n$$\n鉴于 $p  0$、$A  0$ 和 $E_{\\text{cut}}  0$，可以得出 $dE/dE_{\\text{cut}}  0$。因此，函数 $E(E_{\\text{cut}})$ 是严格递减的，这与变分原理所要求的单调不增性质一致。\n\n指定的协议被实现为一个确定性算法。步骤如下：\n\n1.  **网格生成**：构建一个包含 $N+1$ 个截断能的均匀网格。对于从 $0$ 到 $N$ 的每个整数 $k$，截断能由下式给出：\n    $$\n    E_{\\text{cut},k} \\;=\\; E_{\\text{cut},0} \\;+\\; k\\,\\Delta\n    $$\n    每个测试用例都提供了参数 $E_{\\text{cut},0}$、$\\Delta$ 和 $N$。\n\n2.  **能量计算**：在网格的每个点上，使用提供的模型计算每个原子的总能量 $E_k$：\n    $$\n    E_k \\;=\\; E(E_{\\text{cut},k}) \\;=\\; E_\\infty \\;+\\; A \\, (E_{\\text{cut},k})^{-p}\n    $$\n\n3.  **连续差值的计算**：通过检查连续步骤之间能量变化的幅度来监控收敛。对于 $k=1, 2, \\dots, N$，我们定义连续差值 $\\delta_k$：\n    $$\n    \\delta_k \\;=\\; \\lvert E_k - E_{k-1} \\rvert\n    $$\n    由于 $E(E_{\\text{cut}})$ 是一个严格递减函数，$E_k  E_{k-1}$，所以绝对值是多余的：\n    $$\n    \\delta_k \\;=\\; E_{k-1} - E_k\n    $$\n\n4.  **收敛准则的应用**：如果在索引 $k^\\star$ 处，一个包含最近 $w$ 个能量差的“窗口”内的所有值都小于或等于指定的容差 $\\tau$，则宣布收敛。问题指定了窗口大小 $w=3$ 和容差 $\\tau = 0.001$ eV/原子。算法必须在 $\\{w, w+1, \\dots, N\\}$ 范围内找到满足此条件的*最小*索引 $k^\\star$。形式上，我们寻求最小的 $k^\\star$ 使得：\n    $$\n    \\delta_j \\le \\tau \\quad \\text{对于所有 } j \\in \\{k^\\star-w+1,\\dots,k^\\star\\}\n    $$\n    对 $k^\\star$ 的搜索必须从第一个可能的索引 $k^\\star=w=3$ 开始，因为大小为 3 的窗口需要至少有 3 个差值（$\\delta_1, \\delta_2, \\delta_3$）可用。\n\n5.  **输出确定**：如果找到了一个合格的 $k^\\star$，则报告相应的收敛截断能 $E_{\\text{cut},k^\\star}$，并四舍五入到最接近的整数。如果在从 $w$ 到 $N$ 的所有可能 $k^\\star$ 的循环完成时仍未满足准则，这表明在指定的截断范围内未达到收敛。在这种情况下，报告值为 -1。\n\n因此，实现将包含一个遍历所有测试用例的外层循环。对于每个用例，它将为 $E_{\\text{cut},k}$、$E_k$ 和 $\\delta_k$ 生成必要的数组。随后的一个从 $k^\\star=w$ 到 $N$ 的循环将在每一步检查收敛窗口。第一个满足标准的 $k^\\star$ 值将终止搜索，并计算和存储相应的 $E_{\\text{cut},k^\\star}$。如果此内层循环完成但未成功，则存储 -1。最后，将收集到的结果格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the converged kinetic energy cutoff based on a given protocol\n    and a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E_inf, A, p, E_cut_0, Delta, N)\n    test_cases = [\n        (-10.0, 100.0, 2.0, 200.0, 50.0, 13),\n        (-5.0, 1000.0, 1.8, 200.0, 50.0, 13),\n        (-8.0, 5000.0, 1.2, 200.0, 50.0, 13),\n        (-12.0, 50.0, 2.2, 250.0, 25.0, 20),\n        (-7.0, 15000.0, 3.0, 200.0, 100.0, 7)\n    ]\n\n    # Convergence protocol parameters\n    w = 3         # Window length\n    tau = 0.001   # Tolerance in eV per atom\n\n    results = []\n    \n    for case in test_cases:\n        E_inf, A, p, E_cut_0, Delta, N = case\n\n        # 1. Construct a uniform grid of cutoffs\n        # The grid runs from k=0 to N, so there are N+1 points.\n        k_grid = np.arange(N + 1)\n        E_cut_k = E_cut_0 + k_grid * Delta\n\n        # 2. Compute the total energy per atom E_k for each cutoff\n        # E(E_cut) = E_inf + A * E_cut^(-p)\n        energies_k = E_inf + A * E_cut_k**(-p)\n\n        # 3. Define the absolute successive change delta_k\n        # This will be an array of N differences: E_0-E_1, E_1-E_2, ..., E_{N-1}-E_N\n        # Since E(E_cut) is a decreasing function, E_{k-1} > E_k, so abs is not needed.\n        deltas = energies_k[:-1] - energies_k[1:]\n\n        converged_cutoff_result = -1\n        # 4. Declare convergence at the minimal index k_star\n        # The first possible k_star is w=3, since we need w differences.\n        # The loop iterates through possible convergence points.\n        for k_star in range(w, N + 1):\n            # The differences to check are delta_{k_star-w+1}, ..., delta_{k_star}.\n            # In 0-based indexing for the 'deltas' array, this corresponds\n            # to indices from (k_star-w+1)-1 to k_star-1.\n            # So, indices from k_star-w to k_star-1.\n            window_indices_start = k_star - w\n            window_indices_end = k_star\n            \n            window = deltas[window_indices_start:window_indices_end]\n\n            # Check if all differences in the window are = tau\n            if np.all(window = tau):\n                # Convergence is met. Select the corresponding cutoff.\n                converged_cutoff_val = E_cut_0 + k_star * Delta\n                # Round to the nearest integer eV.\n                converged_cutoff_result = int(np.round(converged_cutoff_val))\n                # Break the loop as we need the minimal k_star.\n                break\n        \n        results.append(converged_cutoff_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2475310"}, {"introduction": "我们的模型的好坏取决于其底层的近似。在本实践中，我们将深入探讨验证赝势这一关键任务，确保它能够准确地描述一个元素在不同化学环境（从不同氧化态到不同压力）中的行为。通过实现一套基于物理可观测量（如散射性质和弹性）的诊断测试 ([@problem_id:2475337])，你将学会如何评估计算“配方”中一个核心成分的可靠性。", "problem": "一位材料化学家需要验证一种范数守恒赝势对于单一元素在不同氧化态、配位环境和压力下的可移植性，且只能使用第一性原理一致的诊断方法和数值上明确定义的度量标准。设计一个程序，该程序基于基本的散射和弹性定义计算三个诊断指标，并对几个测试案例进行汇总。推导和算法必须仅基于以下基础：密度泛函理论 (DFT) 的 Kohn–Sham 方程保证了价电子散射性质决定了成键和结构；范数守恒意味着某些径向积分的相等，并因此暗示了在参考通道中对数导数的近似相等；在平衡点附近，不同配位环境中的内聚能可以通过短程对势来近似；等温体弹模量由平衡体积下总能量对体积的二阶导数定义。\n\n对于每个测试案例，您将获得模拟全电子和赝势结果的紧凑数据。您的任务是为每个案例计算三个度量：\n\n- 测试 A（跨氧化态的散射可移植性）：对于每个氧化态 $q \\in \\{0,+2,+4\\}$ 和角动量通道 $l \\in \\{0,1,2\\}$，在固定的匹配半径处，全电子对数导数被建模为电子能量 $E$（单位为 $\\mathrm{eV}$）的三次多项式：$D_{l}^{\\mathrm{AE}}(E;q) = c_{0}+c_{1}E+c_{2}E^{2}+c_{3}E^{3}$，赝势的 $D_{l}^{\\mathrm{PP}}(E;q)$ 也类似。在能量网格 $E \\in \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$（单位为 $\\mathrm{eV}$）上，计算最大绝对偏差\n$$\nM_{1}=\\max_{q,l,E} \\left|D_{l}^{\\mathrm{PP}}(E;q)-D_{l}^{\\mathrm{AE}}(E;q)\\right|.\n$$\n将 $M_{1}$ 报告为无量纲浮点数。\n\n- 测试 B（通过局部键刚度评估的配位可移植性）：对于八面体（$\\mathrm{CN}=6$）和四面体（$\\mathrm{CN}=4$）环境，近平衡键由 Morse 势 $V(r)=D_{e}\\left(1-e^{-a(r-r_{e})}\\right)^{2}-D_{e}$ 建模，其参数 $D_{e}$（单位为 $\\mathrm{eV}$）、$a$（单位为 $\\mathrm{\\AA}^{-1}$）和 $r_{e}$（单位为 $\\mathrm{\\AA}$）分别提供给全电子参考和赝势。计算两种模型在每种环境中平衡点的曲率 $k=\\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}}$，然后计算相对曲率误差 $\\varepsilon=\\left|k^{\\mathrm{PP}}-k^{\\mathrm{AE}}\\right|/k^{\\mathrm{AE}}$。通过取最大值来汇总两种环境的结果\n$$\nM_{2}=\\max\\{\\varepsilon_{\\mathrm{oct}},\\varepsilon_{\\mathrm{tet}}\\}.\n$$\n将 $M_{2}$ 报告为无量纲小数。\n\n- 测试 C（通过状态方程曲率评估的压力可移植性）：给定在不同体积 $V$（单位为 $\\mathrm{\\AA}^{3}$）下的离散总能量 $E(V)$（单位为 $\\mathrm{eV}$），针对全电子参考和赝势，通过对能量最低的三个相邻点进行二次插值来确定平衡体积 $V^{\\star}$ 并估计二阶导数 $\\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}}$。根据体弹模量的热力学定义，\n$$\nB_{0} = V^{\\star} \\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}},\n$$\n计算 $B_{0}^{\\mathrm{AE}}$ 和 $B_{0}^{\\mathrm{PP}}$，使用转换因子 $1\\ \\mathrm{eV}/\\mathrm{\\AA}^{3} = 160.21766208\\ \\mathrm{GPa}$ 将其从 $\\mathrm{eV}/\\mathrm{\\AA}^{3}$ 转换为 $\\mathrm{GPa}$，并报告绝对差值\n$$\nM_{3}=\\left|B_{0}^{\\mathrm{PP}}-B_{0}^{\\mathrm{AE}}\\right|\n$$\n，单位为 $\\mathrm{GPa}$。\n\n您的程序必须为每个测试案例计算 $\\left[M_{1},M_{2},M_{3}\\right]$，并将每个案例的三个结果向量汇总到一个列表中。\n\n所有物理和数值单位必须严格按照规定使用：能量单位为 $\\mathrm{eV}$，长度单位为 $\\mathrm{\\AA}$，体积单位为 $\\mathrm{\\AA}^{3}$，体弹模量单位为 $\\mathrm{GPa}$。角度不出现。所有报告的相对误差必须是小数（而非百分比）。\n\n测试套件。请精确使用以下数据。\n\n- 测试A的能量网格：$E \\in \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$，单位为 $\\mathrm{eV}$。\n\n- 对于所有测试案例，全电子对数导数系数 $c_{0},c_{1},c_{2},c_{3}$ 用于 $D_{l}^{\\mathrm{AE}}(E;q)$ 如下：\n\n  • 氧化态 $q=0$：\n    – $l=0$: $(0.2, -0.05, 0.01, -0.0005)$, \n    – $l=1$: $(0.1, 0.02, -0.005, 0.0002)$, \n    – $l=2$: $(-0.05, 0.03, 0.004, -0.0001)$.\n\n  • 氧化态 $q=+2$：\n    – $l=0$: $(0.25, -0.045, 0.011, -0.00052)$, \n    – $l=1$: $(0.12, 0.018, -0.0045, 0.00018)$, \n    – $l=2$: $(-0.04, 0.028, 0.0045, -0.000095)$.\n\n  • 氧化态 $q=+4$：\n    – $l=0$: $(0.3, -0.04, 0.012, -0.00054)$, \n    – $l=1$: $(0.14, 0.016, -0.004, 0.00016)$, \n    – $l=2$: $(-0.03, 0.026, 0.005, -0.00009)$.\n\n- 测试案例 1（良好赝势）：\n\n  • 赝势多项式偏移量 $\\Delta c$ 添加到上述全电子系数上（即 $c^{\\mathrm{PP}}=c^{\\mathrm{AE}}+\\Delta c$）：\n  \n    – $q=0$：\n      $l=0$: $(0.002, -0.001, 0.0002, -0.00002)$, \n      $l=1$: $(-0.0015, 0.0005, -0.0003, 0.00001)$, \n      $l=2$: $(0.001, -0.0008, 0.0001, 0.0)$.\n      \n    – $q=+2$：\n      $l=0$: $(0.003, -0.0008, 0.0001, 0.0)$, \n      $l=1$: $(0.0, 0.0004, -0.0002, 0.00002)$, \n      $l=2$: $(0.0007, -0.0006, 0.0001, -0.00001)$.\n      \n    – $q=+4$：\n      $l=0$: $(0.004, -0.0005, 0.0002, 0.00002)$, \n      $l=1$: $(0.0005, 0.0003, -0.00015, 0.00002)$, \n      $l=2$: $(0.0008, -0.0005, 0.00012, -0.00002)$.\n  \n  • 八面体和四面体环境的 Morse 参数 $(D_{e},a,r_{e})$ 分别为：\n  \n    – 全电子：八面体 $(1.50, 1.8, 2.00)$，四面体 $(1.20, 1.7, 2.10)$。\n    \n    – 赝势：八面体 $(1.49, 1.82, 2.01)$，四面体 $(1.18, 1.68, 2.11)$。\n  \n  • 测试C的体积（单位为 $\\mathrm{\\AA}^{3}$）：$[13, 14, 15, 16, 17, 18, 19]$。\n\n    – 全电子能量（单位为 $\\mathrm{eV}$）：$[-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225]$。\n    \n    – 赝势能量（单位为 $\\mathrm{eV}$）：$[-4.667138, -4.879939, -4.986128, -5.019981, -4.991551, -4.887212, -4.669016]$。\n\n- 测试案例 2（临界赝势）：\n\n  • 赝势多项式偏移量 $\\Delta c$：\n  \n    – $q=0$：\n      $l=0$: $(0.01, -0.003, 0.0008, -0.00008)$, \n      $l=1$: $(-0.008, 0.002, -0.0009, 0.00005)$, \n      $l=2$: $(0.006, -0.002, 0.0005, 0.00002)$.\n      \n    – $q=+2$：\n      $l=0$: $(0.012, -0.0025, 0.0006, 0.00004)$, \n      $l=1$: $(0.005, 0.0015, -0.0007, 0.00006)$, \n      $l=2$: $(0.007, -0.002, 0.0006, -0.00002)$.\n      \n    – $q=+4$：\n      $l=0$: $(0.015, -0.002, 0.0007, 0.00005)$, \n      $l=1$: $(0.006, 0.001, -0.0006, 0.00005)$, \n      $l=2$: $(0.008, -0.0015, 0.0007, -0.00004)$.\n  \n  • Morse 参数：\n  \n    – 全电子：八面体 $(1.50, 1.8, 2.00)$，四面体 $(1.20, 1.7, 2.10)$。\n    \n    – 赝势：八面体 $(1.40, 1.75, 2.05)$，四面体 $(1.10, 1.60, 2.16)$。\n  \n  • 体积（单位为 $\\mathrm{\\AA}^{3}$）：$[13, 14, 15, 16, 17, 18, 19]$。\n\n    – 全电子能量（单位为 $\\mathrm{eV}$）：$[-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225]$。\n    \n    – 赝势能量（单位为 $\\mathrm{eV}$）：$[-4.471825, -4.7221685, -4.8452055, -4.89443675, -4.89416175, -4.8404805, -4.7002935]$。\n\n- 测试案例 3（较差赝势）：\n\n  • 赝势多项式偏移量 $\\Delta c$：\n  \n    – $q=0$：\n      $l=0$: $(0.05, 0.01, 0.005, 0.0)$, \n      $l=1$: $(-0.04, 0.02, -0.003, 0.0005)$, \n      $l=2$: $(0.03, -0.015, 0.004, -0.0003)$.\n      \n    – $q=+2$：\n      $l=0$: $(0.06, 0.012, 0.006, 0.0002)$, \n      $l=1$: $(-0.035, 0.018, -0.0025, 0.0006)$, \n      $l=2$: $(0.032, -0.013, 0.0045, -0.00035)$.\n      \n    – $q=+4$：\n      $l=0$: $(0.07, 0.015, 0.007, 0.0003)$, \n      $l=1$: $(-0.03, 0.017, -0.002, 0.0007)$, \n      $l=2$: $(0.035, -0.012, 0.005, -0.0004)$.\n  \n  • Morse 参数：\n  \n    – 全电子：八面体 $(1.50, 1.8, 2.00)$，四面体 $(1.20, 1.7, 2.10)$。\n    \n    – 赝势：八面体 $(1.10, 1.5, 2.20)$，四面体 $(0.90, 1.4, 2.30)$。\n  \n  • 体积（单位为 $\\mathrm{\\AA}^{3}$）：$[13, 14, 15, 16, 17, 18, 19]$。\n\n    – 全电子能量（单位为 $\\mathrm{eV}$）：$[-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225]$。\n    \n    – 赝势能量（单位为 $\\mathrm{eV}$）：$[-3.976031, -4.317781, -4.367925, -4.463703, -4.49646725, -4.49621725, -4.456953]$。\n\n答案规格和输出格式：\n\n- 对于三个测试案例中的每一个，计算如上定义的三元组 $[M_{1},M_{2},M_{3}]$。\n\n- 您的程序应生成单行输出，其中包含三个三元组，形式为逗号分隔的列表的列表，每个浮点数四舍五入到六位小数，并用方括号括起来。例如：$[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],[x_{31},x_{32},x_{33}]]$，其中每个 $x_{ij}$ 都是一个浮点数。\n\n- 无需也不允许用户输入；所有数据均按提供的内容固定。\n\n解答必须从所述基础推导得出，不得假设问题陈述中未给出的任何公式。实现可以采用通用数值方法，如多项式求值、有限差分和二次插值。使用转换因子 $1\\ \\mathrm{eV}/\\mathrm{\\AA}^{3} = 160.21766208\\ \\mathrm{GPa}$ 来以 $\\mathrm{GPa}$ 为单位表示 $M_{3}$。角度单位不适用。最终的数值输出必须遵守指定的单位和四舍五入规则。", "solution": "问题陈述已根据所需标准进行解析和验证。\n\n**结论：** 问题是**有效**的。\n\n**推理：**\n1.  **科学基础：** 该问题牢固地植根于计算材料科学的原理，特别是密度泛函理论（DFT）。用于赝势验证的诊断方法——比较散射波函数的对数导数、从势能面分析键刚度以及从状态方程计算体弹模量——是该领域中标准的、具有物理意义且数值定义明确的程序。所提供的理论背景是准确的。\n2.  **适定性：** 该问题在数学和计算上都是适定的。它为三个测试案例中的每一个提供了所有必要的数据和常数。度量 $M_{1}$、$M_{2}$ 和 $M_{3}$ 的定义清晰明确，能够导出一个唯一、可计算的结果。所需的数值方法（多项式求值、二次插值）是标准的。\n3.  **客观性和完整性：** 该问题以客观、定量的语言陈述。所有参数、变量和条件都已明确定义。问题是自包含的，除了所提供的信息外，不需要任何外部信息或假设。\n\n该问题没有科学谬误、矛盾或含糊之处。它代表了一个具体的、非平凡的计算任务，直接模拟了真实的科学工作流程。因此，有必要提供一个完整的解决方案。\n\n**解决方案推导与算法设计**\n\n任务是为赝势的三个测试案例计算三个诊断度量——$M_{1}$、$M_{2}$ 和 $M_{3}$。解决方案的结构是独立处理每个度量的计算。\n\n**度量 $M_{1}$：散射可移植性**\n该度量用于量化全电子（AE）参考模型和赝势（PP）模型在不同氧化态 $q$ 和角动量通道 $l$ 下散射性质的差异。核心量是对数导数 $D_{l}(E;q)$，它被建模为能量 $E$ 的三次多项式：$D(E) = c_{0}+c_{1}E+c_{2}E^{2}+c_{3}E^{3}$。\n\n问题要求计算 $M_{1}=\\max_{q,l,E} \\left|D_{l}^{\\mathrm{PP}}(E;q)-D_{l}^{\\mathrm{AE}}(E;q)\\right|$。\n赝势多项式的系数由 $c^{\\mathrm{PP}} = c^{\\mathrm{AE}} + \\Delta c$ 给出。\n因此，其差值也是一个三次多项式，其系数是所提供的偏移量 $\\Delta c = (\\Delta c_{0}, \\Delta c_{1}, \\Delta c_{2}, \\Delta c_{3})$：\n$$\n\\Delta D_{l}(E;q) = D_{l}^{\\mathrm{PP}}(E;q) - D_{l}^{\\mathrm{AE}}(E;q) = \\Delta c_{0} + \\Delta c_{1}E + \\Delta c_{2}E^{2} + \\Delta c_{3}E^{3}\n$$\n计算 $M_1$ 的算法如下：\n1.  初始化变量 `max_deviation` 为 $0$。\n2.  定义能量网格 $E \\in \\{-5, -4, \\dots, 4, 5\\}$，单位为 $\\mathrm{eV}$。\n3.  遍历氧化态 $q \\in \\{0,+2,+4\\}$ 和角动量 $l \\in \\{0,1,2\\}$ 的每种组合。\n4.  对于每个 $(q, l)$ 对，获取相应的 $\\Delta c$ 向量。\n5.  对能量网格中所有的 $E$ 值，计算多项式 $\\Delta D_{l}(E;q)$ 的值。\n6.  计算这些结果的最大绝对值，$\\max_{E} |\\Delta D_{l}(E;q)|$。\n7.  如果该值大于当前最大值，则更新 `max_deviation`。\n8.  `max_deviation` 的最终值即为度量 $M_1$。\n\n**度量 $M_{2}$：配位可移植性**\n该度量通过比较从 Morse 势模型 $V(r)=D_{e}\\left(1-e^{-a(r-r_{e})}\\right)^{2}-D_{e}$ 导出的键刚度，来评估赝势再现局部成键环境的能力。刚度是势在平衡键距 $r_e$ 处的曲率。\n\n曲率 $k$ 定义为 $k = \\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}}$。我们首先计算 Morse 势的导数：\n$$\n\\frac{dV}{dr} = D_{e} \\cdot 2\\left(1-e^{-a(r-r_{e})}\\right) \\cdot \\left(-e^{-a(r-r_{e})}\\right) \\cdot (-a) = 2aD_{e}\\left(e^{-a(r-r_{e})} - e^{-2a(r-r_{e})}\\right)\n$$\n$$\n\\frac{d^{2}V}{dr^{2}} = 2aD_{e}\\left(-a e^{-a(r-r_{e})} + 2a e^{-2a(r-r_{e})}\\right)\n$$\n在平衡距离 $r=r_{e}$ 处计算二阶导数：\n$$\nk = \\left.\\frac{d^{2}V}{dr^{2}}\\right|_{r=r_{e}} = 2aD_{e}\\left(-a e^{0} + 2a e^{0}\\right) = 2aD_{e}(-a + 2a) = 2a^{2}D_{e}\n$$\n计算 $M_2$ 的算法是：\n1.  对于八面体环境，计算 AE 和 PP 曲率：\n    $k_{\\mathrm{oct}}^{\\mathrm{AE}} = 2 (a_{\\mathrm{oct}}^{\\mathrm{AE}})^2 D_{e, \\mathrm{oct}}^{\\mathrm{AE}}$\n    $k_{\\mathrm{oct}}^{\\mathrm{PP}} = 2 (a_{\\mathrm{oct}}^{\\mathrm{PP}})^2 D_{e, \\mathrm{oct}}^{\\mathrm{PP}}$\n2.  计算八面体情况下的相对误差：$\\varepsilon_{\\mathrm{oct}}=\\left|k_{\\mathrm{oct}}^{\\mathrm{PP}}-k_{\\mathrm{oct}}^{\\mathrm{AE}}\\right|/k_{\\mathrm{oct}}^{\\mathrm{AE}}$。\n3.  对四面体环境重复步骤1和2，以找到 $k_{\\mathrm{tet}}^{\\mathrm{AE}}$、$k_{\\mathrm{tet}}^{\\mathrm{PP}}$ 和 $\\varepsilon_{\\mathrm{tet}}$。\n4.  度量 $M_2$ 是两个相对误差的最大值：$M_{2}=\\max\\{\\varepsilon_{\\mathrm{oct}},\\varepsilon_{\\mathrm{tet}}\\}$。\n\n**度量 $M_{3}$：压力可移植性**\n该度量比较了从状态方程（EOS）（即总能量 $E$ 作为体积 $V$ 的函数）导出的宏观弹性性质——体弹模量 $B_0$。其热力学定义为 $B_{0} = V^{\\star} \\left.\\frac{d^{2}E}{dV^{2}}\\right|_{V^{\\star}}$，其中 $V^{\\star}$ 是平衡体积。\n\n该算法在能量最低点周围的三个点上使用二次插值，将 EOS 曲线局部建模为 $E(V) \\approx aV^2 + bV + c$。\n1.  对于给定的离散 $E(V)$ 数据集，找到对应于最低能量的索引 `i_min`。\n2.  选择 $i \\in \\{\\text{i\\_min}-1, \\text{i\\_min}, \\text{i\\_min}+1\\}$ 的三个点 $(V_{i}, E_{i})$。\n3.  对这三个点拟合一个二次多项式 $E(V) = aV^2 + bV + c$。这可以通过求解一个 $3 \\times 3$ 的线性方程组或使用标准的数值库函数来完成。系数 $a$ 和 $b$ 就足够了。\n4.  从拟合的抛物线可知，二阶导数是一个常数：$\\frac{d^{2}E}{dV^{2}} = 2a$。\n5.  平衡体积 $V^{\\star}$ 对应于抛物线的最小值，该点满足 $\\frac{dE}{dV} = 2aV + b = 0$，因此 $V^{\\star} = -b/(2a)$。\n6.  以 $\\mathrm{eV}/\\mathrm{\\AA}^{3}$ 为单位的体弹模量计算如下：$B_{0} = V^{\\star} \\left(2a\\right) = \\left(-\\frac{b}{2a}\\right) \\left(2a\\right) = -b$。\n7.  对 AE 和 PP 数据集都执行此过程，以找到 $B_{0}^{\\mathrm{AE}}$ 和 $B_{0}^{\\mathrm{PP}}$。\n8.  最终度量 $M_3$ 是转换为吉帕斯卡（GPa）的绝对差值：$M_{3}=\\left|B_{0}^{\\mathrm{PP}}-B_{0}^{\\mathrm{AE}}\\right| \\times 160.21766208 \\text{ GPa}/(\\mathrm{eV}/\\mathrm{\\AA}^{3})$。\n\n这三种算法的组合为每个测试案例提供了所需的三元组 $[M_1, M_2, M_3]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes three pseudopotential validation metrics (M1, M2, M3) for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Common All-Electron (AE) data for all test cases\n    # AE Log-derivative polynomial coefficients: c0, c1, c2, c3\n    c_ae_coeffs = {\n        0: {  # q=0\n            0: [0.2, -0.05, 0.01, -0.0005],  # l=0\n            1: [0.1, 0.02, -0.005, 0.0002],  # l=1\n            2: [-0.05, 0.03, 0.004, -0.0001],  # l=2\n        },\n        2: {  # q=+2\n            0: [0.25, -0.045, 0.011, -0.00052],  # l=0\n            1: [0.12, 0.018, -0.0045, 0.00018],  # l=1\n            2: [-0.04, 0.028, 0.0045, -0.000095],  # l=2\n        },\n        4: {  # q=+4\n            0: [0.3, -0.04, 0.012, -0.00054],  # l=0\n            1: [0.14, 0.016, -0.004, 0.00016],  # l=1\n            2: [-0.03, 0.026, 0.005, -0.00009],  # l=2\n        },\n    }\n    \n    # AE Morse parameters (De, a, re)\n    morse_ae = {\n        'oct': (1.50, 1.8, 2.00),\n        'tet': (1.20, 1.7, 2.10)\n    }\n\n    # AE E(V) data\n    volumes_eos = np.array([13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0])\n    energies_ae_eos = np.array([-4.66925, -4.871, -4.97025, -5.0, -4.96925, -4.863, -4.64225])\n    \n    # Energy grid for Test A\n    energy_grid = np.arange(-5, 6, 1)\n\n    # Conversion factor for Test C\n    GPA_CONV_FACTOR = 160.21766208\n\n    # Test cases data\n    test_cases = [\n        # Test Case 1: good pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.002, -0.001, 0.0002, -0.00002], 1: [-0.0015, 0.0005, -0.0003, 0.00001], 2: [0.001, -0.0008, 0.0001, 0.0]},\n                2: {0: [0.003, -0.0008, 0.0001, 0.0], 1: [0.0, 0.0004, -0.0002, 0.00002], 2: [0.0007, -0.0006, 0.0001, -0.00001]},\n                4: {0: [0.004, -0.0005, 0.0002, 0.00002], 1: [0.0005, 0.0003, -0.00015, 0.00002], 2: [0.0008, -0.0005, 0.00012, -0.00002]},\n            },\n            \"morse_pp\": {'oct': (1.49, 1.82, 2.01), 'tet': (1.18, 1.68, 2.11)},\n            \"energies_pp_eos\": np.array([-4.667138, -4.879939, -4.986128, -5.019981, -4.991551, -4.887212, -4.669016]),\n        },\n        # Test Case 2: borderline pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.01, -0.003, 0.0008, -0.00008], 1: [-0.008, 0.002, -0.0009, 0.00005], 2: [0.006, -0.002, 0.0005, 0.00002]},\n                2: {0: [0.012, -0.0025, 0.0006, 0.00004], 1: [0.005, 0.0015, -0.0007, 0.00006], 2: [0.007, -0.002, 0.0006, -0.00002]},\n                4: {0: [0.015, -0.002, 0.0007, 0.00005], 1: [0.006, 0.001, -0.0006, 0.00005], 2: [0.008, -0.0015, 0.0007, -0.00004]},\n            },\n            \"morse_pp\": {'oct': (1.40, 1.75, 2.05), 'tet': (1.10, 1.60, 2.16)},\n            \"energies_pp_eos\": np.array([-4.471825, -4.7221685, -4.8452055, -4.89443675, -4.89416175, -4.8404805, -4.7002935]),\n        },\n        # Test Case 3: poor pseudopotential\n        {\n            \"delta_c\": {\n                0: {0: [0.05, 0.01, 0.005, 0.0], 1: [-0.04, 0.02, -0.003, 0.0005], 2: [0.03, -0.015, 0.004, -0.0003]},\n                2: {0: [0.06, 0.012, 0.006, 0.0002], 1: [-0.035, 0.018, -0.0025, 0.0006], 2: [0.032, -0.013, 0.0045, -0.00035]},\n                4: {0: [0.07, 0.015, 0.007, 0.0003], 1: [-0.03, 0.017, -0.002, 0.0007], 2: [0.035, -0.012, 0.005, -0.0004]},\n            },\n            \"morse_pp\": {'oct': (1.10, 1.5, 2.20), 'tet': (0.90, 1.4, 2.30)},\n            \"energies_pp_eos\": np.array([-3.976031, -4.317781, -4.367925, -4.463703, -4.49646725, -4.49621725, -4.456953]),\n        },\n    ]\n\n    # --- Calculation Functions ---\n\n    def calculate_m1(delta_c_data):\n        max_deviation = 0.0\n        for q in delta_c_data:\n            for l in delta_c_data[q]:\n                coeffs = delta_c_data[q][l]\n                # np.poly1d expects coefficients for highest power first\n                poly_diff = np.poly1d(coeffs[::-1])\n                deviations_on_grid = np.abs(poly_diff(energy_grid))\n                max_deviation = max(max_deviation, np.max(deviations_on_grid))\n        return max_deviation\n\n    def calculate_m2(morse_ae, morse_pp):\n        def get_curvature(params):\n            De, a, _ = params\n            return 2.0 * a**2 * De\n\n        k_ae_oct = get_curvature(morse_ae['oct'])\n        k_pp_oct = get_curvature(morse_pp['oct'])\n        eps_oct = abs(k_pp_oct - k_ae_oct) / k_ae_oct\n\n        k_ae_tet = get_curvature(morse_ae['tet'])\n        k_pp_tet = get_curvature(morse_pp['tet'])\n        eps_tet = abs(k_pp_tet - k_ae_tet) / k_ae_tet\n        \n        return max(eps_oct, eps_tet)\n\n    def get_bulk_modulus(volumes, energies):\n        if len(volumes)  3:\n            raise ValueError(\"Need at least 3 points for quadratic interpolation.\")\n\n        i_min = np.argmin(energies)\n        \n        # Ensure we don't go out of bounds, though problem data is safe\n        if i_min == 0 or i_min == len(volumes) - 1:\n             raise ValueError(\"Minimum energy is at an endpoint, cannot form a 3-point stencil.\")\n\n        V_fit = volumes[i_min-1:i_min+2]\n        E_fit = energies[i_min-1:i_min+2]\n\n        # Fit E = aV^2 + bV + c\n        # B0 = V* * (d2E/dV2) = (-b/2a) * (2a) = -b\n        a, b, c = np.polyfit(V_fit, E_fit, 2)\n        \n        b0_ev_per_a3 = -b\n        return b0_ev_per_a3\n\n    def calculate_m3(volumes_eos, energies_ae_eos, energies_pp_eos):\n        b0_ae = get_bulk_modulus(volumes_eos, energies_ae_eos)\n        b0_pp = get_bulk_modulus(volumes_eos, energies_pp_eos)\n        \n        m3_gpa = abs(b0_pp - b0_ae) * GPA_CONV_FACTOR\n        return m3_gpa\n\n    # --- Main Loop ---\n    \n    all_results = []\n    for case in test_cases:\n        m1 = calculate_m1(case[\"delta_c\"])\n        m2 = calculate_m2(morse_ae, case[\"morse_pp\"])\n        m3 = calculate_m3(volumes_eos, energies_ae_eos, case[\"energies_pp_eos\"])\n        \n        all_results.append([m1, m2, m3])\n\n    # --- Format and Print Output ---\n    \n    formatted_results = []\n    for result_triplet in all_results:\n        m1, m2, m3 = result_triplet\n        formatted_triplet = f\"[{m1:.6f},{m2:.6f},{m3:.6f}]\"\n        formatted_results.append(formatted_triplet)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2475337"}, {"introduction": "除了静态性质，计算材料科学还使我们能够探索化学反应的动态过程。这最后一个实践提供了一个严谨的工作流程，用于识别和验证过渡态——这个决定化学转化速率和路径的瞬时构型。通过应用基于势能面 $V(\\mathbf{q})$ 微积分的基本准则 ([@problem_id:2475357])，你将掌握从原子尺度上阐明反应机理的核心计算技能。", "problem": "您的任务是形式化并实现一套准则，仅使用基于势能面的微积分基本原理，来验证势能面上的一个给定原子构型是否为反应路径理论意义上的真实过渡态。该验证必须结合两项基本要求：(i) 通过Hessian指数（单一的不稳定模式对应于单一的虚频）确定驻点的局域特性，以及 (ii) 通过质量加权坐标下的内禀反应坐标确定与正确的反应物和产物极小值点的动力学连通性。所有坐标的单位为埃（$\\mathrm{\\AA}$），所有能量的单位为电子伏特（$\\mathrm{eV}$）。由于您的程序必须输出布尔值，因此最终输出中不应包含任何单位。\n\n基本依据与定义：在笛卡尔坐标 $\\mathbf{q} \\in \\mathbb{R}^n$ 上的势能面 $V(\\mathbf{q})$ 将力定义为 $-\\nabla V(\\mathbf{q})$。驻点满足 $\\nabla V(\\mathbf{q}_\\mathrm{s})=\\mathbf{0}$。驻点处的Hessian矩阵 $H(\\mathbf{q})=\\nabla^2 V(\\mathbf{q})$ 对其性质进行分类：极小值点的所有Hessian特征值均为正，而k阶鞍点恰好有k个负特征值（在谐振子近似下，等价于有k个虚谐振频率）。一个真实的过渡态（一阶鞍点）恰好有一个负特征值，且所有其余特征值均为严格正值。内禀反应坐标是在质量加权坐标下，从过渡态出发，沿着唯一的不稳定模式朝向相邻极小值点的最速下降曲线。在本问题中，设所有质量均为单位1，因此笛卡尔坐标下的最速下降与质量加权最速下降相重合。您可以通过沿着 $-\\nabla V(\\mathbf{q})$ 方向的迭代步长，并结合线搜索以确保 $V$ 的单调递减，来离散化内禀反应坐标。\n\n任务：编写一个完整的程序，针对下述每个测试用例，判断给定的候选构型 $\\mathbf{q}_c$ 是否为连接两个指定极小值点的真实过渡态。您的判断必须仅基于从上述基本依据推导出的以下准则：\n\n- 驻点性：$\\lVert \\nabla V(\\mathbf{q}_c)\\rVert_2 \\le \\varepsilon_\\mathrm{grad}$。\n- 1阶Hessian：$H(\\mathbf{q}_c)$ 恰好有一个特征值小于 $-\\varepsilon_\\lambda$，所有其他特征值均大于 $\\varepsilon_\\lambda$，且没有特征值的绝对值小于等于 $\\varepsilon_\\lambda$。\n- 通过内禀反应坐标的连通性：设 $\\mathbf{v}_-$ 为 $H(\\mathbf{q}_c)$ 的最负特征值所对应的归一化特征向量。初始化两个点 $\\mathbf{q}_\\pm^{(0)}=\\mathbf{q}_c \\pm \\delta\\, \\mathbf{v}_-$。对每个分支 $b\\in\\{+,-\\}$，通过迭代更新 $\\mathbf{q}_b^{(k+1)}=\\mathbf{q}_b^{(k)} - s_k \\nabla V(\\mathbf{q}_b^{(k)})$（并对 $s_k$ 进行回溯以强制满足 $V(\\mathbf{q}_b^{(k+1)})  V(\\mathbf{q}_b^{(k)})$），直至收敛到一个满足 $\\lVert \\nabla V(\\mathbf{q}_b^{(*)})\\rVert_2 \\le \\varepsilon_\\mathrm{grad}$ 的驻点。每个收敛的终点必须是一个极小值点（其Hessian矩阵的所有特征值均大于 $\\varepsilon_\\lambda$），并且必须在坐标容差 $\\varepsilon_\\mathrm{dist}$ 内与两个目标极小值点之一匹配（无序匹配，使用终点到目标点距离之和的最小值）。\n\n使用以下您必须一致应用的容差：$\\varepsilon_\\mathrm{grad}=10^{-6}\\ \\mathrm{eV}/\\mathrm{\\AA}$，$\\varepsilon_\\lambda=10^{-4}\\ \\mathrm{eV}/\\mathrm{\\AA}^2$，$\\varepsilon_\\mathrm{dist}=10^{-2}\\ \\mathrm{\\AA}$，小位移 $\\delta=10^{-3}\\ \\mathrm{\\AA}$，以及每个内禀反应坐标分支最多 $N_\\mathrm{iter}=2000$ 步的合理最大值。步长 $s_k$ 可自由选择，但必须为正，并且在势能未能减小时应减小；您可以初始设为 $s_0=10^{-1}$，并根据需要通过折半进行回溯。本问题不使用角度，因此不需要角度单位。\n\n势函数：对于每个测试，势函数 $V(x,y)$ 都有明确的定义。此处 $x$ 和 $y$ 表示 $\\mathbb{R}^2$ 中的两个笛卡尔自由度，用于模拟材料化学背景下的一个简化二维反应坐标。\n\n- 双阱加谐振子势：$V_1(x,y) = a\\,(x^2-b^2)^2 + c\\,y^2$。\n- 耦合双阱势：$V_2(x,y) = a\\,(x^2-b^2)^2 + c\\,y^2 + d\\,x\\,y$。\n- 稳定化的倒置二次型（原点处为高阶鞍点）：$V_3(x,y) = \\alpha\\,x^4 + \\beta\\,y^4 - \\tfrac{1}{2}k_x x^2 - \\tfrac{1}{2}k_y y^2$。\n\n测试套件：对于每个案例，您都会获得势函数类型和参数、候选点 $\\mathbf{q}_c=(x_c,y_c)$ 以及两个目标极小值点。您的程序必须评估上述准则，并为每个案例返回一个布尔值。\n\n- 案例1（理想路径，正确的过渡态和连通性）：\n  - 势函数：$V_1$，参数为 $a=0.05$，$b=1.5$，$c=0.2$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n- 案例2（极小值点被误分类为候选点，应无法通过1阶指数测试）：\n  - 势函数：$V_1$，参数为 $a=0.05$，$b=1.5$，$c=0.2$。\n  - 候选点：$\\mathbf{q}_c=(1.5,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n- 案例3（具有两个不稳定模式的高阶鞍点，应无法通过1阶指数测试）：\n  - 势函数：$V_3$，参数为 $\\alpha=0.1$，$\\beta=0.1$，$k_x=0.6$，$k_y=0.5$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.0,0.0),(1.0,0.0)\\}$。\n\n- 案例4（正确的1阶鞍点，但耦合路径连接到偏移的极小值点；目标点被故意设置不匹配以测试连通性验证）：\n  - 势函数：$V_2$，参数为 $a=0.05$，$b=1.5$，$c=0.2$，$d=0.3$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n- 案例5（候选点处沿一个模式的曲率接近于零，应无法通过严格的1阶指数要求）：\n  - 势函数：$V_1$，参数为 $a=0.05$，$b=1.5$，$c=1.0\\times 10^{-8}$。\n  - 候选点：$\\mathbf{q}_c=(0.0,0.0)$。\n  - 目标点：$\\{(-1.5,0.0),(1.5,0.0)\\}$。\n\n答案规格：所有案例的输出必须汇总到一行中，该行包含一个Python风格的布尔值列表，按案例1到5的顺序排列，无空格，例如，“[$\\texttt{True},\\texttt{False},\\ldots$]”。您的程序必须是一个完整的、可运行的实现，它根据上面给出的定义执行所有计算，并精确地打印这一行。不允许用户输入，也不得使用外部文件。", "solution": "所述问题是有效的。这是一个适定、有科学依据的计算任务，没有矛盾和歧义，并且不需要超出所提供信息之外的任何信息。该问题要求实现一个严谨的、基于第一性原理的算法，以验证一个候选原子构型是否为连接两个指定化学极小值点的真实过渡态。解决此问题需要综合多元微积分和反应动力学理论中的概念，并将其实现为一个精确的数值算法。\n\n验证过程由三个顺序的准则组成，每个准则都必须满足。在势能面 $V(\\mathbf{q})$ 上的一个候选构型 $\\mathbf{q}_c$ 是连接极小值点 $\\mathbf{q}_A$ 和 $\\mathbf{q}_B$ 的真实过渡态，当且仅当它满足以下条件。\n\n首先，候选点必须是势能面上的一个驻点。在驻点上，所有力都为零。系统所受的力由势的负梯度给出，即 $\\mathbf{F}(\\mathbf{q}) = -\\nabla V(\\mathbf{q})$。因此，驻点条件为 $\\nabla V(\\mathbf{q}_c) = \\mathbf{0}$。对于数值验证，我们将其放宽为基于容差的检查：梯度向量的欧几里得范数必须小于给定的阈值 $\\varepsilon_\\mathrm{grad}$。\n$$\n\\lVert \\nabla V(\\mathbf{q}_c) \\rVert_2 \\le \\varepsilon_\\mathrm{grad}\n$$\n在本问题中，$\\varepsilon_\\mathrm{grad} = 10^{-6}\\ \\mathrm{eV}/\\mathrm{\\AA}$。\n\n其次，驻点必须是一阶鞍点，也称为过渡态。势能面在驻点 $\\mathbf{q}_s$ 处的局域曲率由其Hessian矩阵 $H_{ij}(\\mathbf{q}_s) = \\frac{\\partial^2 V}{\\partial q_i \\partial q_j}\\rvert_{\\mathbf{q}_s}$ 描述。驻点的性质由该矩阵的特征值的符号决定。极小值点的所有特征值均为正，而k阶鞍点恰好有k个负特征值。一个真实的过渡态是一个1阶鞍点。此外，为避免与近乎平坦的势能区域（零模式）产生歧义，所有曲率都必须是显著的。这转化为一个条件，即在 $\\mathbf{q}_c$ 处的Hessian矩阵必须恰好有一个严格为负的特征值（小于 $-\\varepsilon_\\lambda$），且所有其他特征值必须严格为正（大于 $\\varepsilon_\\lambda$）。这种严格性确保了没有零或近零的特征值。对于给定的 $\\mathbb{R}^2$ 中的问题，这意味着一个特征值 $\\lambda_1  -\\varepsilon_\\lambda$ 而另一个特征值 $\\lambda_2 > \\varepsilon_\\lambda$，其中 $\\varepsilon_\\lambda = 10^{-4}\\ \\mathrm{eV}/\\mathrm{\\AA}^2$。\n\n第三，过渡态必须在动力学上连接指定的反应物和产物极小值点。这一点通过追踪内禀反应坐标（IRC）来验证。IRC是从过渡态下降到相邻极小值点的最速下降路径。初始下降的方向由与Hessian矩阵的单个负特征值相关联的特征向量 $\\mathbf{v}_-$ 唯一确定。由于问题假设所有自由度的质量均为单位1，质量加权坐标系与笛卡尔坐标系相同，IRC路径就是简单的最速下降路径。我们从过渡态开始，沿正向和反向两个方向追踪此路径。程序如下：\n1.  识别与 $H(\\mathbf{q}_c)$ 的负特征值相对应的归一化特征向量 $\\mathbf{v}_-$。\n2.  通过将候选点 $\\mathbf{q}_c$ 沿 $\\mathbf{v}_-$ 方向微小移动 $\\delta$ 来初始化两条反应路径。IRC两个分支的起始点为 $\\mathbf{q}_\\pm^{(0)} = \\mathbf{q}_c \\pm \\delta \\mathbf{v}_-$，其中 $\\delta = 10^{-3}\\ \\mathrm{\\AA}$。\n3.  对每个分支，执行梯度下降优化以找到其连接的极小值点。每一步k的更新规则是 $\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - s_k \\nabla V(\\mathbf{q}^{(k)})$。步长 $s_k$ 使用回溯线搜索确定，从 $s_0 = 10^{-1}$ 开始，并将其值折半，直到满足条件 $V(\\mathbf{q}^{(k+1)})  V(\\mathbf{q}^{(k)})$。这确保了沿路径的能量单调递减。\n4.  当达到一个满足驻点条件 $\\lVert \\nabla V(\\mathbf{q}^*) \\rVert_2 \\le \\varepsilon_\\mathrm{grad}$ 的点 $\\mathbf{q}^*$ 时，或在最多 $N_\\mathrm{iter} = 2000$ 步内，下降终止。\n5.  收敛后，必须通过检查其Hessian矩阵 $H(\\mathbf{q}^*)$ 的所有特征值是否严格为正（即大于 $\\varepsilon_\\lambda$）来验证每个终点 $\\mathbf{q}^*$ 是否为真实极小值点。\n6.  最后，收敛并验证后的两个极小值点集合 $\\{\\mathbf{q}^*_+, \\mathbf{q}^*_-\\}$ 必须与目标极小值点集合 $\\{\\mathbf{q}_A, \\mathbf{q}_B\\}$ 匹配。匹配是无序的，意味着我们检查每个终点是否在距离容差 $\\varepsilon_\\mathrm{dist} = 10^{-2}\\ \\mathrm{\\AA}$ 内与一个唯一的目标极小值点相对应。\n\n一个候选构型 $\\mathbf{q}_c$ 当且仅当它按顺序通过所有这三项检查时，才被确认为一个真实的过渡态。所提供的代码实现了这一完整算法，包括用于评估给定测试用例的指定势能函数的梯度和Hessian矩阵的解析表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.linalg import norm, eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the transition state verification for all test cases.\n    \"\"\"\n    \n    # Global constants from the problem statement\n    EPS_GRAD = 1e-6\n    EPS_LAMBDA = 1e-4\n    EPS_DIST = 1e-2\n    DELTA = 1e-3\n    N_ITER = 2000\n    S_INIT = 0.1\n\n    def get_potential_v1(params):\n        \"\"\"Factory for V1 potential, gradient, and Hessian.\"\"\"\n        a, b, c = params['a'], params['b'], params['c']\n        \n        def V(q):\n            x, y = q\n            return a * (x**2 - b**2)**2 + c * y**2\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * a * x * (x**2 - b**2), 2 * c * y])\n        \n        def HessV(q):\n            x, y = q\n            return np.array([[a * (12 * x**2 - 4 * b**2), 0.0], [0.0, 2 * c]])\n            \n        return V, gradV, HessV\n\n    def get_potential_v2(params):\n        \"\"\"Factory for V2 potential, gradient, and Hessian.\"\"\"\n        a, b, c, d = params['a'], params['b'], params['c'], params['d']\n        \n        def V(q):\n            x, y = q\n            return a * (x**2 - b**2)**2 + c * y**2 + d * x * y\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * a * x * (x**2 - b**2) + d * y, 2 * c * y + d * x])\n            \n        def HessV(q):\n            x, y = q\n            return np.array([[a * (12 * x**2 - 4 * b**2), d], [d, 2 * c]])\n            \n        return V, gradV, HessV\n\n    def get_potential_v3(params):\n        \"\"\"Factory for V3 potential, gradient, and Hessian.\"\"\"\n        alpha, beta, kx, ky = params['alpha'], params['beta'], params['k_x'], params['k_y']\n        \n        def V(q):\n            x, y = q\n            return alpha * x**4 + beta * y**4 - 0.5 * kx * x**2 - 0.5 * ky * y**2\n        \n        def gradV(q):\n            x, y = q\n            return np.array([4 * alpha * x**3 - kx * x, 4 * beta * y**3 - ky * y])\n            \n        def HessV(q):\n            x, y = q\n            return np.array([[12 * alpha * x**2 - kx, 0.0], [0.0, 12 * beta * y**2 - ky]])\n            \n        return V, gradV, HessV\n\n    potential_factories = {\n        'V1': get_potential_v1,\n        'V2': get_potential_v2,\n        'V3': get_potential_v3,\n    }\n\n    def find_minimum(start_q, V, gradV, HessV):\n        \"\"\"\n        Performs gradient descent with backtracking to find a minimum.\n        Returns the coordinate of the minimum or None if convergence fails\n        or the converged point is not a minimum.\n        \"\"\"\n        q = np.copy(start_q)\n        v_current = V(q)\n\n        for _ in range(N_ITER):\n            grad = gradV(q)\n            \n            if norm(grad) = EPS_GRAD:\n                # Converged to a stationary point, now check if it's a minimum\n                hess = HessV(q)\n                eigenvals, _ = eigh(hess)\n                if np.all(eigenvals > EPS_LAMBDA):\n                    return q  # It's a valid minimum\n                else:\n                    return None  # Converged but not to a minimum\n\n            s = S_INIT\n            while True:\n                q_new = q - s * grad\n                if V(q_new)  v_current:\n                    q = q_new\n                    v_current = V(q)\n                    break\n                s /= 2.0\n                if s  1e-15:  # Step size is too small, cannot proceed\n                    return None\n        return None # Failed to converge within N_ITER\n\n    def is_true_transition_state(case):\n        \"\"\"\n        Applies the three-part verification to determine if a candidate\n        is a true transition state.\n        \"\"\"\n        V, gradV, HessV = potential_factories[case['potential_type']](case['params'])\n        qc = np.array(case['candidate'])\n        targets = [np.array(t) for t in case['targets']]\n        \n        # 1. Stationarity Check\n        grad_qc = gradV(qc)\n        if norm(grad_qc) > EPS_GRAD:\n            return False\n\n        # 2. Hessian Index-1 Check\n        hess_qc = HessV(qc)\n        eigenvals, eigenvecs = eigh(hess_qc)\n\n        # Check for exactly one negative eigenvalue and the rest positive,\n        # with magnitudes outside the epsilon_lambda tolerance.\n        neg_count = np.sum(eigenvals  -EPS_LAMBDA)\n        pos_count = np.sum(eigenvals > EPS_LAMBDA)\n        if not (neg_count == 1 and (neg_count + pos_count) == len(eigenvals)):\n            return False\n            \n        # Get the eigenvector for the unique negative eigenvalue\n        neg_eig_idx = np.argmin(eigenvals)\n        v_neg = eigenvecs[:, neg_eig_idx]\n\n        # 3. Connectivity Check (IRC)\n        q_start_plus = qc + DELTA * v_neg\n        q_start_minus = qc - DELTA * v_neg\n\n        endpoint1 = find_minimum(q_start_plus, V, gradV, HessV)\n        endpoint2 = find_minimum(q_start_minus, V, gradV, HessV)\n        \n        if endpoint1 is None or endpoint2 is None:\n            return False\n\n        t1, t2 = targets\n        dist_11 = norm(endpoint1 - t1)\n        dist_12 = norm(endpoint1 - t2)\n        dist_21 = norm(endpoint2 - t1)\n        dist_22 = norm(endpoint2 - t2)\n\n        # Check for unordered matching of endpoints to targets\n        match_forward = dist_11 = EPS_DIST and dist_22 = EPS_DIST\n        match_reverse = dist_12 = EPS_DIST and dist_21 = EPS_DIST\n        \n        if not (match_forward or match_reverse):\n            return False\n            \n        return True\n\n    test_cases = [\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2},\n            'candidate': (1.5, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V3', 'params': {'alpha': 0.1, 'beta': 0.1, 'k_x': 0.6, 'k_y': 0.5},\n            'candidate': (0.0, 0.0), 'targets': [(-1.0, 0.0), (1.0, 0.0)]\n        },\n        {\n            'potential_type': 'V2', 'params': {'a': 0.05, 'b': 1.5, 'c': 0.2, 'd': 0.3},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        },\n        {\n            'potential_type': 'V1', 'params': {'a': 0.05, 'b': 1.5, 'c': 1.0e-8},\n            'candidate': (0.0, 0.0), 'targets': [(-1.5, 0.0), (1.5, 0.0)]\n        }\n    ]\n    \n    results = [is_true_transition_state(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2475357"}]}