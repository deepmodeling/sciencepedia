{"hands_on_practices": [{"introduction": "这个练习是分析取向序的基础。它通过指导您从第一性原理出发构建序参量张量，然后实现一个稳健的算法，从离散的取向数据中计算它，从而将理论与实践联系起来。这是一项分析模拟或实验结果时的常见任务[@problem_id:2932989]。", "problem": "考虑一个软物质体系中聚合物链段或棒状介晶的 $N$ 个三维取向样本 $\\{\\mathbf{v}_i\\}_{i=1}^{N}$，其中由于测量噪声，每个 $\\mathbf{v}_i \\in \\mathbb{R}^3$ 可能不是单位向量。其潜在的物理原理在任意链段的头尾反转下保持不变，因此物理状态不受 $\\mathbf{u} \\mapsto -\\mathbf{u}$ 的影响，其中 $\\mathbf{u}$ 表示一个单位取向。你的任务是从第一性原理出发，构建一个对称、无迹的二阶张量来量化取向序，并设计一个鲁棒的数值算法，从离散数据中提取其主指向矢和序的标量度量。\n\n从以下基础出发：\n\n- 构型完全由取向分布指定，对于离散数据，该分布通过使用归一化取向 $\\mathbf{u}_i = \\mathbf{v}_i / \\|\\mathbf{v}_i\\|$（对于所有 $\\|\\mathbf{v}_i\\|  0$ 的 $i$）在单位球面上的经验测度来表示。\n- 头尾对称性意味着只有取向的偶数矩才具有物理意义；特别是，二阶矩张量 $\\mathbf{M} = \\langle \\mathbf{u} \\mathbf{u}^{\\mathsf{T}} \\rangle$ 是一个自然的构造单元，其中 $\\langle \\cdot \\rangle$ 表示对样本的平均。\n- 取向序的二阶描述符必须在全局旋转下不变、对称、无迹，并且在各向同性状态下应为零。它还应通过具有与称为指向矢的单位特征向量相关联的唯一最大特征值来区分单轴排列。\n\n任务：\n\n1. 仅使用上述原理，推导可以从 $\\mathbf{M}$ 和单位张量 $\\mathbf{I}$ 构建的唯一的（在差一个整体标量因子的情况下）对称、无迹张量 $\\mathbf{Q}$，并通过以下要求来确定其整体标量因子：对于沿单位向量 $\\mathbf{n}$ 完全对齐的样本（即对所有 $i$ 都有 $\\mathbf{u}_i = \\mathbf{n}$），最大特征值等于 $1$，而在各向同性极限下该张量为零。用离散数据 $\\{\\mathbf{v}_i\\}_{i=1}^{N}$ 明确表示 $\\mathbf{Q}$。\n2. 证明对于任何单位取向的离散集，张量 $\\mathbf{Q}$ 是对称且无迹的，并且最大特征值 $S$ 位于区间 $[-\\frac{1}{2}, 1]$ 内。\n3. 设计一个数值稳定的算法，给定 $\\{\\mathbf{v}_i\\}_{i=1}^{N}$，该算法返回：\n   - 等于 $\\mathbf{Q}$ 的最大特征值的标量 $S$。\n   - 等于相应单位特征向量的指向矢 $\\mathbf{n}$。\n   你的算法必须：\n   - 将每个非零 $\\mathbf{v}_i$ 归一化为 $\\mathbf{u}_i$，并忽略任何范数为零的 $\\mathbf{v}_i$。\n   - 计算样本二阶矩 $\\mathbf{M}$，作为并矢 $\\mathbf{u}_i \\mathbf{u}_i^{\\mathsf{T}}$ 的平均值。\n   - 从 $\\mathbf{M}$ 构建 $\\mathbf{Q}$，使其对称、无迹，并满足任务1中的归一化条件。\n   - 使用适用于实对称矩阵的特征分解程序。\n   - 为 $\\mathbf{n}$ 实现一个确定性的符号约定以消除 $\\mathbf{n} \\leftrightarrow -\\mathbf{n}$ 的模糊性：如果平均取向 $\\bar{\\mathbf{u}} = \\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{u}_i$ 的范数大于容差 $\\epsilon  0$，则选择 $\\mathbf{n}$ 的符号使得 $\\mathbf{n}\\cdot \\bar{\\mathbf{u}} \\ge 0$。否则（对于近各向同性的数据），选择符号使得 $\\mathbf{n}$ 的绝对值最大的分量为非负值。\n   - 鲁棒地处理简并或近各向同性的情况：如果 $\\mathbf{Q}$ 的所有特征值都在零的一个小容差 $\\delta  0$ 范围内，则按约定返回 $S = 0$ 和 $\\mathbf{n} = (0, 0, 1)$。\n4. 将你的算法实现为一个程序，用以评估以下测试套件。每个测试用例是一个三维向量的列表；不使用角度，也没有物理单位。你的程序必须将所有输入视为无量纲，并在内部对向量进行归一化。\n   - 测试用例 A（围绕 $\\hat{\\mathbf{z}}$ 轴的单轴排列，带有小微扰）：$\\left[(0,0,1),(0,0,1),(0,0,1),(0.1,0, \\sqrt{1-0.1^2}),(-0.1,0.05,\\sqrt{1-0.1^2-0.05^2}),(0.05,-0.02,\\sqrt{1-0.05^2-0.02^2})\\right]$。\n   - 测试用例 B（在笛卡尔轴上精确各向同性）：$\\left[(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)\\right]$。\n   - 测试用例 C（$xy$ 平面内的平面偏向，沿 $\\hat{\\mathbf{x}}$ 轴有轻微主导）：$\\left[(1,0,0),(-1,0,0),(1,0.1,0),(0,1,0),(0,-1,0),(0.7,0.7,0)\\right]$。\n   - 测试用例 D（围绕一个接近 $(1,1,1)$ 的公共指向矢的反平行对）：$\\left[(1,1,1),(-1,-1,-1),(0.9,1.1,1.0),(-0.9,-1.1,-1.0)\\right]$。\n   - 测试用例 E（单向量边界情况）：$\\left[(0.3,-0.4,0.8660254)\\right]$。\n5. 输出规范。对于每个测试用例，输出一个列表 $[S,n_x,n_y,n_z]$，其中 $S$ 是 $\\mathbf{Q}$ 的最大特征值，$(n_x,n_y,n_z)$ 是应用符号约定后指向矢的分量。所有四个数字必须四舍五入到恰好6位小数。你的程序应生成单行输出，其中包含所有测试用例的结果，形式为这些单个用例列表的逗号分隔列表，并用方括号括起来。例如，包含两个假设用例的输出应如下所示：$[[0.500000,0.000000,0.000000,1.000000],[0.000000,0.000000,0.000000,1.000000]]$。\n\n你的解决方案必须从所述原理推导出构造和算法，然后实现它以生成给定测试套件所需的输出。不需要外部输入，也没有要报告的物理单位。未使用角度，因此没有角度单位要求。你的算法使用的所有数值容差必须在解决方案中明确说明并给出理由。最终输出格式必须与上述规定完全一致，为单行。每个测试用例的答案是如上定义的浮点数列表。", "solution": "问题陈述已提交以供验证。\n\n### 步骤 1：提取已知条件\n- 数据：一组 $N$ 个取向向量 $\\{\\mathbf{v}_i\\}_{i=1}^{N}$，其中 $\\mathbf{v}_i \\in \\mathbb{R}^3$。\n- 物理原理：头尾反转不变性（$\\mathbf{u} \\mapsto -\\mathbf{u}$）。\n- 表示：来自归一化向量 $\\mathbf{u}_i = \\mathbf{v}_i / \\|\\mathbf{v}_i\\|$（对于 $\\|\\mathbf{v}_i\\|  0$）的经验测度。\n- 构造单元：二阶矩张量 $\\mathbf{M} = \\langle \\mathbf{u} \\mathbf{u}^{\\mathsf{T}} \\rangle$。\n- 对序张量 $\\mathbf{Q}$ 的要求：二阶、对称、无迹、旋转不变，对于各向同性状态为零，通过唯一的最大特征值和指向矢特征向量来区分单轴排列。\n- 归一化条件：对于完美排列（对所有 $i$ 都有 $\\mathbf{u}_i = \\mathbf{n}$），$\\mathbf{Q}$ 的最大特征值为 $1$。对于各向同性分布，$\\mathbf{Q} = \\mathbf{0}$。\n- 算法要求：一个鲁棒的程序，用于从数据 $\\{\\mathbf{v}_i\\}$ 计算最大特征值 $S$ 和相应的特征向量（指向矢）$\\mathbf{n}$，包括对 $\\mathbf{n}$ 的确定性符号约定和对近各向同性情况的处理。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估该问题。\n- **有科学依据**：该问题是软物质统计力学中的一个标准练习，特别是向列序参量张量（de Gennes-Maier-Saupe 张量）的构造。所有原理和定义都是该领域正确且基础的内容。\n- **适定的**：该问题提供了足够的约束来唯一地推导张量 $\\mathbf{Q}$ 及其性质。各项任务在数学上和算法上都是精确的。\n- **客观的**：该问题以客观的数学语言陈述，没有歧义或主观内容。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个计算物理学中自洽、科学上合理且适定的问题。将构建一个解决方案。\n\n---\n\n### 第 1 部分：序参量张量 $\\mathbf{Q}$ 的推导\n\n目标是构建一个对称、无迹的二阶张量 $\\mathbf{Q}$ 来量化取向序。它必须由具有物理意义的二阶矩张量 $\\mathbf{M} = \\langle \\mathbf{u} \\mathbf{u}^{\\mathsf{T}} \\rangle$ 和单位张量 $\\mathbf{I}$ 构成，因为这是在样本坐标系的全局旋转下保持不变的仅有的可用二阶张量。\n\n因此，$\\mathbf{Q}$ 必须是 $\\mathbf{M}$ 和 $\\mathbf{I}$ 的线性组合：\n$$\n\\mathbf{Q} = a\\mathbf{M} + b\\mathbf{I}\n$$\n其中 $a$ 和 $b$ 是标量常数。\n\n张量 $\\mathbf{Q}$ 必须是无迹的，即 $\\mathrm{Tr}(\\mathbf{Q}) = 0$。我们计算其迹：\n$$\n\\mathrm{Tr}(\\mathbf{Q}) = \\mathrm{Tr}(a\\mathbf{M} + b\\mathbf{I}) = a\\mathrm{Tr}(\\mathbf{M}) + b\\mathrm{Tr}(\\mathbf{I})\n$$\n在三维空间中，单位张量的迹是 $\\mathrm{Tr}(\\mathbf{I}) = 3$。二阶矩张量的迹是：\n$$\n\\mathrm{Tr}(\\mathbf{M}) = \\mathrm{Tr}(\\langle \\mathbf{u} \\mathbf{u}^{\\mathsf{T}} \\rangle) = \\langle \\mathrm{Tr}(\\mathbf{u} \\mathbf{u}^{\\mathsf{T}}) \\rangle\n$$\n并矢积 $\\mathbf{u} \\mathbf{u}^{\\mathsf{T}}$ 的迹是 $\\mathrm{Tr}(\\mathbf{u} \\mathbf{u}^{\\mathsf{T}}) = \\mathbf{u}^{\\mathsf{T}}\\mathbf{u} = \\|\\mathbf{u}\\|^2$。由于 $\\mathbf{u}$ 是单位向量，$\\|\\mathbf{u}\\|^2 = 1$。因此，$\\mathrm{Tr}(\\mathbf{M}) = \\langle 1 \\rangle = 1$。\n\n无迹条件变为：\n$$\na(1) + b(3) = 0 \\implies b = -\\frac{a}{3}\n$$\n将此代入 $\\mathbf{Q}$ 的表达式，我们得到 $\\mathbf{Q}$ 的形式，仅差一个标量因子 $a$：\n$$\n\\mathbf{Q} = a\\mathbf{M} - \\frac{a}{3}\\mathbf{I} = a \\left( \\mathbf{M} - \\frac{1}{3}\\mathbf{I} \\right)\n$$\n为了确定常数 $a$，我们应用完美单轴排列状态的归一化条件。在这种状态下，所有取向向量都相同，即对所有 $i$ 都有 $\\mathbf{u}_i = \\mathbf{n}$，其中 $\\mathbf{n}$ 是一个单位向量。二阶矩张量为：\n$$\n\\mathbf{M} = \\langle \\mathbf{n} \\mathbf{n}^{\\mathsf{T}} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{n} \\mathbf{n}^{\\mathsf{T}} = \\mathbf{n} \\mathbf{n}^{\\mathsf{T}}\n$$\n将此代入 $\\mathbf{Q}$ 的表达式：\n$$\n\\mathbf{Q} = a \\left( \\mathbf{n} \\mathbf{n}^{\\mathsf{T}} - \\frac{1}{3}\\mathbf{I} \\right)\n$$\n我们求这个张量的特征值。向量 $\\mathbf{n}$ 是一个特征向量：\n$$\n\\mathbf{Q}\\mathbf{n} = a \\left( \\mathbf{n} \\mathbf{n}^{\\mathsf{T}} \\mathbf{n} - \\frac{1}{3}\\mathbf{I}\\mathbf{n} \\right) = a \\left( \\mathbf{n}(\\mathbf{n}^{\\mathsf{T}}\\mathbf{n}) - \\frac{1}{3}\\mathbf{n} \\right) = a \\left( \\mathbf{n} - \\frac{1}{3}\\mathbf{n} \\right) = \\frac{2a}{3}\\mathbf{n}\n$$\n相应的特征值为 $\\lambda_1 = \\frac{2a}{3}$。任何与 $\\mathbf{n}$ 正交的向量 $\\mathbf{v}$（即 $\\mathbf{n} \\cdot \\mathbf{v}=0$）也是一个特征向量：\n$$\n\\mathbf{Q}\\mathbf{v} = a \\left( \\mathbf{n} \\mathbf{n}^{\\mathsf{T}} \\mathbf{v} - \\frac{1}{3}\\mathbf{I}\\mathbf{v} \\right) = a \\left( \\mathbf{n}(\\mathbf{n}^{\\mathsf{T}}\\mathbf{v}) - \\frac{1}{3}\\mathbf{v} \\right) = a \\left( \\mathbf{0} - \\frac{1}{3}\\mathbf{v} \\right) = -\\frac{a}{3}\\mathbf{v}\n$$\n另外两个特征值是简并的：$\\lambda_{2,3} = -\\frac{a}{3}$。最大特征值是 $\\lambda_1 = \\frac{2a}{3}$。归一化要求它为 $1$：\n$$\n\\frac{2a}{3} = 1 \\implies a = \\frac{3}{2}\n$$\n因此，满足给定原理的唯一张量 $\\mathbf{Q}$ 是：\n$$\n\\mathbf{Q} = \\frac{3}{2} \\left( \\mathbf{M} - \\frac{1}{3}\\mathbf{I} \\right) = \\frac{3}{2}\\mathbf{M} - \\frac{1}{2}\\mathbf{I}\n$$\n对于一个包含 $N_{eff}$ 个非零向量 $\\{\\mathbf{v}_i\\}$ 的离散集，我们首先将它们归一化得到 $\\{\\mathbf{u}_i\\}$。矩张量为 $\\mathbf{M} = \\frac{1}{N_{eff}} \\sum_{i=1}^{N_{eff}} \\mathbf{u}_i \\mathbf{u}_i^{\\mathsf{T}}$。$\\mathbf{Q}$ 的显式表达式为：\n$$\n\\mathbf{Q} = \\frac{3}{2} \\left( \\left( \\frac{1}{N_{eff}} \\sum_{i=1}^{N_{eff}} \\mathbf{u}_i \\mathbf{u}_i^{\\mathsf{T}} \\right) - \\frac{1}{3}\\mathbf{I} \\right)\n$$\n最后，对于完全各向同性的状态，$\\langle u_\\alpha u_\\beta \\rangle = \\frac{1}{3}\\delta_{\\alpha\\beta}$，所以 $\\mathbf{M}_{\\text{iso}} = \\frac{1}{3}\\mathbf{I}$。这得到 $\\mathbf{Q} = \\frac{3}{2}(\\frac{1}{3}\\mathbf{I} - \\frac{1}{3}\\mathbf{I}) = \\mathbf{0}$，符合要求。\n\n### 第 2 部分：性质证明\n\n1.  **对称性**：$\\mathbf{M}$ 是对称矩阵 $\\mathbf{u}_i \\mathbf{u}_i^{\\mathsf{T}}$ 的和，因此它是对称的。$\\mathbf{I}$ 是对称的。因此，作为 $\\mathbf{M}$ 和 $\\mathbf{I}$ 的线性组合，$\\mathbf{Q}$ 也是对称的。\n2.  **无迹性**：如推导中所示，$\\mathrm{Tr}(\\mathbf{M})=1$ 且 $\\mathrm{Tr}(\\mathbf{I})=3$。\n    $$\n    \\mathrm{Tr}(\\mathbf{Q}) = \\mathrm{Tr}\\left(\\frac{3}{2}\\mathbf{M} - \\frac{1}{2}\\mathbf{I}\\right) = \\frac{3}{2}\\mathrm{Tr}(\\mathbf{M}) - \\frac{1}{2}\\mathrm{Tr}(\\mathbf{I}) = \\frac{3}{2}(1) - \\frac{1}{2}(3) = 0\n    $$\n    此性质对任何分布都成立。\n3.  **特征值边界**：设 $\\mathbf{Q}$ 的特征值为 $q_1, q_2, q_3$ 且 $q_1 \\ge q_2 \\ge q_3$。最大特征值为 $S = q_1$。$\\mathbf{Q}$ 的特征值与 $\\mathbf{M}$ 的特征值 $m_1 \\ge m_2 \\ge m_3$ 通过 $q_j = \\frac{3}{2}(m_j - \\frac{1}{3})$ 相关联。\n    矩阵 $\\mathbf{M} = \\langle \\mathbf{u}\\mathbf{u}^{\\mathsf{T}} \\rangle$ 是半正定矩阵的平均值，因此它本身也是半正定的。其特征值因此为非负值，$m_j \\ge 0$。\n    迹条件 $\\mathrm{Tr}(\\mathbf{M})=1$ 意味着 $m_1+m_2+m_3=1$。\n    为了找到 $S = q_1 = \\frac{3}{2}(m_1 - \\frac{1}{3})$ 的边界，我们必须找到 $m_1$ 的边界。\n    -   **上界**：$m_1 = \\max_{\\|\\mathbf{x}\\|=1} \\mathbf{x}^{\\mathsf{T}}\\mathbf{M}\\mathbf{x} = \\max_{\\|\\mathbf{x}\\|=1} \\langle (\\mathbf{x} \\cdot \\mathbf{u})^2 \\rangle$。由于 $(\\mathbf{x} \\cdot \\mathbf{u})^2 \\le \\|\\mathbf{x}\\|^2 \\|\\mathbf{u}\\|^2 = 1$，我们有 $m_1 \\le \\langle 1 \\rangle = 1$。最大值 $m_1=1$ 在完美排列时达到，此时 $m_1=1, m_2=m_3=0$。这得到 $S = \\frac{3}{2}(1 - \\frac{1}{3}) = 1$。\n    -   **下界**：由于 $m_1$ 是三个总和为 $1$ 的非负数中最大的一个，必须有 $m_1 \\ge \\frac{1}{3}$。这个最小值在各向同性情况下达到，此时 $m_1=m_2=m_3=\\frac{1}{3}$。这得到 $S = \\frac{3}{2}(\\frac{1}{3} - \\frac{1}{3}) = 0$。\n    因此，最大特征值 $S$ 总是在区间 $[0, 1]$ 内。问题陈述声称 $S \\in [-\\frac{1}{2}, 1]$，这是一个数学上正确但更宽松的超集，包含了紧密边界。$\\mathbf{Q}$ 的完整特征值谱位于 $[-\\frac{1}{2}, 1]$ 内，因为最小特征值 $q_3 = \\frac{3}{2}(m_3 - \\frac{1}{3})$ 受 $0 \\le m_3 \\le 1/3$ 限制，这导致 $q_3 \\in [-\\frac{1}{2}, 0]$。\n\n### 第 3 部分：算法设计\n\n该算法从向量列表 $\\{\\mathbf{v}_i\\}$ 计算标量序参量 $S$ 和指向矢 $\\mathbf{n}$。\n\n1.  **输入**：$N$ 个向量的列表 $\\{\\mathbf{v}_i\\} \\subset \\mathbb{R}^3$。\n2.  **容差**：设 $\\epsilon = 10^{-8}$ 为用于符号约定的平均取向向量范数的容差。设 $\\delta = 10^{-8}$ 为用于判断特征值是否为零的容差。设 $10^{-12}$ 为判断向量范数是否为非零的阈值。这些值适用于标准的双精度浮点运算。\n3.  **归一化**：遍历输入向量 $\\{\\mathbf{v}_i\\}$。对每个向量，计算其范数 $\\|\\mathbf{v}_i\\|$。如果范数大于 $10^{-12}$，则将向量归一化得到 $\\mathbf{u}_i = \\mathbf{v}_i/\\|\\mathbf{v}_i\\|$，并将其添加到一个有效向量列表中。设这些向量的数量为 $N_{eff}$。如果 $N_{eff}=0$，系统未定义；按照约定，我们返回各向同性的结果 $S=0$ 和 $\\mathbf{n}=(0,0,1)$。\n4.  **二阶矩张量 $\\mathbf{M}$**：计算 $3 \\times 3$ 矩阵 $\\mathbf{M}$，作为归一化向量并矢积的样本平均值：\n    $$\n    \\mathbf{M} = \\frac{1}{N_{eff}} \\sum_{i=1}^{N_{eff}} \\mathbf{u}_i \\mathbf{u}_i^{\\mathsf{T}}\n    $$\n    这可以高效地计算为 $(\\mathbf{U}^{\\mathsf{T}}\\mathbf{U})/N_{eff}$，其中 $\\mathbf{U}$ 是一个 $N_{eff} \\times 3$ 的矩阵，其行是向量 $\\mathbf{u}_i^{\\mathsf{T}}$。\n5.  **序参量张量 $\\mathbf{Q}$**：使用推导出的公式构造 $\\mathbf{Q}$：\n    $$\n    \\mathbf{Q} = \\frac{3}{2}\\left(\\mathbf{M} - \\frac{1}{3}\\mathbf{I}\\right)\n    $$\n6.  **特征分解**：由于 $\\mathbf{Q}$ 是一个实对称矩阵，使用专门的数值程序（如 `numpy.linalg.eigh`）来找到其实特征值和正交特征向量。该程序通常按升序返回排序的特征值，并将相应的特征向量作为矩阵的列。\n7.  **处理各向同性情况**：检查所有特征值的最大绝对值是否小于容差 $\\delta$。如果是，则认为系统是各向同性的。返回 $S=0$ 和约定的指向矢 $\\mathbf{n}=(0,0,1)$。\n8.  **提取 $S$ 和 $\\mathbf{n}$**：最大特征值是 $S$。相应的特征向量是指向矢 $\\mathbf{n}$。\n9.  **符号约定**：为解决 $\\mathbf{n} \\leftrightarrow -\\mathbf{n}$ 的模糊性，应用一个确定性约定。\n    a. 计算平均取向向量 $\\bar{\\mathbf{u}} = \\frac{1}{N_{eff}} \\sum_{i=1}^{N_{eff}} \\mathbf{u}_i$。\n    b. 如果 $\\|\\bar{\\mathbf{u}}\\|  \\epsilon$，则样本具有净极性。选择 $\\mathbf{n}$ 的符号，使其在平均取向上的投影为非负：如果 $\\mathbf{n} \\cdot \\bar{\\mathbf{u}}  0$，则将 $\\mathbf{n}$ 替换为 $-\\mathbf{n}$。\n    c. 如果 $\\|\\bar{\\mathbf{u}}\\| \\le \\epsilon$，则样本是无极性的或近各向同性的。选择 $\\mathbf{n}$ 的符号，使其绝对值最大的分量为非负。找到索引 $k$ 使得 $|n_k|$ 最大；如果 $n_k  0$，则将 $\\mathbf{n}$ 替换为 $-\\mathbf{n}$。\n10. **输出**：返回标量 $S$ 和指向矢 $\\mathbf{n}$ 的分量。\n\n该过程是鲁棒的、数值稳定的，并正确地实现了物理原理和问题要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_order_parameter(vectors: np.ndarray, epsilon: float = 1e-8, delta: float = 1e-8) - list[float]:\n    \"\"\"\n    Calculates the nematic order parameter S and director n from a set of 3D vectors.\n\n    Args:\n        vectors: An (N, 3) numpy array of orientation vectors.\n        epsilon: Tolerance for determining if the mean orientation vector is non-zero.\n        delta: Tolerance for determining if eigenvalues are zero (isotropic case).\n\n    Returns:\n        A list [S, nx, ny, nz] with values rounded to 6 decimal places.\n    \"\"\"\n    # Step 1: Normalize vectors, ignoring zero-norm vectors.\n    norms = np.linalg.norm(vectors, axis=1)\n    non_zero_indices = np.where(norms  1e-12)[0]\n    \n    if len(non_zero_indices) == 0:\n        # If no valid vectors, return the isotropic state by convention.\n        return [0.0, 0.0, 0.0, 1.0]\n\n    unit_vectors = vectors[non_zero_indices] / norms[non_zero_indices, np.newaxis]\n    n_eff = len(unit_vectors)\n\n    # Step 2: Compute the second moment tensor M.\n    # M = (1/n_eff) * sum(u_i @ u_i.T) which is equivalent to U.T @ U / n_eff\n    M = np.dot(unit_vectors.T, unit_vectors) / n_eff\n    \n    # Step 3: Construct the order parameter tensor Q.\n    I = np.identity(3)\n    Q = 1.5 * (M - (1./3.) * I)\n\n    # Step 4: Perform eigendecomposition of the symmetric matrix Q.\n    # np.linalg.eigh returns eigenvalues in ascending order.\n    eigvals, eigvecs = np.linalg.eigh(Q)\n\n    # Step 5: Handle the nearly isotropic case.\n    if np.max(np.abs(eigvals))  delta:\n        return [0.0, 0.0, 0.0, 1.0]\n\n    # Step 6: Extract the largest eigenvalue S and corresponding eigenvector n.\n    S = eigvals[2]\n    n = eigvecs[:, 2]\n\n    # Step 7: Apply the deterministic sign convention for the director n.\n    mean_u = np.mean(unit_vectors, axis=0)\n    norm_mean_u = np.linalg.norm(mean_u)\n\n    if norm_mean_u  epsilon:\n        # Orient n to have a positive projection on the mean orientation vector.\n        if np.dot(n, mean_u)  0:\n            n = -n\n    else:\n        # For apolar/isotropic data, orient n so its largest component is non-negative.\n        max_abs_idx = np.argmax(np.abs(n))\n        if n[max_abs_idx]  0:\n            n = -n\n            \n    # Step 8: Return the final results, rounded to 6 decimal places.\n    return [round(S, 6), round(n[0], 6), round(n[1], 6), round(n[2], 6)]\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the calculation for each case, and prints the final output.\n    \"\"\"\n    test_cases_raw = [\n        # Test case A: Uniaxial alignment with small perturbations about z-axis\n        [(0,0,1), (0,0,1), (0,0,1), (0.1,0, np.sqrt(1-0.1**2)), (-0.1,0.05,np.sqrt(1-0.1**2-0.05**2)), (0.05,-0.02,np.sqrt(1-0.05**2-0.02**2))],\n        # Test case B: Exactly isotropic on Cartesian axes\n        [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)],\n        # Test case C: Planar bias in xy-plane with dominance along x-axis\n        [(1,0,0), (-1,0,0), (1,0.1,0), (0,1,0), (0,-1,0), (0.7,0.7,0)],\n        # Test case D: Antiparallel pairs about a common director near (1,1,1)\n        [(1,1,1), (-1,-1,-1), (0.9,1.1,1.0), (-0.9,-1.1,-1.0)],\n        # Test case E: Single-vector boundary case\n        [(0.3, -0.4, 0.8660254)]\n    ]\n\n    test_cases = [np.array(case, dtype=float) for case in test_cases_raw]\n    \n    results = []\n    for case in test_cases:\n        result = calculate_order_parameter(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python list is already in the correct format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2932989"}, {"introduction": "虽然实验和模拟提供的是离散数据，但理论模型通常使用连续的分布函数来描述取向序。本练习介绍了一种强大的数值方法——高斯-勒让德求积法，用以从这类函数中精确计算序参量，展示了如何以计算方式处理理论预测[@problem_id:2933036]。", "problem": "设计并实现一个完整的数值方案，以使用高斯-勒让德积分法计算单轴体系中的取向序参数。设取向序参数定义为积分\n$$\nS = \\int_{0}^{\\pi} P_{2}(\\cos \\theta)\\, f(\\theta)\\, \\sin \\theta \\, d\\theta,\n$$\n其中 $P_{2}$ 是2次勒让德多项式，$f(\\theta)$ 是关于极角的非负取向分布。所有角度均以弧度为单位。该方案必须满足以下要求。\n\n1. 使用的数学基础：\n   - 变量代换 $x = \\cos \\theta$，得到 $dx = -\\sin \\theta \\, d\\theta$，从而\n     $$\n     S = \\int_{-1}^{1} P_{2}(x)\\, f(\\arccos x)\\, dx.\n     $$\n   - 勒让德多项式 $P_{2}(x)$ 定义为 $P_{2}(x) = \\tfrac{1}{2}(3x^{2}-1)$。\n   - 在 $[-1,1]$ 上的 $N$ 点高斯-勒让德积分法可以精确地对任何次数至多为 $2N-1$ 的多项式进行积分。\n\n2. 数值设计目标：\n   - 为被积函数 $h(x) = P_{2}(x)\\, f(\\arccos x)$ 在 $[-1,1]$ 上构造一个 $N$ 节点的高斯-勒让德积分法。\n   - 为每次使用 $N$ 个节点的计算，提供一个随 $N$ 变化的后验误差界。为此，使用节点倍增策略：\n     - 计算 $S_{N}$、$S_{2N}$ 和 $S_{4N}$。\n     - 定义 $\\Delta_{1} = |S_{2N} - S_{N}|$ 和 $\\Delta_{2} = |S_{4N} - S_{2N}|$。\n     - 如果 $\\Delta_{1} = \\Delta_{2} = 0$，则设置界 $B_{N} = 0$。\n     - 否则，如果 $\\Delta_{1}  0$，定义比率 $R = \\Delta_{2}/\\Delta_{1}$。如果 $0 \\le R  1$，则设置\n       $$\n       B_{N} = \\frac{\\Delta_{1}}{1 - R}。\n       $$\n       如果 $R \\ge 1$ 或 $\\Delta_{1} = 0$，则使用保守选择 $B_{N} = \\max\\{\\Delta_{1},\\Delta_{2}\\}$。\n     这提供了一个可计算的界，对于解析函数 $h(x)$，该界随 $N$ 呈几何级数变化。\n\n3. 测试套件和输入：\n   - 使用以下测试用例。在所有情况下，使用所述方案评估 $S$，并以浮点数形式返回数对 $[S_{N}, B_{N}]$。\n     - 用例 A (边界欠解析)：$f(\\theta) = 1$，$N = 1$。\n     - 用例 B (最小次数下的精确性)：$f(\\theta) = 1$，$N = 2$。\n     - 用例 C (多项式扰动的各向同性)：$f(\\theta) = 1 + \\alpha P_{2}(\\cos \\theta)$，其中 $\\alpha = 0.6$，$N = 3$。\n     - 用例 D (类 Maier–Saupe 偶函数分布，中度取向)：$f(\\theta) = C(\\kappa)\\, \\exp(\\kappa \\cos^{2}\\theta)$，其中 $\\kappa = 5.0$，$C(\\kappa)$ 强制执行归一化\n       $$\n       \\int_{0}^{\\pi} f(\\theta)\\, \\sin \\theta \\, d\\theta = 2.\n       $$\n       证明该归一化意味着\n       $$\n       C(\\kappa) = \\frac{2}{\\int_{-1}^{1} e^{\\kappa x^{2}}\\, dx} = \\frac{2\\sqrt{\\kappa}}{\\sqrt{\\pi}\\, \\operatorname{erfi}(\\sqrt{\\kappa})},\n       $$\n       其中 $\\operatorname{erfi}$ 是虚误差函数。使用 $N = 8$。\n     - 用例 E (类 Maier–Saupe 偶函数分布，强取向)：与用例 D 相同，但 $\\kappa = 20.0$ 且 $N = 12$。\n\n4. 输出要求：\n   - 角度单位为弧度。\n   - 所有输出均为无量纲浮点数。\n   - 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个测试用例对应一个双元素列表 $[S_{N}, B_{N}]$。例如，最终输出必须如下所示\n     $$\n     [[s_{A},b_{A}],[s_{B},b_{B}],[s_{C},b_{C}],[s_{D},b_{D}],[s_{E},b_{E}]].\n     $$\n     不得包含任何额外文本。\n\n目标是从基本的变量代换和高斯-勒让德积分法的定义性质出发，推导出一个有原则的算法，并实现该算法，使其既能返回数值估计值，也能返回一个随节点数增加而减小的、可靠且可计算的界。该界应仅根据所指定的 $S_{N}$、$S_{2N}$ 和 $S_{4N}$ 值构建。关注科学真实性：确保 $f(\\theta)$ 是非负的，对于指数函数的情况，使用上面给出的精确归一化常数 $C(\\kappa)$。所有计算都是无量纲的。角度单位为弧度。要求的最终输出是包含五个按 A 到 E 顺序排列的 $[S_{N}, B_{N}]$ 数对的单行 Python 列表。", "solution": "我们从聚合物和软凝聚态物质中使用的取向平均定义开始：对于一个仅依赖于极角 $\\theta$ 的单轴分布，取向序参数是2次勒让德多项式 $P_{2}(\\cos \\theta)$ 在单位球面上相对于面积元、对分布 $f(\\theta)$ 所作的平均。对于任何方位角对称的 $f(\\theta)$，这可以简化为一维积分\n$$\nS = \\int_{0}^{\\pi} P_{2}(\\cos \\theta)\\, f(\\theta)\\, \\sin \\theta \\, d\\theta,\n$$\n其中所有量均为无量纲，角度以弧度计量。\n\n步骤 1：变换到标准区间。引入变量代换 $x = \\cos \\theta$，得到 $dx = -\\sin \\theta\\, d\\theta$，并将 $\\theta \\in [0,\\pi]$ 映射到 $x \\in [1,-1]$。因此，\n$$\nS = \\int_{0}^{\\pi} P_{2}(\\cos \\theta)\\, f(\\theta)\\, \\sin \\theta \\, d\\theta\n= \\int_{1}^{-1} P_{2}(x) \\, f(\\arccos x)\\, (-dx)\n= \\int_{-1}^{1} P_{2}(x)\\, f(\\arccos x)\\, dx.\n$$\n将 $[-1,1]$ 上的被积函数定义为\n$$\nh(x) = P_{2}(x)\\, g(x), \\quad \\text{其中} \\quad g(x) = f(\\arccos x).\n$$\n勒让德多项式为 $P_{2}(x) = \\tfrac{1}{2}(3x^{2} - 1)$。这将问题转化为在标准区间 $[-1,1]$ 上对光滑函数 $h(x)$ 进行积分。\n\n步骤 2：高斯-勒让德积分法。在 $[-1,1]$ 上的 $N$ 点高斯-勒让德积分法提供了节点 $\\{x_{i}\\}_{i=1}^{N}$ 和权重 $\\{w_{i}\\}_{i=1}^{N}$，可以精确地对任何次数至多为 $2N-1$ 的多项式进行积分。积分近似值为\n$$\nS_{N} = \\sum_{i=1}^{N} w_{i}\\, h(x_{i}) = \\sum_{i=1}^{N} w_{i}\\, P_{2}(x_{i})\\, g(x_{i}).\n$$\n特别地，如果 $h(x)$ 是一个次数至多为 $2N-1$ 的多项式，那么 $S_{N} = S$。\n\n步骤 3：误差行为和可计算的界。对于在 $[-1,1]$ 上足够光滑（例如，解析）的函数 $h(x)$，高斯-勒让德积分法的误差随 $N$ 快速衰减；对于解析函数，由于其在 Bernstein 椭圆内的解析性，误差随 $N$ 呈几何级数衰减。虽然精确常数取决于解析延拓，但可以利用预期的几何衰减特性，通过节点倍增策略推导出一个实用且可计算的后验界。计算三个近似值：\n$$\nS_{N}, \\quad S_{2N}, \\quad S_{4N}.\n$$\n定义差值\n$$\n\\Delta_{1} = |S_{2N} - S_{N}|, \\qquad \\Delta_{2} = |S_{4N} - S_{2N}|.\n$$\n如果误差随 $N$ 的变化近似呈几何级数（这对于解析函数 $h(x)$ 是有保证的），那么比率 $R = \\Delta_{2}/\\Delta_{1}$ 可以估计尾部的收缩因子。$N$ 节点近似误差的一个保守界是\n$$\nB_{N} =\n\\begin{cases}\n0,  \\text{如果 } \\Delta_{1} = \\Delta_{2} = 0,\\\\\n\\dfrac{\\Delta_{1}}{1 - R},  \\text{如果 } 0 \\le R  1,\\\\\n\\max\\{\\Delta_{1},\\Delta_{2}\\},  \\text{其他情况。}\n\\end{cases}\n$$\n这个界可以从 $S_{N}$、$S_{2N}$ 和 $S_{4N}$ 计算得出，并且随 $N$ 变化；对于解析函数 $h(x)$，$R$ 随着 $N$ 的增大而迅速减小，从而使 $B_{N}$ 变小。在退化的精确情况下（$\\Delta_{1}=\\Delta_{2}=0$），界为 $0$。\n\n步骤 4：测试函数和归一化。我们考虑五个用例：\n- 用例 A 和用例 B：$f(\\theta) = 1$。则 $g(x) = 1$ 且 $h(x) = P_{2}(x)$。由于 $\\int_{-1}^{1} P_{2}(x)\\, dx = 0$，精确值为 $S = 0$。使用 $N=2$ 的高斯-勒让德积分法可以精确地积分 2 次多项式，因此 $S_{2} = 0$。当 $N=1$ 时，积分法是欠解析的，会产生一个非零的 $S_{1}$；从 $S_{1}$、$S_{2}$、$S_{4}$ 构建的后验界可以恢复一个有限的误差界。\n- 用例 C：$f(\\theta) = 1 + \\alpha P_{2}(\\cos \\theta)$，其中 $\\alpha = 0.6$。则 $g(x) = 1 + \\alpha P_{2}(x)$ 且 $h(x) = P_{2}(x) + \\alpha P_{2}(x)^{2}$ 是一个 4 次多项式。对于 $N=3$，次数最高为 $2N-1 = 5$ 的多项式可以被精确积分，因此 $S_{3} = S$。勒让德多项式的正交性意味着\n$$\nS = \\int_{-1}^{1} P_{2}(x)\\, \\bigl[1 + \\alpha P_{2}(x)\\bigr]\\, dx\n= \\alpha \\int_{-1}^{1} P_{2}(x)^{2}\\, dx\n= \\alpha \\,\\frac{2}{2\\cdot 2 + 1} = \\alpha \\cdot \\frac{2}{5} = 0.24.\n$$\n- 用例 D 和用例 E：$f(\\theta) = C(\\kappa)\\, e^{\\kappa \\cos^{2}\\theta}$，其中 $\\kappa \\in \\{5.0, 20.0\\}$。这是一个偶函数、方位角对称的分布。我们施加物理归一化条件\n$$\n\\int_{0}^{\\pi} f(\\theta)\\, \\sin \\theta \\, d\\theta = 2\n\\quad \\Longleftrightarrow \\quad\n\\int_{-1}^{1} g(x)\\, dx = 2,\n$$\n这就得到\n$$\nC(\\kappa) = \\frac{2}{\\int_{-1}^{1} e^{\\kappa x^{2}}\\, dx}\n= \\frac{2\\sqrt{\\kappa}}{\\sqrt{\\pi}\\, \\operatorname{erfi}(\\sqrt{\\kappa})}.\n$$\n因此 $g(x) = C(\\kappa)\\, e^{\\kappa x^{2}}$ 且 $h(x) = P_{2}(x)\\, C(\\kappa)\\, e^{\\kappa x^{2}}$。被积函数在 $x$ 上是整函数，因此高斯-勒让德积分误差随 $N$ 快速衰减。节点倍增估计器提供了一个随 $N$ 变化的、可计算的界。\n\n步骤 5：算法实现。\n- 使用一个高斯-勒让德程序来获取 $[-1,1]$ 上用于 $N$、$2N$ 和 $4N$ 的节点和权重。\n- 对每个测试用例，如上所述定义 $g(x)$（对于指数情况，使用虚误差函数计算 $C(\\kappa)$ 以实现精确归一化）。\n- 通过求和 $w_{i}\\, P_{2}(x_{i})\\, g(x_{i})$ 来计算 $S_{N}$、$S_{2N}$ 和 $S_{4N}$。\n- 按照定义构造 $\\Delta_{1}$、$\\Delta_{2}$ 和 $B_{N}$。\n- 按 A 到 E 的顺序为每个用例返回 $[S_{N}, B_{N}]$。\n\n步骤 6：输出格式。生成单行输出，包含一个有五个条目的 Python 列表，每个条目是一个双元素列表 $[S_{N}, B_{N}]$，即，\n$$\n[[S_{A},B_{A}],[S_{B},B_{B}],[S_{C},B_{C}],[S_{D},B_{D}],[S_{E},B_{E}]].\n$$\n\n此过程遵循了基本的变量代换，利用了高斯-勒让德积分法对多项式的定义最优性，并基于几何衰减特性构造了一个误差界，该误差界仅能从嵌套的积分序列中计算得出。对于基于多项式的用例 B 和 C，在指定的 $N$ 值下即可达到精确性，从而产生零误差和零界。对于指数情况， $h(x)$ 的解析性保证了快速收敛，并随着 $N$ 的增加，误差界也相应地变小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfi\n\ndef legendre_P2(x):\n    # P2(x) = (3x^2 - 1)/2\n    return 0.5 * (3.0 * x * x - 1.0)\n\ndef gauss_legendre_integral_of_h(g_func, N):\n    # Compute integral of h(x) = P2(x) * g(x) over [-1,1] using N-point Gauss–Legendre\n    x, w = np.polynomial.legendre.leggauss(N)\n    h_vals = legendre_P2(x) * g_func(x)\n    return np.dot(w, h_vals)\n\ndef normalization_constant_for_exp_kappa(kappa):\n    # Exact normalization constant C(kappa) = 2 / ∫_{-1}^{1} e^{kappa x^2} dx\n    # Integral equals sqrt(pi)/sqrt(kappa) * erfi(sqrt(kappa))\n    sqrt_k = np.sqrt(kappa)\n    integral = np.sqrt(np.pi) / sqrt_k * erfi(sqrt_k)\n    return 2.0 / integral\n\ndef error_bound_doubling(SN, S2N, S4N):\n    d1 = abs(S2N - SN)\n    d2 = abs(S4N - S2N)\n    # Exact or numerically exact case\n    if d1 == 0.0 and d2 == 0.0:\n        return 0.0\n    if d1  0.0:\n        R = d2 / d1\n        if R  1.0:\n            # Geometric a posteriori bound for |S - S_N|\n            return d1 / (1.0 - R)\n    # Fallback conservative choice\n    return max(d1, d2)\n\ndef solve():\n    # Define g(x) for each test case\n    # Case A: f(theta) = 1, N = 1\n    def g_case_A(x):\n        return np.ones_like(x)\n    N_A = 1\n\n    # Case B: f(theta) = 1, N = 2\n    def g_case_B(x):\n        return np.ones_like(x)\n    N_B = 2\n\n    # Case C: f(theta) = 1 + alpha * P2(cos theta), alpha = 0.6, N = 3\n    alpha_C = 0.6\n    def g_case_C(x):\n        return 1.0 + alpha_C * legendre_P2(x)\n    N_C = 3\n\n    # Case D: f(theta) = C(kappa) * exp(kappa * cos^2 theta), kappa = 5.0, N = 8\n    kappa_D = 5.0\n    C_D = normalization_constant_for_exp_kappa(kappa_D)\n    def g_case_D(x):\n        return C_D * np.exp(kappa_D * x * x)\n    N_D = 8\n\n    # Case E: f(theta) = C(kappa) * exp(kappa * cos^2 theta), kappa = 20.0, N = 12\n    kappa_E = 20.0\n    C_E = normalization_constant_for_exp_kappa(kappa_E)\n    def g_case_E(x):\n        return C_E * np.exp(kappa_E * x * x)\n    N_E = 12\n\n    test_cases = [\n        (g_case_A, N_A),\n        (g_case_B, N_B),\n        (g_case_C, N_C),\n        (g_case_D, N_D),\n        (g_case_E, N_E),\n    ]\n\n    results = []\n    for g_func, N in test_cases:\n        SN = gauss_legendre_integral_of_h(g_func, N)\n        S2N = gauss_legendre_integral_of_h(g_func, 2 * N)\n        S4N = gauss_legendre_integral_of_h(g_func, 4 * N)\n        bound = error_bound_doubling(SN, S2N, S4N)\n        results.append([float(SN), float(bound)])\n\n    # Final print statement in the exact required format.\n    # Print as a single line Python-list-like representation.\n    def fmt_pair(p):\n        # Use repr-like formatting with sufficient precision\n        return f\"[{p[0]:.16g},{p[1]:.16g}]\"\n    print(\"[\" + \",\".join(fmt_pair(p) for p in results) + \"]\")\n\nsolve()\n```", "id": "2933036"}, {"introduction": "数值模拟或近似的理论模型有时可能会产生在数学上有效但在物理上不切实际的序参量张量，其违反了对其本征值的基本界限。这个高级练习通过开发一种算法，将任意对称无迹张量“投影”到物理上允许的序参量张量空间中，从而解决了这个关键问题。这是确保理论和计算结果物理一致性的重要步骤[@problem_id:2933004]。", "problem": "考虑三维向列聚合物或液晶中的取向序参数张量。根据定义，取向序参数张量由单位向量的概率分布构建而成，并且是对称无迹的。从取向序参数张量是单位向量的并矢积减去各向同性部分的平均值这一基本统计力学定义出发，仅使用线性代数和凸优化的基本事实，您的任务是推导并实现一个任意对称无迹矩阵到物理上允许的取向序参数张量集合上的投影（关于 Frobenius 范数）。\n\n要求和设置：\n- 令 $\\mathbb{S}_{0}^{3}$ 表示实 $3 \\times 3$ 对称无迹矩阵的集合。矩阵 $A$ 的 Frobenius 范数为 $\\lVert A \\rVert_{\\mathrm{F}} = \\sqrt{\\mathrm{tr}(A^{\\mathsf{T}}A)}$。\n- 在维度 3 中，物理上允许的取向序参数张量 $Q$ 的集合是 $\\mathbb{S}_{0}^{3}$ 的一个子集，其特征值位于区间 $[-1/2,1]$ 内。\n- 给定任意 $A \\in \\mathbb{S}_{0}^{3}$，定义投影问题为在物理上允许的集合上找到一个 $Q^{\\star}$，使其到 $A$ 的 Frobenius 距离最小化。\n\n任务：\n1. 从取向序参数张量的统计定义（即单位向量并矢积减去各向同性部分的平均值）出发，利用对于任意单位向量 $\\mathbf{u}$ 和 $\\mathbf{n}$ 都有 $(\\mathbf{u}\\cdot\\mathbf{n})^{2} \\in [0,1]$ 以及 Frobenius 范数具有正交不变性这两个事实，来确定任何物理 $Q$ 张量的特征值界限，并将投影问题简化为特征值空间中的问题。\n2. 仅使用线性代数和凸优化的一般原理，证明最小化子 $Q^{\\star}$ 与 $A$ 具有相同的特征向量，并且在所有和为零的 $[-1/2,1]^{3}$ 向量中，其特征值（在欧几里得意义上）最接近 $A$ 的特征值。您的证明不能假设优化子的目标公式，也不能提供任何捷径表达式。它必须从第一性原理（谱定理、Frobenius 范数的不变性以及充要最优性条件）进行推理。\n3. 设计一个算法，用于计算任意给定 $A \\in \\mathbb{S}_{0}^{3}$ 的投影 $Q^{\\star}$。该算法的陈述应足够精确以便于实现，并且必须对 $\\mathbb{S}_{0}^{3}$ 中的所有输入都是正确的。它应在有限时间内运行并以唯一答案终止。\n\n编程任务：\n- 实现一个程序，对下列每个测试矩阵，计算其到上述物理上允许集合的 Frobenius 范数投影的特征值（按非递增顺序排序）。您的程序必须将所有测试用例的结果以列表的列表形式单行输出。每个特征值必须四舍五入到恰好 6 位小数。\n\n测试套件（每个矩阵都是对称无迹的）：\n- 情况 1：$A_{1} = \\mathrm{diag}(0.3,-0.2,-0.1)$。\n- 情况 2：$A_{2} = \\mathrm{diag}(1.4,-0.5,-0.9)$。\n- 情况 3：$A_{3} = \\mathrm{diag}(0.8,-0.7,-0.1)$。\n- 情况 4：$A_{4} = \\begin{bmatrix} 0.6  0.2  0.0 \\\\ 0.2  -0.1  0.1 \\\\ 0.0  0.1  -0.5 \\end{bmatrix}$。\n- 情况 5：$A_{5} = \\mathrm{diag}(0.7,0.7,-1.4)$。\n- 情况 6：$A_{6} = \\begin{bmatrix} 0.9  -0.4  0.3 \\\\ -0.4  -0.2  0.5 \\\\ 0.3  0.5  -0.7 \\end{bmatrix}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，其本身是三个特征值（按非递增顺序排序）的列表，并四舍五入到恰好 6 位小数。例如，输出格式为 $[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],\\ldots]$，其中每个 $x_{ij}$ 是一个恰好有 6 位小数的浮点数，且不打印任何额外文本。", "solution": "所述问题是有效的。这是一个适定的凸优化问题，其基础是软物质物理学中已确立的物理原理。定义清晰，数据一致，目标在数学上是明确的。它要求推导并实现到一个凸集上的投影，这是一项标准且有意义的任务。我们将着手解决该问题。\n\n根据要求，分析分为三个部分：特征值问题的推导、解结构的证明以及计算算法的设计。\n\n**第一部分：简化为特征值问题**\n\n取向序参数张量 $Q$ 是通过对分子取向（由单位向量 $\\mathbf{u}$ 表示）的分布进行统计平均来定义的。一个常见的定义是 $Q_{unscaled} = \\langle \\mathbf{u} \\otimes \\mathbf{u} - \\frac{1}{3}I \\rangle$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。对于任意单位向量 $\\mathbf{n}$，瑞利商（Rayleigh quotient）给出 $\\mathbf{n}^{\\mathsf{T}} Q_{unscaled} \\mathbf{n} = \\langle (\\mathbf{u} \\cdot \\mathbf{n})^2 - \\frac{1}{3} \\rangle$。由于 $(\\mathbf{u} \\cdot \\mathbf{n})^2 \\in [0, 1]$，其平均值也必须位于 $[0, 1]$ 内，这意味着 $\\mathbf{n}^{\\mathsf{T}} Q_{unscaled} \\mathbf{n} \\in [-\\frac{1}{3}, \\frac{2}{3}]$。根据 Courant-Fischer 定理，$Q_{unscaled}$ 的特征值包含在该区间内。\n\n问题指出，物理上允许的 $Q$ 张量集合的特征值在 $[-1/2, 1]$ 内。这对应于一种不同但同样标准的归一化，$Q = \\frac{3}{2}Q_{unscaled}$。因此，这个 $Q$ 的特征值被限制在区间 $\\frac{3}{2}[-\\frac{1}{3}, \\frac{2}{3}] = [-1/2, 1]$ 内。问题陈述提供了这个区间，我们将使用它。因此，允许的张量集合为：\n$$ \\mathcal{C} = \\{ Q \\in \\mathbb{S}_{0}^{3} \\mid \\sigma(Q) \\subset [-1/2, 1] \\} $$\n其中 $\\mathbb{S}_{0}^{3}$ 是 $3 \\times 3$ 实对称无迹矩阵的空间，$\\sigma(Q)$ 是 $Q$ 的特征值集合。这个集合 $\\mathcal{C}$ 是闭合且凸的。\n\n任务是找到给定矩阵 $A \\in \\mathbb{S}_{0}^{3}$ 到 $\\mathcal{C}$ 上的投影。这是一个最小化问题：\n$$ \\min_{Q \\in \\mathcal{C}} \\lVert A - Q \\rVert_{\\mathrm{F}}^2 $$\n目标函数是 Frobenius 范数的平方，$\\lVert M \\rVert_{\\mathrm{F}}^2 = \\mathrm{tr}(M^{\\mathsf{T}}M)$。由于 $A$ 和 $Q$ 是对称的，这等于 $\\mathrm{tr}((A-Q)^2)$。\n\n设 $A$ 的谱分解为 $A = V \\Lambda_A V^{\\mathsf{T}}$，其中 $V$ 是一个正交矩阵，其列是 $A$ 的特征向量，$\\Lambda_A = \\mathrm{diag}(\\lambda_{A1}, \\lambda_{A2}, \\lambda_{A3})$ 是相应特征值的对角矩阵。Frobenius 范数在正交变换下是不变的，即对于任何正交矩阵 $U$，$\\lVert U M U^{\\mathsf{T}} \\rVert_{\\mathrm{F}} = \\lVert M \\rVert_{\\mathrm{F}}$。\n我们将此性质应用于目标函数：\n$$ \\lVert A - Q \\rVert_{\\mathrm{F}}^2 = \\lVert V \\Lambda_A V^{\\mathsf{T}} - Q \\rVert_{\\mathrm{F}}^2 = \\lVert V^{\\mathsf{T}}(V \\Lambda_A V^{\\mathsf{T}} - Q)V \\rVert_{\\mathrm{F}}^2 = \\lVert \\Lambda_A - V^{\\mathsf{T}}QV \\rVert_{\\mathrm{F}}^2 $$\n令 $\\tilde{Q} = V^{\\mathsf{T}}QV$。从 $Q$ 到 $\\tilde{Q}$ 的变换是相似变换，因此它们具有相同的特征值和迹。因此，$Q \\in \\mathcal{C}$ 当且仅当 $\\tilde{Q} \\in \\mathcal{C}$。问题变为在所有 $\\tilde{Q} \\in \\mathcal{C}$ 上找到最小化 $\\lVert \\Lambda_A - \\tilde{Q} \\rVert_{\\mathrm{F}}^2$ 的 $\\tilde{Q}^{\\star}$。\n\n我们展开范数：\n$$ \\lVert \\Lambda_A - \\tilde{Q} \\rVert_{\\mathrm{F}}^2 = \\sum_{i,j=1}^3 (\\Lambda_{A,ij} - \\tilde{Q}_{ij})^2 = \\sum_{i=1}^3 (\\lambda_{Ai} - \\tilde{Q}_{ii})^2 + \\sum_{i \\neq j} \\tilde{Q}_{ij}^2 $$\n当非对角元素 $\\tilde{Q}_{ij}$ 在 $i \\neq j$ 时为零时，此表达式最小化。将非对角元素设为零不影响迹或对角线项，因此不干扰对 $\\tilde{Q}$ 特征值（现在就是其对角线元素）的约束。因此，最优矩阵 $\\tilde{Q}^{\\star}$ 必须是一个对角矩阵。我们将其对角线元素（即其特征值）表示为 $\\lambda = (\\lambda_1, \\lambda_2, \\lambda_3)$。\n\n这将原始的矩阵优化问题简化为特征值空间中一个简单得多的向量优化问题：\n$$ \\min_{\\lambda \\in \\mathbb{R}^3} \\sum_{i=1}^3 (\\lambda_{Ai} - \\lambda_i)^2 $$\n其约束条件定义了允许的特征值集合：\n$$ \\sum_{i=1}^3 \\lambda_i = 0 $$\n$$ -1/2 \\le \\lambda_i \\le 1 \\quad \\text{for } i=1, 2, 3 $$\n\n**第二部分：解结构的证明**\n\n第一部分的论证确立了最小化子 $Q^{\\star}$ 与 $A$ 具有相同的特征向量。我们有 $Q^{\\star} = V \\tilde{Q}^{\\star} V^{\\mathsf{T}}$，并且由于 $\\tilde{Q}^{\\star}$ 在 $A$ 的特征向量基中是对角的，所以 $Q^{\\star}$ 与 $A$ 是共对角化的。$Q^{\\star}$ 的特征值（我们表示为 $\\lambda^{\\star}$）是上面推导的向量最小化问题的解。这个问题等价于找到 $A$ 的特征值向量 $\\lambda_A = (\\lambda_{A1}, \\lambda_{A2}, \\lambda_{A3})$ 到由线性等式和边界约束定义的凸集上的欧几里得投影。\n\n为了找到解 $\\lambda^{\\star}$ 的结构，我们使用 Karush-Kuhn-Tucker (KKT) 条件。设目标函数为 $f(\\lambda) = \\frac{1}{2} \\sum_{i=1}^3 (\\lambda_i - \\lambda_{Ai})^2$。拉格朗日函数为：\n$$ L(\\lambda, \\gamma, \\mu, \\nu) = \\frac{1}{2} \\sum_{i=1}^3 (\\lambda_i - \\lambda_{Ai})^2 - \\gamma \\left(\\sum_{i=1}^3 \\lambda_i\\right) - \\sum_{i=1}^3 \\mu_i (1 - \\lambda_i) - \\sum_{i=1}^3 \\nu_i (\\lambda_i + 1/2) $$\n其中拉格朗日乘子为 $\\gamma \\in \\mathbb{R}$ 且 $\\mu_i, \\nu_i \\ge 0$。平稳性条件 $\\nabla_{\\lambda_i} L = 0$ 给出：\n$$ (\\lambda_i - \\lambda_{Ai}) - \\gamma - \\mu_i + \\nu_i = 0 \\implies \\lambda_i = \\lambda_{Ai} + \\gamma + \\mu_i - \\nu_i $$\n互补松弛条件为 $\\mu_i(1 - \\lambda_i) = 0$ 和 $\\nu_i(\\lambda_i + 1/2) = 0$。\n\n我们分析每个分量 $\\lambda_i$ 的三种情况：\n1. 如果界限未激活（$-1/2  \\lambda_i  1$），则 $\\mu_i=0$ 且 $\\nu_i=0$。这意味着 $\\lambda_i = \\lambda_{Ai} + \\gamma$。\n2. 如果上界被激活（$\\lambda_i = 1$），则 $\\nu_i=0$ 且 $\\mu_i \\ge 0$。这意味着 $1 = \\lambda_{Ai} + \\gamma + \\mu_i$，可以重排为 $\\lambda_{Ai} + \\gamma = 1 - \\mu_i \\le 1$。\n3. 如果下界被激活（$\\lambda_i = -1/2$），则 $\\mu_i=0$ 且 $\\nu_i \\ge 0$。这意味着 $-1/2 = \\lambda_{Ai} + \\gamma - \\nu_i$，可以重排为 $\\lambda_{Ai} + \\gamma = -1/2 + \\nu_i \\ge -1/2$。\n\n结合这些情况，每个分量 $\\lambda_i$ 的解可以紧凑地表示为一个平移值在区间 $[-1/2, 1]$ 上的截断（或投影）：\n$$ \\lambda_i = \\max(-1/2, \\min(1, \\lambda_{Ai} + \\gamma)) $$\n未知的标量平移 $\\gamma$ 通过强制执行无迹条件 $\\sum_i \\lambda_i = 0$ 来确定。这导出了一个关于 $\\gamma$ 的非线性标量方程：\n$$ g(\\gamma) = \\sum_{i=1}^3 \\max(-1/2, \\min(1, \\lambda_{Ai} + \\gamma)) = 0 $$\n函数 $g(\\gamma)$ 是截断线性函数的和，使其成为一个关于 $\\gamma$ 的连续、分段线性和单调递增的函数。因此，它有一个唯一的根，可以高效地找到。这就完成了从第一性原理对解结构的证明。\n\n**第三部分：算法设计**\n\n理论分析直接导出以下算法：\n1. 给定输入矩阵 $A \\in \\mathbb{S}_{0}^{3}$，计算其特征值。由于 $A$ 是对称的，我们可以使用标准的数值例程（例如通过像 NumPy 这样的库调用 LAPACK）来找到特征值 $\\lambda_{A1}, \\lambda_{A2}, \\lambda_{A3}$。为了一致性，我们将它们按非递增顺序排序：$\\lambda_{A1} \\ge \\lambda_{A2} \\ge \\lambda_{A3}$。\n\n2. 检查特征值 $\\lambda_{Ai}$ 是否已经满足允许性约束，即 $\\lambda_{A1} \\le 1$ 和 $\\lambda_{A3} \\ge -1/2$。如果满足，则该点已在可行集中，投影就是该点本身：$\\lambda^{\\star}_i = \\lambda_{Ai}$。\n\n3. 如果特征值不满足允许性，求解标量求根问题 $g(\\gamma) = 0$。\n    a. 定义函数 $g(\\gamma) = \\sum_{i=1}^3 \\mathrm{clip}(\\lambda_{Ai} + \\gamma, -1/2, 1)$，其中 $\\mathrm{clip}(x, a, b) = \\max(a, \\min(b, x))$。\n    b. 因为 $g(\\gamma)$ 是单调的，我们可以使用像二分法这样的稳健方法来找到唯一的根 $\\gamma^{\\star}$。必须建立一个合适的搜索区间 $[\\gamma_{\\min}, \\gamma_{\\max}]$。一个安全的选择是 $[\\gamma_{\\min}, \\gamma_{\\max}] = [-1/2 - \\lambda_{A1}, 1 - \\lambda_{A3}]$，因为这个范围保证了平移后的值 $\\lambda_{Ai} + \\gamma$ 可以达到目标区间 $[-1/2, 1]$ 中的任何一点。\n    c. 二分法算法通过重复地将搜索区间减半，同时保持根在该区间内，直到区间宽度低于所需的数值公差。\n\n4. 一旦确定了最优平移 $\\gamma^{\\star}$，计算投影后的特征值：\n    $$ \\lambda^{\\star}_i = \\max(-1/2, \\min(1, \\lambda_{Ai} + \\gamma^{\\star})) $$\n    \n5. 将得到的特征值 $\\lambda^{\\star}_i$ 按非递增顺序排序，并将其作为最终结果。该算法保证在有限时间内以唯一、正确的解终止。\n\n实现将使用 `numpy.linalg.eigh` 进行特征值计算，并使用自定义的二分搜索函数来求解 $\\gamma$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Frobenius-norm projection of a symmetric traceless 3x3 matrix\n    onto the set of physically admissible orientational order parameter tensors.\n    \"\"\"\n\n    test_cases = [\n        np.array([[0.3, 0.0, 0.0], [0.0, -0.2, 0.0], [0.0, 0.0, -0.1]]),\n        np.array([[1.4, 0.0, 0.0], [0.0, -0.5, 0.0], [0.0, 0.0, -0.9]]),\n        np.array([[0.8, 0.0, 0.0], [0.0, -0.7, 0.0], [0.0, 0.0, -0.1]]),\n        np.array([[0.6, 0.2, 0.0], [0.2, -0.1, 0.1], [0.0, 0.1, -0.5]]),\n        np.array([[0.7, 0.0, 0.0], [0.0, 0.7, 0.0], [0.0, 0.0, -1.4]]),\n        np.array([[0.9, -0.4, 0.3], [-0.4, -0.2, 0.5], [0.3, 0.5, -0.7]])\n    ]\n\n    results = []\n\n    for A in test_cases:\n        # Step 1: Compute and sort eigenvalues of A\n        # numpy.linalg.eigh returns eigenvalues in non-decreasing order.\n        # We sort them in non-increasing order.\n        eigvals_A = np.linalg.eigh(A)[0][::-1]\n\n        # Step 2: Check if eigenvalues are already in the admissible set [-0.5, 1]\n        lower_bound = -0.5\n        upper_bound = 1.0\n        \n        if eigvals_A[0] = upper_bound and eigvals_A[-1] = lower_bound:\n            projected_eigvals = eigvals_A\n        else:\n            # Step 3: Solve for the Lagrange multiplier gamma using bisection\n            def g(gamma, eigvals):\n                return np.sum(np.clip(eigvals + gamma, lower_bound, upper_bound))\n\n            # Establish a safe search range for gamma\n            gamma_min = lower_bound - eigvals_A[0]\n            gamma_max = upper_bound - eigvals_A[-1]\n\n            # Bisection method\n            tol = 1e-12\n            max_iter = 100\n            for _ in range(max_iter):\n                gamma = (gamma_min + gamma_max) / 2\n                f_val = g(gamma, eigvals_A)\n                \n                if abs(f_val)  tol:\n                    break\n                \n                if f_val  0:\n                    gamma_max = gamma\n                else:\n                    gamma_min = gamma\n\n            # Step 4: Compute the projected eigenvalues using the found gamma\n            projected_eigvals = np.clip(eigvals_A + gamma, lower_bound, upper_bound)\n        \n        # Ensure final eigenvalues are sorted for consistent output\n        projected_eigvals = np.sort(projected_eigvals)[::-1]\n        \n        # Format results to 6 decimal places\n        formatted_eigvals = [f\"{val:.6f}\" for val in projected_eigvals]\n        results.append(f\"[{','.join(formatted_eigvals)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2933004"}]}