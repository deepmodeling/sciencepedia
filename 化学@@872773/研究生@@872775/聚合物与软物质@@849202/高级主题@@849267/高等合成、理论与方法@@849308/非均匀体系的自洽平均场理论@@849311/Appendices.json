{"hands_on_practices": [{"introduction": "自洽场理论（SCFT）计算的核心是求解单链传播子的修正扩散方程。本练习将指导您使用一种强大而精确的伪谱方法结合算符分裂技术，来构建这一核心引擎。掌握这项任务是构建完整SCFT代码的第一个关键步骤，它能让您深入理解聚合物链在平均场中行为的数值模拟基础。[@problem_id:2927261]", "problem": "您需要为一个出现在高分子链自洽平均场理论中的修正扩散方程设计并实现一个数值求解器，并量化其精度作为链段步长的函数。考虑单链传播子 $q(\\mathbf{r},s)$ 的三维修正扩散方程：\n$$\n\\partial_s q(\\mathbf{r},s) \\;=\\; D \\nabla^2 q(\\mathbf{r},s) \\;-\\; w(\\mathbf{r})\\, q(\\mathbf{r},s),\n$$\n其中 $D$ 是一个正常数，$s$ 是链段变量，$w(\\mathbf{r})$ 是一个具有周期性边界条件的、预设的、不随时间变化的外场。空间域为立方体 $\\Omega = [0,L)^3$，在每个坐标方向上的周期为 $L$。所有量均为无量纲。\n\n基本出发点和核心定义：\n- 扩散的生成元为 $D\\nabla^2$，其中拉普拉斯算子在傅里叶空间中表示为 $-D k^2$，这里 $k^2 = k_x^2 + k_y^2 + k_z^2$。\n- 对于均匀网格上的周期性边界条件，可以使用快速傅里叶变换（FFT）来精确计算扩散半群 $\\exp(s D \\nabla^2)$ 的作用，在傅里叶空间中这表现为与 $\\exp(-s D k^2)$ 的对角乘法。\n- 势场项 $-w(\\mathbf{r}) q$ 在实空间中作为逐点乘法作用。\n- 半群 $\\exp\\{ \\Delta s\\,[D\\nabla^2 - w(\\mathbf{r})]\\}$ 的二阶对称算子分裂（Strang分裂）方法，将实空间中势场的半步作用与傅里叶空间中扩散的全步作用交替进行。\n\n您的任务是：\n1) 在均匀网格上将链段变量 $s$ 以步长 $\\Delta s$ 离散化，应用二阶对称算子分裂，使用FFT处理扩散算子，将 $q$ 从 $s$ 推进到 $s+\\Delta s$。在一个程序中实现此方案。\n2) 对于下述测试用例，计算总链段长度为 $S$ 时的数值解，并使用空间上的 $L^2$-范数量化精度作为 $\\Delta s$ 的函数。\n3) 对于非平凡的非均匀势场，通过对 $\\log(\\text{error})$ 作为 $\\log(\\Delta s)$ 的函数进行直线拟合，估算观测到的精度阶数。\n\n空间离散化与傅里叶表示：\n- 使用一个 $N \\times N \\times N$ 点的均匀网格，其中 $N$ 在测试组中指定。空间坐标为 $x_i = i\\, L/N$, $y_j = j\\, L/N$, $z_k = k\\, L/N$，其中整数 $i,j,k \\in \\{0,1,\\dots,N-1\\}$。\n- 傅里叶波数是根据周期性边界条件下的离散频率定义的。如果 $\\nu_\\alpha$ 是离散傅里叶变换约定返回的离散频率，则角波数为 $k_\\alpha = 2\\pi \\nu_\\alpha$，且 $k^2 = k_x^2 + k_y^2 + k_z^2$。\n\n误差度量：\n- 给定一个参考场 $q_{\\text{ref}}(\\mathbf{r})$ 和一个近似解 $q_{\\Delta s}(\\mathbf{r})$，定义相对 $L^2$ 误差为\n$$\nE(\\Delta s) \\;=\\; \\frac{\\left( \\int_\\Omega |q_{\\Delta s}(\\mathbf{r}) - q_{\\text{ref}}(\\mathbf{r})|^2 \\, d\\mathbf{r} \\right)^{1/2}}{\\left( \\int_\\Omega |q_{\\text{ref}}(\\mathbf{r})|^2 \\, d\\mathbf{r} \\right)^{1/2}},\n$$\n在均匀网格上，这简化为差方均值的平方根除以参考值平方均值的平方根。\n\n测试组：\n采用固定参数 $L = 2\\pi$，$N = 16$，$D = 1$，以及总链段长度 $S = 1$。考虑四个链段步长 $\\Delta s \\in \\{1/8,\\, 1/16,\\, 1/32,\\, 1/64\\}$，使得步数为 $S/\\Delta s \\in \\{8,\\,16,\\,32,\\,64\\}$。使用以下三个测试：\n\n- 测试 1 (均匀，仅扩散)：$w(\\mathbf{r}) = 0$，初始条件 $q(\\mathbf{r},0) = \\cos(x)\\cos(y)\\cos(z)$。在 $s=S$ 时的精确解等于扩散半群作用于初始条件的结果。使用谱表示计算精确解，并对每个 $\\Delta s$ 计算相对 $L^2$ 误差 $E(\\Delta s)$。将四个 $\\Delta s$ 值中的最大误差报告为一个浮点数。\n\n- 测试 2 (与扩散算子对易的均匀势场)：$w(\\mathbf{r}) = w_0$，其中 $w_0 = 0.3$，初始条件 $q(\\mathbf{r},0) = \\cos(x)\\cos(y)\\cos(z)$。在 $s=S$ 时的精确解等于 $\\exp(-w_0 S)$ 乘以扩散半群作用于初始条件的结果。为每个 $\\Delta s$ 计算相对 $L^2$ 误差 $E(\\Delta s)$，并将四个值中的最大值报告为一个浮点数。\n\n- 测试 3 (非均匀势场，基于参考解的精度研究)：$w(\\mathbf{r}) = A \\cos(x)\\cos(y)\\cos(z)$，其中 $A = 0.5$，初始条件 $q(\\mathbf{r},0) = 1$。对于参考解，使用相同的分裂方法但用一个更小的步长 $\\Delta s_{\\text{ref}} = 1/512$ 计算在 $s=S$ 时的 $q_{\\text{ref}}(\\mathbf{r})$。对于每个 $\\Delta s \\in \\{1/8,\\, 1/16,\\, 1/32,\\, 1/64\\}$，计算相对于 $q_{\\text{ref}}$ 的误差 $E(\\Delta s)$。使用最小二乘法对数据点对 $(\\log(\\Delta s), \\log(E(\\Delta s)))$ 进行直线拟合，并将拟合斜率报告为一个浮点数。该斜率估算了观测到的精度阶数。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{max\\_error\\_test1},\\, \\text{max\\_error\\_test2},\\, \\text{observed\\_order\\_test3}]$。例如，一个有效的输出可能看起来像 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 是浮点数。由于所有量都是无量纲的，因此不需要物理单位。根据域 $[0,2\\pi)^3$ 的构造，角度以弧度为单位。", "solution": "所提出的问题是求解偏微分方程的一个标准练习，在统计场论中很常见，具体而言是伪谱方法和算子分裂在修正扩散方程中的应用。问题陈述在科学上是合理的、适定的，并包含了解决该问题所需的所有信息。我将着手提供一个完整的解决方案。\n\n单链传播子 $q(\\mathbf{r},s)$ 的控制方程是一个抛物线型线性偏微分方程：\n$$\n\\partial_s q(\\mathbf{r},s) \\;=\\; D \\nabla^2 q(\\mathbf{r},s) \\;-\\; w(\\mathbf{r})\\, q(\\mathbf{r},s)\n$$\n这可以写成抽象算子形式 $\\partial_s q = (\\mathcal{A} + \\mathcal{B})q$，其中 $\\mathcal{A} = D \\nabla^2$ 是扩散算子，$\\mathcal{B} = -w(\\mathbf{r})$ 是势算子。在长度为 $\\Delta s$ 的一个链段步长上的形式解由传播子（或称半群）的作用给出：$q(s+\\Delta s) = \\exp\\{\\Delta s (\\mathcal{A} + \\mathcal{B})\\} q(s)$。\n\n通常情况下，算子 $\\mathcal{A}$ 和 $\\mathcal{B}$ 不对易（$[\\mathcal{A}, \\mathcal{B}] \\neq 0$）。因此，它们的和的指数不能简单地进行因式分解。问题要求使用二阶对称算子分裂，即Strang分裂，来近似传播子：\n$$\n\\exp\\{\\Delta s (\\mathcal{A} + \\mathcal{B})\\} \\approx e^{\\frac{\\Delta s}{2}\\mathcal{B}} e^{\\Delta s\\mathcal{A}} e^{\\frac{\\Delta s}{2}\\mathcal{B}} + O(\\Delta s^3)\n$$\n这种分裂方案提供了一种鲁棒的方法，通过将链段变量 $s$ 离散化为大小为 $\\Delta s$ 的步长来推进解。在总链段长度 $S$ 处的解是通过将此分裂步算子应用于初始条件 $q(\\mathbf{r},0)$ 共 $M = S/\\Delta s$ 次得到的。\n\n分裂步算子的实现利用了它们在实空间和傅里叶空间中的不同性质。空间域 $\\Omega = [0,L)^3$ 在一个 $N \\times N \\times N$ 点的均匀网格上被离散化。\n1.  **势算子**：算子 $e^{\\frac{\\Delta s}{2}\\mathcal{B}} = \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r}))$ 是实空间中的一个局域算子。它对场 $q(\\mathbf{r},s)$ 的作用是一个简单的逐点乘法。\n2.  **扩散算子**：算子 $e^{\\Delta s\\mathcal{A}} = \\exp(\\Delta s D \\nabla^2)$ 在实空间中是非局域的，但在傅里叶空间中是对角的。在周期域上，拉普拉斯算子 $\\nabla^2$ 的本征函数为 $e^{i\\mathbf{k}\\cdot\\mathbf{r}}$，对应的本征值为 $-k^2$。因此，扩散算子的作用可以通过快速傅里叶变换（FFT）高效计算。过程如下：\n    a.  将场 $q(\\mathbf{r})$ 变换为其傅里叶表示 $\\hat{q}(\\mathbf{k}) = \\mathcal{F}\\{q(\\mathbf{r})\\}$。\n    b.  将傅里叶系数乘以对角扩散核，$\\hat{q}_{\\text{diffused}}(\\mathbf{k}) = \\exp(-\\Delta s D k^2) \\hat{q}(\\mathbf{k})$。波矢模长的平方为 $k^2 = k_x^2 + k_y^2 + k_z^2$。分量 $k_\\alpha$ 是与网格对应的离散角波数，由 $k_\\alpha = 2\\pi\\nu_\\alpha$ 给出，其中 $\\nu_\\alpha$ 是标准FFT算法为尺寸为 $L$ 的域提供的频率。\n    c.  将结果逆变换回实空间：$q_{\\text{diffused}}(\\mathbf{r}) = \\mathcal{F}^{-1}\\{\\hat{q}_{\\text{diffused}}(\\mathbf{k})\\}$。\n\n将解从 $s=0$ 推进到 $s=S$ 的完整算法如下：\n初始化 $q(\\mathbf{r}) = q(\\mathbf{r},0)$。\n对于 $m=1, \\dots, M=S/\\Delta s$：\n1.  $q(\\mathbf{r}) \\leftarrow \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r})) q(\\mathbf{r})$\n2.  $\\hat{q}(\\mathbf{k}) \\leftarrow \\mathcal{F}\\{q(\\mathbf{r})\\}$\n3.  $\\hat{q}(\\mathbf{k}) \\leftarrow \\exp(-\\Delta s D k^2) \\hat{q}(\\mathbf{k})$\n4.  $q(\\mathbf{r}) \\leftarrow \\mathcal{F}^{-1}\\{\\hat{q}(\\mathbf{k})\\}$\n5.  $q(\\mathbf{r}) \\leftarrow \\exp(-\\frac{\\Delta s}{2} w(\\mathbf{r})) q(\\mathbf{r})$\n最终得到的场 $q(\\mathbf{r})$ 即为数值近似解 $q_{\\Delta s}(\\mathbf{r}, S)$。\n\n我们现在分析指定的测试用例。\n\n**测试 1 (均匀, $w(\\mathbf{r}) = 0$) 和 测试 2 (均匀, $w(\\mathbf{r}) = w_0$)**：\n在这两种情况下，算子 $\\mathcal{B}$ 是一个标量乘法（分别为 $-0$ 和 $-w_0$）。标量算子与任何其他算子对易，包括拉普拉斯算子 $\\nabla^2$。因此，$[\\mathcal{A}, \\mathcal{B}] = 0$。对于对易的算子，Strang分裂不是近似，而是精确的恒等式：$e^{\\frac{\\Delta s}{2}\\mathcal{B}} e^{\\Delta s\\mathcal{A}} e^{\\frac{\\Delta s}{2}\\mathcal{B}} = e^{\\Delta s\\mathcal{A}}e^{\\Delta s\\mathcal{B}} = e^{\\Delta s(\\mathcal{A}+\\mathcal{B})}$。\n因此，单步的数值演化与精确演化完全相同。通过归纳法，经过 $M$ 步后的数值解 $(e^{\\Delta s(\\mathcal{A}+\\mathcal{B})})^M q_0 = e^{S(\\mathcal{A}+\\mathcal{B})}q_0$ 与 $s=S$ 处的精确解完全相同。所要求的参考解是通过直接应用总传播子来计算的。迭代数值解与参考解之间的任何偏差都必须仅由浮点运算误差的累积引起。我们预计此误差在机器精度的量级上。报告的是四个 $\\Delta s$ 值中这些小误差的最大值。\n\n**测试 3 (非均匀势场)**：\n这里，势场 $w(\\mathbf{r}) = A \\cos(x)\\cos(y)\\cos(z)$ 是空间依赖的，算子 $\\mathcal{A}$ 和 $\\mathcal{B}$ 不对易。Strang分裂方法引入了一个阶为 $O(\\Delta s^3)$ 的局部截断误差。在总区间 $S$ 上，$M = S/\\Delta s$ 步的累积导致一个阶为 $O(\\Delta s^2)$ 的全局误差。误差预期将按 $E(\\Delta s) \\propto (\\Delta s)^p$ 缩放，其中理论精度阶数 $p=2$。\n为了验证这一点，我们取对数：$\\log E(\\Delta s) = p \\log(\\Delta s) + \\text{const}$。因此，阶数 $p$ 可以通过对数据点 $(\\log(\\Delta s), \\log E(\\Delta s))$ 进行线性拟合的斜率来估计。用于衡量误差的参考解，是使用相同的数值方法但用一个更小的步长 $\\Delta s_{\\text{ref}} = 1/512$ 计算得到的，以确保它是真实解的一个足够精确的替代。斜率通过标准的线性最小二乘回归公式计算：\n$$\np = \\frac{n \\sum_{i=1}^n (x_i y_i) - (\\sum_{i=1}^n x_i)(\\sum_{i=1}^n y_i)}{n \\sum_{i=1}^n (x_i^2) - (\\sum_{i=1}^n x_i)^2}\n$$\n其中 $n=4$，$x_i = \\log(\\Delta s_i)$，以及 $y_i = \\log(E(\\Delta s_i))$。这个斜率就是报告的结果。\n\n代码使用 `numpy` 库实现这些过程，用于数组操作和FFT。误差度量计算为相对 $L^2$ 范数，对于均匀网格，这简化为 $\\text{norm}(q_{\\Delta s} - q_{\\text{ref}}) / \\text{norm}(q_{\\text{ref}})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef setup_grid(N, L):\n    \"\"\"\n    Sets up the spatial grid and the corresponding k-space grid.\n    \n    Args:\n        N (int): Number of grid points in each dimension.\n        L (float): Length of the periodic box.\n\n    Returns:\n        tuple: A tuple containing ((x, y, z), k_squared), where (x,y,z) are the \n               coordinate meshes and k_squared is the mesh of squared wavevector magnitudes.\n    \"\"\"\n    grid_1d = np.arange(N) * L / N\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # Wavevectors (k) corresponding to the grid (N points, L length)\n    # The sample spacing is d = L/N.\n    # np.fft.fftfreq(N, d=L/N) gives frequencies in cycles per unit of length.\n    # Angular wavenumbers are 2*pi times these frequencies.\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n\n    return (x, y, z), k_squared\n\ndef solve_diffusion_equation(q0, w, D, S, ds, k_squared):\n    \"\"\"\n    Solves the modified diffusion equation using Strang splitting.\n\n    Args:\n        q0 (np.ndarray): Initial condition for the field q.\n        w (np.ndarray): External potential field.\n        D (float): Diffusion constant.\n        S (float): Total contour length.\n        ds (float): Contour step size.\n        k_squared (np.ndarray): Squared wavevector magnitudes on the Fourier grid.\n\n    Returns:\n        np.ndarray: The field q at contour length S.\n    \"\"\"\n    num_steps = round(S / ds)\n    if not np.isclose(S / ds, num_steps):\n        raise ValueError(\"S must be an integer multiple of ds for this solver.\")\n    \n    q = q0.copy().astype(np.complex128)\n\n    # Pre-calculate operators for efficiency\n    exp_w_half_step = np.exp(-0.5 * ds * w)\n    diffusion_kernel = np.exp(-ds * D * k_squared)\n\n    for _ in range(num_steps):\n        # Strang splitting step\n        # 1. Half potential step\n        q *= exp_w_half_step\n        \n        # 2. Full diffusion step in Fourier space\n        q_hat = np.fft.fftn(q)\n        q_hat *= diffusion_kernel\n        q = np.fft.ifftn(q_hat)\n\n        # 3. Second half potential step\n        q *= exp_w_half_step\n        \n    return q.real\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    L = 2 * np.pi\n    N = 16\n    D = 1.0\n    S = 1.0\n    \n    (x, y, z), k_squared = setup_grid(N, L)\n    \n    ds_values = [1/8, 1/16, 1/32, 1/64]\n    \n    results = []\n\n    # --- Test 1: Homogeneous, diffusion-only ---\n    w_test1 = np.zeros((N, N, N))\n    q0_test1 = np.cos(x) * np.cos(y) * np.cos(z)\n    \n    # Reference solution for Test 1 (exact in spectral space)\n    q0_hat_test1 = np.fft.fftn(q0_test1)\n    exact_diffusion_kernel = np.exp(-S * D * k_squared)\n    q_ref_hat_test1 = q0_hat_test1 * exact_diffusion_kernel\n    q_ref_test1 = np.fft.ifftn(q_ref_hat_test1).real\n    \n    errors_test1 = []\n    norm_ref1 = np.linalg.norm(q_ref_test1)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test1, w_test1, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test1) / norm_ref1\n        errors_test1.append(error)\n\n    results.append(np.max(errors_test1))\n    \n    # --- Test 2: Homogeneous potential ---\n    w0 = 0.3\n    w_test2 = np.full((N, N, N), w0)\n    q0_test2 = np.cos(x) * np.cos(y) * np.cos(z)\n    \n    # Reference solution for Test 2 (exact since operators commute)\n    q0_hat_test2 = np.fft.fftn(q0_test2)\n    q_ref_hat_test2 = q0_hat_test2 * exact_diffusion_kernel\n    q_ref_test2_diffusion = np.fft.ifftn(q_ref_hat_test2).real\n    q_ref_test2 = np.exp(-w0 * S) * q_ref_test2_diffusion\n    \n    errors_test2 = []\n    norm_ref2 = np.linalg.norm(q_ref_test2)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test2, w_test2, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test2) / norm_ref2\n        errors_test2.append(error)\n\n    results.append(np.max(errors_test2))\n    \n    # --- Test 3: Inhomogeneous potential, accuracy study ---\n    A = 0.5\n    w_test3 = A * np.cos(x) * np.cos(y) * np.cos(z)\n    q0_test3 = np.ones((N, N, N))\n    \n    # Reference solution computed with a much smaller step size\n    ds_ref = 1/512\n    q_ref_test3 = solve_diffusion_equation(q0_test3, w_test3, D, S, ds_ref, k_squared)\n    \n    errors_test3 = []\n    norm_ref3 = np.linalg.norm(q_ref_test3)\n    for ds in ds_values:\n        q_num = solve_diffusion_equation(q0_test3, w_test3, D, S, ds, k_squared)\n        error = np.linalg.norm(q_num - q_ref_test3) / norm_ref3\n        errors_test3.append(error)\n        \n    log_ds_vals = np.log(ds_values)\n    log_errors = np.log(errors_test3)\n    \n    # OLS linear regression to find the slope (order of accuracy)\n    x_fit = log_ds_vals\n    y_fit = log_errors\n    n_fit = len(x_fit)\n    \n    sum_x = np.sum(x_fit)\n    sum_y = np.sum(y_fit)\n    sum_xy = np.sum(x_fit * y_fit)\n    sum_x2 = np.sum(x_fit**2)\n    \n    # Formula for the slope of the regression line\n    slope = (n_fit * sum_xy - sum_x * sum_y) / (n_fit * sum_x2 - sum_x**2)\n    \n    results.append(slope)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2927261"}, {"introduction": "在求解了传播子之后，下一步是处理整个非线性的自洽方程组。简单的Picard迭代法在许多物理条件下（例如在相分离临界点附近）会变得不稳定。本练习旨在探索更先进的牛顿类求解器的原理，这类方法通常能提供更快、更可靠的收敛性。核心任务是推导雅可比-向量积，这是实现高效的无矩阵牛顿-克雷洛夫（Newton-Krylov）方法的关键，也是从理论转向高级数值实现的重要一步。[@problem_id:2927269]", "problem": "考虑一个对称双嵌段共聚物熔体，它在一个周期性域 $\\Omega \\subset \\mathbb{R}^d$（其中 $d \\in \\{2,3\\}$）中，由轮廓变量为 $s \\in [0,1]$ 且 Kuhn 长度为 $b$ 的高斯链建模。设 A 嵌段占据 $s \\in [0,f]$，B 嵌段占据 $s \\in (f,1]$，其中 $f \\in (0,1)$。使用了参数为 $\\kappa N > 0$ 的可压缩 Helfand 罚项以及 Flory–Huggins 参数 $\\chi N > 0$。自洽场（SCF）方程确定了平均场 $w_A(\\mathbf{r})$ 和 $w_B(\\mathbf{r})$ 以及单体密度 $\\phi_A(\\mathbf{r})$ 和 $\\phi_B(\\mathbf{r})$：\n- 单链传播子 $q(\\mathbf{r},s)$ 和 $q^\\dagger(\\mathbf{r},s)$ 满足修正的扩散方程\n$$\n\\partial_s q(\\mathbf{r},s) = \\frac{b^2}{6}\\nabla^2 q(\\mathbf{r},s) - w(\\mathbf{r},s)\\, q(\\mathbf{r},s), \\qquad q(\\mathbf{r},0)=1,\n$$\n$$\n-\\partial_s q^\\dagger(\\mathbf{r},s) = \\frac{b^2}{6}\\nabla^2 q^\\dagger(\\mathbf{r},s) - w(\\mathbf{r},s)\\, q^\\dagger(\\mathbf{r},s), \\qquad q^\\dagger(\\mathbf{r},1)=1,\n$$\n其中，当 $s \\in [0,f]$ 时，$w(\\mathbf{r},s)=w_A(\\mathbf{r})$；当 $s \\in (f,1]$ 时，$w(\\mathbf{r},s)=w_B(\\mathbf{r})$。\n- 单链配分函数为 $Q=\\int_\\Omega q(\\mathbf{r},1)\\, d\\mathbf{r}$。\n- 单体密度为\n$$\n\\phi_A(\\mathbf{r}) = \\frac{1}{Q}\\int_0^f q(\\mathbf{r},s)\\, q^\\dagger(\\mathbf{r},s)\\, ds, \\qquad\n\\phi_B(\\mathbf{r}) = \\frac{1}{Q}\\int_f^1 q(\\mathbf{r},s)\\, q^\\dagger(\\mathbf{r},s)\\, ds.\n$$\n- 可压缩 SCF 方程为\n$$\nw_A(\\mathbf{r}) = \\chi N\\, \\phi_B(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big),\n$$\n$$\nw_B(\\mathbf{r}) = \\chi N\\, \\phi_A(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big).\n$$\n\n定义残差映射 $\\mathbf{R}[\\mathbf{w}] = (R_A,R_B)$，其分量为\n$$\nR_A(\\mathbf{r}) = w_A(\\mathbf{r}) - \\chi N\\, \\phi_B(\\mathbf{r}) - \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big),\n$$\n$$\nR_B(\\mathbf{r}) = w_B(\\mathbf{r}) - \\chi N\\, \\phi_A(\\mathbf{r}) - \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big).\n$$\n\n您的任务是通过 Picard 定点迭代法或 Newton–Krylov 方法求解 $\\mathbf{R}[\\mathbf{w}]=\\mathbf{0}$。在无矩阵 Newton–Krylov 方法中，Krylov 子空间迭代仅需要雅可比-向量积 $\\mathbf{J}[\\mathbf{w}]\\, \\mathbf{v}$，其中 $\\mathbf{J}[\\mathbf{w}]$ 是 $\\mathbf{R}$ 在 $\\mathbf{w}$ 处对给定方向 $\\mathbf{v}=(v_A,v_B)$ 的 Fréchet 导数。\n\n关于这些 SCF 方程的 Picard 方法与 Newton–Krylov 方法的收敛行为，以及在无矩阵实现中雅可比-向量积的正确构造，以下哪个陈述是正确的？\n\nA. 采用单位混合的 Picard 迭代，$w^{(k+1)}=\\chi N\\, \\phi[w^{(k)}] + \\kappa N\\, (\\phi_A[w^{(k)}]+\\phi_B[w^{(k)}]-1)$，对于任何 $\\chi N>0$ 和任何空间离散化都是无条件收敛的，因为 Helfand 罚项使得该映射成为一个收缩映射。\n\nB. Newton–Krylov 方法必须显式地构建和存储完整的雅可比矩阵 $\\mathbf{J}[\\mathbf{w}]$；否则，每个牛顿步内的线性求解将是病态的。\n\nC. 对于此问题，在无矩阵 Newton–Krylov 方法中，雅可比-向量积 $\\mathbf{J}[\\mathbf{w}]\\, \\mathbf{v}$ 的分量为\n$$\n(\\mathbf{J}\\mathbf{v})_A = v_A - \\chi N\\, \\delta \\phi_B[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big),\\quad\n(\\mathbf{J}\\mathbf{v})_B = v_B - \\chi N\\, \\delta \\phi_A[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big),\n$$\n其中，密度在方向 $\\mathbf{v}$ 上的 Fréchet 导数通过求解线性化的正向和反向修正扩散方程\n$$\n\\partial_s \\,\\delta q = \\frac{b^2}{6}\\nabla^2 \\delta q - w\\, \\delta q - v_w(s)\\, q,\\qquad \\delta q(\\mathbf{r},0)=0,\n$$\n$$\n-\\partial_s \\,\\delta q^\\dagger = \\frac{b^2}{6}\\nabla^2 \\delta q^\\dagger - w\\, \\delta q^\\dagger - v_w(s)\\, q^\\dagger,\\qquad \\delta q^\\dagger(\\mathbf{r},1)=0,\n$$\n计算得到，其中当 $s \\in [0,f]$ 时 $v_w(s)=v_A$，当 $s \\in (f,1]$ 时 $v_w(s)=v_B$，随后进行\n$$\n\\delta Q = \\int_\\Omega \\delta q(\\mathbf{r},1)\\, d\\mathbf{r},\\quad\n\\delta \\phi_A(\\mathbf{r}) = \\frac{1}{Q}\\int_0^f \\big(\\delta q\\, q^\\dagger + q\\, \\delta q^\\dagger\\big)\\, ds - \\frac{\\delta Q}{Q}\\, \\phi_A(\\mathbf{r}),\n$$\n$$\n\\delta \\phi_B(\\mathbf{r}) = \\frac{1}{Q}\\int_f^1 \\big(\\delta q\\, q^\\dagger + q\\, \\delta q^\\dagger\\big)\\, ds - \\frac{\\delta Q}{Q}\\, \\phi_B(\\mathbf{r}).\n$$\n\nD. Fréchet 导数 $\\delta \\phi/\\delta w$ 在空间上是逐点局域的；也就是说，$\\delta \\phi_\\alpha(\\mathbf{r})$ 仅依赖于同一位置 $\\mathbf{r}$ 处的 $\\delta w_\\beta(\\mathbf{r})$，因为修正扩散方程在场上是乘性的。\n\nE. 在使用拉格朗日乘子强制执行 $\\phi_A+\\phi_B=1$ 的不可压缩表述中，归一化因子 $Q$ 变得与场无关，因此可以从 $\\delta \\phi_\\alpha$ 的表达式中舍去 $-(\\delta Q/Q)\\, \\phi_\\alpha$ 项，而不影响 Newton–Krylov 的收敛性。", "solution": "问题陈述给出了可压缩双嵌段共聚物熔体的自洽场理论（SCFT）的标准表述。它详细说明了控制传播子、单体密度和平均场势的方程。任务是评估关于通过 Picard 和 Newton–Krylov 方法对这些方程进行数值求解的陈述。\n\n### 问题验证\n给定问题是计算高分子物理领域中一个定义明确的标准问题。\n- **提取的已知条件**：问题提供了可压缩 SCFT模型的所有必要组成部分：传播子 $q$ 和 $q^\\dagger$ 的修正扩散方程，用传播子表示的单体密度 $\\phi_A$ 和 $\\phi_B$ 的定义，闭合自洽循环的化学势场 $w_A$ 和 $w_B$ 的表达式，以及残差向量 $\\mathbf{R}[\\mathbf{w}]$ 的定义。所有参数（$\\chi N$, $\\kappa N$, $f$, $b$）和变量都已明确定义。\n- **验证检查**：\n    - **科学依据**：所呈现的理论是用于高斯链的标准 Edwards-Helfand 模型，它是现代高分子理论的基石。它在事实上和科学上都是合理的。\n    - **适定性**：该方程组是一个标准的非线性边值问题。寻找其解是一项适定的任务，适合使用数值方法。\n    - **客观性**：问题以精确的数学语言陈述，没有任何主观性。\n    - **完整性和一致性**：所有必要的方程和定义都已提供，构成一个自洽的问题。这些关系与高分子统计力学的原理一致。\n    - **无其他缺陷**：该问题并非无足轻重、不切实际或病态的。\n\n**结论**：问题陈述有效。我们可以继续进行求解。\n\n### 逐项分析\n\n**A. 采用单位混合的 Picard 迭代，$w^{(k+1)}=\\chi N\\, \\phi[w^{(k)}] + \\kappa N\\, (\\phi_A[w^{(k)}]+\\phi_B[w^{(k)}]-1)$，对于任何 $\\chi N0$ 和任何空间离散化都是无条件收敛的，因为 Helfand 罚项使得该映射成为一个收缩映射。**\n\n该陈述是错误的。形如 $\\mathbf{w}^{(k+1)} = \\mathcal{F}[\\mathbf{w}^{(k)}]$ 的 Picard 迭代在映射 $\\mathcal{F}$ 是一个收缩映射时收敛，这要求其雅可比矩阵的谱半径 $\\rho(\\delta\\mathcal{F}/\\delta\\mathbf{w})$ 小于1。在 SCFT 中，映射 $\\mathcal{F}$ 由计算密度 $\\phi[\\mathbf{w}]$ 然后更新场的运算组成。此映射的雅可比矩阵与高分子敏感性张量有关。\n与 $\\chi N$ 成正比的项驱动微相分离，并且本质上是不稳定的。对于足够大的 $\\chi N$，雅可比矩阵的某些特征值将超过1，特别是对于波矢为 $q^*$（对应于新出现的微结构畴区尺寸）的涨落模式。带有 $\\kappa N > 0$ 的 Helfand 罚项会惩罚偏离不可压缩性的情况，并通常抑制长波（$q \\to 0$）涨落。然而，它并不能保证对由 $\\chi N$ 驱动的有限 $q^*$ 不稳定性提供稳定作用。因此，众所周知，简单的 Picard 迭代（也称为简单混合）仅是有条件稳定的，并且通常在有序-无序转变（ODT）附近以及在强分离区域失效，无论 $\\kappa N$ 的值是多少。无条件收敛的说法是错误的。\n\n**结论**：错误。\n\n**B. Newton–Krylov 方法必须显式地构建和存储完整的雅可比矩阵 $\\mathbf{J}[\\mathbf{w}]$；否则，每个牛顿步内的线性求解将是病态的。**\n\n这个陈述是根本错误的，并曲解了 Newton-Krylov 方法的本质。求解 $\\mathbf{R}[\\mathbf{w}]=\\mathbf{0}$ 的一个牛顿步需要求解线性系统 $\\mathbf{J}[\\mathbf{w}^{(k)}] \\Delta \\mathbf{w} = -\\mathbf{R}[\\mathbf{w}^{(k)}]$ 以获得更新量 $\\Delta \\mathbf{w}$，其中 $\\mathbf{J}$ 是 $\\mathbf{R}$ 的雅可比矩阵。Krylov 子空间方法（如 GMRES）是求解此类线性系统的迭代算法。Krylov 方法的一个关键特征是，它们不需要访问矩阵 $\\mathbf{J}$ 本身的元素。它们只需要能够计算矩阵作用于向量的结果，即矩阵-向量积 $\\mathbf{J}\\mathbf{v}$。\nNewton-Krylov 求解器的“无矩阵”实现正是利用了这一特性，通过提供一个子程序来计算 $\\mathbf{J}\\mathbf{v}$，而无需构建或存储完整的矩阵 $\\mathbf{J}$。这在 SCFT 中尤为关键，因为雅可比矩阵是一个庞大而密集的矩阵，其存储和求逆在计算上是难以承受的。线性系统的适定性取决于雅可比算子 $\\mathbf{J}$ 的属性（例如条件数），而不是其在内存中的显式表示。该陈述本身就是自相矛盾的。\n\n**结论**：错误。\n\n**C. 对于此问题，在无矩阵 Newton–Krylov 方法中，雅可比-向量积 $\\mathbf{J}[\\mathbf{w}]\\, \\mathbf{v}$ 的分量为... [后面跟着一组看起来正确的方程]。**\n\n为了验证此陈述，我们必须推导雅可比-向量积的表达式，它是残差 $\\mathbf{R}$ 在向量 $\\mathbf{v} = (v_A, v_B)$ 方向上的 Gâteaux 导数。\n残差是 $\\mathbf{R}[\\mathbf{w}] = \\mathbf{w} - \\mathcal{F}[\\mathbf{w}]$，其中 $\\mathcal{F}$ 是 SCF 方程的右侧：\n$$\n\\mathcal{F}_A(\\mathbf{r}) = \\chi N\\, \\phi_B(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big)\n$$\n$$\n\\mathcal{F}_B(\\mathbf{r}) = \\chi N\\, \\phi_A(\\mathbf{r}) + \\kappa N\\, \\big(\\phi_A(\\mathbf{r})+\\phi_B(\\mathbf{r}) - 1\\big)\n$$\n雅可比-向量积是 $\\mathbf{J}\\mathbf{v} = (\\delta \\mathbf{R}/\\delta \\mathbf{w})\\mathbf{v} = \\mathbf{v} - (\\delta \\mathcal{F}/\\delta \\mathbf{w})\\mathbf{v}$。让我们将泛函 $X$ 在方向 $\\mathbf{v}$ 上的方向导数表示为 $\\delta X[\\mathbf{v}]$。那么我们需要计算 $\\delta \\mathcal{F}[\\mathbf{v}]$。\n使用链式法则，我们找到 $\\delta \\mathcal{F}[\\mathbf{v}]$ 的分量：\n$$\n(\\delta \\mathcal{F}[\\mathbf{v}])_A = \\chi N\\, \\delta \\phi_B[\\mathbf{v}] + \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\n$$\n(\\delta \\mathcal{F}[\\mathbf{v}])_B = \\chi N\\, \\delta \\phi_A[\\mathbf{v}] + \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\n因此，雅可比-向量积的分量为：\n$$\n(\\mathbf{J}\\mathbf{v})_A = v_A - \\chi N\\, \\delta \\phi_B[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\n$$\n(\\mathbf{J}\\mathbf{v})_B = v_B - \\chi N\\, \\delta \\phi_A[\\mathbf{v}] - \\kappa N\\, \\big(\\delta \\phi_A[\\mathbf{v}] + \\delta \\phi_B[\\mathbf{v}]\\big)\n$$\n这与陈述的第一部分相符。现在，我们必须验证计算 $\\delta \\phi_A[\\mathbf{v}]$ 和 $\\delta \\phi_B[\\mathbf{v}]$ 的过程。这些是密度的方向导数。我们从求传播子的导数 $\\delta q[\\mathbf{v}]$ 和 $\\delta q^\\dagger[\\mathbf{v}]$ 开始。\n设 $w_\\epsilon(\\mathbf{r},s) = w(\\mathbf{r},s) + \\epsilon v_w(\\mathbf{r},s)$，其中当 $s \\le f$ 时 $v_w=v_A$，当 $s  f$ 时 $v_w=v_B$。设 $q_\\epsilon$ 为对应 $w_\\epsilon$ 的解。对传播子方程 $\\partial_s q_\\epsilon = \\frac{b^2}{6}\\nabla^2 q_\\epsilon - w_\\epsilon q_\\epsilon$ 关于 $\\epsilon$ 在 $\\epsilon=0$ 处求导，得到：\n$$\n\\partial_s (\\delta q) = \\frac{b^2}{6}\\nabla^2 (\\delta q) - w (\\delta q) - v_w q\n$$\n初始条件 $q(\\mathbf{r},0)=1$ 与场无关，所以 $\\delta q(\\mathbf{r},0)=0$。这与 $\\delta q$ 的方程相符。对 $q^\\dagger$ 进行类似的推导，其最终条件为 $q^\\dagger(\\mathbf{r},1)=1$，得到：\n$$\n-\\partial_s (\\delta q^\\dagger) = \\frac{b^2}{6}\\nabla^2 (\\delta q^\\dagger) - w (\\delta q^\\dagger) - v_w q^\\dagger \\quad \\text{其中} \\quad \\delta q^\\dagger(\\mathbf{r},1)=0\n$$\n这与 $\\delta q^\\dagger$ 的方程相符。接下来，我们对 $Q = \\int_\\Omega q(\\mathbf{r},1)\\, d\\mathbf{r}$ 求导得到 $\\delta Q = \\int_\\Omega \\delta q(\\mathbf{r},1)\\, d\\mathbf{r}$，这也是正确的。\n最后，我们使用商法则和积法则对 $\\phi_A = \\frac{1}{Q}\\int_0^f q\\, q^\\dagger\\, ds$ 求导：\n$$\n\\delta \\phi_A = \\frac{\\delta \\left(\\int_0^f q q^\\dagger ds\\right)}{Q} - \\frac{\\int_0^f q q^\\dagger ds}{Q^2} \\delta Q = \\frac{1}{Q} \\int_0^f (\\delta q \\, q^\\dagger + q \\, \\delta q^\\dagger) ds - \\frac{\\phi_A}{Q} \\delta Q\n$$\n这与 $\\delta \\phi_A$ 的表达式相符。$\\delta \\phi_B$ 的表达式可以同样推导得出。陈述的所有部分都从泛函微积分的第一性原理正确推导出来。\n\n**结论**：正确。\n\n**D. Fréchet 导数 $\\delta \\phi/\\delta w$ 在空间上是逐点局域的；也就是说，$\\delta \\phi_\\alpha(\\mathbf{r})$ 仅依赖于同一位置 $\\mathbf{r}$ 处的 $\\delta w_\\beta(\\mathbf{r})$，因为修正扩散方程在场上是乘性的。**\n\n该陈述是错误的。算子 $\\delta\\phi/\\delta w$ 被称为敏感性函数或响应函数，常表示为 $\\chi_{\\alpha\\beta}(\\mathbf{r}, \\mathbf{r}') = \\delta\\phi_\\alpha(\\mathbf{r})/\\delta w_\\beta(\\mathbf{r}')$。局域性将意味着 $\\chi_{\\alpha\\beta}(\\mathbf{r}, \\mathbf{r}') \\propto \\delta(\\mathbf{r}-\\mathbf{r}')$。这不是真的。传播子的修正扩散方程包含拉普拉斯算子 $\\nabla^2$。该算子耦合了相邻的空间点，导致场 $w(\\mathbf{r}')$ 在一点的影响随着链轮廓变量 $s$ 的演化而扩散到整个空间域。因此，传播子 $q(\\mathbf{r},s)$ 和 $q^\\dagger(\\mathbf{r},s)$ 是场 $w$ 的非局域泛函。由于密度 $\\phi_\\alpha(\\mathbf{r})$ 是由这些非局域传播子构建的，因此它们也是 $w$ 的非局域泛函。在单个点 $\\mathbf{r}'$ 的扰动 $\\delta w_\\beta(\\mathbf{r}')$ 将导致整个域上的变化 $\\delta \\phi_\\alpha(\\mathbf{r})$。关于方程在场上是乘性（$w\\,q$）的论点是无关紧要的，因为空间导数项 $\\nabla^2 q$ 的存在使得整个响应成为非局域的。\n\n**结论**：错误。\n\n**E. 在使用拉格朗日乘子强制执行 $\\phi_A+\\phi_B=1$ 的不可压缩表述中，归一化因子 $Q$ 变得与场无关，因此可以从 $\\delta \\phi_\\alpha$ 的表达式中舍去 $-(\\delta Q/Q)\\, \\phi_\\alpha$ 项，而不影响 Newton–Krylov 的收敛性。**\n\n该陈述包含多个不准确之处。首先，在任何 SCFT 表述中，$Q = \\int_\\Omega q(\\mathbf{r},1)\\,d\\mathbf{r}$ 都是场 $w_\\alpha$ 的一个泛函，因为 $q$ 是由 $w_\\alpha$ 决定的。使用不可压缩表述并不会使 $Q$ 与场无关。在 SCFT 中存在规范自由度：如果适当调整自由能，物理体系在场的均匀平移 $w_\\alpha(\\mathbf{r}) \\to w_\\alpha(\\mathbf{r}) + C_\\alpha$ 下是不变的。人们可以利用这种自由度来强制执行像 $\\int_\\Omega (w_A - w_B) d\\mathbf{r} = 0$ 这样的条件，或者在某些情况下，将 $Q$ 的值固定为 $1$。然而，通过规范选择来固定 $Q$ 并不意味着它对任意场变化的导数为零。牛顿步中的一般场更新 $\\delta\\mathbf{w}$ 不会是一个简单的均匀平移，因此它会改变 $Q$ 的值；故 $\\delta Q \\neq 0$。$Q$ 变得“与场无关”的前提是错误的。\n其次，即使忽略这一点并舍去 $-(\\delta Q/Q)\\phi_\\alpha$ 项，使用的也将不再是真正的雅可比矩阵。这会将 Newton 方法修改为一种准 Newton 方法。这种近似会降低收敛性质。真正的 Newton-Raphson 方法在解附近具有二次收敛性。一个近似的雅可比矩阵通常最多只能导致线性收敛速率，并且在完整 Newton 方法本可以收敛的情况下，它很容易导致发散。因此，舍去该项肯定会“影响 Newton–Krylov 的收敛性”。\n\n**结论**：错误。", "answer": "$$\\boxed{C}$$", "id": "2927269"}, {"introduction": "最后的这项综合实践将前面所学的知识融会贯通。您将应用已掌握的数值技术，对经典的嵌段共聚物体系进行一次完整的SCFT模拟。本练习特别强调了科学计算的一个关键环节：通过网格细化研究来验证结果的准确性。这能确保我们计算出的自由能和密度分布等物理量是可靠且有意义的，从而将数值输出与真实的物理洞见联系起来。[@problem_id:2927297]", "problem": "考虑一个周期性区域中形成层状形貌的对称双嵌段共聚物熔体的一维自洽场理论 (SCFT)。其目的是通过网格加密研究，来量化鞍点单链自由能和单体密度分布相对于空间分辨率的收敛性。使用以下基本依据和定义。\n\n一个总链节长度缩放为单位一的高斯链双嵌段共聚物，其 A 嵌段的分数为 $f$，B 嵌段的分数为 $1 - f$。在平均场近似下，外部场中单链传播子 $q(s,z)$ 满足修正的扩散方程\n$$\n\\frac{\\partial q}{\\partial s} = \\nabla^2 q - w_\\alpha(z)\\, q,\n$$\n其中 $s \\in [0,1]$ 是链节变量，$z \\in [0,L)$ 是空间坐标，$w_\\alpha(z)$ 是作用在 $\\alpha \\in \\{\\mathrm{A}, \\mathrm{B}\\}$ 类型链段上的自洽场。该体系是不可压缩的，因此总单体密度受以下约束\n$$\n\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1.\n$$\n通过 $w_\\mathrm{A} = w_+(z) - w_-(z)$ 和 $w_\\mathrm{B} = w_+(z) + w_-(z)$ 引入交换场 $w_-(z)$ 和类压强场 $w_+(z)$。Flory–Huggins 不相容参数为 $\\chi N$，鞍点条件强制要求\n$$\nw_-(z) = \\chi N \\left[\\phi_\\mathrm{B}(z) - \\phi_\\mathrm{A}(z)\\right],\n\\quad\n\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1.\n$$\n正向传播子满足 $q(0,z) = 1$，相应的反向传播子 $q^\\dagger(s,z)$ 满足 $q^\\dagger(1,z) = 1$，并且沿相应的嵌段类型应用相同的修正扩散算子。单链配分函数为\n$$\nQ = \\frac{1}{L} \\int_0^L q(1,z)\\, dz,\n$$\n嵌段密度由传播子得到\n$$\n\\phi_\\mathrm{A}(z) = \\frac{1}{Q} \\int_0^f q(s,z)\\, q^\\dagger(s,z)\\, ds,\\qquad\n\\phi_\\mathrm{B}(z) = \\frac{1}{Q} \\int_f^1 q(s,z)\\, q^\\dagger(s,z)\\, ds.\n$$\n所有方程都以无量纲单位书写，通过用回转半径缩放长度，使得拉普拉斯算子前置因子为一，自由能以玻尔兹曼常数乘以温度 $k_\\mathrm{B} T$ 为单位。\n\n任务。从这些定义出发，完成以下任务。\n\n1) 使用 $N_x$ 个点的均匀网格离散化具有周期性边界条件的空间域 $[0,L)$。使用 $M$ 个均匀步长离散化链节变量 $s \\in [0,1]$。在空间上使用伪谱方法，在 $s$ 上使用 Strang 分裂法进行传播子演化。Strang 分裂应在实空间场乘法的半步和傅里叶空间扩散算子的全步之间交替进行。从修正的扩散方程推导出该算法，并解释为什么它在链节步长上是二阶精度的。\n\n2) 实现一个不动点迭代格式来求解自洽方程中的 $w_-(z)$ 和 $w_+(z)$，并满足不可压缩性约束。对两个场都使用欠松弛更新。施加规范条件，即在每次迭代中 $w_+(z)$ 的空间平均值为零。在规范 $\\langle w_+ \\rangle = 0$ 下，推导鞍点单链自由能 $F$ 的一个规范不变表达式，该表达式纯粹用 $Q$、$w_-(z)$ 和已知常数表示。以每条链 $k_\\mathrm{B} T$ 为单位表示最终的 $F$ 值。\n\n3) 通过一个与盒子中单个层片相符的基波波数的小振幅正弦波来初始化交换场 $w_-(z)$，并将 $w_+(z)$ 初始设为零，从而建立一个层状结构。迭代直至收敛。\n\n4) 网格加密研究。除了 $N_x$ 外，对所有分辨率使用相同的物理和数值参数。计算每个 $N_x$ 下收敛的 $F$ 和收敛的 $\\phi_\\mathrm{A}(z)$。使用最精细的网格作为参考，并按如下方式量化较粗糙网格上的误差：\n- 自由能误差：$\\Delta F(N_x) = F(N_x) - F(N_{\\mathrm{ref}})$。\n- 密度误差：对于 $N_x$ 能整除 $N_{\\mathrm{ref}}$ 的网格，在共同的网格点上比较 $\\phi_\\mathrm{A}(z)$（即将参考分布降采样到粗糙网格上），并计算相对离散 $L^2$ 误差\n$$\n\\mathcal{E}(N_x) = \\left( \\frac{\\sum_j \\left[\\phi_\\mathrm{A}^{(N_x)}(z_j) - \\phi_\\mathrm{A}^{(N_{\\mathrm{ref}})}(z_j)\\right]^2}{\\sum_j \\left[\\phi_\\mathrm{A}^{(N_{\\mathrm{ref}})}(z_j)\\right]^2} \\right)^{1/2}.\n$$\n\n使用以下参数测试套件：\n- 物理参数：$f = 0.5$，$\\chi N = 20.0$，区域长度 $L = 4.0$（无量纲），区域内一个层状周期。\n- 数值参数：$M = 100$（偶数），最大迭代次数 $200$，欠松弛参数 $\\alpha_+ = 0.10$ 和 $\\alpha_- = 0.10$，两个自洽条件的均方根残差收敛容差为 $10^{-6}$。\n- 空间分辨率：$N_x \\in \\{32, 48, 64, 96, 192\\}$，以 $N_{\\mathrm{ref}} = 192$ 作为参考。\n\n最终输出。您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来。具体来说，按此顺序报告每个粗糙网格（不包括参考网格）的自由能误差 $\\Delta F$ 和相对 $L^2$ 密度误差 $\\mathcal{E}$，并按 $N_x$ 递增的顺序排列。格式如下：\n$$\n[\\Delta F(32),\\, \\mathcal{E}(32),\\, \\Delta F(48),\\, \\mathcal{E}(48),\\, \\Delta F(64),\\, \\mathcal{E}(64),\\, \\Delta F(96),\\, \\mathcal{E}(96)].\n$$\n所有自由能必须以每条链 $k_\\mathrm{B} T$ 为单位表示，密度误差是无量纲的。数值应以十进制浮点数的形式在一行中按所描述的精确列表格式打印。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   **系统**：对称双嵌段共聚物熔体，A 嵌段分数为 $f$，B 嵌段分数为 $1-f$，在长度为 $L$ 的周期性区域中形成一维层状结构。\n-   **控制方程**：对于链节 $s \\in [0,1]$ 和位置 $z \\in [0,L)$，单链传播子 $q(s,z)$ 的演化遵循修正的扩散方程：$\\frac{\\partial q}{\\partial s} = \\nabla^2 q - w_\\alpha(z)\\, q$，其中 $w_\\alpha(z)$ 是对 $\\alpha \\in \\{\\mathrm{A}, \\mathrm{B}\\}$ 类型嵌段的平均场。\n-   **初始/边界条件**：正向传播子 $q(0,z) = 1$，反向传播子 $q^\\dagger(1,z) = 1$。在 $z$ 方向上为周期性边界条件。\n-   **自洽性**：系统不可压缩，$\\phi_\\mathrm{A}(z) + \\phi_\\mathrm{B}(z) = 1$。场通过 $w_\\mathrm{A}(z) = w_+(z) - w_-(z)$ 和 $w_\\mathrm{B}(z) = w_+(z) + w_-(z)$ 相关联。鞍点条件为 $w_-(z) = \\chi N \\left[\\phi_\\mathrm{B}(z) - \\phi_\\mathrm{A}(z)\\right]$ 以及不可压缩性约束。\n-   **可观测量**：单链配分函数 $Q = \\frac{1}{L} \\int_0^L q(1,z)\\, dz$。嵌段密度为 $\\phi_\\mathrm{A}(z) = \\frac{1}{Q} \\int_0^f q(s,z)\\, q^\\dagger(s,z)\\, ds$ 和 $\\phi_\\mathrm{B}(z) = \\frac{1}{Q} \\int_f^1 q(s,z)\\, q^\\dagger(s,z)\\, ds$。\n-   **单位**：无量纲，长度以回转半径为单位缩放，能量以 $k_\\mathrm{B} T$ 为单位。\n-   **任务 1 (算法)**：使用 $N_x$ 个空间网格点和 $M$ 个链节步长离散化区域。推导并解释用于传播子演化的带有二阶 Strang 分裂的伪谱算法。\n-   **任务 2 (理论)**：实现不动点迭代。在规范 $\\langle w_+ \\rangle = 0$ 下，推导鞍点单链自由能 $F$ 的一个规范不变表达式。\n-   **任务 3 (初始化)**：用周期为 $L$ 的小振幅正弦波初始化 $w_-(z)$，并设 $w_+(z) = 0$。\n-   **任务 4 (网格研究)**：\n    -   物理参数：$f = 0.5$，$\\chi N = 20.0$，$L = 4.0$。\n    -   数值参数：$M = 100$，最大迭代次数 $= 200$，欠松弛 $\\alpha_+ = \\alpha_- = 0.10$，容差 $= 10^{-6}$。\n    -   空间分辨率：$N_x \\in \\{32, 48, 64, 96, 192\\}$，其中 $N_{\\mathrm{ref}} = 192$。\n    -   误差度量：自由能误差 $\\Delta F(N_x) = F(N_x) - F(N_{\\mathrm{ref}})$ 和相对 $L^2$ 密度误差 $\\mathcal{E}(N_x)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行分析。\n-   **科学基础**：该问题是自洽场理论 (SCFT) 在双嵌段共聚物中的一个标准应用，这是高分子物理中的一个基础模型。其方程和概念是教科书材料（例如，Matsen Schick, 1994）。该框架在科学上是合理的。\n-   **良构性**：任务是找到一个自由能泛函的鞍点，这是一个明确定义的数学目标。指定的迭代数值方案是解决此类问题的标准且稳健的方法。已知的参数集会导致稳定的层状相，确保有意义的解存在。\n-   **客观性**：问题以精确、定量和无偏的数学语言陈述。所有术语都有定义。\n-   **完整性**：所有必需的物理和数值参数、初始条件和收敛标准都已提供。网格加密研究的误差度量有明确定义。\n-   **一致性**：定义和约束是自洽的。场 $w_-$ 和 $w_+$ 的定义及其与嵌段密度的关系被清晰陈述，并构成一个封闭的方程组。网格分辨率 $N_x$ 的选择使得较粗的网格是参考网格的因子，这与密度误差度量的定义相一致。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是一个在计算高分子物理领域中良构、有科学依据且完整的问题。将提供一个解决方案。\n\n### 求解与推导\n\n该问题要求推导数值算法和自由能表达式，然后进行计算实现。\n\n**1. 带有 Strang 分裂的伪谱算法**\n\n传播子 $q(s,z)$ 的演化由修正的扩散方程控制：\n$$\n\\frac{\\partial q}{\\partial s} = \\left(\\nabla^2 - w(z)\\right) q \\equiv (\\hat{A} + \\hat{B}) q\n$$\n在这里，算子被分为扩散部分 $\\hat{A} = \\nabla^2$ 和反应部分 $\\hat{B} = -w(z)$。算子 $\\hat{A}$ 和 $\\hat{B}$ 不对易，因为 $[\\hat{A}, \\hat{B}]q = \\nabla^2(-wq) - (-w)\\nabla^2q \\neq 0$。这种非对易性阻止了简单的指数解 $e^{\\Delta s \\hat{A}}e^{\\Delta s \\hat{B}}$。\n\n伪谱方法非常适合这种结构。扩散算子 $\\hat{A}$ 在傅里叶空间中是一个简单的乘法（$\\hat{A} \\rightarrow -k^2$），而反应算子 $\\hat{B}$ 在实空间中是一个局域乘法。\n\n一种对称的算子分裂方法，称为 Strang 分裂，可提供链节步长 $\\Delta s$ 的二阶精度。在一个步长上的形式解 $q(s+\\Delta s) = e^{\\Delta s(\\hat{A}+\\hat{B})} q(s)$，近似为：\n$$\nq(s+\\Delta s) \\approx e^{\\frac{\\Delta s}{2}\\hat{B}} e^{\\Delta s\\hat{A}} e^{\\frac{\\Delta s}{2}\\hat{B}} q(s)\n$$\n为证明其二阶精度，我们展开指数算子。精确的演化算子是 $e^{\\Delta s (\\hat{A}+\\hat{B})} = 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}+\\hat{B})^2 + O(\\Delta s^3)$。Strang 分裂近似展开为：\n$$\n\\left(1 + \\frac{\\Delta s}{2}\\hat{B} + \\frac{\\Delta s^2}{8}\\hat{B}^2\\right) \\left(1 + \\Delta s\\hat{A} + \\frac{\\Delta s^2}{2}\\hat{A}^2\\right) \\left(1 + \\frac{\\Delta s}{2}\\hat{B} + \\frac{\\Delta s^2}{8}\\hat{B}^2\\right) + O(\\Delta s^3)\n$$\n$$\n= 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}^2 + \\hat{B}^2 + \\hat{A}\\hat{B} + \\hat{B}\\hat{A}) + O(\\Delta s^3)\n$$\n$$\n= 1 + \\Delta s(\\hat{A}+\\hat{B}) + \\frac{\\Delta s^2}{2}(\\hat{A}+\\hat{B})^2 + O(\\Delta s^3)\n$$\n该近似与精确展开在 $\\Delta s^2$ 阶项上匹配，意味着局部截断误差为 $O(\\Delta s^3)$。对于总链节长度为 1 的积分，使用 $M = 1/\\Delta s$ 步，全局误差为 $M \\times O(\\Delta s^3) = O(\\Delta s^2)$，因此该方法是二阶精度的。\n\n单步的算法实现如下：\n1.  实空间半步：$q' = e^{-\\frac{\\Delta s}{2}w(z)} q(z)$。\n2.  变换到傅里叶空间：$\\tilde{q}' = \\mathcal{F}[q']$。\n3.  傅里叶空间全步：$\\tilde{q}'' = e^{-k^2 \\Delta s} \\tilde{q}'$。\n4.  变换回实空间：$q'' = \\mathcal{F}^{-1}[\\tilde{q}'']$。\n5.  实空间第二次半步：$q_{new} = e^{-\\frac{\\Delta s}{2}w(z)} q''$。\n\n反向传播子 $q^\\dagger(s,z)$ 的形式必须确保数值稳定性。其标准控制方程为 $-\\frac{\\partial q^\\dagger}{\\partial s} = (\\nabla^2 - w)q^\\dagger$。令 $s' = 1-s$。方程变换为 $\\frac{\\partial q^\\dagger}{\\partial s'} = (\\nabla^2 - w(1-s'))q^\\dagger$，这在形式上与正向传播子方程相同。因此，使用相同的稳定数值方案从 $s'=0$（物理 $s=1$）演化到 $s'=1$（物理 $s=0$），但嵌段场 $w_B$ 和 $w_A$ 以相反的顺序应用。\n\n**2. 鞍点自由能**\n\n自洽场方程源于寻找一个自由能泛函 $F[w_-, w_+]$ 的鞍点。我们构建一个泛函，使其对场的极值化能够产生给定的自洽条件。单链配分函数部分 $-\\ln Q$ 对场的泛函导数为 $\\frac{\\delta(-\\ln Q)}{\\delta w_\\alpha} = \\phi_\\alpha$。用变换后的场表示：\n$$\n\\frac{\\delta(-\\ln Q)}{\\delta w_+} = \\phi_A + \\phi_B \\quad , \\quad \\frac{\\delta(-\\ln Q)}{\\delta w_-} = \\phi_B - \\phi_A\n$$\n考虑以下形式的单链自由能泛函：\n$$\nF[w_-, w_+] = -\\ln Q + \\frac{1}{L} \\int_0^L \\left( \\frac{w_-^2(z)}{2\\chi N} - w_+(z) \\right) dz\n$$\n对 $w_+$ 和 $w_-$ 进行极值化，得到鞍点方程：\n$$\n\\frac{\\delta F}{\\delta w_+(z)} = -1 + (\\phi_A(z) + \\phi_B(z)) = 0 \\implies \\phi_A(z) + \\phi_B(z) = 1\n$$\n$$\n\\frac{\\delta F}{\\delta w_-(z)} = \\frac{w_-(z)}{\\chi N} - (\\phi_B(z) - \\phi_A(z)) = 0 \\implies w_-(z) = \\chi N (\\phi_B(z) - \\phi_A(z))\n$$\n这些恰好与问题中指定的自洽和不可压缩条件相匹配。该泛函在鞍点的值即为所求的每条链的亥姆霍兹自由能。此表达式是规范不变的。一个位移 $w_+(z) \\to w_+(z) + C_0$ 导致 $q(s,z) \\to q(s,z)e^{-s C_0}$，$Q \\to Q e^{-C_0}$，以及 $-\\ln Q \\to -\\ln Q + C_0$。项 $-\\frac{1}{L}\\int w_+(z) dz$ 位移了 $-C_0$，这恰好抵消了来自 $-\\ln Q$ 的位移。\n问题指定了规范条件，即 $w_+(z)$ 的空间平均值为零，$\\langle w_+ \\rangle = \\frac{1}{L}\\int_0^L w_+(z) dz = 0$。在此规范下，$w_+$ 的积分消失，自由能表达式简化为：\n$$\nF = -\\ln Q + \\frac{1}{2\\chi N L} \\int_0^L w_-^2(z) dz = -\\ln Q + \\frac{1}{2\\chi N} \\langle w_-^2 \\rangle\n$$\n该表达式以每条链 $k_\\mathrm{B} T$ 为单位，将用于计算。不动点迭代更新 $w_-$ 和 $w_+$ 以驱动系统趋向此鞍点。使用带欠松弛的简单 Picard 迭代：\n$w_-^{(k+1)} = (1-\\alpha_-)w_-^{(k)} + \\alpha_- \\left[\\chi N(\\phi_B^{(k)}-\\phi_A^{(k)})\\right]$\n$w_+^{(k+1)} = w_+^{(k)} - \\alpha_+(\\phi_A^{(k)}+\\phi_B^{(k)}-1) - \\langle w_+^{(k)} - \\alpha_+(\\phi_A^{(k)}+\\phi_B^{(k)}-1) \\rangle$\n$w_+$ 的更新是基于不可压缩性误差的简单反馈，然后重新施加规范条件。\n\n**3. 实现与网格加密**\n\n所述算法在 Python 中实现。传播子沿离散化的链节演化，并存储每一步的值。通过对乘积 $q(s,z)q^\\dagger(s,z)$ 在各自嵌段区域上进行数值积分（梯形法则）来计算密度。SCFT 循环被迭代，直到两个自洽条件的均方根残差低于 $10^{-6}$ 的容差。对每个指定的空间分辨率 $N_x$ 执行此过程。最后，相对于最精细的网格（$N_{\\mathrm{ref}}=192$）计算自由能和密度分布误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SCFT problem for a symmetric diblock copolymer and\n    performs a grid refinement study.\n    \"\"\"\n\n    # --- Physical and Numerical Parameters ---\n    f_A = 0.5\n    chi_N = 20.0\n    L = 4.0\n    \n    M = 100  # Number of contour steps\n    max_iter = 200\n    alpha_plus = 0.10\n    alpha_minus = 0.10\n    tolerance = 1e-6\n\n    Nx_list = [32, 48, 64, 96, 192]\n    N_ref = 192\n\n    # --- Container for results ---\n    converged_data = {}\n\n    # --- Main loop over grid resolutions ---\n    for Nx in Nx_list:\n        F_conv, phi_A_conv = run_scft(\n            Nx, M, L, f_A, chi_N, max_iter, tolerance, alpha_minus, alpha_plus\n        )\n        converged_data[Nx] = {'F': F_conv, 'phi_A': phi_A_conv}\n\n    # --- Post-processing: Error Analysis ---\n    ref_data = converged_data[N_ref]\n    F_ref = ref_data['F']\n    phi_A_ref = ref_data['phi_A']\n\n    results_list = []\n    for Nx in sorted(converged_data.keys()):\n        if Nx == N_ref:\n            continue\n\n        coarse_data = converged_data[Nx]\n        F_coarse = coarse_data['F']\n        phi_A_coarse = coarse_data['phi_A']\n\n        # 1. Free energy error\n        delta_F = F_coarse - F_ref\n        results_list.append(delta_F)\n\n        # 2. Density profile error\n        stride = N_ref // Nx\n        phi_A_ref_subsampled = phi_A_ref[::stride]\n        \n        numerator = np.sum((phi_A_coarse - phi_A_ref_subsampled)**2)\n        denominator = np.sum(phi_A_ref_subsampled**2)\n        \n        if denominator == 0:\n            error_phi = 0.0\n        else:\n            error_phi = np.sqrt(numerator / denominator)\n        results_list.append(error_phi)\n\n    # --- Final Output ---\n    output_str = \",\".join([f\"{val:.12f}\" for val in results_list])\n    print(f\"[{output_str}]\")\n\n\ndef run_scft(Nx, M, L, f_A, chi_N, max_iter, tolerance, alpha_minus, alpha_plus):\n    \"\"\"\n    Performs the self-consistent field iteration for a given set of parameters.\n    \"\"\"\n    # --- Grid setup ---\n    z = np.linspace(0, L, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=L / Nx)\n    ds = 1.0 / M\n    f_A_steps = int(f_A * M)\n\n    # --- Field initialization ---\n    w_minus = 0.1 * np.cos(2 * np.pi * z / L)\n    w_plus = np.zeros(Nx)\n\n    for iteration in range(max_iter):\n        # --- Update fields ---\n        w_A = w_plus - w_minus\n        w_B = w_plus + w_minus\n\n        # --- Solve propagator equations ---\n        # Forward propagator q(s,z)\n        q_traj = np.zeros((M + 1, Nx), dtype=np.complex128)\n        q_traj[0, :] = 1.0\n        q_current = q_traj[0, :]\n        \n        # Evolve through A-block\n        for i in range(f_A_steps):\n            q_current = strang_split_step(q_current, w_A, k, ds)\n            q_traj[i + 1, :] = q_current\n            \n        # Evolve through B-block\n        for i in range(f_A_steps, M):\n            q_current = strang_split_step(q_current, w_B, k, ds)\n            q_traj[i + 1, :] = q_current\n            \n        # Single-chain partition function\n        Q = np.mean(q_traj[M, :]).real\n\n        # Backward propagator q_dagger(s,z)\n        q_dagger_traj = np.zeros((M + 1, Nx), dtype=np.complex128)\n        q_dagger_traj[M, :] = 1.0\n        q_dagger_current = q_dagger_traj[M, :]\n\n        # Evolve backwards through B-block (forward in s')\n        for i in range(M - 1, f_A_steps - 1, -1):\n            q_dagger_current = strang_split_step(q_dagger_current, w_B, k, ds)\n            q_dagger_traj[i, :] = q_dagger_current\n        \n        # Evolve backwards through A-block\n        for i in range(f_A_steps - 1, -1, -1):\n            q_dagger_current = strang_split_step(q_dagger_current, w_A, k, ds)\n            q_dagger_traj[i, :] = q_dagger_current\n        \n        # --- Calculate densities ---\n        # Trapezoidal rule for integration over s\n        integrand_A = q_traj[0:f_A_steps + 1, :] * q_dagger_traj[0:f_A_steps + 1, :]\n        phi_A = np.trapz(integrand_A.real, dx=ds, axis=0) / Q\n        \n        integrand_B = q_traj[f_A_steps:M + 1, :] * q_dagger_traj[f_A_steps:M + 1, :]\n        phi_B = np.trapz(integrand_B.real, dx=ds, axis=0) / Q\n\n        # --- Calculate residuals for convergence check ---\n        res_minus_field = w_minus - chi_N * (phi_B - phi_A)\n        res_plus_field = phi_A + phi_B - 1\n        \n        res_minus = np.sqrt(np.mean(res_minus_field**2))\n        res_plus = np.sqrt(np.mean(res_plus_field**2))\n\n        if res_minus  tolerance and res_plus  tolerance:\n            break\n\n        # --- Update fields using simple mixing ---\n        w_minus_target = chi_N * (phi_B - phi_A)\n        w_minus = (1 - alpha_minus) * w_minus + alpha_minus * w_minus_target\n\n        w_plus_updated = w_plus - alpha_plus * (phi_A + phi_B - 1)\n        w_plus = w_plus_updated - np.mean(w_plus_updated)\n\n    # --- Calculate final free energy ---\n    F = -np.log(Q) + np.mean(w_minus**2) / (2 * chi_N)\n    \n    return F, phi_A\n\n\ndef strang_split_step(q_in, w, k, ds):\n    \"\"\"\n    Performs one step of the propagator evolution using a pseudo-spectral\n    method with Strang splitting.\n    \"\"\"\n    # Half-step in real space (reaction)\n    q_half_reac = q_in * np.exp(-0.5 * ds * w)\n    \n    # Full step in Fourier space (diffusion)\n    q_half_reac_f = np.fft.fft(q_half_reac)\n    q_full_diff_f = q_half_reac_f * np.exp(-ds * k**2)\n    q_full_diff = np.fft.ifft(q_full_diff_f)\n    \n    # Second half-step in real space (reaction)\n    q_out = q_full_diff * np.exp(-0.5 * ds * w)\n    \n    return q_out\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2927297"}]}