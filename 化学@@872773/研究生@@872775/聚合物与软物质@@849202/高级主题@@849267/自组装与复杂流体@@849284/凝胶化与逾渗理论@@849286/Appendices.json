{"hands_on_practices": [{"introduction": "这项练习是高分子科学的基石，它运用支化理论的原理来预测凝胶化的发生。通过计算单体混合物的临界反应程度，你将练习使用 Flory-Stockmayer 模型，该模型将微观的官能度与宏观的网络形成现象巧妙地联系起来[@problem_id:2916994]。这是设计和理解网络聚合物的一项基本技能。", "problem": "考虑一个理想的逐步增长网络形成缩聚反应，其中大量的单体各自携带整数个相同的、同官能的反应基团，这些基团彼此两两反应。该体系是官能度为 $f=3$（三官能）和 $f=2$（二官能）的单体的二元混合物。设 $x$ 表示三官能单体的初始摩尔分数（数量分数），因此二官能单体的分数为 $1 - x$。假设满足以下理想条件：(i) 所有官能团在任何时候都具有相同的反应性，(ii) 在凝胶前阶段，分子内环化可以忽略不计，因此团簇在局部是树状的，(iii) 反应在所有未反应的官能团之间随机进行。设 $p$ 为反应程度，定义为所有官能团中已反应的比例。\n\n使用应用于此理想随机网络的分支过程和逾渗理论的第一性原理，根据当一个已反应的键连接到一个新单体时产生的新反应键的平均数，推导出凝胶化判据。然后，对于上述指定的二元混合物，计算凝胶首次出现时的临界反应程度 $p_c$ 作为 $x$ 的显式函数。将您的最终结果表示为关于 $x$ 的单一简化解析表达式。无需四舍五入，最终答案不报告单位。", "solution": "题目要求推导官能度为 $f=3$ 和 $f=2$ 的单体二元混合物在理想逐步增长聚合反应中的凝胶化判据。最终目标是表达凝胶化的临界反应程度 $p_c$，作为三官能单体初始摩尔分数 $x$ 的函数。\n\n问题陈述已经过验证，被认为是科学上可靠、提法恰当、客观且内部一致的。它代表了基于 Flory-Stockmayer 凝胶理论的聚合物统计力学中的一个标准问题，该理论是逾渗理论在化学反应网络上的平均场应用。给定的假设——官能团等反应性、无分子内环化和随机反应——是该模型的标准理想条件。我们可以继续进行解答。\n\n凝胶化的开始对应于无限的、贯穿空间的聚合物网络的形成。用分支过程的语言来说，这是分支级联无限延续的概率变为非零的点。这一转变的判据是分支参数 $\\alpha$ 必须等于或大于 $1$。分支参数 $\\alpha$ 定义为：沿着一个随机选择的已反应键到达下一个单体，然后从该单体分支出去所遇到的新反应键的平均数。凝胶化发生在临界点 $\\alpha = 1$。\n\n让我们为给定体系构建 $\\alpha$。我们有一个二元混合物的单体：\n1.  官能度为 $f_1=3$、摩尔分数为 $x$ 的三官能单体。\n2.  官能度为 $f_2=2$、摩尔分数为 $1-x$ 的二官能单体。\n\n反应程度 $p$ 是任意随机选择的官能团已反应的概率。\n\n为了计算 $\\alpha$，我们执行一个两步的统计平均。首先，我们必须确定沿着一个随机选择的化学键到达某一特定官能度单体的概率。这个概率不是单体的摩尔分数，而是属于该类型单体的官能团占所有官能团的比例。\n\n体系中官能团的总数与数均官能度 $\\langle f \\rangle$ 成正比。\n$$ \\langle f \\rangle = \\sum_{i} x_i f_i = x \\cdot 3 + (1-x) \\cdot 2 = 3x + 2 - 2x = x + 2 $$\n属于三官能单体的官能团的分数为：\n$$ P(f=3)_{\\text{group}} = \\frac{x \\cdot f_1}{\\langle f \\rangle} = \\frac{3x}{x+2} $$\n属于二官能单体的官能团的分数为：\n$$ P(f=2)_{\\text{group}} = \\frac{(1-x) \\cdot f_2}{\\langle f \\rangle} = \\frac{2(1-x)}{x+2} $$\n注意到 $P(f=3)_{\\text{group}} + P(f=2)_{\\text{group}} = \\frac{3x + 2 - 2x}{x+2} = \\frac{x+2}{x+2} = 1$，符合要求。\n\n现在，考虑一个随机选择的已反应键并沿着它到达一个单体单元。该单体是三官能的概率为 $P(f=3)_{\\text{group}}$，是二官能的概率为 $P(f=2)_{\\text{group}}$。一旦我们到达这个单体，它的一个官能团就被我们所跟随的键占据了。一个官能度为 $f$ 的单体有 $f-1$ 个其他“出射”官能团可用于形成更多分支。\n- 对于三官能单体（$f=3$），有 $3-1 = 2$ 个出射基团。\n- 对于二官能单体（$f=2$），有 $2-1 = 1$ 个出射基团。\n\n通过遍历一个键到达的单体的平均出射官能团数是 $(f-1)$ 的基团加权平均值：\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\sum_{i} P(f=f_i)_{\\text{group}} \\cdot (f_i - 1) $$\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\left(\\frac{3x}{x+2}\\right)(3-1) + \\left(\\frac{2(1-x)}{x+2}\\right)(2-1) $$\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\frac{3x \\cdot 2}{x+2} + \\frac{2(1-x) \\cdot 1}{x+2} $$\n$$ \\langle f-1 \\rangle_{\\text{group-weighted}} = \\frac{6x + 2 - 2x}{x+2} = \\frac{4x+2}{x+2} $$\n这个量代表了从该单体出发的潜在路径的平均数。\n\n分支参数 $\\alpha$ 是这些出射路径中实际连接到其他单体的平均数量。由于任何给定官能团已反应的概率是 $p$，新反应键的平均数是 $p$与平均出射基团数的乘积。\n$$ \\alpha = p \\cdot \\langle f-1 \\rangle_{\\text{group-weighted}} = p \\left(\\frac{4x+2}{x+2}\\right) $$\n凝胶化的临界条件是 $\\alpha = 1$。设 $p_c$ 是凝胶点的临界反应程度。\n$$ 1 = p_c \\left(\\frac{4x+2}{x+2}\\right) $$\n解出 $p_c$ 得到凝胶点的最终表达式：\n$$ p_c = \\frac{x+2}{4x+2} $$\n这就是所求的结果。它将临界反应程度表示为单体混合物初始组成的函数。该表达式正确地恢复了已知的极限情况：对于纯二官能体系（$x=0$），$p_c = \\frac{2}{2} = 1$，这表明凝胶化（网络形成）不会发生，尽管重均摩尔质量会发散。对于纯三官能体系（$x=1$），$p_c = \\frac{1+2}{4+2} = \\frac{3}{6} = \\frac{1}{2}$，这是对于 $f=3$ 单体的经典 Flory-Stockmayer 结果，$p_c = 1/(f-1)$。", "answer": "$$ \\boxed{\\frac{x+2}{4x+2}} $$", "id": "2916994"}, {"introduction": "从业已建立的静态图像转向动态视角，本问题通过 Smoluchowski 凝聚方程的视角来探索凝胶化过程。你将分析定义了不同尺寸团簇之间反应速率的相互作用核，如何决定无限大团簇（即凝胶）能否在有限时间内形成[@problem_id:2917061]。这项练习突显了动力学在聚集现象中的关键作用。", "problem": "考虑一个在充分混合介质中发生的不可逆团簇聚集过程，该过程由离散的 Smoluchowski 凝聚方程 (SCE) 描述。设 $c_k(t)$ 表示在时间 $t \\ge 0$ 时，质量（或尺寸）为 $k \\in \\mathbb{N}$ 的团簇的浓度。SCE 方程为\n$$\n\\frac{d c_k}{d t} \\;=\\; \\frac{1}{2} \\sum_{i+j=k} K_{ij}\\, c_i c_j \\;-\\; c_k \\sum_{j \\ge 1} K_{kj}\\, c_j,\n$$\n其中 $K_{ij} \\ge 0$ 是对称的凝聚核。定义矩 $M_n(t) = \\sum_{k \\ge 1} k^n c_k(t)$，对于 $n \\in \\{0,1,2\\}$。假设初始数据是单分散的：$c_1(0)=c_00$ 且对于 $k \\ge 2$ 有 $c_k(0)=0$，因此 $M_1(0)=c_0$ 且 $M_2(0)=c_0$。对于以下两个凝聚核，分析前3个矩的时间演化，并判断是否存在有限时间凝胶化。凝胶化被理解为某个矩在有限时间内的发散，该发散标志着一个渗透（“凝胶”）团簇的形成：\n- 加性核：$K_{ij} = i + j$。\n- 乘性核：$K_{ij} = i\\,j$。\n\n选择所有关于 $M_0(t)$、$M_1(t)$ 和 $M_2(t)$ 在凝胶时间（如果存在）之前的演化，以及关于凝胶化是否发生的正确陈述。\n\nA. 对于 $K_{ij}=i+j$，总质量 $M_1(t)$ 是守恒的；$M_0(t)$ 按 $M_0(t)=M_0(0)\\,\\exp\\!\\big(-M_1(0)\\,t\\big)$ 指数衰减；$M_2(t)$ 按 $M_2(t)=M_2(0)\\,\\exp\\!\\big(2\\,M_1(0)\\,t\\big)$ 指数增长；不存在有限时间凝胶化。\n\nB. 对于 $K_{ij}=i+j$，$M_0(t)$ 按 $M_0(t)=M_0(0)-M_1(0)\\,t$ 线性减少，并且 $M_2(t)$ 随时间二次增长；凝胶化（如果发生）只会在无穷大时间发生。\n\nC. 对于 $K_{ij}=i\\,j$，总质量 $M_1(t)$ 在凝胶化之前是守恒的；$M_0(t)$ 在凝胶化之前按 $M_0(t)=M_0(0)-\\tfrac{1}{2}\\,[M_1(0)]^2\\,t$ 线性减少；$M_2(t)$ 在有限时间 $t_g = 1/M_2(0)$ 发散，表明发生凝胶化。\n\nD. 对于 $K_{ij}=i\\,j$，二阶矩遵循 $\\frac{d M_2}{d t} = 2\\,M_1(t)\\,M_2(t)$，所以 $M_2(t)$ 指数增长，且不存在有限时间凝胶化。\n\nE. 对于 $K_{ij}=i\\,j$，凝胶时间是 $t_g = 1/M_1(0)$，与 $M_2(0)$ 无关。\n\n选择所有适用的选项。", "solution": "问题陈述是研究 Smoluchowski 凝聚方程的一个标准练习，并将据此进行验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n-   **控制方程：** 离散 Smoluchowski 凝聚方程 (SCE) 给出如下\n    $$\n    \\frac{d c_k}{d t} \\;=\\; \\frac{1}{2} \\sum_{i+j=k} K_{ij}\\, c_i c_j \\;-\\; c_k \\sum_{j \\ge 1} K_{kj}\\, c_j\n    $$\n-   **定义：**\n    -   $c_k(t)$: 在时间 $t \\ge 0$ 时尺寸为 $k \\in \\mathbb{N}$ 的团簇的浓度。\n    -   $K_{ij}$: 对称的非负凝聚核。\n    -   矩：$M_n(t) = \\sum_{k \\ge 1} k^n c_k(t)$，对于 $n \\in \\{0,1,2\\}$。\n    -   凝胶化：矩在有限时间内的发散。\n-   **初始条件：**\n    -   单分散数据：$c_1(0)=c_0  0$ 且对于 $k \\ge 2$ 有 $c_k(0)=0$。\n    -   由此导出的初始矩：$M_0(0) = c_0$，$M_1(0) = c_0$，$M_2(0) = c_0$。\n-   **待分析的核：**\n    1.  加性核：$K_{ij} = i + j$。\n    2.  乘性核：$K_{ij} = i\\,j$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题基于 Smoluchowski 凝聚方程，这是聚集动力学的基石。核 $K_{ij}=i+j$ 和 $K_{ij}=ij$ 分别是用于探索非凝胶化和凝胶化动力学的典型例子。矩和凝胶化的定义是标准的。该问题在科学上是合理的。\n-   **适定性：** 该问题提供了一个具有指定初始条件的适定微分方程组。任务是推导矩的动力学，这是一个标准的、可解的过程。\n-   **客观性：** 问题陈述使用精确的数学语言表述，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n问题有效。我们继续进行解答。\n\n**矩方程的推导**\n\nn 阶矩 $M_n(t)$ 的时间导数是\n$$\n\\frac{d M_n}{d t} = \\sum_{k \\ge 1} k^n \\frac{d c_k}{d t} = \\sum_{k \\ge 1} k^n \\left( \\frac{1}{2} \\sum_{i+j=k} K_{ij} c_i c_j - c_k \\sum_{j \\ge 1} K_{kj} c_j \\right).\n$$\n通过对求和变址，可以证明这等价于\n$$\n\\frac{d M_n}{d t} = \\frac{1}{2} \\sum_{i,j \\ge 1} \\left( (i+j)^n - i^n - j^n \\right) K_{ij} c_i c_j.\n$$\n我们将此通用公式应用于 $n=0, 1, 2$。\n\n-   对于 $n=0$:\n    $$\n    \\frac{d M_0}{d t} = \\frac{1}{2} \\sum_{i,j \\ge 1} \\left( (i+j)^0 - i^0 - j^0 \\right) K_{ij} c_i c_j = - \\frac{1}{2} \\sum_{i,j \\ge 1} K_{ij} c_i c_j.\n    $$\n-   对于 $n=1$:\n    $$\n    \\frac{d M_1}{d t} = \\frac{1}{2} \\sum_{i,j \\ge 1} \\left( (i+j)^1 - i^1 - j^1 \\right) K_{ij} c_i c_j = 0.\n    $$\n    这表明对于任何核，在凝胶时间之前，总质量是守恒的，$M_1(t) = M_1(0)$。\n-   对于 $n=2$:\n    $$\n    \\frac{d M_2}{d t} = \\frac{1}{2} \\sum_{i,j \\ge 1} \\left( (i+j)^2 - i^2 - j^2 \\right) K_{ij} c_i c_j = \\frac{1}{2} \\sum_{i,j \\ge 1} (2ij) K_{ij} c_i c_j = \\sum_{i,j \\ge 1} ij K_{ij} c_i c_j.\n    $$\n\n现在我们使用这些矩方程和初始条件 $M_0(0)=M_1(0)=M_2(0)=c_0$ 来分析每个核。\n\n**加性核分析：$K_{ij} = i + j$**\n\n-   **矩 $M_0(t)$：**\n    $$\n    \\frac{d M_0}{d t} = -\\frac{1}{2} \\sum_{i,j \\ge 1} (i+j) c_i c_j = -\\frac{1}{2} \\left[ \\left(\\sum_i i c_i\\right) \\left(\\sum_j c_j\\right) + \\left(\\sum_i c_i\\right) \\left(\\sum_j j c_j\\right) \\right]\n    $$\n    $$\n    \\frac{d M_0}{d t} = -\\frac{1}{2} \\left[ M_1(t) M_0(t) + M_0(t) M_1(t) \\right] = -M_1(t) M_0(t).\n    $$\n    由于 $M_1(t) = M_1(0)$，我们有 $\\frac{d M_0}{d t} = -M_1(0) M_0(t)$。解为\n    $$\n    M_0(t) = M_0(0) \\exp(-M_1(0) t).\n    $$\n-   **矩 $M_1(t)$：**\n    如上所示，$M_1(t) = M_1(0) = c_0$。总质量守恒。\n-   **矩 $M_2(t)$：**\n    $$\n    \\frac{d M_2}{d t} = \\sum_{i,j \\ge 1} ij(i+j) c_i c_j = \\left(\\sum_i i^2 c_i\\right) \\left(\\sum_j j c_j\\right) + \\left(\\sum_i i c_i\\right) \\left(\\sum_j j^2 c_j\\right)\n    $$\n    $$\n    \\frac{d M_2}{d t} = M_2(t) M_1(t) + M_1(t) M_2(t) = 2 M_1(t) M_2(t).\n    $$\n    由于 $M_1(t) = M_1(0)$，我们有 $\\frac{d M_2}{d t} = 2 M_1(0) M_2(t)$。解为\n    $$\n    M_2(t) = M_2(0) \\exp(2 M_1(0) t).\n    $$\n-   **凝胶化：** 二阶矩 $M_2(t)$ 呈指数增长，但在任何有限时间 $t$ 内都不会发散。因此，凝胶化只在 $t \\to \\infty$ 时发生。不存在有限时间凝胶化。\n\n**乘性核分析：$K_{ij} = i j$**\n\n-   **矩 $M_0(t)$：**\n    $$\n    \\frac{d M_0}{d t} = -\\frac{1}{2} \\sum_{i,j \\ge 1} (ij) c_i c_j = -\\frac{1}{2} \\left(\\sum_i i c_i\\right) \\left(\\sum_j j c_j\\right) = -\\frac{1}{2} [M_1(t)]^2.\n    $$\n    由于 $M_1(t) = M_1(0)$，我们有 $\\frac{d M_0}{d t} = -\\frac{1}{2} [M_1(0)]^2$。积分可得\n    $$\n    M_0(t) = M_0(0) - \\frac{1}{2} [M_1(0)]^2 t.\n    $$\n-   **矩 $M_1(t)$：**\n    $M_1(t) = M_1(0) = c_0$。质量在溶胶相中守恒。\n-   **矩 $M_2(t)$：**\n    $$\n    \\frac{d M_2}{d t} = \\sum_{i,j \\ge 1} ij(ij) c_i c_j = \\left(\\sum_i i^2 c_i\\right) \\left(\\sum_j j^2 c_j\\right) = [M_2(t)]^2.\n    $$\n    这是一个可通过分离变量法求解的非线性常微分方程：$\\frac{d M_2}{M_2^2} = dt$。从 $t=0$ 积分得到\n    $$\n    \\frac{1}{M_2(0)} - \\frac{1}{M_2(t)} = t \\implies M_2(t) = \\frac{M_2(0)}{1 - t M_2(0)}.\n    $$\n-   **凝胶化：** 当分母为零时，$M_2(t)$ 发散，即 $1 - t M_2(0) = 0$。这给出了一个有限的凝胶时间\n    $$\n    t_g = \\frac{1}{M_2(0)}.\n    $$\n\n**选项评估**\n\nA. **对于 $K_{ij}=i+j$，总质量 $M_1(t)$ 是守恒的；$M_0(t)$ 按 $M_0(t)=M_0(0)\\,\\exp\\!\\big(-M_1(0)\\,t\\big)$ 指数衰减；$M_2(t)$ 按 $M_2(t)=M_2(0)\\,\\exp\\!\\big(2\\,M_1(0)\\,t\\big)$ 指数增长；不存在有限时间凝胶化。**\n该陈述与我们对加性核的推导结果完全匹配。\n结论：**正确**。\n\nB. **对于 $K_{ij}=i+j$，$M_0(t)$ 按 $M_0(t)=M_0(0)-M_1(0)\\,t$ 线性减少，并且 $M_2(t)$ 随时间二次增长；凝胶化（如果发生）只会在无穷大时间发生。**\n对 $M_0(t)$ 和 $M_2(t)$ 时间演化的描述不正确。我们发现 $M_0(t)$ 呈指数衰减，$M_2(t)$ 呈指数增长。\n结论：**不正确**。\n\nC. **对于 $K_{ij}=i\\,j$，总质量 $M_1(t)$ 在凝胶化之前是守恒的；$M_0(t)$ 在凝胶化之前按 $M_0(t)=M_0(0)-\\tfrac{1}{2}\\,[M_1(0)]^2\\,t$ 线性减少；$M_2(t)$ 在有限时间 $t_g = 1/M_2(0)$ 发散，表明发生凝胶化。**\n该陈述与我们对乘性核的推导结果完全匹配。\n结论：**正确**。\n\nD. **对于 $K_{ij}=i\\,j$，二阶矩遵循 $\\frac{d M_2}{d t} = 2\\,M_1(t)\\,M_2(t)$，所以 $M_2(t)$ 指数增长，且不存在有限时间凝胶化。**\n对于核 $K_{ij}=ij$ 的 $M_2(t)$ 的微分方程是错误的。正确的方程是 $\\frac{d M_2}{d t} = [M_2(t)]^2$。所述方程属于加性核 $K_{ij}=i+j$。因此，关于指数增长和不存在凝胶化的结论对于此核也是错误的。\n结论：**不正确**。\n\nE. **对于 $K_{ij}=i\\,j$，凝胶时间是 $t_g = 1/M_1(0)$，与 $M_2(0)$ 无关。**\n我们的推导得出 $t_g = 1/M_2(0)$。凝胶时间从根本上取决于初始二阶矩 $M_2(0)$。关于它与 $M_2(0)$ 无关的陈述是错误的。等式 $t_g = 1/M_1(0)$ 仅仅是在 $M_1(0) = M_2(0) = c_0$ 的特定单分散初始条件下的一个巧合。对于一般的初始条件，$M_1(0) \\ne M_2(0)$，这个公式将是不正确的。\n结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "2917061"}, {"introduction": "这最后一个练习通过计算机模拟将逾渗理论的概念变得生动起来。你不仅将会在晶格上生成一个逾渗系统，还将剖析贯穿团簇的结构以分离出其“骨架”——即网络的承重部分[@problem_id:2916990]。这项练习能够培养实用的编程技能，并让你对悬垂末端和双连通核心等结构概念有更具体的理解，而这些概念对于凝胶的力学和传输性质至关重要。", "problem": "考虑一个有限方格上的独立键渗流模型。设 $L \\in \\mathbb{N}$ 为线性系统尺寸。定义一个具有开放边界的底层确定性网格图 $G_L = (V,E)$，其中 $V = \\{(i,j) \\mid i \\in \\{0,\\dots,L-1\\}, j \\in \\{0,\\dots,L-1\\}\\}$，并且对于所有 $j \\in \\{0,\\dots,L-2\\}$，$E$ 中包含一条连接 $(i,j)$ 和 $(i,j+1)$ 的无向边；对于所有 $i \\in \\{0,\\dots,L-2\\}$，$E$ 中包含一条连接 $(i,j)$ 和 $(i+1,j)$ 的无向边。对于一个键占据概率 $p \\in [0,1]$ 和一个伪随机种子 $s \\in \\mathbb{N}$，通过一个由 $s$ 初始化的伪随机数生成器，以概率 $p$ 独立地保留 $E$ 中的每条边，从而形成一个随机子图 $G = (V, E_{\\mathrm{open}})$。\n\n定义顶部边界集 $T = \\{(0,j) \\mid j \\in \\{0,\\dots,L-1\\}\\}$ 和底部边界集 $B = \\{(L-1,j) \\mid j \\in \\{0,\\dots,L-1\\}\\}$。$G$ 的一个连通分量 $C$ 如果同时与 $T$ 和 $B$ 相交，则称其为贯穿的（spanning）。如果不存在这样的 $C$，则定义贯穿主干长度 $\\ell$ 为 $0$。\n\n否则，在所有贯穿分量中，为避免歧义，通过以下确定性规则选择 $C^\\star$：最大化 $|V(C)|$；若存在平局，则最大化 $|E(C)|$；若仍存在平局，则根据索引映射 $\\varphi: V \\to \\{0,\\dots,L^2-1\\}$（由 $\\varphi(i,j) = iL + j$ 给出）最小化最小的顶点索引。\n\n对于选定的 $C^\\star$，定义其诱导子图 $H^\\star$，其顶点集为 $V^\\star = V(C^\\star)$，边集包含 $E_{\\mathrm{open}}$ 中所有端点均在 $V^\\star$ 内的开边。定义顶点 $v \\in V^\\star$ 的度 $d_{H^\\star}(v)$ 为 $v$ 在 $H^\\star$ 中的邻居数量。“叶剥离”（leaf-stripping，也称迭代剪枝）过程通过重复移除所有度 $d_{H^\\star}(v)  2$ 的顶点 $v$ 及其关联边，并在每次移除后更新度，直到不存在此类顶点为止，从而构建 $H^\\star$ 的 $2$-核（2-core）。设最终剪枝后的子图为 $K^\\star$。定义贯穿主干长度 $\\ell$ 为 $K^\\star$ 中无向边的数量。\n\n您的任务是实现一个程序，对于每个给定的参数三元组 $(L,p,s)$，生成 $G$，找到存在的 $C^\\star$，通过叶剥离计算其 $2$-核 $K^\\star$，并输出如上定义的整数 $\\ell$。如果不存在贯穿分量，则该情况输出整数 $0$。\n\n算法约束与基础：\n- 仅使用图连通性、度、诱导子图的定义，以及基于度阈值 $2$ 的迭代剪枝规则来获得 $2$-核，该过程移除了所有不可能位于 $T$ 和 $B$ 之间任何简单路径上的悬挂树。\n- 为寻找连通分量，您可以使用广度优先搜索（BFS），该算法按边数的非递减距离系统地探索顶点。\n- 根据指定的 $p$，渗流在各条边上是独立同分布的，并且由 $s$ 播种的伪随机生成器确保了可复现性。\n\n测试套件：\n为以下参数元组 $(L,p,s)$ 提供输出：\n- 案例 1：$(L,p,s) = (2, 1.0, 0)$。\n- 案例 2：$(L,p,s) = (3, 1.0, 0)$。\n- 案例 3：$(L,p,s) = (30, 0.4, 7)$。\n- 案例 4：$(L,p,s) = (50, 0.6, 12345)$。\n- 案例 5：$(L,p,s) = (50, 0.55, 999)$。\n\n所有输出均为整数，不涉及物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），结果顺序与上述案例顺序相同。", "solution": "所述问题是有效的。它在科学上和数学上都是适定的，其基础是渗流理论的既定原则，该理论是统计力学和概率论的一个分支。该问题是自洽的，其定义是精确的，并且用于生成随机图和打破平局的确定性过程确保了每组参数都存在一个唯一的、可验证的解。我们将着手构建此解。\n\n该问题要求计算有限 $L \\times L$ 方格上键渗流模型中贯穿簇的“主干”大小。主干被正式定义为贯穿簇的 $2$-核。步骤如下：\n\n首先，对于给定的系统尺寸 $L$、键占据概率 $p$ 和伪随机种子 $s$，我们构建随机图 $G = (V, E_{\\mathrm{open}})$ 的特定实现。顶点集 $V$ 对应于方格上的位点，为方便计算，我们通过映射 $\\varphi(i,j) = iL + j$ 将位于第 $i$ 行和第 $j$ 列（其中 $i, j \\in \\{0, \\dots, L-1\\}$）的位点用单个整数 $v \\in \\{0, \\dots, L^2-1\\}$ 进行索引。底层网格图 $G_L$ 在相邻顶点之间有边。每条边都以概率 $p$ 独立地包含在开边集 $E_{\\mathrm{open}}$ 中。为确保可复现性，使用种子 $s$ 初始化一个伪随机数生成器。我们通过遍历网格的每条潜在边，为每条边抽取一个伪随机数，如果该数小于 $p$，则将该边添加到邻接表中，从而生成 $G$ 的邻接表表示。\n\n其次，我们必须识别图 $G$ 的所有连通分量。这是一个标准的图遍历问题，广度优先搜索（BFS）算法是一种合适且高效的方法。我们维护一个布尔数组来跟踪已访问的顶点。遍历所有顶点，如果发现一个未访问的顶点，就从它开始启动一个新的 BFS，以找到属于其分量的所有顶点。\n\n第三，对于找到的每个分量，我们确定它是否是一个“贯穿”分量。一个分量 $C$ 被定义为贯穿的，如果其顶点集 $V(C)$ 与顶部边界集 $T = \\{v \\mid 0 \\le v  L\\}$ 和底部边界集 $B = \\{v \\mid L(L-1) \\le v  L^2\\}$ 都有非空交集。如果不存在这样的贯穿分量，问题定义主干长度 $\\ell$ 为 $0$，该情况下的流程终止。\n\n第四，如果存在一个或多个贯穿分量，我们必须根据指定的确定性规则选择一个唯一的分量 $C^\\star$。该规则是基于一系列标准的字典序比较：\n$1$. 顶点数 $|V(C)|$ 最大的分量。\n$2$. 在 $|V(C)|$ 最大的分量中，选择边数 $|E(C)|$ 最大的分量。\n$3$. 如果仍然存在平局，则选择其最小顶点索引值最小的分量。\n这个过程保证了 $C^\\star$ 的唯一性。\n\n第五，我们计算 $C^\\star$ 的 $2$-核，记为 $K^\\star$。图的 $2$-核是最小度至少为 $2$ 的最大诱导子图。它通过迭代剪枝算法（也称为叶剥离）找到。该算法流程如下：\n$1$. 我们首先计算所有顶点 $v \\in V(C^\\star)$ 的度 $d_{C^\\star}(v)$。度是 $v$ 的邻居中也属于 $V(C^\\star)$ 的顶点数量。\n$2$. 所有度 $d_{C^\\star}(v)  2$ 的顶点被识别出来并放入一个队列中。根据定义，这些顶点不能是任何环路的一部分，因此被视为结构的“叶子”。\n$3$. 我们迭代地处理队列。当一个顶点 $u$ 从队列中移除时，它就从图中被剪枝。对于被剪枝顶点 $u$ 的每个邻居 $v$，其度减一。如果邻居 $v$ 的度降至 $1$，它就成了一个新的叶子，并被添加到队列中。\n$4$. 这个过程持续到队列为空。未被剪枝的顶点集合构成了 $2$-核的顶点集 $V(K^\\star)$。在物理上，这个核代表了簇的弹性部分，包含了所有对于稳健传输至关重要的循环路径。\n\n最后，所需贯穿主干长度 $\\ell$ 是最终得到的 $2$-核 $K^\\star$ 中的边数。这可以通过将核内所有顶点的度相加再除以二来计算，即 $\\ell = \\frac{1}{2} \\sum_{v \\in V(K^\\star)} d_{K^\\star}(v)$，或者直接计算端点均在 $V(K^\\star)$ 内的边数。至此，完成了所需的计算。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the percolation backbone problem for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        (2, 1.0, 0),\n        (3, 1.0, 0),\n        (30, 0.4, 7),\n        (50, 0.6, 12345),\n        (50, 0.55, 999),\n    ]\n\n    results = []\n    for L, p, s in test_cases:\n        result = calculate_backbone_length(L, p, s)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_backbone_length(L, p, s):\n    \"\"\"\n    Calculates the spanning backbone length for a given (L, p, s) triple.\n    \"\"\"\n    if L  1:\n        return 0\n\n    N = L * L\n    rng = np.random.default_rng(s)\n    \n    # 1. Generate the random graph G = (V, E_open)\n    adj = {i: [] for i in range(N)}\n    for i in range(L):\n        for j in range(L):\n            u = i * L + j\n            # Edge to the right neighbor\n            if j  L - 1:\n                v = i * L + (j + 1)\n                if rng.random()  p:\n                    adj[u].append(v)\n                    adj[v].append(u)\n            # Edge to the bottom neighbor\n            if i  L - 1:\n                v = (i + 1) * L + j\n                if rng.random()  p:\n                    adj[u].append(v)\n                    adj[v].append(u)\n\n    # 2. Find all connected components and identify spanning ones\n    visited = np.zeros(N, dtype=bool)\n    spanning_components = []\n    for i in range(N):\n        if not visited[i]:\n            component_nodes = set()\n            q = deque([i])\n            visited[i] = True\n            is_top_connected = False\n            is_bottom_connected = False\n            min_v_idx = i\n\n            # BFS to find one component\n            while q:\n                u = q.popleft()\n                component_nodes.add(u)\n                min_v_idx = min(min_v_idx, u)\n                \n                if u  L:\n                    is_top_connected = True\n                if u >= L * (L - 1):\n                    is_bottom_connected = True\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            \n            if is_top_connected and is_bottom_connected:\n                num_vertices = len(component_nodes)\n                num_edges = sum(len(adj[u]) for u in component_nodes) // 2\n                spanning_components.append((-num_vertices, -num_edges, min_v_idx, component_nodes))\n\n    # 3. Select the primary spanning component C_star\n    if not spanning_components:\n        return 0\n\n    spanning_components.sort()\n    C_star_nodes = spanning_components[0][3]\n\n    # 4. Compute the 2-core of C_star using leaf-stripping\n    \n    # Create subgraph representation for C_star\n    subgraph_adj = {u: [v for v in adj[u] if v in C_star_nodes] for u in C_star_nodes}\n    degrees = {u: len(v) for u, v in subgraph_adj.items()}\n\n    # Queue for leaf-stripping\n    q = deque([u for u, d in degrees.items() if d  2])\n    \n    while q:\n        u = q.popleft()\n        \n        # u is pruned. Update its neighbors' degrees.\n        for v in subgraph_adj[u]:\n            if v in degrees:  # Check if neighbor has not been pruned yet\n                degrees[v] -= 1\n                if degrees[v] == 1:\n                    q.append(v)\n        \n        # Remove u from the graph\n        del degrees[u]\n\n    core_nodes = set(degrees.keys())\n\n    # 5. Calculate the backbone length (number of edges in the 2-core)\n    if not core_nodes:\n        return 0\n\n    backbone_len = sum(1 for u in core_nodes for v in subgraph_adj[u] if v in core_nodes and v > u)\n    \n    return backbone_len\n\nsolve()\n```", "id": "2916990"}]}