{"hands_on_practices": [{"introduction": "DNA作为一种带电的生物大分子（聚电解质），其弯曲刚度对于其在细胞核内的压缩以及与其他分子的相互作用至关重要。这种刚度通常用持续长度 $\\ell_p$ 来量化，它由聚合物链的内在机械特性和由周围离子环境调节的静电相互作用共同决定。\n\n本练习 ([@problem_id:2907118]) 将理论与实际数据分析相结合，为您提供了一个绝佳的实践机会。您将基于 Odijk-Skolnick-Fixman (OSF) 理论推导出一个描述 $\\ell_p$ 如何依赖于离子强度 $I$ 的模型，然后应用该模型来拟合实验数据，从而提取出DNA内在刚度等关键物理参数。", "problem": "一种半柔性聚电解质，例如双链脱氧核糖核酸 (DNA)，可以被建模为一个蠕虫状链，其持续长度包含一个短程（力学）部分和一个由屏蔽库仑相互作用引起的长程（静电）部分。从以下基本依据出发：(i) 蠕虫状链中持续长度的定义，即弯曲模量与热能之比，(ii) 电解质的线性化 Debye–Hückel 理论，其中 Debye 屏蔽参数与离子强度 $I$ 的标度关系为 $\\kappa \\propto I^{1/2}$，以及 (iii) Odijk–Skolnick–Fixman 论证，即对于均匀带电圆柱体，对弯曲模量的静电贡献与 $\\kappa^{-2}$ 成正比，推导一个关于总持续长度随离子强度变化的最小双参数模型，该模型需与这些标度关系一致，并满足总持续长度在高离子强度下趋近于一个有限常数的要求。实现一个程序，在给定离子强度和持续长度的测量值后，通过普通最小二乘法拟合此双参数模型，并返回最佳拟合参数及其解释。\n\n您的程序必须：\n- 使用一个由 $I$ 构建的设计变量，推导并拟合由上述约束所隐含的唯一参数线性模型，该设计变量强制静电项与离子强度成反比关系。\n- 通过最小化残差平方和，使用普通最小二乘法从数据 $\\{(I_i,\\ell_{p,i})\\}$ 中估计两个参数。算法要求是求解矩阵形式的线性正规方程组。\n- 解释拟合的参数：识别哪个参数是持续长度的高离子强度渐近值（单位为纳米），哪个参数量化了乘以离子强度倒数的静电强度因子（单位为纳米-摩尔）。\n\n物理单位和输出规范：\n- 离子强度 $I$ 必须以 $\\mathrm{mol\\cdot L^{-1}}$ 为单位处理。\n- 持续长度 $\\ell_p$ 必须以 $\\mathrm{nm}$ 为单位处理。\n- 两个输出参数必须报告为 $\\ell_p^0$（单位 $\\mathrm{nm}$）和 $a$（单位 $\\mathrm{nm\\cdot M}$）。\n- 将每个报告的参数四舍五入到恰好三位小数。\n\n测试套件：\n- 案例 A（平衡的低盐到高盐）：\n  - $I$ (单位 $\\mathrm{M}$)：$[0.001,\\,0.003,\\,0.01,\\,0.03,\\,0.1]$。\n  - $\\ell_p$ (单位 $\\mathrm{nm}$)：$[95.3,\\,61.4666667,\\,50.1,\\,46.5666667,\\,45.5]$。\n- 案例 B（高盐，弱变化）：\n  - $I$ (单位 $\\mathrm{M}$)：$[0.2,\\,0.3,\\,0.5,\\,1.0]$。\n  - $\\ell_p$ (单位 $\\mathrm{nm}$)：$[45.3,\\,45.1466667,\\,45.1,\\,45.06]$。\n- 案例 C（极低盐，强静电）：\n  - $I$ (单位 $\\mathrm{M}$)：$[0.0005,\\,0.001,\\,0.002,\\,0.005]$。\n  - $\\ell_p$ (单位 $\\mathrm{nm}$)：$[144.5,\\,95.0,\\,70.1,\\,54.8]$。\n- 案例 D（不同的聚合物或缓冲液，具有更强的基线和静电效应）：\n  - $I$ (单位 $\\mathrm{M}$)：$[0.002,\\,0.005,\\,0.02,\\,0.2]$。\n  - $\\ell_p$ (单位 $\\mathrm{nm}$)：$[92.2,\\,67.9,\\,56.0,\\,52.45]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个结果列表，每个案例一个结果。每个案例报告为一个双元素列表 $[\\ell_p^0,\\,a]$，其中每个数字都四舍五入到三位小数，并以上述单位表示。因此，完整输出必须是一个包含四个双元素列表的单一列表，例如 $[[\\ell_p^0,\\,a],[\\ell_p^0,\\,a],[\\ell_p^0,\\,a],[\\ell_p^0,\\,a]]$，打印在单行上，无额外文本。", "solution": "该问题要求推导并应用一个物理模型，用于描述半柔性聚电解质（如双链DNA）的持续长度如何作为周围电解质离子强度的函数。该模型必须从基本原理推导得出，其参数必须使用普通最小二乘法对所提供的实验数据进行拟合。\n\n分析分两个阶段进行：首先，根据提供的物理论证推导出数学模型；其次，构建并求解线性回归问题以确定模型参数。\n\n**1. 双参数模型的推导**\n\n问题陈述指出，总持续长度 $\\ell_p$ 是短程力学贡献 $\\ell_p^{mech}$ 和长程静电贡献 $\\ell_p^{elec}$ 之和。\n$$\n\\ell_p = \\ell_p^{mech} + \\ell_p^{elec}\n$$\n力学部分 $\\ell_p^{mech}$ 源于聚合物骨架的内在刚度，且与离子强度 $I$ 无关。问题包含一个约束条件，即在高离子强度下（$I \\to \\infty$），总持续长度趋近于一个有限常数。在此极限下，静电相互作用被完全屏蔽，导致静电贡献消失，即 $\\ell_p^{elec} \\to 0$。因此，持续长度的高盐极限就是力学贡献。我们将此常数定义为 $\\ell_p^0$。\n$$\n\\lim_{I \\to \\infty} \\ell_p(I) = \\ell_p^{mech} = \\ell_p^0\n$$\n因此，该模型可写为：\n$$\n\\ell_p(I) = \\ell_p^0 + \\ell_p^{elec}(I)\n$$\n为了确定 $\\ell_p^{elec}(I)$ 的函数形式，我们遵循指定的物理论证：\n\n(i) 持续长度是弯曲模量 $K$ 与热能 $k_B T$ 之比。此关系分别适用于每个贡献。\n$$\n\\ell_p^{elec} = \\frac{K_{elec}}{k_B T}\n$$\n其中 $K_{elec}$ 是对弯曲模量的静电贡献。\n\n(ii) 根据 Odijk–Skolnick–Fixman (OSF) 论证，对于均匀带电圆柱体，静电弯曲模量与 Debye 屏蔽参数 $\\kappa$ 的平方成反比。\n$$\nK_{elec} \\propto \\kappa^{-2}\n$$\n结合这些可得 $\\ell_p^{elec} \\propto \\kappa^{-2}$。\n\n(iii) 根据线性化 Debye–Hückel 理论，代表屏蔽长度倒数的 Debye 参数与离子强度的平方根成正比。\n$$\n\\kappa \\propto I^{1/2}\n$$\n因此，$\\kappa^2 \\propto I$。\n\n将此标度关系代入 $\\ell_p^{elec}$ 的表达式中，我们发现静电持续长度与离子强度成反比。\n$$\n\\ell_p^{elec} \\propto (I^{1/2})^{-2} \\implies \\ell_p^{elec} \\propto I^{-1}\n$$\n我们引入一个比例常数 $a$，它综合了各种物理因素，如热能、溶剂介电常数和聚合物的线性电荷密度。由此得出静电贡献的表达式：\n$$\n\\ell_p^{elec}(I) = \\frac{a}{I}\n$$\n结合力学和静电部分，我们得到了总持续长度作为离子强度函数的最小双参数模型：\n$$\n\\ell_p(I) = \\ell_p^0 + \\frac{a}{I}\n$$\n该模型与所有前提都一致。待确定的两个参数是 $\\ell_p^0$（内在持续长度）和 $a$（一个量化静电效应强度的参数）。\n\n**2. 通过普通最小二乘法 (OLS) 进行参数估计**\n\n推导出的模型在其参数 $\\ell_p^0$ 和 $a$ 上是线性的。对于一组 $n$ 个测量值 $(I_i, \\ell_{p,i})$，我们可以为每个数据点 $i$ 写出模型：\n$$\n\\ell_{p,i} = \\ell_p^0 + a \\left(\\frac{1}{I_i}\\right) + \\varepsilon_i\n$$\n其中 $\\varepsilon_i$ 是第 $i$ 次测量的残差。这是一个简单的线性回归问题。令因变量为 $y_i = \\ell_{p,i}$，并定义一个设计变量 $x_i = 1/I_i$。模型变为：\n$$\ny_i = \\ell_p^0 \\cdot 1 + a \\cdot x_i + \\varepsilon_i\n$$\n这个包含 $n$ 个方程的系统可以用矩阵形式表示为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$，其中：\n- $\\mathbf{y}$ 是观测到的持续长度的 $n \\times 1$ 向量：$\\mathbf{y} = [\\ell_{p,1}, \\ell_{p,2}, \\dots, \\ell_{p,n}]^T$。\n- $\\mathbf{X}$ 是 $n \\times 2$ 的设计矩阵，其第一列是全为 1 的向量（用于截距项），第二列是设计变量值的向量：\n$$\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_n \\end{pmatrix} = \\begin{pmatrix} 1  1/I_1 \\\\ 1  1/I_2 \\\\ \\vdots  \\vdots \\\\ 1  1/I_n \\end{pmatrix}\n$$\n- $\\boldsymbol{\\beta}$ 是待估计的 $2 \\times 1$ 参数向量：$\\boldsymbol{\\beta} = [\\ell_p^0, a]^T$。\n- $\\boldsymbol{\\varepsilon}$ 是 $n \\times 1$ 的残差向量。\n\n普通最小二乘法找到参数向量 $\\hat{\\boldsymbol{\\beta}}$，以最小化残差平方和 $S = \\boldsymbol{\\varepsilon}^T \\boldsymbol{\\varepsilon} = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})$。这个最小化问题的解由正规方程组给出：\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的（只要不是所有的 $I_i$ 值都相同，这个条件就成立），$\\boldsymbol{\\beta}$ 的 OLS 估计量为：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n程序将实现这个矩阵方程，为每个提供的数据集找到 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\ell}_p^0, \\hat{a}]^T$ 的值。\n\n**3. 参数解释**\n\n- $\\hat{\\ell}_p^0$: $\\hat{\\boldsymbol{\\beta}}$ 的第一个元素是 $\\ell_p$ 对 $1/I$ 回归的截距。它代表了无限离子强度下（$1/I \\to 0$）的持续长度，对应于聚合物的内在力学刚度。其单位为纳米（$\\mathrm{nm}$）。\n- $\\hat{a}$: $\\hat{\\boldsymbol{\\beta}}$ 的第二个元素是回归的斜率。它量化了静电对持续长度贡献的大小。根据模型 $\\ell_p(I) = \\ell_p^0 + a/I$，为了使 $\\ell_p$ 的单位为 $\\mathrm{nm}$，而 $I$ 的单位为摩尔（$\\mathrm{M}$ 或 $\\mathrm{mol \\cdot L^{-1}}$），参数 $a$ 的单位必须是 $\\mathrm{nm \\cdot M}$。\n\n实现部分将根据输入数据构建矩阵 $\\mathbf{X}$ 和 $\\mathbf{y}$，使用矩阵代数求解 $\\hat{\\boldsymbol{\\beta}}$，并报告四舍五入到三位小数的两个参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and fits a two-parameter model for polyelectrolyte persistence length\n    to experimental data using ordinary least squares.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (balanced low-to-high salt)\n        (\n            [0.001, 0.003, 0.01, 0.03, 0.1],\n            [95.3, 61.4666667, 50.1, 46.5666667, 45.5]\n        ),\n        # Case B (high salt, weak variation)\n        (\n            [0.2, 0.3, 0.5, 1.0],\n            [45.3, 45.1466667, 45.1, 45.06]\n        ),\n        # Case C (very low salt, strong electrostatics)\n        (\n            [0.0005, 0.001, 0.002, 0.005],\n            [144.5, 95.0, 70.1, 54.8]\n        ),\n        # Case D (different polymer or buffer)\n        (\n            [0.002, 0.005, 0.02, 0.2],\n            [92.2, 67.9, 56.0, 52.45]\n        ),\n    ]\n\n    # Store results for all cases\n    all_results = []\n\n    for i_vals, lp_vals in test_cases:\n        # Convert data to numpy arrays for vectorization\n        I = np.array(i_vals)\n        lp = np.array(lp_vals)\n\n        # The model is lp = lp_0 + a * (1/I).\n        # This is a linear model y = beta_0 + beta_1 * x,\n        # with y = lp, x = 1/I, beta_0 = lp_0, beta_1 = a.\n        \n        # Construct the design matrix X.\n        # The first column is for the intercept (lp_0), so it's all ones.\n        # The second column is the independent variable, 1/I.\n        design_variable = 1.0 / I\n        X = np.c_[np.ones(len(I)), design_variable]\n\n        # The vector of observations y is the persistence length data.\n        y = lp\n\n        # Solve the normal equations for the parameters beta = [lp_0, a]:\n        # (X^T * X) * beta = X^T * y\n        # beta = (X^T * X)^-1 * X^T * y\n        \n        try:\n            # Calculate (X^T * X)\n            XTX = X.T @ X\n            # Calculate its inverse\n            XTX_inv = np.linalg.inv(XTX)\n            # Calculate X^T * y\n            XTy = X.T @ y\n            # Solve for the parameter vector beta_hat\n            beta_hat = XTX_inv @ XTy\n        except np.linalg.LinAlgError:\n            # In case of a singular matrix, which shouldn't happen for valid input.\n            beta_hat = [np.nan, np.nan]\n\n        # The parameters are lp_0 (intercept) and a (slope).\n        lp0_fit = beta_hat[0]\n        a_fit = beta_hat[1]\n\n        # Store the results for this case.\n        all_results.append((lp0_fit, a_fit))\n\n    # Format the final output string as a list of two-element lists,\n    # with each parameter rounded to exactly three decimal places.\n    # The format specifier ':.3f' ensures trailing zeros are included.\n    # The construction avoids spaces that Python's default list-to-string\n    # conversion would add, matching the implicit formatting of the prompt.\n    output_parts = []\n    for lp0, a in all_results:\n        output_parts.append(f\"[{lp0:.3f},{a:.3f}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2907118"}, {"introduction": "从单个聚合物的静态特性出发，我们现在转向其动态功能。肌动蛋白丝是细胞骨架的关键组成部分，它通过在细胞膜等障碍物上进行聚合来产生推动力，从而驱动细胞迁移和形态变化。\n\n在本练习 ([@problem_id:2907121]) 中，您将深入研究布朗棘轮（Brownian ratchet）模型，这是一个解释细胞如何利用热涨落产生定向力的经典物理模型。通过从统计力学的第一性原理推导出力-速度关系，您将能够洞悉纳米尺度下生物系统将随机热能转化为宏观机械功的精妙机制。", "problem": "一个肌动蛋白丝在恒定阻力下，顶着一个刚性平面障碍物生长。该蛋白丝通过沿其轴线方向添加大小为 $a$ 的单体来伸长。设蛋白丝尖端与障碍物之间的间隙为 $z \\ge 0$。假设在温度 $T$ 和恒定阻力 $f$ 的作用下，障碍物处于准静态热平衡状态，因此间隙的玻尔兹曼权重由势能 $U(z) = f z$ 决定。单体的添加要求间隙大于单体尺寸，即 $z  a$。与单体添加相比，忽略单体解离。当满足几何约束 $z  a$ 时，单体添加是一个泊松过程，其尝试速率为 $k_{\\mathrm{on}} c$，其中 $k_{\\mathrm{on}}$ 是开启速率常数，$c$ 是单体浓度。\n\n1. 从势能 $U(z) = f z$ 下 $z$ 的玻尔兹曼分布和上述动力学模型出发，推导蛋白丝尖端的力-速度关系 $v(f)$。\n\n2. 在温度 $T = 300\\,\\mathrm{K}$ 下，对负载下蛋白丝的生长速度进行了以下实验测量：\n   - 当 $f = 0.0\\,\\mathrm{pN}$ 时, $v = 130\\,\\mathrm{nm\\,s^{-1}}$。\n   - 当 $f = 2.0\\,\\mathrm{pN}$ 时, $v = 35.3\\,\\mathrm{nm\\,s^{-1}}$。\n   \n   使用您推导的关系式，将数据视为具有指数负载依赖性，并提取单体尺寸 $a$。您可以取玻尔兹曼常数为 $k_B = 1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$，并使用 $1\\,\\mathrm{J} = 10^{21}\\,\\mathrm{pN\\,nm}$。将您的最终结果四舍五入到三位有效数字。最终答案以纳米为单位表示。", "solution": "该问题陈述构成了统计生物物理学中一个适定问题，特别涉及了通过聚合蛋白丝产生力的布朗棘轮模型。所有提供的信息都具有科学依据、一致且足以进行推导和计算。因此，该问题被认为是有效的。\n\n根据要求，解答分为两部分：首先，推导力-速度关系；其次，根据提供的实验数据计算单体尺寸。\n\n第一部分：推导力-速度关系 $v(f)$。\n\n蛋白丝的平均生长速度 $v$ 是每次单体添加事件增加的长度 $a$ 与这些事件的平均速率 $\\langle R \\rangle$ 的乘积。\n$$\nv = a \\langle R \\rangle\n$$\n问题陈述，单体添加是一个泊松过程，其尝试速率为 $k_{\\mathrm{on}}c$，只有当蛋白丝尖端与障碍物之间的间隙 $z$ 大于单体尺寸 $a$ 时才能成功。因此，对于给定的间隙 $z$，瞬时添加速率为：\n$$\nR(z) = \\begin{cases} k_{\\mathrm{on}}c  \\text{if } z  a \\\\ 0  \\text{if } z \\le a \\end{cases}\n$$\n平均速率 $\\langle R \\rangle$ 是通过对间隙大小 $z$ 的概率分布求 $R(z)$ 的平均值得到的。\n$$\n\\langle R \\rangle = \\int_0^\\infty R(z) p(z) dz\n$$\n其中 $p(z)$ 是间隙大小 $z$ 的概率密度函数。问题指明，在温度 $T$ 和势能 $U(z) = fz$ 的作用下，间隙处于准静态热平衡状态。概率密度遵循玻尔兹曼分布：\n$$\np(z) = \\frac{\\exp\\left(-\\frac{U(z)}{k_B T}\\right)}{Z} = \\frac{\\exp\\left(-\\frac{fz}{k_B T}\\right)}{Z}\n$$\n其中 $k_B$ 是玻尔兹曼常数，$Z$ 是配分函数。配分函数是归一化常数，通过对所有可能的状态（即所有 $z \\ge 0$）积分玻尔兹曼因子得到。\n$$\nZ = \\int_0^\\infty \\exp\\left(-\\frac{fz}{k_B T}\\right) dz\n$$\n对于 $f  0$，该积分收敛：\n$$\nZ = \\left[ -\\frac{k_B T}{f} \\exp\\left(-\\frac{fz}{k_B T}\\right) \\right]_0^\\infty = 0 - \\left(-\\frac{k_B T}{f} \\exp(0)\\right) = \\frac{k_B T}{f}\n$$\n现在我们可以计算平均速率 $\\langle R \\rangle$：\n$$\n\\langle R \\rangle = \\int_0^\\infty R(z) p(z) dz = \\int_a^\\infty (k_{\\mathrm{on}}c) \\frac{\\exp\\left(-\\frac{fz}{k_B T}\\right)}{Z} dz\n$$\n代入 $Z$ 的表达式：\n$$\n\\langle R \\rangle = (k_{\\mathrm{on}}c) \\frac{f}{k_B T} \\int_a^\\infty \\exp\\left(-\\frac{fz}{k_B T}\\right) dz\n$$\n我们计算这个积分：\n$$\n\\int_a^\\infty \\exp\\left(-\\frac{fz}{k_B T}\\right) dz = \\left[ -\\frac{k_B T}{f} \\exp\\left(-\\frac{fz}{k_B T}\\right) \\right]_a^\\infty = 0 - \\left(-\\frac{k_B T}{f} \\exp\\left(-\\frac{fa}{k_B T}\\right)\\right) = \\frac{k_B T}{f} \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n将此结果代回 $\\langle R \\rangle$ 的表达式中：\n$$\n\\langle R \\rangle = (k_{\\mathrm{on}}c) \\frac{f}{k_B T} \\left( \\frac{k_B T}{f} \\exp\\left(-\\frac{fa}{k_B T}\\right) \\right) = k_{\\mathrm{on}}c \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n最后，速度 $v(f)$ 为：\n$$\nv(f) = a \\langle R \\rangle = a k_{\\mathrm{on}}c \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n零力下的速度 $v_0 = v(f=0)$ 为 $v_0 = a k_{\\mathrm{on}}c$。因此，力-速度关系可以写为：\n$$\nv(f) = v_0 \\exp\\left(-\\frac{fa}{k_B T}\\right)\n$$\n这就是所求的力-速度关系，它表明速度随着对抗力的增加而呈指数衰减。\n\n第二部分：计算单体尺寸 $a$。\n\n我们有两个给定的数据点：\n1. $f_1 = 0.0\\,\\mathrm{pN}$, $v_1 = 130\\,\\mathrm{nm\\,s^{-1}}$\n2. $f_2 = 2.0\\,\\mathrm{pN}$, $v_2 = 35.3\\,\\mathrm{nm\\,s^{-1}}$\n\n从第一个数据点，我们确定零力速度为：$v_0 = v(f_1) = v_1 = 130\\,\\mathrm{nm\\,s^{-1}}$。\n\n使用第二个数据点，我们可以写出：\n$$\nv_2 = v_0 \\exp\\left(-\\frac{f_2 a}{k_B T}\\right)\n$$\n为了求解 $a$，我们首先重新整理方程：\n$$\n\\frac{v_2}{v_0} = \\exp\\left(-\\frac{f_2 a}{k_B T}\\right)\n$$\n对两边取自然对数：\n$$\n\\ln\\left(\\frac{v_2}{v_0}\\right) = -\\frac{f_2 a}{k_B T}\n$$\n分离出 $a$，我们得到：\n$$\na = -\\frac{k_B T}{f_2} \\ln\\left(\\frac{v_2}{v_0}\\right)\n$$\n现在，我们必须计算数值。首先，我们用与所提供的力和距离单位（$\\mathrm{pN}$ 和 $\\mathrm{nm}$）相兼容的单位计算热能 $k_B T$。\n$T = 300\\,\\mathrm{K}$\n$k_B = 1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}$\n单位换算为 $1\\,\\mathrm{J} = 10^{21}\\,\\mathrm{pN\\,nm}$。\n$$\nk_B T = (1.380649 \\times 10^{-23}\\,\\mathrm{J\\,K^{-1}}) \\times (300\\,\\mathrm{K}) = 4.141947 \\times 10^{-21}\\,\\mathrm{J}\n$$\n$$\nk_B T = (4.141947 \\times 10^{-21}\\,\\mathrm{J}) \\times \\left(\\frac{10^{21}\\,\\mathrm{pN\\,nm}}{1\\,\\mathrm{J}}\\right) = 4.141947\\,\\mathrm{pN\\,nm}\n$$\n现在我们将这些数值代入 $a$ 的表达式中：\n$f_2 = 2.0\\,\\mathrm{pN}$\n$v_0 = 130\\,\\mathrm{nm\\,s^{-1}}$\n$v_2 = 35.3\\,\\mathrm{nm\\,s^{-1}}$\n$$\na = -\\frac{4.141947\\,\\mathrm{pN\\,nm}}{2.0\\,\\mathrm{pN}} \\ln\\left(\\frac{35.3}{130}\\right)\n$$\n$$\na = -2.0709735\\,\\mathrm{nm} \\times \\ln(0.271538...)\n$$\n$$\na = -2.0709735\\,\\mathrm{nm} \\times (-1.30351...)\n$$\n$$\na \\approx 2.7001\\,\\mathrm{nm}\n$$\n按要求将结果四舍五入到三位有效数字，我们得到：\n$$\na = 2.70\\,\\mathrm{nm}\n$$\n这个数值与已知的肌动蛋白丝中每个单体的上升高度这一结构参数非常吻合。", "answer": "$$\\boxed{2.70}$$", "id": "2907121"}, {"introduction": "为了进一步拓宽我们的视野，我们将探讨一个适用于更广泛场景的非平衡统计力学普适定理。在生物物理学中，精确测量如折叠自由能 $\\Delta F$ 这样的平衡态热力学量往往十分困难，因为维持严格的平衡条件极具挑战性。\n\nJarzynski 恒等式为我们提供了一个巧妙的解决方案，它将非平衡过程中所做的功与平衡态的自由能差联系起来。在本练习 ([@problem_id:2907045]) 中，您将亲手应用这一现代统计力学的基石。通过分析模拟的单分子拉伸实验数据，您不仅将学会如何估算蛋白质的折叠自由能，还将处理实际数据分析中至关重要的有限样本偏差校正问题。", "problem": "您会获得一组通过原子力显微镜拉伸和解折叠单个蛋白质结构域得到的重复非平衡功测量值。这些功值是从一个由固定拉伸方案产生的未知非平衡功分布中抽取的独立同分布样本。假设所有的功都以热能为单位表示，即以玻尔兹曼常数乘以温度 ($k_{\\mathrm{B}}T$) 的倍数表示。在这些单位中，逆热能为 $\\beta = 1$。您的任务是利用从非平衡功关系推导出的偏差校正估计量，根据这些非平衡功值来估计折叠态和解折叠态之间的平衡自由能差 $\\Delta F$，并评估该估计量的收敛性。\n\n使用非平衡统计力学中一个经过充分检验的结果——Jarzynski 等式作为基本依据：\n$$\n\\left\\langle e^{-\\beta W} \\right\\rangle = e^{-\\beta \\Delta F},\n$$\n其中 $W$ 是功随机变量，$\\beta$ 是逆温度，$\\langle \\cdot \\rangle$ 表示对同一方案的重复实现的系综平均。\n\n设 $\\{W_i\\}_{i=1}^N$ 为一个功值样本。定义 $Y_i = e^{-\\beta W_i}$，样本均值 $\\bar{Y}_N = \\frac{1}{N}\\sum_{i=1}^N Y_i$，以及无偏样本方差 $s_Y^2 = \\frac{1}{N-1}\\sum_{i=1}^N (Y_i - \\bar{Y}_N)^2$。朴素 Jarzynski 估计量使用 $\\bar{Y}_N$ 将 $\\Delta F$ 估计为 $-\\beta^{-1}\\ln \\bar{Y}_N$。然而，由于对数的凹性，该估计量在有限的 $N$ 下是有偏的。从 Jarzynski 等式出发，使用对数函数在 $Y$ 的总体均值周围的二阶泰勒（delta 方法）展开，推导出一个在期望上能够消除领先的 $\\mathcal{O}(1/N)$ 偏差项的偏差校正估计量。然后按如下方式实现该估计量和收敛性评估。\n\n收敛性评估要求：对于给定的容差 $\\varepsilon  0$，计算数据长度为 $n = 3, 4, \\dots, N$ 的前缀的运行偏差校正估计值 $\\widehat{\\Delta F}_{\\mathrm{bc}}(n)$。将收敛指数 $n^\\star$ 定义为集合 $\\{3,\\dots,N\\}$ 中满足以下条件的最小的 $n$：对于所有 $m \\in \\{n+1,\\dots,N\\}$，\n$$\n\\left| \\widehat{\\Delta F}_{\\mathrm{bc}}(m) - \\widehat{\\Delta F}_{\\mathrm{bc}}(m-1) \\right| \\le \\varepsilon.\n$$\n如果不存在这样的 $n$，则返回 $-1$ 作为收敛指数。\n\n实现要求：\n- 所有的功都以 $k_{\\mathrm{B}}T$ 为单位，因此设置 $\\beta = 1$。您最终的自由能估计值也以 $k_{\\mathrm{B}}T$ 为单位表示。\n- 在偏差校正中，使用以 $N-1$ 为除数计算的无偏样本方差 $s_Y^2$ 进行方差估计。\n- 为了进行收敛性扫描，从 $n=3$ 开始，以确保方差是良定义的，并且不会被极小的样本量轻易主导。\n- 将所有报告的自由能估计值四舍五入到 $6$ 位小数。\n- 最终程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表包含每个测试用例的以下序列：使用所有数据的朴素 Jarzynski 估计值、使用所有数据的偏差校正估计值以及收敛指数 $n^\\star$。总体输出是按下列顺序列出的所有测试用例的这些三元组的串联。\n\n测试套件：\n- 用例 A (中等耗散): $N = 30$, $\\varepsilon = 0.1$, $\\beta = 1$，功列表如下\n  $$\n  W = [\\, 6.2,\\, 6.8,\\, 8.1,\\, 7.5,\\, 6.9,\\, 7.2,\\, 7.8,\\, 6.4,\\, 5.9,\\, 8.3,\\, 7.0,\\, 7.1,\\, 6.6,\\, 8.0,\\, 7.4,\\, 6.5,\\, 7.6,\\, 8.2,\\, 6.7,\\, 7.3,\\, 7.9,\\, 6.3,\\, 5.8,\\, 8.4,\\, 6.1,\\, 7.7,\\, 8.5,\\, 5.7,\\, 6.0,\\, 7.0 \\,].\n  $$\n- 用例 B (近平衡): $N = 20$, $\\varepsilon = 0.05$, $\\beta = 1$，功列表如下\n  $$\n  W = [\\, 3.4,\\, 3.6,\\, 3.7,\\, 3.3,\\, 3.5,\\, 3.6,\\, 3.2,\\, 3.8,\\, 3.5,\\, 3.4,\\, 3.6,\\, 3.5,\\, 3.7,\\, 3.3,\\, 3.4,\\, 3.6,\\, 3.5,\\, 3.7,\\, 3.3,\\, 3.4 \\,].\n  $$\n- 用例 C (远离平衡，宽分布): $N = 50$, $\\varepsilon = 0.1$, $\\beta = 1$，功列表如下\n  $$\n  W = [\\, 12.7,\\, 13.1,\\, 12.5,\\, 13.8,\\, 12.9,\\, 14.2,\\, 12.3,\\, 13.5,\\, 12.8,\\, 14.0,\\, 13.2,\\, 12.6,\\, 13.9,\\, 12.4,\\, 13.3,\\, 12.7,\\, 14.1,\\, 12.2,\\, 13.6,\\, 12.9,\\, 13.0,\\, 14.3,\\, 12.1,\\, 13.4,\\, 12.8,\\, 13.7,\\, 12.0,\\, 13.5,\\, 11.9,\\, 14.4,\\, 12.6,\\, 13.8,\\, 12.7,\\, 13.1,\\, 12.5,\\, 14.0,\\, 13.2,\\, 11.8,\\, 13.6,\\, 12.4,\\, 13.3,\\, 12.7,\\, 13.9,\\, 12.3,\\, 13.5,\\, 11.7,\\, 14.1,\\, 12.2,\\, 13.4,\\, 11.6 \\,].\n  $$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[\\, \\widehat{\\Delta F}_{\\mathrm{J}}^{(A)},\\, \\widehat{\\Delta F}_{\\mathrm{bc}}^{(A)},\\, n_\\star^{(A)},\\, \\widehat{\\Delta F}_{\\mathrm{J}}^{(B)},\\, \\widehat{\\Delta F}_{\\mathrm{bc}}^{(B)},\\, n_\\star^{(B)},\\, \\widehat{\\Delta F}_{\\mathrm{J}}^{(C)},\\, \\widehat{\\Delta F}_{\\mathrm{bc}}^{(C)},\\, n_\\star^{(C)} \\,],\n$$\n其中上标 $(A)$、$(B)$ 和 $(C)$ 分别指代用例 A、B 和 C。报告所有以 $k_{\\mathrm{B}}T$ 为单位并将四舍五入到 $6$ 位小数的 $\\Delta F$ 值；将每个 $n_\\star$ 报告为整数。", "solution": "问题陈述被评估为科学上合理、适定且客观。它基于非平衡统计力学的既定原理，特别是 Jarzynski 等式，并涉及单分子生物物理学中的一个标准应用。所提供的数据和要求的计算是现实且明确定义的。\n\n在收敛指数 $n^\\star$ 的问题定义中存在一个轻微的歧义。其定义是：“$n^\\star$ 是集合 $\\{3,\\dots,N\\}$ 中满足以下条件的最小的 $n$：对于所有 $m \\in \\{n+1,\\dots,N\\}$，有 $|\\widehat{\\Delta F}_{\\mathrm{bc}}(m) - \\widehat{\\Delta F}_{\\mathrm{bc}}(m-1)| \\le \\varepsilon$。” 对于 $n=N$ 的情况，条件“对于所有 $m \\in \\{N+1,\\dots,N\\}$”是空泛为真的，因为 $m$ 的取值集合是空的。这意味着在 $\\{3,\\dots,N\\}$ 范围内总会存在一个 $n^\\star$ 的解，这与后续指令“如果不存在这样的 $n$，则返回 $-1$ 作为收敛指数”相矛盾。这表明，在给定的约束（所有 $N \\ge 3$）下，关于返回 $-1$ 的条款可能是多余的，或者意在采用对空集上量词的非标准解释。我将采用标准的数学解释。由此产生的用于寻找 $n^\\star$ 的算法是鲁棒且无歧义的：如果估计序列在数据结束时已经稳定，则会找到一个有限的收敛指数；否则，该指数将对应于最后一个显著波动的点。这种方法在科学上是合理的，并且在所有 $N \\ge 3$ 的情况下都能为 $n^\\star$ 提供一个确定值。\n\n解决方案分两步进行：首先，推导自由能差 $\\Delta F$ 的偏差校正估计量；其次，实现计算和收敛性分析。\n\n**1. 偏差校正估计量的推导**\n\n目标是使用 Jarzynski 等式来估计平衡自由能差 $\\Delta F$：\n$$\n\\left\\langle e^{-\\beta W} \\right\\rangle = e^{-\\beta \\Delta F}\n$$\n其中 $W$ 是在非平衡过程中所做的功，$\\beta = (k_{\\mathrm{B}}T)^{-1}$ 是逆热能，$\\langle \\cdot \\rangle$ 是系综平均。给定一组 $N$ 个功的测量值 $\\{W_i\\}_{i=1}^N$，我们定义量 $Y_i = e^{-\\beta W_i}$。$Y$ 的总体均值为 $\\mu_Y = E[Y_i] = \\langle e^{-\\beta W} \\rangle$。真实的自由能差由 $\\Delta F = -\\beta^{-1}\\ln(\\mu_Y)$ 给出。\n\n通过用样本均值 $\\bar{Y}_N = \\frac{1}{N}\\sum_{i=1}^N Y_i$ 替换总体均值 $\\mu_Y$，可以构建一个 $\\Delta F$ 的朴素估计量：\n$$\n\\widehat{\\Delta F}_{\\mathrm{J}} = -\\beta^{-1}\\ln(\\bar{Y}_N)\n$$\n由于对数函数是凹函数，该估计量对于有限的 $N$ 是有偏的。为了找到领先阶偏差，我们对函数 $f(x) = \\ln(x)$ 在总体均值 $\\mu_Y$ 周围进行二阶泰勒展开，并在样本均值 $\\bar{Y}_N$ 处求值：\n$$\n\\ln(\\bar{Y}_N) \\approx \\ln(\\mu_Y) + (\\bar{Y}_N - \\mu_Y)f'(\\mu_Y) + \\frac{1}{2}(\\bar{Y}_N - \\mu_Y)^2 f''(\\mu_Y)\n$$\n导数为 $f'(x) = 1/x$ 和 $f''(x) = -1/x^2$。代入这些可得：\n$$\n\\ln(\\bar{Y}_N) \\approx \\ln(\\mu_Y) + \\frac{\\bar{Y}_N - \\mu_Y}{\\mu_Y} - \\frac{(\\bar{Y}_N - \\mu_Y)^2}{2\\mu_Y^2}\n$$\n对两边取期望：\n$$\nE[\\ln(\\bar{Y}_N)] \\approx E[\\ln(\\mu_Y)] + \\frac{E[\\bar{Y}_N - \\mu_Y]}{\\mu_Y} - \\frac{E[(\\bar{Y}_N - \\mu_Y)^2]}{2\\mu_Y^2}\n$$\n我们知道 $E[\\bar{Y}_N] = \\mu_Y$，所以 $E[\\bar{Y}_N - \\mu_Y] = 0$。项 $E[(\\bar{Y}_N - \\mu_Y)^2]$ 是样本均值的方差，即 $\\text{Var}(\\bar{Y}_N)$。对于独立同分布的 $Y_i$，$\\text{Var}(\\bar{Y}_N) = \\sigma_Y^2/N$，其中 $\\sigma_Y^2 = \\text{Var}(Y_i)$ 是 $Y$ 的总体方差。\n因此，对数的期望值为：\n$$\nE[\\ln(\\bar{Y}_N)] \\approx \\ln(\\mu_Y) - \\frac{\\sigma_Y^2}{2N\\mu_Y^2}\n$$\n现在，我们求朴素估计量 $\\widehat{\\Delta F}_{\\mathrm{J}}$ 的期望：\n$$\nE[\\widehat{\\Delta F}_{\\mathrm{J}}] = E[-\\beta^{-1}\\ln(\\bar{Y}_N)] = -\\beta^{-1}E[\\ln(\\bar{Y}_N)] \\approx -\\beta^{-1}\\left(\\ln(\\mu_Y) - \\frac{\\sigma_Y^2}{2N\\mu_Y^2}\\right)\n$$\n$$\nE[\\widehat{\\Delta F}_{\\mathrm{J}}] \\approx -\\beta^{-1}\\ln(\\mu_Y) + \\frac{\\beta^{-1}\\sigma_Y^2}{2N\\mu_Y^2} = \\Delta F + \\frac{\\beta^{-1}\\sigma_Y^2}{2N\\mu_Y^2}\n$$\n领先阶偏差是第二项，$\\text{Bias}(\\widehat{\\Delta F}_{\\mathrm{J}}) \\approx \\frac{\\beta^{-1}\\sigma_Y^2}{2N\\mu_Y^2}$。通过从朴素估计量中减去此偏差的估计值，可以构建一个偏差校正估计量 $\\widehat{\\Delta F}_{\\mathrm{bc}}$：\n$$\n\\widehat{\\Delta F}_{\\mathrm{bc}} = \\widehat{\\Delta F}_{\\mathrm{J}} - \\widehat{\\text{Bias}}\n$$\n为了估计偏差，我们用它们的样本估计值来代替总体参数 $\\mu_Y$ 和 $\\sigma_Y^2$：用 $\\bar{Y}_N$ 代替 $\\mu_Y$，用无偏样本方差 $s_Y^2 = \\frac{1}{N-1}\\sum_{i=1}^N (Y_i - \\bar{Y}_N)^2$ 代替 $\\sigma_Y^2$。这得出了偏差校正估计量：\n$$\n\\widehat{\\Delta F}_{\\mathrm{bc}} = -\\beta^{-1}\\ln(\\bar{Y}_N) - \\frac{\\beta^{-1}s_Y^2}{2N\\bar{Y}_N^2}\n$$\n鉴于所有计算都是以 $k_{\\mathrm{B}}T$ 为单位进行的，我们设置 $\\beta=1$：\n$$\n\\widehat{\\Delta F}_{\\mathrm{bc}} = -\\ln(\\bar{Y}_N) - \\frac{s_Y^2}{2N\\bar{Y}_N^2}\n$$\n\n**2. 计算和收敛算法**\n\n实现过程如下：\n首先，对于每个测试用例，使用完整数据集 $\\{W_i\\}_{i=1}^N$ 和推导出的公式来计算朴素估计值 $\\widehat{\\Delta F}_{\\mathrm{J}}(N)$ 和偏差校正估计值 $\\widehat{\\Delta F}_{\\mathrm{bc}}(N)$。\n\n其次，评估偏差校正估计量的收敛性。这包括为大小从 $n=3$ 增加到 $n=N$ 的数据前缀计算一系列估计值 $\\widehat{\\Delta F}_{\\mathrm{bc}}(n)$。\n\n收敛指数 $n^\\star$ 是根据这一系列估计值的稳定性来确定的。具体来说，我们确定估计值变化超过容差 $\\varepsilon$ 的最后一个样本大小 $m$：设 $S = \\{m \\in \\{4, \\dots, N\\} \\mid |\\widehat{\\Delta F}_{\\mathrm{bc}}(m) - \\widehat{\\Delta F}_{\\mathrm{bc}}(m-1)|  \\varepsilon \\}$。\n- 如果集合 $S$ 为空，则意味着估计值在整个过程（对于 $n \\ge 3$）中都是稳定的，因此我们定义 $n^\\star = 3$。\n- 如果 $S$ 不为空，则最后一个显著波动的点出现在 $m_{\\text{max}} = \\max S$。对于任何 $n  m_{\\text{max}}$，收敛准则都会被违反。因此，序列尾部开始稳定的最小 $n$ 值为 $n=m_{\\text{max}}$。因此，我们设置 $n^\\star = m_{\\text{max}}$。\n\n对于任何给定的 $N \\ge 3$ 的数据集，此过程都为 $n^\\star \\in \\{3, \\dots, N\\}$ 提供了一个唯一且良定义的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final formatted output.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"W\": [6.2, 6.8, 8.1, 7.5, 6.9, 7.2, 7.8, 6.4, 5.9, 8.3, 7.0, 7.1, 6.6, 8.0, 7.4, 6.5, 7.6, 8.2, 6.7, 7.3, 7.9, 6.3, 5.8, 8.4, 6.1, 7.7, 8.5, 5.7, 6.0, 7.0],\n            \"N\": 30,\n            \"epsilon\": 0.1,\n            \"beta\": 1.0\n        },\n        {\n            \"name\": \"Case B\",\n            \"W\": [3.4, 3.6, 3.7, 3.3, 3.5, 3.6, 3.2, 3.8, 3.5, 3.4, 3.6, 3.5, 3.7, 3.3, 3.4, 3.6, 3.5, 3.7, 3.3, 3.4],\n            \"N\": 20,\n            \"epsilon\": 0.05,\n            \"beta\": 1.0\n        },\n        {\n            \"name\": \"Case C\",\n            \"W\": [12.7, 13.1, 12.5, 13.8, 12.9, 14.2, 12.3, 13.5, 12.8, 14.0, 13.2, 12.6, 13.9, 12.4, 13.3, 12.7, 14.1, 12.2, 13.6, 12.9, 13.0, 14.3, 12.1, 13.4, 12.8, 13.7, 12.0, 13.5, 11.9, 14.4, 12.6, 13.8, 12.7, 13.1, 12.5, 14.0, 13.2, 11.8, 13.6, 12.4, 13.3, 12.7, 13.9, 12.3, 13.5, 11.7, 14.1, 12.2, 13.4, 11.6],\n            \"N\": 50,\n            \"epsilon\": 0.1,\n            \"beta\": 1.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        W_list = case[\"W\"]\n        N = case[\"N\"]\n        epsilon = case[\"epsilon\"]\n        beta = case[\"beta\"]\n\n        W = np.array(W_list)\n        \n        # 1. Calculate estimators for the full dataset.\n        Y = np.exp(-beta * W)\n        Y_bar = np.mean(Y)\n        \n        # Naive Jarzynski estimator\n        delta_F_J_full = -1/beta * np.log(Y_bar)\n        \n        # Unbiased sample variance with N-1 denominator\n        s_Y_sq = np.var(Y, ddof=1)\n        \n        # Bias correction term and final corrected estimator\n        bias_correction = (s_Y_sq / beta) / (2 * N * Y_bar**2)\n        delta_F_bc_full = delta_F_J_full - bias_correction\n\n        # 2. Convergence analysis\n        # Calculate running bias-corrected estimates for n = 3, 4, ..., N\n        running_bc_estimates = []\n        for n in range(3, N + 1):\n            W_prefix = W[:n]\n            Y_prefix = np.exp(-beta * W_prefix)\n            Y_bar_n = np.mean(Y_prefix)\n            \n            # Naive estimator for prefix\n            delta_F_J_n = -1/beta * np.log(Y_bar_n)\n            \n            # Unbiased variance for prefix\n            s_Y_sq_n = np.var(Y_prefix, ddof=1)\n            \n            # Bias correction for prefix\n            bias_corr_n = (s_Y_sq_n / beta) / (2 * n * Y_bar_n**2)\n            delta_F_bc_n = delta_F_J_n - bias_corr_n\n            running_bc_estimates.append(delta_F_bc_n)\n\n        # Determine the convergence index n_star.\n        # The logic is to find the largest 'm' for which the stability condition is violated.\n        # If no such 'm' exists, the sequence is stable from the beginning (n=3).\n        \n        m_max_instability = -1\n        # The list running_bc_estimates is indexed 0 to N-3.\n        # The estimate for sample size n is at index n-3.\n        # We are calculating differences for m from 4 to N.\n        for m in range(4, N + 1):\n            # Difference between estimate at m and m-1\n            # Index for m is m-3, for m-1 is m-4\n            diff = abs(running_bc_estimates[m-3] - running_bc_estimates[m-4])\n            if diff > epsilon:\n                m_max_instability = m\n\n        if m_max_instability == -1:\n            # No instability was found for m >= 4, so the sequence is stable from n=3.\n            n_star = 3\n        else:\n            # The last point of instability determines the convergence index.\n            n_star = m_max_instability\n            \n        # Append results for this case.\n        # Free energy values are rounded to 6 decimal places.\n        all_results.append(f\"{delta_F_J_full:.6f}\")\n        all_results.append(f\"{delta_F_bc_full:.6f}\")\n        all_results.append(str(n_star))\n\n    # Print all results in the required single-line format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2907045"}]}