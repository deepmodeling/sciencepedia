{"hands_on_practices": [{"introduction": "在进行复杂的模拟之前，理解计算投入（样本量$N$）与结果精度之间的关系至关重要。本练习通过一个简单的蒙特卡洛积分问题，对标准误差进行了基础分析，揭示了其标志性的$1/\\sqrt{N}$收敛行为。这是规划任何严肃模拟项目时必须掌握的关键第一步([@problem_id:2653261])。", "problem": "在平衡统计力学中，可观测量的构型平均可以表示为相对于目标概率密度函数（PDF）的期望。考虑在构型空间$\\Omega=[0,1]$上定义的可观测量$f(x)=x^{2}$，并假设目标PDF $\\pi(x)$在$\\Omega$上是均匀分布的，即对于$x \\in [0,1]$，有$\\pi(x)=1$。您希望使用基于从$\\pi(x)$独立抽样的简单蒙特卡罗（MC）方法来估计积分$I=\\int_{0}^{1} f(x)\\,dx$。\n\n任务：\n1. 使用从$[0,1]$上的均匀分布中抽取的独立同分布样本$X_{1},\\dots,X_{N}$，构建$I$的简单蒙特卡罗估计量，并给出其以$N$表示的标准误差。\n2. 仅使用独立性下的期望和方差的第一性原理，确定所需的最小整数样本量$N$，使得估计量的标准误差严格小于$10^{-3}$。\n\n最终答案只提供最小整数$N$（无量纲）。最终答案中不应出现任何推导过程。最终答案必须是一个数字。如果需要取整，请报告满足要求的最小整数（不要对该整数应用有效数字规则）。", "solution": "该问题要求根据指定的精度确定蒙特卡罗估计的最小样本量。我们首先形式化地定义问题的各个组成部分。\n\n待估计的积分为$I = \\int_{0}^{1} f(x) \\, dx$，其中可观测函数为$f(x) = x^{2}$，定义在构型空间$\\Omega = [0,1]$上。目标概率密度函数在此区间上是均匀的，即对于$x \\in [0,1]$，有$\\pi(x) = 1$。因此，积分$I$等价于$f(X)$的期望，其中$X$是从均匀分布$U(0,1)$中抽取的随机变量。\n$$\nI = \\int_{0}^{1} x^{2} \\cdot \\pi(x) \\, dx = \\mathbb{E}_{\\pi}[f(X)] = \\mathbb{E}[X^{2}]\n$$\n这确立了第一性原理：该积分是一个期望。\n\n我们将$I$的简单蒙特卡罗估计量记为$\\hat{I}_{N}$，它被构造为在从分布$\\pi(x)$中抽取的$N$个独立同分布（i.i.d.）样本$X_{1}, \\dots, X_{N}$上求值的可观测量$f(x)$的样本均值。\n$$\n\\hat{I}_{N} = \\frac{1}{N} \\sum_{i=1}^{N} f(X_{i}) = \\frac{1}{N} \\sum_{i=1}^{N} X_{i}^{2}\n$$\n这就是任务第一部分的估计量。\n\n第一个任务的第二部分是确定该估计量的标准误差$\\text{SE}(\\hat{I}_{N})$。标准误差是估计量方差的平方根，即$\\text{SE}(\\hat{I}_{N}) = \\sqrt{\\text{Var}(\\hat{I}_{N})}$。由于样本的独立同分布性质，样本均值的方差等于可观测量的总体方差除以样本量$N$。\n$$\n\\text{Var}(\\hat{I}_{N}) = \\text{Var}\\left(\\frac{1}{N} \\sum_{i=1}^{N} X_{i}^{2}\\right) = \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\text{Var}(X_{i}^{2}) = \\frac{N \\cdot \\text{Var}(X^{2})}{N^{2}} = \\frac{\\text{Var}(X^{2})}{N}\n$$\n这里，$\\text{Var}(X^{2})$是可观测量$f(X) = X^{2}$的方差。一个随机变量$Y$的方差由$\\text{Var}(Y) = \\mathbb{E}[Y^{2}] - (\\mathbb{E}[Y])^{2}$给出。将此公式应用于我们的可观测量$X^{2}$：\n$$\n\\text{Var}(X^{2}) = \\mathbb{E}\\left[(X^{2})^{2}\\right] - \\left(\\mathbb{E}[X^{2}]\\right)^{2} = \\mathbb{E}[X^{4}] - \\left(\\mathbb{E}[X^{2}]\\right)^{2}\n$$\n为了继续计算，我们必须计算均匀分布$U(0,1)$的必要矩。一个随机变量$X \\sim U(0,1)$的$k$阶矩为：\n$$\n\\mathbb{E}[X^{k}] = \\int_{0}^{1} x^{k} \\pi(x) \\, dx = \\int_{0}^{1} x^{k} \\, dx = \\left[ \\frac{x^{k+1}}{k+1} \\right]_{0}^{1} = \\frac{1}{k+1}\n$$\n我们需要二阶矩和四阶矩：\n$$\n\\mathbb{E}[X^{2}] = \\frac{1}{2+1} = \\frac{1}{3}\n$$\n$$\n\\mathbb{E}[X^{4}] = \\frac{1}{4+1} = \\frac{1}{5}\n$$\n将这些结果代回可观测量的方差表达式中：\n$$\n\\text{Var}(X^{2}) = \\frac{1}{5} - \\left(\\frac{1}{3}\\right)^{2} = \\frac{1}{5} - \\frac{1}{9} = \\frac{9 - 5}{45} = \\frac{4}{45}\n$$\n有了这个结果，估计量$\\hat{I}_{N}$的标准误差为：\n$$\n\\text{SE}(\\hat{I}_{N}) = \\sqrt{\\frac{\\text{Var}(X^{2})}{N}} = \\sqrt{\\frac{4/45}{N}} = \\frac{2}{\\sqrt{45N}}\n$$\n这就完成了第一个任务的推导。\n\n第二个任务是找到最小整数样本量$N$，使得标准误差严格小于$10^{-3}$。我们建立不等式：\n$$\n\\text{SE}(\\hat{I}_{N})  10^{-3}\n$$\n$$\n\\frac{2}{\\sqrt{45N}}  10^{-3}\n$$\n现在我们解这个关于$N$的不等式。\n$$\n\\sqrt{45N} > \\frac{2}{10^{-3}} = 2 \\times 10^{3} = 2000\n$$\n两边平方得到：\n$$\n45N > (2000)^{2} = 4 \\times 10^{6}\n$$\n$$\nN > \\frac{4 \\times 10^{6}}{45}\n$$\n为了确定$N$的界限，我们计算这个分数：\n$$\n\\frac{4000000}{45} = \\frac{800000}{9} = 88888.888\\dots = 88888.\\overline{8}\n$$\n因此，条件是$N > 88888.\\overline{8}$。由于样本量$N$必须是整数，满足此严格不等式的最小整数值是大于$88888.\\overline{8}$的最小整数。\n$$\nN_{\\min} = 88889\n$$\n这就是所需的最小样本量。", "answer": "$$\\boxed{88889}$$", "id": "2653261"}, {"introduction": "许多物理化学系统都存在约束，使用非笛卡尔坐标系进行模拟往往更为自然。本练习将挑战球面上粒子的模拟，这要求我们从基本的Metropolis算法升级到更通用的Metropolis-Hastings框架。你将学习如何通过雅可比行列式（Jacobian）来正确处理坐标变换引起的几何畸变，这是模拟受限系统或使用复杂提议移动时的核心技能([@problem_id:2458841])。", "problem": "一个粒子被约束在三维欧几里得空间中半径为 $R$ 的球面上运动。该球面由球坐标 $(\\theta,\\phi)$ 参数化，其中 $\\theta \\in [0,\\pi]$ 是极角，$\\phi \\in [0,2\\pi)$ 是方位角。粒子的平衡（目标）分布相对于球面上的表面积测度是均匀的。通过向 $(\\theta,\\phi)$ 添加独立的零均值增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 来构造角度空间中的一个提议；然后通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta$ 以及将 $\\phi$ 模 $2\\pi$ 环绕，将受扰动的角度映射回规范范围。提议增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 服从具有指定标准差的高斯分布。所得到的马尔可夫链必须使均匀的表面积分布保持不变。当核在角坐标中指定时，$(\\theta,\\phi)$ 与表面积之间的变量变换会引入一个雅可比行列式，该行列式会影响表面上的提议密度。\n\n您的任务是：\n\n- 仅使用第一性原理，确定从角坐标 $(\\theta,\\phi)$ 到半径为 $R$ 的球面上的表面积元的变换的雅可比行列式 $J(R,\\theta)$。用 $R$ 和 $\\theta$ 表示您的结果。\n\n- 对于对称角扰动（角度空间中的前向和后向分布相同），从第一性原理确定接受率中纯粹由 $(\\theta,\\phi)$ 与表面积测度之间的提议密度变换产生的乘法因子，对于一个移动 $(\\theta,\\phi) \\to (\\theta',\\phi')$，用 $\\theta$ 和 $\\theta'$ 表示。\n\n- 使用上述角坐标提议，实现粒子在球面上的蒙特卡洛（MC）模拟。构建两个变体：\n  1. 一个在其接受决策中使用了您的雅可比行列式所蕴含的正确提议密度变换的变体，以使该链对于均匀表面积分布保持不变。\n  2. 一个在其接受决策中错误地忽略此变换的变体。\n\n- 对于每个变体，在该链的平稳分布下，使用固定种子以保证可复现性，估计可观测量 $f(\\theta,\\phi) = \\cos^2(\\theta)$ 的期望值。\n\n角度必须以弧度为单位。所有数值答案必须表示为不带单位的实数。\n\n测试套件和要求的输出：\n\n1. 在以下参数对处评估雅可比行列式 $J(R,\\theta)$：\n   - $(R,\\theta) = (1,\\pi/6)$,\n   - $(R,\\theta) = (2,\\pi/2)$,\n   - $(R,\\theta) = (3,\\pi)$.\n\n2. 对于对称角扰动，为以下 $(\\theta,\\theta')$ 对评估提议密度雅可比比率因子：\n   - $(\\theta,\\theta') = (\\pi/12,\\pi/3)$,\n   - $(\\theta,\\theta') = (\\pi/3,5\\pi/12)$.\n\n3. 运行一个总步数为 $N = 200000$、预烧期为 $B = 5000$、半径为 $R = 1$、起始角度为 $(\\theta_0,\\phi_0) = (1.234,2.345)$、高斯提议标准差为 $\\sigma_\\theta = 0.3$ 和 $\\sigma_\\phi = 0.6$ 的模拟。使用等于 $123$ 的固定种子。为 $\\mathbb{E}[\\cos^2(\\theta)]$ 生成两个估计值：\n   - 一个使用正确考虑了您的雅可比行列式所导致的提议密度变换的接受决策。\n   - 一个使用忽略了提议密度变换的接受决策。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n  - 来自第1项的三个雅可比值，按给定顺序。\n  - 来自第2项的两个提议密度雅可比比率因子，按给定顺序。\n  - 来自第3项的两个蒙特卡洛估计值，按给定顺序（首先是正确变体的估计值，然后是错误变体的估计值）。\n  例如，输出必须采用 $[\\text{J1},\\text{J2},\\text{J3},\\text{F1},\\text{F2},\\text{E_correct},\\text{E_wrong}]$ 的形式。", "solution": "所提出的问题是计算统计力学中一个定义明确且具有科学依据的练习，具体涉及将 Metropolis-Hastings 算法应用于非笛卡尔坐标系。对问题陈述的严格验证没有发现任何不一致、歧义或违反科学原理之处。因此，我将从第一性原理出发，给出一个完整的解决方案。\n\n解决方案分为三个部分，与问题陈述中概述的任务相对应。\n\n首先，我们确定从球坐标到球面上表面积元的变换的雅可比行列式。半径为 $R$ 的球面上的一个点，在笛卡尔坐标 $(x, y, z)$ 中使用球坐标 $(\\theta, \\phi)$ 参数化为：\n$$\n\\vec{r}(\\theta, \\phi) = (R \\sin\\theta \\cos\\phi, R \\sin\\theta \\sin\\phi, R \\cos\\theta)\n$$\n其中 $\\theta \\in [0, \\pi]$ 是极角，$\\phi \\in [0, 2\\pi)$ 是方位角。一个无穷小的表面积元 $dA$，由切向量 $\\frac{\\partial\\vec{r}}{\\partial\\theta}$ 和 $\\frac{\\partial\\vec{r}}{\\partial\\phi}$ 的叉积的模给出。\n\n偏导数是：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} = (R \\cos\\theta \\cos\\phi, R \\cos\\theta \\sin\\phi, -R \\sin\\theta)\n$$\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\phi} = (-R \\sin\\theta \\sin\\phi, R \\sin\\theta \\cos\\phi, 0)\n$$\n叉积是：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} = (R^2 \\sin^2\\theta \\cos\\phi, R^2 \\sin^2\\theta \\sin\\phi, R^2 \\sin\\theta \\cos\\theta)\n$$\n这个向量的模，即代表该变换的雅可比行列式，是：\n$$\nJ(R, \\theta) = \\left\\| \\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} \\right\\| = \\sqrt{(R^2 \\sin^2\\theta \\cos\\phi)^2 + (R^2 \\sin^2\\theta \\sin\\phi)^2 + (R^2 \\sin\\theta \\cos\\theta)^2}\n$$\n$$\nJ(R, \\theta) = \\sqrt{R^4 \\sin^4\\theta (\\cos^2\\phi + \\sin^2\\phi) + R^4 \\sin^2\\theta \\cos^2\\theta} = \\sqrt{R^4 \\sin^2\\theta (\\sin^2\\theta + \\cos^2\\theta)} = \\sqrt{R^4 \\sin^2\\theta}\n$$\n因为 $\\theta \\in [0, \\pi]$，所以 $\\sin\\theta \\ge 0$。因此，雅可比行列式为：\n$$\nJ(R, \\theta) = R^2 \\sin\\theta\n$$\n这个量将球面上的微分面积元 $dA$ 与角坐标中的微分增量联系起来：$dA = J(R, \\theta) d\\theta d\\phi = R^2 \\sin\\theta d\\theta d\\phi$。\n\n其次，我们确定由坐标变换引起的 Metropolis-Hastings 接受率中的因子。从状态 $s$ 移动到提议状态 $s'$ 的接受概率 $\\alpha$ 由下式给出：\n$$\n\\alpha(s \\to s') = \\min\\left(1, \\frac{\\pi(s')}{\\pi(s)} \\frac{g(s' \\to s)}{g(s \\to s')}\\right)\n$$\n这里，$\\pi(s)$ 是目标概率密度，而 $g(s \\to s')$ 是从 $s$ 到 $s'$ 的提议概率密度。状态 $s$ 和 $s'$ 是球面上的点。目标分布相对于表面积测度是均匀的，这意味着对于球面上所有的点 $s$，$\\pi(s) = \\text{constant}$。因此，目标密度的比率 $\\frac{\\pi(s')}{\\pi(s)} = 1$。\n\n提议是在角坐标 $(\\theta, \\phi)$ 中提出的，而不是直接在球面上。设 $g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$ 为角坐标空间中的提议密度。球面上相应的提议密度 $g(s \\to s')$ 必须相对于表面积测度 $dA$ 来定义。概率守恒要求 $g(s \\to s') dA' = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi')) d\\theta' d\\phi'$。使用 $dA' = J(\\theta') d\\theta' d\\phi'$，我们得到：\n$$\ng(s \\to s') = \\frac{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))}{J(\\theta')}\n$$\n类似地，对于逆向移动：\n$$\ng(s' \\to s) = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{J(\\theta)}\n$$\n因此，接受概率中的提议密度比为：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))} \\times \\frac{J(\\theta')}{J(\\theta)}\n$$\n问题陈述中指出角扰动是对称的，这意味着角度空间中的前向和后向提议具有相同的分布。这意味着 $g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi)) = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$。因此，该比率简化为雅可比行列式的比率：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{J(\\theta')}{J(\\theta)} = \\frac{R^2 \\sin\\theta'}{R^2 \\sin\\theta} = \\frac{\\sin\\theta'}{\\sin\\theta}\n$$\n这就是所需的乘法因子。正确的接受概率是 $\\alpha = \\min\\left(1, \\frac{\\sin\\theta'}{\\sin\\theta}\\right)$。\n\n第三，我们设计蒙特卡洛模拟。目标是估计球面上均匀分布的可观测量 $f(\\theta, \\phi) = \\cos^2(\\theta)$ 的期望值。理论期望值为：\n$$\n\\mathbb{E}[\\cos^2\\theta] = \\frac{\\int_0^{2\\pi} \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta d\\phi}{\\int_0^{2\\pi} \\int_0^\\pi \\sin\\theta \\,d\\theta d\\phi} = \\frac{2\\pi \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta}{4\\pi} = \\frac{1}{2}\\left[-\\frac{\\cos^3\\theta}{3}\\right]_0^\\pi = \\frac{1}{2}\\left(-\\frac{(-1)^3}{3} - \\left(-\\frac{1^3}{3}\\right)\\right) = \\frac{1}{3}\n$$\n模拟实现如下：\n1.  将 $k=0$ 时的状态 $(\\theta_k, \\phi_k)$ 初始化为 $(\\theta_0, \\phi_0)$。\n2.  对 $k = 0, \\dots, N-1$ 进行迭代：\n    a. 通过分别从高斯分布 $\\mathcal{N}(0, \\sigma_\\theta^2)$ 和 $\\mathcal{N}(0, \\sigma_\\phi^2)$ 中抽取独立增量 $\\Delta\\theta$ 和 $\\Delta\\phi$，提出新状态 $(\\theta_p, \\phi_p)$。\n    b. 应用边界条件。新的极角 $\\theta_p$ 是通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta_k + \\Delta\\theta$ 得到的。这是通过变换 $\\theta_p = \\text{mod}(\\theta_k+\\Delta\\theta, 2\\pi)$，然后在 $\\theta_p > \\pi$ 时令 $\\theta_p = 2\\pi - \\theta_p$ 来实现的。新的方位角 $\\phi_p$ 是通过将 $\\phi_k + \\Delta\\phi$ 模 $2\\pi$ 环绕得到的。\n    c. 计算接受概率 $\\alpha$。\n       - **正确变体**：$\\alpha = \\min\\left(1, \\frac{\\sin\\theta_p}{\\sin\\theta_k}\\right)$。\n       - **错误变体**：忽略雅可比因子。接受概率变为 $\\alpha = \\min(1, 1) = 1$，意味着所有移动都被接受。\n    d. 抽取一个随机数 $u \\sim U(0,1)$。如果 $u  \\alpha$，则设置 $(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_p, \\phi_p)$。否则，$(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_k, \\phi_k)$。\n3.  经过 $B$ 步的预烧期后，通过对其余 $N-B$ 步上的 $\\cos^2(\\theta_k)$ 进行平均来估计期望 $\\mathbb{E}[\\cos^2\\theta]$。\n\n错误变体采样的概率密度在 $(\\theta, \\phi)$ 空间中是均匀的，即 $p(\\theta, \\phi) \\propto 1$。在这个错误分布下的期望值为 $\\mathbb{E}_{incorrect}[\\cos^2\\theta] = \\frac{1}{2\\pi^2} \\int_0^{2\\pi} d\\phi \\int_0^\\pi \\cos^2\\theta \\,d\\theta = \\frac{1}{\\pi} \\int_0^\\pi \\frac{1+\\cos(2\\theta)}{2}d\\theta = \\frac{1}{2\\pi}[\\theta + \\frac{\\sin(2\\theta)}{2}]_0^\\pi = \\frac{1}{2}$。模拟结果应符合这些 $1/3$ 和 $1/2$ 的理论预测。实现将精确地遵循此设计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_mc_simulation(params, correct_jacobian, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation of a particle on a sphere.\n\n    Args:\n        params (tuple): A tuple containing simulation parameters:\n                        (N, B, R, theta0, phi0, sigma_theta, sigma_phi).\n        correct_jacobian (bool): If True, use the correct acceptance criterion.\n                                 If False, use the incorrect one.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated expectation value of cos^2(theta).\n    \"\"\"\n    N, B, R, theta0, phi0, sigma_theta, sigma_phi = params\n    \n    # Initialize a new random number generator for each independent run\n    rng = np.random.default_rng(seed)\n    \n    theta = theta0\n    phi = phi0\n    \n    observable_sum = 0.0\n    samples_collected = 0\n    \n    for step in range(N):\n        # Propose a move in angular coordinates\n        d_theta = rng.normal(0.0, sigma_theta)\n        d_phi = rng.normal(0.0, sigma_phi)\n        \n        theta_prop = theta + d_theta\n        phi_prop = phi + d_phi\n        \n        # Apply boundary conditions\n        # For theta: reflection at 0 and pi\n        # This maps the real line to [0, pi] via folding\n        theta_p = np.mod(theta_prop, 2.0 * np.pi)\n        if theta_p > np.pi:\n            theta_p = 2.0 * np.pi - theta_p\n            \n        # For phi: wrapping modulo 2*pi\n        phi_p = np.mod(phi_prop, 2.0 * np.pi)\n        \n        # Calculate acceptance probability\n        if correct_jacobian:\n            # The target distribution is uniform on the sphere, so pi(s')/pi(s) = 1.\n            # The acceptance probability is determined by the Jacobian factor.\n            sin_theta_k = np.sin(theta)\n            sin_theta_p = np.sin(theta_p)\n            \n            # To avoid division by zero if theta is at a pole (0 or pi).\n            if sin_theta_k  1e-12:\n                # If moving from a pole, the volume element is increasing from zero,\n                # so the move should always be accepted unless the proposed\n                # point is also a pole, in which case the ratio is 1.\n                acceptance_ratio = 1.0 if sin_theta_p  1e-12 else np.inf\n            else:\n                acceptance_ratio = sin_theta_p / sin_theta_k\n            \n            alpha = min(1.0, acceptance_ratio)\n        else:\n            # Incorrect variant: ignore the Jacobian factor.\n            # Since the target density is uniform, the acceptance probability is 1.\n            alpha = 1.0\n            \n        # Accept or reject the move\n        if rng.uniform(0.0, 1.0)  alpha:\n            theta = theta_p\n            phi = phi_p\n            \n        # Collect samples after the burn-in period\n        if step >= B:\n            observable_sum += np.cos(theta)**2\n            samples_collected += 1\n            \n    if samples_collected == 0:\n        return np.nan\n        \n    return observable_sum / samples_collected\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, calculate all required values,\n    and print the final output in the specified format.\n    \"\"\"\n    # ====== Task 1: Evaluate Jacobian determinant J(R, theta) ======\n    # J(R, theta) = R^2 * sin(theta)\n    \n    # Test case 1: (R, theta) = (1, pi/6)\n    R1, theta1 = 1.0, np.pi/6.0\n    J1 = R1**2 * np.sin(theta1)\n    \n    # Test case 2: (R, theta) = (2, pi/2)\n    R2, theta2 = 2.0, np.pi/2.0\n    J2 = R2**2 * np.sin(theta2)\n    \n    # Test case 3: (R, theta) = (3, pi)\n    R3, theta3 = 3.0, np.pi\n    J3 = R3**2 * np.sin(theta3)\n    \n    # ====== Task 2: Evaluate proposal-density Jacobian ratio factor ======\n    # Factor = sin(theta') / sin(theta)\n    \n    # Test case 1: (theta, theta') = (pi/12, pi/3)\n    theta_a1, theta_a2 = np.pi/12.0, np.pi/3.0\n    F1 = np.sin(theta_a2) / np.sin(theta_a1)\n\n    # Test case 2: (theta, theta') = (pi/3, 5*pi/12)\n    theta_b1, theta_b2 = np.pi/3.0, 5.0*np.pi/12.0\n    F2 = np.sin(theta_b2) / np.sin(theta_b1)\n    \n    # ====== Task 3: Run Monte Carlo simulations ======\n    sim_params = (\n        200000,  # N: total steps\n        5000,    # B: burn-in steps\n        1.0,     # R: radius\n        1.234,   # theta0\n        2.345,   # phi0\n        0.3,     # sigma_theta\n        0.6      # sigma_phi\n    )\n    seed = 123\n    \n    # Run simulation with correct Jacobian factor\n    E_correct = run_mc_simulation(sim_params, correct_jacobian=True, seed=seed)\n    \n    # Run simulation with incorrect (ignored) Jacobian factor\n    E_wrong = run_mc_simulation(sim_params, correct_jacobian=False, seed=seed)\n\n    # Collate results\n    results = [J1, J2, J3, F1, F2, E_correct, E_wrong]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2458841"}, {"introduction": "蒙特卡洛方法不仅能用于对平衡构型进行抽样，也是模拟系统时间演化的强大工具。本练习通过模拟一个简单的异构化反应，向你介绍动力学蒙特卡洛（kMC）方法。你将实现一个事件驱动的算法来模拟反应动力学过程，分析等待时间分布，并将模拟结果与化学主方程的理论预测联系起来([@problem_id:2653266])。", "problem": "您需要为一个物理化学中的连续时间双态异构化模型实现一个动力学蒙特卡洛模拟，该模型代表单分子反应 $A \\rightleftharpoons B$。该系统被建模为一个连续时间马尔可夫链，具有恒定的转移速率 $k_{AB}$（从 $A$ 到 $B$）和 $k_{BA}$（从 $B$ 到 $A$），其中 $k_{AB}$ 和 $k_{BA}$ 的单位为 $\\mathrm{s}^{-1}$。本问题的基本依据是化学主方程以及控制具有恒定风险率的无记忆转移的齐次泊松过程的定义。目标是通过模拟从第一性原理计算离开每个状态的等待时间分布和稳态布居，并将它们与主方程所蕴含的稳态解进行比较。所有时间量必须以秒为单位表示。\n\n任务规范：\n- 实现一个动力学蒙特卡洛算法（也称为直接法），从一个初始状态开始，顺序生成反应事件：\n  - 在每个事件中，当系统处于某个状态时，它会等待一个随机时间，然后转移到另一个状态。风险率是恒定的，由当前状态的出射反应速率决定。\n  - 该算法必须分别记录离开 $A$ 和离开 $B$ 的等待时间样本，并且必须累积在每个状态中花费的总时间。\n- 对于每组参数，计算以下量：\n  1. 离开 $A$ 的经验平均等待时间（秒），根据系统在转移前处于 $A$ 状态时获得的等待时间样本计算。\n  2. 离开 $B$ 的经验平均等待时间（秒），对状态 $B$ 进行类似计算。\n  3. 离开状态 $A$ 的等待时间的经验累积分布函数与状态 $A$ 中恒定风险率所蕴含的理论累积分布函数之间的柯尔莫哥洛夫距离。柯尔莫哥洛夫距离是两个累积分布函数在所有非负时间上的上确界范数。\n  4. 离开状态 $B$ 的等待时间的经验累积分布函数与状态 $B$ 中恒定风险率所蕴含的理论累积分布函数之间的柯尔莫哥洛夫距离。\n  5. $A$ 的经验稳态布居，计算为在总模拟时间中所占的长时比例。\n  6. $A$ 的经验稳态布居与该双态系统的化学主方程稳态解给出的稳态布居之间的绝对误差。不要将其表示为百分比；它必须是区间 $[0,1]$ 内的一个数字。\n- 您的程序必须对每个测试用例使用固定数量的反应事件（跳跃），为保证可复现性，每个测试用例必须使用固定的伪随机种子，并且必须按照下面指定的顺序报告结果。所有时间输出必须以秒为单位。\n\n测试套件：\n- 使用以下三个测试用例。每个测试用例由 $(k_{AB}, k_{BA}, N, \\text{初始状态}, \\text{种子})$ 指定，其中 $N$ 是反应事件（跳跃）的数量：\n  - 情况1（平衡速率）：$(k_{AB} = 10.0\\ \\mathrm{s}^{-1},\\ k_{BA} = 10.0\\ \\mathrm{s}^{-1},\\ N = 100000,\\ \\text{初始状态} = A,\\ \\text{种子} = 12345)$。\n  - 情况2（中度不对称）：$(k_{AB} = 1.0\\ \\mathrm{s}^{-1},\\ k_{BA} = 9.0\\ \\mathrm{s}^{-1},\\ N = 120000,\\ \\text{初始状态} = B,\\ \\text{种子} = 24680)$。\n  - 情况3（强度不对称）：$(k_{AB} = 0.1\\ \\mathrm{s}^{-1},\\ k_{BA} = 50.0\\ \\mathrm{s}^{-1},\\ N = 150000,\\ \\text{初始状态} = A,\\ \\text{种子} = 13579)$。\n\n实现和数值细节：\n- 利用每个状态中具有恒定风险率的齐次泊松过程的定义来抽样跳跃之间的等待时间。\n- 用于计算绝对误差的稳态布居是与这些速率相对应的双态化学主方程的唯一稳态解。\n- 对于柯尔莫哥洛夫距离的计算，使用每个状态中恒定风险率所蕴含的精确累积分布函数和从样本中获得的经验累积分布函数。考虑到经验累积分布函数的阶梯性质，可以通过在一组样本点上计算来求得上确界。\n- 所有时间量必须以秒为单位报告。\n- 所有输出必须是浮点数。将每个报告的浮点数四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 对于每种情况，按以下顺序输出六个量：\n  1. 离开 $A$ 的经验平均等待时间（秒）。\n  2. 离开 $B$ 的经验平均等待时间（秒）。\n  3. 离开 $A$ 的柯尔莫哥洛夫距离。\n  4. 离开 $B$ 的柯尔莫哥洛夫距离。\n  5. 在 $A$ 中时间的经验稳态分数。\n  6. 在 $A$ 中时间的经验分数与稳态解分数之间的绝对误差。\n- 将三种情况的结果按情况1、情况2、情况3的顺序连接成一个单一的扁平列表。例如，输出应具有 $[x_1, x_2, \\dots, x_{18}]$ 的形式，其中每个 $x_i$ 是一个四舍五入到六位小数的浮点数。", "solution": "我们将双态异构化反应 $A \\rightleftharpoons B$ 建模为一个连续时间马尔可夫链，其从 $A$ 到 $B$ 的转移速率为常数 $k_{AB}$，从 $B$ 到 $A$ 的转移速率为常数 $k_{BA}$，单位均为 $\\mathrm{s}^{-1}$。基本原理是状态概率的化学主方程以及通过齐次泊松过程对等待时间的表征。\n\n1. 化学主方程与稳态解。令 $p_A(t)$ 和 $p_B(t)$ 分别表示在时间 $t$ 处于状态 $A$ 和 $B$ 的概率。主方程为\n$$\n\\frac{d}{dt} \\begin{bmatrix} p_A(t) \\\\ p_B(t) \\end{bmatrix} =\n\\begin{bmatrix}\n- k_{AB}  k_{BA} \\\\\nk_{AB}  -k_{BA}\n\\end{bmatrix}\n\\begin{bmatrix} p_A(t) \\\\ p_B(t) \\end{bmatrix}.\n$$\n在稳态时，$dp_A/dt = dp_B/dt = 0$ 且 $p_A^\\ast + p_B^\\ast = 1$。求解得到唯一的稳态分布\n$$\np_A^\\ast = \\frac{k_{BA}}{k_{AB} + k_{BA}}, \\qquad p_B^\\ast = \\frac{k_{AB}}{k_{AB} + k_{BA}}.\n$$\n根据遍历性，对于具有正速率的不可约双态链，该稳态解是时间平均的长时极限。\n\n2. 恒定风险率下的等待时间分布。当系统处于状态 $A$ 时，离开 $A$ 的时间由一个齐次泊松过程控制，其风险率等于出射反应速率 $k_{AB}$。离开 $A$ 的等待时间 $\\tau_A$ 的生存函数为\n$$\n\\Pr(\\tau_A  t) = \\exp(-k_{AB} t), \\quad t \\ge 0,\n$$\n因此累积分布函数为\n$$\nF_A(t) = 1 - \\exp(-k_{AB} t), \\quad t \\ge 0.\n$$\n类似地，对于状态 $B$，其出射速率为 $k_{BA}$，等待时间 $\\tau_B$ 的分布为\n$$\nF_B(t) = 1 - \\exp(-k_{BA} t), \\quad t \\ge 0.\n$$\n因此，在给定状态下，离开每个状态的等待时间是独立同分布的指数随机变量。\n\n3. 动力学蒙特卡洛（Gillespie直接法）。从一个初始状态开始，算法逐个事件地迭代。如果当前状态是 $A$，抽取一个均匀随机变量 $U \\sim \\mathcal{U}(0,1)$，并将其转换为一个指数等待时间 $\\tau = -\\ln U / k_{AB}$，将此 $\\tau$ 添加到 $A$-离开等待时间样本中，并将此时间累积到在 $A$ 中花费的总时间。然后将状态切换到 $B$。如果当前状态是 $B$，则使用速率 $k_{BA}$ 执行相同的操作，并将时间累积到在 $B$ 中花费的总时间，然后切换到 $A$。对固定数量 $N$ 的反应事件重复此过程。这将产生：\n- 在离开 $A$ 之前观察到的等待时间列表，记为 $\\{\\tau_{A,i}\\}_{i=1}^{n_A}$。\n- 在离开 $B$ 之前观察到的等待时间列表，记为 $\\{\\tau_{B,j}\\}_{j=1}^{n_B}$。\n- 在 $A$ 中花费的总时间 $T_A = \\sum_{i=1}^{n_A} \\tau_{A,i}$，以及在 $B$ 中花费的总时间 $T_B = \\sum_{j=1}^{n_B} \\tau_{B,j}$。\n\n因为该过程是时间齐次的、不可约的（$k_{AB}  0$ 且 $k_{BA}  0$），所以它是遍历的；因此，时间平均分数几乎必然收敛到稳态分布：\n$$\n\\hat{p}_A = \\frac{T_A}{T_A + T_B} \\xrightarrow[N \\to \\infty]{} p_A^\\ast.\n$$\n\n4. 估计量与比较。\n- 等待时间分布：经验平均等待时间为 $\\bar{\\tau}_A = \\frac{1}{n_A} \\sum_{i=1}^{n_A} \\tau_{A,i}$ 和 $\\bar{\\tau}_B = \\frac{1}{n_B} \\sum_{j=1}^{n_B} \\tau_{B,j}$，均以秒为单位报告。对于指数分布，速率的最大似然估计量是 $\\hat{\\lambda} = 1/\\bar{\\tau}$，但这里我们按要求直接报告经验平均值。\n- 柯尔莫哥洛夫距离：设 $F_{n,A}(t)$ 是 $\\{\\tau_{A,i}\\}$ 的经验累积分布函数，$F_A(t)$ 是与 $A$ 中恒定风险率相关的理论累积分布函数。柯尔莫哥洛夫距离是\n$$\nD_A = \\sup_{t \\ge 0} \\left| F_{n,A}(t) - F_A(t) \\right|.\n$$\n在实现上，如果我们对样本进行排序 $\\tau_{A,(1)} \\le \\cdots \\le \\tau_{A,(n_A)}$，则经验累积分布函数是在这些样本点处跳跃大小为 $1/n_A$ 的右连续阶梯函数。上确界可以通过使用著名的单样本柯尔莫哥洛夫–斯米尔诺夫统计量，在样本点网格上取最大值来计算：\n$$\nD_A = \\max_{1 \\le i \\le n_A} \\max\\left\\{ \\left|F_A(\\tau_{A,(i)}) - \\frac{i}{n_A} \\right|,\\ \\left|F_A(\\tau_{A,(i)}) - \\frac{i-1}{n_A} \\right| \\right\\}.\n$$\n对状态 $B$ 进行类似的计算可得到 $D_B$。\n- 稳态布居：在 $A$ 中时间的经验稳态分数为 $\\hat{p}_A = T_A/(T_A+T_B)$，我们将其与稳态解 $p_A^\\ast$ 进行比较，以计算绝对误差 $|\\hat{p}_A - p_A^\\ast|$。\n\n5. 数值设计与测试覆盖。我们为每个测试用例模拟固定数量 $N$ 的跳跃，并使用固定的伪随机种子以确保可复现性。测试套件包括：\n- 平衡速率 $k_{AB} = k_{BA}$，此时 $p_A^\\ast = 1/2$，且两种等待时间分布相同。\n- 中度不对称速率，此时 $A$ 的占据率较高，但两个状态都频繁访问。\n- 强度不对称速率，此时从 $A$ 离开的事件稀少，而从 $B$ 离开的事件非常快，这对长时和短时抽样都构成了考验。\n\n6. 输出。对于每种情况，我们按顺序报告六个浮点数：$\\bar{\\tau}_A$（秒）、$\\bar{\\tau}_B$（秒）、$D_A$、$D_B$、$\\hat{p}_A$、 $|\\hat{p}_A - p_A^\\ast|$，每个都四舍五入到六位小数。将三种情况的结果连接成一个单一的扁平列表 $[x_1, x_2, \\dots, x_{18}]$，并将其作为唯一的一行输出。\n\n根据中心极限定理，蒙特卡洛统计误差的尺度近似为 $N^{-1/2}$，因此增加 $N$ 会减少 $\\bar{\\tau}_A$、$\\bar{\\tau}_B$ 和 $\\hat{p}_A$ 的变异性，并且平均而言也会使柯尔莫哥洛夫距离更小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ks_distance_exponential(samples: np.ndarray, rate: float) - float:\n    \"\"\"\n    Compute the Kolmogorov distance between the empirical CDF of samples and the\n    exponential CDF with given rate. Returns np.nan if no samples.\n    \"\"\"\n    n = samples.size\n    if n == 0:\n        return float('nan')\n    # Sort samples\n    x = np.sort(samples)\n    # Theoretical CDF at sample points: F(t) = 1 - exp(-rate * t)\n    Fx = 1.0 - np.exp(-rate * x)\n    # Empirical CDF brackets at each sample: (i-1)/n and i/n\n    i = np.arange(1, n + 1, dtype=np.float64)\n    ecdf_upper = i / n\n    ecdf_lower = (i - 1.0) / n\n    # Compute the KS one-sample statistic (sup over t = 0)\n    d_upper = np.abs(Fx - ecdf_upper)\n    d_lower = np.abs(Fx - ecdf_lower)\n    D = max(np.max(d_upper), np.max(d_lower))\n    return float(D)\n\ndef simulate_two_state_kmc(k_ab: float, k_ba: float, n_jumps: int, init_state: str, seed: int):\n    \"\"\"\n    Simulate a two-state kinetic Monte Carlo for A - B with rates k_ab and k_ba.\n    Returns:\n        mean_tau_A, mean_tau_B, ks_A, ks_B, pi_A_sim, abs_err_pi_A\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Map state: 0 - A, 1 - B\n    state = 0 if init_state.upper() == 'A' else 1\n\n    # Collect waiting times and accumulated times\n    tau_A = []\n    tau_B = []\n    time_A = 0.0\n    time_B = 0.0\n\n    # Predefine rates per state\n    rates = (float(k_ab), float(k_ba))\n\n    # Main KMC loop\n    for _ in range(n_jumps):\n        r = rates[state]\n        # Draw exponential waiting time via inverse transform: tau = -ln(U)/r\n        u = rng.random()\n        # Ensure u in (0,1], avoid log(0)\n        while u == 0.0:\n            u = rng.random()\n        tau = -np.log(u) / r\n        if state == 0:\n            tau_A.append(tau)\n            time_A += tau\n            state = 1  # switch to B\n        else:\n            tau_B.append(tau)\n            time_B += tau\n            state = 0  # switch to A\n\n    tau_A = np.array(tau_A, dtype=np.float64)\n    tau_B = np.array(tau_B, dtype=np.float64)\n\n    mean_tau_A = float(np.mean(tau_A)) if tau_A.size  0 else float('nan')\n    mean_tau_B = float(np.mean(tau_B)) if tau_B.size  0 else float('nan')\n\n    # Kolmogorov distances with theoretical exponential CDFs parameterized by given rates\n    ks_A = ks_distance_exponential(tau_A, k_ab) if tau_A.size  0 else float('nan')\n    ks_B = ks_distance_exponential(tau_B, k_ba) if tau_B.size  0 else float('nan')\n\n    total_time = time_A + time_B\n    pi_A_sim = float(time_A / total_time) if total_time  0 else float('nan')\n\n    # Theoretical stationary fraction in A from stationary solution of the two-state master equation\n    pi_A_th = float(k_ba / (k_ab + k_ba))\n    abs_err_pi_A = abs(pi_A_sim - pi_A_th) if np.isfinite(pi_A_sim) else float('nan')\n\n    return mean_tau_A, mean_tau_B, ks_A, ks_B, pi_A_sim, abs_err_pi_A\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (k_ab [s^-1], k_ba [s^-1], N_jumps, init_state, seed)\n    test_cases = [\n        (10.0, 10.0, 100_000, 'A', 12345),   # Case 1: balanced\n        (1.0, 9.0, 120_000, 'B', 24680),     # Case 2: moderately asymmetric\n        (0.1, 50.0, 150_000, 'A', 13579),    # Case 3: strongly asymmetric\n    ]\n\n    results = []\n    for k_ab, k_ba, n_jumps, init_state, seed in test_cases:\n        mean_tau_A, mean_tau_B, ks_A, ks_B, pi_A_sim, abs_err_pi_A = simulate_two_state_kmc(\n            k_ab, k_ba, n_jumps, init_state, seed\n        )\n        results.extend([\n            mean_tau_A, mean_tau_B, ks_A, ks_B, pi_A_sim, abs_err_pi_A\n        ])\n\n    # Round each float to six decimals and format as required.\n    formatted = [f\"{x:.6f}\" if np.isfinite(x) else \"nan\" for x in results]\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2653266"}]}