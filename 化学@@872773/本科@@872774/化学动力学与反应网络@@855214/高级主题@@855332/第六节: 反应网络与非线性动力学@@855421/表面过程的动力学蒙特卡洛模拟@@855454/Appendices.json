{"hands_on_practices": [{"introduction": "在模拟动态过程之前，我们必须首先精确定义系统中可能发生的“事件”。本练习将带你了解晶格 kMC 的一个关键前提：如何确定一个受空间限制的事件的发生概率。通过这个关于大分子在有缺陷表面上吸附的假设场景，你将探索分子的几何形状和表面的当前状态如何共同决定一个过程（如此处的吸附）能否成功发生。[@problem_id:1493212]", "problem": "在一个用于将大有机分子沉积到衬底上的简化模型中（这对于像有机发光二极管（OLEDs）这样的技术至关重要），衬底被表示为一个无限大的二维方形吸附位点晶格。在沉积有机分子之前，表面上预先存在分数覆盖率为 $\\theta$ 的惰性点缺陷。这些缺陷占据单个晶格位点，并在表面上随机且独立地分布。\n\n有机分子呈方形，需要一个由四个连续空位点组成的 $2 \\times 2$ 区域才能成功进行化学吸附。一次吸附尝试通过以下随机过程进行建模：\n1. 从所有可用位点中均匀随机地选择一个晶格位点，作为潜在的锚定点。\n2. 这个锚定点通常被定义为分子将占据的 $2 \\times 2$ 区域的左下角。\n3. 如果这个 $2 \\times 2$ 区域完全没有缺陷，则吸附事件成功。否则，尝试失败。\n\n给定缺陷覆盖率 $\\theta$，确定单次随机引发的吸附尝试成功的概率 $P_{success}$。请用含 $\\theta$ 的符号表达式表示你的答案。", "solution": "表面被建模为一个具有独立点缺陷的无限二维方形晶格。缺陷覆盖率为 $\\theta$ 意味着每个晶格位点有缺陷的概率为 $\\theta$，为空的概率为 $1-\\theta$，且与其他所有位点的情况相互独立。\n\n一次吸附尝试在无限晶格上均匀随机地选择一个锚定位点。根据平移不变性，成功的概率不依赖于所选择的具体锚定位点。与锚点关联的 $2\\times 2$ 区域包含四个不同的晶格位点。当且仅当这个 $2\\times 2$ 区域中的所有四个位点都为空时，吸附才会成功。\n\n设 $V_{i}$ 为 $2\\times 2$ 区域中位点 $i$ 为空的事件。那么对于每个 $i$，有 $\\mathbb{P}(V_{i})=1-\\theta$。又因为各点缺陷是相互独立的，所以事件 $\\{V_{i}\\}_{i=1}^{4}$ 也是相互独立的。因此，成功的概率是各个位点为空的概率的乘积：\n$$\nP_{\\text{success}}=\\mathbb{P}\\left(\\bigcap_{i=1}^{4} V_{i}\\right)=\\prod_{i=1}^{4}\\mathbb{P}(V_{i})=(1-\\theta)^{4}.\n$$\n由于晶格是无限的，此结果无需进行边界校正。", "answer": "$$\\boxed{(1-\\theta)^{4}}$$", "id": "1493212"}, {"introduction": "在定义了事件之后，我们现在将这些事件置于动态的时间演化中。本练习将指导你手动完成 kMC 算法（特别是 Gillespie 算法）的核心步骤。通过使用一组给定的随机数，你将亲自计算反应速率、推进模拟时间并随机选择下一个发生的事件，从而深入理解模拟时钟和系统状态是如何随机演变的。[@problem_id:1493167]", "problem": "一个催化表面反应在一个具有周期性边界条件的二维3x3方格晶格上进行建模。晶格上的位点由坐标(i, j)索引，其中i, j可以取0, 1或2。在此表面上可能发生两种基本过程：\n\n1.  **反应**：在位点$s$上的一个物种A的吸附分子，记为A(ad)，与最近邻位点$s'$上的一个物种B的吸附分子，记为B(ad)，发生反应。该反应在位点$s$上形成一个物种C的吸附分子C(ad)，并使位点$s'$变为空。对于任何特定的A(ad)-B(ad)对，该反应的速率是一个常数，$k_R$。\n2.  **脱附**：在位点$s$上的一个吸附分子C(ad)脱附到气相中，使位点$s$变为空。此过程的速率取决于局部环境，由$k_C(n) = k_C^0 \\exp(-\\alpha n)$给出，其中$n$是位点$s$的最近邻位点中被任何物种（A、B或C）占据的数量。\n\n该系统的模拟通过一个随机算法进行。在每一步中：\na.  通过对系统中当前构型下所有可能事件的速率求和，计算出总速率$R_{tot}$。\nb.  模拟时间增加一个增量$\\Delta t = -\\frac{\\ln(u_1)}{R_{tot}}$，其中$u_1$是从区间(0, 1]上的均匀分布中抽取的一个随机数。\nc.  选择一个具有单独速率$r_i$的单一事件$i$发生。该事件以概率$P_i = r_i / R_{tot}$被选择，具体实现方式是找到满足 $\\sum_{j=1}^{i-1} r_j  u_2 R_{tot} \\leq \\sum_{j=1}^{i} r_j$ 的事件索引 $i$，其中$u_2$是从区间(0, 1]上的均匀分布中抽取的第二个随机数。\n\n最初，在时间$t=0$时，晶格的构型如下：\n-   一个A(ad)分子位于位点(1,1)。\n-   一个B(ad)分子位于位点(1,2)。\n-   一个B(ad)分子位于位点(2,1)。\n-   所有其他6个位点均为空。\n\n模拟的参数为：\n-   $k_R = 0.50 \\text{ s}^{-1}$\n-   $k_C^0 = 1.2 \\text{ s}^{-1}$\n-   $\\alpha = 0.25$\n\n给定以下随机数序列以驱动模拟：\n-   第一步：一对随机数$(u_{1,1}, u_{2,1}) = (0.60, 0.40)$。\n-   第二步：一对随机数$(u_{1,2}, u_{2,2}) = (0.80, 0.70)$。\n\n计算第一个C分子从表面脱附时所经过的总时间。答案以秒为单位表示，并四舍五入到三位有效数字。", "solution": "晶格是一个$3 \\times 3$的方格，具有周期性边界，最近邻位于四个基本方向上。\n\n**第1步：初始状态**\n在 $t=0$ 时，A(ad)位于(1,1)，B(ad)分子位于(1,2)和(2,1)。位于(1,1)的A有四个邻近位点：(0,1), (2,1), (1,0)和(1,2)。其中，(1,2)和(2,1)被B占据，因此存在两个不同的A-B最近邻对。每个这样的对都可以发生反应，速率为 $k_{R}$。\n-   事件1：A(1,1) 与 B(1,2) 反应，速率 $r_1 = k_R = 0.50 \\text{ s}^{-1}$。\n-   事件2：A(1,1) 与 B(2,1) 反应，速率 $r_2 = k_R = 0.50 \\text{ s}^{-1}$。\n\n总速率为：\n$$\nR_{\\text{tot},1} = r_1 + r_2 = 2 k_{R} = 2 \\times 0.50 = 1.00 \\text{ s}^{-1}\n$$\n使用第一个随机数对 $(u_{1,1}, u_{2,1}) = (0.60, 0.40)$。\n时间增量为：\n$$\n\\Delta t_1 = -\\frac{\\ln(u_{1,1})}{R_{\\text{tot},1}} = -\\frac{\\ln(0.60)}{1.00} \\approx 0.5108 \\text{ s}\n$$\n选择事件：计算阈值 $u_{2,1} R_{\\text{tot},1} = 0.40 \\times 1.00 = 0.40$。\n-   累积速率 $S_1 = r_1 = 0.50$。\n-   由于 $0  0.40 \\le S_1$，事件1被选中。\n\n状态更新：A(1,1)与B(1,2)反应，在(1,1)处生成C，(1,2)变为空位。\n新构型为：C(ad)在(1,1)，B(ad)在(2,1)。模拟时间 $t_1 = \\Delta t_1 \\approx 0.5108 \\text{ s}$。\n\n**第2步：新状态**\n现在表面上有一个C分子和一个B分子。可能的事件只有一个：C(ad)在(1,1)处脱附。\nC(1,1)的最近邻是(0,1), (2,1), (1,0), (1,2)。其中只有(2,1)被占据。所以邻居数 $n=1$。\n脱附速率为：\n$$\nr_1 = k_C(n=1) = k_C^0 \\exp(-\\alpha n) = 1.2 \\exp(-0.25 \\times 1) \\approx 0.9345 \\text{ s}^{-1}\n$$\n总速率为 $R_{\\text{tot},2} = r_1 \\approx 0.9345 \\text{ s}^{-1}$。\n使用第二个随机数对 $(u_{1,2}, u_{2,2}) = (0.80, 0.70)$。\n时间增量为：\n$$\n\\Delta t_2 = -\\frac{\\ln(u_{1,2})}{R_{\\text{tot},2}} = -\\frac{\\ln(0.80)}{0.9345} \\approx \\frac{0.2231}{0.9345} \\approx 0.2388 \\text{ s}\n$$\n由于只有一个可能的事件，它被自动选中：C分子脱附。\n\n**总时间**\n第一个C分子脱附时的总时间是两次时间增量之和：\n$$\nt_{\\text{total}} = \\Delta t_1 + \\Delta t_2 \\approx 0.5108 + 0.2388 = 0.7496 \\text{ s}\n$$\n四舍五入到三位有效数字，结果为 $0.750 \\text{ s}$。", "answer": "$$\\boxed{0.750}$$", "id": "1493167"}, {"introduction": "从手动计算到利用计算能力，这最后一个实践练习将挑战你编写一个完整的 kMC 模拟程序，用于模拟一个催化反应网络。这个练习不仅能巩固你对整个算法的理解，还将展示 kMC 如何被用作一个强大的工具，来研究复杂系统中表面物种覆盖度和产物生成量随时间的演化。[@problem_id:2458845]", "problem": "一个反应性表面被建模为不可区分的吸附位点的有限集合。该表面与两种气相物种相互作用，并可通过双分子表面反应产生一种气相产物。系统在时间 $t$ 的状态由整数计数 $\\left(n_{AS}(t), n_{BS}(t), n_{S}(t), n_{C}(t)\\right)$ 定义，其中 $n_{AS}$ 是被吸附物种 $A$ 占据的位点数，$n_{BS}$ 是被吸附物种 $B$ 占据的位点数，$n_{S}$ 是空位点数，$n_{C}$ 是已形成的气相产物分子的累积数量，并存在不变量 $n_{AS}(t) + n_{BS}(t) + n_{S}(t) = N_S$。系统在 $t = 0$ 时初始化，状态为 $n_{AS}(0) = 0$, $n_{BS}(0) = 0$, $n_{S}(0) = N_S$ 及 $n_{C}(0) = 0$。时间单位为秒。以下所有速率单位均为秒的倒数，具体含义如下。\n\n在充分混合位点近似下，基元事件及其倾向定义如下：\n- $A$ 的吸附：$A + S \\rightarrow AS$，倾向为 $a_1(t) = k_{\\text{ads},A}\\,n_{S}(t)$，其中 $k_{\\text{ads},A}$ 的单位是 $\\text{s}^{-1}$ 每空位点。\n- $A$ 的解吸：$AS \\rightarrow A + S$，倾向为 $a_2(t) = k_{\\text{des},A}\\,n_{AS}(t)$，其中 $k_{\\text{des},A}$ 的单位是 $\\text{s}^{-1}$ 每吸附的 $A$。\n- $B$ 的吸附：$B + S \\rightarrow BS$，倾向为 $a_3(t) = k_{\\text{ads},B}\\,n_{S}(t)$，其中 $k_{\\text{ads},B}$ 的单位是 $\\text{s}^{-1}$ 每空位点。\n- $B$ 的解吸：$BS \\rightarrow B + S$，倾向为 $a_4(t) = k_{\\text{des},B}\\,n_{BS}(t)$，其中 $k_{\\text{des},B}$ 的单位是 $\\text{s}^{-1}$ 每吸附的 $B$。\n- 表面反应：$AS + BS \\rightarrow C + 2S$，倾向为 $a_5(t) = k_{\\text{rxn}}\\,n_{AS}(t)\\,n_{BS}(t)$，其中 $k_{\\text{rxn}}$ 的单位是 $\\text{s}^{-1}$ 每有序对 $\\left(AS,BS\\right)$。该反应将计数更新为 $n_{AS} \\mapsto n_{AS} - 1$、$n_{BS} \\mapsto n_{BS} - 1$、$n_{S} \\mapsto n_{S} + 2$、$n_{C} \\mapsto n_{C} + 1$。\n\n将动力学视为一个由上述倾向控制的连续时间、离散状态的马尔可夫过程。对于每个指定的参数集，从初始状态开始生成该过程的单条随机轨迹，演化直到结束时间 $T_{\\text{end}}$（以秒为单位）或直到没有更多事件可能发生为止，以先到者为准。为使结果可复现，每种情况均使用指定种子初始化的伪随机数生成器。对于每种情况，报告最终值 $n_{C}(T_{\\text{end}})$，该值为一个非负整数。\n\n所有模拟必须遵守以下条件：\n- 表面位点数为 $N_S$（一个整数）。\n- 结束时间为 $T_{\\text{end}}$（以秒为单位）。\n- 速率 $k_{\\text{ads},A}$、$k_{\\text{des},A}$、$k_{\\text{ads},B}$、$k_{\\text{des},B}$ 和 $k_{\\text{rxn}}$ 是非负实数，单位如上所示。\n- 在模拟每种情况之前，必须使用给定的整数种子初始化随机数生成器。\n\n参数集测试套件 $\\left(N_S, T_{\\text{end}}, k_{\\text{ads},A}, k_{\\text{des},A}, k_{\\text{ads},B}, k_{\\text{des},B}, k_{\\text{rxn}}, \\text{seed}\\right)$:\n- 情况 $1$：$\\left(50, 2.0, 4.0, 1.0, 5.0, 1.5, 0.10, 12345\\right)$。\n- 情况 $2$：$\\left(100, 1.0, 0.0, 1.0, 3.0, 1.0, 1.00, 67890\\right)$。\n- 情况 $3$：$\\left(60, 3.0, 3.0, 0.5, 3.0, 0.5, 0.00, 13579\\right)$。\n- 情况 $4$：$\\left(0, 10.0, 2.0, 0.2, 2.0, 0.2, 0.50, 24680\\right)$。\n- 情况 $5$：$\\left(40, 5.0, 2.0, 0.2, 2.5, 0.2, 0.50, 424242\\right)$。\n\n您的程序必须计算上述五种情况的最终整数结果 $n_{C}(T_{\\text{end}})$，并生成一行输出，其中包含一个用方括号括起来的、无空格的逗号分隔列表，按情况 $1$到 $5$ 的顺序排列结果，例如 $\\left[\\;x_1,x_2,x_3,x_4,x_5\\;\\right]$，其中每个 $x_i$ 是对应的整数 $n_C(T_{\\text{end}})$。", "solution": "所述问题经过严格验证，被认定是有效的。这是一个计算化学领域中定义明确的问题，具体要求模拟表面上的随机化学反应网络。该模型基于化学动力学和统计力学的既定原理，并且提供了获得唯一、可复现解所需的所有参数和条件。该模型是连续时间、离散状态马尔可夫过程的一个实例，其标准且正确的解决方法是 Gillespie 随机模拟算法 (SSA)。\n\n我们现在将进行形式推导和算法规范。\n\n系统在任意时间 $t$ 的状态由整数布居数向量 $\\vec{n}(t) = (n_{AS}(t), n_{BS}(t), n_{S}(t), n_{C}(t))$ 描述。这些分量分别代表被物种 $A$ 占据的位点数、被物种 $B$ 占据的位点数、空位点数以及产物分子 $C$ 的累积计数。总位点数 $N_S$ 是恒定的，从而得到不变量 $n_{AS}(t) + n_{BS}(t) + n_{S}(t) = N_S$。\n\n系统通过五个可能的基元反应通道演化，$\\mu \\in \\{1, 2, 3, 4, 5\\}$:\n1.  $A$ 的吸附：$A + S \\xrightarrow{k_{\\text{ads},A}} AS$\n2.  $A$ 的解吸：$AS \\xrightarrow{k_{\\text{des},A}} A + S$\n3.  $B$ 的吸附：$B + S \\xrightarrow{k_{\\text{ads},B}} BS$\n4.  $B$ 的解吸：$BS \\xrightarrow{k_{\\text{des},B}} B + S$\n5.  表面反应：$AS + BS \\xrightarrow{k_{\\text{rxn}}} C + 2S$\n\n对于每个反应通道 $\\mu$，都有一个对应的状态改变向量 $\\vec{\\nu}_\\mu$，它定义了当该反应发生时状态向量 $\\vec{n}$ 的变化。这些向量是：\n-   $\\vec{\\nu}_1 = (+1, 0, -1, 0)$ 对于 $A$ 吸附\n-   $\\vec{\\nu}_2 = (-1, 0, +1, 0)$ 对于 $A$ 解吸\n-   $\\vec{\\nu}_3 = (0, +1, -1, 0)$ 对于 $B$ 吸附\n-   $\\vec{\\nu}_4 = (0, -1, +1, 0)$ 对于 $B$ 解吸\n-   $\\vec{\\nu}_5 = (-1, -1, +2, +1)$ 对于表面反应\n\n动力学由每个反应通道的倾向函数 $a_\\mu(\\vec{n})$ 控制。倾向 $a_\\mu(\\vec{n}) dt$ 表示在无穷小时间间隔 $[t, t+dt)$ 内反应 $\\mu$ 发生的概率。给定的倾向为：\n-   $a_1(\\vec{n}) = k_{\\text{ads},A}\\,n_{S}(t)$\n-   $a_2(\\vec{n}) = k_{\\text{des},A}\\,n_{AS}(t)$\n-   $a_3(\\vec{n}) = k_{\\text{ads},B}\\,n_{S}(t)$\n-   $a_4(\\vec{n}) = k_{\\text{des},B}\\,n_{BS}(t)$\n-   $a_5(\\vec{n}) = k_{\\text{rxn}}\\,n_{AS}(t)\\,n_{BS}(t)$\n\n总倾向 $a_{\\text{total}}(\\vec{n})$ 是所有单个倾向的总和：\n$$a_{\\text{total}}(\\vec{n}) = \\sum_{\\mu=1}^{5} a_\\mu(\\vec{n})$$\n\nGillespie SSA 提供了一个精确的程序来模拟这样一个系统的轨迹。该算法基于这样一个事实：对于马尔可夫过程，到下一个事件的等待时间呈指数分布，并且特定事件发生的概率与其倾向成正比。该算法的步骤如下：\n\n**Gillespie 算法**\n\n1.  **初始化**：\n    -   设置模拟时间 $t = 0$。\n    -   根据问题陈述初始化状态向量：$n_{AS} = 0$, $n_{BS} = 0$, $n_S = N_S$, $n_C = 0$。\n    -   使用指定的种子初始化伪随机数生成器 (RNG) 以确保可复现性。\n\n2.  **迭代循环**：模拟以离散步骤进行，从一个反应事件跳到下一个，直到模拟时间 $t$ 达到或超过最终时间 $T_{\\text{end}}$。\n    a.  **计算倾向**：给定当前状态 $\\vec{n}$，计算所有五个倾向 $a_1, ..., a_5$ 及其总和 $a_{\\text{total}}$。\n    b.  **检查终止条件**：如果 $a_{\\text{total}} = 0$，则没有更多反应可以发生。系统处于一个吸收态。模拟必须终止。此条件作为模拟逻辑的一部分被明确处理。\n    c.  **生成随机变量**：从区间 $(0, 1)$ 上的均匀分布中生成两个独立的随机数 $r_1$ 和 $r_2$。\n    d.  **确定时间步长**：到下一个事件的时间 $\\tau$ 是一个从参数为 $a_{\\text{total}}$ 的指数分布中抽取的随机变量。计算公式为：\n        $$\\tau = -\\frac{\\ln(r_1)}{a_{\\text{total}}}$$\n    e.  **推进时间**：更新模拟时间：$t \\leftarrow t + \\tau$。\n    f.  **检查结束时间**：如果新时间 $t$ 大于 $T_{\\text{end}}$，则当前轨迹的模拟结束。必须终止循环，系统状态保持在此时间步长*之前*的状态。最终报告的值是在超过 $T_{\\text{end}}$ 之前的最后一个有效时间步的 $n_C$。\n    g.  **选择反应**：下一个要发生的反应 $\\mu = j$ 以概率 $a_j / a_{\\text{total}}$ 被选择。这通过找到满足以下条件的索引 $j$ 来实现：\n        $$\\sum_{i=1}^{j-1} a_i  r_2 \\cdot a_{\\text{total}} \\le \\sum_{i=1}^{j} a_i$$\n    h.  **更新状态**：通过加上相应的状态改变向量来更新状态向量：$\\vec{n} \\leftarrow \\vec{n} + \\vec{\\nu}_j$。\n    i.  返回步骤 2a。\n\n3.  **输出**：当循环终止时（无论是达到 $T_{\\text{end}}$ 还是 $a_{\\text{total}} = 0$），$n_C$ 的最终整数值即为给定参数集的结果。\n\n该算法将针对问题中指定的每个测试用例进行实现。使用指定的种子可确保随机轨迹虽然本质上是随机的，但却是完全可复现的。边界情况，例如情况 4 中 $N_S = 0$ 的情况，会由算法自然处理。如果 $N_S = 0$，则 $n_{AS}(0) = n_{BS}(0) = n_{S}(0)=0$，这意味着在 $t=0$ 时所有倾向都为零。因此，$a_{\\text{total}} = 0$，模拟立即终止，结果被正确报告为 $n_C(0) = 0$。类似地，如果任何速率常数（如情况 3 中的 $k_{\\text{rxn}}$）为零，则相应的倾向 $a_5$ 将始终为零，产物 $C$ 永远无法形成。\n\n最终的实现将是一个 Python 脚本，它将此逻辑封装在一个函数中，遍历提供的测试用例，并按要求的格式打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N_S, T_end, k_ads_A, k_des_A, k_ads_B, k_des_B, k_rxn, seed):\n    \"\"\"\n    Executes a single stochastic simulation trajectory using the Gillespie algorithm.\n    \n    Args:\n        N_S (int): Total number of surface sites.\n        T_end (float): End time of the simulation in seconds.\n        k_ads_A (float): Rate constant for adsorption of A.\n        k_des_A (float): Rate constant for desorption of A.\n        k_ads_B (float): Rate constant for adsorption of B.\n        k_des_B (float): Rate constant for desorption of B.\n        k_rxn (float): Rate constant for the surface reaction.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        int: The final count of product molecules C.\n    \"\"\"\n    # Initialize the pseudorandom number generator\n    rng = np.random.default_rng(seed)\n\n    # State vector: [n_AS, n_BS_n_S, n_C]\n    # Initialize state at t=0\n    n_AS = 0\n    n_BS = 0\n    n_S = N_S\n    n_C = 0\n    t = 0.0\n\n    # State change vectors for each reaction\n    # 1: A + S - AS\n    # 2: AS - A + S\n    # 3: B + S - BS\n    # 4: BS - B + S\n    # 5: AS + BS - C + 2S\n    nu = np.array([\n        [1, 0, -1, 0],   # Reaction 1\n        [-1, 0, 1, 0],   # Reaction 2\n        [0, 1, -1, 0],   # Reaction 3\n        [0, -1, 1, 0],   # Reaction 4\n        [-1, -1, 2, 1]   # Reaction 5\n    ], dtype=np.int32)\n    \n    while t  T_end:\n        # Calculate propensities for all 5 reactions\n        a = np.array([\n            k_ads_A * n_S,\n            k_des_A * n_AS,\n            k_ads_B * n_S,\n            k_des_B * n_BS,\n            k_rxn * n_AS * n_BS\n        ])\n\n        a_total = np.sum(a)\n\n        # If a_total is 0, no more reactions can occur. Terminate.\n        if a_total == 0:\n            break\n\n        # Generate two random numbers\n        r1, r2 = rng.random(size=2)\n        \n        # Calculate time step tau\n        tau = -np.log(r1) / a_total\n\n        # If next event is after T_end, stop simulation\n        if t + tau > T_end:\n            break\n        \n        # Update time\n        t += tau\n\n        # Select which reaction occurs\n        # Find the index j such that sum(a[:j])  r2 * a_total = sum(a[:j+1])\n        target = r2 * a_total\n        cumsum_a = np.cumsum(a)\n        reaction_idx = np.searchsorted(cumsum_a, target, side='right')\n\n        # Update state based on the chosen reaction\n        n_AS += nu[reaction_idx, 0]\n        n_BS += nu[reaction_idx, 1]\n        n_S += nu[reaction_idx, 2]\n        n_C += nu[reaction_idx, 3]\n\n    return n_C\n\ndef solve():\n    \"\"\"\n    Runs the simulations for all test cases and prints the results.\n    \"\"\"\n    # Test Suite: (N_S, T_end, k_ads_A, k_des_A, k_ads_B, k_des_B, k_rxn, seed)\n    test_cases = [\n        (50, 2.0, 4.0, 1.0, 5.0, 1.5, 0.10, 12345),\n        (100, 1.0, 0.0, 1.0, 3.0, 1.0, 1.00, 67890),\n        (60, 3.0, 3.0, 0.5, 3.0, 0.5, 0.00, 13579),\n        (0, 10.0, 2.0, 0.2, 2.0, 0.2, 0.50, 24680),\n        (40, 5.0, 2.0, 0.2, 2.5, 0.2, 0.50, 424242),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2458845"}]}