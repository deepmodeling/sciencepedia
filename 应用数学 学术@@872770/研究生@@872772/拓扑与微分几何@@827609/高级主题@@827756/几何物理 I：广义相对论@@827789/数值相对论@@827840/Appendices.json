{"hands_on_practices": [{"introduction": "在演化爱因斯坦方程之前，必须提供满足特定“约束”方程的初始数据。这项实践 [@problem_id:1001099] 探讨了哈密顿约束，它是初值问题的基石。通过检验一个给定的时空偏离有效解的程度，你将深入理解这些基本约束在确保数值解物理一致性方面的重要性。", "problem": "在广义相对论的 3+1 ADM 形式中，真空时空的爱因斯坦场方程可分解为约束方程和演化方程。对于类空超曲面 $\\Sigma$ 上的初始数据，必须满足哈密顿约束。对于时间对称切片，外在曲率 $K_{ij}$ 为零，哈密顿约束简化为 $\\mathcal{H} = R = 0$，其中 $R$ 是切片上 3-度规 $\\gamma_{ij}$ 的里奇标量。\n\n构建初始数据的一个常用方法是共形方法。该方法假设一个物理度规 $\\gamma_{ij}$，它通过一个共形因子 $\\psi$ 与一个更简单的已知度规 $\\tilde{\\gamma}_{ij}$ 共形相关：\n$$\n\\gamma_{ij} = \\psi^4 \\tilde{\\gamma}_{ij}\n$$\n如果我们选择共形度规为平直度规，即 $\\tilde{\\gamma}_{ij} = \\delta_{ij}$（欧几里得度规），则该物理度规被称为共形平直度规。对于此类度规，里奇标量 $R$ 与共形因子 $\\psi$ 通过以下方程相关联：\n$$\nR = -8\\psi^{-5} \\nabla^2 \\psi\n$$\n其中 $\\nabla^2 = \\delta^{ij}\\partial_i\\partial_j$ 是标准的平直空间拉普拉斯算子。如果 $\\psi$ 是哈密顿约束的一个解，则 $\\nabla^2 \\psi = 0$。\n\n考虑一个在球坐标 $(r, \\theta, \\phi)$ 下给出的共形因子：\n$$\n\\psi(r) = A \\exp\\left(-\\frac{r^2}{\\sigma^2}\\right) + B\n$$\n其中 $r = \\sqrt{x^2+y^2+z^2}$ 是径向坐标，$A$、$B$ 和 $\\sigma$ 是正常数。这种形式的 $\\psi$ 通常不满足哈密顿约束。\n\n在径向坐标 $r=\\sigma$ 处，推导哈密顿约束违背量 $\\mathcal{H}$ 的表达式。您的最终答案应为一个用常数 $A$、$B$ 和 $\\sigma$ 表示的闭式表达式。", "solution": "我们从共形平直度规的哈密顿约束违背量开始，\n$$\n\\mathcal{H}=R=-8\\,\\psi^{-5}\\nabla^2\\psi\\,,\n$$\n对于平直空间中纯径向的 $\\psi(r)$，\n$$\n\\nabla^2\\psi\n=\\frac{1}{r^2}\\partial_r\\bigl(r^2\\partial_r\\psi\\bigr)\\,. \n$$\n给定\n$$\n\\psi(r)=A\\exp\\bigl(-\\tfrac{r^2}{\\sigma^2}\\bigr)+B,\n$$\n我们计算\n$$\n\\partial_r\\psi\n=A\\bigl(-\\tfrac{2r}{\\sigma^2}\\bigr)e^{-r^2/\\sigma^2}\n=-\\frac{2Ar}{\\sigma^2}e^{-r^2/\\sigma^2},\n$$\n$$\nr^2\\partial_r\\psi\n=-\\frac{2A\\,r^3}{\\sigma^2}e^{-r^2/\\sigma^2},\n$$\n$$\n\\partial_r\\bigl(r^2\\partial_r\\psi\\bigr)\n=-\\frac{2A}{\\sigma^2}\\frac{d}{dr}\\Bigl(r^3e^{-r^2/\\sigma^2}\\Bigr)\n=-\\frac{2A}{\\sigma^2}e^{-r^2/\\sigma^2}\\bigl(3r^2-\\tfrac{2r^4}{\\sigma^2}\\bigr).\n$$\n因此\n$$\n\\nabla^2\\psi\n=-\\frac{2A}{\\sigma^2}e^{-r^2/\\sigma^2}\\Bigl(3-\\frac{2r^2}{\\sigma^2}\\Bigr).\n$$\n在 $r=\\sigma$ 处求值，得到 $r^2/\\sigma^2=1$ 且\n$$\n\\nabla^2\\psi\\big|_{r=\\sigma}\n=-\\frac{2A}{\\sigma^2}e^{-1}.\n$$\n所以\n$$\n\\mathcal{H}\\big|_{r=\\sigma}\n=-8\\,\\psi^{-5}\n\\Bigl(-\\frac{2A}{\\sigma^2}e^{-1}\\Bigr)\n=\\frac{16A\\,e^{-1}}{\\sigma^2\\,\\psi(\\sigma)^5},\n$$\n其中 $\\psi(\\sigma)=A e^{-1}+B$。", "answer": "$$\\boxed{\\frac{16A e^{-1}}{\\sigma^2\\bigl(Ae^{-1}+B\\bigr)^5}}$$", "id": "1001099"}, {"introduction": "数值模拟需要在离散网格上表示连续的场和微分算符。这项实践 [@problem_id:1001182] 演示了如何使用有限差分法来近似一个关键的微分算符——协变拉普拉斯算符。这对于编写能够处理弯曲时空几何的演化代码来说，是一项基本技能。", "problem": "在数值相对论中，研究弯曲时空背景下标量场的演化，通常通过将场方程在网格上进行离散化来实现。这些方程中的一个基本算子是协变拉普拉斯算子。对于黎曼流形上度规为 $g_{ab}$ 的标量场 $\\phi$，协变拉普拉斯算子定义为 $\\nabla^2 \\phi = g^{ab} \\nabla_a \\nabla_b \\phi$，其中 $\\nabla_a$ 是与度规相容的协变导数。\n\n考虑一个线元为 $ds^2 = g_{xx}(x) (dx)^2$ 的一维空间切片。在此切片上，标量场 $\\phi(x)$ 的协变拉普拉斯算子可简化为如下紧凑形式：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\sqrt{g_{xx}}} \\frac{d}{dx} \\left(\\frac{1}{\\sqrt{g_{xx}}} \\frac{d\\phi}{dx}\\right)\n$$\n为了数值求解，可以定义一个均匀网格 $x_i = i h$（其中 $i$ 为整数，$h$ 为网格间距），并使用有限差分来近似该算子。一个通过在交错网格上计算导数构建的二阶精度中心差分格式，给出了在网格点 $x_i$ 处拉普拉斯算子的如下近似：\n$$\n(\\nabla^2 \\phi)_i \\approx \\frac{1}{\\sqrt{g_{xx,i}} h^2} \\left( \\frac{\\phi_{i+1} - \\phi_i}{\\sqrt{\\frac{1}{2}(g_{xx,i} + g_{xx,i+1})}} - \\frac{\\phi_i - \\phi_{i-1}}{\\sqrt{\\frac{1}{2}(g_{xx,i-1} + g_{xx,i})}} \\right)\n$$\n其中 $\\phi_i = \\phi(x_i)$ 且 $g_{xx,i} = g_{xx}(x_i)$。\n\n考虑一个空间，其度规分量为 $g_{xx}(x) = e^{2\\alpha x}$，标量场为 $\\phi(x) = \\beta \\sin(\\omega x)$，其中 $\\alpha, \\beta, \\omega$ 和 $h$ 是正实数参数。\n\n你的任务是推导在网格点 $x_1=h$ 处协变拉普拉斯算子 $(\\nabla^2 \\phi)_1$ 的有限差分近似的闭式解析表达式。最终表达式应使用符号常量 $\\alpha, \\beta, \\omega$ 和 $h$ 表示。", "solution": "问题要求在网格点 $x_1 = h$ 处协变拉普拉斯算子 $(\\nabla^2 \\phi)_1$ 的数值近似。给定的有限差分公式为：\n$$\n(\\nabla^2 \\phi)_i \\approx \\frac{1}{\\sqrt{g_{xx,i}} h^2} \\left( \\frac{\\phi_{i+1} - \\phi_i}{\\sqrt{\\frac{1}{2}(g_{xx,i} + g_{xx,i+1})}} - \\frac{\\phi_i - \\phi_{i-1}}{\\sqrt{\\frac{1}{2}(g_{xx,i-1} + g_{xx,i})}} \\right)\n$$\n我们需要计算 $i=1$ 时的值。这需要标量场 $\\phi$ 和度规分量 $g_{xx}$ 在网格点 $x_0 = 0 \\cdot h = 0$，$x_1 = 1 \\cdot h = h$ 和 $x_2 = 2 \\cdot h = 2h$ 处的值。\n\n首先，我们计算标量场 $\\phi(x) = \\beta \\sin(\\omega x)$ 所需的值：\n-   在 $x_0 = 0$ 处：$\\phi_0 = \\beta \\sin(\\omega \\cdot 0) = 0$。\n-   在 $x_1 = h$ 处：$\\phi_1 = \\beta \\sin(\\omega h)$。\n-   在 $x_2 = 2h$ 处：$\\phi_2 = \\beta \\sin(2\\omega h)$。\n\n接下来，我们计算度规分量 $g_{xx}(x) = e^{2\\alpha x}$ 所需的值：\n-   在 $x_0 = 0$ 处：$g_{xx,0} = e^{2\\alpha \\cdot 0} = e^0 = 1$。\n-   在 $x_1 = h$ 处：$g_{xx,1} = e^{2\\alpha h}$。\n-   在 $x_2 = 2h$ 处：$g_{xx,2} = e^{2\\alpha (2h)} = e^{4\\alpha h}$。\n\n现在，我们将这些值代入 $i=1$ 的有限差分公式中：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{1}{\\sqrt{g_{xx,1}} h^2} \\left( \\frac{\\phi_2 - \\phi_1}{\\sqrt{\\frac{1}{2}(g_{xx,1} + g_{xx,2})}} - \\frac{\\phi_1 - \\phi_0}{\\sqrt{\\frac{1}{2}(g_{xx,0} + g_{xx,1})}} \\right)\n$$\n代入计算出的值：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{1}{\\sqrt{e^{2\\alpha h}} h^2} \\left( \\frac{\\beta \\sin(2\\omega h) - \\beta \\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(e^{2\\alpha h} + e^{4\\alpha h})}} - \\frac{\\beta \\sin(\\omega h) - 0}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} \\right)\n$$\n让我们逐项简化表达式。前置因子是 $\\frac{1}{e^{\\alpha h} h^2}$。我们可以从括号中的项里提出因子 $\\beta$。\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\beta}{e^{\\alpha h} h^2} \\left( \\frac{\\sin(2\\omega h) - \\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(e^{2\\alpha h} + e^{4\\alpha h})}} - \\frac{\\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} \\right)\n$$\n现在，简化括号内的分母。\n对于第一项的分母：$\\sqrt{\\frac{1}{2}(e^{2\\alpha h} + e^{4\\alpha h})} = \\sqrt{\\frac{1}{2}e^{2\\alpha h}(1 + e^{2\\alpha h})} = e^{\\alpha h} \\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}$。\n于是表达式变为：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\beta}{e^{\\alpha h} h^2} \\left( \\frac{\\sin(2\\omega h) - \\sin(\\omega h)}{e^{\\alpha h} \\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} - \\frac{\\sin(\\omega h)}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} \\right)\n$$\n我们可以提出因子 $\\frac{1}{\\sqrt{\\frac{1}{2}(1 + e^{2\\alpha h})}} = \\frac{\\sqrt{2}}{\\sqrt{1 + e^{2\\alpha h}}}$。\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\beta}{e^{\\alpha h} h^2} \\frac{\\sqrt{2}}{\\sqrt{1 + e^{2\\alpha h}}} \\left( \\frac{\\sin(2\\omega h) - \\sin(\\omega h)}{e^{\\alpha h}} - \\sin(\\omega h) \\right)\n$$\n合并前置因子，得到最终的简化表达式：\n$$\n(\\nabla^2 \\phi)_1 = \\frac{\\sqrt{2}\\beta}{e^{\\alpha h} h^2 \\sqrt{1 + e^{2\\alpha h}}} \\left( e^{-\\alpha h}(\\sin(2\\omega h) - \\sin(\\omega h)) - \\sin(\\omega h) \\right)\n$$", "answer": "$$\n\\boxed{\\frac{\\sqrt{2}\\beta}{e^{\\alpha h} h^2 \\sqrt{1 + e^{2\\alpha h}}} \\left( e^{-\\alpha h}(\\sin(2\\omega h) - \\sin(\\omega h)) - \\sin(\\omega h) \\right)}\n$$", "id": "1001182"}, {"introduction": "现代数值相对论模拟通常使用 BSSN 形式，因其具有优越的稳定性，但这需要将标准的 ADM 变量转换为 BSSN 变量。这项综合性的编程练习 [@problem_id:2420591] 提供了关于这一关键转换的动手经验，弥合了理论定义与可工作的数值模块之间的差距，是构建稳定数值时空演化程序的核心步骤。", "problem": "你的任务是，在一个使用周期性边界条件的均匀三维笛卡尔网格上，实现、验证并测试一个从 Arnowitt–Deser–Misner (ADM) 初始数据到 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 变量的变换。ADM 初始数据由空间度规 $\\gamma_{ij}$ 和外部曲率 $K_{ij}$ 组成。需要生成的 BSSN 变量是共形因子 $\\phi$、共形度规 $\\tilde{\\gamma}_{ij}$、无迹共形外部曲率 $A_{ij}$、平均曲率 $K$ 以及收缩的共形连接函数 $\\tilde{\\Gamma}^{i}$。\n\n出发点（来自 $3+1$ 分解和 BSSN 表述的基本定义与恒等式）：\n- 度规的共形分解为 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$，其中 $\\det(\\tilde{\\gamma}_{ij}) = 1$。由此可得 $\\det(\\gamma_{ij}) = e^{12 \\phi}$，因此 $\\phi = \\frac{1}{12} \\ln \\det(\\gamma_{ij})$。\n- 平均曲率是外部曲率相对于 $\\gamma_{ij}$ 的迹：$K = \\gamma^{ij} K_{ij}$，其中 $\\gamma^{ij}$ 是 $\\gamma_{ij}$ 的逆矩阵。\n- $K_{ij}$ 的无迹部分是 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。无迹共形外部曲率是 $A_{ij} = e^{-4 \\phi} S_{ij}$。\n- 在笛卡尔坐标系中，当 $\\det(\\tilde{\\gamma}_{ij}) = 1$ 时，收缩的共形连接函数满足 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$，其中 $\\tilde{\\gamma}^{ij}$ 是 $\\tilde{\\gamma}_{ij}$ 的逆矩阵。空间导数需要进行数值近似。\n\n数值要求：\n- 使用一个包含 $N \\times N \\times N$ 个点的均匀笛卡尔网格，覆盖周期性区域 $[0, L] \\times [0, L] \\times [0, L]$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。网格点位于 $x_{n} = n \\Delta x$、$y_{m} = m \\Delta y$、$z_{p} = p \\Delta z$，其中整数 $n, m, p$ 在 $\\{0, 1, \\dots, N-1\\}$ 范围内。\n- 在所有三个方向上使用周期性边界条件。\n- 使用二阶中心有限差分计算空间导数。对于任何标量或张量分量 $u$，沿 $x$ 坐标的离散导数为 $\\partial_{x} u \\approx \\left(u(x+\\Delta x) - u(x-\\Delta x)\\right) / (2 \\Delta x)$，$y$ 和 $z$ 方向类似，并采用周期性环绕处理。\n\n实现任务：\n- 编写一个模块，给定网格上的场 $\\gamma_{ij}$ 和 $K_{ij}$，根据上述定义在每个网格点上计算 $\\phi$、$\\tilde{\\gamma}_{ij}$、$A_{ij}$、$K$ 和 $\\tilde{\\Gamma}^{i}$。\n- 在以下三个测试用例上验证实现。在每个用例中，ADM 数据都是解析给出的，你必须在网格上构建 $\\gamma_{ij}$ 和 $K_{ij}$，应用你的变换，并在 BSSN 量非平凡的情况下与解析已知的 BSSN 量进行比较。\n\n测试套件（所有用例使用相同的网格参数 $N$ 和 $L$）：\n- 通用网格参数：$N = 32$, $L = 2\\pi$。\n\n- 用例 1（纯共形因子，平坦共形度规，外部曲率为零）：\n  - 定义 $f(x) = a \\sin(k x)$，其中 $a = 0.1$ 和 $k = 1$，仅依赖于 $x$。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 和 $K_{ij} = 0$。\n  - BSSN 解析参考解：$\\phi = f(x)$，$\\tilde{\\gamma}_{ij} = \\delta_{ij}$，$A_{ij} = 0$，$K = 0$，$\\tilde{\\Gamma}^{i} = 0$。\n\n- 用例 2（非平凡的单位行列式共形度规，共形因子为零，外部曲率为零）：\n  - 定义 $h(x) = b \\cos(k x)$，其中 $b = 0.2$ 和 $k = 2$，仅依赖于 $x$。\n  - 设置 $\\tilde{\\gamma}_{ij} = \\mathrm{diag}\\left(e^{h(x)}, e^{-h(x)}, 1\\right)$ 和 $\\gamma_{ij} = \\tilde{\\gamma}_{ij}$，且 $K_{ij} = 0$。\n  - BSSN 解析参考解：$\\phi = 0$，$A_{ij} = 0$，$K = 0$。逆共形度规为 $\\tilde{\\gamma}^{ij} = \\mathrm{diag}\\left(e^{-h(x)}, e^{h(x)}, 1\\right)$。因此 $\\tilde{\\Gamma}^{x} = -\\partial_{x}\\tilde{\\gamma}^{xx} = e^{-h(x)} h'(x)$，其中 $h'(x) = - b k \\sin(k x)$，且 $\\tilde{\\Gamma}^{y} = 0$，$\\tilde{\\Gamma}^{z} = 0$。\n\n- 用例 3（非平凡共形因子，平坦共形度规，以及具有指定迹和无迹部分的外部曲率）：\n  - 定义 $f(x) = a \\cos(k x)$，其中 $a = 0.05$ 和 $k = 3$，仅依赖于 $x$。令 $K_{0} = 0.4$ 和 $s = 0.3$ 为常数。\n  - 设置 $\\gamma_{ij} = e^{4 f(x)} \\delta_{ij}$ 并定义一个常数无迹张量 $S_{ij} = \\mathrm{diag}(s, -s/2, -s/2)$（相对于 $\\delta_{ij}$ 是无迹的）。定义 $K_{ij} = \\frac{1}{3} \\gamma_{ij} K_{0} + e^{4 f(x)} S_{ij}$。\n  - BSSN 解析参考解：$\\phi = f(x)$，$\\tilde{\\gamma}_{ij} = \\delta_{ij}$，$K = K_{0}$，$A_{ij} = S_{ij}$，$\\tilde{\\Gamma}^{i} = 0$。\n\n误差评估和要求输出：\n- 对于每个用例，计算：\n  - $\\phi$ 在所有网格点上的最大绝对误差：$\\max |\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{ref}}|$。\n  - $K$ 在所有网格点上的最大绝对误差：$\\max |K_{\\mathrm{num}} - K_{\\mathrm{ref}}|$。\n  - $A_{ij}$ 在所有网格点和分量上的最大绝对误差：$\\max |A^{\\mathrm{num}}_{ij} - A^{\\mathrm{ref}}_{ij}|$。\n  - $\\tilde{\\Gamma}^{i}$ 误差的逐点欧几里得范数的最大值：$\\max \\sqrt{(\\Delta \\tilde{\\Gamma}^{x})^{2} + (\\Delta \\tilde{\\Gamma}^{y})^{2} + (\\Delta \\tilde{\\Gamma}^{z})^{2}}$。\n- 你的程序应生成单行输出，其中包含三个用例的所有结果，按顺序排列，形式为一个用方括号括起来的逗号分隔列表：$[\\mathrm{case1\\_phi},\\mathrm{case1\\_K},\\mathrm{case1\\_A},\\mathrm{case1\\_\\tilde{\\Gamma}};\\mathrm{case2\\_phi},\\mathrm{case2\\_K},\\mathrm{case2\\_A},\\mathrm{case2\\_\\tilde{\\Gamma}};\\mathrm{case3\\_phi},\\mathrm{case3\\_K},\\mathrm{case3\\_A},\\mathrm{case3\\_\\tilde{\\Gamma}}]$。在实际输出字符串中，用逗号替换分号，从而得到一个包含 $12$ 个浮点数的扁平列表。不应打印任何其他文本。", "solution": "问题陈述已提交以供验证。提取并分析了给定的条件、定义和测试用例，以检查其内部一致性和科学有效性。该问题涉及将爱因斯坦场方程的初始数据从 Arnowitt–Deser–Misner (ADM) 表述变换到 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 表述。所有定义——度规的共形分解 $\\gamma_{ij} = e^{4 \\phi} \\tilde{\\gamma}_{ij}$、平均曲率的定义 $K = \\gamma^{ij} K_{ij}$、无迹共形外部曲率 $A_{ij}$，以及收缩的共形连接函数 $\\tilde{\\Gamma}^{i} = - \\partial_{j} \\tilde{\\gamma}^{ij}$——在数值相对论领域都是标准的。所提供的测试用例经核实与这些定义一致。该问题是一个适定的计算物理任务，具有清晰、客观的规范和可验证的结果。因此，该问题被认定为有效。\n\n解决方案需要在均匀笛卡尔网格上实现一个数值程序，用于从 ADM 变量（$\\gamma_{ij}, K_{ij}$）计算 BSSN 变量（$\\phi, \\tilde{\\gamma}_{ij}, K, A_{ij}, \\tilde{\\Gamma}^{i}$）。该程序如下。\n\n首先，建立一个均匀、周期性的三维笛卡尔网格。该网格有 $N \\times N \\times N$ 个点，其中 $N=32$，覆盖区域 $[0, L] \\times [0, L] \\times [0, L]$，其中 $L=2\\pi$。网格间距为 $\\Delta x = \\Delta y = \\Delta z = L/N$。每个网格点 $(i,j,k)$ 的坐标为 $(x_i, y_j, z_k)$。对于三个测试用例中的每一个，初始 ADM 张量场 $\\gamma_{ij}$ 和 $K_{ij}$ 根据其解析定义在此网格上构建为数组。\n\n该变换在每个网格点上按以下计算顺序进行：\n\n1.  **共形因子 $\\phi$**：计算空间度规的行列式 $\\det(\\gamma_{ij})$。然后通过 $\\phi = \\frac{1}{12} \\ln(\\det(\\gamma_{ij}))$ 给出共形因子。此步骤分离出空间几何的体积部分。\n\n2.  **共形度规 $\\tilde{\\gamma}_{ij}$**：使用计算出的共形因子 $\\phi$，对物理度规 $\\gamma_{ij}$ 进行共形重缩放，以获得共形度规 $\\tilde{\\gamma}_{ij} = e^{-4\\phi} \\gamma_{ij}$。根据构造，该度规的行列式为单位 1，即 $\\det(\\tilde{\\gamma}_{ij}) = 1$。\n\n3.  **平均曲率 $K$**：通过在每个网格点上对 $3 \\times 3$ 矩阵 $\\gamma_{ij}$ 求逆来计算物理空间度规的逆 $\\gamma^{ij}$。然后通过将逆度规与外部曲率进行收缩来求得平均曲率：$K = \\gamma^{ij} K_{ij}$。这是对两个指标求和，代表 $K_{ij}$ 的迹。\n\n4.  **无迹共形外部曲率 $A_{ij}$**：首先，计算外部曲率相对于物理度规的无迹部分 $S_{ij} = K_{ij} - \\frac{1}{3} \\gamma_{ij} K$。然后对此张量进行共形重缩放，得到 BSSN 变量 $A_{ij} = e^{-4\\phi} S_{ij}$。\n\n5.  **收缩的共形连接函数 $\\tilde{\\Gamma}^{i}$**：这是唯一需要数值微分的步骤。\n    a.  从 $\\tilde{\\gamma}_{ij}$ 计算共形度规的逆 $\\tilde{\\gamma}^{ij}$。\n    b.  使用带有周期性边界条件的二阶中心有限差分格式计算 $\\tilde{\\gamma}^{ij}$ 各分量的空间导数 $\\partial_j$。对于一个场 $u(x,y,z)$ 和网格间距 $\\Delta x$，在网格点 $i$ 处关于 $x$ 的导数近似为 $\\partial_x u_i \\approx \\frac{u_{i+1} - u_{i-1}}{2 \\Delta x}$。区域的周期性意味着边界处的索引 $i+1$ 会环绕到开头，而 $i-1$ 会环绕到末尾。\n    c.  然后通过收缩这些导数来计算连接函数：$\\tilde{\\Gamma}^{i} = - \\sum_{j} \\partial_j \\tilde{\\gamma}^{ij}$。明确地，对于每个分量 $i \\in \\{x, y, z\\}$：\n    $$ \\tilde{\\Gamma}^x = -(\\partial_x \\tilde{\\gamma}^{xx} + \\partial_y \\tilde{\\gamma}^{xy} + \\partial_z \\tilde{\\gamma}^{xz}) $$\n    $$ \\tilde{\\Gamma}^y = -(\\partial_x \\tilde{\\gamma}^{yx} + \\partial_y \\tilde{\\gamma}^{yy} + \\partial_z \\tilde{\\gamma}^{yz}) $$\n    $$ \\tilde{\\Gamma}^z = -(\\partial_x \\tilde{\\gamma}^{zx} + \\partial_y \\tilde{\\gamma}^{zy} + \\partial_z \\tilde{\\gamma}^{zz}) $$\n    注意，因为逆度规是对称的（$\\tilde{\\gamma}^{ij} = \\tilde{\\gamma}^{ji}$），所以该表达式等价于逆共形度规张量的行（或列）的散度。\n\n最后，对于每个测试用例，将数值计算出的 BSSN 场与其提供的解析参考解进行比较。误差度量按规定计算：标量和张量场 $\\phi$、$K$ 和 $A_{ij}$ 的最大绝对误差，以及 $\\tilde{\\Gamma}^{i}$ 的误差向量的逐点欧几里得范数的最大值。这些误差预计很小，与二阶有限差分格式的截断误差同量级，即 $O(\\Delta x^2)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted from the specified environment.\n\ndef solve():\n    \"\"\"\n    Implements and tests the ADM to BSSN transformation for numerical relativity.\n    \"\"\"\n    N = 32\n    L = 2.0 * np.pi\n    dx = L / N\n    # We use np.mgrid to create coordinate arrays where the first axis corresponds to x,\n    # the second to y, and the third to z. This is unconventional but allows for\n    # straightforward indexing e.g., axis=0 for x-derivatives.\n    coords = np.mgrid[0:N, 0:N, 0:N].astype(float) * dx\n    x, y, z = coords[0], coords[1], coords[2]\n\n    def central_diff(field, axis, step):\n        \"\"\"Computes 2nd-order periodic central difference.\"\"\"\n        return (np.roll(field, -1, axis=axis) - np.roll(field, 1, axis=axis)) / (2.0 * step)\n\n    def adm_to_bssn(gamma, K_ij, dx, dy, dz):\n        \"\"\"\n        Performs the transformation from ADM to BSSN variables on the grid.\n        \n        Args:\n            gamma (np.ndarray): Physical metric, shape (3, 3, N, N, N).\n            K_ij (np.ndarray): Extrinsic curvature, shape (3, 3, N, N, N).\n            dx, dy, dz (float): Grid spacings.\n\n        Returns:\n            A tuple of BSSN variables: (phi, tilde_gamma, A_ij, K_trace, Gamma_i).\n        \"\"\"\n        # Transpose for np.linalg functions which operate on the last two axes\n        gamma_T = gamma.transpose(2, 3, 4, 0, 1)\n        \n        # 1. Conformal factor phi\n        gamma_det = np.linalg.det(gamma_T)\n        phi = (1.0 / 12.0) * np.log(gamma_det)\n\n        # 2. Conformal metric tilde_gamma_ij\n        # Use broadcasting: (N,N,N) * (3,3,N,N,N)\n        tilde_gamma = np.exp(-4.0 * phi) * gamma\n        \n        # 3. Mean curvature K\n        gamma_inv_T = np.linalg.inv(gamma_T)\n        gamma_inv = gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        K_trace = np.einsum('ij...,ij...->...', gamma_inv, K_ij)\n\n        # 4. Conformal trace-free extrinsic curvature A_ij\n        S_ij = K_ij - (1.0 / 3.0) * K_trace * gamma  # Broadcasting K_trace * gamma\n        A_ij = np.exp(-4.0 * phi) * S_ij\n        \n        # 5. Contracted conformal connection functions Gamma^i\n        tilde_gamma_T = tilde_gamma.transpose(2, 3, 4, 0, 1)\n        tilde_gamma_inv_T = np.linalg.inv(tilde_gamma_T)\n        tilde_gamma_inv = tilde_gamma_inv_T.transpose(3, 4, 0, 1, 2)\n        \n        Gamma_i = np.zeros((3, N, N, N))\n        \n        # Sum over j: partial_j tilde_gamma^ij\n        # For i = 0 (x-component):\n        Gamma_i[0] = -(central_diff(tilde_gamma_inv[0, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[0, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[0, 2], 2, dz))\n        # For i = 1 (y-component):\n        Gamma_i[1] = -(central_diff(tilde_gamma_inv[1, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[1, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[1, 2], 2, dz))\n        # For i = 2 (z-component):\n        Gamma_i[2] = -(central_diff(tilde_gamma_inv[2, 0], 0, dx) +\n                       central_diff(tilde_gamma_inv[2, 1], 1, dy) +\n                       central_diff(tilde_gamma_inv[2, 2], 2, dz))\n        \n        return phi, tilde_gamma, A_ij, K_trace, Gamma_i\n\n    all_errors = []\n\n    # Test Case 1\n    a, k = 0.1, 1.0\n    f_x = a * np.sin(k * x)\n    \n    gamma_1 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_1[0, 0] = conf_factor\n    gamma_1[1, 1] = conf_factor\n    gamma_1[2, 2] = conf_factor\n    \n    K_ij_1 = np.zeros((3, 3, N, N, N))\n    \n    phi_num_1, tilde_gamma_num_1, A_ij_num_1, K_num_1, Gamma_i_num_1 = adm_to_bssn(gamma_1, K_ij_1, dx, dx, dx)\n    \n    phi_ref_1 = f_x\n    K_ref_1 = np.zeros_like(phi_ref_1)\n    A_ij_ref_1 = np.zeros_like(A_ij_num_1)\n    Gamma_i_ref_1 = np.zeros_like(Gamma_i_num_1)\n    \n    err_phi_1 = np.max(np.abs(phi_num_1 - phi_ref_1))\n    err_K_1 = np.max(np.abs(K_num_1 - K_ref_1))\n    err_A_1 = np.max(np.abs(A_ij_num_1 - A_ij_ref_1))\n    err_Gamma_1 = np.max(np.sqrt(np.sum((Gamma_i_num_1 - Gamma_i_ref_1)**2, axis=0)))\n    all_errors.extend([err_phi_1, err_K_1, err_A_1, err_Gamma_1])\n\n    # Test Case 2\n    b, k = 0.2, 2.0\n    h_x = b * np.cos(k * x)\n    \n    gamma_2 = np.zeros((3, 3, N, N, N))\n    gamma_2[0, 0] = np.exp(h_x)\n    gamma_2[1, 1] = np.exp(-h_x)\n    gamma_2[2, 2] = 1.0\n    \n    K_ij_2 = np.zeros((3, 3, N, N, N))\n\n    phi_num_2, _, A_ij_num_2, K_num_2, Gamma_i_num_2 = adm_to_bssn(gamma_2, K_ij_2, dx, dx, dx)\n\n    phi_ref_2 = np.zeros_like(phi_num_2)\n    K_ref_2 = np.zeros_like(K_num_2)\n    A_ij_ref_2 = np.zeros_like(A_ij_num_2)\n    \n    Gamma_i_ref_2 = np.zeros((3, N, N, N))\n    hp_x = -b * k * np.sin(k * x)\n    Gamma_i_ref_2[0] = np.exp(-h_x) * hp_x\n    \n    err_phi_2 = np.max(np.abs(phi_num_2 - phi_ref_2))\n    err_K_2 = np.max(np.abs(K_num_2 - K_ref_2))\n    err_A_2 = np.max(np.abs(A_ij_num_2 - A_ij_ref_2))\n    err_Gamma_2 = np.max(np.sqrt(np.sum((Gamma_i_num_2 - Gamma_i_ref_2)**2, axis=0)))\n    all_errors.extend([err_phi_2, err_K_2, err_A_2, err_Gamma_2])\n\n    # Test Case 3\n    a, k = 0.05, 3.0\n    K0, s = 0.4, 0.3\n    f_x = a * np.cos(k * x)\n    \n    gamma_3 = np.zeros((3, 3, N, N, N))\n    conf_factor = np.exp(4.0 * f_x)\n    gamma_3[0, 0] = conf_factor\n    gamma_3[1, 1] = conf_factor\n    gamma_3[2, 2] = conf_factor\n    \n    S_ij_const = np.zeros((3, 3))\n    S_ij_const[0, 0] = s\n    S_ij_const[1, 1] = -s / 2.0\n    S_ij_const[2, 2] = -s / 2.0\n    \n    K_ij_3 = (1.0 / 3.0) * K0 * gamma_3 + conf_factor * S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    \n    phi_num_3, _, A_ij_num_3, K_num_3, Gamma_i_num_3 = adm_to_bssn(gamma_3, K_ij_3, dx, dx, dx)\n\n    phi_ref_3 = f_x\n    K_ref_3 = np.full_like(K_num_3, K0)\n    A_ij_ref_3 = S_ij_const[:, :, np.newaxis, np.newaxis, np.newaxis]\n    Gamma_i_ref_3 = np.zeros_like(Gamma_i_num_3)\n    \n    err_phi_3 = np.max(np.abs(phi_num_3 - phi_ref_3))\n    err_K_3 = np.max(np.abs(K_num_3 - K_ref_3))\n    err_A_3 = np.max(np.abs(A_ij_num_3 - A_ij_ref_3))\n    err_Gamma_3 = np.max(np.sqrt(np.sum((Gamma_i_num_3 - Gamma_i_ref_3)**2, axis=0)))\n    all_errors.extend([err_phi_3, err_K_3, err_A_3, err_Gamma_3])\n\n    print(f\"[{','.join(map(str, all_errors))}]\")\n\nsolve()\n```", "id": "2420591"}]}