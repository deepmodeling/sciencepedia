{"hands_on_practices": [{"introduction": "我们从一个基础应用开始，直接运用深度优先搜索（DFS）来检测循环。这个问题以一个易于理解的城市交通规划场景为例 [@problem_id:1493924]，展示了在DFS遍历过程中发现“回边”（back edge）是如何从数学上确认循环路径存在的。掌握这个核心机制是有效应用该算法的第一步。", "problem": "一位城市规划师正在为一个新的市中心区设计交通流，该区有6个交叉路口，编号从0到5。为了管理交通，所有街道都将是单行道。一项关键任务是确保所提议的布局不包含任何“交通环路”——即允许驾驶员仅通过遵循一系列单行道就能返回其起始交叉路口的路线。\n\n为了检查此类环路，采用了一种基于深度优先搜索（DFS）的算法。这些交叉路口被视为图中的顶点，单行道被视为有向边。如果深度优先搜索过程中发现了一条“后向边”，则检测到一个环路。后向边是指从当前访问的顶点指向仍在探索过程中的祖先顶点（即，它位于当前递归路径上）的边。\n\n提议的单行道如下：\n- 0 到 1\n- 1 到 2\n- 2 到 0\n- 1 到 3\n- 3 到 4\n- 4 到 1\n- 5 到 4\n\nDFS算法遵循以下规则：\n1. 搜索从顶点0开始。\n2. 如果图有多个不相连的组件，则通过选择编号最小的未访问顶点继续搜索。\n3. 从任何给定顶点进行探索时，其相邻邻居按数字升序访问。\n\n在这次特定的DFS算法执行中，总共会检测到多少条后向边？\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3\n\nE. 4", "solution": "我们将交叉路口建模为顶点 $0,1,2,3,4,5$，将单行道建模为有向边。DFS从 $0$ 开始，按升序访问邻居，并在一个组件完成后，从编号最小的未访问顶点继续。后向边是从当前正在探索的顶点到当前递归堆栈上的祖先顶点的边。\n\n按升序构建邻接表：$0:\\{1\\}$, $1:\\{2,3\\}$, $2:\\{0\\}$, $3:\\{4\\}$, $4:\\{1\\}$, $5:\\{4\\}$。\n\n从 $0$ 开始DFS。将 $0$ 标记为活动状态（在递归堆栈上）。从 $0$ 访问 $1$；边 $0\\to 1$ 是树边。在 $1$ 处，首先访问 $2$；边 $1\\to 2$ 是树边。在 $2$ 处，其邻居是 $0$。顶点 $0$ 处于活动状态并且是 $2$ 的祖先，所以 $2\\to 0$ 是后向边；计数为 $1$。完成 $2$ 的访问（它离开堆栈）。返回到 $1$ 并访问下一个邻居 $3$；边 $1\\to 3$ 是树边。在 $3$ 处，访问 $4$；边 $3\\to 4$ 是树边。在 $4$ 处，其邻居是 $1$，$1$ 仍处于活动状态并且是 $4$ 的祖先，所以 $4\\to 1$ 是后向边；计数为 $2$。完成 $4$，然后 $3$，然后 $1$，然后 $0$ 的访问。\n\n完成这个组件后，编号最小的未访问顶点是 $5$。从 $5$ 开始DFS。其邻居是 $4$，$4$ 已经访问完成（不在当前堆栈上），所以 $5\\to 4$ 不是后向边。没有发现额外的后向边。\n\n因此，检测到的后向边总数为 $2$。", "answer": "$$\\boxed{C}$$", "id": "1493924"}, {"introduction": "真实世界的问题常常带有标准算法无法直接处理的约束。这个练习 [@problem_id:1493919] 挑战你检测一个边的类型必须交替出现的特殊循环。解决问题的关键并非改变DFS算法本身，而是将原图转换成一个新的状态空间图，在这个新图上进行标准的循环搜索，从而揭示答案。这体现了问题建模这一强大的技巧。", "problem": "在设计下一代片上系统（SoC）时，使用了两种不同的通信协议“Synchro”和“Asynchro”在功能组件之间进行数据传输。一种称为“协议共振”的关键失效模式可能会发生，即当信号在一个反馈回路中被困住，并且在该回路中每一步的通信协议都严格交替时。\n\n给定一个芯片架构模型如下：\n- 一组 $n$ 个功能组件，由整数 $V = \\{0, 1, \\dots, n-1\\}$ 索引。\n- Synchro协议网络，建模为一个有向图 $G_S = (V, E_S)$，其中一条有向边 $(u, v) \\in E_S$ 表示组件 $u$ 可以使用Synchro协议向组件 $v$ 发送数据。\n- Asynchro协议网络，建模为一个有向图 $G_A = (V, E_A)$，其中一条边 $(u, v) \\in E_A$ 表示一个从 $u$到 $v$ 使用Asynchro协议的有效数据传输。\n\n“交替反馈回路”是指一个组件序列 $v_0, v_1, \\dots, v_k=v_0$（其中路径至少包含一条边），使得用于连接 $(v_0, v_1), (v_1, v_2), \\dots, (v_{k-1}, v_k)$ 的通信协议在Synchro和Asynchro之间严格交替。例如，如果 $(v_0, v_1)$ 是一个Synchro连接，那么 $(v_1, v_2)$ 必须是Asynchro，$(v_2, v_3)$ 必须是Synchro，依此类推，这个模式一直保持到闭合回路的最后一条边 $(v_{k-1}, v_k = v_0)$。\n\n给定一个具体的芯片设计，你的任务是确定至少属于一个此类交替反馈回路的独立功能组件的总数。\n\n**芯片规格：**\n- 组件数量，$n = 8$。\n- Synchro边集，$E_S = \\{(0, 1), (1, 2), (3, 4), (5, 6), (7, 0)\\}$。\n- Asynchro边集，$E_A = \\{(2, 3), (4, 5), (6, 7), (6, 1)\\}$。", "solution": "我们需要计算至少存在于一个有向环路中的顶点数量，该环路的边严格在来自 $E_S$ 的Synchro边和来自 $E_A$ 的Asynchro边之间交替。一个交替环路的长度必须是偶数，这样交替模式才能在整个环路中保持一致。\n\n我们通过追踪在每一步都必须交替类型的边来枚举所有可能的交替环路。\n\n首先，检查以Synchro边开始的环路：\n- 从 $(0,1) \\in E_S$ 出发：下一条边必须是从 $1$ 出发的Asynchro边。不存在 $(1, \\cdot) \\in E_A$，因此没有环路产生。\n- 从 $(1,2) \\in E_S$ 出发：接下来的边由交替规则决定：\n$$1 \\to 2 \\text{ (S) },\\quad 2 \\to 3 \\text{ (A) },\\quad 3 \\to 4 \\text{ (S) },\\quad 4 \\to 5 \\text{ (A) },\\quad 5 \\to 6 \\text{ (S) },\\quad 6 \\to 1 \\text{ (A) },$$\n这形成了一个穿过顶点 $\\{1,2,3,4,5,6\\}$ 的有向交替环路。\n- 从 $(3,4) \\in E_S$ 和 $(5,6) \\in E_S$ 出发：同样的强制交替规则会导向与上面相同的环路 $\\{1,2,3,4,5,6\\}$。\n- 从 $(7,0) \\in E_S$ 出发：下一条边必须是从 $0$ 出发的Asynchro边，但是不存在 $(0,\\cdot) \\in E_A$，因此没有环路产生。\n\n接下来，检查以Asynchro边开始的环路：\n- 从 $(2,3) \\in E_A$ 出发：交替规则强制：\n$$2 \\to 3 \\text{ (A) },\\quad 3 \\to 4 \\text{ (S) },\\quad 4 \\to 5 \\text{ (A) },\\quad 5 \\to 6 \\text{ (S) },\\quad 6 \\to 1 \\text{ (A) },\\quad 1 \\to 2 \\text{ (S) },$$\n这是同一个穿过顶点 $\\{1,2,3,4,5,6\\}$ 的交替环路。\n- 从 $(4,5) \\in E_A$ 和 $(6,1) \\in E_A$ 出发：根据相同的交替规则，我们得到相同的环路 $\\{1,2,3,4,5,6\\}$。\n- 从 $(6,7) \\in E_A$ 出发：交替规则强制通过Synchro连接 $7 \\to 0$，但接下来需要一条从 $0$ 出发的Asynchro边，而这样的边不存在，因此没有环路产生。\n\n最后，我们证明顶点 $0$ 和 $7$ 不能属于任何交替环路。要使 $0$ 处于一个交替环路中，当进入 $0$ 的前一条边是Synchro时，必须存在一条从 $0$ 出发的Asynchro边（或者如果出边是Synchro，则入边必须是Asynchro）。然而，既不存在 $(0,\\cdot) \\in E_A$ 也不存在 $(\\cdot,0) \\in E_A$。对于 $7$ 来说，唯一进入的边是Asynchro边 $(6,7)$，这强制下一条从 $7$ 出发的边必须是Synchro边 $(7,0)$，然后就需要一条从 $0$ 出发的Asynchro边，而这条边不存在。因此 $0$ 和 $7$ 都不能处于任何交替环路中。\n\n因此，唯一的交替环路是 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6 \\to 1$，至少属于一个交替反馈回路的顶点集合是 $\\{1,2,3,4,5,6\\}$。\n\n此类顶点的总数是 $6$。", "answer": "$$\\boxed{6}$$", "id": "1493919"}, {"introduction": "除了简单地判断是否存在循环，我们常常需要知道是否存在满足特定属性的循环。这个问题 [@problem_id:1493933] 要求找到一个边权重之积为 $-1$ 的循环。其精妙的解决方案在于扩展DFS的状态来追踪路径的奇偶性，这展示了如何通过改造算法，使其在遍历过程中收集更复杂的信息。", "problem": "考虑一个有向图 $G = (V, E)$，其中 $V$ 是顶点集合，大小为 $|V| = N$，$E$ 是边集合，大小为 $|E| = M$。每条边 $(u, v) \\in E$ 都被赋予一个权重 $w(u, v)$，其值来自集合 $\\{-1, 1\\}$。你的任务是设计一个算法，以确定图 $G$ 中是否存在至少一个简单环，其构成边的权重之积等于 $-1$。简单环是一条起点和终点相同，且不重复经过其他顶点的路径。\n\n对于能够正确解决任意一般有向图此问题的最高效算法，以下哪个选项代表了其最坏情况时间复杂度的最紧界？\n\nA. $O(N + M)$\n\nB. $O((N+M)\\log N)$\n\nC. $O(N \\cdot M)$\n\nD. $O(N^2)$\n\nE. 该问题是 NP-难的，意味着不存在已知的多项式时间算法。", "solution": "问题的核心是找到一个简单环，其边的权重之积为 $-1$。这等价于找到一个包含奇数条权重为 $-1$ 的边的简单环。这种重新表述将问题从乘积计算转换为了奇偶性检查。\n\n我们可以通过增强标准的图遍历算法（如深度优先搜索 (DFS)）来解决这个问题，使其能够追踪奇偶性信息。关键思想是，在有向图中，任何简单环都可以在 DFS 遍历过程中通过发现一条非树边（返祖边、前向边或交叉边）来识别，这条非树边与现有的树边构成一个闭环。\n\n让我们定义在 DFS 期间需要维护的状态。对于我们访问的每个顶点 `u`，我们将计算 `parity[u]`，它代表从当前 DFS 树的根到 `u` 的唯一路径上权重为 `-1` 的边的数量的奇偶性。我们可以将此奇偶性定义为：偶数次为 0，奇数次为 1。合并奇偶性的操作将是异或运算 (`\\oplus`)。\n\n算法流程如下：\n1.  为所有 $N$ 个顶点初始化一个 `color` 数组为 `WHITE`（未访问）。\n2.  为所有 $N$ 个顶点初始化一个 `parity` 数组。\n3.  遍历 $V$ 中的每个顶点 `v`。如果 `color[v]` 是 `WHITE`，则从 `v` 开始进行 DFS。对于这个新的 DFS 树，设置 `parity[v] = 0` 并调用 `DFS(v)`。\n\n递归函数 `DFS(u)` 的工作方式如下：\n1.  将 `color[u]` 设置为 `GRAY`（正在访问）。\n2.  对于 `u` 的每个通过边 $(u,v)$ 连接的邻居 `v`：\n    a. 如果 $w(u,v) = -1$，则令 `edge_parity` 为 1；如果 $w(u,v) = 1$，则为 0。\n    b. **情况 1：`v` 是 `WHITE`。** 这是一条树边。我们根据从根节点开始的路径更新 `v` 的奇偶性，该路径是到 `u` 路径的延伸。因此，`parity[v] = parity[u] \\oplus edge_parity`。然后，我们递归调用 `DFS(v)`。如果递归调用表明已找到目标环，我们将此信息向上传播。\n    c. **情况 2：`v` 不是 `WHITE`。** 这意味着 $(u,v)$ 是一条非树边（返祖边、前向边或交叉边）。这条边构成了一个简单环。该环由边 $(u,v)$ 和 DFS 树中将 `v` 连接回 `u` 的路径组成。连接 `v` 到 `u` 的树路径由从 `u` 和 `v` 的最近公共祖先 (LCA) 到 `u` 的路径，以及从 LCA 到 `v` 的路径组成。这条树路径上权重为 `-1` 的边的数量的奇偶性是 `parity[u] \\oplus parity[v]`。\n        - 为了理解原因，令 $P_r(x)$ 为从 DFS 根 `r`到顶点 `x` 的树路径的奇偶性。根据我们的定义，`parity[x] = P_r(x)`。\n        - 令 `lca = LCA(u,v)`。从 `r` 到 `u` 的树路径可以看作是从 `r` 到 `lca` 的路径，后接从 `lca` 到 `u` 的路径。因此，`parity[u] = P_r(lca) \\oplus P_{lca}(u)`。类似地，`parity[v] = P_r(lca) \\oplus P_{lca}(v)`。\n        - 对这两个方程进行异或运算，我们得到：`parity[u] \\oplus parity[v] = (P_r(lca) \\oplus P_{lca}(u)) \\oplus (P_r(lca) \\oplus P_{lca}(v)) = P_{lca}(u) \\oplus P_{lca}(v)`。这正是连接 `u` 和 `v` 的树路径上权重为 `-1` 的边的奇偶性。\n    d. 现在，我们可以计算由非树边 $(u,v)$ 构成的整个环的奇偶性。环的总奇偶性是树路径的奇偶性与边 $(u,v)$ 本身奇偶性的和（以异或运算计）。\n       `cycle_parity = (parity[u] \\oplus parity[v]) \\oplus edge_parity`。\n    e. 如果 `cycle_parity` 为 1，我们就找到了一个包含奇数条 `-1` 权重边的简单环。我们可以立即停止并报告存在这样的环。\n\n3.  访问完 `u` 的所有邻居后，将 `color[u]` 设置为 `BLACK`（已完成）。\n\n该算法本质上是对整个图进行一次 DFS 遍历。用于分类边的 `color` 数组和 `parity` 数组为每个顶点增加了常数级的存储空间。在每个顶点和每条边上的计算都是常数次操作（异或和比较）。因此，该算法的总时间复杂度受 DFS 的复杂度限制，即 $O(N + M)$。\n\n尽管许多涉及具有特定属性的“简单环”的问题是 NP-难的（这可能暗示选项 E），但由于奇偶性约束的性质，这个特定问题存在一个高效的多项式时间解法。最高效算法的最坏情况时间复杂度的最紧界是 $O(N + M)$。", "answer": "$$\\boxed{A}$$", "id": "1493933"}]}