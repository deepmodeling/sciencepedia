{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于亲身实践。此练习将带你深入 Bellman-Ford 算法的核心：迭代松弛过程。通过手动追踪算法最初几轮中每个顶点的距离更新，你将对算法如何逐步发现更短路径建立起直观而具体的认识。这项实践 [@problem_id:1482434] 是掌握算法运作机制的基础。", "problem": "在一个未来的研究项目中，科学家们正在研究一个由五个标记为 A、B、C、D 和 E 的时间节点组成的网络，这些节点通过有向的“时子链接”互连。每个链接 $(u, v)$ 都有一个关联的整数“时间偏移”值，代表从节点 $u$ 遍历到节点 $v$ 时所经历的时间扭曲。一些高级链接甚至允许负的时间偏移。\n\n该网络由一个顶点为 $V = \\{A, B, C, D, E\\}$ 的有向加权图表示。“时子链接”集合及其相应的时间偏移（权重）以元组 $(u, v, w)$ 的列表形式给出：\n$E = [(\\text{A}, \\text{B}, 6), (\\text{A}, \\text{C}, 7), (\\text{B}, \\text{D}, 5), (\\text{B}, \\text{E}, -4), (\\text{C}, \\text{B}, -2), (\\text{C}, \\text{D}, 8), (\\text{D}, \\text{E}, 9), (\\text{E}, \\text{A}, 2), (\\text{E}, \\text{C}, 7)]$\n\n为了计算从一个指定的源节点到所有其他节点的最小可能总时间偏移，科研团队采用了 Bellman-Ford 算法。源节点是 A。该算法将节点 A 的时间偏移估计值初始化为 0，并将所有其他节点的初始化为无穷大。然后，它迭代地对边进行松弛操作。在算法的每一遍中，边都严格按照它们在上面列表 $E$ 中出现的顺序进行松弛。\n\n在 Bellman-Ford 算法完成整整两遍之后，节点 $(\\text{A}, \\text{B}, \\text{C}, \\text{D}, \\text{E})$ 的时间偏移估计值的有序元组是什么？\n\nA. $(0, 5, 7, 10, 1)$\n\nB. $(0, 5, 7, 11, 2)$\n\nC. $(0, 6, 7, 11, 2)$\n\nD. $(0, 5, 7, 10, 2)$\n\nE. $(0, 4, 5, 10, 1)$", "solution": "我们从源点 A 开始应用 Bellman-Ford 算法，初始估计值为 $d = \\{\\text{A}:0, \\text{B}:\\infty, \\text{C}:\\infty, \\text{D}:\\infty, \\text{E}:\\infty\\}$。松弛规则是：对于每条边 $(u,v,w)$，如果 $d[u]+w  d[v]$，则更新 $d[v] = d[u]+w$。我们严格按照给定的顺序对边进行松弛。\n\n**第一遍：**\n1.  `(A, B, 6)`: $d(B) = \\min(\\infty, 0+6) = 6$\n2.  `(A, C, 7)`: $d(C) = \\min(\\infty, 0+7) = 7$\n3.  `(B, D, 5)`: $d(D) = \\min(\\infty, 6+5) = 11$\n4.  `(B, E, -4)`: $d(E) = \\min(\\infty, 6-4) = 2$\n5.  `(C, B, -2)`: $d(B) = \\min(6, 7-2) = 5$\n6.  `(C, D, 8)`: $d(D) = \\min(11, 7+8) = 11$ (无变化)\n7.  `(D, E, 9)`: $d(E) = \\min(2, 11+9) = 2$ (无变化)\n8.  `(E, A, 2)`: $d(A) = \\min(0, 2+2) = 0$ (无变化)\n9.  `(E, C, 7)`: $d(C) = \\min(7, 2+7) = 7$ (无变化)\n第一遍后，距离为 $d = (\\text{A}:0, \\text{B}:5, \\text{C}:7, \\text{D}:11, \\text{E}:2)$。\n\n**第二遍：**\n1.  `(A, B, 6)`: $d(B) = \\min(5, 0+6) = 5$ (无变化)\n2.  `(A, C, 7)`: $d(C) = \\min(7, 0+7) = 7$ (无变化)\n3.  `(B, D, 5)`: $d(D) = \\min(11, 5+5) = 10$\n4.  `(B, E, -4)`: $d(E) = \\min(2, 5-4) = 1$\n5.  `(C, B, -2)`: $d(B) = \\min(5, 7-2) = 5$ (无变化)\n6.  `(C, D, 8)`: $d(D) = \\min(10, 7+8) = 10$ (无变化)\n7.  `(D, E, 9)`: $d(E) = \\min(1, 10+9) = 1$ (无变化)\n8.  `(E, A, 2)`: $d(A) = \\min(0, 1+2) = 0$ (无变化)\n9.  `(E, C, 7)`: $d(C) = \\min(7, 1+7) = 7$ (无变化)\n第二遍后，最终距离为 $d = (\\text{A}:0, \\text{B}:5, \\text{C}:7, \\text{D}:10, \\text{E}:1)$。这对应于元组 $(0, 5, 7, 10, 1)$。", "answer": "$$\\boxed{A}$$", "id": "1482434"}, {"introduction": "Bellman-Ford 算法相较于 Dijkstra 算法的一个关键优势在于它能处理负权边。这个问题 [@problem_id:1482465] 让你像网络设计师一样思考。你需要调整网络，通过引入一个负权边来改变最短路径，同时必须确保网络稳定性，即避免产生负权环路。这个练习能让你深刻理解负权重的引入如何影响路径选择，以及负权环路检测的重要性。", "problem": "一位网络管理员正在分析一个小型数据路由网络。该网络拓扑表示为一个有向图，其中顶点是路由器，边权重表示延迟（时间延迟），单位为毫秒 (ms)。由于该网络的协议，路由决策总是旨在寻找从源 S 到目的地 T 总延迟最小的路径。\n\n当前的网络配置由以下顶点 {S, A, B, T} 及其连接和相关延迟定义：\n*   S 到 A：2 毫秒\n*   S 到 B：8 毫秒\n*   A 到 B：3 毫秒\n*   B 到 A：5 毫秒\n*   A 到 T：10 毫秒\n*   B 到 T：10 毫秒\n\n管理员正计划对从路由器 A 到路由器 B 的链路进行升级。这次升级将使其延迟减少一个正整数值 $\\Delta$ 毫秒。因此，A 到 B 链路的新延迟将为 $3 - \\Delta$ 毫秒。请注意，此次升级可能会导致负延迟，这代表了预测性数据转发给予该链路“时间信用”的情景。\n\n管理员需要确定延迟减少量 $\\Delta$ 的最大可能整数值，该值需同时满足两个关键条件：\n1.  从源路由器 S 到目的路由器 T 的总体最短路径（总延迟最小的路径）必须与升级前的原始最短路径不同。\n2.  网络必须保持稳定，这意味着升级不得引入任何会导致总延迟无限减少的路由环路。用图论术语来说，不应产生负权重环路。\n\n延迟减少量 $\\Delta$ (单位为毫秒) 的最大可能整数值是多少？", "solution": "将网络建模为一个有向图，其边权重等于延迟。原始边权重为：$w(S,A)=2$, $w(S,B)=8$, $w(A,B)=3$, $w(B,A)=5$, $w(A,T)=10$, $w(B,T)=10$。升级后，$w(A,B)$ 变为 $3-\\Delta$，其中 $\\Delta$ 是一个正整数。\n\n首先，通过评估简单的 S–T 路径来确定原始最短 S–T 路径：\n$$\n\\begin{aligned}\nL(S\\to A\\to T)=2+10=12,\\\\\nL(S\\to B\\to T)=8+10=18,\\\\\nL(S\\to A\\to B\\to T)=2+3+10=15,\\\\\nL(S\\to B\\to A\\to T)=8+5+10=23.\n\\end{aligned}\n$$\n最小值为 $12$，路径为 $S\\to A\\to T$，因此原始最短路径是 $S\\to A\\to T$。\n\n升级后，只有包含 $A\\to B$ 的路径会发生变化。相关的 S–T 路径长度作为 $\\Delta$ 的函数如下：\n$$\n\\begin{aligned}\nL_{1}(\\Delta)=L(S\\to A\\to T)=12,\\\\\nL_{2}(\\Delta)=L(S\\to B\\to T)=18,\\\\\nL_{3}(\\Delta)=L(S\\to A\\to B\\to T)=2+(3-\\Delta)+10=15-\\Delta,\\\\\nL_{4}(\\Delta)=L(S\\to B\\to A\\to T)=23.\n\\end{aligned}\n$$\n\n为避免负权重环路（稳定性），检查唯一涉及被修改边的有向环路，即 $A\\to B\\to A$，其总权重为\n$$\nw(A,B)+w(B,A)=(3-\\Delta)+5=8-\\Delta.\n$$\n无负权重环路的条件要求\n$$\n8-\\Delta\\geq 0\\quad\\Longleftrightarrow\\quad \\Delta\\leq 8.\n$$\n\n为确保总体最短 S–T 路径不再是原始的 $S\\to A\\to T$，我们必须使该路径不再是最短路径。由于 $L_{1}(\\Delta)=12$ 不变，只需另一条路径严格短于 $12$ 即可。唯一可能小于 $12$ 的候选路径是 $L_{3}(\\Delta)=15-\\Delta$，所以我们需要\n$$\n15-\\Delta  12\\quad\\Longleftrightarrow\\quad \\Delta>3.\n$$\n因为 $\\Delta$ 是一个正整数，结合稳定性约束 $\\Delta\\leq 8$，我们得到 $\\Delta\\in\\{4,5,6,7,8\\}$。\n\n在这些值中，$\\Delta$ 的最大可能整数值为 $\\Delta=8$。当 $\\Delta=8$ 时，环路 $A\\to B\\to A$ 的权重为零（非负），因此稳定性得以保持，并且最短路径长度变为 $L_{3}(8)=15-8=7  12$，该路径为 $S\\to A\\to B\\to T$，与原始的 $S\\to A\\to T$ 不同。\n\n因此，同时满足两个条件的最大整数减少量是 $8$。", "answer": "$$\\boxed{8}$$", "id": "1482465"}, {"introduction": "计算出最短路径的*长度*只是成功了一半，我们通常还需要知道这条路径本身。这个练习 [@problem_id:1482432] 将演示如何利用前驱数组这一 Bellman-Ford 算法的关键输出来实现路径重构。通过从目的地开始，沿着前驱指针反向回溯，你可以高效地重建构成最优路线的顶点序列。", "problem": "一位网络管理员正在分析一个小型有向计算机网络，以寻找从源服务器S出发的最有效路由路径。该网络由四个节点组成：S（源）、A、B和T（目标）。节点之间的链接具有相关的成本，该成本可以为正（表示延迟）或为负（表示处理加速或优化链接）。\n\n该网络由以下有向边及其对应的成本定义：\n- S到A：成本4\n- S到B：成本2\n- S到T：成本7\n- A到B：成本-3\n- A到T：成本6\n- B到T：成本4\n\n管理员以S为源顶点运行Bellman-Ford算法，以找到到所有其他节点的最短路径。算法完成后，计算出的最终最短路径距离估计值（D）和前驱顶点（P）如下：\n\n| 顶点 `v` | 距离 `D[v]` | 前驱 `P[v]` |\n|:----------:|:----------------:|:------------------:|\n|      S     |         0        |        空         |\n|      A     |         4        |         S          |\n|      B     |         1        |         A          |\n|      T     |         5        |         B          |\n\n根据Bellman-Ford算法的这个最终输出，从源S到目标T的最短路径是什么？\n\nA. S → T\n\nB. S → B → T\n\nC. S → A → T\n\nD. S → A → B → T\n\nE. 无法根据所提供的信息确定路径。", "solution": "我们使用Bellman-Ford算法的路径重构属性：在收敛后，前驱映射$P$定义了一个以源$S$为根的最短路径树。具体来说，对于任何前驱为$P[v]=u$的顶点$v \\neq S$，最终的距离满足\n$$\nD[v] = D[u] + w(u,v),\n$$\n并且在前驱图中从$S$到$v$的唯一路径是一条总成本为$D[v]$的最短路径。\n\n为了得到从$S$到$T$的最短路径，我们从$T$开始回溯前驱：\n- $P[T] = B$ 意味着最短$S \\to T$路径上的最后一条边是$B \\to T$。\n- $P[B] = A$ 意味着前一条边是$A \\to B$。\n- $P[A] = S$ 意味着第一条边是$S \\to A$。\n- $P[S] = \\text{空}$ 表示我们已经到达了源头。\n\n因此，从前驱链重构出的路径是$S \\to A \\to B \\to T$。根据Bellman-Ford的正确性条件，\n$$\nD[T] = D[B] + w(B,T) = D[A] + w(A,B) + w(B,T) = D[S] + w(S,A) + w(A,B) + w(B,T),\n$$\n所以这条由前驱定义的路径是从$S$到$T$的最短路径。\n\n与选项匹配，这正是选项D。", "answer": "$$\\boxed{D}$$", "id": "1482432"}]}