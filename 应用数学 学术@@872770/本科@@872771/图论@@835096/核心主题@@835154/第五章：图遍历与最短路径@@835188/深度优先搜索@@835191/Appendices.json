{"hands_on_practices": [{"introduction": "理解深度优先搜索的第一步是追踪它在图中的访问路径。第一个练习 [@problem_id:1362166] 要求你手动执行一次递归 DFS，并记录下每个顶点的发现时间和完成时间。这个过程不仅能阐明遍历的“深度优先”特性，还能让你熟悉时间戳方案，这是许多高级 DFS 应用（如环检测和拓扑排序）的基础。", "problem": "一个软件构建系统使用“依赖解析协议”来确定编译一组相互关联的代码模块的正确顺序。该协议在一个由模块及其依赖关系组成的图上运行。此过程涉及为每个模块分配两个时间戳：“发现时间”和“完成时间”。\n\n协议如下：\n1.  一个全局时间戳计数器初始化为1。\n2.  该过程从一个起始模块开始。如果未指定起始模块，则从按字母顺序排在最前面的模块开始。\n3.  当一个模块首次被访问时，它被标记为“已发现”，其发现时间被设置为全局时间戳的当前值，然后时间戳加1。\n4.  系统接着检查刚发现的模块的邻居。它会按照字母顺序，对找到的第一个未访问的邻居递归调用该协议。\n5.  在对一个模块的所有邻居的递归调用都返回后，该模块被标记为“已完成”，其完成时间被设置为全局时间戳的当前值，然后时间戳加1。之后，过程返回到其被调用的地方。\n6.  如果初始遍历完成但仍有未访问的模块，则从按字母顺序排在最前面的未访问模块开始重复该过程。\n\n考虑一个有八个模块的项目：A, B, C, D, E, F, G, H。依赖关系是对称的（即，如果 X 依赖于 Y，那么 Y 也依赖于 X），定义如下：\n-   模块 A 与 B, D, E 相连。\n-   模块 B 与 A, C 相连。\n-   模块 C 与 B, G, H 相连。\n-   模块 D 与 A, F 相连。\n-   模块 E 与 A, F 相连。\n-   模块 F 与 D, E, G 相连。\n-   模块 G 与 C, F 相连。\n-   模块 H 与 C 相连。\n\n从模块 A 开始执行该协议，确定所有八个模块的发现时间和完成时间。以下哪个选项正确列出了所有模块的 `(发现时间, 完成时间)` 对，并按从 A 到 H 的字母顺序列出？\n\nA. A:(1,16), B:(8,9), C:(7,12), D:(2,15), E:(4,5), F:(3,14), G:(6,13), H:(10,11)\n\nB. A:(1, 16), B:(2, 15), C:(3, 14), D:(8, 9), E:(6, 7), F:(5, 10), G:(4, 11), H:(12, 13)\n\nC. A:(1, 16), B:(2, 15), C:(3, 14), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(12, 13)\n\nD. A:(1, 16), B:(2, 15), C:(3, 12), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(13, 14)", "solution": "我们执行一次深度优先遍历，全局时间戳 $t$ 初始化为 $1$，从 $A$ 开始，并按字母顺序探索邻居。首次访问节点 $v$ 时，设置其发现时间 $d(v)=t$ 并将 $t$ 增加 $1$。在对 $v$ 的邻居的所有递归调用返回后，设置其完成时间 $f(v)=t$ 并将 $t$ 增加 $1$。\n\n初始化 $t=1$。\n\n从 $A$ 开始，其邻居顺序为 $B,D,E$。\n$$d(A)=1,\\quad t=2$$\n转到 $B$（$A$ 的第一个未访问邻居）。$B$ 的邻居顺序为 $A,C$。\n$$d(B)=2,\\quad t=3$$\n$A$ 已被访问；转到 $C$。$C$ 的邻居顺序为 $B,G,H$。\n$$d(C)=3,\\quad t=4$$\n$B$ 已被访问；转到 $G$。$G$ 的邻居顺序为 $C,F$。\n$$d(G)=4,\\quad t=5$$\n$C$ 已被访问；转到 $F$。$F$ 的邻居顺序为 $D,E,G$。\n$$d(F)=5,\\quad t=6$$\n转到 $D$（第一个未访问的）。$D$ 的邻居顺序为 $A,F$。\n$$d(D)=6,\\quad t=7$$\n$A$ 和 $F$ 都已被访问；完成 $D$：\n$$f(D)=7,\\quad t=8$$\n返回到 $F$；下一个邻居是 $E$（未访问）。\n$$d(E)=8,\\quad t=9$$\n$E$ 的邻居是 $A,F$，都已被访问；完成 $E$：\n$$f(E)=9,\\quad t=10$$\n回到 $F$；下一个邻居 $G$ 已被访问；完成 $F$：\n$$f(F)=10,\\quad t=11$$\n回到 $G$；没有更多邻居；完成 $G$：\n$$f(G)=11,\\quad t=12$$\n回到 $C$；下一个邻居是 $H$（未访问）。\n$$d(H)=12,\\quad t=13$$\n$H$ 的邻居 $C$ 已被访问；完成 $H$：\n$$f(H)=13,\\quad t=14$$\n回到 $C$；没有更多邻居；完成 $C$：\n$$f(C)=14,\\quad t=15$$\n回到 $B$；没有更多邻居；完成 $B$：\n$$f(B)=15,\\quad t=16$$\n回到 $A$；剩下的邻居 $D,E$ 已被访问；完成 $A$：\n$$f(A)=16,\\quad t=17$$\n\n因此，发现/完成时间为：\n- $A:(1,16)$\n- $B:(2,15)$\n- $C:(3,14)$\n- $D:(6,7)$\n- $E:(8,9)$\n- $F:(5,10)$\n- $G:(4,11)$\n- $H:(12,13)$\n\n这与选项 C 相符。", "answer": "$$\\boxed{C}$$", "id": "1362166"}, {"introduction": "虽然递归为我们概念化 DFS 提供了优雅的途径，但使用栈的迭代实现则揭示了其底层机制。在这个练习 [@problem_id:1496233] 中，你将模拟一次迭代 DFS，并小心地管理栈中的内容。这种动手实践有助于让你清晰地理解 DFS 是如何维持其路径和进行回溯的，为高效地实现该算法打下坚实的基础。", "problem": "考虑一个无向图 $G = (V, E)$，其顶点集定义为 $V = \\{0, 1, 2, 3, 4\\}$，边集 $E$ 构成一个轮图 $W_5$。在此图中，顶点 0 是中心顶点，与所有其他顶点相连。其余顶点 $\\{1, 2, 3, 4\\}$ 形成一个环，其中边连接 1 和 2、2 和 3、3 和 4，以及 4 回到 1。\n\n该图的邻接表定义如下，每个顶点的邻接顶点按数值升序排列：\n- `Adj(0): [1, 2, 3, 4]`\n- `Adj(1): [0, 2, 4]`\n- `Adj(2): [0, 1, 3]`\n- `Adj(3): [0, 2, 4]`\n- `Adj(4): [0, 1, 3]`\n\n你需要在该图上执行一次迭代深度优先搜索（DFS）。算法流程如下：\n1. 初始化一个空栈和一个空已访问顶点集合。\n2. 将起始顶点推入栈中。\n3. 当栈不为空时，弹出一个顶点 `u`。\n4. 如果 `u` 已被访问，则不执行任何操作，继续下一次迭代。\n5. 如果 `u` 未被访问，则将其标记为已访问。然后，对于 `u` 的每个邻接顶点 `v`（从邻接表中获取），如果 `v` 未被访问，则将 `v` 推入栈中。\n6. `u` 的邻接顶点按其顶点标号的**降序**推入栈中。\n\nDFS 遍历从顶点 0 开始。你的任务是确定在顶点 2 从栈中弹出后，栈中（从栈顶到栈底）的内容。\n\n以下哪个列表表示那一刻栈的内容？\n\nA. `[4, 2, 3, 4]`\n\nB. `[3, 4]`\n\nC. `[2, 4, 2, 3, 4]`\n\nD. `[1, 3, 2, 1]`\n\nE. `[2, 3, 4]`", "solution": "我们按照问题描述的算法逐步追踪栈的状态。我们约定栈顶在列表的最左边。\n1.  **初始状态**：栈为 `[0]`，已访问集合为空。\n2.  **弹出 0**：标记 0 为已访问。按降序将邻居 4, 3, 2, 1 推入栈中。栈变为 `[1, 2, 3, 4]`。\n3.  **弹出 1**：标记 1 为已访问。1 的邻居按降序为 4, 2, 0。0 已访问。4 和 2 未访问，因此先推入 4，再推入 2。栈在推入 4 和 2 后变为 `[2, 4, 2, 3, 4]`。\n4.  **弹出 2**：此时栈顶为 2，我们将其弹出。问题要求的是在这次弹出操作 *之后* 的栈内容。\n5.  **最终栈状态**：弹出 2 后，栈的内容从栈顶到栈底为 `[4, 2, 3, 4]`。\n\n这与选项 A 相符。", "answer": "$$\\boxed{A}$$", "id": "1496233"}, {"introduction": "DFS 所走的路径并非随意，它会产生一个被称为 DFS 树的特定结构。最后一个练习 [@problem_id:1496226] 旨在挑战你思考起点和邻接点选择规则如何显著改变这棵树的形态。通过分析环图上 DFS 树的高度，你将更深刻地体会到算法执行过程与图结构属性之间的关系。", "problem": "考虑一个无向循环图，记为 $C_{10}$，其顶点集为 $V = \\{v_1, v_2, \\dots, v_{10}\\}$。该图的边循环连接顶点，即边集为 $E = \\{(v_i, v_{i+1}) \\mid i = 1, \\dots, 9\\} \\cup \\{(v_{10}, v_1)\\}$。\n\n将对此图执行深度优先搜索 (DFS)。在搜索过程中，当一个顶点有多个未访问的邻居时，将按顶点索引递增的顺序访问这些邻居。例如，如果从一个未访问的邻居为 $v_2$ 和 $v_8$ 的顶点开始探索，DFS 将首先访问 $v_2$。\n\n有根树的高度定义为从根到叶节点的最长向下路径上的边数。\n\n我们将考虑 DFS 遍历的两种不同情况：\n1.  DFS 从顶点 $v_1$ 开始。设得到的 DFS 树的高度为 $H_1$。\n2.  DFS 从顶点 $v_2$ 开始。设得到的 DFS 树的高度为 $H_2$。\n\n确定 $H_1$ 和 $H_2$ 的值。请以有序对 $(H_1, H_2)$ 的形式报告你的答案。", "solution": "设无向循环图为 $C_{10}$，其顶点集为 $V=\\{v_{1},v_{2},\\dots,v_{10}\\}$，边集为 $E=\\{(v_{i},v_{i+1})\\mid i=1,\\dots,9\\}\\cup\\{(v_{10},v_{1})\\}$。对于每个 $v_{i}$，其邻居为 $N(v_{i})=\\{v_{i-1},v_{i+1}\\}$，其中索引按模 $10$ 解释，因此 $v_{0}=v_{10}$ 且 $v_{11}=v_{1}$。DFS 的规则是：在任何一步，当前顶点的未访问邻居中，按索引递增的顺序访问。\n\n情况 1：从 $v_{1}$ 开始。在 $v_{1}$ 处，未访问的邻居是 $\\{v_{2},v_{10}\\}$，因此 DFS 首先选择 $v_{2}$。对于 $k=2,\\dots,9$，在 $v_{k}$ 处的邻居是 $\\{v_{k-1},v_{k+1}\\}$；父节点 $v_{k-1}$ 已被访问，因此唯一的未访问邻居是 $v_{k+1}$，接着访问它。到达 $v_{10}$ 时，其邻居 $v_{9}$ 和 $v_{1}$ 都已被访问，因此 DFS 回溯，不添加新的树边。因此，DFS 树由路径\n$$v_{1}-v_{2}-v_{3}-\\cdots -v_{10},$$\n构成，从根 $v_{1}$ 到叶 $v_{10}$ 有 $9$ 条边。因此 $H_{1}=9$。\n\n情况 2：从 $v_{2}$ 开始。在 $v_{2}$ 处，未访问的邻居是 $\\{v_{1},v_{3}\\}$，因此 DFS 首先选择 $v_{1}$。在 $v_{1}$ 处，索引最小的未访问邻居是 $v_{10}$（因为 $v_{2}$ 已被访问），因此 DFS 继续访问 $v_{10}$。继续下去，从 $v_{10}$ 到 $v_{4}$ 的每一步，唯一的未访问邻居是下一个索引更小的邻居，从而产生序列\n$$v_{2}-v_{1}-v_{10}-v_{9}-v_{8}-v_{7}-v_{6}-v_{5}-v_{4}-v_{3}.$$\n在 $v_{3}$ 处，两个邻居都已被访问，因此 DFS 回溯，当它返回到 $v_{2}$ 时，另一个邻居 $v_{3}$ 也已被访问。因此，DFS 树同样是一个以 $v_{2}$ 为根、包含所有 $10$ 个顶点的单一路径，其最长的根到叶路径（从 $v_{2}$ 到 $v_{3}$）有 $9$ 条边。因此 $H_{2}=9$。\n\n因此，$(H_{1},H_{2})=(9,9)$。", "answer": "$$\\boxed{\\begin{pmatrix} 9  9 \\end{pmatrix}}$$", "id": "1496226"}]}