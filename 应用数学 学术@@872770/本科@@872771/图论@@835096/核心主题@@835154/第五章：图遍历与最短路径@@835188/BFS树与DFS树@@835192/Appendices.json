{"hands_on_practices": [{"introduction": "我们从一个基本问题开始：广度优先搜索（BFS）逐层扩展的探索方式，与深度优先搜索（DFS）深入回溯的策略，在何种情况下会殊途同归？本练习将引导你寻找一种特定的图结构，在该结构上，从同一顶点出发的 BFS 和 DFS 会生成完全相同的生成树[@problem_id:1483515]。通过这个过程，你将能更深刻地理解这两种核心图遍历算法的内在构建机制。", "problem": "考虑一个简单的无向连通图 $G=(V,E)$，其中 $V$ 是顶点集，$E$ 是边集。遍历此类图的两种标准算法是广度优先搜索 (BFS) 和深度优先搜索 (DFS)。从源顶点 $v_s$ 开始的遍历会生成该图连通分量的一棵生成树，根据所使用的算法，这棵树被称为 BFS 树或 DFS 树。\n\n这些树的结构取决于图的拓扑结构、起始顶点以及当一个顶点有多个未访问邻居时用于打破平局的规则。对于本问题，假设当有多个未访问的邻居可用时，算法总是优先访问整数标签最小的邻居。如果 BFS 树和 DFS 树以相同的顶点为根，并且具有完全相同的边集，则认为它们在结构上是相同的。\n\n下面选项中的所有图共享相同的顶点集 $V = \\{1, 2, 3, 4, 5\\}$。每个图的遍历都从源顶点 $v_s = 1$ 开始。\n\n在这些条件下，下列哪个图会生成结构上相同的 BFS 树和 DFS 树？\n\nA. 图 $G_A$，其边集为 $E_A = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}\\}$。\n\nB. 图 $G_B$，其边集为 $E_B = \\{\\{1,2\\}, \\{1,3\\}, \\{1,4\\}, \\{2,3\\}, \\{2,4\\}, \\{3,4\\}, \\{1,5\\}\\}$。\n\nC. 图 $G_C$，其边集为 $E_C = \\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}, \\{1,4\\}, \\{4,5\\}, \\{5,1\\}\\}$。\n\nD. 图 $G_D$，其边集为 $E_D = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,1\\}\\}$。", "solution": "我们分析在以 $1$ 为根并使用最小标签打破平局规则的情况下，BFS 和 DFS 生成树何时会产生相同的边集。BFS 使用队列逐层探索顶点，当从 $u$ 首次发现 $v$ 时添加树边 $(u,v)$；DFS 通过使用栈/递归总是前进到最小的未访问邻居来进行探索，当递归到一个未访问的邻居时添加树边。\n\n选项 A：$E_{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}$。这是一个路径 $1$–$2$–$3$–$4$–$5$。\n- 从 $1$ 开始进行 DFS：每一步都前进到最小的未访问邻居，产生路径 $1 \\to 2 \\to 3 \\to 4 \\to 5$。DFS 树的边是\n$$E_{T,\\mathrm{DFS}}^{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}.$$\n- 从 $1$ 开始进行 BFS：从 $1$ 发现 $2$，然后从 $2$ 发现 $3$，然后从 $3$ 发现 $4$，然后从 $4$ 发现 $5$。BFS 树的边是\n$$E_{T,\\mathrm{BFS}}^{A}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}.$$\n因此 $E_{T,\\mathrm{DFS}}^{A}=E_{T,\\mathrm{BFS}}^{A}$，所以它们是相同的。\n\n选项 B：$E_{B}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{2,3\\},\\{2,4\\},\\{3,4\\},\\{1,5\\}\\}$。这是在 $\\{1,2,3,4\\}$ 上的 $K_{4}$ 加上边 $\\{1,5\\}$。\n- 从 $1$ 开始进行 DFS：访问 $2$，然后是 $3$，然后是 $4$，回溯到 $1$，然后是 $5$。DFS 树的边是\n$$E_{T,\\mathrm{DFS}}^{B}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{1,5\\}\\}.$$\n- 从 $1$ 开始进行 BFS：按递增顺序发现 $1$ 的所有邻居：$2,3,4,5$。BFS 树的边是\n$$E_{T,\\mathrm{BFS}}^{B}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{1,5\\}\\}.$$\n这两个集合不同，所以它们不相同。\n\n选项 C：$E_{C}=\\{\\{1,2\\},\\{2,3\\},\\{3,1\\},\\{1,4\\},\\{4,5\\},\\{5,1\\}\\}$。这是两个共享顶点 $1$ 的三角形 $\\{1,2,3\\}$ 和 $\\{1,4,5\\}$。\n- 从 $1$ 开始进行 DFS：访问 $2$，然后是 $3$，回溯到 $1$，然后是 $4$，然后是 $5$。DFS 树的边是\n$$E_{T,\\mathrm{DFS}}^{C}=\\{\\{1,2\\},\\{2,3\\},\\{1,4\\},\\{4,5\\}\\}.$$\n- 从 $1$ 开始进行 BFS：从 $1$ 发现 $2,3,4,5$。BFS 树的边是\n$$E_{T,\\mathrm{BFS}}^{C}=\\{\\{1,2\\},\\{1,3\\},\\{1,4\\},\\{1,5\\}\\}.$$\n这两个集合不同，所以它们不相同。\n\n选项 D：$E_{D}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,1\\}\\}$，一个 5-环。\n- 从 $1$ 开始进行 DFS：访问路径为 $1 \\to 2 \\to 3 \\to 4 \\to 5$。DFS 树的边是\n$$E_{T,\\mathrm{DFS}}^{D}=\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\}\\}.$$\n- 从 $1$ 开始进行 BFS：从 $1$ 发现 $2$ 和 $5$，然后从 $2$ 发现 $3$，从 $5$ 发现 $4$。BFS 树的边是\n$$E_{T,\\mathrm{BFS}}^{D}=\\{\\{1,2\\},\\{1,5\\},\\{2,3\\},\\{5,4\\}\\}.$$\n这两个集合不同，所以它们不相同。\n\n因此，在所述条件下，只有选项 A 能产生结构上相同的 BFS 和 DFS 树。", "answer": "$$\\boxed{A}$$", "id": "1483515"}, {"introduction": "了解了 BFS 和 DFS 生成树可能相同的情况后，我们来探索其行为的极端差异。这个实践将利用一种称为“轮图”的特殊图结构，来直观展示两种算法在树高上的巨大反差[@problem_id:1483546]。通过计算 BFS 树的高度 $H_{BFS}$ 和 DFS 树的高度 $H_{DFS}$，你将清晰地看到 BFS 的“广度”优先如何产生矮树，而 DFS 的“深度”优先如何产生高树，从而加深对它们核心思想的理解。", "problem": "考虑一个由 $N$ 个顶点构成的简单、连通、无向图，称为轮图 (Wheel Graph)，记作 $W_N$。顶点被标记为 $v_0, v_1, \\dots, v_{N-1}$。顶点 $v_0$ 被称为“轴心”(hub)，并通过一条边连接到每个“轮缘”(rim)顶点 $v_i$ (其中 $i \\in \\{1, 2, \\dots, N-1\\}$)。轮缘顶点也相互连接形成一个环，其边为 $(v_i, v_{i+1})$ (其中 $i=1, \\dots, N-2$) 和一条边 $(v_{N-1}, v_1)$。\n\n我们从轴心顶点 $v_0$ 开始，执行两种独立的图遍历：广度优先搜索 (Breadth-First Search, BFS) 和深度优先搜索 (Depth-First Search, DFS)。这些遍历分别生成一个 BFS 树和一个 DFS 树，它们都是以 $v_0$ 为根的 $W_N$ 的生成树。对于这两种算法，如果一个顶点有多个未访问的邻居可供选择，算法必须总是首先探索顶点索引最小的那个邻居。\n\n有根树的高度定义为从根到任意叶节点的最长路径上的边数。设 $H_{BFS}$ 为 BFS 树的高度，$H_{DFS}$ 为 DFS 树的高度。\n\n对于一个有 $N=50$ 个顶点的轮图，计算差值 $H_{DFS} - H_{BFS}$ 的值。", "solution": "我们分析以轴心 $v_{0}$ 为根的轮图 $W_{N}$ 的 BFS 和 DFS 生成树，遵循当存在多个未访问邻居时选择索引最小的顶点的规则。\n\n根据定义，$v_{0}$ 与每个轮缘顶点 $v_{i}$ ($i \\in \\{1,\\dots,N-1\\}$) 相邻，并且轮缘通过边 $(v_{i},v_{i+1})$ (其中 $i=1,\\dots,N-2$) 和 $(v_{N-1},v_{1})$ 形成一个环。\n\n首先，考虑以 $v_{0}$ 为根的 BFS 树。在开始时，BFS 发现 $v_{0}$ 的所有邻居，即 $v_{1},v_{2},\\dots,v_{N-1}$，并将它们置于距离 $v_{0}$ 为 1 的位置。当之后处理每个 $v_{i}$ 时，它的所有邻居都已被发现：$v_{0}$ 是根节点，而每个轮缘邻居 $v_{i-1}$ 或 $v_{i+1}$ 也已从 $v_{0}$ 被发现。因此，没有顶点会出现在超过 1 的层级。所以 BFS 树是一个以 $v_{0}$ 为中心的星形图，其高度为\n$$\nH_{BFS}=1.\n$$\n\n接下来，考虑在最小索引规则下以 $v_{0}$ 为根的 DFS 树。从 $v_{0}$ 出发，索引最小的邻居是 $v_{1}$，所以第一条 DFS 边是 $(v_{0},v_{1})$。在 $v_{1}$ 处，其邻居为 $\\{v_{0},v_{2},v_{N-1}\\}$；排除已访问的 $v_{0}$，最小的未访问邻居是 $v_{2}$，所以下一条边是 $(v_{1},v_{2})$。归纳地，对于 $k=2,\\dots,N-2$，在 $v_{k}$ 处，其邻居 $\\{v_{0},v_{k-1},v_{k+1}\\}$ 中的未访问邻居在最小索引规则下只剩下 $\\{v_{k+1}\\}$（因为 $v_{0}$ 和 $v_{k-1}$ 已被访问），DFS 沿着 $(v_{k},v_{k+1})$ 继续进行。在 $v_{N-1}$ 处，所有邻居 $v_{0},v_{N-2},v_{1}$ 都已被访问，所以 DFS 一路回溯到 $v_{0}$，此时所有顶点均已被访问。因此，DFS 树的边构成了路径\n$$\n(v_{0},v_{1}),(v_{1},v_{2}),\\dots,(v_{N-2},v_{N-1}),\n$$\n这条路径从 $v_{0}$ 到 $v_{N-1}$ 共有 $N-1$ 条边。因此，DFS 树是一条以一端为根、长度为 $N-1$ 的路径，其高度为\n$$\nH_{DFS}=N-1.\n$$\n\n对于 $N=50$，我们有\n$$\nH_{DFS}-H_{BFS}=(50-1)-1=48.\n$$", "answer": "$$\\boxed{48}$$", "id": "1483546"}, {"introduction": "深度优先搜索（DFS）的威力远不止于遍历图，它还是一个分析图属性的强大工具，尤其是在有向图中。本练习将带你实践一个高级应用：根据 DFS 遍历过程对边进行分类[@problem_id:1483505]。通过识别树边、后向边、前向边和交叉边，你将学会如何揭示有向图的潜在结构，例如环路的存在以及不同子树之间的关系。", "problem": "考虑一个有向图 $G = (V, E)$，其顶点集为 $V = \\{s, a, b, c, d\\}$，边集为 $E = \\{(s, a), (s, c), (a, b), (c, d), (d, b)\\}$。\n\n从顶点 $s$ 开始，对该图执行深度优先搜索（DFS）。该算法遵循一个标准约定：当一个顶点有多个未访问的邻居时，按字母顺序选择访问它们。\n\n在有向图的DFS中，根据生成的DFS树/森林中边 $(u, v)$ 的源顶点 $u$ 和目标顶点 $v$ 之间的关系，边被分为四种类型：\n1.  **树边 (Tree edge)**：通过遍历 $(u, v)$ 第一次发现顶点 $v$ 时的边。\n2.  **返祖边 (Back edge)**：边 $(u,v)$ 中的 $v$ 是 $u$ 的祖先。\n3.  **前向边 (Forward edge)**：非树边，其中 $v$ 是 $u$ 的后代。\n4.  **横叉边 (Cross edge)**：既不是树边、返祖边，也不是前向边的边。这种边通常连接两个不同的子树，其中 $v$ 已经被完全探索（即它的发现时间和完成时间都在 $u$ 被发现之前）。\n\n根据指定的DFS遍历，下列哪条边是横叉边？\n\nA. (s, c)\n\nB. (a, b)\n\nC. (d, b)\n\nD. (c, d)", "solution": "为了确定每条边的类型，我们必须从顶点 $s$ 开始，对图 $G$ 执行深度优先搜索（DFS），并遵循按字母顺序访问未访问邻居的规则。我们将记录每个顶点的发现时间（第一次访问顶点时）和完成时间（其所有后代都已被访问完毕时）。我们将发现时间记为 $d[v]$，完成时间记为 $f[v]$，并维护一个全局计时器 `time`。\n\n**DFS遍历步骤：**\n\n1.  **从 `s` 开始**：`time` = 1。$d[s]$ = 1。`s` 的邻居是 `a` 和 `c`。按字母顺序，我们首先访问 `a`。探索边 `(s, a)`。\n2.  **移动到 `a`**：`time` = 2。$d[a]$ = 2。顶点 `a` 未被访问过，所以 `(s, a)` 是一条**树边**。`a` 的邻居是 `b`。我们访问 `b`。探索边 `(a, b)`。\n3.  **移动到 `b`**：`time` = 3。$d[b]$ = 3。顶点 `b` 未被访问过，所以 `(a, b)` 是一条**树边**。顶点 `b` 没有出边。我们完成了从 `b` 开始的探索。\n4.  **完成 `b`**：`time` = 4。$f[b]$ = 4。回溯到 `a`。\n5.  **返回 `a`**：顶点 `a` 没有其他未访问的邻居。我们完成了从 `a` 开始的探索。\n6.  **完成 `a`**：`time` = 5。$f[a]$ = 5。回溯到 `s`。\n7.  **返回 `s`**：`s` 的下一个未访问的邻居是 `c`。我们访问 `c`。探索边 `(s, c)`。\n8.  **移动到 `c`**：`time` = 6。$d[c]$ = 6。顶点 `c` 未被访问过，所以 `(s, c)` 是一条**树边**。`c` 的邻居是 `d`。我们访问 `d`。探索边 `(c, d)`。\n9.  **移动到 `d`**：`time` = 7。$d[d]$ = 7。顶点 `d` 未被访问过，所以 `(c, d)` 是一条**树边**。`d` 的邻居是 `b`。我们探索边 `(d, b)`。\n10. **分析边 `(d, b)`**：目标顶点 `b` 已经被访问过。我们必须对这条边进行分类。我们比较 `b` 的发现时间和完成时间与 `d` 的发现时间。\n    - $d[b]$ = 3\n    - $f[b]$ = 4\n    - $d[d]$ = 7\n    横叉边 $(u, v)$ 的条件是 $d[v]  f[v]  d[u]$。对于我们的边 $(d, b)$，这对应于 $d[b]  f[b]  d[d]$。代入数值，我们得到 $3  4  7$，这是成立的。因此，`(d, b)` 是一条**横叉边**。\n11. **返回 `d`**：顶点 `d` 没有其他邻居。我们完成了从 `d` 开始的探索。\n12. **完成 `d`**：`time` = 8。$f[d]$ = 8。回溯到 `c`。\n13. **返回 `c`**：顶点 `c` 没有其他未访问的邻居。我们完成了从 `c` 开始的探索。\n14. **完成 `c`**：`time` = 9。$f[c]$ = 9。回溯到 `s`。\n15. **返回 `s`**：顶点 `s` 没有其他未访问的邻居。我们完成了从 `s` 开始的探索。\n16. **完成 `s`**：`time` = 10。$f[s]$ = 10。DFS 完成。\n\n**发现/完成时间总结：**\n- `s`: d=1, f=10\n- `a`: d=2, f=5\n- `b`: d=3, f=4\n- `c`: d=6, f=9\n- `d`: d=7, f=8\n\n**分析选项：**\n\n-   **A. (s, c)**：当从 `s` 探索这条边时，`c` 尚未被访问。这是一条**树边**。\n-   **B. (a, b)**：当从 `a` 探索这条边时，`b` 尚未被访问。这是一条**树边**。\n-   **C. (d, b)**：当从 `d` 探索这条边时，`b` 已经被访问并完成（$d[b]=3, f[b]=4$）。由于 $d[b]  f[b]  d[d]$，这是一条**横叉边**。\n-   **D. (c, d)**：当从 `c` 探索这条边时，`d` 尚未被访问。这是一条**树边**。\n\n因此，选项中唯一的横叉边是 `(d, b)`。", "answer": "$$\\boxed{C}$$", "id": "1483505"}]}