{"hands_on_practices": [{"introduction": "拓扑排序的核心是为一系列具有依赖关系的任务找到一个可行的线性序列。在学习如何生成一个有效的序列之前，一个基本技能是验证一个给定的序列是否满足所有的依赖约束。这个练习通过一个常见的软件模块编译场景，让你直接实践拓扑排序的核心定义：对于每一个“任务U必须在任务V之前”的依赖关系，检查在给定的序列中U是否确实排在V的前面。[@problem_id:1549706]", "problem": "一个软件项目被分为七个不同的模块：Setup (S)、Core (C)、User Interface (UI)、Networking (N)、Database (D)、Analytics (A) 和 Logging (L)。由于编译依赖关系，一些模块必须在其他模块之前编译。直接依赖关系的完整集合如下所示：\n- `Core` 模块依赖于 `Setup` 模块。\n- `UI` 模块依赖于 `Core` 模块。\n- `Networking` 模块依赖于 `Core` 模块。\n- `Database` 模块同时依赖于 `UI` 和 `Networking` 模块。\n- `Analytics` 模块依赖于 `Networking` 模块。\n- `Logging` 模块同时依赖于 `Database` 和 `Analytics` 模块。\n\n一个构建序列是所有七个模块的线性排序。一个构建序列被认为是有效的，当且仅当对于每一个依赖关系，被依赖的模块都出现在依赖它的模块之前。\n\n你的任务是确定以下提出的构建序列中哪些是有效的。\n\nA. `Setup, Core, UI, Networking, Analytics, Database, Logging`\nB. `Setup, Core, Database, UI, Networking, Analytics, Logging`\nC. `Setup, Core, Networking, UI, Analytics, Database, Logging`\nD. `Setup, Core, UI, Networking, Logging, Database, Analytics`\nE. `Setup, Networking, Core, UI, Analytics, Database, Logging`", "solution": "为了验证一个序列是否是有效的拓扑排序，我们必须检查每一条依赖关系。对于每个“U 依赖于 V”的约束，U 必须出现在 V 之前。\n依赖关系可以表示为：S → C, C → UI, C → N, UI → D, N → D, N → A, D → L, A → L。\n\n让我们逐个检查每个选项：\n\n- **A. `Setup, Core, UI, Networking, Analytics, Database, Logging`**:\n  - S 在 C 之前 (✓)\n  - C 在 UI 和 N 之前 (✓)\n  - UI 在 D 之前 (✓)\n  - N 在 A 和 D 之前 (✓)\n  - A 在 L 之前 (✓)\n  - D 在 L 之前 (✓)\n  - **所有约束均满足。此序列有效。**\n\n- **B. `Setup, Core, Database, UI, Networking, Analytics, Logging`**:\n  - 违反了 `UI → D` 的约束，因为 D 出现在 UI 之前。\n  - **此序列无效。**\n\n- **C. `Setup, Core, Networking, UI, Analytics, Database, Logging`**:\n  - S 在 C 之前 (✓)\n  - C 在 N 和 UI 之前 (✓)\n  - N 在 A 和 D 之前 (✓)\n  - UI 在 D 之前 (✓)\n  - A 在 L 之前 (✓)\n  - D 在 L 之前 (✓)\n  - **所有约束均满足。此序列有效。**\n\n- **D. `Setup, Core, UI, Networking, Logging, Database, Analytics`**:\n  - 违反了 `D → L` 的约束，因为 L 出现在 D 之前。\n  - **此序列无效。**\n\n- **E. `Setup, Networking, Core, UI, Analytics, Database, Logging`**:\n  - 违反了 `S → C` 的约束，因为 C 没有出现在 S 之后。\n  - **此序列无效。**\n\n因此，只有序列 A 和 C 是有效的。", "answer": "$$\\boxed{AC}$$", "id": "1549706"}, {"introduction": "在许多实际应用中，一个依赖关系图可能存在多个有效的拓扑排序。当面临多种选择时，我们往往需要一个明确的标准来确定唯一的执行顺序，例如选择“字典序最小”的序列。这个练习将引导你运用一种系统性的方法（如Kahn算法的变体），在每一步都从所有可执行的任务中选择字母顺序最靠前的那个，从而构建出符合特定要求的拓扑排序。[@problem_id:1549700]", "problem": "一个项目经理正在为一个新的数据分析环境规划任务的执行顺序。为确保安装顺利，某些任务必须在其他任务之前完成。团队希望遵循一个字典序最小的执行计划，这意味着在任何步骤，如果存在多个可以执行的任务，他们将选择按字母顺序排在最前面的那个。\n\n这些任务由一个大写字母标识：\n- (A) 安装 Pandas\n- (G) 安装 Git\n- (J) 安装 Jupyter Notebook\n- (M) 安装 Matplotlib\n- (N) 安装 NumPy\n- (P) 安装 Python\n- (S) 安装 Scikit-learn\n- (V) 设置虚拟环境\n\n前置约束如下：\n1.  安装 Python (P) 必须在设置虚拟环境 (V) 之前完成。\n2.  安装 Python (P) 必须在安装 Jupyter Notebook (J) 之前完成。\n3.  设置虚拟环境 (V) 必须在安装 NumPy (N) 之前完成。\n4.  设置虚拟环境 (V) 必须在安装 Pandas (A) 之前完成。\n5.  设置虚拟环境 (V) 必须在安装 Matplotlib (M) 之前完成。\n6.  安装 NumPy (N) 必须在安装 Scikit-learn (S) 之前完成。\n7.  安装 Pandas (A) 必须在安装 Scikit-learn (S) 之前完成。\n\n没有其他依赖关系。“安装 Git” (G) 没有任何前置任务，也不是任何其他任务的前置任务。\n\n以下哪个序列代表了正确的字典序最小的任务顺序？\n\nA. G, P, J, V, A, M, N, S\nB. P, G, J, V, N, A, S, M\nC. G, P, V, J, A, M, N, S\nD. P, G, V, A, N, S, J, M\nE. G, P, J, V, M, N, A, S", "solution": "我们将任务建模为一个有向无环图，并寻找字典序最小的拓扑排序。在每一步中，从所有没有未满足前置条件的任务中，我们选择字母顺序最早的那个。\n\n依赖关系：\n- P 在 V 和 J 之前。\n- V 在 N、A、M 之前。\n- N 和 A 都在 S 之前。\n- G 是独立的（没有前置任务，也不是其他任务的前置任务）。\n\n初始可用任务（无前置条件）：G 和 P。字典序最小的是 G，所以首先选择 G。\n完成 G 后，可用任务剩下 P。接着选择 P。\n完成 P 后，新可用的任务是 J 和 V（都需要 P）。字典序最小的是 J。接着选择 J。\n完成 J 后，可用任务包括 V。接着选择 V。\n完成 V 后，新可用的任务是 A、M、N（都需要 V）。字典序最小的是 A。接着选择 A。\n完成 A 后，可用任务是 M 和 N。字典序最小的是 M。接着选择 M。\n完成 M 后，可用任务是 N。接着选择 N。\n完成 N 后，由于 A 和 N 都已完成，S 变为可用。最后选择 S。\n\n这得出的序列是：G, P, J, V, A, M, N, S。检查约束条件：\n- P 在 V 和 J 之前：满足。\n- V 在 N、A、M 之前：满足。\n- N 在 S 之前且 A 在 S 之前：满足。\n- G 无约束：放在开头是有效的。\n该序列与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1549700"}, {"introduction": "在掌握了如何构建单个拓扑排序之后，我们可以进一步探索所有可能排序的共性。一个有向无环图的所有拓扑排序序列中，哪些顶点可以作为起点，哪些又可以作为终点呢？这个问题将帮助你揭示图的结构（特别是没有前驱的“源”顶点和没有后继的“汇”顶点）与所有可能拓扑排序的边界之间的深刻联系。[@problem_id:1549724]", "problem": "考虑一个有向无环图 (DAG)，其顶点集为 $V = \\{A, B, C, D, E, F, G, H\\}$，有向边集为 $E = \\{(A, B), (A, C), (B, D), (C, D), (D, F), (E, C), (E, G), (G, H)\\}$。一个有向无环图的拓扑排序是其顶点的一种线性排序，使得对于每条从顶点 $u$ 到顶点 $v$ 的有向边，顶点 $u$ 在排序中都出现在顶点 $v$ 之前。\n\n令 $S_{first}$ 为所有可以在给定图的至少一个有效拓扑排序中排在第一位的顶点的集合。令 $S_{last}$ 为所有可以在至少一个有效拓扑排序中排在最后一位的顶点的集合。\n\n从以下选项中确定 $S_{first}$ 和 $S_{last}$ 的正确集合。\n\nA. $S_{first} = \\{A, E\\}$ 和 $S_{last} = \\{F, H\\}$\nB. $S_{first} = \\{A\\}$ 和 $S_{last} = \\{H\\}$\nC. $S_{first} = \\{A, E\\}$ 和 $S_{last} = \\{D, F, H\\}$\nD. $S_{first} = \\{E\\}$ 和 $S_{last} = \\{F\\}$\nE. $S_{first} = \\{A, B, E\\}$ 和 $S_{last} = \\{D, F, H\\}$", "solution": "拓扑排序是与所有有向边一致的线性排序。这里使用了两个基本性质：\n1) 在任何拓扑排序中，第一个顶点必须是源点，即没有入边的顶点。形式上，如果一个顶点 $v$ 出现在第一位，并且存在一条边 $(u,v)$，那么 $u$ 必须排在 $v$ 之前，这是不可能的。因此，只有入度为 $\\deg^{-}(v)=0$ 的顶点才能排在第一位。\n2) 在任何拓扑排序中，最后一个顶点必须是汇点，即没有出边的顶点。如果一个顶点 $v$ 出现在最后一位，并且存在一条边 $(v,w)$，那么 $v$ 必须排在 $w$ 之前，这是不可能的。因此，只有出度为 $\\deg^{+}(v)=0$ 的顶点才能排在最后一位。\n\n使用 $E=\\{(A,B),(A,C),(B,D),(C,D),(D,F),(E,C),(E,G),(G,H)\\}$ 计算入度：\n- $\\deg^{-}(A)=0$ 因为没有边进入 $A$。\n- $\\deg^{-}(B)=1$ 来自 $(A,B)$。\n- $\\deg^{-}(C)=2$ 来自 $(A,C)$ 和 $(E,C)$。\n- $\\deg^{-}(D)=2$ 来自 $(B,D)$ 和 $(C,D)$。\n- $\\deg^{-}(E)=0$ 因为没有边进入 $E$。\n- $\\deg^{-}(F)=1$ 来自 $(D,F)$。\n- $\\deg^{-}(G)=1$ 来自 $(E,G)$。\n- $\\deg^{-}(H)=1$ 来自 $(G,H)$。\n\n因此，源点就是 $\\{A,E\\}$，所以 $S_{first}=\\{A,E\\}$。在 Kahn 算法中，通过选择任意一个源点作为起始顶点，都可以使其排在第一位。\n\n计算出度：\n- $\\deg^{+}(A)=2$ 到 $B$ 和 $C$。\n- $\\deg^{+}(B)=1$ 到 $D$。\n- $\\deg^{+}(C)=1$ 到 $D$。\n- $\\deg^{+}(D)=1$ 到 $F$。\n- $\\deg^{+}(E)=2$ 到 $C$ 和 $G$。\n- $\\deg^{+}(F)=0$。\n- $\\deg^{+}(G)=1$ 到 $H$。\n- $\\deg^{+}(H)=0$。\n\n因此，汇点就是 $\\{F,H\\}$，所以 $S_{last}=\\{F,H\\}$。任何汇点都可以排在最后，因为对于一个汇点 $s$，$V\\setminus\\{s\\}$ 的任何拓扑排序在末尾追加 $s$ 后仍然有效（因为没有离开 $s$ 的边来破坏顺序）。\n\n与选项比较，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1549724"}]}