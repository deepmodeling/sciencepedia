{"hands_on_practices": [{"introduction": "理解有根树的第一步通常是将抽象的关系集合转化为具体的视觉结构。这项练习旨在巩固根、叶、深度和高度等核心定义，这些都是进一步分析树结构的基础。通过将给定的父子关系对系统地组织起来，你将能够亲手构建一棵树并计算其基本属性 [@problem_id:1531605]。", "problem": "一个层次化数据结构由一组父子关系描述。该结构由用大写字母标记的节点组成。这些关系以有序对 `(P, C)` 的集合形式给出，其中 `P` 是 `C` 的父节点。\n\n关系集合为：`{(F, B), (F, J), (B, A), (B, D), (D, C), (D, E), (J, G), (J, K), (G, I), (K, H), (K, L)}`。\n\n对于此结构，需要了解以下几个定义：\n- **根节点**是唯一没有父节点的节点。\n- **叶节点**是没有子节点的节点。\n- 节点的**深度**是指从根节点到该节点的唯一路径上的边数。根据定义，根节点的深度为0。\n- 整个结构的**高度**是结构中所有节点深度的最大值。\n\n根据所提供的关系，确定以下三个值：\n1. 结构的高度。\n2. 结构中叶节点的总数。\n3. 节点 `K` 的深度。\n\n请将您的答案以单行矩阵 `(h, l, d)` 的形式给出，其中 `h` 是高度，`l` 是叶节点数，`d` 是节点 `K` 的深度。", "solution": "设关系集合为 $R=\\{(F,B),(F,J),(B,A),(B,D),(D,C),(D,E),(J,G),(J,K),(G,I),(K,H),(K,L)\\}$。设 $P$ 为出现在 $R$ 中的所有父节点的集合，$C$ 为所有子节点的集合：\n$$P=\\{F,B,D,J,G,K\\},\\quad C=\\{B,J,A,D,C,E,G,K,I,H,L\\}.$$\n根节点是唯一没有父节点的节点，即 $P\\setminus C$ 中的唯一元素，也就是 $F$。\n\n定义深度函数 $d(\\cdot)$，其中 $d(F)=0$，并且对于每个 $(u,v)\\in R$，有 $d(v)=d(u)+1$。递归应用此定义：\n- 从 $(F,B)$ 和 $(F,J)$ 可得：$d(B)=1$, $d(J)=1$。\n- 从 $(B,A)$ 和 $(B,D)$ 可得：$d(A)=2$, $d(D)=2$。\n- 从 $(D,C)$ 和 $(D,E)$ 可得：$d(C)=3$, $d(E)=3$。\n- 从 $(J,G)$ 和 $(J,K)$ 可得：$d(G)=2$, $d(K)=2$。\n- 从 $(G,I)$ 可得：$d(I)=3$。\n- 从 $(K,H)$ 和 $(K,L)$ 可得：$d(H)=3$, $d(L)=3$。\n\n高度是最大深度：\n$$h=\\max\\{d(v)\\colon v\\in V\\}=3.$$\n\n叶节点是没有子节点的节点，即对于节点 $v$，不存在任何 $w$ 使得 $(v,w)\\in R$。叶节点为 $\\{A,C,E,I,H,L\\}$，所以叶节点的总数为\n$$l=6.$$\n\n节点 $K$ 的深度为\n$$d=d(K)=2.$$", "answer": "$$\\boxed{\\begin{pmatrix} 3  6  2 \\end{pmatrix}}$$", "id": "1531605"}, {"introduction": "虽然一般树结构非常灵活，但许多应用场景会采用更具规律性的特殊树结构。这项练习将探索“全 $m$ 元树”，并揭示其叶子节点数量和内部节点数量之间一个简洁而强大的数学关系。你会发现，通过施加“每个内部节点恰好有 $m$ 个子节点”这一结构性约束，我们可以推导出普适的优雅公式 [@problem_id:1531606]。", "problem": "在计算机科学领域，有根树是用于分层组织信息的基本数据结构。考虑一个为高性能数据库索引系统设计的特殊树结构。该结构被建模为**完全 m 元树**。\n\n我们来定义一些术语：\n- **有根树**是一种树，其中一个顶点被指定为根。\n- **m 元树**是一种有根树，其中每个顶点的子节点数最多为 $m$ 个。\n- **完全 m 元树**是一种特殊的 m 元树，其中每个非叶子顶点的子节点数恰好为 $m$ 个。\n- **叶子节点**是没有子节点的顶点。\n- **内部顶点**是至少有一个子节点的任何顶点（即，任何非叶子顶点）。\n\n该数据库系统使用一棵完全 5 元树实现。系统诊断显示该树当前恰好有 21 个叶子节点。根据此信息，确定树中内部顶点的数量。", "solution": "设 $m$ 表示度数，$i$ 表示内部顶点的数量，$l$ 表示叶子节点的数量，$V$ 表示顶点总数，$E$ 表示边的数量。\n\n在一棵有根树中，边的数量满足\n$$\nE = V - 1.\n$$\n在一棵完全 $m$ 元树中，每个内部顶点恰好有 $m$ 个子节点，因此边的总数也等于所有顶点的出度之和，而出度仅由内部顶点贡献：\n$$\nE = m i.\n$$\n顶点的总数是内部顶点和叶子节点的数量之和：\n$$\nV = i + l.\n$$\n令两个关于 $E$ 的表达式相等，得到\n$$\nm i = V - 1 = i + l - 1.\n$$\n整理得，\n$$\nl = (m - 1)i + 1.\n$$\n对于一棵有 $l = 21$ 个叶子节点的完全 5 元树，代入 $m = 5$ 和 $l = 21$：\n$$\n21 = (5 - 1)i + 1 = 4i + 1.\n$$\n求解 $i$：\n$$\n4i = 20 \\quad \\Rightarrow \\quad i = 5.\n$$\n因此，内部顶点的数量为 $5$。", "answer": "$$\\boxed{5}$$", "id": "1531606"}, {"introduction": "这项练习旨在连接抽象的图论概念与它在计算机科学中的实际应用。在实践中，树通常以父指针数组等数据结构形式存储在内存中，而非直观的图表。这个问题要求你直接处理这种常见的表示方式，以解决一个经典的算法问题：寻找最低公共祖先（LCA），这在文件系统、生物信息学等领域都是一项至关重要的操作 [@problem_id:1531615]。", "problem": "在一家现代科技公司中，其组织结构被建模为一棵有根树。每位员工由一个节点表示，汇报结构由一个父数组定义。该公司有 $N=15$ 名员工，索引从 0 到 14。该结构由一个大小为 15 的从零开始索引的父数组 `P` 给出，其中 `P[i]` 是员工 `i` 的直属经理的索引。公司总裁是树的根节点，没有经理，这通过 `P[i] = -1` 来表示，其中 `i` 是根节点员工。\n\n父数组 `P` 如下所示：\n`P = [10, 3, 0, 8, 1, 0, 3, 1, -1, 4, 10, 4, 14, 3, 8]`\n\n我们为此层级结构定义两个概念：\n1.  **深度**：员工节点的深度是其指挥链中严格位于其上方的经理人数。例如，总裁的深度为 0。其经理是总裁的员工深度为 1。\n2.  **最低共同经理 (LCM)**：对于任意两名不同的员工，他们的最低共同经理是同时作为这两名员工祖先且在组织树中处于最大可能深度的经理。\n\n给定此结构，确定员工 `e_1 = 9` 和员工 `e_2 = 7` 的最低共同经理的深度。", "solution": "问题要求在由父数组 `P` 表示的组织层级结构中，求出两名员工 `e_1 = 9` 和 `e_2 = 7` 的最低共同经理 (LCM) 的深度。\n\n首先，我们来确定树的根节点。根节点是满足 `P[i] = -1` 的员工 `i`。检查数组 `P`，我们发现 `P[8] = -1`，因此员工 8 是总裁，也是树的根节点。\n\n解决方案的核心包括三个主要步骤：\n1.  找到员工 `e_1 = 9` 的指挥链（即到根节点的路径）。\n2.  找到员工 `e_2 = 7` 的指挥链。\n3.  从这两条路径中确定最低共同经理 (LCM) 并计算其深度。\n\n**步骤 1：找到员工 9 到根节点的路径。**\n我们向上追溯员工 9 的经理，直到到达根节点（员工 8，其父节点为 -1）。\n- 起始员工是 `9`。\n- `9` 的经理是 `P[9] = 4`。\n- `4` 的经理是 `P[4] = 1`。\n- `1` 的经理是 `P[1] = 3`。\n- `3` 的经理是 `P[3] = 8`。\n- `8` 的经理是 `P[8] = -1`，这表示我们已经到达根节点。\n\n从员工 9 到根节点的路径是 `9 -> 4 -> 1 -> 3 -> 8`。我们可以列出员工 9 的所有祖先集合（包括员工本身）：`{9, 4, 1, 3, 8}`。\n\n**步骤 2：找到员工 7 到根节点的路径。**\n类似地，我们向上追溯员工 7 的经理。\n- 起始员工是 `7`。\n- `7` 的经理是 `P[7] = 1`。\n- `1` 的经理是 `P[1] = 3`。\n- `3` 的经理是 `P[3] = 8`。\n- `8` 的经理是 `P[8] = -1`。我们已经到达根节点。\n\n从员工 7 到根节点的路径是 `7 -> 1 -> 3 -> 8`。员工 7 的祖先集合是 `{7, 1, 3, 8}`。\n\n**步骤 3：确定 LCM 并计算其深度。**\nLCM 是两名员工的共同祖先中深度最大的那个。让我们通过求两个祖先集合的交集来找到共同祖先的集合：\n共同祖先 = `{9, 4, 1, 3, 8}` $\\cap$ `{7, 1, 3, 8}` = `{1, 3, 8}`。\n\n现在我们必须确定这些共同祖先（`1`、`3` 或 `8`）中哪一个的深度最大。节点的深度是从该节点到达根节点所需的步数。\n\n-   **员工 8 的深度：** 员工 8 是根节点。到根节点的路径是平凡的（0 步）。因此，`depth(8) = 0`。\n-   **员工 3 的深度：** 从 3 到根节点的路径是 `3 -> 8`。这需要 1 步。因此，`depth(3) = 1`。\n-   **员工 1 的深度：** 从 1 到根节点的路径是 `1 -> 3 -> 8`。这需要 2 步。因此，`depth(1) = 2`。\n\n比较共同祖先的深度：`depth(1) = 2`，`depth(3) = 1`，`depth(8) = 0`。最大深度为 2，对应于员工 1。\n\n因此，员工 9 和 7 的最低共同经理 (LCM) 是员工 1。\n\n问题要求的是这个 LCM 的深度。正如我们刚刚计算的，员工 1 的深度是 2。", "answer": "$$\\boxed{2}$$", "id": "1531615"}]}