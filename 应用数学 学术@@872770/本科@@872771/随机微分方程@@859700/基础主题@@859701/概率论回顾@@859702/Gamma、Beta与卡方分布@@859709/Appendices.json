{"hands_on_practices": [{"introduction": "在深入研究任何概率分布之前，首要任务是确保其定义在数学上是成立的。对于一个有效的概率密度函数（PDF），其在整个定义域上的积分必须等于1。本练习将引导你通过一个基本的变量替换技巧，验证伽玛分布的密度函数形式，并揭示其归一化常数与欧拉伽玛函数 $\\Gamma(k)$ 之间的直接联系。掌握这项基础计算是理解和应用更复杂随机过程模型的关键一步。[@problem_id:3056353]", "problem": "在一维伊藤扩散（Itô diffusions）的研究中，例如Cox–Ingersoll–Ross平方根过程，候选的平稳密度通常在 $(0,\\infty)$ 上呈现与核 $x^{k-1}\\exp(-x/\\theta)$ 成比例的形式，其中 $k>0$ 且 $\\theta>0$。为了从第一性原理检验其可归一性，考虑积分\n$$\nI(k,\\theta)=\\int_{0}^{\\infty} x^{k-1}\\exp\\!\\left(-\\frac{x}{\\theta}\\right)\\,dx,\n$$\n其参数为 $k>0$ 和 $\\theta>0$。\n\n仅使用伽马函数 $\\Gamma(k)=\\int_{0}^{\\infty} u^{\\,k-1}\\exp(-u)\\,du$ (对于 $k>0$) 的定义和积分的换元法则，以 $k$ 和 $\\theta$ 的函数形式，求出 $I(k,\\theta)$ 的闭式解。你的最终答案必须是单一的解析表达式。不需要进行数值取整。", "solution": "问题要求计算积分\n$$\nI(k,\\theta)=\\int_{0}^{\\infty} x^{k-1}\\exp\\left(-\\frac{x}{\\theta}\\right)\\,dx\n$$\n其中参数 $k>0$ 且 $\\theta>0$。计算必须使用伽马函数 $\\Gamma(k)$ 的定义和积分的换元法则。\n\n首先，我们陈述题目给出的伽马函数对于 $k>0$ 的定义：\n$$\n\\Gamma(k)=\\int_{0}^{\\infty} u^{k-1}\\exp(-u)\\,du\n$$\n\n任务是将积分 $I(k,\\theta)$ 转换为一种可以直接应用此定义的形式。我们比较 $I(k,\\theta)$ 的被积函数 $x^{k-1}\\exp(-x/\\theta)$ 和 $\\Gamma(k)$ 的被积函数 $u^{k-1}\\exp(-u)$。关键区别在于指数函数的自变量。在 $I(k,\\theta)$ 中是 $-x/\\theta$，而在 $\\Gamma(k)$ 中是 $-u$。这一观察启发我们进行变量替换。\n\n我们定义一个新的积分变量 $u$，使得指数项相匹配。我们设：\n$$\nu = \\frac{x}{\\theta}\n$$\n通过此代換，我们求解 $x$ 关于 $u$ 的表达式：\n$$\nx = \\theta u\n$$\n为了完成变量替换，我们需要求出微分 $dx$ 关于 $du$ 的表达式。对 $x$ 关于 $u$ 的表达式求导，我们得到：\n$$\n\\frac{dx}{du} = \\theta\n$$\n这意味着微分元变换为：\n$$\ndx = \\theta \\, du\n$$\n接下来，我们必须变换积分上下限。原积分区间为 $x \\in (0, \\infty)$。\n对于下限，当 $x=0$ 时，新变量为 $u = \\frac{0}{\\theta} = 0$。\n对于上限，当 $x \\to \\infty$ 时，由于已知 $\\theta > 0$，新变量 $u = \\frac{x}{\\theta}$ 也趋近于 $\\infty$。\n因此，关于变量 $u$ 的积分上下限仍然是从 $0$ 到 $\\infty$。\n\n现在，我们将 $x = \\theta u$ 和 $dx = \\theta \\, du$ 代入 $I(k,\\theta)$ 的积分中：\n$$\nI(k,\\theta) = \\int_{0}^{\\infty} (\\theta u)^{k-1} \\exp\\left(-\\frac{\\theta u}{\\theta}\\right) (\\theta \\, du)\n$$\n我们简化积分内的表达式。项 $(\\theta u)^{k-1}$ 变为 $\\theta^{k-1} u^{k-1}$，指数的自变量简化为 $-u$。\n$$\nI(k,\\theta) = \\int_{0}^{\\infty} \\theta^{k-1} u^{k-1} \\exp(-u) \\, \\theta \\, du\n$$\n我们可以利用指数的性质合并 $\\theta$ 的因子：\n$$\nI(k,\\theta) = \\int_{0}^{\\infty} \\theta^{k-1+1} u^{k-1} \\exp(-u) \\, du = \\int_{0}^{\\infty} \\theta^k u^{k-1} \\exp(-u) \\, du\n$$\n项 $\\theta^k$ 不依赖于积分变量 $u$，因此可以从积分中提取出来：\n$$\nI(k,\\theta) = \\theta^k \\int_{0}^{\\infty} u^{k-1} \\exp(-u) \\, du\n$$\n剩下的积分现在与题目陈述中提供的伽马函数定义完全相同：\n$$\n\\int_{0}^{\\infty} u^{k-1} \\exp(-u) \\, du = \\Gamma(k)\n$$\n将此定义代入我们关于 $I(k, \\theta)$ 的表达式，我们得到最终的闭式结果：\n$$\nI(k,\\theta) = \\theta^k \\Gamma(k)\n$$\n此结果对所有 $k>0$ 和 $\\theta>0$ 均有效，这是原积分和伽马函数按规定定义的域。问题因此按要求得到解决。", "answer": "$$\\boxed{\\theta^k \\Gamma(k)}$$", "id": "3056353"}, {"introduction": "理论与实践的桥梁往往由强大的极限定理构建。伽玛分布，作为指数分布随机变量之和，为中心极限定理（CLT）的应用提供了一个绝佳的范例。本练习不仅要求你应用CLT来推导当形状参数 $k$ 很大时伽玛分布的正态近似，还进一步要求你使用Berry–Esseen不等式来量化这种近似的误差。这个过程将加深你对分布之间关系的理解，并展示了在应用近似时评估其精度的重要性。[@problem_id:3056367]", "problem": "考虑一个独立同分布的随机变量序列 $\\{Y_{i}\\}_{i=1}^{k}$，其中每个 $Y_{i}$ 服从率为 $1/\\theta$ 的指数分布（因此 $\\mathbb{E}[Y_{i}]=\\theta$ 且 $\\operatorname{Var}(Y_{i})=\\theta^{2}$），并令 $X_{k}=\\sum_{i=1}^{k}Y_{i}$。一个熟知的事实是，$X_{k}$ 服从形状参数为 $k$、尺度参数为 $\\theta$ 的伽玛分布，记作 $X_{k}\\sim\\Gamma(k,\\theta)$。定义标准化和\n$$\nZ_{k}=\\frac{X_{k}-k\\theta}{\\theta\\sqrt{k}}.\n$$\n从中心极限定理 (CLT) 出发，并从基本定义对每一步进行充分的论证，完成以下任务：\n- 当 $k$ 很大时，推导 $Z_{k}$ 的正态近似，解释 $\\mathbb{E}[Y_{i}]$ 和 $\\operatorname{Var}(Y_{i}]$ 的作用。\n- 以闭合形式计算三阶绝对中心矩 $\\rho=\\mathbb{E}\\big[|Y_{1}-\\theta|^{3}\\big]$，并展示所有积分步骤。\n- 使用 Berry–Esseen 型不等式（可取通用 Berry–Esseen 常数为 $C_{\\mathrm{BE}}=0.56$）来获得柯尔莫哥洛夫距离 $\\sup_{x\\in\\mathbb{R}}\\big|\\mathbb{P}(Z_{k}\\le x)-\\Phi(x)\\big|$ 的一个显式上界，其中 $\\Phi$ 是标准正态分布的累积分布函数。\n\n最后，计算当 $k=100$ 时这个显式上界的值，并报告其数值。将你的答案四舍五入到四位有效数字。最终答案必须是一个实数。[@problem_id:387]", "solution": "### 解答\n\n按问题陈述的要求，解答分为三个部分呈现。\n\n**第一部分：通过中心极限定理的正态近似**\n\n中心极限定理 (CLT) 指出，对于一个独立同分布 (i.i.d.) 的随机变量序列 $\\{Y_i\\}_{i=1}^k$，其中每个变量都有有限的均值 $\\mu = \\mathbb{E}[Y_i]$ 和有限的非零方差 $\\sigma^2 = \\operatorname{Var}(Y_i)$，当样本大小 $k$ 趋于无穷大时，标准化样本均值的分布收敛于标准正态分布。更正式地，如果 $X_k = \\sum_{i=1}^k Y_i$，那么标准化和\n$$ \\frac{X_k - \\mathbb{E}[X_k]}{\\sqrt{\\operatorname{Var}(X_k)}} \\xrightarrow{d} N(0,1) \\quad \\text{当 } k \\to \\infty $$\n其中 $\\xrightarrow{d}$ 表示依分布收敛。\n\n在这个问题中，随机变量是 $\\{Y_i\\}_{i=1}^k$，它们是独立同分布的指数分布变量，具有：\n- 均值：$\\mu = \\mathbb{E}[Y_i] = \\theta$\n- 方差：$\\sigma^2 = \\operatorname{Var}(Y_i) = \\theta^2$\n\n这些变量的和是 $X_k = \\sum_{i=1}^k Y_i$。由于期望的线性性质和变量的独立性，$X_k$ 的均值和方差是：\n- 和的均值：$\\mathbb{E}[X_k] = \\mathbb{E}\\left[\\sum_{i=1}^k Y_i\\right] = \\sum_{i=1}^k \\mathbb{E}[Y_i] = k\\mu = k\\theta$。\n- 和的方差：$\\operatorname{Var}(X_k) = \\operatorname{Var}\\left(\\sum_{i=1}^k Y_i\\right) = \\sum_{i=1}^k \\operatorname{Var}(Y_i) = k\\sigma^2 = k\\theta^2$。\n\n和的标准差是 $\\sqrt{\\operatorname{Var}(X_k)} = \\sqrt{k\\theta^2} = \\theta\\sqrt{k}$。\n\n标准化和是通过减去均值并除以标准差得到的：\n$$ \\frac{X_k - \\mathbb{E}[X_k]}{\\sqrt{\\operatorname{Var}(X_k)}} = \\frac{X_k - k\\theta}{\\theta\\sqrt{k}} $$\n这正是问题中定义的变量 $Z_k$。\n\n因此，根据中心极限定理，当 $k$ 很大时，$Z_k = \\frac{X_k - k\\theta}{\\theta\\sqrt{k}}$ 的分布可以用标准正态分布 $N(0,1)$ 来近似。\n$\\mathbb{E}[Y_i] = \\theta$ 的作用是确定和 $X_k$ 的均值，该均值用于对变量 $X_k$ 进行中心化。$\\operatorname{Var}(Y_i) = \\theta^2$ 的作用是确定和的标准差，该标准差用于对中心化的变量 $X_k-k\\theta$ 进行尺度变换。这种中心化和尺度变换确保了对于任何 $k$，所得变量 $Z_k$ 的均值为 0、方差为 1，并且其分布收敛于标准正态分布。\n\n**第二部分：三阶绝对中心矩的计算**\n\n我们需要计算 $\\rho = \\mathbb{E}[|Y_1 - \\theta|^3]$。随机变量 $Y_1$ 服从率为 $1/\\theta$ 的指数分布，因此其概率密度函数 (PDF) 为 $f(y) = \\frac{1}{\\theta}\\exp(-y/\\theta)$，其中 $y \\ge 0$。\n\n该期望由以下积分给出：\n$$ \\rho = \\int_0^\\infty |y - \\theta|^3 f(y) dy = \\int_0^\\infty |y - \\theta|^3 \\frac{1}{\\theta}\\exp(-y/\\theta) dy $$\n我们在绝对值函数形式改变的点 $y=\\theta$ 处将积分拆分：\n$$ \\rho = \\frac{1}{\\theta} \\left[ \\int_0^\\theta (\\theta - y)^3 \\exp(-y/\\theta) dy + \\int_\\theta^\\infty (y - \\theta)^3 \\exp(-y/\\theta) dy \\right] $$\n让我们分别计算每个积分。\n\n对于第一个积分，令 $u = y/\\theta$，$dy = \\theta du$。积分变为：\n$$ \\int_0^\\theta (\\theta - y)^3 \\exp(-y/\\theta) dy = \\int_0^1 (\\theta - u\\theta)^3 e^{-u} (\\theta du) = \\theta^4 \\int_0^1 (1-u)^3 e^{-u} du $$\n通过三次分部积分法可得 $\\int_0^1 (1-u)^3 e^{-u} du = [- (1-u)^3 e^{-u}]_0^1 - 3 \\int_0^1 (1-u)^2 e^{-u} du = 1 - 3(1-2(1-e^{-1})) = 6e^{-1}-2$。\n所以第一个积分是 $\\theta^4(6e^{-1}-2)$。\n\n对于第二个积分，令 $v = (y-\\theta)/\\theta$，$y = \\theta(1+v)$，$dy=\\theta dv$。积分变为：\n$$ \\int_\\theta^\\infty (y - \\theta)^3 \\exp(-y/\\theta) dy = \\int_0^\\infty (\\theta v)^3 \\exp(-(1+v)) (\\theta dv) = \\theta^4 e^{-1} \\int_0^\\infty v^3 e^{-v} dv $$\n该积分是伽玛函数 $\\Gamma(4) = 3! = 6$。\n因此，第二个积分是 $6e^{-1}\\theta^4$。\n\n将两部分乘以 $1/\\theta$ 后相加：\n$$ \\rho = \\frac{1}{\\theta} \\left[ \\theta^4(6e^{-1}-2) + \\theta^4(6e^{-1}) \\right] = \\theta^3 (12e^{-1} - 2) $$\n\n**第三部分：Berry–Esseen 界与数值计算**\n\nBerry–Esseen 不等式给出了标准化和的累积分布函数与标准正态分布的累积分布函数之间最大差异的一个上界。对于 $Z_k = \\frac{\\sum_{i=1}^k Y_i - k\\mu}{\\sigma\\sqrt{k}}$，该不等式为：\n$$ \\sup_{x\\in\\mathbb{R}}\\big|\\mathbb{P}(Z_{k}\\le x)-\\Phi(x)\\big| \\le C \\frac{\\mathbb{E}[|Y_1 - \\mu|^3]}{\\sigma^3 \\sqrt{k}} $$\n在我们的问题中，我们有：\n- Berry–Esseen 常数 $C = C_{\\mathrm{BE}} = 0.56$。\n- $Y_i$ 的均值是 $\\mu = \\theta$。\n- $Y_i$ 的标准差是 $\\sigma = \\sqrt{\\theta^2} = \\theta$。\n- 三阶绝对中心矩是 $\\rho = \\mathbb{E}[|Y_1 - \\theta|^3] = (12\\exp(-1) - 2)\\theta^3$。\n\n将这些代入不等式中：\n$$ \\sup_{x\\in\\mathbb{R}}\\big|\\mathbb{P}(Z_{k}\\le x)-\\Phi(x)\\big| \\le 0.56 \\cdot \\frac{(12\\exp(-1) - 2)\\theta^3}{(\\theta)^3 \\sqrt{k}} $$\n$\\theta^3$ 项被消去，从而得到一个与尺度参数 $\\theta$ 无关的界：\n$$ \\text{上界} = \\frac{0.56(12\\exp(-1) - 2)}{\\sqrt{k}} $$\n我们需要计算当 $k=100$ 时此界的值。\n$$ \\text{上界}_{k=100} = \\frac{0.56(12\\exp(-1) - 2)}{\\sqrt{100}} = \\frac{0.56(12\\exp(-1) - 2)}{10} = 0.056(12\\exp(-1) - 2) $$\n现在，我们计算其数值：\n$$ 12\\exp(-1) - 2 \\approx 12(0.36787944) - 2 = 4.41455328 - 2 = 2.41455328 $$\n$$ \\text{上界}_{k=100} \\approx 0.056 \\times 2.41455328 \\approx 0.13521498 $$\n将结果四舍五入到四位有效数字，得到 $0.1352$。", "answer": "$$\n\\boxed{0.1352}\n$$", "id": "3056367"}, {"introduction": "在随机微分方程领域，尤其是模拟布朗运动路径时，独立的高斯增量的平方和是一个核心概念，它与二次变差的估计直接相关。本练习将理论付诸实践，要求你从卡方（$\\chi^2$）分布的基本定义——即独立标准正态变量的平方和——出发，构建一个模拟器。更重要的是，本练习将引导你探索大规模计算中的一个关键现实问题：数值稳定性。通过比较不同求和策略的精度，你将体会到理论公式和稳健的数值实现之间的差距。[@problem_id:3056438]", "problem": "本题要求您将随机微分方程中的一个核心构造与经典的连续分布联系起来，然后实现一个数值稳健的模拟器。在由标准布朗运动驱动的 Itô 随机微分方程的 Euler–Maruyama 离散化中，会自然产生独立的标准化高斯增量。考虑独立标准化增量 $\\{Z_k\\}_{k=1}^{\\nu}$，其中 $Z_k \\sim \\mathcal{N}(0,1)$，并注意平方和 $\\sum_{k=1}^{\\nu} Z_k^2$ 出现在二次变分及相关似然的估计量中。请从独立性和标准正态分布的第一性原理出发，确定 $\\sum_{k=1}^{\\nu} Z_k^2$ 的分布，并根据关于伽马分布及其加法稳定性的公认事实推导出其均值和方差。然后，实现一个仅使用独立标准正态定义的模拟（主模拟中不直接调用卡方或伽马采样器），并量化不同求和策略在自由度参数较大时的数值稳定性。\n\n对于每个具有参数 $(\\nu, M, s)$ 的测试用例，您的程序必须执行以下操作：\n- 使用以种子 $s$ 初始化的伪随机数生成器，通过为每次抽取显式生成 $\\nu$ 个独立的 $\\mathcal{N}(0,1)$ 变量并对其平方求和，来模拟 $M$ 次平方和 $\\sum_{k=1}^{\\nu} Z_k^2$ 的独立抽取。\n- 计算这 $M$ 次抽取的样本均值 $\\widehat{\\mu}$ 和无偏样本方差 $\\widehat{\\sigma}^2$，然后计算绝对均值误差 $|\\widehat{\\mu} - \\nu|$ 和绝对方差误差 $|\\widehat{\\sigma}^2 - 2\\nu|$。这些值应以浮点数形式报告。\n- 为评估大 $\\nu$ 值下求和的数值稳定性，使用以种子 $s + 1337$ 初始化的新伪随机数生成器，抽取一个向量 $(Z_1,\\dots,Z_{\\nu})$，其中 $Z_k \\sim \\mathcal{N}(0,1)$，并使用三种方法计算相同的平方和：\n  1. 朴素 Python 累加 $S_{\\text{naive}} = \\sum_{k=1}^{\\nu} Z_k^2$，通过一个普通循环实现，\n  2. Kahan 补偿求和 $S_{\\text{kahan}}$，应用于序列 $\\{Z_k^2\\}_{k=1}^{\\nu}$，\n  3. 向量化成对求和 $S_{\\text{np}}$，使用高级向量化点积实现。\n  基于这些结果，计算两个相对差异（无量纲浮点数）：$r_1 = |S_{\\text{naive}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$ 和 $r_2 = |S_{\\text{np}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$。如果 $S_{\\text{kahan}} = 0$，则将两个相对差异都定义为 $0$。\n- 对于每个测试用例，按固定顺序输出四个浮点数：绝对均值误差、绝对方差误差、$r_1$、$r_2$。\n\n在推导过程中，您可以使用的基本依据是：\n- 标准正态分布 $\\mathcal{N}(0,1)$ 的定义、独立性以及布朗运动中独立增量的可加性。\n- 公认的事实：如果 $X \\sim \\operatorname{Gamma}(k,\\theta)$ 和 $Y \\sim \\operatorname{Gamma}(k',\\theta)$ 独立且具有共同的尺度参数 $\\theta$，则 $X+Y \\sim \\operatorname{Gamma}(k+k',\\theta)$，并且 $\\operatorname{Gamma}(k,\\theta)$ 的均值为 $k\\theta$，方差为 $k\\theta^2$。\n- 数值浮点求和的基本性质以及 Kahan 补偿求和算法。\n\n必须处理边界情况和数值稳定性问题。特别是，对于较大的 $\\nu$，对许多小数求和会累积舍入误差；对于 $\\nu = 0$，分布在 $0$ 处退化。\n\n本题不涉及物理单位。所有角度（如有）默认为弧度（本题未使用）。在表示比例时，始终使用小数。\n\n测试套件：\n- 用例 A（边界）：$(\\nu, M, s) = (0, 1000, 1234)$。\n- 用例 B（正常路径）：$(\\nu, M, s) = (10, 100000, 202311)$。\n- 用例 C（大 $\\nu$ 值稳定性）：$(\\nu, M, s) = (200000, 200, 7)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。按顺序连接用例 A 的四个浮点数，然后是用例 B 的四个浮点数，最后是用例 C 的四个浮点数。例如，输出必须类似于 $[\\text{A\\_mean\\_err},\\text{A\\_var\\_err},\\text{A\\_r1},\\text{A\\_r2},\\text{B\\_mean\\_err},\\dots,\\text{C\\_r2}]$。", "solution": "**理论基础**\n\n本题要求我们确定 $\\nu$ 个独立标准正态随机变量的平方和 $S_{\\nu} = \\sum_{k=1}^{\\nu} Z_k^2$ 的分布，其中每个 $Z_k \\sim \\mathcal{N}(0,1)$ 都是独立的。我们将从第一性原理和所提供的伽马分布性质出发，推导出该分布及其均值和方差。\n\n**步骤1：单个标准正态变量平方的分布**\n\n设 $Z \\sim \\mathcal{N}(0,1)$。$Z$ 的概率密度函数 (PDF) 为 $f_Z(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$，其中 $z \\in (-\\infty, \\infty)$。我们寻求 $Y = Z^2$ 的分布。由于 $Y$ 必须为非负数，我们考虑 $y \\geq 0$。\n\n$Y$ 的累积分布函数 (CDF) 为 $F_Y(y) = P(Y \\leq y) = P(Z^2 \\leq y) = P(-\\sqrt{y} \\leq Z \\leq \\sqrt{y})$。\n$$F_Y(y) = \\int_{-\\sqrt{y}}^{\\sqrt{y}} \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz$$\n我们可以通过对 $Y$ 的 CDF 关于 $y$ 求导来找到其 PDF，这里使用莱布尼茨积分法则：\n$$f_Y(y) = \\frac{d}{dy} F_Y(y) = \\frac{1}{\\sqrt{2\\pi}} e^{-(\\sqrt{y})^2/2} \\cdot \\frac{d}{dy}(\\sqrt{y}) - \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-(-\\sqrt{y})^2/2} \\cdot \\frac{d}{dy}(-\\sqrt{y})\\right)$$\n$$f_Y(y) = \\frac{1}{\\sqrt{2\\pi}} e^{-y/2} \\left(\\frac{1}{2\\sqrt{y}}\\right) - \\frac{1}{\\sqrt{2\\pi}} e^{-y/2} \\left(-\\frac{1}{2\\sqrt{y}}\\right) = 2 \\cdot \\frac{1}{\\sqrt{2\\pi}} e^{-y/2} \\left(\\frac{1}{2\\sqrt{y}}\\right) = \\frac{1}{\\sqrt{2\\pi y}} e^{-y/2}$$\n这是 $y > 0$ 时的 PDF。\n\n现在，我们将其与 $\\operatorname{Gamma}(k, \\theta)$ 分布的 PDF 进行比较，其形式为 $f(x; k, \\theta) = \\frac{1}{\\Gamma(k)\\theta^k} x^{k-1} e^{-x/\\theta}$。\n题目指出，自由度为 $\\nu$ 的卡方分布 $\\chi^2(\\nu)$ 是伽马分布的一个特例，即 $\\operatorname{Gamma}(k=\\nu/2, \\theta=2)$。对于一个自由度（$\\nu=1$），这对应于 $\\operatorname{Gamma}(k=1/2, \\theta=2)$。\n我们将 $k=1/2$ 和 $\\theta=2$ 代入伽马分布的 PDF 公式。已知 $\\Gamma(1/2) = \\sqrt{\\pi}$：\n$$f(y; 1/2, 2) = \\frac{1}{\\Gamma(1/2) 2^{1/2}} y^{1/2-1} e^{-y/2} = \\frac{1}{\\sqrt{\\pi} \\sqrt{2}} y^{-1/2} e^{-y/2} = \\frac{1}{\\sqrt{2\\pi y}} e^{-y/2}$$\n这证实了 $Y=Z^2$ 的 PDF 确实是 $\\operatorname{Gamma}(1/2, 2)$ 分布的 PDF。这也就是自由度为 1 的卡方分布，记为 $\\chi^2(1)$。\n\n**步骤2：平方和的分布**\n\n我们关心的是和 $S_{\\nu} = \\sum_{k=1}^{\\nu} Z_k^2$。随机变量 $Z_k$ 是独立的，这意味着变量 $Y_k = Z_k^2$ 也是独立的。每个 $Y_k \\sim \\operatorname{Gamma}(1/2, 2)$。\n\n题目提供了一个伽马分布的关键性质：如果 $X_1 \\sim \\operatorname{Gamma}(k_1, \\theta)$ 和 $X_2 \\sim \\operatorname{Gamma}(k_2, \\theta)$ 是独立的，那么它们的和 $X_1+X_2 \\sim \\operatorname{Gamma}(k_1+k_2, \\theta)$。这种可加性可以推广到任意数量具有相同尺度参数 $\\theta$ 的独立伽马变量之和。\n\n将此性质应用于我们的和 $S_{\\nu}$：\n$$S_{\\nu} = \\sum_{k=1}^{\\nu} Y_k \\sim \\operatorname{Gamma}\\left(\\sum_{k=1}^{\\nu} \\frac{1}{2}, 2\\right) = \\operatorname{Gamma}\\left(\\frac{\\nu}{2}, 2\\right)$$\n因此，$\\nu$ 个独立标准正态变量的平方和服从形状参数为 $k=\\nu/2$、尺度参数为 $\\theta=2$ 的伽马分布。根据定义，这正是自由度为 $\\nu$ 的卡方分布，即 $\\chi^2(\\nu)$。\n\n**步骤3：均值和方差**\n\n题目指出，对于一个随机变量 $X \\sim \\operatorname{Gamma}(k, \\theta)$，其均值为 $\\mathbb{E}[X] = k\\theta$，方差为 $\\operatorname{Var}(X) = k\\theta^2$。\n对于我们的变量 $S_{\\nu} \\sim \\operatorname{Gamma}(\\nu/2, 2)$，我们有 $k = \\nu/2$ 和 $\\theta=2$。因此：\n- 均值：$\\mathbb{E}[S_{\\nu}] = \\left(\\frac{\\nu}{2}\\right) \\cdot 2 = \\nu$。\n- 方差：$\\operatorname{Var}(S_{\\nu}) = \\left(\\frac{\\nu}{2}\\right) \\cdot 2^2 = \\frac{\\nu}{2} \\cdot 4 = 2\\nu$。\n\n这些理论结果 $\\mathbb{E}[S_{\\nu}]=\\nu$ 和 $\\operatorname{Var}(S_{\\nu})=2\\nu$ 提供了基准真相，我们将用模拟得出的样本统计量与之比较以计算绝对误差。对于边界情况 $\\nu=0$，和为空，定义为 $0$。分布在 $0$ 处退化，我们的公式正确地得出了 $0$ 的均值和 $0$ 的方差。\n\n**实现策略**\n\n对于每个测试用例 $(\\nu, M, s)$，实现将分为两个主要部分。\n\n**A部分：统计估计**\n使用给定的种子 $s$ 初始化一个伪随机数生成器 (PRNG)。我们将生成 $M$ 次和 $S_{\\nu}$ 的独立抽取。为了在 $\\nu > 0$ 时提高计算效率，最好的方法是生成一个 $M \\times \\nu$ 的 $\\mathcal{N}(0,1)$ 样本矩阵，将每个元素平方，然后沿行求和，以获得 $M$ 个 $S_{\\nu}$ 的值。根据这 $M$ 个值的样本，我们计算样本均值 $\\widehat{\\mu}$ 和无偏样本方差 $\\widehat{\\sigma}^2$（使用 $M-1$ 作为分母）。然后计算绝对误差 $|\\widehat{\\mu} - \\nu|$ 和 $|\\widehat{\\sigma}^2 - 2\\nu|$。对于 $\\nu=0$，所有和都为 $0$，因此样本均值和方差都为 $0$，误差也为 $0$。\n\n**B部分：数值稳定性评估**\n使用种子 $s+1337$ 初始化第二个独立的 PRNG。生成一个包含 $\\nu$ 个标准正态样本的向量。使用三种不同的算法计算这些样本的平方和，以突显浮点误差累积的影响，这对于大 $\\nu$ 值尤为重要。\n1.  **朴素求和 ($S_{\\text{naive}}$):** 在 Python 中使用标准的 `for` 循环累加总和。当将一个小数加到一个大得多的累计总和上时，此方法容易丢失精度。\n2.  **Kahan 求和 ($S_{\\text{kahan}}$):** Kahan 补偿求和算法维护一个运行中的补偿项，以跟踪和纠正每次加法中丢失的低位比特。这为求和提供了一个高度精确的“基准真相”。\n3.  **向量化求和 ($S_{\\text{np}}$):** 对样本向量 $v$ 使用 `numpy.dot(v, v)` 来计算平方和。NumPy 底层的 BLAS/LAPACK 库通常采用数值稳定的技术，如成对求和或使用扩展精度累加器，这使得该方法比朴素求和精确得多。\n\n然后计算相对差异 $r_1 = |S_{\\text{naive}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$ 和 $r_2 = |S_{\\text{np}} - S_{\\text{kahan}}| / S_{\\text{kahan}}$。一个特殊情况处理 $S_{\\text{kahan}}=0$ 以防止除以零，将两个差异都设置为 $0$。这种情况当且仅当 $\\nu=0$ 时发生。\n\n最终的代码将封装此逻辑，遍历所提供的测试用例并按指定格式化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (nu, M, s)\n        (0, 1000, 1234),          # Case A (boundary)\n        (10, 100000, 202311),      # Case B (happy path)\n        (200000, 200, 7),         # Case C (large-nu stability)\n    ]\n\n    all_results = []\n    for nu, M, s in test_cases:\n        results_for_case = process_case(nu, M, s)\n        all_results.extend(results_for_case)\n\n    # Format output as a single line: [res1,res2,res3,...]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef process_case(nu, M, s):\n    \"\"\"\n    Process a single test case (nu, M, s) and return a list of the four\n    required float values: [mean_err, var_err, r1, r2].\n    \"\"\"\n\n    # --- Part A: Statistical Estimation ---\n    \n    true_mean = float(nu)\n    true_variance = 2.0 * nu\n    \n    if nu == 0:\n        # Trivial case: sum is always 0.\n        mean_err = 0.0\n        var_err = 0.0\n    else:\n        rng_A = np.random.default_rng(seed=s)\n        # Generate M x nu standard normal variates\n        z_matrix = rng_A.standard_normal(size=(M, nu), dtype=np.float64)\n        # Square them and sum along rows to get M draws of the sum-of-squares\n        sums_of_squares = np.sum(z_matrix**2, axis=1)\n        \n        # Calculate sample mean and unbiased sample variance\n        mu_hat = np.mean(sums_of_squares)\n        sigma2_hat = np.var(sums_of_squares, ddof=1)\n        \n        # Calculate absolute errors\n        mean_err = abs(mu_hat - true_mean)\n        var_err = abs(sigma2_hat - true_variance)\n\n    # --- Part B: Numerical Stability Assessment ---\n\n    if nu == 0:\n        # Trivial case: all sums are 0, so discrepancies are 0.\n        r1 = 0.0\n        r2 = 0.0\n    else:\n        # Initialize a new RNG with a different seed for independence\n        rng_B = np.random.default_rng(seed=s + 1337)\n        z_vector = rng_B.standard_normal(size=nu, dtype=np.float64)\n        z_vector_sq = z_vector**2\n        \n        # 1. Naïve summation in a plain Python loop\n        s_naive = 0.0\n        for x in z_vector_sq:\n            s_naive += x\n            \n        # 2. Kahan compensated summation\n        s_kahan = 0.0\n        c = 0.0  # A running compensation for lost low-order bits.\n        for x in z_vector_sq:\n            y = x - c\n            t = s_kahan + y\n            c = (t - s_kahan) - y\n            s_kahan = t\n            \n        # 3. Vectorized numpy.dot summation\n        s_np = np.dot(z_vector, z_vector)\n        \n        # Calculate relative discrepancies using Kahan sum as the baseline\n        if s_kahan == 0.0:\n            # This case is extremely unlikely for nu > 0 but is handled for correctness.\n            r1 = 0.0\n            r2 = 0.0\n        else:\n            r1 = abs(s_naive - s_kahan) / s_kahan\n            r2 = abs(s_np - s_kahan) / s_kahan\n\n    return [mean_err, var_err, r1, r2]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3056438"}]}