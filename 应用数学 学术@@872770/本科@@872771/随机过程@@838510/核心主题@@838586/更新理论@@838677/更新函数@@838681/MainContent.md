## 引言
在[随机过程](@entry_id:159502)的世界里，许多现象——从机器故障、神经元发放，到客户到达服务系统——都表现为重复发生的事件。更新过程为这类现象提供了强大的数学模型。然而，仅仅定义事件的间隔时间[分布](@entry_id:182848)是不够的，我们更关心的是：在任意给定的时间段内，我们预期会发生多少次事件？这个核心问题引出了[更新理论](@entry_id:263249)的基石——**更新函数**。它量化了更新过程在时间上的累积效应，是连接单个事件随机性与过程长期行为的桥梁。本文旨在系统性地剖析更新函数。在“**原理与机制**”一章中，我们将从其定义和基本性质出发，推导并学习如何求解关键的[更新方程](@entry_id:264802)。接下来，在“**应用与跨学科联系**”中，我们将探索这一理论如何在工程、物理学、生物学等多个领域中解决实际问题，展示其广泛的适用性。最后，通过“**动手实践**”部分，读者将有机会通过具体计算来巩固和应用所学知识，从而真正掌握这一分析工具。

## 原理与机制

在上一章中，我们介绍了更新过程作为对重复发生事件进行建模的[随机过程](@entry_id:159502)。本章将深入探讨其核心的数学工具——**更新函数 (renewal function)**。我们将从其定义和基本性质出发，推导并求解其所满足的基本方程，并探索其在[长期行为](@entry_id:192358)和更广泛模型（如延迟更新和[更新回报过程](@entry_id:271905)）中的应用。

### 更新函数的定义与解释

让我们回顾一下[更新过程](@entry_id:273573)的基本设定。一个事件在时间 $t=0$ 发生，随后的事件间隔时间由一系列独立同分布 (i.i.d.) 的正[随机变量](@entry_id:195330) $X_1, X_2, \dots$ 给出，其公共的[累积分布函数 (CDF)](@entry_id:264700) 为 $F(t) = P(X_i \le t)$。第 $n$ 次事件发生的时间为 $S_n = \sum_{i=1}^n X_i$。

描述[更新过程](@entry_id:273573)在时间 $t$ 之前发生了多少次事件的[计数过程](@entry_id:260664)，记为 $N(t)$，其定义为：
$$
N(t) = \max\{n \ge 0 : S_n \le t\}
$$
这是一个[随机变量](@entry_id:195330)，因为它的值取决于随机的事件间隔时间 $X_i$。在许多应用中，我们感兴趣的是这个计数的[期望值](@entry_id:153208)，它引导我们定义了本章的核心概念。

**定义：更新函数**
> **更新函数 (Renewal Function)** $m(t)$ 定义为在时间区间 $[0, t]$ 内发生的更新事件的期望次数：
> $$
> m(t) = E[N(t)]
> $$

理解更新函数 $m(t)$ 与事件间隔时间的[分布函数](@entry_id:145626) $F(t)$ 之间的区别至关重要。$F(t)$ 描述了**单个**事件间隔的持续时间特性，而 $m(t)$ 则描述了在从 $0$ 开始的一段时间内，**整个过程**累计事件次数的平均表现。

为了阐明这一点，我们考虑一个实际场景 [@problem_id:1344447]。一个工厂的关键组件在发生故障时会立即被更换。每个组件的寿命是一个[随机变量](@entry_id:195330)，其[分布函数](@entry_id:145626)为 $F(t)$。假设我们已知在运行 $t=500$ 小时后，有 $F(500) = 0.40$ 和 $m(500) = 0.55$。这两个数值的实际意义是什么？

*   $F(500) = 0.40$ 意味着任意一个新安装的组件，在其自身投入使用后的 500 小时内发生故障的概率是 $0.40$。这完全是关于单个组件寿命的陈述。具体来说，对于系统在 $t=0$ 时安装的第一个组件，它在时刻 $500$ 之前失效的概率是 $40\%$。

*   $m(500) = 0.55$ 意味着从系统开始运行（$t=0$）到 $t=500$ 小时这个时间段内，我们期望总共发生了 $0.55$ 次更换。这个数值是一个平均值。在许多相同的、独立运行的系统中，有些可能在 500 小时内没有发生更换（如果第一个组件寿命超过 500 小时），有些可能发生了一次更换（如果第一个组件失效，但第二个组件的寿命足够长），甚至可能发生了多次更换。所有这些可能性的平均结果是 $0.55$ 次更换。

这个例子清晰地表明，$F(t)$ 是一个概率，取值在 $[0, 1]$ 之间；而 $m(t)$ 是一个[期望计数](@entry_id:162854)值，可以取任何非负实数。

### 更新函数的基本性质

从定义出发，我们可以推导出更新函数的一些普适性质，这些性质不依赖于具体的事件间隔[分布](@entry_id:182848) $F(t)$。

1.  **初始值**: 只要事件间隔时间是严格为正的，即 $P(X_i > 0) = 1$，那么在 $t=0$ 的瞬间，不可能有任何更新事件发生。因为第一次更新的时间 $S_1 = X_1 > 0$（[几乎必然](@entry_id:262518)）。因此，[计数过程](@entry_id:260664) $N(0)$ 的值必然为 $0$，其期望也为 $0$ [@problem_id:1344462]。
    $$
    m(0) = E[N(0)] = 0
    $$

2.  **[单调性](@entry_id:143760)**: 考虑任意两个时间点 $0 \le t_1  t_2$。由于时间只会向前流逝，在更长的时间区间内观察到的事件次数，必然不会少于在较短时间区间内观察到的次数。对于任意一个样本路径（即一次具体的实现），我们都有 $N(t_2) \ge N(t_1)$。根据期望的单调性，对两边取期望，我们得到 [@problem_id:1344450]：
    $$
    m(t_2) = E[N(t_2)] \ge E[N(t_1)] = m(t_1)
    $$
    因此，**更新函数 $m(t)$ 是一个关于时间 $t$ 的非减函数**。值得注意的是，这里的关系是大于等于。如果存在某个时间段内发生更新的概率为零（例如，在确定性更新中），那么在那个时间段内更新函数可能是一个常数。

3.  **与 $F(t)$ 的关系**: 更新函数与事件间隔的分布函数之间存在一个基本的不等式关系。在时间 $t$ 之前发生的更新次数 $N(t)$ 至少是 $1$ 的条件是，第一次更新必须在时间 $t$ 之前发生，即 $S_1 = X_1 \le t$。我们可以用[指示函数](@entry_id:186820)来表示这个关系：$N(t) \ge \mathbf{1}_{\{S_1 \le t\}}$。对这个不等式两边取期望，我们得到 [@problem_id:1344449]：
    $$
    m(t) = E[N(t)] \ge E[\mathbf{1}_{\{S_1 \le t\}}] = P(S_1 \le t) = F(t)
    $$
    所以，我们有普适的不等式 **$m(t) \ge F(t)$**。这个不等式的直观解释是，在 $[0, t]$ 区间内的期望更新次数，至少等于第一次更新在该区间内发生的概率。

此外，可以证明，只要事件间隔的平均时间 $\mu = E[X_i]$ 是正的，那么对于任意有限的时间 $t$，更新函数 $m(t)$ 都是有限的。

### [更新方程](@entry_id:264802)：一个基本关系

为了进行更深入的分析和计算，我们需要一个能够连接 $m(t)$ 和 $F(t)$ 的方程。这个方程可以通过对第一次更新发生的时间 $X_1$ 进行条件化来推导，这是一种在[随机过程](@entry_id:159502)中极其有力的思想。

让我们来计算 $m(t) = E[N(t)]$。我们将根据 $X_1$ 的值来分解这个期望：
*   如果第一次更新发生在时间 $x$（其中 $x  t$），那么在区间 $[0, t]$ 内没有更新发生，所以 $N(t) = 0$。
*   如果第一次更新发生在时间 $x$（其中 $x \le t$），那么在区间 $[0, t]$ 内至少有一次更新（即在 $x$ 时刻的这一次）。在此之后，从时间 $x$ 开始，过程“重新启动”了。在剩下的时间 $t-x$ 内，我们期望发生的更新次数，根据更新过程的定义，恰好是 $m(t-x)$。因此，当 $X_1=x \le t$ 时，总的期望更新次数是 $1 + m(t-x)$。

综合这两种情况，并对 $X_1$ 的所有可[能值](@entry_id:187992)进行积分（使用[全期望公式](@entry_id:267929)），我们得到：
$$
m(t) = \int_0^\infty E[N(t) | X_1=x] dF(x)
$$
其中 $dF(x)$ 是 $X_1$ 在 $x$ 附近的概率元。根据上面的分析：
$$
m(t) = \int_0^t (1 + m(t-x)) dF(x) + \int_t^\infty 0 \cdot dF(x)
$$
展开第一项积分，我们便得到了**基本[更新方程](@entry_id:264802) (Elementary Renewal Equation)**：
$$
m(t) = \int_0^t dF(x) + \int_0^t m(t-x) dF(x)
$$
注意到 $\int_0^t dF(x) = P(X_1 \le t) = F(t)$，方程可以写成更简洁的形式：
$$
m(t) = F(t) + \int_0^t m(t-x) dF(x)
$$
这个方程是一个沃尔泰拉第二类积分方程。它表明，$t$ 时刻的期望更新数 $m(t)$ 等于两部分之和：(1) 第一次更新在 $t$ 之前发生的概率 $F(t)$，加上 (2) 第一次更新发生在某个时间 $x \le t$ 后，在剩余时间 $t-x$ 内的期望更新数 $m(t-x)$，对所有可能的 $x$ 进行加权平均。

### 求解更新函数

[更新方程](@entry_id:264802)为我们计算 $m(t)$ 提供了理论基础。然而，直接解这个积分方程通常很困难。我们来看两种重要的方法。

#### 特例：泊松过程

最简单也最重要的更新过程是泊松过程。当事件间隔时间 $X_i$ 服从参数为 $\lambda$ 的指数分布时，即 $F(t) = 1 - \exp(-\lambda t)$，更新过程就是一个泊松过程。我们已知泊松过程的[期望计数](@entry_id:162854)值是 $E[N(t)] = \lambda t$。因此，对于指数分布的事件间隔，更新函数就是 $m(t) = \lambda t$。

我们可以通过将 $m(t) = \lambda t$ 代入[更新方程](@entry_id:264802)来验证这个著名的结果。我们需要计算方程的右侧：
$F(t) + \int_0^t m(t-x) dF(x)$。
对于指数分布，其概率密度函数 (PDF) 为 $f(x) = \lambda \exp(-\lambda x)$，所以 $dF(x) = f(x)dx$。
卷积项为 [@problem_id:1344443]：
$$
C(t) = \int_0^t m(t-x) f(x) dx = \int_0^t \lambda(t-x) \cdot \lambda \exp(-\lambda x) dx
$$
$$
C(t) = \lambda^2 \left( t \int_0^t \exp(-\lambda x) dx - \int_0^t x \exp(-\lambda x) dx \right)
$$
通过标准积分计算（第二项使用分部积分法），我们得到：
$$
\int_0^t \exp(-\lambda x) dx = \frac{1}{\lambda}(1 - \exp(-\lambda t))
$$
$$
\int_0^t x \exp(-\lambda x) dx = \frac{1}{\lambda^2}(1 - \exp(-\lambda t)) - \frac{t}{\lambda}\exp(-\lambda t)
$$
代入 $C(t)$ 的表达式，得到：
$$
C(t) = \lambda^2 \left( t \frac{1}{\lambda}(1 - \exp(-\lambda t)) - \left[ \frac{1}{\lambda^2}(1 - \exp(-\lambda t)) - \frac{t}{\lambda}\exp(-\lambda t) \right] \right) = \lambda t - 1 + \exp(-\lambda t)
$$
现在，我们将 $F(t)$ 和 $C(t)$ 加起来：
$$
F(t) + C(t) = (1 - \exp(-\lambda t)) + (\lambda t - 1 + \exp(-\lambda t)) = \lambda t
$$
这恰好等于方程的左侧 $m(t)$。因此，我们验证了 $m(t) = \lambda t$ 确实是指数间隔更新过程的解。

#### 使用拉普拉斯变换

对于更一般的[分布](@entry_id:182848) $F(t)$，拉普拉斯变换是求解[更新方程](@entry_id:264802)的利器。其关键优势在于它能将卷积（如[更新方程](@entry_id:264802)中的积分项）转化为简单的乘积。

让我们用 $\tilde{g}(s) = \mathcal{L}\{g(t)\}(s) = \int_0^\infty \exp(-st) g(t) dt$ 表示函数 $g(t)$ 的[拉普拉斯变换](@entry_id:159339)。[更新方程](@entry_id:264802) $m(t) = F(t) + (m*f)(t)$，其中 $*$ 代表卷积，其[拉普拉斯变换](@entry_id:159339)形式为：
$$
\tilde{m}(s) = \tilde{F}(s) + \tilde{m}(s) \tilde{f}(s)
$$
这里 $\tilde{f}(s)$ 是 PDF $f(t)$ 的[拉普拉斯变换](@entry_id:159339)，并且有关系 $\tilde{F}(s) = \frac{1}{s}\tilde{f}(s)$。
重新整理上式，我们可以解出 $\tilde{m}(s)$：
$$
\tilde{m}(s) (1 - \tilde{f}(s)) = \tilde{F}(s) = \frac{\tilde{f}(s)}{s} \implies \tilde{m}(s) = \frac{\tilde{f}(s)}{s(1 - \tilde{f}(s))}
$$
这个公式提供了一条求解 $m(t)$ 的系统路径：
1.  计算事件间隔PDF $f(t)$ 的拉普拉斯变换 $\tilde{f}(s)$。
2.  将 $\tilde{f}(s)$ 代入上式，得到 $\tilde{m}(s)$。
3.  通过[逆拉普拉斯变换](@entry_id:261877)求得 $m(t) = \mathcal{L}^{-1}\{\tilde{m}(s)\}(t)$。

让我们通过一个例子来演示这个过程 [@problem_id:1344440]。假设事件间隔时间服从[形状参数](@entry_id:270600)为2，速[率参数](@entry_id:265473)为 $\lambda$ 的[爱尔朗分布](@entry_id:264616)（Erlang distribution），其PDF为 $f(t) = \lambda^2 t \exp(-\lambda t)$。

**步骤 1: 计算 $\tilde{f}(s)$**
$$
\tilde{f}(s) = \int_0^\infty \exp(-st) (\lambda^2 t \exp(-\lambda t)) dt = \lambda^2 \int_0^\infty t \exp(-(s+\lambda)t) dt = \frac{\lambda^2}{(s+\lambda)^2}
$$

**步骤 2: 求解 $\tilde{m}(s)$**
$$
\tilde{m}(s) = \frac{1}{s} \frac{\frac{\lambda^2}{(s+\lambda)^2}}{1 - \frac{\lambda^2}{(s+\lambda)^2}} = \frac{1}{s} \frac{\lambda^2}{(s+\lambda)^2 - \lambda^2} = \frac{\lambda^2}{s(s^2 + 2\lambda s)} = \frac{\lambda^2}{s^2(s+2\lambda)}
$$

**步骤 3: [逆变](@entry_id:192290)换 $\tilde{m}(s)$**
我们使用[部分分式分解](@entry_id:159208)法：
$$
\frac{\lambda^2}{s^2(s+2\lambda)} = \frac{A}{s} + \frac{B}{s^2} + \frac{C}{s+2\lambda}
$$
解得系数为 $B = \frac{\lambda}{2}$, $A = -\frac{1}{4}$, $C = \frac{1}{4}$。
因此，
$$
\tilde{m}(s) = -\frac{1}{4} \cdot \frac{1}{s} + \frac{\lambda}{2} \cdot \frac{1}{s^2} + \frac{1}{4} \cdot \frac{1}{s+2\lambda}
$$
利用已知的[拉普拉斯变换](@entry_id:159339)对 $\mathcal{L}^{-1}\{\frac{1}{s}\} = 1$, $\mathcal{L}^{-1}\{\frac{1}{s^2}\} = t$, 和 $\mathcal{L}^{-1}\{\frac{1}{s+a}\} = \exp(-at)$，我们逐项进行[逆变](@entry_id:192290)换，得到最终的更新函数：
$$
m(t) = -\frac{1}{4} + \frac{\lambda t}{2} + \frac{1}{4}\exp(-2\lambda t) = \frac{\lambda t}{2} + \frac{1}{4}(\exp(-2\lambda t) - 1)
$$
这个例子展示了[拉普拉斯变换](@entry_id:159339)方法在求解更新[函数问题](@entry_id:261628)上的强大威力。

### 渐近行为：基本更新定理

虽然我们可以为某些特定的[分布](@entry_id:182848)求出 $m(t)$ 的精确表达式，但在许多情况下，这非常困难。然而，[更新理论](@entry_id:263249)中最深刻和有用的结果之一是关于 $m(t)$ 在 $t \to \infty$ 时的行为，这由**基本更新定理 (Elementary Renewal Theorem, ERT)** 描述。

**定理：基本更新定理**
 如果事件间隔时间 $X_i$ 的均值 $\mu = E[X_i]$ 是有限的，那么：
 $$
 \lim_{t \to \infty} \frac{m(t)}{t} = \frac{1}{\mu}
 $$

这个定理的含义是，随着时间的推移，更新事件发生的**长期平均速率**收敛于 $1/\mu$。这非常符合直觉：如果平均每 $\mu$ 个时间单位发生一次事件，那么事件的发生率就应该是 $1/\mu$。

该定理最重要的一个推论是，对于很大的 $t$ 值，我们可以使用一个简单的线性函数来近似 $m(t)$：
$$
m(t) \approx \frac{t}{\mu} \quad (\text{for large } t)
$$
这使得我们能够估算在很长一段时间内发生的事件数量，而无需知道事件间隔时间的完整[分布](@entry_id:182848)，只需要知道其均值即可。

例如，考虑一个需要持续更换灯泡的场景 [@problem_id:1344456]。A 品牌灯泡的平均寿命 $\mu_A = 1000$ 小时，而 B 品牌灯泡的[平均寿命](@entry_id:195236) $\mu_B = 1200$ 小时。在一个连续运行 5 年（即 $5 \times 365 \times 24 = 43800$ 小时）的时间里，我们可以用 ERT 的结论来估计更换次数。
*   使用 A 品牌，期望更换次数约为 $m_A(43800) \approx \frac{43800}{1000} = 43.8$ 次。
*   使用 B 品牌，期望更换次数约为 $m_B(43800) \approx \frac{43800}{1200} = 36.5$ 次。
因此，在 5 年内，使用 A 品牌预计比 B 品牌多更换约 $43.8 - 36.5 = 7.3$ 个灯泡。

在某些应用中，一个“更新周期”本身可能包含多个阶段。ERT 仍然适用，但我们需要正确地计算整个周期的平均时长 $\mu$。例如，一种[自愈合材料](@entry_id:159093)，每次出现微裂缝后，会经历一个平均时长为 $\mu_h = 10$ 小时的愈合阶段，之后是一个平均时长为 $\mu_w = 150$ 小时的等待阶段，然后新的裂缝才会出现 [@problem_id:1344469]。在这里，一次“更新”（即一次新裂缝的形成）的完整周期时间是愈合时间加上等待时间。因此，平均周期长度为 $\mu = \mu_h + \mu_w = 10 + 150 = 160$ 小时。根据 ERT，该材料形成微裂缝的长期速率为 $1/\mu = 1/160$ 次/小时。换算成每天的次数，就是 $24 \times (1/160) = 0.15$ 次/天。

### 更新模型的扩展

标准的[更新过程](@entry_id:273573)模型可以通过多种方式进行扩展，以适应更广泛的现实世界问题。

#### [延迟更新过程](@entry_id:263025)

在标准更新过程中，我们假设第一个事件间隔 $X_1$ 与所有后续的间隔 $X_2, X_3, \dots$ 来自同一个[分布](@entry_id:182848)。然而，在某些情况下，第一个间隔可能具有不同的[分布](@entry_id:182848)。例如，一个全新设备的第一次故障时间[分布](@entry_id:182848)，可能不同于它被修复或更换后的后续故障时间[分布](@entry_id:182848)。这种过程称为**[延迟更新过程](@entry_id:263025) (Delayed Renewal Process)**。

令第一个事件间隔 $X_1$ 的[分布](@entry_id:182848)为 $F_D(t)$，而所有后续间隔 $X_i (i \ge 2)$ 的[分布](@entry_id:182848)为 $F(t)$。该过程的更新函数记为 $m_D(t)$。我们可以通过类似的条件化方法推导其[更新方程](@entry_id:264802)，即对第一次更新的时间 $X_1$ 的取值 $x$ 进行条件化：
*   如果 $x > t$，则 $N_D(t) = 0$。
*   如果 $x \le t$，则在 $x$ 时刻发生一次更新。在此之后，过程从 $x$ 时刻开始，变成了一个以 $F(t)$ 为间隔[分布](@entry_id:182848)的**普通**[更新过程](@entry_id:273573)。在剩下的 $t-x$ 时间里，期望的更新次数是 $m(t-x)$，其中 $m(t)$ 是对应于 $F(t)$ 的普通更新函数。

因此，延迟更新函数 $m_D(t)$ 满足：
$$
m_D(t) = \int_0^t (1 + m(t-x)) dF_D(x) = F_D(t) + \int_0^t m(t-x) dF_D(x)
$$

考虑一个深空探测器上的传感器阵列 [@problem_id:1344468]。初始传感器的寿命服从速率为 $\lambda_D$ 的指数分布，而所有后续更换的传感器寿命服从速率为 $\lambda$ 的指数分布。这里的 $m(t)$ 是由速率为 $\lambda$ 的[指数分布](@entry_id:273894)产生的普通更新函数，即 $m(t)=\lambda t$。
$m_D(t)$ 可以通[过积分](@entry_id:753033)直接求得：
$$
m_D(t) = \int_0^t (1 + \lambda(t-x)) \lambda_D \exp(-\lambda_D x) dx
$$
$$
m_D(t) = \lambda_D \int_0^t \exp(-\lambda_D x) dx + \lambda\lambda_D \int_0^t (t-x)\exp(-\lambda_D x) dx
$$
计算这两个积分，我们得到：
$$
m_D(t) = (1 - \exp(-\lambda_D t)) + \lambda \left( t - \frac{1}{\lambda_D}(1 - \exp(-\lambda_D t)) \right)
$$
整理后得到最终表达式：
$$
m_D(t) = \lambda t + \left(1 - \frac{\lambda}{\lambda_D}\right)(1 - \exp(-\lambda_D t))
$$
这个结果显示了[初始条件](@entry_id:152863)如何影响系统的瞬态行为。当 $t \to \infty$ 时，$\exp(-\lambda_D t) \to 0$， $m_D(t) \approx \lambda t + (1 - \lambda/\lambda_D)$。其增长率 $\frac{d}{dt}m_D(t)$ 趋向于 $\lambda$，与后续更新的速率一致，这符合我们的直觉。

#### [更新回报过程](@entry_id:271905)

另一个重要的扩展是**[更新回报过程](@entry_id:271905) (Renewal-Reward Process)**。在这种模型中，每次更新事件发生时，我们都会获得一个“回报”或产生一笔“成本”。令第 $k$ 次更新发生在时间 $S_k$，与之相关的回报为 $R_k$。我们通常关心到时间 $t$ 为止的总期望回报，$M(t) = E\left[\sum_{k=1}^{N(t)} R_k\right]$。

回报 $R_k$ 本身可以是随机的，并且可能与导致它的事件间隔 $X_k$ 相关。一个重要的特例是 $R_k = g(X_k)$，即回报是前一个间隔时长的某个函数。

计算 $M(t)$ 的一个直接方法是逐项计算期望：
$$
M(t) = E\left[\sum_{k=1}^\infty R_k \mathbf{1}_{\{S_k \le t\}}\right] = \sum_{k=1}^\infty E[R_k \mathbf{1}_{\{S_k \le t\}}]
$$
这种计算通常很复杂，因为它需要知道每次更新时间 $S_k$ 的[分布](@entry_id:182848)。

让我们来看一个具体的例子 [@problem_id:1344457]。一个通信卫星的组件需要定期维护，维护间隔时间 $X_k$ 服从 $[1, 2]$ 年的[均匀分布](@entry_id:194597)。第 $k$ 次维护的成本与自上次维护以来的时间 $X_k$ 的平方成正比，即 $R_k = c X_k^2$，其中 $c=100$（千美元/年²）。我们想计算到 $t=3.5$ 年时的总期望成本 $M(3.5)$。

由于 $X_k \ge 1$，在 $t=3.5$ 年时，最多可能发生 3 次维护（$S_1 \in [1,2]$, $S_2 \in [2,4]$, $S_3 \in [3,6]$）。因此，求和只需要到 $k=3$：
$$
M(3.5) = E[R_1 \mathbf{1}_{\{S_1 \le 3.5\}}] + E[R_2 \mathbf{1}_{\{S_2 \le 3.5\}}] + E[R_3 \mathbf{1}_{\{S_3 \le 3.5\}}]
$$
每个期望项都需要通[过积分](@entry_id:753033)来计算。例如，对于第二项：
$$
E[R_2 \mathbf{1}_{\{S_2 \le 3.5\}}] = E[c X_2^2 \mathbf{1}_{\{X_1+X_2 \le 3.5\}}]
$$
由于 $X_1$ 和 $X_2$ 是独立的，这个期望可以通过对它们的[联合密度函数](@entry_id:263624)积分来得到。这是一个相当繁琐的计算，涉及到对 $X_1$ 和 $X_2$ 的[分布](@entry_id:182848)进行卷积，然后进行带条件的积分。对于这个问题，经过仔细的计算：
*   第1次维护的期望成本贡献为 $c \cdot E[X_1^2 \mathbf{1}_{\{X_1 \le 3.5\}}] \approx c \cdot 2.333$。
*   第2次维护的期望成本贡献为 $c \cdot E[X_2^2 \mathbf{1}_{\{X_1+X_2 \le 3.5\}}] \approx c \cdot 1.911$。
*   第3次维护的期望成本贡献为 $c \cdot E[X_3^2 \mathbf{1}_{\{X_1+X_2+X_3 \le 3.5\}}] \approx c \cdot 0.027$。

将它们相加并乘以常数 $c=100$，得到总期望成本 $M(3.5) \approx 100 \times (2.333 + 1.911 + 0.027) \approx 427$ 千美元。这个例子虽然计算复杂，但它展示了更新回报框架在解决涉及累积成本或收益的实际工程和经济问题中的强大能力。

本章我们系统地研究了更新函数，从它的定义、基本性质，到求解它的核心工具——[更新方程](@entry_id:264802)，再到它的长期行为和在更复杂模型中的应用。更新函数是理解和分析重复事件[随机过程](@entry_id:159502)的基石。