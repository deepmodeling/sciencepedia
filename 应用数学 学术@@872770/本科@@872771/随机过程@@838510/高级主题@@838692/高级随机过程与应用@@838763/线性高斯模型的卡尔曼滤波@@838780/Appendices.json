{"hands_on_practices": [{"introduction": "卡尔曼滤波器的核心在于其更新步骤，即如何将先前的预测与新的测量结果相结合，以获得更精确的估计。这个练习提供了一个绝佳的起点，通过一个简单的标量系统（测量生物反应器温度）来隔离并实践这一关键机制。通过计算更新后的状态估计，您将亲身体验滤波器如何根据预测和测量的不确定性，智能地加权信息 [@problem_id:1339626]。", "problem": "一名技术人员正在使用数字控制系统监测一个小型实验性生物反应器的内部温度。该系统采用卡尔曼滤波器来估计会发生波动的真实温度。设离散时间步 $k$ 的真实温度表示为 $x_k$。\n\n在特定的时间步 $k$，系统的动态模型根据先前的数据，提供了一个预测温度（*先验*状态估计）为 $\\hat{x}_{k|k-1} = 85.2^\\circ C$。与该预测相关的方差（*先验*误差协方差）为 $P_{k|k-1} = 1.5\\ (^\\circ C)^2$，表示模型的不确定性。\n\n一个温度传感器提供了一个测量值 $z_k$。测量模型由 $z_k = H x_k + v_k$ 给出，其中 $H=1$（传感器直接测量温度），$v_k$ 是一个代表传感器不准确性的零均值高斯噪声项。该测量噪声的方差指定为 $R = 0.6\\ (^\\circ C)^2$。\n\n在此时间步 $k$，传感器返回的测量值为 $z_k = 84.1^\\circ C$。\n\n使用线性卡尔曼滤波器的单次更新步骤，计算在结合这个新测量值后的更新温度估计（*后验*状态估计）$\\hat{x}_{k|k}$。将您的最终答案以摄氏度表示，并四舍五入到四位有效数字。", "solution": "我们对一个标量系统使用标准的线性卡尔曼滤波器测量更新。测量模型为 $z_{k} = H x_{k} + v_{k}$，其中 $H=1$ 且测量噪声方差为 $R$。给定先验估计 $\\hat{x}_{k|k-1}$ 和协方差 $P_{k|k-1}$，卡尔曼增益为\n$$\nK_{k} = \\frac{P_{k|k-1} H^{\\top}}{H P_{k|k-1} H^{\\top} + R}.\n$$\n当 $H=1$ 时，这简化为\n$$\nK_{k} = \\frac{P_{k|k-1}}{P_{k|k-1} + R}.\n$$\n代入给定值 $P_{k|k-1} = 1.5$ 和 $R = 0.6$，\n$$\nK_{k} = \\frac{1.5}{1.5 + 0.6} = \\frac{1.5}{2.1} = \\frac{5}{7}.\n$$\n新息（测量残差）为\n$$\ny_{k} = z_{k} - H \\hat{x}_{k|k-1} = 84.1 - 85.2 = -1.1.\n$$\n后验状态估计为\n$$\n\\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_{k} y_{k} = 85.2 + \\frac{5}{7}(-1.1) = 85.2 - \\frac{11}{14}.\n$$\n数值上，\n$$\n85.2 - \\frac{11}{14} = 84.414285714\\ldots\n$$\n四舍五入到四位有效数字，结果是 $84.41$。", "answer": "$$\\boxed{84.41}$$", "id": "1339626"}, {"introduction": "在掌握了标量系统的基础后，我们将进入更真实的多维世界。这个练习将卡尔曼滤波器应用于一个二维系统，同时跟踪一个物体的位置和速度，这在机器人和导航等领域非常常见。通过执行一个完整的“预测-更新”周期，您将学会如何使用矩阵运算来处理多个相关状态变量及其不确定性，从而更深入地理解滤波器的强大功能 [@problem_id:2888322]。", "problem": "一个用于描述一维空间中匀速运动的离散时间线性时不变 (LTI) 状态空间模型由以下随机差分方程给出\n$$\nx_{k+1} = A x_{k} + w_{k}, \\quad y_{k} = C x_{k} + v_{k},\n$$\n其中 $x_{k} \\in \\mathbb{R}^{2}$ 是状态，其分量为位置和速度，$y_{k} \\in \\mathbb{R}$ 是位置测量值，$w_{k}$ 是协方差为 $Q$ 的零均值过程噪声，$v_{k}$ 是协方差为 $R$ 的零均值测量噪声。假设采样间隔为 $1$ 个时间单位，因此\n$$\nA = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix}, \\quad C = \\begin{bmatrix} 1  0 \\end{bmatrix}, \\quad Q = \\operatorname{diag}(0.01,\\,0.01), \\quad R = \\begin{bmatrix} 0.04 \\end{bmatrix}.\n$$\n假设在时间 $k=0$ 时的初始后验误差协方差为\n$$\nP_{0} = I_{2}.\n$$\n从该先验开始，执行一个完整的卡尔曼滤波器 (KF) 预测-更新周期，以获得在时间 $k=1$ 时的后验误差协方差。你的推导应从估计误差协方差和线性高斯系统的最小方差线性估计器的定义开始，然后进行用于预测和更新的协方差递推。计算协方差更新所需的所有中间量，但最终答案只报告在时间 $k=1$ 时的后验误差协方差矩阵。将报告的每个矩阵元素四舍五入到 $4$ 位有效数字。不需要物理单位。", "solution": "目标是计算在时间 $k=1$ 时的后验误差协方差矩阵，记为 $P_{1|1}$，而已知在时间 $k=0$ 时的后验误差协方差，记为 $P_{0|0}$。卡尔曼滤波器通过一个两步递归循环——预测（时间更新）步骤和更新（测量更新）步骤——来传播状态估计及其误差协方差，从而为带有高斯噪声的线性系统提供最优线性估计器。\n\n协方差传播方程如下。\n预测：\n$$\nP_{k|k-1} = A P_{k-1|k-1} A^T + Q\n$$\n更新：\n$$\nK_k = P_{k|k-1} C^T (C P_{k|k-1} C^T + R)^{-1}\n$$\n$$\nP_{k|k} = (I - K_k C) P_{k|k-1}\n$$\n此处，$P_{k|k-1}$ 是在时间 $k$ 时的先验误差协方差，$P_{k|k}$ 是在时间 $k$ 时的后验误差协方差。$K_k$ 是卡尔曼增益。\n\n给定的参数如下：\n状态转移矩阵：$A = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix}$\n测量矩阵：$C = \\begin{bmatrix} 1  0 \\end{bmatrix}$\n过程噪声协方差：$Q = \\begin{bmatrix} 0.01  0 \\\\ 0  0.01 \\end{bmatrix}$\n测量噪声协方差：$R = [0.04]$\n在 $k=0$ 时的初始后验误差协方差：$P_{0|0} = I_2 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$\n\n我们现在对 $k=1$ 执行一个完整的周期。\n\n**步骤 1：预测（时间更新）**\n\n我们使用在 $k=0$ 时的协方差状态来计算在 $k=1$ 时的先验误差协方差 $P_{1|0}$。\n$$\nP_{1|0} = A P_{0|0} A^T + Q\n$$\n代入给定值：\n$$\nA P_{0|0} A^T = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 1  1 \\end{bmatrix} = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 1  1 \\end{bmatrix} = \\begin{bmatrix} 1 \\cdot 1 + 1 \\cdot 1  1 \\cdot 0 + 1 \\cdot 1 \\\\ 0 \\cdot 1 + 1 \\cdot 1  0 \\cdot 0 + 1 \\cdot 1 \\end{bmatrix} = \\begin{bmatrix} 2  1 \\\\ 1  1 \\end{bmatrix}\n$$\n现在，我们加上过程噪声协方差 $Q$：\n$$\nP_{1|0} = \\begin{bmatrix} 2  1 \\\\ 1  1 \\end{bmatrix} + \\begin{bmatrix} 0.01  0 \\\\ 0  0.01 \\end{bmatrix} = \\begin{bmatrix} 2.01  1 \\\\ 1  1.01 \\end{bmatrix}\n$$\n这是在并入 $k=1$ 时的测量值之前的预测误差协方差。\n\n**步骤 2：更新（测量更新）**\n\n首先，我们计算新息协方差，记为 $S_1$：\n$$\nS_1 = C P_{1|0} C^T + R\n$$\n$$\nC P_{1|0} C^T = \\begin{bmatrix} 1  0 \\end{bmatrix} \\begin{bmatrix} 2.01  1 \\\\ 1  1.01 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 2.01  1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = [2.01]\n$$\n$$\nS_1 = [2.01] + [0.04] = [2.05]\n$$\n接下来，我们计算卡尔曼增益 $K_1$：\n$$\nK_1 = P_{1|0} C^T S_1^{-1}\n$$\n$$\nP_{1|0} C^T = \\begin{bmatrix} 2.01  1 \\\\ 1  1.01 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 2.01 \\\\ 1 \\end{bmatrix}\n$$\n$$\nK_1 = \\begin{bmatrix} 2.01 \\\\ 1 \\end{bmatrix} [2.05]^{-1} = \\begin{bmatrix} \\frac{2.01}{2.05} \\\\ \\frac{1}{2.05} \\end{bmatrix}\n$$\n最后，我们计算后验误差协方差 $P_{1|1}$：\n$$\nP_{1|1} = (I - K_1 C) P_{1|0}\n$$\n我们来计算 $(I - K_1 C)$ 这一项：\n$$\nK_1 C = \\begin{bmatrix} \\frac{2.01}{2.05} \\\\ \\frac{1}{2.05} \\end{bmatrix} \\begin{bmatrix} 1  0 \\end{bmatrix} = \\begin{bmatrix} \\frac{2.01}{2.05}  0 \\\\ \\frac{1}{2.05}  0 \\end{bmatrix}\n$$\n$$\nI - K_1 C = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} \\frac{2.01}{2.05}  0 \\\\ \\frac{1}{2.05}  0 \\end{bmatrix} = \\begin{bmatrix} 1 - \\frac{2.01}{2.05}  0 \\\\ -\\frac{1}{2.05}  1 \\end{bmatrix} = \\begin{bmatrix} \\frac{0.04}{2.05}  0 \\\\ -\\frac{1}{2.05}  1 \\end{bmatrix}\n$$\n现在我们进行最后的矩阵乘法：\n$$\nP_{1|1} = \\begin{bmatrix} \\frac{0.04}{2.05}  0 \\\\ -\\frac{1}{2.05}  1 \\end{bmatrix} \\begin{bmatrix} 2.01  1 \\\\ 1  1.01 \\end{bmatrix}\n$$\n$$\nP_{1|1} = \\begin{bmatrix} (\\frac{0.04}{2.05})(2.01) + (0)(1)  (\\frac{0.04}{2.05})(1) + (0)(1.01) \\\\ (-\\frac{1}{2.05})(2.01) + (1)(1)  (-\\frac{1}{2.05})(1) + (1)(1.01) \\end{bmatrix}\n$$\n$$\nP_{1|1} = \\begin{bmatrix} \\frac{0.0804}{2.05}  \\frac{0.04}{2.05} \\\\ \\frac{-2.01 + 2.05}{2.05}  \\frac{-1 + 1.01 \\cdot 2.05}{2.05} \\end{bmatrix} = \\begin{bmatrix} \\frac{0.0804}{2.05}  \\frac{0.04}{2.05} \\\\ \\frac{0.04}{2.05}  \\frac{1.0705}{2.05} \\end{bmatrix}\n$$\n问题要求将矩阵元素四舍五入到 $4$ 位有效数字。\n$$\nP_{1|1}(1,1) = \\frac{0.0804}{2.05} \\approx 0.0392195... \\approx 0.03922\n$$\n$$\nP_{1|1}(1,2) = P_{1|1}(2,1) = \\frac{0.04}{2.05} \\approx 0.0195121... \\approx 0.01951\n$$\n$$\nP_{1|1}(2,2) = \\frac{1.0705}{2.05} \\approx 0.5221951... \\approx 0.5222\n$$\n因此，在 $k=1$ 时的后验误差协方差矩阵为：\n$$\nP_{1|1} \\approx \\begin{bmatrix} 0.03922  0.01951 \\\\ 0.01951  0.5222 \\end{bmatrix}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.03922  0.01951 \\\\ 0.01951  0.5222 \\end{pmatrix}}\n$$", "id": "2888322"}, {"introduction": "理论模型在现实世界中往往是不完美的。这个动手编程练习将引导您探索一个在实际应用中至关重要的问题：当模型参数（特别是测量噪声）被错误设定时，卡尔曼滤波器会如何表现？通过模拟一个宏观经济时间序列并比较正确与错误规格下的滤波结果，您将直观地看到并量化参数失配所导致的影响，例如估计滞后和平滑过度 [@problem_id:2441505]。", "problem": "您的任务是研究在计算经济学和金融学中使用的线性高斯状态空间模型中，错误指定测量噪声协方差所产生的影响。考虑一个潜在的宏观经济状态，该状态遵循一阶自回归（AR(1)）运动规律，并通过带噪声的观测得到。该潜在状态可以解释为潜在的产出缺口或动态因子模型中的潜在因子。数据生成过程由以下线性高斯状态空间模型定义：\n- 状态转移：$x_{t} = \\phi x_{t-1} + w_{t}$，其中 $w_{t} \\sim \\mathcal{N}(0, Q)$。\n- 测量：$y_{t} = x_{t} + v_{t}$，其中 $v_{t} \\sim \\mathcal{N}(0, R_{\\text{true}})$。\n\n您将实现卡尔曼滤波器（KF），以从 $y_{t}$ 中生成 $x_{t}$ 的滤波估计 $x_{t|t}$。这将在两种设定下进行：一种使用正确的测量噪声方差 $R_{\\text{true}}$，另一种使用被错误夸大的方差 $R_{\\text{hat}} = \\lambda R_{\\text{true}}$（其中 $\\lambda \\ge 1$），后者代表分析师认为测量值的噪声比实际情况更大。滤波器的起始先验必须是均值为 $0$、方差为 $P_{0} = Q/(1-\\phi^{2})$（当 $\\lvert \\phi \\rvert < 1$ 时 AR(1) 的无条件方差）的高斯分布。假设 $x_{0} = 0$。模拟噪声必须在时间上以及在状态和测量方程之间相互独立。\n\n您的任务：\n1. 对于提供的测试套件中的每一组参数，使用指定的随机种子从模型中模拟 $t = 1, \\dots, T$ 的 $(x_{t}, y_{t})$，以确保可复现性。对 $w_{t}$ 和 $v_{t}$ 使用具有规定方差的独立抽样。\n2. 从基本原理出发，实现适用于线性高斯系统的时间递归线性最小均方误差估计器（即卡尔曼滤波器），并对每组参数运行两次：一次使用 $R_{\\text{true}}$，另一次使用 $R_{\\text{hat}} = \\lambda R_{\\text{true}}$（其中 $\\lambda \\ge 1$）。\n3. 对每组参数，通过计算三个指标来量化夸大 $R$ 对滤波器的影响：\n   - 均方误差差异：$\\Delta \\text{MSE} = \\frac{1}{T}\\sum_{t=1}^{T} (x_{t} - \\hat{x}^{(\\text{mis})}_{t|t})^{2} - \\frac{1}{T}\\sum_{t=1}^{T} (x_{t} - \\hat{x}^{(\\text{true})}_{t|t})^{2}$，其中 $\\hat{x}^{(\\text{mis})}_{t|t}$ 是使用 $R_{\\text{hat}}$ 的滤波估计，而 $\\hat{x}^{(\\text{true})}_{t|t}$ 是使用 $R_{\\text{true}}$ 的滤波估计。\n   - 错误指定滤波器的估计滞后周期：$\\ell^{\\ast} = \\arg\\max_{\\ell \\in \\{0,1,\\dots,L_{\\max}\\}} \\mathrm{corr}(x_{t}, \\hat{x}^{(\\text{mis})}_{t-\\ell|t-\\ell})$，通过计算 $x_{t}$ 与滞后 $\\ell$ 个周期的滤波序列之间的样本相关性来经验性地计算，计算范围为所有两者都有定义的 $t$。使用 $L_{\\max} = 10$。\n   - 通过方差比衡量的平滑度差异：$\\Delta \\text{VR} = \\frac{\\mathrm{Var}(\\hat{x}^{(\\text{mis})}_{t|t})}{\\mathrm{Var}(x_{t})} - \\frac{\\mathrm{Var}(\\hat{x}^{(\\text{true})}_{t|t})}{\\mathrm{Var}(x_{t})}$，其中方差是在 $t=1,\\dots,T$ 上的经验样本方差。\n4. 在您的解决方案中，从基本原理出发，解释为什么夸大 $R$ 会减小卡尔曼增益，从而产生更平滑、更滞后的估计。\n\n测试套件：\n对于每个元组 $(\\phi, Q, R_{\\text{true}}, \\lambda, T, \\text{seed})$，模拟并计算上述三个指标。\n- 案例 A（一般情况）：$(\\phi, Q, R_{\\text{true}}, \\lambda, T, \\text{seed}) = (0.9, 0.05, 0.2, 5.0, 200, 123)$。\n- 案例 B（高信噪比，重度夸大）：$(0.9, 0.05, 0.05, 10.0, 200, 456)$。\n- 案例 C（近单位根状态）：$(0.99, 0.02, 0.1, 8.0, 300, 789)$。\n- 案例 D（高过程波动性）：$(0.6, 0.2, 0.2, 5.0, 200, 321)$。\n- 案例 E（边界情况，正确指定）：$(0.9, 0.05, 0.2, 1.0, 200, 999)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个以逗号分隔的列表的列表形式的结果。每个内部列表对应上述顺序的一个案例，并包含三个值：$[\\Delta \\text{MSE}, \\ell^{\\ast}, \\Delta \\text{VR}]$。第一个和第三个条目是四舍五入到六位小数的浮点数；中间的条目是整数。例如：$[[0.012345,2,-0.123456],[\\dots],\\dots]$。\n- 不应打印任何额外文本。", "solution": "首先，我们形式化这个标量系统的状态空间模型。状态方程为：\n$$ x_{t} = \\phi x_{t-1} + w_{t}, \\quad w_{t} \\sim \\mathcal{N}(0, Q) $$\n测量方程为：\n$$ y_{t} = x_{t} + v_{t}, \\quad v_{t} \\sim \\mathcal{N}(0, R) $$\n这里，测量矩阵 $H$ 是单位矩阵，我们表示为 $1$。状态转移矩阵 $F$ 是标量 $\\phi$。\n\n卡尔曼滤波器提供了一个递归算法，用于计算在给定截至时间 $t$ 的观测值的情况下，状态 $x_t$ 的最优线性估计，记为 $\\hat{x}_{t|t} = \\mathbb{E}[x_t | y_1, \\dots, y_t]$。该算法在每个时间增量中分两步进行：预测和更新。\n\n递归在 $t=0$ 时用先验估计 $\\hat{x}_{0|0}$ 及其误差协方差 $P_{0|0} = \\mathbb{E}[(x_0 - \\hat{x}_{0|0})^2]$ 进行初始化。问题指定使用平稳先验，因此我们设置 $\\hat{x}_{0|0} = 0$ 和 $P_{0|0} = Q / (1 - \\phi^2)$。\n\n对于 $t = 1, 2, \\dots, T$：\n\n1.  **预测（时间更新）：** 这一步将状态和协方差估计从时间 $t-1$ 投影到时间 $t$。\n    - 预测的状态估计为：\n      $$ \\hat{x}_{t|t-1} = \\phi \\hat{x}_{t-1|t-1} $$\n    - 预测的误差协方差为：\n      $$ P_{t|t-1} = \\phi^{2} P_{t-1|t-1} + Q $$\n\n2.  **更新（测量更新）：** 这一步结合了新的测量值 $y_t$ 来修正预测估计。\n    - 新息（或测量残差）是实际测量值与其预测值之间的差：\n      $$ \\nu_t = y_t - \\hat{x}_{t|t-1} $$\n    - 新息协方差为：\n      $$ S_t = P_{t|t-1} + R $$\n    - 最优卡尔曼增益 $K_t$ 决定了赋予新息多大的权重。它的计算旨在最小化后验误差协方差 $P_{t|t}$：\n      $$ K_t = \\frac{P_{t|t-1}}{S_t} = \\frac{P_{t|t-1}}{P_{t|t-1} + R} $$\n    - 更新后（滤波后）的状态估计是预测估计和测量信息的加权平均：\n      $$ \\hat{x}_{t|t} = \\hat{x}_{t|t-1} + K_t \\nu_t $$\n    - 更新后的误差协方差为：\n      $$ P_{t|t} = (1 - K_t) P_{t|t-1} $$\n\n现在，考虑错误指定 $R$ 的影响。分析师使用 $R_{\\text{hat}} = \\lambda R_{\\text{true}}$（其中 $\\lambda > 1$），认为测量值的噪声比实际情况更大。这解答了任务 4。\n\n在这种错误指定下的卡尔曼增益变为：\n$$ \\hat{K}_t = \\frac{\\hat{P}_{t|t-1}}{\\hat{P}_{t|t-1} + R_{\\text{hat}}} = \\frac{\\hat{P}_{t|t-1}}{\\hat{P}_{t|t-1} + \\lambda R_{\\text{true}}} $$\n请注意，由于递归，$\\hat{P}_{t|t-1}$ 也会与真实模型的 $P_{t|t-1}$ 不同。然而，对于任何给定的预测协方差值 $\\hat{P}_{t|t-1} > 0$，增加分母中 $R$ 的值会严格减小增益 $K_t$。由于 $\\lambda > 1$，因此 $R_{\\text{hat}} > R_{\\text{true}}$，这通常会导致 $\\hat{K}_t  K_t$。\n\n状态更新方程可以重写为：\n$$ \\hat{x}_{t|t} = (1 - K_t) \\hat{x}_{t|t-1} + K_t y_t $$\n一个较小的增益 $\\hat{K}_t$ 会给予新的、传入的测量值 $y_t$ 较少的权重，反之，会给予完全基于过去信息的先验估计 $\\hat{x}_{t|t-1}$ 更多的权重 $(1 - \\hat{K}_t)$。\n\n这有两个主要后果：\n1.  **更平滑的估计：** 通过在每一步降低噪声测量值 $y_t$ 的权重，滤波序列 $\\hat{x}^{(\\text{mis})}_{t|t}$ 对数据中的短期波动的响应变得不那么灵敏。由于估计值通过预测步骤更牢固地锚定于其自身的过去值，因此它们的演变更加缓慢和平滑。这导致滤波序列的方差降低，这一点由指标 $\\Delta \\text{VR}$ 来衡量。\n2.  **滞后的估计：** 由于滤波器吸收新信息的速度变慢，它需要更长的时间来对潜在真实状态 $x_t$ 的真实变化做出反应。如果 $x_t$ 经历持续性变化，滤波估计 $\\hat{x}^{(\\text{mis})}_{t|t}$ 的“追赶”速度将比正确指定的滤波器慢。这表现为真实状态序列和滤波序列之间的时间滞后，这一点由指标 $\\ell^{\\ast}$ 来捕捉。", "answer": "```python\nimport numpy as np\n\ndef kalman_filter(y_obs, phi, Q, R, x0_hat, P0_hat):\n    \"\"\"\n    Implements a scalar Kalman filter for a linear Gaussian state-space model.\n\n    Args:\n        y_obs (np.ndarray): Array of observations.\n        phi (float): Autoregressive parameter in the state equation.\n        Q (float): Variance of the state noise.\n        R (float): Variance of the measurement noise.\n        x0_hat (float): Initial state estimate.\n        P0_hat (float): Initial estimate variance.\n\n    Returns:\n        np.ndarray: Filtered state estimates x_t|t.\n    \"\"\"\n    T = len(y_obs)\n    x_filtered = np.zeros(T)\n    \n    # Initialize with the posterior at t=0\n    x_curr_post = x0_hat\n    P_curr_post = P0_hat\n\n    for t in range(T):\n        # Prediction step\n        x_pred = phi * x_curr_post\n        P_pred = phi**2 * P_curr_post + Q\n\n        # Update step\n        innovation = y_obs[t] - x_pred\n        innovation_cov = P_pred + R\n        kalman_gain = P_pred / innovation_cov\n\n        x_filtered[t] = x_pred + kalman_gain * innovation\n        P_curr_post = (1 - kalman_gain) * P_pred\n        x_curr_post = x_filtered[t]\n\n    return x_filtered\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating data, running Kalman filters, and computing metrics.\n    \"\"\"\n    test_cases = [\n        # (phi, Q, R_true, lambda, T, seed)\n        (0.9, 0.05, 0.2, 5.0, 200, 123),\n        (0.9, 0.05, 0.05, 10.0, 200, 456),\n        (0.99, 0.02, 0.1, 8.0, 300, 789),\n        (0.6, 0.2, 0.2, 5.0, 200, 321),\n        (0.9, 0.05, 0.2, 1.0, 200, 999),\n    ]\n\n    results = []\n    L_max = 10\n\n    for case in test_cases:\n        phi, Q, R_true, lambda_val, T, seed = case\n        \n        # 1. Simulate data from the true model\n        rng = np.random.default_rng(seed)\n        w = rng.normal(0, np.sqrt(Q), size=T)\n        v = rng.normal(0, np.sqrt(R_true), size=T)\n        \n        x_true = np.zeros(T + 1) # x_0, ..., x_T\n        y_obs = np.zeros(T)      # y_1, ..., y_T\n        \n        # x_0 = 0 is given\n        for t in range(1, T + 1):\n            x_true[t] = phi * x_true[t-1] + w[t-1]\n            y_obs[t-1] = x_true[t] + v[t-1]\n        \n        x_true_series = x_true[1:] # We care about x_1, ..., x_T\n\n        # 2. Run Kalman filter with correct and misspecified R\n        R_hat = lambda_val * R_true\n        \n        # Initial prior for the filter at t=0\n        x0_hat = 0.0\n        P0_hat = Q / (1 - phi**2)\n        \n        x_hat_true = kalman_filter(y_obs, phi, Q, R_true, x0_hat, P0_hat)\n        x_hat_mis = kalman_filter(y_obs, phi, Q, R_hat, x0_hat, P0_hat)\n        \n        # 3. Compute metrics\n        \n        # Delta MSE\n        mse_true = np.mean((x_true_series - x_hat_true)**2)\n        mse_mis = np.mean((x_true_series - x_hat_mis)**2)\n        delta_mse = mse_mis - mse_true\n        \n        # Estimated Lag\n        correlations = []\n        for l in range(L_max + 1):\n            if l == 0:\n                series1 = x_true_series\n                series2 = x_hat_mis\n            else:\n                series1 = x_true_series[l:]\n                series2 = x_hat_mis[:-l]\n            \n            # np.corrcoef returns a 2x2 matrix, we need the off-diagonal element\n            corr = np.corrcoef(series1, series2)[0, 1]\n            correlations.append(corr)\n            \n        lag_star = int(np.argmax(correlations))\n        \n        # Delta Variance Ratio\n        var_x_true = np.var(x_true_series)\n        var_x_hat_true = np.var(x_hat_true)\n        var_x_hat_mis = np.var(x_hat_mis)\n        \n        if var_x_true > 1e-9: # Avoid division by zero for flat series\n            vr_true = var_x_hat_true / var_x_true\n            vr_mis = var_x_hat_mis / var_x_true\n            delta_vr = vr_mis - vr_true\n        else:\n            delta_vr = 0.0\n\n        results.append([round(delta_mse, 6), lag_star, round(delta_vr, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2441505"}]}