{"hands_on_practices": [{"introduction": "理论学习的最终目的是解决实际问题。这个练习将欧几里得算法置于一个具体的应用场景中：景观设计。通过解决这个铺设瓷砖的优化问题，你将亲身体会到，寻找“最大可能的方砖”如何自然地转化为寻找两个维度的最大公约数（GCD），从而揭示了抽象数学概念在解决现实世界挑战中的实用价值。[@problem_id:1406858]", "problem": "一位景观设计师正在为一座新城市公园设计一个矩形露台。该露台的指定区域长1164厘米，宽876厘米。设计师计划使用相同的、不重叠的正方形瓷砖铺满整个区域。为了最大限度地减少成本和灌浆线造成的美学干扰，设计师希望使用能够完美覆盖该区域而无需切割任何瓷砖的、尽可能大的正方形瓷砖。\n\n可用于此项目的最大正方形瓷砖的边长是多少厘米？", "solution": "设每块正方形瓷磚的边长为 $s$。要用边长为 $s$ 的不重叠正方形瓷砖精确铺满 $1164$ 乘以 $876$ 的矩形，则 $1164$ 和 $876$ 都必须是 $s$ 的整数倍。因此，$s$ 必须是 $1164$ 和 $876$ 的公约数。这样的 $s$ 的最大值是最大公约数：\n$$\ns=\\gcd(1164,876).\n$$\n使用欧几里得算法计算 $\\gcd(1164,876)$：\n$$\n1164 = 1 \\cdot 876 + 288,\n$$\n$$\n876 = 3 \\cdot 288 + 12,\n$$\n$$\n288 = 24 \\cdot 12 + 0.\n$$\n最后一个非零余数是 $12$，因此\n$$\n\\gcd(1164,876)=12.\n$$\n因此，最大正方形瓷砖的边长是 $12$ 厘米。", "answer": "$$\\boxed{12}$$", "id": "1406858"}, {"introduction": "在掌握了欧几里得算法的正向计算之后，一个更深入的挑战是逆向思考它的过程。本练习提供了一系列算法执行过程中产生的余数，并要求你反推出符合条件的最小原始输入。这个过程不仅能加深你对算法每一步中除数、被除数和余数之间关系的理解，还能锻炼你通过已知输出来推断未知输入的能力。[@problem_id:1406844]", "problem": "欧几里得算法是求两个整数的最大公约数（GCD）的一种方法。当该算法应用于两个满足 $a > b$ 的正整数 $a$ 和 $b$ 时，它会生成一系列带余除法。第一次除法是用 $a$ 除以 $b$ 得到余数 $r_1$。第二次是用 $b$ 除以 $r_1$ 得到余数 $r_2$。这个过程一直持续下去，在接下来的每一步中，都用前一个除数除以前一个余数，直到余数为0。最大公约数是最后一个非零余数。\n\n假设对于一对满足 $ab$ 的特定正整数 $a$ 和 $b$，执行欧几里得算法产生的连续非零余数序列如下：$r_1 = 24$，$r_2 = 18$，以及 $r_3 = 6$。\n\n求 $a+b$ 的最小可能值。", "solution": "根据欧几里得算法，连续余数为 $r_{1}=24$，$r_{2}=18$，$r_{3}=6$，除法形式如下\n$$\na=q_{1}b+24,\\quad 0  24  b\n$$\n$$\nb=q_{2}\\cdot 24+18,\\quad 01824\n$$\n$$\n24=q_{3}\\cdot 18+6,\\quad 0618\n$$\n$$\n18=q_{4}\\cdot 6+0\n$$\n从最后一个方程开始，我们有 $18=q_{4}\\cdot 6$，这意味着 $q_4 = 3$。\n从第三个方程，$24=q_3\\cdot 18+6$，这意味着 $q_3\\cdot 18=18$，所以 $q_3=1$。\n为了最小化 $a$ 和 $b$，我们必须最小化商。从第二个方程开始，我们有 $b=q_2\\cdot 24+18$。因为 $q_2$ 必须是正整数，所以其最小可能值为 $q_2=1$。\n$$\nb=1\\cdot 24+18=42.\n$$\n这满足 $b > 24$ 的条件。\n现在，我们有 $a=q_1 b+24$，即 $a=q_1\\cdot 42+24$。因为 $q_1$ 必须是正整数且 $a>b$，所以其最小可能值为 $q_1=1$。\n$$\na=1\\cdot 42+24=66.\n$$\n这满足 $a>b$ 的条件（$66>42$）。\n因此，$a$ 和 $b$ 的最小可能值分别为 $66$ 和 $42$。\n因此，$a+b$ 的最小可能值为\n$$\n66+42=108.\n$$", "answer": "$$\\boxed{108}$$", "id": "1406844"}, {"introduction": "将数学算法转化为可执行的代码是理论与实践之间的关键桥梁。欧几里得算法的递归结构使其非常适合用递归函数来实现，但这其中也暗藏陷阱。本练习提供了一段有瑕疵的伪代码，挑战你识别并分析其中的逻辑错误。通过诊断这个“差之毫厘”的错误，你将能更深刻地理解保证递归算法正确终止的条件，以及 `gcd(a, b) = gcd(b, a MOD b)` 这一核心恒等式的精确含义。[@problem_id:1406857]", "problem": "一位学生需要实现一个递归函数，用来求两个非负整数的最大公约数 (GCD)。GCD 是能够同时整除两个数而没有余数的最大正整数。该学生为一个名为 `Altered_GCD` 的函数编写了以下伪代码。\n\n```\nFUNCTION Altered_GCD(a, b):\n    // a and b are non-negative integers\n    // 'MOD' represents the modulo operator\n\n    IF b == 0:\n        RETURN a\n    ELSE:\n        RETURN Altered_GCD(a MOD b, b)\n```\n\n分析这个 `Altered_GCD` 函数的行为。对于任意非负整数输入 `a` 和 `b`，以下哪个陈述最准确地描述了该函数的功能？\n\nA. 该函数能为所有非负整数 `a` 和 `b` 正确计算出 GCD。\n\nB. 当且仅当初始输入满足 `a = b` 时，该函数才能正确计算出 GCD。\n\nC. 对于 `b` 是正整数的任何输入，该函数都无法终止。\n\nD. 该函数计算的是最小公倍数 (LCM)，而不是 GCD。\n\nE. 该函数能正确计算 GCD，但仅限于 `a` 和 `b` 互质（它们的 GCD 为 1）时。", "solution": "题目要求我们分析一个用于寻找最大公约数 (GCD) 的欧几里得算法的有缺陷的递归实现。让我们通过检查其基本情况和递归步骤来分析 `Altered_GCD(a, b)` 函数的行为。\n\n提供的伪代码是：\n```\nFUNCTION Altered_GCD(a, b):\n    IF b == 0:\n        RETURN a\n    ELSE:\n        RETURN Altered_GCD(a MOD b, b)\n```\n\n**情况 1：基本情况**\n递归的基本情况是 `b == 0`。如果函数以 `b=0` 调用，例如 `Altered_GCD(a, 0)`，它会立即返回 `a`。这是正确的行为，因为任何数 `a` 和 0 的 GCD 被定义为 `a`。因此，如果第二个参数初始为 0，函数会终止并给出正确答案。\n\n**情况 2：递归步骤**\n当 `b  0` 时执行递归步骤。函数以新的参数调用自身：`Altered_GCD(a MOD b, b)`。\n\n让我们追踪参数。\n设初始调用为 `(a_0, b_0) = (a, b)`。\n第一次递归调用的参数将是 `(a_1, b_1)`，其中：\n$a_1 = a_0 \\text{ MOD } b_0$\n$b_1 = b_0$\n\n第二次递归调用的参数将是 `(a_2, b_2)`，其中：\n$a_2 = a_1 \\text{ MOD } b_1$\n$b_2 = b_1$\n\n注意这个关键缺陷：第二个参数 `b` 在每次递归调用中都未经改变地传递。让我们用 $b_n$ 表示第 n 次递归步骤中的第二个参数。我们有 $b_n = b_{n-1} = \\dots = b_1 = b_0 = b$。\n\n要使递归算法终止，其状态必须向基本情况发展。在这个算法中，基本情况是 `b == 0`。由于第二个参数的值永远不会从其初始值 `b` 改变，所以除非 `b` 从一开始就是 0，否则 `b == 0` 的条件将永远不会满足。\n\n让我们考虑一个任意输入 `(a, b)`，其中 `b  0`。\n调用序列是：\n`Altered_GCD(a, b)`\n`- Altered_GCD(a MOD b, b)`\n`- Altered_GCD((a MOD b) MOD b, b)`\n`- Altered_GCD(((a MOD b) MOD b) MOD b, b)`\n……依此类推。\n\n让我们检查第一个参数。设 $a' = a \\text{ MOD } b$。根据模运算符的定义，$0 \\le a'  b$。\n第一个位置的下一个参数是 $a' \\text{ MOD } b$。由于 $0 \\le a'  b$，可以得出 $a' \\text{ MOD } b = a'$。\n因此，在第一次递归调用 `Altered_GCD(a MOD b, b)` 之后，所有后续的调用都将是 `Altered_GCD(a MOD b, b)`。函数进入了一个无法逃逸的状态。这导致了无限递归。\n\n例如，让我们追踪 `Altered_GCD(25, 10)`：\n1. `Altered_GCD(25, 10)` - `b` 不为 0。返回 `Altered_GCD(25 MOD 10, 10)`，即 `Altered_GCD(5, 10)`。\n2. `Altered_GCD(5, 10)` - `b` 不为 0。返回 `Altered_GCD(5 MOD 10, 10)`，即 `Altered_GCD(5, 10)`。\n3. `Altered_GCD(5, 10)` - 返回 `Altered_GCD(5, 10)`。…… 这个过程将永远持续下去。\n\n让我们追踪另一个 $a  b$ 的例子，比如 `Altered_GCD(10, 25)`：\n1. `Altered_GCD(10, 25)` - `b` 不为 0。返回 `Altered_GCD(10 MOD 25, 25)`，即 `Altered_GCD(10, 25)`。\n2. 这会立即进入一个无限循环。\n\n唯一能够终止的情形是初始的 `b` 为 0。如果 `b` 是任何正整数，该函数将进入无限递归并且无法终止。\n\n现在让我们评估这些选项：\nA. 该函数能为所有非负整数 `a` 和 `b` 正确计算出 GCD。这是错误的。如果 `b  0`，它无法终止。\nB. 当且仅当初始输入满足 `a = b` 时，该函数才能正确计算出 GCD。这是错误的。我们的例子 `Altered_GCD(25, 10)` 表明即使 `a  b`，它也会失败。\nC. 对于 `b` 是正整数的任何输入，该函数都无法终止。这是正确的，正如我们的分析所示。`b` 的值永远不会减少以达到基本情况 0。\nD. 该函数计算的是最小公倍数 (LCM)，而不是 GCD。这是错误的。其结构基于欧几里得算法，它的失败模式是无法终止，而不是计算一个不同的量。\nE. 该函数能正确计算 GCD，但仅限于 `a` 和 `b` 互质（它们的 GCD 为 1）时。这是错误的。例如，`Altered_GCD(7, 5)`（互质）与 `Altered_GCD(25, 10)` 一样无法终止。终止问题与输入的互质性无关。\n\n因此，最准确的描述是，对于任何正整数 `b`，该函数都无法终止。", "answer": "$$\\boxed{C}$$", "id": "1406857"}]}