{"hands_on_practices": [{"introduction": "算法分析的第一步是学习如何计算基本操作并识别主导增长的项。这个练习将通过一个直接的例子帮助你掌握大O符号的核心思想：关注增长率，忽略常数因子，无论这个常数有多大。通过分析一个主循环和一个内含固定次数操作的子过程，你可以练习将代码结构转化为数学表达式，并应用渐近分析的基本原则[@problem_id:1349082]。", "problem": "一位工程师正在为一个社交媒体平台开发一个系统，以验证其用户帐户的完整性。他们设计了一种名为 `verifyAllAccounts` 的算法，该算法接收一个包含 $n$ 个用户个人资料的列表作为输入。该算法逐一迭代这 $n$ 个个人资料。对于每个个人资料，它都会调用一个名为 `runComplianceScan` 的子程序。这个 `runComplianceScan` 子程序被设计用来执行一组固定且恒定的1000次基本计算操作（例如数据字段比较和哈希检查），以确保帐户符合平台的服务条款。`runComplianceScan` 执行的操作次数始终为1000次，无论个人资料中的具体数据或用户总数 $n$如何。\n\n假设访问列表中的每个个人资料花费常数时间，那么整个 `verifyAllAccounts` 算法关于用户数量 $n$ 的渐近时间复杂度（大O表示法）是多少？\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n^2)$\n\nE. $O(1000^n)$\n\nF. $O(1)$", "solution": "要确定 `verifyAllAccounts` 算法的时间复杂度，我们需要分析它作为输入大小 $n$ 的函数所执行的基本操作总数。令 $T(n)$ 表示这个操作总数。\n\n该算法包含一个主循环，该循环遍历 $n$ 个用户个人资料中的每一个。这个结构可以建模为一个从 $i=1$ 运行到 $n$ 的 `for` 循环。\n\n对于主循环的每次迭代（即，对于每个用户个人资料），该算法都会调用 `runComplianceScan` 子程序。问题陈述 `runComplianceScan` 执行恒定数量的操作，具体为1000次。\n\n因此，在第一次迭代中（对于第一个用户），执行1000次操作。\n在第二次迭代中（对于第二个用户），再执行1000次操作。\n这个过程对所有 $n$ 个用户都继续进行。\n\n为了求出总操作数 $T(n)$，我们将主循环的 $n$ 次迭代中每次执行的操作数相加。由于每次迭代都恰好贡献1000次操作，总数为：\n$$T(n) = \\sum_{i=1}^{n} 1000$$\n这相当于将1000自身相加 $n$ 次：\n$$T(n) = 1000 + 1000 + \\dots + 1000 \\quad (n \\text{ times})$$\n$$T(n) = 1000 \\cdot n$$\n\n现在，我们必须求出 $T(n)$ 的大O复杂度。根据大O表示法的定义，如果存在正常数 $c$ 和 $n_0$，使得对于所有 $n \\ge n_0$ 都有 $0 \\le T(n) \\le c \\cdot g(n)$，则函数 $T(n)$ 属于 $O(g(n))$。\n\n在我们的例子中，$T(n) = 1000n$。我们正在寻找能够界定 $T(n)$ 的最简单函数 $g(n)$。让我们测试函数 $g(n) = n$。\n我们需要检查是否存在某个常数 $c$ 使得对于所有 $n \\ge n_0$ 都有 $1000n \\le c \\cdot n$。\n如果我们选择常数 $c = 1000$，不等式变为 $1000n \\le 1000n$。这对于所有 $n \\ge 1$ 都成立。因此，我们可以选择 $c=1000$ 和 $n_0=1$。\n既然我们找到了这样的常数，我们可以得出结论 $T(n)$ 属于 $O(n)$。\n\n在大O分析中，常数因子被忽略，因为我们关心的是当 $n$ 变得非常大时函数的增长率。函数 $1000n$ 随 $n$ 线性增长，就像函数 $n$ 一样。因此，渐近时间复杂度是 $O(n)$。\n\n将我们的结果与给定选项进行比较：\nA. $O(\\log n)$: 不正确。对数增长远慢于线性增长。\nB. $O(n)$: 正确。运行时间随用户数量线性增长。\nC. $O(n \\log n)$: 不正确。这是超线性增长，常见于高效的排序算法。\nD. $O(n^2)$: 不正确。这是平方增长，是内层循环的迭代次数也取决于 $n$ 的嵌套循环的典型特征。\nE. $O(1000^n)$: 不正确。这是指数增长，远大于实际的线性增长。\nF. $O(1)$: 不正确。常数时间复杂度意味着运行时间与 $n$ 无关。\n\n因此，正确的时间复杂度是 $O(n)$。", "answer": "$$\\boxed{B}$$", "id": "1349082"}, {"introduction": "许多算法的复杂度并非简单的线性或二次关系，其分析需要更精细的数学工具。这个练习展示了如何通过分析一个求和级数来确定一个嵌套循环的运行时间，特别是引入了在算法分析中频繁出现的调和级数。这个问题让你从简单的操作计数，过渡到应用数学近似（如积分界限或已知级数性质）来求解更复杂的性能问题[@problem_id:1349044]。", "problem": "一个新型去中心化数据验证系统的原型正在被分析。该系统以轮次方式运行。对于一个大小为 $n$ 的数据集，主协调节点执行一系列检查。它遍历一个从 $1$ 到 $n$ 的整数参数 $i$。在每次迭代 $i$ 中，它会查询一组验证者节点。在特定迭代 $i$ 中查询的验证者数量由整数值 $V_i = \\lfloor n/i \\rfloor$ 给出。\n\n您的任务是确定协调节点处理单个大小为 $n$ 的数据集所执行的验证者查询总数 $T$ 的渐近复杂度。请从以下选项中选择 $T$ 的最紧确界，用大O表示法表示。\n\nA. $O(n)$\n\nB. $O(\\log_{2} n)$\n\nC. $O(n \\ln n)$\n\nD. $O(n^2)$\n\nE. $O(n \\log_{2} n)$\n\nF. $O(\\sqrt{n})$", "solution": "为了确定验证者查询的总数 $T(n)$ 的渐近复杂度，我们首先写出其数学表达式。总查询数是：\n$$T(n) = \\sum_{i=1}^{n} \\left\\lfloor \\frac{n}{i} \\right\\rfloor$$\n直接计算这个和是困难的，但我们可以通过使用向下取整函数的基本性质 $x - 1  \\lfloor x \\rfloor \\le x$ 来确定其渐近界。\n\n对和中的每一项应用此不等式，然后对 $i$ 从 1 到 $n$ 求和，我们得到：\n$$\\sum_{i=1}^{n} \\left(\\frac{n}{i} - 1\\right)  T(n) \\le \\sum_{i=1}^{n} \\frac{n}{i}$$\n这可以简化为：\n$$n \\left(\\sum_{i=1}^{n} \\frac{1}{i}\\right) - n  T(n) \\le n \\left(\\sum_{i=1}^{n} \\frac{1}{i}\\right)$$\n和 $\\sum_{i=1}^{n} \\frac{1}{i}$ 是第 $n$ 个调和数，记为 $H_n$。众所周知，$H_n$ 的增长与自然对数 $\\ln n$ 类似，即 $H_n = \\Theta(\\ln n)$。\n\n因此，$T(n)$ 的下界是 $\\Theta(n \\ln n - n) = \\Theta(n \\ln n)$，上界是 $\\Theta(n \\ln n)$。\n这意味着 $T(n)$ 的紧确界是 $\\Theta(n \\ln n)$。\n\n由于 $T(n) \\in \\Theta(n \\ln n)$，它也属于 $O(n \\ln n)$。选项 C 正确地描述了这一上界。选项 E，$O(n \\log_2 n)$，也描述了同一个复杂度类，因为对数的底数在渐近分析中只是一个常数因子，但 C 更直接地与调和级数的分析相关。", "answer": "$$\\boxed{C}$$", "id": "1349044"}, {"introduction": "递归是设计高效算法的强大范式，尤其体现在“分而治之”策略中，但分析其复杂度需要不同的方法，即求解递推关系。本练习将引导你使用一种称为“变量替换”的巧妙技巧，将一个不寻常的递推关系转化为一个标准形式，从而揭示算法的真实复杂度。这个方法对于分析那些在每一步都显著减小问题规模（例如开方）的算法至关重要[@problem_id:1349048]。", "problem": "一种名为“层次聚合变换”（Hierarchical Aggregation Transform, HAT）的实验性数据处理算法，被设计用于分析大型高维数据集。HAT 算法作用于一个大小为 $n$ 的数据集。在每一步中，它执行一系列比较和合并操作，所需时间与数据集大小的以 2 为底的对数成正比。此步骤之后，它会对两个独立的、经过变换的子问题进行递归调用，其中每个子问题的有效大小是原始数据集大小的平方根。对于一个大小为 $n$ 的数据集，HAT 算法的运行时间 $T(n)$ 可以用以下递推关系来建模：\n\n$$T(n) = 2T(\\sqrt{n}) + \\log_{2}n$$\n\n假设对于小规模输入（$n \\le 4$），运行时间 $T(n)$ 是一个常数。请确定该算法运行时间 $T(n)$ 的最紧渐近上下界（大$\\Theta$记号）。\n\n请从以下选项中选择正确的渐近界。\n\nA. $\\Theta(\\log_{2}n)$\n\nB. $\\Theta((\\log_{2}n)^2)$\n\nC. $\\Theta(\\sqrt{n})$\n\nD. $\\Theta(\\log_{2}n \\cdot \\log_{2}(\\log_{2}n))$\n\nE. $\\Theta(n)$", "solution": "我们得到的递推关系是\n$$T(n)=2T(\\sqrt{n})+\\log_{2}n,$$\n其基本情况是当 $n \\leq 4$ 时，$T(n)$ 为 $\\Theta(1)$。\n\n引入变量替换 $n=2^{m}$，因此 $m=\\log_{2}n$，并定义 $S(m)=T(2^{m})$。那么 $\\sqrt{n}=2^{m/2}$，所以递推关系变为\n$$S(m)=2S\\left(\\frac{m}{2}\\right)+m,$$\n其中当 $m \\leq 2$ 时，$S(m)=\\Theta(1)$。\n\n这是一个标准的分治递推式，形式为 $S(m)=aS(m/b)+f(m)$，其中 $a=2$，$b=2$，$f(m)=m$。我们有 $m^{\\log_{b}a}=m^{\\log_{2}2}=m$。因此 $f(m)=\\Theta\\!\\left(m^{\\log_{2}2}\\right)$，这符合主定理（Master Theorem）的第二种情况，从而得到\n$$S(m)=\\Theta\\!\\left(m\\log m\\right)。$$\n为了明确对数的底，这可以写成 $S(m)=\\Theta\\!\\left(m\\log_{2}m\\right)$，因为改变对数的底只会影响常数因子。\n\n或者，使用递归树法分析：在第 $i$ 层，有 $2^{i}$ 个大小为 $m/2^{i}$ 的子问题，每个子问题对非递归部分的贡献是 $m/2^{i}$，所以每层的总成本是 $2^{i}\\cdot(m/2^{i})=m$。树的深度是满足 $m/2^{d}\\leq 2$ 的最小 $d$，即 $d=\\Theta(\\log_{2}m)$，所以所有非叶节点的成本总和为 $\\Theta(m\\log_{2}m)$。叶节点的数量是 $2^{d}=\\Theta(m)$，每个叶节点的成本是 $\\Theta(1)$，总共增加 $\\Theta(m)$ 的成本，所以总成本仍然是 $\\Theta(m\\log_{2}m)$。\n\n使用 $m=\\log_{2}n$ 转换回 $n$ 可得\n$$T(n)=S(\\log_{2}n)=\\Theta\\!\\left(\\log_{2}n\\cdot\\log_{2}\\!\\bigl(\\log_{2}n\\bigr)\\right)。$$\n在所提供的选项中，这与选项D匹配。", "answer": "$$\\boxed{D}$$", "id": "1349048"}]}