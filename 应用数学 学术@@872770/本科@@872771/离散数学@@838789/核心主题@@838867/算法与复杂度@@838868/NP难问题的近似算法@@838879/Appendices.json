{"hands_on_practices": [{"introduction": "许多现实世界中的优化问题，如在多台服务器上调度计算任务，都属于 NP-困难问题。这意味着找到绝对最优的解决方案可能需要不切实际的时间。在这种情况下，一个简单直观的贪心策略往往能提供一个足够好的近似解。[@problem_id:1349787] 探讨了一种经典的负载均衡算法——“最长处理时间优先” (LPT) 策略，它指导我们将最耗时的任务优先分配给当前最空闲的机器。通过这个练习，你将亲手执行这一启发式算法，直观地理解它如何有效地最小化整体完成时间（即最大完工时间）。", "problem": "一个研究团队正在管理一个用于运行科学模拟的小型高性能计算集群。该集群由 $m=3$ 个相同的计算节点组成，这些节点可以并行处理作业。该团队需要运行一批共6个计算作业，其处理时间（以小时为单位）分别为：9, 8, 7, 6, 5, 和 2。\n\n集群的自动调度器使用一种特定的“高需求优先”（High-Demand First）协议来分配这些作业。该协议的运行方式如下：\n1. 所有作业按其所需处理时间的降序排列在一个队列中。\n2. 调度器从队列头部逐一取出作业，并将每个作业分配给当前已分配总处理时间最短的计算节点。如果存在多个负载最小的节点（即负载相同），则可以选择其中任何一个。\n\n计算这整批作业的最终完成时间，也称为完工时间（makespan）。完工时间定义为从开始到任何节点上的最后一个作业完成所经过的总时间。请以小时为单位给出您的答案。", "solution": "我们应用所述的“高需求优先”协议，这即是在 $m=3$ 台相同并行机器上的最长处理时间优先（longest-processing-time-first）规则。首先，将作业按处理时间降序排序。给定的时间已经按降序排列：\n$$9,\\,8,\\,7,\\,6,\\,5,\\,2.$$\n设 $L_{1},L_{2},L_{3}$ 分别表示节点 $1,2,3$ 上当前已分配的总负载（以小时为单位）。初始时，\n$$L_{1}=0,\\quad L_{2}=0,\\quad L_{3}=0.$$\n逐一处理作业，始终将下一个作业分配给当前负载最小的节点（按规定，负载相同时可任意选择）：\n\n1. 将作业 $9$ 分配给负载最小的节点（此时所有节点负载均为0，平局）。选择节点 $1$：\n$$L_{1}=0+9=9,\\quad L_{2}=0,\\quad L_{3}=0.$$\n2. 将作业 $8$ 分配给负载最小的节点（节点 $2$ 和 $3$ 的负载均为 $0$，平局）。选择节点 $2$：\n$$L_{1}=9,\\quad L_{2}=0+8=8,\\quad L_{3}=0.$$\n3. 将作业 $7$ 分配给负载最小的节点（即负载为 $0$ 的节点 $3$）：\n$$L_{1}=9,\\quad L_{2}=8,\\quad L_{3}=0+7=7.$$\n4. 将作业 $6$ 分配给负载最小的节点（即负载为 $7$ 的节点 $3$）：\n$$L_{1}=9,\\quad L_{2}=8,\\quad L_{3}=7+6=13.$$\n5. 将作业 $5$ 分配给负载最小的节点（即负载为 $8$ 的节点 $2$）：\n$$L_{1}=9,\\quad L_{2}=8+5=13,\\quad L_{3}=13.$$\n6. 将作业 $2$ 分配给负载最小的节点（即负载为 $9$ 的节点 $1$）：\n$$L_{1}=9+2=11,\\quad L_{2}=13,\\quad L_{3}=13.$$\n\n最终各节点的负载为 $L_{1}=11$, $L_{2}=13$, $L_{3}=13$。完工时间（makespan）被定义为最后一个作业的完成时间，即为所有节点负载中的最大值：\n$$C_{\\max}=\\max\\{L_{1},L_{2},L_{3}\\}=13.$$\n因此，该批作业的总完成时间为 $13$ 小时。", "answer": "$$\\boxed{13}$$", "id": "1349787"}, {"introduction": "集合覆盖问题是组合优化领域的另一个基本 NP-困难问题，它在资源配置、设施选址和生物信息学等领域有着广泛应用。该问题的目标是用最少的集合来覆盖一个全集中的所有元素。[@problem_id:1462666] 让你实践解决集合覆盖问题的标准贪心算法。该算法的核心思想是在每一步都做出局部最优选择：挑选能够覆盖最多“新”元素（即尚未被覆盖的元素）的集合。这个练习将帮助你掌握如何通过迭代应用这一“最大效益”原则来构建一个近似最优的解。", "problem": "集合覆盖问题是计算机科学中的一个经典问题。给定一个元素全集 $U$ 和一个由 $U$ 的子集构成的集合族 $\\mathcal{S}$，其目标是找到 $\\mathcal{S}$ 的一个子集族（称为一个覆盖），该覆盖包含最少数量的集合，且这些集合的并集等于全集 $U$。\n\n由于找到精确的最小覆盖在计算上是困难的（它是一个NP难问题），因此通常使用近似算法。一种常见的方法是贪心算法，其过程定义如下：\n1. 初始化未覆盖元素的集合 $U_{unc}$ 为整个全集 $U$。\n2. 初始化覆盖 $C$ 为一个空集。\n3. 当 $U_{unc}$ 不为空时：\n   a. 从原始集合族 $\\mathcal{S}$ 中选择一个集合 $S$，该集合能覆盖 $U_{unc}$ 中当前最多的元素。如果存在多个集合覆盖的元素数量相同，则选择索引最小的集合（例如，如果 $i  j$，则选择 $S_i$ 而非 $S_j$）。\n   b. 将选定的集合 $S$ 添加到覆盖 $C$ 中。\n   c. 通过移除选定集合 $S$ 的元素来更新 $U_{unc}$（即 $U_{unc} \\leftarrow U_{unc} \\setminus S$）。\n4. 算法终止并返回覆盖 $C$。\n\n考虑一个由以下条件定义的集合覆盖问题的具体实例：\n- 全集 $U = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\\}$。\n- 集合族 $\\mathcal{S} = \\{S_1, S_2, S_3, S_4, S_5, S_6\\}$，其中：\n  - $S_1 = \\{1, 2, 3, 4, 5\\}$\n  - $S_2 = \\{6, 7, 8, 9\\}$\n  - $S_3 = \\{10, 11, 12\\}$\n  - $S_4 = \\{1, 6, 10, 11\\}$\n  - $S_5 = \\{2, 3, 7, 8\\}$\n  - $S_6 = \\{4, 9, 12\\}$\n\n令 $C_{greedy}$ 为对此实例应用贪心算法找到的集合覆盖。计算 $C_{greedy}$ 中所有集合的基数（大小）之和。也就是说，计算表达式 $\\sum_{S \\in C_{greedy}} |S|$ 的值。", "solution": "我们按照指定的方式应用贪心算法。在每次迭代中，我们选择一个能最大化边际覆盖率的集合，该覆盖率由 $|S \\cap U_{unc}|$ 度量，并按最小索引解决平局情况。\n\n初始化 $U_{unc} = U = \\{1,2,3,4,5,6,7,8,9,10,11,12\\}$ 和 $C = \\emptyset$。\n\n第一次迭代：计算所有 $i$ 的 $|S_{i} \\cap U_{unc}|$。\n- $|S_{1} \\cap U_{unc}| = |S_{1}| = 5$。\n- $|S_{2} \\cap U_{unc}| = 4$。\n- $|S_{3} \\cap U_{unc}| = 3$。\n- $|S_{4} \\cap U_{unc}| = 4$。\n- $|S_{5} \\cap U_{unc}| = 4$。\n- $|S_{6} \\cap U_{unc}| = 3$。\n最大值为 $5$，仅由 $S_{1}$ 达到。选择 $S_{1}$。更新 $C \\leftarrow \\{S_{1}\\}$ 和 $U_{unc} \\leftarrow U_{unc} \\setminus S_{1} = \\{6,7,8,9,10,11,12\\}$。\n\n第二次迭代：计算 $|S_{i} \\cap U_{unc}|$。\n- $|S_{1} \\cap U_{unc}| = 0$。\n- $|S_{2} \\cap U_{unc}| = |\\{6,7,8,9\\}| = 4$。\n- $|S_{3} \\cap U_{unc}| = |\\{10,11,12\\}| = 3$。\n- $|S_{4} \\cap U_{unc}| = |\\{6,10,11\\}| = 3$。\n- $|S_{5} \\cap U_{unc}| = |\\{7,8\\}| = 2$。\n- $|S_{6} \\cap U_{unc}| = |\\{9,12\\}| = 2$。\n最大值为 $4$，仅由 $S_{2}$ 达到。选择 $S_{2}$。更新 $C \\leftarrow \\{S_{1}, S_{2}\\}$ 和 $U_{unc} \\leftarrow U_{unc} \\setminus S_{2} = \\{10,11,12\\}$。\n\n第三次迭代：计算 $|S_{i} \\cap U_{unc}|$。\n- $|S_{1} \\cap U_{unc}| = 0$。\n- $|S_{2} \\cap U_{unc}| = 0$。\n- $|S_{3} \\cap U_{unc}| = |\\{10,11,12\\}| = 3$。\n- $|S_{4} \\cap U_{unc}| = |\\{10,11\\}| = 2$。\n- $|S_{5} \\cap U_{unc}| = 0$。\n- $|S_{6} \\cap U_{unc}| = |\\{12\\}| = 1$。\n最大值为 $3$，仅由 $S_{3}$ 达到。选择 $S_{3}$。更新 $C \\leftarrow \\{S_{1}, S_{2}, S_{3}\\}$ 和 $U_{unc} \\leftarrow \\emptyset$。算法终止。\n\n因此 $C_{greedy} = \\{S_{1}, S_{2}, S_{3}\\}$，所求的和为\n$$\\sum_{S \\in C_{greedy}} |S| = |S_{1}| + |S_{2}| + |S_{3}| = 5 + 4 + 3 = 12.$$", "answer": "$$\\boxed{12}$$", "id": "1462666"}, {"introduction": "对于某些 NP-困难问题，我们甚至可以设计出性能更强的近似算法，其近似程度可以由用户自由控制。这就是“全多项式时间近似方案”（FPTAS）的概念，它允许我们在解的精度和计算时间之间进行权衡。[@problem_id:1349838] 通过一个经典的 0-1 背包问题变体，向你展示了 FPTAS 的工作原理。你将学习一种关键技术——数值缩放（value scaling），即通过降低数值的精度来简化问题，从而在多项式时间内找到一个总价值与最优解相差不超过一个可控因子 $\\epsilon$ 的解。这个练习让你能够具体操作一个 FPTAS 算法，深入理解其背后“以精度换速度”的精妙思想。", "problem": "星际项目委员会（IPC）正在为一项即将进行的深空任务敲定其有效载荷选择。火箭有严格的有效载荷质量上限，不可超出。每个候选项目都有其相关的质量和一个指定的“科学价值”分数。目标是选择一个项目子集，使得在不超过质量上限的前提下，总科学价值最大化。\n\n这个选择问题是NP难的0-1背包问题的一个变种。由于为大量项目找到精确的最优解在计算上是不可行的，IPC采用了一种完全多项式时间近似方案（FPTAS）。对于一个最大化问题，给定任意精度参数 $\\epsilon  0$，FPTAS能找到一个总价值至少是最优值 $(1 - \\epsilon)$ 倍的解，并且其运行时间在输入规模和 $1/\\epsilon$ 上都是多项式时间的。\n\nIPC所采用的具体FPTAS算法工作流程如下：\n1.  给定 $n$ 个项目，令 $V_{\\max}$ 为所有单个项目中最大的科学价值。\n2.  计算一个缩放因子 $K = \\frac{\\epsilon V_{\\max}}{n}$。\n3.  对于每个具有原始价值 $v_i$ 的项目 $i$，计算一个新的缩减后的整数值 $v'_i = \\lfloor \\frac{v_i}{K} \\rfloor$。\n4.  然后，算法使用原始质量和这些新的缩放价值 $v'_i$ 来求解一个新的背包问题，并找到其最优解。在质量上限内能够产生最大可能总缩放价值（$v'_i$ 的总和）的项目组合将被选中。\n\n假设有三个候选项目，其属性如下：\n-   **Project Alpha**: 科学价值 = 100, 质量 = 10 kg\n-   **Project Beta**: 科学价值 = 51, 质量 = 5 kg\n-   **Project Gamma**: 科学价值 = 51, 质量 = 5 kg\n\n火箭对这些项目的总质量上限为10公斤。IPC已设定精度参数 $\\epsilon = 0.1$。如果有多个项目组合产生了相同的最大总缩放价值，IPC的协议是选择具有最高总原始科学价值的组合。\n\n你的任务是确定通过此FPTAS算法选出的有效载荷组合的总科学价值。请以单个整数形式提供最终答案。", "solution": "我们精确地应用给定的FPTAS。共有 $n=3$ 个项目，单个项目的最大科学价值为 $V_{\\max}=100$。当 $\\epsilon=0.1$ 时，缩放因子为\n$$\nK=\\frac{\\epsilon V_{\\max}}{n}=\\frac{\\left(\\frac{1}{10}\\right)\\cdot 100}{3}=\\frac{10}{3}.\n$$\n对于每个原始价值为 $v_{i}$ 的项目，其缩放价值为 $v_{i}'=\\left\\lfloor \\frac{v_{i}}{K}\\right\\rfloor=\\left\\lfloor v_{i}\\cdot \\frac{3}{10}\\right\\rfloor$。因此，\n$$\nv_{\\text{Alpha}}'=\\left\\lfloor 100\\cdot \\frac{3}{10}\\right\\rfloor=\\left\\lfloor 30\\right\\rfloor=30,\\quad\nv_{\\text{Beta}}'=\\left\\lfloor 51\\cdot \\frac{3}{10}\\right\\rfloor=\\left\\lfloor \\frac{153}{10}\\right\\rfloor=15,\\quad\nv_{\\text{Gamma}}'=\\left\\lfloor 51\\cdot \\frac{3}{10}\\right\\rfloor=\\left\\lfloor \\frac{153}{10}\\right\\rfloor=15.\n$$\nAlpha的质量仍为10公斤，Beta和Gamma的质量各为5公斤，容量上限为10公斤。我们对缩放后的背包问题进行最优求解：\n- 单独选择Alpha，总缩放价值为 $30$，质量为10公斤。\n- 同时选择Beta和Gamma，总缩放价值为 $15+15=30$，质量为 $5+5=10$ 公斤。\n- 任何包含Alpha以及Beta或Gamma中任意一个的组合都会超过容量上限，而单独选择Beta或Gamma得到的缩放价值为 $15$，不是最优的。\n\n因此，可实现的最大总缩放价值为 $30$，并且在单独选择Alpha与选择Beta+Gamma组合之间出现了平局。根据指定的平局打破规则，我们选择具有更高总原始科学价值的组合。单独选择Alpha的原始总价值为 $100$，而Beta+Gamma组合的原始总价值为 $51+51=102$，所以算法选择Beta+Gamma。因此，所选有效载荷的总科学价值是 $102$。", "answer": "$$\\boxed{102}$$", "id": "1349838"}]}