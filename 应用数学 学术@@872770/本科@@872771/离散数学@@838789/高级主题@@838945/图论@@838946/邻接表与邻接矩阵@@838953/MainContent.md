## 引言
图作为一种描述实体间关系的强大抽象模型，在计算机科学、自然科学和社会科学中无处不在。然而，要将这一抽象概念付诸计算，我们必须首先解决一个根本问题：如何用计算机能够理解的结构化数据来表示图？这个看似简单的问题是所有[图算法](@entry_id:148535)和[网络分析](@entry_id:139553)的基石，选择不同的表示方法将直接影响算法的效率和可扩展性。

本文旨在系统地介绍两种最核心的[图表示](@entry_id:273102)方法——[邻接矩阵](@entry_id:151010)和[邻接表](@entry_id:266874)。在“原理与机制”一章中，我们将深入剖析这两种数据结构的定义、基本性质以及它们在空间和时间效率上的关键权衡。随后的“应用与跨学科联系”将展示这些表示法如何应用于从社交[网络分析](@entry_id:139553)到生物信息学的广泛领域，并揭示其与线性代数的深刻联系，如通过谱分析发现网络深层结构。最后，在“动手实践”部分，你将通过一系列精心设计的问题，将理论知识应用于解决具体的分析任务。通过学习本文，你将不仅掌握[图表示](@entry_id:273102)的理论知识，更将具备根据实际问题需求选择和应用最合适数据结构的能力，为解决复杂的网络问题打下坚实的基础。

## 原理与机制

在将图的抽象概念应用于计算和[科学建模](@entry_id:171987)时，我们必须找到一种系统的方法来表示其结构。计算机程序无法直接理解顶点和边的视觉描绘；它们需要一种结构化的、代数的数据格式。本章将深入探讨两种表示图的基本数据结构：**[邻接矩阵](@entry_id:151010) (adjacency matrix)** 和 **[邻接表](@entry_id:266874) (adjacency list)**。我们将剖析它们的定义、基本性质、扩展形式，并分析它们在不同场景下的效率权衡。理解这些表示方法是掌握[图算法](@entry_id:148535)和利用图模型解决现实世界问题的基石。

### 邻接矩阵：一张结构的蓝图

邻接矩阵也许是表示图最直观的代数方法。对于一个包含 $n$ 个顶点的图 $G=(V, E)$，其[邻接矩阵](@entry_id:151010) $A$ 是一个 $n \times n$ 的方阵，它精确地编码了顶点之间的连接关系。

#### 表示简单[无向图](@entry_id:270905)

让我们从最简单的情况开始：一个既没有[自环](@entry_id:274670)（连接顶点自身的边）也没有重边（两个相同顶点之间有多条边）的**简单[无向图](@entry_id:270905)**。假设图的顶点被标记为 $v_1, v_2, \dots, v_n$。邻接矩阵 $A$ 的定义如下：
$$
A_{ij} = \begin{cases} 1 & \text{如果顶点 } v_i \text{ 和 } v_j \text{ 之间存在一条边} \\ 0 & \text{否则} \end{cases}
$$

这个定义蕴含了几个关键的结构属性，这些属性对于理解和验证邻接矩阵至关重要。考虑一个社交网络平台，连接关系是相互的，且用户不能与自己建立连接 [@problem_id:1348795]。该网络的邻接矩阵必须遵循以下规则：

1.  **对称性 (Symmetry)**：在[无向图](@entry_id:270905)中，如果 $v_i$ 与 $v_j$ 相连，那么 $v_j$ 也必然与 $v_i$ 相连。这意味着 $A_{ij} = A_{ji}$ 对所有 $i, j$ 成立。因此，一个[无向图](@entry_id:270905)的邻接矩阵必然是一个**对称矩阵**，即 $A = A^T$。

2.  **零对角线 (Zero Diagonal)**：简单图的定义排除了[自环](@entry_id:274670)。一个顶点不能与自身相连，所以对于所有的 $i$，矩阵的对角[线元](@entry_id:196833)素 $A_{ii}$ 必须为 $0$。

3.  **二[进制](@entry_id:634389)条目 (Binary Entries)**：矩阵中的元素只取 $0$ 或 $1$ 两个值，表示连接的“有”或“无”。

一个矩阵只有同时满足这三个条件，才能成为一个简单[无向图](@entry_id:270905)的有效邻接矩阵 [@problem_id:1348795]。

#### 从[邻接矩阵](@entry_id:151010)中提取信息

[邻接矩阵](@entry_id:151010)不仅存储了图的结构，还使得一些重要的图属性可以通过简单的矩阵运算来计算。

-   **顶点的度 (Degree of a Vertex)**：顶点 $v_i$ 的度，记为 $\deg(v_i)$，是指与该顶点相连的边的数量。在邻接矩阵中，这等于第 $i$ 行（或第 $i$ 列）所有元素的和。
    $$
    \deg(v_i) = \sum_{j=1}^{n} A_{ij}
    $$

-   **边的总数 (Total Number of Edges)**：图的总边数 $|E|$ 与矩阵中所有元素的总和有着直接的联系。由于每条边 $(v_i, v_j)$ 都在矩阵中贡献了两个 $1$（即 $A_{ij}=1$ 和 $A_{ji}=1$），因此矩阵所有元素之和等于总边数的两倍。这与著名的**握手定理**（所有[顶点的度](@entry_id:264944)之和等于边数的两倍）是一致的。
    $$
    \sum_{i=1}^{n} \sum_{j=1}^{n} A_{ij} = \sum_{i=1}^{n} \deg(v_i) = 2|E|
    $$
    例如，在一个由6台服务器组成的数据中心网络中，如果已知存在7条直接通信链路，那么其[邻接矩阵](@entry_id:151010)的所有元素之和必然为 $2 \times 7 = 14$ [@problem_id:1348811]。这个性质为验证图的表示提供了一个快速的校验方法。

#### 邻接矩阵的幂：揭示[路径信息](@entry_id:169683)

邻接矩阵的强大之处不仅在于它能描述直接连接，更在于它的代数运算能够揭示图的深层连接属性，特别是路径。一个长度为 $k$ 的**途径 (walk)** 是一个顶点序列 $v_{i_0}, v_{i_1}, \dots, v_{i_k}$，其中每对相邻的顶点 $(v_{i_{j-1}}, v_{i_j})$ 之间都有一条边。

考虑[邻接矩阵](@entry_id:151010)的平方 $A^2 = A \times A$。根据矩阵乘法的定义，其 $(i, j)$ 位置的元素为：
$$
(A^2)_{ij} = \sum_{k=1}^{n} A_{ik}A_{kj}
$$
分析这个求和式：$A_{ik}A_{kj}$ 的乘积为 $1$ 当且仅当 $A_{ik}=1$ 且 $A_{kj}=1$，这表示存在一个从 $v_i$ 到 $v_k$ 的边，并且存在一个从 $v_k$ 到 $v_j$ 的边。这恰好构成了一条从 $v_i$ 经过中间顶点 $v_k$ 到达 $v_j$ 的长度为2的途径。因此，$(A^2)_{ij}$ 的值等于从 $v_i$ 到 $v_j$ 的长度为2的途径的总数 [@problem_id:1348766]。

这个结论可以推广：**[邻接矩阵](@entry_id:151010)的 $k$ 次幂 $A^k$ 中，元素 $(A^k)_{ij}$ 的值等于从顶点 $v_i$ 到顶点 $v_j$ 的长度为 $k$ 的途径的数量。**

这个性质有一个特别重要的推论。考虑 $A^2$ 的对角线元素 $(A^2)_{ii}$。它表示从 $v_i$ 出发再回到 $v_i$ 的长度为2的途径数量。这样的一条途径必然是 $v_i \to v_k \to v_i$ 的形式，其中 $v_k$ 是 $v_i$ 的一个邻居。因此，这样的途径数量等于 $v_i$ 的邻居数量，也就是 $v_i$ 的度。
$$
(A^2)_{ii} = \deg(v_i)
$$
这意味着，即使我们没有原始的邻接矩阵 $A$，只要有 $A^2$，我们仍然可以通过其对角线元素确定每个[顶点的度](@entry_id:264944)。进而，利用握手定理，我们可以计算出图的总边数 $|E| = \frac{1}{2} \sum_i \deg(v_i) = \frac{1}{2} \sum_i (A^2)_{ii}$ [@problem_id:1348793]。

### 扩展模型：有向图、[加权图](@entry_id:274716)与[多重图](@entry_id:261576)

基础的[邻接矩阵](@entry_id:151010)模型功能强大，但可以通过放宽其定义中的限制来表示更复杂的图结构。

#### 有向图 (Directed Graphs)

在有向图（directed graph，简称 digraph）中，边具有[方向性](@entry_id:266095)。一条从 $v_i$ 到 $v_j$ 的边 $(v_i, v_j)$ 不再意味着存在一条从 $v_j$ 到 $v_i$ 的边。这导致邻接矩阵的定义变为：
$$
A_{ij} = \begin{cases} 1 & \text{如果存在一条从 } v_i \text{ 到 } v_j \text{ 的边} \\ 0 & \text{否则} \end{cases}
$$
由于连接不再是相互的，[有向图](@entry_id:272310)的邻接矩阵**通常不是对称的**。这也引出了两种不同的度的概念：
-   **[出度](@entry_id:263181) (Out-degree)**：从顶点 $v_i$ 出发的边的数量，等于第 $i$ 行的和：$\deg^+(v_i) = \sum_{j=1}^{n} A_{ij}$。
-   **入度 (In-degree)**：指向顶点 $v_i$ 的边的数量，等于第 $i$ 列的和：$\deg^-(v_i) = \sum_{j=1}^{n} A_{ji}$。

一个有趣的问题是，邻接矩阵的[转置](@entry_id:142115) $A^T$ 代表什么？根据转置的定义，$(A^T)_{ij} = A_{ji}$。因此，在由 $A^T$ 表示的新图 $G'$ 中，存在一条从 $v_i$到 $v_j$ 的边当且仅当在原图 $G$ 中存在一条从 $v_j$ 到 $v_i$ 的边。换言之，$G'$ 是将 $G$ 中**所有边的方向反转**后得到的图 [@problem_id:1348790]。

#### [加权图](@entry_id:274716)与[多重图](@entry_id:261576)

我们可以进一步放宽[邻接矩阵](@entry_id:151010)中元素只能是 $0$ 或 $1$ 的限制，以表示更丰富的信息。

-   **[加权图](@entry_id:274716) (Weighted Graphs)**：在许多应用中，边不仅表示连接，还关联一个数值，如成本、距离、带宽或权重。例如，在一个表示城市间高速公路网的图中，我们可以让[矩阵元](@entry_id:186505)素 $T_{ij}$ 代表从城市 $i$ 到城市 $j$ 的单向高速公路的通行费 [@problem_id:1348815]。如果两地之间没有直达公路，则该条目可以为 $0$ 或 $\infty$（取决于具体算法的需要）。在这种**加权[邻接矩阵](@entry_id:151010)**中，元素可以是任何实数。

-   **[多重图](@entry_id:261576) (Multigraphs)**：当两个顶点之间允许多条平行边，或者顶点允许有[自环](@entry_id:274670)时，我们称之为[多重图](@entry_id:261576)。为了表示这种情况，我们可以让矩阵元素 $M_{ij}$ 成为一个非负整数，表示连接顶点 $v_i$ 和 $v_j$ 的边的**数量**。例如，在一个服务器网络中，如果服务器 $S_1$ 和 $S_2$ 之间有两条独立的物理链路，则 $M_{12}=M_{21}=2$。如果服务器 $S_2$ 上有一个用于诊断的[自环](@entry_id:274670)，则 $M_{22}=1$ [@problem_id:1348777]。
    对于这种基于重数的邻接矩阵，[矩阵元](@entry_id:186505)素的总和与边数的关系变得微妙。总边数 $|E|$ 是所有不同边的计数，包括平行边和自环。可以证明，矩阵所有元素的总和等于 $2|E|$ 减去自环的总[重数](@entry_id:136466)（即对角[线元](@entry_id:196833)素之和）。

### [邻接表](@entry_id:266874)：一种以连接为中心的视角

邻接矩阵提供了一种全局的、结构化的视图，但对于某些任务和某些类型的图来说，它可能不是最高效的。**[邻接表](@entry_id:266874)**提供了另一种以顶点为中心的表示方法。

一个[邻接表](@entry_id:266874)是一个由 $n$ 个列表组成的数组（或字典），记为 `Adj`。其中，第 $i$ 个列表 `Adj[i]` 包含所有与顶点 $v_i$ 直接相邻的顶点的索引。

例如，对于问题 [@problem_id:1348811] 中的服务器网络，其[邻接表](@entry_id:266874)表示如下：
-   Adj[1]: [2, 4]
-   Adj[2]: [1, 3, 5]
-   Adj[3]: [2, 6]
-   Adj[4]: [1, 5]
-   Adj[5]: [2, 4, 6]
-   Adj[6]: [3, 5]

从[邻接矩阵](@entry_id:151010)构建[邻接表](@entry_id:266874)是一个常见的任务。对于一个[无向图](@entry_id:270905)，由于其[邻接矩阵](@entry_id:151010) $A$ 是对称的，我们可以通过只遍历矩阵的上三角部分（即 $j > i$ 的元素）来避免重复工作。当发现 $A_{ij}=1$ 时，我们将 $j$ 添加到 $v_i$ 的[邻接表](@entry_id:266874)，同时将 $i$ 添加到 $v_j$ 的[邻接表](@entry_id:266874) [@problem_id:1348778]。这个过程清晰地展示了两种表示法之间的内在联系。

### 两种结构的抉择：选择合适的表示法

邻接矩阵和[邻接表](@entry_id:266874)各有优劣，选择哪一种取决于图的特性以及我们希望执行的操作类型。这是一个在[算法设计](@entry_id:634229)和系统实现中至关重要的决策。

#### 核心操作的[时间复杂度](@entry_id:145062)

让我们比较两种结构在执行[基本图](@entry_id:160617)操作时的效率 [@problem_id:1348803]。

-   **检查边是否存在**：要确定顶点 $v_i$ 和 $v_j$ 之间是否存在一条边。
    -   **邻接矩阵**：这是一个 $O(1)$ 的常数时间操作。我们只需直接[访问矩阵](@entry_id:746217)的 $A_{ij}$ 元素并检查其值。
    -   **[邻接表](@entry_id:266874)**：在最坏情况下，这是一个 $O(\deg(v_i))$ 的操作。我们需要遍历 $v_i$ 的邻居列表 `Adj[i]`，以查找是否存在 $j$。

-   **遍历顶点的所有邻居**：要获取与顶点 $v_i$ 相邻的所有顶点。
    -   **[邻接矩阵](@entry_id:151010)**：这是一个 $O(n)$ 的操作。我们必须遍历第 $i$ 行的全部 $n$ 个元素，以找出值为 $1$ 的那些位置。
    -   **[邻接表](@entry_id:266874)**：这是一个 $O(\deg(v_i))$ 的操作。我们只需遍历 `Adj[i]` 列表即可，其长度就是 $v_i$ 的度。

#### [空间复杂度](@entry_id:136795)

两种结构在内存消耗上的差异尤为显著，这直接关系到它们处理大规模图的能力。

-   **[邻接矩阵](@entry_id:151010)**：它总是一个 $n \times n$ 的矩阵，因此其[空间复杂度](@entry_id:136795)是 $O(n^2)$，与图中的边数无关。

-   **[邻接表](@entry_id:266874)**：它需要存储 $n$ 个顶点的列表头（通常是指针），以及每条边所对应的列表项。对于[无向图](@entry_id:270905)，每条边会在两个列表中出现，因此总的[空间复杂度](@entry_id:136795)为 $O(n + 2|E|) = O(n + |E|)$。

#### 困境：[稀疏图](@entry_id:261439) vs. [稠密图](@entry_id:634853)

[空间复杂度](@entry_id:136795)的差异引出了**[稀疏图](@entry_id:261439) (sparse graph)** 和**[稠密图](@entry_id:634853) (dense graph)** 的概念，这是决定使用何种表示法的关键。

-   **[稀疏图](@entry_id:261439)**：边的数量 $|E|$ 远小于顶点数平方 $n^2$ 的图（例如，$|E|$ 与 $n$ 成正比）。现实世界中的大多数大型网络，如社交网络、万维网、公路网等，都是稀疏的。对于这类图，[邻接表](@entry_id:266874)的 $O(n + |E|)$ [空间复杂度](@entry_id:136795)远优于邻接矩阵的 $O(n^2)$。在一个拥有数百万用户但平均每个用户只有几百个连接的社交网络中，使用邻接矩阵将导致巨大的内存浪费，因为矩阵中绝大多数元素都将是零 [@problem_id:1348809]。

-   **[稠密图](@entry_id:634853)**：边的数量 $|E|$ 接近 $n^2$ 的图。对于这类图，[邻接矩阵](@entry_id:151010)的空间效率是可以接受的，因为大部分空间都得到了有效利用。此外，如果频繁进行边存在性的检查，邻接矩阵的 $O(1)$ 查询速度将成为显著优势。

在实际应用中，我们可以精确计算出两种表示法内存消耗的[平衡点](@entry_id:272705)。例如，对于一个具体的系统架构，可以推导出当[平均度](@entry_id:261638)数达到某个临界值 $d_{crit}$ 时，[邻接表](@entry_id:266874)和[邻接矩阵](@entry_id:151010)的内存开销会变得相等 [@problem_id:1348809]。对于远低于此临界值的图，[邻接表](@entry_id:266874)是更明智的选择。

综上所述，邻接矩阵和[邻接表](@entry_id:266874)是表示图的两种基本语言。[邻接矩阵](@entry_id:151010)以其全局、规整的结构和快速的边查询能力见长，特别适用于[稠密图](@entry_id:634853)和涉及线性代数运算的场景。而[邻接表](@entry_id:266874)则以其空间效率和快速的邻居遍历能力在处理大规模[稀疏图](@entry_id:261439)时大放异彩。作为一名严谨的科学家或工程师，根据具体问题的性质和计算需求来选择最合适的数据结构，是通向高效解决方案的第一步。