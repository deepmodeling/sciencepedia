{"hands_on_practices": [{"introduction": "理论固然重要，但将其应用于实际场景才是真正检验理解的试金石。霍尔婚姻定理为我们判断是否存在完美匹配提供了明确的准则。这个练习将该定理置于一个贴近生活的大学宿舍分配情景中，通过识别一个不满足霍尔条件的“问题”学生子集，你可以亲手证明为什么一个看似合理的分配方案实际上是不可行的 [@problem_id:1382813]。", "problem": "一所大学的住宿部门正在将 Lavender 小组的五名学生分配到 Gold 宿舍的五间单人房中。学生只能被分配到他们列为可接受的房间。住宿部门希望找到一个“完美匹配”，即五名学生中的每一位都被分配到一个唯一的可接受的房间。\n\nLavender 小组的五名学生是 {Amy, Brian, Chloe, David, Emily}。设此集合为 $L$。\nGold 宿舍的五间可用房间是 {G-101, G-102, G-103, G-104, G-105}。\n\n每位学生可接受的房间列表如下：\n- **Amy:** {G-103, G-104}\n- **Brian:** {G-101, G-102}\n- **Chloe:** {G-104, G-105}\n- **David:** {G-101}\n- **Emily:** {G-102}\n\n学生与房间的完美匹配是不可能的。根据霍尔婚姻定理，这种不可能性可以通过找到一个学生子集 $S \\subseteq L$ 来证明，对于这个子集，他们共同愿意入住的唯一房间数量小于该子集中的学生数量。如果我们令 $N(S)$ 为 $S$ 中至少一名学生可接受的所有房间的集合，则此条件写作 $|N(S)|  |S|$。\n\n以下哪个来自 Lavender 小组的学生子集 $S$ 满足条件 $|N(S)|  |S|$？\n\nA. $S = \\{\\text{Amy, Chloe}\\}$\n\nB. $S = \\{\\text{Brian, David, Emily}\\}$\n\nC. $S = \\{\\text{Amy, Brian, Chloe}\\}$\n\nD. $S = \\{\\text{David, Emily}\\}$\n\nE. $S = \\{\\text{Amy, David}\\}$", "solution": "我们已知学生集合 $L=\\{\\text{Amy, Brian, Chloe, David, Emily}\\}$ 和房间集合 $\\{\\text{G-101, G-102, G-103, G-104, G-105}\\}$。对于每个子集 $S \\subseteq L$，令 $N(S)$ 表示 $S$ 中学生可接受房间的并集。根据霍尔婚姻定理，如果存在某个 $S$ 使得 $|N(S)|  |S|$，则完美匹配是不可能的。我们逐一检查所列选项。\n\n对于选项 A，$S=\\{\\text{Amy, Chloe}\\}$。可接受的房间是：\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-104, G-105}\\}=\\{\\text{G-103, G-104, G-105}\\}.$$\n因此 $|S|=2$ 且 $|N(S)|=3$。由于 $|N(S)| \\ge |S|$，此条件未被违反。\n\n对于选项 B，$S=\\{\\text{Brian, David, Emily}\\}$。可接受的房间是：\n$$N(S)=\\{\\text{G-101, G-102}\\}\\cup\\{\\text{G-101}\\}\\cup\\{\\text{G-102}\\}=\\{\\text{G-101, G-102}\\}.$$\n因此 $|S|=3$ 且 $|N(S)|=2$。由于 $|N(S)|  |S|$，这违反了霍尔条件，证明了完美匹配是不可能的。\n\n对于选项 C，$S=\\{\\text{Amy, Brian, Chloe}\\}$。可接受的房间是：\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-101, G-102}\\}\\cup\\{\\text{G-104, G-105}\\}=\\{\\text{G-101, G-102, G-103, G-104, G-105}\\}.$$\n因此 $|S|=3$ 且 $|N(S)|=5$。由于 $|N(S)| \\ge |S|$，此条件未被违反。\n\n对于选项 D，$S=\\{\\text{David, Emily}\\}$。可接受的房间是：\n$$N(S)=\\{\\text{G-101}\\}\\cup\\{\\text{G-102}\\}=\\{\\text{G-101, G-102}\\}.$$\n因此 $|S|=2$ 且 $|N(S)|=2$。由于 $|N(S)| \\ge |S|$，此条件未被违反。\n\n对于选项 E，$S=\\{\\text{Amy, David}\\}$。可接受的房间是：\n$$N(S)=\\{\\text{G-103, G-104}\\}\\cup\\{\\text{G-101}\\}=\\{\\text{G-101, G-103, G-104}\\}.$$\n因此 $|S|=2$ 且 $|N(S)|=3$。由于 $|N(S)| \\ge |S|$，此条件未被违反。\n\n因此，在这些选项中，唯一满足 $|N(S)|  |S|$ 的子集是选项 B。", "answer": "$$\\boxed{B}$$", "id": "1382813"}, {"introduction": "在确定一个匹配存在之后，我们如何系统地找到它呢？增广路算法是寻找最大匹配的核心方法。这个练习让你扮演算法的角色，从一个空匹配开始，通过逐步寻找和应用增广路来迭代地扩大匹配，从而直观地理解算法如何一步步构建出更优的解决方案 [@problem_id:1520050]。", "problem": "考虑一个二分图 $G = (U \\cup V, E)$，其中顶点划分是 $U = \\{u_1, u_2, u_3, u_4\\}$ 和 $V = \\{v_1, v_2, v_3, v_4\\}$。边集 $E$ 由 $\\{(u_1, v_1), (u_1, v_2), (u_1, v_3), (u_2, v_1), (u_3, v_1)\\}$ 给出。\n\n使用增广路径算法来寻找最大匹配，该算法从一个空匹配 $M_0 = \\emptyset$ 开始，并迭代地增加其大小。在每次迭代中，找到一条关于当前匹配的增广路径，并通过取匹配与该路径的对称差来更新匹配。\n\n你需要精确地执行该算法的两次迭代。在每一步选择增广路径的规则如下：\n1.  路径必须具有最小可能数量的边（即，它必须是一条最短增广路径）。\n2.  如果存在多条最短增广路径，你必须选择字典序最小的那一条。一条路径由其顶点序列表示，例如 $(w_0, w_1, \\dots, w_k)$。路径根据顶点排序 $u_1  u_2  u_3  u_4  v_1  v_2  v_3  v_4$ 进行逐元素比较。\n\n从空匹配 $M_0$ 开始，根据规则确定第一条增广路径 $P_1$，以创建一个新的匹配 $M_1 = M_0 \\Delta P_1$。然后，相对于 $M_1$，找到第二条增广路径 $P_2$，以创建最终匹配 $M_2 = M_1 \\Delta P_2$。\n\n以下哪个边集表示最终匹配 $M_2$？\n\nA. $\\{(u_1, v_1), (u_2, v_1)\\}$\n\nB. $\\{(u_1, v_1)\\}$\n\nC. $\\{(u_1, v_2), (u_2, v_1)\\}$\n\nD. $\\{(u_1, v_3), (u_2, v_1)\\}$\n\nE. $\\{(u_1, v_2), (u_3, v_1)\\}$", "solution": "我们在二分图 $G=(U\\cup V,E)$ 中进行操作，其中 $U=\\{u_{1},u_{2},u_{3},u_{4}\\}$，$V=\\{v_{1},v_{2},v_{3},v_{4}\\}$，且 $E=\\{(u_{1},v_{1}), (u_{1},v_{2}), (u_{1},v_{3}), (u_{2},v_{1}), (u_{3},v_{1})\\}$。我们使用对称差 $\\Delta$ 来更新匹配。\n\n**第一次迭代**\n我们从空匹配 $M_{0}=\\emptyset$ 开始。此时所有顶点都是未匹配（自由）的。\n1.  **寻找增广路 $P_1$**：一条增广路径必须连接两个未匹配的顶点。由于没有匹配边，任何一条边本身就是一条长度为1的增广路径。这些路径包括 $(u_1, v_1), (u_1, v_2), (u_1, v_3), (u_2, v_1), (u_3, v_1)$。根据规则，我们选择最短的（所有这些都是最短的）且字典序最小的路径。顶点排序为 $u_1  u_2  u_3  u_4  v_1  v_2  v_3  v_4$。路径 $(u_1, v_1)$ 在字典序上是最小的。因此，$P_1$ 就是这条边。\n2.  **更新匹配 $M_1$**：$M_1 = M_0 \\Delta P_1 = \\emptyset \\Delta \\{(u_1, v_1)\\} = \\{(u_1, v_1)\\}$。\n\n**第二次迭代**\n当前匹配为 $M_1 = \\{(u_1, v_1)\\}$。未匹配的顶点为 $U' = \\{u_2, u_3, u_4\\}$ 和 $V' = \\{v_2, v_3, v_4\\}$。\n1.  **寻找增广路 $P_2$**：我们需要寻找一条从 $U'$ 中的顶点开始，到 $V'$ 中的顶点结束的 $M_1$-交错路。最短的此类路径长度为3，形如 $u' \\to v \\to u \\to v'$，其中 $(u,v) \\in M_1$。\n    *   我们寻找以 $u_1$ 的匹配顶点 $v_1$ 为中心的交错路。\n    *   可能的路径有：\n        *   $u_2 \\to v_1 \\to u_1 \\to v_2$（路径序列：$(u_2, v_1, u_1, v_2)$）\n        *   $u_2 \\to v_1 \\to u_1 \\to v_3$（路径序列：$(u_2, v_1, u_1, v_3)$）\n        *   $u_3 \\to v_1 \\to u_1 \\to v_2$（路径序列：$(u_3, v_1, u_1, v_2)$）\n        *   $u_3 \\to v_1 \\to u_1 \\to v_3$（路径序列：$(u_3, v_1, u_1, v_3)$）\n    *   所有这些路径的长度都为3，是（最短）增广路。根据字典序规则，$(u_2, v_1, u_1, v_2)$ 是最小的。所以，$P_2$ 的边集为 $\\{(u_2, v_1), (v_1, u_1), (u_1, v_2)\\}$。\n2.  **更新匹配 $M_2$**：$M_2 = M_1 \\Delta P_2 = \\{(u_1, v_1)\\} \\Delta \\{(u_2, v_1), (u_1, v_1), (u_1, v_2)\\}$。\n    *   移除 $M_1$ 中属于 $P_2$ 的边：移除 $(u_1, v_1)$。\n    *   添加 $P_2$ 中不属于 $M_1$ 的边：添加 $(u_2, v_1)$ 和 $(u_1, v_2)$。\n    *   结果为 $M_2 = \\{(u_2, v_1), (u_1, v_2)\\}$。\n\n因此，最终的匹配 $M_2$ 是 $\\{(u_1, v_2), (u_2, v_1)\\}$。", "answer": "$$\\boxed{C}$$", "id": "1520050"}, {"introduction": "在算法设计中，我们常常在“最优”和“高效”之间寻求平衡。贪心算法因其简单直观而备受青睐，但它们能否保证得到最优解呢？本练习通过一个精心设计的分布式计算任务分配场景，让你分析一个特定贪心策略的表现，并将其与最优解进行比较。通过计算性能比，你将深刻体会到，局部最优的选择有时会导致全局结果的显著偏差，这正是算法分析中一个至关重要的概念 [@problem_id:1520052]。", "problem": "在一个大规模分布式计算环境中，资源管理器需要将任务分配给处理节点。对于给定的整数参数 $k \\ge 1$，该系统由两组节点组成：一组 $2k$ 个“提供者”节点 $A$ 和一组 $2k$ 个“请求者”节点 $B$。这些节点被分组成 $k$ 个独立的集群，索引从 $1$ 到 $k$。对于每个索引 $i \\in \\{1, \\ldots, k\\}$，集群 $i$ 由两个提供者节点 $\\{a_{i,1}, a_{i,2}\\}$ 和两个请求者节点 $\\{b_{i,1}, b_{i,2}\\}$ 组成。\n\n在任何集群 $i$ 内部，提供者和请求者之间的兼容性定义如下，形成一个二分图：\n1.  **直接链接**：节点 $a_{i,1}$ 可以服务于节点 $b_{i,1}$，节点 $a_{i,2}$ 可以服务于节点 $b_{i,2}$。这些构成了直接链接集合。\n2.  **备份链接**：节点 $a_{i,1}$ 也可以服务于节点 $b_{i,2}$。这构成了备份链接集合。\n不存在其他兼容性；具体来说，来自不同集群的节点不能连接。\n\n系统使用一个简单的、确定性的贪心算法进行分配。该算法优先处理备份链接，而不是直接链接。它分两个连续的阶段运行：\n- **阶段 1**：算法遍历整个系统中所有可能的备份链接。对于它所考虑的每个备份链接 $(u, v)$，如果节点 $u$ 和节点 $v$ 当前都未被分配，它就将它们相互分配。\n- **阶段 2**：完成阶段 1 后，算法遍历所有可能的直接链接。对于它所考虑的每个直接链接 $(u, v)$，如果节点 $u$ 和节点 $v$ 当前都未被分配，它就将它们相互分配。\n\n在每个阶段内，链接的考虑顺序不影响此特定系统架构的结果。令 $N_{greedy}(k)$ 为该贪心算法所做的总分配数，令 $N_{opt}(k)$ 为系统可能的最大分配数（最大匹配的大小）。\n\n确定该系统的性能比率 $\\frac{N_{opt}(k)}{N_{greedy}(k)}$。结果是一个与 $k$ 无关的常数值。", "solution": "问题要求计算一个特定的贪心匹配算法与一个在特殊构造的二分图族上的最优匹配的性能比率。我们来分析贪心算法所做的分配数 $N_{greedy}(k)$ 和可能的最大分配数 $N_{opt}(k)$。\n\n首先，我们正式定义给定 $k \\ge 1$ 的二分图 $G_k = (L_k \\cup R_k, E_k)$。\n顶点的两个部分是提供者节点和请求者节点：\n$L_k = \\bigcup_{i=1}^{k} \\{a_{i,1}, a_{i,2}\\}$\n$R_k = \\bigcup_{i=1}^{k} \\{b_{i,1}, b_{i,2}\\}$\n每个部分的大小为 $|L_k| = |R_k| = 2k$。\n\n边集 $E_k$ 由直接链接和备份链接组成。\n备份链接的集合是 $E_{backup} = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n直接链接的集合是 $E_{direct} = \\{ (a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n总边集是 $E_k = E_{backup} \\cup E_{direct}$。该图由 $k$ 个不相交的相同组件构成，每个索引 $i$ 对应一个。\n\n**步骤 1：计算贪心匹配的大小, $N_{greedy}(k)$。**\n贪心算法分两个阶段进行。令 $M_G$ 表示由该算法构造的匹配。\n\n**阶段 1：处理备份链接**\n算法考虑 $E_{backup}$ 中的所有边。让我们考虑任意集群 $i$ 的边 $(a_{i,1}, b_{i,2})$。最初，所有节点都未被分配。由于集群是不相交的，一个集群内的分配不影响另一个集群的初始状态。\n对于每个 $i \\in \\{1, \\ldots, k\\}$，算法考虑备份链接 $(a_{i,1}, b_{i,2})$。由于节点 $a_{i,1}$ 和 $b_{i,2}$ 都未被分配，所以这条边被添加到匹配 $M_G$ 中。这种情况对每个集群 $i$ 都会发生。\n阶段 1 完成后，匹配由所有备份链接组成：\n$M_G = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n此时，匹配的大小为 $k$。\n被分配的节点集是：\n- 来自部分 $L_k$：$\\{a_{1,1}, a_{2,1}, \\ldots, a_{k,1}\\}$\n- 来自部分 $R_k$：$\\{b_{1,2}, b_{2,2}, \\ldots, b_{k,2}\\}$\n\n**阶段 2：处理直接链接**\n算法现在考虑 $E_{direct}$ 中的所有边。只有当一条边的两个端点都未被分配时，才能被添加。\n对于每个集群 $i$，直接链接有两种类型：$(a_{i,1}, b_{i,1})$ 和 $(a_{i,2}, b_{i,2})$。\n- 对于链接 $(a_{i,1}, b_{i,1})$：节点 $a_{i,1}$ 在阶段 1 中已经被分配给了 $b_{i,2}$。因此，该链接不能被添加到匹配中。\n- 对于链接 $(a_{i,2}, b_{i,2})$：节点 $b_{i,2}$ 在阶段 1 中已经被分配给了 $a_{i,1}$。因此，该链接不能被添加到匹配中。\n这对所有 $i \\in \\{1, \\ldots, k\\}$ 都成立。因此，在阶段 2 中没有新的边被添加到匹配中。\n\n贪心算法产生的最终匹配是 $M_G = \\{ (a_{i,1}, b_{i,2}) \\mid i=1, \\ldots, k \\}$。\n这个匹配的大小是 $N_{greedy}(k) = |M_G| = k$。\n\n**步骤 2：计算最大匹配的大小, $N_{opt}(k)$。**\n图 $G_k$ 是 $k$ 个相同子图的不相交并集，每个集群 $i$ 对应一个。$G_k$ 的最大匹配是这些子图的最大匹配的并集。让我们找出单个集群 $i$ 的最大匹配。\n集群 $i$ 的子图有节点 $\\{a_{i,1}, a_{i,2}\\}$ 和 $\\{b_{i,1}, b_{i,2}\\}$ 以及边 $(a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}), (a_{i,1}, b_{i,2})$。\n我们可以在这个子图中找到一个完美匹配，例如，通过选择两个直接链接：\n$M_i^* = \\{ (a_{i,1}, b_{i,1}), (a_{i,2}, b_{i,2}) \\}$。\n这个匹配覆盖了集群 $i$ 子图中的所有四个节点。它的大小是 2。由于完美匹配覆盖了所有顶点，所以它必定是该子图的最大匹配。一个集群的最大匹配的大小是 2。\n\n为了找到整个图 $G_k$ 的最大匹配，我们将 $k$ 个不相交集群的每个最大匹配的大小相加。\n$N_{opt}(k) = \\sum_{i=1}^{k} |M_i^*| = \\sum_{i=1}^{k} 2 = 2k$。\n\n**步骤 3：计算性能比率。**\n性能比率是最优匹配的大小除以贪心匹配的大小。\n$$ \\text{性能比率} = \\frac{N_{opt}(k)}{N_{greedy}(k)} = \\frac{2k}{k} = 2 $$\n该比率为 2，与 $k$ 的值无关（对于 $k \\ge 1$）。", "answer": "$$\\boxed{2}$$", "id": "1520052"}]}