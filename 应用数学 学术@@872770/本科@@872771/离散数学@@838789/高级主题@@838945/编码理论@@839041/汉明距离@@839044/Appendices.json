{"hands_on_practices": [{"introduction": "掌握任何新概念都始于对其基本定义的实践。这个练习提供了一个直接计算两个给定二进制字符串之间汉明距离的机会，旨在巩固“计算不同比特位置数量”这一核心定义。在探索更复杂的性质之前，这是必不可少的第一步[@problem_id:1941052]。", "problem": "在数字通信系统中，汉明距离是用于比较两个等长二进制字符串的度量标准。它被定义为两个字符串中对应位置上比特不同的数量。考虑通过信道传输的两个 8 比特二进制字，字 A 和字 B。\n\n字 A 由二进制字符串 `01000001` 表示。\n字 B 由二进制字符串 `01111010` 表示。\n\n计算字 A 和字 B 之间的汉明距离。", "solution": "两个等长二进制字符串之间的汉明距离定义为对应位置上比特不同的数量。对于长度为 $n$ 的字符串 $x$ 和 $y$，这可以写作\n$$\nd_{H}(x,y)=\\sum_{i=1}^{n} \\mathbf{1}\\{x_{i}\\neq y_{i}\\}=\\text{wt}(x\\oplus y),\n$$\n其中 $\\oplus$ 表示按位异或，$\\text{wt}(\\cdot)$ 是汉明权重（1 的数量）。\n\n给定 $A=01000001$ 和 $B=01111010$，计算其异或值：\n- 按位计算：$0\\oplus 0=0$, $1\\oplus 1=0$, $0\\oplus 1=1$, $0\\oplus 1=1$, $0\\oplus 1=1$, $0\\oplus 0=0$, $0\\oplus 1=1$, $1\\oplus 0=1$。\n- 因此，\n$$\nA\\oplus B=00111011.\n$$\n计算 $00111011$ 中 1 的数量：共有 $5$ 个 1。因此，\n$$\nd_{H}(A,B)=5.\n$$", "answer": "$$\\boxed{5}$$", "id": "1941052"}, {"introduction": "在直接计算的基础上，我们可以进一步探索汉明距离和汉明权重之间的内在联系。这个问题巧妙地设置了一个谜题：寻找一个与全1字符串和全0字符串保持特定距离的二进制串，实际上等同于确定该串中1和0的数量。这个练习将加深你对二进制空间结构及其内部距离含义的直观理解[@problem_id:1373971]。", "problem": "在数字通信和编码理论中，汉明距离的概念是检错与纠错的基础。二进制串是一个字符序列，其中每个字符是 0 或 1。两个等长二进制串之间的汉明距离定义为它们相应位置上字符不同的数量。\n\n考虑两个参考二进制串 `u = '11111'` 和 `v = '00000'`。你的任务是找出一个长度为 5 的二进制串 `s`，它同时满足以下两个条件：\n1. `s` 和 `u` 之间的汉明距离恰好为 2。\n2. `s` 和 `v` 之间的汉明距离恰好为 3。\n\n以下哪个二进制串是 `s` 的有效选择？\n\nA. `10110`\n\nB. `00110`\n\nC. `11110`\n\nD. `01010`", "solution": "设 $u=11111$，$v=00000$，并设 $s=s_{1}s_{2}s_{3}s_{4}s_{5}$ 是一个长度为 $5$ 的二进制串。两个等长二进制串 $x$ 和 $y$ 之间的汉明距离是 $d_{H}(x,y)=|\\{i:x_{i}\\neq y_{i}\\}|$。\n\n因为对于所有 $i$，$u_{i}=1$，所以 $d_{H}(s,u)$ 等于 $s_{i}=0$ 的位置数量，即 $s$ 中 0 的数量。\n因为对于所有 $i$，$v_{i}=0$，所以 $d_{H}(s,v)$ 等于 $s_{i}=1$ 的位置数量，即 $s$ 中 1 的数量。\n\n条件是：\n$$d_{H}(s,u)=2 \\implies \\text{s 中 0 的数量}=2,$$\n$$d_{H}(s,v)=3 \\implies \\text{s 中 1 的数量}=3.$$\n这两个条件是一致的，因为串的长度为 $5$ 且 $2+3=5$。因此，一个有效的 $s$ 必须恰好包含三个 1 和两个 0。\n\n通过计算 1 和 0 的数量来检查每个选项：\n- A: $10110$ 有三个 1 和两个 0，所以 $d_{H}(A,u)=2$ 且 $d_{H}(A,v)=3$。\n- B: $00110$ 有两个 1 和三个 0，所以 $d_{H}(B,u)=3$ 且 $d_{H}(B,v)=2$（不满足）。\n- C: $11110$ 有四个 1 和一个 0，所以 $d_{H}(C,u)=1$ 且 $d_{H}(C,v)=4$（不满足）。\n- D: $01010$ 有两个 1 和三个 0，所以 $d_{H}(D,u)=3$ 且 $d_{H}(D,v)=2$（不满足）。\n\n因此，只有选项 A 同时满足两个条件。", "answer": "$$\\boxed{A}$$", "id": "1373971"}, {"introduction": "最后，让我们通过一个实际的纠错场景来展示汉明距离的强大应用价值。当收到一个信号的多个损坏副本时，我们如何才能最好地猜测原始信号？此问题揭示了寻找一个“共识”字符串，使其与所有接收到的版本之间的总汉明距离最小化，是一种优雅而有效的解决方案。这个实践阐明了一个简单的数学度量如何成为构建可靠通信系统的有力工具[@problem_id:1373967]。", "problem": "在数字通信和信息论中，汉明距离是用于比较两个等长二进制字符串的度量。它被定义为相应符号（比特）不同的位置数量。\n\n考虑一个简单的纠错场景，其中一个5比特的数据包通过三个冗余信道传输。由于传输过程中可能存在噪声，目的地接收到的三个数据包并不相同。接收到的数据包如下：\n$S_1 = 10100$\n$S_2 = 01100$\n$S_3 = 11110$\n\n为了重建最可能的原始数据包，一种常见的策略是找到一个“共识”字符串。这是一个5比特的二进制字符串，我们称之为$C$，它使得与三个接收到的字符串的汉明距离之和最小。也就是说，我们寻求找到字符串$C$，以最小化量$d_H(C, S_1) + d_H(C, S_2) + d_H(C, S_3)$。\n\n找出这个5比特的二进制共识字符串$C$。", "solution": "两个长度为5的二进制字符串$x$和$y$之间的汉明距离定义为$d_{H}(x,y)$，即它们不同位置的数量。我们寻求最小化的和可以按位置分解：\n$$\n\\sum_{i=1}^{3} d_{H}(C,S_{i})=\\sum_{j=1}^{5}\\sum_{i=1}^{3}\\mathbf{1}\\{C_{j}\\neq (S_{i})_{j}\\}.\n$$\n由于该和可以按位置$j$分解，每个位置上$C_{j}$的最优选择是最小化与该位置上三个接收比特不一致的数量。因此，对于每个坐标$j$，$C_{j}$应等于$\\{(S_{1})_{j},(S_{2})_{j},(S_{3})_{j}\\}$中的多数比特。\n\n我们对每个位置进行评估：\n- 位置1：比特为$\\{1,0,1\\}$，多数为$1$，所以$C_{1}=1$。\n- 位置2：比特为$\\{0,1,1\\}$，多数为$1$，所以$C_{2}=1$。\n- 位置3：比特为$\\{1,1,1\\}$，多数为$1$，所以$C_{3}=1$。\n- 位置4：比特为$\\{0,0,1\\}$，多数为$0$，所以$C_{4}=0$。\n- 位置5：比特为$\\{0,0,0\\}$，多数为$0$，所以$C_{5}=0$。\n\n因此，共识字符串是$C=11100$。最小总汉明距离等于每个位置上少数比特的数量之和，这里是$1+1+0+1+0=3$，这证实了其最优性。", "answer": "$$\\boxed{11100}$$", "id": "1373967"}]}