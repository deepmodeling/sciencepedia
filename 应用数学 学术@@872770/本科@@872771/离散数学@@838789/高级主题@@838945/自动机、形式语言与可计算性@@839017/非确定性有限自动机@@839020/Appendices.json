{"hands_on_practices": [{"introduction": "要掌握非确定性有限自动机（NFA），最好的方法就是亲自动手实践。本节的第一个练习将引导你为一个常见的模式识别任务——识别特定后缀——设计一个NFA。这个问题 [@problem_id:1388241] 旨在展示NFA的核心优势：它能够“猜测”一个匹配模式何时开始，而无需用确定性的方式去追踪所有可能的历史记录，从而简化设计。", "problem": "在理论计算机科学领域，非确定性有限自动机（Nondeterministic Finite Automaton, NFA）是一种用于识别文本字符串中模式的计算模型。一个 NFA 被形式化地定义为一个五元组 $M = (Q, \\Sigma, \\delta, q_0, F)$，其中：\n- $Q$ 是一个有限的状态集。\n- $\\Sigma$ 是一个有限的输入符号集，称为字母表。\n- $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ 是转移函数，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集。\n- $q_0 \\in Q$ 是起始状态。\n- $F \\subseteq Q$ 是最终（或接受）状态的集合。\n\n如果存在至少一个从 $q_0$ 开始的转移序列，在处理完整个字符串后能够到达 $F$ 中的某个状态，那么这个 NFA 就接受该字符串。\n\n考虑语言 $L$，它由字母表 $\\Sigma = \\{a, b\\}$ 上所有以子串 'ab' 结尾的字符串组成。以下哪个形式化描述正确地表示了一个恰好接受语言 $L$ 的 NFA？在所有选项中，状态集均为 $Q=\\{q_0, q_1, q_2\\}$，字母表为 $\\Sigma = \\{a, b\\}$，起始状态为 $q_0$。未明确定义的转移被假定映射到空集 $\\emptyset$。\n\nA. $F = \\{q_2\\}$，转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nB. $F = \\{q_2\\}$，转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nC. $F = \\{q_2\\}$，转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n   - $\\delta(q_2, a) = \\{q_2\\}$\n   - $\\delta(q_2, b) = \\{q_2\\}$\n\nD. $F = \\{q_0, q_2\\}$，转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$", "solution": "问题要求我们找出一个接受所有在 $\\Sigma = \\{a, b\\}$ 上以子串 'ab' 结尾的字符串所构成的语言 $L$ 的非确定性有限自动机（NFA）。让我们先分析这个语言的特性，然后评估每个选项。\n\n语言 $L$ 包含像 \"ab\"、\"aab\"、\"bab\" 和 \"abbab\" 这样的字符串。它不包含像空字符串 $\\epsilon$、\"a\"、\"b\"、\"ba\" 或 \"aba\" 这样的字符串。用于此语言的 NFA 必须能够处理任意前缀，然后识别出最后的 'ab' 序列。\n\n让我们逐一分析每个选项：\n\n**选项 A 分析：**\n- $Q = \\{q_0, q_1, q_2\\}$，起始状态 $q_0$，$F = \\{q_2\\}$。\n- 转移：$\\delta(q_0, a) = \\{q_0, q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n\n这个 NFA 的逻辑可以解释如下：\n- 状态 $q_0$ 是初始状态，也是一个“搜索”状态。它消耗任意 'a' 和 'b' 的序列。循环 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$ 允许机器对任何前缀都保持在此状态。\n- 转移 $\\delta(q_0, a) \\ni q_1$ 是非确定性的。当 NFA 在状态 $q_0$ 读入一个 'a' 时，它可以“猜测”这个 'a' 可能是期望的 \"ab\" 后缀的开始。它派生出一个新的计算路径，移动到状态 $q_1$。\n- 状态 $q_1$ 代表了这样一个假设：上一个看到的字符是 \"ab\" 中的 'a'。\n- 如果下一个字符是 'b'，转移 $\\delta(q_1, b) = \\{q_2\\}$ 将这条路径带到最终状态 $q_2$。如果字符串在此结束，它就被接受。\n- 如果在状态 $q_1$ 读到任何其他字符（例如 'a'），或在状态 $q_2$ 读到任何字符，该路径就会消亡，因为没有定义相应的转移。\n\n让我们用一些字符串来测试这个 NFA：\n- 字符串 \"aab\"：\n    1. 从 $q_0$ 开始。读入 'a'。$\\delta(q_0, a) = \\{q_0, q_1\\}$。NFA 现在处于状态集合 $\\{q_0, q_1\\}$ 中。\n    2. 读入 'a'。从 $q_0$ 出发，$\\delta(q_0, a) = \\{q_0, q_1\\}$。从 $q_1$ 出发，$\\delta(q_1, a) = \\emptyset$。结果状态的并集是 $\\{q_0, q_1\\} \\cup \\emptyset = \\{q_0, q_1\\}$。NFA 处于状态 $\\{q_0, q_1\\}$ 中。\n    3. 读入 'b'。从 $q_0$ 出发，$\\delta(q_0, b) = \\{q_0\\}$。从 $q_1$ 出发，$\\delta(q_1, b) = \\{q_2\\}$。结果状态的并集是 $\\{q_0\\} \\cup \\{q_2\\} = \\{q_0, q_2\\}$。\n    4. 字符串结束。最终状态集是 $\\{q_0, q_2\\}$。由于这个集合包含一个最终状态（$q_2 \\in F$），字符串 \"aab\" 被接受。正确。\n- 字符串 \"aba\"：\n    1. 从 $q_0$ 开始。读入 'a'。状态为 $\\{q_0, q_1\\}$。\n    2. 读入 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态为 $\\{q_0, q_2\\}$。\n    3. 读入 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\emptyset$。状态为 $\\{q_0, q_1\\}$。\n    4. 字符串结束。最终状态集是 $\\{q_0, q_1\\}$。此集合不包含任何来自 $F$ 的状态。字符串 \"aba\" 被拒绝。正确。\n这个构造正确地接受了所有以 \"ab\" 结尾的字符串，并拒绝了所有其他字符串。因此，选项 A 是正确答案。\n\n**选项 B 分析：**\n- $F = \\{q_2\\}$，$\\delta(q_0, a) = \\{q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n这个 NFA 的转移是确定性的（每个都映射到一个单元素集或空集）。问题在于转移 $\\delta(q_0, a) = \\{q_1\\}$。一旦读入一个 'a'，机器必须移动到 $q_1$ 并且永远不能返回到 $q_0$。\n- 让我们测试 \"aab\"。从 $q_0$ 开始。读入 'a'。进入 $q_1$。读入 'a'。$\\delta(q_1, a) = \\emptyset$。计算路径在未到达最终状态时就中止了。字符串 \"aab\" 被拒绝，但它应该被接受。因此，选项 B 不正确。这个 NFA 只接受形式为 $b^k ab$（其中 $k \\ge 0$）的字符串。\n\n**选项 C 分析：**\n- $F = \\{q_2\\}$。这个 NFA 与 A 相似，但在最终状态 $q_2$ 上增加了自循环：$\\delta(q_2, a) = \\{q_2\\}$ 和 $\\delta(q_2, b) = \\{q_2\\}$。\n这些循环意味着一旦机器到达最终状态 $q_2$（即，一旦它看到了一个 \"ab\" 子串），无论后面跟什么字符，它都将保持在该最终状态。\n- 让我们测试 \"aba\"。\n    1. 从 $q_0$ 开始。读入 'a'。状态为 $\\{q_0, q_1\\}$。\n    2. 读入 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态为 $\\{q_0, q_2\\}$。\n    3. 读入 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\{q_2\\}$。状态为 $\\{q_0, q_1, q_2\\}$。\n    4. 字符串结束。最终状态集包含 $q_2 \\in F$。字符串 \"aba\" 被接受。这是不正确的，因为 \"aba\" 并非以 \"ab\" 结尾。这个 NFA 接受任何*包含* \"ab\" 作为子串的字符串。因此，选项 C 不正确。\n\n**选项 D 分析：**\n- $F = \\{q_0, q_2\\}$。这个 NFA 的转移与选项 A 中的正确 NFA 相同，但最终状态集不同。在这里，起始状态 $q_0$ 也是一个最终状态。\n因为 $q_0$ 是一个最终状态，所以空字符串 $\\epsilon$ 会被接受，这是不正确的。此外，考虑转移 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$。对于*任何*输入字符串，都存在一条仅停留在状态 $q_0$ 的路径。由于 $q_0$ 是一个接受状态，这条路径将导致该字符串被接受。例如，对于字符串 \"b\"，机器可以遵循路径 $q_0 \\xrightarrow{b} q_0$，在最终状态结束。所以 \"b\" 被接受。这是不正确的。这个 NFA 接受 $\\Sigma^*$ 中的所有字符串。因此，选项 D 不正确。\n\n基于以上分析，只有选项 A 正确描述了指定语言的 NFA。", "answer": "$$\\boxed{A}$$", "id": "1388241"}, {"introduction": "在上一个练习的基础上，我们来探讨一个NFA大放异彩的经典场景：识别基于符号相对于字符串*末尾*位置的模式。这类语言对于确定性自动机（DFA）来说通常很棘手，需要大量状态。这个问题 [@problem_id:1388199] 将让你体会到，如何利用非确定性来构建一个异常简洁和高效的自动机，以解决这类问题。", "problem": "在理论计算机科学领域，非确定性有限自动机（NFA）是一种用于识别符号串中模式的计算模型。考虑字母表 $\\Sigma = \\{0, 1\\}$。我们定义语言 $L$ 为该字母表上所有二进制串的集合，其中倒数第三个符号是 $1$。例如，字符串 `1010` 属于 $L$，因为其倒数第三个符号是 `1`，而字符串 `011` 不属于 $L$，因为其倒数第三个符号是 `0`。字符串 `10` 不属于 $L$，因为它太短，没有倒数第三个符号。\n\n一个接受语言 $L$ 的非确定性有限自动机（NFA）所需的最少状态数是多少？", "solution": "设语言为 $L = \\{w \\in \\{0, 1\\}^* \\mid w \\text{ 的倒数第三个符号是 } 1\\}$。我们正在寻找一个接受语言 $L$ 的非确定性有限自动机（NFA）所需的最少状态数。\n\n为该语言设计 NFA 的关键思想是利用非确定性来“猜测”哪个符号是倒数第三个符号。该 NFA 将按以下方式进行：\n1.  读取任意数量的符号（0 或 1），直到它猜测当前位置是输入字符串的倒数第三个符号。\n2.  如果做出此猜测，它必须验证当前符号是 $1$。\n3.  验证该 `1` 之后，它必须接着验证输入字符串中还剩下恰好两个符号。\n\n我们可以构造一个有四个状态的 NFA 来完成此任务。我们将这些状态标记为 $q_0, q_1, q_2, q_3$。\n\n-   **状态 $q_0$（开始状态）：** 这是初始状态。只要 NFA 尚未决定它已经看到了倒数第三个符号，它就一直处于此状态。\n    -   当读取一个 $0$ 时，NFA 保持在状态 $q_0$。\n    -   当读取一个 $1$ 时，NFA 有一个非确定性选择：\n        a) 保持在状态 $q_0$（将此 `1` 解释为不是倒数第三个符号）。\n        b) 转移到状态 $q_1$（猜测此 `1` 是倒数第三个符号）。\n\n-   **状态 $q_1$：** NFA 在猜测刚刚读取了倒数第三个符号（该符号为 `1`）后进入此状态。现在它需要再看到恰好两个符号才能到达字符串的末尾。\n\n-   **状态 $q_2$：** NFA 在处于状态 $q_1$ 并再读取一个符号（0 或 1）后进入此状态。此符号对应于字符串的倒数第二个符号。\n\n-   **状态 $q_3$（接受状态）：** NFA 在处于状态 $q_2$ 并再读取一个符号（0 或 1）后进入此状态。此符号对应于字符串的最后一个符号。由于 NFA 在做出猜测后已成功读取整个字符串，因此这必须是一个接受状态。从 $q_3$ 没有出向转移。如果输入中还有更多符号，则该计算路径终止。\n\n我们来正式总结一下转移：\n-   $\\delta(q_0, 0) = \\{q_0\\}$\n-   $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n-   $\\delta(q_1, 0) = \\{q_2\\}$\n-   $\\delta(q_1, 1) = \\{q_2\\}$\n-   $\\delta(q_2, 0) = \\{q_3\\}$\n-   $\\delta(q_2, 1) = \\{q_3\\}$\n\n状态集为 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n开始状态是 $q_0$。\n最终状态集为 $F = \\{q_3\\}$。\n\n此构造使用了 4 个状态。\n\n为了论证这是最少状态数，我们可以使用 Myhill-Nerode 定理对 NFA 的扩展，或者一个更直观的论证。对于该语言，一个 NFA 必须在某种意义上“记住”它已经看到了一个 `1`，然后计算出已经过去了两个字符。为了区分以 $1xx$（其中 $x$ 是 0 或 1）结尾的字符串与其他字符串，自动机需要一条长度至少为 3 的路径来处理序列 `1`、`x`、`x` 然后接受。一条长度为 3 的路径需要 4 个不同的状态。例如，考虑输入 `100` 时的路径：$q_0 \\xrightarrow{1} q_1 \\xrightarrow{0} q_2 \\xrightarrow{0} q_3$。该路径包含 3 次转移，涉及 4 个状态。如果我们有少于 4 个状态，比如 3 个状态，那么任何长度为 3 的路径都必须包含一个循环。这将意味着自动机也会接受其他长度的字符串（例如，$1(xx)^k$，对于某个 $k>1$），其中原始的 `1` 将不再处于倒数第三的位置，从而导致接受了不正确的语言。因此，至少需要 4 个状态。", "answer": "$$\\boxed{4}$$", "id": "1388199"}, {"introduction": "设计自动机只是第一步，理解其工作原理同样至关重要。这个练习将我们的重点从“设计”转向“分析”，要求你追踪一个NFA在处理给定输入字符串时的完整计算过程。特别地，该练习 [@problem_id:1388210] 引入了 $\\epsilon$-转移，它允许状态在不消耗任何输入符号的情况下发生改变，这是NFA一个强大而独特的特性。通过这个练习，你将学会如何系统地追踪所有并行的计算路径。", "problem": "一位计算机科学家正在设计一个基于非确定性有限自动机 (NFA) 的简单词法分析工具，用于在二进制数据流中检测特定模式。该 NFA 的形式化定义包含以下组成部分：\n- 状态集 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 输入字母表 $\\Sigma = \\{0, 1\\}$。\n- 起始状态 $q_{start} = q_0$。\n- 接受状态集 $F = \\{q_3\\}$。\n\n转移函数 $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$（其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，$\\epsilon$ 表示空字符串）由以下规则表给出。请注意，如果某个状态-输入对未在表中列出，则其转移将指向空集 $\\emptyset$。\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\epsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\n给定输入字符串 `101`，确定在处理完整个字符串后，该自动机可能处于的所有状态的集合。请从以下选项中选择正确的集合。\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "对于带有 $\\epsilon$-转移的 NFA，在每一步中，我们首先计算当前状态集的 $\\epsilon$-闭包，然后根据输入符号进行转移，最后再次计算 $\\epsilon$-闭包。令 $\\text{E}(S)$ 表示集合 $S$ 的 $\\epsilon$-闭包。未指定的转移将指向空集。\n\n初始闭包：\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\n读取第一个符号 $1$ 后：\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\n读取第二个符号 $0$ 后：\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\n读取第三个符号 $1$ 后：\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\n因此，在处理完整个字符串 $101$ 后，可能的状态集为 $\\{q_{0},q_{1},q_{2},q_{3}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1388210"}]}