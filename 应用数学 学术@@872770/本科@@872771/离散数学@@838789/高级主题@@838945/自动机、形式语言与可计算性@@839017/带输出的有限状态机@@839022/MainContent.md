## 引言
在[计算理论](@entry_id:273524)的基石中，[有限状态机](@entry_id:174162)（FSM）提供了一个强大的框架，用于对具有[有限记忆](@entry_id:136984)的系统进行建模。然而，基础的FSM主要作为“识别器”，判断输入序列是否符合特定模式，却无法直接描述那些需要根据输入主动生成响应或信号的系统。现实世界中，从数字电路的控制器到复杂的通信协议，系统不仅需要改变内部状态，更需要产生输出，这便暴露了基础模型的局限性。

本文旨在填补这一认知空白，系统地介绍**[带输出的有限状态机](@entry_id:276334)**。我们将超越简单的接受/拒绝模型，深入探讨系统如何与环境进行动态交互。读者将学习到两种实现这一功能的经典模型——**米里机 (Mealy Machine)** 和**[摩尔机](@entry_id:170836) (Moore Machine)**，并理解它们在设计理念上的根本差异。

文章将分三个章节展开：
- 在“**原理与机制**”中，我们将建立坚实的理论基础，详细定义米里机和[摩尔机](@entry_id:170836)，探讨它们的表示方法、行为特性、等价性以及如何通过[状态最小化](@entry_id:273227)来优化设计。
- 接着，在“**应用与[交叉](@entry_id:147634)学科联系**”中，我们将理论付诸实践，展示这些模型在[数字逻辑](@entry_id:178743)、算法设计、控制理论乃至合成生物学等不同领域中的具体应用，彰显其作为通用建模工具的强大威力。
- 最后，通过“**动手实践**”部分，您将有机会通过解决具体问题来巩固所学知识，从模拟追踪到设计调试，亲身体验状态机的运作逻辑。

通过本次学习，您将能够精确地分析、设计和优化那些需要生成输出序列的离散动态系统，为深入学习更高级的计算主题打下坚实的基础。

## 原理与机制

在前面的章节中，我们已经了解了[有限状态机](@entry_id:174162)（FSM）作为一种计算模型的抽象概念，它通过一组有限的[状态和](@entry_id:193625)在这些状态之间的转换来对系统行为进行建模。然而，许多现实世界的系统不仅需要根据输入改变其内部状态，还需要产生输出——无论是控制信号、计算结果还是用户反馈。本章将深入探讨两种主要的带有输出的[有限状态机](@entry_id:174162)模型：**米里机 (Mealy Machine)** 和**[摩尔机](@entry_id:170836) (Moore Machine)**。我们将详细阐述它们的定义、工作原理、表示方法，并探讨它们之间的等价性、转换方法以及[状态最小化](@entry_id:273227)等关键主题。

### 两种基本模型：米里机与[摩尔机](@entry_id:170836)

带有输出的[有限状态机](@entry_id:174162)的核心区别在于其输出的生成机制。具体来说，输出是仅取决于当前状态，还是同时取决于当前[状态和](@entry_id:193625)当前输入？这个问题引出了两种不同的模型。

#### [摩尔机](@entry_id:170836)：输出与状态绑定

**[摩尔机](@entry_id:170836)**是一种其输出值完全由其当前状态决定的[有限状态机](@entry_id:174162)。换句话说，一旦机器进入某个状态，其输出就固定了，无论接下来会接收到什么输入。我们可以将[摩尔机](@entry_id:170836)的输出函数 $\lambda$ 表示为从状态集合 $S$到输出字母表 $\Lambda$ 的映射：

$Z = \lambda(S)$

其中 $S$ 是当前状态，$Z$ 是对应的输出。

这种模型的直观理解是，输出是状态的一个属性。例如，一个交通信号灯系统可以被建模为[摩尔机](@entry_id:170836)，其中“红灯亮”、“黄灯亮”和“绿灯亮”是三个状态，而灯的颜色（输出）是每个状态固有的一部分。

#### 米里机：输出与转换绑定

与[摩尔机](@entry_id:170836)不同，**米里机**的输出取决于当前[状态和](@entry_id:193625)当前输入的组合。这意味着，即使机器处于同一状态，不同的输入也可能导致不同的输出。因此，米里机的输出函数 $\lambda$ 是一个从状态与输入的[笛卡尔积](@entry_id:154642) $S \times \Sigma$ 到输出字母表 $\Lambda$ 的映射：

$Z = \lambda(S, X)$

其中 $S$ 是当前状态，$X$ 是当前输入，$Z$ 是产生的输出。

米里机的输出与状态转换紧密相关。你可以将其想象为，输出是在从一个状态转移到另一个状态的“路径上”生成的。

#### 一个说明性示例：[序列检测器](@entry_id:261086)

为了更清晰地区分这两种模型，让我们考虑一个旨在检测二[进制](@entry_id:634389)输入序列 `101` 的数字系统 [@problem_id:1935261]。

- **系统 A (米里机)** 的设计目标是：当且仅当机器刚刚接收到序列 `101` 的最后一个 `1` 时，输出 $Z$ 为 `1`。这意味着，输出为 `1` 的条件是：机器的内部[状态表](@entry_id:178995)明之前已接收到[子序列](@entry_id:147702) `10`，并且当前输入 $X$ 为 `1`。在这里，输出 $Z$ 显然是当前状态（“已接收10”）和当前输入（“1”）的函数。因此，系统 A 是一个典型的**米里机**。

- **系统 B ([摩尔机](@entry_id:170836))** 的设计思路不同：它设置了一个特定的“检测”状态，只有在完整的序列 `101` 被接收后，机器才会进入该状态。输出 $Z$ 的规则是：只要机器处于这个“检测”状态，输出就为 `1`；在所有其他状态下，输出为 `0`。在这种情况下，输出仅与机器所处的状态相关，而与触发进入该状态的输入无关。因此，系统 B 是一个**[摩尔机](@entry_id:170836)**。

这个例子深刻地揭示了两种模型在逻辑上的根本差异 [@problem_id:1386390]。[摩尔机](@entry_id:170836)的输出与状态相关联（“我是什么状态，就输出什么”），而米里机的输出与状态转换相关联（“我从什么状态，接收了什么输入，就输出什么”）。

### 形式化表示

为了精确地描述和分析这些机器，我们通常使用[状态表](@entry_id:178995)或[状态图](@entry_id:176069)。这两种表示法都能清晰地揭示机器是米里机还是[摩尔机](@entry_id:170836)。

#### [状态表](@entry_id:178995)

[状态表](@entry_id:178995)是一种表格形式的表示，它列出了所有可能的状态转换和相应的输出。

对于一个**[摩尔机](@entry_id:170836)**，其[状态表](@entry_id:178995)的显著特征是有一个独立的输出列。该列中的每个值都与当前状态行[一一对应](@entry_id:143935)，表明输出仅依赖于当前状态。

例如，请看下面控制器 Alpha 的[状态表](@entry_id:178995) [@problem_id:1962893]：

| Present State (PS) | Next State (NS) if X=0 | NS if X=1 | Output (Z) |
| :---: | :---: | :---: | :---: |
|   S0    |    S1    |    S0    | 0 |
|   S1    |    S2    |    S0    | 0 |
|   S2    |    S2    |    S0    | 1 |

在此表中，$Z$ 列明确指出，无论输入 $X$ 是 `0` 还是 `1`，状态 S0 的输出总是 `0`，S1 的输出总是 `0`，而 S2 的输出总是 `1`。这种结构是[摩尔机](@entry_id:170836)的典型特征。我们可以直接从表中读出每个状态与输出的映射关系，例如，在另一个[摩尔机](@entry_id:170836)中，状态 S1 和 S3 可能都产生输出 'B'，而状态 S2 和 S4 都产生输出 'C' [@problem_id:1962877]。

相比之下，**米里机**的[状态表](@entry_id:178995)将输出与每个状态-输入对（即每次转换）关联起来。输出值通常写在下一状态的旁边。

观察下面控制器 Beta 的[状态表](@entry_id:178995) [@problem_id:1962893]：

| Present State (PS) | NS if X=0 | Z | NS if X=1 | Z |
| :---: | :---: | :-: | :---: | :-: |
|   S0    |    S1    | 0 |    S0    | 0 |
|   S1    |    S2    | 0 |    S0    | 0 |
|   S2    |    S2    | 0 |    S0    | 1 |

在状态 S2 行，当输入 $X=0$ 时，输出为 `0`；而当输入 $X=1$ 时，输出为 `1`。由于在同一状态下输出随输入变化，这明确表明控制器 Beta 是一个米里机。

值得注意的是，即使[状态表](@entry_id:178995)的格式看起来不同，其内在逻辑决定了机器的类型。例如，控制器 Gamma 的表格 [@problem_id:1962893] 尽管为每一行都指定了输入和输出，但仔细观察会发现，对于任何给定的当前状态（如 A、B 或 C），无论输入是 `0` 还是 `1`，其输出 $Z$ 都是相同的。例如，在状态 A，输入 `0` 或 `1` 时输出均为 `1`。因此，Gamma 实际上是一个[摩尔机](@entry_id:170836)。相反，控制器 Delta 在状态 A 时，输入 `0` 输出 `0`，输入 `1` 输出 `1`，这使其成为一个米里机。

### 输出生成动态

两种模型在输出生成机制上的差异直接导致了它们在处理输入序列时行为上的一个重要区别：输出序列的长度。

假设一个长度为 $k$（$k > 0$）的输入序列被馈送到机器中。

- 对于**米里机**，每次处理一个输入符号都会立即生成一个输出符号。这个过程重复 $k$ 次，因此总共会产生一个长度为 $k$ 的输出序列。我们可以说，输出是与输入同步的 [@problem_id:1370720, @problem_id:1386390]。

- 对于**[摩尔机](@entry_id:170836)**，情况有所不同。机器在开始处理任何输入之前，就处于其初始状态，并因此产生一个初始输出。然后，每处理一个输入符号，机器转换到一个新状态，并产生与该新状态相关联的输出。这个过程重复 $k$ 次，总共会产生 $1$ (初始) $+ k$ (转换后) 个输出。因此，对于长度为 $k$ 的输入，[摩尔机](@entry_id:170836)产生长度为 $k+1$ 的输出序列。

让我们通过追踪一个具体的米里机示例来感受其动态行为。考虑一个数字密码锁 [@problem_id:1370721]，其正确密码为 `121`。该锁是一个米里机，其[状态和](@entry_id:193625)输出如下：
- 状态：$S_{locked}$ (初始), $S_{first}$, $S_{second}$, $S_{unlocked}$
- 输出：`0` (静音), `1` (确认音), `2` (开锁音), `3` (错误音)

假设输入序列为 `12101211`。从初始状态 $S_{locked}$ 开始，追踪过程如下：
1.  当前状态 $S_{locked}$，输入 `1`。规则：转到 $S_{first}$，输出 `1`。输出序列: `1`。
2.  当前状态 $S_{first}$，输入 `2`。规则：转到 $S_{second}$，输出 `1`。输出序列: `11`。
3.  当前状态 $S_{second}$，输入 `1`。规则：转到 $S_{unlocked}$，输出 `2` (开锁)。输出序列: `112`。
4.  当前状态 $S_{unlocked}$，输入 `0`。规则：转回 $S_{locked}$ (重锁)，输出 `3`。输出序列: `1123`。
5.  当前状态 $S_{locked}$，输入 `1`。规则：转到 $S_{first}$，输出 `1`。输出序列: `11231`。
6.  当前状态 $S_{first}$，输入 `2`。规则：转到 $S_{second}$，输出 `1`。输出序列: `112311`。
7.  当前状态 $S_{second}$，输入 `1`。规则：转到 $S_{unlocked}$，输出 `2`。输出序列: `1123112`。
8.  当前状态 $S_{unlocked}$，输入 `1`。规则：转回 $S_{locked}$，输出 `3`。输出序列: `11231123`。

最终，长度为 8 的输入序列 `12101211` 产生了长度为 8 的输出序列 `11231123`，这完美地印证了米里机的行为特性。

### 模型间的等价与转换

一个自然的问题是：这两种模型在计算能力上是否等价？答案是肯定的。对于任何米里机，都存在一个行为等价的[摩尔机](@entry_id:170836)，反之亦然。“行为等价”意味着对于任何给定的输入序列，两台机器产生相同的输出序列（尽管[摩尔机](@entry_id:170836)的输出可能会相对于米里机的输出有一个时间单位的延迟）。

#### 从米里机到[摩尔机](@entry_id:170836)的转换

将米里机转换为等价的[摩尔机](@entry_id:170836)是两者转换中较为复杂的一个，因为它可能导致状态数量的增加。其核心思想在于，新的[摩尔机](@entry_id:170836)状态必须“记住”导致进入该状态的米里机转换所产生的输出。

转换算法如下：
1.  **创建[摩尔机](@entry_id:170836)状态**：新的[摩尔机](@entry_id:170836)中的每个状态对应于原米里机中的一个 `(状态, 输出)` 对。具体来说，对于原米里机中的每个状态 $s$ 和每个可能的输入 $i$，如果转换 $\delta(s, i) = s'$ 产生输出 $\lambda(s, i) = o$，我们就可能需要一个表示 $(s', o)$ 的新[摩尔机](@entry_id:170836)状态。我们收集所有这样可达的 `(目标状态, 输出)` 对，形成新状态集。

2.  **定义[摩尔机](@entry_id:170836)输出函数**：对于新的[摩尔机](@entry_id:170836)状态 $(s', o)$，其输出就是 $o$。

3.  **定义[摩尔机](@entry_id:170836)转换函数**：对于新的[摩尔机](@entry_id:170836)状态 $(s, o_{in})$ 和输入 $i$，其下一个状态由原米里机的转换决定。如果原米里机从状态 $s$ 接收输入 $i$ 后转换到 $s'$ 并输出 $o_{out}$，则新的[摩尔机](@entry_id:170836)从状态 $(s, o_{in})$ 接收输入 $i$ 后转换到状态 $(s', o_{out})$。

4.  **确定初始状态**：通常，我们会创建一个专门的初始状态，其输出对应于原米里机在启动时的一个约定输出（例如，0 或一个特殊的“空闲”符号）。

让我们通过一个例子来具体说明。考虑一个用于检测序列 `10` 的米里机 [@problem_id:1370705]。
- 状态：$S = \{s_0, s_1\}$
- 转换与输出：
  - $s_0$ 输入 `0` $\rightarrow$ $s_0$，输出 `0`
  - $s_0$ 输入 `1` $\rightarrow$ $s_1$，输出 `0`
  - $s_1$ 输入 `0` $\rightarrow$ $s_0$，输出 `1` (检测到 `10`)
  - $s_1$ 输入 `1` $\rightarrow$ $s_1$，输出 `0`

要将其转换为[摩尔机](@entry_id:170836)：
1.  **识别状态对**：检查所有转换的 `(目标状态, 输出)` 对：
    - $(s_0, 0)$
    - $(s_1, 0)$
    - $(s_0, 1)$
    这三个是所有可能达到的独特组合。我们将它们命名为新的[摩尔机](@entry_id:170836)状态：$A_0=(s_0, 0)$, $A_1=(s_0, 1)$, $A_2=(s_1, 0)$。
2.  **定义输出**：新状态的输出由其对中的第二个元素决定：
    - $g(A_0) = 0$
    - $g(A_1) = 1$
    - $g(A_2) = 0$
3.  **定义转换**：根据原米里机逻辑计算新状态间的转换：
    - 从 $A_0=(s_0, 0)$ 开始：输入 `0`，原米里机转到 $s_0$ 输出 `0`，故新[摩尔机](@entry_id:170836)转到 $(s_0, 0)$ 即 $A_0$。输入 `1`，原米里机转到 $s_1$ 输出 `0`，故新[摩尔机](@entry_id:170836)转到 $(s_1, 0)$ 即 $A_2$。
    - 从 $A_2=(s_1, 0)$ 开始：输入 `0`，原米里机转到 $s_0$ 输出 `1`，故新[摩尔机](@entry_id:170836)转到 $(s_0, 1)$ 即 $A_1$。输入 `1`，原米里机转到 $s_1$ 输出 `0`，故新[摩尔机](@entry_id:170836)转到 $(s_1, 0)$ 即 $A_2$。
    - 依此类推，可以构建完整的转换表。

这个过程解释了为什么转换可能导致状态数量增加。如果原米里机中的一个状态 $s$ 可以通过多条产生不同输出的转换路径到达，那么在等价的[摩尔机](@entry_id:170836)中，这个单一的米里机状态 $s$ 就必须被“分裂”成多个状态，每个状态对应一个不同的“到达输出” [@problem_id:1370711]。例如，一个拥有 2 个[状态和](@entry_id:193625) 3 个输入符号的米里机，在转换为[摩尔机](@entry_id:170836)时，可能会产生 5 个甚至更多个状态，因为每个原状态都可能与多个不同的输出值配对。理论上，一个有 $n$ 个[状态和](@entry_id:193625) $|O|$ 个可能输出的米里机，其等价的[摩尔机](@entry_id:170836)最多可能有 $n \times |O|$ 个状态，外加一个初始状态。

### [状态最小化](@entry_id:273227)

在设计[状态机](@entry_id:171352)时，一个核心目标是使用最少的状态来实现所需的功能，这不仅可以简化设计，还能降低硬件成本。[状态最小化](@entry_id:273227)的过程就是找到[并合](@entry_id:147963)并所有行为上无法区分的“等价”状态。

#### k-等价与划分细化

[状态最小化](@entry_id:273227)的基础是**[状态等价](@entry_id:261329)**的概念。两个状态 $s_i$ 和 $s_j$ 被认为是**等价**的，如果对于任何可能的输入序列，从 $s_i$ 开始和从 $s_j$ 开始所产生的输出序列都完全相同。

直接测试所有无限长的输入序列是不现实的。因此，我们采用一个迭代的过程，基于**k-等价**的概念。

- **0-等价**：两个状态是 0-等价的，当且仅当它们的输出相同。这是最基本的不可区分性。对于[摩尔机](@entry_id:170836)，这意味着 $\lambda(s_i) = \lambda(s_j)$。

- **k-等价**：两个状态 $s_i$ 和 $s_j$ 是 k-等价的，当且仅当它们是 (k-1)-等价的，并且对于所有单个输入符号 $x$，它们的后继状态 $\delta(s_i, x)$ 和 $\delta(s_j, x)$ 也是 (k-1)-等价的。

这个定义引出了一个优雅的**划分细化算法**：
1.  **初始划分 ($P_0$)**：将所有状态根据其输出进行分组。所有输出相同的状态在同一个初始块中。
2.  **迭代细化**：在第 $k$ 步，我们根据 $P_{k-1}$ 来构造 $P_k$。对于 $P_{k-1}$ 中的每一个块，我们检查其中的状态。如果两个状态 $s_i$ 和 $s_j$ 对于某个输入 $x$，其后继状态 $\delta(s_i, x)$ 和 $\delta(s_j, x)$ 落在 $P_{k-1}$ 的不同块中，那么 $s_i$ 和 $s_j$ 在第 $k$ 步被区分开，必须放入 $P_k$ 的不同块中。
3.  **终止**：当某一步的划分 $P_k$ 与上一步的划分 $P_{k-1}$ 完全相同时，[算法终止](@entry_id:143996)。最终划分中的每个块都代表一个最小化机器中的状态。

让我们看一个具体的例子 [@problem_id:1370740]。考虑一个[访问控制](@entry_id:746212)逻辑单元（ACLU），它是一个[摩尔机](@entry_id:170836)。我们想确定哪些状态是 2-等价但不是 3-等价的。
- **$P_0$ (0-等价)**：根据输出分组。输出为 `R` 的有 $\{s_0, s_1, s_3\}$，输出为 `E` 的有 $\{s_2, s_4\}$，输出为 `G` 的有 $\{s_5, s_6\}$。所以 $P_0 = \{\{s_0, s_1, s_3\}, \{s_2, s_4\}, \{s_5, s_6\}\}$。
- **$P_1$ (1-等价)**：我们检查 $P_0$ 中每个块内的状态。以 $\{s_0, s_1, s_3\}$ 为例。
  - $s_0$ 的后继（输入0, 1）是 $(s_2, s_5)$，它们分别属于 $P_0$ 的 `E` 块和 `G` 块。
  - $s_1$ 的后继是 $(s_4, s_6)$，它们也分别属于 `E` 块和 `G` 块。
  - $s_3$ 的后继是 $(s_5, s_0)$，它们分别属于 `G` 块和 `R` 块。
  由于 $s_3$ 的后继模式 (`G`, `R`) 与 $s_0, s_1$ 的 (`E`, `G`) 不同，$s_3$ 被分离出去。经过对所有状态的分析，我们得到 $P_1 = \{\{s_0, s_1\}, \{s_3\}, \{s_2, s_4\}, \{s_5, s_6\}\}$。
- **$P_2$ (2-等价)**：现在我们用 $P_1$ 的划分来细化。在块 $\{s_5, s_6\}$ 中，它们的后继模式现在根据 $P_1$ 的块来判断，结果发现它们是可区分的，因此 $P_2 = \{\{s_0, s_1\}, \{s_3\}, \{s_2, s_4\}, \{s_5\}, \{s_6\}\}$。
- **$P_3$ (3-等价)**：我们用 $P_2$ 来细化。现在检查 $\{s_0, s_1\}$。
  - $s_0$ 的后继是 $(s_2, s_5)$，在 $P_2$ 中分别属于块 $\{s_2, s_4\}$ 和 $\{s_5\}$。
  - $s_1$ 的后继是 $(s_4, s_6)$，在 $P_2$ 中分别属于块 $\{s_2, s_4\}$ 和 $\{s_6\}$。
  由于它们的后继状态在输入 `1` 时（$s_5$ 和 $s_6$）落在了 $P_2$ 的不同块中，所以 $s_0$ 和 $s_1$ 在这一步被区分开。

因此，$(s_0, s_1)$ 是一对 2-等价（因为在 $P_2$ 中它们仍在同一块）但不是 3-等价（因为在构造 $P_3$ 时它们被分开了）的状态。区分它们的长度为 3 的输入串可以是 `100`，因为从 $s_0$ 开始最终输出 `E`，而从 $s_1$ 开始最终输出 `G`。

### 高级主题：广义等价下的最小化

标准的[状态最小化](@entry_id:273227)算法要求等价状态产生完全相同的输出序列。然而，在某些应用中，我们可能认为某些不同的输出在功能上是等价的。例如，输出 'a' 和 'c' 可能都代表“警告”，而 'b' 和 'd' 都代表“正常”。

我们可以通过在输出字母表上定义一个**等价关系** $\equiv$ 来形式化这个概念 [@problem_id:1370706]。如果 $\lambda(u_i) \equiv \lambda(v_i)$ 对所有 $i \ge 0$ 成立，我们就认为状态 $u$ 和 $v$ 是不可区分的。

这个广义的定义可以无缝地整合到划分细化算法中。唯一的修改在于算法的**第一步**：

- **广义初始划分 ($P_0$)**：不再基于输出的严格相等来划分状态，而是根据输出的**等价类**。如果 $\lambda(s_i) \equiv \lambda(s_j)$，那么 $s_i$ 和 $s_j$ 就在同一个初始块中。

之后的所有细化步骤保持不变。例如，如果输出等价关系由划分 $P_O = \{\{a, c\}, \{b, d\}\}$ 定义，那么所有输出为 $a$ 或 $c$ 的状态都将进入同一个初始块，所有输出为 $b$ 或 $d$ 的状态将进入另一个初始块。

考虑一个拥有状态 $\{s_0, \dots, s_5\}$ 的机器 [@problem_id:1370706]，其输出 $\lambda(s_0)=a, \lambda(s_1)=b, \lambda(s_2)=a, \lambda(s_3)=c, \lambda(s_4)=d, \lambda(s_5)=c$。在上述输出[等价关系](@entry_id:138275)下：
- 初始划分 $P_0$ 将是 $\{\{s_0, s_2, s_3, s_5\}, \{s_1, s_4\}\}$，因为 $\{a, c\}$ 和 $\{b, d\}$ 是两个等价类。

接下来，我们像往常一样应用划分细化算法。经过几轮迭代，我们可能会发现，一些在标准最小化中被区分的状态，在广义定义下却是等价的。例如，原始的 6 个状态的机器，在考虑了输出等价性后，可能被最小化为一个只有 3 个状态的机器。这展示了通过引入领域特定的知识（即输出的等价性）来进一步简化系统模型的强大能力。