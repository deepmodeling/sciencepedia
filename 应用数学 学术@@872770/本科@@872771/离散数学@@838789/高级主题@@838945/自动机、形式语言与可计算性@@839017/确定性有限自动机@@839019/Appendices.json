{"hands_on_practices": [{"introduction": "DFA 的强大之处在于其状态，这些状态可以作为一种有限的内存。本练习将探讨一个基础应用：利用状态来追踪输入字符串的属性，例如对符号出现次数进行计数。通过设计一个能够识别字符‘a’出现次数模3余1的字符串的自动机，你将亲身体验状态如何实现模运算，这是模式识别的基石之一 [@problem_id:1362816]。", "problem": "在计算理论中，确定有限自动机（DFA）是一种理论上的机器模型，它可以识别一个字符串集合，这个集合被称为形式语言。考虑字母表 $\\Sigma = \\{a, b\\}$ 上的一个语言 $L$。一个字符串 $w$ 属于语言 $L$ 的充要条件是，字符串 $w$ 中字符 'a' 出现的总次数模3同余于1。对于任意字符串 $w$，令 $n_a(w)$ 表示 $w$ 中 'a' 的数量。那么，用数学语言表示，该语言为 $L = \\{w \\in \\{a, b\\}^* \\mid n_a(w) \\equiv 1 \\pmod{3}\\}$。注意，空字符串含有零个 'a'。\n\n识别该语言 $L$ 的确定有限自动机（DFA）所需的最少状态数是多少？", "solution": "我们要求解识别语言 $L = \\{w \\in \\{a,b\\}^{*} \\mid n_{a}(w) \\equiv 1 \\pmod{3}\\}$ 的DFA的最少状态数。该语言的性质仅取决于 $n_{a}(w) \\bmod 3$，因此我们考虑模3的同余类。\n\n下界（Myhill-Nerode可区分性）：\n对于 $i \\in \\{0,1,2\\}$，定义集合\n$$\nC_{i} = \\{ w \\in \\{a,b\\}^{*} \\mid n_{a}(w) \\equiv i \\pmod{3} \\}.\n$$\n我们证明 $C_{0}, C_{1}, C_{2}$ 关于语言 $L$ 是两两可区分的。令 $u \\in C_{i}$ 且 $v \\in C_{j}$，其中 $i \\neq j$。选择一个区分性扩展串 $t = a^{k}$，其中 $k \\equiv 1 - i \\pmod{3}$。那么\n$$\nn_{a}(ut) \\equiv n_{a}(u) + n_{a}(t) \\equiv i + k \\equiv i + (1 - i) \\equiv 1 \\pmod{3},\n$$\n所以 $ut \\in L$。另一方面，\n$$\nn_{a}(vt) \\equiv n_{a}(v) + n_{a}(t) \\equiv j + k \\equiv j + (1 - i) \\equiv 1 + (j - i) \\pmod{3}.\n$$\n因为 $j - i \\not\\equiv 0 \\pmod{3}$，我们有 $n_{a}(vt) \\not\\equiv 1 \\pmod{3}$，所以 $vt \\notin L$。因此 $C_{i}$ 和 $C_{j}$ 是可区分的。因此，根据Myhill-Nerode定理，任何用于识别 $L$ 的DFA都至少需要3个状态。\n\n上界（构造一个3状态的DFA）：\n定义一个DFA，其状态集为 $Q = \\{q_{0}, q_{1}, q_{2}\\}$，起始状态为 $q_{0}$，接受状态集为 $\\{q_{1}\\}$，转移函数为\n$$\n\\delta(q_{r}, a) = q_{(r+1) \\bmod 3}, \\quad \\delta(q_{r}, b) = q_{r}.\n$$\n通过对输入串的长度进行归纳，可以证明在读取任意字符串 $w$ 后，该自动机处于状态 $q_{n_{a}(w) \\bmod 3}$。因此，它仅在 $n_{a}(w) \\equiv 1 \\pmod{3}$ 时接受输入串，所以它能识别语言 $L$。\n\n结合3个状态的下界和一个3状态DFA的存在性，我们得出所需的最少状态数是3。", "answer": "$$\\boxed{3}$$", "id": "1362816"}, {"introduction": "复杂的问题通常可以通过分解为更小、更易于管理的部分来简化。在自动机理论中，乘积构造（product construction）提供了一种系统化的方法，用以组合两个DFA来识别其语言的交集。本练习将引导你分析一个通过这种方式构建的机器，让你深入了解如何将简单的自动机组合起来解决更复杂的识别任务 [@problem_id:1362787]。", "problem": "考虑两个定义在字母表 $\\Sigma = \\{a, b\\}$ 上的确定性有限自动机 (DFA)，$M_1$ 和 $M_2$。\n\n第一个自动机 $M_1 = (Q_1, \\Sigma, \\delta_1, q_S, F_1)$ 定义如下：\n-   状态集合为 $Q_1 = \\{q_S, q_A, q_B\\}$。\n-   开始状态为 $q_S$。\n-   接受（最终）状态集合为 $F_1 = \\{q_A, q_B\\}$。注意，开始状态是唯一一个非接受状态。\n-   转移函数 $\\delta_1: Q_1 \\times \\Sigma \\to Q_1$ 由以下规则给出：\n    -   $\\delta_1(q_S, a) = q_A$\n    -   $\\delta_1(q_S, b) = q_B$\n    -   $\\delta_1(q_A, a) = q_A$\n    -   $\\delta_1(q_A, b) = q_B$\n    -   $\\delta_1(q_B, a) = q_A$\n    -   $\\delta_1(q_B, b) = q_B$\n\n第二个自动机 $M_2 = (Q_2, \\Sigma, \\delta_2, p_0, F_2)$ 定义如下：\n-   状态集合为 $Q_2 = \\{p_0, p_1\\}$。\n-   开始状态为 $p_0$。\n-   接受（最终）状态集合为 $F_2 = \\{p_1\\}$。\n-   转移函数 $\\delta_2: Q_2 \\times \\Sigma \\to Q_2$ 由以下规则给出：\n    -   $\\delta_2(p_0, a) = p_1$\n    -   $\\delta_2(p_0, b) = p_0$\n    -   $\\delta_2(p_1, a) = p_1$\n    -   $\\delta_2(p_1, b) = p_0$\n\n一个新的自动机 $M_3 = (Q_3, \\Sigma, \\delta_3, q_{start}, F_3)$ 由 $M_1$ 和 $M_2$ 构造而成，其组成部分如下：\n-   状态集：$Q_3 = Q_1 \\times Q_2$（状态集的笛卡尔积）。\n-   开始状态：$q_{start} = (q_S, p_0)$。\n-   接受状态集：$F_3 = F_1 \\times F_2$。\n-   转移函数：对于任何状态 $(q, p) \\in Q_3$ 和任何符号 $\\sigma \\in \\Sigma$，$\\delta_3((q, p), \\sigma) = (\\delta_1(q, \\sigma), \\delta_2(p, \\sigma))$。\n\n下列哪个陈述准确地描述了机器 $M_3$ 所接受的语言 $L(M_3)$？\n\nA. 字母表 $\\{a, b\\}$ 上所有非空字符串的语言。\n\nB. 字母表 $\\{a, b\\}$ 上所有以符号 'a' 结尾的字符串的语言。\n\nC. 字母表 $\\{a, b\\}$ 上所有至少包含一个 'a' 的字符串的语言。\n\nD. 字母表 $\\{a, b\\}$ 上所有以 'a' 开始并以 'a' 结尾的字符串的语言。\n\nE. 空语言。", "solution": "我们分析每个 DFA 和乘积构造。\n\n对于 $M_1$，从转移函数中观察到，一旦从 $q_S$ 读取第一个输入符号，机器在符号 $a$ 上移动到 $q_A$，或在符号 $b$ 上移动到 $q_B$，而 $q_A$ 和 $q_B$ 都是接受状态。对于任何后续符号，$\\delta_1$ 保持了状态指示最后读取的符号这一属性：$\\delta_{1}(q_{A},a)=q_{A}$，$\\delta_{1}(q_{A},b)=q_{B}$，$\\delta_{1}(q_{B},a)=q_{A}$，以及 $\\delta_{1}(q_{B},b)=q_{B}$。因此，对于任何非空字符串 $w \\in \\{a,b\\}^{+}$，在处理完 $w$ 后，状态位于 $F_1$ 中，而对于空字符串 $\\epsilon$，机器保持在 $q_{S} \\notin F_{1}$。因此，\n$$\nL(M_{1})=\\{a,b\\}^{+}.\n$$\n\n对于 $M_2$，从 $p_0$ 开始，输入 $a$ 的转移到 $p_1$，输入 $b$ 的转移则停留在 $p_0$；从 $p_1$ 开始，输入 $a$ 的转移停留在 $p_1$，输入 $b$ 的转移则回到 $p_0$。通过对输入字符串的长度进行归纳，处理完任何字符串 $w \\in \\{a,b\\}^{\\ast}$ 后，当且仅当 $w$ 的最后一个符号是 $a$ 时，自动机处于 $p_1$ 状态，否则（包括 $w=\\epsilon$ 的情况）处于 $p_0$ 状态。由于 $F_2 = \\{p_1\\}$，我们有\n$$\nL(M_2) = \\{w \\in \\{a,b\\}^\\ast \\mid w \\text{ 的最后一个符号是 } a\\}\n$$\n\n对于乘积 DFA $M_3$，其构造为 $Q_3=Q_1 \\times Q_2$，开始状态为 $q_{start}=(q_S, p_0)$，转移函数为 $\\delta_3((q,p),\\sigma)=(\\delta_1(q,\\sigma), \\delta_2(p,\\sigma))$，接受状态集为 $F_3=F_1 \\times F_2$。对于任何输入 $w \\in \\{a,b\\}^{\\ast}$，根据乘积构造的定义，$M_3$ 接受 $w$ 当且仅当 $M_1$ 接受 $w$ 并且 $M_2$ 接受 $w$，即：\n$$\nL(M_3) = L(M_1) \\cap L(M_2).\n$$\n代入 $L(M_1)$ 和 $L(M_2)$ 的特征，\n$$\nL(M_3) = \\{a,b\\}^+ \\cap \\{w \\in \\{a,b\\}^\\ast \\mid w \\text{ 的最后一个符号是 } a\\}.\n$$\n由于每个最后一个符号是 $a$ 的字符串必然是非空的，所以交集可以简化为\n$$\nL(M_3) = \\{w \\in \\{a,b\\}^\\ast \\mid w \\text{ 的最后一个符号是 } a\\}.\n$$\n这与选项 B 相符：字母表 $\\{a,b\\}$ 上所有以符号 $a$ 结尾的字符串的语言。", "answer": "$$\\boxed{B}$$", "id": "1362787"}]}