{"hands_on_practices": [{"introduction": "在软件开发和语言设计中，我们常常希望能够自动分析代码或语法的有效性。一个基本问题是：一个给定的语法规则集合（上下文无关文法）是否能够生成任何有效的字符串？这个问题，即“空性问题”，虽然看似可能需要检查无限种可能性，但实际上是可判定的，本练习将引导你理解其判定算法的核心思想。[@problem_id:1361679]", "problem": "一个计算机科学家团队正在设计一种名为“Aether”的新编程语言。为了帮助开发者编写更好的代码，他们希望构建一个能够检测“不可达代码”的静态分析工具。在 Aether 的形式化规范中，该语言的语法由上下文无关文法（CFG）定义。一个 CFG 被形式化地定义为一个四元组 $G = (V, T, P, S)$，其中：\n- $V$ 是一个非终结符号（变量）的有限集合。\n- $T$ 是一个终结符号（语言的字母表）的有限集合，与 $V$ 不相交。\n- $P$ 是一个产生式规则的有限集合，其中每条规则的形式为 $A \\to \\alpha$，其中 $A \\in V$，$\\alpha$ 是由 $(V \\cup T)^*$ 中的符号组成的字符串。\n- $S \\in V$ 是特殊的起始符号。\n\n由该文法生成的语言，记为 $L(G)$，是从起始符号 $S$ 推导出的所有终结符号串的集合。\n\n该静态分析工具的一个关键特性是确定 Aether 文法所定义的语言是否完全是“死的”——也就是说，是否不可能从起始符号生成任何有效的程序（任何终结符号串）。用形式化的术语来说，该工具需要对给定的文法 $G$ 判断 $L(G) = \\emptyset$ 是否成立。\n\n该团队需要知道，理论上是否可能创建一个算法，对于任何给定的 CFG $G$，该算法总能终止并正确回答 $L(G)$ 是否为空。\n\n以下哪个陈述正确地评估了该问题的可判定性？\n\nA. 是的，它是可判定的。可以构建一个算法，该算法系统地识别所有能够生成终结符号串的非终结符号，然后检查起始符号是否是其中之一。\n\nB. 不，它是不可判定的。这个问题在计算上等价于停机问题，因为如果文法生成一个无限语言，检查从起始符号出发的所有可能推导可能会导致无限循环。\n\nC. 不，它是不可判定的。为了确定语言是否非空，算法必须检查无限多个潜在的字符串，看是否有任何一个可以被生成，这是一项不可能完成的任务。\n\nD. 是的，它是可判定的，但前提是文法不包含任何递归规则（例如，形如 $A \\to \\alpha A \\beta$ 的规则）。如果存在递归，该问题就变得不可判定。", "solution": "该问题询问是否存在一个算法，可以判断由任意上下文无关文法（CFG）生成的语言 $L(G)$ 是否为空。这被称为上下文无关语言的空性问题。事实上，这个问题是可判定的。让我们描述一个解决该问题的算法。\n\n核心思想是识别文法中所有“能产的”（productive）非终结符号。一个非终结符号如果能推导出至少一个完全由终结符号组成的字符串，那么它就是能产的。如果起始符号 $S$ 是能产的，那么 $L(G)$ 不为空。否则，$L(G)$ 为空。\n\n该算法按以下步骤进行：\n\n1.  **初始化**：我们将维护一个我们已识别为能产的非终结符号的集合。我们称这个集合为 `ProductiveSymbols`。初始时，`ProductiveSymbols` 为空。\n\n2.  **基本情况**：我们对文法 $G = (V, T, P, S)$ 的所有产生式规则 $P$ 进行一次初始遍历。我们识别所有具有 $A \\to w$ 形式规则的非终结符号 $A$，其中 $w$ 是一个完全由来自 $T$ 的终结符号组成的字符串（包括空串 $\\epsilon$）。对于每个这样的规则，我们将非终结符号 $A$ 添加到我们的 `ProductiveSymbols` 集合中。\n\n3.  **迭代步骤**：我们重复遍历所有产生式规则的集合 $P$。在每次迭代中，对于每个规则 $B \\to \\alpha_1 \\alpha_2 ... \\alpha_k$，我们检查其右侧字符串中的每个符号 $\\alpha_i$ 是否要么是终结符号，要么是已经存在于我们 `ProductiveSymbols` 集合中的非终结符号。如果这个条件对于左侧为非终结符号 $B$ 的规则成立，并且 $B$ 尚未在 `ProductiveSymbols` 中，我们就将 $B$ 添加到 `ProductiveSymbols` 中。\n\n4.  **终止**：我们继续迭代步骤（第3步），直到对所有产生式规则的完整遍历不再向 `ProductiveSymbols` 添加任何新的非终结符号为止。这个过程保证会终止，因为非终结符号的集合 $V$ 是有限的，并且在每个修改集合的步骤中，我们至少添加一个非终结符号。`ProductiveSymbols` 的大小最多为 $|V|$。\n\n5.  **判定**：一旦算法终止，我们检查起始符号 $S$ 是否在 `ProductiveSymbols` 集合中。\n    *   如果 $S \\in \\text{ProductiveSymbols}$，这意味着 $S$ 可以推导出一个终结符号串，因此 $L(G)$ 不为空。\n    *   如果 $S \\notin \\text{ProductiveSymbols}$，这意味着 $S$ 没有任何方式可以推导出一个仅由终结符号组成的字符串，因此 $L(G)$ 为空。\n\n既然我们描述了一个对于任何 CFG 都能保证终止，并对 $L(G)$ 是否为空的问题提供正确“是”或“否”答案的算法，那么这个问题是可判定的。\n\n让我们分析给出的选项：\n*   **A**：此选项正确地指出问题是可判定的，并准确地总结了上述算法的逻辑。\n*   **B**：这是不正确的。虽然天真地检查推导过程可能导致无限循环，但这个问题不等价于停机问题。上述算法分析的是文法本身的结构，这是一个有限的对象，而不是模拟无限的推导过程。\n*   **C**：这是不正确的。该算法不涉及测试无限数量的字符串。它直接作用于文法的有限规则集。问题不是“这个字符串是否在语言中？”，而是“语言中是否*存在任何*字符串？”。\n*   **D**：这是不正确的。递归的存在不会使问题变得不可判定。所描述的算法能正确处理递归规则。对于像 $A \\to aA$ 这样的规则，如果 $A$ 有另一个规则，比如说 $A \\to b$，允许它终止，那么 $A$ 就会被标记为能产的。该算法正确地传播了这种“能产性”。\n\n因此，正确的陈述是 A。", "answer": "$$\\boxed{A}$$", "id": "1361679"}, {"introduction": "在理解了可判定和不可判定的基本概念后，一个自然的问题是这些性质在集合运算（如交、并、补）下如何表现。本练习探讨了一个有趣的情形：当一个可判定语言与一个不可判定语言相交时，结果是可判定的还是不可判定的？通过构建具体的例子，你将学会如何严谨地论证这类理论问题，而不是仅凭直觉得出结论。[@problem_id:1361666]", "problem": "在计算理论中，形式语言被定义为在特定字母表 $\\Sigma$ 上的字符串集合。我们关心的是可被计算模型识别的语言类别。\n\n如果存在一台图灵机，对于任意给定的输入字符串，它总能停机并明确回答该字符串是否属于语言 $L$，那么该语言 $L$ 就被称为 **（图灵）可判定的** (decidable)。一个不可判定的语言被称为 **不可判定的** (undecidable)。\n\n设 $L_D$ 是一个任意的可判定语言，$L_U$ 是一个任意的不可判定语言，两者都定义在同一个字母表 $\\Sigma$ 上。考虑它们的交集，定义为语言 $L_{int} = L_D \\cap L_U$。\n\n关于 $L_{int}$ 的可判定性，以下哪个陈述是正确的？\n\nA. $L_{int}$ 总是可判定的。\n\nB. $L_{int}$ 总是不可判定的。\n\nC. $L_{int}$ 的可判定性取决于 $L_D$ 和 $L_U$ 的具体选择；它既可能是可判定的，也可能是不可判定的。\n\nD. 一个可判定语言和一个不可判定语言的交集不是一个良定义的语言，因此其可判定性无法讨论。\n\nE. $L_{int}$ 是可判定的当且仅当 $L_D$ 是一个有限语言。", "solution": "题目要求我们确定一个可判定语言 $L_D$ 和一个不可判定语言 $L_U$ 的交集的可判定性。让我们通过构造例子来分析各种可能性。目标是确定结果是总是可判定的，总是不可判定的，还是两者都有可能。\n\n首先，我们考虑交集 $L_{int} = L_D \\cap L_U$ 是否可以是可判定的。\n为了证明这是可能的，我们需要找到至少一对可判定语言 $L_D$ 和不可判定语言 $L_U$，使得它们的交集是可判定的。\n\n让我们为 $L_D$ 选择一个非常简单的可判定语言。空语言 $L_D = \\emptyset$ 是可判定的。一个判定它的图灵机会立即拒绝每个输入字符串，并且总是停机。因此，$L_D = \\emptyset$ 是可判定的。\n\n现在，让 $L_U$ 是任意一个不可判定语言。一个典型的例子是停机问题语言，通常表示为 $A_{TM}$。$A_{TM}$ 是所有对 $\\langle M, w \\rangle$ 的集合，其中 $M$ 是图灵机的编码，$w$ 是一个输入字符串，且 $M$ 在输入 $w$ 上停机。$A_{TM}$ 是不可判定的，这是可计算性理论中的一个基本结论。\n\n让我们计算这个特定选择的交集：\n$$L_{int} = L_D \\cap L_U = \\emptyset \\cap A_{TM} = \\emptyset$$\n结果语言是空语言 $\\emptyset$。如前所述，空语言是可判定的。因此，我们找到了一个可判定语言和不可判定语言的交集是可判定的实例。这证明了陈述 B “$L_{int}$ 总是不可判定的”是错误的。\n\n接下来，我们考虑交集 $L_{int} = L_D \\cap L_U$ 是否可以是不可判定的。\n为了证明这是可能的，我们需要找到至少一对可判定语言 $L_D$ 和不可判定语言 $L_U$，使得它们的交集是不可判定的。\n\n让我们为 $L_D$ 选择另一个简单的可判定语言。字母表 $\\Sigma$ 上所有可能字符串的语言，表示为 $\\Sigma^*$，是可判定的。一个判定它的图灵机会立即接受每个输入字符串，并且总是停机。因此，$L_D = \\Sigma^*$ 是可判定的。\n\n再次，让 $L_U$ 是不可判定语言 $A_{TM}$。\n\n让我们计算这个新选择的交集：\n$$L_{int} = L_D \\cap L_U = \\Sigma^* \\cap A_{TM}$$\n由于 $A_{TM}$ 是某个字母表 $\\Sigma$ 上的字符串集合，根据定义，它的所有元素都包含在 $\\Sigma^*$ 中。因此，$A_{TM}$ 与 $\\Sigma^*$ 的交集就是 $A_{TM}$ 本身。\n$$L_{int} = A_{TM}$$\n结果语言是 $A_{TM}$，我们知道它是不可判定的。因此，我们找到了一个可判定语言和不可判定语言的交集是不可判定的实例。这证明了陈述 A “$L_{int}$ 总是可判定的”是错误的。\n\n既然我们已经证明了一个交集是可判定的案例和另一个交集是不可判定的案例，那么交集的可判定性不是固定的。它取决于所选择的具体语言 $L_D$ 和 $L_U$。这直接支持了陈述 C。\n\n让我们快速回顾一下其他选项。\n- 陈述 D 是不正确的。两个集合（语言）的交集总是一个良定义的集合（语言）。\n- 陈述 E 是不正确的。在我们的第一个例子中，$L_D = \\emptyset$，是有限的，其交集是可判定的。在我们的第二个例子中，$L_D = \\Sigma^*$，是无限的，其交集是不可判定的。这可能暗示了一种模式。然而，考虑 $L_D = \\{ \\langle M, w \\rangle \\mid \\text{编码的符号数量为偶数} \\}$。这是一个无限的、可判定的语言。它与 $A_{TM}$ 的交集是 $A_{TM}^{\\text{even}} = \\{ \\langle M, w \\rangle \\in A_{TM} \\mid \\text{编码的符号数量为偶数} \\}$。可以证明这个语言是不可判定的（通过从 $A_{TM}$ 归约）。所以一个无限的 $L_D$ 可以导致一个不可判定的交集。但是如果我们取同一个无限的 $L_D$ 并将其与 $L_U = \\text{COMPLEMENT}(A_{TM})$ 求交集，其交集也可能是不可判定的。然而，如果我们取 $L_D$ 为所有不以图灵机编码开头的字符串集合，这是一个无限且可判定的集合，那么 $L_D \\cap A_{TM} = \\emptyset$，这是可判定的。因此，$L_D$ 是无限的并不能保证交集是不可判定的。所以，陈述 E 是错误的。\n\n唯一正确的结论是结果取决于具体的语言。", "answer": "$$\\boxed{C}$$", "id": "1361666"}, {"introduction": "几乎所有程序员的旅程都始于“Hello, world!”。一个看似实际的需求是：我们能否创建一个终极调试工具，它能分析任何程序并判断该程序是否会在其执行过程中打印出“Hello, world!”？这个练习将揭示为何这个“Hello, World!”问题是不可判定的，从而让你深刻体会到程序分析的根本性限制。[@problem_id:1361702]", "problem": "在计算理论中，我们使用图灵机（TM）作为任意计算机程序的形式化模型。一个语言是一个字符串的集合。我们感兴趣的是通过分析问题对应语言的可计算性属性来对问题的难度进行分类。图灵机 $M$ 的编码表示为一个字符串 $\\langle M \\rangle$。\n\n考虑以下语言，我们称之为“Hello World”语言，$L_{HW}$：\n$$ L_{HW} = \\{ \\langle M \\rangle \\mid M \\text{ 是一个图灵机，当在空白输入带上启动时，最终会打印 \"Hello, world!\"} \\} $$\n这意味着，对于一个要属于语言 $L_{HW}$ 的图灵机，必须存在一个有限的步数，在此之后其输出带上包含精确的字符串 \"Hello, world!\"。该机器在打印字符串后不要求停机。\n\n作为背景，回顾以下标准定义：\n*   一个语言是 **可判定的** (decidable)，如果存在一个图灵机，它在每个输入上都会停机，对于属于该语言的字符串，它接受；对于不属于该语言的字符串，它拒绝。\n*   一个语言是 **图灵可识别的** (Turing-recognizable)，如果存在一个图灵机，它接受所有属于该语言的字符串。对于不属于该语言的字符串，该机器可能拒绝或无限循环。\n*   一个语言是 **余-图灵可识别的** (co-Turing-recognizable)，如果它的补集是图灵可识别的。\n\n以下哪个陈述正确地对语言 $L_{HW}$ 进行了分类？\n\nA. $L_{HW}$ 是可判定的。\n\nB. $L_{HW}$ 是图灵可识别的，但不是可判定的。\n\nC. $L_{HW}$ 是余-图灵可识别的，但不是图灵可识别的。\n\nD. $L_{HW}$ 既不是图灵可识别的，也不是余-图灵可识别的。", "solution": "我们必须确定语言 $L_{HW}=\\{\\langle M\\rangle\\mid M\\text{ 是一个在空白输入上最终会打印 \"Hello, world!\" 的图灵机}\\}$ 是可判定的、图灵可识别的、余-图灵可识别的，还是都不是。\n\n首先，我们证明 $L_{HW}$ 是图灵可识别的。根据定义，一个语言是图灵可识别的，如果存在一个图灵机，它精确地接受该语言中的字符串，而对于不在此语言中的字符串可能会无限循环。构造一个识别器 $R$，它在输入 $x$ 上的行为如下：如果 $x$ 不是一个有效的图灵机编码，$R$ 可以立即拒绝（这不影响可识别性）。如果 $x=\\langle M\\rangle$ 是某个图灵机 $M$ 的编码，$R$就在一个空白输入带上逐步模拟 $M$。在每个模拟步骤之后，$R$ 扫描输出带上已写入的部分，并检查精确的有限字符串 \"Hello, world!\" 是否作为一个连续块出现（等价地，当时的输出带是否包含该字符串）。如果在某个有限的模拟时间内发生这种情况，$R$ 就接受。如果 $M$ 永远不产生那个字符串，那么 $R$ 就永远模拟下去并且永不接受。这个过程是有效的，因为在任何有限的时间点，带上已写入的部分是有限的，并且检查一个固定的有限模式是可判定的。因此，$L_{HW}$ 是图灵可识别的。\n\n其次，我们通过从标准的不可判定语言 $A_{TM}=\\{\\langle M,w\\rangle\\mid M\\text{ 接受 }w\\}$进行映射归约，来证明 $L_{HW}$ 是不可判定的。定义一个可计算函数 $f$，它在给定 $\\langle M,w\\rangle$ 时，输出一个图灵机 $N$ 的编码 $\\langle N\\rangle$，$N$ 在空白输入上的行为如下：$N$ 模拟 $M$ 在输入 $w$ 上的运行；如果模拟显示 $M$ 在 $w$ 上进入了接受状态，$N$ 就继续在其输出带上精确地写入字符串 \"Hello, world!\"（然后可以任意循环或停机）。如果 $M$ 拒绝 $w$ 或者在 $w$ 上不停机，那么 $N$ 永远不会产生字符串 \"Hello, world!\"。这样一个 $N$ 可以通过将 $M$ 和 $w$ 硬编码到 $N$ 的转移函数中来有效构造，所以 $f$ 是可计算的。根据构造，\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle N\\rangle=f(\\langle M,w\\rangle)\\in L_{HW}.\n$$\n因此 $A_{TM}\\leq_{m} L_{HW}$。因为 $A_{TM}$ 是不可判定的，所以 $L_{HW}$ 也是不可判定的。\n\n第三，我们证明 $L_{HW}$ 不是余-图灵可识别的。为了引出矛盾，假设 $L_{HW}$ 和它的补集 $\\overline{L_{HW}}$ 都是图灵可识别的。那么对于两者都会存在识别器，并且通过对任意输入交叉运行（dovetailing）这两个识别器，其中一个最终会接受，从而得出了一个 $L_{HW}$ 的判定器。这与 $L_{HW}$ 的不可判定性相矛盾。因此，$\\overline{L_{HW}}$ 不是图灵可识别的。\n\n综合这些结果，$L_{HW}$ 是图灵可识别的但不是可判定的，并且它的补集不是图灵可识别的。因此，正确的分类是选项 B。", "answer": "$$\\boxed{B}$$", "id": "1361702"}]}