{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式是动手实践。本节的第一个练习将引导你构建一个基础的摩尔机。我们将通过一个计算校验和的场景，来具体展示摩尔机中的“状态”如何作为一种记忆单元，记录处理过的信息并据此产生输出 [@problem_id:1386329]。", "problem": "数字通信系统中的一个组件被设计用于为输入的二进制数据流计算一个运行校验和。该组件被建模为一个摩尔机（Moore machine）。\n\n摩尔机是一种有限自动机，由一个六元组 $(Q, \\Sigma, \\Gamma, \\delta, \\lambda, q_{start})$ 正式定义，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是输入字母表。\n- $\\Gamma$ 是输出字母表。\n- $\\delta: Q \\times \\Sigma \\to Q$ 是转移函数，它根据当前状态和输入符号确定下一个状态。\n- $\\lambda: Q \\to \\Gamma$ 是输出函数，其中输出仅取决于当前状态。\n- $q_{start} \\in Q$ 是起始状态。\n\n对于这个问题，该机器从左到右处理一个二进制数字输入串。在处理了任意数量的输入数字后，机器的输出被定义为到那时为止处理的所有数字的总和，模3计算。机器从一个对应于空输入串（总和为0）的状态开始。\n\n机器的输入字母表是 $\\Sigma = \\{0, 1\\}$，输出字母表是 $\\Gamma = \\{0, 1, 2\\}$。设机器的状态用 $S_0, S_1, S_2$ 表示，其中处于状态 $S_i$ 表示到目前为止处理的所有二进制数字的总和与 $i$ 模3同余。起始状态是 $S_0$。\n\n下列哪个选项正确地描述了该摩尔机的转移函数 $\\delta$ 的一部分？\n\nA. $\\delta(S_1, 1) = S_1$ 和 $\\delta(S_2, 1) = S_2$\n\nB. $\\delta(S_0, 1) = S_1$ 和 $\\delta(S_1, 1) = S_2$\n\nC. $\\delta(S_0, 0) = S_1$ 和 $\\delta(S_1, 0) = S_2$\n\nD. $\\delta(S_1, 1) = S_0$ 和 $\\delta(S_2, 0) = S_0$\n\nE. $\\delta(S_2, 1) = S_1$ 和 $\\delta(S_0, 1) = S_0$", "solution": "根据定义，处于状态 $S_{i}$ 意味着到目前为止处理的比特位总和与 $i$ 模 $3$ 同余。当读入一个新的输入比特 $a \\in \\{0,1\\}$ 时，新的总和模 $3$ 变为 $(i + a) \\pmod 3$。因此，转移函数必须满足\n$$\n\\delta(S_{i}, a) = S_{(i+a)\\pmod 3}.\n$$\n具体来说：\n- 对于 $a=0$，对所有 $i$ 都有 $\\delta(S_{i},0)=S_{i}$。\n- 对于 $a=1$，有 $\\delta(S_{0},1)=S_{1}$，$\\delta(S_{1},1)=S_{2}$，以及 $\\delta(S_{2},1)=S_{0}$。\n\n现在检查各个选项：\n- A 选项陈述 $\\delta(S_{1},1)=S_{1}$ 和 $\\delta(S_{2},1)=S_{2}$，这与 $\\delta(S_{1},1)=S_{2}$ 和 $\\delta(S_{2},1)=S_{0}$ 相矛盾，因此 A 是错误的。\n- B 选项陈述 $\\delta(S_{0},1)=S_{1}$ 和 $\\delta(S_{1},1)=S_{2}$，这与推导出的转移相匹配，因此 B 是正确的。\n- C 选项陈述 $\\delta(S_{0},0)=S_{1}$ 和 $\\delta(S_{1},0)=S_{2}$，但对于 $a=0$ 我们必须有自环，因此 C 是错误的。\n- D 选项陈述 $\\delta(S_{1},1)=S_{0}$ 和 $\\delta(S_{2},0)=S_{0}$，两者都与推导出的规则相矛盾，因此 D 是错误的。\n- E 选项陈述 $\\delta(S_{2},1)=S_{1}$ 和 $\\delta(S_{0},1)=S_{0}$，两者都与推导出的规则相矛盾，因此 E 是错误的。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1386329"}, {"introduction": "在掌握了基本的状态设计后，让我们来处理一个更具挑战性的任务：模式识别。这个练习要求我们设计一个摩尔机来检测输入序列是否遵循特定的“交替”模式 [@problem_id:1386354]。通过这个过程，你将学会如何定义状态来记忆输入的历史特征，并首次接触到“陷阱状态”这一重要概念，它在处理无效输入序列时非常有用。", "problem": "摩尔机是一种有限自动机，其输出仅由当前状态决定。它由一个六元组 $(Q, \\Sigma, \\Delta, \\delta, \\lambda, q_0)$ 形式化定义，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是输入字母表。\n- $\\Delta$ 是输出字母表。\n- $\\delta: Q \\times \\Sigma \\to Q$ 是转移函数。\n- $\\lambda: Q \\to \\Delta$ 是输出函数。\n- $q_0 \\in Q$ 是起始状态。\n\n对于一个输入字符串，该机器的输出是从起始状态 $q_0$ 的输出开始，所访问状态的输出序列。\n\n考虑一个设计用于验证数据流的摩尔机。该机器从字母表 $\\Sigma = \\{0, 1\\}$ 中获取一个二进制输入字符串，并从字母表 $\\Delta = \\{0, 1\\}$ 中产生一个二进制输出。如果到目前为止处理的输入字符串部分是“交替的”，则机器必须输出 $1$，否则输出 $0$。如果一个字符串的字符严格在 $0$ 和 $1$ 之间交替（例如 `0`, `1`, `01`, `10`, `010`），则该字符串被定义为“交替的”。空字符串也被认为是交替的。如果一个字符串包含连续相同的字符（例如 `00`, `11`, `100`），则它不是交替的。\n\n以下哪个选项正确定义了这样一台机器的状态 $Q$、起始状态 $q_0$、输出函数 $\\lambda$ 和转移函数 $\\delta$？\n\nA. $Q = \\{S_0, S_1, S_2\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=1, \\lambda(S_1)=1, \\lambda(S_2)=0$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_1$ | $S_1$ |\n| $S_1$ | $S_2$ | $S_2$ |\n| $S_2$ | $S_2$ | $S_2$ |\n\nB. $Q = \\{S_0, S_A, S_B, S_F\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=1, \\lambda(S_A)=1, \\lambda(S_B)=1, \\lambda(S_F)=0$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_F$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_F$ |\n| $S_F$ | $S_F$ | $S_F$ |\n\nC. $Q = \\{S_0, S_A, S_B, S_F\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=0, \\lambda(S_A)=1, \\lambda(S_B)=1, \\lambda(S_F)=0$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_F$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_F$ |\n| $S_F$ | $S_F$ | $S_F$ |\n\nD. $Q = \\{S_0, S_A, S_B\\}$, $q_0 = S_0$。\n   输出函数为 $\\lambda(S_0)=1, \\lambda(S_A)=1, \\lambda(S_B)=1$。\n   转移函数 $\\delta$ 为：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_0$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_0$ |", "solution": "要解决这个问题，我们需要确定需要哪些状态来记住到目前为止所见输入字符串的必要信息。机器的输出取决于字符串是否严格交替。\n\n让我们分析一个状态必须捕获的属性：\n1.  初始状态，代表空字符串。问题陈述中说明空字符串是交替的，所以这个状态的输出必须是 $1$。\n2.  字符串是交替的，并且最后一个字符是 $0$。机器需要记住这一点，以检查下一个字符是否是 $1$。这个状态的输出必须是 $1$。\n3.  字符串是交替的，并且最后一个字符是 $1$。机器需要记住这一点，以检查下一个字符是否是 $0$。这个状态的输出必须是 $1$。\n4.  交替模式已被破坏（例如，出现了 `00` 或 `11`）。一旦模式被破坏，对于任何后续字符，它都保持破坏状态。这是一个“失败”或“陷阱”状态。这个状态的输出必须是 $0$。\n\n基于此分析，我们可以定义四个不同的状态：\n- $S_0$：初始状态。对应于空字符串。字符串是交替的。输出 $\\lambda(S_0) = 1$。\n- $S_A$：处理以 $0$ 结尾的有效交替字符串后达到的状态。字符串是交替的。输出 $\\lambda(S_A) = 1$。\n- $S_B$：处理以 $1$ 结尾的有效交替字符串后达到的状态。字符串是交替的。输出 $\\lambda(S_B) = 1$。\n- $S_F$：失败状态。当交替模式被破坏时达到。字符串不是交替的。输出 $\\lambda(S_F) = 0$。\n\n现在，让我们为每个状态 $q$ 和输入 $i$ 定义转移函数 $\\delta(q, i)$：\n\n- **从状态 $S_0$（起始状态）开始：**\n  - 如果输入是 $0$，新字符串是 `0`，它是交替的并以 $0$ 结尾。我们转移到 $S_A$。所以，$\\delta(S_0, 0) = S_A$。\n  - 如果输入是 $1$，新字符串是 `1`，它是交替的并以 $1$ 结尾。我们转移到 $S_B$。所以，$\\delta(S_0, 1) = S_B$。\n\n- **从状态 $S_A$（交替，以 $0$ 结尾）开始：**\n  - 如果输入是 $0$，字符串现在以 `00` 结尾。模式被破坏。我们转移到失败状态 $S_F$。所以，$\\delta(S_A, 0) = S_F$。\n  - 如果输入是 $1$，字符串现在以 `01` 结尾。模式得以维持，字符串现在以 $1$ 结尾。我们转移到 $S_B$。所以，$\\delta(S_A, 1) = S_B$。\n\n- **从状态 $S_B$（交替，以 $1$ 结尾）开始：**\n  - 如果输入是 $0$，字符串现在以 `10` 结尾。模式得以维持，字符串现在以 $0$ 结尾。我们转移到 $S_A$。所以，$\\delta(S_B, 0) = S_A$。\n  - 如果输入是 $1$，字符串现在以 `11` 结尾。模式被破坏。我们转移到失败状态 $S_F$。所以，$\\delta(S_B, 1) = S_F$。\n\n- **从状态 $S_F$（失败状态）开始：**\n  - 一旦模式被破坏，任何额外的输入都无法修复它。字符串将保持非交替状态。因此，无论输入如何，机器都应停留在失败状态。\n  - 所以，$\\delta(S_F, 0) = S_F$ 且 $\\delta(S_F, 1) = S_F$。\n\n让我们总结一下我们推导出的机器：\n- $Q = \\{S_0, S_A, S_B, S_F\\}$\n- $q_0 = S_0$\n- 输出函数：$\\lambda(S_0)=1, \\lambda(S_A)=1, \\lambda(S_B)=1, \\lambda(S_F)=0$。\n- 转移函数 $\\delta$：\n| 当前状态 | 输入 0 | 输入 1 |\n|---|---|---|\n| $S_0$ | $S_A$ | $S_B$ |\n| $S_A$ | $S_F$ | $S_B$ |\n| $S_B$ | $S_A$ | $S_F$ |\n| $S_F$ | $S_F$ | $S_F$ |\n\n现在我们将这个正确的设计与给定的选项进行比较。\n\n- **选项 A：**这台机器只有 3 个状态。它将“以 0 结尾”和“以 1 结尾”的状态合并为单个状态 $S_1$。从 $S_1$ 开始，任何输入都会导致失败状态 $S_2$。这是不正确的。例如，对于输入 `01`，路径是 $S_0 \\xrightarrow{0} S_1 \\xrightarrow{1} S_2$。字符串 `01` 的输出将是 0（来自状态 $S_2$），但 `01` 是交替的。所以，A 是不正确的。\n\n- **选项 B：**此选项在状态、起始状态、输出函数和转移函数方面与我们推导出的机器完全匹配。这是正确选项。\n\n- **选项 C：**这台机器有正确的状态结构和转移，但输出函数是 $\\lambda(S_0)=0$。这意味着空字符串不是交替的，这与问题陈述相矛盾。所以，C 是不正确的。\n\n- **选项 D：**这台机器有 3 个状态，没有永久的失败状态。如果接收到非交替输入（例如，在状态 $S_A$ 中输入 `0`），它会转换回起始状态 $S_0$。让我们用字符串 `001` 来测试一下。状态路径是 $S_0 \\xrightarrow{0} S_A \\xrightarrow{0} S_0 \\xrightarrow{1} S_B$。机器在读取输入后会经过状态 $S_A$、$S_0$ 和 $S_B$。字符串 `0`、`00` 和 `001` 的输出将是 $\\lambda(S_A)=1$、$\\lambda(S_0)=1$ 和 $\\lambda(S_B)=1$。`00` 的输出应该是 $0$，但在这里是 $1$。因此，这台机器不能正确识别非交替字符串。所以，D 是不正确的。\n\n因此，唯一正确的规范是选项 B。", "answer": "$$\\boxed{B}$$", "id": "1386354"}, {"introduction": "构建一个能够工作的机器是一回事，而构建一个最高效的机器则是工程师和科学家追求的目标。这个高级练习将挑战你思考状态的“必要性”，即确定完成特定任务所需的最少状态数 [@problem_id:1386336]。这个问题不仅是关于构造，更是关于通过证明来确保设计的简洁性和效率，它引入了状态可区分性的核心思想，这是有限自动机理论中的一个关键概念。", "problem": "摩尔机是一种有限自动机，其输出仅由当前状态决定。考虑一个摩尔机，它被设计用于处理来自字母表 $\\Sigma = \\{a, b\\}$ 的输入字符串。对于任何已处理的输入字符串 $w$，令 $n_a(w)$ 表示字符串中字符 'a' 的总数，$n_b(w)$ 表示字符 'b' 的总数。该机器必须被设计成：对于任何已处理的字符串 $w$，其所处状态的输出值等于 $(n_a(w) - n_b(w)) \\pmod k$。这里，$k$ 是一个给定的、大于 1 的正整数，取模运算的结果在集合 $\\{0, 1, \\dots, k-1\\}$ 中。该机器从对应于空字符串的起始状态开始。请确定该摩尔机所需的最小状态数，并表示为 $k$ 的函数。", "solution": "令 $\\Sigma=\\{a,b\\}$ 并定义目标输出函数 $f:\\Sigma^{*}\\to\\{0,1,\\dots,k-1\\}$ 为\n$$\nf(w)=(n_{a}(w)-n_{b}(w))\\pmod k,\n$$\n使得对于每个已处理的字符串 $w$，该摩尔机必须处于一个输出等于 $f(w)$ 的状态。\n\n上界（构造法）：构造一个具有以下组件的摩尔机 $M_{k}$。\n- 状态集 $Q=\\{q_{0},q_{1},\\dots,q_{k-1}\\}$，其中 $q_{r}$ 代表余数 $r\\in\\{0,1,\\dots,k-1\\}$。\n- 起始状态 $q_{0}$，与空字符串 $\\varepsilon$ 的 $f(\\varepsilon)=0$ 一致。\n- 输出函数 $g:Q\\to\\{0,1,\\dots,k-1\\}$，由 $g(q_{r})=r$ 给出。\n- 转移函数 $\\delta:Q\\times\\Sigma\\to Q$，由以下公式给出\n$$\n\\delta(q_{r},a)=q_{(r+1)\\pmod k},\\qquad \\delta(q_{r},b)=q_{(r-1)\\pmod k}.\n$$\n我们通过对 $w$ 的长度进行归纳来证明其正确性。对于 $|w|=0$，机器处于 $q_{0}$ 状态，输出 $g(q_{0})=0=f(\\varepsilon)$。假设从 $q_0$ 开始处理 $w$ 后，机器处于状态 $q_{f(w)}$。那么对于 $wa$，\n$$\n\\delta(q_{f(w)},a)=q_{(f(w)+1)\\pmod k},\\quad \\text{and}\\quad f(wa)=(n_{a}(w)+1-n_{b}(w))\\pmod k=(f(w)+1)\\pmod k,\n$$\n所以到达的状态是 $q_{f(wa)}$，其输出为 $f(wa)$。类似地，对于 $wb$，\n$$\n\\delta(q_{f(w)},b)=q_{(f(w)-1)\\pmod k},\\quad \\text{and}\\quad f(wb)=(n_{a}(w)-(n_{b}(w)+1))\\pmod k=(f(w)-1)\\pmod k,\n$$\n所以到达的状态是 $q_{f(wb)}$，其输出为 $f(wb)$。根据归纳法，处理任何 $w$ 后，机器都处于 $q_{f(w)}$ 状态并输出 $f(w)$。因此 $M_{k}$ 满足规范要求，并使用 $k$ 个状态，从而给出了一个 $k$ 的上界。\n\n下界（最小性）：假设存在一个实现 $f$ 的摩尔机，其状态数少于 $k$ 个。对于每个 $r\\in\\{0,1,\\dots,k-1\\}$，考虑 $w_{r}=a^{r}$，它满足\n$$\nf(w_{r})=(r-0)\\pmod k=r.\n$$\n令处理 $w_{r}$ 后达到的状态为 $s_{r}$。因为该机器是摩尔机，并且必须在状态 $s_{r}$ 输出 $f(w_{r})=r$，所以不同的余数会产生不同的输出：\n$$\nr\\neq s \\implies g(s_{r})\\neq g(s_{s}).\n$$\n在摩尔机中，输出不同的两个状态必然是不同的状态，因此只要 $r \\neq s$，就有 $s_{r}\\neq s_{s}$。因此，至少存在 $k$ 个不同的状态 $\\{s_{0},s_{1},\\dots,s_{k-1}\\}$，这与状态数少于 $k$ 个的假设相矛盾。因此，任何实现 $f$ 的摩尔机都必须至少有 $k$ 个状态。\n\n结合上界和下界，最小状态数恰好为 $k$。", "answer": "$$\\boxed{k}$$", "id": "1386336"}]}