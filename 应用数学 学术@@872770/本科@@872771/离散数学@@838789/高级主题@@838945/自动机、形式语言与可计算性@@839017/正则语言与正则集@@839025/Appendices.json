{"hands_on_practices": [{"introduction": "非确定性有限自动机 (NFA) 是识别字符串中模式的强大工具。由于其固有的灵活性，即非确定性，设计 NFA 通常比设计等价的确定性有限自动机 (DFA) 更直观、更容易。本练习将引导你为一种由特定子串定义的语言设计一个紧凑的 NFA [@problem_id:1396488]，让你亲身体验如何将语言描述转化为形式化的自动机模型。", "problem": "一位计算机科学家正在为一种简单的命令语言设计一个解析器。该语言的字母表定义为 $\\Sigma = \\{a, b, c\\}$。一个命令字符串被认为是有效的，当且仅当它包含子串 `ac` 或子串 `abc`。为了识别这些有效的命令，需要构建一个非确定性有限自动机（NFA）。\n\n接受这个有效命令语言的 NFA 所需的最少状态数（包括起始状态和任何最终状态）是多少？", "solution": "设语言为 $L$。如果一个字符串 $w$ 的形式为 $x \\cdot s \\cdot y$，其中 $x, y \\in \\Sigma^*$（由字母表 $\\Sigma$ 中的符号组成的任意字符串），并且 $s$ 是 `ac` 或 `abc`，那么 $w$ 就在语言 $L$ 中。我们想要找到一个接受语言 $L$ 的非确定性有限自动机（NFA）所需的最少状态数。\n\n两个所需的子串 `ac` 和 `abc` 共享一个公共前缀 `a`。我们可以利用这个重叠来设计一个高效的 NFA。让我们一步步构建这个 NFA。\n\n1.  **起始状态 ($q_0$)**: 这是初始状态。在我们遇到目标子串的任何部分之前，我们都处于这个状态。读取任何字符都不会让我们更接近最终状态，所以我们需要一个对于任何符号都循环回到此状态的转换。然而，符号 `a` 是特殊的，因为它是两个目标子串的开始。因此，在读到 `a` 时，NFA 必须非确定性地选择或者停留在 $q_0$（以处理 `a` 不是所需子串开头的情况，例如在像 `baac` 这样的字符串中），或者转移到一个新状态，该状态表示一个潜在匹配的开始。\n    - 设 $q_0$ 为起始状态。\n    - $q_0$ 的转换：$\\delta(q_0, a) = \\{q_0, q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_0, c) = \\{q_0\\}$。\n\n2.  **看到 'a' 之后的状态 ($q_1$)**: 这个状态表示我们刚刚看到了一个 `a`，它可能是 `ac` 或 `abc` 的前缀。\n    - 从 $q_1$ 开始，如果下一个符号是 `c`，我们就成功找到了子串 `ac`。我们必须转换到一个最终（接受）状态。我们称这个最终状态为 $q_f$。因此，我们添加转换 $\\delta(q_1, c) = \\{q_f\\}$。\n    - 从 $q_1$ 开始，如果下一个符号是 `b`，我们可能正在形成子串 `abc`。我们需要转移到一个新状态来记住我们已经看到了 `ab`。我们称这个状态为 $q_2$。因此，我们添加转换 $\\delta(q_1, b) = \\{q_2\\}$。\n    - 如果下一个符号是 `a`，`ac` 和 `abc` 的序列都被破坏了。这个非确定性路径终止。自动机依赖于另一条路径（即在第一个 `a` 上停留在 $q_0$ 的路径）来稍后找到一个有效的子串。\n\n3.  **看到 'ab' 之后的状态 ($q_2$)**: 这个状态表示已经看到了前缀 `ab`。\n    - 从 $q_2$ 开始，如果下一个符号是 `c`，我们就找到了子串 `abc`。我们必须转换到最终状态 $q_f$。因此，我们添加转换 $\\delta(q_2, c) = \\{q_f\\}$。\n    - 对于任何其他符号（`a` 或 `b`），序列 `abc` 被破坏，这条路径终止。\n\n4.  **最终状态 ($q_f$)**: 这是一个接受状态。到达这个状态意味着我们已经找到了 `ac` 或 `abc`。因为该语言接受任何*包含*这些子串之一的字符串，所以子串之后出现的任何字符都不会改变字符串的有效性。因此，一旦进入最终状态，无论后续输入是什么，NFA 都应保持在该状态。这是一个常见的“陷阱”接受状态。\n    - $q_f$ 的转换：$\\delta(q_f, a) = \\{q_f\\}$，$\\delta(q_f, b) = \\{q_f\\}$，$\\delta(q_f, c) = \\{q_f\\}$。\n\n构建的 NFA 有四个状态：$\\{q_0, q_1, q_2, q_f\\}$，其中 $q_0$ 是起始状态，$q_f$ 是唯一的最终状态。\n\n现在，我们必须论证 4 是最少的状态数。我们可以通过证明所有四个状态都是必要的来做到这一点，因为它们代表了关于迄今为止处理的字符串的不同、可区分的信息。如果存在某个字符串，当从一个状态开始时，它能导向接受状态，但从另一个状态开始时则不能，那么这两个状态就是可区分的。\n\n-   **$q_f$ vs. 非最终状态 ($q_0, q_1, q_2$)**: $q_f$ 是一个最终状态，而其他状态不是。它们可以通过空字符串 $\\epsilon$ 来区分。\n\n-   **$q_0$ vs. $q_1$**: 从 $q_1$ 开始，输入字符串 `c` 会导向最终状态 $q_f$。从 $q_0$ 开始，输入字符串 `c` 会回到 $q_0$，对于这条路径来说这不是一个最终状态。因此，$q_0$ 和 $q_1$ 是可区分的。\n\n-   **$q_0$ vs. $q_2$**: 从 $q_2$ 开始，输入字符串 `c` 会导向 $q_f$。从 $q_0$ 开始，`c` 会导向 $q_0$。因此，$q_0$ 和 $q_2$ 是可区分的。\n\n-   **$q_1$ vs. $q_2$**: 这是关键的比较。从 $q_1$ 和 $q_2$ 开始，输入字符串 `c` 都会导向接受状态。然而，考虑输入字符串 `bc`。从 $q_1$ 开始，读取 `b` 会将我们带到状态 $q_2$，然后读取 `c` 会将我们带到状态 $q_f$（接受）。所以，从 $q_1$ 开始，字符串 `bc` 被接受。从 $q_2$ 开始，没有关于 `b` 的转换，所以路径终止，字符串 `bc` 不被接受。因此，$q_1$ 和 $q_2$ 是可区分的。\n\n由于所有四个状态（$q_0, q_1, q_2, q_f$）都是两两可区分的，没有两个状态可以合并。因此，最少需要 4 个状态。", "answer": "$$\\boxed{4}$$", "id": "1396488"}, {"introduction": "虽然 NFA 在概念设计上非常方便，但在实际的软件实现中，DFA 因其无歧义的执行路径而更受青睐。子集构造法是连接这两个模型的关键桥梁，它提供了一种系统性的算法，可以将任何 NFA 转换为一个功能完全等价的 DFA。通过这个练习 [@problem_id:1396478]，你将掌握这一核心转换技术，加深对 NFA 和 DFA 等价性的理解。", "problem": "考虑一个非确定性有限自动机（NFA），记作 $M$。它被设计用于接受所有倒数第二个字符是 '1' 的二进制字符串集合。该自动机的字母表是 $\\Sigma = \\{0, 1\\}$。\n\nNFA $M$ 由一个 5 元组 $(Q, \\Sigma, \\delta, q_0, F)$ 正式定义，其中：\n- 状态集合为 $Q = \\{q_0, q_1, q_2\\}$。\n- 字母表为 $\\Sigma = \\{0, 1\\}$。\n- 起始状态为 $q_0$。\n- 终止（接受）状态集合为 $F = \\{q_2\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，由下表给出：\n\n| 状态  | 输入 '0' | 输入 '1'   |\n|---------|-----------|-------------|\n| $q_0$   | $\\{q_0\\}$ | $\\{q_0, q_1\\}$|\n| $q_1$   | $\\{q_2\\}$ | $\\{q_2\\}$   |\n| $q_2$   | $\\emptyset$ | $\\emptyset$   |\n\n你的任务是使用标准的子集构造算法将这个 NFA 转换为一个等价的确定性有限自动机（DFA）。在你的构造中，只应包含从 DFA 的起始状态可达的状态。\n\n完成转换后，确定最终得到的 DFA 中的状态总数。", "solution": "我们应用子集构造法将给定的 NFA $M=(Q,\\Sigma,\\delta,q_{0},F)$ 转换为一个 DFA $M'=(Q',\\Sigma,\\delta',S_{0},F')$，其中：\n- $Q' \\subseteq \\mathcal{P}(Q)$ 由从 $S_{0}$ 可达的 $Q$ 的所有子集组成，\n- $S_{0}=\\{q_{0}\\}$（没有 $\\epsilon$-转移，所以 $q_{0}$ 的 $\\epsilon$-闭包是 $\\{q_{0}\\}$），\n- 对于 $S\\subseteq Q$ 和 $a\\in\\Sigma$，$\\delta'(S,a)=\\bigcup_{q\\in S}\\delta(q,a)$，\n- $F'=\\{S\\subseteq Q: S\\cap F\\neq\\emptyset\\}$。\n\n从 $S_{0}=\\{q_{0}\\}$ 开始计算可达子集。使用给定的 NFA 转移函数 $\\delta(q_{0},0)=\\{q_{0}\\}$, $\\delta(q_{0},1)=\\{q_{0},q_{1}\\}$, $\\delta(q_{1},0)=\\{q_{2}\\}$, $\\delta(q_{1},1)=\\{q_{2}\\}$, $\\delta(q_{2},0)=\\emptyset$, $\\delta(q_{2},1)=\\emptyset$：\n\n1. 从 $\\{q_{0}\\}$ 出发：\n$$\n\\delta'(\\{q_{0}\\},0)=\\delta(q_{0},0)=\\{q_{0}\\},\\quad\n\\delta'(\\{q_{0}\\},1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}.\n$$\n目前可达的状态：$\\{q_{0}\\}$, $\\{q_{0},q_{1}\\}$。\n\n2. 从 $\\{q_{0},q_{1}\\}$ 出发：\n$$\n\\delta'(\\{q_{0},q_{1}\\},0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}=\\{q_{0},q_{2}\\},\n$$\n$$\n\\delta'(\\{q_{0},q_{1}\\},1)=\\delta(q_{0},1)\\cup\\delta(q_{1},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{2}\\}=\\{q_{0},q_{1},q_{2}\\}.\n$$\n新的可达子集：$\\{q_{0},q_{2}\\}$, $\\{q_{0},q_{1},q_{2}\\}$。\n\n3. 从 $\\{q_{0},q_{2}\\}$ 出发：\n$$\n\\delta'(\\{q_{0},q_{2}\\},0)=\\delta(q_{0},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\emptyset=\\{q_{0}\\},\n$$\n$$\n\\delta'(\\{q_{0},q_{2}\\},1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\emptyset=\\{q_{0},q_{1}\\}.\n$$\n没有新的子集。\n\n4. 从 $\\{q_{0},q_{1},q_{2}\\}$ 出发：\n$$\n\\delta'(\\{q_{0},q_{1},q_{2}\\},0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\},\n$$\n$$\n\\delta'(\\{q_{0},q_{1},q_{2}\\},1)=\\delta(q_{0},1)\\cup\\delta(q_{1},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{1},q_{2}\\}.\n$$\n没有新的子集。\n\n因此，可达的 DFA 状态恰好是 $\\{q_{0}\\}$, $\\{q_{0},q_{1}\\}$, $\\{q_{0},q_{2}\\}$ 和 $\\{q_{0},q_{1},q_{2}\\}$。空集和任何不包含 $q_{0}$ 的子集都是不可达的，因为对于每个 $a\\in\\Sigma$，$\\delta(q_{0},a)$ 都包含 $q_{0}$，这阻止了向不含 $q_{0}$ 的子集或空集 $\\emptyset$ 的转移。因此，最终得到的 DFA 中（只计算可达状态）的状态总数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "1396478"}, {"introduction": "当我们用一个 DFA 来定义一个“安全”或“有效”的语言后，这个自动机的结构本身就成了一个可以用来解决实际问题的分析工具。这个练习展示了一个极具实践价值的应用：将 DFA 视为一个状态图，并利用图搜索算法来寻找导致错误（非接受）状态的最短输入序列 [@problem_id:1396479]。这项技能在软件测试和系统验证等领域至关重要。", "problem": "一家机器人公司正在开发一款新型先进制造臂。该机械臂的控制器接受来自一个预定义命令集的操作序列。为确保安全，只允许特定的操作序列。这些“安全”序列构成一个正则语言 $L_{safe}$。一位工程师构建了一个确定性有限自动机（DFA），记为 $M$，该自动机恰好能识别语言 $L_{safe}$。\n\nDFA $M$ 由一个五元组 $(Q, \\Sigma, \\delta, q_S, F)$ 定义，其中：\n- 状态集合为 $Q = \\{S, A, B, C, D, E\\}$。\n- 输入字母表为 $\\Sigma = \\{a, b\\}$，代表两种不同的基本操作。\n- 起始状态为 $q_S = S$。\n- 接受（最终）状态集合为 $F = \\{S, A, B, C, D\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to Q$ 由下表给出：\n| 当前状态 | 输入 'a' | 输入 'b' |\n|---------------|-----------|-----------|\n| S             | A         | B         |\n| A             | S         | C         |\n| B             | D         | S         |\n| C             | D         | E         |\n| D             | A         | C         |\n| E             | E         | E         |\n\n为了进行全面的系统测试，工程团队需要找到可能的最短“不安全”操作序列。一个不安全序列是指任何不在 $L_{safe}$ 中的操作序列。\n\n最短不安全操作序列的长度是多少？", "solution": "一个不安全序列是被该DFA拒绝的任何输入词，即一个在消耗完整个输入后，将起始状态 $S$ 转移到一个非接受状态的词。由于唯一的非接受状态是 $E$，且 $E$ 是一个吸收态，满足 $\\delta(E,a)=E$ 和 $\\delta(E,b)=E$，因此最短的不安全词必须是满足扩展转移 $\\hat{\\delta}(S,w)=E$ 的最短的词 $w$。\n\n从给定的转移函数可知，到达 $E$ 的唯一转移是 $\\delta(C,b)=E$。因此，任何到达 $E$ 的词都必须具有 $w=ub$ 的形式，其中 $\\hat{\\delta}(S,u)=C$。因此，不安全词的最小长度是从 $S$ 到达 $C$ 所需的最小长度加 $1$。\n\n我们通过广度优先探索来找到满足 $\\hat{\\delta}(S,u)=C$ 的最短的 $u$：\n- 长度为 $0$：$S$ (不是 $C$)。\n- 长度为 $1$：$\\delta(S,a)=A$, $\\delta(S,b)=B$ (都不是 $C$)。\n- 长度为 $2$：枚举从 $S$ 出发的长度为 $2$ 的词：\n  - $aa$: $S \\xrightarrow{a} A \\xrightarrow{a} S$,\n  - $ab$: $S \\xrightarrow{a} A \\xrightarrow{b} C$,\n  - $ba$: $S \\xrightarrow{b} B \\xrightarrow{a} D$,\n  - $bb$: $S \\xrightarrow{b} B \\xrightarrow{b} S$.\n因此，首次在长度为 $2$ 时通过 $ab$ 到达 $C$。因此，到达 $E$ 的最短的词是 $ub$（其中 $u=ab$），即 $abb$，其长度为 $2+1=3$。\n\n因此，最短不安全序列的长度是 $3$。", "answer": "$$\\boxed{3}$$", "id": "1396479"}]}