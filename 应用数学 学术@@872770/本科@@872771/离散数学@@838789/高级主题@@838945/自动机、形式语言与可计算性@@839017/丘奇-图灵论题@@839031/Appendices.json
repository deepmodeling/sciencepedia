{"hands_on_practices": [{"introduction": "丘奇-图灵论题的核心在于，图灵机是“算法”这一直观概念的精确形式化。为了理解这一论题的重要性，我们通常会将图灵机与其他更简单的计算模型进行比较。此练习将探讨有限状态自动机（FSA）的局限性，通过分析一个看似简单的语言识别任务，揭示为何有限的内存使其无法胜任，从而凸显图灵机无限存储带的强大能力。", "problem": "在丘奇-图灵论题的背景下，该论题假定图灵机（TM）可以计算任何具有算法的函数，我们通常将图灵机与更简单的计算模型进行比较，以理解计算能力的层级。\n\n一名初级软件工程师接到了一个数据验证任务。任务是为字母表 $\\Sigma = \\{0, 1\\}$ 上的语言 $L$ 构建一个识别器。该语言定义为 $L = \\{0^k 1^k \\mid k \\ge 1\\}$，由一个或多个 '0' 后跟等数量的 '1' 组成的字符串构成。例如，'01'、'0011' 和 '000111' 属于 $L$，而 '011'、'001' 和 '10' 则不属于。\n\n该工程师首先尝试使用有限状态自动机（FSA），也称为有限自动机，来实现这个识别器。经过几次尝试，他们得出结论：无法为这个任务构建任何FSA。下列哪个陈述提供了FSA无法识别语言 $L$ 的最根本原因，从而说明了为什么它是一个比图灵机计算能力更弱的模型？\n\nA. FSA由有限的状态集定义。为了识别 $L$，机器必须记住它已处理的 '0' 的确切数量，这个数量可以是任意大的。FSA的有限状态只提供了有限的内存，这对于这种无界计数任务是不够的。相比之下，TM可以将其无限长的纸带用作无界内存。\n\nB. 语言 $L$ 本质上是非确定性的，因为 $k$ 的值是事先未知的。标准的确定性FSA无法处理这一点，虽然非确定性有限自动机（NFA）更强大，但只有TM才足够强大以解决 $L$ 所需的无界非确定性。\n\nC. FSA的主要局限性在于其读头只能在输入上单向移动。TM之所以能成功，是因为其读写头是双向的，允许它在 '0' 块和 '1' 块之间来回移动，以确认它们的数量相等。\n\nD. TM可以识别 $L$ 是因为它能解决针对此特定语言的停机问题，而FSA不能。FSA的主要失败点在于它无法确定在读取 '0' 之后是否应该停机。\n\nE. FSA失败是因为它不能写入或修改其输入。TM可以解决这个问题，因为它具有写入能力，允许它在将每个 '0' 与对应的 '1' 匹配时进行标记，从而跟踪计数。", "solution": "我们通过证明语言 $L=\\{0^{k}1^{k}\\mid k\\ge 1\\}$ 不是正则语言来形式化地说明有限状态自动机（FSA）的局限性，这意味着没有FSA可以识别它。我们将使用鸽巢原理进行反证。\n假设存在一个能够识别 $L$ 的FSA，设其状态数为 $n$。考虑字符串 $s = 0^n 1^n$。根据定义，$s \\in L$，所以这个FSA必须接受它。\n当FSA读取字符串 $s$ 的前 $n$ 个 '0' 时，它会经过 $n+1$ 个状态（包括初始状态）。由于只有 $n$ 个不同的状态，根据鸽巢原理，在读取这些 '0' 的过程中，至少有一个状态被访问了两次。也就是说，存在索引 $i$ 和 $j$（其中 $0 \\le i  j \\le n$），使得FSA在读取了 $i$ 个 '0' 后和在读取了 $j$ 个 '0' 后处于同一个状态，我们称之为 $q_p$。\n这意味着子串 $0^{j-i}$（即第 $i+1$ 到第 $j$ 个 '0'）将机器从状态 $q_p$ 带回了状态 $q_p$。\n现在，我们构造一个新的字符串 $s' = 0^{n-(j-i)}1^n$。这个字符串是通过从 $s$ 中“泵出”（删除）子串 $0^{j-i}$ 得到的。\n当我们的FSA处理 $s'$ 时，它读取前 $i$ 个 '0' 并到达状态 $q_p$。然后，它继续读取剩下的 $n-j$ 个 '0'。由于机器在读取 $s$ 的第 $j$ 个 '0' 后也处于状态 $q_p$，因此在处理完 $s'$ 的所有 '0' 后，机器所处的状态与处理完 $s$ 的所有 '0' 后所处的状态是相同的。\n接下来，机器读取 $1^n$。由于它从相同的状态开始处理这部分输入，并且 $s$ 被接受，因此 $s'$ 也必须被接受。\n然而，字符串 $s'$ 中的 '0' 的数量是 $n-(j-i)$，而 '1' 的数量是 $n$。因为 $j > i$，所以 $j-i > 0$，所以 '0' 和 '1' 的数量不相等。因此，$s' \\notin L$。\n我们的FSA接受了一个不属于语言 $L$ 的字符串，这是一个矛盾。因此，我们最初的假设（存在能够识别 $L$ 的FSA）是错误的。", "answer": "$$\\boxed{A}$$", "id": "1405449"}, {"introduction": "丘奇-图灵论题的一个强有力证据是图灵机模型的“稳健性”——许多看似更强大的计算模型，最终都被证明与标准图灵机等价。本练习将引导你思考一个有趣的假设：如果一台图灵机可以修改自己的程序（转移函数），它会变得更强大吗？通过构建一个思想实验，你将发现，标准图灵机可以模拟这种“自修改”行为，这恰好印证了通用计算中“程序即数据”的核心思想。", "problem": "一位未来计算公司的工程师提出了一种新的理论计算模型，称为自修改图灵机（Self-Modifying Turing Machine, SMTM）。SMTM与标准图灵机（Turing Machine, TM）类似，但增加了一项能力：它可以在执行过程中改变自身的转移函数。\n\n具体来说，一台 SMTM $M_{SM}$ 由一个状态集 $Q$、一个输入字母表 $\\Sigma$ 和一个带字母表 $\\Gamma$ 定义。它的单条无限带在概念上分为两个区域：数据区和程序区。程序区包含了机器自身转移函数 $\\delta$ 的完整编码。SMTM 的一次转移由其当前状态和从数据区读取的符号决定，其形式如下：\n$$ \\delta(q, \\gamma) = (q', \\gamma', D, A) $$\n其中 $q, q' \\in Q$ 是当前状态和下一状态，$\\gamma, \\gamma' \\in \\Gamma$ 是从数据区读取和写入的符号，$D \\in \\{L, R\\}$ 是读写头在数据区上的移动方向，而 $A$ 是一个特殊的“修改动作”。动作 $A$ 可以是以下两种类型之一：\n1.  **`NO-OP`**：不修改程序区。转移函数保持不变。\n2.  **`MODIFY( (q_s, \\gamma_s), (q_t, \\gamma_t, D_t) )`**：机器在其程序区中找到状态-符号对 $(q_s, \\gamma_s)$ 的规则编码并将其覆盖。新规则变为转移到状态 $q_t$，写入符号 $\\gamma_t$，并向 $D_t$ 方向移动读写头。为简单起见，假设这个新定义的转移具有 `NO-OP` 修改动作。\n\n丘奇-图灵论题（Church-Turing thesis）断言，任何能由算法过程计算的函数都可以由标准图灵机计算。为了检验 SMTM 模型是否对该论题构成挑战，必须确定它是否能计算标准图灵机无法计算的函数。这通常通过展示一台标准的、具有固定程序的图灵机（我们称之为 $M_{standard}$）如何模拟任何给定 SMTM 的行为来完成。\n\n假设你的任务是描述这样一种模拟。机器 $M_{standard}$ 将使用它自己的带子来记录 SMTM 的整个格局（configuration），包括 SMTM 的数据区、程序区及其当前状态。\n\n下列哪项陈述最好地描述了允许具有固定转移函数的标准图灵机成功模拟自修改图灵机的核心原理？\n\nA. 每当 SMTM 修改其转移函数时，标准图灵机就停机并由操作员手动重新编程，从而有效地创建一系列不同的图灵机来反映 SMTM 的演变。\nB. 标准图灵机对 SMTM 未来的每个转移函数进行非确定性的“猜测”，如果至少有一条猜测的计算路径与 SMTM 的实际演变相匹配，则该计算被认为是成功的。\nC. 标准图灵机将 SMTM 的转移函数视为存储在其自身带子上的数据。当 SMTM 执行 `MODIFY` 动作时，标准图灵机执行标准的数据写入操作来更新其带子上的这个表示，然后再模拟下一步。\nD. 只有当 SMTM 的自修改次数被限制为有限的、预定的数量时，模拟才可能实现。一台能够在执行过程中进行无限次修改的 SMTM 无法由标准图灵机模拟。\nE. 模拟要求标准图灵机拥有一条特殊的“元带”，它与数据带物理分离，并且普通的读/写操作无法访问，专门用于存储 SMTM 的程序。", "solution": "我们将一台标准图灵机（记为 $M_{standard}$）对一台具有转移关系 $\\delta$ 的自修改图灵机 $M_{SM}$ 的模拟过程形式化。关键的观察是，通用图灵机将对机器的描述解释为数据；因此，对 $M_{SM}$ 程序的任何更改都可以通过对 $M_{standard}$ 在其自身带子上维护的数据进行相应更改来反映。\n\n首先，我们将 $M_{SM}$ 在步骤 $t$ 的完整格局（configuration）定义为 $C_{t}=(q_{t},T^{data}_{t},T^{prog}_{t},h^{data}_{t})$，其中 $q_{t}\\in Q$ 是当前状态，$T^{data}_{t}$ 编码了数据区的内容，$T^{prog}_{t}$ 编码了 $M_{SM}$ 当前的转移表，而 $h^{data}_{t}$ 编码了数据区中的读写头位置。在每个模拟步骤 $t$ 中，机器 $M_{standard}$ 都在其自己的带子上维护 $C_{t}$ 的显式编码。\n\n为了模拟一次转移，$M_{standard}$ 执行以下确定性解释过程：\n1. 它读取编码的数据读写头下的符号 $\\gamma$ 和当前状态 $q_{t}$。\n2. 它在编码的 $T^{prog}_{t}$ 中搜索对应于 $(q_{t},\\gamma)$ 的规则，从而得到 $(q',\\gamma',D,A)=\\delta(q_{t},\\gamma)$。\n3. 它通过在编码的读写头位置写入 $\\gamma'$ 来更新编码的数据区，根据 $D$ 移动编码的读写头位置，并将编码的状态设置为 $q'$。\n\n至关重要的是，对修改动作 $A$ 的处理是通过在 $M_{standard}$ 的带子上进行普通的数据操作来实现的：\n- 如果 $A$ 是 NO-OP，则 $T^{prog}_{t+1}=T^{prog}_{t}$，$M_{standard}$ 使用更新后的格局编码继续进行下一个模拟步骤。\n- 如果 $A$ 是 $\\operatorname{MODIFY}\\big((q_{s},\\gamma_{s}),(q_{targ},\\gamma_{targ},D_{targ})\\big)$，则 $M_{standard}$ 在其带子上对 $T^{prog}_{t}$ 的编码中搜索键为 $(q_{s},\\gamma_{s})$ 的规则，并用新的右侧部分 $(q_{targ},\\gamma_{targ},D_{targ})$ 覆盖该编码规则，按照约定在其编码中将动作设置为 NO-OP。这是对编码了程序的数据进行的一次标准写入操作。结果是一个新的程序编码 $T^{prog}_{t+1}$。\n\n因为每次修改都是对带子有限部分的局部重写，$M_{standard}$ 可以在其计算过程中随时间执行任何有限或可数无限的此类修改序列。不需要非确定性，不需要对 $M_{standard}$ 进行外部干预或重新编程，也不需要普通工作带之外的特殊元带。这正是通用机原理：程序即数据，解释和更新程序都在具有固定转移函数的标准图灵机的能力范围之内。\n\n因此，能够实现模拟的核心原理是，$M_{standard}$ 将 SMTM 的转移函数视为其带子上的数据，并在 SMTM 执行修改时更新该数据，然后继续确定性地进行逐步模拟。所以，正确的选项是明确抓住这一原理的陈述。", "answer": "$$\\boxed{C}$$", "id": "1405429"}, {"introduction": "丘奇-图灵论题不仅定义了什么是“可计算的”，也揭示了计算的内在局限。一旦我们将“算法”等同于图灵机，我们就可以严格证明某些明确定义的问题是“不可计算的”——即不存在任何算法可以解决它们。本练习将介绍著名的“忙碌的海狸函数”（Busy Beaver function），并通过一个精妙的“反证法”论证，展示为何这个函数是不可计算的，从而让你亲身体验计算理论中最深刻的结论之一。", "problem": "丘奇-图灵论题提出，任何能由一个能行过程计算的函数都可以由一台图灵机计算。该论题的一个关键推论是存在着明确定义但不可计算的函数。其中最著名的例子之一是忙碌的海狸函数 $\\Sigma(n)$，其定义为一个会停机的、有 $n$ 个状态、使用 2 个符号（其中一个是空白符）的图灵机在初始为空白的纸带上停机前所能写入的最多'1'的数量。$\\Sigma(n)$ 的不可计算性可以通过反证法来证明。\n\n考虑以下一台图灵机的假设性构造，我们称之为 $M_{paradox}$：\n\n首先，假设存在一台假设的图灵机 $M_{\\Sigma}$，它可以计算忙碌的海狸函数 $\\Sigma(n)$。这台机器 $M_{\\Sigma}$ 从纸带上获取整数 $n$ 作为输入，在其计算完成后，它会停机，并将整数值 $\\Sigma(n)$ 写在纸带上。设这台机器 $M_{\\Sigma}$ 的状态数为一个固定常数 $c$。\n\n现在，我们通过将 $M_{\\Sigma}$ 的功能与其他组件相结合来构造机器 $M_{paradox}$。机器 $M_{paradox}$ 被设计为处理一个硬编码在其结构中的值 $N$。$M_{paradox}$ 的完整操作序列如下：\n1.  一个子机器 $M_{write}$ 将整数 $N$ 写入纸带。该组件需要固定数量的状态，即 $c_{write}$。\n2.  接着执行机器 $M_{\\Sigma}$（及其 $c$ 个状态），使用纸带上的值 $N$ 作为其输入来计算 $\\Sigma(N)$。\n3.  最后一个子机器 $M_{increment}$ 从纸带上读取值 $\\Sigma(N)$，然后在停机前向纸带的一个空白区域上写入总共 $\\Sigma(N) + 1$ 个'1'。该组件需要固定数量的状态，即 $c_{inc}$。\n\n整个机器 $M_{paradox}$ 的总状态数是其组成部分状态数之和，因此其状态数为 $N_{total} = c_{write} + c + c_{inc}$。为了制造悖论，操作步骤中使用的硬编码整数 $N$ 被设置为等于 $M_{paradox}$ 自身总状态数。也就是说，我们设置 $N = N_{total}$。给定来自非预言机组件的额外状态总和为 $c_{write} + c_{inc} = 38$。\n\n这种构造——一个有 $N_{total}$ 个状态且被设计为写入 $\\Sigma(N_{total}) + 1$ 个'1'的机器——当与忙碌的海狸函数的定义本身进行比较时，导致了一个根本性的矛盾，从而证明最初的假设（$M_{\\Sigma}$ 的存在）必定是错误的。\n\n以下哪个数学陈述正确地表示了从这个假设性构造中得出的矛盾？\n\nA. $\\Sigma(c+38) + 1 = \\Sigma(c) + \\Sigma(38)$\nB. $\\Sigma(c+38) \\le \\Sigma(c) + 38$\nC. $c+38 \\le \\Sigma(c+38)$\nD. $\\Sigma(c+38) + 1 \\le \\Sigma(c+38)$\nE. $\\Sigma(c) + 1 \\le \\Sigma(c)$", "solution": "根据忙碌的海狸函数的定义，对于任何一个从空白纸带开始、在停机前写入 $t$ 个'1'的、会停机的 $n$ 状态 2 符号图灵机 $M$，我们有以下基本界限：\n$$t \\le \\Sigma(n)$$\n假设存在一个有 $c$ 个状态的图灵机 $M_{\\Sigma}$，它在给定纸带上的输入 $n$ 后，会停机并在纸带上写下 $\\Sigma(n)$。通过组合以下部分来构造 $M_{paradox}$：\n- 一个写入器 $M_{write}$，它使用 $c_{write}$ 个状态将一个硬编码的整数 $N$ 写入纸带，\n- 有 $c$ 个状态的预言机 $M_{\\Sigma}$，用来计算 $\\Sigma(N)$，\n- 一个有 $c_{inc}$ 个状态的增量器 $M_{increment}$，它在纸带的一个空白区域上精确地写入 $\\Sigma(N)+1$ 个'1'然后停机。\n\n$M_{paradox}$ 的总状态数为：\n$$N_{total} = c_{write} + c + c_{inc}$$\n给定 $c_{write} + c_{inc} = 38$，因此：\n$$N_{total} = c + 38$$\n将硬编码的输入设置为 $N = N_{total}$。那么 $M_{paradox}$ 就是一个 $N$ 状态、2 符号的图灵机，它从空白纸带开始，会停机，并精确写入 $\\Sigma(N) + 1$ 个'1'。将忙碌的海狸函数的定义界限应用于这个特定的 $N$ 状态停机图灵机，得到：\n$$\\Sigma(N) + 1 \\le \\Sigma(N)$$\n这是一个矛盾。代入 $N = c + 38$ 得到明确的矛盾不等式：\n$$\\Sigma(c+38) + 1 \\le \\Sigma(c+38)$$\n在给定的选项中，这正是陈述 D。", "answer": "$$\\boxed{D}$$", "id": "1405440"}]}