{"hands_on_practices": [{"introduction": "理解一个 NFA 如何处理输入串是掌握 NFA-DFA 等价性的第一步。这个练习将引导你追踪一个 NFA 在读取字符串时所处的“活动状态集”，直观地展示非确定性的核心思想：机器可以同时处于多个状态。这个状态集的概念正是子集构造法中 DFA 状态的基础。[@problem_id:1367326]", "problem": "考虑一个非确定性有限自动机 (NFA)，记为 $N$，它由一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 形式化定义。其组成部分定义如下：\n- 状态集合为 $Q = \\{q_0, q_1, q_2\\}$。\n- 输入字母表为 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_0$。\n- 终止（或接受）状态集合为 $F = \\{q_2\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，定义如下：\n  - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n  - $\\delta(q_0, b) = \\{q_0\\}$\n  - $\\delta(q_1, a) = \\emptyset$\n  - $\\delta(q_1, b) = \\{q_2\\}$\n  - $\\delta(q_2, a) = \\emptyset$\n  - $\\delta(q_2, b) = \\emptyset$\n\n当一个 NFA 处理输入字符串时，它可以同时处于多个状态。在处理了输入的一部分后，NFA 可能处于的所有状态的集合被称为“活动状态集”。自动机理论中的一个基本结论是，对于任何 NFA，都存在一个等价的确定性有限自动机 (DFA)，其中 DFA 中的每个状态对应于 NFA 中的一个活动状态集。\n\n给定上述 NFA $N$，请确定从起始状态 $q_0$ 开始，处理输入字符串 `aba` 后的活动状态集。\n\nA. $\\{q_0\\}$\n\nB. $\\{q_0, q_1\\}$\n\nC. $\\{q_0, q_2\\}$\n\nD. $\\{q_1, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "我们使用标准的 NFA 更新规则来模拟活动状态集的演变：如果 $S_{i}$ 是在读取前 $i$ 个符号后的活动状态集，那么对于下一个输入符号 $x \\in \\Sigma$，\n$$\nS_{i+1}=\\bigcup_{q \\in S_{i}} \\delta(q,x).\n$$\n这个 NFA 中没有 $\\epsilon$-转移，所以不需要计算 $\\epsilon$-闭包。从初始集合 $S_{0}=\\{q_{0}\\}$ 开始。\n\n处理第一个符号 $a$：\n$$\nS_{1}=\\bigcup_{q \\in \\{q_{0}\\}} \\delta(q,a)=\\delta(q_{0},a)=\\{q_{0},q_{1}\\}.\n$$\n\n处理下一个符号 $b$：\n$$\nS_{2}=\\bigcup_{q \\in \\{q_{0},q_{1}\\}} \\delta(q,b)=\\delta(q_{0},b)\\cup \\delta(q_{1},b)=\\{q_{0}\\}\\cup \\{q_{2}\\}=\\{q_{0},q_{2}\\}.\n$$\n\n处理最后一个符号 $a$：\n$$\nS_{3}=\\bigcup_{q \\in \\{q_{0},q_{2}\\}} \\delta(q,a)=\\delta(q_{0},a)\\cup \\delta(q_{2},a)=\\{q_{0},q_{1}\\}\\cup \\emptyset=\\{q_{0},q_{1}\\}.\n$$\n\n因此，在处理输入字符串 `aba` 之后，活动状态集是 $\\{q_{0},q_{1}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1367326"}, {"introduction": "在理解了活动状态集的概念后，我们可以将其形式化为子集构造算法，这是将任何 NFA 转换为等价 DFA 的标准方法。通过这个实践，你将从头开始为一个给定的 NFA 构建其对应的最小 DFA。这个过程不仅能巩固你对算法的理解，还能揭示一个简单的 NFA 如何展开为一个结构更丰富的 DFA。[@problem_id:1367335]", "problem": "考虑一个非确定性有限自动机 (NFA)，记作 $N$，它由一个五元组 $(Q, \\Sigma, \\delta, q_{start}, F)$ 形式化定义。其组成部分规定如下：\n- 状态集为 $Q = \\{s_0, s_1\\}$。\n- 输入字母表为 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_{start} = s_0$。\n- 最终（或接受）状态集为 $F = \\{s_1\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，由下表给出：\n\n| 状态 | 输入 'a' | 输入 'b' |\n|:-----:|:---------:|:---------:|\n| $s_0$ | $\\{s_1\\}$   | $\\{s_0, s_1\\}$ |\n| $s_1$ | $\\{s_0\\}$   | $\\{s_1\\}$   |\n\n自动机理论中有一个已知的定理：对于任何 NFA，都存在一个识别相同语言的等价确定性有限自动机 (DFA)。使用标准的子集构造算法，可以构造出这样的一个 DFA。在构造出等价的 DFA 后，应将其最小化以获得最少的状态数。\n\n与上述 NFA $N$ 等价的最小 DFA 中有多少个最终（接受）状态？\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3", "solution": "问题要求计算与给定的非确定性有限自动机 (NFA) 等价的最小确定性有限自动机 (DFA) 中最终状态的数量。我们将使用子集构造算法来找到等价的 DFA，然后计算其最终状态的数量。通过子集构造法从一个没有从起始状态不可达状态的 NFA 生成的 DFA 本身也不会有不可达状态。然后可以检查其最小性。\n\n给定的 NFA 是 $N = (Q, \\Sigma, \\delta, s_0, F)$，其中：\n- $Q = \\{s_0, s_1\\}$\n- $\\Sigma = \\{a, b\\}$\n- 起始状态为 $s_0$\n- 最终状态 $F = \\{s_1\\}$\n- 转移函数 $\\delta$ 如问题陈述中所给出。\n\n等价 DFA（我们称之为 $M$）的状态将是 NFA 状态集 $Q$ 的子集。$M$ 的起始状态是包含 $N$ 起始状态的集合。\n我们将 $M$ 的状态表示为 $S_i$。\n\n1.  **起始状态：** $M$ 的起始状态是 $S_{start} = \\{s_0\\}$。我们称这个状态为 $S_0$。\n\n2.  **从 $S_0 = \\{s_0\\}$ 开始探索：** 我们计算该状态对于字母表 $\\Sigma=\\{a,b\\}$ 中每个符号的转移。\n    - 对于输入 'a'：$\\delta_M(S_0, a) = \\delta(s_0, a) = \\{s_1\\}$。这是一个新状态。我们称之为 $S_1 = \\{s_1\\}$。\n    - 对于输入 'b'：$\\delta_M(S_0, b) = \\delta(s_0, b) = \\{s_0, s_1\\}$。这是另一个新状态。我们称之为 $S_2 = \\{s_0, s_1\\}$。\n\n3.  **从 $S_1 = \\{s_1\\}$ 开始探索：** 现在我们计算新状态 $S_1$ 的转移。\n    - 对于输入 'a'：$\\delta_M(S_1, a) = \\delta(s_1, a) = \\{s_0\\} = S_0$。这个状态已经存在。\n    - 对于输入 'b'：$\\delta_M(S_1, b) = \\delta(s_1, b) = \\{s_1\\} = S_1$。这个状态已经存在。\n\n4.  **从 $S_2 = \\{s_0, s_1\\}$ 开始探索：** 我们计算状态 $S_2$ 的转移。从一个状态集合的转移是该集合中每个状态转移的并集。\n    - 对于输入 'a'：$\\delta_M(S_2, a) = \\delta(s_0, a) \\cup \\delta(s_1, a) = \\{s_1\\} \\cup \\{s_0\\} = \\{s_0, s_1\\} = S_2$。\n    - 对于输入 'b'：$\\delta_M(S_2, b) = \\delta(s_0, b) \\cup \\delta(s_1, b) = \\{s_0, s_1\\} \\cup \\{s_1\\} = \\{s_0, s_1\\} = S_2$。\n\n我们现在已经探索了所有可达状态。我们的新 DFA $M$ 的状态集是 $Q_M = \\{S_0, S_1, S_2\\} = \\{\\{s_0\\}, \\{s_1\\}, \\{s_0, s_1\\}\\}$。该 DFA 有 3 个状态。\n\n5.  **确定最终状态：** 如果 DFA 中的一个状态包含至少一个来自原始 NFA 的最终状态，则该状态是最终状态。NFA 中的最终状态集是 $F = \\{s_1\\}$。\n    - $S_0 = \\{s_0\\}$ 不包含 $s_1$。因此，$S_0$ 不是最终状态。\n    - $S_1 = \\{s_1\\}$ 包含 $s_1$。因此，$S_1$ 是一个最终状态。\n    - $S_2 = \\{s_0, s_1\\}$ 包含 $s_1$。因此，$S_2$ 是一个最终状态。\n    $M$ 中的最终状态集是 $F_M = \\{S_1, S_2\\}$。\n\n6.  **检查最小性：** 如果子集构造法产生的 DFA 的所有状态都是可区分的，那么它就是最小的。\n    - $S_0$ 是非最终状态，而 $S_1$ 和 $S_2$ 是最终状态。因此，$S_0$ 与 $S_1$ 和 $S_2$ 都是可区分的。\n    - 为了区分 $S_1$ 和 $S_2$（两者都是最终状态），我们检查它们的转移。\n        - 在输入 'a' 时，$\\delta_M(S_1, a) = S_0$（一个非最终状态）。\n        - 在输入 'a' 时，$\\delta_M(S_2, a) = S_2$（一个最终状态）。\n    由于输入 'a' 将 $S_1$ 和 $S_2$ 带到不同最终性的状态（一个非最终状态，一个最终状态），因此 $S_1$ 和 $S_2$ 是可区分的。\n    由于所有三个状态彼此之间都是可区分的，因此构造的这个 3 状态 DFA 是最小的。\n\n7.  **计算最终状态数量：** 最终状态集为 $F_M = \\{S_1, S_2\\}$。最终状态的数量为 $|F_M| = 2$。", "answer": "$$\\boxed{C}$$", "id": "1367335"}, {"introduction": "DFAs 和 NFAs 之间的一个关键区别在于它们如何处理补集运算。对于一个 DFA，我们可以简单地通过交换接受和非接受状态来得到其补语言的自动机，但这个捷径对 NFA 无效。这个练习通过一个具体的反例揭示了其中的原因，并强调了为什么在进行补集等操作前，将 NFA 转换为等价的 DFA 是至关重要的一步。[@problem_id:1367357]", "problem": "在计算理论中，为语言 $L$ 的补集构造自动机的一个标准方法是，从一个识别 $L$ 的确定性有限自动机（DFA）开始，然后将其最终状态集与非最终状态集交换。然而，这个过程对于不确定性有限自动机（NFA）通常不成立。\n\n本问题要求您探究此失效情况。考虑由五元组 $(Q, \\Sigma, \\delta, q_s, F)$ 定义的NFA $N$，其中：\n- 状态集为 $Q = \\{q_s, q_f\\}$。\n- 字母表为 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_s$。\n- 最终状态集为 $F = \\{q_f\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，定义如下：\n    - $\\delta(q_s, a) = \\{q_s, q_f\\}$\n    - $\\delta(q_s, b) = \\{q_s\\}$\n    - $\\delta(q_f, a) = \\emptyset$ (空集)\n    - $\\delta(q_f, b) = \\emptyset$\n\n令 $L(N)$ 为 $N$ 接受的语言。\n现在，通过交换 $N$ 的最终状态和非最终状态，构造一个新的NFA $N'$。新的自动机为 $N' = (Q, \\Sigma, \\delta, q_s, Q \\setminus F)$。令 $L(N')$ 为 $N'$ 接受的语言。\n\n$L(N')$ 不是 $L(N)$ 的补集的一个关键标志是，存在一个被两个自动机都接受的字符串。如果 $L(N')$ 是 $L(N)$ 的真正补集，那么没有字符串会同时属于两种语言。\n\n您的任务是找到字母表 $\\Sigma$ 上最短的非空字符串 $w$，它既被原始自动机 $N$ 接受，也被修改后的自动机 $N'$ 接受。", "solution": "我们分析NFA $N=(Q,\\Sigma,\\delta,q_{s},F)$，其中 $Q=\\{q_{s},q_{f}\\}$，$\\Sigma=\\{a,b\\}$，起始状态为 $q_{s}$，接受状态集为 $F=\\{q_{f}\\}$，转移函数为 $\\delta(q_{s},a)=\\{q_{s},q_{f}\\}$，$\\delta(q_{s},b)=\\{q_{s}\\}$，以及 $\\delta(q_{f},a)=\\delta(q_{f},b)=\\emptyset$。\n\n首先，刻画 $L(N)$。一个字符串 $w$ 被 $N$ 接受，当且仅当在读完 $w$ 的所有符号后，存在一个运行路径在 $q_{f}$ 中结束。进入 $q_{f}$ 的唯一方法是在状态 $q_{s}$ 读入一个 $a$ 并进行到 $q_{f}$ 的转移。由于对于所有 $x\\in\\Sigma$，$\\delta(q_{f},x)=\\emptyset$，一旦到达 $q_{f}$，就无法再读取任何输入。因此，在任何接受的运行路径中，进入 $q_{f}$ 的转移必须发生在输入的最后一个符号上，并且该最后一个符号必须是 $a$。反之，对于任何以 $a$ 结尾的字符串，都存在一个运行路径，它在之前的所有符号上都停留在 $q_{s}$（在需要时从 $\\delta(q_{s},a)$ 中选择 $q_{s}$，并使用 $\\delta(q_{s},b)=\\{q_{s}\\}$），然后在最后一个符号上进行 $q_{s}\\xrightarrow{a}q_{f}$ 的转移。因此\n$$\nL(N)=\\{xa\\mid x\\in\\{a,b\\}^{*}\\},\n$$\n即所有最后一个符号为 $a$ 的非空字符串的集合。\n\n现在构造 $N'=(Q,\\Sigma,\\delta,q_{s},Q\\setminus F)$，所以唯一的接受状态是 $q_{s}$。一个字符串 $w$ 被 $N'$ 接受，当且仅当存在一个在 $q_{s}$ 结束的运行路径。从 $q_{s}$ 开始，在输入 $a$ 时，我们可以选择停留在 $q_{s}$（因为 $\\delta(q_{s},a)$ 包含 $q_{s}$），在输入 $b$ 时，我们必须进入 $q_{s}$（因为 $\\delta(q_{s},b)=\\{q_{s}\\}$）。因此，对于每个 $w\\in\\Sigma^{*}$，都存在一个始终停留在 $q_{s}$ 并因此在 $q_{s}$ 结束的运行路径。于是\n$$\nL(N')=\\Sigma^{*}.\n$$\n\n因此，$L(N)\\cap L(N')=L(N)=\\{xa\\mid x\\in\\{a,b\\}^{*}\\}$。此集合中最短的非空字符串是 $w=a$，长度为 $1$，它被 $N$ 接受（通过 $q_{s}\\xrightarrow{a}q_{f}$）也被 $N'$ 接受（通过 $q_{s}\\xrightarrow{a}q_{s}$）。", "answer": "$$\\boxed{a}$$", "id": "1367357"}]}