{"hands_on_practices": [{"introduction": "深度优先搜索（DFS）的核心在于其递归的探索过程。为了精确地理解算法的执行流程，追踪每个顶点的“发现时间”和“完成时间”是一种基本且强大的技术。这个练习将带你手动模拟一次递归DFS，通过记录时间戳来可视化算法如何深入图的结构，又如何回溯。这个过程不仅是理解DFS的基础，也为后续学习拓扑排序和寻找强连通分量等高级应用奠定基础。[@problem_id:1362166]", "problem": "一个软件构建系统使用“依赖解析协议”来确定一组相互连接的代码模块的正确编译顺序。该协议作用于一个由模块及其依赖关系组成的图。该过程包括为每个模块分配两个时间戳：“发现时间”和“完成时间”。\n\n协议如下：\n1.  一个全局时间戳计数器初始化为1。\n2.  该过程从一个起始模块开始。如果没有指定起始模块，则从按字母顺序排在最前面的模块开始。\n3.  当一个模块首次被访问时，它被标记为“已发现”，其发现时间被设置为全局时间戳的当前值，然后时间戳加1。\n4.  然后，系统检查刚刚发现的模块的邻居。它会根据字母顺序，对找到的第一个未访问过的邻居递归调用该协议。\n5.  在对一个模块的所有邻居的递归调用都返回后，该模块被标记为“已完成”，其完成时间被设置为全局时间戳的当前值，然后时间戳加1。然后该过程返回到其被调用的地方。\n6.  如果初始遍历完成时仍有未访问的模块，则从按字母顺序排在最前面的未访问模块开始重复该过程。\n\n考虑一个有八个模块的项目：A, B, C, D, E, F, G, H。依赖关系是对称的（即，如果X依赖于Y，那么Y也依赖于X），定义如下：\n-   模块A与B、D和E相连。\n-   模块B与A和C相连。\n-   模块C与B、G和H相连。\n-   模块D与A和F相连。\n-   模块E与A和F相连。\n-   模块F与D、E和G相连。\n-   模块G与C和F相连。\n-   模块H与C相连。\n\n从模块A开始执行该协议，确定所有八个模块的发现时间和完成时间。以下哪个选项正确列出了从A到H按字母顺序排列的所有模块的`(discovery_time, finish_time)`（发现时间，完成时间）对？\n\nA. A:(1,16), B:(8,9), C:(7,12), D:(2,15), E:(4,5), F:(3,14), G:(6,13), H:(10,11)\n\nB. A:(1, 16), B:(2, 15), C:(3, 14), D:(8, 9), E:(6, 7), F:(5, 10), G:(4, 11), H:(12, 13)\n\nC. A:(1, 16), B:(2, 15), C:(3, 14), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(12, 13)\n\nD. A:(1, 16), B:(2, 15), C:(3, 12), D:(6, 7), E:(8, 9), F:(5, 10), G:(4, 11), H:(13, 14)", "solution": "我们执行一次深度优先遍历，使用一个初始化为 1 的全局时间戳 $t$，从 $A$ 开始，并按字母顺序探索邻居。首次访问一个节点 $v$ 时，设置其发现时间 $d(v)=t$ 并使 $t$ 加 1。在对 $v$ 的所有邻居的递归调用返回后，设置其完成时间 $f(v)=t$ 并使 $t$ 加 1。\n\n初始化 $t=1$。\n\n从 $A$ 开始，其邻居按顺序为 $B,D,E$。\n$d(A)=1, t=2$\n前往 $B$（$A$ 的第一个未访问邻居）。$B$ 的邻居按顺序为 $A,C$。\n$d(B)=2, t=3$\n$A$ 已被访问；前往 $C$。$C$ 的邻居按顺序为 $B,G,H$。\n$d(C)=3, t=4$\n$B$ 已被访问；前往 $G$。$G$ 的邻居按顺序为 $C,F$。\n$d(G)=4, t=5$\n$C$ 已被访问；前往 $F$。$F$ 的邻居按顺序为 $D,E,G$。\n$d(F)=5, t=6$\n前往 $D$（第一个未访问的）。$D$ 的邻居按顺序为 $A,F$。\n$d(D)=6, t=7$\n$A$ 和 $F$ 都已被访问；完成 $D$：\n$f(D)=7, t=8$\n返回到 $F$；下一个邻居是 $E$（未访问）。\n$d(E)=8, t=9$\n$E$ 的邻居是 $A,F$，都已被访问；完成 $E$：\n$f(E)=9, t=10$\n回到 $F$；下一个邻居 $G$ 已被访问；完成 $F$：\n$f(F)=10, t=11$\n回到 $G$；没有更多邻居；完成 $G$：\n$f(G)=11, t=12$\n回到 $C$；下一个邻居是 $H$（未访问）。\n$d(H)=12, t=13$\n$H$ 的邻居 $C$ 已被访问；完成 $H$：\n$f(H)=13, t=14$\n回到 $C$；没有更多邻居；完成 $C$：\n$f(C)=14, t=15$\n回到 $B$；没有更多邻居；完成 $B$：\n$f(B)=15, t=16$\n回到 $A$；剩下的邻居 $D,E$ 都已被访问；完成 $A$：\n$f(A)=16, t=17$\n\n因此，发现/完成时间如下：\n- $A:(1,16)$\n- $B:(2,15)$\n- $C:(3,14)$\n- $D:(6,7)$\n- $E:(8,9)$\n- $F:(5,10)$\n- $G:(4,11)$\n- $H:(12,13)$\n\n这与选项C匹配。", "answer": "$$\\boxed{C}$$", "id": "1362166"}, {"introduction": "虽然递归是理解深度优先搜索（DFS）的优雅方式，但其迭代实现能让我们更清晰地看到算法的底层工作机制。通过使用一个显式的栈来代替递归调用栈，我们可以更好地控制遍历过程，并避免在处理非常深的图时可能出现的栈溢出问题。本练习旨在揭示递归与迭代之间的直接联系，通过追踪栈内容的变化，让你亲手体验DFS的“引擎”是如何运转的。[@problem_id:1496233]", "problem": "考虑一个无向图 $G = (V, E)$，其顶点集定义为 $V = \\{0, 1, 2, 3, 4\\}$，边集 $E$ 构成一个轮图 $W_5$。在此图中，顶点 0 是中心枢纽，连接到所有其他顶点。其余顶点 $\\{1, 2, 3, 4\\}$ 形成一个环，边连接 1 到 2，2 到 3，3 到 4，以及 4 回到 1。\n\n该图的邻接表定义如下，每个顶点的邻居按升序排列：\n- `Adj(0): [1, 2, 3, 4]`\n- `Adj(1): [0, 2, 4]`\n- `Adj(2): [0, 1, 3]`\n- `Adj(3): [0, 2, 4]`\n- `Adj(4): [0, 1, 3]`\n\n你将要在此图上执行一个迭代深度优先搜索 (DFS)。该算法按以下步骤进行：\n1. 初始化一个空栈和一个空已访问顶点集合。\n2. 将起始顶点推入栈中。\n3. 当栈不为空时，弹出一个顶点 `u`。\n4. 如果 `u` 已被访问，则不执行任何操作并继续下一次迭代。\n5. 如果 `u` 未被访问，则将其标记为已访问。然后，对于 `u` 的每个邻居 `v`（从邻接表中获取），如果 `v` 未被访问，则将 `v` 推入栈中。\n6. `u` 的邻居按照其顶点标签的**降序**被推入栈中。\n\nDFS 遍历从顶点 0 开始。你的任务是确定在顶点 2 从栈中弹出后，栈中（从顶到底）的内容。\n\n下列哪个列表表示了那一刻栈的内容？\n\nA. `[4, 2, 3, 4]`\n\nB. `[3, 4]`\n\nC. `[2, 4, 2, 3, 4]`\n\nD. `[1, 3, 2, 1]`\n\nE. `[2, 3, 4]`", "solution": "我们使用一个栈来执行指定的迭代DFS，按降序推入邻居，并且只有未访问过的邻居才会被推入（如果一个顶点在之前被推入时还未被访问，则栈中可能会出现重复项）。\n\n初始化空栈和空已访问集合。将起始顶点 $0$ 推入栈中，因此栈为 [0]。弹出 $0$；由于 $0$ 未被访问，将其标记为已访问，所以 visited $=\\{0\\}$。处理 $0$ 的邻居，即 $[1,2,3,4]$；降序为 $[4,3,2,1]$。所有邻居都未被访问，所以按该顺序推入，得到栈 [4, 3, 2, 1]，栈顶为 $1$。\n\n弹出 $1$；它未被访问，因此标记 visited $=\\{0,1\\}$。$1$ 的邻居是 $[0,2,4]$；降序为 $[4,2,0]$。其中，$4$ 和 $2$ 未被访问，所以先推入 $4$，再推入 $2$。栈变为 [4, 3, 2, 4, 2]，栈顶为 $2$。\n\n现在弹出顶点 $2$。在这次弹出之后，处理 $2$ 之前，栈的内容（从底到顶）是 [4, 3, 2, 4]。因此，从顶到底，栈是 [4, 2, 3, 4]，这与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1496233"}, {"introduction": "深度优先搜索（DFS）的一个重要却又微妙的特性是，其产生的DFS树结构并非唯一。遍历邻接顶点的顺序会直接影响哪些边被归类为“树边”，哪些成为“后向边”，从而塑造出一棵特定的DFS树。这个练习将通过比较两种不同邻接表顺序下的DFS遍历结果，让你深入理解遍历顺序对算法输出的影响。这有助于破除“图只有一棵正确DFS树”的误解，并加深对边分类机制的认识。[@problem_id:1496211]", "problem": "考虑一个无向图 $G = (V, E)$，其中顶点集为 $V = \\{A, B, C, D, E, F\\}$，边集为 $E = \\{\\{A, B\\}, \\{A, C\\}, \\{A, D\\}, \\{B, C\\}, \\{C, D\\}, \\{C, E\\}, \\{D, F\\}, \\{E, F\\}\\}$。\n\n深度优先搜索 (DFS) 是一种用于遍历图的算法。当从一个源顶点开始执行 DFS 时，图的边会被分类。如果顶点 $v$ 是通过从顶点 $u$ 探索而首次被发现的，则边 $(u, v)$ 是一条“树边”。如果顶点 $v$ 在 DFS 树中是顶点 $u$ 的祖先但不是其父节点，则边 $(u, v)$ 是一条“回边”。所有树边的集合构成一棵 DFS 树（或森林）。\n\nDFS 树的结构和边的分类取决于访问相邻顶点的顺序。这个顺序由图的邻接表表示法决定。\n\n对图 $G$ 执行两次不同的 DFS 遍历，两次都从顶点 $A$ 开始。\n1.  **遍历 1**：使用邻接表表示 $L_1$，其中每个顶点的邻居按字母顺序列出。此遍历生成一棵 DFS 树 $T_1$。\n2.  **遍历 2**：使用另一种邻接表表示 $L_2$，其中每个顶点的邻居按下面给出的特定顺序列出。此遍历生成一棵 DFS 树 $T_2$。\n\n邻接表 $L_2$：\n- A: [D, C, B]\n- B: [C, A]\n- C: [E, D, B, A]\n- D: [F, C, A]\n- E: [F, C]\n- F: [E, D]\n\n基于这两次遍历，以下哪个陈述是正确的？\n\nA. 两次遍历的回边集合相同。\n\nB. DFS 树 $T_1$ 的高度大于 DFS 树 $T_2$ 的高度。（树的高度是指从根到叶子的最长向下路径上的边数。）\n\nC. 边 $\\{C, D\\}$ 在 $T_1$ 中是树边，在 $T_2$ 中也是树边。\n\nD. 边 $\\{A, D\\}$ 在 $T_1$ 中是回边，但在 $T_2$ 中是树边。\n\nE. 顶点 $C$ 在两棵 DFS 树 $T_1$ 和 $T_2$ 中有相同的父节点。", "solution": "我们首先根据 $E=\\{\\{A,B\\},\\{A,C\\},\\{A,D\\},\\{B,C\\},\\{C,D\\},\\{C,E\\},\\{D,F\\},\\{E,F\\}\\}$ 构建按字母顺序排列的邻接表 $L_1$：\n- $A:[B,C,D]$, $B:[A,C]$, $C:[A,B,D,E]$, $D:[A,C,F]$, $E:[C,F]$, $F:[D,E]$.\n\n使用 $L_1$ 从 $A$ 开始的深度优先搜索过程如下。\n- 从 $A$ 访问 $B$：树边 $\\{A,B\\}$。\n- 从 $B$ 访问 $C$：树边 $\\{B,C\\}$。\n- 从 $C$ 访问 $D$：树边 $\\{C,D\\}$。在 $C$ 处，其邻居 $A$ 已被访问且是祖先，故 $\\{C,A\\}$ 是回边。\n- 在 $D$ 处，其邻居 $A$ 已被访问且是祖先，故 $\\{D,A\\}$ 是回边。然后访问 $F$：树边 $\\{D,F\\}$。\n- 从 $F$ 访问 $E$：树边 $\\{F,E\\}$。\n- 在 $E$ 处，其邻居 $C$ 已被访问且是祖先，故 $\\{E,C\\}$ 是回边。\n\n因此对于 $T_1$，树边为 $\\{\\{A,B\\},\\{B,C\\},\\{C,D\\},\\{D,F\\},\\{F,E\\}\\}$，形成路径 $A-B-C-D-F-E$。回边为 $\\{\\{A,C\\},\\{A,D\\},\\{C,E\\}\\}$。$T_1$ 的高度为 $5$（最长的根到叶子路径有 $5$ 条边）。\n\n现在使用 $L_2$：\n- $A:[D,C,B]$, $B:[C,A]$, $C:[E,D,B,A]$, $D:[F,C,A]$, $E:[F,C]$, $F:[E,D]$.\n\n使用 $L_2$ 从 $A$ 开始的深度优先搜索过程如下。\n- 从 $A$ 访问 $D$：树边 $\\{A,D\\}$。\n- 从 $D$ 访问 $F$：树边 $\\{D,F\\}$。\n- 从 $F$ 访问 $E$：树边 $\\{F,E\\}$。\n- 从 $E$ 访问 $C$：树边 $\\{E,C\\}$。\n- 在 $C$ 处，其邻居 $D$ 已被访问且是祖先，故 $\\{C,D\\}$ 是回边。然后访问 $B$：树边 $\\{C,B\\}$。\n- 在 $B$ 处，其邻居 $A$ 已被访问且是祖先，故 $\\{B,A\\}$ 是回边。回到 $C$ 处，其邻居 $A$ 也被访问且是祖先，故 $\\{C,A\\}$ 是回边。\n\n因此对于 $T_2$，树边为 $\\{\\{A,D\\},\\{D,F\\},\\{F,E\\},\\{E,C\\},\\{C,B\\}\\}$，形成路径 $A-D-F-E-C-B$。回边为 $\\{\\{A,B\\},\\{A,C\\},\\{C,D\\}\\}$。$T_2$ 的高度也为 $5$。\n\n评估这些陈述：\n- A：回边集合不同（$\\{\\{A,C\\},\\{A,D\\},\\{C,E\\}\\}$ 与 $\\{\\{A,B\\},\\{A,C\\},\\{C,D\\}\\}$），所以为假。\n- B：高度相等（$5$ 和 $5$），所以为假。\n- C：$\\{C,D\\}$ 在 $T_1$ 中是树边，但在 $T_2$ 中是回边，所以为假。\n- D：$\\{A,D\\}$ 在 $T_1$ 中是回边，在 $T_2$ 中是树边，所以为真。\n- E：$C$ 在 $T_1$ 中的父节点是 $B$，而在 $T_2$ 中是 $E$，所以为假。\n\n因此，只有陈述 D 是正确的。", "answer": "$$\\boxed{D}$$", "id": "1496211"}]}