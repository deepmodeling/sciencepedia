{"hands_on_practices": [{"introduction": "在计算机科学和组合数学中，许多计数问题可以通过寻找一个递推关系来解决。强归纳法是验证这些递推关系正确性的有力工具。本练习[@problem_id:1402596]将引导你为一个受限的二进制字符串（不包含“00”子串）构建一个递推关系，并用它来解决一个具体的计数问题。", "problem": "某种类型的计算机存储器被设计用于以二进制字符串（0和1的序列）的形式存储数据。由于数据写入机制的物理限制，无法写入两个连续的'0'。任何不包含子串'00'的二进制字符串都被视为一个“有效字”。您的任务是确定长度为 $n=17$ 的不同有效字的总数。", "solution": "设 $a_n$ 为长度为 $n$ 的有效二进制字符串的数量，其中有效字符串是指不包含子串 '00' 的字符串。我们想求出 $a_{17}$ 的值。\n\n为了解决这个问题，我们首先找到 $a_n$ 的递推关系。我们从为较小的 $n$ 值建立基本情况开始。\n\n对于 $n=1$：可能的字符串是 \"0\" 和 \"1\"。两者都不包含子串 \"00\"，所以它们都是有效的。因此，$a_1 = 2$。\n\n对于 $n=2$：可能的二进制字符串是 \"00\"、\"01\"、\"10\" 和 \"11\"。字符串 \"00\" 是被禁止的。其他三个字符串 \"01\"、\"10\" 和 \"11\" 是有效的。因此，$a_2 = 3$。\n\n现在，让我们考虑一个长度为 $n$（其中 $n \\geq 3$）的有效字符串。我们可以根据它们的最后一位对这些字符串进行分类。\n\n情况1：字符串以 '1' 结尾。\n如果一个长度为 $n$ 的有效字符串以 '1' 结尾，那么它的前 $n-1$ 位可以构成任何长度为 $n-1$ 的有效字符串。在任何有效字符串后面追加一个 '1' 永远不会产生被禁止的 \"00\" 子串。因此，以 '1' 结尾的长度为 $n$ 的有效字符串的数量等于长度为 $n-1$ 的有效字符串的总数，即 $a_{n-1}$。\n\n情况2：字符串以 '0' 结尾。\n如果一个长度为 $n$ 的有效字符串以 '0' 结尾，那么第 $n-1$ 位上的比特不能是 '0'，因为那样会产生被禁止的 \"00\" 子串。因此，第 $n-1$ 位上的比特必须是 '1'。这意味着该字符串必须以 \"10\" 结尾。它的前 $n-2$ 位可以构成任何长度为 $n-2$ 的有效字符串。在任何长度为 $n-2$ 的有效字符串后面追加 \"10\" 将总是得到一个长度为 $n$ 的有效字符串。因此，以 '0' 结尾的长度为 $n$ 的有效字符串的数量等于长度为 $n-2$ 的有效字符串的总数，即 $a_{n-2}$。\n\n由于这两种情况是互斥的（一个字符串不能同时以 '0' 和 '1' 结尾）和穷尽的（一个字符串必须以 '0' 或 '1' 结尾），我们可以通过将两种情况的计数相加来得到长度为 $n$ 的有效字符串的总数。这给了我们递推关系：\n$$ a_n = a_{n-1} + a_{n-2} $$\n此关系对 $n \\geq 3$ 成立。这个依赖于前两项的递推关系的建立，可以通过使用强归纳法原理来正式证明，其中 $a_1$ 和 $a_2$ 作为归纳的基础情况。\n\n现在我们可以顺序计算 $a_n$ 的值，直到达到 $a_{17}$：\n$a_1 = 2$\n$a_2 = 3$\n$a_3 = a_2 + a_1 = 3 + 2 = 5$\n$a_4 = a_3 + a_2 = 5 + 3 = 8$\n$a_5 = a_4 + a_3 = 8 + 5 = 13$\n$a_6 = a_5 + a_4 = 13 + 8 = 21$\n$a_7 = a_6 + a_5 = 21 + 13 = 34$\n$a_8 = a_7 + a_6 = 34 + 21 = 55$\n$a_9 = a_8 + a_7 = 55 + 34 = 89$\n$a_{10} = a_9 + a_8 = 89 + 55 = 144$\n$a_{11} = a_{10} + a_9 = 144 + 89 = 233$\n$a_{12} = a_{11} + a_{10} = 233 + 144 = 377$\n$a_{13} = a_{12} + a_{11} = 377 + 233 = 610$\n$a_{14} = a_{13} + a_{12} = 610 + 377 = 987$\n$a_{15} = a_{14} + a_{13} = 987 + 610 = 1597$\n$a_{16} = a_{15} + a_{14} = 1597 + 987 = 2584$\n$a_{17} = a_{16} + a_{15} = 2584 + 1597 = 4181$\n\n长度为 $n=17$ 的不同有效字的总数为 4181。", "answer": "$$\\boxed{4181}$$", "id": "1402596"}, {"introduction": "强归纳法不仅用于计数，也常用于证明一个过程的某个属性是不变的，或者总和是固定的，无论过程的具体步骤如何。这类属性被称为“不变量”。这个关于数据包分片成本的练习[@problem_id:1402593]就是一个绝佳的例子，它揭示了总计算成本惊人地与分片策略无关，这背后正是强归纳原理在起作用。", "problem": "在一种特定的数据通信协议中，大的数据包在传输前必须被分片。分片过程是递归的。单次操作包括将任何大小为 $k  1$ 字节的数据包分裂成两个更小的、非空的数据包，大小分别为 $k_1$ 和 $k_2$，其中 $k_1 + k_2 = k$。与单次分裂操作相关的计算成本定义为两个新生成数据包大小的乘积，即 $k_1 \\times k_2$。这个过程会一直重复，直到初始数据包被完全分解为大小为1字节的数据包。\n\n计算将一个大小为 $N = 50$ 字节的初始数据包完全分片成50个独立的1字节数据包所需的总计算成本。", "solution": "这个问题可以通过强归纳法解决，但一个更优雅的方法是使用不变量或势函数方法。设 $C(N)$ 为将一个大小为 $N$ 的数据包完全分片的总成本。\n\n**基础情形：**\n对于 $N=1$，数据包已经是1字节，不需要分片，所以 $C(1)=0$。\n对于 $N=2$，只能分裂成 $1+1$。成本为 $1 \\times 1 = 1$。所以 $C(2)=1$。\n对于 $N=3$，可以分裂成 $1+2$。成本为 $1 \\times 2 = 2$，然后对大小为2的包进行分片，成本为 $C(2)=1$。总成本为 $2+1=3$。或者分裂成 $2+1$，结果相同。\n\n**归纳步骤：**\n假设对于所有 $m  N$ 的数据包，总成本为 $C(m) = \\frac{m(m-1)}{2}$。\n现在考虑一个大小为 $N$ 的数据包。第一步将其分裂为大小为 $k_1$ 和 $k_2$ 的两个包，其中 $k_1+k_2=N$ 且 $k_1, k_2 \\ge 1$。\n这一步的成本是 $k_1 \\times k_2$。\n之后，我们需要分别分片大小为 $k_1$ 和 $k_2$ 的包。由于 $k_1  N$ 且 $k_2  N$，我们可以应用归纳假设。\n总成本 $C(N)$ 是当前步骤的成本加上后续分片的成本：\n$$\nC(N) = (k_1 \\times k_2) + C(k_1) + C(k_2)\n$$\n根据归纳假设， $C(k_1) = \\frac{k_1(k_1-1)}{2}$ 且 $C(k_2) = \\frac{k_2(k_2-1)}{2}$。\n代入公式：\n$$\nC(N) = k_1 k_2 + \\frac{k_1(k_1-1)}{2} + \\frac{k_2(k_2-1)}{2}\n$$\n$$\nC(N) = \\frac{2k_1 k_2 + k_1^2 - k_1 + k_2^2 - k_2}{2}\n$$\n$$\nC(N) = \\frac{(k_1^2 + 2k_1 k_2 + k_2^2) - (k_1 + k_2)}{2}\n$$\n$$\nC(N) = \\frac{(k_1+k_2)^2 - (k_1+k_2)}{2}\n$$\n因为 $k_1+k_2 = N$，我们得到：\n$$\nC(N) = \\frac{N^2 - N}{2} = \\frac{N(N-1)}{2}\n$$\n这表明总成本与具体的分裂方式（$k_1$ 和 $k_2$ 的选择）无关，它是一个不变量。\n\n对于 $N = 50$，总计算成本为：\n$$\nC(50) = \\frac{50(50-1)}{2} = \\frac{50 \\times 49}{2} = 25 \\times 49 = 1225\n$$", "answer": "$$\\boxed{1225}$$", "id": "1402593"}, {"introduction": "理论与实践的结合是掌握数学工具的关键。许多通过归纳法证明的定理本质上是“构造性”的，即其证明过程本身就描述了一个算法。这个练习[@problem_id:1402599]让你亲手执行这个构造性证明中的一步，将一个抽象的强归纳步骤转化为一个具体的算法操作，从而加深对归纳证明如何“构建”解的理解。", "problem": "在一场体育分析竞赛中，你的任务是分析循环赛的结果。在这场锦标赛中，有 $n$ 名选手参赛，每位选手都与其他所有选手比赛一次，每场比赛都有一人获胜一人落败（没有平局）。这样的锦标赛可以被建模为一个“竞赛图”，其中选手是顶点，从选手 $u$ 到选手 $v$ 的有向边意味着 $u$ 战胜了 $v$。\n\n一个关键任务是找到一个“优势排名”，这是一个包含所有 $n$ 名选手的序列 $(P_1, P_2, \\dots, P_n)$，使得对于所有 $i=1, \\dots, n-1$，都有 $P_i$ 战胜 $P_{i+1}$。在图论中，这被称为哈密顿路径。\n\n在有 $n$ 名选手的锦标赛中，找到这样一条路径的一个著名构造方法是，从一个包含 $n-1$ 名选手的子锦标赛的现有哈密顿路径开始，然后将第 $n$ 名选手插入到序列中的正确位置。\n\n考虑一个有五名选手的锦标赛：{Anna, Ben, Chloe, David, Emily}。对于由 {Anna, Ben, Chloe, David} 组成的四人子锦标赛，一个可能的优势排名（哈密顿路径）是 (Ben, Anna, David, Chloe)。涉及第五位选手 Emily 的比赛结果如下：\n- Emily 输给了 Anna。\n- Emily 输给了 Ben。\n- Emily 战胜了 Chloe。\n- Emily 战胜了 David。\n\n使用所述的将新选手插入现有路径的构造方法，完整的五人锦标赛的最终优势排名是什么？\n\nA. (Ben, Anna, Emily, David, Chloe)\n\nB. (Emily, Ben, Anna, David, Chloe)\n\nC. (Ben, Anna, David, Chloe, Emily)\n\nD. (Ben, Emily, Anna, David, Chloe)\n\nE. (Anna, Ben, David, Chloe, Emily)", "solution": "该问题要求我们将新选手 Emily 插入到一个已有的优势排名（哈密顿路径）中。现有的路径是 (Ben, Anna, David, Chloe)，可以表示为 $B \\to A \\to D \\to C$。\n\n构造新路径的算法如下：\n1.  如果新选手（Emily）战胜了路径中的第一个人（Ben），则将她放在最前面。Emily 输给了 Ben，所以此情况不适用。\n2.  如果新选手（Emily）输给了路径中的最后一个人（Chloe），则将她放在最后面。Emily 战胜了 Chloe，所以此情况不适用。\n3.  否则，从路径的开头开始寻找，找到第一个选手 $P_j$ 使得 Emily 输给了 $P_j$ 但战胜了紧随其后的选手 $P_{j+1}$。然后将 Emily 插入到 $P_j$ 和 $P_{j+1}$ 之间。\n\n让我们应用这个算法：\n-   路径是：$P_1$=Ben, $P_2$=Anna, $P_3$=David, $P_4$=Chloe。\n-   我们检查 Emily 与路径上相邻选手对的比赛结果。\n-   **对 (Ben, Anna)**：Emily 输给了 Ben，也输给了 Anna。她没有战胜 Anna，所以不能插入此处。\n-   **对 (Anna, David)**：Emily 输给了 Anna，但战胜了 David。这符合我们的条件（在 $P_2$ Anna 和 $P_3$ David 之间）。\n\n因此，我们将 Emily 插入到 Anna 和 David 之间。\n\n新的优势排名（哈密顿路径）是：(Ben, Anna, Emily, David, Chloe)。\n\n这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1402599"}]}