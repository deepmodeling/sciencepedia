{"hands_on_practices": [{"introduction": "我们将从最简单的形式——在一个小的有限集合上——开始探索恒等函数。这个练习可以帮助你巩固恒等函数以及一个密切相关概念——对合（即一个函数是其自身的逆函数）的定义 [@problem_id:1375094]。通过处理具体的例子，你将学会区分恒等映射和其他自我复合后也得到恒等映射的函数。", "problem": "设 $S = \\{a, b, c\\}$ 是一个集合。一个函数 $f: S \\to S$ 如果是其自身的逆，则称其为*对合*。这意味着对于每个元素 $x \\in S$，该函数与自身的复合会返回原始元素，即 $f(f(x)) = x$。\n\n$S$ 上的恒等函数，记为 $\\text{id}_S$，定义为对于所有 $x \\in S$ 都有 $\\text{id}_S(x) = x$。恒等函数是对合的一个例子。\n\n考虑以下从 $S$ 到 $S$ 的函数，每个函数都通过列出其有序对 $(x, y)$ 的集合来定义，其中 $y = f(x)$。以下哪个函数是对合但**不是**恒等函数？\n\nA. $f_A = \\{(a, a), (b, b), (c, c)\\}$\n\nB. $f_B = \\{(a, b), (b, c), (c, a)\\}$\n\nC. $f_C = \\{(a, c), (b, b), (c, a)\\}$\n\nD. $f_D = \\{(a, b), (b, b), (c, b)\\}$", "solution": "$S=\\{a,b,c\\}$ 上的对合满足对于每个 $x\\in S$ 都有 $f(f(x))=x$。我们通过计算所有 $x$ 的 $f(f(x))$ 来检查每个选项，并验证该函数是否等于恒等函数。\n\n- 对于 A：$f_{A}=\\{(a,a),(b,b),(c,c)\\}$ 给出对于所有 $x$ 都有 $f_{A}(x)=x$，所以对于所有 $x$ 都有 $f_{A}(f_{A}(x))=x$。因此 $f_{A}$ 是一个对合，但它正是恒等函数，所以它不满足“不是恒等函数”的要求。\n\n- 对于 B：$f_{B}(a)=b$, $f_{B}(b)=c$, $f_{B}(c)=a$。则 $f_{B}(f_{B}(a))=f_{B}(b)=c\\neq a$，所以 $f_{B}$ 不是一个对合。\n\n- 对于 C：$f_{C}(a)=c$, $f_{C}(b)=b$, $f_{C}(c)=a$。则 $f_{C}(f_{C}(a))=f_{C}(c)=a$，$f_{C}(f_{C}(b))=f_{C}(b)=b$，以及 $f_{C}(f_{C}(c))=f_{C}(a)=c$。因此对于所有 $x$ 都有 $f_{C}(f_{C}(x))=x$，所以 $f_{C}$ 是一个对合。此外，$f_{C}(a)=c\\neq a$，所以它不是恒等函数。\n\n- 对于 D：$f_{D}(a)=b$, $f_{D}(b)=b$, $f_{D}(c)=b$。则 $f_{D}(f_{D}(a))=f_{D}(b)=b\\neq a$，所以 $f_{D}$ 不是一个对合。\n\n因此，唯一是对合但不是恒等函数的选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1375094"}, {"introduction": "恒等函数最重要的作用之一是定义逆函数。如果函数 $f$ 和 $g$ 的复合 $g \\circ f$ 结果为恒等函数，那么函数 $g$ 就是 $f$ 的逆函数。本练习模拟了一个现实世界中的编码和解码场景，让你亲手实践如何为一个给定函数寻找其逆函数 [@problem_id:1375117]。", "problem": "在一个安全的数据传输系统中，一个数字信号经过两个阶段的处理。第一阶段是“编码器”，第二阶段是“解码器”。编码器是一个函数 $f: \\mathbb{R} \\to \\mathbb{R}$，它根据规则 $f(x) = 8x^3 - 1$ 来转换输入的实数 $x$。第二阶段是解码器，它是另一个函数 $g: \\mathbb{R} \\to \\mathbb{R}$。\n\n为使系统正常工作，将解码器函数应用于编码器函数的输出必须能完美地恢复原始输入信号。这个要求意味着这两个函数的复合 $(g \\circ f)$ 必须等价于实数集上的恒等函数。恒等函数，记为 $id_{\\mathbb{R}}$，定义为对所有 $x \\in \\mathbb{R}$ 都有 $id_{\\mathbb{R}}(x) = x$。\n\n给定编码函数 $f(x)$，确定相应的解码函数 $g(x)$ 的数学表达式，使其对所有实数 $x$ 都满足条件 $(g \\circ f)(x) = x$。", "solution": "我们需要一个解码器函数 $g:\\mathbb{R}\\to\\mathbb{R}$，使得对所有 $x\\in\\mathbb{R}$ 都有 $(g\\circ f)(x)=x$，其中 $f(x)=8x^{3}-1$。这意味着 $g$ 必须是 $f$ 的反函数。\n\n为了求反函数，设 $y=f(x)=8x^{3}-1$ 并解出关于 $y$ 的 $x$：\n$$\ny+1=8x^{3},\n$$\n$$\n\\frac{y+1}{8}=x^{3},\n$$\n$$\nx=\\sqrt[3]{\\frac{y+1}{8}}.\n$$\n因此，反函数是 $g(y)=\\sqrt[3]{\\frac{y+1}{8}}$。重命名输入变量，我们写成\n$$\ng(x)=\\sqrt[3]{\\frac{x+1}{8}}.\n$$\n验证：\n$$\n(g\\circ f)(x)=g(8x^{3}-1)=\\sqrt[3]{\\frac{(8x^{3}-1)+1}{8}}=\\sqrt[3]{\\frac{8x^{3}}{8}}=\\sqrt[3]{x^{3}}=x,\n$$\n这对所有实数 $x$ 都成立。因此，这个 $g$ 满足所要求的条件。", "answer": "$$\\boxed{\\sqrt[3]{\\frac{x+1}{8}}}$$", "id": "1375117"}, {"introduction": "除了在定义逆函数中的作用外，恒等函数在函数复合中还是一个关键的“中性元素”，就像 $0$ 是加法的单位元或 $1$ 是乘法的单位元一样。这个练习将让你扮演系统设计者的角色，在一个数据处理流程中使用恒等函数作为“直通”或“检查点”步骤，从而展示其在复杂系统中的实际效用 [@problem_id:1375056]。", "problem": "一个数据处理系统操作三种类型的数据：整数（用集合 $\\mathbb{Z}$ 表示）、字符串（用 $S$ 表示）和布尔值（用 $B$ 表示）。该系统使用一组预定义的基本转换函数：\n- `encode: \\mathbb{Z} \\to S`，将一个整数转换为其字符串表示。\n- `validate: S \\to B`，如果输入字符串是有效令牌则返回 `true`，否则返回 `false`。\n- `quantify: B \\to \\mathbb{Z}`，将 `true` 映射到整数 `1`，将 `false` 映射到整数 `0`。\n\n一个名为 `pipeline_A` 的标准处理管道被定义为这些函数的复合，用于转换初始的整数输入。该管道定义为 `pipeline_A = quantify \\circ validate \\circ encode`。\n\n为了调试和记录日志，该系统还包括三个恒等函数，每种数据类型各一个：\n- `pass_Z: \\mathbb{Z} \\to \\mathbb{Z}`，其中对于任意整数 $x$，`pass_Z(x) = x`。\n- `pass_S: S \\to S`，其中对于任意字符串 $x$，`pass_S(x) = x`。\n- `pass_B: B \\to B`，其中对于任意布尔值 $x$，`pass_B(x) = x`。\n\n现在引入一个新需求：必须创建一个修订版的管道，名为 `pipeline_B`。这个新管道必须执行与 `pipeline_A` 完全相同的转换，但增加了一个“检查点”步骤。该检查点步骤必须在 `validate` 函数产生其布尔输出之后、任何后续处理之前立即发生。检查点是通过将数据传递给该数据类型的相应恒等函数来实现的。\n\n以下哪个表达式正确地表示了 `pipeline_B`？\n\nA. `quantify \\circ validate \\circ pass_S \\circ encode`\n\nB. `pass_Z \\circ quantify \\circ validate \\circ encode`\n\nC. `quantify \\circ pass_B \\circ validate \\circ encode`\n\nD. `quantify \\circ validate \\circ encode \\circ pass_Z`\n\nE. `pass_B \\circ quantify \\circ validate \\circ encode`", "solution": "给定三个带类型的基本函数：\n- $\\,\\mathrm{encode}:\\mathbb{Z}\\to S$，\n- $\\,\\mathrm{validate}:S\\to B$，\n- $\\,\\mathrm{quantify}:B\\to \\mathbb{Z}$。\n\n函数复合的定义为，对于 $f:Y\\to Z$ 和 $g:X\\to Y$，有 $(f\\circ g)(x)=f(g(x))$。\n\n标准管道是\n$$\n\\mathrm{pipeline\\_A}=\\mathrm{quantify}\\circ \\mathrm{validate}\\circ \\mathrm{encode}:\\mathbb{Z}\\to \\mathbb{Z},\n$$\n其类型流为 $\\mathbb{Z}\\xrightarrow{\\mathrm{encode}}S\\xrightarrow{\\mathrm{validate}}B\\xrightarrow{\\mathrm{quantify}}\\mathbb{Z}$。\n\n恒等函数是：\n- $\\mathrm{pass\\_Z}:\\mathbb{Z}\\to\\mathbb{Z}$，对于所有 $z\\in\\mathbb{Z}$，有 $\\mathrm{pass\\_Z}(z)=z$，\n- $\\mathrm{pass\\_S}:S\\to S$，对于所有 $s\\in S$，有 $\\mathrm{pass\\_S}(s)=s$，\n- $\\mathrm{pass\\_B}:B\\to B$，对于所有 $b\\in B$，有 $\\mathrm{pass\\_B}(b)=b$。\n\n要求是在 $\\mathrm{validate}$ 产生布尔值之后、任何后续处理之前立即插入一个检查点。由于 $\\mathrm{validate}$ 的输出类型为 $B$，因此适当的恒等函数是 $\\mathrm{pass\\_B}:B\\to B$。因此，修订后的管道必须是\n$$\n\\mathrm{pipeline\\_B}=\\mathrm{quantify}\\circ \\mathrm{pass\\_B}\\circ \\mathrm{validate}\\circ \\mathrm{encode}.\n$$\n\n为了验证其正确性以及与 $\\mathrm{pipeline\\_A}$ 的等价性，对于任意 $x\\in\\mathbb{Z}$，\n$$\n\\mathrm{pipeline\\_B}(x)\n=\\mathrm{quantify}\\big(\\mathrm{pass\\_B}(\\mathrm{validate}(\\mathrm{encode}(x)))\\big)\n=\\mathrm{quantify}\\big(\\mathrm{validate}(\\mathrm{encode}(x))\\big)\n=\\mathrm{pipeline\\_A}(x),\n$$\n这里使用了恒等定律 $\\mathrm{pass\\_B}(b)=b$（对于所有 $b\\in B$）。\n\n现在与选项进行匹配：\n- A: $\\mathrm{quantify}\\circ \\mathrm{validate}\\circ \\mathrm{pass\\_S}\\circ \\mathrm{encode}$ 在 $\\mathrm{encode}$ 和 $\\mathrm{validate}$ 之间插入 $\\mathrm{pass\\_S}$，而不是在 $\\mathrm{validate}$ 之后。\n- B: $\\mathrm{pass\\_Z}\\circ \\mathrm{quantify}\\circ \\mathrm{validate}\\circ \\mathrm{encode}$ 在 $\\mathrm{quantify}$ 之后插入，而不是在 $\\mathrm{validate}$ 之后。\n- C: $\\mathrm{quantify}\\circ \\mathrm{pass\\_B}\\circ \\mathrm{validate}\\circ \\mathrm{encode}$ 恰好在 $\\mathrm{validate}$ 之后和 $\\mathrm{quantify}$ 之前插入 $\\mathrm{pass\\_B}$，且类型正确。\n- D: $\\mathrm{quantify}\\circ \\mathrm{validate}\\circ \\mathrm{encode}\\circ \\mathrm{pass\\_Z}$ 在 $\\mathrm{encode}$ 之前插入，而不是在 $\\mathrm{validate}$ 之后。\n- E: $\\mathrm{pass\\_B}\\circ \\mathrm{quantify}\\circ \\mathrm{validate}\\circ \\mathrm{encode}$ 类型不匹配，因为 $\\mathrm{quantify}$ 的输出类型为 $\\mathbb{Z}$，但 $\\mathrm{pass\\_B}$ 的输入类型要求为 $B$。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1375056"}]}