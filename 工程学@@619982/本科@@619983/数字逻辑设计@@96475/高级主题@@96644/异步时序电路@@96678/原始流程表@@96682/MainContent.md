## 引言
在数字逻辑的世界里，[同步电路](@article_id:351527)依靠全局时钟的节拍来协调运作，如同纪律严明的军队。然而，当输入信号的到来时间不可预测时，我们需要一种更为灵活、更具适应性的设计[范式](@article_id:329204)——[异步电路](@article_id:348393)。这些电路如何能在没有统一指挥的情况下，可靠地响应和处理来自外部世界的突发事件？这正是[原始流程表](@article_id:347369)（Primitive Flow Table）所要解决的核心问题。

本文将作为一份全面的指南，带领读者深入探索[原始流程表](@article_id:347369)的理论与实践。我们将从第一章“核心概念”开始，解构流程表的内部工作原理，理解稳定状态、状态跃迁以及[竞争风险](@article_id:352378)等基本要素。接着，在第二章“应用与跨学科连接”中，我们将见证这一理论如何转化为现实世界中的功能模块，从简单的存储器到复杂的通信仲裁器。最后，通过一系列“动手实践”案例，您将有机会将所学知识付诸实践，解决真实的设计挑战。现在，让我们首先步入异步逻辑的动态世界，揭开其核心概念的神秘面纱。

## 核心概念

想象一下，你想为一支舞蹈编舞。你不会只列出最终的舞姿，你会详细描述舞姿*之间*的衔接动作。[原始流程表](@article_id:347369)（primitive flow table）对于[异步电路](@article_id:348393)来说，正是这样一份编舞手稿。它不是一张静态的清单，而是一个动态的脚本，一部关于逻辑的编舞作品。

表中的每一行代表一个“舞姿”——电路可以保持的稳定状态。每一列代表一种不同的“音乐”或“提示”——来自外部世界的输入信号组合。而表中的条目就是指令：“处于这个舞姿，当听到这段音乐时，移动到*那个*舞姿。”

### 稳定：万物之核心

那么，是什么让一个“舞姿”变得“稳定”呢？很简单：这是一种平衡状态。如果电路处于一个我们称之为 $A$ 的状态，而输入信号恰好是 $0$，流程表可能会告诉它：“保持在状态 $A$”。这就是一个**稳定状态**。在这种状态和输入的组合下，电路没有改变的意图。我们找到了一个歇脚点，一个[平衡点](@article_id:323137)。[@problem_id:1953737]

你可以扫描整个流程表，将所有这些歇脚点圈出来。在某些电路中，你可能只会找到几个；而在另一些电路中，你可能会发现很多。数一数稳定状态的总数，是理解一个电路“静态”行为能力的第一步。[@problem_id:1953713] 这些被圈起来的条目就像地形图上的山谷；一个放在那里的小球会安然不动。

### 旅程：从不稳定到稳定

但当“音乐”改变时会发生什么呢？输入信号翻转了。我们的电路，原本在输入为 $0$ 的情况下舒适地待在状态 $A$，突然间看到了输入变成了 $1$。它会立刻查阅流程表。在（状态 $A$，输入 $1$）这个单元格里，指令不再是“保持在状态 $A$”，而可能变成了“去状态 $B$”。

此刻，电路进入了一个**[不稳定状态](@article_id:376114)**。它失去了平衡。就好像整个地形倾斜了，我们的小球开始滚动。它向状态 $B$ 跃迁。接下来呢？电路会再次查阅流程表，此时输入仍然是新的信号 $1$。也许（状态 $B$，输入 $1$）的指令是：“去状态 $C$”。小球还没到达山谷，它继续滚动。最后，它到达了状态 $C$。它再次查阅流程表：（状态 $C$，输入 $1$）的指令是：“保持在状态 $C$”。啊哈！它终于找到了一个新的山谷，一个新的稳定状态，旅程就此结束。[@problem_id:1953708] [@problem_id:1953728]

这个从初始稳定状态开始，经过一个或多个[不稳定状态](@article_id:376114)，最终到达一个新的稳定状态的跃迁序列，正是这种电路的基础运算方式。这就是它“思考”和“计算”的过程。我们可以追踪它在一连串输入变化中的完整路径，观察它如何从一个稳定的姿态“舞动”到下一个。 [@problem_id:1953736]

### 输出：电路如何“发声”

在所有这些“舞蹈”进行的同时，电路还可以产生输出。它在与外部世界沟通。它如何决定要“说”什么，引出了一个重要的分类。

在某些电路中，输出*仅仅*取决于当前的内部状态。如果它处于状态 $C$，无论是什么输入信号让它来到这里，它的输出可能永远是 $1$。这种电路被称为**摩尔（Moore）型[状态机](@article_id:350510)**。它的输出就像一种心态或情绪，与自身状态绑定。

而在另一些电路中，输出同时取决于状态*和*当前的输入。在状态 $B$ 时，对于输入 $01$，输出可能是 $0$；但对于输入 $11$，输出可能会翻转成 $1$。这种电路被称为**米利（Mealy）型状态机**。它的输出更像是在直接回答一个问题。通过观察流程表同一行内输出值的变化，你就能立刻判断出你面对的是哪种类型的机器。[@problem_id:1953714]

### 游戏规则：基本模式假设

你可能会注意到，我们的编舞手稿——流程表——经常有一些空白格，通常用短划线（`-`）表示。这是错误吗？是遗漏的舞步吗？完全不是。它们的存在背后有一个非常深刻的理由。

我们与外部世界达成了一个“君子协定”，称为**[基本模式](@article_id:344550)假设（fundamental mode assumption）**：在任意时刻，只允许一个输入信号发生变化。如果当前输入是 $01$，那么下一个合法的输入可以是 $00$ 或 $11$，但*绝不能*是 $10$。为什么？因为要让两个输入在完全相同的时刻改变，需要完美的[同步](@article_id:339180)，这在物理上几乎是不可能的。总有一个信号会比另一个早变动几纳秒。

因此，从 $01$ 到 $10$ 的这种跃迁在我们的假设下被视为“不可能发生”的事件。既然一个跃迁不可能发生，我们自然也无需为它设计响应。我们把它标记为“[无关项](@article_id:344644)（don't care）”。这个巧妙的假设极大地简化了我们的设计任务，让我们能够忽略大量潜在（但不切实际）的场景。[@problem_id:1953709]

### 打破规则：竞争的风险与玄机

但是，如果这个“君子协定”被打破了呢？如果（尽管不太可能）两个输入信号*确实*试图同时改变呢？电路现在就陷入了困境。它先“看到”哪个变化？从 $00$ 到 $11$ 的变化，可能被电路解读为 $00 \to 01 \to 11$，也可能被解读为 $00 \to 10 \to 11$。

这就是**输入竞争（input race）**。如果这两条不同的路径最终导向了不同的稳定状态，那么电路的行为就变得不可预测。它可能最终停在状态 $c$，也可能停在状态 $e$，完全取决于电路走线延迟的微小差异。其结果就是[歧义](@article_id:340434)——这对于一个逻辑电路来说是灾难性的。[@problem_id:1953721]

### 内部竞争：电路与自身的赛跑

更微妙的是，即使输入变化完全合法，竞争也可能在电路*内部*发生。当电路需要从一个由二进制编码 $00$ 代表的状态（比如状态 $p$）跃迁到由 $11$ 代表的状态（比如状态 $q$）时，问题就出现了。状态的两个比特位都必须翻转。但是，哪一个先翻转呢？

[状态变量](@article_id:299238)本身陷入了一场竞赛。

有时，这场竞赛是无害的。想象一下，有两条上山的路，但都通向同一个山顶。如果中间状态（无论是 $01$ 还是 $10$）最终都将电路引导到同一个终点（$11$），那么这场竞争就是**[非关键竞争](@article_id:347213)（non-critical race）**。即使路径不确定，结果依然是可靠的。[@problem_id:1953725]

但是，如果其中一条路径通向了另一个完全不同的山谷——例如，先改变一个比特导致电路走向稳定状态 $r$，而先改变另一个比特则走向稳定状态 $q$——我们就遇到了**关键竞争（critical race）**。[@problem_id:1953690] 电路的最终状态，现在完全取决于其内部逻辑门纳秒级别的时序差异。逻辑本身被破坏了。这正是[异步电路设计](@article_id:351304)的巨大挑战：如何为[状态分配](@article_id:351787)合理的二进制编码，以避免这些灾难性的内部竞争，确保所有状态跃迁要么是明确的单步变化（汉明距离为 $1$），要么是无害的[非关键竞争](@article_id:347213)。