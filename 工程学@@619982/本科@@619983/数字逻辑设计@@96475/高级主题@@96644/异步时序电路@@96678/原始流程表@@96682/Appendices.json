{"hands_on_practices": [{"introduction": "让我们从一个经典的设计问题入手：边缘触发的触发器。这个练习的核心在于，电路必须“记住”其当前的输出状态，以便在下一次输入信号 $x$ 改变时进行翻转。通过这个实践 [@problem_id:1953742]，你将亲身体会到为什么内部状态对于捕捉和维持电路的历史信息至关重要，即使在最简单的场景中也是如此。", "problem": "一个异步时序电路有一个单输入 $x$ 和一个单输出 $z$。该电路被设计为一个边沿触发的翻转器件。具体来说，对于输入线 $x$ 上的任何变化（从 $0$ 到 $1$ 或从 $1$ 到 $0$），输出 $z$ 都必须翻转其当前值。例如，如果 $z$ 当前为 $0$， $x$ 的下一次变化将导致 $z$ 变为 $1$。随后 $x$ 的变化将导致 $z$ 变为 $0$，依此类推。\n\n假设该电路由一个原始流程表描述，其中每一行恰好包含一个稳定状态，请确定完整描述此行为所需的稳定状态总数。", "solution": "设输入为 $x \\in \\{0,1\\}$，输出为 $z \\in \\{0,1\\}$。对于一个单输入的异步时序电路的原始流程表，每个稳定状态都与一个确切的输入值相关联（即该状态在其中稳定的唯一列）。因此，对于任何稳定状态 $s$，都存在一个确切的 $i_{s} \\in \\{0,1\\}$，使得当 $x=i_{s}$ 时 $s$ 是稳定的。\n\n设计要求是一个边沿触发的翻转：每当 $x$ 发生变化时（无论是 $0 \\to 1$ 还是 $1 \\to 0$），输出都必须翻转。如果 $z$ 表示变化前的输出，那么变化后输出必须为\n$$\nz^{+} = 1 - z.\n$$\n当 $x$ 保持不变时（无变化），输出必须保持其当前值。\n\n考虑这对稳定状态集合 $S$ 的影响：\n- 在任何稳定状态 $s \\in S$ 中，当输入 $x=i_{s}$ 保持不变时，输出必须保持在一个固定值 $z_{s} \\in \\{0,1\\}$。\n- 当 $x$ 从 $i_{s}$ 变为 $1-i_{s}$ 时，机器必须转换到在新输入下稳定的状态，并且在该新状态下，输出必须是 $1 - z_{s}$。\n\n我们现在来证明 $|S|$ 的一个下界。\n- 假设 $|S|=2$，以导出矛盾。那么，存在一个状态 $s_{0}$，它在 $x=0$ 时稳定，输出为 $z_{0}$；以及一个状态 $s_{1}$，它在 $x=1$ 时稳定，输出为 $z_{1}$。每当 $x=1$ 保持不变时，电路必须处于 $s_{1}$ 状态，因此无论历史如何，输出都被强制为 $z_{1}$。然而，翻转的要求是，当 $x=1$ 保持不变时，根据已发生的输入变化的次数的奇偶性，输出值 0 和 1 都必须是可达到的（因为每次变化都会翻转 $z$）。对于 $x=1$ 只有一个具有固定输出 $z_{1}$ 的状态 $s_{1}$，这是不可能实现的。因此 $|S| \\geq 4$。\n\n我们现在给出一个恰好有四个稳定状态的构造，以证明其充分性。定义四个稳定状态，它们通过输入稳定性和输出值来区分：\n- $A_{0}$：在 $x=0$ 时稳定，输出 $z=0$。\n- $A_{1}$：在 $x=0$ 时稳定，输出 $z=1$。\n- $B_{0}$：在 $x=1$ 时稳定，输出 $z=0$。\n- $B_{1}$：在 $x=1$ 时稳定，输出 $z=1$。\n\n状态转换定义如下：\n- 如果输入保持不变，机器停留在同一状态（原始流程表中的唯一稳定列）。\n- 当 $x$ 从 $0$ 变为 $1$ 时，翻转 $z$ 并从 $A_{0} \\to B_{1}$ 以及 $A_{1} \\to B_{0}$ 进行转移。\n- 当 $x$ 从 $1$ 变为 $0$ 时，翻转 $z$ 并从 $B_{0} \\to A_{1}$ 以及 $B_{1} \\to A_{0}$ 进行转移。\n\n这满足了在每次输入变化时 $z^{+} = 1 - z$ 并且在 $x$ 恒定时保持 $z$ 不变的要求，同时每个状态只有一个稳定输入，符合原始流程表的规定。因此，所需的最少且足够的稳定状态数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "1953742"}, {"introduction": "掌握了单输入电路后，让我们将挑战升级到多输入系统，并解决一个关键的工程问题：可靠性。异步电路设计通常依赖于“基本模式”假设，即一次只有一个输入发生变化。此练习 [@problem_id:1953732] 让你构建一个故障检测器，专门用于捕捉当输入 $X_1$ 和 $X_2$ 同时改变时的违规行为，并使电路进入一个不可恢复的“陷阱状态”。这展示了如何利用原始流程表来设计对非法输入具有鲁棒性的系统。", "problem": "一个异步时序电路被设计为在基本模式下运行。它有两个二进制输入，$X_1$ 和 $X_2$，以及一个单一输出，$E$。\n\n在正常操作下，任何时候只允许一个输入发生变化。在下一次输入变化发生之前，电路有足够的时间转换到一个新的稳定状态。该电路的目的是作为一个故障检测器。如果两个输入 $X_1$ 和 $X_2$ 同时改变其值（例如，从 $X_1X_2 = 00$ 转换到 $11$，或者从 $X_1X_2 = 01$ 转换到 $10$），电路必须转换到一个唯一的、永久的错误状态。\n\n对于所有正常操作状态，输出 $E$ 定义为 $0$，对于错误状态，输出 $E$ 定义为 $1$。一旦电路进入错误状态，无论后续输入如何变化，它都必须无限期地保持在该状态。\n\n假设在正常的、非错误操作期间，电路必须能够对四种可能的输入组合（$00, 01, 10, 11$）中的任何一种保持稳定。原始流程表是一种状态转换表，其中每一行代表一个唯一的内部状态，并且每一行只包含一个稳定状态项（终端“陷阱”状态可以是个例外，它可能对多个或所有输入都稳定）。\n\n要为这个故障检测器指定完整的原始流程表，最少需要多少行（即总的内部状态数），包括错误状态？", "solution": "由于电路在基本模式下运行，正常操作下每次只有一个输入变化，并且电路在下一次变化前会稳定下来。在原始流程表中，每个内部状态（行）只有一个稳定的输入列；只有一个终端陷阱（错误）状态才被允许多个输入下都稳定。\n\n要求1（正常稳定性）：在正常的、非错误操作期间，机器必须能够对四种输入组合 $00,01,10,11$ 中的每一种都保持稳定，且输出 $E=0$。由于原始流程表中的每一行只能有一个稳定的输入，要实现对所有四种输入组合的稳定，至少需要四个不同的正常内部状态，每种输入组合对应一个。因此，正常操作状态至少需要 $4$ 行。\n\n要求2（永久性错误）：必须有一个唯一的永久性错误状态，输出为 $E=1$。当两个输入同时变化时（从 $00$ 到 $11$ 或从 $01$ 到 $10$），机器进入此状态。一旦进入，无论输入如何变化，它都必须保持该状态，因此它必须是一个对所有四种输入都稳定的陷阱状态。这个错误状态不能与任何正常状态合并，因为正常状态的输出必须为 $E=0$，且每个正常状态行只能对单个输入稳定。因此，错误陷阱至少需要额外的一行。\n\n下限：综合以上分析，至少需要 $4+1=5$ 行。\n\n用 $5$ 行的可实现性：使用四个正常行，每个行恰好在 $00,01,10,11$ 的一个输入下稳定，以及一个对所有输入都稳定的错误陷阱行。定义状态转换，使得从一个正常状态出发，单个比特的输入变化直接转换到相应的相邻正常状态（保持正常行为），而两个比特的变化（非相邻输入）则转换到错误陷阱。这满足了规范要求，并且只使用了 $5$ 行。\n\n因此，包括错误状态在内，所需的最小行数（总内部状态数）是 $5$。", "answer": "$$\\boxed{5}$$", "id": "1953732"}, {"introduction": "最后的挑战将我们带入更复杂的异步设计领域：资源仲裁。在这个后进先出（LIFO）仲裁器问题中，电路的状态不仅取决于哪些请求（$R_2, R_1, R_0$）处于活动状态，更关键的是它们被断言的*顺序*。这个练习 [@problem_id:1953743] 深刻地揭示了电路的“历史”如何直接转化为状态空间的大小，你将计算出，对于一个固定的输入组合，仅因事件发生顺序不同，就需要多少个不同的稳定状态来正确表示其行为。", "problem": "需要设计一个异步三输入抢占式后进先出（LIFO）仲裁器。该仲裁器有三个请求输入 $R_2, R_1, R_0$ 和三个相应的授权输出 $G_2, G_1, G_0$。其行为由以下规则定义：\n\n1.  初始时，系统处于空闲状态，没有请求有效，也没有发出授权。输出向量 $(G_2, G_1, G_0)$ 为 $(0,0,0)$。\n2.  授权被颁发给最近被置为有效的请求。同一时间只能有一个授权有效。对请求 $R_i$ 的有效授权由输出向量表示，其中只有第 $i$ 个分量为 1（例如，$G_1=1$ 对应于 $(0,1,0)$）。\n3.  如果在另一个请求 $R_{old}$ 当前持有授权时，一个新的请求 $R_{new}$ 被置为有效，则 $R_{new}$ 会抢占 $R_{old}$ 并获得授权。被抢占的请求 $R_{old}$ 被推入一个由被抢占请求组成的LIFO堆栈中。\n4.  当当前获得授权的请求被撤销时，授权将传递给抢占堆栈顶部的请求（即最近被抢占的请求），前提是该请求仍然有效。这实际上是将该请求从堆栈中“弹出”。\n5.  如果一个请求从堆栈中弹出但已不再有效，仲裁器会尝试将授权授予堆栈中的下一个请求，并持续此过程，直到发出一个授权或堆栈为空。如果堆栈变空，仲裁器返回到空闲状态。\n6.  如果一个当前在抢占堆栈上（但未持有授权）的请求被撤销，它将直接从其在堆栈中的位置被移除，而不影响当前的授权持有者。\n\n假设一次只有一个输入可以改变，可以构建一个原始流程表来描述电路的行为。每个唯一的抢占序列对应一个唯一的内部状态。对于一个给定的输入组合，可能存在多个稳定状态，每个状态对应于不同的请求到达历史。\n\n对于任何单个输入组合 $(R_2, R_1, R_0)$，可能存在的不同稳定状态的最大数量是多少？", "solution": "我们通过有效请求的集合来为一个固定的输入组合的行为建模。令 $S \\subseteq \\{R_{2},R_{1},R_{0}\\}$ 为在给定输入向量 $(R_{2},R_{1},R_{0})$ 下当前有效的请求子集，并令 $k=|S| \\in \\{0,1,2,3\\}$。\n\n根据规则：\n- 当 $k \\geq 1$ 时，恰好有一个授权是有效的，即针对 $S$ 中最近被置为有效的请求。\n- 抢占堆栈以“后进先出”的顺序包含其他有效的请求，并且任何被撤销的请求都会被立即移除（因此堆栈只包含仍然有效的请求）。\n- 对于固定的输入（没有进一步的变化），不会发生状态转换；因此，稳定性完全由当前有效请求的到达历史决定。\n\n因此，对于一个给定的、有 $k$ 个不同请求有效的集合 $S$，这 $k$ 个请求的每一种可能的到达顺序（抢占序列）都会产生一个不同的内部状态：顺序中最近的那个持有授权，而其余的 $k-1$ 个以LIFO顺序占据堆栈。问题陈述证实了每个唯一的抢占序列都对应一个唯一的内部状态，因此，对于有 $k$ 个有效请求的固定输入，不同稳定状态的数量恰好是\n$$\nk!.\n$$\n为了找到在所有输入组合中的最大值，我们在 $k \\leq 3$ 的约束下最大化 $k!$。这在 $k=3$ 时（即所有三个请求都有效时）发生，得出\n$$\n3! = 6.\n$$\n因此，对于任何单个输入组合，不同稳定状态的最大数量是 $6$。", "answer": "$$\\boxed{6}$$", "id": "1953743"}]}