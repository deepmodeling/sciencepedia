{"hands_on_practices": [{"introduction": "将理论付诸实践的第一步是了解如何根据设计需求确定只读存储器（ROM）的规格。这个练习将带你完成一个基本但至关重要的计算任务：根据一个组合逻辑电路的输入和输出数量，确定实现它所需的最小 ROM 容量。通过解决这个问题 [@problem_id:1956906]，你将牢固掌握 ROM 容量与其地址线（输入）和数据线（输出）宽度之间的关系，即容量等于 $2^n \\times m$。", "problem": "在为物联网（IoT）设备设计一款定制微控制器时，一个关键组件是指令解码器。该解码器作为一个组合逻辑电路，负责解释要执行的操作。该解码器从指令寄存器接收一个4位操作码作为其输入。基于这个操作码，它会生成3个不同的控制信号，并发送到微控制器的算术逻辑单元（ALU）。\n\n为了简化硬件设计并通过固件更新实现可能的修改，一位工程师决定使用单个只读存储器（ROM）来实现这整个解码器逻辑。\n\n确定要完全实现所述解码器功能所需的该ROM的最小总存储容量。答案以比特为单位表示。", "solution": "用于实现组合解码器的只读存储器，会为每一种可能的输入组合存储相应的输出字。如果输入宽度为 $n$ 位，输出宽度为 $m$ 位，那么地址数量为 $2^{n}$，每个地址存储 $m$ 位，因此总存储容量（以比特为单位）为\n$$C=2^{n}\\cdot m.$$\n在此问题中，操作码宽度为 $n=4$，控制信号的数量为 $m=3$，因此\n$$C=2^{4}\\cdot 3=16\\cdot 3=48\\ \\text{bits}.$$\n因此，所需的最小总存储容量为 $48$ 比特。", "answer": "$$\\boxed{48}$$", "id": "1956906"}, {"introduction": "掌握了如何计算 ROM 的大小之后，下一步就是学习如何“编程”它，即将特定的逻辑功能转化为存储在其中的数据。本练习 [@problem_id:1956845] 提供了一个绝佳的实例，要求你为一个 4 位输入质数检测器确定 ROM 中存储的完整 16 位数据内容。这让你亲身体验将一个数学或逻辑规则（什么是质数）直接映射为硬件中的二进制查找表，从而深化对 ROM 作为通用组合逻辑实现工具的理解。", "problem": "一位数字系统工程师的任务是为一个小型专用逻辑设备编程。该设备是一个16x1的只读存储器 (ROM)，它有4条地址线和1条数据输出线。这4条地址线接受一个4位无符号整数，我们记作 $N$，对应于十进制值0到15。这个ROM需要被编程以实现一个素数检测器的功能。如果输入的整数 $N$ 是一个素数，则单条数据线应输出逻辑'1'，否则输出逻辑'0'。根据标准的数学定义，整数0和1不被认为是素数。\n\n您的任务是确定必须存储在该ROM中的完整的16位数据内容，以实现所需的功能。请将您的最终答案以一个16位二进制字符串的形式呈现，其中最左边的位对应于存储在地址0的数据，下一位对应于地址1的数据，以此类推，直到最右边的位对应于地址15的数据。", "solution": "该ROM的地址由 $N \\in \\{0,1,\\dots,15\\}$ 标记。当且仅当 $N$ 是素数时，输出位为 $1$。根据定义，如果一个整数大于1，并且除了1和它自身以外没有其他正因数，那么它就是素数。因此，0和1不是素数，所以 $b_{0}=0$ 且 $b_{1}=0$。\n\n对于 $N \\geq 2$，测试其是否能被从 $2$ 到 $\\lfloor \\sqrt{N} \\rfloor$ 的整数整除：\n- $N=2$: 在 $[2,\\lfloor \\sqrt{2} \\rfloor]$ 区间内没有整数，因此是素数 $\\Rightarrow b_{2}=1$。\n- $N=3$: 在 $[2,\\lfloor \\sqrt{3} \\rfloor]$ 区间内没有整数，因此是素数 $\\Rightarrow b_{3}=1$。\n- $N=4$: 可被2整除，是合数 $\\Rightarrow b_{4}=0$。\n- $N=5$: 不能被2整除，是素数 $\\Rightarrow b_{5}=1$。\n- $N=6$: 可被2整除，是合数 $\\Rightarrow b_{6}=0$。\n- $N=7$: 不能被2或3整除，是素数 $\\Rightarrow b_{7}=1$。\n- $N=8$: 可被2整除，是合数 $\\Rightarrow b_{8}=0$。\n- $N=9$: 可被3整除，是合数 $\\Rightarrow b_{9}=0$。\n- $N=10$: 可被2整除，是合数 $\\Rightarrow b_{10}=0$。\n- $N=11$: 不能被2或3整除，是素数 $\\Rightarrow b_{11}=1$。\n- $N=12$: 可被2整除，是合数 $\\Rightarrow b_{12}=0$。\n- $N=13$: 不能被2或3整除，是素数 $\\Rightarrow b_{13}=1$。\n- $N=14$: 可被2整除，是合数 $\\Rightarrow b_{14}=0$。\n- $N=15$: 可被3（和5）整除，是合数 $\\Rightarrow b_{15}=0$。\n\n因此，在集合 $\\{0,1,\\dots,15\\}$ 中的素数是 $\\{2,3,5,7,11,13\\}$，其映射关系为：\n$$\nb_{N}=\\begin{cases}\n1, & N \\in \\{2,3,5,7,11,13\\},\\\\\n0, & \\text{其它情况}.\n\\end{cases}\n$$\n将从地址 $0$（最左边）到地址 $15$（最右边）的位列出，得到 `0011010100010100`。", "answer": "$$\\boxed{0011010100010100}$$", "id": "1956845"}, {"introduction": "数字设计的魅力在于理论与现实的结合，而这个练习恰好揭示了这一点。在理想模型中，ROM 的输出会即时响应地址变化，但在物理世界中，信号延迟会导致称为“毛刺”的瞬态错误输出。这个问题 [@problem_id:1956894] 探讨了当多个地址位同时变化时产生输出毛刺的风险，并引导你思考一种标准的工程解决方案来确保同步系统的稳定性。通过分析此场景，你将从理想的逻辑门世界过渡到考虑时序和物理限制的现实世界设计挑战。", "problem": "一个数字系统中采用了一个 16x1 的只读存储器（ROM）。该 ROM 有四条地址输入线（表示为 $A_3, A_2, A_1, A_0$）和一条数据输出线 $D_0$。该 ROM 已被编程为一个 4 输入偶校验生成器。如果地址输入中有偶数个'1'，则输出 $D_0$ 为逻辑'0'；如果地址输入中有奇数个'1'，则输出 $D_0$ 为逻辑'1'。\n\n在物理实现中，到达 ROM 内部译码器的地址信号不会在完全相同的瞬间改变。这种时序偏斜意味着，在从一个地址转换到另一个地址的过程中，可能会瞬间选中一个或多个不正确的中间地址，从而可能在输出线 $D_0$ 上产生一个虚假的、短暂的脉冲，称为“毛刺”（glitch）。当大量地址位同时变化，而理想的输出状态应保持不变时，发生毛刺的风险最高。\n\n在这种情况下，以下哪个选项正确地指出了一个极有可能产生输出毛刺的地址转换，并提出了一种在同步数字系统中减轻此类毛刺的有效的、标准的系统级技术？\n\nA. 转换：0001 到 0011；解决方法：在 ROM 输出 $D_0$ 上添加一个大电流缓冲器。\n\nB. 转换：0101 到 1010；解决方法：用一个访问时间更快的 ROM 替换现有 ROM。\n\nC. 转换：0111 到 1000；解决方法：使用一个寄存器锁存 ROM 输出 $D_0$，该寄存器由时钟控制，在数据稳定后进行采样。\n\nD. 转换：0011 到 0110；解决方法：使用分立的异或门重新设计校验生成逻辑，而不是使用 ROM。\n\nE. 转换：0000 到 1111；解决方法：要求所有输入地址序列遵循格雷码（Gray code）模式。", "solution": "我们将编程后的 ROM 建模为实现 4 输入奇偶校验函数\n$$\nD_{0}=A_{3}\\oplus A_{2}\\oplus A_{1}\\oplus A_{0}\n$$,\n其中，当输入中'1'的个数为偶数时，$D_{0}=0$；当'1'的个数为奇数时，$D_{0}=1$。如果在两个地址向量之间转换时地址线没有同时切换，就可能发生毛刺，因为瞬间选中的中间地址的奇偶性可能与预期的最终奇偶性不同。当理想输出应保持不变而多个地址位同时变化时，风险最大，因为经过具有不同奇偶性的中间地址的概率随着转换的汉明距离（Hamming distance）的增加而增加。\n\n将两个地址向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的汉明距离定义为\n$$\nd_{H}(\\mathbf{a},\\mathbf{b})=\\sum_{i=0}^{3}\\left|a_{i}-b_{i}\\right|\n$$,\n它计算了变化的比特数。为了获得最高的毛刺可能性，我们希望 $D_{0}(\\mathbf{a})=D_{0}(\\mathbf{b})$（理想输出恒定）且 $d_{H}$ 尽可能大。\n\n逐个评估每个选项：\n\nA. 转换 0001 到 0011。奇偶性：$0001$ 有一个'1'，是奇数，因此 $D_{0}=1$；$0011$ 有两个'1'，是偶数，因此 $D_{0}=0$。理想输出发生变化，且只有一个比特变化（$d_{H}=1$）。这不是一个高可能性的虚假毛刺情况。所提出的解决方法，即添加一个大电流缓冲器，并不能解决逻辑冒险问题，因为它不消除中间地址译码或内部竞争。\n\nB. 转换 0101 到 1010。奇偶性：$0101$ 有两个'1'，是偶数，$D_{0}=0$；$1010$ 有两个'1'，是偶数，$D_{0}=0$。理想输出恒定，且所有四个比特都变化（$d_{H}=4$），这确实是一个高可能性的毛刺场景。然而，用更快的 ROM 替换并不能保证消除由输入到达时间不一致和内部译码器竞争引起的冒险；它可能只会缩短毛刺，但不能确保在系统级别上的正确同步行为。\n\nC. 转换 0111 到 1000。奇偶性：$0111$ 有三个'1'，是奇数，$D_{0}=1$；$1000$ 有一个'1'，是奇数，$D_{0}=1$。理想输出恒定，且所有四个比特都变化（$d_{H}=4$），从而产生很高的毛刺可能性。所提出的解决方法是用一个寄存器锁存 $D_{0}$，该寄存器由时钟控制，在 ROM 输出稳定后进行采样。在同步系统中，这是标准技术：选择时钟，使得寄存器在 ROM 及其地址输入满足建立和保持约束后对 $D_{0}$ 进行采样，从而过滤掉任何瞬态毛刺。\n\nD. 转换 0011 到 0110。奇偶性：$0011$ 有两个'1'，是偶数，$D_{0}=0$；$0110$ 有两个'1'，是偶数，$D_{0}=0$。理想输出恒定，但只有两个比特变化（$d_{H}=2$），这是一个可能性较低但仍然可能存在的冒险情况。用异或门重新设计本身并不能消除冒险，除非逻辑被明确设计为无冒险的，并且与寄存器输出相比，这仍然不构成一个标准的系统级缓解措施。\n\nE. 转换 0000 到 1111。奇偶性：$0000$ 有零个'1'，是偶数，$D_{0}=0$；$1111$ 有四个'1'，是偶数，$D_{0}=0$。理想输出恒定，且所有四个比特都变化（$d_{H}=4$），因此该转换有很高的毛刺可能性。要求使用格雷码序列可以通过确保单比特转换来减少毛刺，但对于同步系统中的任意地址，这通常不是一个标准的或普遍适用的系统级缓解措施；它对地址生成器施加了约束，并且不如寄存器输出那样适用广泛。\n\n在所有指出了高可能性转换的选项中，B、C 和 E 的 $d_{H}=4$ 且理想输出恒定，但只有 C 提出了有效的、标准的同步系统补救措施，即寄存 ROM 输出以在稳定后进行采样。因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1956894"}]}