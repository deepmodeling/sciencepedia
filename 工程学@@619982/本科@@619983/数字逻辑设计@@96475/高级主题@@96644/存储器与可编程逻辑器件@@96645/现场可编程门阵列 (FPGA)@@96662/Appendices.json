{"hands_on_practices": [{"introduction": "动手实践的第一步是理解 FPGA 的核心构件：查找表（LUT）。LUT 本质上是一个小型可编程存储器，通过配置其内容来实现任意布尔函数。这个练习将带你深入了解 LUT 的内部工作原理，通过为一个具体的逻辑函数确定所需的配置位，你将亲身体验从抽象逻辑到物理实现的映射过程。[@problem_id:1934992]", "problem": "在现场可编程门阵列（FPGA）中，一个基本的逻辑元件是查找表（LUT）。一个 $k$ 输入查找表可以被配置来实现任意一个 $k$ 变量的布尔函数。这是通过编程其 $2^k$ 个内部静态存储单元来实现的，这些存储单元存储了该函数的真值表。\n\n考虑一个4输入查找表，其输入标记为 $I_3, I_2, I_1, I_0$，输出为一个单独的 $O$。这16个配置存储位对应于查找表对于每种可能的输入组合的输出，地址顺序从 $(I_3, I_2, I_1, I_0) = (0,0,0,0)$ 到 $(1,1,1,1)$ 排列。\n\n您的任务是配置此查找表以实现以下4变量布尔函数：\n$$F(A, B, C, D) = (A \\oplus B) \\cdot (C \\odot D)$$\n其中 $\\oplus$ 表示异或（XOR）运算，$\\odot$ 表示同或（XNOR）运算。\n\n函数变量 $A, B, C, D$ 根据以下物理映射连接到查找表的输入端：\n- $A$ 连接到 $I_1$。\n- $B$ 连接到 $I_0$。\n- $C$ 连接到 $I_3$。\n- $D$ 连接到 $I_2$。\n\n确定必须加载到查找表存储器中的16位配置字符串。请将您的答案表示为一个16位的二进制字符串，其中第一位对应地址 $(0,0,0,0)$ 的存储单元，最后一位对应地址 $(1,1,1,1)$ 的存储单元。", "solution": "一个 $k$ 输入查找表在一个 $2^{k}$ 条目的表格中存储每个输入地址 $(I_{3}, I_{2}, I_{1}, I_{0})$ 对应的输出。此处，$k=4$，所需的函数是\n$$F(A,B,C,D)=(A \\oplus B)\\cdot(C \\odot D),$$\n物理映射为 $A \\to I_{1}$，$B \\to I_{0}$，$C \\to I_{3}$，$D \\to I_{2}$。因此，对于一个地址 $(i_{3}, i_{2}, i_{1}, i_{0})$，查找表的输出是\n$$O=(i_{1} \\oplus i_{0}) \\cdot (i_{3} \\odot i_{2}).$$\n根据定义，$x \\oplus y=1$ 当且仅当 $x \\neq y$，且 $x \\odot y=1$ 当且仅当 $x=y$。因此，\n- 如果 $i_{3}=i_{2}$，则 $(i_{3} \\odot i_{2})=1$ 且 $O=i_{1} \\oplus i_{0}$。\n- 如果 $i_{3} \\neq i_{2}$，则 $(i_{3} \\odot i_{2})=0$ 且 $O=0$。\n\n按顺序从 $(0,0,0,0)$ 到 $(1,1,1,1)$ 枚举地址：\n\n1) 对于 $(i_{3},i_{2})=(0,0)$，地址 $(0,0,i_{1},i_{0})$ 产生\n$$(i_{1},i_{0})=(0,0)\\to 0,\\quad (0,1)\\to 1,\\quad (1,0)\\to 1,\\quad (1,1)\\to 0,$$\n所以位为：$0,1,1,0$。\n\n2) 对于 $(i_{3},i_{2})=(0,1)$，$(i_{3} \\odot i_{2})=0$，所以位为：$0,0,0,0$。\n\n3) 对于 $(i_{3},i_{2})=(1,0)$，$(i_{3} \\odot i_{2})=0$，所以位为：$0,0,0,0$。\n\n4) 对于 $(i_{3},i_{2})=(1,1)$，地址 $(1,1,i_{1},i_{0})$ 产生相同的异或模式：\n$$(i_{1},i_{0})=(0,0)\\to 0,\\quad (0,1)\\to 1,\\quad (1,0)\\to 1,\\quad (1,1)\\to 0,$$\n所以位为：$0,1,1,0$。\n\n按地址顺序（从 $0000$ 到 $1111$）连接起来，得到16位的配置：\n$$0110000000000110.$$", "answer": "$$\\boxed{0110000000000110}$$", "id": "1934992"}, {"introduction": "现实世界中的数字逻辑通常比单个 LUT 所能容纳的要复杂得多。因此，必须将大型函数分解到多个 LUT 上。这个练习探讨了这一过程，不仅关注如何最有效地利用资源（即使用最少的 LUT），还引入了关键的性能指标——时序延迟。通过解决这个问题，你将学会如何分析多 LUT 电路的性能，这是 FPGA 设计中必不可少的技能。[@problem_id:1935002]", "problem": "一位数字设计工程师的任务是在一个现代的现场可编程门阵列 (FPGA) 上实现一个7输入逻辑与门。目标FPGA的逻辑结构由6输入查找表 (LUT) 构成。单个6输入LUT可以被配置以实现任意最多6个变量的布尔函数。\n\n该FPGA架构的时序特性如下：\n- 单个LUT从任意输入到其输出的传播延迟为 $T_{\\text{LUT}} = 80 \\text{ ps}$。\n- 从一个LUT的输出到后续LUT的输入之间的互连网络上的信号传播延迟为 $T_{\\text{NET}} = 110 \\text{ ps}$。\n\n为进行此分析，假设与门的全部7个主输入在时间 $t=0$ 时是稳定的，并同时到达第一级LUT的输入端。你的任务是确定资源效率最高的实现方案的参数，其中效率定义为使用最少数量的LUT。\n\n计算实现该7输入与门所需的最少LUT数量（$L$），以及此实现的总最坏情况传播延迟（$D$）。延迟的测量从 $t=0$ 开始，直到最终输出稳定为止。\n\n将你的答案表示为一个2元素行矩阵 $[L, D]$，其中 $L$ 是LUT的无量纲数量，$D$ 是以皮秒为单位的总延迟。", "solution": "单个6输入LUT可以实现任何最多6个独立变量的布尔函数。一个7输入与门依赖于7个独立变量，因此它不能用单个6输入LUT来实现。因此，至少需要2个LUT。\n\n资源最简化的构造使用2个LUT：\n- LUT1计算部分积 $y_{1} = x_{1} \\land x_{2} \\land x_{3} \\land x_{4} \\land x_{5} \\land x_{6}$。\n- LUT2计算最终输出 $y = y_{1} \\land x_{7}$。\n\n因此，最少的LUT数量为 $L=2$。\n\n在时序方面，最坏情况传播延迟是从主输入到最终输出的最长串行路径上所有延迟的总和。经过两个LUT的路径包括：\n- 产生 $y_{1}$ 的第一个LUT延迟 $T_{\\text{LUT}}$，\n- 从LUT1输出到LUT2输入的一个LUT间网络延迟 $T_{\\text{NET}}$，\n- 产生 $y$ 的第二个LUT延迟 $T_{\\text{LUT}}$。\n\n因此，总延迟为\n$$\nD = T_{\\text{LUT}} + T_{\\text{NET}} + T_{\\text{LUT}} = 2T_{\\text{LUT}} + T_{\\text{NET}}.\n$$\n代入给定值 $T_{\\text{LUT}} = 80 \\text{ ps}$ 和 $T_{\\text{NET}} = 110 \\text{ ps}$，可得\n$$\nD = 2 \\times 80 + 110 = 270.\n$$\n因此，$L=2$ 且 $D=270$ （单位：皮秒）。", "answer": "$$\\boxed{\\begin{bmatrix} 2 & 270 \\end{bmatrix}}$$", "id": "1935002"}, {"introduction": "现代 FPGA 不仅仅是 LUT 的集合，它们还包含高度优化的专用硬件块，如块随机存取存储器 (BRAM)。有效地利用这些资源是实现高性能设计的关键。本练习将探讨硬件描述语言 (Verilog) 的编码风格如何直接影响综合工具能否成功推断出这些专用块。通过比较两种不同的编码方式，你将理解编写“可综合”代码的重要性，从而将设计意图准确地映射到物理硬件上。[@problem_id:1934984]", "problem": "一位数字设计工程师的任务是在现场可编程门阵列（FPGA）上实现一个小型高速暂存存储器（scratchpad memory）。该存储器必须能够存储 $2^N$ 个字，每个字宽 $M$ 位。主要目标是确保综合工具使用FPGA专用的、高性能的块RAM（BRAM）资源来实现此存储器，而不是使用通用逻辑单元（即分布式RAM）来实现，因为后者的面积和速度效率要低得多。\n\n工程师考虑了两种不同的Verilog编码风格，即`Module_A`和`Module_B`。两个模块在功能上都旨在实现一个简单的双端口存储器，具有一个写端口和一个读端口。\n\n**模块 A：**\n```verilog\nmodule Module_A #(\n    parameter N = 8, // Address width\n    parameter M = 16 // Data width\n) (\n    input                       clk,\n    input                       write_en,\n    input        [N-1:0]        write_addr,\n    input        [M-1:0]        write_data,\n    input        [N-1:0]        read_addr,\n    output logic [M-1:0]        read_data\n);\n    reg [M-1:0] memory_array [(2**N)-1:0];\n\n    // Write Port (Synchronous)\n    always @(posedge clk) begin\n        if (write_en) begin\n            memory_array[write_addr] = write_data;\n        end\n    end\n\n    // Read Port (Asynchronous)\n    assign read_data = memory_array[read_addr];\n\nendmodule\n```\n\n**模块 B：**\n```verilog\nmodule Module_B #(\n    parameter N = 8, // Address width\n    parameter M = 16 // Data width\n) (\n    input                       clk,\n    input                       write_en,\n    input        [N-1:0]        write_addr,\n    input        [M-1:0]        write_data,\n    input        [N-1:0]        read_addr,\n    output logic [M-1:0]        read_data\n);\n    reg [M-1:0] memory_array [(2**N)-1:0];\n\n    // Write Port (Synchronous)\n    always @(posedge clk) begin\n        if (write_en) begin\n            memory_array[write_addr] = write_data;\n        end\n    end\n\n    // Read Port (Synchronous)\n    always @(posedge clk) begin\n        read_data = memory_array[read_addr];\n    end\n\nendmodule\n```\n\n哪个模块代表了确保推断出BRAM资源的正确编码风格，其主要原因是什么？\n\nA. `Module_A` 更优，因为其异步读取提供了最低的读取延迟，这是存储器设计的一个主要目标。\n\nB. `Module_B` 更优，因为其同步读取行为直接映射到FPGA中专用块RAM原语的寄存器输出架构。\n\nC. `Module_A` 更优，因为它通过避免在读取数据路径上使用时钟信号来降低功耗。\n\nD. `Module_B` 更优，因为只有当读写操作在同一个`always`块中描述时，综合工具才能推断出存储器。\n\nE. 两个模块对于BRAM推断是等效的；选择仅仅是编码偏好问题，因为现代综合工具可以将任何一种风格优化为BRAM。", "solution": "1. 目标与约束：目标是让综合工具推断出专用的块RAM（BRAM），而不是分布式RAM。主流FPGA BRAM原语的关键架构约束是读取是同步的：被寻址的数据在一个时钟边沿产生，通常通过一个内部或外部的输出寄存器。形式上，BRAM的语义对应于\n$$\n\\text{read\\_data}(t^{+})=\\text{memory}\\big(\\text{read\\_addr}(t)\\big),\n$$\n其中 $t^{+}$ 表示在时间 $t$ 的有效时钟边沿之后紧接着的时刻。相比之下，异步读取意味着\n$$\n\\text{read\\_data}(t)=\\text{memory}\\big(\\text{read\\_addr}(t)\\big),\n$$\n这是一种不带时钟的纯组合逻辑依赖。\n\n2. `Module_A`的分析：写端口是同步的，与BRAM推断兼容，但读端口通过连续赋值是异步的：\n$$\n\\text{assign read\\_data}=\\text{memory\\_array[read\\_addr]}.\n$$\n这表达了组合逻辑的读取行为，即 $\\text{read\\_data}(t)$ 会随着 $\\text{read\\_addr}(t)$ 的变化而立即改变，这与BRAM原语的同步读取要求不匹配。综合工具通常会将这种异步读取映射到分布式（LUT）RAM，而不是BRAM。\n\n3. `Module_B`的分析：写端口和读端口都是同步和时钟控制的：\n$$\n\\text{always @(posedge clk)}\\ \\ \\text{read\\_data} \\leftarrow \\text{memory\\_array[read\\_addr]}.\n$$\n这与BRAM的同步读取行为相匹配，即地址在时钟边沿被采样，数据在时钟边沿之后通过内部寄存器呈现出来。因此，`Module_B`遵循了公认的BRAM推断模板。\n\n4. 选项评估：\n- A 是错误的，因为虽然异步读取可以减少表面上的延迟，但它在大多数FPGA上会阻止BRAM的推断。\n- B 是正确的，因为同步读取直接映射到BRAM的寄存器输出架构。\n- C 是错误的；功耗在这里不是主要问题，并且异步读取会使实现转向使用LUT RAM。\n- D 是错误的；推断并不要求读和写在同一个always块中。\n- E 是错误的；综合工具通常无法将异步读取的存储器映射到BRAM。\n\n因此，正确的选择是`Module_B`，主要原因是其同步读取行为与FPGA BRAM原语的寄存式、时钟同步的读取架构一致，从而能够可靠地推断出BRAM。", "answer": "$$\\boxed{B}$$", "id": "1934984"}]}