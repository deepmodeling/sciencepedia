{"hands_on_practices": [{"introduction": "在计算机中执行算术运算时，我们受限于固定的位数。这种限制可能导致有符号数计算中出现溢出等错误。本练习的核心是设计一个简洁而巧妙的电路，仅使用最高有效位的进位信号，来检测这种关键的错误情况。这对于构建可靠的算术逻辑单元（ALU）是一项基本技能。[@problem_id:1914733]", "problem": "在算术逻辑单元（ALU）的设计中，一个关键部件是能够处理有符号数的二进制并行加法器。考虑一个 $n$ 位并行加法器，其设计用于计算和 $S = A + B$，其中 $A$ 和 $B$ 是用二进制补码表示的 $n$ 位有符号整数。该加法器由级联的全加器电路构成。\n\n设操作数的位表示为 $A = a_{n-1}a_{n-2}...a_0$ 和 $B = b_{n-1}b_{n-2}...b_0$，其中 $a_{n-1}$ 和 $b_{n-1}$ 是符号位，即最高有效位（MSB）。令 $C_{n-1}$ 表示进入最高有效位（第 $n-1$ 级）全加器的进位输入信号，令 $C_n$ 表示由该最高有效位级产生的进位输出信号。\n\n您的任务是设计一个最小逻辑电路，该电路产生一个单比特的溢出信号 $V$。如果和 $S$ 超出了 $n$ 位二进制补码数的表示范围，该信号必须为逻辑 '1'，否则为逻辑 '0'。该电路应仅使用 $C_{n-1}$ 和 $C_n$ 作为其输入。\n\n以下哪个布尔表达式正确地表示了溢出信号 $V$？\n\nA. $V = C_n$\n\nB. $V = C_{n-1} \\cdot C_n$\n\nC. $V = C_{n-1} + C_n$\n\nD. $V = C_{n-1} \\oplus C_n$\n\nE. $V = \\overline{C_{n-1} \\oplus C_n}$", "solution": "在 $n$ 位有符号整数的二进制补码加法中，当且仅当两个加数的符号位相同，但和的符号位与它们不同时，才会发生溢出。等效地，仅使用进入最高有效位（MSB）的进位和从 MSB 输出的进位即可检测溢出：当这两个进位不同时，恰好发生溢出。\n\n令 $a \\equiv a_{n-1}$、$b \\equiv b_{n-1}$、$C \\equiv C_{n-1}$、$C_{\\text{out}} \\equiv C_{n}$ 和 $s \\equiv s_{n-1}$ 为最高有效位的和比特。对于最高有效位的全加器，\n$$\ns = a \\oplus b \\oplus C,\\qquad C_{\\text{out}} = a b + a C + b C.\n$$\n用操作数符号和结果符号表示的溢出条件是\n$$\nV = a b\\,\\overline{s} + \\overline{a}\\,\\overline{b}\\,s.\n$$\n我们将证明这等于 $C \\oplus C_{\\text{out}}$。\n\n首先，计算\n$$\nC \\oplus C_{\\text{out}} = C\\,\\overline{C_{\\text{out}}} + \\overline{C}\\,C_{\\text{out}}.\n$$\n使用 $C_{\\text{out}} = a b + a C + b C$ 和德摩根定律（De Morgan’s law），\n$$\n\\overline{C_{\\text{out}}} = \\overline{a b}\\,\\overline{a C}\\,\\overline{b C} = (\\overline{a}+\\overline{b})(\\overline{a}+\\overline{C})(\\overline{b}+\\overline{C}).\n$$\n因此，\n$$\nC\\,\\overline{C_{\\text{out}}} = C(\\overline{a}+\\overline{b})(\\overline{a}+\\overline{C})(\\overline{b}+\\overline{C})\n= C\\,\\overline{a}\\,(\\overline{a}+\\overline{b})(\\overline{b}+\\overline{C})\n= C\\,\\overline{a}\\,(\\overline{b}+\\overline{C})\n= C\\,\\overline{a}\\,\\overline{b}.\n$$\n另外，\n$$\n\\overline{C}\\,C_{\\text{out}} = \\overline{C}(a b + a C + b C) = \\overline{C}\\,a b.\n$$\n因此，\n$$\nC \\oplus C_{\\text{out}} = C\\,\\overline{a}\\,\\overline{b} + \\overline{C}\\,a b.\n$$\n现在根据 $(a,b)$ 的情况来评估溢出定义：\n- 如果 $a=b=1$，那么 $s = 1 \\oplus 1 \\oplus C = C$，所以 $V = a b\\,\\overline{s} = \\overline{C} = \\overline{C}\\,a b$。\n- 如果 $a=b=0$，那么 $s = 0 \\oplus 0 \\oplus C = C$，所以 $V = \\overline{a}\\,\\overline{b}\\,s = C = C\\,\\overline{a}\\,\\overline{b}$。\n- 如果 $a \\neq b$，那么 $a b = \\overline{a}\\,\\overline{b} = 0$，所以 $V=0$。\n\n因此在所有情况下，\n$$\nV = C\\,\\overline{a}\\,\\overline{b} + \\overline{C}\\,a b = C \\oplus C_{\\text{out}}.\n$$\n因此，仅使用 $C_{n-1}$ 和 $C_{n}$ 的最小逻辑是\n$$\nV = C_{n-1} \\oplus C_{n},\n$$\n这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1914733"}, {"introduction": "掌握了错误检测的方法后，我们现在转向ALU的核心功能：减法。构建一个独立的减法器并非最高效的方法，更巧妙的策略是复用我们的加法器，只需先将被减数转换成其二进制补码（two's complement）形式即可。本次练习要求你设计一个能够根据控制信号选择性地对一个数进行求补的电路，这个设计巧妙地使一个加法器单元能够同时执行加法和减法两种运算。[@problem_id:1909155]", "problem": "算术逻辑单元 (ALU) 的一个基本组成部分是能够对数字进行条件取反的电路。您的任务是设计一个4位组合电路，该电路对补码数执行此功能。\n\n该电路有一个4位二进制输入 $B = B_3B_2B_1B_0$（其中 $B_3$ 是最高有效位）和一个单控制输入 $S$。该电路产生一个4位二进制输出 $Y = Y_3Y_2Y_1Y_0$。\n\n该电路的行为定义如下：\n- 如果 $S=0$，输出与输入相同：$Y = B$。\n- 如果 $S=1$，输出是输入的补码：$Y = \\text{Two's Complement}(B)$。\n\n在您的表达式中，使用 $\\cdot$ 表示与（AND），$+$ 表示或（OR），$\\oplus$ 表示异或（XOR），并用上划线表示非（NOT）（例如，$\\bar{A}$）。\n\n以下哪组简化后的布尔表达式正确描述了输出 $Y_3, Y_2, Y_1, Y_0$？\n\nA.\n$Y_0 = B_0$\n$Y_1 = (B_1 \\oplus S) \\oplus (\\bar{B_0} \\cdot S)$\n$Y_2 = (B_2 \\oplus S) \\oplus (\\bar{B_1} \\cdot \\bar{B_0} \\cdot S)$\n$Y_3 = (B_3 \\oplus S) \\oplus (\\bar{B_2} \\cdot \\bar{B_1} \\cdot \\bar{B_0} \\cdot S)$\n\nB.\n$Y_0 = B_0 \\oplus S$\n$Y_1 = B_1 \\oplus S$\n$Y_2 = B_2 \\oplus S$\n$Y_3 = B_3 \\oplus S$\n\nC.\n$Y_0 = B_0 \\oplus S$\n$Y_1 = B_1 \\oplus (B_0 \\cdot S)$\n$Y_2 = B_2 \\oplus (B_1 \\cdot B_0 \\cdot S)$\n$Y_3 = B_3 \\oplus (B_2 \\cdot B_1 \\cdot B_0 \\cdot S)$\n\nD.\n$Y_0 = B_0$\n$Y_1 = (B_1 \\oplus S) \\oplus (B_0 \\cdot S)$\n$Y_2 = (B_2 \\oplus S) \\oplus (B_1 \\cdot B_0 \\cdot S)$\n$Y_3 = (B_3 \\oplus S) \\oplus (B_2 \\cdot B_1 \\cdot B_0 \\cdot S)$", "solution": "我们需要一个4位电路，当 $S=0$ 时输出 $Y=B$，当 $S=1$ 时输出 $Y=\\text{Two's Complement}(B)$。$B$ 的补码是 $\\overline{B}+1$。有条件地实现这一点的一个标准方法是：\n- 使用 $X_{i}=B_{i}\\oplus S$ 有条件地对每一位进行取反（因此，如果 $S=0$，则 $X=B$；如果 $S=1$，则 $X=\\overline{B}$）。\n- 将 $S$ 作为最低有效位的输入进位加入，即计算 $Y=X+S$。\n\n设 $C_{0}=S$，并对每一位 $i$（从 $0$ 到 $3$），使用半加器关系式来将 $X_{i}$ 和 $C_{i}$ 相加：\n$$\nY_{i}=X_{i}\\oplus C_{i},\\qquad C_{i+1}=X_{i}\\cdot C_{i}.\n$$\n使用 $X_{i}=B_{i}\\oplus S$ 和恒等式 $A\\oplus B=A\\cdot\\bar{B}+\\bar{A}\\cdot B$ 以及 $S\\cdot\\bar{S}=0$。\n\n位 $0$：\n$$\nX_{0}=B_{0}\\oplus S,\\quad Y_{0}=(B_{0}\\oplus S)\\oplus S=B_{0},\\quad C_{1}=(B_{0}\\oplus S)\\cdot S=\\bar{B_{0}}\\cdot S.\n$$\n\n位 $1$：\n$$\nX_{1}=B_{1}\\oplus S,\\quad Y_{1}=(B_{1}\\oplus S)\\oplus C_{1}=(B_{1}\\oplus S)\\oplus(\\bar{B_{0}}\\cdot S),\n$$\n$$\nC_{2}=X_{1}\\cdot C_{1}=(B_{1}\\oplus S)\\cdot(\\bar{B_{0}}\\cdot S)=(B_{1}\\bar{S}+\\bar{B_{1}}S)\\cdot\\bar{B_{0}}S=\\bar{B_{1}}\\bar{B_{0}}S.\n$$\n\n位 $2$：\n$$\nX_{2}=B_{2}\\oplus S,\\quad Y_{2}=(B_{2}\\oplus S)\\oplus C_{2}=(B_{2}\\oplus S)\\oplus(\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S),\n$$\n$$\nC_{3}=X_{2}\\cdot C_{2}=(B_{2}\\oplus S)\\cdot(\\bar{B_{1}}\\bar{B_{0}}S)=(B_{2}\\bar{S}+\\bar{B_{2}}S)\\cdot\\bar{B_{1}}\\bar{B_{0}}S=\\bar{B_{2}}\\bar{B_{1}}\\bar{B_{0}}S.\n$$\n\n位 $3$：\n$$\nX_{3}=B_{3}\\oplus S,\\quad Y_{3}=(B_{3}\\oplus S)\\oplus C_{3}=(B_{3}\\oplus S)\\oplus(\\bar{B_{2}}\\cdot\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S).\n$$\n\n因此，简化后的表达式为：\n$$\nY_{0}=B_{0},\\quad Y_{1}=(B_{1}\\oplus S)\\oplus(\\bar{B_{0}}\\cdot S),\\quad Y_{2}=(B_{2}\\oplus S)\\oplus(\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S),\\quad Y_{3}=(B_{3}\\oplus S)\\oplus(\\bar{B_{2}}\\cdot\\bar{B_{1}}\\cdot\\bar{B_{0}}\\cdot S),\n$$\n这与选项A完全匹配。选项B、C和D的进位项不正确（当 $S=1$ 时，B产生反码；C和D使用了 $B$ 的乘积项作为进位，而不是所需的 $\\bar{B}$ 的乘积项进位）。", "answer": "$$\\boxed{A}$$", "id": "1909155"}, {"introduction": "我们已经探讨了广泛使用的二进制补码系统，但它并非表示有符号数的唯一方式。最后的这个实践将深入研究符号-数值（sign-magnitude）表示法，其中符号和数值由独立的逻辑处理。通过为符号-数值加法/减法器设计控制逻辑，你将能更深刻地体会其中的设计权衡，并理解为何二进制补码在现代处理器中如此普及。[@problem_id:1909098]", "problem": "您的任务是为一种专用的算术逻辑单元（ALU）切片设计控制逻辑。该ALU设计用于对以符号-数值（sign-magnitude）格式表示的4位数字进行操作。您的目标是确定该单元内关键控制信号的布尔逻辑。\n\n系统定义如下：\n- 该ALU接受两个4位符号-数值操作数，$A = (A_s, A_2, A_1, A_0)$ 和 $B = (B_s, B_2, B_1, B_0)$。\n- $A_s$ 和 $B_s$ 是符号位，其中0代表正数，1代表负数。其余三位，$(A_2, A_1, A_0)$ 和 $(B_2, B_1, B_0)$，表示数值部分（量值），分别记作 $A_m$ 和 $B_m$。\n- 一个操作选择信号 $S$ 控制功能：$S=0$ 表示加法（$A+B$），$S=1$ 表示减法（$A-B$）。\n- 最终结果是一个4位符号-数值数，$R = (R_s, R_2, R_1, R_0)$，其符号为 $R_s$，数值部分为 $R_m$。\n\n该ALU的内部架构包含两个用于处理数值部分的主要组件：\n1.  一个数值处理模块，接收 $A_m$, $B_m$ 和一个控制信号 $K_{sub}$。当 $K_{sub}=0$ 时，该模块执行 $A_m + B_m$；当 $K_{sub}=1$ 时，执行 $A_m - B_m$。\n2.  一个3位数值比较器，输出一个单一信号 $C_{A \\ge B}$。如果 $A_m \\ge B_m$，该信号为1；如果 $A_m < B_m$，该信号为0。\n\n基于此设计，请确定减法控制信号 $K_{sub}$ 和结果符号位 $R_s$ 的正确布尔逻辑表达式对。表达式应使用输入符号位 $A_s$ 和 $B_s$、操作选择器 $S$ 以及比较器输出 $C_{A \\ge B}$ 来表示。\n\n在以下选项中，并列或 `·` 符号表示逻辑与，`+` 表示逻辑或，`⊕` 表示异或。\n\n下列哪一对关于 $(K_{sub}, R_s)$ 的表达式是正确的？\n\nA. $(A_s \\oplus B_s \\oplus S, \\quad A_s \\oplus ((A_s \\oplus B_s \\oplus S) \\cdot \\neg C_{A \\ge B}))$\n\nB. $(A_s \\oplus B_s \\oplus S, \\quad A_s \\oplus ((A_s \\oplus B_s \\oplus S) \\cdot C_{A \\ge B}))$\n\nC. $(A_s \\oplus B_s, \\quad A_s)$\n\nD. $(A_s \\oplus B_s \\oplus S, \\quad ((A_s \\oplus B_s \\oplus S) \\cdot \\neg C_{A \\ge B}) \\cdot B_s + \\neg ((A_s \\oplus B_s \\oplus S) \\cdot \\neg C_{A \\ge B}) \\cdot A_s)$\n\nE. $(A_s \\oplus B_s, \\quad A_s \\oplus ((A_s \\oplus B_s) \\cdot \\neg C_{A \\ge B}))$", "solution": "问题要求我们推导一个符号-数值ALU中两个信号的布尔逻辑：数值减法控制信号 $K_{sub}$ 和最终结果的符号位 $R_s$。\n\n**第1步：推导减法控制信号 $K_{sub}$**\n\n信号 $K_{sub}$ 决定了数值部分 $A_m$ 和 $B_m$ 是相加（$K_{sub}=0$）还是相减（$K_{sub}=1$）。我们需要确定每种操作的条件。\n\n如果两个操作数（在考虑了操作类型后）的有效符号相同，则对数值部分进行加法运算。如果它们的有效符号不同，则对数值部分进行减法运算。\n\n让我们分析操作选择器 $S$ 的两种情况：\n\n-   **情况1：加法 ($S=0$)**\n    - 如果 $A$ 和 $B$ 的符号相同（$A_s = B_s$），我们对它们的数值部分相加。例如：$(+5) + (+2) = +7$；$(-5) + (-2) = -7$。这需要 $K_{sub}=0$。\n    - 如果符号不同（$A_s \\neq B_s$），我们用较大的数值减去较小的数值。例如：$(+5) + (-2) = +3$。这需要数值减法，因此 $K_{sub}=1$。\n\n-   **情况2：减法 ($S=1$)**\n    - 操作 $A - B$ 等同于 $A + (-B)$。第二个操作数的有效符号与 $B$ 的符号相反。\n    - 如果原始符号不同（$A_s \\neq B_s$），有效符号会变得相同（例如，$(+A) - (-B) \\rightarrow (+A) + (+B)$）。我们对它们的数值部分相加。这需要 $K_{sub}=0$。\n    - 如果原始符号相同（$A_s = B_s$），有效符号会变得不同（例如，$(+A) - (+B) \\rightarrow (+A) + (-B)$）。我们对它们的数值部分相减。这需要 $K_{sub}=1$。\n\n让我们将这些条件总结成一个关于 $A_s$, $B_s$ 和 $S$ 的函数 $K_{sub}$ 的真值表：\n\n| $A_s$ | $B_s$ | $S$ | 运算 | 数值运算 | $K_{sub}$ |\n|:-----:|:-----:|:---:|:----------|:-------------|:---------:|\n| 0     | 0     | 0   | 加法，符号相同  | 加法          | 0         |\n| 0     | 1     | 0   | 加法，符号不同  | 减法     | 1         |\n| 1     | 0     | 0   | 加法，符号不同  | 减法     | 1         |\n| 1     | 1     | 0   | 加法，符号相同  | 加法          | 0         |\n| 0     | 0     | 1   | 减法，符号相同  | 减法     | 1         |\n| 0     | 1     | 1   | 减法，符号不同  | 加法          | 0         |\n| 1     | 0     | 1   | 减法，符号不同  | 加法          | 0         |\n| 1     | 1     | 1   | 减法，符号相同  | 减法     | 1         |\n\n观察最后一列，我们发现当输入（$A_s, B_s, S$）中有奇数个1时，$K_{sub}$ 才为1。这是异或（XOR）函数的定义。\n因此，$K_{sub}$ 的逻辑是：\n$$K_{sub} = A_s \\oplus B_s \\oplus S$$\n\n**第2步：推导结果的符号位 $R_s$**\n\n结果的符号 $R_s$ 取决于对数值部分执行的操作，并可能取决于数值的相对大小。\n\n-   **情况A：数值加法 ($K_{sub} = 0$)**\n    - 这种情况发生在操作数的有效符号相同时。结果的符号将是这个共同的符号。例如，$(+5) + (+2) = +7$（符号来自+5）和 $(-5) - (+2) = (-5) + (-2) = -7$（符号来自-5）。在所有这些情况下，结果的符号与第一个操作数 $A$ 的符号相同。\n    - 所以，如果 $K_{sub}=0$，则 $R_s = A_s$。\n\n-   **情况B：数值减法 ($K_{sub} = 1$)**\n    - 这种情况发生在有效符号不同时。结果的符号取决于哪个操作数的数值更大。\n    - **子情况B1：$A_m \\ge B_m$**\n        - 比较器输出为 $C_{A \\ge B} = 1$。\n        - 数值减法 $A_m - B_m$ 的结果是非负的，最终的符号应该是数值较大操作数的符号，即 $A$ 的符号。\n        - 所以，如果 $K_{sub}=1$ 并且 $C_{A \\ge B}=1$，则 $R_s = A_s$。\n    - **子情况B2：$A_m < B_m$**\n        - 比较器输出为 $C_{A \\ge B} = 0$。\n        - 结果应该取数值较大操作数的符号，即有效操作数 $B$ 的符号。$B$ 的有效符号不仅仅是 $B_s$，还取决于操作 $S$。操作 $A \\pm B$ 被视为 $A + ((-1)^S B)$。第二项的符号在 $S=0$ 时为 $B_s$，在 $S=1$ 时为 $\\neg B_s$。这等价于 $B_s \\oplus S$。\n        - 所以，如果 $K_{sub}=1$ 并且 $C_{A \\ge B}=0$，则 $R_s = B_s \\oplus S$。\n\n**第3步：综合 $R_s$ 的完整表达式**\n\n让我们组合 $R_s$ 的逻辑：\n-   如果 $K_{sub}=0$，$R_s = A_s$。\n-   如果 $K_{sub}=1$ 且 $C_{A \\ge B}=1$，$R_s = A_s$。\n-   如果 $K_{sub}=1$ 且 $C_{A \\ge B}=0$，$R_s = B_s \\oplus S$。\n\n我们可以看到，除了最后一种情况外，$R_s$ 在所有情况下都等于 $A_s$。这种结构表明了对 $A_s$ 的条件性修改。我们将例外情况的条件表示为 $E = (K_{sub} \\cdot \\neg C_{A \\ge B})$。\n该逻辑可以表示为：\n- 如果 $E=1$，则 $R_s = B_s \\oplus S$。\n- 如果 $E=0$，则 $R_s = A_s$。\n\n这是一个2到1多路选择器的功能：$R_s = E \\cdot (B_s \\oplus S) + \\neg E \\cdot A_s$。\n\n让我们尝试使用异或（XOR）将其简化为更紧凑的形式。形如 $R_s = A_s \\oplus F$ 的表达式意味着“如果 $F=0$，$R_s=A_s$；如果 $F=1$，$R_s=\\neg A_s$”。我们来检查这是否可行。\n我们的例外条件是 $E = (K_{sub} \\cdot \\neg C_{A \\ge B})$。我们需要证明当 $E=1$时，所需的符号 $B_s \\oplus S$ 等于 $\\neg A_s$。\n条件 $E=1$ 意味着 $K_{sub}=1$。根据第1步，$K_{sub} = A_s \\oplus B_s \\oplus S$。\n所以，当例外情况发生时，我们有 $A_s \\oplus B_s \\oplus S = 1$。\n这可以重写为 $A_s \\oplus (B_s \\oplus S) = 1$。\n对于单个比特，$x \\oplus y = 1$ 意味着 $x \\neq y$。\n因此，$A_s \\neq (B_s \\oplus S)$，这意味着 $A_s = \\neg(B_s \\oplus S)$，或者等价地，$\\neg A_s = B_s \\oplus S$。\n这正是我们所需要的。当例外条件 $E$ 为真时，正确的结果符号 $B_s \\oplus S$ 确实是 $A_s$ 的反相。\n\n所以，我们可以将 $R_s$ 的逻辑写成：\n$$R_s = A_s \\oplus E$$\n$$R_s = A_s \\oplus (K_{sub} \\cdot \\neg C_{A \\ge B})$$\n代入 $K_{sub}$ 的表达式：\n$$R_s = A_s \\oplus ((A_s \\oplus B_s \\oplus S) \\cdot \\neg C_{A \\ge B})$$\n\n**第4步：最终选择**\n\n推导出的表达式是：\n- $K_{sub} = A_s \\oplus B_s \\oplus S$\n- $R_s = A_s \\oplus ((A_s \\oplus B_s \\oplus S) \\cdot \\neg C_{A \\ge B})$\n\n这对表达式与选项A匹配。\n我们来分析一下为什么使用多路选择器形式的选项D是错误的。选项D给出的表达式是 $R_s = E \\cdot B_s + \\neg E \\cdot A_s$。错误在于在例外情况下使用了 $B_s$ 而不是有效符号 $B_s \\oplus S$。这在减法中会出错，例如 $(-2) - (-5) = +3$。这里 $A_s=1, B_s=1, S=1$。条件 $E$ 为真。选项D会给出结果符号 $B_s=1$（负），这是错误的。正确的符号是 $B_s \\oplus S = 1 \\oplus 1 = 0$（正）。\n\n因此，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1909098"}]}