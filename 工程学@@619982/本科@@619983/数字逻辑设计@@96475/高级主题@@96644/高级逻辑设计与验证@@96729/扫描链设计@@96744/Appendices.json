{"hands_on_practices": [{"introduction": "扫描链的核心功能是将其中的触发器在测试模式下重新配置为一个巨大的移位寄存器。理解数据如何逐位移入这个链条是掌握扫描测试的第一步。本练习通过一个简单的思想实验，让你手动追踪一个测试序列在扫描链中的传播过程，从而直观地理解扫描移位操作的本质。[@problem_id:1958985]", "problem": "在现代数字电路设计中，采用一种称为可测试性设计（DFT）的技术来方便对制造出的芯片进行测试。一种常见的DFT方法是添加扫描链，它在一种特殊的测试模式下，将电路中的触发器重构为一个大的移位寄存器。\n\n考虑一个由五个D型触发器组成的简单5位扫描链，标记为FF1到FF5。在测试模式下，FF1的数据输入端连接到一个主输入端口 `scan_in`。FF1的输出端（Q1）连接到FF2的输入端（D2），FF2的输出端（Q2）连接到FF3的输入端（D3），以此类推，直到FF5的输出端（Q5），它连接到一个主输出端口 `scan_out`。\n\n最初，扫描链中的所有五个触发器都被复位，因此它们的内容，表示为有序位串 `[Q1, Q2, Q3, Q4, Q5]`，是 `00000`。\n\n一个测试向量序列 `10110` 在五个连续的时钟周期内通过 `scan_in` 端口串行移入该链。该序列的第一个比特（`1`）在第一个时钟周期施加于 `scan_in`，第二个比特（`0`）在第二个时钟周期施加，依此类推。\n\n在恰好5个时钟周期后，扫描链的二进制内容 `[Q1, Q2, Q3, Q4, Q5]` 是什么？\n\nA. `10110`\n\nB. `01101`\n\nC. `00000`\n\nD. `01100`\n\nE. `11010`", "solution": "在一个由上升沿触发的D型触发器组成的扫描链中，在每个有效时钟沿，下一状态等于输入：对于FF1，$Q_{1}^{+}=D_{1}=\\text{scan\\_in}$；对于 $i \\in \\{2,3,4,5\\}$，$Q_{i}^{+}=D_{i}=Q_{i-1}$。设 $Q_{i}[k]$ 表示第 $k$ 个时钟之后的内容，初始状态为 $Q_{i}[0]=0$。设施加的串行输入为 $s[1]=1$, $s[2]=0$, $s[3]=1$, $s[4]=1$, $s[5]=0$。那么每个时钟的更新方程为\n$$\nQ_{1}[k]=s[k], \\quad Q_{i}[k]=Q_{i-1}[k-1] \\text{ for } i=2,3,4,5.\n$$\n迭代计算：\n- $k=1$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,0,0,0]$。\n- $k=2$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,0,0,0]$。\n- $k=3$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,0,1,0,0]$。\n- $k=4$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[1,1,0,1,0]$。\n- $k=5$: $[Q_{1},Q_{2},Q_{3},Q_{4},Q_{5}]=[0,1,1,0,1]$。\n\n因此，在恰好五个时钟周期后，扫描链的内容是 $01101$，对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1958985"}, {"introduction": "在掌握了基本的移位操作后，我们需要从更高层面理解整个扫描测试流程的效率。一个完整的测试周期不仅包括移位，还包括一个关键的“捕获”周期，用以锁存组合逻辑的响应。本练习要求你推导应用整个测试向量集所需的总时钟周期数，这有助于你理解测试时间与扫描链长度（$N$）及测试向量数量（$M$）之间的关系，这是衡量测试成本的关键指标。[@problem_id:1958961]", "problem": "在现代系统级芯片 (SoC) 的制造测试中，使用一种称为扫描链测试的技术来验证数字逻辑的完整性。对于一个特定的SoC设计，所有内部状态元件（触发器）都被连接成一个单一、连续的扫描链，以实现观察和控制。\n\n测试过程由一个外部测试控制器管理，遵循一个特定的流水线化协议：\n1.  测试开始时，将一个测试向量串行地移入扫描链。\n2.  一旦一个向量完全加载，SoC就会从“移位模式”切换到“捕获模式”，持续一个时钟周期。在此周期内，组合逻辑根据测试向量定义的状态计算其输出，并且这个结果被触发器捕获。\n3.  之后，SoC会切换回“移位模式”。此时，捕获的响应被串行地移出，同时下一个测试向量被移入。这种流水线操作是实现高效测试的关键。\n\n考虑一个SoC，其单一扫描链由总共 $N$ 个触发器组成。该SoC的完整测试套件包含 $M$ 个不同的测试向量，每个向量的长度为 $N$。\n\n推导出一个闭式解析表达式，用于计算施加全部 $M$ 个测试向量并移出最后一个（第 $M$ 个）向量的完整响应所需的总时钟周期数。你的答案应该用 $N$ 和 $M$ 来表示。", "solution": "令 $T(N,M)$ 表示所需的总时钟周期数。\n\n根据协议：\n- 将第一个长度为 $N$ 的测试向量加载到扫描链中需要 $N$ 个移位周期。这贡献了 $N$ 个周期。\n- $M$ 个测试向量中的每一个都需要一个捕获周期，总共贡献了 $M$ 个周期。\n- 每次捕获之后，响应都必须被移出。共有 $M$ 个这样的响应需要卸载，每次卸载需要 $N$ 个移位周期。对于前 $M-1$ 个响应，这 $N$ 个周期也同时加载了下一个测试向量；对于最后一个（第 $M$ 个）响应，这 $N$ 个周期仅用于卸载响应。在所有情况下，这总共贡献了 $M N$ 个周期。\n\n将这些不相交的贡献相加，得到\n$$\nT(N,M)=N+M+M N.\n$$\n等价地，\n$$\nT(N,M)=M(N+1)+N=(M+1)N+M.\n$$\n因此，总时钟周期的闭式表达式为 $M N + N + M$。", "answer": "$$\\boxed{M N+N+M}$$", "id": "1958961"}, {"introduction": "扫描测试的最终目标是发现并定位制造缺陷。当芯片的实际输出与预期输出不符时，扫描链就成了我们诊断问题的“眼睛”。本练习模拟了一个真实的故障诊断场景：你需要通过对比预期的和观测到的扫描输出数据流，并结合非顺序的扫描链连接信息，精确定位到是哪一个触发器捕获了错误的值，从而将故障范围缩小到特定的逻辑锥。[@problem_id:1958964]", "problem": "在现代片上系统 (SoC) 中，会使用可测试性设计 (DFT) 方法进行广泛的测试。其中一个关键部分是扫描链，它在测试模式下将芯片的触发器连接成一个巨大的移位寄存器。这使得工程师能够控制和观察电路的内部状态。\n\n考虑一个包含 16 个状态保持触发器的数字逻辑块，编号从 FF1 到 FF16。为了测试目的，这些触发器已被连接成一条单一的扫描链。触发器的物理索引不一定与其在扫描链中的位置相对应。从扫描输入引脚到扫描输出引脚的具体扫描链顺序如下：\n\nFF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7\n\n在扫描输入一个特定的测试向量后，芯片会进入功能模式一个时钟周期，以将组合逻辑的输出捕获到触发器中。然后芯片返回测试模式，并将捕获的状态扫描输出。\n\n基于无故障仿真的预期扫描输出比特流是：\n`E = 1011010111010110`\n\n从物理芯片上实际观测到的比特流是：\n`O = 1011010110010110`\n\n比特流从左到右读取，其中第一个比特是最先从扫描输出引脚出来的，最后一个比特是最后出来的。在组合逻辑中存在一个单个的、非间歇性的故障，导致恰好一个触发器捕获了错误的值。请确定故障触发器 FF$k$ 的索引 $k$。在所有捕获了不正确数据的触发器中，首个捕获错误的触发器被定义为沿着扫描路径距离扫描输出引脚最远（即最靠近扫描输入引脚）的那个。", "solution": "该问题要求我们通过分析预期的和观测到的扫描输出比特流，来确定哪个触发器 FF$k$ 捕获了不正确的值。问题的核心在于将比特流中的位置正确地映射到非顺序扫描链中的特定触发器。\n\n步骤 1：理解扫描输出过程\n问题陈述，扫描输出比特流是通过移出捕获的值生成的，从最靠近扫描输出引脚的触发器开始。给出的扫描链顺序是从扫描输入到扫描输出。我们需要反转这个顺序，以找出其数据出现在输出端的触发器序列。\n\n给定的扫描链路径是：\nSCAN_IN → FF13 → FF2 → FF9 → FF16 → FF5 → FF11 → FF4 → FF14 → FF8 → FF1 → FF10 → FF15 → FF6 → FF12 → FF3 → FF7 → SCAN_OUT\n\n离扫描输出引脚最近的触发器是 FF7。其捕获的值将是扫描输出流中的第一个比特。在链中朝向扫描输入引脚的下一个触发器是 FF3，所以它的值将是第二个比特。如此继续，直到最后一个触发器 FF13（离扫描输入引脚最近），其捕获的值将是数据流的最后一个比特。\n\n让我们建立从流中比特位置（1 到 16）到源触发器索引的映射关系：\n- 比特 1: FF7\n- 比特 2: FF3\n- 比特 3: FF12\n- 比特 4: FF6\n- 比特 5: FF15\n- 比特 6: FF10\n- 比特 7: FF1\n- 比特 8: FF8\n- 比特 9: FF14\n- 比特 10: FF4\n- 比特 11: FF11\n- 比特 12: FF5\n- 比特 13: FF16\n- 比特 14: FF9\n- 比特 15: FF2\n- 比特 16: FF13\n\n步骤 2：识别预期和观测到的比特流之间的不匹配\n现在，我们比较预期的比特流 `E` 和观测到的比特流 `O`，以找到任何错误的位置。\n\n预期：`E = 1011010111010110`\n观测：`O = 1011010110010110`\n\n让我们从左到右（位置 1 到 16）逐比特地比较它们：\n- 位置 1-9：比特相同 (`101101011`)。\n- 位置 10：`E` 是 `1`，而 `O` 是 `0`。这是一个不匹配。\n- 位置 11-16：比特相同 (`010110`)。\n\n唯一的不匹配发生在扫描输出流的第 10 个比特位置。\n\n步骤 3：定位故障触发器\n问题陈述，错误的来源是扫描链中第一个捕获错误值的触发器，定义为在所有故障捕获中离扫描输出引脚最远的那个。在扫描输出流中，较晚出来的比特对应于链中更深（离扫描输出引脚更远）的触发器。因此，我们应该识别发生在最高比特位置索引的不匹配。\n\n在本例中，只有一个不匹配，位于比特位置 10。我们现在使用步骤 1 中的映射来确定哪个触发器捕获的值对应于这第 10 个比特。\n\n根据我们的映射：比特 10 对应于 FF4 捕获的值。\n\n由于这是唯一的错误，故障必定位于为 FF4 提供输入的组合逻辑锥中。因此，FF4 是捕获了错误值的触发器。故障触发器 FF$k$ 的索引 $k$ 是 4。", "answer": "$$\\boxed{4}$$", "id": "1958964"}]}