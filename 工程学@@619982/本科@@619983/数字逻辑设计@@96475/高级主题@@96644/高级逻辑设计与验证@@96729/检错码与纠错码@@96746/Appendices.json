{"hands_on_practices": [{"introduction": "汉明码（Hamming code）是纠错码领域的一个经典基石，它能够高效地检测并纠正单个比特的错误。这个练习将引导你完成一个基础但至关重要的任务：为一个给定的数据字计算正确的校验位，并将其组装成一个完整的 (7,4) 汉明码字。通过动手实践这一过程，你将掌握汉明码编码的核心机制，为理解更复杂的纠错系统打下坚实的基础。[@problem_id:1933155]", "problem": "一个用于简化存储系统的数字控制器，其任务是使用系统(7,4)汉明码将4位数据字编码为7位码字，以实现单比特纠错。7位码字的结构由位位置 $c_7, c_6, c_5, c_4, c_3, c_2, c_1$ 定义，其中 $c_7$ 是最高有效位。\n\n位的分配如下：\n- 校验位，记为 $p_1, p_2, p_4$，分别置于位置 $c_1, c_2, c_4$。这些位置对应于2的幂的位位置（即 $2^0, 2^1, 2^2$）。\n- 数据位，记为 $d_7, d_6, d_5, d_3$，分别置于剩余的位置 $c_7, c_6, c_5, c_3$。\n\n当一个表示为 $b_4 b_3 b_2 b_1$（其中 $b_4$ 是最高有效位）的4位数据字需要被编码时，它按如下方式映射到码字中的数据位位置：$d_7 = b_4$，$d_6 = b_3$，$d_5 = b_2$，$d_3 = b_1$。\n\n计算校验位的值以确保在特定位集合上满足偶校验。该计算使用由符号 $\\oplus$ 表示的异或（XOR）运算。校验方程如下：\n- $p_1 = d_3 \\oplus d_5 \\oplus d_7$\n- $p_2 = d_3 \\oplus d_6 \\oplus d_7$\n- $p_4 = d_5 \\oplus d_6 \\oplus d_7$\n\n给定4位数据字 `1011`，请确定其对应的7位系统汉明码字。将答案表示为一个从 $c_7$ 到 $c_1$ 的7位二进制字符串。", "solution": "给定的4位数据字为 $b_{4}b_{3}b_{2}b_{1}=1011$。根据映射关系 $d_{7}=b_{4}$、$d_{6}=b_{3}$、$d_{5}=b_{2}$ 和 $d_{3}=b_{1}$，我们得到\n$$\nd_{7}=1,\\quad d_{6}=0,\\quad d_{5}=1,\\quad d_{3}=1.\n$$\n用于偶校验的校验位使用给定的异或方程计算如下：\n$$\np_{1}=d_{3}\\oplus d_{5}\\oplus d_{7}=1\\oplus 1\\oplus 1=(1\\oplus 1)\\oplus 1=0\\oplus 1=1,\n$$\n$$\np_{2}=d_{3}\\oplus d_{6}\\oplus d_{7}=1\\oplus 0\\oplus 1=(1\\oplus 0)\\oplus 1=1\\oplus 1=0,\n$$\n$$\np_{4}=d_{5}\\oplus d_{6}\\oplus d_{7}=1\\oplus 0\\oplus 1=(1\\oplus 0)\\oplus 1=1\\oplus 1=0.\n$$\n将这些位放入码字位置 $c_{7},c_{6},c_{5},c_{4},c_{3},c_{2},c_{1}$，其中 $c_{7}=d_{7}$，$c_{6}=d_{6}$，$c_{5}=d_{5}$，$c_{4}=p_{4}$，$c_{3}=d_{3}$，$c_{2}=p_{2}$，$c_{1}=p_{1}$，我们有\n$$\n(c_{7},c_{6},c_{5},c_{4},c_{3},c_{2},c_{1})=(1,0,1,0,1,0,1).\n$$\n这满足了在指定集合上的偶校验：$c_{1}\\oplus c_{3}\\oplus c_{5}\\oplus c_{7}=0$，$c_{2}\\oplus c_{3}\\oplus c_{6}\\oplus c_{7}=0$ 以及 $c_{4}\\oplus c_{5}\\oplus c_{6}\\oplus c_{7}=0$，从而证实了其正确性。", "answer": "$$\\boxed{1010101}$$", "id": "1933155"}, {"introduction": "在掌握了汉明码的基本编码后，探索其能力的边界同样重要。虽然 (7,4) 汉明码能完美纠正所有单位错误，但它在面对多位错误时可能会发生“混淆”（aliasing），即某个双位错误的症状（Syndrome）与另一个单位错误完全相同，从而导致纠错失败。本练习要求你设计一个专用逻辑电路来识别一种特定的双位错误模式，通过这个挑战，你将深刻理解纠错码的局限性以及症状分析的精妙之处。[@problem_id:1933128]", "problem": "一个数字通信系统采用标准的系统（7,4）汉明码来防止单位元错误。在此方案中，构建一个 7 位码字 $C = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$，其中位元位置从左到右编号为 1 到 7。对于任何有效码字，其计算结果必须为 0 的奇偶校验方程定义如下：\n- 校验 1：$c_1 \\oplus c_3 \\oplus c_5 \\oplus c_7 = 0$\n- 校验 2：$c_2 \\oplus c_3 \\oplus c_6 \\oplus c_7 = 0$\n- 校验 3：$c_4 \\oplus c_5 \\oplus c_6 \\oplus c_7 = 0$\n\n在接收到一个 7 位字 $R = (r_1, r_2, r_3, r_4, r_5, r_6, r_7)$ 后，会计算出一个伴随式 $S = (s_2, s_1, s_0)$。伴随式位元 $s_0, s_1, s_2$ 分别是对接收到的字 $R$ 进行奇偶校验 1、2 和 3 的结果。伴随式的二进制值 $(s_2 s_1 s_0)_2$ 指示了单位元错误的位置。例如，伴随式为 $(1,0,1)$ 表示第 5 位存在错误。\n\n虽然此码可以纠正所有单位元错误，但某些双位元错误会产生一个非零伴随式，该伴随式与某个单位元错误产生的伴随式相同，从而导致错误纠正。这种现象被称为混叠。\n\n您的任务是设计一个特殊用途检测器。构建一个组合逻辑电路，以接收到的字 $R$ 的 7 个位元作为其输入。该电路的单个输出 $F$ 必须为逻辑 '1'，当且仅当以下两个条件同时满足：\n1. 接收到的字 $R$ 本身是一个双位元错误图样，意味着其汉明权重恰好为 2。\n2. 这个双位元图样产生的伴随式与第 5 位发生单位元错误所产生的伴随式相同。\n\n请提供输出 $F$ 作为输入位元 $r_1, \\dots, r_7$ 函数的最小化布尔表达式。您的表达式应为积之和形式。使用加号 `+` 表示逻辑或运算，并置表示逻辑与运算，上划线表示逻辑非运算（例如，$A\\overline{B} + C$）。", "solution": "设 $H$ 为与给定奇偶校验一致的 $3\\times 7$ 奇偶校验矩阵。对于任何接收到的字 $R=C+E$ (模 $2$)，其伴随式为\n$$\nS=H R^{T}=H(C+E)^{T}=H C^{T}+H E^{T}=0+H E^{T}=H E^{T}.\n$$\n因此，伴随式仅取决于错误图样 $E$。对于位置 $i$ 上的一个单位元错误，其错误向量为 $E=\\mathbf{e}_{i}$，伴随式等于 $H$ 的第 $i$ 列。根据给定的校验，\n- 校验 1 涉及位置 $\\{1,3,5,7\\}$，因此对于 $i\\in\\{1,3,5,7\\}$，$s_{0}=1$。\n- 校验 2 涉及位置 $\\{2,3,6,7\\}$，因此对于 $i\\in\\{2,3,6,7\\}$，$s_{1}=1$。\n- 校验 3 涉及位置 $\\{4,5,6,7\\}$，因此对于 $i\\in\\{4,5,6,7\\}$，$s_{2}=1$。\n\n因此，单位元错误的伴随式（以 $(s_{2},s_{1},s_{0})$ 表示）为：\n$$\n\\begin{aligned}\n1&:001,\\\\\n2&:010,\\\\\n3&:011,\\\\\n4&:100,\\\\\n5&:101,\\\\\n6&:110,\\\\\n7&:111.\n\\end{aligned}\n$$\n在位置 $i$ 和 $j$ 的双位元错误，其错误图样为 $E=\\mathbf{e}_{i}+\\mathbf{e}_{j}$ (模 $2$)，因此\n$$\nS=H(\\mathbf{e}_{i}+\\mathbf{e}_{j})^{T}=H\\mathbf{e}_{i}^{T}+H\\mathbf{e}_{j}^{T}，\n$$\n也就是说，是两个单位元错误伴随式的异或。我们要求这个双位元错误的伴随式等于位置 5 的单位元错误伴随式，即 $101$。因此，我们需要第 $i$ 列和第 $j$ 列满足\n$$\n\\text{col}(i)\\oplus \\text{col}(j)=\\text{col}(5)=101.\n$$\n等效地，以二进制索引形式表示，$i\\oplus j=5$。枚举可得出唯一的无序解\n$$\n\\{i,j\\}\\in\\{\\{1,4\\},\\{2,7\\},\\{3,6\\}\\}.\n$$\n条件 1（汉明权重恰好为 2）意味着所有其他位元必须为 0。因此，当且仅当 $R$ 等于这三个权重为 2 的图样之一时，值为 1 的所需积之和表达式为\n$$\nF=r_{1}r_{4}\\,\\overline{r_{2}}\\,\\overline{r_{3}}\\,\\overline{r_{5}}\\,\\overline{r_{6}}\\,\\overline{r_{7}}\n+ r_{2}r_{7}\\,\\overline{r_{1}}\\,\\overline{r_{3}}\\,\\overline{r_{4}}\\,\\overline{r_{5}}\\,\\overline{r_{6}}\n+ r_{3}r_{6}\\,\\overline{r_{1}}\\,\\overline{r_{2}}\\,\\overline{r_{4}}\\,\\overline{r_{5}}\\,\\overline{r_{7}}.\n$$\n这三个最小项是孤立的（在精确权重约束下不相邻），因此这是最小化的积之和形式。", "answer": "$$\\boxed{r_{1}r_{4}\\overline{r_{2}}\\overline{r_{3}}\\overline{r_{5}}\\overline{r_{6}}\\overline{r_{7}}+r_{2}r_{7}\\overline{r_{1}}\\overline{r_{3}}\\overline{r_{4}}\\overline{r_{5}}\\overline{r_{6}}+r_{3}r_{6}\\overline{r_{1}}\\overline{r_{2}}\\overline{r_{4}}\\overline{r_{5}}\\overline{r_{7}}}$$", "id": "1933128"}, {"introduction": "错误的世界并非只有随机的比特翻转，某些物理故障会导致所有错误都朝同一个方向发生，即所谓的“单向错误”（unidirectional errors）。伯格码（Berger code）就是为高效检测此类错误而设计的精妙编码方案。在这个实践中，你将分析伯格码的校验机制，并学习如何通过分析接收码字的症状来判断所发生的单向错误是 $1 \\to 0$ 类型还是 $0 \\to 1$ 类型，从而领略针对特定错误模型设计编码的智慧。[@problem_id:1933130]", "problem": "一个高可靠性数字系统采用一种可分离的 Berger 码，在 8 位数据字的传输中检测单向错误。在这个具体实现中，一个数据字 $D = D_7D_6...D_0$ 附加一个 4 位校验字 $C = C_3C_2C_1C_0$。校验字 $C$ 是数据字 $D$ 中 0 的总数的 4 位无符号二进制表示。完整的 12 位结构构成了传输的码字 $W = D_7D_6...D_0C_3C_2C_1C_0$。\n\n单向错误是指传输的码字中有一个或多个比特位发生翻转，但所有翻转都是相同类型的事件（即，要么全是 $1 \\to 0$ 翻转，要么全是 $0 \\to 1$ 翻转，但不是两者的混合）。\n\n接收端的译码器计算一个错误伴随式 $S$，以检查错误。对于任何接收到的 12 位字 $W'=(D', C')$，伴随式被定义为整数差：\n$$S = \\text{value}(C') - N_0(D')$$\n其中 $\\text{value}(C')$ 是接收到的校验位 $C'$ 所代表的无符号整数值，而 $N_0(D')$ 是接收到的数据字 $D'$ 中 0 比特的总数。\n\n译码器接收到两个 12 位字：\n- $W_1 = 011100000000$\n- $W_2 = 111010110101$\n\n已知其中一个字是由一个有效的码字经历了单向 $1 \\to 0$ 错误事件产生的，另一个字是由一个有效的码字经历了单向 $0 \\to 1$ 错误事件产生的。\n\n根据对每个接收字的错误伴随式的分析，确定哪个字对应哪种类型的单向错误。\n\nA) $W_1$ 是由 $1 \\to 0$ 错误造成的；$W_2$ 是由 $0 \\to 1$ 错误造成的。\n\nB) $W_1$ 是由 $0 \\to 1$ 错误造成的；$W_2$ 是由 $1 \\to 0$ 错误造成的。\n\nC) $W_1$ 和 $W_2$ 都是由 $1 \\to 0$ 错误造成的。\n\nD) $W_1$ 和 $W_2$ 都是由 $0 \\to 1$ 错误造成的。\n\nE) 伴随式的定义未提供足够的信息来区分这两种错误类型。", "solution": "该码是一种可分离的 Berger 码，有 8 个数据位和 4 个校验位。对于任何接收到的字 $W'=(D',C')$，译码器计算伴随式\n$$\nS=\\text{value}(C')-N_{0}(D'),\n$$\n其中 $\\text{value}(C')$ 是 4 个校验位所代表的无符号整数值，而 $N_{0}(D')$ 是 8 个数据位中 0 的数量。\n\n设传输的码字是有效的，所以 $\\text{value}(C)=N_{0}(D)$。考虑单向错误的影响：\n\n- 如果错误类型是 $1 \\to 0$，那么在数据部分，有 $t_{d}\\geq 0$ 个 1 翻转为 0，因此 $N_{0}(D')=N_{0}(D)+t_{d}$。在校验部分，只有 1 可以翻转为 0；设 $C$ 的数值总减少量为 $x\\geq 0$，因此 $\\text{value}(C')=\\text{value}(C)-x$。所以\n$$\nS=(\\text{value}(C)-x)-(N_{0}(D)+t_{d})=-(x+t_{d})<0,\n$$\n因为发生了错误，这意味着 $x+t_{d}>0$。\n\n- 如果错误类型是 $0 \\to 1$，那么在数据部分，有 $t_{d}\\geq 0$ 个 0 翻转为 1，因此 $N_{0}(D')=N_{0}(D)-t_{d}$。在校验部分，只有 0 可以翻转为 1；设 $C$ 的数值总增加量为 $y\\geq 0$，因此 $\\text{value}(C')=\\text{value}(C)+y$。所以\n$$\nS=(\\text{value}(C)+y)-(N_{0}(D)-t_{d})=y+t_{d}>0,\n$$\n因为发生了错误，这意味着 $y+t_{d}>0$。\n\n因此，$S<0$ 表示 $1 \\to 0$ 错误，而 $S>0$ 表示 $0 \\to 1$ 错误。\n\n现在计算每个接收字的 $S$。\n\n对于 $W_{1}=011100000000$，将其拆分为 $D'=\\text{前 8 位}=01110000$ 和 $C'=\\text{后 4 位}=0000$。计算 $D'$ 中的 0 的数量：$01110000$ 有 $5$ 个 0，所以 $N_{0}(D')=5$。$C'$ 的值是 $\\text{value}(0000)=0$。因此\n$$\nS_{1}=0-5=-5<0,\n$$\n所以 $W_{1}$ 是由一个 $1 \\to 0$ 错误造成的。\n\n对于 $W_{2}=111010110101$，将其拆分为 $D'=\\text{前 8 位}=11101011$ 和 $C'=\\text{后 4 位}=0101$。计算 $D'$ 中的 0 的数量：$11101011$ 有 $2$ 个 0，所以 $N_{0}(D')=2$。$C'$ 的值是 $\\text{value}(0101)=5$。因此\n$$\nS_{2}=5-2=3>0,\n$$\n所以 $W_{2}$ 是由一个 $0 \\to 1$ 错误造成的。\n\n因此，$W_{1}$ 对应于 $1 \\to 0$ 错误，而 $W_{2}$ 对应于 $0 \\to 1$ 错误。", "answer": "$$\\boxed{A}$$", "id": "1933130"}]}