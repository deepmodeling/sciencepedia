{"hands_on_practices": [{"introduction": "让我们从一个基础任务开始：反转数据向量的位。这个练习是学习 `generate for` 循环的绝佳入门，它展示了如何以可扩展的方式创建重复的、基于位置的布线连接。通过实现一个参数化的位反转器，你将掌握生成并行硬件结构的基本语法 [@problem_id:1950959]。", "problem": "在现代数字逻辑设计中，创建灵活且可复用的硬件模块是一项关键原则。为此，Verilog 提供了 `parameter` 和 `generate` 结构。`parameter` 允许模块的特性（例如数据总线的宽度）在实例化时定义，而不是硬编码。`generate` 块允许根据这些参数创建重复的逻辑结构，该过程在仿真或综合之前的展开阶段（elaboration phase）进行。\n\n考虑一个参数化的 `BitReverser` 模块的设计。该模块接收一个 N 位输入向量 `data_in`，并产生一个 N 位输出向量 `data_out`，其中 `data_out` 的位是 `data_in` 位的反向顺序。例如，如果 `N=8` 且 `data_in` 是 `8'b11001010`，那么 `data_out` 应该是 `8'b01010011`。\n\n该模块声明如下：\n```verilog\nmodule BitReverser #(parameter N = 8) (\n    input  wire [N-1:0] data_in,\n    output wire [N-1:0] data_out\n);\n\n    // Implementation to be inserted here\n\nendmodule\n```\n\n当将以下哪个 Verilog 代码片段插入模块中时，可以为参数 `N` 的任何正整数值正确地实现位反转逻辑？\n\nA.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    for (integer i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nC.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin\n        assign data_out[i] = data_in[N-1-i];\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenvar i;\ngenerate\n    for (i = 0; i  N; i = i + 1) begin : reverse_loop\n        assign data_out[i] = data_in[N-i];\n    end\nendgenerate\n```\n\nE.\n```verilog\nalways @(*) begin\n    for (integer i = 0; i  N; i = i + 1) begin\n        data_out[i] = data_in[N-1-i];\n    end\nend\n```", "solution": "我们需要将每个输出位连接到相应的镜像输入位：对于每个索引 $i$（$0 \\leq i \\leq N-1$），正确的映射是 $data\\_out[i] = data\\_in[N-1-i]$。这是一种纯组合的布线模式，完全在展开时确定，应使用带有 genvar 索引的 generate-for 循环来实现，以产生连续赋值。\n\n根据 Verilog-2001 规则和所需的映射来评估每个选项：\n\n- 选项 A：\n  - 使用带有 genvar 索引 $i$ 的 generate-for 循环，这是用于在展开时进行复制的正确结构。\n  - 使用了一个命名的 generate 块 `begin : reverse_loop`，这是推荐的且符合标准的风格。\n  - 实现了正确的索引表达式 $N-1-i$。\n  - 这是正确的。\n\n- 选项 B：\n  - 在 generate-for 循环内部使用了整数循环变量。在 Verilog-2001 的 generate-for 中，循环变量必须声明为 genvar，而不是 integer。因此，这不符合标准，是错误的。\n\n- 选项 C：\n  - 正确使用了 genvar 并实现了正确的映射 $N-1-i$，但省略了 generate 块的标签。在标准的 Verilog-2001 中，for-generate 主体应该是一个命名的 generate 块，以确保合规性并避免工具问题。这一省略使其在严格的 Verilog-2001 用法中不合规。因此，它不是最佳的正确答案。\n\n- 选项 D：\n  - 使用了 $N-i$ 而不是 $N-1-i$，这在 $i=0$ 时会导致索引越界（访问 $data\\_in[N]$），并且整体映射会差一。这是错误的。\n\n- 选项 E：\n  - 使用了一个过程性的 `always @(*)` 块对 `data_out` 进行赋值，但 `data_out` 被声明为 `wire`；过程赋值需要 `reg` 类型。因此，所给代码无法编译。此外，这没有按预期使用 `generate` 结构来创建展开时结构。按所写内容来看是错误的。\n\n因此，在所有选项中，唯一完全正确且符合标准的实现是 A。", "answer": "$$\\boxed{A}$$", "id": "1950959"}, {"introduction": "接下来，我们来探讨参数如何不仅控制模块的大小，还能控制其功能。本练习要求构建一个通用的奇偶校验生成器，可以用一个 `PARITY_TYPE` 参数将其配置为偶校验或奇校验。你将学习如何在生成逻辑中使用参数，以创建功能上可适配的硬件，这超越了简单的结构复制 [@problem_id:1950971]。", "problem": "你的任务是使用 Verilog 设计一个灵活的奇偶校验生成器电路。该模块名为 `ParityGenerator`，应被参数化以处理可变宽度的输入数据向量，并能产生偶校验或奇校验。\n\n该模块必须满足以下规范：\n-   一个参数 `WIDTH`，用于定义输入数据向量的位宽。\n-   一个参数 `PARITY_TYPE`，其值为 `0` 指定**偶校验**，值为 `1` 指定**奇校验**。\n-   一个 `WIDTH` 位的输入端口 `data_in`。\n-   一个单比特输出端口 `parity_out`。\n\n其功能定义如下：\n-   对于**偶校验** (`PARITY_TYPE = 0`)，`parity_out` 位应被设置，使得 `data_in` 和 `parity_out` 组合中 '1' 的总数为偶数。这等效于 `parity_out` 是 `data_in` 中所有比特的异或和。\n-   对于**奇校验** (`PARITY_TYPE = 1`)，`parity_out` 位应被设置，使得 `data_in` 和 `parity_out` 组合中 '1' 的总数为奇数。这等效于 `parity_out` 是 `data_in` 中所有比特的同或和。\n\n你的实现必须使用 `generate` `for` 循环来创建必要的组合逻辑结构。以下哪个 Verilog 代码片段正确实现了指定的 `ParityGenerator` 模块？\n\nA.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = 0;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH] | PARITY_TYPE;\nendmodule\n```\n\nB.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    integer i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nC.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nD.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output parity_out\n);\n    wire [WIDTH:0] p_chain;\n    assign p_chain[0] = PARITY_TYPE;\n\n    genvar i;\n    generate\n        for (i = 0; i  WIDTH; i = i + 1) begin : xor_chain\n            assign p_chain[i+1] = p_chain[i] ^ data_in[i+1];\n        end\n    endgenerate\n\n    assign parity_out = p_chain[WIDTH];\nendmodule\n```\n\nE.\n```verilog\nmodule ParityGenerator #(\n    parameter WIDTH = 8,\n    parameter PARITY_TYPE = 0\n) (\n    input [WIDTH-1:0] data_in,\n    output reg parity_out\n);\n    reg [WIDTH-1:0] p_temp;\n\n    genvar i;\n    generate\n        always @(*) begin\n            p_temp[0] = data_in[0];\n            for (i = 1; i  WIDTH; i = i + 1) begin\n                p_temp[i] = p_temp[i-1] ^ data_in[i];\n            end\n            parity_out = p_temp[WIDTH-1] ^ PARITY_TYPE;\n        end\n    endgenerate\nendmodule\n```", "solution": "设输入向量为 $d=\\text{data\\_in}$，其比特为 $d_{i}$，其中 $i=0, \\dots, \\text{WIDTH}-1$。将数据的按位异或归约定义为\n$$\ns=\\bigoplus_{i=0}^{\\text{WIDTH}-1} d_{i}.\n$$\n奇偶校验位 $p=\\text{parity\\_out}$ 必须满足以下规范：\n- 对于偶校验 $\\text{PARITY\\_TYPE}=0$，$(d,p)$ 中 1 的总数为偶数，这要求 $s \\oplus p=0$。因此，\n$p=s$。\n- 对于奇校验 $\\text{PARITY\\_TYPE}=1$，$(d,p)$ 中 1 的总数为奇数，这要求 $s \\oplus p=1$。因此，\n$p=\\overline{s}=s \\oplus 1$。\n\n使用 $\\text{PARITY\\_TYPE}\\in\\{0,1\\}$ 将两种情况合并为一个表达式，得到\n$$\np = s \\oplus \\text{PARITY\\_TYPE}.\n$$\n使用 generate for-loop 的结构化实现可以通过形成一个用 $\\text{PARITY\\_TYPE}$ 初始化的异或链来实现这一点：\n- 初始化 $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$。\n- 对于从 $0$ 到 $\\text{WIDTH}-1$ 的每个 $i$，计算 $p\\_{\\text{chain}}[i+1]=p\\_{\\text{chain}}[i]\\oplus d_{i}$。\n- 输出 $p=p\\_{\\text{chain}}[\\text{WIDTH}]$。\n\n这将得到 $p\\_{\\text{chain}}[\\text{WIDTH}]=\\left(\\bigoplus_{i=0}^{\\text{WIDTH}-1} d_{i}\\right)\\oplus \\text{PARITY\\_TYPE}=s\\oplus \\text{PARITY\\_TYPE}$，这与偶校验和奇校验所需的行为相匹配。\n\n现在评估各个选项：\n- A 通过链式计算得出 $p=s$，然后设置 $\\text{parity\\_out}=s \\lor \\text{PARITY\\_TYPE}$，当 $\\text{PARITY\\_TYPE}=1$ 时，这会得到 $1$ 而不是 $\\overline{s}$，因此是错误的。\n- B 使用 $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$ 并正确地从逻辑上计算出 $p=s\\oplus \\text{PARITY\\_TYPE}$，但是在 generate for-loop 中将循环变量声明为 integer；generate 循环需要一个编译时 genvar，因此这不满足要求。\n- C 使用 $p\\_{\\text{chain}}[0]=\\text{PARITY\\_TYPE}$，并配合一个基于 genvar 的 generate for-loop 来计算 $p\\_{\\text{chain}}[\\text{WIDTH}]=s\\oplus \\text{PARITY\\_TYPE}$，然后将 $\\text{parity\\_out}$ 设置为该值；这同时满足了功能和 generate 的要求。\n- D 使用 $d_{i+1}$，这既跳过了 $d_{0}$，又在 $i=\\text{WIDTH}-1$ 时访问了越界地址，因此是错误的。\n- E 在一个过程性 for-loop 中将 always 块与 genvar 混合使用，这是非法的；此外，它没有按照要求正确使用 generate for-loop 来创建结构化逻辑。\n\n因此，选项中唯一正确的实现是 C。", "answer": "$$\\boxed{C}$$", "id": "1950971"}, {"introduction": "在前述例子的基础上，这最后一个练习将挑战你实现一个更复杂、更实用的电路：一个用于找到第一个“0”的优先级编码器。这个任务展示了如何使用 `generate` 循环来构建级联逻辑，例如优先级链，其中每个阶段都依赖于下一阶段。掌握这种模式对于在数字系统中设计高效的仲裁器和其他基于优先级的电路至关重要 [@problem_id:1950986]。", "problem": "你的任务是设计一个参数化的Verilog模块 `find_first_zero`，它是在需要处理状态标志或掩码的系统中常见的组件。该模块必须识别从输入向量的最低有效位（LSB）开始搜索时找到的第一个 '0' 位的索引。\n\n**模块规范：**\n*   **模块名称**：`find_first_zero`\n*   **参数**：一个整数 `WIDTH`，用于定义输入向量的位宽。\n*   **输入**：`data_in`，一个大小为 `[WIDTH-1:0]` 的逻辑向量。\n*   **输出**：`index`，一个大小为 `[$clog2(WIDTH+1)-1:0]` 的逻辑向量。\n*   **功能**：\n    *   当从索引 0 (LSB) 向索引 `WIDTH-1` (最高有效位, MSB) 扫描 `data_in` 时，`index` 输出必须保持遇到的第一个 '0' 的位位置。\n    *   在 `data_in` 不包含任何 '0' 位（即所有位都为 '1'）的特定情况下，`index` 输出必须设置为值 `WIDTH`。\n\n下面是为该模块主体提出的四种不同的Verilog代码片段。哪一个正确地实现了指定的功能？\n\nA.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i >= 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? i : index_stage[i+1];\n    end\n    assign index = index_stage[0];\nendgenerate\n```\n\nB.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[0] = WIDTH;\n    for (i = 0; i  WIDTH; i=i+1) begin: priority_chain\n        assign index_stage[i+1] = (~data_in[i]) ? i : index_stage[i];\n    end\n    assign index = index_stage[WIDTH];\nendgenerate\n```\n\nC.\n```verilog\ngenerate\n    genvar i;\n    for (i = 0; i  WIDTH; i=i+1) begin: priority_chain\n        always @(*) begin\n            if (~data_in[i])\n                index = i;\n        end\n    end\nendgenerate\n```\n\nD.\n```verilog\ngenerate\n    genvar i;\n    wire [$clog2(WIDTH+1)-1:0] index_stage [WIDTH:0];\n    assign index_stage[WIDTH] = WIDTH;\n    for (i = WIDTH-1; i >= 0; i=i-1) begin: priority_chain\n        assign index_stage[i] = (~data_in[i]) ? index_stage[i+1] : i;\n    end\n    assign index = index_stage[0];\nendgenerate\n```", "solution": "我们需要一个组合逻辑模块，对于一个输入向量 $data\\_in[\\text{WIDTH}-1:0]$，当从最低有效位向最高有效位扫描时，它返回满足 $\\text{data\\_in}[j]=0$ 的最小索引 $j \\in \\{0, \\dots, \\text{WIDTH}-1\\}$。如果不存在这样的 $j$，输出必须为 $\\text{WIDTH}$。定义目标函数\n$$\nf(i)=\\begin{cases}\n\\min\\{j \\mid j \\in [i, \\text{WIDTH}-1],\\; \\text{data\\_in}[j]=0\\},  \\text{如果存在这样的 } j \\\\\n\\text{WIDTH},  \\text{否则}\n\\end{cases}\n$$\n期望的输出是 $f(0)$。\n\n分析每个选项：\n\n选项A：\n它定义了一个链 $index\\_stage[i]$，边界条件为 $index\\_stage[\\text{WIDTH}]=\\text{WIDTH}$，并且对于从 $\\text{WIDTH}-1$ 向下到 $0$ 的 $i$：\n$$\nindex\\_stage[i] = \\begin{cases}\ni,  \\text{如果 } \\neg \\text{data\\_in}[i] \\\\\nindex\\_stage[i+1],  \\text{否则}\n\\end{cases}\n$$\n这个递推关系与 $f(i)$ 的定义相匹配：显然 $index\\_stage[\\text{WIDTH}]=f(\\text{WIDTH})=\\text{WIDTH}$。对于递减的 $i$，如果 $\\text{data\\_in}[i]=0$，那么在 $i$ 或 $i$ 之上遇到的第一个零就是 $i$，所以 $f(i)=i$。否则，在 $i$ 或 $i$ 之上遇到的第一个零与在 $i+1$ 或 $i+1$ 之上遇到的相同，所以 $f(i)=f(i+1)$。因此，通过归纳法，对于所有的 $i$ 都有 $index\\_stage[i]=f(i)$，最终的赋值 $index=index\\_stage[0]=f(0)$ 完全符合要求的行为，包括全为 '1' 时产生 $\\text{WIDTH}$ 的情况。\n\n选项B：\n它设置 $index\\_stage[0]=\\text{WIDTH}$，并且对于从 $0$ 向上到 $\\text{WIDTH}-1$ 的 $i$：\n$$\nindex\\_stage[i+1] = \\begin{cases}\ni,  \\text{如果 } \\neg \\text{data\\_in}[i] \\\\\nindex\\_stage[i],  \\text{否则}\n\\end{cases}\n$$\n这个逻辑在每次遇到新的零时都会覆盖存储的索引，因此 $index\\_stage[\\text{WIDTH}]$ 变成了具有 $\\text{data\\_in}[i]=0$ 的最大索引 $i$，即从 LSB 到 MSB 扫描时的最后一个零。例如，对于在位置 $2:0$ 处为 `data_in = ...100` 的情况，结果会是 $1$ 而不是正确的 $0$。因此它是错误的。\n\n选项C：\n它创建了多个 always 块，每个块都可能在没有默认赋值的情况下对同一个信号 $index$ 进行赋值。这会导致 $index$ 上有多个过程驱动，并且没有定义选择第一个零的优先级。它在全为 '1' 的情况下也会失败，因为 $index$ 将保持未赋值状态。它没有实现指定的功能。\n\n选项D：\n它使用 $index\\_stage[\\text{WIDTH}]=\\text{WIDTH}$ 并且对于递减的 $i$：\n$$\nindex\\_stage[i] = \\begin{cases}\nindex\\_stage[i+1],  \\text{如果 } \\neg \\text{data\\_in}[i] \\\\\ni,  \\text{否则}\n\\end{cases}\n$$\n这与所需的递推关系相反。例如，在全为 '1' 的情况下，会得到 $index\\_stage[0]=0$ 而不是 $\\text{WIDTH}$，这违反了规范。因此它是错误的。\n\n因此，只有选项 A 正确实现了所需的功能，包括未找到零的边界情况。", "answer": "$$\\boxed{A}$$", "id": "1950986"}]}