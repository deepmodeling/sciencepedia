{"hands_on_practices": [{"introduction": "处理器设计的核心在于精确的控制。控制信号并非凭空产生，而是由具体的组合逻辑电路生成。这个练习将带你深入到控制单元的底层实现，通过为一个常见的硬件设计约束——只读的零号寄存器——设计保护逻辑，来揭示抽象控制信号与底层布尔代数之间的直接联系。掌握这种从高级约束到低级门级电路的转换，是数字逻辑设计师的一项基本功 [@problem_id:1926285]。", "problem": "在一个简单处理器的数据通路设计中，使用了一个包含32个寄存器的寄存器文件。这些寄存器通过一个5位地址总线进行寻址。设目标寄存器地址的五个比特位表示为 $A_4, A_3, A_2, A_1, A_0$，其中 $A_4$ 是最高有效位。寄存器0，对应于所有五个地址位均为0的地址，是一个特殊的硬件常数，它总是输出零值且无法被修改。\n\n处理器的主控制单元生成一个信号 $W_{in}$，当指令需要在寄存器文件中写入一个值时，该信号为高电平（逻辑1），否则为低电平（逻辑0）。然而，该信号没有考虑到寄存器0的特殊性。\n\n您必须设计一个组合逻辑电路，它以 $W_{in}$ 和地址位 $A_4, A_3, A_2, A_1, A_0$ 作为输入，并产生一个最终的写使能信号 $W_{out}$。这个 $W_{out}$ 信号将直接连接到寄存器文件的写使能输入端。该逻辑必须确保写操作仅在原始写信号 $W_{in}$ 为高电平且目标寄存器不是寄存器0时才被启用。\n\n请用 $W_{in}, A_4, A_3, A_2, A_1,$ 和 $A_0$ 表示 $W_{out}$ 的布尔逻辑表达式。使用 `+` 符号表示逻辑或操作，并用并列（例如，$XY$ 表示 $X$ 与 $Y$）表示逻辑与。", "solution": "我们要求只有当输入的写控制信号为高电平且目标不是寄存器0时，才进行写操作。用布尔术语来说，“目标不是寄存器0”这一条件等同于“至少有一个地址位为1”。对于地址位 $A_{4},A_{3},A_{2},A_{1},A_{0} \\in \\{0,1\\}$，谓词“至少有一个位为1”由逻辑或 $A_{4}+A_{3}+A_{2}+A_{1}+A_{0}$ 表示，如果地址位向量不全为零，其值为1，如果全为零，其值为0。\n\n因此，最终的写使能信号必须在 $W_{in}=1$ 且 $(A_{4}+A_{3}+A_{2}+A_{1}+A_{0})=1$ 时才为高电平。使用并列表示与（AND），`+`表示或（OR），所求的表达式为\n$$\nW_{out}=W_{in}\\left(A_{4}+A_{3}+A_{2}+A_{1}+A_{0}\\right).\n$$\n这确保了当目标地址为 $00000$（寄存器0）时，$W_{out}=0$，而在其他情况下，$W_{out}=W_{in}$。", "answer": "$$\\boxed{W_{in}\\left(A_{4}+A_{3}+A_{2}+A_{1}+A_{0}\\right)}$$", "id": "1926285"}, {"introduction": "在理解了单个控制信号的逻辑实现后，我们将视野扩大到整个数据通路，学习如何协同所有部件来执行一条完整的指令。本练习要求你将一个自定义存储指令 (`STOR_OFFSET`) 的功能描述，转化为一组完整的控制信号，以驱动一个单周期处理器。通过这个实践，你将加深对控制单元如何指挥算术逻辑单元（ALU）、寄存器堆和内存等不同组件协同工作的理解 [@problem_id:1926288]。", "problem": "考虑一个为执行一组指令而设计的简化单周期处理器数据通路。该数据通路包括一个具有两个读端口和一个写端口的寄存器文件、一个主存储器单元和一个算术逻辑单元（ALU）。数据流由几个控制信号和多路复用器管理。\n\n主要控制信号及其功能定义如下：\n- `RegWrite`（1位）：当设置为1时，允许将结果写入寄存器文件。\n- `MemtoReg`（1位）：选择寄存器文件写端口的数据来源。如果为0，来源是ALU结果；如果为1，来源是从内存读取的数据。\n- `MemRead`（1位）：当设置为1时，对主存储器执行读操作。\n- `MemWrite`（1位）：当设置为1时，对主存储器执行写操作。\n- `ALUSrc`（1位）：为ALU选择第二个操作数。如果为0，操作数来自寄存器文件的第二个读端口；如果为1，操作数是来自指令的符号扩展的16位立即数。\n- `Branch`（1位）：当设置为1时，为条件分支指令启用逻辑。\n- `ALUOp`（2位）：一个2位信号 `ALUOp_1` 和 `ALUOp_0`，用于指定ALU的操作。编码为：`00` 表示按位与，`01` 表示按位或，`10` 表示加法，`11` 表示减法。\n\n一条新指令 `STOR_OFFSET Rsrc, immediate(Rbase)` 已被添加到指令集中。该指令执行以下操作：它从寄存器 `Rsrc` 中检索值，并将其存储到内存中，地址由寄存器 `Rbase` 中的值与符号扩展的 `immediate` 值相加计算得出。该操作可描述为：$Memory[Register[Rbase] + \\text{sign\\_extend}(\\text{immediate})] \\leftarrow Register[Rsrc]$。\n\n您的任务是确定处理器正确执行 `STOR_OFFSET` 指令所需的主要控制信号的状态。请按以下特定顺序提供信号的二进制值：(`RegWrite`, `ALUSrc`, `MemtoReg`, `MemRead`, `MemWrite`, `Branch`, `ALUOp_1`, `ALUOp_0`)。", "solution": "该指令的语义由下式给出：\n$$\n\\text{Memory}\\big[\\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate})\\big] \\leftarrow \\text{Register}[R_{\\text{src}}].\n$$\n要在单周期数据通路上实现此操作，必须在一个周期内发生以下动作：\n1) 读取两个寄存器：$\\text{Register}[R_{\\text{base}}]$（用于地址计算）和 $\\text{Register}[R_{\\text{src}}]$（要存储的数据）。\n2) 使用ALU计算有效地址：\n$$\n\\text{ALU\\_result} = \\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate}).\n$$\n这需要选择符号扩展的立即数作为ALU的第二个操作数，并选择加法作为ALU的操作。\n3) 在计算出的地址处执行内存写入，写入数据为 $\\text{Register}[R_{\\text{src}}]$。\n4) 不将任何值写回寄存器文件，因为存储指令不产生寄存器结果。\n\n将这些要求映射到控制信号：\n- RegWrite: 对于存储指令，不执行寄存器写回，因此设置为 $0$。\n- ALUSrc: ALU的第二个操作数必须是用于基址加偏移量寻址的符号扩展立即数，因此设置为 $1$。\n- MemtoReg: 由于RegWrite为 $0$，寄存器写回的数据来源无关紧要；这是一个无关项（don't-care）。可以将其设置为 $0$ 而不影响正确性。\n- MemRead: 存储指令不从内存中读取，因此设置为 $0$。\n- MemWrite: 存储指令向内存中写入，因此设置为 $1$。\n- Branch: 该指令不是分支指令，因此设置为 $0$。\n- ALUOp: ALU必须执行加法以计算有效地址。根据编码，加法对应于 $\\text{ALUOp} = 10$，即 $\\text{ALUOp\\_1} = 1$ 且 $\\text{ALUOp\\_0} = 0$。\n\n因此，按照指定的顺序 $(\\text{RegWrite}, \\text{ALUSrc}, \\text{MemtoReg}, \\text{MemRead}, \\text{MemWrite}, \\text{Branch}, \\text{ALUOp\\_1}, \\text{ALUOp\\_0})$，所需的控制值为：\n$$\n(0, 1, 0, 0, 1, 0, 1, 0).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1 & 0 & 0 & 1 & 0 & 1 & 0\\end{pmatrix}}$$", "id": "1926288"}, {"introduction": "单周期设计虽然简单，但其时钟频率受限于最慢的指令，效率不高。多周期设计通过将一条指令分解为多个时钟周期来解决此问题，而这通常由有限状态机（FSM）进行控制。本练习将引导你进入多周期控制模型，探索其如何通过引入一个 `MemReady` 信号和“等待状态”来处理像内存访问延迟这样的实际挑战。你将学习到基于状态的控制如何使处理器设计更加灵活和高效，特别是如何与速度较慢的外部组件（如主存）进行同步 [@problem_id:1926245]。", "problem": "考虑一个简化的多周期处理器，其设计用于执行一个小型指令集。该处理器的控制单元以有限状态机 (FSM) 的形式实现。该FSM具有以下由数字标识的状态：\n- 状态0：取指令 (从内存中获取指令)。\n- 状态1：指令译码 (对指令进行译码并获取源寄存器)。\n- 状态2：执行 (为R型指令执行算术逻辑单元 (ALU) 操作)。\n- 状态3：R型写回 (将ALU结果写回到寄存器中)。\n- 状态4：内存地址计算 (为`load`或`store`指令计算有效内存地址)。\n- 状态5：内存读取 (从ALU指定的内存位置读取数据)。\n- 状态6：内存写回 (将从内存中获取的数据写回到寄存器中)。\n\n该处理器的内存单元可能很慢。为了处理这种情况，FSM在状态5中有一个特殊的行为。当FSM处于状态5时，它会检查一个名为`MemReady`的输入信号。\n- 如果`MemReady`为1，表示内存已成功提供数据，FSM将在下一个时钟沿转换到状态6。\n- 如果`MemReady`为0，表示内存仍在处理读取请求，FSM将在下一个时钟沿保持在状态5，从而有效等待内存。\n\n假设正在执行一条`load`指令。内存速度较慢，需要额外一个时钟周期来提供数据。这意味着在FSM首次进入状态5后，`MemReady`信号将在一个完整的时钟周期内为0，并将在该周期结束时变为1。\n\n在此场景下，从指令执行开始（状态0），控制单元FSM为执行这条`load`指令所经历的完整状态序列（用数字表示）是什么？\n\nA. 0, 1, 4, 5, 6\n\nB. 0, 1, 2, 3\n\nC. 0, 1, 4, 5, 5, 6\n\nD. 0, 1, 5, 6\n\nE. 0, 1, 4, 5, 4, 6", "solution": "在此多周期FSM中，一条`load`指令遵循取指令、译码、地址计算、内存读取和寄存器写回的标准路径。用状态编号表示，当内存立即响应时，标称序列为 $0 \\rightarrow 1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$。\n\n然而，状态$5$中的转换规则取决于输入$MemReady$：在状态$5$时，如果$MemReady=1$，FSM在下一个时钟沿转换到状态$6$；如果$MemReady=0$，FSM在下一个时钟沿保持在状态$5$。问题指明，在FSM首次进入状态$5$后，$MemReady=0$会持续一个完整的时钟周期，并在该周期结束时变为$1$。因此，在首次进入状态$5$时，FSM在下一个时钟沿观察到$MemReady=0$，因此会在状态$5$多停留一个周期。在那个等待周期之后，$MemReady=1$，所以在下一个时钟沿，FSM会从状态$5$转换到状态$6$。\n\n因此，从指令执行开始，完整的状态序列是：\n$0$ (取指令) $\\rightarrow$ $1$ (译码) $\\rightarrow$ $4$ (地址计算) $\\rightarrow$ $5$ (内存读取，初次进入) $\\rightarrow$ $5$ (因$MemReady=0$而停顿) $\\rightarrow$ $6$ (写回)。\n\n这与选项C相符。", "answer": "$$\\boxed{C}$$", "id": "1926245"}]}