{"hands_on_practices": [{"introduction": "异步FIFO设计的核心挑战之一是安全地在不同时钟域之间传递指针。此练习将帮助你掌握将标准二进制指针转换为格雷码（Gray code）的基本技能，这是确保数据在跨时钟域传输时不会因亚稳态而出错的关键技术 [@problem_id:1910272]。通过这个基础计算，你将理解为什么格雷码的单比特跳变特性对于异步设计至关重要。", "problem": "在数字系统中，异步先进先出（FIFO）缓冲器是一个关键组件，用于在两个使用不同且无关时钟工作的模块之间可靠地传输数据（这种情况称为跨时钟域）。为了跟踪数据的写入位置和读取位置，FIFO 使用称为写指针和读指针的内部计数器，来索引缓冲器内的存储单元。\n\n异步 FIFO 的一个主要设计挑战是，为了进行同步和状态标志生成（例如，满或空信号），如何将指针值从一个时钟域安全地传递到另一个时钟域。如果指针使用标准二进制计数器，当计数器递增时，可能会有多个比特同时变化（例如，从二进制 `011` 转换到 `100`）。如果接收时钟在这个多比特转换期间对指针进行采样，它可能会捕获一个无意义的中间值，从而导致灾难性的系统故障。\n\n为了防止这个问题，异步 FIFO 中的指针几乎总是使用格雷码（Gray code）来实现，这是一种二进制数字系统，其中任意两个连续值仅相差一个比特。这种单比特变化的特性确保了即使在转换期间对指针进行采样，接收到的值要么是旧值，要么是新值，这两者都是有效状态。\n\n考虑一个 8 字深的异步 FIFO，它需要一个 3 比特的指针来寻址其存储单元。在某一时刻，写指针的二进制值为 `101`。为了将该指针值安全地传输到读时钟域，必须先将其转换为等效的格雷码。\n\n以下哪个选项表示二进制指针值 `101` 对应的正确 3 比特格雷码？\n\nA. 111\n\nB. 101\n\nC. 110\n\nD. 010", "solution": "要将二进制值转换为格雷码，可以使用二进制比特 $b_{2}, b_{1}, b_{0}$（其中 $b_{2}$ 是最高有效位）与格雷码比特 $g_{2}, g_{1}, g_{0}$ 之间的逐位关系：\n$$\ng_{2} = b_{2}, \\quad g_{1} = b_{2} \\oplus b_{1}, \\quad g_{0} = b_{1} \\oplus b_{0},\n$$\n其中 $\\oplus$ 表示异或（XOR）运算。\n\n给定二进制指针 $b_{2}b_{1}b_{0} = 101$，我们有 $b_{2} = 1$，$b_{1} = 0$ 和 $b_{0} = 1$。计算每个格雷码比特：\n$$\ng_{2} = 1, \\quad g_{1} = 1 \\oplus 0 = 1, \\quad g_{0} = 0 \\oplus 1 = 1.\n$$\n因此，3 比特的格雷码是 $111$，对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1910272"}, {"introduction": "在理解了格雷码的原理之后，下一步是将其在硬件中实现。本练习将引导你从数学转换推导出组合逻辑电路，设计一个将二进制计数器输出转换为格雷码的电路。这是将理论知识转化为实际数字逻辑设计的重要一步，让你能够为自己的FIFO控制器构建必要的硬件模块 [@problem_id:1910274]。", "problem": "在数字系统中，异步先进先出（FIFO）缓冲器常用于在工作于不同、非同步时钟的电路之间安全地传输数据。为了管理读写操作，FIFO使用指针，这些指针是指向其内存阵列的地址。当这些指针从一个时钟域传递到另一个时钟域以检查满或空的状态时，如果指针值的多个比特位同时发生变化，就可能发生同步错误。\n\n为了缓解这个问题，指针通常使用格雷码（Gray code）来实现。格雷码是一种二进制计数系统，其中两个连续的数值仅有一位不同。在典型设计中，一个易于实现的标准二进制计数器会生成地址序列。然后，需要一个组合逻辑电路来将二进制计数器的输出转换为格雷码，之后指针值才能用于跨域比较。\n\n考虑一个需要2位地址指针的小型异步FIFO。来自计数器的二进制输出表示为 $B_1 B_0$，其中 $B_1$ 是最高有效位。所需的相应2位格雷码输出表示为 $G_1 G_0$，其中 $G_1$ 是最高有效位。\n\n以下哪项表示了用二进制输入 $B_1$ 和 $B_0$ 表示格雷码输出 $G_1$ 和 $G_0$ 的正确布尔表达式集？在下面的选项中，符号 $\\oplus$ 代表异或（XOR）运算，而 $+$ 代表逻辑或（OR）运算。\n\nA) $G_1 = B_1$; $G_0 = B_1 \\oplus B_0$\n\nB) $G_1 = B_1 \\oplus B_0$; $G_0 = B_0$\n\nC) $G_1 = B_1$; $G_0 = B_1 + B_0$\n\nD) $G_1 = B_1$; $G_0 = (B_1 \\oplus B_0)'$\n\nE) $G_1 = B_1 \\oplus B_0$; $G_0 = B_1$", "solution": "我们寻找能将2位二进制计数 $B_{1}B_{0}$ 映射到相应2位格雷码 $G_{1}G_{0}$ 的布尔表达式，其中连续的格雷码值仅相差一位。对于一个 $n$ 位的字 $B_{n-1}\\ldots B_{1}B_{0}$，标准的二进制到格雷码转换规则如下：\n$$\nG_{n-1} = B_{n-1}, \\quad G_{i} = B_{i+1} \\oplus B_{i} \\text{ for } i = 0,1,\\ldots,n-2.\n$$\n对于2位的情况（$n=2$），代入 $i=0$ 可得：\n$$\nG_{1} = B_{1}, \\quad G_{0} = B_{1} \\oplus B_{0}.\n$$\n为了验证此映射在二进制计数序列 $00 \\to 01 \\to 10 \\to 11$ 上确实生成了格雷码（即连续值之间仅有一位发生变化），我们进行如下检查：\n- 当 $B_{1}B_{0} = 00$ 时：$G_{1} = 0$，$G_{0} = 0 \\oplus 0 = 0$，因此 $G = 00$。\n- 当 $B_{1}B_{0} = 01$ 时：$G_{1} = 0$，$G_{0} = 0 \\oplus 1 = 1$，因此 $G = 01$。\n- 当 $B_{1}B_{0} = 10$ 时：$G_{1} = 1$，$G_{0} = 1 \\oplus 0 = 1$，因此 $G = 11$。\n- 当 $B_{1}B_{0} = 11$ 时：$G_{1} = 1$，$G_{0} = 1 \\oplus 1 = 0$，因此 $G = 10$。\n序列 $00 \\to 01 \\to 11 \\to 10$ 在每一步中仅改变一位，从而证实了其正确性。\n\n与选项进行比较，这对应于：\n$$\nG_{1} = B_{1}, \\quad G_{0} = B_{1} \\oplus B_{0},\n$$\n即选项A。", "answer": "$$\\boxed{A}$$", "id": "1910274"}, {"introduction": "拥有了可靠的指针同步机制后，我们就可以构建FIFO的核心控制逻辑了。这个实践将介绍一种常用的FIFO设计技巧，即使用比地址深度所需多一位的指针来区分“满”和“空”状态。你的任务是根据指针的比较来推导“写使能”信号的逻辑，这对于防止FIFO写溢出至关重要，是设计健壮系统的关键一环 [@problem_id:1910302]。", "problem": "您是一名初级数字逻辑设计师，任务是为异步先进先出 (FIFO) 缓冲器创建部分控制逻辑。该 FIFO 具有 $D=2^N$ 个数据字的存储深度。\n\n为了正确管理缓冲器的状态并防止跨时钟域的上溢或下溢，该 FIFO 使用 $(N+1)$ 位的二进制指针：一个写指针 `wr_ptr` 和一个读指针 `rd_ptr`。这些指针的范围从 $0$ 到 $2^{N+1}-1$。\n\n在写时钟域内，为您提供以下信号：\n- `wr_req`：一个高电平有效信号。当 `wr_req` 为逻辑 '1' 时，表示有外部请求向 FIFO 写入数据。\n- `wr_ptr[N:0]`：当前的 $(N+1)$ 位写指针。\n- `rd_ptr_sync[N:0]`：$(N+1)$ 位的读指针，该指针已从读时钟域安全同步到写时钟域。\n\nFIFO 的状态通过比较 `wr_ptr` 和 `rd_ptr_sync` 根据以下规则确定：\n- **满条件**：当指针的最高有效位（MSB，即第 $N$ 位）不同，但所有较低的 $N$ 位（从第 $N-1$ 位到第 $0$ 位）都相同时，FIFO 被认为是满的。\n- **空条件**：当写指针和同步后的读指针完全相同时（`wr_ptr == rd_ptr_sync`），FIFO 被认为是空的。\n\n您的任务是推导内部写使能信号 `wr_en` 的逻辑。`wr_en` 当且仅当有外部写请求（`wr_req` 为 '1'）并且 FIFO 未满时，应被置为有效（逻辑 '1'）。\n\n以 `wr_req` 以及指针 `wr_ptr` 和 `rd_ptr_sync` 的各个位的形式，推导 `wr_en` 的简化布尔表达式。", "solution": "设 $\\mathrm{wr\\_ptr}_{i}$ 和 $\\mathrm{rd\\_ptr\\_sync}_{i}$ 分别表示写指针和同步读指针的第 $i$ 位，其中 $i \\in \\{0,1,\\ldots,N\\}$ 且 $i=N$ 为最高有效位。根据所述规则：\n- 满条件：\n$$\n\\text{FULL}=\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\land \\bigwedge_{i=0}^{N-1}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n- 空条件：\n$$\n\\text{EMPTY}=\\bigwedge_{i=0}^{N}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n内部写使能信号当且仅当有外部写请求且 FIFO 未满时才必须置为有效，因此\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land \\lnot(\\text{FULL}).\n$$\n对 $\\lnot(\\text{FULL})$ 应用德摩根定律可得\n$$\n\\lnot(\\text{FULL})=\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n因此，\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right).\n$$\n此表达式表明，当有写请求，并且最高有效位相等，或者至少有一个较低的 $N$ 位不同时，写操作被使能，这恰好是满条件的否定。", "answer": "$$\\boxed{\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right)}$$", "id": "1910302"}]}