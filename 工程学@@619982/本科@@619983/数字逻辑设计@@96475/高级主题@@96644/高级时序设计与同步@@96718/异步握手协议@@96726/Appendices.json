{"hands_on_practices": [{"introduction": "在数字系统中，任何有序的行为都可以用有限状态机 (FSM) 来精确描述。将协议的行为从直观的状态图转化为严谨的状态表，是实现硬件逻辑电路的第一步。这个练习将帮助你掌握这一基本功，通过为一个经典的四相握手协议接收端构建状态表，将抽象的协议规则具体化。[@problem_id:1910555]", "problem": "在异步数据传输系统中，接收单元必须使用握手协议与发送方进行协调。考虑一个实现四相（也称为归零或RZ）握手协议的简单接收器。该接收器的行为由来自发送方的单个输入信号 `Req`（请求）控制，并向发送方产生单个输出信号 `Ack`（确认）。\n\n该接收器时序电路的行为可以用一个包含两个状态的状态图来描述：`S0`（空闲）和 `S1`（数据锁存）。系统的初始状态是 `S0`。状态转换和输出定义如下：\n\n1.  在状态 `S0` 中，`Ack` 信号保持为低电平（逻辑 0）。只要 `Req` 为低电平（逻辑 0），接收器就保持在 `S0` 状态。\n2.  当 `Req` 信号变为高电平（逻辑 1）时，接收器从状态 `S0` 转换到状态 `S1`。\n3.  进入状态 `S1` 后，`Ack` 信号被驱动为高电平（逻辑 1）。只要 `Req` 为高电平，接收器就保持在 `S1` 状态。\n4.  当 `Req` 信号返回低电平（逻辑 0）时，接收器从状态 `S1` 转换回状态 `S0`，从而完成握手周期。\n\n你的任务是为这个 Moore 型有限状态机创建对应的状态表。状态表系统地列出了当前状态和输入的每一种可能组合所对应的下一状态和输出。\n\n下列哪个选项正确表示了所描述的四相握手接收器的状态表？\n\n**A.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      1       |\n|      `S0`     |      1      |    `S1`    |      1       |\n|      `S1`     |      0      |    `S0`    |      0       |\n|      `S1`     |      1      |    `S1`    |      0       |\n\n**B.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S1`    |      0       |\n|      `S1`     |      0      |    `S0`    |      1       |\n|      `S1`     |      1      |    `S1`    |      1       |\n\n**C.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S1`    |      0       |\n|      `S0`     |      1      |    `S0`    |      0       |\n|      `S1`     |      0      |    `S1`    |      1       |\n|      `S1`     |      1      |    `S0`    |      1       |\n\n**D.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S0`    |      1       |\n|      `S1`     |      0      |    `S1`    |      0       |\n|      `S1`     |      1      |    `S1`    |      1       |", "solution": "Moore 型有限状态机的输出仅由当前状态决定。根据描述：在状态 $S0$ 中，输出 $Ack$ 保持为低电平，在状态 $S1$ 中，输出 $Ack$ 保持为高电平。因此，\n$$Ack(S0)=0,\\quad Ack(S1)=1.$$\n状态转换由输入 $Req$ 控制，如下所示：当 $Req=0$ 时保持在 $S0$ 状态，当 $Req=1$ 时转换到 $S1$ 状态；当 $Req=1$ 时保持在 $S1$ 状态，当 $Req=0$ 时转换到 $S0$ 状态。因此，次态函数满足\n$$\\text{Next}(S0,Req=0)=S0,\\quad \\text{Next}(S0,Req=1)=S1,$$\n$$\\text{Next}(S1,Req=1)=S1,\\quad \\text{Next}(S1,Req=0)=S0.$$\n将这些与 Moore 型输出相结合，得到所需的四行：\n- 当前状态 $S0$，$Req=0$：下一状态 $S0$，$Ack=0$。\n- 当前状态 $S0$，$Req=1$：下一状态 $S1$，$Ack=0$。\n- 当前状态 $S1$，$Req=0$：下一状态 $S0$，$Ack=1$。\n- 当前状态 $S1$，$Req=1$：下一状态 $S1$，$Ack=1$。\n与所给选项比较，只有选项 B 完全匹配这些下一状态和输出关系。", "answer": "$$\\boxed{B}$$", "id": "1910555"}, {"introduction": "在设计高速数字系统时，性能是关键指标。异步握手协议虽然灵活，但其完成一次数据传输所需的时间直接影响系统吞吐量。本练习将引导你分解四相握手协议的每一个步骤，并考虑逻辑延迟和线路延迟，从而精确计算出完成一次完整事务所需要的最短时间。[@problem_id:1910561]", "problem": "在现代片上系统 (SoC) 的设计中，中央处理器 (CPU) 与一个专门的神经处理单元 (NPU) 进行通信，以分载机器学习计算。它们之间的通信链路使用一种异步四相归零 (RZ) 握手协议，该协议由两个信号控制：`VALID`，由 CPU（发送方）置位，用于指示数据可用；以及 `READY`，由 NPU（接收方）置位，用于确认数据已被读取。\n\n一个完整的事务周期由四次不同的信号转换组成：\n1. CPU 将 `VALID` 置为高电平。\n2. NPU 响应，将 `READY` 置为高电平。\n3. CPU 看到 `READY` 为高电平后，将 `VALID` 复位为低电平。\n4. NPU 看到 `VALID` 为低电平后，将 `READY` 复位为低电平，使系统返回其初始状态。\n\n该链路的时序特性由以下延迟决定：\n- 发送端逻辑延迟 (`t_sl`): CPU 逻辑处理输入变化并置位或复位 `VALID` 信号所需的时间为 120 ps。\n- 接收端逻辑延迟 (`t_rl`): NPU 逻辑处理输入变化并置位或复位 `READY` 信号所需的时间为 150 ps。\n- 互连传播延迟 (`t_wire`): `VALID` 或 `READY` 线路上的信号变化沿导线从 CPU 传到 NPU（或反之）所需的时间为 80 ps。\n\n计算完成一次完整数据事务所需要的最小总时间。该时间从 CPU 发起传输（开始置位 `VALID` 信号）的时刻开始测量，直到系统完全复位到初始状态并准备好开始下一次事务为止。请以纳秒 (ns) 为单位表示最终答案，并四舍五入到两位有效数字。", "solution": "我们将此四相握手过程建模为一系列因果相关的事件，每个事件都会在驱动端产生逻辑延迟，并通过互连进行传播。设 $t_{sl}$ 为发送端 (CPU) 的逻辑延迟， $t_{rl}$ 为接收端 (NPU) 的逻辑延迟， $t_{\\text{wire}}$ 为互连传播延迟。总事务时间从 CPU 开始置位 $VALID$ 时算起，直到 CPU 观察到 $READY$ 被复位且两个信号都回到低电平为止。\n\n分步时序计算：\n1) CPU 置位 $VALID$：CPU 逻辑延迟 $t_{sl}$，然后 $VALID$ 信号的边沿在 $t_{\\text{wire}}$ 时间内传播到 NPU。\n步骤1后的累计时间：$t_{sl} + t_{\\text{wire}}$。\n\n2) NPU 置位 $READY$：NPU 逻辑延迟 $t_{rl}$，然后 $READY$ 信号的边沿在 $t_{\\text{wire}}$ 时间内传播到 CPU。\n步骤2的额外时间：$t_{rl} + t_{\\text{wire}}$。\n步骤2后的累计时间：$t_{sl} + t_{\\text{wire}} + t_{rl} + t_{\\text{wire}}$。\n\n3) CPU 复位 $VALID$：在 CPU 端看到 $READY$ 为高电平后，CPU 产生逻辑延迟 $t_{sl}$ 以将 $VALID$ 驱动为低电平，然后 $VALID$ 的低电平信号在 $t_{\\text{wire}}$ 时间内传播到 NPU。\n步骤3的额外时间：$t_{sl} + t_{\\text{wire}}$。\n步骤3后的累计时间：$t_{sl} + t_{\\text{wire}} + t_{rl} + t_{\\text{wire}} + t_{sl} + t_{\\text{wire}}$。\n\n4) NPU 复位 $READY$：在 NPU 端看到 $VALID$ 为低电平后，NPU 产生逻辑延迟 $t_{rl}$ 以将 $READY$ 驱动为低电平，然后 $READY$ 的低电平信号在 $t_{\\text{wire}}$ 时间内传播回 CPU（确保发起方看到握手完成，系统准备好进行下一次事务）。\n步骤4的额外时间：$t_{rl} + t_{\\text{wire}}$。\n\n因此，最小总时间为\n$$\nT_{\\text{min}} \\;=\\; 2\\,t_{sl} \\;+\\; 2\\,t_{rl} \\;+\\; 4\\,t_{\\text{wire}}.\n$$\n\n代入给定值（单位为皮秒），然后转换为纳秒：\n$$\nT_{\\text{min}} \\;=\\; 2\\cdot 120 \\;+\\; 2\\cdot 150 \\;+\\; 4\\cdot 80 \\;=\\; 240 \\;+\\; 300 \\;+\\; 320 \\;=\\; 860 \\text{ ps} \\;=\\; 0.86 \\text{ ns}.\n$$\n四舍五入到两位有效数字，结果是 $0.86$ ns。", "answer": "$$\\boxed{0.86}$$", "id": "1910561"}, {"introduction": "现实世界的系统必须足够“鲁棒”，以应对各种异常情况，例如通信伙伴无响应。本练习将挑战你设计一个带有超时机制的四相握手协议发送端状态机，这在航空电子设备等高可靠性应用中至关重要。你将学习如何通过增加错误处理状态和逻辑，来构建一个不仅能正常工作，还能安全处理故障的系统。[@problem_id:1910509]", "problem": "在一个深空探测器的航空电子系统中，中央处理器需要与一个专用的低温传感器接口单元 (CSIU) 通信。该通信遵循四相异步握手协议。为确保在 CSIU 无响应时系统的可靠性，需要一个超时机制。\n\n您的任务是设计用于控制此数据传输的发送端 Mealy 型有限状态机 (FSM)。该 FSM 具有以下输入和输出：\n\n**输入：**\n*   `Go`：来自中央处理器的单位信号。从0到1的跳变启动一次数据传输请求。在整个事务期间，该信号保持为1。\n*   `Ack`：来自 CSIU 的单位确认信号。\n*   `Timeout`：来自外部计时器的单位信号。如果在发出请求后的预定时间内 `Ack` 未被置位，则该信号置位为1。保证当 `Ack` 为1时，`Timeout` 不会为1。\n\n**输出：**\n*   `Req`：发送到 CSIU 的单位请求信号。\n*   `DataValid`：指示总线（此处未明確建模）上的数据有效的单位信号。对于此协议，`DataValid` 与 `Req` 一同置位和复位。\n*   `Error`：向中央处理器标志超时事件的单位信号。\n*   `StartTimer`：启动外部计时器的单位脉冲输出。它在单个状态转换期间置位。\n\n该 FSM 通过四个定义的状态运行：\n*   `S0` (空闲)：初始状态，等待 `Go` 信号。\n*   `S1` (等待 Ack)：请求已发送，FSM 正在等待 `Ack` 信号或 `Timeout`。\n*   `S2` (握手完成)：已收到 `Ack`，FSM 正在等待 CSIU 复位 `Ack` 以完成四相周期。\n*   `S3` (错误)：发生超时。FSM 保持在此状态，置位 `Error` 信号，直到被处理器复位。\n\n状态转换由以下符号描述：`CurrentState, (Go, Ack, Timeout) -> NextState, (Req, DataValid, Error, StartTimer)`，其中 `X` 表示无关条件。\n\n以下哪个选项正确描述了此 FSM 的一套完整且有效的转换规则？\n\nA.\n1. `S1, (X, 1, 0) -> S2, (0, 0, 0, 0)`\n2. `S1, (X, 0, 1) -> S3, (0, 0, 1, 0)`\n3. `S2, (0, 0, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S1, (1, 1, 0, 1)`\n\nB.\n1. `S1, (X, 1, 0) -> S2, (1, 1, 0, 0)`\n2. `S1, (X, 0, 1) -> S3, (0, 0, 0, 0)`\n3. `S2, (0, 0, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S1, (1, 1, 0, 0)`\n\nC.\n1. `S1, (X, 1, 0) -> S0, (0, 0, 0, 0)`\n2. `S1, (X, 0, 1) -> S0, (0, 0, 1, 0)`\n3. `S2, (0, 0, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S2, (1, 1, 0, 1)`\n\nD.\n1. `S1, (X, 1, 0) -> S2, (0, 0, 0, 0)`\n2. `S1, (X, 0, 0) -> S3, (0, 0, 1, 0)`\n3. `S2, (1, 1, 0) -> S0, (0, 0, 0, 0)`\n4. `S2, (1, 0, 0) -> S1, (1, 1, 0, 1)`", "solution": "我们首先重述所需的四相发送端行为。在归零握手中，发送端置位 Req（及其附带的 DataValid）以请求服务，等待接收端的 Ack，然后在看到 Ack 置位后，发送端复位 Req（和 DataValid），最后等待接收端复位 Ack 以完成周期。如果 Ack 未在规定时间内到达，超时保护必须将系统带入错误状态。StartTimer 输出必须是一个单转换脉冲，在发出新请求时精确地启动外部计时器。\n\n由此，发送端必要的 Mealy 型转换和输出如下：\n1) 在 S1 (等待 Ack) 中：如果 Ack 变为1（保证当 Ack 为1时 Timeout 为0），发送端必须转移到 S2 (握手完成) 并立即复位 Req 和 DataValid，以在接收到接收端的 Ack 后执行归零步骤。Error 必须为0，StartTimer 必须为0。这需要 S1, (X, 1, 0) -> S2, (0, 0, 0, 0)。\n2) 在 S1 中：如果 Timeout 在 Ack 仍为0时变为1，发送端必须进入 S3 (错误)，置位 Error，并复位 Req 和 DataValid。StartTimer 必须为0。这需要 S1, (X, 0, 1) -> S3, (0, 0, 1, 0)。\n3) 在 S2 (握手完成) 中：当 Ack 复位为0时，有两种子情况。如果 Go 为0（无新请求），发送端返回到空闲状态 S0，所有输出均复位。这需要 S2, (0, 0, 0) -> S0, (0, 0, 0, 0)。\n4) 在 S2 中：当 Ack 复位为0且 Go 为1时（希望立即发出新请求），发送端必须立即通过置位 Req 和 DataValid，发出单个 StartTimer 脉冲来开始新的事务，并返回到 S1 等待下一个 Ack。这需要 S2, (1, 0, 0) -> S1, (1, 1, 0, 1)。\n\n现在与选项进行比较：\n- 选项 A 恰好具有这四个转换和输出：\n  1. S1, (X, 1, 0) -> S2, (0, 0, 0, 0)：在收到 Ack 后正确复位 Req/DataValid。\n  2. S1, (X, 0, 1) -> S3, (0, 0, 1, 0)：正确的超时转入错误状态。\n  3. S2, (0, 0, 0) -> S0, (0, 0, 0, 0)：当 Go 为0时正确完成并返回空闲状态。\n  4. S2, (1, 0, 0) -> S1, (1, 1, 0, 1)：通过 StartTimer 脉冲正确地立即重启。\n- 选项 B 是不正确的，因为它在收到 Ack 后保持 Req 和 DataValid 被置位（规则1），在超时时未能置位 Error（规则2），并在立即重启时省略了 StartTimer 脉冲（规则4）。\n- 选项 C 是不正确的，因为它在收到 Ack 和超时时从 S1 跳转到 S0 而不是 S2（规则1和2），并且在发出新请求时错误地停留在 S2（规则4）。\n- 选项 D 是不正确的，因为它在没有 Timeout 的情况下发出错误信号（规则2），并在 Ack 仍为1时错误地从 S2 转换到 S0（规则3），违反了四相完成要求。\n\n因此，只有选项 A 正确且完整地匹配了指定的带超时的发送端 FSM 所需的转换和输出。", "answer": "$$\\boxed{A}$$", "id": "1910509"}]}