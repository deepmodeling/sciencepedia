{"hands_on_practices": [{"introduction": "第一个练习是对基本概念的检验。它要求你将基-2 Booth 编码规则应用于一个以二进制补码表示的负数。这个实践旨在巩固算法的核心机制：通过检查相邻的位来生成集合$\\{-1, 0, +1\\}$中的重编码数字。[@problem_id:1916755]", "problem": "在数字系统中，布斯算法（Booth's algorithm）是一种乘法算法，用于将两个以二进制补码表示的有符号二进制数相乘。该算法基2版本的一个关键步骤是使用数字集$\\{-1, 0, +1\\}$将乘数重编码为一种新的表示形式。这种重编码通过减少需要相加的部分积的数量，显著加快了乘法速度。\n\n考虑十进制数 $-5$ 的4位二进制补码表示。您的任务是确定其基2布斯重编码表示。重编码后的表示应为一个四位数字序列$b_3b_2b_1b_0$，其中$b_i$对应于原始比特位$i$，而$i=3$是最高有效位。请将您的答案表示为一个由四个数字组成的有序序列，这些数字来自集合$\\{-1, 0, 1\\}$，并按从最高有效位 ($b_3$) 到最低有效位 ($b_0$) 的顺序列出。", "solution": "我们首先写出十进制数 $-5$ 的4位二进制补码表示。正值 $+5$ 的4位无符号二进制表示是 $0101$。取其二进制补码以得到 $-5$：\n$$\n0101 \\xrightarrow{\\text{invert}} 1010 \\xrightarrow{+1} 1011,\n$$\n因此，乘数位为$y_{3}y_{2}y_{1}y_{0}=1011$，其中$y_{3}=1$，$y_{2}=0$，$y_{1}=1$，$y_{0}=1$。\n\n对于基2布斯重编码，我们附加一个虚拟位$y_{-1}=0$，并将位置$i$的重编码数字定义为\n$$\nb_{i}=y_{i-1}-y_{i}, \\quad i=0,1,2,3,\n$$\n这会产生$\\{-1,0,1\\}$中的数字，并对应于标准决策表：$(y_{i},y_{i-1})=(0,0)$或$(1,1)\\Rightarrow b_{i}=0$，$(0,1)\\Rightarrow b_{i}=+1$，$(1,0)\\Rightarrow b_{i}=-1$。\n\n计算每个$b_{i}$：\n$$\nb_{0}=y_{-1}-y_{0}=0-1=-1, \\quad b_{1}=y_{0}-y_{1}=1-1=0,\n$$\n$$\nb_{2}=y_{1}-y_{2}=1-0=1, \\quad b_{3}=y_{2}-y_{3}=0-1=-1.\n$$\n\n从最高有效位到最低有效位排列，基2布斯重编码数字为$b_{3}b_{2}b_{1}b_{0}=(-1,\\,1,\\,0,\\,-1)$。\n\n作为检验，其加权和再现了原始值：\n$$\nb_{3}2^{3}+b_{2}2^{2}+b_{1}2^{1}+b_{0}2^{0}=(-1)\\cdot 8+(1)\\cdot 4+0\\cdot 2+(-1)\\cdot 1=-5,\n$$\n与目标数值一致。", "answer": "$$\\boxed{\\begin{pmatrix}-1 & 1 & 0 & -1\\end{pmatrix}}$$", "id": "1916755"}, {"introduction": "在你练习了如何对数字进行编码之后，这个练习将挑战你的逆向思维。给定一个基-2 Booth 编码字符串，你的任务是重建原始的二进制数。这个过程会加深你对原始比特$b_i$和编码后数字$y_i$之间数学关系$y_i = b_{i-1} - b_i$的理解，并将其转化为一个逐步重建的过程。[@problem_id:1916767]", "problem": "在数字计算机算术中，基2 Booth算法是一种乘法算法，它将两个用二进制补码表示的有符号二进制数相乘。该算法将一个$n$位乘数$B = b_{n-1}b_{n-2}...b_1b_0$重编码为一个$n$位数字串$Y = y_{n-1}y_{n-2}...y_1y_0$。假定在最低有效位$b_0$的右边有一个虚拟位$b_{-1}=0$。为了在每个位置$i$（从$0$到$n-1$）生成重编码位$y_i$，该算法会检查位$b_i$及其右边的位$b_{i-1}$。重编码位$y_i$可以从$\\{-1, 0, +1\\}$中取值，具体规则基于数对$(b_i, b_{i-1})$如下：\n\n*   $(0, 0) \\rightarrow y_i = 0$\n*   $(0, 1) \\rightarrow y_i = +1$\n*   $(1, 0) \\rightarrow y_i = -1$\n*   $(1, 1) \\rightarrow y_i = 0$\n\n假设一个8位二进制补码数使用该算法进行了重编码，得到的重编码数字串由序列$(y_7, y_6, y_5, y_4, y_3, y_2, y_1, y_0) = (0, +1, 0, -1, 0, +1, 0, -1)$表示。确定原始的8位数。请以8位二进制字符串的形式提供您的答案。", "solution": "Booth重编码表意味着关系式\n$$\ny_{i}=b_{i-1}-b_{i},\n$$\n其中虚拟位$b_{-1}=0$。求解$b_{i}$可得\n$$\nb_{i}=b_{i-1}-y_{i}.\n$$\n已知$(y_{7},y_{6},y_{5},y_{4},y_{3},y_{2},y_{1},y_{0})=(0,+1,0,-1,0,+1,0,-1)$，并从$b_{-1}=0$开始，依次计算：\n$$\nb_{0}=b_{-1}-y_{0}=0-(-1)=1,\n$$\n$$\nb_{1}=b_{0}-y_{1}=1-0=1,\n$$\n$$\nb_{2}=b_{1}-y_{2}=1-(+1)=0,\n$$\n$$\nb_{3}=b_{2}-y_{3}=0-0=0,\n$$\n$$\nb_{4}=b_{3}-y_{4}=0-(-1)=1,\n$$\n$$\nb_{5}=b_{4}-y_{5}=1-0=1,\n$$\n$$\nb_{6}=b_{5}-y_{6}=1-(+1)=0,\n$$\n$$\nb_{7}=b_{6}-y_{7}=0-0=0.\n$$\n因此，原始的8位数是$b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}=00110011$。", "answer": "$$\\boxed{00110011}$$", "id": "1916767"}, {"introduction": "在基-2 原理的基础上，本练习将介绍效率更高的基-4 Booth 算法。通过检查重叠的三位比特组，该方法能进一步减少部分积的数量，这是现代乘法器中的一项关键优化。这个练习将考验你应用基-4 分组和编码规则，从集合$\\{-2, -1, 0, 1, 2\\}$中生成相应数字的能力。[@problem_id:1916743]", "problem": "一位数字系统工程师正在为一款新型微处理器的算术逻辑单元（ALU）设计一个高速硬件乘法器。为了优化性能，该设计采用了Radix-4 Booth算法，该算法可以减少乘法所需的部分积数量。您的任务是确定一个特定的8位乘数的正确Radix-4 Booth编码。\n\n给定乘数$Y$，表示为一个8位二进制补码数$Y = 01011011_2$，请确定表示该数的重编码数字序列$(d_3, d_2, d_1, d_0)$。该序列应从最高有效位（$d_3$）到最低有效位（$d_0$）排序。\n\n以下哪个选项代表了正确的序列？\n\nA. `1, 2, -1, -1`\n\nB. `1, 1, 2, -1`\n\nC. `-1, -1, 2, 1`\n\nD. `0, 1, 2, -1, -1`\n\nE. `1, -2, 1, 1`", "solution": "我们得到8位二进制补码乘数$Y=01011011_{2}$，其各位标记为$y_{7}\\dots y_{0}$，因此\n$$\ny_{7}=0,\\; y_{6}=1,\\; y_{5}=0,\\; y_{4}=1,\\; y_{3}=1,\\; y_{2}=0,\\; y_{1}=1,\\; y_{0}=1,\n$$\n并且为了进行Radix-4 Booth编码，我们附加一位$y_{-1}=0$。\n\n在Radix-4 Booth编码中，我们对$i=0,1,2,3$形成重叠的三位数组$(y_{2i+1},y_{2i},y_{2i-1})$，并使用标准规则将每个三位数组映射到一个数字$d_{i}\\in\\{-2,-1,0,1,2\\}$：\n- $000\\to 0$, $001\\to 1$, $010\\to 1$, $011\\to 2$,\n- $100\\to -2$, $101\\to -1$, $110\\to -1$, $111\\to 0$。\n\n计算每一组：\n- 对于$i=0$：$(y_{1},y_{0},y_{-1})=(1,1,0)$，即$110\\to d_{0}=-1$。\n- 对于$i=1$：$(y_{3},y_{2},y_{1})=(1,0,1)$，即$101\\to d_{1}=-1$。\n- 对于$i=2$：$(y_{5},y_{4},y_{3})=(0,1,1)$，即$011\\to d_{2}=2$。\n- 对于$i=3$：$(y_{7},y_{6},y_{5})=(0,1,0)$，即$010\\to d_{3}=1$。\n\n因此，从最高有效位到最低有效位的序列是$(d_{3},d_{2},d_{1},d_{0})=(1,2,-1,-1)$。\n\n作为一致性检查，从这些数字重构$Y$可得\n$$\nY=d_{0}2^{0}+d_{1}2^{2}+d_{2}2^{4}+d_{3}2^{6}=-1-4+32+64=91,\n$$\n这与无符号解释下的$01011011_{2}=91$相匹配，并且由于$y_{7}=0$，这也与二进制补码表示一致。因此，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1916743"}]}