{"hands_on_practices": [{"introduction": "掌握任何算法的第一步都是通过具体示例，手动逐步跟踪其执行过程。本练习将指导您完成一个完整的恢复除法运算，帮助您熟悉寄存器（如累加器 $A$、商寄存器 $Q$ 和除数寄存器 $M$）在每个周期中的变化。通过这个实践，您将为理解更复杂的数字电路设计打下坚实的基础。[@problem_id:1958382]", "problem": "一个简单的算术逻辑单元 (ALU) 被设计用来执行无符号二进制除法，采用的是恢复余数除法算法。该 ALU 使用 4 位架构。考虑将被除数 9 除以除数 3 的运算。\n\n该硬件由三个主要的 4 位寄存器组成：\n-   **M**：除数寄存器，用除数的值进行初始化。\n-   **Q**：商寄存器，用被除数的值进行初始化。\n-   **A**：累加器寄存器，初始化为零。\n\n恢复余数除法算法的执行周期数等于位数，在本例中为 4。每个周期的步骤如下：\n1.  对由 A 和 Q（`A` 在前，`Q` 在后）拼接而成的 8 位寄存器对执行逻辑左移。\n2.  从 A 寄存器中减去 M 寄存器中的值 ($A \\leftarrow A - M$)。\n3.  检查 A 寄存器的最高有效位 (MSB)。\n    -   如果 A 的 MSB 为 1，则将 Q 的最低有效位 (LSB) 置为 0，并通过将 M 加回到 A 来恢复 A 的值 ($A \\leftarrow A + M$)。\n    -   如果 A 的 MSB 为 0，则将 Q 的 LSB 置为 1。\n\n对 9（被除数）除以 3（除数）的运算，手动追踪此算法的执行过程。确定累加器 (A) 寄存器（存放余数）和商 (Q) 寄存器（存放商）中所包含的最终二进制值。\n\n以一对 4 位二进制字符串的形式提供您的答案，按顺序分别表示 A 和 Q 的最终值。", "solution": "我们使用 4 位寄存器进行无符号恢复余数除法。将被除数和除数编码为二进制，即 $Q=1001$（代表 $9$）、$M=0011$（代表 $3$），并初始化 $A=0000$。对 $A$ 的算术运算以 4 位二进制补码形式进行，以便 MSB 在减法后能指示符号。每个周期执行：(i) 对拼接对 $(A:Q)$ 进行逻辑左移，(ii) $A \\leftarrow A - M$，(iii) 如果 $\\text{MSB}(A)=1$，则将 $Q$ 的 LSB 置为 $0$ 并恢复 $A \\leftarrow A+M$，否则将 $Q$ 的 LSB 置为 $1$。我们执行 4 个周期。\n\n周期 1：\n左移 $(A:Q)$：从 $A=0000$, $Q=1001$ 变为 $A=0001$, $Q=0010$。\n减法：$A \\leftarrow 0001 - 0011 = 1110$（负数，MSB$=1$）。\n恢复并置 $Q_{0}=0$：$A \\leftarrow 1110 + 0011 = 0001$， $Q$ 保持为 $0010$。\n\n周期 2：\n左移 $(A:Q)$：从 $A=0001$, $Q=0010$ 变为 $A=0010$, $Q=0100$。\n减法：$A \\leftarrow 0010 - 0011 = 1111$（负数，MSB$=1$）。\n恢复并置 $Q_{0}=0$：$A \\leftarrow 1111 + 0011 = 0010$， $Q$ 保持为 $0100$。\n\n周期 3：\n左移 $(A:Q)$：从 $A=0010$, $Q=0100$ 变为 $A=0100$, $Q=1000$。\n减法：$A \\leftarrow 0100 - 0011 = 0001$（非负数，MSB$=0$）。\n置 $Q_{0}=1$：$Q \\leftarrow 1001$；无需恢复，$A=0001$。\n\n周期 4：\n左移 $(A:Q)$：从 $A=0001$, $Q=1001$ 变为 $A=0011$, $Q=0010$。\n减法：$A \\leftarrow 0011 - 0011 = 0000$（非负数，MSB$=0$）。\n置 $Q_{0}=1$：$Q \\leftarrow 0011$；无需恢复，$A=0000$。\n\n经过 4 个周期后，最终寄存器的值为 $A=0000$（余数）和 $Q=0011$（商），这对应于 $9 \\div 3 = 3$ 余 $0$。", "answer": "$$\\boxed{\\begin{pmatrix}0000 & 0011\\end{pmatrix}}$$", "id": "1958382"}, {"introduction": "在了解了恢复除法之后，让我们来探索一种更高效的替代方案：不恢复除法。不恢复除法算法通过巧妙地处理减法后的负余数来避免“恢复”加法操作，从而可能加快计算速度。这个练习将要求您跟踪不恢复除法算法的执行过程，以便将其与恢复除法进行比较，并理解其独特的逻辑。[@problem_id:1958432]", "problem": "一个微处理器的算术逻辑单元 (ALU) 被设计用于使用 4 位不恢复余数算法执行无符号整数除法。该 ALU 使用一个 4 位累加器寄存器 `A`（初始化为零）、一个 4 位商寄存器 `Q`（初始存有被除数）和一个 4 位除数寄存器 `M`。\n\n该算法分 `n` 个周期进行，其中 `n` 是位数。在每个周期中，执行以下步骤：\n1. 检查累加器 `A` 的符号位（最高有效位）。\n2. 如果符号位为 0（正），则组合寄存器 $(A,Q)$ 左移一位，然后从 `A` 中减去除数 `M`。\n3. 如果符号位为 1（负），则组合寄存器 $(A,Q)$ 左移一位，然后将除数 `M` 加到 `A`。\n4. `A` 的新符号位决定 `Q` 的新最低有效位：如果新符号位为 0，则该位置为 1；如果新符号位为 1，则该位置为 0。\n\n你的任务是追踪该算法在被除数为 13、除数为 3 时的执行过程。\n\n以下哪个选项正确表示了四个周期中每个周期结束时寄存器 `A` 和 `Q` 的二进制内容？报告的寄存器状态应为在四个周期完成后、进行任何可能需要的最终余数校正步骤*之前*的状态。\n\nA. 周期 1: A=1110, Q=1010; 周期 2: A=0000, Q=0101; 周期 3: A=1101, Q=1010; 周期 4: A=1110, Q=0100\n\nB. 周期 1: A=0001, Q=1010; 周期 2: A=0000, Q=0101; 周期 3: A=0000, Q=1010; 周期 4: A=0001, Q=0100\n\nC. 周期 1: A=1110, Q=1010; 周期 2: A=0000, Q=0101; 周期 3: A=1110, Q=0100; 周期 4: A=1111, Q=1000\n\nD. 周期 1: A=1110, Q=1010; 周期 2: A=1101, Q=0101; 周期 3: A=1101, Q=1010; 周期 4: A=1110, Q=0101", "solution": "我们使用给定的 4 位不恢复余数除法算法，累加器 $A$ 初始化为 $0000$，商寄存器 $Q$ 初始化为被除数 $1101$（即 $13$），除数寄存器 $M=0011$（即 $3$）。$A$ 中的所有算术运算均以 4 位二进制补码形式进行，组合的 $\\{A,Q\\}$ 作为一个 8 位寄存器进行左移。每次加/减法后， $A$ 的新符号位设置 $Q_{0}$：如果 $\\operatorname{sign}(A)=0$，则设置 $Q_{0}=1$，否则设置 $Q_{0}=0$。我们报告每个周期结束时（设置 $Q_{0}$ 之后）的寄存器内容，并且不应用任何最终的余数校正。\n\n初始化：$A=0000$, $Q=1101$, $M=0011$。\n\n周期 1：\n- $\\operatorname{sign}(A)=0$，所以左移 $\\{A,Q\\}$：$0000\\ 1101 \\to 0001\\ 1010$，因此 $A=0001$，$Q=1010$。\n- 由于原始 $\\operatorname{sign}(A)$ 为 $0$，计算 $A:=A-M$：$0001-0011=1110$（二进制补码）。\n- 新的 $\\operatorname{sign}(A)=1$，所以设置 $Q_{0}=0$。因此周期结束时：$A=1110$，$Q=1010$。\n\n周期 2：\n- $\\operatorname{sign}(A)=1$，所以左移 $\\{A,Q\\}$：$1110\\ 1010 \\to 1101\\ 0100$，因此 $A=1101$，$Q=0100$。\n- 由于原始 $\\operatorname{sign}(A)$ 为 $1$，计算 $A:=A+M$：$1101+0011=10000$，保留低 4 位，得 $A=0000$。\n- 新的 $\\operatorname{sign}(A)=0$，所以设置 $Q_{0}=1$。因此周期结束时：$A=0000$，$Q=0101$。\n\n周期 3：\n- $\\operatorname{sign}(A)=0$，所以左移 $\\{A,Q\\}$：$0000\\ 0101 \\to 0000\\ 1010$，因此 $A=0000$，$Q=1010$。\n- 由于原始 $\\operatorname{sign}(A)$ 为 $0$，计算 $A:=A-M$：$0000-0011=1101$。\n- 新的 $\\operatorname{sign}(A)=1$，所以设置 $Q_{0}=0$。因此周期结束时：$A=1101$，$Q=1010$。\n\n周期 4：\n- $\\operatorname{sign}(A)=1$，所以左移 $\\{A,Q\\}$：$1101\\ 1010 \\to 1011\\ 0100$，因此 $A=1011$，$Q=0100$。\n- 由于原始 $\\operatorname{sign}(A)$ 为 $1$，计算 $A:=A+M$：$1011+0011=1110$。\n- 新的 $\\operatorname{sign}(A)=1$，所以设置 $Q_{0}=0$。因此周期结束时：$A=1110$，$Q=0100$。\n\n周期结束时寄存器内容的序列是：\n- 周期 1：$A=1110$, $Q=1010$\n- 周期 2：$A=0000$, $Q=0101$\n- 周期 3：$A=1101$, $Q=1010$\n- 周期 4：$A=1110$, $Q=0100$\n\n这与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1958432"}, {"introduction": "真正的理解不仅仅是能够执行一个算法，更是要能预测和解释其在特定条件下的行为。这个挑战性的练习将检验您对恢复除法核心机制的深刻理解。您需要反向思考，找出一个特定的被除数和除数，使得算法在每个周期都必须执行“恢复”操作，这需要您精确把握触发恢复步骤的条件。[@problem_id:1958391]", "problem": "在数字计算机算术中，恢复除法算法是一种执行无符号整数除法的方法。考虑一个设计用于将一个4位无符号被除数（初始存放在寄存器 Q 中）除以一个4位无符号除数（存放在寄存器 M 中）的系统。该过程使用一个4位累加器寄存器 (A)，其初始值为零。该除法算法进行四个周期。\n\n每个周期包括以下微操作序列：\n1.  对由 A 和 Q 拼接而成的 8 位寄存器对执行逻辑左移。\n2.  从 A 寄存器中减去 M 寄存器中的值 ($A \\leftarrow A - M$)。\n3.  检查 A 寄存器的最高有效位 (MSB)。\n    -   如果 A 的 MSB 为 1（表示结果为负），则将 Q 的最低有效位 (LSB) 置为 0，并通过将 M 加回到 A 来恢复 A 的值 ($A \\leftarrow A + M$)。\n    -   如果 A 的 MSB 为 0（表示结果为非负），则将 Q 的 LSB 置为 1。\n\n下列哪对十进制被除数和除数（表示为4位无符号二进制数）在所有四个周期中的*每一个*周期都需要执行“恢复”步骤？\n\nA. 被除数 = 12, 除数 = 3\n\nB. 被除数 = 9, 除数 = 4\n\nC. 被除数 = 7, 除数 = 8\n\nD. 被除数 = 15, 除数 = 2", "solution": "设4位寄存器分别为 $A$（累加器）、$Q$（被除数）和 $M$（除数）。初始化 $A=0$，并设 $Q$ 的位为 $q_{3}q_{2}q_{1}q_{0}$（其中 $q_{3}$ 是最高有效位）。每个周期执行：\n- 将拼接后的 $AQ$ 左移一位，得到\n$$A \\leftarrow (A \\ll 1) + q_{3}^{(\\text{current})}, \\quad Q \\leftarrow (Q \\ll 1) \\text{ with } Q_{0}=0,$$\n其中 $q_{3}^{(\\text{current})}$ 是 $Q$ 当前的最高有效位。\n- 用二进制补码从 $A$ 中减去 $M$：\n$$A \\leftarrow A - M.$$\n- 如果 $A$ 的符号位为 $1$（即，在二进制补码中 $A - M < 0$），执行恢复步骤：\n$$A \\leftarrow A + M.$$\n\n关键观察：在第 $k$ 个周期的减法之前，$A$ 中的值等于原始被除数 $Q$ 的 $k$ 位前缀。这可以通过归纳法得出：\n- 对于 $k=1$，$A_{1}=(0 \\ll 1)+q_{3}=q_{3}$。\n- 如果 $A_{k}$ 等于 $k$ 位前缀 $q_{3}q_{2}\\dots q_{4-k}$，那么在下一次移位后，\n$$A_{k+1}=(A_{k} \\ll 1) + q_{3-k}$$\n这正是 $(k+1)$-位前缀 $q_{3}q_{2}\\dots q_{4-k}q_{3-k}$。\n\n因此，在第 $k$ 个周期，减法结果为负（符号位为 $1$）当且仅当 $A_{k} - M < 0$。由于 $A_{k}$ 和 $M$ 是 $\\{0,1,\\dots,15\\}$ 中的非负整数，这等价于不等式\n$$A_{k} < M.$$\n因此，当且仅当\n$$A_{1} < M,\\quad A_{2} < M,\\quad A_{3} < M,\\quad A_{4} < M,$$\n时，所有四个周期中的每一个周期都会发生恢复步骤，其中 $A_{k}$ 是被除数的 $k$ 位前缀。\n\n评估每个选项：\n\nA. 被除数 $12$（二进制为 $1100_{2}$），除数 $M=3$。\n- $A_{1}=1$，所以 $1<3$ 成立（恢复）。\n- $A_{2}=3$，所以 $3<3$ 不成立；$A_{2}-M=0$ 是非负数（不恢复）。\n因此不是所有周期都恢复。\n\nB. 被除数 $9$（二进制为 $1001_{2}$），除数 $M=4$。\n- $A_{1}=1<4$（恢复）。\n- $A_{2}=2<4$（恢复）。\n- $A_{3}=4$，所以 $4<4$ 不成立；非负数（不恢复）。\n因此不是所有周期都恢复。\n\nC. 被除数 $7$（二进制为 $0111_{2}$），除数 $M=8$。\n- $A_{1}=0<8$（恢复）。\n- $A_{2}=1<8$（恢复）。\n- $A_{3}=3<8$（恢复）。\n- $A_{4}=7<8$（恢复）。\n所有四个周期都需要恢复。\n\nD. 被除数 $15$（二进制为 $1111_{2}$），除数 $M=2$。\n- $A_{1}=1<2$（恢复）。\n- $A_{2}=3$，所以 $3<2$ 不成立；非负数（不恢复）。\n因此不是所有周期都恢复。\n\n只有选项 C 满足对于 $k=1,2,3,4$ 都有 $A_{k}<M$，因此它在每个周期都需要恢复步骤。", "answer": "$$\\boxed{C}$$", "id": "1958391"}]}