{"hands_on_practices": [{"introduction": "乘法在硬件层面的实现始于最基本的构建模块。这个练习将带你了解并行乘法器设计的第一步：生成部分积。通过计算一个特定尺寸的无符号乘法器所需与门的数量，你将能直观地理解乘法操作的硬件成本，并明白电路的复杂性是如何与输入数据的位数直接关联的。[@problem_id:1914114]", "problem": "一个数字逻辑设计团队正在为一个实时数字信号处理（DSP）应用创建一个专用的协处理器。该协处理器的一个关键组件是一个专用的硬件乘法器，设计用于执行两个无符号二进制数的乘法运算。该架构规定，第一个操作数（被乘数）是一个7位数字，第二个操作数（乘数）是一个5位数字。\n\n乘法过程采用标准的阵列乘法器方法实现。在此过程的第一阶段，会生成一组部分积。每个部分积是通过乘数的一位与被乘数的所有位之间进行逻辑“与”运算形成的。然后，这些部分积在后续阶段被送入一个加法器阵列中。\n\n假设用于生成这些部分积的硬件完全由双输入“与”门构成，计算此部分积生成阶段所需的双输入“与”门的总数。", "solution": "设被乘数有 $m$ 位，乘数有 $n$ 位。对于一个标准的阵列乘法器，部分积的各位是通过将被乘数的每一位与乘数的每一位进行“与”运算来生成的。如果 $a_{i}$ 表示被乘数的第 $i$ 位（其中 $i \\in \\{0,\\dots,m-1\\}$），$b_{j}$ 表示乘数的第 $j$ 位（其中 $j \\in \\{0,\\dots,n-1\\}$），那么每个部分积位是\n$$\np_{i,j} = a_{i} \\land b_{j},\n$$\n这通过一个双输入“与”门来实现。\n\n因此，所需的双输入“与”门的总数等于这种 $(i,j)$ 对的总数，也就是 $m$ 个被乘数位和 $n$ 个乘数位的笛卡尔积的大小：\n$$\n\\sum_{j=0}^{n-1}\\sum_{i=0}^{m-1} 1 = m \\times n.\n$$\n代入 $m=7$ 和 $n=5$ 可得\n$$\n7 \\times 5 = 35.\n$$\n因此，部分积生成阶段需要 $35$ 个双输入“与”门。", "answer": "$$\\boxed{35}$$", "id": "1914114"}, {"introduction": "一个可靠的数字系统不仅要能正确运行，还要能应对潜在的硬件故障。这个思想实验模拟了一个常见的硬件缺陷——“固定为0”故障，挑战你诊断其影响。通过分析在特定故障下哪些输入组合仍能产生正确结果，你将更深入地掌握阵列乘法器中每个部分积的作用，并培养在系统层面进行故障分析的思维能力。[@problem_id:1914169]", "problem": "一个标准的 $2 \\times 2$ 无符号二进制阵列乘法器被设计用于计算乘积 $P = A \\times B$。输入是两个2位无符号数，$A$ 由比特 $a_1a_0$ 表示（其值为 $2a_1 + a_0$），$B$ 由比特 $b_1b_0$ 表示（其值为 $2b_1 + b_0$）。乘积是一个4位数 $P = p_3p_2p_1p_0$。该乘法逻辑可以表示为部分积的加权和：$A \\times B = (a_1b_1) \\cdot 2^2 + (a_1b_0 + a_0b_1) \\cdot 2^1 + (a_0b_0) \\cdot 2^0$。在物理电路中，每一项 $a_i b_j$ 都由一个与门（AND gate）生成。\n\n在制造后测试期间，发现其中一个与门存在“固定为0”（stuck-at-0）故障。具体来说，本应计算部分积项 $a_0b_1$ 的门电路，无论其输入 $a_0$ 和 $b_1$ 的实际值是什么，其输出始终为0。\n\n从下面的输入对 $(A, B)$ 列表中，找出所有对于这些输入，该故障乘法器仍能产生正确最终乘积的数对。请注意，所有输入均以十进制形式给出，并且您只应考虑 $A$ 和 $B$ 均不为零的数对。\n\nA. $A=2, B=3$\n\nB. $A=3, B=2$\n\nC. $A=1, B=2$\n\nD. $A=3, B=1$\n\nE. $A=3, B=3$", "solution": "设 $A=2a_{1}+a_{0}$ 且 $B=2b_{1}+b_{0}$，其中 $a_{i},b_{j}\\in\\{0,1\\}$。正确的乘积是\n$$\nP_{\\text{true}}=(a_{1}b_{1})\\cdot 2^{2}+(a_{1}b_{0}+a_{0}b_{1})\\cdot 2^{1}+(a_{0}b_{0})\\cdot 2^{0}.\n$$\n当计算 $a_{0}b_{1}$ 的与门存在固定为0的故障时，实际计算出的乘积是\n$$\nP_{\\text{faulty}}=(a_{1}b_{1})\\cdot 2^{2}+(a_{1}b_{0}+0)\\cdot 2^{1}+(a_{0}b_{0})\\cdot 2^{0}.\n$$\n因此误差为\n$$\nP_{\\text{true}}-P_{\\text{faulty}}=(a_{0}b_{1})\\cdot 2^{1}.\n$$\n因此，该故障乘法器能产生正确乘积的充分必要条件是 $a_{0}b_{1}=0$。\n\n将每个十进制输入编码为二进制位：\n- $1\\equiv 01$ 所以 $(a_{1},a_{0})=(0,1)$ 或 $(b_{1},b_{0})=(0,1)$。\n- $2\\equiv 10$ 所以 $(a_{1},a_{0})=(1,0)$ 或 $(b_{1},b_{0})=(1,0)$。\n- $3\\equiv 11$ 所以 $(a_{1},a_{0})=(1,1)$ 或 $(b_{1},b_{0})=(1,1)$。\n\n通过计算 $a_{0}b_{1}$ 来检查每个选项：\n- A: $A=2\\Rightarrow a_{0}=0$, $B=3\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=0$；正确。\n- B: $A=3\\Rightarrow a_{0}=1$, $B=2\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=1$；不正确。\n- C: $A=1\\Rightarrow a_{0}=1$, $B=2\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=1$；不正确。\n- D: $A=3\\Rightarrow a_{0}=1$, $B=1\\Rightarrow b_{1}=0$，所以 $a_{0}b_{1}=0$；正确。\n- E: $A=3\\Rightarrow a_{0}=1$, $B=3\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=1$；不正确。\n\n因此，正确的选项是 A 和 D。", "answer": "$$\\boxed{AD}$$", "id": "1914169"}, {"introduction": "在掌握了基本的乘法实现后，下一步是探索如何提高效率。Booth算法通过减少所需的加法和减法次数来加速有符号数的乘法。这个练习并非简单地应用算法，而是要求你反向思考：什么样的乘数能最大限度地发挥Booth算法的优势？通过寻找能使操作次数最少的二进制模式，你将揭示该算法效率提升的根本原因，并深刻理解算法性能与其输入数据特性之间的关系。[@problem_id:1914183]", "problem": "在数字系统中，Booth 算法是一种乘法算法，它可将两个用二进制补码表示的有符号二进制数相乘。其效率源于它能处理乘数中的连续 1 字符串，与标准的“加法和移位”方法相比，这通常能减少所需的加法和减法操作次数。该算法从右到左、一次一对地检查乘数的比特位。\n\n考虑两个有符号 4 比特整数的乘法 `P = M \\times R`，其中 `M` 是被乘数，`R` 是乘数。由 Booth 算法执行的加法和减法操作次数完全由乘数 `R` 的比特模式决定。\n\n您的任务是，为乘数 `R` 找到一个非零的 4 比特二进制值，该值能使加减法操作的总次数达到最小。如果存在多个满足条件的 4 比特 `R` 值，请选择其所代表的有符号十进制整数绝对值最小的那个（即最接近零的值）。请将此 4 比特二进制值作为答案。", "solution": "设 4 比特二进制补码乘数为 $R = Q_{3}Q_{2}Q_{1}Q_{0}$，并根据 Booth 算法，在其右侧附加一个额外比特 $Q_{-1}=0$。在每个步骤 $i \\in \\{0,1,2,3\\}$，算法检查比特对 $(Q_{i},Q_{i-1})$ 并按如下规则操作：\n- 若 $(Q_{i},Q_{i-1})=(0,1)$，则执行一次加法；\n- 若 $(Q_{i},Q_{i-1})=(1,0)$，则执行一次减法；\n- 若 $(Q_{i},Q_{i-1})=(0,0)$ 或 $(1,1)$，则不执行任何操作。\n\n因此，加法和减法操作的总次数恰好等于扩展序列 $Q_{-1},Q_{0},Q_{1},Q_{2},Q_{3}$ 中相邻比特之间发生变化的次数。等价地，\n$$\nN_{\\text{ops}}=\\sum_{i=0}^{3} \\mathbf{1}\\{Q_{i}\\neq Q_{i-1}\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n对于非零的 $R$，$N_{\\text{ops}}$ 的最小可能值为 $1$。具体分析如下：\n- 若 $R=0000$，则 $N_{\\text{ops}}=0$，但这不满足非零约束。\n- 若 $R\\neq 0000$，设 $k$ 为使 $Q_{k}=1$ 的最小索引。根据 $k$ 的最小性，可知 $Q_{-1}=0$ 且 $Q_{0},\\ldots,Q_{k-1}=0$，因此比特对 $(Q_{k},Q_{k-1})=(1,0)$ 至少贡献了一次操作，故 $N_{\\text{ops}} \\geq 1$。\n- 为使 $N_{\\text{ops}}=1$，必须没有更多的比特变化，这要求对于所有 $j \\geq k$，都有 $Q_{j}=1$。因此，$R$ 的形式必须是从零（最低有效位侧）到一（最高有效位侧）的单次变化。\n\n对于 4 比特，能使 $N_{\\text{ops}}=1$ 的确切 $R$ 值集合为\n$$\nR \\in \\{1000,\\,1100,\\,1110,\\,1111\\}。\n$$\n用 4 比特二进制补码表示，这些值分别对应：\n$$\n1000=-8,\\quad 1100=-4,\\quad 1110=-2,\\quad 1111=-1.\n$$\n在这些数中，绝对值最小的是 $|-1|=1$，对应于 $R=1111$。\n\n因此，能使加减法次数最少，且在有多个选项时其绝对值最小的非零 4 比特乘数是 $1111$。", "answer": "$$\\boxed{1111}$$", "id": "1914183"}]}