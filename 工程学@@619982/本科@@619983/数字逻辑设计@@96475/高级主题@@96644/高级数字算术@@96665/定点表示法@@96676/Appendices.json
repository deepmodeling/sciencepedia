{"hands_on_practices": [{"introduction": "在数字系统中，定点表示法是将现实世界中的小数在硬件中高效处理的关键。本练习将带你实践最基本也是最核心的技能：将正负十进制数转换为指定的 $Q$ 格式定点数，并执行一次加法运算。通过这个练习 [@problem_id:1935892]，你将掌握使用二进制补码处理负数以及在定点数上进行算术运算的基础方法。", "problem": "一个简单的嵌入式系统使用专用的数字信号处理器（DSP）来处理传感器数据。该DSP使用带符号的8位定点格式表示所有数字，具体为Q4.4格式。在此约定中，一个数字有4位用于整数部分（包括一位符号位）和4位用于小数部分。负数使用二进制补码表示。\n\n该系统获取原始传感器读数，并向其添加一个预定的校准偏移量。在一个特定实例中，原始传感器读数等效于十进制值 $5.75$，校准偏移量等效于十进制值 $-2.25$。\n\nDSP对这两个值执行加法运算。在Q4.4格式中，表示最终校准值的、不含任何空格或二进制小数点的8位二进制字符串是什么？\n\n从以下选项中选择正确的选项：\n\nA. `00111000`\n\nB. `00110111`\n\nC. `01111100`\n\nD. `11011100`\n\nE. `11001000`", "solution": "在使用二进制补码的Q4.4定点格式中，一个8位存储整数 $N$ 表示实数值 $v$，其关系为 $v = \\frac{N}{2^{4}}$，反之 $N = v \\cdot 2^{4}$。加法是在存储的整数上进行模 $2^{8}$ 运算，并舍弃进位。\n\n计算存储的整数：\n- 对于原始读数 $v_{1} = 5.75$，我们有 $N_{1} = 5.75 \\cdot 2^{4} = 92$。用8位二进制表示，$92$ 为 01011100。\n- 对于偏移量 $v_{2} = -2.25$，我们有 $N_{2} = -2.25 \\cdot 2^{4} = -36$。$-36$ 的8位二进制补码是通过将 $36 = 00100100$ 取反加1得到的，即 11011100。\n\n将存储的整数相加（模 $2^{8}$）：\n$$N_{\\text{sum}} = N_{1} + N_{2} = 92 + (-36) = 56.$$\n等效地，二进制加法 01011100 + 11011100 产生一个被舍弃的进位，得到 00111000。\n\n转换回实数值以进行验证：\n$$v_{\\text{sum}} = \\frac{N_{\\text{sum}}}{2^{4}} = \\frac{56}{16} = 3.5,$$\n该值在Q4.4的表示范围内。因此，最终得到的8位Q4.4表示是 00111000，对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1935892"}, {"introduction": "虽然定点算术在计算上很高效，但其有限的表示范围也带来了一个关键挑战：算术溢出。本练习 [@problem_id:1935887] 模拟了一个在机器人控制系统中计算相对速度的场景，要求你判断一次减法操作是否会导致结果超出 $Q5.3$ 格式的表示范围。理解和预测溢出是设计可靠嵌入式系统的必备技能。", "problem": "一个用于机械臂的嵌入式控制系统使用有符号8位定点数系统来表示关节速度。该格式为Q5.3二进制补码表示法，意即有5位用于整数部分（包括符号位），3位用于小数部分。\n\n控制器需要计算两个关节之间的相对速度。它存储了两个速度值：$A$，代表十进制值10，和$B$，代表十进制值-10。系统硬件计算差值 $D = A - B$。\n\n以下哪个陈述正确描述了处理器内此特定计算的结果？\n\nA. 不会发生溢出，结果被正确表示为20。\n\nB. 不会发生溢出，因为两个符号相反的数相减永远不会导致溢出。\n\nC. 发生溢出，因为该操作等效于两个正数相加，但得出的结果带有一个负的符号位。\n\nD. 发生溢出，因为值-10无法用Q5.3格式表示。\n\nE. 发生溢出，因为从最高有效位位置的最终进位输出位是0。", "solution": "在一个采用Q5.3格式的8位二进制补码定点数系统中，有5个整数位（包括符号位）和3个小数位。量化步长是 $2^{-3}$。一个有符号Q$5.3$数的表示范围是通过将二进制补码的范围按 $2^{-3}$ 缩放得到的：\n$$\nx_{\\min}=-2^{5-1}=-2^{4}=-16,\\qquad x_{\\max}=2^{5-1}-2^{-3}=2^{4}-2^{-3}=16-2^{-3}=15.875.\n$$\n因此，$A=10$ 和 $B=-10$ 都是可以表示的。\n\n定点编码使用 $2^{3}$ 进行缩放，因此存储的整数编码是：\n$$\nk_{A}=A\\cdot 2^{3}=10\\cdot 2^{3}=80,\\qquad k_{B}=B\\cdot 2^{3}=-10\\cdot 2^{3}=-80.\n$$\n在8位二进制补码中，$k_{A}=80$ 是 $01010000_{2}$，$k_{B}=-80$ 是 $10110000_{2}$。\n\n硬件计算差值 $D=A-B$。在二进制补码算术中，\n$$\nD=A-B=A+(-B).\n$$\n因为 $B=-10$，我们有 $-B=+10$，所以该操作等效于两个正数相加：\n$$\nD=10+10=20.\n$$\n在编码空间中，这对应于\n$$\nk_{D}=k_{A}-k_{B}=80-(-80)=160.\n$$\n8位二进制补码的有效编码范围是 $[-2^{7},\\,2^{7}-1]=[-128,\\,127]$。值 $k_{D}=160$ 超出了这个范围，所以8位加法器将以 $2^{8}$ 为模进行回绕：\n$$\nk_{D}\\equiv 160 \\pmod{256}=160-256=-96.\n$$\n因此，存储的结果编码是 $10100000_{2}$，其符号位为 $1$ (负)。将此编码解释为Q5.3值，它代表\n$$\nx_{D}=-96\\cdot 2^{-3}=-12,\n$$\n这并不是数学上正确的结果 $20$，并且只是由于回绕才落在了可表示范围内；这种差异表明发生了有符号溢出。\n\n标准的二进制补码加法有符号溢出条件是：两个符号相同的操作数相加，得到的结果符号不同。在这里，$A$ 和 $-B$ 都是正数，而结果的符号位是 $1$ (负)，因此发生溢出。等效地，可以通过对进入最高有效位的进位和从最高有效位输出的进位进行异或运算来检测溢出；对于 $01010000+01010000$，进入最高有效位的进位是 $1$，而从最高有效位输出的进位是 $0$，它们的异或结果是 $1$，证实了溢出的发生。\n\n评估选项：\n- A 是错误的，因为 $20$ 超过了最大值 $15.875$，所以确实发生了溢出，并且结果没有被正确表示。\n- B 是错误的，因为当 $B<0$ 时，$A-B$ 等效于两个正数相加，这可能会导致溢出。\n- C 是正确的：该操作等效于两个正数相加，但得出的结果带有一个负的符号位，这是典型的二进制补码溢出条件。\n- D 是错误的，因为 $-10$ 在Q5.3格式中是可以表示的。\n- E 的陈述是错误的：单独一个为 $0$ 的最终进位输出并不意味着溢出；正确的判据是使用进入最高有效位的进位和从其输出的进位的异或结果。\n\n因此，正确的陈述是 C。", "answer": "$$\\boxed{C}$$", "id": "1935887"}, {"introduction": "在数字信号处理 (DSP) 等性能敏感的应用中，我们常常需要用更高效的方式实现乘法。本练习 [@problem_id:1935863] 将引导你探索一种无需专用乘法器的常数乘法实现方法，即使用移位和加/减法操作来替代。通过将常数转换为规范有符号数字 (Canonical Signed Digit, CSD) 表示，你将学会如何设计出在硬件资源和功耗上都得到优化的算术单元。", "problem": "在许多数字信号处理（DSP）应用中，需要将数据流乘以一个固定常数。为了创建可最小化电路面积和功耗的高效硬件，通常会避免使用完整的乘法器电路。取而代之的是，这种“常数乘法”仅使用算术移位器（执行乘以或除以2的幂次方的操作）和加法器/减法器来实现。这种方法的效率取决于使用尽可能少的非零位来表示该常数。\n\n你的任务是设计这样一个专用的算术单元。该单元接收一个8位有符号输入数 $X$，该数采用Q4.4定点格式（4个整数位，包括符号位，和4个小数位）。该单元必须计算 $Y = X \\times 2.3125$。\n\n你的设计必须基于常数 $2.3125$ 的典范有符号数位 (CSD) 表示法。典范有符号数位 (CSD) 表示法是一种表示体系，其中每个数位可以是 $1$、$0$ 或 $\\bar{1}$（表示-1），其关键特性是任意两个连续的数位都不为非零。这一特性保证了对于任何给定的常数，其非零数位的数量为最少。\n\n下列哪一个移位和加/减运算序列，能够正确实现所需的乘法 $Y = X \\times 2.3125$，并且其算术运算（加法或减法）次数是采用CSD方法所能得到的最少次数？\n\n**符号说明**:\n- $X$ 是输入数。\n- `(X << n)` 表示将 $X$ 算术左移 $n$ 位（等效于乘以 $2^n$）。\n- `(X >> n)` 表示将 $X$ 算术右移 $n$ 位（等效于除以 $2^n$）。\n\nA. $Y = (X \\ll 1) + (X \\gg 2) + (X \\gg 4)$\n\nB. $Y = (X \\ll 1) + (X \\gg 1) - (X \\gg 2) + (X \\gg 4)$\n\nC. $Y = (X \\ll 2) - (X \\gg 2) - (X \\gg 4)$\n\nD. $Y = (X \\ll 1) + (X \\gg 2) + (X \\gg 3) - (X \\gg 4)$\n\nE. $Y = (X \\ll 2) - (X \\gg 1) + (X \\gg 3)$", "solution": "问题要求我们找到仅使用移位器和加法器/减法器来实现乘以常数 $K=2.3125$ 这一运算的最有效方法。指定的方法是使用该常数的典范有符号数位 (CSD) 表示法。\n\n**步骤1：将常数转换为二进制表示。**\n首先，我们将常数 $K = 2.3125$ 转换为其等效的二进制形式。我们可以通过分别转换整数部分和小数部分来完成。\n整数部分是 $2$，其二进制为 $(10)_2$。\n小数部分是 $0.3125$。要转换这部分，我们可以将其表示为2的负幂次方的和。\n$0.3125 = \\frac{3125}{10000} = \\frac{5}{16}$。\n作为一个分母是2的幂次方的分数，它很容易转换：\n$\\frac{5}{16} = \\frac{4+1}{16} = \\frac{4}{16} + \\frac{1}{16} = \\frac{1}{4} + \\frac{1}{16} = 2^{-2} + 2^{-4}$。\n用二进制表示，这个小数部分是 $0.0101_2$。\n结合整数和小数部分， $2.3125$ 的二进制表示是 $10.0101_2$。\n\n**步骤2：将二进制表示转换为CSD表示。**\n对于任何数，其CSD表示都是唯一的，并且具有任意两个连续数位都不为非零的特性。数位可以是 $\\{1, 0, \\bar{1}\\}$，其中 $\\bar{1} = -1$。\n将二进制数转换为CSD的一种常用算法是将任何形如 `01...1`（包含 $k$ 个1，其中 $k \\ge 2$）的连续1序列替换为 `10...0`$\\bar{1}$。\n让我们检查我们的二进制数：$10.0101_2$。\n非零数位位于对应 $2^1$、$2^{-2}$ 和 $2^{-4}$ 的位置上。在此表示中没有连续的非零数位。例如，没有 `11` 这样的模式。\n由于二进制表示 $10.0101_2$ 已经满足CSD的特性（没有连续的非零数位），因此它与其CSD表示是相同的。\n所以，$K_{CSD} = 10.0101_{CSD}$。\n\n**步骤3：将CSD表示转换为移位和加法运算。**\nCSD表示 $10.0101_{CSD}$ 对应于以下带符号的2的幂次方的和：\n$K = 1 \\cdot 2^1 + 0 \\cdot 2^0 + 0 \\cdot 2^{-1} + 1 \\cdot 2^{-2} + 0 \\cdot 2^{-3} + 1 \\cdot 2^{-4}$\n$K = 2^1 + 2^{-2} + 2^{-4}$\n将输入 $X$ 乘以该常数，我们执行以下运算：\n$Y = X \\times K = X \\times (2^1 + 2^{-2} + 2^{-4})$\n将 $X$ 分配到各项中，可得：\n$Y = (X \\times 2^1) + (X \\times 2^{-2}) + (X \\times 2^{-4})$\n这个表达式可以使用算术移位来实现：\n$Y = (X \\ll 1) + (X \\gg 2) + (X \\gg 4)$\n\n**步骤4：将结果与给定选项匹配。**\n推导出的表达式 $Y = (X \\ll 1) + (X \\gg 2) + (X \\gg 4)$ 与选项A完全对应。\n这个实现有三个非零项，需要进行 $3-1 = 2$ 次加法运算。这是最少的操作次数，因为CSD表示是最小化的。\n\n让我们简要地检查一下其他选项。一些选项，如B和D，虽然也能计算出正确的值，但它们并非基于最小化的CSD形式：\n- 选项B: $Y = (X \\ll 1) + (X \\gg 1) - (X \\gg 2) + (X \\gg 4)$ 代表 $K = 2 + 0.5 - 0.25 + 0.0625 = 2.3125$。该实现需要3次加/减运算。\n- 选项D: $Y = (X \\ll 1) + (X \\gg 2) + (X \\gg 3) - (X \\gg 4)$ 代表 $K = 2 + 0.25 + 0.125 - 0.0625 = 2.3125$。该实现同样需要3次加/减运算。\n这些是有效的但效率较低的有符号数位表示法。题目要求的是从CSD方法推导出的实现，该方法能保证在加/减运算次数方面是最高效的。选项C和E会得到错误的常数值。\n\n因此，选项A是正确答案，因为它代表了唯一的、最小化的CSD实现。", "answer": "$$\\boxed{A}$$", "id": "1935863"}]}