{"hands_on_practices": [{"introduction": "恢复余数法是理解二进制除法硬件实现的绝佳起点，因为它在逻辑上非常直观。本练习将引导你完整地执行一次四位二进制数的除法，通过追踪累加器 $A$ 在每个周期的变化，你将亲眼见证算法如何通过“减法-判断-恢复”的步骤来逐步形成最终的余数。这个过程对于建立二进制除法操作的底层心智模型至关重要。[@problem_id:1913872]", "problem": "一个数字电路被设计用来执行无符号二进制除法，采用的是恢复除法算法。该电路使用一个累加器寄存器 ($A$)、一个商寄存器 ($Q$) 和一个除数寄存器 ($M$)。被除数（也就是 $Q$ 寄存器）的位数为 $n=4$。$A$ 和 $M$ 寄存器的大小为 $n+1=5$ 位，以容纳符号位并防止中间计算过程中的溢出。\n\n该电路的任务是用除数 $11_2$ 去除被除数 $1001_2$。初始时，$A$ 寄存器被清零为 $00000_2$，$Q$ 寄存器保存被除数 $1001_2$，$M$ 寄存器保存除数，并填充至5位，为 $00011_2$。\n\n除法过程进行 $n=4$ 个周期。每个周期包括以下步骤：\n1. 级联寄存器对 $AQ$ 左移一位。从 $Q$ 的最高有效位 (MSB) 移出的位进入 $A$ 的最低有效位 (LSB)。\n2. 从 $A$ 中减去 $M$ 的值 ($A \\leftarrow A - M$)。所有算术运算均使用二的补码表示法进行。\n3. 检查 $A$ 的 MSB。\n    - 如果 $A$ 的 MSB 为 1（表示结果为负），则将 $Q$ 的 LSB 置为 0，并通过将 $M$ 加回到 $A$ 来恢复 $A$ 的值 ($A \\leftarrow A + M$)。\n    - 如果 $A$ 的 MSB 为 0（表示结果为正或零），则将 $Q$ 的 LSB 置为 1，且 $A$ 的值不改变。\n\n以下哪个选项正确列出了从周期1到周期4，每个周期结束时累加器 ($A$) 寄存器中保存的5位二进制数值序列？\n\nA. $00001_2, 00010_2, 00001_2, 00000_2$\n\nB. $11110_2, 11111_2, 00001_2, 00000_2$\n\nC. $00001_2, 00010_2, 00010_2, 00001_2$\n\nD. $00001_2, 00001_2, 00010_2, 00000_2$", "solution": "我们使用恢复除法算法，寄存器设置为：$A$（5位）、$Q$（4位）和 $M$（5位）。初始化 $A=00000_2$，$Q=1001_2$，$M=00011_2$。每个周期执行：级联的 $AQ$ 左移，然后使用5位二的补码算术执行 $A \\leftarrow A - M$，接着如果 $A$ 为负（MSB $=1$），则将 $Q$ 的 LSB 置为 $0$ 并恢复 $A \\leftarrow A+M$；否则将 $Q$ 的 LSB 置为 $1$ 并保持 $A$ 不变。\n\n周期 1：左移 $AQ$。$Q$ 的 MSB 是 $1$，所以移位后 $A=00001_2$，$Q=0010_2$。减去 $M$：计算 $M=00011_2$ 的5位二的补码为 $11101_2$，因此\n$A \\leftarrow 00001_2 + 11101_2 = 11110_2$。\nMSB 是 $1$（负数），所以将 $Q$ 的 LSB 置为 $0$ 并恢复\n$A \\leftarrow 11110_2 + 00011_2 = 00001_2$。\n周期 1 结束：$A=00001_2$。\n\n周期 2：左移 $AQ$。$Q$ 的 MSB 是 $0$，所以 $A=00010_2$，$Q=0100_2$。减去 $M$：\n$A \\leftarrow 00010_2 + 11101_2 = 11111_2$。\n负数，所以将 $Q$ 的 LSB 置为 $0$ 并恢复\n$A \\leftarrow 11111_2 + 00011_2 = 00010_2$。\n周期 2 结束：$A=00010_2$。\n\n周期 3：左移 $AQ$。$Q$ 的 MSB 是 $0$，所以 $A=00100_2$，$Q=1000_2$。减去 $M$：\n$A \\leftarrow 00100_2 + 11101_2 = 00001_2$。\n非负数，所以将 $Q$ 的 LSB 置为 $1$ 并保持 $A$ 不变。周期 3 结束：$A=00001_2$。\n\n周期 4：左移 $AQ$。$Q$ 的 MSB 是 $1$，所以 $A=00011_2$，$Q=0010_2$。减去 $M$：\n$A \\leftarrow 00011_2 - 00011_2 = 00000_2$。\n非负数，所以将 $Q$ 的 LSB 置为 $1$ 并保持 $A$ 不变。周期 4 结束：$A=00000_2$。\n\n因此，在周期 1 到 4 结束时，累加器 $A$ 的值分别为 $00001_2, 00010_2, 00001_2, 00000_2$，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1913872"}, {"introduction": "为了提高效率，工程师们设计了不恢复余数法，它通过在后续步骤中进行补偿来避免恢复加法操作。这个练习将带你走过一次完整的不恢复余数法除法过程，并特别关注算法结束时累加器 $A$ 中的原始值。理解这个“未经修正”的余数是掌握此算法的关键，因为它揭示了该算法与恢复余数法在底层逻辑上的根本区别。[@problem_id:1913819]", "problem": "考虑将4位无符号二进制数 $D = 1011_2$（被除数）除以无符号二进制数 $V = 11_2$（除数）。该除法运算将使用不恢复余数除法算法来执行。\n\n硬件配置包括一个累加器寄存器 $A$、一个商寄存器 $Q$ 和一个除数寄存器 $M$。对于此操作，累加器 $A$ 和除数 $M$ 使用5位来表示。被除数 $D$ 初始加载到4位寄存器 $Q$ 中。累加器 $A$ 初始化为全零。\n\n该算法的执行周期数等于被除数的位数。使用的是标准的无符号整数不恢复余数算法，该算法涉及根据累加器的符号进行条件加法或减法，然后设置新的商位。\n\n确定在四个周期中的最后一个周期完成后，5位累加器寄存器 $A$ 中所包含的最终二进制值。请注意，这是在对余数执行任何可能的最终校正步骤*之前*的值。请以一个5位的二进制字符串形式提供您的答案。", "solution": "我们使用标准不恢复余数除法算法，在5位累加器 $A$ 和5位除数 $M$ 中采用二进制补码运算。初始化 $A=00000$，$Q=1011$，$M=00011$。对于4个周期中的每一个周期，执行以下操作：\n1) 将拼接后的 $(A,Q)$ 左移一位。\n2) 如果 $A \\ge 0$，则执行 $A \\leftarrow A - M$；如果 $A  0$，则执行 $A \\leftarrow A + M$（全部为5位二进制补码运算）。\n3) 如果 $A \\ge 0$，将新的商位 $Q_0$ 设置为1，否则设置为0。\n\n周期 1：\n- 移位：$(A,Q): 00000\\,1011 \\to 00001\\,0110$，所以 $A=00001$，$Q=0110$。\n- 因为 $A \\ge 0$，计算 $A \\leftarrow A - M = 00001 - 00011 = 00001 + 11101 = 11110$。\n- 因为 $A0$，设置 $Q_0=0$，所以 $Q=0110$。\n\n周期 2：\n- 移位：$(A,Q): 11110\\,0110 \\to 11100\\,1100$，所以 $A=11100$，$Q=1100$。\n- 因为 $A  0$，计算 $A \\leftarrow A + M = 11100 + 00011 = 11111$。\n- 因为 $A0$，设置 $Q_0=0$，所以 $Q=1100$。\n\n周期 3：\n- 移位：$(A,Q): 11111\\,1100 \\to 11111\\,1000$，所以 $A=11111$，$Q=1000$。\n- 因为 $A  0$，计算 $A \\leftarrow A + M = 11111 + 00011 = 00010$（舍弃进位）。\n- 因为 $A \\ge 0$，设置 $Q_0=1$，所以 $Q=1001$。\n\n周期 4：\n- 移位：$(A,Q): 00010\\,1001 \\to 00101\\,0010$，所以 $A=00101$，$Q=0010$。\n- 因为 $A \\ge 0$，计算 $A \\leftarrow A - M = 00101 - 00011 = 00010$。\n- 因为 $A \\ge 0$，设置 $Q_0=1$，所以 $Q=0011$。\n\n在第四个周期结束后立即（并且在任何最终校正之前），累加器为 $A=00010$。", "answer": "$$\\boxed{00010}$$", "id": "1913819"}, {"introduction": "掌握了硬件算法的执行步骤后，将注意力转向除法运算的本质——商和余数——同样重要。本练习模拟了一个实际应用场景，要求你处理两次独立的除法运算，其中一次涉及一个重要的特殊情况：被除数小于除数。通过这个练习，你不仅能巩固对商和余数概念的理解，还能体验如何在数字系统中对计算结果进行组合与处理。[@problem_id:1913865]", "problem": "一个定制设计的处理器中的算术逻辑单元 (ALU) 被编程以执行一个特定的操作序列。所有数字都作为无符号二进制整数处理。该 ALU 执行两次独立的除法运算。\n\n首先，它将被除数 $X = 1001_2$ 除以除数 $Y = 1110_2$。设所得的整数商为 $Q_1$ 且余数为 $R_1$。\n\n其次，它将被除数 $P = 110110_2$ 除以除数 $Q = 101_2$。设所得的整数商为 $Q_2$ 且余数为 $R_2$。\n\n然后，该处理器通过将第一个余数 $R_1$ 的比特串与第二个商 $Q_2$ 的比特串拼接起来，构造一个最终的二进制数。$R_1$ 的比特构成输出的最高有效部分，$Q_2$ 的比特构成最低有效部分。\n\n最终的二进制数是什么？您的答案应以无下标的单个二进制字符串形式呈现。", "solution": "我们使用无符号整数除法的定义：对于被除数 $A$ 和正除数 $B$，存在唯一的整数 $Q$ 和 $R$，使得 $A=BQ+R$ 且 $0 \\le R  B$。\n\n第一次除法：设 $X=1001_2$ 且 $Y=1110_2$。比较 $X$ 和 $Y$：因为二者最高有效位都为 $1$，但 $X$ 的下一位是 $0$ 而 $Y$ 的下一位是 $1$，所以我们有 $1001_2  1110_2$。因此，在满足 $0 \\le R_1  Y$ 的 $X=Y \\cdot Q_1+R_1$ 中，我们必有 $Q_1=0$ 且 $R_1=X=1001_2$。\n\n第二次除法：设 $P=110110_2$ 且 $Q=101_2$。执行二进制长除法以求得 $Q_2$ 和 $R_2$，使得 $P=Q \\cdot Q_2+R_2$ 且 $0 \\le R_2  Q$。\n- 使用前三位：$110_2 - 101_2=001_2$，因此商的第一位是 $1$。\n- 向下补下一位 $1$：$0011_2$ 小于 $101_2$，因此商的下一位是 $0$。\n- 向下补下一位 $1$：$0111_2 - 101_2=0010_2$，因此商的下一位是 $1$。\n- 向下补最后一位 $0$：$0010_2$ 变为 $0100_2$，它小于 $101_2$，因此商的最后一位是 $0$。\n\n因此 $Q_2=1010_2$ 且 $R_2=0100_2=100_2$。处理器输出 $R_1$ 的比特串与 $Q_2$ 的比特串的拼接，因此最终的二进制数是 $1001$ 后跟 $1010$，即 $10011010$。", "answer": "$$\\boxed{10011010}$$", "id": "1913865"}]}