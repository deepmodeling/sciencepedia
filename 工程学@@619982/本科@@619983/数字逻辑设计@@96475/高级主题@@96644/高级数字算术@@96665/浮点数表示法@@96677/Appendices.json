{"hands_on_practices": [{"introduction": "让我们从一个基础练习开始：解码。这个练习模拟了一个常见场景，即从微控制器的内存中读取一个二进制位串，并将其翻译回我们熟悉的十进制数值。通过动手实践这个过程，你将牢固掌握符号位 $S$、指数位 $E$ 和尾数位 $F$ 这三个部分如何协同工作，共同构成一个浮点数的精确值。[@problem_id:1937520]", "problem": "一位工程师正在为环境传感器设计一款低功耗微控制器。为了节省内存，该微控制器使用一种自定义的10位浮点数格式来表示传感器读数。该格式定义如下：\n\n- **符号 (S)**：1 位（0为正，1为负）\n- **指数 (E)**：5 位，使用15的指数偏移量。\n- **尾数 (F)**：4 位\n\n这些位按 S、E、F 的顺序排列，从最高有效位到最低有效位。一个规格化数的值由公式 $V = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E-15)}$ 给出，其中 $(1.F)_{2}$ 是带有隐含前导1的尾数。指数全为零（非规格化数/零）或全为一（无穷大/NaN）的特殊情况不适用于本问题。\n\n假设微控制器的内存中包含10位二进制值 `1100101100`。确定此浮点数表示的十进制值。将您的答案表示为十进制数，如有必要，四舍五入到四位有效数字。", "solution": "这个10位的字是 1100101100，按 $S|E|F$ 的格式排列，其中 $S$ 是第一位，$E$ 是接下来的五位，$F$ 是最后四位。因此 $S=1$，$E=10010_{2}$，且 $F=1100_{2}$。由于 $E$ 既不全为零也不全为一，该数为规格化数，我们使用公式\n$$\nV = (-1)^{S}\\,(1.F)_{2}\\,2^{(E-15)}.\n$$\n\n转换指数：\n$$\nE = 1\\cdot 2^{4} + 0\\cdot 2^{3} + 0\\cdot 2^{2} + 1\\cdot 2^{1} + 0\\cdot 2^{0} = 16 + 2 = 18,\n$$\n所以无偏指数为\n$$\nE - 15 = 18 - 15 = 3.\n$$\n\n计算尾数：\n$$\n(1.F)_{2} = 1 + 1\\cdot 2^{-1} + 1\\cdot 2^{-2} + 0\\cdot 2^{-3} + 0\\cdot 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} = \\frac{7}{4}.\n$$\n\n当 $S=1$ 时，符号因子为 $(-1)^{1}=-1$。因此，\n$$\nV = -\\frac{7}{4}\\,2^{3} = -\\frac{7}{4}\\cdot 8 = -14.\n$$\n\n这是一个精确的十进制值，无需四舍五入。", "answer": "$$\\boxed{-14}$$", "id": "1937520"}, {"introduction": "浮点数本质上是对实数的近似表示，这一特性带来了重要的后果——表示误差。本练习将带你直面这个问题。我们将尝试用一个有限精度的自定义格式来存储一个十进制小数，并计算其与真实值之间的绝对误差，从而让你对数字系统中固有的精度与表示范围之间的权衡有更直观的感受。[@problem_id:1937508]", "problem": "一个专用的嵌入式系统使用一种自定义的8位浮点数表示法来存储传感器数据。该格式定义如下：\n- 1位用于符号（S）：0代表正数，1代表负数。\n- 4位用于指数（E）：指数以7为偏置值进行存储。\n- 3位用于尾数（F）：数字被规格化为 $1.F...$ 的形式，且前导的1是隐藏的。\n\n这些位按S、E、F的顺序排列。如果一个数的二进制表示的尾数位多于可存储的位数，系统会截断多余的位（不进行四舍五入）。\n\n计算当系统尝试存储十进制值 $9.2$ 时产生的绝对表示误差。请以十进制数的形式给出你的答案，并四舍五入到三位有效数字。", "solution": "在此格式下，一个规格化的浮点数值为\n$$V=(-1)^{S}\\left(1+\\sum_{i=1}^{3}f_{i}2^{-i}\\right)2^{E-\\mathrm{bias}},$$\n其中偏置值 $\\mathrm{bias}=7$，S是符号位，E是4位指数，而 $f_{i}$ 是三位尾数位。截断意味着我们在规格化后只保留前三位尾数位，并丢弃其余的位。\n\n对于 $9.2>0$，因此 $S=0$。将 $9.2$ 转换为二进制并进行规格化。因为 $9.2=1001.0011001100\\ldots_{2}$，规格化后得到\n$$9.2=1.0010011001100\\ldots_{2}\\times 2^{3},$$\n所以无偏指数为 $e=3$，存储的指数为 $E=e+\\mathrm{bias}=3+7=10$。\n\n规格化尾数的尾数位为 $0010011\\ldots$；截断为三位尾数位后得到 $F=001$，因此存储的尾数是\n$$M_{\\text{stored}}=1.001_{2}=1+2^{-3}.$$\n因此，存储的值为\n$$V_{\\text{stored}}=(1+2^{-3})2^{3}=2^{3}+1=9.$$\n\n绝对表示误差为\n$$\\left|9.2-9\\right|=0.2.$$\n四舍五入到三位有效数字，结果是 $0.200$。", "answer": "$$\\boxed{0.200}$$", "id": "1937508"}, {"introduction": "现在，让我们从自定义格式转向工业界广泛应用的 IEEE 754 单精度标准，探索其表示能力的边界。这个挑战性的问题将引导我们思考一个深刻的问题：在什么情况下，整数会无法被精确表示？通过找出第一个无法被精确表示的正整数，我们将揭示一个关于可表示数之间“间隙”（gap）的基本性质，并理解为什么浮点数不总是适用于精确的整数运算。[@problem_id:2173582]", "problem": "在现代计算中，实数通常使用浮点表示法进行近似表示。为此，一个被广泛采用的标准是电气和电子工程师协会 (IEEE) 754 标准。该标准下的单精度格式使用 32 位来表示一个数。\n\n这 32 位分配如下：\n- 1 位用于符号 ($s$)。\n- 8 位用于偏移指数 ($E$)。\n- 23 位用于小数部分 ($f$)。\n\n对于一个正的规格化数（其中符号位 $s=0$），其值 $V$ 由以下公式确定：\n$$V = 2^{E-127} \\times (1.f)_2$$\n此处，$127$ 是指数偏移量。术语 $(1.f)_2$ 表示二进制的尾数，其中 '1.' 是一个不被存储的隐藏前导位，而 $f$ 是存储在小数位中的 23 位二进制小数。对于规格化数，偏移指数 $E$ 的取值范围为 1 到 254。\n\n尽管这种格式可以表示极广的数值范围，但其有限的精度意味着并非所有数都能被精确表示。在考虑整数时，这种局限性就变得特别有趣。例如，整数 5 可以写成 $1.25 \\times 4 = (1.01)_2 \\times 2^2$。这对应于小数部分 $f=0100...0$ 和一个能产生 2 的幂的指数部分，因此 5 是可以被精确表示的。\n\n你的任务是找到在 IEEE 754 单精度浮点格式中无法被精确表示的最小正整数。", "solution": "一个规格化的单精度值具有以下形式\n$$V=2^{e}\\,(1.f)_{2},\\quad e=E-127,$$\n其中尾数有一个隐藏的前导位加上 23 个存储的小数位，从而得到 $p=24$ 位的有效精度。将小数部分 $f$ 增加一个单位会使 $(1.f)_{2}$ 改变 $2^{-23}$，因此对于一个固定的指数 $e$，连续可表示数之间的间距（末位单位）是\n$$\\mathrm{ulp}(e)=2^{e}\\cdot 2^{-23}=2^{e-23}.$$\n\n为了能精确表示某个区间内的每一个整数，该区间的间距必须至多为 1。因此，我们需要\n$$\\mathrm{ulp}(e)\\leq 1 \\quad \\Longleftrightarrow \\quad 2^{e-23}\\leq 1 \\quad \\Longleftrightarrow \\quad e\\leq 23.$$\n在 $[2^{23},\\,2^{24})$ 范围内的数，其指数 $e=23$，因此 $\\mathrm{ulp}=1$，所以该范围内的每个整数都是可表示的。$2^{24}$ 本身作为一个 2 的幂也是可以精确表示的，其尾数为 $(1.0)_{2}$ 且 $e=24$。\n\n对于下一个范围 $[2^{24},\\,2^{25})$，我们有 $e=24$，因此\n$$\\mathrm{ulp}(24)=2^{24-23}=2,$$\n所以在此范围内只有 2 的倍数是可表示的。因此，这个范围内不能被精确表示的最小整数是最小的奇数，\n$$2^{24}+1.$$\n\n因为所有小于或等于 $2^{24}$ 的正整数都可以精确表示，而 $2^{24}+1$ 不能，所以在 IEEE 754 单精度格式中，无法被精确表示的最小正整数是 $2^{24}+1$。", "answer": "$$\\boxed{16777217}$$", "id": "2173582"}]}