{"hands_on_practices": [{"introduction": "在真实的计算环境中，处理器经常需要在不同位宽的数字之间执行算术运算。这个练习将带你体验一个最基本也最关键的步骤：在进行加法运算前，如何正确地将一个较小编程的补码数扩展为较大位宽，以确保其数值在整个过程中保持不变。通过解决这个问题，你将掌握在混合位宽算术中符号扩展的实际应用。[@problem_id:1913334]", "problem": "一个简化的中央处理器 (CPU) 包含一个8位加法器，该加法器设计用于处理补码表示的整数。该CPU需要计算两个数 $X$ 和 $Y$ 的和。数 $X$ 存储在一个4位寄存器中，其值为 $1010_2$。数 $Y$ 存储在一个8位寄存器中，其值为 $00010110_2$。\n\n为了执行该运算，4位数 $X$ 必须先被转换为等效的8位补码表示，然后才能发送到加法器。加法器随后计算和 $S = X + Y$。\n\n最终得到的和 $S$ 的8位补码二进制值是多少？\n\nA. $00010000_2$\n\nB. $00100000_2$\n\nC. $11110000_2$\n\nD. $11001000_2$\n\nE. $00000000_2$", "solution": "我们使用补码算术进行运算。\n\n1) 将4位数 $X=1010_{2}$ 解释为补码。对于一个具有比特位 $b_{n-1}\\dots b_{0}$ 的 $n$ 位补码数，其值为\n$$\nv=-b_{n-1}2^{n-1}+\\sum_{k=0}^{n-2} b_{k}2^{k}.\n$$\n对于 $X=1010_{2}$ 且 $n=4$，我们有 $b_{3}=1$，$b_{1}=1$，以及 $b_{2}=b_{0}=0$，因此\n$$\nX=-1\\cdot 2^{3}+1\\cdot 2^{1}=-8+2=-6.\n$$\n\n2) 将 $X$ 从4位符号扩展到8位。在补码中，符号扩展会复制最高有效位。由于 $X$ 的符号位是 $1$，其8位表示为\n$$\nX_{(8\\text{-bit})}=11111010_{2}.\n$$\n\n3) 将 $Y=00010110_{2}$ 解释为一个8位补码数。其符号位是 $0$，所以它是一个非负数：\n$$\nY=2^{4}+2^{2}+2^{1}=16+4+2=22.\n$$\n\n4) 计算和 $S=X+Y$：\n$$\nS=-6+22=16.\n$$\n在8位补码中，$16$ 表示为\n$$\nS=00010000_{2}.\n$$\n同样地，直接进行二进制加法也可以证实这一点：\n$$\n11111010_{2}+00010110_{2}=00010000_{2},\n$$\n其产生的进位在定长补码加法中被忽略；因为两个加数的符号相反，所以没有发生溢出。\n\n因此，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1913334"}, {"introduction": "作为一名数字系统设计师，不仅要懂得如何执行符号扩展，更要能够设计出确保这一规则被严格遵守的硬件电路。这项实践将挑战你从硬件设计的角度出发，将符号扩展的定义转化为一个精确的布尔逻辑表达式。你将为一个验证模块设计逻辑，该模块能够自动判断一个32位数是否是一个12位数的正确符号扩展。[@problem_id:1960208]", "problem": "在一个现代计算系统中，一个32位中央处理器（CPU）需要与一个以12位格式提供数据的传统外围设备进行接口。CPU和该外设都使用二进制补码表示法来表示有符号整数。一个接口协处理器的任务是从外设读取12位值，并将其加载到32位的CPU寄存器中。这个过程需要进行符号扩展。\n\n设来自外设的12位值为$A$，其位表示为$a_{11}a_{10}...a_0$，其中$a_{11}$是符号位。$A$的值由下式给出：$-a_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} a_i \\cdot 2^i$。\n\n设CPU寄存器中的32位值为$B$，其位表示为$b_{31}b_{30}...b_0$，其中$b_{31}$是符号位。\n\n要将一个12位数$A$正确地符号扩展为一个32位数$B$，需要满足两个条件：\n1. $B$的低12位必须与$A$的位相等。\n2. $B$的高20位（从第12位到第31位）必须全部与$A$的符号位$a_{11}$相等。\n\n你的任务是设计一个硬件验证模块。该模块接收所有44个位（$A$的12位和$B$的32位）作为输入，并产生一个单一的输出信号$V$。如果$B$是$A$的正确符号扩展，信号$V$必须为逻辑'1'，否则为'0'。\n\n推导输出信号$V$的简化布尔表达式。该表达式应以单个位$a_i$和$b_j$的形式表示。对于逻辑等价（XNOR），你可以使用双条件符号$\\Leftrightarrow$。对于合取（AND），你可以使用符号$\\land$或乘积表示法。", "solution": "我们需要验证32位值$B$是否是12位二进制补码值$A$的正确符号扩展。根据符号扩展的定义：\n1. 低12位必须直接复制：对于所有的$i \\in \\{0,1,\\dots,11\\}$，要求$b_{i} = a_{i}$。\n2. 所有高20位都必须复制符号位$a_{11}$：对于所有的$j \\in \\{12,13,\\dots,31\\}$，要求$b_{j} = a_{11}$。\n\n在硬件中检查位的完全相等，一个自然的基本操作是逻辑等价（XNOR），写作双条件式。对于任意一对位$x,y \\in \\{0,1\\}$，“$x$等于$y$”的条件可以通过$x \\Leftrightarrow y$来表示，它在逻辑上等价于$(x \\land y) \\lor (\\lnot x \\land \\lnot y)$。\n\n因此，验证信号$V$必须是所有要求的逐位相等的合取：\n- 对于低12位：$\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)$。\n- 对于高20位：$\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)$。\n\n将这两个独立的条件通过合取运算结合，得到最终的布尔表达式：\n$$\nV \\;=\\; \\left(\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)\\right) \\land \\left(\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)\\right).\n$$\n此表达式已根据允许的基本操作进行了简化，并直接反映了正确符号扩展所需的条件。", "answer": "$$\\boxed{\\left(\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)\\right) \\land \\left(\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)\\right)}$$", "id": "1960208"}, {"introduction": "理解一个正确方法为何有效，最好的方式之一就是分析当它出错时会发生什么。这个问题模拟了一个常见的硬件设计缺陷：使用一个固定的比特位（$k$）而不是正确的符号位来进行扩展。通过推导这个错误逻辑所引入的数值误差的精确数学表达式，你将对二进制补码的底层数学原理以及符号扩展的必要性有更深刻的认识。[@problem_id:1960202]", "problem": "在一个专门的数字信号处理器设计中，一个核心组件是总线扩展器模块。该模块的功能是将一个$M$位数据字转换为一个$N$位数据字，其中$N > M$。输入和输出字都使用二进制补码表示来表示有符号整数。\n\n设输入为一个$M$位字，由位向量$A = (a_{M-1}, a_{M-2}, \\dots, a_0)$表示，其中$a_{M-1}$是最高有效位（符号位）。一个任意的$X$位二进制补码字$W = (w_{X-1}, \\dots, w_0)$的数值定义为 $V(W) = -w_{X-1} 2^{X-1} + \\sum_{i=0}^{X-2} w_i 2^i$。\n\n该总线扩展器逻辑中发现了一个设计缺陷。该电路没有执行标准的符号扩展，而是根据以下规则从输入字$A$构造出$N$位输出字$B = (b_{N-1}, b_{N-2}, \\dots, b_0)$：\n1. 输出字$B$的低$M$位是输入字$A$各位的直接复制。即，对于所有满足$0 \\leq i \\leq M-1$的整数$i$，$b_i = a_i$。\n2. 输出字$B$的高$N-M$位，即“扩展位”，全部被设置为一个固定的恒定比特值$k$，其中$k \\in \\{0, 1\\}$。即，对于所有满足$M \\leq i \\leq N-1$的整数$i$，$b_i = k$。\n\n设$V_A$是由输入字$A$表示的数值，$V_B$是由输出字$B$表示的数值。您的任务是推导一个闭式解析表达式，用于表示由这种错误逻辑引入的误差，该误差定义为差值$\\Delta V = V_B - V_A$。您的最终表达式应该用输入符号位$a_{M-1}$、固定填充位$k$和输入位宽$M$来表示。", "solution": "根据给定的二进制补码定义，对于任意$X$位字$W=(w_{X-1},\\dots,w_{0})$，\n$$\nV(W)=-w_{X-1}2^{X-1}+\\sum_{i=0}^{X-2}w_{i}2^{i}.\n$$\n对于$M$位输入$A=(a_{M-1},\\dots,a_{0})$，\n$$\nV_{A}=-a_{M-1}2^{M-1}+\\sum_{i=0}^{M-2}a_{i}2^{i}.\n$$\n对于$N$位输出$B=(b_{N-1},\\dots,b_{0})$，其中对于$0\\leq i\\leq M-1$有$b_{i}=a_{i}$，对于$M\\leq i\\leq N-1$有$b_{i}=k$，\n$$\nV_{B}=-k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\sum_{i=M}^{N-2}2^{i}.\n$$\n使用等比数列求和恒等式 $\\sum_{i=p}^{q}2^{i}=2^{p}\\left(2^{q-p+1}-1\\right)$，令$p=M$和$q=N-2$，我们得到\n$$\n\\sum_{i=M}^{N-2}2^{i}=2^{M}\\left(2^{N-1-M}-1\\right).\n$$\n因此\n$$\nV_{B}=-k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\left[2^{M}\\left(2^{N-1-M}-1\\right)\\right]\n= -k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\,2^{N-1}-k\\,2^{M}.\n$$\n项 $\\pm k\\,2^{N-1}$ 相互抵消，得到\n$$\nV_{B}=\\sum_{i=0}^{M-1}a_{i}2^{i}-k\\,2^{M}.\n$$\n因此，误差为\n$$\n\\Delta V=V_{B}-V_{A}=\\left(\\sum_{i=0}^{M-1}a_{i}2^{i}\\right)-k\\,2^{M}-\\left(-a_{M-1}2^{M-1}+\\sum_{i=0}^{M-2}a_{i}2^{i}\\right).\n$$\n化简求和项，\n$$\n\\Delta V=\\left(\\sum_{i=0}^{M-2}a_{i}2^{i}+a_{M-1}2^{M-1}\\right)-k\\,2^{M}+\\;a_{M-1}2^{M-1}-\\sum_{i=0}^{M-2}a_{i}2^{i}\n=2\\,a_{M-1}2^{M-1}-k\\,2^{M}.\n$$\n于是，\n$$\n\\Delta V=2^{M}\\left(a_{M-1}-k\\right).\n$$\n该表达式仅依赖于$a_{M-1}$、$k$和$M$，并且对于所有$N>M$都与$N$无关。", "answer": "$$\\boxed{2^{M}\\left(a_{M-1}-k\\right)}$$", "id": "1960202"}]}