{"hands_on_practices": [{"introduction": "在深入研究华莱士树的复杂缩减过程之前，我们必须首先理解其处理的初始数据结构——部分积矩阵。本次练习将帮助您奠定这一基础。您将学习如何为一个给定的乘法操作生成部分积，并根据它们的权重将它们组织成列，最终确定这个矩阵的关键尺寸特性，例如其最高列的高度 [@problem_id:1977426]。这第一步对于规划后续缩减阶段的硬件资源至关重要。", "problem": "在数字算术中，两个无符号二进制数的乘法是一项基本运算。考虑一个4位无符号数（被乘数）与一个6位无符号数（乘数）的乘法。乘积是通过首先生成部分积阵列，然后将它们相加而形成的。\n\n设4位被乘数为 $A$，其位为 $A_3A_2A_1A_0$，6位乘数为 $B$，其位为 $B_5B_4B_3B_2B_1B_0$。一个部分积项由被乘数的一位 $A_i$ 和乘数的一位 $B_j$ 进行逻辑与（AND）运算形成。该项在最终和中的权重为 $2^{i+j}$。\n\n在执行任何加法或规约操作（例如，使用 Wallace Tree 或 Carry-Save Adder 阵列）之前，这些单独的部分积位在概念上是根据它们的二进制权重排列成列的。所有具有相同权重 $2^k$（即 $i+j$ 的值相同）的项都属于同一列，称之为第 $k$ 列。一列的“高度”是它所包含的部分积位的数量。\n\n确定此 $4 \\times 6$ 乘法中的以下两个量：\n1. 生成的部分积位的总数。\n2. 初始部分积矩阵中最高列的高度。\n\n将这两个整数答案以行矩阵的形式提供，其中总位数作为第一个元素，最高列高度作为第二个元素。", "solution": "问题要求解一个 $4 \\times 6$ 无符号二进制乘法的初始部分积矩阵的两个属性。被乘数 $A$ 是4位宽，因此其位的索引为 $i \\in \\{0, 1, 2, 3\\}$。乘数 $B$ 是6位宽，因此其位的索引为 $j \\in \\{0, 1, 2, 3, 4, 5\\}$。\n\n**第1部分：部分积位的总数**\n\n一个部分积位是由被乘数的一位 $A_i$ 与乘数的一位 $B_j$ 进行逻辑与运算形成的。由于被乘数中有4位，乘数中有6位，因此每个操作数各取一位的每种组合都会形成一个唯一的部分积。\n\n因此，部分积位的总数是被乘数的位数与乘数的位数之积。\n\n部分积位总数 = ($A$的宽度) $\\times$ ($B$的宽度)\n$$ \\text{Total bits} = 4 \\times 6 = 24 $$\n这是我们答案的第一部分。\n\n**第2部分：最高列的高度**\n\n部分积位根据其权重 $2^k$ 排列成列，其中列索引 $k$ 由位索引之和给出，$k = i + j$。第 $k$ 列的高度是满足 $i+j=k$ 的数对 $(i, j)$ 的数量，其中约束条件为 $0 \\le i \\le 3$ 和 $0 \\le j \\le 5$。\n\n我们可以通过为每个 $k$ 枚举有效的 $(i,j)$ 数对来系统地确定每一列的高度：\n\n- **第 $k=0$ 列**：$i+j=0$。唯一有效的数对是 $(i,j)=(0,0)$。高度 = 1。\n- **第 $k=1$ 列**：$i+j=1$。有效数对是 $(0,1)$ 和 $(1,0)$。高度 = 2。\n- **第 $k=2$ 列**：$i+j=2$。有效数对是 $(0,2)$、$(1,1)$ 和 $(2,0)$。高度 = 3。\n- **第 $k=3$ 列**：$i+j=3$。有效数对是 $(0,3)$、$(1,2)$、$(2,1)$ 和 $(3,0)$。高度 = 4。\n- **第 $k=4$ 列**：$i+j=4$。有效数对是 $(0,4)$、$(1,3)$、$(2,2)$ 和 $(3,1)$。高度 = 4。\n- **第 $k=5$ 列**：$i+j=5$。有效数对是 $(0,5)$、$(1,4)$、$(2,3)$ 和 $(3,2)$。高度 = 4。\n- **第 $k=6$ 列**：$i+j=6$。有效数对是 $(1,5)$、$(2,4)$ 和 $(3,3)$。数对 $(0,6)$ 无效，因为 $j_{max}=5$。高度 = 3。\n- **第 $k=7$ 列**：$i+j=7$。有效数对是 $(2,5)$ 和 $(3,4)$。高度 = 2。\n- **第 $k=8$ 列**：$i+j=8$。唯一有效的数对是 $(3,5)$。高度 = 1。\n- **第 $k=9$ 列**：$i+j=9$。不存在有效的数对。例如，对于 $(3,6)$，有 $j>5$。高度 = 0。\n\n各列高度的序列为 (1, 2, 3, 4, 4, 4, 3, 2, 1)。我们可以通过将所有高度相加来验证这一点：$1+2+3+4+4+4+3+2+1 = 24$，这与第一部分计算出的部分积位总数相匹配。\n\n通过检查高度序列，最大值为 4。这出现在第 $k=3, 4, 5$ 列。\n\n因此，最高列的高度为4。这是我们答案的第二部分。\n\n两个所求的值都已确定。部分积位的总数为24，最高列的高度为4。", "answer": "$$\\boxed{\\begin{pmatrix} 24 & 4 \\end{pmatrix}}$$", "id": "1977426"}, {"introduction": "掌握了初始矩阵的结构后，现在是时候深入了解华莱士树乘法器的核心——多级缩减过程了。本次练习将引导您手动模拟这一动态过程，就像一个真正的数字逻辑工程师一样。您将系统地对每列应用全加器 ($FA$) 和半加器 ($HA$)，跟踪矩阵高度如何逐级降低，直到最终只剩下两行，为最后的进位传播加法做好准备 [@problem_id:1977482]。通过这个实践，您将对华莱士树算法的执行流程建立起具体而深刻的理解。", "problem": "在设计一个高速算术逻辑单元时，一名工程师正在使用华莱士树结构实现一个用于两个5位二进制数的无符号硬件乘法器。该乘法器首先生成一个部分积矩阵。然后通过一系列归约阶段将该矩阵归约为一个两行矩阵。最后两行再使用一个常规的进位传播加法器相加。\n\n归约过程分阶段进行。在每个阶段，根据贪婪策略，使用全加器 (FA) 和半加器 (HA) 对矩阵中每一列的位进行归约：\n- 全加器接收来自同一列的三个位作为输入，并为该列生成一个一位的和输出，同时为下一个更高阶（更有效）的列生成一个一位的进位输出。\n- 半加器接收来自同一列的两个位作为输入，并为该列生成一个一位的和输出，同时为下一个更高阶的列生成一个一位的进位输出。\n\n在每一列中，会使用尽可能多的全加器。在形成三位数组后，如果剩下两个位，则使用一个半加器。如果只剩下一个位，则直接传递到下一阶段的同一列中。来自加法器的和位以及任何直接传递的位，连同来自相邻低阶列的进位位，共同构成了下一阶段该列的行。重复此过程，直到矩阵中没有一列的位数超过两位。\n\n计算这个 $5 \\times 5$ 华莱士树乘法器的整个归约阶段所需的总全加器数和总半加器数。请以整数对 `(Total FAs, Total HAs)` 的形式给出你的答案。", "solution": "设两个5位无符号数为 $A = a_4a_3a_2a_1a_0$ 和 $B = b_4b_3b_2b_1b_0$。乘法 $A \\times B$ 会产生25个部分积位 $p_{ij} = a_i \\cdot b_j$。这些位被排列成一个矩阵，并根据其位权重进行移位。乘积最多可以有 $5+5=10$ 位，因此列从 C0（最低有效位）到 C9（最高有效位）进行索引。\n\n首先，我们确定初始部分积矩阵中每一列的位数（即高度）。\n- C0：1 位 ($p_{00}$)\n- C1：2 位 ($p_{01}, p_{10}$)\n- C2：3 位 ($p_{02}, p_{11}, p_{20}$)\n- C3：4 位 ($p_{03}, p_{12}, p_{21}, p_{30}$)\n- C4：5 位 ($p_{04}, p_{13}, p_{22}, p_{31}, p_{40}$)\n- C5：4 位 ($p_{14}, p_{23}, p_{32}, p_{41}$)\n- C6：3 位 ($p_{24}, p_{33}, p_{42}$)\n- C7：2 位 ($p_{34}, p_{43}$)\n- C8：1 位 ($p_{44}$)\n- C9：0 位\n\n初始列高向量 `N0`（从 C9 到 C0）是 `[0, 1, 2, 3, 4, 5, 4, 3, 2, 1]`。最大高度为 5，因此需要进行归约。\n\n**归约阶段 1：**\n我们对 `N0` 的每一列应用加法器。对于一个高度为 $k$ 的列，我们使用 $\\lfloor k/3 \\rfloor$ 个 FA 和 $\\lfloor (k \\pmod 3) / 2 \\rfloor$ 个 HA。每个 FA 产生一个和位和一个进位位。每个 HA 产生一个和位和一个进位位。\n- C0 (k=1)：无加法器。1 位直接传递。(s=1, c=0)\n- C1 (k=2)：1 个 HA。(s=1, c=1)。总计：1 个 HA。\n- C2 (k=3)：1 个 FA。(s=1, c=1)。总计：1 个 FA，1 个 HA。\n- C3 (k=4)：1 个 FA，剩下 1 位。(s=2, c=1)。总计：2 个 FA，1 个 HA。\n- C4 (k=5)：1 个 FA，剩下 2 位 -> 1 个 HA。(s=2, c=2)。总计：3 个 FA，2 个 HA。\n- C5 (k=4)：1 个 FA，剩下 1 位。(s=2, c=1)。总计：4 个 FA，2 个 HA。\n- C6 (k=3)：1 个 FA。(s=1, c=1)。总计：5 个 FA，2 个 HA。\n- C7 (k=2)：1 个 HA。(s=1, c=1)。总计：5 个 FA，3 个 HA。\n- C8 (k=1)：无加法器。1 位直接传递。(s=1, c=0)\n- C9 (k=0)：无位。(s=0, c=0)\n\n阶段 1 使用的加法器：**5 个 FA，3 个 HA**。\n\n现在，我们计算下一阶段的列高 `N1`。列 `i` 的高度是当前阶段列 `i` 的和位与列 `i-1` 的进位位之和。\n`N1[i] = s_i + c_{i-1}`\n- N1[0] = 1 (s0)\n- N1[1] = 1 (s1) + 0 (c0) = 1\n- N1[2] = 1 (s2) + 1 (c1) = 2\n- N1[3] = 2 (s3) + 1 (c2) = 3\n- N1[4] = 2 (s4) + 1 (c3) = 3\n- N1[5] = 2 (s5) + 2 (c4) = 4\n- N1[6] = 1 (s6) + 1 (c5) = 2\n- N1[7] = 1 (s7) + 1 (c6) = 2\n- N1[8] = 1 (s8) + 1 (c7) = 2\n- N1[9] = 0 (s9) + 0 (c8) = 0\n列高向量 `N1` 为 `[0, 2, 2, 2, 4, 3, 3, 2, 1, 1]`。最大高度为 4。\n\n**归约阶段 2：**\n我们对 `N1` 重复此过程。\n- C0 (k=1)，C1 (k=1)：直接传递。(s=1, c=0)\n- C2 (k=2)：1 个 HA。(s=1, c=1)。总计：1 个 HA。\n- C3 (k=3)：1 个 FA。(s=1, c=1)。总计：1 个 FA，1 个 HA。\n- C4 (k=3)：1 个 FA。(s=1, c=1)。总计：2 个 FA，1 个 HA。\n- C5 (k=4)：1 个 FA，剩下 1 位。(s=2, c=1)。总计：3 个 FA，1 个 HA。\n- C6 (k=2)：1 个 HA。(s=1, c=1)。总计：3 个 FA，2 个 HA。\n- C7 (k=2)：1 个 HA。(s=1, c=1)。总计：3 个 FA，3 个 HA。\n- C8 (k=2)：1 个 HA。(s=1, c=1)。总计：3 个 FA，4 个 HA。\n- C9 (k=0)：无位。\n\n阶段 2 使用的加法器：**3 个 FA，4 个 HA**。\n\n计算 `N2`：\n- N2[0]=1, N2[1]=1, N2[2]=1, N2[3]=2, N2[4]=2, N2[5]=3, N2[6]=2, N2[7]=2, N2[8]=2, N2[9]=1.\n列高向量 `N2` 为 `[1, 2, 2, 2, 3, 2, 2, 1, 1, 1]`。最大高度为 3。\n\n**归约阶段 3：**\n我们对 `N2` 重复此过程。\n- C0,C1,C2 (k=1)：直接传递。(s=1, c=0)\n- C3 (k=2)：1 个 HA。(s=1, c=1)。总计：1 个 HA。\n- C4 (k=2)：1 个 HA。(s=1, c=1)。总计：2 个 HA。\n- C5 (k=3)：1 个 FA。(s=1, c=1)。总计：1 个 FA，2 个 HA。\n- C6 (k=2)：1 个 HA。(s=1, c=1)。总计：1 个 FA，3 个 HA。\n- C7 (k=2)：1 个 HA。(s=1, c=1)。总计：1 个 FA，4 个 HA。\n- C8 (k=2)：1 个 HA。(s=1, c=1)。总计：1 个 FA，5 个 HA。\n- C9 (k=1)：直接传递。(s=1, c=0)\n\n阶段 3 使用的加法器：**1 个 FA，5 个 HA**。\n\n计算 `N3`：\n- N3[0]=1, N3[1]=1, N3[2]=1, N3[3]=1, N3[4]=2, N3[5]=2, N3[6]=2, N3[7]=2, N3[8]=2, N3[9]=2.\n列高向量 `N3` 为 `[2, 2, 2, 2, 2, 2, 1, 1, 1, 1]`。最大高度为 2，因此归约阶段完成。\n\n**总加法器数：**\n为了计算总加法器数，我们将每个阶段的数量相加。\n- 总 FA 数 = (阶段 1 的 FA 数) + (阶段 2 的 FA 数) + (阶段 3 的 FA 数) = $5 + 3 + 1 = 9$。\n- 总 HA 数 = (阶段 1 的 HA 数) + (阶段 2 的 HA 数) + (阶段 3 的 HA 数) = $3 + 4 + 5 = 12$。\n\n整个归约阶段需要 9 个全加器和 12 个半加器。", "answer": "$$\\boxed{\\begin{pmatrix} 9 & 12 \\end{pmatrix}}$$", "id": "1977482"}, {"introduction": "理论知识的最终考验在于其在现实世界中的应用，包括理解当系统出现故障时会发生什么。这个最后的实践将抽象的逻辑设计与其具体的算术结果联系起来，这是一个在数字系统测试和验证中常见的场景。通过分析一个特定全加器上的“固定为0”故障所导致的计算错误，您将深刻体会到缩减路径中每个微小元件的正确运作对于保证整个乘法器最终结果准确性的重要性 [@problem_id:1977496]。", "problem": "一位工程师正在设计一个采用华莱士树 (Wallace tree) 结构的 5 位无符号二进制乘法器。该乘法器用于计算一个 5 位被乘数 $A = a_4a_3a_2a_1a_0$ 和一个 5 位乘数 $B = b_4b_3b_2b_1b_0$ 的乘积。操作数的位被索引，其中第 0 位是最低有效位 (LSB)，第 4 位是最高有效位 (MSB)。在这种结构中，初始步骤是生成一个部分积数组。由逻辑与运算 $a_j \\land b_i$ 产生的位被放置在对应位权重为 $2^{j+i}$ 的列中。\n\n然后，华莱士树使用多级并行加法器来规约这个部分积数组。第一级规约阶段接收初始数组，并应用全加器 (FA) 和半加器 (HA) 来减少行数。全加器是一种数字逻辑电路，它接收来自同一列的三个输入位，并产生一个和位（该和位保留在同一列中以用于下一阶段）和一个进位输出位（该进位输出位被传递到下一个更高有效位的列，即第 $k+1$ 列，以用于下一阶段）。\n\n在制造后测试期间，发现了一个缺陷。在第一级规约阶段中，处理需要全加器的最高有效位列的那个全加器，其进位输出线发生了永久性的固定为 0 (stuck-at-0) 故障。\n\n对于一个特定的测试用例，其中被乘数 $A = 28$，乘数 $B = 28$，请计算有故障的乘法器计算出的乘积与正确乘积之间的数值差异。即，求出 $P_{\\text{faulty}} - P_{\\text{correct}}$ 的值。", "solution": "问题要求计算一个 5x5 华莱士树乘法器由于一个特定的固定为 0 故障而在最终乘积中产生的误差。输入为 $A=28$ 和 $B=28$。\n\n首先，我们将被乘数 $A$ 和乘数 $B$ 表示为 5 位无符号二进制数。\n$A = 28_{10} = 16 + 8 + 4 = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 11100_2$。\n所以，$a_4=1, a_3=1, a_2=1, a_1=0, a_0=0$。\n$B = 28_{10} = 11100_2$。\n所以，$b_4=1, b_3=1, b_2=1, b_1=0, b_0=0$。\n\n接下来，我们需要确定一个通用的 5x5 乘法的初始部分积数组的结构。位 $a_j \\land b_i$ 被放置在第 $j+i$ 列。列的索引从 0 到 8。我们确定初始数组中每一列的高度（位数）。\n\n- 第 0 列: $a_0b_0$ (高度: 1)\n- 第 1 列: $a_1b_0, a_0b_1$ (高度: 2)\n- 第 2 列: $a_2b_0, a_1b_1, a_0b_2$ (高度: 3)\n- 第 3 列: $a_3b_0, a_2b_1, a_1b_2, a_0b_3$ (高度: 4)\n- 第 4 列: $a_4b_0, a_3b_1, a_2b_2, a_1b_3, a_0b_4$ (高度: 5)\n- 第 5 列: $a_4b_1, a_3b_2, a_2b_3, a_1b_4$ (高度: 4)\n- 第 6 列: $a_4b_2, a_3b_3, a_2b_4$ (高度: 3)\n- 第 7 列: $a_4b_3, a_3b_4$ (高度: 2)\n- 第 8 列: $a_4b_4$ (高度: 1)\n\n任何高度为 3 或更高的列都需要一个全加器 (FA) 来进行规约。在第一级规约阶段需要全加器的列是第 2, 3, 4, 5, 和 6 列。\n\n问题指出，故障发生在“需要全加器的最高有效位列”。根据我们的分析，这是第 6 列。\n\n第 6 列的全加器将该列中的三个位作为其输入。这些输入是：\n1.  $I_1 = a_4b_2$\n2.  $I_2 = a_3b_3$\n3.  $I_3 = a_2b_4$\n\n现在，我们根据给定的值 $A=11100_2$ 和 $B=11100_2$来计算这些输入。\n- $a_4=1, a_3=1, a_2=1$\n- $b_4=1, b_3=1, b_2=1$\n\n- $I_1 = a_4 \\land b_2 = 1 \\land 1 = 1$\n- $I_2 = a_3 \\land b_3 = 1 \\land 1 = 1$\n- $I_3 = a_2 \\land b_4 = 1 \\land 1 = 1$\n\n第 6 列全加器的输入是 $(1, 1, 1)$。\n\n一个输入为 $(x, y, z)$ 的全加器会产生一个和 $S = x \\oplus y \\oplus z$ 和一个进位输出 $C_{out} = (x \\land y) \\lor (y \\land z) \\lor (z \\land x)$。\n对于输入 $(1, 1, 1)$：\n- 和位为 $S = 1 \\oplus 1 \\oplus 1 = 1$。该位保留在第 6 列以用于下一阶段。\n- 正确的进位输出位为 $C_{out} = (1 \\land 1) \\lor (1 \\land 1) \\lor (1 \\land 1) = 1$。该位应被传递到第 7 列以用于下一阶段。\n\n故障是这条进位输出线上的固定为 0 故障。这意味着无论输入是什么，进位输出总是 0。\n- 正确的进位输出: $C_{correct} = 1$\n- 错误的进位输出: $C_{faulty} = 0$\n\n这个来自第 6 列的进位输出位对第 7 列有贡献。第 7 列中一个位的位权重是 $2^7$。在最终和中引入的误差是进位位值的差乘以其位权重。\n\n误差 = $(C_{faulty} - C_{correct}) \\times (\\text{第 7 列的权重})$\n误差 = $(0 - 1) \\times 2^7$\n误差 = $-1 \\times 128$\n误差 = $-128$\n\n这个误差直接转化为有故障的乘积和正确乘积之间的差值，因为华莱士树是一个求和电路，而这个故障只是从总和中移除了一个项。\n因此，$P_{\\text{faulty}} - P_{\\text{correct}} = -128$。\n\n为了验证，正确的乘积是 $28 \\times 28 = 784$。有故障的乘法器计算出的和比正确的和少 128。所以，$P_{\\text{faulty}} = 784 - 128 = 656$。差值为 $656 - 784 = -128$。", "answer": "$$\\boxed{-128}$$", "id": "1977496"}]}