{"hands_on_practices": [{"introduction": "学习有限状态机（FSM）最有效的方法就是动手设计。这个练习将带你入门，通过一个经典问题来巩固核心概念。我们将构建一个“模三计数器”，它的状态将用于“记忆”输入流中出现过的 $'1'$ 的累计数量模三的余数。这个练习旨在阐明状态如何作为一种有限的内存形式，这对于理解 FSM 在数字计数、频率划分和信号处理中的应用至关重要 [@problem_id:1935256]。", "problem": "一个数字系统被设计用来监控一个串行二进制数据流。该系统的核心是一个摩尔型有限状态机（FSM）。该 FSM 有一个二进制输入，表示为 $x$，以及一个二进制输出，表示为 $z$。\n\n该 FSM 需要执行一个特定功能：其输出 $z$ 必须为 '1'，当且仅当自机器上次复位以来在输入 $x$ 上接收到的 '1' 的累积数量是三的非负整数倍（即 0, 3, 6, 9,...）。对于所有其他 '1' 的计数，输出 $z$ 必须为 '0'。\n\n机器的状态是根据 '1' 的累积计数除以三的余数来定义的。设状态为 $S_0$、$S_1$ 和 $S_2$，分别对应余数 0、1 和 2。机器从复位状态 $S_0$ 开始。\n\n状态表通过列出当前状态、每个可能输入的下一状态以及与当前状态相关的输出来描述 FSM 的行为。以下哪个状态表正确地表示了这台摩尔机？\n\nA.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      1       |\n|     $S_1$     |       $S_1$        |       $S_2$        |      0       |\n|     $S_2$     |       $S_2$        |       $S_0$        |      0       |\n\nB.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      0       |\n|     $S_1$     |       $S_1$        |       $S_2$        |      0       |\n|     $S_2$     |       $S_2$        |       $S_0$        |      1       |\n\nC.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_1$        |       $S_0$        |      1       |\n|     $S_1$     |       $S_2$        |       $S_1$        |      0       |\n|     $S_2$     |       $S_0$        |       $S_2$        |      0       |\n\nD.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      1       |\n|     $S_1$     |       $S_1$        |       $S_0$        |      0       |\n|     $S_2$     |       $S_2$        |       $S_1$        |      0       |\n\nE.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      1       |\n|     $S_1$     |       $S_1$        |       $S_2$        |      0       |\n|     $S_2$     |       $S_0$        |       $S_2$        |      0       |", "solution": "根据输入‘1’的累积计数模三的余数来定义摩尔 FSM 的状态：$S_{0}$ 表示余数为 $0$，$S_{1}$ 表示余数为 $1$，$S_{2}$ 表示余数为 $2$。复位状态是 $S_{0}$。\n\n因为这是一台摩尔机，所以输出仅取决于当前状态。要求是 $z=1$ 当且仅当到目前为止看到的‘1’的数量是三的倍数。因此，$z=1$ 仅在状态 $S_{0}$ 时成立，而在状态 $S_{1}$ 和 $S_{2}$ 时 $z=0$。\n\n设当前状态的余数为 $r \\in \\{0,1,2\\}$。在接收到输入 $x \\in \\{0,1\\}$ 后，‘1’的累积数量增加 $x$，因此下一状态的余数由下式给出\n$$\nr^{+} = (r + x) \\bmod 3.\n$$\n这意味着状态转移结构如下：\n- 当 $x=0$ 时，余数不变，所以 $S_{0} \\to S_{0}$，$S_{1} \\to S_{1}$，$S_{2} \\to S_{2}$。\n- 当 $x=1$ 时，余数模三加一，所以 $S_{0} \\to S_{1}$，$S_{1} \\to S_{2}$，$S_{2} \\to S_{0}$。\n\n结合状态转移和输出，正确的状态表必须具有：\n- 当 $x=0$ 时的下一状态：每个状态都自循环。\n- 当 $x=1$ 时的下一状态：$S_{0} \\to S_{1}$，$S_{1} \\to S_{2}$，$S_{2} \\to S_{0}$。\n- 输出 $z$：在 $S_{0}$ 中为 $1$，在 $S_{1}$ 和 $S_{2}$ 中为 $0$。\n\n与选项比较，只有选项 A 符合这些状态转移和输出。", "answer": "$$\\boxed{A}$$", "id": "1935256"}, {"introduction": "除了计数，FSM 还能高效地执行算法。此练习将探讨一个精巧的 Mealy 型 FSM 设计，用于实现一种基本的二进制算术运算——串行求二的补码 [@problem_id:1935273]。这个问题突显了 Mealy 机的强大之处，其输出取决于当前状态和输入，使其能够对输入比特流进行实时处理。你将看到，一个仅有区区两个状态的简单机器，如何通过在特定事件（遇到第一个 $'1'$）后改变其行为模式，来完成一个看似复杂的任务。", "problem": "一个数字系统被设计用于计算一个二进制数的补码，该二进制数以串行方式，一次一位地输入系统。该系统被实现为一个 Mealy 型有限状态机 (FSM)。\n\nFSM 的输入是一个单位比特 $x$，表示正在处理的数的当前位。输入比特流从最低有效位 (LSB) 开始，然后朝最高有效位 (MSB) 进行。输出是一个单位比特 $y$，表示补码数的相应位。\n\n该 FSM 有两个状态：\n- `S_wait`：初始状态，在此状态下，机器等待输入流中遇到的第一个 '1'。\n- `S_invert`：处理完第一个 '1' 后进入的状态。对于所有后续的比特，机器都保持在此状态。\n\n您的任务是确定这个 Mealy 机的正确状态转换表。该表描述了当前状态和输入 $x$ 的每种组合所对应的下一状态和输出 $y$。\n\n以下哪个表正确表示了串行补码器的行为？\n\n**A.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 0          |\n| `S_wait`      | 1         | `S_invert` | 1          |\n| `S_invert`    | 0         | `S_invert` | 1          |\n| `S_invert`    | 1         | `S_invert` | 0          |\n\n**B.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 1          |\n| `S_wait`      | 1         | `S_wait`   | 0          |\n| `S_invert`    | 0         | `S_invert` | 1          |\n| `S_invert`    | 1         | `S_invert` | 0          |\n\n**C.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 0          |\n| `S_wait`      | 1         | `S_invert` | 0          |\n| `S_invert`    | 0         | `S_invert` | 1          |\n| `S_invert`    | 1         | `S_invert` | 0          |\n\n**D.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 0          |\n| `S_wait`      | 1         | `S_wait`   | 1          |\n| `S_invert`    | 0         | `S_invert` | 0          |\n| `S_invert`    | 1         | `S_invert` | 1          |", "solution": "一个二进制数的补码可以定义为按位取反再加一。当从最低有效位 (LSB) 处理到最高有效位 (MSB) 时，与此定义等效的串行算法是：\n- 从 LSB 端开始，复制所有比特，直到并包括第一个出现的 $1$。\n- 反转所有后续的比特。\n\n要用 Mealy FSM 实现这一点，定义两个状态：\n- $S_{\\text{wait}}$：尚未看到 $1$；我们正在等待第一个 $1$。\n- $S_{\\text{invert}}$：第一个 $1$ 已被处理；从现在开始，反转所有输入的比特。\n\n令输入比特为 $x \\in \\{0,1\\}$，输出为 $y \\in \\{0,1\\}$。每个状态和输入的行为推导如下：\n\n1. 在 $S_{\\text{wait}}$ 状态下：\n   - 如果 $x=0$，则尚未遇到 $1$，根据算法我们复制该比特。因此 $y=0$ 并保持在 $S_{\\text{wait}}$ 状态。\n   - 如果 $x=1$，这是第一个 $1$；我们必须复制它，然后开始反转后续的比特。因此 $y=1$ 并转换到 $S_{\\text{invert}}$ 状态。\n\n2. 在 $S_{\\text{invert}}$ 状态下：\n   - 对于所有后续的比特，我们输出其反码。因此对于任何 $x$，$y=\\overline{x}$ 并保持在 $S_{\\text{invert}}$ 状态。具体来说：\n     - 如果 $x=0$，则 $y=1$ 并保持在 $S_{\\text{invert}}$ 状态。\n     - 如果 $x=1$，则 $y=0$ 并保持在 $S_{\\text{invert}}$ 状态。\n\n总结这些，状态/输出关系是：\n- $S_{\\text{wait}}, x=0 \\rightarrow$ 下一状态 $S_{\\text{wait}}$，输出 $y=0$。\n- $S_{\\text{wait}}, x=1 \\rightarrow$ 下一状态 $S_{\\text{invert}}$，输出 $y=1$。\n- $S_{\\text{invert}}, x=0 \\rightarrow$ 下一状态 $S_{\\text{invert}}$，输出 $y=1$。\n- $S_{\\text{invert}}, x=1 \\rightarrow$ 下一状态 $S_{\\text{invert}}$，输出 $y=0$。\n\n这与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1935273"}, {"introduction": "序列检测是 FSM 在数字通信和协议处理等领域的一项基石应用。这个练习将引导你系统地设计一个 Mealy 机，用于在连续的数据流中识别一个特定的四位序列 $'1001'$ [@problem_id:1935239]。设计的关键在于，让每个状态代表目前已经成功匹配了目标序列的多少前缀。掌握这种将状态映射为“部分进展”的设计模式，是提升 FSM 设计能力的关键一步。", "problem": "正在为金库设计一个数字安全系统。该系统接收串行二进制输入流，每个时钟周期接收一位。当且仅当最后接收的四位比特构成特定序列“10”后跟“01”（即`1001`）时，金库门会解锁一个时钟周期。该系统必须能够识别目标序列的重叠出现。例如，如果输入流是 `...01001001...`，系统应在第八位时产生一个解锁信号，并在第十二位时再次产生一个解锁信号。\n\n您的任务是使用米利型（Mealy-type）有限状态机（FSM）来设计这个系统。米利型FSM是一种状态机，其输出取决于当前状态和当前输入。对于这个系统，FSM应该有一个单一的输出 $Z$，当接收到有效序列 `1001` 的最后一位时，$Z$ 在该时钟周期为 1（解锁），否则为 0。\n\n实现这个FSM所需的最少状态数是多少？\n\nA. 3\nB. 4\nC. 5\nD. 6\nE. 8", "solution": "我们寻求一个米利型FSM，当且仅当最后四个输入位是 $1001$ 时，它会输出 $Z=1$，并允许重叠。在米利机中，输出与转换相关联，而通常的最优构造方法会维持一个状态，该状态表示到目前为止所见比特流的后缀与目标模式的最长公共前缀的长度。\n\n将目标模式定义为长度为 $4$ 的 $P=1001$。标准构造方法是为每个可能匹配的前缀长度 $k\\in\\{0,1,2,3\\}$ 维护一个状态，其中 $k$ 表示最后 $k$ 个输入位等于 $P[1..k]$。设状态为：\n- $S_{0}$：匹配长度为 $0$（没有匹配的非空前缀），\n- $S_{1}$：匹配长度为 $1$（后缀为 $1$），\n- $S_{2}$：匹配长度为 $2$（后缀为 $10$），\n- $S_{3}$：匹配长度为 $3$（后缀为 $100$）。\n\n现在我们通过计算来推导转换和输出行为：对于每个状态和下一个输入 $b\\in\\{0,1\\}$，新的匹配长度是 $P$ 的最长前缀的长度，该前缀同时也是当前后缀加上 $b$ 后形成的新字符串的后缀。米利机输出 $Z$ 为 $1$ 的情况仅发生在完成模式匹配的转换上，即从 $S_{3}$ 接收到输入 $1$ 时。\n\n转换和输出：\n1. 从 $S_{0}$ 开始：\n   - 输入为 $1$ 时：新后缀是 $1$，匹配前缀长度为 $1$，所以转移到 $S_{1}$，输出 $Z=0$。\n   - 输入为 $0$ 时：没有匹配的非空前缀，所以停留在 $S_{0}$，输出 $Z=0$。\n2. 从 $S_{1}$（后缀为 $1$）开始：\n   - 输入为 $0$ 时：新后缀是 $10$，匹配前缀长度为 $2$，所以转移到 $S_{2}$，输出 $Z=0$。\n   - 输入为 $1$ 时：新后缀是 $11$，其最长匹配前缀是 $1$，所以停留在 $S_{1}$，输出 $Z=0$。\n3. 从 $S_{2}$（后缀为 $10$）开始：\n   - 输入为 $0$ 时：新后缀是 $100$，匹配前缀长度为 $3$，所以转移到 $S_{3}$，输出 $Z=0$。\n   - 输入为 $1$ 时：新后缀是 $101$，其最长匹配前缀是 $1$，所以转移到 $S_{1}$，输出 $Z=0$。\n4. 从 $S_{3}$（后缀为 $100$）开始：\n   - 输入为 $1$ 时：新后缀是 $1001$，完成了模式匹配；在此转换上输出 $Z=1$。因为新序列 $1001$ 的后缀 $1$ 也是 $P$ 的一个前缀，所以状态转移到 $S_{1}$。\n   - 输入为 $0$ 时：新后缀是 $1000$，它没有非空的匹配前缀，所以转移到 $S_{0}$，输出 $Z=0$。\n\n该FSM能检测重叠，因为在 $S_{3}\\xrightarrow{1}$ 产生 $Z=1$ 输出后，它会转换到 $S_{1}$，保留了可以开始一个新的 $1001$ 匹配的结尾的 $1$。\n\n最小性论证：我们通过证明这四种上下文（匹配长度为 $0,1,2,3$）对于未来的输入是两两可区分的（根据它们产生的输出流），来表明至少需要 $4$ 个状态。\n- $S_{3}$ vs $S_{2}$：输入 $1$ 会立刻使 $S_{3}$ 产生 $Z=1$ 而 $S_{2}$ 产生 $Z=0$，因此它们是可区分的。\n- $S_{2}$ vs $S_{1}$：输入 $01$ 会使 $S_{2}$ 在第二位上产生 $Z=1$，而 $S_{1}$ 在两位上都产生 $Z=0$，因此是可区分的。\n- $S_{1}$ vs $S_{0}$：输入 $001$ 会使 $S_{1}$ 在第三位上产生 $Z=1$，而 $S_{0}$ 在整个过程中都输出 $Z=0$，因此是可区分的。\n\n因此，这四个上下文中的任何两个都不能合并，所以至少需要 $4$ 个状态。由于上述构造用正好 $4$ 个状态实现了要求，因此一个米利型FSM的最少状态数是 $4$。\n\n在所提供的选项中，这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1935239"}]}