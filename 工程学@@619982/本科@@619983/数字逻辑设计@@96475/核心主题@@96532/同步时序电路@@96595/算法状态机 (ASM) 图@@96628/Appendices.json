{"hands_on_practices": [{"introduction": "让我们从一个常见的现实世界需求出发，将其转化为一个正式的数字设计。这个问题要求你使用算法状态机（ASM）图为一个自动浴室通风系统设计一个控制器 [@problem_id:1908113]。这个练习是学习如何捕捉系统行为、处理时序事件以及通过定义清晰的状态序列来管理多个输出的完美第一步，它展示了 Moore 型状态机模型的清晰性和强大功能。", "problem": "您的任务是使用摩尔型算法状态机 (Moore-type Algorithmic State Machine, ASM) 为自动化浴室通风系统设计一个数字控制器。该系统根据一个墙壁开关和一个外部定时器来控制灯和风扇。\n\n**系统组件和信号:**\n\n*   **输入:**\n    *   `S`: 来自墙壁开关的单比特输入。当开关闭合时 `$S=1$`，断开时 `$S=0$`。\n    *   `T`: 来自定时器模块的单比特输入。当倒计时完成时，定时器在一个时钟周期内断言 `$T=1$`。在其他情况下，`$T=0$`。\n\n*   **输出:**\n    *   `L`: 用于控制灯的单比特输出。`$L=1$` 打开灯，`$L=0$` 关闭灯。\n    *   `F`: 用于控制风扇的单比特输出。`$F=1$` 打开风扇，`$F=0$` 关闭风扇。\n    *   `Start_Timer`: 一个单比特输出，当被断言 (`$\\text{Start\\_Timer}=1$`) 时，指示外部定时器模块开始其倒计时。此信号应为一个单周期脉冲。\n\n**所需行为:**\n\n1.  初始状态下，灯和风扇都关闭。\n2.  当用户打开开关 (`$S=1$`) 时，灯和风扇立即开启。只要开关保持开启状态，它们就一直保持开启。\n3.  当用户关闭开关 (`$S=0$`) 时，灯立即关闭。然而，风扇保持开启状态。\n4.  在关闭开关的同时，控制器必须向定时器模块发送一个单周期的启动信号。\n5.  风扇将持续运行，直到定时器完成其周期（由 `$T=1$` 指示），此时风扇关闭。\n6.  如果用户在风扇处于此灯灭后“延时运行”期间（即在定时器完成之前）重新打开开关 (`$S=1$`)，系统应立即返回到灯和风扇都开启的状态，从而有效地取消定时器倒计时。\n\n以下哪项描述准确地表示了该控制器的摩尔型 ASM？\n\nA. ASM 有四个状态：`IDLE`、`ACTIVE`、`START_DELAY` 和 `FAN_OVERRUN`。\n    - `IDLE`: 输出为 `$L=0, F=0, \\text{Start\\_Timer}=0$`。如果 `$S=1$`，则转移到 `ACTIVE`。\n    - `ACTIVE`: 输出为 `$L=1, F=1, \\text{Start\\_Timer}=0$`。如果 `$S=0$`，则转移到 `START_DELAY`。\n    - `START_DELAY`: 输出为 `$L=0, F=1, \\text{Start\\_Timer}=1$`。无条件转移到 `FAN_OVERRUN`。\n    - `FAN_OVERRUN`: 输出为 `$L=0, F=1, \\text{Start\\_Timer}=0$`。如果 `$S=1$`，则转移到 `ACTIVE`。如果 `$S=0$` 且 `$T=1$`，则转移到 `IDLE`。\n\nB. ASM 有三个状态：`OFF`、`ON` 和 `OVERRUN`。\n    - `OFF`: 输出为 `$L=0, F=0, \\text{Start\\_Timer}=0$`。如果 `$S=1$`，则转移到 `ON`。\n    - `ON`: 输出为 `$L=1, F=1, \\text{Start\\_Timer}=0$`。如果 `$S=0$`，则转移到 `OVERRUN`。\n    - `OVERRUN`: 输出为 `$L=0, F=1, \\text{Start\\_Timer}=1$`。如果 `$S=1$`，则转移到 `ON`。如果 `$S=0$` 且 `$T=1$`，则转移到 `OFF`。\n\nC. ASM 有四个状态：`IDLE`、`ACTIVE`、`START_DELAY` 和 `FAN_OVERRUN`。\n    - `IDLE`: 输出为 `$L=0, F=0, \\text{Start\\_Timer}=0$`。如果 `$S=1$`，则转移到 `ACTIVE`。\n    - `ACTIVE`: 输出为 `$L=1, F=1, \\text{Start\\_Timer}=0$`。如果 `$S=0$`，则转移到 `START_DELAY`。\n    - `START_DELAY`: 输出为 `$L=0, F=1, \\text{Start\\_Timer}=1$`。无条件转移到 `FAN_OVERRUN`。\n    - `FAN_OVERRUN`: 输出为 `$L=0, F=1, \\text{Start\\_Timer}=0$`。如果 `$T=1$`，则转移到 `IDLE`。\n\nD. ASM 有三个状态：`IDLE`、`ACTIVE` 和 `FAN_WAIT`。\n    - `IDLE`: 输出为 `$L=0, F=0$`。如果 `$S=1$`，则转移到 `ACTIVE`。\n    - `ACTIVE`: 输出为 `$L=1, F=1$`。在 `$S$` 变为 0 的转换时，它输出 `$\\text{Start\\_Timer}=1$` 并进入 `FAN_WAIT`。\n    - `FAN_WAIT`: 输出为 `$L=0, F=1$`。如果 `$S=1$`，则转移到 `ACTIVE`。如果 `$T=1$`，则转移到 `IDLE`。", "solution": "我们将控制器建模为摩尔型 ASM，根据定义，其输出仅取决于当前状态。所需的行为意味着对 ASM 结构有以下约束：\n1) 初始时灯和风扇都关闭，因此必须有一个初始状态，其输出为 `$L=0$` 和 `$F=0$`。\n2) 当 `$S=1$` 时，只要 `$S=1$` 保持， `$L$` 和 `$F$` 都必须为 `$1$`，因此必须有一个状态，其输出为 `$L=1$` 和 `$F=1$`，并且在 `$S=1$` 时从初始状态转换到该状态。\n3) 当 `$S$` 变为 `$0$` 时，灯必须立即关闭，风扇保持开启。在摩尔机中，这意味着下一个状态的输出必须是 `$L=0$` 和 `$F=1$`。\n4) 当 `$S$` 变为 `$0$` 时，必须同时产生一个单周期的 `$\\text{Start\\_Timer}$` 脉冲。在摩尔型 ASM 中，产生一个时钟周期脉冲的标准方法是进入一个专用的瞬态，其输出包含 `$\\text{Start\\_Timer}=1$`，然后在下一个时钟周期无条件转换到 `$\\text{Start\\_Timer}=0$` 的稳定延时运行状态。因此，我们需要一个输出为 `$(L, F, \\text{Start\\_Timer})=(0, 1, 1)$` 的状态，该状态无条件转换到一个输出为 `$(0, 1, 0)$` 的状态。\n5) 风扇一直运行，直到定时器断言 `$T=1$` 时才关闭，因此从延时运行状态 `$(L,F)=(0,1)$`，当 `$T=1$` 且 `$S=0$` 时，我们必须转换到空闲状态 `(0,0)`。\n6) 如果用户在延时运行期间（即 `$T=1$` 之前）将 `$S$` 重新置为 `$1$`，系统必须立即返回到状态 `$(L,F)=(1,1)$`，从而取消定时器。在摩尔型 ASM 中，这意味着从任何与延时运行相关的状态，当 `$S=1$` 时，我们都必须优先转换到 `(1,1)` 状态。\n\n现在根据这些摩尔约束来评估选项：\n- 选项 A 提供了四个状态：`IDLE` 其输出为 `$(L, F, \\text{Start\\_Timer})=(0, 0, 0)$`；`ACTIVE` 其输出为 `(1, 1, 0)`；`START_DELAY` 其输出为 `(0, 1, 1)`；以及 `FAN_OVERRUN` 其输出为 `(0, 1, 0)`。从 `ACTIVE` 状态在 `$S=0$` 时的转换进入 `START_DELAY`，由于在下一个时钟周期无条件转换到 `FAN_OVERRUN`，这使得 `$\\text{Start\\_Timer}=1$` 被断言正好一个周期。在 `FAN_OVERRUN` 状态下，如果 `$S=1$`，则转换回 `ACTIVE`（立即取消定时器），如果 `$S=0$` 且 `$T=1$`，则转换到 `IDLE`（风扇关闭）。所有输出都基于状态，因此这是一个有效的摩尔型 ASM，它满足了单周期 `Start_Timer` 的要求以及所有行为 1-6。\n- 选项 B 在整个 `OVERRUN` 状态期间都将 `$\\text{Start\\_Timer}$` 设置为 1，这个状态会持续多个周期直到 `$T=1$`，这违反了单周期脉冲的要求。因此它是不正确的。\n- 选项 C 缺少了从延时运行状态在 `$S=1$` 时转换到活动状态的转换，违反了在延时运行期间立即返回两者都开启并取消定时器的要求。因此它是不正确的。\n- 选项 D 断言 `Start_Timer` 是在“`$S$` 变为 0 的转换时”，这使得 `Start_Timer` 依赖于转换而不是纯粹依赖于状态。这不是一个摩尔规范。因此它不是一个有效的摩尔型 ASM。\n\n只有选项 A 满足摩尔型的要求和所有指定的行为，包括通过专用的瞬态生成单周期 `Start_Timer` 脉冲，并在延时运行期间通过 `$S=1$` 正确处理取消操作。", "answer": "$$\\boxed{A}$$", "id": "1908113"}, {"introduction": "既然我们已经了解了如何用 ASM 图表来建模行为，那么让我们进入下一个步骤：在硬件中实现它。机械开关因其触点抖动而“嘈杂”，本练习将解决一个经典问题——对按钮按键进行去抖，以生成一个单一、干净的信号 [@problem_id:1957151]。通过推导触发器输入的布尔表达式，你将直接连接抽象的状态图和其物理实现所需的具体组合逻辑，填补从理论到实践的鸿沟。", "problem": "在数字逻辑设计中，与按钮等机械元件接口时会遇到一个挑战，称为触点抖动。当按下或释放机械开关时，其金属触点会发生物理反弹，产生一系列快速的、虚假的电脉冲，而不是一个单一、干净的跳变。一个常见的解决方案是使用一个实现为有限状态机（FSM）的去抖动电路。\n\n你的任务是为这样一个 FSM 设计组合逻辑。该 FSM 有两个输入和两个输出：\n- **输入：**\n  - `S`：来自开关的原始信号。按下时 `$S=1$`，释放时 `$S=0$`。该信号是“抖动”的。\n  - `T`：来自外部定时器的信号。`$T=1$` 表示预定义的稳定周期已过。否则 `$T=0$`。\n- **输出：**\n  - `Z`：去抖动后的干净输出信号。在确认有效的按钮按下后，它应该是一个单脉冲，高电平有效，且仅持续一个时钟周期。\n  - `E`：外部定时器的使能信号。`$E=1$` 启动或运行定时器。\n\n该 FSM 遵循此行为，由算法状态机（ASM）图描述：\n1.  从 `IDLE` 状态（`S0`）开始，等待开关被按下（`$S=1$`）。在此状态下，`$Z=0$` 且 `$E=0$`。\n2.  检测到 `$S=1$` 后，转换到 `WAIT` 状态（`S1`）。在此状态下，通过设置 `$E=1$` 来使能定时器。保持 `$Z=0$`。\n3.  保持在 `WAIT` 状态，直到定时器完成（`$T=1$`）。\n4.  一旦 `$T=1$`，再次检查开关输入 `S`。\n    - 如果 `$S=1$`（按压是稳定的），则转换到 `PULSE` 状态（`S2`）。\n    - 如果 `$S=0$`（这是一个抖动/噪声），则转换回 `IDLE` 状态。\n5.  在 `PULSE` 状态下，将干净输出 `$Z$` 置为1，持续一个时钟周期。定时器应被禁用（`$E=0$`）。\n6.  在单脉冲周期之后，转换到 `HELD` 状态（`S3`），在此状态下，机器等待用户释放开关（`$S=0$`）。在此状态下，`$Z=0$` 且 `$E=0$`。\n7.  在 `HELD` 状态下，一旦 `$S=0$`，则转换回 `IDLE` 状态以等待下一次按压。\n\n该 FSM 将使用两个 D 型触发器实现，状态变量为 `$Q_1$` 和 `$Q_0$`。状态分配如下：\n- `$S_0$` (IDLE): `$Q_1Q_0 = 00$`\n- `$S_1$` (WAIT): `$Q_1Q_0 = 01$`\n- `$S_2$` (PULSE): `$Q_1Q_0 = 10$`\n- `$S_3$` (HELD): `$Q_1Q_0 = 11$`\n\n你的任务是确定触发器输入 `$D_1$` 和 `$D_0$` 以及去抖动输出 `$Z$` 的正确的、简化的、积之和形式的布尔表达式集。在下面的表达式中，`·` 表示逻辑与，`+` 表示逻辑或，撇号 `'` 表示逻辑非。\n\n以下哪个选项提供了正确的方程组？\n\nA.\n$D_1 = Q_1 \\cdot Q_0' + Q_1 \\cdot Q_0 \\cdot S + Q_0 \\cdot S \\cdot T$\n$D_0 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot T' + Q_1' \\cdot Q_0' \\cdot S + Q_1 \\cdot Q_0 \\cdot S$\n$Z = Q_1 \\cdot Q_0'$\n\nB.\n$D_1 = Q_1 + S \\cdot T$\n$D_0 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot T' + Q_0' \\cdot S$\n$Z = Q_1 \\cdot Q_0'$\n\nC.\n$D_1 = Q_1 \\cdot Q_0' + Q_1 \\cdot Q_0 \\cdot S + Q_0 \\cdot S \\cdot T$\n$D_0 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot T' + Q_1' \\cdot Q_0' \\cdot S + Q_1 \\cdot Q_0 \\cdot S$\n$Z = Q_1$\n\nD.\n$D_1 = Q_1 \\cdot Q_0' + Q_0 \\cdot T$\n$D_0 = Q_1' \\cdot S + Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0$\n$Z = Q_1 \\cdot Q_0'$\n\nE.\n$D_1 = Q_1 \\cdot Q_0' + Q_1' \\cdot Q_0 \\cdot S \\cdot T$\n$D_0 = Q_1' \\cdot Q_0' \\cdot S + Q_1 \\cdot Q_0'$\n$Z = Q_1 \\cdot Q_0'$", "solution": "我们将现态位表示为 `$Q_1$` 和 `$Q_0$`，次态位（D 输入）表示为 `$D_1=Q_1^+` 和 `$D_0=Q_0^+`。输入为 `$S$`（开关）和 `$T$`（定时器完成）。状态编码如下：\n- `$S_0$` (IDLE): `$Q_1Q_0=00$`\n- `$S_1$` (WAIT): `$Q_1Q_0=01$`\n- `$S_2$` (PULSE): `$Q_1Q_0=10$`\n- `$S_3$` (HELD): `$Q_1Q_0=11$`\n\n根据 ASM 描述，状态转换行为如下：\n- 从 `$00$` (IDLE) 开始：如果 `$S=0$`，则保持 `$00$`；如果 `$S=1$`，则变为 `$01$`。此处的 `$T$` 无关。\n- 从 `$01$` (WAIT) 开始：如果 `$T=0$`，则保持 `$01$`；如果 `$T=1$`，则当 `$S=1$` 时变为 `$10$`，否则（`$S=0$`）变为 `$00$`。\n- 从 `$10$` (PULSE) 开始：在下一个时钟无条件地变为 `$11$`。\n- 从 `$11$` (HELD) 开始：如果 `$S=1$`，则保持 `$11$`；如果 `$S=0$`，则变为 `$00$`。此处的 `$T$` 无关。\n\n我们现在以积之和的形式推导 `$D_1$` 和 `$D_0$`。\n\n首先，`$D_1=1$` 当且仅当次态的 `$Q_1^+=1$`。枚举各种情况：\n- 从 `$01$` 开始且 `$T=1$` 和 `$S=1$`：`$01 \\to 10$`，因此 `$Q_1^+=1$`。这会产生项 `$Q_1'Q_0ST$`。\n- 从 `$10$` 开始：`$10 \\to 11$` 与 `$S,T$` 无关，因此对于所有 `$Q_1=1, Q_0=0$` 的现态最小项，都有 `$Q_1^+=1$`。这会产生项 `$Q_1Q_0'$`。\n- 从 `$11$` 开始且 `$S=1$`：`$11 \\to 11$`，因此 `$Q_1^+=1$`。这会产生项 `$Q_1Q_0S$`。\n因此，\n$$D_1=Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$$\n通过卡诺图化简，$Q_1'Q_0ST + Q_1Q_0S$ 可以简化。让我们重新检查原始推导 `$D_{1}=Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{0}ST$`.\n$Q_1Q_0S + Q_1'Q_0ST = Q_0S(Q_1 + Q_1'T) = Q_0S(Q_1 + T)$. This does not simplify to $Q_0ST$.\nLet's check the derivation in option A: $D_1 = Q_1 Q_0' + Q_1 Q_0 S + Q_0 S T$.\nLet's test this equation. $Q_1 Q_0 S + Q_0 S T = Q_0 S (Q_1 + T)$.\nThe term $Q_1'Q_0ST$ should make $D_1=1$. With the formula from A: $Q_1 Q_0' + Q_1 Q_0 S + Q_0 S T = 0 \\cdot 0' + 0 \\cdot 1 \\cdot 1 + 1 \\cdot 1 \\cdot 1 = 0+0+1=1$. It works.\nThe term $Q_1Q_0S$ should make $D_1=1$. With the formula from A: $1 \\cdot 1' + 1 \\cdot 1 \\cdot 1 + 1 \\cdot 1 \\cdot 1 = 0 + 1 + 1 = 1$. It works.\nThe term $Q_1Q_0'$ should make $D_1=1$. Formula from A: $1 \\cdot 0' + ... = 1$. Works.\nThe solution logic is correct, just that the boolean expression in option A is a simplified form. $Q_1'Q_0ST + Q_1Q_0S = Q_0S(Q_1+T)$, which is not $Q_0S(Q_1+Q_1'T)$. There might be a simplification I'm missing.\n$Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$ is the Sum of Products. Let's check the simplified form $Q_1Q_0' + Q_1Q_0S + Q_0ST$. The term $Q_0ST$ covers both $Q_1Q_0ST$ and $Q_1'Q_0ST$. Our initial derivation only had $Q_1'Q_0ST$. We need to consider all cases where $D_1=1$.\n$D_1 = Q_1'Q_0ST + Q_1Q_0' (\\text{any } S,T) + Q_1Q_0S (\\text{any } T)$.\n$Q_1Q_0' (S'T' + S'T + ST' + ST) + Q_1Q_0S(T' + T) + Q_1'Q_0ST$\n$D_1 = Q_1Q_0' + Q_1Q_0ST' + Q_1Q_0ST + Q_1'Q_0ST = Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$.\nUsing K-map for $D_1(Q_1, Q_0, S, T)$: minterms are $(1,0,S,T)$ -> $m_{8,9,10,11}$, $(1,1,1,T)$ -> $m_{13,15}$, $(0,1,1,1)$ -> $m_7$.\n$D_1 = \\sum m(7, 8, 9, 10, 11, 13, 15)$.\nGrouping $m(8,9,10,11)$ gives $Q_1Q_0'$.\nGrouping $m(13,15)$ gives $Q_1ST$.\nGrouping $m(7,15)$ gives $Q_0ST$.\nSo, $D_1 = Q_1Q_0' + Q_1ST + Q_0ST$. This is not option A.\nLet's re-read the transitions carefully.\nS3(11) to S3(11) if S=1. $Q_1Q_0S \\implies D_1=1$. My term $Q_1ST$ is from $Q_1Q_0S(T'+T)$? No, it's from $Q_1S(Q_0T'+Q_0T) = Q_1S Q_0$.\nMy K-map is right. Let's re-derive $D_1 = Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$. This is the unsimplified sum of products.\nLet's check A's expression: $D_1 = Q_1Q_0' + Q_1Q_0S + Q_0ST$.\nThis implies the $Q_1Q_0ST$ term is covered by $Q_0ST$. Yes.\nWhat about my term $Q_1'Q_0ST$? This is also covered by $Q_0ST$.\nWhat about $Q_1Q_0S$? This can be $Q_1Q_0ST$ or $Q_1Q_0ST'$. The first part is covered by $Q_0ST$. The second part, $Q_1Q_0ST'$, is not covered. So $D_1=Q_1Q_0'+Q_0ST+Q_1Q_0ST'$.\nWait, from S3(11) if S=1, stay in S3. $Q_1Q_0S \\to D_1=1$. This term is $Q_1Q_0S$.\nFrom S1(01) if S=1,T=1, go to S2(10). $Q_1'Q_0ST \\to D_1=1$.\nFrom S2(10), go to S3(11). $Q_1Q_0' \\to D_1=1$.\nSo $D_1 = Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$. This is the correct unsimplified expression.\nLet's check the solution's derivation. It says `$D_{1}=Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{0}ST$`. This seems to have a typo, it should be `$Q_1'Q_0ST$`. Let's assume the option A is correct and the derivation had a typo.\nThe equations in Option A are correct for a slightly different state machine or a simplification I'm not seeing. Let's trust the provided solution is correct and there's a subtle simplification.\n$D_1 = Q_1Q_0' + Q_0S(Q_1+T) = Q_1Q_0' + Q_1Q_0S + Q_0ST$. Yes, this simplification is correct. My mistake was in how I read the distribution. $Q_0S(Q_1+T)$ is the same as $Q_1Q_0S + Q_0ST$. So the derived expression `$Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$` can be simplified. Using consensus theorem: $(X \\cdot Y) + (X' \\cdot Z) + (Y \\cdot Z) = (X \\cdot Y) + (X' \\cdot Z)$. Here, $X=Q_1, Y=Q_0S, Z=Q_0ST$. This doesn't apply.\nLet's go back to the K-map: $D_1 = Q_1Q_0' + Q_1ST + Q_0ST$. This is the simplified result. It's not Option A. There is a discrepancy.\nLet's re-check the solution derivation.\n$D_1=1$ from $01 \\to 10$ ($Q_1'Q_0ST$), from $10 \\to 11$ ($Q_1Q_0'$), from $11 \\to 11$ ($Q_1Q_0S$). Sum is $Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$.\n$D_0=1$ from $00 \\to 01$ ($Q_1'Q_0'S$), from $01 \\to 01$ ($Q_1'Q_0T'$), from $10 \\to 11$ ($Q_1Q_0'$), from $11 \\to 11$ ($Q_1Q_0S$). Sum is $Q_1'Q_0'S + Q_1'Q_0T' + Q_1Q_0' + Q_1Q_0S$.\nThe solution's equations match this exactly.\nLet's look at option A again. The D0 equation in option A is `D0 = Q1·Q0' + Q1'·Q0·T' + Q1'·Q0'·S + Q1·Q0·S`. This matches the derivation.\nThe D1 equation in option A is `D1 = Q1·Q0' + Q1·Q0·S + Q0·S·T`. This does NOT match my derivation $D_1 = Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$. The difference is the term $Q_0ST$ vs $Q_1'Q_0ST$. $Q_0ST$ is a larger group and implies that when in state $Q_1Q_0=11$ and $S=1, T=1$, $D_1$ should also be 1. Let's check the state diagram. In S3(11), if S=1, we stay in S3(11). This means $D_1=1$. The term $Q_1Q_0ST$ is a valid implicant. $Q_0ST$ is a prime implicant covering $m_7(0111)$ and $m_{15}(1111)$. Let's check $m_{15}$. State is S3(11), S=1, T=1. We must stay in S3(11). So next state is 11, D1=1. This is correct. So $Q_0ST$ is a valid prime implicant.\nSo the simplified expression is $D_1 = Q_1Q_0' + Q_1Q_0S + Q_0ST$. The equation in option A is correct. The solution's text has `$D_{1}=Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{0}ST.$` which is correct, but my initial derivation had a typo. The text in the solution file is correct, I misread it initially.\n\nMy corrected derivation for $D_1$ sum of products is $Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST$.\nThe simplified form is $D_1 = Q_1Q_0' + Q_1Q_0S + Q_0ST$.\nIs $Q_1Q_0' + Q_1Q_0S + Q_1'Q_0ST = Q_1Q_0' + Q_1Q_0S + Q_0ST$?\nThe LHS is $Q_1Q_0' + Q_0S(Q_1 + Q_1'T)$. The RHS is $Q_1Q_0' + Q_0S(Q_1+T)$.\nIs $Q_1 + Q_1'T = Q_1+T$? Yes, by absorption rule $X+X'Y=X+Y$.\nSo the expression in Option A is the correct simplified form. The solution text is also correct. All good.\n\n$$\nD_{1}=Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{1}'Q_{0}ST = Q_{1}Q_{0}'+Q_{0}S(Q_1 + Q_1'T) = Q_{1}Q_{0}'+Q_{0}S(Q_1+T) = Q_{1}Q_{0}'+Q_{1}Q_{0}S+Q_{0}ST\n$$\nThe solution text is correct as written. I will just format it correctly.\n\n其次，$D_0=1$ 当且仅当次态的 `$Q_0^+=1$`。枚举各种情况：\n- 从 `$00$` 开始且 `$S=1$`：`$00 \\to 01$`，因此 `$Q_0^+=1$`。这会产生 `$Q_1'Q_0'S$`。\n- 从 `$01$` 开始且 `$T=0$`：`$01 \\to 01$`，因此 `$Q_0^+=1$` 与 `$S$` 无关。这会产生 `$Q_1'Q_0T'$`。\n- 从 `$10$` 开始：`$10 \\to 11$`，因此对于所有 `$Q_1=1, Q_0=0$` 的现态最小项，都有 `$Q_0^+=1$`。这会产生 `$Q_1Q_0'$`。\n- 从 `$11$` 开始且 `$S=1$`：`$11 \\to 11$`，因此 `$Q_0^+=1$`。这会产生 `$Q_1Q_0S$`。\n因此，\n$$\nD_{0}=Q_{1}Q_{0}'+Q_{1}'Q_{0}T'+Q_{1}'Q_{0}'S+Q_{1}Q_{0}S.\n$$\n\n最后，去抖动输出 `$Z$` 必须且仅在 PULSE 状态 `$S_2$`（`$Q_1Q_0=10$`）下有效，因此\n$$\nZ=Q_{1}Q_{0}'.\n$$\n\n与选项比较，这些表达式与选项 A 完全匹配。", "answer": "$$\\boxed{A}$$", "id": "1957151"}, {"introduction": "ASM 图表的真正威力在于协调复杂的、多步骤的操作，就像在计算机处理器中那样。这个高级问题挑战你为一个非恢复除法算法设计一个控制器，这是一种基本的算术运算 [@problem_id:1908116]。你的任务是通过生成精确的控制信号序列来管理一个数据通路——包括寄存器、算术逻辑单元（ALU）和计数器——这将迫使你仔细区分仅依赖于状态的信号（Moore 型输出）和同时依赖于输入的信号（Mealy 型输出）。", "problem": "您的任务是为某个专用硬件单元设计一个控制器，该硬件单元使用多周期不恢复余数除法算法来执行两个`$N$`位无符号整数（被除数和除数）的除法运算。\n\n**数据通路和控制信号：**\n由您的算法状态机 (ASM) 控制的数据通路包括一个 `$(N+1)$` 位寄存器 `A` (累加器，初始化为零)、一个 `$N$` 位移位寄存器 `Q` (用于存放被除数/商)、一个 `$N$` 位寄存器 `M` (用于存放除数) 和一个 `$N$` 位递减计数器 `n`。该控制器接收以下状态输入：\n- `start`：一个单周期信号，用于启动除法过程。\n- `n_zero`：当计数器 `n` 为零时为高电平的信号。\n- `A_sign`：寄存器 `A` 的最高有效位 (MSB)，表示其符号 (0 为正，1 为负)。\n\n控制器必须生成以下控制信号：\n- `Init_Cycle`：在一个周期内执行初始化任务的信号。\n- `n_dec`：将计数器 `n` 减一。\n- `AQ_shift_left`：对级联寄存器 `{A, Q}` 执行1位逻辑左移。\n- `A_load_from_ALU`：将数据通路的算术逻辑单元 (ALU) 的输出加载到寄存器 `A`。\n- `ALU_op_is_add`：用于 ALU 的信号。如果为高电平，ALU 计算 `$A + M$`；如果为低电平，则计算 `$A - M$`。\n- `Q0_write_enable`：使能 `Q` 的最低有效位 `$Q[0]$` 进行更新。当此信号有效时，数据通路被硬连线设计为将值 `$\\text{NOT}(\\text{ALU\\_output\\_sign})$` 写入 `$Q[0]$`。\n- `A_load_correction`：为最终修正步骤将 `$A + M$` 的结果加载到寄存器 `A` 的信号。\n- `Done`：算法完成后置位的信号。\n\n**算法规范：**\n控制器必须实现以下多周期算法：\n1.  **空闲阶段：** 控制器在 `IDLE` 状态下等待，直到 `start` 信号被置位。\n2.  **初始化周期：** 收到 `start` 信号后，控制器转换到 `INIT` 状态一个周期，并置位 `Init_Cycle` 信号。该信号使数据通路将 `A` 加载为 0，`Q` 加载为被除数，`M` 加载为除数，计数器 `n` 加载为 `$N$`。\n3.  **迭代循环 (每位2个周期)：** 控制器随后进入一个重复 `$N$` 次的循环。每次迭代由两个连续的周期 (两个状态) 组成：\n    a. **移位周期：** `{A, Q}` 寄存器左移一位，计数器 `n` 减一。\n    b. **ALU 周期：** 根据移位后 `A` 的符号 (`A_sign`) 执行 ALU 操作，并将结果存回 `A`。具体来说，如果 `$A_{\\text{sign}}$` 为 0，操作为 `$A - M$`。如果 `$A_{\\text{sign}}$` 为 1，操作为 `$A + M$`。同时，新的商位被写入 `$Q[0]$`。\n4.  **修正周期：** 经过 `$N$` 次迭代后 (当 `n_zero` 为高电平时检测到)，控制器检查 `A` 中最终余数的符号。如果 `A` 为负 (`$A_{\\text{sign}} = 1$`)，则执行一个单周期的修正步骤，其中 `A` 被更新为 `$A + M$`。如果 `A` 为非负，则跳过此周期。\n5.  **完成阶段：** 控制器将 `Done` 信号置位一个周期，然后返回 `IDLE` 状态。\n\n**问题：**\n对于根据这些规范设计的最小化ASM控制器，请确定在与算法的 **ALU 周期** (步骤 3b) 相对应的状态中，作为 **摩尔 (Moore) 型输出** 而被置位的完整控制信号集。摩尔型输出是一种控制信号，它仅基于处于特定状态而被置位，并且与在该周期内评估的状态输入 (`start`、`n_zero`、`A_sign`) 无关。\n\nA. `{AQ_shift_left, n_dec}`\nB. `{A_load_from_ALU, Q0_write_enable}`\nC. `{n_dec, A_load_from_ALU}`\nD. `{A_load_from_ALU, Q0_write_enable, ALU_op_is_add}`\nE. `{A_load_correction}`", "solution": "我们必须确定哪些控制信号在 ALU 周期状态 (步骤 3b) 中被置位，这纯粹是因为控制器处于该状态，即它们是摩尔 (Moore) 型输出，与状态输入的当前值无关。\n\n根据算法，在每次迭代中，ALU 周期执行以下操作：\n- 对 `$A$` 和 `$M$` 执行一次 ALU 操作，具体操作根据 `$A_{\\text{sign}}$` 选择：如果 `$A_{\\text{sign}}=0$`，计算 `$A - M$`；如果 `$A_{\\text{sign}}=1$`，计算 `$A + M$`。\n- 将结果加载回 `$A$`。\n- 同时，通过使能 `Q0_write_enable` 将新的商位写入 `$Q[0]$`；当该信号使能时，数据通路的硬连线设计会将 `$\\text{NOT}(\\text{ALU\\_output\\_sign})$` 写入。\n\n由此可知，在每个 ALU 周期中，无论 `$A_{\\text{sign}}$`、`n_zero` 或 `start` 的值如何，都必须置位的信号是：\n- `A_load_from_ALU`：需要在该周期中将 ALU 结果存入 `$A$`，这在每次迭代的 ALU 阶段都是无条件执行的。\n- `Q0_write_enable`：需要在该周期中写入商位，这在每次迭代的 ALU 阶段也是无条件执行的。\n\n信号 `ALU_op_is_add` 的值由同一周期内的 `$A_{\\text{sign}}$` 决定 (它在 `$A+M$` 和 `$A-M$` 之间进行选择)，因此它不是摩尔型输出；它是一个与米利 (Mealy) 型相关的控制。信号 `AQ_shift_left` 和 `n_dec` 属于移位周期，而不是 ALU 周期。信号 `A_load_correction` 仅属于最后的修正周期。这些信号中没有一个仅仅因为处于 ALU 周期状态而被置位。\n\n因此，在 ALU 周期中置位的摩尔型输出的完整集合恰好是 `{A_load_from_ALU, Q0_write_enable}`，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1908116"}]}