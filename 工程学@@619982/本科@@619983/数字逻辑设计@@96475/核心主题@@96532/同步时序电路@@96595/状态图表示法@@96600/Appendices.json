{"hands_on_practices": [{"introduction": "让我们从一个经典的序列检测问题开始。在许多数字通信和数据处理应用中，我们需要识别输入数据流中的特定模式。这个练习将指导你为一个 ‘111’ 重叠序列检测器构建状态转移表，这是一个完美的Mealy型有限状态机（FSM）实例，其输出同时取决于当前状态和当前输入。通过这个练习，你将掌握如何将需求转化为精确的状态转换逻辑。[@problem_id:1962078]", "problem": "一个数字系统包含一个“突发信号触发器”，用于监视单位元串行数据流。该触发器有一个输入 $x$ 和一个输出 $z$。系统与一个时钟同步运行。触发器的功能是，当且仅当当前输入位为'1'且紧邻的前两个输入位也为'1'时，将其输出 $z$ 置为高逻辑电平（'1'）。此功能必须考虑重叠序列；例如，输入流'...011110...'应产生输出流'...000110...'。在所有其他时间，输出 $z$ 必须处于低逻辑电平（'0'）。\n\n这种行为可以用一个有限状态机来描述。假设该系统被设计为具有最少状态数的Mealy机，以下哪个状态转换表正确地表示了其行为？状态定义如下：\n- $S_0$：初始或复位状态。所需的'1'序列已被中断。\n- $S_1$：最近一个输入位是'1'。\n- $S_2$：最近两个输入位是'11'。\n\n表格以（当前状态，输入 $x$，下一状态，输出 $z$）的格式呈现。\n\nA)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S0, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S2, 1)\n\nB)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S0, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S0, 1)\n\nC)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S1, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S2, 1)\n\nD)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S0, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S1, 1)\n\nE)\n(S0, 0, S0, 0)\n(S0, 1, S1, 1)\n(S1, 0, S0, 0)\n(S1, 1, S2, 1)\n(S2, 0, S0, 0)\n(S2, 1, S2, 1)", "solution": "题目要求我们设计一个Mealy型有限状态机，用于检测串行比特流中的'111'序列，包括重叠出现的情况。Mealy机的输出是其当前状态和当前输入的函数。我们需要确定状态转换和相应的输出。\n\n状态是根据检测'111'序列的进展来定义的：\n- $S_0$：复位状态。尚未检测到目标序列的任何前缀。这是在接收到'0'后或启动时的状态。\n- $S_1$：最后一个输入是'1'。这代表已经看到了前缀'1'。\n- $S_2$：最后两个输入是'11'。这代表已经看到了前缀'11'。\n\n让我们根据输入 $x \\in \\{0, 1\\}$ 来分析每个状态的转换。\n\n**状态 $S_0$ (复位状态) 的分析：**\n- 如果当前输入为 $x=0$：状态机没有看到可以开始序列的'1'。系统保持在复位状态 $S_0$。输出 $z$ 必须为0。\n  - 转换：（当前状态：$S_0$，输入：0）$\\rightarrow$（下一状态：$S_0$，输出：0）。\n- 如果当前输入为 $x=1$：这是一个潜在序列的第一个'1'。状态机转换到状态 $S_1$ 以记住它已经看到了一个'1'。完整的序列尚未被检测到，所以输出 $z$ 为0。\n  - 转换：（当前状态：$S_0$，输入：1）$\\rightarrow$（下一状态：$S_1$，输出：0）。\n\n**状态 $S_1$ (已看到一个'1') 的分析：**\n- 如果当前输入为 $x=0$：由于接收到了一个'0'，序列被中断。状态机必须返回到复位状态 $S_0$。输出 $z$ 为0。\n  - 转换：（当前状态：$S_1$，输入：0）$\\rightarrow$（下一状态：$S_0$，输出：0）。\n- 如果当前输入为 $x=1$：状态机处于状态 $S_1$（意味着前一个输入是'1'），现在又接收到一个'1'。序列现在以'11'结尾。状态机转换到状态 $S_2$。完整的'111'序列尚未完成，所以输出 $z$ 为0。\n  - 转换：（当前状态：$S_1$，输入：1）$\\rightarrow$（下一状态：$S_2$，输出：0）。\n\n**状态 $S_2$ (已看到'11') 的分析：**\n- 如果当前输入为 $x=0$：序列被中断。状态机必须返回到复位状态 $S_0$。输出 $z$ 为0。\n  - 转换：（当前状态：$S_2$，输入：0）$\\rightarrow$（下一状态：$S_0$，输出：0）。\n- 如果当前输入为 $x=1$：状态机处于状态 $S_2$（前两个输入是'11'），现在接收到一个'1'。这完成了'111'序列。因此，输出 $z$ 必须为1。题目指定检测器必须处理重叠序列。考虑输入'1111'。第一个'111'应产生输出1。此时，最后接收到的两个输入是'11'。这恰好是处于状态 $S_2$ 的条件。因此，为了检测下一个'111'序列（由第一个序列的最后两个'1'和新的'1'组成），状态机必须转换回状态 $S_2$。\n  - 转换：（当前状态：$S_2$，输入：1）$\\rightarrow$（下一状态：$S_2$，输出：1）。\n\n**整理状态表：**\n结合以上推导出的所有转换，我们可以构建完整的状态转换表：\n\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $z$ |\n|---------------|-----------|------------|------------|\n| $S_0$         | 0         | $S_0$      | 0          |\n| $S_0$         | 1         | $S_1$      | 0          |\n| $S_1$         | 0         | $S_0$      | 0          |\n| $S_1$         | 1         | $S_2$      | 0          |\n| $S_2$         | 0         | $S_0$      | 0          |\n| $S_2$         | 1         | $S_2$      | 1          |\n\n该表与选项A中提供的表完全匹配。让我们分析其他选项以确认它们不正确。\n- 选项B是一个非重叠检测器，因为在（S2, 1）时，它转换到S0，重置了序列。\n- 选项C不正确，因为转换（S1, 0, S1, 0）是错误的；接收到'0'必须中断序列并复位到S0。\n- 选项D在输入'1'时从S2错误地转换到S1。这将无法正确检测像'1111'这样的重叠序列。它会检测到'111'，然后转换到一个‘已看到一个1’的状态，而未能识别出最后两个输入是'11'。\n- 选项E错误地将转换（S0, 1）和（S1, 1）的输出设置为1，这不符合题目要求。只有在完整的'111'序列完成时，输出才应为1。\n\n因此，选项A是指定突发信号触发器的唯一正确表示。", "answer": "$$\\boxed{A}$$", "id": "1962078"}, {"introduction": "现在，让我们探讨另一种有限状态机——Moore机。与Mealy机不同，Moore机的输出仅由当前状态决定。这个练习要求你设计一个Moore机来检测数据流中连续五个或更多‘1’的序列，这在数据完整性校验等场景中非常有用。通过追踪给定输入序列的输出，你将能清晰地体会到Moore机在设计和行为上与Mealy机的根本区别。[@problem_id:1962047]", "problem": "一个用于监控数据完整性的数字系统包含一个比特流异常检测器。该检测器实现为一个同步有限状态机 (FSM)。该 FSM 逐个时钟周期处理一个串行二进制输入流，记为 `X`。它产生一个单一的二进制输出 `E`，用作错误标志。\n\n该系统设计为摩尔机（Moore machine），其输出仅由机器的当前状态决定。当且仅当机器处于刚刚在输入 `X` 上接收到连续五个或更多个 `1` 的序列所对应的状态时，错误标志 `E` 必须被置位（设置为 `1`）。在所有其他状态下，`E` 必须为 `0`。\n\n该 FSM 从一个指定的初始状态 $S_{\\text{reset}}$ 开始运行，该状态表示尚未检测到连续的 `1`（例如，在加电后或接收到 `0` 之后）。\n\n考虑系统在离散时间步长 `t=1, 2, 3, ...` 的情况。机器在时间 `t` 的状态记为 `S(t)`，在该时间接收到的输入比特记为 `X(t)`。机器在时间 `t` 的输出记为 `E(t)`，是当前状态 `S(t)` 的函数。下一个周期的状态 `S(t+1)` 由当前状态 `S(t)` 和当前输入 `X(t)` 决定。初始状态为 `S(1)` = $S_{\\text{reset}}$。\n\n给定从 `t=1`到`t=14` 的 14 位输入序列 `X` 为 `11110111110111`，确定相应的 14 位输出序列 `E`。请将您的答案表示为一个长度为 14 的二进制字符串，代表序列 `E(1)E(2)...E(14)`。", "solution": "将摩尔 FSM 建模，其状态编码了当前连续 1 的运行长度：定义 $c(t)\\in\\{0,1,2,3,4,5^+\\}$ 为当前状态 $S(t)$ 所代表的计数，其中 $c(t)=0$ 表示 $S_{\\text{reset}}$，$c(t)=5^+$ 表示五个或更多。摩尔机的输出为\n$$E(t)=\\begin{cases}\n1,& c(t)=5^+,\\\\\n0,& \\text{otherwise}.\n\\end{cases}$$\n下一状态的更新规则，与 $S(t+1)$ 取决于 $S(t)$ 和 $X(t)$ 的规范一致，如下所示：\n- 如果 $X(t)=0$，则 $c(t+1)=0$。\n- 如果 $X(t)=1$ 且 $c(t)\\in\\{0,1,2,3\\}$，则 $c(t+1)=c(t)+1$。\n- 如果 $X(t)=1$ 且 $c(t)=4$，则 $c(t+1)=5^+$。\n- 如果 $X(t)=1$ 且 $c(t)=5^+$，则 $c(t+1)=5^+$。\n\n初始条件：$S(1)=S_{\\text{reset}}$，因此 $c(1)=0$。\n\n逐步处理给定的输入 $X(1\\ldots 14)=11110111110111$，使用 $c(t)$ 得到 $E(t)$，然后根据 $c(t)$ 和 $X(t)$ 更新 $c(t+1)$：\n\n- $t=1$：$c(1)=0$，所以 $E(1)=0$。$X(1)=1\\Rightarrow c(2)=1$。\n- $t=2$：$c(2)=1$，所以 $E(2)=0$。$X(2)=1\\Rightarrow c(3)=2$。\n- $t=3$：$c(3)=2$，所以 $E(3)=0$。$X(3)=1\\Rightarrow c(4)=3$。\n- $t=4$：$c(4)=3$，所以 $E(4)=0$。$X(4)=1\\Rightarrow c(5)=4$。\n- $t=5$：$c(5)=4$，所以 $E(5)=0$。$X(5)=0\\Rightarrow c(6)=0$。\n- $t=6$：$c(6)=0$，所以 $E(6)=0$。$X(6)=1\\Rightarrow c(7)=1$。\n- $t=7$：$c(7)=1$，所以 $E(7)=0$。$X(7)=1\\Rightarrow c(8)=2$。\n- $t=8$：$c(8)=2$，所以 $E(8)=0$。$X(8)=1\\Rightarrow c(9)=3$。\n- $t=9$：$c(9)=3$，所以 $E(9)=0$。$X(9)=1\\Rightarrow c(10)=4$。\n- $t=10$：$c(10)=4$，所以 $E(10)=0$。$X(10)=1\\Rightarrow c(11)=5^+$。\n- $t=11$：$c(11)=5^+$，所以 $E(11)=1$。$X(11)=0\\Rightarrow c(12)=0$。\n- $t=12$：$c(12)=0$，所以 $E(12)=0$。$X(12)=1\\Rightarrow c(13)=1$。\n- $t=13$：$c(13)=1$，所以 $E(13)=0$。$X(13)=1\\Rightarrow c(14)=2$。\n- $t=14$：$c(14)=2$，所以 $E(14)=0$。$X(14)=1\\Rightarrow c(15)=3$。\n\n因此，输出序列 $E(1\\ldots 14)$ 为 $00000000001000$。", "answer": "$$\\boxed{00000000001000}$$", "id": "1962047"}, {"introduction": "准备好迎接一个更高级的挑战了吗？这个问题将带你超越固定序列检测的范畴，进入参数化模式识别的领域。你需要设计一个Mealy机来检测形如 $b_1 b_2 b_3 b_1 b_2$ 的序列，其中 $b_1$ 和 $b_2$ 是可变的。这项任务将迫使你深入思考：一个状态究竟需要‘记忆’哪些关键信息才能完成任务？确定实现这一功能所需的最小状态数，将极大地锻炼你对状态定义的抽象思维和状态最小化原理的理解。[@problem_id:1962028]", "problem": "一个同步数字系统被设计用于监控一个连续的串行二进制数据流。该系统采用一个 Mealy 型有限状态机 (FSM) 来检测一类特定的 5 比特序列。该 FSM 有一个单一数据输入 `X`（每个时钟周期到达一个比特）和一个单一输出 `Z`。\n\n当且仅当最近接收的五个比特（包括输入 `X` 上的当前比特）构成一个形如 $b_1 b_2 b_3 b_1 b_2$ 结构的序列时，输出 `Z` 被置为 `1`。对于这种结构，第一个比特 $b_1$ 必须与第四个比特相同，第二个比特 $b_2$ 必须与第五个（最新的）比特相同。第三个位置的比特 $b_3$ 可以是 `0` 或 `1`，不影响该模式的有效性。该状态机需要检测所有这样有效的 5 比特模式，包括那些重叠的模式。\n\n例如，如果输入流以 `...01101` 结尾，当接收到最后一个 `1` 时，输出 `Z` 应为 `1`，因为序列 `01101` 匹配 $b_1=0$, $b_2=1$, $b_3=1$ 的结构。类似地，对于以 `...11011` 结尾的输入流，当接收到最后一个 `1` 时，输出 `Z` 为 `1`，对应于 $b_1=1$, $b_2=1$, $b_3=0$。\n\n确定实现这个 Mealy FSM 所需的最小状态数。", "solution": "我们首先将要求形式化。设时钟 t 时的最后五个比特表示为 $x_{t-4}x_{t-3}x_{t-2}x_{t-1}x_{t}$，其中当前输入为 $X=x_{t}$。输出必须满足\n$$\nZ(t)=1 \\quad \\text{iff} \\quad x_{t-4}=x_{t-1} \\text{ and } x_{t-3}=x_{t}.\n$$\n等价地，如果我们将 $X$ 之前的四个最新比特表示为\n$$\nA=x_{t-4}, \\quad B=x_{t-3}, \\quad C=x_{t-2}, \\quad D=x_{t-1},\n$$\n那么在接收到输入 $X$ 时，状态机必须产生\n$$\nZ=1 \\text{ iff } (A=D) \\text{ and } (B=X).\n$$\n\n第一步（通过显式构造法求上界）。一个为每个 4 比特历史 $(A,B,C,D)\\in\\{0,1\\}^{4}$ 设置一个状态的 Mealy FSM 可以实现该规范：\n- 状态：编码最后四个比特 $(A,B,C,D)$。\n- 在输入 $X$ 上的转移：转移到新状态 $(B,C,D,X)$。\n- 在输入 $X$ 上的输出：\n$$\nZ=(A=D)\\wedge(B=X).\n$$\n这个 FSM 有 $2^{4}=16$ 个状态，并且恰好在最后五个比特为 $A\\,B\\,C\\,D\\,X$ 且满足 $A=D$ 和 $B=X$ 时将 $Z$ 置为 `1`。因此，最小状态数至多为 $16$。\n\n第二步（通过可区分性求下界）。我们通过证明所有 $16$ 种可能的 4 比特历史相对于未来的输出都是两两可区分的，即它们属于不同的 Nerode 等价类，来表明任何 Mealy FSM 都不能使用少于 $16$ 个状态。\n\n通过引入定义如下的 $p\\in\\{0,1\\}$ 来改进记法：\n$$\np=\\begin{cases}\n1, & \\text{if } A=D,\\\\\n0, & \\text{if } A\\neq D.\n\\end{cases}\n$$\n那么，在输入 $X$ 时的即时输出为\n$$\nZ=p \\wedge (X=B).\n$$\n输入 $X$ 后的下一个状态变为 $(B,C,D,X)$。因此，从当前时刻起能影响所有未来输出的信息恰好是四元组 $(p,B,C,D)$。\n\n我们现在证明，任意两个不同的四元组 $(p,B,C,D)$ 和 $(p',B',C',D')$ 是可通过某个（有限）输入序列区分的，即存在一个公共的输入字符串，施加于两者之上时，它们的输出序列会不同。\n\n考虑任意两个不同的四元组。分情况对它们进行区分：\n\n1) 如果 $B\\neq B'$，令输入序列为两步：首先 $X_{1}=0$，然后 $X_{2}=C$（取 $B=0$ 的那个状态的 $C$ 值）。第一步之后，中间指示符变为 $p_{1}=[B=0]$，对于 $B=0$ 的状态，该值为 $1$，而对于 $B=1$ 的状态，该值为 $0$。在第二步，输出为\n$$\nZ_{2}=p_{1}\\wedge (X_{2}=C).\n$$\n选择 $B=0$ 状态的 $C$ 作为 $X_{2}$，可以确保该状态的 $Z_{2}=1$，而对于另一个状态，$p_{1}=0$，因此 $Z_{2}=0$。因此输出不同。\n\n2) 若 $B=B'$，且 $C\\neq C'$，令输入序列为 $X_{1}=B$，然后 $X_{2}=0$。第一步之后，我们有 $p_{1}=[B=B]=1$，并且新存储的 $B$ 等于旧的 $C$。在第二步，输出为\n$$\nZ_{2}=p_{1}\\wedge (X_{2}=B_{\\text{new}})=1\\wedge (0=C)=[C=0],\n$$\n因为 $C\\neq C'$，所以该值不同。\n\n3) 若 $B=B', C=C'$，且 $D\\neq D'$，令输入序列为 $X_{1}=B$，然后 $X_{2}=C$，然后 $X_{3}=0$。输入 $X_{1}=B$ 后, $p_{1}=[B=B]=1$ 且新的 $B$ 等于 $C$。输入 $X_{2}=C$ 后, $p_{2}=[B_{\\text{new}}=X_{2}]=[C=C]=1$ 且新的 $B$ 等于旧的 $D$。在第三步，输出为\n$$\nZ_{3}=p_{2}\\wedge (X_{3}=B_{\\text{new}})=1\\wedge (0=D)=[D=0],\n$$\n因为 $D\\neq D'$，所以该值不同。\n\n4) 若 $B=B', C=C', D=D'$ 但 $(p,B,C,D)\\neq(p',B',C',D')$，则 $p\\neq p'$。令输入为 $X_{1}=B$。那么\n$$\nZ_{1}=p\\wedge (X_{1}=B)=p,\\quad Z_{1}'=p'\\wedge (X_{1}=B)=p',\n$$\n由于 $p\\neq p'$，输出立即不同。\n\n因此，任意两个不同的四元组都是可区分的。所以，至少有 16 个可区分状态，这给出了一个 16 的下界。\n\n结合上界（一个显式的 16 状态构造）和下界（所有 16 种上下文的两两可区分性），所需的最小状态数恰好是 16。", "answer": "$$\\boxed{16}$$", "id": "1962028"}]}