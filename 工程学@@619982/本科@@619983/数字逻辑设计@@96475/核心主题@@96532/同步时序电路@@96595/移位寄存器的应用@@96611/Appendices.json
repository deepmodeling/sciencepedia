{"hands_on_practices": [{"introduction": "要真正掌握移位寄存器的应用，首先需要透彻理解其基本操作。这个练习旨在通过一个双向移位寄存器的实例，巩固您对数据如何逐位移动的理解。通过追踪寄存器在多个时钟周期内的状态变化，您将练习处理依赖于当前状态的串行输入逻辑 $SI_R = Q_2 \\oplus Q_1$，这是许多复杂数字系统中常见的场景 [@problem_id:1958084]。", "problem": "为某信号处理应用设计了一个专用的4位同步双向移位寄存器。该寄存器的位表示为 $Q_3, Q_2, Q_1, Q_0$，其中 $Q_3$ 是最高有效位（MSB），$Q_0$ 是最低有效位（LSB）。该寄存器初始并行加载了二进制值 `1100`。\n\n寄存器的行为由以下规则在每个时钟周期确定：\n\n1.  **右移操作**：寄存器的内容向右移动一个位置。位 $Q_3$ 被串行输入 $SI_R$ 替代，$Q_2$ 被旧的 $Q_3$ 替代，$Q_1$ 被旧的 $Q_2$ 替代，$Q_0$ 被旧的 $Q_1$ 替代。右移的串行输入 $SI_R$ 由移位*前*的寄存器状态根据逻辑表达式 $SI_R = Q_2 \\oplus Q_1$ 决定，其中 $\\oplus$ 表示异或（XOR）操作。\n\n2.  **左移操作**：寄存器的内容向左移动一个位置。位 $Q_0$ 被串行输入 $SI_L$ 替代，$Q_1$ 被旧的 $Q_0$ 替代，$Q_2$ 被旧的 $Q_1$ 替代，$Q_3$ 被旧的 $Q_2$ 替代。左移的串行输入 $SI_L$ 由移位*前*的寄存器状态根据逻辑表达式 $SI_L = \\neg Q_3$ 决定，其中 $\\neg$ 表示逻辑非（NOT）操作。\n\n一系列操作被应用于该寄存器，每个操作对应一个时钟脉冲。该序列是：\n- 时钟脉冲 1：右移\n- 时钟脉冲 2：右移\n- 时钟脉冲 3：左移\n\n在第三个时钟脉冲之后，寄存器的最终二进制内容，表示为序列 $Q_3Q_2Q_1Q_0$，是什么？\n\nA. `0011`\n\nB. `0110`\n\nC. `1100`\n\nD. `1110`\n\nE. `1111`", "solution": "这个4位寄存器有从 $Q_{3}$（MSB）到 $Q_{0}$（LSB）的位，并初始加载为 $Q_{3}Q_{2}Q_{1}Q_{0}=1100$，所以 $Q_{3}=1$，$Q_{2}=1$，$Q_{1}=0$，$Q_{0}=0$。\n\n时钟脉冲 1 (右移)：串行输入由移位前状态计算得出：$SI_{R}=Q_{2}\\oplus Q_{1}$。根据初始状态，$SI_{R}=1\\oplus 0=1$。右移更新规则给出\n$$\nQ_{3}\\leftarrow SI_{R}=1,\\quad Q_{2}\\leftarrow \\text{old }Q_{3}=1,\\quad Q_{1}\\leftarrow \\text{old }Q_{2}=1,\\quad Q_{0}\\leftarrow \\text{old }Q_{1}=0,\n$$\n因此，在此脉冲后，$Q_{3}Q_{2}Q_{1}Q_{0}=1110$。\n\n时钟脉冲 2 (右移)：现在根据当前状态 $1110$ 计算 $SI_{R}$：$SI_{R}=Q_{2}\\oplus Q_{1}=1\\oplus 1=0$。应用右移更新：\n$$\nQ_{3}\\leftarrow 0,\\quad Q_{2}\\leftarrow \\text{old }Q_{3}=1,\\quad Q_{1}\\leftarrow \\text{old }Q_{2}=1,\\quad Q_{0}\\leftarrow \\text{old }Q_{1}=1,\n$$\n得到 $Q_{3}Q_{2}Q_{1}Q_{0}=0111$。\n\n时钟脉冲 3 (左移)：串行输入由移位前状态 $0111$ 计算得出：$SI_{L}=\\neg Q_{3}$，所以 $SI_{L}=\\neg 0=1$。应用左移更新：\n$$\nQ_{3}\\leftarrow \\text{old }Q_{2}=1,\\quad Q_{2}\\leftarrow \\text{old }Q_{1}=1,\\quad Q_{1}\\leftarrow \\text{old }Q_{0}=1,\\quad Q_{0}\\leftarrow SI_{L}=1,\n$$\n给出最终状态 $Q_{3}Q_{2}Q_{1}Q_{0}=1111$，这对应于选项 E。", "answer": "$$\\boxed{E}$$", "id": "1958084"}, {"introduction": "移位寄存器是实现计算机算术运算的核心部件之一。本练习将带您深入一个经典的“加法-移位”乘法器设计，展示移位寄存器如何与累加器协同工作，以迭代方式完成二进制乘法。通过模拟这个过程，您将体会到如何将一个算法分解为一系列微操作，并理解移位寄存器在构建复杂计算电路中的关键作用 [@problem_id:1908895]。", "problem": "考虑一个用于将两个4位无符号二进制数相乘的数字电路。该乘法器使用加法和移位算法，由以下组件实现：\n- 寄存器 `M`：一个4位寄存器，用于保存固定的被乘数。\n- 寄存器 `A`：一个4位累加器，初始化为`0000`。\n- 寄存器 `Q`：一个4位移位寄存器，初始加载乘数。\n- 寄存器 `C`：一个1位进位寄存器，初始化为`0`。\n\n乘法过程是同步的，并由一个时钟控制。在每个时钟周期，会发生以下微操作序列：\n1.  检查寄存器 `Q` 的最低有效位，记为 `Q_0`。\n2.  如果 `Q_0` 为 `1`，则将被乘数 `M` 加到累加器 `A` 上。4位的结果被存回 `A`，加法的进位输出被存入进位寄存器 `C`。如果 `Q_0` 为 `0`，则 `A` 和 `C` 保持不变。\n3.  由 `C`、`A` 和 `Q` 组成的9位组合寄存器（按 `C:A:Q` 顺序）向右移一位。`C` 的位移入 `A` 的最高有效位（`A_3`），`A` 的最低有效位（`A_0`）移入 `Q` 的最高有效位（`Q_3`），而 `Q` 的最低有效位（`Q_0`）被丢弃。\n4.  移位后，进位寄存器 `C` 被重置为 `0`，为下一个周期可能发生的加法做准备。\n\n假设被乘数寄存器 `M` 加载了值 `1101`，乘数寄存器 `Q` 加载了 `1011`。在第一个时钟周期之前，系统初始化 `A = 0000` 和 `C = 0`。\n\n确定系统在完成整整三个时钟周期后寄存器 `A` 和 `Q` 的内容。将您的答案表示为一个8位二进制字符串，该字符串是寄存器 `A` 的内容后跟寄存器 `Q` 的内容的串联。例如，如果在某个时刻 `A = 0001` 且 `Q = 1010`，则对应的字符串将是 `00011010`。", "solution": "我们模拟指定的加法和移位乘法过程三个周期，其中 $M=1101$，初始 $A=0000$，$Q=1011$，$C=0$。在每个周期中：\n- 如果 $Q_{0}=1$，计算4位和 $A \\leftarrow A+M$ 并将进位输出到 $C$；如果 $Q_{0}=0$，则保持 $A$ 和 $C$ 不变。\n- 对9位的 $C:A:Q$ 执行右移操作：\n  $$A_{3} \\leftarrow C,\\quad A_{2} \\leftarrow A_{3},\\quad A_{1} \\leftarrow A_{2},\\quad A_{0} \\leftarrow A_{1},$$\n  $$Q_{3} \\leftarrow A_{0}\\ \\text{(old)},\\quad Q_{2} \\leftarrow Q_{3},\\quad Q_{1} \\leftarrow Q_{2},\\quad Q_{0} \\leftarrow Q_{1},$$\n  然后重置 $C \\leftarrow 0$。\n\n周期 1：\n- $Q_{0}=1$，所以将 $M$ 加到 $A$：\n  $$A \\leftarrow 0000+1101=1101,\\quad C \\leftarrow 0.$$\n- 右移 $C:A:Q = 0:1101:1011$：\n  $$A \\leftarrow 0110,\\quad Q \\leftarrow 1101,\\quad C \\leftarrow 0.$$\n\n周期 2：\n- $Q_{0}=1$，所以将 $M$ 加到 $A$：\n  $$A \\leftarrow 0110+1101=0011,\\quad C \\leftarrow 1.$$\n- 右移 $C:A:Q = 1:0011:1101$：\n  $$A \\leftarrow 1001,\\quad Q \\leftarrow 1110,\\quad C \\leftarrow 0.$$\n\n周期 3：\n- $Q_{0}=0$，所以不进行加法：\n  $$A \\leftarrow 1001,\\quad C \\leftarrow 0.$$\n- 右移 $C:A:Q = 0:1001:1110$：\n  $$A \\leftarrow 0100,\\quad Q \\leftarrow 1111,\\quad C \\leftarrow 0.$$\n\n在完成整整三个时钟周期后，内容为 $A=0100$ 和 $Q=1111$，所以要求的8位字符串（$A$ 后跟 $Q$ 的串联）是 $01001111$。", "answer": "$$\\boxed{01001111}$$", "id": "1908895"}, {"introduction": "从概念设计到硬件实现是数字逻辑设计中的关键一步，而硬件描述语言（HDL）的编码方式直接决定了电路的行为。这个练习模拟了一个常见的工程问题：由于在 Verilog 中错误地使用了阻塞赋值，导致移位寄存器功能异常。通过分析这段存在缺陷的代码，您将深刻理解阻塞赋值 (`=`) 与非阻塞赋值 (`<=`) 在时序逻辑中的根本区别，这是编写正确、可综合的 HDL 代码必须掌握的技能 [@problem_id:1915890]。", "problem": "一名初级工程师正在使用硬件描述语言（HDL），特别是Verilog，设计一个4位寄存器，作为更大型数字系统的一部分。该寄存器具有同步复位、并行加载能力和串行右移功能。该工程师编写了以下代码片段，其中包含一个细微但关键的缺陷。\n\n相关的信号和寄存器声明如下：\n- `clk`：主时钟信号。\n- `rst`：同步、高电平有效的复位信号。\n- `load`：一个控制信号，当其为高电平时，启用数据的并行加载。\n- `p_in`：一个4位输入`[3:0]`，用于并行加载。\n- `s_in`：一个1位串行输入，用于移位操作。\n- `q3`, `q2`, `q1`, `q0`：四个1位寄存器，构成系统的4位状态。\n\n时序逻辑由以下 `always` 块描述：\n```verilog\nalways @(posedge clk) begin\n    if (rst) begin\n        q3 = 1'b0;\n        q2 = 1'b0;\n        q1 = 1'b0;\n        q0 = 1'b0;\n    end else if (load) begin\n        q3 = p_in[3];\n        q2 = p_in[2];\n        q1 = p_in[1];\n        q0 = p_in[0];\n    end else begin\n        // Intended shift-right operation\n        q3 = s_in;\n        q2 = q3;\n        q1 = q2;\n        q0 = q1;\n    end\nend\n```\n寄存器的状态由拼接值 `{q3, q2, q1, q0}` 表示，其中 `q3` 是最高有效位（MSB）。最初，寄存器的状态是未知的。然后，系统按以下输入序列运行，该序列在 `clk` 的上升沿进行采样：\n\n- 在第1个时钟上升沿：`rst = 1'b1`。\n- 在第2个时钟上升沿：`rst = 1'b0`，`load = 1'b1`，`p_in = 4'b1011`。\n- 在第3个时钟上升沿：`rst = 1'b0`，`load = 1'b0`，`s_in = 1'b1`。\n\n在第3个时钟上升沿之后，寄存器的值（解释为 `{q3, q2, q1, q0}`）的十进制值是多少？\n\nA. 11\n\nB. 13\n\nC. 14\n\nD. 15\n\nE. 8", "solution": "该问题要求我们根据给定的Verilog代码片段，追踪四个1位寄存器（`q3`、`q2`、`q1`、`q0`）在连续三个时钟上升沿的状态。解决此问题的关键是正确理解顺序 `always` 块中由 `=` 运算符表示的阻塞赋值的行为。\n\n**初始状态：** 在第一个时钟沿之前，`q3、q2、q1、q0` 的值是未知的（`xxxx`）。\n\n**第1个时钟上升沿：**\n在第一个 `posedge clk`，输入被采样。`rst` 信号为高电平（`1'b1`）。\n`always` 块中的 `if (rst)` 条件为真。\n代码执行复位块：\n```verilog\nq3 = 1'b0;\nq2 = 1'b0;\nq1 = 1'b0;\nq0 = 1'b0;\n```\n所有四个寄存器都被赋值为 `0`。\n寄存器 `{q3, q2, q1, q0}` 的状态变为 `4'b0000`。\n\n**第2个时钟上升沿：**\n在第二个 `posedge clk`，输入 `rst = 1'b0`、`load = 1'b1` 和 `p_in = 4'b1011` 被采样。\n- `if (rst)` 条件为假。\n- `else if (load)` 条件为真。\n代码执行并行加载块：\n```verilog\nq3 = p_in[3]; // q3 = 1'b1\nq2 = p_in[2]; // q2 = 1'b0\nq1 = p_in[1]; // q1 = 1'b1\nq0 = p_in[0]; // q0 = 1'b1\n```\n寄存器被加载并行输入数据。尽管这些是阻塞赋值，但此块中的语句之间没有依赖关系（例如，`q3`的值不用于确定`q2`的值），因此其行为是直接的。\n寄存器 `{q3, q2, q1, q0}` 的状态变为 `4'b1011`。\n\n**第3个时钟上升沿：**\n这是分析的关键步骤。在第三个 `posedge clk`，输入 `rst = 1'b0`、`load = 1'b0` 和 `s_in = 1'b1` 被采样。在此之前，寄存器的状态是 `4'b1011`。\n- `if (rst)` 条件为假。\n- `else if (load)` 条件为假。\n代码执行最后的 `else` 块，其中包含了错误的移位实现：\n```verilog\nq3 = s_in;\nq2 = q3;\nq1 = q2;\nq0 = q1;\n```\n因为这些是阻塞赋值（`=`），每条语句都会按顺序执行，并且一次赋值的结果在同一仿真时间步内对下一条语句立即可见。让我们追踪执行过程：\n1.  `q3 = s_in;`\n    `s_in` 的值为 `1'b1`。寄存器 `q3` 被更新为 `1`。对于此块中的后续语句，`q3` 的值现在是 `1`。\n\n2.  `q2 = q3;`\n    此语句读取 `q3` 的*新*值，该值刚刚被设置为 `1`。因此，`q2` 被更新为 `1`。对于后续语句，`q2` 的值现在是 `1`。\n\n3.  `q1 = q2;`\n    此语句读取 `q2` 的*新*值，该值刚刚被设置为 `1`。因此，`q1` 被更新为 `1`。对于后续语句，`q1` 的值现在是 `1`。\n\n4.  `q0 = q1;`\n    此语句读取 `q1` 的*新*值，该值刚刚被设置为 `1`。因此，`q0` 被更新为 `1`。\n\n在该块中的所有语句执行完毕后，寄存器的最终状态被更新。结果是 `s_in` 的值（`1'b1`）在单个时钟周期内传播到了整个寄存器链。\n寄存器 `{q3, q2, q1, q0}` 的状态变为 `4'b1111`。\n\n对于移位寄存器而言，这种行为是不正确的，因为它应该在每个时钟周期将内容移动一个位置。正确的实现会使用非阻塞赋值（`<=`），它会安排所有更新在时间步结束时同时发生，使用的是变量在时间步开始时的值。\n\n最后，我们将二进制结果转换为十进制：\n二进制值 `1111_2` 计算为 $1 \\times 2^{3} + 1 \\times 2^{2} + 1 \\times 2^{1} + 1 \\times 2^{0} = 8 + 4 + 2 + 1 = 15$。\n\n因此，在第3个时钟沿之后，寄存器的十进制值是15。这对应于选项D。\n一个常见的错误答案是13，这是因为假设代码实现了正确的右移操作（得到 `{s_in, q3, q2, q1}` = `{1, 1, 0, 1}` = `4'b1101`），或者将阻塞赋值误解为非阻塞赋值所导致的结果。", "answer": "$$\\boxed{D}$$", "id": "1915890"}]}