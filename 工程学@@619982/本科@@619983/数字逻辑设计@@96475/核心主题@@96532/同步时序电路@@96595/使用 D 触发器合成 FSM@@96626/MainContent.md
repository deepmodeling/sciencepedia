## 引言
在数字世界中，纯粹的[逻辑门](@article_id:302575)只能对当前输入做出瞬时反应，缺乏“记忆”过去的能力。这种局限性使得它们无法执行需要按步骤进行或依赖历史信息的任务。那么，我们如何赋予电路记忆，使其能够理解序列、跟踪状态，并执行复杂的、有时间顺序的行为呢？

这个问题的答案在于一种强大的设计模型——[有限状态机 (FSM)](@article_id:355711)。FSM 是[数字逻辑设计](@article_id:301564)的核心，它为构建从简单的[序列检测器](@article_id:324798)到复杂的计算机处理器控制单元等一切[时序电路](@article_id:346313)提供了理论框架。通过将记忆元件与决策逻辑相结合，FSM 能够将抽象的行为规范转化为具体的硬件实现。

本文将带领您深入探索使用最基本的记忆单元——D [触发器](@article_id:353355)——来合成 FSM 的全过程。首先，我们将剖析 FSM 的核心概念，包括 D [触发器](@article_id:353355)作为记忆元件的原理、[组合逻辑](@article_id:328790)的角色，以及 Moore 和 Mealy 两种不同机型的区别和[状态分配](@article_id:351787)的艺术。随后，我们将展示 FSM 在现实世界中的广泛应用，从日常的自动售货机到[计算机体系结构](@article_id:353998)的核心控制器，揭示这些“小型大脑”如何驱动我们的现代科技。让我们首先深入其基本原理与机制。

## 原理与机制

想象一下，你正在教一个头脑很简单的朋友一个秘密的握手暗号：“推、拉、推、拧”。你的朋友如何知道下一步该做什么？他们必须记住上一个动作是什么。如果你刚做完“推”，下一个动作就是“拉”。如果你刚做完“拉”，下一个动作就是另一个“推”。这个挑战的核心不在于动作本身，而在于*记忆*。这个简单的想法正是我们所说的[有限状态机](@article_id:323352)（FSM）的核心。FSM 是一种带有记忆的电路。而在数字逻辑的世界里，我们最基本的记忆单元是一个非常简单的器件：D [触发器](@article_id:353355)。

### 记忆元件：D [触发器](@article_id:353355)

可以把 D [触发器](@article_id:353355)想象成一个尽职的笔记员。它有一个数据输入端 $D$ 和一个输出端 $Q$。它还侦听一个时钟信号，这个信号像节拍器一样以固定的节奏滴答作响。在时钟的每一次滴答时，[触发器](@article_id:353355)只做一件事：查看其 $D$ 输入端的值（可以是‘1’或‘0’），并将该值复制到其 $Q$ 输出端。然后，它会将这个值稳定地保持在 $Q$ 上，直到下一个时钟滴答到来。

这种行为可以用一个极其简单的方程来概括，这就是 D [触发器](@article_id:353355)的基本定律：

$$Q_{next} = D$$

在这里，$Q_{next}$ 是下一个时钟滴答后输出 $Q$ 将具有的值，而 $D$ 是此刻输入端的值。就是这样！这个小小的器件让我们的电路具备了保存一条信息——一个比特的记忆——的能力。我们称这个存储的信息为[触发器](@article_id:353355)的“状态”。

### 大脑与心脏：组合逻辑与记忆的结合

但仅有记忆是乏味的。一个只会复制你告诉他内容的笔记员并不聪明。当我们给笔记员一个“大脑”时，奇迹就发生了。在 FSM 中，这个“大脑”是一块组合逻辑电路。这个逻辑电路本身没有任何记忆；它是一个纯粹的反应机器。它接收当前的情况——包括电路当前的记忆（来自我们所有[触发器](@article_id:353355)的 $Q$ 值）和来自外部世界的任何新信息（输入）——然后决定笔记员*下一步*应该记下什么。

这个决定，也就是我们逻辑大脑的输出，被直接送入我们[触发器](@article_id:353355)的 $D$ 输入端。因此，在每个时钟滴答时，[触发器](@article_id:353355)都会根据逻辑电路做出的决定来更新其状态 $Q$，而这个决定又是基于*前一个*状态和当前输入做出的。这就形成了一个优美的[反馈回路](@article_id:337231)。这正是一台机器能够按顺序“思考”的方式。

让我们来看一个实际例子。假设我们想构建一个“采样并保持”电路 [@problem_id:1938263]。它有一个数据输入 `data` 和一个控制输入 `sample`。规则很简单：如果 `sample` 为‘1’，我们想“采样”`data` 并存储它。如果 `sample` 为‘0’，我们想“保持”已经存储的任何值。

让我们使用一个状态为 $Q$ 的 D [触发器](@article_id:353355)。那么为它的 $D$ 输入提供信号的“大脑”逻辑应该是什么样的呢？我们可以将规则直接转化为逻辑：

-   **规则1：** 如果 `sample` 是 1，*下一*状态应该是 `data`。所以，$Q_{next}$ 应该是 `data`。
-   **规则2：** 如果 `sample` 是 0，*下一*状态应该与*当前*状态相同。所以，$Q_{next}$ 应该是 $Q$。

由于 $Q_{next} = D$，我们实际上是在定义 $D$ 的逻辑。我们可以将这两个规则合并成一个[布尔表达式](@article_id:326513)：

$$D = (\text{sample} \cdot \text{data}) + (\overline{\text{sample}} \cdot Q)$$

看！这是一个多路选择器。`sample` 输入充当选择器，决定[触发器](@article_id:353355)的下一状态是新数据还是它自己的旧状态。我们刚刚合成了我们的第一个 FSM。我们通过将一个简单的记忆元件与一个同样简单的逻辑大脑相结合，创造了一个可以执行有用的、与时间相关的任务的电路。

同样“保持或更新”的原理也让我们能够创建计数器。计数器只需要知道是保持原位还是前进到序列中的下一个数字，这个决定通常由一个“使能”（Enable）输入控制 [@problem_id:1938272]。

### 抽象的力量：“状态”是什么？

到目前为止，我们的状态 $Q$ 只是存储了一个简单的值。但 FSM 的真正力量在于其状态可以代表抽象的概念，将复杂的历史总结为一种简单、可管理的形式。

考虑一个用于检查奇偶性的机器——判断它在一串输入比特流中看到的‘0’是偶数个还是奇数个 [@problem_id:1938301]。这台机器需要记住它见过的每一个比特吗？当然不需要！那将需要无限的记忆。它只需要知道一件事：“到目前为止，我看到的‘0’的个数是偶数还是奇数？”

这给了我们两个概念上的状态：
-   **状态A：** “0 的数量是偶数。”
-   **状态B：** “0 的数量是奇数。”

我们可以用一个[触发器](@article_id:353355)的状态 $Q$ 来表示这个概念：让 $Q=0$ 表示“偶校验”，$Q=1$ 表示“奇校验”。现在，逻辑是什么？如果我们处于“偶”状态（$Q=0$）且输入一个‘1’，0 的数量不变，所以我们应该停留在“偶”状态。如果输入一个‘0’，数量变为奇数，所以我们必须转换到“奇”状态（$Q=1$）。我们可以列出所有可能性，推导出 $D$ 的方程，并构建一个实际上已将整个历史压缩到单个比特中的机器。

这种将状态作为“进度标记”的思想是 FSM 最常见的应用之一——序列检测——的关键 [@problem_id:1928295]。要构建一个在看到模式‘1001’时喊出“啊哈！”的机器，我们可以定义代表我们成功匹配了多少模式的状态：

-   `S0`：“我还没看到任何有用的东西。”
-   `S1`：“我刚看到了一个‘1’。”
-   `S2`：“我最近的两个输入是‘10’。”
-   `S3`：“我最近的三个输入是‘100’。”

如果我们处于 `S3` 状态且下一个输入是‘1’，我们就找到了我们的序列！机器输出一个‘1’。接下来它会去哪里？它不必重置到 `S0`。完成序列的那个‘1’同时也是一个*新*潜在序列的开始，所以机器巧妙地转换到 `S1`，准备在不错过任何节拍的情况下继续寻找。状态不仅仅是记忆；它代表了进度和上下文。

### 两种类型：Moore 机和 Mealy 机

正如我们所见，FSM 有输入、状态和输出。但它们之间的关系可以有两种不同的风格。

**Mealy 机** 就像一只急切的海狸。它的输出同时取决于其当前状态*和*当前输入。它可以对变化做出即时反应。我们的‘1001’[序列检测器](@article_id:324798)是一个经典的 Mealy 机 [@problem_id:1928295]。它只在处于 `S3` 状态*且*输入为‘1’时才输出‘1’。在同一状态下，不同的输入会产生不同的输出。

而 **Moore 机** 则更为稳重。它的输出*只*取决于其当前状态。输入可以影响它*下一步*去往何处，但无法改变当前时刻的输出。输出是状态本身的特征。

一个完美的例子是设计用来生成周期性波形的机器，比如一个高电平持续一个[时钟周期](@article_id:345164)、低电平持续三个时钟周期的信号 [@problem_id:1938283]。这台机器甚至可能没有任何外部输入！它是一个自成一体的系统，一个数字发条装置。它只是循环通过一个预定义的状态序列。我们可以设计它，使得一个状态是“输出高电平”状态，另外三个是“输出低电平”状态。

-   状态 `00`：在此状态下，输出 `Z` 为 1。
-   状态 `01`：在此状态下，输出 `Z` 为 0。
-   状态 `11`：在此状态下，输出 `Z` 为 0。
-   状态 `10`：在此状态下，输出 `Z` 为 0。

对于这个 Moore 机，输出逻辑非常简单：当且仅当机器处于状态 `00` 时，$Z = 1$。其“大脑”逻辑完全专注于确保状态按正确的顺序转换：`00` → `01` → `11` → `10` → `00`。

### 命名的艺术：[状态分配](@article_id:351787)为何重要

我们已经看到，对于超过两个状态的机器，我们需要多个比特，也就是多个[触发器](@article_id:353355)。对于一个有 5 个状态的机器，我们至少需要 $\lceil \log_{2}(5) \rceil = 3$ 个[触发器](@article_id:353355)，这给了我们 $2^3 = 8$ 个可能的二进制编码。我们把其中五个编码分配给我们的状态。但是，是哪五个，以什么顺序分配？这个选择，被称为**[状态分配](@article_id:351787)**，远非任意。它是一门真正的设计艺术，可以极大地改变 FSM“大脑”的复杂性。

以我们有 5 个状态的机器为例。我们有 3 个未使用的二进制编码。如果由于毛刺或在上电时，机器发现自己处于这些无效状态之一，会发生什么？在设计阶段，这给了我们一个绝佳的礼物：自由。对于这些未使用的状态，我们不关心下一状态是什么。这些是“[无关项](@article_id:344644)”（don't-care conditions）[@problem_id:1961711]。当我们在简化逻辑方程时，这些[无关项](@article_id:344644)就像通配符，让我们能够更积极地组合项，从而产生更简单、更便宜、更快的逻辑。

分配策略本身可以带来惊人的简化。考虑一个有三个状态的机器。我们可以使用两个[触发器](@article_id:353355)，将[状态分配](@article_id:351787)为 `00`、`01`、`10`。或者，我们可以使用**[独热编码](@article_id:349211)**（one-hot encoding）策略，使用三个[触发器](@article_id:353355)，并将[状态分配](@article_id:351787)为 `001`、`010` 和 `100` [@problem_id:1938277]。使用三个[触发器](@article_id:353355)而不是两个似乎很浪费。但请看奇迹发生。如果机器按 `001` → `010` → `100` → `001` 的顺序循环，让我们来计算第三个[触发器](@article_id:353355)输入 $D_2$ 的逻辑。对应的状态位 $Q_2$ 的变化是 `0` → `0` → `1` → `0`。$D_2$ *唯一*需要为‘1’的时刻是当机器准备进入状态 `100` 时——也就是，当它当前处于状态 `010` 时。$D_2$ 的逻辑变得惊人地简单：$D_2 = Q_1$。在记忆元件上看似浪费的选择，却带来了一个极其简单的大脑。

即使是不那么直观的分配也可能隐藏着其自身的优雅。通过仔细选择状态的二进制编码，一个状态位的逻辑可能变成一个输入和另一个状态位的简单函数，完全独立于其自身的历史 [@problem_id:1938303]。这门艺术在于找到最能反映机器行为的自然对称性和流程的分配方式。

从本质上讲，合成一个[有限状态机](@article_id:323352)就是将一个故事——一系列[期望](@article_id:311378)的行为——翻译成逻辑和记忆的语言。这是一场在机器所*知*（其状态）和所*学*（其输入）之间的舞蹈，由我们设计的组合逻辑编排，并伴随着时钟的稳定节拍进行。这是我们为一堆简单的开关赋予智能和目的的根本方式。