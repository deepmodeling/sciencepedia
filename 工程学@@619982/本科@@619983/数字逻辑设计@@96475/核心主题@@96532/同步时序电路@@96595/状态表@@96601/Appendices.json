{"hands_on_practices": [{"introduction": "理解状态表最基本的能力是能够根据给定的输入序列，预测时序电路的行为。本练习将引导你手动模拟一个有限状态机的运行过程，通过追踪输入序列 $X = 1011$ 如何驱动电路从初始状态 $S_0$ 开始进行状态转换。这不仅是验证和调试数字系统设计的核心技能，也是将抽象的状态表与电路的实际动态行为联系起来的关键一步。[@problem_id:1962855]", "problem": "一个同步时序电路充当一个简单材料分拣系统的核心控制器。该控制器的行为由一个有限状态机描述。该状态机有四个不同的状态，表示为 `A`、`B`、`C` 和 `D`。这些状态之间的转换由一个单比特输入 `X` 控制，该输入来自一个区分两种类型材料的传感器。\n\n该状态机的状态转换表如下所示。该表显示了在每个当前状态 (PS) 以及对于输入 `X` 的每个可能值时的下一状态 (NS)。\n\n| 当前状态 (PS) | X=0 时的下一状态 (NS) | X=1 时的下一状态 (NS) |\n|:--------------:|:-------------------:|:-------------------:|\n|       A        |          B          |          C          |\n|       B        |          A          |          D          |\n|       C        |          D          |          B          |\n|       D        |          C          |          A          |\n\n在操作开始前，该状态机被初始化到状态 `A`。然后将一个输入序列 `X = 1011`馈入该状态机，每个时钟周期处理该序列的一个比特。序列的第一个比特 (`1`) 是第一个时钟周期的输入，第二个比特 (`0`) 是第二个时钟周期的输入，依此类推。\n\n请确定该状态机在第一个、第二个、第三个和第四个时钟周期结束时分别所处的状态序列。\n\n从以下选项中选择正确的序列。\n\nA. A, C, D, A\n\nB. B, D, A, B\n\nC. C, B, A, C\n\nD. C, D, A, B\n\nE. C, D, A, C", "solution": "同步有限状态机在每个时钟沿根据转换表定义的下一状态函数 $f(\\text{PS},X)$ 更新其状态。根据该表，下一状态函数为：\n$$\nf(\\text{A},0)=\\text{B},\\quad f(\\text{A},1)=\\text{C},\\quad\nf(\\text{B},0)=\\text{A},\\quad f(\\text{B},1)=\\text{D},\\quad\nf(\\text{C},0)=\\text{D},\\quad f(\\text{C},1)=\\text{B},\\quad\nf(\\text{D},0)=\\text{C},\\quad f(\\text{D},1)=\\text{A}.\n$$\n状态机在第一个时钟前始于状态 $\\text{A}$，因此设 $S_{0}=\\text{A}$。每个周期的输入序列为 $X_{1}=1$, $X_{2}=0$, $X_{3}=1$, $X_{4}=1$。在周期 $k$ 结束时的状态为 $S_{k}=f(S_{k-1},X_{k})$。\n\n逐步分析：\n- 第一个周期结束时：$S_{1}=f(\\text{A},1)=\\text{C}$。\n- 第二个周期结束时：$S_{2}=f(\\text{C},0)=\\text{D}$。\n- 第三个周期结束时：$S_{3}=f(\\text{D},1)=\\text{A}$。\n- 第四个周期结束时：$S_{4}=f(\\text{A},1)=\\text{C}$。\n\n因此，状态序列为 $\\text{C}, \\text{D}, \\text{A}, \\text{C}$，对应选项 E。", "answer": "$$\\boxed{E}$$", "id": "1962855"}, {"introduction": "在前一个练习中，我们假设状态表是完美无缺的，但在实际工程设计中，规格说明可能包含逻辑错误。本练习将让你扮演设计审查工程师的角色，在一份状态机规格说明中找出关键的设计缺陷。你将学习如何识别“非确定性”——即在相同的当前状态和输入下，出现了多个可能的下一状态，这对于标准的确定性有限状态机来说是无法实现的。[@problem_id:1962885]", "problem": "一位初级工程师的任务是设计一个同步时序电路。该电路有一个单个二进制输入 $x$，一个单个二进制输出 $z$，以及四个状态，分别标记为$S_0$、$S_1$、$S_2$和$S_3$。该工程师制定了一份状态转移和输出规范，以米利型状态机（Mealy machine）的规则列表形式呈现。然而，高级设计师怀疑该规范中存在一个关键的逻辑缺陷，导致它无法实现为一个标准的确定性电路。\n\n提出的规范如下：\n- 如果当前状态是 $S_0$ 且输入 $x=0$，那么下一状态是 $S_1$ 且输出 $z=0$。\n- 如果当前状态是 $S_0$ 且输入 $x=1$，那么下一状态是 $S_2$ 且输出 $z=0$。\n- 如果当前状态是 $S_1$ 且输入 $x=0$，那么下一状态是 $S_3$ 且输出 $z=0$。\n- 如果当前状态是 $S_1$ 且输入 $x=1$，那么下一状态是 $S_0$ 且输出 $z=1$。\n- 如果当前状态是 $S_2$ 且输入 $x=0$，那么下一状态是 $S_2$ 且输出 $z=1$。\n- 如果当前状态是 $S_2$ 且输入 $x=1$，那么下一状态是 $S_3$ 且输出 $z=0$。\n- 如果当前状态是 $S_3$ 且输入 $x=0$，那么下一状态是 $S_0$ 且输出 $z=1$。\n- 如果当前状态是 $S_3$ 且输入 $x=1$，那么下一状态是 $S_1$ 且输出 $z=0$。\n- 如果当前状态是 $S_2$ 且输入 $x=1$，那么下一状态是 $S_0$ 且输出 $z=1$。\n\n你的任务是审查该规范，并找出唯一一个其行为被模糊定义的“当前状态”和“输入”的组合。下列哪个选项代表了这个组合？\n\nA. 当前状态: $S_1$, 输入: $x=1$\n\nB. 当前状态: $S_2$, 输入: $x=0$\n\nC. 当前状态: $S_3$, 输入: $x=0$\n\nD. 当前状态: $S_2$, 输入: $x=1$\n\nE. 当前状态: $S_0$, 输入: $x=0$", "solution": "一个同步确定性米利型状态机（Mealy machine）定义了一个函数\n$$\nf:\\{\\text{状态}\\}\\times\\{0,1\\}\\to \\{\\text{状态}\\}\\times\\{0,1\\},\n$$\n使得对于每一对 $(S_{i},x)$，都存在唯一一个像 $(\\text{下一状态},z)$。对于四个状态和一个二进制输入，必须有恰好 $4\\times 2=8$ 条不同的规则。提供的列表有 9 条规则，因此至少有一对（当前状态, $x$）被重复定义，并且产生了相互冲突的结果。\n\n列出每个指定的映射：\n- $(S_{0},0)\\mapsto (S_{1},0)$\n- $(S_{0},1)\\mapsto (S_{2},0)$\n- $(S_{1},0)\\mapsto (S_{3},0)$\n- $(S_{1},1)\\mapsto (S_{0},1)$\n- $(S_{2},0)\\mapsto (S_{2},1)$\n- $(S_{2},1)\\mapsto (S_{3},0)$\n- $(S_{3},0)\\mapsto (S_{0},1)$\n- $(S_{3},1)\\mapsto (S_{1},0)$\n- $(S_{2},1)\\mapsto (S_{0},1)$\n\n对 $(S_{2},1)$ 出现了两次，且具有两个不同的像：\n$$\n(S_{2},1)\\mapsto (S_{3},0)\\quad\\text{和}\\quad (S_{2},1)\\mapsto (S_{0},1),\n$$\n这违反了单值要求并造成了模糊性。检查各个选项：\n- A: $(S_{1},1)$ 出现一次。\n- B: $(S_{2},0)$ 出现一次。\n- C: $(S_{3},0)$ 出现一次。\n- D: $(S_{2},1)$ 出现两次且行为冲突。\n- E: $(S_{0},0)$ 出现一次。\n\n因此，存在模糊性的组合是当前状态 $S_{2}$ 和输入 $x=1$。", "answer": "$$\\boxed{D}$$", "id": "1962885"}, {"introduction": "掌握了状态表的分析与纠错之后，我们进一步探索如何优化设计。本练习将带你进入一个更高级的主题：状态化简，这是减少电路复杂性和成本的关键技术。你将学习如何利用状态表中的“无关项”（don't care entries），用“-”表示，通过策略性地赋值，使得两个原本不完全相同的状态变得兼容并可以合并，从而实现一个更简洁、更高效的电路设计。[@problem_id:1962866]", "problem": "一个同步时序电路由下方的状态表部分描述。该电路有一个输入 `x` 和一个输出 `z`。“无关项”用 `-` 表示。\n\n| 现态 | 次态, x=0 | 次态, x=1 | 输出, z, x=0 | 输出, z, x=1 |\n| :---: | :---: | :---: | :---: | :---: |\n| A | B | C | 1 | 0 |\n| B | A | D | 0 | 1 |\n| C | E | - | - | 0 |\n| D | - | A | 1 | - |\n| E | - | B | 1 | 0 |\n\n在数字逻辑设计中，状态化简是一种关键的优化技术。如果两个状态的输出和次态规定对于任何输入都不冲突，那么它们被认为是相容的（或可合并的）。具体来说，对于任何输入 `x`，它们的输出必须相同，或者其中一个/两个是“无关项”。类似地，它们的次态必须相同，或者形成一对新的相容状态。\n\n你的任务是通过适当定义状态 `C` 和 `D` 各自行中的“无关项”，使它们能够合并。一旦完成这些赋值，状态 `C` 和 `D` 将被合并成一个单一的新状态，我们称之为 `(CD)`。请确定化简后的状态表中这个新状态 `(CD)` 的完整行。\n\n以下哪项以 `(x=0 时的次态, x=1 时的次态, x=0 时的输出, x=1 时的输出)` 的格式表示了合并状态 `(CD)` 的行？\n\nA. `(E, A, 1, 0)`\n\nB. `(E, A, 1, 1)`\n\nC. `(B, C, 0, 0)`\n\nD. `(E, D, 1, 0)`\n\nE. 状态 C 和 D 无法变得相容。", "solution": "为了解决这个问题，我们需要确定对“无关项” (`-`) 的赋值，以使状态 `C` 和 `D` 相容。如果对于每一个输入值，两个状态 `S_i` 和 `S_j` 的输出不矛盾，且它们的次态是一个相容对，那么这两个状态是相容的。\n\n让我们对每个输入 `x` 分析状态对 `(C, D)` 的相容性要求。\n\n**情况1：输入 `x = 0`**\n\n1.  **输出**：我们比较输出 `z(C, 0)` 和 `z(D, 0)`。\n    - 从表中可知，`z(C, 0) = -` 且 `z(D, 0) = 1`。\n    - 为了使它们相容，它们必须不冲突。由于 `z(C, 0)` 是一个“无关项”，我们可以将其赋值为 `z(D, 0)` 的值。\n    - **赋值1**：我们必须设置 `z(C, 0) = 1`。\n\n2.  **次态**：我们比较次态 `NS(C, 0)` 和 `NS(D, 0)`。\n    - 从表中可知，`NS(C, 0) = E` 且 `NS(D, 0) = -`。\n    - 为了相容，我们可以将“无关”次态赋值为已指定的那个次态。\n    - **赋值2**：我们必须设置 `NS(D, 0) = E`。\n    - 这产生了一个隐含的配对要求，即次态对 `(E, E)` 必须是相容的。一对相同的状态总是相容的。\n\n**情况2：输入 `x = 1`**\n\n1.  **输出**：我们比较输出 `z(C, 1)` 和 `z(D, 1)`。\n    - 从表中可知，`z(C, 1) = 0` 且 `z(D, 1) = -`。\n    - 为了相容，我们必须将 `z(D, 1)` 赋值为与 `z(C, 1)` 相同的值。\n    - **赋值3**：我们必须设置 `z(D, 1) = 0`。\n\n2.  **次态**：我们比较次态 `NS(C, 1)` 和 `NS(D, 1)`。\n    - 从表中可知，`NS(C, 1) = -` 且 `NS(D, 1) = A`。\n    - 为了相容，我们必须给 `NS(C, 1)` 赋一个值，使得产生的次态对是相容的。实现这一目标的最简单方法是，将 `NS(C, 1)` 赋值为与 `NS(D, 1)` 相同的值。\n    - **赋值4**：我们设置 `NS(C, 1) = A`。\n    - 这意味着状态对 `(A, A)` 必须是相容的，而这总是成立的。对 `NS(C, 1)` 的任何其他选择都将对另一个状态对引入新的相容性要求，而这需要检查是否存在冲突。例如，设置 `NS(C, 1) = B` 将需要检查状态对 `(B, A)`，它们在 `x=0` 时有冲突的输出 (`z(B,0)=0`, `z(A,0)=1`)，因此它们是不相容的。因此，设置 `NS(C, 1) = A` 是正确且最直接的方法。\n\n**赋值摘要：**\n- `z(C, 0)` 被设置为 `1`。\n- `NS(D, 0)` 被设置为 `E`。\n- `z(D, 1)` 被设置为 `0`。\n- `NS(C, 1)` 被设置为 `A`。\n\n现在我们可以在这些赋值之后写出状态 `C` 和 `D` 的完全指定的行：\n- **状态 C 的行**：\n  - `NS(C, 0) = E` (给定)\n  - `NS(C, 1) = A` (赋值)\n  - `z(C, 0) = 1` (赋值)\n  - `z(C, 1) = 0` (给定)\n  - C 的结果行：`(E, A, 1, 0)`\n\n- **状态 D 的行**：\n  - `NS(D, 0) = E` (赋值)\n  - `NS(D, 1) = A` (给定)\n  - `z(D, 0) = 1` (给定)\n  - `z(D, 1) = 0` (赋值)\n  - D 的结果行：`(E, A, 1, 0)`\n\n由于现在两行完全相同，状态 `C` 和 `D` 可以合并成一个单一的新状态 `(CD)`。这个合并状态的行就是它们现在共同拥有的那一行。\n\n合并状态 `(CD)` 的行，其格式为 `(x=0 时的次态, x=1 时的次态, x=0 时的输出, x=1 时的输出)`，是 `(E, A, 1, 0)`。\n\n将此结果与给出的选项进行比较：\nA. `(E, A, 1, 0)` - 与我们的结果相符。\nB. `(E, A, 1, 1)` - `x=1` 时的输出不正确。\nC. `(B, C, 0, 0)` - 次态和输出均不正确。\nD. `(E, D, 1, 0)` - `x=1` 时的次态不正确。\nE. 状态 C 和 D 无法变得相容。 - 不正确，我们已经证明它们可以相容。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1962866"}]}