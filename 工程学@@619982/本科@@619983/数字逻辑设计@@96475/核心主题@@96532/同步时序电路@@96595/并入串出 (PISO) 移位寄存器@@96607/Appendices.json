{"hands_on_practices": [{"introduction": "在深入了解整个移位寄存器之前，让我们先从其最基本的构建单元——单个“位片”(bit-slice)——开始。这个练习将挑战你使用基本的与门、或门和非门来设计控制逻辑，正是这段逻辑决定了每个触发器是加载新的并行数据 $P_i$ 还是移入来自相邻位的数据 $S_i$。通过从根本上构建这个由控制信号 $M$ 驱动的选择机制 [@problem_id:1950675]，你将揭开 PISO 寄存器核心功能背后的神秘面纱，并理解其输入 $D_i$ 是如何通过布尔表达式 $(M\\cdot P_{i})+(\\overline{M}\\cdot S_{i})$ 实现的。", "problem": "考虑一个通用并行输入、串行输出（PISO）移位寄存器的单个位片，即第 $i$ 级。该级围绕一个 D 型触发器及其相关的输入逻辑构建。该级的行为由单个模式控制信号 $M$ 控制。\n\n其功能定义如下：\n- 当 $M=1$ 时，寄存器处于“加载”模式。在下一个有效时钟沿，触发器应锁存来自并行数据输入线 $P_i$ 的值。\n- 当 $M=0$ 时，寄存器处于“移位”模式。在下一个有效时钟沿，触发器应锁存来自串行数据输入线 $S_i$ 的值。串行输入 $S_i$ 连接到前一级触发器的输出。\n\n你的任务是设计组合逻辑电路，为第 $i$ 级的 D 型触发器提供正确的输入信号 $D_i$。该逻辑必须从基本原理出发进行设计，仅使用基本的与门、或门和非门。明确禁止使用任何如多路复用器（MUX）或译码器之类的预封装逻辑元件。\n\n确定触发器输入 $D_i$ 的布尔表达式，用输入 $P_i$、$S_i$ 和 $M$ 表示。在你的最终表达式中，你可以使用标准的布尔代数表示法，其中乘法（例如 $A \\cdot B$）代表“与”，加法（例如 $A+B$）代表“或”，上划线（例如 $\\overline{A}$）代表“非”。", "solution": "我们需要一个布尔函数 $D_{i}(M,P_{i},S_{i})$，使得：\n- 如果 $M=1$（加载模式），则 $D_{i}=P_{i}$。\n- 如果 $M=0$（移位模式），则 $D_{i}=S_{i}$。\n\n对 $M$ 使用布尔条件（香农展开），任何函数 $F(M,\\dots)$ 都可以写成 $F=\\overline{M}\\cdot F|_{M=0}+M\\cdot F|_{M=1}$。将此应用于 $D_{i}$，其中 $D_{i}|_{M=0}=S_{i}$ 且 $D_{i}|_{M=1}=P_{i}$，得到\n$$\nD_{i}=\\overline{M}\\cdot S_{i}+M\\cdot P_{i}。\n$$\n该表达式仅使用基本门：一个非门生成 $\\overline{M}$，两个与门构成 $M\\cdot P_{i}$ 和 $\\overline{M}\\cdot S_{i}$，以及一个或门将它们相加求和。\n\n验证：\n- 对于 $M=1$：$D_{i}=1\\cdot P_{i}+0\\cdot S_{i}=P_{i}$。\n- 对于 $M=0$：$D_{i}=0\\cdot P_{i}+1\\cdot S_{i}=S_{i}$。\n\n因此，所需的组合逻辑是\n$$\nD_{i}=(M\\cdot P_{i})+(\\overline{M}\\cdot S_{i})。\n$$", "answer": "$$\\boxed{(M\\cdot P_{i})+(\\overline{M}\\cdot S_{i})}$$", "id": "1950675"}, {"introduction": "理解了单个位片的工作原理后，我们现在将视野扩展到一个完整的 8 位寄存器。这个练习模拟了 PISO 寄存器的主要功能：数据串行化。通过手动追踪寄存器在每个时钟周期下的状态 [@problem_id:1950743]，你将直观地感受到并行数据是如何一步步转换为时序串行比特流的，这对于理解数据在计算机系统中的传输方式至关重要。", "problem": "一个简单的数据串行化电路使用了一个 8 位并行输入、串行输出（PISO）移位寄存器。该寄存器由 8 个 D 型触发器组成，从最高有效位（MSB）的 Q7 到最低有效位（LSB）的 Q0 进行标记。\n\n操作分两个阶段进行。首先，在“加载”阶段，8 位的十六进制数据字 `$B4` 被并行加载到寄存器中。这意味着数据字的 MSB 存储在 Q7 中，下一位存储在 Q6 中，以此类推，直到 LSB 存储在 Q0 中。\n\n其次，寄存器的模式被切换到“移位”。在每个后续时钟脉冲的上升沿，寄存器中的所有位都向右移动一个位置（即，$Q_n$ 的值移动到 $Q_{n-1}$）。在整个移位阶段，输入到 Q7 的串行数据输入保持为逻辑 0。电路的串行输出取自 Q0 引脚。\n\n确定在移位阶段出现在串行输出的前 8 位序列，从第一个时钟脉冲产生的输出开始。\n\n下列哪项代表了正确的 8 位串行输出序列？\n\nA. `00101101`\n\nB. `10110100`\n\nC. `01001011`\n\nD. `11010010`\n\nE. `01000011`", "solution": "将十六进制字 `$B4` 解释为一个 8 位二进制字，其中最高有效位（MSB）在 $Q_7$，最低有效位（LSB）在 $Q_0$。因为 $B_{16}=1011_2$ 且 $4_{16}=0100_2$，所以在加载阶段后的初始内容是：\n$$\n[Q_{7},Q_{6},Q_{5},Q_{4},Q_{3},Q_{2},Q_{1},Q_{0}] = [1,0,1,1,0,1,0,0].\n$$\n在移位阶段，在每个时钟上升沿，寄存器向右移位，串行输入为零：\n$$\nQ_{n-1}^{+} = Q_{n}, \\quad Q_{7}^{+} = 0,\n$$\n其中上标 $+$ 表示时钟沿之后的值。\n\n串行输出取自 $Q_0$。由给定脉冲“产生”的位是在该脉冲边沿移出的位，即移位前 $Q_0$ 的内容。因此，前 8 个输出位恰好是最初加载的位，从 LSB 到 MSB 依次移出：\n$$\nb_{k} = Q_{k-1}^{(0)} \\quad \\text{for } k=1,2,\\dots,8,\n$$\n其中 $Q^{(0)}$ 表示加载阶段刚结束时的值。\n\n使用初始状态 $[1,0,1,1,0,1,0,0]$，我们得到输出序列（$b_1$ 到 $b_8$）为：\n$$\n[b_{1},b_{2},b_{3},b_{4},b_{5},b_{6},b_{7},b_{8}] = [Q_{0},Q_{1},Q_{2},Q_{3},Q_{4},Q_{5},Q_{6},Q_{7}] = [0,0,1,0,1,1,0,1].\n$$\n因此，8 位串行输出序列是 `00101101`，对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1950743"}, {"introduction": "在现实世界中，电路并非总能按预期工作。最后的这个练习将让你扮演一位数字工程师，诊断一个有故障的 PISO 寄存器。通过对比观测到的错误输出和预期输出 [@problem_id:1950684]，你将学会如何逆向推理，从而定位数字电路中一种常见的失效模式——“固定型故障”（stuck-at fault），这是一项宝贵的调试技能。", "problem": "一个 8 位并行输入、串行输出（PISO）移位寄存器由 8 个 D 型触发器构成，从左到右依次标记为 $DFF_7$ 到 $DFF_0$。串行输出 $S_{out}$ 取自最右侧触发器 $Q_0$ 的输出。\n\n对于每个触发器 $DFF_i$（其中 $i$ 的范围是从 0 到 7），其 D 输入 $D_i$ 连接到一个 2 选 1 多路选择器的输出。该多路选择器根据单根控制线 `SHIFT/LOAD'` 在两个输入源之间进行选择：\n- 当 `SHIFT/LOAD'` = 0（并行加载模式）时，多路选择器选择并行数据输入位 $P_i$。\n- 当 `SHIFT/LOAD'` = 1（移位模式）时，多路选择器选择其左侧相邻触发器的输出 $Q_{i+1}$。对于最左侧的触发器 $DFF_7$，此移入输入永久接地（逻辑 0）。\n\n该寄存器设计用于执行以下操作：\n1. 将 `SHIFT/LOAD'` 信号设置为 0。将并行数据字 $P = (P_7, P_6, P_5, P_4, P_3, P_2, P_1, P_0) = (1, 1, 1, 1, 1, 1, 1, 1)$ 应用于输入端。施加一个时钟脉冲以加载此数据。\n2. 将 `SHIFT/LOAD'` 信号设置为 1。然后施加 8 个时钟脉冲序列，以串行方式将数据移出。在每个时钟脉冲后，从 $S_{out}$ 读取串行输出流。\n\n执行此操作后，观察到的 8 位串行输出流（从第一个输出位到最后一个）为 `11110111`。已知电路中某处存在一个单一的固定为 0 故障。根据这一观察结果，以下哪个是最可能的故障？\n\nA. 触发器 $DFF_3$ 的 D 输入（$D_3$）固定为 0。\n\nB. 触发器 $DFF_4$ 的输出（$Q_4$）固定为 0。\n\nC. 触发器 $DFF_4$ 的并行数据输入引脚（$P_4$）固定为 0。\n\nD. 主 `SHIFT/LOAD'` 控制线固定为 0。\n\nE. 触发器 $DFF_3$ 的输出（$Q_3$）固定为 0。", "solution": "设寄存器为右移寄存器，在移位模式下 $Q_{i+1}$ 的输出馈入 $D_{i}$，串行输出取自 $S_{out}=Q_{0}$。在使用 $P=(P_{7},\\dots,P_{0})$ 进行并行加载后，寄存器内容为 $Q_{i}(0)=P_{i}$。\n\n当在移位模式下进行时钟操作并观察每个时钟周期移出的位时（标准的PISO时序），观察到的第 $k$ 个串行位 $b_k$ 等于并行加载后立即存在于 $Q_{k-1}$ 中的内容。因此，对于一个理想的、无故障的寄存器，\n$$\nb_{k}=P_{k-1}\\quad\\text{for }k=1,2,\\dots,8.\n$$\n当所有 $i$ 的 $P_{i}=1$ 时，一个完好的寄存器将产生 $b_{1}\\dots b_{8}=11111111$。\n\n观察到的流是 `11110111`。将预期输出与观察输出对比，发现第 5 位不匹配：$b_5=0$ 而不是 1。由于 $b_5$ 对应于加载到 $Q_4$ 的初始值，这意味着加载操作导致 $Q_4(0)=0$，而所有其他加载的位都是 1。\n\n现在根据这个观察结果，逐一测试每个单一的固定为 0 故障：\n\n1.  **D) 主 `SHIFT/LOAD'` 控制线固定为 0**：设备将保持在加载模式；每个时钟脉冲都会重新加载 $P$。由于 $P_0=1$，每次读取时 $Q_{0}$ 都会是 1，从而产生 `11111111`，与观察结果相矛盾。\n\n2.  **A) $D_{3}$ 固定为 0**：在加载期间，$Q_3$ 将加载 0，即 $Q_{3}(0)=0$。这将导致输出流中的第 4 位为 0（即 `11101111`），而不是第 5 位。与观察结果不符。\n\n3.  **E) $Q_{3}$ 固定为 0**：这会强制 $Q_{3}(0)=0$，导致第 4 个输出位为 0。与观察结果不符。\n\n4.  **B) $Q_{4}$ 固定为 0**：此故障会使 $Q_4$ 的输出始终为 0。在加载阶段，这意味着 $Q_4$ 会被强制为 0，这与第 5 个输出位为 0 的观察结果（$b_5=Q_4(0)=0$）部分相符。然而，这个故障也会破坏移位操作。在移位模式下，传给 $D_3$ 的输入值将恒为 0（来自 $Q_4$）。因此，在第 5 个时钟周期后，一个 0 将被移入 $Q_3$，然后在接下来的周期中继续向右传递到 $Q_2, Q_1, Q_0$。这意味着在输出 $b_5=0$ 之后，后续的输出位 $b_6, b_7, b_8$ 也将变为 0，因为来自 $Q_5, Q_6, Q_7$ 的原始值 '1' 无法通过被破坏的 $Q_4$ 节点。最终的输出流应为 `11110000`。这与观察到的 `11110111` 不符。\n\n5.  **C) $P_{4}$ 固定为 0**：在并行加载期间，这个故障将导致加载到 $Q_4$ 的值为 0，即 $Q_4(0)=0$，而所有其他的 $Q_i(0)=1$。这个故障不影响移位路径。因此，在移位操作期间，加载到寄存器中的值将完好无损地串行移出。输出的串行流将等于从 $Q_0$ 到 $Q_7$ 的已加载字：\n    $$\n    b_{1}\\dots b_{8}=(Q_{0}(0),Q_{1}(0),Q_{2}(0),Q_{3}(0),Q_{4}(0),Q_{5}(0),Q_{6}(0),Q_{7}(0))=(1,1,1,1,0,1,1,1),\n    $$\n    这与观察结果 `11110111` 完全匹配。\n\n因此，唯一与观察结果一致的单一固定为 0 故障是并行输入 $P_{4}$ 固定为 0。", "answer": "$$\\boxed{C}$$", "id": "1950684"}]}