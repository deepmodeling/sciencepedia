{"hands_on_practices": [{"introduction": "本练习将带你入门摩尔机最常见的应用之一：序列检测。你将学习如何将一个抽象的序列检测需求（例如，在输入数据流 $x$ 中找到序列 ‘101’）转化为一个精确的状态转换表，并确定与每个状态相关联的输出 $z$。这个过程是设计任何处理时序数据电路的基础，也是理解状态机如何“记忆”历史信息的关键。[@problem_id:1969113]", "problem": "您的任务是设计一个数字电路，该电路监测一个串行输入比特流 `x`。该电路必须产生一个输出 `z`，在检测到特定的三比特序列'101'后，该输出 `z` 会立即变为'1'，并仅持续一个时钟周期。一个关键约束是，检测到的序列必须是不可重叠的。这意味着，一旦一个完整的'101'序列被识别，构成此序列的比特就不能被重用为另一个潜在序列的一部分。检测过程必须重置并重新开始。\n\n您需要使用摩尔有限状态机 (Moore FSM) 来对这种行为进行建模。该状态机使用四个状态来跟踪序列检测的进度：\n- `S0`：初始或重置状态，此时未检测到目标序列的任何前缀。\n- `S1`：表示最近接收到的比特是'1'的状态，该比特可能是序列的开始。\n- `S2`：表示最后接收到的两个比特是'10'的状态。\n- `S3`：表示最后接收到的三个比特是'101'的状态，即检测状态。\n\n根据这些状态定义，从以下选项中选择能正确实现指定摩尔机的状态表。“当前状态”列表示下一个输入比特到达之前的状态，“下一状态”列表示处理输入比特之后的状态，“输出 (z)”是与当前状态相关联的输出。\n\nA.\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| S0    | S0    | S1    | 0     |\n| S1    | S2    | S1    | 0     |\n| S2    | S0    | S3    | 0     |\n| S3    | S0    | S1    | 1     |\n\nB.\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| S0    | S0    | S1    | 0     |\n| S1    | S2    | S1    | 0     |\n| S2    | S0    | S3    | 0     |\n| S3    | S2    | S1    | 1     |\n\nC.\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| S0    | S0    | S1    | 0     |\n| S1    | S2    | S1    | 0     |\n| S2    | S0    | S3    | 1     |\n| S3    | S0    | S1    | 0     |\n\nD.\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| S0    | S1    | S0    | 0     |\n| S1    | S2    | S1    | 0     |\n| S2    | S0    | S3    | 0     |\n| S3    | S0    | S1    | 1     |", "solution": "我们设计一个摩尔FSM，用于检测不可重叠序列'101'，在检测后立即输出$z=1$且仅持续一个时钟周期。在摩尔机中，$z$ 仅取决于当前状态，因此检测状态必须是唯一一个使$z=1$的状态。\n\n根据给定的状态含义：\n- $S0$：没有有用的前缀；下一个状态必须仅取决于当前输入比特。\n- $S1$：最后一个比特是 $1$；输入为 $0$ 时，我们前进到前缀 $10$；输入为 $1$ 时，我们保持与模式前缀匹配的最长真后缀，该后缀仍然是 $1$。\n- $S2$：最后两个比特是 $10$；输入为 $1$ 时，我们完成了 $101$ 并进入检测状态；输入为 $0$ 时，没有匹配的后缀，所以我们重置到 $S0$。\n- $S3$：最后三个比特是 $101$；因为检测必须是不可重叠的，在将 $z=1$ 置位一个周期后，我们必须重新开始搜索，而不重用任何已检测序列中的比特。因此，从 $S3$ 开始的转移逻辑必须与从 $S0$ 重新开始完全相同：输入为 $0$ 时转到 $S0$，输入为 $1$ 时转到 $S1$。\n\n现在确定正确的状态转移和输出：\n\n1) 从 $S0$：\n- 输入 $0$：仍然没有前缀，因此 $S0 \\to S0$。\n- 输入 $1$：一个潜在匹配的开始，因此 $S0 \\to S1$。\n\n2) 从 $S1$：\n- 输入 $0$：我们得到 $10$，因此 $S1 \\to S2$。\n- 输入 $1$：我们仍然有一个结尾的 $1$ 作为最长的前缀，因此 $S1 \\to S1$。\n\n3) 从 $S2$：\n- 输入 $0$：序列变为 $100$，其与 $101$ 的前缀匹配的最长后缀为空，因此 $S2 \\to S0$。\n- 输入 $1$：我们完成了 $101$，因此 $S2 \\to S3$。\n\n4) 从 $S3$（不可重叠的重启）：\n- 输入 $0$：以 $0$ 重启，因此 $S3 \\to S0$。\n- 输入 $1$：以 $1$ 重启，因此 $S3 \\to S1$。\n\n摩尔机的输出分配：\n- $z=1$ 仅在 $S3$（检测状态）中，而在 $S0$、$S1$ 和 $S2$ 中 $z=0$。\n\n与选项进行比较：\n- 选项 A 匹配上述所有转移，并且仅在 $S3$ 中有 $z=1$。\n- 选项 B 在输入为 $0$ 时使用 $S3 \\to S2$，这重用了已检测序列的后缀信息（重叠），违反了不可重叠的要求。\n- 选项 C 在 $S2$ 中分配 $z=1$ 并在 $S3$ 中分配 $z=0$，这与摩尔机的检测定义相矛盾。\n- 选项 D 从 $S0$ 开始的转移是错误的（它交换了对输入 $0$ 和 $1$ 的响应），这是无效的。\n\n因此，正确的状态表是选项 A。", "answer": "$$\\boxed{A}$$", "id": "1969113"}, {"introduction": "从抽象的状态图转向具体的电路实现后，我们需要分析其在所有可能情况下的行为，包括意外进入的“未使用”状态。本练习通过给定的逻辑方程（例如 $D_2 = \\overline{Q_2} Q_1 + Q_1 \\overline{Q_0}$），让你追踪一个摩尔机从一个异常状态 $(Q_2, Q_1, Q_0) = (1, 1, 1)$ 开始的状态序列。这对于确保数字系统的稳健性和可靠性至关重要，是验证和调试硬件设计的核心实践。[@problem_id:1969124]", "problem": "一个摩尔 (Moore) 型时序电路由三个 D 型触发器设计而成。该电路的状态由二进制元组 $(Q_2, Q_1, Q_0)$ 表示，其中 $Q_2$ 是最高有效位。该电路有一个二进制输入 $x$。触发器输入 $(D_2, D_1, D_0)$ 和电路输出 $Z$ 的逻辑由以下布尔方程定义。请注意，并置表示逻辑与 (AND) 运算，`+` 符号表示逻辑或 (OR) 运算，上划线（例如 $\\overline{Q}$）表示逻辑非 (NOT) 运算。\n\n$D_2 = \\overline{Q_2} Q_1 + Q_1 \\overline{Q_0}$\n$D_1 = \\overline{Q_1} Q_0 + x \\overline{Q_2}$\n$D_0 = Q_2 \\overline{Q_0} + \\overline{x} Q_1$\n$Z = Q_2 Q_0$\n\n由于启动异常，电路进入状态 $(Q_2, Q_1, Q_0) = (1, 1, 1)$。从此时起，输入 $x$ 恒定保持为值 $0$。\n\n确定该电路将经历的状态序列。该序列应从初始异常状态开始，并列出接下来三个时钟脉冲之后的后续状态。\n\n以下哪项表示此状态序列？\n\nA. $(1,1,1) \\rightarrow (0,0,1) \\rightarrow (0,1,0) \\rightarrow (1,0,1)$\nB. $(1,1,1) \\rightarrow (0,0,1) \\rightarrow (1,1,0) \\rightarrow (0,0,0)$\nC. $(1,1,1) \\rightarrow (1,0,1) \\rightarrow (0,1,1) \\rightarrow (1,0,0)$\nD. $(1,1,1) \\rightarrow (0,0,0) \\rightarrow (0,0,0) \\rightarrow (0,0,0)$\nE. $(1,1,1) \\rightarrow (0,1,0) \\rightarrow (1,1,1) \\rightarrow (0,0,1)$", "solution": "对于 D 型触发器，下一个状态等于在有效时钟沿施加的 $D$ 输入，因此 $Q_{i}^{+}=D_{i}$。这里，从异常初始状态开始，$x$ 保持为 $0$。\n\n给定\n$$D_{2}=\\overline{Q_{2}}Q_{1}+Q_{1}\\overline{Q_{0}},\\quad D_{1}=\\overline{Q_{1}}Q_{0}+x\\,\\overline{Q_{2}},\\quad D_{0}=Q_{2}\\,\\overline{Q_{0}}+\\overline{x}\\,Q_{1},$$\n当 $x=0$ 时，这些方程简化为\n$$D_{1}=\\overline{Q_{1}}Q_{0},\\qquad D_{0}=Q_{2}\\,\\overline{Q_{0}}+Q_{1}.$$\n\n从 $(Q_{2},Q_{1},Q_{0})=(1,1,1)$ 开始。\n计算下一个状态 $(Q_{2}^{+},Q_{1}^{+},Q_{0}^{+})=(D_{2},D_{1},D_{0})$：\n\n1) 从 $(1,1,1)$ 开始，使用 $\\overline{Q_{2}}=0$，$\\overline{Q_{1}}=0$，$\\overline{Q_{0}}=0$ 和 $\\overline{x}=1$：\n$$D_{2}=0\\cdot 1+1\\cdot 0=0,\\quad D_{1}=0\\cdot 1=0,\\quad D_{0}=1\\cdot 0+1=1$$\n因此下一个状态是 $(0,0,1)$。\n\n2) 从 $(0,0,1)$ 开始，使用 $\\overline{Q_{2}}=1$，$\\overline{Q_{1}}=1$，$\\overline{Q_{0}}=0$ 和 $\\overline{x}=1$：\n$$D_{2}=1\\cdot 0+0\\cdot 0=0,\\quad D_{1}=1\\cdot 1=1,\\quad D_{0}=0\\cdot 0+0=0$$\n因此下一个状态是 $(0,1,0)$。\n\n3) 从 $(0,1,0)$ 开始，使用 $\\overline{Q_{2}}=1$，$\\overline{Q_{1}}=0$，$\\overline{Q_{0}}=1$ 和 $\\overline{x}=1$：\n$$D_{2}=1\\cdot 1+1\\cdot 1=1,\\quad D_{1}=0\\cdot 0=0,\\quad D_{0}=0\\cdot 1+1=1$$\n因此下一个状态是 $(1,0,1)$。\n\n因此，从 $(1,1,1)$ 开始并列出接下来三个时钟脉冲后的状态，序列为\n$$(1,1,1)\\rightarrow(0,0,1)\\rightarrow(0,1,0)\\rightarrow(1,0,1),$$\n这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1969124"}, {"introduction": "在设计更复杂的系统时，我们最初为满足功能需求而构建的状态机可能不是最高效的。本练习挑战你先设计一个能检测多个重叠序列（‘1010’ 或 ‘0101’）的摩尔机，然后应用形式化的状态最小化方法来优化它。掌握状态最小化是减少电路成本和复杂性的关键高级技能，能让你设计出更小、更快、更经济的数字系统。[@problem_id:1969119]", "problem": "在设计一个自定义高速串行通信协议时，一个核心组件是实时数据完整性校验器。该校验器必须持续监控一个输入的二进制数据流，并识别特定的4位同步标记。您的任务是使用一个有限状态机为该校验器设计逻辑。\n\n该校验器将被实现为一个 Moore 机。它有一个单一的二进制输入 $x$，每个时钟周期从数据流中接收一个比特，以及一个单一的二进制输出 $z$。当且仅当输入 $x$ 上最近收到的四位比特序列为 `1010` 或 `0101` 时，输出 $z$ 必须为 1。该状态机必须能够检测这些序列的重叠实例。例如，如果输入流是 `...01010...`，则在最后的 '1' (`0101`) 到达时输出应为 '1'，然后在最后的 '0' (`1010`) 到达时再次输出 '1'。\n\n假设在接收任何比特之前，状态机处于一个复位状态。首先，为正确实现此行为的 Moore 机构建一个状态表。然后，应用一个形式化的状态最小化算法（例如划分法）来找到等价的最小化状态机。这个最小化 Moore 机中的状态总数是多少？", "solution": "为了解决这个问题，我们将首先构建一个能够正确识别目标序列的状态机，然后应用一个形式化的最小化过程来找到等价最小化状态机中的状态数量。\n\n**步骤1：构建非最小化状态机**\n\n构建用于序列检测的 Moore 机的一种系统方法是，定义状态来表示输入流的最长后缀，该后缀同时也是目标序列（`1010` 或 `0101`）之一的前缀。如果一个状态代表一个完整的目标序列，其输出为1，否则为0。\n\n让我们识别所有这些必要的前缀：\n1.  `\"\"` (空字符串，我们的复位状态)\n2.  `1` (`1010` 的前缀)\n3.  `0` (`0101` 的前缀)\n4.  `10` (`1010` 的前缀)\n5.  `01` (`0101` 的前缀)\n6.  `101` (`1010` 的前缀)\n7.  `010` (`0101` 的前缀)\n8.  `1010` (第一个目标序列)\n9.  `0101` (第二个目标序列)\n\n这样我们就得到了总共9个状态。我们如下标记它们：\n-   `S_0`：后缀为 `\"\"` (复位状态)，输出 $z=0$。\n-   `S_1`：后缀为 `1`，输出 $z=0$。\n-   `S_2`：后缀为 `0`，输出 $z=0$。\n-   `S_3`：后缀为 `10`，输出 $z=0$。\n-   `S_4`：后缀为 `01`，输出 $z=0$。\n-   `S_5`：后缀为 `101`，输出 $z=0$。\n-   `S_6`：后缀为 `010`，输出 $z=0$。\n-   `S_7`：后缀为 `1010`，输出 $z=1$。\n-   `S_8`：后缀为 `0101`，输出 $z=1$。\n\n现在，我们来确定状态转换。对于每个状态，我们将输入比特（`0` 或 `1`）附加到该状态所代表的字符串上，并找出新字符串的最长后缀，该后缀必须是我们所定义的前缀之一。\n\n-   从 `S_0` (`\"\"`)：输入 `0` 得到 `0` (`S_2`)；输入 `1` 得到 `1` (`S_1`)。\n-   从 `S_1` (`1`)：输入 `0` 得到 `10` (`S_3`)；输入 `1` 得到 `11` (最长前缀后缀为 `1`，因此是 `S_1`)。\n-   从 `S_2` (`0`)：输入 `0` 得到 `00` (最长前缀后缀为 `0`，因此是 `S_2`)；输入 `1` 得到 `01` (`S_4`)。\n-   从 `S_3` (`10`)：输入 `0` 得到 `100` (最长前缀后缀为 `0`，因此是 `S_2`)；输入 `1` 得到 `101` (`S_5`)。\n-   从 `S_4` (`01`)：输入 `0` 得到 `010` (`S_6`)；输入 `1` 得到 `011` (最长前缀后缀为 `1`，因此是 `S_1`)。\n-   从 `S_5` (`101`)：输入 `0` 得到 `1010` (`S_7`)；输入 `1` 得到 `1011` (最长前缀后缀为 `1`，因此是 `S_1`)。\n-   从 `S_6` (`010`)：输入 `0` 得到 `0100` (最长前缀后缀为 `0`，因此是 `S_2`)；输入 `1` 得到 `0101` (`S_8`)。\n-   从 `S_7` (`1010`, $z=1$)：输入 `0` 得到 `10100` (最长前缀后缀为 `0`，因此是 `S_2`)；输入 `1` 得到 `10101` (最长前缀后缀为 `101`，因此是 `S_5`)。\n-   从 `S_8` (`0101`, $z=1$)：输入 `0` 得到 `01010` (最长前缀后缀为 `10`，因此是 `S_3`)；输入 `1` 得到 `01011` (最长前缀后缀为 `1`，因此是 `S_1`)。\n\n这导出了以下状态表：\n\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n| $S_0$         | $S_2$              | $S_1$              | 0            |\n| $S_1$         | $S_3$              | $S_1$              | 0            |\n| $S_2$         | $S_2$              | $S_4$              | 0            |\n| $S_3$         | $S_2$              | $S_5$              | 0            |\n| $S_4$         | $S_6$              | $S_1$              | 0            |\n| $S_5$         | $S_7$              | $S_1$              | 0            |\n| $S_6$         | $S_2$              | $S_8$              | 0            |\n| $S_7$         | $S_2$              | $S_5$              | 1            |\n| $S_8$         | $S_3$              | $S_1$              | 1            |\n\n**步骤2：通过划分法进行状态最小化**\n\n我们使用划分法来寻找等价状态。如果两个状态具有相同的输出，并且对于每个可能的输入，它们的下一状态都属于同一个等价类，那么这两个状态是等价的。\n\n**划分 $P_0$**：根据输出 $z$ 对状态进行划分。\n-   第1组 ($z=0$): {$S_0, S_1, S_2, S_3, S_4, S_5, S_6$}\n-   第2组 ($z=1$): {$S_7, S_8$}\n$P_0 = \\{ (S_0, S_1, S_2, S_3, S_4, S_5, S_6), (S_7, S_8) \\}$\n\n**划分 $P_1$**：我们检查 $P_0$ 中每个组内状态的转换。下一状态根据它们所属的 $P_0$ 中的组别进行分类。\n对于第1组 (G1):\n-   $S_0$：输入 $x=0 \\to S_2(\\text{G1})$；输入 $x=1 \\to S_1(\\text{G1})$。转换：(G1, G1)。\n-   $S_1$：输入 $x=0 \\to S_3(\\text{G1})$；输入 $x=1 \\to S_1(\\text{G1})$。转换：(G1, G1)。\n-   $S_2$：输入 $x=0 \\to S_2(\\text{G1})$；输入 $x=1 \\to S_4(\\text{G1})$。转换：(G1, G1)。\n-   $S_3$：输入 $x=0 \\to S_2(\\text{G1})$；输入 $x=1 \\to S_5(\\text{G1})$。转换：(G1, G1)。\n-   $S_4$：输入 $x=0 \\to S_6(\\text{G1})$；输入 $x=1 \\to S_1(\\text{G1})$。转换：(G1, G1)。\n-   $S_5$：输入 $x=0 \\to S_7(\\text{G2})$；输入 $x=1 \\to S_1(\\text{G1})$。转换：(G2, G1)。\n-   $S_6$：输入 $x=0 \\to S_2(\\text{G1})$；输入 $x=1 \\to S_8(\\text{G2})$。转换：(G1, G2)。\n\n第1组必须被划分。{$S_0, S_1, S_2, S_3, S_4$} 的转换模式为 (G1,G1)。$S_5$ 的模式为 (G2,G1)。$S_6$ 的模式为 (G1,G2)。这产生了三个新的组。\n\n对于第2组 (G2):\n-   $S_7$：输入 $x=0 \\to S_2(\\text{G1})$；输入 $x=1 \\to S_5(\\text{G1})$。转换：(G1, G1)。\n-   $S_8$：输入 $x=0 \\to S_3(\\text{G1})$；输入 $x=1 \\to S_1(\\text{G1})$。转换：(G1, G1)。\n第2组中的两个状态相对于 $P_0$ 具有相同的转换模式。它们保留在同一个组中。\n\n因此，$P_1 = \\{ (S_0, S_1, S_2, S_3, S_4), (S_5), (S_6), (S_7, S_8) \\}$。我们称这些组为 Ga, Gb, Gc, Gd。\n\n**划分 $P_2$**：细化 $P_1$。\n对于 Ga 组:\n-   $S_0$：输入 $x=0 \\to S_2(\\text{Ga})$；输入 $x=1 \\to S_1(\\text{Ga})$。转换：(Ga, Ga)。\n-   $S_1$：输入 $x=0 \\to S_3(\\text{Ga})$；输入 $x=1 \\to S_1(\\text{Ga})$。转换：(Ga, Ga)。\n-   $S_2$：输入 $x=0 \\to S_2(\\text{Ga})$；输入 $x=1 \\to S_4(\\text{Ga})$。转换：(Ga, Ga)。\n-   $S_3$：输入 $x=0 \\to S_2(\\text{Ga})$；输入 $x=1 \\to S_5(\\text{Gb})$。转换：(Ga, Gb)。\n-   $S_4$：输入 $x=0 \\to S_6(\\text{Gc})$；输入 $x=1 \\to S_1(\\text{Ga})$。转换：(Gc, Ga)。\nGa 组分裂。{$S_0, S_1, S_2$} 的模式为 (Ga,Ga)。$S_3$ 的模式为 (Ga,Gb)。$S_4$ 的模式为 (Gc,Ga)。\n\nGb 组和 Gc 组是单元集，不能再分裂。\n\n对于 Gd 组:\n-   $S_7$：输入 $x=0 \\to S_2(\\text{Ga})$；输入 $x=1 \\to S_5(\\text{Gb})$。转换：(Ga, Gb)。\n-   $S_8$：输入 $x=0 \\to S_3(\\text{Ga})$；输入 $x=1 \\to S_1(\\text{Ga})$。转换：(Ga, Ga)。\n转换模式不同。$S_7$ 和 $S_8$ 不等价。Gd 组分裂。\n\n因此，$P_2 = \\{ (S_0, S_1, S_2), (S_3), (S_4), (S_5), (S_6), (S_7), (S_8) \\}$。\n\n**划分 $P_3$**：细化 $P_2$。\n设 $P_2$ 的各组为： G'a = {S0, S1, S2}, G'b={S3}, G'c={S4}, G'd={S5}, G'e={S6}, G'f={S7}, G'g={S8}。\n对于 G'a 组:\n-   $S_0$：输入 $x=0 \\to S_2(\\text{G'a})$；输入 $x=1 \\to S_1(\\text{G'a})$。转换：(G'a, G'a)。\n-   $S_1$：输入 $x=0 \\to S_3(\\text{G'b})$；输入 $x=1 \\to S_1(\\text{G'a})$。转换：(G'b, G'a)。\n-   $S_2$：输入 $x=0 \\to S_2(\\text{G'a})$；输入 $x=1 \\to S_4(\\text{G'c})$。转换：(G'a, G'c)。\n$S_0, S_1, S_2$ 相对于 $P_2$ 的划分具有完全不同的转换模式。因此, G'a 组分裂成三个单元集组。\n\n因此，$P_3 = \\{ (S_0), (S_1), (S_2), (S_3), (S_4), (S_5), (S_6), (S_7), (S_8) \\}$。\n\n由于无法进行进一步的划分（所有组都已是单元集），我们已经达到了最小化形式。这个过程表明，在我们最初的设计中，没有任何两个状态是等价的。\n这意味着最初的9状态机已经是最小化的了。\n\n最小化状态机中的状态数是9。", "answer": "$$\\boxed{9}$$", "id": "1969119"}]}