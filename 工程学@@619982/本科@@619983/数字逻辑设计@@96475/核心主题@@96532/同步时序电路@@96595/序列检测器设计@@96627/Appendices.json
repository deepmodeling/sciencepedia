{"hands_on_practices": [{"introduction": "让我们从一个基础练习开始，这个练习将帮助我们巩固 Mealy 状态机的核心设计原则。我们将为一个非重叠序列“110”设计一个检测器，这需要我们根据目标序列的前缀来严谨地定义状态。这个问题的特别之处在于它包含一个自定义的复位逻辑，这要求我们不仅要遵循标准的状态转移规则，还要仔细解读并实现特定的设计要求，从而锻炼我们将需求规格精确转化为状态图的能力。[@problem_id:1928691]", "problem": "一个数字控制系统需要一个米利型状态机来检测一个特定的、非重叠的输入序列。该状态机接收一个单比特串行输入 `X`，并产生一个单比特输出 `Z`。当且仅当最后接收到的三个输入为'110'时，该状态机应在一个时钟周期内输出 `Z=1`。否则，输出 `Z` 应为'0'。\n\n该状态机的状态是根据输入流中已识别出的、同时也是目标序列'110'前缀的最长后缀来定义的。\n- `S_0`：初始/复位状态，未检测到任何前缀。\n- `S_1`：最后一个输入为'1'的状态。\n- `S_2`：最后两个输入为'11'的状态。\n\n对于复位行为，规定了一个特殊的操作要求。在非重叠地检测到'110'序列后，状态机必须立即转移到表示刚接收到单个'1'的状态（即状态 `S_1`）。对于所有其他转移，状态机应转移到与新输入字符串末尾的'110'的最长有效前缀相对应的状态。\n\n根据这些规范，以下哪个陈述正确描述了从状态 `S_2` 开始的转移？\n\nA. 如果输入 `X` 为'0'，则输出 `Z` 为'1'，下一状态为 `S_1`。如果输入 `X` 为'1'，则输出 `Z` 为'0'，下一状态为 `S_2`。\n\nB. 如果输入 `X` 为'0'，则输出 `Z` 为'1'，下一状态为 `S_0`。如果输入 `X` 为'1'，则输出 `Z` 为'0'，下一状态为 `S_2`。\n\nC. 如果输入 `X` 为'0'，则输出 `Z` 为'1'，下一状态为 `S_0`。如果输入 `X` 为'1'，则输出 `Z` 为'0'，下一状态为 `S_1`。\n\nD. 如果输入 `X` 为'0'，则输出 `Z` 为'0'，下一状态为 `S_1`。如果输入 `X` 为'1'，则输出 `Z` 为'0'，下一状态为 `S_2`。\n\nE. 如果输入 `X` 为'0'，则输出 `Z` 为'1'，下一状态为 `S_1`。如果输入 `X` 为'1'，则输出 `Z` 为'0'，下一状态为 `S_0`。", "solution": "我们设计一个米利型状态机来检测非重叠序列“110”，其状态由观测到的输入中同时也是“110”前缀的最长后缀定义：状态 S_{0} 对应于没有匹配的前缀，状态 S_{1} 对应于最后一个输入为“1”，状态 S_{2} 对应于最后两个输入为“11”。当新接收的输入完成目标序列“110”时，米利型输出 Z 等于 1；否则 Z 等于 0。此外，规范规定了一种特殊的复位行为：在非重叠地检测到“110”后，下一个状态必须是 S_{1}，这会覆盖通常的最长后缀规则。\n\n我们分析从 S_{2} 开始的转移，此时最后两个输入是“11”。\n\n1) 输入 X 等于 0：\n- 最后三个输入变为“110”，因此发生检测，并且根据米利型状态机的特性，在此输入下 Z 等于 1。\n- 特殊要求规定，在非重叠检测之后，下一个状态立即为 S_{1}，而不管通常的后缀到前缀的映射规则。\n因此，从 S_{2} 开始，当 X 等于 0 时，我们得到 Z 等于 1，下一状态为 S_{1}。\n\n2) 输入 X 等于 1：\n- 最后三个输入是“111”。下一个状态必须是与当前输入历史中同时也是“110”前缀的最长后缀相对应的状态。在后缀“1”、“11”和“111”中，“110”的前缀有“1”和“11”，其中“11”是最长的。因此，下一状态仍为 S_{2}。\n- 没有发生检测，因为观察到的三元组不是“110”，所以 Z 等于 0。\n因此，从 S_{2} 开始，当 X 等于 1 时，我们得到 Z 等于 0，下一状态为 S_{2}。\n\n与选项比较，此行为与选项 A 中的描述完全匹配。", "answer": "$$\\boxed{A}$$", "id": "1928691"}, {"introduction": "在掌握了检测固定序列的基础后，我们来挑战一个更有趣的问题：检测一个关系模式而非特定字符串。这个练习要求我们识别出任意三位序列中，首位和末位不同的情况。这促使我们思考一个关键问题：为了完成任务，状态需要“记忆”的最小历史信息是什么？通过解决这个问题，你将深化对状态本质的理解——状态不仅是匹配的前缀，更是解决未来决策所需的最简历史记录。[@problem_id:1928719]", "problem": "在一个简单的网络数据包嗅探器设计中，使用了一种自定义的轻量级协议来识别特殊的控制帧。该协议在串行数据流中嵌入一个验证标记。如果一个3位序列的首位和末位不同，则该序列被视为一个有效的标记。您的任务是设计一个数字电路，该电路以每次一位的方式连续监测输入数据流的重叠3位窗口。当有效标记序列的第三位到达时，该电路应在一个时钟周期内产生输出'1'，否则输出'0'。\n\n将此序列检测器实现为米利型有限状态机（FSM）所需的最少状态数是多少？就本问题而言，您可以假设数据流的前两位输出为'0'，因为此时尚未接收到一个完整的3位序列。\n\nA. 2\n\nB. 3\n\nC. 4\n\nD. 5\n\nE. 8", "solution": "设输入流为 $\\{x_{k}\\}$，其中每个时钟到达一位 $x_{k} \\in \\{0,1\\}$，并设第 $k$ 位到达时的米利输出为 $y_{k}$。根据要求，对于 $k \\geq 3$，\n$$\ny_{k} =\n\\begin{cases}\n1, & \\text{if } x_{k} \\neq x_{k-2},\\\\\n0, & \\text{if } x_{k} = x_{k-2},\n\\end{cases}\n$$\n且给定 $y_{1}=0$ 和 $y_{2}=0$（因为尚未有完整的3位窗口）。\n\n为了在 $x_{k}$ 到达时实现 $y_{k}$（米利输出），状态机必须存储了足够的过去信息。由于 $y_{k}$ 仅取决于 $x_{k}$ 和 $x_{k-2}$，因此当前输出需要知道 $x_{k-2}$ 的值。此外，为了能够在下一个时钟产生 $y_{k+1}$，状态机必须能够将记忆的“两个步骤前”的位更新为 $x_{k-1}$。因此，在读取 $x_{k}$ 之后，状态必须编码 $x_{k-1}$ 和 $x_{k-2}$ 两者，以便在下一个输入 $x_{k+1}$ 到来时，它能够：\n- 通过比较 $x_{k+1}$ 和 $x_{k-1}$ 来计算 $y_{k+1}$，以及\n- 将存储的数对更新为 $(x_{k}, x_{k-1})$。\n\n因此，一个充分的状态描述符是有序对 $(x_{k-1}, x_{k-2})$，它有 $4$ 种可能的值：$(0,0)$, $(0,1)$, $(1,0)$, $(1,1)$。从任何这样的状态 $(a,b)$，对于输入 $c$，米利输出为\n$$\ny = \\begin{cases}\n1, & \\text{if } c \\neq b,\\\\\n0, & \\text{if } c = b,\n\\end{cases}\n$$\n并且下一个状态是 $(c,a)$。\n\n为了证明必要性（最小性），我们考虑可区分性。以四个状态中的两个不同状态为例，比如 $(0,0)$ 和 $(0,1)$。对于相同的输入 $c=0$，它们的输出是不同的，因为当且仅当第二个分量 $b$ 与 $c$ 不同时 $y=1$；即，$b=0$ 产生 $y=0$，而 $b=1$ 产生 $y=1$。因此，这两个状态不能合并。通过对称性，每一对不同的 $(x_{k-1}, x_{k-2})$ 状态都可以通过某个输入来区分，因此不可能进一步简化，稳态行为至少需要 $4$ 个状态。\n\n题目允许假设 $y_{1}=0$ 和 $y_{2}=0$，而不需要额外的瞬态来强制实现这些输出。因此，实现指定检测器的米利 FSM 所需的最小状态数为 $4$。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1928719"}, {"introduction": "作为我们动手实践的终极挑战，这个问题将“状态即为必要历史”的概念推向极致。你将设计一个电路，用于检测一个8位窗口中，后四位是否为前四位的比特逐位取反。这个练习清晰地展示了状态的数量是如何由模式的“记忆”需求直接决定的。通过系统地定义状态，你会发现即使是看似复杂的检测任务也能被有效分解，同时这也揭示了在复杂设计中可能遇到的“状态空间爆炸”问题，为设计高效、可行的数字系统提供了宝贵的实践经验。[@problem_id:1928726]", "problem": "在为高速串行通信线路设计专门的数据完整性监视器时，一项关键任务是检测输入比特流中的特定关系模式。您的任务是为此监视器设计核心逻辑，其形式为一个Mealy型有限状态机。\n\n该机器接收一个串行比特流，每个时钟周期一个比特。当最近接收的八个比特，记为 `x_7 x_6 x_5 x_4 x_3 x_2 x_1 x_0`（其中 `x_0` 是最近接收的比特），满足一个特定条件时，机器的单个输出 `y` 应仅在一个时钟周期内为 `1`。该条件是，最近的四位半字节 (`x_3 x_2 x_1 x_0`) 是紧邻其前的四位半字节 (`x_7 x_6 x_5 x_4`) 的按位一的补码。否则，输出 `y` 应为 `0`。\n\n例如，如果最后接收的八个比特是 `11000011`，则输出 `y` 为 `1`，因为 `0011` 是 `1100` 的一的补码。如果下一个比特是 `1`，则新的八比特序列是 `10000111`。此时输出将为 `0`，因为 `0111` 不是 `1000` 的一的补码。\n\n确定一个能正确实现此检测逻辑的Mealy机所需的最少状态数。", "solution": "设输入流为 $\\{b_{k}\\}_{k \\in \\mathbb{Z}}$，每个时钟周期一个比特。在时刻 $n$（读取到 $b_{n}$ 时），机器必须输出\n$$\ny_{n} = 1 \\quad \\text{iff} \\quad (b_{n-3},b_{n-2},b_{n-1},b_{n}) = \\overline{(b_{n-7},b_{n-6},b_{n-5},b_{n-4})}\n$$\n其中上划线表示按位补码；否则 $y_{n}=0$。\n\n上界（存在性）：一个以当前输入之前的最后七个比特为状态的Mealy机即可满足要求。将读取 $b_{n}$ 之前的状态定义为\n$$\ns_{n} = (b_{n-7},b_{n-6},b_{n-5},b_{n-4},b_{n-3},b_{n-2},b_{n-1}) \\in \\{0,1\\}^{7}.\n$$\n接收到输入 $b_{n}$ 后，8比特窗口为 $(b_{n-7},\\ldots,b_{n})$。输出函数为\n$$\ny_{n} = 1 \\quad \\text{iff} \\quad (b_{n-3},b_{n-2},b_{n-1},b_{n}) = \\overline{(b_{n-7},b_{n-6},b_{n-5},b_{n-4})},\n$$\n这仅取决于 $s_{n}$ 和 $b_{n}$。次态更新为移位操作\n$$\ns_{n+1} = (b_{n-6},b_{n-5},b_{n-4},b_{n-3},b_{n-2},b_{n-1},b_{n}),\n$$\n是 $s_{n}$ 和 $b_{n}$ 的一个确定性函数。因此，$2^{7}=128$ 个状态是足够的。\n\n下界（最小性）：我们证明任意两个不同的7比特状态都不是等价的，因此至少需要 $2^{7}$ 个状态。设 $\\alpha=(a_{1},a_{2},a_{3},a_{4},a_{5},a_{6},a_{7})$ 和 $\\beta=(a'_{1},a'_{2},a'_{3},a'_{4},a'_{5},a'_{6},a'_{7})$ 是两个不同的状态，其中 $a_{i},a'_{i}\\in\\{0,1\\}$ 表示 $(b_{n-7},\\ldots,b_{n-1})$。令 $k$ 为满足 $a_{k}\\neq a'_{k}$ 的最小索引。选择一个整数 $d\\geq 0$ 使得 $k+d\\geq 4$，例如 $d=\\max(0,4-k)$。考虑一个长度为 $d+4$ 的后续序列，定义如下：任选 $d$ 个比特（任意），然后选择接下来的4个比特，称之为 $v_{1},v_{2},v_{3},v_{4}$，使其成为4比特块 $U_{\\alpha}$ 的按位补码。在状态 $\\alpha$ 下，当该半字节的起始位置为 $k+d$ 时，$U_{\\alpha}$ 将扮演“旧半字节”的角色。因为 $k+d\\geq 4$，相应的“新半字节”在此时完全位于未来，且等于 $(v_{1},v_{2},v_{3},v_{4})$，所以在状态 $\\alpha$ 下，此时的输出为 $1$。在状态 $\\beta$ 下，相应的4比特块 $U_{\\beta}$ 与 $U_{\\alpha}$ 至少在一个位置上不同（特别是在源于 $a_{k}\\neq a'_{k}$ 的位置上），因此相同的 $(v_{1},v_{2},v_{3},v_{4})$ 不可能等于 $\\overline{U_{\\beta}}$，输出为 $0$。因此，这两个状态可以通过某个后续序列区分开，并且任意两个不同的7比特状态都不能合并。\n\n因此，最小状态数恰好是 $2^{7}=128$。", "answer": "$$\\boxed{128}$$", "id": "1928726"}]}