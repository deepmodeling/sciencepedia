{"hands_on_practices": [{"introduction": "理解任何数字电路的第一步是数学化地描述其行为。特性方程是一个强大的工具，它简洁地概括了锁存器的输入、当前状态和下一状态之间的关系。第一个练习将指导你推导与非门 SR 锁存器的这一基本方程，这是分析和设计更复杂时序系统的关键技能。[@problem_id:1971383]", "problem": "时序数字逻辑中的一个基本构建模块是置位-复位（SR）锁存器。考虑一个由两个交叉耦合的与非门构成的SR锁存器。该锁存器有两个低电平有效输入，$\\bar{S}$（置位）和 $\\bar{R}$（复位），以及两个输出，$Q$ 和其反相 $\\bar{Q}$。其逻辑连接定义如下：第一个与非门计算 $Q = \\overline{(\\bar{S} \\cdot \\bar{Q})}$，第二个与非门计算 $\\bar{Q} = \\overline{(\\bar{R} \\cdot Q)}$。\n\n该锁存器的动态行为可以通过一个特性方程来概括，该方程将主输出的下一个稳定状态（表示为 $Q_{next}$）表示为其当前状态 $Q$ 和两个输入 $\\bar{S}$ 和 $\\bar{R}$ 的函数。此方程对所有输入组合均有效，但禁用状态（即 $\\bar{S} = 0$ 且 $\\bar{R} = 0$）除外，我们假设该状态不会发生。\n\n以下哪个布尔表达式正确地表示了这个基于与非门的SR锁存器的特性方程 $Q_{next}$？请注意，在下面的表达式中，上划线表示法（例如 $\\overline{A}$）表示逻辑非运算。\n\nA. $Q_{next} = \\bar{S} + \\bar{R}Q$\n\nB. $Q_{next} = \\overline{\\bar{S}} + \\bar{R}Q$\n\nC. $Q_{next} = \\overline{\\bar{S}} + \\overline{\\bar{R}}Q$\n\nD. $Q_{next} = \\bar{R} + \\overline{\\bar{S}}Q$\n\nE. $Q_{next} = \\bar{S} \\cdot (\\bar{R} + Q)$", "solution": "为了推导与非门SR锁存器的特性方程，我们首先构建其激励表，该表显示了在给定当前状态 $Q$ 和输入 $\\bar{S}$、$\\bar{R}$ 的情况下，下一个状态 $Q_{next}$ 的值。\n\n1.  **置位状态 ($\\bar{S}=0, \\bar{R}=1$)**: $Q_{next}$ 被强制为 1。\n2.  **复位状态 ($\\bar{S}=1, \\bar{R}=0$)**: $Q_{next}$ 被强制为 0。\n3.  **保持状态 ($\\bar{S}=1, \\bar{R}=1$)**: $Q_{next}$ 保持其当前值 $Q$。\n4.  **禁用状态 ($\\bar{S}=0, \\bar{R}=0$)**: 结果是未定义的，因此在化简中作为无关项 (X) 处理。\n\n这构成了 $Q_{next}$ 关于 $\\bar{S}$、$\\bar{R}$ 和 $Q$ 的激励表：\n\n| $\\bar{S}$ | $\\bar{R}$ | $Q$ | $Q_{next}$ | 备注          |\n| :-------: | :-------: | :-: | :--------: | :------------ |\n|     0     |     0     |  0  |     X      | 禁用          |\n|     0     |     0     |  1  |     X      | 禁用          |\n|     0     |     1     |  0  |     1      | 置位          |\n|     0     |     1     |  1  |     1      | 置位          |\n|     1     |     0     |  0  |     0      | 复位          |\n|     1     |     0     |  1  |     0      | 复位          |\n|     1     |     1     |  0  |     0      | 保持          |\n|     1     |     1     |  1  |     1      | 保持          |\n\n为了找到 $Q_{next}$ 的最小化布尔表达式，我们使用卡诺图。我们将无关项 (X) 视为 1，以获得尽可能大的分组。\n\n```\n      \\ Q\n \\bar{S}\\bar{R}\\  0    1\n      \\\n    00 |  X    X  |\n       |----------|\n    01 |  1    1  |\n       |----------|\n    11 |  0    1  |\n       |----------|\n    10 |  0    0  |\n```\n\n我们在卡诺图中对“1”进行分组：\n\n1.  **第一组 (置位优先)**: 我们可以将 $\\bar{S}=0, \\bar{R}=1$ 行中的两个 '1' 与 $\\bar{S}=0, \\bar{R}=0$ 行中的两个 'X'（视为 '1'）组合成一个 2x2 的大方块。在这个方块中，$\\bar{R}$ 和 $Q$ 都在变化，只有 $\\bar{S}=0$ 是恒定的。因此，这个分组给出了项 $\\overline{\\bar{S}}$。\n\n2.  **第二组 (保持状态)**: 剩下的一个 '1' 位于单元格 $(\\bar{S}=1, \\bar{R}=1, Q=1)$。我们可以将它与上方单元格 $(\\bar{S}=0, \\bar{R}=1, Q=1)$ 组合。在这个 1x2 的分组中，变量 $\\bar{S}$ 发生变化，而 $\\bar{R}=1$ 和 $Q=1$ 是恒定的。因此，这个分组给出了项 $\\bar{R}Q$。\n\n将这两个项组合起来，我们得到 $Q_{next}$ 的特性方程：\n$$ Q_{next} = \\overline{\\bar{S}} + \\bar{R}Q $$\n\n此表达式与选项B匹配。这个方程简洁地描述了锁存器的行为：当置位信号 $\\bar{S}$ 为低电平时，输出 $Q_{next}$ 为1；否则，输出取决于复位信号 $\\bar{R}$ 和当前状态 $Q$ 的与组合。", "answer": "$$\\boxed{B}$$", "id": "1971383"}, {"introduction": "理想的电路只存在于纸上；现实世界中的元件可能会以意想不到的方式发生故障。本练习提出了一个实际的故障排除场景：“固定为0”的故障，这是数字电子学中一种常见的故障模型。通过分析此缺陷如何影响锁存器的置位、复位和保持功能，你将培养关键的诊断技能，并对电路的内部逻辑有更深的理解。[@problem_id:1971360]", "problem": "一个低电平有效的置位-复位（SR）锁存器由两个交叉耦合的双输入与非门构成。该锁存器的输入被指定为 $\\bar{S}$（Set，置位）和 $\\bar{R}$（Reset，复位）。输出为 $Q$ 和 $\\bar{Q}$。在标准配置中，输出 $Q$ 由以 $\\bar{R}$ 和 $\\bar{Q}$ 为输入的与非门产生，而输出 $\\bar{Q}$ 由以 $\\bar{S}$ 和 $Q$ 为输入的与非门产生。双输入与非门的行为是：其输出为逻辑'0'当且仅当其两个输入均为逻辑'1'；否则，其输出为逻辑'1'。\n\n该锁存器的预定功能如下：\n- **置位(Set)：** 施加输入 $\\bar{S}=0$ 和 $\\bar{R}=1$ 会强制输出 $Q$ 为 1。\n- **复位(Reset)：** 施加输入 $\\bar{S}=1$ 和 $\\bar{R}=0$ 会强制输出 $Q$ 为 0。\n- **保持(Hold)：** 施加输入 $\\bar{S}=1$ 和 $\\bar{R}=1$ 会使锁存器保持其当前状态（$Q$ 保持不变）。\n\n一个制造缺陷在锁存器内部引入了一个'固定于0'（stuck-at-0）的故障。该故障导致对应于 $\\bar{S}$ 的输入线在其与非门的输入端永久地保持在逻辑'0'，无论外部 $\\bar{S}$ 引脚上施加何种信号。\n\n鉴于此故障，确定该锁存器的哪些预定功能（置位、复位、保持）仍能正常工作。\n\nA. 仅置位\n\nB. 仅复位\n\nC. 仅保持\n\nD. 仅置位和复位\n\nE. 所有功能都不能正常工作。", "solution": "低电平有效SR锁存器的行为由其交叉耦合与非门结构决定，其输出 $Q$ 和 $\\bar{Q}$ 的布尔表达式如下：\n$$Q = \\overline{\\bar{R} \\cdot \\bar{Q}}$$\n$$\\bar{Q} = \\overline{\\bar{S} \\cdot Q}$$\n\n问题陈述 $\\bar{S}$ 输入线上存在一个'固定于0'的故障。这意味着对应于 $\\bar{S}$ 的第二个与非门的输入始终为0，无论外部信号如何。我们将此故障有效输入表示为 $\\bar{S}_{\\text{eff}} = 0$。\n\n因此，$\\bar{Q}$ 的方程因该故障而被修改为：\n$$\\bar{Q} = \\overline{\\bar{S}_{\\text{eff}} \\cdot Q} = \\overline{0 \\cdot Q}$$\n\n与非门的一个基本特性是，如果其任何一个输入为0，其输出则为1。因此，无论 $Q$ 的值是多少，输出 $\\bar{Q}$ 都将被永久强制为逻辑'1'状态。\n$$\\bar{Q} = 1$$\n\n现在我们将这个固定的 $\\bar{Q}$ 值代入另一个输出 $Q$ 的方程中：\n$$Q = \\overline{\\bar{R} \\cdot \\bar{Q}} = \\overline{\\bar{R} \\cdot 1}$$\n\n当与非门的一个输入保持为1时，其行为相当于另一个输入的反相器。这是因为 $\\overline{A \\cdot 1} = \\bar{A}$。在我们的例子中，这意味着：\n$$Q = \\overline{\\bar{R}}$$\n\n所以，这个故障锁存器电路不再保持状态，而是表现为对 $\\bar{R}$ 输入的一个简单反相器。$\\bar{S}$ 输入对输出 $Q$ 没有影响。现在我们基于这个推导出的行为来测试每个预定功能。\n\n**1. 测试'置位'功能：**\n- 预定输入：$\\bar{S}=0$, $\\bar{R}=1$。\n- 期望输出：$Q$ 应被强制为1（$Q \\to 1$）。\n- 故障电路的实际输出：电路的行为是 $Q = \\overline{\\bar{R}}$。当 $\\bar{R}=1$ 时，输出为：\n$$Q = \\overline{1} = 0$$\n- 实际输出是 $Q=0$，而不是期望的 $Q=1$。因此，**置位功能失效**。\n\n**2. 测试'复位'功能：**\n- 预定输入：$\\bar{S}=1$, $\\bar{R}=0$。\n- 期望输出：$Q$ 应被强制为0（$Q \\to 0$）。\n- 故障电路的实际输出：当 $\\bar{R}=0$ 时，输出为：\n$$Q = \\overline{0} = 1$$\n- 实际输出是 $Q=1$，而不是期望的 $Q=0$。因此，**复位功能失效**。\n\n**3. 测试'保持'功能：**\n- 预定输入：$\\bar{S}=1$, $\\bar{R}=1$。\n- 期望输出：$Q$ 应保持其先前的状态（记忆）。\n- 故障电路的实际输出：当 $\\bar{R}=1$ 时，输出为：\n$$Q = \\overline{1} = 0$$\n- 电路强制输出 $Q$ 为0，无论其先前的状态如何。例如，如果锁存器处于 $Q=1$ 的状态，施加'保持'输入会将其状态改变为 $Q=0$。这不是'保持'操作。因此，**保持功能失效**。\n\n由于 $\\bar{S}$ 输入上的'固定于0'故障，所有三个基本功能——置位、复位和保持——都无法按预期工作，因此所有功能均无法正常工作。", "answer": "$$\\boxed{E}$$", "id": "1971360"}, {"introduction": "工程学的一个关键部分不仅仅是分析电路，更是改进它们。标准的SR锁存器有一个明显的局限性——“禁用”输入状态。这最后一个练习挑战你从分析者转变为设计者，通过创建一个“复位优先”的锁存器来妥善处理这个有问题的输入，从而使电路更加健壮和可预测。[@problem_id:1971414]", "problem": "一个标准的低电平有效置位-复位 (SR) 锁存器由两个交叉耦合的双输入与非门构成。其输入为 $\\bar{S}$ (低电平有效置位) 和 $\\bar{R}$ (低电平有效复位)，输出为 $Q$ 和 $\\bar{Q}$。在这种标准配置中，输入组合 $\\bar{S}=0$ 和 $\\bar{R}=0$ 被认为是无效或禁止的，因为它会强制 $Q$ 和 $\\bar{Q}$ 同时变为逻辑高电平 (1)，这违反了输出的互补性。\n\n你的任务是设计一个改进的锁存器，通过建立“复位优先”的行为来解决这种不确定性。在这个新设计中，当 $\\bar{S}$ 和 $\\bar{R}$ 同时有效（即 $\\bar{S}=0$ 和 $\\bar{R}=0$）时，锁存器必须被强制进入复位状态 ($Q=0$, $\\bar{Q}=1$)。所有其他输入组合的行为应与标准SR锁存器中的行为相同。\n\n这个修改是通过在核心的双与非门锁存器前端放置一个组合逻辑电路来实现的。外部输入是 $\\bar{S}$ 和 $\\bar{R}$，组合逻辑电路的输出（为清晰起见，记为 $\\bar{S}_{internal}$ 和 $\\bar{R}_{internal}$）用作核心锁存器的输入。\n\n请确定 $\\bar{S}_{internal}$ 和 $\\bar{R}_{internal}$ 关于外部输入 $\\bar{S}$ 和 $\\bar{R}$ 的最小积之和布尔表达式。设表达式 $\\overline{X}$ 表示 $X$ 的逻辑非。\n\n下列哪对方程正确表示了所需的逻辑？（注意：选项使用 $S_{internal}$ 和 $R_{internal}$ 作为变量名）\n\nA. $S_{internal} = \\bar{S} + \\overline{\\bar{R}}$; $R_{internal} = \\bar{R}$\n\nB. $S_{internal} = \\bar{S}$; $R_{internal} = \\bar{S} + \\bar{R}$\n\nC. $S_{internal} = \\bar{S}$; $R_{internal} = \\bar{R}$\n\nD. $S_{internal} = \\bar{S} \\cdot \\bar{R}$; $R_{internal} = \\bar{S} + \\bar{R}$\n\nE. $S_{internal} = \\overline{\\bar{S}} + \\bar{R}$; $R_{internal} = \\bar{S}$", "solution": "目标是为一个标准的低电平有效SR与非门锁存器设计一个组合逻辑前端，使其具有复位优先的特性。核心锁存器是低电平有效的，其内部输入我们标记为 $\\bar{S}_{internal}$ 和 $\\bar{R}_{internal}$。其行为如下：\n- **复位：** 如果 $\\bar{S}_{internal}=1$ 且 $\\bar{R}_{internal}=0$，输出变为 $Q=0$。\n- **置位：** 如果 $\\bar{S}_{internal}=0$ 且 $\\bar{R}_{internal}=1$，输出变为 $Q=1$。\n- **保持：** 如果 $\\bar{S}_{internal}=1$ 且 $\\bar{R}_{internal}=1$，输出保持其前一个状态。\n- **禁止：** 必须避免 $\\bar{S}_{internal}=0$ 和 $\\bar{R}_{internal}=0$ 的组合。\n\n我们需要根据外部输入 $\\bar{S}$ 和 $\\bar{R}$ 来确定 $\\bar{S}_{internal}$ 和 $\\bar{R}_{internal}$ 的逻辑，以实现所需的整体行为。让我们创建一个真值表，显示每个外部输入组合的期望操作，然后确定产生该操作所需的 $\\bar{S}_{internal}$ 和 $\\bar{R}_{internal}$ 的值。\n\n期望的行为是：\n1.  **保持状态 ($\\bar{S}=1, \\bar{R}=1$)：** 锁存器应保持其状态。这要求内部输入为 $\\bar{S}_{internal}=1, \\bar{R}_{internal}=1$。\n2.  **置位状态 ($\\bar{S}=0, \\bar{R}=1$)：** 锁存器应置位 ($Q=1$)。这要求 $\\bar{S}_{internal}=0, \\bar{R}_{internal}=1$。\n3.  **复位状态 ($\\bar{S}=1, \\bar{R}=0$)：** 锁存器应复位 ($Q=0$)。这要求 $\\bar{S}_{internal}=1, \\bar{R}_{internal}=0$。\n4.  **复位优先状态 ($\\bar{S}=0, \\bar{R}=0$)：** 这是关键的修改。锁存器必须复位 ($Q=0$)。这同样要求 $\\bar{S}_{internal}=1, \\bar{R}_{internal}=0$。\n\n我们可以将此总结在一个真值表中：\n\n| 外部输入 | 期望操作 | 所需内部输入 |\n| :-------------: | :-------------: | :-----------------------: |\n| $\\bar{S}$ | $\\bar{R}$ | | $\\bar{S}_{internal}$ | $\\bar{R}_{internal}$ |\n| 0 | 0 | 复位 | 1 | 0 |\n| 0 | 1 | 置位 | 0 | 1 |\n| 1 | 0 | 复位 | 1 | 0 |\n| 1 | 1 | 保持 | 1 | 1 |\n\n现在，我们从这个表中推导出 $\\bar{S}_{internal}$ 和 $\\bar{R}_{internal}$ 作为 $\\bar{S}$ 和 $\\bar{R}$ 函数的布尔表达式。\n\n**$\\bar{R}_{internal}$ 的推导：**\n观察 $\\bar{R}_{internal}$ 的列 (0, 1, 0, 1)。这个模式与外部输入 $\\bar{R}$ 的模式完全相同 (0, 1, 0, 1)。\n因此，$\\bar{R}_{internal}$ 的表达式即为：\n$$\\bar{R}_{internal} = \\bar{R}$$\n\n**$\\bar{S}_{internal}$ 的推导：**\n我们为 $\\bar{S}_{internal}$ 创建一个卡诺图 (K-map)，其变量为 $\\bar{S}$ 和 $\\bar{R}$：\n\n```\n      \\ \\bar{R}\n       \\ 0   1\n    \\bar{S}\\\n    0   | 1 | 0 |\n    1   | 1 | 1 |\n```\n\n我们将 '1' 分组以找到最小表达式：\n1.  **第一组:** $\\bar{S}=1$ 的整行构成一组，包含两个 '1'。该组的项是 $\\bar{S}$。\n2.  **第二组:** $\\bar{R}=0$ 的整列构成一组，包含两个 '1'。该组的项是 $\\overline{\\bar{R}}$。\n\n通过“或”运算组合这些项，得到最小和之积表达式：\n$$\\bar{S}_{internal} = \\bar{S} + \\overline{\\bar{R}}$$\n\n所以，所需的布尔表达式对是：\n$$\\bar{S}_{internal} = \\bar{S} + \\overline{\\bar{R}}$$\n$$\\bar{R}_{internal} = \\bar{R}$$\n\n尽管问题选项中使用了 $S_{internal}$ 和 $R_{internal}$ 这一可能引起混淆的命名，但其意图是表示核心锁存器的低电平有效输入。将我们推导出的表达式与选项进行比较，选项 A 与我们的结果完全匹配。\n$$S_{internal} = \\bar{S} + \\overline{\\bar{R}}$$\n$$R_{internal} = \\bar{R}$$\n这与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1971414"}]}