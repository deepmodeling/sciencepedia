{"hands_on_practices": [{"introduction": "在我们深入探讨复杂的时序问题之前，让我们先来巩固对D触发器基本工作原理的理解。这个练习将引导你追踪一个连接在简单反馈电路中的触发器其输出状态 $Q$ 的变化过程。通过为给定的输入序列逐步计算输出，你将加深对触发器如何在每个时钟有效边沿捕获其 $D$ 输入端数值这一核心功能的理解。[@problem_id:1931277]", "problem": "一个时序逻辑电路是使用一个正沿触发的D型触发器和一个异或(XOR)门设计的。该电路有一个外部串行数据输入（表示为$S$）和一个时钟信号。触发器的数据输入$D$由异或门的输出驱动。该异或门的两个输入是外部串行数据线$S$和触发器自身的输出$Q$。\n\n初始时，在施加任何时钟脉冲之前，触发器的输出$Q$处于逻辑低电平(0)状态。\n\n外部串行数据输入$S$被馈送5位序列'10110'。$S$的位与时钟同步，这意味着在连续五个时钟上升沿的每一个，序列中的一个新位在$S$输入端是稳定的。第一个位('1')在第一个时钟上升沿出现，第二个位('0')在第二个，以此类推。\n\n在连续五个时钟上升沿之后，输出$Q$处得到的5位状态序列是什么？该序列应从第一个时钟沿后的状态读到第五个时钟沿后的状态。\n\nA. 10110\n\nB. 11011\n\nC. 01011\n\nD. 01110\n\nE. 11100", "solution": "一个正沿触发的D型触发器在每个上升沿根据 $Q^{+}=D$ 更新其状态。这里 $D=S \\oplus Q$，其中 $\\oplus$ 表示异或(XOR)运算。在初始条件 $Q_{0}=0$ 且输入位为 $S_{1}=1$, $S_{2}=0$, $S_{3}=1$, $S_{4}=1$, $S_{5}=0$ 的情况下，状态更新由以下递归公式给出：\n$$\nQ_{i}=S_{i} \\oplus Q_{i-1}, \\quad i=1,\\dots,5.\n$$\n逐步计算：\n$$\nQ_{1}=1 \\oplus 0=1,\\quad\nQ_{2}=0 \\oplus 1=1,\\quad\nQ_{3}=1 \\oplus 1=0,\\quad\nQ_{4}=1 \\oplus 0=1,\\quad\nQ_{5}=0 \\oplus 1=1.\n$$\n因此，每个上升沿后的输出序列是 $11011$，这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1931277"}, {"introduction": "理想的逻辑门在现实中并不存在，数字元件必须遵循严格的时序规则。本练习将带领你从理想模型过渡到D触发器的实际应用，聚焦于其最关键的输入时序约束之一：建立时间 ($t_{setup}$)。你将学会分析一系列信号事件，判断数据输入在时钟边沿到来前是否保持了足够长的稳定时间，这是设计可靠数字系统、避免亚稳态的关键技能。[@problem_id:1931286]", "problem": "一个数字电路使用一个上升沿触发的D型触发器对数据信号进行采样。该触发器的建立时间要求为 $t_{setup} = 3 \\text{ ns}$，保持时间要求为 $t_{hold} = 2 \\text{ ns}$。\n\n数据输入 (D) 和时钟输入 (CLK) 信号初始时均为逻辑0。以下是按时间顺序排列的在85 ns间隔内发生的所有信号跳变列表。一次“从X到Y”的跳变意味着信号在指定时间之前稳定在电平X，在指定时间之后稳定在电平Y。\n\n- 在 $t = 10 \\text{ ns}$ 时，D 信号从 0 跳变为 1。\n- 在 $t = 20 \\text{ ns}$ 时，CLK 信号从 0 跳变为 1。\n- 在 $t = 25 \\text{ ns}$ 时，CLK 信号从 1 跳变为 0。\n- 在 $t = 38 \\text{ ns}$ 时，D 信号从 1 跳变为 0。\n- 在 $t = 40 \\text{ ns}$ 时，CLK 信号从 0 跳变为 1。\n- 在 $t = 45 \\text{ ns}$ 时，CLK 信号从 1 跳变为 0。\n- 在 $t = 50 \\text{ ns}$ 时，D 信号从 0 跳变为 1。\n- 在 $t = 60 \\text{ ns}$ 时，CLK 信号从 0 跳变为 1。\n- 在 $t = 65 \\text{ ns}$ 时，CLK 信号从 1 跳变为 0。\n- 在 $t = 70 \\text{ ns}$ 时，D 信号从 1 跳变为 0。\n- 在 $t = 80 \\text{ ns}$ 时，CLK 信号从 0 跳变为 1。\n- 在 $t = 85 \\text{ ns}$ 时，CLK 信号从 1 跳变为 0。\n\n根据这一事件序列，以下哪个时钟上升沿导致了D触发器的建立时间冲突？\n\nA. 在 $t = 20 \\text{ ns}$ 时的上升沿。\n\nB. 在 $t = 40 \\text{ ns}$ 时的上升沿。\n\nC. 在 $t = 60 \\text{ ns}$ 时的上升沿。\n\nD. 在 $t = 80 \\text{ ns}$ 时的上升沿。\n\nE. 在任何上升沿都没有发生建立时间冲突。", "solution": "问题要求我们确定对于建立时间为 $t_{setup} = 3 \\text{ ns}$ 的D触发器，是哪个时钟上升沿导致了建立时间冲突。\n\n如果数据输入 (D) 在时钟 (CLK) 的有效沿（本例中为上升沿）之前的建立时间窗口内发生变化，就会发生建立时间冲突。对于在时间 $t_{clk}$ 发生的时钟上升沿，数据信号D必须在时间区间 $[t_{clk} - t_{setup}, t_{clk}]$ 内保持稳定。\n\n我们需要分析在问题中描述的四个时钟上升沿之前，D信号的状态。这些上升沿发生在 $t = 20 \\text{ ns}$、$t = 40 \\text{ ns}$、$t = 60 \\text{ ns}$ 和 $t = 80 \\text{ ns}$。\n\n**对 $t = 20 \\text{ ns}$ 时上升沿的分析：**\n时钟沿发生在 $t_{clk,1} = 20 \\text{ ns}$。\n要求的建立时间为 $t_{setup} = 3 \\text{ ns}$。\n建立时间窗口为 $[20 - 3, 20] \\text{ ns} = [17, 20] \\text{ ns}$。\n我们必须检查在此区间内D信号是否稳定。\n根据问题描述，在此次时钟沿之前，D信号的最后一次跳变发生在 $t = 10 \\text{ ns}$ (从0到1)。\nD信号从 $t = 10 \\text{ ns}$ 开始稳定在逻辑1，直到下一次在 $t = 38 \\text{ ns}$ 发生变化。\n由于区间 $[10, 38]$ ns 完全包含了建立时间窗口 $[17, 20]$ ns，因此D信号在建立时间窗口内是稳定的。\n因此，在 $t = 20 \\text{ ns}$ 时没有发生建立时间冲突。\n\n**对 $t = 40 \\text{ ns}$ 时上升沿的分析：**\n时钟沿发生在 $t_{clk,2} = 40 \\text{ ns}$。\n要求的建立时间为 $t_{setup} = 3 \\text{ ns}$。\n建立时间窗口为 $[40 - 3, 40] \\text{ ns} = [37, 40] \\text{ ns}$。\n我们必须检查在此区间内D信号是否稳定。\n在此次时钟沿之前，D信号的最后一次跳变发生在 $t = 38 \\text{ ns}$ (从1到0)。\n这次在 $t = 38 \\text{ ns}$ 的跳变落在建立时间窗口 $[37, 40]$ ns *之内*。\n或者，我们可以计算在时钟沿之前数据保持稳定的时间长度：$\\Delta t = t_{clk,2} - t_{D\\_change} = 40 \\text{ ns} - 38 \\text{ ns} = 2 \\text{ ns}$。\n由于这个时间长度 $\\Delta t = 2 \\text{ ns}$ 小于要求的建立时间 $t_{setup} = 3 \\text{ ns}$，因此发生了建立时间冲突。\n因此，在 $t = 40 \\text{ ns}$ 时发生了建立时间冲突。\n\n**对 $t = 60 \\text{ ns}$ 时上升沿的分析：**\n时钟沿发生在 $t_{clk,3} = 60 \\text{ ns}$。\n要求的建立时间为 $t_{setup} = 3 \\text{ ns}$。\n建立时间窗口为 $[60 - 3, 60] \\text{ ns} = [57, 60] \\text{ ns}$。\n在此次时钟沿之前，D信号的最后一次跳变发生在 $t = 50 \\text{ ns}$ (从0到1)。\nD信号从 $t = 50 \\text{ ns}$ 开始稳定在逻辑1，直到下一次在 $t = 70 \\text{ ns}$ 发生变化。\n由于区间 $[50, 70]$ ns 完全包含了建立时间窗口 $[57, 60]$ ns，因此D信号在建立时间窗口内是稳定的。\n因此，在 $t = 60 \\text{ ns}$ 时没有发生建立时间冲突。\n\n**对 $t = 80 \\text{ ns}$ 时上升沿的分析：**\n时钟沿发生在 $t_{clk,4} = 80 \\text{ ns}$。\n要求的建立时间为 $t_{setup} = 3 \\text{ ns}$。\n建立时间窗口为 $[80 - 3, 80] \\text{ ns} = [77, 80] \\text{ ns}$。\n在此次时钟沿之前，D信号的最后一次跳变发生在 $t = 70 \\text{ ns}$ (从1到0)。\n在指定的时间范围内，D信号从 $t = 70 \\text{ ns}$ 起稳定在逻辑0。\n由于D信号在区间 $[77, 80]$ ns 内没有变化，因此满足建立时间条件。\n因此，在 $t = 80 \\text{ ns}$ 时没有发生建立时间冲突。\n\n根据分析，只有在 $t = 40 \\text{ ns}$ 时的时钟上升沿导致了建立时间冲突。这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1931286"}, {"introduction": "现代数字电路的设计早已不是手动搭建逻辑门，而是通过硬件描述语言（HDL）来完成。这个练习将理论与实践相结合，要求你使用Verilog为一个功能完备的D触发器编写行为级模型。你不仅要实现基本的数据锁存功能，还需要集成异步清零和同步使能等在真实设计中至关重要的控制逻辑，这是迈向复杂数字系统设计的关键一步。[@problem_id:1931239]", "problem": "您的任务是使用 Verilog 硬件描述语言 (HDL) 为一个特殊的 D 型触发器设计行为模型。该触发器具有以下输入和输出端口：一个时钟 `clk`、数据输入 `d`、一个高电平有效同步使能 `en`、一个低电平有效异步清零 `clr_n` 以及一个输出 `q`。输出 `q` 应声明为 `reg` 或 `logic` 类型。\n\n该触发器所需的行为如下：\n1.  **异步清零**：当 `clr_n` 输入为低电平（逻辑 0）时，输出 `q` 必须立即无条件地被强制为 0。此操作必须具有最高优先级，并且无论 `clk` 或 `en` 的状态如何都必须发生。\n2.  **同步操作**：当 `clr_n` 为高电平（逻辑 1）时，触发器的行为与 `clk` 输入的上升沿同步。\n3.  **时钟使能**：在 `clk` 的上升沿（且 `clr_n` 为高电平时），如果 `en` 输入为高电平（逻辑 1），则输出 `q` 应更新为数据输入 `d` 的值。\n4.  **保持状态**：在 `clk` 的上升沿（且 `clr_n` 为高电平时），如果 `en` 输入为低电平（逻辑 0），则输出 `q` 必须保持其先前的值。\n\n下列哪个 Verilog `always` 块正确地实现了所描述的触发器？\n\nA.\n```verilog\nalways @(posedge clk) begin\n    if (!clr_n) begin\n        q <= 1'b0;\n    end else if (en) begin\n        q <= d;\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (!clr_n) begin\n        q = 1'b0;\n    end else if (en) begin\n        q = d;\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (!clr_n) begin\n        q <= 1'b0;\n    end else if (en) begin\n        q <= d;\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (en) begin\n        if (!clr_n) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\nend\n```\n\nE.\n```verilog\nalways @(posedge clk or negedge clr_n) begin\n    if (clr_n == 1'b0)\n        q <= 1'b0;\n    else if (clk == 1'b1 && en == 1'b1)\n        q <= d;\nend\n```", "solution": "我们来解读一下规格要求：\n\n- 具有最高优先级的低电平有效异步清零，要求 `always` 块对清零信号的下降沿敏感，并立即将 $q$ 强制为 $0$，而无需考虑 `clk` 或 `en`。这意味着事件控制的形式应为 `@(posedge clk or negedge clr_n)`（或使用逗号的等效形式），并且需要一个测试 `!clr_n` 的 `if` 分支，通过非阻塞赋值来执行 $q \\leftarrow 0$。\n\n- 当 $clr_n$ 为高电平时，在 $clk$ 上升沿的同步行为意味着对 $q$ 的更新仅在 `posedge clk` 且 $clr_n=1$ 时发生；否则，异步分支处理 $clr_n=0$ 的情况。\n\n- 时钟使能意味着在 `posedge clk` 且 $clr_n=1$ 时，如果 $en=1$，则 $q$ 应采样 $d$；如果 $en=0$，则 $q$ 应保持。在时序 `always` 块中，省略 $en=0$ 情况下的赋值会正确地推断出保持状态。\n\n评估每个选项：\n\n- A 使用 `always @(posedge clk)`，因此无法执行相对于 `clr_n` 立即生效的异步清零。因此，它违反了异步清零的要求。\n\n- B 使用 `always @(posedge clk, negedge clr_n)` 且优先级正确，但在时序块中使用了阻塞赋值 “=”。虽然某些工具可能会对其进行仿真甚至综合，但正确的触发器建模需要使用非阻塞赋值 “<=” 来避免竞争条件和意外行为；因此，这不是正确的实现。\n\n- C 使用 `always @(posedge clk, negedge clr_n)`，使用了非阻塞赋值且优先级正确：如果 `(!clr_n)`，则异步地 $q \\leftarrow 0$；否则（在 `posedge clk` 上），如果 `(en)`，则 $q \\leftarrow d$；再否则保持。这符合所有指定的行为。\n\n- D 将清零操作嵌套在使能条件下。在 `negedge clr_n` 但 `en` 为低电平时，清零将不会执行，这违反了清零具有最高优先级且必须在任何 `en` 状态下都起作用的要求。\n\n- E 在时钟 `always` 块内部包含了对 `clk` 的显式测试。尽管在 `posedge clk` 时功能上是冗余的，但在条件中引用 `clk` 是不标准的，并且可能无法按预期综合；此外，正确的模板既不要求也不建议在 `if` 内部检查 `clk`。与 C 相比，这不是规范的或可可靠综合的形式。\n\n因此，明确且可移植地实现了指定触发器的正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1931239"}]}