{"hands_on_practices": [{"introduction": "在数字逻辑设计中，一个核心思想是利用现有的、更简单的元件来构建更复杂的电路。这个练习挑战你跳出思维定式，使用一个全加器——通常用于算术加法——来实现一个1位数值比较器。这个过程不仅能加深你对比较器和加法器底层布尔逻辑的理解，还能展示不同数字模块之间深刻的内在联系。[@problem_id:1945479]", "problem": "一位数字系统工程师的任务是使用一个1位全加器作为主要组件来创建一个1位数值比较器，以最小化逻辑门数量。该比较器有两个单位输入 $A$ 和 $B$，并产生三个互斥输出：$G$（当 $AB$ 时为高电平）、$E$（当 $A=B$ 时为高电平）和 $L$（当 $AB$ 时为高电平）。\n\n工程师使用一个标准的1位全加器，该全加器有三个输入（$X, Y, C_{in}$）和两个输出：和位 $S$ 和进位输出位 $C_{out}$。为了执行 $A$ 和 $B$ 之间的比较，该全加器配置如下：其输入设置为 $X=A$，$Y=\\bar{B}$（$B$ 的逻辑非），以及 $C_{in}=1$。\n\n您的任务是根据全加器的输出 $S$ 和 $C_{out}$，确定比较器输出 $G$、$E$ 和 $L$ 的正确布尔表达式集合。以下哪个选项正确地实现了该1位数值比较器？\n\nA. $G = S \\cdot C_{out}$, $E = \\bar{S}$, $L = \\overline{C_{out}}$\n\nB. $G = \\bar{S} \\cdot C_{out}$, $E = S$, $L = \\bar{S} \\cdot \\overline{C_{out}}$\n\nC. $G = C_{out}$, $E = \\bar{S}$, $L = \\overline{C_{out}}$\n\nD. $G = S$, $E = S \\oplus C_{out}$, $L = C_{out}$\n\nE. $G = S \\cdot \\overline{C_{out}}$, $E = \\overline{S \\oplus C_{out}}$, $L = \\bar{S} \\cdot C_{out}$", "solution": "一个标准的全加器具有\n$$S = X \\oplus Y \\oplus C_{in}, \\quad C_{out} = XY + X C_{in} + Y C_{in}.$$\n当 $X=A$，$Y=\\bar{B}$ 且 $C_{in}=1$ 时，\n$$S = A \\oplus \\bar{B} \\oplus 1.$$\n使用 $Z \\oplus 1 = \\bar{Z}$ 和 $A \\oplus \\bar{B} = \\overline{A \\oplus B}$ (即XNOR)，\n$$S = \\overline{A \\oplus \\bar{B}} = \\overline{\\overline{A \\oplus B}} = A \\oplus B.$$\n对于进位，\n$$C_{out} = A\\bar{B} + A\\cdot 1 + \\bar{B}\\cdot 1 = A\\bar{B} + A + \\bar{B} = A + \\bar{B},$$\n使用了吸收律 $A + A\\bar{B} = A$。\n\n一个1位比较器需要\n$$G = A\\bar{B}, \\quad E = \\overline{A \\oplus B}, \\quad L = \\bar{A}B.$$\n根据已发现的关系，\n- 由于 $S = A \\oplus B$，我们有 $E = \\bar{S}$。\n- $C_{out} = A + \\bar{B}$ 仅在 $A=0$ 且 $B=1$ 时等于 0，这正是 $AB$ 的情况，因此 $L = \\overline{C_{out}}$。\n- 当 $S=1$（输入不相等）时，$C_{out}=1$ 精确对应 $A=1, B=0$ 的情况，所以 $G = S \\cdot C_{out}$。\n\n因此，正确的实现是\n$$G = S \\cdot C_{out}, \\quad E = \\bar{S}, \\quad L = \\overline{C_{out}},$$\n这与选项 A 一致。", "answer": "$$\\boxed{A}$$", "id": "1945479"}, {"introduction": "从单个比特的设计出发，我们现在进入一个更贴近实际的工程场景：如何扩展一个标准集成电路（IC）的功能。这个练习要求你使用一个现成的4位比较器IC，通过添加外部逻辑门，来设计一个5位的比较器。这是模块化设计中的一个经典问题，也是构建大规模、可扩展数字系统的基础。[@problem_id:1919823]", "problem": "在数字系统设计中，通过级联较小的标准集成电路（IC）元件来构建更大的功能模块是一种常见做法。考虑设计一个5位数值比较器的任务。您只有一个标准的4位数值比较器IC可用，但可以使用任何必要的外部逻辑门。\n\n设要比较的两个5位无符号二进制数为 $A = A_4A_3A_2A_1A_0$ 和 $B = B_4B_3B_2B_1B_0$，其中 $A_4$ 和 $B_4$ 是最高有效位（MSBs）。\n\n所提供的4位比较器IC接收每个数的低四位，即其输入为 $A_{in} = A_3A_2A_1A_0$ 和 $B_{in} = B_3B_2B_1B_0$。它产生三个输出：\n- $G_{in}$：如果 $A_{in}  B_{in}$，该输出为高电平（逻辑1），否则为低电平（逻辑0）。\n- $E_{in}$：如果 $A_{in} = B_{in}$，该输出为高电平（逻辑1），否则为低电平（逻辑0）。\n- $L_{in}$：如果 $A_{in}  B_{in}$，该输出为高电平（逻辑1），否则为低电平（逻辑0）。\n\n您需要推导出最终5位比较输出的布尔逻辑表达式，这些输出表示为 $G_{out}$、$E_{out}$ 和 $L_{out}$，分别对应于条件 $A  B$、$A = B$ 和 $A  B$。这些表达式必须是最高有效位（$A_4$、$B_4$）和4位IC输出（$G_{in}$、$E_{in}$、$L_{in}$）的函数。\n\n请从以下选项中选择正确的布尔表达式集。在表达式中，乘积 `·` 表示逻辑与，和 `+` 表示逻辑或，上划线（例如 $\\overline{X}$）表示逻辑非。\n\nA.\n$G_{out} = (A_4 \\cdot \\overline{B_4}) + G_{in}$\n$E_{out} = \\overline{(A_4 \\oplus B_4)} + E_{in}$\n$L_{out} = (\\overline{A_4} \\cdot B_4) + L_{in}$\n\nB.\n$G_{out} = A_4 \\cdot \\overline{B_4}$\n$E_{out} = E_{in}$\n$L_{out} = \\overline{A_4} \\cdot B_4$\n\nC.\n$G_{out} = (A_4 \\cdot \\overline{B_4}) + (\\overline{A_4 \\oplus B_4}) \\cdot G_{in}$\n$E_{out} = (\\overline{A_4 \\oplus B_4}) \\cdot E_{in}$\n$L_{out} = (\\overline{A_4} \\cdot B_4) + (\\overline{A_4 \\oplus B_4}) \\cdot L_{in}$\n\nD.\n$G_{out} = (\\overline{A_4} \\cdot B_4) + (\\overline{A_4 \\oplus B_4}) \\cdot G_{in}$\n$E_{out} = (A_4 \\oplus B_4) \\cdot E_{in}$\n$L_{out} = (A_4 \\cdot \\overline{B_4}) + (\\overline{A_4 \\oplus B_4}) \\cdot L_{in}$", "solution": "我们通过先检查最高有效位 $A_{4}$ 和 $B_{4}$ 来比较5位无符号数 $A=A_{4}A_{3}A_{2}A_{1}A_{0}$ 和 $B=B_{4}B_{3}B_{2}B_{1}B_{0}$。对于低四位 $A_{in}=A_{3}A_{2}A_{1}A_{0}$ 和 $B_{in}=B_{3}B_{2}B_{1}B_{0}$，提供的4位比较器给出输出 $G_{in}$、$E_{in}$、$L_{in}$，分别表示 $A_{in}B_{in}$、$A_{in}=B_{in}$和 $A_{in}B_{in}$。\n\n基本比较逻辑：\n- 如果 $A_{4}=1$ 且 $B_{4}=0$（即 $A_{4}\\cdot \\overline{B_{4}}$），则无论低位如何，$AB$。因此 $G_{out}=1$，$E_{out}=0$，$L_{out}=0$。\n- 如果 $A_{4}=0$ 且 $B_{4}=1$（即 $\\overline{A_{4}}\\cdot B_{4}$），则无论低位如何，$AB$。因此 $L_{out}=1$，$E_{out}=0$，$G_{out}=0$。\n- 如果 $A_{4}=B_{4}$（即 $\\overline{A_{4}\\oplus B_{4}}$），则比较结果取决于低4位比较的输出：$G_{in}$、$E_{in}$、$L_{in}$。\n\n从这些情况出发，通过将互斥条件进行“或”运算，并用最高有效位相等的条件来门控低位结果，来构建布尔表达式：\n- 大于输出：\n$$\nG_{out}=\\left(A_{4}\\cdot \\overline{B_{4}}\\right)+\\left(\\overline{A_{4}\\oplus B_{4}}\\right)\\cdot G_{in}.\n$$\n- 等于输出：\n$$\nE_{out}=\\left(\\overline{A_{4}\\oplus B_{4}}\\right)\\cdot E_{in}.\n$$\n- 小于输出：\n$$\nL_{out}=\\left(\\overline{A_{4}}\\cdot B_{4}\\right)+\\left(\\overline{A_{4}\\oplus B_{4}}\\right)\\cdot L_{in}.\n$$\n\n这些表达式与选项C匹配，并正确地确保了当最高有效位不同时，由最高有效位决定结果；当最高有效位相等时，由低4位比较器决定结果。", "answer": "$$\\boxed{C}$$", "id": "1919823"}, {"introduction": "理论知识最终需要转化为实际的硬件实现。在现代数字设计中，这通常通过硬件描述语言（HDL）如Verilog来完成。本练习将引导你为2位数值比较器编写行为级Verilog代码，将抽象的逻辑功能转化为可综合的具体描述。这个实践不仅能锻炼你的HDL编程能力，还能让你掌握实现组合逻辑时的关键技巧，例如如何避免产生意想不到的锁存器。[@problem_id:1945508]", "problem": "您的任务是使用行为级Verilog设计一个2位数值比较器。该比较器模块名为`magnitude_comparator_2bit`，它有两个2位输入 $A$ 和 $B$，以及三个1位输出：$A\\_gt\\_B$（当 $A  B$ 时置为高电平）、$A\\_lt\\_B$（当 $A  B$ 时置为高电平）和 $A\\_eq\\_B$（当 $A = B$ 时置为高电平）。该模块的端口声明如下：\n\n`input wire [1:0] A, B;`\n`output reg A_gt_B, A_lt_B, A_eq_B;`\n\n以下哪个 `always` 块正确地实现了该比较器所需的组合逻辑，并确保电路行为正确且不会综合出意外的锁存器？\n\nA.\n```verilog\nalways @(*) begin\n  if (A > B) begin\n    A_gt_B = 1'b1;\n  end else if (A  B) begin\n    A_lt_B = 1'b1;\n  end else begin // A == B\n    A_eq_B = 1'b1;\n  end\nend\n```\n\nB.\n```verilog\nalways @(A) begin\n  if (A > B) begin\n    A_gt_B = 1'b1;\n    A_lt_B = 1'b0;\n    A_eq_B = 1'b0;\n  end else if (A  B) begin\n    A_gt_B = 1'b0;\n    A_lt_B = 1'b1;\n    A_eq_B = 1'b0;\n  end else begin // A == B\n    A_gt_B = 1'b0;\n    A_lt_B = 1'b0;\n    A_eq_B = 1'b1;\n  end\nend\n```\n\nC.\n```verilog\nalways @(*) begin\n  if (A > B) begin\n    A_gt_B = 1'b1;\n    A_lt_B = 1'b0;\n    A_eq_B = 1'b0;\n  end else if (A == B) begin\n    A_gt_B = 1'b0;\n    A_lt_B = 1'b1;\n    A_eq_B = 1'b0;\n  end else begin // A  B\n    A_gt_B = 1'b0;\n    A_lt_B = 1'b0;\n    A_eq_B = 1'b1;\n  end\nend\n```\n\nD.\n```verilog\nalways @(*) begin\n  if (A > B) begin\n    A_gt_B = 1'b1;\n    A_lt_B = 1'b0;\n    A_eq_B = 1'b0;\n  end else if (A  B) begin\n    A_gt_B = 1'b0;\n    A_lt_B = 1'b1;\n    A_eq_B = 1'b0;\n  end else begin // A == B\n    A_gt_B = 1'b0;\n    A_lt_B = 1'b0;\n    A_eq_B = 1'b1;\n  end\nend\n```", "solution": "我们需要一个组合逻辑的2位数值比较器。在Verilog行为级风格中，一个正确的组合逻辑 `always` 块必须满足两个关键条件：\n- 组合逻辑需要一个完整的敏感列表，最好通过使用 `always @(*)` 来保证，这样每当任何右侧信号变化时，该块都会重新求值。\n- 所有的输出都必须在每个控制路径中被赋值，以避免产生意外的锁存器。如果在某个控制路径中任何输出未被赋值，综合工具会为该信号推断出存储单元。\n\n根据这些规则和预期的功能来评估每个选项：\n- 选项A使用了 `always @(*)`，这对于组合逻辑是很好的。然而，在每个分支中，它只对一个输出进行赋值，而让另外两个输出未被赋值。在组合逻辑的 `always` 块中，在某些路径上不给输出赋值会导致这些输出保持其先前的值，从而推断出锁存器。因此，A是错误的。\n- 选项B在每个分支中都对所有三个输出进行了赋值，从而避免了锁存器。但是，其敏感列表是 `always @(A)`，忽略了 `B`。这会导致仿真中的行为不正确（当 `B` 改变时输出不会更新），也不符合正确的组合逻辑编码实践。因此，B是错误的。\n- 选项C使用了 `always @(*)`，并在每个分支中对所有输出进行了赋值，从而避免了锁存器。但是，其功能逻辑是错误的：在 `A == B` 的分支中，它置位了 `A_lt_B` 而不是 `A_eq_B`；在 `else` 分支（对应于 `A  B`）中，它置位了 `A_eq_B` 而不是 `A_lt_B`。因此，C的功能是错误的。\n- 选项D使用了 `always @(*)`，在每个分支中都对所有三个输出进行了赋值，并且条件和置位的输出与预期的比较器功能相匹配：`A  B` 只将 `A_gt_B` 置为高电平；`A  B` 只将 `A_lt_B` 置为高电平；`A == B` 只将 `A_eq_B` 置为高电平。因此，D是正确的，并且可以综合成所需的组合逻辑，而不会产生意外的锁存器。\n\n关于选项中使用的非阻塞赋值（`=`），虽然通常建议在纯组合逻辑的 `always` 块中使用阻塞赋值（`=`）来模拟组合行为并避免混合使用块时出现竞争条件，但只要在每个路径中都对所有输出进行了赋值并且敏感列表是完整的，在这里使用非阻塞赋值本身并不会推断出锁存器。因此，D仍然是可以接受的。", "answer": "$$\\boxed{D}$$", "id": "1945508"}]}