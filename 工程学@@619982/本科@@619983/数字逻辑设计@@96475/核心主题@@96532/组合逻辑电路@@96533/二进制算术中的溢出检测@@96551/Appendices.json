{"hands_on_practices": [{"introduction": "理论是基础，但真正的掌握来自于实践。本节的第一个练习将带你进入二进制溢出的核心。我们将通过一个具体的场景，即在一个位数有限的处理器中进行加法运算，来检验你是否能准确判断运算结果何时会超出其表示范围。这项练习旨在巩固你对溢出基本条件的理解，即两个相同符号的数相加，其结果的符号却与之相反时，溢出便发生了。[@problem_id:1950184]", "problem": "一个简单的处理器核心被设计用于处理传感器数据。它专门使用5位有符号整数进行运算，采用二进制补码表示法。在此系统中，可表示的数字范围是从 $-16$ 到 $+15$。该核心的算术逻辑单元 (ALU) 对两个5位操作数 $A$ 和 $B$ 执行加法运算。如果加法的真实结果超出了可表示范围，则会发生溢出。\n\n现提供几对以十进制值指定的操作数 $(A, B)$。您的任务是确定在以下加法运算 $A + B$ 中，哪一个会在这个5位二进制补码系统中导致溢出。\n\nA) $A = 12, B = -5$\n\nB) $A = -8, B = -7$\n\nC) $A = 9, B = 6$\n\nD) $A = 10, B = 6$\n\nE) $A = -15, B = 15$", "solution": "在一个字长为 $n$ 的二进制补码系统中，可表示的范围是从 $-2^{n-1}$ 到 $2^{n-1}-1$。对于 $n=5$，该范围是\n$$\n[-2^{4},\\,2^{4}-1]=[-16,\\,15].\n$$\n当真实整数和 $r=A+B$ 位于此区间之外时，加法会发生溢出。等效地，溢出只可能发生在两个同符号操作数相加时，其结果的量值超出了可表示的界限，这表现为结果的符号与操作数的符号不同。\n\n通过计算真实和并与该区间进行比较来评估每个选项：\n- A) $12+(-5)=7$，符号相反且 $7\\in[-16,15]$；无溢出。\n- B) $-8+(-7)=-15$，均为负数且 $-15\\in[-16,15]$；无溢出。\n- C) $9+6=15$，均为正数且 $15\\in[-16,15]$；无溢出。\n- D) $10+6=16$，均为正数且 $16\\notin[-16,15]$；发生溢出。\n- E) $-15+15=0$，符号相反且 $0\\in[-16,15]$；无溢出。\n\n因此，只有选项 D 会导致溢出。", "answer": "$$\\boxed{D}$$", "id": "1950184"}, {"introduction": "溢出不仅仅发生在两个数相加时，在其他算术运算中也可能出现。这个练习将引导你探索一个在二的补码运算中至关重要的边界情况：对可表示的最负数进行求反操作。通过分析一个假设的8位处理器的求反操作，你将发现为何对这个特定数值进行求反会导致溢出，这个思想实验揭示了补码表示范围的不对称性，并加深了你对标准求反算法（先按位取反，再加一）在极端情况下如何表现的理解。[@problem_id:1950207]", "problem": "一个数字信号处理器使用 8 位架构来执行有符号整数的算术运算。这些整数使用二进制补码格式表示。该处理器可以执行的基本运算之一是求反，其实现方式是首先将数字的所有位取反（按位非运算），然后将结果加 1。\n\n如果运算结果是一个超出 8 位二进制补码系统可表示范围的数，就会发生算术溢出。恰好有一个 8 位有符号整数，对其进行求反运算会导致溢出。\n\n从下面提供的 8 位二进制数列表中，找出对其应用二进制补码求反运算时会导致溢出的那个数。\n\nA. `0000 0000`\n\nB. `0111 1111`\n\nC. `1000 0000`\n\nD. `1111 1111`\n\nE. `1000 0001`", "solution": "在一个 $n$ 位二进制补码系统中，可表示的整数范围恰好是 $[-2^{n-1},\\,2^{n-1}-1]$。对于 $n=8$，该范围是 $[-2^{7},\\,2^{7}-1]=[-128,\\,127]$。\n\n二进制补码求反的实现方式是按位非运算后加 $1$，这对应于模 $2^{8}$ 的加法：\n$$\n\\operatorname{neg}(x) \\equiv \\operatorname{NOT}(x)+1 \\pmod{2^{8}}.\n$$\n求反运算的溢出恰好发生在当真实的数学结果 $-x$ 不在可表示范围内时。在 8 位二进制补码范围内，唯一一个其 $-x$ 不可表示的 $x$ 是 $x=-2^{7}=-128$，因为 $-(-2^{7})=2^{7}=128$，这超出了 $2^{7}-1=127$。\n\n$-128$ 的 8 位二进制补码编码是在最高有效位为 $1$、其余位为零的模式，即 $1000\\,0000$。应用求反算法：\n$$\n\\operatorname{NOT}(1000\\,0000)=0111\\,1111,\\quad 0111\\,1111+1=1000\\,0000,\n$$\n其结果回绕到相同的位模式，这表明发生了溢出，因为真正的结果应该是 $+128$，而这个数是无法表示的。\n\n在这些选项中：\n- $0000\\,0000$ 代表 $0$，其相反数是 $0$（没有溢出）。\n- $0111\\,1111$ 代表 $127$，其相反数是 $-127$（可表示）。\n- $1111\\,1111$ 代表 $-1$，其相反数是 $1$（可表示）。\n- $1000\\,0001$ 代表 $-127$，其相反数是 $127$（可表示）。\n只有 $1000\\,0000$ 对应于 $-128$，在求反时会引起溢出。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1950207"}, {"introduction": "从识别溢出到设计一个能自动检测溢出的系统，是理论到工程的关键一步。这个高级练习要求你设计一个有限状态机（FSM），使其与一个串行加法器协同工作，以实时检测溢出。通过为这个Mealy型有限状态机指定状态转换和输出，你将把抽象的溢出检测规则，即最高有效位的进位输入 $c_{n-1}$ 和进位输出 $c_n$ 的异或 $V = c_{n-1} \\oplus c_n$，转化为具体的硬件逻辑。这个练习将极大地提升你对计算机算术和数字逻辑设计之间联系的认识。[@problem_id:1950178]", "problem": "一个专用的、资源受限的处理器设计有一个串行算术逻辑单元 (ALU)。该ALU对两个以二进制补码格式表示的$n$位整数$A$和$B$进行操作。这两个数从最低有效位 (LSB) 开始逐位处理。在每个时钟周期 $i$（从 LSB 的 $i=0$ 到最高有效位 MSB 的 $i=n-1$），ALU 的 1 位全加器接收输入位 $a_i$ 和 $b_i$，以及来自前一级的输入进位 $c_i$，并计算出一个和位 $s_i$ 和一个输出进位 $c_{i+1}$。对于第一级，输入进位 $c_0$ 为 0。\n\n您的任务是指定一个与全加器协同工作以检测算术溢出的 Mealy 型有限状态机 (FSM) 的行为。该 FSM 必须生成一个单比特输出 $V$。在对应于 MSB（$i=n-1$）的时钟周期，$V$ 的值必须为 1（如果 $n$ 位加法过程中发生了溢出），否则为 0。FSM 的状态转换与每对比特位的处理同步。\n\n该 FSM 有两个状态：\n-   $S_0$：表示到当前位片的输入进位 $c_i$ 为 0 的情况。\n-   $S_1$：表示到当前位片的输入进位 $c_i$ 为 1 的情况。\n\n在周期 $i$ 时，FSM 的输入是数据位 $a_i$ 和 $b_i$。FSM 以状态 $S_0$ 开始。\n\n以下哪个状态转换和输出表正确描述了此用于溢出检测的 Mealy FSM？\n\nA.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_1$     |        0       |\n|      $S_1$      |        10         |    $S_1$     |        0       |\n|      $S_1$      |        11         |    $S_1$     |        0       |\n\nB.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        0       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_1$     |        1       |\n|      $S_1$      |        10         |    $S_1$     |        1       |\n|      $S_1$      |        11         |    $S_1$     |        1       |\n\nC.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        0       |\n|      $S_0$      |        01         |    $S_0$     |        0       |\n|      $S_0$      |        10         |    $S_0$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        0       |\n|      $S_1$      |        01         |    $S_1$     |        1       |\n|      $S_1$      |        10         |    $S_1$     |        1       |\n|      $S_1$      |        11         |    $S_1$     |        1       |\n\nD.\n| 当前状态 | 输入 ($a_i, b_i$) | 下一状态 | 输出 ($V_i$) |\n|:-------------:|:-----------------:|:----------:|:--------------:|\n|      $S_0$      |        00         |    $S_0$     |        1       |\n|      $S_0$      |        01         |    $S_1$     |        0       |\n|      $S_0$      |        10         |    $S_1$     |        0       |\n|      $S_0$      |        11         |    $S_1$     |        1       |\n|      $S_1$      |        00         |    $S_0$     |        1       |\n|      $S_1$      |        01         |    $S_0$     |        0       |\n|      $S_1$      |        10         |    $S_0$     |        0       |\n|      $S_1$      |        11         |    $S_1$     |        1       |", "solution": "我们每个周期使用一个 1 位全加器串行地相加两个二进制补码数。让 FSM 的状态编码到当前位片的输入进位：$S_{0}$ 表示 $c_{i}=0$，$S_{1}$ 表示 $c_{i}=1$。全加器的输出进位是\n$$\nc_{i+1}=a_{i}b_{i}+a_{i}c_{i}+b_{i}c_{i}.\n$$\n因此，下一状态函数由 $c_{i+1}$ 决定：\n- 如果 $c_{i}=0$（状态 $S_{0}$），则 $c_{i+1}=a_{i}b_{i}$。因此，从 $S_{0}$ 出发，只有当 $(a_{i},b_{i})=(1,1)$ 时，下一状态才是 $S_{1}$；否则它保持在 $S_{0}$。\n- 如果 $c_{i}=1$（状态 $S_{1}$），则 $c_{i+1}=a_{i}+b_{i}$（逻辑或）。因此，从 $S_{1}$ 出发，只有当 $(a_{i},b_{i})=(0,0)$ 时，下一状态才是 $S_{0}$；否则它保持在 $S_{1}$。\n\n在二进制补码加法中，MSB 处的溢出标志满足\n$$\nV_{n-1}=c_{n-1}\\oplus c_{n}.\n$$\n一个 Mealy FSM 可以在周期 $i$ 使用\n$$\nV_{i}=c_{i}\\oplus c_{i+1},\n$$\n来生成这个标志，因为 $c_{i+1}$ 是当前状态和输入的函数。\n\n根据状态和输入计算输出：\n- 对于 $S_{0}$ ($c_{i}=0$)：$V_{i}=0\\oplus c_{i+1}=c_{i+1}=a_{i}b_{i}$。因此，当 $(a_{i},b_{i})$ 分别等于 $00,01,10,11$ 时，产生的 $V_{i}$ 分别为 $0,0,0,1$。\n- 对于 $S_{1}$ ($c_{i}=1$)：$V_{i}=1\\oplus c_{i+1}=1\\oplus(a_{i}+b_{i})$。因此，当 $(a_{i},b_{i})$ 分别等于 $00,01,10,11$ 时，产生的 $V_{i}$ 分别为 $1,0,0,0$。\n\n将推导出的下一状态和输出行为相结合，与选项 A 中的表格完全匹配，而与其他选项（其输出和/或转换不正确）不同。", "answer": "$$\\boxed{A}$$", "id": "1950178"}]}