{"hands_on_practices": [{"introduction": "验证工作中的一个常见陷阱是编写了看起来很全面但实际上遗漏了关键角落案例的测试。这个练习将让你分析一个为基本同步寄存器编写的测试平台，你的任务是找出它*未能*验证的行为。通过这个实践，你将锻炼评估测试覆盖率的思维，确保设计的所有操作模式（如复位、加载和保持）都得到了有效检验。[@problem_id:1966472]", "problem": "一位工程师正在为一个4位同步寄存器设计一个测试平台（testbench）。该寄存器是待测设备（DUT），具有以下特性：\n- 它有一个4位数据输入 `d_in`，一个4位数据输出 `q_out`，一个时钟输入 `clk`，一个低电平有效同步复位输入 `rst_n`，以及一个并行加载使能输入 `load_en`。\n- 在时钟 `clk` 的上升沿：\n    1. 如果 `rst_n` 是逻辑 `0`，输出 `q_out` 被复位为 `4'b0000`。\n    2. 如果 `rst_n` 是逻辑 `1` 且 `load_en` 是逻辑 `1`，输出 `q_out` 将取输入 `d_in` 的值。\n    3. 如果 `rst_n` 是逻辑 `1` 且 `load_en` 是逻辑 `0`，输出 `q_out` 保持其当前值。\n\n工程师编写了以下 Verilog 测试平台代码来验证寄存器的功能。请分析该测试平台并确定寄存器的哪一个特定行为**没有**被此仿真序列所验证。\n\n```verilog\n// DUT module (provided for context, not to be modified)\nmodule register_4bit (\n    input clk,\n    input rst_n,\n    input load_en,\n    input [3:0] d_in,\n    output reg [3:0] q_out\n);\n    always @(posedge clk) begin\n        if (!rst_n) begin\n            q_out <= 4'b0000;\n        end else if (load_en) begin\n            q_out <= d_in;\n        end\n    end\nendmodule\n\n// Testbench module\nmodule tb_register_4bit;\n    // Signal declarations\n    reg clk;\n    reg rst_n;\n    reg load_en;\n    reg [3:0] d_in;\n    wire [3:0] q_out;\n\n    // Instantiate the DUT\n    register_4bit dut (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load_en(load_en),\n        .d_in(d_in),\n        .q_out(q_out)\n    );\n\n    // Clock generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // 10-unit period clock\n    end\n\n    // Test sequence\n    initial begin\n        // Initial state\n        rst_n = 1;\n        load_en = 0;\n        d_in = 4'b0000;\n\n        // Apply reset\n        #10;\n        rst_n = 0;\n\n        // Release reset\n        #10;\n        rst_n = 1;\n\n        // Load first value\n        #10;\n        load_en = 1;\n        d_in = 4'b1010;\n\n        // Load second value\n        #10;\n        d_in = 4'b0101;\n\n        // End simulation\n        #10;\n        $finish;\n    end\nendmodule\n```\n\n以下哪种行为**未**被提供的 `tb_register_4bit` 模块测试？\n\nA. 当低电平有效复位被置为有效时，寄存器正确地复位为全零。\nB. 当加载使能信号为低电平时，寄存器保持其先前的值。\nC. 当加载使能为高电平时，寄存器在时钟上升沿从输入端加载新数据。\nD. 连续的多次数据加载被正确执行。", "solution": "从 `always` 块中确定相关的 DUT 行为：在每个 $clk$ 的上升沿，如果 $rst\\_n=0$ 则 $q\\_out \\leftarrow 4'b0000$；否则如果 $load\\_en=1$ 则 $q\\_out \\leftarrow d\\_in$；否则，没有对 $q\\_out$ 的赋值，因此寄存器保持其先前的值。测试平台驱动以下时间线：时钟周期为 $10$ 个单位，上升沿出现在 $t=5,15,25,35,45,\\dots$。\n\n在 $t=0$ 时，初始条件为 $clk=0$，$rst\\_n=1$，$load\\_en=0$ 和 $d\\_in=4'b0000$。第一个上升沿出现在 $t=5$，此时 $rst\\_n=1$ 且 $load\\_en=0$，因此根据 DUT 逻辑，没有赋值发生，寄存器保持其（未知的）上电初始值。\n\n在 $t=10$ 时，测试平台置位复位：$rst\\_n \\leftarrow 0$。在下一个上升沿 $t=15$ 时，条件 $!rst\\_n=1$ 满足，因此 DUT 设置 $q\\_out \\leftarrow 4'b0000$。这验证了复位行为，从而测试了选项 A。\n\n在 $t=20$ 时，测试平台撤销复位：$rst\\_n \\leftarrow 1$。在下一个上升沿 $t=25$ 时，此时 $rst\\_n=1$ 且 $load\\_en=0$，因此没有赋值发生，寄存器保持其当前值，即 $4'b0000$。尽管这个周期与保持行为一致，但它并不能证明当 $load\\_en=0$ 时寄存器能够抵抗新数据的变化，因为 $d\\_in$ 并未改变，从而在 $d\\_in$ 和 $q\\_out$ 之间产生潜在的差异。因此，没有明确验证当 $load\\_en=0$ 时寄存器会保持一个非零或先前加载的值，也没有在 $load\\_en=0$ 的情况下改变 $d\\_in$ 的测试。\n\n在 $t=30$ 时，测试平台设置 $load\\_en \\leftarrow 1$ 和 $d\\_in \\leftarrow 4'b1010$。在下一个上升沿 $t=35$ 时，此时 $rst\\_n=1$ 且 $load\\_en=1$，因此 DUT 加载 $q\\_out \\leftarrow 4'b1010$，验证了在使能时新数据会在上升沿加载，从而测试了选项 C。\n\n在 $t=40$ 时，测试平台在保持 $load\\_en=1$ 的同时改变 $d\\_in \\leftarrow 4'b0101$。在下一个上升沿 $t=45$ 时，再次有 $rst\\_n=1$ 和 $load\\_en=1$，因此 DUT 加载 $q\\_out \\leftarrow 4'b0101$。这展示了在 $load\\_en$ 保持为高电平的情况下，在连续的上升沿上进行了两次连续加载，从而测试了选项 D。\n\n总结哪些行为得到了真正的测试：\n- A 在 $t=15$ 时被测试。\n- C 在 $t=35$ 时被测试。\n- D 在 $t=35$ 加载之后，于 $t=45$ 时被测试。\n- B 没有被明确测试，因为在任何非零或非复位值出现后，测试平台从未设置 $load\\_en=0$ 并在改变 $d\\_in$ 的同时观察一个时钟沿来确认 $q\\_out$ 是否保持不变。唯一一个在 $rst\\_n=1$ 条件下 $load\\_en=0$ 的周期是在 $t=25$ 时，紧跟在复位之后，此时无论如何 $q\\_out$ 都保持为 $4'b0000$，这并没有为任意存储值的保持行为提供明确的验证。\n\n因此，未被测试的行为是：当 $load\\_en$ 为低电平时，寄存器保持其先前的值。", "answer": "$$\\boxed{B}$$", "id": "1966472"}, {"introduction": "在验证了基本功能覆盖率之后，下一步是为特定的关键行为（例如算术溢出）设计精确的测试向量。本练习要求你为一个4位有符号加法器选择一组最有效的测试用例，以验证其 `overflow` 溢出检测逻辑的正确性。此实践旨在强调，设计激励 (stimulus) 必须基于底层操作的理论（在此即二进制补码算术），才能有效地捕捉到设计中潜在的细微错误。[@problem_id:1966509]", "problem": "你的任务是验证一个4位有符号加法器模块，该模块旨在对两个用补码表示的4位有符号数执行加法运算。一个4位有符号整数的有效范围是从-8到+7。\n\n用于该加法器的Verilog模块，即你的待测设计（DUT），定义如下：\n\n```verilog\nmodule signed_adder_4bit(\n    input signed [3:0] a,\n    input signed [3:0] b,\n    output signed [3:0] sum,\n    output overflow\n);\n\n    // Internal 5-bit calculation to detect overflow\n    wire signed [4:0] extended_sum;\n    assign extended_sum = {a[3], a} + {b[3], b};\n\n    // The sum is the lower 4 bits\n    assign sum = extended_sum[3:0];\n\n    // Overflow occurs if the sign of the result is different from the (common) sign of the inputs\n    // This can be simplified by checking if the sign of the sum (bit 3) is different\n    // from the carry-in to the sign bit (which is extended_sum[4]).\n    assign overflow = extended_sum[4] ^ extended_sum[3];\n\nendmodule\n```\n\n你的目标是编写一个测试平台（testbench），以充分验证 `overflow` 信号。一个有效的测试平台必须检查导致正溢出（两个正数之和为负数）、负溢出（两个负数之和为正数）的条件，以及至少一个不发生溢出的情况。\n\n以下哪个Verilog `initial` 块，在用于 `signed_adder_4bit` 模块的测试平台时，能提供最有效的一组测试向量来验证 `overflow` 信号在所有相关有符号加法场景下的正确性？\n\nA.\n```verilog\ninitial begin\n    // Case 1: Positive Overflow (5 + 4 = 9)\n    a = 4'b0101; b = 4'b0100; #10;\n    if (overflow !== 1) $display(\"Test Failed for 5+4\");\n\n    // Case 2: Negative Overflow (-5 + -4 = -9)\n    a = 4'b1011; b = 4'b1100; #10;\n    if (overflow !== 1) $display(\"Test Failed for -5 + -4\");\n\n    // Case 3: No Overflow (2 + -2 = 0)\n    a = 4'b0010; b = 4'b1110; #10;\n    if (overflow !== 0) $display(\"Test Failed for 2 + -2\");\n\n    $finish;\nend\n```\n\nB.\n```verilog\ninitial begin\n    // Case 1: No Overflow (2 + 3 = 5)\n    a = 4'b0010; b = 4'b0011; #10;\n    if (overflow !== 0) $display(\"Test Failed for 2+3\");\n\n    // Case 2: No Overflow (-2 + -3 = -5)\n    a = 4'b1110; b = 4'b1101; #10;\n    if (overflow !== 0) $display(\"Test Failed for -2 + -3\");\n\n    // Case 3: No Overflow (3 + -3 = 0)\n    a = 4'b0011; b = 4'b1101; #10;\n    if (overflow !== 0) $display(\"Test Failed for 3 + -3\");\n\n    $finish;\nend\n```\n\nC.\n```verilog\ninitial begin\n    // Case 1: Positive Overflow (6 + 3 = 9)\n    a = 4'b0110; b = 4'b0011; #10;\n    if (overflow !== 1) $display(\"Test Failed for 6+3\");\n\n    // Case 2: No Overflow (5 + 2 = 7)\n    a = 4'b0101; b = 4'b0010; #10;\n    if (overflow !== 0) $display(\"Test Failed for 5+2\");\n\n    $finish;\nend\n```\n\nD.\n```verilog\ninitial begin\n    // Case 1: Positive Overflow (7 + 7 = 14)\n    a = 4'b0111; b = 4'b0111; #10;\n    if (overflow !== 1) $display(\"Test Failed for 7+7\");\n\n    // Case 2: Mixed Sign \"Overflow\" (-6 + 7 = 1)\n    a = 4'b1010; b = 4'b0111; #10;\n    if (overflow !== 1) $display(\"Test Failed for -6+7\");\n\n    $finish;\nend\n```\n\nE.\n```verilog\ninitial begin\n    // Case 1: Negative Overflow (-8 + -8 = -16)\n    a = 4'b1000; b = 4'b1000; #10;\n    if (overflow !== 1) $display(\"Test Failed for -8 + -8\");\n\n    // Case 2: Mixed Sign \"Overflow\" (7 + -8 = -1)\n    a = 4'b0111; b = 4'b1000; #10;\n    if (overflow !== 1) $display(\"Test Failed for 7 + -8\");\n    \n    $finish;\nend\n```", "solution": "该问题要求我们确定最有效的测试平台代码片段，以验证一个4位有符号加法器的 `overflow` 信号。一个有效的测试平台必须检查 `overflow` 信号应为高电平或低电平的所有条件。对于有符号补码运算，溢出有特定的规则。\n\n**步骤1：理解补码中的有符号溢出**\n\n对于一个4位系统，可表示的数字范围是从-8（$4'b1000$）到+7（$4'b0111$）。最高有效位（MSB），即第3位，是符号位（0代表正数，1代表负数）。\n\n只有当两个同符号数相加，且结果的符号与操作数符号不同时，才会发生溢出。\n1.  **正溢出**：当两个正数相加而结果看起来是负数时发生。两个操作数的符号位均为0，但和的符号位为1。\n2.  **负溢出**：当两个负数相加而结果看起来是正数时发生。两个操作数的符号位均为1，但和的符号位为0。\n3.  **无溢出**：一个正数和一个负数相加*永远不会*导致溢出，因为和的绝对值将总是小于或等于两个操作数中绝对值较大的那个。\n\n**步骤2：分析每个选项**\n\n我们将评估每个`initial`块，看它是否正确地测试了这些条件。\n\n*   **选项A：**\n    *   **测试1**：`a = 4'b0101` (+5)，`b = 4'b0100` (+4)。预期和为+9，超出了[-8, 7]的范围。二进制加法为 `0101 + 0100 = 1001`。结果 `1001` 的符号位为1，表示一个负数（在补码中为-7）。这是一个典型的**正溢出**情况（正数 + 正数 = 负数）。测试正确地断言 `overflow` 应该为1。\n    *   **测试2**：`a = 4'b1011` (-5)，`b = 4'b1100` (-4)。预期和为-9，超出了范围。二进制加法为 `1011 + 1100 = (1)0111`。4位结果是 `0111`，其符号位为0，表示一个正数（在补码中为+7）。这是一个典型的**负溢出**情况（负数 + 负数 = 正数）。测试正确地断言 `overflow` 应该为1。\n    *   **测试3**：`a = 4'b0010` (+2)，`b = 4'b1110` (-2)。一个正数和一个负数相加。不会发生溢出。和为0。测试正确地断言 `overflow` 应该为0。\n    *   **结论**：这个选项正确地测试了正溢出、负溢出和一个非溢出情况。它是一个全面而有效的测试套件。\n\n*   **选项B：**\n    *   这个选项测试了 `2+3`、`-2 + -3` 和 `3 + -3`。所有这些和（`5`、`-5`、`0`）都在有效范围[-8, 7]之内。因此，这些情况都不会产生溢出。这个测试平台只验证了在非溢出情况下 `overflow` 标志为0。它没有检查电路是否能正确检测到实际的溢出。这是一个不充分的测试。\n\n*   **选项C：**\n    *   **测试1**：`a = 4'b0110` (+6)，`b = 4'b0011` (+3)。和为+9，超出了范围。`0110 + 0011 = 1001`。这是一个**正溢出**。测试正确地检查 `overflow === 1`。\n    *   **测试2**：`a = 4'b0101` (+5)，`b = 4'b0010` (+2)。和为+7，是最大正值并且在范围内。`0101 + 0010 = 0111`。没有溢出。测试正确地检查 `overflow === 0`。\n    *   **结论**：这个选项测试了正溢出，但完全忽略了对负溢出的任何测试。因此，它是不完整的。\n\n*   **选项D：**\n    *   **测试1**：`a = 4'b0111` (+7)，`b = 4'b0111` (+7)。和为+14。`0111 + 0111 = 1110`。这是一个**正溢出**。测试正确地检查 `overflow === 1`。\n    *   **测试2**：`a = 4'b1010` (-6)，`b = 4'b0111` (+7)。这是一个负数和正数的加法。如前所述，这**不可能**导致有符号溢出。和为+1，是正确的。然而，测试断言 `overflow` 应该为1（`if (overflow !== 1) ...`）。这个测试用例存在根本性缺陷，因为它在一个不应发生溢出的地方期望溢出。\n\n*   **选项E：**\n    *   **测试1**：`a = 4'b1000` (-8)，`b = 4'b1000` (-8)。和为-16。`1000 + 1000 = (1)0000`。这是一个**负溢出**。测试正确地检查 `overflow === 1`。\n    *   **测试2**：`a = 4'b0111` (+7)，`b = 4'b1000` (-8)。这是一个正数和负数的加法，**不可能**导致有符号溢出。和为-1。然而，测试断言 `overflow` 应该为1（`if (overflow !== 1) ...`）。与选项D一样，这个测试用例是有缺陷的。\n\n**步骤3：最终决定**\n\n只有选项A提供了一组测试向量，其断言正确且覆盖全面，按要求测试了正溢出、负溢出和非溢出场景，从而可以对 `overflow` 信号进行有效验证。", "answer": "$$\\boxed{A}$$", "id": "1966509"}, {"introduction": "现在，让我们将注意力转向一个更复杂的系统级组件：先进先出（FIFO）存储器。这项实践需要你分析一个产生持续读写“脉冲串”（bursts）的测试平台，并在此过程中跟踪 FIFO 在多个时钟周期内的状态。本练习的目标是理解被测设计（DUT）的状态信号（如 `full` 和 `empty`）如何与测试激励互动并影响系统行为，这是验证复杂设计时的一项核心技能。[@problem_id:1966501]", "problem": "一个数字系统包含一个用于缓冲数据的同步先进先出（FIFO）存储器。本题要求分析该FIFO在特定测试平台激励协议下的行为。\n\n该FIFO具有以下特性：\n- 它的固定存储容量（或深度）为 $D = 32$ 个字。\n- 它由一个时钟 `clk`、一个写使能信号 `wr_en` 和一个读使能信号 `rd_en` 控制。\n- 它提供两个状态标志：`full`（当FIFO包含 $D$ 个字时为高电平）和 `empty`（当FIFO包含 0 个字时为高电平）。\n- FIFO和测试平台的所有状态更新都发生在 `clk` 的上升沿。\n- `full` 和 `empty` 标志根据FIFO的内部字数通过组合逻辑更新，并在字数变化的同一时钟周期内即可用。\n- 如果在时钟上升沿 `wr_en` 为高电平且 `full` 标志为低电平，则写操作成功。一次成功的写操作会使FIFO的内部字数加一。如果 `wr_en` 为高电平但 `full` 也为高电平，则写操作被忽略。\n- 如果在时钟上升沿 `rd_en` 为高电平且 `empty` 标志为低电平，则读操作成功。一次成功的读操作会使FIFO的内部字数减一。如果 `rd_en` 为高电平但 `empty` 也为高电平，则读操作被忽略。\n\n测试平台运行一个状态机，根据以下规则生成激励：\n- 系统在时间 $t=0$ 时复位。在第一个时钟上升沿（周期1），测试平台进入 `WRITE_BURST` 状态。\n- 测试平台使用一个固定的整数序列 $L = [40, 35, 20, 50, 15]$ 来确定每次突发操作的持续时间。列表中的整数按顺序被消耗。\n- 在 `WRITE_BURST` 状态下，测试平台从列表 $L$ 中消耗下一个整数 $N_w$。然后，它将 `wr_en` 置为高电平，`rd_en` 置为低电平，持续 $N_w$ 个连续的时钟周期。这 $N_w$ 个周期后，它转换到 `READ_BURST` 状态。\n- 在 `READ_BURST` 状态下，测试平台从列表 $L$ 中消耗下一个整数 $N_r$。然后，它将 `rd_en` 置为高电平，`wr_en` 置为低电平，持续 $N_r$ 个连续的时钟周期。这 $N_r$ 个周期后，它转换到 `WRITE_BURST` 状态。\n- 测试平台的逻辑不检查 `full` 或 `empty` 标志来决定其状态转换或信号置位；它仅遵循由序列 $L$ 决定的周期计数。\n\n计算在恰好100个时钟周期过去后，成功写入FIFO的数据字总数。第一个时钟周期为周期1。", "solution": "设FIFO深度为 $D=32$。定义 $C(n)$ 为时钟周期 $n$ 结束时FIFO中的字数，定义 $W(n)$ 为截至并包括周期 $n$ 的成功写入累积总数。初始条件为\n$$\nC(0)=0,\\quad W(0)=0.\n$$\n每个上升沿的更新规则：\n- 如果 $wr\\_en=1$ 且 $C(n-1)<D$，则写操作成功：$C(n)=C(n-1)+1$ 且 $W(n)=W(n-1)+1$。如果 $C(n-1)=D$，则写操作被忽略：$C(n)=D$ 且 $W(n)=W(n-1)$。\n- 如果 $rd\\_en=1$ 且 $C(n-1)>0$，则读操作成功：$C(n)=C(n-1)-1$。如果 $C(n-1)=0$，则读操作被忽略：$C(n)=0$。在读突发期间 $wr\\_en=0$，所以 $W(n)$ 不变。\n\n周期1到100的突发操作安排由 $L=[40,35,20,50,15]$ 决定：\n- 周期1到40：长度为40的 `WRITE_BURST`。\n- 周期41到75：长度为35的 `READ_BURST`。\n- 周期76到95：长度为20的 `WRITE_BURST`。\n- 周期96到100：下一个 `READ_BURST` 的前5个周期。\n\n阶段1（周期1到40，仅写操作）：从 $C(0)=0$ 开始，成功写入的次数受限于 $D$。因此，在40个写尝试周期中，\n$$\n\\text{writes}=\\min(40,D)=32,\\quad C(40)=32,\\quad W(40)=32.\n$$\n阶段2（周期41到75，仅读操作）：从 $C(40)=32$ 开始，在周期41到72内，32次读操作成功，将FIFO清空。剩余的周期73到75被忽略。因此，\n$$\nC(75)=0,\\quad W(75)=W(40)=32.\n$$\n阶段3（周期76到95，仅写操作）：从空状态开始，由于 $20<D$，所有20次写尝试均成功，\n$$\n\\text{writes}=20,\\quad C(95)=20,\\quad W(95)=32+20=52.\n$$\n阶段4（周期96到100，仅读操作）：没有写操作发生，所以\n$$\nW(100)=W(95)=52.\n$$\n因此，在恰好100个时钟周期后，成功写入FIFO的数据字总数为52。", "answer": "$$\\boxed{52}$$", "id": "1966501"}]}