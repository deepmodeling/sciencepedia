{"hands_on_practices": [{"introduction": "动手实践是掌握Verilog行为级建模的唯一途径。让我们从一个经典的组合逻辑问题开始：汉明码生成器。这个练习的目标是将一组明确的数学公式（奇偶校验方程）直接转化为Verilog代码，这在数字通信和数据存储系统中是确保数据完整性的基本任务。通过这个实践 [@problem_id:1912766]，你将学习如何使用`always @*`块来实现纯组合逻辑，并精确地将数据位和计算出的校验位映射到指定的输出格式。", "problem": "你的任务是在 Verilog 中设计一个纯组合逻辑的 (7,4) 汉明码生成器电路。该电路输入一个 4 位数据字，并生成一个 7 位码字作为输出。\n\n输入是一个名为 `data_in[3:0]` 的 4 位向量。这四位对应于汉明码的数据部分，我们根据以下映射将其表示为 $d_4, d_3, d_2, d_1$：\n- $d_4 = \\text{data\\_in}[3]$\n- $d_3 = \\text{data\\_in}[2]$\n- $d_2 = \\text{data\\_in}[1]$\n- $d_1 = \\text{data\\_in}[0]$\n\n该电路必须根据以下标准校验方程计算三个偶校验位 $p_4, p_2, p_1$，其中 $\\oplus$ 表示按位异或 (XOR) 运算：\n- $p_1 = d_1 \\oplus d_2 \\oplus d_4$\n- $p_2 = d_1 \\oplus d_3 \\oplus d_4$\n- $p_4 = d_2 \\oplus d_3 \\oplus d_4$\n\n最终的 7 位输出 `hamming_out[6:0]` 必须通过将数据位和计算出的校验位按以下特定位置排列来构成：\n- `hamming_out[6]` = $d_4$\n- `hamming_out[5]` = $d_3$\n- `hamming_out[4]` = $d_2$\n- `hamming_out[3]` = $p_4$\n- `hamming_out[2]` = $d_1$\n- `hamming_out[1]` = $p_2$\n- `hamming_out[0]` = $p_1$\n\n根据这些规范，请确定下列哪个 Verilog 模块正确地实现了此汉明码生成器的行为模型。\n\nA.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Parity bits\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        // Data bits\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nB.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @(data_in[1], data_in[2]) begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nC.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] & data_in[2] & data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nD.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output [6:0] hamming_out\n);\n    always @* begin\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[1];\n        hamming_out[5] = data_in[2];\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```\n\nE.\n```verilog\nmodule hamming_encoder(\n    input [3:0] data_in,\n    output reg [6:0] hamming_out\n);\n    always @* begin\n        // Incorrect mapping of data bits to output\n        hamming_out[0] = data_in[0] ^ data_in[1] ^ data_in[3];\n        hamming_out[1] = data_in[0] ^ data_in[2] ^ data_in[3];\n        hamming_out[3] = data_in[1] ^ data_in[2] ^ data_in[3];\n        hamming_out[2] = data_in[0];\n        hamming_out[4] = data_in[2]; // Wrong\n        hamming_out[5] = data_in[1]; // Wrong\n        hamming_out[6] = data_in[3];\n    end\nendmodule\n```", "solution": "给定数据到符号的映射关系 $d_{4}=\\text{data\\_in}[3]$, $d_{3}=\\text{data\\_in}[2]$, $d_{2}=\\text{data\\_in}[1]$, $d_{1}=\\text{data\\_in}[0]$ 以及偶校验方程\n$$\np_{1}=d_{1}\\oplus d_{2}\\oplus d_{4},\\quad\np_{2}=d_{1}\\oplus d_{3}\\oplus d_{4},\\quad\np_{4}=d_{2}\\oplus d_{3}\\oplus d_{4}.\n$$\n用 `data_in` 的索引表示，它们变为\n$$\np_{1}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[1]\\oplus \\text{data\\_in}[3],\\quad\np_{2}=\\text{data\\_in}[0]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3],\\quad\np_{4}=\\text{data\\_in}[1]\\oplus \\text{data\\_in}[2]\\oplus \\text{data\\_in}[3].\n$$\n所要求的输出映射关系是\n$$\n\\text{hamming\\_out}[6]=d_{4}=\\text{data\\_in}[3],\\;\n\\text{hamming\\_out}[5]=d_{3}=\\text{data\\_in}[2],\\;\n\\text{hamming\\_out}[4]=d_{2}=\\text{data\\_in}[1],\\;\n\\text{hamming\\_out}[3]=p_{4},\\;\n\\text{hamming\\_out}[2]=d_{1}=\\text{data\\_in}[0],\\;\n\\text{hamming\\_out}[1]=p_{2},\\;\n\\text{hamming\\_out}[0]=p_{1}.\n$$\n现在逐一检查每个选项：\n\n- 选项 A 使用 `always @*` (组合逻辑)，使用异或 (XOR) 运算符精确地计算了 $p_{1}$、$p_{2}$、$p_{4}$，并完全按照要求将数据位分配给索引 $[2], [4], [5], [6]$。这同时满足了校验方程和位的布局，并且是纯组合逻辑的。因此 A 是正确的。\n\n- 选项 B 使用了不完整的敏感度列表 `always @(data_in[1], data_in[2])`。这遗漏了 $\\text{data\\_in}[0]$ 和 $\\text{data\\_in}[3]$，因此它在仿真中不能正确地模拟纯组合逻辑行为，尽管赋值语句本身与方程匹配。因此 B 作为一个行为模型是不正确的。\n\n- 选项 C 错误地使用了按位与 (AND) 运算符而不是异或 (XOR) 来计算 $p_{4}$。因此 C 是不正确的。\n\n- 选项 D 将输出声明为线网 (wire) 类型（隐式），但在 `always` 块内对其赋值，而这在 Verilog 中要求其类型为 `reg`。这不是一个正确的 Verilog 行为描述。因此 D 是不正确的。\n\n- 选项 E 交换了数据位 $\\text{hamming\\_out}[4]$ 和 $\\text{hamming\\_out}[5]$ 的位置，与要求的映射关系相矛盾。因此 E 是不正确的。\n\n因此，唯一正确的模块是 A。", "answer": "$$\\boxed{A}$$", "id": "1912766"}, {"introduction": "在掌握了基本的组合逻辑映射后，下一个挑战是实现迭代计算。这个问题——计算一个8位向量中“1”的个数（也称为“population count”）——就是一个很好的例子。这个练习 [@problem_id:1912788] 不仅考察了你使用`for`循环进行迭代计算的能力，更重要的是，它揭示了一个在硬件设计中极其常见的陷阱：位宽限制。通过分析这个看似简单的计数器，你将深刻理解寄存器位宽如何影响计算结果，以及为什么在设计时必须警惕潜在的溢出问题。", "problem": "在开发数字通信系统时，需要一个模块来计算一个8位数据向量的“置位计数”（population count），其定义为值为'1'的总位数。一名初级工程师编写了以下行为级 Verilog 模块来执行此任务。\n\n```verilog\nmodule pop_counter (\n    input [7:0] data_in,\n    output reg [2:0] count_out\n);\n    integer i;\n\n    always @(data_in) begin\n        count_out = 4'd0; // Initialize count\n        for (i = 0; i < 8; i = i + 1) begin\n            if (data_in[i] == 1'b1) begin\n                count_out = count_out + 1;\n            end\n        end\n    end\nendmodule\n```\n\n运行一个测试用例，将输入 `data_in` 设置为值 `8'b11111111`。您的任务是分析该 Verilog 代码并确定其结果输出。对于这个特定的输入，输出 `count_out` 的十进制值是多少？\n\nA. 0\nB. 1\nC. 7\nD. 8\nE. 由于运行时错误，该模块将无法编译或综合。", "solution": "该模块将 `count_out` 声明为一个3位寄存器，因此它只能表示整数0到7。它用 `4'd0` 初始化 `count_out`，其数值为0，因此在这一步不会因截断而产生问题。\n\n`always` 块对 `data_in` 的变化敏感，对于测试输入 `data_in = 8'b11111111`，for 循环会迭代8次（`i = 0, 1, ..., 7`）。在每次迭代中，由于 `data_in[i] == 1'b1`，条件为真，循环体执行，进行阻塞赋值：\n$$\ncount\\_out = count\\_out + 1.\n$$\n从0开始，在8次迭代中，这会顺序产生序列 $1, 2, 3, 4, 5, 6, 7, 8$。然而，在最后一次迭代中，右侧表达式的值为8，然后这个值被赋给3位寄存器 `count_out`。由于一个3位寄存器只能存储模 $2^{3}$ 的值，该赋值会截断为低3位：\n$$\n8 = 2^{3} = (1000)_{2} \\quad \\Longrightarrow \\quad \\text{低 3 位} = (000)_{2} = 0,\n$$\n等效地，\n$$\n8 \\bmod 2^{3} = 8 \\bmod 8 = 0.\n$$\n\n因此，当 `data_in = 8'b11111111` 时，最终的 `count_out` 值为0。代码可以编译和综合（可能会有位宽不匹配的警告），因此没有会阻止其运行的运行时或编译时错误。\n\n因此，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1912788"}, {"introduction": "许多数字系统问题无法仅通过组合逻辑解决，它们需要记忆和状态。这个按键去抖动电路的设计就是一个完美的例子，它展示了行为级建模在时序逻辑设计中的强大能力。物理按键的“抖动”是一个普遍存在的现实问题，而解决方法——去抖动器——是有限状态机（FSM）应用的经典范例。通过完成这个练习 [@problem_id:1912819]，你将设计一个包含状态转换、计数器和时钟同步行为的完整时序电路，这会将你对行为级建模的理解提升到一个新的高度。", "problem": "在数字系统中，机械式按钮和开关是常见的用户输入。然而，它们存在一种被称为“接触抖动”或“颤动”的物理现象，即单次按下或释放操作会在信号最终稳定到一个稳定状态之前，在逻辑高电平和低电平之间产生一系列快速、含噪声的无效跳变。为了将这样的按钮用作可靠的数字输入，需要一个“去抖动”电路。\n\n您的任务是分析一个按钮去抖动器的多种 Verilog 实现。该去抖动器应基于一个有限状态机 (FSM) 和一个计数器来工作。该去抖动模块的规格如下：\n\n**模块接口：**\n-   `clk`：系统时钟输入。\n-   `reset_n`：低电平有效的异步复位输入。\n-   `button_in`：来自按钮的含噪声输入。它通常为高电平（逻辑 1），按下时变为低电平（逻辑 0）。\n-   `pulse_out`：干净、去抖动后的输出。\n\n**功能行为：**\n1.  电路应检测 `button_in` 信号被按下（变为 0）的时刻。\n2.  检测到按下后，它必须等待并确认 `button_in` 在逻辑 0 上保持稳定，持续整整 16 个连续的时钟周期。\n3.  如果信号在所需时间内保持稳定，模块必须在 `pulse_out` 上产生一个干净的、单周期的高电平脉冲。\n4.  产生脉冲后，电路必须等待 `button_in` 被释放（返回到 1），然后才能准备检测下一次按下。这可以防止在按钮被长时间按住时产生多个脉冲。\n5.  如果在 16 个周期的稳定性检查期间，`button_in` 信号在任何时刻跳回 1，则检查失败，计时器必须复位，并且电路应返回其初始状态。\n6.  当异步 `reset_n` 信号被置为有效（低电平）时，必须立即将 FSM 返回到其初始状态，复位所有计数器，并确保 `pulse_out` 为低电平。\n\n**FSM 和实现细节：**\nFSM 使用由参数定义的四个状态：\n`parameter IDLE = 2'b00, WAIT_STABLE = 2'b01, PULSE = 2'b10, WAIT_RELEASE = 2'b11;`\n它还使用一个参数来定义稳定持续时间，并使用一个计数器寄存器：\n`parameter STABLE_CYCLES = 16;`\n`reg [3:0] counter;`\n\n下面给出了四个不同的 Verilog 代码片段，每个片段都声称实现了该去抖动器在 `always @(posedge clk or negedge reset_n)` 块内的逻辑。其中只有一个正确实现了所有指定的行为。请找出正确的实现。\n\nA.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin\n                pulse_out <= 1'b0;\n                if (button_in) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= IDLE; // Transition to IDLE\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin // Unused state\n                pulse_out <= 1'b0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    counter <= 4'd0;\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0;\n            end\n            WAIT_RELEASE: begin\n                // pulse_out is not assigned here\n                if (button_in) begin\n                    state <= IDLE;\n                    pulse_out <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        state <= IDLE;\n        counter <= 4'd0;\n        pulse_out <= 1'b0;\n    end else begin\n        case (state)\n            IDLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    state <= WAIT_STABLE;\n                    // Counter not reset here\n                end\n            end\n            WAIT_STABLE: begin\n                pulse_out <= 1'b0;\n                if (!button_in) begin\n                    if (counter == STABLE_CYCLES - 1) begin\n                        state <= PULSE;\n                    end else begin\n                        counter <= counter + 1;\n                    end\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            PULSE: begin\n                pulse_out <= 1'b1;\n                state <= WAIT_RELEASE;\n                counter <= 4'd0; // Counter is reset here\n            end\n            WAIT_RELEASE: begin\n                pulse_out <= 1'b0;\n                if (button_in) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n```", "solution": "我们将所需的 FSM 行为重述为一系列约束条件，以便对照每个实现进行验证：\n- 当异步复位信号有效时，FSM 必须立即进入 IDLE 状态，计数器必须清零，且 `pulse_out`=0。\n- 在 IDLE 状态，当检测到按键按下 (`button_in`=0) 时，FSM 必须转换到 WAIT_STABLE 状态，并将计数器复位为 0。\n- 在 WAIT_STABLE 状态，当 `button_in`=0 时，它必须对连续稳定的低电平周期进行计数，当计满 `STABLE_CYCLES`=16 个周期时，转换到 PULSE 状态。如果在达到 16 个周期之前 `button_in` 在任何时候返回到 1，则检查失败，计时器必须复位，并且状态机必须返回到 IDLE 状态。\n- 在 PULSE 状态，它必须将 `pulse_out`=1 维持整整一个时钟周期，然后转换到 WAIT_RELEASE 状态，并确保计数器被复位。\n- 在 WAIT_RELEASE 状态，它必须使 `pulse_out` 无效（拉低），并等待直到按键释放 (`button_in`=1) 才返回 IDLE 状态，这样可以防止在按键保持按下状态时产生多个脉冲。\n\n我们现在分析所使用的周期计数机制的正确性：进入 WAIT_STABLE 状态时 `counter`=0，逻辑检查条件为 `counter` == `STABLE_CYCLES` - 1（即15）。由于使用了非阻塞赋值，在 WAIT_STABLE 状态且 `button_in`=0 的情况下，在每个时钟上升沿会发生：\n- 进入该状态后的第一个稳定周期，旧的 `counter`=0≠15，因此计数器递增到 1。\n- 经过 k 个稳定周期后，旧的 `counter`=k-1；如果 k-1≠15，它会递增到 k。\n- 在第 16 个稳定周期，旧的 `counter`=15，满足 `counter`==15 的条件，因此 FSM 在该时钟周期转换到 PULSE 状态。所以，PULSE 状态恰好是在观察到 16 个连续的稳定低电平周期后达到的，满足了规格要求。\n\n检查选项 A:\n- IDLE：按下时，转换到 WAIT_STABLE 状态并将 `counter` 复位为 0；`pulse_out`=0。\n- WAIT_STABLE：当 `button_in`=0 时，它递增 `counter`，并在 `counter`==15 时转换到 PULSE 状态，如上所述，这恰好是 16 个周期。如果 `button_in` 返回到 1，它会转换到 IDLE 状态。尽管在这种抖动情况下它没有显式地复位 `counter`，但下次从 IDLE 进入 WAIT_STABLE 时 `counter` 会被复位，因此在任何新的稳定性检查开始之前，计时器实际上都被复位了，这满足了功能要求。\n- PULSE：将 `pulse_out` 置为 1，并在下一个时钟周期转换到 WAIT_RELEASE 状态；`counter` 被复位，保证了单周期脉冲。\n- WAIT_RELEASE：强制 `pulse_out`=0 并等待按键释放 (`button_in`=1) 后才返回 IDLE，从而防止在按键保持按下时产生多个脉冲。\n- 复位行为是正确的。因此，A 满足所有要求。\n\n检查选项 B:\n- PULSE 状态直接转换到 IDLE，跳过了 WAIT_RELEASE 状态。如果按钮保持按下状态，IDLE 将立即检测到 `button_in`=0 并开始一个新的 WAIT_STABLE 周期，从而允许在按钮被按住期间每 16 个周期产生一次重复脉冲。这违反了在脉冲后等待释放的要求。因此 B 是不正确的。\n\n检查选项 C:\n- 在 WAIT_RELEASE 状态，除非 `button_in` 为 1，否则 `pulse_out` 不会被驱动为低电平。从 `pulse_out`=1 的 PULSE 状态过来，如果按钮保持按下 (`button_in`=0)，那么 `pulse_out` 会保持其前一个值 1，从而产生一个多周期的脉冲。这违反了单周期脉冲的要求。因此 C 是不正确的。\n\n检查选项 D:\n- 在 IDLE 状态，当检测到按键按下时，它在进入 WAIT_STABLE 之前没有复位计数器。因此，等待的长度取决于前一次尝试可能遗留的旧计数值，这可能会缩短所需的 16 周期确认时间，并违反了在开始新的检测时必须复位计时器的要求。它也未能在抖动返回 IDLE 时复位计时器，而是在后面的 PULSE 状态才复位，这太晚了。因此 D 是不正确的。\n\n因此，只有选项 A 正确地实现了所有指定的行为。", "answer": "$$\\boxed{A}$$", "id": "1912819"}]}