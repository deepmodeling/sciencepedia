{"hands_on_practices": [{"introduction": "任何 Verilog 设计的第一步都是定义一个模块，它封装了特定的硬件功能。这个练习将带你实践最基本的技能：创建模块的接口或“骨架”。通过为一个数字比较器定义正确的模块名称、输入和输出端口，你将掌握将设计规范转化为有效 Verilog 代码的关键一步。[@problem_id:1975481]", "problem": "在为一个自动化仓库设计数字控制系统时，一个关键组件是用于比较包裹实测重量与预设参考重量的模块。您的任务是为这个数字比较器编写 Verilog 模块声明。\n\n该模块必须命名为 `weight_comparator`。它具有以下端口：\n- 两个8位输入：`measured_w`（代表实测包裹重量）和 `reference_w`（代表参考重量）。\n- 三个1位输出：`is_heavier`（如果 `measured_w` > `reference_w` 则置为高电平）、`is_lighter`（如果 `measured_w` < `reference_w` 则置为高电平）以及 `is_equal`（如果 `measured_w` == `reference_w` 则置为高电平）。\n\n根据这些规范，以下哪个 Verilog 代码片段正确且完整地声明了该模块及其端口？\n\nA.\n```verilog\nmodule weight_comparator(\n    input [7:0] measured_w,\n    input [7:0] reference_w,\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```\n\nB.\n```verilog\nmodule weight_comparator(\n    input [8:0] measured_w,\n    input [8:0] reference_w,\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```\n\nC.\n```verilog\nmodule weight_comparator(\n    output [7:0] measured_w,\n    output [7:0] reference_w,\n    input is_heavier,\n    input is_lighter,\n    input is_equal\n);\nendmodule\n```\n\nD.\n```verilog\nmodule comparator(\n    input [7:0] measured_w,\n    input [7:0] reference_w,\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```\n\nE.\n```verilog\nmodule weight_comparator(\n    input [7:0] measured_w,\n    input [7:0] reference_w\n    output is_heavier,\n    output is_lighter,\n    output is_equal\n);\nendmodule\n```", "solution": "规范要求：\n- 模块名称必须是 `weight_comparator`。\n- 必须有两个8位输入，因此每个都必须声明为 `input [7:0] measured_w` 和 `input [7:0] reference_w`。\n- 必须有三个1位输出，可以简单地声明为 `output is_heavier`、`output is_lighter` 和 `output is_equal`。\n- 端口列表的语法必须正确，包括括号内所有端口声明之间的逗号以及结束列表的分号。\n\n评估每个选项：\n- 选项 A 使用了正确的模块名，将两个输入声明为8位（使用 `[7:0]`），将所有三个输出声明为1位，并且端口列表语法正确，每个端口后都有逗号，右括号后有分号。这符合规范。\n- 选项 B 将输入声明为 `[8:0]`，即9位宽，违反了8位的要求。\n- 选项 C 颠倒了端口方向，将重量设为输出，将比较标志设为输入，这与规范相矛盾。\n- 选项 D 使用了错误的模块名（`comparator` 而不是 `weight_comparator`），违反了命名要求。\n- 选项 E 在端口列表中省略了第二个输入和第一个输出之间的逗号，导致声明存在语法错误。\n\n因此，只有选项 A 是正确且完整的。", "answer": "$$\\boxed{A}$$", "id": "1975481"}, {"introduction": "在定义了模块的边界后，下一步是确保数据流方向的正确性。错误地将输出端口声明为输入是初学者常犯的错误，这会导致编译失败。这个练习模拟了一个调试场景，要求你识别一个加法器/减法器模块中不正确的端口方向，从而加深对 `input` 和 `output` 声明如何决定信号在模块内外流动的理解。[@problem_id:1975461]", "problem": "一位初级数字设计工程师的任务是调试一个用 Verilog 实现的简单的 4 位算术逻辑单元 (ALU)。该模块旨在根据控制信号 `sub` 对两个 4 位输入 `A` 和 `B` 执行加法或减法。当 `sub` 为 0 时，它应该计算 `A + B`。当 `sub` 为 1 时，它应该计算 `A - B`。结果是一个 4 位的和/差 `S` 和一个单位的进位/借位输出 `C_out`。\n\n在编译期间，报告了一个错误，指示一个网络（net）不能被多个源（source）驱动。该工程师怀疑模块的端口方向声明有误。请在下面提供的 Verilog 代码中找出错误的端口声明。\n\n```verilog\nmodule adder_subtractor(\n  input  [3:0] A, B,\n  input  sub,\n  input  [3:0] S,\n  output C_out\n);\n\n  // Perform addition or subtraction based on the 'sub' signal\n  assign {C_out, S} = sub ? (A - B) : (A + B);\n\nendmodule\n```\n\n下列哪一行包含了错误的端口声明？\n\nA. `input  [3:0] A, B,`\nB. `input  sub,`\nC. `input  [3:0] S,`\nD. `output C_out`", "solution": "我们结合连续赋值语句来分析端口方向。\n\n- 在 Verilog 中，输入端口由模块外部驱动，并且不能由内部赋值驱动。使用 `assign` 关键字的连续赋值会从模块内部驱动其左侧的网络。\n- `assign {C_out, S} = sub ? (A - B) : (A + B);` 这一行在内部驱动了 `C_out` 和 `S`，因为它们出现在赋值语句的左侧。\n- 因此，任何在左侧的信号都必须声明为 `output`（或 `inout`），而不能是 `input`。\n- 在给定的声明中：\n  - `A` 和 `B` 在表达式中仅用作源；将它们声明为输入是正确的。\n  - `sub` 仅用作控制输入；将其声明为输入是正确的。\n  - `C_out` 出现在左侧并被声明为 `output`；这是正确的。\n  - `S` 出现在左侧，但被错误地声明为 `input`。这会导致多驱动源错误（multiple-driver error），因为一个输入网络将同时被外部环境和内部的 `assign` 语句驱动。\n\n因此，错误的端口声明是声明 `S` 为 `input` 的那一行，这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1975461"}, {"introduction": "复杂的数字系统是通过将简单的、可重用的模块组合起来构建的，这体现了设计的层次性。模块实例化是在一个更大的设计中创建并连接子模块实例的过程。这个练习将指导你如何在一个算术逻辑单元（ALU）中实例化一个预定义的四位加法器，并特别强调使用“命名端口连接”这一健壮的设计实践，以提高代码的可读性和可维护性。[@problem_id:1975499]", "problem": "在一个数字逻辑设计项目中，你的任务是创建一个名为 `eight_bit_alu_section` 的顶层模块，该模块利用一个已有的 4 位加法器组件。该加法器的 Verilog 模块声明如下所示：\n\n```verilog\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output reg [3:0] sum,\n    output reg cout\n);\n// Internal logic for the 4-bit adder is defined here.\n// You do not need to know the internal logic to solve this problem.\nendmodule\n```\n\n你的 `eight_bit_alu_section` 模块必须例化一个 `four_bit_adder` 的实例。该算术逻辑单元 (ALU) 部分有其自己的一组端口，这些端口必须连接到加法器实例上。你的设计的模块定义是：\n\n```verilog\nmodule eight_bit_alu_section (\n    input [3:0] operand_X,\n    input [3:0] operand_Y,\n    input initial_carry,\n    output [3:0] result_bus,\n    output final_carry\n);\n// You must place the instantiation code here.\nendmodule\n```\n\n你的任务是在 `eight_bit_alu_section` 模块内部例化 `four_bit_adder` 模块。实例名称必须是 `U1_adder`。例化必须**仅**使用**命名端口连接**。\n\n以下哪个代码片段正确地执行了此例化？\n\nA.\n```verilog\nfour_bit_adder U1_adder (\n    operand_X,\n    operand_Y,\n    initial_carry,\n    result_bus,\n    final_carry\n);\n```\n\nB.\n```verilog\nfour_bit_adder U1_adder (\n    .operand_X(a),\n    .operand_Y(b),\n    .initial_carry(cin),\n    .result_bus(sum),\n    .final_carry(cout)\n);\n```\n\nC.\n```verilog\nfour_bit_adder U1_adder (\n    .cout(final_carry),\n    .sum(result_bus),\n    .cin(initial_carry),\n    .b(operand_Y),\n    .a(operand_X)\n);\n```\n\nD.\n```verilog\nfour_bit_adder U1_adder (\n    .a(operand_X),\n    .b(operand_Y),\n    .cin(initial_carry),\n    .sum(result_bus)\n);\n```", "solution": "我们给定了一个预定义的模块 `four_bit_adder`，其形式端口名称为 `a`、`b`、`cin`、`sum` 和 `cout`。我们必须在 `eight_bit_alu_section` 内部使用命名端口连接来例化它，实例名为 `U1_adder`，并将 ALU 部分的端口与加法器的端口按如下方式连接：\n- 加法器输入 `a` 必须连接到 `operand_X`。\n- 加法器输入 `b` 必须连接到 `operand_Y`。\n- 加法器输入 `cin` 必须连接到 `initial_carry`。\n- 加法器输出 `sum` 必须连接到 `result_bus`。\n- 加法器输出 `cout` 必须连接到 `final_carry`。\n\n在 Verilog 的命名端口关联中，每个连接的左侧是所例化模块的形式端口名，右侧是上层模块中的信号。使用命名连接时，顺序无关紧要，但所有必需的端口都应被连接以满足预期的设计。\n\n评估各个选项：\n- 选项 A 使用的是位置连接而非命名连接，违反了必须仅使用命名端口连接的要求。因此，A 是不正确的。\n- 选项 B 使用了命名关联，但错误地将上层模块的端口名用在了左侧（例如 `.operand_X(a)`），这是无效的，因为左侧必须是 `four_bit_adder` 的形式端口名（`a`, `b`, `cin`, `sum`, `cout`）。此外，右侧的标识符如 `a`、`b` 等并未在 `eight_bit_alu_section` 中定义。因此，B 是不正确的。\n- 选项 C 使用了命名关联，左侧是正确的形式端口名，并正确地将它们映射到上层模块的信号：`.cout(final_carry)`、`.sum(result_bus)`、`.cin(initial_carry)`、`.b(operand_Y)`、`.a(operand_X)`。对于命名连接，顺序是无关紧要的，并且所有端口都已连接。因此，C 是正确的。\n- 选项 D 忽略了 `cout` 的连接（未连接 `final_carry`），使一个重要的输出未被连接，这不满足将模块端口连接到加法器实例的要求。因此，D 是不正确的。\n\n因此，唯一正确的例化方式在选项 C 中给出。", "answer": "$$\\boxed{C}$$", "id": "1975499"}]}