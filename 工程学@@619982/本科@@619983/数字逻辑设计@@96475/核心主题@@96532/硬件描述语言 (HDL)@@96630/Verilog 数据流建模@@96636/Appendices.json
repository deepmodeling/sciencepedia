{"hands_on_practices": [{"introduction": "数据流建模的核心优势之一是能够简洁地描述组合逻辑电路。本练习将通过一个简单的实例，指导您如何用一行代码实现一个小型只读存储器（ROM）。通过这个实践，您将掌握如何使用可变索引从一个常量向量中选取特定位，这是在Verilog中实现真值表、配置寄存器或其他查找功能的基石[@problem_id:1925969]。", "problem": "你的任务是使用 Verilog 设计一个小型 8位×1位 只读存储器（ROM）。该 ROM 将用于存储一个固定的配置模式，以供玩具机器人启动序列使用。该电路必须使用**数据流建模**来实现。\n\n该 Verilog 模块必须命名为 `simple_rom` 并具有以下端口：\n- 一个3位输入 `address`，声明为 `input wire [2:0] address`。\n- 一个1位输出 `data_out`，声明为 `output wire data_out`。\n\n该 ROM 必须被硬编码以存储 8 位常量 `8'b10110101`。在此常量中，第7位是最高有效位 (MSB)，第0位是最低有效位 (LSB)。`address` 输入的值直接对应于要读取的位索引。例如，如果 `address` 是 `3'b110`（十进制为 6），`data_out` 应为该常量的第6位的值。\n\n以下哪个 Verilog 模块使用单个数据流建模语句正确地实现了这个 `simple_rom`？\n\nA.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output wire data_out\n);\n    assign data_out = 8'b10110101[address];\nendmodule\n```\n\nB.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output wire data_out\n);\n    assign data_out = 8'b10101101[address];\nendmodule\n```\n\nC.\n```verilog\nmodule simple_rom(\n    input wire [2_0] address,\n    output reg data_out\n);\n    always @(*)\n        data_out = 8'b10110101[address];\nendmodule\n```\n\nD.\n```verilog\nmodule simple_rom(\n    input wire [2:0] address,\n    output wire data_out\n);\n    wire selected_bit;\n    assign selected_bit[address] = 8'b10110101;\n    assign data_out = selected_bit;\nendmodule\n```", "solution": "我们必须使用数据流建模来实现一个 8x1 的组合逻辑 ROM。在 Verilog 中，这意味着使用带有 assign 关键字的连续赋值语句来驱动一个线网（wire）输出。\n\nROM 的内容固定为 8 位常量 8'b10110101，其位索引是标准的 Verilog 索引，第7位为 MSB，第0位为 LSB。要求是 3 位输入地址直接选择该常量的相应位；因此，一个正确的实现必须将 `data_out` 计算为该常量在索引 `address` 处的位选，即 `data_out` 等于该常量中位号为 `address` 的位。\n\n现在根据要求验证每个选项：\n\n1) 建模风格和单一语句：\n- 数据流建模需要连续赋值。一个 assign 语句满足“单个数据流建模语句”的要求。\n\n2) 正确的内容和索引：\n- 常量必须正好是 8'b10110101。\n- 位选择必须是 `something[address]` 的形式，其中“something”是该 8 位常量。\n\n3) 端口声明和语法正确性：\n- `address` 必须声明为 `input wire [2:0] address`。\n- 如果由 `assign` 驱动，`data_out` 必须是线网 (wire) 类型。\n- 如果必须使用单个数据流语句，则不允许使用过程块 (`always`)。\n\n评估选项：\n\nA. 使用单个连续赋值：\nassign data_out = 8'b10110101[address];\n- 建模：数据流，一条语句：满足要求。\n- 常量：正确 (8'b10110101)。\n- 索引：在 Verilog 中是合法的可变位选择；`address` 选择给定常量的 `address` 位，其中第7位是 MSB，第0位是 LSB，符合要求。\n- 端口：`input wire [2:0] address` 和 `output wire data_out`：正确。\n因此，A 是正确的。\n\nB. 与 A 结构相同，但使用了 8'b10101101 而不是要求的 8'b10110101：\n- 常量不正确，所以 B 不正确。\n\nC. 将输入声明为 `input wire [2_0] address`，这是无效语法（下划线代替了冒号）。它还使用了 `output reg data_out` 和一个 `always @(*)` 过程块：\n- 这是行为建模，不是单个数据流语句。此外，端口声明在语法上是无效的。因此，C 是不正确的。\n\nD. 声明了 `wire selected_bit`（标量），然后尝试：\nassign selected_bit[address] = 8'b10110101;\n- 这是一种非法的连续赋值形式：连续赋值的左侧必须是一个线网，而不是对标量的位选择，并且方向是反的（试图将一个向量赋给一个索引位）。此外，它使用了两个 `assign` 语句，违反了“单个语句”的要求。\n因此，D 是不正确的。\n\n只有 A 满足所有约束条件：正确的常量、正确的变量位选择、正确的端口以及单个数据流赋值。", "answer": "$$\\boxed{A}$$", "id": "1925969"}, {"introduction": "在掌握了基本的位选择之后，让我们来探索Verilog中更强大的数据流操作符。本练习将向您介绍归约运算符（reduction operators），它可以对一个向量的所有位执行特定逻辑运算并产生单个比特的输出。您将通过设计一个偶校验电路来体会这一工具的威力，这是一个在数据通信中用于错误检测的常用电路，并学习如何利用归约异或非（XNOR）运算符 `~^` 来高效地完成任务[@problem_id:1926027]。", "problem": "一个数字电路被设计用于对一个8位数据总线执行一项特殊检查。该电路有一个8位输入向量，声明为 `wire [7:0] data_in;`，以及一个1位输出，`wire even_parity;`。该电路的功能是：如果 `data_in` 中值为‘1’的位数是偶数（包括零个‘1’的情况），则将 `even_parity` 输出置为‘1’，否则置为‘0’。\n\n以下哪条单行Verilog数据流语句正确地实现了这一行为？\n\nA. `assign even_parity = ^data_in;`\n\nB. `assign even_parity = data_in;`\n\nC. `assign even_parity = |data_in;`\n\nD. `assign even_parity = ~^data_in;`\n\nE. `assign even_parity = ~data_in;`", "solution": "设8位输入表示为 $data\\_in = (d_{7}, d_{6}, \\ldots, d_{0})$，其中 $d_{i} \\in \\{0,1\\}$。奇偶校验函数可以使用异或（XOR）运算表示为\n$$\np = d_{7} \\oplus d_{6} \\oplus \\cdots \\oplus d_{0} = \\left(\\sum_{i=0}^{7} d_{i}\\right) \\bmod 2.\n$$\n当‘1’的个数为奇数时，这个 $p$ 等于 $1$；当‘1’的个数为偶数时，$p$ 等于 $0$。因此，所求的偶校验输出是 $p$ 的逻辑非：\n$$\n\\overline{p} = \\overline{d_{7} \\oplus d_{6} \\oplus \\cdots \\oplus d_{0}}.\n$$\n在Verilog中，缩减异或（reduction XOR）运算符写作一元运算符 `^`，因此 `^data_in` 计算的是 $p$。缩减同或（reduction XNOR）运算符写作一元运算符 `~^`，因此 `~^data_in` 计算的是 $\\overline{p}$，其值恰好在‘1’的个数为偶数（包括零）时为 $1$。因此，正确的单行语句是 `assign even_parity = ~^data_in;`。\n\n为完整起见，其他选项实现了不同的缩减运算：\n- `data_in` 计算 $\\prod_{i=0}^{7} d_{i}$，仅当所有位都为 $1$ 时，结果才为 $1$。\n- `|data_in` 计算 $\\max(d_{0},\\ldots,d_{7})$，只要有任意位为 $1$，结果就为 $1$。\n- `^data_in` 计算奇校验。\n- `~data_in` 是缩减与（reduction AND）的非，除非所有位都为 $1$，否则结果为 $1$。\n\n只有缩减同或（reduction XNOR）与偶校验匹配。", "answer": "$$\\boxed{D}$$", "id": "1926027"}, {"introduction": "数据流建模不仅能描述简单的逻辑功能，更擅长于构建高效的算术电路结构。本练习将挑战您构建算术逻辑单元（ALU）中的一个关键组件：一个利用二进制补码原理实现的可控取反器。这个实践将位运算、算术运算和控制信号巧妙地融合在单个 `assign` 语句中，其表达式直接映射到一种优化的硬件实现，充分展示了Verilog在描述复杂数据路径时的简洁与强大[@problem_id:1925996]。", "problem": "你的任务是使用数据流 Verilog 设计一个可控的 8 位取反器。该电路是一个更大的算术逻辑单元 (ALU) 中加法器/减法器单元的关键组件。\n\n计算 `A+B` 或 `A-B` 的 N 位加法器/减法器的标准硬件实现基于补码恒等式 `-B = ~B + 1`。减法 `A-B` 通过计算 `A + ~B + 1` 来执行。这在硬件中通过使用 N 个异或门，根据一个 `subtract` 控制信号有条件地对 `B` 的各位进行取反，然后将这个相同的 `subtract` 信号送入 N 位加法器的进位输入端，从而高效地实现。\n\n你的任务是实现该电路的一个特殊化版本，用于计算 `Y = X` 或 `Y = -X`。这在功能上等同于计算 `0+X` 或 `0-X`。这个“符号控制单元”的 Verilog 模块具有以下接口：\n- 一个有符号的 8 位输入： `input signed [7:0] X`\n- 一个单位的控制信号： `input negate`\n- 一个有符号的 8 位输出： `output [7:0] Y`\n\n要求的行为如下：\n- 如果 `negate` 信号是 `1'b0`，输出 `Y` 必须等于输入 `X`。\n- 如果 `negate` 信号是 `1'b1`，输出 `Y` 必须是 `X` 的补码负值。\n\n遵循上述特定的加法器/减法器硬件原理，以下哪一个单行数据流 Verilog `assign` 语句正确且符合语言习惯地实现了这个功能？\n\nA. `assign Y = (X ^ {8{negate}}) + negate;`\n\nB. `assign Y = negate ? (~X + 1) : X;`\n\nC. `assign Y = (X  {8{negate}}) + negate;`\n\nD. `assign Y = ~X + negate;`\n\nE. `assign Y = (X ~^ {8{negate}}) + negate;`", "solution": "目标是创建一个 Verilog `assign` 语句，该语句基于控制位 `negate` 实现条件性补码求反。问题特别要求实现的方案能够模拟标准加法器/减法器硬件原理。\n\n所需功能为：\n1.  如果 `negate = 0`，则 `Y = X`。\n2.  如果 `negate = 1`，则 `Y = -X`。\n\n在补码表示法中，一个数 `X` 的负数由公式 `-X = ~X + 1` 给出，其中 `~X` 是 `X` 的按位非（反码）。\n\n让我们将这两个条件组合成一个与加法器/减法器原理一致的统一表达式。该原理使用异或门进行条件取反，并使用控制信号作为加法的进位输入。\n\n让我们分析表达式 `(X ^ S) + S`，其中 `S` 是一个根据需要进行广播或扩展的单位控制位。\n\n**情况1：`negate = 0`**\n\n表达式变为 `(X ^ {8{1'b0}}) + 1'b0`。\n- 项 `{8{negate}}` 变为 `8'b00000000`。\n- `X ^ 8'b00000000` 的计算结果为 `X`，因为任何位与 0 进行异或运算，该位保持不变。\n- 加法 `+ negate` 变为 `+ 0`。在 Verilog 中，当对不同位宽的操作数进行加法时，较小的操作数会被零扩展以匹配较大的操作数。因此 `1'b0` 变为 `8'b00000000`。\n- 完整的表达式是 `X + 0`，结果为 `X`。\n这符合 `negate = 0` 时的要求。\n\n**情况2：`negate = 1`**\n\n表达式变为 `(X ^ {8{1'b1}}) + 1'b1`。\n- 项 `{8{negate}}` 变为 `8'b11111111`。\n- `X ^ 8'b11111111` 的计算结果为 `~X`（按位非或反码），因为任何位与 1 进行异或运算都会翻转该位。\n- 加法 `+ negate` 变为 `+ 1`。`1'b1` 被零扩展为 `8'b00000001`。\n- 完整的表达式是 `~X + 1`。\n这是补码求反的精确公式。它符合 `negate = 1` 时的要求。\n\n因此，语句 `assign Y = (X ^ {8{negate}}) + negate;` 正确地实现了所需的功能，并且直接映射到硬件原理：使用异或门进行条件取反 (`X ^ {8{negate}}`)，并使用控制信号 `negate` 作为要加上的值（其作用等同于 `+1` 时的进位输入）。\n\n现在，我们来检查为什么其他选项是错误的：\n\n- **B. `assign Y = negate ? (~X + 1) : X;`**: 这个语句在功能上是正确的。它使用三元条件运算符 (`?:`) 在 `X` 和 `-X` 之间进行选择。然而，它模拟的是一个在两个分开计算的值之间进行选择的多路选择器。它并没有模拟问题背景中描述的单一、可重构的数据通路（异或门阵列馈送给加法器），而 `(X ^ S) + S` 所代表的正是这种通路。问题要求的是基于该特定原理的实现。\n\n- **C. `assign Y = (X  {8{negate}}) + negate;`**: 这个语句使用按位与 (``)。\n    - 如果 `negate = 0`，它变为 `(X  8'b0) + 0`，结果为 `0`。这是不正确的，因为输出应为 `X`。\n    - 如果 `negate = 1`，它变为 `(X  8'b11111111) + 1`，即 `X + 1`。这同样是不正确的。\n\n- **D. `assign Y = ~X + negate;`**:\n    - 如果 `negate = 0`，它变为 `~X + 0`，结果为 `~X`。这是不正确的，因为输出应为 `X`。\n    - 如果 `negate = 1`，它变为 `~X + 1`，这在这种情况下是正确的。然而，由于它在 `negate = 0` 时失败，整个表达式是错误的。\n\n- **E. `assign Y = (X ~^ {8{negate}}) + negate;`**: 这个语句使用按位同或 (`~^`)。`A ~^ B` 等价于 `~(A ^ B)`。\n    - 如果 `negate = 1`，它变为 `(X ~^ 8'b1) + 1`，即 `~(X ^ 8'b1) + 1`。\n    - `X ^ 8'b1` 是 `~X`。\n    - 所以表达式是 `~(~X) + 1`，简化为 `X + 1`。这是不正确的。\n\n基于此分析，选项 A 是唯一一个在所有情况下功能都正确，并且直接模拟了问题陈述中描述的特定硬件实现原理的选项。", "answer": "$$\\boxed{A}$$", "id": "1925996"}]}