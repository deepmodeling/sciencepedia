{"hands_on_practices": [{"introduction": "在VHDL中执行算术运算是一项基本任务，但其强类型系统为不同数据类型之间的直接操作设置了障碍。本练习将引导你完成一个常见场景：将一个代表传感器读数的 `std_logic_vector` 类型与一个整数常量相加。通过这个实践，你将掌握使用 `IEEE.numeric_std` 库进行显式类型转换的关键技能，这是编写可综合且可靠的VHDL代码的基础。[@problem_id:1976718]", "problem": "您正在使用 VHDL 设计一个简单的数字信号处理器。该处理器的一部分需要接收一个 8 位无符号传感器读数，并为其加上一个固定的整数偏移量。\n\n请看下面定义的 VHDL 实体：\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity DataCalibrator is\n    port (\n        clk      : in  std_logic;\n        data_in  : in  std_logic_vector(7 downto 0);\n        data_out : out std_logic_vector(7 downto 0)\n    );\nend entity DataCalibrator;\n```\n\n在 `DataCalibrator` 的架构 (architecture) 中，需要一个时钟同步进程 (clocked process)。该进程必须在 `clk` 信号的上升沿触发，读取 `data_in` 向量，将其值加上整数 `17`，然后将 8 位的结果赋给 `data_out` 信号。结果应能正确处理溢出，实现回绕（例如，如果 `data_in` 是 `250`，加上 `17` 后的结果应为 `11`，因为 `(250+17) mod 256 = 11`）。\n\n以下哪个代码片段正确实现了所需进程？\n\nA.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));\n    end if;\nend process;\n```\n\nB.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = data_in + 17;\n    end if;\nend process;\n```\n\nC.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = data_in + \"00010001\";\n    end if;\nend process;\n```\n\nD.\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = conv_std_logic_vector(conv_integer(data_in) + 17, 8);\n    end if;\nend process;\n```", "solution": "目标是将一个 `integer` 类型的字面量与一个 `std_logic_vector` 信号相加，并将 `std_logic_vector` 类型的结果赋给一个输出端口。VHDL 是一种强类型语言，这意味着操作只能在兼容的数据类型之间进行。`+` 运算符默认没有为 `std_logic_vector` 和 `integer` 混合类型定义。因此，必须进行显式类型转换。问题指定使用 `ieee.numeric_std` 库，这是执行此类运算的行业标准。\n\n我们来分析转换和计算所需的步骤：\n1.  输入信号 `data_in` 的类型是 `std_logic_vector`。要执行算术运算，必须将其转换为数值类型。`numeric_std` 库为此提供了 `unsigned` 类型。由于题目说明传感器读数是无符号的，所以这是正确的选择。必须先将 `std_logic_vector` 强制转换为 `unsigned` 类型：`unsigned(data_in)`。\n2.  加法运算涉及一个 `integer` 类型的操作数（字面量 `17`）。`numeric_std` 中的 `+` 运算符为 `unsigned` + `integer` 定义，其返回一个 `unsigned` 结果。它也为 `integer` + `integer` 定义。为了清晰和稳健，通常在加法前将 `unsigned` 向量转换为 `integer`。`numeric_std` 中的 `to_integer()` 函数可以实现这一点：`to_integer(unsigned(data_in))`。\n3.  现在可以在两个整数之间执行加法：`to_integer(unsigned(data_in)) + 17`。此运算的结果是一个 `integer`。\n4.  输出端口 `data_out` 是一个 8 位的 `std_logic_vector`。加法得到的整数结果必须转换回此类型。首先，我们将整数转换为正确大小（8 位）的 `unsigned` 向量。`to_unsigned()` 函数可以实现此功能：`to_unsigned(integer_result, 8)`。该函数能正确处理问题所要求的环绕行为（模运算）。\n5.  最后，将 `unsigned` 向量强制转换回 `std_logic_vector`，以匹配输出信号的类型：`std_logic_vector(unsigned_result)`。\n\n将所有这些步骤合并到一行中，得到表达式：\n`data_out = std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));`\n\n现在，我们来评估给出的选项：\n\n**A.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = std_logic_vector(to_unsigned(to_integer(unsigned(data_in)) + 17, 8));\n    end if;\nend process;\n```\n该选项与上面的推导完全匹配。它正确地将 `data_in` 强制转换为 `unsigned`，再转换为 `integer`，执行加法，然后将整数结果转换回 8 位的 `unsigned` 向量，最后再强制转换为 `std_logic_vector`。这是正确的实现。\n\n**B.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = data_in + 17;\n    end if;\nend process;\n```\n该选项试图直接将一个 `std_logic_vector` 和一个 `integer` 相加。这将在编译期间导致类型不匹配错误，因为标准库中没有为这些类型定义 `+` 运算符。\n\n**C.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = data_in + \"00010001\";\n    end if;\nend process;\n```\n该选项试图将两个 `std_logic_vector` 相加。在 `ieee.std_logic_1164` 或 `ieee.numeric_std` 中，并没有为 `std_logic_vector` 类型定义 `+` 运算符。算术加法是为 `unsigned` 和 `signed` 类型定义的，但不是直接为 `std_logic_vector` 定义。这同样会导致编译错误。\n\n**D.**\n```vhdl\nprocess(clk)\nbegin\n    if rising_edge(clk) then\n        data_out = conv_std_logic_vector(conv_integer(data_in) + 17, 8);\n    end if;\nend process;\n```\n该选项使用了 `conv_integer` 和 `conv_std_logic_vector` 函数。这些函数不属于标准的 `ieee.numeric_std` 库。它们属于非标准的、特定于供应商的或已弃用的库，例如 `std_logic_arith` (来自 Synopsys)。当指定使用标准的 `ieee.numeric_std` 时，使用它们是不正确的，并且被认为是糟糕的现代 VHDL 实践。\n\n因此，选项 A 是唯一正确且符合标准的解决方案。", "answer": "$$\\boxed{A}$$", "id": "1976718"}, {"introduction": "超越了基本数据类型，理解VHDL中的数据对象（如信号和变量）及其在并发进程中的行为至关重要，尤其是在处理共享资源时。这个思想实验通过一个看似简单的计数器，巧妙地揭示了在多个进程中并发访问共享变量时可能出现的“竞争条件”。通过分析这种非确定性行为，你将深刻理解为何在硬件设计中，信号通常是进程间通信的首选机制，以确保可预测和可重复的结果。[@problem_id:1976697]", "problem": "一位工程师正在设计一个数字系统，用于对两个独立的同步传感器检测到的事件进行计数。为了仿真该事件计数器的行为，创建了一个 VHDL 模型。该设计使用了两个并发进程，每个传感器对应一个进程，旨在公共时钟信号 `clk` 的每个上升沿上增加一个共享计数器的值。仿真由第三个进程控制，该进程在初始 `reset` 后，会在固定数量的时钟周期 `N_CYCLES` 内启用计数功能。\n\n请看下述 `race_condition_eval` 实体的 VHDL 代码片段。\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity race_condition_eval is\n    port (\n        clk   : in  std_logic;\n        reset : in  std_logic;\n        final_count : out integer\n    );\nend entity race_condition_eval;\n\narchitecture behavioral of race_condition_eval is\n    signal stop_sim : boolean := false;\n    shared variable event_counter : integer := 0;\n    \n    constant N_CYCLES : integer := 80;\n\nbegin\n\n    process_A: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_A;\n\n    process_B: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_B;\n\n    control_proc: process\n    begin\n        -- Wait for reset to be applied and then de-asserted\n        wait until reset = '1';\n        wait until reset = '0';\n        \n        event_counter := 0;\n        stop_sim = false;\n        \n        for i in 1 to N_CYCLES loop\n            wait until rising_edge(clk);\n        end loop;\n        \n        stop_sim = true;\n        \n        -- Allow one final delta cycle for processes to stop\n        wait for 0 ns; \n        \n        final_count = event_counter;\n        \n        wait; -- Halt the control process\n    end process control_proc;\n\nend architecture behavioral;\n```\n\n假设一个 VHDL 仿真器执行此代码。由于并发进程中共享变量的特性，在 `final_count` 输出端口上报告的 `event_counter` 的最终值是不确定的。\n\n请确定仿真完成后 `final_count` 的最小可能值和最大可能值。计算此最小可能值与最大可能值的和。", "solution": "我们分析在公共时钟的每个上升沿的执行情况。`process_A` 和 `process_B` 都对 `rising_edge(clk)` 敏感，并且当 `stop_sim` 为 false 时，每个进程都对共享变量执行一次读-修改-写操作：\n```vhdl\nevent_counter := event_counter + 1;\n```\n在 VHDL 中，共享变量的更新是立即的，但并发进程在同一个 delta cycle 内以未指定的顺序恢复执行。因此，在任一给定的上升沿：\n- 如果两个进程在任一进程写入新值之前都读取了相同的旧值 $x$，那么它们各自计算出 $x+1$，然后都写入 $x+1$，最终导致净增量为一。\n- 如果一个进程在另一个进程读取之前完成了其增量操作，那么第二个进程将读取到 $x+1$ 并写入 $x+2$，最终导致净增量为二。\n\n因此，对于每个启用的上升沿 $k$，净增量 $m_{k}$ 满足 $m_{k} \\in \\{1,2\\}$，且没有其他可能的结果。\n\n控制进程执行以下操作：\n1) 等待 `reset` 置位然后撤销，接着执行 `event_counter := 0;` 和 `stop_sim = false;`。对 `event_counter` 的赋值确保了之前的活动被清除；随后的循环精确地对接下来的 `N_CYCLES` 个上升沿进行计数。\n2) 然后，它等待整好 `N_CYCLES` 个上升沿：\n```vhdl\nfor i in 1 to N_CYCLES loop\n    wait until rising_edge(clk);\nend loop;\n```\n在这 `N_CYCLES` 个时钟沿期间，`stop_sim` 保持为 false，因为赋值语句 `stop_sim = true;` 在循环之后才执行，并在下一个 delta cycle 才生效，所以两个进程在这些时钟沿的每一个上都被启用。\n3) 循环结束后，它执行 `stop_sim = true;`，然后执行 `wait for 0 ns;`，以允许一个 delta cycle 的时间，让时钟进程观察到 `stop_sim = true` 并停止进一步的增量，之后才执行 `final_count = event_counter;` 赋值。\n\n令 $N = N_{CYCLES}$。从计数窗口开始时的 $event\\_counter = 0$ 算起，经过 $N$ 个启用的上升沿后，共享变量的最终值为\n$$\nevent\\_counter = \\sum_{k=1}^{N} m_{k}, \\quad \\text{with } m_{k} \\in \\{1,2\\}.\n$$\n因此，当每个周期都丢失一个增量时，达到最小可能值：\n$$\nevent\\_counter_{\\min} = \\sum_{k=1}^{N} 1 = N,\n$$\n而当每个周期都保留两个增量时，达到最大可能值：\n$$\nevent\\_counter_{\\max} = \\sum_{k=1}^{N} 2 = 2N.\n$$\n所求的和是\n$$\nevent\\_counter_{\\min} + event\\_counter_{\\max} = N + 2N = 3N.\n$$\n当 `N_CYCLES` = 80 时，我们得到\n$$\n3N = 3 \\times 80 = 240.\n$$", "answer": "$$\\boxed{240}$$", "id": "1976697"}, {"introduction": "VHDL的强大之处不仅在于其丰富的预定义类型，更在于它允许设计者创建具有自定义行为的新类型。本练习探讨了一个高级概念——“解析类型”，它允许我们将复杂的逻辑（如总线仲裁）直接嵌入到信号的数据类型定义中。在这个假设的多主控总线场景中，你将通过应用一个自定义的优先级解析函数来确定总线的最终状态，从而体验到一种无需显式仲裁器的优雅设计方法。[@problem_id:1976728]", "problem": "在数字系统设计中，共享总线允许多个组件（主设备）通过一组公共线路进行通信。管理对该总线的访问以防止冲突至关重要，这通常由仲裁器电路来处理。本问题探讨了一种新颖的总线架构，该架构通过使用超高速集成电路硬件描述语言 (VHDL) 的特性，将仲裁逻辑直接嵌入到总线信号的数据类型中，从而消除了对显式仲裁器的需求。\n\n考虑一个名为 `priority_logic` 的自定义 VHDL 逻辑类型，它被定义为一个枚举类型，具有以下可能的值：`'U'` (未初始化)、`'X'` (未知/冲突)、`'1'` (逻辑高)、`'0'` (逻辑低) 和 `'Z'` (高阻态)。\n\n当多个主设备同时驱动一个此类型的信号时，一个特殊的分辨函数会决定该信号的最终值。该函数基于严格的优先级方案运行，即在所有驱动值中，具有最高优先级的值会“胜出”。优先级顺序定义如下：\n`'U'  'X'  '1'  '0'  'Z'`\n\n例如，如果三个驱动器试图在线路上置入 `'0'`、`'Z'` 和 `'1'`，由于 `'1'` 在这三者中优先级最高，因此分辨后的值为 `'1'`。如果驱动器提供 `'1'` 和 `'X'`，分辨后的值为 `'X'`。如果所有驱动器均为 `'Z'`，则线路保持在高阻态 `'Z'`。\n\n现在，考虑一个 4 位共享总线 `DATA_BUS`，其中每一位都是一个分辨后的 `priority_logic` 类型的独立信号。这意味着四位中的每一位都根据上述优先级规则被独立地分辨。三个主设备 `M1`、`M2` 和 `M3` 连接到该总线。系统行为遵循以下事件序列：\n\n1.  在所有时间 `t  10 ns`，主设备使用以下恒定的 4 位值（从第 3 位到第 0 位）驱动 `DATA_BUS`：\n    *   `M1` 驱动 `\"0Z1Z\"`\n    *   `M2` 驱动 `\"ZZ01\"`\n    *   `M3` 驱动 `\"ZZZZ\"`\n\n2.  在 `t = 10 ns`时，主设备 `M3` 改变其输出，并开始驱动值 `\"X10X\"`。\n\n3.  在 `t = 20 ns`时，主设备 `M1` 改变其输出，并开始驱动值 `\"Z110\"`。\n\n假设所有信号变化都是瞬时的，请确定在时间 `t = 25 ns` 时 `DATA_BUS` 的 4 位状态。请将您的答案表示为一个 4 字符的字符串，该字符串表示总线从第 3 位到第 0 位的值。", "solution": "该总线使用一种分辨类型，其分辨函数根据严格顺序 $\\text{'U'}\\text{'X'}\\text{'1'}\\text{'0'}\\text{'Z'}$，对每一位独立地选择优先级最高的驱动值。信号变化是瞬时的，因此在 $t=25\\,\\text{ns}$ 时，有效的驱动值是在 $t=20\\,\\text{ns}$ 的最后一个事件之后生效的值。因此，主设备驱动如下：\n- $M1$：\"Z110\"（在 $t=20\\,\\text{ns}$ 时改变），\n- $M2$：\"ZZ01\"（始终未变），\n- $M3$：\"X10X\"（在 $t=10\\,\\text{ns}$ 时改变）。\n\n从最高有效位（第 3 位）到最低有效位（第 0 位）分辨每一位：\n- 第 3 位：$M1=\\text{'Z'}$, $M2=\\text{'Z'}$, $M3=\\text{'X'}$；存在的最高优先级是 $\\text{'X'}$，所以第 3 位 = $\\text{'X'}$。\n- 第 2 位：$M1=\\text{'1'}$, $M2=\\text{'Z'}$, $M3=\\text{'1'}$；存在的最高优先级是 $\\text{'1'}$，所以第 2 位 = $\\text{'1'}$。\n- 第 1 位：$M1=\\text{'1'}$, $M2=\\text{'0'}$, $M3=\\text{'0'}$；存在的最高优先级是 $\\text{'1'}$，所以第 1 位 = $\\text{'1'}$。\n- 第 0 位：$M1=\\text{'0'}$, $M2=\\text{'1'}$, $M3=\\text{'X'}$；存在的最高优先级是 $\\text{'X'}$，所以第 0 位 = $\\text{'X'}$。\n\n因此，在 $t=25\\,\\text{ns}$ 时，从第 3 位到第 0 位的分辨后的 4 位总线值为 \"X11X\"。", "answer": "$$\\boxed{X11X}$$", "id": "1976728"}]}