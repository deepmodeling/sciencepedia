{"hands_on_practices": [{"introduction": "第一个练习专注于非阻塞赋值 (`<=`) 的核心机制。在时序逻辑进程中，所有非阻塞赋值的右侧表达式都会首先使用时钟边沿处存在的值进行计算，然后左侧的寄存器才会被更新。这个练习将帮助你预测这种并发更新的结果，这是建模同步逻辑的一项基本技能。[@problem_id:1915845]", "problem": "在一个使用Verilog硬件描述语言（HDL）指定的数字电路设计中，一个名为`vec`的4位寄存器被声明为`reg [3:0] vec;`。在时间`t = 0`时，该寄存器持有初始值`4'b0010`。更新该寄存器的逻辑在一个对时钟信号`clk`的上升沿敏感的时钟进程中实现，如下面的代码片段所示：\n\n```verilog\nalways @(posedge clk) begin\n  vec[1:0] <= 2'b11;\n  vec[3:2] <= vec[1:0];\nend\n```\n\n假设系统从给定的初始值开始，并且第一个时钟上升沿发生在时间`t_1 > 0`，请确定在此第一个时钟沿之后，寄存器`vec`的二进制值。\n\nA. `4'b0010`\n\nB. `4'b0011`\n\nC. `4'b1011`\n\nD. `4'b1111`", "solution": "我们有一个4位寄存器，其初始值为 vec = 0010，即$vec[3:0] = (0,0,1,0)$，因此在$t=0$时，$vec[1:0] = (1,0)$ 且 $vec[3:2] = (0,0)$。\n\n在时间$t_{1}$的第一个clk上升沿，该进程执行两个非阻塞赋值。非阻塞赋值（$\\leq$）的语义是：\n- 所有的右侧表达式都使用时钟边沿前（旧）的值进行求值。\n- 在所有求值完成后，所有的左侧变量被并发更新。\n\n因此，在上升沿时：\n1) 第一个赋值的右侧是一个常量，因此它调度\n$$vec[1:0] \\gets (1,1)。$$\n2) 第二个赋值的右侧是$vec[1:0]$的旧值，即$(1,0)$，因此它调度\n$$vec[3:2] \\gets (1,0)。$$\n\n在两个被调度的更新并发地生效后，新的寄存器值为\n$$vec[3:0] = (1,0,1,1)，$$\n即二进制值1011，也就是选项C。", "answer": "$$\\boxed{C}$$", "id": "1915845"}, {"introduction": "在掌握了非阻塞赋值的基本行为后，我们现在将知识应用于一个实际的设计场景：一个优先编码器。硬件描述语言 (HDL) 设计中的一个关键经验法则是，对时序逻辑使用非阻塞赋值 (`<=`)，而对组合逻辑则使用阻塞赋值 (`=`)。这个练习要求你为一个组合电路找出正确的实现方式，从而强调为何这条规则对于创建可预测和可综合的硬件至关重要。[@problem_id:1915902]", "problem": "一名初级数字设计工程师的任务是使用 Verilog 创建一个 4-2 优先编码器。该编码器有一个 4 位数据输入 `d[3:0]`、一个 2 位编码输出 `y[1:0]` 和一个 1 位有效输出 `v`。该电路应按如下方式工作：\n\n-   输出 `y` 应表示输入 `d` 中为高电平的最高有效位 (MSB) 的二进制索引。优先级从 MSB 到 LSB，即 `d[3]` 优先级最高，`d[0]` 优先级最低。\n-   如果 `d[3]` 为高电平，`y` 应为 `2'b11`。\n-   如果 `d[3]` 为低电平但 `d[2]` 为高电平，`y` 应为 `2'b10`。\n-   如果 `d[3]` 和 `d[2]` 为低电平但 `d[1]` 为高电平，`y` 应为 `2'b01`。\n-   如果 `d[3]`、`d[2]` 和 `d[1]` 为低电平但 `d[0]` 为高电平，`y` 应为 `2'b00`。\n-   如果 `d` 中至少有一位为高电平，则有效位 `v` 应为高电平。如果 `d` 为 `4'b0000`，则 `v` 应为低电平，且 `y` 的值无关紧要（无关项）。\n\n该工程师使用单个组合逻辑 `always @(*)` 块编写了初始实现。然而，在仿真过程中，输出 `y` 和 `v` 未能在与输入 `d` 相同的仿真时间步内正确更新，导致在集成到更庞大的系统中时出现功能性故障。\n\n您的任务是从以下选项中找出描述纯组合逻辑优先编码器的正确实现，该实现能在仿真和综合中可靠地产生正确输出。\n\nA.\n```verilog\nalways @(*) begin\n  if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nB.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y <= 2'b11;\n    v <= 1'b1;\n  end else if (d[2]) begin\n    y <= 2'b10;\n    v <= 1'b1;\n  end else if (d[1]) begin\n    y <= 2'b01;\n    v <= 1'b1;\n  end else if (d[0]) begin\n    y <= 2'b00;\n    v <= 1'b1;\n  end else begin\n    y <= 2'b00; // a 'don't care' value\n    v <= 1'b0;\n  end\nend\n```\n\nC.\n```verilog\nalways @(*) begin\n  if (d[3]) begin\n    y = 2'b11;\n    v = 1'b1;\n  end else if (d[2]) begin\n    y = 2'b10;\n    v = 1'b1;\n  end else if (d[1]) begin\n    y = 2'b01;\n    v = 1'b1;\n  end else if (d[0]) begin\n    y = 2'b00;\n    v = 1'b1;\n  end else begin\n    y = 2'b00; // a 'don't care' value\n    v = 1'b0;\n  end\nend\n```\n\nD.\n```verilog\nalways @(*) begin\n  casex (d)\n    4'b1xxx: y = 2'b11;\n    4'b01xx: y = 2'b10;\n    4'b001x: y = 2'b01;\n    4'b0001: y = 2'b00;\n    default: y = 2'b00; // a 'don't care' value\n  endcase\n  \n  if (d != 4'b0) begin\n    v = 1'b1;\n  end else begin\n    v = 1'b0;\n  end\nend\n```\n\nE.\n```verilog\nalways @(*) begin\n  y = 2'b00; // Default assignment\n  v = 1'b0;  // Default assignment\n  if (d[3]) begin\n    y <= 2'b11;\n    v <= 1'b1;\n  end else if (d[2]) begin\n    y <= 2'b10;\n    v <= 1'b1;\n  end else if (d[1]) begin\n    y <= 2'b01;\n    v <= 1'b1;\n  end else if (d[0]) {v, y} <= {1'b1, 2'b00};\nend\n```", "solution": "我们需要一个纯组合逻辑的优先编码器，它需要满足：\n- 给予 MSB 优先：先检查 $d[3]$，然后是 $d[2]$，接着是 $d[1]$，最后是 $d[0]$。\n- 在所有分支中都驱动两个输出，以避免产生锁存器。\n- 在组合逻辑 always 块中使用阻塞赋值，以便输出能在同一仿真时间步（delta 周期）内反映输入的变化。在组合逻辑中使用非阻塞赋值会延迟更新，从而产生所描述的仿真问题。\n\n评估每个选项：\n\nA. 该选项在组合逻辑块中使用了阻塞赋值，但它从 LSB 检查到 MSB。如果多个位为高电平，它将错误地将 $d[0]$ 的优先级置于 $d[3]$ 之上，违反了要求的 MSB 优先原则。因此，A 是错误的。\n\nB. 该选项在组合逻辑 always 块中使用了非阻塞赋值。非阻塞赋值会将更新推迟到时间步结束时，这可能导致与其他逻辑集成时，输出无法在同一仿真时间步内按预期更新。这与报告的故障模式相符，因此 B 不是正确的修复方案。\n\nC. 该选项在组合逻辑 always 块中使用了阻塞赋值，并采用了正确的 MSB 到 LSB 优先级顺序。所有输出在所有分支中都被赋值，因此不会推断出锁存器。这是在仿真和综合中实现组合逻辑优先编码器的标准、可靠的风格。\n\nD. 该选项使用 casex 进行优先级判断，并使用一个单独的条件语句来处理有效位。虽然这是组合逻辑且可综合，但 casex 可能会引入仿真与综合不匹配的问题并掩盖未知状态（unknowns），而使用四值比较来单独计算有效位在存在未知状态时可能会产生意外行为。题目要求一个可靠且正确的实现；与使用阻塞赋值的直接 if-else 链相比，通常不鼓励使用这种风格。\n\nE. 该选项在同一个组合逻辑 always 块中混合使用了阻塞赋值（默认值）和非阻塞赋值（条件更新），这是一种已知的坏习惯，会导致竞争条件和同样的仿真时序问题。因此，E 是错误的。\n\n因此，正确的实现是 C。", "answer": "$$\\boxed{C}$$", "id": "1915902"}, {"introduction": "虽然使用阻塞和非阻塞赋值的规则看似清晰，但当它们在同一个时序逻辑块中混合使用时会发生什么呢？最后一个练习探讨了一种常见但危险的编码实践。通过追踪这个假设情景中的信号，你将揭示由此产生的微妙时序问题，并理解为什么混合赋值类型会导致意外行为和设计缺陷。[@problem_id:1915859]", "problem": "在 Verilog 数字逻辑设计中，时钟过程块内阻塞赋值（`=`）与非阻塞赋值（`<=`）之间的区别对于描述预期的硬件至关重要。请看下面的 Verilog 模块代码片段：\n\n```verilog\nmodule mixed_assignments (\n  input  wire       clk,\n  input  wire       rst_n, // active-low asynchronous reset\n  input  wire       data_in,\n  output reg        data_out\n);\n\n  reg temp;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      temp <= 1'b0;\n      data_out <= 1'b0;\n    end else begin\n      temp <= data_in;\n      data_out = temp;\n    end\n  end\n\nendmodule\n```\n\n一系列事件被施加到该模块的输入端。时钟信号 `clk` 的周期为 20 ns，其上升沿发生在 `t = 10, 30, 50, 70, ...` ns。复位信号 `rst_n` 在 `t < 5` ns 期间有效（低电平），在 `t \\ge 5` ns 期间无效（高电平）。输入 `data_in` 保持为 0，但在 `25 \\text{ ns} \\le t < 45 \\text{ ns}` 期间存在一个值为 1 的脉冲。\n\n在 `t = 40` ns、`t = 60` ns 和 `t = 80` ns 时，输出信号 `data_out` 的值分别是多少？\n\nA. 1, 0, 0\n\nB. 0, 1, 0\n\nC. 0, 0, 1\n\nD. 1, 1, 0\n\nE. 0, 0, 0", "solution": "要解决此问题，我们必须追踪寄存器 `temp` 和 `data_out` 在几个时钟周期内的值，并密切关注 `always` 块内阻塞（`=`）和非阻塞（`<=`）赋值的规则。\n\n`always` 块对 `clk` 的上升沿和 `rst_n` 的下降沿敏感。由于复位信号 `rst_n` 在所有 `t \\ge 5` ns 的时间内都是无效的，因此在所有相关的时钟沿，`else` 块都将被执行。\n\n`else` 块包含两条语句：\n1. `temp <= data_in;`（非阻塞赋值）\n2. `data_out = temp;`（阻塞赋值）\n\nVerilog 仿真按时间步进。在一个时钟沿，`always` 块内的语句被执行。\n- 对于非阻塞赋值（`<=`），右侧（RHS）表达式被求值，而对左侧（LHS）的更新被调度在当前仿真时间步的末尾发生，即在所有阻塞赋值都完成之后。\n- 对于阻塞赋值（`=`），右侧表达式被求值，左侧立即被更新，这会阻塞任何后续语句的执行，直到该赋值完成。\n\n让我们逐个周期地追踪信号。\n初始状态（由于 `t < 5` ns 时的复位）：\n在 `t=0` 时，`rst_n` 为低电平。满足复位条件 `if (!rst_n)`。\n`temp` 被设为 0。`data_out` 被设为 0。两者都是非阻塞赋值，因此它们在复位事件结束时生效。\n在 `t=10` ns 第一个时钟沿之前的状态：`temp = 0`，`data_out = 0`。\n\n输入 `data_in` 波形分析：\n- 在 `t=10` ns 时，`data_in = 0`。\n- 在 `t=30` ns 时，`data_in = 1`（因为 `25 \\le 30 < 45`）。\n- 在 `t=50` ns 时，`data_in = 0`（因为 `t \\ge 45`）。\n- 在 `t=70` ns 时，`data_in = 0`。\n\n**周期 1：`t = 10` ns 时的 `posedge clk`**\n- `data_in` 的值为 0。\n- 此时间步开始时 `temp` 的值为 0。\n- `temp <= data_in;`：右侧 `data_in` 为 0。赋值 `temp = 0` 被调度到时间步结束时执行。\n- `data_out = temp;`：右侧 `temp` 被求值。其当前值为 0（来自此时钟沿之前的值）。`data_out` 立即更新为 0。\n- 在时间步结束时，被调度的非阻塞赋值完成：`temp` 更新为 0。\n- **`t=10` ns 之后的状态：** `temp = 0`，`data_out = 0`。\n\n**周期 2：`t = 30` ns 时的 `posedge clk`**\n- `data_in` 的值为 1。\n- 此时间步开始时 `temp` 的值为 0。\n- `temp <= data_in;`：右侧 `data_in` 为 1。赋值 `temp = 1` 被调度。\n- `data_out = temp;`：右侧 `temp` 被求值。其当前值为 0。`data_out` 立即更新为 0。\n- 在时间步结束时，被调度的赋值完成：`temp` 更新为 1。\n- **`t=30` ns 之后的状态：** `temp = 1`，`data_out = 0`。\n\n**在 `t = 40` ns 时的求值：**\n`data_out` 的值由上一次在 `t=30` ns 发生的赋值决定。在 `t=40` ns 时，`data_out` 为 **0**。\n\n**周期 3：`t = 50` ns 时的 `posedge clk`**\n- `data_in` 的值为 0。\n- 此时间步开始时 `temp` 的值为 1。\n- `temp <= data_in;`：右侧 `data_in` 为 0。赋值 `temp = 0` 被调度。\n- `data_out = temp;`：右侧 `temp` 被求值。其当前值为 1。`data_out` 立即更新为 1。\n- 在时间步结束时，被调度的赋值完成：`temp` 更新为 0。\n- **`t=50` ns 之后的状态：** `temp = 0`，`data_out = 1`。\n\n**在 `t = 60` ns 时的求值：**\n`data_out` 的值是在 `t=50` ns 时设置的值。在 `t=60` ns 时，`data_out` 为 **1**。\n\n**周期 4：`t = 70` ns 时的 `posedge clk`**\n- `data_in` 的值为 0。\n- 此时间步开始时 `temp` 的值为 0。\n- `temp <= data_in;`：右侧 `data_in` 为 0。赋值 `temp = 0` 被调度。\n- `data_out = temp;`：右侧 `temp` 被求值。其当前值为 0。`data_out` 立即更新为 0。\n- 在时间步结束时，被调度的赋值完成：`temp` 更新为 0。\n- **`t=70` ns 之后的状态：** `temp = 0`，`data_out = 0`。\n\n**在 `t = 80` ns 时的求值：**\n`data_out` 的值是在 `t=70` ns 时设置的值。在 `t=80` ns 时，`data_out` 为 **0**。\n\n综合结果，`data_out` 在 `t = 40, 60, 80` ns 时的值是 (0, 1, 0)。这对应于选项 B。\n\n这种行为可以总结如下：在每个时钟沿 `N`，`data_out` 获取 `temp` 在该周期开始时的值。而这个 `temp` 的值是在前一个时钟沿 `N-1` 由 `data_in` 设置的。这就创建了一个两级流水线，其中第一级（`temp`）的值通过阻塞赋值被第二级（`data_out`）读取。实际效果是 `data_out` 比 `data_in` 延迟两个时钟周期。让我们从逻辑上重新验证这个分析。`data_out(N) = temp(N,begin) = temp(N-1,end)`。然而，`temp(N-1,end)` 在周期 `N-1` 并未被 `data_out` 读出。周期 `N-1` 的 `data_out` 读取了 `temp(N-1,begin)`。所以 `data_out` 得到的是一个周期前的 `temp` 的值，而 `temp` 得到的是一个周期前的 `data_in` 的值。这意味着 `data_out(N) = temp(N-1) = data_in(N-2)`。这是一个两周期的延迟。\n\n让我们根据一个两周期延迟模型来检查追踪结果。`out_N = in_{N-2}`。\n- `out(30) = in(-10) = 0`。\n- `out(50) = in(10) = 0`。\n- `out(70) = in(30) = 1`。\n序列 `(out(30), out(50), out(70))` 将是 `(0, 0, 1)`。这对应于选项 C。\n\n让我们重新审视一下逻辑。这个错误是微妙的。\n在 `posedge clk` 周期 `N`：\n1. `temp <= data_in(N)`：采样 `data_in(N)` 的值。`temp` 将在时间步结束时更新为此值。\n2. `data_out = temp`：`data_out` *立即*用周期 `N` *开始时* `temp` 的值进行更新。这个值是 `temp_at_begin(N)`。\n\n那么，`temp_at_begin(N)` 是什么？它是前一个时钟周期 `N-1` 结束后 `temp` 所持有的值。\n在周期 `N-1`，发生了赋值 `temp <= data_in(N-1)`。这意味着在周期 `N-1` 结束时，`temp` 被更新为 `data_in(N-1)`。\n所以，`temp_at_begin(N) = data_in(N-1)`。\n\n将此代回到 `data_out` 的表达式中：\n`data_out(N) = temp_at_begin(N) = data_in(N-1)`。\n这是一个单周期延迟。\n\n让我们基于单周期延迟模型 `out_N = in_{N-1}` 重新进行追踪。\n- 在时钟沿 10, 30, 50, 70 时的 `in` 向量：`(0, 1, 0, 0)`\n- 在时钟沿 `N` 的 `out` 将是 `N-1` 时的 `in`。\n- `out(10) = in(t<10) = 0`。\n- `out(30) = in(10) = 0`。\n- `out(50) = in(30) = 1`。\n- `out(70) = in(50) = 0`。\n在上升沿 `10, 30, 50, 70` 设置的 `data_out` 值序列是 `0, 0, 1, 0`。\n- 在 `t=40` 时，`data_out` 保持在 `t=30` 时设置的值，即 0。\n- 在 `t=60` 时，`data_out` 保持在 `t=50` 时设置的值，即 1。\n- 在 `t=80` 时，`data_out` 保持在 `t=70` 时设置的值，即 0。\n最终序列是 (0, 1, 0)。追踪结果终究是正确的，但最初的逻辑推理是混乱的，而这正是问题的关键所在。\n\n最终值：\n- `data_out` 在 `t=40` ns 时为 0。\n- `data_out` 在 `t=60` ns 时为 1。\n- `data_out` 在 `t=80` ns 时为 0。\n序列是 (0, 1, 0)。", "answer": "$$\\boxed{B}$$", "id": "1915859"}]}