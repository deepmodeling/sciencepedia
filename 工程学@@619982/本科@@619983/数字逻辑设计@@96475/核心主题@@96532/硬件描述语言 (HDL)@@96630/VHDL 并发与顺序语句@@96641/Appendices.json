{"hands_on_practices": [{"introduction": "掌握时序逻辑是数字设计的核心。本练习将指导你构建一个带异步复位的基本计数器 [@problem_id:1976164]。通过这个实践，你将学习到如何正确使用 VHDL 的 `PROCESS` 语句、定义敏感列表以及实现独立于时钟的复位逻辑，这是所有复杂时序电路设计的基础。", "problem": "您的任务是为一个数字系统设计一个超高速集成电路硬件描述语言 (VHDL) 组件。该组件是一个3位二进制递减计数器，具有以下规格：\n- 它有一个时钟输入 `clk`。\n- 它有一个低电平有效的异步复位输入 `rst_n`。\n- 它有一个3位输出 `q_out`。\n\n计数器的行为必须如下：\n1.  当复位信号 `rst_n` 被断言（即 `rst_n` 为逻辑'0'）时，输出 `q_out` 必须立即并异步地被设置为值 `111`。\n2.  当复位未被断言时，在时钟 `clk` 的每个上升沿，计数器的值必须减一。\n3.  计数器应该回卷。也就是说，当它从 `000` 递减时，下一个状态应该是 `111`。\n\n假设提供了以下 VHDL 上下文：\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\nUSE ieee.numeric_std.ALL;\n\nENTITY down_counter IS\n  PORT (\n    clk   : IN  std_logic;\n    rst_n : IN  std_logic;\n    q_out : OUT std_logic_vector(2 DOWNTO 0)\n  );\nEND ENTITY down_counter;\n\nARCHITECTURE behavioral OF down_counter IS\n  SIGNAL q_reg : unsigned(2 DOWNTO 0);\nBEGIN\n\n  -- A VHDL process block goes here --\n  \n  q_out <= std_logic_vector(q_reg);\n\nEND ARCHITECTURE behavioral;\n```\n\n以下哪个 VHDL `PROCESS` 模块，在插入到上述架构中时，能正确实现指定的3位递减计数器？\n\nA.\n```vhdl\ncounter_proc : PROCESS (clk)\nBEGIN\n  IF rising_edge(clk) THEN\n    IF rst_n = '0' THEN\n      q_reg <= \"111\";\n    ELSE\n      q_reg <= q_reg - 1;\n    END IF;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nB.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '1' THEN\n    q_reg <= \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg <= q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nC.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg <= \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg <= q_reg + 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nD.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg <= \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg <= q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nE.\n```vhdl\ncounter_proc : PROCESS (clk, q_reg)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg <= \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg <= q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```", "solution": "我们识别出所需的行为，并将其映射到 VHDL 进程结构和敏感性要求：\n\n1) 异步、低电平有效复位：\n- 异步复位意味着进程必须对复位信号敏感，并且当复位条件满足时，无论时钟沿如何，都必须立即赋以复位值。因此，进程敏感列表必须同时包含时钟和复位信号，即必须包含`clk`和`rst_n`。\n- 低电平有效意味着复位操作必须在`rst_n = '0'`时发生。\n- 异步复位的标准 VHDL 模板是将复位条件作为时钟沿检测前的第一个分支：`IF rst_n = '0' THEN` 复位操作; `ELSIF rising_edge(clk) THEN` 序贯操作; `END IF`。\n\n2) 在时钟上升沿递减：\n- 当复位未被断言时，计数器必须在`clk`的每个上升沿减一：这要求`ELSIF rising_edge(clk)`分支执行`q_reg <- q_reg - 1`。\n\n3) 从`000`回卷到`111`：\n- 使用`ieee.numeric_std`库的`unsigned`类型，对一个固定位宽的无符号向量执行`q_reg - 1`操作会以模$2^{3}$的方式回卷。因此，`000 - 1`会自动变为`111`，无需额外逻辑即可满足回卷要求。\n\n现在根据这些要求评估每个选项：\n\n- 选项A：进程敏感列表只包含`clk`，且复位检查位于上升沿分支内部。这实现的是同步复位，而非异步复位。因此，它不满足异步复位要求。\n\n- 选项B：敏感列表包含了`clk`和`rst_n`，但它在`rst_n = '1'`时复位。这实现的是高电平有效复位，与低电平有效的要求相矛盾。\n\n- 选项C：敏感列表和低电平有效异步复位的位置正确，但时钟触发的操作是递增`q_reg <- q_reg + 1`，而不是递减。这违反了指定的行为。\n\n- 选项D：敏感列表包含`clk`和`rst_n`。第一个分支在`rst_n = '0'`时复位（低电平有效，异步），而`ELSIF rising_edge(clk)`分支执行`q_reg <- q_reg - 1`，该操作以正确的模$2^{3}$回卷方式进行递减。这符合所有要求。\n\n- 选项E：敏感列表错误地使用了` (clk, q_reg)`且省略了`rst_n`，因此`rst_n`的变化不会触发该进程，这违反了异步复位要求。\n\n因此，唯一正确实现指定3位递减计数器的选项是D。", "answer": "$$\\boxed{D}$$", "id": "1976164"}, {"introduction": "真实世界的数字系统通常需要处理多个控制信号，例如加载、使能和同步复位。本练习 [@problem_id:1976148] 让你设计一个功能更丰富的同步计数器，它需要在时钟边沿根据控制信号的优先级来决定执行加载、复位还是计数操作。这个任务将深化你对 `IF/ELSIF` 结构如何综合成硬件优先级逻辑的理解。", "problem": "你的任务是使用VHSIC硬件描述语言（VHDL）设计一个数字计数器组件。该组件必须用作一个8位同步递增计数器，具有同步并行加载和同步复位功能。\n\n该组件的实体定义如下：\n```vhdl\nENTITY counter_8bit IS\n  PORT (\n    CLK   : IN  STD_LOGIC;                      -- System Clock\n    RST   : IN  STD_LOGIC;                      -- Synchronous Reset, active-high\n    LOAD  : IN  STD_LOGIC;                      -- Synchronous Load Enable, active-high\n    D_IN  : IN  STD_LOGIC_VECTOR(7 DOWNTO 0);   -- 8-bit data input for parallel load\n    Q_OUT : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)    -- 8-bit counter output\n  );\nEND ENTITY counter_8bit;\n```\n\n计数器的行为必须在时钟`CLK`的上升沿遵循以下优先级：\n1.  **复位：** 如果`RST`为高电平（'1'），计数器输出`Q_OUT`必须被设置为全零（`\"00000000\"`）。\n2.  **加载：** 如果`RST`为低电平（'0'）且`LOAD`为高电平（'1'），计数器输出`Q_OUT`必须加载来自并行数据输入`D_IN`的值。\n3.  **计数：** 如果`RST`和`LOAD`均为低电平（'0'），计数器输出`Q_OUT`必须将其当前值加一。\n4.  **保持：** 如果没有满足任何活动条件，计数器应隐式保持其值，直到下一个时钟上升沿。\n\n假设所有必需的库（`ieee.std_logic_1164.all`和`ieee.numeric_std.all`）都已包含。\n\n以下哪个VHDL架构实现正确地描述了指定的行为？\n\n**A.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK)\n  BEGIN\n    IF rising_edge(CLK) THEN\n      IF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSIF RST = '1' THEN\n        Q_OUT <= (OTHERS => '0');\n      ELSE\n        Q_OUT <= STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1);\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```\n\n**B.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK)\n  BEGIN\n    IF rising_edge(CLK) THEN\n      IF RST = '1' THEN\n        Q_OUT <= (OTHERS => '0');\n      ELSIF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSE\n        Q_OUT <= Q_OUT + 1;\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```\n\n**C.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK)\n  BEGIN\n    IF rising_edge(CLK) THEN\n      IF RST = '1' THEN\n        Q_OUT <= (OTHERS => '0');\n      ELSIF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSE\n        Q_OUT <= STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1);\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```\n\n**D.**\n```vhdl\nARCHITECTURE behavioral OF counter_8bit IS\nBEGIN\n  PROCESS(CLK, RST)\n  BEGIN\n    IF RST = '1' THEN\n      Q_OUT <= (OTHERS => '0');\n    ELSIF rising_edge(CLK) THEN\n      IF LOAD = '1' THEN\n        Q_OUT <= D_IN;\n      ELSE\n        Q_OUT <= STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1);\n      END IF;\n    END IF;\n  END PROCESS;\nEND ARCHITECTURE behavioral;\n```", "solution": "我们将`CLK`上升沿所需的同步行为形式化为8位输出向量`Q_OUT`的次态函数：\n$$\nQ^{+} =\n\\begin{cases}\n(0,0,0,0,0,0,0,0) & \\text{if } RST = '1', \\\\\nD_{\\text{IN}} & \\text{if } RST = '0' \\text{ and } LOAD = '1', \\\\\n\\text{STD\\_LOGIC\\_VECTOR}\\big(\\text{UNSIGNED}(Q_{\\text{OUT}}) + 1\\big) & \\text{if } RST = '0' \\text{ and } LOAD = '0'.\n\\end{cases}\n$$\n在上升沿之间，寄存器会隐式地保持其值。优先级是`RST`高于`LOAD`，并且两者都是同步的，这意味着它们必须在`rising_edge(CLK)`分支内进行评估。增量操作必须使用`numeric_std`类型，即将`Q_OUT`转换为`UNSIGNED`类型进行加法运算，然后再转换回`STD_LOGIC_VECTOR`类型。\n\n评估每个选项：\n\n- 选项A在`rising_edge(CLK)`内部先检查`LOAD`再检查`RST`。如果`RST = '1'`且`LOAD = '1'`，它会加载`D_IN`而不是复位，这违反了`RST`必须占主导地位的指定优先级。因此A是错误的。\n\n- 选项B正确地评估了优先级（先`RST`后`LOAD`），但计数分支使用`Q_OUT <= Q_OUT + 1`，其中`Q_OUT`的类型是`STD_LOGIC_VECTOR`。在`ieee.numeric_std.all`库下，运算符`+`没有为`STD_LOGIC_VECTOR`定义；它需要`UNSIGNED`或`SIGNED`类型。因此，这段代码本身是无效的，不符合给定的库假设。因此B是错误的。\n\n- 选项C先评估`RST`，然后是`LOAD`，这与优先级匹配，并以`STD_LOGIC_VECTOR(UNSIGNED(Q_OUT) + 1)`的方式执行增量，这在`numeric_std`下是正确的。该进程只对`CLK`敏感，因此复位和加载都是同步的。因此C正确实现了指定的行为。\n\n- 选项D将`RST`放在敏感列表中，并在`rising_edge(CLK)`检查之外应用它，这使得复位成为异步的。要求是同步复位，所以D是错误的。\n\n因此，唯一符合所有指定要求的架构是选项C。", "answer": "$$\\boxed{C}$$", "id": "1976148"}, {"introduction": "优秀的 VHDL 代码不仅要功能正确，还要能综合出高效的硬件。本练习 [@problem_id:1976143] 提供了一段复位信号优先级不当的代码，并要求你预测其综合后的硬件结构。通过分析这种次优代码的后果，你将学会如何编写对综合工具更友好的代码，从而避免不必要的逻辑延迟，设计出性能更佳的电路。", "problem": "一位数字系统工程师正在使用 VHSIC 硬件描述语言 (VHDL) 设计一个组件。该组件是一个 8 位寄存器，带有一个同步高电平有效复位 (`sync_reset`) 和一个高电平有效加载使能 (`load_en`)。该寄存器由 `clk` 提供时钟。工程师在一个架构体中编写了以下 VHDL 代码。\n\n```vhdl\n-- Signal Declarations\nsignal clk         : std_logic;\nsignal sync_reset  : std_logic;\nsignal load_en     : std_logic;\nsignal data_in     : std_logic_vector(7 downto 0);\nsignal q           : std_logic_vector(7 downto 0);\n\n-- ...\n\n-- Process for the register\nREG_PROC: process(clk)\nbegin\n  if rising_edge(clk) then\n    if load_en = '1' then\n      q <= data_in;\n    elsif sync_reset = '1' then\n      q <= (others => '0');\n    else\n      q <= q; -- Hold current value\n    end if;\n  end if;\nend process REG_PROC;\n```\n\n当这段 VHDL 代码由综合工具处理以生成硬件时，嵌套 `if-elsif` 结构中编写的控制信号（`load_en` 和 `sync_reset`）的优先级直接影响最终生成的逻辑电路。假设一个标准的综合工具会严格按照代码的描述进行转换，以下哪个陈述为寄存器 `q` 及其输入逻辑的综合硬件提供了最准确的描述？\n\nA. 该代码综合成一个单独的 8 位寄存器。该寄存器的数据输入由一个 2 选 1 多路复用器提供，其选择线为 `load_en`。该多路复用器的 '1' 输入是 `data_in`。'0' 输入由第二个 2 选 1 多路复用器的输出提供，该复用器使用 `sync_reset` 作为其选择线，在一个恒定的零向量和当前寄存器输出 `q` 之间进行选择。\n\nB. 综合工具将识别其功能意图并优化代码。它将生成一个 8 位寄存器，带有一个连接到 `sync_reset` 的专用同步清零端口。寄存器的数据输入将由一个由 `load_en` 控制的 2 选 1 多路复用器提供，该复用器在 `data_in` 和当前寄存器输出 `q` 之间进行选择。\n\nC. 该代码综合成一个 8 位寄存器，其输入由一个单独的 3 选 1 多路复用器提供。该多路复用器的选择线由一个组合逻辑块形成，该逻辑块的输入是 `load_en` 和 `sync_reset`。多路复用器的数据输入是 `data_in`、一个恒定的零向量和当前寄存器输出 `q`。\n\nD. 该代码将综合失败，因为它描述了一个具有模糊优先级结构的硬件元件。在一个时钟进程中，同步复位必须始终是最高优先级的条件，才能被综合成一个标准的触发器。\n\nE. 该代码综合成一个包含一个 8 位锁存器和一个 8 位寄存器的结构。锁存器之所以被创建，是因为 `sync_reset` 条件没有在 `load_en` 信号状态的每个可能分支上被检查。", "solution": "目标是确定综合工具从给定的 VHDL 进程中创建的硬件结构。综合工具将时钟进程内的过程化代码映射成寄存器以及驱动其输入的组合逻辑。\n\n1.  **识别时序元件**：该 VHDL 进程只对时钟 `clk` 敏感，并且所有对 `q` 的信号赋值都发生在 `if rising_edge(clk) then ... end if;` 块内部。这种结构可靠地推断出一组边沿触发的触发器，信号 `q` 的每一位对应一个。由于 `q` 是一个 8 位向量 (`std_logic_vector(7 downto 0)`)，这将是一个 8 位寄存器。\n\n2.  **分析组合逻辑**：决定 `q` 的*下一个*状态（它成为触发器的 D 输入）的逻辑由嵌套的 `if-elsif-else` 语句描述。综合工具将此类优先级编码结构转换为一连串的多路复用器或等效的逻辑门。我们需要追踪其优先级。\n\n3.  **最高优先级条件**：在时钟块内检查的第一个条件是 `if load_en = '1' then`。这使得 `load_en` 具有最高优先级。\n    - 如果 `load_en` 是 '1'，`q` 的下一个值将是 `data_in`。\n    - 如果 `load_en` 是 '0'，逻辑将进入 `elsif` 部分。\n\n4.  **第二优先级条件**：下一个条件是 `elsif sync_reset = '1' then`。只有在 `load_en = '0'` 时才会评估此条件。\n    - 如果 `load_en` 是 '0' 且 `sync_reset` 是 '1'，`q` 的下一个值将是零向量 `(others => '0')`。\n    - 如果 `load_en` 是 '0' 且 `sync_reset` 是 '0'，逻辑将进入 `else` 部分。\n\n5.  **最低优先级条件（默认）**：`else` 子句 `q <= q;` 是默认操作。当 `load_en` 为 '0' 且 `sync_reset` 为 '0' 时执行此操作。`q <= q` 语句意味着寄存器应保持其当前值。\n\n6.  **综合成硬件模型**：我们现在可以构建为 8 位寄存器的 D 输入提供信号的组合逻辑电路，让我们称这个输入为 `d_next`。我们从最高优先级到最低优先级进行分析。\n\n    - 一个 2 选 1 多路复用器（我们称之为 MUX1）用于实现基于 `load_en` 的最高优先级决策。其选择线是 `load_en`。\n    - 当 `load_en = '1'` 时，MUX1 必须选择 `data_in`。所以，`data_in` 连接到 MUX1 的 '1' 输入。\n    - 当 `load_en = '0'` 时，MUX1 必须选择较低优先级逻辑的结果。这个较低优先级逻辑的输出将连接到 MUX1 的 '0' 输入。\n\n    - 现在，让我们设计为 MUX1 的 '0' 输入提供信号的较低优先级逻辑。该逻辑必须在 `load_en` 为 '0' 时决定做什么。该决策基于 `sync_reset`。\n    - 这需要另一个 2 选 1 多路复用器（我们称之为 MUX2）。它的选择线是 `sync_reset`。\n    - 当 `sync_reset = '1'` 时，MUX2 必须选择复位值，即 8 位零向量 `(others => '0')`。所以，常数 `0` 连接到 MUX2 的 '1' 输入。\n    - 当 `sync_reset = '0'` 时，MUX2 必须选择来自 `else` 子句的值，即寄存器的当前值 `q`。所以，寄存器 `q` 的输出被反馈到 MUX2 的 '0' 输入。\n\n7.  **组合各个部分**：MUX2 的输出为 MUX1 的 '0' 输入提供信号。MUX1 的输出为 8 位寄存器 `q` 的 D 输入提供信号。这种结构是一个级联的多路复用器链。这比理想情况（高优先级复位可以使用触发器上的专用清零输入）效率低，但它是对所提供 VHDL 代码的直接且正确的翻译。\n\n8.  **评估选项**：\n    *   **A**：“该代码综合成一个单独的 8 位寄存器。该寄存器的数据输入由一个 2 选 1 多路复用器提供，其选择线为 `load_en`。该多路复用器的 '1' 输入是 `data_in`。'0' 输入由第二个 2 选 1 多路复用器的输出提供，该复用器使用 `sync_reset` 作为其选择线，在一个恒定的零向量和当前寄存器输出 `q` 之间进行选择。” 这个描述与步骤 6 和 7 中推导出的硬件完全匹配。\n    *   **B**：这是不正确的。虽然这是*期望的*且更优化的结构，但综合工具将遵循代码中指定的优先级。代码明确地将 `load_en` 置于比 `sync_reset` 更高的优先级，这在这种直接的翻译中阻止了工具使用专用的复位引脚。\n    *   **C**：一个 3 选 1 多路复用器是实现此逻辑的一种可能性，但级联的 2 选 1 多路复用器结构是对嵌套 `if-elsif-else` 优先级结构更直接、更字面的表示。选项 A 是对这种优先级编码更精确的描述。\n    *   **D**：这是不正确的。该代码对于综合来说是完全有效的 VHDL。它可能会导致次优的硬件（额外的逻辑导致更长的传播延迟），但它并不模糊，并且能够正确综合。\n    *   **E**：这是不正确的。当一个信号在组合逻辑进程的所有可能分支中没有被赋值时，会推断出锁存器。在这个时钟进程中，`else q <= q;` 子句确保了 `q` 在每个时钟上升沿总是被赋值，从而防止了锁存器的推断。\n\n因此，选项 A 是对综合硬件最准确的描述。", "answer": "$$\\boxed{A}$$", "id": "1976143"}]}