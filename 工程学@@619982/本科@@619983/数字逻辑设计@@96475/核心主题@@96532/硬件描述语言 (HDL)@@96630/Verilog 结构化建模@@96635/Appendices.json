{"hands_on_practices": [{"introduction": "这个练习将引导你使用结构化建模构建一个单比特算术逻辑单元（ALU）的基本片元。通过实例化一个预定义的全加器模块并结合基本逻辑门，你将学习如何构建一个可以根据控制信号 $op$ 执行不同操作（加法或异或）的电路。这项实践是掌握层次化设计方法的关键一步，它展示了如何将简单的、可重用的组件集成为更复杂的、功能更丰富的系统 [@problem_id:1964327]。", "problem": "您的任务是创建一个名为 `ALU_slice` 的 1 位处理切片 Verilog 模块。该模块应通过实例化门级原语和一个已提供的 `full_adder` 模块，使用结构化建模来实现。\n\n**模块规范：**\n\n`ALU_slice` 模块具有以下端口：\n- 输入：`a` (1位)、`b` (1位)、`cin` (1位进位输入)、`op` (1位操作选择)。\n- 输出：`result` (1位)、`cout` (1位进位输出)。\n\n**功能行为：**\n\n该模块必须根据 `op` 信号执行两种操作之一：\n1.  如果 `op` 为 `0`，模块执行逻辑异或（XOR）操作。\n    - `result` 应为 `a XOR b`。\n    - `cout` 应为 `0`。\n2.  如果 `op` 为 `1`，模块执行算术加法（ADD）操作。\n    - `result` 应为 `a`、`b` 和 `cin` 的和。\n    - `cout` 应为加法产生的进位输出。\n\n**结构约束：**\n\n您的设计必须在结构上实例化并连接以下组件：\n- 一个 `full_adder` 模块（Verilog 代码如下所示）。\n- 一个用于逻辑操作的原语 `xor` 门。\n- 一个用于正确生成最终 `cout` 信号的原语 `and` 门。\n- 一个等效于 2-1 多路选择器的逻辑电路，由原语 `and`、`or`、`not` 门构成，用于选择最终的 `result`。\n\n**提供的 `full_adder` 模块：**\n\n您必须使用以下 `full_adder` 模块，不得修改。\n\n```verilog\n// full_adder module\n// Outputs: sum, cout\n// Inputs: x, y, z\nmodule full_adder(sum, cout, x, y, z);\n  output sum, cout;\n  input  x, y, z;\n  wire   w1, w2, w3;\n\n  xor(w1, x, y);\n  xor(sum, w1, z);\n  and(w2, x, y);\n  and(w3, w1, z);\n  or(cout, w2, w3);\nendmodule\n```\n\n**问题：**\n\n下列哪个 Verilog 代码块根据所有规范正确实现了 `ALU_slice` 模块？\n\n**A.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, fa_sum, s_not); // MUX path for op=0 connected to fa_sum\n  and A2(w1, xor_out, op);   // MUX path for op=1 connected to xor_out\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**B.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  assign cout = fa_cout; // Incorrect cout logic\nendmodule\n```\n\n**C.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not); // MUX path for op=0\n  and A2(w1, fa_sum, op);     // MUX path for op=1\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**D.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  // Incorrect port mapping for full_adder\n  full_adder FA(fa_sum, fa_cout, a, b, op); \n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```", "solution": "我们需要一个 1 位 ALU 切片，在 $op$ 的控制下，在以下两者之间进行选择：\n- 当 $op=0$ 时进行逻辑异或：$result = a \\oplus b$，$cout=0$。\n- 当 $op=1$ 时进行算术加法：$result = sum(a,b,cin)$，$cout = carry\\_out(a,b,cin)$。\n\n设全加器的输出为 $fa\\_sum$ 和 $fa\\_cout$，输入为 $(a,b,cin)$，因此：\n- $fa\\_sum$ 是 $a+b+cin$ 的和位，\n- $fa\\_cout$ 是进位输出位。\n\n我们还实例化一个原语 XOR 门，产生 $xor\\_out = a \\oplus b$。\n\n最终的 $result$ 必须由一个用原语门构建的 $2$-对-$1$ 多路选择器来选择，以满足：\n$$\nresult = (\\lnot op) \\cdot (a \\oplus b) \\;\\; \\lor \\;\\; op \\cdot fa\\_sum.\n$$\n这在结构上通过一个 NOT 门形成 $s\\_not=\\lnot op$，两个 AND 门实现：\n$$\nw0 = (a \\oplus b) \\cdot (\\lnot op), \\quad w1 = fa\\_sum \\cdot op,\n$$\n以及一个 OR 门：\n$$\nresult = w0 \\lor w1.\n$$\n\n所需的 $cout$ 行为是：\n$$\ncout =\n\\begin{cases}\n0, & op=0, \\\\\nfa\\_cout, & op=1,\n\\end{cases}\n$$\n这正是门控表达式\n$$\ncout = op \\cdot fa\\_cout,\n$$\n并且按要求使用单个原语 AND 门来生成最终的 $cout$。\n\n现在根据这些方程式和结构约束来检查每个选项：\n\n- 选项 A 将多路选择器的路径连接为 $w0 = fa\\_sum \\cdot (\\lnot op)$ 和 $w1 = (a \\oplus b) \\cdot op$，得到\n$$\nresult = (\\lnot op)\\cdot fa\\_sum \\;\\lor\\; op \\cdot (a \\oplus b),\n$$\n这与要求的选择相反。因此，它不满足功能行为要求。\n\n- 选项 B 实现了正确的多路选择器：\n$$\nresult = (\\lnot op)\\cdot (a \\oplus b) \\;\\lor\\; op \\cdot fa\\_sum,\n$$\n但它无条件地设置 $cout = fa\\_cout$，这违反了当 $op=0$ 时 $cout=0$ 的要求，也违反了使用一个原语 AND 门来生成最终 $cout$ 的要求。\n\n- 选项 C 完全匹配：\n  - 全加器作用于 $(a,b,cin)$，\n  - $xor\\_out = a \\oplus b$，\n  - 多路选择器为 $result = (\\lnot op)\\cdot (a \\oplus b) \\;\\lor\\; op \\cdot fa\\_sum$，使用 NOT/AND/OR 实现，\n  - $cout = op \\cdot fa\\_cout$，使用一个 AND 门实现。\n  它同时满足功能行为和结构约束。\n\n- 选项 D 错误地将 $op$ 作为全加器的第三个输入而不是 $cin$，因此加法忽略了 $cin$，功能上是不正确的。\n\n因此，唯一正确的实现是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1964327"}, {"introduction": "在这个实践中，你将通过结构化地连接 D 型触发器来构建一个 4 位扭环计数器（也称为约翰逊计数器）。这个练习的核心在于理解如何通过模块间的连接和反馈路径来创建时序电路。这项任务突显了结构化建模如何直接将电路的物理布局与随时间变化的状态序列联系起来，这是设计状态机和任何时序系统的基础 [@problem_id:1964346]。", "problem": "在数字系统中，控制逻辑通常需要特定的状态序列。您的任务是设计一个4位时序电路，我们称之为“扭环计数器”（twisted-ring counter）。该电路的行为和结构定义如下。\n\n该电路有一个时钟输入 `clk`、一个低电平有效异步复位 `rst_n` 和一个4位输出总线 `Q[3:0]`。当电路复位时（`rst_n` 置为低电平），输出 `Q` 必须为 `4'b0000`。\n\n在非复位状态下，电路在 `clk` 的每个上升沿进行状态转换。其数据路径遵循特定的移位和反馈模式：`Q[3]` 的值移至 `Q[2]`，`Q[2]` 的值移至 `Q[1]`，`Q[1]` 的值移至 `Q[0]`。该计数器的“扭环”特性来自于反馈回路：最高有效位 `Q[3]` 的新值由最低有效位 `Q[0]` 的当前值的*反相*决定。\n\n您的实现必须是纯结构化的。您需要使用一个名为 `d_ff` 的预定义D型触发器模块，该模块具有低电平有效的异步复位功能。此构建模块的Verilog定义如下：\n\n```verilog\nmodule d_ff (\n    output reg q,\n    input d,\n    input clk,\n    input rst_n\n);\n    // On the rising edge of the clock or falling edge of reset\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0; // Asynchronous reset to 0\n        else\n            q <= d;    // Synchronous data load\n    end\nendmodule\n```\n\n您需要通过结构化地实例化并连接四个 `d_ff` 模块的实例来完成下面的 `twisted_ring_counter` 模块的主体部分。\n\n```verilog\nmodule twisted_ring_counter (\n    output [3:0] Q,\n    input clk,\n    input rst_n\n);\n\n    // -- SELECT THE CORRECT CODE BLOCK FOR THIS SECTION --\n\nendmodule\n```\n\n根据规格说明，以下哪个 Verilog 代码片段正确地实现了 `twisted_ring_counter` 模块的主体部分？\n\nA.\n```verilog\nwire not_Q0;\nassign not_Q0 = ~Q[0];\n\nd_ff ff3 (.q(Q[3]), .d(not_Q0), .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```\n\nB.\n```verilog\nd_ff ff3 (.q(Q[3]), .d(Q[0]),   .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```\n\nC.\n```verilog\nwire not_Q3;\nassign not_Q3 = ~Q[3];\n\nd_ff ff3 (.q(Q[3]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[0]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(not_Q3), .clk(clk), .rst_n(rst_n));\n```\n\nD.\n```verilog\nwire not_Q3;\nassign not_Q3 = ~Q[3];\n\nd_ff ff3 (.q(Q[3]), .d(not_Q3), .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```", "solution": "我们通过依据当前输出来编写次态方程来解释该规格。假设 $rst_n=1$，令 $Q_{i}^{+}$ 表示在 `clk` 的下一个上升沿之后 $Q[i]$ 的值。所要求的状态转换是：\n$$Q_{2}^{+}=Q_{3},\\quad Q_{1}^{+}=Q_{2},\\quad Q_{0}^{+}=Q_{1},\\quad Q_{3}^{+}=\\overline{Q_{0}}.$$\n因为所提供的 `d_ff` 在 `clk` 的上升沿将其输入 $d$ 加载到 $q$ 中（除非异步复位，此时输出为 $0$），所以结构化地实现这些方程需要将每个触发器的 $d$ 输入连接到对应的方程右侧：\n- 对于 $Q[3]$: $d=\\overline{Q[0]}$，\n- 对于 $Q[2]$: $d=Q[3]$，\n- 对于 $Q[1]$: $d=Q[2]$，\n- 对于 $Q[0]$: $d=Q[1]$。\n\n将每个选项与这些方程进行核对：\n- 选项 A 计算了 $\\overline{Q[0]}$ 的连线，并将 $d$ 输入连接为 $Q[3]\\leftarrow\\overline{Q[0]}$, $Q[2]\\leftarrow Q[3]$, $Q[1]\\leftarrow Q[2]$, $Q[0]\\leftarrow Q[1]$，这完全符合所需的次态方程。\n- 选项 B 使用 $Q[3]\\leftarrow Q[0]$（缺少反相），因此不满足 $Q_{3}^{+}=\\overline{Q_{0}}$。\n- 选项 C 实现了 $Q[3]\\leftarrow Q[2]$, $Q[2]\\leftarrow Q[1]$, $Q[1]\\leftarrow Q[0]$, $Q[0]\\leftarrow\\overline{Q[3]}$，其移位方向相反，并且反相了错误的位。\n- 选项 D 使用 $Q[3]\\leftarrow\\overline{Q[3]}$，这使得 $Q[3]$ 无论 $Q[0]$ 为何值都会翻转，违反了所要求的反馈。\n\n所有选项都使用了具有低电平有效异步复位的相同 `d_ff` 模块，因此在每种情况下，$rst_n=0$ 时 $Q=4'b0000$ 的复位行为在结构上都得到满足；区分因素是 $d$ 输入的接线是否正确。因此，只有选项 A 正确地实现了指定的扭环计数器。", "answer": "$$\\boxed{A}$$", "id": "1964346"}, {"introduction": "这个高级练习将挑战你设计一个位串行加法器，这是一种截然不同的加法器设计范式。你将学习如何集成一个组合逻辑单元（一个全加器）和一个时序元件（一个用于存储进位的触发器），并用一个计数器来控制整个流程。这项实践不仅揭示了如何通过时间换取硬件面积，还展示了如何将组合逻辑、状态存储和控制序列结合起来，以最少的硬件实现复杂操作，这是数字设计中的一个重要权衡 [@problem_id:1964345]。", "problem": "您的任务是使用 Verilog 设计一个 4 位串行加法器。串行加法器在每个时钟周期处理多位数字的一个比特，从最低有效位 (LSB) 开始。该设计必须是纯结构化的，使用一个预定义的 `full_adder` 模块和用于状态保持的触发器。\n\n您要设计的 `serial_adder` 模块具有以下接口：\n- **输入**：\n    - `clk`：1 位时钟信号。\n    - `reset`：1 位高电平有效异步复位信号。当该信号有效时，加法器应初始化以进行新的 4 位加法。\n    - `a`, `b`：1 位输入，表示正在相加的两个数的当前比特。\n- **输出**：\n    - `s`：1 位输出，表示当前和比特。\n    - `done`：1 位信号，应在产生最高有效位 (MSB) 和的那个周期内，恰好在一个时钟周期内被置为高电平。\n\n提供给您的 `full_adder` 模块具有以下接口：\n`module full_adder(input a, b, cin, output s, cout);`\n\n您的 `serial_adder` 必须根据以下规则实现：\n1.  它必须实例化一个且仅一个 `full_adder`。\n2.  一位加法产生的进位输出 (carry-out) 必须被存储，并在下一个时钟周期用作下一位加法的进位输入 (carry-in)。最低有效位 (LSB) 的初始进位输入必须为 0。这种状态保持必须使用一个寄存器来实现。\n3.  必须使用一个 2 位计数器来跟踪正在处理的比特位置（从比特 0 到比特 3）。该计数器也必须由 `reset` 信号复位。\n\n下面是 `serial_adder` 模块体的四种可能实现。请选择唯一正确实现了指定的 4 位串行加法器的选项。\n\n**模块头：**\n`module serial_adder(input clk, reset, a, b, output s, done);`\n\n**代码片段：**\n\n**A.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b0;\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else if (count == 2'b11)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**B.**\n```verilog\nwire carry;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry), .s(s), .cout(carry));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**C.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b1; // Reset carry to 1\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**D.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(s)); // Incorrect connection\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b0;\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b10); // Incorrect done logic\n```", "solution": "我们首先重申 4 位串行加法器所需的行为：\n\n- 必须实例化一个且仅一个全加器，当前位的进位输出存储在一个寄存器中，并在下一个时钟周期用作进位输入。最低有效位 (LSB) 的初始进位输入必须为零，这由复位强制执行，因此进位寄存器必须异步复位为零。\n- 一个 2 位计数器必须跟踪从 $0$ 到 $3$ 的比特索引。该计数器必须由复位信号异步复位。信号 $done$ 必须在产生最高有效位和的同时，即当前比特索引等于 $3$ 时，被置为高电平，且持续一个时钟周期。\n\n我们根据这些规则评估每个选项。\n\n选项 A：\n- 它实例化了一个且仅一个全加器，其连接为：$cin$ 由寄存的进位驱动，$cout$ 在下一时钟被捕获到进位寄存器中。进位寄存器异步复位为零：\n  - 在 $reset$ 时：$carry\\_reg \\leftarrow 0$，满足了最低有效位的初始进位输入要求。\n  - 在每个时钟上升沿：$carry\\_reg \\leftarrow carry\\_out$，正确地在比特时间之间流水化了进位。\n- 它使用一个 2 位计数器，可异步复位为零。在每个时钟周期：如果当前计数等于 $3$，它加载 $0$；否则，它加 $1$。这实现了复位后的循环 $0 \\to 1 \\to 2 \\to 3 \\to 0 \\to \\dots$。\n- $done$ 被组合地赋值为 $(count == 3)$。由于当前周期的 $s$ 是当前比特索引的和，当 $count=3$ 时置位 $done$ 正好与 MSB 和的产生相吻合，并且因为计数器在下一个周期复位为 $0$，所以 $done$ 在每个四位加法序列中仅在一个周期内为高。这符合要求。\n\n因此，A 满足所有约束。\n\n选项 B：\n- 进位是一个 `wire`，同时馈入 $cin$ 和来自 $cout$，这会产生一个组合逻辑环路，更重要的是，它没有实现带有初始零值的必需的寄存进位。没有寄存器来保持进位，也没有将进位复位为零，这违反了状态保持要求和初始进位输入要求。\n- 尽管存在一个 2 位计数器并且在 $count=3$ 时置位 $done$，但缺少进位寄存器使得该选项不合格。\n\n选项 C：\n- 进位寄存器异步复位为一，即在 $reset$ 时：$carry\\_reg \\leftarrow 1$，这违反了最低有效位的初始进位输入必须为零的要求。\n- 计数器每个周期递增并异步复位为零；尽管 2 位的宽度会导致自然回卷，但不正确的进位初始化已经使这个选项无效。\n\n选项 D：\n- 全加器的 $cout$ 被错误地连接到 $s$ 端口，而声明的 $carry\\_out$ 没有连接到全加器的 $cout$，使得进位寄存器的更新毫无意义。\n- $done$ 逻辑在 $count=2$ 时置位，而不是在 $count=3$ 时，因此它与 MSB 和的产生时间不一致。\n- 这些连线和逻辑错误违反了指定的行为。\n\n根据此分析，只有选项 A 正确实现了指定的 4 位串行加法器：它使用了一个且仅一个全加器，正确地寄存并将进位复位为零，采用了一个可复位的 2 位计数器以从 $0$ 顺序计数到 $3$，并在 MSB 和比特产生时精确地将 $done$ 置位一个周期。", "answer": "$$\\boxed{A}$$", "id": "1964345"}]}