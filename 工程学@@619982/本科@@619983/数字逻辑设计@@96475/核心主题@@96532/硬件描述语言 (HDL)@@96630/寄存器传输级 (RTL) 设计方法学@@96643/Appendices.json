{"hands_on_practices": [{"introduction": "设计任何序贯逻辑电路，第一步都是从基础的寄存器和计数器开始。这个练习将带你实践寄存器传输级（RTL）设计中最基本也是最重要的构件：一个带有同步使能和异步复位的计数器。正确地对这种行为建模是确保数字系统能够可靠地初始化和运行的关键。[@problem_id:1957805]", "problem": "一个数字系统需要一个16位向上计数器。该计数器实现为一个名为 `C` 的寄存器。该系统有以下信号：\n\n*   `clk`: 系统时钟输入。\n*   `reset`: 高电平有效、异步复位输入。\n*   `en`: 高电平有效、同步使能输入。\n\n计数器的行为定义如下：\n1.  在任何时候，如果 `reset` 信号被置为有效（逻辑高），计数器 `C` 必须立即无条件地清零。\n2.  如果 `reset` 信号未被置为有效，则在 `clk` 信号的每个上升沿，计数器的行为由 `en` 信号决定。\n3.  如果在时钟上升沿 `en` 被置为有效（逻辑高），计数器 `C` 加1。\n4.  如果在时钟上升沿 `en` 未被置为有效（逻辑低），计数器 `C` 保持其当前值。\n\n请您选择能够准确建模此行为的正确寄存器传输级（RTL）伪代码描述。该伪代码使用类似于 Verilog 硬件描述语言（HDL）的语法，其中进程由敏感列表触发，`<=` 表示对寄存器的非阻塞赋值。\n\n以下哪个 RTL 描述正确实现了指定的16位计数器？\n\nA.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    C <= 0;\n  else if (en)\n    C <= C + 1;\nend\n```\n\nB.\n```\nalways @ (posedge clk)\nbegin\n  if (reset)\n    C <= 0;\n  else if (en)\n    C <= C + 1;\nend\n```\n\nC.\n```\nalways @ (posedge clk)\nbegin\n  if (en)\n    C <= C + 1;\n  else if (reset)\n    C <= 0;\nend\n```\n\nD.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (en)\n    C <= C + 1;\n  else if (reset)\n    C <= 0;\nend\n```\n\nE.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    C = 0;\n  else if (en)\n    C = C + 1;\nend\n```", "solution": "问题要求为具有特定复位、时钟和使能信号行为的16位计数器提供正确的寄存器传输级（RTL）描述。要解决这个问题，我们必须正确解读异步和同步事件之间的区别以及标准的RTL编码实践。\n\n1.  **分析异步复位需求：** 题目指出 `reset` 是“异步的”和“高电平有效的”。\n    *   **异步：** 这意味着复位操作（将计数器 `C` 清零）必须在 `reset` 信号为高时立即发生，而不管 `clk` 信号的状态如何。在像 Verilog 的 `always` 块这样的 RTL 进程中，这是通过将复位信号包含在敏感列表中来建模的。由于复位是高电平有效的，该模块应该对复位信号的上升沿（或正电平变化）敏感。因此，敏感列表必须是 `always @ (posedge clk or posedge reset)`。\n    *   **无条件优先级：** 复位也是“无条件的”。这意味着它具有最高优先级。在 `if-else if-else` 结构中，必须首先检查最高优先级的条件。因此，`if (reset)` 检查必须出现在 `always` 块内任何其他逻辑之前。\n\n2.  **分析同步行为：** 增量和保持操作是“同步的”。\n    *   **时钟触发：** 这些操作只在时钟的上升沿发生。此逻辑必须以时钟事件为条件。`always @ (posedge clk ...)` 敏感列表处理了这一点。\n    *   **以复位为条件：** 同步逻辑只应在系统*不*处于复位状态时执行。这意味着所有同步逻辑都必须放在主 `if (reset)` 语句的 `else` 部分。\n    *   **使能逻辑：** 在同步部分内，仅当 `en` 为高时，计数器才会递增（`C <= C + 1`）。如果 `en` 为低，`C` 保持其值。在RTL中，如果在给定条件下没有为寄存器分配新值，它将保持其值。因此，我们只需要为增量指定逻辑：`if (en) C <= C + 1;`。这将被放置在与 `if (reset)` 对应的 `else` 块内。\n\n3.  **选择正确的赋值运算符：** 对于建模时序逻辑（寄存器、触发器、计数器），非阻塞赋值运算符（`<=`）是标准约定。它安排在当前仿真时间步结束时进行值更新，这精确地模拟了同步系统中所有触发器在时钟沿同时捕获其新值的行为。阻塞赋值（`=`）可能导致竞争条件和与综合后硬件不匹配的仿真结果。\n\n基于这些原则，我们来评估各个选项：\n\n*   **A:** 敏感列表是 `(posedge clk or posedge reset)`，它正确地建模了一个由时钟或复位事件触发的异步复位。首先检查 `if (reset)` 逻辑，赋予其最高优先级。同步逻辑 `else if (en) C <= C + 1;` 被正确放置，并且仅在复位无效时的时钟沿执行。它使用了非阻塞赋值（`<=`）。此选项正确实现了所有要求。\n\n*   **B:** 敏感列表是 `(posedge clk)`。该模块仅对时钟沿敏感。因此，`reset` 信号只会在时钟上升沿被检查，使其成为一个**同步**复位。这违反了“异步”的要求。\n\n*   **C:** 由于敏感列表是 `(posedge clk)`，这也是一个同步复位。此外，其内部逻辑存在缺陷：它在检查 `if (reset)` 之前检查 `if (en)`，使得使能信号的优先级高于复位，这是不正确的。\n\n*   **D:** 敏感列表 `(posedge clk or posedge reset)` 对于异步复位是正确的。然而，其内部逻辑错误地在检查 `if (reset)` 之前检查 `if (en)`。如果 `en` 和 `reset` 同时为高，这将导致计数器递增，这违反了复位是无条件的要求。\n\n*   **E:** 敏感列表和逻辑结构是正确的。但是，它使用了阻塞赋值（`C = ...`）。如前所述，对于在RTL中建模时序逻辑而言，这是不正确的赋值类型，并且被认为是一种不良且常常是错误的编码实践。\n\n基于此分析，选项A是唯一一个正确建模了指定计数器所有方面的选项。", "answer": "$$\\boxed{A}$$", "id": "1957805"}, {"introduction": "计数器不仅限于简单的算术序列，它们可以遵循任何预定义的模式。本练习将挑战你为一个具有特殊序列（格雷码）的计数器设计其下一状态的组合逻辑，这是创建任何有限状态机（$FSM$）的核心技能。通过这个实践，你将学会如何从状态转换表推导出布尔逻辑方程，从而在RTL层面精确地实现所需的功能。[@problem_id:1957755]", "problem": "在数字系统中，计数器是基本的构建模块。格雷码计数器是一种特殊类型的计数器，它按照二进制数序列进行计数，其中任意两个连续状态之间只有一个比特位发生变化。在状态转换可能是异步或有噪声的系统中，这一特性非常有价值，因为它能防止转换冒险和误读。\n\n您的任务是为一个同步3位格雷码计数器进行寄存器传输级（RTL）设计分析。该计数器由以下规范定义：\n- 它使用一个3位状态寄存器 `G_state`，由D型触发器组成。状态位表示为 $G_2, G_1, G_0$，其中 $G_2$ 是最高有效位。\n- 该计数器有三个输入：一个时钟（`clk`）、一个高电平有效同步复位（`reset`）和一个高电平有效计数使能（`enable`）。\n- 状态寄存器 `G_state` 仅在 `clk` 的上升沿更新。\n- 如果 `reset` 为高电平，则在下一个时钟上升沿，无论 `enable` 信号如何，状态都变为 `000`。\n- 如果 `reset` 为低电平且 `enable` 为高电平，计数器将转换到格雷码序列中的下一个状态。\n- 如果 `reset` 为低电平且 `enable` 为低电平，计数器将保持其当前状态。\n- 3位反射二进制格雷码序列为：000、001、011、010、110、111、101、100，然后循环回到 000。\n\nRTL设计的核心是指定用于计算寄存器下一状态的组合逻辑。设D型触发器的输入为 $D_2, D_1, D_0$。请确定这些输入的最小化积之和（SOP）布尔逻辑方程组，这些方程是当前状态位（$G_2, G_1, G_0$）和 `enable` 信号的函数。假设 `reset` 信号为低电平。\n\n从以下选项中选择正确的方程组。在表达式中，并置表示逻辑与运算，`+` 符号表示逻辑或运算，$\\overline{A}$ 表示A的逻辑非。\n\nA.\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} G_1 \\overline{G_0} + \\text{enable} G_2 G_0$\n$D_1 = \\overline{\\text{enable}} G_1 + G_1 \\overline{G_0} + \\text{enable} \\overline{G_2} G_0$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} \\overline{G_1} \\overline{G_2} + \\text{enable} G_1 G_2$\n\nB.\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} (G_2 \\oplus (G_1 G_0))$\n$D_1 = \\overline{\\text{enable}} G_1 + \\text{enable} (G_1 \\oplus G_0)$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} (\\overline{G_0})$\n\nC.\n$D_2 = G_1 \\overline{G_0} + G_2 G_0$\n$D_1 = \\overline{G_2} G_0 + G_1 \\overline{G_0}$\n$D_0 = \\overline{G_1} \\overline{G_2} + G_1 G_2$\n\nD.\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} G_1 \\overline{G_0} + \\text{enable} G_2 G_0$\n$D_1 = \\overline{\\text{enable}} G_1 + G_1 \\overline{G_0} + \\text{enable} \\overline{G_1} G_0$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} \\overline{G_1} \\overline{G_2} + \\text{enable} G_1 G_2$", "solution": "我们要推导一个同步3位反射格雷码计数器的下一状态逻辑，该计数器具有状态位 $G_{2},G_{1},G_{0}$ 和一个高电平有效使能信号 $\\text{enable}$。假设同步复位为低电平，每个下一状态输入的标准RTL形式为\n$$\nD_{i}=\\overline{\\text{enable}}\\,G_{i}+\\text{enable}\\,N_{i},\n$$\n其中 $N_{i}$ 是计数使能时的下一状态位。\n\n首先，我们写出在 $\\text{enable}=1$ 条件下，从当前状态 $(G_{2}G_{1}G_{0})$ 到下一状态 $(N_{2}N_{1}N_{0})$ 的格雷码序列映射：\n$$\n000\\to 001,\\quad\n001\\to 011,\\quad\n011\\to 010,\\quad\n010\\to 110,\\quad\n110\\to 111,\\quad\n111\\to 101,\\quad\n101\\to 100,\\quad\n100\\to 000.\n$$\n\n根据此映射，我们将每个 $N_{i}$ 推导为关于 $G_{2},G_{1},G_{0}$ 的最小化SOP（积之和）形式。\n\n1) 推导 $N_{2}$。$N_{2}=1$ 的行对应的当前状态为 $010,110,111,101$。一个恰好覆盖这些状态的最小SOP是\n$$\nN_{2}=G_{1}\\overline{G_{0}}+G_{2}G_{0}.\n$$\n\n2) 推导 $N_{1}$。$N_{1}=1$ 的行是 $001,011,010,110$。观察其结构，一个最小SOP是\n$$\nN_{1}=\\overline{G_{2}}\\,G_{0}+G_{1}\\,\\overline{G_{0}}.\n$$\n\n3) 推导 $N_{0}$。$N_{0}=1$ 的行是 $000,001,110,111$。这是 $G_{1}$ 和 $G_{2}$ 的异或非（XNOR）；其SOP形式为\n$$\nN_{0}=\\overline{G_{1}}\\,\\overline{G_{2}}+G_{1}G_{2}.\n$$\n\n包含使能控制的保持行为后，\n$$\nD_{2}=\\overline{\\text{enable}}\\,G_{2}+\\text{enable}\\left(G_{1}\\overline{G_{0}}+G_{2}G_{0}\\right),\n$$\n$$\nD_{1}=\\overline{\\text{enable}}\\,G_{1}+\\text{enable}\\left(\\overline{G_{2}}\\,G_{0}+G_{1}\\,\\overline{G_{0}}\\right),\n$$\n$$\nD_{0}=\\overline{\\text{enable}}\\,G_{0}+\\text{enable}\\left(\\overline{G_{1}}\\,\\overline{G_{2}}+G_{1}G_{2}\\right).\n$$\n\n现在与提供的选项进行比较。选项A陈述为\n$$\nD_{2}=\\overline{\\text{enable}}\\,G_{2}+\\text{enable}\\,G_{1}\\overline{G_{0}}+\\text{enable}\\,G_{2}G_{0},\n$$\n$$\nD_{1}=\\overline{\\text{enable}}\\,G_{1}+G_{1}\\overline{G_{0}}+\\text{enable}\\,\\overline{G_{2}}\\,G_{0},\n$$\n$$\nD_{0}=\\overline{\\text{enable}}\\,G_{0}+\\text{enable}\\,\\overline{G_{1}}\\,\\overline{G_{2}}+\\text{enable}\\,G_{1}G_{2}.\n$$\n对于 $D_{2}$ 和 $D_{0}$，这些与推导出的形式完全匹配。对于 $D_{1}$，注意到\n$$\n\\overline{\\text{enable}}\\,G_{1}+G_{1}\\overline{G_{0}}+\\text{enable}\\,\\overline{G_{2}}\\,G_{0}\n=\\overline{\\text{enable}}\\,G_{1}+\\text{enable}\\left(G_{1}\\overline{G_{0}}+\\overline{G_{2}}\\,G_{0}\\right),\n$$\n因为 $G_{1}\\overline{G_{0}}=(\\overline{\\text{enable}}+\\text{enable})G_{1}\\overline{G_{0}}$。因此，选项A在代数上等效于所需的使能门控形式。\n\n选项B中，$D_{0}$ 依赖于 $\\overline{G_{0}}$ 而不是推导出的 $G_{1},G_{2}$ 的函数，并且 $D_{1}$ 缺少对 $G_{2}$ 的依赖，因此是不正确的。选项C完全忽略了使能信号，违反了保持要求。选项D在 $D_{1}$ 中使用了 $\\text{enable}\\,\\overline{G_{1}}\\,G_{0}$ 而不是所需的 $\\text{enable}\\,\\overline{G_{2}}\\,G_{0}$，因此是不正确的。\n\n因此，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1957755"}, {"introduction": "复杂的数字系统通常通过将任务分解为一系列简单的、按时钟周期执行的步骤来完成。这个练习模拟了这样一个系统，你需要追踪一个控制单元（有限状态机）如何指挥数据在多个时钟周期内流经数据通路（寄存器和移位器），以实现一个计算目标。这个过程是RTL设计方法学的精髓，体现了如何将算法思想转化为硬件实现。[@problem_id:1957789]", "problem": "一个专用的数字电路被设计用于对一个8位未规格化浮点数执行规格化操作。该电路的数据通路包含两个8位寄存器：一个阶码寄存器 `E` 和一个尾数寄存器 `M`。该系统由一个同步有限状态机 (FSM) 控制，该状态机负责协调整个规格化过程。\n\n该数据通路具有以下组件和控制信号：\n- `E`、`M`：8位寄存器。\n- `E_{in}`、`M_{in}`：8位输入总线。\n- `start`：一个1位输入信号，用于开始操作。\n- `done`：一个1位输出信号，当规格化完成时置为高电平 (`1`)。\n- `E_{load}`：一个控制信号，当其有效时，在下一个时钟上升沿将`E_{in}`的值载入`E`。\n- `M_{load}`：一个控制信号，当其有效时，在下一个时钟上升沿将`M_{in}`的值载入`M`。\n- `E_{dec}`：一个控制信号，当其有效时，在下一个时钟上升沿将`E`减一 (`E \\leftarrow E - 1`)。\n- `M_{shiftL}`：一个控制信号，当其有效时，在下一个时钟上升沿对`M`执行一次逻辑左移 (`M \\leftarrow M \\ll 1`，移入`0`)。\n\nFSM遵循以下操作序列，所有状态转换和寄存器更新都在同一时钟的上升沿发生：\n\n1.  **IDLE 状态**：FSM 初始处于 IDLE 状态。只要 `start` 信号为低电平 (`0`)，它就保持在该状态。在此期间，`done` 为低电平。\n2.  **LOAD 状态**：在一个时钟上升沿检测到 `start = 1` 时，FSM 转换到 LOAD 状态，并持续一个时钟周期。在该状态下，它将 `E_{load}` 和 `M_{load}` 置为有效，以捕获输入值。\n3.  **NORMALIZE 状态**：在 LOAD 状态之后，FSM 进入 NORMALIZE 状态。在该状态的每个时钟周期内，它会检查尾数的最高有效位 `M[7]`。\n    - 如果 `M[7] = 1` 或者整个尾数为零 (`M = 00000000_2`)，则该数被视为已规格化。FSM 转换到 DONE 状态。\n    - 如果 `M[7] = 0` 且 `M` 不为零，FSM 将 `E_{dec}` 和 `M_{shiftL}` 信号置为有效，并在下一个周期保持在 NORMALIZE 状态。\n4.  **DONE 状态**：在该状态下，FSM 将 `done` 信号置为 `1`，并保持 `E` 和 `M` 中的最终值。\n\n假设系统已上电并处于 IDLE 状态。在时钟周期 1 的上升沿，输入被设置为 `E_{in} = 10110110_2` 和 `M_{in} = 00001101_2`，并且 `start` 信号被置为高电平。`start` 信号仅在该单个时钟周期内保持高电平。\n\n当 `done` 信号首次被置为高电平时，在该时钟周期结束时，分别存储在寄存器 `E` 和 `M` 中的最终8位二进制值是什么？请将您的答案表示为一个包含 `E` 和 `M` 的两个8位二进制字符串的行矩阵。", "solution": "所有的状态变化和寄存器更新都在时钟上升沿发生，并且在一个时钟周期内置为有效的控制信号所触发的寄存器操作在下一个时钟上升沿生效。FSM 从 IDLE 状态开始，此时 $done=0$。\n\n在时钟周期 $1$ 的上升沿，观测到 $start=1$，因此 FSM 转换为 LOAD 状态，以进入下一个周期。在 LOAD 周期中，它使 $E_{load}=1$ 且 $M_{load}=1$，以便在下一个上升沿锁存输入。\n\n在时钟周期 $2$ 的上升沿，LOAD 控制生效：\n$$E \\leftarrow E_{in} = 10110110,\\quad M \\leftarrow M_{in} = 00001101.$$\nFSM 转换到 NORMALIZE 状态。在每个 NORMALIZE 周期中，它检查 $M[7]$，如果 $M[7]=0$ 且 $M \\neq 0$，则将 E_{dec} 和 M_{shiftL} 置为1，以便在下一个上升沿执行 $E \\leftarrow E-1$ 和 $M \\leftarrow M \\ll 1$；否则，它将转换到 DONE 状态，而不激活这些控制信号。\n\n我们迭代直到 $M[7]=1$：\n- 在上升沿 $2$ 之后的周期内，$M=00001101$ 的 $M[7]=0$ 且 $M \\neq 0$，所以在上升沿 $3$ 时：\n$$E \\leftarrow 10110110 - 00000001 = 10110101,\\quad M \\leftarrow 00001101 \\ll 1 = 00011010.$$\n- 在上升沿 $3$ 之后的周期内，$M=00011010$ 的 $M[7]$ 仍然为 $0$，所以在上升沿 $4$ 时：\n$$E \\leftarrow 10110101 - 00000001 = 10110100,\\quad M \\leftarrow 00011010 \\ll 1 = 00110100.$$\n- 在上升沿 $4$ 之后的周期内，$M=00110100$ 的 $M[7]$ 仍然为 $0$，所以在上升沿 $5$ 时：\n$$E \\leftarrow 10110100 - 00000001 = 10110011,\\quad M \\leftarrow 00110100 \\ll 1 = 01101000.$$\n- 在上升沿 $5$ 之后的周期内，$M=01101000$ 的 $M[7]$ 仍然为 $0$，所以在上升沿 $6$ 时：\n$$E \\leftarrow 10110011 - 00000001 = 10110010,\\quad M \\leftarrow 01101000 \\ll 1 = 11010000.$$\n\n在上升沿 $6$ 之后的周期内，$M=11010000$ 的 $M[7]=1$，所以 FSM 不再激活任何数据通路控制信号，并在下一个上升沿转换到 DONE 状态。在上升沿 $7$ 时，FSM 进入 DONE 状态，`done` 首次被置为高电平，寄存器中的值为：\n$$E = 10110010,\\quad M = 11010000.$$\n在 DONE 状态下，寄存器的值保持不变，因此在 `done` 首次为高电平的时钟周期结束时，值仍然是 $E=10110010$ 和 $M=11010000$。\n\n同样地，计算 $M_{in}=00001101$ 中的前导零个数，可知需要 $4$ 次移位，因此 $M_{final}=M_{in} \\ll 4 = 11010000$ 并且 $E_{final}=E_{in}-4=10110010$，这与上述分步时序分析一致。\n\n因此，最终内容是包含 $E$ 和 $M$ 作为8位二进制字符串的行矩阵。", "answer": "$$\\boxed{\\begin{pmatrix}10110010 & 11010000\\end{pmatrix}}$$", "id": "1957789"}]}