{"hands_on_practices": [{"introduction": "在Verilog中，正确区分 `` `reg` `` 和 `` `wire` `` 数据类型是编写功能正确代码的第一步。这个练习将帮助你理解一个核心规则：`` `reg` `` 类型用于在过程块（如 `` `initial` ``和 `` `always` ``）中存储数值，而 `` `wire` `` 类型则代表物理连线，必须由连续赋值语句驱动。掌握这一区别是避免常见编译错误和构建可靠数字逻辑电路的基础。[@problem_id:1975222]", "problem": "在 Verilog 硬件描述语言 (HDL) 的背景下，请看下面这个简单的模块，它被设计用于在仿真开始时初始化两个信号。\n\n```verilog\nmodule simple_init;\n\n  reg  a;\n  wire b;\n\n  initial begin\n    a = 1'b0;\n    b = 1'b1;\n  end\n\nendmodule\n```\n\n这段代码包含一个根本性错误，会导致其无法正确编译和仿真。以下哪项更改是修复所提供模块中错误的必要且正确的修改？\n\nA. 将 `b` 的声明从 `wire b;` 更改为 `reg b;`\n\nB. 将 `a` 的声明从 `reg a;` 更改为 `wire a;`\n\nC. 在对 `a` 和 `b` 的赋值语句外添加一个 `always @(*)` 块。\n\nD. 将 `initial` 块替换为两条连续赋值语句：`assign a = 1'b0;` 和 `assign b = 1'b1;`", "solution": "Verilog 区分线网类型（例如 wire）和变量类型（例如 reg）。基本规则是，`initial` 或 `always` 块内的过程赋值只能对变量（例如 `reg`）进行赋值，而不能对线网（例如 `wire`）进行赋值。使用 `assign` 关键字的连续赋值驱动的是线网，而不是 `reg` 类型的变量。\n\n在给定的模块中，`initial` 块对 `a` 和 `b` 都进行了赋值。将 `a` 声明为 `reg` 类型对于过程赋值是正确的。然而，`b` 被声明为 `wire` 类型，在过程块中不能对其进行赋值。这就是编译错误所在。\n\n分析各个选项：\n- 选项 A 将 `b` 从 `wire` 更改为 `reg`。这使得 `a` 和 `b` 都成为可以在 `initial` 块内被合法赋值的变量。此举直接修复了错误，且不改变其行为。\n- 选项 B 将 `a` 从 `reg` 更改为 `wire`，这会使得对 `a` 的过程赋值变为非法，从而引入另一个错误。\n- 选项 C 将赋值语句包裹在 `always @(*)` 块中，但这仍然是一个过程上下文；对 `wire` 类型的 `b` 赋值仍然是非法的，因此这不能修复错误。\n- 选项 D 用连续赋值替换了过程性的 `initial` 块。连续赋值需要驱动线网；由于 `a` 被声明为 `reg`，`assign a = 1'b0;` 将是非法的，除非 `a` 也被更改为线网类型。因为该选项没有更改 `a` 的声明，所以这不是一个正确的修复方法。\n\n因此，必要且正确的修改是将 `b` 声明为 `reg`，即选项 A。", "answer": "$$\\boxed{A}$$", "id": "1975222"}, {"introduction": "在处理数据总线或寄存器时，我们常常需要访问其中的一部分数据而非整个向量。Verilog为此提供了简洁的“位选择”（bit-select）和“部分选择”（part-select）语法，让你能够精确地提取任意位。通过这个练习，你将实践如何从一个8位寄存器中选取特定的位，这是数据处理和接口设计中一项不可或缺的基本技能。[@problem_id:1975211]", "problem": "在一个使用 Verilog 设计的数字系统中，声明了一个寄存器，用于保存来自传感器的 8 位数据值。该寄存器定义如下：\n\n`reg [7:0] data_bus;`\n\n对于一个特定的处理单元，只需要 `data_bus` 的两个最低有效位 (LSB)。下列哪个表达式正确地选择了这两位？\n\nA. `data_bus[0:1]`\n\nB. `data_bus[2:1]`\n\nC. `data_bus[1:0]`\n\nD. `data_bus(1:0)`\n\nE. `data_bus[7:6]`\n\nF. `data_bus[0,1]`", "solution": "Verilog 声明 `reg [7:0] data_bus;` 定义了一个 8 位向量，其索引从最高有效位 (MSB) 索引 $7$ 降至最低有效位 (LSB) 索引 $0$。在 Verilog 中，位选择使用方括号，并指定一个降序范围，格式为 $[ \\text{msb} : \\text{lsb} ]$，其中左侧索引必须大于或等于右侧索引。\n\n两个最低有效位是第 $1$ 位和第 $0$ 位。因此，选择这两个最低有效位的正确位选择是 `[1:0]`。\n\n分析各个选项：\n- A. `data_bus[0:1]` 使用了升序范围，这在标准的 Verilog 位选择语法中是无效的。\n- B. `data_bus[2:1]` 选择了第 $2$ 位和第 $1$ 位，而不是两个最低有效位。\n- C. `data_bus[1:0]` 正确地选择了第 $1$ 位和第 $0$ 位，即两个最低有效位。\n- D. `data_bus(1:0)` 使用了圆括号，这是无效语法；Verilog 的索引需要使用方括号。\n- E. `data_bus[7:6]` 选择了两个最高有效位，而不是最低有效位。\n- F. `data_bus[0,1]` 是无效语法；多位选择需要使用拼接操作，例如 `{data_bus[1], data_bus[0]}`，而不是在方括号内使用逗号。\n\n因此，只有选项 C 是正确的。", "answer": "$$\\boxed{C}$$", "id": "1975211"}, {"introduction": "在将多个模块集成为一个复杂系统时，微小的疏忽可能导致难以追踪的错误。本练习模拟了一个常见的设计缺陷：工程师忘记了声明连接两个模块的 `` `wire` ``。通过分析这个问题，你将深入理解Verilog的隐式线网声明规则，以及在端口位宽不匹配时发生的数据截断和零位扩展，这些都是调试实际硬件设计时至关重要的知识。[@problem_id:1975238]", "problem": "在一个使用 Verilog 设计的数字系统中，一个顶层模块 `system_controller` 集成了一个 `data_source` 子模块和一个 `data_sink` 子模块。`data_source` 模块生成一个 8 位的值。这个值本应传递给 `data_sink` 模块进行处理。然而，工程师在 `system_controller` 内部忘记了明确声明连接 `data_source` 实例输出和 `data_sink` 实例输入的线网（wire）。\n\n下面给出了所有三个模块的 Verilog 描述。你的任务是分析此设计，并确定 `system_controller` 的 `system_output` 端口最终的、稳定的十进制值。假设仿真运行时间足够长，以使所有初始值都能传播，并且所有组合逻辑都能稳定下来。\n\n**`data_source` 模块：**\n```verilog\nmodule data_source (\n  output reg [7:0] source_out\n);\n\n  initial begin\n    source_out = 8'hA9; // Hexadecimal A9\n  end\n\nendmodule\n```\n\n**`data_sink` 模块：**\n```verilog\nmodule data_sink (\n  input [3:0] sink_in,\n  output [7:0] sink_out\n);\n\n  // Re-arrange and combine input bits to form the output\n  assign sink_out = {sink_in[3:2], 2'b11, sink_in[1:0], 2'b01};\n\nendmodule\n```\n\n**`system_controller` 模块：**\n```verilog\nmodule system_controller (\n  output [7:0] system_output\n);\n\n  // Instantiation of submodules\n  data_source source_inst (\n    .source_out(internal_connection)\n  );\n\n  data_sink sink_inst (\n    .sink_in(internal_connection),\n    .sink_out(system_output)\n  );\n\n  // NOTE: The wire 'internal_connection' is intentionally NOT declared.\n\nendmodule\n```\n\n`system_output` 的最终十进制值是多少？", "solution": "在 Verilog 中，未声明的标识符 `internal_connection`，在没有 `default_nettype` 覆写的情况下，会根据语言的隐式线网规则，被隐式声明为一个 1 位的 `wire` 类型线网。\n\n在模块 `data_source` 中，输出在一个 `initial` 块中被赋值：\n$$\\text{source\\_out} = 8'hA9 = 8'b10101001.$$\n\n在 `system_controller` 中，端口连接\n$$.\\text{source\\_out}(\\text{internal\\_connection})$$\n将一个 8 位的形式端口连接到一个 1 位的实际信号。根据 Verilog 的位宽不匹配规则，当用一个较宽的向量驱动一个较窄的线网时，该值会被截断，只保留最低有效位。因此，\n$$\\text{internal\\_connection} = \\text{source\\_out}[0] = 1.$$\n\n接下来，连接\n$$.\\text{sink\\_in}(\\text{internal\\_connection})$$\n将一个 4 位的输入形式端口连接到一个 1 位的实际信号。当一个较宽的形式端口接收一个较窄的实际信号（无符号）时，该值会在最高有效位一侧进行零扩展。因此，\n$$\\text{sink\\_in} = 4'b0001.$$\n\n`data_sink` 模块通过组合逻辑赋值计算其输出：\n$$\\text{sink\\_out} = \\{\\text{sink\\_in}[3:2],\\ 2'b11,\\ \\text{sink\\_in}[1:0],\\ 2'b01\\}.$$\n代入 $\\text{sink\\_in} = 4'b0001$ 可得\n$$\\text{sink\\_in}[3:2] = 2'b00,\\quad \\text{sink\\_in}[1:0] = 2'b01,$$\n所以\n$$\\text{sink\\_out} = \\{2'b00,\\ 2'b11,\\ 2'b01,\\ 2'b01\\} = 8'b00110101.$$\n\n因此，在 `system_controller` 中，\n$$\\text{system\\_output} = 8'b00110101 = 8'h35,$$\n其十进制值为\n$$53.$$\n初始化之后，所有信号都是组合逻辑，因此这是最终的稳定值。", "answer": "$$\\boxed{53}$$", "id": "1975238"}]}