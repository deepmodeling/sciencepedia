{"hands_on_practices": [{"introduction": "在数字设计中，我们经常需要像拼装积木一样，对数据位进行重组和拼接。这个练习将带你实践 Verilog 中最核心的位操作工具：拼接运算符 `{...}` 和位选择 `[...]` [@problem_id:1975749]。通过构建一个特定格式的数据包，你将掌握如何灵活地从现有数据中提取部分比特（位选择），并将它们按照新的顺序组合起来（拼接），这是所有硬件描述语言设计的基础。", "problem": "在为一个通信协议设计专用数据包形成器时，您的任务是创建一个 Verilog 模块，该模块将一个8位的输入数据字节转换为一个16位的输出字。\n\n该模块有一个8位输入端口 `val[7:0]` 和一个16位输出端口 `result[15:0]`。转换规则如下：\n1.  输出 `result` 的最高有效字节（即比特 `[15:8]`）必须与输入字节 `val` 完全相同。\n2.  输出 `result` 的最低有效字节（即比特 `[7:0]`）必须是输入字节 `val` 的一个修改版本，其中其高4位半字节（比特 `[7:4]`）和低4位半字节（比特 `[3:0]`）的位置被交换。\n\n下面是为输出 `result` 的连续赋值提出的五种不同的 Verilog `assign` 语句。下列哪条语句正确地实现了指定的逻辑？\n\nA. `assign result = {val, val[3:0], val[7:4]};`\n\nB. `assign result = {{val[3:0], val[7:4]}, val};`\n\nC. `assign result = {val, {val[7:4], val[3:0]}};`\n\nD. `assign result = {val, (val[3:0] << 4) | (val[7:4] >> 4)};`\n\nE. `assign result = {val[7:0], val[4:7], val[0:3]};`", "solution": "该问题要求根据一组特定的规则，从一个8位向量 `val` 构建一个16位向量 `result`。让我们来分解 `result[15:0]` 的构建过程并分析所提供的选项。\n\n**步骤1：解构问题陈述**\n16位输出 `result` 由两个8位部分组成：\n- **最高有效字节 (MSB):** `result[15:8]` 应等于8位输入 `val`。\n- **最低有效字节 (LSB):** `result[7:0]` 应是 `val` 的半字节交换后的版本。\n\n**步骤2：构建半字节交换后的字节**\n输入 `val` 是一个8位向量 `val[7:0]`。\n- 其高半字节是部分选择 `val[7:4]`。\n- 其低半字节是部分选择 `val[3:0]`。\n\n要交换半字节，新的高半字节应为旧的低半字节，新的低半字节应为旧的高半字节。我们可以使用 Verilog 的拼接运算符 `{...}` 来构建这个新的8位字节。\n- 新的8位字节 = `{ 旧的低半字节, 旧的高半字节 }`\n- 在 Verilog 语法中，这表示为：`{val[3:0], val[7:4]}`。\n\n**步骤3：构建最终的16位结果**\n最终的 `result` 是其 MSB 和 LSB 的拼接。\n- `result` = `{ MSB, LSB }`\n- 代入我们已定义的组件：\n  `result` = `{ val, {val[3:0], val[7:4]} }`\n\nVerilog 允许嵌套的拼接被展开。因此，该表达式等效于：\n`result = {val, val[3:0], val[7:4]}`\n\n该表达式将一个 (8 + 4 + 4) = 16位的值赋给16位的 `result` 线网，其维度是正确的。比特按如下方式赋值：\n- `result[15:8]` 获得 `val` (8位)。\n- `result[7:4]` 获得 `val[3:0]` (4位)。\n- `result[3:0]` 获得 `val[7:4]` (4位)。\n这与问题描述完全匹配。`result[15:8]` 是原始的 `val`，而 `result[7:0]` 是 `val` 的半字节交换版本。\n\n**步骤4：分析多项选择题选项**\n\n*   **A. `assign result = {val, val[3:0], val[7:4]};`**\n    如上所推导，该语句正确地构建了16位的 `result`。MSB 是 `val`，LSB 是 `{val[3:0], val[7:4]}`，也就是 `val` 的半字节交换版本。这是正确答案。\n\n*   **B. `assign result = {{val[3:0], val[7:4]}, val};`**\n    该语句先拼接 `val` 的半字节交换版本，然后是原始的 `val`。这将把交换后的字节赋给 `result[15:8]`，而原始字节赋给 `result[7:0]`。这与问题指定的要求相反。\n\n*   **C. `assign result = {val, {val[7:4], val[3:0]}};`**\n    表达式 `{val[7:4], val[3:0]}` 按原始顺序拼接了 `val` 的高半字节和低半字节，这只是简单地重构了原始的 `val`。因此，该语句等效于 `assign result = {val, val};`。它将 `val` 与其自身拼接，而不是与半字节交换后的版本拼接。\n\n*   **D. `assign result = {val, (val[3:0] << 4) | (val[7:4] >> 4)};`**\n    该选项试图使用按位移位运算符来执行半字节交换。然而，它将运算符应用于4位操作数。在 Verilog 中，移位运算的结果宽度与其左操作数相同。\n    - `val[3:0]` 是一个4位值。`val[3:0] << 4` 将这个4位值左移4个位置。所有原始比特都被移出，结果为 `4'b0000`。\n    - `val[7:4]` 是一个4位值。`val[7:4] >> 4` 将这个4位值右移4个位置。所有原始比特也都被移出，结果同样为 `4'b0000`。\n    - 按位或运算 `(4'b0000 | 4'b0000)` 的结果是 `4'b0000`。在拼接的上下文中，这个4位值将被零扩展为8位。因此，该语句实际上是 `assign result = {val, 8'b00000000};`，这是不正确的。\n\n*   **E. `assign result = {val[7:0], val[4:7], val[0:3]};`**\n    Verilog 部分选择的标准语法要求位索引的形式为 `[msb_index : lsb_index]`。表达式 `val[4:7]` 和 `val[0:3]` 违反了此规则，因为冒号左侧的索引小于右侧的索引。该语句会在编译期间导致语法错误，并且不是有效的 Verilog 代码。\n\n基于此分析，只有选项 A 正确且有效地实现了所需的逻辑。", "answer": "$$\\boxed{A}$$", "id": "1975749"}, {"introduction": "数字电路中的计算很少是单一操作的，通常是多种运算符的组合。本练习模拟了一个真实的数据路径计算，它要求你精确追踪一个涉及位与（`&`）、算术右移（`>>>`）和加法（`+`）的复杂表达式的求值过程 [@problem_id:1975764]。处理这个挑战能让你深入理解 Verilog 如何处理有符号数的二进制补码表示，以及在混合运算中如何确定中间结果的位宽和最终值，这些都是避免设计中出现意外逻辑错误的关键。", "problem": "在一个基于 Verilog 硬件描述语言 (HDL) 平台的数字逻辑仿真环境中，一个小型计算模块正在进行测试。\n\n该模块包含三个有符号寄存器，定义如下：`reg signed [4:0] operand_A;`、`reg signed [4:0] operand_B;` 和 `reg signed [5:0] result_reg;`。\n\n最初，这些寄存器被设置为特定的十进制值：`operand_A` 被初始化为 `9`，`operand_B` 被初始化为 `-12`。\n\n随后，执行一个单一的阻塞赋值操作：\n`result_reg = (operand_A & operand_B) + (operand_B >>> 2);`\n\n假设遵循标准的 Verilog 语义，其中 `&` 是按位与运算符，`>>>` 是算术右移运算符，`+` 是加法运算符。中间表达式的位宽由该表达式中最大操作数的位宽决定。右侧表达式计算出的最终值随后被赋给左侧的寄存器，如果目标寄存器更宽，则会进行符号位扩展。\n\n你的任务是确定在此操作完成后，存储在 `result_reg` 中的最终有符号十进制值。", "solution": "我们处理的是有符号二进制补码整数。寄存器 $operand\\_A$ 和 $operand\\_B$ 是 $[4:0]$（5位，范围从 $-16$ 到 $15$），而 $result\\_reg$ 是 $[5:0]$（6位，范围从 $-32$ 到 $31$）。每个子表达式的位宽等于其操作数的最大位宽；此处所有操作数均为5位，因此每个子表达式都是5位有符号数，并且在最终赋值给6位目标时，会对5位结果进行符号位扩展。\n\n将数值用5位二进制补码表示：\n$$9 \\to 01001_{2}, \\quad -12:\\ 12=01100_{2},\\ \\text{invert}\\to 10011_{2},\\ \\text{add }1\\to 10100_{2}.$$\n因此 $operand\\_A=01001_{2}$ 且 $operand\\_B=10100_{2}$。\n\n计算按位与（结果为5位）：\n$$01001_{2}\\ \\text{AND}\\ 10100_{2} = 00000_{2}.$$\n\n计算将 $operand\\_B$ 算术右移 $2$ 位（由于该值为负，需复制符号位）：\n$$10100_{2} \\xrightarrow{\\text{arith.\\ shift right by }1} 11010_{2} \\xrightarrow{\\text{arith.\\ shift right by }1} 11101_{2}.$$\n\n将两个5位有符号结果相加：\n$$00000_{2} + 11101_{2} = 11101_{2}.$$\n\n将结果赋给 $result\\_reg$ $[5:0]$ 并进行符号位扩展（扩展到6位）：\n$$11101_{2} \\to 111101_{2}.$$\n\n将 $111101_{2}$ 解释为一个6位有符号数：\n$$111101_{2} = -3.$$\n因此，存储在 $result\\_reg$ 中的最终有符号十进制值为 $-3$。", "answer": "$$\\boxed{-3}$$", "id": "1975764"}, {"introduction": "最高效的硬件设计往往源于对位运算的深刻洞察和巧妙运用。这个练习将向你展示一个经典且极其高效的“位技巧”，用于在单个时钟周期内快速找到并分离出总线上的最低有效请求 [@problem_id:1975721]。通过结合一个算术运算符和一个位运算符，你将学习如何利用二进制补码的特性来实现看似复杂的功能，这不仅能解决问题，更能启发你用更“硬件”的方式思考。", "problem": "在为一个定制片上系统（SoC）设计低延迟优先级仲裁器时，您的任务是创建一个特定的Verilog硬件模块。该仲裁器接收一个名为`requests`的`N`位输入向量，其中 `reg [N-1:0] requests;`。每一位`requests[i]`表示来自设备`i`的一个请求。您的目标是生成一个`N`位的输出向量`grant`，该向量仅确认索引最低（即，最低有效位）的有效请求。例如，如果`requests`是`8'b01011000`，那么`grant`输出应该是`8'b00001000`。\n\n为了满足严格的时序约束，整个逻辑必须通过一个形式为`assign grant = <expression>;`的单一Verilog连续赋值语句来实现。右侧的表达式必须遵守两条关键规则：\n1. 必须且只能使用一个从集合{`&`（按位与）、`|`（按位或）、`^`（按位异或）、`~`（按位非）}中选择的按位运算符。\n2. 必须且只能使用一个从集合{`+`（加法）、`-`（减法/求负）}中选择的算术运算符。\n\n您可以假设输入向量`requests`始终为非零。下列哪个表达式为`grant`向量正确地实现了所需逻辑？\n\nA. `requests & -requests`\n\nB. `requests ^ (requests - 1)`\n\nC. `requests & (requests + 1)`\n\nD. `requests & (requests - 1)`\n\nE. `requests | -requests`", "solution": "该问题要求我们找到一个Verilog表达式，该表达式使用一个按位运算符和一个算术运算符，来分离出一个非零输入向量`requests`中最低有效置位（LSB）。为简单起见，我们将输入向量表示为`x`。目标是计算一个输出`y`，使得`y`在`x`的最低有效置位（LSB）位置上为'1'，而在其他所有位置上都为'0'。\n\n解决方案依赖于二的补码表示法的特性，Verilog就是使用这种方式来处理有符号算术的。一个数`x`的二的补码负数（即`-x`），在数学上等效于`~x + 1`。\n\n让我们分析一个非零二进制数`x`的结构。我们可以将`x`表示为三个部分的串联：一个高位比特串`A`、最低有效位的'1'，以及一个由`k`个零组成的尾随比特串`B`。\n所以，$x = A1B$，其中$B = 00...0$（$k$次）。\n\n例如，如果$x = 12$（二进制为`...001100`），那么$A = ...001$，最低有效置位是位于$2^2$位置上的'1'，并且$B = 00$（$k=2$）。\n\n现在，让我们使用二的补码公式 $ -x = \\sim x + 1 $ 来计算`-x`。\n1.  首先，我们计算`~x`（按位非）：\n    $ \\sim x = \\sim(A1B) = (\\sim A)0(\\sim B) $。\n    因为`B`是一个由`k`个零组成的串，所以`~B`是一个由`k`个一组成的串。\n    因此，$ \\sim x = (\\sim A)0(11...1) $，其中有`k`个一。\n\n2.  接下来，我们将1加到`~x`上：\n    $ \\sim x + 1 = (\\sim A)0(11...1) + 1 $。\n    将1加到一个由`k`个一组成的串（`11...1`）上，会产生一个进位，该进位会穿过所有的'1'并将它们翻转为'0'，直到遇到最右边的'0'。这个'0'会翻转为'1'，并且进位停止。\n    结果是'1'后面跟着`k`个零（`100...0`）。\n    所以，$ -x = (\\sim A)1(00...0) = (\\sim A)1B $。\n\n现在我们有了`x`和`-x`的表达式：\n$x  = A1B$\n$-x = (\\sim A)1B$\n\n最后一步是应用一个按位运算符。让我们根据问题的约束，尝试使用按位与（`&`）运算符。\n$ y = x \\ \\ \\ (-x) = (A1B) \\ \\ \\ ((\\sim A)1B) $\n\n我们可以对各个部分执行与（AND）操作：\n- 高位比特：$ A \\ \\ \\ (\\sim A) $。对于任何比特串`A`，此操作的结果始终是全零。\n- LSB（最低有效置位）位置：$ 1 \\ \\ \\ 1 = 1 $。\n- 尾随的零比特：$ B \\ \\ \\ B = (00...0) \\ \\ \\ (00...0) = 00...0 $。\n\n结合这些结果，我们得到：\n$ y = (0...0)1(0...0) $。\n这是一个只在原始数字`x`的最低有效置位的精确位置上有一个'1'的数字。\n\n这与选项A中的表达式`requests  -requests`相符。该表达式使用了一个按位运算符（``）和一个算术运算符（`-`），满足所有给定的约束条件。\n\n让我们用一个例子快速检查其他选项，设 `x = 6`（`...0110`）：\n- `x = ...0110`\n- `-x = ~x + 1 = (...1001) + 1 = ...1010`\n- `x-1 = 5 = ...0101`\n- `x+1 = 7 = ...0111`\n\nB. `requests ^ (requests - 1)` - `...0110 ^ ...0101 = ...0011`。不正确。\nC. `requests  (requests + 1)` - `...0110  ...0111 = ...0110`。不正确，未改变原始值。\nD. `requests  (requests - 1)` - `...0110  ...0101 = ...0100`。这会*清除*最低有效置位，而不是分离它。不正确。\nE. `requests | -requests` - `...0110 | ...1010 = ...1110`。不正确。\n\n因此，唯一正确的表达式是 `requests  -requests`。", "answer": "$$\\boxed{A}$$", "id": "1975721"}]}