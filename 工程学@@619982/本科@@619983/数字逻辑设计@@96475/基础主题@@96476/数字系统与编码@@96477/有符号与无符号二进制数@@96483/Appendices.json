{"hands_on_practices": [{"introduction": "第一个练习为处理定长比特系统中的有符号数提供了基础实践。你需要将一个6位的二进制补码数转换为其等效的十进制数并执行一次简单的加法，这是理解处理器如何执行基本算术运算的核心技能。这个问题强化了解读和操作有符号二进制数据的过程。[@problem_id:1960895]", "problem": "在一个为物理实验定制的微控制器中，数据值通过6位寄存器进行处理。\n\n该系统中的有符号整数使用二进制补码表示法进行表示。\n\n两个寄存器 `R1` 和 `R2` 分别存储二进制值 `011011` 和 `101010`。一个算术逻辑单元 (ALU) 被指令计算存储在这两个寄存器中的有符号整数之和。\n\n计算操作 `R1 + R2` 的结果。请将您的最终答案表示为单个有符号十进制整数。", "solution": "在一个6位二进制补码系统中，可表示的范围是从 $-2^{5}$ 到 $2^{5}-1$，即 $[-32, 31]$。对于一个6位的字 $b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}$，如果最高有效位 $b_{5}=0$，则其值是常规的无符号和；如果 $b_{5}=1$，则其值为负，等于其二进制补码绝对值的负数。\n\n寄存器 $R1$ 的值为 $011011_{2}$，其最高有效位为 $0$，因此它是一个非负数，其值通过按权展开计算得出：\n$$\n\\operatorname{val}(R1)=0\\cdot 2^{5}+1\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=16+8+2+1=27.\n$$\n\n寄存器 $R2$ 的值为 $101010_{2}$ ，其最高有效位为 $1$，因此它是一个负数。其二进制补码的绝对值通过将各位取反再加 $1$ 得到：\n$$\n101010_{2}\\ \\xrightarrow{\\text{invert}}\\ 010101_{2}\\ \\xrightarrow{+1}\\ 010110_{2}.\n$$\n因此，其绝对值为\n$$\n|R2|=0\\cdot 2^{5}+1\\cdot 2^{4}+0\\cdot 2^{3}+1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=16+4+2=22,\n$$\n所以\n$$\n\\operatorname{val}(R2)=-22.\n$$\n\nALU 计算这两个有符号整数的和：\n$$\n\\operatorname{val}(R1)+\\operatorname{val}(R2)=27+(-22)=5.\n$$\n由于 $5\\in[-32,31]$，没有发生溢出，结果为有符号十进制整数 $5$。", "answer": "$$\\boxed{5}$$", "id": "1960895"}, {"introduction": "在基本加法的基础上，下一个练习挑战你思考数字系统的边界。通过确定导致算术溢出的最小正数，你将对补码表示的有限范围有更深的直观理解。这是防止数字计算中出现错误的关键概念。[@problem_id:1960935]", "problem": "考虑一个使用8位架构的专用数字信号处理器。该处理器使用标准的二进制补码格式来表示有符号整数。一个运算任务被调度，其中一个特定的数 $A = 01000001$ 将与另一个数 $B$ 相加。\n\n您的任务是找到最小的正8位二进制补码整数 $B$，当它与 $A$ 相加时，会导致算术溢出。\n\n请以8位二进制字符串的形式提供 $B$ 的值。", "solution": "问题要求我们找到最小的正8位二进制补码整数 $B$，当它与 $A = 01000001$ 相加时会导致溢出。\n\n首先，让我们了解8位二进制补码系统的属性。对于一个 $n$ 位系统，可表示的整数范围是从 $-2^{n-1}$ 到 $2^{n-1}-1$。当 $n=8$ 时，范围是从 $-2^{8-1}$ 到 $2^{8-1}-1$，即 $-128$ 到 $127$。\n\n接下来，我们确定给定的数 $A = 01000001$ 的十进制值。最高有效位 (MSB) 是 0，这表示 $A$ 是一个正数。其十进制值的计算如下：\n$A = 0 \\cdot (-2^7) + 1 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 2^4 + 0 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0$\n$A = 64 + 1 = 65$\n\n在二进制补码中，当加法结果超出可表示范围时，就会发生算术溢出。具体到本问题，我们是将两个正数相加：$A$（即+65）和 $B$（指定为正数）。如果它们的和大于可表示的最大正数 127，就会发生溢出。\n\n因此，溢出的条件是：\n$A + B > 127$\n\n代入 $A$ 的十进制值：\n$65 + B > 127$\n\n为了找到 $B$ 的最小值，我们解这个不等式：\n$B > 127 - 65$\n$B > 62$\n\n问题要求的是满足此条件的最小正*整数* $B$。严格大于62的最小整数是63。\n因此，$B$ 的十进制值是 63。\n\n最后，我们需要将这个十进制值转换回其8位二进制补码表示。由于63是一个正数，其表示是标准的二进制转换，并在前面填充零以使其长度达到8位。\n$63 = 32 + 16 + 8 + 4 + 2 + 1$\n$63 = 0 \\cdot 2^7 + 0 \\cdot 2^6 + 1 \\cdot 2^5 + 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0$\n\n在二进制中，这是 $00111111_2$。\n\n为了验证，我们来执行 $A$ 和 $B$ 的二进制加法：\n$A = 01000001_2$（+65）\n$B = 00111111_2$（+63）\n和：\n```\n  01000001\n+ 00111111\n----------\n  10000000\n```\n结果是 $10000000_2$。最高有效位是1，在二进制补码中表示一个负数（具体来说是-128）。由于两个正数的和产生了一个负数结果，因此发生了溢出，这证实了我们的答案。任何小于63的正整数都不会导致和超过127，因此不会引起溢出。例如，如果 $B=62$，和是 $65+62=127$，即 $01111111_2$，这是一个有效的正数结果。", "answer": "$$\\boxed{00111111}$$", "id": "1960935"}, {"introduction": "我们最后的练习解决了一个常见的混淆点：处理器状态寄存器中进位标志（carry-out）和溢出标志（overflow）之间的区别。这个问题要求你识别一个特定的场景，其中产生了进位，但算术结果仍然有效（无溢出）。掌握这种区别对于准确调试和设计可靠的算术电路至关重要。[@problem_id:1960941]", "problem": "在数字系统中，有符号整数通常使用补码（2's complement）格式来表示。考虑一个对此类数字进行算术运算的8位处理器。一个8位补码数的有效范围是从-128到+127。当两个数相加时，通常会考虑两个重要的标志位：来自最高有效位（MSB）的进位输出标志（$C_{\\text{out}}$），以及溢出标志（$V$），它指示结果是否因超出可表示范围而在算术上不正确。\n\n你将得到四对8位补码数。你的任务是找出哪一对数相加后，会产生来自最高有效位的进位输出（$C_{\\text{out}} = 1$），但**不会**导致算术溢出（$V = 0$）。\n\n下列哪一对8位补码数满足这些标准？\n\nA. `11111111` 和 `11111110`\n\nB. `10011100` 和 `10011100`\n\nC. `01100100` 和 `01100100`\n\nD. `00010100` 和 `00011110`", "solution": "问题要求我们找出一对8位补码数，它们相加后会产生来自最高有效位（MSB）的进位输出，但不会引起算术溢出。\n\n首先，我们来确定8位补码算术的规则。\n可表示的数值范围是 $[-2^{8-1}, 2^{8-1}-1]$，即 $[-128, 127]$。\n如果一个数的最高有效位（第7位）是1，则该数为负数；如果最高有效位是0，则为正数或零。\n\n算术溢出在两种情况下发生：\n1.  两个正数之和得到一个负数（和的MSB为1）。\n2.  两个负数之和得到一个正数（和的MSB为0）。\n一个正数和一个负数相加永远不会导致溢出。\n\n进位输出（$C_{\\text{out}}$）是在最高有效位（第7位）位置上进行加法时产生的进位。\n\n检测溢出的一个常用方法是比较进入最高有效位的进位（$C_{\\text{in},7}$）和从最高有效位产生的进位输出（$C_{\\text{out}}$）。当且仅当 $C_{\\text{in},7} \\neq C_{\\text{out}}$ 时，发生溢出。题目要求没有溢出，这意味着我们在寻找一个 $C_{\\text{in},7} = C_{\\text{out}}$ 的情况。又因为题目要求 $C_{\\text{out}}=1$，所以我们具体要找的是 $C_{\\text{in},7}=1$ 且 $C_{\\text{out}}=1$ 的情况。\n\n我们来逐个分析每个选项。\n\n**A. `11111111` 和 `11111110`**\n- **十进制值：**\n  - `11111111` 是-1的补码表示。\n  - `11111110` 是-2的补码表示。\n- **预期和：** $(-1) + (-2) = -3$。这个值在 [-128, 127] 的范围内，所以不应发生溢出。\n- **二进制加法：**\n  ```\n     11111111   (进位)\n     11111111   (-1)\n   + 11111110   (-2)\n   -----------\n   1 11111101\n  ```\n- **分析：**\n  - 8位结果是 `11111101`，这是-3的补码。结果在算术上是正确的，因此**没有溢出**。\n  - 从最高有效位位置产生了一个为1的进位。因此，**$C_{\\text{out}} = 1$**。\n- 这对数满足了两个条件：$C_{\\text{out}} = 1$ 且没有溢出。\n\n**B. `10011100` 和 `10011100`**\n- **十进制值：**\n  - `10011100` 是`01100100` (100)的补码。所以，`10011100` 表示 -100。\n- **预期和：** $(-100) + (-100) = -200$。这个值超出了 [-128, 127] 的范围。一定会发生溢出。\n- **二进制加法：**\n  ```\n      11  111     (进位)\n     10011100   (-100)\n   + 10011100   (-100)\n   -----------\n   1 01011000\n  ```\n- **分析：**\n  - 8位结果是 `01011000`，表示+88。因为我们加了两个负数却得到了一个正数结果，所以**发生了溢出**。\n  - 从最高有效位位置产生了一个为1的进位。因此，**$C_{\\text{out}} = 1$**。\n- 这对数不满足“没有溢出”的条件。\n\n**C. `01100100` 和 `01100100`**\n- **十进制值：**\n  - `01100100` 表示 +100。\n- **预期和：** $100 + 100 = 200$。这个值超出了 [-128, 127] 的范围。一定会发生溢出。\n- **二进制加法：**\n  ```\n     1  1        (进位)\n     01100100   (+100)\n   + 01100100   (+100)\n   -----------\n   0 11001000\n  ```\n- **分析：**\n  - 8位结果是 `11001000`，表示-56。因为我们加了两个正数却得到了一个负数结果，所以**发生了溢出**。\n  - 从最高有效位位置没有产生进位。因此，**$C_{\\text{out}} = 0$**。\n- 这对数两个条件都不满足。\n\n**D. `00010100` 和 `00011110`**\n- **十进制值：**\n  - `00010100` 表示 +20。\n  - `00011110` 表示 +30。\n- **预期和：** $20 + 30 = 50$。这个值在 [-128, 127] 的范围内，所以不应发生溢出。\n- **二进制加法：**\n  ```\n       111       (进位)\n     00010100   (+20)\n   + 00011110   (+30)\n   -----------\n   0 00110010\n  ```\n- **分析：**\n  - 8位结果是 `00110010`，表示+50。结果在算术上是正确的，因此**没有溢出**。\n  - 从最高有效位位置没有产生进位。因此，**$C_{\\text{out}} = 0$**。\n- 这对数不满足“$C_{\\text{out}}=1$”的条件。\n\n**结论：**\n只有选项A中的数对 `11111111` 和 `11111110`，其相加结果会从最高有效位产生1的进位输出，同时得到一个正确的和（没有溢出）。", "answer": "$$\\boxed{A}$$", "id": "1960941"}]}