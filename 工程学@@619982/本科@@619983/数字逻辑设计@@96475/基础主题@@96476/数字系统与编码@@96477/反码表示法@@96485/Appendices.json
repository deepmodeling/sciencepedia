{"hands_on_practices": [{"introduction": "在深入研究反码算术之前，我们首先需要掌握其最基本的技能：如何表示数字。本练习将带你回到早期计算时代，模拟向一个使用反码系统的老式处理器输入一个负值的过程。这个实践旨在巩固从十进制负数到其二进制反码表示的转换规则，这是理解和使用反码进行任何计算的第一步。[@problem_id:1949361]", "problem": "一位古董计算爱好者正在修复一颗来自20世纪70年代初的8位微处理器。这颗处理器与通常使用二进制补码的现代处理器不同，它使用二进制反码系统来表示有符号整数。在这个系统中，正数由其标准二进制等价形式表示，最高有效位（MSB）为0。负数则是通过对其正数对应值进行按位取反（翻转所有位）来得到的。\n\n这位爱好者正在测试算术逻辑单元（ALU），需要将十进制数值 $-21$ 输入到一个寄存器中。十进制数 $-21$ 正确的8位二进制反码表示是什么？\n\n从以下选项中选择正确的二进制字符串。\n\nA. `11101010`\n\nB. `11101011`\n\nC. `10010101`\n\nD. `01101010`\n\nE. `00010101`", "solution": "在8位二进制反码中，负数是通过对正数的8位表示进行按位取反来获得的。设一个正整数的8位表示为 $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}$，其中 $b_{7}$ 是最高有效位（MSB）。对于一个正数，$b_{7}=0$。二进制反码的求反运算按位定义为\n$$\nb_{i}'=1-b_{i}\\quad\\text{for all }i\\in\\{0,1,\\dots,7\\}.\n$$\n首先，将 $+21$ 写成8位二进制数。使用按位展开，\n$$\n21=16+4+1=2^{4}+2^{2}+2^{0},\n$$\n因此低7位是 $b_{4}=1$，$b_{2}=1$，$b_{0}=1$，其余各位为零，而最高有效位 $b_{7}=0$ 以表示正值。因此\n$$\n+21=(00010101)_{2}.\n$$\n应用二进制反码（按位取反），\n$$\n-21:\\quad (00010101)_{2}\\ \\longrightarrow\\ (11101010)_{2}.\n$$\n与选项比较，这与选项A匹配。", "answer": "$$\\boxed{A}$$", "id": "1949361"}, {"introduction": "反码加法的一个独特之处在于其“循环进位”（end-around carry）机制，这是它与我们更熟悉的补码算术的关键区别。通过模拟一个 4 位处理器连续执行“加一”指令的过程，本练习让你亲手操作并观察循环进位的发生。你将看到数字如何从负数通过“负零”过渡到正数，从而深刻理解反码加法的核心工作原理。[@problem_id:1949343]", "problem": "一个老式的4位微处理器正在被分析。该处理器对有符号整数使用反码表示法。在此系统中，负数是通过对其对应正数进行按位取反（翻转所有位）形成的。加法运算使用标准二进制算术执行，其关键规则是：如果加法运算从最高有效位产生一个进位，则此进位位必须加到结果的最低有效位上。这个过程被称为循环进位。\n\n该处理器中的一个特定寄存器被初始化为对应于十进制数$-2$的值。随后，处理器连续三次执行“自增”指令。每个“自增”指令将值$+1$（在4位二进制中表示为`0001`）与寄存器中存储的当前值进行二进制相加。\n\n设$R_0$是寄存器中表示$-2$的初始4位二进制值。设$R_1$、$R_2$和$R_3$分别是经过第一次、第二次和第三次自增运算后寄存器中的4位二进制值。以下哪个选项正确地列出了二进制值序列$(R_1, R_2, R_3)$？\n\nA. `(1110, 1111, 0001)`\n\nB. `(1110, 1111, 0000)`\n\nC. `(1111, 0000, 0001)`\n\nD. `(1011, 1100, 1101)`\n\nE. `(1111, 0001, 0010)`", "solution": "在一个4位反码系统中，负数由其对应正数按位取反形成。正值$+2$是$0010_{2}$，所以表示$-2$的初始寄存器值$R_0$是\n$$\nR_{0} = \\overline{0010} = 1101_{2}.\n$$\n每次自增都加上$+1$（表示为$0001_{2}$），使用带循环进位的二进制加法：如果最高有效位有进位，该进位将加到和的最低有效位上。\n\n第一次自增：\n$$\nR_{1} = R_{0} + 0001_{2} = 1101_{2} + 0001_{2} = 1110_{2},\n$$\n没有产生进位，所以$R_{1} = 1110$。\n\n第二次自增：\n$$\nR_{2} = R_{1} + 0001_{2} = 1110_{2} + 0001_{2} = 1111_{2},\n$$\n没有产生进位，所以$R_{2} = 1111$。\n\n第三次自增：\n$$\nR_{3} = R_{2} + 0001_{2} = 1111_{2} + 0001_{2} = 0000_{2} \\text{ with carry-out } 1.\n$$\n应用循环进位：\n$$\n0000_{2} + 0001_{2} = 0001_{2},\n$$\n所以$R_{3} = 0001$。\n\n因此，序列为$(R_{1}, R_{2}, R_{3}) = (1110, 1111, 0001)$，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1949343"}, {"introduction": "任何使用固定位数来表示数字的系统都有其表示范围的限制。当计算结果超出这个范围时，就会发生“溢出”，导致结果不正确。本练习探讨的就是这种情况，通过将两个正数相加，其和超出了 8 位反码系统能表示的正数范围。通过这个实践，你将学会如何识别反码加法中的溢出条件，这是编写可靠软件和设计稳健硬件的一项至关重要的技能。[@problem_id:1949378]", "problem": "一位工程师的任务是验证一个旧式8位微处理器的行为，已知该处理器对有符号整数使用反码表示法。在该系统中，正数的符号位为0，负数的符号位为1，其表示方式为对应正数的按位取反。\n\n工程师执行了一项测试操作，指令处理器的算术逻辑单元 (ALU) 将十进制数值 $+70$ 和 $+80$ 相加。ALU 执行加法运算，并将输出结果存储在一个8位寄存器中。如果两个同符号数相加的结果与原数符号相反，则设置溢出标志位。\n\n根据8位反码算术规则，确定结果寄存器中的二进制模式对应的十进制值，并判断是否发生了溢出。\n\nA: 结果是-105，且发生了溢出。\n\nB: 结果是-106，且发生了溢出。\n\nC: 结果是-105，且未发生溢出。\n\nD: 结果是+150，且发生了溢出。\n\nE: 结果是-106，且未发生溢出。", "solution": "在8位反码中，正数的符号位为 $0$，并以标准二进制表示；负数的符号位为 $1$，并表示为相应正数大小的按位取反。可表示的范围是从 $-127$ 到 $+127$。\n\n对操作数进行编码：\n$+70$ 的8位二进制表示是 $0100\\,0110_{2}$，$+80$ 的8位二进制表示是 $0101\\,0000_{2}$。\n\n执行8位二进制加法（如果最高有效位有进位，则可能需要循环进位）：\n$$0100\\,0110_{2} + 0101\\,0000_{2} = 1001\\,0110_{2}.$$\n最高有效位没有产生进位，因此不添加循环进位。\n\n以反码解释结果 $1001\\,0110_{2}$。由于符号位是 $1$，所以它是一个负数。其绝对值通过按位取反得到：\n$$\\text{NOT}(1001\\,0110_{2}) = 0110\\,1001_{2}.$$\n计算其绝对值：\n$$0110\\,1001_{2} = 64 + 32 + 8 + 1 = 105.$$\n因此，存储的结果对应于 $-105$。\n\n判断溢出。给定的规则指出，如果两个同符号数相加得到的结果符号相反，则设置溢出标志位。两个输入都是正数（符号位为 $0$），而结果的符号位为 $1$，所以发生了溢出。等效地，符号位的进位为 $1$ 而最高位的进位为 $0$，这也表示在反码加法中发生了溢出。\n\n因此，正确的选项是结果为 $-105$ 且发生了溢出。", "answer": "$$\\boxed{A}$$", "id": "1949378"}]}