{"hands_on_practices": [{"introduction": "在数字系统中，数的表示和运算都受限于固定的位数。这个练习将带你探究当算术运算的结果超出了系统所能表示的范围时会发生什么，即“溢出”。通过一个简单的4位二进制加法 [@problem_id:1914561]，你将亲身体验两个正数相加如何得出一个看似无关的负数结果，从而深刻理解二进制补码溢出的原理及其在实际编程中的重要性。", "problem": "一款低功耗环境传感器的原型机使用一个专用的4位处理器来执行初始数据滤波。该处理器使用4位二进制补码系统来表示有符号整数。在一次测试运行中，该处理器需要将两个传感器读数相加，这两个读数由二进制值 $X = 0110_2$ 和 $Y = 0100_2$ 表示。其和存储在一个4位寄存器中。下列哪个陈述准确地描述了这次加法的结果？\n\nA. 加法结果为正确的十进制值+10，且没有发生溢出。\nB. 加法导致溢出，且存储的4位二进制值表示十进制值-6。\nC. 加法导致溢出，且存储的4位二进制值表示十进制值+2。\nD. 加法没有导致溢出，且存储的4位二进制值为 $0000_2$。\nE. 加法导致溢出，且存储的4位二进制值与该系统中可表示的最大负数的表示形式相同。", "solution": "在一个4位二进制补码系统中，可表示的范围由 $[-2^{n-1},\\,2^{n-1}-1]$ 给出，其中 $n=4$，因此范围是 $[-8,\\,7]$。给定的操作数是 $X=0110_{2}$ 和 $Y=0100_{2}$，它们的最高有效位（MSB）都为0，所以它们都是非负数。转换为十进制后，$0110_{2}=+6$ 且 $0100_{2}=+4$，所以真实的数学和是+10，这超出了可表示的范围，表明预计会发生溢出。\n\n执行4位加法：\n- 位 $0$：$0+0=0$，进位 $0$。\n- 位 $1$：$1+0=1$，进位 $0$。\n- 位 $2$：$1+1=0$，带进位 $1$。\n- 位 $3$ (MSB)：$0+0$+进位 $1=1$，向外进位 $0$。\n\n因此，存储的4位结果是\n$$0110_{2}+0100_{2}=1010_{2}$$\n补码中的溢出检测可以通过以下任一规则来检查：两个同符号操作数相加得到一个符号相反的结果，或者进入最高有效位(MSB)的进位与从MSB产生的向外进位不同。在这里，两个操作数的符号位都是0，而结果的符号位是1，所以发生了溢出。等效地，进入MSB的进位是1，而向外进位是0，所以发生了溢出。\n\n将存储的4位值 $1010_{2}$ 按补码解释：由于MSB是1，所以它是一个负数。其绝对值通过求补运算得到：\n$$\\text{invert}(1010_{2})=0101_{2},\\quad 0101_{2}+0001_{2}=0110_{2}$$\n所以 $1010_{2}$ 在十进制中表示 $-6$。\n\n因此，该加法导致溢出，并且存储的4位二进制值表示十进制值-6，与选项B匹配。", "answer": "$$\\boxed{B}$$", "id": "1914561"}, {"introduction": "在真实的计算中，算术逻辑单元（ALU）经常需要处理不同位宽的操作数。这个练习探讨了一个核心问题：如何将一个较小位宽的数扩展为较大位宽的数？通过对比“符号扩展”（sign-extension）和“零扩展”（zero-extension）这两种不同方法 [@problem_id:1914502]，你将理解它们如何影响数值的解释和最终的计算结果，这是正确处理混合精度运算的关键。", "problem": "一个数字系统的 8 位算术逻辑单元 (ALU) 使用二进制补码表示法对有符号整数进行运算。该 ALU 设计用于执行两个 8 位操作数 $X$ 和 $Y$ 的加法运算。\n\n在一次特定操作中，第一个操作数固定为 $X = 01011010_2$。\n\n第二个操作数 $Y$ 由一个 4 位输入值 $B = 1100_2$ 派生而来。在进行加法运算之前，$B$ 必须被扩展为 8 位。正在评估两种不同的扩展方法：\n\n1.  **零扩展**：通过在 4 位值 $B$ 前面填充四个前导零，将其扩展为一个 8 位操作数 $Y_{zero}$。\n2.  **符号扩展**：将 4 位值 $B$ 解释为一个 4 位二进制补码数，并使用标准符号扩展过程将其扩展为一个 8 位操作数 $Y_{sign}$。\n\nALU 计算两个独立的结果：$R_{zero} = X + Y_{zero}$ 和 $R_{sign} = X + Y_{sign}$。结果 $R_{zero}$ 和 $R_{sign}$ 都以 8 位有符号二进制补码数的形式存储。\n\n计算这两个结果的十进制整数值之差，定义为 $Value(R_{zero}) - Value(R_{sign})$。请以单个十进制整数的形式提供最终答案。", "solution": "8 位有符号二进制补码的表示范围是 $[-2^{7},\\,2^{7}-1]=[-128,\\,127]$。4 位有符号二进制补码的表示范围是 $[-2^{3},\\,2^{3}-1]=[-8,\\,7]$。\n\n固定操作数为 $X=01011010_{2}$。由于最高有效位是 $0$，因此 $X$ 是一个非负数。其值通过按位权计算得出：\n$$\nX=0\\cdot 2^{7}+1\\cdot 2^{6}+0\\cdot 2^{5}+1\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=64+16+8+2=90\n$$\n4 位输入为 $B=1100_{2}$。\n- 零扩展：在前导位填充四个零：$Y_{\\text{zero}}=00001100_{2}$。将其解释为最高有效位为 0 的 8 位有符号整数，其值为\n$$\nY_{\\text{zero}}=0\\cdot 2^{7}+0\\cdot 2^{6}+0\\cdot 2^{5}+0\\cdot 2^{4}+1\\cdot 2^{3}+1\\cdot 2^{2}+0\\cdot 2^{1}+0\\cdot 2^{0}=8+4=12\n$$\n- 符号扩展：首先将 $B$ 解释为 4 位二进制补码数。由于 $B$ 的最高有效位是 $1$，因此它是一个负数。使用带符号的位权展开法，\n$$\nB=1\\cdot(-2^{3})+1\\cdot 2^{2}+0\\cdot 2^{1}+0\\cdot 2^{0}=-8+4=-4\n$$\n通过复制符号位将其符号扩展到 8 位，得到 $Y_{\\text{sign}}=11111100_{2}$，其 8 位二进制补码值同样是 $-4$（这与符号扩展保持数值不变的特性相符）。\n\nALU 的计算结果是\n$$\nR_{\\text{zero}}=X+Y_{\\text{zero}}=90+12=102,\\qquad R_{\\text{sign}}=X+Y_{\\text{sign}}=90+(-4)=86\n$$\n这两个结果都在 $[-128,127]$ 范围内，因此没有发生溢出。\n\n因此，所求的差值为\n$$\n\\text{Value}(R_{\\text{zero}})-\\text{Value}(R_{\\text{sign}})=102-86=16\n$$\n等价地，根据线性性质，\n$$\n\\text{Value}(R_{\\text{zero}})-\\text{Value}(R_{\\text{sign}})=(X+Y_{\\text{zero}})-(X+Y_{\\text{sign}})=Y_{\\text{zero}}-Y_{\\text{sign}}=12-(-4)=16\n$$", "answer": "$$\\boxed{16}$$", "id": "1914502"}, {"introduction": "为了方便读写，工程师和程序员通常使用十六进制和八进制来紧凑地表示二进制数据。本练习模拟了一个在微处理器编程中常见的真实场景：在执行算术运算之前，必须先将来自不同数制（十六进制和八进制）的操作数进行转换 [@problem_id:1914540]。通过解决这个问题，你不仅能巩固不同数制之间转换的技能，还能将其应用于实际的二进制减法运算中。", "problem": "一个假设的16位微处理器中的算术逻辑单元 (ALU) 的任务是执行一条减法指令。该微处理器的内部架构使用16位二进制补码系统来表示所有有符号整数。\n\n需要执行的操作是 `R = A - B`。操作数 `A` 从一个内存地址加载，其存储的十六进制值为 $D4B_{16}$。操作数 `B` 从另一个地址加载，其存储的八进制值为 $3157_8$。\n\n您的任务是确定当结果 `R` 存储在一个16位寄存器中时的最终值。请用 `R` 的16位二进制表示来表达您的最终答案。", "solution": "在16位二进制补码系统中，最高有效位为 $0$ 的值直接表示非负整数，而减法 $R=A-B$ 是通过常规的二进制算术在模 $2^{16}$ 下执行的。\n\n将操作数解释为一致的16位形式。十六进制操作数是 $A=(D4B)_{16}=(0D4B)_{16}$。按半字节（nibble）将其转换为二进制，得到\n$$(0D4B)_{16} \\to (0000\\ 1101\\ 0100\\ 1011)_{2}=(0000110101001011)_{2}$$\n对于八进制操作数 $B=(3157)_{8}$，通过转换规则 $3\\mapsto 011$、$1\\mapsto 001$、$5\\mapsto 101$、$7\\mapsto 111$ 将其转换为二进制，得到\n$$(3157)_{8}=(011001101111)_{2}$$\n填充至16位，并可根据需要重新组合为十六进制：\n$$(011001101111)_{2}=(0000\\ 0110\\ 0110\\ 1111)_{2}=(066F)_{16}$$\n\n用十六进制计算减法：\n$$R=A-B=(0D4B)_{16}-(066F)_{16}=(06DC)_{16}$$\n这可以通过带借位的逐位相减来验证。\n\n将结果按半字节转换为16位二进制：\n$$(06DC)_{16} \\to (0000\\ 0110\\ 1101\\ 1100)_{2}=(0000011011011100)_{2}$$\n\n作为十进制下的一致性检验，$A=13\\cdot 16^{2}+4\\cdot 16+11=3403$，$B=3\\cdot 8^{3}+1\\cdot 8^{2}+5\\cdot 8+7=1647$，所以 $R=3403-1647=1756$，并且确实有 $1756=(06DC)_{16}$。其绝对值小于 $2^{15}$，因此没有发生溢出，其二进制补码表示就是上述的16位二进制数。", "answer": "$$\\boxed{0000011011011100}$$", "id": "1914540"}]}