{"hands_on_practices": [{"introduction": "在信号处理中，一个常见操作是在分析前对信号进行预处理，例如通过零填充来提高频谱分辨率。本练习将探讨这一实用技术如何与按频率抽取（DIF）FFT算法的第一阶段相互作用。通过观察零填充如何简化蝶形运算，你将更深入地理解算法的初始分解步骤及其对输入数据的响应。[@problem_id:1711040]", "problem": "考虑一个长度为4的有限离散时间序列 $x[n]$，其定义域为 $n \\in \\{0, 1, 2, 3\\}$。通过对 $x[n]$ 进行补零，创建一个长度为8的新序列 $y[n]$，使得当 $n \\in \\{0, 1, 2, 3\\}$ 时，$y[n] = x[n]$，当 $n \\in \\{4, 5, 6, 7\\}$ 时，$y[n] = 0$。\n\n这个8点序列 $y[n]$ 是一个标准的基2按频率抽取（DIF）快速傅里叶变换（FFT）算法的输入。该算法的第一级计算出两个中间的4点序列，我们将其记为 $g[n]$ 和 $h[n]$，定义域为 $n \\in \\{0, 1, 2, 3\\}$。计算如下：\n\n$g[n] = y[n] + y[n+4]$\n$h[n] = (y[n] - y[n+4]) W_8^n$\n\n其中，$W_N^k = \\exp(-j2\\pi k/N)$ 是旋转因子。假设 $x[n]$ 不恒为零。\n\n下列哪个陈述正确地描述了因补零而导致的序列 $g[n]$ 和 $h[n]$ 之间的关系？\n\nA. 对所有 $n \\in \\{0, 1, 2, 3\\}$，$h[n] = g[n]$\n\nB. 对所有 $n \\in \\{0, 1, 2, 3\\}$，$h[n] = g[n]W_8^n$\n\nC. 对所有 $n \\in \\{0, 1, 2, 3\\}$，$h[n] = -g[n]$\n\nD. $g[0] = h[1]$ 且 $g[1] = h[0]$\n\nE. 对所有 $n \\in \\{0, 1, 2, 3\\}$，$h[n] = 0$", "solution": "根据构造，补零序列满足当 $n\\in\\{0,1,2,3\\}$ 时 $y[n]=x[n]$，当 $n\\in\\{4,5,6,7\\}$ 时 $y[n]=0$。在基2 DIF FFT的第一级中，对于 $n\\in\\{0,1,2,3\\}$，我们有\n$$\ng[n]=y[n]+y[n+4],\\qquad h[n]=(y[n]-y[n+4])\\,W_{8}^{n}.\n$$\n由于 $n\\in\\{0,1,2,3\\}$ 意味着 $n+4\\in\\{4,5,6,7\\}$，补零操作使得 $y[n+4]=0$。因此，\n$$\ng[n]=y[n]+0=y[n]=x[n],\n$$\n并且\n$$\nh[n]=(y[n]-0)\\,W_{8}^{n}=y[n]\\,W_{8}^{n}=x[n]\\,W_{8}^{n}.\n$$\n由此直接得出\n$$\nh[n]=g[n]\\,W_{8}^{n}\\quad\\text{for all }n\\in\\{0,1,2,3\\}.\n$$\n因此，正确选项是B，而其他选项一般不成立（A选项要求对所有 $n$ 都有 $W_{8}^{n}=1$，C选项要求对所有 $n$ 都有 $W_{8}^{n}=-1$，D选项与这些定义无关，而E选项要求对所有 $n$ 都有 $x[n]=0$，这被假设所排除）。", "answer": "$$\\boxed{B}$$", "id": "1711040"}, {"introduction": "深入理解算法的数据流对于调试和硬件实现至关重要。这个思想实验模拟了“旋转因子”中的一个微小计算错误，并要求你预测它对最终输出的连锁影响。这个过程将清晰地揭示DIF算法的核心“分而治之”策略，特别是它如何将偶数和奇数频率分量的计算路径分离开来。[@problem_id:1711088]", "problem": "一位工程师正在调试一个8点按频率抽取（DIF）的快速傅里叶变换（FFT）算法，该算法用于计算输入序列 $x[n]$（对于 $n = 0, 1, \\dots, 7$）的离散傅里叶变换（DFT）。DFT输出表示为 $X[k]$（对于 $k = 0, 1, \\dots, 7$）。该算法基于标准的DIF-FFT分解，在每个阶段，输入序列被分成前半部分和后半部分。旋转因子定义为 $W_N^k = \\exp(-j\\frac{2\\pi k}{N})$。\n\n经检查发现，算法的第一级中存在一个计算错误。具体来说，旋转因子 $W_8^2$ 被错误地编程为 $1$，而不是其真实值。这个错误仅发生在计算过程中的一个位置。假设输入序列 $x[n]$ 是一个普通的复值序列，并且满足 $x[2] \\neq x[6]$。由于这一个编程错误，下列哪组输出采样 $X[k]$ 会变得不正确？\n\nA. $X[2], X[6]$\n\nB. $X[0], X[2], X[4], X[6]$\n\nC. $X[2], X[3], X[6], X[7]$\n\nD. $X[1], X[3], X[5], X[7]$\n\nE. 所有输出采样 $X[k]$ 对于 $k=0, 1, \\dots, 7$", "solution": "令 $N=8$，DFT 定义为\n$$\nX[k]=\\sum_{n=0}^{7}x[n]W_{8}^{nk},\\quad W_{8}^{k}=\\exp\\!\\left(-j\\frac{2\\pi k}{8}\\right).\n$$\n对于DIF分解，将 $n$ 分为 $n=m$ 和 $n=m+4$ 两部分，其中 $m=0,1,2,3$：\n$$\nX[k]=\\sum_{m=0}^{3}\\left(x[m]+W_{8}^{4k}x[m+4]\\right)W_{8}^{mk}.\n$$\n由于 $W_{8}^{4k}=(-1)^{k}$，我们得到\n$$\nX[k]=\\sum_{m=0}^{3}\\left(x[m]+(-1)^{k}x[m+4]\\right)W_{8}^{mk}.\n$$\n对于偶数 $k=2r$，\n$$\nX[2r]=\\sum_{m=0}^{3}\\left(x[m]+x[m+4]\\right)W_{8}^{m\\cdot 2r}\n=\\sum_{m=0}^{3}a[m]\\,W_{4}^{mr},\n$$\n其中 $a[m]=x[m]+x[m+4]$。对于奇数 $k=2r+1$，\n$$\nX[2r+1]=\\sum_{m=0}^{3}\\left(x[m]-x[m+4]\\right)W_{8}^{m(2r+1)}\n=\\sum_{m=0}^{3}\\underbrace{\\left(x[m]-x[m+4]\\right)W_{8}^{m}}_{c[m]}W_{4}^{mr}.\n$$\n因此，DIF的第一级计算 $a[m]=x[m]+x[m+4]$（无旋转因子）和 $c[m]=(x[m]-x[m+4])W_{8}^{m}$（应用了旋转因子），最终的输出满足\n$$\nX[2r]=\\text{DFT}_{4}\\{a[m]\\}[r],\\quad X[2r+1]=\\text{DFT}_{4}\\{c[m]\\}[r],\\quad r=0,1,2,3.\n$$\n所述的错误是在第一级中，旋转因子 $W_{8}^{2}$ 在一个位置上被错误地设置为 $1$。这只影响 $c[2]$ 的计算，将正确的\n$$\nc[2]=(x[2]-x[6])W_{8}^{2}\n$$\n替换为不正确的\n$$\nc'[2]=(x[2]-x[6]).\n$$\n所有其他的 $a[m]$ 和 $c[m]$ 仍然是正确的。因此，只有依赖于 $c[m]$ 的奇数索引输出会受到影响。错误的奇数输出为（对于 $r=0,1,2,3$）：\n$$\nX'[2r+1]=\\sum_{m=0}^{3}c'[m]W_{4}^{mr}\n= \\sum_{m=0}^{3}c[m]W_{4}^{mr}+\\bigl(c'[2]-c[2]\\bigr)W_{4}^{2r}\n= X[2r+1]+\\bigl(1-W_{8}^{2}\\bigr)(x[2]-x[6])W_{4}^{2r}.\n$$\n对于一个4点DFT，$W_{4}^{2r}=(-1)^{r}$，它永远不为零。根据假设 $W_{8}^{2}\\neq 1$ 且 $x[2]\\neq x[6]$，因此对于每个 $r$，校正项都不为零，所以所有奇数索引的输出 $X[1],X[3],X[5],X[7]$ 都被破坏了。偶数索引的输出仅来自于 $a[m]$，不受影响。\n\n因此，不正确的输出是 $X[1],X[3],X[5],X[7]$，对应于选项D。", "answer": "$$\\boxed{D}$$", "id": "1711088"}, {"introduction": "我们为什么用FFT？它究竟“快”在哪里？本练习将从具体的计算细节转向对算法效率的宏观分析。通过建立并求解描述运算次数的递推关系，你将亲手推导出著名的 $N \\log_{2}(N)$ 复杂度，从而从根本上理解并量化FFT相对于直接计算DFT所带来的巨大计算优势。[@problem_id:1711047]", "problem": "一个工程师团队正在设计一款用于实时音频分析的专用数字信号处理（DSP）芯片。该芯片的核心是一个硬件加速器，用于计算输入信号的离散傅里叶变换（DFT）。为实现高性能，该加速器实现了快速傅里叶变换（FFT）算法，具体采用了一种递归的按频率抽取（DIF）方法。\n\n变换的规模，用 $N$ 表示，总是2的幂，即 $N = 2^k$，其中 $k$ 为某个整数且 $k \\ge 1$。递归的DIF算法按以下方式运行：\n1.  一个 $N$ 点的输入序列通过执行 $N/2$ 次复数加法和 $N/2$ 次复数减法来进行处理。这一阶段产生两个中间序列，每个序列的长度为 $N/2$。\n2.  该算法接着对这两个新的 $N/2$ 点序列分别递归地调用自身。\n3.  当变换规模减小到$2$点时，此递归终止。一次单独的$2$点变换（作为递归的基准情况）需要恰好一次复数加法和一次复数减法。\n\n为了估计算术逻辑单元的功耗和面积需求，该团队需要精确计算所执行的运算次数。你的任务是确定这种特定实现所需的复数加法和减法的总次数。\n\n推导计算一个 $N$ 点DIF-FFT所需的复数加法和减法总次数的闭式解析表达式，记为 $C_A(N)$。请用 $N$ 来表示你的答案。", "solution": "设 $C_{A}(N)$ 表示对一个 $N$ 点输入（其中 $N=2^{k}$ 且 $k \\geq 1$）执行递归按频率抽取FFT算法所需的复数加法和减法总次数。\n\n在规模为 $N$ 的顶层，该算法执行 $N/2$ 次复数加法和 $N/2$ 次复数减法，共计 $N$ 次运算，然后递归处理两个规模为 $N/2$ 的子问题。因此，对于 $N \\geq 4$，\n$$\nC_{A}(N) = N + 2\\,C_{A}\\!\\left(\\frac{N}{2}\\right).\n$$\n基准情况是2点变换，它恰好使用一次加法和一次减法，因此\n$$\nC_{A}(2) = 2.\n$$\n\n为了求解该递推关系，我们将其迭代展开。经过一次展开后，\n$$\nC_{A}(N) = N + 2\\left(\\frac{N}{2} + 2\\,C_{A}\\!\\left(\\frac{N}{4}\\right)\\right) = N + N + 4\\,C_{A}\\!\\left(\\frac{N}{4}\\right).\n$$\n经过 $j$ 次展开后，\n$$\nC_{A}(N) = j\\,N + 2^{j}\\,C_{A}\\!\\left(\\frac{N}{2^{j}}\\right).\n$$\n选择 $j$ 使得 $C_{A}$ 的参数达到基准情况，即 $\\frac{N}{2^{j}} = 2$。由于 $N=2^{k}$，这得到 $j = \\log_{2}(N) - 1$。代入后得到，\n$$\nC_{A}(N) = \\bigl(\\log_{2}(N) - 1\\bigr)N + 2^{\\log_{2}(N) - 1}\\,C_{A}(2).\n$$\n使用 $2^{\\log_{2}(N) - 1} = \\frac{N}{2}$ 和 $C_{A}(2)=2$，\n$$\nC_{A}(N) = \\bigl(\\log_{2}(N) - 1\\bigr)N + \\frac{N}{2}\\cdot 2 = \\bigl(\\log_{2}(N) - 1\\bigr)N + N = N \\log_{2}(N).\n$$\n\n因此，所需的复数加法和减法总次数为 $C_{A}(N) = N \\log_{2}(N)$，这也满足基准情况，因为 $C_{A}(2) = 2 \\log_{2}(2) = 2$。", "answer": "$$\\boxed{N \\log_{2}(N)}$$", "id": "1711047"}]}