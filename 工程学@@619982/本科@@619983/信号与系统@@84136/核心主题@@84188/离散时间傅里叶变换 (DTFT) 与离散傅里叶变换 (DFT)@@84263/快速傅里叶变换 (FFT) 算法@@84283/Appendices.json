{"hands_on_practices": [{"introduction": "快速傅里叶变换（FFT）的惊人效率源于其巧妙的“分而治之”策略。在许多经典的FFT算法中，例如按时间抽取（DIT）FFT，一个关键的初始步骤是在进行核心计算之前对输入数据进行重新排序。这个练习将带你实践这个被称为“位倒序”的过程，这对于理解FFT的底层实现至关重要。[@problem_id:1717784]", "problem": "一位嵌入式系统工程师的任务是在内存有限的微控制器上实现一个实时音频频谱分析仪。为此，该工程师决定使用基2时间抽取（DIT）快速傅里叶变换（FFT）算法。该算法的第一个关键步骤是在主蝶形运算开始前，对输入的时域采样进行重排序。这个重排序是通过将原始序列中索引为 $n$ 的采样 $x[n]$ 放置到打乱后序列的新位置（索引为 $k$）来完成的。新的索引 $k$ 是通过反转原始索引 $n$ 的二进制表示来找到的。\n\n考虑一个离散时间信号，经过采样后产生了一个 $N=8$ 点的序列，记为 $x[n]$，$n=0, 1, 2, ..., 7$。根据DIT-FFT的位反转流程，采样 $x[6]$ 将被移动到重排序后输入缓冲区中的一个新索引位置。这个新索引的数值是多少？", "solution": "在序列长度为 $N=2^{m}$ 的基2 DIT-FFT中，位反转重排序通过反转 $n$ 的 $m$ 位二进制表示，将索引 $n$ 映射到 $k$。形式上，如果 $n=\\sum_{i=0}^{m-1} b_{i} 2^{i}$，其中 $b_{i}\\in\\{0,1\\}$，那么位反转后的索引是\n$$\nk=\\sum_{i=0}^{m-1} b_{i} 2^{m-1-i}.\n$$\n对于 $N=8$，我们有 $m=\\log_{2}(8)=3$。索引 $n=6$ 的3位二进制表示为\n$$\n6=1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}\\;\\Rightarrow\\;(110)_{2},\n$$\n所以 $b_{2}=1$，$b_{1}=1$，$b_{0}=0$。反转这三位得到 $(011)_{2}$，其十进制值为\n$$\nk=0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=3.\n$$\n因此，在 $N=8$ 的DIT-FFT位反转重排序下，采样 $x[6]$ 被移动到索引 $k=3$ 的位置。", "answer": "$$\\boxed{3}$$", "id": "1717784"}, {"introduction": "从算法的内部机制转向其实际应用，我们会发现理论与现实之间的一个重要差异：我们总是只能分析有限时间长度的信号。本练习将探讨这一限制所带来的一个关键现象——频谱泄漏，即纯音的能量会“泄漏”到相邻的频率仓中。通过计算，你将学会量化这种效应，并更深入地理解FFT分析结果的真正含义。[@problem_id:1717762]", "problem": "一位工程师正在分析来自大型工业电机的振动信号。在此分析中，该信号被建模为一个纯正弦波 $x(t) = \\cos(2\\pi f_c t)$，其中幅度和相位的影响被忽略，因为它们不影响最终所需的比率。该信号由一个模数转换器 (ADC) 以 $f_s = 8000 \\text{ Hz}$ 的采样率进行采样。总共采集了 $N = 1024$ 个样本，然后使用快速傅里叶变换 (FFT) 算法进行处理，该算法计算离散傅里叶变换 (DFT)。\n\n电机的真实旋转频率产生的振动信号频率为 $f_c = 150.0 \\text{ Hz}$。由于有限的采样持续时间，该频率并不精确地与 1024 点 FFT 的任何一个频率仓重合。结果，信号的能量表现为分散在多个频率仓中，这种现象被称为频谱泄漏。\n\n设 $X[k]$ 是 FFT 的第 $k$ 个频率仓的复值系数，其中 $k$ 是从 $0$ 到 $N-1$ 的整数。计算真实频率之上的相邻频率仓中 FFT 系数的幅值与真实频率之下的相邻频率仓中 FFT 系数的幅值之比。具体来说，确定比值 $|X[k_{above}]| / |X[k_{below}]|$ 的值，其中 $k_{below}$ 和 $k_{above}$ 分别是紧邻真实信号频率 $f_c$ 下方和上方的整数频率仓索引。\n\n将您的答案表示为一个保留三位有效数字的实数。", "solution": "我们对连续时间正弦波 $x(t)=\\cos(2\\pi f_{c}t)$ 进行采样，得到离散时间序列 $x[n]=\\cos\\!\\left(2\\pi \\frac{f_{c}}{f_{s}}n\\right)$，其中 $n=0,\\ldots,N-1$。$N$ 点 DFT 定义为\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\!\\left(-j\\frac{2\\pi kn}{N}\\right).\n$$\n使用 $x[n]=\\frac{1}{2}\\left(\\exp\\!\\left(j2\\pi \\frac{f_{c}}{f_{s}}n\\right)+\\exp\\!\\left(-j2\\pi \\frac{f_{c}}{f_{s}}n\\right)\\right)$ 和线性性质，\n$$\nX[k]=\\frac{1}{2}X_{+}[k]+\\frac{1}{2}X_{-}[k],\n$$\n其中\n$$\nX_{+}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(j2\\pi n\\left(\\frac{f_{c}}{f_{s}}-\\frac{k}{N}\\right)\\right),\\qquad\nX_{-}[k]=\\sum_{n=0}^{N-1}\\exp\\!\\left(-j2\\pi n\\left(\\frac{f_{c}}{f_{s}}+\\frac{k}{N}\\right)\\right).\n$$\n每一项都是一个有限几何级数。令 $\\Delta=\\frac{f_{c}}{f_{s}}-\\frac{k}{N}$。则\n$$\nX_{+}[k]=\\exp\\!\\left(j\\pi (N-1)\\Delta\\right)\\frac{\\sin(\\pi N\\Delta)}{\\sin(\\pi \\Delta)},\n$$\n所以\n$$\n|X_{+}[k]|=\\frac{|\\sin(\\pi N\\Delta)|}{|\\sin(\\pi \\Delta)|}.\n$$\n将音调的频率仓位置定义为 $r=\\frac{Nf_{c}}{f_{s}}$，小数偏移量为 $\\alpha=r-\\lfloor r\\rfloor\\in(0,1)$。$f_{c}$ 周围的相邻频率仓是 $k_{below}=\\lfloor r\\rfloor$ 和 $k_{above}=\\lfloor r\\rfloor+1$。那么\n$$\n\\Delta_{below}=\\frac{f_{c}}{f_{s}}-\\frac{k_{below}}{N}=\\frac{r}{N}-\\frac{\\lfloor r\\rfloor}{N}=\\frac{\\alpha}{N},\\qquad\n\\Delta_{above}=\\frac{f_{c}}{f_{s}}-\\frac{k_{above}}{N}=\\frac{\\alpha-1}{N}=-\\frac{1-\\alpha}{N}.\n$$\n因此，对于接近 $+f_{c}$ 的复指数分量，\n$$\n|X_{+}[k_{below}]|=\\frac{|\\sin(\\pi \\alpha)|}{|\\sin(\\pi \\alpha/N)|},\\qquad\n|X_{+}[k_{above}]|=\\frac{|\\sin(\\pi (1-\\alpha))|}{|\\sin(\\pi (1-\\alpha)/N)|}.\n$$\n使用 $|\\sin(\\pi \\alpha)|=|\\sin(\\pi (1-\\alpha))|$，由主瓣决定的比值为\n$$\nR\\equiv\\frac{|X[k_{above}]|}{|X[k_{below}]|}\\approx\\frac{|X_{+}[k_{above}]|}{|X_{+}[k_{below}]|}=\\frac{\\sin(\\pi \\alpha/N)}{\\sin(\\pi (1-\\alpha)/N)}.\n$$\n现在代入给定参数来求 $\\alpha$。给定 $f_{s}=8000$，$N=1024$ 和 $f_{c}=150$，\n$$\nr=\\frac{Nf_{c}}{f_{s}}=\\frac{1024\\cdot 150}{8000}=19.2,\\qquad \\alpha=0.2.\n$$\n因此\n$$\nR=\\frac{\\sin\\!\\left(\\pi\\cdot \\frac{0.2}{1024}\\right)}{\\sin\\!\\left(\\pi\\cdot \\frac{0.8}{1024}\\right)}.\n$$\n因为自变量很小，使用 $\\sin(x)\\approx x$ 可得\n$$\nR\\approx\\frac{\\pi\\cdot 0.2/1024}{\\pi\\cdot 0.8/1024}=\\frac{0.2}{0.8}=\\frac{1}{4}=0.25.\n$$\n保留三位有效数字，该比率为 $0.250$。", "answer": "$$\\boxed{0.250}$$", "id": "1717762"}, {"introduction": "为了巩固所学知识并建立对计算工具的深刻信任，最好的方法莫过于亲手实现。本练习将引导你从第一性原理出发，通过构建一个基于其线性代数定义的“慢速”离散傅里叶变换（DFT）来验证一个标准库的FFT函数。这个过程不仅能加深你对DFT核心属性（如帕萨瓦尔定理和厄米对称性）的理解，还能让你对所使用的工具充满信心。[@problem_id:2391694]", "problem": "您需要实现并使用一个基于线性代数定义的参考离散傅里叶变换，以验证一个现成的快速傅里叶变换 (FFT) 实现对小规模问题的正确性。请从以下基础概念出发：\n\n- 复指数 $e^{\\mathrm{i} 2 \\pi k n / N}$ 在离散网格 $n \\in \\{0,1,\\dots,N-1\\}$ 上，对于离散内积，构成一个正交基，并且它们在 $n$ 和 $k$ 上是 $N$ 周期的。\n- 离散傅里叶变换是时域中的标准基与频域中的复指数基之间的线性基变换。\n- 离散时间信号被建模为长度为 $N$ 的复数值有限序列，角度以弧度为单位。\n\n任务：\n\n1) 实现一个函数，该函数通过一个显式构造的 $N \\times N$ 复数矩阵，以纯矩阵向量乘法的形式计算离散傅里叶变换。这必须是直接的、二次时间复杂度的方法，不含任何分治优化。将输入向量表示为 $x \\in \\mathbb{C}^N$，输出表示为 $X \\in \\mathbb{C}^N$。选择与标准库 FFT 的默认归一化一致的正变换约定：正变换没有缩放因子，而逆变换有因子 $1/N$。\n\n2) 以与所选正变换约定一致的方式，通过使用正变换矩阵的逆矩阵，实现相应的逆变换，形式同样为纯矩阵向量乘法。\n\n3) 使用您基于矩阵的变换，通过检查下面列出的每个测试用例的以下属性，验证一个现成的 FFT 实现的正确性（使用您语言中可用的标准库 FFT；在 Python 中，这是 numpy.fft.fft 的默认行为）：\n- 正变换一致性：您的直接变换结果 $X$ 在数值容差范围内与现成的 FFT 结果相匹配。\n- 逆变换一致性：将您的直接逆变换应用于现成的 FFT 结果，能在相同容差范围内重建原始信号。\n- 能量守恒（针对所采用归一化方式的帕塞瓦尔关系）：$\\sum_{n=0}^{N-1} |x_n|^2$ 与 $\\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$ 在容差范围内相等。\n- 实数输入的厄米共轭对称性：如果 $x$ 是实数值，那么对于所有 $k$， $X_k = \\overline{X_{(-k) \\bmod N}}$ 在容差范围内成立。\n\n数值细节：\n\n- 使用绝对容差 $10^{-10}$ 和相对容差 $10^{-10}$。\n- 角度以弧度为单位。\n\n测试套件：\n\n对于每个用例，令 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n- 用例 A（理想情况，复数标量）：$N = 1$, $x_0 = 3 - 2\\,\\mathrm{i}$。\n- 用例 B（边界大小，实数交替）：$N = 2$, $x_0 = 1$, $x_1 = -1$。\n- 用例 C（素数长度，复数混合）：$N = 3$, $x_0 = 1 + 2\\,\\mathrm{i}$, $x_1 = -3 + 0.5\\,\\mathrm{i}$, $x_2 = -\\mathrm{i}$。\n- 用例 D（2的幂长度，单频余弦）：$N = 4$, $x_n = \\cos\\!\\left(2 \\pi \\cdot 1 \\cdot n / 4\\right)$。\n- 用例 E（稀疏脉冲）：$N = 5$, 当 $n = 2$ 时 $x_n = 2$，否则 $x_n = 0$。\n- 用例 F（复 chirp 信号）：$N = 8$, $x_n = \\exp\\!\\left(\\mathrm{i} \\pi\\, n (n-1) / 8\\right)$。\n- 用例 G（随机复数，可复现）：$N = 16$, $x_n = a_n + \\mathrm{i}\\, b_n$，其中 $\\{a_n\\}$ 和 $\\{b_n\\}$ 是由固定种子 $12345$ 生成的独立标准正态分布随机数。\n\n对于每个用例，生成一个布尔值，指示是否所有适用的检查都通过。容差比较必须使用指定的绝对和相对容差。\n\n最终输出格式：\n\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，布尔字面值写作 $\\text{True}$ 或 $\\text{False}$，顺序为用例 A到 G。例如：\"[True,False,True]\"。", "solution": "对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- **原理**：离散傅里叶变换（DFT）是一种从标准基到复指数 $e^{\\mathrm{i} 2 \\pi k n / N}$（于网格 $n \\in \\{0, 1, \\dots, N-1\\}$ 上正交）基的线性变换。\n- **任务1**：通过显式构造 $N \\times N$ DFT 矩阵 $W$，实现一个正向 DFT，$X = Wx$。这是一个直接的、$O(N^2)$ 算法。\n- **任务2**：通过构造逆矩阵 $W_{\\text{inv}}$，实现相应的逆 DFT，$x = W_{\\text{inv}}X$。\n- **归一化约定**：正变换不进行缩放。逆变换按因子 $1/N$进行缩放。\n- **任务3**：通过为一系列测试用例检查四个属性，验证一个现成的快速傅里叶变换（FFT）实现的正确性：\n    1.  **正变换一致性**：直接 DFT 的结果必须与现成的 FFT 结果相匹配。\n    2.  **逆变换一致性**：将直接 IDFT 应用于现成的 FFT 结果，必须能重建原始信号。\n    3.  **能量守恒（帕塞瓦尔关系）**：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n    4.  **厄米共轭对称性**：对于实数值输入 $x$，其变换必须满足 $X_k = \\overline{X_{(-k) \\bmod N}}$。\n- **数值容差**：绝对容差 $10^{-10}$，相对容差 $10^{-10}$。\n- **测试用例**：\n    - **A**：$N=1$, $x_0 = 3 - 2\\,\\mathrm{i}$。\n    - **B**：$N=2$, $x = [1, -1]$。\n    - **C**：$N=3$, $x = [1 + 2\\,\\mathrm{i}, -3 + 0.5\\,\\mathrm{i}, -\\mathrm{i}]$。\n    - **D**：$N=4$, $x_n = \\cos(2 \\pi n / 4)$。\n    - **E**：$N=5$, $x = [0, 0, 2, 0, 0]$。\n    - **F**：$N=8$, $x_n = \\exp(\\mathrm{i} \\pi n(n-1) / 8)$。\n    - **G**：$N=16$, $x_n = a_n + \\mathrm{i}\\,b_n$ 来自种子为 $12345$ 的标准正态分布随机数。\n- **最终输出**：每个测试用例对应一个布尔结果，指示是否所有适用的检查都通过。\n\n**第二步：验证**\n对问题的科学有效性、适定性和客观性进行评估。\n- **科学依据**：该问题在根本上是可靠的。它基于离散傅里叶变换的标准数学定义、其矩阵表示及其核心属性（如帕塞瓦尔定理和厄米共轭对称性）。指定的归一化是一种常见的约定。\n- **适定性**：问题清晰明确且自洽。它提供了所有必要的数据（信号、大小 $N$）、要实现的算法、要验证的属性以及严格的数值容差。预期会有一个唯一的、可验证的结果（一个布尔值列表）。\n- **客观性**：语言精确，没有主观论断。任务纯粹是计算性的和可验证的。\n\n**第三步：结论**\n问题被判定为**有效**。这是一个定义明确的数值验证练习，植根于傅里叶分析的基本原理。我现在将提供解决方案。\n\n---\n\n该解决方案需要实现离散傅里叶变换（DFT）及其逆变换，作为直接的矩阵-向量乘法，以用作验证快速傅里叶变换（FFT）实现的参考。\n\n**1. 正向离散傅里叶变换 (DFT)**\nDFT 将一个长度为 $N$ 的离散信号向量 $x \\in \\mathbb{C}^N$ 映射到其频域表示 $X \\in \\mathbb{C}^N$。对于每个频率分量 $k \\in \\{0, 1, \\dots, N-1\\}$，其值 $X_k$是通过将信号 $x$ 投影到对应于频率 $k$ 的复指数基向量上计算出来的。遵循标准定义，即：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\n这组 $N$ 个线性方程可以表示为矩阵形式 $X = Wx$，其中 $W$ 是 $N \\times N$ 的 DFT 矩阵。该矩阵的元素，由行 $k$ 和列 $n$ 索引，由下式给出：\n$$\nW_{kn} = e^{-\\mathrm{i} 2 \\pi k n / N}\n$$\n实现将明确构造此矩阵并执行矩阵-向量乘法，其计算复杂度为 $O(N^2)$。这与 FFT 算法形成对比，后者以 $O(N \\log N)$ 的时间计算相同的变换。\n\n**2. 逆离散傅里叶变换 (IDFT)**\n逆变换从频谱 $X$ 重建原始信号 $x$。根据指定的归一化约定（正变换无缩放），逆变换必须包含一个 $1/N$ 的缩放因子，以确保正变换和逆变换的复合操作产生单位操作。公式为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k e^{\\mathrm{i} 2 \\pi k n / N}\n$$\n在矩阵形式中，这是 $x = W_{\\text{inv}}X$。逆矩阵 $W_{\\text{inv}}$ 的元素是：\n$$\n(W_{\\text{inv}})_{nk} = \\frac{1}{N} e^{\\mathrm{i} 2 \\pi n k / N}\n$$\nDFT 矩阵的一个基本性质是 $W^{-1} = \\frac{1}{N}W^*$，其中 $W^*$ 是 $W$ 的共轭转置。这源于 $W$ 的列的正交性。我们的实现将构造逆变换的矩阵并应用它。\n\n**3. 验证过程**\n一个现成 FFT 例程的正确性是通过我们的直接矩阵实现来验证的，方法是为每个测试用例执行四个检查。所有数值比较都使用 $r_{tol} = 10^{-10}$ 的相对容差和 $a_{tol} = 10^{-10}$ 的绝对容差。\n\n- **正变换一致性：** 我们计算 $X_{\\text{direct}} = Wx$ 并从标准库函数获得 $X_{\\text{FFT}}$。然后我们验证 $X_{\\text{direct}}$ 和 $X_{\\text{FFT}}$ 在指定容差范围内是逐元素相等的。\n\n- **逆变换一致性：** 我们验证将我们的直接逆变换应用于现成 FFT 的结果 $X_{\\text{FFT}}$ 时，是否能恢复原始信号 $x$。我们计算 $x_{\\text{rec}} = W_{\\text{inv}} X_{\\text{FFT}}$ 并检查 $x$ 和 $x_{\\text{rec}}$ 在容差范围内是否逐元素相等。\n\n- **能量守恒（帕塞瓦尔关系）：** 对于指定的归一化，信号元素的模平方和与其变换系数的模平方和通过以下恒等式相关联：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n我们计算此方程的左侧和右侧，并验证它们在给定容差范围内相等。\n\n- **厄米共轭对称性：** 此属性仅适用于纯实数值的信号 $x$ （即所有 $n$ 的 $x_n \\in \\mathbb{R}$）。对于此类信号，DFT 谱表现出共轭对称性：\n$$\nX_k = \\overline{X_{(-k) \\pmod{N}}}\n$$\n这对所有 $k \\in \\{0, 1, \\dots, N-1\\}$ 进行检查。这意味着 $X_0$ 是实数，如果 $N$ 是偶数，$X_{N/2}$ 也是实数。此检查仅对具有实数值输入的测试用例执行。\n\n对于每个测试用例，最终结果是一个布尔值，当且仅当所有适用的检查都通过时，该值为真。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the DFT verification process.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    # Each dictionary specifies the signal size N and a function to generate the signal x.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 1,\n            \"x_func\": lambda N: np.array([3.0 - 2.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 2,\n            \"x_func\": lambda N: np.array([1.0, -1.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 3,\n            \"x_func\": lambda N: np.array([1.0 + 2.0j, -3.0 + 0.5j, -1.0j]),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"D\",\n            \"N\": 4,\n            \"x_func\": lambda N: np.cos(2 * np.pi * 1 * np.arange(N) / N),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"E\",\n            \"N\": 5,\n            \"x_func\": lambda N: np.array([0.0, 0.0, 2.0, 0.0, 0.0]),\n            \"is_real\": True,\n        },\n        {\n            \"id\": \"F\",\n            \"N\": 8,\n            \"x_func\": lambda N: np.exp(1j * np.pi * np.arange(N) * (np.arange(N) - 1) / N),\n            \"is_real\": False,\n        },\n        {\n            \"id\": \"G\",\n            \"N\": 16,\n            \"x_func\": lambda N: (\n                (rng := np.random.default_rng(12345)).standard_normal(N) +\n                1j * rng.standard_normal(N)\n            ),\n            \"is_real\": False,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        x = case[\"x_func\"](N)\n        is_real_input = case[\"is_real\"]\n        \n        # Run all verification checks for the current case.\n        passed = run_verification(x, N, is_real_input)\n        results.append(passed)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_verification(x, N, is_real_input):\n    \"\"\"\n    Performs all DFT verification checks for a given signal x of size N.\n    \"\"\"\n    rtol = 1e-10\n    atol = 1e-10\n    \n    checks_passed = []\n\n    # --- 1. Forward Agreement Check ---\n    # Construct the direct DFT matrix W\n    k = np.arange(N).reshape((N, 1))\n    n = np.arange(N)\n    W = np.exp(-2j * np.pi * k * n / N)\n\n    # Compute direct DFT and canned FFT\n    X_direct = W @ x\n    X_fft = np.fft.fft(x)\n    \n    forward_agreement = np.allclose(X_direct, X_fft, rtol=rtol, atol=atol)\n    checks_passed.append(forward_agreement)\n\n    # --- 2. Inverse Agreement Check ---\n    # Construct the direct IDFT matrix W_inv\n    # The unscaled matrix is the conjugate transpose of W, or simply change the sign of the exponent.\n    W_inv_unscaled = np.exp(2j * np.pi * k * n / N)\n    W_inv = (1 / N) * W_inv_unscaled\n    \n    # Reconstruct the signal from the canned FFT result\n    x_reconstructed = W_inv @ X_fft\n    \n    inverse_agreement = np.allclose(x, x_reconstructed, rtol=rtol, atol=atol)\n    checks_passed.append(inverse_agreement)\n\n    # --- 3. Energy Conservation (Parseval's Relation) Check ---\n    energy_x = np.sum(np.abs(x)**2)\n    energy_X = (1 / N) * np.sum(np.abs(X_direct)**2)\n\n    parseval_check = np.isclose(energy_x, energy_X, rtol=rtol, atol=atol)\n    checks_passed.append(parseval_check)\n\n    # --- 4. Hermitian Symmetry Check (for real inputs only) ---\n    if is_real_input:\n        # Check that the input signal is indeed real, as a sanity check.\n        assert np.all(np.abs(x.imag) < atol)\n        \n        # Check X_k = conj(X_{(-k) mod N})\n        indices = np.arange(N)\n        neg_indices_mod_N = (-indices) % N\n        X_conj_symmetric = np.conj(X_direct[neg_indices_mod_N])\n        \n        hermitian_check = np.allclose(X_direct, X_conj_symmetric, rtol=rtol, atol=atol)\n        checks_passed.append(hermitian_check)\n\n    # Return True only if all executed checks passed.\n    return all(checks_passed)\n\nsolve()\n```", "id": "2391694"}]}