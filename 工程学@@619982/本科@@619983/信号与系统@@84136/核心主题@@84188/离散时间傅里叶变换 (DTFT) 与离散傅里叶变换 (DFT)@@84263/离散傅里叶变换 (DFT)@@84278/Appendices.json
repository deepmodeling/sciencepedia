{"hands_on_practices": [{"introduction": "要真正掌握离散傅里叶变换（DFT），最好的方法莫过于将其应用于其最基本的构成单元：一个纯粹的单一频率。这个练习将带你计算一个复指数信号的 $N$ 点 DFT。通过这个过程，你将亲眼见证 DFT 如何像一个“频率探测器”一样工作，精确地在信号自身的频率点上产生一个尖锐的峰值，这是所有频谱分析的基础。[@problem_id:1759639]", "problem": "在数字信号处理中，离散傅里叶变换 (DFT) 是分析有限长度信号频谱成分的基本工具。考虑一个纯音信号采样后的简化模型。该信号记为 $x[n]$，由单个复指数表示。\n\n该信号是一个长度为 $N$ 的序列，定义为：\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\n对于时间索引 $n = 0, 1, \\ldots, N-1$。此处，$k_0$ 是一个整数常数，代表该纯音的归一化频率，并且满足 $0 \\le k_0 < N$。\n\n你的任务是计算该信号的 $N$ 点 DFT。DFT 记为 $X[k]$，由以下分析方程定义：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\n其中 $k$ 是频率索引，取整数值 $k = 0, 1, \\ldots, N-1$。\n\n求一个用 $N$、$k$ 和 $k_0$ 表示 $X[k]$ 的单个闭式解析表达式。", "solution": "我们从 DFT 分析方程开始，并代入给定的信号。根据定义，\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\n将 $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$ 代入，上式变为\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\n定义\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\n则\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\n这是一个有限几何级数。使用几何级数求和公式，\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r}, & r \\neq 1, \\\\\nN, & r = 1,\n\\end{cases}\n$$\n并注意到\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\n我们有：\n- 如果 $r \\neq 1$ （对于 $k,k_{0}\\in\\{0,\\ldots,N-1\\}$，等价于 $k \\neq k_{0}$），则 $1 - r^{N} = 0$ 而 $1 - r \\neq 0$，所以 $X[k] = 0$。\n- 如果 $r = 1$ （等价于 $k = k_{0}$），则和式中的每一项都等于 $1$，所以 $X[k] = N$。\n\n综合这两种情况，得到闭式表达式\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\n其中 $\\delta_{k,k_{0}}$ 是克罗内克 δ 函数，当 $k=k_{0}$ 时等于 $1$，否则等于 $0$。", "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$", "id": "1759639"}, {"introduction": "在我们了解了 DFT 如何分离频率分量之后，一个自然而然的进阶步骤就是学习如何操纵这些分量。本实践将探讨一个常见的应用：数字滤波。通过在频域中将某些 DFT 系数置零（一种理想低通滤波器），我们可以去除不想要的频率，但这个在频域看似简单的操作会在时域产生不那么直观的后果，本题将帮助你计算并理解这些影响。[@problem_id:1759601]", "problem": "考虑一个长度为 $N=16$ 的离散时间信号 $x[n]$。该信号定义为一个矩形脉冲：当 $0 \\le n \\le 4$ 时，$x[n]=1$；当 $5 \\le n \\le 15$ 时，$x[n]=0$。该信号在频域中通过一个理想低通滤波器进行处理。信号的 N 点离散傅里叶变换（DFT），记为 $X[k]$，与滤波器频率响应 $H[k]$ 相乘，得到输出频谱 $Y[k] = X[k]H[k]$。滤波器的定义为：当 $k \\in \\{0, 1, 2, 14, 15\\}$ 时，$H[k]=1$；对于 $0 \\le k \\le 15$ 范围内的所有其他 $k$ 值，$H[k]=0$。时域中的输出信号 $y[n]$ 是通过对 $Y[k]$ 进行 N 点离散傅里叶逆变换（IDFT）得到的。计算输出信号样本 $y[7]$ 的值。将最终答案四舍五入到四位有效数字。", "solution": "设 $N=16$，定义 $N$ 点 DFT 和 IDFT 如下\n$$\nX[k]=\\sum_{n=0}^{15} x[n]\\exp(-\\mathrm{j}2\\pi kn/16),\\quad\ny[n]=\\frac{1}{16}\\sum_{k=0}^{15} Y[k]\\exp(\\mathrm{j}2\\pi kn/16),\n$$\n其中 $Y[k]=X[k]H[k]$。由于当 $0\\leq n\\leq 4$ 时 $x[n]=1$，其余情况 $x[n]=0$，我们有对于 $k\\in\\{0,1,\\dots,15\\}$，\n$$\nX[k]=\\sum_{n=0}^{4}\\exp(-\\mathrm{j}2\\pi kn/16).\n$$\n对于 $k=0$，$X[0]=5$。对于 $k\\neq 0$，使用 $M=5$ 和 $\\theta=2\\pi k/16$ 的 Dirichlet 形式的几何级数求和公式，\n$$\nX[k]=\\exp\\!\\big(-\\mathrm{j}\\theta(M-1)/2\\big)\\,\\frac{\\sin(M\\theta/2)}{\\sin(\\theta/2)}\n=\\exp\\!\\big(-\\mathrm{j}\\theta\\cdot 2\\big)\\,\\frac{\\sin(5\\theta/2)}{\\sin(\\theta/2)}.\n$$\n滤波器只保留 $k\\in\\{0,1,2,14,15\\}$ 的分量，所以\n$$\ny[n]=\\frac{1}{16}\\Big(X[0]+X[1]\\exp(\\mathrm{j}\\omega n)+X[2]\\exp(\\mathrm{j}2\\omega n)+X[14]\\exp(\\mathrm{j}14\\omega n)+X[15]\\exp(\\mathrm{j}15\\omega n)\\Big),\n$$\n其中 $\\omega=2\\pi/16$。利用 $X[16-k]=X[k]^{*}$ 以及 $\\exp(\\mathrm{j}14\\omega n)=\\exp(-\\mathrm{j}2\\omega n)$，$\\exp(\\mathrm{j}15\\omega n)=\\exp(-\\mathrm{j}\\omega n)$，上式变为\n$$\ny[n]=\\frac{1}{16}\\Big(X[0]+2\\Re\\{X[1]\\exp(\\mathrm{j}\\omega n)\\}+2\\Re\\{X[2]\\exp(\\mathrm{j}2\\omega n)\\}\\Big).\n$$\n我们现在特化到 $n=7$。显式计算 $X[1]$ 和 $X[2]$：\n- 对于 $k=1$，$\\theta=\\pi/8$，所以\n$$\nX[1]=\\exp(-\\mathrm{j}\\pi/4)\\,\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}.\n$$\n因此\n$$\n\\Re\\{X[1]\\exp(\\mathrm{j}\\omega\\cdot 7)\\}=\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(7\\frac{\\pi}{8}-\\frac{\\pi}{4}\\Big)=\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big).\n$$\n- 对于 $k=2$，$\\theta=\\pi/4$，所以\n$$\nX[2]=\\exp(-\\mathrm{j}\\pi/2)\\,\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}.\n$$\n因此\n$$\n\\Re\\{X[2]\\exp(\\mathrm{j}2\\omega\\cdot 7)\\}=\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(7\\frac{\\pi}{4}-\\frac{\\pi}{2}\\Big)=\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big).\n$$\n所以\n$$\ny[7]=\\frac{1}{16}\\left(5+2\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)+2\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)\\right).\n$$\n在可用之处使用精确的三角函数值：\n$$\n\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)=-\\cos\\!\\Big(\\frac{3\\pi}{8}\\Big),\\quad \\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)=-\\frac{\\sqrt{2}}{2},\\quad \\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}=\\frac{\\sin(3\\pi/8)}{\\sin(\\pi/8)}=1+\\sqrt{2}.\n$$\n数值上，\n$$\n\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\approx 4.2619726274,\\quad \\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)\\approx -0.3826834324,\\quad 1+\\sqrt{2}\\approx 2.4142135624,\n$$\n所以\n$$\n2\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)\\approx -3.2619726274,\\quad\n2\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)=-(\\sqrt{2}+2)\\approx -3.4142135624.\n$$\n因此\n$$\ny[7]\\approx \\frac{1}{16}\\Big(5-3.2619726274-3.4142135624\\Big)\\approx -0.1047616369,\n$$\n四舍五入到四位有效数字为 $-0.1048$。", "answer": "$$\\boxed{-0.1048}$$", "id": "1759601"}, {"introduction": "DFT 的理论威力只有通过高效计算才能完全释放。这项高阶实践将挑战你从零开始实现快速傅里叶变换（FFT）算法——正是这个革命性的方法使得 DFT 在处理真实世界信号时变得切实可行。通过亲手构建算法，并用它来验证卷积定理和帕斯瓦尔（Parseval）恒等式等核心原理，你将对数字信号处理的核心工作方式获得深刻且实用的理解。[@problem_id:2387187]", "problem": "设 $N$ 是一个形如 $N = 2^m$ 的正整数，其中 $m$ 是一个非负整数。对于一个长度为 $N$ 的复数值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{，其中 } k = 0,1,\\dots,N-1,\n$$\n其逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{，其中 } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换程序的情况下，计算长度为 $N = 2^m$ 的序列的DFT和IDFT。你的程序还必须仅使用这些定义，通过明确的测试用例来验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，其长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的DFT。\n- 帕塞瓦尔恒等式 (Parseval identity) (使用上述归一化)：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n你的程序必须为 $N = 2^m$ 实现自己的快速算法来计算DFT和IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度必须以弧度为单位进行解释。\n\n使用以下测试套件，并按下述顺序生成输出：\n\n- 测试 $1$ (DFT与直接DFT的正确性比较，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用你的快速实现计算 $X$，并使用直接DFT计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 $2$ (逆变换恢复)：使用与测试 $1$ 中相同的 $N$ 和 $x$，通过将你的快速实现得到的 $X$ 应用于你的IDFT来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 $3$ (通过频域进行循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$ 且 $b = [0,1,0,0,0,0,0,0]$。直接根据其定义计算长度为 $N$ 的循环卷积 $c$。另外，通过计算 $a$ 和 $b$ 的DFT，进行逐点相乘，然后应用IDFT来计算 $\\hat{c}$。输出标量 $\\max_n |c_n - \\hat{c}_n|$ 作为浮点数。\n- 测试 $4$ (帕塞瓦尔恒等式)：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，其中 $n = 0,1,\\dots,15$。通过你的快速实现计算 $X$。输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ 作为浮点数。\n- 测试 $5$ (边缘情况 $N=1$)：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$，然后通过IDFT计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 $6$ (最小非平凡尺寸 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。通过你的快速实现计算 $X$。在给定约定下，精确的DFT是 $[0,2]$。输出标量 $\\max_k |X_k - [0,2]_k|$ 作为浮点数。\n\n最终输出格式：你的程序应生成单行输出，其中包含按顺序排列的六个结果，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实数值条目必须以标准十进制或科学记数法打印。不应打印任何其他文本。", "solution": "所提出的问题是计算物理领域（特别是在信号处理方面）一个定义明确且科学严谨的练习。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整的、客观的，并且其解决方案是可验证的。下面我们开始进行解答。\n\n问题的核心是为一个给定的长度为 $N$ 的离散复数值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n直接实现此公式涉及两个嵌套循环，一个用于从 $0$ 到 $N-1$ 的每个索引 $k$，另一个用于从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为 $\\mathcal{O}(N^2)$，对于大的 $N$ 来说效率低下。为了验证的目的，我们将实现这样一个直接方法。\n\n问题指定 $N$ 是2的幂，即 $N = 2^m$，其中 $m$ 是非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。长度为 $N$ 的DFT被递归地分解为两个长度为 $(N/2)$ 的DFT。\n\n将序列 $x_n$ 分解为其偶数索引元素，形成序列 $x'_m = x_{2m}$，以及其奇数索引元素，形成序列 $x''_m = x_{2m+1}$，每个序列的长度均为 $N/2$。DFT求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”(twiddle factor)。对于索引的前半部分，$0 \\le k < N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$（$0 \\le k < N/2$），我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这会得到：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的DFT。递归在基例 $N=1$ 时终止，此时序列 $\\{x_0\\}$ 的DFT就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n不需要单独的实现。我们可以将IDFT与正向DFT联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n右侧是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的DFT。因此，我们可以通过计算 $\\overline{X}$ 的DFT，对结果取复共轭，然后乘以 $1/N$ 来找到 $x_n$。即，$x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这使我们也能使用我们高效的FFT实现来计算逆变换 (IFFT)。\n\n该问题进一步要求验证两个基本定理。\n\n首先是循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的DFT是各个DFT的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素相乘。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来对此进行测试。\n\n其次是帕塞瓦尔恒等式 (Parseval's identity)。对于给定的DFT归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将针对一个特定的测试信号来验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT、一个递归的 $\\mathcal{O}(N \\log N)$ FFT、一个基于FFT的IFFT以及一个直接的循环卷积函数。然后，它将使用这些函数和一个数值容差 $\\varepsilon = 10^{-9}$ 来执行 $6$ 个指定的测试用例以进行比较。结果将被收集并以所需格式打印。", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N = 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}