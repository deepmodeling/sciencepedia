{"hands_on_practices": [{"introduction": "本练习聚焦于时间抽取（DIT）FFT算法的基础步骤：输入比特反转和第一阶段的蝶形运算。通过一个具体的4点（$N=4$）变换实例，你将亲手实践输入数据如何被重新排列，并被FFT的基本计算单元处理，从而对算法的核心机制建立起坚实的理解。[@problem_id:1711383]", "problem": "一个标准的基2时间抽取(DIT)快速傅里叶变换(FFT)算法被用于分析一个4点离散时间信号。该算法首先根据时间索引的位倒序对输入序列$x[n]$进行重新排序。在这次重新排序之后，第一个计算级通过对位倒序序列的相邻对执行2点离散傅里叶变换(DFT)，从而产生一个中间序列$G[n]$。\n\n考虑一个由$x[n] = (1+j)^{n}$定义的输入序列，其中$n=0, 1, 2, 3$，$j$是满足$j^2=-1$的虚数单位。\n\n计算4点DIT-FFT算法第一级所产生的中间序列$G[n] = \\{G[0], G[1], G[2], G[3]\\}$的四个复数值。将您的答案呈现为一个包含四个复数的序列。", "solution": "我们给定一个4点基2时间抽取FFT。在此算法中，首先通过对时间索引进行位倒序来重新排列输入$x[n]$，然后对相邻对执行2点DFT，以产生中间序列$G[n]$。\n\n首先计算输入样本：\n对于$x[n]=(1+j)^{n}$，且$j^{2}=-1$：\n$$\nx[0]=(1+j)^{0}=1,\\quad\nx[1]=(1+j)^{1}=1+j,\n$$\n$$\nx[2]=(1+j)^{2}=1+2j+j^{2}=2j,\\quad\nx[3]=(1+j)^{3}=(1+j)\\cdot(1+j)^{2}=(1+j)\\cdot 2j=2j+2j^{2}=-2+2j.\n$$\n\n接下来对索引$n\\in\\{0,1,2,3\\}$应用位倒序。使用2位倒序：\n$$\n0\\,(00)\\to 0\\,(00),\\quad 1\\,(01)\\to 2\\,(10),\\quad 2\\,(10)\\to 1\\,(01),\\quad 3\\,(11)\\to 3\\,(11).\n$$\n因此，位倒序序列是\n$$\n[x[0],\\,x[2],\\,x[1],\\,x[3]]=[1,\\,2j,\\,1+j,\\,-2+2j].\n$$\n\n第一级对相邻对执行2点DFT。对于一对$(a,b)$，其2点DFT产生\n$$\nA[0]=a+b,\\qquad A[1]=a-b.\n$$\n将此应用于两个相邻对：\n\n第1对: $(a,b)=(1,\\,2j)$\n$$\nG[0]=1+2j,\\qquad G[1]=1-2j.\n$$\n\n第2对: $(a,b)=(1+j,\\,-2+2j)$\n$$\nG[2]=(1+j)+(-2+2j)=-1+3j,\\qquad G[3]=(1+j)-(-2+2j)=3-j.\n$$\n\n因此，中间序列是\n$$\nG[n]=\\{\\,1+2j,\\;1-2j,\\;-1+3j,\\;3-j\\,\\}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1+2j & 1-2j & -1+3j & 3-j\\end{pmatrix}}$$", "id": "1711383"}, {"introduction": "在掌握了单级运算之后，本练习将挑战你追踪一个信号在8点（$N=8$）FFT的多级网络中的完整路径。使用简单的单位冲激信号作为输入，能让你清晰地观察到算法如何将信息从一个阶段系统性地传播到下一个阶段，最终分布到各个频率分量上。这个练习是可视化DIT-FFT完整数据流的关键。[@problem_id:1711379]", "problem": "考虑使用标准的时间抽取 (DIT) 快速傅里叶变换 (FFT) 算法来计算一个8点的离散傅里叶变换 (DFT)。\n\n该算法的输入信号为离散时间单位冲激序列，定义为 $x[n] = \\delta[n]$，其中 $n \\in \\{0, 1, \\dots, 7\\}$。\n\n对于一个 $N$ 点的变换，DIT-FFT 算法分 $\\log_2(N)$ 级进行。对于这个8点变换，共有3级。该过程首先对输入序列 $x[n]$ 的顺序进行位反转，以产生第一级的初始序列。第 $m$ 级的输出作为第 $m+1$ 级的输入。\n\n设进入最后一级（第3级）的复数值向量表示为 $X_{2}[k]$，其中 $k \\in \\{0, 1, \\dots, 7\\}$。请确定 $X_{2}[k]$ 的正确序列。\n\n旋转因子定义为 $W_N^k = \\exp(-j\\frac{2\\pi k}{N})$。基本的 DIT 蝶形运算接收两个输入 $A$ 和 $B$，并根据以下关系式产生两个输出 $A'$ 和 $B'$：\n$A' = A + W_N^k B$\n$B' = A - W_N^k B$\n\n以下哪个选项代表序列 $X_2[k]$？\n\nA. $\\{1, 1, 1, 1, 0, 0, 0, 0\\}$\n\nB. $\\{1, 1, 0, 0, 0, 0, 0, 0\\}$\n\nC. $\\{1, 1, 1, 1, 1, 1, 1, 1\\}$\n\nD. $\\{1, 0, 0, 0, 0, 0, 0, 0\\}$\n\nE. $\\{1, 0, 1, 0, 1, 0, 1, 0\\}$", "solution": "我们正在计算一个8点的 DIT-FFT，输入为 $x[n]=\\delta[n]$，其中 $n\\in\\{0,1,\\dots,7\\}$，即 $x[0]=1$ 且当 $n\\neq 0$ 时 $x[n]=0$。在具有自然顺序输出的 DIT-FFT 中，算法首先对输入序列进行位反转。设 $\\mathrm{rev}(m)$ 表示索引 $m$ 的3位反转。第1级的输入是位反转后的序列 $v[m]=x[\\mathrm{rev}(m)]$。由于对于所有 $n\\neq 0$，$x[n]$ 均为零，并且 $\\mathrm{rev}(0)=0$，因此可得\n$$\nv[0]=x[\\mathrm{rev}(0)]=x[0]=1,\\quad v[m]=x[\\mathrm{rev}(m)]=0\\ \\text{for}\\ m\\neq 0,\n$$\n所以，进入第1级的序列是 $[1,0,0,0,0,0,0,0]$。\n\n在每个蝶形运算中，输入为 $A$ 和 $B$，输出为\n$$\nA' = A + W_{8}^{k} B,\\quad B' = A - W_{8}^{k} B,\n$$\n其中 $W_{8}^{k}=\\exp\\!\\left(-j\\frac{2\\pi k}{8}\\right)$。因为在这个问题中，每当 $A=1$ 时，与之配对的 $B$ 都为0，所以旋转因子不影响非零计算。\n\n第1级（长度为2的蝶形）：配对为 $(0,1)$, $(2,3)$, $(4,5)$, $(6,7)$。唯一的非零配对是 $(0,1)$，其 $(A,B)=(1,0)$，产生 $(A',B')=(1,1)$。所有其他配对都产生 $(0,0)$。因此，第1级的输出是\n$$\n[1,1,0,0,0,0,0,0].\n$$\n\n第2级（长度为4的蝶形）：第一组的配对是 $(0,2)$ 和 $(1,3)$，第二组的配对是 $(4,6)$ 和 $(5,7)$。使用第1级的输出，非零配对是 $(0,2)$（其 $(A,B)=(1,0)$）和 $(1,3)$（其 $(A,B)=(1,0)$），每个都产生 $(1,1)$。第二组仍然是零。因此，第2级的输出，也就是最后一级的输入，是\n$$\nX_{2}[k]=[1,1,1,1,0,0,0,0].\n$$\n\n这与选项A相符。（作为一致性检查，第3级会接着将这些值组合起来，得到最终的 DFT 结果 $X[k]=1$（对所有 $k$ 成立），这与单位冲激的 DFT 预期结果一致。）", "answer": "$$\\boxed{A}$$", "id": "1711379"}, {"introduction": "原地（in-place）DIT-FFT算法的效率关键在于一种称为比特反转（bit-reversal）的初始数据重排。这项高级练习不仅要求你从理论上推导出为何需要这种置换，还要求你将其实现为一个高效的迭代算法。本实践旨在连接理论理解与高性能计算工程的实际应用，是掌握FFT精髓的重要一步。[@problem_id:2443897]", "problem": "本题要求您将离散傅里叶变换 (DFT) 的数学结构与基-$2$ 时间抽取 (decimation-in-time) 快速傅里叶变换 (FFT) 算法所需的数据存取模式联系起来，然后将该存取模式实现为一个高效的迭代置换生成器。\n\n从离散傅里叶变换 (DFT) 的定义出发，对于一个长度为 $N$ 的序列，其中 $N = 2^m$ 且 $m \\in \\mathbb{N}$，\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi \\frac{k n}{N}}, \\quad k \\in \\{0,1,\\dots,N-1\\},\n$$\n通过反复将求和拆分为偶数和奇数索引，推导出基-$2$ 时间抽取分解需要对输入进行重排，该重排对应于反转每个时间索引的 $m$ 位二进制表示。具体而言，假设 $k$ 的 $m$ 位二进制展开式为 $k = \\sum_{i=0}^{m-1} b_i 2^i$，其中 $b_i \\in \\{0,1\\}$，并定义位倒序映射 $\\pi_m$ 为\n$$\n\\pi_m(k) = \\sum_{i=0}^{m-1} b_i \\, 2^{m-1-i}.\n$$\n请解释为什么当输入首先根据 $x_{\\mathrm{reordered}}[k] = x[\\pi_m(k)]$ 进行重排后，一个原位 (in-place) 的基-$2$ 时间抽取 FFT 能计算出自然顺序的输出。您的推导应仅依赖于 DFT 定义、二进制展开和指数性质，而不依赖于任何预先引用的 FFT 公式。\n\n任务：\n- 实现一个函数，对于给定的正整数 $N$，当 $N$ 是 2 的幂时，返回长度为 $N$ 的整数列表 $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$；否则，引发一个错误。该实现必须：\n  - 是迭代的（无递归）。\n  - 时间复杂度为 $\\mathcal{O}(N)$，并且除了输出数组外，空间复杂度为 $\\mathcal{O}(1)$。\n  - 仅使用整数和位运算来构建该置换。\n- 将您的置换应用于单位序列 $[0,1,\\dots,N-1]$，即通过该置换进行索引，使得结果列表等于该置换本身，即 $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$。\n- 错误处理：如果 $N$ 不是 2 的正整数次幂，您的程序不应异常终止；相反，对于该测试用例，应记录一个布尔值，表示已正确检测到错误。\n\n约束条件：\n- 不要使用递归。\n- 不要调用任何库中的 FFT 例程。\n\n测试套件：\n对于集合 $\\{\\,1,\\,2,\\,8,\\,16,\\,12,\\,0\\,\\}$ 中的每个 $N$：\n- 如果 $N$ 是 2 的正整数次幂，输出列表 $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$。\n- 如果 $N$ 不是 2 的正整数次幂（包括 $N=0$），若您的实现检测到此情况并通过引发错误来处理，则输出布尔值 $\\,\\mathrm{True}\\,$，否则输出 $\\,\\mathrm{False}\\,$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，结果顺序与测试套件中 $N$ 值的顺序相同。每个列表必须用方括号和逗号分隔的整数打印，布尔值必须打印为 $\\,\\mathrm{True}\\,$ 或 $\\,\\mathrm{False}\\,$。例如，一个有效的最终行可以是\n$[ [0], [0,1], [0,4,2,6,1,5,3,7], [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15], True, True ]$。", "solution": "本题要求推导用于基-$2$ 时间抽取 (DIT) 快速傅里叶变换 (FFT) 算法的位倒序输入置换，然后高效地迭代实现该置换生成器。\n\n首先，我们应推导位倒序置换的必要性。长度为 $N$ 的序列 $x[n]$ 的离散傅里叶变换 (DFT) 定义为：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] W_N^{kn}, \\quad k \\in \\{0, 1, \\dots, N-1\\}\n$$\n其中 $W_N = e^{-j 2\\pi/N}$ 是主 $N$ 次单位根。我们考虑 $N$ 是 2 的幂的情况，即 $N=2^m$，其中 $m$ 为某个非负整数。\n\n时间抽取的原理是将时域索引 $n$ 的求和分为偶数项和奇数项。令偶数索引为 $n=2r$，奇数索引为 $n=2r+1$，其中 $r$ 的范围是从 $0$ 到 $N/2-1$。\n$$\nX[k] = \\sum_{r=0}^{N/2-1} x[2r] W_N^{k(2r)} + \\sum_{r=0}^{N/2-1} x[2r+1] W_N^{k(2r+1)}\n$$\n利用性质 $W_N^2 = W_{N/2}$，表达式变为：\n$$\nX[k] = \\sum_{r=0}^{N/2-1} x[2r] W_{N/2}^{kr} + W_N^k \\sum_{r=0}^{N/2-1} x[2r+1] W_{N/2}^{kr}\n$$\n这表明 $N$ 点 DFT 可以通过两个 $(N/2)$ 点 DFT 计算得出：一个是对 $x[n]$ 的偶数索引部分（我们称之为 $x_e[r] = x[2r]$）进行变换，另一个是对奇数索引部分（$x_o[r] = x[2r+1]$）进行变换。令 $X_e[k]$ 和 $X_o[k]$ 分别为它们的 $(N/2)$ 点 DFT。由于 DFT 的周期性，对于 $k \\ge N/2$，有 $X_e[k] = X_e[k \\pmod{N/2}]$ 和 $X_o[k] = X_o[k \\pmod{N/2}]$。这便得到了蝶形关系：\n$$\n\\begin{cases}\nX[k] = X_e[k] + W_N^k X_o[k] & \\text{对于 } 0 \\le k < N/2 \\\\\nX[k+N/2] = X_e[k] - W_N^k X_o[k] & \\text{对于 } 0 \\le k < N/2\n\\end{cases}\n$$\n这里我们使用了 $W_N^{k+N/2} = W_N^k W_N^{N/2} = -W_N^k$。\n\n这个分解过程可以递归应用。在每个抽取阶段，我们根据索引是偶数还是奇数对序列进行排序。让我们追踪单个输入样本 $x[n]$ 的位置。索引 $n$ 有一个 $m$ 位的二进制表示，$n = (b_{m-1} b_{m-2} \\dots b_1 b_0)_2 = \\sum_{i=0}^{m-1} b_i 2^i$。\n\n在第一级抽取阶段，序列根据 $n$ 的奇偶性进行划分，这取决于其最低有效位 (LSB) $b_0$。所有 $b_0=0$（偶数）的样本 $x[n]$ 被归为一组，所有 $b_0=1$（奇数）的样本被归为另一组。\n在一个概念性的计算树中，这对应于基于 $b_0$ 的分支。如果我们对输入数组进行重排，使得所有偶数索引元素排在前面，奇数索引元素排在后面，那么 $x[n]$ 的位置现在将取决于 $b_0$ 作为其最高有效位 (MSB)。\n\n在第二阶段，这两个组中的每一个都将进一步抽取。例如，偶数组 $\\{x[2r]\\}$ 根据新索引 $r$ 的奇偶性进行划分。由于 $r=n/2$，因此 $r$ 的二进制表示是 $(b_{m-1} b_{m-2} \\dots b_1)_2$。$r$ 的奇偶性由其 LSB 决定，即原始索引 $n$ 的位 $b_1$。这次划分确定了最终重排后索引的第二个 MSB。\n\n这个过程持续 $m$ 个阶段。在第 $s$ 阶段（$s=1, \\dots, m$），抽取基于原始索引 $n$ 的位 $b_{s-1}$。在完全抽取的结构中定位样本 $x[n]$ 所做的一系列决策是 $(b_0, b_1, \\dots, b_{m-1})$。如果我们定义最终重排后的索引 $p$，使其二进制表示从 MSB 到 LSB 由这个决策序列构成，我们得到 $p = (b_0 b_1 \\dots b_{m-1})_2$。\n\n让我们正式地写出这一点。原始索引是 $n = \\sum_{i=0}^{m-1} b_i 2^i$。重排后的索引是 $p = \\sum_{i=0}^{m-1} b_i 2^{m-1-i}$。这正是问题中定义的位倒序映射 $\\pi_m(n)$。\n因此，DIT 分解自然地意味着，要达到长度为 1 的 DFTs（即样本本身）的最终阶段，输入序列 $x[n]$ 必须被重排为序列 $x'[\\pi_m(n)] = x[n]$。\n\n一个迭代的、原位的 FFT 算法是自底向上计算变换的，从长度为 2 的 DFT 开始，逐级进行到长度为 $N$。为了实现高效的原位计算，其中蝶形运算以简单、规则的步幅访问元素，输入数组必须预先进行重排。通过将输入排序为 $x'[\\pi_m(n)] = x[n]$，算法可以逐级进行，最终的输出值 $X[k]$ 将以自然顺序存储，即在数组的索引 $k$ 处。\n\n在实现方面，需要一个高效的 $\\mathcal{O}(N)$ 迭代算法来生成位倒序置换 $[\\pi_m(0), \\pi_m(1), \\dots, \\pi_m(N-1)]$。对从 $0$ 到 $N-1$ 的每个整数进行位反转的朴素方法需要 $\\mathcal{O}(N \\log N)$ 的时间。一个 $\\mathcal{O}(N)$ 的算法可以通过递推来构建。\n令 $\\text{rev}[i]$ 表示 $\\pi_m(i)$。基本情况是 $\\text{rev}[0] = 0$。对于 $i>0$，我们可以从一个先前计算过的值来计算 $\\text{rev}[i]$。考虑 $i$ 和 $i' = i \\gg 1$（整除 2）之间的关系。在二进制中，$i'$ 是移除了 LSB 的 $i$。$i'$ 的位倒序是 $\\text{rev}[i']$。如果我们将 $\\text{rev}[i']$ 右移一位，我们得到的是 $i'$ 的位倒序，并在 MSB 处附加了一个 0。这对应于 $\\text{rev}[i]$ 的大部分位。唯一缺失的部分是 $i$ 的 LSB (`i & 1`)，它必须成为 $\\text{rev}[i]$ 的 MSB。这可以通过将 `i & 1` 左移 $m-1$ 位来实现。\n这导出了递推关系：\n$$\n\\text{rev}[i] = (\\text{rev}[i \\gg 1] \\gg 1) \\ | \\ ((i \\ \\& \\ 1) \\ll (m-1))\n$$\n其中 `|` 表示按位或运算，`&` 是按位与，`>>` 和 `<<` 是按位移位。由于 $m = \\log_2 N$，它可以被计算为 $m = N.\\text{bit\\_length}() - 1$。\n这种关系允许在 $\\mathcal{O}(N)$ 时间内迭代计算整个置换数组 `rev`，因为每一步都花费常数时间，并且有 $N$ 步。除了用于输出数组本身的 $\\mathcal{O}(N)$ 存储外，空间复杂度为 $\\mathcal{O}(1)$。\n检查 $N$ 是否为 2 的正整数次幂可以使用位运算技巧 `(N > 0) and (N & (N - 1) == 0)` 高效地完成。", "answer": "```python\nimport numpy as np\n# Per problem specification, numpy and scipy are part of the execution environment.\n# They are not used in the solution logic to adhere to problem constraints.\n\ndef generate_bit_reversal_permutation(N: int) -> list[int]:\n    \"\"\"\n    Generates the bit-reversal permutation for a given size N.\n\n    Args:\n        N: The size of the sequence, must be a positive power of two.\n\n    Returns:\n        A list of integers representing the bit-reversal permutation.\n\n    Raises:\n        ValueError: If N is not a positive power of two.\n    \"\"\"\n    # Validate that N is a positive power of two.\n    # The expression `(N & (N - 1) == 0)` is true for powers of two.\n    # `N > 0` excludes the case N=0.\n    if not (N > 0 and (N & (N - 1) == 0)):\n        raise ValueError(\"N must be a positive power of two.\")\n\n    if N == 1:\n        return [0]\n\n    # m is the number of bits required to represent numbers up to N-1.\n    # For N=2^m, the number of bits is m.\n    # In Python, m = log2(N) can be found using N.bit_length() - 1.\n    m = N.bit_length() - 1\n\n    # `rev` will store the permutation, where rev[i] is the bit-reversal of i.\n    rev = [0] * N\n\n    # The algorithm computes rev[i] based on rev[i >> 1] in O(1) time.\n    # Total time complexity is O(N).\n    for i in range(1, N):\n        # rev[i >> 1] is the bit-reversal of i with its LSB dropped.\n        # Shifting this right by 1 makes space for the new MSB.\n        # (i & 1) is the LSB of i.\n        # Shifting this left by m-1 positions makes it the MSB.\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (m - 1))\n        \n    return rev\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    test_cases = [1, 2, 8, 16, 12, 0]\n    results = []\n\n    for N in test_cases:\n        try:\n            # Attempt to generate the permutation for the given N.\n            permutation = generate_bit_reversal_permutation(N)\n            results.append(permutation)\n        except ValueError:\n            # If a ValueError is raised, it means the invalid N was correctly detected.\n            # As per the problem, we record `True` in this case.\n            results.append(True)\n    \n    # Format the output string according to the strict problem specification.\n    # Lists are formatted as `[item1,item2,...]` with no spaces.\n    # Booleans are formatted as `True` or `False`.\n    # The entire result is a comma-separated list enclosed in brackets.\n    results_str = []\n    for res in results:\n        if isinstance(res, list):\n            # Custom formatting for lists to match the required output style\n            results_str.append(f\"[{','.join(map(str, res))}]\")\n        else:\n            # Standard string representation for booleans (True/False)\n            results_str.append(str(res))\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2443897"}]}