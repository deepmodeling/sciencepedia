{"hands_on_practices": [{"introduction": "控制系统的许多模型源于本质上非线性的物理定律。本练习将演示如何对一个多变量的、基于物理的空气动力学阻力模型进行线性化 [@problem_id:2720555]，以便在特定的飞行条件下分析飞行器的动态特性。通过这个实践，你不仅能巩固在向量微积分方面的技能，还能对线性化后模型参数的物理直觉有更深刻的理解。", "problem": "考虑一个建模为质点的刚性飞行器的平移动力学。令惯性速度矢量为 $v \\in \\mathbb{R}^{3}$，质量为 $m0$。作用在飞行器上的非线性气动阻力建模为\n$$\nF_{d}(v) = \\frac{1}{2}\\,\\rho\\,C_{D}\\,S\\,\\|v\\|\\,v,\n$$\n其中 $\\rho$ 是空气密度，$C_{D}$ 是一个恒定的阻力系数，$S$ 是参考面积。平移动力学方程为\n$$\nm\\,\\dot{v} = F_{\\text{ext}}(t) - F_{d}(v),\n$$\n其中 $F_{\\text{ext}}(t)$ 包括所有其他力（例如，推力和重力），并且存在一个稳定直线飞行的工作点，其速度恒定为\n$$\nv_{0} = \\begin{pmatrix} V_{0} \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad V_{0}  0,\n$$\n此时没有加速度（即，在 $v=v_{0}$ 时，由于与 $F_{\\text{ext}}$ 精确平衡，$\\dot{v}=0$）。你需要围绕此工作点，对速度动力学关于 $v$ 的扰动进行线性化，并在 $v_{0}$ 的一个足够小的邻域内将 $\\rho$，$C_{D}$ 和 $S$ 视作常数。\n\n使用非线性系统 $\\dot{x} = f(x)$ 在 $x_{0}$ 附近线性化的定义，即 $\\dot{\\delta x} \\approx A\\,\\delta x$，其中 $A = \\left.\\frac{\\partial f}{\\partial x}\\right|_{x_{0}}$。仅关注气动阻力 $F_{d}(v)$ 对线性化动力学的贡献，并计算系统矩阵 $A$ 中将 $\\delta \\dot{v}$ 与 $\\delta v$ 关联起来的相应项。特别地，确定三个对角线元素\n$$\nA_{11},\\; A_{22},\\; A_{33} \\quad \\text{其中} \\quad A_{ij} = \\left.\\frac{\\partial \\dot{v}_{i}}{\\partial v_{j}}\\right|_{v=v_{0}},\n$$\n这些元素仅由阻力项产生。\n\n用 $\\rho$，$C_{D}$，$S$，$m$ 和 $V_{0}$ 的符号形式给出你的最终结果。将你的答案表示为单个的 $1 \\times 3$ 行矩阵 $[A_{11},\\,A_{22},\\,A_{33}]$。不要代入数值。无需四舍五入。最终答案中不要包含单位。", "solution": "该问题要求对飞行器的平移动力学在一个指定工作点附近进行线性化。运动方程为\n$$\nm\\,\\dot{v} = F_{\\text{ext}}(t) - F_{d}(v)\n$$\n其中 $m$ 是质量，$v \\in \\mathbb{R}^3$ 是速度，$F_{\\text{ext}}(t)$ 是外力，$F_{d}(v)$ 是非线性气动阻力。这可以改写为速度动力学形式：\n$$\n\\dot{v} = \\frac{1}{m} F_{\\text{ext}}(t) - \\frac{1}{m} F_{d}(v).\n$$\n我们被要求在稳态工作点 $v_0 = \\begin{pmatrix} V_{0} \\\\ 0 \\\\ 0 \\end{pmatrix}$（其中 $V_0  0$）附近对该系统进行线性化。一个系统 $\\dot{x} = f(x, u)$ 在一个工作点 $(x_0, u_0)$ 附近的线性化会得到线性系统 $\\dot{\\delta x} \\approx A \\delta x + B \\delta u$，其中 $\\delta x = x - x_0$，$\\delta u = u - u_0$，而系统矩阵 $A$ 是雅可比矩阵 $A = \\left.\\frac{\\partial f}{\\partial x}\\right|_{(x_0, u_0)}$。\n\n问题指明，我们必须只关注气动阻力 $F_d(v)$ 对线性化动力学的贡献。这意味着我们要计算 $\\dot{v}$ 表达式中与阻力相关的项的雅可比矩阵。令状态为 $x=v$。动力学函数中与速度相关的部分是 $f(v) = -\\frac{1}{m} F_d(v)$。因此，阻力贡献对应的系统矩阵 $A$ 是\n$$\nA = \\left.\\frac{\\partial}{\\partial v}\\left(-\\frac{1}{m} F_d(v)\\right)\\right|_{v = v_0}.\n$$\n阻力由下式给出：\n$$\nF_{d}(v) = \\frac{1}{2}\\rho C_{D} S \\|v\\| v,\n$$\n其中 $\\rho$、$C_{D}$ 和 $S$ 是正常数，且 $\\|v\\| = \\sqrt{v_1^2 + v_2^2 + v_3^2}$。\n我们定义一个常数 $k = \\frac{\\rho C_{D} S}{2m}$ 来简化记法。阻力对动力学的贡献是\n$$\nf(v) = -k \\|v\\| v.\n$$\n该矢量函数的分量是 $f_i(v) = -k \\|v\\| v_i$，其中 $i=1, 2, 3$。雅可比矩阵 $A$ 的元素由 $A_{ij} = \\left.\\frac{\\partial f_i}{\\partial v_j}\\right|_{v=v_0}$ 给出。使用微分的乘法法则，我们有：\n$$\n\\frac{\\partial f_i}{\\partial v_j} = -k \\frac{\\partial}{\\partial v_j} (\\|v\\| v_i) = -k \\left( \\left(\\frac{\\partial \\|v\\|}{\\partial v_j}\\right) v_i + \\|v\\| \\left(\\frac{\\partial v_i}{\\partial v_j}\\right) \\right).\n$$\n所需的偏导数为：\n$$\n\\frac{\\partial v_i}{\\partial v_j} = \\delta_{ij} \\quad (\\text{克罗内克 δ 符号})\n$$\n$$\n\\frac{\\partial \\|v\\|}{\\partial v_j} = \\frac{\\partial}{\\partial v_j} \\left( \\sum_{l=1}^{3} v_l^2 \\right)^{1/2} = \\frac{1}{2} \\left( \\sum_{l=1}^{3} v_l^2 \\right)^{-1/2} (2 v_j) = \\frac{v_j}{\\|v\\|}.\n$$\n代入这些表达式，得到雅可比元素的通用形式：\n$$\n\\frac{\\partial f_i}{\\partial v_j} = -k \\left( \\frac{v_j}{\\|v\\|} v_i + \\|v\\| \\delta_{ij} \\right).\n$$\n我们必须在工作点 $v_0 = (V_0, 0, 0)^T$ 处对这些元素求值。在该点，速度分量为 $v_1 = V_0$, $v_2 = 0$, $v_3 = 0$，速率为 $\\|v_0\\| = \\sqrt{V_0^2 + 0^2 + 0^2} = V_0$。\n\n问题要求矩阵 $A$ 的对角线元素：$A_{11}$、$A_{22}$ 和 $A_{33}$。通过在通用公式中令 $j=i$ 并在 $v_0$ 处求值得到。\n对于一个通用的对角线元素 $A_{ii}$：\n$$\nA_{ii} = \\left.\\frac{\\partial f_i}{\\partial v_i}\\right|_{v_0} = \\left. -k \\left( \\frac{v_i^2}{\\|v\\|} + \\|v\\| \\right) \\right|_{v=v_0}.\n$$\n现在我们计算每个所需的元素。\n\n对于 $A_{11}$（$i=1$）：\n$$\nA_{11} = -k \\left( \\frac{V_0^2}{V_0} + V_0 \\right) = -k (V_0 + V_0) = -2 k V_0.\n$$\n代回 $k = \\frac{\\rho C_{D} S}{2m}$：\n$$\nA_{11} = -2 \\left(\\frac{\\rho C_{D} S}{2m}\\right) V_0 = -\\frac{\\rho C_{D} S V_0}{m}.\n$$\n\n对于 $A_{22}$（$i=2$）：\n$$\nA_{22} = -k \\left( \\frac{0^2}{V_0} + V_0 \\right) = -k (0 + V_0) = -k V_0.\n$$\n代回 $k = \\frac{\\rho C_{D} S}{2m}$：\n$$\nA_{22} = -\\left(\\frac{\\rho C_{D} S}{2m}\\right) V_0 = -\\frac{\\rho C_{D} S V_0}{2m}.\n$$\n\n对于 $A_{33}$（$i=3$）：\n$$\nA_{33} = -k \\left( \\frac{0^2}{V_0} + V_0 \\right) = -k (0 + V_0) = -k V_0.\n$$\n代回 $k = \\frac{\\rho C_{D} S}{2m}$：\n$$\nA_{33} = -\\left(\\frac{\\rho C_{D} S}{2m}\\right) V_0 = -\\frac{\\rho C_{D} S V_0}{2m}.\n$$\n纵向阻尼项 $A_{11}$ 与横向-航向阻尼项 $A_{22}$ 和 $A_{33}$ 之间2倍的差异在物理上是正确的。前向速度的扰动会影响阻力公式中速度矢量的大小和速度分量，产生一个平方依赖关系，这在线性化后导致了一个2倍的因子。从零开始的横向速度扰动，其对速度大小的贡献是二阶的，因此仅在一阶上线性地影响阻力分量。\n\n最终结果是这三个对角线元素，表示为一个行矩阵。\n$$\n[A_{11}, A_{22}, A_{33}] = \\left[ -\\frac{\\rho C_{D} S V_0}{m}, -\\frac{\\rho C_{D} S V_0}{2m}, -\\frac{\\rho C_{D} S V_0}{2m} \\right].\n$$", "answer": "$$\n\\boxed{\n\\begin{bmatrix}\n-\\frac{\\rho C_{D} S V_{0}}{m}  -\\frac{\\rho C_{D} S V_{0}}{2m}  -\\frac{\\rho C_{D} S V_{0}}{2m}\n\\end{bmatrix}\n}\n$$", "id": "2720555"}, {"introduction": "现实世界的控制系统包含执行器等具有自身非线性特性的组件，例如饱和（saturation）。本练习将探讨这类非线性如何影响整个系统的线性化过程 [@problem_id:2720584]。通过对比系统在非饱和与饱和两种工作状态下的线性化模型，你将发现线性化模型对工作点的关键依赖性，这是控制设计中一个至关重要的实际考量。", "problem": "考虑一个由 $\\dot{x} = f(x,u)$ 给出动态的单输入单状态对象，其中 $f(x,u) = -x + u^{3}$。控制输入 $u$ 由一个具有饱和非线性 $u = \\mathrm{sat}(v)$ 的执行器生成，其中\n$$\n\\mathrm{sat}(v) = \n\\begin{cases}\n-2,  v \\le -2, \\\\\nv,  -2  v  2, \\\\\n2,  v \\ge 2.\n\\end{cases}\n$$\n你需要将从执行器指令 $v$ 到状态 $x$ 的闭环映射在两个稳态工作点附近进行线性化。一个稳态工作点 $(x^{\\star},u^{\\star},v^{\\star})$ 满足 $0 = f(x^{\\star},u^{\\star})$ 和 $u^{\\star} = \\mathrm{sat}(v^{\\star})$。\n\n1) 一个由 $v^{\\star} = 1$ 指定的非饱和工作点。确定该点的 $u^{\\star}$ 和 $x^{\\star}$。\n\n2) 一个由 $v^{\\star} = 3$ 指定的饱和工作点。确定该点的 $u^{\\star}$ 和 $x^{\\star}$。\n\n从一阶泰勒展开和基础微积分（包括链式法则）出发，推导每个工作点附近形式为\n$$\n\\delta \\dot{x} = A\\,\\delta x + B\\,\\delta v,\n$$\n的一阶线性化模型，其中 $\\delta x = x - x^{\\star}$ 且 $\\delta v = v - v^{\\star}$。计算每个工作点对应的输入增益 $B$。\n\n将你的最终答案以单行矩阵的形式给出，其中包含一对值 $\\big(B_{\\text{unsat}},\\,B_{\\text{sat}}\\big)$。给出精确值，不要四舍五入。", "solution": "问题陈述已经过评估并被认为是有效的。这是一个关于非线性系统线性化的适定问题，属于控制理论中的一个基础课题。所有必要的数据和定义都已提供，不存在科学或逻辑上的不一致。我们将着手求解。\n\n系统动态由以下非线性微分方程给出：\n$$\n\\dot{x} = f(x,u) = -x + u^{3}\n$$\n对象输入 $u$ 由执行器指令 $v$ 通过一个饱和函数确定：\n$$\nu = \\mathrm{sat}(v) = \n\\begin{cases}\n-2,  v \\le -2 \\\\\nv,  -2  v  2 \\\\\n2,  v \\ge 2\n\\end{cases}\n$$\n综合起来，从指令 $v$ 到状态 $x$ 的闭环系统动态为：\n$$\n\\dot{x} = g(x,v) = -x + (\\mathrm{sat}(v))^{3}\n$$\n我们的任务是在指定的工作点 $(x^{\\star}, v^{\\star})$ 附近对该系统进行线性化。将 $\\dot{x} = g(x,v)$ 在 $(x^{\\star}, v^{\\star})$ 附近进行一阶泰勒展开，可得：\n$$\n\\dot{x} \\approx g(x^{\\star}, v^{\\star}) + \\frac{\\partial g}{\\partial x}\\bigg|_{(x^{\\star}, v^{\\star})} (x - x^{\\star}) + \\frac{\\partial g}{\\partial v}\\bigg|_{(x^{\\star}, v^{\\star})} (v - v^{\\star})\n$$\n根据定义，在稳态工作点处，$\\dot{x}^{\\star} = g(x^{\\star}, v^{\\star}) = 0$。令 $\\delta x = x - x^{\\star}$ 且 $\\delta v = v - v^{\\star}$。线性化后的动态为：\n$$\n\\delta \\dot{x} = \\frac{\\partial g}{\\partial x}\\bigg|_{(x^{\\star}, v^{\\star})} \\delta x + \\frac{\\partial g}{\\partial v}\\bigg|_{(x^{\\star}, v^{\\star})} \\delta v\n$$\n这与所要求的形式 $\\delta \\dot{x} = A\\,\\delta x + B\\,\\delta v$ 相匹配，其中：\n$$\nA = \\frac{\\partial g}{\\partial x}\\bigg|_{(x^{\\star}, v^{\\star})} \\quad \\text{和} \\quad B = \\frac{\\partial g}{\\partial v}\\bigg|_{(x^{\\star}, v^{\\star})}\n$$\n问题要求计算输入增益 $B$。我们计算 $g(x,v)$ 关于 $v$ 的偏导数：\n$$\nB = \\frac{\\partial}{\\partial v} \\left( -x + (\\mathrm{sat}(v))^{3} \\right)\n$$\n使用链式法则，可得：\n$$\nB = 3(\\mathrm{sat}(v))^{2} \\cdot \\frac{d}{dv}(\\mathrm{sat}(v))\n$$\n该表达式必须在每个工作点处求值。饱和函数的导数是分段常数：\n$$\n\\frac{d}{dv}(\\mathrm{sat}(v)) = \n\\begin{cases}\n0,  v  -2 \\text{ 或 } v  2 \\\\\n1,  -2  v  2\n\\end{cases}\n$$\n导数在 $v = \\pm 2$ 处未定义，但指定的工作点不在这些边界上。\n\n情况1：非饱和工作点\n给定 $v^{\\star} = 1$。该值位于区间 $(-2, 2)$ 内。\n首先，我们确定相应的稳态值 $u^{\\star}$ 和 $x^{\\star}$。\n对于 $v^{\\star} = 1$，执行器处于其线性区：\n$$\nu^{\\star} = \\mathrm{sat}(v^{\\star}) = \\mathrm{sat}(1) = 1\n$$\n稳态条件为 $\\dot{x} = 0$，因此 $f(x^{\\star}, u^{\\star}) = 0$：\n$$\n-x^{\\star} + (u^{\\star})^{3} = 0 \\implies x^{\\star} = (u^{\\star})^{3} = (1)^{3} = 1\n$$\n非饱和工作点为 $(x^{\\star}, u^{\\star}, v^{\\star}) = (1, 1, 1)$。\n现在，我们计算该点的增益 $B_{\\text{unsat}}$。由于 $v^{\\star}=1$ 处于非饱和区，饱和函数的导数为：\n$$\n\\frac{d}{dv}(\\mathrm{sat}(v))\\bigg|_{v=1} = 1\n$$\n将 $v^{\\star} = 1$ 和 $u^{\\star} = \\mathrm{sat}(1) = 1$ 代入 $B$ 的表达式：\n$$\nB_{\\text{unsat}} = 3(\\mathrm{sat}(1))^{2} \\cdot \\left(\\frac{d}{dv}(\\mathrm{sat}(v))\\bigg|_{v=1}\\right) = 3(1)^{2} \\cdot 1 = 3\n$$\n\n情况2：饱和工作点\n给定 $v^{\\star} = 3$。该值位于区域 $v \\ge 2$ 内。\n首先，我们确定相应的稳态值 $u^{\\star}$ 和 $x^{\\star}$。\n对于 $v^{\\star} = 3$，执行器处于饱和状态：\n$$\nu^{\\star} = \\mathrm{sat}(v^{\\star}) = \\mathrm{sat}(3) = 2\n$$\n稳态条件 $f(x^{\\star}, u^{\\star}) = 0$ 得出：\n$$\n-x^{\\star} + (u^{\\star})^{3} = 0 \\implies x^{\\star} = (u^{\\star})^{3} = (2)^{3} = 8\n$$\n饱和工作点为 $(x^{\\star}, u^{\\star}, v^{\\star}) = (8, 2, 3)$。\n现在，我们计算该点的增益 $B_{\\text{sat}}$。由于 $v^{\\star}=3$ 处于饱和区，饱和函数的导数为：\n$$\n\\frac{d}{dv}(\\mathrm{sat}(v))\\bigg|_{v=3} = 0\n$$\n将 $v^{\\star} = 3$ 和 $u^{\\star} = \\mathrm{sat}(3) = 2$ 代入 $B$ 的表达式：\n$$\nB_{\\text{sat}} = 3(\\mathrm{sat}(3))^{2} \\cdot \\left(\\frac{d}{dv}(\\mathrm{sat}(v))\\bigg|_{v=3}\\right) = 3(2)^{2} \\cdot 0 = 0\n$$\n增益为零，这与预期相符。在饱和状态下，指令 $v$ 的微小变化不影响执行器输出 $u$，因此也不影响状态动态。\n\n最终答案是这对值 $(B_{\\text{unsat}}, B_{\\text{sat}})$。", "answer": "$$\n\\boxed{\n\\begin{bmatrix}\n3  0\n\\end{bmatrix}\n}\n$$", "id": "2720584"}, {"introduction": "尽管解析线性化是基础，但对于高度复杂或“黑箱”系统，它可能并不可行。本练习将介绍一种常见的实用替代方法：使用有限差分等数值方法进行经验线性化 [@problem_id:2720568]。通过比较解析方法和数值方法的结果，你将深入了解数值估计的准确性，并体会其作为现代工程实践中强大工具的作用。", "problem": "给定一个由常微分方程（ODE）定义的光滑、时不变、非线性状态空间模型，其状态向量为 $\\mathbf{x} \\in \\mathbb{R}^3$，输入向量为 $\\mathbf{u} \\in \\mathbb{R}^2$。状态导数的分量形式定义如下\n$$\n\\begin{aligned}\nf_1(\\mathbf{x},\\mathbf{u}) = x_2 + 0.5 \\sin(x_1) + u_1, \\\\\nf_2(\\mathbf{x},\\mathbf{u}) = -0.8 \\sin(x_1) - 0.1 x_2^3 + u_2, \\\\\nf_3(\\mathbf{x},\\mathbf{u}) = -0.3 x_3 + 0.2 x_1^2 - 0.1 u_1^2 + 0.05 u_2^2,\n\\end{aligned}\n$$\n因此 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x},\\mathbf{u}) = [f_1,f_2,f_3]^\\top$。考虑在稳态工作点 $(\\mathbf{x}^\\star,\\mathbf{u}^\\star)$ 附近的小信号模型（局部线性化），该点满足 $\\mathbf{f}(\\mathbf{x}^\\star,\\mathbf{u}^\\star) = \\mathbf{0}$。根据泰勒展开和雅可比矩阵的定义，第一性原理小信号模型为\n$$\n\\delta \\dot{\\mathbf{x}} = A \\, \\delta \\mathbf{x} + B \\, \\delta \\mathbf{u},\n$$\n其中 $A = \\left.\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}\\right|_{(\\mathbf{x}^\\star,\\mathbf{u}^\\star)}$ 且 $B = \\left.\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{u}}\\right|_{(\\mathbf{x}^\\star,\\mathbf{u}^\\star)}$。\n\n您的任务是将此第一性原理线性化与通过扰动 $\\mathbf{f}$ 的黑箱高保真模拟器并使用对称有限差分估计雅可比矩阵所获得的经验线性化进行比较。对每个状态和输入分量使用中心差分法，并采用用户指定的扰动幅度 $h  0$：\n$$\n\\widehat{A}_{:,i} \\approx \\frac{\\mathbf{f}(\\mathbf{x}^\\star + h \\mathbf{e}_i,\\mathbf{u}^\\star) - \\mathbf{f}(\\mathbf{x}^\\star - h \\mathbf{e}_i,\\mathbf{u}^\\star)}{2h}, \\quad\n\\widehat{B}_{:,j} \\approx \\frac{\\mathbf{f}(\\mathbf{x}^\\star,\\mathbf{u}^\\star + h \\mathbf{e}_j) - \\mathbf{f}(\\mathbf{x}^\\star,\\mathbf{u}^\\star - h \\mathbf{e}_j)}{2h},\n$$\n其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量。\n\n为确保稳态工作点满足 $\\mathbf{f}(\\mathbf{x}^\\star,\\mathbf{u}^\\star)=\\mathbf{0}$，对于给定的 $(x_1^\\star, x_2^\\star)$ 名义值，按以下方式构造 $(\\mathbf{x}^\\star,\\mathbf{u}^\\star)$：\n- 设置 $u_1^\\star = -x_2^\\star - 0.5 \\sin(x_1^\\star)$。\n- 设置 $u_2^\\star = 0.8 \\sin(x_1^\\star) + 0.1 (x_2^\\star)^3$。\n- 设置 $x_3^\\star = \\dfrac{0.2 (x_1^\\star)^2 - 0.1 (u_1^\\star)^2 + 0.05 (u_2^\\star)^2}{0.3}$。\n\n这种构造方法保证了 $\\mathbf{f}(\\mathbf{x}^\\star,\\mathbf{u}^\\star)=\\mathbf{0}$。\n\n为以下每个测试用例计算解析雅可比矩阵与经验雅可比矩阵之差的 Frobenius 范数，即 $\\lVert A - \\widehat{A} \\rVert_F$ 和 $\\lVert B - \\widehat{B} \\rVert_F$。您的程序必须：\n- 精确实现指定的 $\\mathbf{f}(\\mathbf{x},\\mathbf{u})$。\n- 通过第一性原理计算 $A$ 和 $B$（手动进行符号微分，然后实现）。\n- 使用给定的 $h$ 通过中心有限差分计算 $\\widehat{A}$ 和 $\\widehat{B}$。\n- 为每个测试用例汇总并以指定的输出格式将两个误差范数报告为浮点数。\n\n测试套件（每个测试用例提供 $(x_1^\\star, x_2^\\star, h)$；通过上述规则计算 $(x_3^\\star,u_1^\\star,u_2^\\star)$）：\n- 情况 1：$(x_1^\\star, x_2^\\star, h) = (0.0, 0.0, 1\\times 10^{-6})$。\n- 情况 2：$(x_1^\\star, x_2^\\star, h) = (1.0, 0.5, 1\\times 10^{-6})$。\n- 情况 3：$(x_1^\\star, x_2^\\star, h) = (2.5, -1.0, 1\\times 10^{-5})$。\n- 情况 4：$(x_1^\\star, x_2^\\star, h) = (-1.2, 2.0, 1\\times 10^{-7})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其中包含按以下顺序排列的 8 个浮点结果\n$$\n[\\lVert A - \\widehat{A} \\rVert_F^{(1)}, \\lVert B - \\widehat{B} \\rVert_F^{(1)}, \\lVert A - \\widehat{A} \\rVert_F^{(2)}, \\lVert B - \\widehat{B} \\rVert_F^{(2)}, \\lVert A - \\widehat{A} \\rVert_F^{(3)}, \\lVert B - \\widehat{B} \\rVert_F^{(3)}, \\lVert A - \\widehat{A} \\rVert_F^{(4)}, \\lVert B - \\widehat{B} \\rVert_F^{(4)}].\n$$\n本问题不涉及单位；以默认十进制形式报告浮点值。", "solution": "所提出的问题是有效的。这是控制理论中数值方法的一个明确定义的练习，基于微积分和线性代数的既定原理。任务是比较一个非线性系统的解析雅可比矩阵与其通过有限差分获得的数值估计。所有函数、参数和过程都已明确指定，从而可以得到唯一且可验证的解。\n\n状态空间模型由非线性向量值函数 $\\mathbf{f}: \\mathbb{R}^3 \\times \\mathbb{R}^2 \\to \\mathbb{R}^3$ 给出，使得 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x},\\mathbf{u})$。其分量为：\n$$\n\\begin{aligned}\nf_1(\\mathbf{x},\\mathbf{u}) = x_2 + 0.5 \\sin(x_1) + u_1 \\\\\nf_2(\\mathbf{x},\\mathbf{u}) = -0.8 \\sin(x_1) - 0.1 x_2^3 + u_2 \\\\\nf_3(\\mathbf{x},\\mathbf{u}) = -0.3 x_3 + 0.2 x_1^2 - 0.1 u_1^2 + 0.05 u_2^2\n\\end{aligned}\n$$\n求解过程包括四个主要步骤：计算工作点、推导解析雅可比矩阵、计算经验雅可比矩阵以及评估近似误差。\n\n第 1 步：计算工作点 $(\\mathbf{x}^\\star, \\mathbf{u}^\\star)$\n对于每个测试用例，我们都给定了 $x_1^\\star$ 和 $x_2^\\star$ 的名义值。为确保系统处于稳态，即 $\\mathbf{f}(\\mathbf{x}^\\star, \\mathbf{u}^\\star) = \\mathbf{0}$，通过将 $\\mathbf{f}$ 的每个分量设置为零来确定剩余的分量（$x_3^\\star, u_1^\\star, u_2^\\star$）。\n由 $f_1=0$ 得： $u_1^\\star = -x_2^\\star - 0.5 \\sin(x_1^\\star)$。\n由 $f_2=0$ 得： $u_2^\\star = 0.8 \\sin(x_1^\\star) + 0.1 (x_2^\\star)^3$。\n由 $f_3=0$ 得： $x_3^\\star = \\frac{1}{0.3} \\left( 0.2 (x_1^\\star)^2 - 0.1 (u_1^\\star)^2 + 0.05 (u_2^\\star)^2 \\right)$。\n这些公式用于为每个测试用例找到具体的工作点。\n\n第 2 步：解析雅可比矩阵 A 和 B\n解析雅可比矩阵 $A$ 和 $B$ 是通过分别对向量函数 $\\mathbf{f}$ 求关于状态向量 $\\mathbf{x}$ 和输入向量 $\\mathbf{u}$ 的偏导数得到的。然后，在工作点 $(\\mathbf{x}^\\star, \\mathbf{u}^\\star)$ 对这些导数进行求值。\n\n状态雅可比矩阵 $A$ 是一个 $3 \\times 3$ 矩阵：\n$$\nA = \\left.\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}\\right|_{(\\mathbf{x}^\\star,\\mathbf{u}^\\star)} = \\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial x_1}  \\frac{\\partial f_1}{\\partial x_2}  \\frac{\\partial f_1}{\\partial x_3} \\\\\n\\frac{\\partial f_2}{\\partial x_1}  \\frac{\\partial f_2}{\\partial x_2}  \\frac{\\partial f_2}{\\partial x_3} \\\\\n\\frac{\\partial f_3}{\\partial x_1}  \\frac{\\partial f_3}{\\partial x_2}  \\frac{\\partial f_3}{\\partial x_3}\n\\end{bmatrix}_{(\\mathbf{x}^\\star,\\mathbf{u}^\\star)}\n$$\n各个偏导数为：\n$\\frac{\\partial f_1}{\\partial x_1} = 0.5 \\cos(x_1)$，$\\frac{\\partial f_1}{\\partial x_2} = 1$，$\\frac{\\partial f_1}{\\partial x_3} = 0$。\n$\\frac{\\partial f_2}{\\partial x_1} = -0.8 \\cos(x_1)$，$\\frac{\\partial f_2}{\\partial x_2} = -0.3 x_2^2$，$\\frac{\\partial f_2}{\\partial x_3} = 0$。\n$\\frac{\\partial f_3}{\\partial x_1} = 0.4 x_1$，$\\frac{\\partial f_3}{\\partial x_2} = 0$，$\\frac{\\partial f_3}{\\partial x_3} = -0.3$。\n因此，在 $\\mathbf{x}^\\star$ 处求值：\n$$\nA = \\begin{bmatrix}\n0.5 \\cos(x_1^\\star)  1  0 \\\\\n-0.8 \\cos(x_1^\\star)  -0.3 (x_2^\\star)^2  0 \\\\\n0.4 x_1^\\star  0  -0.3\n\\end{bmatrix}\n$$\n输入雅可比矩阵 $B$ 是一个 $3 \\times 2$ 矩阵：\n$$\nB = \\left.\\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{u}}\\right|_{(\\mathbf{x}^\\star,\\mathbf{u}^\\star)} = \\begin{bmatrix}\n\\frac{\\partial f_1}{\\partial u_1}  \\frac{\\partial f_1}{\\partial u_2} \\\\\n\\frac{\\partial f_2}{\\partial u_1}  \\frac{\\partial f_2}{\\partial u_2} \\\\\n\\frac{\\partial f_3}{\\partial u_1}  \\frac{\\partial f_3}{\\partial u_2}\n\\end{bmatrix}_{(\\mathbf{x}^\\star,\\mathbf{u}^\\star)}\n$$\n各个偏导数为：\n$\\frac{\\partial f_1}{\\partial u_1} = 1$，$\\frac{\\partial f_1}{\\partial u_2} = 0$。\n$\\frac{\\partial f_2}{\\partial u_1} = 0$，$\\frac{\\partial f_2}{\\partial u_2} = 1$。\n$\\frac{\\partial f_3}{\\partial u_1} = -0.2 u_1$，$\\frac{\\partial f_3}{\\partial u_2} = 0.1 u_2$。\n因此，在 $\\mathbf{u}^\\star$ 处求值：\n$$\nB = \\begin{bmatrix}\n1  0 \\\\\n0  1 \\\\\n-0.2 u_1^\\star  0.1 u_2^\\star\n\\end{bmatrix}\n$$\n\n第 3 步：经验雅可比矩阵 $\\widehat{A}$ 和 $\\widehat{B}$\n经验雅可比矩阵使用中心有限差分法并以一个小的扰动量 $h$ 进行估计。$\\widehat{A}$ 的第 $i$ 列和 $\\widehat{B}$ 的第 $j$ 列的计算方式如下：\n$$\n\\widehat{A}_{:,i} = \\frac{\\mathbf{f}(\\mathbf{x}^\\star + h \\mathbf{e}_i, \\mathbf{u}^\\star) - \\mathbf{f}(\\mathbf{x}^\\star - h \\mathbf{e}_i, \\mathbf{u}^\\star)}{2h}\n$$\n$$\n\\widehat{B}_{:,j} = \\frac{\\mathbf{f}(\\mathbf{x}^\\star, \\mathbf{u}^\\star + h \\mathbf{e}_j) - \\mathbf{f}(\\mathbf{x}^\\star, \\mathbf{u}^\\star - h \\mathbf{e}_j)}{2h}\n$$\n其中 $\\mathbf{e}_i$ 表示在第 $i$ 个位置为 1，其他位置为零的标准基向量。对每一列重复此过程以构建完整的矩阵 $\\widehat{A}$ 和 $\\widehat{B}$。\n\n第 4 步：误差计算\n解析雅可比矩阵和经验雅可比矩阵之间的差异使用 Frobenius 范数来量化，对于一个矩阵 $M$，其定义为 $\\lVert M \\rVert_F = \\sqrt{\\sum_{i,j} |M_{ij}|^2}$。我们为每个测试用例计算两个误差度量：$\\lVert A - \\widehat{A} \\rVert_F$ 和 $\\lVert B - \\widehat{B} \\rVert_F$。\n\n对四个指定的测试用例中的每一个都以计算方式实现这些步骤，并将得到的八个误差范数汇总到一个输出列表中。中心差分法具有二阶精度，因此误差预计与 $h^2$ 成正比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares analytical and empirical Jacobians for a nonlinear system\n    at several operating points.\n    \"\"\"\n\n    # Define the nonlinear state-space function f(x, u)\n    def f(x, u):\n        \"\"\"\n        Computes the state derivatives for the given state and input vectors.\n        x: state vector [x1, x2, x3]\n        u: input vector [u1, u2]\n        \"\"\"\n        x1, x2, x3 = x\n        u1, u2 = u\n        f1 = x2 + 0.5 * np.sin(x1) + u1\n        f2 = -0.8 * np.sin(x1) - 0.1 * x2**3 + u2\n        f3 = -0.3 * x3 + 0.2 * x1**2 - 0.1 * u1**2 + 0.05 * u2**2\n        return np.array([f1, f2, f3])\n\n    # Define functions to compute the analytical Jacobians A and B\n    def compute_A_analytical(x_star):\n        \"\"\"Computes the analytical state Jacobian matrix A.\"\"\"\n        x1, x2, _ = x_star\n        A = np.zeros((3, 3))\n        A[0, 0] = 0.5 * np.cos(x1)\n        A[0, 1] = 1.0\n        A[1, 0] = -0.8 * np.cos(x1)\n        A[1, 1] = -0.3 * x2**2\n        A[2, 0] = 0.4 * x1\n        A[2, 2] = -0.3\n        return A\n\n    def compute_B_analytical(u_star):\n        \"\"\"Computes the analytical input Jacobian matrix B.\"\"\"\n        u1, u2 = u_star\n        B = np.zeros((3, 2))\n        B[0, 0] = 1.0\n        B[1, 1] = 1.0\n        B[2, 0] = -0.2 * u1\n        B[2, 1] = 0.1 * u2\n        return B\n\n    # Define functions to compute the empirical Jacobians A_hat and B_hat\n    def compute_A_empirical(f_func, x_star, u_star, h):\n        \"\"\"Computes the empirical state Jacobian matrix A_hat via central differences.\"\"\"\n        n_x = len(x_star)\n        A_hat = np.zeros((n_x, n_x))\n        for i in range(n_x):\n            e_i = np.zeros(n_x)\n            e_i[i] = 1.0\n            x_plus_h = x_star + h * e_i\n            x_minus_h = x_star - h * e_i\n            A_hat[:, i] = (f_func(x_plus_h, u_star) - f_func(x_minus_h, u_star)) / (2 * h)\n        return A_hat\n\n    def compute_B_empirical(f_func, x_star, u_star, h):\n        \"\"\"Computes the empirical input Jacobian matrix B_hat via central differences.\"\"\"\n        n_x, n_u = len(x_star), len(u_star)\n        B_hat = np.zeros((n_x, n_u))\n        for j in range(n_u):\n            e_j = np.zeros(n_u)\n            e_j[j] = 1.0\n            u_plus_h = u_star + h * e_j\n            u_minus_h = u_star - h * e_j\n            B_hat[:, j] = (f_func(x_star, u_plus_h) - f_func(x_star, u_minus_h)) / (2 * h)\n        return B_hat\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (x1_star, x2_star, h)\n        (0.0, 0.0, 1e-6),\n        (1.0, 0.5, 1e-6),\n        (2.5, -1.0, 1e-5),\n        (-1.2, 2.0, 1e-7),\n    ]\n\n    results = []\n    for case in test_cases:\n        x1_star_val, x2_star_val, h = case\n\n        # Step 1: Compute the full operating point (x_star, u_star)\n        u1_star = -x2_star_val - 0.5 * np.sin(x1_star_val)\n        u2_star = 0.8 * np.sin(x1_star_val) + 0.1 * x2_star_val**3\n        x3_star = (0.2 * x1_star_val**2 - 0.1 * u1_star**2 + 0.05 * u2_star**2) / 0.3\n        \n        x_star = np.array([x1_star_val, x2_star_val, x3_star])\n        u_star = np.array([u1_star, u2_star])\n\n        # Step 2: Compute analytical Jacobians\n        A = compute_A_analytical(x_star)\n        B = compute_B_analytical(u_star)\n\n        # Step 3: Compute empirical Jacobians\n        A_hat = compute_A_empirical(f, x_star, u_star, h)\n        B_hat = compute_B_empirical(f, x_star, u_star, h)\n\n        # Step 4: Compute Frobenius norms of the differences\n        err_A = np.linalg.norm(A - A_hat, 'fro')\n        err_B = np.linalg.norm(B - B_hat, 'fro')\n\n        results.extend([err_A, err_B])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2720568"}]}