{"hands_on_practices": [{"introduction": "归一化互质分解是 $\\mathcal{H}_\\infty$ 回路整形设计中描述不确定性和保证鲁棒稳定性的核心数学工具。这个练习将带你从第一性原理出发，为一个给定的稳定单输入单输出（SISO）系统推导其归一化左互质因子。通过完成这个计算，你将掌握谱分解这一基本代数技巧，并加深对 $\\mathcal{H}_\\infty$ 框架下如何表示和处理系统模型的理解。[@problem_id:2711277]", "problem": "考虑连续时间单输入单输出 (SISO) 的实有理、稳定、真传递函数 $G(s) = \\dfrac{s+1}{s+2}$。在 $\\mathcal{RH}_{\\infty}$（具有有限$\\mathcal{H}_\\infty$范数的实有理、真、内部稳定传递函数的集合）中，$G$ 的一个归一化左互质分解是一个对偶 $(\\tilde{M},\\tilde{N})$，其中 $\\tilde{M},\\tilde{N}\\in\\mathcal{RH}_{\\infty}$，使得 $G = \\tilde{M}^{-1}\\tilde{N}$ 且 $\\tilde{M}^{\\sim}\\tilde{M} + \\tilde{N}^{\\sim}\\tilde{N} = 1$。其中，对于 SISO 实有理函数，伴随对合定义为 $X^{\\sim}(s) \\equiv X(-s)$。请从第一性原理出发，推导并计算给定 $G(s)$ 的一个显式归一化左互质分解 $G = \\tilde{M}^{-1}\\tilde{N}$，并验证归一化条件成立。请以闭合形式的单行矩阵 $\\bigl(\\tilde{M}(s)\\ \\tilde{N}(s)\\bigr)$ 给出最终答案。无需四舍五入，不涉及单位。", "solution": "该问题经过审阅，被认定是有效的。在现代控制理论的既定框架内，这是一个适定问题，具体涉及稳定传递函数的归一化互质分解，这是 $\\mathcal{H}_{\\infty}$ 控制和鲁棒系统设计中的一个基本概念。所有提供的信息都是完整、一致且科学合理的。我们现在开始推导。\n\n该问题要求计算给定传递函数 $G(s) = \\dfrac{s+1}{s+2}$ 的归一化左互质分解。一对传递函数 $(\\tilde{M}(s), \\tilde{N}(s))$ 构成这样一个分解，如果它满足以下三个条件：\n1. 稳定性和真性：$\\tilde{M}, \\tilde{N} \\in \\mathcal{RH}_{\\infty}$，其中 $\\mathcal{RH}_{\\infty}$ 是实有理、真、稳定的传递函数的集合。\n2. 分解：$G(s) = \\tilde{M}(s)^{-1}\\tilde{N}(s)$，或等价地，$\\tilde{N}(s) = \\tilde{M}(s)G(s)$。\n3. 归一化：$\\tilde{M}^{\\sim}(s)\\tilde{M}(s) + \\tilde{N}^{\\sim}(s)\\tilde{N}(s) = 1$，其中伴随定义为 $X^{\\sim}(s) = X(-s)$。\n\n给定的对象 $G(s)$ 是稳定的，因为其唯一的极点位于 $s = -2$，在左开复半平面内。对于一个稳定的对象 $G(s)$，可以构造一个左互质分解为 $(\\tilde{M}, \\tilde{N}) = (U, UG)$，其中 $U$ 必须是 $\\mathcal{RH}_{\\infty}$ 中的一个所谓的*单位元*。单位元是一个函数 $U \\in \\mathcal{RH}_{\\infty}$，其逆 $U^{-1}$ 也属于 $\\mathcal{RH}_{\\infty}$。对于有理传递函数，这意味着 $U(s)$ 必须是稳定的、真的，并且在闭右半平面内没有零点（即，它必须是最小相位的）。\n\n我们将 $\\tilde{N}(s) = \\tilde{M}(s)G(s)$ 代入归一化条件。由于我们处理的是单输入单输出 (SISO) 系统，所有传递函数都是标量，因此它们的乘法是可交换的。\n$$ \\tilde{M}^{\\sim}\\tilde{M} + (\\tilde{M}G)^{\\sim}(\\tilde{M}G) = 1 $$\n$$ \\tilde{M}^{\\sim}\\tilde{M} + G^{\\sim}\\tilde{M}^{\\sim}G\\tilde{M} = 1 $$\n$$ \\tilde{M}^{\\sim}\\tilde{M} + G^{\\sim}G\\tilde{M}^{\\sim}\\tilde{M} = 1 $$\n$$ \\tilde{M}^{\\sim}\\tilde{M}(1 + G^{\\sim}G) = 1 $$\n由此，我们推导出乘积 $\\tilde{M}^{\\sim}\\tilde{M}$ 的表达式：\n$$ \\tilde{M}^{\\sim}(s)\\tilde{M}(s) = \\left(1 + G^{\\sim}(s)G(s)\\right)^{-1} $$\n现在我们来计算 $1 + G^{\\sim}(s)G(s)$ 这一项。给定 $G(s) = \\frac{s+1}{s+2}$，其伴随为 $G^{\\sim}(s) = G(-s) = \\frac{-s+1}{-s+2} = \\frac{1-s}{2-s}$。\n乘积 $G^{\\sim}(s)G(s)$ 为：\n$$ G^{\\sim}(s)G(s) = \\left(\\frac{1-s}{2-s}\\right)\\left(\\frac{s+1}{s+2}\\right) = \\frac{-(s-1)(s+1)}{-(s-2)(s+2)} = \\frac{s^2-1}{s^2-4} $$\n现在我们计算 $1 + G^{\\sim}(s)G(s)$：\n$$ 1 + G^{\\sim}(s)G(s) = 1 + \\frac{s^2-1}{s^2-4} = \\frac{(s^2-4) + (s^2-1)}{s^2-4} = \\frac{2s^2-5}{s^2-4} $$\n因此，关于 $\\tilde{M}(s)$ 的方程变为：\n$$ \\tilde{M}^{\\sim}(s)\\tilde{M}(s) = \\left(\\frac{2s^2-5}{s^2-4}\\right)^{-1} = \\frac{s^2-4}{2s^2-5} $$\n为了求出 $\\tilde{M}(s)$，我们必须对右侧进行谱分解。函数 $\\tilde{M}(s)$ 对应于我们初始公式中作为单位元 $U$ 的 $\\tilde{M}$。因此，$\\tilde{M}(s)$ 必须是稳定且最小相位的。首先，我们找出表达式 $\\frac{s^2-4}{2s^2-5}$ 的极点和零点：\n- 零点由 $s^2-4 = 0$ 给出，解得 $s = \\pm 2$。\n- 极点由 $2s^2-5 = 0$ 给出，解得 $s^2 = \\frac{5}{2}$，所以 $s = \\pm\\sqrt{\\frac{5}{2}}$。\n\n我们可以将表达式写为：\n$$ \\tilde{M}^{\\sim}(s)\\tilde{M}(s) = \\frac{(s-2)(s+2)}{2\\left(s-\\sqrt{\\frac{5}{2}}\\right)\\left(s+\\sqrt{\\frac{5}{2}}\\right)} $$\n为了使 $\\tilde{M}(s)$ 稳定，其极点必须在左开复半平面内。$\\tilde{M}^{\\sim}\\tilde{M}$ 的极点位于 $\\pm\\sqrt{\\frac{5}{2}}$。因此，稳定极点是 $s = -\\sqrt{\\frac{5}{2}}$，这必须是 $\\tilde{M}(s)$ 的极点。\n为了使 $\\tilde{M}(s)$ 是最小相位的，其零点必须在左开半平面内。$\\tilde{M}^{\\sim}\\tilde{M}$ 的零点位于 $\\pm 2$。左半平面的零点是 $s = -2$，这必须是 $\\tilde{M}(s)$ 的零点。\n\n基于此，$\\tilde{M}(s)$ 的结构必须是 $c \\frac{s+2}{s+\\sqrt{5/2}}$，其中 $c$ 是某个常数。为了确定 $c$，我们可以计算当 $s \\to \\infty$ 时的极限：\n$$ \\lim_{s\\to\\infty} \\tilde{M}^{\\sim}(s)\\tilde{M}(s) = \\lim_{s\\to\\infty} \\frac{s^2-4}{2s^2-5} = \\frac{1}{2} $$\n对于我们选择的 $\\tilde{M}(s)$ 形式：\n$$ \\lim_{s\\to\\infty} \\left(c \\frac{-s+2}{-s+\\sqrt{5/2}}\\right)\\left(c \\frac{s+2}{s+\\sqrt{5/2}}\\right) = \\lim_{s\\to\\infty} c^2 \\left(\\frac{s-2}{s-\\sqrt{5/2}}\\right)\\left(\\frac{s+2}{s+\\sqrt{5/2}}\\right) = c^2 $$\n令两者相等得到 $c^2 = \\frac{1}{2}$，这意味着 $c = \\frac{1}{\\sqrt{2}}$。按照惯例，我们选择正实根。\n因此，我们找到了 $\\tilde{M}(s)$：\n$$ \\tilde{M}(s) = \\frac{1}{\\sqrt{2}} \\frac{s+2}{s+\\sqrt{\\frac{5}{2}}} = \\frac{s+2}{\\sqrt{2}s+\\sqrt{5}} $$\n现在我们使用关系式 $\\tilde{N}(s) = \\tilde{M}(s)G(s)$ 来求 $\\tilde{N}(s)$：\n$$ \\tilde{N}(s) = \\left(\\frac{s+2}{\\sqrt{2}s+\\sqrt{5}}\\right) \\left(\\frac{s+1}{s+2}\\right) $$\n项 $(s+2)$ 消掉了，得到：\n$$ \\tilde{N}(s) = \\frac{s+1}{\\sqrt{2}s+\\sqrt{5}} $$\n我们必须验证这对 $(\\tilde{M}, \\tilde{N})$ 满足所有条件。\n1.  $\\tilde{M}(s) = \\frac{s+2}{\\sqrt{2}s+\\sqrt{5}}$ 和 $\\tilde{N}(s) = \\frac{s+1}{\\sqrt{2}s+\\sqrt{5}}$ 都在 $s = -\\frac{\\sqrt{5}}{\\sqrt{2}} = -\\sqrt{\\frac{5}{2}}$ 处有一个单极点，该极点在左半平面内。两者都是真的（分子阶数等于分母阶数）。因此，$\\tilde{M}, \\tilde{N} \\in \\mathcal{RH}_{\\infty}$。\n2.  分解 $G=\\tilde{M}^{-1}\\tilde{N}$ 根据构造是成立的。\n3.  互质条件是满足的，因为 $\\tilde{M}(s)$ 和 $\\tilde{N}(s)$ 在闭右半平面内没有公共零点。$\\tilde{M}(s)$ 的零点在 $s=-2$，$\\tilde{N}(s)$ 的零点在 $s=-1$。没有公共零点。\n4.  归一化条件 $\\tilde{M}^{\\sim}\\tilde{M} + \\tilde{N}^{\\sim}\\tilde{N} = 1$ 由我们最初的谱分解保证。\n\n最终结果是传递函数对偶 $(\\tilde{M}(s), \\tilde{N}(s))$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{s+2}{\\sqrt{2}s+\\sqrt{5}} & \\frac{s+1}{\\sqrt{2}s+\\sqrt{5}} \\end{pmatrix}}\n$$", "id": "2711277"}, {"introduction": "在确定了回路整形的目标后，一个关键问题是：对于给定的性能水平 $\\gamma$，是否存在一个控制器能同时稳定系统并满足性能要求？$\\mathcal{H}_\\infty$ 理论将此问题转化为一个可计算的条件，即检验两个代数Riccati方程（AREs）是否存在稳定解以及这些解是否满足一个耦合条件。这个编程练习将引导你使用标准的数值计算工具来实现这一关键的可行性检验，让你亲手验证理论与实践的连接。[@problem_id:2711244]", "problem": "给定一个严格真（strictly proper）、稳定、单输入单输出的线性时不变系统，其状态空间实现由以下矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$、$B \\in \\mathbb{R}^{2 \\times 1}$、$C \\in \\mathbb{R}^{1 \\times 2}$ 和 $D \\in \\mathbb{R}^{1 \\times 1}$ 指定：\n$$\nA = \\begin{bmatrix}0 & 1\\\\ -2 & -3\\end{bmatrix},\\quad\nB = \\begin{bmatrix}0\\\\ 1\\end{bmatrix},\\quad\nC = \\begin{bmatrix}1 & 0\\end{bmatrix},\\quad\nD = 0.\n$$\n在$\\mathcal{H}_{\\infty}$回路成形设计的背景下，一个关键的可行性条件涉及一对连续时间代数Riccati方程（AREs）的镇定解的存在性以及一个谱半径不等式。本问题的基本依据是：\n- 连续时间代数Riccati方程（ARE），对于 $A \\in \\mathbb{R}^{n \\times n}$、$B \\in \\mathbb{R}^{n \\times m}$、$Q = Q^{\\top} \\in \\mathbb{R}^{n \\times n}$ 和 $R = R^{\\top} \\in \\mathbb{R}^{m \\times m}$ 且 $R \\succ 0$，定义为矩阵方程\n$$\nA^{\\top} X + X A - X B R^{-1} B^{\\top} X + Q = 0,\n$$\n其镇定解 $X = X^{\\top} \\succeq 0$ 是唯一的解，使得闭环矩阵 $A - B R^{-1} B^{\\top} X$ 是Hurwitz矩阵。\n- 方阵 $M$ 的谱半径 $\\rho(M)$ 定义为 $M$ 的特征值中模长的最大值。\n\n对于给定的 $\\gamma \\in \\mathbb{R}_{>0}$，定义需要求解的两个CAREs，其解为 $X = X^{\\top} \\in \\mathbb{R}^{2 \\times 2}$ 和 $Y = Y^{\\top} \\in \\mathbb{R}^{2 \\times 2}$：\n1. $X$方程\n$$\nA^{\\top} X + X A - X B \\left(\\gamma^{2} I_{1}\\right)^{-1} B^{\\top} X + C^{\\top} C = 0,\n$$\n其为标准形式，其中 $Q_{X} = C^{\\top} C$ 和 $R_{X} = \\gamma^{2} I_{1}$。\n2. $Y$方程\n$$\nA Y + Y A^{\\top} - Y C^{\\top} \\left(\\gamma^{2} I_{1}\\right)^{-1} C Y + B B^{\\top} = 0,\n$$\n该方程可以通过将标准ARE应用于对偶数据 $(A^{\\top}, C^{\\top}, Q_{Y} = B B^{\\top}, R_{Y} = \\gamma^{2} I_{1})$ 来计算。\n\n对于每个测试的 $\\gamma$，计算镇定解 $X$ 和 $Y$，然后评估谱半径不等式\n$$\n\\rho\\!\\left(X Y\\right) < \\gamma^{2}.\n$$\n您必须使用与上述定义一致的标准连续时间代数Riccati方程求解器来实现计算，并利用 $X Y$ 的特征值来计算谱半径。\n\n测试集：\n- 使用以下 $\\gamma$ 值列表：$[\\;0.25,\\; 0.35,\\; 0.60,\\; 1.00,\\; 3.00\\;]$。\n- 对于此列表中的每个 $\\gamma$，生成一个布尔值，指示不等式 $\\rho(XY) < \\gamma^{2}$ 对于计算出的Riccati镇定解是否成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。例如，如果有五个布尔值，输出格式必须严格为 $[\\text{True},\\text{False},\\text{True},\\text{True},\\text{False}]$ 形式，不含空格。\n- 本问题不涉及物理单位。\n- 所有角度（如有）均与本问题无关。\n\n您的实现必须是一个完整的、可运行的程序，执行计算并为指定的测试集打印所需的单行输出。", "solution": "问题陈述是有效的。它提出了一个来自$\\mathcal{H}_{\\infty}$控制理论领域、适定且具有科学依据的问题。任务是为一个给定的线性时不变（LTI）系统和一组性能水平$\\gamma$，验证一个次优$\\mathcal{H}_{\\infty}$控制器存在的基本可行性条件。所有必要的数据和定义都已提供，没有矛盾或含糊之处。\n\n系统由以下状态空间矩阵定义：\n$$\nA = \\begin{bmatrix}0 & 1\\\\ -2 & -3\\end{bmatrix},\\quad\nB = \\begin{bmatrix}0\\\\ 1\\end{bmatrix},\\quad\nC = \\begin{bmatrix}1 & 0\\end{bmatrix},\\quad\nD = 0.\n$$\n$A$矩阵的特征值是特征方程 $\\det(A - \\lambda I) = \\lambda^2 + 3\\lambda + 2 = 0$ 的根，即 $\\lambda_1 = -1$ 和 $\\lambda_2 = -2$。由于两个特征值都具有负实部，因此开环系统是稳定的，如题所述。此外，该系统是能控和能观的，这些是确保相关代数Riccati方程（AREs）的镇定解存在且唯一的标准假设。\n\n问题的核心在于分析两个连续时间代数Riccati方程（CAREs）以及对每个指定的正标量 $\\gamma$ 的一个耦合条件。\n\n第一个CARE，$X$方程：\n该方程由下式给出：\n$$\nA^{\\top} X + X A - X B (\\gamma^2 I_1)^{-1} B^{\\top} X + C^{\\top} C = 0\n$$\n为使用计算 $A^{\\top} P + P A - P B R^{-1} B^{\\top} P + Q = 0$ 的镇定解的标准数值程序来求解该方程，我们识别出相应的矩阵。在此背景下，系统矩阵是 $A$，输入矩阵是 $B$，状态加权矩阵是 $Q_X = C^{\\top} C$，控制加权矩阵是 $R_X = \\gamma^2 I_1$。数值上，我们有：\n$$\nQ_X = C^{\\top} C = \\begin{bmatrix}1\\\\ 0\\end{bmatrix} \\begin{bmatrix}1 & 0\\end{bmatrix} = \\begin{bmatrix}1 & 0\\\\ 0 & 0\\end{bmatrix}\n$$\n$$\nR_X = \\gamma^2\n$$\n对于测试集中的每个 $\\gamma$，我们必须找到唯一的对称半正定解 $X$，使得闭环矩阵 $A_{cl,X} = A - B R_X^{-1} B^{\\top} X = A - \\frac{1}{\\gamma^2} B B^{\\top} X$ 是Hurwitz矩阵（即，其所有特征值都位于复平面的左半开平面）。\n\n第二个CARE，$Y$方程：\n该方程由下式给出：\n$$\nA Y + Y A^{\\top} - Y C^{\\top} (\\gamma^2 I_1)^{-1} C Y + B B^{\\top} = 0\n$$\n这通常被称为“对偶”Riccati方程。为了使用相同的标准求解器来求解它，我们可以转置方程并重新排列各项以匹配标准形式。该方程等价于：\n$$\n(A^{\\top})^{\\top} Y + Y A^{\\top} - Y C^{\\top} (\\gamma^2 I_1)^{-1} (C^{\\top})^{\\top} Y + B B^{\\top} = 0\n$$\n这种结构对应于一个对偶系统的CARE。我们为标准求解器识别出的矩阵是：系统矩阵 $A_d = A^{\\top}$，输入矩阵 $B_d = C^{\\top}$，状态加权矩阵 $Q_Y = B B^{\\top}$，以及控制加权矩阵 $R_Y = \\gamma^2 I_1$。数值上，我们有：\n$$\nQ_Y = B B^{\\top} = \\begin{bmatrix}0\\\\ 1\\end{bmatrix} \\begin{bmatrix}0 & 1\\end{bmatrix} = \\begin{bmatrix}0 & 0\\\\ 0 & 1\\end{bmatrix}\n$$\n$$\nR_Y = \\gamma^2\n$$\n对于每个 $\\gamma$，我们找到唯一的对称半正定解 $Y$，使得矩阵 $A_{cl,Y} = A_d - B_d R_Y^{-1} B_d^{\\top} Y = A^{\\top} - \\frac{1}{\\gamma^2} C^{\\top} C Y$ 是Hurwitz矩阵。\n\n谱半径条件：\n对于给定的 $\\gamma$，在找到镇定解 $X \\succeq 0$ 和 $Y \\succeq 0$ 之后，存在一个阶数为 $n$ 且能达到性能水平 $\\gamma$ 的 $\\mathcal{H}_{\\infty}$ 控制器的充要条件是谱半径不等式：\n$$\n\\rho(XY) < \\gamma^2\n$$\n这里，$\\rho(M)$ 表示矩阵 $M$ 的谱半径，定义为其特征值绝对值的最大值。如果对于给定的 $\\gamma$，任一CARE的镇定半正定解不存在，则条件不满足，结论为“假”(false)。在这种情况下，数值求解器通常会引发错误。\n\n因此，计算过程如下：\n对于测试集 $[\\;0.25,\\; 0.35,\\; 0.60,\\; 1.00,\\; 3.00\\;]$ 中的每个 $\\gamma$ 值：\n1. 定义矩阵 $A$、$B$、$C$。\n2. 为$X$方程定义CARE参数：$A_X=A$，$B_X=B$，$Q_X=C^{\\top}C$，$R_X=\\gamma^2$。\n3. 尝试求解镇定解 $X$。如果求解器失败，则此 $\\gamma$ 的条件为假。\n4. 为$Y$方程定义CARE参数：$A_Y=A^{\\top}$，$B_Y=C^{\\top}$，$Q_Y=B B^{\\top}$，$R_Y=\\gamma^2$。\n5. 尝试求解镇定解 $Y$。如果求解器失败，则此 $\\gamma$ 的条件为假。\n6. 如果解 $X$ 和 $Y$ 都成功计算，则计算矩阵乘积 $M = XY$。\n7. 计算 $M$ 的特征值。\n8. 计算谱半径 $\\rho(M)$，即这些特征值模长的最大值。\n9. 评估布尔表达式 $\\rho(M) < \\gamma^2$ 并记录结果。\n\n将执行此程序以生成最终的布尔结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_continuous_are\n\ndef solve():\n    \"\"\"\n    Computes H-infinity feasibility condition for a given LTI system and a suite of gamma values.\n    \"\"\"\n    # Define the state-space matrices of the LTI system from the problem statement.\n    A = np.array([[0., 1.], [-2., -3.]])\n    B = np.array([[0.], [1.]])\n    C = np.array([[1., 0.]])\n    \n    # Test suite of gamma values.\n    test_cases = [0.25, 0.35, 0.60, 1.00, 3.00]\n    \n    results = []\n    \n    for gamma in test_cases:\n        gamma_sq = gamma**2\n        \n        # --- Solve the X-Riccati Equation ---\n        # A'X + XA - X B R^{-1} B'X + Q = 0\n        # For the X-equation, Qx = C'C, Rx = gamma^2 * I\n        Qx = C.T @ C\n        Rx = np.array([[gamma_sq]])\n        \n        try:\n            X = solve_continuous_are(A, B, Qx, Rx)\n        except np.linalg.LinAlgError:\n            # If a stabilizing solution does not exist, the condition fails.\n            results.append(False)\n            continue\n\n        # --- Solve the Y-Riccati Equation ---\n        # AY + YA' - Y C' R^{-1} C Y + B B' = 0\n        # This is a dual ARE, solved by applying the standard solver to the dual system.\n        # Ad'Y + YAd - Y Bd Rd^{-1} Bd'Y + Qd = 0\n        # where Ad = A', Bd = C', Qd = B B', Rd = gamma^2 * I\n        Ad = A.T\n        Bd = C.T\n        Qy = B @ B.T\n        Ry = np.array([[gamma_sq]])\n        \n        try:\n            Y = solve_continuous_are(Ad, Bd, Qy, Ry)\n        except np.linalg.LinAlgError:\n            # If a stabilizing solution does not exist, the condition fails.\n            results.append(False)\n            continue\n            \n        # --- Check the Spectral Radius Condition ---\n        # rho(XY) < gamma^2\n        XY = X @ Y\n        \n        # Compute eigenvalues of the product matrix XY\n        eigenvalues = np.linalg.eigvals(XY)\n        \n        # Compute the spectral radius (max of absolute values of eigenvalues)\n        rho = np.max(np.abs(eigenvalues))\n        \n        # Evaluate the inequality\n        is_condition_met = rho < gamma_sq\n        results.append(is_condition_met)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2711244"}, {"introduction": "“回路整形”的精髓在于使用加权函数 $W_1(s)$ 和 $W_2(s)$ 来“塑造”开环系统的奇异值，从而在不同频段实现性能和鲁棒性之间的权衡。本练习为你提供了一个多输入多输出（MIMO）系统的实际案例，要求你通过编程来量化和分析回路整形的效果。通过计算和比较整形前后的关键性能指标，你将直观地看到设计选择（即加权函数）如何转化为系统性能（如低频增益）和鲁棒性（如稳定裕度）的改变。[@problem_id:2711299]", "problem": "考虑一个具有两个输入和两个输出的连续时间、线性时不变、严格真分、稳定的多输入多输出对象。该对象的传递矩阵由下式给出\n$$\nG(s) \\;=\\; \\begin{bmatrix}\n\\dfrac{1}{s + 1} & \\dfrac{0.5}{s + 2} \\\\\n\\dfrac{-0.3}{s + 3} & \\dfrac{1.5}{s + 1}\n\\end{bmatrix}.\n$$\n对于每个角频率 $\\,\\omega \\in \\mathbb{R}_{\\ge 0}\\,$（单位为弧度/秒），定义开环传递矩阵为 $\\,L(j\\omega) = G(j\\omega)\\,$。为进行整形，考虑稳定的最小相位对角前置和后置补偿器 $\\,W_1(s)\\in\\mathbb{C}^{2\\times 2}\\,$ 和 $\\,W_2(s)\\in\\mathbb{C}^{2\\times 2}\\,$，并定义整形后的开环传递矩阵\n$$\nL_s(j\\omega) \\;=\\; W_2(j\\omega)\\,G(j\\omega)\\,W_1(j\\omega).\n$$\n对于任意复方阵 $\\,M\\,$，令 $\\,\\bar{\\sigma}(M)\\,$ 表示其最大奇异值，$\\,\\underline{\\sigma}(M)\\,$ 表示其最小奇异值。定义灵敏度矩阵 $\\,S(j\\omega) = \\big(I + L(j\\omega)\\big)^{-1}\\,$ 和互补灵敏度矩阵 $\\,T(j\\omega) = L(j\\omega)\\big(I + L(j\\omega)\\big)^{-1}\\,$，并类似地定义 $\\,S_s(j\\omega)\\,$ 和 $\\,T_s(j\\omega)\\,$，其中 $\\,L\\,$ 被替换为 $\\,L_s\\,$。在 $\\mathcal{H}_{\\infty}$回路整形设计的背景下，我们关注以下频域标量：\n- 低频回路增益代理指标：$\\,g_{\\mathrm{low}} = \\bar{\\sigma}\\big(L(j\\omega_{\\min})\\big)\\,$ 和 $\\,g_{\\mathrm{low},s} = \\bar{\\sigma}\\big(L_s(j\\omega_{\\min})\\big)\\,$，其中 $\\,\\omega_{\\min}\\,$ 是最小的频率采样点。\n- 返回差裕度代理指标：$\\,m_{\\mathrm{rd}} = \\displaystyle \\min_{\\omega\\in\\Omega}\\,\\underline{\\sigma}\\big(I + L(j\\omega)\\big)\\,$ 和 $\\,m_{\\mathrm{rd},s} = \\displaystyle \\min_{\\omega\\in\\Omega}\\,\\underline{\\sigma}\\big(I + L_s(j\\omega)\\big)\\,$。\n- 互补灵敏度峰值：$\\,\\|T\\|_{\\infty,\\mathrm{grid}} = \\displaystyle \\max_{\\omega\\in\\Omega}\\,\\bar{\\sigma}\\big(T(j\\omega)\\big)\\,$ 和 $\\,\\|T_s\\|_{\\infty,\\mathrm{grid}} = \\displaystyle \\max_{\\omega\\in\\Omega}\\,\\bar{\\sigma}\\big(T_s(j\\omega)\\big)\\,$，在一个有限频率网格 $\\,\\Omega\\,$ 上进行评估。\n\n您的任务是使用以下规范，计算并比较对象 $\\,G(s)\\,$ 在整形前后的这些量。\n\n需要使用的基本定义：\n- 频率响应评估：对于任意真有理传递函数 $\\,H(s) = \\dfrac{b_0 s^n + b_1 s^{n-1} + \\cdots + b_n}{a_0 s^m + a_1 s^{m-1} + \\cdots + a_m}\\,$ 且 $\\,m \\ge n\\,$，在 $\\,j\\omega\\,$ 处的频率响应通过复数求值得到 $\\,H(j\\omega) = \\dfrac{b_0 (j\\omega)^n + \\cdots + b_n}{a_0 (j\\omega)^m + \\cdots + a_m}\\,$。\n- 奇异值：对于任意复矩阵 $\\,M\\,$，奇异值是 $\\,M^* M\\,$ 的特征值的非负平方根。\n- 灵敏度和互补灵敏度：$\\,S(j\\omega) = \\big(I + L(j\\omega)\\big)^{-1}\\,$ 和 $\\,T(j\\omega) = L(j\\omega)\\big(I + L(j\\omega)\\big)^{-1}\\,$。\n\n频率网格：\n- 使用一个对数间隔的网格 $\\,\\Omega\\,$，包含从 $\\,\\omega_{\\min} = 10^{-2}\\,$ 到 $\\,\\omega_{\\max} = 10^{3}\\,$ 弧度/秒的 $\\,N = 400\\,$ 个点。\n\n测试套件：\n对于每个测试用例，为未整形回路 $\\,L(j\\omega)\\,$ 和整形回路 $\\,L_s(j\\omega)\\,$ 计算以下标量：\n- $\\,g_{\\mathrm{low}}\\,$, $\\,g_{\\mathrm{low},s}\\,$,\n- $\\,m_{\\mathrm{rd}}\\,$, $\\,m_{\\mathrm{rd},s}\\,$,\n- $\\,\\|T\\|_{\\infty,\\mathrm{grid}}\\,$, $\\,\\|T_s\\|_{\\infty,\\mathrm{grid}}\\,$.\n\n然后评估：\n- 性能改善布尔值 $\\,b_{\\mathrm{perf}} = 1\\,$ 如果 $\\,g_{\\mathrm{low},s} > g_{\\mathrm{low}}\\,$，否则为 $\\,0\\,$。\n- 鲁棒性改善布尔值 $\\,b_{\\mathrm{rob}} = 1\\,$ 如果 $\\,m_{\\mathrm{rd},s} > m_{\\mathrm{rd}}\\,$ 并且 $\\,\\|T_s\\|_{\\infty,\\mathrm{grid}} < \\|T\\|_{\\infty,\\mathrm{grid}}\\,$，否则为 $\\,0\\,$。\n\n对 $\\,W_1(s)\\,$ 和 $\\,W_2(s)\\,$ 使用以下三种整形配置：\n- 测试用例 $1$：\n  - $\\,W_1(s) = \\mathrm{diag}\\!\\left(\\dfrac{50}{s + 5},\\,\\dfrac{40}{s + 5}\\right)\\,$,\n  - $\\,W_2(s) = \\mathrm{diag}\\!\\left(\\dfrac{20}{s + 20},\\,\\dfrac{30}{s + 30}\\right)\\,$.\n- 测试用例 $2$：\n  - $\\,W_1(s) = \\mathrm{diag}\\!\\left(\\dfrac{100}{s + 5},\\,\\dfrac{75}{s + 5}\\right)\\,$,\n  - $\\,W_2(s) = \\mathrm{diag}\\!\\left(\\dfrac{10}{s + 10},\\,\\dfrac{15}{s + 15}\\right)\\,$.\n- 测试用例 $3$：\n  - $\\,W_1(s) = \\mathrm{diag}\\!\\left(1,\\,1\\right)\\,$,\n  - $\\,W_2(s) = \\mathrm{diag}\\!\\left(1,\\,1\\right)\\,$.\n\n数值与输出要求：\n- 所有频域量必须使用上面指定的频率网格 $\\,\\Omega\\,$ (单位为弧度/秒) 进行计算。\n- 对于每个测试用例，生成列表\n$$\n\\Big[ g_{\\mathrm{low}},\\, g_{\\mathrm{low},s},\\, m_{\\mathrm{rd}},\\, m_{\\mathrm{rd},s},\\, \\|T\\|_{\\infty,\\mathrm{grid}},\\, \\|T_s\\|_{\\infty,\\mathrm{grid}},\\, b_{\\mathrm{perf}},\\, b_{\\mathrm{rob}} \\Big],\n$$\n其中浮点数结果必须四舍五入到三位小数。布尔值必须以整数 $\\,0\\,$ 或 $\\,1\\,$ 的形式报告。最终程序输出必须是单行，包含一个由这三个列表组成的列表，用逗号分隔，并由一对单独的方括号括起来，没有任何额外的空格或文本，例如\n`[ [...], [...], [...] ]`。", "solution": "所提出的问题是有效的。它是在多输入多输出 (MIMO) 控制理论领域中一个适定且有科学依据的问题。所有必要的数据、模型和度量定义都已提供，并且没有内部矛盾或逻辑缺陷。任务是在应用回路整形前后对控制系统的特性进行数值分析，这是鲁棒控制系统设计中的一个标准程序。我们将给出一个完整、合理的解决方案。\n\n任务的核心是通过比较频域性能和鲁棒性指标，来评估回路整形对给定线性时不变 (LTI) 对象 $G(s)$ 的影响。分析是在一个指定的频率网格 $\\Omega$ 上进行的。对于三个测试用例中的每一个，所使用的方法包括以下步骤。\n\n首先，我们建立频域背景。分析基于系统的频率响应，这是通过在一系列角频率 $\\omega$ 上评估系统的传递函数矩阵在 $s = j\\omega$ 处的值来获得的。指定的频率网格 $\\Omega$ 由从 $\\omega_{\\min} = 10^{-2}$ 到 $\\omega_{\\max} = 10^{3}$ 弧度/秒的 $N=400$ 个对数间隔的点组成。选择对数尺度是标准做法，因为它允许在数个频率十倍程上详细检查系统行为，从而捕捉低频（性能）和高频（鲁棒性、噪声敏感性）现象。\n\n对于每个频率 $\\omega \\in \\Omega$，我们计算复值传递矩阵。未整形的开环系统由 $L(j\\omega) = G(j\\omega)$ 给出，其中对象为\n$$\nG(s) = \\begin{bmatrix} \\dfrac{1}{s + 1} & \\dfrac{0.5}{s + 2} \\\\ \\dfrac{-0.3}{s + 3} & \\dfrac{1.5}{s + 1} \\end{bmatrix}.\n$$\n回路整形是通过稳定的最小相位对角前置补偿器 $W_1(s)$ 和后置补偿器 $W_2(s)$ 引入的。它们对开环奇异值进行整形，以实现期望的性能和鲁棒性特性。整形后的开环系统则为 $L_s(j\\omega) = W_2(j\\omega)G(j\\omega)W_1(j\\omega)$。该分析比较了从 $L(j\\omega)$ 和从 $L_s(j\\omega)$ 导出的特性。\n\n评估系统的关键量来源于奇异值分解 (SVD)。对于由矩阵 $M$ 表示的 MIMO 系统，最大奇异值 $\\bar{\\sigma}(M)$ 和最小奇异值 $\\underline{\\sigma}(M)$ 提供了系统在所有输入方向上的最大和最小“增益”的度量。\n\n计算以下指标：\n$1$. 低频性能代理指标：指标 $g_{\\mathrm{low}} = \\bar{\\sigma}\\big(L(j\\omega_{\\min})\\big)$ 近似于系统的直流增益。低频时的高开环增益对于良好的指令跟随和低频扰动抑制至关重要。整形旨在增加此增益，因此当 $g_{\\mathrm{low},s} = \\bar{\\sigma}\\big(L_s(j\\omega_{\\min})\\big) > g_{\\mathrm{low}}$ 时表明有改善。此条件决定了布尔标志 $b_{\\mathrm{perf}}$。\n\n$2$. 鲁棒性指标：对不确定性的鲁棒性通过两个主要量进行评估。\n   - 返回差裕度代理指标 $m_{\\mathrm{rd}} = \\min_{\\omega\\in\\Omega}\\,\\underline{\\sigma}\\big(I + L(j\\omega)\\big)$ 与稳定性裕度相关。较大的 $m_{\\mathrm{rd}}$ 值意味着针对对象输入端的非结构化乘性不确定性具有更大的稳定性裕度。\n   - 互补灵敏度峰值 $\\|T\\|_{\\infty,\\mathrm{grid}} = \\max_{\\omega\\in\\Omega}\\,\\bar{\\sigma}\\big(T(j\\omega)\\big)$。矩阵 $T(j\\omega) = L(j\\omega)\\big(I + L(j\\omega)\\big)^{-1}$ 是互补灵敏度函数，表示从参考到输出的闭环传递函数。其最大奇异值出现大峰值表明阻尼差且对建模误差敏感。\n   - 如果整形后的系统表现出更大的稳定性裕度 ($m_{\\mathrm{rd},s} > m_{\\mathrm{rd}}$) 和更小的灵敏度峰值 ($\\|T_s\\|_{\\infty,\\mathrm{grid}} < \\|T\\|_{\\infty,\\mathrm{grid}}$)，则实现了鲁棒性的同时改善。这个联合条件决定了布尔标志 $b_{\\mathrm{rob}}$。\n\n算法流程如下。对于三个测试用例中的每一个，我们遍历网格 $\\Omega$ 中的每个频率 $\\omega_k$。在每个频率点，我们：\n- 计算复矩阵 $G(j\\omega_k)$、$W_1(j\\omega_k)$ 和 $W_2(j\\omega_k)$。\n- 构建未整形回路 $L_k = G(j\\omega_k)$ 和整形回路 $L_{s,k} = W_2(j\\omega_k)G(j\\omega_k)W_1(j\\omega_k)$。\n- 计算互补灵敏度矩阵 $T_k$ 和 $T_{s,k}$。这是通过求解数值稳定的线性系统 $(I+L_k)T_k = L_k$ 和 $(I+L_{s,k})T_{s,k} = L_{s,k}$ 来完成的，而不是通过显式矩阵求逆。\n- 使用标准 SVD 算法计算 $L_k、L_{s,k}、(I+L_k)、(I+L_{s,k})、T_k$ 和 $T_{s,k}$ 的奇异值。\n- 根据指标定义存储最大和最小奇异值。\n\n频率扫描完成后，使用存储的奇异值数组计算最终指标。低频增益 ($g_{\\mathrm{low}}, g_{\\mathrm{low},s}$) 取自第一个频率点 $\\omega_{\\min}$。鲁棒性裕度 ($m_{\\mathrm{rd}}, m_{\\mathrm{rd},s}$) 和灵敏度峰值 ($\\|T\\|_{\\infty,\\mathrm{grid}}, \\|T_s\\|_{\\infty,\\mathrm{grid}}$) 分别通过在整个频率网格上取最小值或最大值找到。最后，根据指定的条件评估布尔标志 $b_{\\mathrm{perf}}$ 和 $b_{\\mathrm{rob}}$。然后对每个测试用例得到的八个值进行格式化并呈现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the H-infinity loop shaping analysis problem for three test cases.\n    \"\"\"\n    # 1. Setup\n    N = 400\n    omega_min = 1e-2\n    omega_max = 1e3\n    omega_grid = np.logspace(np.log10(omega_min), np.log10(omega_max), N)\n    \n    # Define Plant G(s)\n    def G_func(s: complex) -> np.ndarray:\n        \"\"\"Evaluates the plant transfer matrix G(s) at a given complex frequency s.\"\"\"\n        return np.array([\n            [1.0 / (s + 1.0), 0.5 / (s + 2.0)],\n            [-0.3 / (s + 3.0), 1.5 / (s + 1.0)]\n        ], dtype=complex)\n\n    # Define Test Cases for Compensators W1(s), W2(s)\n    test_cases = [\n        {  # Case 1\n            \"W1\": lambda s: np.diag([50.0 / (s + 5.0), 40.0 / (s + 5.0)]),\n            \"W2\": lambda s: np.diag([20.0 / (s + 20.0), 30.0 / (s + 30.0)])\n        },\n        {  # Case 2\n            \"W1\": lambda s: np.diag([100.0 / (s + 5.0), 75.0 / (s + 5.0)]),\n            \"W2\": lambda s: np.diag([10.0 / (s + 10.0), 15.0 / (s + 15.0)])\n        },\n        {  # Case 3\n            \"W1\": lambda s: np.eye(2, dtype=complex),\n            \"W2\": lambda s: np.eye(2, dtype=complex)\n        }\n    ]\n\n    all_results = []\n    I = np.eye(2, dtype=complex)\n\n    # 2. Main Loop over test cases\n    for case_spec in test_cases:\n        W1_func = case_spec[\"W1\"]\n        W2_func = case_spec[\"W2\"]\n\n        # Storage for frequency-dependent singular values\n        sigma_bar_L_list = np.zeros(N)\n        sigma_bar_Ls_list = np.zeros(N)\n        sigma_under_I_L_list = np.zeros(N)\n        sigma_under_I_Ls_list = np.zeros(N)\n        sigma_bar_T_list = np.zeros(N)\n        sigma_bar_Ts_list = np.zeros(N)\n\n        # 3. Frequency Sweep\n        for i, omega in enumerate(omega_grid):\n            s = 1j * omega\n            \n            # Evaluate matrices at s=j*omega\n            Gm = G_func(s)\n            W1m = W1_func(s)\n            W2m = W2_func(s)\n\n            # Unshaped loop calculations\n            L = Gm\n            I_plus_L = I + L\n            T = np.linalg.solve(I_plus_L, L)\n\n            # Shaped loop calculations\n            Ls = W2m @ Gm @ W1m\n            I_plus_Ls = I + Ls\n            Ts = np.linalg.solve(I_plus_Ls, Ls)\n\n            # Singular value computations\n            sv_L = np.linalg.svd(L, compute_uv=False)\n            sv_Ls = np.linalg.svd(Ls, compute_uv=False)\n            sv_I_L = np.linalg.svd(I_plus_L, compute_uv=False)\n            sv_I_Ls = np.linalg.svd(I_plus_Ls, compute_uv=False)\n            sv_T = np.linalg.svd(T, compute_uv=False)\n            sv_Ts = np.linalg.svd(Ts, compute_uv=False)\n\n            # Store the required singular values\n            sigma_bar_L_list[i] = sv_L[0]\n            sigma_bar_Ls_list[i] = sv_Ls[0]\n            sigma_under_I_L_list[i] = sv_I_L[-1]\n            sigma_under_I_Ls_list[i] = sv_I_Ls[-1]\n            sigma_bar_T_list[i] = sv_T[0]\n            sigma_bar_Ts_list[i] = sv_Ts[0]\n\n        # 4. Post-processing to calculate final metrics\n        g_low = sigma_bar_L_list[0]\n        g_low_s = sigma_bar_Ls_list[0]\n\n        m_rd = np.min(sigma_under_I_L_list)\n        m_rd_s = np.min(sigma_under_I_Ls_list)\n\n        T_inf_grid = np.max(sigma_bar_T_list)\n        Ts_inf_grid = np.max(sigma_bar_Ts_list)\n\n        # 5. Boolean flags evaluation\n        b_perf = 1 if g_low_s > g_low else 0\n        b_rob = 1 if (m_rd_s > m_rd and Ts_inf_grid < T_inf_grid) else 0\n\n        # 6. Format and store results for this case\n        case_result = [\n            round(g_low, 3),\n            round(g_low_s, 3),\n            round(m_rd, 3),\n            round(m_rd_s, 3),\n            round(T_inf_grid, 3),\n            round(Ts_inf_grid, 3),\n            b_perf,\n            b_rob,\n        ]\n        all_results.append(case_result)\n\n    # 7. Final output formatting\n    output_parts = []\n    for res in all_results:\n        part = \"[\" + \",\".join(map(str, res)) + \"]\"\n        output_parts.append(part)\n    final_string = \"[\" + \",\".join(output_parts) + \"]\"\n    \n    print(final_string)\n```", "id": "2711299"}]}