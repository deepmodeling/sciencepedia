{"hands_on_practices": [{"introduction": "横截条件常常作为一组规则被呈现，但其背后蕴含着深刻的几何直觉。本练习将引导你从第一性原理出发，通过分析终端约束流形的切空间，推导出当终端状态被约束在单位球面上时的横截条件。通过亲手实践这一推导，你将不再仅仅是记忆规则，而是深刻理解协态变量在终端时刻必须与约束曲面正交的几何本质。[@problem_id:2698222]", "problem": "考虑一个有限时域最优控制问题，其状态为 $x(t) \\in \\mathbb{R}^{n}$，控制为 $u(t) \\in \\mathbb{R}^{m}$，由一个光滑的控制仿射系统 $\\dot{x}(t) = f(x(t),u(t),t)$ 在区间 $t \\in [0,T]$ 上所控制，其中 $T>0$ 是固定的。性能指标是一个纯积分成本 $J[u(\\cdot)] = \\int_{0}^{T} L(x(t),u(t),t)\\, \\mathrm{d}t$，其中 $L$ 和 $f$ 对其所有变量都是连续可微的。初始状态 $x(0)$ 是固定的，而终端状态 $x(T)$ 被约束在由 $\\|x(T)\\| = 1$ 定义的单位球面上。没有终端成本，也没有不等式端点约束。假设 Pontryagin 极大值原理 (PMP) 所要求的所有标准正则性条件和限定条件都成立，包括存在绝对连续的协态 $ \\lambda(t) \\in \\mathbb{R}^{n}$ 和一个被极大化的哈密顿量。\n\n从 PMP 的基本变分结构和端点约束的几何形状出发，通过刻画约束流形的切空间，并对所有容许的端点变分强制边界项为零，推导与等式约束 $\\|x(T)\\|=1$ 相关联的终端时刻 $T$ 的几何横截条件。计算由此几何横截条件所蕴含的终端协态 $ \\lambda(T)$ 的容许形式，并仅用 $x(T)$ 和一个标量拉格朗日乘子来表达你的最终答案。以单一的闭式符号表达式形式提供你的最终答案，不要求单位，也不要求数值近似。", "solution": "目标是最小化性能指标 $J[u(\\cdot)] = \\int_{0}^{T} L(x(t),u(t),t)\\, \\mathrm{d}t$，其系统由 $\\dot{x}(t) = f(x(t),u(t),t)$ 控制。初始状态 $x(0)$ 是固定的，而终端状态 $x(T)$ 被约束在一个特定的流形上，即 $\\mathbb{R}^{n}$ 中的单位球面。该终端约束由等式 $g(x(T)) = 0$ 给出，其中 $g(x) = \\|x\\|^2 - 1 = x^T x - 1$。性能指标中没有终端成本项。\n\n根据 Pontryagin 极大值原理 (PMP)，我们定义哈密顿量 $H(x, u, \\lambda, t) = L(x, u, t) + \\lambda^T f(x, u, t)$。将变分法应用于成本泛函，并结合系统动力学，即可得出最优性的必要条件。在纳入协态动力学 $\\dot{\\lambda}^T = -\\frac{\\partial H}{\\partial x}$ 和最优性条件 $\\frac{\\partial H}{\\partial u} = 0$ 之后，成本泛函的一阶变分简化为边界项：\n$$\n\\delta J = \\lambda(T)^T \\delta x(T) - \\lambda(0)^T \\delta x(0)\n$$\n其中 $\\delta x(t)$ 是状态轨迹的变分。\n\n初始状态 $x(0)$ 被指定为固定的。因此，任何容许的变分都必须满足 $\\delta x(0) = 0$。这使得边界项条件简化为：\n$$\n\\delta J = \\lambda(T)^T \\delta x(T)\n$$\n对于最优轨迹，成本的一阶变分 $\\delta J$ 对于任何容许的控制扰动都必须是非负的。在终端约束的背景下，这意味着对于终端状态的所有*容许*变分 $\\delta x(T)$，边界项必须为零。因此，我们必须有：\n$$\n\\lambda(T)^T \\delta x(T) = 0\n$$\n一个容许的变分 $\\delta x(T)$ 是与终端约束相一致的变分。终端状态 $x(T)$ 被约束在流形 $\\mathcal{S} = \\{x \\in \\mathbb{R}^{n} \\mid \\|x\\| = 1 \\}$ 上。从该流形上一点 $x(T)$ 出发的任何无穷小变分 $\\delta x(T)$ 都必须位于该点处流形的切空间内，我们将其记为 $T_{x(T)}\\mathcal{S}$。\n\n流形 $\\mathcal{S}$ 被定义为函数 $g(x) = x^T x - 1$ 的一个水平集。切空间 $T_{x(T)}\\mathcal{S}$ 是所有在点 $x(T)$ 处与定义函数 $g(x)$ 的梯度正交的向量的集合。$g(x)$ 的梯度为：\n$$\n\\nabla g(x) = \\frac{\\partial}{\\partial x} (x^T x - 1) = 2x\n$$\n因此，在 $x(T)$ 处的切空间是所有满足以下条件的向量 $\\delta x(T)$ 的集合：\n$$\n(\\nabla g(x(T)))^T \\delta x(T) = 0\n$$\n代入梯度的表达式，我们得到：\n$$\n(2x(T))^T \\delta x(T) = 0 \\implies x(T)^T \\delta x(T) = 0\n$$\n这个方程在几何上表明，任何容许的变分 $\\delta x(T)$ 都必须与位置向量 $x(T)$ 本身正交。对于一个以原点为中心的球面来说，这是一个直观的结果：任何一点的切平面都与指向该点的半径向量正交。\n\n横截条件要求对于所有属于切空间 $T_{x(T)}\\mathcal{S}$ 的向量 $\\delta x(T)$，都有 $\\lambda(T)^T \\delta x(T) = 0$。换句话说，对于所有满足 $x(T)^T \\delta x(T) = 0$ 的 $\\delta x(T)$，都有 $\\lambda(T)^T \\delta x(T) = 0$。\n\n这是线性代数中的一个基本结果。如果一个向量 $\\lambda(T)$ 与一个子空间（即切空间 $T_{x(T)}\\mathcal{S}$）中的每个向量都正交，那么 $\\lambda(T)$ 必须位于该子空间的正交补空间中。切空间的正交补空间是在 $x(T)$ 处流形的法空间。\n\n在 $x(T)$ 处流形 $\\mathcal{S}$ 的法空间是由梯度向量 $\\nabla g(x(T))$ 张成的空间。在这种情况下，法空间是一个由向量 $2x(T)$ 张成的一维空间，或者等价地，由向量 $x(T)$ 张成。\n$$\n\\text{法空间} = \\text{span}\\{\\nabla g(x(T))\\} = \\text{span}\\{x(T)\\}\n$$\n因此，终端协态向量 $\\lambda(T)$ 必须是这个法空间的一个元素。这意味着 $\\lambda(T)$ 必须与终端状态向量 $x(T)$ 共线。我们可以将这种关系表示为：\n$$\n\\lambda(T) = \\nu \\, x(T)\n$$\n其中 $\\nu$ 是一个标量比例常数。这个标量 $\\nu$ 被解释为与终端等式约束 $g(x(T))=0$ 相关联的拉格朗日乘子。它的具体值不能仅由横截条件确定，而需要通过求解完整的两点边值问题来找到。\n\n这个表达式给出了由“最终状态位于单位球面上”这一约束所对应的几何横截条件决定的终端协态 $\\lambda(T)$ 的形式。", "answer": "$$\n\\boxed{\\nu \\, x(T)}\n$$", "id": "2698222"}, {"introduction": "掌握了横截条件的几何意义后，下一个关键步骤是在具体问题中应用它们。本练习提供了一个经典的最小燃料问题场景，其特殊之处在于终端时间 $T$ 是自由的，而非固定的。你将需要应用与自由终端时间相对应的横截条件 $H(T)=0$，并结合系统的动力学和其他约束来求解最优时间 $T^*$，这完美地展示了横截条件如何为求解最优控制问题提供关键的边界信息。[@problem_id:2698226]", "problem": "考虑有界控制的标量控制仿射系统的最小燃料转移问题\n$$\\dot{x}(t) = u(t), \\quad |u(t)| \\leq U,$$\n其初始条件固定\n$$x(0) = x_{0} \\quad \\text{且} \\quad x_{0} > 0,$$\n终端状态固定\n$$x(T) = 0,$$\n其中终端时间 $T$ 自由，且所有量均为无量纲。运行成本是 $L_{1}$ 范数的一个光滑近似，\n$$L_{\\varepsilon}(u) = \\sqrt{u(t)^{2} + \\varepsilon^{2}}, \\quad \\varepsilon > 0.$$\n待最小化的性能指标为\n$$J_{\\varepsilon}[u, T] = \\int_{0}^{T} \\sqrt{u(t)^{2} + \\varepsilon^{2}} \\, dt.$$\n仅使用庞特里亚金极大值原理 (PMP) 的第一性原理和核心定义，推导最优性必要条件，包括伴随（协态）动力学和与自由终端时间相关的适当横截条件。然后，通过在最优解上强制施加横截条件、状态动力学和控制约束，确定最优终端时间 $T^{\\star}$。您的最终答案必须是关于 $x_{0}$ 和 $U$ 的 $T^{\\star}$ 的单个闭式解析表达式。", "solution": "本问题旨在为一个标量系统求解最优终端时间 $T^{\\star}$，该系统动力学为 $\\dot{x}(t) = u(t)$，控制有界 $|u(t)| \\leq U$。状态必须从初始条件 $x(0) = x_{0}$（其中 $x_{0} > 0$）转移到固定的终端状态 $x(T) = 0$，其中终端时间 $T$ 是自由的。目标是最小化性能指标 $J_{\\varepsilon}[u, T] = \\int_{0}^{T} \\sqrt{u(t)^{2} + \\varepsilon^{2}} \\, dt$，其中 $\\varepsilon > 0$。我们将使用庞特里亚金极大值原理 (PMP) 来推导最优性必要条件。\n\n首先，我们定义哈密顿函数 $H$。对于一个正常极值，哈密顿函数由运行成本与协态向量和状态动力学函数的内积之和给出。这里，状态是 $x$，控制是 $u$，协态是 $p$，运行成本是 $L(u) = \\sqrt{u^{2} + \\varepsilon^{2}}$，状态动力学是 $f(x, u) = u$。\n$$H(x, p, u) = L(u) + p \\cdot f(x, u) = \\sqrt{u^{2} + \\varepsilon^{2}} + p u$$\n\n根据 PMP，对于一个最优控制 $u^{\\star}(t)$ 和相应的状态轨迹 $x^{\\star}(t)$，必须存在一个协态轨迹 $p^{\\star}(t)$，使得以下必要条件得到满足：\n\n1.  状态方程：$\\dot{x}^{\\star}(t) = \\frac{\\partial H}{\\partial p} = u^{\\star}(t)$。这就是给定的系统动力学。\n\n2.  协态（伴随）方程：协态的动力学由 $\\dot{p}^{\\star}(t) = -\\frac{\\partial H}{\\partial x}$ 给出。\n    $$\\dot{p}^{\\star}(t) = -\\frac{\\partial}{\\partial x} \\left(\\sqrt{(u^{\\star}(t))^{2} + \\varepsilon^{2}} + p^{\\star}(t) u^{\\star}(t)\\right) = 0$$\n    这意味着协态在最优轨迹上是常数：$p^{\\star}(t) = p_{c}$，对于某个常数 $p_{c}$。\n\n3.  哈密顿最小化条件：对于几乎所有的 $t \\in [0, T^{\\star}]$，最优控制 $u^{\\star}(t)$ 必须在容许控制集 $U_{adm} = \\{u \\in \\mathbb{R} : |u| \\leq U\\}$ 上最小化哈密顿函数。\n    $$u^{\\star}(t) = \\arg\\min_{|u| \\leq U} H(x^{\\star}(t), p_{c}, u) = \\arg\\min_{|u| \\leq U} \\left(\\sqrt{u^{2} + \\varepsilon^{2}} + p_{c} u\\right)$$\n\n4.  自由终端时间 $T$ 的横截条件：对于一个终端状态固定、终端时间自由的问题，在最优轨迹上于终端时间取值的哈密顿函数必须为零。\n    $$H(x^{\\star}(T^{\\star}), p_{c}, u^{\\star}(T^{\\star})) = 0$$\n    由于哈密顿函数不显式依赖于时间，并且 $\\dot{x}^{\\star}$ 和 $\\dot{p}^{\\star}$ 都只是 $x, p, u$ 的函数，所以哈密顿函数在最优轨迹上是常数。因此，对于所有 $t \\in [0, T^{\\star}]$，$H(t) = 0$。\n\n现在，我们分析哈密顿最小化问题来确定最优控制 $u^{\\star}$。令 $h(u) = \\sqrt{u^{2} + \\varepsilon^{2}} + p_{c} u$。这个函数是严格凸的，因为它的二阶导数 $h''(u) = \\frac{\\varepsilon^{2}}{(u^{2}+\\varepsilon^{2})^{3/2}}$ 对于 $\\varepsilon > 0$ 是严格为正的。$h(u)$ 在紧区间 $[-U, U]$ 上的最小值必然存在，要么在导数为零的点（内部解），要么在边界 $u = \\pm U$ 处。\n\n我们首先考虑内部（非饱和）解的情况，即 $|u^{\\star}| < U$。这要求 $h(u)$ 的导数在 $u=u^{\\star}$ 处为零：\n$$\\frac{\\partial h}{\\partial u} \\bigg|_{u=u^{\\star}} = \\frac{u^{\\star}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}} + p_{c} = 0 \\quad (1)$$\n这意味着 $p_{c} = -\\frac{u^{\\star}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}$。由此可见， $|p_{c}| = \\frac{|u^{\\star}|}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}} < 1$。\n现在我们应用横截条件 $H=0$：\n$$\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}} + p_{c} u^{\\star} = 0 \\quad (2)$$\n将式 $(1)$ 中的 $p_c$ 代入式 $(2)$：\n$$\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}} + \\left(-\\frac{u^{\\star}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}\\right) u^{\\star} = 0$$\n$$\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}} = \\frac{(u^{\\star})^{2}}{\\sqrt{(u^{\\star})^{2} + \\varepsilon^{2}}}$$\n$$(u^{\\star})^{2} + \\varepsilon^{2} = (u^{\\star})^{2}$$\n$$\\varepsilon^{2} = 0$$\n这与给定条件 $\\varepsilon > 0$ 相矛盾。因此，非饱和的最优控制是不可能的。最优控制必须位于容许集的边界上。\n\n最优控制必须是 $u^{\\star}(t) = U$ 或 $u^{\\star}(t) = -U$。由于状态必须从 $x(0) = x_{0} > 0$ 驱动到 $x(T) = 0$，速度 $\\dot{x} = u$ 必须是平均负值。由于 $p_c$ 是常数，最小化哈密顿函数的控制 $u^{\\star}$ 也必须是常数。因此，最优控制必须是 $u^{\\star}(t) = -U$ 对于所有 $t \\in [0, T^{\\star}]$。\n\n现在，我们将此控制策略应用于系统动力学和边界条件，以求得最优时间 $T^{\\star}$。\n$$\\dot{x}(t) = -U$$\n从 $t=0$ 到 $t=T^{\\star}$ 进行积分：\n$$\\int_{0}^{T^{\\star}} \\dot{x}(t) \\, dt = \\int_{0}^{T^{\\star}} -U \\, dt$$\n$$x(T^{\\star}) - x(0) = -U T^{\\star}$$\n代入边界条件 $x(0) = x_{0}$ 和 $x(T^{\\star}) = 0$：\n$$0 - x_{0} = -U T^{\\star}$$\n$$T^{\\star} = \\frac{x_{0}}{U}$$\n\n最后，我们必须验证该解与 PMP 的所有必要条件一致。控制 $u^{\\star} = -U$ 必须是 $H(u)$ 的最小化器，对于由横截条件决定的 $p_c$ 值。\n$u^{\\star} = -U$ 时的横截条件 $H=0$ 给出：\n$$H = \\sqrt{(-U)^{2} + \\varepsilon^{2}} + p_{c}(-U) = 0$$\n$$\\sqrt{U^{2} + \\varepsilon^{2}} - p_{c} U = 0$$\n$$p_{c} = \\frac{\\sqrt{U^{2} + \\varepsilon^{2}}}{U}$$\n为使 $u^{\\star} = -U$ 成为凸函数 $h(u)$ 的最小化器，在 $u=-U$ 处的导数必须非负：\n$$h'(-U) = \\frac{-U}{\\sqrt{(-U)^{2} + \\varepsilon^{2}}} + p_{c} \\geq 0$$\n$$p_{c} \\geq \\frac{U}{\\sqrt{U^{2} + \\varepsilon^{2}}}$$\n代入我们求得的 $p_c$ 值：\n$$\\frac{\\sqrt{U^{2} + \\varepsilon^{2}}}{U} \\geq \\frac{U}{\\sqrt{U^{2} + \\varepsilon^{2}}}$$\n两边同乘以 $U\\sqrt{U^{2} + \\varepsilon^{2}}$（一个正量，因为要求 $U>0$ 才能解决问题，且 $\\varepsilon>0$）：\n$$(\\sqrt{U^{2} + \\varepsilon^{2}})^{2} \\geq U^{2}$$\n$$U^{2} + \\varepsilon^{2} \\geq U^{2}$$\n$$\\varepsilon^{2} \\geq 0$$\n此不等式成立，因为 $\\varepsilon>0$。PMP 的所有必要条件均由控制 $u^{\\star}(t)=-U$ 和终端时间 $T^{\\star} = x_0/U$ 满足。这是最优解的唯一候选解。", "answer": "$$\\boxed{\\frac{x_{0}}{U}}$$", "id": "2698226"}, {"introduction": "理论的优雅最终需要通过计算来实现。这个综合性练习旨在连接庞特里亚金极大值原理的理论推导与数值求解的实际应用。你将亲手实现一个基于牛顿法的打靶法，来解决由状态方程、协态方程和边界/横截条件构成的两点边值问题 (TPBVP)。通过这个编码实践，你将把抽象的必要条件转化为一个具体、强大的算法，用于计算最优控制轨迹。[@problem_id:2698225]", "problem": "要求您实现、分析和测试一种牛顿型打靶法，该方法通过更新初始协态来满足有限时域最优控制问题中的末端等式约束。该方法必须使用 Pontryagin 最小原理（PMP）、伴随（协态）方程以及末端约束相对于初始协态的灵敏度分析，从第一性原理推导得出。实现时必须使用相应常微分方程（ODE）的数值积分，并利用从变分（灵敏度）方程计算出的雅可比矩阵，通过牛顿法迭代更新初始协态。\n\n考虑以下有限时域最优控制问题：\n- 最小化积分代价\n$$\nJ(u) \\;=\\; \\int_{0}^{T} \\tfrac{1}{2}\\,\\big(x(t)^{\\top} Q\\,x(t) \\;+\\; u(t)^{\\top} R \\, u(t)\\big)\\, dt,\n$$\n满足线性时不变动力学约束\n$$\n\\dot{x}(t) \\;=\\; A\\,x(t) \\;+\\; B\\,u(t), \\quad x(0) \\;=\\; x_{0},\n$$\n以及末端等式约束\n$$\n\\psi\\big(x(T)\\big) \\;=\\; C\\,x(T) \\;-\\; x_{T} \\;=\\; 0.\n$$\n此处，$x(t) \\in \\mathbb{R}^{n}$，$u(t) \\in \\mathbb{R}^{m}$，$A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$，$Q \\in \\mathbb{R}^{n \\times n}$ 是半正定的，$R \\in \\mathbb{R}^{m \\times m}$ 是正定的，$C \\in \\mathbb{R}^{r \\times n}$，$x_{0} \\in \\mathbb{R}^{n}$ 是给定的，$x_{T} \\in \\mathbb{R}^{r}$ 是给定的，并且 $T > 0$ 是固定的。假设 $m = 1$ 且 $R$ 是一个标量（即 $R \\in \\mathbb{R}$ 且 $R > 0$）。\n\n基本原理与推导要求：\n- 使用 Pontryagin 最小原理（PMP）。定义哈密顿函数\n$$\nH(x,u,\\lambda) \\;=\\; \\tfrac{1}{2}\\,\\big(x^{\\top} Q\\,x \\;+\\; u^{\\top} R\\,u\\big) \\;+\\; \\lambda^{\\top}(A x + B u),\n$$\n其中协态为 $\\lambda(t) \\in \\mathbb{R}^{n}$。PMP 导出了以下必要条件：\n    - 状态方程：$\\dot{x}(t) \\;=\\; A\\,x(t) \\;+\\; B\\,u(t)$，其中 $x(0)=x_{0}$。\n    - 协态方程：$\\dot{\\lambda}(t) \\;=\\; -Q\\,x(t) \\;-\\; A^{\\top}\\lambda(t)$。\n    - 最优控制（一阶条件）：$\\partial H/\\partial u \\;=\\; R u \\;+\\; B^{\\top}\\lambda \\;=\\; 0$，因此 $u(t) \\;=\\; -R^{-1} B^{\\top}\\lambda(t)$。\n    - 等式约束的末端横截条件：存在一个拉格朗日乘子 $\\nu \\in \\mathbb{R}^{r}$，使得 $\\lambda(T) \\;=\\; C^{\\top}\\nu$ 且 $\\psi\\big(x(T)\\big)=0$。\n- 为了对初始协态实施单次打靶牛顿法，将 $\\lambda(0)$ 视为决策向量。对于任意猜测的 $\\lambda(0)$，使用 $u(t) = -R^{-1} B^{\\top}\\lambda(t)$ 对耦合的状态-协态 ODE 进行时间上的正向积分，以获得 $x(T)$ 和末端残差\n$$\nr\\big(\\lambda(0)\\big) \\;=\\; \\psi\\big(x(T)\\big) \\;=\\; C\\,x(T) \\;-\\; x_{T}.\n$$\n- 推导并积分关于 $\\lambda(0)$ 的变分（灵敏度）ODE，以获得牛顿法所需的雅可比矩阵。令 $S(t) = \\dfrac{\\partial x(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$ 和 $M(t) = \\dfrac{\\partial \\lambda(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$。利用 $f(x,\\lambda) = A x + B u$ 和 $u(\\lambda) = -R^{-1} B^{\\top}\\lambda$ 的定义以及协态动力学，推导出线性时变矩阵 ODE\n$$\n\\begin{aligned}\n\\dot{S}(t) \\;&=\\; A\\,S(t) \\;-\\; B\\,R^{-1} B^{\\top}\\,M(t), \\\\\n\\dot{M}(t) \\;&=\\; -Q\\,S(t) \\;-\\; A^{\\top} M(t),\n\\end{aligned}\n$$\n初始条件为 $S(0) = 0$ 和 $M(0)=I_{n}$。则约束的末端灵敏度为\n$$\nJ\\big(\\lambda(0)\\big) \\;=\\; \\frac{\\partial \\psi(x(T))}{\\partial \\lambda(0)} \\;=\\; C\\,S(T).\n$$\n- 对 $\\lambda(0)$ 实施牛顿法，使用更新式\n$$\n\\lambda(0) \\leftarrow \\lambda(0) \\;-\\; \\Delta, \\quad \\text{其中 } J\\,\\Delta \\;=\\; r.\n$$\n如果 $J$ 不是方阵或不可逆，则在最小二乘意义下求解。迭代直至 $\\lVert r \\rVert_{2}$ 低于指定的容差或达到最大迭代次数。\n\n编程任务：\n- 实现一个程序，对每个给定的测试用例，执行上述牛顿型打靶法：\n    - 在 $[0,T]$ 上对 $\\big(x(t),\\lambda(t),S(t),M(t)\\big)$ 的耦合 ODE 系统进行数值积分。\n    - 计算末端残差 $r$ 和雅可比矩阵 $J$。\n    - 通过牛顿步骤中的线性求解更新 $\\lambda(0)$。\n    - 重复直至收敛。\n- 将 $r$ 的停止容差设置为欧几里得范数 $\\varepsilon = 10^{-9}$，最大迭代次数为 $10$ 次。\n- 将 $\\lambda(0)$ 初始化为零向量。\n- 使用 $10^{-10}$ 的绝对和相对 ODE 求解器容差。\n\n测试套件：\n为以下四种情况提供数值结果。每种情况下，$n = 2, m = 1$。\n\n- 情况 1（理想情况，方形末端约束）：\n    - $A = \\begin{bmatrix} 0 & 1 \\\\ -1 & -\\tfrac{1}{2}\\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n      $R = 1$,\n      $C = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$,\n      $T = 2$.\n- 情况 2（欠定末端约束，最小二乘牛顿步骤）：\n    - $A = \\begin{bmatrix} 0 & 1 \\\\ -1 & -\\tfrac{1}{2}\\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n      $R = 1$,\n      $C = \\begin{bmatrix} 1 & 0 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\end{bmatrix}$,\n      $T = 2$.\n- 情况 3（双积分器，方形末端约束）：\n    - $A = \\begin{bmatrix} 0 & 1 \\\\ 0 & 0 \\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1 & 0 \\\\ 0 & 0.1 \\end{bmatrix}$,\n      $R = 0.1$,\n      $C = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$,\n      $T = 1.5$.\n- 情况 4（不同阻尼和单分量约束）：\n    - $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -0.2 \\end{bmatrix}$,\n      $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$,\n      $Q = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n      $R = 10$,\n      $C = \\begin{bmatrix} 0 & 1 \\end{bmatrix}$,\n      $x_{0} = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}$,\n      $x_{T} = \\begin{bmatrix} 0 \\end{bmatrix}$,\n      $T = 1.2$.\n\n要求输出：\n- 对于每种情况，在牛顿迭代终止后，返回末端残差的欧几里得范数 $\\lVert r \\rVert_{2}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按情况 1 到 4 顺序排列的结果，每个残差四舍五入到小数点后 10 位（例如，$[0.0,0.0,0.0,0.0]$ 表示在舍入误差内精确满足）。\n\n约束和说明：\n- 不涉及角度；不需要角度单位。\n- 没有需要报告的明确物理单位。\n- 在牛顿步骤中使用数值稳定的线性代数运算（对可能非方阵的 $J$ 使用最小二乘法）。\n- 实现必须是自包含的，不需要任何输入，并严格按照指定格式打印一行。", "solution": "该问题要求解决一个有限时域最优控制问题，该问题定义为最小化一个二次代价泛函：\n$$\nJ(u) = \\int_{0}^{T} \\tfrac{1}{2}\\,\\big(x(t)^{\\top} Q\\,x(t) + u(t)^{\\top} R \\, u(t)\\big)\\, dt\n$$\n满足线性时不变动力学约束：\n$$\n\\dot{x}(t) = A\\,x(t) + B\\,u(t), \\quad x(0) = x_{0}\n$$\n以及一个末端等式约束：\n$$\n\\psi\\big(x(T)\\big) = C\\,x(T) - x_{T} = 0\n$$\n此处，$x(t) \\in \\mathbb{R}^{n}$，$u(t) \\in \\mathbb{R}^{m}$，并且所有矩阵和向量都具有相容的维度。给定 $n=2$ 和 $m=1$。\n\n根据 Pontryagin 最小原理，我们引入哈密顿函数 $H(x, u, \\lambda)$：\n$$\nH(x, u, \\lambda) = \\tfrac{1}{2}\\,\\big(x^{\\top} Q\\,x + u^{\\top} R\\,u\\big) + \\lambda^{\\top}(A x + B u)\n$$\n其中 $\\lambda(t) \\in \\mathbb{R}^{n}$ 是协态向量。最优性的必要条件是：\n1.  状态方程：$\\dot{x} = \\nabla_{\\lambda}H = Ax + Bu$。\n2.  协态方程：$\\dot{\\lambda} = -\\nabla_{x}H = -Qx - A^{\\top}\\lambda$。\n3.  最优性条件：$\\nabla_{u}H = Ru + B^{\\top}\\lambda = 0$。由于 $R$ 是正定的，这给出了以协态表示的最优控制律：\n    $$\n    u^{*}(t) = -R^{-1}B^{\\top}\\lambda(t)\n    $$\n4.  横截条件：对于末端约束 $\\psi(x(T))=0$，必须存在一个拉格朗日乘子向量 $\\nu \\in \\mathbb{R}^{r}$，使得 $\\lambda(T) = \\frac{\\partial}{\\partial x(T)} [\\nu^\\top \\psi(x(T))]^\\top = (C^\\top \\nu)^\\top{}^\\top = C^\\top \\nu$。\n\n将最优控制 $u^*(t)$ 代入状态和协态方程，得到一个线性常微分方程（ODE）的耦合系统：\n$$\n\\begin{aligned}\n\\dot{x}(t) &= A\\,x(t) - B\\,R^{-1}B^{\\top}\\lambda(t) \\\\\n\\dot{\\lambda}(t) &= -Q\\,x(t) - A^{\\top}\\lambda(t)\n\\end{aligned}\n$$\n这可以写成块矩阵形式：\n$$\n\\frac{d}{dt}\\begin{pmatrix} x(t) \\\\ \\lambda(t) \\end{pmatrix} = \\begin{pmatrix} A & -BR^{-1}B^{\\top} \\\\ -Q & -A^{\\top} \\end{pmatrix} \\begin{pmatrix} x(t) \\\\ \\lambda(t) \\end{pmatrix}\n$$\n该系统构成一个两点边值问题（TPBVP），其边界条件为 $x(0) = x_0$ 和末端条件 $C x(T) - x_T = 0$。初始协态 $\\lambda(0)$ 是未知的。\n\n打靶法将此 TPBVP 转化为一个初值问题。我们将未知的初始协态 $\\lambda(0)$ 视为一个决策变量。对于一个给定的 $\\lambda(0)$ 猜测值，我们可以将 ODE 系统从 $t=0$ 到 $t=T$ 进行时间上的正向积分。这会产生一个作为初始猜测值函数的末端状态，即 $x(T; \\lambda(0))$。问题就变成了找到 $\\lambda(0)$ 以满足末端约束。这是一个针对残差函数 $r(\\lambda(0))$ 的求根问题：\n$$\nr\\big(\\lambda(0)\\big) = C\\,x(T; \\lambda(0)) - x_{T} = 0\n$$\n我们采用牛顿法来求解这个关于 $\\lambda(0)$ 的非线性方程组。迭代更新式为：\n$$\n\\lambda(0)_{k+1} = \\lambda(0)_{k} - \\Delta_k\n$$\n其中 $\\Delta_k$ 是线性系统 $J_k \\Delta_k = r_k$ 的解。这里，$r_k = r(\\lambda(0)_k)$ 是第 $k$ 次迭代的残差，而 $J_k$ 是在 $\\lambda(0)_k$ 处求值的残差函数的雅可比矩阵：\n$$\nJ(\\lambda(0)) = \\frac{\\partial r(\\lambda(0))}{\\partial \\lambda(0)} = C \\frac{\\partial x(T)}{\\partial \\lambda(0)}\n$$\n为了计算雅可比矩阵，我们需要末端状态相对于初始协态的灵敏度。我们定义灵敏度矩阵 $S(t) = \\frac{\\partial x(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$ 和 $M(t) = \\frac{\\partial \\lambda(t)}{\\partial \\lambda(0)} \\in \\mathbb{R}^{n \\times n}$。通过对耦合的 $(x, \\lambda)$ ODE 系统关于 $\\lambda(0)$ 求导，我们得到变分（或灵敏度）方程：\n$$\n\\frac{d}{dt}\\begin{pmatrix} S(t) \\\\ M(t) \\end{pmatrix} = \\begin{pmatrix} A & -BR^{-1}B^{\\top} \\\\ -Q & -A^{\\top} \\end{pmatrix} \\begin{pmatrix} S(t) \\\\ M(t) \\end{pmatrix}\n$$\n这些灵敏度矩阵的初始条件由原系统的初始条件导出。由于 $x(0) = x_0$ 是固定的，不依赖于 $\\lambda(0)$，所以其导数为零：$S(0) = \\frac{\\partial x(0)}{\\partial \\lambda(0)} = 0$。初始协态 $\\lambda(0)$ 是自变量，因此它对自身的导数是单位矩阵：$M(0) = \\frac{\\partial \\lambda(0)}{\\partial \\lambda(0)} = I_n$。\n\n完整的数值流程如下。我们构建一个增广状态向量 $Y(t)$，它连接了状态、协态和向量化的灵敏度矩阵：\n$$\nY(t) = \\begin{pmatrix} x(t) \\\\ \\lambda(t) \\\\ \\text{vec}(S(t)) \\\\ \\text{vec}(M(t)) \\end{pmatrix} \\in \\mathbb{R}^{2n+2n^2}\n$$\n$Y(t)$ 的动力学由四个耦合矩阵 ODE 的组合系统给出。基于牛顿法的打靶法的数值算法如下：\n1.  初始化初始协态的猜测值，$\\lambda(0)_0 = 0 \\in \\mathbb{R}^n$。\n2.  对于每次迭代 $k = 0, 1, \\dots, \\text{max\\_iter}-1$：\n    a. 使用 $x_0$、当前猜测值 $\\lambda(0)_k$、$S(0) = 0$ 和 $M(0) = I_n$ 构建增广系统的初始条件 $Y(0)$。\n    b. 使用高精度的数值求解器（例如，Runge-Kutta）将增广 ODE 系统从 $t=0$ 积分到 $t=T$。\n    c. 从末端解 $Y(T)$ 中，提取末端状态 $x(T)$ 和末端灵敏度矩阵 $S(T)$。\n    d. 计算残差 $r_k = C\\,x(T) - x_T$ 及其欧几里得范数 $\\|r_k\\|_2$。\n    e. 如果 $\\|r_k\\|_2$ 低于指定容差 $\\varepsilon = 10^{-9}$，则达到收敛，迭代终止。\n    f. 计算雅可比矩阵 $J_k = C\\,S(T)$。\n    g. 求解线性系统 $J_k \\Delta_k = r_k$ 以获得更新步长 $\\Delta_k$。使用最小二乘求解器（`numpy.linalg.lstsq`）来稳健地处理方形（$r=n$）和非方形（$r \\neq n$）的雅可比矩阵。\n    h. 更新初始协态：$\\lambda(0)_{k+1} = \\lambda(0)_{k} - \\Delta_k$。\n3.  循环终止后（因收敛或达到最大迭代次数），将最终的残差范数 $\\|r_k\\|_2$ 作为结果报告。\n\n对所提供的四个测试用例中的每一个都实施此过程。用于 ODE 求解器的状态向量是一个包含 $x, \\lambda, S, M$ 所有分量的一维扁平化数组。ODE 系统函数正确地解包此向量，计算导数，并将其作为扁平化向量返回。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the shooting method for each.\n    \"\"\"\n    \n    # Case 1: happy path, square terminal constraint\n    case1 = {\n        \"A\": np.array([[0, 1], [-1, -0.5]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 1]]),\n        \"R\": 1.0,\n        \"C\": np.array([[1, 0], [0, 1]]),\n        \"x0\": np.array([1, 0]),\n        \"xT\": np.array([0, 0]),\n        \"T\": 2.0\n    }\n\n    # Case 2: underdetermined terminal constraint\n    case2 = {\n        \"A\": np.array([[0, 1], [-1, -0.5]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 1]]),\n        \"R\": 1.0,\n        \"C\": np.array([[1, 0]]),\n        \"x0\": np.array([1, 0]),\n        \"xT\": np.array([0]),\n        \"T\": 2.0\n    }\n\n    # Case 3: double integrator, square terminal constraint\n    case3 = {\n        \"A\": np.array([[0, 1], [0, 0]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 0.1]]),\n        \"R\": 0.1,\n        \"C\": np.array([[1, 0], [0, 1]]),\n        \"x0\": np.array([1, -1]),\n        \"xT\": np.array([0, 0]),\n        \"T\": 1.5\n    }\n\n    # Case 4: different damping and single component constraint\n    case4 = {\n        \"A\": np.array([[0, 1], [-2, -0.2]]),\n        \"B\": np.array([[0], [1]]),\n        \"Q\": np.array([[1, 0], [0, 1]]),\n        \"R\": 10.0,\n        \"C\": np.array([[0, 1]]),\n        \"x0\": np.array([0.5, -0.5]),\n        \"xT\": np.array([0]),\n        \"T\": 1.2\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    results = []\n\n    for case in test_cases:\n        final_residual_norm = run_shooting_method(\n            case[\"A\"], case[\"B\"], case[\"Q\"], case[\"R\"], case[\"C\"],\n            case[\"x0\"], case[\"xT\"], case[\"T\"]\n        )\n        results.append(f\"{final_residual_norm:.10f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_shooting_method(A, B, Q, R, C, x0, xT, T):\n    \"\"\"\n    Performs the Newton-type shooting method for a single optimal control problem.\n\n    Args:\n        A, B, Q, R, C: System matrices\n        x0, xT: Initial state and target vector for the terminal constraint\n        T: Final time\n\n    Returns:\n        The Euclidean norm of the final terminal residual.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Since R is a scalar m=1, R_inv is simple.\n    R_inv = 1.0 / R\n    \n    # Pre-compute matrix products for efficiency in the ODE function.\n    BRB_T = B @ B.T * R_inv\n\n    def ode_system(t, y):\n        \"\"\"\n        Defines the augmented ODE system for [x, lambda, S, M].\n        y is a flattened vector of size (2n + 2n^2).\n        \"\"\"\n        # Unpack state vector y\n        x = y[0:n]\n        lam = y[n:2*n]\n        S_flat = y[2*n : 2*n + n*n]\n        M_flat = y[2*n + n*n : 2*n + 2*n*n]\n        \n        S = S_flat.reshape((n, n))\n        M = M_flat.reshape((n, n))\n        \n        # State and Costate ODEs\n        dx_dt = A @ x - BRB_T @ lam\n        dlam_dt = -Q @ x - A.T @ lam\n        \n        # Sensitivity ODEs\n        dS_dt = A @ S - BRB_T @ M\n        dM_dt = -Q @ S - A.T @ M\n        \n        # Pack derivatives into a flat vector for the solver\n        dy_dt = np.concatenate((\n            dx_dt,\n            dlam_dt,\n            dS_dt.flatten(),\n            dM_dt.flatten()\n        ))\n        return dy_dt\n\n    # Newton's method settings\n    lambda0 = np.zeros(n)\n    max_iter = 10\n    conv_tol = 1e-9\n    ode_tol = 1e-10\n\n    residual_norm = -1.0\n\n    for i in range(max_iter):\n        # Set initial conditions for the augmented system\n        S0 = np.zeros((n, n))\n        M0 = np.eye(n)\n        y0 = np.concatenate((\n            x0,\n            lambda0,\n            S0.flatten(),\n            M0.flatten()\n        ))\n        \n        # Integrate the augmented ODEs\n        sol = solve_ivp(\n            ode_system,\n            [0, T],\n            y0,\n            method='RK45', \n            rtol=ode_tol,\n            atol=ode_tol\n        )\n        \n        # Extract terminal values from the integration result\n        y_T = sol.y[:, -1]\n        x_T_sim = y_T[0:n]\n        S_T = y_T[2*n : 2*n + n*n].reshape((n, n))\n        \n        # Compute the terminal residual and its norm\n        residual = C @ x_T_sim - xT\n        residual_norm = np.linalg.norm(residual)\n        \n        # Check for convergence\n        if residual_norm < conv_tol:\n            break\n            \n        # Compute the Jacobian for the Newton step\n        jacobian = C @ S_T\n        \n        # Solve for the Newton update delta: J * delta = r\n        # Use least squares to handle both square and non-square Jacobians\n        delta, _, _, _ = np.linalg.lstsq(jacobian, residual, rcond=None)\n        \n        # Update the initial costate guess\n        lambda0 = lambda0 - delta\n        \n    return residual_norm\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2698225"}]}