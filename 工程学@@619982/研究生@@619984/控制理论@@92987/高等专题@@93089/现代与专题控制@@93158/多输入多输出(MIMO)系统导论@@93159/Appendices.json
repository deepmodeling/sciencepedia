{"hands_on_practices": [{"introduction": "多输入多输出（MIMO）系统的分析始于对其数学模型的深刻理解。本练习将引导你从第一性原理出发，推导一个具有分组输入和输出的MIMO系统的传递矩阵，这在处理大型、模块化系统时是一种常见做法。通过这项实践，你将巩固状态空间表示与传递函数表示之间的基本关系 $G(s) = C(sI-A)^{-1}B+D$，并直观地看到系统的物理或逻辑子结构如何直接映射到传递矩阵的块结构上[@problem_id:2713773]。", "problem": "考虑一个连续时间线性时不变 (LTI) 多输入多输出 (MIMO) 系统，其状态、输入和输出由以下方程描述：\n$$\\dot{x}(t) = A x(t) + B u(t), \\quad y(t) = C x(t) + D u(t),$$\n其中 $x(t) \\in \\mathbb{R}^{n}$，$u(t) \\in \\mathbb{R}^{m}$，$y(t) \\in \\mathbb{R}^{p}$。输入和输出各自被分组成两个子系统，使得：\n$$u(t) = \\begin{pmatrix} u_{1}(t) \\\\ u_{2}(t) \\end{pmatrix}, \\quad y(t) = \\begin{pmatrix} y_{1}(t) \\\\ y_{2}(t) \\end{pmatrix},$$\n其中 $u_{1}(t) \\in \\mathbb{R}^{m_{1}}$，$u_{2}(t) \\in \\mathbb{R}^{m_{2}}$，$y_{1}(t) \\in \\mathbb{R}^{p_{1}}$，$y_{2}(t) \\in \\mathbb{R}^{p_{2}}$，并且 $m_{1} + m_{2} = m$，$p_{1} + p_{2} = p$。矩阵 $B$、$C$ 和 $D$ 相容地分块如下：\n$$B = \\begin{pmatrix} B_{1} & B_{2} \\end{pmatrix}, \\quad C = \\begin{pmatrix} C_{1} \\\\ C_{2} \\end{pmatrix}, \\quad D = \\begin{pmatrix} D_{11} & D_{12} \\\\ D_{21} & D_{22} \\end{pmatrix},$$\n其中对于 $i \\in \\{1,2\\}$ 和 $j \\in \\{1,2\\}$，$B_{j} \\in \\mathbb{R}^{n \\times m_{j}}$，$C_{i} \\in \\mathbb{R}^{p_{i} \\times n}$，$D_{ij} \\in \\mathbb{R}^{p_{i} \\times m_{j}}$。\n\n从第一性原理出发，利用零初始条件下状态方程的拉普拉斯变换以及传递矩阵作为拉普拉斯变换 $U(s)$ 和 $Y(s)$ 之间映射的定义，推导输入-输出传递矩阵 $G(s)$，并说明输入和输出的分组如何引出一个 $2 \\times 2$ 的分块结构。将 $G(s)$ 明确地表示为由 $A$、$B_{1}$、$B_{2}$、$C_{1}$、$C_{2}$、$D_{ij}$ 和复拉普拉斯变量 $s$ 构成的单个 $2 \\times 2$ 分块矩阵。你的推导应清楚说明哪个子块将哪个输入组映射到哪个输出组，以及其原因。\n\n请将你的最终结果作为传递矩阵 $G(s)$ 的单个 $2 \\times 2$ 分块闭式解析表达式。不需要进行数值计算，也不需要进行舍入。不要包含单位。", "solution": "在尝试任何解答之前，首先检查问题陈述的有效性。\n\n首先，我们提取问题的已知条件。\n该系统是一个连续时间线性时不变 (LTI) 多输入多输出 (MIMO) 系统，由状态空间方程描述：\n$$\n\\dot{x}(t) = A x(t) + B u(t)\n$$\n$$\ny(t) = C x(t) + D u(t)\n$$\n状态、输入和输出向量的维度为 $x(t) \\in \\mathbb{R}^{n}$，$u(t) \\in \\mathbb{R}^{m}$，$y(t) \\in \\mathbb{R}^{p}$。\n初始条件指定为零：$x(0) = 0$。\n输入和输出向量被分块为：\n$$\nu(t) = \\begin{pmatrix} u_{1}(t) \\\\ u_{2}(t) \\end{pmatrix}, \\quad y(t) = \\begin{pmatrix} y_{1}(t) \\\\ y_{2}(t) \\end{pmatrix}\n$$\n这些分块的维度为 $u_{1}(t) \\in \\mathbb{R}^{m_{1}}$，$u_{2}(t) \\in \\mathbb{R}^{m_{2}}$，$y_{1}(t) \\in \\mathbb{R}^{p_{1}}$，$y_{2}(t) \\in \\mathbb{R}^{p_{2}}$，其中 $m_{1} + m_{2} = m$ 且 $p_{1} + p_{2} = p$。\n系统矩阵 $B$、$C$ 和 $D$ 被相容地分块为：\n$$\nB = \\begin{pmatrix} B_{1} & B_{2} \\end{pmatrix}, \\quad C = \\begin{pmatrix} C_{1} \\\\ C_{2} \\end{pmatrix}, \\quad D = \\begin{pmatrix} D_{11} & D_{12} \\\\ D_{21} & D_{22} \\end{pmatrix}\n$$\n矩阵分块的维度为，对于 $i \\in \\{1,2\\}$ 和 $j \\in \\{1,2\\}$，$B_{j} \\in \\mathbb{R}^{n \\times m_{j}}$，$C_{i} \\in \\mathbb{R}^{p_{i} \\times n}$，$D_{ij} \\in \\mathbb{R}^{p_{i} \\times m_{j}}$。\n任务是从第一性原理出发，推导输入-输出传递矩阵 $G(s)$，并将其表示为一个由给定的分块矩阵和拉普拉斯变量 $s$ 构成的 $2 \\times 2$ 分块矩阵。\n\n接下来，我们验证问题陈述。\n该问题有科学依据，植根于线性系统和控制理论的基本原理。状态空间表示法以及通过拉普拉斯变换推导传递函数是标准的、成熟的程序。该问题是适定的，提供了推导传递矩阵唯一数学表达式所需的所有必要信息（方程、分块、零初始条件）。语言客观且数学上精确。问题设定完整且内部一致，所有矩阵和向量的维度对于指定的操作都是相容的。该问题是 MIMO 系统分析中一个可形式化且相关的练习。它没有违反任何无效标准。\n\n问题被认定为有效。我们着手进行解答。\n\n推导过程从对状态空间方程应用拉普拉斯变换开始。令 $X(s)$、$U(s)$ 和 $Y(s)$ 分别为 $x(t)$、$u(t)$ 和 $y(t)$ 的拉普拉斯变换。对状态方程应用变换，得到：\n$$\n\\mathcal{L}\\{\\dot{x}(t)\\} = \\mathcal{L}\\{A x(t) + B u(t)\\}\n$$\n使用拉普拉斯变换的微分性质，$\\mathcal{L}\\{\\dot{x}(t)\\} = sX(s) - x(0)$。在零初始状态的条件下，$x(0)=0$，这简化为 $sX(s)$。方程变为：\n$$\nsX(s) = AX(s) + BU(s)\n$$\n这是一个在拉普拉斯域中的代数方程。我们必须求解状态向量的变换 $X(s)$，用输入变换 $U(s)$ 来表示。\n$$\nsX(s) - AX(s) = BU(s)\n$$\n对 $X(s)$ 进行因式分解需要使用维度为 $n \\times n$ 的单位矩阵 $I$：\n$$\n(sI - A)X(s) = BU(s)\n$$\n假设 $s$ 不是 $A$ 的特征值，则矩阵 $(sI - A)$ 是可逆的。我们可以用它的逆矩阵 $(sI - A)^{-1}$ 进行左乘，该逆矩阵是矩阵 $A$ 的预解式。\n$$\nX(s) = (sI - A)^{-1} B U(s)\n$$\n现在，我们对输出方程应用拉普拉斯变换：\n$$\n\\mathcal{L}\\{y(t)\\} = \\mathcal{L}\\{C x(t) + D u(t)\\}\n$$\n$$\nY(s) = CX(s) + DU(s)\n$$\n将 $X(s)$ 的表达式代入变换后的输出方程：\n$$\nY(s) = C(sI - A)^{-1} B U(s) + D U(s)\n$$\n通过在右侧提取公因式 $U(s)$，我们得到输入和输出变换之间的关系：\n$$\nY(s) = \\left[ C(sI - A)^{-1} B + D \\right] U(s)\n$$\n根据定义，传递矩阵 $G(s)$ 是将输入变换 $U(s)$ 与输出变换 $Y(s)$ 关联起来的矩阵，即 $Y(s) = G(s)U(s)$。因此，我们确定传递矩阵为：\n$$\nG(s) = C(sI - A)^{-1} B + D\n$$\n为了揭示由输入和输出分块引起的 $2 \\times 2$ 分块结构，我们将矩阵 $B$、$C$ 和 $D$ 的分块形式代入此表达式。\n$$\nG(s) = \\begin{pmatrix} C_{1} \\\\ C_{2} \\end{pmatrix} (sI - A)^{-1} \\begin{pmatrix} B_{1} & B_{2} \\end{pmatrix} + \\begin{pmatrix} D_{11} & D_{12} \\\\ D_{21} & D_{22} \\end{pmatrix}\n$$\n分块矩阵 $C$ 和 $B_j$ 与中间矩阵 $(sI-A)^{-1}$ 的乘积根据分块矩阵乘法规则进行：\n$$\n\\begin{pmatrix} C_{1} \\\\ C_{2} \\end{pmatrix} (sI - A)^{-1} \\begin{pmatrix} B_{1} & B_{2} \\end{pmatrix} = \\begin{pmatrix} C_{1}(sI - A)^{-1}B_{1} & C_{1}(sI - A)^{-1}B_{2} \\\\ C_{2}(sI - A)^{-1}B_{1} & C_{2}(sI - A)^{-1}B_{2} \\end{pmatrix}\n$$\n现在，我们加上分块的前馈矩阵 $D$：\n$$\nG(s) = \\begin{pmatrix} C_{1}(sI - A)^{-1}B_{1} & C_{1}(sI - A)^{-1}B_{2} \\\\ C_{2}(sI - A)^{-1}B_{1} & C_{2}(sI - A)^{-1}B_{2} \\end{pmatrix} + \\begin{pmatrix} D_{11} & D_{12} \\\\ D_{21} & D_{22} \\end{pmatrix}\n$$\n两个相容分块的块矩阵之和是其对应子块的逐块相加。这就得到了传递矩阵 $G(s)$ 最终的 $2 \\times 2$ 分块结构：\n$$\nG(s) = \\begin{pmatrix} C_{1}(sI - A)^{-1}B_{1} + D_{11} & C_{1}(sI - A)^{-1}B_{2} + D_{12} \\\\ C_{2}(sI - A)^{-1}B_{1} + D_{21} & C_{2}(sI - A)^{-1}B_{2} + D_{22} \\end{pmatrix}\n$$\n此表达式显示了系统传递矩阵的显式 $2 \\times 2$ 分块形式。如果我们将 $G(s)$ 表示为 $G(s) = \\begin{pmatrix} G_{11}(s) & G_{12}(s) \\\\ G_{21}(s) & G_{22}(s) \\end{pmatrix}$，那么输入-输出关系 $Y(s) = G(s)U(s)$ 可以写成：\n$$\n\\begin{pmatrix} Y_{1}(s) \\\\ Y_{2}(s) \\end{pmatrix} = \\begin{pmatrix} G_{11}(s) & G_{12}(s) \\\\ G_{21}(s) & G_{22}(s) \\end{pmatrix} \\begin{pmatrix} U_{1}(s) \\\\ U_{2}(s) \\end{pmatrix}\n$$\n由此可见，每个子块 $G_{ij}(s)$ 将输入组 $j$ 映射到输出组 $i$。具体来说：\n$G_{11}(s) = C_{1}(sI - A)^{-1}B_{1} + D_{11}$ 将 $U_{1}(s)$ 映射到 $Y_{1}(s)$。\n$G_{12}(s) = C_{1}(sI - A)^{-1}B_{2} + D_{12}$ 将 $U_{2}(s)$ 映射到 $Y_{1}(s)$。\n$G_{21}(s) = C_{2}(sI - A)^{-1}B_{1} + D_{21}$ 将 $U_{1}(s)$ 映射到 $Y_{2}(s)$。\n$G_{22}(s) = C_{2}(sI - A)^{-1}B_{2} + D_{22}$ 将 $U_{2}(s)$ 映射到 $Y_{2}(s)$。\n这完成了所要求的推导。最终表达式是 $2 \\times 2$ 分块传递矩阵的单个闭式解析表达式。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nC_{1}(sI - A)^{-1}B_{1} + D_{11} & C_{1}(sI - A)^{-1}B_{2} + D_{12} \\\\\nC_{2}(sI - A)^{-1}B_{1} + D_{21} & C_{2}(sI - A)^{-1}B_{2} + D_{22}\n\\end{pmatrix}\n}\n$$", "id": "2713773"}, {"introduction": "将控制器与被控对象连接成闭环后，分析的核心便转向了回路特性。本练习要求你为一个具体的二输入二输出系统计算其回路传递矩阵 $L(s)$ 和返回差阵 $I+L(s)$，这是评估多变量反馈系统稳定性和性能的基石[@problem_id:2713799]。通过计算返回差阵的行列式 $\\det(I+L(s))$，你将亲手验证这一关键量如何将单变量系统中的标量判据 $1+L(s)$ 推广至多维空间，为后续的奈奎斯特稳定性分析和鲁棒性评估奠定基础。", "problem": "考虑一个双输入双输出的线性时不变对象，其传递矩阵为\n$$\nG(s)=\\begin{pmatrix}\n\\dfrac{1}{s+1} & \\dfrac{1}{s+2} \\\\\n0 & \\dfrac{2}{s+3}\n\\end{pmatrix},\n$$\n以及一个静态多变量控制器\n$$\nK=\\begin{pmatrix}\nk_{1} & 0\\\\\nk_{2} & k_{3}\n\\end{pmatrix},\n$$\n其中 $k_{1}$、$k_{2}$ 和 $k_{3}$ 为实常数。该对象与控制器构成标准负反馈回路，其中控制器作用于跟踪误差 $e=r-y$ 产生控制输入 $u=K e$，对象输出为 $y=G u$，参考信号减去测量值得到误差。\n\n从负反馈的基本框图关系和多变量反馈中回路传递的定义出发，完成以下任务：\n\n- 推导回路传递矩阵 $L(s)$ 和回差矩阵 $I+L(s)$。\n- 计算两者在 $s=0$ 处的值。\n- 然后，仅使用矩阵代数，计算在 $s=0$ 处的回差矩阵的行列式，并将其化简为以 $k_{1}$、$k_{2}$ 和 $k_{3}$ 表示的闭式解析表达式。\n\n此外，请（定性地，不使用任何未引入的简化公式）解释为什么回路传递和回差矩阵在量化多变量增益和相位裕度方面起着核心作用，特别是通过它们与灵敏度函数和余灵敏度函数的联系来解释。\n\n你最终报告的答案必须是 $\\det(I+L(0))$ 关于 $k_{1}$、$k_{2}$ 和 $k_{3}$ 的简化闭式表达式。不需要进行数值代入，也不需要四舍五入。最终答案中不要包含单位。", "solution": "该问题提法恰当，有科学依据，并包含了完整求解所需的所有信息。这是多变量控制理论中的一个标准练习。我们开始进行推导。\n\n该负反馈系统的基本关系式如下：\n$$\n\\mathbf{y}(s) = \\mathbf{G}(s) \\mathbf{u}(s)\n$$\n$$\n\\mathbf{u}(s) = \\mathbf{K} \\mathbf{e}(s)\n$$\n$$\n\\mathbf{e}(s) = \\mathbf{r}(s) - \\mathbf{y}(s)\n$$\n其中 $\\mathbf{y}(s)$ 是对象输出，$\\mathbf{u}(s)$ 是控制输入，$\\mathbf{e}(s)$ 是跟踪误差，$\\mathbf{r}(s)$ 是参考信号。\n\n首先，我们推导回路传递矩阵 $\\mathbf{L}(s)$。回路传递矩阵是从误差信号 $\\mathbf{e}(s)$ 到对象输出 $\\mathbf{y}(s)$ 的传递函数矩阵，该输出随后被反馈回求和点。结合前两个方程，我们得到：\n$$\n\\mathbf{y}(s) = \\mathbf{G}(s) (\\mathbf{K} \\mathbf{e}(s)) = (\\mathbf{G}(s)\\mathbf{K}) \\mathbf{e}(s)\n$$\n因此，回路传递矩阵定义为 $\\mathbf{L}(s) = \\mathbf{G}(s)\\mathbf{K}$。\n\n我们已知对象传递矩阵 $\\mathbf{G}(s)$ 和控制器矩阵 $\\mathbf{K}$：\n$$\n\\mathbf{G}(s)=\\begin{pmatrix}\n\\frac{1}{s+1} & \\frac{1}{s+2} \\\\\n0 & \\frac{2}{s+3}\n\\end{pmatrix}, \\quad \\mathbf{K}=\\begin{pmatrix}\nk_{1} & 0\\\\\nk_{2} & k_{3}\n\\end{pmatrix}\n$$\n我们计算乘积 $\\mathbf{L}(s) = \\mathbf{G}(s)\\mathbf{K}$：\n$$\n\\mathbf{L}(s) = \\begin{pmatrix}\n\\frac{1}{s+1} & \\frac{1}{s+2} \\\\\n0 & \\frac{2}{s+3}\n\\end{pmatrix} \\begin{pmatrix}\nk_{1} & 0\\\\\nk_{2} & k_{3}\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{1}{s+1} \\cdot k_{1} + \\frac{1}{s+2} \\cdot k_{2} & \\frac{1}{s+1} \\cdot 0 + \\frac{1}{s+2} \\cdot k_{3} \\\\\n0 \\cdot k_{1} + \\frac{2}{s+3} \\cdot k_{2} & 0 \\cdot 0 + \\frac{2}{s+3} \\cdot k_{3}\n\\end{pmatrix}\n$$\n$$\n\\mathbf{L}(s) = \\begin{pmatrix}\n\\frac{k_{1}}{s+1} + \\frac{k_{2}}{s+2} & \\frac{k_{3}}{s+2} \\\\\n\\frac{2k_{2}}{s+3} & \\frac{2k_{3}}{s+3}\n\\end{pmatrix}\n$$\n回差矩阵定义为 $\\mathbf{I}+\\mathbf{L}(s)$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。\n$$\n\\mathbf{I}+\\mathbf{L}(s) = \\begin{pmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix} + \\begin{pmatrix}\n\\frac{k_{1}}{s+1} + \\frac{k_{2}}{s+2} & \\frac{k_{3}}{s+2} \\\\\n\\frac{2k_{2}}{s+3} & \\frac{2k_{3}}{s+3}\n\\end{pmatrix} = \\begin{pmatrix}\n1 + \\frac{k_{1}}{s+1} + \\frac{k_{2}}{s+2} & \\frac{k_{3}}{s+2} \\\\\n\\frac{2k_{2}}{s+3} & 1 + \\frac{2k_{3}}{s+3}\n\\end{pmatrix}\n$$\n下一步是计算这些矩阵在 $s=0$ 处的值。首先，我们计算 $\\mathbf{L}(0)$：\n$$\n\\mathbf{L}(0) = \\begin{pmatrix}\n\\frac{k_{1}}{0+1} + \\frac{k_{2}}{0+2} & \\frac{k_{3}}{0+2} \\\\\n\\frac{2k_{2}}{0+3} & \\frac{2k_{3}}{0+3}\n\\end{pmatrix} = \\begin{pmatrix}\nk_{1} + \\frac{k_{2}}{2} & \\frac{k_{3}}{2} \\\\\n\\frac{2k_{2}}{3} & \\frac{2k_{3}}{3}\n\\end{pmatrix}\n$$\n以及在 $s=0$ 处的回差矩阵：\n$$\n\\mathbf{I}+\\mathbf{L}(0) = \\begin{pmatrix}\n1 + k_{1} + \\frac{k_{2}}{2} & \\frac{k_{3}}{2} \\\\\n\\frac{2k_{2}}{3} & 1 + \\frac{2k_{3}}{3}\n\\end{pmatrix}\n$$\n现在，我们按要求计算在 $s=0$ 处的回差矩阵的行列式。\n$$\n\\det(\\mathbf{I}+\\mathbf{L}(0)) = \\left(1 + k_{1} + \\frac{k_{2}}{2}\\right) \\left(1 + \\frac{2k_{3}}{3}\\right) - \\left(\\frac{k_{3}}{2}\\right) \\left(\\frac{2k_{2}}{3}\\right)\n$$\n我们展开乘积：\n$$\n\\det(\\mathbf{I}+\\mathbf{L}(0)) = 1\\left(1 + \\frac{2k_{3}}{3}\\right) + k_{1}\\left(1 + \\frac{2k_{3}}{3}\\right) + \\frac{k_{2}}{2}\\left(1 + \\frac{2k_{3}}{3}\\right) - \\frac{2k_{2}k_{3}}{6}\n$$\n$$\n\\det(\\mathbf{I}+\\mathbf{L}(0)) = 1 + \\frac{2k_{3}}{3} + k_{1} + \\frac{2k_{1}k_{3}}{3} + \\frac{k_{2}}{2} + \\frac{2k_{2}k_{3}}{6} - \\frac{k_{2}k_{3}}{3}\n$$\n注意到 $\\frac{2k_{2}k_{3}}{6} = \\frac{k_{2}k_{3}}{3}$，最后两项相互抵消。这就得到了简化后的表达式：\n$$\n\\det(\\mathbf{I}+\\mathbf{L}(0)) = 1 + k_{1} + \\frac{k_{2}}{2} + \\frac{2k_{3}}{3} + \\frac{2k_{1}k_{3}}{3}\n$$\n这就是所要求的闭式解析表达式。\n\n此外，还需要进行定性解释。闭环系统的稳定性由其极点的位置决定，这些极点是特征方程 $\\det(\\mathbf{I}+\\mathbf{L}(s)) = 0$ 的根。对于单输入单输出（SISO）情况，这简化为 $1+L(s)=0$。奈奎斯特（Nyquist）稳定性判据通过考察频率响应 $L(j\\omega)$ 对临界点 $-1$ 的环绕情况来判断稳定性。距离 $|1+L(j\\omega)|$ 是鲁棒性的一个度量；其值小表明系统接近不稳定。\n\n在多输入多输出（MIMO）情况下，回差矩阵 $\\mathbf{I}+\\mathbf{L}(s)$ 扮演着类似的角色。广义奈奎斯特判据指出，对于开环稳定的系统，如果当 $\\omega \\in [-\\infty, \\infty]$ 时，$\\det(\\mathbf{I}+\\mathbf{L}(j\\omega))$ 的轨迹不环绕原点，则闭环系统是稳定的。$\\det(\\mathbf{I}+\\mathbf{L}(j\\omega))$ 的值是标量距离 $1+L(j\\omega)$（到临界点的距离）在多变量系统中的等效量。一个接近零的值表明系统正接近不稳定状态。因此，诸如 $\\mathbf{I}+\\mathbf{L}(j\\omega)$ 的最小奇异值 $\\sigma_{\\min}(\\mathbf{I}+\\mathbf{L}(j\\omega))$ 等量，通过量化矩阵 $\\mathbf{I}+\\mathbf{L}(j\\omega)$ 离奇异的接近程度，为多变量增益和相位裕度提供了鲁棒的度量。\n\n此外，回差矩阵通过灵敏度函数 $\\mathbf{S}(s) = (\\mathbf{I}+\\mathbf{L}(s))^{-1}$ 和余灵敏度函数 $\\mathbf{T}(s) = \\mathbf{L}(s)(\\mathbf{I}+\\mathbf{L}(s))^{-1}$ 与系统性能有着根本的联系。灵敏度函数 $\\mathbf{S}(s)$ 将参考指令和输出扰动映射到跟踪误差。为获得良好性能（跟踪和扰动抑制），$\\mathbf{S}(s)$ 在低频时必须很小，这要求 $\\mathbf{L}(s)$ 要“大”。余灵敏度函数 $\\mathbf{T}(s)$ 将传感器噪声映射到对象输出。为保证对噪声和模型不确定性的鲁棒性，$\\mathbf{T}(s)$ 在高频时必须很小，这要求 $\\mathbf{L}(s)$ 要“小”。因此，$\\mathbf{I}+\\mathbf{L}(s)$ 在所有频率上的行为决定了性能与鲁棒性之间的基本权衡，其行列式决定了闭环系统的绝对稳定性。", "answer": "$$\n\\boxed{1 + k_{1} + \\frac{k_{2}}{2} + \\frac{2k_{3}}{3} + \\frac{2k_{1}k_{3}}{3}}\n$$", "id": "2713799"}, {"introduction": "理论分析为我们提供了框架，而计算实践则揭示了理论在复杂动态中的具体表现。这项练习将你带入一个计算场景，通过评估灵敏度函数 $S(j\\omega)$ 和互补灵敏度函数 $T(j\\omega)$ 的奇异值，来量化MIMO系统中固有的交互耦合效应[@problem_id:2713822]。你将通过编程发现，即使采用简单的对角控制器，被控对象各通道间的耦合（非对角项）也可能导致性能指标出现意想不到的峰值，这直观地证明了为何必须使用多变量工具来分析和设计鲁棒的MIMO控制器。", "problem": "考虑一个双输入双输出被控对象与一个对角控制器的标准负反馈互联结构。设被控对象在 Laplace 域中由传递矩阵 $G(s) \\in \\mathbb{C}^{2 \\times 2}$ 给出，其元素为\n- $g_{11}(s) = \\dfrac{2}{(s+1)(0.5\\,s+1)}$,\n- $g_{22}(s) = \\dfrac{3}{(s+2)(0.2\\,s+1)}$,\n- $g_{12}(s) = c \\cdot \\dfrac{0.5}{s+1}$,\n- $g_{21}(s) = -\\,c \\cdot \\dfrac{0.4}{s+0.2}$,\n其中 $c \\in \\mathbb{R}$ 是一个控制非对角交互水平的标量。控制器是对角的，\n$K(s) = \\mathrm{diag}(k_1, k_2)$,\n其中 $k_1 = 1.5$ 且 $k_2 = 1.2$。假设为单位负反馈，且所有互联都是适定的。\n\n仅使用负反馈的闭环基本定义和频率响应评估方法，完成以下任务：\n- 从框图方程和代数消元出发，推导灵敏度矩阵 $S(j\\omega)$ 和互补灵敏度矩阵 $T(j\\omega)$ 关于 $G(j\\omega)$ 和 $K(j\\omega)$ 的表达式。除已声明的结构外，不要假设任何特殊结构，并且不要从预先记忆的闭环公式开始。\n- 对于每个频率 $\\omega$，将 $S(j\\omega)$ 和 $T(j\\omega)$ 解释为复数矩阵，并量化其最大奇异值。最大奇异值定义为诱导 2-范数，即 $M(j\\omega)^{*} M(j\\omega)$ 的最大特征值的平方根，其中 $M \\in \\{S, T\\}$ 且 $(\\cdot)^{*}$ 表示共轭转置。\n\n定义角频率的分析网格在 $\\omega \\in [10^{-2}, 10^{3}]$ 弧度/秒内对数间隔分布，使用 $N = 2000$ 个点。对于下面指定的每个 $c$ 值，计算：\n- $S(j\\omega)$ 最大奇异值的峰值（即对 $\\omega$ 的最大值），记为 $\\max_{\\omega}\\,\\bar{\\sigma}(S(j\\omega))$。\n- $T(j\\omega)$ 最大奇异值的峰值（即对 $\\omega$ 的最大值），记为 $\\max_{\\omega}\\,\\bar{\\sigma}(T(j\\omega))$。\n\n为分析交互引起的峰值，使用纯对角参考被控对象 $G_{\\mathrm{diag}}(s)$，该对象通过设置 $c=0$ 获得，同时保持相同的对角元素和相同的控制器。对于每个 $c$，定义比率\n- $R_S(c) = \\dfrac{\\max_{\\omega}\\,\\bar{\\sigma}(S_{\\mathrm{MIMO}}(j\\omega;c))}{\\max_{\\omega}\\,\\bar{\\sigma}(S_{\\mathrm{diag}}(j\\omega))}$,\n- $R_T(c) = \\dfrac{\\max_{\\omega}\\,\\bar{\\sigma}(T_{\\mathrm{MIMO}}(j\\omega;c))}{\\max_{\\omega}\\,\\bar{\\sigma}(T_{\\mathrm{diag}}(j\\omega))}$,\n并报告布尔标志\n- $\\text{peakS}(c) = \\text{True}$ 如果 $R_S(c) > \\tau$, 否则为 $\\text{False}$,\n- $\\text{peakT}(c) = \\text{True}$ 如果 $R_T(c) > \\tau$, 否则为 $\\text{False}$,\n阈值为 $\\tau=1.05$。\n\n测试组：\n- 使用三个值 $c \\in \\{0.0, 0.3, 0.8\\}$。\n\n数值与输出要求：\n- 通过将 $s = j\\omega$ 代入每个标量元素来评估 $G(j\\omega)$。\n- 将每个测试用例的两个峰值表示为四舍五入到六位小数的实数。\n- 布尔标志必须根据上述比率和 $\\tau=1.05$ 计算得出。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按 $c = 0.0, c = 0.3, c = 0.8$ 的顺序，为每个 $c$ 连接四个项目 $[\\max_{\\omega}\\,\\bar{\\sigma}(S), \\max_{\\omega}\\,\\bar{\\sigma}(T), \\text{peakS}, \\text{peakT}]$，每个峰值四舍五入到六位小数，每个布尔值作为不带引号的字面量，最终形成一个长度为12的扁平列表。例如，输出格式必须为 $[\\text{val}_{1},\\text{val}_{2},\\text{bool}_{1},\\text{bool}_{2},\\ldots]$，不含任何附加文本。", "solution": "该问题经过验证。所有给定条件，包括被控对象传递矩阵 $G(s)$、对角控制器 $K(s)$、反馈配置和分析任务，都已明确说明。该问题在科学上基于标准的多输入多输出 (MIMO) 控制理论，利用了灵敏度函数、频率响应和奇异值分析等概念。问题是适定的、客观的，并包含足够的信息以获得唯一解。不存在矛盾、歧义或事实不准确之处。因此，该问题被视为**有效的**，我将继续提供解答。\n\n这个问题的基础是对一个线性时不变 (LTI) 负反馈系统进行代数分析。系统行为由被控对象 $G(s)$ 和控制器 $K(s)$ 的互联描述。我们给出了参考信号 $R(s)$、误差信号 $E(s)$、控制器输出信号 $U(s)$ 和被控对象输出信号 $Y(s)$ 的向量信号，它们都处于 Laplace 域。系统动态由以下方程决定：\n$$Y(s) = G(s)U(s) \\quad (\\text{被控对象})$$\n$$U(s) = K(s)E(s) \\quad (\\text{控制器})$$\n$$E(s) = R(s) - Y(s) \\quad (\\text{负反馈误差})$$\n该任务要求从第一性原理出发推导闭环传递矩阵。\n\n首先，我们推导互补灵敏度矩阵 $T(s)$，它是从参考输入 $R(s)$ 到被控对象输出 $Y(s)$ 的闭环传递函数。我们通过代数代换消去内部信号 $E(s)$ 和 $U(s)$ 来实现：\n$$Y(s) = G(s)U(s) = G(s)K(s)E(s)$$\n代入误差 $E(s)$ 的表达式：\n$$Y(s) = G(s)K(s)(R(s) - Y(s))$$\n我们展开此表达式，并对包含 $Y(s)$ 的项进行分组：\n$$Y(s) = G(s)K(s)R(s) - G(s)K(s)Y(s)$$\n$$IY(s) + G(s)K(s)Y(s) = G(s)K(s)R(s)$$\n此处，$I$ 是适当维度的单位矩阵，本例中为 $2 \\times 2$。将 $Y(s)$ 因子提出得到：\n$$(I + G(s)K(s))Y(s) = G(s)K(s)R(s)$$\n为分离出 $Y(s)$，我们左乘 $(I + G(s)K(s))$ 的逆矩阵：\n$$Y(s) = (I + G(s)K(s))^{-1}G(s)K(s)R(s)$$\n根据定义，$Y(s) = T(s)R(s)$，因此互补灵敏度矩阵为：\n$$T(s) = (I + L(s))^{-1}L(s)$$\n其中 $L(s) = G(s)K(s)$ 是回路传递矩阵。\n\n接下来，我们推导灵敏度矩阵 $S(s)$，它是从参考信号 $R(s)$ 到误差信号 $E(s)$ 的闭环传递函数。从误差的定义开始：\n$$E(s) = R(s) - Y(s)$$\n代入 $Y(s) = T(s)R(s)$：\n$$E(s) = R(s) - T(s)R(s) = (I - T(s))R(s)$$\n因此，我们得到恒等式 $S(s) = I - T(s)$。通过代入 $T(s)$ 的表达式，我们可以用回路矩阵 $L(s)$ 来表示 $S(s)$：\n$$S(s) = I - (I + L(s))^{-1}L(s)$$\n为简化，我们将 $I$ 写为 $(I + L(s))^{-1}(I + L(s))$：\n$$S(s) = (I + L(s))^{-1}(I + L(s)) - (I + L(s))^{-1}L(s)$$\n$$S(s) = (I + L(s))^{-1}(I + L(s) - L(s))$$\n这可以简化为灵敏度矩阵的规范形式：\n$$S(s) = (I + L(s))^{-1}$$\n\n分析在频域中进行，方法是令 $s = j\\omega$，其中 $j$ 是虚数单位，$\\omega$ 是角频率。在每个频率下，所得复数矩阵 $S(j\\omega)$ 和 $T(j\\omega)$ 的“大小”通过其最大奇异值 $\\bar{\\sigma}(\\cdot)$ 来量化，该值对应于诱导 2-范数。最大奇异值定义为 $\\bar{\\sigma}(M) = \\sqrt{\\lambda_{\\max}(M^*M)}$，其中 $M^*$ 是 $M$ 的共轭转置，$\\lambda_{\\max}$ 表示最大特征值。\n\n数值计算步骤如下。给定被控对象：\n$$G(s) = \\begin{pmatrix} \\frac{2}{(s+1)(0.5s+1)} & c \\cdot \\frac{0.5}{s+1} \\\\ -c \\cdot \\frac{0.4}{s+0.2} & \\frac{3}{(s+2)(0.2s+1)} \\end{pmatrix}$$\n和控制器：\n$$K(s) = \\begin{pmatrix} 1.5 & 0 \\\\ 0 & 1.2 \\end{pmatrix}$$\n创建一个包含 $N=2000$ 个频率 $\\omega_k$ 的网格，在 $10^{-2}$ 到 $10^3$ rad/s 范围内对数间隔分布。对于 $c \\in \\{0.0, 0.3, 0.8\\}$ 中的每个值，以及网格中的每个频率 $\\omega_k$：\n1. 计算复数值 $s_k = j\\omega_k$。\n2. 通过代入 $s_k$ 来构建复数矩阵 $G(j\\omega_k)$。\n3. 计算回路传递矩阵 $L(j\\omega_k) = G(j\\omega_k)K$。\n4. 使用数值稳定的矩阵求逆方法计算灵敏度矩阵 $S(j\\omega_k) = (I + L(j\\omega_k))^{-1}$ 和 $T(j\\omega_k) = S(j\\omega_k)L(j\\omega_k)$。\n5. 通过奇异值分解 (Singular Value Decomposition, SVD) 计算最大奇异值 $\\bar{\\sigma}(S(j\\omega_k))$ 和 $\\bar{\\sigma}(T(j\\omega_k))$。\n6. 这些奇异值在所有频率上的最大值被记录为 $\\max_{\\omega} \\bar{\\sigma}(S)$ 和 $\\max_{\\omega} \\bar{\\sigma}(T)$。\n\n$c=0$ 的情况确立了解耦系统的基准性能，得到 $\\max_{\\omega}\\bar{\\sigma}(S_{\\text{diag}})$ 和 $\\max_{\\omega}\\bar{\\sigma}(T_{\\text{diag}})$。对于每个 $c$，由耦合引起的性能下降通过以下比率进行评估：\n$$R_S(c) = \\frac{\\max_{\\omega}\\bar{\\sigma}(S_{\\mathrm{MIMO}}(j\\omega; c))}{\\max_{\\omega}\\bar{\\sigma}(S_{\\mathrm{diag}}(j\\omega))}, \\quad R_T(c) = \\frac{\\max_{\\omega}\\bar{\\sigma}(T_{\\mathrm{MIMO}}(j\\omega; c))}{\\max_{\\omega}\\bar{\\sigma}(T_{\\mathrm{diag}}(j\\omega))}$$\n这些比率与阈值 $\\tau = 1.05$ 进行比较，以生成布尔标志 $\\text{peakS}(c)$ 和 $\\text{peakT}(c)$，指示是否存在显著峰值。最终结果按规定格式收集和整理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the MIMO sensitivity analysis problem.\n    \"\"\"\n    # Define system parameters and analysis grid\n    k1 = 1.5\n    k2 = 1.2\n    K = np.diag([k1, k2])\n    N = 2000\n    omega_grid = np.logspace(-2, 3, N)\n    c_values = [0.0, 0.3, 0.8]\n    tau = 1.05\n    I = np.identity(2)\n    \n    test_cases = c_values\n    \n    # Dictionary to store the peak singular values for each c\n    peak_results = {}\n\n    # Iterate over each test case for the coupling parameter c\n    for c in test_cases:\n        max_sigma_S = 0.0\n        max_sigma_T = 0.0\n        \n        # Iterate over each frequency in the grid\n        for w in omega_grid:\n            s = 1j * w\n            \n            # Evaluate the plant transfer matrix G(jw)\n            g11 = 2 / ((s + 1) * (0.5 * s + 1))\n            g22 = 3 / ((s + 2) * (0.2 * s + 1))\n            g12 = c * 0.5 / (s + 1)\n            g21 = -c * 0.4 / (s + 0.2)\n            G = np.array([[g11, g12], [g21, g22]], dtype=complex)\n            \n            # Compute the loop transfer matrix L(jw)\n            L = G @ K\n            \n            # Compute sensitivity S(jw) and complementary sensitivity T(jw)\n            # Using np.linalg.solve for numerical stability (solves (I+L)X = I for X)\n            S = np.linalg.solve(I + L, I)\n            T = S @ L\n            \n            # Compute singular values using SVD. svd returns them in descending order.\n            sigma_S = np.linalg.svd(S, compute_uv=False)\n            sigma_T = np.linalg.svd(T, compute_uv=False)\n            \n            # The largest singular value is the first element\n            current_max_sigma_S = sigma_S[0]\n            current_max_sigma_T = sigma_T[0]\n            \n            # Update the peak values found so far\n            if current_max_sigma_S > max_sigma_S:\n                max_sigma_S = current_max_sigma_S\n            \n            if current_max_sigma_T > max_sigma_T:\n                max_sigma_T = current_max_sigma_T\n                \n        # Store the peak values for the current c\n        peak_results[c] = (max_sigma_S, max_sigma_T)\n\n    # Get the baseline (diagonal) results from c = 0.0\n    peak_S_diag, peak_T_diag = peak_results[0.0]\n\n    all_results = []\n    # Process each test case to compute ratios and flags\n    for c in test_cases:\n        peak_S_mimo, peak_T_mimo = peak_results[c]\n        \n        # Calculate ratios relative to the diagonal case\n        # Guard against division by zero, although not expected in this problem\n        if peak_S_diag != 0:\n            R_S = peak_S_mimo / peak_S_diag\n        else:\n            R_S = float('inf') if peak_S_mimo > 0 else 1.0\n\n        if peak_T_diag != 0:\n            R_T = peak_T_mimo / peak_T_diag\n        else:\n            R_T = float('inf') if peak_T_mimo > 0 else 1.0\n\n        # Determine boolean flags based on the threshold tau\n        peakS_flag = R_S > tau\n        peakT_flag = R_T > tau\n        \n        # Append formatted results to the final list\n        all_results.extend([\n            f\"{peak_S_mimo:.6f}\",\n            f\"{peak_T_mimo:.6f}\",\n            str(peakS_flag),\n            str(peakT_flag)\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2713822"}]}