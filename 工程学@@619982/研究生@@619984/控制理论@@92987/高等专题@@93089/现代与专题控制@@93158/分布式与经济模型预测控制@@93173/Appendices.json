{"hands_on_practices": [{"introduction": "对偶分解为协调多个智能体以遵循共享资源限制提供了一种优雅的、基于价格的机制。本练习提供了一个对偶上升迭代的具体分步计算，展示了智能体如何响应中心价格，以及该价格如何根据资源不平衡进行更新。掌握这一基本机制是理解更复杂分布式优化方案的第一步。[@problem_id:2701668]", "problem": "考虑一个分布式经济模型预测控制 (MPC) 方案中的单个协调步骤，该方案包含两个具有标量输入的子系统。在给定的预测步，集中式阶段问题是在共享资源平衡的条件下，最小化局部经济成本之和。局部经济阶段成本是严格凸二次函数，由 $J_{1}(u_{1})=\\tfrac{1}{2} q_{1} u_{1}^{2}+r_{1} u_{1}$ 和 $J_{2}(u_{2})=\\tfrac{1}{2} q_{2} u_{2}^{2}+r_{2} u_{2}$ 给出，并且各自具有输入约束 $u_{1} \\in [u_{1}^{\\min},u_{1}^{\\max}]$ 和 $u_{2} \\in [u_{2}^{\\min},u_{2}^{\\max}]$。各智能体通过资源平衡等式约束 $u_{1}+u_{2}=\\bar{u}$ 耦合。\n\n从等式约束凸规划的拉格朗日函数定义出发，使用耦合约束残差作为次梯度，对对偶函数进行次梯度上升，按如下方式执行一次对偶上升迭代：\n- 对于给定的当前价格（对偶变量）$\\lambda_{k}$，通过最小化关于 $u_{1}$ 和 $u_{2}$ 的局部拉格朗日函数，并在各自的箱式约束下，计算局部最优输入。\n- 使用恒定步长 $\\alpha$ 更新价格。\n\n此步骤使用以下数据：\n- $q_{1}=2$, $r_{1}=-3$, $u_{1}^{\\min}=0$, $u_{1}^{\\max}=2$.\n- $q_{2}=1$, $r_{2}=2$, $u_{2}^{\\min}=-3$, $u_{2}^{\\max}=1$.\n- 耦合参数 $\\bar{u}=-\\tfrac{3}{2}$.\n- 当前价格 $\\lambda_{k}=\\tfrac{6}{5}$.\n- 步长 $\\alpha=\\tfrac{1}{2}$.\n\n将这次对偶上升迭代的结果报告为行向量 $\\big(u_{1,k}^{\\star},\\,u_{2,k}^{\\star},\\,\\lambda_{k+1}\\big)$。\n\n你的最终答案必须是单个行矩阵。无需四舍五入，你必须给出精确值（可接受分数形式）。不要包含任何单位。", "solution": "所给问题是凸优化领域一个有效、适定的练习，具体是对偶分解在分布式经济模型预测控制场景中的一个应用。所有必要的参数都已提供，问题在科学上是合理的。我们开始求解。\n\n集中式优化问题是在局部约束和耦合约束下，最小化总经济成本，即局部成本 $J_{1}(u_{1})$ 和 $J_{2}(u_{2})$ 之和。\n该问题表述为：\n$$\n\\min_{u_{1}, u_{2}} \\quad J_{1}(u_{1}) + J_{2}(u_{2}) = \\left(\\frac{1}{2} q_{1} u_{1}^{2} + r_{1} u_{1}\\right) + \\left(\\frac{1}{2} q_{2} u_{2}^{2} + r_{2} u_{2}\\right)\n$$\n约束条件为：\n$$\nu_{1} + u_{2} = \\bar{u} \\\\\nu_{1} \\in [u_{1}^{\\min}, u_{1}^{\\max}] \\\\\nu_{2} \\in [u_{2}^{\\min}, u_{2}^{\\max}]\n$$\n这是一个凸优化问题，因为目标函数是严格凸二次函数之和（由于 $q_{1} > 0$ 且 $q_{2} > 0$），并且约束定义了一个凸集。\n\n为了使用对偶分解以分布式方式解决此问题，我们通过引入拉格朗日乘子（或称对偶变量）$\\lambda$ 来松弛耦合约束 $u_{1} + u_{2} - \\bar{u} = 0$。拉格朗日函数 $L(u_{1}, u_{2}, \\lambda)$ 为：\n$$\nL(u_{1}, u_{2}, \\lambda) = J_{1}(u_{1}) + J_{2}(u_{2}) + \\lambda(u_{1} + u_{2} - \\bar{u})\n$$\n拉格朗日函数可以分解为对应于每个子系统的部分：\n$$\nL(u_{1}, u_{2}, \\lambda) = \\left( J_{1}(u_{1}) + \\lambda u_{1} \\right) + \\left( J_{2}(u_{2}) + \\lambda u_{2} \\right) - \\lambda \\bar{u}\n$$\n我们为每个子系统 $i \\in \\{1, 2\\}$ 定义局部拉格朗日函数：\n$$\nL_{i}(u_{i}, \\lambda) = J_{i}(u_{i}) + \\lambda u_{i}\n$$\n对偶上升算法在每次迭代 $k$ 中按以下两个步骤进行：\n$1$. 对于给定的价格 $\\lambda_{k}$，每个子系统独立求解其局部优化问题，以找到最优输入 $u_{1,k}^{\\star}$ 和 $u_{2,k}^{\\star}：$\n$$\nu_{i,k}^{\\star} = \\arg\\min_{u_{i} \\in [u_{i}^{\\min}, u_{i}^{\\max}]} L_{i}(u_{i}, \\lambda_{k})\n$$\n$2$. 使用次梯度上升法更新价格 $\\lambda_{k}$，其中次梯度是松弛耦合约束的残差。更新规则为：\n$$\n\\lambda_{k+1} = \\lambda_{k} + \\alpha (u_{1,k}^{\\star} + u_{2,k}^{\\star} - \\bar{u})\n$$\n其中 $\\alpha > 0$ 是步长。\n\n我们现在使用给定数据执行一次迭代：\n- $q_{1}=2$, $r_{1}=-3$, $u_{1}^{\\min}=0$, $u_{1}^{\\max}=2$.\n- $q_{2}=1$, $r_{2}=2$, $u_{2}^{\\min}=-3$, $u_{2}^{\\max}=1$.\n- $\\bar{u}=-\\frac{3}{2}$.\n- 初始价格 $\\lambda_{k}=\\frac{6}{5}$.\n- 步长 $\\alpha=\\frac{1}{2}$.\n\n首先，我们求解 $u_{1}$ 和 $u_{2}$ 的局部最小化问题。\n对于子系统 1：\n$$\nL_{1}(u_{1}, \\lambda_{k}) = \\frac{1}{2} q_{1} u_{1}^{2} + r_{1} u_{1} + \\lambda_{k} u_{1} = \\frac{1}{2} (2) u_{1}^{2} + (-3) u_{1} + \\frac{6}{5} u_{1} = u_{1}^{2} - \\frac{9}{5} u_{1}\n$$\n为了找到无约束最小值，我们将关于 $u_{1}$ 的导数设为零：\n$$\n\\frac{\\partial L_{1}}{\\partial u_{1}} = 2 u_{1} - \\frac{9}{5} = 0 \\implies u_{1}^{\\text{unc}} = \\frac{9}{10}\n$$\n$u_{1}$ 的局部约束为 $[0, 2]$。因为 $0 \\le \\frac{9}{10} \\le 2$，所以无约束最小值是可行的。因此，最优局部输入为：\n$$\nu_{1,k}^{\\star} = \\frac{9}{10}\n$$\n\n对于子系统 2：\n$$\nL_{2}(u_{2}, \\lambda_{k}) = \\frac{1}{2} q_{2} u_{2}^{2} + r_{2} u_{2} + \\lambda_{k} u_{2} = \\frac{1}{2} (1) u_{2}^{2} + (2) u_{2} + \\frac{6}{5} u_{2} = \\frac{1}{2} u_{2}^{2} + \\frac{16}{5} u_{2}\n$$\n为了找到无约束最小值，我们将关于 $u_{2}$ 的导数设为零：\n$$\n\\frac{\\partial L_{2}}{\\partial u_{2}} = u_{2} + \\frac{16}{5} = 0 \\implies u_{2}^{\\text{unc}} = -\\frac{16}{5} = -3.2\n$$\n$u_{2}$ 的局部约束为 $[-3, 1]$。由于 $u_{2}^{\\text{unc}} = -3.2 < -3$，凸函数 $L_{2}$ 在该区间上的最小值位于下界。因此，最优局部输入为：\n$$\nu_{2,k}^{\\star} = u_{2}^{\\min} = -3\n$$\n\n接下来，我们更新价格 $\\lambda$。耦合约束的残差为：\n$$\ns_{k} = u_{1,k}^{\\star} + u_{2,k}^{\\star} - \\bar{u} = \\frac{9}{10} + (-3) - \\left(-\\frac{3}{2}\\right) = \\frac{9}{10} - \\frac{30}{10} + \\frac{15}{10} = \\frac{9 - 30 + 15}{10} = -\\frac{6}{10} = -\\frac{3}{5}\n$$\n更新后的价格 $\\lambda_{k+1}$ 计算如下：\n$$\n\\lambda_{k+1} = \\lambda_{k} + \\alpha s_{k} = \\frac{6}{5} + \\frac{1}{2} \\left(-\\frac{3}{5}\\right) = \\frac{6}{5} - \\frac{3}{10} = \\frac{12}{10} - \\frac{3}{10} = \\frac{9}{10}\n$$\n\n这次单次对偶上升迭代的结果是行向量 $(u_{1,k}^{\\star}, u_{2,k}^{\\star}, \\lambda_{k+1})$。\n代入计算出的值，我们得到：\n$$\n\\left( \\frac{9}{10}, -3, \\frac{9}{10} \\right)\n$$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{9}{10} & -3 & \\frac{9}{10} \\end{pmatrix}}$$", "id": "2701668"}, {"introduction": "交替方向乘子法 (Alternating Direction Method of Multipliers, ADMM) 是分布式凸优化的主力算法，因其强大的收敛特性而备受推崇。在此实践中，你将对一个资源分配问题执行单次 ADMM 迭代，亲身体验其独特的原始变量和对偶变量更新步骤。通过计算原始残差和对偶残差，你还将清楚地了解在实践中如何监控 ADMM 的收敛过程。[@problem_id:2701685]", "problem": "考虑一个源于经济模型预测控制 (eMPC) 中单步时域的双智能体资源分配子问题。每个智能体 $i \\in \\{1,2\\}$ 选择一个标量决策变量 $x_i$（局部输入），且总资源使用量必须满足一个施加了共享容量的线性耦合约束。该集中式二次规划问题是\n在约束 $x_1 + x_2 = s$ 下，对 $x_1, x_2$ 最小化函数 $\\frac{1}{2} q_1 x_1^2 + p_1 x_1 + \\frac{1}{2} q_2 x_2^2 + p_2 x_2$，\n其中 $q_1, q_2 > 0$ 和 $p_1, p_2 \\in \\mathbb{R}$ 分别代表局部的二次和线性经济惩罚项，而 $s \\in \\mathbb{R}$ 是总资源设定点。\n\n为模拟分布式模型预测控制 (dMPC)，对上述问题执行一次（从 $k=0$ 到 $k=1$）尺度交替方向乘子法 (ADMM) 迭代，将线性约束视为 $A x_1 + B x_2 = s$（其中 $A = 1$ 且 $B = 1$），并使用尺度对偶变量 $u$ 和惩罚参数 $\\rho > 0$。\n\n使用以下数值数据：\n- $q_1 = 2$, $p_1 = 1$,\n- $q_2 = 4$, $p_2 = -2$,\n- $s = 1$,\n- $\\rho = 1$,\n- 初始值 $x_1^{(0)} = 0$, $x_2^{(0)} = 0.5$, $u^{(0)} = 0$。\n\n在执行这次单次 ADMM 迭代后，计算与 $k=1$ 时的尺度 ADMM 迭代相关的原始残差 $r^{(1)}$ 和对偶残差 $s^{(1)}$。然后，取两个残差的欧几里得范数（对于这些标量，即绝对值）中的较大者。将最终答案四舍五入至四位有效数字。将最终答案表示为一个无单位的标量。", "solution": "所给出的问题是一个带有线性等式约束的标准二次规划问题，这是经济和分布式模型预测控制中一个常见的子问题。任务是应用一次尺度交替方向乘子法 (ADMM) 迭代，并计算由此产生的原始残差和对偶残差。\n\n首先，必须确认问题的有效性。\n\n步骤 1：提取已知条件\n问题提供了以下信息：\n- 待最小化的目标函数：$f(x_1, x_2) = \\frac{1}{2} q_1 x_1^2 + p_1 x_1 + \\frac{1}{2} q_2 x_2^2 + p_2 x_2$\n- 约束条件：$x_1 + x_2 = s$\n- 参数约束：$q_1, q_2 > 0$ 和 $p_1, p_2 \\in \\mathbb{R}$, $s \\in \\mathbb{R}$\n- ADMM 公式：约束被视为 $A x_1 + B x_2 = s$，其中 $A=1$ 且 $B=1$。该算法使用一个尺度对偶变量 $u$ 和一个惩罚参数 $\\rho > 0$。\n- 数值数据：\n    - $q_1 = 2$, $p_1 = 1$\n    - $q_2 = 4$, $p_2 = -2$\n    - $s = 1$\n    - $\\rho = 1$\n- ADMM 迭代的初始值 ($k=0$)：\n    - $x_1^{(0)} = 0$\n    - $x_2^{(0)} = 0.5$\n    - $u^{(0)} = 0$\n- 任务：在一次迭代后 ($k=1$) 计算原始残差 $r^{(1)}$ 和对偶残差 $s^{(1)}$，并找出它们的欧几里得范数（对于标量即绝对值）中的较大者，结果四舍五入至四位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n该问题在优化和控制理论方面具有科学依据。由于 $q_1 > 0$ 和 $q_2 > 0$，目标函数是严格凸的，且约束是线性的，这定义了一个适定的二次规划问题。ADMM 是以分布式方式解决此类问题的标准、正确的算法。所有术语（$dMPC$, $eMPC$, $ADMM$, 尺度对偶变量, 残差）都使用正确。问题是客观的，提供了清晰的数值数据和精确的计算任务。没有矛盾、缺失信息或伪科学元素。该问题是有效的。\n\n步骤 3：结论与行动\n问题有效。将提供解答。\n\n问题的一般形式是在约束 $A x_1 + B x_2 = s$ 下最小化 $f_1(x_1) + f_2(x_2)$，其中 $f_1(x_1) = \\frac{1}{2} q_1 x_1^2 + p_1 x_1$ 且 $f_2(x_2) = \\frac{1}{2} q_2 x_2^2 + p_2 x_2$。\n尺度 ADMM 算法在第 $k$ 次迭代时包含以下更新序列：\n1. $x_1^{(k+1)} := \\arg\\min_{x_1} \\left( f_1(x_1) + \\frac{\\rho}{2} \\| A x_1 + B x_2^{(k)} - s + u^{(k)} \\|_2^2 \\right)$\n2. $x_2^{(k+1)} := \\arg\\min_{x_2} \\left( f_2(x_2) + \\frac{\\rho}{2} \\| A x_1^{(k+1)} + B x_2 - s + u^{(k)} \\|_2^2 \\right)$\n3. $u^{(k+1)} := u^{(k)} + A x_1^{(k+1)} + B x_2^{(k+1)} - s$\n\n对于这个特定问题，$A=1$ 和 $B=1$，且所有变量都是标量。更新步骤变为：\n1. $x_1^{(k+1)} := \\arg\\min_{x_1} \\left( \\frac{1}{2} q_1 x_1^2 + p_1 x_1 + \\frac{\\rho}{2} (x_1 + x_2^{(k)} - s + u^{(k)})^2 \\right)$\n2. $x_2^{(k+1)} := \\arg\\min_{x_2} \\left( \\frac{1}{2} q_2 x_2^2 + p_2 x_2 + \\frac{\\rho}{2} (x_1^{(k+1)} + x_2 - s + u^{(k)})^2 \\right)$\n3. $u^{(k+1)} := u^{(k)} + x_1^{(k+1)} + x_2^{(k+1)} - s$\n\n为了找到 $x_1$ 和 $x_2$ 更新的最小值点，我们将相应目标函数的导数设为零。\n对于 $x_1$ 的更新：\n$q_1 x_1 + p_1 + \\rho (x_1 + x_2^{(k)} - s + u^{(k)}) = 0$\n$(q_1 + \\rho) x_1 = -p_1 - \\rho (x_2^{(k)} - s + u^{(k)})$\n$x_1^{(k+1)} = \\frac{-p_1 - \\rho (x_2^{(k)} - s + u^{(k)})}{q_1 + \\rho}$\n\n对于 $x_2$ 的更新：\n$q_2 x_2 + p_2 + \\rho (x_1^{(k+1)} + x_2 - s + u^{(k)}) = 0$\n$(q_2 + \\rho) x_2 = -p_2 - \\rho (x_1^{(k+1)} - s + u^{(k)})$\n$x_2^{(k+1)} = \\frac{-p_2 - \\rho (x_1^{(k+1)} - s + u^{(k)})}{q_2 + \\rho}$\n\n我们现在使用所提供的数值数据，执行一次从 $k=0$ 到 $k=1$ 的迭代：\n$q_1 = 2, q_2 = 4, p_1 = 1, p_2 = -2, s = 1, \\rho = 1$。\n初始条件：$x_1^{(0)} = 0, x_2^{(0)} = 0.5, u^{(0)} = 0$。\n\n首先，计算 $x_1^{(1)}$：\n$$x_1^{(1)} = \\frac{-p_1 - \\rho (x_2^{(0)} - s + u^{(0)})}{q_1 + \\rho} = \\frac{-1 - 1 (0.5 - 1 + 0)}{2 + 1} = \\frac{-1 - (-0.5)}{3} = \\frac{-0.5}{3} = -\\frac{1}{6}$$\n\n接下来，使用新计算出的 $x_1^{(1)}$ 计算 $x_2^{(1)}$：\n$$x_2^{(1)} = \\frac{-p_2 - \\rho (x_1^{(1)} - s + u^{(0)})}{q_2 + \\rho} = \\frac{-(-2) - 1 (-\\frac{1}{6} - 1 + 0)}{4 + 1} = \\frac{2 - (-\\frac{7}{6})}{5} = \\frac{2 + \\frac{7}{6}}{5} = \\frac{\\frac{12+7}{6}}{5} = \\frac{19/6}{5} = \\frac{19}{30}$$\n\n最后，计算对偶变量的更新 $u^{(1)}$：\n$$u^{(1)} = u^{(0)} + x_1^{(1)} + x_2^{(1)} - s = 0 + (-\\frac{1}{6}) + \\frac{19}{30} - 1 = -\\frac{5}{30} + \\frac{19}{30} - \\frac{30}{30} = \\frac{14 - 30}{30} = -\\frac{16}{30} = -\\frac{8}{15}$$\n\n现在，我们计算在迭代 $k=1$ 时的残差。\n原始残差 $r^{(k+1)}$ 定义为 $A x_1^{(k+1)} + B x_2^{(k+1)} - s$。\n$$r^{(1)} = x_1^{(1)} + x_2^{(1)} - s = -\\frac{1}{6} + \\frac{19}{30} - 1 = -\\frac{5}{30} + \\frac{19}{30} - \\frac{30}{30} = -\\frac{16}{30} = -\\frac{8}{15}$$\n原始残差的欧几里得范数是其绝对值：\n$$\\|r^{(1)}\\| = \\left|-\\frac{8}{15}\\right| = \\frac{8}{15}$$\n\n尺度 ADMM 的对偶残差 $s^{(k+1)}$ 定义为 $\\rho A^T B (x_2^{(k+1)} - x_2^{(k)})$。\n$$s^{(1)} = \\rho A^T B (x_2^{(1)} - x_2^{(0)}) = 1 \\cdot 1 \\cdot 1 \\cdot (\\frac{19}{30} - 0.5) = \\frac{19}{30} - \\frac{1}{2} = \\frac{19}{30} - \\frac{15}{30} = \\frac{4}{30} = \\frac{2}{15}$$\n对偶残差的欧几里得范数是其绝对值：\n$$\\|s^{(1)}\\| = \\left|\\frac{2}{15}\\right| = \\frac{2}{15}$$\n\n最后一步是找出两个残差范数中较大的一个。\n$$\\max(\\|r^{(1)}\\|, \\|s^{(1)}\\|) = \\max\\left(\\frac{8}{15}, \\frac{2}{15}\\right) = \\frac{8}{15}$$\n其小数值为 $\\frac{8}{15} \\approx 0.533333...$。四舍五入到四位有效数字得到 $0.5333$。", "answer": "$$\\boxed{0.5333}$$", "id": "2701685"}, {"introduction": "为确保在存在不确定性的情况下的安全性和性能，鲁棒 MPC 技术至关重要。这个高级实践聚焦于基于“管道”(tube) 的 MPC，其中状态约束被“收紧”以保证系统状态在扰动下仍保持可行。你将通过使用支持函数计算最小鲁棒正不变 (minimal Robust Positively Invariant, mRPI) 集的外部近似，来实现计算这些收紧约束的核心逻辑。[@problem_id:2701664]", "problem": "给定一组由 $i \\in \\{1,2,3\\}$ 索引的独立线性时不变子系统，其局部误差动态为\n$$\ne_{i}^{+} = \\left(A_i + B_i K_i\\right) e_i + w_i,\n$$\n其中 $e_i \\in \\mathbb{R}^{n_i}$ 是局部误差状态，$A_i \\in \\mathbb{R}^{n_i \\times n_i}$，$B_i \\in \\mathbb{R}^{n_i \\times m_i}$，$K_i \\in \\mathbb{R}^{m_i \\times n_i}$ 是一个给定的局部反馈增益，$w_i \\in \\mathcal{W}_i$ 是局部扰动。假设闭环矩阵 $A_{i,\\mathrm{cl}} \\triangleq A_i + B_i K_i$ 是舒尔矩阵（所有特征值严格位于单位圆盘内部），并满足诱导无穷范数界 $\\lVert A_{i,\\mathrm{cl}} \\rVert_{\\infty} < 1$。局部状态约束为多面体形式\n$$\n\\mathcal{X}_i \\triangleq \\{x_i \\in \\mathbb{R}^{n_i} \\mid H_i x_i \\le h_i \\},\n$$\n其中 $H_i \\in \\mathbb{R}^{p_i \\times n_i}$ 的行是 $c_{i,j}^{\\top}$（$j \\in \\{1,\\dots,p_i\\}$），$h_i \\in \\mathbb{R}^{p_i}$。\n\n对于每个子系统 $i$，上述误差动态的最小鲁棒正不变 (mRPI) 集已知为\n$$\n\\mathcal{Z}_{i,\\infty} = \\bigoplus_{k=0}^{\\infty} A_{i,\\mathrm{cl}}^k \\mathcal{W}_i,\n$$\n前提是 $\\mathcal{W}_i$ 是包含原点的凸紧集，其中 $\\oplus$ 表示 Minkowski 和。在基于管的分布式模型预测控制 (dMPC) 中使用的约束收紧量则由 Pontryagin 差分给出\n$$\n\\mathcal{X}_{i,\\mathrm{tight}} \\triangleq \\mathcal{X}_i \\ominus \\mathcal{Z}_{i,\\infty} = \\{x_i \\mid H_i x_i \\le h_i - s_i\\},\n$$\n其中偏移量 $s_i \\in \\mathbb{R}^{p_i}$ 以逐分量的方式定义为\n$$\n\\left[s_i\\right]_j = \\sigma_{\\mathcal{Z}_{i,\\infty}}(c_{i,j}), \\quad \\text{for } j \\in \\{1,\\dots,p_i\\},\n$$\n且 $\\sigma_{\\mathcal{S}}(c) \\triangleq \\sup_{z \\in \\mathcal{S}} c^{\\top} z$ 表示集合 $\\mathcal{S}$ 在方向 $c$ 上的支撑函数。\n\n你的任务是编写一个程序，对于指定的数值数据，通过在支撑函数域中使用迭代 Minkowski 和与线性映射，计算一个适用于约束收紧的 $\\mathcal{Z}_{i,\\infty}$ 的外近似，然后返回每个子系统 $i$ 的收紧边界向量 $h_i - s_i$。\n\n使用以下基本定义和事实作为你推导和算法设计的基础：\n\n- 对于任意凸紧集 $\\mathcal{W} \\subset \\mathbb{R}^{n}$ 和矩阵 $A \\in \\mathbb{R}^{n \\times n}$，对于任意 $c \\in \\mathbb{R}^{n}$，支撑函数满足 $\\sigma_{A \\mathcal{W}}(c) = \\sigma_{\\mathcal{W}}(A^{\\top} c)$。\n- 对于 Minkowski 和，$\\sigma_{\\mathcal{S}_1 \\oplus \\mathcal{S}_2}(c) = \\sigma_{\\mathcal{S}_1}(c) + \\sigma_{\\mathcal{S}_2}(c)$。\n- 对于定义 $\\mathcal{Z}_{\\infty}$ 的无穷级数，当级数收敛时，在方向 $c$ 上的支撑等于 $\\sigma_{\\mathcal{Z}_{\\infty}}(c) = \\sum_{k=0}^{\\infty} \\sigma_{\\mathcal{W}}\\left(\\left(A^{\\top}\\right)^k c\\right)$。\n- 对于形式为 $\\mathcal{W} = \\{w \\in \\mathbb{R}^n \\mid \\lVert w \\rVert_{\\infty} \\le r\\}$ 且 $r > 0$ 的超矩形扰动，对于任意 $d \\in \\mathbb{R}^n$，我们有 $\\sigma_{\\mathcal{W}}(d) = r \\lVert d \\rVert_1$。\n- 如果 $\\lVert A \\rVert_{\\infty} < 1$，那么对于任意 $c \\in \\mathbb{R}^n$ 和 $r > 0$，\n$$\n\\sum_{k=N+1}^{\\infty} \\sigma_{\\mathcal{W}}\\left(\\left(A^{\\top}\\right)^k c\\right) \\le r \\lVert c \\rVert_1 \\frac{\\lVert A \\rVert_{\\infty}^{N+1}}{1 - \\lVert A \\rVert_{\\infty}},\n$$\n这为在索引 N 处截断无穷和提供了一个可计算的尾部界。\n\n为确保获得一个经过验证的外近似的算法要求：对于每个子系统 $i$，选择最小的整数 $N_i \\ge 0$，使得对于给定的容差 $\\varepsilon > 0$，\n$$\nr_i \\left(\\max_{j \\in \\{1,\\dots,p_i\\}} \\lVert c_{i,j} \\rVert_1 \\right) \\frac{\\lVert A_{i,\\mathrm{cl}} \\rVert_{\\infty}^{N_i+1}}{1 - \\lVert A_{i,\\mathrm{cl}} \\rVert_{\\infty}} \\le \\varepsilon.\n$$\n然后，对于每个约束法向量 $c_{i,j}$，定义\n$$\n\\left[s_i\\right]_j = \\sum_{k=0}^{N_i} \\sigma_{\\mathcal{W}_i}\\left(\\left(A_{i,\\mathrm{cl}}^{\\top}\\right)^k c_{i,j}\\right) + r_i \\lVert c_{i,j} \\rVert_1 \\frac{\\lVert A_{i,\\mathrm{cl}} \\rVert_{\\infty}^{N_i+1}}{1 - \\lVert A_{i,\\mathrm{cl}} \\rVert_{\\infty}},\n$$\n最后逐分量地计算收紧后的边界 $h_i - s_i$。这在支撑函数的意义上，沿着约束法向量方向，产生了一个对 $\\mathcal{Z}_{i,\\infty}$ 的有保证的过近似，因此得到了一个有效的收紧 $\\mathcal{X}_i \\ominus \\mathcal{Z}_{i,\\infty} \\supseteq \\{x_i \\mid H_i x_i \\le h_i - s_i\\}$。\n\n为以下包含三个独立子系统的测试套件实现上述算法。在所有情况下，扰动都是一个中心化的超矩形 $\\mathcal{W}_i = \\{w \\in \\mathbb{R}^{n_i} \\mid \\lVert w \\rVert_{\\infty} \\le r_i\\}$。\n\n- 测试用例 1：\n  - $A_1 = \\begin{bmatrix} 0.6 & 0.1 \\\\ -0.05 & 0.5 \\end{bmatrix}$，$B_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$，$K_1 = \\begin{bmatrix} -0.2 & 0.0 \\end{bmatrix}$。\n  - 状态约束 $\\mathcal{X}_1 = \\{x \\in \\mathbb{R}^2 \\mid H_1 x \\le h_1\\}$，其中 $H_1 = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ -1 & 0 \\\\ 0 & -1 \\end{bmatrix}$ 且 $h_1 = \\begin{bmatrix} 2.0 \\\\ 1.5 \\\\ 2.0 \\\\ 1.5 \\end{bmatrix}$。\n  - 扰动半径 $r_1 = 0.05$。\n\n- 测试用例 2：\n  - $A_2 = \\begin{bmatrix} 0.7 & 0.2 \\\\ 0.0 & 0.8 \\end{bmatrix}$，$B_2 = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$，$K_2 = \\begin{bmatrix} 0.0 & 0.0 \\end{bmatrix}$。\n  - 状态约束 $\\mathcal{X}_2 = \\{x \\in \\mathbb{R}^2 \\mid H_2 x \\le h_2\\}$，其中 $H_2 = \\begin{bmatrix} 1 & 1 \\\\ -1 & 2 \\\\ -1 & 0 \\\\ 0 & -1 \\end{bmatrix}$ 且 $h_2 = \\begin{bmatrix} 2.0 \\\\ 1.5 \\\\ 1.2 \\\\ 1.2 \\end{bmatrix}$。\n  - 扰动半径 $r_2 = 0.02$。\n\n- 测试用例 3：\n  - $A_3 = \\begin{bmatrix} 0.95 \\end{bmatrix}$，$B_3 = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$K_3 = \\begin{bmatrix} -0.1 \\end{bmatrix}$。\n  - 状态约束 $\\mathcal{X}_3 = \\{x \\in \\mathbb{R} \\mid H_3 x \\le h_3\\}$，其中 $H_3 = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$ 且 $h_3 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$。\n  - 扰动半径 $r_3 = 0.02$。\n\n对所有测试用例使用容差 $\\varepsilon = 10^{-6}$。不涉及角度；没有物理单位。\n\n你的程序应如上所述，为每个测试用例 $i \\in \\{1,2,3\\}$ 计算向量 $h_i - s_i$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是对应测试用例的收紧边界的 Python 列表，并按测试用例的顺序排列。例如，要求输出格式为 $[\\,[\\cdot,\\cdot,\\dots],\\,[\\cdot,\\cdot,\\dots],\\,[\\cdot,\\cdot,\\dots]\\,]$，其中包含浮点数值。", "solution": "问题陈述已经过严格审查，并被认为是有效的。它在科学上基于鲁棒控制理论的原理，在数学上是适定的、客观的，并包含了推导出唯一解所需的所有必要信息。所提供的数值数据与理论前提一致，特别是对于所有子系统 $i \\in \\{1, 2, 3\\}$，稳定性条件 $\\lVert A_i + B_i K_i \\rVert_{\\infty} < 1$ 均成立。因此，我将继续进行解法的推导和实现。\n\n该问题要求为一组受有界扰动影响的离散时间线性子系统计算收紧的状态约束边界。任务的核心是为每个子系统的误差动态计算最小鲁棒正不变 (mRPI) 集 $\\mathcal{Z}_{i,\\infty}$ 的一个外近似，并利用这个近似来确定必要的约束回退量。\n\n子系统 $i$ 的误差动态由下式给出\n$$\ne_{i}^{+} = A_{i,\\mathrm{cl}} e_i + w_i,\n$$\n其中 $A_{i,\\mathrm{cl}} \\triangleq A_i + B_i K_i$ 为闭环矩阵，$w_i$ 是属于集合 $\\mathcal{W}_i = \\{w \\in \\mathbb{R}^{n_i} \\mid \\lVert w \\rVert_{\\infty} \\le r_i\\}$ 的扰动。\n\nmRPI 集是无穷 Minkowski 和 $\\mathcal{Z}_{i,\\infty} = \\bigoplus_{k=0}^{\\infty} A_{i,\\mathrm{cl}}^k \\mathcal{W}_i$。状态约束是多面体的，$\\mathcal{X}_i = \\{x_i \\mid H_i x_i \\le h_i\\}$，其中 $H_i$ 的行是向量 $c_{i,j}^{\\top}$。收紧的约束向量是 $h_i - s_i$，其中偏移向量 $s_i$ 的分量由 $\\mathcal{Z}_{i,\\infty}$ 在约束法向量方向上的支撑函数给出：\n$$\n[s_i]_j = \\sigma_{\\mathcal{Z}_{i,\\infty}}(c_{i,j}) = \\sup_{z \\in \\mathcal{Z}_{i,\\infty}} c_{i,j}^{\\top} z.\n$$\n\n利用支撑函数的性质，这变成了一个无穷级数：\n$$\n[s_i]_j = \\sigma_{\\bigoplus_{k=0}^{\\infty} A_{i,\\mathrm{cl}}^k \\mathcal{W}_i}(c_{i,j}) = \\sum_{k=0}^{\\infty} \\sigma_{A_{i,\\mathrm{cl}}^k \\mathcal{W}_i}(c_{i,j}) = \\sum_{k=0}^{\\infty} \\sigma_{\\mathcal{W}_i}\\left(\\left(A_{i,\\mathrm{cl}}^{\\top}\\right)^k c_{i,j}\\right).\n$$\n\n对于给定的超矩形扰动集 $\\mathcal{W}_i$，其支撑函数为 $\\sigma_{\\mathcal{W}_i}(d) = r_i \\lVert d \\rVert_1$。因此，\n$$\n[s_i]_j = \\sum_{k=0}^{\\infty} r_i \\left\\lVert \\left(A_{i,\\mathrm{cl}}^{\\top}\\right)^k c_{i,j} \\right\\rVert_1.\n$$\n\n为使此计算易于处理，无穷级数在索引 $N_i \\ge 0$ 处被截断，剩余的尾部由一个可计算的界来过近似。算法对每个子系统 $i \\in \\{1, 2, 3\\}$ 按以下步骤进行。\n\n**步骤1：系统参数计算**\n首先，我们计算闭环矩阵 $A_{i,\\mathrm{cl}} = A_i + B_i K_i$。然后，我们计算其诱导无穷范数 $\\alpha_i \\triangleq \\lVert A_{i,\\mathrm{cl}} \\rVert_{\\infty}$。从问题验证中，我们已经确认对于所有给定的测试用例，$\\alpha_i < 1$。我们还从矩阵 $H_i$ 的行中识别出约束法向量 $c_{i,j}$，并找到它们中的最大 $L_1$-范数，$C_{i,\\mathrm{max}} \\triangleq \\max_{j} \\lVert c_{i,j} \\rVert_1$。\n\n**步骤2：确定截断长度 $N_i$**\n截断长度 $N_i$ 被选为保证级数的尾部（对于最坏情况的法向量）以给定容差 $\\varepsilon = 10^{-6}$ 为界的最小非负整数。条件是：\n$$\nr_i C_{i,\\mathrm{max}} \\frac{\\alpha_i^{N_i+1}}{1 - \\alpha_i} \\le \\varepsilon.\n$$\n这个不等式可以解出 $N_i+1$：\n$$\n\\alpha_i^{N_i+1} \\le \\frac{\\varepsilon (1 - \\alpha_i)}{r_i C_{i,\\mathrm{max}}}.\n$$\n取对数（并注意因为 $\\alpha_i < 1$，所以 $\\log(\\alpha_i) < 0$）得到：\n$$\nN_i+1 \\ge \\frac{\\log\\left(\\frac{\\varepsilon (1 - \\alpha_i)}{r_i C_{i,\\mathrm{max}}}\\right)}{\\log(\\alpha_i)}.\n$$\n因此，$N_i$ 是满足此条件的最小整数，可以通过从 $0$ 开始向上迭代 $N_i$ 直到条件满足来找到。\n\n**步骤3：计算偏移向量 $s_i$**\n对于每个约束法向量 $c_{i,j}$，相应的偏移量 $[s_i]_j$ 计算为有限级数和与尾部界之和：\n$$\n[s_i]_j = \\left( \\sum_{k=0}^{N_i} \\sigma_{\\mathcal{W}_i}\\left(\\left(A_{i,\\mathrm{cl}}^{\\top}\\right)^k c_{i,j}\\right) \\right) + \\text{Tail}_j.\n$$\n第一项是截断和，通过迭代计算：\n$$\nS_{i,j} \\triangleq \\sum_{k=0}^{N_i} r_i \\left\\lVert \\left(A_{i,\\mathrm{cl}}^{\\top}\\right)^k c_{i,j} \\right\\rVert_1.\n$$\n第二项是特定法向量 $c_{i,j}$ 的级数尾部界，由下式给出：\n$$\n\\text{Tail}_j \\triangleq r_i \\lVert c_{i,j} \\rVert_1 \\frac{\\alpha_i^{N_i+1}}{1-\\alpha_i}.\n$$\n这提供了对真实支撑函数值的经过验证的过近似，所以 $[s_i]_j = S_{i,j} + \\text{Tail}_j$。\n\n**步骤4：最终计算收紧边界**\n最后，通过逐分量相减来计算收紧的约束边界向量：\n$$\nh_{i, \\text{tight}} = h_i - s_i.\n$$\n此过程为所提供的三个测试用例中的每一个实现。数值计算由附带的 Python 脚本执行。```python\nimport numpy as np\n\ndef compute_tightened_bounds(A, B, K, H, h, r, epsilon):\n    \"\"\"\n    Computes the tightened constraint bounds for a single subsystem.\n\n    Args:\n        A (np.array): System matrix.\n        B (np.array): Input matrix.\n        K (np.array): Feedback gain matrix.\n        H (np.array): Constraint matrix.\n        h (np.array): Constraint vector.\n        r (float): Disturbance radius.\n        epsilon (float): Tolerance for tail bound.\n\n    Returns:\n        list: The vector of tightened bounds h - s.\n    \"\"\"\n    # Step 1: System Parameter Calculation\n    A_cl = A + B @ K\n    alpha = np.linalg.norm(A_cl, np.inf)\n\n    normals = H\n    c_norms_1 = [np.linalg.norm(c, 1) for c in normals]\n    max_c_norm_1 = max(c_norms_1) if c_norms_1 else 0\n\n    # Step 2: Determination of Truncation Horizon N\n    # The problem guarantees alpha < 1, so the denominator (1 - alpha) is positive.\n    # The loop will terminate.\n    N = 0\n    if max_c_norm_1 > 0 and r > 0:\n      while True:\n          # According to the problem, this is the error bound for the worst-case normal\n          tail_bound_max = r * max_c_norm_1 * (alpha**(N + 1)) / (1 - alpha)\n          if tail_bound_max <= epsilon:\n              break\n          N += 1\n\n    # Step 3: Computation of the Offset Vector s\n    s = np.zeros(h.shape)\n    A_cl_T = A_cl.T\n    \n    for j, (c, c_norm_1) in enumerate(zip(normals, c_norms_1)):\n        # Compute the finite sum part\n        sum_part = 0.0\n        # This vector will be updated in each iteration: (A_cl_T^k) @ c\n        A_cl_T_k_c = c\n        for _ in range(N + 1):\n            # support function sigma_W(d) = r * ||d||_1\n            sum_part += r * np.linalg.norm(A_cl_T_k_c, 1)\n            # Prepare for next iteration\n            A_cl_T_k_c = A_cl_T @ A_cl_T_k_c\n\n        # Compute the tail bound part for this specific normal\n        tail_part = r * c_norm_1 * (alpha**(N + 1)) / (1 - alpha)\n        \n        # Total offset for this constraint\n        s[j] = sum_part + tail_part\n        \n    # Step 4: Final Calculation of Tightened Bounds\n    h_tight = h - s\n    \n    return h_tight.tolist()\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Define test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[0.6, 0.1], [-0.05, 0.5]]),\n            \"B\": np.array([[1.0], [0.0]]),\n            \"K\": np.array([[-0.2, 0.0]]),\n            \"H\": np.array([[1, 0], [0, 1], [-1, 0], [0, -1]]),\n            \"h\": np.array([2.0, 1.5, 2.0, 1.5]),\n            \"r\": 0.05\n        },\n        {\n            \"A\": np.array([[0.7, 0.2], [0.0, 0.8]]),\n            \"B\": np.array([[0.0], [1.0]]),\n            \"K\": np.array([[0.0, 0.0]]),\n            \"H\": np.array([[1, 1], [-1, 2], [-1, 0], [0, -1]]),\n            \"h\": np.array([2.0, 1.5, 1.2, 1.2]),\n            \"r\": 0.02\n        },\n        {\n            \"A\": np.array([[0.95]]),\n            \"B\": np.array([[1.0]]),\n            \"K\": np.array([[-0.1]]),\n            \"H\": np.array([[1], [-1]]),\n            \"h\": np.array([0.5, 0.5]),\n            \"r\": 0.02\n        }\n    ]\n    \n    epsilon = 1e-6\n    results = []\n    \n    for case in test_cases:\n        result = compute_tightened_bounds(\n            case[\"A\"], case[\"B\"], case[\"K\"],\n            case[\"H\"], case[\"h\"], case[\"r\"],\n            epsilon\n        )\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    # The format requires printing a string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# This is a helper function and is not part of the required answer.\n# solve()\n```", "answer": "[[1.8653835619375626, 1.3711538356193756, 1.8653835619375626, 1.3711538356193756],[1.558352601708849, 0.933355203417698, 1.0166666666666666, 1.05],[0.3666666666666667, 0.3666666666666667]]", "id": "2701664"}]}