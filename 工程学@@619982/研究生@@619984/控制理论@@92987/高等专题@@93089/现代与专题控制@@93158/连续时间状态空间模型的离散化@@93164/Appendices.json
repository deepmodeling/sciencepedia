{"hands_on_practices": [{"introduction": "离散化一个连续时间系统的第一步是理解其自主行为如何在一个采样周期内演化。这个过程的核心是计算状态转移矩阵 $A_d$。本练习将通过计算矩阵指数 $A_d = e^{AT}$，让您亲身体验这一基础概念，并通过一系列涵盖稳定、零动态和 nilpotent 矩阵的案例，加深您对不同系统动态的理解。[@problem_id:2701315]", "problem": "给定形式为 $\\dot{x}(t)=A x(t)$ 的连续时间、线性、时不变状态方程，其中 $A \\in \\mathbb{R}^{2 \\times 2}$，以及一个采样周期 $T \\ge 0$。单个采样间隔内的离散时间状态转移由 $2 \\times 2$ 矩阵 $\\Phi(T)$ 表示，该矩阵被定义为初值问题 $\\frac{d}{dt}\\Phi(t) = A \\Phi(t)$ 且 $\\Phi(0)=I$ 的唯一解，其中 $I$ 是 $2 \\times 2$ 单位矩阵。您的任务是为下面的每个测试用例数值计算 $\\Phi(T)$，将每个矩阵元素四舍五入到三位有效数字。请将所需的四舍五入理解为按通常的有效数字意义逐元素地应用于实数；如果四舍五入后的值为零，则报告为 $0$。\n\n基本原理：使用状态转移矩阵 $\\Phi(t)$ 的定义微分方程，以及对于常数矩阵 $A$，解在所有 $t \\in \\mathbb{R}$ 上存在且唯一的事实。\n\n测试套件：\n- 用例 1 (正常路径)：$A=\\begin{bmatrix}0 & 1 \\\\ -2 & -3\\end{bmatrix}$，$T=0.1$。\n- 用例 2 (边界：零动态)：$A=\\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}$，$T=0.1$。\n- 用例 3 (幂零若尔当块)：$A=\\begin{bmatrix}0 & 1 \\\\ 0 & 0\\end{bmatrix}$，$T=0.1$。\n- 用例 4 (边界：零采样间隔)：$A=\\begin{bmatrix}0 & 1 \\\\ -2 & -3\\end{bmatrix}$，$T=0$。\n\n最终输出要求：\n- 对于每个用例，将 $2 \\times 2$ 矩阵 $\\Phi(T)$ 按行主序展开为一个列表 $[\\Phi_{11}, \\Phi_{12}, \\Phi_{21}, \\Phi_{22}]$，每个元素需四舍五入到三位有效数字。\n- 您的程序应生成单行输出，其中包含一个由这四个四元素列表组成的逗号分隔列表，无空格，并用方括号括起来。例如：$[[a_{11},a_{12},a_{21},a_{22}],[\\dots],[\\dots],[\\dots]]$，使用计算出的数值。\n- 不涉及物理单位，也不出现角度；仅报告纯数字。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个在控制理论领域，特别是关于连续时间线性系统离散化的适定的、有科学依据的问题。所有必要信息都已提供，要求也明确无误。\n\n问题的核心是计算由状态方程 $\\dot{x}(t) = A x(t)$ 描述的连续时间线性时不变 (LTI) 系统的状态转移矩阵 $\\Phi(T)$。矩阵 $\\Phi(t)$ 被定义为矩阵初值问题的唯一解：\n$$\n\\frac{d}{dt}\\Phi(t) = A \\Phi(t), \\quad \\Phi(0) = I\n$$\n其中 $I$ 是单位矩阵。对于常数矩阵 $A$，该微分方程的解由矩阵指数给出：\n$$\n\\Phi(t) = e^{At}\n$$\n因此，任务简化为为每个给定的矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$ 和采样周期 $T \\ge 0$ 计算 $\\Phi(T) = e^{AT}$。\n\n对于数值计算，方阵 $M$ 的矩阵指数 $e^M$ 最可靠的计算方法是使用 Padé 近似法，该方法为指数函数提供了有理函数近似。此算法是数值库中的标准算法，能够平衡准确性、效率和稳定性。`scipy.linalg.expm` 函数实现了此方法，并将用于本次计算。\n\n一个关键要求是将计算出的矩阵 $\\Phi(T)$ 的每个元素四舍五入到三位有效数字。对于非零数 $x$，四舍五入到 $s$ 位有效数字需要将数字格式化为特定的小数位数 $d$，该位数由其数量级决定。$d$ 的公式为：\n$$\nd = s - 1 - \\lfloor \\log_{10}|x| \\rfloor\n$$\n其中在本问题中 $s=3$，$\\lfloor \\cdot \\rfloor$ 表示向下取整函数。需要一个自定义的格式化函数来正确处理这种四舍五入，并确保最终输出中保留有效的尾随零，因为标准的浮点数到字符串转换可能会省略它们。对于任何恰好为零的值，报告为 $0$。\n\n我们现在分析每个测试用例：\n\n用例 1：$A=\\begin{bmatrix}0 & 1 \\\\ -2 & -3\\end{bmatrix}$，$T=0.1$。\n我们计算矩阵乘积 $M_1 = AT = 0.1 \\times \\begin{bmatrix}0 & 1 \\\\ -2 & -3\\end{bmatrix} = \\begin{bmatrix}0 & 0.1 \\\\ -0.2 & -0.3\\end{bmatrix}$。状态转移矩阵为 $\\Phi(0.1) = e^{M_1}$。此值通过数值计算得出。然后将结果矩阵的元素四舍五入到三位有效数字。\n\n用例 2：$A=\\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}$，$T=0.1$。\n矩阵 $A$ 是零矩阵 $O$。乘积矩阵 $M_2 = AT$ 也是零矩阵。状态转移矩阵为 $\\Phi(0.1) = e^O$。根据矩阵指数的泰勒级数定义 $e^M = \\sum_{k=0}^{\\infty} \\frac{M^k}{k!} = I + M + \\frac{M^2}{2!} + \\dots$，对于 $M=O$，结果显然是单位矩阵 $I$。\n$$\n\\Phi(0.1) = e^O = I = \\begin{bmatrix}1 & 0 \\\\ 0 & 1\\end{bmatrix}\n$$\n元素 $1$ 被格式化为三位有效数字，即 $1.00$。\n\n用例 3：$A=\\begin{bmatrix}0 & 1 \\\\ 0 & 0\\end{bmatrix}$，$T=0.1$。\n乘积矩阵是 $M_3 = AT = \\begin{bmatrix}0 & 0.1 \\\\ 0 & 0\\end{bmatrix}$。这个矩阵是幂零的，因为 $M_3^2 = \\begin{bmatrix}0 & 0.1 \\\\ 0 & 0\\end{bmatrix}\\begin{bmatrix}0 & 0.1 \\\\ 0 & 0\\end{bmatrix} = \\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix} = O$。因此，所有 $k \\ge 2$ 的更高次幂 $M_3^k$ 也是零矩阵。指数的泰勒级数截断为：\n$$\ne^{M_3} = I + M_3 + \\frac{M_3^2}{2!} + \\dots = I + M_3\n$$\n$$\n\\Phi(0.1) = \\begin{bmatrix}1 & 0 \\\\ 0 & 1\\end{bmatrix} + \\begin{bmatrix}0 & 0.1 \\\\ 0 & 0\\end{bmatrix} = \\begin{bmatrix}1 & 0.1 \\\\ 0 & 1\\end{bmatrix}\n$$\n然后将这些元素格式化为三位有效数字，得到 $1.00$ 和 $0.100$。\n\n用例 4：$A=\\begin{bmatrix}0 & 1 \\\\ -2 & -3\\end{bmatrix}$，$T=0$。\n采样周期为 $T=0$。乘积矩阵是 $M_4 = A \\times 0 = O$。此用例简化为与用例 2 相同的计算。或者，根据定义，$\\Phi(0)$ 是初始值，指定为单位矩阵 $I$。\n$$\n\\Phi(0) = e^{A \\cdot 0} = e^O = I = \\begin{bmatrix}1 & 0 \\\\ 0 & 1\\end{bmatrix}\n$$\n这些元素被格式化为三位有效数字，即 $1.00$。\n\n该实现将对每个用例系统地应用这些原理，使用 `scipy.linalg.expm` 计算数值，将结果格式化为三位有效数字，并按规定构建最终输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nimport math\n\ndef format_to_sf(x, sf):\n    \"\"\"\n    Formats a number x to a string with a specified number of significant figures (sf).\n    Handles trailing zeros correctly.\n    \"\"\"\n    if x == 0:\n        return '0'\n    \n    # Calculate the order of magnitude\n    if abs(x) < 1e-12: # Treat very small numbers as 0\n        return '0'\n    order = math.floor(math.log10(abs(x)))\n    \n    # Number of decimal places needed for fixed-point notation\n    decimals = sf - 1 - order\n    \n    # For numbers whose magnitude requires rounding in the integer part (e.g., 12345 to 3sf -> 12300)\n    if decimals < 0:\n        factor = 10**(-decimals)\n        val = int(round(x / factor) * factor)\n        return str(val)\n    else:\n        # Use f-string formatting with 'f' specifier for fixed-point notation\n        return f'{x:.{decimals}f}'\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the state transition matrix for each test case.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {'A': np.array([[0, 1], [-2, -3]]), 'T': 0.1},\n        # Case 2 (boundary: zero dynamics)\n        {'A': np.array([[0, 0], [0, 0]]), 'T': 0.1},\n        # Case 3 (nilpotent Jordan block)\n        {'A': np.array([[0, 1], [0, 0]]), 'T': 0.1},\n        # Case 4 (boundary: zero sampling interval)\n        {'A': np.array([[0, 1], [-2, -3]]), 'T': 0.0},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        A = case['A']\n        T = case['T']\n        \n        # The state transition matrix Phi(T) is the matrix exponential of A*T\n        M = A * T\n        phi_T = expm(M)\n        \n        # Flatten the resulting 2x2 matrix in row-major order\n        phi_T_flat = phi_T.flatten()\n        \n        # Round each element to 3 significant digits and format as a string\n        # to preserve significant trailing zeros.\n        num_significant_digits = 3\n        rounded_results = [format_to_sf(val, num_significant_digits) for val in phi_T_flat]\n        \n        all_results.append(f\"[{','.join(rounded_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2701315"}, {"introduction": "在掌握了状态转移矩阵 $A_d$ 的计算之后，下一步是正确处理输入项。一个常见的误区是将连续时间输入矩阵 $B$ 简单地乘以采样周期 $T$ 来得到离散输入矩阵 $B_d$。本练习通过一个简单的标量系统，要求您分析性地证明这种近似方法的谬误，从而强调在零阶保持假设下，通过积分推导 $B_d$ 的正确形式至关重要。[@problem_id:2701337]", "problem": "考虑一个由常微分方程 $\\dot{x}(t)=A x(t)+B u(t)$ 定义的标量连续时间线性时不变系统，其中 $A\\in\\mathbb{R}$ 且 $B\\in\\mathbb{R}$，输入为零阶保持器 (ZOH) 输入 $u(t)=u_{k}$（对于 $t\\in[kT,(k+1)T)$），且采样周期 $T>0$。在一个采样间隔内，可以从线性时不变系统的基本解推导出精确的离散时间更新 $x_{k+1}$，而一种常见但简陋的建模方法是将采样点间的卷积积分替换为 $B T u_{k}$。\n\n仅使用线性微分方程的第一性原理和零阶保持器假设，构建一个最小反例，以证明即使在标量情况下，用 $B T u_{k}$ 替代精确的采样点间积分也会得到不正确的离散模型。具体来说，对于参数选择 $A=1$, $B=1$, $T=1$, $x_{k}=0$ 以及 $u_{k}=1$：\n- 推导精确的单步更新 $x_{k+1}^{\\mathrm{exact}}$。\n- 推导通过将采样点间积分替换为 $B T u_{k}$ 得到的近似单步更新 $x_{k+1}^{\\mathrm{approx}}$。\n- 计算误差 $\\Delta \\equiv x_{k+1}^{\\mathrm{exact}}-x_{k+1}^{\\mathrm{approx}}$。\n\n将 $\\Delta$ 报告为单个闭式解析表达式。不要对答案进行四舍五入。不需要单位。", "solution": "该问题要求针对一种连续时间线性系统的简陋离散化方法，推导出一个反例。我们将按照指示，从第一性原理出发。\n\n连续时间线性时不变 (LTI) 系统由以下标量常微分方程描述：\n$$\n\\dot{x}(t) = A x(t) + B u(t)\n$$\n其中 $A \\in \\mathbb{R}$ 且 $B \\in \\mathbb{R}$。\n\n在时间区间 $[t_0, t]$ 上，该微分方程的基本解由常数变易法公式给出：\n$$\nx(t) = \\exp(A(t - t_0)) x(t_0) + \\int_{t_0}^{t} \\exp(A(t - \\tau)) B u(\\tau) \\, d\\tau\n$$\n我们关心的是状态在单个采样周期 $T$ 内的转移，即从时间 $t_k = kT$ 到 $t_{k+1} = (k+1)T$。令 $x_k = x(kT)$ 且 $x_{k+1} = x((k+1)T)$。设 $t_0 = kT$ 和 $t = (k+1)T$，解变为：\n$$\nx_{k+1} = \\exp(A((k+1)T - kT)) x_k + \\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) B u(\\tau) \\, d\\tau\n$$\n问题指定了零阶保持器 (ZOH) 输入，意味着控制输入 $u(t)$ 在每个采样区间内保持恒定：对于 $t \\in [kT, (k+1)T)$，$u(t) = u_k$。将此代入方程，我们可以将常数 $B$ 和 $u_k$ 移到积分符号外：\n$$\nx_{k+1} = \\exp(AT) x_k + B u_k \\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) \\, d\\tau\n$$\n这便是通用的精确单步更新公式。\n\n首先，我们推导精确的单步更新 $x_{k+1}^{\\mathrm{exact}}$。为了计算该积分，我们进行变量替换。令 $\\sigma = (k+1)T - \\tau$。这意味着 $d\\sigma = -d\\tau$。积分上下限从 $\\tau = kT$ 变为 $\\sigma = T$，从 $\\tau = (k+1)T$ 变为 $\\sigma = 0$。积分变为：\n$$\n\\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) \\, d\\tau = \\int_{T}^{0} \\exp(A\\sigma) (-d\\sigma) = \\int_{0}^{T} \\exp(A\\sigma) \\, d\\sigma\n$$\n由于 $A$ 是一个非零标量常数 ($A=1$)，该积分的计算结果为：\n$$\n\\int_{0}^{T} \\exp(A\\sigma) \\, d\\sigma = \\left[ \\frac{1}{A} \\exp(A\\sigma) \\right]_0^T = \\frac{1}{A} (\\exp(AT) - \\exp(A \\cdot 0)) = \\frac{1}{A} (\\exp(AT) - 1)\n$$\n将此结果代回，得到精确离散时间更新的表达式：\n$$\nx_{k+1}^{\\mathrm{exact}} = \\exp(AT) x_k + \\frac{B}{A}(\\exp(AT) - 1) u_k\n$$\n现在我们代入给定的参数：$A=1$，$B=1$，$T=1$，$x_k=0$ 以及 $u_k=1$。\n$$\nx_{k+1}^{\\mathrm{exact}} = \\exp(1 \\cdot 1) \\cdot 0 + \\frac{1}{1}(\\exp(1 \\cdot 1) - 1) \\cdot 1 = 0 + (\\exp(1) - 1) = \\exp(1) - 1\n$$\n\n其次，我们推导近似的单步更新 $x_{k+1}^{\\mathrm{approx}}$。问题指出，这是通过将“采样点间卷积积分”（即项 $\\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) B u_k \\, d\\tau$）替换为简陋的近似值 $B T u_k$ 来获得的。\n精确的公式是：\n$$\nx_{k+1} = \\exp(AT) x_k + \\left( \\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) d\\tau \\right) B u_k\n$$\n按照指定替换积分项，得到近似模型：\n$$\nx_{k+1}^{\\mathrm{approx}} = \\exp(AT) x_k + B T u_k\n$$\n该近似仅在 $AT \\ll 1$ 时有效。我们使用给定的参数从该模型计算数值：$A=1$，$B=1$，$T=1$，$x_k=0$ 以及 $u_k=1$。\n$$\nx_{k+1}^{\\mathrm{approx}} = \\exp(1 \\cdot 1) \\cdot 0 + (1)(1)(1) = 0 + 1 = 1\n$$\n\n最后，我们计算误差 $\\Delta$，其定义为精确结果与近似结果之差：\n$$\n\\Delta = x_{k+1}^{\\mathrm{exact}} - x_{k+1}^{\\mathrm{approx}}\n$$\n代入推导出的值：\n$$\n\\Delta = (\\exp(1) - 1) - 1 = \\exp(1) - 2\n$$\n这便是误差的最终解析表达式。", "answer": "$$\n\\boxed{\\exp(1) - 2}\n$$", "id": "2701337"}, {"introduction": "前面的练习分别探讨了 $A_d$ 和 $B_d$ 的计算及其中的陷阱。在实际工程中，我们需要一种统一且数值稳定的方法来同时计算它们。本练习将引导您使用 Van Loan 方法，这是一种通过构造一个增广矩阵并计算其指数来实现精确离散化的强大技术，它将前面分离的概念整合为一个优雅且实用的计算流程。[@problem_id:2701343]", "problem": "给定一个由微分方程 $\\dot{x}(t) = A x(t) + B u(t)$ 定义的连续时间、线性时不变状态空间模型，其输入为零阶保持器 (ZOH) 采样输入，其中 $u(t)$ 在每个长度为 $T > 0$ 的采样间隔内保持恒定。目标是获得一个等效的离散时间状态空间模型 $x_{k+1} = A_d x_k + B_d u_k$，该模型在ZOH条件下精确匹配每个采样间隔内的连续时间动态。您的推导必须从线性系统的状态转移算子定义以及“带恒定输入的线性常微分方程在一个区间上的解是通过状态转移与输入的积分得到的”这一性质出发。请勿假设或引用任何闭式分块矩阵指数恒等式；相反，应从这些基本原理出发进行推理，以证明一个用于计算 $A_d$ 和 $B_d$ 的算法的合理性，该算法对于一般矩阵 $A$ 和 $B$ 都是数值稳定的。然后实现该算法。\n\n对于数值计算，请使用 Van Loan 方法，该方法是基于一个增广线性系统的基本解构建的，该系统的输入在零阶保持下是恒定的。您的程序必须为以下每个测试案例计算 $A_d$ 和 $B_d$，并保留四位小数。\n\n请实现一个程序，为每个测试案例计算 $A_d$ 和 $B_d$，并将其条目四舍五入到四位小数后输出。对于每个案例，您必须按行主序展开 $A_d$，然后按行主序展开 $B_d$，再将它们连接成一个单一的浮点数列表。将所有案例的结果按下列顺序列入一个总的单一列表中。\n\n不涉及物理单位；所有量均为无量纲实数。\n\n测试套件:\n- 案例 1 (一般振荡，有阻尼): $A = \\begin{bmatrix} 0 & 1 \\\\ -10 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0.05$。\n- 案例 2 (边界条件 $T=0$): $A = \\begin{bmatrix} 0 & 1 \\\\ -10 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0$。\n- 案例 3 (幂零矩阵 $A$): $A = \\begin{bmatrix} 0 & 1 \\\\ 0 & 0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0.1$。\n- 案例 4 (无驱动): $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -0.5 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $T = 0.2$。\n- 案例 5 (刚性，快速模态): $A = \\begin{bmatrix} 0 & 1 \\\\ -100 & -20 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0.01$。\n\n最终输出格式:\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果 (例如, $[r_1,r_2,\\dots]$)。该列表必须按顺序包含每个案例的 $A_d$ 条目（按行展开）和 $B_d$ 条目（按行展开），所有数值均为四舍五入到四位小数的浮点数。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 连续时间线性时不变 (LTI) 状态空间模型：$\\dot{x}(t) = A x(t) + B u(t)$。\n- 输入 $u(t)$ 在长度为 $T > 0$ 的采样间隔内是恒定的，这一假设被称为零阶保持器 (ZOH)，使得 $u(t) = u_k$ 对于 $t \\in [kT, (k+1)T)$ 成立。\n- 所需的等效离散时间模型形式为 $x_{k+1} = A_d x_k + B_d u_k$。\n- 推导必须从状态转移算子和LTI常微分方程解的积分形式开始。\n- 禁止引用分块矩阵指数恒等式；必须对其进行推导。\n- 必须论证并使用一种数值稳定的算法，特别是 Van Loan 方法，来进行计算。\n- 提供的测试案例为：\n    1. $A = \\begin{bmatrix} 0 & 1 \\\\ -10 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0.05$。\n    2. $A = \\begin{bmatrix} 0 & 1 \\\\ -10 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0$。\n    3. $A = \\begin{bmatrix} 0 & 1 \\\\ 0 & 0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0.1$。\n    4. $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -0.5 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $T = 0.2$。\n    5. $A = \\begin{bmatrix} 0 & 1 \\\\ -100 & -20 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 0.01$。\n- 每个测试案例的最终输出必须包含 $A_d$ 的条目（按行主序展开），后跟 $B_d$ 的条目（按行主序展开），连接成一个单一的数值列表，四舍五入到四位小数。所有测试案例的结果必须汇总到一个单一列表中。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需准则对问题进行评估。\n- **科学上成立:** 该问题涉及连续时间LTI系统的离散化，这是控制理论和线性系统分析中的一个基本且成熟的课题。所给出的控制方程和指定的 Van Loan 方法都是标准且正确的。\n- **良构的:** 问题为每个测试案例提供了所有必要信息（$A$、$B$、$T$），以唯一确定离散时间矩阵 $A_d$ 和 $B_d$。$T=0$ 的情况虽然在一般条件 $T>0$ 之后陈述，但它代表了一个有效且重要的边界条件，一个鲁棒的解必须能够正确处理。这并非矛盾，而是一个极限情况。\n- **客观的:** 问题使用精确的数学和技术语言陈述，没有任何主观性或模糊性。\n\n**步骤 3：结论与行动**\n该问题在科学上是合理的、良构的且客观的。它不包含任何逻辑矛盾、信息缺失或伪科学成分。因此，该问题被判定为**有效**。我们继续进行求解。\n\n连续时间状态空间方程 $\\dot{x}(t) = A x(t) + B u(t)$ 在区间 $[t_0, t]$ 上的解由常数变易法公式给出：\n$$\nx(t) = e^{A(t-t_0)} x(t_0) + \\int_{t_0}^{t} e^{A(t-\\tau)} B u(\\tau) d\\tau\n$$\n其中 $e^{At}$ 是状态转移矩阵。\n\n我们关心的是状态从时间 $t_k = kT$ 到 $t_{k+1} = (k+1)T$ 的演化。设 $t_0 = kT$ 和 $t = (k+1)T$，我们有：\n$$\nx((k+1)T) = e^{A((k+1)T - kT)} x(kT) + \\int_{kT}^{(k+1)T} e^{A((k+1)T - \\tau)} B u(\\tau) d\\tau\n$$\n通过定义离散状态向量 $x_k \\triangleq x(kT)$，方程变为：\n$$\nx_{k+1} = e^{AT} x_k + \\int_{kT}^{(k+1)T} e^{A((k+1)T - \\tau)} B u(\\tau) d\\tau\n$$\n问题指定了输入上的零阶保持，这意味着 $u(\\tau)$ 在采样间隔内是恒定的，$u(\\tau) = u(kT) = u_k$ 对于 $\\tau \\in [kT, (k+1)T)$。将此代入方程，我们可以将常数项 $B$ 和 $u_k$ 移到积分之外：\n$$\nx_{k+1} = e^{AT} x_k + \\left( \\int_{kT}^{(k+1)T} e^{A((k+1)T - \\tau)} d\\tau \\right) B u_k\n$$\n为了简化积分，我们进行变量替换。令 $\\sigma = (k+1)T - \\tau$。这意味着 $d\\sigma = -d\\tau$。积分限从 $\\tau = kT$ 变为 $\\sigma = T$，从 $\\tau = (k+1)T$ 变为 $\\sigma = 0$。积分变为：\n$$\n\\int_{T}^{0} e^{A\\sigma} (-d\\sigma) = \\int_{0}^{T} e^{A\\sigma} d\\sigma\n$$\n将此结果代回，我们得到精确的离散时间模型：\n$$\nx_{k+1} = \\left( e^{AT} \\right) x_k + \\left( \\int_{0}^{T} e^{A\\sigma} d\\sigma \\right) B u_k\n$$\n通过与目标形式 $x_{k+1} = A_d x_k + B_d u_k$ 进行比较，我们确定离散时间系统矩阵为：\n$$\nA_d = e^{AT}\n$$\n$$\nB_d = \\left( \\int_{0}^{T} e^{A\\sigma} d\\sigma \\right) B\n$$\n计算的挑战在于精确计算矩阵指数 $e^{AT}$ 和矩阵指数的积分。分别计算这两个量的朴素方法可能会遇到数值不精确的问题，特别是对于刚性系统或小采样时间 $T$。Van Loan 方法提供了一种鲁棒的方式来同时计算 $A_d$ 和 $B_d$。\n\n该方法通过构建一个增广 $(n+m) \\times (n+m)$ 矩阵来证明其合理性，其中 $n$ 是状态的维度，$m$ 是输入的维度：\n$$\nM = \\begin{bmatrix} A & B \\\\ 0 & 0 \\end{bmatrix}\n$$\n零块具有适当的维度，以使 $M$ 成为一个有效的方阵。我们现在计算矩阵指数 $e^{MT}$。使用矩阵指数的泰勒级数展开 $e^X = \\sum_{k=0}^{\\infty} \\frac{X^k}{k!}$，我们分析 $MT$ 的幂次：\n$$\nMT = \\begin{bmatrix} AT & BT \\\\ 0 & 0 \\end{bmatrix}\n$$\n对于 $k \\ge 1$，幂次为：\n$$\n(MT)^k = \\begin{bmatrix} (AT)^k & (AT)^{k-1}BT \\\\ 0 & 0 \\end{bmatrix}\n$$\n因此，指数为：\n$$\ne^{MT} = I + \\sum_{k=1}^{\\infty} \\frac{(MT)^k}{k!} = \\begin{bmatrix} I & 0 \\\\ 0 & I \\end{bmatrix} + \\sum_{k=1}^{\\infty} \\frac{1}{k!} \\begin{bmatrix} (AT)^k & (AT)^{k-1}BT \\\\ 0 & 0 \\end{bmatrix}\n$$\n通过对相应的块求和，我们得到：\n$$\ne^{MT} = \\begin{bmatrix} I + \\sum_{k=1}^{\\infty} \\frac{(AT)^k}{k!} & \\sum_{k=1}^{\\infty} \\frac{(AT)^{k-1}T}{k!} B \\\\ 0 & I \\end{bmatrix}\n$$\n我们识别出所得分块矩阵中的项。左上角块是 $e^{AT}$ 的泰勒级数：\n$$\n\\Phi_{11} = I + \\sum_{k=1}^{\\infty} \\frac{(AT)^k}{k!} = e^{AT} = A_d\n$$\n右上角块是：\n$$\n\\Phi_{12} = \\left( \\sum_{k=1}^{\\infty} \\frac{A^{k-1}T^k}{k!} \\right) B\n$$\n让我们将其与 $B_d$ 的前乘子的积分形式进行比较。我们使用泰勒级数展开矩阵指数的积分：\n$$\n\\int_{0}^{T} e^{A\\sigma} d\\sigma = \\int_{0}^{T} \\left( \\sum_{j=0}^{\\infty} \\frac{(A\\sigma)^j}{j!} \\right) d\\sigma = \\sum_{j=0}^{\\infty} \\frac{A^j}{j!} \\int_{0}^{T} \\sigma^j d\\sigma = \\sum_{j=0}^{\\infty} \\frac{A^j}{(j)!} \\frac{T^{j+1}}{j+1} = \\sum_{j=0}^{\\infty} \\frac{A^j T^{j+1}}{(j+1)!}\n$$\n设 $k = j+1$，这个和变为 $\\sum_{k=1}^{\\infty} \\frac{A^{k-1} T^k}{k!}$。这正是 $\\Phi_{12}$ 中与 $B$ 相乘的矩阵。因此：\n$$\n\\Phi_{12} = \\left( \\int_{0}^{T} e^{A\\sigma} d\\sigma \\right) B = B_d\n$$\n因此，我们证明了增广矩阵 $MT$ 的指数具有以下结构：\n$$\ne^{MT} = \\begin{bmatrix} A_d & B_d \\\\ 0 & I \\end{bmatrix}\n$$\n这个结果构成了 Van Loan 算法的基础。它在数值上更优，因为它通过单个、良态的矩阵指数计算来计算 $A_d$ 和 $B_d$，而对于这种计算存在高度鲁棒的算法（例如带缩放和平方的Padé近似）。\n\n实现步骤如下：\n1.  对于每个测试案例（$A$、$B$、$T$），确定状态维度 $n$ 和输入维度 $m$。\n2.  构建 $(n+m) \\times (n+m)$ 的增广矩阵 $M = \\begin{bmatrix} A & B \\\\ 0 & 0 \\end{bmatrix}$。\n3.  使用可靠的数值库函数计算矩阵指数 $\\Phi = e^{MT}$。\n4.  提取子矩阵：$A_d$ 是 $\\Phi$ 的左上角 $n \\times n$ 块，$B_d$ 是右上角 $n \\times m$ 块。\n5.  将得到的矩阵 $A_d$ 和 $B_d$ 按行主序展开为一维数组。\n6.  连接这些数组，并将元素四舍五入到四位小数。\n7.  将所有测试案例的结果汇总到最终列表中。\n这个过程正确且鲁棒地计算了所需的离散时间矩阵。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the discretized state-space matrices Ad and Bd for a set of test cases\n    using the Van Loan method.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General oscillatory, damped\n        {'A': np.array([[0, 1], [-10, -1]]), 'B': np.array([[0], [1]]), 'T': 0.05},\n        # Case 2: Boundary condition T=0\n        {'A': np.array([[0, 1], [-10, -1]]), 'B': np.array([[0], [1]]), 'T': 0.0},\n        # Case 3: Nilpotent A\n        {'A': np.array([[0, 1], [0, 0]]), 'B': np.array([[0], [1]]), 'T': 0.1},\n        # Case 4: No actuation\n        {'A': np.array([[0, 1], [-2, -0.5]]), 'B': np.array([[0], [0]]), 'T': 0.2},\n        # Case 5: Stiff, fast mode\n        {'A': np.array([[0, 1], [-100, -20]]), 'B': np.array([[0], [1]]), 'T': 0.01},\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        T = case['T']\n\n        n = A.shape[0]\n        if B.ndim == 1:\n            B = B.reshape(-1, 1)\n        m = B.shape[1]\n\n        # Construct the augmented matrix M for the Van Loan method\n        M = np.zeros((n + m, n + m))\n        M[:n, :n] = A\n        M[:n, n:] = B\n\n        # Compute the matrix exponential of M*T\n        # scipy.linalg.expm is a robust implementation using Padé approximation\n        phi = expm(M * T)\n\n        # Extract Ad and Bd from the resulting matrix\n        Ad = phi[:n, :n]\n        Bd = phi[:n, n:]\n\n        # Flatten Ad and Bd row-wise\n        flat_Ad = Ad.flatten()\n        flat_Bd = Bd.flatten()\n\n        # Concatenate and round results to four decimal places\n        case_result = np.concatenate((flat_Ad, flat_Bd))\n        rounded_result = np.round(case_result, 4)\n\n        final_results.extend(rounded_result.tolist())\n\n    # Format the final output as a single comma-separated list in brackets\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "2701343"}]}