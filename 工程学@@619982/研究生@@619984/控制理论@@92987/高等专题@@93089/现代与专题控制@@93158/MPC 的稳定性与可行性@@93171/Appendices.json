{"hands_on_practices": [{"introduction": "在证明模型预测控制（MPC）的稳定性时，一个精心选择的终端成本函数 $V_f(x) = x^\\top P x$ 扮演着至关重要的角色。它确保了在预测时域的末端，系统的状态值函数能够下降，从而满足Lyapunov稳定性的条件。本练习将引导您完成计算终端成本矩阵 $P$ 的标准流程，即求解离散时间Lyapunov方程，这是保证标称系统稳定性的基石 [@problem_id:2746597]。", "problem": "考虑用于模型预测控制（MPC）稳定性分析的离散时间线性时不变系统，\n$$x_{k+1} = A x_k + B u_k,$$\n其状态反馈控制律为\n$$u_k = K x_k,$$\n和二次阶段成本\n$$\\ell(x_k,u_k) = x_k^{\\top} Q x_k + u_k^{\\top} R u_k.$$\n假设闭环矩阵 $A_{K} \\coloneqq A + B K$ 是 Schur 矩阵（所有特征值都严格位于单位圆盘内部）。MPC 的一个标准终端成本候选是二次 Lyapunov 函数\n$$V(x) = x^{\\top} P x,$$\n其中 $P \\succ 0$ 解出离散时间 Lyapunov 方程\n$$P = A_{K}^{\\top} P A_{K} + \\left(Q + K^{\\top} R K\\right).$$\n这一选择通过确保 Lyapunov 下降条件来保证递推可行性和闭环稳定性。\n\n对于给定的具体数据\n$$A=\\begin{bmatrix}1  1\\\\ 0  1\\end{bmatrix},\\quad B=\\begin{bmatrix}0\\\\ 1\\end{bmatrix},\\quad K=\\begin{bmatrix}-1  -2\\end{bmatrix},\\quad Q=I,\\quad R=I,$$\n执行以下操作：\n1) 计算求解上述离散时间 Lyapunov 方程的唯一对称正定矩阵 $P$。\n2) 使用你计算出的 $P$，验证对所有 $x$ 的 Lyapunov 下降不等式，\n$$V(x^{+})-V(x) \\leq -\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right),$$\n其中 $x^{+} = A_{K} x$。\n\n请以具有有理数元素（无四舍五入）的精确 $2 \\times 2$ 矩阵 $P$ 的形式给出你的最终答案。最终答案中不要包含任何不等式。", "solution": "所提出的问题是关于反馈控制下线性离散时间系统稳定性分析的一个标准练习，具体涉及二次 Lyapunov 函数的构造。该问题提法得当且科学上是合理的。我将开始进行求解。\n\n任务是从离散时间代数 Lyapunov 方程中求解对称正定矩阵 $P$：\n$$P = A_{K}^{\\top} P A_{K} + \\left(Q + K^{\\top} R K\\right)$$\n并随后验证 Lyapunov 下降条件。\n\n首先，我们必须计算闭环系统矩阵 $A_K = A + BK$。给定的矩阵是：\n$$A = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix}, \\quad B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad K = \\begin{bmatrix} -1  -2 \\end{bmatrix}$$\n乘积 $BK$ 是：\n$$BK = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\begin{bmatrix} -1  -2 \\end{bmatrix} = \\begin{bmatrix} 0 \\times (-1)  0 \\times (-2) \\\\ 1 \\times (-1)  1 \\times (-2) \\end{bmatrix} = \\begin{bmatrix} 0  0 \\\\ -1  -2 \\end{bmatrix}$$\n因此，闭环矩阵 $A_K$ 是：\n$$A_K = A + BK = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix} + \\begin{bmatrix} 0  0 \\\\ -1  -2 \\end{bmatrix} = \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}$$\n问题陈述 $A_K$ 是 Schur 矩阵。我们来确认一下。特征方程为 $\\det(A_K - \\lambda I) = 0$。\n$$\\det \\left( \\begin{bmatrix} 1-\\lambda  1 \\\\ -1  -1-\\lambda \\end{bmatrix} \\right) = (1-\\lambda)(-1-\\lambda) - (1)(-1) = -1 - \\lambda + \\lambda + \\lambda^2 + 1 = \\lambda^2 = 0$$\n特征值为 $\\lambda_{1,2} = 0$。由于所有特征值的模 $|\\lambda| = 0  1$，矩阵 $A_K$ 确实是 Schur 矩阵，这保证了对于任何正定加权矩阵 $Q + K^{\\top} R K$，Lyapunov 方程都存在唯一的正定解 $P$。\n\n接下来，我们计算阶段成本的总加权矩阵，我们将其表示为 $Q_{cl} = Q + K^{\\top} R K$。给定 $Q = I$ 和 $R = I$。由于控制输入 $u_k = Kx_k$ 是一个标量，所以 $R$ 是标量 $1$。\n$$K^{\\top} R K = \\begin{bmatrix} -1 \\\\ -2 \\end{bmatrix} (1) \\begin{bmatrix} -1  -2 \\end{bmatrix} = \\begin{bmatrix} (-1)(-1)  (-1)(-2) \\\\ (-2)(-1)  (-2)(-2) \\end{bmatrix} = \\begin{bmatrix} 1  2 \\\\ 2  4 \\end{bmatrix}$$\n因此，$Q_{cl}$ 是：\n$$Q_{cl} = Q + K^{\\top} R K = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} + \\begin{bmatrix} 1  2 \\\\ 2  4 \\end{bmatrix} = \\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix}$$\nLyapunov 方程为 $P = A_K^{\\top} P A_K + Q_{cl}$。设 $P$ 为对称矩阵 $P = \\begin{bmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{bmatrix}$。我们必须求解其元素。\n首先，我们计算项 $A_K^{\\top} P A_K$：\n$$A_K^{\\top} P A_K = \\begin{bmatrix} 1  -1 \\\\ 1  -1 \\end{bmatrix} \\begin{bmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{bmatrix} \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}$$\n$$= \\begin{bmatrix} p_{11}-p_{12}  p_{12}-p_{22} \\\\ p_{11}-p_{12}  p_{12}-p_{22} \\end{bmatrix} \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}$$\n$$= \\begin{bmatrix} (p_{11}-p_{12}) - (p_{12}-p_{22})  (p_{11}-p_{12}) - (p_{12}-p_{22}) \\\\ (p_{11}-p_{12}) - (p_{12}-p_{22})  (p_{11}-p_{12}) - (p_{12}-p_{22}) \\end{bmatrix}$$\n$$= \\begin{bmatrix} p_{11}-2p_{12}+p_{22}  p_{11}-2p_{12}+p_{22} \\\\ p_{11}-2p_{12}+p_{22}  p_{11}-2p_{12}+p_{22} \\end{bmatrix}$$\n令标量值 $c = p_{11}-2p_{12}+p_{22}$。则 $A_K^{\\top} P A_K = c \\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$。\n将此代入 Lyapunov 方程：\n$$\\begin{bmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{bmatrix} = \\begin{bmatrix} c  c \\\\ c  c \\end{bmatrix} + \\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix} = \\begin{bmatrix} c+2  c+2 \\\\ c+2  c+5 \\end{bmatrix}$$\n通过比较元素，我们得到一个方程组：\n1) $p_{11} = c+2$\n2) $p_{12} = c+2$\n3) $p_{22} = c+5$\n从方程 1) 和 2)，我们发现 $p_{11} = p_{12}$。\n现在我们将这些代入 $c$ 的定义中：\n$$c = p_{11} - 2p_{12} + p_{22} = (c+2) - 2(c+2) + (c+5)$$\n$$c = c+2 - 2c-4 + c+5 = (c-2c+c) + (2-4+5) = 0 \\cdot c + 3$$\n$$c = 3$$\n使用这个值，我们求出 $P$ 的元素：\n$$p_{11} = c+2 = 3+2 = 5$$\n$$p_{12} = c+2 = 3+2 = 5$$\n$$p_{22} = c+5 = 3+5 = 8$$\n所以，解是矩阵：\n$$P = \\begin{bmatrix} 5  5 \\\\ 5  8 \\end{bmatrix}$$\n这个矩阵是对称的。我们使用 Sylvester 判据来检查其正定性。顺序主子式为 $5  0$ 和 $\\det(P) = 5 \\times 8 - 5 \\times 5 = 40 - 25 = 15  0$。两者均为正，因此 $P$ 是正定的。这就完成了问题的第一部分。\n\n对于第二部分，我们必须验证 Lyapunov 下降不等式：\n$$V(x^{+}) - V(x) \\leq -\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right)$$\n其中 $V(x) = x^{\\top} P x$ 且 $x^{+} = A_K x$。\n左手边 (LHS) 是：\n$$V(x^{+}) - V(x) = (A_K x)^{\\top} P (A_K x) - x^{\\top} P x = x^{\\top} (A_K^{\\top} P A_K - P) x$$\n右手边 (RHS) 是：\n$$-\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right) = -x^{\\top} (Q + K^{\\top} R K) x$$\n该不等式等价于证明 $x^{\\top} (A_K^{\\top} P A_K - P) x \\leq -x^{\\top} (Q + K^{\\top} R K) x$。\n根据 Lyapunov 方程 $P = A_K^{\\top} P A_K + Q + K^{\\top} R K$ 中 $P$ 的定义，我们可以将其重新排列为：\n$$A_K^{\\top} P A_K - P = -(Q + K^{\\top} R K)$$\n这意味着定义不等式两边二次型的矩阵不仅仅是由不等式关联，它们实际上是相等的。将此等式代入不等式的 LHS 得到：\n$$x^{\\top} (-(Q + K^{\\top} R K)) x = -x^{\\top} (Q + K^{\\top} R K) x$$\n这恰好是 RHS。因此，对于求解 Lyapunov 方程的矩阵 $P$，该关系以等式形式成立：\n$$V(x^{+}) - V(x) = -\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right)$$\n由于等式蕴含“小于或等于”条件，通过 $P$ 的构造，该不等式被平凡地验证了。为了严谨起见，我们可以重新代入我们计算出的值来证明矩阵等式 $A_K^{\\top} P A_K - P = -(Q + K^{\\top} R K)$ 成立。\n我们计算出 $A_K^{\\top} P A_K = \\begin{bmatrix} 3  3 \\\\ 3  3 \\end{bmatrix}$ 和 $P = \\begin{bmatrix} 5  5 \\\\ 5  8 \\end{bmatrix}$。\n$$A_K^{\\top} P A_K - P = \\begin{bmatrix} 3  3 \\\\ 3  3 \\end{bmatrix} - \\begin{bmatrix} 5  5 \\\\ 5  8 \\end{bmatrix} = \\begin{bmatrix} -2  -2 \\\\ -2  -5 \\end{bmatrix}$$\n并且我们计算出 $Q_{cl} = Q + K^{\\top} R K = \\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix}$。\n$$-(Q + K^{\\top} R K) = -\\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix} = \\begin{bmatrix} -2  -2 \\\\ -2  -5 \\end{bmatrix}$$\n这两个矩阵是相同的，这证实了我们对 $P$ 的求解是正确的，并验证了该条件。", "answer": "$$\\boxed{\\begin{pmatrix} 5  5 \\\\ 5  8 \\end{pmatrix}}$$", "id": "2746597"}, {"introduction": "将理论从理想的标称系统扩展到现实世界，我们必须考虑外部扰动的影响。为了在存在扰动的情况下始终满足状态和输入约束，一种关键技术是“约束收紧”。本练习将介绍鲁棒正不变（RPI）集的概念，它是一个能够包含扰动引起的所有状态变化的“安全区域”。您将通过计算最小RPI集，并由此量化所需的状态约束收紧程度，从而掌握确保鲁棒可行性的核心方法 [@problem_id:2746575]。", "problem": "考虑一个在模型预测控制 (MPC) 下的离散时间线性时不变 (LTI) 闭环误差系统，其具有加性有界扰动，动态由 $e_{k+1} = A_{K} e_{k} + w_{k}$ 给出，其中 $A_{K} \\in \\mathbb{R}^{n \\times n}$ 且对于所有 $k \\in \\mathbb{N}$ 都有 $w_{k} \\in W$。如果一个集合 $\\mathcal{E} \\subset \\mathbb{R}^{n}$ 满足 $A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$，则称其为该系统的鲁棒正不变 (RPI) 集，其中 $\\oplus$ 表示 Minkowski 和。在鲁棒 MPC 中，通常会通过 RPI 集来紧缩标称状态约束，从而使得标称状态在存在扰动的情况下仍保持可行；具体来说，对于一个对称凸约束集 $X$，一种常见的紧缩是 $X_{\\text{tight}} = X \\ominus \\mathcal{E}$，其中 $\\ominus$ 表示 Pontryagin 差。\n\n假设 $A_{K} = 0.5 I$，扰动集为轴对齐超立方体 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。标称状态约束集为 $X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。请仅使用 RPI 集、Minkowski 和以及集值级数极限的基本定义，推导最小 RPI 集 $\\mathcal{E}$，该集是通过将 $W$ 在闭环动态中重复传播所生成的 Minkowski 和级数的极限。然后，从第一性原理出发，量化所引起的无穷范数约束紧缩，该紧缩定义为必须从 $X$ 的每个边界中减去的标量 $\\tau$，使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n请提供紧缩量 $\\tau$ 的精确值作为最终答案。无需四舍五入。最终答案必须是单个实数。", "solution": "问题陈述经验证。\n\n逐字提取的已知条件如下：\n- 闭环误差动态：$e_{k+1} = A_{K} e_{k} + w_{k}$。\n- 系统矩阵：$A_{K} \\in \\mathbb{R}^{n \\times n}$。\n- 扰动：对于所有 $k \\in \\mathbb{N}$，$w_{k} \\in W$。\n- 鲁棒正不变 (RPI) 集 $\\mathcal{E}$：$A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$。\n- Minkowski 和算子：$\\oplus$。\n- Pontryagin 差算子：$\\ominus$。\n- 约束紧缩：$X_{\\text{tight}} = X \\ominus \\mathcal{E}$。\n- 特定系统矩阵：$A_{K} = 0.5 I$。\n- 特定扰动集：$W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。\n- 特定标称状态约束集：$X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。\n- 任务1：推导作为 Minkowski 和级数极限的最小 RPI 集 $\\mathcal{E}$。\n- 任务2：量化紧缩量 $\\tau$，使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n该问题在科学上基于鲁棒控制理论和模型预测控制 (MPC) 的既定原则。该问题是适定的，因为对于带​​有有界扰动的稳定 LTI 系统，最小 RPI 集的概念是标准的，并会导出一个唯一的解。问题陈述客观、完整，且不包含任何矛盾。所有术语都有数学定义，并与该领域的文献一致。因此，该问题被认为是有效的，并将提供解答。\n\n第一步是为给定系统推导最小鲁棒正不变 (RPI) 集 $\\mathcal{E}$。最小 RPI 集是在所有可能的扰动序列作用下，从原点 ($e_0 = 0$) 可达的所有状态的集合。它被构造为由系统动态传播的扰动集的无穷 Minkowski 和。\n从 $e_0 = 0$ 开始，在时间步 $k$ 的状态由以下公式给出：\n$$ e_k = \\sum_{i=0}^{k-1} A_K^i w_{k-1-i} $$\n任何时刻所有可能状态的集合是所有可达集的并集。最小 RPI 集 $\\mathcal{E}$ 是当 $k \\to \\infty$ 时这些可达集的极限：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} A_K^i W $$\n该级数收敛，因为系统矩阵 $A_K$ 是 Schur 稳定的。$A_K = 0.5 I$ 的特征值均为 $0.5$，其幅值小于 $1$。\n代入给定的 $A_K = 0.5 I$：\n$$ A_K^i = (0.5 I)^i = (0.5)^i I $$\n因此，最小 RPI 集为：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} (0.5)^i I W = \\bigoplus_{i=0}^{\\infty} (0.5)^i W $$\n扰动集 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$ 是一个凸的、中心对称的集合（一个以原点为中心的超立方体）。对于这类集合，缩放和 Minkowski 加法具有性质 $\\alpha S \\oplus \\beta S = (\\alpha+\\beta)S$，其中 $\\alpha, \\beta$ 为非负标量。将其扩展到无穷和，我们可以写出：\n$$ \\mathcal{E} = \\left( \\sum_{i=0}^{\\infty} (0.5)^i \\right) W $$\n这个和是一个公比为 $r = 0.5$ 的几何级数：\n$$ \\sum_{i=0}^{\\infty} (0.5)^i = \\frac{1}{1 - 0.5} = \\frac{1}{0.5} = 2 $$\n因此，最小 RPI 集是：\n$$ \\mathcal{E} = 2 W = 2 \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\} $$\n为了描述这个集合，令 $e \\in \\mathcal{E}$。那么对于某个 $w \\in W$，有 $e = 2w$。 $e$ 的范数为 $\\|e\\|_{\\infty} = \\|2w\\|_{\\infty} = 2\\|w\\|_{\\infty}$。由于 $\\|w\\|_{\\infty} \\le 0.1$，可得 $\\|e\\|_{\\infty} \\le 2 \\times 0.1 = 0.2$。\n所以，最小 RPI 集是超立方体：\n$$ \\mathcal{E} = \\{ e \\in \\mathbb{R}^{n} : \\|e\\|_{\\infty} \\le 0.2 \\} $$\n\n第二步是确定紧缩量 $\\tau$。紧缩后的约束集为 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$。该集合必须满足条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。这个条件确保了如果标称状态在 $X_{\\text{tight}}$ 中，那么真实状态（标称状态加误差）将保持在原始约束集 $X$ 内。\n\n我们来分析 Minkowski 和 $X_{\\text{tight}} \\oplus \\mathcal{E}$。$X_{\\text{tight}}$ 和 $\\mathcal{E}$ 都是由无穷范数边界定义的、以原点为中心的超立方体。\n- $X_{\\text{tight}}$ 是一个无穷范数半径为 $1 - \\tau$ 的超立方体。\n- $\\mathcal{E}$ 是一个无穷范数半径为 $0.2$ 的超立方体。\n两个以原点为中心的超立方体的 Minkowski 和是另一个以原点为中心的超立方体，其半径是它们半径之和。\n令 $z \\in X_{\\text{tight}} \\oplus \\mathcal{E}$。那么对于某个 $x \\in X_{\\text{tight}}$ 和 $e \\in \\mathcal{E}$，有 $z = x + e$。$z$ 的无穷范数有界，如下：\n$$ \\|z\\|_{\\infty} = \\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty} $$\n最大可能值是可以达到的，因此结果集由以下公式表征：\n$$ \\sup_{z \\in X_{\\text{tight}} \\oplus \\mathcal{E}} \\|z\\|_{\\infty} = \\sup_{x \\in X_{\\text{tight}}} \\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}} \\|e\\|_{\\infty} = (1 - \\tau) + 0.2 = 1.2 - \\tau $$\n所以，$X_{\\text{tight}} \\oplus \\mathcal{E} = \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\}$。\n条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$ 变为：\n$$ \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\} \\subseteq \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\} $$\n为使此集合包含关系成立，内部集合的半径必须小于或等于外部集合的半径：\n$$ 1.2 - \\tau \\le 1 $$\n这意味着 $0.2 \\le \\tau$。为了在保证可行性的同时做到最小化保守，我们必须为紧缩量 $\\tau$ 选择可能的最小值。满足条件的最小紧缩量是 $\\tau = 0.2$。\n\n这等价于计算 Pontryagin 差 $X \\ominus \\mathcal{E}$。根据定义，$X \\ominus \\mathcal{E} = \\{ x \\in \\mathbb{R}^n \\mid x \\oplus \\mathcal{E} \\subseteq X \\}$。\n对于此集合中的一个元素 $x$，必须对所有的 $e \\in \\mathcal{E}$ 都有 $x+e \\in X$。这意味着对于所有 $\\|e\\|_{\\infty} \\le 0.2$，都有 $\\|x+e\\|_{\\infty} \\le 1$。\n对于一个固定的 $x$，$\\|x+e\\|_{\\infty}$ 的最大值为 $\\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}}\\|e\\|_{\\infty}$。\n所以，条件是 $\\|x\\|_{\\infty} + 0.2 \\le 1$，可简化为 $\\|x\\|_{\\infty} \\le 0.8$。\n这定义了最大的紧缩集：$X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 0.8 \\}$。\n将其与给定形式 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 进行比较，我们令边界相等：\n$$ 1 - \\tau = 0.8 $$\n求解 $\\tau$ 得 $\\tau = 1 - 0.8 = 0.2$。\n紧缩量为 $\\tau = 0.2$。", "answer": "$$\n\\boxed{0.2}\n$$", "id": "2746575"}, {"introduction": "模型预测控制本质上是一种计算密集型的控制策略，其可行性和稳定性分析离不开数值方法。本练习将视角从解析推导转向算法实现，要求您通过编程来探索可行域的结构。您将通过对状态和输入空间进行离散化，构建一个N步可行集的内估计，并验证递归可行性这一关键属性，它构成了许多MPC稳定性证明的理论基础 [@problem_id:2746631]。", "problem": "考虑用于模型预测控制（MPC）的离散时间线性时不变系统，由状态更新方程 $x_{k+1} = A x_k + B u_k$ 定义，其中 $x_k \\in \\mathbb{R}^2$ 且 $u_k \\in \\mathbb{R}$。设 $A = \\begin{bmatrix}1  1 \\\\ 0  1\\end{bmatrix}$ 且 $B = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$。状态约束集为 $X = \\{ x \\in \\mathbb{R}^2 : \\|x\\|_{\\infty} \\le 1 \\}$，输入约束集为 $U = \\{ u \\in \\mathbb{R} : |u| \\le u_{\\max} \\}$。$N$步可行集 $X_N$ 通过基本的可行前驱算子递归定义如下：对于任意集合 $S \\subseteq \\mathbb{R}^2$，定义 $\\mathrm{Pre}(S) = \\{ x \\in X : \\exists u \\in U \\text{ 使得 } A x + B u \\in S \\}$。则 $X_0 = X$ 且对于 $k \\ge 0$ 有 $X_{k+1} = \\mathrm{Pre}(X_k)$。集合 $X_N$ 包含所有初始状态 $x_0$，对于这些状态，存在一个输入序列 $(u_0,\\dots,u_{N-1})$（其中每个 $u_i \\in U$），使得预测状态在 $N$ 步内保持在 $X$ 中。\n\n您的任务是：\n\n1) 仅使用上述基本定义，不借助任何预计算公式，通过对 $X$ 进行网格化和对 $U$ 进行离散化，构造一个 $X_3$ 的非空内逼近。具体来说：\n- 在 $X$ 上使用一个均匀的矩形网格，每个坐标的间距为 $\\Delta$。对于每个网格点 $x_0$，通过检查是否存在一个从有限离散集 $U_{\\mathrm{disc}} \\subset U$ 中抽取的序列 $(u_0,\\dots,u_{N-1})$，使得在 $x_{k+1} = A x_k + B u_k$ 下的 $N$ 步前向仿真在每个预测步都保持在 $X$ 内部，来确定其在内逼近 $\\widehat{X}_N$ 中的成员资格。因为 $U_{\\mathrm{disc}} \\subset U$ 并且 $X$ 上的网格是有限的，所以得到的集合是 $X_N$ 的一个可计算的内逼近。\n\n2) 通过标准的MPC候选序列论证，验证单步递归可行性：对于每个 $x_0 \\in \\widehat{X}_N$，取任何一个证明其成员资格的可行输入序列 $(u_0,\\dots,u_{N-1})$。通过平移并追加的方式，即 $(u_1,\\dots,u_{N-1}, u_N)$，形成下一时刻的候选序列。通过找到某个 $u_N \\in U_{\\mathrm{disc}}$ 使得额外的预测状态 $x_{N+1} \\in X$，来证明下一时刻的可行性。结论是，对于从 $x_1$ 开始且具有相同约束集的时域-$N$问题，该平移后的序列是一个可行的候选序列。您的程序应输出一个布尔值，表示此单步递归可行性检查是否对每个 $x_0 \\in \\widehat{X}_N$ 都成功。\n\n您必须使用 $X$ 上的有限网格和 $U$ 的有限离散化来实现上述任务。使用以下测试套件（每个案例指定 $u_{\\max}$、时域 $N$ 和网格间距 $\\Delta$；所有案例使用相同的 $A$、 $B$ 和 $X$）：\n- 测试 1 (正常情况): $u_{\\max} = 0.5$, $N = 3$, $\\Delta = 0.5$。\n- 测试 2 (更严格的输入边界): $u_{\\max} = 0.25$, $N = 3$, $\\Delta = 0.5$。\n- 测试 3 (边界时域): $u_{\\max} = 0.5$, $N = 1$, $\\Delta = 0.5$。\n- 测试 4 (更长的时域): $u_{\\max} = 0.5$, $N = 4$, $\\Delta = 0.5$。\n\n对于所有案例，使用离散输入集 $U_{\\mathrm{disc}} = \\{-u_{\\max}, 0, u_{\\max}\\}$ 和由 $\\{ x \\in \\mathbb{R}^2 : x_i \\in \\{-1, -1+\\Delta, \\dots, 1-\\Delta, 1\\}, i=1,2 \\}$ 定义的状态网格。\n\n您的程序必须：\n- 对于每个测试案例，计算内逼近 $\\widehat{X}_N \\subseteq X$ 的基数（即，存在至少一个来自 $U_{\\mathrm{disc}}$ 的可行 $N$ 步序列，能使预测状态保持在 $X$ 中的网格点 $x_0$ 的数量）。\n- 对于每个测试案例，输出一个布尔值，该值为真的充要条件是 $\\widehat{X}_N$ 非空，并且通过移位候选序列的单步递归可行性检查对 $\\widehat{X}_N$ 中的每个 $x_0$ 都成功。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个类似Python列表的列表形式的结果。每个内部列表对应一个测试案例，并恰好包含两个元素：第一个是 $\\widehat{X}_N$ 的整数基数，第二个是表示对于该案例中 $\\widehat{X}_N$ 内所有点，候选序列的递归可行性检查是否通过的布尔值。除此单行外，不要打印任何额外文本。", "solution": "该问题要求对一个离散时间线性时不变系统的有限时域可行集进行数值研究，这是模型预测控制（MPC）分析与实现中的一项基本任务。该系统由状态更新方程 $x_{k+1} = A x_k + B u_k$ 描述，给定矩阵 $A = \\begin{bmatrix}1  1 \\\\ 0  1\\end{bmatrix}$ 和 $B = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$。状态 $x_k$ 和输入 $u_k$ 分别被约束在多胞集 $X = \\{ x \\in \\mathbb{R}^2 : \\|x\\|_{\\infty} \\le 1 \\}$ 和 $U = \\{ u \\in \\mathbb{R} : |u| \\le u_{\\max} \\}$ 中。\n\n求解过程按要求分两个阶段进行。首先，我们构造真实$N$步可行集 $X_N$ 的一个可计算内逼近，记为 $\\widehat{X}_N$。其次，我们验证与此计算集内所有点的递归可行性相关的一个关键属性。\n\n我们数值方法的基础是对连续的状态和输入空间进行离散化。状态约束集 $X$（即正方形 $[-1, 1] \\times [-1, 1]$）被一个有限的点网格所替代。对于给定的间距 $\\Delta$，该网格由所有点 $(x_1, x_2)$ 组成，其中 $x_1, x_2 \\in \\{-1, -1+\\Delta, \\dots, 1-\\Delta, 1\\}$。输入约束集 $U$ 被离散化为一个有限集 $U_{\\mathrm{disc}} = \\{-u_{\\max}, 0, u_{\\max}\\}$。这些有限表示将问题从一个无限搜索问题转化为一个组合评估问题，尽管其规模可能很大。\n\n**第1部分：内逼近 $\\widehat{X}_N$ 的构造**\n\n$N$步可行集 $X_N$ 是所有初始状态 $x_0 \\in X$ 的集合，对于这些状态，存在一个可行的输入序列 $(u_0, \\dots, u_{N-1})$，能在 $N$ 步内将整个状态轨迹保持在 $X$ 中。我们的内逼近 $\\widehat{X}_N$ 是通过将初始状态集和可用输入集都限制为其离散对应物来构造的。\n\n算法如下：\n1.  遍历 $X$ 上定义的网格中的每个初始状态 $x_0$。\n2.  对于每个 $x_0$，系统地测试所有可能的输入序列 $(u_0, \\dots, u_{N-1})$，其中每个 $u_k$ 从 $U_{\\mathrm{disc}}$ 中抽取。此类序列的总数为 $|U_{\\mathrm{disc}}|^N=3^N$。\n3.  对于每个候选序列，使用动力学模型 $x_{k+1} = A x_k + B u_k$ 进行 $N$ 步前向系统仿真。\n4.  在每一步 $k \\in \\{1, \\dots, N\\}$，检查所得状态 $x_k$ 是否满足状态约束，即 $\\|x_k\\|_{\\infty} \\le 1$。\n5.  如果整个状态轨迹 $(x_1, \\dots, x_N)$ 均保持在 $X$ 内，则该输入序列被视为对初始状态 $x_0$ 的“认证”或可行序列。\n6.  如果至少找到了一个这样的认证序列，则初始状态 $x_0$ 被包含在集合 $\\widehat{X}_N$ 中。\n7.  对于每个 $x_0 \\in \\widehat{X}_N$ 的所有认证序列都必须存储起来，以供第二部分的分析使用。\n8.  $\\widehat{X}_N$ 的基数是满足此标准的网格点的总数。\n\n这种前向仿真或“穷举”法保证了 $\\widehat{X}_N$ 是一个内逼近，即 $\\widehat{X}_N \\subseteq X_N$，因为它是使用更严格的初始状态集（有限网格）和输入集（$U_{\\mathrm{disc}} \\subset U$）构造的。\n\n**第2部分：单步递归可行性的验证**\n\n递归可行性是MPC稳定性证明的基石。它确保如果控制问题在当前时刻存在可行解，那么在下一时刻也存在可行解。保证这一点的常用方法是证明一个根据前一最优解构造的候选解总是可用且可行的。本问题要求我们验证一个能使该论证成立的条件。\n\n在时刻 $k+1$ 的候选输入序列通常是通过取前一最优序列 $(u_1^*, \\dots, u_{N-1}^*)$，将其平移，并追加某个新输入 $u_N$ 来形成的。为使此策略有效，我们必须确保总能找到一个维持可行性的 $u_N$。\n\n验证算法如下：\n1.  仅当 $\\widehat{X}_N$ 非空时，整体检查才可能通过。如果 $\\widehat{X}_N$ 为空，检查失败。\n2.  如果 $\\widehat{X}_N$ 非空，我们必须遍历 $\\widehat{X}_N$ 中的每个点 $x_0$。\n3.  对于每个这样的 $x_0$，我们必须接着遍历其在第1部分中找到的*每一个*认证序列 $(u_0^*, \\dots, u_{N-1}^*)$。该条件必须普遍成立。\n4.  对于给定的 $x_0$ 和认证序列对，计算相应轨迹的终端状态：$x_N = A x_{N-1} + B u_{N-1}^*$。\n5.  检查是否存在至少一个输入 $u_N \\in U_{\\mathrm{disc}}$，使得下一步的状态 $x_{N+1} = A x_N + B u_N$ 满足状态约束 $\\|x_{N+1}\\|_{\\infty} \\le 1$。这通过测试 $U_{\\mathrm{disc}}$ 中的三个值来完成。\n6.  如果对于任何 $x_0 \\in \\widehat{X}_N$ 及其任何一个认证序列，找不到这样的 $u_N$，则递归可行性属性不成立。该测试案例的总体结果为 `False`，并且可以终止该过程。\n7.  如果该条件对 $\\widehat{X}_N$ 中的所有点及其各自所有的认证序列都成立，则该测试案例的总体结果为 `True`。\n\n这个穷举检查确认了所选择的离散化是否支持平移并追加的候选解策略，这是真实连续空间可行集属性的一个离散模拟。所提供的Python代码为每个指定的测试案例实现了这一完整的验证和确认过程。", "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport sys\n\ndef solve():\n    \"\"\"\n    Solves the MPC feasibility problem for the given test cases.\n    \"\"\"\n    # The problem statement requests output to be Python-like, which may be interpreted\n    # as having spaces. To be safe and unambiguous, printing with an f-string is robust.\n    # The default boolean representation ('True', 'False') is standard.\n    # Disabling the default formatter's behavior for strictness.\n    # pylint: disable=f-string-without-interpolation, consider-using-f-string\n    \n    # Define matrix A and B from the problem statement\n    A = np.array([[1.0, 1.0], [0.0, 1.0]])\n    B = np.array([[0.0], [1.0]])\n\n    # Define the test cases\n    test_cases = [\n        (0.5, 3, 0.5),   # Test 1 (happy path)\n        (0.25, 3, 0.5),  # Test 2 (tighter input bound)\n        (0.5, 1, 0.5),   # Test 3 (boundary horizon)\n        (0.5, 4, 0.5),   # Test 4 (longer horizon)\n    ]\n\n    all_results = []\n\n    for u_max, N, delta in test_cases:\n        # Discretize input space U\n        U_disc = np.array([-u_max, 0.0, u_max])\n\n        # Generate grid for state space X\n        grid_coords = np.arange(-1.0, 1.0 + delta / 2.0, delta)\n        x0_grid_tuples = list(product(grid_coords, grid_coords))\n\n        # Generate all possible input sequences of length N\n        input_sequences = list(product(U_disc, repeat=N))\n\n        # Dictionary to store initial states in hat_X_N and their certifying sequences\n        hat_X_N_data = {}\n\n        # --- Part 1: Construct inner approximation hat_X_N ---\n        for x0_tuple in x0_grid_tuples:\n            x0 = np.array(x0_tuple).reshape(2, 1)\n            certifying_sequences = []\n\n            for u_seq in input_sequences:\n                is_traj_feasible = True\n                x_k = x0\n                \n                # Simulate system for N steps\n                for k in range(N):\n                    u_k = u_seq[k]\n                    # State update: x_{k+1} = A*x_k + B*u_k\n                    x_k_plus_1 = A @ x_k + B * u_k\n                    # Check state constraints: ||x_{k+1}||_inf = 1\n                    # A small tolerance is used for robust floating point comparison.\n                    if np.any(np.abs(x_k_plus_1)  1.0 + 1e-9):\n                        is_traj_feasible = False\n                        break\n                    x_k = x_k_plus_1\n                \n                if is_traj_feasible:\n                    certifying_sequences.append(u_seq)\n            \n            if certifying_sequences:\n                hat_X_N_data[x0_tuple] = certifying_sequences\n\n        cardinality = len(hat_X_N_data)\n\n        # --- Part 2: Verify one-step recursive feasibility ---\n        recursive_feasibility_ok = True\n        if cardinality == 0:\n            # If hat_X_N is empty, the condition is not met.\n            recursive_feasibility_ok = False\n        else:\n            # Check must hold for every x0 in hat_X_N and every one of its certifying sequences\n            for x0_tuple, c_seqs in hat_X_N_data.items():\n                x0 = np.array(x0_tuple).reshape(2, 1)\n                \n                for u_seq in c_seqs:\n                    # Find the terminal state x_N for this trajectory\n                    x_N = x0\n                    for u_k in u_seq:\n                        x_N = A @ x_N + B * u_k\n                        \n                    # Check if there exists a u_N in U_disc s.t. A*x_N + B*u_N is in X\n                    terminal_condition_met = False\n                    for u_N in U_disc:\n                        x_N_plus_1 = A @ x_N + B * u_N\n                        if np.all(np.abs(x_N_plus_1) = 1.0 + 1e-9):\n                            terminal_condition_met = True\n                            break\n                            \n                    if not terminal_condition_met:\n                        # If check fails for even one sequence, the overall check fails\n                        recursive_feasibility_ok = False\n                        break  # Break from c_seqs loop\n                \n                if not recursive_feasibility_ok:\n                    break  # Break from hat_X_N_data loop\n\n        all_results.append([cardinality, recursive_feasibility_ok])\n\n    # Print results in the required format\n    # Example: [[5, True], [2, False]]\n    print(str(all_results))\n\n# Execute the main function\nsolve()\n```", "id": "2746631"}]}