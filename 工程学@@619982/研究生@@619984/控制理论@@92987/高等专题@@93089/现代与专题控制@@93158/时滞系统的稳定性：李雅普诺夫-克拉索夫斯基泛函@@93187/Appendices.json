{"hands_on_practices": [{"introduction": "我们实践的第一步是回答有关时间延迟系统的一个根本问题：系统的稳定性是否依赖于延迟的大小？本练习将通过比较一个简单但保守的“延迟无关”稳定性测试与一个更精确的“延迟相关”测试来探讨这一问题。通过这个练习 [@problem_id:2747657]，你将发现一个具体场景：对于一个给定的延迟，系统实际上是稳定的，但简单方法却无法证明其稳定性，从而体会到为何延迟相关分析的额外复杂性往往是必要的。", "problem": "考虑由延迟型泛函微分方程描述的线性时滞系统 $\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)$,\n其中时滞 $h \\ge 0$ 为常数，$a,b \\in \\mathbb{R}$ 为实标量。要求您实现两种基于Lyapunov的稳定性认证测试，并展示一个时滞无关测试未能检测到稳定性，而基于经Wirtinger增强的Lyapunov-Krasovskii泛函（LKF）的时滞相关测试却成功的案例。\n\n您的程序必须实现以下两个充分条件：\n\n1) 仅使用状态和积分能量的时滞无关Lyapunov-Krasovskii泛函（LKF）测试：\n- 考虑泛函 $V(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds$，其中 $p > 0$ 且 $q > 0$。其沿解的时间导数为 $\\dot{V}(t) = 2 p\\,x(t)\\,\\dot{x}(t) + q\\,x(t)^2 - q\\,x(t-h)^2$。\n将 $\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)$ 代入，得到关于 $[\\,x(t),\\,x(t-h)\\,]^T$ 的二次型：\n$$\n\\dot{V}(t) = \n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}^\\top\n\\underbrace{\\begin{bmatrix}\n2 p a + q & p b \\\\\np b & -q\n\\end{bmatrix}}_{M(p,q)}\n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}.\n$$\n如果存在 $p>0,q>0$ 使得 $M(p,q) \\prec 0$（负定），则对于所有 $h \\ge 0$，原点都是渐近稳定的。这是一个时滞无关测试。\n\n2) 经Wirtinger增强的时滞相关LKF测试：\n- 考虑增强的泛函\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds + \\int_{t-h}^{t}\\int_{\\xi}^{t} r\\,\\dot{x}(\\tau)^2\\,d\\tau\\,d\\xi,\n$$\n其中 $p>0, q>0, r>0$。其时间导数满足\n$$\n\\dot{V}(t) = 2 p\\,x(t)\\,\\dot{x}(t) + q\\big(x(t)^2 - x(t-h)^2\\big) + r\\,h\\,\\dot{x}(t)^2 - r\\int_{t-h}^{t} \\dot{x}(s)^2\\,ds.\n$$\n使用不等式\n$$\n\\int_{t-h}^{t} \\dot{x}(s)^2 ds \\ge \\frac{1}{h}\\big(x(t) - x(t-h)\\big)^2,\n$$\n并代入 $\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)$，可以得到一个上界\n$$\n\\dot{V}(t) \\le \n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}^\\top\n\\underbrace{\\begin{bmatrix}\n2 p a + q + r h a^2 - \\frac{r}{h} & p b + r h a b + \\frac{r}{h} \\\\\np b + r h a b + \\frac{r}{h} & -q + r h b^2 - \\frac{r}{h}\n\\end{bmatrix}}_{N(p,q,r;h)}\n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}.\n$$\n如果存在 $p>0, q>0, r>0$ 使得 $N(p,q,r;h) \\prec 0$，则对于该特定时滞 $h$，原点是渐近稳定的。这是一个通过导数项和积分不等式（一个Wirtinger型界）加强的时滞相关测试。\n\n您的任务是：\n- 将两种测试实现为计算程序，通过搜索决策变量来检测一个可行的证签。\n- 对每个测试，您必须通过检查相关的对称$2\\times 2$矩阵是否为负定（即所有特征值都严格为负）来判断可行性。使用一个小的数值容差，仅当矩阵的最大特征值低于$-10^{-9}$时，才将其视为负定。\n\n测试套件：\n- 使用以下参数集 $\\{(a,b,h)\\}$：\n    1) $a=-0.3,\\, b=-0.8,\\, h=0.5$\n    2) $a=-0.3,\\, b=-0.8,\\, h=1.6$\n    3) $a=-0.3,\\, b=-0.8,\\, h=3.0$\n    4) $a=-2.0,\\, b=0.5,\\, h=3.0$\n- 对每种情况，返回一个包含两个整数的列表 $[d_1,d_2]$，其中：\n    - $d_1 \\in \\{0,1\\}$ 表示时滞无关LKF测试是否找到了一个证签（1表示成功，0表示失败）。\n    - $d_2 \\in \\{0,1\\}$ 表示经Wirtinger增强的时滞相关LKF测试是否为给定的$h$找到了一个证签（1表示成功，0表示失败）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个结果，格式为四个双整数列表的逗号分隔列表，不含空格，并用方括号括起来。例如：\n[[0,1],[0,1],[0,0],[1,1]]\n不涉及物理单位。不使用角度。不使用百分比。", "solution": "该问题已经过严格验证，并被确认为有效。其科学基础是控制理论的既定原则，特别是使用Lyapunov-Krasovskii泛函对时滞系统进行的稳定性分析。泛函的时间导数及其产生的矩阵不等式的数学公式是正确的。该问题提法明确，提供了一套清晰、客观、完整的规范，可以据此开发和验证计算解。问题中没有科学上的不准确、模糊或矛盾之处。我们将开始解答。\n\n该问题要求为由以下方程描述的线性时滞系统实现两种不同的稳定性测试：\n$$\n\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)\n$$\n其中 $a, b \\in \\mathbb{R}$ 是常系数，$h \\ge 0$ 是时滞。目标是对于几组参数集 $\\{a, b, h\\}$，确定每种稳定性测试是否可以认证系统原点的渐近稳定性。如果存在一组正决策变量使得特定的测试矩阵为负定，则认为找到了一个证签。一个对称矩阵是负定的，当且仅当其最大特征值严格为负。出于计算目的，我们将使用指定的阈值，即最大特征值必须小于$-10^{-9}$。\n\n第一个测试是一个时滞无关条件，意味着如果该条件满足，系统对所有非负时滞 $h \\ge 0$ 都是稳定的。第二个测试是时滞相关的，即使在第一个测试失败的情况下，也可能为特定的 $h$ 值认证稳定性。这展示了稳定性判据的通用性与其保守性之间的权衡。\n\n### 测试1：时滞无关Lyapunov-Krasovskii泛函\n\n该测试使用以下泛函：\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds\n$$\n稳定性条件要求找到正标量 $p > 0$ 和 $q > 0$，使得矩阵 $M(p,q)$ 为负定（$M(p,q) \\prec 0$），其中：\n$$\nM(p,q) = \\begin{bmatrix}\n2 p a + q & p b \\\\\np b & -q\n\\end{bmatrix}\n$$\n该条件关于决策变量是齐次的；如果($p, q$)是一个可行解，那么对于任何$\\alpha > 0$，($\\alpha p, \\alpha q$)也是一个可行解。这允许我们固定一个变量，例如$p=1$，并将搜索简化为寻找可行$q > 0$的一维问题。计算过程将涉及在$q$的一系列正值范围内进行数值搜索。对于每个$q$，构造矩阵$M(1, q)$并计算其特征值。如果两个特征值都小于所要求的容差$-10^{-9}$，则表明已找到证签，测试成功。\n\n### 测试2：经Wirtinger增强的时滞相关LKF\n\n该测试采用了一个更复杂的泛函，其中包含一个涉及状态导数的积分项，并通过Wirtinger不等式进行增强，以推导出更紧的界：\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds + \\int_{t-h}^{t}\\int_{\\xi}^{t} r\\,\\dot{x}(\\tau)^2\\,d\\tau\\,d\\xi\n$$\n此处的稳定性条件是，对于一个*特定的*时滞$h$，找到正标量$p > 0, q > 0, r > 0$，使得矩阵$N(p,q,r;h) \\prec 0$，其中：\n$$\nN(p,q,r;h) = \\begin{bmatrix}\n2 p a + q + r h a^2 - \\frac{r}{h} & p b + r h a b + \\frac{r}{h} \\\\\np b + r h a b + \\frac{r}{h} & -q + r h b^2 - \\frac{r}{h}\n\\end{bmatrix}\n$$\n与第一个测试类似，这是一个在$p, q, r$上齐次的可行性问题。我们可以固定$p=1$，然后搜索一对正标量($q, r$)。实现时将对$q$和$r$在一个预定义的正值范围内执行二维网格搜索。对于每一对($q, r$)，构造矩阵$N(1,q,r;h)$，计算其特征值，并检查其负定性条件。如果找到一个可行的配对，则对于给定的$h$值，测试成功。\n\n### 计算搜索策略\n\n对于两种测试，决策变量的搜索实现如下：\n- **测试1：** 在固定$p=1$的情况下，对$q$执行一维线性搜索。$q$的搜索空间是一个足够大区间（例如`[1e-6, 100]`）内的点的网格。\n- **测试2：** 在固定$p=1$的情况下，对($q, r$)执行二维网格搜索。搜索空间是$q$和$r$的两个线性网格的笛卡尔积，例如`[1e-4, 50] x [1e-4, 50]`。\n\n- 对于搜索空间中的每个点，构造相应的矩阵（$M$或$N$），并使用针对对称矩阵的鲁棒数值方法计算其特征值。如果最大特征值低于容差$-10^{-9}$，则搜索成功终止。如果在耗尽整个搜索空间后仍未找到证签，则该测试被视为失败。这种计算方法直接解决了由稳定性条件提出的可行性问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_neg_def(matrix: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a symmetric 2x2 matrix is negative definite.\n    A matrix is negative definite if all its eigenvalues are strictly negative.\n    The check is performed against a specified numerical tolerance.\n    \"\"\"\n    # eigvalsh is efficient for symmetric matrices\n    eigenvalues = np.linalg.eigvalsh(matrix)\n    return np.max(eigenvalues) < -1e-9\n\ndef run_test_1(a: float, b: float) -> int:\n    \"\"\"\n    Implements the delay-independent LKF test by searching for a feasible certificate.\n    It fixes p=1 and performs a 1D search for q > 0.\n\n    Args:\n        a (float): System parameter 'a'.\n        b (float): System parameter 'b'.\n\n    Returns:\n        int: 1 if stable (certificate found), 0 otherwise.\n    \"\"\"\n    p = 1.0  # Fix p=1 due to homogeneity\n    \n    # Search for a feasible q > 0 on a linear grid\n    q_vals = np.linspace(1e-6, 100.0, 2000)\n    \n    for q in q_vals:\n        M = np.array([\n            [2 * p * a + q, p * b],\n            [p * b, -q]\n        ])\n        \n        if check_neg_def(M):\n            return 1\n            \n    return 0\n\ndef run_test_2(a: float, b: float, h: float) -> int:\n    \"\"\"\n    Implements the Wirtinger-enhanced delay-dependent LKF test for a given h.\n    It fixes p=1 and performs a 2D grid search for q > 0 and r > 0.\n\n    Args:\n        a (float): System parameter 'a'.\n        b (float): System parameter 'b'.\n        h (float): System delay 'h'.\n\n    Returns:\n        int: 1 if stable (certificate found), 0 otherwise.\n    \"\"\"\n    # h must be positive for this test\n    if h <= 0:\n        return 0\n\n    p = 1.0  # Fix p=1\n    \n    # Define a 2D grid for the search\n    q_vals = np.linspace(1e-4, 50.0, 150)\n    r_vals = np.linspace(1e-4, 50.0, 150)\n    \n    # Pre-calculate h-dependent terms for efficiency\n    ha2 = h * a**2\n    hb2 = h * b**2\n    hab = h * a * b\n    r_over_h = 1.0 / h\n\n    for q in q_vals:\n        for r in r_vals:\n            # Construct the N(p,q,r;h) matrix with p=1\n            r_term_11 = r * (ha2 - r_over_h)\n            r_term_12 = r * (hab + r_over_h)\n            r_term_22 = r * (hb2 - r_over_h)\n            \n            N11 = 2 * a + q + r_term_11\n            N12 = b + r_term_12\n            N22 = -q + r_term_22\n            \n            N = np.array([\n                [N11, N12],\n                [N12, N22]\n            ])\n            \n            if check_neg_def(N):\n                return 1\n                \n    return 0\n\ndef solve():\n    \"\"\"\n    Main function to run the stability tests on the provided test suite\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-0.3, -0.8, 0.5),\n        (-0.3, -0.8, 1.6),\n        (-0.3, -0.8, 3.0),\n        (-2.0, 0.5, 3.0)\n    ]\n\n    results = []\n    for a, b, h in test_cases:\n        d1 = run_test_1(a, b)\n        d2 = run_test_2(a, b, h)\n        results.append(f\"[{d1},{d2}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2747657"}, {"introduction": "Lyapunov-Krasovskii 泛函分析中的一个主要保守性来源是我们如何处理其中的积分项。这个练习 [@problem_id:2747627] 专注于这一核心问题，带你超越基础的 Jensen 不等式。你将通过数值计算，比较一系列从正交多项式导出的、愈发复杂的积分不等式（如 Wirtinger 型和 Bessel-Legendre 型不等式）的紧密程度，从而具体理解这些高等数学工具是如何减少分析的保守性，并获得更精确的稳定性估计。", "problem": "考虑一个出现在时滞系统的李雅普诺夫–克拉索夫斯基（Lyapunov–Krasovskii）泛函中的标量时滞泛函项：二次积分 $\\int_{0}^{h} x(s)^{2} \\, ds$ 乘以一个正常数 $Q > 0$（代表简化为标量情况的对称正定矩阵）。对于区间 $[0,h]$ 上的一个给定光滑标量函数 $x(s)$，定义其精确值为\n$$\nI(Q,h;x) = Q \\int_{0}^{h} x(s)^{2} \\, ds.\n$$\n在稳定性分析中，一个常见的任务是使用积分不等式来求 $I(Q,h;x)$ 的下界。此类界分为三族：\n- 詹森（Jensen）不等式界，仅使用 $x(s)$ 在 $[0,h]$ 上的均值。\n- 基于Wirtinger的界，在均值的基础上增加了一阶移位勒让德（Legendre）模态。\n- 贝塞尔–勒让德（Bessel–Legendre）界，将 $x(s)$ 在移位勒让德多项式基上的正交展开截断至指定阶数。\n\n您的任务是，对下文指定的每个测试用例，计算以下三个下界，并报告它们相对于 $I(Q,h;x)$ 的紧度：\n1. 基于 $x(s)$ 均值的詹森界 $L_{J}$。\n2. 基于前两个移位勒让德模态（0次和1次）的Wirtinger界 $L_{W}$。\n3. 基于前三个移位勒让德模态（0次、1次和2次）的贝塞尔–勒让德界 $L_{BL}$。\n\n任何三角函数中的所有角度均以弧度为单位。\n\n需要使用的基本原理：\n- 积分的柯西–施瓦茨（Cauchy–Schwarz）不等式和詹森（Jensen）不等式。\n- 移位勒让德多项式在 $[0,1]$ 上的正交性，即，如果 $P_{k}(\\tau)$ 是 $[-1,1]$ 上的 $k$ 次勒让德多项式，那么 $[0,1]$ 上的 $P_{k}^{\\text{sh}}(\\tau) = P_{k}(2\\tau - 1)$ 满足\n$$\n\\int_{0}^{1} P_{k}^{\\text{sh}}(\\tau)\\, P_{\\ell}^{\\text{sh}}(\\tau)\\, d\\tau = \\begin{cases}\n\\frac{1}{2k+1} & k = \\ell \\\\[4pt]\n0 & k \\neq \\ell\n\\end{cases}.\n$$\n- 标准正交展开的贝塞尔（Bessel）不等式。\n\n需要实现的定义：\n- 定义 $\\tau = s/h$，使得 $s \\in [0,h]$ 映射到 $\\tau \\in [0,1]$ 且 $ds = h\\, d\\tau$。\n- 设 $P_{k}^{\\text{sh}}(\\tau)$ 为 $[0,1]$ 上的 $k$ 次移位勒让德多项式。使用 $[0,1]$ 上的标准正交族 $\\varphi_{k}(\\tau) = \\sqrt{2k+1}\\, P_{k}^{\\text{sh}}(\\tau)$，定义系数\n$$\nc_{k} = \\int_{0}^{1} x(h \\tau)\\, \\varphi_{k}(\\tau)\\, d\\tau = \\frac{\\sqrt{2k+1}}{h}\\, \\int_{0}^{h} P_{k}^{\\text{sh}}\\!\\left(\\frac{s}{h}\\right) x(s)\\, ds.\n$$\n- $N$ 阶的贝塞尔–勒让德下界为\n$$\nL_{N}(Q,h;x) = Q h \\sum_{k=0}^{N} c_{k}^{2} = \\frac{Q}{h} \\sum_{k=0}^{N} (2k+1)\\, \\left(\\int_{0}^{h} P_{k}^{\\text{sh}}\\!\\left(\\frac{s}{h}\\right) x(s)\\, ds\\right)^{2}.\n$$\n- 詹森界对应于 $N = 0$，即 $L_{J} = L_{0}(Q,h;x)$。\n- 此处的基于Wirtinger的界对应于 $N = 1$，即 $L_{W} = L_{1}(Q,h;x)$。\n- 要使用的贝塞尔–勒让德界是二阶截断 $N = 2$，即 $L_{BL} = L_{2}(Q,h;x)$。\n\n对于每个测试用例，以高精度数值计算精确积分 $I(Q,h;x)$，通过上述公式计算三个下界 $L_{J}$、$L_{W}$ 和 $L_{BL}$，并报告紧度比\n$$\n\\rho_{J} = \\frac{L_{J}}{I(Q,h;x)}, \\qquad\n\\rho_{W} = \\frac{L_{W}}{I(Q,h;x)}, \\qquad\n\\rho_{BL} = \\frac{L_{BL}}{I(Q,h;x)}.\n$$\n\n测试套件：\n- 用例1（单位区间上的一般三角–仿射函数）：$Q = 2.0$, $h = 1.0$，以及对于 $s \\in [0,1]$，$x(s) = \\sin(2\\pi s) + 0.3\\, s - 0.1$。\n- 用例2（小区间行为）：$Q = 5.0$, $h = 0.05$，以及对于 $s \\in [0,0.05]$，$x(s) = \\sin(2\\pi s) + 0.3\\, s - 0.1$。\n- 用例3（较长区间）：$Q = 1.5$, $h = 2.0$，以及对于 $s \\in [0,2]$，$x(s) = \\sin(2\\pi s) + 0.3\\, s - 0.1$。\n- 用例4（以移位勒让德基表示的最高2次多项式；在 $N=2$ 时界变为精确值）：$Q = 1.0$, $h = 3.0$，以及\n$$\nx(s) = a + b\\,\\Big(2\\frac{s}{h} - 1\\Big) + c\\,\\Big(6\\Big(\\frac{s}{h}\\Big)^{2} - 6\\frac{s}{h} + 1\\Big),\n$$\n其中 $a = 0.7$, $b = -1.2$, $c = 0.9$，对于 $s \\in [0,3]$。\n- 用例5（高度振荡函数）：$Q = 0.7$, $h = 1.0$，以及对于 $s \\in [0,1]$，$x(s) = \\sin(10\\pi s) + 0.2\\, \\cos(3\\pi s) - 0.05$。\n\n要求的最终输出格式：\n- 对于每个用例，计算三元组 $(\\rho_{J}, \\rho_{W}, \\rho_{BL})$ 并将每个条目四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含结果，格式为由逗号分隔的三元组列表，并用方括号括起来，不含空格。例如，包含两个用例的有效输出如下所示：“[[0.123456,0.234567,0.345678],[0.987654,0.876543,0.765432]]”。", "solution": "问题陈述经评估有效。它在控制理论和应用数学领域具有科学依据，特别是关于使用李雅普诺夫–克拉索夫斯基（Lyapunov-Krasovskii）泛函进行时滞系统的稳定性分析。该问题是适定的、客观的，并包含得出唯一解所需的所有必要信息和定义。所提供的任务在计算上是可行的，并且基于积分不等式和正交多项式展开等已建立的数学原理。\n\n问题的核心是将积分项 $I(Q,h;x) = Q \\int_{0}^{h} x(s)^{2} \\, ds$ 的精确值与从函数 $x(s)$ 的谱展开导出的若干下界进行比较。该分析在平方可积函数的希尔伯特（Hilbert）空间中进行，而这些界是贝塞尔（Bessel）不等式的直接推论。\n\n让我们首先进行变量替换，将积分区间从 $[0,h]$ 映射到 $[0,1]$。令 $\\tau = s/h$，这意味着 $s = h\\tau$ 且 $ds = h\\, d\\tau$。积分 $I(Q,h;x)$ 可以重写为：\n$$\nI(Q,h;x) = Q \\int_{0}^{1} x(h\\tau)^{2} \\, (h\\, d\\tau) = Qh \\int_{0}^{1} [x(h\\tau)]^{2} \\, d\\tau.\n$$\n令 $y(\\tau) = x(h\\tau)$。该积分为 $I = Qh \\int_{0}^{1} y(\\tau)^2 d\\tau = Qh \\|y\\|_{L^2[0,1]}^2$，其中 $\\| \\cdot \\|_{L^2[0,1]}$ 是区间 $[0,1]$ 上平方可积函数空间中的标准范数。\n\n该问题利用了在 $[0,1]$ 上正交的移位勒让德（Legendre）多项式基 $P_{k}^{\\text{sh}}(\\tau)$。其正交关系由下式给出：\n$$\n\\int_{0}^{1} P_{k}^{\\text{sh}}(\\tau)\\, P_{\\ell}^{\\text{sh}}(\\tau)\\, d\\tau = \\frac{\\delta_{k\\ell}}{2k+1},\n$$\n其中 $\\delta_{k\\ell}$ 是克罗内克（Kronecker）δ。由此，我们可以为 $L^2[0,1]$ 构建一个标准正交基 $\\{\\varphi_k(\\tau)\\}_{k=0}^{\\infty}$：\n$$\n\\varphi_{k}(\\tau) = \\sqrt{2k+1}\\, P_{k}^{\\text{sh}}(\\tau).\n$$\n任何函数 $y(\\tau) \\in L^2[0,1]$ 都可以用此基展开为 $y(\\tau) = \\sum_{k=0}^{\\infty} c_k \\varphi_k(\\tau)$，其中系数 $c_k$ 是 $y$ 在基函数上的投影：\n$$\nc_{k} = \\langle y, \\varphi_k \\rangle = \\int_{0}^{1} y(\\tau)\\, \\varphi_{k}(\\tau)\\, d\\tau.\n$$\n根据帕塞瓦尔（Parseval）恒等式，函数的范数平方是其傅里叶–勒让德系数的平方和：$\\|y\\|^2 = \\sum_{k=0}^{\\infty} c_k^2$。因此，精确积分为：\n$$\nI(Q,h;x) = Qh \\sum_{k=0}^{\\infty} c_k^2.\n$$\n贝塞尔（Bessel）不等式指出，对于任何有限截断阶数 $N$，系数平方的部分和为总范数平方提供了一个下界：\n$$\n\\sum_{k=0}^{N} c_k^2 \\le \\|y\\|^2.\n$$\n乘以 $Qh$，我们得到积分 $I$ 的下界：\n$$\nL_N(Q,h;x) = Qh \\sum_{k=0}^{N} c_k^2 \\le I(Q,h;x).\n$$\n这正是问题陈述中给出的贝塞尔–勒让德下界的公式。任务是计算截断阶数 $N=0$、$N=1$ 和 $N=2$ 时的这个界。\n\n为了实现计算，我们将系数 $c_k$ 用在原区间 $[0,h]$ 上的积分表示：\n$$\nc_k = \\int_{0}^{1} x(h\\tau) \\sqrt{2k+1} P_k^{\\text{sh}}(\\tau) d\\tau = \\frac{\\sqrt{2k+1}}{h} \\int_{0}^{h} x(s) P_k^{\\text{sh}}(s/h) ds.\n$$\n将此代入 $L_N$ 的公式，我们得到：\n$$\nL_N(Q,h;x) = Qh \\sum_{k=0}^{N} \\left(\\frac{2k+1}{h^2}\\right) \\left(\\int_{0}^{h} x(s) P_k^{\\text{sh}}(s/h) ds\\right)^2 = \\frac{Q}{h} \\sum_{k=0}^{N} (2k+1) \\left(\\int_{0}^{h} x(s) P_k^{\\text{sh}}(s/h) ds\\right)^2,\n$$\n这与所提供的定义相符。\n\n我们需要前三个移位勒让德多项式，其中 $\\tau = s/h$：\n\\begin{itemize}\n    \\item $P_{0}^{\\text{sh}}(\\tau) = 1$\n    \\item $P_{1}^{\\text{sh}}(\\tau) = 2\\tau - 1 = 2\\frac{s}{h} - 1$\n    \\item $P_{2}^{\\text{sh}}(\\tau) = 6\\tau^2 - 6\\tau + 1 = 6\\left(\\frac{s}{h}\\right)^2 - 6\\frac{s}{h} + 1$\n\\end{itemize}\n\n让我们定义矩 $m_k = \\int_{0}^{h} x(s) P_{k}^{\\text{sh}}(s/h) ds$。这些界可以写为：\n\\begin{enumerate}\n    \\item 詹森界 $L_J = L_0$：\n    $$L_{J} = \\frac{Q}{h} (2(0)+1) m_0^2 = \\frac{Q}{h} \\left(\\int_0^h x(s) ds\\right)^2.$$\n    \\item 基于Wirtinger的界 $L_W = L_1$：\n    $$L_{W} = \\frac{Q}{h} \\left(m_0^2 + 3m_1^2\\right) = L_J + \\frac{3Q}{h} \\left(\\int_0^h \\left(2\\frac{s}{h}-1\\right)x(s) ds\\right)^2.$$\n    \\item 贝塞尔–勒让德界 $L_{BL} = L_2$：\n    $$L_{BL} = \\frac{Q}{h} \\left(m_0^2 + 3m_1^2 + 5m_2^2\\right) = L_W + \\frac{5Q}{h} \\left(\\int_0^h \\left(6\\left(\\frac{s}{h}\\right)^2 - 6\\frac{s}{h} + 1\\right)x(s) ds\\right)^2.$$\n\\end{enumerate}\n从这些表达式中可以清楚地看出，$L_J \\le L_W \\le L_{BL} \\le I$。由比率 $\\rho = L/I$ 表示的这些界的紧度，预期会随着阶数 $N$ 的增加而提高。\n\n对于每个测试用例，我们将使用高精度求积法（具体为 `scipy.integrate.quad` 函数）来数值计算所需的定积分。然后，我们使用这些值来计算 $I$、$L_J$、$L_W$ 和 $L_{BL}$，并最终计算紧度比 $\\rho_J, \\rho_W, \\rho_{BL}$。对于特殊用例4，其中 $x(s)$ 是前三个基多项式的线性组合，我们预期界 $L_{BL}$ 是精确的，从而得到 $\\rho_{BL}=1.0$，因为其展开式不含更高阶的项。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes Jensen, Wirtinger-based, and Bessel-Legendre lower bounds for\n    a quadratic integral term and reports their tightness.\n    \"\"\"\n\n    # Define test cases: (Q, h, function x(s), extra params for x(s))\n    test_cases = [\n        # Case 1\n        (2.0, 1.0, \n         lambda s, h, params: np.sin(2 * np.pi * s) + 0.3 * s - 0.1, \n         None),\n        # Case 2\n        (5.0, 0.05, \n         lambda s, h, params: np.sin(2 * np.pi * s) + 0.3 * s - 0.1, \n         None),\n        # Case 3\n        (1.5, 2.0, \n         lambda s, h, params: np.sin(2 * np.pi * s) + 0.3 * s - 0.1, \n         None),\n        # Case 4\n        (1.0, 3.0, \n         lambda s, h, params: params['a'] + params['b'] * (2 * s / h - 1) + \n                              params['c'] * (6 * (s / h)**2 - 6 * s / h + 1), \n         {'a': 0.7, 'b': -1.2, 'c': 0.9}),\n        # Case 5\n        (0.7, 1.0, \n         lambda s, h, params: np.sin(10 * np.pi * s) + 0.2 * np.cos(3 * np.pi * s) - 0.05, \n         None),\n    ]\n\n    # Shifted Legendre Polynomials as functions of tau = s/h\n    P0_sh = lambda tau: 1.0\n    P1_sh = lambda tau: 2.0 * tau - 1.0\n    P2_sh = lambda tau: 6.0 * tau**2 - 6.0 * tau + 1.0\n\n    results = []\n    \n    for case in test_cases:\n        Q, h, x_func, params = case\n\n        # Integrand for the exact value I\n        integrand_I = lambda s: (x_func(s, h, params))**2\n        \n        # Integrands for the moments m_k\n        integrand_m0 = lambda s: P0_sh(s / h) * x_func(s, h, params)\n        integrand_m1 = lambda s: P1_sh(s / h) * x_func(s, h, params)\n        integrand_m2 = lambda s: P2_sh(s / h) * x_func(s, h, params)\n\n        # Numerical integration using scipy.integrate.quad for high accuracy\n        I_val = Q * integrate.quad(integrand_I, 0, h)[0]\n        m0 = integrate.quad(integrand_m0, 0, h)[0]\n        m1 = integrate.quad(integrand_m1, 0, h)[0]\n        m2 = integrate.quad(integrand_m2, 0, h)[0]\n\n        # Calculate the lower bounds\n        L_J = (Q / h) * (m0**2)\n        L_W = L_J + (Q / h) * 3 * (m1**2)\n        L_BL = L_W + (Q / h) * 5 * (m2**2)\n        \n        # Protective check for I_val being close to zero\n        if np.isclose(I_val, 0):\n            # If I=0, then x(s)=0 almost everywhere. All bounds must be 0.\n            # In this scenario, define tightness as 1.0.\n            rho_J, rho_W, rho_BL = 1.0, 1.0, 1.0\n        else:\n            # Calculate the tightness ratios\n            rho_J = L_J / I_val\n            rho_W = L_W / I_val\n            rho_BL = L_BL / I_val\n\n        results.append((rho_J, rho_W, rho_BL))\n\n    # Format the output string as specified\n    formatted_results = []\n    for r_tuple in results:\n        # Round to 6 decimal places and format\n        formatted_tuple = f\"[{r_tuple[0]:.6f},{r_tuple[1]:.6f},{r_tuple[2]:.6f}]\"\n        formatted_results.append(formatted_tuple)\n\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2747627"}, {"introduction": "现在，我们将前面章节的概念融会贯通，完成一个端到端的应用。你将从一个包含多个积分项的 Lyapunov-Krasovskii 泛函出发，首先推导出线性矩阵不等式（LMI）形式的稳定性条件。然后，你将实现一个计算算法 [@problem_id:2747632]，该算法结合了对可行 LKF 参数的搜索和二分法，以数值方式估算系统保持稳定所能允许的最大延迟 $h_{\\text{max}}$ —— 这是控制工程中一个常见且非常实际的问题。", "problem": "考虑由延迟型泛函微分方程 $\\dot{x}(t) = A x(t) + A_d x(t - h)$ 定义的线性时滞系统，其中 $A \\in \\mathbb{R}^{n \\times n}$，$A_d \\in \\mathbb{R}^{n \\times n}$，且 $h \\ge 0$ 是一个常数时滞。从李雅普诺夫-克拉索夫斯基泛函 (LKF) 的基本定义和基础微积分出发，使用形式为 $V(x_t) = x(t)^{\\top} P x(t) + \\int_{t-h}^{t} x(s)^{\\top} Q x(s) \\, ds + \\int_{t-h}^{t} \\int_{s}^{t} \\dot{x}(\\tau)^{\\top} R \\dot{x}(\\tau) \\, d\\tau \\, ds$ 的二次李雅普诺夫-克拉索夫斯基泛函，其中 $P \\in \\mathbb{S}_{++}^{n}$，$Q \\in \\mathbb{S}_{+}^{n}$ 和 $R \\in \\mathbb{S}_{+}^{n}$ 是决策变量。结合乘法法则、微积分基本定理以及应用于 $\\int_{t-h}^{t} \\dot{x}(\\tau)^{\\top} R \\dot{x}(\\tau) \\, d\\tau$ 的詹森不等式，推导出一个关于 $P$、$Q$、$R$ 和 $h$ 的时滞相关线性矩阵不等式 (LMI) 条件，该条件保证对于某个 $\\epsilon > 0$，有 $\\dot{V}(x_t) \\le - \\epsilon \\| x(t) \\|^2$ 成立，从而保证零解的渐近稳定性。\n\n您必须接着实现一个数值程序，使用以下约束来估计确保稳定性的最大允许常数时滞 $h_{\\max}$：\n- 限制于 $n = 2$ 的特殊情况，其中 $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -3 \\end{bmatrix}$ 且 $A_d$ 按测试套件中的规定。\n- 将决策矩阵限制为单位矩阵的标量倍：$P = p I_2$，$Q = q I_2$，$R = r I_2$，其中 $p > 0$，$q \\ge 0$，$r > 0$。\n- 对于固定的 $h$，必须通过检验相关的对称分块矩阵是否负定来检查关于变量 $p$、$q$、$r$ 的LMI。如果在有限搜索集中存在使该条件成立的 $p$、$q$、$r$，则证实其可行性。\n- 对于给定的有限 $H_{\\text{search}}$，通过在 $h \\in [0, H_{\\text{search}}]$ 上进行二分法来估计 $h_{\\max}$，并使用上述可行性检查作为检验函数。如果系统对于所有 $h \\in [0, H_{\\text{search}}]$ 都可行，则报告该测试用例的 $h_{\\max} = H_{\\text{search}}$。\n\n您必须按如下方式实现数值搜索：\n- 对于每个给定的 $h$ 进行可行性检查时，在有限网格 $(p, q, r) \\in \\mathcal{G}_p \\times \\mathcal{G}_q \\times \\mathcal{G}_r$ 上进行搜索，其中 $\\mathcal{G}_p = \\{ 0.1, 0.5, 1, 2, 5, 10 \\}$，$\\mathcal{G}_q = \\{ 0, 0.5, 1, 2, 5, 10 \\}$，$\\mathcal{G}_r = \\{ 0.1, 0.5, 1, 2, 5, 10 \\}$。如果此网格中的任何三元组 $(p, q, r)$ 产生一个负定的LMI矩阵，则声明为可行。\n- 使用至少 $25$ 次迭代的二分法来估计 $h_{\\max}$，起始于一个小的严格正下界和一个有限上界 $H_{\\text{search}} = 5$。如果可行性检查在 $h = H_{\\text{search}}$ 时成功，则返回 $h_{\\max} = H_{\\text{search}}$。如果即使在极小的正 $h$ 值下可行性也失败，则返回 $h_{\\max} = 0$。\n\n测试套件：\n- 情况 1 (基准): $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -3 \\end{bmatrix}$, $A_d = \\begin{bmatrix} 0 & 0 \\\\ 0 & -1 \\end{bmatrix}$。\n- 情况 2 (无时滞效应): $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -3 \\end{bmatrix}$, $A_d = \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\end{bmatrix}$。\n- 情况 3 (中等时滞效应): $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -3 \\end{bmatrix}$, $A_d = 2 \\cdot \\begin{bmatrix} 0 & 0 \\\\ 0 & -1 \\end{bmatrix}$。\n- 情况 4 (强时滞效应): $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -3 \\end{bmatrix}$, $A_d = 4 \\cdot \\begin{bmatrix} 0 & 0 \\\\ 0 & -1 \\end{bmatrix}$。\n\n输出要求：\n- 报告每个测试用例的估计 $h_{\\max}$ 值，单位为秒，四舍五入到四位小数。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[h1,h2,h3,h4]\"），其中每个 $h_i$ 对应于上面列出的顺序中的一个测试用例。", "solution": "我们考虑具有常数时滞 $h \\ge 0$ 的线性时滞系统 $\\dot{x}(t) = A x(t) + A_d x(t - h)$。我们寻求使用李雅普诺夫-克拉索夫斯基泛函 (LKF) 得到一个时滞相关的稳定性条件。我们从核心原理开始：导数的定义、乘法法则、微积分基本定理和詹森不等式。\n\n定义二次 LKF\n$$\nV(x_t) = V_1 + V_2 + V_3,\n$$\n其中\n$$\nV_1 = x(t)^{\\top} P x(t), \\quad V_2 = \\int_{t-h}^{t} x(s)^{\\top} Q x(s) \\, ds, \\quad V_3 = \\int_{t-h}^{t} \\int_{s}^{t} \\dot{x}(\\tau)^{\\top} R \\dot{x}(\\tau) \\, d\\tau \\, ds,\n$$\n其中 $P \\in \\mathbb{S}_{++}^{n}$，$Q \\in \\mathbb{S}_{+}^{n}$ 和 $R \\in \\mathbb{S}_{+}^{n}$。我们使用微积分基本定理和标准微分法则逐项计算导数。\n\n1) 对于 $V_1$，使用乘法法则和 $P$ 的对称性，\n$$\n\\dot{V}_1 = \\dot{x}(t)^{\\top} P x(t) + x(t)^{\\top} P \\dot{x}(t) = 2 x(t)^{\\top} P \\dot{x}(t) = x(t)^{\\top} (A^{\\top} P + P A) x(t) + 2 x(t)^{\\top} P A_d x(t - h).\n$$\n\n2) 对于 $V_2$，根据微积分基本定理，\n$$\n\\dot{V}_2 = x(t)^{\\top} Q x(t) - x(t - h)^{\\top} Q x(t - h).\n$$\n\n3) 对于 $V_3$，观察到\n$$\nV_3 = \\int_{t-h}^{t} (t - s) \\dot{x}(s)^{\\top} R \\dot{x}(s) \\, ds.\n$$\n微分得到\n$$\n\\dot{V}_3 = h \\, \\dot{x}(t)^{\\top} R \\dot{x}(t) - \\int_{t-h}^{t} \\dot{x}(s)^{\\top} R \\dot{x}(s) \\, ds.\n$$\n将詹森不等式应用于长度为 $h$ 的区间上关于 $\\dot{x}$ 的凸二次型，得到\n$$\n\\int_{t-h}^{t} \\dot{x}(s)^{\\top} R \\dot{x}(s) \\, ds \\ge \\frac{1}{h} \\left( \\int_{t-h}^{t} \\dot{x}(s) \\, ds \\right)^{\\top} R \\left( \\int_{t-h}^{t} \\dot{x}(s) \\, ds \\right).\n$$\n注意到 $\\int_{t-h}^{t} \\dot{x}(s) \\, ds = x(t) - x(t - h)$，我们有界\n$$\n\\dot{V}_3 \\le h \\, \\dot{x}(t)^{\\top} R \\dot{x}(t) - \\frac{1}{h} \\left( x(t) - x(t - h) \\right)^{\\top} R \\left( x(t) - x(t - h) \\right).\n$$\n\n综合 $\\dot{V}_1$、$\\dot{V}_2$ 和 $\\dot{V}_3$ 的界，并代入 $\\dot{x}(t) = A x(t) + A_d x(t-h)$，我们可以将总导数的上界表示为关于堆叠向量 $\\xi = \\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}$ 的二次型：\n$$\n\\dot{V}(x_t) \\le \\xi^{\\top} \\mathcal{M}(h) \\, \\xi,\n$$\n其分块矩阵为\n$$\n\\mathcal{M}(h) = \\begin{bmatrix}\nM_{11} & M_{12} \\\\\nM_{12}^{\\top} & M_{22}\n\\end{bmatrix},\n$$\n其中\n$$\n\\begin{aligned}\nM_{11} &= A^{\\top} P + P A + Q + h \\, A^{\\top} R A - \\frac{1}{h} R, \\\\\nM_{12} &= P A_d + h \\, A^{\\top} R A_d + \\frac{1}{h} R, \\\\\nM_{22} &= - Q + h \\, A_d^{\\top} R A_d - \\frac{1}{h} R.\n\\end{aligned}\n$$\n渐近稳定性的一个充分条件是，对于某个 $P \\in \\mathbb{S}_{++}^{n}$、$Q \\in \\mathbb{S}_{+}^{n}$ 和 $R \\in \\mathbb{S}_{+}^{n}$，有 $\\mathcal{M}(h) \\prec 0$，因为根据 S-过程和标准的紧致性论证，这意味着对于某个 $\\epsilon > 0$，有 $\\dot{V}(x_t) \\le -\\epsilon \\| x(t) \\|^2$。对于固定的 $h$，条件 $\\mathcal{M}(h) \\prec 0$ 是一个关于决策矩阵 $P$、$Q$ 和 $R$ 的线性矩阵不等式 (LMI)。\n\n为了使可行性检查在计算上简单，并且无需专用的半定规划求解器即可完全实现，我们在 $n = 2$ 的情况下限制为单位矩阵的标量倍，即 $P = p I_2$、$Q = q I_2$、$R = r I_2$，其中 $p > 0$，$q \\ge 0$，$r > 0$。在此限制下，$M_{11}$、$M_{12}$ 和 $M_{22}$ 成为 $p$、$q$、$r$ 和 $h$ 的显式函数，而检查 $\\mathcal{M}(h) \\prec 0$ 则简化为验证 $4 \\times 4$ 对称矩阵 $\\mathcal{M}(h)$ 的所有特征值都是严格负的。\n\n算法设计：\n- 对于每个固定的 $h$，在有限网格 $(p, q, r) \\in \\mathcal{G}_p \\times \\mathcal{G}_q \\times \\mathcal{G}_r$ 上执行有限网格搜索，其中 $\\mathcal{G}_p = \\{ 0.1, 0.5, 1, 2, 5, 10 \\}$，$\\mathcal{G}_q = \\{ 0, 0.5, 1, 2, 5, 10 \\}$，$\\mathcal{G}_r = \\{ 0.1, 0.5, 1, 2, 5, 10 \\}$。对于每个三元组，组装 $\\mathcal{M}(h)$ 并通过其特征值测试负定性。如果任何三元组产生负定矩阵，则声明在该 $h$ 处可行。\n- 在 $h \\in [h_{\\text{low}}, H_{\\text{search}}]$ 上使用二分法，其中 $h_{\\text{low}}$ 是一个小的严格正数（例如 $10^{-6}$），以找到可行时滞的上确界。通过在 $h = H_{\\text{search}} = 5$ 处检查可行性来进行初始化。如果可行，报告 $h_{\\max} = H_{\\text{search}}$。否则，确保在小的 $h_{\\text{low}}$ 处可行；如果即便在那里也不可行，则报告 $h_{\\max} = 0$。如果在 $h_{\\text{low}}$ 处可行但在 $H_{\\text{search}}$ 处不可行，则执行至少 $25$ 次二分法迭代，以遇到的最大可行 $h$ 从下方逼近 $h_{\\max}$。\n- 测试套件包括四个情况，它们具有相同的 $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -3 \\end{bmatrix}$ 和如上所列的不同 $A_d$。这些情况涵盖了一个基准、一个无时滞耦合的边界场景，以及递增的时滞反馈强度。\n\n数值输出：\n- 对于每个测试用例，返回以秒为单位的估计 $h_{\\max}$，四舍五入到四位小数。\n- 以 \"[h1,h2,h3,h4]\" 的格式单行输出结果。\n\n由于对 $P$、$Q$ 和 $R$ 的对角标量限制以及詹森不等式松弛，该方法是保守的；因此，估计的 $h_{\\max}$ 是真实最大允许时滞的一个下界。尽管如此，该方法是系统可计算的，并且基于推导出的 LMI 条件，满足了使用李雅普诺夫-克拉索夫斯基泛函和第一性原理的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_M(A, Ad, h, p, q, r):\n    \"\"\"\n    Assemble the 4x4 symmetric LMI matrix M(h) using:\n    P = p * I, Q = q * I, R = r * I for 2x2 A, Ad.\n    \"\"\"\n    I = np.eye(2)\n    P = p * I\n    Q = q * I\n    R = r * I\n\n    AT = A.T\n    AdT = Ad.T\n\n    # Blocks according to the derived expressions\n    M11 = AT @ P + P @ A + Q + h * (AT @ R @ A) - (1.0 / h) * R\n    M12 = P @ Ad + h * (AT @ R @ Ad) + (1.0 / h) * R\n    M21 = M12.T\n    M22 = -Q + h * (AdT @ R @ Ad) - (1.0 / h) * R\n\n    # Form the full 4x4 block matrix\n    upper = np.hstack((M11, M12))\n    lower = np.hstack((M21, M22))\n    M = np.vstack((upper, lower))\n    # Ensure symmetry numerically\n    M = 0.5 * (M + M.T)\n    return M\n\ndef is_negative_definite(M, tol=-1e-9):\n    \"\"\"\n    Check if M is strictly negative definite by verifying eigenvalues < tol.\n    \"\"\"\n    # Use symmetric eigenvalue solver\n    evals = np.linalg.eigvalsh(M)\n    return np.max(evals) < tol\n\ndef feasible_for_h(A, Ad, h, grid_p, grid_q, grid_r):\n    \"\"\"\n    Feasibility oracle: returns True if there exist p, q, r in the provided grids\n    such that the LMI matrix M(h) is negative definite.\n    \"\"\"\n    for p in grid_p:\n        for q in grid_q:\n            for r in grid_r:\n                # p > 0, q >= 0, r > 0 ensured by grids\n                M = assemble_M(A, Ad, h, p, q, r)\n                if is_negative_definite(M):\n                    return True\n    return False\n\ndef estimate_hmax(A, Ad, H_search=5.0, max_bisect_iter=30):\n    \"\"\"\n    Estimate h_max by bisection using the feasibility oracle.\n    If feasible at H_search, return H_search.\n    If infeasible even at tiny h, return 0.0.\n    Else perform bisection to approximate the boundary from below.\n    \"\"\"\n    grid_p = [0.1, 0.5, 1.0, 2.0, 5.0, 10.0]\n    grid_q = [0.0, 0.5, 1.0, 2.0, 5.0, 10.0]\n    grid_r = [0.1, 0.5, 1.0, 2.0, 5.0, 10.0]\n\n    # Check at the upper bound\n    if feasible_for_h(A, Ad, H_search, grid_p, grid_q, grid_r):\n        return H_search\n\n    # Find a small feasible lower bound\n    small_h_candidates = [1e-3, 1e-4, 1e-5, 1e-6]\n    h_low = None\n    for h0 in small_h_candidates:\n        if feasible_for_h(A, Ad, h0, grid_p, grid_q, grid_r):\n            h_low = h0\n            break\n    if h_low is None:\n        return 0.0\n\n    h_high = H_search\n    # Bisection\n    for _ in range(max_bisect_iter):\n        h_mid = 0.5 * (h_low + h_high)\n        if feasible_for_h(A, Ad, h_mid, grid_p, grid_q, grid_r):\n            h_low = h_mid\n        else:\n            h_high = h_mid\n    return h_low\n\ndef solve():\n    # Define the test cases from the problem statement.\n    A = np.array([[0.0, 1.0],\n                  [-2.0, -3.0]])\n\n    Ad_base = np.array([[0.0, 0.0],\n                        [0.0, -1.0]])\n\n    test_cases = [\n        (A, Ad_base.copy()),                      # Case 1\n        (A, np.zeros_like(Ad_base)),             # Case 2\n        (A, 2.0 * Ad_base.copy()),               # Case 3\n        (A, 4.0 * Ad_base.copy()),               # Case 4\n    ]\n\n    H_search = 5.0\n    results = []\n    for A_case, Ad_case in test_cases:\n        h_est = estimate_hmax(A_case, Ad_case, H_search=H_search, max_bisect_iter=30)\n        # Round to four decimals\n        h_est_rounded = round(h_est + 0.0, 4)\n        results.append(h_est_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2747632"}]}