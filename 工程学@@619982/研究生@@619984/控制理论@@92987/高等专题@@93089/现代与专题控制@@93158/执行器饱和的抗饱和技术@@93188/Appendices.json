{"hands_on_practices": [{"introduction": "在控制器中加入反饱和（anti-windup）回路只是第一步，其效果在很大程度上取决于相关参数的整定。本练习将指导你超越简单的试错法，通过一种基于原理的方法——回路成形（loop shaping）——来推导并实现“反算（back-calculation）”抗饱和增益 $k_{\\mathrm{aw}}$ 的整定规则。通过这个实践，你将学会如何根据期望的脱饱和动态（desaturation dynamics）来系统地选择增益，并通过数值仿真直观地观察不同增益对系统从饱和状态恢复瞬态性能的影响。[@problem_id:2690044]", "problem": "给定一个单输入单输出闭环系统，由一个线性时不变被控对象、一个比例-积分控制器、一个饱和执行器和一个反馈校正抗饱和机制组成。被控对象由传递函数 $P(s) = \\dfrac{1}{s + 1}$ 描述，控制器由传递函数 $K(s) = k_p + \\dfrac{k_i}{s}$ 描述。执行器将控制器输出 $u(t)$ 饱和为信号 $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$，其对称限幅为 $\\pm u_{\\max}$。反馈校正抗饱和机制通过将信号 $v(t) - u(t)$ 乘以一个标量增益 $k_{\\mathrm{aw}}$ 来修正控制器的内部积分器状态，即控制器积分器的动态为\n$$\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right),$$\n其中 $u(t) = k_p e(t) + k_i z(t)$ 且 $e(t) = r(t) - y(t)$，$y(t)$ 是被控对象输出，$r(t)$ 是参考信号。\n\n从线性时不变系统、拉普拉斯变换和闭环互联的核心定义出发，并仅利用比例-积分控制器和饱和执行器的特性，通过对从外源信号 $w(t) = u(t) - v(t)$到 $v(t)$ 的环路传递进行整形，推导一种基于原理的抗饱和增益 $k_{\\mathrm{aw}}$ 整定方法，以使有效脱饱和动态在期望的角带宽 $\\omega_{\\mathrm{aw}}$（以弧度/秒为单位）处呈现一个位于实轴上的单极点。您的推导必须从在执行器处注入外源输入 $w(t)$ 的闭环系统的状态空间或传递函数表示开始，必须与上面给出的被控对象和控制器内部一致，并论证 $k_{\\mathrm{aw}}$ 的选择如何决定脱饱和带宽。\n\n在推导出整定规则后，通过一个数值实验来实现它，以展示在一次大的阶跃指令后，抗饱和带宽如何影响从执行器饱和状态下的暂态恢复。在数值实验中使用以下固定参数：\n- 被控对象 $P(s) = \\dfrac{1}{s + 1}$。\n- 控制器增益 $k_p = 4$ 和 $k_i = 4$。\n- 饱和限幅 $u_{\\max} = 0.5$。\n- 阶跃参考信号 $r(t) = r_0$，其中对于所有 $t \\ge 0$，$r_0 = 2$。\n- 被控对象状态 $x_p$ 的初始条件为 $x_p(0) = 0$，控制器积分器状态 $z$ 的初始条件为 $z(0) = 0$。\n\n将未饱和闭环带宽 $\\omega_{\\mathrm{cl}}$ 定义为由 $P(s)$ 和 $K(s)$ 组成、不含执行器饱和和抗饱和反馈（即采用标准比例-积分控制器）的线性闭环系统的最慢（最靠近虚轴）极点实部的绝对值。使用您推导的整定方法，选择 $k_{\\mathrm{aw}}$ 以实现由 $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$ 给出的三种不同的抗饱和带宽 $\\omega_{\\mathrm{aw}}$，其中因子 $f$ 在下面的测试套件中指定。\n\n仿真带有饱和器和抗饱和反馈的非线性闭环系统，并计算脱饱和恢复时间 $t_{\\mathrm{rec}}$，其定义为饱和偏差 $|w(t)| = |u(t) - v(t)|$ 超过一个小阈值 $\\varepsilon$ 的最后一个时刻。使用 $\\varepsilon = 1\\times 10^{-3}$，并仿真至一个足以捕捉恢复过程的有限时间域 $T_{\\max}$；您必须使用 $T_{\\max} = 15$ 秒。将 $t_{\\mathrm{rec}}$ 以秒为单位表示，四舍五入到三位小数。\n\n您的程序必须实现以下包含三种抗饱和带宽因子的测试套件：\n- 情况 1：$f = 0.5$。\n- 情况 2：$f = 2$。\n- 情况 3：$f = 10$。\n\n对于每种情况，计算 $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$，根据您推导的环路整形规则整定 $k_{\\mathrm{aw}}$，运行仿真，并返回相应的 $t_{\\mathrm{rec}}$。您的程序应生成单行输出，包含一个由逗号分隔并用方括号括起来的结果列表（例如，“[1.234,5.678,9.000]”），其中每个条目是对应测试用例的 $t_{\\mathrm{rec}}$（以秒为单位，四舍五入到三位小数）。不应打印任何额外文本。", "solution": "我们从一个单输入单输出线性被控对象与一个比例-积分控制器和一个饱和执行器的标准互联开始。被控对象为 $P(s) = \\dfrac{1}{s + 1}$。控制器为 $K(s) = k_p + \\dfrac{k_i}{s}$，通过内部积分器状态 $z(t)$ 实现，在没有抗饱和的情况下，其方程为 $u(t) = k_p e(t) + k_i z(t)$ 和 $\\dot{z}(t) = e(t)$。饱和器将饱和前输入 $u(t)$ 映射为 $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$，被控对象的状态空间实现为 $\\dot{x}_p(t) = - x_p(t) + v(t)$，输出为 $y(t) = x_p(t)$。闭环误差为 $e(t) = r(t) - y(t)$。\n\n为分析执行器饱和，我们引入外源偏差信号 $w(t) = u(t) - v(t)$，因此 $v(t) = u(t) - w(t)$。反馈校正抗饱和机制将积分器动态修正为\n$$\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right) = e(t) - k_{\\mathrm{aw}} w(t).$$\n这种结构使控制器内部状态跟踪饱和的执行器输出，从而抑制积分饱和。\n\n我们通过考察控制脱饱和动态的映射来推导环路整形规则，该动态由饱和前控制器信号 $u(t)$ 对饱和执行器输出 $v(t)$ 的跟踪过程所体现。考虑通过设置 $e(t) = 0$ 来隔离跟踪环路的情形，这代表当误差反馈与反馈校正项相比可以忽略时，饱和对控制器的局部影响。在 $e(t) = 0$ 条件下，我们有 $u(t) = k_i z(t)$ 和\n$$\\dot{z}(t) = - k_{\\mathrm{aw}} w(t) = k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right).$$\n由此可得\n$$\\dot{u}(t) = k_i \\dot{z}(t) = k_i k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right).$$\n在零初始条件下进行拉普拉斯变换，得到\n$$s U(s) = k_i k_{\\mathrm{aw}} \\left(V(s) - U(s)\\right),$$\n因此从 $V(s)$ 到 $U(s)$ 的传递函数为\n$$\\frac{U(s)}{V(s)} = \\frac{k_i k_{\\mathrm{aw}}}{s + k_i k_{\\mathrm{aw}}}.$$\n因此，$u(t)$ 对 $v(t)$ 的跟踪动态是一个稳定的一阶系统动态，其单极点位于 $s = - k_i k_{\\mathrm{aw}}$，带宽等于角频率 $\\omega = k_i k_{\\mathrm{aw}}$。由于 $w(t) = u(t) - v(t)$，偏差 $w(t)$ 以相同的时间常数衰减。在脱饱和期间，当 $e(t)$ 相对于反馈校正作用很小时，这一基本关系与被控对象的具体细节无关。\n\n这启发了一条环路整形规则：通过设置\n$$k_{\\mathrm{aw}} = \\frac{\\omega_{\\mathrm{aw}}}{k_i}$$\n来选择 $k_{\\mathrm{aw}}$，以实现期望的脱饱和带宽 $\\omega_{\\mathrm{aw}}$。该规则确保与脱饱和相关的闭环映射在 $s = - \\omega_{\\mathrm{aw}}$ 处有一个单实极点，从而通过以指定带宽跟踪 $u(t)$ 到 $v(t)$ 的过程，间接整形了从 $w(t)$ 到 $v(t)$ 的传递。这对包含 $P(s)$ 和 $K(s)$ 的完整闭环系统的影响是，在饱和期间，控制器内部状态被牵引以时间常数 $1 / \\omega_{\\mathrm{aw}}$ 来跟踪饱和的执行器输出，从而减少积分饱和并在执行器脱离饱和后改善恢复过程。\n\n接下来，我们必须定义在没有饱和和抗饱和的情况下，基准闭环带宽 $\\omega_{\\mathrm{cl}}$。对于 $P(s) = \\dfrac{1}{s + 1}$ 和 $K(s) = k_p + \\dfrac{k_i}{s}$，单位反馈下的线性闭环系统的特征多项式可由 $1 + K(s) P(s) = 0$ 得到，即\n$$1 + \\left(k_p + \\frac{k_i}{s}\\right) \\frac{1}{s + 1} = 0.$$\n两边乘以 $s (s + 1)$ 得到\n$$s (s + 1) + k_p s + k_i = 0,$$\n简化为\n$$s^2 + (1 + k_p) s + k_i = 0.$$\n闭环极点是该二次方程的根。最慢的极点（最靠近虚轴的那个）决定了主导衰减率，我们将未饱和闭环带宽定义为\n$$\\omega_{\\mathrm{cl}} = \\left| \\operatorname{Re}\\left(s_{\\mathrm{dom}}\\right) \\right|,$$\n其中 $s_{\\mathrm{dom}}$ 是此例中两个不同实极点中具有最大实部（最接近零）的极点。对于数值参数 $k_p = 4$ 和 $k_i = 4$，特征多项式为 $s^2 + 5 s + 4$，其根为 $s = -1$ 和 $s = -4$，因此主导极点是 $s_{\\mathrm{dom}} = -1$，且 $\\omega_{\\mathrm{cl}} = 1$。\n\n利用这个基准带宽，我们通过设置\n$$\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}, \\quad k_{\\mathrm{aw}} = \\frac{\\omega_{\\mathrm{aw}}}{k_i} = \\frac{f \\, \\omega_{\\mathrm{cl}}}{k_i}$$\n来实现环路整形规则。这提供了从期望的脱饱和带宽因子 $f$ 到抗饱和增益 $k_{\\mathrm{aw}}$ 的系统性映射。\n\n为展示抗饱和带宽对暂态恢复的影响，我们仿真了带有饱和器和反馈校正抗饱和的非线性闭环系统，使用了被控对象状态空间 $\\dot{x}_p(t) = - x_p(t) + v(t)$ 和 $y(t) = x_p(t)$，控制器 $u(t) = k_p e(t) + k_i z(t)$ 及 $\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right)$，误差 $e(t) = r(t) - y(t)$，阶跃参考 $r(t) = r_0$（其中 $r_0 = 2$），以及饱和 $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$（其中 $u_{\\max} = 0.5$）。初始条件为 $x_p(0) = 0$ 和 $z(0) = 0$。\n\n我们将脱饱和恢复时间 $t_{\\mathrm{rec}}$ 定义为饱和偏差 $|w(t)| = |u(t) - v(t)|$ 超过阈值 $\\varepsilon = 10^{-3}$ 的最后一个时刻。即，$t_{\\mathrm{rec}}$ 是仿真时间域 $[0, T_{\\max}]$ 内满足 $|w(t)| > \\varepsilon$ 的时间 $t$ 的上确界。我们仿真到 $T_{\\max} = 15$ 秒，这个时间足以捕捉在给定 $k_{\\mathrm{aw}}$ 范围内的恢复过程。\n\n该测试套件使用三个因子 $f$：\n- 情况 1：$f = 0.5$，所以 $\\omega_{\\mathrm{aw}} = 0.5 \\, \\omega_{\\mathrm{cl}}$ 且 $k_{\\mathrm{aw}} = \\dfrac{0.5 \\, \\omega_{\\mathrm{cl}}}{k_i}$，\n- 情况 2：$f = 2$，所以 $\\omega_{\\mathrm{aw}} = 2 \\, \\omega_{\\mathrm{cl}}$ 且 $k_{\\mathrm{aw}} = \\dfrac{2 \\, \\omega_{\\mathrm{cl}}}{k_i}$，\n- 情况 3：$f = 10$，所以 $\\omega_{\\mathrm{aw}} = 10 \\, \\omega_{\\mathrm{cl}}$ 且 $k_{\\mathrm{aw}} = \\dfrac{10 \\, \\omega_{\\mathrm{cl}}}{k_i}$。\n\n我们预期，更大的 $\\omega_{\\mathrm{aw}}$（即更大的 $k_{\\mathrm{aw}}$）会产生更快的脱饱和，因此 $t_{\\mathrm{rec}}$ 更小，但过大的 $k_{\\mathrm{aw}}$ 可能会增加暂态峰值或在饱和极限附近引起抖振。该数值实验通过 $t_{\\mathrm{rec}}$ 来量化恢复过程。\n\n程序的算法步骤：\n- 通过求解 $s^2 + (1 + k_p) s + k_i = 0$ 来计算未饱和闭环极点，并将 $\\omega_{\\mathrm{cl}}$ 设为主导极点实部的绝对值。\n- 对于测试套件中的每个因子 $f$，设置 $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$ 和 $k_{\\mathrm{aw}} = \\omega_{\\mathrm{aw}} / k_i$。\n- 在 $[0, T_{\\max}]$ 上仿真带有饱和和反馈校正抗饱和的闭环微分方程，并计算 $w(t) = u(t) - v(t)$。\n- 将 $t_{\\mathrm{rec}}$ 设为 $|w(t)| > \\varepsilon$ 的最后一个时刻（如果从未发生饱和，则为零），并四舍五入到三位小数。\n- 将列表 $[t_{\\mathrm{rec}}^{(1)}, t_{\\mathrm{rec}}^{(2)}, t_{\\mathrm{rec}}^{(3)}]$ 作为单行打印，其中上标对应三种情况。\n\n此过程基于比例-积分控制器和饱和执行器的基本动态，并利用脱饱和跟踪动态的环路整形来选择抗饱和增益。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.polynomial.polynomial import Polynomial\n\ndef closed_loop_dominant_bandwidth(kp: float, ki: float) -> float:\n    \"\"\"\n    Compute the unsaturated closed-loop dominant bandwidth as the absolute value\n    of the real part of the slowest pole of s^2 + (1+kp)s + ki = 0.\n    For kp=4, ki=4, poles are -1 and -4, so bandwidth is 1 rad/s.\n    \"\"\"\n    # Characteristic polynomial coefficients: s^2 + (1+kp)s + ki\n    a2 = 1.0\n    a1 = 1.0 + kp\n    a0 = ki\n    roots = np.roots([a2, a1, a0])\n    # Dominant pole: real part closest to zero (largest real part)\n    # For real coefficients, roots should be real here given values.\n    real_parts = np.real(roots)\n    dominant = real_parts[np.argmax(real_parts)]\n    return abs(dominant)\n\ndef simulate_aw_response(kp: float, ki: float, umax: float, r0: float,\n                         k_aw: float, t_final: float = 15.0,\n                         eps: float = 1e-3) -> float:\n    \"\"\"\n    Simulate the nonlinear closed loop with saturation and back-calculation AW.\n    Plant: xdot = -x + v, y = x.\n    Controller: u = kp*e + ki*z, zdot = e + k_aw*(v - u), e = r - y.\n    Saturation: v = sat(u, umax).\n    Return desaturation recovery time t_rec = last time where |u - v| > eps,\n    or 0.0 if saturation discrepancy never exceeds eps.\n    \"\"\"\n    def dynamics(t, state):\n        x, z = state\n        y = x\n        e = r0 - y\n        u = kp * e + ki * z\n        v = np.clip(u, -umax, umax)\n        zdot = e + k_aw * (v - u)\n        xdot = -x + v\n        return [xdot, zdot]\n\n    # Time grid for evaluation\n    t_eval = np.linspace(0.0, t_final, 6001)  # 2.5 ms step approx\n    sol = solve_ivp(dynamics, (0.0, t_final), [0.0, 0.0], t_eval=t_eval, rtol=1e-8, atol=1e-10, method='RK45')\n    x = sol.y[0, :]\n    z = sol.y[1, :]\n    y = x\n    e = r0 - y\n    u = kp * e + ki * z\n    v = np.clip(u, -umax, umax)\n    w = u - v\n    mask = np.abs(w) > eps\n    if not np.any(mask):\n        return 0.0\n    # Last time index where saturation discrepancy is above eps\n    last_idx = np.where(mask)[0][-1]\n    t_rec = sol.t[last_idx]\n    return float(t_rec)\n\ndef solve():\n    # Fixed parameters\n    kp = 4.0\n    ki = 4.0\n    umax = 0.5\n    r0 = 2.0\n    t_final = 15.0\n    eps = 1e-3\n\n    # Compute unsaturated closed-loop dominant bandwidth\n    omega_cl = closed_loop_dominant_bandwidth(kp, ki)\n\n    # Test cases: factors f for omega_aw = f * omega_cl\n    test_cases = [0.5, 2.0, 10.0]\n\n    results = []\n    for f in test_cases:\n        omega_aw = f * omega_cl\n        k_aw = omega_aw / ki  # loop-shaping rule derived from u_dot = ki*k_aw (v - u)\n        t_rec = simulate_aw_response(kp, ki, umax, r0, k_aw, t_final=t_final, eps=eps)\n        results.append(round(t_rec, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2690044"}, {"introduction": "在学会如何为提升性能而整定抗饱和增益之后，一个自然而关键的问题是：我们能将增益设得多大而不致使系统失稳？本练习将引导你运用输入-输出稳定性理论（如圆判据），对一个同时包含幅值和速率限制的更真实执行器模型进行严格的稳定性分析。通过这个推导，你将得出一个保证闭环系统不会因抗饱和补偿器与执行器非线性相互作用而产生自激振荡的充分条件，从而为抗饱和增益 $k_{aw}$ 的选择提供一个明确的稳定边界。[@problem_id:2690042]", "problem": "考虑一个单输入单输出反馈系统，该系统包含一个严格真有理对象、一个比例积分控制器、一个同时具有幅值和压摆率限制的饱和执行器，以及一个标准的反计算抗饱和环路。对象的传递函数为 $P(s) = \\frac{1}{s+1}$，控制器为 $C(s) = k_p + \\frac{k_i}{s}$，其增益固定为 $k_p = 1$ 和 $k_i = 1$，参考信号为分段常数。记 $y$ 为对象输出，$r$ 为参考信号，$e = r - y$ 为跟踪误差，$x_i$ 为控制器积分器状态，$u_c = k_p e + x_i$ 为饱和前控制信号，$v$ 为执行器输出。反计算抗饱和方法将积分器动态修正为 $\\dot{x}_i = k_i e - k_{aw} (u_c - v)$，其中 $k_{aw} > 0$ 是抗饱和增益。执行器强制施加硬性幅值限制 $|v(t)| \\leq V_{\\max}$ 和硬性压摆率限制 $|\\dot{v}(t)| \\leq R_{\\max}$，其中 $V_{\\max} > 0$ 且 $R_{\\max} > 0$，并可能在幅值限制激活和压摆率限制激活两种模式之间切换。\n\n仅使用关于能量信号、单调非线性的扇区和斜率界、以及反馈互联的输入输出稳定性的基本定义和经过充分检验的事实，推导出一个关于 $k_{aw}$ 的充分条件，该条件保证当执行器在速率限制和幅值饱和之间切换时，闭环系统不会因抗饱和补偿器与执行器之间的相互作用而产生自激振荡。推导过程必须从第一性原理出发，通过 (i) 使用一个度量执行器所致偏差的辅助信号，对线性时不变部分与执行器非线性之间的抗饱和互联进行建模，以及 (ii) 建立一个在执行器非线性于其两种限制模式之间任意切换时都成立的一致增量增益界。\n\n在这些假设下，并针对给定的 $P(s)$ 和 $C(s)$，确定使您的充分条件成立的抗饱和增益 $k_{aw}$ 的精确上确界值 $k_{aw}^{\\star}$。请将最终答案表示为一个精确的实数（无单位，不四舍五入）。", "solution": "问题要求为一个包含比例积分(PI)控制器、严格真有理对象以及同时受幅值和压摆率饱和限制的执行器的反馈系统，推导其稳定性的一个充分条件。该系统包含一个反计算抗饱和方案。这里的稳定性指不存在自激振荡，这可以通过考察零外部输入下闭环系统的稳定性来分析。\n\n我们的策略是将系统重构为一个线性时不变(LTI)系统和一个非线性算子的反馈互联形式。然后，我们可以应用输入输出稳定性判据，例如圆判据，该判据利用了问题陈述所提示的非线性的扇区界性质。\n\n首先，我们根据问题陈述定义系统方程：\n对象：$P(s) = \\frac{1}{s+1}$。\n控制器：$C(s) = k_p + \\frac{k_i}{s}$，其中 $k_p=1$ 且 $k_i=1$。\n跟踪误差：$e = r - y$。\n饱和前控制信号：$u_c = k_p e + x_i = e + x_i$。\n带抗饱和的积分器状态动态：$\\dot{x}_i = k_i e - k_{aw}(u_c - v) = e - k_{aw}(u_c - v)$。\n执行器输出：$v = \\Psi(u_c)$，其中 $\\Psi$ 表示包含幅值（$|v(t)| \\leq V_{\\max}$）和压摆率（$|\\dot{v}(t)| \\leq R_{\\max}$）限制的非线性执行器动态。\n\n为了分析抗饱和环路的稳定性，我们需要分离线性动态与执行器非线性之间的相互作用。一种标准方法是将系统建模为一个围绕“执行器误差信号” $w(t) = u_c(t) - v(t)$ 的反馈环路。抗饱和项由该信号驱动。让我们找出将误差信号 $w$ 映射到控制器输出 $u_c$ 的LTI传递函数 $G(s)$。我们在零参考输入（$r=0$）的情况下分析系统，此时 $e=-y$。\n\n在拉普拉斯域中，控制器方程为：\n$u_c(s) = k_p e(s) + x_i(s)$\n$s x_i(s) = k_i e(s) - k_{aw} w(s)$\n\n从第二个方程，我们得到 $x_i(s) = \\frac{k_i}{s} e(s) - \\frac{k_{aw}}{s} w(s)$。将其代入第一个方程：\n$u_c(s) = k_p e(s) + \\frac{k_i}{s} e(s) - \\frac{k_{aw}}{s} w(s) = C(s) e(s) - \\frac{k_{aw}}{s} w(s)$。\n\n现在，我们将误差 $e(s)$ 与执行器输出 $v(s)$ 关联起来，并进而与 $u_c(s)$ 和 $w(s)$ 关联起来：\n$e(s) = -y(s) = -P(s) v(s)$。\n由于 $v(s) = u_c(s) - w(s)$，我们有 $e(s) = -P(s)(u_c(s) - w(s))$。\n\n将这个 $e(s)$ 的表达式代回 $u_c(s)$ 的方程中：\n$u_c(s) = C(s) [-P(s)(u_c(s) - w(s))] - \\frac{k_{aw}}{s} w(s)$\n$u_c(s) = -C(s)P(s) u_c(s) + C(s)P(s) w(s) - \\frac{k_{aw}}{s} w(s)$\n$u_c(s) (1 + C(s)P(s)) = \\left( C(s)P(s) - \\frac{k_{aw}}{s} \\right) w(s)$\n\n这就得到了从 $w$ 到 $u_c$ 的目标传递函数 $G(s)$：\n$G(s) = \\frac{u_c(s)}{w(s)} = \\frac{C(s)P(s) - \\frac{k_{aw}}{s}}{1 + C(s)P(s)}$。\n\n现在我们代入给定的对象和控制器传递函数：\n$k_p = 1$, $k_i = 1 \\implies C(s) = 1 + \\frac{1}{s} = \\frac{s+1}{s}$。\n$P(s) = \\frac{1}{s+1}$。\n环路增益为 $L(s) = C(s)P(s) = \\frac{s+1}{s} \\frac{1}{s+1} = \\frac{1}{s}$。\n\n将 $L(s)$ 代入 $G(s)$ 的表达式中：\n$G(s) = \\frac{\\frac{1}{s} - \\frac{k_{aw}}{s}}{1 + \\frac{1}{s}} = \\frac{\\frac{1-k_{aw}}{s}}{\\frac{s+1}{s}} = \\frac{1-k_{aw}}{s+1}$。\n\n系统现在可以表示为一个负反馈互联，其中前向路径是LTI系统 $G(s)$，反馈路径是由 $w(t) = \\Phi(u_c(t))$ 定义的非线性算子 $\\Phi$。在我们的设置中，这是一个正反馈回路：$u_c = G(w)$ 和 $w = \\Phi(u_c)$。\n非线性元件是 $\\Phi(u_c) = u_c - v = u_c - \\Psi(u_c) = (I - \\Psi)(u_c)$。\n\n问题要求为执行器 $\\Psi$ 建立一个一致的增量增益界。执行器施加幅值和速率限制。饱和和速率限制都是无源的、耗散的现象。任何实现这些约束的因果物理执行器模型，其增量 $L_2$ 增益都不会大于1。这是非线性控制中一个“经过充分检验的事实”。形式上，对于任意两个输入信号 $u_{c1}, u_{c2}$ 和对应的输出 $v_1=\\Psi(u_{c1}), v_2=\\Psi(u_{c2})$，我们有 $\\|\\Delta v\\|_{L_2} \\le \\|\\Delta u_c\\|_{L_2}$，其中 $\\Delta v = v_1-v_2$ 且 $\\Delta u_c=u_{c1}-u_{c2}$。在斜率界的意义上，这对应于算子 $\\Psi$ 位于增量扇区 $[0, 1]$ 内。这意味着对于任意两个输入 $u_{c1}, u_{c2}$，不等式 $0 \\le (\\Psi(u_{c1}) - \\Psi(u_{c2}))(u_{c1} - u_{c2})$ 成立，并且在平均意义上（$L_2$ 意义上）$(\\Psi(u_{c1}) - \\Psi(u_{c2}))^2 \\le (u_{c1} - u_{c2})^2$ 也成立。\n\n现在我们分析反馈回路中的非线性 $\\Phi = I - \\Psi$。我们可以从 $\\Psi$ 的性质来确定其增量扇区性质。设 $\\Delta w = w_1 - w_2$ 对应两个输入 $u_{c1}, u_{c2}$。$\\Delta w = \\Delta u_c - \\Delta v$。增量斜率为 $\\frac{\\Delta w}{\\Delta u_c} = 1 - \\frac{\\Delta v}{\\Delta u_c}$。由于 $\\Psi$ 位于增量扇区 $[0, 1]$ 内，比率 $\\frac{\\Delta v}{\\Delta u_c}$ 也位于 $[0, 1]$（在适用于动态算子的意义上）。因此，$\\Phi$ 的增量斜率 $\\frac{\\Delta w}{\\Delta u_c}$ 也位于范围 $[1-1, 1-0] = [0, 1]$ 内。所以，非线性 $\\Phi$ 也位于增量扇区 $[0, 1]$ 内。\n\n我们现在有一个由LTI系统 $G(s)$ 和一个位于扇区 $[0, 1]$ 内的非线性算子 $\\Phi$ 构成的反馈回路。我们可以应用圆判据来判断绝对稳定性。对于一个位于扇区 $[0, K]$ 内的非线性，如果 $G(j\\omega)$ 的奈奎斯特图不进入或包围临界圆盘 $D(-1/K, \\infty)$，则判据保证稳定性。对于 $K=1$，这个圆盘是实轴上的点 $-1$ 及其左侧的区域。因此，如果 $G(j\\omega)$ 的奈奎斯特图严格位于由 $\\text{Re}(z) > -1$ 定义的右半平面内，稳定性就得到保证。该条件为 $\\inf_{\\omega \\in \\mathbb{R}} \\text{Re}[G(j\\omega)] > -1$。\n\n让我们计算 $G(j\\omega)$ 的实部：\n$G(j\\omega) = \\frac{1-k_{aw}}{1+j\\omega} = \\frac{(1-k_{aw})(1-j\\omega)}{1+\\omega^2} = \\frac{1-k_{aw}}{1+\\omega^2} - j\\frac{\\omega(1-k_{aw})}{1+\\omega^2}$。\n所以，$\\text{Re}[G(j\\omega)] = \\frac{1-k_{aw}}{1+\\omega^2}$。\n\n我们需要找出该表达式对于所有 $\\omega \\geq 0$ 的下确界。分析取决于 $(1-k_{aw})$ 的符号。\n情况 1：$k_{aw} < 1$。此时，$(1-k_{aw}) > 0$。表达式 $\\frac{1-k_{aw}}{1+\\omega^2}$ 恒为正。其下确界在 $\\omega \\to \\infty$ 时出现，值为 $0$。条件是 $0 > -1$，这总是成立的。因此，对于所有 $0 < k_{aw} < 1$，系统是稳定的（已知 $k_{aw}>0$）。\n\n情况 2：$k_{aw} = 1$。此时，$G(s)=0$，且 $\\text{Re}[G(j\\omega)] = 0$。条件 $0 > -1$ 成立。\n\n情况 3：$k_{aw} > 1$。此时，$(1-k_{aw}) < 0$。表达式 $\\frac{1-k_{aw}}{1+\\omega^2}$ 恒为负。其下确界（最负的值）在分母 $1+\\omega^2$ 最小时出现，即在 $\\omega=0$ 时。\n$\\inf_{\\omega} \\text{Re}[G(j\\omega)] = \\frac{1-k_{aw}}{1+0^2} = 1-k_{aw}$。\n稳定性条件变为 $1-k_{aw} > -1$。\n这可以简化为 $2 > k_{aw}$。\n\n综合所有情况，稳定性的充分条件在 $k_{aw}$ 处于范围 $(0, 2)$ 内时成立。问题要求的是使此充分条件成立的抗饱和增益的上确界值 $k_{aw}^{\\star}$。满足条件的增益集合是 $(0, 2)$。该集合的上确界是 $2$。", "answer": "$$\\boxed{2}$$", "id": "2690042"}, {"introduction": "抗饱和技术设计的最终目标是提升系统的性能与鲁棒性，尤其是在系统经历大的扰动或指令变化时。本练习提供了一种强大的方法，通过数值计算来量化这种性能提升，即估算系统的吸引域（Region of Attraction, RoA）。通过对比有无抗饱和补偿下吸引域的大小，你将能直接衡量并理解抗饱和技术如何显著增强系统从大幅度偏离平衡点的状态下恢复稳定运行的能力。[@problem_id:2690066]", "problem": "考虑一个带有饱和执行器的双积分器对象，其控制器为在位置状态上增加了积分作用的线性状态反馈控制器。该对象遵循以下状态空间方程\n$$\n\\dot{x}_1 = x_2,\\quad \\dot{x}_2 = u,\n$$\n其中 $x_1 \\in \\mathbb{R}$ 是位置，$x_2 \\in \\mathbb{R}$ 是速度，$u \\in \\mathbb{R}$ 是控制输入。指令控制 $v \\in \\mathbb{R}$ 由一个带积分作用的线性状态反馈生成，\n$$\nv = -k_1 x_1 - k_2 x_2 - k_I z,\n$$\n其中 $z \\in \\mathbb{R}$ 是对 $x_1$ 进行积分的控制器积分器状态。执行器根据下式对指令控制进行饱和处理\n$$\nu = \\mathrm{sat}(v; u_{\\max}) \\triangleq \\max\\!\\big(-u_{\\max},\\, \\min(v,\\, u_{\\max})\\big),\n$$\n饱和极限为 $u_{\\max} \\gt 0$。不带抗饱和作用的积分器动态为\n$$\n\\dot{z} = x_1,\n$$\n而带有标准线性反算抗饱和增强的动态为\n$$\n\\dot{z} = x_1 + k_{\\mathrm{aw}}(u - v),\n$$\n其中 $k_{\\mathrm{aw}} \\ge 0$ 是抗饱和增益。所有量均为无量纲。\n\n对于给定的参数集 $(k_1, k_2, k_I, u_{\\max}, k_{\\mathrm{aw}})$ 和固定的初始积分器状态 $z(0) = 0$，将 $(x_1, x_2)$ 平面内原点的吸引域 (Region of Attraction, RoA) 定义为使得闭环轨迹收敛于原点的所有初始条件 $(x_1(0), x_2(0))$ 的集合。在本问题中，您将计算吸引域的一个已认证的内估计，即包含在吸引域中、以原点为中心的最大欧几里得球，其大小由半径 $r^\\star \\ge 0$ 量化：\n$$\nr^\\star \\triangleq \\sup\\{ r \\ge 0 \\; | \\; \\text{for all } \\theta \\in [0, 2\\pi),\\ \\|(x_1(0), x_2(0))\\|_2=r,\\ z(0)=0 \\Rightarrow \\lim_{t\\to\\infty} \\|(x_1(t), x_2(t))\\|_2 = 0 \\}.\n$$\n\n由于对该非线性饱和系统精确解析计算 $r^\\star$ 非常困难，您必须通过仿真闭环系统并对 $r$ 执行二分搜索来对其进行数值估计。请使用以下基于原则的规范：\n\n1. 使用上文给出的带饱和的完整非线性闭环动态。\n2. 对于一个候选半径 $r \\ge 0$，测试圆 $\\{(x_1(0), x_2(0)) \\; | \\; \\|(x_1(0), x_2(0))\\|_2 = r\\}$ 上所有初始条件，这些初始条件位于 $N$ 个等距角度 $\\theta_j = 2\\pi j/N$ 处，其中 $j \\in \\{0,1,\\ldots,N-1\\}$，$x_1(0) = r\\cos(\\theta_j)$，$x_2(0) = r\\sin(\\theta_j)$，且 $z(0)=0$。\n3. 对于每个初始条件，将系统仿真至有限时间域 $T$。如果轨迹进入了原点周围半径为 $\\varepsilon$ 的球内，即存在 $t \\in [0, T]$ 使得 $\\sqrt{x_1(t)^2 + x_2(t)^2} \\le \\varepsilon$，则宣布收敛。如果圆上的任何初始条件在时间域内未能收敛，则该候选半径 $r$ 未被认证。\n4. 使用由一个失败和一个成功的半径所构成的区间进行二分搜索，以计算出具有所需数值容差的 $r^\\star$ 估计值。您可以按几何级数增加上界，直到检测到失败或达到预设的上限。\n5. 对每个参数集重复计算两次：一次不使用抗饱和（即使用 $\\dot{z} = x_1$），一次使用抗饱和（即使用 $\\dot{z} = x_1 + k_{\\mathrm{aw}}(u-v)$）。将估计的半径分别表示为 $r^\\star_{\\mathrm{no\\_aw}}$ 和 $r^\\star_{\\mathrm{aw}}$，并通过以下比率量化由增强引起的扩大：\n$$\n\\rho \\triangleq \\frac{r^\\star_{\\mathrm{aw}}}{\\max(r^\\star_{\\mathrm{no\\_aw}}, \\delta)},\n$$\n其中 $\\delta \\gt 0$ 是一个微小的正则化项，以避免在退化情况下出现除以零的错误。\n\n使用定步长显式四阶 Runge–Kutta (RK4) 数值积分方法，时间步长为 $\\Delta t$，以确保确定性。在所有测试中使用以下数值参数：\n- 角度数量 $N = 24$。\n- 时间域 $T = 12$。\n- 时间步长 $\\Delta t = 0.01$。\n- 收敛半径 $\\varepsilon = 0.02$。\n- 发散警戒值：如果 $\\sqrt{x_1(t)^2 + x_2(t)^2}$ 曾超过 $R_{\\mathrm{div}} = 100$，则宣布该初始条件失败。\n- 二分搜索迭代次数 $N_{\\mathrm{bis}} = 12$。\n- 如果测试持续成功，初始上界 $r_{\\mathrm{init}} = 0.1$ 将以 $2$ 的因子增长，直至上限 $r_{\\mathrm{cap}} = 5.0$。\n\n测试套件。您的程序必须按给定顺序为以下四个参数集中的每一个计算 $(r^\\star_{\\mathrm{no\\_aw}}, r^\\star_{\\mathrm{aw}}, \\rho)$：\n- 情况 $1$：$k_1 = 2.0$, $k_2 = 2.0$, $k_I = 3.0$, $u_{\\max} = 0.5$, $k_{\\mathrm{aw}} = 5.0$。\n- 情况 $2$：$k_1 = 2.0$, $k_2 = 2.0$, $k_I = 3.0$, $u_{\\max} = 0.2$, $k_{\\mathrm{aw}} = 5.0$。\n- 情况 $3$：$k_1 = 4.0$, $k_2 = 3.0$, $k_I = 2.0$, $u_{\\max} = 0.5$, $k_{\\mathrm{aw}} = 10.0$。\n- 情况 $4$：$k_1 = 3.0$, $k_2 = 2.5$, $k_I = 2.0$, $u_{\\max} = 0.3$, $k_{\\mathrm{aw}} = 8.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表。对于每种情况，按顺序附加三个浮点数 $(r^\\star_{\\mathrm{no\\_aw}}, r^\\star_{\\mathrm{aw}}, \\rho)$，从而形成一个长度为 $12$ 的扁平列表。例如，输出必须具有以下形式\n$$\n[\\; r^\\star_{\\mathrm{no\\_aw},1},\\ r^\\star_{\\mathrm{aw},1},\\ \\rho_1,\\ r^\\star_{\\mathrm{no\\_aw},2},\\ r^\\star_{\\mathrm{aw},2},\\ \\rho_2,\\ r^\\star_{\\mathrm{no\\_aw},3},\\ r^\\star_{\\mathrm{aw},3},\\ \\rho_3,\\ r^\\star_{\\mathrm{no\\_aw},4},\\ r^\\star_{\\mathrm{aw},4},\\ \\rho_4 \\;].\n$$\n将每个打印的浮点数四舍五入到 $6$ 位小数。", "solution": "该问题要求对一个在带积分作用的饱和状态反馈控制下的双积分器对象，进行吸引域的数值估计。我们将针对两种情况进行此分析：带有和不带有反算抗饱和方案。目标是量化抗饱和增强所带来的性能提升。\n\n该闭环系统动态由一组三个一阶非线性常微分方程描述。设状态向量为 $\\mathbf{y}(t) = [x_1(t), x_2(t), z(t)]^T$，其中 $x_1$ 是位置，$x_2$ 是速度，$z$ 是积分器状态。状态空间表示为 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$。向量场 $f$ 的分量由下式给出：\n$$\n\\dot{x}_1 = x_2\n$$\n$$\n\\dot{x}_2 = u\n$$\n$$\n\\dot{z} = x_1 + k_{\\mathrm{aw}}(u - v)\n$$\n指令控制信号 $v$ 是状态的线性函数：\n$$\nv = -k_1 x_1 - k_2 x_2 - k_I z\n$$\n输入到对象的实际控制输入 $u$ 是指令信号 $v$ 经过带有极限 $u_{\\max}$ 的执行器饱和处理后的结果：\n$$\nu = \\mathrm{sat}(v; u_{\\max}) = \\max(-u_{\\max}, \\min(v, u_{\\max}))\n$$\n不带抗饱和的系统是这些动态的一个特例，其中抗饱和增益 $k_{\\mathrm{aw}}$ 设置为 $0$。\n\n对于此类非线性饱和系统，解析确定其吸引域 (RoA) 通常是难以解决的。因此，我们采用一种结构化的数值程序来计算吸引域的已认证内估计。所指定的估计是在 $(x_1, x_2)$ 平面中以原点为中心的最大欧几里得球，从该球出发的所有轨迹都收敛于原点。我们将该球的半径表示为 $r^\\star$。其形式化定义如下：\n$$\nr^\\star \\triangleq \\sup\\{ r \\ge 0 \\; | \\; \\text{for all } \\theta \\in [0, 2\\pi),\\ \\|(x_1(0), x_2(0))\\|_2=r,\\ z(0)=0 \\Rightarrow \\lim_{t\\to\\infty} \\|(x_1(t), x_2(t))\\|_2 = 0 \\}\n$$\n积分器的初始状态固定为 $z(0) = 0$。\n\n估计 $r^\\star$ 的计算方法遵循一个系统性的两阶段过程：区间确定和二分搜索。\n\n首先，我们定义一个测试程序 `check_radius(r)`，它确定给定的候选半径 $r$ 是否被认证。这是通过将 $(x_1, x_2)$ 平面中半径为 $r$ 的圆离散化为 $N=24$ 个初始点 $(x_1(0), x_2(0)) = (r\\cos(\\theta_j), r\\sin(\\theta_j))$（其中 $\\theta_j = 2\\pi j/N$，$j \\in \\{0, \\dots, N-1\\}$）来实现的。对于每个初始条件，使用定步长为 $\\Delta t=0.01$ 的显式四阶 Runge-Kutta (RK4) 方法对系统轨迹进行仿真，仿真时长为 $T=12$，以确保结果的确定性。如果一条轨迹在 $(x_1, x_2)$ 平面上的投影进入了原点周围半径为 $\\varepsilon=0.02$ 的球内，即对于某个 $t \\in [0, T]$ 存在 $\\sqrt{x_1(t)^2 + x_2(t)^2} \\le \\varepsilon$，则该轨迹被宣布为收敛。如果一条轨迹的范数超过了发散警戒值 $R_{\\mathrm{div}}=100$，则宣布其为不收敛。只有当来自其圆周上的所有 $N$ 条轨迹都收敛时，半径 $r$ 才被认证。\n\n其次，我们采用一种搜索算法来找到上确界 $r^\\star$。\n1.  **区间确定**：我们寻找一个区间 $[r_{\\text{low}}, r_{\\text{high}}]$，使得 `check_radius`($r_{\\text{low}}$) 成功而 `check_radius`($r_{\\text{high}}$) 失败。我们从 $r_{\\text{high}} = r_{\\text{init}} = 0.1$ 开始，并已知在 $r=0$ 时测试成功。如果 $r_{\\text{high}}$ 测试成功，我们便将 $r_{\\text{low}}$ 更新为此新值，并按因子 $2$ 几何级数增加 $r_{\\text{high}}$，重复此过程直到检测到失败或达到上限 $r_{\\text{cap}}=5.0$。如果在 $r_{\\text{cap}}$ 处测试仍然成功，我们就取 $r^\\star = r_{\\text{cap}}$。\n2.  **二分搜索**：一旦找到一个有效的区间 $[r_{\\text{low}}, r_{\\text{high}}]$，我们执行 $N_{\\mathrm{bis}}=12$ 次二分法迭代来精化 $r^\\star$ 的估计值。在每次迭代中，我们测试中点 $r_{\\text{mid}} = (r_{\\text{low}} + r_{\\text{high}})/2$。如果 $r_{\\text{mid}}$ 被认证，我们更新 $r_{\\text{low}} = r_{\\text{mid}}$；否则，我们更新 $r_{\\text{high}} = r_{\\text{mid}}$。最终结果是 $r_{\\text{low}}$ 的终值。\n\n对每个参数集都执行这整个过程，一次在 $k_{\\mathrm{aw}}=0$ 的情况下找到 $r^\\star_{\\mathrm{no\\_aw}}$，另一次在给定的 $k_{\\mathrm{aw}}>0$ 的情况下找到 $r^\\star_{\\mathrm{aw}}$。相对提升由比率 $\\rho = r^\\star_{\\mathrm{aw}} / \\max(r^\\star_{\\mathrm{no\\_aw}}, \\delta)$ 来衡量，其中 $\\delta=10^{-9}$ 是一个小的正则化项。该实现严格遵守所有指定的数值参数。", "answer": "```python\nimport numpy as np\nimport math\n\n# Global numerical parameters\nN_ANGLES = 24\nTIME_HORIZON = 12.0\nDT = 0.01\nCONVERGENCE_RADIUS = 0.02\nDIVERGENCE_GUARD = 100.0\nN_BISECTION = 12\nR_INIT = 0.1\nR_CAP = 5.0\nDELTA_REG = 1e-9\n\ndef system_dynamics(state, params, use_aw):\n    \"\"\"\n    Computes the time derivative of the state vector.\n    state: [x1, x2, z]\n    params: dictionary of controller and plant parameters\n    use_aw: boolean to enable/disable anti-windup\n    \"\"\"\n    x1, x2, z = state\n    k1, k2, kI, u_max, k_aw = params['k1'], params['k2'], params['kI'], params['u_max'], params['k_aw']\n\n    # Commanded control\n    v = -k1 * x1 - k2 * x2 - kI * z\n\n    # Saturated control\n    u = np.clip(v, -u_max, u_max)\n\n    # State derivatives\n    dx1_dt = x2\n    dx2_dt = u\n    \n    if use_aw:\n        dz_dt = x1 + k_aw * (u - v)\n    else:\n        dz_dt = x1\n        \n    return np.array([dx1_dt, dx2_dt, dz_dt])\n\ndef rk4_step(func, state, t, dt, params, use_aw):\n    \"\"\"Performs a single RK4 step.\"\"\"\n    k1 = func(state, params, use_aw)\n    k2 = func(state + dt / 2.0 * k1, params, use_aw)\n    k3 = func(state + dt / 2.0 * k2, params, use_aw)\n    k4 = func(state + dt * k3, params, use_aw)\n    return state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef simulate_trajectory(x1_0, x2_0, params, use_aw):\n    \"\"\"\n    Simulates a single trajectory to check for convergence.\n    Returns True if converges, False otherwise.\n    \"\"\"\n    state = np.array([x1_0, x2_0, 0.0])\n    num_steps = int(TIME_HORIZON / DT)\n\n    for i in range(num_steps):\n        t = i * DT\n        state = rk4_step(system_dynamics, state, t, DT, params, use_aw)\n        \n        # Check for convergence\n        if math.sqrt(state[0]**2 + state[1]**2) <= CONVERGENCE_RADIUS:\n            return True\n            \n        # Check for divergence\n        if math.sqrt(state[0]**2 + state[1]**2) > DIVERGENCE_GUARD:\n            return False\n\n    return False\n\ndef check_radius(r, params, use_aw):\n    \"\"\"\n    Tests if all initial conditions on a circle of radius r converge.\n    Returns True if all converge, False otherwise.\n    \"\"\"\n    if r == 0.0:\n        return True\n    \n    angles = np.linspace(0, 2 * np.pi, N_ANGLES, endpoint=False)\n    for theta in angles:\n        x1_0 = r * math.cos(theta)\n        x2_0 = r * math.sin(theta)\n        \n        if not simulate_trajectory(x1_0, x2_0, params, use_aw):\n            return False\n            \n    return True\n\ndef find_r_star(params, use_aw):\n    \"\"\"\n    Finds the estimated radius of the region of attraction r_star.\n    \"\"\"\n    # Phase 1: Bracket finding\n    r_low = 0.0\n    r_high = R_INIT\n    \n    while True:\n        is_success = check_radius(r_high, params, use_aw)\n        if is_success:\n            r_low = r_high\n            if r_high == R_CAP:\n                return R_CAP  # Succeeded up to the cap\n            r_high = min(r_high * 2, R_CAP)\n        else:\n            break  # Found bracket [r_low, r_high] where low succeeds and high fails\n            \n    # Phase 2: Bisection search\n    for _ in range(N_BISECTION):\n        r_mid = (r_low + r_high) / 2.0\n        if check_radius(r_mid, params, use_aw):\n            r_low = r_mid\n        else:\n            r_high = r_mid\n            \n    return r_low\n\ndef solve():\n    test_cases = [\n        {'k1': 2.0, 'k2': 2.0, 'kI': 3.0, 'u_max': 0.5, 'k_aw': 5.0},\n        {'k1': 2.0, 'k2': 2.0, 'kI': 3.0, 'u_max': 0.2, 'k_aw': 5.0},\n        {'k1': 4.0, 'k2': 3.0, 'kI': 2.0, 'u_max': 0.5, 'k_aw': 10.0},\n        {'k1': 3.0, 'k2': 2.5, 'kI': 2.0, 'u_max': 0.3, 'k_aw': 8.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        r_star_no_aw = find_r_star(params, use_aw=False)\n        r_star_aw = find_r_star(params, use_aw=True)\n        \n        rho = r_star_aw / max(r_star_no_aw, DELTA_REG)\n        \n        all_results.extend([r_star_no_aw, r_star_aw, rho])\n\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2690066"}]}