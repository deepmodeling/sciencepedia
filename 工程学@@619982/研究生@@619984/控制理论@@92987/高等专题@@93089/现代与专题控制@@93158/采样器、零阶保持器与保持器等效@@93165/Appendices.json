{"hands_on_practices": [{"introduction": "理论学习之后，最佳的巩固方式便是亲手实践。我们将从一个基本的一阶系统入手，通过第一性原理推导其在采样器和零阶保持器（ZOH）作用下的精确离散时间模型。这个练习旨在帮助你牢固掌握将连续时间系统转化为离散时间差分方程的核心过程，这是数字控制领域的一项基本功。[@problem_id:2743064]", "problem": "考虑一个连续时间标量一阶系统，其传递函数为 $P(s)=\\frac{1}{s+a}$，其中 $a0$。该系统由一个采样数据互联结构驱动，该结构包含一个采样周期为 $T0$ 的理想采样器和一个零阶保持器 (ZOH)，零阶保持器在每个采样区间内将输入采样值保持为常数。设 $u[k]$ 表示施加于 ZOH 的离散时间输入，因此连续时间输入 $u(t)$ 是分段常数，对于 $t\\in[kT,(k+1)T)$ 满足 $u(t)=u[k]$；并设 $y[k]$ 表示采样输出 $y(kT)$。\n\n从线性时不变 (LTI) 系统的第一性原理出发——即状态空间表示、通过矩阵指数求解线性微分方程以及零阶保持器 (ZOH) 的定义——推导在采样周期 $T$ 下，与“采样器-系统-ZOH”互联结构中的连续时间系统保持器等效的、形式为 $y[k+1]=\\alpha\\,y[k]+\\beta\\,u[k]$ 的精确离散时间输入-输出关系。\n\n您的任务是以闭式解的形式计算系数 $\\alpha$ 和 $\\beta$，使其表示为 $a$ 和 $T$ 的函数。请以单个行向量 $\\begin{pmatrix}\\alpha  \\beta\\end{pmatrix}$ 的形式给出您的最终答案（无单位）。", "solution": "该连续时间系统由传递函数 $P(s) = \\frac{Y(s)}{U(s)} = \\frac{1}{s+a}$ 描述。这对应于线性常微分方程：\n$$\n\\frac{d}{dt}y(t) + a y(t) = u(t)\n$$\n我们将该系统表示为状态空间形式。对于此一阶系统，我们可以选择状态变量 $x(t)$ 为输出本身，即 $x(t) = y(t)$。其状态空间表示则为：\n$$\n\\dot{x}(t) = A x(t) + B u(t)\n$$\n$$\ny(t) = C x(t) + D u(t)\n$$\n通过与微分方程 $\\dot{y}(t) = -a y(t) + u(t)$ 进行比较，并注意到 $x(t) = y(t)$，我们可确定系统矩阵（在本例中为标量）：\n$$\nA = -a, \\quad B = 1, \\quad C = 1, \\quad D = 0\n$$\n对于线性时不变 (LTI) 系统，其在时间区间 $[t_0, t]$ 上的状态方程的解由常数变易法公式给出：\n$$\nx(t) = \\exp(A(t-t_0)) x(t_0) + \\int_{t_0}^{t} \\exp(A(t-\\tau)) B u(\\tau) d\\tau\n$$\n我们关心的是状态从一个采样时刻 $t_0 = kT$ 到下一个采样时刻 $t = (k+1)T$ 的演变。将这些值代入解中可得：\n$$\nx((k+1)T) = \\exp(A((k+1)T - kT)) x(kT) + \\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) B u(\\tau) d\\tau\n$$\n我们定义离散时间状态 $x[k] \\equiv x(kT)$。方程变为：\n$$\nx[k+1] = \\exp(AT) x[k] + \\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) B u(\\tau) d\\tau\n$$\n问题指明了采用零阶保持器 (ZOH)，这意味着连续时间输入 $u(t)$ 在每个采样区间上是分段常数。具体来说，对于区间 $[kT, (k+1)T)$ 内的任何 $\\tau$，输入都保持在离散时间采样值 $u[k]$，即 $u(\\tau) = u[k]$。由于 $u[k]$ 是一个常数，我们可以将其提到积分符号外：\n$$\nx[k+1] = \\exp(AT) x[k] + \\left( \\int_{kT}^{(k+1)T} \\exp(A((k+1)T - \\tau)) B d\\tau \\right) u[k]\n$$\n为计算此积分，我们进行变量替换。令 $\\lambda = (k+1)T - \\tau$。这意味着 $d\\lambda = -d\\tau$。积分限变化如下：当 $\\tau = kT$ 时，$\\lambda = T$；当 $\\tau = (k+1)T$ 时，$\\lambda = 0$。该积分变为：\n$$\n\\int_{T}^{0} \\exp(A\\lambda) B (-d\\lambda) = \\int_{0}^{T} \\exp(A\\lambda) B d\\lambda\n$$\n这就得到了精确的离散时间状态空间模型：\n$$\nx[k+1] = F_d x[k] + G_d u[k]\n$$\n其中离散时间系统矩阵 $F_d$ 和输入矩阵 $G_d$ 定义为：\n$$\nF_d = \\exp(AT)\n$$\n$$\nG_d = \\left( \\int_{0}^{T} \\exp(A\\lambda) d\\lambda \\right) B\n$$\n现在，我们将我们特定系统的标量值 $A = -a$ 和 $B = 1$ 代入。\n矩阵 $F_d$ 是：\n$$\nF_d = \\exp(-aT)\n$$\n矩阵 $G_d$ 通过计算以下积分得到：\n$$\nG_d = \\left( \\int_{0}^{T} \\exp(-a\\lambda) d\\lambda \\right) \\cdot 1 = \\left[ -\\frac{1}{a} \\exp(-a\\lambda) \\right]_0^T\n$$\n代入积分限计算得：\n$$\nG_d = -\\frac{1}{a} (\\exp(-aT) - \\exp(0)) = -\\frac{1}{a} (\\exp(-aT) - 1) = \\frac{1 - \\exp(-aT)}{a}\n$$\n因此，离散时间状态方程为：\n$$\nx[k+1] = \\exp(-aT) x[k] + \\frac{1-\\exp(-aT)}{a} u[k]\n$$\n问题要求将采样输入 $u[k]$ 与采样输出 $y[k] \\equiv y(kT)$ 关联起来。根据我们的状态空间定义，$y(t) = C x(t) + D u(t)$。当 $C=1$ 且 $D=0$ 时，我们有 $y(t) = x(t)$。因此，采样输出等于离散时间状态：$y[k] = y(kT) = x(kT) = x[k]$。\n在离散状态方程中用 $y[k]$ 替换 $x[k]$，我们得到最终的输入-输出关系：\n$$\ny[k+1] = \\exp(-aT) y[k] + \\frac{1-\\exp(-aT)}{a} u[k]\n$$\n该方程符合所需形式 $y[k+1] = \\alpha y[k] + \\beta u[k]$。通过直接比较，我们确定系数 $\\alpha$ 和 $\\beta$：\n$$\n\\alpha = \\exp(-aT)\n$$\n$$\n\\beta = \\frac{1-\\exp(-aT)}{a}\n$$\n如要求所述，这些系数是系统参数 $a$ 和采样周期 $T$ 的函数。", "answer": "$$\\boxed{\\begin{pmatrix} \\exp(-aT)  \\frac{1-\\exp(-aT)}{a} \\end{pmatrix}}$$", "id": "2743064"}, {"introduction": "对于高阶或复杂的系统，直接通过解析积分计算离散时间矩阵 $B_d$ 往往是不现实的。本次实践将引导你探索并实现三种不同的数值计算方法，并对它们的精度进行比较。通过这个编码练习，你将深入理解将理论公式转化为可靠数值算法的挑战与策略，并体会不同算法在精度和效率上的权衡。[@problem_id:2743061]", "problem": "考虑在每个采样区间内输入恒定的连续时间线性时不变状态空间模型（零阶保持器假设）：对于状态向量 $x(t) \\in \\mathbb{R}^n$ 和输入向量 $u(t) \\in \\mathbb{R}^m$，当 $t \\in [kT,(k+1)T)$ 时输入恒为 $u(t) \\equiv u_k$（其中 $T  0$ 是采样周期），其动态方程由 $\\dot{x}(t) = A x(t) + B u(t)$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times m}$ 是常数矩阵。其零阶保持器等效离散时间模型由映射 $x((k+1)T) = \\Phi x(kT) + B_d u_k$ 定义，其中 $\\Phi \\in \\mathbb{R}^{n \\times n}$ 和 $B_d \\in \\mathbb{R}^{n \\times m}$ 是与该保持器相关联的离散时间状态矩阵和输入矩阵。根据常数变易法公式，其精确定义为 $\\Phi = \\exp(A T)$ 和\n$$\nB_d = \\int_0^{T} \\exp(A \\tau) \\, B \\, d\\tau.\n$$\n你的任务是实现三种数值方法，为指定的矩阵三元组 $(A,B,T)$ 计算 $B_d$，并通过估计它们的误差来对这些方法进行比较。所要求的三种方法是：\n- 对 $B_d$ 的定义积分使用高阶法则进行直接数值积分，并采用步长加倍法估计积分误差。\n- 对 $\\exp(A \\tau)$ 进行截断级数展开并逐项积分，截断误差估计量可基于级数中首个被忽略的项进行计算。\n- 计算一个增广系统的分块矩阵指数，在其非对角块中得到 $B_d$，并计算任何精确 $B_d$ 都必须满足的一致性残差。\n\n你的实现和分析必须基于以下基本事实：\n- 线性系统的常数变易法公式和矩阵指数 $\\exp(A t)$ 的定义。\n- 级数和积分的范数性质及基本不等式。\n- 弗罗贝尼乌斯矩阵范数的定义。\n\n实现和误差估计要求：\n- 对于直接积分法，在 $[0,T]$ 上使用具有 $N$ 个节点的高斯-勒让德法则，并通过比较 $N$ 和 $2N$ 个节点的结果获得误差估计量。使用 $N = 64$ 和 $2N = 128$。\n- 对于级数展开法，将 $\\exp(A \\tau)$ 展开为其幂级数，逐项积分并求和，直到首个被忽略项的弗罗贝尼乌斯范数与当前部分和的弗罗贝尼乌斯范数之比低于容差 $\\epsilon$。使用 $\\epsilon = 10^{-12}$，并设置 $K_{\\max} = 200$ 项的硬性上限以避免无限循环。误差估计量为首个被忽略项相对于部分和的相对范数。\n- 对于分块矩阵指数法，通过一次增广矩阵指数计算同时得到 $\\Phi$ 和 $B_d$，并使用对精确量成立的离散时间恒等式残差来评估其质量：\n$$\nA B_d = \\left(\\Phi - I_n\\right) B,\n$$\n其中 $I_n$ 是 $n \\times n$ 的单位矩阵。报告以弗罗贝尼乌斯范数计算的相对残差，该残差通过 $\\|A\\|_F \\|B_d\\|_F$ 和 $\\|\\Phi - I_n\\|_F \\|B\\|_F$ 中的较大者进行归一化。\n\n数值输出：\n- 对于每个测试用例 $(A,B,T)$，计算：\n    1. 直接积分法计算的 $B_d$ 相对于通过分块矩阵指数法获得的高精度参考值的相对弗罗贝尼乌斯范数误差。\n    2. 通过节点加倍法获得的积分误差估计量。\n    3. 级数展开法计算的 $B_d$ 相对于同一参考值的相对弗罗贝尼乌斯范数误差。\n    4. 级数截断误差估计量（首个被忽略项相对于部分和）。\n    5. 如上所述的分块矩阵指数法的一致性相对残差。\n\n所有范数均为弗罗贝尼乌斯范数，所有相对误差均为无单位的标量。\n\n测试套件：\n- 使用以下五个测试用例。对于每个用例，$A$ 和 $B$ 为给定的实数矩阵，$T$ 为一个实数正标量。无需报告物理单位。\n\n    - 用例 1：$A = [-1.0]$, $B = [1.0]$, $T = 0.1$。\n    - 用例 2：$A = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $T = 1.0$。\n    - 用例 3：$A = \\begin{bmatrix} -10  20  0 \\\\ -30  -40  0 \\\\ 0  0  -0.01 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\end{bmatrix}$, $T = 0.05$。\n    - 用例 4：$A = \\begin{bmatrix} 0  -10 \\\\ 10  0 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, $T = 0.2$。\n    - 用例 5：$A = \\begin{bmatrix} -100  0 \\\\ 0  -0.1 \\end{bmatrix}$, $B = \\begin{bmatrix} 1  2 \\\\ 3  4 \\end{bmatrix}$, $T = 10^{-3}$。\n\n最终输出格式：\n- 你的程序应生成包含一个列表的列表的单行输出。对于上述给出的每个测试用例，按顺序返回一个包含五个浮点数的列表：\n$$\n\\left[ e_{\\mathrm{quad,true}}, \\; e_{\\mathrm{quad,est}}, \\; e_{\\mathrm{series,true}}, \\; e_{\\mathrm{series,est}}, \\; e_{\\mathrm{block,resid}} \\right],\n$$\n其中每个标量都如上所定义。将五个用例的列表聚合到一个列表中，并打印仅包含此聚合列表的一行，使用逗号分隔值并用方括号括起来，例如：\n$$\n\\left[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], \\ldots \\right].\n$$\n无需物理单位，也不涉及角度。所有结果均为实数浮点数。", "solution": "连续时间系统由状态空间方程 $\\dot{x}(t) = A x(t) + B u(t)$ 描述，其中 $x(t) \\in \\mathbb{R}^n$ 是状态向量，$u(t) \\in \\mathbb{R}^m$ 是输入向量，$A \\in \\mathbb{R}^{n \\times n}$ 是状态矩阵，$B \\in \\mathbb{R}^{n \\times m}$ 是输入矩阵。在零阶保持器下，输入在每个采样区间 $T  0$ 内保持恒定，具体为 $u(t) = u_k$ 当 $t \\in [kT, (k+1)T)$。通过常数变易法公式求解状态方程，可得到等效的离散时间模型：\n$$x_{k+1} = \\Phi x_k + B_d u_k$$\n其中 $x_k = x(kT)$，$\\Phi = \\exp(A T)$ 是状态转移矩阵，$B_d$ 是离散时间输入矩阵，由以下积分给出：\n$$B_d = \\int_0^{T} \\exp(A \\tau) B \\, d\\tau$$\n我们的任务是使用三种不同的数值方法计算 $B_d$ 并评估其精度。所有矩阵范数，记作 $\\|\\cdot\\|_F$，均为弗罗贝尼乌斯范数。\n\n**方法1：直接数值积分**\n定义 $B_d$ 的积分可以使用数值积分法则来近似。我们采用 $N$ 点高斯-勒让德积分。标准节点 $x_i$ 和权重 $w_i$ 定义在区间 $[-1, 1]$ 上。为了在 $[0, T]$ 上计算积分，我们进行变量代换 $\\tau = \\frac{T}{2}(\\xi + 1)$，得到近似式：\n$$B_d \\approx B_{d,N} = \\frac{T}{2} \\sum_{i=1}^{N} w_i \\exp\\left(A \\frac{T}{2}(\\xi_i + 1)\\right) B$$\n我们使用 $N=64$ 和 $2N=128$ 个节点计算两个近似值 $B_{d,N}$ 和 $B_{d,2N}$。矩阵指数 $\\exp(\\cdot)$ 使用高保真算法计算。$N$ 点法则的误差通过将其结果与 $2N$ 点法则的结果进行比较来估计。相对误差估计量定义为：\n$$e_{\\mathrm{quad,est}} = \\frac{\\|B_{d,128} - B_{d,64}\\|_F}{\\|B_{d,128}\\|_F}$$\n$64$ 点法则的真实相对误差是相对于一个高精度参考解 $B_{d,\\mathrm{ref}}$ 计算的，该参考解由稍后讨论的分块矩阵指数法得到。\n$$e_{\\mathrm{quad,true}} = \\frac{\\|B_{d,64} - B_{d,\\mathrm{ref}}\\|_F}{\\|B_{d,\\mathrm{ref}}\\|_F}$$\n\n**方法2：截断级数展开**\n矩阵指数可以展开为幂级数：$\\exp(A \\tau) = \\sum_{k=0}^{\\infty} \\frac{(A\\tau)^k}{k!}$。将其代入 $B_d$ 的定义并逐项积分，得到：\n$$B_d = \\int_0^{T} \\left( \\sum_{k=0}^{\\infty} \\frac{A^k \\tau^k}{k!} \\right) B \\, d\\tau = \\left( \\sum_{k=0}^{\\infty} \\frac{A^k}{k!} \\int_0^{T} \\tau^k d\\tau \\right) B = \\left( \\sum_{k=0}^{\\infty} \\frac{A^k T^{k+1}}{(k+1)!} \\right) B$$\n该级数可以写成 $B_d = S \\cdot B$，其中 $S = \\sum_{k=0}^{\\infty} M_k$ 且 $M_k = \\frac{A^k T^{k+1}}{(k+1)!}$。项 $M_k$ 可以通过递推关系 $M_0 = T I_n$ 和 $k \\ge 1$ 时的 $M_k = M_{k-1} \\frac{A T}{k+1}$ 高效计算。我们计算部分和 $S_K = \\sum_{k=0}^{K} M_k$，得到近似值 $B_{d,K} = S_K B$。当下一待加项 $M_{K+1}B$ 的弗罗贝尼乌斯范数与当前和 $B_{d,K}$ 的弗罗贝尼乌斯范数之比低于容差 $\\epsilon = 10^{-12}$ 时，或者达到 $K_{\\max} = 200$ 项的最大限制时，求和终止。误差估计量为首个被忽略项的相对范数：\n$$e_{\\mathrm{series,est}} = \\frac{\\|M_{K+1}B\\|_F}{\\|S_K B\\|_F}$$\n真实相对误差是相对于参考解计算的：\n$$e_{\\mathrm{series,true}} = \\frac{\\|B_{d,\\mathrm{series}} - B_{d,\\mathrm{ref}}\\|_F}{\\|B_{d,\\mathrm{ref}}\\|_F}$$\n\n**方法3：分块矩阵指数**\n该方法可以同时高精度地计算 $\\Phi$ 和 $B_d$，并将作为我们的参考方法。我们构建一个增广线性系统。鉴于 $u(t) = u_k$ 是常数，其时间导数为零。我们可以写出：\n$$\\frac{d}{dt} \\begin{pmatrix} x(t) \\\\ u_k \\end{pmatrix} = \\begin{pmatrix} A  B \\\\ 0  0_{m \\times m} \\end{pmatrix} \\begin{pmatrix} x(t) \\\\ u_k \\end{pmatrix}$$\n其中 $0_{m \\times m}$ 是 $m \\times m$ 的零矩阵。这个增广齐次系统在一个采样周期 $T$ 内的解由增广矩阵的矩阵指数给出：\n$$\\begin{pmatrix} x((k+1)T) \\\\ u_k \\end{pmatrix} = \\exp\\left( \\begin{pmatrix} A  B \\\\ 0  0 \\end{pmatrix} T \\right) \\begin{pmatrix} x(kT) \\\\ u_k \\end{pmatrix}$$\n已知该分块矩阵指数的结构为：\n$$\\exp\\left( \\begin{pmatrix} A  B \\\\ 0  0 \\end{pmatrix} T \\right) = \\begin{pmatrix} \\exp(AT)  \\int_0^T \\exp(A\\tau) B d\\tau \\\\ 0  I_m \\end{pmatrix} = \\begin{pmatrix} \\Phi  B_d \\\\ 0  I_m \\end{pmatrix}$$\n因此，通过计算一个 $(n+m) \\times (n+m)$ 矩阵的指数，我们即可在其子块中同时获得 $\\Phi$ 和 $B_d$。该方法通常被认为是最鲁棒和最准确的。我们将其结果指定为 $\\Phi_{\\mathrm{ref}}$ 和 $B_{d,\\mathrm{ref}}$。\n\n为了评估此计算的质量，我们使用一个已知的、精确的 $\\Phi$ 和 $B_d$ 必须满足的一致性恒等式：$A B_d = (\\Phi - I_n) B$。残差矩阵为 $R = A B_{d,\\mathrm{ref}} - (\\Phi_{\\mathrm{ref}} - I_n) B$。相对一致性残差按规定定义为：\n$$e_{\\mathrm{block,resid}} = \\frac{\\|R\\|_F}{\\max \\left( \\|A\\|_F \\|B_{d,\\mathrm{ref}}\\|_F, \\|\\Phi_{\\mathrm{ref}} - I_n\\|_F \\|B\\|_F \\right)}$$\n\n以下实现将这三种方法应用于指定的测试用例，并为每个用例计算五个所需的性能指标。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef compute_Bd_quadrature(A, B, T, N):\n    \"\"\"\n    Computes Bd using N-point Gauss-Legendre quadrature.\n    \"\"\"\n    # Get Gauss-Legendre nodes and weights for interval [-1, 1]\n    xi, w = np.polynomial.legendre.leggauss(N)\n\n    # Scale nodes and weights for interval [0, T]\n    tau = 0.5 * T * (xi + 1.0)\n    w_scaled = 0.5 * T * w\n\n    n, m = B.shape\n    Bd = np.zeros((n, m), dtype=float)\n\n    for i in range(N):\n        # The integrand is exp(A*tau) * B\n        integrand = expm(A * tau[i]) @ B\n        Bd += w_scaled[i] * integrand\n    \n    return Bd\n\ndef compute_Bd_series(A, B, T, tol, max_terms):\n    \"\"\"\n    Computes Bd using term-by-term integration of the matrix exponential series.\n    \"\"\"\n    n, m = B.shape\n    \n    # M_k = (A^k * T^(k+1)) / (k+1)!\n    # Recurrence: M_k = M_{k-1} * (A*T) / (k+1)\n    \n    # k = 0 term\n    M_k = T * np.eye(n, dtype=float)\n    S = M_k.copy()\n\n    for k in range(1, max_terms):\n        # Compute next matrix term M_k\n        M_k = M_k @ (A * T) / (k + 1)\n        \n        # Check stopping criterion\n        current_Bd_sum = S @ B\n        next_Bd_term = M_k @ B\n        \n        norm_sum = np.linalg.norm(current_Bd_sum, 'fro')\n        norm_next = np.linalg.norm(next_Bd_term, 'fro')\n\n        # Avoid division by zero if the sum is zero\n        if norm_sum  0:\n            rel_norm = norm_next / norm_sum\n            if rel_norm  tol:\n                error_est = rel_norm\n                return S @ B, error_est\n        \n        S += M_k\n\n    # If loop finished, return current sum and last relative norm\n    final_Bd = S @ B\n    final_next_term = M_k @ (A * T) / (max_terms + 1) @ B\n    error_est = np.linalg.norm(final_next_term, 'fro') / np.linalg.norm(final_Bd, 'fro')\n\n    return final_Bd, error_est\n\ndef compute_phi_bd_block_matrix(A, B, T):\n    \"\"\"\n    Computes Phi and Bd using the block matrix exponential method.\n    \"\"\"\n    n, m = B.shape\n    \n    # Construct the augmented matrix M\n    M = np.zeros((n + m, n + m), dtype=float)\n    M[:n, :n] = A\n    M[:n, n:] = B\n    \n    # Compute the matrix exponential\n    E = expm(M * T)\n    \n    # Extract Phi and Bd\n    Phi = E[:n, :n]\n    Bd = E[:n, n:]\n    \n    return Phi, Bd\n\ndef frobenius_norm(M):\n    \"\"\"Convenience function for Frobenius norm.\"\"\"\n    return np.linalg.norm(M, 'fro')\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and compute error metrics.\n    \"\"\"\n    test_cases = [\n        (np.array([[-1.0]]), np.array([[1.0]]), 0.1),\n        (np.array([[0.0, 1.0], [0.0, 0.0]]), np.array([[0.0], [1.0]]), 1.0),\n        (np.array([[-10.0, 20.0, 0.0], [-30.0, -40.0, 0.0], [0.0, 0.0, -0.01]]),\n         np.array([[1.0], [0.0], [1.0]]), 0.05),\n        (np.array([[0.0, -10.0], [10.0, 0.0]]), np.array([[1.0], [0.0]]), 0.2),\n        (np.array([[-100.0, 0.0], [0.0, -0.1]]), np.array([[1.0, 2.0], [3.0, 4.0]]), 1e-3)\n    ]\n    \n    all_results = []\n\n    for A, B, T in test_cases:\n        n = A.shape[0]\n\n        # Method 3: Block Matrix Exponential (Reference)\n        Phi_ref, Bd_ref = compute_phi_bd_block_matrix(A, B, T)\n        norm_Bd_ref = frobenius_norm(Bd_ref)\n\n        # Method 1: Quadrature\n        N_quad_1 = 64\n        N_quad_2 = 128\n        Bd_quad_1 = compute_Bd_quadrature(A, B, T, N_quad_1)\n        Bd_quad_2 = compute_Bd_quadrature(A, B, T, N_quad_2)\n        \n        e_quad_true = frobenius_norm(Bd_quad_1 - Bd_ref) / norm_Bd_ref\n        norm_Bd_quad_2 = frobenius_norm(Bd_quad_2)\n        e_quad_est = frobenius_norm(Bd_quad_2 - Bd_quad_1) / norm_Bd_quad_2 if norm_Bd_quad_2  0 else 0.0\n\n        # Method 2: Series Expansion\n        tol_series = 1e-12\n        max_terms_series = 200\n        Bd_series, e_series_est = compute_Bd_series(A, B, T, tol_series, max_terms_series)\n        \n        e_series_true = frobenius_norm(Bd_series - Bd_ref) / norm_Bd_ref\n\n        # Quality of Reference Method (Block Matrix)\n        I_n = np.eye(n)\n        R = A @ Bd_ref - (Phi_ref - I_n) @ B\n        norm_R = frobenius_norm(R)\n        \n        term1 = frobenius_norm(A) * frobenius_norm(Bd_ref)\n        term2 = frobenius_norm(Phi_ref - I_n) * frobenius_norm(B)\n        \n        den = max(term1, term2)\n        e_block_resid = norm_R / den if den  0 else 0.0\n        \n        case_results = [e_quad_true, e_quad_est, e_series_true, e_series_est, e_block_resid]\n        all_results.append(case_results)\n\n    # Format the output as specified\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2743061"}, {"introduction": "掌握了离散化方法后，一个更深层次的问题是：离散化过程是否总能保持原连续系统的所有优良特性，如能达性？这个实践将通过一个引人深思的计算任务揭示“病态采样”现象，即不恰当的采样周期可能导致一个完全能达的连续系统变为离散时间下不能达的。你将通过编程来诊断这种特性的丢失，并探索如何通过微调采样周期 $T$ 来恢复系统的能达性，这对于鲁棒的数字控制器设计至关重要。[@problem_id:2743060]", "problem": "考虑一个带有采样器和输入端零阶保持器 (ZOH) 的连续时间线性时不变状态空间模型。该系统由状态方程 $\\dot{x}(t) = A x(t) + B u(t)$ 和输出方程 $y(t) = C x(t)$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$，$C \\in \\mathbb{R}^{p \\times n}$。在周期为 $T  0$ 秒的采样器和输入端零阶保持器的作用下，其精确（保持器等效）离散时间模型为 $x_{k+1} = A_d x_k + B_d u_k$, $y_k = C x_k$，其中 $A_d = e^{A T}$ 且 $B_d = \\int_{0}^{T} e^{A \\tau} B \\, d\\tau$。\n\n定义离散时间能达性矩阵为\n$$\n\\mathcal{R}_d(A_d,B_d) = \\left[ B_d \\; , \\; A_d B_d \\; , \\; \\dots \\; , \\; A_d^{n-1} B_d \\right] \\in \\mathbb{R}^{n \\times (n m)},\n$$\n定义离散时间能观性矩阵为\n$$\n\\mathcal{O}_d(A_d,C) = \\begin{bmatrix}\nC \\\\\nC A_d \\\\\n\\vdots \\\\\nC A_d^{n-1}\n\\end{bmatrix} \\in \\mathbb{R}^{(n p) \\times n}.\n$$\n如果 $\\operatorname{rank}(\\mathcal{R}_d) = n$，则该离散时间模型是能达的；如果 $\\operatorname{rank}(\\mathcal{O}_d) = n$，则是能观的。\n\n您的任务是编写一个完整的程序，对每个测试用例执行以下所有操作：\n- 对于给定的 $(A,B)$ 和采样周期 $T$，计算 ZOH 等效的离散时间系统对 $(A_d,B_d)$。\n- 构建 $\\mathcal{R}_d$ 和 $\\mathcal{O}_d$，并使用基于机器精度的容差、通过数值稳定的奇异值分解来计算它们的矩阵秩。\n- 如果 $\\operatorname{rank}(\\mathcal{R}_d) = n$，则报告扰动 $\\delta T = 0$（单位：秒）。如果 $\\operatorname{rank}(\\mathcal{R}_d)  n$，则确定在均匀搜索网格内恢复满秩能达性所需的最小幅值扰动 $\\delta T$（单位：秒），并遵循以下规则：\n  1. 扰动在离散对称集 $\\{\\delta T = k \\Delta \\mid k \\in \\mathbb{Z}, 1 \\le |k| \\le K_{\\max} \\}$ 上搜索，步长 $\\Delta = 10^{-3}$ 秒，界限 $K_{\\max} = 1000$。\n  2. 遇到的第一个使 $\\operatorname{rank}(\\mathcal{R}_d(A_d(T+\\delta T), B_d(T+\\delta T))) = n$ 成立的最小非零幅值 $\\delta T$ 将被接受。如果 $\\pm k \\Delta$ 出现平局，选择负扰动（即，优先选择 $\\delta T = -k \\Delta$）。\n  3. 如果在搜索集内不存在这样的 $\\delta T$，或者如果连续时间系统对 $(A,B)$ 本身不是能达的（即 $\\operatorname{rank}([B, AB, \\dots, A^{n-1} B])  n$），则报告 $\\delta T = -1$（一个表示在给定约束下不可能实现的标志值）。\n\n所有时间必须以秒为单位。任何角度量（如果存在）均以弧度为单位。所有秩均为整数。扰动 $\\delta T$ 必须报告为四舍五入到六位小数的实数。\n\n使用以下测试套件。对于每个用例，使用给定的 $(A,B,C,T)$：\n- 用例 1: $n = 2$, $m = 1$, $p = 1$, $A = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 1  0 \\end{bmatrix}$, $T = 2\\pi$。\n- 用例 2: $n = 2$, $m = 1$, $p = 1$, $A = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 1  0 \\end{bmatrix}$, $T = \\pi$。\n- 用例 3: $n = 2$, $m = 1$, $p = 1$, $A = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 1  0 \\end{bmatrix}$, $T = 0.1$。\n- 用例 4: $n = 2$, $m = 1$, $p = 1$, $A = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, $C = \\begin{bmatrix} 0  1 \\end{bmatrix}$, $T = 0.3$。\n- 用例 5: $n = 3$, $m = 1$, $p = 1$, $A = \\begin{bmatrix} 0  1  0 \\\\ -4  0  0 \\\\ 0  0  -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 1  0  0 \\end{bmatrix}$, $T = \\pi$。\n\n您的程序必须输出一行，其中包含一个逗号分隔的扁平列表，按顺序汇总了所有用例的结果。对于每个用例，按顺序输出三个值：整数能达性秩 $\\operatorname{rank}(\\mathcal{R}_d)$、整数能观性秩 $\\operatorname{rank}(\\mathcal{O}_d)$ 和四舍五入到六位小数的扰动 $\\delta T$。例如，输出格式必须严格为\n$[r_{c,1},r_{o,1},\\delta T_1,r_{c,2},r_{o,2},\\delta T_2,\\dots,r_{c,5},r_{o,5},\\delta T_5]$，\n其中 $\\delta T_i$ 打印为六位小数（例如，$0.001000$），标志值在适用时打印为 $-1.000000$。", "solution": "首先，必须为给定的采样周期 $T$ 计算 ZOH 等效离散时间系统矩阵 $(A_d, B_d)$。一个稳健且标准的计算方法涉及一个增广分块矩阵的矩阵指数。定义矩阵 $M$ 如下：\n$$\nM = \\begin{bmatrix} A  B \\\\ \\mathbf{0}  \\mathbf{0} \\end{bmatrix} \\in \\mathbb{R}^{(n+m) \\times (n+m)}\n$$\n$M T$ 的指数在其上部分块中产生所需的离散时间矩阵：\n$$\ne^{M T} = \\exp\\left( \\begin{bmatrix} AT  BT \\\\ \\mathbf{0}  \\mathbf{0} \\end{bmatrix} \\right) = \\begin{bmatrix} e^{AT}  \\left(\\int_0^T e^{A\\sigma} d\\sigma\\right) B \\\\ \\mathbf{0}  I \\end{bmatrix} = \\begin{bmatrix} A_d  B_d \\\\ \\mathbf{0}  I \\end{bmatrix}\n$$\n数值库（例如，使用 Padé 逼近）可以高效地处理此计算。\n\n其次，利用离散时间系统对 $(A_d, B_d)$ 和矩阵 $C$，我们构建离散时间能达性矩阵 $\\mathcal{R}_d$ 和能观性矩阵 $\\mathcal{O}_d$。\n$$\n\\mathcal{R}_d = \\begin{bmatrix} B_d  A_d B_d  \\dots  A_d^{n-1} B_d \\end{bmatrix}\n$$\n$$\n\\mathcal{O}_d = \\begin{bmatrix} C \\\\ CA_d \\\\ \\vdots \\\\ CA_d^{n-1} \\end{bmatrix}\n$$\n这些矩阵的秩决定了系统的特性。秩定义为非零奇异值的数量，为了数值稳定性，最好通过 SVD 计算，并计算大于基于机器精度的容差的奇异值数量。\n\n第三，我们分析能达性并确定扰动 $\\delta T$。\n首先评估使用初始采样周期 $T$ 计算的 $\\mathcal{R}_d$ 的秩。如果此秩等于状态维度 $n$，则系统是能达的，所需扰动为 $\\delta T = 0$。\n\n如果秩小于 $n$，则发生了能达性丢失。这可能是因为原始连续时间系统本身是不能达的，也可能是采样过程的病态问题。我们首先通过计算连续时间能达性矩阵 $\\mathcal{R}_c$ 的秩来检查连续时间能达性：\n$$\n\\mathcal{R}_c = \\begin{bmatrix} B  AB  \\dots  A^{n-1}B \\end{bmatrix}\n$$\n如果 $\\operatorname{rank}(\\mathcal{R}_c)  n$，则该系统根本上是不能达的，改变采样周期也无法纠正。根据问题规则，我们报告 $\\delta T = -1$。\n\n如果 $\\operatorname{rank}(\\mathcal{R}_c) = n$ 但 $\\operatorname{rank}(\\mathcal{R}_d)  n$，则能达性的丢失是由于病态采样。这通常发生在采样周期 $T$ 与系统的固有频率（与 $A$ 的特征值的虚部相关）发生破坏性相互作用时。我们必须寻找一个最小的扰动 $\\delta T$ 来恢复能达性。搜索在离散网格上进行，对于从 $1$ 到 $K_{\\max} = 1000$ 的整数 $k$：\n1. 测试负扰动。令 $T_{\\text{new}} = T - k \\Delta$，其中 $\\Delta = 10^{-3}$。如果 $T_{\\text{new}}  0$，计算新的离散系统 $(A_d(T_{\\text{new}}), B_d(T_{\\text{new}}))$ 及其对应能达性矩阵的秩。如果秩为 $n$，则找到了最小扰动：$\\delta T = -k \\Delta$。搜索终止。\n2. 如果未测试负扰动或测试失败，则测试正扰动。令 $T_{\\text{new}} = T + k \\Delta$。计算新的离散系统及其能达性秩。如果秩为 $n$，则找到了最小扰动：$\\delta T = +k \\Delta$。搜索终止。\n此搜索顺序内在地满足了优先选择负扰动的平局打破规则。如果循环完成而没有找到合适的扰动，则在给定的约束条件下不存在解决方案，我们报告 $\\delta T = -1$。\n\n整个过程封装在一个程序中，并应用于每个指定的测试用例，以生成所需的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef compute_rank(matrix):\n    \"\"\"\n    Computes the rank of a matrix using SVD-based method from numpy.\n    This method is numerically stable and uses a tolerance based on machine precision.\n    \"\"\"\n    if matrix.size == 0:\n        return 0\n    return np.linalg.matrix_rank(matrix)\n\ndef get_discrete_system(A, B, T):\n    \"\"\"\n    Computes the ZOH-equivalent discrete-time system (Ad, Bd) for a given\n    continuous-time system (A, B) and sampling period T.\n    \"\"\"\n    n = A.shape[0]\n    m = B.shape[1]\n\n    # Handle invalid sampling period\n    if T = 0:\n        raise ValueError(\"Sampling period T must be positive.\")\n\n    # Augmented matrix method\n    M = np.zeros((n + m, n + m))\n    M[:n, :n] = A\n    M[:n, n:] = B\n    \n    phi = expm(M * T)\n    \n    Ad = phi[:n, :n]\n    Bd = phi[:n, n:]\n    \n    return Ad, Bd\n\ndef get_reachability_matrix(A_mat, B_mat, n):\n    \"\"\"\n    Constructs the reachability matrix R = [B, AB, A^2B, ..., A^(n-1)B].\n    \"\"\"\n    if B_mat.size == 0:\n        return np.zeros((n, 0))\n    m = B_mat.shape[1]\n    R_d = np.zeros((n, n * m))\n    \n    current_power_B = B_mat\n    R_d[:, 0:m] = current_power_B\n    \n    for i in range(1, n):\n        current_power_B = A_mat @ current_power_B\n        R_d[:, i * m:(i + 1) * m] = current_power_B\n        \n    return R_d\n\ndef get_observability_matrix(A_mat, C_mat, n):\n    \"\"\"\n    Constructs the observability matrix O = [C^T, (CA)^T, ..., (CA^(n-1))^T]^T.\n    \"\"\"\n    p = C_mat.shape[0]\n    O_d = np.zeros((n * p, n))\n    \n    current_power_C = C_mat\n    O_d[0:p, :] = current_power_C\n    \n    for i in range(1, n):\n        current_power_C = current_power_C @ A_mat\n        O_d[i * p:(i + 1) * p, :] = current_power_C\n        \n    return O_d\n\ndef process_case(A, B, C, T):\n    \"\"\"\n    Analyzes a single test case according to the problem description.\n    \"\"\"\n    A = np.array(A, dtype=float)\n    B = np.array(B, dtype=float)\n    C = np.array(C, dtype=float)\n    \n    n = A.shape[0]\n    \n    # 1. Compute discrete system and initial ranks\n    Ad, Bd = get_discrete_system(A, B, T)\n    \n    R_d = get_reachability_matrix(Ad, Bd, n)\n    O_d = get_observability_matrix(Ad, C, n)\n    \n    rank_r_d = compute_rank(R_d)\n    rank_o_d = compute_rank(O_d)\n    \n    # 2. Determine delta_T\n    delta_T = 0.0\n    \n    if rank_r_d  n:\n        # Check continuous-time reachability\n        R_c = get_reachability_matrix(A, B, n)\n        if compute_rank(R_c)  n:\n            delta_T = -1.0\n        else:\n            # Search for a perturbation\n            delta_T = -1.0  # Default to sentinel if not found\n            DELTA = 1e-3\n            K_MAX = 1000\n            \n            found = False\n            for k in range(1, K_MAX + 1):\n                # Try negative perturbation first\n                T_neg = T - k * DELTA\n                if T_neg  0:\n                    Ad_neg, Bd_neg = get_discrete_system(A, B, T_neg)\n                    R_d_neg = get_reachability_matrix(Ad_neg, Bd_neg, n)\n                    if compute_rank(R_d_neg) == n:\n                        delta_T = -k * DELTA\n                        found = True\n                        break\n                \n                # Try positive perturbation\n                T_pos = T + k * DELTA\n                Ad_pos, Bd_pos = get_discrete_system(A, B, T_pos)\n                R_d_pos = get_reachability_matrix(Ad_pos, Bd_pos, n)\n                if compute_rank(R_d_pos) == n:\n                    delta_T = k * DELTA\n                    found = True\n                    break\n            \n    return rank_r_d, rank_o_d, delta_T\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": [[0, 1], [-1, 0]], \"B\": [[0], [1]], \n            \"C\": [[1, 0]], \"T\": 2 * np.pi\n        },\n        {\n            \"A\": [[0, 1], [-1, 0]], \"B\": [[0], [1]], \n            \"C\": [[1, 0]], \"T\": np.pi\n        },\n        {\n            \"A\": [[0, 1], [0, 0]], \"B\": [[0], [1]], \n            \"C\": [[1, 0]], \"T\": 0.1\n        },\n        {\n            \"A\": [[0, 0], [0, 0]], \"B\": [[1], [0]], \n            \"C\": [[0, 1]], \"T\": 0.3\n        },\n        {\n            \"A\": [[0, 1, 0], [-4, 0, 0], [0, 0, -1]], \"B\": [[0], [1], [1]],\n            \"C\": [[1, 0, 0]], \"T\": np.pi\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r_c, r_o, dt = process_case(case[\"A\"], case[\"B\"], case[\"C\"], case[\"T\"])\n        results.extend([r_c, r_o, f\"{dt:.6f}\"])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2743060"}]}