{"hands_on_practices": [{"introduction": "无迹卡尔曼滤波器 (UKF) 的核心在于其独特的无迹变换 (Unscented Transform, UT) 方法。本练习将引导您亲手完成一个非线性系统的测量更新步骤，这是一个具体细致的计算过程。通过本练习，您将清晰地了解如何生成西格玛点 (sigma points)、如何通过非线性函数传播这些点，以及如何重新组合它们来更新状态协方差，从而为深入理解滤波器的工作机制打下坚实的基础。[@problem_id:691357]", "problem": "一个无迹卡尔曼滤波器（UKF）正被用于估计一个二维动态系统的状态。UKF是一种强大的贝叶斯滤波技术，它通过一组被称为sigma点的确定性采样点来近似一个概率分布。与扩展卡尔曼滤波器等基于线性化的方法相比，这些点在通过非线性函数传播后，可以为得到的均值和协方差提供更准确的估计。\n\n在离散时间步 $k$，系统状态由向量 $x_k = [x_{1,k}, x_{2,k}]^\\top$ 表示。该滤波器已经完成了其预测步骤，得到了先验（预测）状态估计 $\\hat{x}_{k|k-1}$ 及其对应的误差协方差矩阵 $P_{k|k-1}$。该先验分布假设为高斯分布，即 $x_k \\sim \\mathcal{N}(\\hat{x}_{k|k-1}, P_{k|k-1})$。\n\n给定以下信息：\n1.  先验状态估计为 $\\hat{x}_{k|k-1} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n2.  先验误差协方差是一个对角矩阵 $P_{k|k-1} = \\begin{pmatrix} \\sigma_1^2 & 0 \\\\ 0 & \\sigma_2^2 \\end{pmatrix}$。\n3.  从传感器获得一个标量测量值 $z_k$。测量模型是非线性的，由以下公式给出：\n    $$z_k = h(x_k) + v_k$$\n    其中函数 $h: \\mathbb{R}^2 \\to \\mathbb{R}$ 为 $h(x_k) = x_{1,k} + \\gamma x_{2,k}^2$，而 $v_k$ 是一个零均值高斯测量噪声，其方差为 $R$，即 $v_k \\sim \\mathcal{N}(0, R)$。\n4.  UKF使用一组标准参数来生成sigma点：状态维度 $n=2$，主缩放参数 $\\alpha_{ukf}=1$，用于整合分布先验知识的参数 $\\beta=2$（对高斯分布为最优），以及次级缩放参数 $\\kappa=1$。\n\nsigma点的选择遵循标准算法。对于状态维度 $n$，定义一个复合缩放参数 $\\lambda$ 为 $\\lambda = \\alpha_{ukf}^2(n+\\kappa) - n$。这 $2n+1$ 个sigma点 $\\mathcal{X}_i$ 及其用于均值 ($W_i^{(m)}$) 和协方差 ($W_i^{(c)}$) 的相应权重由以下公式给出：\n-   $\\mathcal{X}_0 = \\hat{x}$\n-   $\\mathcal{X}_i = \\hat{x} + (\\sqrt{(n+\\lambda)P})_i, \\quad i=1, \\dots, n$\n-   $\\mathcal{X}_{i+n} = \\hat{x} - (\\sqrt{(n+\\lambda)P})_i, \\quad i=1, \\dots, n$\n其中 $(\\sqrt{M})_i$ 是矩阵 $M$ 的矩阵平方根的第 $i$ 列。\n-   $W_0^{(m)} = \\frac{\\lambda}{n+\\lambda}$\n-   $W_0^{(c)} = \\frac{\\lambda}{n+\\lambda} + (1 - \\alpha_{ukf}^2 + \\beta)$\n-   $W_i^{(m)} = W_i^{(c)} = \\frac{1}{2(n+\\lambda)}, \\quad i=1, \\dots, 2n$\n\n你的任务是执行UKF的测量更新步骤，以计算后验（更新后）状态协方差矩阵 $P_{k|k}$。\n\n**问题：**\n计算后验状态协方差矩阵的左上角元素 $(P_{k|k})_{11}$。", "solution": "以下是详细的计算步骤：\n\n1.  **计算参数和权重**\n    -   给定参数 $n=2$, $\\alpha_{ukf}=1$, $\\beta=2$, $\\kappa=1$。\n    -   复合缩放参数：$\\lambda = \\alpha_{ukf}^2(n+\\kappa) - n = 1^2(2+1) - 2 = 1$。\n    -   因此，$n+\\lambda=3$。\n    -   计算权重：\n        -   $W_0^{(m)} = \\frac{\\lambda}{n+\\lambda} = \\frac{1}{3}$\n        -   $W_0^{(c)} = \\frac{\\lambda}{n+\\lambda} + (1 - \\alpha_{ukf}^2 + \\beta) = \\frac{1}{3} + (1 - 1^2 + 2) = \\frac{7}{3}$\n        -   $W_i^{(m)} = W_i^{(c)} = \\frac{1}{2(n+\\lambda)} = \\frac{1}{6}$ (对于 $i=1, \\dots, 4$)\n\n2.  **生成Sigma点**\n    -   先验均值 $\\hat{x}_{k|k-1} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n    -   先验协方差 $P_{k|k-1} = \\begin{pmatrix} \\sigma_1^2 & 0 \\\\ 0 & \\sigma_2^2 \\end{pmatrix}$。\n    -   计算矩阵平方根的列向量：$\\sqrt{(n+\\lambda)P_{k|k-1}} = \\sqrt{3P_{k|k-1}} = \\begin{pmatrix} \\sqrt{3}\\sigma_1 & 0 \\\\ 0 & \\sqrt{3}\\sigma_2 \\end{pmatrix}$。\n    -   Sigma点 $\\mathcal{X}_i$ 如下：\n        -   $\\mathcal{X}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$\n        -   $\\mathcal{X}_1 = \\hat{x} + \\begin{pmatrix} \\sqrt{3}\\sigma_1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\sqrt{3}\\sigma_1 \\\\ 0 \\end{pmatrix}$\n        -   $\\mathcal{X}_2 = \\hat{x} + \\begin{pmatrix} 0 \\\\ \\sqrt{3}\\sigma_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\sqrt{3}\\sigma_2 \\end{pmatrix}$\n        -   $\\mathcal{X}_3 = \\hat{x} - \\begin{pmatrix} \\sqrt{3}\\sigma_1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\sqrt{3}\\sigma_1 \\\\ 0 \\end{pmatrix}$\n        -   $\\mathcal{X}_4 = \\hat{x} - \\begin{pmatrix} 0 \\\\ \\sqrt{3}\\sigma_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ -\\sqrt{3}\\sigma_2 \\end{pmatrix}$\n\n3.  **通过测量函数传播Sigma点**\n    -   测量函数为 $h(x) = x_1 + \\gamma x_2^2$。\n    -   传播后的点 $\\mathcal{Z}_i = h(\\mathcal{X}_i)$：\n        -   $\\mathcal{Z}_0 = 0 + \\gamma(0)^2 = 0$\n        -   $\\mathcal{Z}_1 = \\sqrt{3}\\sigma_1 + \\gamma(0)^2 = \\sqrt{3}\\sigma_1$\n        -   $\\mathcal{Z}_2 = 0 + \\gamma(\\sqrt{3}\\sigma_2)^2 = 3\\gamma\\sigma_2^2$\n        -   $\\mathcal{Z}_3 = -\\sqrt{3}\\sigma_1 + \\gamma(0)^2 = -\\sqrt{3}\\sigma_1$\n        -   $\\mathcal{Z}_4 = 0 + \\gamma(-\\sqrt{3}\\sigma_2)^2 = 3\\gamma\\sigma_2^2$\n\n4.  **计算预测测量值和协方差**\n    -   预测测量均值 $\\hat{z}_{k|k-1} = \\sum_{i=0}^{4} W_i^{(m)}\\mathcal{Z}_i = \\frac{1}{3}(0) + \\frac{1}{6}(\\sqrt{3}\\sigma_1) + \\frac{1}{6}(3\\gamma\\sigma_2^2) + \\frac{1}{6}(-\\sqrt{3}\\sigma_1) + \\frac{1}{6}(3\\gamma\\sigma_2^2) = \\gamma\\sigma_2^2$。\n    -   新息协方差 $S_k = \\sum_{i=0}^{4} W_i^{(c)}(\\mathcal{Z}_i - \\hat{z}_{k|k-1})^2 + R$。\n        $S_k = \\frac{7}{3}(0-\\gamma\\sigma_2^2)^2 + \\frac{1}{6}[(\\sqrt{3}\\sigma_1-\\gamma\\sigma_2^2)^2 + (-\\sqrt{3}\\sigma_1-\\gamma\\sigma_2^2)^2] + \\frac{2}{6}(3\\gamma\\sigma_2^2-\\gamma\\sigma_2^2)^2 + R$\n        $S_k = \\frac{7}{3}\\gamma^2\\sigma_2^4 + \\frac{1}{6}[2(3\\sigma_1^2 + (\\gamma\\sigma_2^2)^2)] + \\frac{1}{3}(2\\gamma\\sigma_2^2)^2 + R$\n        $S_k = \\frac{7}{3}\\gamma^2\\sigma_2^4 + \\sigma_1^2 + \\frac{1}{3}\\gamma^2\\sigma_2^4 + \\frac{4}{3}\\gamma^2\\sigma_2^4 + R = \\sigma_1^2 + 4\\gamma^2\\sigma_2^4 + R$。\n\n5.  **计算互协方差**\n    -   $P_{xz} = \\sum_{i=0}^{4} W_i^{(c)}(\\mathcal{X}_i - \\hat{x}_{k|k-1})(\\mathcal{Z}_i - \\hat{z}_{k|k-1})^\\top$。\n    -   由于 $\\hat{x}_{k|k-1}$ 为零向量，$\\mathcal{X}_i - \\hat{x}_{k|k-1} = \\mathcal{X}_i$。\n    -   $P_{xz} = \\frac{7}{3}\\mathcal{X}_0(\\dots)^\\top + \\frac{1}{6}\\mathcal{X}_1(\\mathcal{Z}_1 - \\hat{z})^\\top + \\frac{1}{6}\\mathcal{X}_2(\\mathcal{Z}_2 - \\hat{z})^\\top + \\frac{1}{6}\\mathcal{X}_3(\\mathcal{Z}_3 - \\hat{z})^\\top + \\frac{1}{6}\\mathcal{X}_4(\\mathcal{Z}_4 - \\hat{z})^\\top$。\n    -   第一分量 $(P_{xz})_1 = \\frac{1}{6}(\\sqrt{3}\\sigma_1)(\\sqrt{3}\\sigma_1 - \\gamma\\sigma_2^2) + \\frac{1}{6}(-\\sqrt{3}\\sigma_1)(-\\sqrt{3}\\sigma_1 - \\gamma\\sigma_2^2) = \\frac{1}{6}(3\\sigma_1^2 - \\dots + 3\\sigma_1^2 + \\dots) = \\sigma_1^2$。\n    -   第二分量 $(P_{xz})_2 = \\frac{1}{6}(0) + \\frac{1}{6}(\\sqrt{3}\\sigma_2)(2\\gamma\\sigma_2^2) + \\frac{1}{6}(0) + \\frac{1}{6}(-\\sqrt{3}\\sigma_2)(2\\gamma\\sigma_2^2) = 0$。\n    -   所以，$P_{xz} = \\begin{pmatrix} \\sigma_1^2 \\\\ 0 \\end{pmatrix}$。\n\n6.  **计算后验协方差**\n    -   卡尔曼增益 $K_k = P_{xz} S_k^{-1} = \\begin{pmatrix} \\sigma_1^2/S_k \\\\ 0 \\end{pmatrix}$。\n    -   后验协方差 $P_{k|k} = P_{k|k-1} - K_k S_k K_k^\\top = P_{k|k-1} - \\begin{pmatrix} \\sigma_1^2/S_k \\\\ 0 \\end{pmatrix} S_k \\begin{pmatrix} \\sigma_1^2/S_k & 0 \\end{pmatrix} = \\begin{pmatrix} \\sigma_1^2 & 0 \\\\ 0 & \\sigma_2^2 \\end{pmatrix} - \\begin{pmatrix} \\sigma_1^4/S_k & 0 \\\\ 0 & 0 \\end{pmatrix}$。\n    -   左上角元素 $(P_{k|k})_{11} = \\sigma_1^2 - \\frac{\\sigma_1^4}{S_k} = \\sigma_1^2 - \\frac{\\sigma_1^4}{\\sigma_1^2 + 4\\gamma^2\\sigma_2^4 + R}$。", "answer": "$$\\boxed{\\sigma_1^2-\\frac{\\sigma_1^4}{\\sigma_1^2+4\\gamma^2\\sigma_2^4+R}}$$", "id": "691357"}, {"introduction": "在掌握了 UKF 的运作方式后，理解其为何通常优于更简洁的扩展卡尔曼滤波器 (EKF) 至关重要。本练习要求您进行一项解析推导，以比较两种滤波器在预测均值时的偏差。这项分析将揭示 UKF 卓越的精度，展示它如何捕捉状态分布的更高阶矩，而这正是 EKF 的线性化方法所忽略的。[@problem_id:2886769]", "problem": "考虑一个标量、离散时间、非线性随机系统\n$$\nx_{k+1} \\;=\\; f(x_k) \\;+\\; w_k, \n\\qquad f(x) \\;=\\; x \\;+\\; \\frac{1}{2}\\sin(x),\n$$\n其非线性量测为\n$$\ny_k \\;=\\; h(x_k) \\;+\\; v_k, \n\\qquad h(x) \\;=\\; x^2,\n$$\n其中 $w_k$ 和 $v_k$ 是相互独立、零均值的高斯随机变量，且独立于 $x_k$。假设以过去的数据为条件，$x_k$ 的先验分布为高斯分布，\n$$\nx_k \\mid \\mathcal{Y}_{k-1} \\;\\sim\\; \\mathcal{N}(\\mu, P),\n$$\n其方差 $P>0$ 很小。定义真实的一步预测状态均值和真实的预测量测均值为\n$$\n\\bar{x}_{k+1}^{\\mathrm{true}} \\;=\\; \\mathbb{E}\\!\\left[f(x_k)\\right], \n\\qquad \n\\bar{y}_k^{\\mathrm{true}} \\;=\\; \\mathbb{E}\\!\\left[h(x_k)\\right],\n$$\n其中期望是关于 $x_k$ 的高斯先验计算的。\n\n扩展卡尔曼滤波器 (EKF) 和无迹卡尔曼滤波器 (UKF) 的预测均值定义如下。对于 EKF，使用关于先验均值的一阶线性化，因此\n$$\n\\bar{x}_{k+1}^{\\mathrm{EKF}} \\;=\\; f(\\mu), \n\\qquad \n\\bar{y}_k^{\\mathrm{EKF}} \\;=\\; h(\\mu).\n$$\n对于 UKF，使用一维 ($n=1$) 标准无迹变换 (UT)，其缩放参数为 $\\alpha>0$，次级缩放参数为 $\\kappa \\in \\mathbb{R}$，并定义\n$$\n\\lambda \\;=\\; \\alpha^2 (n+\\kappa) \\;-\\; n \\;=\\; \\alpha^2(1+\\kappa)\\;-\\;1,\n\\quad\\text{假设 } 1+\\lambda>0.\n$$\n使用 sigma 点和均值权重\n$$\n\\chi_0 \\;=\\; \\mu, \n\\qquad \n\\chi_{\\pm} \\;=\\; \\mu \\,\\pm\\, \\sqrt{(1+\\lambda)\\,P},\n$$\n$$\nW_0^{(m)} \\;=\\; \\frac{\\lambda}{1+\\lambda}, \n\\qquad \nW_{+}^{(m)} \\;=\\; W_{-}^{(m)} \\;=\\; \\frac{1}{2(1+\\lambda)}.\n$$\n那么 UKF 的预测均值为\n$$\n\\bar{x}_{k+1}^{\\mathrm{UKF}} \\;=\\; \\sum_{i\\in\\{0,+,-\\}} W_i^{(m)}\\, f(\\chi_i),\n\\qquad\n\\bar{y}_k^{\\mathrm{UKF}} \\;=\\; \\sum_{i\\in\\{0,+,-\\}} W_i^{(m)}\\, h(\\chi_i).\n$$\n\n对于每个映射 $g \\in \\{f,h\\}$，将方法的预测偏差定义为该方法的预测均值与真实预测均值之差，\n$$\nb_g^{\\mathrm{method}} \\;=\\; \\bar{g}^{\\mathrm{method}} \\;-\\; \\bar{g}^{\\mathrm{true}}.\n$$\n计算四个偏差到小方差 $P$ 的第一个非零阶，\n$$\nb_f^{\\mathrm{EKF}},\\quad b_f^{\\mathrm{UKF}},\\quad b_h^{\\mathrm{EKF}},\\quad b_h^{\\mathrm{UKF}},\n$$\n以 $\\mu$、$P$ 和 $\\lambda$（如果存在）的显式解析表达式表示。将您的最终结果表示为单个 $1\\times 4$ 的行向量\n$$\n\\bigl[\\, b_f^{\\mathrm{EKF}} \\;\\; b_f^{\\mathrm{UKF}} \\;\\; b_h^{\\mathrm{EKF}} \\;\\; b_h^{\\mathrm{UKF}} \\,\\bigr].\n$$\n无需四舍五入，也无需单位。所有角度均以弧度表示。", "solution": "首先必须验证问题陈述的科学合理性、完整性和客观性。\n\n步骤 1：提取已知条件\n逐字给出的已知条件如下：\n- 状态模型：$x_{k+1} = f(x_k) + w_k$，其中 $f(x) = x + \\frac{1}{2}\\sin(x)$。\n- 量测模型：$y_k = h(x_k) + v_k$，其中 $h(x) = x^2$。\n- 噪声特性：$w_k$ 和 $v_k$ 是相互独立、零均值的高斯随机变量，且独立于 $x_k$。\n- 先验分布：$x_k \\mid \\mathcal{Y}_{k-1} \\sim \\mathcal{N}(\\mu, P)$，其方差 $P>0$ 很小。\n- 真实预测均值：$\\bar{x}_{k+1}^{\\mathrm{true}} = \\mathbb{E}[f(x_k)]$ 和 $\\bar{y}_k^{\\mathrm{true}} = \\mathbb{E}[h(x_k)]$，其中期望是关于 $x_k$ 的先验计算的。\n- EKF 预测均值：$\\bar{x}_{k+1}^{\\mathrm{EKF}} = f(\\mu)$ 和 $\\bar{y}_k^{\\mathrm{EKF}} = h(\\mu)$。\n- UKF 参数：维度 $n=1$，缩放参数 $\\alpha>0$，$\\kappa \\in \\mathbb{R}$，其中 $\\lambda = \\alpha^2(1+\\kappa)-1$ 且假设 $1+\\lambda>0$。\n- UKF sigma 点：$\\chi_0 = \\mu$，$\\chi_{\\pm} = \\mu \\pm \\sqrt{(1+\\lambda)P}$。\n- UKF 均值权重：$W_0^{(m)} = \\frac{\\lambda}{1+\\lambda}$，$W_{+}^{(m)} = W_{-}^{(m)} = \\frac{1}{2(1+\\lambda)}$。\n- UKF 预测均值：$\\bar{x}_{k+1}^{\\mathrm{UKF}} = \\sum_{i\\in\\{0,+,-\\}} W_i^{(m)} f(\\chi_i)$ 和 $\\bar{y}_k^{\\mathrm{UKF}} = \\sum_{i\\in\\{0,+,-\\}} W_i^{(m)} h(\\chi_i)$。\n- 偏差定义：对于通用函数 $g \\in \\{f,h\\}$，偏差为 $b_g^{\\mathrm{method}} = \\bar{g}^{\\mathrm{method}} - \\bar{g}^{\\mathrm{true}}$。\n- 目标：计算四个偏差 $b_f^{\\mathrm{EKF}}$、$b_f^{\\mathrm{UKF}}$、$b_h^{\\mathrm{EKF}}$ 和 $b_h^{\\mathrm{UKF}}$ 到小方差 $P$ 的第一个非零阶。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是非线性状态估计领域的标准分析。该问题是适定的 (well-posed)，提供了计算所需量值的所有必要定义和函数。小方差 $P$ 的假设证明了使用泰勒级数展开是合理的，这是完成此项任务的标准分析工具。该问题是客观的，所有术语都有数学定义。它没有内部矛盾、信息缺失或验证标准中列出的致命缺陷。\n\n步骤 3：结论与行动\n问题有效。将推导解答。\n\n问题的核心是计算和比较高斯随机变量的非线性函数的期望值的不同近似。令 $x_k$ 为一个服从分布 $\\mathcal{N}(\\mu, P)$ 的随机变量。令 $g(x_k)$ 为一个足够平滑的非线性函数。真实的均值预测为 $\\bar{g}^{\\mathrm{true}} = \\mathbb{E}[g(x_k)]$。我们通过将 $g(x_k)$ 在均值 $\\mu$ 附近进行泰勒级数展开来分析此问题：\n$$\ng(x_k) = g(\\mu) + g'(\\mu)(x_k-\\mu) + \\frac{g''(\\mu)}{2!}(x_k-\\mu)^2 + \\frac{g'''(\\mu)}{3!}(x_k-\\mu)^3 + \\frac{g^{(4)}(\\mu)}{4!}(x_k-\\mu)^4 + O\\bigl((x_k-\\mu)^5\\bigr)\n$$\n对 $x_k \\sim \\mathcal{N}(\\mu, P)$ 取期望，并使用高斯分布的中心矩，$\\mathbb{E}[(x_k-\\mu)] = 0$，$\\mathbb{E}[(x_k-\\mu)^2] = P$，$\\mathbb{E}[(x_k-\\mu)^3] = 0$ 和 $\\mathbb{E}[(x_k-\\mu)^4] = 3P^2$，我们得到：\n$$\n\\bar{g}^{\\mathrm{true}} = g(\\mu) + \\frac{g''(\\mu)}{2}P + \\frac{g^{(4)}(\\mu)}{24}(3P^2) + O(P^3) = g(\\mu) + \\frac{g''(\\mu)}{2}P + \\frac{g^{(4)}(\\mu)}{8}P^2 + O(P^3)\n$$\n该表达式提供了用于比较 EKF 和 UKF 近似的基准。\n\n首先，我们计算函数 $f(x) = x + \\frac{1}{2}\\sin(x)$ 和 $h(x) = x^2$ 所需的导数。\n对于 $f(x)$：\n$f'(x) = 1 + \\frac{1}{2}\\cos(x)$\n$f''(x) = -\\frac{1}{2}\\sin(x)$\n$f'''(x) = -\\frac{1}{2}\\cos(x)$\n$f^{(4)}(x) = \\frac{1}{2}\\sin(x)$\n\n对于 $h(x)$：\n$h'(x) = 2x$\n$h''(x) = 2$\n对于所有 $n \\geq 3$，$h^{(n)}(x) = 0$。\n\n现在我们计算这四个偏差。\n\n1. EKF 偏差：\nEKF 对均值的近似就是 $\\bar{g}^{\\mathrm{EKF}} = g(\\mu)$。偏差定义为 $b_g^{\\mathrm{EKF}} = \\bar{g}^{\\mathrm{EKF}} - \\bar{g}^{\\mathrm{true}}$。\n$$\nb_g^{\\mathrm{EKF}} = g(\\mu) - \\left( g(\\mu) + \\frac{g''(\\mu)}{2}P + O(P^2) \\right) = -\\frac{g''(\\mu)}{2}P + O(P^2)\n$$\n$P$ 的第一个非零阶是 $O(P)$。\n\n对于 $f(x)$，其中 $f''(\\mu) = -\\frac{1}{2}\\sin(\\mu)$：\n$$\nb_f^{\\mathrm{EKF}} = -\\frac{1}{2}\\left(-\\frac{1}{2}\\sin(\\mu)\\right)P = \\frac{1}{4}\\sin(\\mu)P\n$$\n\n对于 $h(x)$，其中 $h''(\\mu) = 2$：\n$$\nb_h^{\\mathrm{EKF}} = -\\frac{1}{2}(2)P = -P\n$$\n对于 $h(x)$，这个结果是精确的，因为所有更高阶的导数都为零，所以 $\\bar{h}^{\\mathrm{true}} = h(\\mu) + \\frac{h''(\\mu)}{2}P = \\mu^2 + P$。因此，$b_h^{\\mathrm{EKF}} = \\mu^2 - (\\mu^2 + P) = -P$。\n\n2. UKF 偏差：\nUKF 的预测均值是 $\\bar{g}^{\\mathrm{UKF}} = \\sum_i W_i^{(m)} g(\\chi_i)$。\n令 $\\Delta = \\sqrt{(1+\\lambda)P}$。sigma 点为 $\\chi_0 = \\mu$ 和 $\\chi_{\\pm} = \\mu \\pm \\Delta$。\n我们将 $g(\\chi_{\\pm})$ 在 $\\mu$ 附近展开：\n$$\ng(\\mu \\pm \\Delta) = g(\\mu) \\pm g'(\\mu)\\Delta + \\frac{g''(\\mu)}{2}\\Delta^2 \\pm \\frac{g'''(\\mu)}{6}\\Delta^3 + \\frac{g^{(4)}(\\mu)}{24}\\Delta^4 + O(\\Delta^5)\n$$\nUKF 均值为：\n$$\n\\bar{g}^{\\mathrm{UKF}} = W_0^{(m)}g(\\chi_0) + W_+^{(m)}g(\\chi_+) + W_-^{(m)}g(\\chi_-) = \\frac{\\lambda}{1+\\lambda}g(\\mu) + \\frac{1}{2(1+\\lambda)}\\left[ g(\\mu+\\Delta) + g(\\mu-\\Delta) \\right]\n$$\n使用泰勒展开式的和：$g(\\mu+\\Delta) + g(\\mu-\\Delta) = 2g(\\mu) + g''(\\mu)\\Delta^2 + \\frac{g^{(4)}(\\mu)}{12}\\Delta^4 + O(\\Delta^6)$。\n将此代入 UKF 均值表达式：\n$$\n\\bar{g}^{\\mathrm{UKF}} = \\frac{\\lambda}{1+\\lambda}g(\\mu) + \\frac{1}{2(1+\\lambda)}\\left[ 2g(\\mu) + g''(\\mu)\\Delta^2 + \\frac{g^{(4)}(\\mu)}{12}\\Delta^4 + O(\\Delta^6) \\right]\n$$\n$$\n= \\left(\\frac{\\lambda}{1+\\lambda} + \\frac{1}{1+\\lambda}\\right)g(\\mu) + \\frac{g''(\\mu)\\Delta^2}{2(1+\\lambda)} + \\frac{g^{(4)}(\\mu)\\Delta^4}{24(1+\\lambda)} + O(P^3)\n$$\n代入 $\\Delta^2 = (1+\\lambda)P$：\n$$\n\\bar{g}^{\\mathrm{UKF}} = g(\\mu) + \\frac{g''(\\mu)(1+\\lambda)P}{2(1+\\lambda)} + \\frac{g^{(4)}(\\mu)\\left((1+\\lambda)P\\right)^2}{24(1+\\lambda)} + O(P^3)\n$$\n$$\n= g(\\mu) + \\frac{g''(\\mu)}{2}P + \\frac{(1+\\lambda)g^{(4)}(\\mu)}{24}P^2 + O(P^3)\n$$\nUKF 偏差为 $b_g^{\\mathrm{UKF}} = \\bar{g}^{\\mathrm{UKF}} - \\bar{g}^{\\mathrm{true}}$：\n$$\nb_g^{\\mathrm{UKF}} = \\left( g(\\mu) + \\frac{g''(\\mu)}{2}P + \\frac{(1+\\lambda)g^{(4)}(\\mu)}{24}P^2 \\right) - \\left( g(\\mu) + \\frac{g''(\\mu)}{2}P + \\frac{g^{(4)}(\\mu)}{8}P^2 \\right) + O(P^3)\n$$\n$$\n= \\left( \\frac{1+\\lambda}{24} - \\frac{3}{24} \\right)g^{(4)}(\\mu)P^2 + O(P^3) = \\frac{\\lambda-2}{24}g^{(4)}(\\mu)P^2 + O(P^3)\n$$\n$P$ 的第一个非零阶是 $O(P^2)$。\n\n对于 $f(x)$，其中 $f^{(4)}(\\mu) = \\frac{1}{2}\\sin(\\mu)$：\n$$\nb_f^{\\mathrm{UKF}} = \\frac{\\lambda-2}{24}\\left(\\frac{1}{2}\\sin(\\mu)\\right)P^2 = \\frac{\\lambda-2}{48}\\sin(\\mu)P^2\n$$\n\n对于 $h(x)$，其中 $h^{(4)}(\\mu) = 0$：\n$$\nb_h^{\\mathrm{UKF}} = \\frac{\\lambda-2}{24}(0)P^2 = 0\n$$\n这个结果是精确的。无迹变换为任何二次函数提供精确的均值，因为 sigma 点足以精确地捕捉二阶矩。\n对于 $h(x)=x^2$ 的直接验证：$\\bar{y}_k^{\\mathrm{UKF}} = \\mu^2 + P$。真实均值为 $\\bar{y}_k^{\\mathrm{true}} = \\mathbb{E}[x_k^2] = (\\mathbb{E}[x_k])^2 + \\text{Var}(x_k) = \\mu^2+P$。因此，$b_h^{\\mathrm{UKF}} = (\\mu^2+P) - (\\mu^2+P) = 0$。\n\n偏差到第一个非零阶的总结：\n- $b_f^{\\mathrm{EKF}} = \\frac{1}{4}\\sin(\\mu)P$\n- $b_f^{\\mathrm{UKF}} = \\frac{\\lambda-2}{48}\\sin(\\mu)P^2$\n- $b_h^{\\mathrm{EKF}} = -P$\n- $b_h^{\\mathrm{UKF}} = 0$\n\n最终结果以一个 $1\\times 4$ 的行向量报告。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{4}P\\sin(\\mu) & \\frac{(\\lambda-2)}{48}P^2\\sin(\\mu) & -P & 0 \\end{pmatrix}}\n$$", "id": "2886769"}, {"introduction": "最后的这项实践将所有知识点融会贯通于一个全面的仿真任务中。您将完整地实现一个 UKF，用于追踪非线性摆锤这一控制理论中的经典模型的状态。更重要的是，您将学会使用标准的一致性度量，如归一化新息平方 (Normalized Innovation Squared, NIS) 和归一化估计误差平方 (Normalized Estimation Error Squared, NEES)，来评估滤波器的性能，这些都是任何实际应用中不可或缺的技能。[@problem_id:2756735]", "problem": "考虑一个平面摆的离散时间非线性状态估计问题，其状态向量为 $x_k = [\\theta_k,\\ \\omega_k]^\\top$，其中 $\\theta_k$ 是角位移，$\\omega_k$ 是在离散时间 $k$ 的角速度。连续时间动力学在一个采样间隔 $\\Delta t$ 内通过前向欧拉法进行近似，得到离散时间过程模型\n$$\n\\begin{aligned}\n\\theta_{k+1} &= \\theta_k + \\Delta t\\, \\omega_k,\\\\\n\\omega_{k+1} &= \\omega_k + \\Delta t\\left(-\\frac{g}{L}\\sin(\\theta_k)\\right) + w_k,\n\\end{aligned}\n$$\n以及测量模型\n$$\nz_k = \\sin(\\theta_k) + v_k.\n$$\n此处，$g$ 为重力加速度，$L$ 为摆长，$w_k$ 是施加于角速度通道的标量过程噪声，$v_k$ 是标量测量噪声。所有角度都必须以弧度为单位处理。必须使用无迹卡尔曼滤波器（UKF）根据测量值 $z_k$ 来估计状态 $x_k$。\n\n您必须从贝叶斯滤波递归和针对高斯先验的无迹变换定义开始实现 UKF，使用由参数 $\\alpha$、$\\beta$ 和 $\\kappa$ 决定的 sigma 点和权重。不得假定任何线性化；您必须将 sigma 点通过非线性过程和测量映射进行传播。过程噪声协方差为 $Q = \\operatorname{diag}(0,\\ q)$，其中 $q$ 是仅应用于 $\\omega$ 通道的标量方差，测量噪声方差为 $R = r$。UKF 必须使用加性噪声形式。\n\n为了在没有随机采样的情况下进行确定性和可复现的测试，必须使用以下确定性“噪声”序列来生成真实轨迹和测量值，您必须将这些序列视为作用于系统的实际扰动：\n- 对于每个步骤 $k \\in \\{1,2,\\dots,T\\}$，定义\n$$\nw_k = \\sqrt{q}\\, \\frac{1}{2}\\left(\\sin(k) + \\cos(2k)\\right), \\quad v_k = \\sqrt{r}\\, \\frac{1}{2}\\left(\\sin(0.3k) - \\cos(0.7k)\\right).\n$$\n- 真实状态的传播方式如下\n$$\n\\begin{aligned}\n\\theta_{k} &= \\theta_{k-1} + \\Delta t\\, \\omega_{k-1},\\\\\n\\omega_{k} &= \\omega_{k-1} + \\Delta t\\left(-\\frac{g}{L}\\sin(\\theta_{k-1})\\right) + w_k,\n\\end{aligned}\n$$\n初始条件为 $x_0 = [\\theta_0,\\ \\omega_0]^\\top$。\n- 测量值为\n$$\nz_k = \\sin(\\theta_k) + v_k.\n$$\n\n在每个步骤 $k$，令 $\\hat{x}_{k|k-1}$ 和 $P_{k|k-1}$ 表示预测状态均值和协方差，$\\hat{z}_{k|k-1}$ 和 $S_k$ 表示预测测量均值和新息协方差，并令新息（也称为残差）为\n$$\n\\nu_k = z_k - \\hat{z}_{k|k-1}.\n$$\n令 $\\hat{x}_{k|k}$ 和 $P_{k|k}$ 表示在融合 $z_k$ 后的后验状态均值和协方差。将步骤 $k$ 的归一化新息平方（NIS）和归一化估计误差平方（NEES）定义为\n$$\n\\operatorname{NIS}_k = \\nu_k^\\top S_k^{-1} \\nu_k, \\qquad \\operatorname{NEES}_k = e_k^\\top P_{k|k}^{-1} e_k,\n$$\n其中 $e_k = x_k - \\hat{x}_{k|k}$ 是相对于真实值 $x_k$ 的估计误差。对于标量测量，白化新息定义为\n$$\n\\tilde{\\nu}_k = \\frac{\\nu_k}{\\sqrt{S_k}}.\n$$\n给定一个序列 $\\{\\tilde{\\nu}_k\\}_{k=1}^T$，定义样本均值\n$$\n\\bar{\\nu} = \\frac{1}{T} \\sum_{k=1}^T \\tilde{\\nu}_k,\n$$\n以及对于每个延迟 $\\ell \\in \\{1,2,3\\}$，定义样本自相关系数\n$$\n\\rho(\\ell) = \\frac{\\sum_{k=\\ell+1}^{T} (\\tilde{\\nu}_k - \\bar{\\nu})(\\tilde{\\nu}_{k-\\ell} - \\bar{\\nu})}{\\sum_{k=1}^{T} (\\tilde{\\nu}_k - \\bar{\\nu})^2}.\n$$\n您的程序必须：\n- 为状态维度 $n = 2$ 和标量测量实现无迹卡尔曼滤波器（UKF），使用从 $(\\alpha,\\ \\beta,\\ \\kappa)$ 导出的 sigma 点和权重。\n- 使用上述公式模拟确定性的真实轨迹和测量值。\n- 计算序列 $\\{\\operatorname{NIS}_k\\}_{k=1}^T$、$\\{\\tilde{\\nu}_k\\}_{k=1}^T$ 和 $\\{\\operatorname{NEES}_k\\}_{k=1}^T$。\n- 为每个测试用例报告：\n  1. $\\operatorname{NIS}_k$ 的时间平均值，即 $\\frac{1}{T}\\sum_{k=1}^T \\operatorname{NIS}_k$。\n  2. 在延迟 $\\ell \\in \\{1,2,3\\}$ 上的最大绝对样本自相关，即 $\\max_{\\ell \\in \\{1,2,3\\}} |\\rho(\\ell)|$。\n  3. $\\operatorname{NEES}_k$ 的时间平均值，即 $\\frac{1}{T}\\sum_{k=1}^T \\operatorname{NEES}_k$。\n\n所有角度都必须以弧度为单位处理。物理常数为 $g = 9.81$ ($\\mathrm{m/s^2}$) 和 $L = 1.0$ ($\\mathrm{m}$)。时间单位为秒（$\\mathrm{s}$）。输出为无量纲实数，必须报告为四舍五入到六位小数的浮点数。输出中不需要其他单位。\n\n测试套件。您的程序必须运行以下三个测试用例，并按指定顺序汇总其结果。对于每个用例，请使用给定的参数和初始条件：\n- 用例 A (标称):\n  - $\\Delta t = 0.05$,\n  - $T = 60$,\n  - $q = (0.05)^2$,\n  - $r = (0.05)^2$,\n  - $x_0 = [0.3,\\ 0.0]^\\top$,\n  - $P_0 = \\operatorname{diag}((0.1)^2,\\ (0.1)^2)$,\n  - $\\alpha = 0.8$, $\\beta = 2.0$, $\\kappa = 0.0$。\n- 用例 B (低噪声，快速采样):\n  - $\\Delta t = 0.02$,\n  - $T = 80$,\n  - $q = (0.01)^2$,\n  - $r = (0.001)^2$,\n  - $x_0 = [0.25,\\ 0.05]^\\top$,\n  - $P_0 = \\operatorname{diag}((0.05)^2,\\ (0.05)^2)$,\n  - $\\alpha = 0.7$, $\\beta = 2.0$, $\\kappa = 0.0$。\n- 用例 C (高噪声，较慢采样):\n  - $\\Delta t = 0.10$,\n  - $T = 50$,\n  - $q = (0.10)^2$,\n  - $r = (0.20)^2$,\n  - $x_0 = [0.4,\\ -0.1]^\\top$,\n  - $P_0 = \\operatorname{diag}((0.2)^2,\\ (0.2)^2)$,\n  - $\\alpha = 0.5$, $\\beta = 2.0$, $\\kappa = 0.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含九个结果（每个用例三个，按上述顺序列出），形式为用方括号括起来的逗号分隔列表。每个浮点数必须四舍五入到六位小数。输出顺序为：\n$$\n[\\overline{\\operatorname{NIS}}_{\\mathrm{A}},\\ \\max_{\\ell \\in \\{1,2,3\\}}|\\rho_{\\mathrm{A}}(\\ell)|,\\ \\overline{\\operatorname{NEES}}_{\\mathrm{A}},\\ \\overline{\\operatorname{NIS}}_{\\mathrm{B}},\\ \\max_{\\ell \\in \\{1,2,3\\}}|\\rho_{\\mathrm{B}}(\\ell)|,\\ \\overline{\\operatorname{NEES}}_{\\mathrm{B}},\\ \\overline{\\operatorname{NIS}}_{\\mathrm{C}},\\ \\max_{\\ell \\in \\{1,2,3\\}}|\\rho_{\\mathrm{C}}(\\ell)|,\\ \\overline{\\operatorname{NEES}}_{\\mathrm{C}}].\n$$\n例如，一个语法正确的输出看起来像 $[1.234567,0.012345,1.987654, \\dots]$。", "solution": "所提出的问题是针对离散时间动态系统的非线性状态估计的一个标准练习。该系统是一个平面摆，其动力学由一组非线性常微分方程描述，并使用前向欧拉近似进行离散化。任务是从带有噪声的标量测量值 $z_k = \\sin(\\theta_k)$ 中估计包含角位置和角速度的状态向量 $x_k = [\\theta_k, \\omega_k]^\\top$。为此，指定了使用无迹卡尔曼滤波器（UKF）。\n\n该问题定义明确且科学上合理，为确定性和可复现的仿真提供了所有必要的模型、参数和初始条件。它通过对过程和测量噪声使用确定性序列，正确地构建了一个基准场景，这允许对所实现的滤波器进行客观的性能评估。所要求的分析，涉及计算归一化新息平方（NIS）、归一化估计误差平方（NEES）和新息自相关，构成了对卡尔曼滤波器实现的标准一致性和性能检查。\n\n解决方案首先详细介绍无迹卡尔曼滤波器的原理，然后将该算法应用于特定的摆系统，最后使用指定的指标评估其性能。\n\n**1. 无迹卡尔曼滤波器（UKF）原理**\n\nUKF 解决了通过非线性变换传播概率分布的难题。与对系统动力学和测量模型进行线性化的扩展卡尔曼滤波器（EKF）不同，UKF 采用一种称为无迹变换的确定性采样技术。其核心思想是，近似一个概率分布比近似一个任意的非线性函数更容易。\n\n无迹变换通过从状态分布中生成一组最小的采样点（称为 sigma 点）来运作。这些 sigma 点是确定性选择的，以捕捉分布的均值和协方差。当通过真实的非线性函数传播时，只要先验分布是高斯分布，它们就能为任何非线性问题准确地捕捉后验均值和协方差，精度达到三阶。对于非高斯先验，精度至少达到二阶。\n\n**2. Sigma 点生成**\n\n对于维度为 $n$ 的状态向量，从给定的均值 $\\hat{x}$ 和协方差 $P$ 生成一组 $2n+1$ 个 sigma 点 $\\mathcal{X}$ 以及相应的权重 $(W_m, W_c)$。生成过程取决于参数 $\\alpha$、$\\beta$ 和 $\\kappa$。\n\n- 状态维度为 $n=2$。\n- 定义一个复合缩放参数 $\\lambda$ 为 $\\lambda = \\alpha^2(n+\\kappa) - n$。\n- 用于计算均值（$W_m$）和协方差（$W_c$）的权重为：\n$$\n\\begin{aligned}\nW_m^{(0)} &= \\frac{\\lambda}{n+\\lambda} \\\\\nW_c^{(0)} &= \\frac{\\lambda}{n+\\lambda} + (1 - \\alpha^2 + \\beta) \\\\\nW_m^{(i)} &= W_c^{(i)} = \\frac{1}{2(n+\\lambda)}, \\quad \\text{for } i=1, \\dots, 2n\n\\end{aligned}\n$$\n- sigma 点 $\\mathcal{X}^{(i)}$ 的计算方法如下：\n$$\n\\begin{aligned}\n\\mathcal{X}^{(0)} &= \\hat{x} \\\\\n\\mathcal{X}^{(i)} &= \\hat{x} + \\left( \\sqrt{(n+\\lambda)P} \\right)_i, \\quad \\text{for } i=1, \\dots, n \\\\\n\\mathcal{X}^{(i+n)} &= \\hat{x} - \\left( \\sqrt{(n+\\lambda)P} \\right)_i, \\quad \\text{for } i=1, \\dots, n\n\\end{aligned}\n$$\n其中 $\\left( \\sqrt{(n+\\lambda)P} \\right)_i$ 是矩阵 $(n+\\lambda)P$ 的平方根的第 $i$ 列，通常通过 Cholesky 分解计算。\n\n**3. UKF 算法步骤**\n\n滤波器从初始估计 $\\hat{x}_{0|0}$ 及其协方差 $P_{0|0}$ 开始，对每个时间步 $k = 1, \\dots, T$ 迭代执行一个预测-更新周期。\n\n**预测步骤：**\n\n1.  **生成 Sigma 点：** 使用上一步的后验估计 $\\hat{x}_{k-1|k-1}$ 和协方差 $P_{k-1|k-1}$，计算 $2n+1$ 个 sigma 点 $\\{\\mathcal{X}_{k-1|k-1}^{(i)}\\}$。\n\n2.  **传播 Sigma 点：** 将每个 sigma 点通过非线性过程模型 $f(\\cdot)$ 传播，以获得一组预测的 sigma 点。过程模型指定为：\n    $$\n    f(x_k) = f([\\theta_k, \\omega_k]^\\top) = \\begin{bmatrix} \\theta_k + \\Delta t\\, \\omega_k \\\\ \\omega_k - \\Delta t \\frac{g}{L}\\sin(\\theta_k) \\end{bmatrix}\n    $$\n    因此，对于每个 $i=0, \\dots, 2n$：$\\mathcal{X}_{k|k-1}^{(i)} = f(\\mathcal{X}_{k-1|k-1}^{(i)})$。\n\n3.  **计算预测状态和协方差：** 使用权重 $W_m$ 和 $W_c$ 重新组合传播后的 sigma 点，以获得预测（先验）状态均值 $\\hat{x}_{k|k-1}$ 和协方差 $P_{k|k-1}$。\n    $$\n    \\hat{x}_{k|k-1} = \\sum_{i=0}^{2n} W_m^{(i)} \\mathcal{X}_{k|k-1}^{(i)}\n    $$\n    $$\n    P_{k|k-1} = \\sum_{i=0}^{2n} W_c^{(i)} (\\mathcal{X}_{k|k-1}^{(i)} - \\hat{x}_{k|k-1})(\\mathcal{X}_{k|k-1}^{(i)} - \\hat{x}_{k|k-1})^\\top + Q\n    $$\n    加上过程噪声协方差 $Q = \\operatorname{diag}(0, q)$，这反映了加性噪声的公式。\n\n**更新步骤：**\n\n1.  **变换预测的 Sigma 点：** 将预测的 sigma 点 $\\{\\mathcal{X}_{k|k-1}^{(i)}\\}$ 通过非线性测量模型 $h(\\cdot)$ 传播，以获得预测的测量点 $\\{\\mathcal{Z}_k^{(i)}\\}$。模型是 $h(x_k) = \\sin(\\theta_k)$。\n    $$\n    \\mathcal{Z}_k^{(i)} = h(\\mathcal{X}_{k|k-1}^{(i)}) = \\sin(\\mathcal{X}_{k|k-1}^{(i)}[0])\n    $$\n\n2.  **计算预测测量和新息协方差：** 重新组合测量点，以找到预测的测量均值 $\\hat{z}_{k|k-1}$ 和新息协方差 $S_k$。\n    $$\n    \\hat{z}_{k|k-1} = \\sum_{i=0}^{2n} W_m^{(i)} \\mathcal{Z}_k^{(i)}\n    $$\n    $$\n    S_k = \\sum_{i=0}^{2n} W_c^{(i)} (\\mathcal{Z}_k^{(i)} - \\hat{z}_{k|k-1})(\\mathcal{Z}_k^{(i)} - \\hat{z}_{k|k-1})^\\top + R\n    $$\n    加上测量噪声协方差 $R=r$。由于测量是标量，$S_k$ 也是标量。\n\n3.  **计算互协方差：** 计算状态和测量之间的互协方差。\n    $$\n    P_{xz, k} = \\sum_{i=0}^{2n} W_c^{(i)} (\\mathcal{X}_{k|k-1}^{(i)} - \\hat{x}_{k|k-1})(\\mathcal{Z}_k^{(i)} - \\hat{z}_{k|k-1})^\\top\n    $$\n    对于状态维度 $n=2$ 和标量测量，$P_{xz, k}$ 是一个 $2 \\times 1$ 的向量。\n\n4.  **计算卡尔曼增益：**\n    $$\n    K_k = P_{xz, k} S_k^{-1}\n    $$\n\n5.  **更新状态和协方差：** 使用实际测量值 $z_k$（来自真实轨迹仿真），计算新息 $\\nu_k = z_k - \\hat{z}_{k|k-1}$，并将状态估计和协方差更新为步骤 $k$ 的最终（后验）值。\n    $$\n    \\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_k \\nu_k\n    $$\n    $$\n    P_{k|k} = P_{k|k-1} - K_k S_k K_k^\\top\n    $$\n这些更新后的值 $\\hat{x}_{k|k}$ 和 $P_{k|k}$ 将作为时间 $k+1$ 预测步骤的输入。\n\n**4. 性能评估指标**\n\n-   **归一化新息平方 (NIS):** $\\operatorname{NIS}_k = \\nu_k^\\top S_k^{-1} \\nu_k$。对于一个一致的滤波器，NIS 值的序列应遵循自由度等于测量维度（此处为 $1$）的卡方分布。因此，NIS 的时间平均值应约等于 $1$。\n-   **归一化估计误差平方 (NEES):** $\\operatorname{NEES}_k = (x_k - \\hat{x}_{k|k})^\\top P_{k|k}^{-1} (x_k - \\hat{x}_{k|k})$。该指标将实际的估计误差平方与滤波器自身报告的后验协方差进行比较。对于一个一致的滤波器，NEES 序列应遵循自由度等于状态维度（此处为 $2$）的卡方分布。其时间平均值应约等于 $2$。\n-   **新息自相关：** 对于一个最优滤波器，当新息序列被“白化”为 $\\tilde{\\nu}_k = \\nu_k / \\sqrt{S_k}$ 后，应为一个零均值的白噪声过程。对于延迟 $\\ell > 0$，自相关函数 $\\rho(\\ell)$ 应接近于零。显著的相关性表明模型不匹配或滤波器非最优。\n\n现在，实现将继续为指定的测试用例执行此算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the UKF simulation for all test cases.\n    \"\"\"\n    # Physical and system constants\n    g = 9.81\n    L = 1.0\n    n = 2  # State dimension: [theta, omega]\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # Case A: nominal\n        {'name': 'A', 'dt': 0.05, 'T': 60, 'q': 0.05**2, 'r': 0.05**2,\n         'x0': np.array([[0.3], [0.0]]), 'P0': np.diag([0.1**2, 0.1**2]),\n         'alpha': 0.8, 'beta': 2.0, 'kappa': 0.0},\n        # Case B: low noise, fast sampling\n        {'name': 'B', 'dt': 0.02, 'T': 80, 'q': 0.01**2, 'r': 0.001**2,\n         'x0': np.array([[0.25], [0.05]]), 'P0': np.diag([0.05**2, 0.05**2]),\n         'alpha': 0.7, 'beta': 2.0, 'kappa': 0.0},\n        # Case C: high noise, slower sampling\n        {'name': 'C', 'dt': 0.10, 'T': 50, 'q': 0.10**2, 'r': 0.20**2,\n         'x0': np.array([[0.4], [-0.1]]), 'P0': np.diag([0.2**2, 0.2**2]),\n         'alpha': 0.5, 'beta': 2.0, 'kappa': 0.0},\n    ]\n\n    # Process models as functions\n    def f_process(x, dt):\n        theta, omega = x[0, 0], x[1, 0]\n        theta_next = theta + dt * omega\n        omega_next = omega + dt * (-g / L * np.sin(theta))\n        return np.array([[theta_next], [omega_next]])\n\n    def h_measure(x):\n        theta = x[0, 0]\n        return np.sin(theta)\n\n    def run_ukf_simulation(params):\n        \"\"\"\n        Runs the UKF simulation for a single test case.\n        \"\"\"\n        dt, T, q, r = params['dt'], params['T'], params['q'], params['r']\n        alpha, beta, kappa = params['alpha'], params['beta'], params['kappa']\n        x0, P0 = params['x0'], params['P0']\n        \n        Q = np.diag([0, q])\n        R_scalar = r\n\n        # --- UKF Weights and Parameters ---\n        lambda_param = alpha**2 * (n + kappa) - n\n        \n        W_m = np.full(2 * n + 1, 1 / (2 * (n + lambda_param)))\n        W_c = np.full(2 * n + 1, 1 / (2 * (n + lambda_param)))\n        \n        W_m[0] = lambda_param / (n + lambda_param)\n        W_c[0] = lambda_param / (n + lambda_param) + (1 - alpha**2 + beta)\n\n        # --- Initialization ---\n        x_est = x0.copy()  # Posterior estimate at k=0\n        P_est = P0.copy()  # Posterior covariance at k=0\n        x_true = x0.copy() # Ground truth at k=0\n\n        nis_history = []\n        nees_history = []\n        whitened_nu_history = []\n        \n        # --- Main Filter Loop ---\n        for k in range(1, T + 1):\n            # 1. Ground Truth Generation\n            w_k = np.sqrt(q) * 0.5 * (np.sin(k) + np.cos(2 * k))\n            v_k = np.sqrt(r) * 0.5 * (np.sin(0.3 * k) - np.cos(0.7 * k))\n            \n            x_true = f_process(x_true, dt) + np.array([[0], [w_k]])\n            z_k = h_measure(x_true) + v_k\n\n            # 2. UKF Prediction\n            # Generate sigma points from estimate at k-1\n            sqrt_P = np.linalg.cholesky((n + lambda_param) * P_est)\n            sigma_points = np.zeros((2 * n + 1, n, 1))\n            sigma_points[0] = x_est\n            for i in range(n):\n                sigma_points[i + 1]       = x_est + sqrt_P[:, i:i+1]\n                sigma_points[i + 1 + n] = x_est - sqrt_P[:, i:i+1]\n            \n            # Propagate sigma points through process model\n            propagated_sigma_points = np.array([f_process(sp, dt) for sp in sigma_points])\n\n            # Predicted state mean and covariance\n            x_pred = np.sum(W_m[:, np.newaxis, np.newaxis] * propagated_sigma_points, axis=0)\n            \n            P_pred = np.zeros((n, n))\n            for i in range(2 * n + 1):\n                diff = propagated_sigma_points[i] - x_pred\n                P_pred += W_c[i] * (diff @ diff.T)\n            P_pred += Q\n\n            # 3. UKF Update\n            # Transform sigma points through measurement model\n            measurement_sigma_points = np.array([h_measure(sp) for sp in propagated_sigma_points])\n            \n            # Predicted measurement mean\n            z_pred = np.sum(W_m * measurement_sigma_points)\n            \n            # Innovation covariance\n            S_k = np.sum(W_c * (measurement_sigma_points - z_pred)**2) + R_scalar\n            \n            # Cross-covariance\n            P_xz = np.zeros((n, 1))\n            for i in range(2 * n + 1):\n                diff_x = propagated_sigma_points[i] - x_pred\n                diff_z = measurement_sigma_points[i] - z_pred\n                P_xz += W_c[i] * diff_x * diff_z\n                \n            # Kalman Gain\n            K_k = P_xz / S_k\n            \n            # Innovation\n            nu_k = z_k - z_pred\n            \n            # Update state estimate and covariance\n            x_est = x_pred + K_k * nu_k\n            P_est = P_pred - K_k * S_k * K_k.T\n            \n            # 4. Metrics Calculation\n            nis_k = nu_k**2 / S_k\n            nis_history.append(nis_k)\n\n            whitened_nu_k = nu_k / np.sqrt(S_k)\n            whitened_nu_history.append(whitened_nu_k)\n            \n            error = x_true - x_est\n            # Ensure P_est is well-conditioned before inverting\n            try:\n                P_inv = np.linalg.inv(P_est)\n                nees_k = (error.T @ P_inv @ error).item()\n                nees_history.append(nees_k)\n            except np.linalg.LinAlgError:\n                # In case of singularity, we cannot compute NEES for this step.\n                # Skip this data point; this is a sign of filter divergence.\n                pass\n\n        # 5. Final Statistics Calculation\n        avg_nis = np.mean(nis_history)\n        avg_nees = np.mean(nees_history) if nees_history else float('nan')\n        \n        # Autocorrelation\n        whitened_nu_arr = np.array(whitened_nu_history)\n        nu_mean = np.mean(whitened_nu_arr)\n        nu_mean_subtracted = whitened_nu_arr - nu_mean\n        \n        autocov = np.correlate(nu_mean_subtracted, nu_mean_subtracted, mode='full')\n        \n        lags = [1, 2, 3]\n        autocorr_values = []\n        denominator = autocov[T - 1] # Lag-0 autocovariance\n        if denominator > 1e-9: # Avoid division by zero\n            for lag in lags:\n                numerator = autocov[T - 1 + lag]\n                autocorr_values.append(np.abs(numerator / denominator))\n        else:\n             autocorr_values = [0.0, 0.0, 0.0]\n\n        max_abs_rho = max(autocorr_values) if autocorr_values else 0.0\n        \n        return avg_nis, max_abs_rho, avg_nees\n\n    results = []\n    for case in test_cases:\n        avg_nis, max_abs_rho, avg_nees = run_ukf_simulation(case)\n        results.extend([avg_nis, max_abs_rho, avg_nees])\n    \n    # Format and print the final output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2756735"}]}