{"hands_on_practices": [{"introduction": "鲁棒控制的基石是确保在存在不确定性的情况下仍然满足约束。本练习介绍庞特里亚金集合差 ($X \\ominus S$) 这一基本运算，它用于“收紧”状态约束，从而为标称系统创建一个更小但鲁棒可行的集合。通过从第一性原理出发解决这个简单的一维标量示例，您将为如何通过数学方法保证系统对有界扰动的安全裕度建立起坚实的直觉。[@problem_id:2884329]", "problem": "在鲁棒模型预测控制(MPC)中，针对加性扰动的状态约束收紧通常使用Pontryagin差分来表示。考虑标量离散时间系统 $x_{k+1}=x_{k}+u_{k}+w_{k}$，其中加性扰动 $w_{k}$ 属于紧凑区间 $S=[-\\delta,\\delta]$（$\\delta\\in[0,1]$），硬状态约束集为 $X=[-1,1]$。确保对 $S$ 中所有容许扰动都具有鲁棒可行性的标称状态约束由Pontryagin差分 $X\\ominus S$ 给出，该差分定义为集合\n$$\nX\\ominus S=\\{x\\in\\mathbb{R}\\mid x+s\\in X,\\ \\forall s\\in S\\}。\n$$\n请严格根据上述定义和 $\\mathbb{R}$ 上的基本序性质，推导集合 $[-1,1]\\ominus[-\\delta,\\delta]$ 的闭式表达式，结果应为一个以 $\\delta$ 表示的单个区间。你的最终答案必须是该区间的一个闭式解析表达式。不要使用任何预先记忆的集合差分快捷公式；直接根据定义中的量词进行推理。无需进行数值舍入。", "solution": "该问题是有效的，因为它在科学上基于控制理论的原理，其定义清晰、数据充分，是一个适定的问题，并且其表述是客观的。这是一个应用Pontryagin差分定义的标准练习，Pontryagin差分是鲁棒控制和集论方法中的一个基本概念。我们将从第一性原理出发进行严格推导。\n\n$\\mathbb{R}$ 中两个集合 $X$ 和 $S$ 的Pontryagin差分的定义如下：\n$$\nX \\ominus S = \\{x \\in \\mathbb{R} \\mid x+s \\in X, \\ \\forall s \\in S\\}\n$$\n在本问题中，给定状态约束集 $X = [-1, 1]$ 和扰动集 $S = [-\\delta, \\delta]$，参数 $\\delta$ 满足 $\\delta \\in [0, 1]$。我们的任务是确定集合 $X \\ominus S = [-1, 1] \\ominus [-\\delta, \\delta]$。\n\n根据定义，一个元素 $x \\in \\mathbb{R}$ 属于集合 $X \\ominus S$ 当且仅当对于集合 $S = [-\\delta, \\delta]$ 中所有可能的 $s$ 值，命题“$x+s \\in [-1, 1]$”为真。\n\n条件 $x+s \\in [-1, 1]$ 等价于以下两个不等式的逻辑合取：\n$$\n-1 \\le x+s \\quad \\land \\quad x+s \\le 1\n$$\n为了使 $x$ 属于Pontryagin差分，这两个不等式必须对所有 $s \\in [-\\delta, \\delta]$ 都成立。我们可以分别分析这两个要求。\n\n首先，我们分析条件：\n$$\n\\forall s \\in [-\\delta, \\delta], \\quad -1 \\le x+s\n$$\n这个不等式可以重排为关于 $x$ 的条件：\n$$\n\\forall s \\in [-\\delta, \\delta], \\quad x \\ge -1 - s\n$$\n为使此式成立，$x$ 必须大于或等于表达式 $-1-s$ 在 $s$ 遍历区间 $[-\\delta, \\delta]$ 时的最大可能值。函数 $f(s) = -1-s$ 是关于 $s$ 的严格递减函数。因此，它在闭区间上的最大值在 $s$ 取最小值时达到。在 $[-\\delta, \\delta]$ 中 $s$ 的最小值为 $-\\delta$。\n因此，我们必须有：\n$$\nx \\ge \\max_{s \\in [-\\delta, \\delta]} (-1 - s) = -1 - (-\\delta) = -1 + \\delta\n$$\n这给出了 $x$ 的下界。\n\n其次，我们分析另一个条件：\n$$\n\\forall s \\in [-\\delta, \\delta], \\quad x+s \\le 1\n$$\n将此不等式重排为关于 $x$ 的条件，得到：\n$$\n\\forall s \\in [-\\delta, \\delta], \\quad x \\le 1 - s\n$$\n为使此式成立，$x$ 必须小于或等于表达式 $1-s$ 在 $s$ 遍历区间 $[-\\delta, \\delta]$ 时的最小可能值。函数 $g(s) = 1-s$ 是关于 $s$ 的严格递减函数。因此，它在闭区间上的最小值在 $s$ 取最大值时达到。在 $[-\\delta, \\delta]$ 中 $s$ 的最大值为 $\\delta$。\n因此，我们必须有：\n$$\nx \\le \\min_{s \\in [-\\delta, \\delta]} (1 - s) = 1 - \\delta\n$$\n这给出了 $x$ 的上界。\n\n一个元素 $x$ 属于集合 $[-1, 1] \\ominus [-\\delta, \\delta]$ 当且仅当它同时满足上面推导出的下界和上界。结合这两个条件，我们得到：\n$$\n-1 + \\delta \\le x \\le 1 - \\delta\n$$\n这个复合不等式将所有满足条件的 $x$ 定义为一个闭区间。问题陈述中的条件 $\\delta \\in [0, 1]$ 确保了 $-1+\\delta \\le 1-\\delta$，因为这等价于 $2\\delta \\le 2$，即 $\\delta \\le 1$。因此，所得区间总非空。\n\n因此，Pontryagin差分的闭式表达式为区间 $[-1+\\delta, 1-\\delta]$。", "answer": "$$\n\\boxed{[-1+\\delta, 1-\\delta]}\n$$", "id": "2884329"}, {"introduction": "虽然静态收紧能够处理单步扰动，但真实系统是动态的，会持续受到扰动的影响。本实践引入了鲁棒正不变 (RPI) 集的概念，该集合描述了一个稳定闭环系统在无限时间范围内可能累积的所有误差。您将通过一个无限闵可夫斯基和 (Minkowski sum) 级数的极限，解析地推导出该集合，这对于量化确保递推可行性所需的“管道”大小至关重要。[@problem_id:2746575]", "problem": "考虑一个在模型预测控制（MPC）下的离散时间线性时不变（LTI）闭环误差系统，其受到加性有界扰动，动力学方程为 $e_{k+1} = A_{K} e_{k} + w_{k}$，其中 $A_{K} \\in \\mathbb{R}^{n \\times n}$ 且对所有 $k \\in \\mathbb{N}$ 都有 $w_{k} \\in W$。如果一个集合 $\\mathcal{E} \\subset \\mathbb{R}^{n}$ 满足 $A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$，则称其为该系统的一个鲁棒正不变（RPI）集，其中 $\\oplus$ 表示 Minkowski 和。在鲁棒MPC中，标称状态约束通常通过RPI集进行收紧，以确保标称状态在存在扰动的情况下仍保持可行；具体来说，对于一个对称凸约束集 $X$，一个常见的收紧方法是 $X_{\\text{tight}} = X \\ominus \\mathcal{E}$，其中 $\\ominus$ 表示 Pontryagin 差集。\n\n假设 $A_{K} = 0.5 I$，扰动集为轴对齐超立方体 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。标称状态约束集为 $X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。请仅使用 RPI 集、Minkowski 和以及集值级数极限的基本定义，推导最小 RPI 集 $\\mathcal{E}$，该集是通过闭环动力学对 $W$ 进行重复传播生成的 Minkowski 和级数的极限。然后，从第一性原理出发，量化由此产生的无穷范数约束收紧量，该收紧量定义为标量 $\\tau$，必须从 $X$ 的每个边界中减去，使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n请提供收紧量 $\\tau$ 的精确值作为最终答案。无需四舍五入。最终答案必须是单个实数。", "solution": "问题陈述需要进行验证。\n\n逐字提取的已知条件如下：\n- 闭环误差动力学：$e_{k+1} = A_{K} e_{k} + w_{k}$。\n- 系统矩阵：$A_{K} \\in \\mathbb{R}^{n \\times n}$。\n- 扰动：对所有 $k \\in \\mathbb{N}$ 都有 $w_{k} \\in W$。\n- 鲁棒正不变（RPI）集 $\\mathcal{E}$：$A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$。\n- Minkowski 和算子：$\\oplus$。\n- Pontryagin 差集算子：$\\ominus$。\n- 约束收紧：$X_{\\text{tight}} = X \\ominus \\mathcal{E}$。\n- 特定系统矩阵：$A_{K} = 0.5 I$。\n- 特定扰动集：$W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。\n- 特定标称状态约束集：$X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。\n- 任务1：将最小 RPI 集 $\\mathcal{E}$ 推导为 Minkowski 和级数的极限。\n- 任务2：量化收紧量 $\\tau$，使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n该问题在科学上基于鲁棒控制理论和模型预测控制（MPC）的既定原则。这是一个适定问题，因为对于具有有界扰动的稳定LTI系统，最小RPI集的概念是标准的，并能导出一个唯一解。问题陈述是客观、完整的，不包含任何矛盾。所有术语都有数学定义，并与该领域的文献一致。因此，该问题被认为是有效的，并将提供解答。\n\n第一步是为给定系统推导最小鲁棒正不变（RPI）集 $\\mathcal{E}$。最小RPI集是在所有可能的扰动序列作用下，从原点（$e_0 = 0$）可达的所有状态的集合。它被构造为通过系统动力学传播的扰动集的无限 Minkowski 和。\n从 $e_0 = 0$ 开始，在时间步 $k$ 的状态由下式给出：\n$$ e_k = \\sum_{i=0}^{k-1} A_K^i w_{k-1-i} $$\n任何时刻所有可能状态的集合是所有可达集的并集。最小RPI集 $\\mathcal{E}$ 是当 $k \\to \\infty$ 时这些可达集的极限：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} A_K^i W $$\n该级数收敛，因为系统矩阵 $A_K$ 是舒尔稳定的。$A_K = 0.5 I$ 的特征值均为 $0.5$，其模长小于 $1$。\n代入给定的 $A_K = 0.5 I$：\n$$ A_K^i = (0.5 I)^i = (0.5)^i I $$\n因此，最小 RPI 集为：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} (0.5)^i I W = \\bigoplus_{i=0}^{\\infty} (0.5)^i W $$\n扰动集 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$ 是一个凸的、中心对称的集合（一个以原点为中心的超立方体）。对于此类集合，缩放和 Minkowski 加法具有以下性质：对于非负标量 $\\alpha, \\beta$，有 $\\alpha S \\oplus \\beta S = (\\alpha+\\beta)S$。将此性质推广到无限和，我们可以写出：\n$$ \\mathcal{E} = \\left( \\sum_{i=0}^{\\infty} (0.5)^i \\right) W $$\n该和是一个公比为 $r = 0.5$ 的几何级数：\n$$ \\sum_{i=0}^{\\infty} (0.5)^i = \\frac{1}{1 - 0.5} = \\frac{1}{0.5} = 2 $$\n因此，最小 RPI 集是：\n$$ \\mathcal{E} = 2 W = 2 \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\} $$\n为了描述这个集合，令 $e \\in \\mathcal{E}$。那么对于某个 $w \\in W$，有 $e = 2w$。$e$ 的范数为 $\\|e\\|_{\\infty} = \\|2w\\|_{\\infty} = 2\\|w\\|_{\\infty}$。由于 $\\|w\\|_{\\infty} \\le 0.1$，可得 $\\|e\\|_{\\infty} \\le 2 \\times 0.1 = 0.2$。\n所以，最小 RPI 集是超立方体：\n$$ \\mathcal{E} = \\{ e \\in \\mathbb{R}^{n} : \\|e\\|_{\\infty} \\le 0.2 \\} $$\n\n第二步是确定收紧量 $\\tau$。收紧后的约束集为 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$。该集合必须满足条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。这个条件确保如果标称状态在 $X_{\\text{tight}}$ 内，则真实状态（标称状态加误差）保持在原始约束集 $X$ 内。\n\n我们来分析 Minkowski 和 $X_{\\text{tight}} \\oplus \\mathcal{E}$。$X_{\\text{tight}}$ 和 $\\mathcal{E}$ 都是由无穷范数界定的以原点为中心的超立方体。\n- $X_{\\text{tight}}$ 是一个无穷范数半径为 $1 - \\tau$ 的超立方体。\n- $\\mathcal{E}$ 是一个无穷范数半径为 $0.2$ 的超立方体。\n两个以原点为中心的超立方体的 Minkowski 和是另一个以原点为中心的超立方体，其半径是它们半径之和。\n令 $z \\in X_{\\text{tight}} \\oplus \\mathcal{E}$。那么对于某个 $x \\in X_{\\text{tight}}$ 和 $e \\in \\mathcal{E}$，有 $z = x + e$。$z$ 的无穷范数有界，如下：\n$$ \\|z\\|_{\\infty} = \\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty} $$\n最大可能值是可以达到的，因此结果集可由下式描述：\n$$ \\sup_{z \\in X_{\\text{tight}} \\oplus \\mathcal{E}} \\|z\\|_{\\infty} = \\sup_{x \\in X_{\\text{tight}}} \\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}} \\|e\\|_{\\infty} = (1 - \\tau) + 0.2 = 1.2 - \\tau $$\n所以，$X_{\\text{tight}} \\oplus \\mathcal{E} = \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\}$。\n条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$ 变为：\n$$ \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\} \\subseteq \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\} $$\n为了使这个集合包含关系成立，内部集合的半径必须小于或等于外部集合的半径：\n$$ 1.2 - \\tau \\le 1 $$\n这意味着 $0.2 \\le \\tau$。为了在保证可行性的同时做到最小保守，我们必须为收紧量 $\\tau$ 选择可能的最小值。满足该条件的最小收紧量是 $\\tau = 0.2$。\n\n这等价于计算 Pontryagin 差集 $X \\ominus \\mathcal{E}$。根据定义，$X \\ominus \\mathcal{E} = \\{ x \\in \\mathbb{R}^n \\mid x \\oplus \\mathcal{E} \\subseteq X \\}$。\n对于一个元素 $x$ 要属于这个集合，必须对所有 $e \\in \\mathcal{E}$ 都有 $x+e \\in X$。\n这意味着对于所有 $\\|e\\|_{\\infty} \\le 0.2$ 都有 $\\|x+e\\|_{\\infty} \\le 1$。\n对于一个固定的 $x$ ，$\\|x+e\\|_{\\infty}$ 的最大值是 $\\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}}\\|e\\|_{\\infty}$。\n所以，条件是 $\\|x\\|_{\\infty} + 0.2 \\le 1$，可简化为 $\\|x\\|_{\\infty} \\le 0.8$。\n这就定义了最大的收紧集：$X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 0.8 \\}$。\n将其与给定形式 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 进行比较，我们令边界相等：\n$$ 1 - \\tau = 0.8 $$\n求解 $\\tau$ 可得 $\\tau = 1 - 0.8 = 0.2$。\n收紧量为 $\\tau = 0.2$。", "answer": "$$\n\\boxed{0.2}\n$$", "id": "2746575"}, {"introduction": "不变集的解析计算通常仅限于特定的系统结构，因此对于通用系统，我们需要强大的数值方法。本练习将指导您实现一个实用的迭代算法，利用线性规划来计算状态约束内包含的最大 RPI 集。该方法的核心在于重复应用鲁棒单步前溯算子 (robust one-step predecessor operator)，直至收敛到一个不动点。通过将不变集的理论概念转化为一个可执行的算法，本实践将帮助您跨越理论与应用之间的鸿沟，掌握鲁棒控制器综合的一项关键计算技能。[@problem_id:2741157]", "problem": "考虑一个由 $x^{+} = A x + B u + w$ 给出的带加性扰动的离散时间线性时不变系统，其中 $x \\in \\mathbb{R}^{n}$ 是状态，$u \\in \\mathbb{R}^{m}$ 是控制输入，$w \\in \\mathbb{R}^{n}$ 是一个外源性扰动。应用静态状态反馈 $u = K x$，得到闭环系统 $x^{+} = A_{\\mathrm{cl}} x + w$，其中 $A_{\\mathrm{cl}} := A + B K$。状态被约束在一个紧凸集 $X := \\{ x \\in \\mathbb{R}^{n} \\mid H x \\le h \\}$ 内，扰动有界于一个紧凸集 $W$ 内。如果对于所有 $x \\in S$ 和所有 $w \\in W$，其后继状态 $A_{\\mathrm{cl}} x + w$ 仍在 $S$ 内，那么集合 $S \\subseteq X$ 称为该闭环系统的一个鲁棒正不变 (RPI) 集。在鲁棒模型预测控制 (RMPC) 的背景下，计算包含在 $X$ 中的最大RPI集可以保证鲁棒可行性和约束满足性。\n\n您的任务是推导并实现一个不动点迭代，用以计算包含在 $X$ 内的最大RPI集。该迭代使用基于多胞体的不动点迭代方法，并依赖于鲁棒一步前驱算子。计算过程必须是完全自动化的，并且当满足收敛准则或当结果集变为空集时必须在数值上终止。\n\n基本原理：\n- 鲁棒正不变性的定义：对于系统 $x^{+} = A_{\\mathrm{cl}} x + w$，一个集合 $S$ 是RPI集，当且仅当对于所有 $x \\in S$ 和所有 $w \\in W$，都有 $A_{\\mathrm{cl}} x + w \\in S$。\n- 集合 $S$ 的鲁棒一步前驱集是 $\\mathrm{Pre}(S) := \\{ x \\in \\mathbb{R}^{n} \\mid A_{\\mathrm{cl}} x + w \\in S \\ \\text{for all} \\ w \\in W \\}$。\n- 对于多胞体集 $S = \\{ x \\mid H x \\le c \\}$ 和紧凸集 $W$，包含关系 $A_{\\mathrm{cl}} x + w \\in S$ 对所有 $w \\in W$ 成立，等价于 $H A_{\\mathrm{cl}} x \\le c - s$。其中 $s \\in \\mathbb{R}^{q}$ 的分量为 $s_{i} = \\max_{w \\in W} (H_{i} w)$，即 $W$ 的支撑函数在面法向量 $H_{i}$ 上的取值。\n- 用于计算 $X$ 的最大RPI子集的集合迭代为 $S_{0} := X$ 和 $S_{k+1} := X \\cap \\mathrm{Pre}(S_{k})$。这是一个单调非增序列，在温和条件下收敛到 $X$ 的最大RPI子集或空集。\n\n为了使计算在有限时间内算法上可行且易于测试，使用一个固定的面法向量模板 $H$，并计算一系列形如 $S_{k} = \\{ x \\mid H x \\le c_{k} \\}$ 的集合，其中向量 $c_{k}$ 变化而 $H$ 保持不变。您必须：\n- 使用轴对齐的盒状模板 $H = \\begin{bmatrix} I \\\\ -I \\end{bmatrix}$，其中 $I$ 是 $n \\times n$ 的单位矩阵。当相对的面上的上界相等时，该模板表示关于原点对称的超矩形。状态约束集为 $X := \\{ x \\mid H x \\le h_{X} \\}$，其中 $h_{X} = \\begin{bmatrix} \\bar{x} \\\\ \\bar{x} \\end{bmatrix}$，$\\bar{x} \\in \\mathbb{R}^{n}_{\\ge 0}$ 是状态边界向量。\n- 设扰动集为盒状集合 $W := \\{ w \\in \\mathbb{R}^{n} \\mid |w_{j}| \\le \\bar{w}_{j} \\}$，因此其在行向量 $H_{i}$ 处的支撑函数为 $s_{i} = \\sum_{j=1}^{n} |H_{i j}| \\bar{w}_{j}$。对于所选的 $H$，这简化为 $s = \\begin{bmatrix} \\bar{w} \\\\ \\bar{w} \\end{bmatrix}$。\n\n按如下方式推导将 $c_{k}$ 映射到 $c_{k+1}$ 的不动点更新：\n- 从 $c_{0} = h_{X}$ 开始。\n- 给定 $c_{k}$，计算鲁棒前驱约束 $H A_{\\mathrm{cl}} x \\le c_{k} - s$。\n- 通过求解线性规划来计算 $c_{k+1}$，使其成为满足 $S_{k+1} = \\{ x \\mid H x \\le c_{k+1} \\} \\supseteq X \\cap \\mathrm{Pre}(S_{k})$ 的同一模板下的最紧向量。具体地，对每一行 $i$，求解在满足 $H A_{\\mathrm{cl}} x \\le c_{k} - s$ 和 $H x \\le h_{X}$ 的 $x$ 上返回 $H_{i} x$ 最大值的线性规划问题。将 $c_{k+1,i}$ 设为此最大值。如果交集为空，则声明 $S_{k+1} = \\varnothing$ 并终止。\n- 当 $\\| c_{k+1} - c_{k} \\|_{\\infty} \\le \\varepsilon$（其中 $\\varepsilon$ 是收敛容差）或检测到空集时停止。\n\n关于报告，将最终集合的各轴半宽度定义为 $r_{j} := \\min\\{ c_{\\infty, j}, \\ c_{\\infty, j+n} \\}$，对于 $j \\in \\{1,\\dots,n\\}$，其中 $c_{\\infty}$ 是收敛后的向量。如果集合为空，则对所有 $j$ 定义 $r_{j} := 0$。将二维情况下的面积定义为 $A := 4 \\, r_{1} r_{2}$。所有数值结果必须四舍五入到六位小数。\n\n使用线性规划来解决逐面的最大化问题，并实现上述算法。使用以下测试套件。在每个测试中，计算 $A_{\\mathrm{cl}} = A + B K$，迭代直到收敛或集合为空，并输出半宽度和面积。\n\n测试套件 (所有数字都是实数标量；所有矩阵和向量都明确给出)：\n- 测试 1 (理想情况，开环稳定)：\n  - $n = 2$,\n  - $A = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.0 & 0.8 \\end{bmatrix}$,\n  - $B = I_{2}$,\n  - $K = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$,\n  - $\\bar{x} = \\begin{bmatrix} 2.0 \\\\ 2.0 \\end{bmatrix}$,\n  - $\\bar{w} = \\begin{bmatrix} 0.05 \\\\ 0.05 \\end{bmatrix}$。\n- 测试 2 (通过反馈镇定，非平凡耦合)：\n  - $n = 2$,\n  - $A = \\begin{bmatrix} 1.2 & 0.1 \\\\ 0.2 & 1.1 \\end{bmatrix}$,\n  - $B = I_{2}$,\n  - $K = \\begin{bmatrix} -0.8 & 0.0 \\\\ 0.0 & -0.7 \\end{bmatrix}$,\n  - $\\bar{x} = \\begin{bmatrix} 1.0 \\\\ 0.8 \\end{bmatrix}$,\n  - $\\bar{w} = \\begin{bmatrix} 0.02 \\\\ 0.01 \\end{bmatrix}$。\n- 测试 3 (边界情况，因扰动过大而不可行)：\n  - $n = 2$,\n  - $A = 0.95 \\, I_{2}$,\n  - $B = I_{2}$,\n  - $K = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}$,\n  - $\\bar{x} = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$,\n  - $\\bar{w} = \\begin{bmatrix} 0.12 \\\\ 0.12 \\end{bmatrix}$。\n\n数值规格：\n- 在 $\\ell_{\\infty}$-范数下使用收敛容差 $\\varepsilon = 10^{-8}$，最大迭代次数为 $200$ 次。\n- 如果任何一次迭代产生的交集 $X \\cap \\mathrm{Pre}(S_{k})$ 不可行，则视该集合为空集。\n\n要求的最终输出格式：\n- 您的程序必须打印单行内容，其中包含一个各测试结果的列表，每个测试结果是一个列表 $[r_{1}, r_{2}, A]$，所有条目都四舍五入到六位小数。对于上述三个测试，要求的格式是：\n- $[[r_{1}^{(1)}, r_{2}^{(1)}, A^{(1)}],[r_{1}^{(2)}, r_{2}^{(2)}, A^{(2)}],[r_{1}^{(3)}, r_{2}^{(3)}, A^{(3)}]]$。\n\n此问题中没有物理单位。不使用角度。所有实数值输出必须是小数点后恰好有六位的小数。", "solution": "该问题要求推导并实现一个不动点迭代算法，用以计算在状态和扰动约束下，离散时间线性系统的最大鲁棒正不变(RPI)集。该解决方案将基于多胞体集合运算，并通过线性规划在算法上予以实现。\n\n系统动力学由 $x^{+} = A x + B u + w$ 给出，在采用状态反馈控制律 $u=Kx$ 后，闭环系统为 $x^{+} = A_{\\mathrm{cl}} x + w$，其中 $A_{\\mathrm{cl}} = A + B K$。状态 $x \\in \\mathbb{R}^n$ 被约束在集合 $X$ 内，扰动 $w \\in \\mathbb{R}^n$ 有界于集合 $W$ 内。\n\n如果对于任何状态 $x \\in S$ 和任何扰动 $w \\in W$，下一状态 $x^{+} = A_{\\mathrm{cl}}x + w$ 仍然在 $S$ 内，则集合 $S$ 是一个鲁棒正不变(RPI)集。目标是找到包含在状态约束集 $X$ 内的、最大的此类集合，记为 $S_{\\infty} \\subseteq X$。\n\n计算通过对一系列集合 $\\{S_k\\}_{k \\ge 0}$ 进行不动点迭代来完成，定义如下：\n$$ S_0 = X $$\n$$ S_{k+1} = X \\cap \\mathrm{Pre}(S_k) $$\n其中 $\\mathrm{Pre}(S_k)$ 是 $S_k$ 的鲁棒一步前驱集。它包含所有这样的状态 $x$：对于这些状态，无论扰动 $w \\in W$ 如何，所有可能的下一状态 $A_{\\mathrm{cl}}x + w$ 都在 $S_k$ 内。形式上，\n$$ \\mathrm{Pre}(S_k) = \\{ x \\in \\mathbb{R}^n \\mid A_{\\mathrm{cl}}x + w \\in S_k, \\ \\forall w \\in W \\} $$\n这个集合序列是单调非增的，$S_{k+1} \\subseteq S_k$，并收敛于最大RPI集 $S_{\\infty}$。\n\n为了使该算法在计算上可行，我们将集合表示为具有固定面法向量模板的多胞体。模板由 $H = \\begin{bmatrix} I \\\\ -I \\end{bmatrix}$ 给出，其中 $I$ 是 $n \\times n$ 的单位矩阵。因此，这些集合是形如 $S_k = \\{ x \\mid H x \\le c_k \\}$ 的超矩形。\n\n状态约束集为 $X = \\{ x \\mid H x \\le h_X \\}$，其中对于给定的正边界向量 $\\bar{x}$，$h_X = [\\bar{x}^T, \\bar{x}^T]^T$。这对应于每个分量 $j$ 满足 $|x_j| \\le \\bar{x}_j$。扰动集为 $W = \\{ w \\mid |w_j| \\le \\bar{w}_j \\}$。\n\n让我们推导前驱集 $\\mathrm{Pre}(S_k)$ 的约束。给定 $S_k = \\{ x \\mid H x \\le c_k \\}$，条件 $A_{\\mathrm{cl}}x + w \\in S_k$ 变为 $H(A_{\\mathrm{cl}}x + w) \\le c_k$。这必须对所有 $w \\in W$ 成立。这等价于：\n$$ H A_{\\mathrm{cl}} x + H w \\le c_k, \\quad \\forall w \\in W $$\n$$ H A_{\\mathrm{cl}} x \\le c_k - H w, \\quad \\forall w \\in W $$\n为了对所有 $w$ 满足这个条件，我们必须为使 $Hw$ 最大化的最坏情况 $w$ 满足它。这导致了不等式：\n$$ H A_{\\mathrm{cl}} x \\le c_k - s $$\n其中 $s$ 是一个向量，其第 $i$ 个分量是 $W$ 的支撑函数在法向量 $H_i$ 上的取值，即 $s_i = \\max_{w \\in W} (H_i w)$。对于所选的模板 $H$ 和扰动集 $W$，$H$ 的行分别是 $H_{j} = e_j$ 和 $H_{n+j} = -e_j$，其中 $j=1, \\dots, n$。对于行 $H_j = e_j$，$s_j = \\max_{w \\in W} w_j = \\bar{w}_j$。对于行 $H_{n+j} = -e_j$，$s_{n+j} = \\max_{w \\in W} (-w_j) = \\bar{w}_j$。因此，支撑向量是常数 $s = [\\bar{w}^T, \\bar{w}^T]^T$。前驱集是多胞体 $\\mathrm{Pre}(S_k) = \\{ x \\mid H A_{\\mathrm{cl}} x \\le c_k - s \\}$。\n\n下一个迭代集合 $S_{k+1}$ 由两个多胞体的交集定义：$S_{k+1, \\text{exact}} = X \\cap \\mathrm{Pre}(S_k) = \\{ x \\mid H x \\le h_X \\text{ and } H A_{\\mathrm{cl}} x \\le c_k - s \\}$。为了使用固定的模板 $H$ 继续迭代，我们必须找到包含这个交集的最紧的超矩形 $\\{x \\mid H x \\le c_{k+1}\\}$。新向量的各分量 $c_{k+1,i}$ 是通过在交集上最大化相应的线性函数 $H_i x$ 来找到的。这是通过为 $2n$ 个面中的每一个求解一个线性规划 (LP) 问题来实现的：\n$$ c_{k+1, i} = \\max_{x \\in \\mathbb{R}^n} \\quad H_i x $$\n$$ \\text{subject to:} \\quad \\begin{bmatrix} H \\\\ H A_{\\mathrm{cl}} \\end{bmatrix} x \\le \\begin{bmatrix} h_X \\\\ c_k - s \\end{bmatrix} $$\n如果这些 LP 问题中的任何一个不可行，则交集为空，意味着在 $X$ 内不存在 RPI 集，迭代终止。\n\n整体算法如下：\n1.  初始化 $k=0$ 并令 $c_0 = h_X$。\n2.  在每次迭代 $k$ 中，构造 LP 约束的右侧项，$b_{LP} = [h_X^T, (c_k - s)^T]^T$。约束矩阵 $A_{LP} = [H^T, (H A_{\\mathrm{cl}})^T]^T$ 是常数。\n3.  对每个面 $i=1, \\ldots, 2n$，求解相应的 LP 以找到 $c_{k+1,i}$。如果任何一个 LP 不可行，则最大 RPI 集为空集。终止并报告空集。\n4.  通过比较新向量 $c_{k+1}$ 与前一个向量 $c_k$ 来检查收敛性。如果对于一个小的容差 $\\varepsilon$，有 $\\|c_{k+1} - c_k\\|_{\\infty} \\le \\varepsilon$，则迭代已收敛到 $c_{\\infty}$。\n5.  如果未收敛，则设置 $c_k = c_{k+1}$ 并从步骤 2 开始重复，直到达到最大迭代次数。\n6.  一旦收敛到 $c_{\\infty}$，最终集合为 $S_{\\infty} = \\{x \\mid Hx \\le c_{\\infty}\\}$。半宽度计算为 $r_j = \\min\\{ c_{\\infty, j}, c_{\\infty, j+n} \\}$，其中 $j=1, \\dots, n$。如果集合为空，则所有 $r_j=0$。对于 $n=2$，面积为 $A = 4 r_1 r_2$。\n该过程被实现用来解决给定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef compute_mRPI(A, B, K, x_bar, w_bar, tol=1e-8, max_iter=200):\n    \"\"\"\n    Computes the maximal Robust Positively Invariant (RPI) set.\n    \n    The function implements a fixed-point iteration using linear programming\n    to find the maximal RPI set S_inf contained in the state constraint set X\n    for the system x^+ = A_cl*x + w.\n    \"\"\"\n    n = A.shape[0]\n\n    # --- Setup System and Set Definitions ---\n    A_cl = A + B @ K\n    I_n = np.identity(n)\n    H = np.vstack([I_n, -I_n])  # Shape (2n, n)\n\n    h_X = np.hstack([x_bar, x_bar])  # Shape (2n,)\n    s = np.hstack([w_bar, w_bar])    # Shape (2n,)\n\n    # --- LP Formulation ---\n    # The constraint matrix is constant throughout the iterations.\n    A_lp = np.vstack([H, H @ A_cl])  # Shape (4n, n)\n\n    # --- Iteration ---\n    c_k = h_X\n    is_empty = False\n    \n    for k in range(max_iter):\n        c_k_plus_1 = np.zeros(2 * n)\n        \n        # The right-hand side of the LP constraints depends on c_k.\n        b_lp = np.hstack([h_X, c_k - s])  # Shape (4n,)\n\n        for i in range(2 * n):\n            # Objective: max H[i,:] @ x <=> min -H[i,:] @ x\n            c_obj = -H[i, :]\n\n            # Solve the LP. The 'highs' method is robust and the default in recent SciPy.\n            res = linprog(c=c_obj, A_ub=A_lp, b_ub=b_lp, bounds=(None, None), method='highs')\n            \n            # Check for infeasibility.\n            if not res.success:\n                is_empty = True\n                break\n            \n            # The LP minimizes, so the maximum value is -res.fun\n            c_k_plus_1[i] = -res.fun\n        \n        if is_empty:\n            break\n\n        # Check for emptiness based on derived bounds.\n        # If max(x_j) < min(x_j), the set is empty.\n        # max(x_j) = c_k_plus_1[j], min(x_j) = -c_k_plus_1[n+j].\n        # So, if c_k_plus_1[j] < -c_k_plus_1[n+j] for any j, it's empty.\n        if np.any(c_k_plus_1[:n] < -c_k_plus_1[n:]):\n            is_empty = True\n            break\n        \n        # Check for convergence in the infinity norm.\n        if np.max(np.abs(c_k_plus_1 - c_k)) <= tol:\n            c_k = c_k_plus_1 # Final converged value\n            break\n        \n        c_k = c_k_plus_1\n\n    # --- Post-processing and Result Calculation ---\n    if is_empty:\n        r = np.zeros(n)\n        area = 0.0\n    else:\n        # If loop finished due to max_iter, use the last computed c_k.\n        c_inf = c_k\n        # Calculate half-widths as per problem definition\n        r = np.minimum(c_inf[:n], c_inf[n:])\n        \n        # If any half-width is negative, the set is considered empty.\n        if np.any(r < 0):\n            r.fill(0.0)\n            area = 0.0\n        else:\n            if n == 2:\n                # Area = (2*r1) * (2*r2)\n                area = 4 * r[0] * r[1]\n            else:\n                area = np.nan # Not defined for n!=2 in this problem\n    return r, area\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Stable open-loop system\n        {\n            \"A\": np.array([[0.9, 0.1], [0.0, 0.8]]),\n            \"B\": np.identity(2),\n            \"K\": np.zeros((2, 2)),\n            \"x_bar\": np.array([2.0, 2.0]),\n            \"w_bar\": np.array([0.05, 0.05]),\n        },\n        # Test 2: Unstable system stabilized by feedback\n        {\n            \"A\": np.array([[1.2, 0.1], [0.2, 1.1]]),\n            \"B\": np.identity(2),\n            \"K\": np.array([[-0.8, 0.0], [0.0, -0.7]]),\n            \"x_bar\": np.array([1.0, 0.8]),\n            \"w_bar\": np.array([0.02, 0.01]),\n        },\n        # Test 3: Infeasible due to large disturbance\n        {\n            \"A\": 0.95 * np.identity(2),\n            \"B\": np.identity(2),\n            \"K\": np.zeros((2, 2)),\n            \"x_bar\": np.array([0.1, 0.1]),\n            \"w_bar\": np.array([0.12, 0.12]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r, area = compute_mRPI(\n            A=case[\"A\"], \n            B=case[\"B\"], \n            K=case[\"K\"], \n            x_bar=case[\"x_bar\"], \n            w_bar=case[\"w_bar\"]\n        )\n        \n        # Store results for final printing\n        if r.shape[0] == 2:\n            results.append([r[0], r[1], area])\n\n    # Final print statement in the exact required format.\n    # Format: [[r1_1,r2_1,A_1],[r1_2,r2_2,A_2],[r1_3,r2_3,A_3]]\n    # with 6 decimal places and no spaces within the inner lists.\n    formatted_results = []\n    for res in results:\n        # res is a list [r1, r2, Area]\n        formatted_results.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2741157"}]}