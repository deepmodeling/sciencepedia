{"hands_on_practices": [{"introduction": "在设计任何分布式估计或控制系统之前，我们必须回答一个基本问题：网络中的传感器能否共同观测到整个系统的状态？这个练习将通过基础的Popov-Belevitch-Hautus (PBH)测试来巩固可观测性的概念。通过诊断系统的不可观测模态并确定如何通过增加最少的传感器来恢复可观测性，你将锻炼解决实际传感器布局问题的能力。[@problem_id:2701991]", "problem": "考虑一个由 $\\dot{x}(t) = A x(t)$ 控制的线性时不变网络系统，其状态维度为 $n = 4$。其中\n$$\nA = \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  2  0\\\\\n0  0  0  3\n\\end{pmatrix}.\n$$\n有 $3$ 个传感智能体（节点），索引为 $i \\in \\{1,2,3\\}$，每个智能体都有一个局部测量值 $y_i(t) = C_i x(t)$。局部传感矩阵为\n$$\nC_1 = \\begin{pmatrix}1  0  0  0\\end{pmatrix},\\quad\nC_2 = \\begin{pmatrix}0  0  1  0\\end{pmatrix},\\quad\nC_3 = \\begin{pmatrix}0  0  0  1\\end{pmatrix}.\n$$\n这 $3$ 个智能体之间的有向通信图是强连通的，边集为 $\\{(1,2),(2,3),(3,1)\\}$。智能体可以通过此图交换信息。\n\n仅使用线性系统和网络估计的基本定义，判断在所有可用传感器的联合作用下（即使用堆叠测量矩阵 $C = \\begin{pmatrix} C_1^{\\vphantom{\\top}} \\\\ C_2^{\\vphantom{\\top}} \\\\ C_3^{\\vphantom{\\top}} \\end{pmatrix}$），该系统是否是集体可观测的。如果不可观测，计算需要添加的最少数量 $m$ 个形式为 $y_{\\text{add}}(t) = e_j^{\\top} x(t)$ 的附加标量传感器（其中 $e_j$ 是 $\\mathbb{R}^{4}$ 中的标准基向量且 $j \\in \\{1,2,3,4\\}$，可以放置在任何节点），使得联合传感使系统对 $(A,C_{\\text{aug}})$ 可观测。请将你的最终答案以整数 $m$ 的形式给出。如果系统已经是可观测的，则 $m=0$。最终答案必须是单个整数；无需四舍五入。", "solution": "该问题要求分析一个给定的线性时不变系统的集体可观测性，并在系统尚不具备可观测性时，确定实现可观测性所需的最少附加标准传感器数量。\n\n首先，我们必须按规定将“集体可观测性”这一概念形式化。问题指出，这是在“所有可用传感器的联合作用下”的可观测性。对于线性系统 $\\dot{x}(t) = Ax(t)$，这等同于检查系统对 $(A, C)$ 的可观测性，其中 $A$ 是状态矩阵，$C$ 是所有单个传感器矩阵 $C_i$ 的堆叠矩阵。有关通信图拓扑的信息与*分布式*可观测性相关，在分布式可观测性中，每个智能体必须使用本地测量和来自其邻居的信息来估计状态。然而，对于集体可观测性，我们考虑的是一个集中式场景，其中所有测量值都是同时可用的。\n\n状态矩阵给定为：\n$$\nA = \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  2  0\\\\\n0  0  0  3\n\\end{pmatrix}\n$$\n单个传感器矩阵为：\n$$\nC_1 = \\begin{pmatrix}1  0  0  0\\end{pmatrix},\\quad\nC_2 = \\begin{pmatrix}0  0  1  0\\end{pmatrix},\\quad\nC_3 = \\begin{pmatrix}0  0  0  1\\end{pmatrix}\n$$\n集体测量矩阵 $C$ 是通过堆叠这些单个矩阵形成的：\n$$\nC = \\begin{pmatrix} C_1 \\\\ C_2 \\\\ C_3 \\end{pmatrix} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n状态维度为 $n=4$。为确定系统对 $(A, C)$ 是否可观测，我们将采用 Popov-Belevitch-Hautus (PBH) 检验。PBH 检验指出，系统对 $(A, C)$ 是可观测的，当且仅当对于 $A$ 的每一个特征值 $\\lambda$，矩阵\n$$\n\\begin{pmatrix} A - \\lambda I \\\\ C \\end{pmatrix}\n$$\n都具有满列秩，即秩为 $n=4$。\n\n由于 $A$ 是一个对角矩阵，其特征值即为其对角线元素。$A$ 的特征值集合，记作 $\\sigma(A)$，是 $\\{1, 1, 2, 3\\}$。我们必须对每个不同的特征值检查 PBH 秩条件：$\\lambda=1$，$\\lambda=2$ 和 $\\lambda=3$。\n\n情况 1：$\\lambda = 2$\n与此特征值对应的特征向量是 $v_2 = e_3 = (0, 0, 1, 0)^{\\top}$。一个模式是可观测的，当且仅当对于与该模式相关的任何特征向量 $v$，都有 $Cv \\neq 0$。\n$$\nC v_2 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\neq 0\n$$\n由于 $C v_2 \\neq 0$，与 $\\lambda=2$ 相关的模式是可观测的。\n\n情况 2：$\\lambda = 3$\n与此特征值对应的特征向量是 $v_3 = e_4 = (0, 0, 0, 1)^{\\top}$。我们检验：\n$$\nC v_3 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\neq 0\n$$\n由于 $C v_3 \\neq 0$，与 $\\lambda=3$ 相关的模式是可观测的。\n\n情况 3：$\\lambda = 1$\n此特征值的代数重数为 $2$。矩阵 $A$ 是对角矩阵，因此几何重数也为 $2$。与 $\\lambda=1$ 相关的特征空间由特征向量 $v_{1a} = e_1 = (1, 0, 0, 0)^{\\top}$ 和 $v_{1b} = e_2 = (0, 1, 0, 0)^{\\top}$ 张成。\n如果存在一个 $A$ 的非零特征向量 $v$ 位于 $C$ 的核空间中，即 $Cv=0$，则系统对 $(A,C)$ 是不可观测的。我们对 $\\lambda=1$ 的特征空间的基向量进行检验。\n对于 $v_{1a} = e_1$：\n$$\nC e_1 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\neq 0\n$$\n对于 $v_{1b} = e_2$：\n$$\nC e_2 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = 0\n$$\n我们找到了一个非零特征向量 $v_{1b} = e_2$，使得 $C v_{1b} = 0$。这意味着与此特征向量相关的模式是不可观测的。不可观测子空间是此特征向量的张成空间，即 $\\text{span}\\{e_2\\}$。因此，该系统不是集体可观测的。\n\n现在的问题是，要使系统可观测，需要添加的最少数量 $m$ 个形式为 $y_{\\text{add}}(t) = e_j^{\\top} x(t)$（其中 $j \\in \\{1,2,3,4\\}$）的附加传感器。添加这样一个传感器对应于将行向量 $e_j^{\\top}$ 附加到测量矩阵 $C$ 上。设增广矩阵为 $C_{\\text{aug}}$。\n为了使与 $e_2$ 对应的不可观测模式变得可观测，增广测量矩阵 $C_{\\text{aug}}$ 必须满足 $C_{\\text{aug}}e_2 \\neq 0$。这要求至少有一个添加的行 $e_j^{\\top}$ 满足 $e_j^{\\top} e_2 \\neq 0$。\n我们对每个可能的 $j$ 计算乘积 $e_j^{\\top} e_2$：\n\\begin{itemize}\n    \\item $j=1$: $e_1^{\\top} e_2 = \\begin{pmatrix}1  0  0  0\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 0$。\n    \\item $j=2$: $e_2^{\\top} e_2 = \\begin{pmatrix}0  1  0  0\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 1 \\neq 0$。\n    \\item $j=3$: $e_3^{\\top} e_2 = \\begin{pmatrix}0  0  1  0\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 0$。\n    \\item $j=4$: $e_4^{\\top} e_2 = \\begin{pmatrix}0  0  0  1\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 0$。\n\\end{itemize}\n唯一能够观测状态分量 $x_2$ 进而观测到不可观测模式的传感器选择是对应于 $j=2$ 的传感器，即 $y_{\\text{add}}(t) = e_2^{\\top}x(t) = x_2(t)$。\n添加这单个传感器就足够了。让我们用这个附加传感器构成新的增广矩阵 $C_{\\text{aug}}$：\n$$\nC_{\\text{aug}} = \\begin{pmatrix} C \\\\ e_2^{\\top} \\end{pmatrix} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n该矩阵是一个置换矩阵，因此具有满秩 $4$。现在我们必须检查系统对 $(A, C_{\\text{aug}})$ 的可观测性。由于添加传感器不会消除可观测性，$\\lambda=2$ 和 $\\lambda=3$ 的模式仍然是可观测的。我们只需要重新检查 $\\lambda=1$ 的特征空间。\n该特征空间中的任何向量 $v$ 的形式为 $v = \\alpha e_1 + \\beta e_2 = (\\alpha, \\beta, 0, 0)^{\\top}$。如果对于某个非零 $v$（即 $\\alpha$ 或 $\\beta$ 不为零），有 $C_{\\text{aug}}v=0$，则该模式是不可观测的。\n$$\nC_{\\text{aug}}v = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\\\\\n0  1  0  0\n\\end{pmatrix}\n\\begin{pmatrix} \\alpha \\\\ \\beta \\\\ 0 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} \\alpha \\\\ 0 \\\\ 0 \\\\ \\beta \\end{pmatrix}\n$$\n要使 $C_{\\text{aug}}v = 0$，我们需要 $\\alpha=0$ 和 $\\beta=0$，这意味着 $v=0$。因此，此特征空间中没有非零的不可观测特征向量。系统 $(A, C_{\\text{aug}})$ 现在是完全可观测的。\n由于原始系统是不可观测的，必须至少添加一个传感器。我们已经证明，添加一个特定的传感器就足够了。因此，所需的最少附加传感器数量为 $m=1$。\n最终答案必须是一个整数，即 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "2701991"}, {"introduction": "掌握了可观测性的基础后，我们将从被动观察转向主动的信息处理。这项实践将深入研究分布式系统的基石：一致性算法。你将首先从理论上推导出保证算法收敛的充要条件，然后编写一个程序来验证这些条件，从而将数学分析与实际验证联系起来。[@problem_id:2702015]", "problem": "考虑一个由 $n$ 个智能体组成的网络，每个智能体的局部状态维度相同，为 $p \\in \\mathbb{N}$。在离散时间 $k \\in \\mathbb{N}$，将局部状态堆叠成一个全局向量 $x_k \\in \\mathbb{R}^{np}$。令 $L \\in \\mathbb{R}^{n \\times n}$ 为一个无向图的图拉普拉斯矩阵，并令 $I_p \\in \\mathbb{R}^{p \\times p}$ 为单位矩阵。考虑分布式输出反馈一致性迭代\n$$\nx_{k+1} \\;=\\; x_k \\;-\\; \\alpha \\, (L \\otimes I_p) \\, y_k, \n\\qquad y_k \\;=\\; C \\, x_k,\n$$\n其中步长 $\\alpha \\in \\mathbb{R}$ 为常数，输出矩阵为 $C \\in \\mathbb{R}^{np \\times np}$。假设 $C$ 是块对角矩阵且对所有智能体都相同，即 $C = I_n \\otimes C_{\\mathrm{loc}}$，其中 $C_{\\mathrm{loc}} \\in \\mathbb{R}^{p \\times p}$ 是对称矩阵。将一致性子空间表示为 $\\mathcal{S} \\triangleq \\{ \\mathbf{1}_n \\otimes v : v \\in \\mathbb{R}^p \\}$，其中 $\\mathbf{1}_n \\in \\mathbb{R}^n$ 是全1向量。\n\n您的任务是：\n\n1) 仅从图拉普拉斯矩阵和 Kronecker 积的核心定义和已知事实出发，推导线性迭代矩阵 $M \\triangleq I_{np} - \\alpha \\,(L \\otimes I_p) \\, C$ 的谱。然后，利用该谱推导出关于 $\\alpha$、 $L$ 的特征值以及 $C_{\\mathrm{loc}}$ 的特征值的充分必要条件，以保证对于任意初始条件 $x_0 \\in \\mathbb{R}^{np}$，序列 $(x_k)_{k \\in \\mathbb{N}}$ 都收敛到一致性子空间 $\\mathcal{S}$。将这些条件以矩阵对 $(C, I_{np})$ 的可检测性形式表示，以确保 $M$ 的单位模特征值仅对应于子空间 $\\mathcal{S}$。请用以下方式给出您的条件：\n- 由 $L$ 编码的图的连通性，\n- $C_{\\mathrm{loc}}$ 的定性，\n- 以及 $\\alpha$ 作为 $L$ 和 $C_{\\mathrm{loc}}$ 最大特征值的函数的可容许范围。\n\n2) 实现一个程序，对下述每个测试用例，返回一个布尔值，指示您推导的条件是否满足，从而保证每个轨迹都收敛到一致状态。该程序不得模拟轨迹；它必须仅使用第 1 部分推导的谱条件进行判断。一致性的概念是所有智能体之间的严格全局一致，即对于任意初始 $x_0$ 都收敛到 $\\mathcal{S}$。\n\n可使用的基本事实：\n- 对于一个无向连通图，其拉普拉斯矩阵 $L$ 是对称半正定的，且具有一个单零特征值，即 $\\lambda_1(L) = 0$ 且对于所有 $i \\in \\{2,\\dots,n\\}$ 都有 $\\lambda_i(L)  0$。\n- 对于对称矩阵 $A \\in \\mathbb{R}^{a \\times a}$ 和 $B \\in \\mathbb{R}^{b \\times b}$，Kronecker 积 $A \\otimes B$ 的特征值是 $A$ 和 $B$ 各自特征值的两两乘积。\n- 序列 $x_{k+1} = M x_k$ 对所有初始条件收敛到与单位模特征值相关的特征空间，当且仅当所有其他特征值都严格位于单位圆盘内部，并且单位圆上的特征值是半单的。\n\n测试套件：\n- 测试 1 (正常情况): $n = 4$, $p = 2$, \n  $$\n  L = \\begin{bmatrix}\n  1  -1  0  0 \\\\\n  -1  2  -1  0 \\\\\n  0  -1  2  -1 \\\\\n  0  0  -1  1\n  \\end{bmatrix}, \n  \\quad \n  C_{\\mathrm{loc}} = \\begin{bmatrix} 1  0 \\\\ 0  2 \\end{bmatrix}, \n  \\quad \n  \\alpha = 0.1464466094067262.\n  $$\n- 测试 2 (边界步长): 与测试 1 相同的 $L$ 和 $C_{\\mathrm{loc}}$，其中\n  $$\n  \\alpha = 0.2928932188134524.\n  $$\n- 测试 3 (步长过大): 与测试 1 相同的 $L$ 和 $C_{\\mathrm{loc}}$，其中\n  $$\n  \\alpha = 0.3661165235168155.\n  $$\n- 测试 4 (不可检测的输出方向): 与测试 1 相同的 $L$，\n  $$\n  C_{\\mathrm{loc}} = \\begin{bmatrix} 1  0 \\\\ 0  0 \\end{bmatrix}, \n  \\quad \n  \\alpha = 0.1.\n  $$\n- 测试 5 (不连通图): $n = 4$, $p = 1$, \n  $$\n  L = \\begin{bmatrix}\n  1  -1  0  0 \\\\\n  -1  1  0  0 \\\\\n  0  0  1  -1 \\\\\n  0  0  -1  1\n  \\end{bmatrix}, \n  \\quad \n  C_{\\mathrm{loc}} = \\begin{bmatrix} 1 \\end{bmatrix}, \n  \\quad \n  \\alpha = 0.5.\n  $$\n\n最终输出规范：\n- 您的程序应生成一行结果，该结果是一个用方括号括起来的逗号分隔列表，即形式为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是对上述第 $i$ 个测试的布尔结果。", "solution": "此问题陈述有效。这是一个在分布式控制理论领域内定义良好、有科学依据的问题。下面我们进行求解。\n\n系统动力学由线性时不变迭代描述：\n$$x_{k+1} = M x_k$$\n其中迭代矩阵 $M \\in \\mathbb{R}^{np \\times np}$ 由下式给出：\n$$M \\triangleq I_{np} - \\alpha \\, (L \\otimes I_p) \\, C.$$\n已知 $C = I_n \\otimes C_{\\mathrm{loc}}$。将此代入 $M$ 的表达式，并使用 Kronecker 积的混合乘积性质 $(A \\otimes B)(D \\otimes F) = (AD \\otimes BF)$，得到：\n$$M = I_n \\otimes I_p - \\alpha (L \\otimes I_p) (I_n \\otimes C_{\\mathrm{loc}}) = I_n \\otimes I_p - \\alpha (L I_n \\otimes I_p C_{\\mathrm{loc}}) = I_n \\otimes I_p - \\alpha (L \\otimes C_{\\mathrm{loc}}).$$\n问题要求对于任意初始条件 $x_0 \\in \\mathbb{R}^{np}$，状态轨迹 $x_k$ 收敛到一致性子空间 $\\mathcal{S} \\triangleq \\{ \\mathbf{1}_n \\otimes v : v \\in \\mathbb{R}^p \\}$。对于线性系统，这意味着状态的非一致分量必须收敛到零。这由矩阵 $M$ 的谱性质决定。具体来说，当且仅当关于 $M$ 谱的两个条件得到满足时，才能保证收敛到子空间 $\\mathcal{S}$：\n1. $M$ 对应于单位模特征值的特征空间恰好是一致性子空间 $\\mathcal{S}$。\n2. $M$ 的所有其他特征值都严格位于复平面的开放单位圆盘内（即，其模长严格小于 1）。\n\n问题陈述指出 $L$（对于无向图）和 $C_{\\mathrm{loc}}$ 都是对称矩阵。因此，它们是可对角化的，并且具有实特征值。设 $L$ 的特征值为 $\\lambda_1(L), \\dots, \\lambda_n(L)$，对应特征向量为 $v_1, \\dots, v_n$。设 $C_{\\mathrm{loc}}$ 的特征值为 $\\mu_1(C_{\\mathrm{loc}}), \\dots, \\mu_p(C_{\\mathrm{loc}})$，对应特征向量为 $u_1, \\dots, u_p$。\nKronecker 积 $L \\otimes C_{\\mathrm{loc}}$ 的特征值是 $L$ 和 $C_{\\mathrm{loc}}$ 特征值的所有两两乘积，即 $\\{\\lambda_i(L)\\mu_j(C_{\\mathrm{loc}})\\}_{i=1,\\dots,n, j=1,\\dots,p}$。对应的特征向量为 $\\{v_i \\otimes u_j\\}_{i,j}$。\n矩阵 $M$ 的形式为 $I - \\alpha A$，其中 $A = L \\otimes C_{\\mathrm{loc}}$。因此，$M$ 的特征值（记为 $\\gamma_{i,j}$）由下式给出：\n$$\\gamma_{i,j} = 1 - \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}}), \\quad \\forall i \\in \\{1,\\dots,n\\}, \\forall j \\in \\{1,\\dots,p\\}.$$\n由于 $L$ 和 $C_{\\mathrm{loc}}$ 是对称的，所以 $L \\otimes C_{\\mathrm{loc}}$ 也是对称的，因此 $M$ 是对称的。这保证了 $M$ 的所有特征值都是实的且是半单的，满足了问题陈述中的条件。\n\n现在我们通过分析特征值 $\\gamma_{i,j}$ 来推导充分必要条件。我们将 $L$ 的特征值排序，使得 $0 \\le \\lambda_1(L) \\le \\lambda_2(L) \\le \\dots \\le \\lambda_n(L)$。\n\n**条件 1：图的连通性**\n任何无向图的图拉普拉斯矩阵 $L$ 都是半正定的，因此 $\\lambda_1(L) = 0$。对应的特征向量是 $v_1 = \\frac{1}{\\sqrt{n}}\\mathbf{1}_n$。对于此模式（$i=1$），$M$ 的特征值为：\n$$\\gamma_{1,j} = 1 - \\alpha \\lambda_1(L) \\mu_j(C_{\\mathrm{loc}}) = 1 - \\alpha \\cdot 0 \\cdot \\mu_j(C_{\\mathrm{loc}}) = 1, \\quad \\forall j \\in \\{1, \\dots, p\\}.$$\n与这 $p$ 个特征值对应的特征向量是 $\\{v_1 \\otimes u_j\\}_{j=1,\\dots,p} = \\{\\frac{1}{\\sqrt{n}}\\mathbf{1}_n \\otimes u_j\\}_{j=1,\\dots,p}$。由于 $C_{\\mathrm{loc}}$ 的特征向量 $\\{u_j\\}$ 构成了 $\\mathbb{R}^p$ 的一组基，这些特征向量的张成空间（span）恰好是一致性子空间 $\\mathcal{S}$。\n为了收敛到 $\\mathcal{S}$，这些必须是唯一的单位模特征值。如果图是不连通的，$L$ 会有多个零特征值。假设 $\\lambda_2(L) = 0$。那么，对于 $i=2$，我们将对所有 $j$ 得到 $\\gamma_{2,j} = 1 - \\alpha \\cdot 0 \\cdot \\mu_j(C_{\\mathrm{loc}}) = 1$。对应于 $\\lambda_2(L)$ 的特征向量 $v_2$ 与 $v_1 = \\frac{1}{\\sqrt{n}}\\mathbf{1}_n$ 正交。因此，特征向量 $\\{v_2 \\otimes u_j\\}$ 代表了不会衰减的非一致状态，从而阻止了系统收敛到全局一致。因此，要求 $L$ 具有一个单零特征值。这当且仅当图是连通的时成立。\n**条件 I：** 图必须是连通的，这等价于 $\\lambda_2(L)  0$。\n\n**条件 2：$C_{\\mathrm{loc}}$ 的可检测性与定性**\n对于所有非一致模式（即，对于所有 $i \\in \\{2, \\dots, n\\}$ 和 $j \\in \\{1, \\dots, p\\}$），我们要求 $M$ 对应的特征值的模严格小于 1：\n$$|\\gamma_{i,j}| = |1 - \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})|  1.$$\n这等价于双边不等式：\n$$-1  1 - \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})  1.$$\n右侧不等式意味着 $0  \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})$。如果任何一个 $\\mu_j(C_{\\mathrm{loc}})$ 为零，这个条件就会被违反。对应的特征值将是 $\\gamma_{i,j}=1$，导致一个不衰减的非一致模式。这对应于可检测性的失效：该模式处于输出矩阵 $C=I_n \\otimes C_{\\mathrm{loc}}$ 的零空间中，因此对于控制反馈是不可观测的。因此，$C_{\\mathrm{loc}}$ 的所有特征值都必须非零。假设为标准的梯度下降形式，其中 $\\alpha  0$，并根据条件 I 知对于 $i  1$ 有 $\\lambda_i(L)  0$，我们必须对所有 $j$ 都有 $\\mu_j(C_{\\mathrm{loc}})  0$。这意味着 $C_{\\mathrm{loc}}$ 必须是正定的。\n**条件 II：** 矩阵 $C_{\\mathrm{loc}}$ 必须是正定的，这等价于其最小特征值满足 $\\mu_{\\min}(C_{\\mathrm{loc}})  0$。\n\n**条件 3：步长 $\\alpha$ 的可容许范围**\n在条件 I 和 II 满足且假设 $\\alpha  0$ 的情况下，不等式 $0  \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})$ 对所有非一致模式均成立。我们剩下不等式的左半部分：\n$$1 - \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})  -1 \\implies \\alpha \\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})  2.$$\n这必须对所有 $i \\in \\{2, \\dots, n\\}$ 和 $j \\in \\{1, \\dots, p\\}$ 成立。为保证这一点，该条件必须对乘积 $\\lambda_i(L) \\mu_j(C_{\\mathrm{loc}})$ 的最大可能值成立。这个最大值是 $\\lambda_{\\max}(L) \\mu_{\\max}(C_{\\mathrm{loc}})$，其中 $\\lambda_{\\max}(L) = \\lambda_n(L)$ 和 $\\mu_{\\max}(C_{\\mathrm{loc}})$ 分别是它们各自矩阵的最大特征值。\n因此，我们必须有 $\\alpha \\lambda_n(L) \\mu_{\\max}(C_{\\mathrm{loc}})  2$，这给出了 $\\alpha$ 的上界：\n$$\\alpha  \\frac{2}{\\lambda_n(L) \\mu_{\\max}(C_{\\mathrm{loc}})}.$$\n结合 $\\alpha0$ 的假设，我们推导出了步长的完整范围。\n**条件 III：** 步长必须满足 $0  \\alpha  \\frac{2}{\\lambda_n(L) \\mu_{\\max}(C_{\\mathrm{loc}})}$。严格不等式至关重要，因为等式将导致一个值为 -1 的特征值，这对应于一个振荡的、不收敛的非一致模式。\n\n总结来说，要使每个轨迹都收敛到一致性子空间 $\\mathcal{S}$，其充分必要条件是：\n1.  **连通性：** 图是连通的 ($\\lambda_2(L)  0$)。\n2.  **可检测性：** 局部输出矩阵 $C_{\\mathrm{loc}}$ 是正定的 ($\\mu_{\\min}(C_{\\mathrm{loc}})  0$)。\n3.  **稳定性：** 步长 $\\alpha$ 在范围 $0  \\alpha  \\frac{2}{\\lambda_n(L) \\mu_{\\max}(C_{\\mathrm{loc}})}$ 内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_convergence_conditions(L, C_loc, alpha):\n    \"\"\"\n    Checks if the necessary and sufficient conditions for convergence to consensus are met.\n\n    Args:\n        L (np.ndarray): The graph Laplacian matrix.\n        C_loc (np.ndarray): The local output matrix.\n        alpha (float): The step size.\n\n    Returns:\n        bool: True if conditions are met, False otherwise.\n    \"\"\"\n    TOL = 1e-9  # Tolerance for floating point comparisons\n\n    # Condition 1: Graph Connectivity\n    # The graph must be connected, which means the Laplacian L has a simple zero eigenvalue.\n    # np.linalg.eigvalsh is used for symmetric matrices. It is faster and more stable.\n    try:\n        lambda_L = np.linalg.eigvalsh(L)\n    except np.linalg.LinAlgError:\n        return False  # Matrix is not valid\n    \n    n = L.shape[0]\n    if n  1:\n        # The second smallest eigenvalue must be strictly positive.\n        if lambda_L[1] = TOL:\n            return False  # Graph is not connected\n    \n    # Condition 2: C_loc Definiteness\n    # C_loc must be positive definite, meaning all its eigenvalues are strictly positive.\n    try:\n        mu_C = np.linalg.eigvalsh(C_loc)\n    except np.linalg.LinAlgError:\n        return False  # Matrix is not valid\n        \n    mu_min = mu_C.min()\n    if mu_min = TOL:\n        return False  # C_loc is not positive definite\n    \n    # Condition 3: Step Size Range\n    # The step size alpha must be in the range 0  alpha  2 / (lambda_max(L) * mu_max(C_loc)).\n    lambda_max = lambda_L[-1]\n    mu_max = mu_C.max()\n    \n    # If the graph has only one node, lambda_max is 0.\n    # In this case, consensus is trivial, and any positive alpha works\n    # assuming C_loc is PD. However, all test cases have n  1.\n    if lambda_max = TOL:\n        # This case is handled by Condition 1 for n  1.\n        # This is just a safeguard.\n        return True\n        \n    alpha_upper_bound = 2.0 / (lambda_max * mu_max)\n    \n    # The inequalities must be strict.\n    is_alpha_valid = (alpha  TOL) and (alpha  alpha_upper_bound)\n    \n    if not is_alpha_valid:\n        return False\n        \n    # All three conditions are satisfied.\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Test 1: Happy path\n    L1 = np.array([\n        [1, -1, 0, 0],\n        [-1, 2, -1, 0],\n        [0, -1, 2, -1],\n        [0, 0, -1, 1]\n    ], dtype=float)\n    C_loc1 = np.array([\n        [1, 0],\n        [0, 2]\n    ], dtype=float)\n    alpha1 = 0.1464466094067262\n    \n    # Test 2: Boundary step size\n    L2 = L1\n    C_loc2 = C_loc1\n    alpha2 = 0.2928932188134524\n    \n    # Test 3: Too large step size\n    L3 = L1\n    C_loc3 = C_loc1\n    alpha3 = 0.3661165235168155\n    \n    # Test 4: Undetectable output directions\n    L4 = L1\n    C_loc4 = np.array([\n        [1, 0],\n        [0, 0]\n    ], dtype=float)\n    alpha4 = 0.1\n    \n    # Test 5: Disconnected graph\n    L5 = np.array([\n        [1, -1, 0, 0],\n        [-1, 1, 0, 0],\n        [0, 0, 1, -1],\n        [0, 0, -1, 1]\n    ], dtype=float)\n    C_loc5 = np.array([[1]], dtype=float)\n    alpha5 = 0.5\n    \n    test_cases = [\n        (L1, C_loc1, alpha1),\n        (L2, C_loc2, alpha2),\n        (L3, C_loc3, alpha3),\n        (L4, C_loc4, alpha4),\n        (L5, C_loc5, alpha5)\n    ]\n    \n    results = []\n    for L, C_loc, alpha in test_cases:\n        result = check_convergence_conditions(L, C_loc, alpha)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2702015"}, {"introduction": "最后，我们将分布式系统的原理应用于一个控制设计挑战。此练习通过比较一个最优的集中式线性二次调节器(LQR)控制器和一个受约束的局部化控制器，探讨了性能与通信及计算结构之间的基本权衡。你将获得设计结构化控制器和量化评估其次优性的实践经验。[@problem_id:2702021]", "problem": "考虑一个由$n$个节点组成的一维链式离散时间线性时不变网络化系统，节点间存在最近邻耦合。状态向量为 $x_{t} \\in \\mathbb{R}^{n}$，控制输入为 $u_{t} \\in \\mathbb{R}^{n}$，动力学由 $x_{t+1} = A x_{t} + B u_{t}$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其主对角线上的元素为 $a$，第一条次对角线和超对角线上的元素为 $c$，且 $B = I_{n}$。性能通过无穷时域二次代价 $J = \\sum_{t=0}^{\\infty} \\left( x_{t}^{\\top} Q x_{t} + u_{t}^{\\top} R u_{t} \\right)$ 来衡量，其中 $Q = q I_{n}$ 且 $R = r I_{n}$，$q  0$，$r  0$。\n\n将集中式线性二次调节器 (LQR) 定义为最优静态状态反馈 $u_{t} = -K_{\\mathrm{cen}} x_{t}$，它在所有静态增益中使 $J$ 最小化。将局部性半径为 $1$ 的局部化线性二次调节器 (LLQR) 定义为任意静态反馈 $u_{t} = -K_{\\mathrm{loc}} x_{t}$，其中增益矩阵 $K_{\\mathrm{loc}} \\in \\mathbb{R}^{n \\times n}$ 是半带宽为 $1$ 的带状矩阵，即当 $\\lvert i - j \\rvert  1$ 时，$\\left(K_{\\mathrm{loc}}\\right)_{ij} = 0$。\n\n您必须计算 $K_{\\mathrm{cen}}$ 并使用以下保持局部性的综合规则来构造 $K_{\\mathrm{loc}}$：\n- 对每个节点索引 $i \\in \\{1,2,\\dots,n\\}$，形成局部索引集 $S_{i} = \\{j \\in \\{1,2,\\dots,n\\} : \\lvert j - i \\rvert \\le 1\\}$。\n- 通过将 $A$ 和 $B$ 限制在由 $S_{i}$ 索引的行和列，提取局部子系统矩阵 $A_{S_{i}} \\in \\mathbb{R}^{\\lvert S_{i} \\rvert \\times \\lvert S_{i} \\rvert}$ 和 $B_{S_{i}} = I_{\\lvert S_{i} \\rvert}$。\n- 在此局部子系统上，针对局部代价 $Q_{S_{i}} = q I_{\\lvert S_{i} \\rvert}$ 和 $R_{S_{i}} = r I_{\\lvert S_{i} \\rvert}$，综合集中式 LQR 增益，从而得到一个局部增益矩阵 $K_{S_{i}} \\in \\mathbb{R}^{\\lvert S_{i} \\rvert \\times \\lvert S_{i} \\rvert}$。\n- 令 $p$ 为索引 $i$ 在有序集 $S_{i}$ 中的位置，通过将 $K_{S_{i}}$ 的第 $p$ 行置于由 $S_{i}$ 索引的列中来设置 $K_{\\mathrm{loc}}$ 的第 $i$ 行，该行中所有其他条目均为 $0$。\n\n为定量地比较这两个控制器，请使用标准的无穷时域代价矩阵。对于集中式 LQR，令 $P_{\\mathrm{cen}} \\in \\mathbb{R}^{n \\times n}$ 表示与初始状态 $x_{0}$ 的最小代价 $J = x_{0}^{\\top} P_{\\mathrm{cen}} x_{0}$ 相关联的最优代价矩阵。对于局部化控制器 $K_{\\mathrm{loc}}$，定义闭环矩阵 $A_{\\mathrm{cl,loc}} = A - B K_{\\mathrm{loc}}$ 和相应的代价矩阵 $P_{\\mathrm{loc}}$，该矩阵是离散时间李雅普诺夫方程 $P_{\\mathrm{loc}} = A_{\\mathrm{cl,loc}}^{\\top} P_{\\mathrm{loc}} A_{\\mathrm{cl,loc}} + \\left(Q + K_{\\mathrm{loc}}^{\\top} R K_{\\mathrm{loc}}\\right)$ 的唯一解，前提是 $A_{\\mathrm{cl,loc}}$ 是Schur稳定的（所有特征值严格在单位圆内）。如果 $A_{\\mathrm{cl,loc}}$ 不是Schur稳定的，则将代价视为无界。\n\n对于每个测试用例，您的程序必须计算标量比率 $\\rho = \\operatorname{trace}\\left(P_{\\mathrm{loc}}\\right) \\big/ \\operatorname{trace}\\left(P_{\\mathrm{cen}}\\right)$，该比率等于当初始状态 $x_{0}$ 服从零均值和单位协方差分布时的期望无穷时域代价之比。如果 $A_{\\mathrm{cl,loc}}$ 不是Schur稳定的，则该测试用例的输出为 $+\\infty$。\n\n使用以下参数集测试套件，其中每个用例指定 $(n, a, c, q, r)$:\n- 用例 1: $n = 5$, $a = 0.6$, $c = 0.15$, $q = 1.0$, $r = 0.1$。\n- 用例 2: $n = 8$, $a = 0.7$, $c = 0.10$, $q = 1.0$, $r = 0.5$。\n- 用例 3: $n = 3$, $a = 0.95$, $c = 0.02$, $q = 1.0$, $r = 0.01$。\n\n实现要求:\n- 构造三对角矩阵 $A$，其条目为：对所有 $i$，$A_{ii} = a$；对所有 $i \\in \\{1,2,\\dots,n-1\\}$，$A_{i,i+1} = c$；对所有 $i \\in \\{1,2,\\dots,n-1\\}$，$A_{i+1,i} = c$。并设置 $B = I_{n}$。\n- 使用离散时间系统的标准集中式 LQR 方法计算 $K_{\\mathrm{cen}}$，并从同一解中一致地获得 $P_{\\mathrm{cen}}$。\n- 使用上面给出的保持局部性的综合规则构建 $K_{\\mathrm{loc}}$，然后在 $A_{\\mathrm{cl,loc}}$ 是Schur稳定的情况下，通过离散时间李雅普诺夫方程评估 $P_{\\mathrm{loc}}$。\n- 对每个用例，以浮点数形式输出比率 $\\rho$。\n\n最终输出规范:\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试用例相同。例如，输出应类似于 $[\\rho_{1},\\rho_{2},\\rho_{3}]$。\n- 不涉及物理单位。\n- 不会出现角度。\n- 将每个 $\\rho$ 表示为浮点十进制数。", "solution": "所提出的问题是现代控制理论中一个适定且标准的练习，特别关注网络化系统控制器设计中最优性与去中心化之间的权衡。我们将进行严格的分析。目标是计算一个性能比率 $\\rho$，该比率量化了一个结构化的局部控制器相对于全局最优的集中式控制器的次优性。\n\n系统动力学由离散时间线性时不变方程给出：\n$$x_{t+1} = A x_{t} + B u_{t}$$\n其中 $x_{t} \\in \\mathbb{R}^{n}$ 是状态， $u_{t} \\in \\mathbb{R}^{n}$ 是控制输入。系统矩阵为 $A \\in \\mathbb{R}^{n \\times n}$，一个主对角线上元素为 $a$、第一条次对角线上元素为 $c$ 的三对角矩阵，以及 $B = I_{n}$，即 $n \\times n$ 的单位矩阵。性能目标是最小化无穷时域二次代价：\n$$J = \\sum_{t=0}^{\\infty} \\left( x_{t}^{\\top} Q x_{t} + u_{t}^{\\top} R u_{t} \\right)$$\n其中加权矩阵为 $Q = q I_{n}$ ($q  0$) 和 $R = r I_{n}$ ($r  0$)。\n\n首先，我们分析集中式线性二次调节器 (LQR)。最优控制律是一个静态状态反馈 $u_{t} = -K_{\\mathrm{cen}} x_{t}$。最优增益 $K_{\\mathrm{cen}}$ 和相关的待付代价矩阵 $P_{\\mathrm{cen}}$ 通过求解离散代数黎卡提方程 (DARE) 找到。对于一个通用系统 $(A, B)$ 和代价 $(Q, R)$，DARE 为：\n$$P = A^{\\top} P A - (A^{\\top} P B)(R + B^{\\top} P B)^{-1}(B^{\\top} P A) + Q$$\n此方程的解 $P$ 是最优代价矩阵，因此 $P_{\\mathrm{cen}} = P$。这意味着从初始状态 $x_{0}$ 开始的最小代价是 $J^{*} = x_{0}^{\\top} P_{\\mathrm{cen}} x_{0}$。由于 $B=I_{n}$，系统对 $(A, B)$ 是可控的；由于 $Q=qI_{n}$ 且 $q0$，系统对 $(A, Q^{1/2})$ 是可观的。这些条件保证了存在一个唯一的正定解 $P_{\\mathrm{cen}}$，它能产生一个稳定的反馈增益。\n\n最优集中式反馈增益由下式给出：\n$$K_{\\mathrm{cen}} = (R + B^{\\top} P_{\\mathrm{cen}} B)^{-1}(B^{\\top} P_{\\mathrm{cen}} A)$$\n代入 $B = I_{n}$ 和 $R = r I_{n}$，上式简化为：\n$$K_{\\mathrm{cen}} = (r I_{n} + P_{\\mathrm{cen}})^{-1}(P_{\\mathrm{cen}} A)$$\n我们将数值求解 DARE 以找到 $P_{\\mathrm{cen}}$，然后计算 $K_{\\mathrm{cen}}$。\n\n接下来，我们遵循指定的综合规则来构造局部化控制器 $K_{\\mathrm{loc}}$。这是一个自下而上的设计过程，它从局部最优解构建全局控制器。对每个节点 $i \\in \\{1, 2, \\dots, n\\}$，我们定义一个局部邻域 $S_{i} = \\{j \\in \\{1, \\dots, n\\} : |j - i| \\le 1\\}$。该集合的大小 $|S_{i}|$ 对于边界节点（$i=1$ 和 $i=n$）为 $2$，对于内部节点（$1  i  n$，假设 $n  2$）为 $3$。\n\n对每个 $i$，我们提取局部子系统矩阵。$A_{S_{i}}$ 是通过选择索引在 $S_{i}$ 中的行和列从 $A$ 中形成的子矩阵。局部输入和代价矩阵为 $B_{S_{i}} = I_{|S_{i}|}$，$Q_{S_{i}} = q I_{|S_{i}|}$，和 $R_{S_{i}} = r I_{|S_{i}|}$。然后我们为这个更小的局部 LQR 问题求解 DARE：\n$$P_{S_{i}} = A_{S_{i}}^{\\top} P_{S_{i}} A_{S_{i}} - (A_{S_{i}}^{\\top} P_{S_{i}} B_{S_{i}})(R_{S_{i}} + B_{S_{i}}^{\\top} P_{S_{i}} B_{S_{i}})^{-1}(B_{S_{i}}^{\\top} P_{S_{i}} A_{S_{i}}) + Q_{S_{i}}$$\n相应的局部最优增益为 $K_{S_{i}} = (R_{S_{i}} + B_{S_{i}}^{\\top} P_{S_{i}} B_{S_{i}})^{-1}(B_{S_{i}}^{\\top} P_{S_{i}} A_{S_{i}})$。\n\n全局局部化增益矩阵 $K_{\\mathrm{loc}}$ 是逐行组装的。对每个节点 $i$，令 $p$ 为索引 $i$ 在有序集 $S_{i}$ 中的位置。$K_{\\mathrm{loc}}$ 的第 $i$ 行是通过取局部增益矩阵 $K_{S_{i}}$ 的第 $p$ 行，并将其元素放入 $K_{\\mathrm{loc}}$ 的第 $i$ 行中与 $S_{i}$ 中索引相对应的列来构造的。$K_{\\mathrm{loc}}$ 的第 $i$ 行中的所有其他条目均为零。这种构造确保了当 $|i-j|  1$ 时 $(K_{\\mathrm{loc}})_{ij} = 0$，从而强制实现了所需的局部性结构。\n\n使用局部化控制器 $u_{t} = -K_{\\mathrm{loc}} x_{t}$，闭环系统动力学变为：\n$$x_{t+1} = (A - B K_{\\mathrm{loc}}) x_{t} = (A - K_{\\mathrm{loc}}) x_{t}$$\n令 $A_{\\mathrm{cl,loc}} = A - K_{\\mathrm{loc}}$。该控制器的性能由代价矩阵 $P_{\\mathrm{loc}}$ 决定，该矩阵是离散时间李雅普诺夫方程的解，前提是 $A_{\\mathrm{cl,loc}}$ 是 Schur 稳定的（其所有特征值都严格位于复平面的单位圆内）。李雅普诺夫方程为：\n$$P_{\\mathrm{loc}} = A_{\\mathrm{cl,loc}}^{\\top} P_{\\mathrm{loc}} A_{\\mathrm{cl,loc}} + Q + K_{\\mathrm{loc}}^{\\top} R K_{\\mathrm{loc}}$$\n如果 $A_{\\mathrm{cl,loc}}$ 不是 Schur 稳定的，定义代价 $J$ 的和会发散，代价被认为是无限的。如果是稳定的，则存在一个唯一的正定解 $P_{\\mathrm{loc}}$。我们将数值求解这个线性矩阵方程。一个标准方法是向量化该方程：令 $p_{\\mathrm{loc}} = \\operatorname{vec}(P_{\\mathrm{loc}})$ 和 $M = Q + K_{\\mathrm{loc}}^{\\top} R K_{\\mathrm{loc}}$。方程变为 $(I_{n^2} - A_{\\mathrm{cl,loc}}^{\\top} \\otimes A_{\\mathrm{cl,loc}}^{\\top}) p_{\\mathrm{loc}} = \\operatorname{vec}(M)$，这是一个标准的线性系统。\n\n最后，我们计算所需比率 $\\rho$。该比率比较了两种控制方案下的期望代价，其中期望是针对从零均值和单位协方差 $\\mathbb{E}[x_{0}x_{0}^{\\top}] = I_{n}$ 的分布中抽取的初始状态 $x_{0}$ 计算的。期望代价为 $\\mathbb{E}[x_{0}^{\\top} P x_{0}] = \\operatorname{trace}(P \\mathbb{E}[x_{0}x_{0}^{\\top}]) = \\operatorname{trace}(P)$。因此，性能比率为：\n$$\\rho = \\frac{\\operatorname{trace}(P_{\\mathrm{loc}})}{\\operatorname{trace}(P_{\\mathrm{cen}})}$$\n如果 $P_{\\mathrm{loc}}$ 是无界的，我们设置 $\\rho = +\\infty$。现在，我们将对每个指定的测试用例进行计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_discrete_are, solve_lyapunov, LinAlgError\n\ndef solve():\n    \"\"\"\n    Solves the control theory problem for centralized and localized LQR controllers.\n    \"\"\"\n    test_cases = [\n        # (n, a, c, q, r)\n        (5, 0.6, 0.15, 1.0, 0.1),\n        (8, 0.7, 0.10, 1.0, 0.5),\n        (3, 0.95, 0.02, 1.0, 0.01),\n    ]\n\n    results = []\n    for n, a, c, q, r in test_cases:\n        # Construct system matrices A, B, Q, R\n        A = np.diag(np.full(n, a)) + np.diag(np.full(n - 1, c), k=1) + np.diag(np.full(n - 1, c), k=-1)\n        B = np.eye(n)\n        Q = q * np.eye(n)\n        R = r * np.eye(n)\n\n        # 1. Centralized LQR\n        # Solve Discrete Algebraic Riccati Equation (DARE) for P_cen\n        # X = A'XA - (A'XB)(R+B'XB)^-1(B'XA) + Q\n        try:\n            P_cen = solve_discrete_are(A, B, Q, R)\n        except LinAlgError:\n            # Should not happen for these parameters as system is controllable and observable\n            results.append(np.inf)\n            continue\n        \n        # 2. Localized LQR (LLQR) Synthesis\n        K_loc = np.zeros((n, n))\n        for i in range(n):\n            # Define local index set Si (using 0-based indexing)\n            s_i_indices = []\n            if i  0:\n                s_i_indices.append(i - 1)\n            s_i_indices.append(i)\n            if i  n - 1:\n                s_i_indices.append(i + 1)\n            \n            s_i_size = len(s_i_indices)\n            \n            # Extract local subsystem matrices\n            A_si = A[np.ix_(s_i_indices, s_i_indices)]\n            B_si = np.eye(s_i_size)\n            Q_si = q * np.eye(s_i_size)\n            R_si = r * np.eye(s_i_size)\n            \n            # Solve local DARE\n            P_si = solve_discrete_are(A_si, B_si, Q_si, R_si)\n\n            # Compute local gain K_si\n            # K = (R + B'PB)^-1 B'PA\n            K_si = np.linalg.inv(R_si + B_si.T @ P_si @ B_si) @ (B_si.T @ P_si @ A_si)\n            \n            # Find the position 'p' of index 'i' in S_i\n            p = s_i_indices.index(i)\n            \n            # Place the p-th row of K_si into the i-th row of K_loc\n            K_loc[i, s_i_indices] = K_si[p, :]\n\n        # 3. Evaluate LLQR performance\n        A_cl_loc = A - B @ K_loc\n        \n        # Check Schur stability\n        eigvals = np.linalg.eigvals(A_cl_loc)\n        if np.any(np.abs(eigvals) = 1.0):\n            results.append(np.inf)\n            continue\n\n        # Solve discrete-time Lyapunov equation for P_loc\n        # P = A_cl' * P * A_cl + M, where M = Q + K_loc' * R * K_loc\n        M = Q + K_loc.T @ R @ K_loc\n        \n        # Solving P = A'PA + Q using Kronecker product:\n        # (I - A' kron A')vec(P) = vec(Q)\n        # In our case A is A_cl_loc and Q is M\n        kron_mat = np.kron(A_cl_loc.T, A_cl_loc.T)\n        I_n2 = np.eye(n * n)\n        \n        try:\n            vec_Ploc = np.linalg.solve(I_n2 - kron_mat, M.flatten())\n            P_loc = vec_Ploc.reshape((n, n))\n        except LinAlgError:\n            # Can happen if (I - kron) is singular, related to eigenvalues on unit circle\n            results.append(np.inf)\n            continue\n            \n        # 4. Compute the ratio rho\n        trace_P_cen = np.trace(P_cen)\n        trace_P_loc = np.trace(P_loc)\n        \n        if trace_P_cen == 0: # Avoid division by zero\n            rho = np.inf if trace_P_loc  0 else 1.0\n        else:\n            rho = trace_P_loc / trace_P_cen\n        \n        results.append(rho)\n\n    # Format output as requested\n    formatted_results = [f\"{r:.7f}\" if r != np.inf else \"inf\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2702021"}]}