{"hands_on_practices": [{"introduction": "我们将从一个连续时间域的完整设计与分析问题开始。这个练习将引导你实践史密斯预估器的核心思想：首先为系统的无延迟部分 $G(s)$ 设计一个控制器，然后通过预估器结构将此控制器应用于带有时滞的完整系统。通过推导闭环传递函数，你将亲眼见证史密斯预估器如何巧妙地将时滞项 $e^{-Ls}$ 从系统的特征方程中移除，从而简化控制设计并提升系统性能 [@problem_id:2696599]。", "problem": "考虑一个稳定的、严格真分数的时滞对象，其传递函数为 $P(s)=G(s)\\exp(-Ls)$，其中 $G(s)=\\frac{1}{(s+1)^{2}}$ 且 $L=1$（时间单位为秒）。一个形式为 $C(s)=k\\frac{s+z}{s+p}$ 的严格真分数控制器被用于一个史密斯预估器结构中，该结构使用了对象的精确内部模型。你需要为无时滞对象 $G(s)$ 设计 $C(s)$，然后解析推导在使用和不使用史密斯预估器两种情况下的闭环传递函数。\n\n从史密斯预估器结构的定义和标准框图代数出发，完成以下步骤：\n\n1) 对于围绕 $G(s)$ 的无时滞环路，要求闭环特征多项式具有位于 $s=-a$ 的三阶实数重极点（其中 $a=\\frac{2}{3}$），并且从参考输入到输出的无时滞闭环系统具有单位稳态增益。使用这两项指标来确定 $k$、$z$ 和 $p$ 的值。\n\n2) 使用精确的史密斯预估器（具有精确的内部模型）和步骤 1 中得到的 $C(s)$，从基本原理出发，为整体的时滞对象推导从参考输入到输出的闭环传递函数 $T_{\\mathrm{SP}}(s)$。然后推导其在时域中对应的单位阶跃响应 $y_{\\mathrm{SP}}(t)$。\n\n3) 作为对比，推导不使用史密斯预估器时的标准单位反馈闭环传递函数 $T_{\\mathrm{NP}}(s)$，并写出其特征方程。根据特征方程中是否存在指数因子，简要说明极点位置有何不同。\n\n请给出仅含变量 $s$ 的 $T_{\\mathrm{SP}}(s)$ 的解析表达式作为最终答案。无需进行数值取整。最终答案表达式中请勿包含物理单位。", "solution": "首先将对问题陈述的科学合理性、完整性和客观性进行验证。\n\n步骤 1：提取已知条件\n- 对象传递函数：$P(s)=G(s)\\exp(-Ls)$\n- 对象的无时滞部分：$G(s)=\\frac{1}{(s+1)^{2}}$\n- 时滞：$L=1$\n- 控制器形式：$C(s)=k\\frac{s+z}{s+p}$，陈述为严格真分数。\n- 使用精确内部模型 ($G_m(s)=G(s)$, $L_m=L$) 的史密斯预估器配置。\n- 无时滞环路（$C(s)$ 和 $G(s)$）的设计指标 1：闭环特征多项式为 $(s+a)^3$，其中 $a=\\frac{2}{3}$。\n- 无时滞环路的设计指标 2：从参考输入到输出的闭环传递函数具有单位稳态增益。\n\n步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是控制理论中一个关于时滞系统史密斯预估器设计与分析的标准练习。所有概念都是该领域的基础。该问题具有科学合理性。\n- **适定性**：问题提供了足够的指标（极点配置和稳态增益）来唯一确定控制器参数。各项任务定义清晰且顺序明确。\n- **客观性**：问题以精确的数学和工程术语陈述，不含主观性。\n- **完整性与一致性**：该问题基本自洽。存在一个微小的不一致之处：问题要求控制器是“严格真分数”的，但为实现特定的三阶特征多项式和单位稳态增益而设定的设计指标，导出的控制器在原点处有一个极点 ($p=0$)，这是一个比例-积分（PI）控制器。PI 控制器是真分数的，但不是严格真分数的。这在此类设计问题中是常见结果，并不会使问题无法解决。其意图是明确的，求解参数的方法是清晰的。我们将继续进行，并注意到这个术语上的微小不精确性。\n\n步骤 3：结论与行动\n该问题被判定为有效，仅需注意关于“严格真分数”控制器术语的微小说明。将提供完整的解答。\n\n**第 1 部分：控制器设计**\n\n我们首先考虑由控制器 $C(s)$ 和无时滞对象 $G(s)$ 在单位反馈配置下组成的无时滞反馈环路。其开环传递函数为 $L_0(s) = C(s)G(s)$。\n$$L_0(s) = \\left( k\\frac{s+z}{s+p} \\right) \\left( \\frac{1}{(s+1)^2} \\right) = \\frac{k(s+z)}{(s+p)(s+1)^2}$$\n这个无时滞系统的闭环传递函数 $T_0(s)$ 由下式给出：\n$$T_0(s) = \\frac{L_0(s)}{1+L_0(s)} = \\frac{\\frac{k(s+z)}{(s+p)(s+1)^2}}{1+\\frac{k(s+z)}{(s+p)(s+1)^2}} = \\frac{k(s+z)}{(s+p)(s+1)^2 + k(s+z)}$$\n无时滞闭环系统的特征多项式是 $T_0(s)$ 的分母：\n$$\\Delta_0(s) = (s+p)(s+1)^2 + k(s+z)$$\n展开此多项式，我们得到：\n$$\\Delta_0(s) = (s+p)(s^2+2s+1) + ks+kz = s^3 + 2s^2 + s + ps^2 + 2ps + p + ks + kz$$\n$$\\Delta_0(s) = s^3 + (2+p)s^2 + (1+2p+k)s + (p+kz)$$\n问题要求这个特征多项式具有位于 $s=-a$ 的三阶实数重极点，其中 $a=\\frac{2}{3}$。期望的特征多项式为：\n$$\\Delta_{\\text{desired}}(s) = \\left(s+\\frac{2}{3}\\right)^3 = s^3 + 3s^2\\left(\\frac{2}{3}\\right) + 3s\\left(\\frac{2}{3}\\right)^2 + \\left(\\frac{2}{3}\\right)^3 = s^3 + 2s^2 + \\frac{4}{3}s + \\frac{8}{27}$$\n通过令 $\\Delta_0(s)$ 和 $\\Delta_{\\text{desired}}(s)$ 的系数相等：\n\\begin{itemize}\n    \\item $s^2$ 的系数: $2+p = 2 \\implies p=0$。\n    \\item $s^1$ 的系数: $1+2p+k = \\frac{4}{3} \\implies 1+2(0)+k = \\frac{4}{3} \\implies k=\\frac{1}{3}$。\n    \\item $s^0$ 的系数: $p+kz = \\frac{8}{27} \\implies 0 + \\left(\\frac{1}{3}\\right)z = \\frac{8}{27} \\implies z=\\frac{8}{9}$。\n\\end{itemize}\n得到的控制器是：\n$$C(s) = \\frac{1}{3}\\frac{s+8/9}{s} = \\frac{s+8/9}{3s}$$\n这是一个 PI 控制器。如前所述，它是真分数的（分母阶次 = 分子阶次），但不是严格真分数的。\n\n第二项指标是无时滞闭环必须具有单位稳态增益。稳态增益是传递函数 $T_0(s)$ 在 $s=0$ 处的值。\n$$T_0(s) = \\frac{k(s+z)}{(s+a)^3} = \\frac{\\frac{1}{3}(s+\\frac{8}{9})}{(s+\\frac{2}{3})^3}$$\n稳态增益为 $T_0(0)$:\n$$T_0(0) = \\frac{\\frac{1}{3}(\\frac{8}{9})}{(\\frac{2}{3})^3} = \\frac{\\frac{8}{27}}{\\frac{8}{27}} = 1$$\n我们的设计满足了此项指标。\n\n**第 2 部分：史密斯预估器分析**\n\n史密斯预估器结构的通用闭环传递函数是：\n$$T_{\\mathrm{SP}}(s) = \\frac{C(s)P(s)}{1 + C(s)G_m(s) + C(s)(P(s) - P_m(s))}$$\n其中 $P(s) = G(s)\\exp(-Ls)$ 是实际对象，$P_m(s)=G_m(s)\\exp(-L_m s)$ 是模型。问题陈述使用了精确的内部模型，因此 $G_m(s) = G(s)$ 且 $L_m = L$。表达式可大大简化为：\n$$T_{\\mathrm{SP}}(s) = \\frac{C(s)G(s)\\exp(-Ls)}{1 + C(s)G(s) + C(s)(G(s)\\exp(-Ls) - G(s)\\exp(-Ls))} = \\frac{C(s)G(s)\\exp(-Ls)}{1 + C(s)G(s)}$$\n项 $\\frac{C(s)G(s)}{1 + C(s)G(s)}$ 正是无时滞系统的闭环传递函数 $T_0(s)$。因此：\n$$T_{\\mathrm{SP}}(s) = T_0(s) \\exp(-Ls)$$\n代入前面推导出的 $T_0(s)$ 表达式：\n$$T_{\\mathrm{SP}}(s) = \\frac{\\frac{1}{3}(s+\\frac{8}{9})}{(s+\\frac{2}{3})^3} \\exp(-s)$$\n我们简化这个表达式：\n$$T_{\\mathrm{SP}}(s) = \\frac{\\frac{1}{3}\\frac{9s+8}{9}}{(\\frac{3s+2}{3})^3} \\exp(-s) = \\frac{\\frac{9s+8}{27}}{\\frac{(3s+2)^3}{27}} \\exp(-s) = \\frac{9s+8}{(3s+2)^3} \\exp(-s)$$\n这就是所求的闭环传递函数。\n\n为了求取单位阶跃响应 $y_{\\mathrm{SP}}(t)$，我们将 $T_{\\mathrm{SP}}(s)$ 乘以单位阶跃的拉普拉斯变换 $R(s) = \\frac{1}{s}$：\n$$Y_{\\mathrm{SP}}(s) = T_{\\mathrm{SP}}(s) \\frac{1}{s} = \\frac{9s+8}{s(3s+2)^3} \\exp(-s)$$\n响应 $y_{\\mathrm{SP}}(t)$ 是 $Y_{\\mathrm{SP}}(s)$ 的拉普拉斯逆变换。令 $Y_0(s) = \\frac{9s+8}{s(3s+2)^3}$。那么 $y_{\\mathrm{SP}}(t) = \\mathcal{L}^{-1}\\{Y_0(s)\\exp(-s)\\} = y_0(t-1)u(t-1)$，其中 $y_0(t) = \\mathcal{L}^{-1}\\{Y_0(s)\\}$，$u(t)$ 是亥维赛阶跃函数。我们对 $Y_0(s)$ 进行部分分式展开：\n$$Y_0(s) = \\frac{9s+8}{27s(s+\\frac{2}{3})^3} = \\frac{A}{s} + \\frac{B_1}{s+\\frac{2}{3}} + \\frac{B_2}{(s+\\frac{2}{3})^2} + \\frac{B_3}{(s+\\frac{2}{3})^3}$$\n求得系数为 $A=1$, $B_1=-1$, $B_2=-\\frac{2}{3}$ 和 $B_3=-\\frac{1}{9}$。\n$$Y_0(s) = \\frac{1}{s} - \\frac{1}{s+\\frac{2}{3}} - \\frac{2/3}{(s+\\frac{2}{3})^2} - \\frac{1/9}{(s+\\frac{2}{3})^3}$$\n使用性质 $\\mathcal{L}^{-1}\\left\\{\\frac{1}{(s+a)^n}\\right\\} = \\frac{t^{n-1}}{(n-1)!}\\exp(-at)$ 进行拉普拉斯逆变换：\n$$y_0(t) = \\left(1 - \\exp(-\\frac{2}{3}t) - \\frac{2}{3}t\\exp(-\\frac{2}{3}t) - \\frac{1}{9}\\frac{t^2}{2!}\\exp(-\\frac{2}{3}t)\\right)u(t)$$\n$$y_0(t) = \\left(1 - \\exp(-\\frac{2}{3}t)\\left[1 + \\frac{2}{3}t + \\frac{1}{18}t^2\\right]\\right)u(t)$$\n因此，最终的响应为：\n$$y_{\\mathrm{SP}}(t) = \\left(1 - \\exp(-\\frac{2}{3}(t-1))\\left[1 + \\frac{2}{3}(t-1) + \\frac{1}{18}(t-1)^2\\right]\\right)u(t-1)$$\n\n**第 3 部分：与标准反馈的比较**\n\n在不使用史密斯预估器时，系统是一个标准的单位反馈环路，包含控制器 $C(s)$ 和对象 $P(s)=G(s)\\exp(-Ls)$。其闭环传递函数 $T_{\\mathrm{NP}}(s)$ 为：\n$$T_{\\mathrm{NP}}(s) = \\frac{C(s)P(s)}{1+C(s)P(s)} = \\frac{C(s)G(s)\\exp(-Ls)}{1+C(s)G(s)\\exp(-Ls)}$$\n代入 $C(s)$ 和 $G(s)$ 的表达式：\n$$T_{\\mathrm{NP}}(s) = \\frac{\\frac{s+8/9}{3s(s+1)^2}\\exp(-s)}{1+\\frac{s+8/9}{3s(s+1)^2}\\exp(-s)} = \\frac{(s+8/9)\\exp(-s)}{3s(s+1)^2 + (s+8/9)\\exp(-s)}$$\n将分母设为零，即可得到特征方程：\n$$1+C(s)G(s)\\exp(-Ls) = 0 \\implies 3s(s+1)^2 + (s+8/9)\\exp(-s) = 0$$\n根本区别在于特征方程。\n- **使用史密斯预估器**：特征方程为 $1+C(s)G(s)=0$，即 $(s+\\frac{2}{3})^3=0$。这是一个多项式方程，具有有限数量的极点（三个位于 $s=-2/3$ 的极点）。时滞被有效地从稳定性判定环路中移除，从而可以进行常规的极点配置。\n- **不使用史密斯预估器**：特征方程为 $1+C(s)G(s)\\exp(-s)=0$。这是一个超越方程，也称为拟多项式。由于存在 $\\exp(-s)$ 项，它在 s 平面中拥有无穷多个极点，这使得稳定性分析和控制器设计变得异常复杂。与理想的史密斯预估器情况相比，时滞通常会导致系统性能下降。", "answer": "$$\\boxed{\\frac{9s+8}{(3s+2)^{3}}\\exp(-s)}$$", "id": "2696599"}, {"introduction": "在掌握了基本设计方法后，我们将深入探讨史密斯预估器一个更精妙且强大的特性。本练习旨在分析传感器噪声 $n(s)$ 如何影响控制器的输出 $U(s)$。你将通过推导发现一个引人注目的结论：在模型完全精确的理想情况下，从噪声到控制输入的传递函数与系统的时滞 $L$ 无关，这深刻揭示了史密斯预估器隔离时滞影响的本质 [@problem_id:2696670]。", "problem": "考虑一个具有输入-输出纯时间延迟的单输入/单输出线性时不变被控对象。该被控对象由传递函数 $P(s) = G_{0}(s)\\exp(-Ls)$ 给出，其中 $G_{0}(s)$ 是严格真分且稳定的， $L \\ge 0$ 是延迟时间。测量输出受到加性传感器噪声的干扰，因此 $y_{m}(s) = y(s) + n(s)$，其中 $n(s)$ 是传感器噪声信号的拉普拉斯变换。系统采用 Smith 预估器，使用标称模型 $\\hat{P}(s) = \\hat{G}_{0}(s)\\exp(-\\hat{L}s)$ 通过预估器为控制器构建一个无延迟反馈。该预估器构建内部估计值\n$$\n\\hat{y}(s) \\;=\\; \\hat{G}_{0}(s)U(s) \\;+\\; \\Big(y_{m}(s) - \\exp(-\\hat{L}s)\\,\\hat{G}_{0}(s)U(s)\\Big),\n$$\n而控制器是任意一个由基于预估器的误差驱动的真分补偿器 $C(s)$：\n$$\nU(s) \\;=\\; C(s)\\big(R(s) - \\hat{y}(s)\\big).\n$$\n假设模型完全匹配，即 $\\hat{G}_{0}(s) = G_{0}(s)$ 且 $\\hat{L} = L$。仅使用线性时不变互联法则和拉普拉斯域代数，当参考输入为零时，推导从传感器噪声到控制输入的闭式传递函数，即求出以下表达式\n$$\n\\frac{U(s)}{N(s)} \\quad \\text{其中} \\quad R(s) \\equiv 0.\n$$\n将最终答案表示为单一的闭式解析表达式。无需进行数值取整。在您的推导过程中，用一两句话解释在模型完全匹配的情况下，时间延迟 $L$ 如何影响（或不影响）这个从噪声到控制的传递。", "solution": "问题陈述经评估有效。这是一个线性控制理论中的适定问题，科学上合理，并包含唯一解所需的所有信息。我们开始进行推导。\n\n该系统由以下拉普拉斯域中的方程组描述：\n被控对象传递函数为 $P(s) = G_{0}(s)\\exp(-Ls)$，它关联了被控对象输出 $y(s)$ 与控制输入 $U(s)$：\n$$y(s) = G_{0}(s)\\exp(-Ls)U(s)$$\n测量输出 $y_{m}(s)$ 受到加性传感器噪声 $n(s)$ 的干扰，在拉普拉斯域中记为 $N(s)$：\n$$y_{m}(s) = y(s) + N(s) = G_{0}(s)\\exp(-Ls)U(s) + N(s)$$\nSmith 预估器使用标称模型 $\\hat{P}(s) = \\hat{G}_{0}(s)\\exp(-\\hat{L}s)$ 来生成输出的内部估计值 $\\hat{y}(s)$：\n$$\\hat{y}(s) = \\hat{G}_{0}(s)U(s) + \\Big(y_{m}(s) - \\exp(-\\hat{L}s)\\hat{G}_{0}(s)U(s)\\Big)$$\n控制律由一个补偿器 $C(s)$ 给出，该补偿器作用于参考输入 $R(s)$ 和估计输出 $\\hat{y}(s)$ 之间的误差：\n$$U(s) = C(s)\\big(R(s) - \\hat{y}(s)\\big)$$\n问题指定了两个条件：参考输入为零，$R(s) \\equiv 0$，并且模型完全匹配，即 $\\hat{G}_{0}(s) = G_{0}(s)$ 且 $\\hat{L} = L$。\n\n我们需要推导从传感器噪声 $N(s)$ 到控制输入 $U(s)$ 的传递函数，即 $\\frac{U(s)}{N(s)}$。\n\n首先，我们将零参考输入条件 $R(s)=0$ 应用于控制律：\n$$U(s) = C(s)\\big(0 - \\hat{y}(s)\\big) = -C(s)\\hat{y}(s)$$\n接着，我们将完全匹配的模型参数 $\\hat{G}_{0}(s) = G_{0}(s)$ 和 $\\hat{L} = L$ 代入预估器估计值 $\\hat{y}(s)$ 的方程中：\n$$\\hat{y}(s) = G_{0}(s)U(s) + \\Big(y_{m}(s) - \\exp(-Ls)G_{0}(s)U(s)\\Big)$$\n现在，我们将测量输出的表达式 $y_{m}(s) = G_{0}(s)\\exp(-Ls)U(s) + N(s)$ 代入此 $\\hat{y}(s)$ 的方程中：\n$$\\hat{y}(s) = G_{0}(s)U(s) + \\Big(\\big(G_{0}(s)\\exp(-Ls)U(s) + N(s)\\big) - \\exp(-Ls)G_{0}(s)U(s)\\Big)$$\n我们可以化简大括号内的表达式。包含被控对象延迟的项相互抵消：\n$$G_{0}(s)\\exp(-Ls)U(s) - \\exp(-Ls)G_{0}(s)U(s) = 0$$\n这给出了预估器估计值 $\\hat{y}(s)$ 的一个简化表达式：\n$$\\hat{y}(s) = G_{0}(s)U(s) + N(s)$$\n此次代数抵消表明，在模型完全匹配的情况下，Smith 预估器结构有效地从控制器使用的反馈信号中移除了被控对象延迟的影响。因此，时间延迟 $L$ 不会出现在从噪声到控制信号的闭环传递函数中，因为它的影响被预估器的内部模型完美地减去了。\n\n最后，我们将这个简化的 $\\hat{y}(s)$ 表达式代回到控制律 $U(s) = -C(s)\\hat{y}(s)$ 中：\n$$U(s) = -C(s)\\big(G_{0}(s)U(s) + N(s)\\big)$$\n为求得所需的传递函数，我们必须通过代数方法解出 $U(s)$ 关于 $N(s)$ 的表达式。我们将 $-C(s)$ 分配到右侧：\n$$U(s) = -C(s)G_{0}(s)U(s) - C(s)N(s)$$\n现在，我们将所有包含 $U(s)$ 的项收集到等式的左侧：\n$$U(s) + C(s)G_{0}(s)U(s) = -C(s)N(s)$$\n从左侧的项中提出公因子 $U(s)$：\n$$U(s)\\big(1 + C(s)G_{0}(s)\\big) = -C(s)N(s)$$\n将等式两边同时除以 $N(s)$ 和 $\\big(1 + C(s)G_{0}(s)\\big)$，我们便得到了从传感器噪声到控制输入的闭式传递函数：\n$$\\frac{U(s)}{N(s)} = \\frac{-C(s)}{1 + C(s)G_{0}(s)}$$\n这就是在指定条件下，关联控制输入与传感器噪声的最终表达式。", "answer": "$$\\boxed{\\frac{-C(s)}{1 + C(s)G_{0}(s)}}$$", "id": "2696670"}, {"introduction": "最后，我们将理论与实践相结合，从连续时间域过渡到数字控制的实现。这个动手实践要求你从头开始构建一个离散时间的史密斯预估器，通过极点配置方法设计数字控制器，并编写代码来仿真系统的阶跃响应。这个练习不仅能让你将解析概念转化为可执行的算法，还能让你通过改变设计参数直观地观察系统性能的变化，从而加深对时滞系统数字控制的理解 [@problem_id:2696634]。", "problem": "考虑一个带有纯输入延迟的离散时间单输入单输出 (SISO) 线性时不变 (LTI) 对象模型。标称对象（无延迟）由复 $z$ 域中的传递函数给出\n$$\nG(z) = \\frac{0.1}{1 - 0.9 z^{-1}},\n$$\n而真实对象包含 $N$ 个采样点的纯延迟，因此真实对象的传递函数为\n$$\nG_{\\text{true}}(z) = z^{-N} G(z),\n$$\n其中 $N = 3$。参考输入为单位阶跃信号，即对于所有整数时间索引 $k \\ge 0$，有 $r(k) = 1$。所有仿真都应在离散时间内以单位采样进行，因此时间以整数值的采样点来衡量。下面要求的所有时间索引均为采样点索引（单位：采样点）。\n\n您的任务是为此延迟对象实现一个离散 Smith 预估器，其使用的内部模型与真实对象完全匹配（即具有相同的 $G(z)$ 和相同的延迟 $N$）。该 Smith 预估器必须按如下方式配置：\n\n1. Smith 预估器中使用的控制器 $C(z)$ 应为一个比例控制器 $C(z) = K$，其中增益 $K$ 不直接给出，而是必须通过对无延迟标称对象 $G(z)$ 在单位负反馈下进行极点配置来设计。具体来说，为无延迟闭环系统（即包含 $G(z)$和控制器 $C(z)$ 但不含延迟的系统）选择一个期望的闭环极点 $p_d \\in (0,1)$，然后确定能实现该极点的比例增益 $K$。\n\n2. 使用标准的离散时间 Smith 预估器结构：控制器 $C(z)$ 作用于参考输入与预估的无延迟输出之间的差值。令 $y(k)$ 为真实对象输出，$y_m(k)$ 为带有延迟 $N$ 的对象模型输出，$y_{m0}(k)$ 为无延迟的对象模型输出。控制器使用的内部预估无延迟输出为\n$$\ny_{\\text{sp}}(k) = y_{m0}(k) + y(k) - y_m(k).\n$$\n控制律为\n$$\nu(k) = K \\left( r(k) - y_{\\text{sp}}(k) \\right).\n$$\n\n3. 使用与 $G(z)$ 对应的标准因果差分方程，在时域中实现对象和模型的动态：\n$$\ny(k) = 0.9\\, y(k-1) + 0.1\\, u(k), \\quad \\text{(no delay)}\n$$\n和\n$$\ny(k) = 0.9\\, y(k-1) + 0.1\\, u(k-N), \\quad \\text{(with delay } N \\text{)}.\n$$\n所有初始条件均为零，输入延迟通过一个长度为 $N$ 且用零初始化的先进先出 (FIFO) 缓冲区实现。\n\n重要实现说明：由于 $G(z)$ 有一个非零直通项（即输出取决于 $u(k)$），$y_{m0}(k)$ 的方程包含 $u(k)$，而 $u(k)$ 是由控制器根据 $y_{\\text{sp}}(k)$ 计算得出的，$y_{\\text{sp}}(k)$ 本身又使用 $y_{m0}(k)$。为了避免代数环，您必须为该比例控制器以闭合形式显式求解 $u(k)$。其结果是一个因果计算过程，该过程使用 $y(k)$、$y_m(k)$ 和 $y_{m0}(k-1)$ 来计算 $u(k)$，之后再更新 $y_{m0}(k)$。\n\n设计依据和数据：\n- $G(z)$ 的模型参数为 $a = 0.9$ 和 $b = 0.1$，这意味着无延迟模型的差分方程为 $y(k) = a\\, y(k-1) + b\\, u(k)$。\n- 对象延迟为 $N = 3$ 个采样点。\n- 阶跃输入对于所有 $k \\ge 0$ 均为 $r(k) = 1$。\n- 仿真时长为 $T = 120$ 个采样点，即 $k = 0,1,\\dots,119$。\n\n通过极点配置进行控制器设计：\n- 对于带有单位负反馈和对象 $G(z)$ 的无延迟闭环系统，选择一个期望的实数闭环极点 $p_d \\in (0,1)$，并设计一个比例增益 $K$，使得（无延迟闭环系统的）闭环极点恰好为 $p_d$。您必须从第一性原理推导 $K$。\n\n需要计算和返回的内容：\n- 对于下面指定的每个测试用例（每个用例具有不同的期望极点 $p_d$），实现 Smith 预估器，仿真对单位阶跃的闭环响应，并报告以下三个量：\n  1. 时间索引 $k = N + 5$ 处的输出采样值 $y(k)$。\n  2. 时间索引 $k = N + 20$ 处的输出采样值 $y(k)$。\n  3. 最终仿真时间 $k = T - 1$ 处的输出采样值 $y(k)$。\n- 这三个量都是无量纲的，应作为实数报告，并四舍五入到 6 位小数。\n\n测试套件：\n- 为无延迟设计使用以下期望的闭环极点：\n  - 用例 A：$p_d = 0.2$\n  - 用例 B：$p_d = 0.5$\n  - 用例 C：$p_d = 0.8$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。顺序首先是用例 A 的值，然后是用例 B 的值，最后是用例 C 的值。在每个用例中，按上述顺序报告三个值。具体来说，输出必须是\n$$\n[ y_{A,N+5}, y_{A,N+20}, y_{A,T-1}, y_{B,N+5}, y_{B,N+20}, y_{B,T-1}, y_{C,N+5}, y_{C,N+20}, y_{C,T-1} ],\n$$\n其中每个条目都四舍五入到 6 位小数。", "solution": "本问题将进行验证。\n\n**第一步：提取已知条件**\n- 标称对象传递函数：$G(z) = \\frac{0.1}{1 - 0.9 z^{-1}}$。其一般形式为 $G(z) = \\frac{b}{1 - a z^{-1}}$，其中 $a=0.9$，$b=0.1$。\n- 真实对象传递函数：$G_{\\text{true}}(z) = z^{-N} G(z)$。\n- 对象延迟：$N = 3$ 个采样点。\n- 参考输入：对于 $k \\ge 0$，$r(k) = 1$。\n- 仿真时长：$T = 120$ 个采样点（$k \\in [0, 119]$）。\n- 控制器：比例控制器，$C(z) = K$。\n- 控制器设计：为无延迟单位负反馈回路进行极点配置，期望的闭环极点为 $p_d$。\n- Smith 预估器结构：\n  - 控制律：$u(k) = K ( r(k) - y_{\\text{sp}}(k) )$。\n  - 预估的无延迟输出：$y_{\\text{sp}}(k) = y_{m0}(k) + y(k) - y_m(k)$，其中 $y(k)$ 是真实对象输出，$y_m(k)$ 是带延迟的模型输出，$y_{m0}(k)$ 是无延迟的模型输出。\n- 时域动态：\n  - 无延迟对象/模型：$y(k) = a y(k-1) + b u(k)$。\n  - 带延迟对象/模型：$y(k) = a y(k-1) + b u(k-N)$。\n- 初始条件：所有状态和缓冲区均为零。\n- 代数环警告：$u(k)$ 必须被显式求解。\n- 测试用例（期望极点 $p_d$）：用例 A: $p_d=0.2$，用例 B: $p_d=0.5$，用例 C: $p_d=0.8$。\n- 要求输出：对于每个用例，$y(N+5)$、$y(N+20)$ 和 $y(T-1)$ 的值。\n\n**第二步：使用提取的已知条件进行验证**\n此问题是离散时间控制理论中的一个标准练习。它有科学根据，使用了 LTI 系统和 Smith 预估器架构的既定原则。问题是适定的，为获得唯一的数值解提供了所有必要的参数和条件。语言客观、精确。没有违反科学或数学原则，没有信息缺失，也没有矛盾。解决代数环的要求在数字信号处理（DSP）和控制实现中是一个不平凡但标准的过程，反映了对计算因果性的正确理解。\n\n**第三步：结论与行动**\n问题有效。将提供解决方案。\n\n**基于原理的解决方案**\n\n目标是为一个带输入延迟的一阶离散时间对象设计并仿真一个 Smith 预估器。解决方案分三个阶段进行：控制器综合、离散时间仿真方程的构建和数值实现。\n\n**1. 通过极点配置进行控制器综合**\n\n比例控制器增益 $K$ 是为标称对象 $G(z) = \\frac{b}{1 - a z^{-1}}$ 在无延迟的单位负反馈配置下设计的。这个无延迟系统的闭环传递函数 $T_{CL}(z)$ 为：\n$$\nT_{CL}(z) = \\frac{C(z)G(z)}{1 + C(z)G(z)} = \\frac{K \\frac{b}{1 - a z^{-1}}}{1 + K \\frac{b}{1 - a z^{-1}}}\n$$\n将分子和分母同乘以 $(1 - a z^{-1})$ 可得：\n$$\nT_{CL}(z) = \\frac{Kb}{1 - a z^{-1} + Kb} = \\frac{Kb}{(1+Kb) - a z^{-1}}\n$$\n闭环极点 $z_p$ 可由特征方程求得，即令传递函数的分母为零：\n$$\n(1+Kb) - a z^{-1} = 0 \\implies z_p = \\frac{a}{1+Kb}\n$$\n我们需要将此极点配置在期望位置 $p_d$。因此，我们令 $z_p = p_d$：\n$$\np_d = \\frac{a}{1+Kb}\n$$\n求解此方程以获得控制器增益 $K$：\n$$\np_d(1+Kb) = a \\implies p_d + p_d Kb = a \\implies K = \\frac{a - p_d}{p_d b}\n$$\n使用给定参数 $a = 0.9$ 和 $b = 0.1$，我们为每个测试用例计算 $K$：\n- 用例 A ($p_d = 0.2$)：$K = \\frac{0.9 - 0.2}{0.2 \\times 0.1} = \\frac{0.7}{0.02} = 35$。\n- 用例 B ($p_d = 0.5$)：$K = \\frac{0.9 - 0.5}{0.5 \\times 0.1} = \\frac{0.4}{0.05} = 8$。\n- 用例 C ($p_d = 0.8$)：$K = \\frac{0.9 - 0.8}{0.8 \\times 0.1} = \\frac{0.1}{0.08} = 1.25$。\n\n**2. Smith 预估器仿真方程**\n\n仿真需要仔细处理计算依赖关系以确保因果性。在每个离散时间步 $k$，我们必须计算当前的控制输入 $u(k)$ 并更新所有系统状态。问题描述正确地指出了在 $u(k)$ 的定义中存在一个代数环。我们按如下方式解决此问题。\n\n控制律为 $u(k) = K(r(k) - y_{sp}(k))$。代入 $y_{sp}(k) = y_{m0}(k) + y(k) - y_m(k)$ 的定义：\n$$\nu(k) = K(r(k) - [y_{m0}(k) + y(k) - y_m(k)])\n$$\n无延迟模型的输出由差分方程 $y_{m0}(k) = a y_{m0}(k-1) + b u(k)$ 给出。将其代入控制律：\n$$\nu(k) = K(r(k) - [ (a y_{m0}(k-1) + b u(k)) + y(k) - y_m(k) ])\n$$\n展开并合并包含 $u(k)$ 的项：\n$$\nu(k) = K r(k) - K a y_{m0}(k-1) - K b u(k) - K y(k) + K y_m(k)\n$$\n$$\nu(k) (1 + Kb) = K [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n$$\n这给出了控制输入 $u(k)$ 的显式、因果的更新规则：\n$$\nu(k) = \\frac{K}{1 + Kb} [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n$$\n在时间步 $k$，$y(k)$ 和 $y_m(k)$ 的值是可用的，因为它们依赖于过去的输入值 $u(k-N)$。$y_{m0}(k-1)$ 的值也是过去的状态。因此，$u(k)$ 可以被计算出来。\n\n**3. 仿真算法**\n\n仿真对 $k = 0, 1, \\dots, T-1$ 进行迭代。在每一步 $k$，按顺序执行以下计算：\n\n1.  **检索过去的值**：访问来自步骤 $k-1$ 的状态值（例如 $y(k-1)$, $y_m(k-1)$, $y_{m0}(k-1)$）和延迟的输入 $u(k-N)$。根据初始条件，对于 $k-1 < 0$ 或 $k-N < 0$，这些值为零。\n2.  **计算延迟输出**：计算真实对象和延迟模型的输出。由于模型是完美的，它们遵循相同的动态规律：\n    $$\n    y(k) = a y(k-1) + b u(k-N)\n    $$\n    $$\n    y_m(k) = a y_m(k-1) + b u(k-N)\n    $$\n    在理想的仿真中，对所有 $k$ 都有 $y(k) = y_m(k)$。\n3.  **计算控制输入**：使用推导出的因果公式计算 $u(k)$：\n    $$\n    u(k) = \\frac{K}{1 + Kb} [ r(k) - y(k) + y_m(k) - a y_{m0}(k-1) ]\n    $$\n    此处 $r(k)=1$。在这种理想情况下，项 $y(k)-y_m(k)$ 将为零。\n4.  **计算无延迟模型输出**：使用刚刚计算出的 $u(k)$ 更新无延迟模型的状态：\n    $$\n    y_{m0}(k) = a y_{m0}(k-1) + b u(k)\n    $$\n5.  **存储状态**：将计算出的值 $y(k)$、$y_m(k)$、$y_{m0}(k)$ 和 $u(k)$ 存储起来，用于后续的时间步。\n\n该算法针对每个设计用例，在指定的持续时间 $T=120$ 内实现。然后提取并报告在 $k=N+5=8$、$k=N+20=23$和 $k=T-1=119$ 时的输出值 $y(k)$。带完美模型的 Smith 预估器的行为是产生一个等效于无延迟系统响应的闭环响应，但在时间上平移了延迟 $N$。系统输出 $y(k)$ 应表现出一阶系统的动态特性，其极点为 $p_d$，但其响应从 $k=N$ 开始。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete-time Smith predictor problem for a plant with time delay.\n    \"\"\"\n    # Define system parameters from the problem statement.\n    a = 0.9  # Plant pole\n    b = 0.1  # Plant numerator gain\n    N = 3    # Input delay in samples\n    T = 120  # Total simulation time in samples\n\n    # Define the test cases with different desired closed-loop poles.\n    test_cases_pd = [0.2, 0.5, 0.8]\n\n    # A list to store the final results for all test cases.\n    results = []\n\n    # Iterate through each test case.\n    for p_d in test_cases_pd:\n        # 1. Controller Design: Calculate proportional gain K by pole placement.\n        # The formula K = (a - p_d) / (p_d * b) is derived from setting the\n        # delay-free closed-loop pole to p_d.\n        K = (a - p_d) / (p_d * b)\n\n        # 2. Simulation Initialization: Create arrays to store system signals over time.\n        # All signals are initialized to zero, which handles the initial conditions.\n        y = np.zeros(T)      # True plant output\n        ym = np.zeros(T)     # Delayed plant model output\n        ym0 = np.zeros(T)    # Undelayed plant model output\n        u = np.zeros(T)      # Control input\n        r = np.ones(T)       # Reference input (unit step)\n\n        # Pre-calculate a constant factor for the control input equation.\n        u_factor = K / (1 + K * b)\n\n        # 3. Simulation Loop: Iterate from k = 0 to T-1.\n        for k in range(T):\n            # Retrieve past values, handling boundary conditions at k=0.\n            # If the index is negative, the value is 0.\n            y_km1 = y[k - 1] if k > 0 else 0.0\n            ym_km1 = ym[k - 1] if k > 0 else 0.0\n            ym0_km1 = ym0[k - 1] if k > 0 else 0.0\n            \n            # The input u(k-N) causes the delay. For k  N, u(k-N) is 0.\n            u_k_minus_N = u[k - N] if k >= N else 0.0\n\n            # Update delayed outputs based on past values. This must be done\n            # before calculating the current control input u(k).\n            y[k] = a * y_km1 + b * u_k_minus_N\n            ym[k] = a * ym_km1 + b * u_k_minus_N\n\n            # Calculate the current control input u(k).\n            # The formula is derived to resolve the algebraic loop.\n            # Since the model is perfect, y[k] - ym[k] will be zero.\n            u[k] = u_factor * (r[k] - y[k] + ym[k] - a * ym0_km1)\n            \n            # Update the undelayed model output using the newly calculated u(k).\n            ym0[k] = a * ym0_km1 + b * u[k]\n\n        # 4. Extract and Store Results for the current test case.\n        # The required time indices are N+5, N+20, and T-1.\n        y_N_plus_5 = y[N + 5]\n        y_N_plus_20 = y[N + 20]\n        y_T_minus_1 = y[T - 1]\n\n        # Append the rounded results to the main results list.\n        results.extend([\n            np.round(y_N_plus_5, 6),\n            np.round(y_N_plus_20, 6),\n            np.round(y_T_minus_1, 6)\n        ])\n\n    # 5. Final Output: Print the results in the specified format.\n    # The format is a single line: [val1,val2,val3,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2696634"}]}