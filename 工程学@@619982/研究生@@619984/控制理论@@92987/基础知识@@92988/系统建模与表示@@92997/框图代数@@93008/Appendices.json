{"hands_on_practices": [{"introduction": "本次练习是框图代数的核心。我们将从最基础的负反馈系统出发，通过代数化简推导出闭环传递函数 [@problem_id:2690577]。这个过程不仅能帮助你熟练掌握反馈环路的基本简化规则，还能让你深刻理解系统结构如何直接决定其动态特性的关键——闭环极点。", "problem": "考虑一个线性时不变 (LTI) 系统的单输入单输出单位负反馈结构。前向通路被控对象的传递函数为 $G(s)=\\dfrac{k}{s(s+1)}$，其中 $k \\in \\mathbb{R}$ 是一个实数设计参数，反馈通路为单位反馈 $H(s)=1$，而 $s$ 是复拉普拉斯变量。仅从求和点的定义、LTI 模块传递函数的意义以及框图中串联和反馈互联的代数规则出发，执行回路的等效框图化简，以获得从参考输入 $R(s)$ 到输出 $Y(s)$ 的闭环传递函数 $T(s)=\\dfrac{Y(s)}{R(s)}$，该函数是关于 $k$ 和 $s$ 的函数。然后，通过精确的符号计算，确定作为 $k$ 函数的闭环极点位置。在最终答案中，将两个极点位置以有序对的形式报告。最终答案无需数值近似，也无需单位。", "solution": "问题陈述经评估有效。这是一个经典的控制理论中的标准、适定问题，没有科学或逻辑上的不一致之处。我们将按要求进行推导。\n\n该系统是一个单位负反馈结构。设 $R(s)$ 为参考输入信号的拉普拉斯变换，$Y(s)$ 为输出信号的拉普拉斯变换。误差信号 $E(s)$ 由一个求和点产生，该求和点将反馈信号 $B(s)$ 从参考输入 $R(s)$ 中减去。其代数关系是：\n$$E(s) = R(s) - B(s)$$\n前向通路包含一个传递函数为 $G(s)$ 的被控对象。其输入 $E(s)$ 与输出 $Y(s)$ 之间的关系是：\n$$Y(s) = G(s) E(s)$$\n反馈通路的传递函数为 $H(s)$。其输入是系统输出 $Y(s)$，输出是反馈信号 $B(s)$：\n$$B(s) = H(s) Y(s)$$\n要推导闭环传递函数 $T(s) = \\dfrac{Y(s)}{R(s)}$，我们必须组合这些基本方程以消去内部信号 $E(s)$ 和 $B(s)$。我们首先将 $B(s)$ 的表达式代入 $E(s)$ 的方程中：\n$$E(s) = R(s) - H(s) Y(s)$$\n接着，我们将这个 $E(s)$ 的表达式代入输出 $Y(s)$ 的方程中：\n$$Y(s) = G(s) [R(s) - H(s) Y(s)]$$\n我们将 $G(s)$ 乘入右侧的括号中：\n$$Y(s) = G(s) R(s) - G(s) H(s) Y(s)$$\n为了求解比率 $\\dfrac{Y(s)}{R(s)}$，我们将所有包含 $Y(s)$ 的项移到等式的一边：\n$$Y(s) + G(s) H(s) Y(s) = G(s) R(s)$$\n提取公因式 $Y(s)$，得到：\n$$Y(s) [1 + G(s) H(s)] = G(s) R(s)$$\n最后，通过除以 $R(s)$ 和括号中的项，我们得出负反馈系统闭环传递函数的一般表达式：\n$$T(s) = \\dfrac{Y(s)}{R(s)} = \\dfrac{G(s)}{1 + G(s) H(s)}$$\n此推导是严谨的，且仅基于框图组件已定义的代数规则。\n\n现在，我们代入题目中给出的具体传递函数：$G(s) = \\dfrac{k}{s(s+1)}$ 和 $H(s) = 1$。\n$$T(s) = \\dfrac{\\dfrac{k}{s(s+1)}}{1 + \\left(\\dfrac{k}{s(s+1)}\\right)(1)}$$\n为简化此繁分式，我们为总分母中的各项找到公分母：\n$$T(s) = \\dfrac{\\dfrac{k}{s(s+1)}}{\\dfrac{s(s+1)}{s(s+1)} + \\dfrac{k}{s(s+1)}} = \\dfrac{\\dfrac{k}{s(s+1)}}{\\dfrac{s(s+1) + k}{s(s+1)}}$$\n通过消去繁分式中，分子部分的分母和分母部分的公分母 $s(s+1)$，化简可得：\n$$T(s) = \\dfrac{k}{s(s+1) + k}$$\n展开分母中的多项式，得到闭环传递函数的最终形式：\n$$T(s) = \\dfrac{k}{s^2 + s + k}$$\n根据定义，闭环极点是特征方程的根，而特征方程是通过将闭环传递函数的分母置零得到的。该系统的特征方程为：\n$$s^2 + s + k = 0$$\n这是一个关于复变量 $s$ 的二次方程，形式为 $as^2 + bs + c = 0$，其系数为 $a=1$，$b=1$ 和 $c=k$。其根可通过二次求根公式求得：\n$$s = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n代入系数，我们得到两个极点的位置：\n$$s = \\dfrac{-(1) \\pm \\sqrt{(1)^2 - 4(1)(k)}}{2(1)}$$\n$$s = \\dfrac{-1 \\pm \\sqrt{1 - 4k}}{2}$$\n因此，两个极点位置的不同符号表达式为 $s_1 = \\dfrac{-1 + \\sqrt{1 - 4k}}{2}$ 和 $s_2 = \\dfrac{-1 - \\sqrt{1 - 4k}}{2}$。这些就是所要求的、作为实数参数 $k$ 的函数的极点。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{-1 + \\sqrt{1 - 4k}}{2} & \\frac{-1 - \\sqrt{1 - 4k}}{2} \\end{pmatrix}}$$", "id": "2690577"}, {"introduction": "在掌握了基本的简化技巧后，我们必须关注框图这一图形语言本身的严谨性。本练习旨在强调在求和点处使用明确、标准化的符号来表示代数运算的重要性，以避免在简化复杂系统时出现常见的符号错误 [@problem_id:2690564]。掌握这套“语法”是精确建模和分析任何控制系统的基础。", "problem": "一个传递函数为 $G(s)$ 的单输入单输出线性时不变 (LTI) 对象，由一个指令输入 $u(s)$ 和一个外部扰动 $d(s)$ 的代数和驱动，因此对象的输入为 $v(s)$，输出为 $y(s)$，其中 $y(s)=G(s)\\,v(s)$ 且 $v(s)=u(s)+d(s)$。您希望绘制一个框图，然后进行框图代数运算（串联/并联组合、移动引出点、重新定位求和点），同时避免产生符号错误。特别是，您需要一种针对求和点和信号箭头的标注策略，该策略在这种变换下保持不变，并使节点方程没有歧义。\n\n仅从“求和点实现带符号输入的代数和”以及“模块实现其输入到输出的线性映射”这两个定义出发，以下哪种标注策略能正确地指定求和点的信号方向和极性，从而使得代数化简能够无符号歧义地得到 $y(s)=G(s)\\,[u(s)+d(s)]$？\n\nA. 将求和点的所有输入用指向节点的箭头绘制，节点的输出用指向外部的箭头绘制。在节点的每个输入线旁边放置一个明确的 $+$ 或 $-$ 标签，在局部节点方程 $v(s)=\\sum_i \\sigma_i x_i(s)$（其中 $\\sigma_i\\in\\{+1,-1\\}$）中解释其符号，这与输入线进入圆圈的位置无关。对于 $v(s)=u(s)+d(s)$ 中的加法，在节点处为 $u(s)$ 和 $d(s)$ 都标上 $+$。如果信号必须沿相反的几何方向布线，应保持箭头与信号流向一致，并在需要时在线路上插入一个增益为-1的显式模块，而不是通过箭头方向来编码符号。\n\nB. 省略所有 $+$ 和 $-$ 标签。将任何从左侧进入求和点的线解释为正，从右侧进入的解释为负，从顶部进入的解释为正，从底部进入的解释为负；依赖这种空间约定来确定代数符号。\n\nC. 不在输入上放置 $+$ 或 $-$ 标签。使用箭头方向来编码极性：任何箭头指向求和点的线都被视为正，任何箭头指离求和点的线都被视为负；节点输出箭头的指向可以根据方便指向节点或指离节点。\n\nD. 在求和圈内放置一个单独的 $+$ 号，表示该点执行加法。如果需要减法，则允许后续的代数化简将负号引入模块增益中，而不是在求和点上进行标注。\n\nE. 将所有输入用指向求和点的箭头绘制，并在输出线上放置一个 $+$ 号以表示正的输出方向。对于任何减法输入，将其箭头画成指离求和点的方向；不要在节点处放置 $-$ 标签，并避免在线路上使用显式的-1增益。", "solution": "该问题要求在线性时不变 (LTI) 系统的背景下，为框图（特别是求和点）确定一种正确且无歧义的标注策略。一个有效的策略必须确保数学关系得到保留和清晰表示，且与图的几何布局无关，并确保框图在标准的框图代数变换下保持一致。该系统由方程 $y(s)=G(s)\\,v(s)$ 和 $v(s)=u(s)+d(s)$ 定义。\n\n框图是用于表示方程组的一种图形语言。为了有效，其语法必须是无歧义的。基本原则是：\n1.  信号线上的箭头表示因果关系或信号流的方向。箭头从源节点或模块输出指向目标节点或模块输入。这个约定必须是不可违背的。\n2.  求和点表示一个代数求和。其输出信号是其输入信号的线性组合。\n\n现在我们将根据这些原则以及无歧义性和不变性的标准来评估每种提议的标注策略。\n\n**选项A评估**\n该策略规定：\n- 求和点的所有输入都有指向节点的箭头。\n- 输出有一个指离节点的箭头。\n- 在每个输入箭头的旁边放置一个明确的 $+$ 或 $-$ 标签来表示其在求和式 $v(s)=\\sum_i \\sigma_i x_i(s)$（其中 $\\sigma_i \\in \\{+1, -1\\}$）中的符号。\n- 对于几何上的重新布线，信号流向（箭头）保持不变，符号反转通过增益为-1的模块实现，而不是通过反转箭头方向。\n\n该策略建立了一套清晰且分离的表示方法：\n- 信号流（因果关系）完全由箭头方向编码。\n- 代数符号完全由求和点输入端的 $+$ 或 $-$ 标签编码。\n\n这种分离避免了任何歧义。框图的含义与线路的空间布局无关。对于给定的方程 $v(s)=u(s)+d(s)$，信号 $u(s)$ 和 $d(s)$ 都将有指向求和点的箭头，并且每个箭头旁都伴有一个 $+$ 号。结果信号 $v(s)$ 将有一个指离求和点的箭头。这正确且唯一地表示了指定的代数关系。该策略是控制系统工程中使用的标准约定，正是因为它鲁棒、无歧义，并且对于图表变换是不变的。\n\n结论：**正确**。\n\n**选项B评估**\n该策略规定符号由线路进入求和点的几何方向决定（左/上 $= +$，右/下 $= -$)，没有明确的标签。\n\n这个策略有致命的缺陷。首先，它有歧义。一条以 $45^\\circ$ 角进入的线符号是什么？笛卡尔坐标参考（左/右，上/下）是任意的且定义不清。其次，也是更严重的是，它使得框图的数学意义依赖于其图形布局。为了美观清晰而简单地重画框图，可能会无意中改变输入的符号，从而改变了框图本应代表的系统方程。这违反了不变性原则。对于任何严肃的工程工作，一个标记系统必须能鲁棒地应对这种无关紧要的表示变化。\n\n结论：**不正确**。\n\n**选项C评估**\n该策略规定箭头方向编码极性：指向求和点的箭头为正，指离的为负。输出箭头的方向据说是灵活的。\n\n这个策略可能是缺陷最大的，因为它完全破坏了框图中箭头的基本含义。箭头的主要作用是指示信号流的方向。通过挪用这一作用来同时表示代数符号，该策略造成了无法解决的歧义。如果一个指离求和点的箭头代表一个负输入，那么如何将其与求和点的实际输出区分开来？而实际输出*必须*是流出求和点的。“输出箭头可以指向节点或指离节点”的说法是毫无意义的，并且违反了因果关系原则。一个节点的输出不能流向自身。该策略未能提供一种一致的方法来区分输入和输出，因此不能构成一种连贯的图形语言。\n\n结论：**不正确**。\n\n**选项D评估**\n该策略建议在求和圈内放置一个单独的 $+$ 号表示加法，并通过上游的增益为-1的模块来处理减法，而不是在求和点上标注。\n\n诚然，任何减法 $a-b$ 都可以写成加法 $a+(-b)$，并且人们总可以插入一个增益为-1的模块来从 $b$ 生成 $-b$，但作为一个通用规则，这个策略是不完整和限制性的。它没有定义如何标注一个同时执行加法和减法的求和点，例如 $w(s) = x(s) + y(s) - z(s)$。标准策略 (A) 可以轻松处理这种情况，只需为输入 $x(s)$ 和 $y(s)$ 标记上 $+$，为 $z(s)$ 标记上 $-$。策略 (D) 迫使框图因每次减法都增加额外的增益为-1的模块而变得杂乱，这是低效的。一个鲁棒的标记系统应该提供一种直接在求和点本身表示像减法这样常见运算的方法。因此，该策略是(A)中所述的更优策略的一个贫乏子集。\n\n结论：**不正确**。\n\n**选项E评估**\n该策略规定，减法输入通过将其箭头*指离*求和点来表示，而加法输入则有指向求和点的箭头。\n\n该策略与选项C有相同的根本缺陷：它将代数符号与信号流方向混为一谈。按照惯例，指离求和点的箭头必须代表一个输出信号。用它来代表一个负输入，使得区分负输入和输出变得不可能。在像 $v(s) = u(s) - d(s)$ 这样的方程中，信号 $u(s)$ 和 $d(s)$ 都是产生 $v(s)$ 的减法数学运算的因果输入。图形表示必须反映这一点。让 $d(s)$ 的箭头指离求和点，会错误地将 $d(s)$ 描绘成求和点的结果或输出，而实际上它是一个原因或输入。这导致了逻辑上和图形上的不一致。\n\n结论：**不正确**。\n\n总而言之，只有选项A提供了一个逻辑上合理、无歧义且鲁棒的框架，用于标注符合控制理论既定原则的框图。它正确地将信号因果关系（箭头）的表示与代数运算（符号）的表示分离开来。", "answer": "$$\\boxed{A}$$", "id": "2690564"}, {"introduction": "当面对具有复杂互联的系统时，逐级进行框图简化可能会变得繁琐。梅森增益公式（Mason's Gain Formula）提供了一种更为系统化的替代方法。本练习将引导你应用梅森公式，通过识别前向通路、回路和不接触回路来求解一个复杂系统的传递函数，并通过与传统简化方法对比来验证其结果 [@problem_id:2690600]。", "problem": "考虑一个因果线性时不变（LTI）单输入单输出系统，由下述信号流图（SFG）结构描述。有一个源节点，承载拉普拉斯域输入信号 $R(s)$，该信号馈入一个求和节点 $n_0$。从 $n_0$ 出发，有两条严格平行的前向支路将信号传输到输出求和节点 $n_5$，该节点产生拉普拉斯域输出 $Y(s)$。这两条支路如下：\n\n- 支路1（上支路）：来自 $n_0$ 的信号经过一个传递函数为 $G_1(s)$ 的模块到达节点 $n_1$，然后经过一个传递函数为 $G_2(s)$ 的模块到达节点 $n_2$。节点 $n_2$ 直接连接到输出求和节点 $n_5$。有一条从 $n_2$ 回到 $n_1$ 的局部负反馈，通过一个传递函数为 $H_1(s)$ 的模块，以负号进入 $n_1$ 处的求和点。因此，$n_1$ 处的代数和是来自 $G_1(s)$ 的前向信号减去来自 $H_1(s)$ 的反馈信号。\n\n- 支路2（下支路）：来自 $n_0$ 的信号经过一个传递函数为 $G_3(s)$ 的模块到达节点 $n_3$，然后经过一个传递函数为 $G_4(s)$ 的模块到达节点 $n_4$。节点 $n_4$ 直接连接到输出求和节点 $n_5$。有一条从 $n_4$ 回到 $n_3$ 的局部负反馈，通过一个传递函数为 $H_2(s)$ 的模块，以负号进入 $n_3$ 处的求和点。因此，$n_3$ 处的代数和是来自 $G_3(s)$ 的前向信号减去来自 $H_2(s)$ 的反馈信号。\n\n没有其他互连。所有传递函数 $G_1(s)$、$G_2(s)$、$G_3(s)$、$G_4(s)$、$H_1(s)$ 和 $H_2(s)$ 都是具有实系数的真有理函数，并且图中恰好包含两个不接触的回路：支路1内由 $G_2(s)$ 和 $H_1(s)$ 构成的回路，以及支路2内由 $G_4(s)$ 和 $H_2(s)$ 构成的回路。输出节点 $n_5$ 仅将来自 $n_2$ 和 $n_4$ 的贡献相加。\n\n任务：\n- 使用信号流图（SFG）的回路、前向路径和不接触回路的定义，应用 Mason增益公式（MGF）计算总传递函数 $T(s) = \\dfrac{Y(s)}{R(s)}$。除了给定的结构描述外，不要假定任何简化。\n- 通过直接进行方框图化简来独立验证您的结果，仅使用基于节点线性和叠加原理的串联、并联和负反馈互连恒等式。\n\n将您的最终答案表示为 $T(s)$ 的单个闭式符号表达式，用 $G_1(s)$、$G_2(s)$、$G_3(s)$、$G_4(s)$、$H_1(s)$ 和 $H_2(s)$ 表示。不需要进行数值计算或四舍五入，最终表达式也不需要报告物理单位。", "solution": "在尝试求解之前，必须对问题陈述进行严格的验证。\n\n**步骤1：提取已知条件**\n- 系统类型：因果线性时不变（LTI）单输入单输出（SISO）。\n- 输入信号：$R(s)$，位于指定为 $n_0$ 的源节点。\n- 输出信号：$Y(s)$，位于指定为 $n_5$ 的输出节点。\n- 系统结构：一个由从 $n_0$ 到 $n_5$ 的两条“严格平行的前向支路”组成的信号流图（SFG）。\n- 支路1（上支路）：信号路径从 $n_0$ 经过 $G_1(s)$ 到达节点 $n_1$，然后经过 $G_2(s)$ 到达节点 $n_2$，该节点连接到输出节点 $n_5$。存在一条通过 $H_1(s)$ 从 $n_2$ 到 $n_1$ 的负反馈路径。\n- 支路2（下支路）：信号路径从 $n_0$ 经过 $G_3(s)$ 到达节点 $n_3$，然后经过 $G_4(s)$ 到达节点 $n_4$，该节点连接到输出节点 $n_5$。存在一条通过 $H_2(s)$ 从 $n_4$ 到 $n_3$ 的负反馈路径。\n- 节点求和：节点 $n_5$ 将来自 $n_2$ 和 $n_4$ 的信号相加。指定 $n_1$ 和 $n_3$ 处的求和点对反馈信号取负号。\n- 回路结构：图中恰好包含两个不接触的回路：一个在支路1中（由 $G_2(s)$ 和 $H_1(s)$ 构成），一个在支路2中（由 $G_4(s)$ 和 $H_2(s)$ 构成）。\n- 组件属性：所有传递函数 $G_1(s)$、$G_2(s)$、$G_3(s)$、$G_4(s)$、$H_1(s)$、$H_2(s)$ 均为具有实系数的真有理函数。\n- 任务：使用两种方法计算总传递函数 $T(s) = \\frac{Y(s)}{R(s)}$：(1) Mason增益公式（MGF）和 (2) 用于独立验证的方框图化简。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题描述了一个标准的控制系统结构。其语言混合了方框图术语（“求和点”）和信号流图术语（“节点”）。这种措辞略有歧义。然而，在信号流图理论中，每个节点都隐含地作为其所有输入支路的求和点。这种解释消除了歧义，并创建了一个定义明确的结构。\n- **科学依据**：该问题基于经典控制理论，特别是LTI系统的拉普拉斯域分析。Mason增益公式和方框图代数是标准且有效的分析工具。\n- **适定性**：在标准解释下，该信号流图是定义明确的。它具有单一输入和单一输出。传递函数是唯一的。\n- **客观性和完整性**：该问题陈述客观。描述了构建系统模型所需的所有组件和连接。没有缺少必要的数据。\n- **缺陷分析**：\n  - 不存在科学或事实上的不健全之处。\n  - 该问题是可形式化的，并且与控制理论相关。\n  - 在标准SFG解释下，该设置并不矛盾。\n  - 该问题是符号性的，因此物理上不可行的问题不适用。\n  - 该问题是适定的，并且只要底层组件系统是稳定的，就存在唯一的稳定解。\n\n**步骤3：结论与行动**\n问题是**有效的**。措辞上的不精确是次要的，不影响将系统严格且唯一地形式化为信号流图。我现在将开始求解。\n\n分析将按要求分两部分进行：首先使用Mason增益公式，然后使用代数方框图化简。\n\n**方法1：Mason增益公式（MGF）**\n\nMason增益公式为 $T(s) = \\frac{1}{\\Delta(s)} \\sum_{k} P_k(s) \\Delta_k(s)$，其中 $P_k$ 是前向路径增益，$\\Delta$ 是图的行列式，$\\Delta_k$ 是路径的余子式。\n\n1.  **前向路径 ($P_k$)**: 前向路径是指从输入节点 $n_0$ 到输出节点 $n_5$ 的路径，且不重复经过任何节点。\n    -   路径1 ($P_1$)：通过上支路，$n_0 \\rightarrow n_1 \\rightarrow n_2 \\rightarrow n_5$。路径增益是支路增益的乘积： $P_1(s) = G_1(s) G_2(s) \\cdot 1 = G_1(s)G_2(s)$。\n    -   路径2 ($P_2$)：通过下支路，$n_0 \\rightarrow n_3 \\rightarrow n_4 \\rightarrow n_5$。路径增益为： $P_2(s) = G_3(s) G_4(s) \\cdot 1 = G_3(s)G_4(s)$。\n    共有两条前向路径。\n\n2.  **单个回路 ($L_i$)**: 回路是起点和终点为同一节点的路径。\n    -   回路1 ($L_1$)：上支路中的反馈回路，$n_1 \\rightarrow n_2 \\rightarrow n_1$。该回路的增益为 $L_1(s) = G_2(s) \\cdot (-H_1(s)) = -G_2(s)H_1(s)$。负号来自指定的负反馈。\n    -   回路2 ($L_2$)：下支路中的反馈回路，$n_3 \\rightarrow n_4 \\rightarrow n_3$。该回路的增益为 $L_2(s) = G_4(s) \\cdot (-H_2(s)) = -G_4(s)H_2(s)$。\n    共有两个回路。正如问题所述，这些回路是不接触的，因为它们不共享任何节点。回路 $L_1$ 涉及节点 $\\{n_1, n_2\\}$，回路 $L_2$ 涉及节点 $\\{n_3, n_4\\}$。\n\n3.  **图的行列式 ($\\Delta$)**: 行列式计算公式为 $\\Delta = 1 - (\\sum L_i) + (\\sum L_i L_j) - \\dots$。\n    -   单个回路增益之和：$\\sum L_i = L_1(s) + L_2(s) = -G_2(s)H_1(s) - G_4(s)H_2(s)$。\n    -   不接触回路对的增益乘积之和：只有一对不接触的回路，($L_1, L_2$)。其乘积为 $L_1(s)L_2(s) = (-G_2(s)H_1(s))(-G_4(s)H_2(s)) = G_2(s)H_1(s)G_4(s)H_2(s)$。\n    -   因此，行列式为：\n        $$ \\Delta(s) = 1 - (L_1(s) + L_2(s)) + (L_1(s)L_2(s)) $$\n        $$ \\Delta(s) = 1 - (-G_2(s)H_1(s) - G_4(s)H_2(s)) + G_2(s)H_1(s)G_4(s)H_2(s) $$\n        $$ \\Delta(s) = 1 + G_2(s)H_1(s) + G_4(s)H_2(s) + G_2(s)H_1(s)G_4(s)H_2(s) $$\n        这可以因式分解为 $\\Delta(s) = (1 + G_2(s)H_1(s))(1 + G_4(s)H_2(s))$。\n\n4.  **路径余子式 ($\\Delta_k$)**: $\\Delta_k$ 是通过移除所有与第 $k$ 条前向路径接触的回路后形成的子图的行列式。\n    -   对于路径 $P_1$（节点 $n_0, n_1, n_2, n_5$）：该路径接触回路 $L_1$（在节点 $n_1, n_2$），但不接触回路 $L_2$。因此，$\\Delta_1$ 仅用回路 $L_2$ 计算。\n        $$ \\Delta_1(s) = 1 - L_2(s) = 1 - (-G_4(s)H_2(s)) = 1 + G_4(s)H_2(s) $$\n    -   对于路径 $P_2$（节点 $n_0, n_3, n_4, n_5$）：该路径接触回路 $L_2$（在节点 $n_3, n_4$），但不接触回路 $L_1$。因此，$\\Delta_2$ 仅用回路 $L_1$ 计算。\n        $$ \\Delta_2(s) = 1 - L_1(s) = 1 - (-G_2(s)H_1(s)) = 1 + G_2(s)H_1(s) $$\n\n5.  **总传递函数 ($T(s)$)**:\n    $$ T(s) = \\frac{P_1(s)\\Delta_1(s) + P_2(s)\\Delta_2(s)}{\\Delta(s)} $$\n    $$ T(s) = \\frac{G_1(s)G_2(s)(1 + G_4(s)H_2(s)) + G_3(s)G_4(s)(1 + G_2(s)H_1(s))}{(1 + G_2(s)H_1(s))(1 + G_4(s)H_2(s))} $$\n\n**方法2：方框图化简**\n\n系统结构由两个并联的独立支路组成。输入 $R(s)$ 同时馈入两个支路，它们的输出在节点 $n_5$ 处相加以产生 $Y(s)$。根据叠加原理，总传递函数 $T(s)$ 是两个并联支路传递函数 $T_1(s)$ 和 $T_2(s)$ 的和。\n$$ T(s) = T_1(s) + T_2(s) $$\n\n1.  **支路1的传递函数 ($T_1(s)$)**:\n    该支路有一个模块 $G_1(s)$ 与一个反馈结构串联。反馈回路包含前向传递函数 $G_2(s)$ 和反馈传递函数 $H_1(s)$。负反馈回路的标准公式是 $\\frac{G}{1+GH}$。\n    -   反馈部分（从节点 $n_1$ 到节点 $n_2$）的传递函数为 $\\frac{G_2(s)}{1+G_2(s)H_1(s)}$。\n    -   该反馈系统与前面的模块 $G_1(s)$ 串联。串联组件的传递函数是它们的乘积。\n    -   因此，整个上支路的传递函数为：\n        $$ T_1(s) = G_1(s) \\cdot \\frac{G_2(s)}{1 + G_2(s)H_1(s)} = \\frac{G_1(s)G_2(s)}{1 + G_2(s)H_1(s)} $$\n\n2.  **支路2的传递函数 ($T_2(s)$)**:\n    该支路在结构上与第一个相同。通过类比，我们将 $G_1(s), G_2(s), H_1(s)$ 替换为 $G_3(s), G_4(s), H_2(s)$。\n    -   反馈部分的传递函数为 $\\frac{G_4(s)}{1+G_4(s)H_2(s)}$。\n    -   这与 $G_3(s)$ 串联。\n    -   因此，整个下支路的传递函数为：\n        $$ T_2(s) = G_3(s) \\cdot \\frac{G_4(s)}{1 + G_4(s)H_2(s)} = \\frac{G_3(s)G_4(s)}{1 + G_4(s)H_2(s)} $$\n\n3.  **总传递函数 ($T(s)$)**:\n    将两个并联支路的传递函数相加得到：\n    $$ T(s) = T_1(s) + T_2(s) = \\frac{G_1(s)G_2(s)}{1 + G_2(s)H_1(s)} + \\frac{G_3(s)G_4(s)}{1 + G_4(s)H_2(s)} $$\n    为与MGF结果进行验证，我们可以将此表达式通分：\n    $$ T(s) = \\frac{G_1(s)G_2(s)(1 + G_4(s)H_2(s))}{(1 + G_2(s)H_1(s))(1 + G_4(s)H_2(s))} + \\frac{G_3(s)G_4(s)(1 + G_2(s)H_1(s))}{(1 + G_2(s)H_1(s))(1 + G_4(s)H_2(s))} $$\n    $$ T(s) = \\frac{G_1(s)G_2(s)(1 + G_4(s)H_2(s)) + G_3(s)G_4(s)(1 + G_2(s)H_1(s))}{(1 + G_2(s)H_1(s))(1 + G_4(s)H_2(s))} $$\n该表达式与使用Mason增益公式推导出的表达式相同。独立验证成功。最终表达式的结构证实了总系统响应是两个独立的并行子系统响应之和。", "answer": "$$ \\boxed{\\frac{G_{1}(s)G_{2}(s)(1 + G_{4}(s)H_{2}(s)) + G_{3}(s)G_{4}(s)(1 + G_{2}(s)H_{1}(s))}{(1 + G_{2}(s)H_{1}(s))(1 + G_{4}(s)H_{2}(s))}} $$", "id": "2690600"}]}