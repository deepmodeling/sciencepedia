{"hands_on_practices": [{"introduction": "稳定性是任何反馈系统最基本的要求。然而，“稳定”这一概念本身存在细微差别，仅仅观察到系统对某个特定输入的响应是有界的，并不足以保证整个系统是良态的。这个练习 [@problem_id:2708249] 旨在挑战这一常见误解，它将引导你深入探索内部稳定性与输入-输出稳定性之间的关键区别，并揭示极点-零点对消在线性系统分析中可能带来的“隐藏”风险。", "problem": "考虑一个拉普拉斯域中的单输入单输出、线性时不变、单位负反馈互联系统，其前向通路的控制器和被控对象分别为 $K(s)=k$ 和 $P(s)=\\frac{1}{s(s-1)}$。外部参考输入为 $r(t)$，控制信号为 $u(t)$，测量输出为 $y(t)$。假设所有信号都是可进行拉普拉斯变换的，并且对于所有实数 $k$，该反馈互联系统都是适定的。使用反馈互联的基本原理，并结合以下定义，来推导您的结论：\n\n- 有界输入有界输出 (BIBO) 稳定性被定义为：任何有界的外部输入都会产生有界的测量输出的性质。这等效于从外源输入到测量输出的每一个闭环传递函数都是真的，并且其所有极点都严格位于开左半平面内。\n- 内部稳定性（也称为闭环实现的渐近稳定性）被定义为：互联实现的所有内部模态（包括那些从所选输入输出通道可能不可观测或不可控的模态）都具有严格为负的实部。\n\n任务：\n1. 从求和点和框图关系出发，推导从 $r$ 到 $y$ 的闭环传递函数，不要使用任何预先记忆的灵敏度公式。\n2. 使用您得到的多项式，通过基本原理分析闭环极点，来描述对于实数 $k$ 时从 $r$ 到 $y$ 的映射的 BIBO 稳定性。\n3. 确定使该互联系统 BIBO 稳定但非内部稳定的所有实数 $k$ 的集合。您的论证必须明确说明，在这种配置下，任何不稳定的内部模态是否会因闭环输入输出映射中的代数极点-零点对消而被隐藏（不可观测和/或不可控），并从原理上解释这种隐藏的不稳定模态的作用。\n\n用标准数学符号将您的最终答案表示为一个集合。无需四舍五入，也不涉及物理单位。", "solution": "我们将通过验证其前提条件来分析该问题，然后使用线性控制理论的基本原理来完成指定的任务。\n\n首先，我们推导从参考输入 $r$ 到测量输出 $y$ 的闭环传递函数。设 $R(s)$、$U(s)$ 和 $Y(s)$ 分别是 $r(t)$、$u(t)$ 和 $y(t)$ 的拉普拉斯变换。对于单位负反馈配置，求和点处的误差信号由下式给出：\n$$E(s) = R(s) - Y(s)$$\n控制信号 $U(s)$ 由控制器 $K(s)$ 作用于误差 $E(s)$ 产生：\n$$U(s) = K(s) E(s) = k(R(s) - Y(s))$$\n被控对象输出 $Y(s)$ 是被控对象 $P(s)$ 作用于控制信号 $U(s)$ 的结果：\n$$Y(s) = P(s) U(s) = \\frac{1}{s(s-1)} U(s)$$\n将 $U(s)$ 的表达式代入 $Y(s)$ 的方程中，得到：\n$$Y(s) = \\frac{k}{s(s-1)} (R(s) - Y(s))$$\n我们重新整理各项，以求解比率 $\\frac{Y(s)}{R(s)}$：\n$$Y(s) \\left(1 + \\frac{k}{s(s-1)}\\right) = \\frac{k}{s(s-1)} R(s)$$\n$$Y(s) \\left(\\frac{s(s-1) + k}{s(s-1)}\\right) = \\frac{k}{s(s-1)} R(s)$$\n这给出了从 $r$ 到 $y$ 的闭环传递函数，从而完成了任务 1：\n$$T_{yr}(s) = \\frac{Y(s)}{R(s)} = \\frac{k}{s(s-1) + k} = \\frac{k}{s^2 - s + k}$$\n\n对于任务 2，我们描述从 $r$ 到 $y$ 的映射的有界输入有界输出 (BIBO) 稳定性。这要求传递函数 $T_{yr}(s)$ 的所有极点都严格位于开左半平面内。我们通过求解特征多项式 $\\Delta(s) = s^2 - s + k = 0$ 的根来检验极点。\n根据 $k$ 的值，有两种情况。\n情况 1：$k \\neq 0$。$T_{yr}(s)$ 的极点是 $s^2 - s + k = 0$ 的根。设根为 $p_1$ 和 $p_2$。根据韦达定理，根的和为 $p_1 + p_2 = -(-1)/1 = 1$。根的实部之和为 $\\text{Re}(p_1 + p_2) = \\text{Re}(p_1) + \\text{Re}(p_2) = 1$。要使两个极点都位于开左半平面，必须满足 $\\text{Re}(p_1) < 0$ 和 $\\text{Re}(p_2) < 0$。这将意味着 $\\text{Re}(p_1) + \\text{Re}(p_2) < 0$，这与实部之和为 $1$ 的事实相矛盾。因此，对于任何 $k \\neq 0$，至少有一个极点不位于开左半平面内，所以从 $r$ 到 $y$ 的映射不是 BIBO 稳定的。\n情况 2：$k=0$。传递函数变为 $T_{yr}(s) = \\frac{0}{s^2-s} = 0$。一个恒为零的传递函数没有极点。具有零传递函数的系统是 BIBO 稳定的，因为任何有界输入产生的输出始终为零，而零是有界的。\n综合这两种情况，从 $r$ 到 $y$ 的映射是 BIBO 稳定的，当且仅当 $k=0$。\n\n对于任务 3，我们必须找到使该互联系统 BIBO 稳定但非内部稳定的所有实数 $k$ 的集合。\n首先，我们分析内部稳定性。闭环系统的内部模态是特征方程 $1 + P(s)K(s) = 0$ 的根，前提是开环传递函数 $L(s) = P(s)K(s)$ 中没有极点-零点对消。在此，$L(s) = \\frac{k}{s(s-1)}$，没有发生此类对消。特征方程为 $1 + \\frac{k}{s(s-1)} = 0$，可简化为 $s^2 - s + k = 0$。为使系统内部稳定，其所有内部模态（即该多项式的根）的实部必须严格为负。正如在任务 2 的分析中所确立的，这些根的实部之和恒为 $1$。对于任何实数 $k$，这个稳定性条件都无法满足。因此，对于任何 $k \\in \\mathbb{R}$，该互联系统都永不具备内部稳定性。\n\n接下来，我们分析该互联系统的 BIBO 稳定性。根据问题给出的严格定义，这要求从外源输入到测量输出的*每一个*闭环传递函数的所有极点都位于开左半平面内。我们考虑一个加在被控对象输入端的外源扰动输入 $d(t)$。此时被控对象的输出为 $Y(s) = P(s)(U(s)+D(s))$。从该扰动 $d$ 到输出 $y$ 的传递函数由 $T_{yd}(s) = \\frac{P(s)}{1+P(s)K(s)}$ 给出。代入 $P(s)$ 和 $K(s)$ 的给定表达式：\n$$T_{yd}(s) = \\frac{\\frac{1}{s(s-1)}}{1+\\frac{k}{s(s-1)}} = \\frac{1}{s(s-1)+k} = \\frac{1}{s^2-s+k}$$\n要使该互联系统 BIBO 稳定，$T_{yd}(s)$ 的极点（即 $s^2-s+k=0$ 的根）必须全部位于开左半平面内。如前所示，对于任何实数 $k$，这都永不成立。由于对于任何 $k$ 都存在至少一个不稳定的输入输出映射，因此该互联系统永不具备 BIBO 稳定性。\n\n问题要求的是使该互联系统 BIBO 稳定 且 非内部稳定的 $k$ 的集合。\n- 条件“该互联系统是 BIBO 稳定的”对任何实数 $k$ 都不成立。满足此条件的 $k$ 的集合为空集 $\\emptyset$。\n- 条件“该互联系统是非内部稳定的”对所有实数 $k$ 都成立。满足此条件的 $k$ 的集合为 $\\mathbb{R}$。\n这两个集合的交集是 $\\emptyset \\cap \\mathbb{R} = \\emptyset$。\n\n问题要求对隐藏模态进行明确的讨论。当 $k=0$ 时，系统是非内部稳定的，其模态位于 $s=0$ 和 $s=1$。然而，传递函数 $T_{yr}(s)$ 为零，因此是稳定的。这是在状态空间实现背景下的极点-零点对消情况：不稳定的内部模态与参考输入 $r$ 没有连接。它们之所以被“隐藏”，是因为它们对于 $r$ 是不可控的。然而，这些模态并非在所有通道中都被隐藏。它们在扰动传递函数 $T_{yd}(s) = \\frac{1}{s(s-1)}$ 中表现为极点。根据所给定义，此映射的不稳定性导致整个互联系统不是 BIBO 稳定的。对于任何 $k \\neq 0$，都不会发生此类对消，不稳定的内部模态会在所有传递函数（包括 $T_{yr}(s)$ 和 $T_{yd}(s)$）中表现为不稳定的极点。", "answer": "$$\\boxed{\\emptyset}$$", "id": "2708249"}, {"introduction": "反馈是一把双刃剑：它在抑制扰动、改善系统性能的同时，也可能放大我们不希望看到的信号，例如传感器测量噪声。这个实践练习 [@problem_id:2708252] 将让你亲身体验这一核心的工程权衡，你将学习使用系统的 $\\mathcal{H}_2$ 范数来量化噪声放大的程度。通过调整控制器增益，你需要在满足输出方差约束的前提下，找到一个最佳的平衡点。", "problem": "考虑一个连续时间、单输入单输出 (SISO) 的线性时不变 (LTI) 单位负反馈回路，其中受控对象为 $P(s)=\\dfrac{5}{(s+1)(s+5)}$，控制器为 $K(s)=k\\dfrac{s+1}{s/10+1}$，其中标量增益 $k \\ge 0$。测量信号受到加性测量噪声 $n(t)$ 的干扰，该噪声具有单位（单边）功率谱密度，理想化为单位强度的连续时间白噪声。假设参考输入恒为零，因此唯一的激励是在传感器处加性注入到受控对象输出上的测量噪声。闭环输出 $y(t)$ 被测量并反馈，形成一个标准的负反馈互连结构。\n\n需要在程序中实现的任务：\n\n1) 根据反馈互连的基本原理，推导从测量噪声 $n(t)$ 到受控对象输出 $y(t)$ 的闭环传递函数 $T(s)$。\n\n2) 利用严格真、内部稳定的 LTI 系统的 $\\mathcal{H}_2$ 范数定义，以及在单位强度白噪声激励下输出方差与 $\\mathcal{H}_2$ 范数平方之间的等价关系，将由 $n(t)$ 引起的输出方差 $\\sigma_y^2$ 表示为 $T(s)$ 的参数和控制器增益 $k$ 的函数。\n\n3) 对于给定的非负 $k$ 和指定的方差上限 $V_{\\max} \\ge 0$，计算：\n   - 给定 $k$ 对应的噪声放大系数 $\\lVert T \\rVert_2$（即 $\\mathcal{H}_2$ 范数）。\n   - 一个调整后的增益 $k_{\\text{adj}} \\in [0,k]$，该增益应在保证方差约束 $\\sigma_y^2 \\le V_{\\max}$ 的前提下尽可能大。\n   - 在 $k_{\\text{adj}}$ 下的最终输出方差。\n\n所有计算都必须在闭环系统内部稳定的假设下进行。如果 $V_{\\max}=0$，则取 $k_{\\text{adj}}=0$。\n\n您必须使用的基础理论：\n- 基于基本加法节点和串联互联规则构建的标准单位负反馈回路中，灵敏度函数和补灵敏度函数的定义。\n- 对于一个传递函数为 $G(s)$ 的严格真、渐近稳定的 LTI 系统，其 $\\mathcal{H}_2$ 范数的定义为：$\\lVert G \\rVert_2^2 = \\dfrac{1}{2\\pi}\\displaystyle\\int_{-\\infty}^{\\infty} \\lvert G(\\mathrm{j}\\omega) \\rvert^2 \\,\\mathrm{d}\\omega$，等价地，$\\lVert G \\rVert_2^2 = \\operatorname{trace}(CWC^\\top)$，其中 $W$ 是可控性格拉姆矩阵，是 $G(s)$ 的一个最小实现 $(A,B,C,0)$ 所对应的连续时间李雅普诺夫方程 $AW + WA^\\top + BB^\\top = 0$ 的解。\n- 在单位强度白噪声输入下，一个严格真、稳定的 LTI 系统输出的稳态方差等于其 $\\mathcal{H}_2$ 范数的平方，即 $\\lVert G \\rVert_2^2$ 这一性质。\n\n您的程序必须实现上述步骤，并为以下参数值测试集生成结果。每个测试用例是一个参数对 $(k, V_{\\max})$：\n\n- 用例 1 (一般情况): $(0.5, 10.0)$。\n- 用例 2 (约束激活): $(2.0, 1.0)$。\n- 用例 3 (位于边界): $(0.75, 0.5357142857142857)$。\n- 用例 4 (严格限制): $(1.0, 0.0001)$。\n- 用例 5 (零限制): $(3.0, 0.0)$。\n\n对于每个用例，计算三个量：\n- 给定 $k$ 时的初始噪声放大系数 $\\lVert T \\rVert_2$。\n- 为满足 $\\sigma_y^2 \\le V_{\\max}$ 同时最大化 $k_{\\text{adj}} \\le k$ 而选择的调整后增益 $k_{\\text{adj}}$。\n- 在 $k_{\\text{adj}}$ 下的最终输出方差 $\\sigma_y^2$。\n\n数值和输出要求：\n- 将所有最终数值输出表示为无量纲实数，并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个子列表，顺序与上文指定的一致。每个子列表必须采用 $[\\lVert T \\rVert_2, k_{\\text{adj}}, \\sigma_y^2]$ 的形式，并使用上述的四舍五入规则。例如，包含两个用例的一行输出应如下所示：$[[0.123456,0.100000,0.015000],[0.234567,0.200000,0.030000]]$。", "solution": "所给出的问题是分析受随机扰动影响的线性时不变 (LTI) 反馈系统的一个标准练习。该问题具有科学依据，提法明确且客观。问题陈述是有效的，因为它包含了所有必要信息，内部逻辑一致，并依赖于控制理论的既定原理。我们将进行一个正式的、分步的推导和求解。\n\n主要目标是分析测量噪声对受控对象输出的影响，并设计一个满足输出方差约束的控制器增益。该系统是一个单位反馈回路，其受控对象为 $P(s) = \\dfrac{5}{(s+1)(s+5)}$，控制器为 $K(s) = k\\dfrac{s+1}{s/10+1}$。参考输入 $r(t)$ 为零，系统由单位强度的加性白测量噪声 $n(t)$ 激励。\n\n**步骤 1：推导噪声到输出的传递函数**\n\n在拉普拉斯域中，闭环系统的动态由以下信号关系描述：\n1. 受控对象输出：$Y(s) = P(s)U(s)$\n2. 控制器输入：$E(s) = R(s) - (Y(s) + N(s))$\n3. 控制器输出：$U(s) = K(s)E(s)$\n\n给定参考 $R(s) = 0$，控制器输入简化为 $E(s) = -(Y(s) + N(s))$。\n将此代入控制器输出方程，得到受控对象输入：\n$U(s) = -K(s)(Y(s) + N(s))$\n\n于是受控对象输出为：\n$Y(s) = P(s)U(s) = -P(s)K(s)(Y(s) + N(s)) = -P(s)K(s)Y(s) - P(s)K(s)N(s)$\n\n为了找到从噪声输入 $N(s)$ 到受控对象输出 $Y(s)$ 的传递函数，我们重新整理方程以求解 $Y(s)$：\n$Y(s) + P(s)K(s)Y(s) = -P(s)K(s)N(s)$\n$Y(s)(1 + P(s)K(s)) = -P(s)K(s)N(s)$\n\n因此，所求的传递函数（记作 $T(s)$）为：\n$T(s) = \\dfrac{Y(s)}{N(s)} = -\\dfrac{P(s)K(s)}{1 + P(s)K(s)}$\n\n这是补灵敏度函数的负值。首先计算环路传递函数 $L(s) = P(s)K(s)$：\n$L(s) = \\left(\\dfrac{5}{(s+1)(s+5)}\\right) \\left(k\\dfrac{s+1}{0.1s+1}\\right) = \\dfrac{5k}{(s+5)(0.1s+1)}$\n注意到在 $s=-1$ 处存在极零点对消。由于被对消的极点是稳定的，只要简化后的闭环系统稳定，内部稳定性就能得以保持。\n\n将 $L(s)$ 代入 $T(s)$ 的表达式：\n$T(s) = -\\dfrac{\\frac{5k}{(s+5)(0.1s+1)}}{1 + \\frac{5k}{(s+5)(0.1s+1)}} = -\\dfrac{5k}{(s+5)(0.1s+1) + 5k}$\n展开分母多项式：\n$(s+5)(0.1s+1) + 5k = 0.1s^2 + s + 0.5s + 5 + 5k = 0.1s^2 + 1.5s + 5(1+k)$\n\n为将分母的首项系数归一化，我们将分子和分母同乘以 $10$：\n$T(s) = -\\dfrac{50k}{s^2 + 15s + 50(1+k)}$\n\n**步骤 2：稳定性与输出方差**\n\n闭环系统的稳定性由其特征多项式（即 $T(s)$ 的分母）的根决定：$s^2 + 15s + 50(1+k) = 0$。对于二阶多项式，如果所有系数均为正，则其稳定性（所有根位于左半平面）得到保证。给定 $k \\ge 0$，系数 $1$、$15$ 和 $50(1+k)$ 均为正。因此，对于所有非负增益 $k$，该闭环系统都是内部稳定的。\n\n问题陈述指出，对于一个由单位强度白噪声激励的严格真、稳定的 LTI 系统，其传递函数为 $G(s)$，输出的稳态方差等于系统 $\\mathcal{H}_2$ 范数的平方，即 $\\sigma^2 = \\lVert G \\rVert_2^2$。传递函数 $T(s)$ 是严格真且稳定的。\n\n对于一个一般的二阶系统 $G(s) = \\dfrac{b_0}{s^2 + a_1s + a_0}$，其 $\\mathcal{H}_2$ 范数的平方由公式 $\\lVert G \\rVert_2^2 = \\dfrac{b_0^2}{2a_1a_0}$ 给出。\n对于我们的传递函数 $T(s)$，参数为：\n$b_0 = -50k$\n$a_1 = 15$\n$a_0 = 50(1+k)$\n\n输出方差 $\\sigma_y^2$ 作为增益 $k$ 的函数为：\n$\\sigma_y^2(k) = \\lVert T \\rVert_2^2 = \\dfrac{(-50k)^2}{2(15)(50(1+k))} = \\dfrac{2500k^2}{1500(1+k)} = \\dfrac{5k^2}{3(1+k)}$\n\n噪声放大系数即 $\\mathcal{H}_2$ 范数本身：对于 $k \\ge 0$，$\\lVert T \\rVert_2(k) = \\sqrt{\\sigma_y^2(k)} = k\\sqrt{\\dfrac{5}{3(1+k)}}$。\n\n**步骤 3：增益调整算法**\n\n我们必须找到满足方差约束 $\\sigma_y^2(k_{\\text{adj}}) \\le V_{\\max}$ 的最大增益 $k_{\\text{adj}} \\in [0, k]$。为此，我们分析 $\\sigma_y^2$ 与 $k$ 之间的关系。方差对 $k$ 的导数为：\n$\\dfrac{d\\sigma_y^2}{dk} = \\dfrac{5}{3}\\dfrac{d}{dk}\\left(\\dfrac{k^2}{1+k}\\right) = \\dfrac{5}{3}\\dfrac{2k(1+k) - k^2}{(1+k)^2} = \\dfrac{5}{3}\\dfrac{k^2+2k}{(1+k)^2}$\n对于 $k > 0$，该导数严格为正。因此，对于 $k \\ge 0$，$\\sigma_y^2(k)$ 是 $k$ 的一个单调递增函数。\n\n这种单调性决定了对于给定的输入对 $(k, V_{\\max})$，应遵循以下逻辑：\n1.  计算在给定增益 $k$ 下的方差：$\\sigma_y^2(k) = \\dfrac{5k^2}{3(1+k)}$。\n2.  将此方差与最大允许方差 $V_{\\max}$ 进行比较。\n    - 如果 $\\sigma_y^2(k) \\le V_{\\max}$，则约束已满足。在允许范围 $[0, k]$ 内可能的最大增益就是 $k$ 本身。因此，$k_{\\text{adj}} = k$。最终方差为 $\\sigma_y^2(k)$。\n    - 如果 $\\sigma_y^2(k) > V_{\\max}$，则增益 $k$ 过高。由于单调性，满足约束的最大增益是一个值 $k_{\\text{adj}} < k$，使得方差恰好等于上限，即 $\\sigma_y^2(k_{\\text{adj}}) = V_{\\max}$。我们必须求解此方程以得到 $k_{\\text{adj}}$。\n\n需要求解的方程是：\n$\\dfrac{5k_{\\text{adj}}^2}{3(1+k_{\\text{adj}})} = V_{\\max}$\n$5k_{\\text{adj}}^2 = 3V_{\\max}(1+k_{\\text{adj}})$\n$5k_{\\text{adj}}^2 - (3V_{\\max})k_{\\text{adj}} - 3V_{\\max} = 0$\n\n这是一个关于 $k_{\\text{adj}}$ 的二次方程。应用二次公式并选择非负根（因为 $k_{\\text{adj}} \\ge 0$ 且 $V_{\\max} \\ge 0$）：\n$k_{\\text{adj}} = \\dfrac{3V_{\\max} + \\sqrt{(3V_{\\max})^2 - 4(5)(-3V_{\\max})}}{2(5)} = \\dfrac{3V_{\\max} + \\sqrt{9V_{\\max}^2 + 60V_{\\max}}}{10}$\n在这种情况下，根据构造，最终的方差为 $\\sigma_y^2(k_{\\text{adj}}) = V_{\\max}$。\n\n从方差公式可知，$V_{\\max}=0$ 的特殊情况意味着 $k=0$ 是唯一的非负解。问题陈述明确指示，如果 $V_{\\max}=0$，我们必须设置 $k_{\\text{adj}}=0$。\n\n程序实现将对每个测试用例遵循此逻辑。\n对于每对 $(k, V_{\\max})$，程序将计算：\n1. 给定 $k$ 时的初始噪声放大系数：$\\lVert T \\rVert_2(k) = \\sqrt{\\frac{5k^2}{3(1+k)}}$。\n2. 使用上述逻辑计算出的调整后增益 $k_{\\text{adj}}$。\n3. 在调整后增益下的最终输出方差：$\\sigma_y^2(k_{\\text{adj}})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the control theory problem for a suite of test cases.\n\n    The solution involves:\n    1. Calculating the initial noise amplification (H2 norm) for a given gain k.\n    2. Determining the maximum adjusted gain k_adj <= k that satisfies a variance constraint.\n    3. Computing the output variance at k_adj.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (k_initial, V_max).\n    test_cases = [\n        (0.5, 10.0),\n        (2.0, 1.0),\n        (0.75, 0.5357142857142857),\n        (1.0, 0.0001),\n        (3.0, 0.0),\n    ]\n\n    results = []\n    \n    # Process each test case\n    for k_in, v_max in test_cases:\n        # Step 1: Compute initial noise amplification factor\n        # The output variance is sigma_y^2 = (5 * k^2) / (3 * (1 + k))\n        # The noise amplification factor is the H2 norm, which is sqrt(sigma_y^2)\n        if k_in == 0:\n            initial_variance = 0.0\n        else:\n            initial_variance = (5.0 * k_in**2) / (3.0 * (1.0 + k_in))\n        \n        h2_norm = np.sqrt(initial_variance)\n\n        # Step 2 & 3: Compute adjusted gain k_adj and final variance\n        \n        # Handle special case as per problem statement\n        if v_max == 0.0:\n            k_adj = 0.0\n            final_variance = 0.0\n        # If initial variance is within the limit, no adjustment is needed\n        elif initial_variance <= v_max:\n            k_adj = k_in\n            final_variance = initial_variance\n        # If initial variance exceeds the limit, we must reduce the gain\n        else:\n            # We solve the quadratic equation 5*k^2 - (3*V_max)*k - 3*V_max = 0 for k.\n            # k_adj is the positive root of this equation.\n            a = 5.0\n            b = -3.0 * v_max\n            c = -3.0 * v_max\n            \n            discriminant = np.sqrt(b**2 - 4.0 * a * c)\n            k_adj = (-b + discriminant) / (2.0 * a)\n            \n            # The resulting variance is V_max by construction\n            final_variance = v_max\n            \n        results.append([h2_norm, k_adj, final_variance])\n\n    # Format the final output string exactly as required\n    formatted_cases = []\n    for case_result in results:\n        # case_result is a list [h2_norm, k_adj, final_variance]\n        # Format each number to six decimal places\n        formatted_numbers = [f\"{num:.6f}\" for num in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2708252"}, {"introduction": "真实的控制系统设计往往需要在多个相互冲突的性能指标之间进行权衡。这个综合性练习 [@problem_id:2708282] 介绍了一种强大的现代控制设计方法——混合灵敏度 $\\mathcal{H}_{\\infty}$ 综合。你将学习如何通过设计加权函数来精确地表达对系统性能（如指令跟踪和噪声抑制）的要求，并利用数值优化方法综合出一个能在这些目标之间达到最佳平衡的控制器。", "problem": "要求您实现一个完整的、可运行的程序，该程序基于反馈原理综合一个连续时间反馈控制器，并在哈代空间无穷范数（$\\mathcal{H}_{\\infty}$）的意义下评估加权闭环性能。被控对象是线性时不变（LTI）的，性能目标通过加权灵敏度函数和加权互补灵敏度函数来定义。\n\n给定 LTI 单输入单输出被控对象\n$$\nP(s)=\\frac{1}{s(s+1)},\n$$\n以及加权函数\n$$\nW_{1}(s)=\\frac{s/0.1+1}{s/10+1},\\qquad W_{3}(s)=\\frac{s/100+1}{s/1000+1},\n$$\n您必须从严格真超前-滞后控制器族\n$$\nK(s)=k\\frac{s+z}{s+p},\n$$\n（其中 $k>0$, $z>0$, $p>0$）中选择一个镇定控制器，以最小化性能指标\n$$\n\\gamma=\\max\\left(\\lVert W_{1}S\\rVert_{\\infty},\\,\\lVert W_{3}T\\rVert_{\\infty}\\right),\n$$\n其中灵敏度函数 $S$ 和互补灵敏度函数 $T$ 由闭环关系\n$$\nS(s)=\\frac{1}{1+L(s)},\\qquad T(s)=\\frac{L(s)}{1+L(s)},\\qquad L(s)=P(s)K(s)\n$$\n定义。\n对于给定的频率 $\\omega$（单位为弧度/秒），用 $j\\omega$ 表示在虚轴上的取值。对于有理函数 $G(s)$，使用 $G(j\\omega)$ 来计算幅值响应。一个稳定真传递函数 $G$ 的 $\\mathcal{H}_{\\infty}$ 范数是\n$$\n\\lVert G\\rVert_{\\infty}=\\sup_{\\omega\\in\\mathbb{R}}\\sigma_{\\max}\\bigl(G(j\\omega)\\bigr),\n$$\n对于单输入单输出系统，这简化为幅值 $\\lvert G(j\\omega)\\rvert$ 在所有 $\\omega$ 上的上确界。\n\n您的程序必须：\n1. 在 $k, z, p$ 上进行搜索，找到一个镇定控制器 $K(s)$，它能最小化如上定义的 $\\gamma$。$\\mathcal{H}_{\\infty}$ 范数的计算基于在一个足够密集的对数频率网格（$\\omega$ 单位为弧度/秒）上的扫频近似。您必须通过检查闭环特征多项式的所有极点是否都具有严格为负的实部来明确地验证闭环稳定性。\n2. 一旦找到最佳控制器参数 $(k^{\\star},z^{\\star},p^{\\star})$，使用相同的频率网格计算并报告所达到的 $\\gamma$ 值，以及两个构成范数 $\\lVert W_{1}S\\rVert_{\\infty}$ 和 $\\lVert W_{3}T\\rVert_{\\infty}$。\n\n您必须使用的基本原理：\n- 反馈互联定义：$S(s)=\\frac{1}{1+L(s)}$, $T(s)=\\frac{L(s)}{1+L(s)}$, $L(s)=P(s)K(s)$。\n- 对于单输入单输出系统，$\\mathcal{H}_{\\infty}$ 范数定义为频率响应幅值的上确界。\n- 通过特征多项式的根严格位于开左半平面来进行闭环稳定性测试。\n\n您的搜索必须是完全数值化的，不得使用符号代数或任何用于综合的控制专用库函数。频率单位应为弧度/秒。\n\n测试套件和要求输出：\n- 使用如上指定的被控对象 $P(s)$ 和权重 $W_{1}(s)$, $W_{3}(s)$。\n- 评估三个性能界限的目标水平 $\\gamma_{\\text{target}}$：$[1.5,\\,1.2,\\,1.05]$（所有值均无单位）。\n- 为测试套件中的每个 $\\gamma_{\\text{target}}$，程序必须判断所综合的最佳控制器是否满足 $\\gamma<\\gamma_{\\text{target}}$，并按顺序报告由布尔可行性、实现的 $\\gamma$、实现的 $\\lVert W_{1}S\\rVert_{\\infty}$ 和实现的 $\\lVert W_{3}T\\rVert_{\\infty}$ 组成的元组。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素本身是 $[\\text{feasible},\\gamma,\\lVert W_{1}S\\rVert_{\\infty},\\lVert W_{3}T\\rVert_{\\infty}]$ 形式的列表。\n- 例如，包含三个用例的输出应如下所示： $[[\\text{True},1.23,1.10,1.08],[\\text{True},1.18,1.05,1.12],[\\text{False},1.34,1.30,1.20]]$。\n- 所有频率计算必须以弧度/秒为单位进行，最终输出不需要物理单位。\n\n您的最终答案必须是一个单一、完整、可运行的 Python 程序，该程序通过数值搜索执行综合，并仅按上述确切格式打印所需的单行内容。不允许用户输入或外部文件。答案必须是自包含且可复现的。", "solution": "所述问题是控制系统工程领域一个有效的练习。它具有科学依据，是一个适合数值求解的良态问题，并且所有术语和目标都经过了数学上的精确定义。任务是执行一个固定结构控制器的数值综合，以满足混合灵敏度 $\\mathcal{H}_{\\infty}$ 性能目标。我们将着手解决。\n\n问题的核心是为超前-滞后控制器\n$$\nK(s) = k\\frac{s+z}{s+p}\n$$\n（其中 $k>0$, $z>0$, 且 $p>0$）找到参数 $(k, z, p)$，以最小化性能指标 $\\gamma$。该指标定义为两个加权 $\\mathcal{H}_{\\infty}$ 范数的最大值：\n$$\n\\gamma = \\max\\left(\\lVert W_{1}S\\rVert_{\\infty}, \\lVert W_{3}T\\rVert_{\\infty}\\right)\n$$\n该系统包含一个单输入单输出被控对象 $P(s)$，其灵敏度函数 $S(s)$ 和互补灵敏度函数 $T(s)$ 由标准反馈关系给出：\n$$\nS(s) = \\frac{1}{1+L(s)}, \\quad T(s) = \\frac{L(s)}{1+L(s)}\n$$\n其中 $L(s) = P(s)K(s)$ 是开环传递函数。被控对象和加权函数指定为：\n$$\nP(s) = \\frac{1}{s(s+1)}, \\quad W_{1}(s)=\\frac{s/0.1+1}{s/10+1}, \\quad W_{3}(s)=\\frac{s/100+1}{s/1000+1}\n$$\n\n任何解决方案的一个强制性先决条件是闭环系统的稳定性。闭环系统的特征多项式是 $1+L(s)$ 的分子。我们推导出该多项式为：\n$$\n1+L(s) = 1 + \\frac{k(s+z)}{s(s+1)(s+p)} = \\frac{s(s+1)(s+p) + k(s+z)}{s(s+1)(s+p)}\n$$\n因此特征多项式为 $\\Delta(s) = s^3 + (p+1)s^2 + (p+k)s + kz$。对于一个三阶多项式 $a_3s^3+a_2s^2+a_1s+a_0=0$，Routh-Hurwitz 稳定性判据要求所有系数为正，并且 $a_2 a_1 > a_3 a_0$。鉴于约束条件 $k>0$, $z>0$, $p>0$，所有系数 $a_3=1$, $a_2=p+1$, $a_1=p+k, a_0=kz$ 均严格为正。因此，稳定性条件简化为单个不等式：\n$$\n(p+1)(p+k) > kz\n$$\n任何违反此条件的参数集 $(k, z, p)$ 都会导致不稳定的控制器，并被立即舍弃。\n\n该问题通过数值优化来解决。对于单输入单输出系统，一个稳定传递函数 $G(s)$ 的 $\\mathcal{H}_{\\infty}$ 范数是其在虚轴上幅值的上确界：\n$$\n\\lVert G \\rVert_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} |G(j\\omega)|\n$$\n这个上确界通过在一个密集的对数间隔频率网格 $\\omega$ 上评估 $|G(j\\omega)|$ 并找到最大值来进行数值近似。\n\n综合任务被表述为以下优化问题：\n$$\n\\min_{k,z,p} \\gamma(k,z,p) \\quad \\text{约束条件为} \\quad k>0, z>0, p>0 \\quad \\text{且} \\quad (p+1)(p+k) > kz\n$$\n为处理正性约束，采用了对数变量代换：$k=10^{x_1}$，$z=10^{x_2}$，$p=10^{x_3}$。然后对无约束实变量 $(x_1, x_2, x_3)$ 进行优化。构建一个目标函数，它接受这些对数参数，计算出相应的 $(k, z, p)$，检查稳定性，如果系统稳定，则计算并返回 $\\gamma$。如果系统不稳定，函数返回一个无穷大惩罚，以引导优化器远离此类区域。\n\n使用一种无导数优化算法，特别是 `scipy.optimize.minimize` 提供的 Nelder-Mead 方法，来寻找最优参数。为了增加找到全局最优解并避免陷入较差的局部最小值的概率，实施了多起点策略。优化程序从参数空间中的几个不同初始点执行，并将获得的最佳结果作为最终解。\n\n一旦确定了最优参数 $(k^{\\star}, z^{\\star}, p^{\\star})$ 和最小性能指标 $\\gamma^{\\star}$，最后一步是根据三个指定的目标值 $\\gamma_{\\text{target}} \\in \\{1.5, 1.2, 1.05\\}$ 来评估这一结果。对于每个目标，我们判断所实现的性能是否更优（即 $\\gamma^{\\star} < \\gamma_{\\text{target}}$），并报告布尔可行性以及所实现的 $\\gamma^{\\star}$ 和构成范数 $\\lVert W_{1}S\\rVert_{\\infty}$、$\\lVert W_{3}T\\rVert_{\\infty}$。最终输出被构造成这些评估元组的列表，精确遵循指定的格式。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport sys\n\n# Suppress runtime warnings that can occur with complex numbers (e.g., divide by zero in L).\n# The optimization logic handles these cases by returning np.inf.\nnp.seterr(all='ignore')\n\ndef solve():\n    \"\"\"\n    Synthesizes a feedback controller by minimizing a mixed-sensitivity H-infinity\n    performance index and evaluates the result against specified targets.\n    \"\"\"\n    # Define the target performance levels for evaluation from the problem statement.\n    gamma_targets = [1.5, 1.2, 1.05]\n\n    # --- System and Optimization Setup ---\n\n    # Define a dense logarithmic frequency grid for H-infinity norm approximation.\n    # The range covers all relevant dynamics of the plant and weights.\n    omega = np.logspace(-3, 4, 5000)\n    s = 1j * omega\n\n    # Pre-calculate frequency responses of fixed system components.\n    # Plant: P(s) = 1 / (s * (s + 1))\n    P_s = 1 / (s * (s + 1))\n    # Weight 1: W1(s) = (s/0.1 + 1) / (s/10 + 1)\n    W1_s = (s / 0.1 + 1) / (s / 10 + 1)\n    # Weight 3: W3(s) = (s/100 + 1) / (s/1000 + 1)\n    W3_s = (s / 100 + 1) / (s / 1000 + 1)\n\n    # Cache for the optimization to avoid re-computation for the same parameters.\n    cost_cache = {}\n\n    def cost_function(log_params):\n        \"\"\"\n        Calculates the performance index gamma for a given set of controller parameters.\n        Parameters are provided in log10 scale to enforce positivity and handle wide ranges.\n        \"\"\"\n        params_tuple = tuple(log_params)\n        if params_tuple in cost_cache:\n            return cost_cache[params_tuple]\n\n        log_k, log_z, log_p = log_params\n        k = 10**log_k\n        z = 10**log_z\n        p = 10**log_p\n\n        # --- Stability Check ---\n        # Using the Routh-Hurwitz criterion for the 3rd-order characteristic polynomial:\n        # delta(s) = s^3 + (p+1)s^2 + (p+k)s + kz\n        # Condition for stability: (p+1)*(p+k) > k*z\n        if (p + 1) * (p + k) <= k * z:\n            return np.inf  # Return infinity for unstable controllers\n\n        # --- Performance Calculation ---\n        # Controller: K(s) = k * (s + z) / (s + p)\n        K_s = k * (s + z) / (s + p)\n        \n        L_s = P_s * K_s\n        # Add a small epsilon to prevent division by zero if 1+L=0 at some frequency\n        S_s = 1 / (1 + L_s + 1e-12)\n        T_s = L_s / (1 + L_s + 1e-12)\n\n        # Approximate H-infinity norms by finding the maximum magnitude over the frequency grid.\n        norm_w1s = np.max(np.abs(W1_s * S_s))\n        norm_w3t = np.max(np.abs(W3_s * T_s))\n        \n        gamma = np.max([norm_w1s, norm_w3t])\n        \n        cost_cache[params_tuple] = gamma\n        return gamma\n\n    # --- Optimization using a Multi-Start Strategy ---\n    # This mitigates the risk of converging to a poor local minimum.\n    # Initial guesses for [log10(k), log10(z), log10(p)]\n    initial_guesses = [\n        [1.0, 0.0, 1.0],    # k=10, z=1, p=10 (Lead)\n        [0.0, -1.0, 1.0],   # k=1, z=0.1, p=10 (Lead)\n        [1.0, 1.0, 0.0],    # k=10, z=10, p=1 (Lag)\n        [2.0, 0.5, 2.5],    # k=100, z=~3.16, p=~316 (Lead)\n        [1.5, -0.5, 2.0],   # k=~31.6, z=~0.316, p=100 (Lead)\n    ]\n    \n    best_result = None\n    min_gamma = np.inf\n\n    for x0 in initial_guesses:\n        res = minimize(\n            cost_function,\n            x0,\n            method='Nelder-Mead',\n            options={'maxiter': 1500, 'adaptive': True}\n        )\n        if res.success and res.fun < min_gamma:\n            min_gamma = res.fun\n            best_result = res\n\n    # --- Final Evaluation ---\n    # Once the best controller is found, evaluate its performance metrics.\n    if best_result is None or not np.isfinite(min_gamma):\n        # Fallback if no stable solution is found\n        achieved_gamma = np.inf\n        achieved_norm_w1s = np.inf\n        achieved_norm_w3t = np.inf\n    else:\n        log_k_opt, log_z_opt, log_p_opt = best_result.x\n        k_opt, z_opt, p_opt = 10**log_k_opt, 10**log_z_opt, 10**log_p_opt\n\n        K_s_opt = k_opt * (s + z_opt) / (s + p_opt)\n        L_s_opt = P_s * K_s_opt\n        S_s_opt = 1 / (1 + L_s_opt + 1e-12)\n        T_s_opt = L_s_opt / (1 + L_s_opt + 1e-12)\n\n        achieved_norm_w1s = np.max(np.abs(W1_s * S_s_opt))\n        achieved_norm_w3t = np.max(np.abs(W_s_opt))\n        achieved_gamma = np.max([achieved_norm_w1s, achieved_norm_w3t])\n\n    # --- Format Output ---\n    # Assemble the results for each target gamma.\n    results_list = []\n    for target in gamma_targets:\n        feasible = bool(achieved_gamma < target)\n        results_list.append([\n            feasible, \n            achieved_gamma, \n            achieved_norm_w1s, \n            achieved_norm_w3t\n        ])\n    \n    # Construct the output string manually to match the required format exactly\n    # (no spaces between list elements, True/False capitalized).\n    case_strings = []\n    for case in results_list:\n        case_str = f\"[{case[0]},{case[1]},{case[2]},{case[3]}]\"\n        case_strings.append(case_str)\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "2708282"}]}