{"hands_on_practices": [{"introduction": "对偶原理不仅仅是一个理论上的奇观，它更是实践中设计控制系统的强大工具。本练习将展示对偶性最直接的应用：通过解决一个等效的状态反馈控制器问题来设计状态观测器。通过理解为系统 $(A, C)$ 配置观测器极点的问题与为对偶系统 $(A^T, C^T)$ 配置控制器极点的问题是对偶的，我们可以复用相同的极点配置技术，从而加深对控制器增益 $K$ 和观测器增益 $L$ 之间联系的理解。[@problem_id:2703047]", "problem": "考虑如下的单输入单输出 (SISO) 线性时不变 (LTI) 状态空间模型，其状态为 $x \\in \\mathbb{R}^{2}$，输入为 $u \\in \\mathbb{R}$，输出为 $y \\in \\mathbb{R}$：\n$$\n\\dot{x} = A x + B u,\\quad y = C x,\n$$\n其中\n$$\nA = \\begin{pmatrix} 0 & 1 \\\\ -2 & -3 \\end{pmatrix},\\quad B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\\quad C = \\begin{pmatrix} 1 & 0 \\end{pmatrix}.\n$$\n你需要设计一个全状态反馈和一个全阶 Luenberger 观测器。仅使用可控性和可观测性的核心定义，以及状态反馈 $u = -K x$ 产生闭环矩阵 $A - B K$、观测器误差动力学由 $A - L C$ 控制这两个基本事实。\n\n任务：\n- 首先，从基本原理出发，验证系统对 $(A,B)$ 是可控的，系统对 $(A,C)$ 是可观测的。\n- 然后，为状态反馈选择期望的闭环极点为共轭复数对 $-1 \\pm 2 i$，并推导唯一的实行向量 $K = \\begin{pmatrix} k_{1} & k_{2} \\end{pmatrix}$，将这些极点配置给 $A - B K$。\n- 最后，为观测器误差动力学选择期望的极点为相同的共轭复数对 $-1 \\pm 2 i$，并推导唯一的实列向量 $L = \\begin{pmatrix} l_{1} \\\\ l_{2} \\end{pmatrix}$，将这些极点配置给 $A - L C$。你的推理过程应明确利用矩阵和特征多项式层面上的可控性与可观测性之间的对偶性。\n\n将你的最终答案以单一行向量 $\\big(k_{1},\\,k_{2},\\,l_{1},\\,l_{2}\\big)$ 的形式报告。不需要进行数值取整，也不涉及单位。最终答案必须是按指定顺序排列的单一行。", "solution": "在尝试求解之前，必须严格验证问题陈述。\n\n逐字提取给定条件：\n一个单输入单输出线性时不变 (LTI) 状态空间模型由 $\\dot{x} = A x + B u$ 和 $y = C x$ 给出。\n状态为 $x \\in \\mathbb{R}^{2}$，输入为 $u \\in \\mathbb{R}$，输出为 $y \\in \\mathbb{R}$。\n系统矩阵指定为：\n$$\nA = \\begin{pmatrix} 0 & 1 \\\\ -2 & -3 \\end{pmatrix},\\quad B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\\quad C = \\begin{pmatrix} 1 & 0 \\end{pmatrix}.\n$$\n需要设计一个规律为 $u = -K x$ 的全状态反馈控制器，其中增益是一个实行向量 $K = \\begin{pmatrix} k_{1} & k_{2} \\end{pmatrix}$。状态反馈的期望闭环极点是共轭复数对 $-1 \\pm 2 i$。\n需要设计一个全阶 Luenberger 观测器，其中增益是一个实列向量 $L = \\begin{pmatrix} l_{1} \\\\ l_{2} \\end{pmatrix}$。期望的观测器误差动力学极点也是 $-1 \\pm 2 i$。\n任务是：1) 从基本原理出发验证 $(A,B)$ 的可控性和 $(A,C)$ 的可观测性；2) 推导唯一的增益 $K$；3) 明确利用可控性与可观测性之间的对偶性推导唯一的增益 $L$。\n\n问题陈述的验证：\n该问题是线性控制系统理论中一个标准的、定义明确的练习。它具有科学基础，使用了状态空间表示、可控性、可观测性、极点配置和对偶性等基本概念。所有必要信息都已提供，并且矩阵的维度（$A$ 是 $2 \\times 2$，$B$ 是 $2 \\times 1$，$C$ 是 $1 \\times 2$）是一致的。该问题是客观的、无歧义的，并且可以进行数学形式化。不存在违反物理原理或逻辑不一致之处。因此，该问题被认定为 **有效**。我们继续进行求解。\n\n按照要求，解答分为三个部分构建。\n\n首先，我们从基本原理出发验证可控性和可观测性。\n系统是可控的，当且仅当其可控性矩阵 $\\mathcal{C}$ 满秩。对于维度 $n=2$ 的系统，可控性矩阵为 $\\mathcal{C} = \\begin{pmatrix} B & AB \\end{pmatrix}$。\n我们计算乘积 $AB$：\n$$ AB = \\begin{pmatrix} 0 & 1 \\\\ -2 & -3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} (0)(0) + (1)(1) \\\\ (-2)(0) + (-3)(1) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -3 \\end{pmatrix} $$\n然后构成可控性矩阵：\n$$ \\mathcal{C} = \\begin{pmatrix} B & AB \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ 1 & -3 \\end{pmatrix} $$\n$\\mathcal{C}$ 的秩由其行列式决定。\n$$ \\det(\\mathcal{C}) = (0)(-3) - (1)(1) = -1 $$\n由于 $\\det(\\mathcal{C}) = -1 \\neq 0$，矩阵 $\\mathcal{C}$ 的秩为 2，即状态空间的维度。因此，系统对 $(A,B)$ 是可控的。\n\n系统是可观测的，当且仅当其可观测性矩阵 $\\mathcal{O}$ 满秩。对于 $n=2$，可观测性矩阵为 $\\mathcal{O} = \\begin{pmatrix} C \\\\ CA \\end{pmatrix}$。\n我们计算乘积 $CA$：\n$$ CA = \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 \\\\ -2 & -3 \\end{pmatrix} = \\begin{pmatrix} (1)(0) + (0)(-2) & (1)(1) + (0)(-3) \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\end{pmatrix} $$\n可观测性矩阵为：\n$$ \\mathcal{O} = \\begin{pmatrix} C \\\\ CA \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = I_{2} $$\n其中 $I_2$ 是 $2 \\times 2$ 单位矩阵。行列式为 $\\det(\\mathcal{O}) = 1 \\neq 0$。因此，$\\mathcal{O}$ 满秩，系统对 $(A,C)$ 是可观测的。\n\n其次，我们设计用于极点配置的状态反馈增益 $K$。\n带有状态反馈 $u=-Kx$ 的闭环系统动力学由矩阵 $A_{cl} = A-BK$ 控制。$A_{cl}$ 的特征值是其特征多项式 $\\chi_{cl}(s) = \\det(sI - (A-BK))$ 的根。\n我们计算矩阵 $A-BK$：\n$$ A-BK = \\begin{pmatrix} 0 & 1 \\\\ -2 & -3 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\begin{pmatrix} k_{1} & k_{2} \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ -2 & -3 \\end{pmatrix} - \\begin{pmatrix} 0 & 0 \\\\ k_{1} & k_{2} \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ -2-k_{1} & -3-k_{2} \\end{pmatrix} $$\n特征多项式是：\n$$ \\chi_{cl}(s) = \\det \\begin{pmatrix} s & -1 \\\\ 2+k_{1} & s+3+k_{2} \\end{pmatrix} = s(s+3+k_{2}) - (-1)(2+k_{1}) = s^{2} + (3+k_{2})s + (2+k_{1}) $$\n期望的极点是 $-1+2i$ 和 $-1-2i$。相应的期望特征多项式是：\n$$ \\chi_{des}(s) = (s - (-1+2i))(s - (-1-2i)) = ((s+1)-2i)((s+1)+2i) = (s+1)^{2} - (2i)^{2} = s^{2}+2s+1 - (-4) = s^{2}+2s+5 $$\n通过比较 $\\chi_{cl}(s)$ 和 $\\chi_{des}(s)$ 的系数：\n对于 $s^{1}$ 项：$3+k_{2} = 2$，这意味着 $k_{2} = -1$。\n对于 $s^{0}$ 项：$2+k_{1} = 5$，这意味着 $k_{1} = 3$。\n状态反馈增益向量是 $K = \\begin{pmatrix} 3 & -1 \\end{pmatrix}$。\n\n第三，我们利用对偶原理设计观测器增益 $L$。\n观测器误差动力学由矩阵 $A_{obs} = A-LC$ 控制。观测器的极点配置问题是选择 $L$，使得 $A-LC$ 的特征值位于期望的位置。对偶原理断言，系统对 $(A,C)$ 是可观测的，当且仅当对偶系统对 $(A^{T}, C^{T})$ 是可控的。为系统 $(A,C)$ 寻找观测器增益 $L$ 的问题，与为具有矩阵 $(A^{T}, C^{T})$ 的系统寻找状态反馈增益 $K_{dual}$ 的问题是对偶的。$A-LC$ 的特征值与其转置 $(A-LC)^{T} = A^{T} - C^{T}L^{T}$ 的特征值相同。\n我们可以通过为由状态矩阵 $A' = A^{T}$ 和输入矩阵 $B' = C^{T}$ 定义的对偶系统寻找一个状态反馈增益 $K_{dual} = L^{T}$ 来解决观测器问题。\n对偶系统的矩阵是：\n$$ A' = A^{T} = \\begin{pmatrix} 0 & -2 \\\\ 1 & -3 \\end{pmatrix}, \\quad B' = C^{T} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} $$\n我们为这个对偶系统寻找一个增益 $K' = \\begin{pmatrix} k'_{1} & k'_{2} \\end{pmatrix}$，其中 $L^{T} = \\begin{pmatrix} l_{1} & l_{2} \\end{pmatrix} = K'$。对偶系统的闭环矩阵是 $A' - B'K'$。\n$$ A' - B'K' = \\begin{pmatrix} 0 & -2 \\\\ 1 & -3 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} l_{1} & l_{2} \\end{pmatrix} = \\begin{pmatrix} 0 & -2 \\\\ 1 & -3 \\end{pmatrix} - \\begin{pmatrix} l_{1} & l_{2} \\\\ 0 & 0 \\end{pmatrix} = \\begin{pmatrix} -l_{1} & -2-l_{2} \\\\ 1 & -3 \\end{pmatrix} $$\n观测器误差的特征多项式 $\\chi_{obs}(s)$，是这个对偶闭环系统的特征多项式：\n$$ \\chi_{obs}(s) = \\det(sI - (A' - B'K')) = \\det \\begin{pmatrix} s+l_{1} & 2+l_{2} \\\\ -1 & s+3 \\end{pmatrix} = (s+l_{1})(s+3) + (2+l_{2}) = s^{2}+(3+l_{1})s+(3l_{1}+l_{2}+2) $$\n期望的观测器极点是 $-1 \\pm 2i$，这对应于相同的期望特征多项式 $\\chi_{des}(s) = s^{2}+2s+5$。\n比较系数：\n对于 $s^{1}$ 项：$3+l_{1} = 2$，这意味着 $l_{1} = -1$。\n对于 $s^{0}$ 项：$3l_{1}+l_{2}+2 = 5$。\n将 $l_{1}=-1$ 代入第二个方程，得到 $3(-1)+l_{2}+2 = 5$，化简为 $-3+l_{2}+2 = 5$，即 $-1+l_{2}=5$。由此得出 $l_{2} = 6$。\n对偶问题的增益是 $L^{T} = K' = \\begin{pmatrix} -1 & 6 \\end{pmatrix}$。观测器增益是该向量的转置：\n$$ L = (L^{T})^{T} = \\begin{pmatrix} -1 \\\\ 6 \\end{pmatrix} $$\n因此，分量为 $l_{1}=-1$ 和 $l_{2}=6$。\n\n问题要求最终答案为单一行向量 $(k_{1}, k_2, l_{1}, l_{2})$。\n根据我们的推导，$k_{1}=3$, $k_{2}=-1$, $l_{1}=-1$, 以及 $l_{2}=6$。\n最终的向量是 $\\begin{pmatrix} 3 & -1 & -1 & 6 \\end{pmatrix}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3 & -1 & -1 & 6 \\end{pmatrix}}\n$$", "id": "2703047"}, {"introduction": "可控性和可观测性不仅仅是简单的“是”或“否”的判断，它们定义了状态空间系统的基本结构。Kalman分解将状态空间划分为四个关键子空间，揭示了系统的哪些部分是可控的、可观测的、两者兼具或两者皆非。本练习将引导您为一个系统及其对偶系统构建这种分解，通过分析变换后的系统矩阵，您将直接验证对偶原理如何体现为原始系统和对偶系统结构组成部分之间的对称关系。[@problem_id:2703050]", "problem": "考虑由状态空间矩阵定义的线性时不变（LTI）系统\n$$\nA=\\begin{pmatrix}\n2 & 0 & 0 & 0\\\\\n0 & -1 & 0 & 0\\\\\n0 & 0 & 3 & 0\\\\\n0 & 0 & 0 & 7\n\\end{pmatrix},\\quad\nB=\\begin{pmatrix}\n1\\\\\n1\\\\\n0\\\\\n0\n\\end{pmatrix},\\quad\nC=\\begin{pmatrix}\n1 & 0 & 1 & 0\n\\end{pmatrix}.\n$$\n仅使用线性时不变系统的能控性和能观性的基本定义，以及从可达子空间和不可观子空间构造 Kalman 分解的方法，完成以下任务，不得使用超出这些定义的任何快捷公式：\n\n1) 确定给定系统的能控子空间和能观子空间的维数和显式生成集。\n\n2) 由此，确定四个 Kalman 子空间：能控能观子空间、能控不可观子空间、不能控能观子空间和不能控不可观子空间。构造一个基变换矩阵 $T$，其列向量构成一个基，顺序为：先是能控能观，然后是能控不可观，接着是不能控能观，最后是不能控不可观。\n\n3) 计算变换后的三元组 $(A_{k},B_{k},C_{k})$，其中 $A_{k}=T^{-1}AT$，$B_{k}=T^{-1}B$，$C_{k}=CT$，并展示出与此排序下 Kalman 分解相对应的块结构。\n\n4) 构建对偶系统 $(A^{\\top},C^{\\top},B^{\\top})$。使用相同的基本原理方法，确定对偶系统对应的四个子空间，并验证对偶性下的块对应关系，即原系统中的能控不可观块在维数上对应于对偶系统中的不能控能观块，反之亦然，而能控能观块和不能控不可观块在对偶性下与自身对应。\n\n最后，令 $A_{co}$ 和 $A_{uu}$ 分别表示 $A_{k}$ 的能控能观和不能控不可观对角块。计算标量\n$$\ns \\equiv \\det(A_{co})\\cdot \\det(A_{uu}).\n$$\n仅报告 $s$ 的值作为最终答案。无需四舍五入。", "solution": "所提出的问题是线性系统理论中关于能控性、能观性和 Kalman 规范分解的一个标准练习。该问题具有科学依据，是适定的，并且提供了所有必要的信息。我们将按照要求，基于基本原理进行严谨、分步的求解。状态空间的维数为 $n=4$。\n\n首先，我们确定给定的线性时不变（LTI）系统的能控子空间和能观子空间。\n该系统由以下矩阵定义：\n$$\nA=\\begin{pmatrix}\n2 & 0 & 0 & 0\\\\\n0 & -1 & 0 & 0\\\\\n0 & 0 & 3 & 0\\\\\n0 & 0 & 0 & 7\n\\end{pmatrix},\\quad\nB=\\begin{pmatrix}\n1\\\\\n1\\\\\n0\\\\\n0\n\\end{pmatrix},\\quad\nC=\\begin{pmatrix}\n1 & 0 & 1 & 0\n\\end{pmatrix}\n$$\n\n能控子空间，记为 $\\mathcal{C}$，是从原点出发的可达子空间，对于 LTI 系统，它是能控性矩阵 $\\mathcal{M}_c = \\begin{pmatrix} B & AB & A^2B & \\dots & A^{n-1}B \\end{pmatrix}$ 的像。对 $n=4$，我们计算其列向量：\n$B = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n$AB = \\begin{pmatrix} 2 & 0 & 0 & 0\\\\ 0 & -1 & 0 & 0\\\\ 0 & 0 & 3 & 0\\\\ 0 & 0 & 0 & 7 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n$A^2B = A(AB) = \\begin{pmatrix} 4 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n$A^3B = A(A^2B) = \\begin{pmatrix} 8 \\\\ -1 \\\\ 0 \\\\ 0 \\end{pmatrix}$\n因此，能控性矩阵为：\n$$ \\mathcal{M}_c = \\begin{pmatrix} 1 & 2 & 4 & 8 \\\\ 1 & -1 & 1 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\end{pmatrix} $$\n$\\mathcal{M}_c$ 的像由其线性无关的列向量生成。前两列是线性无关的，其余的列是前两列的线性组合。该子空间由向量 $(1, 1, 0, 0)^\\top$ 和 $(2, -1, 0, 0)^\\top$ 生成。这等价于标准基向量 $e_1 = (1, 0, 0, 0)^\\top$ 和 $e_2 = (0, 1, 0, 0)^\\top$ 的生成空间。\n因此，能控子空间为 $\\mathcal{C} = \\text{span}\\{e_1, e_2\\}$，其维数为 $\\dim(\\mathcal{C})=2$。\n\n接下来，我们求解不可观子空间 $\\mathcal{N}$，它被定义为能观性矩阵 $\\mathcal{M}_o = \\begin{pmatrix} C^\\top & (CA)^\\top & (CA^2)^\\top & \\dots & (CA^{n-1})^\\top \\end{pmatrix}^\\top$ 的核。我们计算其行向量：\n$C = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}$\n$CA = \\begin{pmatrix} 1 & 0 & 1 & 0 \\end{pmatrix}A = \\begin{pmatrix} 2 & 0 & 3 & 0 \\end{pmatrix}$\n$CA^2 = (CA)A = \\begin{pmatrix} 4 & 0 & 9 & 0 \\end{pmatrix}$\n$CA^3 = (CA^2)A = \\begin{pmatrix} 8 & 0 & 27 & 0 \\end{pmatrix}$\n能观性矩阵为：\n$$ \\mathcal{M}_o = \\begin{pmatrix} 1 & 0 & 1 & 0 \\\\ 2 & 0 & 3 & 0 \\\\ 4 & 0 & 9 & 0 \\\\ 8 & 0 & 27 & 0 \\end{pmatrix} $$\n不可观子空间 $\\mathcal{N}$ 是所有满足 $\\mathcal{M}_o x = 0$ 的向量 $x = (x_1, x_2, x_3, x_4)^\\top$ 的集合。该方程组意味着 $x_1+x_3=0$ 和 $2x_1+3x_3=0$，其唯一解为 $x_1=0, x_3=0$。对 $x_2$ 和 $x_4$ 没有约束。因此，$\\mathcal{N}$ 中的任何向量都具有 $(0, x_2, 0, x_4)^\\top$ 的形式。\n不可观子空间为 $\\mathcal{N} = \\text{span}\\{e_2, e_4\\}$，其维数为 $\\dim(\\mathcal{N})=2$。\n能观子空间 $\\mathcal{O}$ 是不可观子空间的正交补，即 $\\mathcal{O}=\\mathcal{N}^\\perp$。因此，$\\mathcal{O} = (\\text{span}\\{e_2, e_4\\})^\\perp = \\text{span}\\{e_1, e_3\\}$，其维数为 $\\dim(\\mathcal{O})=2$。\n\n在确定了 $\\mathcal{C}$ 和 $\\mathcal{N}$ 之后，我们构造四个 Kalman 子空间：\n1. 能控能观子空间：$S_{co} = \\mathcal{C} \\cap \\mathcal{O} = \\text{span}\\{e_1, e_2\\} \\cap \\text{span}\\{e_1, e_3\\} = \\text{span}\\{e_1\\}$。\n2. 能控不可观子空间：$S_{cu} = \\mathcal{C} \\cap \\mathcal{N} = \\text{span}\\{e_1, e_2\\} \\cap \\text{span}\\{e_2, e_4\\} = \\text{span}\\{e_2\\}$。\n3. 不能控能观子空间：$S_{uo} = \\mathcal{C}^\\perp \\cap \\mathcal{O} = \\text{span}\\{e_3, e_4\\} \\cap \\text{span}\\{e_1, e_3\\} = \\text{span}\\{e_3\\}$。\n4. 不能控不可观子空间：$S_{uu} = \\mathcal{C}^\\perp \\cap \\mathcal{N} = \\text{span}\\{e_3, e_4\\} \\cap \\text{span}\\{e_2, e_4\\} = \\text{span}\\{e_4\\}$。\n每个子空间的维数都是 1。根据 Kalman 分解 $\\{S_{co}, S_{cu}, S_{uo}, S_{uu}\\}$ 的顺序，整个状态空间的一个基是 $\\{e_1, e_2, e_3, e_4\\}$。由这些列向量构成的基变换矩阵是单位矩阵 $T=I_4$。\n\n变换后的状态空间表示 $(A_k, B_k, C_k)$ 由 $A_k=T^{-1}AT$，$B_k=T^{-1}B$ 和 $C_k=CT$ 给出。由于 $T=I_4$，变换后的系统与原系统相同：$(A_k, B_k, C_k) = (A, B, C)$。状态变量已经根据 Kalman 子空间进行了解耦。我们展示其块结构：\n$$ A_k = A = \\begin{pmatrix} 2 & 0 & 0 & 0 \\\\ \\hline 0 & -1 & 0 & 0 \\\\ \\hline 0 & 0 & 3 & 0 \\\\ \\hline 0 & 0 & 0 & 7 \\end{pmatrix} = \\begin{pmatrix} A_{co} & 0 & 0 & 0 \\\\ 0 & A_{cu} & 0 & 0 \\\\ 0 & 0 & A_{uo} & 0 \\\\ 0 & 0 & 0 & A_{uu} \\end{pmatrix} $$\n$$ B_k = B = \\begin{pmatrix} 1 \\\\ \\hline 1 \\\\ \\hline 0 \\\\ \\hline 0 \\end{pmatrix} = \\begin{pmatrix} B_{co} \\\\ B_{cu} \\\\ 0 \\\\ 0 \\end{pmatrix} \\quad C_k = C = \\begin{pmatrix} 1 & | & 0 & | & 1 & | & 0 \\end{pmatrix} = \\begin{pmatrix} C_{co} & 0 & C_{uo} & 0 \\end{pmatrix} $$\n各个分块为：\n$A_{co} = (2)$, $A_{cu} = (-1)$, $A_{uo} = (3)$, $A_{uu} = (7)$。\n$B_{co} = (1)$, $B_{cu} = (1)$。\n$C_{co} = (1)$, $C_{uo} = (1)$。\n该结构是块对角的，因为 Kalman 子空间是 A-不变的，这是由于 A 是对角矩阵所导致的结果。\n\n现在我们分析对偶系统 $(\\tilde{A}, \\tilde{B}, \\tilde{C})=(A^\\top, C^\\top, B^\\top)$。\n$\\tilde{A} = A^\\top = A$。\n$\\tilde{B} = C^\\top = (1, 0, 1, 0)^\\top$。\n$\\tilde{C} = B^\\top = (1, 1, 0, 0)$。\n对偶系统的能控子空间 $\\tilde{\\mathcal{C}}$ 是 $\\tilde{\\mathcal{M}}_c = \\begin{pmatrix} \\tilde{B} & \\tilde{A}\\tilde{B} & \\dots \\end{pmatrix}$ 的像。\n$\\tilde{A}\\tilde{B} = A C^\\top = (2, 0, 3, 0)^\\top$。\n$\\tilde{\\mathcal{M}}_c$ 的列向量与 $(1, 0, 1, 0)^\\top$ 和 $(2, 0, 3, 0)^\\top$ 生成相同的子空间，即 $\\text{span}\\{e_1, e_3\\}$。所以，$\\tilde{\\mathcal{C}} = \\text{span}\\{e_1, e_3\\}$。这与原系统的能观子空间 $\\mathcal{O}$ 相同，正如对偶理论所预测的那样。$\\dim(\\tilde{\\mathcal{C}}) = 2$。\n对偶系统的不可观子空间 $\\tilde{\\mathcal{N}}$ 是其能观性矩阵 $\\tilde{\\mathcal{M}}_o$ 的核，其行向量为 $\\tilde{C}, \\tilde{C}\\tilde{A}, \\dots$。\n$\\tilde{C}\\tilde{A} = B^\\top A = (2, -1, 0, 0)$。\n其核是满足 $x_1+x_2=0$ 和 $2x_1-x_2=0$ 的向量 $x$ 的集合，这意味着 $x_1=0, x_2=0$。因此 $\\tilde{\\mathcal{N}} = \\text{span}\\{e_3, e_4\\}$。对偶系统的能观子空间是 $\\tilde{\\mathcal{O}} = \\tilde{\\mathcal{N}}^\\perp = \\text{span}\\{e_1, e_2\\}$，这与原系统的能控子空间 $\\mathcal{C}$ 相同。\n\n对偶系统的 Kalman 子空间为：\n$\\tilde{S}_{co} = \\tilde{\\mathcal{C}} \\cap \\tilde{\\mathcal{O}} = \\text{span}\\{e_1, e_3\\} \\cap \\text{span}\\{e_1, e_2\\} = \\text{span}\\{e_1\\}$。\n$\\tilde{S}_{cu} = \\tilde{\\mathcal{C}} \\cap \\tilde{\\mathcal{N}} = \\text{span}\\{e_1, e_3\\} \\cap \\text{span}\\{e_3, e_4\\} = \\text{span}\\{e_3\\}$。\n$\\tilde{S}_{uo} = \\tilde{\\mathcal{C}}^\\perp \\cap \\tilde{\\mathcal{O}} = \\text{span}\\{e_2, e_4\\} \\cap \\text{span}\\{e_1, e_2\\} = \\text{span}\\{e_2\\}$。\n$\\tilde{S}_{uu} = \\tilde{\\mathcal{C}}^\\perp \\cap \\tilde{\\mathcal{N}} = \\text{span}\\{e_2, e_4\\} \\cap \\text{span}\\{e_3, e_4\\} = \\text{span}\\{e_4\\}$。\n维数都是 1。我们验证其对应关系：\n$\\dim(S_{co})=1$ 对应于 $\\dim(\\tilde{S}_{co})=1$。\n$\\dim(S_{cu})=1$ 对应于 $\\dim(\\tilde{S}_{uo})=1$。\n$\\dim(S_{uo})=1$ 对应于 $\\dim(\\tilde{S}_{cu})=1$。\n$\\dim(S_{uu})=1$ 对应于 $\\dim(\\tilde{S}_{uu})=1$。\n对偶对应关系得到证实。\n\n最后，我们计算标量 $s \\equiv \\det(A_{co})\\cdot \\det(A_{uu})$。\n从 $A_k$ 的分解中，我们得到 $1\\times1$ 矩阵 $A_{co}=(2)$ 和 $A_{uu}=(7)$。\n其行列式分别为 $\\det(A_{co}) = 2$ 和 $\\det(A_{uu}) = 7$。\n乘积为 $s = 2 \\cdot 7 = 14$。", "answer": "$$\n\\boxed{14}\n$$", "id": "2703050"}, {"introduction": "可控性、可观测性及其对偶性的概念可以推广到更一般的线性时变 (LTV) 系统。对于LTV系统，这些性质通常使用在有限时间区间上定义的Gramian矩阵来分析。本练习要求您从解析公式转向数值实现，这是控制工程师的一项关键技能，您将编写代码计算这些Gramian矩阵，并数值验证对偶关系在时变情况下依然成立，即一个系统的Gramian矩阵与其伴随系统的Gramian矩阵之间存在着确定的变换关系。[@problem_id:2703029]", "problem": "给定由矩阵函数 $A(t)$、$B(t)$ 和 $C(t)$ 在有限时间区间 $[t_0,t_f]$ 上指定的线性时变系统。考虑状态方程 $\\dot{x}(t)=A(t)x(t)+B(t)u(t)$ 和输出方程 $y(t)=C(t)x(t)$。令 $\\Phi(t,s)$ 表示状态转移矩阵，它满足 $\\frac{d}{dt}\\Phi(t,s)=A(t)\\Phi(t,s)$ 和 $\\Phi(s,s)=I$。在 $[t_0,t_f]$ 区间上，于末端点 $t_f$ 的有限时间可控性格拉姆矩阵定义为\n$$\nW_c(t_0,t_f) \\triangleq \\int_{t_0}^{t_f} \\Phi(t_f,\\tau)\\,B(\\tau)B(\\tau)^\\top\\,\\Phi(t_f,\\tau)^\\top\\,d\\tau,\n$$\n在 $[t_0,t_f]$ 区间上，于初始点 $t_0$ 的有限时间可观测性格拉姆矩阵定义为\n$$\nW_o(t_0,t_f) \\triangleq \\int_{t_0}^{t_f} \\Phi(\\tau,t_0)^\\top\\,C(\\tau)^\\top C(\\tau)\\,\\Phi(\\tau,t_0)\\,d\\tau.\n$$\n定义伴随系统，其状态矩阵为 $A_d(t)\\triangleq -A(t)^\\top$，输入矩阵为 $B_d(t)\\triangleq C(t)^\\top$，输出矩阵为 $C_d(t)\\triangleq B(t)^\\top$。令 $\\Phi_d(t,s)$ 为其状态转移矩阵，满足 $\\frac{d}{dt}\\Phi_d(t,s)=A_d(t)\\Phi_d(t,s)$ 且 $\\Phi_d(s,s)=I$。仅使用这些定义，为每个系统数值计算其有限时间格拉姆矩阵，并利用区间端点间的状态转移矩阵，验证一个系统与其伴随系统的格拉姆矩阵之间由对偶性导出的合同关系。\n\n数值要求：\n- 使用上述定义和状态转移矩阵的性质，基于常微分方程积分和数值积分构建数值算法。除所提供的定义外，不假设任何特殊结构。\n- 在 $[t_0,t_f]$ 上使用一个至少包含 $N=400$ 个子区间的均匀网格，并使用梯形法则进行时间积分。\n- 使用一个高精度常微分方程积分器，通过对基础解矩阵的微分方程进行积分，来计算所需的 $\\Phi(t,s)$。\n- 通过计算两边之差的弗罗贝尼乌斯范数来判断合同关系是否成立，如果相对误差 $\\|E\\|_F/\\max(1,\\|R\\|_F)$ 小于 $\\varepsilon$，则声明成功，其中 $E$ 是被测试的差分矩阵，$R$ 是左侧的参考矩阵。使用 $\\varepsilon=10^{-5}$。\n\n测试套件：\n对于以下每种情况，取 $t_0=0$ 和指定的 $t_f$。每个 $A(t)$、$B(t)$ 和 $C(t)$ 都明确给出。角度以弧度为单位。不涉及物理单位。\n\n- 情况 1（时不变，二维）：\n  - $n=2$, $m=1$, $p=1$。\n  - $A(t)=\\begin{bmatrix}0 & 1\\\\ -2 & -3\\end{bmatrix}$，$B(t)=\\begin{bmatrix}0\\\\ 1\\end{bmatrix}$，$C(t)=\\begin{bmatrix}1 & 0\\end{bmatrix}$，$t_f=1$。\n- 情况 2（时变，二维）：\n  - $n=2$, $m=1$, $p=1$。\n  - $A(t)=\\begin{bmatrix}0 & 1\\\\ -\\big(2+0.5\\cos t\\big) & -0.5\\end{bmatrix}$，\n    $B(t)=\\begin{bmatrix}0.5+0.1\\sin t\\\\ 1\\end{bmatrix}$，\n    $C(t)=\\begin{bmatrix}1+0.2\\cos(2t) & 0.3\\sin t\\end{bmatrix}$，$t_f=2.5$。\n- 情况 3（部分不可控和不可观测模式，三维）：\n  - $n=3$, $m=1$, $p=1$。\n  - $A(t)=\\begin{bmatrix}0 & 1 & 0\\\\ 0 & -1 & 0\\\\ 0 & 0 & 2\\end{bmatrix}$，\n    $B(t)=\\begin{bmatrix}1\\\\ 0\\\\ 0\\end{bmatrix}$，\n    $C(t)=\\begin{bmatrix}1 & 0 & 0\\end{bmatrix}$，$t_f=1.2$。\n- 情况 4（短时域，二维）：\n  - $n=2$, $m=1$, $p=1$。\n  - $A(t)=\\begin{bmatrix}0 & 1\\\\ -1 & 0\\end{bmatrix}$，\n    $B(t)=\\begin{bmatrix}0\\\\ 1\\end{bmatrix}$，\n    $C(t)=\\begin{bmatrix}1 & 1\\end{bmatrix}$，$t_f=10^{-3}$。\n\n对于每种情况：\n- 计算原系统的 $W_c(t_0,t_f)$ 和 $W_o(t_0,t_f)$。\n- 计算伴随系统相应的有限时间格拉姆矩阵，以验证对偶性预测的合同关系。\n- 使用端点间的状态转移矩阵将伴随系统的格拉姆矩阵变换到适当的端点，并如上所述与原系统的格拉姆矩阵进行合同性测试。\n\n程序输出规范：\n- 对于每个测试用例，输出一个包含两个布尔值的列表：\n  - 第一个布尔值表示，将伴随系统的可观测性格拉姆矩阵在端点间进行变换后，与原系统的可控性格拉姆矩阵的合同关系是否成立。\n  - 第二个布尔值表示，将伴随系统的可控性格拉姆矩阵在端点间进行变换后，与原系统的可观测性格拉姆矩阵的合同关系是否成立。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由每个案例的结果列表组成，并用方括号括起来，例如 $[\\,[\\text{True},\\text{True}],[\\text{True},\\text{True}]\\,]$。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于线性控制理论的原理，问题设定良好，目标明确，数值约束清晰，并且没有任何逻辑矛盾或含糊之处。我现在将提供解决方案。\n\n该问题要求对线性时变 (LTV) 系统的对偶性原理进行数值验证。该原理建立了一个系统的可控性与其伴随系统的可观测性之间的基本联系，反之亦然。我们将首先推导待测试的具体关系，然后概述用于验证的数值算法。\n\n一个线性系统由以下方程描述：\n$$ \\dot{x}(t) = A(t)x(t) + B(t)u(t) \\quad (\\text{系统 } \\Sigma) $$\n$$ y(t) = C(t)x(t) $$\n其状态转移矩阵 $\\Phi(t,s)$ 将状态从时间 $s$ 传播到时间 $t$，并且是矩阵微分方程 $\\frac{d}{dt}\\Phi(t,s) = A(t)\\Phi(t,s)$ 在初始条件 $\\Phi(s,s)=I$（其中 $I$ 是单位矩阵）下的唯一解。\n\n伴随系统（我们表示为 $\\Sigma_d$）由以下矩阵定义：\n$$ A_d(t) \\triangleq -A(t)^\\top, \\quad B_d(t) \\triangleq C(t)^\\top, \\quad C_d(t) \\triangleq B(t)^\\top $$\n令 $\\Phi_d(t,s)$ 为伴随系统的状态转移矩阵。一个关键性质将原系统和伴随系统的状态转移矩阵联系起来：$\\Phi_d(t,s) = \\Phi(s,t)^\\top$。这可以通过证明 $\\Phi(s,t)^\\top$ 满足 $\\Phi_d(t,s)$ 的微分方程和初始条件来证明。\n\n问题提供了在时间区间 $[t_0, t_f]$ 上的可控性和可观测性格拉姆矩阵的定义：\n可控性格拉姆矩阵（于 $t_f$）：$W_c(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi(t_f,\\tau) B(\\tau) B(\\tau)^\\top \\Phi(t_f,\\tau)^\\top d\\tau$\n可观测性格拉姆矩阵（于 $t_0$）：$W_o(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi(\\tau,t_0)^\\top C(\\tau)^\\top C(\\tau) \\Phi(\\tau,t_0) d\\tau$\n\n这些定义必须同时应用于原系统 $\\Sigma$ 和伴随系统 $\\Sigma_d$。我们将伴随系统的格拉姆矩阵表示为 $W_{c,d}$ 和 $W_{o,d}$。\n\n**对偶性诱导的合同关系的推导**\n\n我们现在推导需要验证的两个关系式。\n\n**关系 1：$\\Sigma$ 的可控性与 $\\Sigma_d$ 的可观测性**\n伴随系统 $\\Sigma_d$ 在 $t_0$ 的可观测性格拉姆矩阵为：\n$$ W_{o,d}(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi_d(\\tau,t_0)^\\top C_d(\\tau)^\\top C_d(\\tau) \\Phi_d(\\tau,t_0) d\\tau $$\n使用定义 $C_d(\\tau) = B(\\tau)^\\top$ 和恒等式 $\\Phi_d(\\tau,t_0) = \\Phi(t_0,\\tau)^\\top$，我们有 $\\Phi_d(\\tau,t_0)^\\top = \\Phi(t_0,\\tau)$。代入这些可得：\n$$ W_{o,d}(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi(t_0,\\tau) B(\\tau) B(\\tau)^\\top \\Phi(t_0,\\tau)^\\top d\\tau $$\n为了将其与 $W_c(t_0,t_f)$ 联系起来，我们使用状态转移矩阵的半群性质：$\\Phi(t_f, \\tau) = \\Phi(t_f, t_0) \\Phi(t_0, \\tau)$，这意味着 $\\Phi(t_0,\\tau) = \\Phi(t_f,t_0)^{-1} \\Phi(t_f,\\tau) = \\Phi(t_0,t_f) \\Phi(t_f,\\tau)$。将此代入 $W_{o,d}$ 的表达式中：\n$$ W_{o,d}(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi(t_0,t_f) \\Phi(t_f,\\tau) B(\\tau)B(\\tau)^\\top \\left(\\Phi(t_0,t_f) \\Phi(t_f,\\tau)\\right)^\\top d\\tau $$\n由于 $\\Phi(t_0,t_f)$ 相对于积分变量 $\\tau$是常数，我们可以将其提出：\n$$ W_{o,d}(t_0,t_f) = \\Phi(t_0,t_f) \\left( \\int_{t_0}^{t_f} \\Phi(t_f,\\tau) B(\\tau)B(\\tau)^\\top \\Phi(t_f,\\tau)^\\top d\\tau \\right) \\Phi(t_0,t_f)^\\top $$\n括号中的表达式正是 $W_c(t_0,t_f)$。因此，我们得到关系式 $W_{o,d}(t_0,t_f) = \\Phi(t_0, t_f) W_c(t_0,t_f) \\Phi(t_0, t_f)^\\top$。问题要求我们通过变换伴随格拉姆矩阵来验证合同关系。利用 $\\Phi(t_0,t_f)^{-1} = \\Phi(t_f,t_0)$ 对 $W_c(t_0,t_f)$ 进行整理，得到第一个待测试的关系式：\n$$ W_c(t_0,t_f) = \\Phi(t_f,t_0) W_{o,d}(t_0,t_f) \\Phi(t_f,t_0)^\\top $$\n\n**关系 2：$\\Sigma$ 的可观测性与 $\\Sigma_d$ 的可控性**\n伴随系统 $\\Sigma_d$ 在 $t_f$ 的可控性格拉姆矩阵为：\n$$ W_{c,d}(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi_d(t_f,\\tau) B_d(\\tau) B_d(\\tau)^\\top \\Phi_d(t_f,\\tau)^\\top d\\tau $$\n使用 $B_d(\\tau) = C(\\tau)^\\top$ 和 $\\Phi_d(t_f,\\tau) = \\Phi(\\tau,t_f)^\\top$，上式变为：\n$$ W_{c,d}(t_0,t_f) = \\int_{t_0}^{t_f} \\Phi(\\tau,t_f)^\\top C(\\tau)^\\top C(\\tau) \\Phi(\\tau,t_f) d\\tau $$\n为了将其与 $W_o(t_0,t_f)$ 联系起来，我们使用 $\\Phi(\\tau,t_0) = \\Phi(\\tau,t_f) \\Phi(t_f,t_0)$。代入 $W_o(t_0,t_f)$ 的定义中：\n$$ W_o(t_0,t_f) = \\int_{t_0}^{t_f} \\left(\\Phi(\\tau,t_f) \\Phi(t_f,t_0)\\right)^\\top C(\\tau)^\\top C(\\tau) \\left(\\Phi(\\tau,t_f) \\Phi(t_f,t_0)\\right) d\\tau $$\n提出常数项 $\\Phi(t_f,t_0)$:\n$$ W_o(t_0,t_f) = \\Phi(t_f,t_0)^\\top \\left( \\int_{t_0}^{t_f} \\Phi(\\tau,t_f)^\\top C(\\tau)^\\top C(\\tau) \\Phi(\\tau,t_f) d\\tau \\right) \\Phi(t_f,t_0) $$\n括号中的表达式是 $W_{c,d}(t_0,t_f)$。这给出了第二个待测试的关系式：\n$$ W_o(t_0,t_f) = \\Phi(t_f,t_0)^\\top W_{c,d}(t_0,t_f) \\Phi(t_f,t_0) $$\n\n**数值算法**\n\n数值程序的核心是计算四个格拉姆矩阵（$W_c, W_o, W_{c,d}, W_{o,d}$）和状态转移矩阵 $\\Phi(t_f, t_0)$，然后检验推导出的两个合同关系。\n\n1.  **时间离散化**：在 $[t_0, t_f]$ 上创建一个包含 $N=400$ 个子区间的均匀网格，从而得到 $N+1$ 个点 $\\tau_k = t_0 + k \\cdot (t_f-t_0)/N$，其中 $k=0, \\dots, N$。\n\n2.  **状态转移矩阵计算**：需要计算状态转移矩阵在网格点上的值。一个直接且准确的方法是求解其定义的矩阵常微分方程 (ODE)。为了便于 ODE 求解器处理，一个大小为 $n \\times n$ 的状态矩阵被展平为一个大小为 $n^2$ 的向量。\n    - 为了得到所有 $k$ 的 $\\Phi(\\tau_k, t_0)$：我们求解初值问题 $\\dot{X}(t) = A(t)X(t)$，其中 $X(t_0)=I$，从 $t_0$ 到 $t_f$ 正向积分。解是一个数组 $X(\\tau_k) = \\Phi(\\tau_k, t_0)$。最终值 $X(t_f)$ 得到 $\\Phi(t_f,t_0)$。\n    - 为了得到所有 $k$ 的 $\\Phi(t_f, \\tau_k)$：我们计算 $Z(t) = \\Phi(t_f,t)^\\top$，它满足 $\\dot{Z}(t) = -A(t)^\\top Z(t) = A_d(t)Z(t)$，且 $Z(t_f)=I$。我们从 $t_f$ 到 $t_0$ 反向求解这个初值问题。解给出一个数组 $Z(\\tau_k) = \\Phi(t_f,\\tau_k)^\\top$。\n    - 伴随系统的状态转移矩阵 $\\Phi_d(\\tau_k, t_0)$ 和 $\\Phi_d(t_f, \\tau_k)$ 可类似地计算，分别通过正向求解 $\\dot{X}_d=A_d(t)X_d$ 和反向求解 $\\dot{Z}_d=A(t)Z_d$。\n\n3.  **格拉姆矩阵计算**：对于四个格拉姆矩阵中的每一个，我们首先在每个网格点 $\\tau_k$ 上计算被积函数的值。例如，$W_o$ 的被积函数是 $F_o(\\tau_k) = \\Phi(\\tau_k, t_0)^\\top C(\\tau_k)^\\top C(\\tau_k) \\Phi(\\tau_k, t_0)$。然后，积分使用梯形法则进行近似，对于一个矩阵值函数 $F(\\tau)$，其形式为 $\\int_{t_0}^{t_f} F(\\tau) d\\tau \\approx \\Delta t \\left( \\frac{F(\\tau_0) + F(\\tau_N)}{2} + \\sum_{k=1}^{N-1} F(\\tau_k) \\right)$。\n\n4.  **验证**：在计算完四个格拉姆矩阵和 $\\Phi(t_f,t_0)$ 之后，对两个合同关系进行测试。对于每个关系，我们计算左手边 (LHS) 和右手边 (RHS) 之间的差分矩阵 $E$。如果相对误差 $\\|E\\|_F / \\max(1, \\|\\text{LHS}\\|_F)$ 小于容差 $\\varepsilon = 10^{-5}$，则验证测试成功。使用弗罗贝尼乌斯范数 $\\| \\cdot \\|_F$。这个相对误差度量被稳健地定义，特别是当参考格拉姆矩阵的范数很小时。\n\n这个详细的、基于原理的数值过程在以下 Python 代码中实现。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n    \n    # Define test cases\n    test_cases = [\n        # Case 1: time-invariant, two-dimensional\n        {\n            \"n\": 2, \"m\": 1, \"p\": 1, \"t0\": 0.0, \"tf\": 1.0,\n            \"A\": lambda t: np.array([[0.0, 1.0], [-2.0, -3.0]]),\n            \"B\": lambda t: np.array([[0.0], [1.0]]),\n            \"C\": lambda t: np.array([[1.0, 0.0]]),\n        },\n        # Case 2: time-varying, two-dimensional\n        {\n            \"n\": 2, \"m\": 1, \"p\": 1, \"t0\": 0.0, \"tf\": 2.5,\n            \"A\": lambda t: np.array([[0.0, 1.0], [-(2.0 + 0.5 * np.cos(t)), -0.5]]),\n            \"B\": lambda t: np.array([[0.5 + 0.1 * np.sin(t)], [1.0]]),\n            \"C\": lambda t: np.array([[1.0 + 0.2 * np.cos(2*t), 0.3 * np.sin(t)]]),\n        },\n        # Case 3: partially uncontrollable and unobservable mode, three-dimensional\n        {\n            \"n\": 3, \"m\": 1, \"p\": 1, \"t0\": 0.0, \"tf\": 1.2,\n            \"A\": lambda t: np.array([[0.0, 1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 2.0]]),\n            \"B\": lambda t: np.array([[1.0], [0.0], [0.0]]),\n            \"C\": lambda t: np.array([[1.0, 0.0, 0.0]]),\n        },\n        # Case 4: short horizon, two-dimensional\n        {\n            \"n\": 2, \"m\": 1, \"p\": 1, \"t0\": 0.0, \"tf\": 1e-3,\n            \"A\": lambda t: np.array([[0.0, 1.0], [-1.0, 0.0]]),\n            \"B\": lambda t: np.array([[0.0], [1.0]]),\n            \"C\": lambda t: np.array([[1.0, 1.0]]),\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(**case)\n        all_results.append(result)\n\n    # Format output as specified\n    output_str = \"[\" + \",\".join([f\"[{b1},{b2}]\" for b1, b2 in all_results]) + \"]\"\n    print(output_str)\n\ndef process_case(n, m, p, t0, tf, A, B, C):\n    \"\"\"\n    Processes a single test case to compute Gramians and verify duality relations.\n    \"\"\"\n    N = 400\n    epsilon = 1e-5\n    t_grid = np.linspace(t0, tf, N + 1)\n    \n    # ODE solver settings\n    solver_opts = {'method': 'RK45', 'rtol': 1e-9, 'atol': 1e-12}\n\n    # Define system matrices for original and adjoint systems\n    A_d = lambda t: -A(t).T\n    \n    # --- ODE derivative functions for STM calculations ---\n    # The state y is a flattened n x n matrix\n    def ode_fwd(t, y, A_func):\n        Y = y.reshape((n, n))\n        dYdt = A_func(t) @ Y\n        return dYdt.flatten()\n\n    def ode_bwd(t, y, A_func): \n        # For Z(t) = Phi(tf, t)^T satisfying dZ/dt = -A(t)^T Z(t)\n        Ad_func = lambda t_inner: -A_func(t_inner).T\n        Z = y.reshape((n, n))\n        dZdt = Ad_func(t) @ Z\n        return dZdt.flatten()\n\n    # --- Compute STMs by solving ODEs ---\n    I_flat = np.eye(n).flatten()\n\n    # Original system STMs\n    # 1. Forward solve for Phi(t, t0)\n    sol_fwd = solve_ivp(lambda t, y: ode_fwd(t, y, A), [t0, tf], I_flat, t_eval=t_grid, **solver_opts)\n    # Shape: (N+1, n, n)\n    Phi_t_t0_vals = sol_fwd.y.T.reshape(-1, n, n)\n    # The final value is Phi(tf, t0)\n    Phi_tf_t0 = Phi_t_t0_vals[-1]\n\n    # 2. Backward solve for Phi(tf, t)^T\n    sol_bwd = solve_ivp(lambda t, y: ode_bwd(t, y, A), [tf, t0], I_flat, t_eval=t_grid[::-1], **solver_opts)\n    # The result needs to be reversed to match t_grid\n    Phi_tf_t_T_vals = sol_bwd.y.T.reshape(-1, n, n)[::-1]\n\n    # Adjoint system STMs\n    # 3. Forward solve for Phi_d(t, t0)\n    sol_d_fwd = solve_ivp(lambda t, y: ode_fwd(t, y, A_d), [t0, tf], I_flat, t_eval=t_grid, **solver_opts)\n    Phi_d_t_t0_vals = sol_d_fwd.y.T.reshape(-1, n, n)\n    \n    # 4. Backward solve for Phi_d(tf, t)^T\n    sol_d_bwd = solve_ivp(lambda t, y: ode_bwd(t, y, A_d), [tf, t0], I_flat, t_eval=t_grid[::-1], **solver_opts)\n    Phi_d_tf_t_T_vals = sol_d_bwd.y.T.reshape(-1, n, n)[::-1]\n\n    # --- Compute Gramian Integrands ---\n    integrand_Wc = np.zeros((N + 1, n, n))\n    integrand_Wo = np.zeros((N + 1, n, n))\n    integrand_Wcd = np.zeros((N + 1, n, n))\n    integrand_Wod = np.zeros((N + 1, n, n))\n\n    for k, t in enumerate(t_grid):\n        # Matrix values at time t\n        B_t = B(t)\n        C_t = C(t)\n        \n        # Integrand for W_c(t0, tf)\n        Phi_tf_tk_T = Phi_tf_t_T_vals[k]\n        integrand_Wc[k] = Phi_tf_tk_T.T @ (B_t @ B_t.T) @ Phi_tf_tk_T\n        \n        # Integrand for W_o(t0, tf)\n        Phi_tk_t0 = Phi_t_t0_vals[k]\n        integrand_Wo[k] = Phi_tk_t0.T @ (C_t.T @ C_t) @ Phi_tk_t0\n        \n        # Integrand for W_c,d(t0, tf)\n        Bd_t = C_t.T\n        Phi_d_tf_tk_T = Phi_d_tf_t_T_vals[k]\n        integrand_Wcd[k] = Phi_d_tf_tk_T.T @ (Bd_t @ Bd_t.T) @ Phi_d_tf_tk_T\n        \n        # Integrand for W_o,d(t0, tf)\n        Cd_t = B_t.T\n        Phi_d_tk_t0 = Phi_d_t_t0_vals[k]\n        integrand_Wod[k] = Phi_d_tk_t0.T @ (Cd_t.T @ Cd_t) @ Phi_d_tk_t0\n\n    # --- Compute Gramians via Trapezoidal Rule ---\n    Wc = np.trapz(integrand_Wc, t_grid, axis=0)\n    Wo = np.trapz(integrand_Wo, t_grid, axis=0)\n    Wcd = np.trapz(integrand_Wcd, t_grid, axis=0)\n    Wod = np.trapz(integrand_Wod, t_grid, axis=0)\n\n    # --- Verify Congruence Relations ---\n    # Test 1: Wc = Phi(tf, t0) * Wod * Phi(tf, t0)^T\n    LHS1 = Wc\n    RHS1 = Phi_tf_t0 @ Wod @ Phi_tf_t0.T\n    error1 = np.linalg.norm(LHS1 - RHS1, 'fro') / max(1.0, np.linalg.norm(LHS1, 'fro'))\n    check1 = error1  epsilon\n\n    # Test 2: Wo = Phi(tf, t0)^T * Wcd * Phi(tf, t0)\n    LHS2 = Wo\n    RHS2 = Phi_tf_t0.T @ Wcd @ Phi_tf_t0\n    error2 = np.linalg.norm(LHS2 - RHS2, 'fro') / max(1.0, np.linalg.norm(LHS2, 'fro'))\n    check2 = error2  epsilon\n\n    return [check1, check2]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2703029"}]}