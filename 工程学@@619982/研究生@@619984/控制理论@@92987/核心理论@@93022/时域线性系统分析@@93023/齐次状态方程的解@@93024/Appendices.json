{"hands_on_practices": [{"introduction": "掌握齐次状态方程的解析解是控制理论的基石。本练习将引导您使用特征值分解来求解状态向量 $x(t)$，从而将系统的内在属性（其模态）与其动态行为直接联系起来。这项基本技能对于理解系统响应和验证数值仿真是必不可少的。[@problem_id:1611524]", "problem": "一个线性时不变 (LTI) 系统由齐次状态空间方程 $\\dot{x}(t) = Ax(t)$ 描述，其中 $x(t) = \\begin{pmatrix} x_1(t) \\\\ x_2(t) \\end{pmatrix}$ 是状态向量。系统矩阵 $A$ 由下式给出：\n$$\nA = \\begin{pmatrix} -2 & 1 \\\\ 2 & -3 \\end{pmatrix}\n$$\n给定系统在 $t=0$ 时的初始状态为 $x(0) = \\begin{pmatrix} 2 \\\\ 5 \\end{pmatrix}$，求出所有 $t \\ge 0$ 时的状态向量 $x(t)$。将您的答案表示为一个列向量，其分量是 $t$ 的函数。", "solution": "对于具有常数矩阵 $A$ 的齐次 LTI 系统 $\\dot{x}(t)=Ax(t)$，状态轨迹为 $x(t)=\\exp(At)x(0)$。为了计算 $\\exp(At)$，通过其特征值和特征向量对 $A$ 进行对角化。\n\n计算特征多项式：\n$$\n\\det(A-\\lambda I)=\\det\\begin{pmatrix}-2-\\lambda & 1 \\\\ 2 & -3-\\lambda\\end{pmatrix}=(\\lambda+2)(\\lambda+3)-2=\\lambda^{2}+5\\lambda+4。\n$$\n求解 $\\lambda^{2}+5\\lambda+4=0$ 得到特征值 $\\lambda_{1}=-1$ 和 $\\lambda_{2}=-4$。\n\n求出相应的特征向量。对于 $\\lambda_{1}=-1$，求解 $(A+I)v=0$：\n$$\n\\begin{pmatrix}-1 & 1 \\\\ 2 & -2\\end{pmatrix}\\begin{pmatrix}v_{1}\\\\v_{2}\\end{pmatrix}=0 \\implies v_{2}=v_{1}，\n$$\n因此选择 $v_{1}=\\begin{pmatrix}1\\\\1\\end{pmatrix}$。对于 $\\lambda_{2}=-4$，求解 $(A+4I)v=0$：\n$$\n\\begin{pmatrix}2 & 1 \\\\ 2 & 1\\end{pmatrix}\\begin{pmatrix}v_{1}\\\\v_{2}\\end{pmatrix}=0 \\implies v_{2}=-2v_{1}，\n$$\n因此选择 $v_{2}=\\begin{pmatrix}1\\\\-2\\end{pmatrix}$。\n\n通解是沿特征向量的线性组合：\n$$\nx(t)=c_{1}\\exp(-t)\\begin{pmatrix}1\\\\1\\end{pmatrix}+c_{2}\\exp(-4t)\\begin{pmatrix}1\\\\-2\\end{pmatrix}。\n$$\n根据初始条件 $x(0)=\\begin{pmatrix}2\\\\5\\end{pmatrix}$ 确定 $c_{1}$ 和 $c_{2}$：\n$$\n\\begin{pmatrix}2\\\\5\\end{pmatrix}=c_{1}\\begin{pmatrix}1\\\\1\\end{pmatrix}+c_{2}\\begin{pmatrix}1\\\\-2\\end{pmatrix}=\\begin{pmatrix}c_{1}+c_{2}\\\\c_{1}-2c_{2}\\end{pmatrix}。\n$$\n这给出了线性系统 $c_{1}+c_{2}=2$ 和 $c_{1}-2c_{2}=5$。相减得到 $-3c_{2}=3$，所以 $c_{2}=-1$，进而 $c_{1}=3$。\n\n因此，\n$$\nx(t)=3\\exp(-t)\\begin{pmatrix}1\\\\1\\end{pmatrix}-\\exp(-4t)\\begin{pmatrix}1\\\\-2\\end{pmatrix}=\\begin{pmatrix}3\\exp(-t)-\\exp(-4t)\\\\3\\exp(-t)+2\\exp(-4t)\\end{pmatrix}。\n$$\n这同时满足微分方程和初始条件。", "answer": "$$\\boxed{\\begin{pmatrix}3\\exp(-t)-\\exp(-4t)\\\\3\\exp(-t)+2\\exp(-4t)\\end{pmatrix}}$$", "id": "1611524"}, {"introduction": "矩阵指数是一个强大的工具，但要避免常见误区，就必须理解其性质。本实践问题揭示了一个基本原理：对于矩阵而言，$e^{At}e^{Bt}$通常不等于$e^{(A+B)t}$，这是矩阵乘法非对易性的直接结果。通过这个反例的演算，您将巩固对这一关键细微差别的理解，这对于精确建模涉及多种动态过程的系统至关重要。[@problem_id:1611533]", "problem": "在分析一个简化的两态系统的动力学时，其状态向量根据一个状态空间模型进行演化。该系统受到两个独立过程的影响，这两个过程由常数矩阵 $A$ 和 $B$ 描述。\n\n设矩阵为：\n$$\nA = \\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\n$$\n$$\nB = \\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\n$$\n\n系统在时间间隔 $t$ 内的精确演化由状态转移矩阵 $\\Phi_{exact}(t) = \\exp((A+B)t)$ 给出。一种常见的简化方法，称为一阶 Lie-Trotter 近似，是分开处理这两个演化过程，从而得到近似的状态转移矩阵 $\\Phi_{approx}(t) = \\exp(At)\\exp(Bt)$。\n\n为了量化该近似所引入的差异，我们定义一个误差矩阵 $E(t) = \\Phi_{approx}(t) - \\Phi_{exact}(t)$。\n\n计算在时间 $t=2$ 时，误差矩阵的第一行第二列元素的值，记为 $E_{12}$。请将答案表示为一个闭式解析表达式。", "solution": "我们首先注意到 $A^{2}=0$ 且 $B^{2}=0$，因为\n$$\nA^{2}=\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}=\\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}，\\quad\nB^{2}=\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}=\\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix}。\n$$\n因此，它们的矩阵指数可简化为\n$$\n\\exp(At)=I+tA，\\quad \\exp(Bt)=I+tB。\n$$\n于是，近似转移矩阵为\n$$\n\\Phi_{\\text{approx}}(t)=\\exp(At)\\exp(Bt)=(I+tA)(I+tB)=I+t(A+B)+t^{2}AB。\n$$\n计算 $AB$ 与 $BA$：\n$$\nAB=\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}，\\quad BA=\\begin{pmatrix} 0 & 0 \\\\ 0 & 1 \\end{pmatrix}。\n$$\n因此\n$$\n\\Phi_{\\text{approx}}(t)=\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}+t\\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}+t^{2}\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}\n=\\begin{pmatrix} 1+t^{2} & t \\\\ t & 1 \\end{pmatrix}。\n$$\n对于精确转移，我们观察到 $(A+B)^{2}=AB+BA=I$，因此设 $J=A+B$ 且 $J^{2}=I$，\n$$\n\\exp(Jt)=I\\cosh t+J\\sinh t=\\begin{pmatrix} \\cosh t & \\sinh t \\\\ \\sinh t & \\cosh t \\end{pmatrix}。\n$$\n因此，误差矩阵为\n$$\nE(t)=\\Phi_{\\text{approx}}(t)-\\Phi_{\\text{exact}}(t)\n=\\begin{pmatrix} 1+t^{2}-\\cosh t & t-\\sinh t \\\\ t-\\sinh t & 1-\\cosh t \\end{pmatrix}。\n$$\n于是，元素 $E_{12}(t)$ 为\n$$\nE_{12}(t)=t-\\sinh t。\n$$\n在 $t=2$ 处求值可得\n$$\nE_{12}(2)=2-\\sinh(2)。\n$$\n这是一个闭式解析表达式。", "answer": "$$\\boxed{2-\\sinh(2)}$$", "id": "1611533"}, {"introduction": "这项高级实践将带您从时不变系统进入周期性线性时变（LTV）系统的领域，这在许多工程和物理应用中都很常见。您将实现一个基于 Floquet 理论的数值算法，以计算描述系统在一个周期内净行为的常数生成元矩阵 $R$。这项编程练习将磨练您在数值求解矩阵常微分方程方面的技能，并应用如单值矩阵和矩阵对数等概念来分析复杂的动态系统。[@problem_id:2745820]", "problem": "考虑一个连续时间线性时变 (LTV) 系统的齐次状态方程，该方程由常微分方程 (ODE) $\\dot{x}(t)=A(t)\\,x(t)$ 定义。其中，$A(t)$ 是一个 $T$ 周期性的 $2\\times 2$ 矩阵，即对所有 $t$ 满足 $A(t+T)=A(t)$。状态转移矩阵 $\\Phi(t,t_{0})$ 是满足 $\\frac{d}{dt}\\Phi(t,t_{0})=A(t)\\,\\Phi(t,t_{0})$ 和 $\\Phi(t_{0},t_{0})=I$ 的唯一矩阵函数，其中 $I$ 是单位矩阵。经过一个周期的单值矩阵为 $M=\\Phi(T,0)$，它编码了从单位阵开始经过一个周期的净演化。在单值矩阵 $M$ 没有位于非正实轴上的特征值的条件下，可以通过矩阵对数将一个常数生成元矩阵 $R$ 与 $M$ 关联起来，从而保证主矩阵对数存在。您的程序必须通过对矩阵 ODE 进行时序积分来数值计算 $M$，然后使用主矩阵对数从 $M$ 计算 $R$。\n\n算法要求：\n- 通过直接对矩阵 ODE $\\dot{\\Phi}(t,0)=A(t)\\,\\Phi(t,0)$ 在初始条件 $\\Phi(0,0)=I$ 下进行积分来计算 $\\Phi(t,0)$。这通过时间上的正向演化，数值地实现了时序指数。\n- 在最终时刻 $T$ 处，令 $M=\\Phi(T,0)$。\n- 将 $M$ 的主矩阵对数除以周期来计算 $R$，即通过对 $M$ 应用主矩阵对数并乘以 $1/T$ 来计算满足 $\\exp(R\\,T)=M$ 的矩阵 $R$。\n\n角度单位说明：当出现三角函数时，其参数应以弧度为单位进行解释。\n\n测试套件：\n为以下四种情况实现该算法。对于每种情况，计算下面指定的标量误差。所有数值常数都是无量纲的，所有角度都以弧度为单位。\n\n- 情况 $\\mathbf{1}$ (常数、可交换基准)：\n  - 周期：$T=3$。\n  - 矩阵：$A(t)=\\begin{bmatrix}-0.2 & 0\\\\ 0 & -0.5\\end{bmatrix}$ (对所有 $t$)。\n  - 期望的生成元：$R_{\\text{exp}}=\\begin{bmatrix}-0.2 & 0\\\\ 0 & -0.5\\end{bmatrix}$。\n  - 此情况要求的标量输出：$e_{1}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n\n- 情况 $\\mathbf{2}$ (零均值对角周期矩阵，处于 $M=I$ 的边界)：\n  - 周期：$T=2\\pi$。\n  - 矩阵：$A(t)=\\operatorname{diag}\\left(\\sin(t),-\\sin(t)\\right)$。\n  - 期望的生成元：$R_{\\text{exp}}=\\begin{bmatrix}0 & 0\\\\ 0 & 0\\end{bmatrix}$。\n  - 要求的标量输出：$e_{2}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n\n- 情况 $\\mathbf{3}$ (非零均值对角周期矩阵，可交换但时变)：\n  - 周期：$T=2\\pi$。\n  - 矩阵：$A(t)=\\operatorname{diag}\\left(-0.1+0.05\\sin(2t),\\,-0.3+0.02\\cos(3t)\\right)$。\n  - 期望的生成元：$R_{\\text{exp}}=\\operatorname{diag}\\left(-0.1,\\,-0.3\\right)$。\n  - 要求的标量输出：$e_{3}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n\n- 情况 $\\mathbf{4}$ (不可交换的周期矩阵，重构检验)：\n  - 周期：$T=2\\pi$。\n  - 矩阵：$A(t)=\\begin{bmatrix}0 & 1+0.2\\sin(2t)\\\\ -\\left(1.0+0.1\\cos(t)\\right) & 0\\end{bmatrix}$。\n  - 未提供闭式形式的期望生成元。\n  - 要求的标量输出：$e_{4}=\\left\\|\\exp(R\\,T)-M\\right\\|_{F}$，其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。\n\n最终输出格式：\n- 您的程序必须产生单行输出，其中包含一个以逗号分隔的 Python 风格列表 $\\left[e_{1},e_{2},e_{3},e_{4}\\right]$。\n- 每个浮点数必须以科学记数法打印，小数点后恰好有六位数字 (例如，$1.234567\\text{e-}04$)。\n- 不应打印任何其他文本。\n\n您的实现必须是完全自包含的，不得要求任何用户输入，并且必须使用对 $\\Phi(t,0)$ 的矩阵 ODE 进行时序数值积分，然后对 $M$ 进行主矩阵对数运算以获得 $R$。", "solution": "该问题是计算控制理论中一个明确定义的练习，具体涉及具有周期系数的线性时变 (LTV) 系统的分析。\n\n### 步骤 1：提取已知条件\n- **系统方程**：齐次状态方程 $\\dot{x}(t) = A(t)x(t)$。\n- **系统矩阵**：$A(t)$ 是一个 $2\\times 2$ 矩阵，周期为 $T$，因此 $A(t+T) = A(t)$。\n- **状态转移矩阵**：$\\Phi(t, t_0)$ 是满足 $\\frac{d}{dt}\\Phi(t,t_0) = A(t)\\Phi(t,t_0)$ 和初始条件 $\\Phi(t_0,t_0) = I$ 的唯一解。\n- **单值矩阵**：$M = \\Phi(T, 0)$。\n- **生成元矩阵**：$R$ 是一个满足 $\\exp(RT) = M$ 的常数矩阵。它是通过 $R = \\frac{1}{T}\\log(M)$ 计算的，使用主矩阵对数，并假定其存在。\n- **算法**：\n    1.  从 $t=0$ 到 $t=T$ 对 $\\dot{\\Phi}(t,0) = A(t)\\Phi(t,0)$ 进行数值积分，初始条件为 $\\Phi(0,0)=I$。\n    2.  令 $M = \\Phi(T,0)$。\n    3.  计算 $R = \\frac{1}{T}\\log(M)$。\n- **测试用例**：\n    - **情况 1**：$T=3$，$A(t)=\\begin{bmatrix}-0.2 & 0\\\\ 0 & -0.5\\end{bmatrix}$，$R_{\\text{exp}}=\\begin{bmatrix}-0.2 & 0\\\\ 0 & -0.5\\end{bmatrix}$，误差 $e_{1}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n    - **情况 2**：$T=2\\pi$，$A(t)=\\operatorname{diag}\\left(\\sin(t),-\\sin(t)\\right)$，$R_{\\text{exp}}=\\begin{bmatrix}0 & 0\\\\ 0 & 0\\end{bmatrix}$，误差 $e_{2}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n    - **情况 3**：$T=2\\pi$，$A(t)=\\operatorname{diag}\\left(-0.1+0.05\\sin(2t),\\,-0.3+0.02\\cos(3t)\\right)$，$R_{\\text{exp}}=\\operatorname{diag}\\left(-0.1,\\,-0.3\\right)$，误差 $e_{3}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n    - **情况 4**：$T=2\\pi$，$A(t)=\\begin{bmatrix}0 & 1+0.2\\sin(2t)\\\\ -\\left(1.0+0.1\\cos(t)\\right) & 0\\end{bmatrix}$，误差 $e_{4}=\\left\\|\\exp(R\\,T)-M\\right\\|_{F}$。\n- **输出格式**：一个列表 $[e_1, e_2, e_3, e_4]$，每个数字使用科学记数法表示，并保留六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于 Floquet 理论，这是常微分方程研究中的一个标准课题。问题定义明确，提供了所有必要的数据和定义。算法要求清晰且计算上可行。测试用例涵盖了简单的、可解析验证的场景，以及需要指定数值方法的更复杂的非交换情况。该问题不含科学不准确、模糊或矛盾之处。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个基于数值积分和矩阵分析的解决方案。\n\n### 解决方案\n这个问题的核心在于将 Floquet 理论的原理应用于周期性 LTV 系统。系统的动力学由方程 $\\dot{x}(t) = A(t)x(t)$ 描述，其中 $A(t+T)=A(t)$。系统的演化由状态转移矩阵 $\\Phi(t,t_0)$ 捕捉，该矩阵必须通过求解以下矩阵微分方程找到：\n$$\n\\frac{d}{dt}\\Phi(t, 0) = A(t)\\Phi(t, 0), \\quad \\Phi(0, 0) = I\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。形式上，解涉及一个时序指数 $\\mathcal{T}\\exp\\left(\\int_0^t A(\\tau) d\\tau\\right)$。除特殊情况外，这不能简化为标准的矩阵指数。指定的数值过程——直接对矩阵 ODE 进行积分——是计算此时序乘积的标准方法。\n\n对于周期为 $T$ 的系统，单值矩阵 $M=\\Phi(T,0)$ 描述了系统在一个周期内的演化。Floquet 理论保证我们可以找到一个常数矩阵 $R$，称为生成元，使得 $M = \\exp(RT)$。根据这个关系式，可以通过取矩阵对数来找到 $R$：\n$$\nR = \\frac{1}{T}\\log(M)\n$$\n问题要求使用主矩阵对数，该对数在 $M$ 没有位于非正实轴上的特征值的条件下是唯一的。\n\n数值实现过程如下：\n1.  **ODE 积分**：$\\Phi(t,0)$ 的矩阵 ODE 是一个包含 $2 \\times 2 = 4$ 个耦合线性一阶微分方程的系统。为了使用像 `scipy.integrate.solve_ivp` 这样的标准数值求解器，将 $2 \\times 2$ 矩阵 $\\Phi$ 向量化（展平）成一个 $4 \\times 1$ 的状态向量 $y(t)$。提供给求解器的导数函数计算 $A(t)$，将 $y(t)$ 重塑回矩阵 $\\Phi$，计算乘积 $A(t)\\Phi$，并将展平后的结果作为导数向量 $\\dot{y}(t)$ 返回。我们从 $t=0$ 到 $t=T$ 进行积分，初始条件 $y(0)$ 对应于展平的单位矩阵。\n2.  **单值矩阵**：求解器在 $t=T$ 处的输出给出了最终状态向量，该向量被重塑以形成单值矩阵 $M = \\Phi(T, 0)$。\n3.  **生成元矩阵**：然后使用数值库函数计算主矩阵对数 (`scipy.linalg.logm`)，从而得到生成元矩阵 $R = \\frac{1}{T}\\log(M)$。\n\n对于情况 1、2 和 3，矩阵 $A(t)$ 具有对于所有 $t_1, t_2$ 都满足 $[A(t_1), A(t_2)]=0$ 的性质。在情况 1 中，这是因为 $A(t)$ 是常数。在情况 2 和 3 中，这是因为 $A(t)$ 对所有 $t$ 都是对角矩阵，而对角矩阵是可交换的。对于这类可交换系统，时序指数简化为积分的标准矩阵指数：\n$$\n\\Phi(T, 0) = \\exp\\left(\\int_0^T A(\\tau) d\\tau\\right)\n$$\n于是生成元 $R$ 变为 $A(t)$ 的时间平均值，即 $R = \\bar{A} = \\frac{1}{T}\\int_0^T A(\\tau) d\\tau$。这证实了为这些情况提供的 $R_{\\text{exp}}$。例如，在情况 2 中，$\\int_0^{2\\pi} \\sin(t) dt = 0$，所以 $\\bar{A}$ 是零矩阵。\n\n对于情况 4，矩阵 $A(t)$ 是非交换的。简单计算表明 $[A(t_1), A(t_2)] \\neq 0$。因此，对矩阵 ODE 进行完整的数值积分是必不可少的，并且生成元 $R$ 不再是 $A(t)$ 的简单时间平均值。误差度量 $e_4 = \\|\\exp(RT) - M\\|_F$ 作为数值过程的验证，检查计算出的 $R$ 是否能准确重构 $M$。这个误差预计会接近机器精度。\n\n实现将利用高精度的 `RK45` 积分方案以最小化数值误差，从而可以与期望结果进行准确比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import logm, expm\n\ndef solve():\n    \"\"\"\n    Computes the generator matrix R for four LTV systems and calculates\n    the specified error metrics.\n    \"\"\"\n\n    def compute_R_and_M(A_func, T):\n        \"\"\"\n        Computes the monodromy matrix M and the generator R for a given\n        system A(t) and period T.\n        \"\"\"\n        # Define the ODE system for the flattened state-transition matrix Phi.\n        # The state vector y has 4 elements, representing the 2x2 matrix Phi.\n        def ode_system(t, y):\n            Phi = y.reshape((2, 2))\n            A = A_func(t)\n            dPhi_dt = A @ Phi\n            return dPhi_dt.flatten()\n\n        # Initial condition Phi(0, 0) = I, flattened to a vector.\n        y0 = np.identity(2, dtype=float).flatten()\n        \n        # Numerically integrate the ODE from t=0 to t=T.\n        # We use a high-precision solver configuration to ensure accuracy.\n        # We only need the solution at the final time T.\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, T],\n            y0=y0,\n            method='RK45',\n            t_eval=[T],\n            rtol=1e-13,\n            atol=1e-13\n        )\n        \n        # The monodromy matrix M is the state-transition matrix at t=T.\n        M = sol.y[:, -1].reshape((2, 2))\n        \n        # Compute the generator matrix R using the principal matrix logarithm.\n        R = logm(M) / T\n        \n        return R, M\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"A_func\": lambda t: np.array([[-0.2, 0.0], [0.0, -0.5]]),\n            \"T\": 3.0,\n            \"R_exp\": np.array([[-0.2, 0.0], [0.0, -0.5]]),\n        },\n        {\n            \"case_id\": 2,\n            \"A_func\": lambda t: np.diag([np.sin(t), -np.sin(t)]),\n            \"T\": 2 * np.pi,\n            \"R_exp\": np.zeros((2, 2)),\n        },\n        {\n            \"case_id\": 3,\n            \"A_func\": lambda t: np.diag([-0.1 + 0.05 * np.sin(2*t), -0.3 + 0.02 * np.cos(3*t)]),\n            \"T\": 2 * np.pi,\n            \"R_exp\": np.diag([-0.1, -0.3]),\n        },\n        {\n            \"case_id\": 4,\n            \"A_func\": lambda t: np.array([[0.0, 1.0 + 0.2 * np.sin(2*t)], [-(1.0 + 0.1 * np.cos(t)), 0.0]]),\n            \"T\": 2 * np.pi,\n            \"R_exp\": None, # No analytical R_exp is provided\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A_func = case[\"A_func\"]\n        T = case[\"T\"]\n        R_exp = case[\"R_exp\"]\n        \n        R, M = compute_R_and_M(A_func, T)\n        \n        if case[\"case_id\"] in [1, 2, 3]:\n            # For cases 1-3, the error is the maximum absolute difference\n            # between the computed R and the expected R_exp.\n            error = np.max(np.abs(R - R_exp))\n        else: # case_id == 4\n            # For case 4, the error is a self-consistency check: the Frobenius norm\n            # of the difference between the reconstructed M and the original M.\n            M_reconstructed = expm(R * T)\n            error = np.linalg.norm(M_reconstructed - M, 'fro')\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    # e.g., [1.234567e-08,_..._]\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "2745820"}]}