{"hands_on_practices": [{"introduction": "理解恒定载荷和恒定真实应力下的蠕变测试之间的差异，对于正确解读实验数据和预测构件寿命至关重要。本练习 [@problem_id:2883386] 将引导您基于第一性原理进行定性分析，帮助您建立对几何软化效应的物理直觉，这种效应在常见的工程测试中会加速蠕变。通过仔细思考真实应力和应变的定义，您将揭示为何这两种测试条件不等效，特别是对于应力敏感的材料。", "problem": "一个圆柱形多晶金属试样在足够高的恒定温度 $T$ 下进行单轴拉伸测试，该温度下时间依赖性形变（蠕变）非常显著。试样初始横截面积为 $A_0$，加载后初始真应力为 $\\sigma_0$。进行了两个独立的蠕变测试：\n\n- 测试1：保持恒定载荷 $F_0$，即 $F(t)=F_0$，初始真应力为 $\\sigma_0=F_0/A_0$。\n- 测试2：连续调节施加载荷，使真应力恒定在 $\\sigma(t)=\\sigma_0$。\n\n假设该材料表现出经典的蠕变三阶段响应（第一、第二、第三阶段），在所施加的温度 $T$ 下塑性流动过程中体积近似恒定，并且在稳态（第二）阶段遵循一个公认的经验应力幂律蠕变法则，其应力指数 $n$ 在给定温度 $T$ 下满足 $n>1$。忽略温度梯度，并假设在第三阶段蠕变开始前形变是均匀的（在第三阶段前没有几何不稳定性）。在第三阶段之前，试样的横截面保持圆形，且横向塑性流动是各向同性的。\n\n关于蠕变的定性演化和第三阶段蠕变的开始，哪个/哪些陈述与上述情况以及真实应力和不可压缩塑性流动的第一性原理定义最为一致？请选择所有适用项。\n\nA. 在恒定载荷测试中，真实应力随时间减小，因为横截面积增大，所以第二阶段的持续时间比恒定真实应力下更长。\n\nB. 在 $n>1$ 的恒定温度下，恒定载荷测试倾向于比恒定真实应力测试更早进入第三阶段蠕变，因为真实应力随轴向应变增加而增加，即使在微观结构损伤占主导地位之前，蠕变速率也会加速。\n\nC. 在恒定真实应力下，必须随时间减小外部施加的载荷以维持 $\\sigma(t)=\\sigma_0$；因此，第二阶段被延长，并且可能在损伤开始前几乎保持稳定。\n\nD. 到达第三阶段蠕变开始的时间基本上与测试是在恒定载荷下还是在恒定真实应力下进行无关，因为在幂律蠕变中，应力历史不影响损伤演化。\n\nE. 增大应力指数 $n$ 会放大两种测试之间的差异，在其他条件相同的情况下，使得在恒定载荷下，第三阶段蠕变的开始相对早于恒定真实应力下的情况。", "solution": "该问题要求对两种蠕变测试方法进行定性比较：恒定载荷与恒定真实应力。在继续之前，我们必须验证问题陈述的有效性。\n\n**步骤1：提取已知条件**\n- 试样：圆柱形多晶金属。\n- 测试类型：单轴拉伸。\n- 温度：恒定为 $T$，足够高以引起蠕变。\n- 初始几何：横截面积 $A_0$。\n- 初始应力：真应力 $\\sigma_0$。\n- 测试1：恒定载荷，$F(t) = F_0$，初始真应力为 $\\sigma_0 = F_0/A_0$。\n- 测试2：恒定真应力，$\\sigma(t) = \\sigma_0$。\n- 材料行为假设：\n    - 表现出第一、第二和第三阶段蠕变。\n    - 塑性流动过程中体积恒定（$AL = A_0L_0$）。\n    - 第二（稳态）蠕变阶段遵循经验幂律法则：$\\dot{\\varepsilon} \\propto \\sigma^n$。\n    - 应力指数 $n$ 满足 $n>1$。\n- 其他条件：\n    - 无温度梯度。\n    - 在第三阶段蠕变开始前形变是均匀的。\n    - 横截面保持圆形。\n    - 在第三阶段前，横向塑性流动是各向同性的。\n\n**步骤2：验证问题陈述**\n问题陈述在科学上是合理的、提法得当且客观的。它描述了材料力学中的一个标准问题，特别是蠕变研究。真实应力、真实应变、恒体积形变和幂律蠕变等概念是该领域的基本原理。所提供的假设，如 $n > 1$ 和体积恒定，对于高温下的金属是物理上现实的。问题是自洽的，并为进行严谨的定性分析提供了所有必要信息。没有矛盾、歧义或事实错误。\n\n**步骤3：结论**\n问题有效。我们开始求解。\n\n**推导控制关系式**\n设 $L(t)$ 和 $A(t)$ 分别为试样的瞬时长度和横截面积。初始状态由 $L_0$ 和 $A_0$ 定义。\n\n真轴向应变的定义是：\n$$ \\varepsilon(t) = \\int_{L_0}^{L(t)} \\frac{dL}{L} = \\ln\\left(\\frac{L(t)}{L_0}\\right) $$\n这意味着 $L(t) = L_0 e^{\\varepsilon(t)}$。\n\n塑性变形过程中体积恒定的假设表明 $A(t)L(t) = A_0L_0$。我们可以用真应变 $\\varepsilon(t)$ 来表示瞬时面积 $A(t)$：\n$$ A(t) = A_0 \\frac{L_0}{L(t)} = A_0 \\frac{L_0}{L_0 e^{\\varepsilon(t)}} = A_0 e^{-\\varepsilon(t)} $$\n这个关系是我们分析的基础。\n\n真实应力的定义是 $\\sigma(t) = F(t)/A(t)$，其中 $F(t)$ 是瞬时施加的载荷。\n\n第二蠕变阶段由幂律法则控制：\n$$ \\dot{\\varepsilon}(t) = \\frac{d\\varepsilon}{dt} = B \\sigma(t)^n $$\n其中 $B$ 是一个与温度相关的材料常数，$n > 1$ 是应力指数。\n\n**测试1分析：恒定载荷**\n在此测试中，施加的载荷保持其初始值不变，$F(t) = F_0$。初始真应力为 $\\sigma_0 = F_0/A_0$。在任意时间 $t$ 的真实应力为：\n$$ \\sigma(t) = \\frac{F_0}{A(t)} = \\frac{F_0}{A_0 e^{-\\varepsilon(t)}} = \\left(\\frac{F_0}{A_0}\\right) e^{\\varepsilon(t)} = \\sigma_0 e^{\\varepsilon(t)} $$\n随着试样蠕变，它会伸长，因此 $L(t) > L_0$ 且真应变 $\\varepsilon(t) > 0$。因此，$e^{\\varepsilon(t)} > 1$。这意味着在恒定载荷测试中，随着试样横截面积的减小，真实应力 $\\sigma(t)$ 从其初始值 $\\sigma_0$ 开始持续*增加*。\n\n蠕变应变速率则为：\n$$ \\dot{\\varepsilon}(t) = B \\sigma(t)^n = B (\\sigma_0 e^{\\varepsilon(t)})^n = B \\sigma_0^n e^{n\\varepsilon(t)} $$\n由于 $\\varepsilon(t)$ 随时间增加且 $n > 1$，项 $e^{n\\varepsilon(t)}$ 会增长，导致应变速率 $\\dot{\\varepsilon}(t)$ 加速。这就形成了一个正反馈循环：应变增加了真应力，而真应力又增加了应变速率，导致更快的应变。这种几何软化效应甚至在显著的微观结构损伤（第三阶段蠕变的典型原因）累积之前就导致了蠕变的加速。因此，第二阶段不是一个真正的稳态，向第三阶段的过渡被加速了。\n\n**测试2分析：恒定真实应力**\n在此测试中，真实应力保持恒定，$\\sigma(t) = \\sigma_0$。\n因此，第二阶段的蠕变应变速率是恒定的：\n$$ \\dot{\\varepsilon}(t) = B \\sigma_0^n = \\text{常数} $$\n这代表了真实的稳态蠕变条件。应变随时间线性增加，$\\varepsilon(t) = (B \\sigma_0^n) t + \\varepsilon_{primary}$。\n\n为了保持恒定的真实应力，施加的载荷 $F(t)$ 必须被连续调节。根据真实应力的定义：\n$$ F(t) = \\sigma(t) A(t) = \\sigma_0 A(t) = \\sigma_0 (A_0 e^{-\\varepsilon(t)}) $$\n随着试样伸长和 $\\varepsilon(t)$ 增加，项 $e^{-\\varepsilon(t)}$ 减小。因此，施加的载荷 $F(t)$ 必须随时间*减小*。\n\n在这种情况下，测试1中出现的几何加速被消除了。在第二阶段，蠕变速率保持恒定，因此该阶段被延长。第三阶段蠕变的开始则主要由材料损伤的内在累积（例如，空洞形成、微裂纹）所控制，而不是被不断增加的应力所加速。\n\n**评估选项**\n\n**A. 在恒定载荷测试中，真实应力随时间减小，因为横截面积增大，所以第二阶段的持续时间比恒定真实应力下更长。**\n- “真实应力随时间减小”：这是错误的。如上所示，$\\sigma(t) = \\sigma_0 e^{\\varepsilon(t)}$，该值是增加的。\n- “因为横截面积增大”：这是错误的。在拉伸中，面积减小。\n- “第二阶段的持续时间更长”：这是错误的。加速缩短了第二阶段。\n结论：**不正确**。\n\n**B. 在 $n>1$ 的恒定温度下，恒定载荷测试倾向于比恒定真实应力测试更早进入第三阶段蠕变，因为真实应力随轴向应变增加而增加，即使在微观结构损伤占主导地位之前，蠕变速率也会加速。**\n该陈述正确地指出，在恒定载荷测试中，真实应力随着应变的累积而增加（$\\sigma(t) = \\sigma_0 e^{\\varepsilon(t)}$）。这导致了蠕变速率的加速（$\\dot{\\varepsilon} \\propto \\sigma^n$），从而使系统比恒定真实应力测试（其中没有这种几何加速）更快地进入第三阶段。其推理与我们的推导完全一致。\n结论：**正确**。\n\n**C. 在恒定真实应力下，必须随时间减小外部施加的载荷以维持 $\\sigma(t)=\\sigma_0$；因此，第二阶段被延长，并且可能在损伤开始前几乎保持稳定。**\n该陈述正确地描述了恒定真实应力测试的要求和结果。载荷必须按照 $F(t) = \\sigma_0 A_0 e^{-\\varepsilon(t)}$ 进行减小，以补偿缩小的面积。这消除了几何加速效应，导致一个真实的稳态（恒定 $\\dot{\\varepsilon}$）第二阶段，因此与恒定载荷情况相比，该阶段被延长了。向第三阶段的过渡则由较慢的损伤累积过程决定。\n结论：**正确**。\n\n**D. 到达第三阶段蠕变开始的时间基本上与测试是在恒定载荷下还是在恒定真实应力下进行无关，因为在幂律蠕变中，应力历史不影响损伤演化。**\n这是不正确的。对测试1和测试2的分析明确表明，应变和应变速率的演化是根本不同的。由于真实应力的加速效应，在恒定载荷下达到临界应变或不稳定状态（第三阶段蠕变）的时间要短得多。“应力历史不影响损伤演化”这个前提也是一种过度简化，并且通常是错误的；更高的应力和应变速率通常会加速损伤机制。\n结论：**不正确**。\n\n**E. 增大应力指数 $n$ 会放大两种测试之间的差异，在其他条件相同的情况下，使得在恒定载荷下，第三阶段蠕变的开始相对早于恒定真实应力下的情况。**\n在恒定载荷测试中，应变速率为 $\\dot{\\varepsilon}(t) = B \\sigma_0^n e^{n\\varepsilon(t)}$。相对于恒定应力测试，引起加速的项是 $e^{n\\varepsilon(t)}$。对于给定的应变 $\\varepsilon$，指数 $n$ 的值越大， $e^{n\\varepsilon(t)}$ 的值就越大得多。这意味着正反馈循环（应变 $\\rightarrow$ 应力 $\\rightarrow$ 应变速率）对于具有更高应力指数的材料要显著增强。蠕变速率会更急剧地加速，导致更快地进入第三阶段。因此，增大 $n$ 会增强两种测试类型之间的差异，使得恒定载荷测试相对更快地失效。\n结论：**正确**。", "answer": "$$\\boxed{BCE}$$", "id": "2883386"}, {"introduction": "在前一个练习建立的定性认知基础上，我们现在转向严谨的数学构建。本实践要求您推导在恒定载荷下，遵循诺顿 (Norton) 蠕变定律的杆件其真实应变演化的控制微分方程 [@problem_id:2883365]。此推导将几何因素引致蠕变加速这一物理概念用数学形式清晰地表达出来，为定量寿命预测提供了基础。", "problem": "一根初始长度为 $L_{0}$、初始横截面积为 $A_{0}$ 的细长均质杆，在恒定温度下承受恒定的单轴拉伸载荷 $P$。在此温度下，弹性应变与蠕变应变相比可以忽略不计。假设变形在标距段内是空间均匀的，并且非弹性流动是等容的（不可压缩的），因此在单轴拉伸过程中满足 $A(t)\\,L(t)=A_{0}\\,L_{0}$。设轴向拉伸比为 $\\lambda(t)=L(t)/L_{0}$，真实（对数）轴向应变为 $\\epsilon_{\\text{true}}(t)=\\ln \\lambda(t)$。真实轴向柯西应力取为 $\\sigma(t)=P/A(t)$。该材料遵循单轴形式的诺顿蠕变定律，材料参数为 $C>0$ 和 $n>1$，因此真实蠕变应变率满足 $\\dot{\\epsilon}_{\\text{true}}(t)=C\\,[\\sigma(t)]^{n}$。\n\n仅从这些定义和基本关系出发，推导在恒定载荷下真实应变演化的自治常微分方程。具体来说，确定函数 $f(\\epsilon_{\\text{true}})$，使得 $\\dot{\\epsilon}_{\\text{true}}(t)=f(\\epsilon_{\\text{true}}(t))$。\n\n以 $C$、$n$、$P$、$A_{0}$ 和 $\\epsilon_{\\text{true}}$ 表示 $f(\\epsilon_{\\text{true}})$，将你的最终答案写成一个单一的闭式符号表达式。最终表达式中不应包含单位。", "solution": "目标是根据不可压缩单轴拉伸和诺顿蠕变定律，推导在恒定施加载荷 $P$ 下真实应变 $\\epsilon_{\\text{true}}(t)$ 的自治常微分方程。我们从基本运动学、平衡关系和经验蠕变定律出发进行推导。\n\n首先，定义单轴拉伸的运动学。轴向拉伸比为 $\\lambda(t)=L(t)/L_{0}$。根据定义，真实（对数）应变为\n$$\n\\epsilon_{\\text{true}}(t)=\\ln \\lambda(t).\n$$\n对于不可压缩的单轴变形（等容流动），当前横截面积 $A(t)$ 和当前长度 $L(t)$ 满足体积守恒 $A(t)\\,L(t)=A_{0}\\,L_{0}$。因此，\n$$\nA(t)=\\frac{A_{0}\\,L_{0}}{L(t)}=\\frac{A_{0}}{\\lambda(t)}.\n$$\n\n在恒定施加载荷 $P$ 下，真实柯西应力通过力平衡与当前面积相关联，\n$$\n\\sigma(t)=\\frac{P}{A(t)}.\n$$\n代入 $A(t)$ 的不可压缩性关系式可得\n$$\n\\sigma(t)=\\frac{P}{A_{0}/\\lambda(t)}=\\frac{P}{A_{0}}\\,\\lambda(t).\n$$\n使用真实应变的定义 $\\lambda(t)=\\exp(\\epsilon_{\\text{true}}(t))$，我们得到\n$$\n\\sigma(t)=\\frac{P}{A_{0}}\\,\\exp\\!\\big(\\epsilon_{\\text{true}}(t)\\big).\n$$\n\n关于单轴蠕变，诺顿蠕变定律给出了真实蠕变应变率是真实应力的幂函数，\n$$\n\\dot{\\epsilon}_{\\text{true}}(t)=C\\,[\\sigma(t)]^{n},\n$$\n其中 $C>0$ 和 $n>1$ 是给定温度下的材料参数。代入 $\\sigma(t)$ 的表达式可得\n$$\n\\dot{\\epsilon}_{\\text{true}}(t)=C\\left[\\frac{P}{A_{0}}\\,\\exp\\!\\big(\\epsilon_{\\text{true}}(t)\\big)\\right]^{n}\n=C\\left(\\frac{P}{A_{0}}\\right)^{n}\\exp\\!\\big(n\\,\\epsilon_{\\text{true}}(t)\\big).\n$$\n\n这是一个形式为\n$$\n\\dot{\\epsilon}_{\\text{true}}(t)=f\\!\\big(\\epsilon_{\\text{true}}(t)\\big),\n$$\n的自治常微分方程，其右端函数为\n$$\nf(\\epsilon_{\\text{true}})=C\\left(\\frac{P}{A_{0}}\\right)^{n}\\exp\\!\\big(n\\,\\epsilon_{\\text{true}}\\big).\n$$\n\n至此，利用真实应变的基本运动学定义、不可压缩性约束、柯西应力的力平衡以及诺顿经验蠕变定律，完成了推导。", "answer": "$$\\boxed{C\\left(\\frac{P}{A_{0}}\\right)^{n}\\exp\\!\\left(n\\,\\epsilon_{\\text{true}}\\right)}$$", "id": "2883365"}, {"introduction": "掌握本构模型的最后一步是学习如何进行数值实现，这是现代计算力学的核心技能。这项高阶实践 [@problem_id:2883346] 要求您为一个粘塑性模型开发数值积分算法，这是有限元分析软件中的一项核心任务。通过推导并实现一个应力松弛问题的求解过程，您将获得连接理论与工程仿真的数值方法的实践经验。", "problem": "一种单轴、小应变、等温材料表现出率相关的非弹性变形，其遵循 Norton 幂律蠕变（或粘塑性）流动法则。在时间步 $n+1$ 内，总应变被指定为常数（应变控制），这模拟了应力松弛现象。运动学上，总应变分解为 $\\epsilon = \\epsilon^{\\mathrm{e}} + \\epsilon^{\\mathrm{vp}}$，其中 $\\epsilon^{\\mathrm{e}}$ 是弹性应变，$\\epsilon^{\\mathrm{vp}}$ 是粘塑性（蠕变）应变。应力由 Hooke 定律给出：$\\sigma = E \\, \\epsilon^{\\mathrm{e}}$，其中 $E$ 是弹性模量。粘塑性应变率遵循 Norton 法则：$\\dot{\\epsilon}^{\\mathrm{vp}} = A \\, |\\sigma|^{n-1}\\sigma$，其中 $A$ 是一个材料参数，单位为 $\\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$，$n \\ge 1$ 是应力指数。假设小应变，并在时长为 $\\Delta t$ 的时间步上采用后向欧拉时间离散化。假设上一步的 $\\epsilon^{\\mathrm{vp}}_n$ 和 $\\sigma_n$ 已知。令步末给定的总应变为 $\\epsilon_{n+1}$。\n\n1) 从上述定义和粘塑性应变的后向欧拉离散化出发，构建一个标量非线性残差方程 $R(\\sigma_{n+1}) = 0$。该方程的解是在给定 $\\epsilon_{n+1}$ 和已知 $\\epsilon^{\\mathrm{vp}}_n$ 的约束下，得到的更新后的应力 $\\sigma_{n+1}$。不要预先假设解的形式；从第一性原理推导该残差。\n\n2) 通过对残差方程分别关于 $\\sigma_{n+1}$ 和 $\\epsilon_{n+1}$ 求导，推导算法一致性切线模量 $C_{\\mathrm{alg}} = \\dfrac{d \\sigma_{n+1}}{d \\epsilon_{n+1}}$ 的显式表达式。该模量是隐式有限元实现中确保全局解的牛顿迭代具有二次收敛性所必需的。请用 $E$, $A$, $n$, $\\Delta t$ 和 $\\sigma_{n+1}$ 表示 $C_{\\mathrm{alg}}$。\n\n3) 阐明清晰且可验证的条件，在这些条件下，用于局部应力更新、采用一致性雅可比矩阵的牛顿法预期能实现二次收敛。你的条件应由 $R(\\sigma_{n+1})$ 在根附近的适当数学性质来证明。\n\n4) 实现一个程序，对下面列出的每个测试用例执行以下操作：\n   - 使用带有精确局部雅可比矩阵（$R$ 关于 $\\sigma_{n+1}$ 的导数）的牛顿迭代法，在后向欧拉和应变控制下求解 $\\sigma_{n+1}$，迭代从弹性预测值 $\\sigma^{\\mathrm{trial}} = E \\, (\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n)$ 开始。\n   - 使用第二个类牛顿求解器，该求解器用简化的 $J_{\\mathrm{simp}} = 1$ 替代精确的局部雅可比矩阵，同时保持相同的残差函数，并使用回溯线搜索以促进全局收敛，迭代从相同的初始猜测开始。\n   - 对两个求解器均采用基于绝对残差的鲁棒停止准则。使用绝对容差 $T_{\\mathrm{abs}} = 10^{-8} \\, E \\, \\max(1, |\\epsilon_{n+1}|)$（单位为 $\\mathrm{Pa}$），并在 $|R| \\le T_{\\mathrm{abs}}$ 时停止。\n   - 在一致性雅可比求解器收敛后，计算收敛的 $\\sigma_{n+1}$ 处的算法一致性切线模量 $C_{\\mathrm{alg}} = \\dfrac{d \\sigma_{n+1}}{d \\epsilon_{n+1}}$。\n   - 对每个测试用例，记录：收敛后的应力 $\\sigma_{n+1}$（单位为兆帕，MPa），一致性切线模量 $C_{\\mathrm{alg}}$（单位为吉帕，GPa），一致性雅可比求解器所用的牛顿迭代次数，以及简化雅可比求解器所用的迭代次数。\n   - 牛顿迭代最多进行 $50$ 次，并使用回溯线搜索，步长缩减因子为 $1/2$，充分下降检验为 $|R_{\\mathrm{new}}| < |R_{\\mathrm{old}}|$。如果初始猜测的残差已低于容差，则迭代计数为零。\n\n5) 物理单位：\n   - 弹性模量 $E$ 必须以帕斯卡 ($\\mathrm{Pa}$) 为单位。\n   - Norton 参数 $A$ 的单位必须是 $\\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$。\n   - 时间步 $\\Delta t$ 必须以秒 ($\\mathrm{s}$) 为单位。\n   - 应变是无量纲的。\n   - 输出的应力单位为兆帕 (MPa)，模量单位为吉帕 (GPa)，两者都四舍五入到六位小数。\n\n6) 测试套件：\n   - 案例1（中等应力松弛）: $E = 210 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-30} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 3$, $\\Delta t = 3600 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.002$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$。\n   - 案例2（步内近弹性）: $E = 210 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-30} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 3$, $\\Delta t = 1 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.002$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$。\n   - 案例3（高指数，长时步，中等模量）: $E = 70 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-50} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 5$, $\\Delta t = 100000 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.001$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$。\n   - 案例4（边界情况：总应变为零）: $E = 100 \\times 10^{9} \\ \\mathrm{Pa}$, $A = 1.0 \\times 10^{-30} \\ \\mathrm{Pa}^{-n}\\,\\mathrm{s}^{-1}$, $n = 3$, $\\Delta t = 1000 \\ \\mathrm{s}$, $\\epsilon_{n+1} = 0.0$, $\\epsilon^{\\mathrm{vp}}_{n} = 0$。\n\n7) 最终输出格式：\n   - 您的程序应生成单行输出，其中包含汇总到一个用方括号括起来的逗号分隔列表中的所有结果。\n   - 对每个测试用例，按此顺序附加：\n     1. $\\sigma_{n+1}$，单位为 $\\mathrm{MPa}$，四舍五入至六位小数（浮点数）。\n     2. $C_{\\mathrm{alg}}$，单位为 $\\mathrm{GPa}$，四舍五入至六位小数（浮点数）。\n     3. 一致性雅可比牛顿求解器使用的迭代次数（整数）。\n     4. 简化雅可比求解器使用的迭代次数（整数）。\n   - 因此，对于四个测试用例，列表总共包含十六个条目：\n     $[\\sigma_1(\\mathrm{MPa}), C_{\\mathrm{alg},1}(\\mathrm{GPa}), it^{(c)}_1, it^{(s)}_1, \\dots, \\sigma_4(\\mathrm{MPa}), C_{\\mathrm{alg},4}(\\mathrm{GPa}), it^{(c)}_4, it^{(s)}_4]$。\n\n您的程序必须是自包含的，不得请求任何输入，并且必须严格按照规定只打印指定的单行列表。", "solution": "问题陈述已经过验证，被认为是科学上合理、良定且自包含的。它代表了计算非弹性力学中的一个标准练习。我们开始进行求解。\n\n推导过程分为三个部分，随后是对数值实现的解释。\n\n**1. 标量非线性残差的推导**\n\n材料的行为由一组基本方程控制。总应变 $\\epsilon$ 可加法分解为一个弹性部分 $\\epsilon^{\\mathrm{e}}$ 和一个粘塑性部分 $\\epsilon^{\\mathrm{vp}}$：\n$$ \\epsilon = \\epsilon^{\\mathrm{e}} + \\epsilon^{\\mathrm{vp}} $$\n应力 $\\sigma$ 通过 Hooke 定律与弹性应变相关：\n$$ \\sigma = E \\, \\epsilon^{\\mathrm{e}} $$\n其中 $E$ 是弹性模量。粘塑性应变 $\\dot{\\epsilon}^{\\mathrm{vp}}$ 的演化率遵循 Norton 幂律：\n$$ \\dot{\\epsilon}^{\\mathrm{vp}} = A \\, |\\sigma|^{n-1}\\sigma $$\n其中 $A$ 和 $n$ 是材料参数。将其写成等价形式 $\\dot{\\epsilon}^{\\mathrm{vp}} = A_s \\mathrm{sgn}(\\sigma)|\\sigma|^n$ 很有用，其中 $A_s$ 通常使用不同的值，该值包含一个参考应力，但对于 $n \\ge 1$ 的情况，给定形式在数学上是清晰的，在物理上是标准的。\n\n我们在时长为 $\\Delta t$ 的时间步上采用后向欧拉时间积分方案。在时间步末端，即时间 $t_{n+1}$ 处的粘塑性应变率近似为：\n$$ \\dot{\\epsilon}^{\\mathrm{vp}}_{n+1} \\approx \\frac{\\epsilon^{\\mathrm{vp}}_{n+1} - \\epsilon^{\\mathrm{vp}}_{n}}{\\Delta t} $$\n此处，$\\epsilon^{\\mathrm{vp}}_{n+1}$ 和 $\\epsilon^{\\mathrm{vp}}_{n}$ 分别是时间 $t_{n+1}$ 和 $t_n$ 时的粘塑性应变。\n\n后向欧拉方法的关键在于，流动法则是使用步末状态 $\\sigma_{n+1}$ 进行计算的：\n$$ \\dot{\\epsilon}^{\\mathrm{vp}}_{n+1} = A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\n结合前两个方程，得到粘塑性应变的更新法则：\n$$ \\epsilon^{\\mathrm{vp}}_{n+1} = \\epsilon^{\\mathrm{vp}}_{n} + \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\n现在，考虑时间 $t_{n+1}$ 时的运动学和弹性定律：\n$$ \\epsilon_{n+1} = \\epsilon^{\\mathrm{e}}_{n+1} + \\epsilon^{\\mathrm{vp}}_{n+1} = \\frac{\\sigma_{n+1}}{E} + \\epsilon^{\\mathrm{vp}}_{n+1} $$\n我们已知总应变 $\\epsilon_{n+1}$ 和上一步的粘塑性应变 $\\epsilon^{\\mathrm{vp}}_{n}$。未知量是步末的应力 $\\sigma_{n+1}$。将 $\\epsilon^{\\mathrm{vp}}_{n+1}$ 的更新法则代入应变分解式，可得：\n$$ \\epsilon_{n+1} = \\frac{\\sigma_{n+1}}{E} + \\epsilon^{\\mathrm{vp}}_{n} + \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\n为了构造残差方程 $R(\\sigma_{n+1}) = 0$，我们重排此方程。在计算力学中，通常定义一个“弹性试探应力”$\\sigma^{\\mathrm{trial}}$，它表示如果该步是纯弹性的（$\\Delta \\epsilon^{\\mathrm{vp}} = 0$）将会达到的应力：\n$$ \\sigma^{\\mathrm{trial}} = E (\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n) $$\n使用这个定义，我们可以将方程重写为：\n$$ \\frac{\\sigma^{\\mathrm{trial}}}{E} = \\frac{\\sigma_{n+1}}{E} + \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\n$$ \\sigma^{\\mathrm{trial}} = \\sigma_{n+1} + E \\, \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} $$\n最后，标量非线性残差 $R$ 被定义为一个函数，其根即为更新后的应力 $\\sigma_{n+1}$：\n$$ R(\\sigma_{n+1}) = \\sigma_{n+1} + E \\, \\Delta t \\, A \\, |\\sigma_{n+1}|^{n-1}\\sigma_{n+1} - \\sigma^{\\mathrm{trial}} = 0 $$\n\n**2. 算法一致性切线模量的推导**\n\n算法一致性切线模量 $C_{\\mathrm{alg}}$ 定义为更新后的应力 $\\sigma_{n+1}$ 相对于给定总应变 $\\epsilon_{n+1}$ 的导数：\n$$ C_{\\mathrm{alg}} = \\frac{d \\sigma_{n+1}}{d \\epsilon_{n+1}} $$\n在隐式有限元分析中，该量对于全局 Newton-Raphson 求解方案的二次收敛性至关重要。为了推导它，我们认识到残差 $R$ 是 $\\sigma_{n+1}$ 和 $\\epsilon_{n+1}$（通过 $\\sigma^{\\mathrm{trial}}$）的函数，并且对于任何容许对 $(\\sigma_{n+1}, \\epsilon_{n+1})$ 都必须恒等于零。因此，它关于 $\\epsilon_{n+1}$ 的全导数必须为零：\n$$ \\frac{dR}{d\\epsilon_{n+1}} = \\frac{\\partial R}{\\partial \\sigma_{n+1}} \\frac{d \\sigma_{n+1}}{d \\epsilon_{n+1}} + \\frac{\\partial R}{\\partial \\epsilon_{n+1}} = 0 $$\n求解 $C_{\\mathrm{alg}}$ 可得：\n$$ C_{\\mathrm{alg}} = \\frac{d \\sigma_{n+1}}{d \\epsilon_{n+1}} = - \\left( \\frac{\\partial R}{\\partial \\sigma_{n+1}} \\right)^{-1} \\left( \\frac{\\partial R}{\\partial \\epsilon_{n+1}} \\right) $$\n我们需要计算这两个偏导数。首先，$R$ 关于 $\\sigma_{n+1}$ 的偏导数。这也是局部牛顿迭代所需的雅可比矩阵。设 $g(\\sigma) = |\\sigma|^{n-1}\\sigma$。其导数为 $g'(\\sigma) = n|\\sigma|^{n-1}$（对于 $n \\ge 1$）。\n$$ \\frac{\\partial R}{\\partial \\sigma_{n+1}} = \\frac{\\partial}{\\partial \\sigma_{n+1}} \\left( \\sigma_{n+1} + E \\, \\Delta t \\, A \\, g(\\sigma_{n+1}) - E(\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n) \\right) $$\n$$ \\frac{\\partial R}{\\partial \\sigma_{n+1}} = 1 + E \\, \\Delta t \\, A \\, \\left( n|\\sigma_{n+1}|^{n-1} \\right) $$\n接下来，是关于 $\\epsilon_{n+1}$ 的偏导数：\n$$ \\frac{\\partial R}{\\partial \\epsilon_{n+1}} = \\frac{\\partial}{\\partial \\epsilon_{n+1}} \\left( \\sigma_{n+1} + E \\, \\Delta t \\, A \\, g(\\sigma_{n+1}) - E(\\epsilon_{n+1} - \\epsilon^{\\mathrm{vp}}_n) \\right) = -E $$\n将这些代入 $C_{\\mathrm{alg}}$ 的表达式中可得：\n$$ C_{\\mathrm{alg}} = - \\left( 1 + n E \\Delta t A |\\sigma_{n+1}|^{n-1} \\right)^{-1} (-E) $$\n$$ C_{\\mathrm_{\\mathrm{alg}}} = \\frac{E}{1 + n E \\Delta t A |\\sigma_{n+1}|^{n-1}} $$\n这就是算法一致性切线模量的显式表达式。\n\n**3. 二次收敛的条件**\n\n用于求解标量方程 $R(\\sigma) = 0$ 的局部 Newton-Raphson 方法，在满足以下三个条件时，在根 $\\sigma^*$ 附近表现出二次收敛性：\n1.  初始猜测值 $\\sigma_0$ 足够接近根 $\\sigma^*$。在我们的问题中，使用了弹性预测值 $\\sigma^{\\mathrm{trial}}$，这通常是一个高质量的初始猜测。\n2.  根是单根，意味着残差在根处的一阶导数非零，即 $R'(\\sigma^*) \\neq 0$。对于我们的残差，其导数为 $R'(\\sigma) = 1 + n E \\Delta t A |\\sigma|^{n-1}$。由于 $E > 0$, $\\Delta t > 0$, $A > 0$, $n \\ge 1$ 且 $|\\sigma|^{n-1} \\ge 0$，因此对于所有 $\\sigma$ 都有 $R'(\\sigma) \\ge 1$。所以，导数永远不为零，根总是单根。这也意味着 $R(\\sigma)$ 是一个严格单调函数，保证了解的唯一性。\n3.  残差函数 $R(\\sigma)$ 在根 $\\sigma^*$ 的一个邻域内是二阶连续可微的（$C^2$）。其二阶导数为 $R''(\\sigma) = n(n-1) E \\Delta t A |\\sigma|^{n-2} \\mathrm{sgn}(\\sigma)$。该函数除了可能在 $\\sigma=0$ 处外，处处连续。\n    -   如果解是 $\\sigma^* \\neq 0$，那么 $R''(\\sigma)$ 在 $\\sigma^*$ 的一个邻域内是连续的。\n    -   如果解是 $\\sigma^* = 0$，那么 $R''(\\sigma)$ 的连续性取决于指数 $n$。$|\\sigma|^{n-2}$ 这一项仅当指数 $n-2 \\ge 0$ (即 $n \\ge 2$) 时在 $\\sigma=0$ 处连续。然而，要使 $R''(\\sigma)$ 连续，极限必须为 $0$。这要求 $n-2>0$，即 $n>2$。对于 $n=2$，$R''(\\sigma)$ 在 $\\sigma=0$ 处有一个跳跃间断点。对于 $1 \\le n < 2$，$R''(\\sigma)$ 在 $\\sigma=0$ 处是奇异的。\n总而言之，如果初始猜测足够接近根，则预期会实现二次收敛。对于任何非零根，这一点是有保证的。如果根恰好为零，则理论上的二次收敛仅在 $n>2$ 时得到保证。由于所有测试用例的 $n \\ge 3$，此条件得到满足。\n\n所提供的 Python 代码为推导出的残差方程实现了两种指定的求解器，计算了最终应力和一致性切线模量，并对每个案例统计了迭代次数，同时遵守所有指定的数值容差、求解器参数和输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the viscoplastic stress update problem for given test cases.\n    \"\"\"\n\n    def compute_step(E, A, n, dt, eps_total, eps_vp_n):\n        \"\"\"\n        Computes the stress update for a single time step using two different solvers.\n\n        Args:\n            E (float): Elastic modulus in Pa.\n            A (float): Norton law parameter in Pa^-n * s^-1.\n            n (float): Norton law exponent.\n            dt (float): Time step in s.\n            eps_total (float): Prescribed total strain at step n+1.\n            eps_vp_n (float): Viscoplastic strain at step n.\n\n        Returns:\n            tuple: A tuple containing:\n                - sigma_n1_mpa (float): Converged stress in MPa.\n                - C_alg_gpa (float): Algorithmic tangent modulus in GPa.\n                - iter_c (int): Iterations for the consistent-Jacobian solver.\n                - iter_s (int): Iterations for the simplified-Jacobian solver.\n        \"\"\"\n        # 1. Initial values, constants, and helper functions\n        sigma_trial = E * (eps_total - eps_vp_n)\n        tol_abs = 1e-8 * E * max(1.0, np.abs(eps_total))\n        max_iter = 50\n\n        def g(sigma):\n            \"\"\"Evaluates the nonlinear part of the flow rule: sgn(sigma) * |sigma|^n.\"\"\"\n            if sigma == 0.0:\n                return 0.0\n            return np.sign(sigma) * np.power(np.abs(sigma), n)\n\n        def R(sigma):\n            \"\"\"Calculates the residual for the nonlinear equation.\"\"\"\n            return sigma + E * dt * A * g(sigma) - sigma_trial\n\n        # ---- Solver 1: Consistent-Jacobian Newton-Raphson ----\n        sigma_c = sigma_trial\n        iter_c = 0\n        \n        # Check if initial guess is already converged\n        res_c_abs = np.abs(R(sigma_c))\n        if res_c_abs > tol_abs:\n            for i in range(1, max_iter + 1):\n                res_c = R(sigma_c)\n                # Consistent Jacobian J = R'(sigma)\n                if sigma_c == 0.0:\n                    J_c = 1.0 # For n > 1. If n=1, term is constant anyway.\n                else:\n                    J_c = 1.0 + E * dt * A * n * np.power(np.abs(sigma_c), n - 1)\n                \n                delta_sigma = -res_c / J_c\n                \n                # Backtracking line search\n                alpha = 1.0\n                sigma_new = sigma_c + alpha * delta_sigma\n                res_new_abs = np.abs(R(sigma_new))\n                \n                while res_new_abs >= res_c_abs:\n                    alpha /= 2.0\n                    if alpha < 1e-8: # Safety break to prevent infinite loop\n                        sigma_new = sigma_c\n                        res_new_abs = res_c_abs\n                        break\n                    sigma_new = sigma_c + alpha * delta_sigma\n                    res_new_abs = np.abs(R(sigma_new))\n                \n                sigma_c = sigma_new\n                res_c_abs = res_new_abs\n                iter_c = i\n\n                if res_c_abs <= tol_abs:\n                    break\n\n        sigma_n1_c = sigma_c\n\n        # ---- Solver 2: Simplified-Jacobian Solver ----\n        sigma_s = sigma_trial\n        iter_s = 0\n\n        res_s_abs = np.abs(R(sigma_s))\n        if res_s_abs > tol_abs:\n            for i in range(1, max_iter + 1):\n                res_s = R(sigma_s)\n                # Simplified Jacobian\n                J_s = 1.0\n                delta_sigma = -res_s / J_s\n                \n                # Backtracking line search\n                alpha = 1.0\n                sigma_new = sigma_s + alpha * delta_sigma\n                res_new_abs = np.abs(R(sigma_new))\n                \n                while res_new_abs >= res_s_abs:\n                    alpha /= 2.0\n                    if alpha < 1e-8: # Safety break\n                        sigma_new = sigma_s\n                        res_new_abs = res_s_abs\n                        break\n                    sigma_new = sigma_s + alpha * delta_sigma\n                    res_new_abs = np.abs(R(sigma_new))\n\n                sigma_s = sigma_new\n                res_s_abs = res_new_abs\n                iter_s = i\n\n                if res_s_abs <= tol_abs:\n                    break\n        \n        # 3. Calculate Algorithmic Consistent Tangent Modulus\n        # Use the converged stress from the consistent solver\n        if sigma_n1_c == 0.0:\n            C_alg_pa = E / 1.0\n        else:\n            C_alg_pa = E / (1.0 + E * dt * A * n * np.power(np.abs(sigma_n1_c), n - 1))\n        \n        # 4. Units conversion for output\n        sigma_n1_mpa = sigma_n1_c / 1e6\n        C_alg_gpa = C_alg_pa / 1e9\n        \n        return sigma_n1_mpa, C_alg_gpa, iter_c, iter_s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (moderate stress relaxation)\n        {'E': 210e9, 'A': 1.0e-30, 'n': 3, 'dt': 3600, 'eps_total': 0.002, 'eps_vp_n': 0},\n        # Case 2 (nearly elastic)\n        {'E': 210e9, 'A': 1.0e-30, 'n': 3, 'dt': 1, 'eps_total': 0.002, 'eps_vp_n': 0},\n        # Case 3 (high exponent, long step)\n        {'E': 70e9, 'A': 1.0e-50, 'n': 5, 'dt': 100000, 'eps_total': 0.001, 'eps_vp_n': 0},\n        # Case 4 (edge case: zero strain)\n        {'E': 100e9, 'A': 1.0e-30, 'n': 3, 'dt': 1000, 'eps_total': 0.0, 'eps_vp_n': 0},\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        s_mpa, C_gpa, it_c, it_s = compute_step(**case_params)\n        \n        # Append results in specified format\n        all_results.append(f\"{s_mpa:.6f}\")\n        all_results.append(f\"{C_gpa:.6f}\")\n        all_results.append(str(it_c))\n        all_results.append(str(it_s))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2883346"}]}