{"hands_on_practices": [{"introduction": "在应用任何物理定律之前，科学家或工程师必须首先掌握其基本构成。本练习将通过量纲分析这一基本工具，来揭示Paris定律中经验常数 $C$ 的物理单位。这个过程不仅能加深你对该定律数学结构的理解，还能强化对其中每一个物理量实际意义的认识，这是进行严谨科学计算的基石。[@problem_id:2885911]", "problem": "一个金属结构试件在循环载荷下经历疲劳，其每循环裂纹扩展速率由一个与I型应力强度因子范围相关的幂律关系决定。设 $a$ 表示以米为单位测量的裂纹长度，I型应力强度因子范围 $\\Delta K$ 以兆帕-根号米为单位，即 $\\Delta K$ 的单位是 $\\text{MPa}\\sqrt{\\text{m}}$，其中兆帕 (MPa) 是 $10^{6}$ 帕斯卡 (Pa)。每循环裂纹扩展速率 $da/d(\\text{cycle})$ 与 $(\\Delta K)^{m}$ 成正比，比例常数 $C$ 未知，且取决于材料和环境。\n\n假设使用国际单位制 (SI) 的基本单位千克 (kg)、米 (m) 和秒 (s)，并视“循环”为无量纲计数（为清晰起见，您可以明确地追踪“每循环”，但它不引入SI基本量纲）。\n\n使用量纲分析，并基于以下基本事实：应力具有压力（帕斯卡）的单位，其中 $1\\,\\text{Pa} = 1\\,\\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}$，以及I型应力强度因子量纲的定义 $[\\Delta K] = [\\text{stress}]\\,[\\text{length}]^{1/2}$，请确定比例常数 $C$ 必须具有的物理单位，以使该关系对于任意实数指数 $m$ 都是量纲一致的。\n\n请将您的最终答案表示为 $C$ 的SI基本单位 $(\\text{kg}, \\text{m}, \\text{s})$ 的指数关于 $m$ 的函数所构成的行向量，并按此顺序排列。例如，形式为 $\\text{kg}^{\\alpha}\\,\\text{m}^{\\beta}\\,\\text{s}^{\\gamma}$ 的答案应按指定顺序报告为单个行向量 $(\\alpha, \\beta, \\gamma)$。不要求进行数值计算。", "solution": "任务是根据量纲一致性的要求来确定比例常数 $C$ 的单位。所考虑的裂纹扩展定律指出，每循环裂纹扩展速率与I型应力强度因子范围的某个幂成正比。将比例常数记为 $C$，指数记为 $m$。每循环速率为 $da/d(\\text{cycle})$，其中 $a$ 的单位是长度。\n\n我们使用国际单位制 (SI) 的基本单位千克 (kg)、米 (m) 和秒 (s) 进行量纲分析，并利用以下基本事实：\n- 应力是压力，其单位为 $[\\text{stress}] = [\\text{Pa}] = \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}$。\n- I型应力强度因子 $K$ 的量纲为 $[\\text{stress}]\\,[\\text{length}]^{1/2}$，因此 $[K] = \\text{kg}\\,\\text{m}^{-1}\\,\\text{s}^{-2}\\cdot \\text{m}^{1/2} = \\text{kg}\\,\\text{m}^{-1/2}\\,\\text{s}^{-2}$。\n- 范围 $\\Delta K$ 与 $K$ 具有相同的量纲，因此 $[\\Delta K] = \\text{kg}\\,\\text{m}^{-1/2}\\,\\text{s}^{-2}$。以兆帕-根号米 $\\text{MPa}\\sqrt{\\text{m}}$ 报告 $K$ 或 $\\Delta K$ 不会改变其相对于帕斯卡的量纲，因为连接 MPa 和 Pa 的因子 $10^{6}$ 是无量纲的；它只改变数值大小。\n\n每循环裂纹扩展速率 $da/d(\\text{cycle})$ 的单位是长度/循环。由于“循环”在 SI 中是无量纲计数，因此 $da/d(\\text{cycle})$ 的 SI 基本量纲简化为长度的量纲：\n$$\n\\left[\\frac{da}{d(\\text{cycle})}\\right] = \\text{m}.\n$$\n\n该正比关系意味着\n$$\n\\left[\\frac{da}{d(\\text{cycle})}\\right] = [C]\\,[\\Delta K]^{m}.\n$$\n解出 $C$ 的单位可得\n$$\n[C] = \\frac{\\left[\\dfrac{da}{d(\\text{cycle})}\\right]}{[\\Delta K]^{m}} = \\frac{\\text{m}}{\\left(\\text{kg}\\,\\text{m}^{-1/2}\\,\\text{s}^{-2}\\right)^{m}}.\n$$\n对分母进行幂运算，\n$$\n[\\Delta K]^{m} = \\text{kg}^{m}\\,\\text{m}^{-m/2}\\,\\text{s}^{-2m}.\n$$\n因此，\n$$\n[C] = \\text{kg}^{-m}\\,\\text{m}^{1 + \\frac{m}{2}}\\,\\text{s}^{2m}.\n$$\n\n如果希望将“每循环”作为一个记账标签来追踪，那么也可以用兆帕 (MPa) 和米 (m) 来表示明确的工程单位，如下所示\n$$\n[C] = \\text{MPa}^{-m}\\,\\text{m}^{\\,1 - \\frac{m}{2}}\\,\\text{cycle}^{-1},\n$$\n这是等效的，因为 $\\text{MPa}$ 与 $\\text{Pa}$ 具有相同的量纲，且因子 $10^{6}$ 是无量纲的。将 $\\text{MPa}^{-m}$ 展开为 SI 基本单位可恢复以下表达式\n$$\n[C] = \\text{kg}^{-m}\\,\\text{m}^{\\,1 + \\frac{m}{2}}\\,\\text{s}^{2m},\n$$\n其中“循环”在 SI 中是无量纲的。\n\n问题要求将最终答案表示为 $(\\text{kg}, \\text{m}, \\text{s})$ 的指数构成的行向量，并按此顺序排列。从 SI 基本单位表达式中读出指数可得：\n- $\\text{kg}$ 的指数：$-m$，\n- $\\text{m}$ 的指数：$1 + \\dfrac{m}{2}$，\n- $\\text{s}$ 的指数：$2m$。\n\n因此，所求的行向量是 $( -m,\\ 1 + \\dfrac{m}{2},\\ 2m )$。", "answer": "$$\\boxed{\\begin{pmatrix}-m & 1 + \\dfrac{m}{2} & 2m\\end{pmatrix}}$$", "id": "2885911"}, {"introduction": "掌握Paris定律的核心应用之一是预测结构的疲劳寿命。本练习将引导你从抽象的微分方程走向具体的寿命计算，通过对裂纹扩展速率进行积分来预测在恒定幅值循环载荷下裂纹的扩展寿命。由于几何修正因子 $Y$ 的存在使解析积分变得困难，本练习强调了数值积分方法在工程实践中的重要性，这是一项关键的计算技能。[@problem_id:2885969]", "problem": "一块结构板含有一条单边裂纹，承受循环远场拉伸载荷。你需要计算在恒定幅值的循环应力作用下，裂纹从初始长度 $a_i$ 扩展到最终长度 $a_f$ 所需的载荷循环次数。你的推导和算法必须从以下基本原理出发，不得假定任何闭合形式的积分结果：\n- I型加载的应力强度因子范围定义为 $\\Delta K(a) = Y(a/W)\\,\\Delta \\sigma \\,\\sqrt{\\pi a}$，其中 $Y(a/W)$ 是一个无量纲的几何修正函数，$W$ 是板的宽度，$a$ 是裂纹长度，$\\Delta \\sigma$ 是施加的远场应力范围。\n- 在Paris区，疲劳裂纹扩展速率遵循一个经过充分经验验证的、与应力强度因子范围相关的幂律关系，该关系由材料常数 $C$ 和 $m$ 表征。\n- 从 $a_i$ 扩展到 $a_f$ 所需的循环次数 $N$ 是通过对裂纹扩展速率的倒数在 $a$ 上积分来确定的。\n\n使用数值积分来计算得到 $N$ 的定积分。不允许使用闭合形式的反导数；你必须以足够的精度进行数值积分。对于单边裂纹板的几何因子，采用以下科学上公认的多项式近似（在 $0 \\le a/W \\lesssim 0.6$ 范围内有效）：\n$$\nY(\\alpha) \\equiv Y\\!\\left(\\frac{a}{W}\\right) = 1.12 - 0.231\\,\\alpha + 10.55\\,\\alpha^2 - 21.72\\,\\alpha^3 + 30.39\\,\\alpha^4,\n$$\n其中 $\\alpha = a/W$。\n\n物理和数值单位：\n- 使用国际单位制（SI）。裂纹长度 $a$、$a_i$、$a_f$ 及宽度 $W$ 必须以米（m）为单位。应力 $\\Delta \\sigma$ 必须以兆帕（MPa）为单位。因此，应力强度因子范围 $\\Delta K$ 的单位是 $\\text{MPa}\\sqrt{\\text{m}}$。\n- 材料常数 $C$ 的单位必须是 $\\text{m/cycle} \\cdot (\\text{MPa}\\sqrt{\\text{m}})^{-m}$，以使裂纹扩展速率的单位为 $\\text{m/cycle}$。\n- 输出循环次数，单位为“次”（cycles，无量纲），并四舍五入到六位小数。\n\n测试集：\n对于以下每一组参数，计算裂纹从 $a_i = 1\\,\\text{mm}$ 扩展到 $a_f = 10\\,\\text{mm}$ 所需的循环次数 $N$。在计算中将毫米转换为米：$1\\,\\text{mm} = 1.0\\times 10^{-3}\\,\\text{m}$ 和 $10\\,\\text{mm} = 1.0\\times 10^{-2}\\,\\text{m}$。确保积分域内所有的 $a/W$ 值都保持在 $Y(\\alpha)$ 的规定有效范围内。\n- 情况1（理想情况）：$W = 50\\,\\text{mm}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 3.0$。\n- 情况2（减小应力范围）：$W = 50\\,\\text{mm}$，$\\Delta \\sigma = 50\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 3.0$。\n- 情况3（增大指数）：$W = 50\\,\\text{mm}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 4.0$。\n- 情况4（较窄的板，几何有效性边界）：$W = 25\\,\\text{mm}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0\\times 10^{-12}$，$m = 3.0$。\n- 情况5（不同的材料常数）：$W = 40\\,\\text{mm}$，$\\Delta \\sigma = 80\\,\\text{MPa}$，$C = 5.0\\times 10^{-13}$，$m = 3.2$。\n\n算法要求：\n- 你的程序必须对每种情况，使用稳健的积分方法在 $a \\in [a_i,a_f]$ 上对定义 $N$ 的积分进行数值计算，并设置足够小的绝对和相对容差，以确保结果中至少有六位有效数字是正确的。\n- 完全按照上面给出的公式处理 $Y(a/W)$，其中 $a$ 和 $W$ 始终以米为单位。\n- 对每种情况，验证在整个积分区间内 $a/W \\le 0.6$；如果任何测试用例违反了此条件，则计算将无效（但是，所提供的测试集已构造为满足此条件）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个情况的结果，格式为方括号内以逗号分隔的列表，每个值都以“次”（cycles）为单位四舍五入到六位小数（例如，$[n_1,n_2,n_3,n_4,n_5]$）。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 疲劳裂纹扩展速率定律：隐式地由Paris-Erdogan定律给出，$da/dN = f(\\Delta K)$。\n- 定律的显式形式：$da/dN = C(\\Delta K)^m$。\n- I型应力强度因子范围：$\\Delta K(a) = Y(a/W)\\,\\Delta \\sigma \\,\\sqrt{\\pi a}$。\n- 单边裂纹板的几何修正函数：$Y(\\alpha) = 1.12 - 0.231\\,\\alpha + 10.55\\,\\alpha^2 - 21.72\\,\\alpha^3 + 30.39\\,\\alpha^4$，其中 $\\alpha = a/W$。\n- $Y(\\alpha)$ 的有效范围：$0 \\le a/W \\lesssim 0.6$。\n- 裂纹从 $a_i$ 扩展到 $a_f$ 所需的循环次数 $N$：$N = \\int_{a_i}^{a_f} \\frac{1}{da/dN} \\, da$。\n- 数值计算要求：计算 $N$ 的积分必须使用数值积分，而不是闭合形式的反导数。\n- 单位：裂纹长度（$a, a_i, a_f, W$）以米（m）为单位，应力范围 $\\Delta \\sigma$ 以兆帕（MPa）为单位，$\\Delta K$ 以 $\\text{MPa}\\sqrt{\\text{m}}$ 为单位，材料常数 $C$ 以 $\\text{m/cycle} \\cdot (\\text{MPa}\\sqrt{\\text{m}})^{-m}$ 为单位。\n- 初始和最终裂纹长度：$a_i = 1\\,\\text{mm} = 1.0 \\times 10^{-3}\\,\\text{m}$，$a_f = 10\\,\\text{mm} = 1.0 \\times 10^{-2}\\,\\text{m}$。\n- 测试用例：\n  - 情况1：$W = 50\\,\\text{mm} = 5.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 3.0$。\n  - 情况2：$W = 50\\,\\text{mm} = 5.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 50\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 3.0$。\n  - 情况3：$W = 50\\,\\text{mm} = 5.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 4.0$。\n  - 情况4：$W = 25\\,\\text{mm} = 2.5 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 100\\,\\text{MPa}$，$C = 1.0 \\times 10^{-12}$，$m = 3.0$。\n  - 情况5：$W = 40\\,\\text{mm} = 4.0 \\times 10^{-2}\\,\\text{m}$，$\\Delta \\sigma = 80\\,\\text{MPa}$，$C = 5.0 \\times 10^{-13}$，$m = 3.2$。\n- 算法要求：验证在积分区间 $[a_i, a_f]$ 内 $a/W \\le 0.6$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据和客观性**：该问题基于线弹性断裂力学的公认原理，特别是用于疲劳裂纹扩展的Paris-Erdogan定律。这是材料科学和机械工程中的一个标准和基本概念。其表述是客观的，并使用了精确的标准术语。\n- **适定性**：该问题是适定的。它要求计算一个在指定积分区间 $[a_i, a_f]$ 上连续且表现良好的函数的定积分，因为 $a_i > 0$。对于循环次数 $N$ 存在唯一、稳定的解。\n- **不完整或矛盾的设定**：该问题是自洽的。为每个测试用例提供了所有必需的材料常数、几何参数和加载条件。单位在内部是一致的。必须检查几何函数 $a/W \\le 0.6$ 的有效性条件。对于所有情况，最大裂纹长度为 $a_f = 1.0 \\times 10^{-2}\\,\\text{m}$。\n  - 情况1：$a_f/W = (1.0 \\times 10^{-2}) / (5.0 \\times 10^{-2}) = 0.2 \\le 0.6$。有效。\n  - 情况2：$a_f/W = (1.0 \\times 10^{-2}) / (5.0 \\times 10^{-2}) = 0.2 \\le 0.6$。有效。\n  - 情况3：$a_f/W = (1.0 \\times 10^{-2}) / (5.0 \\times 10^{-2}) = 0.2 \\le 0.6$。有效。\n  - 情况4：$a_f/W = (1.0 \\times 10^{-2}) / (2.5 \\times 10^{-2}) = 0.4 \\le 0.6$。有效。\n  - 情况5：$a_f/W = (1.0 \\times 10^{-2}) / (4.0 \\times 10^{-2}) = 0.25 \\le 0.6$。有效。\n对于所有测试用例，在整个积分域上均满足有效性条件。\n- **不切实际或不可行**：所提供的材料参数和应力水平对于常见的工程合金（如钢或铝）在循环加载条件下来说是现实的。\n\n**第3步：结论与行动**\n该问题科学合理、适定且完整。它是**有效的**。将提供一个解决方案。\n\n**求解推导**\n裂纹扩展速率 $da/dN$ 与加载循环次数 $N$ 之间的基本关系，可以通过对微分形式进行变量分离得到：\n$$ dN = \\frac{da}{da/dN} $$\n为了求得裂纹从初始长度 $a_i$ 扩展到最终长度 $a_f$ 所需的总循环次数 $N$，我们必须在裂纹长度区间上对该表达式进行积分：\n$$ N = \\int_{a_i}^{a_f} \\frac{1}{da/dN} \\, da $$\n疲劳裂纹的扩展速率 $da/dN$ 由Paris-Erdogan定律控制，该定律将扩展速率与应力强度因子范围 $\\Delta K$ 相关联：\n$$ \\frac{da}{dN} = C (\\Delta K)^m $$\n其中 $C$ 和 $m$ 是经验性材料常数。\n\n将Paris定律代入 $N$ 的积分中，得到：\n$$ N = \\int_{a_i}^{a_f} \\frac{1}{C (\\Delta K)^m} \\, da $$\n应力强度因子范围 $\\Delta K$ 是外加应力范围 $\\Delta \\sigma$、裂纹长度 $a$ 以及构件几何形状的函数。对于指定的单边裂纹板，其表达式为：\n$$ \\Delta K(a) = Y(\\alpha) \\Delta \\sigma \\sqrt{\\pi a} $$\n其中 $\\alpha = a/W$，$Y(\\alpha)$ 是以多项式形式给出的无量纲几何修正因子：\n$$ Y(\\alpha) = 1.12 - 0.231\\,\\alpha + 10.55\\,\\alpha^2 - 21.72\\,\\alpha^3 + 30.39\\,\\alpha^4 $$\n通过将 $\\Delta K(a)$ 的表达式代入 $N$ 的积分中，我们得到完整的被积函数：\n$$ N = \\int_{a_i}^{a_f} \\frac{1}{C \\left( Y(a/W) \\Delta \\sigma \\sqrt{\\pi a} \\right)^m} \\, da $$\n可以重写此式，将常数项从积分中分离出来：\n$$ N = \\frac{1}{C (\\Delta \\sigma)^m (\\pi)^{m/2}} \\int_{a_i}^{a_f} \\frac{1}{\\left( Y(a/W) \\sqrt{a} \\right)^m} \\, da $$\n由于 $Y(a/W)$ 的多项式形式，该积分没有通用的闭合形式解析解。因此，按照题目要求，数值积分是进行计算的正确且必要的方法。我们定义被积函数 $f(a)$：\n$$ f(a) = \\frac{1}{C \\left( Y(a/W) \\Delta \\sigma \\sqrt{\\pi a} \\right)^m} $$\n循环次数即为 $N = \\int_{a_i}^{a_f} f(a) \\, da$。这个定积分将使用稳健的数值积分算法对每个测试用例进行计算，确保所有物理量统一使用国际单位制。裂纹长度 $a$、$a_i$、$a_f$ 和板宽 $W$ 的单位是米（m）。应力范围 $\\Delta \\sigma$ 的单位是兆帕（MPa）。Paris常数 $C$ 的单位是 $\\text{m/cycle} \\cdot (\\text{MPa}\\sqrt{\\text{m}})^{-m}$。最终得到的 $N$ 值将是一个代表循环次数的无量纲量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the number of fatigue cycles for crack growth using numerical integration\n    of the Paris law.\n    \"\"\"\n    \n    # Define the initial and final crack lengths in meters.\n    a_i = 1.0e-3  # m\n    a_f = 1.0e-2  # m\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (W_m, delta_sigma_MPa, C, m)\n    # W_m is the plate width in meters.\n    # delta_sigma_MPa is the stress range in MPa.\n    # C is the Paris law constant in m/cycle * (MPa*sqrt(m))^-m.\n    # m is the Paris law exponent (dimensionless).\n    test_cases = [\n        # Case 1: Happy path\n        (50.0e-3, 100.0, 1.0e-12, 3.0),\n        # Case 2: Reduced stress range\n        (50.0e-3, 50.0, 1.0e-12, 3.0),\n        # Case 3: Increased exponent\n        (50.0e-3, 100.0, 1.0e-12, 4.0),\n        # Case 4: Narrower plate\n        (25.0e-3, 100.0, 1.0e-12, 3.0),\n        # Case 5: Different material constants\n        (40.0e-3, 80.0, 5.0e-13, 3.2),\n    ]\n\n    results = []\n    \n    # Polynomial coefficients for the geometry function Y(alpha), where alpha = a/W.\n    # Y(alpha) = c0 + c1*alpha + c2*alpha^2 + c3*alpha^3 + c4*alpha^4\n    Y_coeffs = np.array([30.39, -21.72, 10.55, -0.231, 1.12])\n\n    def Y(alpha):\n        \"\"\"\n        Computes the geometry correction factor Y for a given alpha = a/W.\n        \"\"\"\n        return np.polyval(Y_coeffs, alpha)\n\n    for case in test_cases:\n        W_m, delta_sigma_MPa, C, m = case\n\n        def integrand(a):\n            \"\"\"\n            Defines the function 1 / (da/dN) to be integrated with respect to crack length 'a'.\n            All units must be consistent (SI/MPa based).\n            \n            Args:\n                a (float): Crack length in meters.\n\n            Returns:\n                float: The value of 1 / (da/dN) in units of cycles/m.\n            \"\"\"\n            # Calculate dimensionless crack length ratio\n            alpha = a / W_m\n\n            # Check if a/W is within the valid range for the geometry function Y.\n            # The problem statement guarantees this, but it is good practice.\n            if not (0 <= alpha <= 0.6):\n                # This should not be reached with the given test cases.\n                # Return infinity to signal an error if quad explores outside the domain.\n                return np.inf\n            \n            # Calculate geometry factor\n            Y_val = Y(alpha)\n            \n            # Calculate stress intensity factor range (MPa*sqrt(m))\n            delta_K = Y_val * delta_sigma_MPa * np.sqrt(np.pi * a)\n            \n            # Calculate crack growth rate (m/cycle) using Paris law\n            da_dN = C * (delta_K ** m)\n            \n            # The function to integrate is the reciprocal of the growth rate\n            return 1.0 / da_dN\n\n        # Perform numerical integration from a_i to a_f\n        # quad returns a tuple (result, error_estimate)\n        N_cycles, _ = integrate.quad(\n            integrand, \n            a_i, \n            a_f,\n            epsabs=1e-9, # Absolute tolerance for high accuracy\n            epsrel=1e-9  # Relative tolerance for high accuracy\n        )\n        \n        results.append(N_cycles)\n\n    # Final print statement must be in the exact required format.\n    # Each value is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2885969"}, {"introduction": "真实世界的载荷谱远比恒定幅值的循环要复杂。本项高级实践旨在弥合理论与工程实践的鸿沟，要求你模拟在可变幅值载荷下的裂纹扩展，特别是要考虑过载（overload）引起的“减速效应”（retardation effect）。你将通过构建一个整合了裂纹闭合与载荷历史效应模型的逐周循环仿真程序，体验更接近真实的计算断裂力学分析。[@problem_id:2885943]", "problem": "您需要实现一个模拟，计算在规定的循环加载块谱作用下单边裂纹有限宽度板的疲劳裂纹扩展。每个周期的裂纹扩展量由一个关于有效应力强度因子范围的幂律关系决定，该关系经过裂纹闭合函数和延迟因子的修正。模拟必须逐个循环进行显式迭代，以累积裂纹的推进量。所有物理量在适用时必须采用国际单位制（SI），其中应力单位为兆帕，长度单位为米，应力强度因子单位为兆帕乘以米的平方根。\n\n请从以下基本事实和定义开始。\n\n1) I型加载下有限宽度单边裂纹板的应力强度因子：其范围由每个周期的最大和最小应力水平构成。对于在裂纹长度为$a$、板宽为$W$时的每个周期，处理\n$$\nY\\left(\\frac{a}{W}\\right) = 1.12 - 0.231\\left(\\frac{a}{W}\\right) + 10.55\\left(\\frac{a}{W}\\right)^2 - 21.72\\left(\\frac{a}{W}\\right)^3 + 30.39\\left(\\frac{a}{W}\\right)^4,\n$$\n并将I型应力强度因子的最大值和最小值定义为\n$$\nK_{\\max} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\max}\\,\\sqrt{\\pi a},\\quad\nK_{\\min} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\min}\\,\\sqrt{\\pi a},\n$$\n其中$\\sigma_{\\max}$和$\\sigma_{\\min}$分别是该周期内施加的名义应力的最大值和最小值。应力比为$R=\\sigma_{\\min}/\\sigma_{\\max}$，范围为$\\Delta K = K_{\\max}-K_{\\min} = (1-R)\\,K_{\\max}$。\n\n2) 基于Newman的平面应力下经验性裂纹张开估算，通过裂纹闭合得到有效范围：定义\n$$\n\\phi(R) = 0.825 - 0.34\\,R + 0.05\\,R^2,\n$$\n并将其值限定在区间$[0,1]$内。对于$-1 \\le R \\le 1$，裂纹张开比为$K_{\\mathrm{op}}/K_{\\max}=\\phi(R)$，对于超出该范围的任何$R$值，应用此限定。裂纹张开函数为\n$$\nU(R) = \\frac{K_{\\max} - K_{\\mathrm{op}}}{\\Delta K} = \\frac{1 - \\phi(R)}{1 - R},\n$$\n其值限定在区间$[0,1]$内，并在极限情况下，当$R\\to 1$以致$\\Delta K \\to 0$时，解释为$U(R)=1$。有效范围为$\\Delta K_{\\mathrm{eff}} = U(R)\\,\\Delta K$。\n\n3) 通过Wheeler型塑性区模型实现的延迟效应：假设屈服强度为$\\sigma_{y}$。对于被指定为过载事件的循环，计算过载尖端处的平面应力单调塑性区尺寸：\n$$\nr_{p,\\mathrm{ol}} = \\frac{1}{2\\pi}\\left(\\frac{K_{\\max,\\mathrm{ol}}}{\\sigma_{y}}\\right)^2,\n$$\n并将过载时的裂纹长度记录为$a_{\\mathrm{ol}}$。对于后续的循环，直到裂纹尖端到达$a \\ge a_{\\mathrm{ol}} + r_{p,\\mathrm{ol}}$，应用一个延迟因子\n$$\nf_{\\mathrm{ret}} = \\left(\\max\\left\\{0,\\frac{a_{\\mathrm{ol}} + r_{p,\\mathrm{ol}} - a}{r_{p,\\mathrm{ol}}}\\right\\}\\right)^{\\gamma_{w}},\n$$\n其中$\\gamma_{w}$是给定的Wheeler指数。当$a \\ge a_{\\mathrm{ol}} + r_{p,\\mathrm{ol}}$时，设置$f_{\\mathrm{ret}}=1$，直到下一次过载。如果在先前的过载塑性区耗尽之前发生新的过载，则使用新过载循环的$K_{\\max}$覆盖$a_{\\mathrm{ol}}$和$r_{p,\\mathrm{ol}}$。\n\n您的程序必须：\n- 对每个循环，计算$Y$、$K_{\\max}$、$K_{\\min}$、$\\Delta K$、$U(R)$、$\\Delta K_{\\mathrm{eff}}$和$f_{\\mathrm{ret}}$。\n- 使用给定的材料常数$C$和$m$，使裂纹长度按每循环的增量推进，该增量与有效范围成幂律关系。\n- 累积整个块谱下的总裂纹扩展量。\n- 对每个测试用例，输出总裂纹推进量$\\Delta a = a_{\\mathrm{final}} - a_{0}$。\n\n科学真实性约束：\n- 一致地使用单位：$\\sigma$和$\\sigma_{y}$的单位为兆帕，$a$和$W$的单位为米，$K$的单位为$\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，材料系数$C$的单位为$\\mathrm{m}/\\mathrm{cycle}/(\\mathrm{MPa}\\sqrt{\\mathrm{m}})^{m}$。\n- 如上所示，使用平面应力塑性区缩放因子$1/(2\\pi)$。\n- 如上所给，使用应力强度因子几何函数$Y(a/W)$，不做修改。\n- 使用$\\gamma_{w} = 1.0$。\n\n数值说明：\n- 对于每个测试用例，生成一个等于总裂纹推进量$\\Delta a$（单位：米）的浮点数，四舍五入到$10^{-12}$米。\n- 计算中不出现角度，因此不需要角度单位。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，给定板宽$W$、初始裂纹长度$a_{0}$、屈服强度$\\sigma_{y}$、材料常数$C$和$m$，以及一个由加载段组成的块谱。每个加载段是一个元组$\\left(N_{i}, \\sigma_{\\max,i}, R_{i}, \\mathrm{OL}_{i}\\right)$，表示在该水平下连续进行$N_{i}$次循环，其中$R_{i}=\\sigma_{\\min,i}/\\sigma_{\\max,i}$，$\\mathrm{OL}_{i}$是一个布尔值，指示该段的第一个循环是否为延迟模型的过载事件。如果存在过载事件，则必须在施加该过载循环的增量后更新$a_{\\mathrm{ol}}$和$r_{p,\\mathrm{ol}}$。\n\n- 测试用例1：\n  - $W = 0.10$米, $a_{0} = 0.005$米, $\\sigma_{y} = 350$兆帕, $C = 2.0\\times 10^{-12}$, $m = 3.2$。\n  - 块谱：\n    - $\\left(1000, 120, 0.10, \\mathrm{false}\\right)$\n    - $\\left(1, 220, 0.10, \\mathrm{true}\\right)$\n    - $\\left(2000, 120, 0.10, \\mathrm{false}\\right)$\n    - $\\left(1000, 140, 0.30, \\mathrm{false}\\right)$\n\n- 测试用例2：\n  - $W = 0.08$米, $a_{0} = 0.004$米, $\\sigma_{y} = 400$兆帕, $C = 1.5\\times 10^{-12}$, $m = 3.0$。\n  - 块谱：\n    - $\\left(3000, 100, -0.30, \\mathrm{false}\\right)$\n    - $\\left(1000, 140, 0.00, \\mathrm{false}\\right)$\n\n- 测试用例3：\n  - $W = 0.06$米, $a_{0} = 0.020$米, $\\sigma_{y} = 500$兆帕, $C = 5.0\\times 10^{-13}$, $m = 3.5$。\n  - 块谱：\n    - $\\left(800, 160, 0.40, \\mathrm{false}\\right)$\n    - $\\left(1, 260, 0.40, \\mathrm{true}\\right)$\n    - $\\left(1500, 160, 0.40, \\mathrm{false}\\right)$\n    - $\\left(1, 300, 0.40, \\mathrm{true}\\right)$\n    - $\\left(1000, 170, 0.40, \\mathrm{false}\\right)$\n\n算法和实现要求：\n- 按提供的顺序逐个循环进行迭代。在每个加载段内，当且仅当$\\mathrm{OL}_{i}=\\mathrm{true}$时将第一个循环视为过载；否则它是一个常规循环。\n- 按照所述，使用针对$\\phi(R)$和$U(R)$的限定规则。\n- 为保证数值稳健性，如果$R$非常接近1以至于$1-R < 10^{-9}$，则在该循环中设置$U(R)=1$。\n- 如果在模拟过程中，$a/W$超过$0.6$，本问题仍继续使用相同的$Y(a/W)$关系式。\n- 要求的最终输出格式是包含一个Python风格列表的单行，列表中按顺序包含三个结果，每个结果四舍五入到$10^{-12}$米。例如，打印的行必须如下所示：\n  $$\n  [x_{1},x_{2},x_{3}]\n  $$\n  其中$x_{i}$是以米为单位的十进制数。\n\n您的程序必须是一个完整的、可运行的脚本，它只产生这一行输出，没有其他任何内容。", "solution": "问题陈述已经过严格验证。它具有科学依据、提法明确、客观且内部一致。它提出了一个计算断裂力学中标准的、尽管复杂的问题，要求在变幅载荷下对疲劳裂纹扩展律进行数值积分。所提供的模型——用于应力强度因子的多项式几何函数、Newman的裂纹闭合模型和Wheeler的延迟模型——都是该领域的成熟组成部分。每个测试用例都提供了所有必要的参数、边界条件和材料常数。关于数值算法的说明，包括过载事件的特定处理和数值稳定性考虑，是明确且充分的，足以开发出一个无歧义的实现。该问题被认为是有效的，并将提供一个解决方案。\n\n任务是模拟在块加载谱作用下单边裂纹板中疲劳裂纹的逐周期扩展。每个测试用例所需的输出是总裂纹扩展量$\\Delta a$。\n\n模拟的核心是裂纹扩展律，它综合了外加应力范围、裂纹闭合和过载引起的延迟效应。每周循环的裂纹扩展增量$\\Delta a_{\\text{cycle}}$由一个修正的Paris定律给出：\n$$\n\\frac{da}{dN} \\approx \\Delta a_{\\text{cycle}} = f_{\\text{ret}} \\cdot C \\cdot (\\Delta K_{\\text{eff}})^m\n$$\n其中$C$和$m$是材料常数，$\\Delta K_{\\text{eff}}$是有效应力强度因子范围，而$f_{\\text{ret}}$是延迟因子。模拟通过在加载谱中指定的总循环次数上累积这些增量来进行。\n\n对于当前裂纹长度为$a$的每个循环，计算过程如下：\n\n首先，使用给定的多项式计算有限宽度板的几何修正因子$Y(a/W)$：\n$$\nY\\left(\\frac{a}{W}\\right) = 1.12 - 0.231\\left(\\frac{a}{W}\\right) + 10.55\\left(\\frac{a}{W}\\right)^2 - 21.72\\left(\\frac{a}{W}\\right)^3 + 30.39\\left(\\frac{a}{W}\\right)^4\n$$\n其中$W$是板宽。\n\n其次，计算当前循环在应力$\\sigma_{\\max}$和$\\sigma_{\\min}$下的最大和最小应力强度因子$K_{\\max}$和$K_{\\min}$：\n$$\nK_{\\max} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\max}\\,\\sqrt{\\pi a}\n$$\n$$\nK_{\\min} = Y\\left(\\frac{a}{W}\\right)\\,\\sigma_{\\min}\\,\\sqrt{\\pi a}\n$$\n应力强度因子范围为$\\Delta K = K_{\\max} - K_{\\min}$。\n\n第三，引入裂纹闭合效应以确定有效应力强度因子范围$\\Delta K_{\\text{eff}}$。这基于Newman的经验模型。该循环的应力比为$R = \\sigma_{\\min}/\\sigma_{\\max}$。首先计算裂纹张开函数$\\phi(R)$。输入$R$在用于公式前被限定在区间$[-1, 1]$内，输出则被限定在$[0, 1]$内：\n$$\nR_{\\text{clipped}} = \\max(-1, \\min(1, R))\n$$\n$$\n\\phi(R) = \\text{clip}_{[0,1]}\\left(0.825 - 0.34\\,R_{\\text{clipped}} + 0.05\\,R_{\\text{clipped}}^2\\right)\n$$\n然后确定裂纹闭合参数$U(R)$。为保证当$R \\to 1$时的数值稳定性，如果$1-R < 10^{-9}$，则$U(R)$设为$1$。否则，计算公式为：\n$$\nU(R) = \\frac{1 - \\phi(R)}{1 - R}\n$$\n此结果也被限定在区间$[0, 1]$内。有效范围则为：\n$$\n\\Delta K_{\\text{eff}} = U(R)\\,\\Delta K\n$$\n\n第四，基于Wheeler模型计算延迟因子$f_{\\text{ret}}$。该模型解释了由先前过载产生的塑性区内的残余压应力。一个过载由其最大应力强度因子$K_{\\max,\\text{ol}}$和发生过载时的裂纹长度$a_{\\text{ol}}$来定义。相关的塑性区尺寸为：\n$$\nr_{p,\\text{ol}} = \\frac{1}{2\\pi}\\left(\\frac{K_{\\max,\\text{ol}}}{\\sigma_{y}}\\right)^2\n$$\n其中$\\sigma_y$是材料的屈服强度。对于后续循环，只要当前裂纹尖端（长度为$a$）位于此过载塑性区内（即$a < a_{\\text{ol}} + r_{p,\\text{ol}}$），就应用延迟因子：\n$$\nf_{\\text{ret}} = \\left(\\frac{a_{\\text{ol}} + r_{p,\\text{ol}} - a}{r_{p,\\text{ol}}}\\right)^{\\gamma_{w}}\n$$\n其中给定的Wheeler指数为$\\gamma_w = 1.0$。如果裂纹已经扩展到过载塑性区之外（$a \\ge a_{\\text{ol}} + r_{p,\\text{ol}}$），则不发生延迟，且$f_{\\text{ret}} = 1$。最初，没有活动的过载。如果发生新的过载，其对应的$a_{\\text{ol}}$和$r_{p,\\text{ol}}$会覆盖任何先前的值。\n\n计算过程是在逐周期循环中直接实现这些步骤。\n\n1.  为每个测试用例初始化状态变量：当前裂纹长度$a \\leftarrow a_0$，以及过载参数$a_{\\text{ol}}$和$r_{p,\\text{ol}}$以指示无活动延迟。\n2.  遍历指定的加载块。对每个块，迭代指定的循环次数$N_i$。\n3.  在每个循环中，使用$a$的当前值和循环的加载参数（$\\sigma_{\\max}$, $R$）计算裂纹扩展增量$\\Delta a_{\\text{cycle}}$。\n4.  更新裂纹长度：$a \\leftarrow a + \\Delta a_{\\text{cycle}}$。\n5.  如果当前循环被指定为过载，其$K_{\\max}$被记录为$K_{\\max,\\text{ol}}$。计算新的过载塑性区尺寸$r_{p,\\text{ol}}$。根据问题的明确指示，过载裂纹长度$a_{\\text{ol}}$被设置为*新更新*的裂纹长度$a$。\n6.  在所有块中的所有循环完成后，总裂纹推进量计算为$\\Delta a = a_{\\text{final}} - a_0$。\n\n该算法被应用于三个测试用例中的每一个，使用它们各自的参数和加载谱。最终结果四舍五入到指定的$10^{-12}$米精度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the fatigue crack growth simulation for all test cases.\n    \"\"\"\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"W\": 0.10, \"a0\": 0.005, \"sigma_y\": 350,\n            \"C\": 2.0e-12, \"m\": 3.2,\n            \"spectrum\": [\n                (1000, 120, 0.10, False),\n                (1, 220, 0.10, True),\n                (2000, 120, 0.10, False),\n                (1000, 140, 0.30, False),\n            ]\n        },\n        {\n            \"W\": 0.08, \"a0\": 0.004, \"sigma_y\": 400,\n            \"C\": 1.5e-12, \"m\": 3.0,\n            \"spectrum\": [\n                (3000, 100, -0.30, False),\n                (1000, 140, 0.00, False),\n            ]\n        },\n        {\n            \"W\": 0.06, \"a0\": 0.020, \"sigma_y\": 500,\n            \"C\": 5.0e-13, \"m\": 3.5,\n            \"spectrum\": [\n                (800, 160, 0.40, False),\n                (1, 260, 0.40, True),\n                (1500, 160, 0.40, False),\n                (1, 300, 0.40, True),\n                (1000, 170, 0.40, False),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_a = run_simulation(case)\n        results.append(round(delta_a, 12))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(params):\n    \"\"\"\n    Performs the cycle-by-cycle fatigue crack growth simulation for a single test case.\n    \"\"\"\n    W = params[\"W\"]\n    a = params[\"a0\"]\n    a0 = params[\"a0\"]\n    sigma_y = params[\"sigma_y\"]\n    C = params[\"C\"]\n    m = params[\"m\"]\n    spectrum = params[\"spectrum\"]\n    gamma_w = 1.0\n\n    # Retardation state variables\n    a_ol = -1.0  # Crack length at last overload, initialized to indicate no overload\n    r_p_ol = 0.0   # Plastic zone size of last overload\n\n    for (N_cycles, sigma_max, R, is_ol_segment) in spectrum:\n        sigma_min = R * sigma_max\n        \n        for cycle in range(1, N_cycles + 1):\n            # 1. Geometry Factor Y(a/W)\n            x = a / W\n            Y = 1.12 - 0.231*x + 10.55*x**2 - 21.72*x**3 + 30.39*x**4\n            \n            # 2. Stress-Intensity Factor (SIF) calculations\n            K_max = Y * sigma_max * np.sqrt(np.pi * a)\n            delta_K = K_max * (1 - R)\n\n            # 3. Effective SIF range (Crack Closure)\n            R_clipped = np.clip(R, -1.0, 1.0)\n            phi_val = 0.825 - 0.34*R_clipped + 0.05*R_clipped**2\n            phi = np.clip(phi_val, 0.0, 1.0)\n            \n            if (1.0 - R) < 1e-9:\n                U = 1.0\n            else:\n                U = (1.0 - phi) / (1.0 - R)\n            U = np.clip(U, 0.0, 1.0)\n            \n            delta_K_eff = U * delta_K\n\n            # 4. Retardation Factor (Wheeler Model)\n            if a < a_ol + r_p_ol:\n                f_ret = ((a_ol + r_p_ol - a) / r_p_ol)**gamma_w\n                f_ret = max(0.0, f_ret)\n            else:\n                f_ret = 1.0\n\n            # 5. Crack growth increment\n            da = f_ret * C * (delta_K_eff**m)\n\n            # 6. Update crack length\n            a += da\n\n            # 7. Overload update logic\n            is_overload_cycle = (cycle == 1 and is_ol_segment)\n            if is_overload_cycle:\n                # Update retardation parameters based on this overload cycle\n                # Note: K_max_ol is the K_max calculated in this very cycle\n                K_max_ol = K_max\n                # Plane-stress monotonic plastic zone size\n                r_p_ol_new = (1.0 / (2.0 * np.pi)) * (K_max_ol / sigma_y)**2\n                # Overwrite old values\n                r_p_ol = r_p_ol_new\n                a_ol = a  # Use the *new* crack length as specified\n    \n    return a - a0\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2885943"}]}