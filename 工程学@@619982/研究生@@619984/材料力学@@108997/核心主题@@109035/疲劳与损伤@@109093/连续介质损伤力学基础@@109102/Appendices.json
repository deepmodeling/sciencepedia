{"hands_on_practices": [{"introduction": "损伤建模的关键第一步是选择一个合适的标量量度——即“等效应变”——来量化损伤的驱动力。不同的物理机制（例如，解理断裂与剪切滑移）会导致不同的数学表达形式。本练习探讨了两种基本的损伤萌生准则：一种基于最大主应变（Rankine型），另一种基于偏应变能（von Mises型），旨在揭示它们在相同的多轴应变状态下如何做出不同的响应。[@problem_id:2873780]", "problem": "一个各向同性、均匀的薄板在连续介质损伤力学 (CDM) 框架内，基于小应变运动学进行建模。考虑一个平面应变状态下的比例双轴拉伸，其主应变为 $ \\varepsilon_{1} = 0.020 $，$ \\varepsilon_{2} = 0.010 $ 和 $ \\varepsilon_{3} = 0 $。考虑两种用于触发损伤起始的常见标量应变度量：\n\n- 一种Rankine型度量，当最大拉伸主应变达到临界值时触发损伤。\n- 一种von Mises（第二偏不变量，常称为 $J_{2}$）度量，当由小应变张量的偏量部分构成的标量等效应变达到临界值时触发损伤。\n\n从小应变运动学和各向同性的基本原理出发，计算在给定状态下每种度量的标量等效应变，然后计算两者之差，定义为 $ \\Delta = \\varepsilon_{\\mathrm{VM}} - \\varepsilon_{\\mathrm{R}} $，其中 $ \\varepsilon_{\\mathrm{VM}} $ 是von Mises型等效应变，$ \\varepsilon_{\\mathrm{R}} $ 是Rankine型等效应变。将最终答案表示为一个无量纲小数，并四舍五入到四位有效数字。", "solution": "所述问题具有科学依据，提法恰当且客观。它基于连续介质力学的基本原理，并且可以直接根据所提供的信息求解。因此，将提供解答。\n\n应变状态由小应变张量 $\\boldsymbol{\\varepsilon}$ 的主分量给出。在主坐标系中，应变张量表示为对角矩阵：\n$$ \\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{1} & 0 & 0 \\\\ 0 & \\varepsilon_{2} & 0 \\\\ 0 & 0 & \\varepsilon_{3} \\end{pmatrix} $$\n给定值为 $\\varepsilon_{1} = 0.020$，$\\varepsilon_{2} = 0.010$ 和 $\\varepsilon_{3} = 0$。\n\n首先，我们确定Rankine型等效应变 $\\varepsilon_{\\mathrm{R}}$。该度量定义为最大拉伸主应变。对于给定的应变状态，主应变均为正值或零，因此它们都是拉伸或中性的。最大值为：\n$$ \\varepsilon_{\\mathrm{R}} = \\max(\\varepsilon_{1}, \\varepsilon_{2}, \\varepsilon_{3}) = \\max(0.020, 0.010, 0) $$\n$$ \\varepsilon_{\\mathrm{R}} = 0.020 $$\n\n接下来，我们确定von Mises型等效应变 $\\varepsilon_{\\mathrm{VM}}$。该度量由应变张量的偏量部分构建。应变张量 $\\boldsymbol{\\varepsilon}$ 可以分解为其体积（或静水）部分和偏量部分。体积应变 $\\varepsilon_{\\mathrm{v}}$ 是应变张量的迹：\n$$ \\varepsilon_{\\mathrm{v}} = \\mathrm{tr}(\\boldsymbol{\\varepsilon}) = \\varepsilon_{1} + \\varepsilon_{2} + \\varepsilon_{3} $$\n代入给定值：\n$$ \\varepsilon_{\\mathrm{v}} = 0.020 + 0.010 + 0 = 0.030 $$\n平均应变 $\\varepsilon_{\\mathrm{m}}$ 是体积应变的三分之一：\n$$ \\varepsilon_{\\mathrm{m}} = \\frac{1}{3} \\varepsilon_{\\mathrm{v}} = \\frac{1}{3} (0.030) = 0.010 $$\n偏应变张量 $\\mathbf{e}$ 定义为 $\\mathbf{e} = \\boldsymbol{\\varepsilon} - \\varepsilon_{\\mathrm{m}} \\mathbf{I}$，其中 $\\mathbf{I}$ 是二阶单位张量。偏应变张量的主分量 $e_i$ 为：\n$$ e_{1} = \\varepsilon_{1} - \\varepsilon_{\\mathrm{m}} = 0.020 - 0.010 = 0.010 $$\n$$ e_{2} = \\varepsilon_{2} - \\varepsilon_{\\mathrm{m}} = 0.010 - 0.010 = 0 $$\n$$ e_{3} = \\varepsilon_{3} - \\varepsilon_{\\mathrm{m}} = 0 - 0.010 = -0.010 $$\n\nvon Mises型等效应变是基于偏应变张量的第二不变量 $J_{2}$ 定义的。不变量 $J_{2}$ 定义为：\n$$ J_{2} = \\frac{1}{2} e_{ij} e_{ji} = \\frac{1}{2} (e_{1}^{2} + e_{2}^{2} + e_{3}^{2}) $$\n代入主偏应变：\n$$ J_{2} = \\frac{1}{2} \\left[ (0.010)^{2} + (0)^{2} + (-0.010)^{2} \\right] = \\frac{1}{2} (0.0001 + 0 + 0.0001) = 0.0001 $$\nvon Mises等效应变的标准定义（在不可压缩塑性流动下与von Mises应力功共轭）是：\n$$ \\varepsilon_{\\mathrm{VM}} = \\sqrt{\\frac{4}{3} J_{2}} $$\n或者，这可以直接用主应变表示：\n$$ \\varepsilon_{\\mathrm{VM}} = \\frac{\\sqrt{2}}{3} \\sqrt{(\\varepsilon_{1} - \\varepsilon_{2})^{2} + (\\varepsilon_{2} - \\varepsilon_{3})^{2} + (\\varepsilon_{3} - \\varepsilon_{1})^{2}} $$\n使用计算出的 $J_{2}$ 值：\n$$ \\varepsilon_{\\mathrm{VM}} = \\sqrt{\\frac{4}{3} (0.0001)} = \\sqrt{\\frac{0.0004}{3}} = \\frac{\\sqrt{0.0004}}{\\sqrt{3}} = \\frac{0.02}{\\sqrt{3}} $$\n其数值约为 $\\varepsilon_{\\mathrm{VM}} \\approx 0.011547$。\n\n最后，我们计算差值 $\\Delta = \\varepsilon_{\\mathrm{VM}} - \\varepsilon_{\\mathrm{R}}$：\n$$ \\Delta = \\frac{0.02}{\\sqrt{3}} - 0.020 = 0.020 \\left( \\frac{1}{\\sqrt{3}} - 1 \\right) $$\n计算其数值：\n$$ \\Delta \\approx 0.011547 - 0.020 = -0.008453 $$\n题目要求答案四舍五入到四位有效数字。计算值为 $\\Delta \\approx -0.00845299...$。第一个有效数字是 $8$。四舍五入到四位有效数字得到 $-0.008453$。", "answer": "$$\n\\boxed{-0.008453}\n$$", "id": "2873780"}, {"introduction": "一个具有预测能力的损伤模型的优劣取决于其模型参数，而这些参数必须通过实验数据进行标定。本实践将从理论概念转向计算材料科学中的一项核心任务：参数辨识。你将通过实现一个最小二乘拟合程序，直接从一组应力-应变测量数据中，确定指数软化本构律的参数，该本构律描述了材料在达到强度峰值后其承载能力如何退化。[@problem_id:2873718]", "problem": "考虑一个用于单轴拉伸试验的小应变、标量各向同性的连续介质损伤力学（CDM）模型。根据应变等效性假说，名义柯西应力 $\\,\\sigma\\,$ 通过损伤变量 $\\,D \\in [0,1]\\,$ 与应变 $\\,\\varepsilon\\,$ 相关，其关系如下\n$$\n\\sigma = \\left(1 - D\\right) E \\varepsilon,\n$$\n其中 $\\,E\\,$ 是杨氏模量。在准脆性材料的峰后拉伸软化阶段，假设名义应力遵循一个由两个正应变 $\\,\\varepsilon_0\\,$ 和 $\\,\\varepsilon_f\\,$（满足 $\\,\\varepsilon_f > \\varepsilon_0\\,$）参数化的指数衰减规律，即\n$$\n\\sigma_{\\mathrm{model}}(\\varepsilon; \\varepsilon_0,\\varepsilon_f) = E \\, \\varepsilon_0 \\, \\exp\\!\\left(-\\frac{\\varepsilon - \\varepsilon_0}{\\varepsilon_f - \\varepsilon_0}\\right),\n\\quad \\text{for } \\varepsilon \\ge \\varepsilon_0,\n$$\n该定律确保了在软化起始点 $\\,\\varepsilon=\\varepsilon_0\\,$ 处的连续性，此处 $\\,\\sigma_{\\mathrm{model}}(\\varepsilon_0; \\varepsilon_0,\\varepsilon_f) = E \\varepsilon_0\\,$，并定义了一个由 $\\,\\varepsilon_f - \\varepsilon_0\\,$ 控制的特征衰减长度。本问题中所有给定数据均处于峰后软化阶段，即 $\\,\\varepsilon_i \\ge \\varepsilon_0\\,$。\n\n标定任务。给定一组测量的单轴软化数据 $\\{(\\varepsilon_i,\\sigma_i)\\}_{i=1}^n$ 和一个已知的模量 $\\,E\\,$，通过最小化测量应力与模型应力之间的残差平方和来确定参数 $\\,\\varepsilon_0\\,$ 和 $\\,\\varepsilon_f\\,$：\n$$\n\\min_{\\varepsilon_0,\\varepsilon_f} \\; J(\\varepsilon_0,\\varepsilon_f) \n= \\sum_{i=1}^{n} \\left[\\sigma_{\\mathrm{model}}(\\varepsilon_i; \\varepsilon_0,\\varepsilon_f) - \\sigma_i \\right]^2\n\\quad \\text{约束条件为} \\quad \\varepsilon_0 > 0,\\; \\varepsilon_f > \\varepsilon_0.\n$$\n\n单位与报告。应变 $\\,\\varepsilon\\,$ 是无量纲的。应力 $\\,\\sigma\\,$ 和模量 $\\,E\\,$ 的单位是帕斯卡 $\\,(\\mathrm{Pa})\\,$。您的程序必须为每个测试用例计算 $\\,\\varepsilon_0\\,$ 和 $\\,\\varepsilon_f\\,$，并将它们作为无量纲十进制数输出。在最终输出格式中，将报告的每个参数四舍五入至最多 $\\,8\\,$ 位有效数字。\n\n测试套件。对于下文的每个用例，请使用所提供的杨氏模量 $\\,E\\,$ 和测量数据对 $\\{(\\varepsilon_i,\\sigma_i)\\}$，其中所有 $\\,\\sigma_i\\,$ 的单位为 $\\,\\mathrm{Pa}\\,$，所有 $\\,\\varepsilon_i\\,$ 均为无量纲。每个用例仅包含峰后数据。\n\n- 用例 A (理想路径，中等软化范围)：\n  - 模量：$\\,E = 5.0 \\times 10^{10}\\,\\mathrm{Pa}\\,$。\n  - 数据（$(\\varepsilon,\\sigma)$ 对）：\n    - $\\,\\left(0.0002,\\,10000000.0\\right)\\,$,\n    - $\\,\\left(0.0004,\\,8187307.530779818\\right)\\,$,\n    - $\\,\\left(0.0006,\\,6703200.460356393\\right)\\,$,\n    - $\\,\\left(0.0009,\\,4965853.037914095\\right)\\,$,\n    - $\\,\\left(0.0012,\\,3678794.411714423\\right)\\,$,\n    - $\\,\\left(0.0016,\\,2465969.639416065\\right)\\,$,\n    - $\\,\\left(0.0020,\\,1652988.8822158656\\right)\\,$。\n\n- 用例 B (类边界情况，急剧软化且特征范围短)：\n  - 模量：$\\,E = 5.0 \\times 10^{10}\\,\\mathrm{Pa}\\,$。\n  - 数据（$(\\varepsilon,\\sigma)$ 对）：\n    - $\\,\\left(0.00015,\\,7500000.0\\right)\\,$,\n    - $\\,\\left(0.00018,\\,5556136.655112884\\right)\\,$,\n    - $\\,\\left(0.00020,\\,4548979.94784475\\right)\\,$,\n    - $\\,\\left(0.00023,\\,3369967.2308791618\\right)\\,$,\n    - $\\,\\left(0.00025,\\,2759095.8087858175\\right)\\,$,\n    - $\\,\\left(0.00028,\\,2043988.4477550946\\right)\\,$,\n    - $\\,\\left(0.00032,\\,1370126.43039551\\right)\\,$。\n\n- 用例 C (边缘情况，软化范围宽且长尾)：\n  - 模量：$\\,E = 5.0 \\times 10^{10}\\,\\mathrm{Pa}\\,$。\n  - 数据（$(\\varepsilon,\\sigma)$ 对）：\n    - $\\,\\left(0.00010,\\,5000000.0\\right)\\,$,\n    - $\\,\\left(0.000825,\\,3894003.9153570245\\right)\\,$,\n    - $\\,\\left(0.00155,\\,3032653.298563167\\right)\\,$,\n    - $\\,\\left(0.002275,\\,2361832.7637050735\\right)\\,$,\n    - $\\,\\left(0.00300,\\,1839397.2058572115\\right)\\,$,\n    - $\\,\\left(0.003725,\\,1432523.9843009505\\right)\\,$,\n    - $\\,\\left(0.005175,\\,868869.7172522257\\right)\\,$。\n\n程序要求。\n- 实现一个求解器，用于计算使所述最小二乘目标函数最小化的参数对 $\\,(\\varepsilon_0,\\varepsilon_f)\\,$，并满足严格不等式 $\\,\\varepsilon_0 > 0\\,$ 和 $\\,\\varepsilon_f > \\varepsilon_0\\,$。这些不等式必须在数值上强制执行；例如，可以通过保证正定性和顺序的参数变换来实现。\n- 最终的程序输出应为单行，包含一个有三个条目的列表，每个条目对应一个测试用例。每个条目本身是一个列表 $[\\varepsilon_0,\\varepsilon_f]$，格式化为不含空格，且每个浮点数四舍五入至最多 $\\,8\\,$ 位有效数字。例如：$\\,\\left[[\\varepsilon_{0,A},\\varepsilon_{f,A}],[\\varepsilon_{0,B},\\varepsilon_{f,B}],[\\varepsilon_{0,C},\\varepsilon_{f,C}]\\right]\\,$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的结果，形式为逗号分隔的列表（例如， \"[[resultA0,resultAf],[resultB0,resultBf],[resultC0,resultCf]]\"）。", "solution": "所提出的问题是连续介质损伤力学框架内的一个参数辨识任务。它要求确定两个模型参数：软化起始应变 $\\varepsilon_0$ 和控制软化衰减的特征应变 $\\varepsilon_f$。这些参数需要通过最小化理论应力-应变模型与一组实验数据点之间的差异来标定。这是一个标准的非线性最小二乘优化问题。\n\n待最小化的函数代表残差平方和，由 $J(\\varepsilon_0, \\varepsilon_f)$ 给出：\n$$\nJ(\\varepsilon_0, \\varepsilon_f) = \\sum_{i=1}^{n} \\left[ \\sigma_{\\mathrm{model}}(\\varepsilon_i; \\varepsilon_0, \\varepsilon_f) - \\sigma_i \\right]^2\n$$\n在给定应变 $\\varepsilon_i$ 下，模型预测的应力 $\\sigma_{\\mathrm{model}}$ 由指数软化定律定义：\n$$\n\\sigma_{\\mathrm{model}}(\\varepsilon_i; \\varepsilon_0, \\varepsilon_f) = E \\, \\varepsilon_0 \\, \\exp\\left(-\\frac{\\varepsilon_i - \\varepsilon_0}{\\varepsilon_f - \\varepsilon_0}\\right)\n$$\n此处，$E$ 是杨氏模量，$\\{\\sigma_i, \\varepsilon_i\\}$ 是测量的应力-应变对。\n\n此优化必须遵循物理约束。参数必须为正，且软化必须在其起始点之后发生，这施加了严格不等式 $\\varepsilon_0 > 0$ 和 $\\varepsilon_f > \\varepsilon_0$。此外，问题说明给定的数据位于峰后软化阶段，意味着对所有数据点 $i$，有 $\\varepsilon_i \\ge \\varepsilon_0$。这为 $\\varepsilon_0$ 的搜索空间施加了一个关键的上限：\n$$\n\\varepsilon_0 \\le \\min_{i} \\{\\varepsilon_i\\}\n$$\n\n为了便于进行稳健的数值求解，我们进行变量替换。定义一个新的参数向量 $\\boldsymbol{p} = [p_0, p_1]$，使得：\n$$\np_0 = \\varepsilon_0\n$$\n$$\np_1 = \\varepsilon_f - \\varepsilon_0\n$$\n就这些新变量而言，约束条件变得更加直接。$\\varepsilon_0 > 0$ 的条件转化为 $p_0 > 0$。$\\varepsilon_f > \\varepsilon_0$ 的条件意味着 $p_0 + p_1 > p_0$，可简化为 $p_1 > 0$。$\\varepsilon_0 \\le \\min_{i} \\{\\varepsilon_i\\}$ 的条件变为 $p_0 \\le \\min_{i} \\{\\varepsilon_i\\}$。\n\n现在，优化问题可以重新表述为，最小化关于 $p_0$ 和 $p_1$ 的目标函数 $J(p_0, p_1)$：\n$$\nJ(p_0, p_1) = \\sum_{i=1}^{n} \\left[ E \\, p_0 \\, \\exp\\left(-\\frac{\\varepsilon_i - p_0}{p_1}\\right) - \\sigma_i \\right]^2\n$$\n并服从于简单的箱型约束：\n$$\n0 < p_0 \\le \\min_{i}\\{\\varepsilon_i\\}\n$$\n$$\np_1 > 0\n$$\n这种结构非常适合支持边界约束的数值求解器，例如 L-BFGS-B（带边界的有限内存 Broyden–Fletcher–Goldfarb–Shanno 算法）方法。该算法在 Python 的 `scipy.optimize.minimize` 函数中得以实现。\n\n解决方案将按如下方式实现：\n$1$. 对于每个测试用例，使用提供的材料模量 $E$ 和实验数据 $\\{\\varepsilon_i, \\sigma_i\\}$ 来定义目标函数 $J(p_0, p_1)$。\n$2$. 设置优化变量的边界。对于 $p_0$，边界为 $(0, \\min_i\\{\\varepsilon_i\\}]$；对于 $p_1$，下界为 $0$。在数值实践中，下界会使用一个很小的正值（例如 $10^{-15}$）来确保其严格为正。\n$3$. 需要为 $(p_0, p_1)$ 提供一个初始猜测值以启动迭代优化过程。对于初始 $p_0$，一个合理的选择是其可行范围内的一个值，例如 $0.9 \\times \\min_i\\{\\varepsilon_i\\}$。对于代表软化曲线特征宽度的 $p_1$，数据的应变范围 $\\max_i\\{\\varepsilon_i\\} - \\min_i\\{\\varepsilon_i\\}$ 是一个合理的起始估计。\n$4$. 然后采用 L-BFGS-B 算法来寻找最小化目标函数的最优参数集 $(p_{0,\\mathrm{opt}}, p_{1,\\mathrm{opt}})$。\n$5$. 最后，将这些最优参数转换回具有物理意义的参数 $\\varepsilon_0$ 和 $\\varepsilon_f$：\n$$\n\\varepsilon_{0,\\mathrm{opt}} = p_{0,\\mathrm{opt}}\n$$\n$$\n\\varepsilon_{f,\\mathrm{opt}} = p_{0,\\mathrm{opt}} + p_{1,\\mathrm{opt}}\n$$\n计算出的值随后按最终输出要求格式化为最多8位有效数字。鉴于所提供的数据是无噪声的，并且对于特定参数能与模型完美匹配，预计优化将得到一个有效值为零的最小目标函数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves for the optimal damage model parameters e0 and ef for three test cases\n    by minimizing the sum of squared residuals.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"E\": 5.0e10,\n            \"data\": np.array([\n                (0.0002, 10000000.0),\n                (0.0004, 8187307.530779818),\n                (0.0006, 6703200.460356393),\n                (0.0009, 4965853.037914095),\n                (0.0012, 3678794.411714423),\n                (0.0016, 2465969.639416065),\n                (0.0020, 1652988.8822158656),\n            ])\n        },\n        {\n            \"E\": 5.0e10,\n            \"data\": np.array([\n                (0.00015, 7500000.0),\n                (0.00018, 5556136.655112884),\n                (0.00020, 4548979.94784475),\n                (0.00023, 3369967.2308791618),\n                (0.00025, 2759095.8087858175),\n                (0.00028, 2043988.4477550946),\n                (0.00032, 1370126.43039551),\n            ])\n        },\n        {\n            \"E\": 5.0e10,\n            \"data\": np.array([\n                (0.00010, 5000000.0),\n                (0.000825, 3894003.9153570245),\n                (0.00155, 3032653.298563167),\n                (0.002275, 2361832.7637050735),\n                (0.00300, 1839397.2058572115),\n                (0.003725, 1432523.9843009505),\n                (0.005175, 868869.7172522257),\n            ])\n        }\n    ]\n    \n    # Objective function to minimize (sum of squared residuals)\n    def objective_function(p, E, eps_data, sig_data):\n        \"\"\"\n        Calculates the sum of squared residuals for the given parameters.\n        p[0] = e0\n        p[1] = ef - e0\n        \"\"\"\n        p0, p1 = p\n        # The term (eps_data - p0) is guaranteed non-negative by the bounds\n        # The term p1 is guaranteed positive by the bounds\n        # This prevents numerical issues like division by zero or log of negative number\n        sigma_model = E * p0 * np.exp(-(eps_data - p0) / p1)\n        residuals = sigma_model - sig_data\n        return np.sum(residuals**2)\n\n    all_results = []\n    \n    for case in test_cases:\n        E = case[\"E\"]\n        data = case[\"data\"]\n        eps_data = data[:, 0]\n        sig_data = data[:, 1]\n        \n        eps_min = np.min(eps_data)\n        eps_max = np.max(eps_data)\n        \n        # Bounds for the optimization variables [p0, p1]\n        # p0 = e0, so 0  p0 = eps_min\n        # p1 = ef - e0, so p1 > 0\n        bounds = ((1e-15, eps_min), (1e-15, np.inf))\n        \n        # Initial guess for the optimizer\n        # A good guess helps convergence, especially for non-convex problems\n        p0_guess = 0.9 * eps_min\n        p1_guess = eps_max - eps_min\n        initial_guess = [p0_guess, p1_guess]\n        \n        # Perform the optimization using L-BFGS-B which supports bounds\n        result = minimize(\n            objective_function,\n            initial_guess,\n            args=(E, eps_data, sig_data),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        p0_opt, p1_opt = result.x\n        \n        # Convert back to the original parameters e0 and ef\n        e0 = p0_opt\n        ef = p0_opt + p1_opt\n        \n        all_results.append([e0, ef])\n\n    # Format the results into the required string format\n    output_parts = []\n    for res_pair in all_results:\n        e0, ef = res_pair\n        # Format each number to at most 8 significant digits using '.8g'\n        s_e0 = format(e0, '.8g')\n        s_ef = format(ef, '.8g')\n        output_parts.append(f\"[{s_e0},{s_ef}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2873718"}, {"introduction": "为了模拟损伤如何随时间或加载累积，我们必须对其演化方程进行积分。本练习聚焦于计算力学中的一项基本数值技术：后向欧拉法。你将为一个率相关的损伤变量$D$推导并实现一个鲁棒的更新算法，并在此过程中学习如何处理对于保证物理真实性至关重要的不可逆性（$D_{n+1} \\ge D_n$）和饱和（$D_{n+1} \\le 1$）约束。[@problem_id:2873731]", "problem": "在连续介质损伤力学中，考虑一个标准的标量各向同性损伤变量 $D \\in [0,1]$，其演化规律由一个非负驱动函数控制。设其演化由以下率方程指定\n$$\\dot{D} = \\lambda \\langle \\tilde{\\varepsilon} - \\kappa \\rangle_+,$$\n其中 $\\lambda \\gt 0$ 是一个材料参数，$\\kappa \\ge 0$ 是一个常数阈值，$\\tilde{\\varepsilon}$ 是当前时刻一个已知的等效类应变驱动量（在步长级别上作为给定数据处理），$\\langle x \\rangle_+ = \\max(x,0)$ 表示 Macaulay 括号。假设满足热力学不可逆性 $D_{n+1} \\ge D_n$ 和界限 $D_{n+1} \\le 1$。所有量均为无量纲。\n\n仅从损伤率方程的定义、Macaulay 括号和标准的隐式时间离散化出发，完成以下任务：\n\n1) 在从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$、步长为 $\\Delta t \\gt 0$ 的时间步上，推导后向欧拉（Backward Euler (BE)）全隐式时间离散格式，得出一个在解处必须为零的标量非线性局部残差 $R(D_{n+1})$。\n\n2) 利用 Macaulay 括号的定义以及不可逆性和界限约束，确定 $R(D_{n+1})$ 的激活集结构，并推导一个关于 $D_n$、$\\Delta t$、$\\lambda$、$\\kappa$ 和给定的 $\\tilde{\\varepsilon}_{n+1}$ 的鲁棒局部更新算法。你的更新必须强制满足 $D_{n+1} \\in [D_n,1]$。\n\n3) 在适用情况下，给出残差关于 $D_{n+1}$ 的标量导数（在一致算法切线的意义上），并明确说明在哪些情况下由于激活约束，该导数未定义或不需要。\n\n将得到的局部更新算法在一个程序中实现。对于每个测试用例，该程序返回更新后的损伤值 $D_{n+1}$。将所有变量视为无量纲标量。不要使用任何外部输入；程序必须为以下六个测试用例计算并打印答案，每个用例以 $(D_n,\\Delta t,\\lambda,\\kappa,\\tilde{\\varepsilon}_{n+1})$ 的形式给出：\n\n- 情况 A (理想路径，激活演化)： (0.2, 0.1, 5.0, 0.01, 0.05)。\n- 情况 B (未激活，低于阈值)： (0.6, 0.5, 10.0, 0.2, 0.1)。\n- 情况 C (激活边界，恰好在阈值处)： (0.3, 1.0, 3.0, 0.15, 0.15)。\n- 情况 D (达到上界饱和)： (0.95, 1.0, 2.0, 0.1, 0.8)。\n- 情况 E (刚性时间尺度和小编驱动，检查数值缩放)： (0.0, 1.0e-6, 1.0e6, 0.0, 1.0e-3)。\n- 情况 F (卸载下的不可逆性)： (0.7, 1.0, 1.0, 1.0, 0.9)。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\"[r_1,r_2,\\dots]\"$），其中每个条目是按 A、B、C、D、E、F 顺序对应的测试用例计算出的 $D_{n+1}$。每个条目必须是十进制数。由于所有量都是无量纲的，因此不需要物理单位。程序必须完全自包含，并能在指定环境中按原样运行。", "solution": "所提出的问题是计算非弹性力学中一个标准的、适定的练习，具体涉及一个简单的率相关各向同性损伤模型的数值积分。任务是推导并实现一个鲁棒的局部更新算法，在此背景下即为返回映射算法。推导从时间离散化和约束优化的第一性原理出发。\n\n该问题经检验具有科学依据、问题适定且客观。它不包含任何不一致或模糊之处。所有必要的数据均已提供。我们着手进行求解。\n\n主要步骤是：1) 演化方程的时间离散化；2) 通过分析约束问题的 Kuhn-Tucker 条件推导闭式更新；3) 推导一致算法切线，以用于基于 Newton-Raphson 的隐式有限元代码中。\n\n**1. 后向欧拉离散化和局部残差**\n\n损伤变量 $D$ 的演化由以下一阶常微分方程控制：\n$$\n\\dot{D} = \\lambda \\langle \\tilde{\\varepsilon} - \\kappa \\rangle_+\n$$\n其中 $\\dot{D} = \\frac{dD}{dt}$，$\\lambda  0$ 是一个流动性参数，$\\kappa \\ge 0$ 是损伤激活的静态阈值，$\\tilde{\\varepsilon}$ 是驱动损伤过程的等效应变，$\\langle x \\rangle_+ = \\max(x, 0)$ 是 Macaulay 括号，它强制了损伤率的非负性。\n\n我们对时间区间 $[t_n, t_{n+1}]$ 进行时间离散化，其中 $\\Delta t = t_{n+1} - t_n$ 是时间步长。使用一阶全隐式后向欧拉 (BE) 格式，时间 $t_{n+1}$ 处的导数 $\\dot{D}$ 近似为：\n$$\n\\dot{D}(t_{n+1}) \\approx \\frac{D(t_{n+1}) - D(t_n)}{\\Delta t} = \\frac{D_{n+1} - D_n}{\\Delta t}\n$$\n在全隐式格式中，演化律的右侧也在时间 $t_{n+1}$ 进行求值：\n$$\n\\lambda \\langle \\tilde{\\varepsilon}(t_{n+1}) - \\kappa \\rangle_+ = \\lambda \\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+\n$$\n将这两个表达式相等，得到离散演化方程：\n$$\n\\frac{D_{n+1} - D_n}{\\Delta t} = \\lambda \\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+\n$$\n至关重要的是，问题指定 $\\tilde{\\varepsilon}_{n+1}$ 是步长级别的给定数量，与未知的 $D_{n+1}$ 无关。这极大地简化了问题，因为它将损伤更新与其他场变量解耦。\n\n局部残差 $R(D_{n+1})$ 是在解处必须等于零的函数。通常从离散演化方程定义它：\n$$\nR(D_{n+1}) = D_{n+1} - D_n - \\Delta t \\lambda \\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+\n$$\n求解 $D_{n+1}$ 需要求解由方程 $R(D_{n+1}) = 0$ 以及不可逆性约束 $D_{n+1} \\ge D_n$ 和饱和约束 $D_{n+1} \\le 1$ 组成的系统。\n\n**2. 激活集结构和鲁棒更新算法**\n\n寻找 $D_{n+1}$ 是一个约束优化问题。其解由 Karush-Kuhn-Tucker (KKT) 条件决定。让我们定义一个试探值 $D_{n+1}^{\\text{trial}}$，作为无约束方程 $R(D_{n+1}) = 0$ 的解：\n$$\nD_{n+1}^{\\text{trial}} = D_n + \\Delta t \\lambda \\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+\n$$\n最终解 $D_{n+1}$ 是此试探状态在容许区间 $[D_n, 1]$ 上的投影。激活集分析揭示了解的结构。\n\n有两个主要条件需要检查：损伤激活和损伤饱和。\n\n情况 1：未激活状态（相对于损伤的弹性行为）。\n当驱动力不超过阈值时发生：$\\tilde{\\varepsilon}_{n+1} \\le \\kappa$。\n在这种情况下，Macaulay 括号求值为零：$\\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+ = 0$。\n试探值变为：\n$$\nD_{n+1}^{\\text{trial}} = D_n + 0 = D_n\n$$\n该值自然满足两个约束：$D_n \\ge D_n$ 和 $D_n \\le 1$（因为 $D_n$ 是上一步的有效状态）。因此更新为：\n$$\nD_{n+1} = D_n \\quad \\text{if} \\quad \\tilde{\\varepsilon}_{n+1} \\le \\kappa\n$$\n\n情况 2：激活状态（损伤演化）。\n当驱动力超过阈值时发生：$\\tilde{\\varepsilon}_{n+1}  \\kappa$。\nMacaulay 括号被激活：$\\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+ = \\tilde{\\varepsilon}_{n+1} - \\kappa  0$。\n试探值为：\n$$\nD_{n+1}^{\\text{trial}} = D_n + \\Delta t \\lambda (\\tilde{\\varepsilon}_{n+1} - \\kappa)\n$$\n由于 $\\Delta t  0$, $\\lambda  0$, 且 $(\\tilde{\\varepsilon}_{n+1} - \\kappa)  0$，可以保证 $D_{n+1}^{\\text{trial}}  D_n$。不可逆性约束 $D_{n+1} \\ge D_n$ 自动满足。我们只需要强制饱和约束 $D_{n+1} \\le 1$。\n\n这导致两种子情况：\n\n子情况 2a：激活，非饱和。\n如果 $D_{n+1}^{\\text{trial}} \\le 1$，则试探值是容许的。更新为：\n$$\nD_{n+1} = D_{n+1}^{\\text{trial}}\n$$\n\n子情况 2b：激活，饱和。\n如果 $D_{n+1}^{\\text{trial}}  1$，则试探值违反了饱和极限。损伤被约束到其最大可能值。更新为：\n$$\nD_{n+1} = 1\n$$\n\n将所有情况结合起来，得到一个单一、鲁棒、闭式的更新算法。$D_{n+1}$ 的值是试探状态在容许区间 $[D_n, 1]$ 上的投影。由于 $D_{n+1}^{\\text{trial}} \\ge D_n$ 恒成立，这个投影简化为取与上界 $1$ 的最小值：\n$$\nD_{n+1} = \\min\\left(1, D_{n+1}^{\\text{trial}}\\right)\n$$\n代入 $D_{n+1}^{\\text{trial}}$ 的表达式，得到完整的更新规则：\n$$\nD_{n+1} = \\min\\left(1, D_n + \\Delta t \\lambda \\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+\\right)\n$$\n\n**3. 算法切线**\n\n算法切线是残差方程关于未知变量的导数，在这里是 $\\frac{\\partial R}{\\partial D_{n+1}}$。这个量对于在隐式有限元方法中使用的 Newton-Raphson 求解器至关重要，用于求解像 $D_{n+1}$ 这样的材料状态变量与其他场（例如位移）耦合的全局方程组。\n\n残差为 $R(D_{n+1}) = D_{n+1} - D_n - \\Delta t \\lambda \\langle \\tilde{\\varepsilon}_{n+1} - \\kappa \\rangle_+$。\n根据问题陈述，$\\tilde{\\varepsilon}_{n+1}$ 是给定数据，不是 $D_{n+1}$ 的函数。因此，残差表达式中跟随 $D_{n+1}$ 的整个项相对于 $D_{n+1}$ 是常数。\n\n切线导数的适用性取决于激活集。\n\n情况 1：激活、非饱和状态（$\\tilde{\\varepsilon}_{n+1}  \\kappa$ 且 $D_{n+1}^{\\text{trial}}  1$）。\n在这种情况下，解 $D_{n+1}$ 是通过求解无约束残差方程得到的。Macaulay 括号被解析为 $(\\tilde{\\varepsilon}_{n+1} - \\kappa)$。实际求解的残差为：\n$$\nR(D_{n+1}) = D_{n+1} - D_n - \\Delta t \\lambda (\\tilde{\\varepsilon}_{n+1} - \\kappa) = 0\n$$\n一致算法切线是该表达式关于 $D_{n+1}$ 的导数：\n$$\nK_T = \\frac{\\partial R}{\\partial D_{n+1}} = 1\n$$\n这是唯一需要切线且在 Newton-Raphson 方案中具有非平凡意义的情况。值为 $1$ 表明在这个特定公式中，关于 $D_{n+1}$ 的方程是线性和解耦的。\n\n情况 2：未激活或饱和状态。\n如果 $\\tilde{\\varepsilon}_{n+1} \\le \\kappa$，解由约束 $D_{n+1} = D_n$ 固定。\n如果 $\\tilde{\\varepsilon}_{n+1}  \\kappa$ 但试探状态导致饱和，解由约束 $D_{n+1} = 1$ 固定。\n在这两种情况下，$D_{n+1}$ 都不是通过对残差 $R(D_{n+1})$ 进行求根来求解的自由变量。相反，它是由一个已激活的不等式约束确定的。在数值求解器中，这个自由度将从方程组中移除。因此，对于这些情况，算法切线没有定义，或者更准确地说，是不需要的，因为变量是被指定的。\n\n总之，残差的导数是 $1$，但仅在激活、非饱和区域有意义。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the updated damage variable D_{n+1} for a set of test cases\n    based on a rate-dependent isotropic damage model.\n    \"\"\"\n\n    # Test cases are given as tuples: (D_n, delta_t, lambda, kappa, eps_tilde_np1)\n    test_cases = [\n        # Case A (happy path, active evolution)\n        (0.2, 0.1, 5.0, 0.01, 0.05),\n        # Case B (inactive, below threshold)\n        (0.6, 0.5, 10.0, 0.2, 0.1),\n        # Case C (boundary of activation, exactly at threshold)\n        (0.3, 1.0, 3.0, 0.15, 0.15),\n        # Case D (saturation to the upper bound)\n        (0.95, 1.0, 2.0, 0.1, 0.8),\n        # Case E (stiff time scale and small driving)\n        (0.0, 1.0e-6, 1.0e6, 0.0, 1.0e-3),\n        # Case F (irreversibility under unloading)\n        (0.7, 1.0, 1.0, 1.0, 0.9),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        D_n, delta_t, lam, kappa, eps_tilde_np1 = case\n\n        # The core of the update algorithm is derived from the backward Euler\n        # discretization and application of irreversibility and saturation constraints.\n        # The evolution law is: dot(D) = lambda * eps_tilde - kappa_+\n        # Discretized form: (D_{n+1} - D_n) / delta_t = lambda * eps_tilde_{n+1} - kappa_+\n        # This gives a trial value for D_{n+1}:\n        # D_trial_{n+1} = D_n + delta_t * lambda * eps_tilde_{n+1} - kappa_+\n        \n        # The Macaulay bracket x_+ is implemented as max(0, x).\n        driving_force = eps_tilde_np1 - kappa\n        macaulay_term = max(0.0, driving_force)\n        \n        # Calculate the trial damage value for the next step.\n        D_np1_trial = D_n + delta_t * lam * macaulay_term\n        \n        # The final damage value D_{n+1} must be in the interval [D_n, 1].\n        # The formulation of D_np1_trial ensures D_np1_trial = D_n automatically.\n        # We only need to enforce the saturation constraint D_{n+1} = 1.\n        D_np1 = min(1.0, D_np1_trial)\n        \n        results.append(D_np1)\n\n    # Format the results as a comma-separated list in brackets, as specified.\n    # Using a general format specifier to handle floating point numbers cleanly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2873731"}]}