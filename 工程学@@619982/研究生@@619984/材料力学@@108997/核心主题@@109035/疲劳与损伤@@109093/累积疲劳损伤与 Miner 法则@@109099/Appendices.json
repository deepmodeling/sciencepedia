{"hands_on_practices": [{"introduction": "这第一个练习提供了一个基础的起点，重点在于Palmgren-Miner法则的直接应用。通过计算一个承受简单两步加载块的构件的累积损伤和剩余寿命，你将掌握基础疲劳评估所需的核心计算技能。这个实践旨在巩固线性损伤累积的概念。[@problem_id:2628832]", "problem": "一个由高强度钢制成的金属试样，在全反向应力比 $R=-1$ 的条件下，承受两阶段块状加载。其在高周疲劳区的应力-寿命 ($S$–$N$) 行为由经验性的 Basquin 型关系式表征，其常用对数形式为\n$$\n\\log_{10} N = a - b \\log_{10} S_a,\n$$\n该关系式适用于以 $\\mathrm{MPa}$ 为单位的应力幅 $S_a$ 和以周为单位的疲劳寿命 $N$。对于这种钢，常数为 $a=12$ 和 $b=3$。试样经历以下块状加载历史：\n- 第一阶段：在应力幅 $S_{a1}=300\\,\\mathrm{MPa}$ 下加载 $n_1=1.0\\times 10^4$ 周。\n- 第二阶段：在应力幅 $S_{a2}=150\\,\\mathrm{MPa}$ 下加载 $n_2=5.0\\times 10^4$ 周。\n\n假设在等幅加载段下疲劳损伤是线性累积的，并且破坏由达到临界损伤值定义，计算这两个阶段加载后的累积损伤 $D$。然后，在第二个应力幅 $S_{a2}$ 下继续加载，确定达到破坏准则所需的额外循环次数 $\\Delta n$。将 $D$ 和 $\\Delta n$ 的结果均四舍五入至三位有效数字。以周为单位表示额外循环次数。最终答案必须是一个单行矩阵，按顺序包含 $D$ 和 $\\Delta n$。", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **材料行为**：应力-寿命 ($S$–$N$) 关系由 Basquin 型关系式给出：$\\log_{10} N = a - b \\log_{10} S_a$。\n- **材料常数**：$a=12$，$b=3$。\n- **单位**：应力幅 $S_a$ 的单位是 $\\mathrm{MPa}$，疲劳寿命 $N$ 的单位是周。\n- **加载条件**：全反向应力比，$R=-1$。\n- **加载历史**：\n    - 阶段 1：在应力幅 $S_{a1}=300\\,\\mathrm{MPa}$ 下加载 $n_1=1.0\\times 10^4$ 周。\n    - 阶段 2：在应力幅 $S_{a2}=150\\,\\mathrm{MPa}$ 下加载 $n_2=5.0\\times 10^4$ 周。\n- **损伤模型**：假设为线性累积疲劳损伤（Palmgren-Miner 法则）。\n- **破坏准则**：当累积损伤 $D$ 达到临界值时发生破坏，对于标准的 Palmgren-Miner 法则，该临界值默认为 $1$。\n- **要求输出**：\n    1.  两个加载阶段后的累积损伤 $D$。\n    2.  在应力幅 $S_{a2}$ 下导致破坏所需的额外循环次数 $\\Delta n$。\n- **格式要求**：两个结果都必须四舍五入至三位有效数字。最终答案必须是行矩阵。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，采用了标准的 Basquin 关系式和 Palmgren-Miner 法则，这些都是金属疲劳工程分析中的基本概念。该问题是适定的，因为计算唯一解所需的所有数据和关系都已提供。语言客观、精确。所提供的材料常数和应力水平的数值对于高强度钢是符合物理实际的。该问题没有违反任何力学或数学原理，内容完整且无矛盾，并且可以直接形式化。\n\n**第 3 步：结论与行动**\n该问题被判定为**有效**。将推导其解法。\n\n分析基于 Palmgren-Miner 线性损伤累积法则进行。累积损伤 $D$ 是每个不同加载条件下循环比的总和：\n$$\nD = \\sum_{i} \\frac{n_i}{N_{fi}}\n$$\n其中，$n_i$是在应力幅 $S_{ai}$ 下施加的循环次数，$N_{fi}$ 是在相同应力幅下达到破坏的循环次数。当 $D=1$ 时，预测将发生破坏。\n\n对于给定的应力幅 $S_a$，达到破坏的循环次数 $N_f$ 由所给的 Basquin 关系式确定：\n$$\n\\log_{10} N_f = a - b \\log_{10} S_a\n$$\n给定常数 $a=12$ 和 $b=3$，方程为：\n$$\n\\log_{10} N_f = 12 - 3 \\log_{10} S_a\n$$\n这可以表示为幂律形式：\n$$\nN_f S_a^b = 10^a \\implies N_f = \\frac{10^a}{S_a^b} = \\frac{10^{12}}{S_a^3}\n$$\n\n首先，我们计算与第一个应力幅 $S_{a1} = 300\\,\\mathrm{MPa}$ 相对应的疲劳寿命 $N_{f1}$：\n$$\nN_{f1} = \\frac{10^{12}}{(300)^3} = \\frac{10^{12}}{(3 \\times 10^2)^3} = \\frac{10^{12}}{27 \\times 10^6} = \\frac{10^6}{27} \\text{ 周}\n$$\n$N_{f1} \\approx 37037.037...$ 周。\n\n接着，我们计算与第二个应力幅 $S_{a2} = 150\\,\\mathrm{MPa}$ 相对应的疲劳寿命 $N_{f2}$：\n$$\nN_{f2} = \\frac{10^{12}}{(150)^3} = \\frac{10^{12}}{(1.5 \\times 10^2)^3} = \\frac{10^{12}}{3.375 \\times 10^6} = \\frac{10^6}{3.375} = \\frac{8 \\times 10^6}{27} \\text{ 周}\n$$\n$N_{f2} \\approx 296296.296...$ 周。注意，$N_{f2} = 8 N_{f1}$，这是符合预期的，因为 $S_{a1} = 2 S_{a2}$ 且指数 $b=3$。\n\n现在，我们计算每个加载阶段所产生的损伤。\n对于第一个阶段，在 $S_{a1}=300\\,\\mathrm{MPa}$ 下加载 $n_1=1.0\\times 10^4$ 周：\n$$\nD_1 = \\frac{n_1}{N_{f1}} = \\frac{1.0 \\times 10^4}{10^6 / 27} = \\frac{10^4 \\times 27}{10^6} = \\frac{27}{100} = 0.27\n$$\n\n对于第二个阶段，在 $S_{a2}=150\\,\\mathrm{MPa}$ 下加载 $n_2=5.0\\times 10^4$ 周：\n$$\nD_2 = \\frac{n_2}{N_{f2}} = \\frac{5.0 \\times 10^4}{8 \\times 10^6 / 27} = \\frac{5 \\times 10^4 \\times 27}{8 \\times 10^6} = \\frac{5 \\times 27}{800} = \\frac{135}{800} = 0.16875\n$$\n\n两个阶段后的总累积损伤 $D$ 是各部分损伤之和：\n$$\nD = D_1 + D_2 = 0.27 + 0.16875 = 0.43875\n$$\n四舍五入至三位有效数字，累积损伤为 $D \\approx 0.439$。\n\n根据 Palmgren-Miner 法则，当 $D=1$ 时发生破坏。剩余的损伤容量为：\n$$\nD_{\\text{rem}} = 1 - D = 1 - 0.43875 = 0.56125\n$$\n问题要求计算在第二个应力幅 $S_{a2}=150\\,\\mathrm{MPa}$ 下达到破坏所需的额外循环次数 $\\Delta n$。这对应于消耗剩余的损伤容量 $D_{\\text{rem}}$：\n$$\nD_{\\text{rem}} = \\frac{\\Delta n}{N_{f2}}\n$$\n求解 $\\Delta n$：\n$$\n\\Delta n = D_{\\text{rem}} \\times N_{f2} = 0.56125 \\times \\left(\\frac{8 \\times 10^6}{27}\\right)\n$$\n$$\n\\Delta n = \\frac{4490000}{27} \\approx 166296.296... \\text{ 周}\n$$\n四舍五入至三位有效数字，额外循环次数为 $\\Delta n \\approx 1.66 \\times 10^5$ 周。\n\n要求输出的累积损伤 $D$ 和达到破坏的额外循环次数 $\\Delta n$ 均需四舍五入至三位有效数字。\n$D \\approx 0.439$\n$\\Delta n \\approx 1.66 \\times 10^5$ 周。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.439 & 1.66 \\times 10^5\n\\end{pmatrix}\n}\n$$", "id": "2628832"}, {"introduction": "在超越简单的计算后，这个实践将深入探讨疲劳寿命对应力变化的临界敏感性。通过解析推导应力相对变化与寿命相对变化之间的关系，你将对Basquin指数 $m$ 的物理意义产生更深刻的直觉，并理解为何看似微小的载荷变化会对构件的耐久性产生巨大影响。[@problem_id:2875892]", "problem": "一个均匀的金属构件承受完全反向的等幅单轴载荷，应力幅值为 $\\sigma_{a}$（单位为兆帕）。其应力-寿命行为由 Basquin 型应力-寿命关系表示\n$$\nN(\\sigma_{a}) \\;=\\; A\\,\\sigma_{a}^{-m},\n$$\n其中 $A>0$ 和 $m>0$ 是材料常数，$N(\\sigma_{a})$ 是在应力幅值 $\\sigma_{a}$ 下的失效循环次数。在变幅载荷下的累积疲劳损伤由线性损伤累积假说（通常称为 Miner 法则）建模，根据该法则，一系列载荷块后的总损伤是循环分数 $n_{i}/N(\\sigma_{a,i})$ 的总和，当累积损伤达到 $1$ 时，即发生失效。\n\n1) 仅使用基本微积分和给定的应力-寿命关系，推导一个微分关系，该关系量化了 $\\sigma_{a}$ 的无穷小分数变化如何引起 $N$ 的相应分数变化。根据推导出的关系，解释指数 $m$ 作为灵敏度参数的物理意义。\n\n2) 考虑一个重复的两级载荷块序列。在每个载荷块中，构件承受 $n$ 次应力幅值为 $\\sigma_{a}$ 的循环和 $n$ 次应力幅值为 $\\kappa\\,\\sigma_{a}$ 的循环，其中 $\\kappa\\in(0,1)$ 是一个固定比率。用 $n$, $A$, $m$, $\\kappa$ 和 $\\sigma_{a}$ 表示每块载荷的损伤 $D_{\\text{block}}$，并求出由 $\\sigma_{a}$ 的无穷小分数变化引起的一阶分数变化 $D_{\\text{block}}$。\n\n3) 设 $A=1.0\\times 10^{21}$, $m=6.5$, $\\sigma_{a}=200$ (兆帕), $\\kappa=0.8$, 且 $n=2.0\\times 10^{4}$。假设基础幅值 $\\sigma_{a}$ 增加一个小的分数 $\\varepsilon=0.03$, 而 $\\kappa$, $n$, $A$ 和 $m$ 保持不变。利用第 1) 和 2) 部分的结果, 确定失效前载荷块数 $M_{f}$ 的一阶分数变化, 其定义为 $M_{f}=1/D_{\\text{block}}$。将 $M_{f}$ 分数变化的最终答案表示为小数（无单位），并四舍五入到四位有效数字。", "solution": "所述问题具有科学依据，提法明确，并包含得出唯一且有意义的解所需的所有信息。这是材料力学中的一个标准练习，特别关注变幅载荷下的疲劳寿命预测。我们将按要求分三部分进行解答。\n\n第 1 部分：分数变化的微分关系推导及指数 $m$ 的解释。\n\n应力-寿命行为由 Basquin 关系给出：\n$$\nN(\\sigma_{a}) = A\\,\\sigma_{a}^{-m}\n$$\n其中 $N$ 是在应力幅值 $\\sigma_{a}$ 下的失效循环次数，$A$ 和 $m$ 是正的材料常数。为了找到分数变化之间的关系，我们对等式两边取自然对数：\n$$\n\\ln(N) = \\ln(A\\,\\sigma_{a}^{-m})\n$$\n利用对数的性质，展开得到：\n$$\n\\ln(N) = \\ln(A) + \\ln(\\sigma_{a}^{-m}) = \\ln(A) - m\\ln(\\sigma_{a})\n$$\n现在，我们求这个表达式的全微分。由于 $A$ 和 $m$ 是常数，它们的微分是零。我们将 $N$ 视为 $\\sigma_{a}$ 的函数。对表达式进行微分得到：\n$$\nd(\\ln(N)) = d(\\ln(A) - m\\ln(\\sigma_{a}))\n$$\n$\\ln(x)$ 的微分是 $dx/x$。应用此法则，我们得到：\n$$\n\\frac{dN}{N} = 0 - m \\frac{d\\sigma_{a}}{\\sigma_{a}}\n$$\n这就得到了所需的微分关系：\n$$\n\\frac{dN}{N} = -m \\frac{d\\sigma_{a}}{\\sigma_{a}}\n$$\n该关系将寿命的无穷小分数变化 $dN/N$ 与应力幅值的无穷小分数变化 $d\\sigma_{a}/\\sigma_{a}$ 联系起来。\n\n从这个关系中，指数 $m$ 的物理意义就变得清晰了。它作为一个灵敏度参数。具体来说，$m$ 是疲劳寿命分数变化与应力幅值分数变化之比的绝对值。负号表示反比关系：应力幅值的增加导致疲劳寿命的减少。对于一个 $m$ 值较大的材料，即使应力幅值只有很小的百分比增加，其寿命也会有很大的百分比减少。因此，在疲劳背景下，$m$ 量化了材料对应力水平变化的敏感性。\n\n第 2 部分：每块载荷的损伤及其分数变化。\n\n载荷序列由一个重复的两级载荷块组成：$n$ 次应力幅值为 $\\sigma_{a}$ 的循环和 $n$ 次应力幅值为 $\\kappa\\,\\sigma_{a}$ 的循环。根据 Miner 的线性损伤累积法则，一个载荷块内产生的损伤 $D_{\\text{block}}$ 是每个级别循环比的总和。\n\n在应力幅值 $\\sigma_{a}$ 下的失效循环次数是 $N(\\sigma_{a}) = A\\,\\sigma_{a}^{-m}$。\n在应力幅值 $\\kappa\\,\\sigma_{a}$ 下的失效循环次数是 $N(\\kappa\\,\\sigma_{a}) = A\\,(\\kappa\\,\\sigma_{a})^{-m} = A\\,\\kappa^{-m}\\,\\sigma_{a}^{-m}$。\n\n第一级的损伤是 $D_{1} = \\frac{n}{N(\\sigma_{a})} = \\frac{n}{A\\,\\sigma_{a}^{-m}} = \\frac{n\\,\\sigma_{a}^{m}}{A}$。\n第二级的损伤是 $D_{2} = \\frac{n}{N(\\kappa\\,\\sigma_{a})} = \\frac{n}{A\\,\\kappa^{-m}\\,\\sigma_{a}^{-m}} = \\frac{n\\,\\kappa^{m}\\,\\sigma_{a}^{m}}{A}$。\n\n每块载荷的总损伤是 $D_{\\text{block}} = D_{1} + D_{2}$ 的总和：\n$$\nD_{\\text{block}} = \\frac{n\\,\\sigma_{a}^{m}}{A} + \\frac{n\\,\\kappa^{m}\\,\\sigma_{a}^{m}}{A}\n$$\n提取公因式，得到每块载荷损伤的表达式：\n$$\nD_{\\text{block}} = \\frac{n\\,\\sigma_{a}^{m}}{A}(1 + \\kappa^{m})\n$$\n为了求出由 $\\sigma_{a}$ 的分数变化引起的 $D_{\\text{block}}$ 的一阶分数变化，我们再次使用对数微分法。参数 $n$, $A$, $m$ 和 $\\kappa$ 是常数。\n$$\n\\ln(D_{\\text{block}}) = \\ln\\left(\\frac{n}{A}(1 + \\kappa^{m})\\right) + \\ln(\\sigma_{a}^{m})\n$$\n$$\n\\ln(D_{\\text{block}}) = \\ln\\left(\\frac{n}{A}(1 + \\kappa^{m})\\right) + m\\ln(\\sigma_{a})\n$$\n对这个表达式关于 $\\sigma_{a}$ 求导得到：\n$$\n\\frac{1}{D_{\\text{block}}}\\frac{dD_{\\text{block}}}{d\\sigma_{a}} = 0 + \\frac{m}{\\sigma_{a}}\n$$\n这给出了 $D_{\\text{block}}$ 分数变化的微分关系：\n$$\n\\frac{dD_{\\text{block}}}{D_{\\text{block}}} = m \\frac{d\\sigma_{a}}{\\sigma_{a}}\n$$\n这表明，载荷块损伤的分数变化与基础应力幅值 $\\sigma_{a}$ 的分数变化成正比，比例常数是 Basquin 指数 $m$。\n\n第 3 部分：失效前载荷块数分数变化的计算。\n\n失效前载荷块数 $M_{f}$ 定义为每块载荷损伤 $D_{\\text{block}}$ 的倒数，因为当总损伤等于 $1$ 时发生失效。\n$$\nM_{f} = \\frac{1}{D_{\\text{block}}}\n$$\n我们需要求出 $M_{f}$ 的分数变化，即 $dM_{f}/M_{f}$。我们可以将其与 $D_{\\text{block}}$ 的分数变化联系起来：\n$$\n\\ln(M_{f}) = \\ln\\left(\\frac{1}{D_{\\text{block}}}\\right) = -\\ln(D_{\\text{block}})\n$$\n对此进行微分得到：\n$$\n\\frac{dM_{f}}{M_{f}} = - \\frac{dD_{\\text{block}}}{D_{\\text{block}}}\n$$\n代入第 2 部分的结果：\n$$\n\\frac{dM_{f}}{M_{f}} = - \\left( m \\frac{d\\sigma_{a}}{\\sigma_{a}} \\right) = -m \\frac{d\\sigma_{a}}{\\sigma_{a}}\n$$\n问题陈述基础幅值 $\\sigma_{a}$ 增加了一个小的分数 $\\varepsilon = 0.03$。对于一个小的有限变化，我们可以用这个有限值来近似微分分数变化：\n$$\n\\frac{d\\sigma_{a}}{\\sigma_{a}} \\approx \\frac{\\Delta\\sigma_{a}}{\\sigma_{a}} = \\varepsilon\n$$\n因此，$M_{f}$ 的一阶分数变化是：\n$$\n\\frac{\\Delta M_{f}}{M_{f}} \\approx -m\\,\\varepsilon\n$$\n问题给出了值 $m=6.5$ 和 $\\varepsilon=0.03$。请注意，此特定计算不需要其他参数（$A, \\sigma_{a}, \\kappa, n$），因为由于控制方程的幂律性质，分数变化与它们无关。\n\n代入给定值：\n$$\n\\frac{\\Delta M_{f}}{M_{f}} \\approx -6.5 \\times 0.03 = -0.195\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\frac{\\Delta M_{f}}{M_{f}} \\approx -0.1950\n$$\n这个负值表示基础应力幅值增加 $3\\%$ 会导致失效前载荷块数减少 $19.5\\%$，这表明了由指数 $m$ 决定的疲劳寿命对应力变化的高度敏感性。", "answer": "$$\n\\boxed{-0.1950}\n$$", "id": "2875892"}, {"introduction": "这个最终的、综合性的练习将挑战你将所学知识整合成一个完整的疲劳分析计算工具。你将实现一个工程标准流程，从原始的应力时间序列开始，到最终的累积损伤值，其间融合了雨流计数法和平均应力修正等关键技术。这个实践连接了理论与实际应用，为你装备上现代疲劳设计与分析所必需的重要技能。[@problem_id:2875935]", "problem": "您必须编写一个完整、可运行的程序，通过实施一套原则性流程，将离散的应力时间序列转换为累积疲劳损伤 $D$。该流程包括：对反转点进行雨流计数、线性平均应力修正、通过 $S$-$N$ 关系映射到失效循环数，以及最终的线性损伤累积。推导过程应基于核心定义：通过反转和闭合提取循环、计算每个循环的应力幅值和平均应力、采用以极限抗拉强度为参考的线性平均应力修正、使用与高周疲劳相符的 $S$-$N$ 关系，以及线性累积损伤。程序必须仅输出下文指定的数值结果。\n\n要求的概念流程：\n- 从离散应力序列 $s(t_i)$ 开始，首先提取反转点（局部最大值和最小值），并保留序列的第一个和最后一个点。\n- 对反转点执行雨流计数，以产生具有应力范围 $\\Delta S$ 和平均应力 $S_m$ 的循环，同时计数闭合循环和两端的残余半循环。\n- 对每个循环，计算应力幅值 $S_a$ 和平均应力 $S_m$；应用以极限抗拉强度 $S_u$ 为参考的线性平均应力修正（Goodman 类型），以获得等效的完全反向应力幅值。\n- 使用带有明确疲劳极限 $S_e$ 的幂律 $S$-$N$ 关系，将等效幅值映射到失效循环数，当应力低于该极限时，损伤计为零。\n- 通过对所有循环进行线性求和来累积损伤，从而得到 $D$。\n\n科学和数值要求：\n- 所有应力单位必须为兆帕（MPa）。\n- 累积损伤 $D$ 是无量纲的。将 $D$ 表示为小数点后保留 $6$ 位的小数。\n- 对于等效幅值小于或等于疲劳极限 $S_e$ 的循环，其造成的损伤计为零。\n- 根据雨流计数标准，残余半循环的权重应计为完整循环的 $0.5$。\n- 使用以 $S_u$ 为参考的线性平均应力修正。\n- 使用由常数 $C$ 和 $m$ 表征的幂律 $S$-$N$ 关系。\n\n测试套件：\n- 对所有测试用例，使用相同的材料参数：\n  - 极限抗拉强度 $S_u = 700$ MPa。\n  - 疲劳极限 $S_e = 160$ MPa。\n  - $S$-$N$ 常数: $C = 4.9 \\times 10^{12}$，$m = 3.0$。\n- 时间序列以离散应力值 $s_i$（单位 MPa）给出。您的实现必须首先将每个序列简化为反转点，然后执行雨流计数。\n\n待评估的测试用例：\n- 用例 1（理想情况，高于 $S_e$ 的完全反向循环）：`[0, 200, -200, 200, -200, 0]`。\n- 用例 2（边界情况，低于 $S_e$ 的完全反向循环）：`[0, 80, -80, 80, -80, 0]`。\n- 用例 3（显著的非零平均应力，修正后高于 $S_e$）：`[100, 280, -80, 280, -80, 100]`。\n- 用例 4（边缘情况，包含混合小循环和产生半循环的未闭合大偏移）：`[0, 50, 0, -50, 0, 220, 0]`。\n\n您的程序应生成单行输出，其中包含按用例顺序排列的结果，格式为方括号内的逗号分隔列表，例如 $[d_1,d_2,d_3,d_4]$，其中每个 $d_i$ 是累积损伤值，四舍五入到小数点后 $6$ 位。\n\n交付内容：\n- 一个独立的 Python 程序，该程序：\n  - 使用提供的 $C$、$m$、$S_e$ 实现反转点提取、雨流计数、平均应力修正（相对于 $S_u$ 的线性修正）和 $S$-$N$ 映射。\n  - 通过线性累积计算每个测试用例的 $D$。\n  - 精确打印一行格式为 $[d_1,d_2,d_3,d_4]$ 的结果，其中每个 $d_i$ 四舍五入到小数点后 $6$ 位。\n\n在您的书面解决方案中，请清楚地识别并论证该流程中涉及的每项近似或建模选择，包括但不限于 $s(t)$ 的离散化、反转点提取、雨流闭合准则、线性平均应力修正、基于 $S_e$ 的 $S$-$N$ 外推和阈值处理，以及线性损伤累积。代码输出必须保持为前述规定的纯数值格式。", "solution": "该问题是计算材料力学领域一个明确定义的练习，旨在通过实现一个标准的疲劳分析流程，估算累积疲劳损伤。该问题具有科学依据、内部逻辑一致，并提供了计算唯一解所需的所有参数和数据。\n\n解决方案流程基于既定原则，始于应力-时间历史，终于无量纲的损伤值 $D$。\n\n**步骤 1：反转点提取**\n疲劳损伤由应力反转驱动。因此，第一步是将离散应力序列 $s_i$ 简化为其局部极值（峰值和谷值）序列。对于给定的序列，我们通过检查条件 $(s_i - s_{i-1})(s_{i+1} - s_i) < 0$ 来识别内部反转点。根据规范，序列的第一个和最后一个点始终保留。\n\n**步骤 2：雨流计数法**\n为了从反转点序列中识别出单个应力循环，我们采用标准的雨流计数算法（如 ASTM E1049-85 中所述的“三点法”）。\n算法流程如下：\n1.  初始化一个空堆栈，用于存储已处理的反转点。\n2.  遍历反转点序列。对于每个点 $p_i$：\n    a.  将 $p_i$ 推入堆栈。\n    b.  当堆栈中至少有三个点（从栈顶到底为 $P_3, P_2, P_1$）时，计算两个连续的范围：$R_1 = |P_3 - P_2|$ 和 $R_2 = |P_2 - P_1|$。\n    c.  如果内层范围 $R_2$ 小于或等于外层范围 $R_1$（即 $R_2 \\le R_1$），则从 $P_1$ 和 $P_2$ 中识别出一个闭合循环。该循环被计为一个完整循环（$n_i=1.0$），其幅值和平均应力被计算出来，然后将点 $P_2$ 从堆栈中移除。此检查将重复进行，直到条件不再满足。\n3.  遍历完所有反转点后，堆栈中剩余的每对相邻点构成一个未闭合的半循环（$n_i=0.5$）。\n\n对于每个识别出的循环，我们计算其应力幅值 $S_a = (\\text{range})/2$ 和平均应力 $S_m = (S_{\\text{max}} + S_{\\text{min}})/2$。\n\n**步骤 3：平均应力修正**\n拉伸平均应力会降低疲劳寿命。我们采用 Goodman 关系式来计算等效的完全反向应力幅值 $S_{a,eq}$，该值在理论上产生与实际循环相同的寿命。\n$$ S_{a,eq} = \\frac{S_a}{1 - \\frac{S_m}{S_u}} $$\n此修正仅适用于拉伸平均应力 ($S_m > 0$)。对于压缩平均应力 ($S_m \\le 0$)，我们保守地假设没有影响，即 $S_{a,eq} = S_a$。\n\n**步骤 4：失效循环数 ($S$-$N$ 关系)**\n我们使用 Basquin 方程的幂律形式将 $S_{a,eq}$ 映射到失效循环数 $N_f$：\n$$ N_f = \\frac{C}{S_{a,eq}^m} $$\n一个关键的假设是疲劳极限 $S_e$ 的存在。如果 $S_{a,eq} \\le S_e$，则该循环造成的损伤为零 ($N_f \\to \\infty$)。\n\n**步骤 5：线性损伤累积（Miner 法则）**\n最后，我们使用 Palmgren-Miner 法则，通过对所有造成损伤的循环的损伤分数进行求和来计算总损伤 $D$：\n$$ D = \\sum_{i} \\frac{n_i}{N_{f,i}} $$\n其中 $n_i$ 是循环计数（完整循环为 1.0，半循环为 0.5）。\n\n**计算分析**\n材料参数：$S_u = 700$ MPa, $S_e = 160$ MPa, $C = 4.9 \\times 10^{12}$, $m = 3.0$。\n\n- **用例 1**: `[0, 200, -200, 200, -200, 0]`。雨流计数识别出两个从 -200 MPa 到 200 MPa 的完整循环。\n  - 对每个循环：$S_a=200$ MPa, $S_m=0$ MPa。$S_m=0$, 因此 $S_{a,eq} = 200$ MPa。\n  - $S_{a,eq} > S_e$。$N_f = (4.9 \\times 10^{12}) / 200^3 = 612500$。\n  - $D = 2 \\times (1 / 612500) \\approx 0.000003265$。\n\n- **用例 2**: `[0, 80, -80, 80, -80, 0]`。雨流计数识别出两个从 -80 MPa 到 80 MPa 的完整循环。\n  - 对每个循环：$S_a=80$ MPa, $S_m=0$ MPa。$S_{a,eq} = 80$ MPa。\n  - 由于 $S_{a,eq} \\le S_e$, 每个循环造成的损伤为零。$D = 0$。\n\n- **用例 3**: `[100, 280, -80, 280, -80, 100]`。标准的雨流计数算法识别出三个完整循环：\n  1. $S_1 = 100$, $S_2 = 280$。$S_a = 90$, $S_m = 190$。$S_{a,eq} = 90 / (1 - 190/700) \\approx 123.5$ MPa。$S_{a,eq} \\le S_e \\implies D_1 = 0$。\n  2. $S_1 = -80$, $S_2 = 100$。$S_a = 90$, $S_m = 10$。$S_{a,eq} = 90 / (1 - 10/700) \\approx 91.3$ MPa。$S_{a,eq} \\le S_e \\implies D_2 = 0$。\n  3. $S_1 = -80$, $S_2 = 280$。$S_a = 180$, $S_m = 100$。$S_{a,eq} = 180 / (1 - 100/700) = 210$ MPa。$S_{a,eq} > S_e$。$N_f = (4.9 \\times 10^{12}) / 210^3 \\approx 529099.45$。$D_3 = 1 / N_f \\approx 0.000001890$。\n  - 总损伤 $D = D_1 + D_2 + D_3 \\approx 0.000001890$。\n\n- **用例 4**: `[0, 50, 0, -50, 0, 220, 0]`。反转点序列为 `[0, 50, -50, 220, 0]`。雨流计数识别出三个完整循环：\n  1. $S_1=0$, $S_2=50$。$S_a = 25, S_m=25$。$S_{a,eq} = 25 / (1 - 25/700) \\approx 25.9$ MPa。$S_{a,eq} \\le S_e \\implies D_1 = 0$。\n  2. $S_1=0$, $S_2=-50$。$S_a=25, S_m=-25$。$S_{a,eq} = 25$ MPa。$S_{a,eq} \\le S_e \\implies D_2=0$。\n  3. $S_1=0$, $S_2=220$。$S_a=110, S_m=110$。$S_{a,eq} = 110 / (1 - 110/700) \\approx 130.5$ MPa。$S_{a,eq} \\le S_e \\implies D_3=0$。\n  - 总损伤 $D = 0$。\n\n综合计算结果，四舍五入到小数点后6位，最终输出应为 `[0.000003, 0.000000, 0.000002, 0.000000]`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes cumulative fatigue damage for a set of stress time series\n    using a standard pipeline: reversal extraction, rainflow counting,\n    Goodman mean stress correction, and Miner's linear damage rule.\n    \"\"\"\n\n    # Material parameters (all stresses in MPa)\n    S_u = 700.0   # Ultimate tensile strength\n    S_e = 160.0   # Endurance limit\n    C = 4.9e12    # S-N constant\n    m = 3.0       # S-N exponent\n\n    test_cases = [\n        [0.0, 200.0, -200.0, 200.0, -200.0, 0.0],\n        [0.0, 80.0, -80.0, 80.0, -80.0, 0.0],\n        [100.0, 280.0, -80.0, 280.0, -80.0, 100.0],\n        [0.0, 50.0, 0.0, -50.0, 0.0, 220.0, 0.0],\n    ]\n\n    def extract_reversals(series):\n        \"\"\"\n        Extracts reversal points (peaks and valleys) from a time series.\n        Keeps the first and last points.\n        \"\"\"\n        if len(series) < 3:\n            return series\n\n        reversals = [series[0]]\n        for i in range(1, len(series) - 1):\n            p_prev, p_curr, p_next = series[i - 1], series[i], series[i + 1]\n            if (p_curr - p_prev) * (p_next - p_curr) < 0:\n                reversals.append(p_curr)\n        if series[-1] != reversals[-1]:\n             reversals.append(series[-1])\n        return reversals\n\n    def rainflow_count(reversals):\n        \"\"\"\n        Performs rainflow cycle counting using the 3-point algorithm (ASTM E1049-85).\n        Returns a list of tuples (amplitude, mean, count).\n        \"\"\"\n        stack = []\n        cycles = []\n        \n        for point in reversals:\n            stack.append(point)\n            while len(stack) >= 3:\n                # Top to bottom: P3, P2, P1\n                P3, P2, P1 = stack[-1], stack[-2], stack[-3]\n                range1 = abs(P3 - P2)\n                range2 = abs(P2 - P1)\n\n                if range2 <= range1:\n                    # A closed cycle is found from P1 and P2\n                    amplitude = range2 / 2.0\n                    mean_stress = (P1 + P2) / 2.0\n                    cycles.append((amplitude, mean_stress, 1.0))\n                    \n                    # Pop the middle point P2 from the stack\n                    stack.pop(-2)\n                else:\n                    break\n\n        # Process residual half-cycles remaining in the stack\n        while len(stack) >= 2:\n            P2 = stack.pop()\n            P1 = stack.pop()\n            amplitude = abs(P1 - P2) / 2.0\n            mean_stress = (P1 + P2) / 2.0\n            cycles.append((amplitude, mean_stress, 0.5))\n\n        return cycles\n\n    results = []\n    for case_series in test_cases:\n        reversals = extract_reversals(case_series)\n        cycles = rainflow_count(reversals)\n\n        total_damage = 0.0\n        for Sa, Sm, count in cycles:\n            if Sa == 0:\n                continue\n\n            # Apply Goodman mean stress correction\n            Sa_eq = Sa\n            if Sm > 0:\n                # Avoid division by zero if Sm approaches Su\n                if Sm < S_u:\n                    Sa_eq = Sa / (1.0 - Sm / S_u)\n                else: # Tensile mean stress exceeds ultimate strength\n                    Sa_eq = float('inf')\n\n            # Accumulate damage only if equivalent amplitude is above endurance limit\n            if Sa_eq > S_e:\n                # Calculate cycles to failure using S-N relation\n                Nf = C / (Sa_eq ** m)\n                total_damage += count / Nf\n\n        results.append(round(total_damage, 6))\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```", "id": "2875935"}]}