{"hands_on_practices": [{"introduction": "实践中测得的疲劳裂纹扩展阈值 $\\Delta K_{\\mathrm{th}}$ 并非材料的固有属性，它会受到裂纹闭合等外部因素的显著影响。本练习旨在通过分析不同环境下（真空、氮气和空气）的实验数据，帮助您区分材料的“内在”抗断裂能力与“表观”测量值。通过计算，您将量化由氧化物诱导的裂纹闭合对疲劳阈值的贡献，从而更深刻地理解有效应力强度因子范围 $\\Delta K_{\\mathrm{eff}}$ 的物理意义。[@problem_id:2925988]", "problem": "一个高强度铝合金的边缘裂纹紧凑拉伸试样在恒定振幅载荷下进行测试，以建立近阈值扩展条件。测试采用固定的载荷比（最小与最大应力强度因子之比）$R = K_{\\min}/K_{\\max} = 0.1$ 和低频加载。在三种环境中测量了近阈值应力强度因子范围（$\\Delta K_{\\mathrm{th}}$）：高真空、干燥氮气和实验室环境空气。室温下的测量值如下：\n- 高真空：$\\Delta K_{\\mathrm{th}}^{\\mathrm{vac}} = 2.30\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}$，\n- 干燥氮气：$\\Delta K_{\\mathrm{th}}^{\\mathrm{N_2}} = 2.80\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}$，\n- 环境空气：$\\Delta K_{\\mathrm{th}}^{\\mathrm{air}} = 3.60\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}$。\n\n假设小范围屈服、I型加载，并且近阈值裂纹扩展的内禀的、对环境不敏感的障碍由一个无闭合效应的有效阈值 $\\Delta K_{0}$ 来表征，使得在所有环境中，阈值处的有效裂尖应力强度因子范围满足 $\\Delta K_{\\mathrm{eff,th}} = \\Delta K_{0}$。采用以下定义：\n- $\\Delta K = K_{\\max} - K_{\\min}$，\n- $R = K_{\\min}/K_{\\max}$，\n- $\\Delta K_{\\mathrm{eff}} = U\\,\\Delta K$，其中 $U$ 是裂纹闭合参数，\n- $U = \\left(K_{\\max} - K_{\\mathrm{op}}\\right)/\\left(K_{\\max} - K_{\\min}\\right)$，其中 $K_{\\mathrm{op}}$ 是裂纹张开应力强度因子。\n\n在真空阈值条件下进行的独立高分辨率柔度测量表明，在 $R=0.1$ 时，闭合参数不为1，其值为 $U^{\\mathrm{vac}} = 0.97$。假设在所有环境中，阈值处的 $K_{\\mathrm{op}} > K_{\\min}$。\n\n仅使用这些定义和上述数据，确定无闭合效应的内禀阈值 $\\Delta K_{0}$，并通过计算在 $R=0.1$ 时干燥氮气和环境空气中的 $U$ 和 $K_{\\mathrm{op}}$，定量解释 $\\Delta K_{\\mathrm{th}}$ 在不同环境中的差异。在报告的答案中，仅提供 $\\Delta K_{0}$ 的数值。\n\n以 $\\mathrm{MPa}\\sqrt{\\mathrm{m}}$ 为单位表示最终报告的 $\\Delta K_{0}$ 值，并四舍五入到四位有效数字。", "solution": "所给问题经过严格验证，被认为是具有科学依据、提法得当且客观的。它基于材料力学中疲劳裂纹扩展和裂纹闭合的既定原理。所有必要的数据和定义均已提供，并且对于在指定测试条件下的高强度铝合金而言，其前提在物理上是现实的。因此，该问题适用于完整的解析求解。\n\n问题的核心前提是，有效近阈值应力强度因子范围 $\\Delta K_{\\mathrm{eff,th}}$ 代表一种内禀材料属性，记为 $\\Delta K_{0}$。假定该值是恒定的，且独立于测试环境（高真空、干燥氮气、环境空气）。\n\n外加（或名义）应力强度因子范围 $\\Delta K$ 与有效范围 $\\Delta K_{\\mathrm{eff}}$ 之间的关系由裂纹闭合参数 $U$ 给出：\n$$ \\Delta K_{\\mathrm{eff}} = U \\Delta K $$\n在疲劳阈值处，此关系变为：\n$$ \\Delta K_{\\mathrm{eff,th}} = U \\Delta K_{\\mathrm{th}} $$\n鉴于在所有环境中 $\\Delta K_{\\mathrm{eff,th}} = \\Delta K_{0}$，我们可以得出：\n$$ \\Delta K_{0} = U \\Delta K_{\\mathrm{th}} $$\n这个方程构成了我们整个分析的基础。\n\n问题提供了在高真空中进行测试的数据，其中测得的阈值为 $\\Delta K_{\\mathrm{th}}^{\\mathrm{vac}} = 2.30\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}$，闭合参数为 $U^{\\mathrm{vac}} = 0.97$。我们可以使用这个基准案例来确定内禀阈值 $\\Delta K_{0}$。\n$$ \\Delta K_{0} = U^{\\mathrm{vac}} \\Delta K_{\\mathrm{th}}^{\\mathrm{vac}} $$\n代入给定的数值：\n$$ \\Delta K_{0} = (0.97) \\times (2.30\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}) = 2.231\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}} $$\n这个值 $\\Delta K_{0}$ 代表了材料在阈值下抵抗疲劳裂纹扩展的基本能力，其中已排除了外在的裂纹闭合效应。问题要求报告此值，并四舍五入到四位有效数字，即 $2.231$。\n\n为了按要求进行完整解释，我们现在使用计算出的内禀阈值 $\\Delta K_{0}$ 来分析其他两种环境中的行为。与真空相比，在氮气和空气中测得的 $\\Delta K_{\\mathrm{th}}$ 的增加归因于裂纹闭合程度的增加，这主要是由于裂纹表面形成了腐蚀产物（氧化物），这种现象被称为氧化物诱导的裂纹闭合。对于给定的外加 $\\Delta K$，这种增加的闭合效应导致裂尖处的有效应力强度因子范围降低。\n\n首先，我们计算干燥氮气和环境空气中的闭合参数 $U$。\n对于干燥氮气，$\\Delta K_{\\mathrm{th}}^{\\mathrm{N_2}} = 2.80\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}$。闭合参数为：\n$$ U^{\\mathrm{N_2}} = \\frac{\\Delta K_{0}}{\\Delta K_{\\mathrm{th}}^{\\mathrm{N_2}}} = \\frac{2.231\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}}{2.80\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}} \\approx 0.7968 $$\n对于环境空气，$\\Delta K_{\\mathrm{th}}^{\\mathrm{air}} = 3.60\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}$。闭合参数为：\n$$ U^{\\mathrm{air}} = \\frac{\\Delta K_{0}}{\\Delta K_{\\mathrm{th}}^{\\mathrm{air}}} = \\frac{2.231\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}}{3.60\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}}} \\approx 0.6197 $$\n正如预期的，随着环境反应性的增强（从真空到氮气再到空气），$U$ 的值减小，表明在加载循环中裂纹保持闭合的时间比例更大。\n\n接下来，我们计算每种环境下的裂纹张开应力强度因子 $K_{\\mathrm{op}}$。$U$ 的定义是：\n$$ U = \\frac{K_{\\max} - K_{\\mathrm{op}}}{K_{\\max} - K_{\\min}} = \\frac{K_{\\max} - K_{\\mathrm{op}}}{\\Delta K} $$\n由此，我们可以解出 $K_{\\mathrm{op}}$：\n$$ K_{\\mathrm{op}} = K_{\\max} - U \\Delta K $$\n我们必须用 $\\Delta K$ 和应力比 $R$ 来表示 $K_{\\max}$。定义为 $R = K_{\\min}/K_{\\max}$ 和 $\\Delta K = K_{\\max} - K_{\\min}$。\n将 $K_{\\min} = R K_{\\max}$ 代入 $\\Delta K$ 的表达式：\n$$ \\Delta K = K_{\\max} - R K_{\\max} = K_{\\max}(1 - R) $$\n因此，$K_{\\max} = \\frac{\\Delta K}{1-R}$。将此代入 $K_{\\mathrm{op}}$ 的表达式：\n$$ K_{\\mathrm{op}} = \\frac{\\Delta K}{1-R} - U \\Delta K = \\Delta K \\left(\\frac{1}{1-R} - U\\right) $$\n使用 $R = 0.1$，在每种环境的阈值条件下计算此表达式。其中 $\\frac{1}{1-R} = \\frac{1}{1-0.1} = \\frac{1}{0.9} = \\frac{10}{9}$。\n\n对于阈值下的干燥氮气：\n$$ K_{\\mathrm{op}}^{\\mathrm{N_2}} = \\Delta K_{\\mathrm{th}}^{\\mathrm{N_2}} \\left(\\frac{1}{1-R} - U^{\\mathrm{N_2}}\\right) = (2.80) \\left(\\frac{10}{9} - \\frac{2.231}{2.80}\\right) = 2.80\\left(\\frac{10}{9}\\right) - 2.231 \\approx 3.111 - 2.231 = 0.880\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}} $$\n对于阈值下的环境空气：\n$$ K_{\\mathrm{op}}^{\\mathrm{air}} = \\Delta K_{\\mathrm{th}}^{\\mathrm{air}} \\left(\\frac{1}{1-R} - U^{\\mathrm{air}}\\right) = (3.60) \\left(\\frac{10}{9} - \\frac{2.231}{3.60}\\right) = 3.60\\left(\\frac{10}{9}\\right) - 2.231 = 4.000 - 2.231 = 1.769\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}} $$\n定量分析证实了物理上的解释：逐渐增强反应性的环境（干燥氮气、环境空气）导致更高水平的裂纹闭合（更低的 $U$，更高的 $K_{\\mathrm{op}}$），这反过来又提高了外部测量的疲劳阈值 $\\Delta K_{\\mathrm{th}}$。内禀材料抗力 $\\Delta K_{0}$ 保持不变。\n\n问题特别要求提供 $\\Delta K_{0}$ 的数值。\n$$ \\Delta K_{0} = 2.231\\ \\mathrm{MPa}\\sqrt{\\mathrm{m}} $$", "answer": "$$\\boxed{2.231}$$", "id": "2925988"}, {"introduction": "在工程应用中，我们常通过表面处理（如喷丸）引入残余压应力来延长部件的疲劳寿命，其核心机制正是增强了裂纹闭合效应。本练习将裂纹闭合的概念应用于一个实际工程场景，要求您运用叠加原理来量化残余应力场对裂纹尖端有效应力比 $R_{\\text{eff}}$ 的影响。通过这个计算，您将掌握评估残余应力对疲劳裂纹扩展行为影响的基本方法。[@problem_id:2926015]", "problem": "一块经过喷丸处理的长金属板含有一个半无限表面断裂I型裂纹，其裂纹前缘局部垂直于板面。该板承受远场单轴循环拉伸载荷，其最大名义应力为 $\\,\\sigma_{\\max} = 240\\,\\text{MPa}\\,$，名义应力比为 $\\,R_{\\text{nom}} = \\sigma_{\\min}/\\sigma_{\\max} = 0.1\\,$。该裂纹深度为 $\\,a = 0.80\\,\\text{mm}\\,$，该深度是沿厚度方向 $\\,z\\,$ 从表面测量的。由喷丸处理产生的残余应力是自平衡的，并随深度 $\\,z\\,$ 按如下公式变化：\n$$\n\\sigma_{r}(z) = -350\\,\\exp\\!\\left(-\\frac{z}{0.25}\\right) + 70\\,\\exp\\!\\left(-\\frac{z}{1.0}\\right)\n$$\n公式中应力单位为兆帕 (MPa)，$\\,z\\,$ 的单位为毫米 (mm)。假设问题满足线性弹性断裂力学 (LEFM) 和叠加原理，且在所关注的裂纹前缘点处，局部I型应力强度因子 (SIF) 为 $\\,K = Y\\,\\sigma\\,\\sqrt{\\pi a}\\,$。其中，无量纲几何因子 $\\,Y\\,$ 对于最大和最小载荷状态是相同的，并且与残余应力无关。通过将有效最小SIF取为 $\\,K_{\\min,\\text{eff}} = \\max\\!\\left(0,\\,K_{\\min,\\text{total}}\\right)\\,$ 来模拟裂纹闭合效应，即当总SIF不大于零时，便认为裂纹完全闭合。在裂纹前缘的中点深度处（$\\,z = a/2\\,$）进行计算。\n\n从基本定义出发，计算中点深度处的有效应力比\n$$\nR_{\\text{eff}} \\equiv \\frac{K_{\\min,\\text{eff}}}{K_{\\max,\\text{total}}}\n$$\n。将答案四舍五入至四位有效数字。报告的 $\\,R_{\\text{eff}}\\,$ 为无量纲数（无单位）。", "solution": "该问题经验证具有科学依据、提法明确且客观。所有必要数据均已提供，且问题前提与线性弹性断裂力学（LEFM）的原理一致。下面我们进行求解。\n\n本分析的核心原理是应力强度因子 (SIF) 的叠加。裂纹前缘处的总SIF, $K_{\\text{total}}$，是由远场施加的循环载荷引起的SIF ($K_{\\text{applied}}$) 和由静态残余应力场引起的SIF ($K_{\\text{residual}}$) 的线性叠加。\n$$\nK_{\\text{total}} = K_{\\text{applied}} + K_{\\text{residual}}\n$$\n问题陈述，对于给定的应力 $\\sigma$，SIF为 $K = Y\\,\\sigma\\,\\sqrt{\\pi a}$，其中 $Y$ 是在所关注点上适用于所有应力分量的恒定几何因子。这使我们可以直接对应力应用叠加原理。驱动SIF的有效应力是外加应力 $\\sigma_{\\text{applied}}$ 和残余应力 $\\sigma_{r}$ 的和。\n\n我们必须在裂纹前缘的中点深度处（即深度 $z = a/2$）计算所有物理量。已知裂纹深度 $a = 0.80\\,\\text{mm}$，因此所关注的点位于 $z = 0.80/2 = 0.40\\,\\text{mm}$。\n\n首先，我们使用给定的表达式计算该深度处的残余应力 $\\sigma_{r}$：\n$$\n\\sigma_{r}(z) = -350\\,\\exp\\left(-\\frac{z}{0.25}\\right) + 70\\,\\exp\\left(-\\frac{z}{1.0}\\right)\n$$\n代入 $z = 0.40\\,\\text{mm}$：\n$$\n\\sigma_{r}(z=0.40) = -350\\,\\exp\\left(-\\frac{0.40}{0.25}\\right) + 70\\,\\exp\\left(-\\frac{0.40}{1.0}\\right)\n$$\n$$\n\\sigma_{r}(0.40) = -350\\,\\exp(-1.6) + 70\\,\\exp(-0.4)\n$$\n使用数值 $\\exp(-1.6) \\approx 0.2018965$ 和 $\\exp(-0.4) \\approx 0.6703200$：\n$$\n\\sigma_{r}(0.40) \\approx -350(0.2018965) + 70(0.6703200) \\approx -70.66378 + 46.92240 \\approx -23.74138\\,\\text{MPa}\n$$\n这个压性残余应力是在所关注位置的一个恒定应力分量。\n\n接下来，我们确定外加应力循环。给定最大名义应力 $\\sigma_{\\max} = 240\\,\\text{MPa}$ 和名义应力比 $R_{\\text{nom}} = 0.1$。最小名义应力 $\\sigma_{\\min}$ 为：\n$$\n\\sigma_{\\min} = R_{\\text{nom}} \\times \\sigma_{\\max} = 0.1 \\times 240\\,\\text{MPa} = 24\\,\\text{MPa}\n$$\n现在，我们可以求出载荷循环最大和最小点处的总SIF。最大总SIF, $K_{\\max,\\text{total}}$，对应于最大外加SIF与残余应力SIF之和。\n$$\nK_{\\max,\\text{total}} = K_{\\max,\\text{applied}} + K_{\\text{residual}}\n$$\n$$\nK_{\\max,\\text{total}} = Y\\,\\sigma_{\\max}\\sqrt{\\pi a} + Y\\,\\sigma_{r}(a/2)\\sqrt{\\pi a} = Y\\,(\\sigma_{\\max} + \\sigma_{r}(a/2))\\sqrt{\\pi a}\n$$\n类似地，最小总SIF, $K_{\\min,\\text{total}}$, 为：\n$$\nK_{\\min,\\text{total}} = K_{\\min,\\text{applied}} + K_{\\text{residual}}\n$$\n$$\nK_{\\min,\\text{total}} = Y\\,\\sigma_{\\min}\\sqrt{\\pi a} + Y\\,\\sigma_{r}(a/2)\\sqrt{\\pi a} = Y\\,(\\sigma_{\\min} + \\sigma_{r}(a/2))\\sqrt{\\pi a}\n$$\n问题基于一个裂纹闭合模型定义了有效最小SIF, $K_{\\min,\\text{eff}}$，该模型中裂纹不能承受压性SIF：\n$$\nK_{\\min,\\text{eff}} = \\max(0, K_{\\min,\\text{total}})\n$$\n为确定 $K_{\\min,\\text{eff}}$，我们必须评估 $K_{\\min,\\text{total}}$ 的符号。这取决于最小载荷点处的总应力 $\\sigma_{\\min} + \\sigma_{r}(a/2)$ 的符号。\n$$\n\\sigma_{\\min} + \\sigma_{r}(a/2) \\approx 24\\,\\text{MPa} + (-23.74138\\,\\text{MPa}) \\approx 0.25862\\,\\text{MPa}\n$$\n由于此和为正，所以 $K_{\\min,\\text{total}}$ 也为正。因此，闭合条件不会导致截断，我们得到：\n$$\nK_{\\min,\\text{eff}} = K_{\\min,\\text{total}}\n$$\n问题要求我们计算有效应力比 $R_{\\text{eff}}$：\n$$\nR_{\\text{eff}} = \\frac{K_{\\min,\\text{eff}}}{K_{\\max,\\text{total}}} = \\frac{K_{\\min,\\text{total}}}{K_{\\max,\\text{total}}}\n$$\n代入SIF的表达式：\n$$\nR_{\\text{eff}} = \\frac{Y\\,(\\sigma_{\\min} + \\sigma_{r}(a/2))\\sqrt{\\pi a}}{Y\\,(\\sigma_{\\max} + \\sigma_{r}(a/2))\\sqrt{\\pi a}}\n$$\n$Y\\sqrt{\\pi a}$ 项可以消掉，表达式简化为有效应力之比：\n$$\nR_{\\text{eff}} = \\frac{\\sigma_{\\min} + \\sigma_{r}(a/2)}{\\sigma_{\\max} + \\sigma_{r}(a/2)}\n$$\n现在我们将数值代入此表达式：\n$$\nR_{\\text{eff}} \\approx \\frac{24 + (-23.74138)}{240 + (-23.74138)} = \\frac{0.25862}{216.25862}\n$$\n$$\nR_{\\text{eff}} \\approx 0.00119589\n$$\n按要求四舍五入至四位有效数字：\n$$\nR_{\\text{eff}} \\approx 0.001196\n$$", "answer": "$$\n\\boxed{0.001196}\n$$", "id": "2926015"}, {"introduction": "裂纹闭合不仅受静态因素（如残余应力）影响，它更是一个随加载历史动态演变的复杂现象，尤其是在变幅加载条件下。本练习要求您通过一个逐周期算法，模拟单次超载事件如何产生持久的“记忆效应”，并在其后数个周期内抑制裂纹扩展（即延迟效应）。完成此练习将帮助您理解载荷顺序效应的物理基础，并掌握量化分析变幅疲劳行为的核心工具。[@problem_id:2925941]", "problem": "一个线弹性体中的单边裂纹在指定的加载历史下进行循环加载。在每个载荷循环中，将最大应力强度因子定义为 $K_{\\max}$，最小应力强度因子定义为 $K_{\\min}$。载荷比为 $R = K_{\\min}/K_{\\max}$。循环中能引起物理扩展的部分由有效应力强度因子范围控制，其定义为\n$$\n\\Delta K_{\\mathrm{eff}} = K_{\\max} - \\max\\left(K_{\\min},\\,K_{\\mathrm{op}}\\right),\n$$\n其中 $K_{\\mathrm{op}}$ 是裂纹张开应力强度因子，它包含了由尾流塑性和断裂面接触引起的裂纹闭合效应。目标是逐个循环地量化载荷比 $R$ 的变化和偶尔的单循环过载（即 $K_{\\max}$ 相对于名义基线暂时升高的循环）是如何通过 $K_{\\mathrm{op}}$ 的演化来改变 $\\Delta K_{\\mathrm{eff}}$ 的。\n\n请使用以下最小化的、物理上一致的唯象算法，该算法必须在每个循环 $n = 1,2,\\dots,N$ 应用：\n1. 每个循环 $n$ 的输入：指定的 $K_{\\max}(n)$ 和指定的 $R(n)$。则 $K_{\\min}(n)=R(n)\\,K_{\\max}(n)$。\n2. 循环 $n$ 的内在闭合基线：\n$$\nK_{\\mathrm{op,base}}(n) = K_{\\min}(n) + \\chi\\left(K_{\\max}(n) - K_{\\min}(n)\\right),\n$$\n其中材料参数 $0 \\le \\chi < 1$ 代表在没有过载记忆的情况下，因闭合而损失的范围的内在分数。\n3. 过载记忆状态 $z(n)$ 作为一个标量内变量进行演化，当 $K_{\\max}(n)$ 超过名义基线 $K_{\\mathrm{nom}}$ 时累积，并随循环次数呈几何级数松弛：\n$$\nz(n^+) = \\rho\\,z(n^-) + c_{\\mathrm{ol}}\\,\\max\\left(0,\\,K_{\\max}(n)-K_{\\mathrm{nom}}\\right),\n$$\n其中 $0<\\rho<1$ 是每循环保留因子，$c_{\\mathrm{ol}}>0$ 是过载-闭合敏感度。此处 $n^-$ 表示循环 $n$ 结束前的瞬间状态，$n^+$ 表示为下一个循环存储的更新后状态。初始化 $z(0)=0$。\n4. 在循环 $n$ 开始时，限制有效范围的起作用的张开水平为\n$$\nK_{\\mathrm{op}}(n) = \\min\\left(K_{\\max}(n),\\,K_{\\mathrm{op,base}}(n) + z(n-1^+)\\right),\n$$\n这强制要求裂纹张开水平不能超过 $K_{\\max}(n)$，并且过载记忆 $z$ 仅影响产生它的过载事件之后的循环。\n5. 在循环 $n$ 期间实现的有效范围则为\n$$\n\\Delta K_{\\mathrm{eff}}(n) = \\max\\left(0,\\,K_{\\max}(n)-K_{\\mathrm{op}}(n)\\right).\n$$\n\n所有应力强度因子都必须以 $\\mathrm{MPa}\\sqrt{\\mathrm{m}}$ 为单位处理。设长裂纹扩展的阈值为 $\\Delta K_{\\mathrm{th}}$，单位为 $\\mathrm{MPa}\\sqrt{\\mathrm{m}}$。对于每个测试用例，在整个包含 $N$ 个循环的加载块上计算：\n- 算术平均值 $\\overline{\\Delta K_{\\mathrm{eff}}}$，单位 $\\mathrm{MPa}\\sqrt{\\mathrm{m}}$。\n- $\\Delta K_{\\mathrm{eff}}(n)$ 大于或等于 $\\Delta K_{\\mathrm{th}}$ 的循环所占的比例，表示为 $[0,1]$ 范围内的小数。\n\n您的程序必须完全按照上述说明实现逐循环算法，并对所有测试用例使用以下固定的材料参数：\n- $\\chi = 0.3$,\n- $c_{\\mathrm{ol}} = 0.6$,\n- $\\rho = 0.9$,\n- $\\Delta K_{\\mathrm{th}} = 6.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$。\n\n过载被指定为在特定循环索引处的事件，并通过仅在该单次循环中将 $K_{\\max}(n)$ 暂时设置为一个严格大于名义基线 $K_{\\mathrm{nom}}$ 的值来实现。对于所有非过载循环，$K_{\\max}(n) = K_{\\mathrm{nom}}$。循环从 $1$ 到 $N$ 索引。\n\n测试套件。对于以下每个用例，根据给定的段和过载事件构建循环历史。每个段是一个对偶 $(n_{\\mathrm{seg}},R_{\\mathrm{seg}})$，表示接下来的 $n_{\\mathrm{seg}}$ 个循环使用恒定的载荷比 $R_{\\mathrm{seg}}$。确保在每个用例中，所有 $n_{\\mathrm{seg}}$ 的总和等于 $N$。\n- 用例 1 (标准情况，无过载，低 $R$ 值)：$N=50$，$K_{\\mathrm{nom}}=15.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，分段 $\\left[(50,\\,0.1)\\right]$，过载事件 $\\left[\\right]$。\n- 用例 2 (恒定 $R$ 值下的单次过载)：$N=50$，$K_{\\mathrm{nom}}=15.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，分段 $\\left[(50,\\,0.1)\\right]$，过载事件 $\\left[(10,\\,1.5)\\right]$，表示在循环 10 时设置 $K_{\\max}(10)=1.5\\,K_{\\mathrm{nom}}$。\n- 用例 3 (加载块中段 $R$ 比值增加，且有前期过载)：$N=60$，$K_{\\mathrm{nom}}=14.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，分段 $\\left[(20,\\,0.1),(20,\\,0.6),(20,\\,0.1)\\right]$，过载事件 $\\left[(15,\\,1.4)\\right]$。\n- 用例 4 (高 $R$ 值伴随大的过载，导致暂时的 $\\Delta K_{\\mathrm{eff}}=0$)：$N=40$，$K_{\\mathrm{nom}}=10.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，分段 $\\left[(40,\\,0.8)\\right]$，过载事件 $\\left[(5,\\,1.8)\\right]$。\n- 用例 5 (负 $R$ 值基线伴随适度过载)：$N=40$，$K_{\\mathrm{nom}}=12.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，分段 $\\left[(40,\\,-0.3)\\right]$，过载事件 $\\left[(20,\\,1.2)\\right]$。\n\n您的程序必须输出一行，其中包含测试套件的结果，格式为逗号分隔的列表之列表，其中每个内部列表包含恰好两个浮点数：$\\left[\\overline{\\Delta K_{\\mathrm{eff}}},\\,\\text{fraction}\\right]$。第一个数字必须是平均值 $\\overline{\\Delta K_{\\mathrm{eff}}}$，单位是 $\\mathrm{MPa}\\sqrt{\\mathrm{m}}$，第二个数字必须是比例（无单位）的小数表示。两个数字都必须四舍五入到小数点后六位。整体输出格式必须是\n$[\\,[\\overline{\\Delta K_{\\mathrm{eff}}}^{(1)},\\,f^{(1)}],\\,[\\overline{\\Delta K_{\\mathrm{eff}}}^{(2)},\\,f^{(2)}],\\,\\dots\\,]$,\n对于从 1 到 5 的五个有序用例。", "solution": "所提供的问题经评估有效。它提出了一个基于断裂力学领域唯象模型的、适定的、面向计算的任务。该模型虽然经过简化，但在科学上基于疲劳裂纹扩展中裂纹闭合和过载引起的延迟等已确立的概念。所有参数、初始条件和程序步骤都已清晰、无矛盾地指定，从而可以得到唯一解。该问题要求直接实现一个确定性的、逐循环的算法。\n\n目标是为五个不同的加载历史计算两个量：有效应力强度因子范围的算术平均值 $\\overline{\\Delta K_{\\mathrm{eff}}}$，以及 $\\Delta K_{\\mathrm{eff}}(n)$ 超过给定阈值 $\\Delta K_{\\mathrm{th}}$ 的循环比例 $f$。\n\n解决方案是通过开发一个计算算法来推进，该算法精确地遵循为每个循环 $n$（从 1 到 $N$）指定的递推关系。系统的状态由单个内变量 $z$ 来表征，它代表了先前过载事件的记忆。\n\n首先，为每个测试用例构建完整的加载历史，包括最大应力强度因子 $K_{\\max}(n)$ 和载荷比 $R(n)$ 的逐循环值。对于所有未指定为过载的循环，$K_{\\max}(n)$ 设置为名义基线 $K_{\\mathrm{nom}}$。在指定的过载循环中，根据给定的过载比率提高 $K_{\\max}(n)$。载荷比 $R(n)$ 根据指定的段进行设置。\n\n然后，模拟循环对 $n=1, 2, \\dots, N$ 进行。记忆状态变量初始化为 $z(0^+) = 0$。对于每个循环 $n$，按顺序计算以下量：\n\n1.  最小应力强度因子由输入确定：$K_{\\min}(n) = R(n) K_{\\max}(n)$。\n2.  计算内在或基线裂纹张开应力强度因子，它仅取决于当前循环的参数：\n    $$\n    K_{\\mathrm{op,base}}(n) = K_{\\min}(n) + \\chi \\left(K_{\\max}(n) - K_{\\min}(n)\\right)\n    $$\n    此处，材料参数 $\\chi=0.3$。\n3.  通过考虑基线值和先前循环的记忆效应（由 $z((n-1)^+)$ 表示，即循环 $n-1$ 完成后的状态）来确定起作用的裂纹张开水平 $K_{\\mathrm{op}}(n)$：\n    $$\n    K_{\\mathrm{op}}(n) = \\min\\left(K_{\\max}(n), K_{\\mathrm{op,base}}(n) + z((n-1)^+)\\right)\n    $$\n    这个公式正确地确保了 $K_{\\mathrm{op}}(n)$ 不会超过 $K_{\\max}(n)$。\n4.  然后计算当前循环的有效应力强度因子范围。这是加载循环中对裂纹扩展有贡献的部分：\n    $$\n    \\Delta K_{\\mathrm{eff}}(n) = \\max\\left(0, K_{\\max}(n) - K_{\\mathrm{op}}(n)\\right)\n    $$\n    计算出的 $\\Delta K_{\\mathrm{eff}}(n)$ 值被存储起来用于后续的统计分析。\n5.  最后，记忆状态变量 $z$ 更新为其新值 $z(n^+)$，该值将被带到下一个循环 $n+1$。更新规则捕捉了现有记忆的几何衰减，以及如果当前循环相对于 $K_{\\mathrm{nom}}$ 是一个过载，则会增加一个新项：\n    $$\n    z(n^+) = \\rho \\, z((n-1)^+) + c_{\\mathrm{ol}}\\,\\max\\left(0, K_{\\max}(n) - K_{\\mathrm{nom}}\\right)\n    $$\n    此演化的材料参数为保留因子 $\\rho=0.9$ 和过载敏感度 $c_{\\mathrm{ol}}=0.6$。\n\n在遍历所有 $N$ 个循环后，收集到的 $\\Delta K_{\\mathrm{eff}}(n)$ 值历史记录用于计算所需的输出。算术平均值计算为 $\\overline{\\Delta K_{\\mathrm{eff}}} = \\frac{1}{N} \\sum_{n=1}^{N} \\Delta K_{\\mathrm{eff}}(n)$。超过阈值的循环比例计算为 $f = \\frac{1}{N} \\left| \\left\\{ n \\mid \\Delta K_{\\mathrm{eff}}(n) \\ge \\Delta K_{\\mathrm{th}} \\right\\} \\right|$，其中 $\\Delta K_{\\mathrm{th}} = 6.0~\\mathrm{MPa}\\sqrt{\\mathrm{m}}$。\n\n这一系列操作在随附的 Python 程序中实现，该程序的结构是为了处理五个指定的测试用例中的每一个，并根据规定的输出要求格式化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the crack closure simulation for all test cases and print results.\n    \"\"\"\n\n    # Fixed material parameters\n    CHI = 0.3\n    C_OL = 0.6\n    RHO = 0.9\n    DELTA_K_TH = 6.0  # MPa sqrt(m)\n\n    # Test suite definition\n    test_cases = [\n        # Case 1\n        {'N': 50, 'K_nom': 15.0, 'segments': [(50, 0.1)], 'overloads': []},\n        # Case 2\n        {'N': 50, 'K_nom': 15.0, 'segments': [(50, 0.1)], 'overloads': [(10, 1.5)]},\n        # Case 3\n        {'N': 60, 'K_nom': 14.0, 'segments': [(20, 0.1), (20, 0.6), (20, 0.1)], 'overloads': [(15, 1.4)]},\n        # Case 4\n        {'N': 40, 'K_nom': 10.0, 'segments': [(40, 0.8)], 'overloads': [(5, 1.8)]},\n        # Case 5\n        {'N': 40, 'K_nom': 12.0, 'segments': [(40, -0.3)], 'overloads': [(20, 1.2)]},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(\n            N=case['N'],\n            K_nom=case['K_nom'],\n            segments=case['segments'],\n            overloads=case['overloads'],\n            chi=CHI,\n            c_ol=C_OL,\n            rho=RHO,\n            delta_K_th=DELTA_K_TH\n        )\n        all_results.append(result)\n    \n    # Format the final output string exactly as specified\n    results_str_list = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in all_results]\n    print(f\"[{','.join(results_str_list)}]\")\n\n\ndef run_simulation(N, K_nom, segments, overloads, chi, c_ol, rho, delta_K_th):\n    \"\"\"\n    Performs the cycle-by-cycle simulation for a single test case.\n\n    Args:\n        N (int): Total number of cycles.\n        K_nom (float): Nominal baseline K_max.\n        segments (list): List of (n_seg, R_seg) tuples defining R-ratio history.\n        overloads (list): List of (cycle_idx, ol_factor) tuples for overloads.\n        chi (float): Material parameter for K_op,base.\n        c_ol (float): Material parameter for overload sensitivity.\n        rho (float): Material parameter for memory retention.\n        delta_K_th (float): Threshold for crack growth.\n\n    Returns:\n        list: A list containing [mean_delta_K_eff, fraction_above_threshold].\n    \"\"\"\n    \n    # 1. Construct loading history arrays\n    K_max_history = np.full(N, K_nom, dtype=float)\n    R_history = np.zeros(N, dtype=float)\n\n    # Populate R_history from segments\n    current_cycle_idx = 0\n    for n_seg, R_seg in segments:\n        R_history[current_cycle_idx : current_cycle_idx + n_seg] = R_seg\n        current_cycle_idx += n_seg\n\n    # Apply overloads to K_max_history\n    for cycle_idx, ol_factor in overloads:\n        # Problem uses 1-based indexing for cycles\n        K_max_history[cycle_idx - 1] = ol_factor * K_nom\n\n    # 2. Run cycle-by-cycle simulation\n    z_memory = 0.0  # Represents z(0+), the state before cycle 1\n    delta_K_eff_history = np.zeros(N, dtype=float)\n\n    for n in range(N):  # Loop for cycles 1 to N (using 0-based index n)\n        # State at the beginning of cycle n+1 is z((n)+), which is z_memory\n        #\n        # Retrieve current cycle's loading parameters\n        K_max_n = K_max_history[n]\n        R_n = R_history[n]\n\n        # Step 1: K_min\n        K_min_n = R_n * K_max_n\n\n        # Step 2: K_op,base\n        K_op_base_n = K_min_n + chi * (K_max_n - K_min_n)\n        \n        # Step 3: K_op\n        # Uses z_memory, which is the state from the end of the previous cycle z((n-1)+)\n        K_op_n = min(K_max_n, K_op_base_n + z_memory)\n\n        # Step 4: Delta_K_eff\n        delta_K_eff_n = max(0.0, K_max_n - K_op_n)\n        delta_K_eff_history[n] = delta_K_eff_n\n        \n        # Step 5: Update memory state z for the next cycle\n        z_update_term = c_ol * max(0.0, K_max_n - K_nom)\n        z_memory = rho * z_memory + z_update_term\n    \n    # 3. Calculate and return final statistics\n    mean_delta_K_eff = np.mean(delta_K_eff_history)\n    \n    num_above_thresh = np.sum(delta_K_eff_history >= delta_K_th)\n    fraction_above_thresh = num_above_thresh / N\n    \n    return [mean_delta_K_eff, fraction_above_thresh]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2925941"}]}