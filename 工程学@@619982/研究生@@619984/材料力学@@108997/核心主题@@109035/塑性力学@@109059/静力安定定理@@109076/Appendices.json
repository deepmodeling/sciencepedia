{"hands_on_practices": [{"introduction": "本练习探讨了安定理论中最基本的情景之一：一个受约束的杆在循环温度变化下的响应。通过构建一个时不变的残余应力场，我们将运用Melan静力安定定理来确定结构能够避免循环塑性变形的临界条件。这个实践旨在揭示残余应力在帮助结构“适应”循环载荷、最终实现纯弹性响应中的核心作用，从而为理解更复杂的安定问题奠定基础。", "problem": "一根长度为 $L$、横截面积恒定的直棱柱形均匀各向同性杆，其两端在轴向位移上受到完全约束。该材料遵循小应变、率无关的线性弹性规律，杨氏模量为 $E$。在单轴拉伸/压缩下，当应力达到屈服应力 $\\sigma_{y}$ 时发生屈服，此后材料表现为理想塑性。该杆具有恒定的线性热膨胀系数 $\\alpha$。杆件承受一个空间上均匀、准静态的温度历史 $T(t)$，该温度围绕一个无初始应力的参考温度，在 $-\\Delta T$ 和 $+\\Delta T$ 之间对称地重复循环。\n\n使用 Melan 的静力安定定理和叠加一个不随时间变化的残余应力场的思想，按以下步骤进行：\n\n- 令 $\\sigma^{e}(t)$ 表示在给定的热载荷下，若塑性应变始终被约束为零，且满足两端完全固定的轴向协调条件时所产生的弹性应力场。令 $\\sigma^{r}$ 为一个不随时间变化的残余应力，假设其在杆的横截面上均匀分布，并沿杆的长度方向保持恒定。要求应力场 $\\sigma^{e}(t)+\\sigma^{r}$ 在循环过程中的所有时刻都保持在弹性域内，即强制满足 $|\\sigma^{e}(t)+\\sigma^{r}|\\le \\sigma_{y}$。\n\n- 推导最大温度幅值 $\\Delta T_{\\text{crit}}$，使得存在至少一个常数 $\\sigma^{r}$，能让上述条件在整个对称循环 $T(t)\\in[-\\Delta T,\\,+\\Delta T]$ 期间都成立。您的推导必须从基本的运动学和本构关系出发，除了安定条件的陈述外，不得假设任何专门的公式。\n\n将您关于 $\\Delta T_{\\text{crit}}$ 的最终答案表示为由 $E$、$\\sigma_{y}$ 和 $\\alpha$ 构成的单个闭式解析表达式。最终结果必须不带单位书写，但为了便于解释，$\\Delta T_{\\text{crit}}$ 应以开尔文（Kelvin）为单位。", "solution": "所述问题是有效的。这是一个在热弹塑性力学和结构力学领域内，具有科学依据的适定问题，特别涉及 Melan 静力安定定理的应用。所有必要信息均已提供，目标明确且可形式化。我们将着手进行推导。\n\n问题要求找到最大温度幅值 $\\Delta T_{\\text{crit}}$，使得一根两端完全约束的单轴受载杆能够发生安定。安定意味着在经历一段有限的初始塑性变形后，结构的响应变为纯弹性的，塑性应变的累积停止。Melan 的静力安定定理为这种情况的发生提供了条件。该定理指出，如果能够找到一个不随时间变化、自平衡的残余应力场 $\\sigma^{r}$，使得该残余应力与纯弹性应力解 $\\sigma^{e}(t)$ 之和在结构各处、在所有载荷变化情况下都满足屈服准则，那么安定就会发生。\n\n首先，我们必须确定纯弹性应力场 $\\sigma^{e}(t)$。杆是完全受约束的，这意味着总轴向应变 $\\epsilon_{\\text{total}}$ 在任何时候都必须为零。\n总应变是弹性应变($\\epsilon^{e}$)、塑性应变($\\epsilon^{p}$)和热应变($\\epsilon^{th}$)的总和：\n$$ \\epsilon_{\\text{total}} = \\epsilon^{e} + \\epsilon^{p} + \\epsilon^{th} $$\n由于杆的两端是固定的，总伸长量为零，因此 $\\epsilon_{\\text{total}} = 0$。\n问题要求的是纯弹性应力响应，这是一个假设的应力场，它是通过假设材料行为是纯弹性的（即为此计算目的将塑性应变约束为零，$\\epsilon^{p}=0$）来计算的。\n因此，弹性分析的协调条件变为：\n$$ \\epsilon^{e} + \\epsilon^{th} = 0 $$\n热应变由 $\\epsilon^{th}(t) = \\alpha T(t)$ 给出，其中 $\\alpha$ 是热膨胀系数，$T(t)$ 是相对于无应力参考状态的温度变化。\n弹性应变通过单轴应力的胡克定律与弹性应力 $\\sigma^{e}$ 相关联：$\\epsilon^{e}(t) = \\frac{\\sigma^{e}(t)}{E}$，其中 $E$ 是杨氏模量。\n将这些本构关系代入协调方程，得到：\n$$ \\frac{\\sigma^{e}(t)}{E} + \\alpha T(t) = 0 $$\n由此，我们求解出纯弹性应力作为温度的函数：\n$$ \\sigma^{e}(t) = -E \\alpha T(t) $$\n温度 $T(t)$ 在 $-\\Delta T$ 和 $+\\Delta T$ 之间对称循环。因此，我们可以确定在一个循环中弹性应力的最小值和最大值。\n最大弹性应力 $\\sigma^{e}_{\\text{max}}$ 出现在最低温度 $T = -\\Delta T$ 时：\n$$ \\sigma^{e}_{\\text{max}} = -E \\alpha (-\\Delta T) = E \\alpha \\Delta T $$\n这对应于拉应力。\n最小弹性应力 $\\sigma^{e}_{\\text{min}}$ 出现在最高温度 $T = +\\Delta T$ 时：\n$$ \\sigma^{e}_{\\text{min}} = -E \\alpha (+\\Delta T) = -E \\alpha \\Delta T $$\n这对应于压应力。\n\n现在，我们应用 Melan 的安定定理。我们将一个不随时间变化、空间均匀的残余应力 $\\sigma^{r}$ 叠加到弹性应力场上。任意时刻的总应力为 $\\sigma(t) = \\sigma^{e}(t) + \\sigma^{r}$。为使安定发生，该总应力必须在所有时刻 $t$ 都保持在弹性域内。理想塑性材料的屈服准则是 $|\\sigma| \\le \\sigma_{y}$，其中 $\\sigma_{y}$ 是屈服应力。\n因此，安定条件是：\n$$ |\\sigma^{e}(t) + \\sigma^{r}| \\le \\sigma_{y} \\quad \\text{for all } t $$\n这个不等式等价于两个必须在所有时刻同时满足的条件：\n$$ -\\sigma_{y} \\le \\sigma^{e}(t) + \\sigma^{r} \\le \\sigma_{y} $$\n为使这些不等式在整个循环中都成立，它们必须在最关键的点（即弹性应力最大和最小的点）成立。\n第一个不等式 $\\sigma^{e}(t) + \\sigma^{r} \\le \\sigma_{y}$ 在 $\\sigma^{e}(t)$ 为最大值时最为严格。因此，我们必须满足：\n$$ \\sigma^{e}_{\\text{max}} + \\sigma^{r} \\le \\sigma_{y} \\quad (1) $$\n第二个不等式 $\\sigma^{e}(t) + \\sigma^{r} \\ge -\\sigma_{y}$ 在 $\\sigma^{e}(t)$ 为最小值时最为严格。因此，我们必须满足：\n$$ \\sigma^{e}_{\\text{min}} + \\sigma^{r} \\ge -\\sigma_{y} \\quad (2) $$\n这两个不等式为残余应力 $\\sigma^{r}$ 的可能取值定义了一个范围：\n从 (1) 式可得：\n$$ \\sigma^{r} \\le \\sigma_{y} - \\sigma^{e}_{\\text{max}} $$\n从 (2) 式可得：\n$$ \\sigma^{r} \\ge -\\sigma_{y} - \\sigma^{e}_{\\text{min}} $$\n一个有效的残余应力 $\\sigma^{r}$ 存在的充要条件是，$\\sigma^{r}$ 的下界小于或等于其上界：\n$$ -\\sigma_{y} - \\sigma^{e}_{\\text{min}} \\le \\sigma_{y} - \\sigma^{e}_{\\text{max}} $$\n重新整理此不等式，将弹性和屈服应力项归类，我们得到：\n$$ \\sigma^{e}_{\\text{max}} - \\sigma^{e}_{\\text{min}} \\le 2\\sigma_{y} $$\n这是对称载荷循环中发生安定的基本条件。它表明，纯弹性应力的总范围 $\\Delta\\sigma^{e} = \\sigma^{e}_{\\text{max}} - \\sigma^{e}_{\\text{min}}$ 不得超过屈服应力的两倍。\n现在让我们代入 $\\sigma^{e}_{\\text{max}}$ 和 $\\sigma^{e}_{\\text{min}}$ 的表达式：\n$$ (E \\alpha \\Delta T) - (-E \\alpha \\Delta T) \\le 2\\sigma_{y} $$\n$$ 2 E \\alpha \\Delta T \\le 2\\sigma_{y} $$\n简化这个不等式，得到使安定成为可能的温度幅值 $\\Delta T$ 的条件：\n$$ \\Delta T \\le \\frac{\\sigma_{y}}{E \\alpha} $$\n问题要求的是能够发生安定的最大温度幅值 $\\Delta T_{\\text{crit}}$。这对应于不等式变为等式的边界情况。\n因此，临界温度幅值为：\n$$ \\Delta T_{\\text{crit}} = \\frac{\\sigma_{y}}{E \\alpha} $$\n如果 $\\Delta T > \\Delta T_{\\text{crit}}$，弹性应力范围 $2 E \\alpha \\Delta T$ 将大于 $2\\sigma_{y}$，就不可能找到一个残余应力 $\\sigma^r$ 使得总应力在整个循环中保持在屈服极限内。在这种情况下，结构将表现出棘轮效应或交变塑性，意味着每个循环都会发生塑性变形，而无法实现安定。", "answer": "$$\\boxed{\\frac{\\sigma_{y}}{E \\alpha}}$$", "id": "2916218"}, {"introduction": "在掌握了单个构件的安定分析后，我们将注意力转向一个简单的结构体系——门式刚架。这个练习要求我们同时运用Melan静力（下限）安定定理和Koiter运动（上限）安定定理，来确定该结构的精确安定极限。通过证明这两个理论所给出的安定载荷乘子上下限在此问题中完全重合，本实践深刻地展示了安定理论的完备性与强大分析能力。", "problem": "考虑一个单跨单层刚接门式框架，由两根高度为 $h$ 的相同等截面柱，通过一根具有有效无限抗弯强度的刚性梁连接而成。材料表现为理想弹塑性，在两根柱的顶部和底部的潜在塑性铰位置，具有均匀的全塑性弯矩承载力 $M_p$。适用小位移运动学，且可忽略几何非线性。无竖向重力荷载。\n\n该结构承受一个施加在梁上的准静态、零均值、重复水平集中荷载，其形式为 $H(t)=\\lambda\\,H_0\\,s(t)$，其中 $H_0>0$ 是给定的参考荷载，$\\lambda>0$ 是一个未知的标量荷载乘子，$s(t)$ 是任何有界标量函数，满足在所有时间 $t$ 都有 $-1\\le s(t)\\le 1$，并在重复循环中取遍该区间内的所有极值。假设塑性是关联的、率无关的、无硬化的，且塑性变形仅以理想塑性铰的形式在柱顶和柱底局部化。\n\n仅使用刚塑性机构的基本运动学、虚功原理以及Melan静力安定定理（下限）和Koiter运动安定定理（上限）的定义，完成以下任务：\n\n- 构建一个静力容许、不随时变的残余弯矩场，以通过Melan静力安定定理证明对于某个最大的 $\\lambda$ 可以发生安定，并推导出相应的 $\\lambda$ 的下限。\n\n- 构建一个运动容许、形状不随时变的单参数塑性机构，该机构与框架和荷载集相容，并使用Koiter运动安定定理推导出相应的 $\\lambda$ 的上限。\n\n证明对于此框架和荷载，这两个界限重合，并以 $M_p$、$h$ 和 $H_0$ 的闭合形式表达式，得出精确的安定乘子 $\\lambda_{\\mathrm{sh}}$。\n\n你的最终答案必须是 $\\lambda_{\\mathrm{sh}}$ 的单一解析表达式。请用 $M_p$、$h$ 和 $H_0$ 的符号形式表达你的最终答案。在最终方框内的答案中不要包含单位。", "solution": "问题陈述需经验证。\n\n**步骤 1：提取已知条件**\n- 结构：单跨单层刚接门式框架。\n- 柱：两根相同的等截面柱，高度为 $h$。\n- 梁：刚性，抗弯强度无限。\n- 材料行为：理想弹塑性。\n- 塑性承载力：在柱顶和柱底具有均匀的全塑性弯矩 $M_p$。\n- 运动学：适用小位移理论；忽略几何非线性。\n- 重力荷载：无。\n- 荷载：施加于梁的准静态、零均值、重复水平集中荷载 $H(t)=\\lambda\\,H_0\\,s(t)$。\n- 荷载参数：$H_0>0$（参考荷载），$\\lambda>0$（荷载乘子），时间函数 $s(t)$ 有界，即在所有时间 $t$ 内满足 $-1 \\le s(t) \\le 1$，并覆盖此区间内的所有值。\n- 塑性模型：关联、率无关、无硬化，塑性变形局部化为四个理想铰位置（柱顶和柱底）。\n\n**步骤 2：使用提取的已知条件进行验证**\n- 该问题是**有科学依据的**。它是结构塑性安定理论中的一个经典问题，运用了Melan和Koiter的基本定理。其假设（理想弹塑性材料、理想铰、刚性梁）是结构分析中的标准理想化。\n- 该问题是**适定的**。几何形状、材料属性和荷载都已明确定义。目标是找到一个特定的、唯一的值，即安定乘子 $\\lambda_{\\mathrm{sh}}$。\n- 该问题是**客观的**。其语言技术性强且精确，没有主观或含糊的术语。\n- 问题陈述是自洽的，不包含矛盾信息。所做的理想化与求解所需的方法（安定定理）是一致的。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将提供解答。\n\n**弹性响应分析**\n\n该门式框架在几何上对称，荷载水平施加在梁上。梁被指定为具有无限抗弯强度，意味着它是刚性的，不会弯曲。由于结构和荷载的整体对称性，刚性梁将在没有转动的情况下水平平移。因此，两根柱的顶部经历相等的水平位移 $\\Delta(t)$，但没有转动。柱的底部是固定的，因此既不发生平移也不发生转动。\n\n因此，每根高度为 $h$ 的柱都处于双端固定状态（底部固定，顶部抗转动固定），并承受侧向剪力。总水平荷载 $H(t)$ 平均分配给两根相同的柱，所以每根柱中的剪力为 $V(t) = \\frac{H(t)}{2}$。\n\n对于一根高度为 $h$、两端固定并承受剪力 $V$ 的柱，其顶部和底部的弯矩大小相等、方向相同。端部弯矩 $M$ 与剪力 $V$ 之间的关系由 $M_{top} + M_{base} = V h$ 给出。由于 $M_{top} = M_{base} = M^E$，我们有 $2M^E = Vh$，即 $M^E = \\frac{Vh}{2}$。\n\n代入 $V(t) = \\frac{H(t)}{2}$，在所有四个潜在塑性铰位置（每根柱的顶部和底部），弹性弯矩 $M^E(t)$ 是相同的：\n$$ M^E(t) = \\frac{1}{2} \\left( \\frac{H(t)}{2} \\right) h = \\frac{H(t)h}{4} $$\n使用给定的荷载表达式 $H(t) = \\lambda H_0 s(t)$，弹性弯矩为：\n$$ M^E(t) = \\frac{\\lambda H_0 h}{4} s(t) $$\n由于函数 $s(t)$ 在区间 $[-1, 1]$ 内变化，因此在四个位置中每个位置的弹性弯矩包络为：\n$$ M^E_{max} = \\frac{\\lambda H_0 h}{4} $$\n$$ M^E_{min} = -\\frac{\\lambda H_0 h}{4} $$\n因此，弹性弯矩的范围是：\n$$ \\Delta M^E = M^E_{max} - M^E_{min} = \\frac{\\lambda H_0 h}{4} - \\left(-\\frac{\\lambda H_0 h}{4}\\right) = \\frac{\\lambda H_0 h}{2} $$\n\n**使用Melan静力定则计算$\\lambda_{\\mathrm{sh}}$的下限**\n\nMelan定理指出，如果存在一个不随时变的、自平衡的残余弯矩场 $M^r$，使得弹性弯矩 $M^E(t)$ 和残余弯矩 $M^r$ 的叠加在任何点和任何时间都不违反屈服条件，那么结构将会安定（即，在经历一个初始的塑性变形阶段后，完全弹性地响应）。屈服条件为 $|M| \\le M_p$。\n\n因此，为使安定发生，我们必须找到一个自平衡的 $M^r$ 场，使得对于每个潜在的铰位置 $i$：\n$$ |M^E_i(t) + M^r_i| \\le M_p \\quad \\forall t $$\n由于所有四个位置的弹性弯矩都相同，我们可以去掉 $M^E$ 的下标 $i$。该条件等价于两个不等式：\n$$ M^E_{max} + M^r_i \\le M_p $$\n$$ M^E_{min} + M^r_i \\ge -M_p $$\n代入 $M^E_{max}$ 和 $M^E_{min}$ 的表达式：\n$$ \\frac{\\lambda H_0 h}{4} + M^r_i \\le M_p \\implies M^r_i \\le M_p - \\frac{\\lambda H_0 h}{4} $$\n$$ -\\frac{\\lambda H_0 h}{4} + M^r_i \\ge -M_p \\implies M^r_i \\ge -M_p + \\frac{\\lambda H_0 h}{4} $$\n为了使 $M^r_i$ 的值存在，下界必须小于或等于上界：\n$$ -M_p + \\frac{\\lambda H_0 h}{4} \\le M_p - \\frac{\\lambda H_0 h}{4} $$\n$$ \\frac{\\lambda H_0 h}{2} \\le 2 M_p $$\n$$ \\lambda \\le \\frac{4 M_p}{H_0 h} $$\n这个不等式确立了任何安定解可能存在的 $\\lambda$ 的最大值。为了确认这是一个可实现的下限，我们必须证明对于这个 $\\lambda$ 值，存在一个有效的自平衡残余弯矩场。\n\n让我们测试特定的荷载乘子 $\\lambda = \\frac{4 M_p}{H_0 h}$。对于这个值，对 $M^r_i$ 的条件变为：\n$$ M^r_i \\le M_p - \\frac{1}{4} \\left(\\frac{4 M_p}{H_0 h}\\right) H_0 h = M_p - M_p = 0 $$\n$$ M^r_i \\ge -M_p + \\frac{1}{4} \\left(\\frac{4 M_p}{H_0 h}\\right) H_0 h = -M_p + M_p = 0 $$\n这两个条件共同要求对于所有四个位置 $i=1,2,3,4$，都有 $M^r_i = 0$。平庸场 $M^r_i = 0$ 是一个有效的自平衡残余弯矩场。\n因此，根据Melan定理，当 $\\lambda \\le \\frac{4 M_p}{H_0 h}$ 时，结构保证会安定。这为安定乘子提供了下限：\n$$ \\lambda_{\\mathrm{sh}} \\ge \\frac{4 M_p}{H_0 h} $$\n\n**使用Koiter运动定则计算$\\lambda_{\\mathrm{sh}}$的上限**\n\nKoiter定理指出，如果可以找到一个运动容许的塑性机构，使得弹性应力在一个塑性变形循环中所做的功大于或等于塑性机构内部耗散的能量，则安定不会发生。失效可能以增量坍塌（棘轮效应）或交变塑性（低周疲劳）的形式发生。由于施加的荷载是零均值的，增量坍塌不是预期的失效模式。我们研究由交变塑性引起的失效。\n\n如果某位置的弹性应力（或弯矩）范围超过屈服强度（或塑性弯矩承载力）的两倍，则该位置会发生交变塑性。我们可以通过构建一个合适的塑性变形循环来用Koiter定理形式化这一点。\n\n考虑一个运动容许的机构，它由单个铰位置（例如，左柱底部的位置1）的塑性循环组成。假设此循环包含一个 $+\\Delta\\theta_p$ 的塑性转动，然后是一个 $-\\Delta\\theta_p$ 的塑性转动，使铰恢复到其原始方向。\n\n在此循环中耗散的总内能为：\n$$ D_{cycle} = \\int_{cycle} |M_p d\\theta_p| = M_p |+\\Delta\\theta_p| + M_p |-\\Delta\\theta_p| = 2M_p \\Delta\\theta_p $$\n弹性弯矩 $M_1^E(t)$ 在此塑性循环中所做的功为 $W^E_{cycle} = \\int_{cycle} M_1^E(t) d\\theta_p(t)$。为获得安定的上限（即，找到失效必然发生的荷载），我们考虑最不利的情况，即此功达到最大。这种情况发生在正塑性转动 $+\\Delta\\theta_p$ 恰好在弹性弯矩 $M_1^E(t)$ 达到其最大值 $M^E_{max}$ 时发生，而负转动 $-\\Delta\\theta_p$ 在弯矩达到其最小值 $M^E_{min}$ 时发生。\n$$ W^E_{cycle, max} = M^E_{max} (\\Delta\\theta_p) + M^E_{min} (-\\Delta\\theta_p) = (M^E_{max} - M^E_{min}) \\Delta\\theta_p = \\Delta M^E \\Delta\\theta_p $$\n代入弹性弯矩范围 $\\Delta M^E = \\frac{\\lambda H_0 h}{2}$：\n$$ W^E_{cycle, max} = \\frac{\\lambda H_0 h}{2} \\Delta\\theta_p $$\n根据Koiter定理，如果 $W^E_{cycle, max} \\ge D_{cycle}$，则安定失效是必然的。\n$$ \\frac{\\lambda H_0 h}{2} \\Delta\\theta_p \\ge 2M_p \\Delta\\theta_p $$\n两边除以 $\\Delta\\theta_p > 0$：\n$$ \\frac{\\lambda H_0 h}{2} \\ge 2M_p \\implies \\lambda \\ge \\frac{4 M_p}{H_0 h} $$\n此条件为安定乘子提供了上限。如果 $\\lambda$ 大于或等于此值，结构必然会失效。\n$$ \\lambda_{\\mathrm{sh}} \\le \\frac{4 M_p}{H_0 h} $$\n\n**结论**\n\n通过Melan定理的静力（下限）分析得出 $\\lambda_{\\mathrm{sh}} \\ge \\frac{4 M_p}{H_0 h}$。\n通过Koiter定理的运动（上限）分析得出 $\\lambda_{\\mathrm{sh}} \\le \\frac{4 M_p}{H_0 h}$。\n\n由于安定乘子的下限和上限重合，我们确定了其精确值：\n$$ \\lambda_{\\mathrm{sh}} = \\frac{4 M_p}{H_0 h} $$\n该值对应于结构的弹性极限，即最大弹性弯矩等于塑性弯矩承载力。对于这个具有零均值循环荷载的特定问题，不存在一个荷载乘子区间，使得有限的塑性变形能够导致有利的残余应力状态和随后的弹性安定。一旦达到弹性极限，失效就会因交变塑性而发生。", "answer": "$$\n\\boxed{\\frac{4 M_p}{H_0 h}}\n$$", "id": "2684276"}, {"introduction": "为了将安定理论与现代工程实践相结合，本练习将引导我们将抽象的安定条件转化为一种可计算的数学模型。我们将学习如何把基于Melan定理的静力安定问题构建成一个线性规划（Linear Programming, LP）问题，从而可以用数值方法求解复杂结构在任意载荷组合下的最大安定载荷因子。这个实践旨在弥合理论推导与计算实现之间的鸿沟，展示了安定理论在现代计算结构分析中的实际应用。", "problem": "考虑基于 Melan 定理在离散应力空间上建立的静力（下界）安定验证。设结构由应力合力向量 $s \\in \\mathbb{R}^n$ 和一个不随时变的残余应力 $r \\in \\mathbb{R}^n$ 表示。设容许应力域为多面体集 $\\{s \\in \\mathbb{R}^n : \\lvert s_i \\rvert \\le \\sigma_y, \\, i = 1,\\dots,n\\}$，其中给定的屈服极限 $\\sigma_y \\gt 0$（这是无穷范数 Tresca 型近似）。设残余应力的平衡由一个满秩线性算子 $E \\in \\mathbb{R}^{q \\times n}$ 表示，使得容许的残余应力满足 $E r = 0$。设荷载在一个凸紧集内变化，其极点由 $m$ 个弹性应力影响向量 $\\{p^{(k)} \\in \\mathbb{R}^n\\}_{k=1}^m$ 表示。对于一个荷载因子 $\\lambda \\ge 0$，Melan 静力安定条件要求存在一个残余应力 $r$，使得对于每个极端荷载 $k \\in \\{1,\\dots,m\\}$，\n$$\nr + \\lambda \\, p^{(k)} \\in \\{s \\in \\mathbb{R}^n : \\lvert s_i \\rvert \\le \\sigma_y, \\, i=1,\\dots,n\\},\n\\quad \\text{and} \\quad E r = 0.\n$$\n根据线性和凸性，只需在有限的极值点集上检验这些不等式。\n\n任务：\n- 从基本原理出发，推导一个线性规划公式，用于计算最大安定荷载因子 $\\lambda^\\star$，并在所有能达到 $\\lambda^\\star$ 的残余应力中，选择一个具有最小 $\\ell_1$ 范数的残余应力。您必须通过以下步骤完成：\n  1. 建立一个关于变量 $(r,\\lambda)$ 的线性规划，在 $m$ 个给定荷载极值下的平衡与屈服约束下，最大化 $\\lambda$。\n  2. 建立第二个关于变量 $(r,t)$ 的线性规划，在将 $\\lambda$ 固定为最优值 $\\lambda^\\star$ 的情况下，最小化 $\\sum_{i=1}^n t_i$，其约束条件为 $t_i \\ge \\lvert r_i \\rvert$、相同的平衡约束以及在 $\\lambda^\\star$ 下计算的相同屈服约束。\n- 您的程序必须仅使用数据 $(\\sigma_y, E, \\{p^{(k)}\\}_{k=1}^m)$ 来实现这两个线性规划。\n\n程序需要编码的数学公式要求：\n- 对第一个线性规划，使用残余应力 $r \\in \\mathbb{R}^n$ 和荷载因子 $\\lambda \\in \\mathbb{R}$ 作为决策变量。施加 $\\lambda \\ge 0$。对于每个极值 $k \\in \\{1,\\dots,m\\}$ 和分量 $i \\in \\{1,\\dots,n\\}$，通过以下一对线性不等式强制实施屈服容许性：\n$$\nr_i + \\lambda \\, p^{(k)}_i \\le \\sigma_y, \\qquad -r_i - \\lambda \\, p^{(k)}_i \\le \\sigma_y,\n$$\n并通过 $E r = 0$ 施加平衡约束。最大化 $\\lambda$。\n- 对第二个线性规划，固定 $\\lambda = \\lambda^\\star$ 并引入辅助变量 $t \\in \\mathbb{R}^n$，其中 $t_i \\ge 0$ 且\n$$\nr_i - t_i \\le 0, \\qquad -r_i - t_i \\le 0,\n$$\n这共同意味着 $t_i \\ge \\lvert r_i \\rvert$。在这些约束、 $E r = 0$ 以及将 $\\lambda$ 替换为 $\\lambda^\\star$ 的相同屈服约束下，最小化 $\\sum_{i=1}^n t_i$。\n\n实现与输出：\n- 实现一个程序，对于下述每个测试用例，返回一对 $[\\lambda^\\star, \\|r^\\star\\|_1]$，其中 $\\lambda^\\star$ 是第一个线性规划的最优荷载因子，$\\|r^\\star\\|_1$ 是在 $\\lambda^\\star$ 下，第二个线性规划中 $\\sum_{i=1}^n t_i$ 的最优值。\n- 您的程序必须输出一行包含结果的内容，格式为逗号分隔的列表的列表，每个测试用例一个，每个浮点数四舍五入到 $6$ 位小数，例如，$\\big[\\,[\\lambda_1^\\star,\\|r_1^\\star\\|_1],[\\lambda_2^\\star,\\|r_2^\\star\\|_1]\\,\\big]$。\n\n测试套件：\n- 使用三种情况，每种由 $(n,m,\\sigma_y,E,\\{p^{(k)}\\}_{k=1}^m)$ 指定：\n  1. 情况 A（理想情况，对称极值）： $n = 2$, $m = 2$, $\\sigma_y = 1$, $E = \\begin{bmatrix} 1 & 1 \\end{bmatrix}$, $p^{(1)} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, $p^{(2)} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$。\n  2. 情况 B（通过平衡进行缩放与耦合）： $n = 2$, $m = 2$, $\\sigma_y = \\tfrac{3}{2}$, $E = \\begin{bmatrix} 1 & -1 \\end{bmatrix}$, $p^{(1)} = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$, $p^{(2)} = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。\n  3. 情况 C（需要非平凡残余应力的不对称极值）： $n = 2$, $m = 2$, $\\sigma_y = 1$, $E = \\begin{bmatrix} 1 & 1 \\end{bmatrix}$, $p^{(1)} = \\begin{bmatrix} 2 \\\\ -1 \\end{bmatrix}$, $p^{(2)} = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}$。\n\n最终输出格式：\n- 程序必须精确打印一行：一个包含三个条目的列表，每个条目是对应情况的列表 $[\\lambda^\\star,\\|r^\\star\\|_1]$，没有空格，且每个数字四舍五入到 $6$ 位小数，即 $\\big[\\,[\\lambda_A^\\star,\\|r_A^\\star\\|_1],[\\lambda_B^\\star,\\|r_B^\\star\\|_1],[\\lambda_C^\\star,\\|r_C^\\star\\|_1]\\,\\big]$。", "solution": "我们从 Melan 静力安定定理开始，该定理指出，如果一个结构承受的变动荷载来自一个凸紧的荷载域，那么只要存在一个不随时变、自平衡的残余应力 $r$，使得对于所有容许的荷载历史，总应力保持在弹性域内，结构就会安定下来（长期来看不会发生进一步的塑性变形）。在离散化设置中，对荷载的弹性应力响应可以表示为 $p \\in \\mathbb{R}^n$，容许应力域是一个凸集 $Y \\subset \\mathbb{R}^n$。静力（下界）陈述保证，如果存在 $r$ 满足 $E r = 0$，使得对于凸荷载集中的所有 $p$，对于某个最大 $\\lambda$，有 $r + \\lambda p \\in Y$，则结构会安定。因为荷载集是凸的，且约束 $r + \\lambda p \\in Y$ 对 $p$ 是凸的，所以只需在有限的多个极值点 $\\{p^{(k)}\\}_{k=1}^m$ 上进行检验。\n\n为了得到一个线性或二阶锥规划，我们必须选择 $Y$ 作为一个具有易于处理的不等式的凸集。如果我们选择 von Mises (J$_2$) 屈服域，条件 $\\|r + \\lambda p^{(k)}\\|_2 \\le \\sigma_y$ 是二阶锥可表示的。为了保持在线性规划的框架内，我们采用多面体 Tresca/无穷范数近似：\n$$\nY = \\{ s \\in \\mathbb{R}^n : -\\sigma_y \\le s_i \\le \\sigma_y, \\, i=1,\\dots,n \\}.\n$$\n然后，对于每个分量 $i$ 和极值 $k$，强制 $r + \\lambda p^{(k)} \\in Y$ 等价于一对线性不等式：\n$$\nr_i + \\lambda p^{(k)}_i \\le \\sigma_y, \\qquad -r_i - \\lambda p^{(k)}_i \\le \\sigma_y.\n$$\n此外，$r$ 必须是自平衡的，这由线性方程组 $E r = 0$ 编码。\n\n第一个线性规划（最大化荷载因子）。将决策变量集合为 $(r,\\lambda) \\in \\mathbb{R}^{n+1}$ 并施加 $\\lambda \\ge 0$。该线性规划为\n$$\n\\begin{aligned}\n\\max_{r \\in \\mathbb{R}^n,\\, \\lambda \\in \\mathbb{R}} \\ & \\lambda \\\\\n\\text{subject to } \\ & r_i + \\lambda p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n& -r_i - \\lambda p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n& E r = 0, \\\\\n& \\lambda \\ge 0,\n\\end{aligned}\n$$\n其中 $r$ 是自由变量。因为不同 $k$ 的约束将同一个 $r$ 与不同的 $\\lambda p^{(k)}$ 耦合，且 $E r = 0$ 限制了 $r$，所以对于非平凡的 $\\{p^{(k)}\\}$ 集合，该问题是适定的且有界的。\n\n第二个线性规划（在 $\\lambda^\\star$ 下的最小 $\\ell_1$ 范数残余应力）。固定从第一个规划中获得的 $\\lambda = \\lambda^\\star$，并引入辅助变量 $t \\in \\mathbb{R}^n$，满足 $t_i \\ge 0$ 和 $t_i \\ge \\lvert r_i \\rvert$。标准的线性化方法使用\n$$\nr_i - t_i \\le 0, \\qquad -r_i - t_i \\le 0, \\qquad t_i \\ge 0,\n$$\n这蕴含了 $t_i \\ge \\lvert r_i \\rvert$，因此 $\\sum_i t_i \\ge \\sum_i \\lvert r_i \\rvert = \\|r\\|_1$。最小化 $\\sum_i t_i$ 可以在所有能够承受 $\\lambda^\\star$ 的残余应力中，找到范数最小的那个。该线性规划为\n$$\n\\begin{aligned}\n\\min_{r \\in \\mathbb{R}^n,\\, t \\in \\mathbb{R}^n} \\ & \\sum_{i=1}^n t_i \\\\\n\\text{subject to } \\ & r_i + \\lambda^\\star p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n& -r_i - \\lambda^\\star p^{(k)}_i \\le \\sigma_y, \\quad i=1,\\dots,n,\\ k=1,\\dots,m, \\\\\n& r_i - t_i \\le 0, \\quad -r_i - t_i \\le 0, \\quad t_i \\ge 0, \\quad i=1,\\dots,n, \\\\\n& E r = 0.\n\\end{aligned}\n$$\n\n算法转化：\n- 通过堆叠的方式组装屈服约束的不等式矩阵。对于每个 $k$ 和 $i$，一行包含对 $r_i$ 和 $\\lambda$ 的系数，分别为 $1$ 和 $p^{(k)}_i$；另一行包含系数 $-1$ 和 $-p^{(k)}_i$。两种情况下的右侧项均为 $\\sigma_y$。\n- 对于第一个线性规划，使用目标向量 $c = [0,\\dots,0,-1]$ 来最小化 $- \\lambda$（即最大化 $\\lambda$）。\n- 对于第二个线性规划，将 $\\lambda = \\lambda^\\star$ 固定为常数，并为变量 $(r,t)$ 组装不等式，捕捉屈服和绝对值线性化两种约束，目标向量为 $c = [0,\\dots,0,1,\\dots,1]$，用于求和 $t_i$。\n- 在两个规划中都将 $E r = 0$ 作为等式约束强制实施。\n- 使用可靠的线性规划求解器求解。SciPy 的线性规划例程通过 HiGHS 后端支持这些功能。\n\n测试套件的原理与覆盖范围：\n- 情况 A 使用对称的极值和一个单一的平衡约束 $r_1 + r_2 = 0$，这会产生一个清晰、有界的最大荷载因子 $\\lambda^\\star$，并演示了多个极值如何耦合单个 $r$。\n- 情况 B 将屈服极限缩放至 $\\sigma_y = \\tfrac{3}{2}$，并使用 $E r = 0$ 的形式 $r_1 - r_2 = 0$，探讨了平衡空间如何修改容许的残余应力，并显示了在此离散设置中 $\\lambda^\\star$ 与 $\\sigma_y$ 的预期线性缩放关系。\n- 情况 C 使用了与情况 A 相同的平衡约束，但采用了不对称的极值 $p^{(1)}$ 和 $p^{(2)}$，其设计旨在需要一个非平凡的残余应力才能达到最大的 $\\lambda^\\star$，从而对第二个线性规划进行检验。\n\n输出规范：\n- 对每种情况，以浮点数形式报告配对 $[\\lambda^\\star,\\|r^\\star\\|_1]$，四舍五入到 $6$ 位小数，并将它们聚合到一个列表中，该列表在一行上打印，无空格：$\\big[\\,[\\lambda_A^\\star,\\|r_A^\\star\\|_1],[\\lambda_B^\\star,\\|r_B^\\star\\|_1],[\\lambda_C^\\star,\\|r_C^\\star\\|_1]\\,\\big]$。\n\n上述公式严格遵循应用于离散应力模型的线性化 Melan 静力定理，仅使用平衡和屈服容许性的基本定义，并利用凸性将验证限制在有限的荷载极值集上。由此产生的规划是线性的，因此对于指定的小维度测试套件可以高效且稳健地求解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_case_sigma_E_P(sigma_y, E, P_list):\n    \"\"\"\n    Solve the two-stage shakedown LP:\n    Stage 1: maximize lambda subject to yield constraints at extremes and equilibrium E r = 0\n    Stage 2: with lambda* fixed, minimize ||r||_1 using standard LP linearization with t >= |r|\n    Inputs:\n        sigma_y: float > 0\n        E: (q, n) numpy array\n        P_list: list of m numpy arrays of shape (n,) representing elastic stress influence at extremes\n    Returns:\n        lambda_star: float\n        l1_min: float (sum of t_i at optimum, equals minimal ||r||_1)\n    \"\"\"\n    # Dimensions\n    n = P_list[0].shape[0]\n    m = len(P_list)\n    q = E.shape[0] if E is not None and E.size > 0 else 0\n\n    # Stage 1: LP in variables x = [r (n), lambda (1)]\n    # Build inequality constraints A_ub x <= b_ub for yield at each extreme\n    A_ub = []\n    b_ub = []\n    for k in range(m):\n        p_k = P_list[k].reshape(-1)\n        for i in range(n):\n            # r_i + lambda * p_k[i] <= sigma_y\n            row = np.zeros(n + 1)\n            row[i] = 1.0\n            row[-1] = p_k[i]\n            A_ub.append(row)\n            b_ub.append(sigma_y)\n            # -r_i - lambda * p_k[i] <= sigma_y\n            row = np.zeros(n + 1)\n            row[i] = -1.0\n            row[-1] = -p_k[i]\n            A_ub.append(row)\n            b_ub.append(sigma_y)\n    A_ub = np.array(A_ub) if A_ub else None\n    b_ub = np.array(b_ub) if b_ub else None\n\n    # Equality constraints: E r = 0\n    if q > 0:\n        A_eq = np.zeros((q, n + 1))\n        A_eq[:, :n] = E\n        b_eq = np.zeros(q)\n    else:\n        A_eq = None\n        b_eq = None\n\n    # Variable bounds: r free, lambda >= 0\n    bounds = [(None, None)] * n + [(0.0, None)]\n\n    # Objective: minimize -lambda\n    c = np.zeros(n + 1)\n    c[-1] = -1.0\n\n    res1 = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=\"highs\")\n    if not res1.success:\n        # In unexpected failure cases, return NaNs to signal an issue.\n        return float(\"nan\"), float(\"nan\")\n\n    x_star = res1.x\n    lambda_star = x_star[-1]\n\n    # Stage 2: LP in variables y = [r (n), t (n)]\n    # Fix lambda = lambda_star in the yield constraints (becomes a constant RHS shift)\n    A_ub2 = []\n    b_ub2 = []\n\n    for k in range(m):\n        p_k = P_list[k].reshape(-1)\n        for i in range(n):\n            # r_i + lambda_star * p_k[i] <= sigma_y\n            row = np.zeros(2 * n)\n            row[i] = 1.0  # r_i\n            # no coefficient on t here\n            A_ub2.append(row)\n            b_ub2.append(sigma_y - lambda_star * p_k[i])\n            # -r_i - lambda_star * p_k[i] <= sigma_y  ->  -r_i <= sigma_y + lambda_star * p_k[i]\n            row = np.zeros(2 * n)\n            row[i] = -1.0  # -r_i\n            A_ub2.append(row)\n            b_ub2.append(sigma_y + lambda_star * p_k[i])\n\n    # Absolute value linearization: r_i - t_i <= 0 and -r_i - t_i <= 0, and t_i >= 0\n    for i in range(n):\n        row = np.zeros(2 * n)\n        row[i] = 1.0      # r_i\n        row[n + i] = -1.0 # -t_i\n        A_ub2.append(row)\n        b_ub2.append(0.0)\n\n        row = np.zeros(2 * n)\n        row[i] = -1.0     # -r_i\n        row[n + i] = -1.0 # -t_i\n        A_ub2.append(row)\n        b_ub2.append(0.0)\n\n    A_ub2 = np.array(A_ub2) if A_ub2 else None\n    b_ub2 = np.array(b_ub2) if b_ub2 else None\n\n    # Equality constraints: E r = 0\n    if q > 0:\n        A_eq2 = np.zeros((q, 2 * n))\n        A_eq2[:, :n] = E\n        b_eq2 = np.zeros(q)\n    else:\n        A_eq2 = None\n        b_eq2 = None\n\n    # Bounds: r free, t >= 0\n    bounds2 = [(None, None)] * n + [(0.0, None)] * n\n\n    # Objective: minimize sum t_i\n    c2 = np.zeros(2 * n)\n    c2[n:] = 1.0\n\n    res2 = linprog(c2, A_ub=A_ub2, b_ub=b_ub2, A_eq=A_eq2, b_eq=b_eq2, bounds=bounds2, method=\"highs\")\n    if not res2.success:\n        return float(lambda_star), float(\"nan\")\n\n    y_star = res2.x\n    t_star = y_star[n:]\n    l1_min = float(np.sum(t_star))\n\n    return float(lambda_star), float(l1_min)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    sigma_A = 1.0\n    E_A = np.array([[1.0, 1.0]])\n    P_A = [np.array([1.0, 0.0]), np.array([0.0, 1.0])]\n\n    # Case B\n    sigma_B = 1.5\n    E_B = np.array([[1.0, -1.0]])\n    P_B = [np.array([1.0, 1.0]), np.array([1.0, -1.0])]\n\n    # Case C\n    sigma_C = 1.0\n    E_C = np.array([[1.0, 1.0]])\n    P_C = [np.array([2.0, -1.0]), np.array([-1.0, 2.0])]\n\n    test_cases = [\n        (sigma_A, E_A, P_A),\n        (sigma_B, E_B, P_B),\n        (sigma_C, E_C, P_C),\n    ]\n\n    results = []\n    for sigma_y, E, P_list in test_cases:\n        lam_star, l1_norm = solve_case_sigma_E_P(sigma_y, E, P_list)\n        # Round to 6 decimals for output\n        lam_star = float(np.round(lam_star, 6)) if np.isfinite(lam_star) else lam_star\n        l1_norm = float(np.round(l1_norm, 6)) if np.isfinite(l1_norm) else l1_norm\n        results.append((lam_star, l1_norm))\n\n    # Final print statement in the exact required format: no spaces, numbers with 6 decimals.\n    formatted = []\n    for lam, nrm in results:\n        if np.isnan(lam) or np.isnan(nrm):\n            # Represent NaNs in a consistent float format with 6 decimals\n            lam_str = \"nan\"\n            nrm_str = \"nan\"\n        else:\n            lam_str = f\"{lam:.6f}\"\n            nrm_str = f\"{nrm:.6f}\"\n        formatted.append(f\"[{lam_str},{nrm_str}]\")\n    print(f\"[[{','.join(formatted)}]]\")\n\nsolve()\n```", "id": "2916223"}]}