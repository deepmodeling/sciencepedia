{"hands_on_practices": [{"introduction": "延性设计的基础是理解梁在初次屈服后仍能继续承载直至达到其完全塑性承载能力。本练习将通过第一性原理，为最简单的矩形截面推导其屈服弯矩 $M_y$、塑性弯矩 $M_p$ 以及形状因子。这个过程不仅揭示了塑性内力重分布的核心机制，也为后续更复杂的塑性分析奠定了坚实的理论基础。[@problem_id:2908840]", "problem": "一根由均匀、各向同性的理想弹塑性材料制成的直棱柱梁，其单轴屈服应力为 $\\sigma_{y}$（拉压对称）。该梁具有宽度为 $b$、高度为 $h$ 的矩形截面。梁绕其强形心轴承受一个单调递增的静施弯矩 $M$，使得顶层纤维受压，底层纤维受拉。假设小应变、平截面在变形后仍保持为平面、无轴向力，并忽略剪切变形和应变硬化。\n\n仅从弹性弯曲的基本原理和理想弹塑性材料全塑性状态的定义出发，完成以下任务：\n\n- 使用线性弹性弯曲关系和矩形截面的二次矩，确定截面绕弯曲轴的弹性截面模量 $S$，并用 $b$ 和 $h$ 表示。\n- 使用初屈服的定义（边缘纤维达到 $\\sigma_{y}$），确定弹性屈服弯矩 $M_{y}$，并用 $\\sigma_{y}$、$b$ 和 $h$ 表示。\n- 在达到全塑性状态时（无弹性核心剩余），通过内力平衡条件，对理想弹塑性应力分布在截面上进行积分，计算全塑性弯矩 $M_{p}$。将 $M_{p}$ 用 $\\sigma_{y}$、$b$ 和 $h$ 表示。\n- 最后，对 $M_{y}$ 和 $M_{p}$进行比较，并给出定义为 $M_{p}/M_{y}$ 的形状系数。\n\n请以 $M_{p}/M_{y}$ 的精确值（无量纲）作为最终答案。不要四舍五入。请将最终答案表示为最简分数。", "solution": "所述问题是材料力学中一个标准的、基本的问题。它具有科学依据，提法得当，客观，并包含了获得唯一解所需的所有信息。因此，该问题被认为是有效的。我们开始推导。\n\n分析从线性弹性弯曲的原理开始。对于一根绕其强形心轴承受纯弯矩 $M$ 的梁，距离中性轴 $y$ 处的正应力 $\\sigma_x$ 由弯曲公式给出：\n$$\n\\sigma_x(y) = -\\frac{M y}{I}\n$$\n其中 $I$ 是截面绕中性轴的二次矩。符号约定假设正弯矩 $M$ 在 $y$ 值为负时（底层纤维）引起拉伸（正应力），在 $y$ 值为正时（顶层纤维）引起压缩（负应力），这与问题陈述一致。\n\n最大应力值 $\\sigma_{max}$ 出现在边缘纤维处，即 $y = \\pm \\frac{h}{2}$。令 $c$ 表示到边缘纤维的距离，因此 $c = \\frac{h}{2}$。\n$$\n\\sigma_{max} = \\frac{M c}{I} = \\frac{M}{I/c}\n$$\n\n第一个任务是确定弹性截面模量 $S$。其定义为 $S = \\frac{I}{c}$。对于宽度为 $b$、高度为 $h$ 的矩形截面，绕形心轴的二次矩为：\n$$\nI = \\int_A y^2 dA = \\int_{-h/2}^{h/2} y^2 (b \\, dy) = b \\left[ \\frac{y^3}{3} \\right]_{-h/2}^{h/2} = b \\left( \\frac{(h/2)^3}{3} - \\frac{(-h/2)^3}{3} \\right) = b \\left( \\frac{h^3}{24} + \\frac{h^3}{24} \\right) = \\frac{bh^3}{12}\n$$\n当 $c = \\frac{h}{2}$ 时，弹性截面模量 $S$ 为：\n$$\nS = \\frac{I}{c} = \\frac{bh^3/12}{h/2} = \\frac{bh^2}{6}\n$$\n\n第二个任务是确定弹性屈服弯矩 $M_y$。这是指边缘纤维处的应力首次达到材料屈服应力 $\\sigma_y$ 时的弯矩。\n$$\n\\sigma_{max} = \\sigma_y\n$$\n将此代入弯曲公式，可将 $M_y$ 与 $\\sigma_y$ 和 $S$ 联系起来：\n$$\n\\sigma_y = \\frac{M_y}{S}\n$$\n因此，屈服弯矩为：\n$$\nM_y = S \\sigma_y = \\frac{bh^2}{6} \\sigma_y\n$$\n\n第三个任务是计算全塑性弯矩 $M_p$。在此阶段，弯矩已增加到足以使截面中的每一根纤维都发生屈服。在这种理想弹塑性材料模型中，整个截面的应力大小等于屈服应力 $\\sigma_y$。由于截面的对称性和材料的拉压对称性，中性轴保持在几何形心处。\n\n应力分布是不连续的：\n$$\n\\sigma_x(y) = \n\\begin{cases} \n      -\\sigma_y & \\text{当 } 0 < y \\le \\frac{h}{2} \\quad \\text{(压缩)} \\\\\n      \\sigma_y & \\text{当 } -\\frac{h}{2} \\le y < 0 \\quad \\text{(拉伸)}\n\\end{cases}\n$$\n全塑性弯矩 $M_p$ 是由该应力分布产生的内抵抗弯矩。它通过对截面面积 $A$ 上由微元力 $dF = \\sigma_x dA$ 产生的力矩贡献进行积分来计算。\n$$\nM_p = -\\int_A y \\, \\sigma_x(y) \\, dA\n$$\n我们将积分分为受压区（上半部分，$A_c$）和受拉区（下半部分，$A_t$）。微元面积为 $dA = b \\, dy$。\n$$\nM_p = - \\left( \\int_{0}^{h/2} y (-\\sigma_y) (b \\, dy) + \\int_{-h/2}^{0} y (\\sigma_y) (b \\, dy) \\right)\n$$\n$$\nM_p = b \\sigma_y \\int_{0}^{h/2} y \\, dy - b \\sigma_y \\int_{-h/2}^{0} y \\, dy\n$$\n$$\nM_p = b \\sigma_y \\left[ \\frac{y^2}{2} \\right]_{0}^{h/2} - b \\sigma_y \\left[ \\frac{y^2}{2} \\right]_{-h/2}^{0}\n$$\n$$\nM_p = b \\sigma_y \\left( \\frac{(h/2)^2}{2} - 0 \\right) - b \\sigma_y \\left( 0 - \\frac{(-h/2)^2}{2} \\right)\n$$\n$$\nM_p = b \\sigma_y \\left( \\frac{h^2}{8} \\right) - b \\sigma_y \\left( -\\frac{h^2}{8} \\right) = \\frac{b h^2 \\sigma_y}{8} + \\frac{b h^2 \\sigma_y}{8}\n$$\n$$\nM_p = \\frac{b h^2 \\sigma_y}{4}\n$$\n\n最后一个任务是计算形状系数，即全塑性弯矩 $M_p$ 与屈服弯矩 $M_y$ 的比值。这个无量纲系数用于量化由于应力的塑性重分布，截面在初次屈服之后所能提供的额外承载能力。\n$$\n\\text{形状系数} = \\frac{M_p}{M_y}\n$$\n代入推导出的 $M_p$ 和 $M_y$ 的表达式：\n$$\n\\frac{M_p}{M_y} = \\frac{\\frac{b h^2 \\sigma_y}{4}}{\\frac{b h^2 \\sigma_y}{6}}\n$$\n分子和分母中的公共项 $\\sigma_y$、$b$ 和 $h^2$ 可以相互抵消。\n$$\n\\frac{M_p}{M_y} = \\frac{1/4}{1/6} = \\frac{1}{4} \\times 6 = \\frac{6}{4} = \\frac{3}{2}\n$$\n矩形截面的形状系数为 $\\frac{3}{2}$。", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "2908840"}, {"introduction": "塑性变形是永久性的；当外载荷移除后，构件并不会回到无应力状态，而是会形成残余应力。本练习通过将弹性卸载响应叠加在已知的弹塑性应力状态上，深入探讨了残余应力的形成过程，这对于理解回弹、自增强效应以及疲劳寿命至关重要。非对称的拉压屈服强度设定，使得初始加载分析更具挑战性也更贴近某些实际材料的特性。[@problem_id:2215767]", "problem": "一个宽度为 $b$、高度为 $h$ 的矩形截面直梁承受纯弯矩作用。该梁由一种特殊的弹-理想塑性材料制成。该材料的杨氏模量为 $E$，其拉伸和压缩的屈服强度不同。拉伸屈服强度为 $\\sigma_{YT}$，压缩屈服强度为 $\\sigma_{YC} = 2\\sigma_{YT}$。\n\n一个正弯矩 $M$ 作用于通过截面形心的水平轴，在顶层纤维（$y>0$）中引起压缩，在底层纤维（$y<0$）中引起拉伸，其中 $y$ 是从形心轴测量的垂直坐标。弯矩逐渐增加，直到从底面（$y=-h/2$）开始的塑性屈服向内扩展了 $h/4$ 的距离。达到此状态后，弯矩被完全移除。\n\n由于塑性变形，梁中会保留残余应力。确定残余应力为零且最靠近梁底面的点的位置 $y$，用 $h$ 表示。", "solution": "求解过程包括三个阶段：1) 分析施加弯矩过程中的应力分布，2) 确定卸载弯矩时的弹性应力分布，以及 3) 叠加这两种应力以求得残余应力分布。\n\n**1. 加载过程中的应力分布**\n\n设 $y$ 是从矩形截面几何形心测量的垂直坐标。梁的高度范围为从 $y=-h/2$ 到 $y=h/2$。正弯矩在 $y<0$ 处引起拉伸（$\\sigma > 0$），在 $y>0$ 处引起压缩（$\\sigma < 0$）。\n\n材料是弹-理想塑性的。由于 $\\sigma_{YT} < \\sigma_{YC}$，屈服首先在受拉侧开始。题目说明塑性区已从底面（$y=-h/2$）向内扩展了 $h/4$ 的距离。这意味着受拉侧的弹塑性界面位于 $y_T = -h/2 + h/4 = -h/4$。\n因此，对于 $-h/2 \\le y \\le -h/4$，梁处于塑性拉伸状态，应力为常数：$\\sigma(y) = \\sigma_{YT}$。\n\n在区域 $-h/4 < y \\le h/2$ 内，材料仍处于弹性状态（我们稍后将验证关于压缩侧的这一假设）。即使存在塑性区，梁截面上的应变分布也是线性的。然而，由于不对称屈服，中性轴（应变为零的位置）将偏离几何形心。设中性轴的位置为 $y_{NA}$。应变由 $\\epsilon(y) = -\\kappa(y - y_{NA})$ 给出，其中 $\\kappa$ 是曲率。\n\n弹性区域内的应力为 $\\sigma(y) = E\\epsilon(y) = -E\\kappa(y - y_{NA})$。\n在弹塑性边界 $y_T = -h/4$ 处，应力恰好是拉伸屈服强度，即 $\\sigma(y_T) = \\sigma_{YT}$。\n因此，$\\sigma_{YT} = -E\\kappa(-h/4 - y_{NA}) = E\\kappa(h/4 + y_{NA})$。这给出了曲率项的关系式：$E\\kappa = \\frac{\\sigma_{YT}}{h/4 + y_{NA}}$。\n弹性区域的应力可以写为：$\\sigma(y) = -\\frac{\\sigma_{YT}}{h/4 + y_{NA}}(y - y_{NA})$。\n\n为了求出 $y_{NA}$，我们应用截面上净轴力为零的条件：$\\int_A \\sigma(y) dA = 0$。由于宽度 $b$ 是常数，这可以简化为 $\\int_{-h/2}^{h/2} \\sigma(y) dy = 0$。\n我们将积分分为塑性区和弹性区：\n$$ \\int_{-h/2}^{-h/4} \\sigma_{YT} dy + \\int_{-h/4}^{h/2} \\left(-\\frac{\\sigma_{YT}}{h/4 + y_{NA}}(y - y_{NA})\\right) dy = 0 $$\n两边同除以 $\\sigma_{YT}$（非零）：\n$$ \\int_{-h/2}^{-h/4} 1 \\, dy - \\frac{1}{h/4 + y_{NA}} \\int_{-h/4}^{h/2} (y - y_{NA}) dy = 0 $$\n$$ [y]_{-h/2}^{-h/4} = \\frac{1}{h/4 + y_{NA}} \\left[\\frac{y^2}{2} - y_{NA}y \\right]_{-h/4}^{h/2} $$\n$$ (-h/4) - (-h/2) = \\frac{1}{h/4 + y_{NA}} \\left[ \\left(\\frac{h^2}{8} - \\frac{y_{NA}h}{2}\\right) - \\left(\\frac{h^2}{32} + \\frac{y_{NA}h}{4}\\right) \\right] $$\n$$ \\frac{h}{4} = \\frac{1}{h/4 + y_{NA}} \\left( \\frac{3h^2}{32} - \\frac{3y_{NA}h}{4} \\right) $$\n$$ \\frac{h}{4}\\left(\\frac{h}{4} + y_{NA}\\right) = \\frac{3h^2}{32} - \\frac{3y_{NA}h}{4} $$\n$$ \\frac{h^2}{16} + \\frac{hy_{NA}}{4} = \\frac{3h^2}{32} - \\frac{3hy_{NA}}{4} $$\n$$ \\frac{hy_{NA}}{4} + \\frac{3hy_{NA}}{4} = \\frac{3h^2}{32} - \\frac{2h^2}{32} \\implies hy_{NA} = \\frac{h^2}{32} \\implies y_{NA} = \\frac{h}{32} $$\n中性轴向上移动，这与预期相符。现在，我们验证顶层纤维（$y=h/2$）没有发生压缩屈服。顶层纤维的应力为：\n$$ \\sigma(h/2) = -\\frac{\\sigma_{YT}}{h/4 + h/32}(h/2 - h/32) = -\\frac{\\sigma_{YT}}{9h/32}(15h/32) = -\\frac{15}{9}\\sigma_{YT} = -\\frac{5}{3}\\sigma_{YT} $$\n该应力的绝对值为 $|\\sigma(h/2)| = \\frac{5}{3}\\sigma_{YT} \\approx 1.67\\sigma_{YT}$。由于压缩屈服强度为 $\\sigma_{YC} = 2\\sigma_{YT}$，顶层纤维保持弹性。我们假设的应力分布是正确的。\n\n加载时的应力分布 $\\sigma(y)$ 为：\n$$ \\sigma(y) = \\begin{cases} \\sigma_{YT} & -h/2 \\le y \\le -h/4 \\\\ -\\frac{32\\sigma_{YT}}{9h}(y - \\frac{h}{32}) & -h/4 < y \\le h/2 \\end{cases} $$\n\n接下来，我们计算所施加的弯矩 $M = -\\int_A y\\sigma(y)dA = -b\\int_{-h/2}^{h/2} y\\sigma(y)dy$。\n$$ M = -b\\left[ \\int_{-h/2}^{-h/4} y\\sigma_{YT} dy + \\int_{-h/4}^{h/2} y\\left(-\\frac{32\\sigma_{YT}}{9h}(y - \\frac{h}{32})\\right) dy \\right] $$\n$$ \\int_{-h/2}^{-h/4} y\\sigma_{YT} dy = \\sigma_{YT}\\left[\\frac{y^2}{2}\\right]_{-h/2}^{-h/4} = \\sigma_{YT}\\left(\\frac{h^2/16}{2} - \\frac{h^2/4}{2}\\right) = -\\frac{3\\sigma_{YT}h^2}{32} $$\n$$ \\int_{-h/4}^{h/2} -y\\frac{32\\sigma_{YT}}{9h}(y - \\frac{h}{32}) dy = -\\frac{32\\sigma_{YT}}{9h} \\int_{-h/4}^{h/2} (y^2 - \\frac{h}{32}y) dy $$\n$$ = -\\frac{32\\sigma_{YT}}{9h} \\left[\\frac{y^3}{3} - \\frac{h}{64}y^2\\right]_{-h/4}^{h/2} = -\\frac{32\\sigma_{YT}}{9h}\\left[ \\left(\\frac{h^3}{24}-\\frac{h^3}{256}\\right) - \\left(-\\frac{h^3}{192}-\\frac{h^3}{1024}\\right) \\right] $$\n$$ = -\\frac{32\\sigma_{YT}}{9h}\\left[ \\frac{29h^3}{768} - (-\\frac{19h^3}{3072}) \\right] = -\\frac{32\\sigma_{YT}}{9h}\\left[ \\frac{116h^3+19h^3}{3072} \\right] = -\\frac{32\\sigma_{YT}}{9h}\\frac{135h^3}{3072} $$\n化简分数：$\\frac{32 \\times 135}{9 \\times 3072} = \\frac{2^5 \\times 5 \\times 3^3}{3^2 \\times 3 \\times 2^{10}} = \\frac{5}{2^5} = \\frac{5}{32}$。积分为 $-\\frac{5\\sigma_{YT}h^2}{32}$。\n$$ M = -b\\left[ -\\frac{3\\sigma_{YT}h^2}{32} - \\frac{5\\sigma_{YT}h^2}{32} \\right] = -b\\left[ -\\frac{8\\sigma_{YT}h^2}{32} \\right] = \\frac{b\\sigma_{YT}h^2}{4} $$\n\n**2. 弹性卸载应力**\n\n当弯矩 $M$ 被移除时，梁会发生弹性响应。这等效于对梁施加一个大小为 $-M$ 的弯矩。其产生的卸载应力分布 $\\sigma_{unload}(y)$ 是线性的，由弯曲公式给出：\n$$ \\sigma_{unload}(y) = \\frac{(-M)y}{I_{xx}} = -\\frac{My}{I_{xx}} $$\n其中 $I_{xx} = \\frac{bh^3}{12}$ 是矩形截面的截面二次矩。\n$$ \\sigma_{unload}(y) = -\\frac{(b\\sigma_{YT}h^2/4)y}{bh^3/12} = -\\frac{12b\\sigma_{YT}h^2y}{4bh^3} = -\\frac{3\\sigma_{YT}y}{h} $$\n，等等，卸载弯矩的符号应与加载弯矩相反。由于我计算出的 $M$ 是一个正值，卸载应叠加一个对应于弯矩 $-M$ 的应力分布。来自卸载弯矩的应力是 $\\sigma_{unload}(y) = \\frac{(-M)y}{I_{xx}} = -\\frac{M y}{I}$。对于 $M = \\frac{b\\sigma_{YT}h^2}{4}$（正值），这便是 $\\sigma_{unload}(y) = -\\frac{3\\sigma_{YT}y}{h}$。让我们重新检查我最初的约定。正弯矩意味着底部受拉（$y<0$）。$\\sigma_T > 0$。$M = \\int -y\\sigma dA$。对于 $y<0$，有 $-y > 0$。而 $\\sigma>0$。所以积分是正的。这似乎是正确的。对于给定的y，卸载应力的符号应该与加载应力相反。我的加载应力在底部是正的（拉伸），在顶部是负的（压缩）。卸载应力在底部应该是负的（压缩），在顶部应该是正的（拉伸）。我的 $\\sigma_{unload}(y) = -\\frac{3\\sigma_{YT}y}{h}$ 正好给出这个结果。一切都吻合。\n\n**3. 残余应力**\n\n残余应力 $\\sigma_{res}(y)$ 是加载应力和卸载应力之和：$\\sigma_{res}(y) = \\sigma(y) + \\sigma_{unload}(y)$。\n\n我们分析两个区域：\na) 原塑性区：$-h/2 \\le y \\le -h/4$\n在此区域，$\\sigma(y) = \\sigma_{YT}$。\n$$ \\sigma_{res}(y) = \\sigma_{YT} - \\frac{3\\sigma_{YT}y}{h} = \\sigma_{YT}\\left(1 - \\frac{3y}{h}\\right) $$\n为找到残余应力为零的位置，我们令 $\\sigma_{res}(y)=0$：\n$$ 1 - \\frac{3y}{h} = 0 \\implies y = \\frac{h}{3} $$\n此值不在区间 $[-h/2, -h/4]$ 内，因此此处没有零点。\n\n让我重新检查我的计算和约定。哦，我看到了我的错误。如果我们将 $M$ 定义为反作用力矩的大小，那么卸载应力为 $\\sigma_{unload}(y) = My/I$。让我们重新定义。加载弯矩为 $M_{load} = \\frac{b\\sigma_{YT}h^2}{4}$。卸载等效于施加 $M_{unload} = -M_{load}$。卸载应力为 $\\sigma_{unload}(y) = \\frac{M_{unload} y}{I} = \\frac{-M_{load} y}{I} = -\\frac{3\\sigma_{YT}y}{h}$。这就是我所使用的。让我们重新进行代数计算。\n\n$\\sigma_{res}(y) = \\sigma(y) + \\sigma_{unload}(y) = \\sigma(y) - \\frac{3\\sigma_{YT}y}{h}$。\n区域 (a), $-h/2 \\le y \\le -h/4$: $\\sigma_{res}(y) = \\sigma_{YT} - \\frac{3\\sigma_{YT}y}{h}$。\n我是否可能搞错了 $M$ 的符号？让我们重新验证定义 $M = -\\int y \\sigma dA$。这个定义是标准的，即正弯矩在顶部（正y）引起压缩。我的应力 $\\sigma$ 对于拉伸为正，对于压缩为负。所以对于顶部 ($y>0$)，有 $\\sigma<0$，因此 $-y\\sigma > 0$。对于底部 ($y<0$)，有 $\\sigma>0$，因此 $-y\\sigma > 0$。所以对于一个“笑脸”形弯曲，此积分将为正值。结果 $M = b\\sigma_{YT}h^2/4$ 为正。这与定义一致。\n对应于弯矩 $-M$ 的卸载会产生 $\\sigma_{unload} = (-M)y/I$。这就是我所用的。\n\n啊，我找到错误了。弹性区域的加载应力 $\\sigma(y)$ 为 $\\sigma(y) = -E\\kappa(y-y_{NA})$。当 $y > y_{NA}$ 时，$\\sigma<0$（压缩）。当 $y < y_{NA}$ 时，$\\sigma>0$（拉伸）。\n边界为 $y_T = -h/4$。由于 $y_{NA}=h/32$，我们有 $y_T < y_{NA}$。所以在 $y_T$ 处，应力 $\\sigma(y_T)$ 应该是正的。这正是我所使用的。\n我到目前的计算似乎是正确的。\n让我们再次检查区域 (a) 的零点计算： $\\sigma_{YT}(1 - 3y/h) = 0 \\implies y=h/3$。这在 $[-0.5h, -0.25h]$ 之外。这里没有零点。\n\n让我从第一性原理重新检查。\n总应力为 $\\sigma_{res}$。在 $y=-h/2$ 处，$\\sigma_{load}=\\sigma_{YT}$。$\\sigma_{unload} = -3\\sigma_{YT}(-h/2)/h = +1.5\\sigma_{YT}$。\n等等。这意味着卸载增加了*更多*的拉应力。这不可能对。\n卸载弯矩必须与加载弯矩反向。\n加载弯矩 $M_{load}$ 在底部引起拉伸。卸载过程叠加了一个由 $M_{unload}=-M_{load}$ 产生的应力场。\n负弯矩在底部（$y<0$）引起压缩。负弯矩使梁呈“皱眉”状。顶部受拉，底部受压。\n所以对于 $y<0$，$\\sigma_{unload}$ 应该是负的。但是我的公式 $(-M)y/I$ 在 $y<0$ 时给出了正值。\n问题出在弯曲公式本身的符号约定上。让我们写成 $\\sigma_x = -M_z y / I_z$。如果 $M_z$ 是一个正弯矩（底部受拉），那么对于 $y<0$，$\\sigma_x > 0$。这个公式可行。\n我计算出 $M_z = M = b\\sigma_{YT}h^2/4 > 0$。\n它产生的应力是 $\\sigma_{load}(y)$ (分段的)。\n卸载应力由 $-M_z$ 产生。所以 $\\sigma_{unload}(y) = -(-M_z) y / I_z = M_z y / I_z$。\n$\\sigma_{unload}(y) = \\frac{(b\\sigma_{YT}h^2/4)y}{bh^3/12} = \\frac{3\\sigma_{YT}y}{h}$。\n所以在底部 ($y=-h/2$)，$\\sigma_{unload} = -1.5\\sigma_{YT}$ (压缩)。这是正确的。\n\n**3. 残余应力**\n\n残余应力 $\\sigma_{res}(y)$ 是加载应力和卸载应力之和：$\\sigma_{res}(y) = \\sigma(y) + \\sigma_{unload}(y)$。\n\n我们分析两个区域：\na) 原塑性区： $-h/2 \\le y \\le -h/4$\n在此区域，$\\sigma(y) = \\sigma_{YT}$。\n$$ \\sigma_{res}(y) = \\sigma_{YT} + \\frac{3\\sigma_{YT}y}{h} = \\sigma_{YT}\\left(1 + \\frac{3y}{h}\\right) $$\n令其为零：$1 + \\frac{3y}{h} = 0 \\implies y = -h/3$。\n区间是 $[-0.5h, -0.25h]$。$y = -h/3 \\approx -0.333h$。此值在区间内。所以 $y = -h/3$ 是一个解。\n\nb) 原弹性区：$-h/4 < y \\le h/2$\n$\\sigma(y) = -\\frac{32\\sigma_{YT}}{9h}(y - \\frac{h}{32})$。\n$$ \\sigma_{res}(y) = -\\frac{32\\sigma_{YT}}{9h}(y - \\frac{h}{32}) + \\frac{3\\sigma_{YT}y}{h} $$\n除以 $\\sigma_{YT}$ 并令其为零：\n$$ -\\frac{32}{9h}\\left(y - \\frac{h}{32}\\right) + \\frac{3y}{h} = 0 $$\n$$ -\\frac{32y}{9h} + \\frac{32h}{9h \\cdot 32} + \\frac{3y}{h} = 0 $$\n$$ -\\frac{32y}{9h} + \\frac{1}{9} + \\frac{27y}{9h} = 0 $$\n$$ \\frac{1}{9} - \\frac{5y}{9h} = 0 \\implies 1 = \\frac{5y}{h} \\implies y = \\frac{h}{5} $$\n区间是 $(-0.25h, 0.5h]$。$y = h/5 = 0.2h$。此值在区间内。所以 $y=h/5$ 是另一个解。\n\n**4. 最终答案**\n\n我们找到了两个残余应力为零的位置：$y_1 = -h/3$ 和 $y_2 = h/5$。\n题目要求最靠近梁底面（位于 $y=-h/2$）的位置。\n$y_1$ 与底面的距离是 $|y_1 - (-h/2)| = |-h/3 + h/2| = |h/6| = h/6$。\n$y_2$ 与底面的距离是 $|y_2 - (-h/2)| = |h/5 + h/2| = |7h/10| = 7h/10$。\n因为 $h/6 < 7h/10$，所以最靠近底面的点是 $y_1 = -h/3$。", "answer": "$$\\boxed{-\\frac{h}{3}}$$", "id": "2215767"}, {"introduction": "理论的魅力在于其精确性，但解析解往往只适用于简单的几何形状。为了跨越理论与工程实践之间的鸿沟，本高级练习引入了强大的“纤维模型”——一种用于计算任意截面弯矩-曲率响应的数值方法。通过实践该方法，你不仅能将所学知识推广到一般情况，还能深入了解现代结构分析软件背后的核心计算原理。[@problem_id:2908874]", "problem": "考虑由各向同性、均质材料制成的棱柱梁，在小应变、率无关、等温条件下发生的弯曲。该材料遵循弹性理想塑性单轴本构律。采用经典的欧拉-伯努利运动学假定（平截面在变形后保持为平面且垂直于中性轴）和合轴力为零的纯弯曲情况。设绕强轴的曲率用 $\\kappa$（单位为 $\\mathrm{m}^{-1}$）表示。对于在 $xy$ 平面内描述的横截面 $\\mathcal{A}$（其中 $y$ 沿厚度方向测量），其纵向应变场为 $\\varepsilon(y)=\\varepsilon_{0}+\\kappa\\,(y-y_{\\mathrm{ref}})$，其中 $\\varepsilon_{0}$ 是为确保轴力为零而选取的未知均匀轴向应变，而 $y_{\\mathrm{ref}}$ 是一个固定的参考纵坐标。单轴应力由弹性理想塑性定律 $\\sigma(\\varepsilon)=\\mathrm{clip}\\big(E\\,\\varepsilon,-\\sigma_{y},\\sigma_{y}\\big)$ 给出，其中 $E$ 是杨氏模量，$\\sigma_{y}$ 是拉伸和压缩下的屈服应力。绕中性轴的内弯矩为\n$$\nM(\\kappa)=\\int_{\\mathcal{A}} \\sigma\\big(\\varepsilon(y)\\big)\\,(y-y_{\\mathrm{ref}})\\,\\mathrm{d}A.\n$$\n您必须实现一个纤维离散化方案，通过水平纤维来近似该积分。对于一个给定的多边形横截面，将其离散化为 $N_{y}$ 个水平纤维，这些纤维位于纵坐标 $y_{i}$ 处，宽度为 $w_{i}$，统一厚度为 $\\Delta y$，因此 $\\Delta A_{i}=w_{i}\\,\\Delta y$，并近似计算\n$$\nN(\\varepsilon_{0};\\kappa)=\\sum_{i=1}^{N_{y}} \\sigma\\big(\\varepsilon_{0}+\\kappa\\,(y_{i}-y_{\\mathrm{ref}})\\big)\\,\\Delta A_{i},\\qquad \nM(\\kappa)\\approx \\sum_{i=1}^{N_{y}} \\sigma\\big(\\varepsilon_{0}^{\\star}+\\kappa\\,(y_{i}-y_{\\mathrm{ref}})\\big)\\,(y_{i}-y_{\\mathrm{ref}})\\,\\Delta A_{i},\n$$\n其中 $\\varepsilon_{0}^{\\star}$ 是 $N(\\varepsilon_{0};\\kappa)=0$ 的唯一根。通过一个稳健的一维求根方法求解 $\\varepsilon_{0}^{\\star}$。\n\n对于宽度为 $b$、高度为 $h$ 的矩形横截面，在相同假设下，存在一个 $M(\\kappa)$ 的闭式解析表达式。该表达式是根据第一性原理（力平衡、变形协调和弹性理想塑性定律），通过考虑弹性核心区和完全屈服的外层区域推导出来的。使用该解析解来对您的纤维积分数值方法进行基准检验。\n\n您的程序必须：\n- 通过水平扫描线切片法，为任意简单多边形横截面实现纤维离散化，以获得 $\\{(y_{i},w_{i})\\}$。\n- 对每个测试用例，通过求解 $N(\\varepsilon_{0};\\kappa)=0$ 来强制轴力为零。\n- 对每个测试用例，数值计算 $M(\\kappa)$。\n- 对于矩形截面，独立计算解析解 $M(\\kappa)$，并报告数值方法相对于解析结果的相对误差。\n- 对于非矩形多边形，通过纤维法数值计算塑性截面模量 $Z_{p}=\\int_{\\mathcal{A}} |y-y_{c}|\\,\\mathrm{d}A$（其中 $y_{c}$ 是 $\\mathcal{A}$ 的形心纵坐标），并通过报告在高曲率下 $M(\\kappa)$ 与 $\\sigma_{y}\\,Z_{p}$ 的偏差来验证大曲率极限。\n\n使用以下参数（全部采用国际单位制）：\n- 材料：$E=210\\times 10^{9}\\,\\mathrm{Pa}$，$\\sigma_{y}=250\\times 10^{6}\\,\\mathrm{Pa}$。\n- 矩形：宽度 $b=0.1\\,\\mathrm{m}$，高度 $h=0.2\\,\\mathrm{m}$，其中 $y$ 从底边（$y=0$）测量至顶边（$y=h$）。使用 $y_{\\mathrm{ref}}=y_{c}$，即形心纵坐标。\n- 定义矩形屈服曲率 $\\kappa_{y}=\\dfrac{\\sigma_{y}}{E\\,c}$，其中 $c=h/2$。\n- 非矩形多边形（等腰梯形，关于 x 轴对称）：顶点按逆时针顺序排列为 $(-0.03,0)$, $(0.03,0)$, $(0.09,0.2)$, $(-0.09,0.2)$（单位为 $\\mathrm{m}$）。使用 $y_{\\mathrm{ref}}=y_{c}$，即多边形的形心纵坐标。\n\n测试套件（所有情况均使用相同的 $E$ 和 $\\sigma_{y}$，并采用适当且足够精细的 $N_{y}$ 以确保纤维法收敛）：\n- 案例 $\\mathbf{1}$ (矩形，弹性)：$\\kappa=0.1\\,\\kappa_{y}$。输出相对误差 $\\big|M_{\\mathrm{num}}-M_{\\mathrm{ana}}\\big|/M_{\\mathrm{ana}}$，作为一个无量纲浮点数。\n- 案例 $\\mathbf{2}$ (矩形，屈服开始)：$\\kappa=1.0\\,\\kappa_{y}$。如上输出相对误差。\n- 案例 $\\mathbf{3}$ (矩形，部分塑性)：$\\kappa=5.0\\,\\kappa_{y}$。如上输出相对误差。\n- 案例 $\\mathbf{4}$ (矩形，接近完全塑性)：$\\kappa=200.0\\,\\kappa_{y}$。如上输出相对误差。\n- 案例 $\\mathbf{5}$ (梯形，轴向平衡检验)：$\\kappa=50.0\\,\\kappa_{y}$。输出无量纲比值 $\\big|N(\\varepsilon_{0}^{\\star};\\kappa)\\big|/(\\sigma_{y}\\,A)$，作为一个浮点数，其中 $A$ 是多边形面积。\n- 案例 $\\mathbf{6}$ (梯形，大曲率塑性极限)：$\\kappa=200.0\\,\\kappa_{y}$。输出 $\\left| \\dfrac{M_{\\mathrm{num}}}{\\sigma_{y}\\,Z_{p}} - 1 \\right|$，作为一个浮点数。\n\n角度单位不适用。所有中间计算都应在国际单位制（SI）下统一执行。测试套件中的输出是无量纲的，因此输出中不需单位标注。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6]”）。每个条目必须按顺序对应于案例 $\\mathbf{1}$ 到 $\\mathbf{6}$，并以标准十进制表示法打印。", "solution": "我们从以下基本原理和定义出发：(i) 纯弯曲的欧拉-伯努利运动学，即平截面保持为平面，且纵向应变随横向坐标线性变化，$\\varepsilon(y)=\\varepsilon_{0}+\\kappa\\,(y-y_{\\mathrm{ref}})$；(ii) 弹性理想塑性单轴本构律 $\\sigma(\\varepsilon)=\\mathrm{clip}(E\\,\\varepsilon,-\\sigma_{y},\\sigma_{y})$；(iii) 纯弯曲要求轴力为零的静力平衡条件，$N(\\varepsilon_{0};\\kappa)=\\int_{\\mathcal{A}}\\sigma\\big(\\varepsilon(y)\\big)\\,\\mathrm{d}A=0$；以及 (iv) 绕 $y_{\\mathrm{ref}}$ 的合弯矩，$M(\\kappa)=\\int_{\\mathcal{A}}\\sigma\\big(\\varepsilon(y)\\big)\\,(y-y_{\\mathrm{ref}})\\,\\mathrm{d}A$。\n\n纤维离散化的算法设计：\n1. 通过水平纤维进行几何离散化。设多边形横截面由有序顶点表示。对于选定的切片数 $N_{y}$，在 $y_{\\min}$ 和 $y_{\\max}$ 之间定义间距为 $\\Delta y=(y_{\\max}-y_{\\min})/N_{y}$ 的均匀分布的扫描线，其纵坐标为 $y_{i}$。对于每个 $y_{i}$，使用标准的奇偶规则计算扫描线与多边形边界的交点：对于每个与 $y_{i}$ 相交的非水平边，计算交点横坐标 $x$ 并收集所有这些 $x$。将它们按升序排序后，通过配对连续的横坐标 $(x_{2k},x_{2k+1})$ 得到内部线段的并集。纤维宽度为 $w_{i}=\\sum_{k}(x_{2k+1}-x_{2k})$，纤维面积为 $\\Delta A_{i}=w_{i}\\,\\Delta y$。纤维的形心纵坐标取为扫描线的纵坐标 $y_{i}$（中点约定）。\n2. 参考轴与形心。计算离散化后的形心纵坐标 $y_{c}=\\left(\\sum_{i} y_{i}\\,\\Delta A_{i}\\right)\\big/\\left(\\sum_{i}\\Delta A_{i}\\right)$，并使用 $y_{\\mathrm{ref}}=y_{c}$，从而使弯矩是关于形心轴的。\n3. 强制轴力为零。定义轴力泛函\n$$\nN(\\varepsilon_{0};\\kappa)=\\sum_{i=1}^{N_{y}} \\sigma\\!\\left(\\varepsilon_{0}+\\kappa\\,(y_{i}-y_{c})\\right)\\,\\Delta A_{i},\\quad \\sigma(\\cdot)=\\max\\!\\left(-\\sigma_{y},\\min\\!\\left(\\sigma_{y},E\\,(\\cdot)\\right)\\right).\n$$\n因为 $\\sigma(\\cdot)$ 是其参数的单调非减函数，所以 $N(\\varepsilon_{0};\\kappa)$ 是 $\\varepsilon_{0}$ 的一个连续、严格递增函数，这保证了根的唯一性。使用稳健的二分法：通过选择足够大的负值和正值界限来界定 $\\varepsilon_{0}$（例如，$\\varepsilon_{0}^{-}=-\\alpha-\\kappa\\,Y$ 和 $\\varepsilon_{0}^{+}=+\\alpha+\\kappa\\,Y$，其中 $Y=\\max_{i}|y_{i}-y_{c}|$，且 $\\alpha>0$ 的尺度应超过弹性极限，如 $\\alpha=2\\,\\sigma_{y}/E$），如果需要则扩大区间，然后进行二分直至 $|N|$ 可忽略不计。\n4. 弯矩计算。求得根 $\\varepsilon_{0}^{\\star}$ 后，计算\n$$\nM_{\\mathrm{num}}(\\kappa)=\\sum_{i=1}^{N_{y}} \\sigma\\!\\left(\\varepsilon_{0}^{\\star}+\\kappa\\,(y_{i}-y_{c})\\right)\\,(y_{i}-y_{c})\\,\\Delta A_{i}.\n$$\n5. 矩形截面的解析解。考虑一个宽度为 $b$（$x$ 方向）和高度为 $h$（$y$ 方向）的矩形，其形心轴位于 $y_{c}=h/2$。在曲率 $\\kappa$ 和零轴力作用下，对称性意味着应力场关于 $(y-y_{c})$ 是奇函数。设 $c=h/2$，屈服曲率为 $\\kappa_{y}=\\sigma_{y}/(E\\,c)$。如果 $|\\kappa|\\le \\kappa_{y}$，截面完全处于弹性状态，弯矩为\n$$\nM_{\\mathrm{ana}}(\\kappa)=E\\,I\\,\\kappa,\\qquad I=\\frac{b\\,h^{3}}{12}.\n$$\n如果 $|\\kappa|>\\kappa_{y}$，在 $y_{c}$ 周围会保留一个半厚度为 $e=\\sigma_{y}/(E\\,|\\kappa|)$ 的弹性核心区，而外层则完全屈服。不失一般性地考虑 $\\kappa$ 为正的情况，当 $|y-y_{c}|\\le e$ 时，应力为 $\\sigma=E\\,\\kappa\\,(y-y_{c})$；当 $e<|y-y_{c}|\\le c$ 时，应力为 $\\sigma=\\mathrm{sign}(y-y_{c})\\,\\sigma_{y}$，从而得到\n$$\nM_{\\mathrm{ana}}(\\kappa)=2\\,b\\left[\\int_{0}^{e} E\\,\\kappa\\,y^{2}\\,\\mathrm{d}y+\\int_{e}^{c} \\sigma_{y}\\,y\\,\\mathrm{d}y\\right] =2\\,b\\left(\\frac{E\\,\\kappa\\,e^{3}}{3}+\\frac{\\sigma_{y}}{2}\\left(c^{2}-e^{2}\\right)\\right),\n$$\n其中 $e=\\sigma_{y}/(E\\,\\kappa)$ 且 $c=h/2$。当 $\\kappa=\\kappa_{y}$ 时，此表达式连续地简化为 $E\\,I\\,\\kappa$；当 $\\kappa\\to\\infty$ 时，此表达式趋近于全塑性弯矩 $M_{p}=\\sigma_{y}\\,Z_{p}$，其中矩形的塑性截面模量为 $Z_{p}=b\\,h^{2}/4$。\n6. 通过纤维法计算塑性截面模量。对于一般截面，近似计算\n$$\nZ_{p}\\approx \\sum_{i=1}^{N_{y}} |y_{i}-y_{c}|\\,\\Delta A_{i},\n$$\n因此对于足够大的 $|\\kappa|$，全塑性极限为 $M\\approx \\sigma_{y}\\,Z_{p}$。\n\n数值和物理一致性：\n- 求解 $\\varepsilon_{0}$ 的二分法求根过程确保在指定的容差范围内，轴向平衡在浮点运算下是精确的，使得 $N(\\varepsilon_{0}^{\\star};\\kappa)$ 相对于 $\\sigma_{y}\\,A$ 非常小。\n- 扫描线纤维离散法在 $N_{y}\\to\\infty$ 时收敛。选择一个足够大的 $N_{y}$ 可以使离散化误差相对于解析基准很小。\n- 对于矩形截面，数值解 $M_{\\mathrm{num}}(\\kappa)$ 在弹性和塑性区间内均一致地收敛于解析解 $M_{\\mathrm{ana}}(\\kappa)$，最大偏差出现在弹塑性过渡区域附近，这是由分段仿射的应力饱和引起的；增加 $N_{y}$ 会减小这些偏差。\n- 对于梯形截面，根据塑性截面模量的定义，大曲率下的比值 $M_{\\mathrm{num}}/(\\sigma_{y}\\,Z_{p})$ 趋近于 1，这符合预期。\n\n程序实现了：\n- 一个多边形扫描线切片器，以获得纤维宽度 $w_{i}$。\n- 从纤维计算离散化形心 $y_{c}$。\n- 一个稳健的二分法，用于求解 $\\varepsilon_{0}$ 以强制 $N=0$。\n- $M(\\kappa)$ 和 $Z_{p}$ 的数值计算。\n- 基于上述推导表达式的矩形截面解析公式。\n- 指定的测试套件，其输出为：\n  1. 矩形, $\\kappa=0.1\\,\\kappa_{y}$：报告 $\\big|M_{\\mathrm{num}}-M_{\\mathrm{ana}}\\big|/M_{\\mathrm{ana}}$。\n  2. 矩形, $\\kappa=1.0\\,\\kappa_{y}$：相同的相对误差。\n  3. 矩形, $\\kappa=5.0\\,\\kappa_{y}$：相同的相对误差。\n  4. 矩形, $\\kappa=200.0\\,\\kappa_{y}$：相同的相对误差。\n  5. 梯形, $\\kappa=50.0\\,\\kappa_{y}$：报告 $\\big|N(\\varepsilon_{0}^{\\star};\\kappa)\\big|/(\\sigma_{y}\\,A)$。\n  6. 梯形, $\\kappa=200.0\\,\\kappa_{y}$：报告 $\\left| \\dfrac{M_{\\mathrm{num}}}{\\sigma_{y}\\,Z_{p}} - 1 \\right|$。\n\n所有输出都是无量纲的浮点数，按要求以单个列表的形式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef polygon_area_centroid(vertices):\n    \"\"\"\n    Compute polygon area and centroid (x_c, y_c) using the shoelace formula.\n    vertices: array-like of shape (n, 2), ordered counterclockwise, non-self-intersecting.\n    Returns: area (positive), x_c, y_c\n    \"\"\"\n    verts = np.asarray(vertices, dtype=float)\n    x = verts[:, 0]\n    y = verts[:, 1]\n    # Close the polygon\n    x_shift = np.roll(x, -1)\n    y_shift = np.roll(y, -1)\n    cross = x * y_shift - x_shift * y\n    area = 0.5 * np.sum(cross)\n    if area == 0.0:\n        return 0.0, np.nan, np.nan\n    cx = (1.0 / (6.0 * area)) * np.sum((x + x_shift) * cross)\n    cy = (1.0 / (6.0 * area)) * np.sum((y + y_shift) * cross)\n    return abs(area), cx, cy\n\ndef scanline_fibers(vertices, Ny):\n    \"\"\"\n    Discretize a simple polygon by horizontal scanlines into Ny fibers.\n    Returns:\n      y_centers: (Ny,) array of y ordinates (midpoints of slices)\n      widths: (Ny,) array of total width inside polygon at each y\n      dy: scalar fiber thickness\n    \"\"\"\n    verts = np.asarray(vertices, dtype=float)\n    # Bounding box in y\n    y_min = np.min(verts[:, 1])\n    y_max = np.max(verts[:, 1])\n    # Avoid degenerate dy\n    Ny = int(Ny)\n    if Ny < 1:\n        raise ValueError(\"Ny must be >= 1\")\n    dy = (y_max - y_min) / Ny\n    # Place y-centers at midpoints of each slice\n    y_centers = y_min + (np.arange(Ny) + 0.5) * dy\n\n    # Precompute edges\n    n = len(verts)\n    x1 = verts[:, 0]\n    y1 = verts[:, 1]\n    x2 = np.roll(x1, -1)\n    y2 = np.roll(y1, -1)\n\n    widths = np.zeros_like(y_centers)\n    # For each scanline, compute intersections\n    for i, y in enumerate(y_centers):\n        xs = []\n        for j in range(n):\n            yj1 = y1[j]\n            yj2 = y2[j]\n            xj1 = x1[j]\n            xj2 = x2[j]\n            # Skip horizontal edges to avoid double counting\n            if yj1 == yj2:\n                continue\n            # Check if scanline intersects edge with standard rule:\n            # Include lower endpoint, exclude upper to avoid double counting at vertices\n            ymin = min(yj1, yj2)\n            ymax = max(yj1, yj2)\n            if (y >= ymin) and (y < ymax):\n                # Linear interpolation for intersection x\n                t = (y - yj1) / (yj2 - yj1)\n                x_int = xj1 + t * (xj2 - xj1)\n                xs.append(x_int)\n        if len(xs) == 0:\n            widths[i] = 0.0\n        else:\n            xs.sort()\n            # Pair up consecutive intersections\n            total_width = 0.0\n            for k in range(0, len(xs) - 1, 2):\n                total_width += xs[k + 1] - xs[k]\n            widths[i] = total_width\n    return y_centers, widths, dy\n\ndef fibers_from_polygon(vertices, Ny):\n    \"\"\"\n    Build fiber discretization arrays from polygon.\n    Returns:\n      y: (m,) array of y positions\n      dA: (m,) array of fiber areas\n      y_centroid: scalar centroid ordinate computed from fibers\n      area: total area from fibers\n    \"\"\"\n    y, widths, dy = scanline_fibers(vertices, Ny)\n    dA = widths * dy\n    area = dA.sum()\n    if area <= 0.0:\n        return y, dA, np.nan, 0.0\n    y_centroid = (y * dA).sum() / area\n    return y, dA, y_centroid, area\n\ndef elastoplastic_stress(E, sigy, strain):\n    \"\"\"\n    Elastic-perfectly-plastic stress.\n    \"\"\"\n    sig = E * strain\n    sig = np.clip(sig, -sigy, sigy)\n    return sig\n\ndef solve_epsilon0_for_N_zero(E, sigy, kappa, y, dA, y_ref, tol=1e-14, max_iter=200):\n    \"\"\"\n    Solve for epsilon0 such that sum sigma(epsilon0 + kappa*(y - y_ref)) * dA = 0.\n    Use bisection with automatic bracketing.\n    \"\"\"\n    y_diff = y - y_ref\n    Y = np.max(np.abs(y_diff)) if y.size > 0 else 0.0\n    # Initial bracket based on saturating beyond yield plus kappa*Y\n    alpha = 2.0 * sigy / E if E > 0 else 1.0\n    lo = -alpha - abs(kappa) * (Y + 1.0)\n    hi = alpha + abs(kappa) * (Y + 1.0)\n\n    def N_of_eps0(eps0):\n        strain = eps0 + kappa * y_diff\n        sig = elastoplastic_stress(E, sigy, strain)\n        return float(np.dot(sig, dA))\n\n    f_lo = N_of_eps0(lo)\n    f_hi = N_of_eps0(hi)\n    # Expand bracket if no sign change\n    expand = 0\n    while f_lo * f_hi > 0 and expand < 50:\n        lo -= alpha + abs(kappa) * (Y + 1.0) * (2 ** (expand + 1))\n        hi += alpha + abs(kappa) * (Y + 1.0) * (2 ** (expand + 1))\n        f_lo = N_of_eps0(lo)\n        f_hi = N_of_eps0(hi)\n        expand += 1\n    # If still no sign change (degenerate cross-section), return zero\n    if f_lo == 0.0:\n        return lo\n    if f_hi == 0.0:\n        return hi\n    if f_lo * f_hi > 0:\n        # Fallback: return mid (should not happen for valid sections)\n        return 0.0\n    # Bisection\n    for _ in range(max_iter):\n        mid = 0.5 * (lo + hi)\n        f_mid = N_of_eps0(mid)\n        if abs(f_mid) <= tol:\n            return mid\n        if f_lo * f_mid < 0.0:\n            hi = mid\n            f_hi = f_mid\n        else:\n            lo = mid\n            f_lo = f_mid\n        if abs(hi - lo) <= max(1e-16, 0.5 * tol * (abs(lo) + abs(hi) + 1.0)):\n            return 0.5 * (lo + hi)\n    return 0.5 * (lo + hi)\n\ndef numerical_M_of_kappa(vertices, E, sigy, kappa, Ny):\n    \"\"\"\n    Compute numerical bending moment M for a polygon at curvature kappa via fiber method.\n    Returns:\n      M_num: numerical moment about centroidal axis\n      N_res: residual axial force (should be ~ 0)\n      A: area\n      y_c: centroid ordinate\n      y: fiber y positions\n      dA: fiber areas\n    \"\"\"\n    y, dA, y_c, A = fibers_from_polygon(vertices, Ny)\n    if A <= 0.0 or not np.isfinite(y_c):\n        return 0.0, 0.0, 0.0, np.nan, y, dA\n    eps0 = solve_epsilon0_for_N_zero(E, sigy, kappa, y, dA, y_c)\n    strain = eps0 + kappa * (y - y_c)\n    sig = elastoplastic_stress(E, sigy, strain)\n    N_res = float(np.dot(sig, dA))\n    M_num = float(np.dot(sig * (y - y_c), dA))\n    return M_num, N_res, A, y_c, y, dA\n\ndef analytic_M_rect(b, h, E, sigy, kappa):\n    \"\"\"\n    Analytical M(kappa) for a rectangular cross-section under elastic-perfectly-plastic law.\n    \"\"\"\n    c = 0.5 * h\n    I = b * h**3 / 12.0\n    ky = sigy / (E * c) if E > 0 and c > 0 else np.inf\n    kappa_abs = abs(kappa)\n    if kappa_abs <= ky:\n        M = E * I * kappa\n        return M\n    # Partially plastic or near fully plastic\n    e = sigy / (E * kappa_abs)\n    # Ensure e does not exceed c due to floating error\n    e = min(e, c)\n    term1 = 2.0 * b * (E * kappa_abs * e**3 / 3.0)\n    term2 = 2.0 * b * (sigy * (c**2 - e**2) / 2.0)\n    M_abs = term1 + term2\n    # Sign follow kappa\n    return np.sign(kappa) * M_abs\n\ndef rectangle_vertices(b, h, y0=0.0, x0=0.0):\n    \"\"\"\n    Build rectangle polygon with bottom at y0 and top at y0+h, centered at x0, width b.\n    Returns CCW vertices.\n    \"\"\"\n    half_b = 0.5 * b\n    return np.array([\n        [x0 - half_b, y0],\n        [x0 + half_b, y0],\n        [x0 + half_b, y0 + h],\n        [x0 - half_b, y0 + h]\n    ], dtype=float)\n\ndef compute_Zp_from_fibers(y, dA, y_c):\n    \"\"\"\n    Compute plastic section modulus Zp = integral |y - y_c| dA using fibers.\n    \"\"\"\n    return float(np.dot(np.abs(y - y_c), dA))\n\ndef solve():\n    # Material properties\n    E = 210.0e9  # Pa\n    sigy = 250.0e6  # Pa\n\n    # Rectangle parameters\n    b = 0.1   # m\n    h = 0.2   # m\n    rect_poly = rectangle_vertices(b, h, y0=0.0, x0=0.0)\n\n    # Yield curvature for the rectangle\n    c = 0.5 * h\n    ky = sigy / (E * c)\n\n    # Trapezoid polygon (isosceles), vertices CCW\n    trapezoid = np.array([\n        [-0.03, 0.0],\n        [ 0.03, 0.0],\n        [ 0.09, 0.2],\n        [-0.09, 0.2]\n    ], dtype=float)\n\n    # Discretization resolution\n    Ny_rect = 8000  # high resolution for rectangle\n    Ny_trap = 8000  # high resolution for trapezoid\n\n    # Test suite curvatures\n    kappas_rect = [0.1 * ky, 1.0 * ky, 5.0 * ky, 200.0 * ky]\n    kappas_trap = [50.0 * ky, 200.0 * ky]\n\n    results = []\n\n    # Rectangle cases: relative errors\n    for kappa in kappas_rect:\n        M_num, N_res, A_rect_num, yc_rect, y_rect, dA_rect = numerical_M_of_kappa(rect_poly, E, sigy, kappa, Ny_rect)\n        M_ana = analytic_M_rect(b, h, E, sigy, kappa)\n        # Avoid division by zero (kappa=0 not used in suite)\n        rel_err = abs(M_num - M_ana) / (abs(M_ana) if abs(M_ana) > 0 else 1.0)\n        results.append(rel_err)\n\n    # Trapezoid axial equilibrium check\n    kappa_trap_1 = kappas_trap[0]\n    M_num_tr1, N_res_tr1, A_trap1, yc_trap1, y_trap1, dA_trap1 = numerical_M_of_kappa(trapezoid, E, sigy, kappa_trap_1, Ny_trap)\n    axial_ratio = abs(N_res_tr1) / (sigy * A_trap1 if A_trap1 > 0 else 1.0)\n    results.append(axial_ratio)\n\n    # Trapezoid plastic limit check\n    kappa_trap_2 = kappas_trap[1]\n    M_num_tr2, N_res_tr2, A_trap2, yc_trap2, y_trap2, dA_trap2 = numerical_M_of_kappa(trapezoid, E, sigy, kappa_trap_2, Ny_trap)\n    Zp_trap = compute_Zp_from_fibers(y_trap2, dA_trap2, yc_trap2)\n    ratio_err = abs(M_num_tr2 / (sigy * Zp_trap) - 1.0) if Zp_trap > 0 else 0.0\n    results.append(ratio_err)\n\n    # Final print statement in the exact required format.\n    # Convert to standard decimal representation\n    # Use repr for clarity but ensure it's comma-separated within brackets\n    print(\"[\" + \",\" + \",\".join(f\"{r:.12e}\" for r in results)[1:] + \"]\" if False else f\"[{','.join(str(r) for r in results)}]\")\n\n# Ensure deterministic run\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2908874"}]}