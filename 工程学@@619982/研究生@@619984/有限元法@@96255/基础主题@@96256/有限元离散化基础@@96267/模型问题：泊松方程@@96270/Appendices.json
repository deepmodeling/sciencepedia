{"hands_on_practices": [{"introduction": "为了给有限元方法打下坚实的理论基础，我们从分析一维泊松方程这个基本问题开始。这个练习将引导你推导狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件下的弱形式，并强调选择合适函数空间如 $H^1_0$ 与 $H^1$ 以及满足可解性条件的关键性。通过将Lax-Milgram定理的理论框架与一个精确的解析解联系起来，你将对有限元方法所要逼近的连续问题建立起更深刻的直觉。[@problem_id:2579521]", "problem": "考虑开区间 $\\Omega=(0,1)$ 上具有常数源 $f(x)\\equiv 1$ 的一维泊松模型问题。从边值问题的强形式出发，基于索博列夫空间 $H^{1}(0,1)$ 和 $H^{1}_{0}(0,1)$ 推导其相应的弱形式：\n- 狄利克雷问题：求 $u:\\Omega\\to\\mathbb{R}$ 使得对于 $x\\in(0,1)$ 有 $-u''(x)=1$，且 $u(0)=u(1)=0$。\n- 纯诺伊曼问题：求 $u:\\Omega\\to\\mathbb{R}$ 使得对于 $x\\in(0,1)$ 有 $-u''(x)=1$，且 $u'(0)=u'(1)=0$。\n\n利用弱形式，通过引用庞加莱不等式和 Lax–Milgram 定理（可不加证明地叙述）来证明解的存在性和唯一性（在适当情况下相差一个加性常数），然后求解强形式以获得：\n1. 狄利克雷问题的唯一解。\n2. 纯诺伊曼问题解集的刻画，包括关于 $f$ 的可解性的必要相容性条件，以及对于给定的 $f(x)\\equiv 1$ 的可解性结论。\n\n作为最终答案，仅报告狄利克雷解 $u_{D}(x)$ 的显式闭式表达式。无需四舍五入，也无需涉及物理单位。", "solution": "所述问题在数学上是良定的，是椭圆边值问题分析中的一个标准练习。我们通过依次分析狄利克雷问题和纯诺伊曼问题来求解。\n\n首先，我们考虑狄利克雷问题：\n求 $u: \\Omega \\to \\mathbb{R}$ 使得\n$$\n-u''(x) = 1 \\text{ for } x \\in \\Omega = (0,1)\n$$\n带有齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。\n\n为了推导弱形式，我们首先定义适当的函数空间。齐次边界条件是本质（或稳定）条件，必须被构建到试探函数和检验函数的空间中。正确的空间是索博列夫空间 $H^{1}_{0}(\\Omega)$，定义为 $C^{\\infty}_{c}(\\Omega)$（在 $\\Omega$ 中具有紧支集的无穷可微函数）在 $H^{1}$ 范数下的闭包。$H^{1}_{0}(\\Omega)$ 中的函数在边界上的值为零（在迹的意义上）。\n\n我们将方程的强形式乘以一个任意的检验函数 $v \\in H^{1}_{0}(\\Omega)$，并在区域 $\\Omega$ 上积分：\n$$\n\\int_{0}^{1} -u''(x)v(x) \\,dx = \\int_{0}^{1} 1 \\cdot v(x) \\,dx\n$$\n对左侧应用分部积分法得到：\n$$\n\\int_{0}^{1} u'(x)v'(x) \\,dx - \\left[ u'(x)v(x) \\right]_{0}^{1} = \\int_{0}^{1} v(x) \\,dx\n$$\n由于检验函数 $v$ 属于 $H^{1}_{0}(\\Omega)$，我们有 $v(0) = v(1) = 0$。因此，边界项 $\\left[ u'(x)v(x) \\right]_{0}^{1}$ 为零。这引出了狄利克雷问题的弱形式：\n求 $u \\in H^{1}_{0}(\\Omega)$ 使得\n$$\n\\int_{0}^{1} u'(x)v'(x) \\,dx = \\int_{0}^{1} v(x) \\,dx \\quad \\forall v \\in H^{1}_{0}(\\Omega)\n$$\n这可以写成抽象形式 $a(u,v) = L(v)$，其中双线性形式 $a(\\cdot, \\cdot): H^{1}_{0}(\\Omega) \\times H^{1}_{0}(\\Omega) \\to \\mathbb{R}$ 定义为 $a(u,v) = \\int_{0}^{1} u'(x)v'(x) \\,dx$，线性泛函 $L(\\cdot): H^{1}_{0}(\\Omega) \\to \\mathbb{R}$ 定义为 $L(v) = \\int_{0}^{1} v(x) \\,dx$。\n\n该弱问题的解的存在性和唯一性由 Lax-Milgram 定理保证。我们必须验证双线性形式 $a(u,v)$ 是有界的和强制的（或 $H^{1}_{0}$-椭圆的），并且线性泛函 $L(v)$ 是有界的。\n1. $a(u,v)$ 的有界性：根据柯西-施瓦茨不等式，\n$|a(u,v)| = \\left| \\int_{0}^{1} u'v' \\,dx \\right| \\leq \\|u'\\|_{L^{2}} \\|v'\\|_{L^{2}} \\leq \\|u\\|_{H^{1}} \\|v\\|_{H^{1}}$。因此 $a(u,v)$ 是有界的。\n2. $a(u,v)$ 的强制性：我们有 $a(u,u) = \\int_{0}^{1} (u'(x))^{2} \\,dx = \\|u'\\|_{L^{2}}^{2}$。对于 $H^{1}_{0}(\\Omega)$ 中的函数，庞加莱不等式指出存在一个常数 $C_{P} > 0$ 使得 $\\|u\\|_{L^{2}} \\leq C_{P} \\|u'\\|_{L^{2}}$。完整的 $H^{1}$ 范数为 $\\|u\\|_{H^{1}}^{2} = \\|u\\|_{L^{2}}^{2} + \\|u'\\|_{L^{2}}^{2}$。利用庞加莱不等式，我们得到 $\\|u\\|_{H^{1}}^{2} \\leq (C_{P}^{2} + 1)\\|u'\\|_{L^{2}}^{2} = (C_{P}^{2} + 1)a(u,u)$。因此，$a(u,u) \\geq \\frac{1}{C_{P}^{2}+1} \\|u\\|_{H^{1}}^{2}$。这证明了 $a(u,v)$ 是强制的，其强制性常数为 $\\alpha = (C_{P}^{2}+1)^{-1} > 0$。\n3. $L(v)$ 的有界性：根据柯西-施瓦茨不等式， $|L(v)| = \\left| \\int_{0}^{1} 1 \\cdot v(x) \\,dx \\right| \\leq \\|1\\|_{L^{2}} \\|v\\|_{L^{2}} = \\sqrt{1} \\cdot \\|v\\|_{L^{2}} \\leq \\|v\\|_{H^{1}}$。因此 $L(v)$ 是有界的。\n由于所有条件都得到满足，Lax-Milgram 定理保证了唯一解 $u \\in H^{1}_{0}(\\Omega)$ 的存在性。\n\n为了显式地求出这个解，我们通过直接积分来解强形式：\n$-u''(x) = 1$\n对 $x$ 积分一次得到：\n$-u'(x) = x + C_{1}$\n再次积分得到：\n$-u(x) = \\frac{1}{2}x^{2} + C_{1}x + C_{2}$\n所以，通解为 $u(x) = -\\frac{1}{2}x^{2} - C_{1}x - C_{2}$。\n我们应用边界条件来确定常数 $C_1$ 和 $C_2$：\n$u(0) = 0 \\implies -\\frac{1}{2}(0)^{2} - C_{1}(0) - C_{2} = 0 \\implies C_{2} = 0$。\n$u(1) = 0 \\implies -\\frac{1}{2}(1)^{2} - C_{1}(1) - 0 = 0 \\implies -\\frac{1}{2} - C_{1} = 0 \\implies C_{1} = -\\frac{1}{2}$。\n将常数代回，狄利克雷问题的唯一解为：\n$u_{D}(x) = -\\frac{1}{2}x^{2} - \\left(-\\frac{1}{2}\\right)x = \\frac{1}{2}x - \\frac{1}{2}x^{2} = \\frac{1}{2}x(1-x)$。\n\n接下来，我们考虑纯诺伊曼问题：\n求 $u: \\Omega \\to \\mathbb{R}$ 使得\n$$\n-u''(x) = 1 \\text{ for } x \\in \\Omega = (0,1)\n$$\n带有齐次诺伊曼边界条件 $u'(0) = 0$ 和 $u'(1) = 0$。\n\n诺伊曼条件是自然边界条件，因此它们不施加于函数空间上。试探函数和检验函数的适当空间都是 $H^{1}(\\Omega)$。我们乘以一个检验函数 $v \\in H^{1}(\\Omega)$ 并积分：\n$\\int_{0}^{1} -u''(x)v(x) \\,dx = \\int_{0}^{1} 1 \\cdot v(x) \\,dx$。\n分部积分得到：\n$\\int_{0}^{1} u'(x)v'(x) \\,dx - \\left[ u'(x)v(x) \\right]_{0}^{1} = \\int_{0}^{1} v(x) \\,dx$。\n边界项为 $- (u'(1)v(1) - u'(0)v(0))$。利用指定的诺伊曼条件 $u'(0)=0$ 和 $u'(1)=0$，该项为零。因此弱形式为：\n求 $u \\in H^{1}(\\Omega)$ 使得\n$$\n\\int_{0}^{1} u'(x)v'(x) \\,dx = \\int_{0}^{1} v(x) \\,dx \\quad \\forall v \\in H^{1}(\\Omega)\n$$\n这同样是 $a(u,v) = L(v)$ 的形式，其中 $a(u,v) = \\int_{0}^{1} u'v' \\,dx$ 和 $L(v) = \\int_{0}^{1} v \\,dx$，但现在是在空间 $H^{1}(\\Omega)$ 上。\n\n对于此问题，双线性形式 $a(u,v)$ 在 $H^{1}(\\Omega)$ 上不是强制的。考虑任意非零常数函数 $u(x) = c \\neq 0$。对于这样的函数，$\\|u\\|_{H^{1}}^{2} = \\int_{0}^{1} c^{2} \\,dx + \\int_{0}^{1} 0^{2} \\,dx = c^{2} > 0$。然而，$a(u,u) = \\int_{0}^{1} (u'(x))^{2} \\,dx = \\int_{0}^{1} 0^{2} \\,dx = 0$。因此，不存在常数 $\\alpha > 0$ 使得对于所有 $u \\in H^{1}(\\Omega)$ 都有 $a(u,u) \\ge \\alpha \\|u\\|_{H^{1}}^{2}$。该双线性形式的核由所有常数函数组成。Lax-Milgram 定理不直接适用。\n\n解存在的必要条件是，对于 $a(\\cdot, \\cdot)$ 的核中的所有函数 $v$，右端项泛函 $L(v)$ 必须为零。我们通过选择检验函数 $v(x)=1$（它是核的一组基）来检验此条件。\n$L(1) = \\int_{0}^{1} f(x) \\cdot 1 \\,dx = \\int_{0}^{1} 1 \\,dx = 1$。\n由于 $L(1) = 1 \\neq 0$，相容性条件不满足。因此，源为 $f(x)=1$ 的纯诺伊曼问题无解。\n\n这可以通过将方程的强形式在定义域上积分来证实：\n$\\int_{0}^{1} -u''(x) \\,dx = \\int_{0}^{1} f(x) \\,dx$\n对左侧应用微积分基本定理：\n$-[u'(x)]_{0}^{1} = \\int_{0}^{1} f(x) \\,dx$\n$-(u'(1) - u'(0)) = \\int_{0}^{1} f(x) \\,dx$\n代入诺伊曼边界条件 $u'(0) = 0$ 和 $u'(1) = 0$ 得到相容性（或可解性）条件：\n$0 = \\int_{0}^{1} f(x) \\,dx$。\n对于给定的源项 $f(x)=1$，我们有 $\\int_{0}^{1} 1 \\,dx = 1 \\neq 0$。该条件不被满足，证实了不存在经典解。\n\n如果源项 $f$ 确实满足 $\\int_{0}^{1} f(x) \\,dx = 0$，解将会存在，但不是唯一的。如果 $u(x)$ 是一个解，那么对于任意常数 $C \\in \\mathbb{R}$，$u(x)+C$ 也是一个解，因为 $(u+C)'' = u''$ 且 $(u+C)'=u'$。解集将是一个相差一个加性常数的函数等价类。可以通过施加一个额外的约束，例如 $\\int_{0}^{1} u(x) \\,dx = 0$，来获得唯一解。", "answer": "$$\n\\boxed{\\frac{1}{2}x(1-x)}\n$$", "id": "2579521"}, {"introduction": "在理解了连续弱形式之后，下一步便是将其离散化。该练习专注于推导单元刚度矩阵 $K^e$，这是任何有限元代码中的基本构件。通过从第一性原理出发，为一个标准的二维三角形单元计算矩阵项并分析其正定性等性质，你将揭示弱形式中的积分与最终代数系统之间的直接联系，并理解矩阵零空间所对应的物理意义。[@problem_id:2579542]", "problem": "考虑在有限元法 (FEM) 中使用的单个参考单元上的模型泊松问题 $-\\Delta u = f$。令 $\\widehat{T}$ 表示 $\\mathbb{R}^{2}$ 中的参考直角三角形，其顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$。令 $\\{\\widehat{N}_{1},\\widehat{N}_{2},\\widehat{N}_{3}\\}$ 为与这些顶点相关的标准线性 Lagrange 形函数。对于具有单位扩散系数的 Laplace 算子，其单元刚度矩阵 $K^{e} \\in \\mathbb{R}^{3 \\times 3}$ 由双线性形式定义：\n$$\nK^{e}_{ij} \\;=\\; \\int_{\\widehat{T}} \\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j} \\, d\\widehat{x}, \\quad i,j \\in \\{1,2,3\\}.\n$$\n从 Poisson 方程的弱形式和 $\\widehat{T}$ 上线性形函数的定义出发，依据第一性原理显式推导出 $K^{e}$（不要假定任何预先计算好的单元矩阵），并利用推导过程来验证其对称性及严格判断其定性。具体来说，确定 $K^{e}$ 是严格正定的还是仅为半正定的，并在其零空间存在的情况下，指出其零空间。\n\n你最终报告的量必须是 $\\det(K^{e})$ 的精确值，作为一个实数。无需四舍五入，也没有单位。请提供完整的推导和证明，然后仅报告 $\\det(K^{e})$ 作为最终答案。", "solution": "该问题要求在标准的二维线性三角形参考单元 $\\widehat{T}$ 上，针对 Laplace 算子，推导并分析单元刚度矩阵 $K^{e}$。$\\widehat{T}$ 的顶点为 $\\widehat{\\mathbf{x}}_1 = (0,0)$、$\\widehat{\\mathbf{x}}_2 = (1,0)$ 和 $\\widehat{\\mathbf{x}}_3 = (0,1)$。\n\n首先，我们必须确定与这些顶点相关的线性 Lagrange 形函数 $\\{\\widehat{N}_{1}, \\widehat{N}_{2}, \\widehat{N}_{3}\\}$。$\\mathbb{R}^{2}$ 上的线性函数具有一般形式 $\\widehat{N}(\\widehat{x}, \\widehat{y}) = a\\widehat{x} + b\\widehat{y} + c$。形函数 $\\widehat{N}_{i}$ 由属性 $\\widehat{N}_{i}(\\widehat{\\mathbf{x}}_{j}) = \\delta_{ij}$ 定义，其中 $\\delta_{ij}$ 是 Kronecker delta。\n\n对于 $\\widehat{N}_{1}(\\widehat{x}, \\widehat{y}) = a_1\\widehat{x} + b_1\\widehat{y} + c_1$：\n条件是 $\\widehat{N}_{1}(0,0)=1$, $\\widehat{N}_{1}(1,0)=0$, $\\widehat{N}_{1}(0,1)=0$。\n由 $\\widehat{N}_{1}(0,0)=1$ 可得 $c_1=1$。\n由 $\\widehat{N}_{1}(1,0)=0$ 可得 $a_1 + c_1 = 0 \\implies a_1 = -1$。\n由 $\\widehat{N}_{1}(0,1)=0$ 可得 $b_1 + c_1 = 0 \\implies b_1 = -1$。\n因此，$\\widehat{N}_{1}(\\widehat{x}, \\widehat{y}) = 1 - \\widehat{x} - \\widehat{y}$。\n\n对于 $\\widehat{N}_{2}(\\widehat{x}, \\widehat{y}) = a_2\\widehat{x} + b_2\\widehat{y} + c_2$：\n条件是 $\\widehat{N}_{2}(0,0)=0$, $\\widehat{N}_{2}(1,0)=1$, $\\widehat{N}_{2}(0,1)=0$。\n由 $\\widehat{N}_{2}(0,0)=0$ 可得 $c_2=0$。\n由 $\\widehat{N}_{2}(1,0)=1$ 可得 $a_2 = 1$。\n由 $\\widehat{N}_{2}(0,1)=0$ 可得 $b_2 = 0$。\n因此，$\\widehat{N}_{2}(\\widehat{x}, \\widehat{y}) = \\widehat{x}$。\n\n对于 $\\widehat{N}_{3}(\\widehat{x}, \\widehat{y}) = a_3\\widehat{x} + b_3\\widehat{y} + c_3$：\n条件是 $\\widehat{N}_{3}(0,0)=0$, $\\widehat{N}_{3}(1,0)=0$, $\\widehat{N}_{3}(0,1)=1$。\n由 $\\widehat{N}_{3}(0,0)=0$ 可得 $c_3=0$。\n由 $\\widehat{N}_{3}(1,0)=0$ 可得 $a_3 = 0$。\n由 $\\widehat{N}_{3}(0,1)=1$ 可得 $b_3 = 1$。\n因此，$\\widehat{N}_{3}(\\widehat{x}, \\widehat{y}) = \\widehat{y}$。\n\n接下来，我们计算这些形函数的梯度。由于这些函数是线性的，它们的梯度是常数向量。\n$$\n\\nabla \\widehat{N}_{1} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}, \\quad\n\\nabla \\widehat{N}_{2} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad\n\\nabla \\widehat{N}_{3} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}.\n$$\n\n单元刚度矩阵 $K^{e}$ 的元素由 $K^{e}_{ij} = \\int_{\\widehat{T}} \\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j} \\, d\\widehat{x}$ 定义。由于梯度是常数，点积 $\\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j}$ 也是常数。因此，积分就是这个常数值与区域 $\\widehat{T}$ 面积的乘积。\n$$\nK^{e}_{ij} = (\\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j}) \\int_{\\widehat{T}} 1 \\, d\\widehat{x} = (\\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j}) \\cdot \\text{Area}(\\widehat{T}).\n$$\n顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的直角三角形的面积为 $\\text{Area}(\\widehat{T}) = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$。\n\n我们现在计算梯度的点积：\n$\\nabla \\widehat{N}_{1} \\cdot \\nabla \\widehat{N}_{1} = (-1)^2 + (-1)^2 = 2$。\n$\\nabla \\widehat{N}_{1} \\cdot \\nabla \\widehat{N}_{2} = (-1)(1) + (-1)(0) = -1$。\n$\\nabla \\widehat{N}_{1} \\cdot \\nabla \\widehat{N}_{3} = (-1)(0) + (-1)(1) = -1$。\n$\\nabla \\widehat{N}_{2} \\cdot \\nabla \\widehat{N}_{2} = (1)^2 + (0)^2 = 1$。\n$\\nabla \\widehat{N}_{2} \\cdot \\nabla \\widehat{N}_{3} = (1)(0) + (0)(1) = 0$。\n$\\nabla \\widehat{N}_{3} \\cdot \\nabla \\widehat{N}_{3} = (0)^2 + (1)^2 = 1$。\n\n利用这些值和 $\\text{Area}(\\widehat{T}) = \\frac{1}{2}$，我们组装矩阵 $K^{e}$：\n$K^{e}_{11} = 2 \\times \\frac{1}{2} = 1$。\n$K^{e}_{12} = -1 \\times \\frac{1}{2} = -\\frac{1}{2}$。\n$K^{e}_{13} = -1 \\times \\frac{1}{2} = -\\frac{1}{2}$。\n$K^{e}_{22} = 1 \\times \\frac{1}{2} = \\frac{1}{2}$。\n$K^{e}_{23} = 0 \\times \\frac{1}{2} = 0$。\n$K^{e}_{33} = 1 \\times \\frac{1}{2} = \\frac{1}{2}$。\n\n根据点积的交换律，$\\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j} = \\nabla \\widehat{N}_{j} \\cdot \\nabla \\widehat{N}_{i}$，这意味着 $K^{e}_{ij} = K^{e}_{ji}$。该矩阵是对称的。完整的矩阵是：\n$$\nK^{e} = \\begin{pmatrix}\n1 & -\\frac{1}{2} & -\\frac{1}{2} \\\\\n-\\frac{1}{2} & \\frac{1}{2} & 0 \\\\\n-\\frac{1}{2} & 0 & \\frac{1}{2}\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n2 & -1 & -1 \\\\\n-1 & 1 & 0 \\\\\n-1 & 0 & 1\n\\end{pmatrix}.\n$$\n\n现在，我们分析 $K^{e}$ 的定性。考虑一个任意向量 $\\mathbf{v} = (v_1, v_2, v_3)^T \\in \\mathbb{R}^3$ 和相关的二次型 $\\mathbf{v}^T K^e \\mathbf{v}$。令 $\\widehat{u}_h(\\widehat{\\mathbf{x}}) = \\sum_{j=1}^{3} v_j \\widehat{N}_j(\\widehat{\\mathbf{x}})$ 为有限元空间中的一个函数。二次型为：\n$$\n\\mathbf{v}^T K^e \\mathbf{v} = \\sum_{i=1}^{3} \\sum_{j=1}^{3} v_i K^{e}_{ij} v_j = \\sum_{i,j} v_i v_j \\int_{\\widehat{T}} \\nabla \\widehat{N}_{i} \\cdot \\nabla \\widehat{N}_{j} \\, d\\widehat{x}\n$$\n根据积分和微分的线性性质，这变为：\n$$\n\\mathbf{v}^T K^e \\mathbf{v} = \\int_{\\widehat{T}} \\left( \\sum_{i=1}^{3} v_i \\nabla \\widehat{N}_{i} \\right) \\cdot \\left( \\sum_{j=1}^{3} v_j \\nabla \\widehat{N}_{j} \\right) \\, d\\widehat{x} = \\int_{\\widehat{T}} |\\nabla \\widehat{u}_h|^2 \\, d\\widehat{x}.\n$$\n由于被积函数 $|\\nabla \\widehat{u}_h|^2$ 是非负的，所以积分也是非负的。因此，对于所有 $\\mathbf{v} \\in \\mathbb{R}^3$，都有 $\\mathbf{v}^T K^e \\mathbf{v} \\geq 0$，这证明了 $K^{e}$ 是半正定的。\n\n要使 $K^{e}$ 是正定的，$\\mathbf{v}^T K^e \\mathbf{v} = 0$ 必须意味着 $\\mathbf{v} = \\mathbf{0}$。条件 $\\mathbf{v}^T K^e \\mathbf{v} = 0$ 等价于 $\\int_{\\widehat{T}} |\\nabla \\widehat{u}_h|^2 \\, d\\widehat{x} = 0$。由于被积函数是连续且非负的，这意味着对于所有 $\\widehat{\\mathbf{x}} \\in \\widehat{T}$，都有 $\\nabla \\widehat{u}_h(\\widehat{\\mathbf{x}}) = \\mathbf{0}$。\n$$\n\\nabla \\widehat{u}_h = \\nabla \\left( \\sum_{j=1}^{3} v_j \\widehat{N}_j \\right) = \\sum_{j=1}^{3} v_j \\nabla \\widehat{N}_j = v_1 \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} + v_2 \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + v_3 \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -v_1 + v_2 \\\\ -v_1 + v_3 \\end{pmatrix}.\n$$\n令梯度为零，得到方程组：\n$$\n-v_1 + v_2 = 0 \\implies v_1 = v_2\n$$\n$$\n-v_1 + v_3 = 0 \\implies v_1 = v_3\n$$\n因此，$\\nabla \\widehat{u}_h = \\mathbf{0}$ 当且仅当 $v_1 = v_2 = v_3$。对于任意标量 $c \\in \\mathbb{R}$，形如 $\\mathbf{v} = c(1, 1, 1)^T$ 的向量都会导致 $\\mathbf{v}^T K^e \\mathbf{v} = 0$。如果 $c \\neq 0$，则 $\\mathbf{v} \\neq \\mathbf{0}$。这证明了 $K^{e}$ 不是正定的；它只是半正定的。\n这类向量的集合构成了 $K^e$ 的零空间（核）：\n$$\n\\text{ker}(K^e) = \\{ \\mathbf{v} \\in \\mathbb{R}^3 : K^e \\mathbf{v} = \\mathbf{0} \\} = \\text{span} \\left\\{ \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\right\\}.\n$$\n其物理意义是常数函数 $\\widehat{u}_h = c \\sum \\widehat{N}_j = c(1) = c$ 的梯度为零，因此其“应变能” $\\int |\\nabla u|^2$ 也为零。\n\n最后，我们必须计算 $K^{e}$ 的行列式。线性代数的一个基本定理指出，一个方阵是奇异的（即不可逆的）当且仅当其零空间非平凡。正如我们已经证明的 $\\text{dim}(\\text{ker}(K^e)) = 1$，矩阵 $K^{e}$ 是奇异的。任何奇异矩阵的行列式均为零。\n因此，$\\det(K^{e}) = 0$。\n\n为求完整，我们通过直接计算来验证这一点：\n$$\n\\det(K^{e}) = \\det \\begin{pmatrix}\n1 & -\\frac{1}{2} & -\\frac{1}{2} \\\\\n-\\frac{1}{2} & \\frac{1}{2} & 0 \\\\\n-\\frac{1}{2} & 0 & \\frac{1}{2}\n\\end{pmatrix}\n$$\n$$\n= 1 \\left( (\\frac{1}{2})(\\frac{1}{2}) - (0)(0) \\right) - (-\\frac{1}{2}) \\left( (-\\frac{1}{2})(\\frac{1}{2}) - (0)(-\\frac{1}{2}) \\right) + (-\\frac{1}{2}) \\left( (-\\frac{1}{2})(0) - (\\frac{1}{2})(-\\frac{1}{2}) \\right)\n$$\n$$\n= 1 \\left( \\frac{1}{4} \\right) + \\frac{1}{2} \\left( -\\frac{1}{4} \\right) - \\frac{1}{2} \\left( \\frac{1}{4} \\right)\n$$\n$$\n= \\frac{1}{4} - \\frac{1}{8} - \\frac{1}{8} = \\frac{1}{4} - \\frac{2}{8} = \\frac{1}{4} - \\frac{1}{4} = 0.\n$$\n计算结果证实了理论推断。最终答案是 $0$。", "answer": "$$\n\\boxed{0}\n$$", "id": "2579542"}, {"introduction": "最后的这个练习将理论与计算融为一体，通过一个数值实验来验证伽辽金（Galerkin）方法的一个基石原理。你将实现一个简单的有限元求解器，以验证在嵌套的、协调的函数空间中，随着网格的加密，离散解的能量泛函 $J(u_h)$ 会单调递减。这项动手编程任务将展示瑞利-里兹（Rayleigh-Ritz）最小化原理的实际应用，并为该方法的收敛特性提供具体证据。[@problem_id:2579540]", "problem": "考虑单位正方形上的泊松方程模型边值问题。令 $\\Omega=(0,1)^2$，令 $f:\\Omega\\to\\mathbb{R}$ 为光滑函数，考虑以下狄利克雷问题\n$$\n-\\Delta u = f \\quad \\text{在 } \\Omega \\text{ 内},\\qquad u=0 \\quad \\text{在 } \\partial\\Omega \\text{ 上}。\n$$\n相应的能量泛函为\n$$\nJ(v) = \\tfrac{1}{2}\\int_{\\Omega}\\lvert \\nabla v \\rvert^2\\,\\mathrm{d}x - \\int_{\\Omega} f\\, v\\,\\mathrm{d}x,\n$$\n其定义于索博列夫空间 $H_0^1(\\Omega)$ 中的 $v$。\n\n你的任务是，使用定义在 $\\Omega$ 相容三角剖分上的连续分片线性形函数的相容有限元方法 (FEM) 进行数值验证，证明在一致网格加密下 $J(u_h)$ 是单调递减的，其中 $u_h$ 表示相容有限元空间 $V_h \\subset H_0^1(\\Omega)$ 中的唯一伽辽金解。此验证必须通过在一系列一致加密的嵌套网格上，由组装好的离散双线性和线性形式直接计算 $J(u_h)$ 来完成。\n\n基本出发点：\n- 使用基于变分法第一原理的弱形式：$u\\in H_0^1(\\Omega)$ 的特征是 $J$ 在 $H_0^1(\\Omega)$ 上的唯一极小化子，等价地满足对于所有 $v\\in H_0^1(\\Omega)$ 都有 $\\int_{\\Omega} \\nabla u\\cdot\\nabla v\\,\\mathrm{d}x = \\int_{\\Omega} f v\\,\\mathrm{d}x$。\n- 对于相容离散化 $V_h\\subset H_0^1(\\Omega)$，伽辽金解 $u_h\\in V_h$ 是 $J$ 限制在 $V_h$ 上的唯一极小化子。\n\n待实现的算法规范：\n- 通过将 $\\Omega$ 划分成 $N\\times N$ 个全等正方形，并将每个正方形沿左下到右上的对角线进行细分，来构造一致的、形状规则的嵌套三角剖分，其中 $N\\in\\mathbb{N}$。这样每个正方形会产生两个直角三角形。$2N$ 加密后的网格节点是 $N$ 网格节点的超集，从而确保了嵌套的相容空间。\n- 使用连续分片线性基函数（相容的 $P^1$ 有限元），并通过将边界自由度置零来强加齐次本质边界条件。\n- 通过在每个三角形 $T$ 上对积分 $\\int_T \\nabla \\phi_i\\cdot\\nabla \\phi_j\\,\\mathrm{d}x$ 的单元贡献求和，来组装全局刚度矩阵。由于 $P^1$ 基函数的梯度在单元上是常数，该积分可以精确计算。\n- 通过在每个单元 $T$ 上对积分 $\\int_T f\\,\\phi_i\\,\\mathrm{d}x$ 的单元贡献求和，来组装全局载荷向量。对于一般的光滑函数 $f$，使用一个高阶求积方法来近似该积分，其精度应足以探测到单调性行为。在三角形上至少使用 5 阶高斯求积。对于 $f\\equiv 1$ 的特殊情况，必须使用恒等式 $\\int_T \\phi_i\\,\\mathrm{d}x = \\lvert T\\rvert/3$（其中 $\\lvert T\\rvert$ 是三角形 $T$ 的面积）精确计算单元载荷，以避免不必要的求积误差。\n- 求解关于内部自由度的线性系统以获得 $u_h$。\n- 根据组装好的算子计算离散能量值\n$$\nJ(u_h) = \\tfrac{1}{2}\\, \\mathbf{u}^\\top \\mathbf{K}\\,\\mathbf{u} - \\mathbf{u}^\\top \\mathbf{b},\n$$\n其中 $\\mathbf{K}$ 是限制在内部节点上的刚度矩阵，$\\mathbf{b}$ 是相应的载荷向量，$\\mathbf{u}$ 是 $u_h$ 的内部节点值向量。\n\n需要执行的测试：\n- 测试 A (常数强迫项，精确单元载荷)：对于所有 $(x,y)\\in\\Omega$，$f(x,y)=1$，网格参数 $N\\in\\{1,2,4,8,16,32\\}$。检查序列 $\\{J(u_h)\\}$ 是否在 $10^{-12}$ 的数值容差内非增。\n- 测试 B (三角函数强迫项，求积)：$f(x,y)=\\sin(\\pi x)\\sin(\\pi y)$，网格参数 $N\\in\\{2,4,8,16,32\\}$。载荷组装使用至少 5 阶的三角形高斯求积。检查是否在 $10^{-10}$ 的容差内非增。\n- 测试 C (指数函数强迫项，求积)：$f(x,y)=\\mathrm{e}^{x+y}$，网格参数 $N\\in\\{2,4,8,16\\}$。载荷组装使用至少 5 阶的三角形高斯求积。检查是否在 $10^{-10}$ 的容差内非增。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含测试 A、B、C 单调性检查的三个布尔值结果，以逗号分隔并用方括号括起，例如 $[\\text{True},\\text{True},\\text{True}]$。\n- 不应打印任何额外文本。\n\n不涉及物理单位。在任何辅助计算中，所有角度（若适用）均以弧度为单位。在中间检查中可能出现的任何百分比都必须作为小数处理，并且不是所需输出的一部分。确保你的程序是完全自包含的，不需要任何输入，并且只使用指定的库。", "solution": "问题陈述要求对相容伽辽金有限元方法的一个基本性质进行数值验证。该问题在科学上是有效的，数学上是适定的，并为其实现提供了完整而明确的规范。不存在任何缺陷、矛盾或无效的前提。\n\n待验证的核心原理是应用于嵌套、相容近似空间的 Rayleigh-Ritz 极小化原理的直接推论。给定一系列一致加密的网格 $\\mathcal{T}_{h_k}$，使得网格尺寸 $h_k \\to 0$，我们获得一个相应的嵌套有限元空间序列 $V_{h_1} \\subset V_{h_2} \\subset \\dots \\subset H_0^1(\\Omega)$。根据定义，伽辽金解 $u_{h_k} \\in V_{h_k}$ 是能量泛函 $J(v)$ 在空间 $V_{h_k}$ 上的唯一极小化子。\n$$\nJ(u_{h_k}) = \\min_{v_h \\in V_{h_k}} J(v_h)\n$$\n由于 $V_{h_k} \\subset V_{h_{k+1}}$，在 $V_{h_{k+1}}$ 上进行极小化时，$V_{h_k}$ 中的任何函数也都是候选的试探函数。特别地，有 $u_{h_k} \\in V_{h_{k+1}}$。因此，在较大空间 $V_{h_{k+1}}$ 上的最小能量不可能大于在该空间中任何函数（包括 $u_{h_k}$）上计算出的能量。\n$$\nJ(u_{h_{k+1}}) = \\min_{v_h \\in V_{h_{k+1}}} J(v_h) \\le J(u_{h_k})\n$$\n这证明了在一系列嵌套、相容的有限元空间上，伽辽金解的能量值序列 $\\{J(u_{h_k})\\}$ 必须是单调非增的。本问题即为对这一理论结果进行数值验证。\n\n实现过程如下，遵循算法规范。\n\n**1. 离散化与有限元空间**\n域 $\\Omega=(0,1)^2$ 被一个 $N \\times N$ 的正方形组成的均匀网格离散化，每个正方形的边长为 $h=1/N$。每个正方形沿其左下到右上的对角线被细分为两个等腰直角三角形。这产生了一个相容的三角剖分 $\\mathcal{T}_h$。有限元空间 $V_h$ 由连续函数构成，这些函数在每个三角形 $T \\in \\mathcal{T}_h$ 上是分片线性多项式，并在边界 $\\partial\\Omega$ 上为零。$V_h$ 的一组基由与网格内部节点相关联的节点“帽”函数 $\\{\\phi_i\\}$ 给出。\n\n**2. 代数表示**\n伽辽金解 $u_h = \\sum_{i \\in \\mathcal{I}} u_i \\phi_i(x)$（其中 $\\mathcal{I}$ 是内部节点索引的集合）通过求解线性代数系统 $\\mathbf{K}\\mathbf{u} = \\mathbf{b}$ 得到。该系统被限制在 $(N-1)^2$ 个内部自由度上，这对应于对齐次狄利克雷边界条件的强施加。\n刚度矩阵 $\\mathbf{K}$ 和载荷向量 $\\mathbf{b}$ 的各项为：\n$$\n\\mathbf{K}_{ij} = a(\\phi_j, \\phi_i) = \\int_\\Omega \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, dx \\quad \\text{以及} \\quad \\mathbf{b}_i = L(\\phi_i) = \\int_\\Omega f \\phi_i \\, dx\n$$\n这些全局矩阵是通过对单元贡献求和来组装的。对于每个三角形 $T$，我们计算 $3 \\times 3$ 的单元刚度矩阵 $K^e$ 和 $3 \\times 1$ 的单元载荷向量 $b^e$。\n\n**3. 单元矩阵和向量计算**\n$K^e$ 的各项是使用从一个参考三角形 $\\hat{T}$ 到物理三角形 $T$ 的仿射映射 $F_T: \\hat{T} \\to T$ 计算的。由于基函数 $\\phi_i$ 是线性的，它们的梯度在每个单元上是常数。这使得单元刚度矩阵可以被精确计算：\n$$\nK^e_{\\alpha\\beta} = \\int_T \\nabla\\phi_\\alpha \\cdot \\nabla\\phi_\\beta \\, dx = |T| (\\nabla\\phi_\\alpha \\cdot \\nabla\\phi_\\beta)\n$$\n其中 $|T|$ 是单元面积，$\\nabla\\phi_\\alpha = (B_T^{-1})^\\top \\nabla\\hat{\\phi}_\\alpha$，$B_T$ 是仿射映射的雅可比矩阵。\n\n单元载荷向量 $b^e$ 根据问题规范计算：\n- 对于 $f(x,y) = 1$，积分为精确值：$b^e_\\alpha = \\int_T \\phi_\\alpha \\, dx = |T|/3$。\n- 对于一般的光滑函数 $f$，需要进行数值求积。按照指定，采用一个 6 点对称求积法则，该法则对最高 5 次的多项式是精确的。单元 $T$ 上的积分近似为：\n$$\nb^e_\\alpha = \\int_T f \\phi_\\alpha \\, dx \\approx |T| \\sum_{q=1}^{6} w_q f(x_q) \\hat{\\phi}_\\alpha(\\hat{x}_q)\n$$\n其中 $\\{w_q, \\hat{x}_q\\}$ 是参考单元上的求积权重和点，$x_q = F_T(\\hat{x}_q)$ 是物理单元上对应的点。\n\n**4. 能量计算与验证**\n一旦系统 $\\mathbf{K}\\mathbf{u}=\\mathbf{b}$ 解出内部节点值向量 $\\mathbf{u}$，就可以计算伽辽金解 $u_h$ 的能量。伽辽金方程 $\\mathbf{K}\\mathbf{u}=\\mathbf{b}$ 的一个直接推论是能量可以高效地计算为：\n$$\nJ(u_h) = \\frac{1}{2}\\mathbf{u}^\\top \\mathbf{K} \\mathbf{u} - \\mathbf{u}^\\top \\mathbf{b} = \\frac{1}{2}\\mathbf{u}^\\top \\mathbf{b} - \\mathbf{u}^\\top \\mathbf{b} = -\\frac{1}{2}\\mathbf{u}^\\top \\mathbf{b}\n$$\n该公式用于计算。对于每个测试用例，针对指定的网格加密级别 $N$ 计算能量值序列 $\\{J(u_h)\\}$。然后通过验证每个加密步骤满足 $J(u_{h_{k+1}}) - J(u_{h_k}) \\le \\tau$ 来检查单调性，其中 $\\tau$ 是指定的数值容差。最终输出是一个布尔值列表，表示每个测试是否成功通过此检查。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function to run all specified tests and print the final result.\n    \"\"\"\n    # Test A: Constant forcing function f(x,y) = 1\n    # Use exact integration for the load vector.\n    f_A = lambda x, y: np.ones_like(x)\n    N_A = [1, 2, 4, 8, 16, 32]\n    result_A = run_test(f_A, N_A, use_quadrature=False, tol=1e-12)\n\n    # Test B: Trigonometric forcing function\n    f_B = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    N_B = [2, 4, 8, 16, 32]\n    result_B = run_test(f_B, N_B, use_quadrature=True, tol=1e-10)\n\n    # Test C: Exponential forcing function\n    f_C = lambda x, y: np.exp(x + y)\n    N_C = [2, 4, 8, 16]\n    result_C = run_test(f_C, N_C, use_quadrature=True, tol=1e-10)\n\n    results = [result_A, result_B, result_C]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_test(f, N_values, use_quadrature, tol):\n    \"\"\"\n    Runs a single test case for a given function, mesh sizes, and tolerance.\n    \"\"\"\n    energies = []\n    for N in N_values:\n        energy = compute_fem_energy(N, f, use_quadrature)\n        energies.append(energy)\n    \n    is_monotonic = True\n    for i in range(1, len(energies)):\n        # Check if J(h_{i}) <= J(h_{i-1}) within the given tolerance\n        if energies[i] - energies[i-1] > tol:\n            is_monotonic = False\n            break\n            \n    return is_monotonic\n\n# 6-point symmetric quadrature rule for triangles, exact for degree 5.\n# Source: FEniCS project, derived from a rule attributed to Strang, Fix, and Zienkiewicz.\n# Points are in barycentric coordinates. Weights sum to 1.0.\nalpha_q = 0.108103018168070\nbeta_q = 0.445948490915965\ngamma_q = 0.816847572980459\ndelta_q = 0.091576213509771\nw1_q = 0.223381589678011\nw2_q = 0.109951743655322\n\nBARY_POINTS = np.array([\n    [beta_q, beta_q, alpha_q], [beta_q, alpha_q, beta_q], [alpha_q, beta_q, beta_q],\n    [delta_q, delta_q, gamma_q], [delta_q, gamma_q, delta_q], [gamma_q, delta_q, delta_q]\n])\nQUAD_WEIGHTS = np.array([w1_q, w1_q, w1_q, w2_q, w2_q, w2_q])\n\ndef compute_fem_energy(N, f, use_quadrature):\n    \"\"\"\n    Computes the discrete energy J(u_h) for a given mesh parameter N and forcing f.\n    \"\"\"\n    h = 1.0 / N\n    num_nodes_total = (N + 1)**2\n    num_nodes_interior = (N - 1)**2\n\n    # Map from global grid coordinates (ix, iy) to a single global index k\n    def global_idx(ix, iy):\n        return iy * (N + 1) + ix\n\n    # Map from global node index to interior node index\n    interior_nodes_map = {}\n    is_interior = np.zeros(num_nodes_total, dtype=bool)\n    interior_counter = 0\n    for iy in range(1, N):\n        for ix in range(1, N):\n            k = global_idx(ix, iy)\n            is_interior[k] = True\n            interior_nodes_map[k] = interior_counter\n            interior_counter += 1\n\n    K = np.zeros((num_nodes_interior, num_nodes_interior), dtype=np.float64)\n    b = np.zeros(num_nodes_interior, dtype=np.float64)\n\n    # Gradients of shape functions on the reference element ((0,0),(1,0),(0,1))\n    # \\phi_1 = 1-xi-eta, \\phi_2 = xi, \\phi_3 = eta\n    grad_phi_ref = np.array([[-1., -1.], [1., 0.], [0., 1.]], dtype=np.float64)\n\n    # Loop over all squares in the grid to define the triangles\n    for j_sq in range(N):\n        for i_sq in range(N):\n            # Global grid indices of the four corners of the square\n            n00_idx, n10_idx = (i_sq, j_sq), (i_sq + 1, j_sq)\n            n01_idx, n11_idx = (i_sq, j_sq + 1), (i_sq + 1, j_sq + 1)\n            \n            # Vertices of the square\n            v00, v10 = np.array([i_sq*h, j_sq*h]), np.array([(i_sq+1)*h, j_sq*h])\n            v01, v11 = np.array([i_sq*h, (j_sq+1)*h]), np.array([(i_sq+1)*h, (j_sq+1)*h])\n            \n            triangles = [\n                ((n00_idx, n10_idx, n11_idx), (v00, v10, v11)),\n                ((n00_idx, n01_idx, n11_idx), (v00, v01, v11)),\n            ]\n\n            for (node_indices, vertices) in triangles:\n                v1, v2, v3 = vertices\n                \n                # Affine map from reference element: x = B * \\hat{x} + v1\n                B = np.array([v2 - v1, v3 - v1]).T\n                B_inv_T = linalg.inv(B).T\n                area = 0.5 * np.abs(linalg.det(B))\n\n                grad_phi_phys = grad_phi_ref @ B_inv_T\n                Ke = (grad_phi_phys @ grad_phi_phys.T) * area\n\n                be = np.zeros(3, dtype=np.float64)\n                if not use_quadrature:\n                    be.fill(area / 3.0)\n                else:\n                    phys_points = BARY_POINTS @ np.array([v1, v2, v3])\n                    # Values of shape functions on reference element are the barycentric coordinates\n                    phi_vals_at_quad_points = BARY_POINTS\n                    f_vals = f(phys_points[:, 0], phys_points[:, 1])\n                    for i in range(3):\n                        integrand = f_vals * phi_vals_at_quad_points[:, i]\n                        be[i] = area * np.sum(QUAD_WEIGHTS * integrand)\n\n                global_node_ids = [global_idx(ix, iy) for (ix, iy) in node_indices]\n                \n                for i in range(3):\n                    gi = global_node_ids[i]\n                    if is_interior[gi]:\n                        mi = interior_nodes_map[gi]\n                        b[mi] += be[i]\n                        for j in range(3):\n                            gj = global_node_ids[j]\n                            if is_interior[gj]:\n                                mj = interior_nodes_map[gj]\n                                K[mi, mj] += Ke[i, j]\n\n    u = linalg.solve(K, b)\n    energy = -0.5 * np.dot(u, b)\n    return energy\n\nsolve()\n```", "id": "2579540"}]}