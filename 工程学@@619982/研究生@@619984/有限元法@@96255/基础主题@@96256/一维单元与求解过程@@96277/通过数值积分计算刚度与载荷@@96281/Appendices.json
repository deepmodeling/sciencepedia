{"hands_on_practices": [{"introduction": "在有限元分析中，精确计算单元刚度矩阵是核心步骤之一。在选择合适的数值积分方案之前，我们必须首先理解被积函数的数学特性。本练习将引导你分析一个基本但至关重要的情形：对于一个仿射映射下的双线性四边形单元，其刚度矩阵的被积函数 $B^T D B$ 在母坐标系下的多项式阶数是多少 [@problem_id:2599447]。通过这个先验分析，你将掌握确定积分精度的基础技能。", "problem": "考虑一个二维等参双线性四边形有限元，其定义在坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 的母体正方形上，并具有标准的双线性形函数 $N_{i}(\\xi,\\eta)$（其中 $i=1,2,3,4$）。假设从母体域到物理域存在一个仿射等参映射，使得 $x(\\xi,\\eta)=a_{0}+a_{1}\\xi+a_{2}\\eta$ 且 $y(\\xi,\\eta)=b_{0}+b_{1}\\xi+b_{2}\\eta$，其中常数 $a_{k}$ 和 $b_{k}$ 使得雅可比矩阵 $J=\\partial(x,y)/\\partial(\\xi,\\eta)$ 为常数矩阵且非奇异。设本构（材料）矩阵 $D$ 为常数（例如，具有常系数的平面应力或平面应变问题）。用 $B$ 表示该单元通常的 $3\\times 8$ 应变-位移矩阵，其元素是 $\\partial N_{i}/\\partial x$ 和 $\\partial N_{i}/\\partial y$ 的线性组合。对于一个一般的、非退化的仿射映射和常数矩阵 $D$，在表示为母体坐标 $(\\xi,\\eta)$ 函数的单元刚度被积表达式 $B^{T} D B$ 中，确定矩阵 $B^{T} D B$ 每个元素关于 $\\xi$ 和 $\\eta$ 的多项式次数。以无单位的单个整数形式提供您的答案。", "solution": "问题陈述经核实具有科学依据、内容自洽且客观。它在有限元方法领域内提出了一个专业但适定的问题。我们开始进行解答。\n\n分析的关键在于确定构成矩阵乘积 $B^{T} D B$ 的各项作为母体坐标 $(\\xi, \\eta)$ 函数时的多项式特性。\n\n$1$. 形函数及其导数：\n对于一个双线性四边形单元，其形函数 $N_{i}(\\xi,\\eta)$（$i=1, 2, 3, 4$）是关于 $\\xi$ 和 $\\eta$ 的双线性多项式。一个通用的形函数具有以下形式：\n$$ N_{i}(\\xi,\\eta) = c_{i0} + c_{i1}\\xi + c_{i2}\\eta + c_{i3}\\xi\\eta $$\n其中 $c_{ij}$ 是常数。例如，$N_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$。\n关于母体坐标的偏导数为：\n$$ \\frac{\\partial N_{i}}{\\partial \\xi} = c_{i1} + c_{i3}\\eta $$\n$$ \\frac{\\partial N_{i}}{\\partial \\eta} = c_{i2} + c_{i3}\\xi $$\n这些导数分别是关于 $\\eta$ 和 $\\xi$ 的线性多项式，即次数为1的多项式。\n\n$2$. 等参映射与雅可比矩阵：\n问题指定了一个仿射等参映射：\n$$ x(\\xi,\\eta) = a_{0}+a_{1}\\xi+a_{2}\\eta $$\n$$ y(\\xi,\\eta) = b_{0}+b_{1}\\xi+b_{2}\\eta $$\n该变换的雅可比矩阵 $J$ 联系了母体坐标系与物理坐标系。其分量由下式给出：\n$$ J = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} a_{1} & b_{1} \\\\ a_{2} & b_{2} \\end{pmatrix} $$\n由于系数 $a_{k}$ 和 $b_{k}$ 是常数，雅可比矩阵 $J$ 是一个常数矩阵。问题陈述其为非奇异矩阵，因此其行列式 $\\det(J) = a_{1}b_{2} - a_{2}b_{1} \\neq 0$。\n\n$3$. 物理坐标系中的导数：\n微分链式法则将物理域 $(x, y)$ 中的导数与母体域 $(\\xi, \\eta)$ 中的导数联系起来：\n$$ \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} = J^{T} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} $$\n为了求得关于物理坐标的导数，我们对此关系求逆：\n$$ \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = (J^{T})^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} $$\n由于 $J$ 是一个常数非奇异矩阵，其逆转置矩阵 $(J^{T})^{-1}$ 也是一个常数非奇异矩阵。令 $(J^{T})^{-1} = \\hat{J}$，这是一个常数矩阵。因此，物理导数是母体坐标导数的常数线性组合：\n$$ \\frac{\\partial N_{i}}{\\partial x} = \\hat{J}_{11} \\frac{\\partial N_{i}}{\\partial \\xi} + \\hat{J}_{12} \\frac{\\partial N_{i}}{\\partial \\eta} $$\n$$ \\frac{\\partial N_{i}}{\\partial y} = \\hat{J}_{21} \\frac{\\partial N_{i}}{\\partial \\xi} + \\hat{J}_{22} \\frac{\\partial N_{i}}{\\partial \\eta} $$\n由于 $\\frac{\\partial N_{i}}{\\partial \\xi}$ 和 $\\frac{\\partial N_{i}}{\\partial \\eta}$ 是关于 $(\\xi, \\eta)$ 的1次多项式，且系数 $\\hat{J}_{kl}$ 是常数，所以导数 $\\frac{\\partial N_{i}}{\\partial x}$ 和 $\\frac{\\partial N_{i}}{\\partial y}$ 也是关于 $(\\xi, \\eta)$ 的1次多项式。对于一般的、非退化的映射，这些导数不会退化为常数。\n\n$4$. 应变-位移矩阵 $B$：\n应变-位移矩阵 $B$ 是一个 $3 \\times 8$ 的矩阵，其结构为 $B = [B_1, B_2, B_3, B_4]$，其中每个分块 $B_i$ 是一个 $3 \\times 2$ 的矩阵，由下式给出：\n$$ B_{i} = \\begin{pmatrix} \\frac{\\partial N_{i}}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_{i}}{\\partial y} \\\\ \\frac{\\partial N_{i}}{\\partial y} & \\frac{\\partial N_{i}}{\\partial x} \\end{pmatrix} $$\n根据以上分析，每个 $B_i$ 分块中的所有非零元素都是关于 $(\\xi, \\eta)$ 的1次多项式。\n\n$5$. 刚度被积表达式 $B^{T} D B$：\n单元刚度矩阵是通过在母体域上对刚度核进行积分来计算的。我们关心的是被积矩阵 $B^{T} D B$ 的多项式次数。\n- $B$ 是一个 $3 \\times 8$ 矩阵，其元素是1次多项式。\n- $B^{T}$ 是一个 $8 \\times 3$ 矩阵，其元素也是1次多项式。\n- $D$ 是一个常数 $3 \\times 3$ 矩阵，其元素是0次多项式。\n\n我们来考察最终得到的 $8 \\times 8$ 矩阵的一个通用元素 $(B^{T} D B)_{jk}$。它通过如下方式计算：\n$$ (B^{T} D B)_{jk} = \\sum_{m=1}^{3} \\sum_{n=1}^{3} (B^{T})_{jm} D_{mn} B_{nk} $$\n此处，$(B^{T})_{jm}$ 是 $B^{T}$ 的第 $j$ 行（即 $B$ 的第 $j$ 列）中的一个元素，而 $B_{nk}$ 是 $B$ 的第 $n$ 行第 $k$ 列中的一个元素。两者都是1次多项式。$D_{mn}$ 是一个常数。\n因此，乘积 $(B^{T})_{jm} D_{mn} B_{nk}$ 是两个1次多项式和一个0次多项式（一个常数）的乘积。结果是一个次数为 $1+0+1=2$ 的多项式。\n最终的元素 $(B^{T} D B)_{jk}$ 是这类2次多项式的和。2次多项式的和是一个次数至多为2的多项式。\n对于一般的、非退化的映射和一个非平凡的材料矩阵 $D$，二次项的系数不会系统性地相消为零。例如，构成被积表达式的一个典型项，如 $d_{11} (\\frac{\\partial N_i}{\\partial x}) (\\frac{\\partial N_j}{\\partial x})$，是两个1次多项式的乘积，因此其次数为2。对于一个一般的问题设置，没有物理或数学上的原因会导致所有二次项在求和过程中完全抵消。\n\n因此，矩阵 $B^{T} D B$ 的每个元素都是关于 $\\xi$ 和 $\\eta$ 的2次多项式函数。", "answer": "$$\\boxed{2}$$", "id": "2599447"}, {"introduction": "理想的单元形状在实际工程问题的网格划分中难以保证，单元畸变是一种常见现象。本练习是一个思想实验，旨在揭示一种严重的失效模式：当单元发生几何“翻转”（即雅可比行列式 $\\det J < 0$）时会发生什么 [@problem_id:2599488]。你将发现，即使单元的一部分已经无效，标准的Gauss积分法也可能完全无法探测到这个问题，从而导致计算结果错误。这个练习突显了理解数值方法局限性以及在实践中检验单元质量的重要性。", "problem": "考虑一个用于有限元法 (FEM) 的三线性等参六面体单元，它定义在父域 $\\hat{\\Omega}=[-1,1]^{3}$ 上，父坐标为 $(\\xi,\\eta,\\zeta)$。假设从父域 $\\hat{\\Omega}$ 到物理单元的几何映射使得雅可比行列式为\n$$\n\\det J(\\xi,\\eta,\\zeta)=1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right).\n$$\n这种情况模拟了一个扭曲的单元，在父空间角点 $(\\xi,\\eta,\\zeta)=(1,1,1)$ 附近有一个翻转的物理角点，映射在该处发生了局部折叠。该单元的刚度矩阵和载荷向量将通过 Gauss–Legendre 张量积求积法进行计算。\n\n仅使用等参映射的核心定义、雅可比行列式在积分变量替换中的意义以及 Gauss–Legendre 求积的基本性质，完成以下任务：\n\n1) 确定在 $\\hat{\\Omega}$ 中 $\\det J(\\xi,\\eta,\\zeta)$ 变号的轨迹，并从几何上确定 $\\det J(\\xi,\\eta,\\zeta)<0$ 的区域。\n\n2) 精确计算 $\\det J(\\xi,\\eta,\\zeta)<0$ 的区域占父域体积 $|\\hat{\\Omega}|$ 的比例。将你的最终答案表示为一个最简分数。\n\n3) 通过计算 $2\\times 2\\times 2$ 规则的张量积 Gauss 点上的 $\\det J$ 值，解释为什么标准求积法在组集刚度积分和载荷积分时可能无法检测到单元翻转。\n\n你最终报告的答案必须仅为任务 2 的结果，形式为一个无量纲的最简分数。不需要四舍五入。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 单元类型: 三线性等参六面体单元。\n- 父域: $\\hat{\\Omega}=[-1,1]^{3}$。\n- 父坐标: $(\\xi,\\eta,\\zeta)$。\n- 雅可比行列式: $\\det J(\\xi,\\eta,\\zeta)=1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right)$。\n- 任务1: 确定 $\\det J(\\xi,\\eta,\\zeta)$ 变号的轨迹，并确定 $\\det J(\\xi,\\eta,\\zeta)<0$ 的区域。\n- 任务2: 计算 $\\det J(\\xi,\\eta,\\zeta)<0$ 区域占父域体积 $|\\hat{\\Omega}|$ 的比例。\n- 任务3: 解释为什么 $2\\times 2\\times 2$ Gauss–Legendre 求积法可能无法检测到翻转。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于有限元法 (FEM) 的基本概念，特别是等参映射、雅可比行列式在积分中的作用、单元翻转 ($\\det J < 0$) 和数值求积。这些都是计算力学和应用数学中的标准课题。\n- **适定性：** 问题陈述清晰，包含了所有必要信息。雅可比行列式的函数已给出，域已指定，各项任务是明确的数学练习，可以导出一个唯一、稳定且有意义的解。\n- **客观性：** 语言形式化且精确，没有主观性或歧义。\n\n**步骤3：结论与行动**\n该问题有效。它是一个有限元法领域内的适定、有科学依据的问题。将提供解答。\n\n该问题研究了在父域 $\\hat{\\Omega} = [-1,1]^{3}$ 内，由给定的雅可比行列式 $\\det J$ 表征的一个扭曲单元的性质。\n\n**1) 变号轨迹与翻转区域**\n\n雅可比行列式 $\\det J(\\xi,\\eta,\\zeta)$ 的符号指示了从父坐标到物理坐标的映射是保持还是反转局部方向。负的行列式意味着一个“翻转”或“折叠”的单元，这在物理上是无意义的，在计算上也是有问题的。\n\n$\\det J$ 变号的轨迹是行列式为零的点集。我们将给定表达式设为零：\n$$\n\\det J(\\xi,\\eta,\\zeta) = 1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right) = 0\n$$\n对坐标和求解，得到：\n$$\n\\xi+\\eta+\\zeta = 2\n$$\n这个方程在 $(\\xi,\\eta,\\zeta)$ 坐标空间中定义了一个平面。这个平面就是映射为奇异的轨迹。\n\n单元翻转的区域是 $\\det J(\\xi,\\eta,\\zeta) < 0$ 的地方。这对应于不等式：\n$$\n1-\\frac{1}{2}\\left(\\xi+\\eta+\\zeta\\right) < 0\n$$\n化简为：\n$$\n\\xi+\\eta+\\zeta > 2\n$$\n在几何上，这个不等式描述了平面 $\\xi+\\eta+\\zeta = 2$ 不包含原点一侧的半空间。我们关心的是位于父域立方体 $\\hat{\\Omega} = [-1,1]^{3}$ 内的这部分半空间。平面 $\\xi+\\eta+\\zeta = 2$ 与交于角点 $(1,1,1)$ 的立方体棱相交。翻转区域（我们记为 $V_{\\text{neg}}$）是从该角点切下的一个小四面体，其边界由立方体边界的平面 $\\xi=1, \\eta=1, \\zeta=1$ 和平面 $\\xi+\\eta+\\zeta=2$ 所界定。\n\n**2) 翻转区域的体积比例**\n\n父域的总体积 $|\\hat{\\Omega}|$ 是一个边长为 $1 - (-1) = 2$ 的立方体的体积。因此：\n$$\n|\\hat{\\Omega}| = 2^{3} = 8\n$$\n为了求出翻转区域的体积 $|V_{\\text{neg}}|$，我们必须计算在第 1 部分中确定的四面体的体积。这个四面体的顶点是立方体的角点 $(1,1,1)$ 以及平面 $\\xi+\\eta+\\zeta=2$ 与连接到该角点的立方体棱的交点。\n- 与棱 $(\\xi,1,1)$ 的交点：$\\xi+1+1=2 \\implies \\xi=0$。点：$(0,1,1)$。\n- 与棱 $(1,\\eta,1)$ 的交点：$1+\\eta+1=2 \\implies \\eta=0$。点：$(1,0,1)$。\n- 与棱 $(1,1,\\zeta)$ 的交点：$1+1+\\zeta=2 \\implies \\zeta=0$。点：$(1,1,0)$。\n所以，该四面体的四个顶点是 $A=(1,1,1)$, $B=(0,1,1)$, $C=(1,0,1)$ 和 $D=(1,1,0)$。\n\n以 $A, B, C, D$ 为顶点的四面体的体积由公式 $|V| = \\frac{1}{6} |\\det(\\vec{AB}, \\vec{AC}, \\vec{AD})|$ 给出。我们计算以顶点 $A$ 为起点的向量：\n$$\n\\vec{AB} = (0-1, 1-1, 1-1) = (-1, 0, 0)\n$$\n$$\n\\vec{AC} = (1-1, 0-1, 1-1) = (0, -1, 0)\n$$\n$$\n\\vec{AD} = (1-1, 1-1, 0-1) = (0, 0, -1)\n$$\n体积为：\n$$\n|V_{\\text{neg}}| = \\frac{1}{6} \\left| \\det \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix} \\right| = \\frac{1}{6} |(-1)(-1)(-1)| = \\frac{1}{6} |-1| = \\frac{1}{6}\n$$\n或者，这个体积也可以通过积分计算：\n$$\n|V_{\\text{neg}}| = \\int_{0}^{1} \\int_{2-\\xi-1}^{1} \\int_{2-\\xi-\\eta}^{1} d\\zeta d\\eta d\\xi = \\int_{0}^{1} \\int_{1-\\xi}^{1} (1 - (2-\\xi-\\eta)) d\\eta d\\xi = \\frac{1}{6}\n$$\n$\\det J(\\xi,\\eta,\\zeta)<0$ 的区域占父域体积的比例为：\n$$\n\\frac{|V_{\\text{neg}}|}{|\\hat{\\Omega}|} = \\frac{1/6}{8} = \\frac{1}{48}\n$$\n\n**3) $2\\times 2\\times 2$ Gauss 求积法的失效**\n\n用于域 $[-1,1]^{3}$ 的标准 $2\\times 2\\times 2$ Gauss-Legendre 求积法则使用 8 个积分点（Gauss 点）。这些点是一维 2 点 Gauss 法则的张量积，其点位于 $\\pm\\frac{1}{\\sqrt{3}}$。因此，这 8 个点的坐标是 $(\\xi_i, \\eta_j, \\zeta_k)$，其中 $\\xi_i, \\eta_j, \\zeta_k \\in \\{-\\frac{1}{\\sqrt{3}}, +\\frac{1}{\\sqrt{3}}\\}$。\n\n像 Gauss 求积这样的数值积分方法，通过被积函数在这些离散点上的值的加权和来近似一个积分。对于单元刚度矩阵和载荷向量的组集，被积函数包含一个因子 $\\det J$。如果 $\\det J$ 在所有 Gauss 点上都为正，即使它在域内其他地方为负，该方法也无法检测到单元翻转。\n\n让我们在这些点上计算 $\\det J$ 的值。这需要计算和 $S = \\xi+\\eta+\\zeta$。当所有坐标都为正时，这个和达到最大值：\n$$\nS_{\\text{max}} = \\frac{1}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} = \\frac{3}{\\sqrt{3}} = \\sqrt{3}\n$$\n当所有坐标都为负时，达到最小值：$S_{\\text{min}} = -\\sqrt{3}$。所有其他符号组合产生的和为 $\\pm \\frac{1}{\\sqrt{3}}$。因此，对于任何 $2\\times 2\\times 2$ Gauss 点，和 $S = \\xi+\\eta+\\zeta$ 的界限为 $|S| \\le \\sqrt{3}$。\n\n单元翻转的条件是 $\\xi+\\eta+\\zeta > 2$。\n然而，在任何 Gauss 点上的最大和是 $\\sqrt{3} \\approx 1.732$。由于 $\\sqrt{3} < 2$，我们有：\n$$\n(\\xi+\\eta+\\zeta)_{\\text{Gauss pt}} \\le \\sqrt{3} < 2\n$$\n这证明了没有一个 $2\\times 2\\times 2$ Gauss 点落在翻转区域 $V_{\\text{neg}}$ 内。在每个 Gauss 点上，和 $\\xi+\\eta+\\zeta$ 都小于 2，这意味着在所有采样点上 $\\det J = 1 - \\frac{1}{2}(\\xi+\\eta+\\zeta)$ 的值都将为正。\n具体来说，在 Gauss 点上 $\\det J$ 的最小值出现在 $S_{\\text{max}}=\\sqrt{3}$ 处：\n$$\n\\det J_{\\text{min at a Gauss pt}} = 1 - \\frac{\\sqrt{3}}{2} \\approx 1 - 0.866 = 0.134 > 0\n$$\n因为该求积方案仅在 $\\det J > 0$ 的区域对被积函数进行采样，所以它完全无法检测到翻转区域的存在。数值计算将会像单元几何在任何地方都有效一样进行，从而导致一个物理上和数学上都不正确的刚度矩阵和载荷向量。", "answer": "$$ \\boxed{\\frac{1}{48}} $$", "id": "2599488"}, {"introduction": "对于具有复杂几何形状或非均匀材料属性的单元，预先确定一个固定的最优积分阶数几乎是不可能的。本练习将理论付诸实践，要求你编写一个自适应积分程序 [@problem_id:2599445]。这个算法能够自动增加积分点的数量，直到计算出的刚度矩阵达到预设的精度要求，为解决现实世界中的复杂问题提供了一种稳健且高效的计算策略。", "problem": "设计并实现一个自适应数值积分程序，用于在有限元法 (FEM) 中评估二维四节点等参双线性四边形单元的单元刚度矩阵。目标是在单个单元内自动提高 Gauss–Legendre 求积阶数，直到单元刚度矩阵的变化量低于预设容差。\n\n从线性弹性力学的基本弱形式出发：给定一个位移场 $u$ 和一个虚位移场 $v$，单元域 $\\Omega_e$ 内的内虚功为\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_e} \\varepsilon(u)^{\\mathsf T} \\, \\mathbf{C}(x,y) \\, \\varepsilon(v) \\, \\mathrm{d}\\Omega,\n$$\n其中 $\\varepsilon(\\cdot)$ 是小应变算子，$\\mathbf{C}(x,y)$ 是空间变化的本构矩阵。一致单元刚度矩阵由以下双线性形式定义\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}(x,y)^{\\mathsf T} \\, \\mathbf{D}(x,y) \\, \\mathbf{B}(x,y) \\, \\mathrm{d}\\Omega,\n$$\n其中 $\\mathbf{B}$ 是线性化应变-位移矩阵，$\\mathbf{D}(x,y)$ 是应力-应变关系 $\\sigma = \\mathbf{D} \\, \\varepsilon$ 中的本构矩阵。考虑平面应力情况，泊松比为 $\\nu$，杨氏模量场为 $E(x,y)$，因此\n$$\n\\mathbf{D}(x,y) = \\frac{E(x,y)}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\tfrac{1-\\nu}{2} \\end{bmatrix}.\n$$\n\n使用与单元节点坐标 $\\{(x_i,y_i)\\}_{i=1}^4$ 相关的双线性形函数 $\\{N_i(\\xi,\\eta)\\}_{i=1}^4$，将单元从具有局部坐标 $(\\xi,\\eta)$ 的母单元正方形 $\\hat{\\Omega} = [-1,1]\\times[-1,1]$ 映射到物理域 $(x,y)$。使用标准双线性形函数\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta) &= \\tfrac{1}{4}(1-\\xi)(1-\\eta), \\\\\nN_2(\\xi,\\eta) &= \\tfrac{1}{4}(1+\\xi)(1-\\eta), \\\\\nN_3(\\xi,\\eta) &= \\tfrac{1}{4}(1+\\xi)(1+\\eta), \\\\\nN_4(\\xi,\\eta) &= \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n\\end{aligned}\n$$\n由此构造雅可比矩阵 $\\mathbf{J}(\\xi,\\eta)$、其行列式 $\\det\\mathbf{J}(\\xi,\\eta)$ 以及形函数关于 $(x,y)$ 的导数，以形成 $\\mathbf{B}(\\xi,\\eta)$。$\\mathbf{K}_e$ 的积分将通过在每个母坐标方向上使用 $p$ 阶的张量积 Gauss–Legendre 求积法来计算：\n$$\n\\mathbf{K}_e^{(p)} = \\sum_{i=1}^{p}\\sum_{j=1}^{p} \\mathbf{B}(\\xi_i,\\eta_j)^{\\mathsf T}\\,\\mathbf{D}(x(\\xi_i,\\eta_j),y(\\xi_i,\\eta_j))\\,\\mathbf{B}(\\xi_i,\\eta_j)\\,\\det\\mathbf{J}(\\xi_i,\\eta_j)\\,w_i\\,w_j,\n$$\n其中 $\\{(\\xi_i,w_i)\\}_{i=1}^p$ 和 $\\{(\\eta_j,w_j)\\}_{j=1}^p$ 分别是 $[-1,1]$ 上的 Gauss–Legendre 节点和权重。\n\n设计一个自适应细化策略，其中求积阶数从 $p=p_0$ 开始，每步增加 1。在每个细化步骤中，使用 Frobenius 范数比较连续的近似值。如果满足以下条件，则接受阶数 $p^\\star$：\n$$\n\\frac{\\lVert \\mathbf{K}_e^{(p^\\star)} - \\mathbf{K}_e^{(p^\\star-1)} \\rVert_F}{\\max\\big(\\lVert \\mathbf{K}_e^{(p^\\star)} \\rVert_F, \\varepsilon_{\\text{safe}}\\big)} \\le \\varepsilon_{\\text{tol}},\n$$\n其中使用一个小的安全下限 $\\varepsilon_{\\text{safe}}$ 以避免除以零。如果当 $p=p_{\\max}$ 时仍未满足容差，则接受 $p^\\star=p_{\\max}$。\n\n针对具有空间变化模量的平面应力问题实现此方法\n$$\nE(x,y) = E_0\\left[1 + \\alpha \\sin(\\pi x)\\cos(\\pi y)\\right],\n$$\n其中 $E_0>0$ 是基础杨氏模量，$\\alpha \\in \\mathbb{R}$ 控制非均匀性。当 $\\alpha=0$ 时，材料是均匀的。\n\n测试套件。使用以下四个测试用例，每个用例由逆时针顺序的节点坐标 $\\big((x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)\\big)$、泊松比 $\\nu$、基础模量 $E_0$、非均匀性参数 $\\alpha$、容差 $\\varepsilon_{\\text{tol}}$、初始阶数 $p_0$ 和最大阶数 $p_{\\max}$ 定义：\n- 用例 A (仿射矩形，均匀材料): 节点 $((0,0),(2,0),(2,1),(0,1))$, $\\nu=0.3$, $E_0=1.0$, $\\alpha=0.0$, $\\varepsilon_{\\text{tol}}=10^{-12}$, $p_0=1$, $p_{\\max}=12$.\n- 用例 B (扭曲四边形，均匀材料): 节点 $((0,0),(1.2,0.1),(1.0,0.9),(-0.1,1.1))$, $\\nu=0.25$, $E_0=1.0$, $\\alpha=0.0$, $\\varepsilon_{\\text{tol}}=10^{-8}$, $p_0=1$, $p_{\\max}=12$.\n- 用例 C (仿射正方形，非均匀材料): 节点 $((0,0),(1,0),(1,1),(0,1))$, $\\nu=0.3$, $E_0=1.0$, $\\alpha=0.5$, $\\varepsilon_{\\text{tol}}=10^{-6}$, $p_0=1$, $p_{\\max}=12$.\n- 用例 D (扭曲四边形，非均匀材料，严格容差): 节点 $((0.0,0.0),(1.1,-0.1),(1.0,1.0),(-0.2,1.1))$, $\\nu=0.28$, $E_0=1.0$, $\\alpha=0.8$, $\\varepsilon_{\\text{tol}}=10^{-10}$, $p_0=1$, $p_{\\max}=12$.\n\n$E(x,y)$ 中三角函数的角度单位是弧度。\n\n您的程序必须：\n- 对于每个用例，运行自适应程序并返回最小的可接受求积阶数 $p^\\star$ 和 Frobenius 范数 $\\lVert \\mathbf{K}_e^{(p^\\star)} \\rVert_F$。\n- 报告的 Frobenius 范数需四舍五入到 8 位小数。\n- 生成单行输出，其中包含所有用例的结果，格式为逗号分隔的列表的列表，不含空格，精确格式如下\n$[\\![p^\\star_A,\\lVert \\mathbf{K}_e^{(p^\\star_A)} \\rVert_F],[p^\\star_B,\\lVert \\mathbf{K}_e^{(p^\\star_B)} \\rVert_F],[p^\\star_C,\\lVert \\mathbf{K}_e^{(p^\\star_C)} \\rVert_F],[p^\\star_D,\\lVert \\mathbf{K}_e^{(p^\\star_D)} \\rVert_F]]$，\n例如 $[[3,0.12345678],[5,0.23456789],[4,0.34567890],[6,0.45678901]]$。\n\n您的最终答案必须是一个完整、可运行的程序，该程序实现上述要求并以指定格式精确打印一行。无需用户输入。答案必须是无量纲的；请勿在输出中包含任何物理单位。", "solution": "所提出的问题是设计并实现一个自适应数值积分程序，用于在平面应力条件下计算四节点等参四边形单元的单元刚度矩阵。材料属性，特别是杨氏模量，被允许在空间上变化。这个问题在科学上是合理的且是适定的。我们将进行系统的推导，然后进行实现。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 通过在单元域 $\\Omega_e$ 上的积分定义：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}(x,y)^{\\mathsf T} \\, \\mathbf{D}(x,y) \\, \\mathbf{B}(x,y) \\, \\mathrm{d}\\Omega\n$$\n其中 $\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{D}$ 是本构矩阵。\n\n**1. 等参映射**\n\n等参格式的核心是使用相同的形函数来插值单元的几何形状及其位移场。单元内任意点的物理坐标 $(x, y)$ 是从带有局部坐标 $(\\xi, \\eta)$ 的母单元正方形 $\\hat{\\Omega} = [-1,1]\\times[-1,1]$ 映射而来的。\n\n该映射由下式给出：\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) x_i\n$$\n$$\ny(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) y_i\n$$\n其中 $(x_i, y_i)$ 是四个单元节点的坐标，$N_i(\\xi,\\eta)$ 是所提供的双线性形函数：\n$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$,\n$N_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta)$,\n$N_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta)$,\n$N_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta)$.\n\n**2. 变换的雅可比矩阵**\n\n为了评估空间导数和变换积分，我们需要映射的雅可比矩阵 $\\mathbf{J}$：\n$$\n\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n雅可比矩阵的各项是通过对映射方程求导来计算的：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i, \\quad \\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} y_i, \\quad \\text{etc.}\n$$\n面积微元变换为 $\\mathrm{d}\\Omega = \\mathrm{d}x \\mathrm{d}y = \\det(\\mathbf{J}) \\mathrm{d}\\xi \\mathrm{d}\\eta$。一个有效的映射要求在整个单元内 $\\det(\\mathbf{J}) > 0$。\n\n**3. 应变-位移矩阵（$\\mathbf{B}$ 矩阵）**\n\n单元内的位移场由节点位移 $\\mathbf{u}_e = \\{u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}, u_{4x}, u_{4y}\\}^\\mathsf{T}$ 插值得到。平面应力的应变向量为 $\\varepsilon = \\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}^\\mathsf{T}$，其中 $\\varepsilon_{xx} = \\partial u/\\partial x$, $\\varepsilon_{yy} = \\partial v/\\partial y$, 以及 $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$。\n\n应变通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移相关联，即 $\\varepsilon = \\mathbf{B} \\mathbf{u}_e$。$\\mathbf{B}$ 矩阵是一个 $3 \\times 8$ 的矩阵，由形函数关于物理坐标 $(x,y)$ 的导数构成：\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4], \\quad \\text{其中} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n使用链式法则求得这些导数：\n$$\n\\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix}\n$$\n注意，$\\mathbf{J}$ 以及因此的 $\\mathbf{B}$ 通常是 $(\\xi,\\eta)$ 的函数。\n\n**4. 本构矩阵（$\\mathbf{D}$ 矩阵）**\n\n对于平面应力条件下的各向同性材料，本构矩阵将应力 $\\sigma$ 与应变 $\\varepsilon$ 联系起来（$\\sigma = \\mathbf{D} \\varepsilon$）。它由下式给出：\n$$\n\\mathbf{D}(x,y) = \\frac{E(x,y)}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\tfrac{1-\\nu}{2} \\end{bmatrix}\n$$\n在这个问题中，杨氏模量 $E$ 是物理坐标 $(x,y)$ 的函数：\n$$\nE(x,y) = E_0\\left[1 + \\alpha \\sin(\\pi x)\\cos(\\pi y)\\right]\n$$\n在母域中积分时，这变为 $E(x(\\xi,\\eta), y(\\xi,\\eta))$。\n\n**5. 数值积分与自适应方案**\n\n刚度矩阵的积分被变换到母域：\n$$\n\\mathbf{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\xi,\\eta)^{\\mathsf T} \\mathbf{D}(x(\\xi,\\eta), y(\\xi,\\eta)) \\mathbf{B}(\\xi,\\eta) \\det(\\mathbf{J}(\\xi,\\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\n该积分使用 $p \\times p$ 的张量积 Gauss-Legendre 求积法则进行近似计算：\n$$\n\\mathbf{K}_e^{(p)} = \\sum_{i=1}^{p}\\sum_{j=1}^{p} w_i w_j \\left[ \\mathbf{B}(\\xi_i,\\eta_j)^{\\mathsf T} \\mathbf{D}(\\xi_i,\\eta_j) \\mathbf{B}(\\xi_i,\\eta_j) \\det(\\mathbf{J}(\\xi_i,\\eta_j)) \\right]\n$$\n其中 $(\\xi_i, w_i)$ 和 $(\\eta_j, w_j)$ 是 $[-1,1]$ 上的 Gauss-Legendre 求积点和权重。\n\n自适应过程如下：\n1. 从初始求积阶数 $p = p_0$ 开始。计算该阶数的刚度矩阵，$\\mathbf{K}_{\\text{prev}} = \\mathbf{K}_e^{(p_0)}$。\n2. 通过递增阶数进行迭代，$p = p_0+1, p_0+2, \\dots, p_{\\max}$。\n3. 在每次迭代中，计算当前的刚度矩阵，$\\mathbf{K}_{\\text{curr}} = \\mathbf{K}_e^{(p)}$。\n4. 使用 Frobenius 范数计算相对变化：\n$$\n\\text{error} = \\frac{\\lVert \\mathbf{K}_{\\text{curr}} - \\mathbf{K}_{\\text{prev}} \\rVert_F}{\\max\\big(\\lVert \\mathbf{K}_{\\text{curr}} \\rVert_F, \\varepsilon_{\\text{safe}}\\big)}\n$$\n5. 如果 $\\text{error} \\le \\varepsilon_{\\text{tol}}$，则认为求积阶数 $p$ 足够。设置最终接受的阶数为 $p^\\star = p$ 并终止过程。\n6. 如果条件未满足，更新 $\\mathbf{K}_{\\text{prev}} = \\mathbf{K}_{\\text{curr}}$ 并进入下一个阶数 $p+1$。\n7. 如果循环达到 $p_{\\max}$ 仍未收敛，则预先将接受的阶数设为 $p^\\star = p_{\\max}$。\n\n该过程确保求积阶数自动增加，直到刚度矩阵的积分计算达到期望的精度，从而适应由单元几何形状和材料非均匀性共同决定的被积函数的复杂性。实现部分将在每个 Gauss 点系统地构造必要的矩阵，并执行上述的自适应循环。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main solver function to run the adaptive quadrature for all test cases.\n    \"\"\"\n    # Safety floor for the relative error denominator to prevent division by zero.\n    EPS_SAFE = 1e-16\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A: affine rectangle, homogeneous\n        {'nodes': np.array([[0,0],[2,0],[2,1],[0,1]]), 'nu': 0.3, 'E0': 1.0, 'alpha': 0.0, 'tol': 1e-12, 'p0': 1, 'p_max': 12},\n        # Case B: distorted quadrilateral, homogeneous\n        {'nodes': np.array([[0,0],[1.2,0.1],[1.0,0.9],[-0.1,1.1]]), 'nu': 0.25, 'E0': 1.0, 'alpha': 0.0, 'tol': 1e-8, 'p0': 1, 'p_max': 12},\n        # Case C: affine square, heterogeneous\n        {'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 'nu': 0.3, 'E0': 1.0, 'alpha': 0.5, 'tol': 1e-6, 'p0': 1, 'p_max': 12},\n        # Case D: distorted quadrilateral, heterogeneous\n        {'nodes': np.array([[0.0,0.0],[1.1,-0.1],[1.0,1.0],(-0.2,1.1]]), 'nu': 0.28, 'E0': 1.0, 'alpha': 0.8, 'tol': 1e-10, 'p0': 1, 'p_max': 12},\n    ]\n\n    # Cache for Gauss points and weights to avoid re-computation.\n    gauss_cache = {}\n\n    def get_gauss_points(p):\n        \"\"\"\n        Retrieves Gauss-Legendre quadrature points and weights for order p.\n        \"\"\"\n        if p not in gauss_cache:\n            points, weights = roots_legendre(p)\n            gauss_cache[p] = (points, weights)\n        return gauss_cache[p]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        \"\"\"\n        Computes shape functions N and their derivatives w.r.t. (xi, eta) at a point.\n        \"\"\"\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        \n        # dN/dxi and dN/deta for each of the 4 shape functions\n        dN_dxi = 0.25 * np.array([\n            -(1 - eta),\n             (1 - eta),\n             (1 + eta),\n            -(1 + eta)\n        ])\n        dN_deta = 0.25 * np.array([\n            -(1 - xi),\n            -(1 + xi),\n             (1 + xi),\n             (1 - xi)\n        ])\n\n        return N, dN_dxi, dN_deta\n\n    def compute_stiffness_matrix(p, nodes, nu, E0, alpha):\n        \"\"\"\n        Computes the element stiffness matrix for a given quadrature order p.\n        \"\"\"\n        k_e = np.zeros((8, 8))\n        xi_pts, w_xi = get_gauss_points(p)\n        eta_pts, w_eta = get_gauss_points(p)\n\n        # Constitutive matrix D (constant part)\n        D_const = E0 / (1 - nu**2) * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n\n        for i in range(p):\n            for j in range(p):\n                xi, eta = xi_pts[i], eta_pts[j]\n                \n                N, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n\n                # Jacobian matrix J\n                # J = [dx/dxi, dy/dxi; dx/deta, dy/deta]\n                J = np.zeros((2, 2))\n                J[0, 0] = np.dot(dN_dxi, nodes[:, 0])\n                J[0, 1] = np.dot(dN_dxi, nodes[:, 1])\n                J[1, 0] = np.dot(dN_deta, nodes[:, 0])\n                J[1, 1] = np.dot(dN_deta, nodes[:, 1])\n\n                detJ = np.linalg.det(J)\n                if detJ <= 0:\n                    raise ValueError(\"Jacobian determinant is non-positive.\")\n                invJ = np.linalg.inv(J)\n\n                # Derivatives of N w.r.t (x, y)\n                dN_dx_dy = np.vstack((dN_dxi, dN_deta))\n                dN_dxy = invJ @ dN_dx_dy\n                dN_dx = dN_dxy[0, :]\n                dN_dy = dN_dxy[1, :]\n\n                # Strain-displacement matrix B\n                B = np.zeros((3, 8))\n                for k in range(4):\n                    B[0, 2 * k] = dN_dx[k]\n                    B[1, 2 * k + 1] = dN_dy[k]\n                    B[2, 2 * k] = dN_dy[k]\n                    B[2, 2 * k + 1] = dN_dx[k]\n                \n                # Material properties at Gauss point\n                x_gp = np.dot(N, nodes[:, 0])\n                y_gp = np.dot(N, nodes[:, 1])\n                E_factor = 1.0 + alpha * np.sin(np.pi * x_gp) * np.cos(np.pi * y_gp)\n                D = D_const * E_factor\n\n                # Add contribution to stiffness matrix\n                integrand = B.T @ D @ B\n                k_e += integrand * detJ * w_xi[i] * w_eta[j]\n        \n        return k_e\n\n    results = []\n    for case in test_cases:\n        p0 = case['p0']\n        p_max = case['p_max']\n        tol = case['tol']\n        \n        p = p0\n        k_prev = compute_stiffness_matrix(p, case['nodes'], case['nu'], case['E0'], case['alpha'])\n        \n        p_star = p  # Initialize in case loop doesn't run\n        k_final = k_prev\n        \n        if p0 == p_max: # Special case if only one order is allowed\n            p_star = p_max\n            k_final = k_prev\n        else:\n            for p in range(p0 + 1, p_max + 1):\n                k_curr = compute_stiffness_matrix(p, case['nodes'], case['nu'], case['E0'], case['alpha'])\n                \n                norm_diff = np.linalg.norm(k_curr - k_prev, ord='fro')\n                norm_curr = np.linalg.norm(k_curr, ord='fro')\n                \n                error = norm_diff / max(norm_curr, EPS_SAFE)\n                \n                if error <= tol:\n                    p_star = p\n                    k_final = k_curr\n                    break # Convergence achieved\n                \n                k_prev = k_curr\n                p_star = p # Update p_star in case we hit p_max\n                k_final = k_curr\n        \n        final_norm = np.linalg.norm(k_final, ord='fro')\n        results.append(f\"[{p_star},{final_norm:.8f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2599445"}]}