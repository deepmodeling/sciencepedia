{"hands_on_practices": [{"introduction": "在有限元分析中，选择的形函数决定了单元的近似能力。这个练习将帮助我们验证一维二次分层单元的基本插值特性。我们将首先证明，该单元能够精确地再现任何线性位移场（即常应变状态），这是任何有效单元必须满足的“完备性”要求。然后，我们将通过计算三次函数 $u(x) = x^3$ 的插值误差，来量化其对更高阶多项式的逼近效果，从而深入理解其近似精度和收敛性 [@problem_id:2538578]。", "problem": "考虑一个长度为 $L$ 的一维杆有限元，占据区间 $x \\in [0,L]$。设参考坐标为 $\\xi \\in [-1,1]$，其仿射映射为 $x(\\xi) = \\frac{L}{2}(1+\\xi)$。一个分层二次近似空间由以下三个形函数定义\n$$\nN_{1}(\\xi) = \\frac{1-\\xi}{2}, \n\\quad\nN_{2}(\\xi) = \\frac{1+\\xi}{2}, \n\\quad\nN_{3}(\\xi) = 1 - \\xi^{2},\n$$\n其中 $N_{1}$ 和 $N_{2}$ 张成线性子空间，$N_{3}$ 是一个在单元端点处为零的二次气泡函数。该插值算子作用于一个足够光滑的标量场 $u(x)$ 如下：\n$$\nI_{h}u(x) \\;=\\; u(0)\\,N_{1}(\\xi(x)) \\;+\\; u(L)\\,N_{2}(\\xi(x)) \\;+\\; \\Big(u\\!\\left(\\tfrac{L}{2}\\right) - \\tfrac{u(0)+u(L)}{2}\\Big)\\,N_{3}(\\xi(x)),\n$$\n使得近似解在 $x=0$、$x=L/2$ 和 $x=L$ 处与 $u$ 相匹配。\n\n任务：\n1) 仅使用形函数的性质和插值算子 $I_{h}$ 的定义，证明任何仿射函数 $u(x) = a + b x$（其中 $a$ 和 $b$ 为常数）都能被此分层二次集合精确再生，即在 $[0,L]$ 上有 $I_{h}u(x) \\equiv u(x)$。\n\n2) 对于三次函数 $u(x) = x^{3}$，在 $[0,L]$ 上推导其逐点插值误差 $e(x) \\;=\\; u(x) - I_{h}u(x)$，然后通过计算其 $L^{2}$ 范数的平方 $\\|e\\|_{L^{2}(0,L)}^{2} \\;=\\; \\int_{0}^{L} \\big(e(x)\\big)^{2}\\,dx$ 来量化该误差，结果表示为仅含 $L$ 的闭式解析表达式。\n\n请给出 $\\|e\\|_{L^{2}(0,L)}^{2}$ 关于 $L$ 的精确解析表达式作为最终答案。无需进行四舍五入。", "solution": "该问题是适定的，具有科学依据，并包含了获得唯一解所需的所有信息。这是有限元方法中关于插值理论和误差分析的一个标准练习。因此，将提供一个解答。\n\n该问题分为两部分。第一部分是证明给定的分层二次插值算子能够精确再生任何仿射函数。第二部分是计算三次函数 $u(x) = x^3$ 的插值误差的 $L^2$ 范数的平方。\n\n第 1 部分：对仿射函数的精确性。\n设仿射函数为 $u(x) = a + bx$，其中 $a, b \\in \\mathbb{R}$ 为常数。我们必须证明其插值函数 $I_h u(x)$ 对于所有 $x \\in [0,L]$ 都与 $u(x)$ 完全相同。\n\n插值算子的定义如下：\n$$\nI_{h}u(x) = u(0)N_{1}(\\xi(x)) + u(L)N_{2}(\\xi(x)) + \\left(u\\left(\\frac{L}{2}\\right) - \\frac{u(0)+u(L)}{2}\\right)N_{3}(\\xi(x))\n$$\n首先，我们计算函数 $u(x)$ 在插值点 $x=0$，$x=L/2$ 和 $x=L$ 处的值：\n$$u(0) = a + b(0) = a$$\n$$u(L) = a + bL$$\n$$u\\left(\\frac{L}{2}\\right) = a + b\\frac{L}{2}$$\n\n接下来，我们计算分层气泡函数 $N_3(\\xi)$ 的系数。该系数由 $c_3 = u(\\frac{L}{2}) - \\frac{u(0)+u(L)}{2}$ 给出。\n代入上述值：\n$$\nc_3 = \\left(a + \\frac{bL}{2}\\right) - \\frac{a + (a+bL)}{2} = \\left(a + \\frac{bL}{2}\\right) - \\frac{2a+bL}{2} = \\left(a + \\frac{bL}{2}\\right) - \\left(a + \\frac{bL}{2}\\right) = 0\n$$\n由于对于任何仿射函数，$N_3(\\xi)$ 的系数都为零，因此插值算子简化为：\n$$\nI_h u(x) = u(0) N_1(\\xi(x)) + u(L) N_2(\\xi(x))\n$$\n代入 $u(0)$、$u(L)$、$N_1(\\xi)$ 和 $N_2(\\xi)$ 的表达式：\n$$\nI_h u(x) = a \\left(\\frac{1-\\xi}{2}\\right) + (a+bL) \\left(\\frac{1+\\xi}{2}\\right)\n$$\n我们展开并简化此表达式：\n$$\nI_h u(x) = \\frac{a - a\\xi + a + a\\xi + bL + bL\\xi}{2} = \\frac{2a + bL + bL\\xi}{2} = a + \\frac{bL}{2}(1+\\xi)\n$$\n现在，我们使用给定的仿射映射 $x(\\xi) = \\frac{L}{2}(1+\\xi)$。将其代入我们关于 $I_h u(x)$ 的表达式中：\n$$\nI_h u(x) = a + b \\left(\\frac{L}{2}(1+\\xi)\\right) = a + bx\n$$\n由于 $u(x) = a + bx$，我们已经证明了对于任何仿射函数都有 $I_h u(x) = u(x)$。该插值格式对至多 1 次的多项式是精确的。\n\n第 2 部分：对三次函数的误差分析。\n设函数为 $u(x) = x^3$。我们需要求出插值误差 $e(x) = u(x) - I_h u(x)$，并计算其 $L^2$ 范数的平方 $\\|e\\|_{L^2(0,L)}^2$。\n\n首先，我们计算 $u(x)=x^3$ 在插值点上的值：\n$$u(0) = 0^3 = 0$$\n$$u(L) = L^3$$\n$$u\\left(\\frac{L}{2}\\right) = \\left(\\frac{L}{2}\\right)^3 = \\frac{L^3}{8}$$\n\n接下来，我们计算插值算子 $I_h u(x)$ 的系数：\n$N_1(\\xi)$ 的系数是 $u(0) = 0$。\n$N_2(\\xi)$ 的系数是 $u(L) = L^3$。\n$N_3(\\xi)$ 的系数是 $c_3 = u(\\frac{L}{2}) - \\frac{u(0)+u(L)}{2}$：\n$$\nc_3 = \\frac{L^3}{8} - \\frac{0 + L^3}{2} = \\frac{L^3}{8} - \\frac{4L^3}{8} = -\\frac{3L^3}{8}\n$$\n因此，插值函数为：\n$$\nI_h u(x) = (0)N_1(\\xi) + (L^3)N_2(\\xi) + \\left(-\\frac{3L^3}{8}\\right)N_3(\\xi) = L^3\\left(\\frac{1+\\xi}{2}\\right) - \\frac{3L^3}{8}\\left(1-\\xi^2\\right)\n$$\n为了求出误差，最方便的方法是用参考坐标 $\\xi$ 来表示 $u(x)$。使用映射 $x(\\xi) = \\frac{L}{2}(1+\\xi)$：\n$$\nu(x) = x^3 = \\left( \\frac{L}{2}(1+\\xi) \\right)^3 = \\frac{L^3}{8}(1+\\xi)^3\n$$\n误差函数 $e(x)$ 可以写成关于 $\\xi$ 的函数：\n$$\ne(\\xi) = u(\\xi) - I_h u(\\xi) = \\frac{L^3}{8}(1+\\xi)^3 - \\left[ L^3\\left(\\frac{1+\\xi}{2}\\right) - \\frac{3L^3}{8}\\left(1-\\xi^2\\right) \\right]\n$$\n提出公因子 $\\frac{L^3}{8}$：\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1+\\xi)^3 - 4(1+\\xi) + 3(1-\\xi^2) \\right]\n$$\n展开括号内的各项：\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1+3\\xi+3\\xi^2+\\xi^3) - (4+4\\xi) + (3-3\\xi^2) \\right]\n$$\n合并 $\\xi$ 的同次幂项：\n$$\ne(\\xi) = \\frac{L^3}{8} \\left[ (1-4+3) + (3-4)\\xi + (3-3)\\xi^2 + \\xi^3 \\right] = \\frac{L^3}{8} (\\xi^3 - \\xi)\n$$\n现在我们计算 $L^2$ 范数的平方，$\\|e\\|_{L^2(0,L)}^2 = \\int_0^L (e(x))^2 dx$。我们将积分变换到参考域 $\\xi \\in [-1,1]$。微分元变换为 $dx = \\frac{dx}{d\\xi}d\\xi = \\frac{L}{2}d\\xi$。\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\int_{-1}^{1} (e(\\xi))^2 \\frac{L}{2} d\\xi = \\int_{-1}^{1} \\left( \\frac{L^3}{8}(\\xi^3-\\xi) \\right)^2 \\frac{L}{2} d\\xi\n$$\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\left(\\frac{L^3}{8}\\right)^2 \\frac{L}{2} \\int_{-1}^{1} (\\xi^3-\\xi)^2 d\\xi = \\frac{L^6}{64} \\frac{L}{2} \\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = \\frac{L^7}{128} \\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi\n$$\n被积函数是偶函数，所以积分值是从 $0$ 到 $1$ 积分的两倍：\n$$\n\\int_{-1}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = 2 \\int_{0}^{1} (\\xi^6 - 2\\xi^4 + \\xi^2) d\\xi = 2 \\left[ \\frac{\\xi^7}{7} - \\frac{2\\xi^5}{5} + \\frac{\\xi^3}{3} \\right]_0^1\n$$\n$$\n= 2 \\left( \\frac{1}{7} - \\frac{2}{5} + \\frac{1}{3} \\right) = 2 \\left( \\frac{15 - 42 + 35}{105} \\right) = 2 \\left( \\frac{8}{105} \\right) = \\frac{16}{105}\n$$\n最后，我们将此结果代回范数的表达式中：\n$$\n\\|e\\|_{L^2(0,L)}^2 = \\frac{L^7}{128} \\cdot \\frac{16}{105} = \\frac{L^7}{8 \\cdot 105} = \\frac{L^7}{840}\n$$\n插值误差的 $L^2$ 范数的平方为 $\\frac{L^7}{840}$。", "answer": "$$\n\\boxed{\\frac{L^{7}}{840}}\n$$", "id": "2538578"}, {"introduction": "构单元刚度矩阵是有限元方法的核心计算步骤，它涉及对形函数导数乘积的积分。由于这些被积函数通常是多项式，我们可以利用高斯-勒让德（Gauss-Legendre）数值积分来实现精确计算。这个实践旨在确定在给定常数材料属性和线性几何映射的条件下，精确积分二次分层单元所有刚度矩阵项所需的最小高斯点数 $n$。通过分析被积函数的最高多项式次数，我们可以应用 $p = 2n-1$ 法则，这对于编写高效且准确的有限元代码至关重要 [@problem_id:2538587]。", "problem": "考虑一个定义在参考区间 $\\left[-1,1\\right]$ 上的一维杆有限元，其具有二次分层形函数。设分层基选择为两个线性端点函数和一个内部增益（气泡）函数，\n$$\nN_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2},\\quad \\xi\\in\\left[-1,1\\right].\n$$\n假设杨氏模量 $E$ 和横截面积 $A$ 为常数，并且从参考坐标 $\\xi$ 到物理坐标 $x$ 的几何映射为线性等参映射，因此雅可比 $J=\\frac{dx}{d\\xi}$ 在整个单元上为常数。单元刚度矩阵的各项定义为\n$$\nk_{ij}=\\int_{\\Omega_{e}} B_{i}(x)\\,E\\,A\\,B_{j}(x)\\,dx,\\quad B_{i}(x)=\\frac{dN_{i}}{dx},\\quad i,j\\in\\{1,2,3\\}.\n$$\n仅以此定义为出发点，且不预先假设任何特定的数值积分公式，确定在 $\\left[-1,1\\right]$ 上所需的高斯-勒让德积分点最少整数数量 $n$，以便在所述假设下，该单元的所有刚度项 $k_{ij}$ 都能被精确积分。请以单个整数形式给出最终答案，不带单位。", "solution": "所述问题具有科学依据、提法恰当、客观且自洽。这是有限元法中的一个标准问题。验证成功。\n\n目标是确定为精确积分所有刚度矩阵项 $k_{ij}$ 所需的高斯-勒让德积分点的最少整数数量，记为 $n$。一个在参考区间 $\\left[-1,1\\right]$ 上具有 $n$ 个点的高斯-勒让德积分方案可以精确积分次数 $p$ 最高为 $p = 2n-1$ 的任意多项式。因此，问题简化为求解用于计算刚度项的被积函数的最高多项式次数。\n\n刚度矩阵项 $k_{ij}$ 由在物理单元域 $\\Omega_{e}$ 上的积分定义：\n$$\nk_{ij}=\\int_{\\Omega_{e}} B_{i}(x)\\,E\\,A\\,B_{j}(x)\\,dx\n$$\n此处，$E$ 是杨氏模量，$A$ 是横截面积，两者均假设为常数。应变-位移矩阵分量 $B_{i}(x)$ 是形函数 $N_{i}$ 对物理坐标 $x$ 的导数：\n$$\nB_{i}(x) = \\frac{dN_{i}}{dx}\n$$\n为了计算该积分，我们必须将其从物理坐标 $x$ 变换到参考坐标 $\\xi \\in \\left[-1,1\\right]$。问题陈述中使用了线性等参映射，这意味着变换的雅可比 $J = \\frac{dx}{d\\xi}$ 是常数。微分长度元变换为 $dx = J\\,d\\xi$。\n\n使用链式法则，对 $x$ 的导数与对 $\\xi$ 的导数关系如下：\n$$\n\\frac{dN_{i}}{dx} = \\frac{dN_{i}}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J}\\frac{dN_{i}}{d\\xi}\n$$\n将这些表达式代入 $k_{ij}$ 的积分中：\n$$\nk_{ij} = \\int_{-1}^{1} \\left(\\frac{1}{J}\\frac{dN_{i}}{d\\xi}\\right) E A \\left(\\frac{1}{J}\\frac{dN_{j}}{d\\xi}\\right) (J\\,d\\xi)\n$$\n由于 $E$，$A$ 和 $J$ 都是常数，我们可以简化此表达式：\n$$\nk_{ij} = \\frac{EA}{J} \\int_{-1}^{1} \\left(\\frac{dN_{i}}{d\\xi}\\right) \\left(\\frac{dN_{j}}{d\\xi}\\right) d\\xi\n$$\n常数前置因子 $\\frac{EA}{J}$ 不影响被积函数的多项式次数。被积函数为 $I_{ij}(\\xi) = \\left(\\frac{dN_{i}}{d\\xi}\\right) \\left(\\frac{dN_{j}}{d\\xi}\\right)$。我们必须找出对于所有 $i,j \\in \\{1, 2, 3\\}$，$I_{ij}(\\xi)$ 的最高多项式次数。\n\n首先，我们计算给定的分层形函数对 $\\xi$ 的导数：\n$$\nN_{1}(\\xi)=\\frac{1-\\xi}{2} \\implies \\frac{dN_{1}}{d\\xi} = -\\frac{1}{2}\n$$\n$$\nN_{2}(\\xi)=\\frac{1+\\xi}{2} \\implies \\frac{dN_{2}}{d\\xi} = \\frac{1}{2}\n$$\n$$\nN_{3}(\\xi)=1-\\xi^{2} \\implies \\frac{dN_{3}}{d\\xi} = -2\\xi\n$$\n这些导数分别是 $0$ 次、$0$ 次和 $1$ 次的多项式。令 $P[f(\\xi)]$ 表示函数 $f(\\xi)$ 的多项式次数。\n\n现在，我们确定所有唯一的 $(i,j)$ 对的被积函数 $I_{ij}(\\xi)$ 的次数：\n- 对于 $(i,j) = (1,1)$: $I_{11}(\\xi) = (-\\frac{1}{2})(-\\frac{1}{2}) = \\frac{1}{4}$。次数为 $P[I_{11}] = 0$。\n- 对于 $(i,j) = (1,2)$: $I_{12}(\\xi) = (-\\frac{1}{2})(\\frac{1}{2}) = -\\frac{1}{4}$。次数为 $P[I_{12}] = 0$。\n- 对于 $(i,j) = (1,3)$: $I_{13}(\\xi) = (-\\frac{1}{2})(-2\\xi) = \\xi$。次数为 $P[I_{13}] = 1$。\n- 对于 $(i,j) = (2,2)$: $I_{22}(\\xi) = (\\frac{1}{2})(\\frac{1}{2}) = \\frac{1}{4}$。次数为 $P[I_{22}] = 0$。\n- 对于 $(i,j) = (2,3)$: $I_{23}(\\xi) = (\\frac{1}{2})(-2\\xi) = -\\xi$。次数为 $P[I_{23}] = 1$。\n- 对于 $(i,j) = (3,3)$: $I_{33}(\\xi) = (-2\\xi)(-2\\xi) = 4\\xi^{2}$。次数为 $P[I_{33}] = 2$。\n\n在所有被积函数 $I_{ij}(\\xi)$ 中找到的最高多项式次数 $p_{\\text{max}}$ 为 $2$，这出现在 $k_{33}$ 项中。\n\n为了精确积分一个次数为 $p_{\\text{max}}$ 的多项式，高斯-勒让德积分点数 $n$ 必须满足条件：\n$$\n2n - 1 \\ge p_{\\text{max}}\n$$\n代入 $p_{\\text{max}} = 2$：\n$$\n2n - 1 \\ge 2\n$$\n解出 $n$：\n$$\n2n \\ge 3\n$$\n$$\nn \\ge 1.5\n$$\n由于积分点数 $n$ 必须是整数，满足此不等式的最小整数值为 $n=2$。因此，需要 $2$ 个高斯-勒让德积分点来精确积分刚度矩阵的所有项。", "answer": "$$\\boxed{2}$$", "id": "2538587"}, {"introduction": "分层基函数的一个主要优势在于它们天然支持静态凝聚（static condensation）技术，从而显著提高计算效率。在这个综合性的编程实践中，你将实现一个完整的一维杆单元求解器，并对比包含内部“气泡”自由度的完整系统与经过静态凝聚的简化系统。通过在单元层面精确地消去内部自由度，该练习将验证静态凝聚能够在不损失整体节点位移解精度的情况下，大幅减小全局方程组的规模，从而在实践中确认这一强大技术的理论正确性 [@problem_id:2538553]。", "problem": "实现一个一维有限元求解器，用于求解轴向加载杆问题。在每个网格区间上使用一个二次分层单元。每个单元有两个端点节点自由度和一个内部层次气泡自由度，其形函数在单元两端为零。从虚功原理、父域上的形函数定义以及小应变线性弹性理论出发，构建单元刚度矩阵和一致单元载荷向量。然后通过两种方式组装全局系统：(i) 包含所有端点节点和内部气泡未知量的完整系统，以及 (ii) 通过精确的 Schur 补消除法在单元级别上消除内部气泡未知量的静力缩聚系统。在相同的边界条件和载荷下求解这两个全局系统，并在一组测试案例中验证端点节点位移和端点节点力残差在指定容差范围内匹配。\n\n基本原理：\n- 虚功原理指出，对于处于轴向变形的弹性杆，当内虚功对于所有虚位移都等于外虚功时，即可获得离散平衡。这产生线性系统 $$\\mathbf{K}\\,\\mathbf{u}=\\mathbf{F},$$ 其中 $$\\mathbf{K}$$ 是由单元贡献组装而成的全局刚度矩阵，$$\\mathbf{u}$$ 是全局位移向量，$$\\mathbf{F}$$ 是由体力与面力组装而成的全局载荷向量。\n- 在通过雅可比行列式 $$J=L/2$$ 仿射映射到长度为 $$L$$ 的物理单元上的父坐标 $$\\xi\\in[-1,1]$$ 中，使用以下分层形函数：\n  $$N_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2},$$\n  其中 $$N_{3}(\\pm 1)=0$$，因此相关自由度位于单元内部。轴向应变为 $$\\varepsilon=\\mathrm{d}u/\\mathrm{d}x,$$ 其中 $$u(x)=\\sum_{a=1}^{3}N_{a}(\\xi(x))\\,d_{a}。$$\n- 单元刚度和一致载荷由下式得出：\n  $$\\mathbf{K}^{e}=\\int_{-1}^{1}\\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\!T} E A \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) J\\,\\mathrm{d}\\xi,\\qquad \\mathbf{f}^{e}=\\int_{-1}^{1}\\mathbf{N}^{T} b\\, J\\,\\mathrm{d}\\xi,$$\n  其中 $$E$$ 是杨氏模量，$$A$$ 是横截面积，$$b$$ 是单位长度的体力密度。端点面力在全局组装时作为边界节点上的节点力计入。\n- 静力缩聚通过应用对应于主要（端点节点）和内部（气泡）未知量的单元级分区的 Schur 补，精确地消除了每个单元的内部气泡自由度，从而为全局节点系统生成一个缩聚的单元贡献，且不损失节点解的精度。\n\n您的程序必须：\n- 使用上述分层形函数和对 $$\\xi\\in[-1,1]$$ 上的多项式进行精确数值积分的方法，推导并实现单元矩阵。\n- 对每个测试案例，组装并求解完整全局系统（包括内部气泡未知量）和缩聚全局系统（单元内气泡已消除）。\n- 通过直接在指定节点上指定位移值来施加本质边界条件。\n- 对两种公式，计算全局系统上的节点力残差 $$\\mathbf{r}=\\mathbf{K}\\mathbf{u}-\\mathbf{F}$$。对于约束节点，这些残差等于反力；对于自由节点，在平衡状态下它们应在数值上为零。\n- 对每个测试案例，验证在相对容差 $$10^{-9}$$ 和绝对容差 $$10^{-12}$$ 内，完整系统和缩聚系统在域两端的端点节点位移和端点节点残差是相同的。\n\n物理和数值单位：\n- 所有输入均采用国际单位制 (SI)：长度单位为米 ($$m$$)，杨氏模量单位为帕斯卡 ($$Pa$$)，面积单位为平方米 ($$m^{2}$$)，体力密度单位为牛顿/米 ($$N/m$$)，节点载荷单位为牛顿 ($$N$$)，位移单位为米 ($$m$$)。\n- 最终输出仅包含布尔值，因此输出不需要单位。\n\n测试套件：\n对于每个案例，杆被划分为 $$n_{e}$$ 个单元，具有给定的单元长度、材料属性和分布体力。节点载荷作用于全局节点，本质边界条件指定节点位移。使用以下数据。\n\n- 案例 $$1$$ (标准路径，混合加载，右端自由):\n  - 单元数量 $$n_{e}=3。$$\n  - 单元长度 $$\\{0.4,\\,0.3,\\,0.3\\}~m。$$\n  - 每个单元的杨氏模量 $$\\{2.10\\times 10^{11},\\,2.10\\times 10^{11},\\,2.10\\times 10^{11}\\}~Pa。$$\n  - 面积 $$\\{5.0\\times 10^{-4},\\,5.0\\times 10^{-4},\\,5.0\\times 10^{-4}\\}~m^{2}。$$\n  - 体力 $$\\{1.0\\times 10^{3},\\,1.0\\times 10^{3},\\,1.0\\times 10^{3}\\}~N/m。$$\n  - 作用于 $$4$$ 个全局节点上的节点点载荷：$$\\{0,\\,0,\\,0,\\,1.0\\times 10^{5}\\}~N。$$\n  - 本质边界条件：左端位移 $$u(0)=0~m。$$\n\n- 案例 $$2$$ (边界情况，两端固定，负体力):\n  - 单元数量 $$n_{e}=1。$$\n  - 单元长度 $$\\{2.0\\}~m。$$\n  - 杨氏模量 $$\\{7.0\\times 10^{10}\\}~Pa。$$\n  - 面积 $$\\{1.0\\times 10^{-3}\\}~m^{2}。$$\n  - 体力 $$\\{-5.0\\times 10^{2}\\}~N/m。$$\n  - 作用于 $$2$$ 个全局节点上的节点点载荷：$$\\{0,\\,0\\}~N。$$\n  - 本质边界条件：$$u(0)=0~m$$ 和 $$u(2.0)=0~m。$$\n\n- 案例 $$3$$ (非均匀材料与截面，指定右端位移，内部节点载荷):\n  - 单元数量 $$n_{e}=4。$$\n  - 单元长度 $$\\{0.25,\\,0.25,\\,0.25,\\,0.25\\}~m。$$\n  - 杨氏模量 $$\\{2.0\\times 10^{11},\\,1.5\\times 10^{11},\\,1.0\\times 10^{11},\\,1.2\\times 10^{11}\\}~Pa。$$\n  - 面积 $$\\{8.0\\times 10^{-4},\\,1.2\\times 10^{-3},\\,1.0\\times 10^{-3},\\,9.0\\times 10^{-4}\\}~m^{2}。$$\n  - 体力 $$\\{0,\\,5.0\\times 10^{3},\\,-3.0\\times 10^{3},\\,2.0\\times 10^{3}\\}~N/m。$$\n  - 作用于 $$5$$ 个全局节点上的节点点载荷：$$\\{0,\\,0,\\,2.0\\times 10^{3},\\,0,\\,0\\}~N。$$\n  - 本质边界条件：$$u(0)=0~m$$ 和 $$u(1.0)=1.0\\times 10^{-4}~m。$$\n\n- 案例 $$4$$ (强非均匀性，混合边界，非零牵引力符号):\n  - 单元数量 $$n_{e}=2。$$\n  - 单元长度 $$\\{0.5,\\,1.5\\}~m。$$\n  - 杨氏模量 $$\\{1.0\\times 10^{11},\\,5.0\\times 10^{10}\\}~Pa。$$\n  - 面积 $$\\{7.0\\times 10^{-4},\\,7.0\\times 10^{-4}\\}~m^{2}。$$\n  - 体力 $$\\{1.0\\times 10^{2},\\,0\\}~N/m。$$\n  - 作用于 $$3$$ 个全局节点上的节点点载荷：$$\\{0,\\,0,\\,-1.0\\times 10^{4}\\}~N。$$\n  - 本质边界条件：$$u(0)=0~m。$$\n\n算法要求：\n- 在 $$\\xi\\in[-1,1]$$ 上使用至少三点的高斯-勒让德积分来精确计算给定多项式场的单元积分。\n- 为完整系统和缩聚系统组装全局矩阵。\n- 通过将系统划分为自由和固定集合并求解简化的线性系统来施加本质边界条件。\n- 为两种公式计算全局节点残差向量 $$\\mathbf{r}=\\mathbf{K}\\mathbf{u}-\\mathbf{F}$$。\n- 对于每个案例，在左右两端节点上比较两种公式的：\n  - 位移，以及\n  - 节点残差（在位移被指定处，其等于反力）。\n- 如果左右两端节点位移和节点残差都在指定的相对容差 $$10^{-9}$$ 和绝对容差 $$10^{-12}$$ 内匹配，则该测试案例通过。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试案例的布尔结果，格式为逗号分隔的列表，并用方括号括起来（例如，$$[true,false,true,true]$$，但使用 Python 的布尔值大写形式）。顺序必须是案例 $$1$$、案例 $$2$$、案例 $$3$$、案例 $$4$$。", "solution": "所提出的问题是有限元方法中一个适定且科学上合理的应用练习，它基于线性弹性和计算力学的既定原理。问题是完整的、一致的，并且所有提供的数据在物理上都是现实的。该问题已经过验证，可以构建解决方案。\n\n目标是实现一个一维有限元求解器，用于求解使用特定二次分层单元的轴向加载杆。我们必须以两种方式构建和求解全局系统：一个包含所有自由度（DOF）的完整系统，以及一个在单元级别消除内部自由度的静力缩聚系统。这两种方法的一致性将得到验证。\n\n首先，我们推导单元刚度矩阵 $\\mathbf{K}^e$ 和单元一致载荷向量 $\\mathbf{f}^e$。分析在父单元域 $\\xi \\in [-1, 1]$ 上进行，该域被映射到长度为 $L$ 的物理单元。此映射的雅可比行列式为 $J = L/2$。\n\n分层形函数如下：\n$$N_{1}(\\xi)=\\frac{1-\\xi}{2},\\quad N_{2}(\\xi)=\\frac{1+\\xi}{2},\\quad N_{3}(\\xi)=1-\\xi^{2}$$\n其中 $N_1$ 和 $N_2$ 与单元的起始和结束节点相关联，而 $N_3$ 是“气泡”函数，与一个在单元端点处无值（$N_3(\\pm 1) = 0$）的内部自由度相关联。\n\n单元内的轴向位移场 $u$ 通过 $u(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}^e$ 进行插值，其中 $\\mathbf{N} = [N_1, N_2, N_3]$，$\\mathbf{d}^e = [d_1, d_2, d_3]^T$ 是单元节点位移。\n\n轴向应变 $\\varepsilon = du/dx$ 通过链式法则与父坐标导数相关联：\n$$\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J}\\frac{d}{d\\xi}$$\n形函数对 $\\xi$ 的导数为：\n$$\\frac{dN_1}{d\\xi} = -\\frac{1}{2}, \\quad \\frac{dN_2}{d\\xi} = \\frac{1}{2}, \\quad \\frac{dN_3}{d\\xi} = -2\\xi$$\n因此，应变-位移矩阵 $\\mathbf{B}$ 为：\n$$\\mathbf{B}(\\xi) = \\frac{d\\mathbf{N}}{dx} = \\frac{1}{J} \\frac{d\\mathbf{N}}{d\\xi} = \\frac{1}{J} \\begin{bmatrix} -1/2 & 1/2 & -2\\xi \\end{bmatrix}$$\n\n单元刚度矩阵 $\\mathbf{K}^e$ 由以下公式给出：\n$$\\mathbf{K}^{e}=\\int_{0}^{L} \\mathbf{B}^T E A \\mathbf{B} \\,dx = \\int_{-1}^{1} \\mathbf{B}(\\xi)^T E A \\mathbf{B}(\\xi) J \\,d\\xi$$\n假设杨氏模量 $E$ 和面积 $A$ 在单元内是常数：\n$$\\mathbf{K}^e = EAJ \\int_{-1}^{1} \\left(\\frac{1}{J^2}\\right) \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right)^T \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right) \\,d\\xi = \\frac{EA}{J} \\int_{-1}^{1} \\begin{bmatrix} -1/2 \\\\ 1/2 \\\\ -2\\xi \\end{bmatrix} \\begin{bmatrix} -1/2 & 1/2 & -2\\xi \\end{bmatrix} \\,d\\xi$$\n$$\\mathbf{K}^e = \\frac{EA}{J} \\int_{-1}^{1} \\begin{bmatrix} 1/4 & -1/4 & \\xi \\\\ -1/4 & 1/4 & -\\xi \\\\ \\xi & -\\xi & 4\\xi^2 \\end{bmatrix} \\,d\\xi$$\n多项式项的积分为 $\\int_{-1}^1 1 \\,d\\xi = 2$，$\\int_{-1}^1 \\xi \\,d\\xi = 0$ 和 $\\int_{-1}^1 \\xi^2 \\,d\\xi = 2/3$。利用这些结果：\n$$\\mathbf{K}^e = \\frac{EA}{J} \\begin{bmatrix} 1/2 & -1/2 & 0 \\\\ -1/2 & 1/2 & 0 \\\\ 0 & 0 & 8/3 \\end{bmatrix} = \\frac{2EA}{L} \\begin{bmatrix} 1/2 & -1/2 & 0 \\\\ -1/2 & 1/2 & 0 \\\\ 0 & 0 & 8/3 \\end{bmatrix} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & 0 & 16/3 \\end{bmatrix}$$\n一个关键的观察是刚度矩阵是块对角矩阵。线性节点自由度（$d_1, d_2$）与内部层次自由度（$d_3$）解耦。这是因为交叉项导数乘积的积分，例如 $\\frac{dN_1}{d\\xi}\\frac{dN_3}{d\\xi} = \\xi$，在对称域 $[-1, 1]$ 上的积分为零。\n\n由恒定体力 $b$ 产生的一致单元载荷向量 $\\mathbf{f}^e$ 是：\n$$\\mathbf{f}^{e} = \\int_{0}^{L} \\mathbf{N}^T b \\,dx = \\int_{-1}^{1} \\mathbf{N}(\\xi)^T b J \\,d\\xi$$\n$$\\mathbf{f}^e = bJ \\int_{-1}^{1} \\begin{bmatrix} (1-\\xi)/2 \\\\ (1+\\xi)/2 \\\\ 1-\\xi^2 \\end{bmatrix} d\\xi = b \\frac{L}{2} \\begin{bmatrix} 1 \\\\ 1 \\\\ 4/3 \\end{bmatrix}$$\n这些积分将使用三点高斯-勒让德积分进行数值计算，该方法对于最高次数为 5 的多项式是精确的，足以满足我们最高次数为 2 的被积函数。\n\n对于**完整系统**，我们将 $3 \\times 3$ 的单元矩阵组装成一个全局系统。总自由度数将为 $n_{nodes} + n_{elements}$。前 $n_{nodes}$ 个自由度对应于物理节点，随后的 $n_{elements}$ 个自由度对应于每个单元的内部气泡模式。\n\n对于**静力缩聚系统**，我们在单元级别消除内部自由度 $d_3$。一个单元系统被划分为主要（p）和内部（i）自由度：\n$$ \\begin{bmatrix} \\mathbf{K}_{pp} & \\mathbf{K}_{pi} \\\\ \\mathbf{K}_{ip} & K_{ii} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{d}_p \\\\ d_i \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{f}_p \\\\ f_i \\end{Bmatrix} $$\n主要自由度 $\\mathbf{d}_p$ 的缩聚（Schur 补）系统为 $\\mathbf{K}_{cond}^e \\mathbf{d}_p = \\mathbf{f}_{cond}^e$，其中：\n$$\\mathbf{K}_{cond}^e = \\mathbf{K}_{pp} - \\mathbf{K}_{pi} K_{ii}^{-1} \\mathbf{K}_{ip}$$\n$$\\mathbf{f}_{cond}^e = \\mathbf{f}_p - \\mathbf{K}_{pi} K_{ii}^{-1} f_i$$\n由于我们的 $\\mathbf{K}^e$ 是解耦的，我们有 $\\mathbf{K}_{pi} = \\mathbf{0}$ 和 $\\mathbf{K}_{ip} = \\mathbf{0}^T$。方程简化为：\n$$\\mathbf{K}_{cond}^e = \\mathbf{K}_{pp} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$$\n$$\\mathbf{f}_{cond}^e = \\mathbf{f}_p = \\frac{bL}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$$\n这揭示了缩聚系统等效于使用线性杆单元的标准有限元分析。当单元内的材料属性为常数时，气泡函数不改变节点位移解。\n\n实现将按以下步骤进行：\n1.  为每个测试案例定义参数。\n2.  循环遍历每个单元，使用数值积分计算其刚度矩阵和载荷向量。\n3.  组装完整全局系统矩阵 $(\\mathbf{K}_{full}, \\mathbf{F}_{full})$。该系统的大小为 $(n_{nodes} + n_{elements}) \\times (n_{nodes} + n_{elements})$。\n4.  通过对每个单元首先进行静力缩聚来组装缩聚全局系统矩阵 $(\\mathbf{K}_{cond}, \\mathbf{F}_{cond})$。该系统的大小为 $n_{nodes} \\times n_{nodes}$。\n5.  将节点点载荷添加到各自的全局力向量中。\n6.  通过将每个系统划分为自由和固定自由度，并为自由自由度求解简化系统，来施加本质边界条件（指定位移）。\n7.  重建完整的位移向量 $(\\mathbf{u}_{full}, \\mathbf{u}_{cond})$。\n8.  使用公式 $\\mathbf{r} = \\mathbf{K}\\mathbf{u} - \\mathbf{F}$ 计算全局节点残差向量 $(\\mathbf{r}_{full}, \\mathbf{r}_{cond})$。\n9.  最后，使用指定的容差（$rtol=10^{-9}, atol=10^{-12}$）比较两个解的端点节点位移和端点节点残差。如果一个测试案例的所有比较都通过，则该案例的布尔结果为真。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the 1D hierarchical FEA solver.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            \"n_e\": 3,\n            \"lengths\": [0.4, 0.3, 0.3],\n            \"E\": [2.10e11, 2.10e11, 2.10e11],\n            \"A\": [5.0e-4, 5.0e-4, 5.0e-4],\n            \"b\": [1.0e3, 1.0e3, 1.0e3],\n            \"nodal_loads\": [0.0, 0.0, 0.0, 1.0e5],\n            \"bcs\": {0: 0.0}\n        },\n        { # Case 2\n            \"n_e\": 1,\n            \"lengths\": [2.0],\n            \"E\": [7.0e10],\n            \"A\": [1.0e-3],\n            \"b\": [-5.0e2],\n            \"nodal_loads\": [0.0, 0.0],\n            \"bcs\": {0: 0.0, 1: 0.0} \n        },\n        { # Case 3\n            \"n_e\": 4,\n            \"lengths\": [0.25, 0.25, 0.25, 0.25],\n            \"E\": [2.0e11, 1.5e11, 1.0e11, 1.2e11],\n            \"A\": [8.0e-4, 1.2e-3, 1.0e-3, 9.0e-4],\n            \"b\": [0.0, 5.0e3, -3.0e3, 2.0e3],\n            \"nodal_loads\": [0.0, 0.0, 2.0e3, 0.0, 0.0],\n            \"bcs\": {0: 0.0, 4: 1.0e-4}\n        },\n        { # Case 4\n            \"n_e\": 2,\n            \"lengths\": [0.5, 1.5],\n            \"E\": [1.0e11, 5.0e10],\n            \"A\": [7.0e-4, 7.0e-4],\n            \"b\": [1.0e2, 0.0],\n            \"nodal_loads\": [0.0, 0.0, -1.0e4],\n            \"bcs\": {0: 0.0}\n        },\n    ]\n\n    results = []\n    for case_data in test_cases:\n        results.append(run_case(case_data))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_element_matrices(L, E, A, b):\n    \"\"\"\n    Computes element stiffness matrix and load vector using 3-point Gauss quadrature.\n    \"\"\"\n    Ke = np.zeros((3, 3))\n    fe = np.zeros(3)\n    J = L / 2.0\n\n    # 3-point Gauss-Legendre quadrature\n    gauss_points = [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)]\n    gauss_weights = [5.0 / 9.0, 8.0 / 9.0, 5.0 / 9.0]\n\n    for xi, w in zip(gauss_points, gauss_weights):\n        # Shape functions N(xi)\n        N = np.array([(1.0 - xi) / 2.0, (1.0 + xi) / 2.0, 1.0 - xi**2])\n        # Derivatives of shape functions w.r.t. xi\n        dN_dxi = np.array([-0.5, 0.5, -2.0 * xi])\n        # B matrix (derivatives of N w.r.t. x)\n        B = dN_dxi / J\n\n        Ke += np.outer(B, B) * E * A * J * w\n        fe += N * b * J * w\n        \n    return Ke, fe\n\ndef solve_system(K, F, bcs, n_dof):\n    \"\"\"\n    Applies boundary conditions and solves the linear system.\n    \"\"\"\n    dof_fixed = np.array(list(bcs.keys()), dtype=int)\n    dof_all = np.arange(n_dof)\n    dof_free = np.setdiff1d(dof_all, dof_fixed)\n\n    u = np.zeros(n_dof)\n    for dof, val in bcs.items():\n        u[dof] = val\n\n    if len(dof_free) > 0:\n        K_ff = K[np.ix_(dof_free, dof_free)]\n        K_fd = K[np.ix_(dof_free, dof_fixed)]\n        F_f = F[dof_free]\n        u_d = u[dof_fixed]\n\n        F_eff = F_f - K_fd @ u_d\n        u[dof_free] = np.linalg.solve(K_ff, F_eff)\n    \n    return u\n\ndef run_case(case):\n    \"\"\"\n    Runs a single test case for both full and condensed systems and compares results.\n    \"\"\"\n    n_e = case[\"n_e\"]\n    n_nodes = n_e + 1\n    \n    # --- Full System ---\n    n_dof_full = n_nodes + n_e\n    K_full = np.zeros((n_dof_full, n_dof_full))\n    F_full = np.zeros(n_dof_full)\n\n    # --- Condensed System ---\n    n_dof_cond = n_nodes\n    K_cond = np.zeros((n_dof_cond, n_dof_cond))\n    F_cond = np.zeros(n_dof_cond)\n\n    for i in range(n_e):\n        L, E, A, b = case[\"lengths\"][i], case[\"E\"][i], case[\"A\"][i], case[\"b\"][i]\n        Ke, fe = get_element_matrices(L, E, A, b)\n        \n        # Assembly for full system\n        node_indices = [i, i + 1]\n        bubble_index = n_nodes + i\n        full_dof_map = np.array([node_indices[0], node_indices[1], bubble_index])\n        K_full[np.ix_(full_dof_map, full_dof_map)] += Ke\n        F_full[full_dof_map] += fe\n\n        # Static condensation and assembly for condensed system\n        K_pp = Ke[:2, :2]\n        K_pi = Ke[:2, 2:3]\n        K_ip = Ke[2:3, :2]\n        K_ii = Ke[2, 2]\n        f_p = fe[:2]\n        f_i = fe[2]\n        \n        K_cond_e = K_pp - (K_pi @ K_ip) / K_ii\n        f_cond_e = f_p - (K_pi.flatten() * f_i) / K_ii\n\n        cond_dof_map = np.array(node_indices)\n        K_cond[np.ix_(cond_dof_map, cond_dof_map)] += K_cond_e\n        F_cond[cond_dof_map] += f_cond_e\n\n    # Add nodal loads\n    F_full[:n_nodes] += case[\"nodal_loads\"]\n    F_cond += case[\"nodal_loads\"]\n\n    # Solve systems\n    bcs_full = case[\"bcs\"]\n    u_full = solve_system(K_full, F_full, bcs_full, n_dof_full)\n    \n    # Remap BCs for condensed system, as they only affect nodes\n    bcs_cond = {k: v for k, v in bcs_full.items() if k < n_nodes}\n    u_cond = solve_system(K_cond, F_cond, bcs_cond, n_dof_cond)\n\n    # Calculate residuals\n    r_full = K_full @ u_full - F_full\n    r_cond = K_cond @ u_cond - F_cond\n\n    # Extract nodal values from full system for comparison\n    u_full_nodes = u_full[:n_nodes]\n    r_full_nodes = r_full[:n_nodes]\n\n    # Comparison\n    rtol, atol = 1e-9, 1e-12\n    \n    disp_left_ok = np.isclose(u_full_nodes[0], u_cond[0], rtol=rtol, atol=atol)\n    disp_right_ok = np.isclose(u_full_nodes[-1], u_cond[-1], rtol=rtol, atol=atol)\n    \n    res_left_ok = np.isclose(r_full_nodes[0], r_cond[0], rtol=rtol, atol=atol)\n    res_right_ok = np.isclose(r_full_nodes[-1], r_cond[-1], rtol=rtol, atol=atol)\n    \n    return all([disp_left_ok, disp_right_ok, res_left_ok, res_right_ok])\n\nsolve()\n```", "id": "2538553"}]}