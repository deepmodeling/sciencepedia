{"hands_on_practices": [{"introduction": "非贴体有限元方法的核心挑战在于如何处理被界面切割的背景网格单元。本练习将引导你从零开始，实现处理切割单元所需的关键几何操作和数据结构。你将学习如何通过水平集函数 $\\phi(x,y)$ 裁剪一个单元，为裁剪后的任意多边形生成一个用于积分的子网格，并在此基础上组装局部质量矩阵 $M_{ij} = \\int_{T^{-}} N_{i}(x,y)N_{j}(x,y)\\mathrm{d}A$ [@problem_id:2609382]。掌握这些基本功是构建完整非贴体有限元求解器的第一步。", "problem": "考虑一个在二维背景单纯剖分网格上标量扩散问题的非贴体有限元离散化。设背景单元为固定的父三角形 $T$，其顶点为 $x_{0} = (0,0)$、$x_{1} = (1,0)$ 和 $x_{2} = (0,1)$。定义水平集函数 $\\phi(x,y) = a\\,x + b\\,y + c$ 和物理子域 $T^{-} = \\{(x,y) \\in T \\mid \\phi(x,y) \\le 0\\}$。此设定模拟了一个切割单元。在 $T$ 上，使用标准的分片线性节点基（仿射形函数）$\\{N_{i}\\}_{i=1}^{3}$。这些基函数与顶点 $x_0, x_1, x_2$ 相关联，并满足克罗内克-德尔塔性质 $N_{i}(x_{j-1}) = \\delta_{ij}$，其中 $i,j \\in \\{1,2,3\\}$。\n\n您的任务是，从第一性原理出发，实现以下对非贴体有限元方法至关重要的基本组件：\n\n$1.$ 裁剪：通过用 $\\phi(x,y) \\le 0$ 定义的半平面裁剪三角形 $T$ 来计算交多边形 $P = T \\cap \\{(x,y)\\mid \\phi(x,y) \\le 0\\}$。将满足 $\\phi(x,y) \\le \\varepsilon$ 的点解释为内部点，其中 $\\varepsilon = 10^{-12}$ 是一个数值容差。如果结果集的面积为零（例如，由于半平面与 $T$ 相交于单一点或线段而导致的退化情况），则将 $P$ 视为空集，其面积 $A = 0$，形心 $(c_{x}, c_{y}) = (0,0)$。\n\n$2.$ 积分网格：首先计算 $P$ 的形心，然后通过将该形心与多边形的每条边连接形成扇形三角剖分，从而构建 $P$ 的一个三角剖分，得到一个积分网格 $\\mathcal{T}_{\\mathrm{int}}(P)$。该网格由不重叠的三角形组成，其并集为 $P$。如果 $P$ 的顶点数少于 $3$ 个或面积小于 $\\varepsilon$，则将 $\\mathcal{T}_{\\mathrm{int}}(P)$ 设为空集，其三角形数量 $n_{\\triangle} = 0$。\n\n$3.$ 切割单元上的局部质量矩阵：在 $T^{-}$ 上定义局部一致质量矩阵 $M \\in \\mathbb{R}^{3\\times 3}$ 为\n$$\nM_{ij} = \\int_{T^{-}} N_{i}(x,y)\\,N_{j}(x,y)\\,\\mathrm{d}A,\\quad i,j \\in \\{1,2,3\\}。\n$$\n通过在 $\\mathcal{T}_{\\mathrm{int}}(P)$ 上使用对每个三角形上最高总次数为 $2$ 的多项式精确的求积法则进行精确多项式积分来组装 $M$。使用基函数 $N_{i}$ 相对父三角形 $T$ 的仿射定义，在物理坐标中逐点计算它们的值。如果 $P$ 为空，则将 $M$ 设为零矩阵。报告其弗罗贝尼乌斯范数 $\\lVert M \\rVert_{F} = \\sqrt{\\sum_{i=1}^{3}\\sum_{j=1}^{3} M_{ij}^{2}}$。\n\n$4.$ 几何属性：计算 $P$ 的面积 $A$ 和形心 $(c_{x}, c_{y})$。对非自交多边形使用标准的多边形面积和形心公式；如果 $P$ 为空，则使用 $(A,c_{x},c_{y}) = (0,0,0)$。\n\n设计并实现鲁棒的数据结构，将 $P$ 存储为其顶点的有序列表，将 $\\mathcal{T}_{\\mathrm{int}}(P)$ 存储为三角形列表，其中每个三角形由其在物理空间中的三个顶点坐标表示。您的算法必须能正确处理未切割、完全切除以及退化的边界对齐情况。\n\n测试套件。对于下面给出的每个参数三元组 $(a,b,c)$，使用上述指定的固定父三角形 $T$，计算：\n- $P$ 的面积 $A$，\n- $P$ 的形心坐标 $(c_{x}, c_{y})$，\n- 积分网格 $\\mathcal{T}_{\\mathrm{int}}(P)$ 中的三角形数量 $n_{\\triangle}$，以及\n- $T^{-}$ 上局部质量矩阵的弗罗贝尼乌斯范数 $\\lVert M \\rVert_{F}$。\n\n使用以下 $5$ 个测试用例：\n- 用例 1：$(a,b,c) = (0,0,-1)$，完全在内部的情况。\n- 用例 2：$(a,b,c) = (0,0,1)$，完全在外部的情况。\n- 用例 3：$(a,b,c) = (1,0.3,-0.2)$，典型的切割情况。\n- 用例 4：$(a,b,c) = (1,1,0)$，与顶点相切的退化情况。\n- 用例 5：$(a,b,c) = (1,0,0)$，与边对齐的退化情况。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，不含空格。对于每个用例，输出一个列表 $[A,c_{x},c_{y},n_{\\triangle},\\lVert M\\rVert_{F}]$。因此，最终输出必须具有以下形式：\n$[[A_{1},c_{x,1},c_{y,1},n_{\\triangle,1},\\lVert M\\rVert_{F,1}],[A_{2},c_{x,2},c_{y,2},n_{\\triangle,2},\\lVert M\\rVert_{F,2}],\\dots,[A_{5},c_{x,5},c_{y,5},n_{\\triangle,5},\\lVert M\\rVert_{F,5}]]$。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n\n-   **域**：一个固定的父三角形 $T$，其顶点为 $x_{0} = (0,0)$，$x_{1} = (1,0)$ 和 $x_{2} = (0,1)$。\n-   **水平集函数**：$\\phi(x,y) = a\\,x + b\\,y + c$。\n-   **物理子域**：$T^{-} = \\{(x,y) \\in T \\mid \\phi(x,y) \\le 0\\}$。\n-   **数值容差**：$\\varepsilon = 10^{-12}$。将满足 $\\phi(x,y) \\le \\varepsilon$ 的点视为在物理子域内部。\n-   **基函数**：在 $T$ 上定义的分片线性节点基函数 $\\{N_{i}\\}_{i=1}^{3}$，与顶点 $x_0, x_1, x_2$ 相关联，并满足克罗内克-德尔塔性质 $N_{i}(x_{j-1}) = \\delta_{ij}$，其中 $i,j \\in \\{1,2,3\\}$。\n-   **任务 1 (裁剪)**：计算交多边形 $P = T^{-}$。对于面积为零的退化情况，$P$ 视为空集。\n-   **任务 2 (积分网格)**：使用从其形心出发的扇形三角剖分，将 $P$ 剖分为 $\\mathcal{T}_{\\mathrm{int}}(P)$。如果 $P$ 的顶点数少于 $3$ 个或面积小于 $\\varepsilon$，则 $\\mathcal{T}_{\\mathrm{int}}(P)$ 为空集，其三角形数量 $n_{\\triangle} = 0$。\n-   **任务 3 (质量矩阵)**：使用对最高次数为 $2$ 的多项式精确的求积法则计算局部质量矩阵 $M_{ij} = \\int_{T^{-}} N_{i}(x,y)\\,N_{j}(x,y)\\,\\mathrm{d}A$。报告其弗罗贝尼乌斯范数 $\\lVert M \\rVert_{F}$。如果 $P$ 为空，则 $M$ 为零矩阵。\n-   **任务 4 (几何属性)**：计算 $P$ 的面积 $A$ 和形心 $(c_{x}, c_{y})$。如果 $P$ 为空，则这些值为 $(0,0,0)$。\n-   **测试用例**：给出了 5 种特定情况的参数 $(a,b,c)$：$(0,0,-1)$、$(0,0,1)$、$(1,0.3,-0.2)$、$(1,1,0)$ 和 $(1,0,0)$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n根据既定的验证标准对问题进行评估。\n\n-   **科学性**：该问题植根于有限元方法，特别是在非贴体网格技术（例如，XFEM、CutFEM）的背景下。所有组件——水平集方法、多边形裁剪、数值求积和基函数——都是数值分析和计算几何中的标准和严谨概念。\n-   **适定性**：该问题是适定的。一个凸多边形（三角形 $T$）与一个半平面的交集是一个明确定义的凸多边形。后续计算几何属性、创建扇形三角剖分和执行数值积分的步骤都有明确的算法规定。处理退化情况的指令清晰明确，消除了歧义，确保每个测试用例都有唯一的解。\n-   **客观性**：问题陈述使用了精确、客观的数学语言，没有任何主观或有偏见的术语。\n-   **完整性和一致性**：问题是自洽的。所有必要的数据，包括域几何、基函数定义（通过其节点属性隐式定义）、水平集形式、数值容差以及三角剖分和积分的算法，都已提供。设置中没有矛盾之处。\n\n### 第 3 步：结论与行动\n\n此问题是**有效的**。它代表了计算科学中一个标准的、适定的任务，没有科学缺陷、歧义或信息缺失。将提供一个合理的解决方案。\n\n### 求解方法\n\n该解决方案需要实现一个计算流程来处理切割单元上的几何形状和积分。该过程按照问题中的规定，分为四个主要阶段。\n\n**基函数**\n对于顶点为 $x_0=(0,0)$、$x_1=(1,0)$ 和 $x_2=(0,1)$ 的父三角形 $T$ 的标准仿射基函数 $\\{N_i\\}_{i=1}^3$，由节点属性 $N_i(x_{j-1}) = \\delta_{ij}$ 决定。这得出以下显式表达式：\n-   $N_1(x,y) = 1 - x - y$ (关联于顶点 $x_0=(0,0)$)\n-   $N_2(x,y) = x$ (关联于顶点 $x_1=(1,0)$)\n-   $N_3(x,y) = y$ (关联于顶点 $x_2=(0,1)$)\n\n**1. 裁剪算法**\n交多边形 $P = T \\cap \\{(x,y) \\mid \\phi(x,y) \\le \\varepsilon\\}$ 是通过用水平集函数定义的半平面裁剪三角形 $T$ 来计算的。采用了 Sutherland-Hodgman 算法的一种变体。顺序处理 $T$ 的三条边。对于连接顶点 $u$ 和 $v$ 的每条边：\n-   在两个端点 $u$ 和 $v$ 处评估水平集函数 $\\phi$ 的值，得到 $\\phi_u$ 和 $\\phi_v$。\n-   如果两个端点都在内部（$\\phi_u \\le \\varepsilon$ 且 $\\phi_v \\le \\varepsilon$），则将第二个顶点 $v$ 添加到输出多边形的顶点列表中。\n-   如果边从内部穿到外部（$\\phi_u \\le \\varepsilon, \\phi_v > \\varepsilon$），则计算交点 $I$ 并将其添加到列表中。\n-   如果边从外部穿到内部（$\\phi_u > \\varepsilon, \\phi_v \\le \\varepsilon$），则将交点 $I$ 和顶点 $v$ 都添加到列表中。\n-   如果两个端点都在外部，则不添加任何顶点。\n\n位于 $u$ 和 $v$ 之间线段上的交点 $I$ 被参数化为 $I(t) = u + t(v-u)$。通过求解 $\\phi(I(t))=0$ 来找到参数 $t$。由于 $\\phi$ 的线性特性，可得 $t = \\phi_u / (\\phi_u - \\phi_v)$。最终生成的有序顶点列表定义了多边形 $P$。在退化情况下产生的冗余顶点将被移除。\n\n**2. 几何属性与积分网格**\n对于一个具有 $n$ 个有序顶点 $(x_0, y_0), \\dots, (x_{n-1}, y_{n-1})$ 的非退化多边形 $P$，其面积 $A$ 和形心 $(c_x, c_y)$ 使用鞋带公式计算：\n$$ A = \\frac{1}{2} \\left| \\sum_{i=0}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n$$ c_x = \\frac{1}{6A} \\sum_{i=0}^{n-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n$$ c_y = \\frac{1}{6A} \\sum_{i=0}^{n-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i) $$\n其中 $(x_n, y_n) = (x_0, y_0)$。\n\n如果多边形 $P$ 非退化（即，至少有 $3$ 个顶点且面积 $A \\ge \\varepsilon$），则构建一个积分网格 $\\mathcal{T}_{\\mathrm{int}}(P)$。通过创建连接计算出的形心 $C = (c_x, c_y)$ 与 $P$ 的每条边的三角形来形成扇形三角剖分。三角形的数量 $n_{\\triangle}$ 等于 $P$ 的顶点数。\n\n**3. 局部质量矩阵组装**\n局部质量矩阵 $M \\in \\mathbb{R}^{3 \\times 3}$ 通过计算积分 $M_{ij} = \\int_P N_i N_j dA$ 来组装。总积分是积分网格中每个三角形 $T_k \\in \\mathcal{T}_{\\mathrm{int}}(P)$ 上积分的总和：\n$$ M_{ij} = \\sum_{T_k \\in \\mathcal{T}_{\\mathrm{int}}(P)} \\int_{T_k} N_i(x,y) N_j(x,y) \\,dA $$\n每个子三角形 $T_k$ 上的积分使用一个对于总次数最高为 $2$ 的多项式精确的数值求积法则进行近似。这里使用满足此要求的 3 点中点法则。对于面积为 $A_k$、三条边中点为 $m_1, m_2, m_3$ 的三角形 $T_k$：\n$$ \\int_{T_k} f(x,y) \\,dA \\approx \\frac{A_k}{3} \\sum_{l=1}^3 f(m_l) $$\n被积函数为 $f(x,y) = N_i(x,y) N_j(x,y)$。来自每个求积点的贡献被累加到相应的矩阵项 $M_{ij}$ 中。最后，计算弗罗贝尼乌斯范数 $\\lVert M \\rVert_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$。\n\n**4. 退化情况处理**\n该算法按规定包含了对退化情况的鲁棒处理：\n- 如果裁剪过程产生的多边形 $P$ 的唯一顶点数少于 $3$ 个或面积 $A < \\varepsilon$，则该情况被视为退化。\n- 对于此类情况，输出值被设置为 $A=0$, $(c_x, c_y) = (0,0)$, $n_{\\triangle}=0$，且 $M$ 为零矩阵，从而得到 $\\lVert M \\rVert_F = 0$。这正确地处理了物理域 $T^-$ 为空集、单一点或线段的场景。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        (0.0, 0.0, -1.0),  # Case 1: Fully inside\n        (0.0, 0.0, 1.0),   # Case 2: Fully outside\n        (1.0, 0.3, -0.2),  # Case 3: Typical cut\n        (1.0, 1.0, 0.0),   # Case 4: Vertex-touching degenerate\n        (1.0, 0.0, 0.0),   # Case 5: Edge-aligned degenerate\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n    \n    # Format the final output string exactly as required\n    formatted_sublists = []\n    for r in results:\n        str_items = [str(item) for item in r]\n        formatted_sublists.append(f\"[{','.join(str_items)}]\")\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output)\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case for the given level-set parameters.\n    \"\"\"\n    a, b, c = params\n    epsilon = 1e-12\n    T_verts = [np.array([0., 0.]), np.array([1., 0.]), np.array([0., 1.])]\n\n    # 1. Clipping\n    P_verts = clip_triangle(T_verts, a, b, c, epsilon)\n\n    # Handle case with fewer than 3 unique vertices\n    if len(P_verts) < 3:\n        return [0.0, 0.0, 0.0, 0, 0.0]\n\n    # 2. Geometric properties\n    area = polygon_area(P_verts)\n    \n    # Handle degenerate case (zero area)\n    if area < epsilon:\n        return [0.0, 0.0, 0.0, 0, 0.0]\n\n    centroid = polygon_centroid(P_verts, area)\n\n    # 3. Integration mesh\n    integration_triangles = fan_triangulate(P_verts, centroid)\n    n_triangles = len(integration_triangles)\n\n    # 4. Local mass matrix\n    mass_matrix = compute_mass_matrix(integration_triangles)\n    norm_M = np.linalg.norm(mass_matrix, 'fro')\n\n    return [area, centroid[0], centroid[1], n_triangles, norm_M]\n\ndef clip_triangle(T_verts, a, b, c, epsilon):\n    \"\"\"\n    Clips a triangle against the half-plane phi(x,y) <= epsilon using a\n    Sutherland-Hodgman-like algorithm.\n    \"\"\"\n    def phi(p):\n        return a * p[0] + b * p[1] + c\n\n    phi_vals = [phi(v) for v in T_verts]\n    \n    clipped_verts = []\n    \n    for i in range(3):\n        u = T_verts[i]\n        v = T_verts[(i + 1) % 3]\n        phi_u = phi_vals[i]\n        phi_v = phi_vals[(i + 1) % 3]\n\n        u_is_inside = phi_u <= epsilon\n        v_is_inside = phi_v <= epsilon\n\n        if u_is_inside and v_is_inside:\n            clipped_verts.append(v)\n        elif u_is_inside and not v_is_inside:\n            # edge from in to out, add intersection\n            t = phi_u / (phi_u - phi_v)\n            intersection = u + t * (v - u)\n            clipped_verts.append(intersection)\n        elif not u_is_inside and v_is_inside:\n            # edge from out to in, add intersection then v\n            t = phi_u / (phi_u - phi_v)\n            intersection = u + t * (v - u)\n            clipped_verts.append(intersection)\n            clipped_verts.append(v)\n        # if both outside, do nothing\n\n    # Remove duplicate vertices that can appear in degenerate cuts\n    if not clipped_verts:\n        return []\n\n    unique_verts = []\n    for v in clipped_verts:\n        is_duplicate = False\n        for uv in unique_verts:\n            if np.linalg.norm(v - uv) < epsilon:\n                is_duplicate = True\n                break\n        if not is_duplicate:\n            unique_verts.append(v)\n    \n    return unique_verts\n\ndef polygon_area(verts):\n    \"\"\"\n    Computes the area of a polygon using the shoelace formula.\n    \"\"\"\n    n = len(verts)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += verts[i][0] * verts[j][1]\n        area -= verts[j][0] * verts[i][1]\n    return abs(area) / 2.0\n\ndef polygon_centroid(verts, area):\n    \"\"\"\n    Computes the centroid of a polygon.\n    \"\"\"\n    n = len(verts)\n    cx, cy = 0.0, 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        common_factor = verts[i][0] * verts[j][1] - verts[j][0] * verts[i][1]\n        cx += (verts[i][0] + verts[j][0]) * common_factor\n        cy += (verts[i][1] + verts[j][1]) * common_factor\n    return np.array([cx, cy]) / (6.0 * area)\n\ndef fan_triangulate(P_verts, centroid):\n    \"\"\"\n    Creates a fan triangulation of a polygon from its centroid.\n    \"\"\"\n    n = len(P_verts)\n    triangles = []\n    for i in range(n):\n        v1 = P_verts[i]\n        v2 = P_verts[(i + 1) % n]\n        triangles.append([centroid, v1, v2])\n    return triangles\n\ndef compute_mass_matrix(triangles):\n    \"\"\"\n    Computes the local mass matrix by integrating over the provided triangulation.\n    \"\"\"\n    M = np.zeros((3, 3))\n    \n    # Nodal basis functions for the parent triangle T\n    N1 = lambda p: 1.0 - p[0] - p[1]\n    N2 = lambda p: p[0]\n    N3 = lambda p: p[1]\n    basis_funcs = [N1, N2, N3]\n\n    for tri_verts in triangles:\n        p1, p2, p3 = tri_verts[0], tri_verts[1], tri_verts[2]\n        \n        # Area of the integration subtriangle\n        area_k = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area_k < 1e-15:\n            continue\n            \n        # 3-point quadrature rule (midpoints of edges)\n        q1 = (p1 + p2) / 2.0\n        q2 = (p2 + p3) / 2.0\n        q3 = (p3 + p1) / 2.0\n        quad_points = [q1, q2, q3]\n        \n        # Quadrature weight\n        w = area_k / 3.0\n        \n        # Accumulate matrix contributions from each quadrature point\n        for qp in quad_points:\n            N_vals = np.array([f(qp) for f in basis_funcs])\n            M += w * np.outer(N_vals, N_vals)\n            \n    return M\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2609382"}, {"introduction": "在前一个练习建立的几何处理基础上，我们现在将这些构件应用于一个完整的物理问题。本练习旨在解决一个包含多相流和表面张力效应的一维模型，这在计算物理中是一个典型且重要的问题。你将推导并实现一个完整的非贴体有限元求解器，关键在于将界面上的物理条件（即由Laplace-Young定律引起的通量跳跃 $[k u']_{\\Gamma} = g$）准确地转化为弱形式中的特定项，并通过与精确解的比较来验证你的数值结果[@problem_id:2609391]。", "problem": "考虑一个带有表面张力效应的两相稳态扩散/压力场的一维模型问题。设计算域为区间 $\\Omega = (0,1)$，流体-流体界面为点 $\\Gamma = \\{\\alpha\\}$，其中 $\\alpha \\in (0,1)$。未知场 $u : \\Omega \\to \\mathbb{R}$ 满足以下强形式：求解 $u$ 使得\n- 在每个子域 $\\Omega^{-} = (0,\\alpha)$ 和 $\\Omega^{+} = (\\alpha,1)$ 中，方程 $- (k u')' = 0$ 成立，其中 $k$ 是分段常数，在 $\\Omega^{-}$ 中 $k = k_0$，在 $\\Omega^{+}$ 中 $k = k_1$；\n- 解在界面上连续，即 $[u]_{\\Gamma} = 0$；\n- 界面上的扩散通量跳跃遵循一个 Laplace–Young 型关系 $[k u']_{\\Gamma} = g$，其中标量 $g$ 表示表面张力 $\\gamma$ 和曲率 $\\kappa$ 的乘积，即 $g = \\gamma \\kappa$；\n- 指定了齐次 Dirichlet 边界条件 $u(0) = 0$ 和 $u(1) = 0$。\n\n此处 $[\\,\\cdot\\,]_{\\Gamma}$ 表示界面 $\\Gamma$ 上的跳跃，定义为从 $\\Omega^{+}$ 的迹减去从 $\\Omega^{-}$ 的迹。该设定是高维中带表面张力多相问题的一维类比，其中的跳跃条件由 Laplace–Young 定律导出。我们的目标是设计并实现一种非贴体有限元近似方法，该方法能够独立于网格来处理界面位置。\n\n你需要从基本定义出发，推导并实现一个一致的非贴体有限元方法：\n1. 从基于标准 Sobolev 空间 $H_0^1(0,1)$ 的弱（变分）形式出发：推导一个双线性形式和一个线性泛函，以施加分段扩散，并将界面上的通量跳跃作为一个分布意义下的源项包含进来。不要假设任何预先打包好的非贴体方案；从第一性原理（在子域上进行分部积分和利用 Laplace–Young 跳跃条件）推导界面贡献。\n2. 在 $\\Omega$ 上使用一个包含 $N$ 个区间的均匀网格，其节点独立于界面位置 $\\alpha$（即非贴体网格）。使用连续分片线性基函数。对于完全位于 $\\Omega^{-}$ 或 $\\Omega^{+}$ 内的单元，使用相应的常数扩散系数。对于包含 $\\alpha$ 的单个被切割单元，通过在 $\\alpha$ 处分割该单元来精确积分双线性形式。将界面贡献作为由 $g$ 加权的点求值，显式地包含在线性泛函中。\n3. 精确解是分片线性的。从强形式和界面/边界条件推导出它，以便进行定量误差评估。\n\n算法任务。实现一个完整的程序，该程序：\n- 使用在被切割单元中的精确子单元积分方法，为非贴体网格组装全局刚度矩阵和载荷向量，并包含界面引起的点载荷。\n- 施加齐次 Dirichlet 边界条件。\n- 求解得到的线性系统以获得节点系数。\n- 通过分片精确积分计算 $L^2$-范数误差和能量半范数误差，并将数值解与你推导出的精确解进行比较。\n\n精确的数学要求：\n- 弱形式应为：求解 $u \\in H_0^1(0,1)$ 使得\n$$\n\\int_{0}^{\\alpha} k_0\\, u'(x)\\, v'(x)\\, dx + \\int_{\\alpha}^{1} k_1\\, u'(x)\\, v'(x)\\, dx = g\\, v(\\alpha)\n\\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n- 精确解的形式为，在 $(0,\\alpha)$ 上 $u(x) = a_0 x + b_0$，在 $(\\alpha,1)$ 上 $u(x) = a_1 x + b_1$，其中的常数由界面和边界条件确定。\n\n你的程序必须为以下参数元组 $(N,\\alpha,k_0,k_1,\\gamma,\\kappa)$ 的测试套件求解该问题：\n- 案例 1：$(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (8,\\, 0.3,\\, 1.0,\\, 3.0,\\, 2.5,\\, 1.2)$，因此 $g = \\gamma \\kappa = 3.0$。\n- 案例 2：$(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (10,\\, 0.000001,\\, 5.0,\\, 1.0,\\, 1.0,\\, 2.0)$，因此 $g = 2.0$。\n- 案例 3：$(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (5,\\, 0.5,\\, 1.0,\\, 1.0,\\, 1.0,\\, 1.0)$，因此 $g = 1.0$。\n- 案例 4：$(N,\\alpha,k_0,k_1,\\gamma,\\kappa) = (12,\\, 0.37,\\, 1.0,\\, 7.0,\\, 0.0,\\, 3.0)$，因此 $g = 0.0$。\n\n对于每个案例，你的程序必须输出一对浮点数：\n- 误差的 $L^2$-范数 $\\|u - u_h\\|_{L^2(0,1)}$；\n- 能量半范数误差 $\\left(\\int_{0}^{\\alpha} k_0\\, |u' - u_h'|^2\\, dx + \\int_{\\alpha}^{1} k_1\\, |u' - u_h'|^2\\, dx \\right)^{1/2}$。\n\n最终输出格式：\n- 打印单行，该行是一个由数对组成的列表，每个测试案例对应一个数对，使用以下格式\n$$\n[[e_{L^2}^{(1)}, e_{E}^{(1)}],[e_{L^2}^{(2)}, e_{E}^{(2)}],[e_{L^2}^{(3)}, e_{E}^{(3)}],[e_{L^2}^{(4)}, e_{E}^{(4)}]]\n$$\n其中每个浮点数都四舍五入到恰好 $8$ 位小数。\n- 不应打印任何额外文本。\n\n澄清说明：\n- 本问题专注于网格独立于界面的非贴体有限元方法。你不应为了贴合 $\\Gamma$ 而重新划分网格。虽然对于高维问题存在诸如切割有限元法 (CutFEM) 或扩展有限元法 (XFEM) 等方法，但当前的一维设定允许对界面进行精确求积，并允许将表面张力引起的通量跳跃 $g$ 表示为点载荷。", "solution": "问题陈述已经过分析，并被认为是有效的。这是一个带不连续系数和界面条件的适定一维椭圆边值问题，也是计算物理学中的一个标准模型。它具有科学依据、内容自洽，且不含任何歧义或矛盾。我们开始进行求解。\n\n解法分四部分展开：第一，从强形式推导弱（变分）形式；第二，推导解析精确解；第三，构建非贴体有限元方法；第四，计算误差范数的方法。\n\n**1. 弱形式**\n\n问题的强形式由下式给出：\n$$\n- (k u')' = 0 \\quad \\text{in } \\Omega^{-} \\cup \\Omega^{+} = (0,\\alpha) \\cup (\\alpha,1)\n$$\n附带边界条件 $u(0)=0$, $u(1)=0$ 和界面条件 $[u]_{\\Gamma}=0$, $[k u']_{\\Gamma}=g$。跳跃定义为 $[\\cdot]_{\\Gamma} = (\\cdot)|_{\\alpha^+} - (\\cdot)|_{\\alpha^-}$。\n\n为推导弱形式，我们将方程乘以一个测试函数 $v \\in H_0^1(0,1)$ 并在域 $\\Omega = (0,1)$ 上积分。积分在界面 $\\alpha$ 处分割：\n$$\n- \\int_{0}^{\\alpha} (k_0 u')' v \\, dx - \\int_{\\alpha}^{1} (k_1 u')' v \\, dx = 0\n$$\n对每个积分应用分部积分，得到：\n$$\n\\int_{0}^{\\alpha} k_0 u' v' \\, dx - [ (k_0 u') v ]_{0}^{\\alpha} + \\int_{\\alpha}^{1} k_1 u' v' \\, dx - [ (k_1 u') v ]_{\\alpha}^{1} = 0\n$$\n代入积分限：\n$$\n\\left( \\int_{0}^{\\alpha} k_0 u' v' \\, dx - k_0 u'(\\alpha^-) v(\\alpha) + k_0 u'(0^+) v(0) \\right) + \\left( \\int_{\\alpha}^{1} k_1 u' v' \\, dx - k_1 u'(1^-) v(1) + k_1 u'(\\alpha^+) v(\\alpha) \\right) = 0\n$$\n由于 $v \\in H_0^1(0,1)$，边界项 $v(0)$ 和 $v(1)$ 为零。表达式简化为：\n$$\n\\int_{0}^{\\alpha} k_0 u' v' \\, dx + \\int_{\\alpha}^{1} k_1 u' v' \\, dx + (k_1 u'(\\alpha^+) - k_0 u'(\\alpha^-)) v(\\alpha) = 0\n$$\n使用通量跳跃条件 $[k u']_{\\Gamma} = k_1 u'(\\alpha^+) - k_0 u'(\\alpha^-) = g$，我们得到最终的弱形式：求解 $u \\in H_0^1(0,1)$ 使得\n$$\n\\int_{0}^{\\alpha} k_0 u'(x) v'(x) \\, dx + \\int_{\\alpha}^{1} k_1 u'(x) v'(x) \\, dx = g v(\\alpha) \\quad \\forall v \\in H_0^1(0,1)\n$$\n这定义了双线性形式 $a(u,v) = \\int_0^1 k(x) u' v' dx$ 和线性泛函 $L(v) = g v(\\alpha)$。\n\n**2. 精确解**\n\n在每个子域中，方程 $u''=0$ 意味着解是分片线性的。\n设当 $x \\in (0,\\alpha)$ 时 $u(x) = c_0 x + d_0$ 且当 $x \\in (\\alpha,1)$ 时 $u(x) = c_1 x + d_1$。\n应用四个条件：\n1.  $u(0) = 0 \\implies c_0(0) + d_0 = 0 \\implies d_0 = 0$。\n2.  $u(1) = 0 \\implies c_1(1) + d_1 = 0 \\implies d_1 = -c_1$。\n3.  $[u]_{\\Gamma} = 0 \\implies c_1 \\alpha + d_1 = c_0 \\alpha \\implies c_1 \\alpha - c_1 = c_0 \\alpha$。\n4.  $[k u']_{\\Gamma} = g \\implies k_1 c_1 - k_0 c_0 = g$。\n\n从条件 3，我们有 $c_0 = c_1 (\\alpha-1)/\\alpha$。将其代入条件 4 得到：\n$k_1 c_1 - k_0 c_1 \\frac{\\alpha-1}{\\alpha} = g \\implies c_1 \\left(k_1 - k_0 \\frac{\\alpha-1}{\\alpha}\\right) = g \\implies c_1 \\frac{k_1\\alpha - k_0\\alpha + k_0}{\\alpha} = g$。\n解出 $c_1$ 和 $c_0$：\n$$\nc_1 = \\frac{g \\alpha}{(k_1 - k_0)\\alpha + k_0}, \\qquad c_0 = \\frac{g (\\alpha-1)}{(k_1 - k_0)\\alpha + k_0}\n$$\n因此，精确解为：\n$$\nu(x) =\n\\begin{cases}\nc_0 x & \\text{if } 0 \\le x \\le \\alpha \\\\\nc_1 (x-1) & \\text{if } \\alpha < x \\le 1\n\\end{cases}\n$$\n分母 $(k_1-k_0)\\alpha+k_0 = k_1\\alpha+k_0(1-\\alpha)$ 是正扩散系数的凸组合，因此对于 $\\alpha \\in(0,1)$ 是严格为正的，这确保了解的适定性。\n\n**3. 非贴体有限元方法**\n\n我们用一个含 $N$ 个单元、尺寸为 $h=1/N$ 的均匀网格来离散化域 $\\Omega=(0,1)$。节点为 $x_i=ih$，$i=0, \\dots, N$。我们使用满足 $\\phi_i(x_j)=\\delta_{ij}$ 的标准连续分片线性 (P1) 基函数。近似解为 $u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)$，其中 $U_j$ 是内部节点上的未知节点值，因为根据 Dirichlet 条件 $U_0=U_N=0$。\n\n离散系统是一个线性系统 $A \\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U} = (U_1, \\dots, U_{N-1})^T$，且对于 $i,j \\in \\{1,\\dots,N-1\\}$：\n$$\nA_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 k(x) \\phi_j'(x) \\phi_i'(x) \\, dx, \\quad F_i = L(\\phi_i) = g \\phi_i(\\alpha)\n$$\n矩阵 $A$ 是三对角的。其元素由导数 $\\phi_i'(x) = 1/h$ (在 $(x_{i-1}, x_i)$ 上) 和 $\\phi_i'(x) = -1/h$ (在 $(x_i, x_{i+1})$ 上) 计算得出。\n对于大小为 $N-1$ 的矩阵，其对角元和非对角元（对于 $i=1, \\dots, N-1$）为：\n$$\nA_{i-1,i-1} = \\frac{1}{h^2} \\left( \\int_{x_{i-1}}^{x_i} k(x) dx + \\int_{x_i}^{x_{i+1}} k(x) dx \\right)\n$$\n$$\nA_{i-1,i} = A_{i,i-1} = -\\frac{1}{h^2} \\int_{x_i}^{x_{i+1}} k(x) dx \\quad (\\text{for } i<N-1)\n$$\n积分值取决于 $\\alpha$ 的位置。设 $m=\\lfloor \\alpha/h \\rfloor$。对于一个单元 $(x_j, x_{j+1})$：\n- 如果 $j \\ne m$，$\\int_{x_j}^{x_{j+1}} k(x) dx = k_{\\text{elem}} h$，其中如果 $x_{j+1} \\le \\alpha$，则 $k_{\\text{elem}}$ 为 $k_0$；如果 $x_j \\ge \\alpha$，则为 $k_1$。\n- 如果 $j = m$（被切割单元），$\\int_{x_m}^{x_{m+1}} k(x) dx = k_0(\\alpha - x_m) + k_1(x_{m+1} - \\alpha)$。\n\n载荷向量 $\\mathbf{F}$ 由 $F_i = g \\phi_i(\\alpha)$ 组装而成。由于 $\\phi_i(\\alpha)$ 仅当 $\\alpha \\in (x_{i-1}, x_{i+1})$ 时非零，所以只有邻近界面的节点会接收到载荷。对于被切割单元 $(x_m, x_{m+1})$：\n$$\nF_{m-1} = g \\phi_m(\\alpha) = g \\frac{x_{m+1} - \\alpha}{h} \\quad (\\text{若 } m > 0)\n$$\n$$\nF_{m} = g \\phi_{m+1}(\\alpha) = g \\frac{\\alpha - x_m}{h} \\quad (\\text{若 } m+1 < N)\n$$\n然后求解该线性系统以得到节点值 $\\mathbf{U}$。\n\n**4. 误差计算**\n\n误差范数通过在每个单元上精确积分误差函数来计算。误差 $e(x) = u(x) - u_h(x)$ 在由网格节点和界面点 $\\alpha$ 定义的子区间上是分片线性的。\n设一个积分区间为 $[a,b]$。\n$L^2$-范数误差为 $\\|e\\|_{L^2(0,1)} = \\left( \\int_0^1 e(x)^2 dx \\right)^{1/2}$。在任何 $e(x)$ 是线性的子区间 $[a,b]$ 上，其积分由 $\\int_a^b e(x)^2 dx = \\frac{b-a}{3}(e(a)^2 + e(a)e(b) + e(b)^2)$ 给出。\n能量半范数误差为 $\\|e\\|_E = \\left( \\int_0^1 k(x) (e'(x))^2 dx \\right)^{1/2}$。在一个子区间 $[a,b]$ 上，$u'(x)$ 是常数，$u_h'(x)$ 也是常数，因此 $e'(x)$ 是常数。该积分为 $k(x) (e')^2 (b-a)$。\n\n总误差通过将每个子区间的贡献相加得到。为此，被切割单元 $(x_m, x_{m+1})$ 被分割为 $(x_m, \\alpha)$ 和 $(\\alpha, x_{m+1})$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D two-phase diffusion problem with an interface flux jump\n    using an unfitted finite element method for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (8, 0.3, 1.0, 3.0, 2.5, 1.2),\n        (10, 0.000001, 5.0, 1.0, 1.0, 2.0),\n        (5, 0.5, 1.0, 1.0, 1.0, 1.0),\n        (12, 0.37, 1.0, 7.0, 0.0, 3.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, alpha, k0, k1, gamma, kappa = case\n        g = gamma * kappa\n\n        # 1. Analytically derive exact solution parameters\n        denom = (k1 - k0) * alpha + k0\n        c0 = g * (alpha - 1) / denom if denom != 0 else 0\n        c1 = g * alpha / denom if denom != 0 else 0\n\n        def u_exact(x):\n            if isinstance(x, (int, float)):\n                return c0 * x if x <= alpha else c1 * (x - 1)\n            else: # numpy array\n                res = np.zeros_like(x, dtype=float)\n                mask0 = x <= alpha\n                mask1 = ~mask0\n                res[mask0] = c0 * x[mask0]\n                res[mask1] = c1 * (x[mask1] - 1)\n                return res\n        \n        # 2. Set up mesh and system for internal nodes\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n        num_unknowns = N - 1\n        \n        # 3. Assemble Stiffness Matrix A\n        def get_k_integral(x_start, x_end):\n            if x_end <= alpha:\n                return k0 * (x_end - x_start)\n            elif x_start >= alpha:\n                return k1 * (x_end - x_start)\n            else:  # cut element\n                return k0 * (alpha - x_start) + k1 * (x_end - alpha)\n\n        diag = np.zeros(num_unknowns)\n        off_diag = np.zeros(num_unknowns-1)\n\n        for i in range(1, N):  # Loop over internal nodes 1 to N-1\n            idx = i - 1\n            integral_left = get_k_integral(nodes[i - 1], nodes[i])\n            integral_right = get_k_integral(nodes[i], nodes[i + 1])\n            diag[idx] = (integral_left + integral_right) / h**2\n            if i < N - 1:\n                off_diag[idx] = -integral_right / h**2\n        \n        # Banded matrix format for scipy solver: ab[0,:]=super-diag, ab[1,:]=main-diag, ab[2,:]=sub-diag\n        ab = np.zeros((3, num_unknowns))\n        ab[0, 1:] = off_diag\n        ab[1, :] = diag\n        ab[2, :-1] = off_diag\n\n        # 4. Assemble Load Vector F\n        F = np.zeros(num_unknowns)\n        m = int(np.floor(alpha / h))  # Index of the left node of the cut element\n        \n        # Contribution at node m (if internal)\n        if m > 0:\n            F[m - 1] += g * (nodes[m + 1] - alpha) / h\n            \n        # Contribution at node m+1 (if internal)\n        if m + 1 < N:\n            F[m] += g * (alpha - nodes[m]) / h\n\n        # 5. Solve linear system and construct full solution vector\n        U_internal = solve_banded((1, 1), ab, F)\n        \n        U_h = np.zeros(N + 1)\n        U_h[1:-1] = U_internal\n        \n        # 6. Compute error norms with exact piecewise integration\n        l2_err_sq = 0.0\n        energy_err_sq = 0.0\n\n        for i in range(N):  # Loop over elements\n            x_i, x_i1 = nodes[i], nodes[i + 1]\n            u_hi, u_hi1 = U_h[i], U_h[i + 1]\n            u_h_prime_val = (u_hi1 - u_hi) / h\n            \n            sub_intervals = []\n            if x_i1 <= alpha:\n                sub_intervals.append((x_i, x_i1, k0, c0))\n            elif x_i >= alpha:\n                sub_intervals.append((x_i, x_i1, k1, c1))\n            else:  # Cut element\n                sub_intervals.append((x_i, alpha, k0, c0))\n                sub_intervals.append((alpha, x_i1, k1, c1))\n\n            for a, b, k_val, c_val in sub_intervals:\n                # Energy semi-norm contribution\n                e_prime = c_val - u_h_prime_val\n                energy_err_sq += k_val * e_prime**2 * (b - a)\n\n                # L2-norm contribution\n                def u_h_local(x):\n                    return u_hi * (x_i1 - x) / h + u_hi1 * (x - x_i) / h\n                \n                e_a = u_exact(a) - u_h_local(a)\n                e_b = u_exact(b) - u_h_local(b)\n                \n                l2_err_sq += ((b - a) / 3.0) * (e_a**2 + e_a * e_b + e_b**2)\n\n        l2_error = np.sqrt(l2_err_sq)\n        energy_error = np.sqrt(energy_err_sq)\n\n        all_results.append(f\"[{l2_error:.8f},{energy_error:.8f}]\")\n    \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2609391"}, {"introduction": "在学会如何构建一个非贴体求解器之后，一个自然而然的问题是：我们如何评估其解的质量和可靠性？本练习将我们的关注点从“如何构建”转向“如何分析”。你将探索用于非贴体方法的后验误差估计器 $\\eta$，并研究当界面位置发生微小扰动时估计器的鲁棒性——这对于确保数值方法的稳定性和可信度至关重要[@problem_id:2609385]。", "problem": "考虑一个在开区间 $\\Omega=(0,1)$ 上带材料界面的一维稳态扩散模型。设扩散系数为分段常数，在界面点 $\\Gamma=\\{x=s\\}$ (其中 $s\\in(0,1)$) 处有跳跃，由 $\\alpha(x)=\\alpha^{-}$ (对于 $x<s$) 和 $\\alpha(x)=\\alpha^{+}$ (对于 $x>s$) 给出，其中 $\\alpha^{-}>0$ 且 $\\alpha^{+}>0$。其强形式为 $-(\\alpha u')'=f$ 在 $\\Omega\\setminus\\Gamma$ 上成立，同时在界面 $\\Gamma$ 处满足 $u$ 的连续性和通量连续性 $\\llbracket \\alpha u' \\rrbracket_{\\Gamma}=0$，并在 $x=0$和 $x=1$ 处满足齐次 Dirichlet 边界条件。一种非贴体有限元方法（例如，在独立于 $\\Gamma$ 的背景网格上使用 Nitsche 型方法）通过添加一致性项和稳定化项来弱施加界面条件，这些项惩罚位移跳跃并控制跨 $\\Gamma$ 的通量跳跃，其中使用对称罚，其稳定化参数与扩散系数成比例。\n\n定义 $\\Omega$ 上的一个包含 $N$ 个单元的均匀网格，其节点为 $x_i=i/N$ ($i=0,1,\\dots,N$)，单元尺寸为 $h=1/N$。设 $u_h$ 是函数 $g(x)=\\sin(\\pi x)$ 在此网格上的连续分段仿射节点插值，因此 $u_h(0)=u_h(1)=0$。设右端项为 $f(x)\\equiv 1$。对于一个不与网格节点重合的固定界面位置 $s\\in(0,1)$，考虑为一维空间中的非贴体、Nitsche 稳定离散化设计的基于残差的后验误差指示子的以下概念性组成部分：\n- 逐单元的体残差，用于衡量每个单元上强残差的 $L^2$ 范数，并按局部网格尺寸的适当幂次进行缩放。\n- 内部节点贡献，用于衡量跨网格节点（在一维中被视为内部面）的通量跳跃 $\\llbracket \\alpha u_h' \\rrbracket$，并按局部网格尺寸的适当幂次进行缩放。\n- 在切割位置 $x=s$ 处的界面贡献，其结合了对位移跳跃的惩罚和对通量跳跃的惩罚，其缩放方式仿照对称 Nitsche 施加界面条件的方式，稳定化参数 $\\beta>0$ 的选择与最大扩散系数成正比，以实现对扩散对比度和界面位置的鲁棒性。\n\n从带有 Nitsche 型界面项的弱形式以及连续分段仿射函数的残差分布定义出发，推导出一维全局指示子 $\\eta(s)$ 的全离散表达式，该表达式仅依赖于网格、分段常数系数 $\\alpha^{-}$ 和 $\\alpha^{+}$、稳定化参数 $\\beta$、右端项 $f$ 以及 $u_h$ 的分段常数单元导数。您的推导必须只使用基于残差指示子的基本定义和与弱施加界面条件一致的对称罚缩放，不得依赖任何未经证明的捷径。\n\n然后，实现一个程序来评估该指示子在界面位置小扰动下的鲁棒性。具体来说，设 $N=8$，$h=1/N$，$u_h$ 为 $g(x)=\\sin(\\pi x)$ 的节点插值，且 $f(x)\\equiv 1$。对于以下每个测试用例，给定值 $\\alpha^{-}$、$\\alpha^{+}$、稳定化参数 $\\beta$、一个基准界面位置 $s_0$以及集合 $\\Delta=\\{\\delta_1,\\delta_2,\\delta_3\\}$ 中收集的三个扰动。对于每个 $\\delta\\in\\Delta$，设置 $s=s_0+\\delta$ 并使用您推导的表达式计算全局指示子 $\\eta(s)$。定义鲁棒性比率 $\\rho(\\delta)=\\eta(s_0+\\delta)/\\eta(s_0)$。对于每个测试用例，还需计算一个布尔标志，当且仅当所有比率都位于指定的界限区间 $[L,U]$（含边界）内时，该标志为真。\n\n测试套件：\n- 测试用例 A (在单个被切割单元内的理想情况): $N=8$, $(\\alpha^{-},\\alpha^{+})=(5,1)$, $\\beta=5$, $s_0=0.31$, $\\Delta=\\{-0.02,0.00,0.02\\}$, 界限 $[L,U]=[0.95,1.05]$。\n- 测试用例 B (高对比度鲁棒性，稳定化参数按最大扩散系数缩放): $N=8$, $(\\alpha^{-},\\alpha^{+})=(1000,0.1)$, $\\beta=1000$, $s_0=0.43$, $\\Delta=\\{-0.02,0.00,0.02\\}$, 界限 $[L,U]=[0.95,1.05]$。\n- 测试用例 C (穿越网格节点的扰动，导致被切割单元改变): $N=8$, $(\\alpha^{-},\\alpha^{+})=(2,7)$, $\\beta=7$, $s_0=0.44$, $\\Delta=\\{-0.02,0.00,0.08\\}$, 界限 $[L,U]=[0.5,1.5]$。\n- 测试用例 D (界面靠近边界，在扰动下仍保持在第一个单元内): $N=8$, $(\\alpha^{-},\\alpha^{+})=(3,1)$, $\\beta=3$, $s_0=0.06$, $\\Delta=\\{-0.02,0.00,0.02\\}$, 界限 $[L,U]=[0.95,1.05]$。\n\n您的程序必须在均匀网格上根据 $g(x)=\\sin(\\pi x)$ 构建 $u_h$，将 $f(x)\\equiv 1$ 视为常数，并为每个用例计算列表 $[\\rho(\\delta_1),\\rho(\\delta_2),\\rho(\\delta_3),\\text{flag}]$。最终输出必须是单行，包含一个列表，其中每个条目对应一个测试用例，且每个条目都是上述形式的列表。例如，输出格式必须是单行，如 $[[r_{A,1},r_{A,2},r_{A,3},b_A],[r_{B,1},r_{B,2},r_{B,3},b_B],[r_{C,1},r_{C,2},r_{C,3},b_C],[r_{D,1},r_{D,2},r_{D,3},b_D]]$，其中每个 $r_{\\cdot,\\cdot}$ 是一个浮点数，每个 $b_{\\cdot}$ 是一个布尔值。此问题不涉及物理单位。所有角度（如果出现）必须以弧度为单位，但此处不需要。如果需要，可将浮点值四舍五入到合理的小数位数以供显示；但请保持内部精度以避免虚假的舍入效应。您的程序不得读取任何输入，也不得写入除所要求的单行输出之外的任何辅助文本。", "solution": "该问题要求针对带材料界面的一维扩散问题，推导并实现一个基于残差的后验误差指示子 $\\eta(s)$。推导将基于指定概念性组成部分。\n\n该问题定义在域 $\\Omega=(0,1)$上，使用一个包含 $N$ 个单元的均匀网格，单元尺寸为 $h=1/N$，节点为 $x_i=i/N$ ($i=0, \\dots, N$)。近似解 $u_h$ 是 $g(x)=\\sin(\\pi x)$ 的连续分段仿射节点插值。强形式为 $-(\\alpha u')'=f$ 在 $\\Omega \\setminus \\Gamma$ 上成立，其中 $\\Gamma=\\{s\\}$ 是界面位置。扩散系数为 $\\alpha(x)=\\alpha^{-}$ (对于 $x<s$) 和 $\\alpha(x)=\\alpha^{+}$ (对于 $x>s$) 。右端项为 $f(x) \\equiv 1$。\n\n全局误差指示子 $\\eta(s)$ 由局部贡献的总和构成。指示子的平方是局部指示子平方的总和：\n$$ \\eta(s)^2 = \\eta_R^2 + \\eta_F^2 + \\eta_I^2 $$\n这些项分别对应于单元（体）残差、内部面（节点）残差以及特定界面残差。我们将逐一推导每个分量。\n\n**1. 单元体残差贡献 ($\\eta_R^2$)**\n\n单元 $T$ 的体残差基于强残差 $R_T(x) = -(\\alpha(x) u_h'(x))' - f(x)$。函数 $u_h$ 是分段仿射的，因此其导数 $u_h'$ 是分段常数。令 $u_h'(x) = u'_{h,i}$ 对于 $x \\in T_i = (x_{i-1}, x_i)$。\n对于任何未被界面 $s$ 切割的单元 $T_i$，系数 $\\alpha(x)$ 是常数。因此，$(\\alpha(x) u_h'(x))' = (\\text{常数} \\cdot \\text{常数})' = 0$。残差为 $R_{T_i}(x) = -f(x) = -1$。\n对于被界面切割的单个单元 $T_k$，$\\alpha(x)$ 有一个跳跃。导数 $(\\alpha u_h')'$ 是一个以 $s$ 为中心的 Dirac 分布，形式上为 $u'_{h,k} (\\alpha^+ - \\alpha^-) \\delta(x-s)$。在非贴体方法的基于残差的指示子中，这个分布部分自然地被并入界面跳跃项。在单元部分 $(x_{k-1},s)$ 和 $(s,x_k)$ 内部，体残差仍然只是 $-f(x)=-1$。\n因此，对于所有单元 $T_i$，体残差的 $L^2$ 被积函数就是 $f(x)^2 = 1^2 = 1$。一个标准的残差指示子将体残差的 $L^2$ 范数的平方乘以单元尺寸 $h$ 的平方进行缩放。来自单元 $T_i$ 的贡献是：\n$$ \\eta_{R,i}^2 = h^2 \\int_{T_i} f(x)^2 \\, dx = h^2 \\int_{x_{i-1}}^{x_i} 1 \\, dx = h^2 \\cdot h = h^3 $$\n对网格的所有 $N$ 个单元求和，得到总体残差贡献：\n$$ \\eta_R^2 = \\sum_{i=1}^{N} \\eta_{R,i}^2 = \\sum_{i=1}^{N} h^3 = N h^3 = (1/h) h^3 = h^2 $$\n\n**2. 内部节点残差贡献 ($\\eta_F^2$)**\n\n此项惩罚跨内部网格节点 $x_j$ ($j=1, \\dots, N-1$) 的通量 $\\alpha u_h'$ 的跳跃。在节点 $x_j$ 处的跳跃定义为 $\\llbracket \\alpha u_h' \\rrbracket_{x_j} = (\\alpha u_h')(x_j^+) - (\\alpha u_h')(x_j^-)$。在一个节点 $x_j$ 处，根据假设该节点不与 $s$ 重合，因此系数 $\\alpha$ 是连续的，即 $\\alpha(x_j^+) = \\alpha(x_j^-) = \\alpha(x_j)$。导数 $u_h'$ 在相邻单元上是常数，在 $T_j=(x_{j-1},x_j)$ 上取值 $u'_{h,j}$，在 $T_{j+1}=(x_j,x_{j+1})$ 上取值 $u'_{h,j+1}$。因此通量跳跃为：\n$$ \\llbracket \\alpha u_h' \\rrbracket_{x_j} = \\alpha(x_j) u'_{h,j+1} - \\alpha(x_j) u'_{h,j} = \\alpha(x_j) (u'_{h,j+1} - u'_{h,j}) $$\n对于一个面（一维中的节点），指示子的平方按面测度进行缩放，这里取为单元尺寸 $h$。所有内部节点的总贡献为：\n$$ \\eta_F^2 = \\sum_{j=1}^{N-1} h \\left( \\llbracket \\alpha u_h' \\rrbracket_{x_j} \\right)^2 = \\sum_{j=1}^{N-1} h \\left( \\alpha(x_j) (u'_{h,j+1} - u'_{h,j}) \\right)^2 $$\n\n**3. 界面残差贡献 ($\\eta_I^2$)**\n\n此项源于 Nitsche 型方法中界面条件的弱施加。它惩罚位移连续性 $[u]_s = 0$ 和通量连续性 $\\llbracket \\alpha u' \\rrbracket_s = 0$ 的不满足。对称 Nitsche 公式建议了一个复合惩罚项。相应指示子贡献的标准形式为：\n$$ \\eta_{I,s}^2 = \\frac{\\beta}{h} [u_h]_s^2 + \\frac{h}{\\beta} \\llbracket \\alpha u_h' \\rrbracket_s^2 $$\n其中 $\\beta$ 是一个正的稳定化参数，$h$ 是包含界面的单元的尺寸。\n问题指明 $u_h$ 是一个连续的分段仿射函数。根据这种构造，在任何点 $s$ 的位移跳跃都恒等于零：\n$$ [u_h]_s = u_h(s^+) - u_h(s^-) = 0 $$\n因此，$\\eta_{I,s}^2$ 中的第一项消失。\n第二项涉及在物理界面 $s$ 处的通量跳跃。设 $T_k=(x_{k-1}, x_k)$ 是包含 $s$ 的单元。导数 $u_h'$ 在此单元上是常数，$u_h'(x) = u'_{h,k}$ 对于 $x \\in T_k$。系数 $\\alpha$ 在 $s$ 处从 $\\alpha^-$ 跳跃到 $\\alpha^+$。通量跳跃为：\n$$ \\llbracket \\alpha u_h' \\rrbracket_s = (\\alpha u_h')(s^+) - (\\alpha u_h')(s^-) = \\alpha^+ u'_{h,k} - \\alpha^- u'_{h,k} = u'_{h,k} (\\alpha^+ - \\alpha^-) $$\n因此，界面对指示子的贡献简化为：\n$$ \\eta_{I,s}^2 = \\frac{h}{\\beta} \\left( u'_{h,k} (\\alpha^+ - \\alpha^-) \\right)^2 $$\n\n**4. 全局指示子的最终表达式**\n\n结合这三个分量，得到全局指示子平方 $\\eta(s)^2$ 的最终表达式：\n$$ \\eta(s)^2 = N h^3 + \\sum_{j=1}^{N-1} h \\left( \\alpha(x_j) (u'_{h,j+1} - u'_{h,j}) \\right)^2 + \\frac{h}{\\beta} \\left( u'_{h,k} (\\alpha^+ - \\alpha^-) \\right)^2 $$\n为了实现这个公式，我们需要以下离散量：\n- 网格参数: $N$ 和 $h = 1/N$。\n- $u_h$ 的导数: 在每个单元 $T_i=(x_{i-1}, x_i)$ 上，导数是常数，由下式给出\n  $$ u'_{h,i} = \\frac{u_h(x_i) - u_h(x_{i-1})}{h} = \\frac{\\sin(\\pi i/N) - \\sin(\\pi(i-1)/N)}{h} $$\n  对于 $i=1, \\dots, N$。\n- 节点处的系数值: 对于一个给定的界面位置 $s$，若 $j/N < s$，则 $\\alpha(x_j) = \\alpha^-$；若 $j/N > s$，则 $\\alpha(x_j) = \\alpha^+$。\n- 被切割单元的索引: 对于一个给定的 $s$，包含 $s$ 的被切割单元 $T_k$ 的索引 $k$ 满足 $x_{k-1} < s < x_k$。对于均匀网格，这等于 $k = \\lfloor s/h \\rfloor + 1 = \\lfloor sN \\rfloor + 1$。所需的导数是 $u'_{h,k}$。\n\n该实现将针对每个测试用例中指定的参数来评估此表达式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and implementing an a posteriori error indicator for an \n    unfitted finite element method, and testing its robustness.\n    \"\"\"\n\n    test_cases = [\n        # Case A: Happy path\n        {'N': 8, 'alpha_m': 5, 'alpha_p': 1, 'beta': 5, 's0': 0.31, \n         'Delta': [-0.02, 0.00, 0.02], 'bounds': [0.95, 1.05]},\n        # Case B: High-contrast\n        {'N': 8, 'alpha_m': 1000, 'alpha_p': 0.1, 'beta': 1000, 's0': 0.43, \n         'Delta': [-0.02, 0.00, 0.02], 'bounds': [0.95, 1.05]},\n        # Case C: Node crossing\n        {'N': 8, 'alpha_m': 2, 'alpha_p': 7, 'beta': 7, 's0': 0.44, \n         'Delta': [-0.02, 0.00, 0.08], 'bounds': [0.5, 1.5]},\n        # Case D: Interface near boundary\n        {'N': 8, 'alpha_m': 3, 'alpha_p': 1, 'beta': 3, 's0': 0.06, \n         'Delta': [-0.02, 0.00, 0.02], 'bounds': [0.95, 1.05]},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case['N']\n        alpha_m = case['alpha_m']\n        alpha_p = case['alpha_p']\n        beta = case['beta']\n        s0 = case['s0']\n        Delta = case['Delta']\n        L, U = case['bounds']\n\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        # Pre-compute derivatives u_h' on each element\n        u_h_nodes = np.sin(np.pi * nodes)\n        u_h_prime = (u_h_nodes[1:] - u_h_nodes[:-1]) / h\n\n        def compute_eta_squared(s):\n            # 1. Bulk residual contribution\n            eta_R_sq = N * h**3\n\n            # 2. Interior node residual contribution\n            eta_F_sq = 0.0\n            for j in range(1, N):\n                node_j = nodes[j]\n                alpha_at_node = alpha_m if node_j < s else alpha_p\n                # Derivatives are on T_j and T_{j+1}, corresponding to indices j-1 and j\n                u_h_prime_jump = u_h_prime[j] - u_h_prime[j-1]\n                flux_jump_sq = (alpha_at_node * u_h_prime_jump)**2\n                eta_F_sq += h * flux_jump_sq\n\n            # 3. Interface residual contribution\n            # Cut element index k (1-based) is floor(s/h) + 1\n            # 0-based index for u_h_prime is k-1 = floor(s/h)\n            k_idx = int(s // h)\n            # Ensure index is within bounds [0, N-1]\n            k_idx = min(max(k_idx, 0), N - 1)\n            \n            u_h_prime_k = u_h_prime[k_idx]\n            flux_jump_s_sq = (u_h_prime_k * (alpha_p - alpha_m))**2\n            eta_I_sq = (h / beta) * flux_jump_s_sq\n            \n            return eta_R_sq + eta_F_sq + eta_I_sq\n\n        eta_s0 = np.sqrt(compute_eta_squared(s0))\n        \n        ratios = []\n        is_robust = True\n        for delta in Delta:\n            s_perturbed = s0 + delta\n            # Ensure s is within (0,1) but not exactly on a node for validity\n            # (though the formula works, this reflects problem constraints).\n            # Small epsilon shift if s lands on a node.\n            if any(np.isclose(s_perturbed, nodes[1:-1])):\n                s_perturbed += 1e-9\n\n            eta_s = np.sqrt(compute_eta_squared(s_perturbed))\n            \n            ratio = eta_s / eta_s0 if eta_s0 != 0 else 0\n            ratios.append(ratio)\n            \n            if not (L <= ratio <= U):\n                is_robust = False\n        \n        case_result = ratios + [is_robust]\n        all_results.append(case_result)\n        \n    # Format floating-point numbers for consistent output\n    formatted_results = []\n    for res_list in all_results:\n        float_vals = res_list[:-1]\n        bool_val = res_list[-1]\n        formatted_floats = [f\"{v:.8f}\" for v in float_vals]\n        formatted_results.append(f\"[{','.join(formatted_floats)},{str(bool_val).lower()}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2609385"}]}