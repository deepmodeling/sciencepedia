{"hands_on_practices": [{"introduction": "这一基础练习是掌握可杂交间断伽辽金 (Hybridizable Discontinuous Galerkin, HDG) 方法的第一步。我们将深入剖析单个参考单元上的 HDG 公式，通过为简单情况显式写出连接迹未知数与单元内部未知数的矩阵，您将对该方法的核心构建块有一个具体的理解。这个过程对于理解如何从变分形式过渡到可计算的代数系统至关重要。[@problem_id:2566501]", "problem": "考虑在顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的参考三角形 $\\widehat{T}$ 上的泊松方程的可杂交间断伽辽金 (HDG) 方法。令扩散系数为常数 $1$，且稳定化参数 $\\tau$ 在每条边上为常数。考虑 $\\widehat{T}$ 上的一阶系统\n$q + \\nabla u = 0$ 和 $\\nabla \\cdot q = f$，并假设 $f \\equiv 0$，从而局部求解器将迹未知量 $\\widehat{u}_h$ 映射到单元未知量 $(q_h,u_h)$，而无载荷项的贡献。\n\n在每条边 $\\mathcal{F} \\subset \\partial \\widehat{T}$ 上使用多项式空间 $V_h(\\widehat{T}) = [\\mathcal{P}_k(\\widehat{T})]^2$，$W_h(\\widehat{T}) = \\mathcal{P}_k(\\widehat{T})$ 和 $M_h(\\partial \\widehat{T}) = \\mathcal{P}_k(\\mathcal{F})$，其中 $k=1$。设 $\\{\\boldsymbol{\\varphi}_i\\}_{i=1}^{N_v}$ 为 $V_h(\\widehat{T})$ 的一组基，$\\{\\phi_j\\}_{j=1}^{N_w}$ 为 $W_h(\\widehat{T})$ 的一组基，$\\{\\psi_m\\}_{m=1}^{N_m}$ 为由各边上的基组合而成的 $M_h(\\partial \\widehat{T})$ 的一组基。在 $\\partial \\widehat{T}$ 上采用数值通量 $\\widehat{q}_h \\cdot n = q_h \\cdot n + \\tau\\,(u_h - \\widehat{u}_h)$。\n\n从一阶系统的弱形式出发，推导将迹系数 $\\widehat{\\boldsymbol{u}} \\in \\mathbb{R}^{N_m}$ 映射到 $(q_h,u_h)$ 的局部系数的单元局部线性系统，其分块形式写作\n$$\n\\begin{pmatrix}\n\\mathbf{M} & \\mathbf{D}^\\top \\\\\n\\mathbf{B} & \\mathbf{N}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\boldsymbol{q} \\\\\n\\boldsymbol{u}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{C} \\\\\n\\mathbf{T}\n\\end{pmatrix}\n\\widehat{\\boldsymbol{u}}.\n$$\n此处，向量 $\\boldsymbol{q} \\in \\mathbb{R}^{N_v}$ 和 $\\boldsymbol{u} \\in \\mathbb{R}^{N_w}$ 分别汇集了 $q_h$ 和 $u_h$ 在所选基下的系数，而 $\\widehat{\\boldsymbol{u}}$ 汇集了 $\\widehat{u}_h$ 在 $\\partial \\widehat{T}$ 上的系数。将每个局部矩阵 $\\mathbf{M}$、$\\mathbf{D}$、$\\mathbf{B}$、$\\mathbf{N}$、$\\mathbf{C}$ 和 $\\mathbf{T}$ 用关于所选基的单元或边积分显式写出。然后，对于参考三角形 $\\widehat{T}$ 上 $k=1$ 的情况，计算这些矩阵的尺寸（行数和列数）。\n\n最后，根据您的推导，确定在组装 HDG 局部系统时每个单元的单元局部未知量总数 $N_{\\text{tot}}$，即在 $\\widehat{T}$ 上当 $k=1$ 时拼接向量 $(\\boldsymbol{q}, \\boldsymbol{u}, \\widehat{\\boldsymbol{u}})$ 的维数。将 $N_{\\text{tot}}$ 以一个不带单位的整数形式报告。", "solution": "所述问题具有科学依据，是适定、客观且自洽的。这是数值分析领域，特别是关于有限元方法的一个标准推导。其中没有矛盾、歧义或事实错误。因此，该问题被视为有效，并将提供解答。\n\n该问题要求推导应用于参考三角形 $\\widehat{T}$ 上泊松方程的可杂交间断伽辽金 (HDG) 方法的局部线性系统。控制一阶系统由下式给出：\n$$\n\\boldsymbol{q} + \\nabla u = \\boldsymbol{0} \\quad \\text{in } \\widehat{T}\n$$\n$$\n\\nabla \\cdot \\boldsymbol{q} = f \\quad \\text{in } \\widehat{T}\n$$\n我们已知源项 $f \\equiv 0$，扩散系数为 $1$，多项式阶数为 $k=1$。\n\n单元局部系统的推导通过构造这些方程的弱形式来进行。我们将第一个方程乘以一个向量检验函数 $\\boldsymbol{v} \\in V_h(\\widehat{T})$，第二个方程乘以一个标量检验函数 $w \\in W_h(\\widehat{T})$，并在单元 $\\widehat{T}$ 上积分。\n\n对于第一个方程，我们有：\n$$\n\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} + \\int_{\\widehat{T}} (\\nabla u_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} = 0\n$$\n对第二项应用分部积分（Green 第一恒等式）可得：\n$$\n\\int_{\\widehat{T}} (\\nabla u_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} = -\\int_{\\widehat{T}} u_h (\\nabla \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} u_h (\\boldsymbol{v} \\cdot \\boldsymbol{n}) \\, dS\n$$\n在 HDG 方法中，标量场 $u_h$ 在边界 $\\partial \\widehat{T}$ 上的迹被一个新的独立未知量——数值迹 $\\widehat{u}_h \\in M_h(\\partial \\widehat{T})$ 所取代。将此代入方程，我们得到第一个偏微分方程的弱形式：\n$$\n\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} - \\int_{\\widehat{T}} u_h (\\nabla \\cdot \\boldsymbol{v}) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} \\widehat{u}_h (\\boldsymbol{v} \\cdot \\boldsymbol{n}) \\, dS = 0, \\quad \\forall \\boldsymbol{v} \\in V_h(\\widehat{T})\n$$\n\n对于第二个方程 $\\nabla \\cdot \\boldsymbol{q}_h = 0$，其弱形式为：\n$$\n\\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{q}_h) w \\, d\\boldsymbol{x} = 0\n$$\n应用分部积分可得：\n$$\n-\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\nabla w) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{n}) w \\, dS = 0\n$$\n通量的法向分量 $\\boldsymbol{q}_h \\cdot \\boldsymbol{n}$ 被数值通量 $\\widehat{\\boldsymbol{q}}_h \\cdot \\boldsymbol{n} = \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h)$ 所取代，其中 $\\tau$ 是稳定化参数。这得到了第二个弱形式：\n$$\n-\\int_{\\widehat{T}} (\\boldsymbol{q}_h \\cdot \\nabla w) \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} (\\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h)) w \\, dS = 0, \\quad \\forall w \\in W_h(\\widehat{T})\n$$\n\n为了获得矩阵系统，我们将离散解在其各自的基中展开：\n$\\boldsymbol{q}_h = \\sum_{j=1}^{N_v} q_j \\boldsymbol{\\varphi}_j(\\boldsymbol{x})$，$u_h = \\sum_{j=1}^{N_w} u_j \\phi_j(\\boldsymbol{x})$，以及 $\\widehat{u}_h = \\sum_{j=1}^{N_m} \\widehat{u}_j \\psi_j(\\boldsymbol{x})$。我们依次对每个基函数进行检验。设检验函数为 $\\boldsymbol{v} = \\boldsymbol{\\varphi}_i$ 和 $w = \\phi_i$。\n\n从第一个弱形式方程出发，令 $\\boldsymbol{v} = \\boldsymbol{\\varphi}_i$（对于 $i=1, \\dots, N_v$）：\n$$\n\\sum_{j=1}^{N_v} \\left( \\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{\\varphi}_i \\, d\\boldsymbol{x} \\right) q_j - \\sum_{j=1}^{N_w} \\left( \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_i) \\phi_j \\, d\\boldsymbol{x} \\right) u_j = - \\sum_{j=1}^{N_m} \\left( \\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_i \\cdot \\boldsymbol{n}) \\psi_j \\, dS \\right) \\widehat{u}_j\n$$\n将其与目标系统的第一个分块行 $\\mathbf{M}\\boldsymbol{q} + \\mathbf{D}^\\top\\boldsymbol{u} = \\mathbf{C}\\widehat{\\boldsymbol{u}}$ 进行比较，我们识别出这些矩阵（使用行索引 $i$ 和列索引 $j$）：\n- $\\mathbf{M}_{ij} = \\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{\\varphi}_i \\, d\\boldsymbol{x}$\n- $(\\mathbf{D}^\\top)_{ij} = - \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_i) \\phi_j \\, d\\boldsymbol{x}$\n- $\\mathbf{C}_{ij} = -\\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_i \\cdot \\boldsymbol{n}) \\psi_j \\, dS$\n\n从第二个弱形式方程出发，令 $w = \\phi_i$（对于 $i=1, \\dots, N_w$）：\n$$\n\\sum_{j=1}^{N_v} \\left( -\\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\nabla \\phi_i \\, d\\boldsymbol{x} + \\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{n}) \\phi_i \\, dS \\right) q_j + \\sum_{j=1}^{N_w} \\left( \\int_{\\partial \\widehat{T}} \\tau \\phi_j \\phi_i \\, dS \\right) u_j = \\sum_{j=1}^{N_m} \\left( \\int_{\\partial \\widehat{T}} \\tau \\phi_i \\psi_j \\, dS \\right) \\widehat{u}_j\n$$\n对第一项使用分部积分：$-\\int_{\\widehat{T}} \\boldsymbol{\\varphi}_j \\cdot \\nabla \\phi_i \\, d\\boldsymbol{x} = \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_j) \\phi_i \\, d\\boldsymbol{x} - \\int_{\\partial \\widehat{T}} (\\boldsymbol{\\varphi}_j \\cdot \\boldsymbol{n}) \\phi_i \\, dS$。边界项相互抵消，从而简化了表达式。\n与第二个分块行 $\\mathbf{B}\\boldsymbol{q} + \\mathbf{N}\\boldsymbol{u} = \\mathbf{T}\\widehat{\\boldsymbol{u}}$ 进行比较，我们识别出：\n- $\\mathbf{B}_{ij} = \\int_{\\widehat{T}} (\\nabla \\cdot \\boldsymbol{\\varphi}_j) \\phi_i \\, d\\boldsymbol{x}$\n- $\\mathbf{N}_{ij} = \\int_{\\partial \\widehat{T}} \\tau \\phi_j \\phi_i \\, dS$\n- $\\mathbf{T}_{ij} = \\int_{\\partial \\widehat{T}} \\tau \\phi_i \\psi_j \\, dS$\n\n从这些定义中，我们观察到关系 $\\mathbf{B} = -\\mathbf{D}$，其中矩阵 $\\mathbf{D}$ 是 $\\mathbf{D}^\\top$ 的转置，即 $D_{ji} = (\\mathbf{D}^\\top)_{ij}$。\n\n接下来，我们计算在二维域参考三角形 $\\widehat{T}$ 上，当 $k=1$ 时这些矩阵的尺寸。\n多项式空间 $\\mathcal{P}_k(\\mathbb{R}^d)$ 的维数是 $\\binom{k+d}{d}$。\n- 对于标量空间 $W_h(\\widehat{T}) = \\mathcal{P}_1(\\widehat{T})$，我们有 $d=2, k=1$。其维数为 $N_w = \\binom{1+2}{2} = 3$。\n- 对于向量空间 $V_h(\\widehat{T}) = [\\mathcal{P}_1(\\widehat{T})]^2$，两个分量中的每一个都位于一个 $3$ 维空间中。因此，总维数为 $N_v = 2 \\times 3 = 6$。\n- 对于迹空间 $M_h(\\partial \\widehat{T})$，其边界由 $3$ 条边组成。在每条边 $\\mathcal{F}$（一个一维域）上，空间为 $\\mathcal{P}_1(\\mathcal{F})$。其维数为 $\\binom{1+1}{1} = 2$。由于迹空间是每条边上空间的直和，总维数为 $N_m = 3 \\times 2 = 6$。\n\n这些矩阵的尺寸（行数 $\\times$ 列数）由相应空间的维数决定：\n- $\\mathbf{M}: N_v \\times N_v \\implies 6 \\times 6$\n- $\\mathbf{D}^\\top: N_v \\times N_w \\implies 6 \\times 3$\n- $\\mathbf{B}: N_w \\times N_v \\implies 3 \\times 6$\n- $\\mathbf{N}: N_w \\times N_w \\implies 3 \\times 3$\n- $\\mathbf{C}: N_v \\times N_m \\implies 6 \\times 6$\n- $\\mathbf{T}: N_w \\times N_m \\implies 3 \\times 6$\n\n最后，单元局部未知量的总数 $N_{\\text{tot}}$ 是 $\\boldsymbol{q}_h$、$u_h$ 和 $\\widehat{u}_h$ 的系数数量之和。\n$$\nN_{\\text{tot}} = N_v + N_w + N_m\n$$\n代入 $k=1$ 时计算出的维数：\n$$\nN_{\\text{tot}} = 6 + 3 + 6 = 15\n$$\n这是局部未知量向量 $(\\boldsymbol{q}, \\boldsymbol{u}, \\widehat{\\boldsymbol{u}})$ 的总维数。", "answer": "$$\\boxed{15}$$", "id": "2566501"}, {"introduction": "在理解了局部系统之后，下一步的关键是观察“杂交”或“静态凝聚”过程是如何将这些局部问题耦合成一个全局系统的。本练习使用一个简单的一维问题来演示如何通过代数操作消去单元内部的未知数，从而得到一个仅涉及单元边界上迹变量的全局“骨架”系统。值得注意的是，对于最低阶 ($k=0$) 的情况，这个实践将揭示复杂的 HDG 方法与我们所熟悉的有限差分法之间深刻而直接的联系。[@problem_id:2566544]", "problem": "考虑一维空间中的扩散模型问题：寻找 $u$ 使得在 $(0,L)$ 内有 $- (\\kappa u^{\\prime})^{\\prime} = f$ ，并满足齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(L)=0$，其中 $\\kappa>0$ 是一个常数。将区间离散化为一个由 $N$ 个单元组成的均匀网格，单元大小为 $h = L/N$，节点为 $\\{x_i\\}_{i=0}^{N}$。应用可杂交间断伽辽金 (HDG, hybridizable discontinuous Galerkin) 方法，在每个单元 $K=[x_{i-1},x_i]$ 上对单元未知量使用 $k=0$ 的多项式次数，并在所有面上使用常数稳定化参数 $\\tau>0$。使用一阶系统，其中通量为 $q = -\\kappa u^{\\prime}$，并在 $\\partial K$ 上使用标准的 HDG 数值通量 $\\widehat{q}\\,n = q\\,n + \\tau\\,(u - \\widehat{u})$，其中 $n$ 是外法线，$u$ 和 $q$ 表示单元未知量（在 $K$ 上为常数），而 $\\widehat{u}$ 是定义在网格骨架上的单值迹未知量（每个节点一个标量）。\n\n从每个单元 $K$ 上的 HDG 局部方程出发，\n- $(\\kappa^{-1} q, r)_K - (u, r^{\\prime})_K + \\langle \\widehat{u}, r\\,n \\rangle_{\\partial K} = 0$ 对所有 $K$ 上的常数 $r$ 成立，\n- $-(q, v^{\\prime})_K + \\langle \\widehat{q}\\,n, v \\rangle_{\\partial K} = (f, v)_K$ 对所有 $K$ 上的常数 $v$ 成立，\n并强制执行全局 HDG 传输条件，即每个内部节点处的数值通量 $\\widehat{q}\\,n$ 之和为零，消去单元未知量 $u$ 和 $q$，以获得关于节点迹未知量 $\\{\\widehat{u}_i\\}_{i=1}^{N-1}$ 的凝聚全局（骨架）系统。证明该凝聚骨架系统在内部节点上具有一个三对角三点模板，且该模板与标准的二阶差分模板 $[1,\\,-2,\\,1]$ 成正比。\n\n凝聚骨架刚度矩阵等于标准二阶差分三对角矩阵的 $c$ 倍，其中 $c$ 是什么？请用 $\\kappa$、$h$ 和 $\\tau$ 表示这个精确的比例常数 $c$。请为 $c$ 提供一个单一的闭式解析表达式作为您的答案。", "solution": "我们从 $(0,L)$ 上的扩散方程 $- (\\kappa u^{\\prime})^{\\prime} = f$ 和齐次 Dirichlet 边界条件 $u(0)=0$、$u(L)=0$ 开始。引入一阶系统\n$$\nq = -\\kappa u^{\\prime}, \\qquad -q^{\\prime} = f.\n$$\n在均匀网格上使用多项式次数 $k=0$ 的可杂交间断伽辽金 (HDG, hybridizable discontinuous Galerkin) 方法中，单元未知量 $(q,u)$ 在每个长度为 $h$ 的单元 $K=[x_{i-1},x_i]$ 上是常数，而迹 $\\widehat{u}$ 是每个节点 $x_i$ 上的单个标量。数值通量为\n$$\n\\widehat{q}\\,n = q\\,n + \\tau\\,(u - \\widehat{u}) \\quad \\text{on } \\partial K,\n$$\n其中稳定化参数 $\\tau>0$ 是常数。\n\n令 $(\\cdot,\\cdot)_K$ 表示 $K$ 上的 $L^2$ 内积，$\\langle \\cdot, \\cdot \\rangle_{\\partial K}$ 表示在两个单元面上的求和。由于 $k=0$，测试函数 $r$ 和 $v$ 在 $K$ 上是常数，因此 $r^{\\prime} = 0$ 和 $v^{\\prime} = 0$。$K$ 单元上的局部 HDG 方程简化为：\n$$\n(\\kappa^{-1} q, r)_K + \\langle \\widehat{u}, r\\,n \\rangle_{\\partial K} = 0, \\qquad \\langle \\widehat{q}\\,n, v \\rangle_{\\partial K} = (f, v)_K,\n$$\n对所有常数 $r$ 和 $v$ 成立。取 $r=1$ 和 $v=1$，并使用 $(\\kappa^{-1} q, 1)_K = \\kappa^{-1} q\\, h$ 和 $(f,1)_K = \\bar{f}_K\\, h$，其中 $\\bar{f}_K$ 是 $f$ 在 $K$ 上的单元平均值，并将左右端点处的节点迹值分别表示为 $\\widehat{u}_{i-1}$ 和 $\\widehat{u}_{i}$，我们得到：\n$$\n\\kappa^{-1} q\\, h + \\big(\\widehat{u}_i \\cdot (+1) + \\widehat{u}_{i-1} \\cdot (-1)\\big) = 0,\n$$\n即，\n$$\nq = -\\kappa\\,\\frac{\\widehat{u}_i - \\widehat{u}_{i-1}}{h}.\n$$\n对于第二个局部方程，我们对两个面上的数值通量贡献求和。在 $x_{i-1}$ 处单位外法线为 $n=-1$，在 $x_i$ 处为 $n=+1$，并在每个面上使用 $\\widehat{q}\\,n = q\\,n + \\tau (u - \\widehat{u})$，我们得到：\n$$\n\\langle \\widehat{q}\\,n, 1 \\rangle_{\\partial K}\n= \\big[q\\cdot(+1) + \\tau\\,(u - \\widehat{u}_i)\\big] + \\big[q\\cdot(-1) + \\tau\\,(u - \\widehat{u}_{i-1})\\big]\n= \\tau\\,[2u - (\\widehat{u}_i + \\widehat{u}_{i-1})].\n$$\n令其等于 $(f,1)_K = \\bar{f}_K h$ 得到局部关系式\n$$\n\\tau\\,[2u - (\\widehat{u}_i + \\widehat{u}_{i-1})] = \\bar{f}_K\\, h,\n$$\n因此\n$$\nu = \\frac{1}{2}\\,(\\widehat{u}_i + \\widehat{u}_{i-1}) + \\frac{h}{2\\tau}\\,\\bar{f}_K.\n$$\n\n现在，我们在每个内部节点 $x_i$ 上施加全局 HDG 传输条件，即跨该节点的相邻单元的数值通量之和为零：\n$$\n\\big(\\widehat{q}\\,n\\big)\\big|_{K_{L},\\,\\text{right face at }x_i} + \\big(\\widehat{q}\\,n\\big)\\big|_{K_{R},\\,\\text{left face at }x_i} = 0,\n$$\n其中 $K_L=[x_{i-1},x_i]$，$K_R=[x_i,x_{i+1}]$。在 $K_L$ 上使用先前导出的局部表达式，其中 $q_L = -\\kappa(\\widehat{u}_i - \\widehat{u}_{i-1})/h$ 且 $u_L = \\tfrac{1}{2}(\\widehat{u}_i + \\widehat{u}_{i-1}) + \\tfrac{h}{2\\tau}\\,\\bar{f}_{L}$，则来自 $K_L$ 右侧面的数值通量为\n$$\n\\big(\\widehat{q}\\,n\\big)_{K_L,\\text{ right}} = q_L\\cdot(+1) + \\tau\\,(u_L - \\widehat{u}_i)\n= -\\frac{\\kappa}{h}\\,(\\widehat{u}_i - \\widehat{u}_{i-1}) + \\frac{\\tau}{2}\\,(\\widehat{u}_{i-1} - \\widehat{u}_i) + \\frac{h}{2}\\,\\bar{f}_L.\n$$\n类似地，在 $K_R$ 上，其中 $q_R = -\\kappa(\\widehat{u}_{i+1} - \\widehat{u}_i)/h$ 且 $u_R = \\tfrac{1}{2}(\\widehat{u}_{i+1} + \\widehat{u}_{i}) + \\tfrac{h}{2\\tau}\\,\\bar{f}_{R}$，则来自左侧面的数值通量为\n$$\n\\big(\\widehat{q}\\,n\\big)_{K_R,\\text{ left}} = q_R\\cdot(-1) + \\tau\\,(u_R - \\widehat{u}_i)\n= \\frac{\\kappa}{h}\\,(\\widehat{u}_{i+1} - \\widehat{u}_i) + \\frac{\\tau}{2}\\,(\\widehat{u}_{i+1} - \\widehat{u}_i) + \\frac{h}{2}\\,\\bar{f}_R.\n$$\n将两者相加并令结果为零，得到内部节点 $x_i$ 处的凝聚全局方程：\n$$\n\\Big(\\frac{\\kappa}{h} + \\frac{\\tau}{2}\\Big)\\,\\widehat{u}_{i-1} - \\Big(2\\,\\frac{\\kappa}{h} + \\tau\\Big)\\,\\widehat{u}_{i} + \\Big(\\frac{\\kappa}{h} + \\frac{\\tau}{2}\\Big)\\,\\widehat{u}_{i+1}\n= -\\frac{h}{2}\\,(\\bar{f}_L + \\bar{f}_R).\n$$\n观察到左手边可以因式分解为\n$$\n\\Big(\\frac{\\kappa}{h} + \\frac{\\tau}{2}\\Big)\\,\\big(\\widehat{u}_{i-1} - 2\\,\\widehat{u}_i + \\widehat{u}_{i+1}\\big),\n$$\n因为 $- \\big(2\\,\\tfrac{\\kappa}{h} + \\tau\\big) = -2 \\big(\\tfrac{\\kappa}{h} + \\tfrac{\\tau}{2}\\big)$。因此，内部节点上的凝聚骨架刚度矩阵恰好是带有模板 $[1,\\,-2,\\,1]$ 的标准二阶差分三对角矩阵的常数倍。\n\n因此，使得凝聚骨架矩阵等于标准二阶差分矩阵 $c$ 倍的比例常数 $c$ 是\n$$\nc = \\frac{\\kappa}{h} + \\frac{\\tau}{2}.\n$$\n该常数与源项 $f$ 无关，仅取决于 $\\kappa$、$h$ 和稳定化参数 $\\tau$。", "answer": "$$\\boxed{\\frac{\\kappa}{h}+\\frac{\\tau}{2}}$$", "id": "2566544"}, {"introduction": "从理论走向实践，这最后一个练习旨在解决在并行计算机上实现 HDG 方法的现实挑战。您将设计并思考一种算法，该算法使用消息传递接口 (MPI) 在分布式内存环境中高效地组装全局骨架系统。这个实践强调了数据依赖性、所有权规则和通信模式，这些都是开发可扩展的高性能科学计算代码所必需的关键技能。[@problem_id:2566516]", "problem": "构建一个可实现的算法，用以在多个消息传递接口（MPI）进程上并行化可杂交间断伽辽金 (HDG) 方法中的局部静态凝聚和骨架集成，并为共享面指定显式的通信模式。请从 Galerkin 有限元集成的基本属性出发，即单元贡献是可加的，且杂交（静态凝聚）通过消除内部未知量以获得在迹（骨架）未知量上的 Schur 补。具体而言，假定以下基本事实：(i) 对每个单元 $K$，局部消除内部未知量以产生面局部贡献，这些贡献进入单元级迹上的 Schur 补算子；(ii) 骨架上的全局集成是每个面上所有相邻单元的贡献之和；在区域分解下，仅当面与位于不同 MPI 进程上的单元相邻时才需要通信。\n\n您必须完成以下所有任务。\n\n1) 从第一性原理推导出一个算法流程，该流程：\n- 在每个 MPI 进程上，为该进程拥有的所有单元独立执行局部求解。\n- 对于可能位于不同进程上的两个单元共享的每个面，确定一个唯一的面所有者进程，并规定一种邻居聚合通信模式，其中对于每对进程 $(r_{\\text{src}}, r_{\\text{dst}})$，所有从 $r_{\\text{src}}$ 发往 $r_{\\text{dst}}$ 的面贡献被打包到单个消息中，并按全局面标识符递增排序。\n- 在每个面的所有者进程上，通过将接收到的贡献与任何本地贡献相加来集成最终的面块。\n\n2) 实现一个程序，在给定下文抽象描述的离散化的情况下，为每个测试用例计算两个可测量的量：\n- 全局集成的骨架算子限制在对角面块上的 Frobenius 范数，定义如下。对于每个具有 $m$ 个迹自由度的面 $f$，令 $S^{(e)}_{ff} \\in \\mathbb{R}^{m \\times m}$ 表示来自与 $f$ 相邻的单元 $e$ 的局部面块贡献。面 $f$ 的集成面块为 $S_{f} = \\sum_{e \\in \\mathcal{N}(f)} S^{(e)}_{ff}$，其中 $\\mathcal{N}(f)$ 是与面 $f$ 相邻的单元集合。考虑块对角矩阵 $S = \\operatorname{diag}(S_{0}, S_{1}, \\dots, S_{F-1}) \\in \\mathbb{R}^{(mF) \\times (mF)}$，其中 $F$ 是面的数量。输出 $S$ 的 Frobenius 范数 $\\|S\\|_{F}$。\n- 在上述邻居聚合规则下，通过所有消息发送的浮点标量（双精度浮点数）数量来衡量的总通信量。每个源自非所有者进程上的单元 $e$ 并发送至面 $f$ 的所有者进程的贡献 $S^{(e)}_{ff}$，会为通信量增加 $m^{2}$ 个双精度浮点数。令 $M$ 为不同邻居聚合消息的数量（即具有非零负载的不同有序进程对的数量）。您还必须计算 $M$。\n\n3) 为使问题自洽且纯粹算法化，局部 Schur 面块贡献 $S^{(e)}_{ff}$ 应通过以下规则确定性地生成，该规则模拟了由消元产生的对称正定面块：\n- 对于面 $f$ 和相邻单元 $e$，定义向量 $v \\in \\mathbb{R}^{m}$，其分量为 $v_{i} = (e+1) + 0.1\\,(f+1) + 0.01\\,(i+1)$，其中 $i=0,\\dots,m-1$，并设置 $\\alpha = 1.0 + \\big((e + 2f) \\bmod 3\\big)$。则\n$$\nS^{(e)}_{ff} \\;=\\; \\alpha I_{m} + v v^{\\top},\n$$\n其中 $I_{m}$ 是 $m \\times m$ 单位矩阵。此定义确保了对称性和正定性，无需任何偏微分方程的细节，并且与可加的面集成一致。\n\n4) 通信和所有权规则：\n- 每个面 $f$ 都有一个唯一的宿主进程 $r_{\\text{own}}(f)$，从其相邻单元的进程集合中选择。如果与面 $f$ 相邻的单元 $e$ 位于进程 $r(e)$ 上，且 $r(e) \\neq r_{\\text{own}}(f)$，则其贡献 $S^{(e)}_{ff}$ 必须从 $r(e)$ 发送到 $r_{\\text{own}}(f)$。\n- 邻居聚合消息传递规定，对于每个有序对 $(r_{\\text{src}}, r_{\\text{dst}})$，只发送一条消息，其中包含所有满足 $r(e)=r_{\\text{src}}$ 和 $r_{\\text{own}}(f)=r_{\\text{dst}}$ 条件的所需贡献 $S^{(e)}_{ff}$ 的串联，并按全局面标识符 $f$ 递增排序。\n\n5) 测试套件。您的程序必须硬编码并执行以下三个测试用例。在每个用例中，您应计算并输出 Frobenius 范数 $\\|S\\|_{F}$、消息数量 $M$ 以及发送的双精度浮点数总数 $V$。\n\n- 测试用例 A（含一个跨进程面的链式结构）：\n    - 进程数：$R=2$。\n    - 单元数：$E=3$，单元 $e=0,1,2$ 的进程所有权分别为 $[0,0,1]$。\n    - 面数：$F=4$，邻接关系和所有者进程如下：\n        - 面 $f=0$：相邻单元 $[0]$，所有者进程 $0$。\n        - 面 $f=1$：相邻单元 $[0,1]$，所有者进程 $0$。\n        - 面 $f=2$：相邻单元 $[1,2]$，所有者进程 $1$。\n        - 面 $f=3$：相邻单元 $[2]$，所有者进程 $1$。\n    - 每个面的迹自由度：$m=2$。\n\n- 测试用例 B（含两个跨进程面的多进程链式结构）：\n    - 进程数：$R=3$。\n    - 单元数：$E=4$，单元 $e=0,1,2,3$ 的进程所有权分别为 $[0,1,1,2]$。\n    - 面数：$F=6$，邻接关系和所有者进程如下：\n        - 面 $f=0$：相邻单元 $[0]$，所有者进程 $0$。\n        - 面 $f=1$：相邻单元 $[0,1]$，所有者进程 $0$。\n        - 面 $f=2$：相邻单元 $[1]$，所有者进程 $1$。\n        - 面 $f=3$：相邻单元 $[1,2]$，所有者进程 $1$。\n        - 面 $f=4$：相邻单元 $[2,3]$，所有者进程 $2$。\n        - 面 $f=5$：相邻单元 $[3]$，所有者进程 $2$。\n    - 每个面的迹自由度：$m=3$。\n\n- 测试用例 C（无跨进程面）：\n    - 进程数：$R=2$。\n    - 单元数：$E=3$，单元 $e=0,1,2$ 的进程所有权分别为 $[0,0,1]$。\n    - 面数：$F=4$，邻接关系和所有者进程如下：\n        - 面 $f=0$：相邻单元 $[0]$，所有者进程 $0$。\n        - 面 $f=1$：相邻单元 $[0,1]$，所有者进程 $0$。\n        - 面 $f=2$：相邻单元 $[1]$，所有者进程 $0$。\n        - 面 $f=3$：相邻单元 $[2]$，所有者进程 $1$。\n    - 每个面的迹自由度：$m=1$。\n\n6) 最终输出格式。您的程序必须生成单行输出，其中包含一个扁平列表，按 A、B、C 的顺序为每个测试用例包含三元组 $[\\|S\\|_{F}, M, V]$，并将这些三元组串联起来。具体而言，打印单行格式\n\"[$x_{A},y_{A},z_{A},x_{B},y_{B},z_{B},x_{C},y_{C},z_{C}$]\"\n其中 $x_{\\bullet}$ 是作为浮点数的 Frobenius 范数 $\\|S\\|_{F}$，$y_{\\bullet}$ 是作为整数的消息数 $M$，$z_{\\bullet}$ 是作为整数的双精度浮点数数量 $V$。\n\n不涉及角度，也没有物理单位。所有输出都是纯数字。\n\n您的程序必须自成一体，不需任何输入，并严格遵守所述的通信和集成规则。您的算法和实现不得假定超出此处定义的结构，不得使用任何外部文件或网络，也不得依赖执行环境中指定范围之外的库。", "solution": "所提出的问题是为混合化间断 Galerkin (HDG) 方法的骨架矩阵集成阶段构建并实现一个并行算法。该问题定义明确、科学上合理且内部一致。它为单元级贡献提供了一个抽象而形式化的框架，并为进程间通信规定了清晰的方案，从而可以得出一个严谨的算法解。我们将从第一性原理出发推导该算法，然后进行实现。\n\n有限元集成的基本原理是将一个全局算子分解为网格 $\\mathcal{T}_h$ 中每个单元 $K$ 的局部贡献之和。对于 HDG 方法，在对每个单元内部的未知量进行局部静态凝聚之后，我们得到一个关于网格骨架 $\\mathcal{F}_h$ 的面上解的迹相关自由度的系统。全局骨架算子 $S$ 是通过对相邻单元的贡献求和来集成的。也就是说，对于每个面 $f \\in \\mathcal{F}_h$，全局系统中对应的块 $S_f$ 由下式给出：\n$$\nS_{f} = \\sum_{e \\in \\mathcal{N}(f)} S^{(e)}_{ff}\n$$\n其中 $\\mathcal{N}(f)$ 是与面 $f$ 相邻的单元集合，$S^{(e)}_{ff}$ 是由单元 $e$ 上的局部求解产生的对该面块 $S_f$ 的贡献。\n\n在一个带有区域分解的并行环境中，单元集合 $\\mathcal{T}_h$被划分到 $R$ 个消息传递接口 (MPI) 进程中。令 $r(e)$ 表示拥有单元 $e$ 的进程。当一个面 $f$ 位于不同进程所拥有的单元边界上时，通信就成为必需。问题陈述指出，每个面 $f$ 都有一个唯一的所有者进程 $r_{\\text{own}}(f)$，它负责集成最终的块 $S_f$。\n\n基于这些原理，我们为并行集成推导出以下算法流程。\n\n**步骤 1：Schur 补贡献的局部计算**\n\n这第一阶段是易于并行的。每个 MPI 进程 $r \\in \\{0, \\dots, R-1\\}$ 遍历其拥有的所有单元 $e$ （即满足 $r(e) = r$ 的单元）。对于每个这样的单元 $e$，该进程识别所有与其相邻的面 $f$。对于每对 $(e,f)$，它计算局部贡献矩阵 $S^{(e)}_{ff} \\in \\mathbb{R}^{m \\times m}$。此计算由问题陈述定义为：\n$$\nS^{(e)}_{ff} = \\alpha I_{m} + v v^{\\top}\n$$\n其中 $I_m$ 是 $m \\times m$ 单位矩阵，$\\alpha = 1.0 + \\big((e + 2f) \\bmod 3\\big)$，向量 $v \\in \\mathbb{R}^{m}$ 的分量为 $v_{i} = (e+1) + 0.1(f+1) + 0.01(i+1)$，其中 $i \\in \\{0, \\dots, m-1\\}$。这些局部计算出的矩阵存储在计算它们的进程的内存中。\n\n**步骤 2：通信规划与数据交换**\n\n局部计算完成后，每个进程必须确定哪些计算出的贡献需要发送给其他进程。\n\n对于每个进程 $r_{\\text{src}} \\in \\{0, \\dots, R-1\\}$：\n1.  初始化一个通信伙伴集合，$\\text{Partners}_{\\text{send}} = \\emptyset$。\n2.  初始化用于缓冲出站消息的数据结构，例如一个以目标进程为键的字典 `send_buffers`。\n3.  遍历每个本地拥有的单元 $e$ (其中 $r(e) = r_{\\text{src}}$) 及其每个相邻的面 $f$。\n4.  获取该面的所有者进程 $r_{\\text{dst}} = r_{\\text{own}}(f)$。\n5.  如果 $r_{\\text{src}} \\neq r_{\\text{dst}}$，则贡献 $S^{(e)}_{ff}$ 必须被通信。该贡献被标记为发送到进程 $r_{\\text{dst}}$。序对 $(r_{\\text{src}}, r_{\\text{dst}})$ 被添加到一个全局通信序对集合中，该集合将用于确定总消息数 $M$。待发送数据的大小，$m \\times m$ 个浮点数，被加到总通信量 $V$ 中。\n6.  遵循邻居聚合消息传递规则，所有从 $r_{\\text{src}}$ 到 $r_{\\text{dst}}$ 的贡献被打包到单个消息缓冲区中。问题陈述指出，这些贡献（即矩阵 $S^{(e)}_{ff}$）按全局面标识符 $f$ 递增排序。\n\n这个规划阶段确定了完整的通信模式。随后，在一个实际的 MPI 实现中，各进程将执行非阻塞发送和接收 (`MPI_Isend`, `MPI_Irecv`)，然后执行等待 (`MPI_Waitall`) 来确保所有数据都已交换。\n\n**步骤 3：在所有者进程上进行全局集成**\n\n每个进程 $r \\in \\{0, \\dots, R-1\\}$ 负责为其拥有的所有面 $f$（即 $r_{\\text{own}}(f) = r$ 的面）集成最终的矩阵 $S_f$。\n\n对于每个进程 $r_{\\text{own}} \\in \\{0, \\dots, R-1\\}$：\n1.  为所有满足 $r_{\\text{own}}(f) = r_{\\text{own}}$ 的面 $f$ 初始化空矩阵 $S_f = 0 \\in \\mathbb{R}^{m \\times m}$。\n2.  处理本地贡献：对于进程 $r_{\\text{own}}$ 拥有的每个面 $f$，以及同样由 $r_{\\text{own}}$ 拥有的每个相邻单元 $e$（即 $r(e) = r_{\\text{own}}$），添加本地存储的贡献：$S_f \\leftarrow S_f + S^{(e)}_{ff}$。\n3.  处理远程贡献：对于每个其他进程 $r_{\\text{src}}$，解包接收到的消息缓冲区（如果有的话）。对于缓冲区中的每个贡献 $S^{(e)}_{ff}$（与一个面标识符 $f$ 相关联），将其加到对应的矩阵中：$S_f \\leftarrow S_f + S^{(e)}_{ff}$。\n\n此步骤之后，每个矩阵 $S_f$ 都已完全集成并驻留在其所有者进程 $r_{\\text{own}}(f)$ 上。\n\n**步骤 4：输出量的计算**\n\n最后一步是根据集成的系统和通信计划计算所需的度量。我们的实现将串行地模拟此逻辑。\n\n1.  **总通信量 ($V$) 和消息数 ($M$)**: 这些在步骤 2 中确定。\n    -   $V$ 是所有跨进程边界的矩阵大小之和：$V = \\sum_{r(e) \\neq r_{\\text{own}}(f)} m^2$。\n    -   $M$ 是至少发送一个矩阵的唯一有序对 $(r_{\\text{src}}, r_{\\text{dst}})$ 的总数。\n\n2.  **Frobenius 范数 ($\\|S\\|_F$):** 全局矩阵 $S$ 是块对角的，$S = \\operatorname{diag}(S_{0}, S_{1}, \\dots, S_{F-1})$，其中 $F$ 是面的总数。Frobenius 范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |a_{ij}|^2}$。对于块对角矩阵，这简化为对角块范数平方和的平方根：\n    $$\n    \\|S\\|_{F} = \\sqrt{\\sum_{f=0}^{F-1} \\|S_f\\|_F^2}\n    $$\n    在并行计算中，每个进程 $r$ 将计算其所拥有面的范数平方和 $\\sum_{f: r_{\\text{own}}(f)=r} \\|S_f\\|_F^2$。然后使用全局归约操作（带有 `MPI_SUM` 算子的 `MPI_Allreduce`）来计算所有进程的总和。最终结果是该全局总和的平方根。\n\n我们的实现将为每个测试用例执行这些步骤，以产生所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for all test cases.\n    It defines test cases, runs the simulation for each, and prints the result.\n    \"\"\"\n\n    # Test Case A\n    case_A = {\n        \"name\": \"A\",\n        \"num_ranks\": 2,\n        \"num_elements\": 3,\n        \"element_ranks\": [0, 0, 1],\n        \"num_faces\": 4,\n        \"face_adjacencies\": [[0], [0, 1], [1, 2], [2]],\n        \"face_owners\": [0, 0, 1, 1],\n        \"m\": 2,\n    }\n\n    # Test Case B\n    case_B = {\n        \"name\": \"B\",\n        \"num_ranks\": 3,\n        \"num_elements\": 4,\n        \"element_ranks\": [0, 1, 1, 2],\n        \"num_faces\": 6,\n        \"face_adjacencies\": [[0], [0, 1], [1], [1, 2], [2, 3], [3]],\n        \"face_owners\": [0, 0, 1, 1, 2, 2],\n        \"m\": 3,\n    }\n\n    # Test Case C\n    case_C = {\n        \"name\": \"C\",\n        \"num_ranks\": 2,\n        \"num_elements\": 3,\n        \"element_ranks\": [0, 0, 1],\n        \"num_faces\": 4,\n        \"face_adjacencies\": [[0], [0, 1], [1], [2]],\n        \"face_owners\": [0, 0, 0, 1],\n        \"m\": 1,\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    final_results = []\n\n    for case in test_cases:\n        norm_S_F, M, V = compute_hdg_assembly(case)\n        final_results.extend([norm_S_F, M, V])\n\n    # Format and print the final output as a single-line list.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\ndef compute_hdg_assembly(case):\n    \"\"\"\n    Simulates the HDG skeleton assembly for a single test case.\n    \n    Args:\n        case (dict): A dictionary containing all parameters for the test case.\n        \n    Returns:\n        tuple: A tuple containing (Frobenius norm, number of messages, communication volume).\n    \"\"\"\n\n    # Extract parameters from the case dictionary\n    num_elements = case[\"num_elements\"]\n    num_faces = case[\"num_faces\"]\n    m = case[\"m\"]\n    element_ranks = case[\"element_ranks\"]\n    face_adjacencies = case[\"face_adjacencies\"]\n    face_owners = case[\"face_owners\"]\n\n    # Step 1: Local Computation of Schur Complement Contributions\n    # We store all contributions in a dictionary for easy lookup.\n    # The key is a tuple (element_id, face_id).\n    local_contributions = {}\n    \n    # In a real scenario, each rank computes only its own elements.\n    # Here, we simulate this by iterating through all elements and their faces.\n    for e in range(num_elements):\n        # Find all faces adjacent to element e\n        adjacent_faces = [f for f, adj_elems in enumerate(face_adjacencies) if e in adj_elems]\n        for f in adjacent_faces:\n            # Generate the local contribution matrix S^(e)_(ff)\n            v = np.array([(e + 1) + 0.1 * (f + 1) + 0.01 * (i + 1) for i in range(m)])\n            alpha = 1.0 + ((e + 2 * f) % 3)\n            S_eff = alpha * np.identity(m) + np.outer(v, v)\n            local_contributions[(e, f)] = S_eff\n\n    # Step 2 & 3: Communication Planning and Global Assembly\n    # We simulate the assembly process on the owner ranks.\n    \n    # Initialize storage for the final assembled face blocks\n    assembled_face_blocks = [np.zeros((m, m)) for _ in range(num_faces)]\n    \n    # Initialize communication metrics\n    comm_volume = 0\n    comm_pairs = set()\n\n    # Iterate through all faces to assemble them\n    for f in range(num_faces):\n        owner_rank = face_owners[f]\n        adjacent_elements = face_adjacencies[f]\n        \n        for e in adjacent_elements:\n            src_rank = element_ranks[e]\n            contribution = local_contributions[(e, f)]\n            \n            # If element rank is not the face owner rank, communication is required\n            if src_rank != owner_rank:\n                comm_volume += m * m\n                comm_pairs.add((src_rank, owner_rank))\n            \n            # The owner rank adds the contribution (whether local or received)\n            assembled_face_blocks[f] += contribution\n            \n    num_messages = len(comm_pairs)\n\n    # Step 4: Computation of Final Quantities\n    \n    # Calculate Frobenius norm of the block-diagonal matrix S\n    sum_sq_norms = 0.0\n    for S_f in assembled_face_blocks:\n        sum_sq_norms += np.linalg.norm(S_f, 'fro')**2\n    \n    norm_S_F = np.sqrt(sum_sq_norms)\n    \n    return norm_S_F, num_messages, comm_volume\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2566516"}]}