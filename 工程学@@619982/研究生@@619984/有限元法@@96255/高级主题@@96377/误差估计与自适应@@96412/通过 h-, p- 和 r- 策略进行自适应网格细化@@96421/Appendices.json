{"hands_on_practices": [{"introduction": "本实践将引导您探索自适应网格剖分的核心思想。通过分析一个具有边界层特征的一维模型问题，您将亲手推导并实现一个基于插值误差理论的最优网格密度准则[@problem_id:2540459]。这个练习旨在帮助您量化理解 $r$-自适应（节点移动）与 $h$-自适应（单元加密）在有限的计算资源下达到目标精度时的能力与局限。", "problem": "考虑单位区间 $[0,1]$ 上的一个一维边界层原型，由光滑函数 $u(x) = 1 - \\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$ 给出，其中 $\\varepsilon \\in (0,1]$ 控制了 $x=1$ 附近的边界层厚度。我们通过两种策略来分析分片线性有限元的自适应网格加密：$r$-自适应（节点移动，单元数量固定）和 $h$-自适应（插入单元，即增加单元数量），同时保持多项式次数不变。假设通常的有限元插值误差理论适用于本性上确界范数 $L^\\infty$ 中的 $C^2$ 函数。\n\n从以下公认的基础出发：\n- 长度为 $h$ 的单元上的分片线性插值误差满足不等式 $\\|u - I_h u\\|_{L^\\infty(\\text{element})} \\le C_I \\,\\max_{x \\text{ in element}} |u''(x)|\\, h^2$，其中常数 $C_I = \\dfrac{1}{8}$，$I_h u$ 表示局部线性插值函数。\n- 标量监控函数的 $r$-自适应均分原理指出，为了在固定单元预算下最小化所有单元上的最大插值误差，应选择一个与二阶导数大小的平方根成反比的网格密度，即单元尺寸 $h(x)$ 满足 $|u''(x)|\\, h(x)^2 \\approx \\text{常数}$。\n- 边界层函数满足 $u''(x) = \\dfrac{1}{\\varepsilon^2}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$，该函数为正，并且在远离 $x=1$ 时呈指数衰减。\n\n您的任务是：\n1. 从插值误差界和均分原理出发，推导在最优自适应网格下，确保全局 $L^\\infty$ 插值误差不超过目标容差 $\\tau > 0$ 所需的最小单元数 $n_\\star$ 的一个估计。用 $\\varepsilon$、$\\tau$ 和 $C_I$ 表示 $n_\\star$。\n2. 对于具有固定单元预算 $n_0 \\in \\mathbb{N}$ 的 $r$-自适应，确定仅通过节点移动（不改变连接性或单元数量）是否能满足容差 $\\tau$。当且仅当 $n_0 \\ge n_\\star$ 时，此条件成立。\n3. 通过计算在指定的正参数 $\\Lambda$ 下，应位于末端子区间 $[1 - \\Lambda \\varepsilon, 1]$ 内的单元分数 $f_{\\Lambda}$，来量化最优均分所要求的边界层附近的单元集中程度。将此解释为最优网格密度在 $[1 - \\Lambda \\varepsilon, 1]$ 上的积分与在 $[0,1]$ 上的积分之比。\n\n您必须实现一个程序，该程序：\n- 使用您推导的表达式计算 $n_\\star$（向上取整）。\n- 确定 $r$-自适应是否成功的布尔指标，如果 $n_0 \\ge n_\\star$ 则为 $1$，否则为 $0$。\n- 计算 $f_{\\Lambda}$ 并将其四舍五入到 $6$ 位小数。\n\n您的实现应针对给定的 $u(x)$ 进行专门化，并且仅使用下面指定的数据。对于这个 $u(x)$，基于均分的最优单元密度与 $\\sqrt{|u''(x)|}$ 成正比，您的程序应使用这一事实来精确计算 $f_{\\Lambda}$。答案必须是无量纲的。\n\n测试套件：\n- 情况 1：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.05, 10^{-2}, 40, 4)$。\n- 情况 2：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.005, 10^{-4}, 50, 5)$。\n- 情况 3：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.5, 10^{-2}, 5, 1)$。\n- 情况 4：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.001, 5\\times 10^{-3}, 8, 3)$。\n- 情况 5：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.02, 2\\times 10^{-3}, 30, 4)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，顺序与上面相同。\n- 每个条目必须是 $[n_\\star, s, f_{\\Lambda}]$ 形式的列表，其中 $n_\\star$ 是一个整数，$s \\in \\{0,1\\}$ 表示仅靠 $r$-自适应是否成功，$f_{\\Lambda}$ 是一个四舍五入到 $6$ 位小数的浮点数。\n- 输出必须打印为单行，不含额外文本，条目之间用逗号分隔并置于方括号内。例如，一个有效的形式是 $[[n_\\star^{(1)},s^{(1)},f_{\\Lambda}^{(1)}],[n_\\star^{(2)},s^{(2)},f_{\\Lambda}^{(2)}],\\dots]$。", "solution": "我们处理在 $[0,1]$ 上的特定边界层剖面 $u(x) = 1 - \\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$，其中 $\\varepsilon \\in (0,1]$。其导数为\n$$\nu'(x) = \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right),\\quad\nu''(x) = \\dfrac{1}{\\varepsilon^2}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right).\n$$\n在长度为 $h_K$ 的单元 $K$ 上的分片线性插值误差界为\n$$\n\\|u - I_h u\\|_{L^\\infty(K)} \\le C_I \\big(\\max_{x\\in K} |u''(x)|\\big)\\, h_K^2,\n$$\n其中 $C_I = \\dfrac{1}{8}$，这是一个可从线性插值的 Peano 核推导出的经典结果。$r$-自适应的最优性原理（均分）旨在选择单元尺寸 $\\{h_K\\}$，以使各单元对误差的贡献均等。在一维情况下，对于定义域上的连续网格尺寸函数 $h(x)$，这对应于强制执行\n$$\nC_I\\, |u''(x)|\\, h(x)^2 \\approx \\tau_e,\n$$\n其中 $\\tau_e$ 是目标均等化单元误差，使得全局 $L^\\infty$ 误差不超过预设的容差 $\\tau > 0$。当所有单元共享相同的界 $C_I |u''| h^2 = \\tau_e$ 时，网格上的全局最大值不超过 $\\tau_e$，因此为了保守设计，我们可以设置 $\\tau_e = \\tau$。求解 $h(x)$ 可得\n$$\nh(x) = \\sqrt{\\dfrac{\\tau}{C_I}}\\, |u''(x)|^{-1/2}.\n$$\n与此连续网格尺寸相关的总单元数 $n$ 是定义域的路径长度除以局部尺寸：\n$$\nn \\approx \\int_{0}^{1} \\dfrac{dx}{h(x)} = \\sqrt{\\dfrac{C_I}{\\tau}} \\int_{0}^{1} \\sqrt{|u''(x)|}\\, dx.\n$$\n因此，能够达到容差的最小单元数的一个估计是\n$$\nn_\\star = \\left\\lceil \\sqrt{\\dfrac{C_I}{\\tau}} \\int_{0}^{1} \\sqrt{|u''(x)|}\\, dx \\right\\rceil.\n$$\n对于我们的 $u(x)$，我们有 $|u''(x)| = \\dfrac{1}{\\varepsilon^2}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$，因此\n$$\n\\sqrt{|u''(x)|} = \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{1-x}{2\\varepsilon}\\right).\n$$\n该积分可以被精确计算：\n$$\n\\int_{0}^{1} \\sqrt{|u''(x)|}\\, dx = \\int_{0}^{1} \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{1-x}{2\\varepsilon}\\right) dx.\n$$\n通过换元 $y = 1-x$, $dy = -dx$，积分变为\n$$\n\\int_{y=1}^{0} \\dfrac{1}{\\varepsilon} \\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right) (-dy) = \\int_{0}^{1} \\dfrac{1}{\\varepsilon} \\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right) dy = \\left[-2 \\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right)\\right]_{0}^{1} = 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right).\n$$\n因此，\n$$\nn_\\star = \\left\\lceil \\sqrt{\\dfrac{C_I}{\\tau}} \\cdot 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right) \\right\\rceil,\n$$\n其中 $C_I = \\dfrac{1}{8}$。这个 $n_\\star$ 是最优重分布下 $h$-自适应和 $r$-自适应的基准：$h$-自适应可以通过增加单元数直至至少达到 $n_\\star$ 来满足容差，而当且仅当可用单元数 $n_0$ 满足 $n_0 \\ge n_\\star$ 时，$r$-自适应才能在不改变单元数的情况下满足容差。\n\n为量化边界层附近的网格集中程度，请注意最优单元密度与 $\\sqrt{|u''(x)|}$ 成正比。令 $\\rho(x) = \\sqrt{|u''(x)|}$ 并定义\n$$\nI_{\\text{tot}}(\\varepsilon) = \\int_{0}^{1} \\rho(x)\\, dx = 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right).\n$$\n预期在末端子区间 $[1 - \\Lambda \\varepsilon, 1]$ 内的单元分数为\n$$\nf_{\\Lambda} = \\dfrac{\\int_{1-\\Lambda \\varepsilon}^{1} \\rho(x)\\, dx}{\\int_{0}^{1} \\rho(x)\\, dx}.\n$$\n使用相同的换元 $y=1-x$ 并注意到子区间对应于 $y \\in [0, \\min(1,\\Lambda \\varepsilon)]$，我们发现\n$$\n\\int_{1-\\Lambda \\varepsilon}^{1} \\rho(x)\\, dx = \\int_{0}^{\\min(1,\\Lambda \\varepsilon)} \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right) dy = 2\\left(1 - \\exp\\!\\left(-\\min\\!\\left(\\dfrac{1}{2\\varepsilon}, \\dfrac{\\Lambda}{2}\\right)\\right)\\right).\n$$\n因此，\n$$\nf_{\\Lambda}(\\varepsilon,\\Lambda) = \\dfrac{1 - \\exp\\!\\left(-\\min\\!\\left(\\dfrac{1}{2\\varepsilon}, \\dfrac{\\Lambda}{2}\\right)\\right)}{1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)}.\n$$\n这就给出了一个精确的、无量纲的分数，表示一个完美均分的网格会分配到层邻域的单元比例。\n\n每个测试用例 $(\\varepsilon, \\tau, n_0, \\Lambda)$ 的算法步骤：\n1. 计算 $I_{\\text{tot}}(\\varepsilon) = 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right)$。\n2. 用 $C_I=\\dfrac{1}{8}$ 计算 $n_\\star = \\left\\lceil \\sqrt{\\dfrac{C_I}{\\tau}} \\cdot I_{\\text{tot}}(\\varepsilon) \\right\\rceil$。\n3. 如果 $n_0 \\ge n_\\star$，则设置 $s=1$，否则 $s=0$。\n4. 使用上述精确公式计算 $f_{\\Lambda}$ 并四舍五入到 $6$ 位小数。\n\n将此应用于指定的测试套件会产生确定性的整数和浮点数输出。程序必须打印单行，其中包含一个包含 5 个条目的列表，每个条目的形式为 $[n_\\star, s, f_{\\Lambda}]$，$f_{\\Lambda}$ 四舍五入到 6 位小数，且无额外文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef n_star(eps: float, tol: float, C_I: float = 1.0/8.0) -> int:\n    # I_tot = integral of sqrt(|u''|) over [0,1] for u'' = exp(-(1-x)/eps)/eps^2\n    # sqrt(|u''|) = exp(-(1-x)/(2 eps))/eps\n    # Integral = 2 * (1 - exp(-1/(2 eps)))\n    I_tot = 2.0 * (1.0 - np.exp(-1.0 / (2.0 * eps)))\n    val = np.sqrt(C_I / tol) * I_tot\n    return int(np.ceil(val))\n\ndef fraction_in_layer(eps: float, Lam: float) -> float:\n    # f_Lambda = (1 - exp(-min(1/(2 eps), Lam/2))) / (1 - exp(-1/(2 eps)))\n    denom = 1.0 - np.exp(-1.0 / (2.0 * eps))\n    m = min(1.0 / (2.0 * eps), Lam / 2.0)\n    numer = 1.0 - np.exp(-m)\n    # Handle potential numerical issues if denom is extremely small (shouldn't happen in given tests)\n    if denom <= 0.0:\n        return 1.0  # degenerate smooth limit: all density uniform\n    f = numer / denom\n    # Clamp to [0,1] due to rounding\n    return max(0.0, min(1.0, f))\n\ndef solve():\n    # Define the test cases from the problem statement: (eps, tau, n0, Lambda)\n    test_cases = [\n        (0.05, 1e-2, 40, 4.0),\n        (0.005, 1e-4, 50, 5.0),\n        (0.5, 1e-2, 5, 1.0),\n        (0.001, 5e-3, 8, 3.0),\n        (0.02, 2e-3, 30, 4.0),\n    ]\n\n    results = []\n    for eps, tau, n0, Lam in test_cases:\n        n_req = n_star(eps, tau, C_I=1.0/8.0)\n        r_success = 1 if n0 >= n_req else 0\n        frac = fraction_in_layer(eps, Lam)\n        frac_rounded = round(frac, 6)\n        results.append([n_req, r_success, float(f\"{frac_rounded:.6f}\")])\n\n    # Format as a single-line list of lists with no spaces for exactness\n    def format_entry(entry):\n        # entry is [int, int, float]\n        return f\"[{entry[0]},{entry[1]},{entry[2]}]\"\n    print(f\"[{','.join(format_entry(e) for e in results)}]\")\n\nsolve()\n```", "id": "2540459"}, {"introduction": "在掌握了一维问题中的基本概念后，我们转向更复杂的各向异性问题，这是许多物理现象（如边界层和剪切层）的共同特征。在此实践中，您将为一个具有拉伸高斯特征的二维问题实现并比较各向同性与各向异性 $h$-自适应策略[@problem_id:2540498]。通过编码实现经典的“估计-标记-加密”循环，您将直观地看到并量化各向异性网格在以更少的自由度捕捉解的定向特征方面的巨大优势。", "problem": "考虑方形域 $\\Omega = [0,1]^2$ 以及由下式定义的目标场 $u_{\\sigma_x,\\sigma_y}:\\Omega\\to\\mathbb{R}$\n$$\nu_{\\sigma_x,\\sigma_y}(x,y) = \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma_x^2} - \\frac{(y-\\tfrac{1}{2})^2}{2\\sigma_y^2}\\right),\n$$\n其中 $\\sigma_x \\in (0,1)$ 和 $\\sigma_y \\in (0,1)$ 控制一个拉伸高斯特征的轴向宽度。考虑对轴对齐矩形网格上的连续双线性（也称 $\\mathbb{Q}_1$）有限元进行自适应 h-加密。您将比较各向同性与各向异性单元标记和加密策略在一个自由度数量的代理指标下的表现。\n\n使用以下基本依据和定义。\n\n- 双线性插值余项取决于目标场的二阶导数。受此及标准各向异性网格自适应实践的启发，在一个矩形单元 $K = [x_0,x_1]\\times[y_0,y_1]$（其中 $h_x = x_1-x_0$, $h_y = y_1-y_0$, 面积 $|K|=h_x h_y$, 中心 $c_K=(\\tfrac{x_0+x_1}{2},\\tfrac{y_0+y_1}{2})$）上定义一个局部逐单元误差指示子\n$$\n\\eta_K = |K|\\left(|u_{xx}(c_K)|\\,h_x^2 + |u_{yy}(c_K)|\\,h_y^2 + 2\\,|u_{xy}(c_K)|\\,h_x h_y\\right),\n$$\n其中 $u_{xx}$、$u_{yy}$ 和 $u_{xy}$ 是 $u_{\\sigma_x,\\sigma_y}$ 的二阶偏导数。\n\n- 对于一个网格 $\\mathcal{T}$，全局误差指示子为 $\\eta = \\sum_{K\\in\\mathcal{T}} \\eta_K$。\n\n- 使用 Dörfler 标记：给定一个体参数 $\\theta\\in(0,1)$，选择一个最小基数子集 $\\mathcal{M}\\subset\\mathcal{T}$，使得 $\\sum_{K\\in\\mathcal{M}} \\eta_K \\ge \\theta\\,\\eta$。在实践中，这通过将 $\\{\\eta_K\\}$ 按非增序排序并累加直至满足阈值来实现。\n\n- 在相同的初始网格 $\\mathcal{T}_0$ 上比较两种加密策略：\n  1. 各向同性加密：每个被标记的单元 $K\\in\\mathcal{M}$ 通过将两个方向都对半（即在 $x=\\tfrac{x_0+x_1}{2}$ 和 $y=\\tfrac{y_0+y_1}{2}$ 处二等分）来加密成 $4$ 个子单元。\n  2. 各向异性加密（定向）：对每个被标记的单元 $K\\in\\mathcal{M}$，根据主曲率对 $\\eta_K$ 的相对贡献选择一个单一的分裂方向。具体来说，如果 $|u_{yy}(c_K)|\\,h_y \\ge |u_{xx}(c_K)|\\,h_x$，则仅在 $y$-方向上对半，将 $K$ 分裂成 $2$ 个子单元；否则，仅在 $x$-方向上对半。\n\n- 停止准则：迭代标记和加密，直到 $\\eta \\le \\mathrm{TOL}$，或达到元素总数的硬上限 $N_{\\max}$，或达到加密迭代次数的硬上限 $I_{\\max}$。硬上限确保即使在极端参数体系下也能终止。\n\n- 自由度代理指标：对于带有局部悬挂节点约束的 $\\mathbb{Q}_1$ 网格，全局自由度的数量与叶单元的数量成正比，比例常数依赖于网格。为获得一个稳健且独立于实现的度量，使用叶单元的数量 $N_\\mathrm{elem}$ 作为自由度的代理指标。报告每种策略的此代理指标。\n\n实现一个程序，该程序：\n- 将 $\\Omega$ 均匀剖分为 $N_0\\times N_0$ 的矩形，构建初始网格 $\\mathcal{T}_0$。\n- 使用单元中心 $c_K$ 计算 $\\eta_K$。\n- 应用具有给定 $\\theta$ 的 Dörfler 标记。\n- 根据指定的各向同性或各向异性规则进行加密。\n- 重复此过程，直到满足停止准则。\n- 对于每个测试用例，返回一个三元组 $[N_\\mathrm{iso}, N_\\mathrm{ani}, S]$，其中 $N_\\mathrm{iso}$ 是各向同性加密的最终元素数量， $N_\\mathrm{ani}$ 是各向异性加密的最终元素数量，而 $S = N_\\mathrm{iso}/N_\\mathrm{ani}$ 是通过各向异性加密实现的自由度节省率（$S>1$ 的值表示有节省）。\n\n必须使用 $u_{\\sigma_x,\\sigma_y}$ 的二阶导数的解析表达式：\n$$\nu_{xx}(x,y) = \\left(\\frac{(x-\\tfrac{1}{2})^2}{\\sigma_x^4} - \\frac{1}{\\sigma_x^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\\quad\nu_{yy}(x,y) = \\left(\\frac{(y-\\tfrac{1}{2})^2}{\\sigma_y^4} - \\frac{1}{\\sigma_y^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\n$$\n$$\nu_{xy}(x,y) = \\frac{(x-\\tfrac{1}{2})(y-\\tfrac{1}{2})}{\\sigma_x^2 \\sigma_y^2}\\,u_{\\sigma_x,\\sigma_y}(x,y).\n$$\n\n使用以下测试套件，它涵盖了典型的、近各向同性的和高度各向异性的特征。常量 $N_{\\max}$ 和 $I_{\\max}$ 是所有测试共有的安全限制。\n\n- 测试 1：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.05,\\,0.6,\\,0.02,\\,8)$。\n- 测试 2：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.025,\\,0.6,\\,0.02,\\,8)$。\n- 测试 3：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.15,\\,0.15,\\,0.6,\\,0.02,\\,8)$。\n- 测试 4：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.30,\\,0.02,\\,0.6,\\,0.02,\\,8)$。\n\n使用 $N_{\\max}=40000$ 和 $I_{\\max}=200$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表，列表中的每个条目本身都是对应一个测试的三元组，顺序与上面相同。例如，输出必须具有以下形式：\n$[[N_\\mathrm{iso,1},N_\\mathrm{ani,1},S_1],[N_\\mathrm{iso,2},N_\\mathrm{ani,2},S_2],[N_\\mathrm{iso,3},N_\\mathrm{ani,3},S_3],[N_\\mathrm{iso,4},N_\\mathrm{ani,4},S_4]]$,\n所有数字都用十进制表示法书写。此问题不涉及任何物理单位或角度，任何可能本应为百分比的量都必须表示为 $[0,1]$ 范围内的十进制数。", "solution": "我们从一个基本性质出发：对于轴对齐矩形上的连续双线性单元，插值误差可以与目标场的二阶导数相关联。具体而言，每个坐标上的泰勒展开余项意味着，逐单元插值误差的尺度是 $|u_{xx}|h_x^2$、$|u_{yy}|h_y^2$ 和一个涉及 $|u_{xy}|h_x h_y$ 的混合项的线性组合，并与单元面积 $|K|$ 成正比。这启发我们使用感知各向异性的指示子\n$$\n\\eta_K = |K|\\left(|u_{xx}(c_K)|\\,h_x^2 + |u_{yy}(c_K)|\\,h_y^2 + 2\\,|u_{xy}(c_K)|\\,h_x h_y\\right).\n$$\n该指示子不是未知真实误差的简便公式，而是一个与插值误差的二阶导数结构相一致的可计算的替代物。将所有单元的 $\\eta_K$ 相加，得到一个全局指示子 $\\eta$。\n\n我们指定使用参数为 $\\theta\\in(0,1)$ 的 Dörfler 标记（也称体追踪），这是一个经过充分检验的、用于定位误差估计中最大贡献项的机制。具体来说，如果局部指示子按非增序排列为 $\\eta_{K_1}\\ge\\eta_{K_2}\\ge\\cdots$，那么满足 $\\sum_{i=1}^m \\eta_{K_i}\\ge \\theta \\sum_{K}\\eta_K$ 的最小索引 $m$ 决定了被标记的集合 $\\mathcal{M}=\\{K_1,\\dots,K_m\\}$。这确保了在每次迭代中都处理了全局指示子的一个固定比例，在合理的估计子性质下，这反过来又会导致收敛。\n\n比较了两种加密规则：\n\n- 各向同性加密：每个被标记的矩形在两个轴向上都被对半，产生 4 个子单元，其 $(h_x,h_y)$ 各减半。此策略不利用方向信息。\n\n- 各向异性加密：对于一个被标记的单元 $K$，我们评估在 $|u_{yy}(c_K)|\\,h_y$ 与 $|u_{xx}(c_K)|\\,h_x$ 的意义上，哪个项对 $\\eta_K$ 的贡献更强。如果 $|u_{yy}(c_K)|\\,h_y \\ge |u_{xx}(c_K)|\\,h_x$，我们仅沿 $y$ 轴分裂，将 $h_y$ 减半，产生 2 个子单元。否则，我们仅沿 $x$ 轴分裂，将 $h_x$ 减半，产生 2 个子单元。此规则旨在最有效地减小占主导地位的曲率贡献。\n\n目标场是一个可分离的高斯脊：\n$$\nu_{\\sigma_x,\\sigma_y}(x,y) = \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma_x^2} - \\frac{(y-\\tfrac{1}{2})^2}{2\\sigma_y^2}\\right),\n$$\n其 Hessian 矩阵具有闭式形式：\n$$\nu_{xx}(x,y) = \\left(\\frac{(x-\\tfrac{1}{2})^2}{\\sigma_x^4} - \\frac{1}{\\sigma_x^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\\quad\nu_{yy}(x,y) = \\left(\\frac{(y-\\tfrac{1}{2})^2}{\\sigma_y^4} - \\frac{1}{\\sigma_y^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\n$$\n$$\nu_{xy}(x,y) = \\frac{(x-\\tfrac{1}{2})(y-\\tfrac{1}{2})}{\\sigma_x^2 \\sigma_y^2}\\,u_{\\sigma_x,\\sigma_y}(x,y).\n$$\n值得注意的是, 在中心附近，主曲率的大小缩放关系类似 $|u_{xx}|\\sim \\sigma_x^{-2}$ 和 $|u_{yy}|\\sim \\sigma_y^{-2}$，这意味着当 $\\sigma_y\\ll\\sigma_x$ 时，可能存在很大的各向异性。\n\n算法设计：\n\n- 在 $\\Omega$ 上初始化一个均匀的 $N_0\\times N_0$ 网格。每个单元 $K$ 由其边界 $[x_0,x_1]\\times[y_0,y_1]$ 表示。\n\n- 在每次迭代中：\n  1. 对每个单元 $K$，计算 $h_x$、$h_y$、中心 $c_K$，评估 $u_{xx}(c_K)$、$u_{yy}(c_K)$ 和 $u_{xy}(c_K)$，然后计算 $\\eta_K$。\n  2. 求和得到 $\\eta$。如果 $\\eta \\le \\mathrm{TOL}$，则停止。否则，将 $\\{\\eta_K\\}$ 按非增序排序，并使用参数 $\\theta$ 进行 Dörfler 标记。\n  3. 根据所选策略加密被标记的单元。对于各向同性加密，用 4 个子单元替换每个被标记的单元。对于各向异性加密，使用定向规则，每个被标记的单元产生 2 个子单元。\n  4. 重复此过程，直到 $\\eta \\le \\mathrm{TOL}$ 或达到元素数量 $N_{\\max}$ 或迭代次数 $I_{\\max}$ 的安全上限。\n\n- 自由度代理指标是叶单元的数量 $N_\\mathrm{elem}$，在终止时报告。\n\n为什么各向异性加密能在拉伸特征上节省自由度：\n\n- 考虑解析一个在 $y$-方向上宽度为 $\\sigma_y$，在 $x$-方向上宽度为 $\\sigma_x$ 的层。各向同性加密同时减小 $h_x$ 和 $h_y$。为了将主导项 $|u_{yy}|\\,h_y^2$ 减小到目标容差，各向同性加密也不必要地减小了 $h_x$，导致额外单元数量增加，其因子与特征的纵横比相当。相比之下, 当 $|u_{yy}|\\,h_y$ 占主导时，各向异性规则选择性地减小 $h_y$，当 $\\sigma_y\\ll\\sigma_x$ 时，渐近节省因子可达 $\\sigma_x/\\sigma_y$ 的量级。\n\n- Dörfler 标记确保算法将加密集中在特征附近以及误差贡献最大的方向上，这使得在各向异性场景下，各向异性策略中每个新增单元能更快地使全局指示子衰减。\n\n计算考量和边界情况：\n\n- 该指示子使用单元中心；这是一种计算上高效的采样方法，与平滑的 Hessian 矩阵相符。\n\n- 安全上限 $N_{\\max}$ 和 $I_{\\max}$ 防止在极端参数体系下出现失控的加密。如果在 $\\eta\\le \\mathrm{TOL}$ 之前达到上限，算法返回当前的 $N_\\mathrm{elem}$，这对于比较策略仍然具有信息价值。\n\n- 在近各向同性的情况下（例如，$\\sigma_x\\approx\\sigma_y$），两种策略应产生相似的 $N_\\mathrm{elem}$，且比率 $S$ 接近于 1。在高度各向异性的情况下（例如，$\\sigma_y\\ll\\sigma_x$），我们期望 $S>1$，表明各向异性策略节省了自由度。\n\n该程序实现了上述算法，并将其应用于指定的测试套件：\n- 测试 1：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.05,\\,0.6,\\,0.02,\\,8)$。\n- 测试 2：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.025,\\,0.6,\\,0.02,\\,8)$。\n- 测试 3：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.15,\\,0.15,\\,0.6,\\,0.02,\\,8)$。\n- 测试 4：$(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.30,\\,0.02,\\,0.6,\\,0.02,\\,8)$。\n\n它输出单行，其中包含一个包含四个三元组 $[N_\\mathrm{iso},N_\\mathrm{ani},S]$ 的列表，每个三元组对应一个测试。结果量化了可归因于各向异性标记的自由度节省。虽然该算法专注于 h-加密, 但与 p- 和 r- 策略的概念性比较如下：p-加密会在解平滑的地方（高斯函数是平滑的）增加多项式阶数，可能在不改变网格的情况下减少自由度，但当误差由需要固定阶数下定向分辨率的几何拉伸主导时，其效果不如各向异性。r-加密（节点重定位）可以使单元形状适应 Hessian 度量而无需改变连通性；然而，在存在强各向异性的情况下，如果纵横比必须超过稳定性界限，仅靠 r-移动可能不足，因此 h-各向异性仍然至关重要。所实现的指示子和加密规则通过将曲率驱动的方向性直接编码到 h-分裂的网格中来反映这些原则。", "answer": "```python\nimport numpy as np\n\n# Adaptive h-refinement comparison: isotropic vs anisotropic marking on a stretched Gaussian feature.\n# Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used). No external input/output.\n\ndef u_and_hessian(x, y, sigx, sigy):\n    # Gaussian value and second derivatives at (x,y)\n    cx = 0.5\n    cy = 0.5\n    dx = x - cx\n    dy = y - cy\n    invsx2 = 1.0 / (sigx * sigx)\n    invsy2 = 1.0 / (sigy * sigy)\n    # Value\n    u = np.exp(-0.5 * (dx * dx * invsx2 + dy * dy * invsy2))\n    # Second derivatives\n    u_xx = ((dx * dx) * (invsx2 ** 2) - invsx2) * u\n    u_yy = ((dy * dy) * (invsy2 ** 2) - invsy2) * u\n    u_xy = (dx * dy) * (invsx2 * invsy2) * u\n    return u, u_xx, u_yy, u_xy\n\ndef element_indicator(rect, sigx, sigy):\n    x0, x1, y0, y1 = rect\n    hx = x1 - x0\n    hy = y1 - y0\n    xc = 0.5 * (x0 + x1)\n    yc = 0.5 * (y0 + y1)\n    _, u_xx, u_yy, u_xy = u_and_hessian(xc, yc, sigx, sigy)\n    area = hx * hy\n    eta = area * (abs(u_xx) * (hx ** 2) + abs(u_yy) * (hy ** 2) + 2.0 * abs(u_xy) * hx * hy)\n    return eta, abs(u_xx), abs(u_yy)\n\ndef dorfler_mark(indices, etas, theta):\n    # indices: list of element indices, etas: list of corresponding indicators\n    # return a list of indices to mark according to Dörfler with parameter theta\n    order = sorted(indices, key=lambda i: etas[i], reverse=True)\n    total = sum(etas)\n    if total <= 0.0:\n        return []\n    target = theta * total\n    acc = 0.0\n    marked = []\n    for i in order:\n        marked.append(i)\n        acc += etas[i]\n        if acc >= target:\n            break\n    return marked\n\ndef refine_mesh(mesh, marked_set, strategy, sigx, sigy):\n    # strategy: 'iso' or 'ani'\n    new_mesh = []\n    for idx, rect in enumerate(mesh):\n        if idx not in marked_set:\n            new_mesh.append(rect)\n        else:\n            x0, x1, y0, y1 = rect\n            xm = 0.5 * (x0 + x1)\n            ym = 0.5 * (y0 + y1)\n            if strategy == 'iso':\n                # split into 4 children\n                new_mesh.append((x0, xm, y0, ym))\n                new_mesh.append((xm, x1, y0, ym))\n                new_mesh.append((x0, xm, ym, y1))\n                new_mesh.append((xm, x1, ym, y1))\n            else:\n                # anisotropic: decide direction based on |u_yy|*hy vs |u_xx|*hx at center\n                hx = x1 - x0\n                hy = y1 - y0\n                xc = 0.5 * (x0 + x1)\n                yc = 0.5 * (y0 + y1)\n                _, u_xx, u_yy, _ = u_and_hessian(xc, yc, sigx, sigy)\n                if abs(u_yy) * hy >= abs(u_xx) * hx:\n                    # split along y only\n                    new_mesh.append((x0, x1, y0, ym))\n                    new_mesh.append((x0, x1, ym, y1))\n                else:\n                    # split along x only\n                    new_mesh.append((x0, xm, y0, y1))\n                    new_mesh.append((xm, x1, y0, y1))\n    return new_mesh\n\ndef adaptive_refine(sigx, sigy, theta, TOL, N0, strategy, Nmax=40000, Imax=200):\n    # Build initial uniform mesh\n    xs = np.linspace(0.0, 1.0, N0 + 1)\n    ys = np.linspace(0.0, 1.0, N0 + 1)\n    mesh = []\n    for i in range(N0):\n        for j in range(N0):\n            mesh.append((xs[i], xs[i+1], ys[j], ys[j+1]))\n    # Adaptive loop\n    for it in range(Imax):\n        n = len(mesh)\n        etas = [0.0] * n\n        # Compute indicators\n        total_eta = 0.0\n        for i, rect in enumerate(mesh):\n            eta, _, _ = element_indicator(rect, sigx, sigy)\n            etas[i] = eta\n            total_eta += eta\n        if total_eta <= TOL:\n            break\n        # Mark with Dörfler\n        indices = list(range(n))\n        marked = dorfler_mark(indices, etas, theta)\n        marked_set = set(marked)\n        # Refine\n        mesh = refine_mesh(mesh, marked_set, strategy, sigx, sigy)\n        if len(mesh) > Nmax:\n            break\n    return len(mesh)\n\ndef run_case(sigx, sigy, theta, TOL, N0):\n    N_iso = adaptive_refine(sigx, sigy, theta, TOL, N0, 'iso')\n    N_ani = adaptive_refine(sigx, sigy, theta, TOL, N0, 'ani')\n    ratio = float(N_iso) / float(N_ani) if N_ani > 0 else float('inf')\n    # Format: integers for counts, ratio as float with reasonable precision\n    return [int(N_iso), int(N_ani), float(f\"{ratio:.6f}\")]\n\ndef solve():\n    # Test suite as specified in the problem statement\n    test_cases = [\n        (0.25, 0.05, 0.6, 0.02, 8),\n        (0.25, 0.025, 0.6, 0.02, 8),\n        (0.15, 0.15, 0.6, 0.02, 8),\n        (0.30, 0.02, 0.6, 0.02, 8),\n    ]\n    results = []\n    for sigx, sigy, theta, TOL, N0 in test_cases:\n        res = run_case(sigx, sigy, theta, TOL, N0)\n        results.append(res)\n    # Print single-line output exactly as required: a list of lists, comma-separated, no extra text\n    # Ensure no spaces for strict formatting\n    def list_to_str(lst):\n        if isinstance(lst, list):\n            return \"[\" + \",\".join(list_to_str(x) for x in lst) + \"]\"\n        else:\n            return str(lst)\n    print(list_to_str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2540498"}, {"introduction": "任何自适应策略的有效性都依赖于其误差估计器的可靠性。这个高级实践将带您深入“估计”这一关键步骤的内部，超越简单的误差指标，探索基于局部Neumann问题的、更为稳健的后验误差估计方法[@problem_id:2540490]。通过在一维泊松问题上实现并对比标准残差估计器与这种基于局部问题求解的估计器，您将对误差上界的计算原理及其在保证自适应算法可靠性中的作用有更深刻的体会。", "problem": "考虑一维空间中的标量泊松问题：求 $u \\in H_0^1(0,1)$，使得在 $(0,1)$ 中有 $-u'' = f$，并满足齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。能量范数定义为 $\\lVert v \\rVert_E := \\left(\\int_0^1 \\lvert v'(x)\\rvert^2\\,dx\\right)^{1/2}$。设 $V_h$ 表示在 $[0,1]$ 上一个包含 $N$ 个单元的均匀网格上的连续分片线性函数空间，其节点为 $x_i = i h$（$i=0,\\dots,N$），且 $h=1/N$。有限元方法旨在寻求 $u_h\\in V_h\\cap H_0^1(0,1)$，使得对于所有 $v\\in V_h\\cap H_0^1(0,1)$，都有 $\\int_0^1 u_h'(x)v'(x)\\,dx=\\int_0^1 f(x)v(x)\\,dx$。\n\n您的任务是：\n\n1) 实现能量误差 $\\lVert u' - u_h'\\rVert_{L^2(0,1)}$ 的计算，使用数值积分，其中 $u$ 是对应于下面给出的选定右端项 $f$ 的精确解。\n\n2) 实现一维分片线性有限元的标准残差型后验误差估计子。对于每个长度为 $h_K$ 的单元 $K=[x_{i},x_{i+1}]$，将内部残差贡献定义为 $h_K^2 \\int_K f(x)^2\\,dx$；对于每个内部节点 $x_i$（$i=1,\\dots,N-1$），定义离散通量的跳跃 $\\llbracket u_h'\\rrbracket_i := u_h'(x_i^-)-u_h'(x_i^+)$。将在节点 $x_i$ 处的跳跃贡献定义为 $\\frac{h_{i-1}+h_{i}}{2}\\,\\llbracket u_h'\\rrbracket_i^2$，其中 $h_{i-1}=x_i-x_{i-1}$ 且 $h_{i}=x_{i+1}-x_i$。总的标准估计子为\n$$\n\\eta_{\\mathrm{std}}^2 := \\sum_{K} h_K^2 \\int_K f(x)^2\\,dx \\;+\\;\\sum_{i=1}^{N-1} \\frac{h_{i-1}+h_i}{2}\\,\\llbracket u_h'\\rrbracket_i^2.\n$$\n\n3) 实现一个替代的可计算界，该界通过顶点片上局部诺伊曼问题的解来取代散度残差项。对于每个内部节点 $x_i$（$i=1,\\dots,N-1$），考虑片 $\\omega_i := (x_{i-1},x_{i+1})$ 和离散局部诺伊曼问题：求 $w_i \\in V_h(\\omega_i)$ 使得对于所有 $v \\in V_h(\\omega_i)$，都有\n$$\n\\int_{\\omega_i} w_i'(x) v'(x)\\,dx = \\int_{\\omega_i} f(x) v(x)\\,dx,\n$$\n并附加约束 $\\int_{\\omega_i} w_i(x)\\,dx = 0$ 以固定诺伊曼零空间，其中 $V_h(\\omega_i)$ 表示全局分片线性空间在 $\\omega_i$ 上的限制。将局部片能量定义为\n$$\n\\eta_{i,\\mathrm{div}}^2 := \\int_{\\omega_i} \\lvert w_i'(x)\\rvert^2\\,dx,\n$$\n诺伊曼片估计子定义为\n$$\n\\eta_{\\mathrm{neu}}^2 := \\sum_{i=1}^{N-1} \\eta_{i,\\mathrm{div}}^2 \\;+\\;\\sum_{i=1}^{N-1} \\frac{h_{i-1}+h_i}{2}\\,\\llbracket u_h'\\rrbracket_i^2.\n$$\n通过组装节点 $\\{x_{i-1},x_i,x_{i+1}\\}$ 上的 $3\\times 3$ 片刚度矩阵、相应的片载荷向量，并通过单个拉格朗日乘子施加附加约束来计算离散片空间中的 $w_i$。\n\n4) 对于每个测试案例，计算可靠性常数 $C_{\\mathrm{std}} := \\eta_{\\mathrm{std}} / \\lVert u' - u_h'\\rVert_{L^2(0,1)}$ 和 $C_{\\mathrm{neu}} := \\eta_{\\mathrm{neu}} / \\lVert u' - u_h'\\rVert_{L^2(0,1)}$，结果为浮点数。\n\n使用以下右端项 $f$ 和精确解 $u$：\n- $f_1(x) := \\pi^2 \\sin(\\pi x)$，其解为 $u_1(x) := \\sin(\\pi x)$，因此 $u_1'(x) := \\pi \\cos(\\pi x)$。\n- $f_2(x) := 1$，其解为 $u_2(x) := \\tfrac{1}{2}x(1-x)$，因此 $u_2'(x) := \\tfrac{1}{2}(1-2x)$。\n- $f_3(x) := \\begin{cases} 1, & x < \\tfrac{1}{2}, \\\\ 2, & x \\ge \\tfrac{1}{2},\\end{cases}$，其对应的精确解满足 $-u_3''=f_3$ 和 $u_3(0)=0, u_3(1)=0$，可得\n$$\nu_3(x) := \\begin{cases}\n-\\tfrac{1}{2}x^2 + \\tfrac{5}{8}x, & 0 \\le x \\le \\tfrac{1}{2},\\\\\n-x^2 + \\tfrac{9}{8}x - \\tfrac{1}{8}, & \\tfrac{1}{2} < x \\le 1,\n\\end{cases}\n\\quad\nu_3'(x) := \\begin{cases}\n-x + \\tfrac{5}{8}, & 0 \\le x \\le \\tfrac{1}{2},\\\\\n-2x + \\tfrac{9}{8}, & \\tfrac{1}{2} < x \\le 1.\n\\end{cases}\n$$\n\n测试套件：\n- 案例 A：$N=4$，使用 $f_1$。\n- 案例 B：$N=16$，使用 $f_1$。\n- 案例 C：$N=3$，使用 $f_2$。\n- 案例 D：$N=20$，使用 $f_3$。\n- 案例 E：$N=2$，使用 $f_3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表。对于每个测试案例，首先输出 $C_{\\mathrm{std}}$，然后输出 $C_{\\mathrm{neu}}$，并按案例 A 到 E 的顺序排列。例如，输出必须具有以下形式：$[C_{\\mathrm{std},A},C_{\\mathrm{neu},A},C_{\\mathrm{std},B},C_{\\mathrm{neu},B},C_{\\mathrm{std},C},C_{\\mathrm{neu},C},C_{\\mathrm{std},D},C_{\\mathrm{neu},D},C_{\\mathrm{std},E},C_{\\mathrm{neu},E}]$。", "solution": "所给出的问题是关于一维泊松方程有限元方法后验误差分析的一个定义明确的练习。它在科学上是合理的，数学上是一致的，并且所有必需的组件都已明确指定。因此，该问题被认为是有效的。我将继续进行求解。\n\n问题的核心是为一维泊松方程 $-u'' = f$（在 $(0,1)$ 上，且 $u(0)=u(1)=0$）的有限元解计算和比较两种后验误差估计子。\n\n**1. 有限元解**\n\n我们使用一个均匀网格，该网格有 $N$ 个大小为 $h = 1/N$ 的单元和节点 $x_i = i h$（$i=0, \\dots, N$）。在零值于 $x=0$ 和 $x=1$ 的连续分片线性函数空间 $V_h$ 中寻求有限元解 $u_h$。我们可以用标准的“帽子”基函数 $\\phi_i(x)$ 来表示 $u_h$ 为 $u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)$，其中 $U_j = u_h(x_j)$ 是未知的节点值。\n\nGalerkin 公式导出一个线性方程组 $A \\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = (U_1, \\dots, U_{N-1})^T$。刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的条目是：\n$$\nA_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx \\quad \\text{和} \\quad b_i = \\int_0^1 f(x) \\phi_i(x) \\,dx\n$$\n对于一维均匀网格，刚度矩阵是一个 $(N-1) \\times (N-1)$ 的对称三对角矩阵：\n$$\nA = \\frac{1}{h}\n\\begin{pmatrix}\n2 & -1 & 0 & \\dots & 0 \\\\\n-1 & 2 & -1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\dots & -1 & 2 & -1 \\\\\n0 & \\dots & 0 & -1 & 2\n\\end{pmatrix}\n$$\n载荷向量 $b_i$ 的条目必须通过数值积分来计算，特别是对于非多项式的 $f(x)$。一旦系统 $A \\mathbf{U} = \\mathbf{b}$ 解出 $\\mathbf{U}$，近似解 $u_h$ 就被完全确定。其导数 $u_h'$ 在每个单元 $K_i = [x_i, x_{i+1}]$ 上是分片常数：\n$$\nu_h'(x) = \\frac{U_{i+1} - U_i}{h} \\quad \\text{对于 } x \\in (x_i, x_{i+1}),\n$$\n其中我们定义 $U_0 = U_N = 0$。\n\n**2. 能量误差**\n\n精确能量误差由 $\\lVert u' - u_h' \\rVert_{L^2(0,1)}$ 给出。其平方通过对每个单元的贡献求和来计算：\n$$\n\\lVert u' - u_h' \\rVert_{L^2(0,1)}^2 = \\int_0^1 (u'(x) - u_h'(x))^2 \\,dx = \\sum_{i=0}^{N-1} \\int_{x_i}^{x_{i+1}} \\left(u'(x) - \\frac{U_{i+1}-U_i}{h}\\right)^2 \\,dx\n$$\n该积分使用高阶数值积分以保证精度。\n\n**3. 标准残差估计子 ($\\eta_{\\mathrm{std}}$)**\n\n该估计子定义为 $\\eta_{\\mathrm{std}}^2 = \\eta_{\\mathrm{res}}^2 + \\eta_{\\mathrm{jump}}^2$。\n第一项是单元残差贡献：\n$$\n\\eta_{\\mathrm{res}}^2 = \\sum_{K} h_K^2 \\int_K f(x)^2\\,dx = \\sum_{i=0}^{N-1} h^2 \\int_{x_i}^{x_{i+1}} f(x)^2\\,dx\n$$\n$f^2$ 的积分在每个单元上使用数值积分计算。\n\n第二项涉及离散解在内部节点处导数的跳跃：\n$$\n\\eta_{\\mathrm{jump}}^2 = \\sum_{i=1}^{N-1} \\frac{h_{i-1}+h_i}{2}\\,\\llbracket u_h'\\rrbracket_i^2 = \\sum_{i=1}^{N-1} h\\,\\llbracket u_h'\\rrbracket_i^2\n$$\n其中 $\\llbracket u_h'\\rrbracket_i = u_h'(x_i^-) - u_h'(x_i^+)$。Galerkin 方法的一个基本结果是，该跳跃项等于载荷向量中的相应条目。对于每个内部基函数 $\\phi_i$，弱形式给出：\n$$\n\\int_0^1 u_h'(x)\\phi_i'(x)\\,dx = \\int_0^1 f(x)\\phi_i(x)\\,dx = b_i\n$$\n将左侧在 $\\phi_i$ 的支集中的每个单元上进行分部积分，可得：\n$$\n\\int_0^1 u_h'(x)\\phi_i'(x)\\,dx = u_h'(x_i^-) - u_h'(x_i^+) = \\llbracket u_h'\\rrbracket_i\n$$\n因此，$\\llbracket u_h'\\rrbracket_i = b_i$。这极大地简化了跳跃项的计算：\n$$\n\\eta_{\\mathrm{jump}}^2 = \\sum_{i=1}^{N-1} h\\, b_i^2\n$$\n\n**4. 诺伊曼片估计子 ($\\eta_{\\mathrm{neu}}$)**\n\n该估计子用局部诺伊曼问题解的能量之和代替了单元残差项。其形式为：\n$$\n\\eta_{\\mathrm{neu}}^2 = \\sum_{i=1}^{N-1} \\eta_{i,\\mathrm{div}}^2 + \\eta_{\\mathrm{jump}}^2\n$$\n跳跃项 $\\eta_{\\mathrm{jump}}^2$ 与标准估计子中的相同。我们专注于计算每个内部节点 $x_i$（$i \\in \\{1, \\dots, N-1\\}$）的片散度项 $\\eta_{i,\\mathrm{div}}^2$。\n\n对于每个片 $\\omega_i = (x_{i-1}, x_{i+1})$，我们在由限制在 $\\omega_i$ 上的 $\\{\\phi_{i-1}, \\phi_{i}, \\phi_{i+1}\\}$ 张成的局部三节点有限元空间中求解关于 $w_i(x)$ 的局部诺伊曼问题。设 $\\mathbf{w} = (w_{i-1}, w_i, w_{i+1})^T$ 为局部解 $w_i$ 的节点值。局部问题由刚度矩阵 $A_p$ 和载荷向量 $\\mathbf{b}_p$ 定义：\n$$\nA_p \\mathbf{w} = \\mathbf{b}_p \\quad \\text{其中} \\quad A_p = \\frac{1}{h}\\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{pmatrix}, \\quad (\\mathbf{b}_p)_j = \\int_{\\omega_i} f(x)\\phi_j(x)\\,dx\n$$\n对于 $j \\in \\{i-1, i, i+1\\}$。矩阵 $A_p$ 是奇异的，反映了诺伊曼问题常数函数的零空间。唯一解由约束 $\\int_{\\omega_i} w_i(x)\\,dx=0$ 固定，这转化为对节点值的线性约束：\n$$\n\\int_{x_{i-1}}^{x_{i+1}} \\sum_{j=i-1}^{i+1} w_j \\phi_j(x)\\,dx = w_{i-1}\\frac{h}{2} + w_i h + w_{i+1}\\frac{h}{2} = 0 \\implies \\mathbf{C}^T \\mathbf{w} = 0\n$$\n其中 $\\mathbf{C} = (h/2, h, h/2)^T$。我们使用拉格朗日乘子 $\\lambda$ 来求解这个约束系统，这导出了增广的 $4 \\times 4$ 系统：\n$$\n\\begin{pmatrix} A_p & \\mathbf{C} \\\\ \\mathbf{C}^T & 0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{w} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} \\mathbf{b}_p \\\\ 0 \\end{pmatrix}\n$$\n解出 $\\mathbf{w}$ 后，局部能量贡献为 $\\eta_{i,\\mathrm{div}}^2 = \\int_{\\omega_i} \\lvert w_i'(x)\\rvert^2\\,dx$。从局部问题的弱形式出发，通过将测试函数设为 $w_i$ 本身，我们发现：\n$$\n\\eta_{i,\\mathrm{div}}^2 = \\int_{\\omega_i} w_i'(x)w_i'(x)\\,dx = \\int_{\\omega_i} f(x) w_i(x)\\,dx = \\sum_{j=i-1}^{i+1} w_j \\int_{\\omega_i} f(x)\\phi_j(x)\\,dx = \\mathbf{w}^T \\mathbf{b}_p\n$$\n这提供了一种计算片能量的有效方法。\n\n**5. 可靠性常数**\n\n最后，对于每个测试案例，我们计算估计误差与真实误差的比率，称为可靠性常数（或有效性指数）：\n$$\nC_{\\mathrm{std}} = \\frac{\\eta_{\\mathrm{std}}}{\\lVert u' - u_h'\\rVert_{L^2(0,1)}}, \\quad C_{\\mathrm{neu}} = \\frac{\\eta_{\\mathrm{neu}}}{\\lVert u' - u_h'\\rVert_{L^2(0,1)}}\n$$\n这些常数是为 $N$ 和 $f(x)$ 的每个指定配置计算的。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson problem using FEM and computes error estimators for specified test cases.\n    \"\"\"\n\n    class TestCase:\n        def __init__(self, N, f_func, u_prime_func, f_discontinuity=None):\n            self.N = N\n            self.f = f_func\n            self.u_prime = u_prime_func\n            self.f_discontinuity = f_discontinuity\n\n    # Define test functions\n    f1 = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u1_prime = lambda x: np.pi * np.cos(np.pi * x)\n\n    f2 = lambda x: 1.0\n    u2_prime = lambda x: 0.5 * (1.0 - 2.0 * x)\n    \n    def f3(x):\n        if hasattr(x, '__iter__'):\n            return np.piecewise(x, [x < 0.5], [1.0, 2.0])\n        return 1.0 if x < 0.5 else 2.0\n\n    def u3_prime(x):\n        if hasattr(x, '__iter__'):\n            return np.piecewise(x, [x < 0.5],\n                                [lambda v: -v + 5/8, lambda v: -2*v + 9/8])\n        return -x + 5/8 if x < 0.5 else -2*x + 9/8\n\n    test_cases = [\n        TestCase(N=4, f_func=f1, u_prime_func=u1_prime),\n        TestCase(N=16, f_func=f1, u_prime_func=u1_prime),\n        TestCase(N=3, f_func=f2, u_prime_func=u2_prime),\n        TestCase(N=20, f_func=f3, u_prime_func=u3_prime, f_discontinuity=0.5),\n        TestCase(N=2, f_func=f3, u_prime_func=u3_prime, f_discontinuity=0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case.N\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n        \n        # --- 1. Global FEM solution ---\n        if N > 1:\n            A = np.zeros((N - 1, N - 1))\n            main_diag = 2.0 / h * np.ones(N - 1)\n            off_diag = -1.0 / h * np.ones(N - 2)\n            A += np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n            b = np.zeros(N - 1)\n            for i in range(1, N):\n                # Hat function phi_i\n                phi_i = lambda x, i_node=i: np.maximum(0, 1 - np.abs(x - nodes[i_node]) / h)\n                integrand = lambda x: case.f(x) * phi_i(x)\n                \n                points = [case.f_discontinuity] if case.f_discontinuity and nodes[i-1] < case.f_discontinuity < nodes[i+1] else None\n                b[i - 1] = quad(integrand, nodes[i - 1], nodes[i + 1], points=points)[0]\n\n            U_internal = np.linalg.solve(A, b)\n            U = np.concatenate(([0], U_internal, [0]))\n        else: # N=1 case, only boundary nodes\n            U = np.zeros(2)\n            b = np.array([])\n\n        # --- 2. Energy Error ---\n        error_sq = 0.0\n        for i in range(N):\n            u_h_prime_val = (U[i + 1] - U[i]) / h\n            integrand = lambda x: (case.u_prime(x) - u_h_prime_val)**2\n            \n            points = [case.f_discontinuity] if case.f_discontinuity and nodes[i] < case.f_discontinuity < nodes[i+1] else None\n            error_sq += quad(integrand, nodes[i], nodes[i+1], points=points)[0]\n\n        energy_error = np.sqrt(error_sq)\n\n        # --- 3. Standard Estimator ---\n        # Residual term\n        eta_res_sq = 0.0\n        for i in range(N):\n            integrand = lambda x: case.f(x)**2\n            points = [case.f_discontinuity] if case.f_discontinuity and nodes[i] < case.f_discontinuity < nodes[i+1] else None\n            integral_f_sq = quad(integrand, nodes[i], nodes[i+1], points=points)[0]\n            eta_res_sq += h**2 * integral_f_sq\n        \n        # Jump term\n        eta_jump_sq = h * np.sum(b**2)\n        eta_std = np.sqrt(eta_res_sq + eta_jump_sq)\n\n        # --- 4. Neumann-Patch Estimator ---\n        eta_div_sq_sum = 0.0\n        if N > 1:\n            for i in range(1, N): # Loop over interior nodes\n                # Local patch stiffness matrix\n                A_p = (1.0 / h) * np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\n                C = np.array([h/2, h, h/2])\n                \n                # Augmented system matrix\n                M = np.zeros((4,4))\n                M[:3,:3] = A_p\n                M[:3, 3] = C\n                M[3, :3] = C.T\n\n                # Local load vector b_p\n                b_p = np.zeros(3)\n                patch_nodes_idx = [i - 1, i, i + 1]\n                for j_local, j_global in enumerate(patch_nodes_idx):\n                    phi_j = lambda x, j_node=j_global: np.maximum(0, 1 - np.abs(x - nodes[j_node]) / h)\n                    integrand = lambda x: case.f(x) * phi_j(x)\n                    \n                    points = [case.f_discontinuity] if case.f_discontinuity and nodes[i-1] < case.f_discontinuity < nodes[i+1] else None\n                    b_p[j_local] = quad(integrand, nodes[i - 1], nodes[i + 1], points=points)[0]\n\n                # RHS for augmented system\n                F_aug = np.concatenate((b_p, [0]))\n\n                # Solve for (w, lambda)\n                sol_aug = np.linalg.solve(M, F_aug)\n                w = sol_aug[:3]\n\n                # Compute local patch energy\n                eta_i_div_sq = np.dot(w, b_p)\n                eta_div_sq_sum += eta_i_div_sq\n\n        eta_neu = np.sqrt(eta_div_sq_sum + eta_jump_sq)\n\n        # --- 5. Reliability Constants ---\n        C_std = eta_std / energy_error if energy_error > 1e-15 else 0.0\n        C_neu = eta_neu / energy_error if energy_error > 1e-15 else 0.0\n        results.extend([C_std, C_neu])\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2540490"}]}