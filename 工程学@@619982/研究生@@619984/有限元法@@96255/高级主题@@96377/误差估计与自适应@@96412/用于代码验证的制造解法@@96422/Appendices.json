{"hands_on_practices": [{"introduction": "在应用制造解法时，第一步总是分析性的：根据选定的制造解推导出必需的源项和边界条件。这个练习 [@problem_id:2576877] 将超越简单的泊松方程，带你处理一个具有空间变化电导率 $k(\\boldsymbol{x})$ 的扩散问题。你将完成建立一个可验证问题所需的关键分析工作，并思考使问题适定所需的理论光滑度条件。", "problem": "考虑标量扩散方程 $-\\nabla \\cdot \\big(k(\\boldsymbol{x}) \\nabla u(\\boldsymbol{x})\\big) = f(\\boldsymbol{x})$，该方程定义在单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上，并带有狄利克雷（Dirichlet）或诺伊曼（Neumann）边界条件。在用于有限元方法（FEM）代码验证的“制造解方法”（method of manufactured solutions）中，人们特意选择一个光滑的制造解 $u_m$ 和一个处处为正且空间变化的电导率 $k$，然后推导出源项 $f$ 和边界数据，使得 $u_m$ 是该边值问题的精确解。\n\n设制造解和电导率为\n$$\nu_m(x,y) = \\exp(x)\\,\\sin(\\pi y), \\qquad k(x,y) = 1 + x + y^2,\n$$\n对于 $(x,y) \\in \\Omega$。假设 $k$ 在 $\\overline{\\Omega}$ 上处处为正。\n\n任务：\n1. 仅通过应用基本的多变量微积分（分量求导和乘积法则），推导出体积源项 $f(x,y)$，使得 $u_m$ 在 $\\Omega$ 中满足 $-\\nabla \\cdot (k \\nabla u_m) = f$。\n2. 为以下两种情况构建一致的边界数据：\n   - 在 $\\partial \\Omega$ 上的狄利克雷数据 $g$，使得 $u = g$ 且在 $\\partial \\Omega$ 上有 $u \\equiv u_m$。\n   - 在 $\\partial \\Omega$ 上的诺伊曼数据 $h$，使得 $-k \\nabla u \\cdot \\boldsymbol{n} = h$ 且在 $\\Omega$ 中有 $u \\equiv u_m$，其中 $\\boldsymbol{n}$ 是 $\\partial \\Omega$ 上的单位外法向量。\n3. 阐明并论证对 $u_m$ 和 $k$ 的最小光滑性假设，以确保：\n   - 强形式的源 $f = -\\nabla \\cdot (k \\nabla u_m)$ 作为一个在 $L^2(\\Omega)$ 中的函数是良定义的，适用于标准的弱形式。\n   - 狄利克雷迹 $g$ 是良定义的，诺伊曼通量 $h$ 作为平方可积散度场的希尔伯特（Hilbert）空间中一个场的法向迹是有意义的。\n\n将任务1中得到的源项 $f(x,y)$ 的显式解析表达式作为最终答案。无需进行数值计算，也无需四舍五入。如果出现角度，请用弧度表示。", "solution": "首先对问题陈述进行严格验证。\n\n第1步：提取已知条件\n- 控制方程：$-\\nabla \\cdot \\big(k(\\boldsymbol{x}) \\nabla u(\\boldsymbol{x})\\big) = f(\\boldsymbol{x})$\n- 区域：$\\Omega = (0,1) \\times (0,1)$\n- 制造解：$u_m(x,y) = \\exp(x)\\,\\sin(\\pi y)$\n- 电导率：$k(x,y) = 1 + x + y^2$\n- 条件：问题陈述假设 $k$ 在 $\\overline{\\Omega}$ 上处处为正。对于 $(x,y) \\in [0,1] \\times [0,1]$，$k(x,y)$ 的最小值在 $(0,0)$ 处取得，为 $k(0,0)=1$；最大值在 $(1,1)$ 处取得，为 $k(1,1)=3$。因此，在闭域 $\\overline{\\Omega}$ 上，$k(x,y) \\in [1,3]$，这证实了它确实是处处为正的。\n- 任务：\n  1. 推导源项 $f(x,y)$，使得 $-\\nabla \\cdot (k \\nabla u_m) = f$ 成立。\n  2. 构建在边界 $\\partial\\Omega$ 上的狄利克雷数据 $g$ 和诺伊曼数据 $h$。\n  3. 阐明为使问题在弱解意义下是适定的（well-defined），对 $u_m$ 和 $k$ 的最小光滑性假设。\n\n第2步：使用提取的已知条件进行验证\n该问题具有科学依据，是验证偏微分方程数值解算器的人造解方法的标准应用。该问题在数学上是适定的；各项任务涉及基于给定函数的直接计算，没有歧义。问题陈述是客观的，并使用了精确的数学语言。它是自洽的，提供了所有必需的数据，并且没有内部矛盾。指定的函数 $u_m$ 和 $k$ 是无限可微的（$C^\\infty$），这对于所需的计算来说绰绰有余。该问题不违反任何有效性标准。\n\n第3步：结论与行动\n问题被判定为有效。将提供完整的解答。\n\n解答过程按顺序处理三个任务。\n\n任务1：推导源项 $f(x,y)$\n源项由方程 $f(x,y) = -\\nabla \\cdot (k(x,y) \\nabla u_m(x,y))$ 定义。我们分步进行此计算。\n\n首先，我们计算制造解的梯度 $\\nabla u_m$：\n$$\n\\nabla u_m(x,y) = \\left( \\frac{\\partial u_m}{\\partial x}, \\frac{\\partial u_m}{\\partial y} \\right)\n$$\n偏导数是：\n$$\n\\frac{\\partial u_m}{\\partial x} = \\frac{\\partial}{\\partial x} (\\exp(x) \\sin(\\pi y)) = \\exp(x) \\sin(\\pi y)\n$$\n$$\n\\frac{\\partial u_m}{\\partial y} = \\frac{\\partial}{\\partial y} (\\exp(x) \\sin(\\pi y)) = \\pi \\exp(x) \\cos(\\pi y)\n$$\n所以，梯度是：\n$$\n\\nabla u_m(x,y) = \\begin{pmatrix} \\exp(x) \\sin(\\pi y) \\\\ \\pi \\exp(x) \\cos(\\pi y) \\end{pmatrix}\n$$\n接下来，我们将梯度乘以电导率 $k(x,y) = 1 + x + y^2$ 来获得通量矢量场，我们将其表示为 $\\boldsymbol{q}_m = k \\nabla u_m$：\n$$\nk \\nabla u_m = (1 + x + y^2) \\begin{pmatrix} \\exp(x) \\sin(\\pi y) \\\\ \\pi \\exp(x) \\cos(\\pi y) \\end{pmatrix} = \\begin{pmatrix} (1 + x + y^2)\\exp(x) \\sin(\\pi y) \\\\ (1 + x + y^2)\\pi \\exp(x) \\cos(\\pi y) \\end{pmatrix}\n$$\n最后，我们计算这个矢量场的散度 $\\nabla \\cdot (k \\nabla u_m)$。设矢量场的分量为 $V_x$ 和 $V_y$：\n$$\nV_x(x,y) = (1 + x + y^2)\\exp(x) \\sin(\\pi y)\n$$\n$$\nV_y(x,y) = (1 + x + y^2)\\pi \\exp(x) \\cos(\\pi y)\n$$\n散度是 $\\nabla \\cdot (k \\nabla u_m) = \\frac{\\partial V_x}{\\partial x} + \\frac{\\partial V_y}{\\partial y}$。我们使用乘积法则计算每个偏导数。\n$$\n\\frac{\\partial V_x}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ (1 + x + y^2)\\exp(x) \\sin(\\pi y) \\right] = [1 \\cdot \\exp(x) + (1+x+y^2)\\exp(x)] \\sin(\\pi y) = (2+x+y^2)\\exp(x)\\sin(\\pi y)\n$$\n$$\n\\frac{\\partial V_y}{\\partial y} = \\frac{\\partial}{\\partial y} \\left[ (1 + x + y^2)\\pi \\exp(x) \\cos(\\pi y) \\right] = [2y \\cdot \\pi \\exp(x) \\cos(\\pi y)] + [(1+x+y^2)\\pi \\exp(x) (-\\pi \\sin(\\pi y))]\n$$\n$$\n\\frac{\\partial V_y}{\\partial y} = 2\\pi y \\exp(x) \\cos(\\pi y) - \\pi^2(1+x+y^2)\\exp(x)\\sin(\\pi y)\n$$\n将这些导数相加得到散度：\n$$\n\\nabla \\cdot (k \\nabla u_m) = (2+x+y^2)\\exp(x)\\sin(\\pi y) + 2\\pi y \\exp(x) \\cos(\\pi y) - \\pi^2(1+x+y^2)\\exp(x)\\sin(\\pi y)\n$$\n将含有 $\\sin(\\pi y)$ 和 $\\cos(\\pi y)$ 的项分组：\n$$\n\\nabla \\cdot (k \\nabla u_m) = \\left[ (2+x+y^2) - \\pi^2(1+x+y^2) \\right] \\exp(x)\\sin(\\pi y) + 2\\pi y \\exp(x)\\cos(\\pi y)\n$$\n源项 $f(x,y)$ 是该表达式的负值：\n$$\nf(x,y) = -\\nabla \\cdot (k \\nabla u_m) = \\left[ \\pi^2(1+x+y^2) - (2+x+y^2) \\right] \\exp(x)\\sin(\\pi y) - 2\\pi y \\exp(x)\\cos(\\pi y)\n$$\n\n任务2：构建边界数据\n单位正方形的边界 $\\partial \\Omega$ 由四条边组成。\n\n- 狄利克雷数据 $g$：该数据通过在 $\\partial \\Omega$ 上计算 $u_m$ 的值得到，即 $g = u_m|_{\\partial \\Omega}$。\n  - 在底边（$y=0, x \\in [0,1]$）上： $g(x,0) = \\exp(x)\\sin(0) = 0$。\n  - 在右边（$x=1, y \\in [0,1]$）上： $g(1,y) = \\exp(1)\\sin(\\pi y) = e \\sin(\\pi y)$。\n  - 在顶边（$y=1, x \\in [0,1]$）上： $g(x,1) = \\exp(x)\\sin(\\pi) = 0$。\n  - 在左边（$x=0, y \\in [0,1]$）上： $g(0,y) = \\exp(0)\\sin(\\pi y) = \\sin(\\pi y)$。\n\n- 诺伊曼数据 $h$：该数据定义为 $h = -k \\nabla u_m \\cdot \\boldsymbol{n}$，其中 $\\boldsymbol{n}$ 是单位外法向量。\n  - 在底边（$y=0$）上：$\\boldsymbol{n} = (0,-1)$。\n    $h(x,0) = -(k(x,0) \\nabla u_m(x,0)) \\cdot (0,-1) = - (1+x) \\begin{pmatrix} 0 \\\\ \\pi \\exp(x) \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = (1+x)\\pi\\exp(x)$。\n  - 在右边（$x=1$）上：$\\boldsymbol{n} = (1,0)$。\n    $h(1,y) = -(k(1,y) \\nabla u_m(1,y)) \\cdot (1,0) = - (2+y^2) \\begin{pmatrix} e\\sin(\\pi y) \\\\ \\pi e\\cos(\\pi y) \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = -(2+y^2)e\\sin(\\pi y)$。\n  - 在顶边（$y=1$）上：$\\boldsymbol{n} = (0,1)$。\n    $h(x,1) = -(k(x,1) \\nabla u_m(x,1)) \\cdot (0,1) = - (2+x) \\begin{pmatrix} 0 \\\\ -\\pi \\exp(x) \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = (2+x)\\pi\\exp(x)$。\n  - 在左边（$x=0$）上：$\\boldsymbol{n} = (-1,0)$。\n    $h(0,y) = -(k(0,y) \\nabla u_m(0,y)) \\cdot (-1,0) = - (1+y^2) \\begin{pmatrix} \\sin(\\pi y) \\\\ \\pi \\cos(\\pi y) \\end{pmatrix} \\cdot \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} = (1+y^2)\\sin(\\pi y)$。\n\n任务3：最小光滑性假设\n我们在弱解的背景下分析每个项良定义所需的正则性。\n\n- 为使源项 $f = -\\nabla \\cdot (k \\nabla u_m)$ 属于 $L^2(\\Omega)$：\n该项可以展开为 $f = -(\\nabla k \\cdot \\nabla u_m + k \\nabla^2 u_m)$。为使 $f$ 是平方可积的，和中的每一项都必须是。一组标准的充分条件是 $u_m$ 属于索博列夫（Sobolev）空间 $H^2(\\Omega)$ 且 $k$ 属于 $W^{1,\\infty}(\\Omega)$。空间 $H^2(\\Omega)$ 由其所有一阶和二阶偏导数都属于 $L^2(\\Omega)$ 的函数组成。空间 $W^{1,\\infty}(\\Omega)$ 由利普希茨（Lipschitz）连续函数组成，意味着 $k$ 有界且其一阶导数本质有界。在这些假设下，$\\nabla^2 u_m \\in L^2(\\Omega)$ 且 $k \\in L^\\infty(\\Omega)$，所以它们的乘积 $k \\nabla^2 u_m \\in L^2(\\Omega)$。同样，$\\nabla u_m \\in (H^1(\\Omega))^2$，根据二维中的索博列夫嵌入定理，它被包含在 $(L^p(\\Omega))^2$ 中，对于任何有限的 $p \\geq 1$。由于 $\\nabla k \\in (L^\\infty(\\Omega))^2$，乘积 $\\nabla k \\cdot \\nabla u_m$ 也属于 $L^2(\\Omega)$。因此，如果 $u_m \\in H^2(\\Omega)$ 且 $k \\in W^{1,\\infty}(\\Omega)$，则可以保证 $f \\in L^2(\\Omega)$。\n\n- 为使狄利克雷迹 $g$ 良定义：\n迹定理指出，对于函数 $u_m \\in H^1(\\Omega)$，其在边界 $\\partial\\Omega$ 上的限制（迹）作为空间 $H^{1/2}(\\partial\\Omega)$ 中的一个元素是良定义的。因此，对 $u_m$ 的最小假设是 $u_m \\in H^1(\\Omega)$。\n\n- 为使诺伊曼通量 $h$ 有意义：\n诺伊曼数据 $h = -k \\nabla u_m \\cdot \\boldsymbol{n}$ 是矢量场 $\\boldsymbol{q} = -k \\nabla u_m$ 的法向迹。为了使这个法向迹在一个合适的空间中（通常是 $H^{1/2}(\\partial\\Omega)$ 的对偶空间 $H^{-1/2}(\\partial\\Omega)$）良定义，矢量场 $\\boldsymbol{q}$ 必须属于空间 $H(\\text{div}, \\Omega)$。该空间由 $(L^2(\\Omega))^2$ 中其散度也在 $L^2(\\Omega)$ 中的矢量场组成。如果 $k \\in L^\\infty(\\Omega)$ 且 $u_m \\in H^1(\\Omega)$，则条件 $\\boldsymbol{q} = -k \\nabla u_m \\in (L^2(\\Omega))^2$ 得到满足。条件 $\\nabla \\cdot \\boldsymbol{q} \\in L^2(\\Omega)$ 等价于要求 $f \\in L^2(\\Omega)$。如上所述，这需要更高的正则性，即 $u_m \\in H^2(\\Omega)$ 和 $k \\in W^{1,\\infty}(\\Omega)$。因此，在这一标准泛函分析设置中，这些是为使诺伊曼通量良定义而对 $u_m$ 和 $k$ 提出的最小假设。", "answer": "$$\n\\boxed{\\left[ \\pi^2(1+x+y^2) - (2+x+y^2) \\right]\\exp(x)\\sin(\\pi y) - 2\\pi y \\exp(x)\\cos(\\pi y)}\n$$", "id": "2576877"}, {"introduction": "制造解的选择可以成为诊断数值方案特定性质的有力工具。本练习 [@problem_id:2444972] 使用了一个二次多项式解，它与标准的二阶离散格式有着特殊的关系。通过解决这个问题，你将亲眼见证截断误差如何消失，从而得到一个在机器精度内完全精确的数值解，这为代码实现的正确性提供了一个精确而严格的测试。", "problem": "考虑单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松问题，其带有狄利克雷边界条件。您需要应用制造解方法进行代码验证，具体如下。设制造解为二次多项式\n$$\nu_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,\n$$\n其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 是实常数。定义源项 $s(x,y)$，使得 $u_m$ 精确满足带有负拉普拉斯算子的泊松方程，\n$$\n- \\Delta u(x,y) = s(x,y) \\quad \\text{in } \\Omega,\n$$\n以及狄利克雷边界条件\n$$\nu(x,y) = u_m(x,y) \\quad \\text{for } (x,y) \\in \\partial \\Omega.\n$$\n使用标准的二阶中心有限差分格式，在均匀的笛卡尔网格上对 $- \\Delta$ 进行离散化。该网格在每个空间方向上有 $N$ 个内部节点，网格间距为 $h = \\frac{1}{N+1}$。设内部网格点为 $\\{(x_i,y_j)\\}_{i,j=1}^N$，其中 $x_i = i h$ 且 $y_j = j h$。对于每个内部节点 $(i,j)$，需要执行的离散内部方程为：\n$$\n\\frac{-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j}}{h^2} = s(x_i,y_j),\n$$\n其狄利克雷边界值由 $\\partial \\Omega$ 上的 $u_m$ 指定。此处 $u_{i,j}$ 表示 $u(x_i,y_j)$ 的离散近似值。\n\n对于下方的每个测试用例，计算包括边界节点在内的整个网格上的离散解，然后报告最大绝对节点误差\n$$\nE_\\infty = \\max_{0 \\le i \\le N+1,\\; 0 \\le j \\le N+1} \\left| u_{i,j} - u_m(x_i,y_j) \\right|.\n$$\n不涉及物理单位。如果出现任何角度，都必须以弧度为单位进行解释，但此处不需要。\n\n测试套件（每个用例为 $(N, a, b, c, d, e, f)$）：\n- 用例 1：$(\\,10,\\, 1.0,\\, 0.5,\\, 2.0,\\, -1.0,\\, 0.25,\\, -0.75\\,)$\n- 用例 2：$(\\,15,\\, 0.0,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.0\\,)$\n- 用例 3：$(\\,8,\\, 0.0,\\, 0.0,\\, 0.0,\\, -2.0,\\, 1.5,\\, 0.1\\,)$\n- 用例 4：$(\\,12,\\, -0.7,\\, 0.0,\\, 0.4,\\, 0.0,\\, 0.0,\\, 2.0\\,)$\n\n您的程序必须按以上列出的顺序为每个用例计算 $E_\\infty$，并生成单行输出，其中包含四个结果，以逗号分隔，并用方括号括起来，例如“[$r_1$,$r_2$,$r_3$,$r_4$]”。每个 $r_k$ 都必须是浮点数。不允许任何其他输出。", "solution": "用户提供了一个计算工程问题，要求应用制造解方法（MMS）进行代码验证。任务是计算二维泊松方程有限差分解的最大节点误差，其中精确解是一个选定的制造多项式。\n\n**问题验证**\n\n首先，我必须对问题进行严格验证。\n\n**步骤1：提取已知条件**\n- **控制方程**：二维泊松方程 $-\\Delta u(x,y) = s(x,y)$，定义在 $\\Omega = [0,1] \\times [0,1]$ 上。\n- **制造解**：$u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。\n- **源项**：$s(x,y)$ 从 $-\\Delta u_m(x,y)$ 推导而来。\n- **边界条件**：狄利克雷边界条件，$u(x,y) = u_m(x,y)$ on $\\partial \\Omega$。\n- **离散化**：均匀网格上的二阶中心有限差分格式。\n- **网格**：每个方向有 $N$ 个内部节点，间距 $h = 1/(N+1)$。网格点 $(x_i, y_j) = (ih, jh)$。\n- **离散方程**：对于内部节点 $i,j \\in \\{1, \\dots, N\\}$，$\\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = s(x_i,y_j)$。\n- **误差度量**：$E_\\infty = \\max_{0 \\le i,j \\le N+1} | u_{i,j} - u_m(x_i,y_j) |$。\n- **测试用例**：提供了四组参数 $(N, a, b, c, d, e, f)$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础**：该问题在根本上是合理的。它使用了泊松方程、制造解方法和有限差分法，这些都是数值分析和计算工程中的标准概念。\n- **适定性**：该问题是适定的。带有狄利克雷条件的泊松方程有唯一解。由有限差分离散化得到的相应线性系统是非奇异的，并且也有唯一解。计算误差是代码验证中的一个标准程序。\n- **客观性**：该问题使用精确、客观的数学语言陈述，没有歧义或主观成分。\n\n该问题是自洽的、一致的且科学上有效的。所有必要的信息都已提供。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行求解。\n\n**基于原理的求解设计**\n\n这个问题的核心在于理解有限差分格式的截断误差。制造解方法是专门为测试代码实现而设计的，它提供一个已知精确解的问题。\n\n1.  **源项的推导**：\n    制造解为 $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。我们必须首先计算其拉普拉斯算子来定义源项 $s(x,y) = -\\Delta u_m(x,y)$。\n    偏导数是：\n    $\\frac{\\partial u_m}{\\partial x} = 2ax + by + d$\n    $\\frac{\\partial^2 u_m}{\\partial x^2} = 2a$\n    $\\frac{\\partial u_m}{\\partial y} = bx + 2cy + e$\n    $\\frac{\\partial^2 u_m}{\\partial y^2} = 2c$\n    拉普拉斯算子是 $\\Delta u_m = \\frac{\\partial^2 u_m}{\\partial x^2} + \\frac{\\partial^2 u_m}{\\partial y^2} = 2a + 2c$。\n    因此，源项是一个常数：$s(x,y) = -(2a + 2c)$。\n\n2.  **截断误差分析**：\n    负拉普拉斯算子的离散算子是 $L_h u_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}$。\n    该算子的截断误差 $\\tau$ 由 $\\tau = L_h u - (-\\Delta u)$ 给出。对于一个足够光滑的函数 $u$，泰勒级数展开表明 $\\tau = -\\frac{h^2}{12}(\\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4}) + \\mathcal{O}(h^4)$。\n    该格式是二阶精确的。然而，对于我们的特定制造解 $u_m(x,y)$，它是一个二次多项式，所有三阶或更高阶的偏导数都恒为零。\n    具体来说，$\\frac{\\partial^4 u_m}{\\partial x^4} = 0$ 且 $\\frac{\\partial^4 u_m}{\\partial y^4} = 0$。\n    这意味着截断误差的主项为零。实际上，所有高阶项也为零。对于二次多项式，截断误差精确为零：$\\tau = 0$。\n    这意味着当应用于任何二次多项式时，有限差分算子能精确地再现连续微分算子：\n    $$\n    L_h u_m(x_i, y_j) = -\\Delta u_m(x_i, y_j) = s(x_i, y_j)\n    $$\n    这个恒等式是解决此问题的关键。它表明，在网格点上求值的制造解是离散方程组的精确解。\n\n3.  **数值实现策略**：\n    任务是计算离散解 $u_{i,j}$ 并将其与精确解 $u_m(x_i, y_j)$ 进行比较。步骤如下：\n    a.  **网格设置**：定义一个包含 $(N+2) \\times (N+2)$ 个点的均匀网格，覆盖域 $[0,1] \\times [0,1]$。\n    b.  **系统构建**：为内部网格点上的 $N^2$ 个未知值构建线性系统 $A \\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 表示五点模板的系数（对角线上为 4，相邻点为 -1）。向量 $\\mathbf{b}$ 包含源项值 $h^2 s(x_i,y_j)$ 和从 $u_m$ 得到的已知边界值。\n    c.  **系统求解**：求解稀疏线性系统，得到内部未知数向量 $\\mathbf{u}$。\n    d.  **误差计算**：通过将解出的内部值与指定的边界值相结合，重构完整的解网格 $u_{i,j}$。然后，计算此数值解与在网格上求值的制造解之间的最大绝对差：$E_\\infty = \\max |u_{i,j} - u_m(x_i,y_j)|$。\n\n    鉴于截断误差为零，数值解 $u_{i,j}$ 在所有网格点上都必须与 $u_m(x_i,y_j)$ 相同，直至浮点精度的极限。因此，预期的误差 $E_\\infty$ 将是一个非常小的数，量级约为机器精度。一个非零的结果将表明线性系统求解器或问题设置的实现中存在错误。所提供的代码稳健地实现了这一过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (N, a, b, c, d, e, f)\n        (10, 1.0, 0.5, 2.0, -1.0, 0.25, -0.75),\n        (15, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0),\n        (8, 0.0, 0.0, 0.0, -2.0, 1.5, 0.1),\n        (12, -0.7, 0.0, 0.4, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b, c, d, e, f = case\n        error = calculate_max_error(N, a, b, c, d, e, f)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_error(N, a, b, c, d, e, f):\n    \"\"\"\n    Calculates the maximum absolute nodal error for a single test case by\n    setting up and solving the discrete Poisson equation.\n    \"\"\"\n    h = 1.0 / (N + 1)\n\n    # 1. Set up the grid and coordinates.\n    # The grid is indexed by (j, i) corresponding to (y, x) for standard\n    # row-major array ordering.\n    x_coords = np.linspace(0.0, 1.0, N + 2)\n    y_coords = np.linspace(0.0, 1.0, N + 2)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # 2. Define manufactured solution and evaluate on the grid.\n    u_m_func = lambda x, y: a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n    u_m_grid = u_m_func(X, Y)\n\n    # The source term s(x,y) = -Laplacian(u_m) = -(2a + 2c) is a constant.\n    s_val = -(2*a + 2*c)\n\n    # 3. Set up the linear system A*u = b for interior nodes.\n    # The N*N unknowns correspond to interior grid points, flattened using\n    # row-major ordering: k = (j-1)*N + (i-1).\n    \n    # Construct the sparse matrix A for the 5-point stencil:\n    # 4*u_ji - u_{j,i-1} - u_{j,i+1} - u_{j-1,i} - u_{j+1,i}\n    \n    d_main = np.full(N*N, 4.0)\n    d_h_off = np.full(N*N - 1, -1.0)\n    d_v_off = np.full(N*N - N, -1.0)\n    \n    # Zero out connections between the end of a grid row and the start of the next.\n    for j in range(1, N):\n        d_h_off[j*N - 1] = 0.0\n    \n    diagonals = [d_main, d_h_off, d_h_off, d_v_off, d_v_off]\n    offsets = [0, -1, 1, -N, N]\n    A = diags(diagonals, offsets, shape=(N*N, N*N), format='csr')\n\n    # 4. Construct the RHS vector b.\n    b = np.zeros(N*N)\n    for j in range(1, N + 1):      # y-index on grid\n        for i in range(1, N + 1):  # x-index on grid\n            k = (j - 1) * N + (i - 1)  # row-major vector index\n            \n            # Source term contribution\n            b[k] = h**2 * s_val\n            \n            # Add contributions from known boundary values\n            if i == 1:   # Left boundary (x=0)\n                b[k] += u_m_grid[j, 0]\n            if i == N:   # Right boundary (x=1)\n                b[k] += u_m_grid[j, N+1]\n            if j == 1:   # Bottom boundary (y=0)\n                b[k] += u_m_grid[0, i]\n            if j == N:   # Top boundary (y=1)\n                b[k] += u_m_grid[N+1, i]\n\n    # 5. Solve the linear system for interior node values.\n    u_interior_vec = spsolve(A, b)\n\n    # 6. Reconstruct the full solution grid.\n    u_discrete = np.zeros((N + 2, N + 2))\n    \n    # Set boundary values from manufactured solution\n    u_discrete[0, :] = u_m_grid[0, :]\n    u_discrete[N+1, :] = u_m_grid[N+1, :]\n    u_discrete[:, 0] = u_m_grid[:, 0]\n    u_discrete[:, N+1] = u_m_grid[:, N+1]\n    \n    # Fill interior with the solved values, reshaped according to row-major order.\n    u_discrete[1:N+1, 1:N+1] = u_interior_vec.reshape((N, N), order='C')\n\n    # 7. Calculate the maximum absolute error over the entire grid.\n    error = np.max(np.abs(u_discrete - u_m_grid))\n    \n    return error\n\nsolve()\n\n```", "id": "2444972"}, {"introduction": "使用制造解法进行代码验证的最终目标是确认当网格加密时，数值误差能够以理论预期的速率收敛。本实践 [@problem_id:2444940] 将指导你为一个二维泊松方程求解器完成一个完整的收敛性验证研究。通过在一系列加密的网格上实现求解，并计算观测到的收敛阶 $p$，你将为你的代码实现正确且性能符合预期提供强有力的证据。", "problem": "考虑方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松方程：\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in \\Omega,$$\n其狄利克雷边界条件由一个构造解 $u_{m}(x,y)$ 给出：\n$$u(x,y)\\big|_{\\partial \\Omega} = u_{m}(x,y),$$\n其中\n$$u_{m}(x,y) = \\sin(\\pi x)\\,\\cosh(y) + x^2 y^3.$$\n所有三角函数的参数都必须以弧度为单位进行解释。\n\n您的任务是使用构造解方法来验证一个泊松方程的数值求解器。具体来说：\n- 通过对构造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2$，精确推导源项 $f(x,y)$。\n- 对于指定的 $N$ 值，在包含边界的 $N \\times N$ 个节点的均匀笛卡尔网格上，使用推导出的 $f(x,y)$ 求解该边值问题。\n- 在每个网格上，通过在 $\\partial \\Omega$ 上设置 $u(x,y)$ 等于 $u_{m}(x,y)$ 来精确地施加狄利克雷边界条件。\n- 将计算出的数值解 $u_{\\text{num}}$ 与网格节点上的精确构造解 $u_{m}$进行比较，以量化误差。\n\n对于一个具有 $N \\times N$ 个节点和均匀间距 $h = 1/(N-1)$ 的网格，定义以下误差度量：\n- 所有网格节点上的离散最大范数（无穷范数）：\n$$E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} \\left| u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right|.$$\n- 所有网格节点上的离散 $L^2$ 范数：\n$$E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right)^2 \\, h^2 \\right)^{1/2}.$$\n\n使用离散 $L^2$ 误差计算两种尺寸分别为 $N_1$ 和 $N_2$（其中 $N_2 = 2N_1 - 1$，使得网格间距减半）的网格之间的观测精度阶 $p$：\n$$p = \\frac{\\log\\left( \\dfrac{E_{2}(N_1)}{E_{2}(N_2)} \\right)}{\\log(2)}.$$\n\n角度单位说明：所有角度均为弧度。\n\n测试套件及要求的输出：\n- 测试用例 $1$：$N = 3$。报告 $E_{\\infty}(3)$。\n- 测试用例 $2$：$N = 9$。报告 $E_{2}(9)$。\n- 测试用例 $3$：$N_1 = 17$ 和 $N_2 = 33$。根据上述公式，由 $E_{2}(17)$ 和 $E_{2}(33)$ 计算并报告观测到的精度阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序为 $[E_{\\infty}(3), E_{2}(9), p]$。\n- 每个数值条目必须格式化为小数点后有 $10$ 位数字的十进制数。\n- 例如，一个有效的输出行格式为：$[0.1234567890,0.0123456789,1.9876543210]$。", "solution": "所述问题构成了一项适定且具有科学依据的任务，用于验证数值方法的有效性。它遵循了计算工程中既定的原则，特别是使用构造解方法来验证泊松方程有限差分求解器的实现。所有必要的数据、方程和定义均已提供，且不存在内部矛盾或与科学事实相悖之处。因此，该问题是有效的，并将构建一个解决方案。\n\n该方法论包括两个主要阶段：首先，解析推导构造解所需的源项；其次，对得到的边值问题进行数值求解并计算误差度量。\n\n首先，我们通过对指定的构造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 来推导源项 $f(x,y)$。\n给定的构造解为：\n$$u_{m}(x,y) = \\sin(\\pi x)\\cosh(y) + x^2 y^3$$\n我们计算关于 $x$ 和 $y$ 的偏导数。\n关于 $x$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial x} = \\pi \\cos(\\pi x)\\cosh(y) + 2x y^3 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3 $$\n关于 $y$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial y} = \\sin(\\pi x)\\sinh(y) + 3x^2 y^2 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial y^2} = \\sin(\\pi x)\\cosh(y) + 6x^2 y $$\n源项 $f(x,y)$ 是这些二阶导数的和：\n$$ f(x,y) = \\nabla^2 u_{m} = \\frac{\\partial^2 u_{m}}{\\partial x^2} + \\frac{\\partial^2 u_{m}}{\\partial y^2} $$\n$$ f(x,y) = \\left(-\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3\\right) + \\left(\\sin(\\pi x)\\cosh(y) + 6x^2 y\\right) $$\n合并各项得到精确的源函数：\n$$ f(x,y) = (1 - \\pi^2)\\sin(\\pi x)\\cosh(y) + 6x^2 y + 2y^3 $$\n\n其次，我们在一个覆盖域 $\\Omega = [0,1] \\times [0,1]$ 的 $N \\times N$ 个节点的均匀笛卡尔网格上求解泊松方程 $\\nabla^2 u(x,y) = f(x,y)$。网格坐标为 $x_j = j h$ 和 $y_i = i h$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 1/(N-1)$。令 $U_{i,j}$ 表示 $u(y_i, x_j)$ 的数值近似。在每个内部节点 $(y_i, x_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$），使用二阶中心有限差分格式来近似拉普拉斯算子：\n$$ \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} + \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} = f(y_i, x_j) $$\n重排此格式，得到每个内部节点的线性方程：\n$$ U_{i,j-1} + U_{i,j+1} + U_{i-1,j} + U_{i+1,j} - 4U_{i,j} = h^2 f(y_i, x_j) $$\n这组针对 $(N-2)^2$ 个未知内部节点值的 $(N-2)^2$ 个方程构成了一个形式为 $A \\mathbf{u} = \\mathbf{b}$ 的线性系统。向量 $\\mathbf{u}$ 包含了未知值 $U_{i,j}$，例如按行主序排列。矩阵 $A$ 是一个稀疏的块三对角矩阵，表示有限差分格式的连通性。右侧向量 $\\mathbf{b}$ 包含了根据已知边界条件调整后的 $h^2 f(y_i, x_j)$ 的值。对于一个与边界相邻的内部节点 $(y_i, x_j)$，格式中的相应项（例如，如果 $i=1$，则为 $U_{0,j}$）是一个来自狄利克雷条件的已知值 $u_m(y_0, x_j)$，并被移到方程的右侧。\n\n完整的数值解 $u_{\\text{num}}$ 是通过求解此线性系统得到内部节点值，并将其与由 $u_m(x,y)$ 指定的精确边界值组合而成的。\n\n误差使用指定的离散范数进行量化。离散最大范数 $E_{\\infty}(N)$ 计算如下：\n$$ E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} | u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) | $$\n离散 $L^2$ 范数 $E_{2}(N)$ 计算如下：\n$$ E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} ( u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) )^2 h^2 \\right)^{1/2} $$\n然后，通过比较两个相继加密的网格（$N_1$ 和 $N_2=2N_1-1$，这对应于将网格间距 $h$ 减半）上的 $L^2$ 误差来计算观测精度阶 $p$：\n$$ p = \\frac{\\log( E_{2}(N_1) / E_{2}(N_2) )}{\\log(2)} $$\n该值预期约为 $2$，这与有限差分格式的二阶精度相符。\n\n实现过程将为指定的 $N$ 值（$N=3, 9, 17, 33$）构建并求解该线性系统，以计算所需的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    \n    # Define PI for use in trigonometric functions.\n    PI = np.pi\n\n    def u_m(x, y):\n        \"\"\"\n        Computes the manufactured solution u_m(x,y).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        return np.sin(PI * x) * np.cosh(y) + x**2 * y**3\n\n    def f_source(x, y):\n        \"\"\"\n        Computes the source term f(x,y) derived from grad^2(u_m).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        term1 = (1.0 - PI**2) * np.sin(PI * x) * np.cosh(y)\n        term2 = 6.0 * x**2 * y\n        term3 = 2.0 * y**3\n        return term1 + term2 + term3\n\n    def solve_poisson(N):\n        \"\"\"\n        Solves the Poisson equation on an N x N grid using finite differences.\n        \n        Args:\n            N (int): The number of nodes along one dimension of the grid.\n\n        Returns:\n            tuple: A tuple containing:\n                - u_num (np.ndarray): The N x N numerical solution array.\n                - u_exact (np.ndarray): The N x N exact manufactured solution array.\n                - h (float): The grid spacing.\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Grid size N must be at least 2.\")\n        if N == 2: # No interior points\n            h = 1.0\n            x = np.linspace(0.0, 1.0, N)\n            y = np.linspace(0.0, 1.0, N)\n            xx, yy = np.meshgrid(x, y, indexing='xy')\n            u_exact = u_m(xx, yy)\n            return u_exact, u_exact, h\n\n        # 1. Grid setup\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # 2. Evaluate exact solution and source term\n        u_exact = u_m(xx, yy)\n        f_vals = f_source(xx, yy)\n\n        # 3. Setup linear system Ax = b for interior points\n        num_interior_nodes_1d = N - 2\n        num_unknowns = num_interior_nodes_1d**2\n        \n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # The mapping from 2D interior grid index (i_int, j_int) to 1D vector index k\n        # is row-major: k = i_int * num_interior_nodes_1d + j_int\n        # This corresponds to full grid index (i, j) where i = i_int + 1, j = j_int + 1\n        for k in range(num_unknowns):\n            i_int = k // num_interior_nodes_1d\n            j_int = k % num_interior_nodes_1d\n            \n            i = i_int + 1\n            j = j_int + 1\n\n            # Main diagonal coefficient for -4*U_ij\n            A[k, k] = -4.0\n\n            # Right-hand side from source term f(y_i, x_j)\n            b[k] = h**2 * f_vals[i, j]\n\n            # Neighbor contribution (x-direction, j-1)\n            if j == 1:\n                b[k] -= u_exact[i, 0]\n            else:\n                A[k, k - 1] = 1.0\n\n            # Neighbor contribution (x-direction, j+1)\n            if j == N - 2:\n                b[k] -= u_exact[i, N - 1]\n            else:\n                A[k, k + 1] = 1.0\n\n            # Neighbor contribution (y-direction, i-1)\n            if i == 1:\n                b[k] -= u_exact[0, j]\n            else:\n                A[k, k - num_interior_nodes_1d] = 1.0\n\n            # Neighbor contribution (y-direction, i+1)\n            if i == N - 2:\n                b[k] -= u_exact[N - 1, j]\n            else:\n                A[k, k + num_interior_nodes_1d] = 1.0\n\n        # 4. Solve the linear system\n        u_interior_flat = np.linalg.solve(A, b)\n        u_interior = u_interior_flat.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n\n        # 5. Construct the full numerical solution grid\n        u_num = np.copy(u_exact)  # Initialize with correct boundary values\n        u_num[1:N-1, 1:N-1] = u_interior\n\n        return u_num, u_exact, h\n\n    # Test case 1: N = 3, compute E_infinity\n    u_num_3, u_exact_3, _ = solve_poisson(N=3)\n    e_inf_3 = np.max(np.abs(u_num_3 - u_exact_3))\n\n    # Test case 2: N = 9, compute E_2\n    u_num_9, u_exact_9, h_9 = solve_poisson(N=9)\n    e_2_9 = np.sqrt(np.sum((u_num_9 - u_exact_9)**2) * h_9**2)\n\n    # Test case 3: N1=17, N2=33, compute order of accuracy p\n    # Compute E_2 for N=17\n    u_num_17, u_exact_17, h_17 = solve_poisson(N=17)\n    e_2_17 = np.sqrt(np.sum((u_num_17 - u_exact_17)**2) * h_17**2)\n    \n    # Compute E_2 for N=33\n    u_num_33, u_exact_33, h_33 = solve_poisson(N=33)\n    e_2_33 = np.sqrt(np.sum((u_num_33 - u_exact_33)**2) * h_33**2)\n    \n    # Compute order of accuracy p\n    p = np.log(e_2_17 / e_2_33) / np.log(2.0)\n    \n    # Compile and format results\n    results = [e_inf_3, e_2_9, p]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10f}' for x in results)}]\")\n\nsolve()\n```", "id": "2444940"}]}