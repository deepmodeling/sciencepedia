{"hands_on_practices": [{"introduction": "本章的第一个练习将引导你完成一个基础但至关重要的计算。通过一个简单的一维泊松问题，你将亲手推导并计算经典的基于残差的后验误差估计子。这个实践旨在帮助你直观地理解单元内部残差和单元间通量跳跃是如何构成总误差度量的，以及如何通过计算效率指数来评估其性能 [@problem_id:2539270]。", "problem": "考虑在 $(0,1)$ 上的边值问题 $-u''=1$，其齐次狄利克雷边界条件为 $u(0)=u(1)=0$。令 $V:=H_{0}^{1}(0,1)$，并令 $u\\in V$ 表示其精确解。设 $\\{\\mathcal{T}_h\\}$ 为 $(0,1)$ 上的一族均匀网格，包含 $N\\in\\mathbb{N}$ 个尺寸为 $h=1/N$ 的单元，并设 $V_h\\subset V$ 是与 $\\mathcal{T}_h$ 相关联的协调分片线性有限元空间。设 $u_h\\in V_h$ 为 $V_h$ 中弱问题的伽辽金解。从弱残差及其通过分部积分的局部化出发，构造一个标准的基于残差的后验误差估计子，该估计子由带网格尺寸缩放的单元（体积）残差和单元间法向通量跳跃构成。以仅含 $N$ 的闭式表达式，计算以下两者：\n- 全局的基于残差的估计子 $\\eta(N)$，\n- 精确的能量范数误差 $\\|u-u_h\\|_{H_{0}^{1}(0,1)}$。\n然后构建效率指数 $\\theta(N):=\\eta(N)\\big/\\|u-u_h\\|_{H_{0}^{1}(0,1)}$。\n\n你的最终答案应为一个仅含 $N$ 的单个闭式表达式（无数值舍入）。", "solution": "所陈述的问题是有效的。这是一个偏微分方程数值分析中的适定典范问题，具体属于有限元方法后验误差估计的范畴。所有组成部分都定义清晰且在数学上是合理的。我们将着手求解。\n\n该边值问题为：\n$$ -u'' = 1 \\quad \\text{在 } (0,1)\\text{上}, \\quad u(0)=u(1)=0 $$\n弱形式所用的空间是 $V := H_{0}^{1}(0,1)$。弱形式是找到 $u \\in V$，使得\n$$ a(u,v) = L(v) \\quad \\forall v \\in V, $$\n其中双线性形式 $a(u,v)$ 和线性泛函 $L(v)$ 由下式给出：\n$$ a(u,v) := \\int_{0}^{1} u'(x) v'(x) \\, dx, \\quad L(v) := \\int_{0}^{1} 1 \\cdot v(x) \\, dx $$\n与此问题相关联的能量范数是 $\\|v\\|_{H_{0}^{1}(0,1)} = (\\int_{0}^{1} (v'(x))^2 \\, dx)^{1/2} = \\|v'\\|_{L^2(0,1)}$。\n\n首先，我们求精确解 $u(x)$。对 $-u''=1$ 积分两次得到 $u(x) = -\\frac{1}{2}x^2 + C_1 x + C_2$。应用边界条件 $u(0)=0$ 和 $u(1)=0$ 可得 $C_2=0$ 和 $C_1=\\frac{1}{2}$。因此，精确解为\n$$ u(x) = \\frac{1}{2}x(1-x) $$\n精确解的导数是 $u'(x) = \\frac{1}{2} - x$。\n\n接下来，我们刻画伽辽金解 $u_h \\in V_h$。空间 $V_h$ 由定义在均匀网格上的连续分片线性函数组成，其节点为 $x_i = i h$，其中 $i=0, \\dots, N$，$h=1/N$。伽辽金问题是：找到 $u_h \\in V_h$ 使得\n$$ a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h $$\n对于这个特定问题，有限元解 $u_h$ 在网格节点上插值精确解 $u$：对所有 $i=0, \\dots, N$ 均有 $u_h(x_i) = u(x_i)$。在每个单元 $T_i := [x_{i-1}, x_i]$ 上，$u_h$ 是线性的，所以其导数 $u_h'$ 是一个常数。该常数为\n$$ u_h'(x)|_{T_i} = \\frac{u_h(x_i) - u_h(x_{i-1})}{h} = \\frac{u(ih) - u((i-1)h)}{h} $$\n代入 $u(x)$ 的表达式：\n$$ u_h'(x)|_{T_i} = \\frac{1}{h} \\left( \\frac{1}{2}ih(1-ih) - \\frac{1}{2}(i-1)h(1-(i-1)h) \\right) = \\frac{1}{2} (1 - (2i-1)h) $$\n该值等于精确解的导数 $u'(x)$ 在单元中点 $x_{i-1/2} = (i-1/2)h$ 处的值。\n\n现在我们计算精确的能量范数误差，$\\|u-u_h\\|_{H_{0}^{1}(0,1)}$。\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)}^2 = \\int_{0}^{1} (u'(x) - u_h'(x))^2 \\, dx = \\sum_{i=1}^{N} \\int_{x_{i-1}}^{x_i} (u'(x) - u_h'(x))^2 \\, dx $$\n在单元 $T_i$ 上，被积函数为：\n$$ (u'(x) - u_h'(x))^2 = \\left( \\left(\\frac{1}{2} - x\\right) - \\frac{1}{2}(1 - (2i-1)h) \\right)^2 = \\left( (i-1/2)h - x \\right)^2 $$\n令 $s = x - (i-1/2)h$。在 $T_i$ 上的积分变为：\n$$ \\int_{-h/2}^{h/2} s^2 \\, ds = \\left[ \\frac{s^3}{3} \\right]_{-h/2}^{h/2} = \\frac{1}{3} \\left( \\left(\\frac{h}{2}\\right)^3 - \\left(-\\frac{h}{2}\\right)^3 \\right) = \\frac{h^3}{12} $$\n这个结果对所有 $N$ 个单元都是相同的。将这些贡献相加，得到总的误差平方：\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)}^2 = \\sum_{i=1}^{N} \\frac{h^3}{12} = N \\frac{h^3}{12} = N \\frac{(1/N)^3}{12} = \\frac{1}{12N^2} $$\n因此，精确误差为：\n$$ \\|u-u_h\\|_{H_{0}^{1}(0,1)} = \\sqrt{\\frac{1}{12N^2}} = \\frac{1}{2\\sqrt{3}N} $$\n\n接下来，我们构造标准的基于残差的后验误差估计子。误差 $e = u-u_h$ 满足伽辽金正交性条件 $a(e, v_h)=0$，对所有 $v_h \\in V_h$ 成立。对于任意 $v \\in V$，误差方程为 $a(e,v) = L(v) - a(u_h,v)$。该方程的右端项是弱残差。通过逐单元分部积分，可以写成：\n$$ L(v) - a(u_h,v) = \\sum_{i=1}^{N} \\int_{T_i} (1+u_h''(x)) v(x) \\, dx + \\sum_{i=1}^{N-1} \\llbracket -u_h' \\rrbracket(x_i) v(x_i) $$\n其中 $R_{T_i} = 1+u_h''|_{T_i}$ 是单元残差，$J_i = \\llbracket -u_h' \\rrbracket(x_i)$ 是内部节点 $x_i$ 处的跳跃残差。\n标准的估计子是通过计算这些残差分量的范数并用单元尺寸 $h$ 的幂次进行缩放来构建的。估计子的平方为：\n$$ \\eta^2 = \\sum_{i=1}^{N} h^2 \\|R_{T_i}\\|_{L^2(T_i)}^2 + \\sum_{i=1}^{N-1} h |\\llbracket u_h' \\rrbracket(x_i)|^2 $$\n我们计算各个分量。由于 $u_h$ 在每个单元 $T_i$ 上是线性的，因此 $u_h''=0$。所以，单元残差 $R_{T_i} = 1$。其 $L^2$-范数的平方是：\n$$ \\|R_{T_i}\\|_{L^2(T_i)}^2 = \\int_{x_{i-1}}^{x_i} 1^2 \\, dx = h $$\n在内部节点 $x_i$ 处导数的跳跃是：\n$$ \\llbracket u_h' \\rrbracket(x_i) = u_h'(x)|_{T_{i+1}} - u_h'(x)|_{T_i} = \\frac{1}{2}(1 - (2(i+1)-1)h) - \\frac{1}{2}(1 - (2i-1)h) $$\n$$ = \\frac{1}{2}(1 - (2i+1)h - 1 + (2i-1)h) = \\frac{1}{2}(-2h) = -h $$\n体积残差的平方和为：\n$$ \\sum_{i=1}^{N} h^2 \\|R_{T_i}\\|_{L^2(T_i)}^2 = \\sum_{i=1}^{N} h^2 \\cdot h = N h^3 $$\n跳跃残差的平方和为：\n$$ \\sum_{i=1}^{N-1} h |\\llbracket u_h' \\rrbracket(x_i)|^2 = \\sum_{i=1}^{N-1} h(-h)^2 = (N-1)h^3 $$\n总估计子的平方是这两部分之和：\n$$ \\eta^2 = N h^3 + (N-1)h^3 = (2N-1)h^3 $$\n代入 $h=1/N$：\n$$ \\eta(N)^2 = \\frac{2N-1}{N^3} \\implies \\eta(N) = \\sqrt{\\frac{2N-1}{N^3}} $$\n\n最后，我们计算效率指数 $\\theta(N) = \\eta(N) / \\|u-u_h\\|_{H_{0}^{1}(0,1)}$：\n$$ \\theta(N) = \\frac{\\sqrt{\\frac{2N-1}{N^3}}}{\\frac{1}{2\\sqrt{3}N}} = 2\\sqrt{3}N \\sqrt{\\frac{2N-1}{N^3}} = 2\\sqrt{3} \\sqrt{\\frac{N^2(2N-1)}{N^3}} $$\n$$ \\theta(N) = 2\\sqrt{3} \\sqrt{\\frac{2N-1}{N}} = \\sqrt{12 \\left(2 - \\frac{1}{N}\\right)} = \\sqrt{\\frac{12(2N-1)}{N}} $$", "answer": "$$\\boxed{\\sqrt{\\frac{12(2N-1)}{N}}}$$", "id": "2539270"}, {"introduction": "在掌握了基本估计子的概念后，我们将探索一种更强大的技术，即获得误差的保证上界和下界。这个练习要求你构建一个满足平衡条件的通量，并利用残差的对偶范数来严格地框定真实误差。通过这个过程，你将体验到如何从一个简单的误差指示发展到一种更严格的误差控制形式 [@problem_id:2539225]。", "problem": "考虑区间 $[0,1]$ 上的带齐次狄利克雷边界条件的一维泊松问题：求 $u \\in H_0^1(0,1)$ 使得在 $(0,1)$ 内有 $-u'' = f$，且 $u(0) = u(1) = 0$，其中 $f(x) = 1$。设 $u_h \\in V_h \\subset H_0^1(0,1)$ 是在节点为 $x=0$、$x = \\tfrac{1}{2}$ 和 $x=1$ 的均匀网格上的协调分片线性有限元法 (Finite Element Method (FEM)) 近似解。\n\n从弱形式、能量范数 $\\|v\\|_E := \\|v'\\|_{L^2(0,1)}$ 的定义、以及通过分部积分和边界条件推导出的平衡通量和残差对偶范数的概念出发，完成以下任务：\n\n1) 计算有限元法解 $u_h$ 及其分片常数导数 $u_h'$。\n\n2) 构造一个容许通量场 $q \\in H^1(0,1)$，使其在 $(0,1)$ 内满足局部平衡条件 $q' + f = 0$。仅利用此平衡条件和源于弱形式的 $L^2$ 最小化原理，确定使 $\\|q - u_h'\\|_{L^2(0,1)}$ 最小的 $q$。并用此结果给出一个能量范数误差 $\\|u' - u_h'\\|_{L^2(0,1)}$ 的保证上限。\n\n3) 利用由弱形式定义的残差泛函 $R(w)$ 和通过分部积分得到的能量误差的对偶范数刻画，选择一个在单元上具有支撑的显式非零函数 $w \\in H_0^1(0,1)$，从而得到 $\\|u' - u_h'\\|_{L^2(0,1)}$ 的一个可计算的保证下限。精确计算此下限的值。\n\n4) 直接由 $u$ 和 $u_h$ 计算精确的能量范数误差 $\\|u' - u_h'\\|_{L^2(0,1)}$，并验证该误差值位于你所计算的下限和上限之间。\n\n报告能量范数误差 $\\|u' - u_h'\\|_{L^2(0,1)}$ 的精确值作为你的最终答案。不要四舍五入；请给出精确表达式。不需要单位。", "solution": "所提出的问题是关于一维边值问题的有限元法后验误差分析中的一个标准、定义明确的练习。它在数学和科学上是合理的、完整的，并且没有歧义。我将开始解题。\n\n问题是求 $u \\in H_0^1(0,1)$ 使得\n$$\n-u'' = 1 \\quad \\text{在 } (0,1) \\text{ 内}, \\quad u(0) = u(1) = 0.\n$$\n其弱形式为：求 $u \\in H_0^1(0,1)$，使得对所有 $v \\in H_0^1(0,1)$ 都有 $a(u,v) = L(v)$，其中双线性形式为 $a(u,v) = \\int_0^1 u'v' \\,dx$，线性泛函为 $L(v) = \\int_0^1 f v \\,dx$。能量范数为 $\\|v\\|_E = \\sqrt{a(v,v)} = \\|v'\\|_{L^2(0,1)}$。\n\n有限元空间 $V_h$ 由在节点为 $x_0=0$、$x_1=1/2$、$x_2=1$ 的网格上，且在端点处为零的连续分片线性函数构成。该空间是一维的，由以 $x=1/2$ 为中心的帽子函数 $\\phi_{1/2}(x)$ 张成。\n$$\n\\phi_{1/2}(x) = \\begin{cases} 2x & \\text{for } x \\in [0, 1/2] \\\\ 2(1-x) & \\text{for } x \\in [1/2, 1] \\end{cases}\n$$\n其导数为分片常数：\n$$\n\\phi_{1/2}'(x) = \\begin{cases} 2 & \\text{for } x \\in (0, 1/2) \\\\ -2 & \\text{for } x \\in (1/2, 1) \\end{cases}\n$$\n\n**1) 有限元解 $u_h$ 的计算**\n\n有限元解 $u_h(x) = U_{1/2} \\phi_{1/2}(x)$ 可通过求解伽辽金方程 $a(u_h, v_h) = L(v_h)$（对所有 $v_h \\in V_h$）得到。用基函数 $v_h = \\phi_{1/2}$ 进行测试即可。\n$$\na(U_{1/2} \\phi_{1/2}, \\phi_{1/2}) = L(\\phi_{1/2}) \\implies U_{1/2} \\int_0^1 (\\phi_{1/2}')^2 \\,dx = \\int_0^1 f \\phi_{1/2} \\,dx\n$$\n我们计算积分。源项为 $f(x)=1$。\n刚度矩阵项是导数平方的积分：\n$$\n\\int_0^1 (\\phi_{1/2}')^2 \\,dx = \\int_0^{1/2} (2)^2 \\,dx + \\int_{1/2}^1 (-2)^2 \\,dx = 4 \\cdot \\frac{1}{2} + 4 \\cdot \\frac{1}{2} = 4.\n$$\n载荷向量项是基函数的积分：\n$$\n\\int_0^1 1 \\cdot \\phi_{1/2} \\,dx = \\text{Area}(\\phi_{1/2}) = \\frac{1}{2} \\cdot \\text{base} \\cdot \\text{height} = \\frac{1}{2} \\cdot 1 \\cdot 1 = \\frac{1}{2}.\n$$\n将这些值代入伽辽金方程：\n$$\nU_{1/2} \\cdot 4 = \\frac{1}{2} \\implies U_{1/2} = \\frac{1}{8}.\n$$\n有限元解为 $u_h(x) = \\frac{1}{8} \\phi_{1/2}(x)$。其导数是一个分片常数函数：\n$$\nu_h'(x) = \\frac{1}{8} \\phi_{1/2}'(x) = \\begin{cases} \\frac{1}{4} & \\text{for } x \\in (0, 1/2) \\\\ -\\frac{1}{4} & \\text{for } x \\in (1/2, 1) \\end{cases}\n$$\n\n**2) 保证上限**\n\n令 $\\sigma = u'$ 为精确通量。通量的误差为 $e_\\sigma = \\sigma - \\sigma_h = u' - u_h'$。对于任何满足 $q' + f = 0$（即 $-q'=f$）的平衡通量 $q \\in H^1(0,1)$，以下精确误差恒等式成立（这是 Prager-Synge 定理的一个推论）：\n$$\n\\|u' - u_h'\\|_{L^2}^2 + \\|u' - q\\|_{L^2}^2 = \\|q - u_h'\\|_{L^2}^2.\n$$\n该恒等式直接给出了误差能量范数的一个保证上限：\n$$\n\\|u' - u_h'\\|_{L^2} \\le \\|q - u_h'\\|_{L^2}.\n$$\n为从该方法中获得尽可能紧的上限，我们必须找到使 $\\|q - u_h'\\|_{L^2(0,1)}$ 最小化的通量 $q$。条件 $q' = -f = -1$ 意味着 $q(x) = -x + C$，其中 $C$ 为某个常数。我们对泛函 $J(C) = \\|(-x+C) - u_h'\\|_{L^2}^2$ 关于 $C$ 进行最小化：\n$$\n\\frac{dJ}{dC} = \\int_0^1 2 ((-x+C) - u_h'(x)) \\,dx = 0.\n$$\n这意味着 $\\int_0^1 (-x+C) \\,dx = \\int_0^1 u_h'(x) \\,dx$。\n左边是 $\\int_0^1 (-x+C) \\,dx = [-\\frac{x^2}{2} + Cx]_0^1 = -\\frac{1}{2} + C$。\n右边是 $\\int_0^1 u_h'(x) \\,dx = u_h(1) - u_h(0) = 0 - 0 = 0$。\n因此 $C - \\frac{1}{2} = 0 \\implies C = \\frac{1}{2}$。最优通量为 $q(x) = -x + \\frac{1}{2}$。\n上限 $\\eta_{UB}$ 是此最优 $q$ 与 $u_h'$ 之差的范数：\n$$\n\\eta_{UB}^2 = \\|q - u_h'\\|_{L^2}^2 = \\int_0^1 (q(x) - u_h'(x))^2 \\,dx.\n$$\n我们将积分分到两个单元上进行计算：\n$$\n\\eta_{UB}^2 = \\int_0^{1/2} \\left( \\left(-x+\\frac{1}{2}\\right) - \\frac{1}{4} \\right)^2 \\,dx + \\int_{1/2}^1 \\left( \\left(-x+\\frac{1}{2}\\right) - \\left(-\\frac{1}{4}\\right) \\right)^2 \\,dx\n$$\n$$\n\\eta_{UB}^2 = \\int_0^{1/2} \\left(-x+\\frac{1}{4}\\right)^2 \\,dx + \\int_{1/2}^1 \\left(-x+\\frac{3}{4}\\right)^2 \\,dx\n$$\n我们计算积分：\n$$\n\\int_0^{1/2} \\left(x-\\frac{1}{4}\\right)^2 \\,dx = \\left[ \\frac{1}{3}\\left(x-\\frac{1}{4}\\right)^3 \\right]_0^{1/2} = \\frac{1}{3}\\left(\\left(\\frac{1}{4}\\right)^3 - \\left(-\\frac{1}{4}\\right)^3\\right) = \\frac{1}{3}\\left(\\frac{1}{64} + \\frac{1}{64}\\right) = \\frac{2}{192} = \\frac{1}{96}.\n$$\n$$\n\\int_{1/2}^1 \\left(x-\\frac{3}{4}\\right)^2 \\,dx = \\left[ \\frac{1}{3}\\left(x-\\frac{3}{4}\\right)^3 \\right]_{1/2}^1 = \\frac{1}{3}\\left(\\left(\\frac{1}{4}\\right)^3 - \\left(-\\frac{1}{4}\\right)^3\\right) = \\frac{1}{96}.\n$$\n因此，$\\eta_{UB}^2 = \\frac{1}{96} + \\frac{1}{96} = \\frac{2}{96} = \\frac{1}{48}$。保证上限为 $\\eta_{UB} = \\sqrt{\\frac{1}{48}} = \\frac{1}{4\\sqrt{3}} = \\frac{\\sqrt{3}}{12}$。\n\n**3) 保证下限**\n\n误差的能量范数由残差泛函 $R(v) = L(v) - a(u_h,v)$ 的对偶范数给出：\n$$\n\\|u' - u_h'\\|_{L^2} = \\sup_{w \\in H_0^1(0,1), \\|w'\\|_{L^2}=1} |R(w)|.\n$$\n这意味着对于任何非零的 $w \\in H_0^1(0,1)$，我们有一个保证下限：\n$$\n\\|u' - u_h'\\|_{L^2} \\ge \\eta_{LB} = \\frac{|R(w)|}{\\|w'\\|_{L^2}}.\n$$\n一个对 $w$ 的明智选择能将下限与上限的计算联系起来。我们选择 $w \\in H_0^1(0,1)$，使其导数为 $w'(x) = q(x) - u_h'(x)$，其中 $q(x)=-x+1/2$ 是第2部分中的最优通量。\n我们通过检查在 $w(0)=0$ 的条件下是否有 $w(1)=0$ 来验证这是一个有效的选择：\n$$\nw(1) = \\int_0^1 w'(x) \\,dx = \\int_0^1 (q(x) - u_h'(x)) \\,dx = \\int_0^1 q(x) \\,dx - \\int_0^1 u_h'(x) \\,dx.\n$$\n我们已经证明了这两个积分都为零，因此 $w(1)=0$。该函数属于 $H_0^1(0,1)$。\n通过这个选择，下限公式的分母变为 $\\|w'\\|_{L^2} = \\|q-u_h'\\|_{L^2} = \\eta_{UB} = \\frac{\\sqrt{3}}{12}$。\n现在我们计算分子 $R(w)$：\n$$\nR(w) = \\int_0^1 f w \\,dx - \\int_0^1 u_h' w' \\,dx.\n$$\n使用 $f = -q'$ 并对第一项进行分部积分：\n$$\n\\int_0^1 f w \\,dx = \\int_0^1 (-q') w \\,dx = -\\left[ q w \\right]_0^1 + \\int_0^1 q w' \\,dx.\n$$\n由于 $w(0)=w(1)=0$，上式简化为 $\\int_0^1 q w' \\,dx$。残差变为：\n$$\nR(w) = \\int_0^1 q w' \\,dx - \\int_0^1 u_h' w' \\,dx = \\int_0^1 (q - u_h') w' \\,dx.\n$$\n代入 $w' = q-u_h'$，我们得到：\n$$\nR(w) = \\int_0^1 (q - u_h')^2 \\,dx = \\|q - u_h'\\|_{L^2}^2 = \\eta_{UB}^2 = \\frac{1}{48}.\n$$\n该值为正，因此 $|R(w)| = R(w)$。下限为：\n$$\n\\eta_{LB} = \\frac{R(w)}{\\|w'\\|_{L^2}} = \\frac{\\|q - u_h'\\|_{L^2}^2}{\\|q - u_h'\\|_{L^2}} = \\|q - u_h'\\|_{L^2} = \\eta_{UB} = \\frac{\\sqrt{3}}{12}.\n$$\n在这个特殊情况下，可计算的下限和上限是重合的。\n\n**4) 精确误差与验证**\n\n为了求得精确误差，我们首先求出精确解 $u(x)$。\n$$\n-u'' = 1 \\implies u' = -x + C_1 \\implies u = -\\frac{x^2}{2} + C_1 x + C_2.\n$$\n应用边界条件 $u(0)=0$ 和 $u(1)=0$：\n$$\nu(0) = 0 \\implies C_2=0.\n$$\n$$\nu(1) = -\\frac{1}{2} + C_1 = 0 \\implies C_1 = \\frac{1}{2}.\n$$\n精确解为 $u(x) = -\\frac{x^2}{2} + \\frac{x}{2}$。其导数为 $u'(x) = -x + \\frac{1}{2}$。\n我们观察到，精确通量 $u'(x)$ 与第2部分中找到的最优平衡通量 $q(x)$ 完全相同。\n精确的能量范数误差为 $\\|u' - u_h'\\|_{L^2}$。由于 $u'=q$，这等于：\n$$\n\\|u' - u_h'\\|_{L^2} = \\|q - u_h'\\|_{L^2} = \\eta_{UB}.\n$$\n计算过程与第2部分中的完全相同，得到：\n$$\n\\|u' - u_h'\\|_{L^2} = \\sqrt{\\frac{1}{48}} = \\frac{\\sqrt{3}}{12}.\n$$\n我们验证精确误差位于所计算的上下限之间：\n$$\n\\eta_{LB} \\le \\|u' - u_h'\\|_{L^2} \\le \\eta_{UB} \\implies \\frac{\\sqrt{3}}{12} \\le \\frac{\\sqrt{3}}{12} \\le \\frac{\\sqrt{3}}{12}.\n$$\n不等式成立，并且在这种情况下，估计子是精确的，这意味着它们直接给出了误差值本身，而不仅仅是界限。这是因为精确通量 $u'$ 恰好位于用于构造平衡通量 $q$ 的函数空间（线性多项式）中。\n最终答案是该误差的精确值。", "answer": "$$ \\boxed{\\frac{\\sqrt{3}}{12}} $$", "id": "2539225"}, {"introduction": "最后的综合性练习将理论与实践融为一体，要求你实现一个完整的自适应网格加密循环。你将使用基于残差的指示子来驱动一个包含材料界面的问题的网格细化，并观察网格如何自动在解的正则性较低的区域进行加密。这个练习旨在弥合理论误差估计与其实际在科学计算中应用之间的鸿沟 [@problem_id:2539292]。", "problem": "考虑在开区间 $\\Omega = (0,1)$ 上具有两种材料的一维标量扩散问题：求解满足齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$ 的函数 $u:\\overline{\\Omega}\\to\\mathbb{R}$，使得\n$$\n-\\frac{d}{dx}\\left( k(x)\\,\\frac{du}{dx}(x) \\right) = f(x)\\quad\\text{for }x\\in(0,1),\n$$\n其中标量扩散系数 $k(x)$ 是分段常数，在材料界面 $x_{\\star} = 0.5$ 处有单个跳跃，即当 $x<x_{\\star}$ 时 $k(x)=k_1$，当 $x>x_{\\star}$ 时 $k(x)=k_2$。源项 $f(x)$ 是分段光滑的，在下文的测试中是一个常数函数。在 Sobolev 空间 $H_0^1(\\Omega)$ 中进行计算，并使用标准 Galerkin 有限元方法，该方法在 $\\Omega$ 的一个协调剖分（由闭区间构成）上采用连续的分段仿射（线性）形函数。\n\n你的任务是实现一个由基于残差的后验误差指示器驱动的自适应有限元算法，该算法需与以下基本原理和核心定义保持一致：\n\n- 弱形式为：求解 $u\\in H_0^1(\\Omega)$，使得对于所有 $v\\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 k(x)\\,u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx.\n$$\n\n- 连续残差定义为 $R(v) = \\int_0^1 \\left(f(x) + (k(x)u_h'(x))'\\right)v(x)\\,dx$，其中 $u_h$ 是有限元解。通过在每个单元上使用分部积分以及利用 $v$ 的连续性，此残差可分解为来自体内平衡的单元贡献和来自内部节点处离散通量跳跃的单元间贡献。\n\n- 必须根据上述弱残差分解为每个单元构建一个基于残差的后验误差指示器，该指示器必须包含一个与单元尺寸和单元上强残差的 $L^2$-范数成比例的体内项，以及一个与单元尺寸和离散法向通量在单元端点（内部节点）处跳跃的大小成比例的边项。\n\n- 网格加密必须通过“体”追踪策略（也称为 Dörfler 标记）来标记单元：给定参数 $\\theta\\in(0,1)$，选择一个最小的单元集合，使其指示器（在适当的非负聚合下）之和至少占全局总和的 $\\theta$ 比例。通过二等分方法加密所有被标记的单元。\n\n从 $\\Omega$ 的一个协调初始网格开始，实现一个自适应循环，该循环重复执行以下步骤：\n$\\,$(i) 组装并求解关于 $u_h$ 的线性系统，$\\,$ (ii) 计算与上述原理一致的、逐单元的基于残差的指示器，$\\,$ (iii) 使用参数 $\\theta$ 通过“体”追踪准则标记单元，以及 $\\,$(iv) 通过二等分方法加密所有被标记的单元。在规定的自适应迭代次数 $L$ 之后，通过计算最后一次迭代中被标记的单元与界面邻域 $[x_{\\star}-\\delta,\\,x_{\\star}+\\delta]$ 相交的比例，来量化加密在材料界面处的集中程度。当且仅当该比例大于或等于给定阈值 $\\alpha$ 时，判定加密集中在界面处。\n\n实现要求：\n- 使用分段仿射形函数，并对单元积分使用精确或足够精确的数值积分；数值过程必须与上述弱形式一致。\n- 基于残差的指示器必须同时反映体内平衡残差和离散通量跳跃；其构造必须从弱形式和分部积分推导而来，而非来自任何特设规则。\n- 使用齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n测试套件：\n对于每个测试，参数包括：参数对 $(k_1,k_2)$，恒定源值 $c$（其中 $f(x)\\equiv c$），自适应迭代次数 $L$，“体”追踪参数 $\\theta$，界面邻域半宽度 $\\delta$，判定阈值 $\\alpha$，以及一个决定初始网格布局的布尔标志。如果标志“align”为真，则初始网格是节点位于 $x=0, x=0.5, x=1$ 的双单元网格。如果标志为假，则初始网格是节点位于 $x=0, x=1/3, x=2/3, x=1$ 的三单元网格。\n\n提供以下四个测试用例的结果：\n- 测试 $1$: $(k_1,k_2}=(1,10)$, $c=1$, $L=5$, $\\theta=0.5$, $\\delta=0.1$, $\\alpha=0.6$, align $=\\,$false.\n- 测试 $2$: $(k_1,k_2)=(1,1000)$, $c=1$, $L=4$, $\\theta=0.5$, $\\delta=0.08$, $\\alpha=0.6$, align $=\\,$false.\n- 测试 $3$: $(k_1,k_2)=(1,1)$, $c=1$, $L=4$, $\\theta=0.5$, $\\delta=0.08$, $\\alpha=0.6$, align $=\\,$false.\n- 测试 $4$: $(k_1,k_2)=(0.01,1)$, $c=1$, $L=5$, $\\theta=0.5$, $\\delta=0.08$, $\\alpha=0.6$, align $=\\,$true.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按上述测试的顺序排列结果。列表中的每个条目都是一个布尔值，指示根据所述规则，加密是否集中在界面处。例如，输出形式可以是“[True,False,True,True]”。不应打印任何其他文本。", "solution": "所提出的问题是偏微分方程数值分析领域中一个定义明确的任务，具体涉及针对一维扩散问题的自适应有限元方法（FEM）。\n\n该问题的验证如下：\n- **给定条件**：所有必要的组成部分均已提供：控制微分方程 $-\\frac{d}{dx}(k(x) \\frac{du}{dx}) = f(x)$、定义域 $\\Omega=(0,1)$、齐次 Dirichlet 边界条件、在 $x_{\\star}=0.5$ 处有跳跃的分段常数扩散系数 $k(x)$、常数源项 $f(x)=c$、弱形式，以及构建基于残差的后验误差指示器的核心原理。自适应策略，包括 Dörfler 标记和二等分加密，都已明确规定。测试套件提供了所有必要的参数 $(k_1, k_2, c, L, \\theta, \\delta, \\alpha)$ 和初始网格配置。\n- **验证结论**：问题是**有效的**。它在科学上是合理的，基于成熟的有限元方法（FEM）和后验误差估计理论。它是适定的、客观的、完整的，并且在计算上是可行的。该任务要求从第一性原理推导特定算法并加以实现，这是科学计算中的一个标准且不平凡的练习。\n\n解决方案的步骤是：首先形式化后验误差指示器，然后概述自适应算法，最后实现该算法以解决给定的测试用例。\n\n### 数学公式化\n\n**1. 有限元离散化**\n我们在 $\\Omega=(0,1)$ 的网格 $\\mathcal{T}_h = \\{T_i\\}$ 上使用连续分段线性有限元，其中每个单元 $T_i$ 是一个闭区间 $[x_{i-1}, x_i]$。有限元解 $u_h$ 在空间 $V_h \\subset H_0^1(\\Omega)$ 中求解，该空间由在 $x=0$ 和 $x=1$ 处为零的连续分段线性函数构成。Galerkin 形式是求解 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$：\n$$\na(u_h, v_h) := \\int_0^1 k(x) u_h'(x) v_h'(x) dx = \\int_0^1 f(x) v_h(x) dx\n$$\n这导出一个线性方程组 $AU=b$，其中 $U$ 是 $u_h$ 在内部节点处的节点值向量。\n\n对于长度为 $h_i = x_i - x_{i-1}$ 的单元 $T_i = [x_{i-1}, x_i]$，计算其单元刚度矩阵和载荷向量。系数 $k(x)$ 在网格上近似为分段常数函数 $k_h$，其中 $k_h|_{T_i} = k((x_{i-1}+x_i)/2)$。当 $f(x)=c$ 时，这得到：\n$$\nA^{(i)} = \\frac{k_h|_{T_i}}{h_i} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad b^{(i)} = \\frac{c h_i}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n\n**2. 基于残差的后验误差指示器**\n误差 $e=u-u_h$ 满足从弱残差推导出的后验误差关系。对于任何 $v \\in H_0^1(\\Omega)$：\n$$\na(e,v) = \\int_0^1 f v dx - \\int_0^1 k u_h' v' dx = \\sum_{T \\in \\mathcal{T}_h} \\left( \\int_T f v dx - \\int_T k u_h' v' dx \\right)\n$$\n逐单元分部积分并整理各项，可得到一个用单元残差和通量跳跃表示的误差表达式。误差的能量范数的平方由局部误差指示器 $\\eta_T^2$ 的平方和所界定。与问题原理一致的、在单元 $T_i=[x_{i-1}, x_i]$ 上的局部指示器的标准形式，由一个体内项和边（跳跃）项组成：\n$$\n\\eta_{T_i}^2 = h_i^2 \\| f + (k_h u_h')' \\|_{L^2(T_i)}^2 + \\frac{1}{2}h_i |J_{i-1}|^2 + \\frac{1}{2}h_i |J_{i}|^2\n$$\n在这里，由于 $u_h$ 是线性的且 $k_h$ 在 $T_i$ 上是常数，强残差 $(k_h u_h')'$ 为零。在内部节点 $x_i$ 处的跳跃 $J_i$ 是离散通量的跳跃：\n$$\nJ_i = \\llbracket k_h u_h' \\rrbracket_{x_i} = (k_h u_h')|_{T_{i+1}} - (k_h u_h')|_{T_i}\n$$\n对于边界节点，跳跃为零。当 $f(x)=c$ 时，指示器简化为：\n$$\n\\eta_{T_i}^2 = c^2 h_i^3 + \\frac{1}{2}h_i (J_{i-1}^2 + J_i^2)\n$$\n该形式具有适当的缩放比例，并用于指导网格加密。\n\n### 自适应算法\n\n自适应循环执行规定的迭代次数 $L$。在每次迭代中：\n1.  **求解**：给定当前网格（一个排序的节点数组），组装全局刚度矩阵 $A$ 和载荷向量 $b$。通过将系统缩减至内部节点来施加齐次 Dirichlet 边界条件。求解该线性系统以获得有限元解 $u_h$ 的节点值 $U$。\n2.  **估计**：使用上面推导的公式，为网格中的所有单元 $T_i$ 计算逐单元误差指示器 $\\eta_{T_i}^2$。这需要计算每个单元上的导数 $u_h'$，然后计算每个内部节点处的通量跳跃 $J_i$。\n3.  **标记**：采用 Dörfler 标记策略。计算指示器总和 $\\mathcal{E}^2 = \\sum_i \\eta_{T_i}^2$。按指示器值降序对单元进行排序。标记一个最小的单元集合 $\\mathcal{M}$，使得 $\\sum_{T \\in \\mathcal{M}} \\eta_T^2 \\ge \\theta \\mathcal{E}^2$。\n4.  **加密**：通过二等分每个被标记的单元来生成新网格。新的节点集由将所有被标记单元的中点添加到现有节点集中而形成。\n\n经过 $L$ 次迭代后，对最后一步中标记的单元集 $\\mathcal{M}_L$ 进行分析。我们计算 $\\mathcal{M}_L$ 中与材料界面邻域 $[x_{\\star}-\\delta, x_{\\star}+\\delta]$ 相交的单元比例。如果 $x_i > x_{\\star}-\\delta$ 且 $x_{i-1} < x_{\\star}+\\delta$，则单元 $[x_{i-1}, x_i]$ 与该邻域相交。如果此比例大于或等于阈值 $\\alpha$，则认为加密集中在界面处。\n\n这个过程构成了一个解决问题和评估测试用例的完整算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the adaptive finite element problem.\n    \"\"\"\n    test_cases = [\n        # Test 1: (k1, k2)=(1,10), c=1, L=5, theta=0.5, delta=0.1, alpha=0.6, align=false.\n        (1, 10, 1, 5, 0.5, 0.1, 0.6, False),\n        # Test 2: (k1, k2)=(1,1000), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6, align=false.\n        (1, 1000, 1, 4, 0.5, 0.08, 0.6, False),\n        # Test 3: (k1, k2)=(1,1), c=1, L=4, theta=0.5, delta=0.08, alpha=0.6, align=false.\n        (1, 1, 1, 4, 0.5, 0.08, 0.6, False),\n        # Test 4: (k1, k2)=(0.01,1), c=1, L=5, theta=0.5, delta=0.08, alpha=0.6, align=true.\n        (0.01, 1, 1, 5, 0.5, 0.08, 0.6, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_adaptive_fem(*case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_adaptive_fem(k1, k2, c, L, theta, delta, alpha, align_flag):\n    \"\"\"\n    Executes the adaptive FEM for a single test case.\n    \"\"\"\n    x_star = 0.5\n\n    def k_func(x):\n        # Per problem, k(x) jumps at x_star.\n        # k(x) = k1 for x = x_star, k2 for x > x_star.\n        if np.isscalar(x):\n            return k1 if x = x_star else k2\n        return np.where(x = x_star, k1, k2)\n\n    # Initial mesh setup\n    if align_flag:\n        nodes = np.array([0.0, 0.5, 1.0])\n    else:\n        nodes = np.array([0.0, 1.0/3.0, 2.0/3.0, 1.0])\n\n    marked_indices = []\n    # nodes_on_which_marking_was_done will store the mesh state\n    # before the final refinement, which is used for the analysis.\n    nodes_on_which_marking_was_done = nodes\n\n    for _ in range(L):\n        nodes_on_which_marking_was_done = np.copy(nodes)\n        num_nodes = len(nodes)\n        num_elements = num_nodes - 1\n        h = np.diff(nodes)\n        \n        num_unknowns = num_nodes - 2\n        if num_unknowns = 0:\n            marked_indices = list(range(num_elements))\n            # Refine all elements if no system to solve\n            new_nodes_set = set(nodes)\n            for idx in marked_indices:\n                new_node = (nodes[idx] + nodes[idx+1]) / 2.0\n                new_nodes_set.add(new_node)\n            nodes = np.array(sorted(list(new_nodes_set)))\n            continue\n\n        # Assemble stiffness matrix A and load vector b for interior nodes\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        element_midpoints = nodes[:-1] + h / 2.0\n        k_h = k_func(element_midpoints)\n\n        # Diagonal entries for A\n        diag = k_h[:-1] / h[:-1] + k_h[1:] / h[1:]\n        np.fill_diagonal(A, diag)\n        \n        # Off-diagonal entries for A\n        off_diag = -k_h[1:-1] / h[1:-1]\n        np.fill_diagonal(A[1:], off_diag)\n        np.fill_diagonal(A[:, 1:], off_diag)\n        \n        # Load vector b\n        b[:] = c * (h[:-1] + h[1:]) / 2.0\n\n        # Solve linear system AU=b for interior nodal values\n        try:\n            U_interior = scipy.linalg.solve(A, b, assume_a='sym')\n        except np.linalg.LinAlgError:\n            # Fallback for singular matrix\n            U_interior = np.zeros(num_unknowns)\n\n        U = np.concatenate(([0.0], U_interior, [0.0]))\n\n        # Compute a posteriori error indicators\n        u_h_deriv = np.diff(U) / h\n        flux = k_h * u_h_deriv\n        jumps = flux[1:] - flux[:-1]\n        full_jumps = np.concatenate(([0.0], jumps, [0.0]))\n\n        indicators_sq = np.zeros(num_elements)\n        for i in range(num_elements):\n            h_i = h[i]\n            # Jump contribution from left and right nodes of element i\n            J_left_sq = full_jumps[i]**2\n            J_right_sq = full_jumps[i+1]**2\n            \n            bulk_term = (c**2) * (h_i**3)\n            jump_term = 0.5 * h_i * (J_left_sq + J_right_sq)\n            indicators_sq[i] = bulk_term + jump_term\n            \n        # Dörfler (bulk-chasing) marking\n        total_indicator_sq_sum = np.sum(indicators_sq)\n        if total_indicator_sq_sum  1e-18:\n            marked_indices = []\n        else:\n            sorted_indices = np.argsort(indicators_sq)[::-1]\n            cumulative_sum = 0.0\n            marked_indices = []\n            for idx in sorted_indices:\n                marked_indices.append(idx)\n                cumulative_sum += indicators_sq[idx]\n                if cumulative_sum >= theta * total_indicator_sq_sum:\n                    break\n        \n        # Refine mesh by bisecting marked elements\n        new_nodes_set = set(nodes)\n        for idx in marked_indices:\n            new_node = (nodes[idx] + nodes[idx+1]) / 2.0\n            new_nodes_set.add(new_node)\n        nodes = np.array(sorted(list(new_nodes_set)))\n\n    # Final analysis on the last set of marked elements\n    if not marked_indices:\n        return False\n        \n    num_marked = len(marked_indices)\n    num_intersecting = 0\n    neighborhood_min = x_star - delta\n    neighborhood_max = x_star + delta\n    \n    for idx in marked_indices:\n        elem_left = nodes_on_which_marking_was_done[idx]\n        elem_right = nodes_on_which_marking_was_done[idx+1]\n        \n        # Check for non-empty intersection of interval (elem_left, elem_right)\n        # with [neighborhood_min, neighborhood_max]\n        if elem_right > neighborhood_min and elem_left  neighborhood_max:\n            num_intersecting += 1\n            \n    fraction = num_intersecting / num_marked if num_marked > 0 else 0.0\n    \n    return fraction >= alpha\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2539292"}]}