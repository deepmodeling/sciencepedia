{"hands_on_practices": [{"introduction": "Zienkiewicz-Zhu (ZZ) 应力恢复方法的核心思想是在单元片（patch）上通过局部多项式拟合来获得一个连续的应力场。第一个动手实践将通过引导您完成基本步骤来揭示这一过程的奥秘。您将为一个内部节点手动构建并求解最小二乘系统，从而具体理解如何从原始的有限元输出中计算出恢复应力。[@problem_id:2612978]", "problem": "考虑平面线性弹性问题，以及在围绕空间位置 $\\mathbf{x}_{0} = (0,\\,0)$ 处一个内部节点的单元片上应用的 Zienkiewicz–Zhu 应力恢复程序。给定在单元片内四个采样点上计算得到的单元常数近似的正应力分量 $\\sigma_{xx}$：\n位于 $\\mathbf{x}_{1} = (-1,\\,0)$ 处，$\\sigma_{xx}^{(1)} = -0.9$ (MPa)，\n位于 $\\mathbf{x}_{2} = (1,\\,0)$ 处，$\\sigma_{xx}^{(2)} = 5.2$ (MPa)，\n位于 $\\mathbf{x}_{3} = (0,\\,1)$ 处，$\\sigma_{xx}^{(3)} = 0.8$ (MPa)，\n位于 $\\mathbf{x}_{4} = (0,\\,-1)$ 处，$\\sigma_{xx}^{(4)} = 3.1$ (MPa)。\n假设单元片上的恢复应力分量采用线性多项式拟设 $p(x,y) = a_{0} + a_{1}\\,x + a_{2}\\,y$，\n并对给定的采样点使用无权最小二乘拟合。\n\n任务：\n(a) 显式地构建此单元片和基对应的范德蒙式设计矩阵 $A \\in \\mathbb{R}^{4 \\times 3}$ 和数据向量 $\\mathbf{s} \\in \\mathbb{R}^{4}$。\n(b) 从最小二乘原理出发，写出正规方程并求解系数向量 $\\mathbf{a} = (a_{0},\\,a_{1},\\,a_{2})^{\\mathsf{T}}$。\n(c) 计算内部节点处的恢复应力 $p(0,0)$，并以 MPa 为单位表示最终数值答案。将最终答案四舍五入至 $4$ 位有效数字。\n(d) 现在考虑一个位于直边界段上的边界节点片，已知其单位外法线为 $\\mathbf{n} = (0,\\,1)$，并且在一组有限的边界配置点 $\\{\\mathbf{x}_{b}^{(k)}\\}_{k=1}^{m_{b}}$ 上有可用的边界牵引力测量值 $\\bar{\\mathbf{t}}(\\mathbf{x}) = (\\bar{t}_{x}(\\mathbf{x}),\\,\\bar{t}_{y}(\\mathbf{x}))$。假设单元片上的每个独立应力分量都由与 $p$ 形式相同的线性多项式近似，即\n$\\sigma_{xx}(x,y) = a_{xx,0} + a_{xx,1}\\,x + a_{xx,2}\\,y$， \n$\\sigma_{yy}(x,y) = a_{yy,0} + a_{yy,1}\\,x + a_{yy,2}\\,y$， \n$\\sigma_{xy}(x,y) = a_{xy,0} + a_{xy,1}\\,x + a_{xy,2}\\,y$。\n通过显式构造约束矩阵，解释如何通过拉格朗日乘子在边界配置点上施加牵引力条件 $\\sigma(\\mathbf{x})\\,\\mathbf{n} = \\bar{\\mathbf{t}}(\\mathbf{x})$，并写出相应的增广 Karush–Kuhn–Tucker 线性系统，无需求解。\n\n您的最终答案必须是 $p(0,0)$ 的单一实数值，以 MPa 为单位，并按要求四舍五入至 $4$ 位有效数字。", "solution": "该问题展示了在有限元方法框架内 Zienkiewicz-Zhu 应力恢复技术的一项标准应用。该问题经检验具有科学依据、是适定的，并包含求解所需的所有数据。我们将按顺序解决每个任务。\n\n(a) 显式地构建范德蒙式设计矩阵 $A \\in \\mathbb{R}^{4 \\times 3}$ 和数据向量 $\\mathbf{s} \\in \\mathbb{R}^{4}$。\n\n恢复的应力场是一个形式为 $p(x,y) = a_{0} + a_{1}x + a_{2}y$ 的线性多项式。这可以写成一个基函数的行向量和一个系数的列向量的乘积：$p(x,y) = \\begin{pmatrix} 1 & x & y \\end{pmatrix} \\begin{pmatrix} a_{0} \\\\ a_{1} \\\\ a_{2} \\end{pmatrix}$。\n最小二乘问题旨在找到系数向量 $\\mathbf{a} = (a_{0}, a_{1}, a_{2})^{\\mathsf{T}}$，以最小化在采样点处计算的多项式值与给定应力数据之间的平方误差。针对四个采样点的方程组为 $A\\mathbf{a} \\approx \\mathbf{s}$。\n\n设计矩阵 $A$ 是通过在四个采样点 $\\mathbf{x}_{i} = (x_{i}, y_{i})$ 中的每一个点上计算基函数来构建的。$A$ 的第 $i$ 行由 $(1, x_{i}, y_{i})$ 给出。\n给定的点为 $\\mathbf{x}_{1} = (-1,0)$，$\\mathbf{x}_{2} = (1,0)$，$\\mathbf{x}_{3} = (0,1)$ 和 $\\mathbf{x}_{4} = (0,-1)$。\n由此产生的设计矩阵 $A$ 为：\n$$A = \\begin{pmatrix} 1 & -1 & 0 \\\\ 1 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 1 & 0 & -1 \\end{pmatrix}$$\n数据向量 $\\mathbf{s}$ 由与每个采样点相对应的给定应力值 $\\sigma_{xx}^{(i)}$ 组成：$\\sigma_{xx}^{(1)} = -0.9$，$\\sigma_{xx}^{(2)} = 5.2$，$\\sigma_{xx}^{(3)} = 0.8$ 和 $\\sigma_{xx}^{(4)} = 3.1$。\n数据向量 $\\mathbf{s}$ 为：\n$$\\mathbf{s} = \\begin{pmatrix} -0.9 \\\\ 5.2 \\\\ 0.8 \\\\ 3.1 \\end{pmatrix}$$\n\n(b) 从最小二乘原理出发，写出正规方程并求解系数向量 $\\mathbf{a}$。\n\n无权最小二乘原理旨在最小化残差向量的欧几里得范数的平方，$J(\\mathbf{a}) = \\|\\mathbf{r}\\|_{2}^{2} = \\|\\mathbf{s} - A\\mathbf{a}\\|_{2}^{2}$。最小值在 $J$ 相对于 $\\mathbf{a}$ 的梯度为零处取得：$\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = \\mathbf{0}$。\n计算梯度：\n$\\nabla_{\\mathbf{a}} \\left( (\\mathbf{s} - A\\mathbf{a})^{\\mathsf{T}} (\\mathbf{s} - A\\mathbf{a}) \\right) = \\nabla_{\\mathbf{a}} \\left( \\mathbf{s}^{\\mathsf{T}}\\mathbf{s} - 2\\mathbf{s}^{\\mathsf{T}}A\\mathbf{a} + \\mathbf{a}^{\\mathsf{T}}A^{\\mathsf{T}}A\\mathbf{a} \\right) = -2A^{\\mathsf{T}}\\mathbf{s} + 2A^{\\mathsf{T}}A\\mathbf{a}$。\n将梯度设为零，得到正规方程：\n$$A^{\\mathsf{T}}A\\mathbf{a} = A^{\\mathsf{T}}\\mathbf{s}$$\n我们计算矩阵 $A^{\\mathsf{T}}A$ 和向量 $A^{\\mathsf{T}}\\mathbf{s}$。\n$$A^{\\mathsf{T}} = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix}$$\n$$A^{\\mathsf{T}}A = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} 1 & -1 & 0 \\\\ 1 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 1 & 0 & -1 \\end{pmatrix} = \\begin{pmatrix} 1+1+1+1 & -1+1+0+0 & 0+0+1-1 \\\\ -1+1+0+0 & 1+1+0+0 & 0+0+0+0 \\\\ 0+0+1-1 & 0+0+0+0 & 0+0+1+1 \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix}$$\n在采样点加权的点积意义下，列的正交性导致了一个对角矩阵，这简化了求解过程。\n$$A^{\\mathsf{T}}\\mathbf{s} = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & -1 \\end{pmatrix} \\begin{pmatrix} -0.9 \\\\ 5.2 \\\\ 0.8 \\\\ 3.1 \\end{pmatrix} = \\begin{pmatrix} (-0.9) + 5.2 + 0.8 + 3.1 \\\\ -(-0.9) + 5.2 \\\\ 0.8 - 3.1 \\end{pmatrix} = \\begin{pmatrix} 8.2 \\\\ 6.1 \\\\ -2.3 \\end{pmatrix}$$\n因此，正规方程为：\n$$\\begin{pmatrix} 4 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 2 \\end{pmatrix} \\begin{pmatrix} a_{0} \\\\ a_{1} \\\\ a_{2} \\end{pmatrix} = \\begin{pmatrix} 8.2 \\\\ 6.1 \\\\ -2.3 \\end{pmatrix}$$\n解这个对角系统，得到系数：\n$4a_{0} = 8.2 \\implies a_{0} = \\frac{8.2}{4} = 2.05$\n$2a_{1} = 6.1 \\implies a_{1} = \\frac{6.1}{2} = 3.05$\n$2a_{2} = -2.3 \\implies a_{2} = \\frac{-2.3}{2} = -1.15$\n系数向量为 $\\mathbf{a} = (2.05, 3.05, -1.15)^{\\mathsf{T}}$。\n\n(c) 计算内部节点处的恢复应力 $p(0,0)$。\n\n在节点位置 $\\mathbf{x}_{0} = (0,0)$ 处的恢复应力是通过在这些坐标上计算多项式 $p(x,y)$ 得到的。\n$$p(0,0) = a_{0} + a_{1}(0) + a_{2}(0) = a_{0}$$\n根据上一步，$a_{0} = 2.05$。单位是兆帕 (MPa)。四舍五入到 $4$ 位有效数字，结果是 $2.050$ MPa。\n\n(d) 解释如何通过拉格朗日乘子施加牵引力条件。\n\n在这种情况下，我们对所有三个独立的应力分量 ($\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}$) 进行最小二乘拟合，同时受到已知边界牵引力施加的线性约束。设完整的未知系数集为 $\\mathbf{\\alpha} \\in \\mathbb{R}^{9}$：\n$$\\mathbf{\\alpha} = (a_{xx,0}, a_{xx,1}, a_{xx,2}, \\,\\,\\, a_{yy,0}, a_{yy,1}, a_{yy,2}, \\,\\,\\, a_{xy,0}, a_{xy,1}, a_{xy,2})^{\\mathsf{T}}$$\n在具有单位外法线 $\\mathbf{n}$ 的表面上的牵引力向量 $\\mathbf{t}$ 由 $\\mathbf{t} = \\sigma \\mathbf{n}$ 给出。对于 $\\mathbf{n} = (0, 1)^{\\mathsf{T}}$，这变为：\n$$\\mathbf{t} = \\begin{pmatrix} t_{x} \\\\ t_{y} \\end{pmatrix} = \\begin{pmatrix} \\sigma_{xx} & \\sigma_{xy} \\\\ \\sigma_{xy} & \\sigma_{yy} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\sigma_{xy} \\\\ \\sigma_{yy} \\end{pmatrix}$$\n这些牵引力必须等于在一组 $m_{b}$ 个边界配置点 $\\{\\mathbf{x}_{b}^{(k)}\\}_{k=1}^{m_{b}}$ 上的测量牵引力 $\\bar{\\mathbf{t}}(\\mathbf{x}) = (\\bar{t}_{x}(\\mathbf{x}), \\bar{t}_{y}(\\mathbf{x}))^{\\mathsf{T}}$。对于每个点 $\\mathbf{x}_{b}^{(k)} = (x_{b}^{(k)}, y_{b}^{(k)})$，我们有两个关于 $\\mathbf{\\alpha}$ 的线性约束：\n$$ \\sigma_{xy}(x_{b}^{(k)}, y_{b}^{(k)}) = a_{xy,0} + a_{xy,1}x_{b}^{(k)} + a_{xy,2}y_{b}^{(k)} = \\bar{t}_{x}(\\mathbf{x}_{b}^{(k)}) $$\n$$ \\sigma_{yy}(x_{b}^{(k)}, y_{b}^{(k)}) = a_{yy,0} + a_{yy,1}x_{b}^{(k)} + a_{yy,2}y_{b}^{(k)} = \\bar{t}_{y}(\\mathbf{x}_{b}^{(k)}) $$\n这 $2m_{b}$ 个约束可以写成矩阵形式 $C\\mathbf{\\alpha} = \\mathbf{d}$，其中 $C$ 是一个 $(2m_{b}) \\times 9$ 矩阵，$\\mathbf{d}$ 是一个 $(2m_{b}) \\times 1$ 向量。\n设 $\\mathbf{p}_{k} = (1, x_{b}^{(k)}, y_{b}^{(k)})$。$C$ 中对应于点 $\\mathbf{x}_{b}^{(k)}$ 的一对行为：\n$$ C_{(2k-1, \\cdot)} = \\begin{pmatrix} 0 & 0 & 0 & 0 & 0 & 0 & 1 & x_{b}^{(k)} & y_{b}^{(k)} \\end{pmatrix} $$\n$$ C_{(2k, \\cdot)} = \\begin{pmatrix} 0 & 0 & 0 & 1 & x_{b}^{(k)} & y_{b}^{(k)} & 0 & 0 & 0 \\end{pmatrix} $$\n右端向量为 $\\mathbf{d} = (\\bar{t}_{x}(\\mathbf{x}_{b}^{(1)}), \\bar{t}_{y}(\\mathbf{x}_{b}^{(1)}), \\dots, \\bar{t}_{x}(\\mathbf{x}_{b}^{(m_{b})}), \\bar{t}_{y}(\\mathbf{x}_{b}^{(m_{b})}))^{\\mathsf{T}}$。\n优化问题是在约束条件 $C\\mathbf{\\alpha}=\\mathbf{d}$ 下，最小化内部采样点的最小二乘泛函 $\\frac{1}{2}\\|A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full}\\|^{2}$。使用拉格朗日乘子法，我们引入一个乘子向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{2m_{b}}$ 并构造拉格朗日函数：\n$$ \\mathcal{L}(\\mathbf{\\alpha}, \\boldsymbol{\\lambda}) = \\frac{1}{2}(A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full})^{\\mathsf{T}}(A_{full}\\mathbf{\\alpha} - \\mathbf{s}_{full}) + \\boldsymbol{\\lambda}^{\\mathsf{T}}(C\\mathbf{\\alpha} - \\mathbf{d}) $$\n最优解的 Karush-Kuhn-Tucker (KKT) 条件是 $\\nabla_{\\mathbf{\\alpha}}\\mathcal{L} = \\mathbf{0}$ 和 $\\nabla_{\\boldsymbol{\\lambda}}\\mathcal{L} = \\mathbf{0}$，由此得出：\n$$ (A_{full}^{\\mathsf{T}}A_{full})\\mathbf{\\alpha} + C^{\\mathsf{T}}\\boldsymbol{\\lambda} = A_{full}^{\\mathsf{T}}\\mathbf{s}_{full} $$\n$$ C\\mathbf{\\alpha} = \\mathbf{d} $$\n设 $K = A_{full}^{\\mathsf{T}}A_{full}$ 且 $\\mathbf{f} = A_{full}^{\\mathsf{T}}\\mathbf{s}_{full}$。增广 KKT 线性系统为：\n$$ \\begin{pmatrix} K & C^{\\mathsf{T}} \\\\ C & \\mathbf{0} \\end{pmatrix} \\begin{pmatrix} \\mathbf{\\alpha} \\\\ \\boldsymbol{\\lambda} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f} \\\\ \\mathbf{d} \\end{pmatrix} $$\n这里，$K$ 是由内部单元采样点的无约束最小二乘拟合产生的块对角矩阵，$\\mathbf{f}$ 是相应的右端向量。这个对称不定系统可以求解，得到系数 $\\mathbf{\\alpha}$ 和乘子 $\\boldsymbol{\\lambda}$。", "answer": "$$\\boxed{2.050}$$", "id": "2612978"}, {"introduction": "恢复应力场的主要目的是估计有限元解的误差。一个好的误差估计量应该是“渐近精确”的，即随着网格的细化，其值应趋近于真实的误差。这个实践旨在通过一个计算实验来验证这一关键特性，您将为一个具有已知解析解的问题实施 ZZ 估计量，计算其有效性指数 $\\theta_h$，并观察其如何收敛于 1，从而增强您对该估计量可靠性的信心。[@problem_id:2613010]", "problem": "考虑在方形域 $\\Omega = [0,1] \\times [0,1]$ 上的小应变、线性、各向同性平面应变弹性力学问题。设精确位移场由以下制造解给出\n$$\n\\mathbf{u}^{\\mathrm{ex}}(x,y) = \\begin{bmatrix} \\sin(\\pi x)\\sin(\\pi y) \\\\ \\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n假设 Lamé 参数 $\\lambda$ 和 $\\mu$ 由杨氏模量 $E$ 和泊松比 $\\nu$ 通过以下公式导出\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n$$\n在平面应变条件下，Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 与小应变张量 $\\boldsymbol{\\varepsilon}$ 通过 Hooke 定律相关联\n$$\n\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I},\n$$\n其中 $\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$。设体力场的选取能够使精确位移满足平衡条件，即\n$$\n\\mathbf{b}(x,y) = (\\lambda + \\mu)\\,\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) + \\mu\\,\\Delta \\mathbf{u}^{\\mathrm{ex}},\n$$\n从而使得强形式 $-\\nabla \\cdot \\boldsymbol{\\sigma}(\\mathbf{u}) = \\mathbf{b}$ 对于 $\\mathbf{u} = \\mathbf{u}^{\\mathrm{ex}}$ 精确成立。在边界 $\\partial \\Omega$ 上施加 Dirichlet 边界条件 $\\mathbf{u} = \\mathbf{u}^{\\mathrm{ex}}$。\n\n用 $n \\times n$ 个单元（$n \\in \\mathbb{N}$）的双线性四边形单元（$Q_4$）的均匀网格对 $\\Omega$ 进行离散化。令 $\\mathbf{u}_h$ 表示通过用于刚度和载荷组装的 $2 \\times 2$ Gauss 积分得到的有限元解。按以下步骤构建 Zienkiewicz–Zhu (ZZ) 恢复应力场 $\\boldsymbol{\\sigma}^\\star$：\n- 在每个单元的高斯点上计算有限元应力 $\\boldsymbol{\\sigma}_h$。\n- 对每个网格节点，构建一个由共享该节点的所有单元组成的单元片。利用单元片内所有的高斯点样本 $(x_k,y_k,\\boldsymbol{\\sigma}_h(x_k,y_k))$，对每个应力分量计算一个关于空间坐标的线性多项式 $s(x,y) \\approx a_0 + a_1 x + a_2 y$ 的最小二乘拟合。在节点处评估此拟合，以获得恢复的节点应力。\n- 在每个单元内，使用双线性有限元形函数对恢复的节点应力进行插值，以获得高斯点上的 $\\boldsymbol{\\sigma}^\\star$。\n\n将误差的能量范数和 ZZ 误差估计子定义为\n$$\n\\| e_h \\|_E^2 = \\int_{\\Omega} \\left( \\boldsymbol{\\sigma}(\\mathbf{u}^{\\mathrm{ex}}) - \\boldsymbol{\\sigma}_h \\right)^{\\top} \\mathbf{D}^{-1} \\left( \\boldsymbol{\\sigma}(\\mathbf{u}^{\\mathrm{ex}}) - \\boldsymbol{\\sigma}_h \\right)\\, \\mathrm{d}\\Omega,\n$$\n$$\n\\eta_h^2 = \\int_{\\Omega} \\left( \\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h \\right)^{\\top} \\mathbf{D}^{-1} \\left( \\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h \\right)\\, \\mathrm{d}\\Omega,\n$$\n其中 $\\mathbf{D}$ 是在 Voigt 记法下作用于向量 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^{\\top}$ 的平面应变本构矩阵，且 $\\gamma_{xy} = 2 \\varepsilon_{xy}$。效率指数为\n$$\n\\theta_h = \\frac{\\eta_h}{\\| e_h \\|_E}.\n$$\n您的任务是：\n1. 实现所述的有限元法 (FEM) 和 Zienkiewicz–Zhu (ZZ) 应力恢复方法，以针对逐次均匀细化的网格计算 $\\theta_h$。\n2. 使用 $E = 1$ 以及以下包含泊松比和网格分辨率的测试集：\n   - 情况 A（典型可压缩）：$\\nu = 0.30$， $n \\in \\{2, 4, 8, 16\\}$，\n   - 情况 B（近不可压缩）：$\\nu = 0.49$， $n \\in \\{4, 8\\}$，\n   - 情况 C（低泊松比）：$\\nu = 0.00$， $n \\in \\{4, 8, 16\\}$。\n3. 对每对 $(\\nu, n)$，使用与有限元列式一致的数值积分方法计算效率指数 $\\theta_h$。\n\n最终程序输出应为单行，包含一个 Python 风格的列表，其中含有所有计算出的 $\\theta_h$ 值，顺序如下\n$$\n[\\theta_h(\\nu{=}0.30,n{=}2), \\theta_h(\\nu{=}0.30,n{=}4), \\theta_h(\\nu{=}0.30,n{=}8), \\theta_h(\\nu{=}0.30,n{=}16), \\theta_h(\\nu{=}0.49,n{=}4), \\theta_h(\\nu{=}0.49,n{=}8), \\theta_h(\\nu{=}0.00,n{=}4), \\theta_h(\\nu{=}0.00,n{=}8), \\theta_h(\\nu{=}0.00,n{=}16)].\n$$\n所有值必须以浮点数形式打印在单个列表中，不得包含额外文本。由于 $\\theta_h$ 是无量纲的，最终输出无需物理单位。如果存在角度，必须以弧度为单位。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表（例如：“[r_1,r_2,\\dots,r_9]”）。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且完整的。我们接下来进行形式化的求解。\n\n该问题要求针对平面应变条件下的二维线性各向同性弹性问题，实现一个有限元法 (FEM)。我们在单位方形域 $\\Omega = [0,1] \\times [0,1]$ 上给出了一个位移场 $\\mathbf{u}^{\\mathrm{ex}}$ 的制造解。该精确解为\n$$\n\\mathbf{u}^{\\mathrm{ex}}(x,y) = \\begin{bmatrix} u^{\\mathrm{ex}}(x,y) \\\\ v^{\\mathrm{ex}}(x,y) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\pi x)\\sin(\\pi y) \\\\ \\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n材料由杨氏模量 $E$ 和泊松比 $\\nu$ 定义，由此可以导出 Lamé 参数 $\\lambda$ 和 $\\mu$。本构关系，即 Hooke 定律，由 $\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I}$ 给出，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\boldsymbol{\\varepsilon}$ 是小应变张量，$\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$。\n\n在 Voigt 记法中，应力向量为 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$，应变向量为 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$（其中 $\\gamma_{xy} = 2\\varepsilon_{xy}$），本构定律为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$。平面应变本构矩阵 $\\mathbf{D}$ 为\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n    \\lambda+2\\mu & \\lambda & 0 \\\\\n    \\lambda & \\lambda+2\\mu & 0 \\\\\n    0 & 0 & \\mu\n\\end{bmatrix}\n= \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n    1-\\nu & \\nu & 0 \\\\\n    \\nu & 1-\\nu & 0 \\\\\n    0 & 0 & (1-2\\nu)/2\n\\end{bmatrix}.\n$$\n控制方程为平衡方程 $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{b}$，其中体力 $\\mathbf{b}$ 被特别选择以使 $\\mathbf{u}^{\\mathrm{ex}}$ 满足该方程。根据给定的表达式 $\\mathbf{b} = (\\lambda + \\mu)\\,\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) + \\mu\\,\\Delta \\mathbf{u}^{\\mathrm{ex}}$，我们推导出体力的分量。$\\mathbf{u}^{\\mathrm{ex}}$ 的散度是 $\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}} = \\pi \\sin(\\pi(x+y))$。其梯度为 $\\nabla(\\nabla \\cdot \\mathbf{u}^{\\mathrm{ex}}) = [\\pi^2 \\cos(\\pi(x+y)), \\pi^2 \\cos(\\pi(x+y))]^{\\top}$。每个位移分量的拉普拉斯算子是 $\\Delta u^{\\mathrm{ex}} = \\Delta v^{\\mathrm{ex}} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。因此，体力向量是\n$$\n\\mathbf{b}(x,y) = \\begin{bmatrix} (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y)) - 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) \\\\ (\\lambda+\\mu)\\pi^2\\cos(\\pi(x+y)) - 2\\mu\\pi^2\\sin(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n该区域被离散化为一个由双线性四边形（$Q_4$）单元组成的均匀 $n \\times n$ 网格。通过求解由控制方程的 Galerkin 弱形式得到的线性系统 $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$，可以求得有限元解 $\\mathbf{u}_h$。单元刚度矩阵 $\\mathbf{K}^e$ 和载荷向量 $\\mathbf{F}^e$ 通过使用 $2 \\times 2$ Gauss 积分的数值积分方法计算：\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega, \\quad \\mathbf{F}^e = \\int_{\\Omega_e} \\mathbf{N}^{\\top} \\mathbf{b} \\, \\mathrm{d}\\Omega,\n$$\n其中 $\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{N}$ 是形函数矩阵。在所有边界 $\\partial \\Omega$ 上强加 Dirichlet 边界条件 $\\mathbf{u}_h = \\mathbf{u}^{\\mathrm{ex}}$。\n\n获得节点位移 $\\mathbf{U}$ 后，在每个单元的高斯点上计算有限元应力张量 $\\boldsymbol{\\sigma}_h$。然后应用 Zienkiewicz-Zhu (ZZ) 应力恢复过程以获得一个更精确、更连续的应力场 $\\boldsymbol{\\sigma}^\\star$。对于网格中的每个节点，形成一个连接到该节点的单元片。收集该单元片内所有高斯点上的应力值 $\\boldsymbol{\\sigma}_h$。对每个应力分量执行线性多项式 $s(x,y) = a_0 + a_1 x + a_2 y$ 的最小二乘拟合。节点上的恢复应力即为该多项式在节点坐标处的值。这样就得到了一组所有节点上的恢复应力。然后，在每个单元内，通过使用相同的双线性形函数对这些恢复的节点值进行插值，来定义场 $\\boldsymbol{\\sigma}^\\star$。\n\n最后，我们计算真实误差的能量范数 $\\| e_h \\|_E$ 和 ZZ 误差估计子 $\\eta_h$。它们的平方值由下式给出：\n$$\n\\| e_h \\|_E^2 = \\int_{\\Omega} (\\boldsymbol{\\sigma}^{\\mathrm{ex}} - \\boldsymbol{\\sigma}_h)^{\\top} \\mathbf{D}^{-1} (\\boldsymbol{\\sigma}^{\\mathrm{ex}} - \\boldsymbol{\\sigma}_h) \\, \\mathrm{d}\\Omega,\n$$\n$$\n\\eta_h^2 = \\int_{\\Omega} (\\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h)^{\\top} \\mathbf{D}^{-1} (\\boldsymbol{\\sigma}^\\star - \\boldsymbol{\\sigma}_h) \\, \\mathrm{d}\\Omega,\n$$\n其中 $\\boldsymbol{\\sigma}^{\\mathrm{ex}}$ 是由 $\\mathbf{u}^{\\mathrm{ex}}$ 导出的精确应力，本构矩阵的逆为\n$$\n\\mathbf{D}^{-1} = \\frac{1+\\nu}{E}\n\\begin{bmatrix}\n    1-\\nu & -\\nu & 0 \\\\\n    -\\nu & 1-\\nu & 0 \\\\\n    0 & 0 & 2\n\\end{bmatrix}.\n$$\n误差和估计子的积分使用相同的 $2 \\times 2$ Gauss 积分进行数值计算。估计子的质量通过效率指数 $\\theta_h = \\eta_h / \\| e_h \\|_E$ 来评估。一个接近 1 的 $\\theta_h$ 值表示这是一个有效的误差估计子。下面的实现为指定的测试用例执行了这整个过程。", "answer": "```python\nimport numpy as np\n\ndef compute_effectivity(n, nu):\n    \"\"\"\n    Computes the effectivity index for a given mesh resolution n and Poisson's ratio nu.\n    \"\"\"\n    E = 1.0\n    PI = np.pi\n\n    # --- 1. Material and Exact Solution Definition ---\n    if np.isclose(nu, 0.5): # Avoid singularity\n        # This case is not in the test suite but is a necessary check.\n        lam = 0.0 # Placeholder, should not be used\n    else:\n        lam = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    D = np.array([\n        [lam + 2 * mu, lam, 0],\n        [lam, lam + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    \n    D_inv = (1 + nu) / E * np.array([\n        [1 - nu, -nu, 0],\n        [-nu, 1 - nu, 0],\n        [0, 0, 2]\n    ])\n\n    def u_exact(x, y):\n        val = np.sin(PI * x) * np.sin(PI * y)\n        return np.array([val, val])\n\n    def strain_exact(x, y):\n        exx = PI * np.cos(PI * x) * np.sin(PI * y)\n        eyy = PI * np.sin(PI * x) * np.cos(PI * y)\n        gxy = PI * np.sin(PI * (x + y))\n        return np.array([exx, eyy, gxy])\n    \n    def body_force(x, y):\n        f_val = (lam + mu) * PI**2 * np.cos(PI * (x + y)) - 2 * mu * PI**2 * np.sin(PI * x) * np.sin(PI * y)\n        return np.array([f_val, f_val])\n\n    # --- 2. Mesh Generation ---\n    num_nodes = (n + 1) * (n + 1)\n    num_elems = n * n\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(n + 1):\n        for i in range(n + 1):\n            node_idx = j * (n + 1) + i\n            node_coords[node_idx] = [i / n, j / n]\n            \n    elem_nodes = np.zeros((num_elems, 4), dtype=int)\n    for j in range(n):\n        for i in range(n):\n            elem_idx = j * n + i\n            n0 = j * (n + 1) + i\n            n1 = j * (n + 1) + i + 1\n            n2 = (j + 1) * (n + 1) + i + 1\n            n3 = (j + 1) * (n + 1) + i\n            elem_nodes[elem_idx] = [n0, n1, n2, n3]\n\n    # --- 3. FEM Assembly ---\n    gp_loc = 1.0 / np.sqrt(3)\n    gauss_points = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    def shape_functions(xi, eta):\n        return 0.25 * np.array([\n            (1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)\n        ])\n\n    def shape_derivatives(xi, eta):\n        return 0.25 * np.array([\n            [-(1-eta),  (1-eta),  (1+eta), -(1+eta)],  # dN/dxi\n            [-(1-xi), -(1+xi),  (1+xi),   (1-xi)]   # dN/deta\n        ])\n\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n\n    # Store Gauss point coordinates and FE stresses for all elements\n    gauss_pt_coords = np.zeros((num_elems, 4, 2))\n    \n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        \n        Ke = np.zeros((8, 8))\n        Fe = np.zeros(8)\n        \n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[gp_idx]\n            N_vec = shape_functions(xi, eta)\n            dN_dxi_eta = shape_derivatives(xi, eta)\n            \n            J = dN_dxi_eta @ el_node_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            dN_dx_dy = invJ @ dN_dxi_eta\n            \n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2*i] = dN_dx_dy[0, i]\n                B[1, 2*i+1] = dN_dx_dy[1, i]\n                B[2, 2*i] = dN_dx_dy[1, i]\n                B[2, 2*i+1] = dN_dx_dy[0, i]\n                \n            Ke += B.T @ D @ B * detJ * w\n            \n            x_gp, y_gp = N_vec @ el_node_coords\n            gauss_pt_coords[e_idx, gp_idx, :] = [x_gp, y_gp]\n            \n            b_vec = body_force(x_gp, y_gp)\n            N_mat = np.zeros((2, 8))\n            for i in range(4):\n                N_mat[0, 2*i] = N_vec[i]\n                N_mat[1, 2*i+1] = N_vec[i]\n            \n            Fe += N_mat.T @ b_vec * detJ * w\n            \n        dof_map = np.array([[2*nid, 2*nid+1] for nid in el_node_ids]).flatten()\n        K[np.ix_(dof_map, dof_map)] += Ke\n        F[dof_map] += Fe\n    \n    # --- 4. Boundary Conditions ---\n    boundary_nodes = []\n    for i in range(n + 1):\n        boundary_nodes.extend([i, i*(n+1), i*(n+1)+n, n*(n+1)+i])\n    boundary_nodes = sorted(list(set(boundary_nodes)))\n\n    boundary_dofs = []\n    u_bc_vals = {}\n    for node_idx in boundary_nodes:\n        x, y = node_coords[node_idx]\n        u, v = u_exact(x, y)\n        dof_x, dof_y = 2 * node_idx, 2 * node_idx + 1\n        boundary_dofs.extend([dof_x, dof_y])\n        u_bc_vals[dof_x] = u\n        u_bc_vals[dof_y] = v\n    boundary_dofs = sorted(list(set(boundary_dofs)))\n\n    active_dofs = list(set(range(num_dofs)) - set(boundary_dofs))\n    \n    F_mod = F[active_dofs] - K[np.ix_(active_dofs, boundary_dofs)] @ [u_bc_vals[d] for d in boundary_dofs]\n    K_mod = K[np.ix_(active_dofs, active_dofs)]\n\n    # --- 5. Solve ---\n    U_h = np.zeros(num_dofs)\n    U_h[active_dofs] = np.linalg.solve(K_mod, F_mod)\n    for dof in boundary_dofs:\n        U_h[dof] = u_bc_vals[dof]\n\n    # --- 6. Compute FE Stresses ---\n    gauss_stresses_h = np.zeros((num_elems, 4, 3))\n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        dof_map = np.array([[2*nid, 2*nid+1] for nid in el_node_ids]).flatten()\n        U_e = U_h[dof_map]\n        \n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            dN_dxi_eta = shape_derivatives(xi, eta)\n            J = dN_dxi_eta @ el_node_coords\n            invJ = np.linalg.inv(J)\n            dN_dx_dy = invJ @ dN_dxi_eta\n            \n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2 * i] = dN_dx_dy[0, i]\n                B[1, 2 * i + 1] = dN_dx_dy[1, i]\n                B[2, 2 * i] = dN_dx_dy[1, i]\n                B[2, 2 * i + 1] = dN_dx_dy[0, i]\n\n            strain_h = B @ U_e\n            stress_h = D @ strain_h\n            gauss_stresses_h[e_idx, gp_idx, :] = stress_h\n\n    # --- 7. Zienkiewicz-Zhu Recovery ---\n    node_patches = [[] for _ in range(num_nodes)]\n    for e_idx, nodes in enumerate(elem_nodes):\n        for node_id in nodes:\n            node_patches[node_id].append(e_idx)\n\n    sigma_star_nodal = np.zeros((num_nodes, 3))\n    for node_idx in range(num_nodes):\n        patch_elems = node_patches[node_idx]\n        patch_coords = []\n        patch_stresses = []\n        for e_idx in patch_elems:\n            patch_coords.extend(gauss_pt_coords[e_idx, :, :])\n            patch_stresses.extend(gauss_stresses_h[e_idx, :, :])\n        \n        patch_coords = np.array(patch_coords)\n        patch_stresses = np.array(patch_stresses)\n        \n        A = np.c_[np.ones(patch_coords.shape[0]), patch_coords]\n        \n        for comp in range(3):\n            s = patch_stresses[:, comp]\n            coeffs = np.linalg.lstsq(A, s, rcond=None)[0]\n            xn, yn = node_coords[node_idx]\n            sigma_star_nodal[node_idx, comp] = coeffs[0] + coeffs[1] * xn + coeffs[2] * yn\n\n    # --- 8. Error and Estimator Calculation ---\n    error_sq_sum = 0.0\n    estimator_sq_sum = 0.0\n    \n    for e_idx in range(num_elems):\n        el_node_ids = elem_nodes[e_idx]\n        el_node_coords = node_coords[el_node_ids]\n        nodal_sigma_star = sigma_star_nodal[el_node_ids]\n\n        for gp_idx, (xi, eta) in enumerate(gauss_points):\n            w = gauss_weights[gp_idx]\n            N_vec = shape_functions(xi, eta)\n            \n            J = shape_derivatives(xi, eta) @ el_node_coords\n            detJ = np.linalg.det(J)\n            \n            x_gp, y_gp = gauss_pt_coords[e_idx, gp_idx]\n            \n            sigma_h = gauss_stresses_h[e_idx, gp_idx, :]\n            \n            strain_ex = strain_exact(x_gp, y_gp)\n            sigma_ex = D @ strain_ex\n            \n            sigma_star = N_vec @ nodal_sigma_star\n            \n            diff_err = sigma_ex - sigma_h\n            diff_est = sigma_star - sigma_h\n            \n            error_sq_sum += (diff_err.T @ D_inv @ diff_err) * detJ * w\n            estimator_sq_sum += (diff_est.T @ D_inv @ diff_est) * detJ * w\n\n    return np.sqrt(estimator_sq_sum) / np.sqrt(error_sq_sum)\n\n\ndef solve():\n    test_cases = [\n        (0.30, 2), (0.30, 4), (0.30, 8), (0.30, 16),\n        (0.49, 4), (0.49, 8),\n        (0.00, 4), (0.00, 8), (0.00, 16)\n    ]\n\n    results = []\n    for nu, n in test_cases:\n        theta_h = compute_effectivity(n, nu)\n        results.append(theta_h)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2613010"}, {"introduction": "误差估计的最终目标是指导自适应网格细化，使我们能够将计算资源集中在最需要的地方。对于具有方向性特征（如边界层）的问题，各向同性的均匀细化效率低下。在最后的这个实践中，您将不再仅仅是估计误差，而是利用恢复的应力场来设计一种更智能的、各向异性的细化策略，您将学习如何从恢复的应力中提取方向信息，从而显著提高解决挑战性问题的计算效率。[@problem_id:2613032]", "problem": "考虑单位正方形域 $(x,y) \\in [0,1] \\times [0,1]$ 上的标量扩散模型，其精确解在 $x=1$ 附近存在一个边界层，由下式给出：\n$$\nu(x,y;\\epsilon) = \\left(1 - e^{-\\frac{1-x}{\\epsilon}}\\right)\\,\\sin(\\pi y),\n$$\n其中 $\\epsilon \\in (0,1]$ 是一个控制边界层厚度的固定参数。在此标量情境中，将负梯度解释为“应力”（通量），定义为\n$$\n\\sigma(x,y;\\epsilon) = -\\nabla u(x,y;\\epsilon).\n$$\n设网格是 $[0,1]^2$ 的一个笛卡尔划分，将其分为 $N_x \\times N_y$ 个矩形，每个矩形通过从左下顶点到右上顶点的对角线分割成两个三角形。设 $u_h$ 是在得到的三角剖分上使用分片线性形函数对 $u$ 进行的节点插值。对每个三角形 $K$，单元应力是恒定向量\n$$\n\\sigma_h|_K = -\\nabla u_h|_K.\n$$\nZienkiewicz–Zhu (ZZ) 恢复应力 $\\sigma^*$ 通过节点平均定义：对每个节点 $P$，计算所有共享节点 $P$ 的三角形 $K$ 上的单元应力 $\\sigma_h|_K$ 的面积加权平均值，并将该平均值赋为 $\\sigma^*(P)$；对于一个顶点为 $P_1,P_2,P_3$ 的三角形 $K$，定义单元恢复应力为\n$$\n\\sigma^*_K = \\frac{1}{3}\\left(\\sigma^*(P_1)+\\sigma^*(P_2)+\\sigma^*(P_3)\\right).\n$$\n使用三角形 $K$ 上的 ZZ 能量范数指示器，\n$$\n\\eta_K^2 = |K|\\,\\lVert \\sigma^*_K - \\sigma_h|_K \\rVert_2^2,\n$$\n以及全局 ZZ 估计子\n$$\n\\eta = \\left(\\sum_{K} \\eta_K^2\\right)^{1/2}.\n$$\n此外，基于恢复应力定义方向性能量度量为\n$$\nS_x = \\sum_{K} |K|\\,\\left(\\sigma^*_K\\right)_x^2,\\qquad S_y = \\sum_{K} |K|\\,\\left(\\sigma^*_K\\right)_y^2,\n$$\n以及方向主导比\n$$\nR = \\frac{S_x}{S_y + \\delta},\n$$\n其中 $\\delta = 10^{-30}$ 是一个为避免除以零而设的固定微小常数。\n\n你的任务是：\n1) 对任意 $(N_x,N_y)$ 网格，实现上述定义和计算，包括三角剖分的构建、通过单元梯度计算 $\\sigma_h$ 以及 $\\sigma^*$ 的节点恢复。确保 ZZ 估计子 $\\eta$ 以及方向性度量 $S_x$、$S_y$ 和 $R$ 的计算与规定完全一致。\n\n2) 仅使用从 $\\sigma^*$ 导出的信息，证明以 ZZ 估计子为指导的各向同性加密对于边界层问题可能不是最优的，并设计一种利用 $\\sigma^*$ 中的方向性信息来选择优先加密方向的各向异性加密策略。具体步骤如下：\n- 使用基础网格 $(N_x,N_y)=(8,8)$ 计算给定 $\\epsilon$ 下的方向主导比 $R$。\n- 设定阈值 $\\alpha=3$。如果 $R \\ge \\alpha$，则采用一种各向异性加密规则，对于目标单元预算 $B$（矩形总数），仅沿 $x$ 方向加密，即设置 $(N_x,N_y)=(B/N_y^{(0)},N_y^{(0)})$，其中 $N_y^{(0)}=8$，并假设 $B$ 可被 $N_y^{(0)}$ 整除。否则，采用各向同性加密规则，设置 $(N_x,N_y)=(\\sqrt{B},\\sqrt{B})$。\n- 对于任意 $(N_x,N_y)$，如上定义全局 ZZ 估计子 $\\eta(N_x,N_y;\\epsilon)$。\n\n3) 对于相同的目标单元预算 $B$，将各向同性基准定义为 $(N_x,N_y)=(\\sqrt{B},\\sqrt{B})$，不论 $R$ 值大小。通过比率来比较各向同性和各向异性策略：\n$$\n\\rho(B;\\epsilon) = \\frac{\\eta_{\\text{iso}}(B;\\epsilon)}{\\eta_{\\text{ani}}(B;\\epsilon)},\n$$\n其中 $\\eta_{\\text{iso}}(B;\\epsilon)$ 是在各向同性网格上的 ZZ 估计子，而 $\\eta_{\\text{ani}}(B;\\epsilon)$ 是在各向异性选择的网格上的 ZZ 估计子。\n\n实现一个程序，对于下方的每个测试用例，计算列出的预算 $B$ 所对应的三个比率 $\\rho(B;\\epsilon)$。测试用例集为：\n- $\\epsilon \\in \\{0.2,\\;0.05,\\;1.0\\}$，分别代表中等强度边界层、强边界层和弱（几乎不存在的）边界层。\n- 对每个 $\\epsilon$，预算 $B \\in \\{256,\\;1024,\\;4096\\}$。\n\n所有计算都是无量纲的；不需要物理单位。不使用角度。你的程序应将其最终输出以单行形式生成，该行包含一个类似于 Python 的嵌套列表，结果按以下顺序排列：\n- 一个长度为三的外层列表，每个条目按 $\\epsilon=0.2, \\epsilon=0.05, \\epsilon=1.0$ 的顺序对应一个 $\\epsilon$ 值。\n- 每个条目是一个包含三个浮点数的内层列表，按顺序对应于预算 $B=256, B=1024, B=4096$，其中包含计算出的比率 $\\rho(B;\\epsilon)$。\n\n例如，输出必须具有 \"[[r11,r12,r13],[r21,r22,r23],[r31,r32,r33]]\" 的精确格式，其中每个 \"rij\" 都是一个浮点数。程序不得读取任何输入，也不得打印任何其他内容。", "solution": "所述问题已经过严格验证，并被认定有效。其科学基础在于有限元法的原理，特别是关于通过 Zienkiewicz-Zhu 应力恢复进行的*后验*误差估计。该问题是适定的、客观的，并包含了其唯一、可验证且非平凡解所需的所有信息。不存在矛盾、歧义或事实不准确之处。因此，我们可以着手求解。\n\n该问题要求实现和比较各向同性与各向异性网格加密策略，这些策略由从恢复应力场中提取的方向性信息指导。任务的核心是为各种网格配置计算 Zienkiewicz-Zhu (ZZ) 误差估计子 $\\eta$ 和方向主导比 $R$。\n\n首先，我们建立数学框架。在域 $\\Omega = [0,1] \\times [0,1]$ 上的精确解由下式给出：\n$$\nu(x,y;\\epsilon) = \\left(1 - e^{-\\frac{1-x}{\\epsilon}}\\right)\\,\\sin(\\pi y)\n$$\n精确“应力”（通量）场 $\\sigma$ 是 $u$ 的负梯度：\n$$\n\\sigma(x,y;\\epsilon) = -\\nabla u = -\\begin{pmatrix} \\partial_x u \\\\ \\partial_y u \\end{pmatrix} = -\\begin{pmatrix} \\frac{1}{\\epsilon}e^{-\\frac{1-x}{\\epsilon}}\\sin(\\pi y) \\\\ \\pi\\left(1 - e^{-\\frac{1-x}{\\epsilon}}\\right)\\cos(\\pi y) \\end{pmatrix}\n$$\n域被离散化为 $N_x \\times N_y$ 个矩形单元的笛卡尔网格。每个单元的左下角位于网格点 $(i,j)$，由顶点 $P_{i,j}, P_{i+1,j}, P_{i,j+1}, P_{i+1,j+1}$ 组成。该单元通过从左下顶点 $P_{i,j}$ 到右上顶点 $P_{i+1,j+1}$ 的对角线细分为两个三角形：\n- 顶点为 $(P_{i,j}, P_{i+1,j}, P_{i+1,j+1})$ 的三角形 $K_{1,i,j}$。\n- 顶点为 $(P_{i,j}, P_{i,j+1}, P_{i+1,j+1})$ 的三角形 $K_{2,i,j}$。\n每个三角形的面积是一致的：$|K| = \\frac{1}{2}h_x h_y$，其中 $h_x = 1/N_x$ 且 $h_y = 1/N_y$。\n\n近似解 $u_h$ 是使用分片线性基函数对 $u$ 进行的节点插值。在任意三角形 $K$ 上，梯度 $\\nabla u_h$ 是常数。单元应力 $\\sigma_h|_K = -\\nabla u_h|_K$ 可以从 $u_h$ 的顶点值计算得出。对于一个顶点为 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$、节点值为 $u_1, u_2, u_3$ 的三角形，其梯度为\n$$\n\\nabla u_h = \\frac{1}{2|K|} \\begin{bmatrix}\nu_1(y_2 - y_3) + u_2(y_3 - y_1) + u_3(y_1 - y_2) \\\\\nu_1(x_3 - x_2) + u_2(x_1 - x_3) + u_3(x_2 - x_1)\n\\end{bmatrix}\n$$\n将此应用于单元 $(i,j)$ 中的特定三角形：\n- 对于 $K_{1,i,j}$：$\\nabla u_h = \\left( \\frac{u_{i+1,j} - u_{i,j}}{h_x}, \\frac{u_{i+1,j+1} - u_{i+1,j}}{h_y} \\right)$\n- 对于 $K_{2,i,j}$：$\\nabla u_h = \\left( \\frac{u_{i+1,j+1} - u_{i,j+1}}{h_x}, \\frac{u_{i,j+1} - u_{i,j}}{h_y} \\right)$\n这里，$u_{k,l} = u(k h_x, l h_y; \\epsilon)$ 是来自精确解的节点值。\n\n下一步是 Zienkiewicz-Zhu 应力恢复。在节点 $P$ 处的恢复应力记为 $\\sigma^*(P)$，是所有共享该节点 $P$ 的三角形 $K$ 上的单元应力 $\\sigma_h|_K$ 的面积加权平均。由于所有三角形面积相等，这可以简化为算术平均：\n$$\n\\sigma^*(P) = \\frac{1}{M_P} \\sum_{K \\ni P} \\sigma_h|_K\n$$\n其中 $M_P$是与节点 $P$ 相邻的三角形数量。$M_P$ 的值从1到6不等，具体取决于节点的位置（角点、边点或内部点）。该计算需要为网格上的每个节点细致地记录其三角形连接关系。\n\n一旦节点恢复应力已知，具有顶点 $P_1, P_2, P_3$ 的三角形 $K$ 的单元恢复应力就是其节点值的平均值：\n$$\n\\sigma^*_K = \\frac{1}{3} \\left( \\sigma^*(P_1) + \\sigma^*(P_2) + \\sigma^*(P_3) \\right)\n$$\n那么三角形 $K$ 的局部误差指示器为\n$$\n\\eta_K^2 = |K| \\lVert \\sigma^*_K - \\sigma_h|_K \\rVert_2^2\n$$\n而全局误差估计子是所有 $N_T = 2 N_x N_y$ 个三角形上的总和：\n$$\n\\eta = \\sqrt{\\sum_{K} \\eta_K^2}\n$$\n\n为了指导各向异性加密，我们从恢复应力场计算方向性能量度量：\n$$\nS_x = \\sum_{K} |K|\\,(\\sigma^*_{K,x})^2, \\quad S_y = \\sum_{K} |K|\\,(\\sigma^*_{K,y})^2\n$$\n方向主导比为 $R = \\frac{S_x}{S_y + \\delta}$，其中 $\\delta = 10^{-30}$。较大的 $R$ 值表示误差主要由 $x$ 方向的梯度主导，这表明在 $x$ 方向进行加密更有效率。\n\n对于每个测试用例 $(\\epsilon, B)$，整体算法按以下步骤进行：\n1. 在基础网格 $(N_x^{(0)}, N_y^{(0)}) = (8,8)$ 上计算主导比 $R$。\n2. 如果 $R \\geq \\alpha = 3$，各向异性策略指定网格为 $(N_x, N_y) = (B/8, 8)$。否则，选择各向同性网格 $(N_x, N_y) = (\\sqrt{B}, \\sqrt{B})$。这定义了用于计算 $\\eta_{\\text{ani}}$ 的网格。\n3. 各向同性基准策略始终使用网格 $(N_x, N_y) = (\\sqrt{B}, \\sqrt{B})$，这定义了用于计算 $\\eta_{\\text{iso}}$ 的网格。\n4. 在它们各自的网格上计算 $\\eta_{\\text{ani}}(B;\\epsilon)$ 和 $\\eta_{\\text{iso}}(B;\\epsilon)$。\n5. 计算性能比 $\\rho(B;\\epsilon) = \\eta_{\\text{iso}}(B;\\epsilon) / \\eta_{\\text{ani}}(B;\\epsilon)$。\n\n该实现将重度利用 `numpy` 进行向量化计算。$u$ 的节点值在网格上计算。单元应力 $\\sigma_h$ 使用数组差分计算。节点应力恢复 $\\sigma^*$ 通过遍历每个网格节点并对其定义的邻居单元的贡献求和来执行。单元恢复应力 $\\sigma^*_K$ 以及 $\\eta^2$、$S_x$ 和 $S_y$ 的最终求和也使用向量化操作进行计算。整个过程被封装在一个函数中，针对每种所需的网格配置调用该函数，以获得最终的比率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_quantities(Nx, Ny, epsilon, delta=1e-30):\n    \"\"\"\n    Computes the ZZ error estimator eta and directional ratio R for a given grid and epsilon.\n    \"\"\"\n    if Nx <= 0 or Ny <= 0:\n        raise ValueError(\"Nx and Ny must be positive.\")\n\n    # 1. Grid and Nodal Values\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n    x_coords = np.linspace(0, 1, Nx + 1)\n    y_coords = np.linspace(0, 1, Ny + 1)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n\n    # Exact solution u at nodes\n    U = (1.0 - np.exp(-(1.0 - xx) / epsilon)) * np.sin(np.pi * yy)\n\n    # 2. Element Stresses (sigma_h)\n    # Vectorized computation of gradients on all triangles\n    gradx_h_on_U = np.diff(U, axis=1) / hx\n    grady_h_on_U = np.diff(U, axis=0) / hy\n\n    # Gradients for type 1 triangles (LL, LR, UR)\n    grad_K1_x = gradx_h_on_U[:-1, :]\n    grad_K1_y = grady_h_on_U[:, 1:]\n    sigma_h_K1 = -np.stack([grad_K1_x, grad_K1_y], axis=-1)\n\n    # Gradients for type 2 triangles (LL, UL, UR)\n    grad_K2_x = gradx_h_on_U[1:, :]\n    grad_K2_y = grady_h_on_U[:, :-1]\n    sigma_h_K2 = -np.stack([grad_K2_x, grad_K2_y], axis=-1)\n\n    # 3. Nodal Stress Recovery (sigma_star_nodal)\n    sigma_star_nodal = np.zeros((Ny + 1, Nx + 1, 2))\n    for l in range(Ny + 1):  # y-index\n        for k in range(Nx + 1):  # x-index\n            stresses_sum = np.zeros(2)\n            count = 0\n\n            # Neighbors based on pre-derived connectivity\n            # K1 and K2 from cell (k, l)\n            if k < Nx and l < Ny:\n                stresses_sum += sigma_h_K1[l, k]\n                stresses_sum += sigma_h_K2[l, k]\n                count += 2\n            # K1 from cell (k-1, l)\n            if k > 0 and l < Ny:\n                stresses_sum += sigma_h_K1[l, k - 1]\n                count += 1\n            # K2 from cell (k, l-1)\n            if k < Nx and l > 0:\n                stresses_sum += sigma_h_K2[l - 1, k]\n                count += 1\n            # K1 and K2 from cell (k-1, l-1)\n            if k > 0 and l > 0:\n                stresses_sum += sigma_h_K1[l - 1, k - 1]\n                stresses_sum += sigma_h_K2[l - 1, k - 1]\n                count += 2\n            \n            if count > 0:\n                sigma_star_nodal[l, k] = stresses_sum / count\n\n    # 4. Elementwise Recovered Stress (sigma_star_K) and Indicators\n    # For K1 triangles\n    s_star_p1 = sigma_star_nodal[:-1, :-1]\n    s_star_p2 = sigma_star_nodal[:-1, 1:]\n    s_star_p3 = sigma_star_nodal[1:, 1:]\n    sigma_star_K1 = (s_star_p1 + s_star_p2 + s_star_p3) / 3.0\n\n    # For K2 triangles\n    s_star_p1 = sigma_star_nodal[:-1, :-1]\n    s_star_p2 = sigma_star_nodal[1:, :-1]\n    s_star_p3 = sigma_star_nodal[1:, 1:]\n    sigma_star_K2 = (s_star_p1 + s_star_p2 + s_star_p3) / 3.0\n\n    # 5. Global Quantities\n    tri_area = 0.5 * hx * hy\n    \n    # Global ZZ estimator eta\n    diff1_sq_norm = np.sum((sigma_star_K1 - sigma_h_K1)**2)\n    diff2_sq_norm = np.sum((sigma_star_K2 - sigma_h_K2)**2)\n    eta_squared_sum = tri_area * (diff1_sq_norm + diff2_sq_norm)\n    eta = np.sqrt(eta_squared_sum)\n\n    # Directional dominance ratio R\n    Sx = tri_area * (np.sum(sigma_star_K1[:, :, 0]**2) + np.sum(sigma_star_K2[:, :, 0]**2))\n    Sy = tri_area * (np.sum(sigma_star_K1[:, :, 1]**2) + np.sum(sigma_star_K2[:, :, 1]**2))\n    R = Sx / (Sy + delta)\n\n    return eta, R\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem logic and print the final results.\n    \"\"\"\n    epsilons = [0.2, 0.05, 1.0]\n    budgets = [256, 1024, 4096]\n    alpha = 3.0\n    Nx0, Ny0 = 8, 8\n\n    all_results = []\n\n    for epsilon in epsilons:\n        budget_results = []\n        \n        # Determine refinement strategy based on base mesh\n        _, R_base = compute_quantities(Nx0, Ny0, epsilon)\n        \n        is_anisotropic = R_base >= alpha\n\n        for B in budgets:\n            # Isotropic baseline grid\n            N_iso = int(np.sqrt(B))\n            Nx_iso, Ny_iso = N_iso, N_iso\n            \n            # Anisotropic strategy grid\n            if is_anisotropic:\n                Nx_ani, Ny_ani = int(B / Ny0), Ny0\n            else:\n                N_ani = int(np.sqrt(B))\n                Nx_ani, Ny_ani = N_ani, N_ani\n            \n            # Compute estimators\n            eta_iso, _ = compute_quantities(Nx_iso, Ny_iso, epsilon)\n            eta_ani, _ = compute_quantities(Nx_ani, Ny_ani, epsilon)\n\n            # Compute and store the ratio. Handle division by zero.\n            if eta_ani > 0:\n                rho = eta_iso / eta_ani\n            else: # Should not happen in practice for this problem\n                rho = 1.0 if eta_iso == 0 else np.inf\n                \n            budget_results.append(rho)\n        all_results.append(budget_results)\n\n    # Format the final output exactly as required\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2613032"}]}