{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解始于实践。我们将从一个最简单的一维接触问题开始：一根杆件与一堵刚性墙的碰撞。这个练习旨在揭示增广拉格朗日方法（在此简化为罚函数法）的核心机制，即如何通过一个“软”的罚项来近似一个“硬”的不可侵入约束。通过计算不同罚参数 $\\varepsilon$ 下的接触力，你将亲手验证并直观地理解该方法如何随着罚参数的增大而收敛到精确解，这是掌握此类算法的关键第一步 [@problem_id:2541954]。", "problem": "考虑一根一维线性弹性杆，在有限元法 (FEM) 中使用单个双节点线性有限元进行离散化。该杆的轴向刚度为 $k = \\dfrac{EA}{L}$，其中 $E$ 是杨氏模量，$A$ 是横截面积，$L$ 是长度。左节点的位移被指定为向右的 $u_{1} = U$，而右节点 $u_{2}$ 可能会与一个距离杆未变形右端 $g_{0}$ 的刚性墙发生单边无摩擦接触。采用符号约定，标量法向间隙为 $g(u_{2}) = g_{0} - u_{2}$，单边接触约束为 $g(u_{2}) \\ge 0$。\n\n使用最小总势能原理和处理接触的增广拉格朗日法 (ALM)，专门考虑初始乘子 $\\lambda^{(0)} = 0$ 和固定罚参数 $\\varepsilon > 0$ 的第一次增广迭代。在此特定条件下，第一次增广步的驻定问题简化为最小化弹性势能加上对无穿透约束违背的二次罚项。明确推导 $u_{2}$ 的标量驻定条件，并以闭合形式求解，区分无接触和接触激活两种情况，以获得 $u_{2}(\\varepsilon)$ 以及右节点处的相关反力 $R(\\varepsilon)$。\n\n然后，使用以下数据，\n- $k = 1000\\,\\mathrm{N/m}$，\n- $U = 0.01\\,\\mathrm{m}$，\n- $g_{0} = 0.006\\,\\mathrm{m}$，\n计算在三个罚值 $\\varepsilon \\in \\{100\\,\\mathrm{N/m}, 1000\\,\\mathrm{N/m}, 10000\\,\\mathrm{N/m}\\}$ 下的接触反力 $R(\\varepsilon)$，并确定当 $\\varepsilon \\to \\infty$ 时的极限约束反力 $R^{\\star}$。你可以假设对于这些数据，接触激活分支是相关分支，但必须根据你推导的条件来证明这一点。\n\n将你的最终结果以单行矩阵的形式报告，其中包含以下顺序的四个力：\n$[R(100\\,\\mathrm{N/m}),\\; R(1000\\,\\mathrm{N/m}),\\; R(10000\\,\\mathrm{N/m}),\\; R^{\\star}]$。\n所有力以牛顿为单位表示。提供精确值（不要四舍五入）。", "solution": "我们将杆建模为具有节点位移 $u_{1}$ 和 $u_{2}$ 的单个轴向有限元。该单元的内部弹性势能为\n$$\n\\Pi_{\\text{int}}(u_{1},u_{2}) = \\frac{1}{2}\\,k\\,(u_{1} - u_{2})^{2}.\n$$\n右节点没有外部随动力；左节点位移被指定为 $u_{1} = U$。与右端刚性墙的单边无摩擦接触由法向间隙表示\n$$\ng(u_{2}) = g_{0} - u_{2},\n$$\n约束条件为 $g(u_{2}) \\ge 0$（无穿透）。增广拉格朗日法 (ALM) 对约束使用拉格朗日乘子 $\\lambda$ 和一个罚参数 $\\varepsilon > 0$ 来稳定/改善收敛性。在初始乘子为 $\\lambda^{(0)} = 0$ 的第一次增广步中，增广势能简化为对约束违背的罚正则化：\n$$\n\\Pi_{\\varepsilon}(u_{2}) \\equiv \\Pi_{\\text{int}}(U,u_{2}) + \\frac{\\varepsilon}{2}\\,\\big\\langle -g(u_{2}) \\big\\rangle_{+}^{2}\n= \\frac{1}{2}\\,k\\,(U - u_{2})^{2} + \\frac{\\varepsilon}{2}\\,\\big\\langle u_{2} - g_{0} \\big\\rangle_{+}^{2},\n$$\n其中 $\\langle x \\rangle_{+} = \\max(x,0)$ 是正部函数。极小值点 $u_{2}$ 满足变分驻定条件，我们可以根据接触是未激活 ($u_{2} \\le g_{0}$) 还是激活 ($u_{2} > g_{0}$) 进行分段求导来推导该条件。\n\n情况1（无接触，$u_{2} \\le g_{0}$）：此时 $\\langle u_{2} - g_{0} \\rangle_{+} = 0$，所以\n$$\n\\Pi_{\\varepsilon}(u_{2}) = \\frac{1}{2}\\,k\\,(U - u_{2})^{2}.\n$$\n驻定条件 $\\dfrac{d\\Pi_{\\varepsilon}}{du_{2}} = 0$ 给出\n$$\n-k\\,(U - u_{2}) = 0 \\quad \\Rightarrow \\quad u_{2} = U.\n$$\n该候选解在情况1中是容许的，当且仅当 $u_{2} \\le g_{0}$，即 $U \\le g_{0}$。\n\n情况2（接触激活，$u_{2} > g_{0}$）：此时 $\\langle u_{2} - g_{0} \\rangle_{+} = u_{2} - g_{0}$，且\n$$\n\\Pi_{\\varepsilon}(u_{2}) = \\frac{1}{2}\\,k\\,(U - u_{2})^{2} + \\frac{\\varepsilon}{2}\\,(u_{2} - g_{0})^{2}.\n$$\n驻定条件给出\n$$\n-k\\,(U - u_{2}) + \\varepsilon\\,(u_{2} - g_{0}) = 0\n\\quad \\Rightarrow \\quad\n(k + \\varepsilon)\\,u_{2} = k\\,U + \\varepsilon\\,g_{0}\n\\quad \\Rightarrow \\quad\nu_{2}(\\varepsilon) = \\frac{k\\,U + \\varepsilon\\,g_{0}}{k + \\varepsilon}.\n$$\n该候选解在情况2中是容许的，如果 $u_{2}(\\varepsilon) > g_{0}$。注意到\n$$\nu_{2}(\\varepsilon) - g_{0} = \\frac{k\\,U + \\varepsilon\\,g_{0}}{k + \\varepsilon} - g_{0}\n= \\frac{k\\,(U - g_{0})}{k + \\varepsilon}.\n$$\n因此，如果 $U > g_{0}$ 且 $\\varepsilon > 0$，则 $u_{2}(\\varepsilon) - g_{0} > 0$，所以接触激活的情况是自洽且唯一的。\n\n从罚项可知，右节点的节点接触反力为\n$$\nR(\\varepsilon) = \\varepsilon\\,\\langle u_{2}(\\varepsilon) - g_{0} \\rangle_{+} = \\varepsilon\\,(u_{2}(\\varepsilon) - g_{0})\n= \\varepsilon\\,\\frac{k\\,(U - g_{0})}{k + \\varepsilon}\n= \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0}).\n$$\n等效地，根据内力平衡，杆中的轴力为\n$$\nN(\\varepsilon) = k\\,(U - u_{2}(\\varepsilon)) = \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0}),\n$$\n这与 $R(\\varepsilon)$ 相符，正如预期。\n\n约束（精确）接触解对应于强制施行 $u_{2} = g_{0}$，当 $\\varepsilon \\to \\infty$ 时给出极限反力：\n$$\nR^{\\star} = \\lim_{\\varepsilon \\to \\infty} R(\\varepsilon) = \\lim_{\\varepsilon \\to \\infty} \\frac{\\varepsilon\\,k}{k + \\varepsilon}\\,(U - g_{0})\n= k\\,(U - g_{0}).\n$$\n\n现在代入给定数据 $k = 1000\\,\\mathrm{N/m}$，$U = 0.01\\,\\mathrm{m}$ 和 $g_{0} = 0.006\\,\\mathrm{m}$。首先注意到 $U - g_{0} = 0.004\\,\\mathrm{m} > 0$，因此对于任意 $\\varepsilon > 0$，接触激活分支都适用：\n$$\nR(\\varepsilon) = \\frac{\\varepsilon \\cdot 1000}{1000 + \\varepsilon} \\cdot 0.004.\n$$\n在所要求的罚值下进行计算：\n- 对于 $\\varepsilon = 100\\,\\mathrm{N/m}$，\n$$\nR(100) = \\frac{100 \\cdot 1000}{1000 + 100} \\cdot 0.004\n= \\frac{100000}{1100} \\cdot 0.004\n= \\frac{400}{1100}\n= \\frac{4}{11}.\n$$\n- 对于 $\\varepsilon = 1000\\,\\mathrm{N/m}$，\n$$\nR(1000) = \\frac{1000 \\cdot 1000}{1000 + 1000} \\cdot 0.004\n= \\frac{1000000}{2000} \\cdot 0.004\n= 500 \\cdot 0.004\n= 2.\n$$\n- 对于 $\\varepsilon = 10000\\,\\mathrm{N/m}$，\n$$\nR(10000) = \\frac{10000 \\cdot 1000}{1000 + 10000} \\cdot 0.004\n= \\frac{10000000}{11000} \\cdot 0.004\n= \\frac{40000}{11000}\n= \\frac{40}{11}.\n$$\n最后，约束极限为\n$$\nR^{\\star} = 1000 \\cdot 0.004 = 4.\n$$\n\n因此，所要求的以牛顿为单位的行矩阵是\n$$\n\\big[\\, R(100),\\; R(1000),\\; R(10000),\\; R^{\\star} \\,\\big]\n= \\left[\\, \\frac{4}{11},\\; 2,\\; \\frac{40}{11},\\; 4 \\,\\right].\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{4}{11} & 2 & \\frac{40}{11} & 4\\end{pmatrix}}$$", "id": "2541954"}, {"introduction": "在理解了增广拉格朗日法的基本原理后，下一个挑战是如何高效地求解其引入的非线性方程组。牛顿法是首选工具，其二次收敛速度的秘诀在于精确的切线刚度矩阵（雅可比矩阵）。这个练习将指导你推导接触约束贡献的“一致性切线”，这需要正确处理非光滑的投影算子。掌握这一推导，是构建一个能够处理复杂接触问题的、功能强大且收敛快速的隐式有限元求解器的核心技能 [@problem_id:2541817]。", "problem": "在有限元法 (FEM) 中，考虑一个可变形体与一个刚性障碍物之间的单节点、无摩擦、单边接触。设运动学法向间隙为标量函数 $g(u) = a\\,u - c$，其中 $u \\in \\mathbb{R}$ 是节点法向位移，$a \\in \\mathbb{R}$ 是间隙关于 $u$ 的常数方向导数（其中 $a > 0$），$c \\in \\mathbb{R}$ 是一个常数偏移量。该接触由无摩擦接触的 Kuhn–Tucker 条件所约束：$g(u) \\ge 0$，$\\lambda \\ge 0$ 以及 $g(u)\\,\\lambda = 0$，其中 $\\lambda \\in \\mathbb{R}$ 是法向接触拉格朗日乘子。\n\n采用增广拉格朗日方法 (ALM)，其罚参数为 $\\rho > 0$，在牛顿迭代第 $k$ 步时，乘子的算法投影更新由下式给出\n$$\n\\tilde{\\lambda}(u) \\equiv P\\!\\left(\\lambda^{k} + \\rho\\,g(u)\\right),\n$$\n其中 $P(y) = \\max(0,y)$ 是到 $[0,\\infty)$ 上的投影算子。接触对位移平衡方程全局残差的贡献由下式建模\n$$\nr(u) = a\\,\\tilde{\\lambda}(u).\n$$\n将赫维赛德阶跃函数 $H(y)$ 定义为几乎处处 $y<0$ 时 $H(y)=0$，$y>0$ 时 $H(y)=1$；其在 $y=0$ 处的值可在 $[0,1]$ 中选取，但此处不作要求。\n\n仅从上述定义和互补结构出发，推导一致线性化（牛顿切线）$k(u) = \\frac{dr}{du}$，并考虑投影算子 $P(\\cdot)$ 的导数。引入辅助变量 $y \\equiv \\lambda^{k} + \\rho\\,g(u)$，并用 $a$、$\\rho$ 和 $H(y)$ 的闭式形式表示 $k(u)$ 的最终结果。您的最终答案必须是单一的解析表达式。不需要进行数值计算，也不涉及任何单位。", "solution": "目标是求出接触残差的一致线性化，即其关于位移变量 $u$ 的导数。这便是切向刚度贡献，记为 $k(u)$。\n$$\nk(u) = \\frac{dr}{du}\n$$\n残差 $r(u)$ 定义为 $r(u) = a\\,\\tilde{\\lambda}(u)$。由于 $a$ 是常数，其导数为：\n$$\nk(u) = a\\,\\frac{d\\tilde{\\lambda}}{du}\n$$\n算法乘子 $\\tilde{\\lambda}(u)$ 是一个复合函数，定义为 $\\tilde{\\lambda}(u) = P(y(u))$，其中 $P(y) = \\max(0,y)$，辅助变量 $y(u)$ 由 $y(u) = \\lambda^{k} + \\rho\\,g(u)$ 给出。我们必须应用微分链式法则：\n$$\n\\frac{d\\tilde{\\lambda}}{du} = \\frac{dP}{dy} \\frac{dy}{du}\n$$\n我们将分别计算每一项。\n\n首先，我们求投影算子 $P(y) = \\max(0,y)$ 的导数。这是一个非光滑函数。其导数几乎处处有定义：\n- 当 $y < 0$ 时，$P(y) = 0$，所以 $\\frac{dP}{dy} = 0$。\n- 当 $y > 0$ 时，$P(y) = y$，所以 $\\frac{dP}{dy} = 1$。\n这种行为恰好可以用问题中定义的赫维赛德阶跃函数 $H(y)$ 来描述。因此，我们将投影算子的导数写为：\n$$\n\\frac{dP}{dy} = H(y)\n$$\n在 $y=0$ 处的不可微性在接触力学中是典型的，并由这个广义导数来处理。\n\n其次，我们求辅助变量 $y(u)$ 关于 $u$ 的导数。函数 $y(u)$ 由下式给出：\n$$\ny(u) = \\lambda^{k} + \\rho\\,g(u)\n$$\n代入间隙函数定义 $g(u) = a\\,u - c$：\n$$\ny(u) = \\lambda^{k} + \\rho(a\\,u - c) = \\lambda^{k} + \\rho\\,a\\,u - \\rho\\,c\n$$\n在当前的牛顿迭代中，量 $\\lambda^{k}$、$\\rho$、$a$ 和 $c$ 相对于微分变量 $u$ 都是常数。因此，导数为：\n$$\n\\frac{dy}{du} = \\frac{d}{du} (\\lambda^{k} + \\rho\\,a\\,u - \\rho\\,c) = \\rho\\,a\n$$\n现在，我们将这两个导数代回链式法则表达式中：\n$$\n\\frac{d\\tilde{\\lambda}}{du} = \\frac{dP}{dy} \\frac{dy}{du} = H(y) \\cdot (\\rho\\,a) = \\rho\\,a\\,H(y)\n$$\n最后，我们将此结果代入切向刚度 $k(u)$ 的表达式中：\n$$\nk(u) = a\\,\\frac{d\\tilde{\\lambda}}{du} = a\\,(\\rho\\,a\\,H(y)) = a^2\\,\\rho\\,H(y)\n$$\n这就是接触残差的一致线性化。结果用所要求的项 $a$、$\\rho$ 和 $H(y)$ 表示，其中 $y \\equiv \\lambda^{k} + \\rho\\,g(u)$。", "answer": "$$\n\\boxed{a^2 \\rho H(y)}\n$$", "id": "2541817"}, {"introduction": "现在，我们将所有概念整合起来，解决一个更接近实际的挑战：带有库仑摩擦的接触问题。这个综合性练习要求你实现一个完整的增广拉格朗日更新算法，它能正确处理法向的接触/分离以及切向的粘着/滑移状态。你将实现一个“预测-校正”方案，包括对法向力进行非负投影和对切向力进行“径向返回”投影，以确保其位于摩擦锥内。通过编写代码并测试不同的接触状态，你将把理论知识转化为可工作的算法，这是真正掌握计算接触力学的终极实践 [@problem_id:2541924]。", "problem": "考虑有限元法中使用的单个二维节点到刚性平面的接触单元，其单位外法线与垂直轴对齐。令标量法向间隙表示为 $g_n$，其中 $g_n \\ge 0$ 表示分离，而 $g_n &lt; 0$ 表示必须通过接触力来修正的侵彻。令切向相对位移增量为位于刚性表面切平面内的向量 $\\mathbf{s}_t \\in \\mathbb{R}^2$。接触牵引力由拉格朗日乘子表示：法向乘子 $\\lambda_n \\ge 0$（接触压力，为压应力）和切向乘子向量 $\\boldsymbol{\\lambda}_t \\in \\mathbb{R}^2$。摩擦模型为库仑摩擦，摩擦系数为 $\\mu \\ge 0$。增广拉格朗日方法使用正的罚参数 $\\rho_n > 0$ 和 $\\rho_t > 0$ 分别对法向和切向的拉格朗日乘子进行更新。\n\n从单边接触的基本 Signorini 条件（$g_n \\ge 0$, $\\lambda_n \\ge 0$, 和 $g_n \\lambda_n = 0$）以及由摩擦锥 $\\{\\boldsymbol{\\lambda}_t \\in \\mathbb{R}^2 : \\|\\boldsymbol{\\lambda}_t\\| \\le \\mu \\lambda_n\\}$ 和粘滞/滑移规则定义的库仑摩擦定律出发，推导一个有原则的增广拉格朗日更新方案。该方案通过将无约束的乘子更新量投影到由这些定律所蕴含的容许集上，从而强制施加接触约束。你的推导应从 Karush–Kuhn–Tucker 条件和接触问题的增广拉格朗日量的定义开始，并应展示如何获得 $\\lambda_n$ 和 $\\boldsymbol{\\lambda}_t$ 的算法更新，以及如何根据最终更新的乘子和运动学状态，将接触状态分为分离、粘滞或滑移。\n\n然后，实现一个程序，给定上一时刻的乘子 $\\lambda_n^{\\text{old}}$ 和 $\\boldsymbol{\\lambda}_t^{\\text{old}}$，当前运动学量 $(g_n, \\mathbf{s}_t)$，罚参数 $(\\rho_n, \\rho_t)$ 和摩擦系数 $\\mu$，该程序计算：\n- 更新后的法向乘子 $\\lambda_n^{\\text{new}}$，\n- 更新后的切向乘子 $\\boldsymbol{\\lambda}_t^{\\text{new}}$，\n- 接触状态码 $r \\in \\{0,1,2\\}$，其中 $r=0$ 表示分离，$r=1$ 表示粘滞，$r=2$ 表示滑移。\n\n将所有量表示为无量纲实数；本问题无需物理单位。不涉及角度。该算法必须对试探切向状态恰好位于摩擦锥边界上的边缘情况具有鲁棒性。\n\n使用以下测试套件（每个案例提供 $(g_n, \\mathbf{s}_t, \\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}}, \\rho_n, \\rho_t, \\mu)$）：\n- 案例 A (粘滞): $g_n = -10^{-5}$, $\\mathbf{s}_t = [10^{-7}, 2 \\cdot 10^{-7}]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$。\n- 案例 B (滑移): $g_n = -5 \\cdot 10^{-6}$, $\\mathbf{s}_t = [2 \\cdot 10^{-2}, 0]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$。\n- 案例 C (分离): $g_n = 10^{-3}$, $\\mathbf{s}_t = [10^{-3}, -10^{-3}]$, $\\lambda_n^{\\text{old}} = 10^{3}$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [1, -1]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$。\n- 案例 D (锥面边界，视为粘滞): $g_n = -10^{-6}$, $\\mathbf{s}_t = [6 \\cdot 10^{-7}, 0]$, $\\lambda_n^{\\text{old}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{old}} = [0, 0]$, $\\rho_n = 10^{6}$, $\\rho_t = 5 \\cdot 10^{5}$, $\\mu = 3 \\cdot 10^{-1}$。\n\n你的程序应按 A、B、C、D 的顺序处理这些案例，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个案例的结果本身是包含四个数字的列表 $[\\lambda_n^{\\text{new}}, \\lambda_{t,x}^{\\text{new}}, \\lambda_{t,y}^{\\text{new}}, r]$。例如，最终输出必须类似于 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$，不含任何额外文本。所有数字必须以标准十进制形式打印。接触状态码必须是 $\\{0,1,2\\}$ 中的整数。", "solution": "接触问题的增广拉格朗日更新的推导过程，最清晰的理解方式是将其视为一个预测-校正算法，也称为算子分裂法。这种方法将问题分解为一个无约束的试探步，随后是一个强制施加接触和摩擦物理约束的投影步。\n\n接触界面的状态由法向间隙 $g_n$ 和切向相对位移增量 $\\mathbf{s}_t$ 定义。相应的力（牵引力）是拉格朗日乘子：法向压力 $\\lambda_n$ 和切向牵引力 $\\boldsymbol{\\lambda}_t$。\n\n约束条件如下：\n$1$. 法向（单边接触）：Karush-Kuhn-Tucker (KKT) 条件，也称为 Signorini 条件，规定 $g_n \\ge 0$（无侵彻），$\\lambda_n \\ge 0$（压力是压性的，无粘附），以及 $g_n \\lambda_n = 0$（若存在间隙，则压力为零）。\n$2$. 切向（库仑摩擦）：切向牵引力的大小受法向压力的限制，$\\|\\boldsymbol{\\lambda}_t\\| \\le \\mu \\lambda_n$，其中 $\\mu$ 是摩擦系数。这定义了摩擦锥。系统要么处于粘滞状态（滑移为零），要么处于滑移状态（滑移方向与切向牵引力方向相反）。\n\n增广拉格朗日方法旨在迭代地满足这些条件。一个常见的更新方案可以从增广拉格朗日泛函的驻定性条件推导出来，或者更直接地，通过预测-校正的解释来推导。我们从上一次迭代的状态 $(\\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}})$ 开始，并基于当前的运动学状态 $(g_n, \\mathbf{s}_t)$ 计算新状态 $(\\lambda_n^{\\text{new}}, \\boldsymbol{\\lambda}_t^{\\text{new}})$。\n\n**步骤 1：法向乘子更新（投影到法向压力的容许集上）**\n\n首先，计算一个“试探”法向压力 $\\lambda_n^{\\text{trial}}$。该试探值表示为闭合间隙 $g_n$ 所需的更新压力，并由上一步的压力增广。它是一个基于罚参数 $\\rho_n$ 的线性更新。\n$$\n\\lambda_n^{\\text{trial}} = \\lambda_n^{\\text{old}} - \\rho_n g_n\n$$\n在此方程中，如果存在侵彻（$g_n < 0$），试探压力会增加。如果存在间隙（$g_n > 0$），试探压力会减小。\n\n然而，这个试探压力可能会违反非负约束 $\\lambda_n \\ge 0$。为了强制满足此约束，我们将 $\\lambda_n^{\\text{trial}}$ 投影到非负实数集 $\\mathbb{R}^+ \\cup \\{0\\}$ 上。这个投影是通过斜坡函数，即 $\\max$ 算子实现的。\n$$\n\\lambda_n^{\\text{new}} = \\max(0, \\lambda_n^{\\text{trial}}) = \\max(0, \\lambda_n^{\\text{old}} - \\rho_n g_n)\n$$\n此更新内在地满足了 KKT 条件。如果 $g_n > 0$ 导致 $\\lambda_n^{\\text{trial}} < 0$，更新后的压力将变为 $\\lambda_n^{\\text{new}} = 0$，满足 $\\lambda_n g_n = 0$。如果建立了接触，$\\lambda_n^{\\text{new}} > 0$，这意味着算法正在驱动间隙 $g_n$ 朝向一个非正值（理想情况下为零）以满足互补条件。\n\n如果 $\\lambda_n^{\\text{new}} = 0$，则节点处于分离状态。在这种情况下，不可能存在切向摩擦力，因此我们必须设置 $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\mathbf{0}$。接触状态为**分离**（$r=0$）。该迭代的算法终止。\n\n**步骤 2：切向乘子更新（投影到摩擦锥上）**\n\n如果 $\\lambda_n^{\\text{new}} > 0$，则表面处于接触状态，我们继续更新切向乘子。该过程遵循类似的预测-校正模式。\n\n首先，我们在“粘滞”条件的假设下计算一个试探切向牵引力 $\\boldsymbol{\\lambda}_t^{\\text{trial}}$。该试探牵引力是阻止任何切向滑移 $\\mathbf{s}_t$ 所需的力。\n$$\n\\boldsymbol{\\lambda}_t^{\\text{trial}} = \\boldsymbol{\\lambda}_t^{\\text{old}} + \\rho_t \\mathbf{s}_t\n$$\n必须根据库仑摩擦定律检查此试探状态。切向牵引力的最大容许大小为 $\\mu \\lambda_n^{\\text{new}}$，这取决于**更新后**的法向压力。我们定义一个滑移函数 $\\Phi_t$：\n$$\n\\Phi_t(\\boldsymbol{\\lambda}_t^{\\text{trial}}, \\lambda_n^{\\text{new}}) = \\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| - \\mu \\lambda_n^{\\text{new}}\n$$\n其中 $\\|\\cdot\\|$ 是欧几里得范数。\n\n出现两种情况：\n\n情况 2a：$\\Phi_t \\le 0$（粘滞条件）\n如果试探切向牵引力的大小在摩擦极限内，则粘滞假设有效。试探牵引力是容许的。最终更新的切向牵引力就是试探牵引力。\n$$\n\\boldsymbol{\\lambda}_t^{\\text{new}} = \\boldsymbol{\\lambda}_t^{\\text{trial}}\n$$\n接触状态为**粘滞**（$r=1$）。问题陈述要求将边界情况 $\\Phi_t = 0$ 视为粘滞。\n\n情况 2b：$\\Phi_t > 0$（滑移条件）\n如果试探切向牵引力的大小超过摩擦极限，则粘滞假设无效。系统必须发生滑移。切向牵引力必须位于摩擦锥的边界上。为了强制满足此条件，我们将 $\\boldsymbol{\\lambda}_t^{\\text{trial}}$ 径向投影到半径为 $\\mu \\lambda_n^{\\text{new}}$ 的摩擦圆上。牵引力的方向得以保留，因为它必须与即将发生的运动方向（由 $\\boldsymbol{\\lambda}_t^{\\text{trial}}$ 给出）相反。\n$$\n\\boldsymbol{\\lambda}_t^{\\text{new}} = (\\mu \\lambda_n^{\\text{new}}) \\frac{\\boldsymbol{\\lambda}_t^{\\text{trial}}}{\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|}\n$$\n此操作称为径向返回映射。接触状态为**滑移**（$r=2$）。因为 $\\Phi_t > 0$ 意味着 $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| > \\mu \\lambda_n^{\\text{new}} \\ge 0$，所以除以 $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|$ 是有定义的。\n\n**算法总结**\n对于给定的输入 $(g_n, \\mathbf{s}_t, \\lambda_n^{\\text{old}}, \\boldsymbol{\\lambda}_t^{\\text{old}}, \\rho_n, \\rho_t, \\mu)$：\n$1$. 计算更新后的法向乘子：$\\lambda_n^{\\text{new}} = \\max(0, \\lambda_n^{\\text{old}} - \\rho_n g_n)$。\n$2$. 检查分离：如果 $\\lambda_n^{\\text{new}} \\le 0$（在实践中，可与一个极小的容差或精确的零进行比较），则设置 $\\lambda_n^{\\text{new}} = 0$, $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\mathbf{0}$，状态为分离（$r=0$）。\n$3$. 如果处于接触状态（$\\lambda_n^{\\text{new}} > 0$）：\n    a. 计算试探切向乘子：$\\boldsymbol{\\lambda}_t^{\\text{trial}} = \\boldsymbol{\\lambda}_t^{\\text{old}} + \\rho_t \\mathbf{s}_t$。\n    b. 计算其范数：$\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|$。\n    c. 计算摩擦极限：$F_{\\text{lim}} = \\mu \\lambda_n^{\\text{new}}$。\n    d. 比较并分类：\n        i. 如果 $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| \\le F_{\\text{lim}}$：设置 $\\boldsymbol{\\lambda}_t^{\\text{new}} = \\boldsymbol{\\lambda}_t^{\\text{trial}}$。状态为粘滞（$r=1$）。\n        ii. 如果 $\\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\| > F_{\\text{lim}}$：设置 $\\boldsymbol{\\lambda}_t^{\\text{new}} = F_{\\text{lim}} \\cdot (\\boldsymbol{\\lambda}_t^{\\text{trial}} / \\|\\boldsymbol{\\lambda}_t^{\\text{trial}}\\|)$。状态为滑移（$r=2$）。\n$4$. 返回结果：$(\\lambda_n^{\\text{new}}, \\boldsymbol{\\lambda}_t^{\\text{new}}, r)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_contact_update(g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu):\n    \"\"\"\n    Computes the updated Lagrange multipliers and contact regime for a single node-to-plane element.\n\n    Args:\n        g_n (float): Normal gap (positive for separation).\n        s_t (np.ndarray): Tangential relative displacement increment vector (shape (2,)).\n        lambda_n_old (float): Normal multiplier from the previous iteration.\n        lambda_t_old (np.ndarray): Tangential multiplier vector from the previous iteration (shape (2,)).\n        rho_n (float): Normal penalty parameter.\n        rho_t (float): Tangential penalty parameter.\n        mu (float): Coefficient of friction.\n\n    Returns:\n        list: A list containing [lambda_n_new, lambda_tx_new, lambda_ty_new, regime_code].\n    \"\"\"\n    # Step 1: Normal Multiplier Update\n    lambda_n_trial = lambda_n_old - rho_n * g_n\n    lambda_n_new = max(0.0, lambda_n_trial)\n\n    # Step 2: Check for Separation\n    # A small tolerance is not strictly necessary here since max(0, ...) handles it,\n    # but for floating point comparisons, it's good practice.\n    # We will use direct comparison as the logic is robust.\n    if lambda_n_new == 0.0:\n        lambda_t_new = np.array([0.0, 0.0])\n        regime_code = 0  # Separation\n    else:\n        # Step 3: Tangential Multiplier Update (Contact)\n        # 3a. Compute trial tangential multiplier (stick predictor)\n        lambda_t_trial = lambda_t_old + rho_t * s_t\n\n        # 3b. Calculate its norm\n        norm_lambda_t_trial = np.linalg.norm(lambda_t_trial)\n\n        # 3c. Calculate the friction limit\n        friction_limit = mu * lambda_n_new\n\n        # 3d. Compare and classify (stick/slip)\n        if norm_lambda_t_trial <= friction_limit:\n            # Stick condition (including the on-cone boundary case)\n            lambda_t_new = lambda_t_trial\n            regime_code = 1  # Stick\n        else:\n            # Slip condition (radial return projection)\n            # This check is technically not needed as norm_lambda_t_trial will be > 0.\n            if norm_lambda_t_trial > 0:\n                lambda_t_new = friction_limit * (lambda_t_trial / norm_lambda_t_trial)\n            else: # Should not be reached given the slip condition\n                lambda_t_new = np.array([0.0, 0.0])\n            regime_code = 2  # Slip\n\n    return [lambda_n_new, lambda_t_new[0], lambda_t_new[1], regime_code]\n\ndef solve():\n    \"\"\"\n    Processes the test suite and prints the final results in the specified format.\n    \"\"\"\n    # Test suite: (g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu)\n    test_cases = [\n        # Case A (stick)\n        (-1e-5, np.array([1e-7, 2e-7]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n        # Case B (slip)\n        (-5e-6, np.array([2e-2, 0.0]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n        # Case C (separation)\n        (1e-3, np.array([1e-3, -1e-3]), 1e3, np.array([1.0, -1.0]), 1e6, 5e5, 0.3),\n        # Case D (on-cone boundary, stick)\n        (-1e-6, np.array([6e-7, 0.0]), 0.0, np.array([0.0, 0.0]), 1e6, 5e5, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters\n        g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu = case\n        \n        # Calculate result for the current case\n        result = compute_contact_update(g_n, s_t, lambda_n_old, lambda_t_old, rho_n, rho_t, mu)\n        results.append(result)\n\n    # Format the final output string to be exactly as specified, without extra spaces.\n    results_str_list = []\n    for res in results:\n        # res = [lambda_n, lambda_tx, lambda_ty, regime]\n        # Format numbers to standard decimal form as requested.\n        # Python's f-string with default formatting is sufficient here.\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        results_str_list.append(inner_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2541924"}]}