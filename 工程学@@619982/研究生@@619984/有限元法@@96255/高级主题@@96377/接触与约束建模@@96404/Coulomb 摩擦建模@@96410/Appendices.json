{"hands_on_practices": [{"introduction": "在深入研究复杂的摩擦现象之前，我们必须首先验证数值实现的鲁棒性，确保其在基本和已知的极限情况下表现正确。本练习将引导您完成一项至关重要的验证测试：确保当摩擦系数 $\\mu$ 设为零时，您的库仑摩擦模型能正确地简化为无摩擦接触模型。通过这项实践，您将巩固对接触本构律算法结构的理解，并建立对代码正确性的信心 [@problem_id:2550832]。", "problem": "设计并实现一个验证测试，用于验证有限元方法中的一个库仑摩擦接触算法，该算法在摩擦系数为零时应简化为无摩擦单边接触。目标是确认当摩擦系数设为零时，该方法不产生切向牵引力，并且仅施加单边法向接触响应。您必须从第一性原理导出控制接触响应的方程，并将其实现为一个完整的、可运行的程序，以评估指定的测试套件。\n\n从以下基本原理开始：\n- 离散节点与刚性平面接触的虚功原理，该原理给出了接触牵引力与外力作用之间的平衡关系。\n- 法向的单边（Signorini）接触条件：法向间隙 $g_n$ 满足 $g_n \\ge 0$，法向接触反力 $r_n$ 满足 $r_n \\ge 0$，以及互补条件 $r_n g_n = 0$。\n- 切向平面上摩擦系数为 $\\mu \\ge 0$ 的库仑摩擦模型，其中在滑移过程中，切向牵引力的大小受 $\\mu r_n$ 限制，且方向与切向相对运动相反。\n- 法向接触的罚函数正则化，当试探状态违反 $g_n \\ge 0$ （即当 $g_n < 0$）时，该方法会对侵彻进行惩罚。\n\n离散化模型：\n- 考虑单个表面节点与一个刚性平面相互作用，该平面在接触点具有单位外法线 $\\mathbf{n}$ 和一个正交切向标架 $\\{\\mathbf{t}_1,\\mathbf{t}_2\\}$。\n- 设带符号的法向间隙为 $g_n \\in \\mathbb{R}$，定义为分离时为正，侵彻时为负。设切向间隙矢量为 $\\mathbf{g}_t \\in \\mathbb{R}^2$，在局部切向基中表示。接触反力分解为 $\\mathbf{r} = r_n \\mathbf{n} + \\mathbf{r}_t$，其中 $r_n \\in \\mathbb{R}$ 且 $\\mathbf{r}_t \\in \\mathbb{R}^2$。\n- 使用法向罚刚度 $k_n > 0$ 和切向罚刚度 $k_t > 0$ 来定义摩擦投影之前的试探弹性牵引力。\n\n根据虚功原理和罚函数正则化，法向反力由关于侵彻的二次罚势能的导数得到，\n$$\n\\Pi_n(g_n) = \\tfrac{1}{2} k_n \\,\\langle -g_n \\rangle_+^2,\n$$\n其中 $\\langle x \\rangle_+ = \\max(0,x)$。因此，法向反力为\n$$\nr_n = \\dfrac{\\partial \\Pi_n}{\\partial g_n} \\cdot (-1) = k_n \\,\\langle -g_n \\rangle_+ = k_n \\max(0,-g_n).\n$$\n在切向平面中，定义试探弹性牵引力\n$$\n\\mathbf{t}^{\\text{trial}} = k_t \\,\\mathbf{g}_t.\n$$\n为施加摩擦系数为 $\\mu \\ge 0$ 的库仑摩擦，当接触被激活时，将 $\\mathbf{t}^{\\text{trial}}$ 投影到容许集\n$$\n\\mathcal{C}(r_n) = \\left\\{ \\mathbf{t} \\in \\mathbb{R}^2 \\,:\\, \\|\\mathbf{t}\\| \\le \\mu r_n \\right\\}\n$$\n上。若 $r_n = 0$（无接触），则设 $\\mathbf{r}_t = \\mathbf{0}$。若 $r_n > 0$，则：\n- 若 $\\|\\mathbf{t}^{\\text{trial}}\\| \\le \\mu r_n$，则为粘着，此时 $\\mathbf{r}_t = \\mathbf{t}^{\\text{trial}}$。\n- 若 $\\|\\mathbf{t}^{\\text{trial}}\\| > \\mu r_n$，则为滑移，此时\n$$\n\\mathbf{r}_t = \\mu r_n \\dfrac{\\mathbf{t}^{\\text{trial}}}{\\|\\mathbf{t}^{\\text{trial}\\|}}.\n$$\n当摩擦系数为零，即 $\\mu = 0$ 时，容许集简化为 $\\mathcal{C}(r_n) = \\{\\mathbf{0}\\}$，因此该方法的一致简化是在所有状态下 $\\mathbf{r}_t = \\mathbf{0}$，法向反力 $r_n$ 如上所述。对于任何 $k_t$ 和 $\\mathbf{g}_t$ 的选择，此条件都必须成立，且不产生伪切向牵引力。\n\n编程任务：\n- 实现上述单个节点与刚性平面接触的接触定律，法向反力使用基于罚函数的方法，切向平面使用库仑投影。\n- 使用国际单位制（SI）：长度单位为米（$\\mathrm{m}$），力单位为牛顿（$\\mathrm{N}$）。在内部，所有输入均以SI单位提供。程序的最终输出是表示每个测试通过或失败的无量纲布尔值，因此不应打印任何单位。\n\n测试套件：\n对于每个测试用例，将摩擦系数设为 $\\mu = 0$，计算 $(r_n, \\mathbf{r}_t)$，并使用固定的绝对容差 $\\varepsilon = 10^{-10}$ 验证以下条件：\n- 无伪切向牵引力：$\\|\\mathbf{r}_t\\| \\le \\varepsilon$。\n- 正确的法向反力：$|r_n - k_n \\max(0,-g_n)| \\le \\varepsilon$。\n- 若 $g_n \\ge 0$（分离或接触），则额外验证 $r_n \\le \\varepsilon$。\n\n使用以下五个测试用例（每个元组为 $(g_n, \\mathbf{g}_t, k_n, k_t)$）：\n- 用例A（激活接触状态下大切向滑移的理想路径）：$(-10^{-3}\\ \\mathrm{m},\\ [3\\times 10^{-2},\\ -4\\times 10^{-2}]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$。\n- 用例B（分离）：$(2\\times 10^{-4}\\ \\mathrm{m},\\ [1,\\ -1]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$。\n- 用例C（接触边界）：$(0\\ \\mathrm{m},\\ [10^{-1},\\ 10^{-1}]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$。\n- 用例D（小侵彻及极大切向罚刚度）：$(-5\\times 10^{-5}\\ \\mathrm{m},\\ [5\\times 10^{-1},\\ -5\\times 10^{-1}]\\ \\mathrm{m},\\ 3\\times 10^{8}\\ \\mathrm{N/m},\\ 10^{9}\\ \\mathrm{N/m})$。\n- 用例E（零切向间隙的侵彻）：$(-2\\times 10^{-4}\\ \\mathrm{m},\\ [0,\\ 0]\\ \\mathrm{m},\\ 4\\times 10^{7}\\ \\mathrm{N/m},\\ 5\\times 10^{6}\\ \\mathrm{N/m})$。\n\n程序预期行为：\n- 对于每个用例，使用上述算法（$\\mu = 0$ 和 $\\varepsilon = 10^{-10}$）计算 $(r_n, \\mathbf{r}_t)$，然后将三个检查评估为每个用例的单个通过/失败布尔值：如果所有适用检查都满足，则用例通过。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个方括号内用逗号分隔的列表（例如，“[true1,true2,true3,true4,true5]”）。使用Python布尔字面量（“True”或“False”）。", "solution": "我们针对与刚性平面接触的单个节点，推导一个一致的离散接触响应。该推导在法向使用罚函数正则化，在切向对库仑摩擦使用返回映射投影。推导从虚功原理开始，该原理指出内力和接触力的虚功与外力的虚功相平衡。对于与刚性平面相互作用的单个节点，接触力是界面上唯一的内力贡献，并与间隙功共轭。\n\n法向接触。单边约束由Signorini条件表达：$g_n \\ge 0$，$r_n \\ge 0$，$r_n g_n = 0$。为正则化此约束，我们引入一个仅作用于侵彻的凸罚势能，\n$$\n\\Pi_n(g_n) = \\tfrac{1}{2} k_n \\,\\langle -g_n \\rangle_+^2,\n$$\n其中 $k_n > 0$ 且 $\\langle x \\rangle_+ = \\max(0,x)$。法向接触反力根据链式法则，由增广能量相对于间隙虚变分的平稳性得出，\n$$\n\\delta \\Pi_n = \\dfrac{\\partial \\Pi_n}{\\partial g_n} \\,\\delta g_n, \\quad \\text{和} \\quad \\delta W_n = r_n \\,\\delta g_n,\n$$\n因此，通过辨识可得 $r_n = \\partial \\Pi_n/\\partial g_n \\cdot (-1)$ （出现负号是因为当 $g_n$ 正向减小时，正的压缩反力做负功）。求导可得\n$$\nr_n = k_n \\,\\langle -g_n \\rangle_+ = k_n \\max(0,-g_n).\n$$\n此响应在分离或接触（$g_n \\ge 0$）时强制 $r_n = 0$，在侵彻（$g_n < 0$）时强制 $r_n = k_n (-g_n)$，这在极限 $k_n \\to \\infty$ 的情况下与单边约束是一致的。\n\n切向接触与库仑摩擦。在切向平面，从二次罚储存能定义弹性试探牵引力，\n$$\n\\Pi_t(\\mathbf{g}_t) = \\tfrac{1}{2} k_t \\,\\|\\mathbf{g}_t\\|^2, \\quad \\mathbf{t}^{\\text{trial}} = \\dfrac{\\partial \\Pi_t}{\\partial \\mathbf{g}_t} = k_t \\,\\mathbf{g}_t,\n$$\n其中 $k_t > 0$。当接触被激活时，库仑摩擦将容许的切向牵引力 $\\mathbf{r}_t$ 限制在切向平面内一个半径为 $\\mu r_n$ 的闭凸集（圆盘）内，\n$$\n\\mathcal{C}(r_n) = \\left\\{ \\mathbf{t} \\in \\mathbb{R}^2 \\,:\\, \\|\\mathbf{t}\\| \\le \\mu r_n \\right\\}.\n$$\n当 $r_n = 0$（无激活接触）时，不存在容许的切向牵引力，且一致性要求 $\\mathbf{r}_t = \\mathbf{0}$。当 $r_n > 0$ 时，一致的算法是将试探牵引力在欧几里得范数意义下正交投影到 $\\mathcal{C}(r_n)$ 上：\n- 若 $\\|\\mathbf{t}^{\\text{trial}}\\| \\le \\mu r_n$ （粘着），则 $\\mathbf{r}_t = \\mathbf{t}^{\\text{trial}}$。\n- 否则（滑移），在 $\\mathbf{t}^{\\text{trial}}$ 方向上投影到半径为 $\\mu r_n$ 的圆周上，可得\n$$\n\\mathbf{r}_t = \\mu r_n \\,\\dfrac{\\mathbf{t}^{\\text{trial}}}{\\|\\mathbf{t}^{\\text{trial}}\\|}.\n$$\n此投影是 $\\|\\mathbf{t} - \\mathbf{t}^{\\text{trial}}\\|$ 在约束条件 $\\mathbf{t} \\in \\mathcal{C}(r_n)$ 下的唯一极小值点，并且是有限元实现中使用的标准返回映射算法的离散对应形式。\n\n零摩擦极限。当 $\\mu = 0$ 时，对于任何 $r_n \\ge 0$，容许集都简化为 $\\mathcal{C}(r_n) = \\{\\mathbf{0}\\}$。因此，当 $r_n > 0$ 时，粘着条件和滑移投影都坍缩到唯一的容许值\n$$\n\\mathbf{r}_t = \\mathbf{0}.\n$$\n当 $r_n = 0$ 时，根据分离（或接触）的一致性要求，我们同样有 $\\mathbf{r}_t = \\mathbf{0}$。因此，无论切向间隙 $\\mathbf{g}_t$ 或切向罚刚度 $k_t$ 如何，$\\mu = 0$ 的库仑模型都严格简化为无摩擦单边接触：即纯法向反力，无伪切向牵引力。\n\n验证检查。为了验证此简化，我们检验：\n- 无伪切向牵引力：$\\|\\mathbf{r}_t\\| \\le \\varepsilon$，其中 $\\varepsilon$ 为小容差。\n- 正确的法向反力：$|r_n - k_n \\max(0,-g_n)| \\le \\varepsilon$。\n- 分离时的一致性：若 $g_n \\ge 0$，则 $r_n \\le \\varepsilon$。\n\n各测试用例的算法步骤：\n1. 输入 $(g_n, \\mathbf{g}_t, k_n, k_t)$，并设置 $\\mu = 0$ 和一个容差 $\\varepsilon$。\n2. 计算 $r_n = k_n \\max(0,-g_n)$。\n3. 如果 $r_n = 0$，设置 $\\mathbf{r}_t = \\mathbf{0}$。否则，计算 $\\mathbf{t}^{\\text{trial}} = k_t \\,\\mathbf{g}_t$，并将其投影到 $\\mu = 0$ 的 $\\mathcal{C}(r_n)$ 上，得到 $\\mathbf{r}_t = \\mathbf{0}$。\n4. 评估三个检查，并为该用例记录一个布尔值的通过/失败结果。\n\n所提供的程序实现了此算法并执行了五个指定的用例：\n- 用例A（侵彻及大切向滑移）测试激活接触状态，并确保即使在大的 $\\|\\mathbf{g}_t\\|$ 和大的 $k_t$ 下，$\\mathbf{r}_t = \\mathbf{0}$。\n- 用例B（分离）测试互补性：$r_n$ 和 $\\|\\mathbf{r}_t\\|$ 都必须在容差范围内为零。\n- 用例C（接触边界）进一步测试单边约束的边界。\n- 用例D（小侵彻，极大切向罚刚度）在极端试探切向牵引力下对投影进行压力测试，并确认其返回值仍为 $\\mathbf{0}$。\n- 用例E（侵彻及零切向间隙）测试切向试探牵引力恰好为零的极限情况。\n\n输出是包含五个布尔值的单个列表，每个用例一个。如果实现正确地在 $\\mu=0$ 时简化为无伪切向牵引力的无摩擦接触，则所有布尔值都必须为 True。", "answer": "```python\nimport numpy as np\n\ndef contact_response(g_n, g_t_vec, k_n, k_t, mu, tol=1e-14):\n    \"\"\"\n    Compute contact reaction for a single node against a rigid plane.\n\n    Parameters:\n        g_n (float): normal gap (m), positive in separation, negative in penetration.\n        g_t_vec (array-like): tangential gap vector (m) in 2D tangential frame.\n        k_n (float): normal penalty stiffness (N/m).\n        k_t (float): tangential penalty stiffness (N/m).\n        mu (float): Coulomb friction coefficient (dimensionless).\n        tol (float): small tolerance for numerical decisions.\n\n    Returns:\n        r_n (float): normal reaction (N), non-negative.\n        r_t (np.ndarray): tangential reaction vector (N) in 2D.\n    \"\"\"\n    g_t = np.array(g_t_vec, dtype=float).reshape(2)\n    # Normal reaction via penalty on interpenetration\n    r_n = k_n * max(0.0, -g_n)\n\n    # If no contact is active, no tangential traction\n    if r_n <= tol:\n        return 0.0, np.zeros(2)\n\n    # Trial tangential elastic traction\n    t_trial = k_t * g_t\n    norm_t_trial = np.linalg.norm(t_trial)\n    bound = mu * r_n\n\n    if norm_t_trial <= bound + tol:\n        # Stick\n        r_t = t_trial\n    else:\n        # Slip: project onto friction disk\n        if norm_t_trial <= tol or bound <= tol:\n            r_t = np.zeros(2)\n        else:\n            r_t = (bound / norm_t_trial) * t_trial\n\n    return r_n, r_t\n\n\ndef run_tests():\n    # Frictionless limit\n    mu = 0.0\n    # Tolerances for verification\n    tol_force = 1e-10\n\n    test_cases = [\n        # (g_n, g_t, k_n, k_t)\n        (-1e-3,  [3e-2, -4e-2], 1e7, 2e7),      # Case A: penetration, large tangential slip\n        ( 2e-4,  [1.0,  -1.0],  1e7, 2e7),      # Case B: separation\n        ( 0.0,   [1e-1,  1e-1], 1e7, 2e7),      # Case C: touching boundary\n        (-5e-5,  [5e-1, -5e-1], 3e8, 1e9),      # Case D: small penetration, very stiff kt\n        (-2e-4,  [0.0,   0.0],  4e7, 5e6),      # Case E: penetration, zero tangential gap\n    ]\n\n    results = []\n    for g_n, g_t, k_n, k_t in test_cases:\n        r_n, r_t = contact_response(g_n, g_t, k_n, k_t, mu)\n        # Checks\n        # 1) No spurious tangential traction\n        no_spurious_tan = np.linalg.norm(r_t) <= tol_force\n        # 2) Correct normal reaction\n        r_n_expected = k_n * max(0.0, -g_n)\n        correct_normal = abs(r_n - r_n_expected) <= tol_force\n        # 3) If separation or touching, r_n must be zero\n        sep_touch_ok = True\n        if g_n >= 0.0:\n            sep_touch_ok = r_n <= tol_force\n\n        results.append(bool(no_spurious_tan and correct_normal and sep_touch_ok))\n    return results\n\n\ndef solve():\n    results = run_tests()\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2550832"}, {"introduction": "在完成基本验证之后，下一步是评估有限元近似的准确性和收敛性，尤其是在模拟粘滑（stick-slip）边界等界面非线性行为时。本练习要求您设计一个网格细化研究，以定量评估您的离散化方法如何捕捉连续的切向牵引力场和离散的粘滑区域划分。通过分析收敛性，您将更深入地了解有限元方法在处理摩擦问题时的可靠性和局限性 [@problem_id:2550840]。", "problem": "针对一个带有Coulomb摩擦的二维平面滑块接触问题，设计并实现一个自洽的一维界面有限元离散化网格细化研究。其目标是随着界面网格的细化，评估计算出的切向反力场以及粘滑界面划分的收敛性。所有量均为无量纲；所有输出均以无量纲浮点数的形式报告。\n\n基础和建模的基本假设：\n- 接触界面为长度 $L>0$ 的线段 $\\left[0,L\\right]$。\n- 沿界面法向接触压力是均匀的，等于 $p_n>0$。\n- 切向摩擦系数为 $\\mu>0$。\n- 切向罚刚度为 $k_t>0$。\n- 在满载下，规定的相对切向滑移场为 $g_t(x)=U_0\\left(\\dfrac{x}{L}\\right)^{\\alpha}$，其中 $x\\in[0,L]$，且给定了 $U_0\\ge 0$ 和 $\\alpha\\ge 1$。\n- 带罚函数正则化的Coulomb摩擦定律逐点施加如下。定义试探切向牵引力 $t_{\\mathrm{tr}}(x)=k_t\\,g_t(x)$。则容许的切向牵引力为\n$$\nt(x)=\\begin{cases}\nt_{\\mathrm{tr}}(x), & \\text{若 } \\left|t_{\\mathrm{tr}}(x)\\right|\\le \\mu\\,p_n \\quad \\text{(粘滞)},\\\\\n\\mu\\,p_n\\,\\mathrm{sign}\\!\\left(t_{\\mathrm{tr}}(x)\\right), & \\text{若 } \\left|t_{\\mathrm{tr}}(x)\\right|>\\mu\\,p_n \\quad \\text{(滑移)}.\n\\end{cases}\n$$\n该局部返回映射算法使用给定的罚刚度来施加Coulomb边界。\n- 界面的有限元 (FE) 近似在 $[0,L]$上使用$N$个均匀分布的节点。相对滑移的离散节点值取为在节点处采样的精确值$g_t(x)$。$g_t$在界面上的有限元插值是标准的分段线性插值。近似切向牵引力场$t_h(x)$通过在每个$x$处对插值后的滑移值应用上述局部返回映射算法得到。\n\n参考解和误差范数的定义：\n- 通过在$[0,L]$上的一个包含$n_{\\mathrm{ref}}$个均匀分布采样点的精细网格上，使用精确的$g_t(x)$计算$t(x)$来定义一个高分辨率参考场。将这些采样点位置表示为$\\{x_i\\}_{i=0}^{n_{\\mathrm{ref}}-1}$，其间距为$\\Delta x = \\dfrac{L}{n_{\\mathrm{ref}}-1}$。令$t_{\\mathrm{ref},i}=t(x_i)$。\n- 对于一个给定的具有$N$个节点的有限元网格，通过计算网格上$g_t$的分段线性插值并在每个$x_i$处应用相同的返回映射算法来定义$t_{h,i}=t_h(x_i)$。\n- 切向牵引力的相对$L^2$误差为\n$$\n\\mathcal{E}_{L^2}=\\frac{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{h,i}-t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}}{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}},\n$$\n其中梯形权重为$w_0=w_{n_{\\mathrm{ref}}-1}=\\dfrac{\\Delta x}{2}$，$w_i=\\Delta x$（对于$i=1,\\dots,n_{\\mathrm{ref}}-2$）。如果分母为零，则定义$\\mathcal{E}_{L^2}=0$。\n- 粘滑划分误差的定义方法是：对于参考场，如果$\\left|t_{\\mathrm{tr}}(x_i)\\right|\\le \\mu\\,p_n$，则将每个采样点$x_i$分类为粘滞，否则为滑移；对于近似场，则类似地使用有限元插值滑移进行分类。令$s_{\\mathrm{ref},i}\\in\\{0,1\\}$，粘滞为1，滑移为0；令$s_{h,i}$为在$x_i$处相应的基于有限元的分类。划分误差是对称差分数\n$$\n\\mathcal{E}_{\\mathrm{part}}=\\frac{1}{n_{\\mathrm{ref}}}\\sum_{i=0}^{n_{\\mathrm{ref}}-1}\\left|s_{h,i}-s_{\\mathrm{ref},i}\\right|.\n$$\n\n算法要求：\n- 为多组参数集实现上述模型和误差计算。对参考解使用精确的$g_t(x)$，对离散近似使用有限元插值的$g_t(x)$。\n- 使用$n_{\\mathrm{ref}}=4001$的参考网格来数值近似积分和划分度量。\n- 所有计算均为无量纲。以无量纲浮点数的形式报告$\\mathcal{E}_{L^2}$和$\\mathcal{E}_{\\mathrm{part}}$。\n\n测试套件：\n除非另有说明，所有测试均使用以下固定参数：$L=1$, $\\mu=0.3$, $p_n=1$, $k_t=50$。定义六个测试用例，涵盖理想路径、细化过程和边界情况：\n- 用例 1：$N=4$, $U_0=0.02$, $\\alpha=1$。\n- 用例 2：$N=8$, $U_0=0.02$, $\\alpha=1$。\n- 用例 3：$N=16$, $U_0=0.02$, $\\alpha=1$。\n- 用例 4：$N=8$, $U_0=0.001$, $\\alpha=1$。\n- 用例 5：$N=8$, $U_0=0.5$, $\\alpha=1$。\n- 用例 6：$N=8$, $U_0=0.02$, $\\alpha=3$。\n\n程序必须执行的操作：\n- 对每个用例，按上述定义计算$\\mathcal{E}_{L^2}$和$\\mathcal{E}_{\\mathrm{part}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个结果必须是$[\\mathcal{E}_{L^2},\\mathcal{E}_{\\mathrm{part}}]$形式的双元素列表，因此最终输出的格式为“[ [e11,e12],[e21,e22],...[e61,e62] ]”，其中每个$e$都是一个浮点数。", "solution": "本解决方案旨在为一维摩擦接触问题实现网格细化研究。这涉及将有限元（FE）近似解与高分辨率的参考解进行比较。该问题的核心在于正确实现有限元近似的两个关键部分：分段线性插值和决定摩擦响应的非线性返回映射算法。\n\n首先，我们建立解析框架。物理域是区间 $[0,L]$。规定的相对滑移为 $g_t(x) = U_0 (x/L)^\\alpha$。由于所有参数均为非负，试探切向牵引力 $t_{\\mathrm{tr}}(x) = k_t g_t(x)$ 也是非负的。摩擦响应由库仑条件控制，最大容许牵引力（摩擦极限）为 $\\tau_{\\mathrm{crit}} = \\mu p_n$。因此，返回映射算法可以简化为：\n$$\nt(x) = \\min(t_{\\mathrm{tr}}(x), \\tau_{\\mathrm{crit}})\n$$\n粘滑状态由 $t_{\\mathrm{tr}}(x) \\le \\tau_{\\mathrm{crit}}$（粘滞）还是 $t_{\\mathrm{tr}}(x) > \\tau_{\\mathrm{crit}}$（滑移）来决定。\n\n参考解是在一个包含 $n_{\\mathrm{ref}}=4001$ 个点的精细网格上计算的。对于网格上的每个点 $x_i$，我们使用精确的滑移函数 $g_t(x_i)$ 来计算参考牵引力 $t_{\\mathrm{ref},i}$ 和粘滑状态 $s_{\\mathrm{ref},i}$。\n\n有限元近似解是基于一个包含 $N$ 个均匀节点的粗网格构建的。我们首先在这些节点上计算精确的滑移值。然后，我们使用分段线性插值来获得在整个域上定义的近似滑移场 $g_h(x)$。这个近似的滑移场随后在精细参考网格的每个点 $x_i$ 上被评估，以计算近似牵引力 $t_{h,i}$ 和粘滑状态 $s_{h,i}$。\n\n最后，我们通过计算两个误差度量来量化近似解的准确性：\n1. 相对 $L^2$ 误差 $\\mathcal{E}_{L^2}$，它使用梯形法则进行数值积分，衡量了牵引力场的整体误差。\n2. 划分误差 $\\mathcal{E}_{\\mathrm{part}}$，它计算了被错误分类为粘滞或滑移的点的比例。\n\n该算法遍历每个测试用例，执行上述步骤，并计算两种误差度量。用例1到3展示了随着网格细化（$N$ 从4增加到16），误差如何减小，从而验证了收敛性。其他用例则探讨了模型对滑移量值（$U_0$）及其空间分布（$\\alpha$）的敏感性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D frictional contact problem for a suite of test cases.\n    \"\"\"\n\n    # Define the 6 test cases from the problem statement.\n    # Format: (N, U0, alpha)\n    test_cases = [\n        (4, 0.02, 1),\n        (8, 0.02, 1),\n        (16, 0.02, 1),\n        (8, 0.001, 1),\n        (8, 0.5, 1),\n        (8, 0.02, 3),\n    ]\n\n    # Fixed parameters for all tests\n    L = 1.0\n    mu = 0.3\n    p_n = 1.0\n    k_t = 50.0\n    n_ref = 4001\n\n    results = []\n\n    for case in test_cases:\n        N, U0, alpha = case\n\n        # Friction limit (critical traction)\n        tau_crit = mu * p_n\n\n        # --- High-resolution reference solution ---\n\n        # Define the fine reference grid\n        x_ref = np.linspace(0, L, n_ref)\n\n        # Exact prescribed relative slip field g_t(x)\n        g_t = lambda x: U0 * (x / L)**alpha if L > 0 else (U0 if x == 0 else 0)\n        \n        # Evaluate exact slip on the reference grid\n        g_ref = g_t(x_ref)\n\n        # Calculate reference trial traction\n        t_tr_ref = k_t * g_ref\n\n        # Apply return-mapping to get reference traction field t(x)\n        # Since t_tr is non-negative, this is a simple min operation\n        t_ref = np.minimum(t_tr_ref, tau_crit)\n\n        # Determine reference stick-slip partition\n        # s=1 for stick, s=0 for slip\n        s_ref = (t_tr_ref = tau_crit).astype(int)\n\n        # --- Finite Element (FE) approximation ---\n\n        # Define the coarse FE nodal grid\n        x_nodes = np.linspace(0, L, N)\n\n        # Evaluate exact slip at the FE nodes\n        g_nodal = g_t(x_nodes)\n\n        # Compute the piecewise linear interpolation of slip on the reference grid\n        g_h = np.interp(x_ref, x_nodes, g_nodal)\n\n        # Calculate approximate trial traction from interpolated slip\n        t_tr_h = k_t * g_h\n\n        # Apply return-mapping to get approximate traction field t_h(x)\n        t_h = np.minimum(t_tr_h, tau_crit)\n\n        # Determine approximate stick-slip partition\n        s_h = (t_tr_h = tau_crit).astype(int)\n\n        # --- Error computation ---\n\n        # 1. Relative L2 error in tangential traction\n        delta_x = L / (n_ref - 1)\n        weights = np.full(n_ref, delta_x)\n        weights[0] = delta_x / 2.0\n        weights[-1] = delta_x / 2.0\n\n        l2_err_numerator = np.sqrt(np.sum(weights * (t_h - t_ref)**2))\n        l2_norm_ref = np.sqrt(np.sum(weights * t_ref**2))\n        \n        if l2_norm_ref > 1e-15:\n            e_l2 = l2_err_numerator / l2_norm_ref\n        else:\n            e_l2 = 0.0 # As per problem statement\n\n        # 2. Stick-slip partition error\n        e_part = np.mean(np.abs(s_h - s_ref))\n\n        results.append([e_l2, e_part])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2550840"}, {"introduction": "摩擦耗散本质上是路径依赖的，这意味着其计算必须遵循客观性（objectivity）原则，即计算结果不应随观察者参考系的变化而改变。本练习通过一个经典的“旋转环”基准问题，展示了在处理复杂、非比例加载路径时，算法中采用客观更新的关键重要性。通过对比物理上正确的客观算法与简化的非客观算法，您将直接观察到后者如何导致对能量耗散的根本性错误预测 [@problem_id:2550801]。", "problem": "考虑一个半径为 $r$、宽度为 $b$ 的薄圆环，在均匀接触压力 $p$（单位为 $\\mathrm{Pa} = \\mathrm{N}/\\mathrm{m}^2$）的作用下被压在一个刚性平面上。该圆环位于 $z=0$ 平面内，平面的外法向单位向量与全局 $z$ 轴对齐。该圆环在平面内承受一个给定的相对切向运动：在圆环上的每个材料点，其瞬时相对切向速度矢量的大小恒为 $v_s$（单位为 $\\mathrm{m}/\\mathrm{s}$），其方向以角速度 $\\omega$（单位为 $\\mathrm{rad}/\\mathrm{s}$）绕平面法线旋转。这模拟了“刚性平面上的旋转环”问题，其中滑移方向随时间旋转。假设库仑摩擦系数 $\\mu$ 为常数（无量纲）。总法向力为 $F_N = p \\cdot (2\\pi r b)$（单位为 $\\mathrm{N}$）。您将通过对比在时间范围 $T$（单位为 $\\mathrm{s}$）内计算切向功的两种离散算法，来研究有限元法（FEM）背景下摩擦功计算的客观性。\n\n您的模型应基于以下基本定律和核心定义：\n- 库仑摩擦定律：发生滑移时，摩擦力的大小为 $F_T = \\mu F_N$。\n- 机械功：切向功增量为 $\\mathrm{d}W = \\boldsymbol{F}_T \\cdot \\mathrm{d}\\boldsymbol{u}_t$，其中 $\\mathrm{d}\\boldsymbol{u}_t$ 是平面内的切向滑移增量矢量。\n- 客观性（标架无关性）：在叠加的刚体运动（包括空间坐标系的旋转）下，诸如耗散功之类的物理可测量必须保持不变。\n\n将瞬时相对切向速度定义为一个平面矢量 $\\boldsymbol{v}_{\\mathrm{rel}}(t)$，其大小恒为 $v_s$，方向以角速度 $\\omega$ 绕平面法线旋转，即对所有 $t \\in [0,T]$，$\\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| = v_s$，其在平面内的方向为 $\\boldsymbol{e}_t(t) = [\\cos(\\omega t), \\sin(\\omega t)]$。法向没有耦合；接触保持闭合，且 $F_N$ 恒定。\n\n实现并比较以下两种用于计算在 $t \\in [0,T]$ 上累积的总切向功 $W$ 的离散算法：\n\n- 客观增量功累积（带客观标架更新）：\n  - 将区间 $[0,T]$ 划分为 $M$ 个大小为 $\\Delta t = T/M$ 的均匀子步。\n  - 在每个子步 $k$，使用当前方向 $\\boldsymbol{e}_t(t_k)$ 计算切向滑移增量 $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\,\\Delta t$，并累积功增量 $\\Delta W_{\\mathrm{obj}}^{(k)} = \\mu F_N \\|\\Delta \\boldsymbol{u}_t^{(k)}\\|$。\n  - 总客观功为 $W_{\\mathrm{obj}} = \\sum_{k=1}^{M} \\Delta W_{\\mathrm{obj}}^{(k)}$。\n  - 该算法通过在每一步使用瞬时方向 $\\boldsymbol{e}_t(t_k)$ 来更新切向标架，从而保持了客观性。\n\n- 非客观累积（不带客观标架更新）：\n  - 将区间 $[0,T]$ 划分为 $M$ 个大小为 $\\Delta t = T/M$ 的均匀子步。\n  - 在每个子步 $k$，计算切向滑移增量 $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\,\\Delta t$，但只在一个固定的初始标架中累积平面滑移矢量：$\\boldsymbol{s} \\leftarrow \\boldsymbol{s} + \\Delta \\boldsymbol{u}_t^{(k)}$，其中 $\\boldsymbol{s}$ 在 $t=0$ 时初始化为 $\\boldsymbol{0}$。\n  - 最后，计算 $W_{\\mathrm{no}} = \\mu F_N \\|\\boldsymbol{s}\\|$。\n  - 该算法不随演化的切向标架旋转所存储的切向状态，因此在旋转的滑移方向下不具有客观性。\n\n您的任务是实现一个程序，为以下四个测试用例组成的测试套件计算 $W_{\\mathrm{obj}}$ 和 $W_{\\mathrm{no}}$。角度单位使用弧度，角速度单位为 $\\mathrm{rad}/\\mathrm{s}$，长度单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，力单位为 $\\mathrm{N}$，压力单位为 $\\mathrm{Pa}$，功单位为 $\\mathrm{J}$。为保证数值稳定性和一致性，为每个用例选择一个整数 $M \\geq 10^4$ 个子步（您可以选择任何能提供数值稳定结果的固定 $M$；由于 $\\|\\boldsymbol{v}_{\\mathrm{rel}}\\|$ 不随时间变化，客观算法的结果与 $M$ 无关）。\n\n使用以下参数集：\n- 用例 A (一般的旋转滑移方向):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 2.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.25\\,\\mathrm{s}$.\n- 用例 B (滑移方向恰好旋转完整一周):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 2.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = \\dfrac{2\\pi}{\\omega}\\,\\mathrm{s}$.\n- 用例 C (标架旋转非常慢，近乎恒定的滑移方向):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 0.001\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$.\n- 用例 D (无旋转，恒定的滑移方向):\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 0.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$.\n\n您的程序必须：\n- 为每个用例计算 $F_N = p \\cdot (2\\pi r b)$。\n- 为每个用例按上文定义计算 $W_{\\mathrm{obj}}$ 和 $W_{\\mathrm{no}}$。\n- 将所有功值以 $\\mathrm{J}$ 为单位表示，并四舍五入到六位小数。\n- 生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序如下：\n  - $[W_{\\mathrm{obj}}^{A}, W_{\\mathrm{no}}^{A}, W_{\\mathrm{obj}}^{B}, W_{\\mathrm{no}}^{B}, W_{\\mathrm{obj}}^{C}, W_{\\mathrm{no}}^{C}, W_{\\mathrm{obj}}^{D}, W_{\\mathrm{no}}^{D}]$。\n\n覆盖性设计：\n- 用例 A 代表无特殊对称性的一般旋转滑移方向。\n- 用例 B 是一个边界条件，非客观累积在此情况下遭受最大抵消误差。\n- 用例 C 是一个边缘情况，标架旋转非常慢且两种方法几乎重合。\n- 用例 D 是滑移方向恒定且两种方法必须完全一致的极限情况。\n\n无需读取任何输入；所有参数均按上文指定固定。输出必须是确定性的和可复现的。", "solution": "该问题要求对比两种计算摩擦功的方法，以揭示在处理旋转滑移路径时数值算法客观性的重要性。\n\n首先，我们确定关键的物理量。总法向力为压力与接触面积的乘积：$F_N = p \\cdot (2\\pi r b)$。根据库仑定律，滑移过程中的摩擦力大小恒为 $F_T = \\mu F_N$。\n\n物理上正确的总耗散功是摩擦功率对时间的积分。由于速度大小恒为 $v_s$，增量滑移距离为 $\\mathrm{d}s = v_s \\mathrm{d}t$。因此，总功是对路径长度的积分：\n$$W = \\int_0^T F_T \\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| \\mathrm{d}t = \\int_0^T (\\mu F_N) v_s \\mathrm{d}t = \\mu F_N v_s T$$\n这个表达式是总耗散功的精确解析解。\n\n我们分析问题中提出的两种离散算法：\n\n1.  **客观增量功累积 ($W_{\\mathrm{obj}}$)**：该算法在每个时间步 $k$ 内计算功的标量增量 $\\Delta W_{\\mathrm{obj}}^{(k)} = F_T \\|\\Delta \\boldsymbol{u}_t^{(k)}\\| = (\\mu F_N) (v_s \\Delta t)$，然后将它们累加起来。总功为 $W_{\\mathrm{obj}} = \\sum_{k=1}^{M} \\mu F_N v_s \\Delta t = \\mu F_N v_s (M \\Delta t) = \\mu F_N v_s T$。这个方法正确地离散化了功率的积分，因此其结果与物理现实一致，并且与步数 $M$ 无关。它之所以是“客观的”，是因为它在每个瞬时状态下正确地计算了耗散，这等同于在有限元中使用协同旋转坐标系。\n\n2.  **非客观累积 ($W_{\\mathrm{no}}$)**：该算法首先在一个固定的坐标系中累加所有的矢量滑移增量 $\\Delta \\boldsymbol{u}_t^{(k)}$，得到一个最终的净位移矢量 $\\boldsymbol{s} = \\sum \\Delta \\boldsymbol{u}_t^{(k)}$。然后，它根据这个净位移的大小计算功：$W_{\\mathrm{no}} = \\mu F_N \\|\\boldsymbol{s}\\|$。对于任何非直线的路径（即 $\\omega \\neq 0$），这种方法在物理上是不正确的。它计算的是基于起点和终点之间直线距离的“功”，而忽略了实际走过的更长路径。根据积分的三角不等式，我们总是有 $\\|\\int \\boldsymbol{v}(t) \\mathrm{d}t\\| \\le \\int \\|\\boldsymbol{v}(t)\\| \\mathrm{d}t$，这意味着 $W_{\\mathrm{no}} \\le W_{\\mathrm{obj}}$。\n\n两种算法的对比凸显了路径依赖的重要性。特别是用例B，当滑移路径完成一个完整的圆周时，净位移矢量 $\\boldsymbol{s}$ 为零，导致 $W_{\\mathrm{no}}=0$。这与物理现实形成鲜明对比，因为在整个过程中实际上耗散了大量的能量（$W_{\\mathrm{obj}} > 0$）。用例D则显示，只有在路径为直线（$\\omega = 0$）的特殊情况下，两种算法的结果才会一致。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares objective vs. non-objective frictional work for a\n    set of test cases involving a spinning slip direction.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General spinning slip\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 2.0, 'T': 1.25},\n        # Case B: Exactly one full revolution\n        # T is calculated dynamically below.\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 2.0, 'T': -1},\n        # Case C: Very slow spin\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 0.001, 'T': 1.0},\n        # Case D: No spin\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 0.0, 'T': 1.0},\n    ]\n\n    # For numerical stability, choose M >= 10^4. We use M = 100,000.\n    M = 100000\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        r = case['r']\n        b = case['b']\n        p = case['p']\n        mu = case['mu']\n        vs = case['vs']\n        omega = case['omega']\n        T = case['T']\n\n        # Special handling for Case B where T depends on omega\n        if T == -1:\n            if omega == 0.0:\n                T = np.inf\n            else:\n                T = 2.0 * np.pi / omega\n        \n        # Calculate total normal force\n        F_N = p * (2.0 * np.pi * r * b)\n        \n        # --- Objective Work Calculation (W_obj) ---\n        # The objective work is the integral of the scalar power, which is\n        # mu * F_N * vs. Since vs is constant, the integral is simply\n        # W_obj = mu * F_N * vs * T.\n        W_obj = mu * F_N * vs * T\n        \n        # --- Non-Objective Work Calculation (W_no) ---\n        # This method accumulates the slip vector in a fixed frame and then\n        # computes the work from the magnitude of the final net vector.\n        dt = T / M\n        slip_vector = np.array([0.0, 0.0])\n        \n        if omega == 0.0:\n            # For the constant direction case, the velocity vector is constant.\n            slip_vector[0] = vs * T\n        else:\n            # Vectorized computation for the sum is faster than a Python loop.\n            k_steps = np.arange(1, M + 1)\n            t_k = k_steps * dt\n            \n            # Compute velocity vectors at each time point\n            cos_vals = np.cos(omega * t_k)\n            sin_vals = np.sin(omega * t_k)\n            \n            # Sum the velocity components\n            sum_vx = np.sum(cos_vals)\n            sum_vy = np.sum(sin_vals)\n\n            # Final slip vector s = sum(v_rel * dt)\n            slip_vector[0] = vs * dt * sum_vx\n            slip_vector[1] = vs * dt * sum_vy\n\n        # Calculate the norm of the total slip vector\n        slip_norm = np.linalg.norm(slip_vector)\n        \n        # Calculate The non-objective work\n        W_no = mu * F_N * slip_norm\n        \n        # Append results, rounded to six decimal places\n        results.append(round(W_obj, 6))\n        results.append(round(W_no, 6))\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2550801"}]}