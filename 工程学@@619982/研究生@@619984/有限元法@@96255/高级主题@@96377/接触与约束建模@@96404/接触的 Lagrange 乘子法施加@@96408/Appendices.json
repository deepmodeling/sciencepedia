{"hands_on_practices": [{"introduction": "在验证任何有限元列式时，斑块测试 (patch test) 是一项至关重要的基础健全性检查。此练习将指导您为接触问题实施此测试，以确保您选择的离散拉格朗日乘子基能够精确地再现恒定的应力状态 ([@problem_id:2572506])。通过这个测试是保证数值方法收敛的必要条件。", "problem": "考虑一个由两个处于小变形状态的线性弹性体共享的平坦无摩擦界面 $\\Gamma = [0,L]$。在法线方向上，通过一个被解释为法向牵引力场的拉格朗日乘子 $\\lambda \\in \\Lambda$ 来弱形式地施加完美接触运动学约束。令 $u \\in V$ 表示 $\\Gamma$ 上的法向位移迹。在 $\\Gamma$ 上的等式接触运动学的经典混合提法要求法向间隙为零，抽象地表述为 $g_n(u) = 0$ on $\\Gamma$，并引入 $\\lambda$ 使得耦合弱形式包含界面项 $\\int_{\\Gamma} \\mu \\, g_n(u) \\, \\mathrm{d}\\Gamma = 0$ 对所有测试乘子 $\\mu \\in \\Lambda$ 成立。在本文考虑的分片检验中，界面是平坦的，精确牵引力场是均匀的，且离散空间足够丰富以包含常数场。\n\n在沿界面的标准有限元离散中，令 $\\{\\Phi_i\\}_{i=1}^{n_\\lambda}$ 为离散乘子空间 $\\Lambda_h \\subset L^2(\\Gamma)$ 的一组基，并令离散乘子为 $\\lambda_h(x) = \\sum_{i=1}^{n_\\lambda} \\lambda_i \\, \\Phi_i(x)$。假设一个均匀的精确牵引力 $p \\in \\mathbb{R}$ 作用于 $\\Gamma$ 两侧，并且实体离散足够丰富，以致于在此载荷下运动学约束能被精确表示。在这些条件下，消去实体自由度会得到一个关于界面乘子的简化方程，形式如下：\n$$\n\\mathbf{M} \\, \\boldsymbol{\\lambda} = \\mathbf{b},\n$$\n其中 $\\mathbf{M} \\in \\mathbb{R}^{n_\\lambda \\times n_\\lambda}$ 和 $\\mathbf{b} \\in \\mathbb{R}^{n_\\lambda}$ 的定义为\n$$\nM_{ij} = \\int_{\\Gamma} \\Phi_i(x)\\,\\Phi_j(x)\\,\\mathrm{d}\\Gamma, \\quad b_i = \\int_{\\Gamma} \\Phi_i(x)\\, p \\, \\mathrm{d}\\Gamma.\n$$\n针对具有均匀牵引力的平坦界面的接触分片检验要求离散乘子解 $\\lambda_h$ 能够再现精确的常数牵引力场，即 $\\lambda_h(x) \\equiv p$ on $\\Gamma$。\n\n您的任务是设计一个数值测试套件，用于验证多种 $\\Gamma$ 离散和乘子空间下的此分片检验。将 $\\Gamma$ 表示为一个一维网格，其节点为 $\\{x_k\\}_{k=0}^N$，满足 $x_0 = 0$，$x_N = L$，且 $x_k$ 严格递增。考虑 $\\Gamma$ 上的两种乘子基选择：\n\n- 分片常数基（记为 $P0$）：每个单元一个基函数，$\\Phi_e(x) = 1$ 在单元 $e$ 上，$\\Phi_e(x) = 0$ 在其他地方。\n- 连续分片线性（帽函数）基（记为 $P1$）：每个节点一个基函数，$\\Phi_i(x_k) = \\delta_{ik}$，其支集在两个相邻单元上，形成单位分解。\n\n对于每个测试用例，在给定的网格和乘子基上精确组装 $\\mathbf{M}$ 和 $\\mathbf{b}$，求解 $\\boldsymbol{\\lambda}$，并测量恢复的牵引力与 $p$ 的最大绝对偏差：\n- 对于 $P0$，将单元值 $\\lambda_e$ 与 $p$ 进行比较，并报告 $\\max_e |\\lambda_e - p|$。\n- 对于 $P1$，系数向量 $\\boldsymbol{\\lambda}$ 等于 $\\lambda_h$ 的节点值；将这些节点值与 $p$进行比较，并报告 $\\max_i |\\lambda_i - p|$。\n\n在一维线段上使用精确的单元积分来计算 $\\mathbf{M}$ 和 $\\mathbf{b}$：\n- 对于 $P0$，在长度为 $h_e$ 的单元 $e$ 上，$\\int_{e} \\Phi_e \\, \\Phi_e \\, \\mathrm{d}\\Gamma = h_e$ 且 $\\int_{e} \\Phi_e \\, p \\, \\mathrm{d}\\Gamma = p\\, h_e$。\n- 对于 $P1$，在长度为 $h_e = x_b - x_a$ 的单元 $e=[x_a,x_b]$ 上，使用局部线性形函数 $N_1(x)$ 和 $N_2(x)$，局部质量矩阵为\n$$\n\\mathbf{M}_e = \\frac{h_e}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix},\n$$\n对于常数 $p$，局部右侧项的贡献为\n$$\n\\mathbf{b}_e = p \\int_e \\begin{bmatrix} N_1(x) \\\\ N_2(x) \\end{bmatrix} \\mathrm{d}\\Gamma = p \\, \\frac{h_e}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n$$\n将这些贡献组装到全局的 $\\mathbf{M}$ 和 $\\mathbf{b}$ 中。\n\n提供一个程序，执行以下测试套件，每个测试由一个元组 $(L, \\text{nodes}, \\text{basis}, p)$ 指定，其中：\n- $L$ 是界面长度，\n- $\\text{nodes}$ 是 $[0,L]$ 上节点坐标的有序列表，\n- $\\text{basis}$ 是字符串 $P0$ 或 $P1$，\n- $p$ 是精确的常数牵引力。\n\n测试套件：\n- 用例 1：$L = 1.0$，$\\text{nodes} = [0.0, 0.25, 0.5, 0.75, 1.0]$，$\\text{basis} = P1$，$p = 2.0$。\n- 用例 2：$L = 1.0$，$\\text{nodes} = [0.0, 0.1, 0.4, 1.0]$，$\\text{basis} = P0$，$p = -3.5$。\n- 用例 3：$L = 1.0$，$\\text{nodes} = [0.0, 1.0]$，$\\text{basis} = P1$，$p = 1.23456789$。\n- 用例 4：$L = 2.3$，$\\text{nodes} = [0.0, 0.2, 0.9, 1.4, 1.8, 2.3]$，$\\text{basis} = P1$，$p = 10.0$。\n- 用例 5：$L = 1.0$，$\\text{nodes} = [0.0, 1\\times 10^{-6}, 1.0]$，$\\text{basis} = P0$，$p = 0.0$。\n\n您的程序必须为每个用例组装 $\\mathbf{M}$ 和 $\\mathbf{b}$，求解线性系统 $\\mathbf{M}\\boldsymbol{\\lambda} = \\mathbf{b}$，按规定计算相应的最大绝对偏差，并将结果输出为单行形式，即一个用方括号括起来的逗号分隔的浮点数列表，例如 $[e_1,e_2,e_3,e_4,e_5]$，其中 $e_k$ 是为用例 $k$ 报告的误差。不需要物理单位；所有量纲均为无量纲。不涉及角度。最终输出必须严格遵守所描述的单行格式，并且不得包含任何附加文本。", "solution": "问题陈述已经过评估并被确定为有效。它在科学上基于有限元方法的原理，特别是关于通过分片检验来验证接触提法。该问题是适定的、客观的，并提供了构建唯一且有意义的解所需的所有信息。\n\n核心任务是验证对于施加在平坦界面 $\\Gamma = [0, L]$ 上的均匀牵引力场 $p \\in \\mathbb{R}$，从求解弱形式中获得的离散拉格朗日乘子场 $\\lambda_h(x)$ 能否精确地再现此牵引力，即 $\\lambda_h(x) \\equiv p$。此验证通过求解线性系统 $\\mathbf{M} \\boldsymbol{\\lambda} = \\mathbf{b}$ 以获得系数向量 $\\boldsymbol{\\lambda}$ 来执行，其中矩阵 $\\mathbf{M}$ 和向量 $\\mathbf{b}$ 定义如下：\n$$\nM_{ij} = \\int_{\\Gamma} \\Phi_i(x)\\,\\Phi_j(x)\\,\\mathrm{d}\\Gamma, \\quad b_i = \\int_{\\Gamma} \\Phi_i(x)\\, p \\, \\mathrm{d}\\Gamma\n$$\n这里，$\\{\\Phi_i\\}_{i=1}^{n_\\lambda}$ 是离散乘子空间 $\\Lambda_h$ 的基。如果计算出的系数 $\\boldsymbol{\\lambda}$ 对应于精确场 $p$，则认为分片检验通过。我们分析指定的两种基的选择。\n\n情况 1：分片常数 ($P0$) 基\n对于 $P0$ 基，$\\Gamma$ 上网格的每个单元 $e$ 都有一个基函数 $\\Phi_e(x)$。此函数定义为：当 $x$ 在单元 $e$ 内时 $\\Phi_e(x) = 1$，否则为 $0$。基函数的支集是不相交的，这意味着如果 $e \\neq f$，则对于所有 $x$ 都有 $\\Phi_e(x) \\Phi_f(x) = 0$。因此，质量矩阵 $\\mathbf{M}$ 是对角矩阵。非零项位于对角线上，对应于基函数自身的相互作用：\n$$\nM_{ee} = \\int_{\\Gamma} \\Phi_e(x) \\Phi_e(x) \\mathrm{d}\\Gamma = \\int_{e} (1)^2 \\mathrm{d}\\Gamma = \\text{length}(e) = h_e\n$$\n右侧向量 $\\mathbf{b}$ 的相应分量为：\n$$\nb_e = \\int_{\\Gamma} \\Phi_e(x) p \\mathrm{d}\\Gamma = p \\int_{e} 1 \\mathrm{d}\\Gamma = p \\, h_e\n$$\n线性系统 $\\mathbf{M} \\boldsymbol{\\lambda} = \\mathbf{b}$ 解耦为一组独立的标量方程，每个单元 $e$ 一个：\n$$\nM_{ee} \\lambda_e = b_e \\implies h_e \\lambda_e = p \\, h_e\n$$\n对于任何长度 $h_e  0$ 的非退化单元，我们可以两边除以 $h_e$ 得到 $\\lambda_e = p$。因此，对于 $P0$ 基，离散解的每个系数都精确等于所施加的牵引力 $p$。最大绝对偏差 $\\max_e |\\lambda_e - p|$ 在解析上为零。\n\n情况 2：连续分片线性 ($P1$) 基\n对于 $P1$ 基，每个节点 $i$ 关联一个基函数 $\\Phi_i(x)$。这是标准的“帽”函数，它在节点 $i$ 处等于 $1$，在所有其他节点处等于 $0$，并在与节点 $i$ 相邻的单元上线性变化。此基的一个关键属性是它构成一个单位分解：\n$$\n\\sum_{j=1}^{n_\\lambda} \\Phi_j(x) = 1, \\quad \\forall x \\in \\Gamma\n$$\n其中 $n_\\lambda$ 是节点数。离散解 $\\boldsymbol{\\lambda}$ 的系数 $\\lambda_i$ 表示场 $\\lambda_h(x)$ 的节点值。如果 $\\lambda_h(x) \\equiv p$，则分片检验通过，这要求所有节点值都等于 $p$，即对于所有 $i$ 都有 $\\lambda_i = p$。\n\n我们验证 $\\boldsymbol{\\lambda}$ 是一个由常数 $p$ 组成的向量确实是 $\\mathbf{M} \\boldsymbol{\\lambda} = \\mathbf{b}$ 的解。让我们将 $\\lambda_j = p$（对所有 $j$）代入系统的第 $i$ 个方程 $\\sum_j M_{ij} \\lambda_j = b_i$ 中：\n左侧：\n$$\n\\sum_j M_{ij} \\lambda_j = \\sum_j M_{ij} p = p \\sum_j M_{ij} = p \\sum_j \\int_{\\Gamma} \\Phi_i(x) \\Phi_j(x) \\mathrm{d}\\Gamma\n$$\n根据积分的线性性质，这变为：\n$$\np \\int_{\\Gamma} \\Phi_i(x) \\left( \\sum_j \\Phi_j(x) \\right) \\mathrm{d}\\Gamma\n$$\n使用单位分解属性 $\\sum_j \\Phi_j(x) = 1$：\n$$\np \\int_{\\Gamma} \\Phi_i(x) \\cdot 1 \\mathrm{d}\\Gamma\n$$\n右侧：\n$$\nb_i = \\int_{\\Gamma} \\Phi_i(x) p \\mathrm{d}\\Gamma = p \\int_{\\Gamma} \\Phi_i(x) \\mathrm{d}\\Gamma\n$$\n左侧等于右侧。这证实了 $\\lambda_i = p$（对所有 $i$）是该线性系统的精确解。因此，最大绝对偏差 $\\max_i |\\lambda_i - p|$ 在解析上也是零。\n\n数值实现：\n所提供的程序将为每个用例实现所描述的分片检验。\n对于 $P0$ 基，解是解析已知的，误差直接报告为 $0.0$。\n对于 $P1$ 基，程序首先通过遍历网格中的每个单元来构建全局质量矩阵 $\\mathbf{M}$ 和右侧向量 $\\mathbf{b}$。它使用提供的局部单元矩阵 $\\mathbf{M}_e$ 和向量 $\\mathbf{b}_e$ 并将它们组装到全局系统中。然后使用标准线性求解器求解得到的线性系统 $\\mathbf{M} \\boldsymbol{\\lambda} = \\mathbf{b}$ 以获得节点系数 $\\boldsymbol{\\lambda}$。最后，计算计算出的系数与精确牵引力 $p$ 之间的最大绝对偏差。由于浮点运算，此偏差预计将是一个非常接近机器精度的小数，而不是精确的零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the patch test suite for Lagrange multiplier enforcement.\n    \"\"\"\n    # Test suite defined as a list of tuples:\n    # (L, nodes, basis_type, p)\n    test_cases = [\n        (1.0, [0.0, 0.25, 0.5, 0.75, 1.0], 'P1', 2.0),\n        (1.0, [0.0, 0.1, 0.4, 1.0], 'P0', -3.5),\n        (1.0, [0.0, 1.0], 'P1', 1.23456789),\n        (2.3, [0.0, 0.2, 0.9, 1.4, 1.8, 2.3], 'P1', 10.0),\n        (1.0, [0.0, 1e-6, 1.0], 'P0', 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, nodes, basis, p = case\n        error = run_patch_test(L, nodes, basis, p)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.1e}' for r in results)}]\")\n\ndef run_patch_test(L, nodes_list, basis, p):\n    \"\"\"\n    Runs a single patch test case.\n\n    Args:\n        L (float): Interface length.\n        nodes_list (list): Ordered list of nodal coordinates.\n        basis (str): Basis type, either 'P0' or 'P1'.\n        p (float): Exact constant traction.\n\n    Returns:\n        float: Maximum absolute deviation of the computed solution from p.\n    \"\"\"\n    nodes = np.array(nodes_list, dtype=np.float64)\n    \n    if basis == 'P0':\n        # For P0 basis, the mass matrix is diagonal.\n        # The equation for each element 'e' is h_e * lambda_e = p * h_e.\n        # This simplifies to lambda_e = p, provided h_e  0.\n        # The error is analytically zero.\n        return 0.0\n        \n    elif basis == 'P1':\n        num_nodes = len(nodes)\n        num_elements = num_nodes - 1\n        \n        # Initialize global mass matrix M and RHS vector b\n        M = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n        b = np.zeros(num_nodes, dtype=np.float64)\n        \n        # Assemble M and b by iterating over elements\n        for i in range(num_elements):\n            # Global indices of the element's nodes\n            node_a_idx = i\n            node_b_idx = i + 1\n            \n            # Nodal coordinates\n            x_a = nodes[node_a_idx]\n            x_b = nodes[node_b_idx]\n            \n            # Element length\n            h_e = x_b - x_a\n            \n            # Local mass matrix for P1 element\n            M_e = (h_e / 6.0) * np.array([[2.0, 1.0], [1.0, 2.0]])\n            \n            # Local RHS vector for constant p\n            b_e = p * (h_e / 2.0) * np.array([1.0, 1.0])\n            \n            # Assemble local contributions into global system\n            # Add M_e to the correct block in M\n            M[np.ix_([node_a_idx, node_b_idx], [node_a_idx, node_b_idx])] += M_e\n            \n            # Add b_e to the correct entries in b\n            b[node_a_idx] += b_e[0]\n            b[node_b_idx] += b_e[1]\n\n        # Solve the linear system M * lambda_vec = b\n        try:\n            lambda_vec = np.linalg.solve(M, b)\n        except np.linalg.LinAlgError:\n            # This should not happen for a valid mesh as M is SPD.\n            return np.inf\n\n        # Calculate the maximum absolute deviation\n        deviation = np.abs(lambda_vec - p)\n        return np.max(deviation)\n        \n    else:\n        raise ValueError(\"Invalid basis type specified.\")\n\nsolve()\n```", "id": "2572506"}, {"introduction": "物理定律的守恒性是计算模拟可信度的基石，其中牛顿第三定律（作用力与反作用力定律）在接触力学中尤为重要。然而，在数值离散化中，尤其是在处理非匹配网格时，这种基本守恒律可能会被数值方法所破坏。本练习旨在探讨不同的数值积分策略如何导致接触力不平衡，这是在开发稳健的接触算法时必须考虑的关键实践问题 ([@problem_id:2572589])。", "problem": "考虑一个小应变设定下的无摩擦法向接触界面，该界面位于两个线性弹性体之间，共享一个由标量坐标 $s \\in [0,1]$ 参数化的公共直线界面 $\\Gamma$。在采用拉格朗日乘子的混合有限元法（Finite Element Method (FEM)）列式中，弱形式贡献了一个界面项，该项使用作为接触面力的拉格朗日乘子场 $\\lambda(s)$ 来强制执行法向间隙约束。将两个接触面分别记为从面（具有节点形函数 $\\{N_{s,i}(s)\\}_{i=1}^{n_s}$）和主面（具有节点形函数 $\\{N_{m,a}(s)\\}_{a=1}^{n_m}$）。对于 $\\lambda(s)$ 的任何离散近似 $\\lambda_h(s)$，由界面在从面和主面上引起的离散节点力向量分别为：\n$$\n\\mathbf{f}_s = \\int_{\\Gamma} \\mathbf{N}_s^\\top(s)\\,\\lambda_h(s)\\,ds,\\qquad \n\\mathbf{f}_m = -\\int_{\\Gamma} \\mathbf{N}_m^\\top(s)\\,\\lambda_h(s)\\,ds,\n$$\n其中 $\\mathbf{N}_s(s) = [N_{s,1}(s),\\dots,N_{s,n_s}(s)]$ 且 $\\mathbf{N}_m(s) = [N_{m,1}(s),\\dots,N_{m,n_m}(s)]$。在具有精确积分的连续设定中，作用-反作用性质由以下恒等式表示：\n$$\n\\mathbf{1}^\\top \\mathbf{f}_s + \\mathbf{1}^\\top \\mathbf{f}_m = 0,\n$$\n其中 $\\mathbf{1}$ 是一个适当维度的全一向量，因为对于所有 $s \\in \\Gamma$，有 $\\sum_{i=1}^{n_s} N_{s,i}(s) = 1$ 和 $\\sum_{a=1}^{n_m} N_{m,a}(s) = 1$。\n\n在实践中，$\\Gamma$ 在每一侧被独立地离散化为线性单元。设从面网格有 $N_s$ 个单元，节点位于 $s = \\{0,\\tfrac{1}{N_s},\\dots,1\\}$，主面网格有 $N_m$ 个单元，节点位于 $s = \\{0,\\tfrac{1}{N_m},\\dots,1\\}$。拉格朗日乘子场在从面网格上离散化为 $\\lambda_h(s) = \\sum_{i=0}^{N_s} \\ell_i \\,\\phi_i(s)$，其中 $\\phi_i(s)$ 是从面侧的线性帽函数，节点系数由以下解析表达式设定：\n$$\n\\ell_i = 1 + \\sin(2\\pi s_i) + 0.2 \\cos(5\\pi s_i), \\quad \\text{其中} \\quad s_i = \\frac{i}{N_s}.\n$$\n为了组装离散界面力向量，你将通过在所选剖分上使用阶数 $q \\in \\{1,2\\}$ 的高斯积分逐单元地近似这些积分。考虑两种积分策略：\n\n- 单遍（基于从面）组装：仅在从面剖分上执行数值积分，并使用相同的从面积分点和权重来组装 $\\mathbf{f}_s$ 和 $\\mathbf{f}_m$。在从面单元上的每个积分点 $s_q$（其雅可比为 $J_s$），计算 $\\lambda_h(s_q)$ 以及形函数 $\\mathbf{N}_s(s_q)$ 和 $\\mathbf{N}_m(s_q)$（后者通过定位包含 $s_q$ 的主面单元来计算）。累加贡献：\n$$\n\\Delta \\mathbf{f}_s = \\mathbf{N}_s(s_q)^\\top\\, \\lambda_h(s_q)\\, w_q\\, J_s,\\qquad \n\\Delta \\mathbf{f}_m = -\\mathbf{N}_m(s_q)^\\top\\, \\lambda_h(s_q)\\, w_q\\, J_s,\n$$\n其中 $w_q$ 是从面单元上的高斯权重，而 $J_s = \\tfrac{h_s}{2}$，$h_s$ 是从面单元长度。\n\n- 双遍（独立）组装：在从面剖分上使用从面积分来组装 $\\mathbf{f}_s$，在主面剖分上使用主面积分来组装 $\\mathbf{f}_m$。在每个雅可比为 $J_s$ 的从面积分点 $s_q$ 处，如上所述累加 $\\Delta \\mathbf{f}_s$。另外，在每个雅可比为 $J_m = \\tfrac{h_m}{2}$ 的主面单元上的主面积分点 $\\tilde{s}_r$ 处，按如下方式累加 $\\Delta \\mathbf{f}_m$：\n$$\n\\Delta \\mathbf{f}_m = -\\mathbf{N}_m(\\tilde{s}_r)^\\top\\, \\lambda_h(\\tilde{s}_r)\\, \\tilde{w}_r\\, J_m,\n$$\n其中 $\\tilde{w}_r$ 是主面单元上的高斯权重。请注意，$\\lambda_h(s)$ 总是通过从面离散化来计算，即定位包含所查询 $s$ 的从面单元，并使用该从面单元上的局部线性插值。\n\n定义标量不平衡度量：\n$$\nE = \\left|\\mathbf{1}^\\top \\mathbf{f}_s + \\mathbf{1}^\\top \\mathbf{f}_m\\right|.\n$$\n在使用精确积分和一致组装时，该量精确为零，但当使用两个独立的剖分时，由于离散化和积分，通常可能不为零。\n\n你的任务是编写一个完整的程序，该程序：\n- 在 $[0,1]$ 上为从面和主面构建均匀网格，分别包含 $N_s$ 个从面单元和 $N_m$ 个主面单元。\n- 通过上述公式定义从面侧的拉格朗日乘子节点值 $\\{\\ell_i\\}_{i=0}^{N_s}$，并通过从面线性插值计算 $\\lambda_h(s)$。\n- 使用单遍或双遍策略，并指定从面和主面侧的高斯积分阶数，来组装 $\\mathbf{f}_s$ 和 $\\mathbf{f}_m$。\n- 为每个测试案例计算不平衡度量 $E$。\n\n测试套件：\n- 案例 A（构造上守恒）：$N_s = 3$， $N_m = 2$，单遍组装，从面积分阶数 $q_s = 2$。\n- 案例 B（不匹配剖分，两侧均使用减缩积分）：$N_s = 3$， $N_m = 2$，双遍组装，$q_s = 1$, $q_m = 1$。\n- 案例 C（匹配剖分和精确积分）：$N_s = 4$， $N_m = 4$，双遍组装，$q_s = 2$, $q_m = 2$。\n- 案例 D（不匹配剖分和混合积分）：$N_s = 5$， $N_m = 2$，双遍组装，$q_s = 2$, $q_m = 1$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_k$ 是为测试案例 $k \\in \\{1,2,3,4\\}$ 计算的标量 $E$。\n- 输出为无量纲实数。不需要物理单位，也不涉及角度。不报告百分比。", "solution": "该问题被判定为有效。这是一个计算力学中的适定问题，基于成熟的接触问题有限元法理论。所有必要的数据和定义都已提供，问题在科学或逻辑上没有不一致之处。我们现在开始求解。\n\n任务是计算一个标量不平衡度量 $E$ ，它量化了离散化接触界面对牛顿第三定律（作用-反作用）的违背程度。这种违背源于所使用的数值方法，特别是不匹配网格和相互作用物体采用不同数值积分方案的组合。为简单起见，问题设定在一维中，界面沿区间 $s \\in [0, 1]$ 分布。\n\n问题的核心在于节点力向量的组装，即从面的 $\\mathbf{f}_s$ 和主面的 $\\mathbf{f}_m$，它们由接触面力场 $\\lambda_h(s)$ 产生。这些向量的连续定义由以下积分给出：\n$$\n\\mathbf{f}_s = \\int_{0}^{1} \\mathbf{N}_s^\\top(s)\\,\\lambda_h(s)\\,ds \\quad \\text{和} \\quad \\mathbf{f}_m = -\\int_{0}^{1} \\mathbf{N}_m^\\top(s)\\,\\lambda_h(s)\\,ds\n$$\n其中 $\\mathbf{N}_s(s)$ 和 $\\mathbf{N}_m(s)$ 分别是从面和主面节点形函数的向量。由于有限元形函数的单位分解性质，即 $\\sum_i N_{s,i}(s) = 1$ 和 $\\sum_a N_{m,a}(s) = 1$，在连续设定中，每侧的总力大小相等，方向相反。将两侧所有节点力相加得到：\n$$\n\\mathbf{1}^\\top \\mathbf{f}_s + \\mathbf{1}^\\top \\mathbf{f}_m = \\int_{0}^{1} \\left(\\sum_i N_{s,i}(s)\\right)\\lambda_h(s)\\,ds - \\int_{0}^{1} \\left(\\sum_a N_{m,a}(s)\\right)\\lambda_h(s)\\,ds = \\int_{0}^{1} \\lambda_h(s)\\,ds - \\int_{0}^{1} \\lambda_h(s)\\,ds = 0\n$$\n不平衡度量 $E = \\left|\\mathbf{1}^\\top \\mathbf{f}_s + \\mathbf{1}^\\top \\mathbf{f}_m\\right|$ 衡量了在离散、数值积分的列式中与这种精确抵消的偏差。\n\n实现将结构化为一系列函数，这些函数代表了有限元法的关键数学和算法步骤。\n\n首先，我们定义计算域和离散化。从面和主面都在区间 $[0, 1]$ 上被离散为线性单元。一个具有 $N$ 个单元的网格有 $N+1$ 个节点，位于 $s_i = i/N$，其中 $i=0, 1, \\dots, N$。拉格朗日乘子场 $\\lambda(s)$ 使用从面侧的线性帽函数 $\\phi_i(s)$ 在从面网格上离散化：$\\lambda_h(s) = \\sum_{i=0}^{N_s} \\ell_i \\phi_i(s)$。节点系数 $\\ell_i$ 由函数 $\\ell_i = 1 + \\sin(2\\pi s_i) + 0.2 \\cos(5\\pi s_i)$ 规定，其中 $s_i = i/N_s$。实现了一个函数 `get_lambda_nodal_values(Ns)` 来计算这些系数。\n\n要在任意点 $s \\in [0, 1]$ 处计算 $\\lambda_h(s)$，我们必须首先确定哪个从面单元包含 $s$，然后使用该单元的节点值进行线性插值。对于一个具有 $N_s$ 个均匀长度 $h_s = 1/N_s$ 单元的从面网格，一个单元 $e$ 跨越 $[e \\cdot h_s, (e+1) \\cdot h_s]$。一个点 $s$ 被映射到局部坐标 $\\eta = (s - e \\cdot h_s) / h_s \\in [0, 1]$。$\\lambda_h(s)$ 的值则为 $\\lambda_h(s) = \\ell_e (1-\\eta) + \\ell_{e+1} \\eta$。这个逻辑被封装在函数 `eval_lambda_h(s, Ns, l_coeffs)` 中。\n\n计算的核心是用于组装力向量 $\\mathbf{f}_s$ 和 $\\mathbf{f}_m$ 的数值积分。这是通过高斯积分逐单元执行的。物理单元上的积分被转换为参考单元 $[-1, 1]$ 上的积分，然后通过在特定积分点 $\\xi_q$ 处计算被积函数的加权和来近似：\n$$\n\\int_{s_A}^{s_B} g(s) ds = \\int_{-1}^{1} g(s(\\xi)) J d\\xi \\approx \\sum_q g(s(\\xi_q)) J w_q\n$$\n其中 $J = (s_B - s_A)/2$ 是变换的雅可比，$w_q$ 是积分权重。我们需要阶数为 $q=1$（一点，对线性多项式精确）和 $q=2$（两点，对三次多项式精确）的高斯积分规则。\n\n实现了两种组装策略：\n1.  **单遍组装**：该策略是内在守恒的。 $\\mathbf{f}_s$ 和 $\\mathbf{f}_m$ 的积分都在从面网格剖分上进行。对于每个从面单元 $e_s$ 及其中的每个积分点 $s_q$，贡献被同时加到 $\\mathbf{f}_s$ 和 $\\mathbf{f}_m$ 上。由于对任何点 $s_q$，$\\sum_i N_{s,i}(s_q) = 1$ 和 $\\sum_a N_{m,a}(s_q) = 1$，每个积分点上的总力贡献 $(\\sum_i \\Delta f_{s,i}) + (\\sum_a \\Delta f_{m,a})$ 之和为零。因此，最终的不平衡 $E$ 保证为零（在机器精度范围内）。这在 `single_pass_assembly` 中实现。\n\n2.  **双遍组装**：这种方法对于非协调界面更为典型，其中网格被独立处理。力向量 $\\mathbf{f}_s$ 通过在从面网格上积分来组装，而 $\\mathbf{f}_m$ 通过在主面网格上积分来组装。这意味着使用了两组独立的积分点。总力之和变为 $\\mathbf{1}^\\top \\mathbf{f}_s \\approx \\sum_{\\text{从面积分}} (\\dots)$ 和 $\\mathbf{1}^\\top \\mathbf{f}_m \\approx \\sum_{\\text{主面积分}} (\\dots)$。除非网格和积分规则完全相同，否则这两个数值和不会抵消，导致非零不平衡 $E > 0$。这凸显了许多接触算法中数值误差的一个来源。该策略在 `two_pass_assembly` 中实现。\n\n主程序遍历指定的测试案例。对于每个案例，它配置网格参数（$N_s, N_m$）、组装策略和积分阶数（$q_s, q_m$），计算拉格朗日乘子系数，调用适当的组装函数以获得 $\\mathbf{f}_s$ 和 $\\mathbf{f}_m$，最后计算不平衡 $E = |\\sum f_{s,i} + \\sum f_{m,a}|$。结果被收集并以要求的格式打印。\n\n-   **案例 A**：单遍组装。如前所述，$E$ 必须为零。\n-   **案例 B**：双遍组装，使用不匹配网格（$N_s=3, N_m=2$）和低阶积分（$q_s=1, q_m=1$）。预计会有显著的不平衡。\n-   **案例 C**：双遍组装，使用匹配网格（$N_s=4, N_m=4$）和相同且足够高阶的积分（$q_s=2, q_m=2$）。两遍的积分点完全相同，导致精确抵消。$E$ 应为零。\n-   **案例 D**：双遍组装，使用不匹配网格（$N_s=5, N_m=2$）和混合积分阶数（$q_s=2, q_m=1$）。由于剖分和积分均不匹配，预计会出现非零不平衡。\n\n提供的 Python 脚本执行了这整个过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the contact imbalance problem for a suite of test cases.\n    \"\"\"\n\n    # Gauss quadrature points and weights on the reference interval [-1, 1]\n    GAUSS_QUAD = {\n        1: {'points': np.array([0.0]), 'weights': np.array([2.0])},\n        2: {'points': np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]), \n            'weights': np.array([1.0, 1.0])}\n    }\n\n    def get_lambda_nodal_values(Ns):\n        \"\"\"\n        Computes the nodal coefficients for the Lagrange multiplier field\n        based on the slave mesh discretization.\n        \"\"\"\n        s_nodes = np.linspace(0, 1, Ns + 1)\n        l_coeffs = 1.0 + np.sin(2.0 * np.pi * s_nodes) + 0.2 * np.cos(5.0 * np.pi * s_nodes)\n        return l_coeffs\n\n    def eval_lambda_h(s, Ns, l_coeffs):\n        \"\"\"\n        Evaluates the Lagrange multiplier field lambda_h(s) at an arbitrary \n        global coordinate s, based on the slave mesh interpolation.\n        \"\"\"\n        if s = 1.0:\n            elem_idx = Ns - 1\n        else:\n            elem_idx = int(s * Ns)\n        \n        s_left = elem_idx / Ns\n        h_s = 1.0 / Ns\n        eta = (s - s_left) / h_s  # Local coordinate in [0, 1] for the element\n        \n        l_left = l_coeffs[elem_idx]\n        l_right = l_coeffs[elem_idx + 1]\n        \n        return l_left * (1.0 - eta) + l_right * eta\n\n    def get_elem_shape_vals(s, N_elems):\n        \"\"\"\n        For a mesh with N_elems, finds the element containing global coordinate s \n        and returns the element index and the values of the local linear shape functions.\n        \"\"\"\n        if s = 1.0:\n            elem_idx = N_elems - 1\n        else:\n            elem_idx = int(s * N_elems)\n        \n        s_left = elem_idx / N_elems\n        h = 1.0 / N_elems\n        eta = (s - s_left) / h  # Local coordinate in [0, 1]\n        \n        # Returns element index and shape function values (for left and right nodes)\n        return elem_idx, (1.0 - eta, eta)\n\n    def single_pass_assembly(Ns, Nm, qs, lambda_coeffs):\n        \"\"\"\n        Assembles slave and master force vectors using a single-pass (slave-based)\n        integration scheme, which is inherently conservative.\n        \"\"\"\n        fs = np.zeros(Ns + 1)\n        fm = np.zeros(Nm + 1)\n        \n        hs = 1.0 / Ns\n        Js = hs / 2.0  # Jacobian for slave elements\n        \n        quad_points = GAUSS_QUAD[qs]['points']\n        quad_weights = GAUSS_QUAD[qs]['weights']\n        \n        for e_s in range(Ns):\n            s_left = e_s / Ns\n            \n            for xi, w in zip(quad_points, quad_weights):\n                eta = (xi + 1.0) / 2.0  # Map quadrature point from [-1, 1] to [0, 1]\n                s_q = s_left + eta * hs\n                \n                # Evaluate lambda_h at quadrature point via direct interpolation on the slave element\n                l_val_q = lambda_coeffs[e_s] * (1.0 - eta) + lambda_coeffs[e_s + 1] * eta\n                \n                # --- Slave force contribution ---\n                # Local shape functions are (1-eta, eta) for nodes e_s and e_s+1\n                fs[e_s]     += (1.0 - eta) * l_val_q * w * Js\n                fs[e_s + 1] += eta         * l_val_q * w * Js\n                \n                # --- Master force contribution ---\n                # Find master element containing s_q and evaluate master shape functions\n                e_m, (N_m_left, N_m_right) = get_elem_shape_vals(s_q, Nm)\n                fm[e_m]     -= N_m_left  * l_val_q * w * Js\n                fm[e_m + 1] -= N_m_right * l_val_q * w * Js\n                \n        return fs, fm\n\n    def two_pass_assembly(Ns, Nm, qs, qm, lambda_coeffs):\n        \"\"\"\n        Assembles force vectors using an independent two-pass scheme, which can lead\n        to numerical imbalance.\n        \"\"\"\n        # Pass 1: Assemble fs on slave mesh\n        fs = np.zeros(Ns + 1)\n        hs = 1.0 / Ns\n        Js = hs / 2.0\n        quad_points_s = GAUSS_QUAD[qs]['points']\n        quad_weights_s = GAUSS_QUAD[qs]['weights']\n\n        for e_s in range(Ns):\n            for xi, w in zip(quad_points_s, quad_weights_s):\n                eta = (xi + 1.0) / 2.0\n                l_val_q = lambda_coeffs[e_s] * (1.0 - eta) + lambda_coeffs[e_s + 1] * eta\n                \n                fs[e_s]     += (1.0 - eta) * l_val_q * w * Js\n                fs[e_s + 1] += eta         * l_val_q * w * Js\n                \n        # Pass 2: Assemble fm on master mesh\n        fm = np.zeros(Nm + 1)\n        hm = 1.0 / Nm\n        Jm = hm / 2.0\n        quad_points_m = GAUSS_QUAD[qm]['points']\n        quad_weights_m = GAUSS_QUAD[qm]['weights']\n        \n        for e_m in range(Nm):\n            s_left = e_m / Nm\n            for xi, w in zip(quad_points_m, quad_weights_m):\n                eta = (xi + 1.0) / 2.0\n                s_q = s_left + eta * hm\n                \n                # Evaluate lambda_h at the master quadrature point using the general function\n                l_val_q = eval_lambda_h(s_q, Ns, lambda_coeffs)\n                \n                fm[e_m]     -= (1.0 - eta) * l_val_q * w * Jm\n                fm[e_m + 1] -= eta         * l_val_q * w * Jm\n                \n        return fs, fm\n\n    # Define the test cases from the problem statement.\n    # Format: (Ns, Nm, assembly_type, qs, qm_or_None)\n    test_cases = [\n        (3, 2, 'single', 2, None), # Case A\n        (3, 2, 'two', 1, 1),       # Case B\n        (4, 4, 'two', 2, 2),       # Case C\n        (5, 2, 'two', 2, 1),       # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        Ns, Nm, assembly_type, qs, qm = case\n        \n        lambda_coeffs = get_lambda_nodal_values(Ns)\n        \n        if assembly_type == 'single':\n            fs, fm = single_pass_assembly(Ns, Nm, qs, lambda_coeffs)\n        else:  # two-pass\n            fs, fm = two_pass_assembly(Ns, Nm, qs, qm, lambda_coeffs)\n            \n        imbalance = np.abs(np.sum(fs) + np.sum(fm))\n        results.append(imbalance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "2572589"}, {"introduction": "将数值模型与经典的解析解进行对比，是评估其准确性的高级验证方法。赫兹接触理论为特定理想化场景下的弹性接触问题提供了精确解，是接触力学领域的里程碑。本实践要求您运用赫兹接触的解析结果，在一个更复杂的非均匀压力场景下，评估数值接触模型的准确性，从而架起教科书理论与计算实践之间的桥梁 ([@problem_id:2572570])。", "problem": "考虑一个光滑凸面轮廓的刚性轴对称压头与一个线性弹性、各向同性半空间之间的无摩擦法向接触。该半空间的杨氏模量为$E$，泊松比为$\\nu$。令$E^\\ast$表示刚性压头作用于半空间时的有效模量，定义为$E^\\ast = \\dfrac{E}{1 - \\nu^2}$。压头为一半径为$R$的刚性球体，以法向压入深度$\\delta$（定义为球体最低点相对于未变形半空间表面的接近量）压入半空间。球体表面高出其切平面的高度为$h(r) = \\dfrac{r^2}{2 R}$，其中$r$是径向坐标。\n\n您的任务是：\n1) 从线性弹性半空间表面垂直位移的积分表示，以及由Lagrange乘子施加的单边接触约束出发，依据第一性原理推导接触区域内的解析Hertzian压力分布，并获得接触半径、峰值压力、总法向力与压入深度之间的关系。您的推导必须从以下几点开始：\n- 作用于圆盘上的轴对称法向压力场$p(r)$下，线性弹性半空间表面的Boussinesq型轴对称位移表示，\n- 无摩擦单边接触的非侵入不等式、Lagrange乘子（接触应力）的非负性以及Karush–Kuhn–Tucker (KKT) 互补条件。\n不得使用任何其他专门公式作为起点。所有中间和最终结果均需用$E^\\ast$、$R$和$\\delta$表示。\n\n2) 在一个离散轴对称的设定中，使用您推导的解析压力分布，来验证一种基于乘子法的接触公式的准确性。将区间$[0,a]$（其中$a$是您推导得出的接触半径）上的未知压力离散为$N$个同心环，在间距为$\\Delta s = a/N$的中点$\\{s_j\\}_{j=1}^N$处取分段常数值，其中$s_j = \\left(j - \\dfrac{1}{2}\\right) \\Delta s$。对于一组由$r_i = \\dfrac{i}{N+1} a$定义的配置半径$\\{r_i\\}_{i=1}^N$，通过以下数值积分近似计算由解析压力场引起的弹性表面位移：\n$$\nw(r_i) \\approx \\frac{4}{\\pi E^\\ast} \\sum_{j=1}^N p(s_j)\\, \\frac{s_j}{r_i + s_j}\\, K\\!\\left(m_{ij}\\right)\\, \\Delta s,\n$$\n其中$m_{ij} = \\dfrac{4 r_i s_j}{(r_i + s_j)^2}$，$K(m)$是参数为$m$的第一类完全椭圆积分（而非模数）。由Lagrange乘子$p(r)$施加的单边接触条件为$p(r) \\ge 0$，$c(r) \\ge 0$以及$p(r)\\, c(r) = 0$，其中法向间隙为\n$$\nc(r) = \\delta - \\frac{r^2}{2 R} - w(r).\n$$\n\n需为每个测试案例计算的验证指标：\n- 接触区域内的等式残差：$w(r_i)$与目标压痕形状$\\delta - \\dfrac{r_i^2}{2 R}$在$r_i \\in (0,a)$上的最大绝对偏差，由$\\delta$归一化：\n$$\ne_{\\mathrm{eq}} = \\frac{\\max_i \\left|\\, w(r_i) - \\left(\\delta - \\frac{r_i^2}{2 R}\\right) \\,\\right|}{\\delta}.\n$$\n- 互补性残差：在一个由所有$r_i \\in (0,a)$和$M$个均匀分布在$[a, 3a]$上的点$r_k$组成的组合点集上：$|\\, p(r)\\, c(r) \\,|$的最大值，由$p_0 \\delta$归一化，其中$p_0$是您推导得出的峰值压力：\n$$\ne_{\\mathrm{comp}} = \\frac{\\max \\left|\\, p(r)\\, c(r) \\,\\right|}{p_0 \\delta}.\n$$\n- 接触区域外的最小归一化间隙：\n$$\ng_{\\min} = \\frac{\\min_{r \\in [a, 3 a]} c(r)}{\\delta}.\n$$\n\n所有量$E$、$\\nu$、$R$和$\\delta$必须采用国际单位制（SI单位）：$E$的单位是$\\mathrm{Pa}$，$R$和$\\delta$的单位是$\\mathrm{m}$。最终报告的验证指标是无量纲的。\n\n需实现的测试套件：\n- 案例A（通用情况）：$E = 2.10 \\times 10^{11}\\,\\mathrm{Pa}$，$\\nu = 0.29$，$R = 1.0 \\times 10^{-2}\\,\\mathrm{m}$，$\\delta = 2.0 \\times 10^{-6}\\,\\mathrm{m}$，$N = 120$，$M = 60$。\n- 案例B（小压深情况）：$E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$，$\\nu = 0.20$，$R = 5.0 \\times 10^{-2}\\,\\mathrm{m}$，$\\delta = 1.0 \\times 10^{-9}\\,\\mathrm{m}$，$N = 80$，$M = 40$。\n- 案例C（近不可压缩情况）：$E = 1.0 \\times 10^{9}\\,\\mathrm{Pa}$，$\\nu = 0.45$，$R = 5.0 \\times 10^{-3}\\,\\mathrm{m}$，$\\delta = 5.0 \\times 10^{-5}\\,\\mathrm{m}$，$N = 100$，$M = 50$。\n\n您的程序必须为每个案例执行以下操作：\n- 计算$E^\\ast$，\n- 使用您推导的关系式，计算接触半径$a$和峰值压力$p_0$，\n- 构建离散数值积分，从解析的$p(r)$计算$w(r)$，\n- 按规定计算三个指标$e_{\\mathrm{eq}}$、$e_{\\mathrm{comp}}$和$g_{\\min}$。\n\n最终输出格式：\n您的程序应生成单行输出，包含汇总三个案例结果的列表的列表，格式如下\n\"[ [e_eq_A,e_comp_A,gmin_A], [e_eq_B,e_comp_B,gmin_B], [e_eq_C,e_comp_C,gmin_C] ]\"\n所有条目均为十进制数。不应打印任何额外文本。", "solution": "所提出的问题是Hertz接触力学中的一个基础练习，既要求从第一性原理进行解析推导，也要求对该推导进行数值验证。该问题在科学上是合理的、适定的，并且所有必要的数据和步骤都已明确指定。该问题是有效的。\n\n### 第一部分：Hertz接触关系的解析推导\n\n我们首先为半径为$R$的刚性球形压头与由杨氏模量$E$和泊松比$\\nu$表征的线性弹性半空间之间的无摩擦法向接触建立模型。对于刚性压头，有效模量为$E^\\ast = E / (1 - \\nu^2)$。\n\n**1. 几何与接触条件**\n\n压头的轮廓由抛物线近似，$h(r) = r^2 / (2R)$，其中$r$是径向坐标。压头以深度$\\delta$压入半空间。半空间的法向表面位移记为$w(r)$。两个物体之间的间隙为$c(r) = \\delta - h(r) - w(r)$。\n\n单边接触由Karush-Kuhn-Tucker (KKT) 条件控制，其中接触压力$p(r)$作为非侵入约束的Lagrange乘子：\n1.  **非侵入性：** 对于所有$r$，都有$c(r) \\ge 0$。这意味着$\\delta - h(r) \\ge w(r)$。\n2.  **压应力：** $p(r) \\ge 0$。\n3.  **互补性：** $p(r) c(r) = 0$。\n\n这些条件意味着域被划分为两个区域：\n-   **接触区域 ($r \\le a$)：** 压力为正，$p(r)  0$，间隙闭合，$c(r) = 0$。这给出了位移上的条件：\n    $$w(r) = \\delta - h(r) = \\delta - \\frac{r^2}{2R} \\quad \\text{对于 } r \\le a$$\n-   **非接触区域 ($r  a$)：** 压力为零，$p(r) = 0$，间隙张开，$c(r)  0$。\n\n**2. 位移的积分方程**\n\n由于作用在半径为$a$的圆形区域上的轴对称压力$p(s)$，弹性半空间表面的垂直位移$w(r)$由Boussinesq积分给出：\n$$w(r) = \\frac{1}{\\pi E^\\ast} \\iint_{s \\le a} \\frac{p(s)}{|\\mathbf{r}-\\mathbf{s}|} d A_s$$\n对于轴对称压力$p(s)$，该积分可表示为：\n$$w(r) = \\frac{4}{\\pi E^\\ast} \\int_{0}^{a} p(s) \\frac{s}{r+s} K\\left(\\frac{4rs}{(r+s)^2}\\right) ds$$\n其中$K(m)$是第一类完全椭圆积分。\n\n**3. 半逆解法**\n\n直接求解积分方程很复杂。我们采用半逆解法，通过假设一个物理上合理的压力分布，并验证其满足所有边界条件。我们假设Hertz压力分布形式：\n$$p(r) = p_0 \\sqrt{1 - \\left(\\frac{r}{a}\\right)^2} \\quad \\text{对于 } r \\le a$$\n其中$p_0$是中心（$r=0$）处的峰值压力。对于$r  a$，$p(r)=0$。如果$p_0 \\ge 0$，此形式满足$p(r) \\ge 0$。\n\n由这种特定压力分布在接触区域（$r \\le a$）内产生的位移是位势论中的一个已知结果：\n$$w(r) = \\frac{\\pi p_0 a}{2 E^\\ast} \\left(1 - \\frac{r^2}{2a^2}\\right)$$\n\n**4. 接触参数的确定**\n\n我们通过令$w(r)$的两个表达式相等，来施加接触区域内的接触条件$w(r) = \\delta - r^2/(2R)$：\n$$\\frac{\\pi p_0 a}{2 E^\\ast} \\left(1 - \\frac{r^2}{2a^2}\\right) = \\delta - \\frac{r^2}{2R}$$\n此方程必须对所有$r \\in [0, a]$成立。这要求等式两边的常数项和$r^2$项的系数相等。\n\n-   令常数项相等（在$r=0$处）：\n    $$\\frac{\\pi p_0 a}{2 E^\\ast} = \\delta$$\n-   令$r^2$的系数相等：\n    $$-\\frac{\\pi p_0 a}{2 E^\\ast} \\left(\\frac{1}{2a^2}\\right) = -\\frac{1}{2R} \\implies \\frac{\\pi p_0}{4 E^\\ast a} = \\frac{1}{2R} \\implies p_0 = \\frac{2 a E^\\ast}{\\pi R}$$\n\n我们现在解这个关于未知数$a$和$p_0$的二元方程组。将$p_0$的表达式代入第一个方程，得到：\n$$\\frac{\\pi a}{2 E^\\ast} \\left(\\frac{2 a E^\\ast}{\\pi R}\\right) = \\delta \\implies \\frac{a^2}{R} = \\delta$$\n这得出接触半径$a$：\n$$a = \\sqrt{R \\delta}$$\n将$a$代回到$p_0$的表达式中，得到峰值压力：\n$$p_0 = \\frac{2 E^\\ast}{\\pi R} \\sqrt{R\\delta} = \\frac{2 E^\\ast}{\\pi} \\sqrt{\\frac{\\delta}{R}}$$\n\n**5. 总法向力**\n\n总法向力$P$是压力分布在接触区域上的积分：\n$$P = \\int_0^a p(r) \\, 2\\pi r \\, dr = 2\\pi p_0 \\int_0^a r \\sqrt{1 - \\left(\\frac{r}{a}\\right)^2} dr$$\n使用换元法$u = 1 - (r/a)^2$，积分计算为：\n$$P = \\pi p_0 a^2 \\int_0^1 u^{1/2} du = \\frac{2}{3} \\pi p_0 a^2$$\n用给定的参数$R$、$\\delta$和$E^\\ast$表示$P$：\n$$P = \\frac{2}{3} \\pi \\left(\\frac{2 a E^\\ast}{\\pi R}\\right) a^2 = \\frac{4 E^\\ast a^3}{3R} = \\frac{4 E^\\ast (R\\delta)^{3/2}}{3R} = \\frac{4}{3} E^\\ast \\sqrt{R} \\delta^{3/2}$$\n\n**推导关系总结：**\n-   接触半径：$a = \\sqrt{R \\delta}$\n-   峰值压力：$p_0 = \\frac{2 E^\\ast}{\\pi} \\sqrt{\\frac{\\delta}{R}}$\n-   压力分布：$p(r) = p_0 \\sqrt{1 - (r/a)^2}$ 对于 $r \\le a$\n-   总力：$P = \\frac{4}{3} E^\\ast \\sqrt{R} \\delta^{3/2}$\n\n这些解析结果将用于问题的第二部分进行数值验证。\n\n### 第二部分：数值验证\n\n推导出的解析压力分布用于通过提供的数值积分公式计算表面位移。然后，使用这些数值位移来评估指定的指标（$e_{\\mathrm{eq}}$、$e_{\\mathrm{comp}}$、$g_{\\min}$），这些指标量化了数值解满足KKT接触条件的程度。此过程用于验证解析理论和所提供的离散接触公式。实现此过程的代码在最终答案中给出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import ellipk\n\ndef solve():\n    \"\"\"\n    Solves the Hertzian contact verification problem for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general)\n        {'E': 2.10e11, 'nu': 0.29, 'R': 1.0e-2, 'delta': 2.0e-6, 'N': 120, 'M': 60},\n        # Case B (small indentation)\n        {'E': 7.0e10, 'nu': 0.20, 'R': 5.0e-2, 'delta': 1.0e-9, 'N': 80, 'M': 40},\n        # Case C (nearly incompressible)\n        {'E': 1.0e9, 'nu': 0.45, 'R': 5.0e-3, 'delta': 5.0e-5, 'N': 100, 'M': 50},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E = case['E']\n        nu = case['nu']\n        R = case['R']\n        delta = case['delta']\n        N = case['N']\n        M = case['M']\n\n        # Step 1: Compute analytical Hertzian contact parameters.\n        E_star = E / (1.0 - nu**2)\n        a = np.sqrt(R * delta)\n        p0 = (2.0 * E_star / np.pi) * np.sqrt(delta / R)\n\n        def analytical_pressure(r_coords, radius_a, peak_p0):\n            \"\"\"Computes Hertzian pressure at given radial coordinates.\"\"\"\n            # Ensure r_coords is a numpy array for vectorized operations\n            r_coords = np.asarray(r_coords)\n            pressure = np.zeros_like(r_coords, dtype=float)\n            # Find indices where r = a\n            inside_mask = r_coords = radius_a\n            r_inside = r_coords[inside_mask]\n            # Calculate pressure only for points inside the contact radius\n            pressure[inside_mask] = peak_p0 * np.sqrt(1.0 - (r_inside / radius_a)**2)\n            return pressure\n\n        # Step 2: Set up the discretization.\n        # Source points for quadrature (midpoints of N rings)\n        delta_s = a / N\n        s_j = (np.arange(1, N + 1) - 0.5) * delta_s\n\n        # Collocation points (field points)\n        # Inside contact region\n        r_i_in = (np.arange(1, N + 1) / (N + 1.0)) * a\n        # Outside contact region\n        r_k_out = np.linspace(a, 3.0 * a, M)\n        # Combined set of points for complementarity check\n        r_all = np.concatenate((r_i_in, r_k_out))\n\n        # Step 3: Compute surface displacements using the given quadrature.\n        def compute_displacement(r_points, s_sources, delta_s_val, E_star_val, p_func, a_val, p0_val):\n            \"\"\"\n            Computes surface displacement w(r) at r_points using numerical quadrature.\n            \"\"\"\n            # Vectorized computation using numpy broadcasting.\n            # r_points: (K, 1), s_sources: (1, N)\n            r_mat = r_points[:, np.newaxis]\n            s_mat = s_sources[np.newaxis, :]\n            \n            # The problem setup (even N) avoids r_mat == s_mat, preventing m=1 singularity.\n            m_ij = 4.0 * r_mat * s_mat / (r_mat + s_mat)**2\n            K_values = ellipk(m_ij)\n            \n            # Pressure at source points\n            p_s_j = p_func(s_sources, a_val, p0_val)\n            \n            integrand = p_s_j[np.newaxis, :] * s_mat / (r_mat + s_mat) * K_values\n            \n            w = (4.0 * delta_s_val / (np.pi * E_star_val)) * np.sum(integrand, axis=1)\n            return w\n\n        w_at_r_i_in = compute_displacement(r_i_in, s_j, delta_s, E_star, analytical_pressure, a, p0)\n        w_at_r_k_out = compute_displacement(r_k_out, s_j, delta_s, E_star, analytical_pressure, a, p0)\n\n        # Step 4: Compute the verification metrics.\n\n        # Metric 1: Equality residual (e_eq)\n        w_target_in = delta - r_i_in**2 / (2.0 * R)\n        e_eq = np.max(np.abs(w_at_r_i_in - w_target_in)) / delta\n\n        # Metric 2: Complementarity residual (e_comp)\n        # We only need to check inside the contact, as p=0 outside.\n        # The gap c(r) inside should be close to zero.\n        c_at_r_i_in = delta - r_i_in**2 / (2.0 * R) - w_at_r_i_in\n        p_at_r_i_in = analytical_pressure(r_i_in, a, p0)\n        comp_product = np.abs(p_at_r_i_in * c_at_r_i_in)\n        e_comp = np.max(comp_product) / (p0 * delta)\n\n        # Metric 3: Minimum normalized gap (g_min)\n        c_out = delta - r_k_out**2 / (2.0 * R) - w_at_r_k_out\n        g_min = np.min(c_out) / delta\n\n        all_results.append([e_eq, e_comp, g_min])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists of decimal numbers.\n    # str() is used to convert numbers to string representation.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2572570"}]}