{"hands_on_practices": [{"introduction": "第一项实践是奠定基础，旨在阐明扩展有限元法（XFEM）如何构建其独特的近似空间。通过根据节点与裂纹的相对位置手动识别富集节点，并计算由此产生的额外自由度，您将对单位分解富集概念有一个具体的理解 [@problem_id:2557355]。这个练习是从 XFEM 理论走向实际应用的第一步，是掌握其核心机制的关键。", "problem": "考虑在矩形域 $\\Omega = [0,3] \\times [0,2]$ 上的二维平面应变线性弹性问题，该问题使用双线性四边形有限元进行离散。网格包含 $3 \\times 2$ 个单元，节点位于整数格点上。从左下角开始按行对节点进行编号，使得节点坐标 $(x,y)$ 如下所示：\n节点 $1:(0,0)$，节点 $2:(1,0)$，节点 $3:(2,0)$，节点 $4:(3,0)$，\n节点 $5:(0,1)$，节点 $6:(1,1)$，节点 $7:(2,1)$，节点 $8:(3,1)$，\n节点 $9:(0,2)$，节点 $10:(1,2)$，节点 $11:(2,2)$，节点 $12:(3,2)$。\n设六个单元具有以下节点连接关系（逆时针）：`e1`=[1,2,6,5], `e2`=[2,3,7,6], `e3`=[3,4,8,7], `e4`=[5,6,10,9], `e5`=[6,7,11,10], `e6`=[7,8,12,11]。\n\n一条厚度为零的直裂纹 $\\Gamma_c$ 嵌入在域中。该裂纹使用扩展有限元法 (XFEM) 进行建模，利用 Heaviside 增强来表示裂纹面上的位移跳跃，并利用尖端附近的渐近分支增强来捕捉裂纹尖端附近的奇异场。裂纹定义为从 $\\mathbf{x}_A=(0.2,0.9)$ 到尖端 $\\mathbf{x}_T=(2.4,0.9)$ 的线段（坐标单位与网格相同），且不穿过任何节点，也不与任何单元边重合。\n\n假设遵循以下增强选择规则：\n\n(1) Heaviside 增强：如果一个节点至少有一个与之相连的单元被 $\\Gamma_c$ 的内部所贯穿，并且该节点不属于尖端附近增强集，则该节点被 Heaviside 增强。\n\n(2) 尖端附近增强：设 $e_t$ 是包含裂纹尖端 $\\mathbf{x}_T$ 的唯一单元。尖端附近增强集由属于 $e_t$ 以及所有与 $e_t$ 共享边的单元的并集中的所有节点组成。\n\n假设标准位移近似中每个节点有 $2$ 个平移自由度。在 XFEM 增强中：\n- 每个被 Heaviside 增强的节点带有一个与标量 Heaviside 函数相关的向量值增强系数（即每个被 Heaviside 增强的节点增加 $2$ 个自由度）。\n- 每个被尖端附近增强的节点带有四个与标准的二维尖端附近分支函数相关的向量值增强系数（即每个被尖端附近增强的节点增加 $8$ 个自由度）。\n\n从这些定义和有限元法中节点支承的标准概念出发，确定对于此网格和裂纹构型，增强相对于标准有限元模型所引入的额外自由度的总数。根据所述规则，说明哪些节点被 Heaviside 增强，哪些节点被尖端附近增强。最终答案以无单位的整数形式表示。", "solution": "我们从有限元的基本概念开始：一个双线性四边形单元将每个节点与一个标量形函数相关联，该形函数的支承是包含该节点的所有单元的并集。在二维线性弹性中，位移场有两个分量，因此每个节点拥有 $2$ 个标准自由度。在扩展有限元法 (XFEM) 中，由标准形函数提供的单位分解会乘以增强函数，以表示位移跳跃和裂纹尖端奇点等特征。节点上的每个标量增强函数会引入一个向量值增强系数，带来 $2$ 个额外的自由度。\n\n我们应用所提供的增强选择规则：\n\n步骤1：确定被 $\\Gamma_c$ 内部贯穿的单元以及包含裂纹尖端的单元。\n\n裂纹 $\\Gamma_c$ 是从 $\\mathbf{x}_A=(0.2,0.9)$ 到 $\\mathbf{x}_T=(2.4,0.9)$ 的线段，即一条在 $y=0.9$ 处从 $x=0.2$ 到 $x=2.4$ 的水平线。各单元的范围是：\n- $e_1=[1,2,6,5]$ 跨越 $x \\in [0,1]$, $y \\in [0,1]$,\n- $e_2=[2,3,7,6]$ 跨越 $x \\in [1,2]$, $y \\in [0,1]$,\n- $e_3=[3,4,8,7]$ 跨越 $x \\in [2,3]$, $y \\in [0,1]$,\n- $e_4=[5,6,10,9]$ 跨越 $x \\in [0,1]$, $y \\in [1,2]$,\n- $e_5=[6,7,11,10]$ 跨越 $x \\in [1,2]$, $y \\in [1,2]$,\n- $e_6=[7,8,12,11]$ 跨越 $x \\in [2,3]$, $y \\in [1,2]$。\n\n由于 $y=0.9 \\in (0,1)$，裂纹位于底行单元（$e_1$, $e_2$, $e_3$）内。裂纹的 $x$ 区间是 $[0.2,2.4]$，它贯穿了：\n- $e_1$（对于 $x \\in [0.2,1]$，内部贯穿），\n- $e_2$（对于 $x \\in [1,2]$，内部贯穿），\n- $e_3$（对于 $x \\in [2,2.4]$，内部贯穿直至尖端）。\n\n裂纹尖端点 $\\mathbf{x}_T=(2.4,0.9)$ 满足 $2<2.4<3$ 和 $0<0.9<1$，因此尖端单元是 $e_t=e_3$。\n\n步骤2：根据规则(2)构建尖端附近增强节点集。\n\n根据规则(2)，尖端附近增强集由 $e_t$ 的节点以及所有与 $e_t$ 共享边的单元的节点组成。与 $e_3$ 边相邻的单元是：\n- 左侧相邻单元 $e_2$（共享沿 $x=2$ 的竖直边），\n- 顶部相邻单元 $e_6$（共享沿 $y=1$ 的水平边），\n且没有右侧相邻单元（域边界在 $x=3$）和底部相邻单元（域边界在 $y=0$）。\n\n因此，尖端附近片区是单元 $\\{e_2,e_3,e_6\\}$ 的并集，其节点集为：\n- $e_2$ 的节点为 $\\{2,3,7,6\\}$，\n- $e_3$ 的节点为 $\\{3,4,8,7\\}$，\n- $e_6$ 的节点为 $\\{7,8,12,11\\}$。\n\n取其并集，得到尖端附近增强节点集为\n$\\mathcal{N}_{\\text{tip}}=\\{2,3,4,6,7,8,11,12\\}$。\n\n根据所述的近似方法，每个被尖端附近增强的节点引入 $4$ 个标量分支函数，每个函数带一个 $2$ 分量的向量系数，即每个节点增加 $8$ 个自由度。\n\n步骤3：根据规则(1)构建 Heaviside 增强节点集。\n\n首先列出被 $\\Gamma_c$ 内部贯穿的单元：它们是 $e_1$、$e_2$ 和 $e_3$。规则(1)要求节点不属于尖端增强集，且其支承被裂纹*内部*贯穿。一个更标准的定义是，如果节点的支承被裂纹切割，则该节点被增强。\n- 支承被裂纹切割的节点集是 $e_1, e_2, e_3$ 中所有节点的并集：$\\{1,2,3,4,5,6,7,8\\}$。\n- 从这个集合中，我们移除属于尖端附近增强集 $\\mathcal{N}_{\\text{tip}}$ 的节点。\n$\\mathcal{N}_{\\text{tip}} = \\{2,3,4,6,7,8,11,12\\}$\n- 两个集合的交集是 $\\{2,3,4,6,7,8\\}$。\n- 剩余的被 Heaviside 增强的节点是 $\\{1,5\\}$。\n\n每个被 Heaviside 增强的节点引入一个标量 Heaviside 函数，带一个 $2$ 分量的向量系数，即每个节点增加 $2$ 个自由度。\n\n步骤4：计算增加的自由度。\n\n- Heaviside 贡献：$|\\mathcal{N}_{H}| \\times 2 = 2 \\times 2 = 4$ 个额外自由度。\n- 尖端附近贡献：$|\\mathcal{N}_{\\text{tip}}| \\times 8 = 8 \\times 8 = 64$ 个额外自由度。\n\n增强相对于标准有限元模型所引入的额外自由度总数为\n$4 + 64 = 68$。\n\n步骤5：选择的理由说明。\n\nHeaviside 增强被赋予其节点支承被裂纹段内部贯穿的节点，以确保单位分解可以在远离尖端的被裂纹切割的单元中表示裂纹面上的位移跳跃。从 Heaviside 增强中排除尖端附近片区中的节点，可以避免在相同节点上出现重叠的不连续增强和奇异增强，这种情况可能导致病态和线性相关。\n\n尖端附近增强被赋予尖端单元及其边相邻单元，以使用四个标准的二维分支函数来捕捉裂纹尖端附近应力场和位移场的平方根奇点和角度变化。将尖端增强扩展到边相邻单元的一环，为表示渐近场提供了足够的支承，同时保持了一个紧凑的增强区域。这种增强集的划分与扩展有限元法的单位分解框架一致，并利用了裂纹尖端奇异场的局部性，同时独立处理远离尖端的位移跳跃。\n\n因此，额外自由度的总数为 $68$。", "answer": "$$\\boxed{68}$$", "id": "2557355"}, {"introduction": "在定义了富集近似之后，一个新的挑战随之而来：如何对被裂纹“切割”的单元进行函数积分。本实践旨在解决这一关键的实施细节，因为标准的高斯求积方法在这种情况下会失效 [@problem_id:2557298]。您将通过将一个包含裂纹的单元分解为多个子域来进行数值积分，这项技术对于在 XFEM 程序中精确组装刚度矩阵至关重要。", "problem": "在扩展有限元方法 (XFEM) 中，通过将被不连续面隔开的父单元分解为多个子域，然后在每个子域上应用基于面积的精确求积，来对被切割的单元进行积分。考虑一个三角形有限元，其顶点为 $A=(0,0)$、$B=(3,0)$ 和 $C=(0,2)$。一条直裂纹沿竖直线 $x=1$ 与该单元相交，从边 $\\overline{AB}$ 上的点 $D=(1,0)$ 延伸到边 $\\overline{BC}$ 上的点 $E=\\left(1,\\frac{4}{3}\\right)$。该裂纹将单元分割成两个多边形子域：$x<1$ 的左子域和 $x\\ge 1$ 的右子域。\n\n定义分段线性被积函数 $g:\\mathbb{R}^{2}\\to\\mathbb{R}$ 如下：\n- 在左子域 $\\{(x,y) : x<1\\}$ 上，$g(x,y)=1+x+y$\n- 在右子域 $\\{(x,y) : x\\ge 1\\}$ 上，$g(x,y)=2-x+3y$\n\n使用适用于 XFEM 子单元积分的精确面积分解方法：\n- 将由裂纹产生的两个多边形剖分为多个不重叠的三角形，这些三角形的顶点取自集合 $\\{A,B,C,D,E\\}$，且它们的并集等于原始单元，\n- 对每个三角形，在其形心处构造一个求积点，其权等于该三角形的面积，并且\n- 使用这些求积点和权来计算积分\n$$\nI \\;=\\; \\iint_{T} g(x,y)\\,\\mathrm{d}A,\n$$\n其中 $T=\\mathrm{conv}\\{A,B,C\\}$ 是原始三角形。\n\n将 $I$ 的最终值表示为单个精确有理数（不进行四舍五入）。最终答案中不要包含单位。如果你需要在裂纹本身（即 $x=1$ 处）上取值，请证明你的选择不影响积分结果。", "solution": "在三角形 $T$ 上的积分 $I$ 可以分解为在 $x=1$ 处的裂纹所产生的两个子域上的积分之和。设 $T_{\\text{left}}$ 为 $T$ 中 $x<1$ 的部分， $T_{\\text{right}}$ 为 $T$ 中 $x>1$ 的部分。线段在 $\\mathbb{R}^2$ 中是零测集，因此在直线 $x=1$ 本身上的积分为零。因此，在裂纹线上使用 $x\\ge 1$ 的定义不会影响积分的最终值。\n$$\nI = \\iint_{T} g(x,y)\\,\\mathrm{d}A = \\iint_{T_{\\text{left}}} (1+x+y)\\,\\mathrm{d}A + \\iint_{T_{\\text{right}}} (2-x+3y)\\,\\mathrm{d}A\n$$\n子域 $T_{\\text{left}}$ 是顶点为 $A(0,0)$、$D(1,0)$、$E\\left(1, \\frac{4}{3}\\right)$ 和 $C(0,2)$ 的四边形。子域 $T_{\\text{right}}$ 是顶点为 $D(1,0)$、$B(3,0)$ 和 $E\\left(1, \\frac{4}{3}\\right)$ 的三角形。\n\n按照题目的指示，我们将四边形 $T_{\\text{left}}$ 剖分为两个三角形。我们选择对角线 $\\overline{AE}$，它将 $T_{\\text{left}}$ 分解为 $\\triangle ADE$ 和 $\\triangle ACE$。因此，原始三角形 $T$ 被分解为三个子三角形：\n1.  $T_1 = \\triangle ADE$\n2.  $T_2 = \\triangle ACE$\n3.  $T_3 = \\triangle DBE$ (这与 $T_{\\text{right}}$ 相同)\n\n指定的数值积分方案通过将子三角形的面积乘以被积函数在其形心处的值来计算积分。对于三角形 $\\Delta$ 上的线性被积函数 $f(x,y)$，此方法是精确的：$\\iint_{\\Delta} f(x,y)\\,\\mathrm{d}A = \\text{Area}(\\Delta) \\cdot f(x_c, y_c)$，其中 $(x_c, y_c)$ 是 $\\Delta$ 的形心。由于我们的被积函数 $g(x,y)$ 是分段线性的，并且每个子三角形都完全位于 $g$ 是线性的一个区域内，因此该过程将得出积分的精确值。\n\n我们现在计算每个子三角形的贡献。\n\n**1. 子三角形 $T_1 = \\triangle ADE$**\n-   顶点：$A(0,0)$、$D(1,0)$、$E\\left(1, \\frac{4}{3}\\right)$。\n-   该三角形位于 $x<1$ 的区域（除了边 $\\overline{DE}$）。我们使用 $g(x,y) = 1+x+y$。\n-   面积：$A_1 = \\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2} \\times 1 \\times \\frac{4}{3} = \\frac{2}{3}$。\n-   形心：$C_1 = \\left(\\frac{0+1+1}{3}, \\frac{0+0+\\frac{4}{3}}{3}\\right) = \\left(\\frac{2}{3}, \\frac{4}{9}\\right)$。\n-   形心处的被积函数值：$g(C_1) = 1 + \\frac{2}{3} + \\frac{4}{9} = \\frac{9}{9} + \\frac{6}{9} + \\frac{4}{9} = \\frac{19}{9}$。\n-   积分贡献：$I_1 = A_1 \\cdot g(C_1) = \\frac{2}{3} \\cdot \\frac{19}{9} = \\frac{38}{27}$。\n\n**2. 子三角形 $T_2 = \\triangle ACE$**\n-   顶点：$A(0,0)$、$C(0,2)$、$E\\left(1, \\frac{4}{3}\\right)$。\n-   该三角形位于 $x<1$ 的区域（除了顶点 $E$）。我们使用 $g(x,y) = 1+x+y$。\n-   面积（使用鞋带公式）：$A_2 = \\frac{1}{2} |(0 \\cdot 2 + 0 \\cdot \\frac{4}{3} + 1 \\cdot 0) - (0 \\cdot 0 + 2 \\cdot 1 + \\frac{4}{3} \\cdot 0)| = \\frac{1}{2} |0 - 2| = 1$。\n-   形心：$C_2 = \\left(\\frac{0+0+1}{3}, \\frac{0+2+\\frac{4}{3}}{3}\\right) = \\left(\\frac{1}{3}, \\frac{\\frac{10}{3}}{3}\\right) = \\left(\\frac{1}{3}, \\frac{10}{9}\\right)$。\n-   形心处的被积函数值：$g(C_2) = 1 + \\frac{1}{3} + \\frac{10}{9} = \\frac{9}{9} + \\frac{3}{9} + \\frac{10}{9} = \\frac{22}{9}$。\n-   积分贡献：$I_2 = A_2 \\cdot g(C_2) = 1 \\cdot \\frac{22}{9} = \\frac{22}{9}$。\n\n**3. 子三角形 $T_3 = \\triangle DBE$**\n-   顶点：$D(1,0)$、$B(3,0)$、$E\\left(1, \\frac{4}{3}\\right)$。\n-   该三角形位于 $x \\ge 1$ 的区域。我们使用 $g(x,y) = 2-x+3y$。\n-   面积：$A_3 = \\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2} \\times (3-1) \\times \\frac{4}{3} = \\frac{1}{2} \\cdot 2 \\cdot \\frac{4}{3} = \\frac{4}{3}$。\n-   形心：$C_3 = \\left(\\frac{1+3+1}{3}, \\frac{0+0+\\frac{4}{3}}{3}\\right) = \\left(\\frac{5}{3}, \\frac{4}{9}\\right)$。\n-   形心处的被积函数值：$g(C_3) = 2 - \\frac{5}{3} + 3\\left(\\frac{4}{9}\\right) = 2 - \\frac{5}{3} + \\frac{4}{3} = 2 - \\frac{1}{3} = \\frac{5}{3}$。\n-   积分贡献：$I_3 = A_3 \\cdot g(C_3) = \\frac{4}{3} \\cdot \\frac{5}{3} = \\frac{20}{9}$。\n\n**总积分**\n总积分 $I$ 是三个子三角形贡献之和：\n$$\nI = I_1 + I_2 + I_3 = \\frac{38}{27} + \\frac{22}{9} + \\frac{20}{9}\n$$\n为了将这些分数相加，我们找到公分母 $27$。\n$$\nI = \\frac{38}{27} + \\frac{22 \\cdot 3}{27} + \\frac{20 \\cdot 3}{27} = \\frac{38 + 66 + 60}{27}\n$$\n$$\nI = \\frac{104 + 60}{27} = \\frac{164}{27}\n$$\n作为检验，面积之和为 $A_1+A_2+A_3 = \\frac{2}{3} + 1 + \\frac{4}{3} = \\frac{6}{3}+1 = 2+1=3$。顶点为 $(0,0)$、$(3,0)$、$(0,2)$ 的原始三角形 $T$ 的面积是 $\\frac{1}{2} \\times 3 \\times 2 = 3$。面积分解是正确的。最终结果是积分的精确值。", "answer": "$$\n\\boxed{\\frac{164}{27}}\n$$", "id": "2557298"}, {"introduction": "编写像 XFEM 这样复杂的数值代码需要严格的验证以确保其正确性。这最后一项实践将向您介绍“人造解法”（Method of Manufactured Solutions, MMS），这是一种强有力的代码验证技术。通过将您的 XFEM 列式计算出的位移跳跃与一个已知的人造解析解进行比较，您将学会如何系统地验证您的实现是否准确地捕捉了不连续性的物理特性 [@problem_id:2557321]。", "problem": "您的任务是使用制造解（manufactured solution）来验证一个二维直裂纹的扩展有限元方法（XFEM）实施概念。考虑一个二维的单一四节点双线性单元，其内部含有一条由有符号距离水平集表示的直裂纹。您将计算由 XFEM Heaviside 富集产生的裂纹面位移跳跃，并将其与制造解引起的解析跳跃进行比较。您必须在一个完整的、可运行的程序中实现所需的计算。\n\n请从以下基本定义和事实开始：\n\n- 在小应变线性化运动学中，当内部不连续性由水平集表示时，裂纹表面由水平集函数 $\\phi(\\boldsymbol{x})$ 的零等值线给出，其中 $\\phi(\\boldsymbol{x}) = \\boldsymbol{n} \\cdot (\\boldsymbol{x} - \\boldsymbol{x}_0)$，$\\boldsymbol{n}$ 为单位法向量，$\\boldsymbol{x}_0$ 为裂纹线上的一点。裂纹两侧分别表示为 $\\phi(\\boldsymbol{x}) > 0$（正侧）和 $\\phi(\\boldsymbol{x}) < 0$（负侧）。\n- 在用于强位移不连续的、采用 Heaviside 富集函数的扩展有限元方法（XFEM）中，单个单元 $\\Omega_e$ 上的离散位移场为\n$$\n\\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{a}_i \\;+\\; H(\\phi(\\boldsymbol{x})) \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{b}_i,\n$$\n其中 $N_i(\\boldsymbol{x})$ 是标准双线性形函数，$\\boldsymbol{a}_i$ 是标准自由度，$\\boldsymbol{b}_i$ 是与 Heaviside 富集相关的富集自由度，$H(\\cdot)$ 是符号 Heaviside 函数，其中 $H(\\phi) \\in \\{-1,+1\\}$ 且 $H(\\phi) = \\mathrm{sign}(\\phi)$。\n- 裂纹面位移跳跃定义为\n$$\n[\\![\\boldsymbol{u}]\\!](\\boldsymbol{x}) \\equiv \\lim_{\\epsilon \\to 0^+} \\left( \\boldsymbol{u}(\\boldsymbol{x}+\\epsilon \\boldsymbol{n}) - \\boldsymbol{u}(\\boldsymbol{x}-\\epsilon \\boldsymbol{n}) \\right)\n$$\n对于裂纹集 $\\{\\phi(\\boldsymbol{x}) = 0\\}$ 上的点 $\\boldsymbol{x}$。场的连续部分在此极限中抵消，而不连续部分则通过 Heaviside 函数产生贡献。\n\n制造解验证方案：\n\n- 考虑一个形式如下的制造位移\n$$\n\\boldsymbol{u}^{\\star}(\\boldsymbol{x}) = \\boldsymbol{u}_{\\mathrm{cont}}(\\boldsymbol{x}) + H(\\phi(\\boldsymbol{x}))\\,\\boldsymbol{F}(\\boldsymbol{x}),\n$$\n其中 $\\boldsymbol{u}_{\\mathrm{cont}}(\\boldsymbol{x})$ 是单元上的任意连续函数（它不影响跳跃），而 $\\boldsymbol{F}(\\boldsymbol{x})$ 是一个指定的向量值函数。由该制造解引起的解析跳跃为\n$$\n[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}) = 2\\,\\boldsymbol{F}(\\boldsymbol{x}) \\quad \\text{for } \\phi(\\boldsymbol{x})=0.\n$$\n- 通过将单元节点 $\\boldsymbol{x}_i$ 处的富集自由度设置为制造的半跳跃的节点计算值，来模拟 XFEM 表示，\n$$\n\\boldsymbol{b}_i = \\boldsymbol{F}(\\boldsymbol{x}_i), \\quad i \\in \\{1,2,3,4\\}.\n$$\n根据这一选择，从 XFEM 沿单元内部裂纹段恢复的离散跳跃简化为\n$$\n[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}) = 2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x})\\,\\boldsymbol{b}_i \\quad \\text{for } \\phi(\\boldsymbol{x})=0.\n$$\n当 $\\boldsymbol{F}(\\boldsymbol{x})$ 在 $(x,y)$ 上是双线性时，上述表达式在单元内的任何地方都等于精确跳跃。当 $\\boldsymbol{F}(\\boldsymbol{x})$ 不是双线性时，这将产生一个一致的双线性插值误差。\n\n几何设置和形函数：\n\n- 使用单个轴对齐的矩形双线性单元，节点按逆时针顺序排列为 $\\boldsymbol{x}_1=(x_L,y_B)$、$\\boldsymbol{x}_2=(x_R,y_B)$、$\\boldsymbol{x}_3=(x_R,y_T)$、$\\boldsymbol{x}_4=(x_L,y_T)$。设单元中心为 $(x_C,y_C)=\\left(\\frac{x_L+x_R}{2},\\frac{y_B+y_T}{2}\\right)$，宽度为 $w = x_R-x_L$，高度为 $h = y_T-y_B$。对应于物理点 $(x,y)$ 的等参坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 为\n$$\n\\xi = \\frac{2(x-x_C)}{w}, \\qquad \\eta = \\frac{2(y-y_C)}{h}.\n$$\n双线性形函数为\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n\n单元内部的裂纹线段：\n\n- 裂纹是无限直线 $\\{\\boldsymbol{x}:\\phi(\\boldsymbol{x})=0\\}$，其中 $\\phi(\\boldsymbol{x}) = \\boldsymbol{n}\\cdot(\\boldsymbol{x}-\\boldsymbol{x}_0)$，它将单元切割成两个子域。单元内部的裂纹段是该直线与单元边界的交集。在数值上，通过检查每个单元边上 $\\phi$ 的符号变化并沿边缘进行线性插值来定位两个交点。使用一个小的容差去除重合的交点。将该线段参数化为 $\\boldsymbol{x}(s) = \\boldsymbol{x}_A + s(\\boldsymbol{x}_B - \\boldsymbol{x}_A)$，其中 $s \\in [0,1]$，$\\boldsymbol{x}_A$ 和 $\\boldsymbol{x}_B$ 是线段端点，其长度为 $L = \\|\\boldsymbol{x}_B - \\boldsymbol{x}_A\\|_2$。\n\n每个测试用例需要计算的验证指标：\n\n- 沿裂纹的离散跳跃为\n$$\n[\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s)) = 2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x}(s)) \\,\\boldsymbol{b}_i,\n$$\n解析跳跃为 $[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s)) = 2\\,\\boldsymbol{F}(\\boldsymbol{x}(s))$。\n- 使用三点高斯积分计算沿线段的向量跳跃误差的 $L^2$ 范数，\n$$\ne_{\\mathrm{vec}} = \\left( \\int_{0}^{1} \\left\\| [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s)) - [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s)) \\right\\|_2^2 \\, L \\,\\mathrm{d}s \\right)^{1/2},\n$$\n使用在 $[-1,1]$ 上的标准3点高斯法则，其横坐标为 $[-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}]$，权重为 $[5/9,\\,8/9,\\,5/9]$，并映射到 $[0,1]$。\n- 计算量值误差的 $L^2$ 范数，\n$$\ne_{\\mathrm{mag}} = \\left( \\int_{0}^{1} \\left( \\left\\| [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(s)) \\right\\|_2 - \\left\\| [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(s)) \\right\\|_2 \\right)^2 \\, L \\,\\mathrm{d}s \\right)^{1/2}.\n$$\n- 确定在线段中点 $s = 1/2$ 处计算的法向张开的符号，\n$$\n\\mathrm{sign}_h = \\mathrm{sign}\\left( \\boldsymbol{n} \\cdot [\\![\\boldsymbol{u}_h]\\!](\\boldsymbol{x}(1/2)) \\right),\n$$\n并验证其与解析符号是否匹配\n$$\n\\mathrm{sign}_{\\star} = \\mathrm{sign}\\left( \\boldsymbol{n} \\cdot [\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}(1/2)) \\right).\n$$\n记录一个布尔值 $\\mathrm{sign\\_ok}$，表示这些符号是否相等。\n\n测试套件：\n\n对于每个用例，定义矩形单元节点 $\\{\\boldsymbol{x}_i\\}_{i=1}^{4}$、裂纹单位法向量 $\\boldsymbol{n}$、裂纹上的一点 $\\boldsymbol{x}_0$ 以及制造的半跳跃 $\\boldsymbol{F}(\\boldsymbol{x})$。\n\n- 用例 1：\n    - $\\boldsymbol{x}_1=(0,0)$, $\\boldsymbol{x}_2=(1,0)$, $\\boldsymbol{x}_3=(1,1)$, $\\boldsymbol{x}_4=(0,1)$。\n    - $\\boldsymbol{n}=(0,1)$, $\\boldsymbol{x}_0=(0,0.3)$。\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} 0.2 + 0.5 x + 0.1 y - 0.1 x y \\\\ 0.3 + 0.2 x + 0.05 y + 0.0 x y \\end{bmatrix}$。\n- 用例 2：\n    - $\\boldsymbol{x}_1=(0,-1)$, $\\boldsymbol{x}_2=(2,-1)$, $\\boldsymbol{x}_3=(2,1)$, $\\boldsymbol{x}_4=(0,1)$。\n    - $\\boldsymbol{n}=(1,0)$, $\\boldsymbol{x}_0=(0.5,0)$。\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} -0.4 - 0.3 x + 0.2 y + 0.1 x y \\\\ 0.1 - 0.1 x + 0.05 y - 0.02 x y \\end{bmatrix}$。\n- 用例 3：\n    - $\\boldsymbol{x}_1=(-1,-1)$, $\\boldsymbol{x}_2=(2,-1)$, $\\boldsymbol{x}_3=(2,2)$, $\\boldsymbol{x}_4=(-1,2)$。\n    - $\\boldsymbol{n}=\\frac{1}{\\sqrt{2}}(1,1)$, $\\boldsymbol{x}_0=(0,0)$。\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} 0.1 + 0.2 x - 0.05 y + 0.03 x y \\\\ -0.2 + 0.4 x + 0.3 y - 0.06 x y \\end{bmatrix}$。\n- 用例 4（非双线性，以产生非零插值误差）：\n    - $\\boldsymbol{x}_1=(0,0)$, $\\boldsymbol{x}_2=(1,0)$, $\\boldsymbol{x}_3=(1,1)$, $\\boldsymbol{x}_4=(0,1)$。\n    - $\\boldsymbol{n}=\\frac{1}{\\sqrt{2}}(1,-1)$, $\\boldsymbol{x}_0=(0.5,0.5)$。\n    - $\\boldsymbol{F}(\\boldsymbol{x}) = \\begin{bmatrix} 0.1 + x^2 \\\\ 0.2 - y^2 + 0.1 x y \\end{bmatrix}$。\n\n要求的最终输出格式：\n\n- 对于每个用例，计算如上定义的三元组 $(e_{\\mathrm{vec}}, e_{\\mathrm{mag}}, \\mathrm{sign\\_ok})$。将所有结果聚合到一个列表中，按顺序展平为\n$$\n[e_{\\mathrm{vec}}^{(1)}, e_{\\mathrm{mag}}^{(1)}, \\mathrm{sign\\_ok}^{(1)}, e_{\\mathrm{vec}}^{(2)}, e_{\\mathrm{mag}}^{(2)}, \\mathrm{sign\\_ok}^{(2)}, e_{\\mathrm{vec}}^{(3)}, e_{\\mathrm{mag}}^{(3)}, \\mathrm{sign\\_ok}^{(3)}, e_{\\mathrm{vec}}^{(4)}, e_{\\mathrm{mag}}^{(4)}, \\mathrm{sign\\_ok}^{(4)}].\n$$\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12}]$。\n\n角度单位不适用。没有需要报告的物理单位；这是一个纯粹的数学验证。所有计算必须以双精度进行。", "solution": "本练习的目标是实现一个程序，用人造解法（Method of Manufactured Solutions）来验证XFEM中Heaviside增强的实现。该程序将计算裂纹面上的解析位移跳跃与通过单个双线性有限元获得的数值近似之间的差异。此过程将对几个定义的测试用例进行。\n\n程序的核心逻辑遵循以下步骤：\n\n1.  **定义XFEM近似**：\n    对于一个被裂纹穿过的单元，XFEM位移近似由标准部分和增强部分组成：\n    $$\n    \\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{a}_i \\;+\\; H(\\phi(\\boldsymbol{x})) \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\,\\boldsymbol{b}_i\n    $$\n    其中 $\\boldsymbol{b}_i$ 是捕捉位移不连续性的富集自由度。裂纹面上的位移跳跃 $[\\![\\boldsymbol{u}_h]\\!]$ 可以推导为 $2 \\sum_{i=1}^{4} N_i(\\boldsymbol{x})\\,\\boldsymbol{b}_i$。\n\n2.  **应用人造解**：\n    人造解的形式为 $\\boldsymbol{u}^{\\star}(\\boldsymbol{x}) = \\boldsymbol{u}_{\\mathrm{cont}}(\\boldsymbol{x}) + H(\\phi(\\boldsymbol{x}))\\,\\boldsymbol{F}(\\boldsymbol{x})$，其解析跳跃为 $[\\![\\boldsymbol{u}^{\\star}]\\!](\\boldsymbol{x}) = 2\\boldsymbol{F}(\\boldsymbol{x})$。为了使离散解和解析解具有可比性，我们将富集自由度 $\\boldsymbol{b}_i$ 设为在节点处采样的函数 $\\boldsymbol{F}(\\boldsymbol{x})$，即 $\\boldsymbol{b}_i = \\boldsymbol{F}(\\boldsymbol{x}_i)$。这样，XFEM的跳跃近似就变成了对解析跳跃的节点值的插值。如果 $\\boldsymbol{F}(\\boldsymbol{x})$ 是双线性的，插值误差应为零。\n\n3.  **实现计算流程**：\n    对于每个测试用例，程序将执行以下操作：\n    -   **几何分析**：确定单元内裂纹线段的端点。这是通过检查水平集函数 $\\phi$ 在单元四条边上的符号变化来完成的。交点通过线性插值找到。\n    -   **数值积分**：使用3点高斯求积法计算沿裂纹线段的误差积分。在每个高斯点上：\n        a. 将物理坐标映射到等参坐标 $(\\xi, \\eta)$。\n        b. 计算双线性形函数 $N_i$。\n        c. 计算离散跳跃 $[\\![\\boldsymbol{u}_h]\\!]$ 和解析跳跃 $[\\![\\boldsymbol{u}^{\\star}]\\!]$。\n        d. 累加误差的平方。\n    -   **计算验证指标**：根据积分结果计算向量误差范数 $e_{\\mathrm{vec}}$ 和量值误差范数 $e_{\\mathrm{mag}}$。\n    -   **符号检查**：在裂纹段的中点，比较离散跳跃和解析跳跃的法向分量的符号，并设置布尔标志 $\\mathrm{sign\\_ok}$。\n\n此过程系统地应用于所有四个测试用例。前三个用例使用双线性 $\\boldsymbol{F}(\\boldsymbol{x})$，预计误差接近于机器精度零。第四个用例使用非双线性 $\\boldsymbol{F}(\\boldsymbol{x})$，这将产生一个非零的插值误差，从而对实现提供一个非平凡的检验。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the XFEM validation problem for all test cases.\n    \"\"\"\n\n    # Gauss quadrature points and weights for the interval [0, 1]\n    # Mapped from [-sqrt(3/5), 0, sqrt(3/5)] and [5/9, 8/9, 5/9] on [-1, 1].\n    s_gauss_pts = [0.5 * (1.0 - np.sqrt(3.0 / 5.0)), 0.5, 0.5 * (1.0 + np.sqrt(3.0 / 5.0))]\n    w_gauss_wts = [5.0 / 18.0, 8.0 / 18.0, 5.0 / 18.0]\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"n\": np.array([0.0, 1.0]),\n            \"x0\": np.array([0.0, 0.3]),\n            \"F\": lambda x, y: np.array([\n                0.2 + 0.5 * x + 0.1 * y - 0.1 * x * y,\n                0.3 + 0.2 * x + 0.05 * y + 0.0 * x * y\n            ]),\n        },\n        {\n            \"nodes\": np.array([[0.0, -1.0], [2.0, -1.0], [2.0, 1.0], [0.0, 1.0]]),\n            \"n\": np.array([1.0, 0.0]),\n            \"x0\": np.array([0.5, 0.0]),\n            \"F\": lambda x, y: np.array([\n                -0.4 - 0.3 * x + 0.2 * y + 0.1 * x * y,\n                0.1 - 0.1 * x + 0.05 * y - 0.02 * x * y\n            ]),\n        },\n        {\n            \"nodes\": np.array([[-1.0, -1.0], [2.0, -1.0], [2.0, 2.0], [-1.0, 2.0]]),\n            \"n\": np.array([1.0 / np.sqrt(2.0), 1.0 / np.sqrt(2.0)]),\n            \"x0\": np.array([0.0, 0.0]),\n            \"F\": lambda x, y: np.array([\n                0.1 + 0.2 * x - 0.05 * y + 0.03 * x * y,\n                -0.2 + 0.4 * x + 0.3 * y - 0.06 * x * y\n            ]),\n        },\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"n\": np.array([1.0 / np.sqrt(2.0), -1.0 / np.sqrt(2.0)]),\n            \"x0\": np.array([0.5, 0.5]),\n            \"F\": lambda x, y: np.array([\n                0.1 + x**2,\n                0.2 - y**2 + 0.1 * x * y\n            ]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        n_crack = case[\"n\"]\n        x0_crack = case[\"x0\"]\n        F_func = case[\"F\"]\n        \n        # --- 1. Find crack segment ---\n        def phi(p):\n            return np.dot(n_crack, p - x0_crack)\n\n        edges = [(nodes[0], nodes[1]), (nodes[1], nodes[2]), \n                 (nodes[2], nodes[3]), (nodes[3], nodes[0])]\n        \n        intersections = []\n        tol = 1e-12\n        for p1, p2 in edges:\n            phi1 = phi(p1)\n            phi2 = phi(p2)\n            if abs(phi1) < tol:\n                intersections.append(p1)\n            if phi1 * phi2 < -tol: # Strict sign change\n                t = phi1 / (phi1 - phi2)\n                intersect_pt = p1 + t * (p2 - p1)\n                intersections.append(intersect_pt)\n\n        # Deduplicate intersections\n        unique_intersections = []\n        if intersections:\n            # Sort to bring close points together\n            sorted_pts = sorted([tuple(p) for p in intersections])\n            unique_intersections.append(np.array(sorted_pts[0]))\n            for i in range(1, len(sorted_pts)):\n                if not np.allclose(sorted_pts[i], sorted_pts[i-1], atol=tol):\n                    unique_intersections.append(np.array(sorted_pts[i]))\n\n        if len(unique_intersections) != 2:\n            # This case should not occur for the given problems.\n            # An element is either uncut (0), cut (2), or grazed (1, not in tests).\n            # A cut through two vertices gives 2 points.\n            raise ValueError(f\"Expected 2 intersection points, found {len(unique_intersections)}\")\n\n        xA, xB = unique_intersections[0], unique_intersections[1]\n        L = np.linalg.norm(xB - xA)\n\n        # --- 2. Element properties and shape functions ---\n        xL, yB = nodes[0]\n        xR, yT = nodes[2]\n        w = xR - xL\n        h = yT - yB\n        xC = (xL + xR) / 2.0\n        yC = (yB + yT) / 2.0\n        \n        def physical_to_iso(x, y):\n            xi = 2.0 * (x - xC) / w\n            eta = 2.0 * (y - yC) / h\n            return xi, eta\n\n        def shape_functions(xi, eta):\n            N1 = 0.25 * (1 - xi) * (1 - eta)\n            N2 = 0.25 * (1 + xi) * (1 - eta)\n            N3 = 0.25 * (1 + xi) * (1 + eta)\n            N4 = 0.25 * (1 - xi) * (1 + eta)\n            return np.array([N1, N2, N3, N4])\n        \n        # --- 3. Compute enriched DOFs ---\n        b_dofs = np.array([F_func(p[0], p[1]) for p in nodes])\n        \n        # --- 4. Numerical integration for error norms ---\n        e_vec_sq_sum = 0.0\n        e_mag_sq_sum = 0.0\n        \n        for s, weight in zip(s_gauss_pts, w_gauss_wts):\n            x_s = xA + s * (xB - xA)\n            \n            xi, eta = physical_to_iso(x_s[0], x_s[1])\n            N_vals = shape_functions(xi, eta)\n            \n            jump_h = 2.0 * np.dot(N_vals, b_dofs)\n            jump_star = 2.0 * F_func(x_s[0], x_s[1])\n            \n            vec_error = jump_h - jump_star\n            e_vec_sq_sum += weight * np.dot(vec_error, vec_error)\n            \n            mag_error = np.linalg.norm(jump_h) - np.linalg.norm(jump_star)\n            e_mag_sq_sum += weight * (mag_error**2)\n\n        e_vec = np.sqrt(L * e_vec_sq_sum)\n        e_mag = np.sqrt(L * e_mag_sq_sum)\n\n        # --- 5. Sign check at midpoint ---\n        s_mid = 0.5\n        x_mid = xA + s_mid * (xB - xA)\n        \n        xi_mid, eta_mid = physical_to_iso(x_mid[0], x_mid[1])\n        N_mid = shape_functions(xi_mid, eta_mid)\n        \n        jump_h_mid = 2.0 * np.dot(N_mid, b_dofs)\n        jump_star_mid = 2.0 * F_func(x_mid[0], x_mid[1])\n        \n        sign_h = np.sign(np.dot(n_crack, jump_h_mid))\n        sign_star = np.sign(np.dot(n_crack, jump_star_mid))\n        \n        sign_ok = int(sign_h == sign_star)\n        \n        results.extend([e_vec, e_mag, sign_ok])\n\n    # Final print statement in the exact required format.\n    # We convert boolean `sign_ok` to integer 1/0.\n    formatted_results = [f\"{val:.15g}\" if isinstance(val, float) else str(val) for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2557321"}]}