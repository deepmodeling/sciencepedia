{"hands_on_practices": [{"introduction": "理论模型与实验数据的结合是进行任何有意义的模拟的关键。本练习旨在弥合实验断裂力学与内聚区模型（CZM）计算之间的差距，指导您如何从标准的双悬臂梁（DCB）测试数据中提取基本内聚参数。通过应用经典的梁理论和Irwin-Kies关系，您将练习从宏观测量（如载荷和位移）反向推导材料界面本构行为（如临界能量释放率 $G_{Ic}$ 和峰值牵引力 $\\sigma_{c}$）的核心技能。[@problem_id:2544709]", "problem": "对一个沿着薄弱界面含有预制裂纹的对称层合板进行双悬臂梁 (DCB) 试验，以表征用于分层分析的I型内聚区法则。其目标是为一个内聚区模型 (CZM) 确定法向张开下的三角形牵引力-分离位移法则的参数：临界能量释放率 $G_{I c}$、峰值法向牵引力 $\\sigma_{c}$、最终分离位移 $\\delta_{f}$ 以及初始罚刚度 $K$（法向模式）。假设线性弹性、小应变、剪切变形可忽略、根部转动可忽略。使用 Euler–Bernoulli 梁理论和 Irwin–Kies 能量释放率关系式。两个相同的悬臂臂厚度为 $h$，宽度为 $b$，由杨氏模量为 $E$ 的各向同性线性弹性固体材料制成。施加载荷 $P$ 是施加在每个悬臂臂上的力，测得的张开位移 $\\delta$ 是两个加载点之间的相对张开位移。\n\n给定数据：\n- 几何形状与材料：$E = 70 \\times 10^{9}$，$b = 0.020$，$h = 0.003$。\n- 裂纹开始扩展时的裂纹长度：$a = 0.050$。\n- 裂纹开始扩展时测得的载荷和张开位移：$P_{\\text{on}} = 60$，$\\delta_{\\text{on}} = 0.0018$。\n- 相同裂纹长度下测得的初始（损伤前）线性响应：$P_{\\ell} = 30$，$\\delta_{\\ell} = 0.00090$。\n- 通过数字图像相关法测得的完全脱粘时的最终分离位移：$\\delta_{f} = 20 \\times 10^{-6}$。\n- 为确定罚刚度 $K$，通过匹配初始斜率，将界面贡献近似为一个长度为 $L_{\\text{eff}} = 0.010$ 的等效线性弹簧，该弹簧与悬臂臂的弯曲柔度串联。\n\n任务：\n1) 使用 I 型的 Irwin–Kies 关系式 $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$，并结合两个相同悬臂梁的 Euler–Bernoulli 梁理论，推导出一个用 $P$、$\\delta$、$b$ 和 $a$ 表示 $G_{I}$ 的闭式表达式，并在起始条件下计算 $G_{I c}$。\n2) 对于 I 型的三角形牵引力-分离位移法则，使用面积条件 $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$ 来计算 $\\sigma_{c}$。\n3) 通过匹配初始斜率来确定罚刚度 $K$：将完整结构建模为裂纹长度为 $a$ 的 DCB 悬臂臂的弯曲柔度与一个刚度为 $k_{c} = b K L_{\\text{eff}}$ 的等效内聚弹簧的串联组合。使用测得的初始柔度 $C_{\\exp} = \\delta_{\\ell}/P_{\\ell}$ 来求解 $K$。\n\n报告有序三元组 $\\left(G_{I c},\\,\\sigma_{c},\\,K\\right)$，结果四舍五入到三位有效数字，其中 $G_{I c}$ 以 $\\text{J}\\,\\text{m}^{-2}$ 为单位，$\\sigma_{c}$ 以 $\\text{MPa}$ 为单位， $K$ 以 $\\text{N}\\,\\text{mm}^{-3}$ 为单位。在最终的方框答案中不要包含单位；条目的顺序必须遵循此处指定的顺序。", "solution": "首先对问题陈述进行严格验证。\n\n步骤1：提取的已知条件。\n- 材料属性：杨氏模量 $E = 70 \\times 10^{9}$。\n- 几何属性：梁宽 $b = 0.020$，梁厚（单臂）$h = 0.003$。\n- 裂纹开始扩展时的裂纹长度：$a = 0.050$。\n- 裂纹开始扩展时测得的数据：载荷 $P_{\\text{on}} = 60$，张开位移 $\\delta_{\\text{on}} = 0.0018$。\n- 同一裂纹长度下线性弹性范围内测得的数据：载荷 $P_{\\ell} = 30$，张开位移 $\\delta_{\\ell} = 0.00090$。\n- 完全失效时的最终分离位移：$\\delta_{f} = 20 \\times 10^{-6}$。\n- 用于计算罚刚度的等效长度：$L_{\\text{eff}} = 0.010$。\n- 控制关系式：Irwin–Kies 关系式 $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$，Euler–Bernoulli 梁理论，三角形内聚法则面积 $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$，以及用于初始刚度的串联柔度模型 $C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$，其中 $k_{c} = \\frac{1}{C_{\\text{coh}}} = b K L_{\\text{eff}}$。\n- 假设：线性弹性、小应变、剪切变形可忽略、根部转动可忽略。除非另有说明，所有数值均假定采用国际单位制基本单位（米、牛顿、帕斯卡）。\n\n步骤2：验证。\n该问题具有科学依据，采用线性弹性断裂力学和梁理论的标准原理来分析双悬臂梁 (DCB) 试验这一常见的实验程序。所提供的数据是自洽的；例如，从线性响应点计算出的柔度 $C_{\\ell} = \\delta_{\\ell} / P_{\\ell} = 0.00090 / 30 = 3 \\times 10^{-5}$，与起始点处的柔度 $C_{\\text{on}} = \\delta_{\\text{on}} / P_{\\text{on}} = 0.0018 / 60 = 3 \\times 10^{-5}$ 相同，这在物理上是正确的，因为裂纹开始扩展标志着线性阶段的结束。该问题是适定的、客观的，并包含足够的信息以获得唯一解。它没有违反任何指定的无效性标准。\n\n步骤3：结论。\n该问题有效。将提供解答。\n\n解答过程按序处理三个指定的任务。\n\n任务1：$G_{I}$ 的推导与 $G_{I c}$ 的计算。\n根据 Euler-Bernoulli 梁理论，长度为 $a$ 的单个悬臂梁在载荷 $P$ 作用下，其末端的挠度 $w$ 由下式给出：\n$$w = \\frac{Pa^{3}}{3EI}$$\n其中 $E$ 是杨氏模量，$I$ 是梁横截面的截面二次矩。对于宽度为 $b$、厚度为 $h$ 的矩形横截面，$I = \\frac{bh^{3}}{12}$。DCB 试样由两个这样的梁组成，因此加载点处的总张开位移 $\\delta$ 是单个悬臂臂挠度的两倍：\n$$\\delta = 2w = \\frac{2Pa^{3}}{3EI} = \\frac{2Pa^{3}}{3E \\left( \\frac{bh^{3}}{12} \\right)} = \\frac{8Pa^{3}}{Ebh^{3}}$$\n试样的柔度 $C$ 定义为张开位移与载荷之比，$C = \\delta/P$。\n$$C(a) = \\frac{8a^{3}}{Ebh^{3}}$$\n问题指定使用 I 型能量释放率的 Irwin–Kies 关系式 $G_{I}$：\n$$G_{I} = \\frac{P^{2}}{2b} \\frac{dC}{da}$$\n我们计算柔度相对于裂纹长度 $a$ 的导数：\n$$\\frac{dC}{da} = \\frac{d}{da} \\left( \\frac{8a^{3}}{Ebh^{3}} \\right) = \\frac{24a^{2}}{Ebh^{3}}$$\n将此导数代入 Irwin–Kies 关系式，得到 $G_{I}$ 的表达式：\n$$G_{I} = \\frac{P^{2}}{2b} \\left( \\frac{24a^{2}}{Ebh^{3}} \\right) = \\frac{12P^{2}a^{2}}{b^{2}Eh^{3}}$$\n为按要求用 $P$、$\\delta$、$b$ 和 $a$ 表示 $G_{I}$，我们使用柔度关系式 $C = \\delta/P$ 并注意到 $\\frac{dC}{da} = 3 \\frac{C}{a}$。因此：\n$$G_{I} = \\frac{P^{2}}{2b} \\left( 3 \\frac{C}{a} \\right) = \\frac{3P^{2}}{2ab} \\left( \\frac{\\delta}{P} \\right) = \\frac{3P\\delta}{2ab}$$\n这就是所要求的闭式表达式。临界能量释放率 $G_{I c}$ 是在裂纹开始扩展时使用所提供的数据计算的：$P_{\\text{on}} = 60\\,\\text{N}$，$\\delta_{\\text{on}} = 0.0018\\,\\text{m}$，$a = 0.050\\,\\text{m}$ 和 $b = 0.020\\,\\text{m}$。\n$$G_{I c} = \\frac{3 P_{\\text{on}} \\delta_{\\text{on}}}{2ab} = \\frac{3 \\times 60 \\times 0.0018}{2 \\times 0.050 \\times 0.020} = \\frac{0.324}{0.002} = 162\\,\\text{J}\\,\\text{m}^{-2}$$\n\n任务2：峰值法向牵引力 $\\sigma_{c}$ 的计算。\n对于三角形牵引力-分离位移法则，断裂能 $G_{I c}$ 是由峰值牵引力 $\\sigma_{c}$ 和最终分离位移 $\\delta_{f}$ 定义的三角形的面积：\n$$G_{I c} = \\frac{1}{2} \\sigma_{c} \\delta_{f}$$\n求解 $\\sigma_{c}$：\n$$\\sigma_{c} = \\frac{2G_{I c}}{\\delta_{f}}$$\n使用计算值 $G_{I c} = 162\\,\\text{J}\\,\\text{m}^{-2}$ 和给定的最终分离位移 $\\delta_{f} = 20 \\times 10^{-6}\\,\\text{m}$：\n$$\\sigma_{c} = \\frac{2 \\times 162}{20 \\times 10^{-6}} = \\frac{324}{20 \\times 10^{-6}} = 16.2 \\times 10^{6}\\,\\text{Pa}$$\n由于 $1\\,\\text{MPa} = 10^{6}\\,\\text{Pa}$，峰值牵引力为 $\\sigma_{c} = 16.2\\,\\text{MPa}$。\n\n任务3：罚刚度 $K$ 的确定。\n试样的初始响应被建模为梁弯曲柔度 $C_{\\text{beam}}$ 和等效内聚柔度 $C_{\\text{coh}}$ 的串联组合。总测量柔度 $C_{\\exp}$ 是这两者之和：\n$$C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$$\n实验柔度由线性响应数据确定：\n$$C_{\\exp} = \\frac{\\delta_{\\ell}}{P_{\\ell}} = \\frac{0.00090}{30} = 3.0 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\n梁弯曲柔度由先前推导的理论表达式给出：\n$$C_{\\text{beam}} = \\frac{8a^{3}}{Ebh^{3}} = \\frac{8 \\times (0.050)^{3}}{(70 \\times 10^{9}) \\times 0.020 \\times (0.003)^{3}} = \\frac{1 \\times 10^{-3}}{37.8} \\approx 2.6455 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\n内聚柔度通过减法求得：\n$$C_{\\text{coh}} = C_{\\exp} - C_{\\text{beam}} = (3.0 \\times 10^{-5}) - (2.6455 \\times 10^{-5}) = 0.3545 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\n内聚柔度通过等效弹簧刚度 $k_c = 1/C_{\\text{coh}}$ 与罚刚度 $K$ 相关。该弹簧表示罚刚度在等效面积 $A_{\\text{eff}} = b L_{\\text{eff}}$ 上的积分效应。内聚区的刚度由 $k_{c} = b K L_{\\text{eff}}$ 给出。 因此：\n$$C_{\\text{coh}} = \\frac{1}{b K L_{\\text{eff}}}$$\n求解 $K$：\n$$K = \\frac{1}{b L_{\\text{eff}} C_{\\text{coh}}} = \\frac{1}{0.020 \\times 0.010 \\times (0.3545 \\times 10^{-5})} = \\frac{1}{7.09 \\times 10^{-10}} \\approx 1.4104 \\times 10^{9}\\,\\text{N}\\,\\text{m}^{-3}$$\n结果必须转换为 $\\text{N}\\,\\text{mm}^{-3}$。转换因子为 $1\\,\\text{N}\\,\\text{m}^{-3} = 1\\,\\text{N}\\,(1000\\,\\text{mm})^{-3} = 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3}$。\n$$K = (1.4104 \\times 10^{9}) \\times 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3} \\approx 1.4104\\,\\text{N}\\,\\text{mm}^{-3}$$\n四舍五入到三位有效数字，$K = 1.41\\,\\text{N}\\,\\text{mm}^{-3}$。\n\n最终的有序三元组 $(G_{I c}, \\sigma_{c}, K)$，其值四舍五入到三位有效数字后为 $(162\\,\\text{J}\\,\\text{m}^{-2}, 16.2\\,\\text{MPa}, 1.41\\,\\text{N}\\,\\text{mm}^{-3})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 162 & 16.2 & 1.41 \\end{pmatrix}\n}\n$$", "id": "2544709"}, {"introduction": "许多工程材料（尤其是聚合物和复合材料）在断裂过程中表现出显著的时间依赖性行为，而简单的弹性-软化内聚模型无法捕捉这一点。本练习将引导您将内聚模型扩展到粘弹性领域，具体采用由弹簧和粘壶串联组成的Maxwell模型。您将从第一性原理出发，推导控制方程的离散更新格式（后向欧拉法）以及用于确保数值求解鲁棒性的“一致性切线刚度”，这些都是计算非弹性力学中的基础且重要的技能。[@problem_id:2544693]", "problem": "考虑一个由线性弹簧和线性黏壶串联组成的麦克斯韦单元建模的一维黏性界面。设标量张开位移表示为 $\\delta(t)$，标量牵引力表示为 $t(t)$。对于串联连接，两个组成部分中的牵引力相同，总张开位移是弹簧和黏壶张开位移之和。假设线性弹簧的刚度为 $k$，线性黏壶的黏度为 $\\eta$，两者均为正常数。使用以下基本法则：\n\n- 串联平衡：弹簧和黏壶中的牵引力相同，即 $t_{\\text{spring}}(t) = t_{\\text{dashpot}}(t) = t(t)$。\n- 串联运动学可加性：$\\delta(t) = \\delta_{\\text{spring}}(t) + \\delta_{\\text{dashpot}}(t)$。\n- 线性弹簧定律：$t(t) = k\\,\\delta_{\\text{spring}}(t)$。\n- 线性黏壶定律：$t(t) = \\eta\\,\\dot{\\delta}_{\\text{dashpot}}(t)$。\n- 时间离散化：在从 $t_n$ 到 $t_{n+1}$ 的时间步长 $\\Delta t > 0$ 上，使用后向欧拉法，其中 $(\\delta_n, t_n)$ 已知，$\\delta_{n+1}$ 给定。\n\n您的任务是：\n\n1) 仅从上述基本定律和定义出发，推导以 $\\delta(t)$ 表示的控制 $t(t)$ 的一阶常微分方程，然后使用后向欧拉法在区间 $[t_n, t_{n+1}]$ 上推导牵引力 $t_{n+1}$ 的全离散更新格式。您最终的离散更新格式必须用 $k$、$\\eta$、$\\Delta t$、$\\delta_n$、$\\delta_{n+1}$ 和 $t_n$ 表示。\n\n2) 推导与您的后向欧拉离散化相关的算法一致性切线（一致性雅可比），即导数 $\\dfrac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$，并保持 $k$、$\\eta$、$\\Delta t$、$\\delta_n$ 和 $t_n$ 不变。\n\n3) 编写一个程序，给定 $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$，计算并返回更新后的牵引力 $t_{n+1}$ 和一致性切线 $\\dfrac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$。该程序必须应用您从第（1）和（2）部分推导出的闭式公式。\n\n物理和数值单位：\n- 牵引力 $t_{n+1}$ 以帕斯卡（Pa）为单位报告。\n- 切线 $\\dfrac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$ 以帕斯卡每米（Pa/m）为单位报告。\n- 所有角度（如有）必须以弧度为单位，尽管此处不直接涉及角度。\n- 所有数值答案必须打印为浮点数。\n\n测试套件：\n使用以下参数集，每个参数集指定为 $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$，单位为 $(\\text{m}, \\text{Pa}, \\text{m}, \\text{s}, \\text{Pa/m}, \\text{Pa}\\cdot\\text{s}/\\text{m})$：\n\n- 情况 A（一般情况）：$(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (0, 0, 10^{-4}, 10^{-2}, 2\\times 10^{6}, 2\\times 10^{3})$。\n- 情况 B（极小时间步）：$(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (10^{-5}, 10^{2}, 3\\times 10^{-5}, 10^{-9}, 10^{6}, 10^{3})$。\n- 情况 C（极大时间步）：$(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (0, 0, 10^{-3}, 10^{1}, 10^{6}, 10^{3})$。\n- 情况 D（极大黏度）：$(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta) = (5\\times 10^{-4}, 2.5\\times 10^{2}, 10^{-3}, 1, 10^{6}, 10^{12})$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含所有四种情况的结果，以逗号分隔，并用方括号括起来。对于每种情况，先输出牵引力，后输出切线，因此总结果必须按以下顺序排列 $[t_{n+1}^{(A)}, \\frac{\\partial t_{n+1}^{(A)}}{\\partial \\delta_{n+1}}, t_{n+1}^{(B)}, \\frac{\\partial t_{n+1}^{(B)}}{\\partial \\delta_{n+1}}, t_{n+1}^{(C)}, \\frac{\\partial t_{n+1}^{(C)}}{\\partial \\delta_{n+1}}, t_{n+1}^{(D)}, \\frac{\\partial t_{n+1}^{(D)}}{\\partial \\delta_{n+1}}]$。", "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n第 1 步：提取已知条件\n问题描述了一个一维黏性界面，其模型为一个麦克斯韦单元，由一个线性弹簧和一个线性黏壶串联组成。\n- 变量：标量张开位移 $\\delta(t)$，标量牵引力 $t(t)$。\n- 常数：弹簧刚度 $k > 0$，黏壶黏度 $\\eta > 0$。\n- 基本定律：\n    1. 串联平衡：$t_{\\text{spring}}(t) = t_{\\text{dashpot}}(t) = t(t)$。\n    2. 串联运动学可加性：$\\delta(t) = \\delta_{\\text{spring}}(t) + \\delta_{\\text{dashpot}}(t)$。\n    3. 线性弹簧定律：$t(t) = k\\,\\delta_{\\text{spring}}(t)$。\n    4. 线性黏壶定律：$t(t) = \\eta\\,\\dot{\\delta}_{\\text{dashpot}}(t)$，其中 $\\dot{(\\cdot)}$ 表示对时间 $t$ 的导数。\n- 数值方法：\n    - 使用后向欧拉法进行时间离散化。\n    - 从 $t_n$ 到 $t_{n+1}$ 的时间步长为 $\\Delta t > 0$。\n    - 在时间步开始时，$(\\delta_n, t_n)$ 是已知的。\n    - 在时间步结束时，位移 $\\delta_{n+1}$ 是给定的。\n- 测试数据：提供了四组参数 $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$，并指定了单位。\n\n第 2 步：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n- **科学性**：该问题基于线性黏弹性的麦克斯韦模型，这是连续介质力学和材料科学中的一个基本概念。其控制方程是标准且正确的。\n- **适定性**：该问题是适定的。它要求推导一个一阶常微分方程，并随后使用标准数值方法（后向欧拉法）对其进行时间离散化。一致性切线的推导是计算力学中实现隐式求解器的标准流程。输入被明确定义，并期望得到唯一解。\n- **客观性**：问题以精确、客观的数学和物理术语陈述。\n- **完整性和一致性**：提供了所有必要的定义、定律和参数。没有矛盾之处。\n- **可行性和现实性**：该问题在物理上是现实的，在计算上是可行的。所提供的参数，包括用于测试极限情况的参数，在物理上都是合理的。\n\n第 3 步：结论和行动\n问题有效。它在科学上是合理的、适定的和完整的。将提供一个完整的、有理有据的解答。\n\n**第 1 部分：控制常微分方程（ODE）和离散更新的推导**\n\n目标是推导牵引力 $t(t)$ 和总张开位移 $\\delta(t)$ 之间的关系。我们从提供的基本定律开始。运动学可加性表明：\n$$\n\\delta(t) = \\delta_{\\text{spring}}(t) + \\delta_{\\text{dashpot}}(t)\n$$\n将此表达式对时间 $t$ 求导，得到速率之间的关系：\n$$\n\\dot{\\delta}(t) = \\dot{\\delta}_{\\text{spring}}(t) + \\dot{\\delta}_{\\text{dashpot}}(t)\n$$\n弹簧和黏壶的本构律可以被重新整理和微分，以用牵引力 $t(t)$ 及其速率 $\\dot{t}(t)$ 来表示这些速率。\n根据线性弹簧定律，$t(t) = k\\,\\delta_{\\text{spring}}(t)$，我们有 $\\delta_{\\text{spring}}(t) = \\frac{t(t)}{k}$。对时间求导，得到：\n$$\n\\dot{\\delta}_{\\text{spring}}(t) = \\frac{1}{k}\\dot{t}(t)\n$$\n根据线性黏壶定律，$t(t) = \\eta\\,\\dot{\\delta}_{\\text{dashpot}}(t)$，我们可以直接写出：\n$$\n\\dot{\\delta}_{\\text{dashpot}}(t) = \\frac{1}{\\eta}t(t)\n$$\n将这两个速率表达式代回微分后的运动学可加性方程中，我们得到：\n$$\n\\dot{\\delta}(t) = \\frac{1}{k}\\dot{t}(t) + \\frac{1}{\\eta}t(t)\n$$\n重新整理此方程，将 $\\dot{t}(t)$ 表示为 $t(t)$ 和 $\\dot{\\delta}(t)$ 的函数，便得到牵引力的一阶常微分方程（ODE）：\n$$\n\\dot{t}(t) = k\\,\\dot{\\delta}(t) - \\frac{k}{\\eta}t(t)\n$$\n这就是麦克斯韦模型的控制常微分方程。\n\n接下来，我们在时长为 $\\Delta t = t_{n+1} - t_n$ 的时间区间 $[t_n, t_{n+1}]$ 上，使用后向欧拉法对该 ODE 进行离散化。后向欧拉格式将时间 $t_{n+1}$ 处的导数近似为有限差分，并在 $t_{n+1}$ 处计算所有其他项：\n$$\n\\frac{t_{n+1} - t_n}{\\Delta t} \\approx \\dot{t}(t_{n+1})\n$$\n$$\n\\frac{\\delta_{n+1} - \\delta_n}{\\Delta t} \\approx \\dot{\\delta}(t_{n+1})\n$$\n将这些近似值代入在 $t_{n+1}$ 处计算的 ODE 中，得到离散方程：\n$$\n\\frac{t_{n+1} - t_n}{\\Delta t} = k \\left( \\frac{\\delta_{n+1} - \\delta_n}{\\Delta t} \\right) - \\frac{k}{\\eta} t_{n+1}\n$$\n我们的目标是求解未知牵引力 $t_{n+1}$，用已知量 $t_n$、$\\delta_n$ 和给定量 $\\delta_{n+1}$ 来表示。首先，将整个方程乘以 $\\Delta t$：\n$$\nt_{n+1} - t_n = k (\\delta_{n+1} - \\delta_n) - \\frac{k \\Delta t}{\\eta} t_{n+1}\n$$\n接下来，我们将所有包含 $t_{n+1}$ 的项移到方程左侧：\n$$\nt_{n+1} + \\frac{k \\Delta t}{\\eta} t_{n+1} = t_n + k (\\delta_{n+1} - \\delta_n)\n$$\n提取公因子 $t_{n+1}$：\n$$\nt_{n+1} \\left( 1 + \\frac{k \\Delta t}{\\eta} \\right) = t_n + k (\\delta_{n+1} - \\delta_n)\n$$\n最后，分离出 $t_{n+1}$，得到全离散更新公式：\n$$\nt_{n+1} = \\frac{t_n + k (\\delta_{n+1} - \\delta_n)}{1 + \\frac{k \\Delta t}{\\eta}}\n$$\n\n**第 2 部分：算法一致性切线的推导**\n\n算法一致性切线（或一致性雅可比）是更新后的未知变量 $t_{n+1}$ 相对于给定的驱动变量 $\\delta_{n+1}$ 的导数。这在有限元背景下，对于牛顿-拉夫逊型迭代求解器是必需的。我们必须计算偏导数 $\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$，同时保持所有其他参数和上一步的变量（$k$、$\\eta$、$\\Delta t$、$\\delta_n$、$t_n$）为常数。\n我们从推导出的 $t_{n+1}$ 表达式开始：\n$$\nt_{n+1} = \\frac{t_n + k \\delta_{n+1} - k \\delta_n}{1 + \\frac{k \\Delta t}{\\eta}}\n$$\n我们将其重写，以分离出依赖于 $\\delta_{n+1}$ 的项：\n$$\nt_{n+1} = \\left( \\frac{1}{1 + \\frac{k \\Delta t}{\\eta}} \\right) (t_n - k \\delta_n + k \\delta_{n+1})\n$$\n第一个括号中的项相对于 $\\delta_{n+1}$ 是一个常数。因此，求导过程非常直接：\n$$\n\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\frac{\\partial}{\\partial \\delta_{n+1}} \\left[ \\left( \\frac{1}{1 + \\frac{k \\Delta t}{\\eta}} \\right) (t_n - k \\delta_n + k \\delta_{n+1}) \\right]\n$$\n$$\n\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\left( \\frac{1}{1 + \\frac{k \\Delta t}{\\eta}} \\right) \\frac{\\partial}{\\partial \\delta_{n+1}} (t_n - k \\delta_n + k \\delta_{n+1})\n$$\n项 $(t_n - k \\delta_n + k \\delta_{n+1})$ 对 $\\delta_{n+1}$ 的导数就是 $k$。\n因此，一致性切线为：\n$$\n\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\frac{k}{1 + \\frac{k \\Delta t}{\\eta}}\n$$\n\n**第 3 部分：实现**\n\n推导出的 $t_{n+1}$ 及其导数 $\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}}$ 的公式在一个 Python 程序中实现。该程序为问题陈述中提供的四个测试用例分别计算这两个值，并按要求格式化输出。计算直接遵循方程。\n对于一组给定的参数 $(\\delta_n, t_n, \\delta_{n+1}, \\Delta t, k, \\eta)$:\n1.  牵引力计算如下 $t_{n+1} = \\frac{t_n + k \\cdot (\\delta_{n+1} - \\delta_n)}{1 + (k \\cdot \\Delta t) / \\eta}$。\n2.  一致性切线计算如下 $\\frac{\\partial t_{n+1}}{\\partial \\delta_{n+1}} = \\frac{k}{1 + (k \\cdot \\Delta t) / \\eta}$。\n将对所有指定的测试用例执行这些计算。最终答案将呈现数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the updated traction and consistent tangent for a 1D Maxwell model\n    discretized with backward Euler, for a given set of test cases.\n    \"\"\"\n\n    # Test cases from the problem statement.\n    # Each tuple is in the format: (delta_n, t_n, delta_n_plus_1, dt, k, eta)\n    # Units: (m, Pa, m, s, Pa/m, Pa*s/m)\n    test_cases = [\n        # Case A (general case)\n        (0.0, 0.0, 1e-4, 1e-2, 2e6, 2e3),\n        # Case B (very small time step)\n        (1e-5, 100.0, 3e-5, 1e-9, 1e6, 1e3),\n        # Case C (very large time step)\n        (0.0, 0.0, 1e-3, 10.0, 1e6, 1e3),\n        # Case D (very large viscosity)\n        (5e-4, 250.0, 1e-3, 1.0, 1e6, 1e12),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_n, t_n, delta_n_plus_1, dt, k, eta = case\n\n        # Derived formula for the updated traction t_{n+1}\n        # t_{n+1} = (t_n + k * (delta_{n+1} - delta_n)) / (1 + (k * dt) / eta)\n        numerator_t = t_n + k * (delta_n_plus_1 - delta_n)\n        denominator = 1.0 + (k * dt) / eta\n        t_n_plus_1 = numerator_t / denominator\n\n        # Derived formula for the consistent tangent d(t_{n+1})/d(delta_{n+1})\n        # tangent = k / (1 + (k * dt) / eta)\n        tangent = k / denominator\n        \n        results.append(t_n_plus_1)\n        results.append(tangent)\n\n    # Final print statement in the exact required format.\n    # Example format: [val1_A,val2_A,val1_B,val2_B,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2544693"}, {"introduction": "为了模拟更复杂的不可逆界面失效过程，我们需要一个比简单软化或粘弹性更通用的框架，而界面塑性理论为此提供了强大的工具。本练习是一项高级实践，要求您为率无关的关联塑性内聚模型开发并实施一个完整的“返回映射算法”。您将深入探讨弹塑性本构更新的核心逻辑：从弹性试探步到塑性修正步，再到推导保证全局牛顿法二次收敛的一致性算法切线，这是现代计算塑性力学中的一个基石性技术。[@problem_id:2544669]", "problem": "您的任务是为具有率无关伴随塑性的界面，在内聚区模型的背景下，开发并实现一个稳健的返回映射算法。界面牵引力 $\\mathbf{t} \\in \\mathbb{R}^2$（其分量对应于法向和剪切方向）通过线性弹性关系与位移跳跃 $\\boldsymbol{\\delta} \\in \\mathbb{R}^2$ 及塑性位移跳跃 $\\boldsymbol{\\delta}^{\\mathrm{p}} \\in \\mathbb{R}^2$ 相关联。屈服条件和伴随流动法则作用于跳跃空间中。您的程序必须为多个测试用例计算更新后的牵引力和算法一致切线。\n\n从以下率无关伴随塑性和线性弹性的基本定律及定义开始：\n- 界面的弹性本构关系为 $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$，其中 $\\mathbf{K} \\in \\mathbb{R}^{2 \\times 2}$ 是一个对称正定的界面刚度矩阵。\n- 屈服函数是凸函数，由下式给出\n$$\nf(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0,\n$$\n其中 $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定矩阵，且 $t_c > 0$。\n- 塑性容许性的 Kuhn–Tucker 条件为\n$$\nf(\\mathbf{t}) \\le 0,\\quad \\Delta\\gamma \\ge 0,\\quad \\Delta\\gamma\\,f(\\mathbf{t}) = 0,\n$$\n其中 $\\Delta\\gamma \\ge 0$ 是塑性乘子增量。\n- 跳跃空间中的伴随流动法则为\n$$\n\\Delta \\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma\\,\\frac{\\partial f}{\\partial \\mathbf{t}}(\\mathbf{t}).\n$$\n\n您必须推导出一个返回映射算法，该算法在给定上述弹性预测子和屈服函数的情况下，计算更新后的牵引力 $\\mathbf{t}_{n+1}$ 和一致算法切线 $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$，以确保全局层面牛顿法的二次收敛性。只能使用上述基本陈述作为出发点，不要假设任何特殊的简化公式。\n\n具体操作如下：\n1. 给定 $\\boldsymbol{\\delta}_{n+1}$ 和 $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n}$，构建弹性预测子（试探状态）\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big)\n$$\n并通过 $f(\\mathbf{t}^{\\mathrm{tr}})$ 来检验屈服容许性。\n2. 如果 $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$，则该步为弹性步：设置 $\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}$ 和 $\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{K}$。\n3. 如果 $f(\\mathbf{t}^{\\mathrm{tr}}) > 0$，则通过使用与约束 $f(\\mathbf{t}_{n+1}) = 0$ 相关的拉格朗日乘子 $\\lambda \\ge 0$ 和增量势的驻定性，返回到屈服面来强制执行一致性条件。证明驻定性条件可导出以下非线性系统\n$$\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - \\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0},\\quad f(\\mathbf{t}_{n+1}) = 0,\n$$\n您必须求解该系统以得到 $\\mathbf{t}_{n+1}$ 和 $\\lambda$。证明这可以简化为一个关于 $\\lambda$ 的一维求根问题。\n4. 假设理想塑性（无硬化），通过对上述系统关于 $\\boldsymbol{\\delta}_{n+1}$ 进行线性化，推导出精确的一致算法切线 $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$。您的最终表达式必须通过从线性化方程中消去 $\\mathrm{d}\\lambda$ 来获得，使得 $\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{C}_{\\mathrm{alg}}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$。\n\n所有量均为无量纲；不需要物理单位。\n\n您的程序必须实现此返回映射算法，并为以下测试套件生成所要求的输出。每个测试用例提供 $\\mathbf{K}$、$\\mathbf{A}$、$t_c$、$\\boldsymbol{\\delta}_{n+1}$ 和 $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$。对于每个测试，计算：\n- 更新后的牵引力分量 $\\mathbf{t}_{n+1} = [t_n,\\, t_s]^\\mathsf{T}$。\n- 一致切线矩阵 $\\mathbf{C}_{\\mathrm{alg}} \\in \\mathbb{R}^{2\\times 2}$，以其元素 $C_{11}, C_{12}, C_{21}, C_{22}$ 的形式报告。\n\n测试套件：\n- 测试 $1$（弹性，对角 $\\mathbf{K}$）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.002 \\\\ 0.002 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 $2$（塑性，对角 $\\mathbf{K}$）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 $3$（在屈服面上，如果 $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$ 则视为弹性）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} \\frac{3}{1000\\sqrt{2}} \\\\ \\frac{2}{500\\sqrt{2}} \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 $4$（塑性，耦合 $\\mathbf{K}$）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1200 & 200 \\\\ 200 & 800 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 $5$（弹性，具有非零的先前塑性跳跃）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000 & 0 \\\\ 0 & 500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9} & 0 \\\\ 0 & \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.006 \\\\ 0.0 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0.004 \\\\ 0.0 \\end{bmatrix}$。\n\n程序输出规范：\n- 对每个测试，输出列表 $[t_n, t_s, C_{11}, C_{12}, C_{21}, C_{22}]$，所有元素均四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试的结果，形式为这些列表的逗号分隔列表，并用方括号括起来，例如：\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$。", "solution": "本问题要求针对内聚界面的率无关伴随塑性，推导并实现一个返回映射算法。对于给定的材料参数和最终位移跳跃 $\\boldsymbol{\\delta}_{n+1}$，我们必须计算更新后的牵引力向量 $\\mathbf{t}_{n+1}$ 和一致算法切线矩阵 $\\mathbf{C}_{\\mathrm{alg}}$。推导过程必须从第一性原理出发。\n\n让我们首先将问题形式化。时间增量开始时的状态是已知的，其特征为塑性位移跳跃 $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$。增量结束时的总位移跳跃 $\\boldsymbol{\\delta}_{n+1}$ 是给定的。\n\n控制方程如下：\n1.  弹性定律： $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$\n2.  屈服函数： $f(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0$\n3.  流动法则（后向欧拉离散化）： $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} + \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}$，其中 $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma \\left. \\frac{\\partial f}{\\partial \\mathbf{t}} \\right|_{\\mathbf{t}_{n+1}}$\n4.  Kuhn-Tucker 加载/卸载条件： $\\Delta\\gamma \\ge 0$, $f(\\mathbf{t}_{n+1}) \\le 0$, $\\Delta\\gamma\\,f(\\mathbf{t}_{n+1}) = 0$\n\n屈服函数的梯度为：\n$$\n\\frac{\\partial f}{\\partial \\mathbf{t}} = \\frac{\\mathbf{A}\\,\\mathbf{t}}{\\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}}}\n$$\n在塑性加载期间，我们有 $f(\\mathbf{t}_{n+1}) = 0$，这意味着 $\\sqrt{\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}} = t_c$。因此，流动法则简化为：\n$$\n\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\frac{\\Delta\\gamma}{t_c} \\mathbf{A}\\,\\mathbf{t}_{n+1} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\n这里我们定义了缩放后的（非负）塑性乘子 $\\lambda = \\Delta\\gamma/t_c \\ge 0$。\n\n返回映射算法分为两个主要步骤：一个弹性试探步，以及在必要时跟随一个塑性校正步。\n\n**第1步：弹性预测子（试探状态）**\n首先，我们假设整个增量步是弹性的，即 $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\mathbf{0}$。试探牵引力 $\\mathbf{t}^{\\mathrm{tr}}$ 使用弹性定律计算得出：\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n})\n$$\n然后，我们通过在该试探状态下评估屈服函数来检查是否发生塑性屈服：\n$$\nf(\\mathbf{t}^{\\mathrm{tr}}) = \\sqrt{(\\mathbf{t}^{\\mathrm{tr}})^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}^{\\mathrm{tr}}} - t_c\n$$\n如果 $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$，则弹性假设是正确的。状态更新如下：\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\n$$\n\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\n响应是纯弹性的，因此一致切线就是弹性刚度矩阵：\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}} = \\frac{\\partial}{\\partial \\boldsymbol{\\delta}_{n+1}} \\left[ \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) \\right] = \\mathbf{K}\n$$\n\n**第2步：塑性校正（返回映射）**\n如果 $f(\\mathbf{t}^{\\mathrm{tr}}) > 0$，则试探状态位于弹性域之外，需要进行塑性校正。最终状态 $(\\mathbf{t}_{n+1}, \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1})$ 必须满足本构方程和一致性条件 $f(\\mathbf{t}_{n+1}) = 0$。\n\n更新后的牵引力与试探状态的关系为：\n$$\n\\mathbf{t}_{n+1} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1}) = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} - \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}) = \\mathbf{t}^{\\mathrm{tr}} - \\mathbf{K}\\,\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}\n$$\n代入流动法则 $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}$：\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}} - \\lambda\\,\\mathbf{K}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\n整理得到 $\\mathbf{t}_{n+1}$：\n$$\n(\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\n用 $\\mathbf{K}^{-1}$ 左乘，得到：\n$$\n(\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathbf{t}^{\\mathrm{tr}} = \\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\n这导出了 $\\mathbf{t}_{n+1}$ 作为未知乘子 $\\lambda$ 的函数表达式：\n$$\n\\mathbf{t}_{n+1}(\\lambda) = (\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})^{-1}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) = (\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})^{-1}\\,\\mathbf{t}^{\\mathrm{tr}}\n$$\n用于求解塑性步的方程组，如问题中所给，由该关系和一致性条件组成：\n$$\n\\begin{cases}\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - (\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0} \\\\\nf(\\mathbf{t}_{n+1}) = 0\n\\end{cases}\n$$\n为求解此系统，我们将 $\\mathbf{t}_{n+1}(\\lambda)$ 的表达式代入一致性条件 $f(\\mathbf{t}_{n+1})=0$ 中，这等价于 $\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} - t_c^2 = 0$。这将得到一个关于 $\\lambda$ 的标量非线性残差方程：\n$$\nR(\\lambda) = \\sqrt{\\mathbf{t}_{n+1}(\\lambda)^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}(\\lambda)} - t_c = 0\n$$\n这个关于 $\\lambda > 0$ 的一维求根问题可以使用如牛顿-拉夫逊法等数值方法高效求解。一旦确定了 $\\lambda$，就可以计算出更新后的牵引力 $\\mathbf{t}_{n+1}$。\n\n**第3步：一致算法切线的推导**\n在有限元背景下，为确保全局牛顿-拉夫逊求解器的二次收敛性，需要一致切线算子 $\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$。它通过对控制塑性状态的方程组取全微分来推导。我们对系统进行线性化：\n1.  $(\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\mathbf{t}^{\\mathrm{tr}}$\n2.  $f(\\mathbf{t}_{n+1}) = 0$\n\n回想 $\\mathbf{t}^{\\mathrm{tr}}$ 依赖于 $\\boldsymbol{\\delta}_{n+1}$（通过 $\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$），我们对第一个方程进行微分：\n$$\n\\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} + (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\,\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}^{-1}\\,(\\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}) = \\mathrm{d}\\boldsymbol{\\delta}_{n+1}\n$$\n我们定义 $\\mathbf{H}_{\\lambda}^{-1} = \\mathbf{K}^{-1} + \\lambda\\mathbf{A}$。解出 $\\mathrm{d}\\mathbf{t}_{n+1}$：\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1})\n$$\n接下来，我们对一致性条件 $f(\\mathbf{t}_{n+1})=0$ 微分，这意味着任何变分都必须位于屈服面的切平面内：\n$$\n\\mathrm{d}f = \\left(\\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}}\\right)^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0\n$$\n令 $\\mathbf{m} = \\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}} = \\frac{\\mathbf{A}\\,\\mathbf{t}_{n+1}}{t_c}$。条件为 $\\mathbf{m}^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0$。\n代入 $\\mathrm{d}\\mathbf{t}_{n+1}$ 的表达式：\n$$\n\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) = 0\n$$\n我们求解此方程以得到乘子微分 $\\mathrm{d}\\lambda$：\n$$\n\\mathrm{d}\\lambda = \\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\n此表达式将塑性乘子的增量与总位移跳跃的增量联系起来。最后，我们将 $\\mathrm{d}\\lambda$ 代回到 $\\mathrm{d}\\mathbf{t}_{n+1}$ 的表达式中，以消除对 $\\mathrm{d}\\lambda$ 的依赖：\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\\,\\left(\\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\\right)\n$$\n使用外积表示法 $(\\mathbf{u} \\otimes \\mathbf{v}) \\mathbf{w} = \\mathbf{u} (\\mathbf{v}^\\mathsf{T} \\mathbf{w})$，我们可以识别出从 $\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$ 到 $\\mathrm{d}\\mathbf{t}_{n+1}$ 的映射算子：\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{H}_{\\lambda} - \\frac{(\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) \\otimes (\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda})}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\n其中 $\\mathbf{H}_{\\lambda} = (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})^{-1}$ 且 $\\mathbf{m} = \\mathbf{A}\\,\\mathbf{t}_{n+1} / t_c$。这就是塑性步的精确一致算法切线。\n\n现在的实现将遵循此推导的算法来处理所提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the cohesive zone plasticity problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (elastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.002, 0.002]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 2 (plastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 3 (on the yield surface)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([3.0 / (1000.0 * np.sqrt(2.0)), 2.0 / (500.0 * np.sqrt(2.0))]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 4 (plastic, coupled K)\n        {\n            'K': np.array([[1200.0, 200.0], [200.0, 800.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 5 (elastic with prior plastic jump)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.006, 0.0]),\n            'delta_p_n': np.array([0.004, 0.0])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K = case['K']\n        A = case['A']\n        tc = case['tc']\n        delta_n1 = case['delta']\n        delta_p_n = case['delta_p_n']\n\n        # Step 1: Elastic Predictor\n        delta_e_tr = delta_n1 - delta_p_n\n        t_tr = K @ delta_e_tr\n        \n        # Check yield condition\n        f_tr_val_sq = t_tr.T @ A @ t_tr\n        f_tr = np.sqrt(f_tr_val_sq) - tc\n\n        if f_tr <= 1e-12:  # Using tolerance for floating point comparison\n            # Elastic step\n            t_n1 = t_tr\n            C_alg = K\n        else:\n            # Plastic step: return mapping\n            \n            # Formulate the residual function for lambda\n            K_inv = np.linalg.inv(K)\n            \n            def residual(lam):\n                # Using the expression t_n1 = (I + lambda*K*A)^-1 * t_tr\n                # Inversion is expensive, so it's better to solve the linear system\n                # (I + lam*K@A) @ t_n1 = t_tr\n                M = np.eye(2) + lam * K @ A\n                t_n1_lam = np.linalg.solve(M, t_tr)\n                yield_val_sq = t_n1_lam.T @ A @ t_n1_lam\n                return np.sqrt(yield_val_sq) - tc\n\n            # Solve for lambda using a root-finding algorithm\n            sol = root_scalar(residual, bracket=[0, 1e-2], method='brentq')\n            lam = sol.root\n            \n            # Update traction vector\n            M_final = np.eye(2) + lam * K @ A\n            t_n1 = np.linalg.solve(M_final, t_tr)\n            \n            # Calculate consistent tangent\n            H_lam = np.linalg.inv(K_inv + lam * A)\n            m = (A @ t_n1) / tc\n            \n            numerator_vec1 = H_lam @ A @ t_n1\n            numerator_vec2_T = m.T @ H_lam\n            \n            denominator = m.T @ H_lam @ A @ t_n1\n            \n            C_alg = H_lam - np.outer(numerator_vec1, numerator_vec2_T) / denominator\n\n        # Format output\n        tn, ts = t_n1[0], t_n1[1]\n        C11, C12 = C_alg[0, 0], C_alg[0, 1]\n        C21, C22 = C_alg[1, 0], C_alg[1, 1]\n        \n        results.append(\n            f\"[{tn:.6f},{ts:.6f},{C11:.6f},{C12:.6f},{C21:.6f},{C22:.6f}]\"\n        )\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2544669"}]}