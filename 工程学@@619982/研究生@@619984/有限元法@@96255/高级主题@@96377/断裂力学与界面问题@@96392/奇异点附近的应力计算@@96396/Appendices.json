{"hands_on_practices": [{"introduction": "理解应力奇异性的解析形式是精确进行有限元分析的第一步。本练习将引导您从第一性原理出发，推导经典L形域（一种典型的重入角）中反平面剪切问题的奇异性指数。通过这个过程，您不仅能掌握奇异性分析的核心方法，还能深入理解奇异指数对解的$H^1$正则性的影响，这对于有限元法的适定性至关重要。[@problem_id:2602467]", "problem": "考虑一个二维L形弹性域中的反平面剪切问题，该弹性域在原点处有一个凹角。在该角点的一个足够小的邻域内，引入以该角点为中心的极坐标$\\left(r,\\theta\\right)$，使得该域局部上与一个内角为$\\omega = \\frac{3\\pi}{2}$弧度的楔形区域$\\left\\{(r,\\theta): r>0,\\ 0<\\theta<\\omega\\right\\}$重合。假设没有体力，且两个楔形面$\\theta=0$和$\\theta=\\omega$是无牵引力的。令面外位移为$w(r,\\theta)$，它满足反平面剪切的线性弹性平衡方程。\n\n1. 从反平面剪切的第一性原理出发，通过寻找一个分离变量形式$w_{\\text{sing}}(r,\\theta)=r^{\\lambda} f(\\theta)$并施加控制偏微分方程和边界条件，来推导角点附近的局部主导阶奇异行为。利用此方法得到确定容许指数$\\lambda$的特征方程，并计算最小的正指数。\n\n2. 利用最小正指数的值，论证应变能密度的局部可积性，并说明其对$w$在角点邻域内属于索伯列夫空间$H^{1}$的影响。\n\n最终答案只给出主导奇异指数$\\lambda$的精确值（无单位，不四舍五入）。任何关于$H^{1}$-正则性的讨论都应包含在您的解题过程中，而不是最终答案中。", "solution": "在反平面剪切中，位移形式为$u_{x}=0$, $u_{y}=0$, $u_{z}=w(x,y)$，唯一非零的柯西应力分量是剪切应力$\\tau_{xz}$和$\\tau_{yz}$。对于剪切模量为$G$的均匀、各向同性、线性弹性材料，其本构关系为$\\tau_{xz}=G\\,\\partial w/\\partial x$和$\\tau_{yz}=G\\,\\partial w/\\partial y$。在没有体力的情况下，静力平衡要求$\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}$，这可简化为\n$$\n\\frac{\\partial \\tau_{xz}}{\\partial x}+\\frac{\\partial \\tau_{yz}}{\\partial y}=0.\n$$\n代入本构关系，并利用$G$是常数这一事实，可得到面外位移的拉普拉斯方程：\n$$\n\\Delta w=0.\n$$\n在极坐标$\\left(r,\\theta\\right)$中，拉普拉斯算子变为\n$$\n\\Delta w=\\frac{\\partial^{2}w}{\\partial r^{2}}+\\frac{1}{r}\\frac{\\partial w}{\\partial r}+\\frac{1}{r^{2}}\\frac{\\partial^{2}w}{\\partial \\theta^{2}}.\n$$\n在楔形面$\\theta=0$和$\\theta=\\omega$上的无牵引力边界条件意味着那里的法向剪切应力为零。对于反平面剪切，在射线$\\theta=\\text{const}$上的无牵引力条件局部简化为\n$$\n\\frac{\\partial w}{\\partial n}=0\\quad\\Longleftrightarrow\\quad \\frac{1}{r}\\frac{\\partial w}{\\partial \\theta}=0\\quad\\text{on}\\ \\theta=0,\\ \\theta=\\omega.\n$$\n因此，边界条件变为\n$$\n\\frac{\\partial w}{\\partial \\theta}(r,0)=0,\\qquad \\frac{\\partial w}{\\partial \\theta}(r,\\omega)=0,\\qquad r>0.\n$$\n我们寻找一个形式如下的主导阶奇异项\n$$\nw_{\\text{sing}}(r,\\theta)=r^{\\lambda}f(\\theta),\\quad \\lambda>0.\n$$\n将其代入拉普拉斯方程，可得\n\\begin{align*}\n\\frac{\\partial w}{\\partial r}&=\\lambda r^{\\lambda-1}f(\\theta),\\\\\n\\frac{\\partial^{2}w}{\\partial r^{2}}&=\\lambda(\\lambda-1)r^{\\lambda-2}f(\\theta),\\\\\n\\frac{\\partial^{2}w}{\\partial \\theta^{2}}&=r^{\\lambda}f''(\\theta).\n\\end{align*}\n因此\n$$\n\\Delta w_{\\text{sing}}=r^{\\lambda-2}\\left[\\lambda(\\lambda-1)f(\\theta)+\\lambda f(\\theta)+f''(\\theta)\\right]=r^{\\lambda-2}\\left[f''(\\theta)+\\lambda^{2}f(\\theta)\\right]=0,\n$$\n所以$f$满足常微分方程\n$$\nf''(\\theta)+\\lambda^{2}f(\\theta)=0.\n$$\n其通解为\n$$\nf(\\theta)=A\\cos(\\lambda \\theta)+B\\sin(\\lambda \\theta).\n$$\n无牵引力边界条件转化为\n$$\n\\frac{\\partial w_{\\text{sing}}}{\\partial \\theta}(r,\\theta)=r^{\\lambda}f'(\\theta)=0\\quad \\text{at}\\ \\theta=0,\\ \\theta=\\omega.\n$$\n计算$f'(\\theta)=-A\\lambda \\sin(\\lambda \\theta)+B\\lambda \\cos(\\lambda \\theta)$。施加$f'(0)=0$可得\n$$\nf'(0)=B\\lambda=0\\quad\\Longrightarrow\\quad B=0.\n$$\n然后$f'(\\omega)=-A\\lambda \\sin(\\lambda \\omega)=0$。对于一个非平凡的角向形状（$A\\neq 0$），这意味着特征方程为\n$$\n\\sin(\\lambda \\omega)=0\\quad\\Longleftrightarrow\\quad \\lambda \\omega = m\\pi,\\quad m\\in \\mathbb{N}.\n$$\n因此，容许的奇异指数为\n$$\n\\lambda_{m}=\\frac{m\\pi}{\\omega},\\quad m=1,2,\\dots\n$$\n主导奇异指数是最小的正指数：\n$$\n\\lambda=\\frac{\\pi}{\\omega}.\n$$\n对于给定的凹角$\\omega=\\frac{3\\pi}{2}$，\n$$\n\\lambda=\\frac{\\pi}{\\frac{3\\pi}{2}}=\\frac{2}{3}.\n$$\n\n为讨论对$H^{1}$正则性的影响，注意到应力分量与$w$的梯度成正比，且当$r\\to 0$时，与奇异项相关的梯度大小表现为\n$$\n|\\nabla w_{\\text{sing}}|\\sim r^{\\lambda-1}\\quad\\text{as}\\ r\\to 0.\n$$\n局部应变能密度与$|\\nabla w|^{2}$成正比，因此角点附近的能量（在一个常数因子范围内）的标度行为如同\n$$\n\\int_{0}^{\\varepsilon}\\int_{0}^{\\omega}|\\nabla w_{\\text{sing}}|^{2}\\, r\\, d\\theta\\, dr\\ \\sim\\ \\int_{0}^{\\varepsilon}\\int_{0}^{\\omega} r^{2(\\lambda-1)}\\, r\\, d\\theta\\, dr\\ =\\ \\omega\\int_{0}^{\\varepsilon} r^{2\\lambda-1}\\, dr.\n$$\n这个积分在$r=0$处收敛当且仅当$2\\lambda-1>-1$，即$\\lambda>0$。由于$\\lambda=\\frac{2}{3}>0$，能量是有限的，因此位移$w$在角点周围局部地属于$H^{1}$空间。然而，由于$\\lambda<1$，应力$|\\nabla w|$在$r\\to 0$时像$r^{-1/3}$一样是无界的，这排除了在角点邻域内具有如$H^{2}$等更高的正则性。从有限元方法的角度来看，有限的能量意味着在$H^{1}$框架下的适定性，但应力奇异性使得必须对角点附近进行网格加密或富集，才能精确计算应力。", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "2602467"}, {"introduction": "在解析推导出奇异性的形式之后，下一步是评估现有的数值方法能否有效捕捉这种行为。本练习挑战您批判性地思考，为什么像“四分之一点单元”这样的常用技术在处理非标准奇异性（例如，指数不为$1/2$的角点奇异性或双材料界面裂纹的振荡奇异性）时会失效。通过评估一系列关于奇异单元、扩展有限元法（XFEM）和网格分级的论述，您将深化对处理奇异性问题的先进数值策略的理解。[@problem_id:2602499]", "problem": "考虑一个二维($2$D)线性弹性体，其在极坐标半径$r = 0$处包含一个尖锐的奇异点（例如，裂纹尖端或凹角）。在奇异点附近，已知精确位移场$u(r,\\theta)$是非光滑的，并且可能表现为指数$\\lambda \\neq 1/2$的代数奇异性（例如，楔形角），或具有对数调制的振荡行为（例如，双材料界面裂纹），导致应力场在$r \\to 0$时无界，但在线性弹性和材料稳定性的标准假设下，在应变能范数下保持平方可积。一种常见的有限元方法补救措施是使用等参奇异单元，将边中节点移动到四分之一点位置，以在近似中引入$1/\\sqrt{r}$型的应变奇异性。\n\n仅使用线性弹性的基本变分公式（从最小势能原理导出的弱形式）、等参映射的定义以及多项式形函数的逼近性质，分析四分之一点单元对于上述奇异性类别是否一致，如果不是，应采取何种修改或替代方案。选择所有正确的陈述。\n\nA. 对于任何代数奇异性指数$\\lambda \\in (0,1)$，四分之一点单元都是渐近最优的，因为等参映射会自动产生精确的应力爆破率，且与$\\lambda$无关。\n\nB. 如果奇异性指数满足$\\lambda \\neq 1/2$，则四分之一点单元与精确的局部行为不一致，并可能引发污染误差和伪振荡；使用具有可调指数的广义奇异映射（例如，将节点移动到非四分之一点的位置以强制$r \\sim \\xi^{1/\\lambda}$）或定制的奇异单元，可以在$\\lambda$已知或可估计的情况下恢复最优收敛性。\n\nC. 对于双材料界面裂纹，其主导奇异场在$r$上具有对数调制振荡，这是四分之一点单元无法表示的；通过单位分解框架（例如扩展有限元法 XFEM）添加包含振荡尖端行为的富集函数，是一种有效的替代方案。\n\nD. 使用标准多项式基的均匀$p$-加密（无网格分级、奇异映射或富集）总能消除在奇异点附近进行特殊处理的需要，因为足够高的多项式次数可以以最优精度逼近任何局部行为。\n\nE. 对于非振荡性代数奇异性，即使使用标准单元，尺寸按$h_k \\sim q^k$（其中$0<q<1$）递减的几何分级网格也可以在能量范数下恢复最优的代数收敛率；然而，仅靠这种分级无法捕捉振荡对数特征，这需要除分级之外的适当富集或定制的奇异函数。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 系统是一个二维($2$D)线性弹性体。\n- 在极坐标系原点($r=0$)处存在一个奇异点。\n- 考虑两类奇异性：\n    1. 指数为$\\lambda \\neq 1/2$的代数奇异性。\n    2. 具有对数调制的振荡奇异性，这是双材料界面裂纹的特征。\n- 应力场在$r \\to 0$时无界，但在应变能范数下保持平方可积。\n- 提出的一种有限元方法(FEM)技术是使用等参奇异单元，其边中节点被移动到四分之一点位置。\n- 该技术的效果据称是引入一个$1/\\sqrt{r}$型的应变奇异性。\n- 任务是基于变分公式、等参映射和多项式逼近理论，分析四分之一点单元对这些奇异性的一致性，并评估替代方案。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述在科学上是合理的且适定的。\n- **科学依据：** 该问题基于计算固体力学和有限元方法中的规范概念构建。对奇异性（角的代数奇异性，双材料裂纹的振荡奇异性）、应力场性质以及处理方法（四分之一点单元、富集、网格分级）的描述都是该学科中标准且符合事实的要素。\n- **适定性与客观性：** 该问题被构建为一个概念分析任务，要求根据既定理论评估几个技术陈述。术语精确且客观。问题是可回答的，没有歧义。它提供了进行严谨分析所需足够的信息。\n- **缺陷核查：** 问题陈述未违反任何无效性标准。它不基于错误的前提，是可形式化的、完整的，并在计算工程领域提出了一个有意义、非平凡的问题。\n\n**步骤3：结论与行动**\n问题有效。将进行全面分析。\n\n**原理推导**\n\n分析的基础是最小势能原理，它导出了线性弹性问题的弱（变分）形式。目标是从一个合适的索伯列夫空间（通常是$H^1(\\Omega)$）中找到一个满足变分方程的位移场$u$。有限元近似解$u_h$到精确解$u$的收敛性关键取决于$u$的正则性。\n\n在奇异点$r=0$附近，精确位移场允许以下形式的渐近展开：\n$$ u(r, \\theta) = u_{regular}(r, \\theta) + \\sum_{i=1}^{\\infty} K_i r^{\\lambda_i} f_i(\\theta) $$\n其中$u_{regular}$是一个光滑函数，$K_i$是广义应力强度因子，$\\lambda_i>0$是奇异性指数，其对应的角函数为$f_i(\\theta)$。应变张量$\\boldsymbol{\\varepsilon}$是$u$的对称梯度，其行为如同$\\boldsymbol{\\varepsilon} \\sim r^{\\lambda_{min}-1}$，其中$\\lambda_{min}$是最小的正指数。为了使能量范数有限（$||\\boldsymbol{\\varepsilon}||_{L^2} < \\infty$），我们必须有$\\lambda_{min} > 0$。\n\n对于均质、各向同性材料中的裂纹，$\\lambda_{min} = 1/2$。对于凹角（楔形问题），$\\lambda_{min}$是角点角度和边界条件的函数，通常$\\lambda_{min} \\neq 1/2$。对于双材料界面处的裂纹，指数是复数，$\\lambda_{min} = 1/2 \\pm i\\epsilon$，导致应力出现$\\sigma \\sim r^{-1/2} \\cos(\\epsilon \\ln r)$形式的振荡奇异性。\n\n标准的四分之一点单元是一种等参二次单元，其中边中节点从中点移动到最靠近奇异点的四分之一点。对于一个长度为$L$的一维单元，其节点位于$x=0$, $x=L/4$, 和$x=L$，从母单元坐标$\\xi \\in [-1, 1]$到物理坐标$x$（在$\\xi=-1$处$x=0$）的映射为：\n$$ x(\\xi) = N_1(\\xi) \\cdot 0 + N_2(\\xi) \\cdot \\frac{L}{4} + N_3(\\xi) \\cdot L $$\n其中$N_1$, $N_2$, $N_3$是标准的二次形函数。这可以简化为：\n$$ x(\\xi) = (1-\\xi^2)\\frac{L}{4} + \\frac{1}{2}\\xi(1+\\xi)L = \\frac{L}{4}(1+\\xi)^2 $$\n令$r=x$为距奇异点的距离，我们发现关系$r \\propto (1+\\xi)^2$，这意味着$(1+\\xi) \\propto \\sqrt{r}$。由于单元上的位移近似$u_h$是关于$\\xi$的二次多项式，它可以写成一个关于$(1+\\xi)$的多项式：$u_h(\\xi) = A_0 + A_1(1+\\xi) + A_2(1+\\xi)^2$。代入$r$的关系式，物理坐标中的位移近似为：\n$$ u_h(r) = A_0 + A_1' \\sqrt{r} + A_2' r $$\n相应的应变近似为$\\epsilon_h(r) = \\frac{du_h}{dr} = \\frac{A_1'}{2\\sqrt{r}} + A_2'$。因此，该映射硬编码了一种$r^{-1/2}$类型的应变奇异性，这恰好对应于$\\lambda = 1/2$的情况。\n\n**逐项分析**\n\nA. 对于任何代数奇异性指数$\\lambda \\in (0,1)$，四分之一点单元都是渐近最优的，因为等参映射会自动产生精确的应力爆破率，且与$\\lambda$无关。\n\n该陈述明显是错误的。如上所述，四分之一点单元是专门为产生$r^{-1/2}$应变奇异性而构造的，这对应于$\\lambda=1/2$。它不会“自动”适应任何其他指数$\\lambda$。如果真实的奇异性指数是$\\lambda \\neq 1/2$，四分之一点单元会对近似施加不正确的奇异行为，导致解场表示不佳和精度损失。该方法只对一个特定的指数是正确的，而不是与指数无关。\n结论：**不正确**。\n\nB. 如果奇异性指数满足$\\lambda \\neq 1/2$，则四分之一点单元与精确的局部行为不一致，并可能引发污染误差和伪振荡；使用具有可调指数的广义奇异映射（例如，将节点移动到非四分之一点的位置以强制$r \\sim \\xi^{1/\\lambda}$）或定制的奇异单元，可以在$\\lambda$已知或可估计的情况下恢复最优收敛性。\n\n这个陈述是正确的。第一部分正确地指出，对于$\\lambda \\neq 1/2$的问题使用四分之一点单元与物理行为不一致，并会导致污染误差，从而降低全局解的质量。第二部分提出了正确的补救措施。为了匹配$r^{\\lambda}$类型的奇异性，可以构建一个特殊的映射，使得$r \\propto (1+\\xi)^{1/\\lambda}$。这可以通过将边中节点放置在依赖于$\\lambda$的特定位置来实现，或者更一般地，通过构造其形函数明确包含$r^{\\lambda}$项的专用奇异单元来实现。如果主导的奇异行为被正确地嵌入到有限元基函数中，解在逼近量看来就变得“更光滑”，并且可以恢复有限元方法的最优收敛率。\n结论：**正确**。\n\nC. 对于双材料界面裂纹，其主导奇异场在$r$上具有对数调制振荡，这是四分之一点单元无法表示的；通过单位分解框架（例如扩展有限元法 XFEM）添加包含振荡尖端行为的富集函数，是一种有效的替代方案。\n\n这个陈述是正确的。双材料裂纹尖端附近的位移场涉及诸如$\\sqrt{r}\\cos(\\epsilon \\ln r)$和$\\sqrt{r}\\sin(\\epsilon \\ln r)$之类的项。四分之一点单元的逼近基由$\\sqrt{r}$的多项式组成，这些函数是非振荡的，从根本上无法表示对数项在$r \\to 0$时的无限快速振荡。所述的替代方案，XFEM，通过使用单位分解将标准多项式基乘以这些已知的振荡函数来解决这个问题。这丰富了逼近空间，使其能够准确地捕捉真实的渐近行为，而无需不切实际的细密网格。这是解决此类问题的最新技术方法。\n结论：**正确**。\n\nD. 使用标准多项式基的均匀$p$-加密（无网格分级、奇异映射或富集）总能消除在奇异点附近进行特殊处理的需要，因为足够高的多项式次数可以以最优精度逼近任何局部行为。\n\n这个陈述是不正确的。虽然$p$版本的有限元法非常强大，但在均匀应用时，它并不能“消除对奇异点进行特殊处理的需要”。对于正则性为$u \\in H^{1+\\lambda}$的解，均匀$p$-加密的收敛率是代数的，通常为$\\|u-u_h\\|_{E} \\le C p^{-2\\lambda}$。与$p$-方法对光滑（$C^\\infty$）解所能达到的指数收敛率$\\|u-u_h\\|_{E} \\le C e^{-\\gamma p}$相比，这是次优的。奇异性污染了近似解，并阻止该方法发挥其全部潜力。为了用$p$-FEM恢复指数收敛率，必须对奇异点使用几何网格加密。声称均匀加密就足够了是一个常见的误解。\n结论：**不正确**。\n\nE. 对于非振荡性代数奇异性，即使使用标准单元，尺寸按$h_k \\sim q^k$（其中$0<q<1$）递减的几何分级网格也可以在能量范数下恢复最优的代数收敛率；然而，仅靠这种分级无法捕捉振荡对数特征，这需要除分级之外的适当富集或定制的奇异函数。\n\n这个陈述是正确的，并提出了一个细致入微的观点。这是$h$-版本有限元法理论中的一个经典结果：对于非振荡奇异性（例如，$r^\\lambda$），朝向奇异点的几何网格分级允许标准多项式单元达到最优的代数收敛率，即$\\|u-u_h\\|_{E} \\le C h^{p}$，其中$p$是多项式次数，$h$是最大单元的特征尺寸。陈述的第二部分也是正确的。虽然对网格进行分级有助于定位和控制奇异性带来的误差，但这些小单元上的标准多项式形函数仍然不适合逼近像$\\cos(\\epsilon \\ln r)$这样高度振荡的函数。为了正确捕捉这种行为，基函数本身必须包含这种振荡分量，这正是富集方法（如选项C中所示）所提供的。因此，仅靠分级对于振荡奇异性是不够的。\n结论：**正确**。", "answer": "$$\\boxed{BCE}$$", "id": "2602499"}, {"introduction": "作为一名计算科学家或工程师，一项关键技能是从数值模拟结果中验证和提取理论预测的物理量。本练习将理论与计算实践紧密结合，要求您设计一个稳健的数值程序，从一系列在几何分级网格上得到的有限元计算误差数据中，反向估计出奇异性指数$\\lambda$。这个过程不仅能巩固您对收敛率理论的理解，还为您提供了处理和解释计算数据的宝贵实践经验。[@problem_id:2602428]", "problem": "考虑一个二维标量椭圆边值问题，该问题由多边形域上的泊松方程建模，该域具有一个内角大于 $\\pi$ 的单个凹角。经典正则性理论表明，在角点附近，精确解表现出 $u(r,\\theta) \\sim r^{\\lambda}\\phi(\\theta)$ 形式的奇性，其中 $r$ 是到角点的距离，$\\lambda \\in (0,1)$ 是由几何形状和边界条件决定的角点指数。在使用多项式次数为 $p$ 的连续分片多项式形函数的有限元（FE，Finite Element）方法中，能量范数误差受此奇性主导。在朝向角点进行几何加密的网格上，加密指数为 $\\beta > 0$（这意味着角点附近的有效分辨率比均匀细化增长得更快），经过充分检验的先验误差估计表明，能量范数误差的行为如下\n$$\n\\| \\nabla(u - u_h) \\|_{L^2(\\Omega)} \\approx C\\, h^{\\alpha}, \\quad \\alpha = \\min(p, \\beta \\lambda),\n$$\n对于角点附近足够小的特征网格尺寸 $h$ 和某个与网格无关的常数 $C>0$。对于线性单元，$p = 1$。目标是从在连续细化的加密网格上测量得到的一系列能量范数误差中，估计未知的角点指数 $\\lambda$。\n\n任务。设计并实现一个稳健的数值程序，在给定以下输入的情况下：\n- 角点附近的一系列特征网格尺寸 $h_k$，\n- 相应的测量能量范数误差 $e_k \\approx \\| \\nabla(u - u_h) \\|_{L^2(\\Omega)}$，\n- 已知的网格加密指数 $\\beta$，\n返回角点指数的估计值 $\\widehat{\\lambda}$。您的方法必须：\n1) 从基本模型 $e_k \\approx C\\, h_k^{\\alpha}$ 开始，对于线性单元（$p = 1$），$\\alpha = \\min(1, \\beta \\lambda)$，\n2) 转换到对数坐标，将收敛率 $\\alpha$ 识别为线性关系 $\\log(e_k) \\approx \\log C + \\alpha \\log(h_k)$ 中的斜率，\n3) 使用统计上合理且数值上稳健的策略，以减轻前渐近污染和轻度噪声的影响。具体而言，在所有后缀（最后 $m$ 个层级，$m \\ge 3$）中，选择一个既能最小化 $(\\log h, \\log e)$ 中最小二乘线性拟合的残差，又表现出稳定的成对斜率的后缀，然后使用从此后缀得到的斜率 $\\widehat{\\alpha}$，\n4) 通过设置 $\\widehat{\\alpha}_{\\text{clip}} = \\min(\\widehat{\\alpha}, 1)$ 来强制执行多项式次数饱和效应，\n5) 返回 $\\widehat{\\lambda} = \\widehat{\\alpha}_{\\text{clip}}/\\beta$。\n\n您的程序必须实现此过程，并将其应用于以下测试套件。每个测试用例按以下方式提供 $(\\beta, \\{h_k\\}, \\{e_k\\})$。所有数字都是无量纲的，没有物理单位。\n\n测试用例 1（理想情况，清晰的渐近区域）：\n- $\\beta = 1.5$，\n- $h = (0.2, 0.1, 0.05, 0.025, 0.0125)$，\n- $e = C h^{\\alpha}$，其中 $C = 2.0$ 且 $\\alpha = 0.75$。\n\n测试用例 2（多项式次数饱和，即 $\\beta \\lambda > 1$，因此观测到的速率为 $1$）：\n- $\\beta = 2.5$，\n- $h = (0.4, 0.2, 0.1, 0.05, 0.025)$，\n- $e = C h^{1}$，其中 $C = 0.5$。\n\n测试用例 3（粗糙层级存在前渐近污染，之后为纯净的幂律）：\n- $\\beta = 1.0$，\n- $h = (0.4, 0.2, 0.1, 0.05, 0.025)$，\n- $e = C h^{\\alpha}$，其中 $C = 1.3$ 且 $\\alpha = 0.33$，但前两个值被放大了 1.6 倍，即报告的序列为 $(1.6 C h_1^{\\alpha}, 1.6 C h_2^{\\alpha}, C h_3^{\\alpha}, C h_4^{\\alpha}, C h_5^{\\alpha})$。\n\n测试用例 4（轻度测量噪声）：\n- $\\beta = 1.2$，\n- $h = (0.3, 0.15, 0.075, 0.0375, 0.01875, 0.009375)$，\n- $e = C h^{\\alpha}$，其中 $C = 0.8$ 且 $\\alpha = 0.84$，逐元素乘以固定的扰动因子 $(1.02, 0.98, 1.01, 0.99, 1.00, 1.03)$。\n\n实施要求：\n- 对每个测试用例独立计算 $\\widehat{\\lambda}$。\n- 为确保稳健性，在选择后缀时，请在 $(\\log h, \\log e)$ 的小最小二乘残差与成对斜率的稳定性之间进行权衡；例如，您可以对候选后缀内局部斜率的较大变异性进行惩罚。\n- 最终输出结果表示为四舍五入到 3 位小数的数值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，按测试用例 1 到 4 的顺序排列。例如：$[0.123,0.456,0.789,0.321]$。", "solution": "所提出的问题是设计一个数值程序，用于在有限元方法（FEM）应用于带凹角的域上的泊松问题的背景下，估计角点奇性指数 $\\lambda$。该估计将利用一系列测量的能量范数误差 $e_k$ 来执行，这些误差对应于几何加密网格上的一系列特征网格尺寸 $h_k$。该程序必须能稳健地抵抗前渐近效应和测量噪声。\n\n此问题是有效的。它在科学上基于成熟的奇异问题有限元分析理论。其前提在事实上是合理的，目标定义明确，所提供的测试用例是数值上可能的情景。我们将继续进行所需程序的推导和实现。\n\n理论基础是误差能量范数的先验误差估计，对于线性有限元（$p=1$）和加密指数为 $\\beta$ 的几何加密网格，该估计由下式给出：\n$$\ne_h \\equiv \\| \\nabla(u - u_h) \\|_{L^2(\\Omega)} \\approx C h^{\\alpha}\n$$\n这里，$u$ 是精确解，$u_h$ 是有限元近似解，$h$ 是奇点附近的特征网格尺寸，$C$ 是一个与 $h$ 无关的常数。收敛率 $\\alpha$ 由形函数的多项式次数和经奇性调整的网格加密共同决定，取二者中的较小值：\n$$\n\\alpha = \\min(p, \\beta \\lambda) = \\min(1, \\beta \\lambda)\n$$\n我们的目标是从离散数据对 $(h_k, e_k)$（其中 $k=1, \\dots, N$）中估计 $\\lambda$。\n\n为从幂律关系中提取指数 $\\alpha$，我们通过对两边取自然对数，将方程转换为线性形式：\n$$\n\\ln(e_k) \\approx \\ln(C) + \\alpha \\ln(h_k)\n$$\n该方程具有 $y_k \\approx c + \\alpha x_k$ 的形式，其中 $y_k = \\ln(e_k)$，$x_k = \\ln(h_k)$，截距 $c = \\ln(C)$。收敛率 $\\alpha$ 是误差与网格尺寸的双对数图中直线的斜率。\n\n直接对所有数据点 $(x_k, y_k)$ 应用线性回归是幼稚的，因为数值数据常受污染。较粗的网格（较大的 $h_k$）可能不处于该理论成立的渐近区域内，并且所有测量值都可能受到微小扰动。问题要求采用稳健的程序来减轻这些问题。\n\n规定的稳健策略涉及分析数据序列的后缀。其基本原理是，对于较小的 $h_k$（对应于逐步细化网格序列中的最后条目），渐近误差估计更为准确。我们考虑所有长度 $m \\geq 3$ 的后缀，其中至少需要 3 个点才能进行最低限度的稳健统计分析（例如，计算成对斜率的标准差）。\n\n对于由最后 $m$ 个数据点组成的每个候选后缀，我们使用两个指标来评估其质量：\n1.  **拟合优度**：此指标衡量后缀中的点对线性模型的遵循程度。我们对后缀的 $(\\ln h, \\ln e)$ 数据执行线性最小二乘回归，以找到估计的斜率 $\\widehat{\\alpha}_m$ 和截距 $\\widehat{c}_m$。此拟合的质量通过均方根误差（RMSE）量化：\n    $$\n    R_m = \\sqrt{\\frac{1}{m} \\sum_{i=N-m+1}^{N} \\left( \\ln(e_i) - (\\widehat{\\alpha}_m \\ln(h_i) + \\widehat{c}_m) \\right)^2}\n    $$\n2.  **收敛率稳定性**：此指标衡量后缀内部收敛率的一致性。我们计算连续点之间的局部、成对斜率：\n    $$\n    s_i = \\frac{\\ln(e_{i+1}) - \\ln(e_i)}{\\ln(h_{i+1}) - \\ln(h_i)}\n    $$\n    对于后缀内的点 $i$ 和 $i+1$。然后，通过这些成对斜率的标准差 $V_m$ 来衡量稳定性。一个小的 $V_m$ 表明在后缀所包含的细化层级上，收敛率是稳定的。\n\n为了选择“最佳”后缀，我们必须平衡这两个标准。较小的均方根误差和较小的斜率标准差都是理想的。我们为每个长度为 $m$ 的后缀定义一个简单的、未加权的成本函数 $J_m$：\n$$\nJ_m = R_m + V_m\n$$\n最小化此成本函数的后缀被认为是渐进行为最可靠的表示。从此最佳后缀的线性拟合中得到的斜率 $\\widehat{\\alpha}$被选为收敛率的最佳估计值。\n\n一旦确定了最优速率 $\\widehat{\\alpha}$，我们必须考虑由基函数多项式次数施加的饱和效应。真实速率 $\\alpha$ 不能超过 $p=1$。因此，我们对估计的速率进行截断：\n$$\n\\widehat{\\alpha}_{\\text{clip}} = \\min(\\widehat{\\alpha}, 1.0)\n$$\n最后，我们反转关系式 $\\widehat{\\alpha}_{\\text{clip}} = \\beta \\widehat{\\lambda}$ 以求得奇性指数的估计值：\n$$\n\\widehat{\\lambda} = \\frac{\\widehat{\\alpha}_{\\text{clip}}}{\\beta}\n$$\n至此，稳健估计程序的设计完成。接下来的实现将把此逻辑应用于所提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not strictly necessary as numpy covers the needs.\n\ndef estimate_lambda(beta, h_values, e_values):\n    \"\"\"\n    Estimates the corner singularity exponent lambda from FE error data.\n\n    Args:\n        beta (float): The mesh grading exponent.\n        h_values (np.ndarray): A sequence of characteristic mesh sizes.\n        e_values (np.ndarray): A sequence of corresponding energy norm errors.\n\n    Returns:\n        float: The estimated singularity exponent lambda_hat.\n    \"\"\"\n    if len(h_values) < 3:\n        raise ValueError(\"At least 3 data points are required.\")\n\n    log_h = np.log(h_values)\n    log_e = np.log(e_values)\n\n    best_suffix_info = {\n        'cost': np.inf,\n        'alpha': np.nan,\n        'length': 0\n    }\n\n    n_points = len(h_values)\n    min_suffix_len = 3\n\n    # Iterate through all possible suffixes of length m >= 3\n    for m in range(min_suffix_len, n_points + 1):\n        # Extract the current suffix (last m points)\n        x_suffix = log_h[-m:]\n        y_suffix = log_e[-m:]\n\n        # 1. Perform linear least-squares regression\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        slope, intercept = np.polyfit(x_suffix, y_suffix, 1)\n\n        # 2. Calculate the Root Mean Squared Error (RMSE) of the fit\n        predictions = slope * x_suffix + intercept\n        residuals = y_suffix - predictions\n        rmse = np.sqrt(np.mean(residuals**2))\n\n        # 3. Calculate the stability of pairwise slopes\n        # Pairwise slopes are (y2-y1)/(x2-x1)\n        pairwise_slopes = (y_suffix[1:] - y_suffix[:-1]) / (x_suffix[1:] - x_suffix[:-1])\n        \n        # Standard deviation of pairwise slopes\n        slope_std_dev = np.std(pairwise_slopes)\n\n        # 4. Define and compute the cost function\n        cost = rmse + slope_std_dev\n        \n        # 5. Check if this is the best suffix found so far\n        if cost < best_suffix_info['cost']:\n            best_suffix_info['cost'] = cost\n            best_suffix_info['alpha'] = slope\n            best_suffix_info['length'] = m\n\n    # Extract the best estimate for alpha from the optimal suffix\n    alpha_hat = best_suffix_info['alpha']\n\n    # Enforce the polynomial-degree saturation: alpha <= p=1\n    alpha_clip = min(alpha_hat, 1.0)\n\n    # Compute the final estimate for lambda\n    lambda_hat = alpha_clip / beta\n\n    return lambda_hat\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the estimation for each, and prints the results.\n    \"\"\"\n    # Test case 1: Happy path, clear asymptotic regime\n    h1 = np.array([0.2, 0.1, 0.05, 0.025, 0.0125])\n    e1 = 2.0 * h1**0.75\n    case1 = (1.5, h1, e1)\n\n    # Test case 2: Saturation at polynomial degree\n    h2 = np.array([0.4, 0.2, 0.1, 0.05, 0.025])\n    e2 = 0.5 * h2**1.0\n    case2 = (2.5, h2, e2)\n\n    # Test case 3: Pre-asymptotic contamination\n    h3 = np.array([0.4, 0.2, 0.1, 0.05, 0.025])\n    e3_base = 1.3 * h3**0.33\n    e3_base[:2] *= 1.6  # Inflate the first two error values\n    case3 = (1.0, h3, e3_base)\n\n    # Test case 4: Mild measurement noise\n    h4 = np.array([0.3, 0.15, 0.075, 0.0375, 0.01875, 0.009375])\n    e4_base = 0.8 * h4**0.84\n    perturbations = np.array([1.02, 0.98, 1.01, 0.99, 1.00, 1.03])\n    e4 = e4_base * perturbations\n    case4 = (1.2, h4, e4)\n\n    test_cases = [case1, case2, case4]\n\n    results = []\n    for beta, h, e in test_cases:\n        lambda_estimate = estimate_lambda(beta, h, e)\n        results.append(lambda_estimate)\n\n    # Format the final output string as required.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2602428"}]}