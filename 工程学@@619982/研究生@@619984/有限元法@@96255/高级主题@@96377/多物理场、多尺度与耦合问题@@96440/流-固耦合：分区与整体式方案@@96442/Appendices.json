{"hands_on_practices": [{"introduction": "本节的第一个练习旨在揭开分区方案的神秘面纱。通过在一个简化的活塞模型上手动计算单个时间步，您将亲身体验信息（例如速度和压力）如何在流体和结构子问题之间交换。这个练习将帮助您对显式交错求解过程建立一个具体而深入的理解 [@problem_id:2560189]。", "problem": "一维管内活塞模型用于在分区设置下，通过有限元法（FEM）研究流固耦合（FSI）问题。结构部分为一个质量为 $m$ 的刚性活塞，连接到一个刚度为 $k$ 的线性弹簧和一个阻尼系数为 $c$ 的线性阻尼器上。活塞封住一根横截面积恒为 $A$ 的直管的一端，管内充满体积模量为 $K$、初始柱长为 $L_0$ 的可压缩流体。设 $u_s(t)$ 为活塞向管内的位移，规定指向流体方向为正。假设在一个时间步内，流体压力在空间上保持均匀，且管的远端是密封的。界面耦合强制要求活塞速度等于流体边界速度（运动学连续性），同时流体压力对活塞施加法向载荷（动力学平衡）。\n\n您将使用显式交错更新，在一个从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的单个时间步上，应用分区的 Dirichlet–Neumann (D–N) 算法：\n- 流体子步 (Dirichlet)：使用 $t^n$ 时刻的界面速度，运动学上预测在 $\\Delta t$ 时间内的界面运动，然后根据质量守恒和线性可压缩性确定 $t^{n+1}$ 时刻的流体压力。\n- 结构子步 (Neumann)：使用 Newton 第二定律，将 $t^{n+1}$ 时刻的流体压力作为外载荷，计算 $t^n$ 时刻的活塞加速度，然后使用与 $v=\\mathrm{d}u/\\mathrm{d}t$ 和 $a=\\mathrm{d}v/\\mathrm{d}t$ 一致的显式二阶运动学展开将活塞位移更新至 $t^{n+1}$。\n\n使用以下数据：\n- $m=10\\,\\mathrm{kg}$，$c=1000\\,\\mathrm{N\\,s/m}$，$k=10^6\\,\\mathrm{N/m}$，\n- $A=1.0\\times 10^{-2}\\,\\mathrm{m^2}$，$L_0=1.0\\,\\mathrm{m}$，$K=2.0\\times 10^9\\,\\mathrm{Pa}$，\n- $\\Delta t=1.0\\times 10^{-3}\\,\\mathrm{s}$，\n- $t^n$ 时刻的初始条件：$u_s^n=0$，$v_s^n=0.10\\,\\mathrm{m/s}$，\n- 表压参考压力 $p_0=0$，\n- 外部非流体载荷 $F_{\\mathrm{ext}}^n=0$。\n\n推导基于：\n- 运动学关系 $v=\\mathrm{d}u/\\mathrm{d}t$ 和 $a=\\mathrm{d}v/\\mathrm{d}t$，\n- 活塞的 Newton 第二定律，其中流体压力载荷作用于面积 $A$ 上，且方向与正 $u_s$ 相反，\n- 流体的线性可压缩性：压力增量满足 $\\Delta p=-K\\,\\Delta V/V_0$，其中 $V_0=A L_0$，由活塞运动引起的体积变化为 $\\Delta V=-A\\,u_s$。\n\n计算此单个 D–N 步产生的更新后的结构位移 $u_s^{n+1}$。将您的答案四舍五入至四位有效数字。最终答案以米为单位表示。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n首先，逐字提取所有给定条件。\n- 活塞质量：$m=10\\,\\mathrm{kg}$\n- 阻尼系数：$c=1000\\,\\mathrm{N\\,s/m}$\n- 弹簧刚度：$k=10^6\\,\\mathrm{N/m}$\n- 管的横截面积：$A=1.0\\times 10^{-2}\\,\\mathrm{m^2}$\n- 初始流体柱长度：$L_0=1.0\\,\\mathrm{m}$\n- 流体体积模量：$K=2.0\\times 10^9\\,\\mathrm{Pa}$\n- 时间步长：$\\Delta t=1.0\\times 10^{-3}\\,\\mathrm{s}$\n- $t^n$ 时刻的初始位移：$u_s^n=0$\n- $t^n$ 时刻的初始速度：$v_s^n=0.10\\,\\mathrm{m/s}$\n- 表压参考压力：$p_0=0$\n- $t^n$ 时刻的外部非流体载荷：$F_{\\mathrm{ext}}^n=0$\n- 运动学关系：$v=\\mathrm{d}u/\\mathrm{d}t$，$a=\\mathrm{d}v/\\mathrm{d}t$\n- 活塞的运动方程：Newton 第二定律，流体压力载荷为 $-pA$。\n- 流体可压缩性定律：$\\Delta p=-K\\,\\Delta V/V_0$，其中 $V_0=A L_0$ 且 $\\Delta V=-A\\,u_s$。\n- 算法：一种特定的分区 Dirichlet–Neumann (D–N) 显式交错格式。\n\n根据所需标准对问题进行验证。\n- **科学基础和客观性**：该问题描述了一个标准的、简化的流固耦合模型，该模型基于力学的基本原理（Newton 第二定律）和流体动力学（线性可压缩性）。诸如空间均匀流体压力之类的假设是明确说明的简化，是入门模型的典型特征，不构成科学缺陷。该问题以客观、明确的语言提出。\n- **适定性**：该问题是自洽的，提供了所有必要的数据、初始条件和一个明确定义的算法，以计算指定时间步的唯一解。\n- **一致性**：所有提供的数据在量纲上都是一致的。该模型在逻辑上是连贯的。\n- **相关性**：该问题与流固耦合和有限元法的主题直接相关，特别是涉及分区求解格式。\n\n结论：该问题被认为是有效且可解的。现在将推导求解过程。\n\n求解过程是执行规定的分区 Dirichlet–Neumann 算法从时间 $t^n$ 到 $t^{n+1}$ 的单个步骤。该算法包括两个子步。\n\n**子步 1：流体子步 (Dirichlet 预测)**\n\n在此子步中，我们基于对活塞运动的运动学预测来预测 $t^{n+1}$ 时刻的流体压力。\n压力-位移关系由线性可压缩性定律推导得出。问题陈述暗示了一个总压力公式 $p = p_0 + (K/L_0) u_s$。让我们从增量形式 $\\Delta p = -K \\Delta V / V_0$ 来验证这一点。从初始状态 $(u_s=0, V=V_0)$ 到位移为 $u_s$ 的状态，体积变化为 $\\Delta V = V - V_0 = A(L_0 - u_s) - A L_0 = -A u_s$。相应的压力变化为 $\\Delta p = p - p_0$。因此，$p - p_0 = -K(-A u_s) / (A L_0) = K u_s / L_0$。在给定的表压参考压力 $p_0=0$ 的条件下，流体压力与活塞位移成正比：\n$$p(t) = \\frac{K}{L_0} u_s(t)$$\n该算法要求使用 $t^n$ 时刻的界面速度来预测界面运动。我们对 $t^{n+1}$ 时刻的位移进行一阶显式预测，记为 $\\tilde{u}_s^{n+1}$：\n$$\\tilde{u}_s^{n+1} = u_s^n + v_s^n \\Delta t$$\n使用给定的初始条件 $u_s^n = 0$，$v_s^n=0.10\\,\\mathrm{m/s}$ 和 $\\Delta t=1.0\\times 10^{-3}\\,\\mathrm{s}$：\n$$\\tilde{u}_s^{n+1} = 0 + (0.10\\,\\mathrm{m/s}) (1.0\\times 10^{-3}\\,\\mathrm{s}) = 1.0\\times 10^{-4}\\,\\mathrm{m}$$\n这个预测的位移被用作流体子问题的 Dirichlet 边界条件，以求出 $t^{n+1}$ 时刻的压力：\n$$p^{n+1} = \\frac{K}{L_0} \\tilde{u}_s^{n+1}$$\n代入数值 $K=2.0\\times 10^9\\,\\mathrm{Pa}$ 和 $L_0=1.0\\,\\mathrm{m}$：\n$$p^{n+1} = \\frac{2.0\\times 10^9\\,\\mathrm{Pa}}{1.0\\,\\mathrm{m}} (1.0\\times 10^{-4}\\,\\mathrm{m}) = 2.0\\times 10^5\\,\\mathrm{Pa}$$\n该压力将在下一个子步中作为载荷施加到结构上。\n\n**子步 2：结构子步 (Neumann 更新)**\n\n在此子步中，我们计算结构响应。活塞（结构）的运动方程由 Newton 第二定律给出：\n$$m a_s(t) + c v_s(t) + k u_s(t) = F_{\\mathrm{ext}}(t) - p(t) A$$\n其中 $a_s(t)$ 是加速度。该算法指定使用流体压力 $p^{n+1}$ 来计算 $t^n$ 时刻的加速度。结构的状态变量（$u_s^n$，$v_s^n$）取自 $t^n$ 时刻：\n$$m a_s^n = F_{\\mathrm{ext}}^n - p^{n+1} A - c v_s^n - k u_s^n$$\n我们求解加速度 $a_s^n$：\n$$a_s^n = \\frac{1}{m} (F_{\\mathrm{ext}}^n - p^{n+1} A - c v_s^n - k u_s^n)$$\n代入给定值：$m=10\\,\\mathrm{kg}$，$F_{\\mathrm{ext}}^n=0$，$p^{n+1}=2.0\\times 10^5\\,\\mathrm{Pa}$，$A=1.0\\times 10^{-2}\\,\\mathrm{m^2}$，$c=1000\\,\\mathrm{N\\,s/m}$，$v_s^n=0.10\\,\\mathrm{m/s}$，$k=10^6\\,\\mathrm{N/m}$ 和 $u_s^n=0$：\n$$a_s^n = \\frac{1}{10} \\left( 0 - (2.0\\times 10^5)(1.0\\times 10^{-2}) - (1000)(0.10) - (10^6)(0) \\right)$$\n$$a_s^n = \\frac{1}{10} \\left( -2000 - 100 - 0 \\right) = \\frac{-2100}{10} = -210\\,\\mathrm{m/s^2}$$\n接下来，我们使用指定的显式二阶运动学展式将活塞位移更新至 $t^{n+1}$，这是 $u_s(t)$ 在 $t^n$ 附近的泰勒级数展开：\n$$u_s^{n+1} = u_s^n + v_s^n \\Delta t + \\frac{1}{2} a_s^n (\\Delta t)^2$$\n代入已知和计算出的值：\n$$u_s^{n+1} = 0 + (0.10\\,\\mathrm{m/s})(1.0\\times 10^{-3}\\,\\mathrm{s}) + \\frac{1}{2}(-210\\,\\mathrm{m/s^2})(1.0\\times 10^{-3}\\,\\mathrm{s})^2$$\n$$u_s^{n+1} = 1.0\\times 10^{-4} + \\frac{1}{2}(-210)(1.0\\times 10^{-6})$$\n$$u_s^{n+1} = 1.0\\times 10^{-4} - 105 \\times 1.0\\times 10^{-6}$$\n$$u_s^{n+1} = 1.0\\times 10^{-4} - 1.05\\times 10^{-4}$$\n$$u_s^{n+1} = -0.05\\times 10^{-4}\\,\\mathrm{m} = -5.0\\times 10^{-6}\\,\\mathrm{m}$$\n问题要求答案四舍五入到四位有效数字。\n$$u_s^{n+1} = -5.000\\times 10^{-6}\\,\\mathrm{m}$$\n这是一步 D–N 算法后更新的结构位移。", "answer": "$$\n\\boxed{-5.000 \\times 10^{-6}}\n$$", "id": "2560189"}, {"introduction": "在理解了显式分步的基本机制后，我们现在来研究一个关键挑战：附加质量不稳定性。本编码练习使用冯·诺依曼 ($von\\ Neumann$) 稳定性分析来量化简单狄利克雷-诺依曼 ($Dirichlet–Neumann$) 方案的不稳定性，并展示了基于阻抗的罗宾-罗宾 ($Robin–Robin$) 方案如何恢复稳定性。这是一堂关于诊断和解决流固耦合核心数值问题的实践课 [@problem_id:2560166]。", "problem": "实现一个程序，用于计算一个简单的一维流固耦合 (FSI) 模型在两种分区耦合策略下的线性放大因子，并在一个指定的测试套件上汇总结果。背景设定是以下用于研究界面附加质量效应的简化和典型模型：\n\n- 结构被建模为一个质量为 $m_s$ 的质点，连接到一个刚度为 $k$ 的线性弹簧上，其位移 $x(t)$ 遵循牛顿第二定律。\n- 与结构相邻的流体柱被建模为一个长度为 $L$、密度为 $\\rho_f$ 的不可压缩、刚性横截面的流体柱，产生附加质量效应，对结构施加一个力 $F_f(t)$，该力与界面加速度 $a(t) = \\ddot{x}(t)$ 成正比。\n- 附加质量为 $m_a = \\rho_f A L$，其中 $A$ 是横截面积。流体力为 $F_f(t) = - m_a a(t)$。\n- 通过将结构和流体合并到单个方程中得到的精确整体式常微分方程为 $(m_s + m_a) \\ddot{x}(t) + k x(t) = 0$，该方程是线性稳定的。\n\n为研究分区时间积分效应，使用一个均匀的时间步长 $\\Delta t$ 和加速度的中心差分近似：\n$$ a^n = \\frac{x^{n} - 2 x^{n-1} + x^{n-2}}{\\Delta t^2}, $$\n其中 $x^n \\approx x(t^n)$ 且 $t^n = n \\Delta t$。\n\n定义以下无量纲参数：\n- 质量比 $\\mu = \\dfrac{m_a}{m_s}$。\n- 无量纲结构刚度 $r = \\dfrac{k \\Delta t^2}{m_s}$。\n\n考虑以下两种用于推进结构求解的分区耦合方案：\n\n1. 狄利克雷-诺依曼 (Dirichlet–Neumann, DN) 显式附加质量滞后：\n   - 结构步使用前一个时间层级的流体力。离散结构方程为\n     $$ m_s a^n + k x^{n-1} = - F_f^{n-1}, $$\n     而在获得新位移后，流体计算 $F_f^{n} = - m_a a^n$。这些步骤的组合导致了关于 $x^n$ 的齐次递推关系。\n\n2. 基于阻抗的罗宾-罗宾 (Robin–Robin, RR) 稳定化，带有惯性分裂：\n   - 引入一个罗宾分裂参数 $\\alpha \\in [0,1]$，它将一部分附加惯量隐式地分配给结构，其余部分则显式地作为流体滞后项，得到\n     $$ (m_s + \\alpha m_a) a^n + k x^{n-1} = - (1 - \\alpha) m_a a^{n-1}. $$\n   - 对于一个平衡了结构和流体惯性效应的基于阻抗的选择，设置\n     $$ \\alpha^\\star = \\frac{\\mu}{1 + \\mu}. $$\n   - 这一选择的动机是匹配惯性阻抗，从而使附加惯量的隐式部分与流固惯量比成比例，以减轻附加质量不稳定性。\n\n通过将中心差分公式代入 DN 和 RR 方程，并用 $m_s$ 进行无量纲化，两种方案都可简化为以下形式的线性齐次递推关系：\n$$ a_3 g^3 + a_2 g^2 + a_1 g + a_0 = 0, $$\n在模态假设 $x^n = C g^n$ 下，其中 $g$ 是放大因子。系数如下：\n- 对于 DN (设置 $\\alpha = 0$):\n  $$ a_3 = 1, \\quad a_2 = -2 + r + \\mu, \\quad a_1 = 1 - 2 \\mu, \\quad a_0 = \\mu. $$\n- 对于具有通用 $\\alpha$ 的 RR:\n  $$ a_3 = 1 + \\alpha \\mu, \\quad a_2 = -2 + r + \\mu - 3 \\alpha \\mu, \\quad a_1 = 1 - 2 \\mu + 3 \\alpha \\mu, \\quad a_0 = (1 - \\alpha) \\mu. $$\n设置基于阻抗的选择 $\\alpha = \\alpha^\\star = \\dfrac{\\mu}{1 + \\mu}$ 以获得本问题中使用的 RR 方案。\n\n你的任务是：\n- 实现一个程序，对下面列出的每个测试用例 $(\\mu, r)$，构建 DN 和 RR 相应的特征多项式，计算所有根 $g$，并报告每个方案的谱半径 $\\rho = \\max_i |g_i|$。\n- 使用浮点运算，并以标准双精度计算谱半径。\n- 输出单行内容，包含所有测试用例的谱半径的扁平列表，按指定的确切顺序排列，每个测试用例的 DN 和 RR 结果交错排列。\n\n本问题中没有物理单位输出，因为所有参数在构造上都是无量纲的。所有角度（如有）在此不适用。所有输出都是实值浮点数。\n\n测试套件（四个测试用例）：\n- 用例 1：$\\mu = 0.01$，$r = 0.5$。\n- 用例 2：$\\mu = 5.0$，$r = 0.1$。\n- 用例 3：$\\mu = 10.0$，$r = 0.0$。\n- 用例 4：$\\mu = 1.0$，$r = 3.9$。\n\n最终输出格式：\n- 你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[$\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6,\\text{result}_7,\\text{result}_8$]”），其中，对于每个用例，你首先列出 Dirichlet–Neumann 谱半径，然后是使用 $\\alpha^\\star = \\dfrac{\\mu}{1 + \\mu}$ 计算的 Robin–Robin 谱半径。", "solution": "所提出的问题是一个标准的 von Neumann 稳定性分析，应用于一个典型的一维流固耦合 (FSI)模型的分区时间积分方案。目标是计算两种不同分区方案（即 Dirichlet–Neumann (DN) 方案和 Robin–Robin (RR) 方案）的数值放大因子的谱半径。该问题是适定的、科学上合理的且内部一致的。我们将进行推导和求解。\n\n该系统由一个位于刚度为 $k$ 的弹簧上的结构质量 $m_s$，以及一个附加质量为 $m_a$ 的流体组成。流体施加在结构上的力由 $F_f(t) = -m_a \\ddot{x}(t)$ 给出。结构的运动方程是 $m_s \\ddot{x}(t) + k x(t) = F_f(t)$。为了进行数值求解，我们考虑离散时间 $t^n = n \\Delta t$。\n\n问题中提供的最通用的离散方程是针对 RR 方案的，我们基于力的分区的一致性表述对其进行重写。总流体力 $F_f$ 被分为隐式部分（在时间层级 $n$ 处理）和显式部分（在时间层级 $n-1$ 滞后）。\n$F_f \\approx -\\alpha m_a a^n - (1-\\alpha) m_a a^{n-1}$\n离散化的运动方程 $m_s a^n = -k x_{discrete} + F_f$ 变为\n$m_s a^n = -k x^{n-1} -\\alpha m_a a^n - (1-\\alpha) m_a a^{n-1}$\n其中弹簧力也通过 $x^{n-1}$ 进行了显式滞后。重新整理各项，得到以下线性多步公式：\n$$ (m_s + \\alpha m_a) a^n + (1-\\alpha) m_a a^{n-1} + k x^{n-1} = 0 $$\n这种形式正确地模拟了惯性分裂，并且与提供的特征多项式系数一致。DN 方案是该公式在 $\\alpha=0$ 时的特例。\n\n我们通过将加速度的中心差分近似\n$$ a^k = \\frac{x^k - 2x^{k-1} + x^{k-2}}{\\Delta t^2} $$\n和模态假设 $x^n = C g^n$ 代入离散运动方程，来进行 von Neumann 稳定性分析。此处，$g \\in \\mathbb{C}$ 是放大因子。将中心差分代入整理后的方程，得到：\n$$ (m_s + \\alpha m_a) \\frac{x^n - 2x^{n-1} + x^{n-2}}{\\Delta t^2} + (1-\\alpha) m_a \\frac{x^{n-1} - 2x^{n-2} + x^{n-3}}{\\Delta t^2} + k x^{n-1} = 0 $$\n我们除以 $m_s$ 并乘以 $\\Delta t^2$，引入无量纲质量比 $\\mu = m_a/m_s$ 和刚度 $r = k \\Delta t^2/m_s$：\n$$ (1 + \\alpha \\mu) (x^n - 2x^{n-1} + x^{n-2}) + (1-\\alpha) \\mu (x^{n-1} - 2x^{n-2} + x^{n-3}) + r x^{n-1} = 0 $$\n现在，我们代入假设 $x^k = C g^k$ 并将整个方程除以 $C g^{n-3}$：\n$$ (1 + \\alpha \\mu) (g^3 - 2g^2 + g) + (1-\\alpha) \\mu (g^2 - 2g + 1) + r g^2 = 0 $$\n按 $g$ 的幂次合并各项，得到特征多项式 $a_3 g^3 + a_2 g^2 + a_1 g + a_0 = 0$：\n- $g^3$: $a_3 = 1 + \\alpha \\mu$\n- $g^2$: $a_2 = -2(1 + \\alpha \\mu) + (1-\\alpha)\\mu + r = -2 - 2\\alpha\\mu + \\mu - \\alpha\\mu + r = -2 + r + \\mu - 3\\alpha\\mu$\n- $g^1$: $a_1 = (1 + \\alpha \\mu) - 2(1-\\alpha)\\mu = 1 + \\alpha\\mu - 2\\mu + 2\\alpha\\mu = 1 - 2\\mu + 3\\alpha\\mu$\n- $g^0$: $a_0 = (1-\\alpha)\\mu$\n\n这些系数与问题描述中提供的系数完全匹配，证实了我们公式的一致性。方案的稳定性由其谱半径 $\\rho = \\max_i |g_i|$ 决定，其中 $\\{g_i\\}$ 是特征多项式的根。如果 $\\rho \\le 1$，则该方案是稳定的。\n\n解决该问题的算法如下：\n1. 对于每个测试用例 $(\\mu, r)$，我们定义要分析的两种方案。\n2. DN 方案对应于设置参数 $\\alpha = 0$。其特征多项式的系数使用通用公式和该 $\\alpha$ 值计算。\n3. 基于阻抗的 RR 方案使用特定参数 $\\alpha = \\alpha^\\star = \\dfrac{\\mu}{1 + \\mu}$。其特征多项式的系数使用通用公式和该 $\\alpha$ 值计算。\n4. 对于这两个多项式中的每一个，我们使用数值求根算法计算其三个复数根 $\\{g_1, g_2, g_3\\}$。\n5. 然后计算每个方案的谱半径 $\\rho$ 为这些根的绝对值的最大值：$\\rho = \\max(|g_1|, |g_2|, |g_3|)$。\n6. 结果按指定顺序汇总：对于每个用例，先列出 DN 谱半径，然后列出 RR 谱半径。\n\n将对四个给定的测试用例实施此过程。所有计算均使用浮点运算执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral radius for two partitioned FSI coupling schemes\n    over a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (mu, r)\n        (0.01, 0.5),\n        (5.0, 0.1),\n        (10.0, 0.0),\n        (1.0, 3.9),\n    ]\n\n    results = []\n\n    def calculate_spectral_radius(mu, r, alpha):\n        \"\"\"\n        Calculates the spectral radius for a given set of nondimensional\n        parameters (mu, r) and a Robin split parameter (alpha).\n\n        The characteristic polynomial is a_3*g^3 + a_2*g^2 + a_1*g + a_0 = 0.\n        \"\"\"\n        # Coefficients for the general Robin-Robin scheme\n        a3 = 1.0 + alpha * mu\n        a2 = -2.0 + r + mu - 3.0 * alpha * mu\n        a1 = 1.0 - 2.0 * mu + 3.0 * alpha * mu\n        a0 = (1.0 - alpha) * mu\n\n        # The coefficients must be in order of decreasing power for numpy.roots\n        coeffs = [a3, a2, a1, a0]\n        \n        # Find the roots of the characteristic polynomial\n        roots = np.roots(coeffs)\n        \n        # The spectral radius is the maximum of the absolute values of the roots\n        spectral_radius = np.max(np.abs(roots))\n        \n        return spectral_radius\n\n    for mu, r in test_cases:\n        # Case 1: Dirichlet-Neumann (DN) scheme\n        # This is equivalent to the Robin-Robin scheme with alpha = 0\n        alpha_dn = 0.0\n        rho_dn = calculate_spectral_radius(mu, r, alpha_dn)\n        results.append(rho_dn)\n        \n        # Case 2: Impedance-based Robin-Robin (RR) scheme\n        # This uses the specified stabilization parameter alpha_star\n        alpha_rr = mu / (1.0 + mu)\n        rho_rr = calculate_spectral_radius(mu, r, alpha_rr)\n        results.append(rho_rr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2560166"}, {"introduction": "真实的流固耦合仿真通常会为流体和固体域使用不同的、不匹配的网格。最后一个练习将解决在这些网格之间传递力，同时不违反牛顿第三定律等基本物理法则的关键任务。通过实现一个守恒的映射方案，您将验证作用力与反作用力是否完美平衡，这是任何稳健的分区求解器的基石 [@problem_id:2560143]。", "problem": "考虑一个由区间 $\\Gamma = [0,1]$ 表示的一维流固耦合界面。流体侧沿 $\\Gamma$ 提供一个给定的牵引力场 $t_f(s)$，其中 $s \\in [0,1]$ 是界面坐标。流体和固体界面使用不匹配的节点集，通过分段线性有限元进行独立离散化。设流体界面网格有 $n_f$ 个单元，节点位于 $\\{x_i^f\\}_{i=0}^{n_f}$；固体界面网格有 $n_s$ 个单元，节点位于 $\\{x_j^s\\}_{j=0}^{n_s}$，且 $x_0^f = x_0^s = 0$ 和 $x_{n_f}^f = x_{n_s}^s = 1$。每一侧在其单元上使用标准的线性形函数，这些形函数在每个单元上满足单位分解特性。\n\n根据牛顿第三定律（作用力-反作用力），流体施加在固体界面上的牵引力与固体施加在流体界面上的牵引力大小相等、方向相反。在有限元法（FEM）中，以弱形式强制实现这种平衡的守恒离散界面载荷向量由一致性载荷组装定义：\n- 对固体而言：$\\mathbf{f}_s = \\int_{\\Gamma} \\mathbf{N}_s^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$，其中 $\\mathbf{N}_s$ 汇集了与固体界面节点相关联的固体侧形函数。\n- 对流体而言：$\\mathbf{f}_f = -\\int_{\\Gamma} \\mathbf{N}_f^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$，其中 $\\mathbf{N}_f$ 汇集了与流体界面节点相关联的流体侧形函数。\n\n在不匹配网格上的守恒分区传递方案需要在流体单元和固体单元的精确重叠区域上计算这些积分。实现这一目标的一种鲁棒方法是，将 $\\Gamma$ 分割成由所有流体单元和固体单元的成对交集定义的子分段集合，并在组装 $\\mathbf{f}_s$ 和 $\\mathbf{f}_f$ 时，在每个子分段上应用相同的高斯求积。由于线性形函数满足单位分解特性，当在每个子分段上对两侧使用相同的求积方法时，就能实现总力的守恒。\n\n你的任务是实现这种守恒的牵引力传递方案，并对几个测试用例进行数值验证以确认其守恒性。具体要求如下：\n\n- 在不匹配的网格上实现 $\\mathbf{f}_s$ 和 $\\mathbf{f}_f$ 的组装，方法如下：\n  - 通过流体和固体网格在 $\\Gamma$ 上的单元交集来构建覆盖网格。\n  - 在每个非空交集子分段 $[a,b] \\subset \\Gamma$ 上，应用 $n_q = 3$ 点的高斯-勒让德求积，其求积点和权重从 $[-1,1]$ 映射到 $[a,b]$。\n  - 在每个求积点 $s_q \\in [a,b]$，计算 $t_f(s_q)$ 以及包含 $s_q$ 的各自单元上的活动流体和固体线性形函数。\n  - 使用相同的求积权重，并根据上文指定的符号，将贡献累加到 $\\mathbf{f}_s$ 和 $\\mathbf{f}_f$ 中。\n\n- 通过计算标量总和 $F_s = \\sum_k (\\mathbf{f}_s)_k$ 和 $F_f = \\sum_\\ell (\\mathbf{f}_f)_\\ell$，并检查是否满足 $|F_s + F_f| \\le \\tau$ 来验证守恒性，其中 $\\tau$ 是代表求解器容差的数值容差。使用 $\\tau = 10^{-12}$。\n\n- 将具有匹配均匀节点的 $n_f = n_s$ 情况解释为整体式方案（共享界面网格）的替代。在这种情况下，相同的组装方法仍然适用，并且也应满足相同的守恒容差。\n\n使用以下测试套件。对于每个测试用例，$t_f(s)$ 是在流体侧给定的标量牵引力场，且网格是均匀的：\n- 测试 1（匹配网格，类整体式）：$n_f = 8$, $n_s = 8$, $t_f(s) = 3.5 + 1.0\\, s$ for $s \\in [0,1]$。\n- 测试 2（不匹配网格，恒定牵引力）：$n_f = 5$, $n_s = 7$, $t_f(s) = 5.0$ for $s \\in [0,1]$。\n- 测试 3（高度不匹配，从粗到细）：$n_f = 2$, $n_s = 19$, $t_f(s) = 2.0 + 3.0\\, s$ for $s \\in [0,1]$。\n- 测试 4（不匹配，振荡牵引力）：$n_f = 17$, $n_s = 13$, $t_f(s) = 0.2 + \\sin(6\\pi s)$ for $s \\in [0,1]$。\n- 测试 5（边界情况，一侧非常粗糙）：$n_f = 1$, $n_s = 50$, $t_f(s) = \\sin(2\\pi s)$ for $s \\in [0,1]$。\n\n你的程序必须：\n- 在每个交集子分段上使用 $n_q = 3$ 个高斯-勒让德点，实现上述的守恒组装。\n- 对每个测试用例，计算布尔结果 $b = \\left(|F_s + F_f| \\le \\tau\\right)$，其中 $\\tau = 10^{-12}$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[True,False,True,True,False]”）。不应打印任何其他文本。\n\n没有外部输入。所有量均为无量纲。输出仅包含布尔值；因此，输出中不需要也不允许使用物理单位。", "solution": "问题陈述提出了一个在流固耦合背景下验证不匹配网格间力传递方案的数值守恒性的任务。在继续之前，有必要进行一项关键的验证。该问题在数学上是适定的，并且在算法上有足够详细的说明。然而，所提供的物理依据中存在一个微小的不精确之处。陈述“物理上正确的耦合条件是在 $\\Gamma$ 上有 $t_s(s) = -t_f(s)$，其中 $t_s$ 是作用在固体上的牵引力”与标准惯例相反。如果 $t_f(s)$ 是流体施加在界面上的牵引力，那么固体感受到的牵引力恰好是 $t_s(s) = t_f(s)$。而固体施加在流体上的反作用力则是 $-t_f(s)$。\n\n幸运的是，随后离散力向量的定义在物理上是正确且明确的：\n- 固体力向量：$\\mathbf{f}_s = \\int_{\\Gamma} \\mathbf{N}_s^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$。这正确定地义了固体上的载荷是由流体牵引力 $t_f(s)$ 引起的。\n- 流体力向量：$\\mathbf{f}_f = -\\int_{\\Gamma} \\mathbf{N}_f^\\top(s)\\, t_f(s)\\, \\mathrm{d}s$。这正确定地义了流体上的载荷是反作用力 $-t_f(s)$。\n\n这些积分定义为本任务提供了合理且充分的基础。我们注意到了那个有缺陷的引言句，但它并不影响这个定义明确的数学问题。我们将基于这些正确的积分公式继续进行。\n\n待验证的核心原理是有限元形函数单位分解性质的一个直接推论。作用在固体界面上的总力 $F_s$ 是 $\\mathbf{f}_s$ 中所有节点力的总和：\n$$ F_s = \\sum_j (\\mathbf{f}_s)_j = \\sum_j \\int_{\\Gamma} N_{s,j}(s) \\, t_f(s) \\, \\mathrm{d}s $$\n根据积分的线性性质，我们可以交换求和与积分的顺序：\n$$ F_s = \\int_{\\Gamma} \\left( \\sum_j N_{s,j}(s) \\right) t_f(s) \\, \\mathrm{d}s $$\n固体网格的所有形函数集合 $\\{N_{s,j}(s)\\}$ 构成一个单位分解，这意味着在 $\\Gamma$ 上的任意点 $s$，它们的和都等于 1。因此，$\\sum_j N_{s,j}(s) = 1$。固体上总力的表达式简化为总施加载荷：\n$$ F_s = \\int_{\\Gamma} t_f(s) \\, \\mathrm{d}s $$\n对流体侧进行类似的推导，得到总力 $F_f$：\n$$ F_f = \\sum_i (\\mathbf{f}_f)_i = \\sum_i \\left( -\\int_{\\Gamma} N_{f,i}(s) \\, t_f(s) \\, \\mathrm{d}s \\right) = - \\int_{\\Gamma} \\left( \\sum_i N_{f,i}(s) \\right) t_f(s) \\, \\mathrm{d}s $$\n流体形函数也构成一个单位分解，$\\sum_i N_{f,i}(s) = 1$，这导致：\n$$ F_f = - \\int_{\\Gamma} t_f(s) \\, \\mathrm{d}s $$\n从解析上讲，总力是完全平衡的：$F_s + F_f = 0$。\n\n任务是验证所提出的数值方案是否保持了这种守恒特性。该方案的基础是通过叠加流体和固体网格来创建一个公共计算网格。区间 $\\Gamma = [0,1]$ 被分解为一组不相交的子分段 $\\{I_k\\}_{k=1}^M$，其中每个 $I_k = [a_k, b_k]$ 是一个流体单元和一个固体单元的非空交集。\n\n$\\mathbf{f}_s$ 和 $\\mathbf{f}_f$ 的积分是通过对每个子分段的贡献求和来计算的。在每个子分段 $I_k$ 上，采用 $n_q=3$ 点的高斯-勒让德求积。参考区间 $[-1,1]$ 上的求积点 $\\xi_q$ 和权重 $w_q$被映射到 $I_k$ 上的点 $s_{q,k}$ 和权重 $W_{q,k}$：\n$$ s_{q,k} = \\frac{a_k+b_k}{2} + \\frac{b_k-a_k}{2} \\xi_q, \\quad W_{q,k} = \\frac{b_k-a_k}{2} w_q $$\n数值计算出的固体上的总力 $F_s^{\\text{num}}$ 是所有节点力分量的总和：\n$$ F_s^{\\text{num}} = \\sum_j \\left( \\sum_{k} \\sum_{q} N_{s,j}(s_{q,k}) \\, t_f(s_{q,k}) \\, W_{q,k} \\right) = \\sum_{k,q} \\left( \\sum_j N_{s,j}(s_{q,k}) \\right) t_f(s_{q,k}) \\, W_{q,k} $$\n在每个求积点应用单位分解性质 $\\sum_j N_{s,j}(s_{q,k}) = 1$ 可得：\n$$ F_s^{\\text{num}} = \\sum_{k,q} t_f(s_{q,k}) \\, W_{q,k} $$\n类似地，流体上的总力为：\n$$ F_f^{\\text{num}} = \\sum_i \\left( -\\sum_{k,q} N_{f,i}(s_{q,k}) \\, t_f(s_{q,k}) \\, W_{q,k} \\right) = -\\sum_{k,q} \\left( \\sum_i N_{f,i}(s_{q,k}) \\right) t_f(s_{q,k}) \\, W_{q,k} $$\n使用流体形函数的单位分解性质 $\\sum_i N_{f,i}(s_{q,k}) = 1$：\n$$ F_f^{\\text{num}} = -\\sum_{k,q} t_f(s_{q,k}) \\, W_{q,k} $$\n守恒的关键在于，由于流体和固体的计算使用了相同的子分段和求积法则，总载荷的数值近似 $\\sum_{k,q} t_f(s_{q,k}) \\, W_{q,k}$ 对两者是相同的。因此，在浮点运算的精度范围内，我们必须有 $F_s^{\\text{num}} + F_f^{\\text{num}} = 0$。指定的容差 $\\tau = 10^{-12}$ 作为验证此属性的实用阈值。\n\n实现将按以下步骤进行：\n1. 对每个测试用例，在区间 $[0,1]$ 上为包含 $n_f$ 个单元的流体网格和包含 $n_s$ 个单元的固体网格生成均匀的节点坐标。\n2. 初始化大小为 $n_f+1$ 的力向量 $\\mathbf{f}_f$ 和大小为 $n_s+1$ 的力向量 $\\mathbf{f}_s$ 为零向量。\n3. 遍历每个流体单元 $e_f^i$（对于 $i=0, \\dots, n_f-1$）和每个固体单元 $e_s^j$（对于 $j=0, \\dots, n_s-1$）。\n4. 确定交集区间 $[a,b] = [x_i^f, x_{i+1}^f] \\cap [x_j^s, x_{j+1}^s]$。\n5. 如果交集非空（即 $a < b$），则使用 3 点高斯-勒让德求积在 $[a,b]$ 上进行数值积分。\n6. 在每个求积点 $s_q$，计算牵引力 $t_f(s_q)$ 以及活动流体单元 $e_f^i$ 和固体单元 $e_s^j$ 的局部线性形函数的值。\n7. 将加权贡献 $N(s_q) t_f(s_q) W_q$ 累加到 $\\mathbf{f}_s$ 的相应全局分量中，并以负号累加到 $\\mathbf{f}_f$ 中。\n8. 遍历所有单元对后，计算总力 $F_s = \\sum_j (\\mathbf{f}_s)_j$ 和 $F_f = \\sum_i (\\mathbf{f}_f)_i$。\n9. 最后，评估布尔条件 $|F_s + F_f| \\le 10^{-12}$ 以确认守恒性。对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that executes all test cases for conservative traction transfer.\n    \"\"\"\n    \n    # Define Gauss-Legendre quadrature points and weights for n_q = 3 on [-1, 1].\n    # These are high-precision values for sqrt(3/5).\n    gauss_points_3 = np.array([-0.7745966692414834, 0.0, 0.7745966692414834])\n    gauss_weights_3 = np.array([0.5555555555555556, 0.8888888888888888, 0.5555555555555556])\n    \n    # Numerical tolerance for conservation check.\n    tolerance = 1.0e-12\n\n    def get_gauss_quadrature(a, b, points, weights):\n        \"\"\"Maps Gauss points and weights from the reference interval [-1, 1] to [a, b].\"\"\"\n        mid = (a + b) / 2.0\n        half_len = (b - a) / 2.0\n        quad_points = mid + half_len * points\n        quad_weights = half_len * weights\n        return quad_points, quad_weights\n\n    def linear_shape_functions(s, x1, x2):\n        \"\"\"\n        Evaluates 1D linear shape functions for an element defined by nodes [x1, x2] at a point s.\n        Returns a tuple (N1(s), N2(s)).\n        \"\"\"\n        length = x2 - x1\n        if length <= 0:\n            # Handle degenerate or invalid element lengths.\n            return 0.0, 0.0\n        n1 = (x2 - s) / length\n        n2 = (s - x1) / length\n        return n1, n2\n\n    def solve_one_case(n_f, n_s, t_f_func, tau):\n        \"\"\"\n        Implements the conservative assembly and verification for a single test case.\n        Args:\n            n_f (int): Number of fluid elements.\n            n_s (int): Number of solid elements.\n            t_f_func (callable): The traction function t_f(s).\n            tau (float): The conservation tolerance.\n        Returns:\n            bool: True if conservation is satisfied, False otherwise.\n        \"\"\"\n        # 1. Define uniform meshes on the interval [0, 1].\n        nodes_f = np.linspace(0.0, 1.0, n_f + 1)\n        nodes_s = np.linspace(0.0, 1.0, n_s + 1)\n\n        # Initialize global force vectors to zero.\n        f_f = np.zeros(n_f + 1)\n        f_s = np.zeros(n_s + 1)\n\n        # 2. Loop over all fluid-solid element pairs to find intersections.\n        for i in range(n_f):  # Loop over fluid elements\n            x_f1, x_f2 = nodes_f[i], nodes_f[i + 1]\n            for j in range(n_s):  # Loop over solid elements\n                x_s1, x_s2 = nodes_s[j], nodes_s[j + 1]\n\n                # Find the intersection subsegment [a, b].\n                a = max(x_f1, x_s1)\n                b = min(x_f2, x_s2)\n\n                # 3. Integrate over the non-empty intersection subsegment.\n                if a < b:\n                    # Get Gauss quadrature points and weights for the subsegment [a, b].\n                    quad_points, quad_weights = get_gauss_quadrature(\n                        a, b, gauss_points_3, gauss_weights_3\n                    )\n\n                    # Perform numerical integration.\n                    for q_idx in range(len(quad_points)):\n                        s_q = quad_points[q_idx]\n                        w_q = quad_weights[q_idx]\n\n                        # Evaluate traction at the quadrature point.\n                        t_q = t_f_func(s_q)\n\n                        # Evaluate fluid shape functions for element i at s_q.\n                        nf1_q, nf2_q = linear_shape_functions(s_q, x_f1, x_f2)\n\n                        # Evaluate solid shape functions for element j at s_q.\n                        ns1_q, ns2_q = linear_shape_functions(s_q, x_s1, x_s2)\n                        \n                        # 4. Accumulate forces into global vectors.\n                        # Fluid force vector (action-reaction principle gives a negative sign).\n                        f_f[i]     -= nf1_q * t_q * w_q\n                        f_f[i + 1] -= nf2_q * t_q * w_q\n                        \n                        # Solid force vector (receives the fluid traction).\n                        f_s[j]     += ns1_q * t_q * w_q\n                        f_s[j + 1] += ns2_q * t_q * w_q\n\n        # 5. Verify conversation by summing all nodal forces.\n        f_total_f = np.sum(f_f)\n        f_total_s = np.sum(f_s)\n        \n        residual = abs(f_total_f + f_total_s)\n        return residual <= tau\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 8, lambda s: 3.5 + 1.0 * s),\n        (5, 7, lambda s: 5.0),\n        (2, 19, lambda s: 2.0 + 3.0 * s),\n        (17, 13, lambda s: 0.2 + np.sin(6 * np.pi * s)),\n        (1, 50, lambda s: np.sin(2 * np.pi * s)),\n    ]\n\n    results = []\n    for nf, ns, t_f in test_cases:\n        result = solve_one_case(nf, ns, t_f, tolerance)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2560143"}]}