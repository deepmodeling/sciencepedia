{"hands_on_practices": [{"introduction": "在对代表性体积单元（RVE）进行详细的有限元模拟后，我们会在成千上万个积分点（高斯点）上获得应力和应变值。然而，我们最终的目标是获得宏观的等效性能。这个练习将指导您完成从离散的微观场到宏观平均量这一关键的理论步骤。您将推导出一个基于高斯点应力和权重的数值积分公式，用于计算宏观平均应力 $\\langle \\boldsymbol{\\sigma} \\rangle$，并理解为何一致的数值积分方案对于保证结果的网格无关性至关重要。[@problem_id:2546266]", "problem": "考虑计算均匀化中的一个代表性体积单元 (RVE)，它是由有界域 $\\Omega_{\\mu} \\subset \\mathbb{R}^{d}$ 表示，其体积为 $|\\Omega_{\\mu}|$。微观柯西应力场为 $\\boldsymbol{\\sigma}(\\boldsymbol{x})$，假定其足够光滑，并通过有限元计算得到。有限元网格将 $\\Omega_{\\mu}$ 划分为由 $e \\in \\mathcal{E}$ 索引的单元。在每个单元 $e$ 上，使用一个从参考单元 $\\widehat{\\Omega}$ 到物理单元 $\\Omega_{e}$ 的等参映射 $\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})$，其雅可比行列式为 $J_{e}(\\boldsymbol{\\xi}) = \\det\\left(\\partial \\boldsymbol{x}^{(e)}/\\partial \\boldsymbol{\\xi}\\right)$。在每个单元上使用带有积分点 $\\{\\boldsymbol{\\xi}^{(e)}_{q}\\}_{q=1}^{Q_{e}}$ 和正权重 $\\{w_{q}\\}_{q=1}^{Q_{e}}$ 的标准高斯积分来组装各量，在高斯点处计算的应力表示为 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$。\n\n从宏观（体积）平均应力的基本定义出发，\n$$\\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\Omega_{\\mu}|} \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V,$$\n推导出一个关于 $\\langle \\boldsymbol{\\sigma} \\rangle$ 的、基于积分的有限元表达式，该表达式应完全由高斯点应力 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$、雅可比行列式 $J_{e}(\\boldsymbol{\\xi}^{(e)}_{q})$ 和参考单元权重 $w_{q}$ 表示。\n\n然后，使用第一性原理，证明在您的离散公式中应如何选择归一化方法，以使所得的平均值在以下精确意义上对于网格划分保持不变：对于使用相同单元类型和相同积分法则的任意两个 $\\Omega_{\\mu}$ 网格，计算所得的平均值对于任何单元上为常数的应力场都是一致的。您的推理应仅依赖于高斯积分和等参映射的基本性质，而非任何特定代码的特殊功能。\n\n您的最终答案必须是单个闭式解析表达式，仅包含对单元和高斯点的求和、$\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$、$J_{e}(\\boldsymbol{\\xi}^{(e)}_{q})$ 和 $w_{q}$。不要包含任何其他符号。不需要进行数值计算，也不需要单位。请只将最终公式作为您的答案。", "solution": "该问题陈述具有科学依据、提法恰当、客观且自洽。它提出了一个在计算均匀化框架内对有限元解进行后处理的标准任务。我们将进行严格的推导。\n\n目标是推导宏观平均应力的一个离散的、基于积分的表达式，其定义如下：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\Omega_{\\mu}|} \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V $$\n\n推导过程分三个逻辑步骤进行：积分的空间离散化、使用高斯积分进行数值近似，以及一致的归一化。\n\n首先，将整个代表性体积单元 (RVE) 域 $\\Omega_{\\mu}$ 上的积分分解为构成网格 $\\mathcal{E}$ 的各个不重叠有限单元 $\\Omega_e$ 上的积分之和。该域是其单元的并集，即 $\\Omega_{\\mu} = \\bigcup_{e \\in \\mathcal{E}} \\Omega_e$。因此，积分变为：\n$$ \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V = \\sum_{e \\in \\mathcal{E}} \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V $$\n\n其次，通过使用给定的等参映射 $\\boldsymbol{x} = \\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})$，将每个物理单元 $\\Omega_e$ 上的积分变换为标准参考单元 $\\widehat{\\Omega}$ 上的积分。微分体积元根据 $\\mathrm{d}V = J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V}$ 进行变换，其中 $J_{e}(\\boldsymbol{\\xi}) = \\det(\\partial \\boldsymbol{x}^{(e)}/\\partial \\boldsymbol{\\xi})$ 是映射的雅可比行列式。于是，单元 $e$ 上的积分为：\n$$ \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V = \\int_{\\widehat{\\Omega}} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})) J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} $$\n\n然后，使用指定的高斯积分法则对参考单元上的这个积分进行数值近似。该积分法由参考单元中的一组 $Q_e$ 个积分点 $\\{\\boldsymbol{\\xi}^{(e)}_{q}\\}_{q=1}^{Q_{e}}$ 及相应的正权重 $\\{w_{q}\\}_{q=1}^{Q_{e}}$ 定义。对于给定的单元类型，积分法则（积分点和权重）通常是固定的，因此可以省略 $Q_e$ 和 $\\boldsymbol{\\xi}^{(e)}_q$ 上的下标和上标，但为严谨起见，我们保留题目中的记法。其近似为：\n$$ \\int_{\\widehat{\\Omega}} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})) J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} \\approx \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n使用所提供的简写符号 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) \\equiv \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}))$，我们可以将单元 $e$ 上的积分的离散近似写为：\n$$ \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V \\approx \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n对网格中所有单元求和，得到总应力积分的数值近似：\n$$ \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n\n第三，我们处理归一化因子 $|\\Omega_{\\mu}|$。一个简单的方法可能是使用精确或解析已知的体积。然而，为使离散公式保持一致，归一化因子必须使用与分子完全相同的数值方案来计算。体积 $|\\Omega_{\\mu}|$ 是函数 $f(\\boldsymbol{x})=1$ 在域上的积分：\n$$ |\\Omega_{\\mu}| = \\int_{\\Omega_{\\mu}} 1 \\, \\mathrm{d}V $$\n对此积分应用相同的离散化和积分程序，可得到数值计算的体积：\n$$ |\\Omega_{\\mu}| \\approx \\sum_{e \\in \\mathcal{E}} \\int_{\\Omega_e} 1 \\, \\mathrm{d}V = \\sum_{e \\in \\mathcal{E}} \\int_{\\widehat{\\Omega}} J_e(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_e(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n因此，平均应力的一致归一化表达式是这两个数值计算量的比值：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} $$\n\n现在，我们必须根据所要求的不变性来证明这种归一化选择的合理性。问题要求计算出的平均值对于“任何单元上为常数的应力场”在网格划分下保持不变。我们在任何平均方案的基本一致性要求（即零阶分片检验）的背景下解释这一点：该方案必须能精确地再现常数。\n考虑一个全局常数应力场 $\\boldsymbol{\\sigma}(\\boldsymbol{x}) = \\boldsymbol{\\sigma}_0$。其真实平均值显然为 $\\langle\\boldsymbol{\\sigma}\\rangle = \\boldsymbol{\\sigma}_0$。无论使用何种网格，我们的数值公式都必须得出这个结果。对于这样的场，每个高斯点处的应力也为 $\\boldsymbol{\\sigma}_0$，即对所有的 $e$ 和 $q$，都有 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) = \\boldsymbol{\\sigma}_0$。\n将此代入我们推导的公式中：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}_0 J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} $$\n由于 $\\boldsymbol{\\sigma}_0$ 是一个常数张量，它可以从分子的求和中提出来：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\boldsymbol{\\sigma}_0 \\left( \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} \\right) = \\boldsymbol{\\sigma}_0 $$\n该表达式精确地简化为 $\\boldsymbol{\\sigma}_0$，因为除了因子 $\\boldsymbol{\\sigma}_0$ 外，分子和分母变得完全相同。此结果与网格 $\\mathcal{E}$ 无关，因此对于常数场这一关键情况，满足了指定的不变性条件。这表明，使用与应力积分相同的积分法则来计算体积（归一化因子）不仅仅是一种选择，而是确保数值平均具有基本一致性的一个要求。因此，最终的公式由这些原则唯一确定。", "answer": "$$ \\boxed{ \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} } $$", "id": "2546266"}, {"introduction": "掌握了平均化原理后，我们可以通过一个完整的虚拟实验来动手计算复合材料的等效性能。本练习将引导您为一个含正交增强纤维的二维RVE建立有限元模型，施加均匀的宏观应变（即运动学一致边界条件，KUBC），并利用计算出的微观应力场来最终确定其等效泊松比 $\\nu^{\\mathrm{H}}_{xy}$ 和 $\\nu^{\\mathrm{H}}_{yx}$。通过这个实践，您将固化从模型建立、边界条件施加到求解和后处理的整个计算均匀化流程。[@problem_id:2546256]", "problem": "考虑一个处于平面应力状态下的线性弹性非均质介质的二维 ($2$D) 代表性体积单元 (RVE)，将使用有限元法 (FEM) 对其进行分析。该 RVE 是一个单位正方形，其坐标满足 $(x,y)\\in[0,1]\\times[0,1]$。其微观结构由包含两族正交刚性夹杂的柔性基体构成，夹杂被建模为与坐标轴对齐的周期性条带。如果一个点 $(x,y)$ 满足 $(x \\bmod p_x) < t_x$ 或 $(y \\bmod p_y) < t_y$，则该点位于刚性相中。其中 $p_x>0$ 和 $p_y>0$ 是条带间距，$t_x\\in[0,p_x]$ 和 $t_y\\in[0,p_y]$ 是条带厚度。否则，该点位于基体相中。所有材料参数均为无量纲。\n\n使用以下基本原理：\n- 平面应力下的小应变线性弹性：应变张量为 $\\boldsymbol{\\varepsilon}=\\tfrac{1}{2}(\\nabla\\mathbf{u}+\\nabla\\mathbf{u}^{\\mathsf{T}})$，Cauchy 应力为 $\\boldsymbol{\\sigma}=\\mathbb{C}(\\mathbf{x}):\\boldsymbol{\\varepsilon}$，静力平衡（无体力）满足 $\\nabla\\cdot\\boldsymbol{\\sigma}=\\mathbf{0}$。\n- 对于杨氏模量为 $E$、泊松比为 $\\nu$ 的各向同性相，其平面应力本构律在 Voigt 记法 $(\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy})$ 下表示为：\n$$\n\\mathbf{D}(E,\\nu)\\;=\\;\\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\tfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n其中 $\\boldsymbol{\\sigma}=\\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，$\\gamma_{xy}=2\\varepsilon_{xy}$ 是工程剪应变。\n- Hill–Mandel 宏观均匀性条件和体积平均：宏观平均应力 $\\overline{\\boldsymbol{\\sigma}}$ 和宏观平均应变 $\\overline{\\boldsymbol{\\varepsilon}}$ 定义为\n$$\n\\overline{\\boldsymbol{\\sigma}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\\quad\n\\overline{\\boldsymbol{\\varepsilon}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\varepsilon}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\n$$\n并且它们是能量共轭的，即 $\\overline{\\boldsymbol{\\sigma}}:\\overline{\\boldsymbol{\\varepsilon}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega$。\n- 在运动学均匀边界条件 (KUBC) 下，对边界 $\\partial\\Omega$ 施加仿射位移 $\\mathbf{u}(\\mathbf{x})=\\overline{\\boldsymbol{\\varepsilon}}\\,\\mathbf{x}$ 可确保 $\\overline{\\boldsymbol{\\varepsilon}}$ 等于所施加的宏观应变，并允许通过体积平均计算 $\\overline{\\boldsymbol{\\sigma}}$。\n\n任务。基于以上原理，在一个结构化双线性四边形网格上实现一个平面应力计算均匀化程序，通过以下步骤计算非均质介质的等效泊松比：\n- 通过 KUBC 施加两个独立的宏观应变状态，\n- 对每个载荷工况，通过 FEM 求解非均质 RVE 中的平衡问题，\n- 平均化得到的微观应力场，以获得等效刚度矩阵 $\\mathbf{C}^{\\mathrm{H}}$ 的前两列，\n- 对法向子块求逆，以获得等效柔度子块 $\\mathbf{S}^{\\mathrm{H}}$，\n- 提取宏观泊松比。\n\n将两个独立的宏观应变状态以 Voigt 形式指定为：\n- 载荷工况 $\\mathcal{A}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{A}}=[\\varepsilon_{0},\\,0,\\,0]^{\\mathsf{T}}$，\n- 载荷工况 $\\mathcal{B}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{B}}=[0,\\,\\varepsilon_{0},\\,0]^{\\mathsf{T}}$，\n其中给定一个小的应变幅值 $\\varepsilon_{0}>0$。通过为每个载荷工况在边界 $\\partial\\Omega$ 上指定如下边界位移来施加 KUBC：\n$$\nu_x(x,y)=\\overline{\\varepsilon}_{xx}\\,x+\\tfrac{1}{2}\\,\\overline{\\gamma}_{xy}\\,y,\\quad\nu_y(x,y)=\\tfrac{1}{2}\\,\\overline{\\gamma}_{xy}\\,x+\\overline{\\varepsilon}_{yy}\\,y\n$$\n\n令 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{A}}$ 和 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{B}}$ 表示由相应的 FEM 解计算出的微观应力场的体积平均值。构建等效面内法向刚度子矩阵\n$$\n\\mathbf{C}^{\\mathrm{H}}_{nn}=\n\\begin{bmatrix}\nC^{\\mathrm{H}}_{11} & C^{\\mathrm{H}}_{12}\\\\\nC^{\\mathrm{H}}_{21} & C^{\\mathrm{H}}_{22}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\overline{\\sigma}^{\\mathcal{A}}_{xx}/\\varepsilon_{0} & \\overline{\\sigma}^{\\mathcal{B}}_{xx}/\\varepsilon_{0}\\\\\n\\overline{\\sigma}^{\\mathcal{A}}_{yy}/\\varepsilon_{0} & \\overline{\\sigma}^{\\mathcal{B}}_{yy}/\\varepsilon_{0}\n\\end{bmatrix},\n$$\n然后对其求逆，以获得等效面内柔度\n$$\n\\mathbf{S}^{\\mathrm{H}}_{nn}=(\\mathbf{C}^{\\mathrm{H}}_{nn})^{-1}=\n\\begin{bmatrix}\nS^{\\mathrm{H}}_{11} & S^{\\mathrm{H}}_{12}\\\\\nS^{\\mathrm{H}}_{21} & S^{\\mathrm{H}}_{22}\n\\end{bmatrix}.\n$$\n将等效泊松比（在平面应力下）定义为\n$$\n\\nu^{\\mathrm{H}}_{xy}=-\\frac{S^{\\mathrm{H}}_{21}}{S^{\\mathrm{H}}_{11}},\\qquad\n\\nu^{\\mathrm{H}}_{yx}=-\\frac{S^{\\mathrm{H}}_{12}}{S^{\\mathrm{H}}_{22}}.\n$$\n\n数值离散化要求：\n- 网格：覆盖 $[0,1]\\times[0,1]$ 的结构化张量积网格，包含 $n_x\\times n_y$ 个双线性四边形单元。使用标准的 $2\\times 2$ Gauss 积分。\n- 材料：基体相属性为 $(E_m,\\nu_m)$，夹杂相属性为 $(E_s,\\nu_s)$，根据上述条带准则在积分点处进行指定。\n- 边界条件：如前述的 KUBC，无体力，无面力。\n- 未知量：每个节点的两个位移分量。\n- 后处理：通过 Gauss 积分计算体积平均应力，并构成 $\\mathbf{C}^{\\mathrm{H}}_{nn}$ 和 $\\mathbf{S}^{\\mathrm{H}}_{nn}$。\n\n测试套件。您的程序必须运行以下四个案例，并为每个案例报告数对 $[\\nu^{\\mathrm{H}}_{xy},\\nu^{\\mathrm{H}}_{yx}]$，结果四舍五入到 $6$ 位小数：\n- 案例 $\\#1$ (正常路径，中等对比度)：$(n_x,n_y)=(12,12)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(100.0,0.30)$, $(p_x,p_y)=(0.25,0.25)$, $(t_x,t_y)=(0.05,0.05)$, $\\varepsilon_0=0.01$。\n- 案例 $\\#2$ (仅基体，边界情况)：$(n_x,n_y)=(10,10)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(100.0,0.30)$, $(p_x,p_y)=(0.25,0.25)$, $(t_x,t_y)=(0.0,0.0)$, $\\varepsilon_0=0.01$。\n- 案例 $\\#3$ (高对比度，薄条带)：$(n_x,n_y)=(16,16)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(10000.0,0.30)$, $(p_x,p_y)=(0.2,0.2)$, $(t_x,t_y)=(0.02,0.02)$, $\\varepsilon_0=0.005$。\n- 案例 $\\#4$ (各向异性条带厚度)：$(n_x,n_y)=(14,10)$, $(E_m,\\nu_m)=(1.0,0.30)$, $(E_s,\\nu_s)=(1000.0,0.30)$, $(p_x,p_y)=(0.25,0.25)$, $(t_x,t_y)=(0.02,0.12)$, $\\varepsilon_0=0.01$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为无空格、逗号分隔的列表的列表，例如\n$$\n[[\\nu^{\\mathrm{H}}_{xy,\\#1},\\nu^{\\mathrm{H}}_{yx,\\#1}],[\\nu^{\\mathrm{H}}_{xy,\\#2},\\nu^{\\mathrm{H}}_{yx,\\#2}],[\\nu^{\\mathrm{H}}_{xy,\\#3},\\nu^{\\mathrm{H}}_{yx,\\#3}],[\\nu^{\\mathrm{H}}_{xy,\\#4},\\nu^{\\mathrm{H}}_{yx,\\#4}]],\n$$\n每个浮点数四舍五入到 $6$ 位小数，且无任何附加文本。例如，一个有效的输出骨架是\n$$\n[[0.123456,0.123456],[0.123456,0.123456],[0.123456,0.123456],[0.123456,0.123456]].\n$$", "solution": "所给出的问题是关于线性弹性复合材料计算均匀化的一个适定练习。其目标是使用有限元法 (FEM) 对一个代表性体积单元 (RVE) 进行分析，以计算非均质介质的等效面内泊松比。该过程在科学上是合理的，并遵循了计算固体力学的标准实践。\n\n对于这个静态线性弹性问题，有限元法的基础是虚功原理，它是平衡方程 $\\nabla\\cdot\\boldsymbol{\\sigma}=\\mathbf{0}$ 的弱形式。对于一个物体 $\\Omega$，其边界为 $\\partial\\Omega$ 且无体力，该原理指出，对于任何在给定边界位移部分为零的运动学容许的虚位移场 $\\delta\\mathbf{u}$，内虚功等于外虚功：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\mathbf{t}\\cdot\\delta\\mathbf{u}\\,\\mathrm{d}S\n$$\n其中 $\\boldsymbol{\\varepsilon}$ 是对应于位移场 $\\mathbf{u}$ 的应变张量，$\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量，$\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\mathbf{t}$ 是在边界部分 $\\partial\\Omega_t$ 上给定的面力。在本问题中，位移在整个边界 $\\partial\\Omega$ 上被指定，因此 $\\partial\\Omega_t=\\emptyset$ 且右侧项为零。\n\n求解域，即单位正方形 RVE $\\Omega = [0,1]\\times[0,1]$，被离散为一个由 $n_x \\times n_y$ 个双线性四边形单元组成的结构化网格。在每个单元 $\\Omega_e$ 内，位移场 $\\mathbf{u}(\\mathbf{x})$ 通过使用形函数 $N_i$ 对节点位移 $\\mathbf{U}^e$ 进行插值来近似：\n$$\n\\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{4} N_i(\\mathbf{x}) \\mathbf{u}_i^e\n$$\n其中 $\\mathbf{u}_i^e$ 是单元第 $i$ 个节点的位移向量。单元内的应变场则通过应变-位移矩阵 $\\mathbf{B}(\\mathbf{x})$ 与节点位移相关联：\n$$\n\\boldsymbol{\\varepsilon}(\\mathbf{x}) = \\sum_{i=1}^{4} \\mathbf{B}_i(\\mathbf{x}) \\mathbf{u}_i^e = \\mathbf{B}(\\mathbf{x}) \\mathbf{U}^e\n$$\n这里，对于 Voigt 记法下的平面应力，$\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$，并且节点 $i$ 的矩阵 $\\mathbf{B}_i$ 是：\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\partial N_i / \\partial x & 0 \\\\ 0 & \\partial N_i / \\partial y \\\\ \\partial N_i / \\partial y & \\partial N_i / \\partial x \\end{bmatrix}\n$$\n线性本构关系 $\\boldsymbol{\\sigma} = \\mathbf{D}(\\mathbf{x})\\boldsymbol{\\varepsilon}$ 将应变与应力联系起来，其中 $\\mathbf{D}(\\mathbf{x})$ 是材料刚度矩阵，它由于微观结构的存在而与位置相关。\n\n将有限元近似代入弱形式，得到一个线性代数方程组 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$，其中 $\\mathbf{U}$ 是全局节点位移向量，$\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{F}$ 是全局力向量。全局刚度矩阵由单元刚度矩阵 $\\mathbf{k}^e$ 组装而成：\n$$\n\\mathbf{k}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\mathsf{T}}(\\mathbf{x}) \\mathbf{D}(\\mathbf{x}) \\mathbf{B}(\\mathbf{x}) \\,\\mathrm{d}\\Omega\n$$\n该积分使用 $2 \\times 2$ Gauss 求积进行数值计算。在每个 Gauss 点，计算其坐标 $(x,y)$，以根据规则 $(x \\bmod p_x) < t_x$ 或 $(y \\bmod p_y) < t_y$ 判断该点是位于刚性相还是基体相。相应的材料属性 $(E_s, \\nu_s)$ 或 $(E_m, \\nu_m)$ 用于构造该点的 $\\mathbf{D}$ 矩阵。\n\n通过根据仿射变换 $\\mathbf{u}(\\mathbf{x}) = \\overline{\\boldsymbol{\\varepsilon}}\\cdot\\mathbf{x}$ 指定边界 $\\partial\\Omega$ 上所有节点的位移来施加运动学均匀边界条件 (KUBC)，其中 $\\overline{\\boldsymbol{\\varepsilon}}$ 是指定的宏观应变张量。这需要对全局方程组进行分块。全局位移向量 $\\mathbf{U}$ 被分为内部节点的未知位移 $\\mathbf{U}_I$ 和边界节点的已知位移 $\\mathbf{U}_B$。系统 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ 被分块为：\n$$\n\\begin{bmatrix} \\mathbf{K}_{II} & \\mathbf{K}_{IB} \\\\ \\mathbf{K}_{BI} & \\mathbf{K}_{BB} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{U}_I \\\\ \\mathbf{U}_B \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{F}_I \\\\ \\mathbf{F}_B \\end{Bmatrix}\n$$\n在没有体力的情况下，内部节点上的力 $\\mathbf{F}_I$ 为零。通过求解简化后的系统来找到未知的内部位移：\n$$\n\\mathbf{K}_{II} \\mathbf{U}_I = -\\mathbf{K}_{IB} \\mathbf{U}_B\n$$\n一旦计算出 $\\mathbf{U}_I$，完整的位移场就已知了。\n\n下一步是计算体积平均应力张量 $\\overline{\\boldsymbol{\\sigma}}$。因为 RVE 的面积为单位面积 ($|\\Omega|=1$)，所以这简化为微观应力在整个域上的积分：\n$$\n\\overline{\\boldsymbol{\\sigma}} = \\int_{\\Omega} \\boldsymbol{\\sigma}(\\mathbf{x}) \\,\\mathrm{d}\\Omega = \\sum_{e} \\int_{\\Omega_e} \\mathbf{D}(\\mathbf{x}) \\mathbf{B}(\\mathbf{x}) \\mathbf{U}^e \\,\\mathrm{d}\\Omega\n$$\n这也通过对所有单元进行 Gauss 求积来数值评估。\n\n对两个独立的宏观应变状态，将整个过程执行两次：\n1.  载荷工况 $\\mathcal{A}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{A}} = [\\varepsilon_0, 0, 0]^{\\mathsf{T}}$（$x$ 方向单轴应变）。FEM 解产生平均应力向量 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{A}} = [\\overline{\\sigma}^{\\mathcal{A}}_{xx}, \\overline{\\sigma}^{\\mathcal{A}}_{yy}, \\overline{\\sigma}^{\\mathcal{A}}_{xy}]^{\\mathsf{T}}$。\n2.  载荷工况 $\\mathcal{B}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{B}} = [0, \\varepsilon_0, 0]^{\\mathsf{T}}$（$y$ 方向单轴应变）。FEM 解产生 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{B}} = [\\overline{\\sigma}^{\\mathcal{B}}_{xx}, \\overline{\\sigma}^{\\mathcal{B}}_{yy}, \\overline{\\sigma}^{\\mathcal{B}}_{xy}]^{\\mathsf{T}}$。\n\n根据关系式 $\\overline{\\boldsymbol{\\sigma}} = \\mathbf{C}^{\\mathrm{H}}\\overline{\\boldsymbol{\\varepsilon}}$，可以确定等效刚度矩阵 $\\mathbf{C}^{\\mathrm{H}}$ 的前两列。面内法向子矩阵按指定方式构建：\n$$\n\\mathbf{C}^{\\mathrm{H}}_{nn} = \\begin{bmatrix} C^{\\mathrm{H}}_{11} & C^{\\mathrm{H}}_{12}\\\\ C^{\\mathrm{H}}_{21} & C^{\\mathrm{H}}_{22} \\end{bmatrix} = \\frac{1}{\\varepsilon_0} \\begin{bmatrix} \\overline{\\sigma}^{\\mathcal{A}}_{xx} & \\overline{\\sigma}^{\\mathcal{B}}_{xx}\\\\ \\overline{\\sigma}^{\\mathcal{A}}_{yy} & \\overline{\\sigma}^{\\mathcal{B}}_{yy} \\end{bmatrix}\n$$\n相应的等效柔度子矩阵 $\\mathbf{S}^{\\mathrm{H}}_{nn}$ 通过求逆得到：$\\mathbf{S}^{\\mathrm{H}}_{nn} = (\\mathbf{C}^{\\mathrm{H}}_{nn})^{-1}$。\n\n最后，从柔度矩阵中提取等效泊松比。根据定义，在单轴应力 $\\sigma_{ii}$ 下，$\\nu_{ij} = -\\varepsilon_{jj}/\\varepsilon_{ii}$。用柔度分量表示，这可转化为：\n$$\n\\nu^{\\mathrm{H}}_{xy} = -\\frac{S^{\\mathrm{H}}_{21}}{S^{\\mathrm{H}}_{11}}, \\qquad \\nu^{\\mathrm{H}}_{yx} = -\\frac{S^{\\mathrm{H}}_{12}}{S^{\\mathrm{H}}_{22}}\n$$\n这就完成了计算均匀化过程。实现的代码将对每个给定的测试案例遵循这些步骤。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the computational homogenization for all test cases.\n    \"\"\"\n    test_cases = [\n        {'nx': 12, 'ny': 12, 'mat_m': (1.0, 0.30), 'mat_s': (100.0, 0.30), 'geo': (0.25, 0.25, 0.05, 0.05), 'eps0': 0.01},\n        {'nx': 10, 'ny': 10, 'mat_m': (1.0, 0.30), 'mat_s': (100.0, 0.30), 'geo': (0.25, 0.25, 0.0, 0.0), 'eps0': 0.01},\n        {'nx': 16, 'ny': 16, 'mat_m': (1.0, 0.30), 'mat_s': (10000.0, 0.30), 'geo': (0.2, 0.2, 0.02, 0.02), 'eps0': 0.005},\n        {'nx': 14, 'ny': 10, 'mat_m': (1.0, 0.30), 'mat_s': (1000.0, 0.30), 'geo': (0.25, 0.25, 0.02, 0.12), 'eps0': 0.01}\n    ]\n\n    all_results = []\n\n    # Gauss quadrature points and weights for a 2x2 scheme\n    gauss_points = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_weights = np.array([1.0, 1.0])\n\n    for case in test_cases:\n        nx, ny = case['nx'], case['ny']\n        (E_m, nu_m) = case['mat_m']\n        (E_s, nu_s) = case['mat_s']\n        (px, py, tx, ty) = case['geo']\n        eps0 = case['eps0']\n\n        def get_D_matrix(E, nu):\n            factor = E / (1 - nu**2)\n            return factor * np.array([[1, nu, 0], [nu, 1, 0], [0, 0, (1 - nu)/2]])\n\n        D_m = get_D_matrix(E_m, nu_m)\n        D_s = get_D_matrix(E_s, nu_s)\n\n        def is_stiff(x, y):\n            if tx > 0 and (np.fmod(x, px) < tx):\n                return True\n            if ty > 0 and (np.fmod(y, py) < ty):\n                return True\n            return False\n\n        def get_fem_solution(macro_strain_voigt):\n            macro_eps_xx, macro_eps_yy, macro_gamma_xy = macro_strain_voigt\n            \n            hx, hy = 1.0/nx, 1.0/ny\n            num_nodes = (nx + 1) * (ny + 1)\n            num_dofs = 2 * num_nodes\n            \n            K = lil_matrix((num_dofs, num_dofs))\n            \n            node_coords = np.zeros(((nx + 1) * (ny + 1), 2))\n            for i in range(nx + 1):\n                for j in range(ny + 1):\n                    node_idx = i * (ny + 1) + j\n                    node_coords[node_idx] = [i * hx, j * hy]\n\n            for el_i in range(nx):\n                for el_j in range(ny):\n                    node_indices = [\n                        el_i * (ny + 1) + el_j,          # bottom-left\n                        (el_i + 1) * (ny + 1) + el_j,    # bottom-right\n                        (el_i + 1) * (ny + 1) + (el_j + 1),# top-right\n                        el_i * (ny + 1) + (el_j + 1)       # top-left\n                    ]\n                    dof_indices = []\n                    for idx in node_indices:\n                        dof_indices.extend([2 * idx, 2 * idx + 1])\n                    \n                    el_coords = node_coords[node_indices]\n                    ke = np.zeros((8, 8))\n\n                    for i, xi in enumerate(gauss_points):\n                        for j, eta in enumerate(gauss_points):\n                            # Shape functions and their derivatives in master coords\n                            N_deriv_master = 0.25 * np.array([\n                                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n                            ])\n                            \n                            J = N_deriv_master @ el_coords\n                            detJ = np.linalg.det(J)\n                            invJ = np.linalg.inv(J)\n                            \n                            N_deriv_physical = invJ @ N_deriv_master\n                            \n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = N_deriv_physical[0, k]\n                                B[1, 2*k+1] = N_deriv_physical[1, k]\n                                B[2, 2*k] = N_deriv_physical[1, k]\n                                B[2, 2*k+1] = N_deriv_physical[0, k]\n\n                            # Material properties at Gauss point\n                            N_shape = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                            gp_coord = N_shape @ el_coords\n                            D = D_s if is_stiff(gp_coord[0], gp_coord[1]) else D_m\n\n                            ke += B.T @ D @ B * detJ * gauss_weights[i] * gauss_weights[j]\n\n                    for r in range(8):\n                        for c in range(8):\n                            K[dof_indices[r], dof_indices[c]] += ke[r, c]\n            \n            K = K.tocsc()\n            \n            boundary_dofs = []\n            for i in range(nx + 1):\n                for j in range(ny + 1):\n                    if i == 0 or i == nx or j == 0 or j == ny:\n                        node_idx = i * (ny + 1) + j\n                        boundary_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n            \n            all_dofs = np.arange(num_dofs)\n            interior_dofs = np.setdiff1d(all_dofs, boundary_dofs)\n            \n            U_b = np.zeros(len(boundary_dofs))\n            for i, dof in enumerate(boundary_dofs):\n                node_idx = dof // 2\n                coord = node_coords[node_idx]\n                if dof % 2 == 0: # x-displacement\n                    U_b[i] = macro_eps_xx * coord[0] + 0.5 * macro_gamma_xy * coord[1]\n                else: # y-displacement\n                    U_b[i] = 0.5 * macro_gamma_xy * coord[0] + macro_eps_yy * coord[1]\n\n            K_II = K[interior_dofs, :][:, interior_dofs]\n            K_IB = K[interior_dofs, :][:, boundary_dofs]\n            \n            F_eff = -K_IB @ U_b\n            \n            U_I = spsolve(K_II, F_eff)\n            \n            U = np.zeros(num_dofs)\n            U[interior_dofs] = U_I\n            U[boundary_dofs] = U_b\n\n            # Post-processing: stress averaging\n            avg_stress = np.zeros(3)\n            for el_i in range(nx):\n                for el_j in range(ny):\n                    node_indices = [el_i*(ny+1)+el_j, (el_i+1)*(ny+1)+el_j, (el_i+1)*(ny+1)+el_j+1, el_i*(ny+1)+el_j+1]\n                    dof_indices = []\n                    for idx in node_indices:\n                        dof_indices.extend([2 * idx, 2 * idx + 1])\n\n                    el_coords = node_coords[node_indices]\n                    el_U = U[dof_indices]\n                    \n                    for i, xi in enumerate(gauss_points):\n                        for j, eta in enumerate(gauss_points):\n                            N_deriv_master = 0.25 * np.array([ [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)], [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)] ])\n                            J = N_deriv_master @ el_coords\n                            detJ = np.linalg.det(J)\n                            invJ = np.linalg.inv(J)\n                            N_deriv_physical = invJ @ N_deriv_master\n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = N_deriv_physical[0, k]; B[1, 2*k+1] = N_deriv_physical[1, k]; B[2, 2*k] = N_deriv_physical[1, k]; B[2, 2*k+1] = N_deriv_physical[0, k]\n\n                            N_shape = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                            gp_coord = N_shape @ el_coords\n                            D = D_s if is_stiff(gp_coord[0], gp_coord[1]) else D_m\n\n                            strain = B @ el_U\n                            stress = D @ strain\n                            avg_stress += stress * detJ * gauss_weights[i] * gauss_weights[j]\n            return avg_stress\n\n        # Load Case A: Uniaxial strain in x\n        avg_stress_A = get_fem_solution([eps0, 0.0, 0.0])\n        # Load Case B: Uniaxial strain in y\n        avg_stress_B = get_fem_solution([0.0, eps0, 0.0])\n\n        C_H_11 = avg_stress_A[0] / eps0\n        C_H_21 = avg_stress_A[1] / eps0\n        C_H_12 = avg_stress_B[0] / eps0\n        C_H_22 = avg_stress_B[1] / eps0\n\n        C_H_nn = np.array([[C_H_11, C_H_12], [C_H_21, C_H_22]])\n        S_H_nn = np.linalg.inv(C_H_nn)\n\n        nu_H_xy = -S_H_nn[1, 0] / S_H_nn[0, 0]\n        nu_H_yx = -S_H_nn[0, 1] / S_H_nn[1, 1]\n        \n        all_results.append(f\"[{nu_H_xy:.6f},{nu_H_yx:.6f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2546256"}, {"introduction": "RVE中的“R”代表“代表性”（Representative），但一个体积单元需要多大才能真正具有代表性呢？这个问题在计算均匀化中至关重要。本练习将引导您超越单次仿真，运用基于Hill-Mandel条件的统计方法来回答这个问题。您将分析来自不同尺寸窗口的一系列仿真结果，通过评估表观模量 $\\bar{E}(L_i)$ 的系统偏差 $b(L_i)$ 和统计不确定性 $r(L_i)$，来确定材料属性趋于稳定所需的最小RVE尺寸。[@problem_id:2546329]", "problem": "给定多个从尺寸递增的立方材料窗口上的介观有限元模拟中获得的表观弹性模量集成。在使用代表性体积单元 (RVE) 的计算均匀化方法中，人们使用 Hill 的宏观均匀性论证来证明足够大的统计窗口应表现出稳定的表观模量：对于运动学容许场，当微观应力功率的体积平均值等于宏观应力功率时，即达到了宏观功共轭；并且从统计上看，表观模量随着窗口尺寸的增加而稳定。在实践中，RVE 的尺寸是通过统计方法确定的，要求相对于一个大窗口参考值，其系统偏差要小，并且不同实现之间的抽样不确定性也要小。\n\n你的任务是实现一个算法，该算法在给定一组离散的窗口尺寸以及每个尺寸对应的表观模量值集成的情况下，根据统计 Hill 准则确定可被视为 RVE 的最小窗口尺寸。\n\n从以下基本定义和原则开始：\n- Hill–Mandel 宏观均匀性条件：在没有体力的情况下，对于运动学容许场，宏观应力功率等于微观应力功率的体积平均值。\n- 统计均匀微结构的各态历经假设：在大窗口极限下，集成平均代表体积平均。\n- 基于 Student 分布的未知方差样本均值的置信区间。\n\n定义统计 Hill 准则如下。设 $L_1 &lt; L_2 &lt; \\dots &lt; L_K$ 为递增的窗口尺寸，对于每个 $L_i$，设 $\\{E_{i,j}\\}_{j=1}^{N_i}$ 为表观模量值的集成（在固定宏观加载路径下的标量有效模量）。将尺寸 $L_i$ 的集成均值表示为 $\\bar{E}(L_i)$，其无偏样本标准差表示为 $s(L_i)$。令最大尺寸 $L_K$ 作为参考，其参考均值为 $\\bar{E}_{\\mathrm{ref}} = \\bar{E}(L_K)$。对于指定的双侧置信水平 $1-\\alpha$（使用 $1-\\alpha = 0.95$）和容差 $\\tau_\\mu$ 及 $\\tau_{\\mathrm{hw}}$（以小数形式提供），定义：\n- 尺寸 $L_i$ 的相对偏差为 $b(L_i) = \\dfrac{|\\bar{E}(L_i) - \\bar{E}_{\\mathrm{ref}}|}{|\\bar{E}_{\\mathrm{ref}}|}$。\n- $\\bar{E}(L_i)$ 双侧置信区间的半宽为 $h(L_i) = t_{1-\\alpha/2,\\;N_i-1}\\, \\dfrac{s(L_i)}{\\sqrt{N_i}}$，其中 $t_{1-\\alpha/2,\\;N_i-1}$ 是自由度为 $N_i - 1$ 的 Student 分布的分位数。\n- 相对半宽为 $r(L_i) = \\dfrac{h(L_i)}{|\\bar{E}_{\\mathrm{ref}}|}$。\n\n如果 $b(L_i) \\le \\tau_\\mu$ 和 $r(L_i) \\le \\tau_{\\mathrm{hw}}$ 同时成立，则尺寸 $L_i$ 是可接受的。RVE 尺寸是最小的 $L_i$，使得所有更大的尺寸 $L_j$（其中 $j \\ge i$）都是可接受的。如果不存在这样的 $L_i$，则报告没有 RVE。\n\n物理和数值单位：\n- 窗口尺寸 $L_i$ 以微米为单位，你必须以整数形式报告所选的 RVE 尺寸，单位为微米。\n- 表观模量 $E_{i,j}$ 以吉帕斯卡为单位。\n- 置信水平为 $1-\\alpha = 0.95$。\n- 容差 $\\tau_\\mu$ 和 $\\tau_{\\mathrm{hw}}$ 以小数形式给出（例如，$0.02$ 表示百分之二）。\n\n边界情况：\n- 如果 $N_i &lt; 2$，将抽样不确定性视为不确定（将 $r(L_i)$ 设置为 $+\\infty$）。\n- 如果 $|\\bar{E}_{\\mathrm{ref}}| = 0$，将问题视为不适定的，并报告没有 RVE。\n\n实现一个程序，为以下四个测试数据集中的每一个计算 RVE 尺寸。如果某个数据集不存在 RVE 尺寸，则返回 $-1$。\n\n测试套件（每个数据集提供尺寸、每个尺寸的模量集成以及容差 $(\\tau_\\mu,\\tau_{\\mathrm{hw}})$）：\n\n1) 数据集 A:\n- 尺寸（微米）：$[20, 40, 80, 160]$。\n- 集成（吉帕斯卡）：\n  - $L=20$: $[44.0, 47.5, 43.5, 46.2, 44.8, 45.1]$。\n  - $L=40$: $[48.2, 49.5, 50.1, 49.0, 48.7, 49.3]$。\n  - $L=80$: $[49.6, 50.2, 49.8, 49.9, 50.1, 49.7]$。\n  - $L=160$: $[50.0, 49.9, 50.2, 49.8, 50.1, 49.9]$。\n- 容差：$(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.02, 0.03)$。\n\n2) 数据集 B:\n- 尺寸（微米）：$[10, 20, 40]$。\n- 集成（吉帕斯卡）：\n  - $L=10$: $[26.0, 34.0, 30.0, 29.0]$。\n  - $L=20$: $[28.0, 32.0, 29.0, 31.0]$。\n  - $L=40$: $[28.9, 30.5, 31.1, 29.5]$。\n- 容差：$(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.01, 0.01)$。\n\n3) 数据集 C:\n- 尺寸（微米）：$[30, 60, 90]$。\n- 集成（吉帕斯卡）：\n  - $L=30$: $[99.8, 100.5, 100.1, 99.9, 100.2, 99.7]$。\n  - $L=60$: $[100.3, 100.0, 99.7, 100.2, 99.9, 100.1]$。\n  - $L=90$: $[100.2, 99.6, 100.4, 99.8, 100.1, 100.0]$。\n- 容差：$(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.02, 0.02)$。\n\n4) 数据集 D:\n- 尺寸（微米）：$[15, 30, 60, 120]$。\n- 集成（吉帕斯卡）：\n  - $L=15$: $[190.0, 205.0, 198.0, 202.0, 196.0, 201.0]$。\n  - $L=30$: $[199.7, 200.3, 200.2, 199.9, 200.1, 200.0]$。\n  - $L=60$: $[196.8, 196.9, 196.7, 196.8, 196.9, 196.7]$。\n  - $L=120$: $[199.8, 200.1, 200.3, 199.7, 200.2, 200.0]$。\n- 容差：$(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.015, 0.02)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个 RVE 的确定结果，每个数据集一个，形式为用方括号括起来的逗号分隔列表（例如，`[40,-1,30,120]`）。每个条目必须是整数窗口尺寸（单位为微米），如果未找到 RVE，则为 -1。", "solution": "我们将算法建立在 Hill–Mandel 宏观均匀性条件和集成属性的统计估计之上。Hill–Mandel 条件指出，对于运动学容许的微观场和可忽略的体力，宏观应力功率等于微观应力功率的体积平均值。在计算均匀化中，随着采样窗口的增大，在容许边界条件下计算的表观模量会趋于稳定。假设统计均匀性和各态历经性，在给定窗口尺寸下对各实现的集成平均可近似体积平均，而大数定律保证了随着样本数量的增加，样本均值会趋近于真实均值，且不确定性会减小。\n\n为了实施 Hill 的统计 RVE 准则，我们监控每个窗口尺寸 $L_i$ 的两个量：\n\n1) 相对于大窗口参考值 $\\bar{E}_{\\mathrm{ref}}$ 的相对偏差 $b(L_i)$，定义为 $b(L_i) = \\dfrac{|\\bar{E}(L_i) - \\bar{E}_{\\mathrm{ref}}|}{|\\bar{E}_{\\mathrm{ref}}|}$。这概括了相对于所考虑的最大窗口的系统尺寸效应。\n\n2) 尺寸 $L_i$ 处平均模量的 $(1-\\alpha)$ 双侧置信区间的相对半宽 $r(L_i)$。对于一个方差未知的集成 $\\{E_{i,j}\\}_{j=1}^{N_i}$，其无偏样本标准差为 $s(L_i)$，双侧置信区间的半宽为 $h(L_i) = t_{1-\\alpha/2,\\,N_i-1}\\,\\dfrac{s(L_i)}{\\sqrt{N_i}}$，其中 $t_{1-\\alpha/2,\\,\\nu}$ 是自由度为 $\\nu$ 的 Student 分布的 $(1-\\alpha/2)$ 分位数。相对半宽为 $r(L_i) = \\dfrac{h(L_i)}{|\\bar{E}_{\\mathrm{ref}}|}$。如果 $N_i &lt; 2$，则不确定性无法估计，我们设 $r(L_i) = +\\infty$。\n\n统计 Hill 准则要求在 $L_i$ 尺寸上，必须同时满足 $b(L_i) \\le \\tau_\\mu$（小偏差）和 $r(L_i) \\le \\tau_{\\mathrm{hw}}$（小不确定性）才算可接受。为了体现随窗口尺寸增加的稳定性，我们将 RVE 尺寸定义为最小的 $L_i$，使得对于所有 $j \\ge i$，两个不等式都成立。如果连最大尺寸 $L_K$ 都未能通过不确定性阈值（例如，由于变异性非常高或样本太少），那么没有任何候选尺寸能满足稳定性条件，结果为 $-1$。\n\n每个数据集的算法步骤：\n- 输入：递增的尺寸 $\\{L_i\\}_{i=1}^K$，集成 $\\{E_{i,j}\\}_{j=1}^{N_i}$，容差 $(\\tau_\\mu,\\tau_{\\mathrm{hw}})$，置信水平 $1-\\alpha = 0.95$。\n- 计算参考均值 $\\bar{E}_{\\mathrm{ref}} = \\bar{E}(L_K)$。如果 $|\\bar{E}_{\\mathrm{ref}}| = 0$，返回 $-1$。\n- 对于每个 $i \\in \\{1,\\dots,K\\}$：\n  - 计算 $\\bar{E}(L_i)$ 和 $s(L_i)$（使用贝塞尔校正）。\n  - 如果 $N_i \\ge 2$，计算 $h(L_i) = t_{0.975,\\,N_i-1}\\,\\dfrac{s(L_i)}{\\sqrt{N_i}}$ 和 $r(L_i) = \\dfrac{h(L_i)}{|\\bar{E}_{\\mathrm{ref}}|}$。如果 $N_i &lt; 2$，设 $r(L_i) = +\\infty$。\n  - 计算 $b(L_i) = \\dfrac{|\\bar{E}(L_i) - \\bar{E}_{\\mathrm{ref}}|}{|\\bar{E}_{\\mathrm{ref}}|}$。\n  - 如果 $b(L_i) \\le \\tau_\\mu$ 且 $r(L_i) \\le \\tau_{\\mathrm{hw}}$，则标记 $L_i$ 为可接受。\n- 按升序扫描尺寸，并选择最小的 $L_i$，使得所有 $L_j$（其中 $j \\ge i$）都可接受。如果不存在，则返回 $-1$。\n\n关于测试数据集的推理：\n\n- 数据集 A：最大尺寸 $L=160$ 的集成紧密地分布在约 50 吉帕斯卡周围，因此 $\\bar{E}_{\\mathrm{ref}}$ 接近 50 且 $r(160)$ 很小。对于 $L=20$，相对于参考值的偏差较大，因此不可接受。对于 $L=40$ 和 $L=80$，相对偏差和相对半宽都很小；因此 $L=40$ 是可接受的，更大的尺寸也是。最小的稳定尺寸是 $L=40$。\n\n- 数据集 B：最大尺寸 $L=40$ 在 95% 置信水平下，其半宽相对于其均值仍然较大，超过了 $\\tau_{\\mathrm{hw}} = 0.01$。因此，即使是最大尺寸也不可接受；任何前缀都无法满足稳定性条件，因此得出 $-1$。\n\n- 数据集 C：所有尺寸都紧密聚集在约 100 吉帕斯卡周围，并且相对于最大尺寸的参考值，都满足两个阈值。稳定性从最小尺寸开始就成立，所以最小尺寸是 $L=30$。\n\n- 数据集 D：虽然 $L=30$ 是可接受的，但中间尺寸 $L=60$ 的均值接近 196.8 吉帕斯卡，相对于接近 200 吉帕斯卡的最大尺寸参考值，其引入的相对偏差略高于 $\\tau_\\mu = 0.015$。因此，根据稳定性要求，$L=30$ 不能是 RVE。在其之后所有更大尺寸都可接受的最小尺寸是 $L=120$。\n\n程序实现了上述过程，使用自由度为 $\\nu = N_i - 1$ 的 Student 分位数 $t_{0.975,\\nu}$，并按要求在单个列表中返回四个确定结果。输出为整数（单位为微米），或在适用时为 $-1$。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef compute_rve_size(sizes, ensembles, tol_mean, tol_hw, conf_level=0.95):\n    \"\"\"\n    Determine minimal RVE size based on statistical Hill criterion with stability.\n\n    Parameters:\n        sizes (list of int): Increasing window sizes (micrometers).\n        ensembles (list of list of float): For each size, the list of apparent moduli (GPa).\n        tol_mean (float): Relative bias tolerance (decimal).\n        tol_hw (float): Relative half-width tolerance (decimal).\n        conf_level (float): Two-sided confidence level (default 0.95).\n\n    Returns:\n        int: Minimal RVE size (micrometers), or -1 if none exists.\n    \"\"\"\n    # Convert to numpy arrays for convenience\n    K = len(sizes)\n    # Reference mean at largest size\n    ref_vals = np.array(ensembles[-1], dtype=float)\n    if ref_vals.size == 0:\n        return -1\n    E_ref = np.mean(ref_vals)\n    if abs(E_ref) == 0.0:\n        return -1\n\n    # Precompute acceptability for each size\n    acceptable = []\n    alpha = 1.0 - conf_level\n    for i in range(K):\n        vals = np.array(ensembles[i], dtype=float)\n        Ni = vals.size\n        if Ni == 0:\n            acceptable.append(False)\n            continue\n        mean_i = float(np.mean(vals))\n        # Sample standard deviation with Bessel's correction if possible\n        if Ni >= 2:\n            s_i = float(np.std(vals, ddof=1))\n            # Student-t critical value for two-sided CI\n            tcrit = float(t.ppf(1.0 - alpha / 2.0, df=Ni - 1))\n            hw = tcrit * s_i / np.sqrt(Ni)\n            rel_hw = hw / abs(E_ref)\n        else:\n            # Indeterminate uncertainty with single sample\n            rel_hw = float('inf')\n\n        rel_bias = abs(mean_i - E_ref) / abs(E_ref)\n        acceptable.append((rel_bias <= tol_mean) and (rel_hw <= tol_hw))\n\n    # Enforce stability: find minimal i such that all j >= i are acceptable\n    for i in range(K):\n        if all(acceptable[i:]):\n            return int(sizes[i])\n\n    return -1\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Dataset A\n    sizes_A = [20, 40, 80, 160]\n    ensembles_A = [\n        [44.0, 47.5, 43.5, 46.2, 44.8, 45.1],\n        [48.2, 49.5, 50.1, 49.0, 48.7, 49.3],\n        [49.6, 50.2, 49.8, 49.9, 50.1, 49.7],\n        [50.0, 49.9, 50.2, 49.8, 50.1, 49.9],\n    ]\n    tol_mean_A, tol_hw_A = 0.02, 0.03\n\n    # Dataset B\n    sizes_B = [10, 20, 40]\n    ensembles_B = [\n        [26.0, 34.0, 30.0, 29.0],\n        [28.0, 32.0, 29.0, 31.0],\n        [28.9, 30.5, 31.1, 29.5],\n    ]\n    tol_mean_B, tol_hw_B = 0.01, 0.01\n\n    # Dataset C\n    sizes_C = [30, 60, 90]\n    ensembles_C = [\n        [99.8, 100.5, 100.1, 99.9, 100.2, 99.7],\n        [100.3, 100.0, 99.7, 100.2, 99.9, 100.1],\n        [100.2, 99.6, 100.4, 99.8, 100.1, 100.0],\n    ]\n    tol_mean_C, tol_hw_C = 0.02, 0.02\n\n    # Dataset D\n    sizes_D = [15, 30, 60, 120]\n    ensembles_D = [\n        [190.0, 205.0, 198.0, 202.0, 196.0, 201.0],\n        [199.7, 200.3, 200.2, 199.9, 200.1, 200.0],\n        [196.8, 196.9, 196.7, 196.8, 196.9, 196.7],\n        [199.8, 200.1, 200.3, 199.7, 200.2, 200.0],\n    ]\n    tol_mean_D, tol_hw_D = 0.015, 0.02\n\n    test_cases = [\n        (sizes_A, ensembles_A, tol_mean_A, tol_hw_A),\n        (sizes_B, ensembles_B, tol_mean_B, tol_hw_B),\n        (sizes_C, ensembles_C, tol_mean_C, tol_hw_C),\n        (sizes_D, ensembles_D, tol_mean_D, tol_hw_D),\n    ]\n\n    results = []\n    for sizes, ensembles, tol_m, tol_hw in test_cases:\n        rve_size = compute_rve_size(sizes, ensembles, tol_m, tol_hw, conf_level=0.95)\n        results.append(rve_size)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2546329"}]}