{"hands_on_practices": [{"introduction": "在有限元分析中，我们通常在一个简单的“母单元”上定义形函数，然后通过雅可比矩阵（Jacobian matrix）将其映射到物理空间中的实际单元。这个映射的成功与否，直接决定了单元的几何有效性。雅可比行列式 $\\det J$ 在此过程中扮演着核心角色：它不仅是数值积分中的面积（或体积）缩放因子，其符号还直接反映了单元是否存在几何“翻转”。本实践将引导你手动计算一个四节点四边形单元在不同积分点上的雅可比行列式，从而亲身体验如何判断一个单元是否几何畸变，这是构建任何有效有限元模型的基础。[@problem_id:2554541]", "problem": "在有限元法 (FEM) 中，计算平面应力或平面应变下二维线性弹性分析的单元刚度矩阵的背景下，考虑一个 $4$-节点等参四边形单元，其节点的标准自然（父）坐标分配如下：节点 $1 \\equiv (\\xi,\\eta)=(-1,-1)$，节点 $2 \\equiv (1,-1)$，节点 $3 \\equiv (1,1)$，节点 $4 \\equiv (-1,1)$。该单元节点的相应物理坐标（单位为米）为：\n- 节点 $1$：$(x_{1},y_{1})=(0,-1)$，\n- 节点 $2$：$(x_{2},y_{2})=(3.5,-1)$，\n- 节点 $3$：$(x_{3},y_{3})=(-1.5,1)$，\n- 节点 $4$：$(x_{4},y_{4})=(0,1)$。\n\n仅从双线性等参映射 $x(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}$，$y(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}$（使用标准双线性形函数 $N_{i}(\\xi,\\eta)$）和雅可比矩阵 $J(\\xi,\\eta)=\\begin{bmatrix}\\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$（其行列式为 $\\det J(\\xi,\\eta)$）的定义出发，完成以下操作：\n\n- 在每个标准 $2\\times 2$ 高斯点 $(\\xi,\\eta)\\in\\{(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3})\\}$ 处，推导 $\\det J$。\n- 使用这些值评估单元是否反转（即，是否存在至少一个高斯点使得 $\\det J<0$）。\n- 报告四个高斯点中 $\\det J$ 的最小值作为最终数值结果。\n\n将您报告的最终最小行列式值四舍五入到四位有效数字，并以平方米表示。只提供该单个实数作为您的最终答案。", "solution": "问题陈述已经过严格验证，被认为是有效的。它以连续介质力学和有限元法的原理为科学基础，是适定的，提供了所有必要信息，并以客观、精确的语言表达。因此，我们可以开始求解。\n\n该问题要求计算给定 4 节点等参四边形单元在四个特定高斯积分点处的雅可比矩阵行列式 $\\det J$。从父单元坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的映射由等参格式给出：\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}\n$$\n$$\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}\n$$\n其中 $(x_i, y_i)$ 是节点 $i$ 的物理坐标，$N_i(\\xi, \\eta)$ 是双线性形函数。对于标准的 4 节点四边形，它们是：\n$$\nN_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nN_{2}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_{3}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)\n$$\n$$\nN_{4}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n问题将雅可比矩阵 $J$ 定义为：\n$$\nJ(\\xi,\\eta)=\\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}\n$$\n$J$ 的分量通过对映射方程求导得出：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\xi}x_{i}, \\quad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\eta}x_{i}\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\xi}y_{i}, \\quad \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4}\\frac{\\partial N_{i}}{\\partial \\eta}y_{i}\n$$\n形函数的偏导数为：\n$$\n\\frac{\\partial N_{1}}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_{2}}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_{3}}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_{4}}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta)\n$$\n$$\n\\frac{\\partial N_{1}}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi), \\quad \\frac{\\partial N_{2}}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_{3}}{\\partial \\eta} = \\frac{1}{4}(1+\\xi), \\quad \\frac{\\partial N_{4}}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n$$\n节点坐标给出如下：$(x_1, y_1)=(0, -1)$，$(x_2, y_2)=(3.5, -1)$，$(x_3, y_3)=(-1.5, 1)$ 和 $(x_4, y_4)=(0, 1)$。我们将这些值代入雅可比分量的表达式中。\n\n对于 $J_{11} = \\partial x/\\partial \\xi$：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}[-x_1(1-\\eta) + x_2(1-\\eta) + x_3(1+\\eta) - x_4(1+\\eta)]\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{1}{4}[-(0)(1-\\eta) + (3.5)(1-\\eta) + (-1.5)(1+\\eta) - (0)(1+\\eta)] = \\frac{1}{4}[3.5 - 3.5\\eta - 1.5 - 1.5\\eta] = \\frac{1}{4}(2 - 5\\eta)\n$$\n对于 $J_{12} = \\partial x/\\partial \\eta$：\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}[-x_1(1-\\xi) - x_2(1+\\xi) + x_3(1+\\xi) + x_4(1-\\xi)]\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{1}{4}[-(0)(1-\\xi) - (3.5)(1+\\xi) + (-1.5)(1+\\xi) + (0)(1-\\xi)] = \\frac{1}{4}[-3.5 - 3.5\\xi - 1.5 - 1.5\\xi] = \\frac{1}{4}(-5 - 5\\xi) = -\\frac{5}{4}(1+\\xi)\n$$\n对于 $J_{21} = \\partial y/\\partial \\xi$：\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}[-y_1(1-\\eta) + y_2(1-\\eta) + y_3(1+\\eta) - y_4(1+\\eta)]\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{1}{4}[-(-1)(1-\\eta) + (-1)(1-\\eta) + (1)(1+\\eta) - (1)(1+\\eta)] = \\frac{1}{4}[ (1-\\eta) - (1-\\eta) + (1+\\eta) - (1+\\eta) ] = 0\n$$\n对于 $J_{22} = \\partial y/\\partial \\eta$：\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}[-y_1(1-\\xi) - y_2(1+\\xi) + y_3(1+\\xi) + y_4(1-\\xi)]\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{1}{4}[-(-1)(1-\\xi) - (-1)(1+\\xi) + (1)(1+\\xi) + (1)(1-\\xi)] = \\frac{1}{4}[1-\\xi + 1+\\xi + 1+\\xi + 1-\\xi] = \\frac{4}{4} = 1\n$$\n因此，雅可比矩阵为：\n$$\nJ(\\xi,\\eta) = \\begin{bmatrix} \\frac{1}{4}(2 - 5\\eta) & -\\frac{5}{4}(1+\\xi) \\\\ 0 & 1 \\end{bmatrix}\n$$\n雅可比行列式为：\n$$\n\\det J(\\xi,\\eta) = \\left(\\frac{1}{4}(2 - 5\\eta)\\right)(1) - \\left(-\\frac{5}{4}(1+\\xi)\\right)(0) = \\frac{1}{4}(2 - 5\\eta)\n$$\n我们必须在四个标准的 $2 \\times 2$ 高斯点处计算 $\\det J$ 的值，这些点是 $(\\xi_i, \\eta_j)$，其中 $\\xi_i, \\eta_j \\in \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$。令 $a = 1/\\sqrt{3}$。这四个点是 $(-a, -a)$、$(a, -a)$、$(a, a)$ 和 $(-a, a)$。注意 $\\det J$ 仅依赖于 $\\eta$。\n\n1. 对于 $\\eta = -1/\\sqrt{3}$ 的两个高斯点：\n   $$\n   \\det J = \\frac{1}{4}\\left(2 - 5\\left(-\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{4}\\left(2 + \\frac{5}{\\sqrt{3}}\\right)\n   $$\n   数值上，$\\det J = \\frac{1}{4}(2 + 2.88675...) = \\frac{4.88675...}{4} = 1.22168...\n   $$\n\n2. 对于 $\\eta = 1/\\sqrt{3}$ 的两个高斯点：\n   $$\n   \\det J = \\frac{1}{4}\\left(2 - 5\\left(\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{4}\\left(2 - \\frac{5}{\\sqrt{3}}\\right)\n   $$\n   数值上，$\\det J = \\frac{1}{4}(2 - 2.88675...) = \\frac{-0.88675...}{4} = -0.22168...\n   $$\n\n在高斯点处的四个行列式值为 $\\{1.22168..., 1.22168..., -0.22168..., -0.22168...\\}$。\n存在至少一个高斯点使得 $\\det J < 0$ 表明单元映射是反转的。在本例中，四个高斯点中有两个呈现出负的雅可比行列式。这样的单元在几何上是无效的，并会导致有限元分析失败。\n\n四个高斯点中 $\\det J$ 的最小值是那个负值。\n$$\n\\min(\\det J) = -0.22168...\n$$\n问题指明节点坐标的单位是米，因此雅可比行列式的单位是平方米。最终结果必须四舍五入到四位有效数字。\n$$\n\\min(\\det J) \\approx -0.2217\n$$", "answer": "$$ \\boxed{-0.2217} $$", "id": "2554541"}, {"introduction": "一个几何有效的单元是第一步，但我们还必须确保它在力学上是稳定的。单元的稳定性通过其刚度矩阵 $\\mathbf{K}_e$ 的性质来体现，具体而言，是通过其特征值来判断。零特征值对应的特征向量（或称为模式）代表了单元在变形时不储存应变能的运动方式。除了物理上必须存在的刚体运动模式外，任何额外的零能模式都是数值计算中产生的伪影，即“沙漏模式”，它会导致计算结果的失效。本编程实践旨在通过对单元刚度矩阵进行特征值分析，让你亲手揭示并理解不同单元（如常应变三角形和四节点四边形）以及不同积分方案（完全积分与减缩积分）是如何影响单元稳定性的。[@problem_id:2554569]", "problem": "编写一个程序，该程序从虚功原理和等参插值的定义出发，在二维弹性力学问题中，组装单元刚度矩阵并执行特征分析，以识别刚体模态和任何伪零能机制。具体而言，考虑在平面应力和平面应变两种假设下的常应变三角形（CST）单元和四节点四边形（Q4）单元。从单元刚度矩阵由以下双线性形式给出的基本恒等式出发：\n$$\n\\mathbf{K}_e \\;=\\; \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\, \\mathbf{D} \\, \\mathbf{B} \\; t \\; \\mathrm{d}\\Omega,\n$$\n其中，$t$ 是厚度，$\\mathbf{D}$ 是对应于平面应力或平面应变的各向同性弹性矩阵，$\\mathbf{B}$ 是通过插值函数的空间导数获得的应变-位移矩阵。实现以下内容：\n- 对于常应变三角形（CST）单元：在单元域上为常数的 $\\mathbf{B}$ 矩阵，并使用精确的面积积分。\n- 对于四节点四边形（Q4）单元：采用等参双线性插值和数值积分。使用 $2 \\times 2$ 高斯积分法则进行完全积分，使用 $1 \\times 1$ 高斯积分法则（单个中心点）进行减缩积分。\n\n对每个单元刚度矩阵 $\\mathbf{K}_e$ 进行特征分析，并计算数值上为零的特征值的数量，该数量解释为零能模态的数量。根据力学原理，在二维空间中应恰好存在三个刚体模态（两个平移和一个平面内转动）。任何额外的数值零特征值都表示存在伪机制。\n\n您的程序必须使用标准线性弹性理论，实现用于平面应力和平面应变的各向同性弹性矩阵 $\\mathbf{D}$：\n- 平面应力：\n$$\n\\mathbf{D}_{\\text{ps}} \\;=\\; \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n- 平面应变：\n$$\n\\mathbf{D}_{\\text{pe}} \\;=\\; \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n1-\\nu & \\nu & 0\\\\\n\\nu & 1-\\nu & 0\\\\\n0 & 0 & \\frac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n\n对于 Q4 单元，在局部坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 的母单元域上使用标准的双线性等参形函数，计算积分点处的雅可比矩阵 $\\mathbf{J}$ 及其行列式，并通过 $\\mathbf{J}^{-1}$ 将导数转换到物理坐标系。对于完全积分，使用位于 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ 的四个高斯点，每个点的权为 $1$；对于减缩积分，使用位于 $(0,0)$ 的单个点，总权为 $4$。\n\n通过将每个特征值的绝对值与一个和该情况下最大特征值模成比例的容差进行比较，来数值上检测零特征值的数量。使用基于谱半径的相对容差 $10^{-8}$ 和一个小的绝对下限，以使最终计数为一个整数。\n\n测试套件。您的程序必须按顺序运行以下五个测试用例，并返回每个用例中接近零的特征值的数量：\n\n1. CST，平面应力。节点位于 $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, $(x_3,y_3)=(0,1)$，厚度 $t=0.05\\,\\mathrm{m}$，杨氏模量 $E=210\\times 10^9\\,\\mathrm{Pa}$，泊松比 $\\nu=0.29$。\n\n2. Q4，平面应力，完全积分。节点位于 $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1,0)$, $(x_3,y_3)=(1,1)$, $(x_4,y_4)=(0,1)$，厚度 $t=0.05\\,\\mathrm{m}$，杨氏模量 $E=210\\times 10^9\\,\\mathrm{Pa}$，泊松比 $\\nu=0.29$。\n\n3. Q4，平面应力，减缩积分。与用例 2 具有相同的几何形状和材料，但使用位于 $(\\xi,\\eta)=(0,0)$ 的 $1\\times 1$ 高斯积分法则。\n\n4. Q4，平面应力，在扭曲单元上的减缩积分。节点位于 $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0.2)$, $(x_3,y_3)=(2.2,1.8)$, $(x_4,y_4)=(0,1)$，厚度 $t=0.1\\,\\mathrm{m}$，杨氏模量 $E=70\\times 10^9\\,\\mathrm{Pa}$，泊松比 $\\nu=0.25$。\n\n5. Q4，平面应变，完全积分。节点位于 $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0)$, $(x_3,y_3)=(2,1)$, $(x_4,y_4)=(0,1)$，厚度 $t=0.1\\,\\mathrm{m}$，杨氏模量 $E=1\\times 10^6\\,\\mathrm{Pa}$，泊松比 $\\nu=0.49$。\n\n对于每个用例，计算单元刚度矩阵接近零的特征值的整数数量。您的程序的最终输出必须是单行文本，包含一个 Python 风格的列表，其中按测试用例的顺序包含五个整数，无单位（整数是无量纲的）。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[3,3,5,5,3]$）。", "solution": "该问题是良定的，并基于计算固体力学的既定原理。它要求实现和分析有限元方法中的基本单元类型。我们将着手进行推导和求解。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 的基础是虚功原理，该原理将内虚功与外虚功相等同。对于线性弹性连续体，这导出了势能的表达式，其驻值性产生了平衡方程。单元刚度矩阵由应变能项导出，该项由应变能密度的体积分给出。对于厚度均匀为 $t$ 的单元 $\\Omega_e$，其表达式为：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, t \\, \\mathrm{d}\\Omega\n$$\n此处，$\\mathbf{B}$ 是应变-位移矩阵，它将工程应变向量 $\\boldsymbol{\\epsilon} = [\\epsilon_x, \\epsilon_y, \\gamma_{xy}]^\\mathsf{T}$ 与节点位移向量 $\\mathbf{d}_e$ 联系起来。矩阵 $\\mathbf{D}$ 是材料本构矩阵，通过 $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\epsilon}$ 将应力 $\\boldsymbol{\\sigma}$ 与应变 $\\boldsymbol{\\epsilon}$ 联系起来。\n\n单元内的位移场是使用形函数 $\\mathbf{N}$ 从节点位移 $\\mathbf{d}_e$ 插值得到的：\n$$\n\\mathbf{u}(x,y) = \\mathbf{N}(x,y) \\mathbf{d}_e\n$$\n通过将运动学微分算子 $\\mathcal{L}$ 应用于位移场来获得应变：\n$$\n\\boldsymbol{\\epsilon} = \\mathcal{L} \\mathbf{u} = \\mathcal{L} (\\mathbf{N} \\mathbf{d}_e) = (\\mathcal{L} \\mathbf{N}) \\mathbf{d}_e\n$$\n由此，应变-位移矩阵被确定为 $\\mathbf{B} = \\mathcal{L}\\mathbf{N}$。对于二维问题，该算子为：\n$$\n\\mathcal{L} = \\begin{bmatrix} \\frac{\\partial}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial}{\\partial y} \\\\ \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial x} \\end{bmatrix}\n$$\n\n材料行为由各向同性弹性矩阵 $\\mathbf{D}$ 描述。对于指定的二维状态：\n-   平面应力（$\\sigma_z = 0$）：适用于薄结构。该矩阵为：\n    $$\n    \\mathbf{D}_{\\text{ps}} = \\frac{E}{1-\\nu^2}\\begin{bmatrix}\n    1 & \\nu & 0 \\\\\n    \\nu & 1 & 0 \\\\\n    0 & 0 & \\frac{1-\\nu}{2}\n    \\end{bmatrix}\n    $$\n-   平面应变（$\\epsilon_z = 0$）：适用于平面外变形受约束的厚结构。该矩阵为：\n    $$\n    \\mathbf{D}_{\\text{pe}} = \\frac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}\n    1-\\nu & \\nu & 0 \\\\\n    \\nu & 1-\\nu & 0 \\\\\n    0 & 0 & \\frac{1-2\\nu}{2}\n    \\end{bmatrix}\n    $$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n我们现在将为每种单元类型建立刚度矩阵的公式。\n\n**常应变三角形（CST）单元**\n\nCST 是一个 3 节点三角形单元，每个节点有 2 个自由度（DOF），总共有 6 个自由度。位移场是线性插值的：\n$$\nu(x,y) = N_1 u_1 + N_2 u_2 + N_3 u_3 \\quad \\text{and} \\quad v(x,y) = N_1 v_1 + N_2 v_2 + N_3 v_3\n$$\n线性形函数 $N_i(x,y)$ 具有恒定的一阶导数。因此，应变分量 $\\epsilon_x = \\partial u/\\partial x$、$\\epsilon_y = \\partial v/\\partial y$ 和 $\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x$ 在整个单元内是常数，该单元也因此得名。应变-位移矩阵 $\\mathbf{B}$ 是一个常数的 $3 \\times 6$ 矩阵。\n对于节点 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 按逆时针排序的三角形，其 $\\mathbf{B}$ 矩阵由下式给出：\n$$\n\\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\n其中 $A$ 是三角形的面积。由于 $\\mathbf{B}$、$\\mathbf{D}$ 和 $t$ 都是常数，刚度矩阵的积分简化为一个直接乘积：\n$$\n\\mathbf{K}_e = \\mathbf{B}^\\mathsf{T} \\mathbf{D} \\mathbf{B} \\, (A \\cdot t)\n$$\n\n**四节点四边形（Q4）单元**\n\nQ4 单元是一个 4 节点单元，总共有 8 个自由度。其公式是等参的，意味着使用相同的形函数来插值几何形状和位移场。我们使用一个由局部坐标 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 定义的标准母单元域。双线性形函数为：\n$$\nN_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i \\xi)(1 + \\eta_i \\eta)\n$$\n其中 $(\\xi_i, \\eta_i)$ 是母单元域中节点 $i$ 的坐标：对于节点 $1, 2, 3, 4$，分别为 $(-1,-1), (1,-1), (1,1), (-1,1)$。\n\n物理坐标 $(x,y)$ 从母单元坐标映射而来：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{and} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n应变-位移矩阵 $\\mathbf{B}$ 需要对物理坐标 $(x,y)$ 求导，这些导数是通过链式法则，从对母单元坐标 $(\\xi, \\eta)$ 的导数获得的，其中涉及到雅可比矩阵 $\\mathbf{J}$：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} \\quad \\text{where} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n此时 $\\mathbf{B}$ 矩阵是 $(\\xi, \\eta)$ 的函数。刚度矩阵的积分被转换到母单元域：\n$$\n\\mathbf{K}_e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\, \\det(\\mathbf{J}) \\, t \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\n该积分使用高斯积分进行数值计算：\n$$\n\\mathbf{K}_e \\approx t \\sum_{i=1}^{n_p} \\sum_{j=1}^{n_p} w_i w_j \\left( \\mathbf{B}(\\xi_i, \\eta_j)^\\mathsf{T} \\mathbf{D} \\mathbf{B}(\\xi_i, \\eta_j) \\det(\\mathbf{J}(\\xi_i, \\eta_j)) \\right)\n$$\n其中 $(\\xi_i, \\eta_j)$ 是高斯点，$w_i, w_j$是相应的权。\n-   **完全积分：** 使用 $2 \\times 2$ 法则（$n_p=2$）。积分点为 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，所有权重均为 $1$。该法则可以精确积分最高 3 次的多项式，这足以精确积分一个矩形 Q4 单元的刚度矩阵。\n-   **减缩积分：** 使用 $1 \\times 1$ 法则（$n_p=1$）。单点位于中心 $(\\xi, \\eta) = (0,0)$，权重为 $w_1 \\cdot w_1 = 4$。此方法计算效率高，但可能引入伪零能模态，称为沙漏现象。\n\n**刚度矩阵的特征分析**\n\n$\\mathbf{K}_e$ 的特征值代表了其相应特征模态（变形形状）的能量代价。零特征值对应于零能模态，即一种不产生应变也就不产生应力的变形。对于二维空间中任何未约束的单元，必须恰好有 3 个这样的模态：2 个刚体平移和 1 个平面内刚体转动。这些是物理上正确的。\n\n任何额外的零能模态都是伪的、非物理的、由单元构造导致的人为产物。它们被称为“沙漏模态”，并表明单元可以在不储存任何应变能的情况下以某种模式变形，从而使其变得不稳定。任务是对每个计算出的 $\\mathbf{K}_e$ 进行特征分析，并计算数值上为零的特征值的数量。如果一个特征值 $\\lambda$ 的绝对值小于一个相对于谱半径（最大绝对特征值）$\\lambda_{\\text{max}}$ 的容差，则认为其为零：\n$$\n|\\lambda| < 10^{-8} \\cdot \\lambda_{\\text{max}}\n$$\n这个计数揭示了每种单元配置下的刚体模态数量加上任何伪机制的数量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_D(E, nu, analysis_type):\n    \"\"\"\n    Computes the isotropic elasticity matrix D for plane stress or plane strain.\n    \"\"\"\n    if analysis_type == \"plane_stress\":\n        if abs(1.0 - nu**2) < 1e-12:\n            raise ValueError(\"Invalid Poisson's ratio for plane stress: 1 - nu^2 is zero.\")\n        factor = E / (1.0 - nu**2)\n        D = factor * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n    elif analysis_type == \"plane_strain\":\n        denom = (1.0 + nu) * (1.0 - 2.0 * nu)\n        if abs(denom) < 1e-12:\n            raise ValueError(\"Invalid Poisson's ratio for plane strain: (1+nu)(1-2*nu) is zero.\")\n        factor = E / denom\n        D = factor * np.array([\n            [1.0 - nu, nu, 0.0],\n            [nu, 1.0 - nu, 0.0],\n            [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n        ])\n    else:\n        raise ValueError(f\"Invalid analysis type: {analysis_type}\")\n    return D\n\ndef stiffness_cst(nodes, t, E, nu, analysis_type):\n    \"\"\"\n    Computes the stiffness matrix for a Constant Strain Triangle (CST) element.\n    \"\"\"\n    # Nodal coordinates\n    x1, y1 = nodes[0]\n    x2, y2 = nodes[1]\n    x3, y3 = nodes[2]\n\n    # Area of the triangle\n    A = 0.5 * np.linalg.det(np.array([[1.0, x1, y1], [1.0, x2, y2], [1.0, x3, y3]]))\n    if A <= 1e-12:\n        raise ValueError(\"Degenerate or inverted triangle element.\")\n\n    # Components for the constant B matrix\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    c1 = x3 - x2\n    c2 = x1 - x3\n    c3 = x2 - x1\n\n    # B matrix (strain-displacement matrix)\n    B = (1.0 / (2.0 * A)) * np.array([\n        [b1, 0.0, b2, 0.0, b3, 0.0],\n        [0.0, c1, 0.0, c2, 0.0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ])\n\n    D = get_D(E, nu, analysis_type)\n    \n    Ke = B.T @ D @ B * A * t\n    return Ke\n\ndef stiffness_q4(nodes, t, E, nu, analysis_type, integration_rule):\n    \"\"\"\n    Computes the stiffness matrix for a 4-node quadrilateral (Q4) element.\n    \"\"\"\n    D = get_D(E, nu, analysis_type)\n\n    if integration_rule == \"full\":  # 2x2\n        gauss_points_1d = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\n        gauss_weights_1d = [1.0, 1.0]\n    elif integration_rule == \"reduced\":  # 1x1\n        gauss_points_1d = [0.0]\n        gauss_weights_1d = [2.0]\n    else:\n        raise ValueError(f\"Invalid integration rule: {integration_rule}\")\n\n    Ke = np.zeros((8, 8))\n\n    for xi_idx, xi in enumerate(gauss_points_1d):\n        for eta_idx, eta in enumerate(gauss_points_1d):\n            if integration_rule == \"full\":\n                weight = gauss_weights_1d[xi_idx] * gauss_weights_1d[eta_idx]\n            else: # reduced\n                weight = gauss_weights_1d[0] * gauss_weights_1d[0]\n            \n            # Derivatives of shape functions w.r.t. parent coordinates (xi, eta)\n            # N_derivs_parent[0, i] = dN_i/d_xi, N_derivs_parent[1, i] = dN_i/d_eta\n            N_derivs_parent = 0.25 * np.array([\n                [-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)],\n                [-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)]\n            ])\n\n            # Jacobian matrix\n            # Note: J definition in problem text is [dx/dxi, dy/dxi; dx/deta, dy/deta]\n            # My nodes is (4,2) array of coords. N_derivs_parent is (2,4). J = N_derivs_parent @ nodes is (2,2)\n            # J[0,0] = dN/dxi . x = dx/dxi\n            # J[0,1] = dN/dxi . y = dy/dxi\n            # J[1,0] = dN/deta . x = dx/deta\n            # J[1,1] = dN/deta . y = dy/deta\n            J = N_derivs_parent @ nodes\n            detJ = np.linalg.det(J)\n            if detJ <= 1e-12:\n                raise ValueError(\"Jacobian determinant is non-positive. Check element geometry or node ordering.\")\n\n            # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n            J_inv = np.linalg.inv(J)\n            N_derivs_physical = J_inv @ N_derivs_parent\n\n            # B matrix assembly\n            B = np.zeros((3, 8))\n            for k in range(4):\n                dNdX_k = N_derivs_physical[0, k]\n                dNdY_k = N_derivs_physical[1, k]\n                B[0, 2*k]      = dNdX_k\n                B[1, 2*k + 1]  = dNdY_k\n                B[2, 2*k]      = dNdY_k\n                B[2, 2*k + 1]  = dNdX_k\n\n            Ke += B.T @ D @ B * detJ * weight * t\n            \n    return Ke\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'type': 'CST', 'nodes': np.array([[0,0],[1,0],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': None},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': 'full'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[1,0],[1,1],[0,1]]), 't': 0.05, 'E': 210e9, 'nu': 0.29, 'analysis': 'plane_stress', 'integration': 'reduced'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[2,0.2],[2.2,1.8],[0,1]]), 't': 0.1, 'E': 70e9, 'nu': 0.25, 'analysis': 'plane_stress', 'integration': 'reduced'},\n        {'type': 'Q4',  'nodes': np.array([[0,0],[2,0],[2,1],[0,1]]), 't': 0.1, 'E': 1e6, 'nu': 0.49, 'analysis': 'plane_strain', 'integration': 'full'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        if case['type'] == 'CST':\n            Ke = stiffness_cst(case['nodes'], case['t'], case['E'], case['nu'], case['analysis'])\n        elif case['type'] == 'Q4':\n            Ke = stiffness_q4(case['nodes'], case['t'], case['E'], case['nu'], case['analysis'], case['integration'])\n        else:\n            raise ValueError(f\"Unknown element type specified in test case: {case['type']}\")\n            \n        # Eigenanalysis\n        # Stiffness matrix is real and symmetric, so use eigvalsh for efficiency.\n        eigenvalues = np.linalg.eigvalsh(Ke)\n        \n        # Count near-zero eigenvalues based on relative tolerance\n        max_eig_abs = np.max(np.abs(eigenvalues))\n        \n        zero_eig_count = 0\n        if max_eig_abs < 1e-9: # Safeguard for a nearly zero matrix\n            # If all eigenvalues are effectively zero, all are zero modes\n            zero_eig_count = len(eigenvalues)\n        else:\n            rel_tolerance = 1e-8 * max_eig_abs\n            abs_tolerance = 1e-9 # A small absolute floor tolerance\n            zero_eig_count = np.sum(np.abs(eigenvalues) < max(rel_tolerance, abs_tolerance))\n            \n        results.append(int(zero_eig_count))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    # Minor correction in the original provided code's weight handling for simplicity and correctness.\n    # The original logic would miscalculate weight for reduced integration inside the loops.\n    # This version is correct.\n    import sys\n    # The problem description for Q4 integration rule is slightly ambiguous.\n    # For 1x1 rule: one point at (0,0) with total weight 4.\n    # My implementation uses a loop over gauss_points_1d = [0.0]. The weight should be 2.0*2.0 = 4.0.\n    # The original provided code had a bug in weight calculation, now fixed.\n    \n    # Correction to Q4 stiffness routine to handle weight correctly for reduced integration.\n    original_stiffness_q4 = stiffness_q4\n    def fixed_stiffness_q4(nodes, t, E, nu, analysis_type, integration_rule):\n        D = get_D(E, nu, analysis_type)\n\n        if integration_rule == \"full\":  # 2x2\n            gauss_points_xi = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\n            gauss_points_eta = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\n            gauss_weights_xi = [1.0, 1.0]\n            gauss_weights_eta = [1.0, 1.0]\n        elif integration_rule == \"reduced\":  # 1x1\n            gauss_points_xi = [0.0]\n            gauss_points_eta = [0.0]\n            gauss_weights_xi = [2.0]\n            gauss_weights_eta = [2.0]\n        else:\n            raise ValueError(f\"Invalid integration rule: {integration_rule}\")\n\n        Ke = np.zeros((8, 8))\n\n        for w_xi, xi in zip(gauss_weights_xi, gauss_points_xi):\n            for w_eta, eta in zip(gauss_weights_eta, gauss_points_eta):\n                weight = w_xi * w_eta\n\n                N_derivs_parent = 0.25 * np.array([\n                    [-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)],\n                    [-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)]\n                ])\n\n                J = N_derivs_parent @ nodes\n                detJ = np.linalg.det(J)\n                if detJ <= 1e-12:\n                    raise ValueError(\"Jacobian is non-positive.\")\n                \n                J_inv = np.linalg.inv(J)\n                N_derivs_physical = J_inv @ N_derivs_parent\n\n                B = np.zeros((3, 8))\n                for k in range(4):\n                    dNdX_k, dNdY_k = N_derivs_physical[:, k]\n                    B[0, 2*k]      = dNdX_k\n                    B[1, 2*k + 1]  = dNdY_k\n                    B[2, 2*k]      = dNdY_k\n                    B[2, 2*k + 1]  = dNdX_k\n\n                Ke += B.T @ D @ B * detJ * weight * t\n        return Ke\n    \n    # Replace the function with the more robust version for execution\n    stiffness_q4 = fixed_stiffness_q4\n    \n    solve()\n```", "id": "2554569"}, {"introduction": "在确认了单元的几何有效性和力学稳定性之后，我们最关心的问题便是其计算精度。有限元解的误差主要来源于其形函数对真实位移场的插值能力。为了量化这种插值误差，一种强大的技术是“制造解法”（Method of Manufactured Solutions），即预设一个精确的解，并用它来评估有限元近似的优劣。本次编程实践将基于一个已知的二次位移场，引导你计算并比较常应变三角形（CST）单元和双线性四边形（Q4）单元在计算应力场时的误差。通过这个过程，你将直观地理解单元的插值阶次如何直接影响其计算精度，这是在实际工程问题中选择合适单元类型的关键考量。[@problem_id:2554580]", "problem": "编写一个程序，该程序在平面应力和平面应变两种假设下，针对二维线性弹性问题，构造并比较两种标准有限元插值（常应变三角形（CST）和双线性四边形（Q4））的逐单元应力近似误差。此比较必须由一个已知的二次位移场驱动，以确保精确的应变场和应力场可以解析得到。\n\n本任务需要完全基于以下原理和核心定义进行：\n- 运动学：小应变张量是位移的对称梯度。根据工程剪切应变约定，面内应变向量为\n$$\n\\boldsymbol{\\varepsilon}(x,y) = \\begin{bmatrix}\\varepsilon_{xx}(x,y) \\\\ \\varepsilon_{yy}(x,y) \\\\ \\gamma_{xy}(x,y)\\end{bmatrix}\n= \\begin{bmatrix}\\dfrac{\\partial u_x}{\\partial x} \\\\ \\dfrac{\\partial u_y}{\\partial y} \\\\ \\dfrac{\\partial u_x}{\\partial y} + \\dfrac{\\partial u_y}{\\partial x}\\end{bmatrix}.\n$$\n- 本构律：在线性弹性假设下，柯西应力向量为\n$$\n\\boldsymbol{\\sigma}(x,y) = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(x,y),\n$$\n其中，平面应力的本构矩阵为\n$$\n\\mathbf{D}_{\\mathrm{ps}} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\dfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n平面应变的本构矩阵为\n$$\n\\mathbf{D}_{\\mathrm{pe}} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n1-\\nu & \\nu & 0 \\\\\n\\nu & 1-\\nu & 0 \\\\\n0 & 0 & \\dfrac{1-2\\nu}{2}\n\\end{bmatrix}.\n$$\n- 插值：有限元位移场是通过形函数对节点位移进行插值来构造的。对于 CST，形函数在每个三角形上是线性的，从而产生分片常数应变。对于仿射、轴对齐矩形网格上的 Q4，形函数在每个四边形上是双线性的，从而产生分片线性应变。\n\n使用单位正方形域 $[0,1]\\times[0,1]$，并用均匀的 $N\\times N$ 轴对齐正方形网格对其进行离散化。对于 CST 近似，将每个正方形沿左下到右上的对角线分割成两个三角形。对于 Q4 近似，在每个正方形上使用双线性形函数。不要组装任何全局系统；相反，对于每个单元，通过在单元节点处采样精确位移场来设置单元节点位移，使用单元的形函数在单元内部插值位移场，通过微分求得近似应变 $\\boldsymbol{\\varepsilon}^h$，并计算近似应力 $\\boldsymbol{\\sigma}^h = \\mathbf{D}\\boldsymbol{\\varepsilon}^h$。\n\n采用如下的精确位移场\n$$\nu_x(x,y) = a_1 x^2 + a_2 x y + a_3 y^2 + a_4 x + a_5 y + a_6,\\quad\nu_y(x,y) = b_1 x^2 + b_2 x y + b_3 y^2 + b_4 x + b_5 y + b_6,\n$$\n固定系数为\n$$\na_1=1,\\; a_2=\\tfrac{1}{2},\\; a_3=\\tfrac{1}{5},\\; a_4=\\tfrac{1}{10},\\; a_5=\\tfrac{1}{20},\\; a_6=\\tfrac{1}{100},\\\\\nb_1=-\\tfrac{3}{10},\\; b_2=\\tfrac{2}{5},\\; b_3=\\tfrac{9}{10},\\; b_4=\\tfrac{1}{5},\\; b_5=-\\tfrac{1}{10},\\; b_6=-\\tfrac{1}{50}.\n$$\n由此，通过微分计算精确应变 $\\boldsymbol{\\varepsilon}(x,y)$ 和精确应力 $\\boldsymbol{\\sigma}(x,y) = \\mathbf{D}\\boldsymbol{\\varepsilon}(x,y)$。\n\n对于误差测量，使用相对 $L^2$ 型应力误差范数\n$$\n\\eta = \\left(\\frac{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}(x,y) - \\boldsymbol{\\sigma}^h(x,y) \\rVert_2^2 \\, \\mathrm{d}\\Omega}{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}(x,y) \\rVert_2^2 \\, \\mathrm{d}\\Omega}\\right)^{1/2},\n$$\n该范数是无量纲的。通过在每个单元上使用精确或足够精确的高斯求积来数值逼近积分：\n- 对于 CST 三角形，使用三角形上的二次精确求积法则（三个等权重的点）。\n- 对于矩形上的 Q4 四边形，在自然坐标中使用张量积 $2\\times 2$ 高斯求积。\n\n你的程序必须：\n- 通过 $\\mathbf{D}_{\\mathrm{ps}}$ 和 $\\mathbf{D}_{\\mathrm{pe}}$ 实现平面应力和平面应变。\n- 按描述实现 CST 和 Q4 单元的运动学。\n- 对于每个测试用例，计算两个数值：CST 相对误差 $\\eta_{\\mathrm{CST}}$ 和 Q4 相对误差 $\\eta_{\\mathrm{Q4}}$。\n\n使用以下参数集作为测试套件，其中 $E$ 是杨氏模量（单位：帕斯卡），$\\nu$ 是泊松比。所有输出都必须报告为无量纲的十进制数（无物理单位）：\n- 测试 $1$：平面应力， $E=200\\times 10^9$， $\\nu=0.3$， $N=1$。\n- 测试 $2$：平面应力， $E=200\\times 10^9$， $\\nu=0.3$， $N=4$。\n- 测试 $3$：平面应变， $E=70\\times 10^9$， $\\nu=0.25$， $N=2$。\n- 测试 $4$：平面应变， $E=70\\times 10^9$， $\\nu=0$， $N=3$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含 $8$ 个结果，以逗号分隔的列表形式包含在方括号中，顺序如下\n$$\n[\\eta_{\\mathrm{CST}}^{(1)},\\eta_{\\mathrm{Q4}}^{(1)},\\eta_{\\mathrm{CST}}^{(2)},\\eta_{\\mathrm{Q4}}^{(2)},\\eta_{\\mathrm{CST}}^{(3)},\\eta_{\\mathrm{Q4}}^{(3)},\\eta_{\\mathrm{CST}}^{(4)},\\eta_{\\mathrm{Q4}}^{(4)}].\n$$", "solution": "我们从运动学和本构基础开始。位移场被指定为关于 $x$ 和 $y$ 的二次多项式，因此通过微分得到的精确应变场 $\\boldsymbol{\\varepsilon}(x,y)$，\n$$\n\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x},\\quad\n\\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y},\\quad\n\\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x},\n$$\n是关于 $(x,y)$ 的线性函数。精确应力场可由线性弹性本构矩阵 $\\mathbf{D}$ 得到：\n$$\n\\boldsymbol{\\sigma}(x,y) = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(x,y).\n$$\n我们计算相对 $L^2$ 型应力误差\n$$\n\\eta = \\left(\\frac{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^h \\rVert_2^2 \\, \\mathrm{d}\\Omega}{\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma} \\rVert_2^2 \\, \\mathrm{d}\\Omega}\\right)^{1/2},\n$$\n其中 $\\boldsymbol{\\sigma}^h$ 表示通过对精确节点位移进行插值并在单元内微分得到的有限元应力。这种设置在不求解平衡方程的情况下，隔离了插值误差。\n\n对于常应变三角形（CST），单元形函数是关于 $(x,y)$ 的线性函数，因此位移插值是线性的，其梯度以及应变 $\\boldsymbol{\\varepsilon}^h$ 在每个三角形内部是恒定的。对于一个节点为 $\\left(x_i,y_i\\right)$, $i\\in\\{1,2,3\\}$ 的三角形，其应变-位移矩阵 $\\mathbf{B}$ 为\n$$\n\\mathbf{B} = \\frac{1}{2A}\n\\begin{bmatrix}\nb_1 & 0 & b_2 & 0 & b_3 & 0 \\\\\n0 & c_1 & 0 & c_2 & 0 & c_3 \\\\\nc_1 & b_1 & c_2 & b_2 & c_3 & b_3\n\\end{bmatrix},\n$$\n其中 $A$ 是三角形面积，$(b_i,c_i)$ 是几何系数\n$$\nb_1 = y_2 - y_3,\\quad b_2 = y_3 - y_1,\\quad b_3 = y_1 - y_2; \\quad\nc_1 = x_3 - x_2,\\quad c_2 = x_1 - x_3,\\quad c_3 = x_2 - x_1.\n$$\n给定节点位移向量 $\\mathbf{d}_e = [u_1,v_1,u_2,v_2,u_3,v_3]^\\top$（通过在三角形节点处对精确位移进行采样来填充），单元应变为 $\\boldsymbol{\\varepsilon}^h = \\mathbf{B}\\mathbf{d}_e$，单元应力为 $\\boldsymbol{\\sigma}^h = \\mathbf{D}\\boldsymbol{\\varepsilon}^h$，两者在三角形上都是常数。由于精确应力是 $(x,y)$ 的线性函数，而 CST 应力是常数，它们的差是线性的；其范数的平方是一个二次多项式。我们使用重心坐标点为 $(\\tfrac{2}{3},\\tfrac{1}{6},\\tfrac{1}{6})$ 及其置换、权重均为 $\\tfrac{1}{3}$ 的二次三点高斯求积法则，并按三角形面积进行缩放，从而在每个三角形上精确地对其进行积分。\n\n对于轴对齐矩形单元上的双线性四边形（Q4），从自然坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 的等参映射采用双线性形函数\n$$\nN_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n位移插值为\n$$\n\\mathbf{u}^h(\\xi,\\eta) = \\sum_{a=1}^4 N_a(\\xi,\\eta)\\,\\mathbf{u}_a,\n$$\n其中 $\\mathbf{u}_a$ 是四边形顶点的精确节点位移。应变通过对 $\\mathbf{u}^h$ 关于物理坐标求导得出。使用雅可比矩阵 $\\mathbf{J}=\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$ 和链式法则，\n$$\n\\begin{bmatrix}\n\\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y}\n\\end{bmatrix}\n= \\mathbf{J}^{-1}\n\\begin{bmatrix}\n\\frac{\\partial N_a}{\\partial \\xi} \\\\ \\frac{\\partial N_a}{\\partial \\eta}\n\\end{bmatrix},\n$$\n我们在每个求积点组装 Q4 的标准 $\\mathbf{B}$ 矩阵，使用 $\\mathbf{d}_e=[u_1,v_1,u_2,v_2,u_3,v_3,u_4,v_4]^\\top$ 计算 $\\boldsymbol{\\varepsilon}^h = \\mathbf{B}\\mathbf{d}_e$，然后计算 $\\boldsymbol{\\sigma}^h=\\mathbf{D}\\boldsymbol{\\varepsilon}^h$。由于在仿射映射的矩形上，精确应力和 Q4 应力都是 $(x,y)$ 的线性函数，它们的差也是线性的，其范数的平方是二次的。我们通过在 $(\\xi,\\eta)$ 中使用张量积 $2\\times 2$ 高斯求积，其求积点在 $\\xi,\\eta=\\pm 1/\\sqrt{3}$，权重为单位权重，并按 $\\det\\mathbf{J}$ 进行缩放，从而精确地对其积分。\n\n对于这两种单元类型，我们通过求积逐单元累加分子\n$$\n\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}-\\boldsymbol{\\sigma}^h\\rVert_2^2 \\,\\mathrm{d}\\Omega\n$$\n和分母\n$$\n\\int_{\\Omega} \\lVert \\boldsymbol{\\sigma}\\rVert_2^2 \\,\\mathrm{d}\\Omega\n$$\n以获得相对误差 $\\eta$。\n\n为什么对于二次位移场，Q4 与 CST 的结果不同：\n- 精确应变是 $(x,y)$ 的线性函数，因为位移是二次的。CST 应变在每个三角形上是常数，这是对该区域上线性场的最佳常数逼近，导致了一阶（$\\mathcal{O}(h)$）的梯度误差，且其常数项相对较大。\n- Q4 应变在每个矩形上是线性的（在仿射网格上），能更紧密地匹配精确的线性变化。虽然双线性位移不能精确地再现纯 $x^2$ 或 $y^2$ 项，但其导数是线性的，由于能部分再现混合项和具有更好的局部拟合性，其产生的一阶（$\\mathcal{O}(h)$）梯度误差具有较小的常数项。\n- 因此，对于相同的网格，我们预期 $\\eta_{\\mathrm{Q4}}<\\eta_{\\mathrm{CST}}$，并且随着 $N$ 的增加（网格细化），两者都会减小。\n\n程序实现：\n- 通过对给定的二次多项式进行解析微分得到精确应变。\n- 通过 $\\mathbf{D}_{\\mathrm{ps}}$ 和 $\\mathbf{D}_{\\mathrm{pe}}$ 得到精确应力。\n- CST：通过三角形 $\\mathbf{B}$ 矩阵得到单元常数应力 $\\boldsymbol{\\sigma}^h$，并使用二次三角形求积进行误差积分。\n- Q4：通过等参微分和 $2\\times 2$ 高斯求积得到逐点应力 $\\boldsymbol{\\sigma}^h(\\xi,\\eta)$。\n- 为四个指定的测试聚合相对误差。输出是包含八个无量纲数的单行文本，按要求顺序排列。\n\n此设计遵循了基本的运动学和本构律，在不考虑全局平衡的情况下隔离了插值效应，并使用了对于误差被积函数中出现的多项式次数而言是精确的求积法则。", "answer": "```python\nimport numpy as np\n\n# Finite Element interpolation error comparison for CST vs Q4\n# under plane stress / plane strain, using a known quadratic displacement field.\n\ndef constitutive_matrix(E, nu, mode):\n    if mode == 'plane_stress':\n        fac = E / (1.0 - nu**2)\n        D = fac * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n    elif mode == 'plane_strain':\n        fac = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        D = fac * np.array([\n            [1.0 - nu, nu, 0.0],\n            [nu, 1.0 - nu, 0.0],\n            [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n        ])\n    else:\n        raise ValueError(\"Unknown mode\")\n    return D\n\n# Quadratic displacement coefficients\na1, a2, a3, a4, a5, a6 = 1.0, 0.5, 0.2, 0.1, 0.05, 0.01\nb1, b2, b3, b4, b5, b6 = -0.3, 0.4, 0.9, 0.2, -0.1, -0.02\n\ndef exact_u(x, y):\n    ux = a1*x*x + a2*x*y + a3*y*y + a4*x + a5*y + a6\n    uy = b1*x*x + b2*x*y + b3*y*y + b4*x + b5*y + b6\n    return ux, uy\n\ndef exact_strain(x, y):\n    dux_dx = 2.0*a1*x + a2*y + a4\n    dux_dy = a2*x + 2.0*a3*y + a5\n    duy_dx = 2.0*b1*x + b2*y + b4\n    duy_dy = b2*x + 2.0*b3*y + b5\n    exx = dux_dx\n    eyy = duy_dy\n    gxy = dux_dy + duy_dx\n    return np.array([exx, eyy, gxy])\n\ndef exact_sigma(x, y, D):\n    return D @ exact_strain(x, y)\n\n# Triangle area\ndef tri_area(coords):\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    return 0.5 * ((x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1))\n\ndef B_matrix_CST(coords):\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    A2 = (x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1)  # 2*A\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    c1 = x3 - x2\n    c2 = x1 - x3\n    c3 = x2 - x1\n    B = np.array([\n        [b1, 0.0, b2, 0.0, b3, 0.0],\n        [0.0, c1, 0.0, c2, 0.0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ]) / A2\n    A = 0.5 * A2\n    return B, A\n\n# Triangle quadrature: degree-2 exact (three points)\ntri_qw = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0])\ntri_qL = np.array([\n    [2.0/3.0, 1.0/6.0, 1.0/6.0],\n    [1.0/6.0, 2.0/3.0, 1.0/6.0],\n    [1.0/6.0, 1.0/6.0, 2.0/3.0]\n])\n\n# Q4 shape functions and derivatives\ndef q4_shape_funcs(xi, eta):\n    N = np.array([\n        0.25*(1 - xi)*(1 - eta),\n        0.25*(1 + xi)*(1 - eta),\n        0.25*(1 + xi)*(1 + eta),\n        0.25*(1 - xi)*(1 + eta)\n    ])\n    dN_dxi = np.array([\n        -0.25*(1 - eta),\n        0.25*(1 - eta),\n        0.25*(1 + eta),\n        -0.25*(1 + eta)\n    ])\n    dN_deta = np.array([\n        -0.25*(1 - xi),\n        -0.25*(1 + xi),\n        0.25*(1 + xi),\n        0.25*(1 - xi)\n    ])\n    return N, dN_dxi, dN_deta\n\ngauss_pts = [-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)]\ngauss_wts = [1.0, 1.0]\n\ndef compute_errors(Ndiv, E, nu, mode):\n    D = constitutive_matrix(E, nu, mode)\n    # Build mesh node coordinates along x and y\n    xs = np.linspace(0.0, 1.0, Ndiv+1)\n    ys = np.linspace(0.0, 1.0, Ndiv+1)\n    # CST accumulators\n    num_cst = 0.0\n    den_cst = 0.0\n    # Q4 accumulators\n    num_q4 = 0.0\n    den_q4 = 0.0\n\n    for i in range(Ndiv):\n        for j in range(Ndiv):\n            # four corners of the square (Q4)\n            x0, y0 = xs[i], ys[j]\n            x1, y1 = xs[i+1], ys[j]\n            x2, y2 = xs[i+1], ys[j+1]\n            x3, y3 = xs[i], ys[j+1]\n            quad_coords = np.array([[x0,y0],[x1,y1],[x2,y2],[x3,y3]])\n\n            # Q4 contribution\n            # Nodal displacements for Q4 element\n            de_q4 = []\n            for (x, y) in quad_coords:\n                ux, uy = exact_u(x, y)\n                de_q4.extend([ux, uy])\n            de_q4 = np.array(de_q4)\n\n            # 2x2 gauss integration\n            for w_xi, xi in zip(gauss_wts, gauss_pts):\n                for w_eta, eta in zip(gauss_wts, gauss_pts):\n                    N, dN_dxi, dN_deta = q4_shape_funcs(xi, eta)\n                    # Map to physical\n                    x = np.dot(N, quad_coords[:,0])\n                    y = np.dot(N, quad_coords[:,1])\n                    # Jacobian\n                    J = np.zeros((2,2))\n                    J[0,0] = np.dot(dN_dxi, quad_coords[:,0])    # dx/dxi\n                    J[0,1] = np.dot(dN_dxi, quad_coords[:,1])    # dy/dxi\n                    J[1,0] = np.dot(dN_deta, quad_coords[:,0])   # dx/deta\n                    J[1,1] = np.dot(dN_deta, quad_coords[:,1])   # dy/deta\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    # Derivatives w.r.t x,y\n                    grads = np.zeros((4,2))\n                    for a in range(4):\n                        dN_nat = np.array([dN_dxi[a], dN_deta[a]])\n                        dN_xy = invJ @ dN_nat\n                        grads[a,0] = dN_xy[0]\n                        grads[a,1] = dN_xy[1]\n                    # Build B matrix 3x8\n                    B = np.zeros((3, 8))\n                    for a in range(4):\n                        dNx = grads[a,0]\n                        dNy = grads[a,1]\n                        B[0, 2*a]   = dNx\n                        B[1, 2*a+1] = dNy\n                        B[2, 2*a]   = dNy\n                        B[2, 2*a+1] = dNx\n                    eps_h = B @ de_q4\n                    sig_h = D @ eps_h\n                    sig_ex = exact_sigma(x, y, D)\n                    diff = sig_ex - sig_h\n                    w = w_xi * w_eta * detJ\n                    num_q4 += np.dot(diff, diff) * w\n                    den_q4 += np.dot(sig_ex, sig_ex) * w\n\n            # CST contribution: split into two triangles (0-1-2) and (0-2-3)\n            tris = [\n                np.array([quad_coords[0], quad_coords[1], quad_coords[2]]),\n                np.array([quad_coords[0], quad_coords[2], quad_coords[3]])\n            ]\n            for tri in tris:\n                Bc, A = B_matrix_CST(tri)\n                # nodal displacement vector de: [u1,v1,u2,v2,u3,v3]\n                de_tri = []\n                for (x, y) in tri:\n                    ux, uy = exact_u(x, y)\n                    de_tri.extend([ux, uy])\n                de_tri = np.array(de_tri)\n                eps_h = Bc @ de_tri\n                sig_h = D @ eps_h\n                # Triangular quadrature (3 points)\n                for (wL, L) in zip(tri_qw, tri_qL):\n                    # barycentric to Cartesian\n                    x = L[0]*tri[0,0] + L[1]*tri[1,0] + L[2]*tri[2,0]\n                    y = L[0]*tri[0,1] + L[1]*tri[1,1] + L[2]*tri[2,1]\n                    sig_ex = exact_sigma(x, y, D)\n                    diff = sig_ex - sig_h\n                    num_cst += np.dot(diff, diff) * (A * wL)\n                    den_cst += np.dot(sig_ex, sig_ex) * (A * wL)\n\n    eta_cst = np.sqrt(num_cst / den_cst) if den_cst > 0 else 0.0\n    eta_q4  = np.sqrt(num_q4  / den_q4)  if den_q4 > 0 else 0.0\n    return eta_cst, eta_q4\n\ndef solve():\n    test_cases = [\n        # (N, E, nu, mode)\n        (1, 200e9, 0.3, 'plane_stress'),\n        (4, 200e9, 0.3, 'plane_stress'),\n        (2, 70e9, 0.25, 'plane_strain'),\n        (3, 70e9, 0.0, 'plane_strain')\n    ]\n    results = []\n    for (N, E, nu, mode) in test_cases:\n        eta_cst, eta_q4 = compute_errors(N, E, nu, mode)\n        results.append(eta_cst)\n        results.append(eta_q4)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2554580"}]}