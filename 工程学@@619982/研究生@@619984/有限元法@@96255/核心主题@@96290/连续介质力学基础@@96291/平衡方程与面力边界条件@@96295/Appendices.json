{"hands_on_practices": [{"introduction": "在有限元法中，施加牵引力边界条件最终归结为计算边界积分。有限元解的准确性在很大程度上取决于我们如何精确地计算这些载荷积分。本练习关注一个核心的实现细节：选择正确的数值求积（高斯积分）规则，以精确地积分单元边界上的多项式牵引力，这是任何有限元分析代码的基本构建模块。[@problem_id:2556076]", "problem": "考虑一个可变形体的平衡，其受不计惯性的 Cauchy 动量平衡方程控制。其强形式为：在域内，Cauchy 应力张量的散度加上体力场等于零；在部分边界上，通过一个牵引力边界条件来指定表面牵引力向量。将域记为 $\\Omega$，指定牵引力的边界记为 $\\Gamma_{t}$，Cauchy 应力张量记为 $\\boldsymbol{\\sigma}$，外法向单位向量记为 $\\boldsymbol{n}$，单位体积的体力记为 $\\boldsymbol{b}$，指定的牵引力向量记为 $\\boldsymbol{t}$。基本定律为：在 $\\Omega$ 内 $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$，以及在 $\\Gamma_{t}$ 上 $\\boldsymbol{\\sigma} \\boldsymbol{n} = \\boldsymbol{t}$。使用虚功原理和带有适当本质边界条件的检验（虚位移）场 $\\boldsymbol{v}$，其弱形式包含边界积分 $\\int_{\\Gamma_{t}} \\boldsymbol{v} \\cdot \\boldsymbol{t} \\,\\mathrm{d}\\Gamma$。在有限元法 (FEM) 中，使用形函数 $N_{i}$，由 $\\Gamma_{t}$ 对节点 $i$ 的全局载荷向量的贡献为 $\\int_{\\Gamma_{t}} N_{i} \\, \\boldsymbol{t} \\cdot \\boldsymbol{e} \\,\\mathrm{d}\\Gamma$，其中 $\\boldsymbol{e}$ 是一个选择位移分量的标准基向量。\n\n假设使用等参单元，每个单元上具有仿射（线性）几何映射，使得边界边和面从参考边和面进行仿射映射，从而使边界雅可比因子在每个边或面上为常数，并确保物理边或面上的多项式牵引力场在参考坐标系下变为一个相同总次数的多项式。考虑限制在边或面上的 $r \\in \\mathbb{N}$ 次多项式 Lagrange 形函数，以及在该边或面上的一个牵引力场，它在相应的参考坐标系下是一个 $q \\in \\mathbb{N}_{0}$ 次的多项式。在这些假设下，边或面上的边值项的被积函数是一个多项式，其次数由 $N_{i}$ 与牵引力的乘积确定，并由一个常数边界雅可比因子缩放。\n\n您的任务是实现适用于边界积分的数值求积法则，并针对每个给定情况，确定精确积分边界牵引力项所需的最小求积点数：\n- 在边上：为任意正整数点数 $n$ 实现参考区间 $[-1,1]$ 上的 Gauss–Legendre 求积，并确定保证在仿射边上精确积分多项式被积函数的最小 $n$。\n- 在三角形面上：在参考三角形上实现对总次数最高为指定值 $s$（其中 $s \\in \\{1,2,3,4,5\\}$）的多项式精确的对称求积法则（例如，Dunavant 型法则），并确定保证在仿射三角形面上精确积分多项式被积函数的最小求积点数。\n\n从第一性原理出发：从强形式和牵引力边界条件开始，推导弱形式的边界项，在仿射映射假设下，根据 $r$ 和 $q$ 确定边界牵引力贡献的被积函数的多项式次数，并推导出相关的求积精确度要求。然后，实现相应的求积法则，并计算下面每个测试用例所需的最小点数。\n\n测试套件（每个项目指定实体类型和配对 $(r,q)$）：\n- 边: $(r,q) = (1,1)$。\n- 边: $(r,q) = (2,0)$。\n- 边: $(r,q) = (3,2)$。\n- 边: $(r,q) = (1,0)$。\n- 三角形面: $(r,q) = (1,1)$。\n- 三角形面: $(r,q) = (2,2)$。\n- 三角形面: $(r,q) = (3,1)$。\n- 三角形面: $(r,q) = (1,0)$。\n\n您的程序必须：\n- 为任意正整数 $n$ 实现 $[-1,1]$ 上的 Gauss–Legendre 求积。\n- 实现对总多项式次数 $s \\in \\{1,2,3,4,5\\}$ 精确的三角形求积法则。\n- 对于每个测试用例，在所述假设下，计算确保边界牵引力积分能被精确计算的最小求积点数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔的整数列表（例如，$[a,b,c]$），其中每个整数是对应于上述顺序的测试用例的最小求积点数。", "solution": "我们从不计惯性的准静态条件下的线性动量平衡出发，该平衡由在 $\\Omega$ 内的 $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$ 给出，并辅以在 $\\Gamma_{t}$ 上的牵引力边界条件 $\\boldsymbol{\\sigma}\\boldsymbol{n} = \\boldsymbol{t}$。设 $\\boldsymbol{v}$ 为一个容许虚位移场。虚功原理可得出\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) : \\boldsymbol{\\sigma} \\,\\mathrm{d}\\Omega = \\int_{\\Omega} \\boldsymbol{v}\\cdot \\boldsymbol{b} \\,\\mathrm{d}\\Omega + \\int_{\\Gamma_{t}} \\boldsymbol{v}\\cdot \\boldsymbol{t} \\,\\mathrm{d}\\Gamma,\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{v})$ 是小应变张量。在采用形函数 $N_{i}$ 和节点虚位移 $\\delta \\boldsymbol{u}_{i}$ 的有限元法 (FEM) 离散化中，我们取 $\\boldsymbol{v} \\approx \\sum_{i} N_{i} \\,\\delta \\boldsymbol{u}_{i}$。牵引力边界对与节点 $i$ 和给定平移分量方向相关的离散载荷向量分量的贡献是\n$$\nf_{i}^{\\Gamma} = \\int_{\\Gamma_{t}} N_{i} \\, t \\, \\mathrm{d}\\Gamma,\n$$\n其中 $t$ 表示牵引力向量的相应分量。该标量边界积分在单元边界段上进行计算：在二维中是在边（一维流形）上，在三维中是在面（二维流形）上。\n\n我们假设采用等参格式，每个单元上具有仿射（线性）几何映射。对于边积分，从参考区间 $[-1,1]$ 到物理边的映射是仿射的。将参考积分转换为物理积分的边界雅可比因子 $J_{\\Gamma}$ 在每个仿射边上为常数，因此除了一个乘法常数外，被积函数的多项式特性不受影响。设边上的形函数在限制于该边时是次数为 $r \\in \\mathbb{N}$ 的多项式，并设该边上的牵引力分量 $t$ 是次数为 $q \\in \\mathbb{N}_{0}$ 的多项式。那么，边上的被积函数 $N_{i} \\, t$ 在参考坐标系下是一个次数为 $r+q$ 的一维多项式。为了用 $[-1,1]$ 上的 $n$ 点 Gauss–Legendre 求积法精确地积分该函数，我们使用一个熟知的事实：一个 $n$ 点 Gauss–Legendre 法则对所有次数最高为 $2n-1$ 的多项式都是精确的。因此，为保证精确性，需要满足\n$$\n2n - 1 \\ge r + q \\quad \\Longrightarrow \\quad n \\ge \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil,\n$$\n所以仿射边上 Gauss–Legendre 求积点的最小数量为 $n_{\\text{edge}} = \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil$。\n\n对于四面体单元的三角形面，从参考三角形到物理面的映射是仿射的。边界面积雅可比因子 $J_{\\Gamma}$ 在每个面上是常数，次数为 $r$ 的形函数 $N_{i}$ 在该面上的限制，是在参考三角形坐标系下总次数为 $r$ 的二元多项式。如果牵引力分量 $t$ 是面上总次数为 $q$ 的二元多项式，那么乘积 $N_{i}\\, t$ 就是一个总次数为 $r+q$ 的二元多项式。一个对所有总次数最高为 $s$ 的多项式都精确的对称三角形求积法则，当 $s \\ge r+q$ 时可以精确地积分该函数。具有保证精确度 $s$ 的最少点法则已被广泛制表。一个方便的集合是 Dunavant 法则，例如，它提供：\n- 次数 $s \\le 1$：$1$ 个点（形心法则）。\n- 次数 $s \\le 2$：$3$ 个点。\n- 次数 $s \\le 3$：$4$ 个点。\n- 次数 $s \\le 4$：$6$ 个点。\n- 次数 $s \\le 5$：$7$ 个点。\n\n因此，对于在所述假设下的三角形面，最小求积点数可通过选择满足 $s \\ge r+q$ 的最小可用法则并报告其点数来获得。\n\n算法设计：\n- 使用正交多项式工具在 $[-1,1]$ 上实现 Gauss–Legendre 求积，以获得任意 $n$ 的节点和权重。其精确度为 $2n-1$，因此所需的最小 $n$ 是 $n_{\\text{edge}} = \\left\\lceil \\frac{r+q+1}{2} \\right\\rceil$。\n- 为精确度 $s \\in \\{1,2,3,4,5\\}$ 实现带有节点和权重的三角形求积法则（例如，Dunavant 法则）。对于给定的 $(r,q)$，计算 $m = r+q$，选择满足 $s \\ge m$ 的最小 $s \\in \\{1,2,3,4,5\\}$，并返回该法则的点数。\n- 将这些应用于指定顺序的测试套件，并以整数形式输出最小点数。\n\n将公式应用于测试套件，得出：\n- 边 $(r,q)=(1,1)$: $n_{\\text{edge}}=\\left\\lceil \\frac{1+1+1}{2} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2$。\n- 边 $(r,q)=(2,0)$: $n_{\\text{edge}}=\\left\\lceil \\frac{2+0+1}{2} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = 2$。\n- 边 $(r,q)=(3,2)$: $n_{\\text{edge}}=\\left\\lceil \\frac{3+2+1}{2} \\right\\rceil = \\left\\lceil \\frac{6}{2} \\right\\rceil = 3$。\n- 边 $(r,q)=(1,0)$: $n_{\\text{edge}}=\\left\\lceil \\frac{1+0+1}{2} \\right\\rceil = \\left\\lceil \\frac{2}{2} \\right\\rceil = 1$。\n- 面 $(r,q)=(1,1)$: $m=1+1=2 \\Rightarrow s=2$ 即可 $\\Rightarrow 3$ 个点。\n- 面 $(r,q)=(2,2)$: $m=2+2=4 \\Rightarrow s=4$ 即可 $\\Rightarrow 6$ 个点。\n- 面 $(r,q)=(3,1)$: $m=3+1=4 \\Rightarrow s=4$ 即可 $\\Rightarrow 6$ 个点。\n- 面 $(r,q)=(1,0)$: $m=1+0=1 \\Rightarrow s=1$ 即可 $\\Rightarrow 1$ 个点。\n\n因此，按顺序所需的输出是整数 $[2,2,3,1,3,6,6,1]$，程序将使用所实现的求积法则逻辑来计算它们。", "answer": "```python\nimport numpy as np\n\n# Implement Gauss-Legendre quadrature on [-1, 1]\ndef gauss_legendre_rule(n):\n    # Returns nodes and weights for n-point Gauss-Legendre\n    # Using numpy's leggauss for robustness\n    from numpy.polynomial.legendre import leggauss\n    nodes, weights = leggauss(n)\n    return nodes, weights\n\n# Implement Dunavant-type symmetric triangle quadrature rules\n# providing exactness up to degrees 1..5. Returns (points, weights, degree, n_points).\n# Points are given in barycentric coordinates (L1,L2,L3) with L1+L2+L3=1, L_i >= 0.\ndef triangle_rule_by_degree_exactness(s_required):\n    # Select the minimal rule with exactness >= s_required from available set.\n    # Data from standard Dunavant rules.\n    rules = [\n        # degree, points (barycentric), weights\n        (1,\n         np.array([[1/3, 1/3, 1/3]]),\n         np.array([1.0])),\n        (2,\n         np.array([\n             [2/3, 1/6, 1/6],\n             [1/6, 2/3, 1/6],\n             [1/6, 1/6, 2/3],\n         ]),\n         np.array([1/3, 1/3, 1/3])),\n        (3,\n         np.array([\n             [1/3, 1/3, 1/3],\n             [0.6, 0.2, 0.2],\n             [0.2, 0.6, 0.2],\n             [0.2, 0.2, 0.6],\n         ]),\n         np.array([-27/48, 25/48, 25/48, 25/48])),\n        (4,\n         np.array([\n             [0.445948490915965, 0.445948490915965, 0.108103018168070],\n             [0.445948490915965, 0.108103018168070, 0.445948490915965],\n             [0.108103018168070, 0.445948490915965, 0.445948490915965],\n             [0.091576213509771, 0.091576213509771, 0.816847572980458],\n             [0.091576213509771, 0.816847572980458, 0.091576213509771],\n             [0.816847572980458, 0.091576213509771, 0.091576213509771],\n         ]),\n         np.array([\n             0.223381589678011,\n             0.223381589678011,\n             0.223381589678011,\n             0.109951743655322,\n             0.109951743655322,\n             0.109951743655322,\n         ])),\n        (5,\n         np.array([\n             [1/3, 1/3, 1/3],\n             [0.059715871789770, 0.470142064105115, 0.470142064105115],\n             [0.470142064105115, 0.059715871789770, 0.470142064105115],\n             [0.470142064105115, 0.470142064105115, 0.059715871789770],\n             [0.797426985353087, 0.101286507323456, 0.101286507323456],\n             [0.101286507323456, 0.797426985353087, 0.101286507323456],\n             [0.101286507323456, 0.101286507323456, 0.797426985353087],\n         ]),\n         np.array([\n             0.225000000000000,\n             0.132394152788506,\n             0.132394152788506,\n             0.132394152788506,\n             0.125939180544827,\n             0.125939180544827,\n             0.125939180544827,\n         ])),\n    ]\n    # Choose smallest rule with degree >= s_required\n    for degree, pts, wts in rules:\n        if degree >= s_required:\n            return pts, wts, degree, pts.shape[0]\n    # If higher degree requested than available, raise error\n    raise ValueError(\"Requested triangle quadrature exactness degree exceeds available rules (max 5).\")\n\n# Compute minimal number of Gauss-Legendre points for edge integrals\ndef minimal_edge_points(r, q):\n    # n such that 2n-1 >= r+q -> n >= ceil((r+q+1)/2)\n    return int(np.ceil((r + q + 1) / 2.0))\n\n# Compute minimal number of triangle quadrature points for face integrals\ndef minimal_triangle_face_points(r, q):\n    m = r + q  # required total degree exactness\n    _, _, _, npts = triangle_rule_by_degree_exactness(m)\n    return npts\n\ndef solve():\n    # Define the test suite in the specified order\n    # Each tuple: (entity_type, r, q)\n    test_cases = [\n        (\"edge\", 1, 1),\n        (\"edge\", 2, 0),\n        (\"edge\", 3, 2),\n        (\"edge\", 1, 0),\n        (\"face_triangle\", 1, 1),\n        (\"face_triangle\", 2, 2),\n        (\"face_triangle\", 3, 1),\n        (\"face_triangle\", 1, 0),\n    ]\n\n    results = []\n    for entity, r, q in test_cases:\n        if entity == \"edge\":\n            # implement rule (nodes, weights) though only count is needed\n            n = minimal_edge_points(r, q)\n            _nodes, _weights = gauss_legendre_rule(n)\n            results.append(n)\n        elif entity == \"face_triangle\":\n            npts = minimal_triangle_face_points(r, q)\n            # also obtain nodes and weights (unused in result)\n            _pts, _wts, _deg, _ = triangle_rule_by_degree_exactness(r + q)\n            results.append(npts)\n        else:\n            raise ValueError(\"Unknown entity type in test cases.\")\n\n    # Final output format: single line with comma-separated list enclosed in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2556076"}, {"introduction": "在编写复杂的代码之前，制定一个验证其正确性的计划至关重要。“制造解法”（Method of Manufactured Solutions, MMS）是实现这一目标的强大技术。本练习将挑战你像软件开发者和质量保证工程师一样思考，选择一个正确且严谨的程序来创建一个测试案例。这个案例不仅能暴露代码中的错误，还能验证代码在处理牵引力边界条件时是否达到了理论上的收敛阶。[@problem_id:2556121]", "problem": "考虑一个静态、小应变、线弹性体，该物体占据开放方域 $\\Omega=(0,1)^2\\subset\\mathbb{R}^2$，其边界为 $\\partial\\Omega=\\Gamma_u\\cup\\Gamma_t$，且 $\\Gamma_u\\cap\\Gamma_t=\\emptyset$。令 $\\boldsymbol{u}:\\Omega\\to\\mathbb{R}^2$ 表示位移场，$\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u}+(\\nabla\\boldsymbol{u})^\\top\\right)$ 表示线性化应变张量，$\\boldsymbol{\\sigma}(\\boldsymbol{u})$ 表示平面应变条件下各向同性线弹性的Cauchy应力张量，其Lamé参数 $\\lambda>0$ 和 $\\mu>0$，由 $\\boldsymbol{\\sigma}(\\boldsymbol{u})=\\lambda\\,(\\nabla\\cdot\\boldsymbol{u})\\,\\boldsymbol{I}+2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$ 给出。体力为 $\\boldsymbol{b}:\\Omega\\to\\mathbb{R}^2$。$\\partial\\Omega$ 上的外单位法向量为 $\\boldsymbol{n}$。静态平衡的强形式为 $\\nabla\\cdot\\boldsymbol{\\sigma}+\\boldsymbol{b}=\\boldsymbol{0}$ in $\\Omega$，位移边界条件为 $\\boldsymbol{u}=\\bar{\\boldsymbol{u}}$ on $\\Gamma_u$，面力边界条件为 $\\boldsymbol{t}=\\bar{\\boldsymbol{t}}$ on $\\Gamma_t$，其中边界面力矢量满足Cauchy关系式 $\\boldsymbol{t}=\\boldsymbol{\\sigma}\\,\\boldsymbol{n}$ on $\\partial\\Omega$。\n\n您计划使用人造解方法来验证一个针对此问题的基于位移的有限元方法（FEM）实现，并在边界的非空部分上施加非平凡、空间变化的面力。目标是评估代码的正确性（平衡和边界条件施加的一致性）和关于网格尺寸 $h$ 的渐近收敛率（对于 $k$ 次多项式单元），此过程使用准均匀加密和足够光滑的数据。\n\n以下哪项概述了一个正确且完整的验证计划，该计划与上述控制方程一致，适用于评估正确性和最优收敛性，并特别地使用已知的非零面力来检验面力边界条件？\n\nA. 选择一个足够光滑、非平凡的人造位移 $\\boldsymbol{u}^\\star\\in C^\\infty(\\overline{\\Omega})$，其在 $\\Gamma_t$ 上的限制与本构定律结合后能产生非零面力。通过 $\\boldsymbol{b}^\\star=-\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$ 来定义域 $\\Omega$ 内的体力。在非空的 $\\Gamma_u$ 上指定 $\\bar{\\boldsymbol{u}}=\\boldsymbol{u}^\\star$，并在非空的、不相交的 $\\Gamma_t$ 上指定 $\\bar{\\boldsymbol{t}}=\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\,\\boldsymbol{n}$，以避免刚体模式，同时检验面力的施加。在一系列使用 $k$ 阶单元的准均匀网格上求解，使用足够精确的求积方法，以确保刚度项和载荷项的积分误差在离散误差范围内。计算相对于 $\\boldsymbol{u}^\\star$ 在 $H^1$-半范数和 $L^2$-范数下的误差，并验证当 $h\\to 0$ 时，与光滑解的最佳逼近性质一致的预期渐近收敛率。\n\nB. 选择光滑的 $\\boldsymbol{u}^\\star$。通过 $\\boldsymbol{b}^\\star=\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$ 定义体力，并通过 $\\bar{\\boldsymbol{t}}=-\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\,\\boldsymbol{n}$ 定义在 $\\Gamma_t$ 上的面力。在 $\\Gamma_u$ 上施加 $\\boldsymbol{u}^\\star$，并通过监测最大节点位移误差来验证收敛性，期望对于所有 $k\\ge 1$，在 $L^\\infty$-范数下收敛率为 $h^{k+1}$。\n\nC. 人造一个光滑且对称但不必与任何位移相容的应力场 $\\boldsymbol{\\sigma}^\\star$，在 $\\Omega$ 中设置 $\\boldsymbol{b}^\\star=\\boldsymbol{0}$，并在整个边界 $\\Gamma_t=\\partial\\Omega$ 上施加 $\\bar{\\boldsymbol{t}}=\\boldsymbol{\\sigma}^\\star\\,\\boldsymbol{n}$，不设位移约束。如果FEM解计算出的位移场，其数值应力在容差范围内逐点匹配 $\\boldsymbol{\\sigma}^\\star$，则验证正确性，并报告能量范数下的收敛性。\n\nD. 选择一个光滑位移 $\\boldsymbol{u}^\\star$ 并在 $\\Omega$ 中定义 $\\boldsymbol{b}^\\star=-\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$，但取 $\\Gamma_u=\\emptyset$ 并在 $\\Gamma_t=\\partial\\Omega$ 上施加无面力边界条件 $\\bar{\\boldsymbol{t}}=\\boldsymbol{0}$，并声称非零面力是不必要的，因为体力已经检验了平衡。仅在 $L^2$-范数下确认收敛性。\n\nE. 选择一个光滑位移 $\\boldsymbol{u}^\\star$ 并定义数据使其在强形式下满足平衡，但为了降低计算成本，使用特意低阶的数值求积（例如，仅对 $k-1$ 次多项式精确）来组装单元矩阵和边界面力。通过检查 $H^1$-半范数误差随 $h$ 减小来验证正确性和收敛性，并报告任何观察到的收敛率，只要它是单调的就可接受。\n\n选择最符合所述验证目标，并且与平衡方程和面力边界条件完全一致的选项。", "solution": "任务是为线弹性静力学问题，确定一个用于基于位移的有限元方法（FEM）实现的正确且完整的验证计划。该验证将使用人造解方法（MMS）来评估代码的正确性和渐近收敛率，并有明确要求测试非零面力边界条件。\n\n该问题的控制方程是：\n1.  域 $\\Omega$ 内的平衡方程：$\\nabla\\cdot\\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$\n2.  本构定律（平面应变，各向同性线弹性）：$\\boldsymbol{\\sigma}(\\boldsymbol{u}) = \\lambda\\,(\\nabla\\cdot\\boldsymbol{u})\\,\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$\n3.  应变-位移关系：$\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}\\left(\\nabla\\boldsymbol{u} + (\\nabla\\boldsymbol{u})^\\top\\right)$\n4.  位移（Dirichlet）边界条件：$\\boldsymbol{u} = \\bar{\\boldsymbol{u}}$ on $\\Gamma_u$\n5.  面力（Neumann）边界条件：$\\boldsymbol{\\sigma}\\boldsymbol{n} = \\bar{\\boldsymbol{t}}$ on $\\Gamma_t$\n\n人造解方法（MMS）是一种严谨的验证技术。其步骤包括：\n1.  选择一个人造解 $\\boldsymbol{u}^\\star$，它必须足够光滑，以允许观察到理论上的渐近收敛率。\n2.  将 $\\boldsymbol{u}^\\star$ 代入控制微分方程和边界条件，以导出必要的源项和边界数据。这确保了 $\\boldsymbol{u}^\\star$ 是所构造问题的精确解析解。\n    -   由平衡方程：$\\boldsymbol{b}^\\star = -\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$。\n    -   由位移边界条件：$\\bar{\\boldsymbol{u}} = \\boldsymbol{u}^\\star$ on $\\Gamma_u$。\n    -   由面力边界条件：$\\bar{\\boldsymbol{t}} = \\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\boldsymbol{n}$ on $\\Gamma_t$。\n3.  使用FEM代码对此构造的边值问题进行数值求解。\n4.  在适当的范数下，计算数值解 $\\boldsymbol{u}_h$ 与已知精确解 $\\boldsymbol{u}^\\star$ 之间的误差。\n5.  通过在一系列连续加密的网格（网格尺寸 $h \\to 0$）上求解来进行收敛性研究，并验证误差以理论预测的速率减小。对于一个光滑解 $\\boldsymbol{u}^\\star$ 和 $k$ 次多项式的Lagrange有限元，预期的最优收敛率是：\n    -   $\\|\\boldsymbol{u}^\\star - \\boldsymbol{u}_h\\|_{H^1(\\Omega)} = O(h^k)$ （或等效地，对于 $H^1$-半范数）。\n    -   $\\|\\boldsymbol{u}^\\star - \\boldsymbol{u}_h\\|_{L^2(\\Omega)} = O(h^{k+1})$。\n\n实现的一个关键方面是，用于组装刚度矩阵和载荷向量的数值求积必须足够精确，以免污染离散误差。否则，观察到的收敛率将是次优的。\n\n现在，我将根据这些原则评估每个选项。\n\n**选项 A 评估**\n该选项建议：\n1.  选择一个光滑的人造位移 $\\boldsymbol{u}^\\star$。这是正确的起点。\n2.  将体力定义为 $\\boldsymbol{b}^\\star = -\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$。这是正确的。\n3.  在非空的 $\\Gamma_u$ 上指定边界条件 $\\bar{\\boldsymbol{u}} = \\boldsymbol{u}^\\star$，并在非空的 $\\Gamma_t$ 上指定 $\\bar{\\boldsymbol{t}} = \\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\boldsymbol{n}$。这正确地导出了边界数据。通过设置非空的 $\\Gamma_u$，确保了问题是适定的，避免了刚体模式。通过选择能够产生非零面力的 $\\boldsymbol{u}^\\star$，它满足了检验面力边界条件实现的具体目标。\n4.  使用足够精确的求积以避免引入显著的积分误差。这是实现最优收敛率的一个关键且正确的考虑。\n5.  计算在 $H^1$-半范数和 $L^2$-范数下的误差，并检查预期的渐近收敛率。这代表了对收敛性进行完整和标准的验证。\n\n该计划在方法论上是合理的、完整的，并且与FEM和MMS的理论一致。\n结论：**正确**。\n\n**选项 B 评估**\n该选项建议：\n1.  将体力定义为 $\\boldsymbol{b}^\\star = \\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)$。这里的符号是错误的。从平衡方程 $\\nabla\\cdot\\boldsymbol{\\sigma}+\\boldsymbol{b}=\\boldsymbol{0}$ 推导出的正确关系是 $\\boldsymbol{b} = -\\nabla\\cdot\\boldsymbol{\\sigma}$。\n2.  将面力定义为 $\\bar{\\boldsymbol{t}} = -\\boldsymbol{\\sigma}(\\boldsymbol{u}^\\star)\\boldsymbol{n}$。这里的符号也是错误的。边界条件是 $\\boldsymbol{\\sigma n} = \\bar{\\boldsymbol{t}}$。\n3.  它建议仅监测最大节点位移误差。虽然 $L^\\infty$-范数是一个有效的误差度量，但仅关注节点值可能会产生误导。更重要的是，使用像 $L^2$和$H^1$这样的积分范数是标准做法，并且更稳健，因为它们度量了整个域上的误差，并与问题的弱形式直接相关。\n\n人造数据定义中的符号错误是根本性缺陷。代码将求解一个不同于以 $\\boldsymbol{u}^\\star$ 为解的问题，这使得任何与 $\\boldsymbol{u}^\\star$ 的误差计算对于验证来说都毫无意义。\n结论：**不正确**。\n\n**选项 C 评估**\n该选项有几个根本性缺陷：\n1.  它建议人造一个“不必与任何位移相容”的应力场 $\\boldsymbol{\\sigma}^\\star$。一个不相容的应力场违反了应变协调条件。基于位移的FEM列式在一个函数空间中寻找解，根据定义，该空间中的应变由位移导出，因此是相容的。这样的问题在基于位移的框架内没有解。\n2.  它设置了一个纯面力问题（$\\Gamma_u = \\emptyset$）。对于弹性静力学，这样的问题是不适定的，因为解在刚体运动（在 $\\mathbb{R}^2$ 中，两次平移和一次旋转）下是不确定的。只有当外载荷（体力与面力）自平衡时，解才存在。验证测试应基于一个适定问题。\n3.  验证标准（“数值应力在容差范围内逐点匹配 $\\boldsymbol{\\sigma}^\\star$”）并非MMS的标准程序。标准程序是检查主场变量（$\\boldsymbol{u}$）与已知精确解（$\\boldsymbol{u}^\\star$）的收敛率。\n\n这种方法与弹性力学和基于位移的有限元方法的数学基础都不一致。\n结论：**不正确**。\n\n**选项 D 评估**\n该选项建议：\n1.  设置 $\\Gamma_u=\\emptyset$ 并在 $\\Gamma_t=\\partial\\Omega$ 上设置 $\\bar{\\boldsymbol{t}}=\\boldsymbol{0}$。与选项C一样，这设置了一个不适定的纯Neumann问题。\n2.  它声称测试非零面力是不必要的。这明确地未能满足问题描述中提出的一个关键目标：“特别地使用已知的非零面力来检验面力边界条件”。验证非零面力的边界积分的组装是一个全面验证套件的重要组成部分。\n3.  它建议仅在 $L^2$-范数下确认收敛性。这是一个不完整的检查。能量范数（$H^1$-范数）的收敛性是标准FEM理论的主要结果（通过Céa引理），必须得到验证。\n\n这个计划是有缺陷的，因为它构建了一个不适定问题，并且未能满足指定的验证目标。\n结论：**不正确**。\n\n**选项 E 评估**\n该选项有两个主要缺陷：\n1.  它建议使用“特意低阶的数值求积”。这会引入一个求积误差，当网格加密时，该误差将主导离散误差，从而妨碍观察到最优的理论收敛率。验证研究的目的是确认代码在正确配置时能够达到这些最优率。故意使用不精确的求积会破坏这一目标。虽然减缩积分有其用途，但它不是旨在确认理论收敛率的标准验证计划的一部分。\n2.  它提出了一个很弱的成功标准：“通过检查 $H^1$-半范数误差随 $h$ 减小来验证...并报告任何观察到的收敛率，只要它是单调的就可接受。”这完全不足。MMS的目标是定量验证。必须检查收敛的*速率*是否与理论预测相符（例如，$O(h^k)$）。任何单调减少都不能作为正确性的可接受证明。一个有错误的代码可能仍会显示某种程度的收敛，但收敛率是次优的。\n\n这个计划描述了一个拙劣且无定论的验证过程。\n结论：**不正确**。\n\n总之，只有选项A概述了一个严谨、理论上合理，且满足问题中所有要求的验证计划。它正确地应用了人造解方法，确保了问题的适定性，并指定了用于正确性和最优性能的适当检查。", "answer": "$$\\boxed{A}$$", "id": "2556121"}, {"introduction": "现在，让我们将上一个练习中设计的验证计划付诸实践。本练习涵盖了一个完整的实现周期：从一个解析解（由艾里应力函数导出）出发，计算出相应的边界牵引力，然后构建一个有限元求解器来解决这个问题。最后，将数值结果与精确解进行比较以计算误差，这个综合性练习融合了理论、实现和验证，是计算科学家必须掌握的关键技能。[@problem_id:2556099]", "problem": "考虑一个矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上的二维小应变线性弹性静力学平面应力问题。设材料是均匀且各向同性的，其杨氏模量为 $E$，泊松比为 $\\nu$。未知位移场为 $\\mathbf{u}(x,y) = (u_x(x,y), u_y(x,y))$。不存在体力。在整个边界 $\\partial \\Omega$ 上给定了面力。\n\n为保证精确满足零体力下的强形式平衡方程，使用 Airy 应力函数 $F(x,y)$ 并通过以下方式定义应力张量：\n$$\n\\sigma_{xx} = \\frac{\\partial^2 F}{\\partial y^2}, \\quad\n\\sigma_{yy} = \\frac{\\partial^2 F}{\\partial x^2}, \\quad\n\\sigma_{xy} = -\\frac{\\partial^2 F}{\\partial x \\partial y}.\n$$\n选择四次 Airy 应力函数：\n$$\nF(x,y) = a\\,x\\,y^3 + b\\,x^3\\,y + c\\,x^2\\,y + d\\,x\\,y^2,\n$$\n其中 $a$、$b$、$c$ 和 $d$ 是给定常数。由于 $F$ 是一个最高为4次的多项式，它是双调和的，因此所产生的应力场在线性弹性理论中满足零体力下的协调方程。\n\n边界面力定义为 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ on $\\partial \\Omega$，其中 $\\mathbf{n}$ 是外法向单位向量。在矩形的四条边上，外法向单位向量是常数：\n- 在 $x=0$ 上：$\\mathbf{n} = (-1,0)$，\n- 在 $x=L_x$ 上：$\\mathbf{n} = (1,0)$，\n- 在 $y=0$ 上：$\\mathbf{n} = (0,-1)$，\n- 在 $y=L_y$ 上：$\\mathbf{n} = (0,1)$。\n\n设平面应力的本构关系将应力与工程应变 $\\boldsymbol{\\varepsilon}_{\\text{eng}} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^T$ 通过以下方式关联：\n$$\n\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}_{\\text{eng}}, \\quad\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n以及柔度关系 $\\boldsymbol{\\varepsilon}_{\\text{eng}} = \\mathbf{S}\\,\\boldsymbol{\\sigma}$，其中\n$$\n\\mathbf{S} =\n\\begin{bmatrix}\n\\frac{1}{E} & -\\frac{\\nu}{E} & 0 \\\\\n-\\frac{\\nu}{E} & \\frac{1}{E} & 0 \\\\\n0 & 0 & \\frac{2(1+\\nu)}{E}\n\\end{bmatrix}.\n$$\n工程剪应变为 $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$。在零体力和仅有面力边界条件下，弱形式为：寻找 $\\mathbf{u} \\in V$，使得对于所有虚位移 $\\mathbf{v} \\in V_0$，\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}_{\\text{eng}}(\\mathbf{v})^T \\mathbf{D}\\, \\boldsymbol{\\varepsilon}_{\\text{eng}}(\\mathbf{u}) \\, d\\Omega\n=\n\\int_{\\partial \\Omega} \\mathbf{v} \\cdot \\mathbf{t} \\, d\\Gamma.\n$$\n为唯一地移除刚体模态，施加以下最小基本约束：\n$$\nu_x(0,0) = 0,\\quad u_y(0,0) = 0,\\quad u_y(L_x,0)=0.\n$$\n\n任务。在 $N_x \\times N_y$ 个单元的均匀网格上，使用双线性等参四边形单元实现一个协调有限元法 (FEM)，以求解由 Airy 应力函数导出的面力场下的上述弱形式问题。通过执行高斯积分来组装全局刚度矩阵和一致 Neumann 载荷向量：\n- 对单元刚度使用 $2 \\times 2$ 高斯积分，\n- 对每条边界边上的面力载荷使用 $2$ 点高斯积分。\n\n通过对由 Airy 导出的应力经由平面应力柔度关系得到的应变场进行积分，构造精确位移场 $(u_x^\\star, u_y^\\star)$。定义：\n$$\n\\sigma_{xx} = 6 a\\, x y + 2 d\\, x,\\quad\n\\sigma_{yy} = 6 b\\, x y + 2 c\\, y,\\quad\n\\tau_{xy} = -3 a\\, y^2 - 3 b\\, x^2 - 2 c\\, x - 2 d\\, y.\n$$\n工程应变为：\n$$\n\\varepsilon_{xx} = \\frac{1}{E}\\left(\\sigma_{xx} - \\nu \\sigma_{yy}\\right),\\quad\n\\varepsilon_{yy} = \\frac{1}{E}\\left(\\sigma_{yy} - \\nu \\sigma_{xx}\\right),\\quad\n\\gamma_{xy} = \\frac{2(1+\\nu)}{E}\\,\\tau_{xy}.\n$$\n积分 $\\partial u_x/\\partial x = \\varepsilon_{xx}$ 和 $\\partial u_y/\\partial y = \\varepsilon_{yy}$，并通过强制满足 $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$ 来确定缺失的单变量函数。一个多项式特解（不考虑刚体运动）为：\n$$\nu_x^{\\text{base}}(x,y) = \\frac{1}{E}\\left( \\frac{6a-6\\nu b}{2}\\, x^2 y + d\\, x^2 - 2 \\nu c\\, x y \\right)\n-\\frac{1}{E}\\left( \\frac{(6+3\\nu)a + 3 b}{3}\\, y^3 + \\frac{4+2\\nu}{2}\\, d\\, y^2 \\right),\n$$\n$$\nu_y^{\\text{base}}(x,y) = \\frac{1}{E}\\left( \\frac{6b-6\\nu a}{2}\\, x y^2 + c\\, y^2 - 2 \\nu d\\, x y \\right)\n-\\frac{1}{E}\\left( \\frac{3 a + (6+3\\nu) b}{3}\\, x^3 + \\frac{4+2\\nu}{2}\\, c\\, x^2 \\right).\n$$\n为了在不改变应变场的情况下满足三个基本约束，增加一个由标量角度参数 $\\theta$ 定义的刚性旋转：\n$$\nu_x^\\star(x,y) = u_x^{\\text{base}}(x,y) - \\theta\\, y, \\quad\nu_y^\\star(x,y) = u_y^{\\text{base}}(x,y) + \\theta\\, x.\n$$\n选择 $\\theta$ 以强制满足 $u_y^\\star(L_x,0)=0$。使用 $u_y^{\\text{base}}(x,0) = -\\frac{1}{E}\\left( \\frac{3 a + (6+3\\nu) b}{3}\\, x^3 + \\frac{4+2\\nu}{2}\\, c\\, x^2 \\right)$，可得：\n$$\n\\theta = -\\frac{u_y^{\\text{base}}(L_x,0)}{L_x}\n= \\frac{1}{E}\\left[\\left(a+(2+\\nu)b\\right)L_x^2 + (2+\\nu)\\, c\\, L_x \\right].\n$$\n\n数值验证。使用带节点邻域权重的离散类 $L^2$ 范数，在网格节点上比较有限元解 $\\mathbf{u}_h$ 和精确解 $\\mathbf{u}^\\star$。对每个节点 $i$，定义权重 $w_i$ 为其所有相邻单元面积的四分之一之和。计算相对误差：\n$$\n\\eta = \\frac{\\left(\\sum_i w_i \\left[ (u_{x,h}(\\mathbf{x}_i) - u_x^\\star(\\mathbf{x}_i))^2 + (u_{y,h}(\\mathbf{x}_i) - u_y^\\star(\\mathbf{x}_i))^2 \\right]\\right)^{1/2}}{\\left(\\sum_i w_i \\left[ (u_x^\\star(\\mathbf{x}_i))^2 + (u_y^\\star(\\mathbf{x}_i))^2 \\right]\\right)^{1/2}},\n$$\n如果分母为零，则定义 $\\eta=0$。\n\n测试套件。您的程序必须评估以下三种情况，并为每种情况输出相对误差 $\\eta$：\n\n- 情况1（非平凡，中等 $\\nu$）：\n  - $L_x=1.0$, $L_y=0.8$, $N_x=10$, $N_y=8$, $E=1000.0$, $\\nu=0.3$,\n  - $a=0.7$, $b=-0.4$, $c=0.5$, $d=-0.2$。\n\n- 情况2（平凡，零面力边界情况）：\n  - $L_x=1.0$, $L_y=1.0$, $N_x=4$, $N_y=4$, $E=500.0$, $\\nu=0.25$,\n  - $a=0.0$, $b=0.0$, $c=0.0$, $d=0.0$。\n\n- 情况3（平面应力下的近不可压缩）：\n  - $L_x=2.0$, $L_y=1.0$, $N_x=16$, $N_y=8$, $E=2000.0$, $\\nu=0.49$,\n  - $a=0.2$, $b=0.3$, $c=-0.1$, $d=0.15$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3]`），列表中的每一项是对应测试用例的相对误差 $\\eta$（一个浮点数），顺序与上文所列一致。不允许有其他输出。所有量都是无量纲的，不需要物理单位。", "solution": "所给出的问题是计算力学中的一个标准练习，具体来说，是将有限元法 (FEM) 应用于平面应力条件下的二维线性弹性静力学问题。该问题定义明确、科学上合理且内部一致。\n\n首先，验证问题陈述。控制方程是线性弹性静力学的方程。使用 Airy 应力函数 $F(x,y)$ 来定义应力场 $(\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy})$ 是一种经典方法，能确保强形式平衡方程 $\\boldsymbol{\\nabla} \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$ 恒等满足。所选的 $F(x,y)$ 多项式形式是双调和的，这保证了所产生的应力场对于均匀、各向同性的材料在零体力下满足协调方程。提供的本构律是平面应力的标准形式。弱形式从虚功原理正确推导得出。给定的边界面力通过 $\\mathbf{t} = \\boldsymbol{\\sigma} \\mathbf{n}$ 从应力张量正确导出。纯 Neumann 边值问题固有的刚体运动问题，通过施加足以产生唯一解的最小基本约束得到了正确处理。所提供的位移场解析解已经通过对应变场（由应力场通过柔度关系导出）进行积分并确保其满足协调性得到验证，从而证实了其正确性。数值误差度量是一个标准的加权离散 $L^2$ 范数。所有测试用例都提供了完整的数据。因此，该问题被认为是有效且可解的。\n\n解决方案将使用标准的有限元流程，在均匀矩形网格上采用双线性四边形单元来实现。\n\n1.  **网格生成**：生成一个 $N_x \\times N_y$ 个单元的均匀网格，该网格包含 $(N_x+1) \\times (N_y+1)$ 个节点。系统地创建节点坐标和单元连接关系（即构成每个单元的节点列表）。\n\n2.  **单元级计算**：对于每个双线性四边形单元，必须计算其 $8 \\times 8$ 的单元刚度矩阵 $k^e$。该矩阵源于弱形式中的体积积分：\n    $$\n    k^e = \\int_{\\Omega_e} B^T D B \\, d\\Omega\n    $$\n    此处，$D$ 是 $3 \\times 3$ 的平面应力本构矩阵，$B$ 是 $3 \\times 8$ 的应变-位移矩阵，它将应变分量 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})$ 与单元的8个节点位移自由度关联起来。$B$ 的项取决于双线性形函数 $N_i$ 的空间导数。该积分在单元域 $\\Omega_e$ 上进行。通过将单元映射到 $(\\xi, \\eta)$ 坐标系下的标准方形域 $[-1,1] \\times [-1,1]$，该积分可使用 $2 \\times 2$ 高斯积分进行数值计算。\n\n3.  **组装**：将全局刚度矩阵 $K$ 和全局力向量 $F$ 初始化为零。然后，代码遍历所有单元，计算每个 $k^e$，并根据单元的连接关系将其组装到全局矩阵 $K$ 的相应位置。\n\n4.  **载荷向量计算**：全局力向量 $F$ 表示给定边界面力所做的功。通过在边界 $\\partial\\Omega$ 上对虚位移与面力向量的点积进行积分来计算：\n    $$\n    F_i = \\int_{\\partial \\Omega} N_i \\mathbf{t} \\, d\\Gamma\n    $$\n    这可分解为沿矩形域四条边界边的积分。对于每条边界边，积分是一维线积分，使用 2 点 Gauss-Legendre 积分法则进行数值计算。首先在每条边界边上的高斯点处计算面力向量 $\\mathbf{t}(x,y)$ 的值。\n\n5.  **施加边界条件**：全局系统 $K\\mathbf{d} = F$ 是奇异的，因为问题在整个边界上都是 Neumann 边界条件，这会容许刚体运动。为了获得唯一解，需要强制实施指定的三个基本约束 $u_x(0,0)=0$、 $u_y(0,0)=0$ 和 $u_y(L_x,0)=0$。这通常通过修改矩阵 $K$ 和向量 $F$ 来实现。对于每个被约束的自由度 (DOF) $i$，将 $K$ 的对应行和列置零，$K_{ii}$ 设置为 $1$，并将 $F_i$ 设置为给定的位移值（在此所有情况下均为 $0$）。\n\n6.  **求解线性系统**：施加约束后，修改后的线性方程组 $K\\mathbf{d} = F$ 变为非奇异，可使用标准线性求解器求解全局位移向量 $\\mathbf{d}$。\n\n7.  **误差计算**：现在，节点上的数值解 $\\mathbf{u}_h$ 已知。精确解析解 $\\mathbf{u}^\\star$ 也在每个节点坐标处进行计算。然后，使用给定的加权离散 $L^2$ 范数计算相对误差 $\\eta$。节点权重 $w_i$ 计算为与节点 $i$ 相邻的每个单元面积的四分之一之和。对于精确解为零的特殊情况（情况2），误差范数的分母为零，根据问题定义，误差 $\\eta$ 取为 $0$。\n\n该流程将系统地应用于问题陈述中指定的三个测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the results.\n    \"\"\"\n\n    def solve_case(Lx, Ly, Nx, Ny, E, nu, a, b, c, d):\n        \"\"\"\n        Solves a single instance of the 2D elastostatics problem using FEM.\n        \"\"\"\n        # 1. MESH GENERATION\n        hx = Lx / Nx\n        hy = Ly / Ny\n        n_nodes_x = Nx + 1\n        n_nodes_y = Ny + 1\n        num_nodes = n_nodes_x * n_nodes_y\n        num_elements = Nx * Ny\n        num_dofs = 2 * num_nodes\n\n        nodes = np.zeros((num_nodes, 2))\n        for j in range(n_nodes_y):\n            for i in range(n_nodes_x):\n                node_idx = j * n_nodes_x + i\n                nodes[node_idx, 0] = i * hx\n                nodes[node_idx, 1] = j * hy\n\n        elements = np.zeros((num_elements, 4), dtype=int)\n        for j in range(Ny):\n            for i in range(Nx):\n                el_idx = j * Nx + i\n                n1 = j * n_nodes_x + i\n                n2 = j * n_nodes_x + i + 1\n                n3 = (j + 1) * n_nodes_x + i + 1\n                n4 = (j + 1) * n_nodes_x + i\n                elements[el_idx] = [n1, n2, n3, n4]\n\n        # 2. ELEMENT-LEVEL CALCULATIONS & ASSEMBLY\n        D = (E / (1 - nu**2)) * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n\n        gp_loc = 1.0 / np.sqrt(3.0)\n        gauss_points_1d = np.array([-gp_loc, gp_loc])\n        gauss_weights_1d = np.array([1.0, 1.0])\n        \n        K = np.zeros((num_dofs, num_dofs))\n\n        detJ = hx * hy / 4.0\n\n        for el_idx in range(num_elements):\n            k_e = np.zeros((8, 8))\n            for i_gp, xi in enumerate(gauss_points_1d):\n                w_xi = gauss_weights_1d[i_gp]\n                for j_gp, eta in enumerate(gauss_points_1d):\n                    w_eta = gauss_weights_1d[j_gp]\n                    \n                    dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n                    dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n                    \n                    dNdx = dNdxi * (2.0 / hx)\n                    dNdy = dNdeta * (2.0 / hy)\n                    \n                    B = np.zeros((3, 8))\n                    for i in range(4):\n                        B[0, 2*i] = dNdx[i]\n                        B[1, 2*i+1] = dNdy[i]\n                        B[2, 2*i] = dNdy[i]\n                        B[2, 2*i+1] = dNdx[i]\n                    \n                    k_e += B.T @ D @ B * w_xi * w_eta * detJ\n            \n            node_indices = elements[el_idx]\n            dof_indices = [idx for i in node_indices for idx in (2*i, 2*i+1)]\n            K[np.ix_(dof_indices, dof_indices)] += k_e\n\n        # 3. LOAD VECTOR CALCULATION\n        F = np.zeros(num_dofs)\n\n        def get_stress(x, y):\n            s_xx = 6 * a * x * y + 2 * d * x\n            s_yy = 6 * b * x * y + 2 * c * y\n            s_xy = -3 * a * y**2 - 3 * b * x**2 - 2 * c * x - 2 * d * y\n            return s_xx, s_yy, s_xy\n\n        # Boundary loop (bottom, right, top, left)\n        boundary_edges = []\n        for i in range(Nx): boundary_edges.append(((i, 0), (i + 1, 0))) # Bottom\n        for j in range(Ny): boundary_edges.append(((Nx, j), (Nx, j + 1))) # Right\n        for i in range(Nx): boundary_edges.append(((Nx - i, Ny), (Nx - i - 1, Ny))) # Top\n        for j in range(Ny): boundary_edges.append(((0, Ny - j), (0, Ny - j - 1))) # Left\n\n        normals = [np.array([0, -1]), np.array([1, 0]), np.array([0, 1]), np.array([-1, 0])]\n\n        edge_idx_offset = 0\n        for side_idx in range(4):\n            normal = normals[side_idx]\n            num_side_elements = Nx if side_idx % 2 == 0 else Ny\n            \n            for i in range(num_side_elements):\n                n_start_idx = edge_idx_offset + i\n                start_node_coords, end_node_coords = boundary_edges[n_start_idx]\n                \n                n1 = start_node_coords[1] * n_nodes_x + start_node_coords[0]\n                n2 = end_node_coords[1] * n_nodes_x + end_node_coords[0]\n\n                edge_vec = nodes[n2] - nodes[n1]\n                edge_len = np.linalg.norm(edge_vec)\n                detJ_1d = edge_len / 2.0\n                \n                f_e = np.zeros(4)\n                for i_gp, s in enumerate(gauss_points_1d):\n                    w = gauss_weights_1d[i_gp]\n                    gp_coord = (nodes[n1] + nodes[n2]) / 2.0 + s * detJ_1d * (edge_vec / edge_len)\n                    \n                    s_xx, s_yy, s_xy = get_stress(gp_coord[0], gp_coord[1])\n                    sigma = np.array([[s_xx, s_xy], [s_xy, s_yy]])\n                    t = sigma @ normal\n                    \n                    N_1d = np.array([(1-s)/2.0, (1+s)/2.0])\n                    f_e[0] += N_1d[0] * t[0] * w * detJ_1d\n                    f_e[1] += N_1d[0] * t[1] * w * detJ_1d\n                    f_e[2] += N_1d[1] * t[0] * w * detJ_1d\n                    f_e[3] += N_1d[1] * t[1] * w * detJ_1d\n\n                dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]\n                F[dofs] += f_e\n            edge_idx_offset += num_side_elements\n\n        # 4. APPLY BOUNDARY CONDITIONS\n        bc_dofs = [0, 1, 2 * Nx + 1]\n        for dof in bc_dofs:\n            K[dof, :] = 0\n            K[:, dof] = 0\n            K[dof, dof] = 1.0\n            F[dof] = 0.0\n        \n        # 5. SOLVE LINEAR SYSTEM\n        u_h_vec = linalg.solve(K, F)\n        u_h = u_h_vec.reshape((num_nodes, 2))\n        \n        # 6. ERROR COMPUTATION\n        def u_base_x(x, y):\n            term1 = (1/E) * ( (3*a - 3*nu*b) * x**2 * y + d*x**2 - 2*nu*c*x*y )\n            term2 = -(1/E) * ( ((6+3*nu)*a + 3*b)/3 * y**3 + (4+2*nu)/2 * d * y**2 )\n            return term1 + term2\n        \n        def u_base_y(x, y):\n            term1 = (1/E) * ( (3*b - 3*nu*a) * x*y**2 + c*y**2 - 2*nu*d*x*y )\n            term2 = -(1/E) * ( (3*a + (6+3*nu)*b)/3 * x**3 + (4+2*nu)/2 * c * x**2 )\n            return term1 + term2\n\n        theta = (1/E) * ( (a + (2+nu)*b)*Lx**2 + (2+nu)*c*Lx )\n\n        def u_star_x(x, y): return u_base_x(x, y) - theta * y\n        def u_star_y(x, y): return u_base_y(x, y) + theta * x\n\n        u_exact = np.array([[u_star_x(x, y), u_star_y(x, y)] for x, y in nodes])\n            \n        weights = np.zeros(num_nodes)\n        el_area = hx * hy\n        for el_idx in range(num_elements):\n            weights[elements[el_idx]] += el_area / 4.0\n\n        err_num_sq = np.sum(weights * np.sum((u_h - u_exact)**2, axis=1))\n        norm_den_sq = np.sum(weights * np.sum(u_exact**2, axis=1))\n\n        if norm_den_sq < 1e-25: return 0.0\n        \n        return np.sqrt(err_num_sq / norm_den_sq)\n\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 0.8, 'Nx': 10, 'Ny': 8, 'E': 1000.0, 'nu': 0.3,\n         'a': 0.7, 'b': -0.4, 'c': 0.5, 'd': -0.2},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'E': 500.0, 'nu': 0.25,\n         'a': 0.0, 'b': 0.0, 'c': 0.0, 'd': 0.0},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 8, 'E': 2000.0, 'nu': 0.49,\n         'a': 0.2, 'b': 0.3, 'c': -0.1, 'd': 0.15},\n    ]\n\n    results = [solve_case(**case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2556099"}]}