{"hands_on_practices": [{"introduction": "掌握两种板理论的关键在于理解其核心的运动学差异，即Mindlin-Reissner理论允许独立的法线转动和横向剪切变形。本练习将通过一个解析推导，让您从Mindlin-Reissner的一般情况出发，通过施加Kirchhoff-Love运动学约束，亲眼见证横向剪切应变为零。这清晰地揭示了Kirchhoff-Love理论是Mindlin-Reissner理论在无剪切假设下的特例。[@problem_id:2588777]", "problem": "考虑一厚度为 $h$ 的均质、各向同性平板，其中面域为 $\\{(x,y)\\}$，横向沿 $z$ 轴方向。采用Mindlin–Reissner一阶剪切变形理论 (FSDT) 的运动学，其中三维位移场为\n$$\nu(x,y,z) \\;=\\; u_{0}(x,y) \\;+\\; z\\,\\phi_{x}(x,y),\\qquad\nv(x,y,z) \\;=\\; v_{0}(x,y) \\;+\\; z\\,\\phi_{y}(x,y),\\qquad\nw(x,y,z) \\;=\\; w_{0}(x,y),\n$$\n其中 $u_{0}$ 和 $v_{0}$ 是中面面内位移，$w_{0}$ 是中面的横向挠度，而 $\\phi_{x}$ 和 $\\phi_{y}$ 分别是与 $x$ 和 $y$ 方向相关的横向法线的独立转角。小应变、小转角运动学意味着工程横向剪切应变为\n$$\n\\gamma_{xz} \\;=\\; \\frac{\\partial u}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial x}, \\qquad\n\\gamma_{yz} \\;=\\; \\frac{\\partial v}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial y}.\n$$\n该板承受绕 $x$ 轴的均匀圆柱弯曲，其特征为相对于 $y$ 的恒定曲率 $\\kappa$，因此中面挠度为\n$$\nw_{0}(x,y) \\;=\\; \\frac{\\kappa}{2}\\,y^{2}.\n$$\n假设与剪切计算相关的中面面内位移为零，即 $u_{0}(x,y)=0$ 和 $v_{0}(x,y)=0$。仅使用上述给出的定义，计算Mindlin–Reissner剪切应变 $\\gamma_{xz}(x,y)$ 和 $\\gamma_{yz}(x,y)$，并用 $\\kappa$、$y$ 以及转角场 $\\phi_{x}(x,y)$ 和 $\\phi_{y}(x,y)$ 表示。然后，通过施加Kirchhoff–Love约束（即横向法线保持与中面正交），证明在Kirchhoff–Love极限下这些横向剪切应变为零。\n\n请以行矩阵的形式给出 $\\big(\\gamma_{xz}(x,y),\\,\\gamma_{yz}(x,y)\\big)$ 的最终答案。", "solution": "题干声明需经过验证。\n\n**第1步：提取已知条件**\n- **理论**：Mindlin–Reissner一阶剪切变形理论 (FSDT)。\n- **板**：均质、各向同性、平坦，厚度为 $h$，中面域为 $\\{(x,y)\\}$。\n- **运动学**：位移场由下式给出：\n$u(x,y,z) \\;=\\; u_{0}(x,y) \\;+\\; z\\,\\phi_{x}(x,y)$\n$v(x,y,z) \\;=\\; v_{0}(x,y) \\;+\\; z\\,\\phi_{y}(x,y)$\n$w(x,y,z) \\;=\\; w_{0}(x,y)$\n其中 $u_0, v_0$ 是中面面内位移，$w_0$ 是横向挠度，$\\phi_x, \\phi_y$ 是独立转角。\n- **应变定义**：工程横向剪切应变为：\n$\\gamma_{xz} \\;=\\; \\frac{\\partial u}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial x}$\n$\\gamma_{yz} \\;=\\; \\frac{\\partial v}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial y}$\n- **加载条件**：绕 $x$ 轴的均匀圆柱弯曲，相对于 $y$ 的曲率为常数 $\\kappa$。\n- **挠度**：中面挠度被指定为：\n$w_{0}(x,y) \\;=\\; \\frac{\\kappa}{2}\\,y^{2}$\n- **假设**：$u_{0}(x,y)=0$ 且 $v_{0}(x,y)=0$。\n- **任务**：\n  1. 用 $\\kappa$、$y$ 以及转角场 $\\phi_{x}(x,y)$ 和 $\\phi_{y}(x,y)$ 表示Mindlin–Reissner剪切应变 $\\gamma_{xz}(x,y)$ 和 $\\gamma_{yz}(x,y)$。\n  2. 施加Kirchhoff–Love约束（横向法线保持与中面正交），并证明这些剪切应变为零。\n\n**第2步：使用提取的已知条件进行验证**\n该问题有科学依据，是板理论中的一个标准练习。在特定的符号约定下，所有关于运动学和应变的定义都是FSDT的标准定义。该问题是自洽的、客观且适定的。给出的信息对于推导所需表达式以及证明Mindlin-Reissner理论与Kirchhoff-Love理论之间的关系是充分且一致的。不存在事实或逻辑上的不一致。\n\n**第3步：结论与行动**\n问题有效。将提供解答。\n\n解答按要求分两部分进行。首先，在Mindlin-Reissner框架下计算剪切应变。其次，正式推导并应用Kirchhoff-Love约束，以证明剪切应变为零。\n\n**第1部分：Mindlin–Reissner剪切应变的计算**\n\n位移场由FSDT运动学给出。我们应用给定的假设，即中面的面内位移为零，即 $u_{0}(x,y) = 0$ 和 $v_{0}(x,y) = 0$。运动学关系变为：\n$$u(x,y,z) = z\\,\\phi_{x}(x,y)$$\n$$v(x,y,z) = z\\,\\phi_{y}(x,y)$$\n$$w(x,y,z) = w_{0}(x,y)$$\n均匀圆柱弯曲的横向挠度由 $w_{0}(x,y) = \\frac{\\kappa}{2}y^{2}$ 给出。\n\n工程横向剪切应变定义为：\n$$\\gamma_{xz} = \\frac{\\partial u}{\\partial z} + \\frac{\\partial w}{\\partial x}$$\n$$\\gamma_{yz} = \\frac{\\partial v}{\\partial z} + \\frac{\\partial w}{\\partial y}$$\n\n我们计算所需的偏导数：\n1.  $u$ 对 $z$ 的导数：\n    $$\\frac{\\partial u}{\\partial z} = \\frac{\\partial}{\\partial z} \\left( z\\,\\phi_{x}(x,y) \\right) = \\phi_{x}(x,y)$$\n2.  $v$ 对 $z$ 的导数：\n    $$\\frac{\\partial v}{\\partial z} = \\frac{\\partial}{\\partial z} \\left( z\\,\\phi_{y}(x,y) \\right) = \\phi_{y}(x,y)$$\n3.  $w$ 对 $x$ 的导数：\n    $$\\frac{\\partial w}{\\partial x} = \\frac{\\partial w_{0}}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\frac{\\kappa}{2}y^{2} \\right) = 0$$\n4.  $w$ 对 $y$ 的导数：\n    $$\\frac{\\partial w}{\\partial y} = \\frac{\\partial w_{0}}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( \\frac{\\kappa}{2}y^{2} \\right) = \\kappa y$$\n\n将这些导数代入应变定义，得到指定圆柱弯曲情况下的Mindlin-Reissner剪切应变：\n$$\\gamma_{xz}(x,y) = \\phi_{x}(x,y) + 0 = \\phi_{x}(x,y)$$\n$$\\gamma_{yz}(x,y) = \\phi_{y}(x,y) + \\kappa y$$\n这就完成了第一个任务。\n\n**第2部分：Kirchhoff–Love约束的应用**\n\nKirchhoff–Love假定指出，初始垂直于板中面的材料线（法线）在变形后仍然垂直于变形后的中面。让我们将此约束形式化。\n\n首先，我们确定变形后中面的法向矢量。中面上的一点 $(x, y, 0)$ 移动到 $\\mathbf{p}_{0}(x,y) = (x, y, w_{0}(x,y))$。变形后中面的两个切向矢量为：\n$$\\mathbf{T}_{x} = \\frac{\\partial \\mathbf{p}_{0}}{\\partial x} = \\left(1, 0, \\frac{\\partial w_{0}}{\\partial x}\\right)$$\n$$\\mathbf{T}_{y} = \\frac{\\partial \\mathbf{p}_{0}}{\\partial y} = \\left(0, 1, \\frac{\\partial w_{0}}{\\partial y}\\right)$$\n因此，变形后中面的法向矢量 $\\mathbf{n}$ 可由它们的叉乘得到：\n$$\\mathbf{n} = \\mathbf{T}_{x} \\times \\mathbf{T}_{y} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 1 & 0 & \\frac{\\partial w_{0}}{\\partial x} \\\\ 0 & 1 & \\frac{\\partial w_{0}}{\\partial y} \\end{vmatrix} = \\left(-\\frac{\\partial w_{0}}{\\partial x}, -\\frac{\\partial w_{0}}{\\partial y}, 1\\right)$$\n\n接下来，我们确定变形后法线的方向矢量。在Mindlin-Reissner理论中，法线的变形由转角 $(\\phi_x, \\phi_y)$ 描述。对于小转角，变形后法线的方向矢量 $\\mathbf{d}$ 可以近似为：\n$$\\mathbf{d} \\approx (\\phi_x, \\phi_y, 1)$$\n这个矢量代表了原先沿 $z$ 轴的纤维在变形后的指向。\n\nKirchhoff-Love约束要求变形后的法线 $\\mathbf{d}$ 与变形后中面的法向矢量 $\\mathbf{n}$ 平行。这意味着对于某个标量 $C$，有 $\\mathbf{d} = C \\mathbf{n}$。\n$$(\\phi_{x}, \\phi_{y}, 1) = C \\left(-\\frac{\\partial w_{0}}{\\partial x}, -\\frac{\\partial w_{0}}{\\partial y}, 1\\right)$$\n比较两个矢量的第三个分量，我们得到 $1 = C \\cdot 1$，因此 $C=1$。然后，令其他分量相等，即可得到Kirchhoff-Love理论的运动学约束：\n$$\\phi_{x}(x,y) = -\\frac{\\partial w_{0}(x,y)}{\\partial x}$$\n$$\\phi_{y}(x,y) = -\\frac{\\partial w_{0}(x,y)}{\\partial y}$$\n这些方程将法线的转角直接与中面的斜率联系起来。\n\n现在，我们证明这些约束使得横向剪切应变为零。Mindlin-Reissner剪切应变的一般表达式为：\n$$\\gamma_{xz} = \\phi_{x} + \\frac{\\partial w_{0}}{\\partial x}$$\n$$\\gamma_{yz} = \\phi_{y} + \\frac{\\partial w_{0}}{\\partial y}$$\n将Kirchhoff-Love运动学约束代入这些表达式：\n$$\\gamma_{xz} = \\left(-\\frac{\\partial w_{0}}{\\partial x}\\right) + \\frac{\\partial w_{0}}{\\partial x} = 0$$\n$$\\gamma_{yz} = \\left(-\\frac{\\partial w_{0}}{\\partial y}\\right) + \\frac{\\partial w_{0}}{\\partial y} = 0$$\n因此，通过施加Kirchhoff–Love约束（即横向法线保持与中面正交），可以严格证明横向剪切应变 $\\gamma_{xz}$ 和 $\\gamma_{yz}$ 必须为零。这是区分Kirchhoff-Love理论与Mindlin-Reissner理论的定义性特征。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\phi_{x}(x,y) & \\phi_{y}(x,y) + \\kappa y\n\\end{pmatrix}\n}\n$$", "id": "2588777"}, {"introduction": "理解了理论的运动学之后，下一步是构建其有限元模型，其核心便是单元刚度矩阵。本练习将引导您从第一性原理出发，为四节点Mindlin-Reissner单元推导其完整的 $12 \\times 12$ 刚度矩阵。通过构建应变-位移矩阵($B$)和本构矩阵($D$)并执行积分 $K_e = \\int B^T D B \\, dA$，您将深入理解单元力学行为的数学基础，这是开发和使用有限元程序的关键一步。[@problem_id:2588744]", "problem": "在有限元法 (FEM) 中，使用四节点四边形Mindlin–Reissner板单元对一个各向同性、均质板进行建模。每个节点具有三个自由度：横向位移 $w$ 以及分别绕 $y$ 轴和 $x$ 轴的转角 $\\theta_{x}$ 和 $\\theta_{y}$。Mindlin–Reissner运动学假设一阶剪切变形，其横向剪应变为 $\\gamma_{xz}$ 和 $\\gamma_{yz}$，弯曲曲率为 $\\kappa_{x}$、$\\kappa_{y}$ 和 $\\kappa_{xy}$。该板的厚度为 $t$，杨氏模量为 $E$，泊松比为 $\\nu$，剪切修正因子为 $\\kappa$。剪切模量为 $G = E/\\bigl(2(1+\\nu)\\bigr)$。\n\n考虑一个四节点单元，它在物理 $(x,y)$ 平面内是一个边长分别为 $a$ (沿 $x$ 轴) 和 $b$ (沿 $y$ 轴) 的矩形，与坐标轴对齐，通过仿射映射 $x = \\tfrac{a}{2}\\,\\xi + x_{c}$ 和 $y = \\tfrac{b}{2}\\,\\eta + y_{c}$ 从母单元正方形 $(\\xi,\\eta)\\in[-1,1]^2$ 映射而来。在母单元域上使用标准的双线性形函数，\n$$\nN_{1}(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n\n从Mindlin–Reissner运动学定义和线弹性各向同性本构关系出发，并使用上述形函数对 $w$、$\\theta_{x}$ 和 $\\theta_{y}$ 进行标准的等参插值，完成以下任务：\n\n1. 推导弯曲和剪切的单元应变-位移矩阵 $B^{(b)}$ 和 $B^{(s)}$，用形函数对 $x$ 和 $y$ 的导数表示。清楚地指明每个矩阵映射到哪些广义应变。\n2. 写出Mindlin–Reissner理论中各向同性板的弯曲和剪切本构矩阵 $D^{(b)}$ 和 $D^{(s)}$。\n3. 以虚功原理为基本出发点，推导 $12\\times 12$ 的单元刚度矩阵，其为弯曲部分和剪切部分之和，\n$$\nK_{e} \\;=\\; K_{e}^{(b)} \\;+\\; K_{e}^{(s)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(b)}\\bigr)^{\\mathsf{T}} D^{(b)} B^{(b)}\\,\\mathrm{d}A \\;+\\; \\int_{\\Omega_{e}} \\bigl(B^{(s)}\\bigr)^{\\mathsf{T}} D^{(s)} B^{(s)}\\,\\mathrm{d}A,\n$$\n并明确指出与弯曲和剪切相关的子块，强调与横向位移 $w$ 的耦合存在与否。\n4. 对给定的矩形单元映射，使用全高斯积分（$[-1,1]^2$ 上的 $2\\times 2$ 个点，单位权重）计算这些积分。\n\n最后，作为一个具体的标量，计算在全高斯积分下得到的总单元刚度矩阵 $K_{e}$ 中，将节点1的横向位移 $w$ 与其自身耦合的单个刚度项的闭式符号表达式，即 $(w_{1},w_{1})$ 项。用 $E$、$\\nu$、$t$、$\\kappa$、$a$ 和 $b$ 表示你的最终答案。不要近似。答案以牛顿/米 (N/m) 为单位。最终报告的答案必须是单一的闭式表达式。", "solution": "出发点是Mindlin–Reissner板单元的虚功原理，该原理给出的单元刚度是弯曲和剪切贡献之和，\n$$\nK_{e} \\;=\\; K_{e}^{(b)} \\;+\\; K_{e}^{(s)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(b)}\\bigr)^{\\mathsf{T}} D^{(b)} B^{(b)}\\,\\mathrm{d}A \\;+\\; \\int_{\\Omega_{e}} \\bigl(B^{(s)}\\bigr)^{\\mathsf{T}} D^{(s)} B^{(s)}\\,\\mathrm{d}A.\n$$\n节点自由度的顺序为\n$$\n\\{d\\} \\;=\\; \\begin{bmatrix}\nw_{1} & \\theta_{x1} & \\theta_{y1} & w_{2} & \\theta_{x2} & \\theta_{y2} & w_{3} & \\theta_{x3} & \\theta_{y3} & w_{4} & \\theta_{x4} & \\theta_{y4}\n\\end{bmatrix}^{\\mathsf{T}}.\n$$\n\nMindlin–Reissner板的运动学关系为\n$$\n\\gamma_{xz} \\;=\\; \\theta_{x} \\;+\\; \\frac{\\partial w}{\\partial x},\\qquad\n\\gamma_{yz} \\;=\\; \\theta_{y} \\;+\\; \\frac{\\partial w}{\\partial y},\n$$\n$$\n\\kappa_{x} \\;=\\; \\frac{\\partial \\theta_{x}}{\\partial x},\\qquad\n\\kappa_{y} \\;=\\; \\frac{\\partial \\theta_{y}}{\\partial y},\\qquad\n\\kappa_{xy} \\;=\\; \\frac{\\partial \\theta_{x}}{\\partial y} \\;+\\; \\frac{\\partial \\theta_{y}}{\\partial x}.\n$$\n\n使用双线性形函数 $N_{i}$ 对场进行插值为\n$$\nw(\\xi,\\eta) \\;=\\; \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,w_{i},\\qquad\n\\theta_{x}(\\xi,\\eta) \\;=\\; \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,\\theta_{xi},\\qquad\n\\theta_{y}(\\xi,\\eta) \\;=\\; \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,\\theta_{yi}.\n$$\n对于矩形的仿射映射，雅可比矩阵是常数且是对角阵，\n$$\nJ \\;=\\; \\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta}\\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\frac{a}{2} & 0\\\\[4pt]\n0 & \\frac{b}{2}\n\\end{bmatrix},\\qquad\n\\det J \\;=\\; \\frac{ab}{4},\n$$\n导数变换如下\n$$\n\\frac{\\partial}{\\partial x} \\;=\\; \\frac{2}{a}\\,\\frac{\\partial}{\\partial \\xi},\\qquad\n\\frac{\\partial}{\\partial y} \\;=\\; \\frac{2}{b}\\,\\frac{\\partial}{\\partial \\eta}.\n$$\n\n通过将插值代入运动学关系并读取节点自由度的系数来构建应变-位移矩阵。定义广义应变向量\n$$\n\\{\\varepsilon^{(b)}\\} \\;=\\; \\begin{bmatrix} \\kappa_{x} & \\kappa_{y} & \\kappa_{xy} \\end{bmatrix}^{\\mathsf{T}},\\qquad\n\\{\\varepsilon^{(s)}\\} \\;=\\; \\begin{bmatrix} \\gamma_{xz} & \\gamma_{yz} \\end{bmatrix}^{\\mathsf{T}}.\n$$\n则\n$$\n\\{\\varepsilon^{(b)}\\} \\;=\\; B^{(b)} \\{d\\},\\qquad \\{\\varepsilon^{(s)}\\} \\;=\\; B^{(s)} \\{d\\},\n$$\n其中 $B^{(b)}\\in\\mathbb{R}^{3\\times 12}$ 和 $B^{(s)}\\in\\mathbb{R}^{2\\times 12}$ 是逐节点组装的。对于节点 $i$，与 $\\{w_{i},\\theta_{xi},\\theta_{yi}\\}$ 相关的对 $B^{(b)}$ 的 $3\\times 3$ 弯曲贡献为\n$$\nB^{(b)}_{i} \\;=\\; \\begin{bmatrix}\n0 & \\dfrac{\\partial N_{i}}{\\partial x} & 0\\\\[8pt]\n0 & 0 & \\dfrac{\\partial N_{i}}{\\partial y}\\\\[8pt]\n0 & \\dfrac{\\partial N_{i}}{\\partial y} & \\dfrac{\\partial N_{i}}{\\partial x}\n\\end{bmatrix},\n$$\n因此 $B^{(b)}$ 是 $B^{(b)}_{i}$（$i=1,\\dots,4$）的水平拼接，并且在 $w_{i}$ 出现的位置其列向量为零（弯曲不依赖于 $w$）。对于剪切，节点 $i$ 的 $2\\times 3$ 贡献为\n$$\nB^{(s)}_{i} \\;=\\; \\begin{bmatrix}\n\\dfrac{\\partial N_{i}}{\\partial x} & N_{i} & 0\\\\[8pt]\n\\dfrac{\\partial N_{i}}{\\partial y} & 0 & N_{i}\n\\end{bmatrix},\n$$\n因此 $B^{(s)}$ 是 $B^{(s)}_{i}$（$i=1,\\dots,4$）的水平拼接。\n\nMindlin–Reissner板的各向同性本构矩阵为\n$$\nD^{(b)} \\;=\\; \\frac{E t^{3}}{12\\bigl(1-\\nu^{2}\\bigr)}\\begin{bmatrix}\n1 & \\nu & 0\\\\[4pt]\n\\nu & 1 & 0\\\\[4pt]\n0 & 0 & \\dfrac{1-\\nu}{2}\n\\end{bmatrix},\\qquad\nD^{(s)} \\;=\\; \\kappa\\, G\\, t \\begin{bmatrix} 1 & 0\\\\[4pt] 0 & 1 \\end{bmatrix},\\quad G \\;=\\; \\frac{E}{2(1+\\nu)}.\n$$\n\n有了这些，单元刚度贡献可由下式得出\n$$\nK_{e}^{(b)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(b)}\\bigr)^{\\mathsf{T}} D^{(b)} B^{(b)}\\,\\mathrm{d}A,\\qquad\nK_{e}^{(s)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(s)}\\bigr)^{\\mathsf{T}} D^{(s)} B^{(s)}\\,\\mathrm{d}A.\n$$\n以分块矩阵形式，将自由度首先按 $\\{w\\}$ 排序，然后是 $\\{\\theta_{x},\\theta_{y}\\}$，可以观察到\n$$\nK_{e}^{(b)} \\;=\\; \\begin{bmatrix}\n0 & 0\\\\[4pt]\n0 & K_{\\theta\\theta}^{(b)}\n\\end{bmatrix},\\qquad\nK_{e}^{(s)} \\;=\\; \\begin{bmatrix}\nK_{ww}^{(s)} & K_{w\\theta}^{(s)}\\\\[4pt]\n\\bigl(K_{w\\theta}^{(s)}\\bigr)^{\\mathsf{T}} & K_{\\theta\\theta}^{(s)}\n\\end{bmatrix},\n$$\n因此弯曲部分仅涉及转动自由度，而剪切部分则耦合了横向位移和转角，并且也对 $K_{ww}$ 有贡献。\n\n$[-1,1]^2$ 上的 $2\\times 2$ 点全高斯积分使用四个点 $(\\xi,\\eta)=(\\pm s,\\pm s)$，其中 $s=1/\\sqrt{3}$，权重为单位权重。雅可比行列式是常数，$\\det J = ab/4$，因此对于任何被积函数 $f(\\xi,\\eta)$，\n$$\n\\int_{\\Omega_{e}} f\\,\\mathrm{d}A \\;=\\; \\sum_{g=1}^{4} f(\\xi_{g},\\eta_{g})\\,\\det J.\n$$\n\n我们现在计算所要求的单个标量项：通过全高斯积分得到的总单元刚度 $K_{e}$ 的 $(w_{1},w_{1})$ 项。如前所述，弯曲不依赖于 $w$，因此该项完全由 $K_{e}^{(s)}$ 贡献。根据 $B^{(s)}$ 的形式，$(w_{1},w_{1})$ 项为\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\int_{\\Omega_{e}} \\kappa\\,G\\,t\\left[\\left(\\frac{\\partial N_{1}}{\\partial x}\\right)^{2} + \\left(\\frac{\\partial N_{1}}{\\partial y}\\right)^{2}\\right]\\mathrm{d}A.\n$$\n对于矩形映射，使用 $N_{1}(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$，\n$$\n\\frac{\\partial N_{1}}{\\partial \\xi} \\;=\\; -\\frac{1}{4}(1-\\eta),\\qquad\n\\frac{\\partial N_{1}}{\\partial \\eta} \\;=\\; -\\frac{1}{4}(1-\\xi),\n$$\n因此\n$$\n\\frac{\\partial N_{1}}{\\partial x} \\;=\\; \\frac{2}{a}\\frac{\\partial N_{1}}{\\partial \\xi} \\;=\\; -\\frac{1}{2a}(1-\\eta),\\qquad\n\\frac{\\partial N_{1}}{\\partial y} \\;=\\; \\frac{2}{b}\\frac{\\partial N_{1}}{\\partial \\eta} \\;=\\; -\\frac{1}{2b}(1-\\xi).\n$$\n通过全高斯求积法计算该积分，\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\sum_{(\\xi,\\eta)\\in\\{\\pm s\\}^{2}} \\kappa\\,G\\,t\\left[\\frac{1}{4a^{2}}(1-\\eta)^{2} + \\frac{1}{4b^{2}}(1-\\xi)^{2}\\right]\\det J.\n$$\n由于高斯点集包含两个 $\\eta=s$ 和两个 $\\eta=-s$ 的点，对 $\\xi$ 也类似，因此求和可以分离。令 $s=1/\\sqrt{3}$。则\n$$\n\\sum_{(\\xi,\\eta)} (1-\\eta)^{2} \\;=\\; 2\\bigl[(1-s)^{2} + (1+s)^{2}\\bigr] \\;=\\; 4(1+s^{2}),\n$$\n同样的恒等式也适用于 $\\sum_{(\\xi,\\eta)} (1-\\xi)^{2}$。因此，\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\kappa\\,G\\,t\\left[\\frac{1}{4a^{2}} + \\frac{1}{4b^{2}}\\right]\\cdot 4(1+s^{2})\\cdot \\det J.\n$$\n代入 $s^{2}=\\tfrac{1}{3}$ 和 $\\det J=\\tfrac{ab}{4}$，上式简化为\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\kappa\\,G\\,t\\left[\\frac{1}{4a^{2}} + \\frac{1}{4b^{2}}\\right]\\cdot \\frac{16}{3}\\cdot \\frac{ab}{4}\n\\;=\\; \\kappa\\,G\\,t\\cdot \\frac{ab}{3}\\left[\\frac{1}{a^{2}}+\\frac{1}{b^{2}}\\right]\n\\;=\\; \\kappa\\,G\\,t\\cdot \\frac{1}{3}\\left(\\frac{b}{a}+\\frac{a}{b}\\right).\n$$\n代入 $G=\\dfrac{E}{2(1+\\nu)}$ 得到最终的闭式表达式\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\frac{\\kappa\\,E\\,t}{6(1+\\nu)}\\left(\\frac{a}{b}+\\frac{b}{a}\\right).\n$$\n单位是牛顿/米，因为 $\\kappa$ 是无量纲的，$E$ 的单位是压力，$t$ 是长度。\n\n至此，完成了将单元刚度分解为弯曲和剪切部分，以及使用全高斯积分计算所要求的标量刚度项的推导。", "answer": "$$\\boxed{\\dfrac{\\kappa\\,E\\,t}{6(1+\\nu)}\\left(\\dfrac{a}{b}+\\dfrac{b}{a}\\right)}$$", "id": "2588744"}, {"introduction": "理论正确的单元在计算中未必有效，因为“剪切锁定”(shear locking)等数值问题会严重影响其精度，因此必须通过“斑块检验”(patch test)进行验证。这项编程实践将带您从理论走向代码，要求您实现并对比三种不同的Mindlin-Reissner单元。通过在纯弯曲和纯剪切条件下测试它们，您将直面剪切锁定问题，并理解为何需要诸如MITC之类的先进技术来确保单元的可靠性。[@problem_id:2588738]", "problem": "考虑一阶剪切变形（Mindlin-Reissner）板理论，其运动学场由横向挠度 $w(x,y)$ 以及法线分别绕 $y$ 轴和 $x$ 轴的转角 $\\theta_x(x,y)$ 和 $\\theta_y(x,y)$ 给出。横向剪切应变为 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$。弯曲曲率为 $\\kappa_{xx} = -\\partial \\theta_x/\\partial x$、$\\kappa_{yy} = -\\partial \\theta_y/\\partial y$ 和 $\\kappa_{xy} = -(\\partial \\theta_x/\\partial y + \\partial \\theta_y/\\partial x)$。在斑块检验中，我们指定一个变形场，该场要么引起一个剪切为零的常曲率状态（纯弯曲），要么引起一个曲率为零的恒定横向剪切状态（纯剪切），然后检查一个有限元格式是否能在精确节点插值的情况下，以零误差再现目标应变场。\n\n实现并比较三种用于斑块检验的四节点四边形（$Q4$）Mindlin-Reissner板单元：\n- 标准双线性单元：$w$、$\\theta_x$ 和 $\\theta_y$ 使用相同的等参双线性形函数进行插值。横向剪切应变直接计算为 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$。使用位于 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ 且权重为单位值的全二乘二高斯积分。\n- 减缩积分单元：运动学关系相同，但使用位于 $(0,0)$、权重为 $4$ 的单个高斯点来计算横向剪切应变和任何与剪切相关的积分；弯曲量仍在二乘二高斯点处计算。对于此任务，如下文定义的误差度量，剪切误差的计算规则应与为减缩积分情况指定的规则（单个高斯点）相同，弯曲误差的计算规则应与下文指定的规则（二乘二高斯点）相同。\n- 张量分量的混合插值（MITC）：对于弯曲量，$w$、$\\theta_x$ 和 $\\theta_y$ 使用相同的双线性插值，但通过在适当的边中点关联剪切应变分量，并在单元内对其进行插值，来构建修正的横向剪切应变 $\\gamma_{xz}^\\ast$ 和 $\\gamma_{yz}^\\ast$。这种方式可以确保在纯弯曲状态下剪切为零，并在纯剪切状态下再现恒定的剪切。在母体域中，$\\gamma_{xz}$ 的关联点位于边的中点 $(\\xi, \\eta) = (0, +1)$ 和 $(0, -1)$，而 $\\gamma_{yz}$ 的关联点位于 $(+1, 0)$ 和 $(-1, 0)$。使用关联的剪切场 $\\gamma^\\ast$，在二乘二高斯点处评估剪切应变的误差。\n\n使用母体正方形 $[-1,1]\\times[-1,1]$ 上的标准双线性形函数进行等参映射，并仿射变换到具有给定节点坐标的物理单元上。对于给定的精确场，通过在物理节点坐标处对精确场进行采样来分配节点值。\n\n为斑块检验定义两个精确场：\n- 绕 $y$ 轴的纯弯曲，具有恒定曲率 $\\kappa_x$：$w(x,y) = \\tfrac{1}{2}\\kappa_x x^2$，$\\theta_x(x,y) = -\\kappa_x x$ 和 $\\theta_y(x,y) = 0$。对于此状态，精确的横向剪切应变处处为零，即 $\\gamma_{xz} = 0$ 和 $\\gamma_{yz} = 0$。使用 $\\kappa_x = 1.0$，单位为 $\\text{m}^{-1}$；由此产生的剪切误差是无量纲的。\n- $x$ 方向的纯横向剪切，具有恒定的 $\\gamma_{xz} = \\gamma_0$ 和 $\\gamma_{yz} = 0$：取 $w(x,y) = 0$，$\\theta_x(x,y) = \\gamma_0$ 和 $\\theta_y(x,y) = 0$。对于此状态，精确的弯曲曲率恒为零。使用 $\\gamma_0 = 1.0$（无量纲）；由此产生的曲率误差单位为 $\\text{m}^{-1}$。\n\n将误差评估为单元上的均方根（RMS）度量：\n- 对于给定单元和给定场的剪切误差：令 $\\mathbf{\\gamma}$ 表示直接剪切应变 $(\\gamma_{xz}, \\gamma_{yz})$（对于标准和减缩积分单元）或关联剪切应变 $(\\gamma_{xz}^\\ast, \\gamma_{yz}^\\ast)$（对于 MITC 单元）。定义 RMS 剪切误差为\n$$\n\\varepsilon_{\\text{shear}} = \\sqrt{\\frac{\\int_{\\Omega_e} \\left(\\gamma_{xz}^2 + \\gamma_{yz}^2\\right)\\, \\mathrm{d}\\Omega}{\\int_{\\Omega_e} \\mathrm{d}\\Omega}},\n$$\n按上述每种单元指定的相应高斯法则进行近似计算。\n- 对于给定单元和给定场的弯曲误差：令 $\\boldsymbol{\\kappa} = (\\kappa_{xx}, \\kappa_{yy}, \\kappa_{xy})$ 通过插值的转角直接计算。定义 RMS 弯曲误差为\n$$\n\\varepsilon_{\\text{bend}} = \\sqrt{\\frac{\\int_{\\Omega_e} \\left(\\kappa_{xx}^2 + \\kappa_{yy}^2 + \\kappa_{xy}^2\\right)\\, \\mathrm{d}\\Omega}{\\int_{\\Omega_e} \\mathrm{d}\\Omega}},\n$$\n使用二乘二高斯法则进行近似计算。\n\n构建一个包含两种单元几何形状的测试套件（节点按逆时针排序）：\n- 几何形状 A（正方形）：节点位于 $(-0.5,-0.5)$、$(0.5,-0.5)$、$(0.5,0.5)$、$(-0.5,0.5)$，坐标单位为 $\\text{m}$。\n- 几何形状 B（高纵横比矩形）：节点位于 $(-2.0,-0.25)$、$(2.0,-0.25)$、$(2.0,0.25)$、$(-2.0,0.25)$，坐标单位为 $\\text{m}$。\n\n对每种几何形状，计算：\n- 对于纯弯曲场：计算三种单元（标准、减缩积分、MITC）各自的 RMS 剪切误差 $\\varepsilon_{\\text{shear}}$。\n- 对于纯剪切场：计算三种单元（标准、减缩积分、MITC）各自的 RMS 弯曲误差 $\\varepsilon_{\\text{bend}}$。\n\n您的程序应生成单行输出，其中包含 $12$ 个浮点值的结果，以逗号分隔列表的形式并用方括号括起，顺序如下：\n- 对于几何形状 A：$[\\varepsilon_{\\text{shear}}^{\\text{STD}}, \\varepsilon_{\\text{shear}}^{\\text{RI}}, \\varepsilon_{\\text{shear}}^{\\text{MITC}}, \\varepsilon_{\\text{bend}}^{\\text{STD}}, \\varepsilon_{\\text{bend}}^{\\text{RI}}, \\varepsilon_{\\text{bend}}^{\\text{MITC}}]$。\n- 对于几何形状 B：$[\\varepsilon_{\\text{shear}}^{\\text{STD}}, \\varepsilon_{\\text{shear}}^{\\text{RI}}, \\varepsilon_{\\text{shear}}^{\\text{MITC}}, \\varepsilon_{\\text{bend}}^{\\text{STD}}, \\varepsilon_{\\text{bend}}^{\\text{RI}}, \\varepsilon_{\\text{bend}}^{\\text{MITC}}]$。\n\n所有应变均为无量纲，所有曲率单位均为 $\\text{m}^{-1}$。按指定顺序将数值报告为十进制浮点数。最终输出必须是形如 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{12}]$ 的单行。", "solution": "所提出的问题是计算力学领域中一个明确定义的练习，特别是在使用 Mindlin-Reissner 理论进行板的有限元分析方面。它要求通过标准的斑块检验来实现和验证三种不同的四节点四边形单元格式。该问题具有科学依据，形式规范，且内部一致。它提供了所有必要的数据，包括运动学关系、单元插值方案、积分规则、用于测试的指定变形场以及精确的误差度量。因此，该问题被认为是有效的，下文提供了正式的解答。\n\n该解答首先建立了等参四节点 Mindlin-Reissner 板单元的理论基础。随后，详细介绍了标准（STD）、减缩积分（RI）和张量分量的混合插值（MITC）单元的具体格式。最后，实施斑块检验程序和误差计算，以生成所需的数值结果。\n\n### 1. Mindlin-Reissner 板理论与运动学\n\nMindlin-Reissner 理论是一种用于板的一阶剪切变形理论。位于 $x-y$ 平面中的板中面的运动学状态由三个独立的场描述：横向挠度 $w(x,y)$ 和横截面的两个转角，即绕 $y$ 轴的 $\\theta_x(x,y)$ 和绕 $x$ 轴的 $\\theta_y(x,y)$。\n\n弯曲曲率（用向量 $\\boldsymbol{\\kappa}$ 表示）和横向剪切应变（用向量 $\\boldsymbol{\\gamma}$ 表示）定义如下：\n$$\n\\boldsymbol{\\kappa} =\n\\begin{Bmatrix} \\kappa_{xx} \\\\ \\kappa_{yy} \\\\ \\kappa_{xy} \\end{Bmatrix} =\n\\begin{Bmatrix} -\\frac{\\partial \\theta_x}{\\partial x} \\\\ -\\frac{\\partial \\theta_y}{\\partial y} \\\\ -(\\frac{\\partial \\theta_x}{\\partial y} + \\frac{\\partial \\theta_y}{\\partial x}) \\end{Bmatrix}\n\\quad , \\quad\n\\boldsymbol{\\gamma} =\n\\begin{Bmatrix} \\gamma_{xz} \\\\ \\gamma_{yz} \\end{Bmatrix} =\n\\begin{Bmatrix} \\theta_x + \\frac{\\partial w}{\\partial x} \\\\ \\theta_y + \\frac{\\partial w}{\\partial y} \\end{Bmatrix}\n$$\n\n### 2. 等参四节点四边形（$Q4$）单元\n\n单元的几何形状和运动学场通过在母体正方形域 $[-1,1] \\times [-1,1]$ 上定义的等参双线性形函数 $N_i(\\xi, \\eta)$ 从节点值插值得到。四个形函数为：\n$$\nN_1 = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad, \\quad N_2 = \\frac{1}{4}(1+\\xi)(1-\\eta) \\quad, \\quad N_3 = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad, \\quad N_4 = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n单元内的物理坐标 $(x,y)$ 和运动学场 $(w, \\theta_x, \\theta_y)$ 由各自的节点值插值得到：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) x_i \\quad, \\quad y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) y_i\n$$\n$$\nw^h(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) w_i \\quad, \\quad \\theta_x^h(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{xi} \\quad, \\quad \\theta_y^h(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{yi}\n$$\n上标 $h$ 表示有限元近似。相对于物理坐标的导数通过链式法则获得，这涉及到雅可比矩阵 $\\boldsymbol{J}$：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\boldsymbol{J}^{-1} \\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} \\quad \\text{其中} \\quad \\boldsymbol{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} \\sum \\frac{\\partial N_i}{\\partial \\xi} x_i & \\sum \\frac{\\partial N_i}{\\partial \\xi} y_i \\\\ \\sum \\frac{\\partial N_i}{\\partial \\eta} x_i & \\sum \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{bmatrix}\n$$\n微分面积元变换为 $d\\Omega = \\det(\\boldsymbol{J}) d\\xi d\\eta$。对于指定的矩形几何形状，雅可比矩阵 $\\boldsymbol{J}$ 是一个常数对角矩阵。\n\n### 3. 单元格式和应变计算\n\n三种单元格式在计算横向剪切应变和处理相关数值积分的方式上有所不同，这是避免剪切自锁的关键方面。\n\n**标准（STD）单元：** 所有场都进行双线性插值。应变通过将运动学定义直接应用于插值场来计算。任何积分（例如，用于刚度矩阵或误差范数）中的弯曲项和剪切项都使用完整的 $2 \\times 2$ 高斯求积法则进行计算，积分点位于 $(\\xi, \\eta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，权重 $w_g=1$。已知这种格式会遭受严重的剪切自锁，特别是在薄板或扭曲网格的情况下。\n\n**减缩积分（RI）单元：** 此格式与标准单元相同，不同之处在于涉及横向剪切应变的积分使用位于单元中心 $(\\xi, \\eta) = (0,0)$、权重为 $w_g=4$ 的单个高斯点进行计算。对于本问题，剪切误差 $\\varepsilon_{\\text{shear}}$ 使用此 $1 \\times 1$ 法则计算。与弯曲相关的积分继续使用 $2 \\times 2$ 法则。该技术通常能缓解剪切自锁，但有时会引入其他问题，如伪零能模式。\n\n**张量分量的混合插值（MITC）单元：** 这是一种更复杂的对抗剪切自锁的方法。虽然弯曲曲率是直接从双线性插值的转角计算得出的，但横向剪切应变则源自一个单独的“关联”插值。\n过程如下：\n1.  “原始”横向剪切应变 $(\\gamma_{xz}, \\gamma_{yz})$ 在母体域中单元边上的特定关联点处进行计算。对于 $\\gamma_{xz}$，关联点为 $A: (\\xi=0, \\eta=-1)$ 和 $B: (\\xi=0, \\eta=1)$。对于 $\\gamma_{yz}$，关联点为 $C: (\\xi=-1, \\eta=0)$ 和 $D: (\\xi=1, \\eta=0)$。\n2.  在这些点上，应变根据标准运动学定义计算，例如 $\\gamma_{xz, A} = \\theta_x^h(A) + \\frac{\\partial w^h}{\\partial x}(A)$。\n3.  然后，使用这些关联值在单元上插值出一个修正的剪切应变场 $(\\gamma_{xz}^\\ast, \\gamma_{yz}^\\ast)$：\n    $$\n    \\gamma_{xz}^\\ast(\\xi, \\eta) = \\frac{1}{2}(1-\\eta) \\gamma_{xz,A} + \\frac{1}{2}(1+\\eta) \\gamma_{xz,B}\n    $$\n    $$\n    \\gamma_{yz}^\\ast(\\xi, \\eta) = \\frac{1}{2}(1-\\xi) \\gamma_{yz,C} + \\frac{1}{2}(1+\\xi) \\gamma_{yz,D}\n    $$\n4.  剪切误差 $\\varepsilon_{\\text{shear}}$ 通过在单元上使用 $2 \\times 2$ 高斯法则对这些修正应变 $\\gamma^\\ast$ 进行积分来计算。\n\n### 4. 斑块检验和误差评估\n\n斑块检验验证了单元精确再现恒定应变状态的能力。这里测试两种状态：\n- **纯弯曲：** 指定一个具有恒定曲率 $\\kappa_{xx} = \\kappa_x = 1.0$ 和零横向剪切应变 $(\\gamma_{xz} = \\gamma_{yz}=0)$ 的场： $w(x,y) = \\frac{1}{2}\\kappa_x x^2$, $\\theta_x(x,y) = -\\kappa_x x$, $\\theta_y(x,y) = 0$。计算数值剪切误差 $\\varepsilon_{\\text{shear}}$。理想的单元应得出 $\\varepsilon_{\\text{shear}} = 0$。\n- **纯剪切：** 指定一个具有恒定剪切应变 $\\gamma_{xz} = \\gamma_0 = 1.0$ 和零曲率 $(\\kappa_{xx} = \\kappa_{yy} = \\kappa_{xy} = 0)$ 的场： $w(x,y)=0$, $\\theta_x(x,y)=\\gamma_0$, $\\theta_y(x,y)=0$。计算数值弯曲误差 $\\varepsilon_{\\text{bend}}$。理想的单元应得出 $\\varepsilon_{\\text{bend}} = 0$。\n\n对于每个测试，通过在单元的物理节点坐标处评估指定的解析场来获得节点值 $(w_i, \\theta_{xi}, \\theta_{yi})$。\n\n误差使用均方根（RMS）度量进行量化，通过数值积分计算：\n$$\n\\varepsilon_{\\text{shear}} = \\sqrt{\\frac{\\sum_{g} (\\gamma_{xz}^2 + \\gamma_{yz}^2)_g w_g \\det(\\boldsymbol{J}_g)}{\\sum_{g} w_g \\det(\\boldsymbol{J}_g)}} \\quad , \\quad \\varepsilon_{\\text{bend}} = \\sqrt{\\frac{\\sum_{g} (\\kappa_{xx}^2 + \\kappa_{yy}^2 + \\kappa_{xy}^2)_g w_g \\det(\\boldsymbol{J}_g)}{\\sum_{g} w_g \\det(\\boldsymbol{J}_g)}}\n$$\n求和是对为每种单元类型和应变分量指定的 高斯点 $g$ 进行的。项 $\\gamma$ 对于 STD 和 RI 单元指的是直接计算的剪切应变，对于 MITC 单元指的是关联应变 $\\gamma^\\ast$。\n\n### 5. 算法实现\n\nPython 代码实现了这些过程。一个主循环遍历指定的两种几何形状。对于每种几何形状，它执行两种斑块检验。\n1.  **纯弯曲检验：**\n    - 从纯弯曲场方程计算节点自由度。\n    - 为 STD、RI 和 MITC 单元计算剪切误差 $\\varepsilon_{\\text{shear}}$，使用它们各自的应变计算和积分规则。\n2.  **纯剪切检验：**\n    - 从纯剪切场方程计算节点自由度。\n    - 为所有三个单元计算弯曲误差 $\\varepsilon_{\\text{bend}}$，使用 $2 \\times 2$ 高斯法则。\n\n对于给定的简单矩形几何形状，纯剪切场的有限元近似是精确的，导致所有单元类型的弯曲误差都为零。对于纯弯曲场，双线性单元无法精确表示二次挠度 $w=\\frac{1}{2}\\kappa_x x^2$，这会导致寄生剪切应变。标准单元表现出非零的剪切误差，显示出剪切自锁现象。减缩积分和 MITC 格式旨在纠正此缺陷，并有望在矩形单元上以零误差通过此检验。代码得出的结果与这些理论预期一致。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares three Q4 Mindlin-Reissner plate elements\n    (Standard, Reduced Integration, MITC) in a patch test.\n    \"\"\"\n    \n    # --- Constants and Test Case Definitions ---\n    KAPPA_X = 1.0  # m^-1\n    GAMMA_0 = 1.0  # dimensionless\n\n    # Gauss points and weights for 2x2 integration\n    gp_val = 1.0 / np.sqrt(3.0)\n    GAUSS_2x2 = {\n        'points': [\n            (-gp_val, -gp_val), (gp_val, -gp_val),\n            (gp_val, gp_val), (-gp_val, gp_val)\n        ],\n        'weights': [1.0, 1.0, 1.0, 1.0]\n    }\n    \n    # Gauss point and weight for 1x1 integration\n    GAUSS_1x1 = {\n        'points': [(0.0, 0.0)],\n        'weights': [4.0]\n    }\n\n    geometries = {\n        'A': np.array([\n            [-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]\n        ]),\n        'B': np.array([\n            [-2.0, -0.25], [2.0, -0.25], [2.0, 0.25], [-2.0, 0.25]\n        ])\n    }\n\n    # --- Core FEM Helper Functions ---\n\n    def get_shape_functions(xi, eta):\n        \"\"\"Returns bilinear shape functions and their derivatives in parent coords.\"\"\"\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        dNdxi = 0.25 * np.array([\n            -(1 - eta), (1 - eta), (1 + eta), -(1 + eta)\n        ])\n        dNdeta = 0.25 * np.array([\n            -(1 - xi), -(1 + xi), (1 + xi), (1 - xi)\n        ])\n        return N, dNdxi, dNdeta\n\n    def get_jacobian_and_physical_grads(xi, eta, nodes):\n        \"\"\"Computes Jacobian, its determinant, and shape function grads in physical coords.\"\"\"\n        _, dNdxi, dNdeta = get_shape_functions(xi, eta)\n        \n        # Jacobian matrix J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dNdxi, nodes[:, 0])\n        J[0, 1] = np.dot(dNdxi, nodes[:, 1])\n        J[1, 0] = np.dot(dNdeta, nodes[:, 0])\n        J[1, 1] = np.dot(dNdeta, nodes[:, 1])\n        \n        detJ = np.linalg.det(J)\n        if detJ = 0:\n            raise ValueError(\"Jacobian determinant is non-positive.\")\n        \n        J_inv = np.linalg.inv(J)\n        \n        # Gradients of shape functions w.r.t physical coordinates (x, y)\n        dG = np.vstack((dNdxi, dNdeta)) # shape (2, 4)\n        dN_dxy = J_inv @ dG # shape (2, 4)\n        dNdx = dN_dxy[0, :]\n        dNdy = dN_dxy[1, :]\n        \n        return detJ, dNdx, dNdy\n\n    # --- Element-Specific Calculation Functions ---\n\n    def calculate_errors(nodes, nodal_dofs):\n        \"\"\"\n        Calculates shear and bending errors for all three element formulations.\n        \"\"\"\n        w_nodal = nodal_dofs[:, 0]\n        th_x_nodal = nodal_dofs[:, 1]\n        th_y_nodal = nodal_dofs[:, 2]\n\n        # --- Quantities for STD and RI elements ---\n        num_shear_std, den_shear_std = 0.0, 0.0\n        num_shear_ri, den_shear_ri = 0.0, 0.0\n        num_bend_std_ri, den_bend_std_ri = 0.0, 0.0\n        \n        # Bending error (and shear for STD) uses 2x2 Gauss rule\n        for i, (xi, eta) in enumerate(GAUSS_2x2['points']):\n            w_gp = GAUSS_2x2['weights'][i]\n            N, _, _ = get_shape_functions(xi, eta)\n            detJ, dNdx, dNdy = get_jacobian_and_physical_grads(xi, eta, nodes)\n            \n            # Interpolated rotations\n            th_x = np.dot(N, th_x_nodal)\n            th_y = np.dot(N, th_y_nodal)\n            \n            # Bending curvatures\n            k_xx = -np.dot(dNdx, th_x_nodal)\n            k_yy = -np.dot(dNdy, th_y_nodal)\n            k_xy = -(np.dot(dNdy, th_x_nodal) + np.dot(dNdx, th_y_nodal))\n            \n            # Direct shear strains\n            gam_xz = th_x + np.dot(dNdx, w_nodal)\n            gam_yz = th_y + np.dot(dNdy, w_nodal)\n            \n            num_bend_std_ri += (k_xx**2 + k_yy**2 + k_xy**2) * w_gp * detJ\n            den_bend_std_ri += w_gp * detJ\n            \n            num_shear_std += (gam_xz**2 + gam_yz**2) * w_gp * detJ\n            den_shear_std += w_gp * detJ\n\n        # Shear error for RI uses 1x1 Gauss rule\n        xi_ri, eta_ri = GAUSS_1x1['points'][0]\n        w_gp_ri = GAUSS_1x1['weights'][0]\n        N_ri, _, _ = get_shape_functions(xi_ri, eta_ri)\n        detJ_ri, dNdx_ri, dNdy_ri = get_jacobian_and_physical_grads(xi_ri, eta_ri, nodes)\n        \n        th_x_ri = np.dot(N_ri, th_x_nodal)\n        gam_xz_ri = th_x_ri + np.dot(dNdx_ri, w_nodal)\n        th_y_ri = np.dot(N_ri, th_y_nodal)\n        gam_yz_ri = th_y_ri + np.dot(dNdy_ri, w_nodal)\n        \n        num_shear_ri = (gam_xz_ri**2 + gam_yz_ri**2) * w_gp_ri * detJ_ri\n        den_shear_ri = w_gp_ri * detJ_ri\n\n        eps_shear_std = np.sqrt(num_shear_std / den_shear_std)\n        eps_shear_ri = np.sqrt(num_shear_ri / den_shear_ri)\n        eps_bend_std = np.sqrt(num_bend_std_ri / den_bend_std_ri)\n        eps_bend_ri = eps_bend_std # Same bending formulation\n\n        # --- Quantities for MITC element ---\n        tying_points = {\n            'A': (0.0, -1.0), 'B': (0.0, 1.0), # for gamma_xz\n            'C': (-1.0, 0.0), 'D': (1.0, 0.0)  # for gamma_yz\n        }\n        \n        tied_strains = {}\n        for name, (xi, eta) in tying_points.items():\n            N, _, _ = get_shape_functions(xi, eta)\n            _, dNdx, dNdy = get_jacobian_and_physical_grads(xi, eta, nodes)\n            th_x = np.dot(N, th_x_nodal)\n            th_y = np.dot(N, th_y_nodal)\n            gam_xz = th_x + np.dot(dNdx, w_nodal)\n            gam_yz = th_y + np.dot(dNdy, w_nodal)\n            tied_strains[name] = (gam_xz, gam_yz)\n        \n        gam_xz_A = tied_strains['A'][0]\n        gam_xz_B = tied_strains['B'][0]\n        gam_yz_C = tied_strains['C'][1]\n        gam_yz_D = tied_strains['D'][1]\n\n        num_shear_mitc, den_shear_mitc = 0.0, 0.0\n        for i, (xi, eta) in enumerate(GAUSS_2x2['points']):\n            w_gp = GAUSS_2x2['weights'][i]\n            detJ, _, _ = get_jacobian_and_physical_grads(xi, eta, nodes)\n            \n            # Interpolated tied shear strains\n            gam_xz_star = 0.5 * (1 - eta) * gam_xz_A + 0.5 * (1 + eta) * gam_xz_B\n            gam_yz_star = 0.5 * (1 - xi) * gam_yz_C + 0.5 * (1 + xi) * gam_yz_D\n            \n            num_shear_mitc += (gam_xz_star**2 + gam_yz_star**2) * w_gp * detJ\n            den_shear_mitc += w_gp * detJ\n        \n        eps_shear_mitc = np.sqrt(num_shear_mitc / den_shear_mitc)\n        eps_bend_mitc = eps_bend_std # Same bending formulation\n        \n        return {\n            'shear_std': eps_shear_std, 'shear_ri': eps_shear_ri, 'shear_mitc': eps_shear_mitc,\n            'bend_std': eps_bend_std, 'bend_ri': eps_bend_ri, 'bend_mitc': eps_bend_mitc\n        }\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    \n    for geom_name in sorted(geometries.keys()):\n        nodes = geometries[geom_name]\n        \n        # 1. Pure Bending Patch Test (compute shear error)\n        dofs_bending_test = np.zeros((4, 3))\n        dofs_bending_test[:, 0] = 0.5 * KAPPA_X * nodes[:, 0]**2  # w\n        dofs_bending_test[:, 1] = -KAPPA_X * nodes[:, 0]        # theta_x\n        dofs_bending_test[:, 2] = 0.0                           # theta_y\n        \n        errors_bending_test = calculate_errors(nodes, dofs_bending_test)\n        all_results.append(errors_bending_test['shear_std'])\n        all_results.append(errors_bending_test['shear_ri'])\n        all_results.append(errors_bending_test['shear_mitc'])\n        \n        # 2. Pure Shear Patch Test (compute bending error)\n        dofs_shear_test = np.zeros((4, 3))\n        dofs_shear_test[:, 0] = 0.0                             # w\n        dofs_shear_test[:, 1] = GAMMA_0                         # theta_x\n        dofs_shear_test[:, 2] = 0.0                             # theta_y\n        \n        errors_shear_test = calculate_errors(nodes, dofs_shear_test)\n        all_results.append(errors_shear_test['bend_std'])\n        all_results.append(errors_shear_test['bend_ri'])\n        all_results.append(errors_shear_test['bend_mitc'])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in all_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2588738"}]}