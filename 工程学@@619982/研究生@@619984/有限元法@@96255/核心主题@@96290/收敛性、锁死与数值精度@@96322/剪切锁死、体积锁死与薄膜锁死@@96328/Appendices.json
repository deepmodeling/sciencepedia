{"hands_on_practices": [{"introduction": "剪切锁定是模拟弯曲行为的单元（如铁木辛柯梁单元）中常见的数值问题。本练习提供了一种直接的动手方法，通过实现一个简单的线性铁木辛柯梁单元来“看见”这一效应。通过将薄梁的数值解与精确解进行比较，您将能定量地分析单元如何变得过于刚硬，这是一项关键的诊断技能。[@problem_id:2595579]", "problem": "考虑一个铁木辛柯梁模型，该梁为直棱柱、矩形截面的悬臂梁，长度为 $L$，在自由端承受横向点载荷 $P$。截面单位宽度 $b=1$，厚度为 $t$。材料的杨氏模量为 $E$，剪切模量为 $G$。铁木辛柯运动学采用横向位移场 $w(x)$ 和截面转角 $\\varphi(x)$。弯曲曲率为 $\\kappa_b(x)=\\dfrac{d\\varphi}{dx}$，剪切应变为 $\\gamma(x)=\\dfrac{dw}{dx}-\\varphi(x)$。一个区间上的应变能是弯曲和剪切贡献之和。弯曲刚度为 $E I$，其中 $I=\\dfrac{b t^3}{12}$；剪切刚度为 $\\kappa_s G A$，其中 $A=b\\,t$，对于矩形截面，剪切修正因子 $\\kappa_s=\\dfrac{5}{6}$。在末端载荷 $P$ 作用下，悬臂梁的铁木辛柯精确尖端挠度由弯曲部分和剪切部分之和给出。本问题中所有量均为无量纲，因此答案中无需物理单位。\n\n您将使用线性双节点铁木辛柯梁单元，在均匀网格上实现一个有限元模型。每个节点有两个自由度：横向位移 $w$ 和转角 $\\varphi$。使用最小势能原理和标准的有限元装配程序。对于长度为 $\\ell_e$ 的单个单元，使用线性形函数 $N_1(x)=1-\\dfrac{x}{\\ell_e}$ 和 $N_2(x)=\\dfrac{x}{\\ell_e}$ 来近似 $w(x)$ 和 $\\varphi(x)$，即：\n$$\nw(x)=N_1(x)\\,w_1+N_2(x)\\,w_2,\\quad \\varphi(x)=N_1(x)\\,\\varphi_1+N_2(x)\\,\\varphi_2.\n$$\n从定义 $\\kappa_b(x)=\\dfrac{d\\varphi}{dx}$ 和 $\\gamma(x)=\\dfrac{dw}{dx}-\\varphi(x)$ 出发，通过在单元上对应变能密度的二次型进行积分，推导单元刚度矩阵。为在 $x=0$ 处固支（施加 $w(0)=0$ 和 $\\varphi(0)=0$）且在 $x=L$ 处仅受横向尖端载荷 $P$ 的悬臂梁，装配全局刚度矩阵。求解线性系统得到节点未知数，并提取在 $x=L$ 处的尖端位移的有限元近似值 $w_{\\mathrm{FE}}$。\n\n设计一个数值实验来量化尖端位移的收敛性并诊断剪切锁定现象。使用以下参数：\n- $L=10$, $E=1$, $G=1$, $\\kappa_s=\\dfrac{5}{6}$, $b=1$, $P=1$, 以及 $t\\in\\{1,0.1,0.01\\}$。\n- 对于每个厚度 $t$，在单元数量为 $n_e\\in\\{1,2,4,8,16,32\\}$ 的均匀网格上计算 $w_{\\mathrm{FE}}$。\n- 对每种情况，也计算精确的铁木辛柯尖端挠度\n$$\nw_{\\mathrm{exact}}=\\frac{P\\,L^3}{3\\,E\\,I}+\\frac{P\\,L}{\\kappa_s\\,G\\,A}.\n$$\n对每个 $n_e$ 和 $t$，通过比率 $r(n_e,t)=\\dfrac{w_{\\mathrm{FE}}(n_e,t)}{w_{\\mathrm{exact}}(t)}$ 来量化收敛性。您的程序必须输出所有网格和所有三种厚度的这些比率。\n\n测试套件和要求的最终输出格式：\n- 测试套件是 $t\\in\\{1,0.1,0.01\\}$ 和 $n_e\\in\\{1,2,4,8,16,32\\}$ 的笛卡尔积。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中外层列表包含三个内层列表，每个内层列表对应一个厚度值，按 $t=1$, $t=0.1$, $t=0.01$ 的顺序排列。每个内层列表必须包含六个浮点数比率 $r(n_e,t)$，按 $n_e=1,2,4,8,16,32$ 的顺序排列。例如，一个带有占位符值的输出看起来像\n$$\n[[r_{1,1},r_{2,1},r_{4,1},r_{8,1},r_{16,1},r_{32,1}],[r_{1,0.1},r_{2,0.1},r_{4,0.1},r_{8,0.1},r_{16,0.1},r_{32,0.1}],[r_{1,0.01},r_{2,0.01},r_{4,0.01},r_{8,0.01},r_{16,0.01},r_{32,0.01}]].\n$$\n不要打印任何其他文本。这些值必须通过如上所述装配和求解有限元系统来计算。\n\n您的任务：\n- 根据基本运动学定义和能量表达式，实现线性铁木辛柯梁单元的有限元装配。\n- 为指定的测试套件计算 $w_{\\mathrm{FE}}$ 和 $r(n_e,t)$。\n- 以指定的精确格式生成最终输出，仅包含比率的嵌套列表。\n- 运行程序后，将 $r(n_e,t)$ 随 $n_e$ 和 $t$ 变化的趋势解释为剪切锁定的证据：持续的低估（即 $r(n_e,t)<1$），且随着 $t$ 减小，通过网格细化改善缓慢，是剪切锁定的特征。您无需打印此解释；下面的解析解编写部分需要它。", "solution": "所提出的问题是计算力学中的一个标准练习，用于演示铁木辛柯梁有限元分析中被称为剪切锁定（Shear Locking）的数值假象。该问题具有科学依据，提法明确且完整。我将开始推导和求解。\n\n有限元方法的基础是最小势能原理。梁的总势能 $\\Pi$ 是内部应变能 $U$ 减去外力所做的功 $W_e$ 的总和。对于我们的问题，\n$$ \\Pi = U - W_e = \\frac{1}{2} \\int_0^L \\left( EI (\\kappa_b(x))^2 + \\kappa_s G A (\\gamma(x))^2 \\right) dx - P w(L) $$\n其中 $L$ 是梁长， $E$ 是杨氏模量， $I$ 是面积二次矩， $G$ 是剪切模量， $A$ 是截面积， $\\kappa_s$ 是剪切修正因子， $P$ 是在自由端 $x=L$ 处的点载荷。运动学变量是横向位移 $w(x)$ 和截面转角 $\\varphi(x)$。弯曲曲率为 $\\kappa_b(x) = \\frac{d\\varphi}{dx}$，剪切应变为 $\\gamma(x) = \\frac{dw}{dx} - \\varphi(x)$。\n\n我们将梁离散为 $n_e$ 个有限元。对于一个长度为 $\\ell_e$、局部坐标为 $\\bar{x} \\in [0, \\ell_e]$ 的双节点单元，场 $w(\\bar{x})$ 和 $\\varphi(\\bar{x})$ 从节点自由度进行插值。单元的节点位移向量为 $\\mathbf{d}_e = [w_1, \\varphi_1, w_2, \\varphi_2]^T$。我们使用指定的线性形函数 $N_1(\\bar{x}) = 1 - \\frac{\\bar{x}}{\\ell_e}$ 和 $N_2(\\bar{x}) = \\frac{\\bar{x}}{\\ell_e}$。\n$$ w(\\bar{x}) = N_1(\\bar{x}) w_1 + N_2(\\bar{x}) w_2 $$\n$$ \\varphi(\\bar{x}) = N_1(\\bar{x}) \\varphi_1 + N_2(\\bar{x}) \\varphi_2 $$\n关于 $\\bar{x}$ 的导数为：\n$$ \\frac{dw}{d\\bar{x}} = \\frac{d N_1}{d\\bar{x}} w_1 + \\frac{d N_2}{d\\bar{x}} w_2 = -\\frac{1}{\\ell_e} w_1 + \\frac{1}{\\ell_e} w_2 $$\n$$ \\frac{d\\varphi}{d\\bar{x}} = \\frac{d N_1}{d\\bar{x}} \\varphi_1 + \\frac{d N_2}{d\\bar{x}} \\varphi_2 = -\\frac{1}{\\ell_e} \\varphi_1 + \\frac{1}{\\ell_e} \\varphi_2 $$\n弯曲曲率 $\\kappa_b$ 在单元内是常数：\n$$ \\kappa_b(\\bar{x}) = \\frac{d\\varphi}{d\\bar{x}} = \\frac{1}{\\ell_e} (-\\varphi_1 + \\varphi_2) = \\begin{bmatrix} 0 & -\\frac{1}{\\ell_e} & 0 & \\frac{1}{\\ell_e} \\end{bmatrix} \\mathbf{d}_e = \\mathbf{B}_b \\mathbf{d}_e $$\n剪切应变 $\\gamma$ 在单元内是线性的：\n$$ \\gamma(\\bar{x}) = \\frac{dw}{d\\bar{x}} - \\varphi(\\bar{x}) = \\left( -\\frac{1}{\\ell_e} w_1 + \\frac{1}{\\ell_e} w_2 \\right) - \\left( (1-\\frac{\\bar{x}}{\\ell_e}) \\varphi_1 + \\frac{\\bar{x}}{\\ell_e} \\varphi_2 \\right) $$\n$$ \\gamma(\\bar{x}) = \\begin{bmatrix} -\\frac{1}{\\ell_e} & -(1-\\frac{\\bar{x}}{\\ell_e}) & \\frac{1}{\\ell_e} & -\\frac{\\bar{x}}{\\ell_e} \\end{bmatrix} \\mathbf{d}_e = \\mathbf{B}_s(\\bar{x}) \\mathbf{d}_e $$\n单元应变能 $U_e$ 由 $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$ 给出，其中单元刚度矩阵 $\\mathbf{K}_e$ 是弯曲刚度 $\\mathbf{K}_b$ 和剪切刚度 $\\mathbf{K}_s$ 之和：\n$$ \\mathbf{K}_e = \\mathbf{K}_b + \\mathbf{K}_s = \\int_0^{\\ell_e} \\mathbf{B}_b^T E I \\mathbf{B}_b d\\bar{x} + \\int_0^{\\ell_e} \\mathbf{B}_s(\\bar{x})^T \\kappa_s G A \\mathbf{B}_s(\\bar{x}) d\\bar{x} $$\n弯曲刚度矩阵计算如下：\n$$ \\mathbf{K}_b = E I \\int_0^{\\ell_e} \\frac{1}{\\ell_e^2} \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 1 \\end{bmatrix} d\\bar{x} = \\frac{EI}{\\ell_e} \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 1 \\end{bmatrix} $$\n剪切刚度矩阵需要对 $\\mathbf{B}_s(\\bar{x})$ 的二次型进行积分：\n$$ \\mathbf{K}_s = \\kappa_s G A \\int_0^{\\ell_e} \\mathbf{B}_s(\\bar{x})^T \\mathbf{B}_s(\\bar{x}) d\\bar{x} $$\n逐项积分得到：\n$$ \\mathbf{K}_s = \\kappa_s G A \\begin{bmatrix} 1/\\ell_e & 1/2 & -1/\\ell_e & 1/2 \\\\ 1/2 & \\ell_e/3 & -1/2 & \\ell_e/6 \\\\ -1/\\ell_e & -1/2 & 1/\\ell_e & -1/2 \\\\ 1/2 & \\ell_e/6 & -1/2 & \\ell_e/3 \\end{bmatrix} $$\n总单元刚度矩阵 $\\mathbf{K}_e = \\mathbf{K}_b + \\mathbf{K}_s$ 随后被组装成整个梁的全局刚度矩阵 $\\mathbf{K}$，整个梁包含 $n_e$ 个单元和 $n_e+1$ 个节点。全局方程组为 $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$，其中 $\\mathbf{D}$ 是所有节点位移和转角的向量，$\\mathbf{F}$ 是全局力向量。\n\n对于在 $x=0$ 处固支的悬臂梁，边界条件为 $w(0)=0$ 和 $\\varphi(0)=0$。这对应于全局系统中的前两个自由度 $D_0$ 和 $D_1$。我们通过修改系统矩阵和向量来施加这些约束，通常是将相应的行和列设为零（对角线上的元素设为 1），并将相应的力分量设为零。在自由端 $x=L$ 施加横向点载荷 $P$。这对应于最后一个节点 $n_e$。力 $P$ 被加到与该节点横向位移相关的 $\\mathbf{F}$ 分量上。\n\n求解修正后的线性系统得到 $\\mathbf{D}$ 后，我们提取尖端位移的有限元近似值 $w_{\\mathrm{FE}}$，它是 $\\mathbf{D}$ 中对应于节点 $n_e$ 处横向位移的分量。\n\n将此解与精确的铁木辛柯解进行比较：\n$$ w_{\\mathrm{exact}}=\\frac{P L^3}{3 E I}+\\frac{P L}{\\kappa_s G A} $$\n比率 $r(n_e, t) = w_{\\mathrm{FE}}(n_e, t) / w_{\\mathrm{exact}}(t)$ 用于量化收敛性。参数 $t$ 是梁的厚度，它通过 $A=bt$ 和 $I=bt^3/12$ 进入计算。对于这个问题，$b=1$，因此 $A=t$ 且 $I=t^3/12$。\n\n当梁变得很薄（即高宽比 $L/t$ 很大）时，会出现剪切锁定现象。在薄梁极限下，真实的剪切应变 $\\gamma = dw/dx - \\varphi$ 应趋近于零。然而，我们对 $w$ 和 $\\varphi$ 都使用线性插值的有限元公式会强制 $\\gamma$ 成为 $\\bar{x}$ 的线性函数，而弯曲主导的状态要求 $\\varphi$ 呈线性变化，从而 $dw/dx$ 需呈二次变化。线性单元无法正确表示这一点。为了最小化大的剪切能项（与 $\\kappa_s G A \\sim t$ 成正比），单元的自由度受到伪约束，迫使 $\\gamma(\\bar{x})$ 在各处都趋于零。这迫使 $\\varphi$ 在单元内几乎保持不变，从而将其锁定并阻止其正常弯曲。这导致了人为的过刚响应，计算出的位移 $w_{\\mathrm{FE}}$ 被严重低估。\n\n数值结果将证明这一点。对于厚梁（$t=1$），收敛会很快（$r$ 迅速趋近于 1）。对于薄梁（$t=0.1$，尤其是 $t=0.01$），在粗网格（$n_e$ 较小）下，比率 $r$ 会非常小，并且只有在网格细化后才会缓慢趋近于 1。这种对薄结构的不良收敛性是剪切锁定的标志。下面的实现将精确地量化这种行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Timoshenko beam problem using FEM and analyzes shear locking.\n    \"\"\"\n    # Problem Constants\n    L = 10.0\n    E = 1.0\n    G = 1.0\n    ks = 5.0 / 6.0\n    b = 1.0\n    P = 1.0\n\n    # Test Suite Parameters\n    thicknesses = [1.0, 0.1, 0.01]\n    n_elements_list = [1, 2, 4, 8, 16, 32]\n\n    results = []\n\n    for t in thicknesses:\n        # Geometric and Material Properties for the current thickness\n        A = b * t\n        I = b * t**3 / 12.0\n        \n        # Calculate the exact Timoshenko tip deflection\n        # Bending part + Shear part\n        w_exact = (P * L**3) / (3.0 * E * I) + (P * L) / (ks * G * A)\n\n        ratios_for_t = []\n        for ne in n_elements_list:\n            le = L / ne\n            num_nodes = ne + 1\n            num_dofs = 2 * num_nodes\n\n            # Calculate element stiffness matrix Ke = Kb + Ks\n            # Bending stiffness matrix Kb\n            Kb = (E * I / le) * np.array([\n                [0, 0, 0, 0],\n                [0, 1, 0, -1],\n                [0, 0, 0, 0],\n                [0, -1, 0, 1]\n            ])\n\n            # Shear stiffness matrix Ks\n            Ks_factor = ks * G * A\n            Ks_geom = np.array([\n                [1.0/le, 0.5, -1.0/le, 0.5],\n                [0.5, le/3.0, -0.5, le/6.0],\n                [-1.0/le, -0.5, 1.0/le, -0.5],\n                [0.5, le/6.0, -0.5, le/3.0]\n            ])\n            Ks = Ks_factor * Ks_geom\n            \n            Ke = Kb + Ks\n\n            # Assemble global stiffness matrix K and force vector F\n            K_global = np.zeros((num_dofs, num_dofs))\n            F_global = np.zeros(num_dofs)\n\n            for i in range(ne):\n                # Global DOFs for element i (nodes i and i+1)\n                dof_map = [2*i, 2*i + 1, 2*(i+1), 2*(i+1) + 1]\n                for row_loc in range(4):\n                    for col_loc in range(4):\n                        row_glob = dof_map[row_loc]\n                        col_glob = dof_map[col_loc]\n                        K_global[row_glob, col_glob] += Ke[row_loc, col_loc]\n\n            # Apply point load P at the free end (node ne)\n            # The DOF is for transverse displacement 'w' at the last node.\n            F_global[2*ne] = P\n\n            # Apply boundary conditions (clamped at x=0, node 0)\n            # w(0) = 0 and phi(0) = 0\n            # This corresponds to DOFs 0 and 1.\n            K_global[0, :] = 0.0\n            K_global[:, 0] = 0.0\n            K_global[0, 0] = 1.0\n            F_global[0] = 0.0\n\n            K_global[1, :] = 0.0\n            K_global[:, 1] = 0.0\n            K_global[1, 1] = 1.0\n            F_global[1] = 0.0\n            \n            # Solve the linear system KU=F\n            D = np.linalg.solve(K_global, F_global)\n\n            # Extract tip displacement w_FE at x=L (node ne)\n            w_fe = D[2*ne]\n\n            # Calculate the ratio\n            ratio = w_fe / w_exact\n            ratios_for_t.append(ratio)\n        \n        results.append(ratios_for_t)\n\n    # Format the output string as specified\n    output_str = \"[\"\n    for i, t_results in enumerate(results):\n        output_str += f\"[{','.join(map(str, t_results))}]\"\n        if i < len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "2595579"}, {"introduction": "从剪切锁定转向体积锁定，后者主要影响模拟近不可压缩材料的单元。本练习将引导您使用严谨的“制造解法”，系统地比较一个会失效的标准单元和一个成功的混合单元。此实践不仅展示了体积锁定的现象，还提供了实现其强大解决方案——位移-压力（$u-p$）混合格式——的宝贵经验。[@problem_id:2595504]", "problem": "考虑一个在单位正方形域 $\\Omega=[0,1]\\times[0,1]$ 上的二维平面应变线性弹性边值问题，其具有一个构造的光滑位移解。设位移定义为 $u_x(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 和 $u_y(x,y)=\\cos(\\pi x)\\sin(\\pi y)$。设材料为近不可压缩材料，其杨氏模量 $E=1$，泊松比 $\\nu=0.4999$。Lamé 参数记为 $\\lambda=\\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu=\\dfrac{E}{2(1+\\nu)}$。精确压力由 $p_{\\text{exact}}(x,y)=-\\lambda\\,\\nabla\\cdot u(x,y)$ 定义。设体力为 $f(x,y)=-\\nabla\\cdot\\sigma(x,y)$，其中 Cauchy 应力为 $\\sigma=2\\mu\\,\\varepsilon(u)+\\lambda\\,\\text{tr}(\\varepsilon(u))I=2\\mu\\,\\varepsilon(u)-p_{\\text{exact}} I$，$\\varepsilon(u)$ 是小应变张量。通过在整个边界 $\\partial\\Omega$ 上指定精确位移来施加 Dirichlet 边界条件。\n\n你的任务是通过比较位移和压力的 $L^2$ 误差来量化体积锁定，比较对象为：\n- 一种使用完全线性弹性刚度（易受体积锁定影响）的标准基于位移的双线性四边形单元 (Q4) 离散格式，\n- 一种基于 Herrmann 格式的位移-压力混合格式，其中位移采用 Q4 单元，压力在每个单元上为分片常数 (Q4/P0)。该格式中，偏量部分由 $2\\mu\\,\\varepsilon(u):\\varepsilon(v)$ 处理，压力 $p$ 是一个独立的未知量，在弱形式意义下强制满足 $p+\\lambda\\,\\nabla\\cdot u=0$。\n\n从以下基本原理出发：\n- 平面应变问题的线性弹性弱形式、Lamé 参数的定义、小应变张量的定义以及线性弹性中的 Cauchy 应力概念。\n- 用于近不可压缩弹性问题的 Herrmann 混合格式，其中压力 $p$ 为独立未知量。\n- 等参双线性四边形单元的数值积分（使用张量积 Gauss 法则）。\n- 域 $\\Omega$ 上的 $L^2$ 范数定义。\n\n按以下步骤进行，且只使用这些基础知识，不使用超出这些原理的任何快捷公式：\n- 从构造的位移 $u$ 和精确压力 $p_{\\text{exact}}$ 推导出体力 $f$。\n- 对于纯位移 Q4 方法，从双线性形式 $\\int_{\\Omega} \\varepsilon(v)^T D\\,\\varepsilon(u)\\,\\mathrm{d}\\Omega$（其中 $D$ 为平面应变本构张量）和线性泛函 $\\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$ 组装全局系统。使用精确边界位移强施加 Dirichlet 条件。\n- 对于混合 Q4/P0 方法 (Herrmann)，从如下双线性形式\n  - $a(u,v)=\\int_{\\Omega} 2\\mu\\,\\varepsilon(u):\\varepsilon(v)\\,\\mathrm{d}\\Omega$,\n  - $b(v,p)=-\\int_{\\Omega} p\\,\\nabla\\cdot v\\,\\mathrm{d}\\Omega$ and $b(u,q)=-\\int_{\\Omega} q\\,\\nabla\\cdot u\\,\\mathrm{d}\\Omega$,\n  - $c(p,q)=-\\int_{\\Omega}\\dfrac{1}{\\lambda}\\,pq\\,\\mathrm{d}\\Omega$,\n  和线性泛函 $\\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$ 组装关于 $(u,p)$ 的分块系统。每个单元使用一个压力自由度（单元上为常数）。如上所述，对 $u$ 强施加 Dirichlet 条件。\n- 对于纯位移 Q4 方法，将计算出的压力场定义为 $p_h=-\\lambda\\,\\nabla\\cdot u_h$，并在积分点上进行计算。\n- 使用适当的 Gaussian 积分计算位移的 $L^2$ 误差 $e_u=\\left(\\int_{\\Omega}\\|u_h-u_{\\text{exact}}\\|^2\\,\\mathrm{d}\\Omega\\right)^{1/2}$ 和压力的 $L^2$ 误差 $e_p=\\left(\\int_{\\Omega}\\left(p_h-p_{\\text{exact}}\\right)^2\\,\\mathrm{d}\\Omega\\right)^{1/2}$。对于混合 Q4/P0 方法，$p_h$ 是分片常数，因此在每个单元内通过积分来计算其误差。\n\n在 $\\Omega$ 上使用 $N\\times N$ 的结构化双线性四边形单元网格，节点均匀分布。实现等参映射，并对所有单元积分使用 $2\\times 2$ Gaussian 积分法则。通过构造解精确施加所有边界条件。\n\n测试套件：\n- 使用三种网格，$N\\in\\{2,4,8\\}$。\n- 对每个 $N$，计算四个浮点数：Q4 方法的位移 $L^2$ 误差，Q4 方法的压力 $L^2$ 误差（其中 $p_h=-\\lambda\\,\\nabla\\cdot u_h$），混合 Q4/P0 方法的位移 $L^2$ 误差，以及混合 Q4/P0 方法的压力 $L^2$ 误差。\n\n最终输出规格：\n- 你的程序应生成单行输出，包含一个逗号分隔的列表的列表。其中每个内部列表对应一个网格（按 $N=2, N=4, N=8$ 的顺序），并按上述顺序包含四个浮点数。所有浮点数均使用科学记数法表示，保留小数点后六位。例如，格式必须与以下完全一样：\n  $[ [a_{11},a_{12},a_{13},a_{14}], [a_{21},a_{22},a_{23},a_{24}], [a_{31},a_{32},a_{33},a_{34}] ]$\n此问题中没有物理单位。", "solution": "所述问题是计算力学中一个适定的练习题，具体涉及近不可压缩线性弹性的有限元分析。该问题具有科学依据、内容自洽且无矛盾。其目的是展示低阶位移单元中的体积锁定现象以及如何使用混合格式来解决该问题。所有必要的组成部分——域、边界条件、控制方程、材料属性和分析方法——均已提供。因此，该问题是有效的。我们开始求解。\n\n该分析基于平面应变线性弹性原理。控制平衡方程为 $\\nabla \\cdot \\sigma + f = 0$，其中 $\\sigma$ 是 Cauchy 应力张量，$f$ 是单位体积的体力。\n\n首先，我们建立构造解及其导数的表达式，这对于定义问题和评估数值解的精度至关重要。\n\n位移场给定为：\n$$ u_x(x,y) = \\sin(\\pi x)\\sin(\\pi y) $$\n$$ u_y(x,y) = \\cos(\\pi x)\\sin(\\pi y) $$\n小应变张量 $\\varepsilon(u) = \\frac{1}{2}(\\nabla u + (\\nabla u)^T)$ 的分量为：\n$$ \\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = \\pi \\cos(\\pi x)\\sin(\\pi y) $$\n$$ \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = \\pi \\cos(\\pi x)\\cos(\\pi y) $$\n$$ \\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}\\right) = \\frac{1}{2}\\left(\\pi \\sin(\\pi x)\\cos(\\pi y) - \\pi \\sin(\\pi x)\\sin(\\pi y)\\right) = \\frac{\\pi}{2} \\sin(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) $$\n对于平面应变，$\\varepsilon_{zz} = 0$。\n\n位移场的散度是应变张量的迹：\n$$ \\nabla \\cdot u = \\varepsilon_{xx} + \\varepsilon_{yy} = \\pi \\cos(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) $$\n精确压力定义为 $p_{\\text{exact}} = -\\lambda \\, \\text{tr}(\\varepsilon(u)) = -\\lambda (\\nabla \\cdot u)$：\n$$ p_{\\text{exact}}(x,y) = -\\lambda \\pi \\cos(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) $$\n\n推导体力 $f$ 是为了确保构造的位移场是该边值问题的精确解。根据弹性力学的 Navier-Cauchy 方程，$f$ 由下式给出：\n$$ f = - \\nabla \\cdot \\sigma = - \\nabla \\cdot (2\\mu\\varepsilon + \\lambda(\\nabla \\cdot u)I) = -\\mu \\nabla^2 u - (\\mu+\\lambda)\\nabla(\\nabla \\cdot u) $$\n我们计算必要的项：\n$$ \\nabla^2 u_x = \\frac{\\partial^2 u_x}{\\partial x^2} + \\frac{\\partial^2 u_x}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_x $$\n$$ \\nabla^2 u_y = \\frac{\\partial^2 u_y}{\\partial x^2} + \\frac{\\partial^2 u_y}{\\partial y^2} = -2\\pi^2 \\cos(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_y $$\n$$ \\nabla(\\nabla \\cdot u) = \\begin{pmatrix} \\frac{\\partial}{\\partial x}(\\nabla \\cdot u) \\\\ \\frac{\\partial}{\\partial y}(\\nabla \\cdot u) \\end{pmatrix} = \\begin{pmatrix} -\\pi^2 \\sin(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) \\\\ \\pi^2 \\cos(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) \\end{pmatrix} $$\n将这些代入 $f$ 的表达式，得到体力的分量：\n$$ f_x(x,y) = 2\\mu\\pi^2 u_x + (\\mu+\\lambda)\\pi^2 \\sin(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) = \\pi^2 \\sin(\\pi x) \\left( (3\\mu+\\lambda)\\sin(\\pi y) + (\\mu+\\lambda)\\cos(\\pi y) \\right) $$\n$$ f_y(x,y) = 2\\mu\\pi^2 u_y - (\\mu+\\lambda)\\pi^2 \\cos(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) = \\pi^2 \\cos(\\pi x) \\left( (3\\mu+\\lambda)\\sin(\\pi y) - (\\mu+\\lambda)\\cos(\\pi y) \\right) $$\n\n该问题使用 $N \\times N$ 的结构化双线性四边形单元 (Q4) 网格进行离散。对于定义在参考域 $[-1,1]\\times[-1,1]$ 上的单元，等参映射和位移插值由下式给出：\n$$ x(\\xi, \\eta) = \\sum_{a=1}^4 N_a(\\xi, \\eta) x_a, \\quad u_h(\\xi, \\eta) = \\sum_{a=1}^4 N_a(\\xi, \\eta) d_a $$\n其中 $N_a(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_a\\xi)(1+\\eta_a\\eta)$ 是形函数，$x_a$ 是节点坐标，$d_a$ 是节点位移向量。应变-位移矩阵 $B$ 将应变向量 $\\varepsilon_V = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^T$ 与节点位移向量 $d$ 关联起来：$\\varepsilon_V = B d$。\n\n**方法1：标准的基于位移的 Q4 格式**\n\n其弱形式为 $\\int_{\\Omega} \\varepsilon(v)^T D\\,\\varepsilon(u)\\,\\mathrm{d}\\Omega = \\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$。这导出一个线性系统 $K d = F$。单元刚度矩阵 $K^e$ 和单元力向量 $F^e$ 分别为：\n$$ K^e = \\int_{\\Omega_e} B^T D B \\, \\mathrm{d}\\Omega, \\quad F^e = \\int_{\\Omega_e} N^T f \\, \\mathrm{d}\\Omega $$\n平面应变本构矩阵 $D$ 为：\n$$ D = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & (1-2\\nu)/2 \\end{pmatrix} = \\begin{pmatrix} \\lambda+2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda+2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{pmatrix} $$\n积分使用 $2 \\times 2$ Gauss 积分法则计算。组装完全局系统后，通过对系统进行分块并求解未知的内部自由度来强施加 Dirichlet 边界条件。数值压力场由计算出的位移场 $u_h$ 后处理得到，即 $p_h = -\\lambda (\\nabla \\cdot u_h)$。该计算在积分点上进行。\n\n**方法2：位移-压力混合 Q4/P0 格式 (Herrmann)**\n\n此格式将压力 $p$ 视为一个独立变量（在每个单元上为常数），以克服锁定。其弱形式是一个鞍点系统：\n$$ \\int_{\\Omega} 2\\mu\\,\\varepsilon(u):\\varepsilon(v)\\,\\mathrm{d}\\Omega - \\int_{\\Omega} p\\,\\nabla\\cdot v\\,\\mathrm{d}\\Omega = \\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega $$\n$$ -\\int_{\\Omega} q\\,\\nabla\\cdot u\\,\\mathrm{d}\\Omega - \\int_{\\Omega}\\dfrac{1}{\\lambda}\\,pq\\,\\mathrm{d}\\Omega = 0 $$\n这导出一个分块矩阵系统：\n$$ \\begin{pmatrix} A & B^T \\\\ B & C \\end{pmatrix} \\begin{pmatrix} d \\\\ p \\end{pmatrix} = \\begin{pmatrix} F \\\\ 0 \\end{pmatrix} $$\n单元级别的矩阵为：\n - $A^e = \\int_{\\Omega_e} B^T D_{dev} B \\, \\mathrm{d}\\Omega$，其中 $D_{dev} = \\text{diag}(2\\mu, 2\\mu, \\mu)$。这代表了刚度的偏量部分。\n - $B^e$ 是一个 $1 \\times 8$ 矩阵，它将单元的单个压力自由度与其 8 个位移自由度耦合起来：$B^e = -\\int_{\\Omega_e} [1, 1, 0]B \\, \\mathrm{d}\\Omega$。\n - $C^e$ 是压力项的 $1 \\times 1$ 矩阵：$C^e = -\\int_{\\Omega_e} \\frac{1}{\\lambda} \\, \\mathrm{d}\\Omega = -\\frac{\\text{Area}(e)}{\\lambda}$。\n - $F^e$ 与 Q4 方法中的体力向量相同。\n全局系统由这些单元矩阵组装而成。矩阵 $C$ 是对角阵。边界条件以与 Q4 方法相同的方式施加于位移自由度。该系统的解同时产生位移场 $u_h$ 和分片常数压力场 $p_h$。\n\n**误差计算**\n\n对于这两种方法，都计算位移和压力的 $L^2$ 误差以量化其精度。误差定义为：\n$$ e_u = \\left(\\int_{\\Omega}\\|u_h-u_{\\text{exact}}\\|^2\\,\\mathrm{d}\\Omega\\right)^{1/2} $$\n$$ e_p = \\left(\\int_{\\Omega}\\left(p_h-p_{\\text{exact}}\\right)^2\\,\\mathrm{d}\\Omega\\right)^{1/2} $$\n这些积分通过在每个单元上使用相同的 $2 \\times 2$ Gauss 积分法则进行数值计算，并将各单元的贡献求和以获得总误差。对于 Q4/P0 方法，$p_h$ 是为每个单元计算出的分片常数值；而对于 Q4 方法，$p_h$ 是根据每个积分点上的位移导数计算得出的。\n\n下面的 Python 实现针对指定的网格尺寸执行了这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear elasticity problem with a manufactured solution\n    to demonstrate volumetric locking and its mitigation with a mixed method.\n    \"\"\"\n\n    # Material properties and constants\n    E = 1.0\n    nu = 0.4999\n    \n    # Lamé parameters\n    lmbda = (E * nu) / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    mu = E / (2.0 * (1.0 + nu))\n    \n    # Constitutive matrix for plane strain (Q4 method)\n    D = np.array([\n        [lmbda + 2 * mu, lmbda, 0],\n        [lmbda, lmbda + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    \n    # Deviatoric part for Q4/P0 method\n    D_dev = np.diag([2 * mu, 2 * mu, mu])\n    \n    # Manufactured solution and its derivatives\n    pi = np.pi\n    u_exact_fn = lambda x, y: (np.sin(pi * x) * np.sin(pi * y), np.cos(pi * x) * np.sin(pi * y))\n    p_exact_fn = lambda x, y: -lmbda * pi * np.cos(pi * x) * (np.sin(pi * y) + np.cos(pi * y))\n\n    # Body force from manufactured solution\n    # f_x = pi**2 * sin(pi*x) * ((3*mu+lmbda)*sin(pi*y) + (mu+lmbda)*cos(pi*y))\n    # f_y = pi**2 * cos(pi*x) * ((3*mu+lmbda)*sin(pi*y) - (mu+lmbda)*cos(pi*y))\n    c1 = 3 * mu + lmbda\n    c2 = mu + lmbda\n    f_fn = lambda x, y: (\n        pi**2 * np.sin(pi * x) * (c1 * np.sin(pi * y) + c2 * np.cos(pi * y)),\n        pi**2 * np.cos(pi * x) * (c1 * np.sin(pi * y) - c2 * np.cos(pi * y))\n    )\n\n    # Gaussian quadrature points and weights for 2x2 rule\n    gauss_pts = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_w = [1.0, 1.0]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        # Shape functions N(xi, eta)\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        \n        # Derivatives of N w.r.t. xi, eta\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dN_dxi, dN_deta\n\n    def solve_fem(N, method):\n        # Mesh parameters\n        h = 1.0 / N\n        num_nodes = (N + 1)**2\n        num_elems = N**2\n        num_disp_dofs = 2 * num_nodes\n        \n        nodes = np.array([[i * h, j * h] for j in range(N + 1) for i in range(N + 1)])\n        elements = np.array([\n            [j * (N + 1) + i, j * (N + 1) + i + 1, (j + 1) * (N + 1) + i + 1, (j + 1) * (N + 1) + i]\n            for j in range(N) for i in range(N)\n        ])\n        elem_map = {(j, i): j * N + i for j in range(N) for i in range(N)}\n        \n        if method == 'Q4':\n            K = np.zeros((num_disp_dofs, num_disp_dofs))\n            F = np.zeros(num_disp_dofs)\n        elif method == 'Q4/P0':\n            num_pressure_dofs = num_elems\n            dof_total = num_disp_dofs + num_pressure_dofs\n            K_saddle = np.zeros((dof_total, dof_total))\n            F_saddle = np.zeros(dof_total)\n            A_mat = K_saddle[:num_disp_dofs, :num_disp_dofs]\n            B_mat = K_saddle[num_disp_dofs:, :num_disp_dofs] # B\n            C_mat = K_saddle[num_disp_dofs:, num_disp_dofs:]\n            F_disp = F_saddle[:num_disp_dofs]\n            \n            # Pressure matrix is diagonal\n            np.fill_diagonal(C_mat, -h**2 / lmbda)\n\n        # Assemble matrices\n        for j in range(N):\n            for i in range(N):\n                elem_idx = elem_map[(j, i)]\n                elem_nodes = elements[elem_idx]\n                elem_coords = nodes[elem_nodes]\n\n                # Element matrices\n                Ke = np.zeros((8, 8))\n                Fe = np.zeros(8)\n                if method == 'Q4/P0':\n                    Be_row = np.zeros(8)\n                \n                detJ = (h / 2.0)**2\n                \n                for gp_eta in gauss_pts:\n                    for gp_xi in gauss_pts:\n                        N_vals, dN_dxi, dN_deta = get_shape_functions_and_derivs(gp_xi, gp_eta)\n                        \n                        # Jacobian is constant for structured grid\n                        dN_dx = dN_dxi * (2.0 / h)\n                        dN_dy = dN_deta * (2.0 / h)\n                        \n                        B = np.zeros((3, 8))\n                        for k in range(4):\n                            B[0, 2*k] = dN_dx[k]\n                            B[1, 2*k+1] = dN_dy[k]\n                            B[2, 2*k] = dN_dy[k]\n                            B[2, 2*k+1] = dN_dx[k]\n\n                        D_eff = D if method == 'Q4' else D_dev\n                        Ke += B.T @ D_eff @ B * detJ\n                        \n                        x_gp, y_gp = elem_coords.T @ N_vals\n                        f_vec = f_fn(x_gp, y_gp)\n                        \n                        N_matrix = np.zeros((2, 8))\n                        N_matrix[0, 0::2] = N_vals\n                        N_matrix[1, 1::2] = N_vals\n                        \n                        Fe += N_matrix.T @ np.array(f_vec) * detJ\n                        \n                        if method == 'Q4/P0':\n                            G_transpose = np.array([1, 1, 0]) @ B\n                            Be_row -= G_transpose * detJ\n\n                # Assemble into global system\n                dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n                if method == 'Q4':\n                    K[np.ix_(dofs, dofs)] += Ke\n                    F[dofs] += Fe\n                elif method == 'Q4/P0':\n                    A_mat[np.ix_(dofs, dofs)] += Ke\n                    F_disp[dofs] += Fe\n                    B_mat[elem_idx, dofs] += Be_row\n\n        if method == 'Q4/P0':\n            # Transpose B to get B.T\n            K_saddle[:num_disp_dofs, num_disp_dofs:] = B_mat.T\n        \n        # Apply boundary conditions\n        boundary_nodes = set()\n        for i in range(N + 1):\n            boundary_nodes.add(i)  # bottom\n            boundary_nodes.add(N * (N + 1) + i) # top\n            boundary_nodes.add(i * (N + 1)) # left\n            boundary_nodes.add(i * (N + 1) + N) # right\n        \n        boundary_dofs = []\n        for n in sorted(list(boundary_nodes)):\n            boundary_dofs.extend([2 * n, 2 * n + 1])\n        \n        all_dofs = np.arange(num_disp_dofs)\n        internal_dofs = np.setdiff1d(all_dofs, boundary_dofs)\n        \n        u_h_full = np.zeros(num_disp_dofs)\n        boundary_coords = nodes[sorted(list(boundary_nodes))]\n        u_exact_b = np.array([u_exact_fn(c[0], c[1]) for c in boundary_coords]).ravel()\n        u_h_full[boundary_dofs] = u_exact_b\n        \n        if method == 'Q4':\n            K_II = K[np.ix_(internal_dofs, internal_dofs)]\n            K_IB = K[np.ix_(internal_dofs, boundary_dofs)]\n            F_I = F[internal_dofs]\n            F_eff = F_I - K_IB @ u_exact_b\n            u_I = np.linalg.solve(K_II, F_eff)\n            u_h_full[internal_dofs] = u_I\n            u_h = u_h_full\n            p_h = None\n        \n        elif method == 'Q4/P0':\n            dof_total = num_disp_dofs + num_pressure_dofs\n            all_saddle_dofs = np.arange(dof_total)\n            pressure_dofs_global = np.arange(num_disp_dofs, dof_total)\n            internal_saddle_dofs = np.concatenate([internal_dofs, pressure_dofs_global])\n            \n            K_saddle_II = K_saddle[np.ix_(internal_saddle_dofs, internal_saddle_dofs)]\n            K_saddle_IB = K_saddle[np.ix_(internal_saddle_dofs, boundary_dofs)]\n            F_saddle_I = F_saddle[internal_saddle_dofs]\n            F_saddle_eff = F_saddle_I - K_saddle_IB @ u_exact_b\n            \n            sol_I = np.linalg.solve(K_saddle_II, F_saddle_eff)\n            u_h_full[internal_dofs] = sol_I[:len(internal_dofs)]\n            u_h = u_h_full\n            p_h = sol_I[len(internal_dofs):]\n\n        # Error computation\n        u_err_sq, p_err_sq = 0.0, 0.0\n        for j in range(N):\n            for i in range(N):\n                elem_idx = elem_map[(j, i)]\n                elem_nodes = elements[elem_idx]\n                elem_coords = nodes[elem_nodes]\n                \n                detJ = (h / 2.0)**2\n                \n                for gp_eta in gauss_pts:\n                    for gp_xi in gauss_pts:\n                        N_vals, dN_dxi, dN_deta = get_shape_functions_and_derivs(gp_xi, gp_eta)\n                        x_gp, y_gp = elem_coords.T @ N_vals\n                        \n                        u_exact_gp = np.array(u_exact_fn(x_gp, y_gp))\n                        p_exact_gp = p_exact_fn(x_gp, y_gp)\n                        \n                        dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n                        u_nodal = u_h[dofs]\n                        \n                        N_matrix = np.zeros((2, 8))\n                        N_matrix[0, 0::2] = N_vals\n                        N_matrix[1, 1::2] = N_vals\n                        \n                        u_h_gp = N_matrix @ u_nodal\n                        u_err_sq += np.sum((u_h_gp - u_exact_gp)**2) * detJ\n\n                        if method == 'Q4':\n                            dN_dx = dN_dxi * (2.0 / h)\n                            dN_dy = dN_deta * (2.0 / h)\n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = dN_dx[k]\n                                B[1, 2*k+1] = dN_dy[k]\n                            div_u_h = (B[0, :] + B[1, :]) @ u_nodal\n                            p_h_gp = -lmbda * div_u_h\n                        elif method == 'Q4/P0':\n                            p_h_gp = p_h[elem_idx]\n\n                        p_err_sq += (p_h_gp - p_exact_gp)**2 * detJ\n                        \n        return np.sqrt(u_err_sq), np.sqrt(p_err_sq)\n\n\n    test_cases = [2, 4, 8]\n    results = []\n    \n    for n in test_cases:\n        case_results = []\n        \n        # Q4 analysis\n        err_u_q4, err_p_q4 = solve_fem(n, 'Q4')\n        case_results.extend([err_u_q4, err_p_q4])\n        \n        # Q4/P0 analysis\n        err_u_q4q0, err_p_q4q0 = solve_fem(n, 'Q4/P0')\n        case_results.extend([err_u_q4q0, err_p_q4q0])\n        \n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Note: The problem description has a typo Q4/Q0, which should be Q4/P0. My code uses Q4/P0 internally.\n    formatted_results = [\n        \"[\" + \", \".join(f\"{val:.6e}\" for val in case) + \"]\"\n        for case in results\n    ]\n    print(f\"[{', '.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2595504"}, {"introduction": "在通过数值实验观察到锁定现象后，让我们转向理论验证。“检验”（Patch Test）是评估有限元一致性的基本工具。本练习要求您为通过体积锁定检验定义精确的条件，特别是在扭曲网格这一具有挑战性的情况下。理解这些条件对于开发稳健的有限元以及正确解读其在非规则网格上的计算结果至关重要。[@problem_id:2595541]", "problem": "考虑一个由等参双线性四边形单元（四节点四边形）组成的应变片，这些单元组装成一个覆盖平面上凸域的扭曲网格。每个单元内的几何映射是双线性的，不一定是仿射的，但雅可比行列式处处严格为正，因此映射是可逆的。材料是小应变下的线性弹性体，其柯西应力分解为\n$$\n\\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}_{\\mathrm{dev}} + K\\,\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I},\n$$\n其中 $\\mu>0$ 是剪切模量，$K>0$ 是体积模量，$\\mathbf{I}$ 是二阶单位张量，$\\boldsymbol{\\varepsilon}=\\tfrac{1}{2}(\\nabla\\mathbf{u} + \\nabla\\mathbf{u}^{\\mathsf{T}})$ 是小应变张量，其体积应变为 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$。不存在体力。您希望设计一个体积应变片检验，通过指定一个在连续介质中处处产生精确为零的体积应变的线性位移场，来隔离扭曲四边形网格上潜在的体积锁定问题。\n\n您选择一个线性场\n$$\n\\mathbf{u}(\\mathbf{x}) = \\mathbf{a} + \\mathbf{A}\\,\\mathbf{x}, \\qquad \\mathbf{a}\\in\\mathbb{R}^{2},\\ \\mathbf{A}\\in\\mathbb{R}^{2\\times 2},\n$$\n使得\n$$\n\\operatorname{tr}(\\mathbf{A}) = 0,\n$$\n因此在精确（连续介质）解中，$\\operatorname{tr}(\\boldsymbol{\\varepsilon})=\\operatorname{tr}\\big(\\tfrac{1}{2}(\\mathbf{A}+\\mathbf{A}^{\\mathsf{T}})\\big)=\\operatorname{tr}(\\mathbf{A})=0$。在有限元应变片上，您通过将边界节点的位移指定为这些边界节点上 $\\mathbf{u}(\\mathbf{x})$ 的精确值来施加狄利克雷边界条件。不施加任何面力。有限元格式是标准的基于位移的等参插值格式；或者，在位移-压力混合格式中，压力 $p$ 作为拉格朗日乘子引入，以强制实现不可压缩性，其中 $p=-K\\,\\operatorname{tr}(\\boldsymbol{\\varepsilon})$。\n\n下列哪个陈述精确而完整地指明了在扭曲四边形网格上进行此体积应变片检验的必要和充分通过条件？\n\nA. 对于任何可逆的双线性几何映射（雅可比行列式严格为正）和单元矩阵及向量的精确数值积分，在应变片边界节点上指定 $\\mathbf{u}(\\mathbf{x})=\\mathbf{a}+\\mathbf{A}\\mathbf{x}$ 且 $\\operatorname{tr}(\\mathbf{A})=0$，必须在机器精度内产生以下结果：(i) 在每个单元内逐点再现 $\\mathbf{u}(\\mathbf{x})$（因此在所有积分点上产生恒定的偏应变和 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\equiv 0$），(ii) 在所有内部节点处单元级内力残差为零，且边界反力等于从连续介质偏应力场获得的反力，以及 (iii) 在位移-压力混合格式中，离散压力场是常数，并且可以在整个应变片上取为恒等于零（不考虑任意的加性常数），且没有伪压力模式。只要雅可比行列式保持为正，这些条件必须独立于单元扭曲程度而成立。\n\nB. 由于几何扭曲，等参双线性单元无法在物理坐标中精确再现线性场；因此，应变片检验应仅要求每个单元中的单元平均体积应变 $\\int_{\\Omega_{e}}\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathrm{d}\\Omega$ 为零，而只要满足反力的全局平衡，非零的逐点 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ 和非零的单元平均压力是可以接受的。\n\nC. 为避免刚体模态，除了指定的边界位移外，还必须施加一个均匀体力。如果应变片平均压力为零且净反力为零，则单元通过体积应变片检验；在扭曲网格上，具有局部变化的分片常数压力场和非恒定的偏应力是可以接受的。\n\nD. 在扭曲的等参四边形网格上，通过体积应变为零的线性场来进行体积应变片检验通常是不可能的；正确的要求仅是有限元解在网格细化的极限下收敛到零体积应变，即使应变片检验在固定的扭曲应变片上失败。\n\nE. 对于基于位移的四边形单元，只有当体积项和偏量项都使用单点（选择性）减缩积分时，才能在扭曲网格上通过体积应变片检验；使用精确或高阶求积通常会导致剪切或体积锁定并导致检验失败。\n\n选择所有正确且完整的陈述。", "solution": "该问题陈述在科学上是合理的且定义明确。它提出了有限元方法（FEM）理论中一个标准但高级的主题：为诊断等参单元中的体积锁定而制定的应变片检验。所有术语、方程和概念在计算力学领域内都是标准的并被严格定义。因此，我将继续进行解答。\n\n问题的核心是定义有限元格式通过“体积应变片检验”的必要和充分条件。由 B. M. Irons 引入的应变片检验是有限元协调性的基本检验。如果一个格式能够在其解属于特定函数类别（例如，特定次数的多项式）时精确再现该精确解，则该格式是协调的。通过应变片检验是确保在网格细化时达到最优阶收敛的必要条件。\n\n问题指定了一个线性位移场 $\\mathbf{u}(\\mathbf{x}) = \\mathbf{a} + \\mathbf{A}\\,\\mathbf{x}$ 作为精确解。相应的应变张量在整个连续介质中是恒定的：\n$$ \\boldsymbol{\\varepsilon} = \\frac{1}{2}\\left(\\nabla\\mathbf{u} + (\\nabla\\mathbf{u})^{\\mathsf{T}}\\right) = \\frac{1}{2}\\left(\\mathbf{A} + \\mathbf{A}^{\\mathsf{T}}\\right) = \\text{constant} $$\n问题进一步指明这是一个针对体积行为的检验，通过施加 $\\operatorname{tr}(\\mathbf{A}) = 0$，这意味着精确的体积应变处处为零：\n$$ \\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\operatorname{tr}\\left(\\frac{1}{2}\\left(\\mathbf{A} + \\mathbf{A}^{\\mathsf{T}}\\right)\\right) = \\operatorname{tr}(\\mathbf{A}) = 0 $$\n因此，精确的柯西应力张量是纯偏量的：\n$$ \\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}_{\\mathrm{dev}} + K\\,\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I} = 2\\mu\\,\\boldsymbol{\\varepsilon} $$\n由于 $\\boldsymbol{\\varepsilon}$ 是常数，应力 $\\boldsymbol{\\sigma}$ 也是常数。一个恒定的应力场在没有体力的情况下自动满足平衡方程 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$。\n\n有限元应变片检验的工作原理如下：使用精确场来指定边界节点位移，即 $\\mathbf{u}_i = \\mathbf{u}(\\mathbf{x}_i)$。然后，有限元方法求解内部状态。要使该格式“通过”应变片检验，它必须在应变片内部再现精确解的状态。这意味着：\n1.  离散位移场 $\\mathbf{u}^h(\\mathbf{x})$ 必须在每个单元内的所有点上与精确场 $\\mathbf{u}(\\mathbf{x})$ 相同。\n2.  作为(1)的直接结果，计算出的应变场 $\\boldsymbol{\\varepsilon}^h$ 必须在所有点上与精确的常数应变 $\\boldsymbol{\\varepsilon}$ 相同，对本问题而言，这意味着 $\\boldsymbol{\\varepsilon}^h$ 必须是常数并满足 $\\operatorname{tr}(\\boldsymbol{\\varepsilon}^h) = 0$。这必须在用于数值积分的所有积分点上成立。\n3.  计算出的应力场 $\\boldsymbol{\\sigma}^h$ 必须与精确的常数应力 $\\boldsymbol{\\sigma}$ 相同。\n4.  离散平衡方程必须在没有任何虚拟体力的情况下精确满足。这表现为应变片内任何内部节点上的内力向量之和为零。\n5.  边界节点上的反力必须与从精确连续介质应力场导出的面力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n}$ 一致。\n\n问题的一个关键方面是使用了“扭曲的”等参双线性四边形网格。对于一个四节点四边形，从父单元方块 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的等参映射是双线性的。如果单元不是平行四边形（即，它是扭曲的），则此映射不是仿射的。有限元理论中的一个已知结果是，物理坐标中的一般线性函数 $\\mathbf{u}(\\mathbf{x})$ 无法在扭曲的物理单元上通过双线性形函数精确表示。因此，许多标准单元格式（例如，全积分四节点四边形）将无法通过此应变片检验。然而，问题问的是通过条件的*定义*，而不是某个特定单元是否通过。通过条件代表了协调格式所要求的基准。\n\n在确立了这些原则之后，我们来评估每个选项。\n\n**A. 对于任何可逆的双线性几何映射（雅可比行列式严格为正）和单元矩阵及向量的精确数值积分，在应变片边界节点上指定 $\\mathbf{u}(\\mathbf{x})=\\mathbf{a}+\\mathbf{A}\\mathbf{x}$ 且 $\\operatorname{tr}(\\mathbf{A})=0$，必须在机器精度内产生以下结果：(i) 在每个单元内逐点再现 $\\mathbf{u}(\\mathbf{x})$（因此在所有积分点上产生恒定的偏应变和 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\equiv 0$），(ii) 在所有内部节点处单元级内力残差为零，且边界反力等于从连续介质偏应力场获得的反力，以及 (iii) 在位移-压力混合格式中，离散压力场是常数，并且可以在整个应变片上取为恒等于零（不考虑任意的加性常数），且没有伪压力模式。只要雅可比行列式保持为正，这些条件必须独立于单元扭曲程度而成立。**\n\n该陈述严格而完整地列举了应变片检验的通过条件，如上文原则所述。\n-   条件(i) 正确地陈述了逐点再现位移场的要求，这导致精确再现常数应变状态（处处 $\\operatorname{tr}(\\boldsymbol{\\varepsilon}^h) = 0$）。\n-   条件(ii) 正确地陈述了在内部节点满足离散平衡并产生正确边界反力的要求。\n-   条件(iii) 正确地指明了混合格式的要求，即压力场必须没有伪振荡（这是锁定的一个症状）并与精确压力（为零或常数）一致。\n-   最后的条款，“独立于单元扭曲程度”，是单元鲁棒性的关键要求，而这正是应变片检验的目的所在。\n此选项正确而精确地定义了通过检验的含义。\n结论：**正确**。\n\n**B. 由于几何扭曲，等参双线性单元无法在物理坐标中精确再现线性场；因此，应变片检验应仅要求每个单元中的单元平均体积应变 $\\int_{\\Omega_{e}}\\operatorname{tr}(\\boldsymbol{\\varepsilon})\\,\\mathrm{d}\\Omega$ 为零，而只要满足反力的全局平衡，非零的逐点 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ 和非零的单元平均压力是可以接受的。**\n\n该陈述正确地观察到标准双线性单元在扭曲网格上无法再现线性场。然而，其结论根本上是错误的。它建议削弱应变片检验的标准，以迁就特定单元类型的失效。正式的应变片检验要求解在逐点意义上得到满足，而不仅仅是在平均意义上。允许非零的逐点体积应变（$\\operatorname{tr}(\\boldsymbol{\\varepsilon}^h) \\neq 0$）意味着单元正在“锁定”——它产生了伪体积应力和能量——而这正是该检验旨在检测和使其失效的原因。接受这一点将使该检验作为锁定诊断工具变得毫无意义。\n结论：**不正确**。\n\n**C. 为避免刚体模态，除了指定的边界位移外，还必须施加一个均匀体力。如果应变片平均压力为零且净反力为零，则单元通过体积应变片检验；在扭曲网格上，具有局部变化的分片常数压力场和非恒定的偏应力是可以接受的。**\n\n该陈述包含多个错误。首先，如问题中所述，在应变片边界上施加狄利克雷边界条件足以约束刚体模态，前提是场 $\\mathbf{A}\\mathbf{x}$ 不是纯旋转。增加体力改变了问题；精确解将不再具有恒定的应力，这与检验的前提相矛盾。其次，所提出的通过标准（应变片平均压力为零，净反力为零）过于薄弱。即使平均值为零，局部压力变化（“棋盘格模式”）也可能存在，这表明存在锁定。非恒定的偏应力直接意味着未能再现精确解。应变片检验是一个非常严格的检验，不是对全局平均值的检查。\n结论：**不正确**。\n\n**D. 在扭曲的等参四边形网格上，通过体积应变为零的线性场来进行体积应变片检验通常是不可能的；正确的要求仅是有限元解在网格细化的极限下收敛到零体积应变，即使应变片检验在固定的扭曲应变片上失败。**\n\n该选项混淆了协调性（由应变片检验验证）和收敛性。应变片检验是在有限尺寸的应变片上执行的特定程序，以检查协调性。通过应变片检验的单元格式保证以最优理论速率收敛。未通过的单元可能仍然会收敛，但通常以次优速率收敛，或者在某些条件下（如锁定）可能根本不收敛到正确的解。问题问的是*应变片检验本身*的通过条件。将要求重新定义为仅仅是“在极限下收敛”等于放弃了应变片检验作为单元验证的有用工具。\n结论：**不正确**。\n\n**E. 对于基于位移的四边形单元，只有当体积项和偏量项都使用单点（选择性）减缩积分时，才能在扭曲网格上通过体积应变片检验；使用精确或高阶求积通常会导致剪切或体积锁定并导致检验失败。**\n\n该选项描述了一种特定的单元技术，而不是检验的基本通过条件。虽然使用减缩积分是通过应变片检验和缓解锁定的常用策略，但该陈述存在缺陷。声称这是*唯一*的方法（“只有当”）是错误的；存在其他方法，例如B-bar（增强应变）格式。此外，对体积项和偏量项*都*使用单点积分（一致减缩积分）已知会引入伪零能模态（沙漏），这是另一种类型的失效。选择性减缩积分（对偏量部分和体积部分使用不同的规则）是另一种更稳定的策略。此选项将一个可能的解决方案与问题定义混淆，并且在事实上是不完整的。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2595541"}]}