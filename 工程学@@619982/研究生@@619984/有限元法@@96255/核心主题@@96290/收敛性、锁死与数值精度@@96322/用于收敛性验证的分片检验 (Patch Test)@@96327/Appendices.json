{"hands_on_practices": [{"introduction": "一个单元能否通过特定阶次的检验片测试，其根本在于其形函数所包含的多项式基是否“完备”，即能否精确表示该阶次的多项式场。本练习旨在通过一个具体实例，让你识别并补全一个二次多项式基，从而加深对单元收敛性与多项式完备性之间内在联系的理解 [@problem_id:2605451]。", "problem": "考虑一个二维小应变线性弹性问题，该问题在一个由直边三角形单元组成的单元片上，通过基于位移的连续($C^0$)有限元法进行离散。\n\n每个从参考三角形到物理坐标的单元映射都是仿射的，因此物理坐标 $(x,y)$ 线性依赖于参考坐标。\n\n您计划对每个位移分量 $u(x,y)$ 和 $v(x,y)$ 使用相同的标量多项式逼近，即一个由 $(x,y)$ 的单项式构成的基。具体来说，您当前为每个分量选择的基是\n$$\n\\mathcal{B}=\\{1,\\, x,\\, y,\\, x^{2},\\, y^{2}\\}.\n$$\n\n为了通过单元片检验进行收敛性验证，您要求单元能通过二次单元片检验。这意味着，在体力为零、边界牵引力与一个二次位移场相一致的条件下，当单元组装成单元片后，它必须能在每个单元上精确再现该二次位移场。在所述条件（仿射映射和基于位移的格式）下，此要求等价于每个分量的标量逼近空间包含 $(x,y)$ 中总次数最高为2的完备二元多项式空间。\n\n确定必须添加到基 $\\mathcal{B}$ 中的最小总次数的唯一单项式，以使所得的标量逼近空间包含 $(x,y)$ 中的所有二次多项式，从而使单元通过二次单元片检验。请以 $x$ 和 $y$ 表示的单个单项式形式报告您的答案。", "solution": "问题陈述已经过验证，被认为是科学合理、良定且客观的。它提出了有限元方法理论中的一个标准问题。我现在将开始解答。\n\n该问题要求确定必须添加到给定基中的特定单项式，以确保单元格式能通过二次单元片检验。问题明确指出，在给定条件（基于位移的$C^0$格式、具有仿射映射的直边三角形单元）下，通过二次单元片检验等价于每个位移分量的标量逼近空间包含总次数最高为2的完备二元多项式空间。我们将此空间记为 $\\mathcal{P}_2(x,y)$。\n\n如果一个多项式空间包含所有总次数小于或等于 $k$ 的单项式，则称该空间是“直到 $k$ 次完备的”。单项式 $x^a y^b$ 的总次数定义为其指数之和 $a+b$。\n\n空间 $\\mathcal{P}_2(x,y)$ 是所有满足以下形式的多项式 $p(x,y)$ 的集合：\n$$\np(x,y) = \\sum_{i+j \\le 2} c_{ij} x^i y^j\n$$\n其中 $c_{ij}$ 是常系数。为了构成该空间的基，我们必须包含所有满足 $i+j \\le 2$ 的非负整数 $i$和$j$ 的单项式 $x^i y^j$。让我们系统地列举这些单项式：\n\n1.  总次数 0: $i+j=0$。唯一可能性是 $i=0, j=0$，对应单项式 $x^0 y^0 = 1$。\n2.  总次数 1: $i+j=1$。可能性是 $(i,j) = (1,0)$ 和 $(i,j) = (0,1)$，对应单项式 $x^1 y^0 = x$ 和 $x^0 y^1 = y$。\n3.  总次数 2: $i+j=2$。可能性是 $(i,j) = (2,0)$、$(i,j) = (1,1)$ 和 $(i,j) = (0,2)$，对应单项式 $x^2 y^0 = x^2$、$x^1 y^1 = xy$ 和 $x^0 y^2 = y^2$。\n\n综合这些，空间 $\\mathcal{P}_2(x,y)$ 的一个完备单项式基由以下集合给出：\n$$\n\\mathcal{B}_{\\text{complete}} = \\{1, x, y, x^2, y^2, xy\\}\n$$\n该空间的维数为6。\n\n问题中给出的当前用于单元格式的基是不完备的：\n$$\n\\mathcal{B} = \\{1, x, y, x^2, y^2\\}\n$$\n由 $\\mathcal{B}$ 张成的空间是 $\\mathcal{P}_2(x,y)$ 的一个子空间，但它不是完备空间。为满足单元片检验条件，必须扩充该基以张成整个 $\\mathcal{P}_2(x,y)$ 空间。\n\n将集合 $\\mathcal{B}_{\\text{complete}}$ 与给定的基 $\\mathcal{B}$ 直接比较，就可以发现缺失的项。存在于 $\\mathcal{B}_{\\text{complete}}$ 中但 $\\mathcal{B}$ 中没有的单项式正是混合项或耦合项 $xy$。\n\n问题要求的是必须添加的最小总次数的唯一单项式。需要添加的单项式是 $xy$。其总次数为 $1+1=2$。所有较低总次数的单项式（$1, x, y$）都已存在于 $\\mathcal{B}$ 中。总次数为2的仅有的其他单项式是 $x^2$ 和 $y^2$，它们也已经存在。因此，$xy$ 是总次数为2或更小且缺失的*唯一*单项式。因此，它是为达到直到2次的完备性而必须添加的唯一单项式。添加它是完备化该基的充分必要条件。\n\n通过将单项式 $xy$ 添加到基 $\\mathcal{B}$ 中，我们得到新的基 $\\mathcal{B}' = \\{1, x, y, x^2, y^2, xy\\}$，它与 $\\mathcal{B}_{\\text{complete}}$ 相同。$\\mathcal{B}'$ 的张成空间是 $\\mathcal{P}_2(x,y)$，从而满足了通过二次单元片检验的要求。这种不完备的基选择是单元无法通过二次单元片检验的根本原因，而使用完备二次多项式基的单元（如六节点拉格朗日三角形单元）则能通过检验。", "answer": "$$\\boxed{xy}$$", "id": "2605451"}, {"introduction": "在评估单元性能之前，必须确保其从参考域到物理域的几何映射是有效的，这要求雅可比行列式在单元内部处处为正。本练习提供了一个动手计算的机会，让你推导出一个等参单元的几何映射变为奇异（即雅可比行列式为零）的临界条件，这直接关联到网格质量和分析的可靠性 [@problem_id:2605481]。", "problem": "考虑一个在非凸双单元斑块上进行的二维平面应力斑块检验，该斑块由等参双线性四边形单元构成。该斑块的外边界上施加了精确的线性位移场 $u(x,y)=x$ 和 $v(x,y)=0$，其中 $u$ 和 $v$ 是笛卡尔位移分量。材料是均匀、各向同性的线性弹性体，其杨氏模量为 $E$，泊松比为 $\\nu$，但不需要 $E$ 或 $\\nu$ 的具体数值。有限元列式采用标准的等参双线性形函数和标准的高斯求积，积分点为 $2 \\times 2$ 个，位于 $(\\xi,\\eta) \\in \\{(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})\\}$。\n\n关注斑块中一个随着参数 $\\epsilon$ 变化而变为非凸的单元。在物理笛卡尔平面中，其节点坐标如下：\n- 节点 1：$(x_{1},y_{1})=(0,0)$，\n- 节点 2：$(x_{2},y_{2})=(1,0)$，\n- 节点 3：$(x_{3},y_{3})=(1,\\epsilon)$，\n- 节点 4：$(x_{4},y_{4})=(0,1)$，\n\n节点1、2、3、4分别与参考单元的角点 $(\\xi,\\eta)=(-1,-1),(1,-1),(1,1),(-1,1)$ 对应。等参映射由 $(x(\\xi,\\eta),y(\\xi,\\eta))=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)(x_{i},y_{i})$ 给出，其中 $N_{i}$ 为标准的双线性形函数。通过线性斑块检验的一个必要条件是，在所有高斯点处映射都是局部可逆的，即在所有四个 $2 \\times 2$ 的高斯点上都有 $\\det J(\\xi,\\eta)>0$，其中 $J(\\xi,\\eta)$ 是等参映射的雅可比矩阵。\n\n将 $\\epsilon$ 视为一个实参数，确定当映射在高斯点 $(\\xi,\\eta)=(1/\\sqrt{3},1/\\sqrt{3})$ 处首次变为奇异时的临界值 $\\epsilon_{\\text{crit}}$（以精确解析形式表示），即，使得 $\\det J(1/\\sqrt{3},1/\\sqrt{3})=0$ 成立的最小 $\\epsilon$ 值（在此特定高斯点上从容许状态跨越到不容许状态的意义上）。无需四舍五入，也无需单位。最终答案必须是 $\\epsilon_{\\text{crit}}$ 的单个闭式表达式。", "solution": "该问题是适定的，并包含足够的信息以获得唯一解。我们直接进行推导。\n\n问题的核心在于分析从参考单元到物理单元的等参映射。该映射由标准的双线性形函数 $N_i(\\xi, \\eta)$ 和物理单元的节点坐标 $(x_i, y_i)$ 定义。\n\n映射表示为：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i\n$$\n$$\ny(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n其中 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 是参考域中的坐标。标准的双线性形函数为：\n$$\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)\n$$\n$$\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n问题给出了物理 $(x, y)$ 平面中的节点坐标：\n节点 1：$(x_1, y_1) = (0, 0)$\n节点 2：$(x_2, y_2) = (1, 0)$\n节点 3：$(x_3, y_3) = (1, \\epsilon)$\n节点 4：$(x_4, y_4) = (0, 1)$\n\n将这些坐标代入映射方程：\n对于 $x$ 坐标映射：\n$$\nx(\\xi, \\eta) = N_1(\\xi, \\eta)(0) + N_2(\\xi, \\eta)(1) + N_3(\\xi, \\eta)(1) + N_4(\\xi, \\eta)(0) = N_2(\\xi, \\eta) + N_3(\\xi, \\eta)\n$$\n$$\nx(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{4}(1+\\xi)[(1-\\eta)+(1+\\eta)] = \\frac{1}{4}(1+\\xi)(2) = \\frac{1}{2}(1+\\xi)\n$$\n对于 $y$ 坐标映射：\n$$\ny(\\xi, \\eta) = N_1(\\xi, \\eta)(0) + N_2(\\xi, \\eta)(0) + N_3(\\xi, \\eta)(\\epsilon) + N_4(\\xi, \\eta)(1) = \\epsilon N_3(\\xi, \\eta) + N_4(\\xi, \\eta)\n$$\n$$\ny(\\xi, \\eta) = \\epsilon \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) = \\frac{1}{4}(1+\\eta)[\\epsilon(1+\\xi) + (1-\\xi)]\n$$\n$$\ny(\\xi, \\eta) = \\frac{1}{4}(1+\\eta)[1+\\epsilon + (\\epsilon-1)\\xi]\n$$\n该变换的雅可比矩阵定义为：\n$$\nJ(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\n我们计算必要的偏导数：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\frac{1}{2}(1+\\xi) \\right] = \\frac{1}{2}\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\frac{1}{2}(1+\\xi) \\right] = 0\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left[ \\frac{1}{4}(1+\\eta)(1+\\epsilon + (\\epsilon-1)\\xi) \\right] = \\frac{1}{4}(1+\\eta)(\\epsilon-1)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left[ \\frac{1}{4}(1+\\eta)(1+\\epsilon + (\\epsilon-1)\\xi) \\right] = \\frac{1}{4}(1+\\epsilon + (\\epsilon-1)\\xi)\n$$\n组装雅可比矩阵：\n$$\nJ(\\xi, \\eta) = \\begin{pmatrix} \\frac{1}{2} & 0 \\\\ \\frac{1}{4}(1+\\eta)(\\epsilon-1) & \\frac{1}{4}(1+\\epsilon + (\\epsilon-1)\\xi) \\end{pmatrix}\n$$\n雅可比矩阵的行列式 $\\det J$ 在单元内必须处处为正，以保证映射是局部可逆的。当 $\\det J = 0$ 时，映射发生奇异。\n$$\n\\det J(\\xi, \\eta) = \\left(\\frac{1}{2}\\right) \\left( \\frac{1}{4}(1+\\epsilon + (\\epsilon-1)\\xi) \\right) - (0) \\left( \\frac{1}{4}(1+\\eta)(\\epsilon-1) \\right)\n$$\n$$\n\\det J(\\xi, \\eta) = \\frac{1}{8}(1+\\epsilon + (\\epsilon-1)\\xi)\n$$\n问题要求找到使映射在指定高斯点 $(\\xi, \\eta) = (1/\\sqrt{3}, 1/\\sqrt{3})$ 处变为奇异的临界值 $\\epsilon_{\\text{crit}}$。我们将行列式在该点的值设为零。注意到该行列式与 $\\eta$ 无关，所以我们只需代入 $\\xi = 1/\\sqrt{3}$：\n$$\n\\det J\\left(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{8}\\left(1+\\epsilon_{\\text{crit}} + (\\epsilon_{\\text{crit}}-1)\\frac{1}{\\sqrt{3}}\\right) = 0\n$$\n这给出条件：\n$$\n1+\\epsilon_{\\text{crit}} + (\\epsilon_{\\text{crit}}-1)\\frac{1}{\\sqrt{3}} = 0\n$$\n为了求解 $\\epsilon_{\\text{crit}}$，我们将整个方程乘以 $\\sqrt{3}$ 以消去分式：\n$$\n\\sqrt{3}(1+\\epsilon_{\\text{crit}}) + (\\epsilon_{\\text{crit}}-1) = 0\n$$\n$$\n\\sqrt{3} + \\sqrt{3}\\epsilon_{\\text{crit}} + \\epsilon_{\\text{crit}} - 1 = 0\n$$\n合并包含 $\\epsilon_{\\text{crit}}$ 的项：\n$$\n\\epsilon_{\\text{crit}}(\\sqrt{3}+1) = 1 - \\sqrt{3}\n$$\n分离出 $\\epsilon_{\\text{crit}}$ 可得：\n$$\n\\epsilon_{\\text{crit}} = \\frac{1 - \\sqrt{3}}{1 + \\sqrt{3}}\n$$\n为得到最终的简化解析形式，我们通过将分子和分母同乘以分母的共轭式 $(1 - \\sqrt{3})$ 来使分母有理化：\n$$\n\\epsilon_{\\text{crit}} = \\frac{1 - \\sqrt{3}}{1 + \\sqrt{3}} \\cdot \\frac{1 - \\sqrt{3}}{1 - \\sqrt{3}} = \\frac{(1 - \\sqrt{3})^2}{1^2 - (\\sqrt{3})^2}\n$$\n$$\n\\epsilon_{\\text{crit}} = \\frac{1 - 2\\sqrt{3} + (\\sqrt{3})^2}{1 - 3} = \\frac{1 - 2\\sqrt{3} + 3}{-2} = \\frac{4 - 2\\sqrt{3}}{-2}\n$$\n$$\n\\epsilon_{\\text{crit}} = -2 + \\sqrt{3}\n$$\n这就是参数 $\\epsilon$ 的精确临界值。为了在该特定高斯点上满足容许性，要求 $\\epsilon > \\sqrt{3}-2$。因此，$\\epsilon_{\\text{crit}} = \\sqrt{3}-2$ 代表了映射从容许状态转变为不容许状态的边界。", "answer": "$$\n\\boxed{\\sqrt{3}-2}\n$$", "id": "2605481"}, {"introduction": "理论上，一个正确的单元（如常应变三角形单元）应该以机器精度通过检验片测试。然而，在实际计算中，不良的网格几何形状可能导致刚度矩阵病态，而有限的浮点数精度则会引入舍入误差。本编程练习将通过模拟这些效应，让你亲手探究数值精度和网格质量如何在实践中影响检验片测试的结果 [@problem_id:2605438]。", "problem": "要求您从基本原理出发，使用常应变三角形 (CST) 单元，通过有限元法 (FEM) 为二维线性弹性力学问题实现一个计算斑块检验，并明确研究网格条件数和数值精度如何影响验证结果。当施加相应的 Dirichlet 边界条件且体力为零时，斑块检验用于检查离散化方法能否精确再现任意线性位移场。您的实现必须包含一个受控舍入模型，该模型通过模拟使用指定数量二进制尾数位的算术运算，以评估对数值精度的敏感性。\n\n从以下基本原理出发：\n- 无体力的小应变、平面应力线性弹性力学的弱形式：在容许空间中寻找位移场 $u : \\Omega \\to \\mathbb{R}^2$，使得对于所有容许虚位移 $w$ 都有\n$$\n\\int_{\\Omega} \\varepsilon(w)^{\\mathsf{T}} D \\, \\varepsilon(u)\\, \\mathrm{d}\\Omega = 0,\n$$\n其中 $D$ 是各向同性平面应力弹性的本构矩阵，$\\varepsilon(\\cdot)$ 是线性化应变算子。\n- 节点坐标为 $(x_i,y_i)$，$i \\in \\{1,2,3\\}$ 的常应变三角形 (CST) 单元具有一个常数应变-位移矩阵 $B$ 和单元刚度\n$$\nK_e = t \\, A \\, B^{\\mathsf{T}} D B,\n$$\n其中 $t$ 是单元厚度，$A$ 是三角形面积，$D$ 是平面应力本构张量\n$$\nD = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n- 一阶完备性的斑块检验从一个线性场规定边界上的位移\n$$\nu(x,y) =\n\\begin{bmatrix}\na_0 + a_1 x + a_2 y\\\\\nb_0 + b_1 x + b_2 y\n\\end{bmatrix},\n$$\n。对于一个 CST 单元网格，在精确算术条件下，内部节点的解必须与精确线性场完全匹配。\n\n几何与网格：\n- 考虑正方形区域 $\\Omega = [0,1]\\times[0,1]$，该区域通过一个位于坐标 $x \\in \\{0, 0.5, 1\\}$ 和 $y \\in \\{0, 0.5, 1\\}$ 上的 $3\\times 3$ 节点网格进行离散化，并通过将 4 个小正方形中的每一个沿相同对角线分割，从而将其三角剖分为 8 个 CST 单元。为控制条件数，将 y 坐标以一个因子 $s>0$ 进行各向异性压缩，即使用节点坐标 $(x, s y)$，同时保持 $x$ 不变。将压缩因子记为 $s$。\n- 使用位于几何中心的内部节点作为唯一的自由节点，并在所有边界节点上施加由线性场给出的 Dirichlet 边界条件。\n\n材料与载荷：\n- 使用平面应力模型，Young 模量 $E = 1$，Poisson 比 $\\nu = 0.3$，厚度 $t = 1$。无体力，无面力。\n- 使用线性位移场系数 $a_0 = 0.3$, $a_1 = 1.7$, $a_2 = -0.9$, $b_0 = -0.2$, $b_1 = 0.4$, $b_2 = 1.1$。\n\n数值精度模型：\n- 通过将每个基本算术运算结果舍入到 $p$ 个二进制尾数位，模拟具有指定二进制尾数位数 $p$ 的算术运算。通过标准分解将实数表示为 $m 2^e$（其中 $m \\in [0.5,1)$）后，对尾数进行四舍五入。将此舍入操作一致地应用于单元刚度计算和全局刚度组装中使用的标量加、减、乘、除运算，以及用于形成简化右端项的矩阵-向量乘积。使用标准的双精度求解器求解最终的简化线性系统。\n- 在进行误差评估之前，将恢复的内部节点位移量化到 $p$ 位尾数，以反映有限的输出精度。\n\n误差度量：\n- 令 $u_h$ 为内部（自由）节点处的计算位移，$u_{\\star}$ 为该节点处的精确线性场位移。定义相对误差为\n$$\n\\mathrm{err} = \\frac{\\|u_h - u_{\\star}\\|_2}{\\|u_{\\star}\\|_2}.\n$$\n\n任务：\n- 为以下 $(s,p)$ 对组成的测试套件实现上述过程：\n  1. $s = 1$, $p = 53$ (条件良好的几何形状，双精度尾数)。\n  2. $s = 10^{-3}$, $p = 24$ (中等病态几何形状，类单精度尾数)。\n  3. $s = 10^{-6}$, $p = 53$ (高度病态几何形状，双精度尾数)。\n  4. $s = 10^{-6}$, $p = 10$ (高度病态几何形状，极低精度尾数)。\n- 对于每种情况，计算如上定义的 $\\mathrm{err}$。\n\n输出规格：\n- 您的程序应产生单行输出，其中包含四个相对误差，形式为逗号分隔的列表，并用方括号括起来，顺序与上述四种 $(s,p)$ 情况的列表顺序一致。这些数字是无量纲的。例如，一个符合要求的输出格式是\n$$\n[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3,\\mathrm{err}_4],\n$$\n其中每个 $\\mathrm{err}_i$ 是一个标准十进制表示法的浮点数。", "solution": "问题陈述经过严格审查，被认为是有效的。这是一个计算力学中的适定且有科学依据的问题，要求在受控的数值精度下实现有限元斑块检验。其参数、方程和目标都以足够的清晰度和严谨性给出，足以得到一个唯一且有意义的解。\n\n该任务旨在验证用于二维平面应力弹性问题的常应变三角形 (CST) 单元的一阶完备性。这通过斑块检验来实现，该检验断言，对于一个单元片，当施加相应的 Dirichlet 边界条件时，有限元解必须能精确再现一个线性位移场。该问题引入了两个关键的复杂性：一是通过各向异性网格扭曲来引入病态条件，二是通过模拟的有限精度算术模型来研究其与数值误差的相互作用。\n\n在无体力的情况下的静力平衡的弱形式为：\n$$\n\\int_{\\Omega} \\varepsilon(w)^{\\mathsf{T}} D \\, \\varepsilon(u)\\, \\mathrm{d}\\Omega = 0 \\quad \\forall w \\in V_0\n$$\n其中 $u$ 是容许函数空间 $V$ 中的位移场，$w$ 是在 Dirichlet 边界上为零的空间 $V_0$ 中的虚位移，$\\varepsilon(\\cdot)$ 是产生应变分量的对称梯度算子，$D$ 是材料本构矩阵。对于各向同性平面应力， $D$ 由下式给出：\n$$\nD = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0\\\\\n\\nu & 1 & 0\\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\n其中 Young 模量 $E=1$，Poisson 比 $\\nu=0.3$。\n\n域 $\\Omega = [0,1]\\times[0,1]$ 使用一个位于 $3 \\times 3$ 节点网格上的包含 8 个 CST 单元的网格进行离散化。节点坐标为 $(x, sy)$，其中 $x, y \\in \\{0, 0.5, 1\\}$，$s$ 是网格压缩因子。节点自由度 (DOF) 是水平和垂直位移 $(u_x, u_y)$。离散化后得到代数系统 $KU=F$。\n\n对于节点 $i, j, k$ 坐标为 $(x_i, y_i), (x_j, y_j), (x_k, y_k)$ 的单个 CST 单元，其 $6 \\times 6$ 的单元刚度矩阵 $K_e$ 计算如下：\n$$\nK_e = t A B^{\\mathsf{T}} D B\n$$\n此处，$t=1$ 是厚度，$A$ 是单元面积，$B$ 是常应变-位移矩阵：\n$$\nB = \\frac{1}{2A} \\begin{bmatrix}\ny_j-y_k & 0 & y_k-y_i & 0 & y_i-y_j & 0 \\\\\n0 & x_k-x_j & 0 & x_i-x_k & 0 & x_j-x_i \\\\\ny_j-y_k & x_k-x_j & y_k-y_i & x_i-x_k & y_i-y_j & x_j-x_i\n\\end{bmatrix}\n$$\n面积 $A$ 由 $A = \\frac{1}{2} |x_i(y_j - y_k) + x_j(y_k - y_i) + x_k(y_i - y_j)|$ 给出。\n\n此问题的一个关键组成部分是模拟有限精度算术。在计算单元刚度矩阵、将其组装成全局矩阵以及形成右端向量的整个过程中，每个基本运算（加、减、乘、除）都必须舍入到 $p$ 个二进制位的尾数。这是通过一个自定义的舍入函数实现的，该函数对一个数 $x$ 进行操作，首先将其分解为尾数和指数，$x=m \\cdot 2^e$，其中 $m \\in [-1, -0.5) \\cup \\{0\\} \\cup [0.5, 1)$，然后将尾数 $m$ 舍入到最接近的可用 $p$ 位表示的值，最后重构该数。\n\n指定的位移场是线性的：\n$$\nu(x,y) = \\begin{bmatrix} u_x(x,y) \\\\ u_y(x,y) \\end{bmatrix} =\n\\begin{bmatrix}\na_0 + a_1 x + a_2 y\\\\\nb_0 + b_1 x + b_2 y\n\\end{bmatrix}\n$$\n其系数为 $a_0 = 0.3, a_1 = 1.7, a_2 = -0.9, b_0 = -0.2, b_1 = 0.4, b_2 = 1.1$。该场在 8 个边界节点的坐标处求值，以定义 Dirichlet 边界条件。位于 $(0.5, 0.5s)$ 的单个内部节点保持自由。\n\n全局系统 $KU=F$ 被划分为自由 (f) 和指定 (p) 自由度：\n$$\n\\begin{bmatrix} K_{ff} & K_{fp} \\\\ K_{pf} & K_{pp} \\end{bmatrix} \\begin{Bmatrix} U_f \\\\ U_p \\end{Bmatrix} = \\begin{Bmatrix} F_f \\\\ F_p \\end{Bmatrix}\n$$\n由于自由节点上没有外力，$F_f = 0$。用于求解未知位移 $U_f$ 的简化系统为：\n$$\nK_{ff} U_f = -K_{fp} U_p\n$$\n矩阵 $K_{ff}$ 和 $K_{fp}$ 是全局刚度矩阵 $K$ 的子矩阵，该全局矩阵使用有限精度算术逐单元组装而成。右端向量 $RHS = -K_{fp} U_p$ 也使用考虑精度的矩阵-向量乘法计算。根据问题规定，这个最终的 $2 \\times 2$ 系统使用标准的双精度线性求解器求解。\n\n在获得自由节点的计算位移 $u_h$ 后，其分量被量化到 $p$ 位精度。然后相对于该节点的精确位移 $u_{\\star} = u(0.5, 0.5s)$ 计算相对误差：\n$$\n\\mathrm{err} = \\frac{\\|u_h - u_{\\star}\\|_2}{\\|u_{\\star}\\|_2}\n$$\n对测试套件中提供的每对参数 $(s, p)$ 重复此过程。该实现将系统地在指定的精度约束下构造所有矩阵和向量，以评估条件数和舍入误差对斑块检验结果的影响。", "answer": "```python\nimport numpy as np\nimport math\n\nclass PFloatOps:\n    \"\"\"\n    A class to handle arithmetic operations with controlled precision.\n    All elementary operations are rounded to a mantissa of p binary bits.\n    \"\"\"\n    def __init__(self, p):\n        if not (1 <= p <= 53):\n            raise ValueError(\"Precision bits p must be between 1 and 53.\")\n        self.p = p\n\n    def round(self, val: float) -> float:\n        \"\"\"Rounds a float to p mantissa bits.\"\"\"\n        if val == 0.0 or not np.isfinite(val):\n            return val\n        \n        m, e = math.frexp(val)\n        # m is in [-1, -0.5) or [0.5, 1)\n        # Scale mantissa, round to nearest integer, and scale back.\n        scale = 2**self.p\n        rounded_m = round(m * scale) / scale\n        return math.ldexp(rounded_m, e)\n\n    def add(self, a: float, b: float) -> float:\n        return self.round(a + b)\n\n    def sub(self, a: float, b: float) -> float:\n        return self.round(a - b)\n\n    def mul(self, a: float, b: float) -> float:\n        return self.round(a * b)\n\n    def div(self, a: float, b: float) -> float:\n        return self.round(a / b)\n\n    def matmul(self, A: np.ndarray, B: np.ndarray) -> np.ndarray:\n        \"\"\"Performs matrix multiplication with controlled precision.\"\"\"\n        m, n = A.shape\n        n_B, p_ = B.shape\n        if n != n_B:\n            raise ValueError(\"Matrix dimensions are incompatible for multiplication.\")\n        \n        C = np.zeros((m, p_))\n        for i in range(m):\n            for j in range(p_):\n                sum_val = 0.0\n                for k in range(n):\n                    prod = self.mul(A[i, k], B[k, j])\n                    sum_val = self.add(sum_val, prod)\n                C[i, j] = sum_val\n        return C\n    \n    def matvecmul(self, A: np.ndarray, v: np.ndarray) -> np.ndarray:\n        \"\"\"Performs matrix-vector multiplication with controlled precision.\"\"\"\n        m, n = A.shape\n        if n != v.shape[0]:\n            raise ValueError(\"Matrix and vector dimensions are incompatible.\")\n\n        res = np.zeros(m)\n        for i in range(m):\n            sum_val = 0.0\n            for j in range(n):\n                prod = self.mul(A[i, j], v[j])\n                sum_val = self.add(sum_val, prod)\n            res[i] = sum_val\n        return res\n\ndef get_cst_stiffness(nodes_coords: np.ndarray, D: np.ndarray, t: float, ops: PFloatOps) -> np.ndarray:\n    \"\"\"\n    Computes the stiffness matrix for a single Constant Strain Triangle (CST) element\n    using the provided precision operations.\n    \"\"\"\n    (x1, y1), (x2, y2), (x3, y3) = nodes_coords\n    \n    # Calculate area with precision\n    term1 = ops.mul(x1, ops.sub(y2, y3))\n    term2 = ops.mul(x2, ops.sub(y3, y1))\n    term3 = ops.mul(x3, ops.sub(y1, y2))\n    sum_terms = ops.add(ops.add(term1, term2), term3)\n    area = ops.div(sum_terms, 2.0)\n    \n    if area <= 0:\n        raise ValueError(\"Element has zero or negative area.\")\n\n    # Components of B matrix\n    beta1, beta2, beta3 = ops.sub(y2, y3), ops.sub(y3, y1), ops.sub(y1, y2)\n    gamma1, gamma2, gamma3 = ops.sub(x3, x2), ops.sub(x1, x3), ops.sub(x2, x1)\n\n    inv_2A = ops.div(1.0, ops.mul(2.0, area))\n\n    B = np.zeros((3, 6))\n    betas = [beta1, beta2, beta3]\n    gammas = [gamma1, gamma2, gamma3]\n\n    for i in range(3):\n        B[0, 2*i] = ops.mul(betas[i], inv_2A)\n        B[1, 2*i+1] = ops.mul(gammas[i], inv_2A)\n        B[2, 2*i] = ops.mul(gammas[i], inv_2A)\n        B[2, 2*i+1] = ops.mul(betas[i], inv_2A)\n\n    # Ke = t * A * B.T @ D @ B with controlled precision\n    Bt = B.T\n    DB = ops.matmul(D, B)\n    BtDB = ops.matmul(Bt, DB)\n    \n    Ke = np.zeros((6, 6))\n    scalar = ops.mul(t, area)\n    for i in range(6):\n        for j in range(6):\n            Ke[i, j] = ops.mul(scalar, BtDB[i, j])\n\n    return Ke\n\ndef solve_case(s: float, p: int) -> float:\n    \"\"\"\n    Runs the patch test for a given geometry scaling `s` and precision `p`.\n    \"\"\"\n    ops = PFloatOps(p)\n\n    # Material properties\n    E = 1.0\n    nu = 0.3\n    t = 1.0\n    \n    # Constitutive matrix D for plane stress, calculated with precision\n    nu_sq = ops.mul(nu, nu)\n    one_minus_nu_sq = ops.sub(1.0, nu_sq)\n    factor = ops.div(E, one_minus_nu_sq)\n    \n    D = np.zeros((3, 3))\n    D[0, 0] = factor\n    D[0, 1] = ops.mul(factor, nu)\n    D[1, 0] = D[0, 1]\n    D[1, 1] = factor\n    D[2, 2] = ops.mul(factor, ops.div(ops.sub(1.0, nu), 2.0))\n\n    # Mesh definition\n    x_coords = [0.0, 0.5, 1.0]\n    y_coords = [0.0, 0.5, 1.0]\n    nodes = np.array([[x, ops.mul(s, y)] for y in y_coords for x in x_coords])\n    \n    # Node indices are 0-8, row-by-row from bottom-left\n    # Elements are numbered to create a consistent triangulation\n    elements = [\n        (0, 1, 4), (0, 4, 3), (1, 2, 5), (1, 5, 4),\n        (3, 4, 7), (3, 7, 6), (4, 5, 8), (4, 8, 7)\n    ]\n    \n    # Assembly\n    num_nodes = 9\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for el_nodes in elements:\n        node1_idx, node2_idx, node3_idx = el_nodes\n        el_coords = nodes[[node1_idx, node2_idx, node3_idx]]\n        \n        Ke = get_cst_stiffness(el_coords, D, t, ops)\n        \n        dof_indices = [2*node1_idx, 2*node1_idx+1, 2*node2_idx, 2*node2_idx+1, 2*node3_idx, 2*node3_idx+1]\n        \n        for i in range(6):\n            for j in range(6):\n                global_i, global_j = dof_indices[i], dof_indices[j]\n                K_global[global_i, global_j] = ops.add(K_global[global_i, global_j], Ke[i, j])\n\n    # Boundary conditions and partitioning\n    free_dofs = [8, 9]  # DOFs for the central node (node 4)\n    prescribed_dofs = [i for i in range(2 * num_nodes) if i not in free_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n    \n    # Prescribed displacement field coefficients\n    a0, a1, a2 = 0.3, 1.7, -0.9\n    b0, b1, b2 = -0.2, 0.4, 1.1\n\n    def u_exact(x, y):\n        ux = a0 + a1*x + a2*y\n        uy = b0 + b1*x + b2*y\n        return np.array([ux, uy])\n\n    U_p = np.zeros(len(prescribed_dofs))\n    for i, dof in enumerate(prescribed_dofs):\n        node_idx = dof // 2\n        dof_type = dof % 2\n        node_coord = nodes[node_idx]\n        u_val = u_exact(node_coord[0], node_coord[1])[dof_type]\n        U_p[i] = u_val\n        \n    # Solve system: K_ff * U_f = -K_fp * U_p\n    RHS = ops.matvecmul(K_fp, U_p)\n    RHS = -RHS\n    \n    # Solve using standard double precision solver\n    try:\n        Uh_f = np.linalg.solve(K_ff, RHS)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # Quantize solution\n    Uh_f_quantized = np.array([ops.round(Uh_f[0]), ops.round(Uh_f[1])])\n    \n    # Error calculation\n    center_node_coord = nodes[4]\n    U_star = u_exact(center_node_coord[0], center_node_coord[1])\n    \n    diff_vec = Uh_f_quantized - U_star\n    err_norm = np.linalg.norm(diff_vec)\n    ustar_norm = np.linalg.norm(U_star)\n    \n    if ustar_norm == 0:\n        return 0.0 if err_norm == 0.0 else np.inf\n    \n    return err_norm / ustar_norm\n\ndef solve():\n    test_cases = [\n        (1.0, 53),\n        (1e-3, 24),\n        (1e-6, 53),\n        (1e-6, 10),\n    ]\n\n    results = []\n    for s, p in test_cases:\n        rel_err = solve_case(s, p)\n        results.append(rel_err)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2605438"}]}