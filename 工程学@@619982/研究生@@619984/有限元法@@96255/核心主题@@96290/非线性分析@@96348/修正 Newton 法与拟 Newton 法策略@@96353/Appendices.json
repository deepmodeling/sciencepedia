{"hands_on_practices": [{"introduction": "第一个练习旨在通过具体的步骤，对完整的牛顿-拉弗森法与其最简单的准牛顿变体——修正牛顿法——进行比较。通过对一个小型二自由度系统进行迭代计算，您将直接观察到每次迭代的计算成本与收敛速度之间的相互作用。这项实践对于直观理解那些驱动更高级准牛顿策略发展的基本权衡至关重要。", "problem": "考虑一个源自简化的双自由度有限元 (FE) 系统的非线性平衡方程，其中残差向量 $\\boldsymbol{R}(\\boldsymbol{u}) \\in \\mathbb{R}^{2}$ 的分量定义如下\n$$\nR_{1}(\\boldsymbol{u}) \\equiv 2\\,u_{1} + \\tfrac{1}{2}\\,u_{1}^{2} + 0.1\\,u_{2}^{2} - 1.2, \\quad\nR_{2}(\\boldsymbol{u}) \\equiv -0.3\\,u_{1} + 1.5\\,u_{2} + 0.2\\,u_{1}\\,u_{2} + 0.1\\,u_{2}^{3} - 0.9,\n$$\n初始猜测值为 $\\boldsymbol{u}_{0} = (0,0)^{\\mathsf{T}}$。一致切线（雅可比）矩阵 $\\boldsymbol{K}(\\boldsymbol{u}) = \\partial \\boldsymbol{R}/\\partial \\boldsymbol{u}$ 为\n$$\n\\boldsymbol{K}(\\boldsymbol{u}) = \n\\begin{pmatrix}\n2 + u_{1} & 0.2\\,u_{2} \\\\\n-0.3 + 0.2\\,u_{2} & 1.5 + 0.2\\,u_{1} + 0.3\\,u_{2}^{2}\n\\end{pmatrix},\n$$\n在初始猜测值处，我们有\n$$\n\\boldsymbol{K}(\\boldsymbol{u}_{0}) = \n\\begin{pmatrix}\n2 & 0 \\\\\n-0.3 & 1.5\n\\end{pmatrix}.\n$$\n从 $\\boldsymbol{u}_{0}$ 开始，对以下每种策略执行两次迭代：\n- 完全牛顿法：$\\boldsymbol{u}_{k+1} = \\boldsymbol{u}_{k} - \\boldsymbol{K}(\\boldsymbol{u}_{k})^{-1}\\,\\boldsymbol{R}(\\boldsymbol{u}_{k})$。\n- 修正牛顿法（一种采用冻结切线的拟牛顿策略）：$\\boldsymbol{u}_{k+1} = \\boldsymbol{u}_{k} - \\boldsymbol{K}(\\boldsymbol{u}_{0})^{-1}\\,\\boldsymbol{R}(\\boldsymbol{u}_{k})$。\n\n对于每种策略，将第 $k$ 次迭代的欧几里得残差缩减因子定义为\n$$\n\\rho_{k} \\equiv \\frac{\\|\\boldsymbol{R}(\\boldsymbol{u}_{k+1})\\|_{2}}{\\|\\boldsymbol{R}(\\boldsymbol{u}_{k})\\|_{2}},\n$$\n其中 $\\|\\cdot\\|_{2}$ 表示欧几里得范数。根据牛顿线性化原理推导迭代过程，并直接计算所有残差和因子（不使用线搜索或阻尼）。\n\n作为最终答案，报告修正牛顿法第二次迭代的残差缩减因子 $\\rho_{1}$。将最终答案四舍五入到四位有效数字。无需物理单位。", "solution": "该问题要求计算修正牛顿法经过两次迭代后的残差缩减因子 $\\rho_{1}$。通过牛顿类方法求解非线性方程组 $\\boldsymbol{R}(\\boldsymbol{u}) = \\boldsymbol{0}$ 的一般原理是基于残差向量 $\\boldsymbol{R}$ 在当前迭代点 $\\boldsymbol{u}_{k}$ 附近的一阶泰勒级数展开：\n$$\n\\boldsymbol{R}(\\boldsymbol{u}_{k+1}) \\approx \\boldsymbol{R}(\\boldsymbol{u}_{k}) + \\frac{\\partial \\boldsymbol{R}}{\\partial \\boldsymbol{u}}\\bigg|_{\\boldsymbol{u}_{k}} (\\boldsymbol{u}_{k+1} - \\boldsymbol{u}_{k})\n$$\n将 $\\boldsymbol{R}(\\boldsymbol{u}_{k+1})$ 设为 $\\boldsymbol{0}$，并定义切线矩阵 $\\boldsymbol{K}(\\boldsymbol{u}_{k}) = \\frac{\\partial \\boldsymbol{R}}{\\partial \\boldsymbol{u}}\\big|_{\\boldsymbol{u}_{k}}$ 和位移增量 $\\Delta \\boldsymbol{u}_{k} = \\boldsymbol{u}_{k+1} - \\boldsymbol{u}_{k}$，我们得到关于增量的线性系统：\n$$\n\\boldsymbol{K}(\\boldsymbol{u}_{k}) \\Delta \\boldsymbol{u}_{k} = -\\boldsymbol{R}(\\boldsymbol{u}_{k})\n$$\n则下一个迭代点为 $\\boldsymbol{u}_{k+1} = \\boldsymbol{u}_{k} + \\Delta \\boldsymbol{u}_{k}$。\n对于完全牛顿法，切线矩阵 $\\boldsymbol{K}(\\boldsymbol{u}_{k})$ 在每次迭代 k 中都会重新计算。对于修正牛顿法，切线矩阵仅在初始猜测值 $\\boldsymbol{u}_{0}$ 处计算一次，然后在所有后续迭代中保持不变（冻结）。因此，迭代更新式为 $\\boldsymbol{u}_{k+1} = \\boldsymbol{u}_{k} - \\boldsymbol{K}(\\boldsymbol{u}_{0})^{-1}\\boldsymbol{R}(\\boldsymbol{u}_{k})$。\n\n我们从初始猜测值 $\\boldsymbol{u}_{0} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 开始。\n\n**初始状态 ($k=0$)**\n\n首先，计算初始残差向量 $\\boldsymbol{R}(\\boldsymbol{u}_{0})$：\n$$\nR_{1}(\\boldsymbol{u}_{0}) = 2(0) + \\frac{1}{2}(0)^{2} + 0.1(0)^{2} - 1.2 = -1.2\n$$\n$$\nR_{2}(\\boldsymbol{u}_{0}) = -0.3(0) + 1.5(0) + 0.2(0)(0) + 0.1(0)^{3} - 0.9 = -0.9\n$$\n所以，$\\boldsymbol{R}(\\boldsymbol{u}_{0}) = \\begin{pmatrix} -1.2 \\\\ -0.9 \\end{pmatrix}$。\n初始残差的欧几里得范数为：\n$$\n\\|\\boldsymbol{R}(\\boldsymbol{u}_{0})\\|_{2} = \\sqrt{(-1.2)^{2} + (-0.9)^{2}} = \\sqrt{1.44 + 0.81} = \\sqrt{2.25} = 1.5\n$$\n在初始猜测值处的切线矩阵给出如下：\n$$\n\\boldsymbol{K}_{0} = \\boldsymbol{K}(\\boldsymbol{u}_{0}) = \\begin{pmatrix} 2 & 0 \\\\ -0.3 & 1.5 \\end{pmatrix}\n$$\n该矩阵的行列式为 $\\det(\\boldsymbol{K}_{0}) = (2)(1.5) - (0)(-0.3) = 3$。其逆矩阵为：\n$$\n\\boldsymbol{K}_{0}^{-1} = \\frac{1}{3} \\begin{pmatrix} 1.5 & 0 \\\\ 0.3 & 2 \\end{pmatrix} = \\begin{pmatrix} 0.5 & 0 \\\\ 0.1 & \\frac{2}{3} \\end{pmatrix}\n$$\n\n**第一次迭代 ($k=0$)**\n\n这次迭代对于完全牛顿法和修正牛顿法是相同的。我们求解 $\\boldsymbol{K}_{0} \\Delta \\boldsymbol{u}_{0} = -\\boldsymbol{R}(\\boldsymbol{u}_{0})$。\n$$\n\\Delta \\boldsymbol{u}_{0} = -\\boldsymbol{K}_{0}^{-1} \\boldsymbol{R}(\\boldsymbol{u}_{0}) = -\\begin{pmatrix} 0.5 & 0 \\\\ 0.1 & \\frac{2}{3} \\end{pmatrix} \\begin{pmatrix} -1.2 \\\\ -0.9 \\end{pmatrix} = -\\begin{pmatrix} 0.5(-1.2) \\\\ 0.1(-1.2) + \\frac{2}{3}(-0.9) \\end{pmatrix} = -\\begin{pmatrix} -0.6 \\\\ -0.12 - 0.6 \\end{pmatrix} = \\begin{pmatrix} 0.6 \\\\ 0.72 \\end{pmatrix}\n$$\n第一个更新后的位移向量为：\n$$\n\\boldsymbol{u}_{1} = \\boldsymbol{u}_{0} + \\Delta \\boldsymbol{u}_{0} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 0.6 \\\\ 0.72 \\end{pmatrix} = \\begin{pmatrix} 0.6 \\\\ 0.72 \\end{pmatrix}\n$$\n接下来，我们计算在 $\\boldsymbol{u}_{1}$ 处的残差：\n$$\nR_{1}(\\boldsymbol{u}_{1}) = 2(0.6) + \\frac{1}{2}(0.6)^{2} + 0.1(0.72)^{2} - 1.2 = 1.2 + 0.5(0.36) + 0.1(0.5184) - 1.2 = 0.18 + 0.05184 = 0.23184\n$$\n$$\nR_{2}(\\boldsymbol{u}_{1}) = -0.3(0.6) + 1.5(0.72) + 0.2(0.6)(0.72) + 0.1(0.72)^{3} - 0.9 = -0.18 + 1.08 + 0.0864 + 0.1(0.373248) - 0.9 = 0.0864 + 0.0373248 = 0.1237248\n$$\n因此，$\\boldsymbol{R}(\\boldsymbol{u}_{1}) = \\begin{pmatrix} 0.23184 \\\\ 0.1237248 \\end{pmatrix}$。该残差的范数为：\n$$\n\\|\\boldsymbol{R}(\\boldsymbol{u}_{1})\\|_{2} = \\sqrt{(0.23184)^{2} + (0.1237248)^{2}} = \\sqrt{0.0537498256 + 0.01530782611584} = \\sqrt{0.06905765171584} \\approx 0.2627885994\n$$\n该值将作为缩减因子 $\\rho_{1}$ 的分母。\n\n**第二次迭代 ($k=1$) - 修正牛顿法**\n\n对于修正牛顿法，我们使用冻结的切线矩阵 $\\boldsymbol{K}_{0}$。我们求解 $\\boldsymbol{K}_{0} \\Delta \\boldsymbol{u}_{1} = -\\boldsymbol{R}(\\boldsymbol{u}_{1})$。\n$$\n\\Delta \\boldsymbol{u}_{1} = -\\boldsymbol{K}_{0}^{-1} \\boldsymbol{R}(\\boldsymbol{u}_{1}) = -\\begin{pmatrix} 0.5 & 0 \\\\ 0.1 & \\frac{2}{3} \\end{pmatrix} \\begin{pmatrix} 0.23184 \\\\ 0.1237248 \\end{pmatrix} = -\\begin{pmatrix} 0.5(0.23184) \\\\ 0.1(0.23184) + \\frac{2}{3}(0.1237248) \\end{pmatrix} = -\\begin{pmatrix} 0.11592 \\\\ 0.023184 + 0.0824832 \\end{pmatrix} = \\begin{pmatrix} -0.11592 \\\\ -0.1056672 \\end{pmatrix}\n$$\n第二个更新后的位移向量为：\n$$\n\\boldsymbol{u}_{2} = \\boldsymbol{u}_{1} + \\Delta \\boldsymbol{u}_{1} = \\begin{pmatrix} 0.6 \\\\ 0.72 \\end{pmatrix} + \\begin{pmatrix} -0.11592 \\\\ -0.1056672 \\end{pmatrix} = \\begin{pmatrix} 0.48408 \\\\ 0.6143328 \\end{pmatrix}\n$$\n现在我们计算在 $\\boldsymbol{u}_{2}$ 处的残差：\n$$\nR_{1}(\\boldsymbol{u}_{2}) = 2(0.48408) + \\frac{1}{2}(0.48408)^{2} + 0.1(0.6143328)^{2} - 1.2\n$$\n$$\nR_{1}(\\boldsymbol{u}_{2}) = 0.96816 + 0.5(0.2343334464) + 0.1(0.3774048590378304) - 1.2 = 0.96816 + 0.1171667232 + 0.0377404859 - 1.2 \\approx -0.0769327909\n$$\n$$\nR_{2}(\\boldsymbol{u}_{2}) = -0.3(0.48408) + 1.5(0.6143328) + 0.2(0.48408)(0.6143328) + 0.1(0.6143328)^{3} - 0.9\n$$\n$$\nR_{2}(\\boldsymbol{u}_{2}) = -0.145224 + 0.9214992 + 0.2(0.297440535936) + 0.1(0.231846067341235...) - 0.9 \\approx -0.145224 + 0.9214992 + 0.0594881072 + 0.0231846067 - 0.9 \\approx -0.0410520861\n$$\n残差向量为 $\\boldsymbol{R}(\\boldsymbol{u}_{2}) \\approx \\begin{pmatrix} -0.07693279 \\\\ -0.04105209 \\end{pmatrix}$。其范数为：\n$$\n\\|\\boldsymbol{R}(\\boldsymbol{u}_{2})\\|_{2} \\approx \\sqrt{(-0.07693279)^{2} + (-0.04105209)^{2}} = \\sqrt{0.0059186546 + 0.0016852731} = \\sqrt{0.0076039277} \\approx 0.0872005029\n$$\n最后，第二次迭代 ($k=1$) 的残差缩减因子定义为：\n$$\n\\rho_{1} = \\frac{\\|\\boldsymbol{R}(\\boldsymbol{u}_{2})\\|_{2}}{\\|\\boldsymbol{R}(\\boldsymbol{u}_{1})\\|_{2}} \\approx \\frac{0.0872005029}{0.2627885994} \\approx 0.33182046\n$$\n四舍五入到四位有效数字，我们得到 $0.3318$。", "answer": "$$ \\boxed{0.3318} $$", "id": "2580609"}, {"introduction": "在近似切线矩阵概念的基础上，本练习将深入探讨著名的Broyden-Fletcher-Goldfarb-Shanno (BFGS) 更新的内部机理。您将通过在连续迭代中应用BFGS公式，手动构建一个Hessian矩阵的近似。此练习的关键学习目标是理解如何利用先前步骤的正割信息来改进刚度矩阵，并通过比较最终的准牛顿搜索方向与精确的牛顿方向，来量化评估此近似的质量。", "problem": "考虑一个由总势能驻定原理导出的双自由度非线性有限元系统。设总势能为\n$$\n\\Pi(u_1,u_2) \\;=\\; u_1^2 + u_2^2 + u_1 u_2 + u_1^3 + u_2^3 + \\frac{1}{2} u_1^2 u_2 \\;-\\; f_1 u_1 \\;-\\; f_2 u_2,\n$$\n其载荷向量分量指定为 $f_1 = 1$ 和 $f_2 = 1$。残差（内力减去外力）是 $\\Pi$ 的梯度，即 $r(u) = \\nabla \\Pi(u)$，一致切线（雅可比矩阵）是其海森矩阵 $K(u) = \\nabla^2 \\Pi(u)$。\n\n给定三个试位移状态\n$$\nu_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\quad\nu_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad\nu_2 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n定义 $s_k = u_{k+1} - u_k$ 和 $y_k = r(u_{k+1}) - r(u_k)$。从初始对称正定近似 $B_0 = \\gamma I$（其中 $\\gamma = 2$）开始，使用 $(s_0,y_0)$ 和 $(s_1,y_1)$ 对，对海森矩阵近似执行两次连续的 Broyden-Fletcher-Goldfarb-Shanno (BFGS) 更新，以获得 $B_2$。\n\n在状态 $u_2$ 处，构建：\n- 拟牛顿预测步 $s_{\\mathrm{QN}} = -B_2^{-1} r(u_2)$，\n- 精确牛顿步 $s_{\\mathrm{N}} = -K(u_2)^{-1} r(u_2)$。\n\n计算差值 $\\| s_{\\mathrm{QN}} - s_{\\mathrm{N}} \\|_2$ 的欧几里得范数。将您的最终答案以单个实数的形式给出，四舍五入到四位有效数字。无需单位。", "solution": "首先，我们将载荷 $f_1 = 1$ 和 $f_2 = 1$ 代入势能泛函中：\n$$\n\\Pi(u_1, u_2) = u_1^2 + u_2^2 + u_1 u_2 + u_1^3 + u_2^3 + \\frac{1}{2} u_1^2 u_2 - u_1 - u_2\n$$\n残差向量 $r(u)$ 是 $\\Pi(u)$ 的梯度：\n$$\nr(u) = \\nabla \\Pi(u) = \\begin{pmatrix} \\frac{\\partial \\Pi}{\\partial u_1} \\\\ \\frac{\\partial \\Pi}{\\partial u_2} \\end{pmatrix} = \\begin{pmatrix} 2u_1 + u_2 + 3u_1^2 + u_1 u_2 - 1 \\\\ 2u_2 + u_1 + 3u_2^2 + \\frac{1}{2}u_1^2 - 1 \\end{pmatrix}\n$$\n切线刚度矩阵 $K(u)$ 是 $\\Pi(u)$ 的海森矩阵：\n$$\nK(u) = \\nabla^2 \\Pi(u) = \\begin{pmatrix} \\frac{\\partial^2 \\Pi}{\\partial u_1^2} & \\frac{\\partial^2 \\Pi}{\\partial u_1 \\partial u_2} \\\\ \\frac{\\partial^2 \\Pi}{\\partial u_2 \\partial u_1} & \\frac{\\partial^2 \\Pi}{\\partial u_2^2} \\end{pmatrix} = \\begin{pmatrix} 2 + 6u_1 + u_2 & 1 + u_1 \\\\ 1 + u_1 & 2 + 6u_2 \\end{pmatrix}\n$$\n海森矩阵近似 $B$ 的 BFGS 更新公式为：\n$$\nB_{k+1} = B_k - \\frac{B_k s_k s_k^T B_k}{s_k^T B_k s_k} + \\frac{y_k y_k^T}{y_k^T s_k}\n$$\n我们从 $B_0 = 2I = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix}$ 开始。\n\n**第一次 BFGS 更新：**\n我们计算向量 $s_0$ 和 $y_0$。\n$u_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，$u_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n$$\ns_0 = u_1 - u_0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\n我们计算在 $u_0$ 和 $u_1$ 处的残差：\n$$\nr(u_0) = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}\n$$\n$$\nr(u_1) = \\begin{pmatrix} 2(1) + 0 + 3(1)^2 + (1)(0) - 1 \\\\ 2(0) + 1 + 3(0)^2 + \\frac{1}{2}(1)^2 - 1 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 0.5 \\end{pmatrix}\n$$\n因此，$y_0$ 为：\n$$\ny_0 = r(u_1) - r(u_0) = \\begin{pmatrix} 4 \\\\ 0.5 \\end{pmatrix} - \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 5 \\\\ 1.5 \\end{pmatrix}\n$$\n现在我们计算更新所需的各项：\n$y_0^T s_0 = \\begin{pmatrix} 5 & 1.5 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 5$。\n$B_0 s_0 = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix}$。\n$s_0^T B_0 s_0 = \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} = 2$。\n更新项为：\n$$\n\\frac{B_0 s_0 s_0^T B_0}{s_0^T B_0 s_0} = \\frac{1}{2} \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 2 & 0 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 0 \\end{pmatrix}\n$$\n$$\n\\frac{y_0 y_0^T}{y_0^T s_0} = \\frac{1}{5} \\begin{pmatrix} 5 \\\\ 1.5 \\end{pmatrix} \\begin{pmatrix} 5 & 1.5 \\end{pmatrix} = \\frac{1}{5} \\begin{pmatrix} 25 & 7.5 \\\\ 7.5 & 2.25 \\end{pmatrix} = \\begin{pmatrix} 5 & 1.5 \\\\ 1.5 & 0.45 \\end{pmatrix}\n$$\n所以，$B_1$ 是：\n$$\nB_1 = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} - \\begin{pmatrix} 2 & 0 \\\\ 0 & 0 \\end{pmatrix} + \\begin{pmatrix} 5 & 1.5 \\\\ 1.5 & 0.45 \\end{pmatrix} = \\begin{pmatrix} 5 & 1.5 \\\\ 1.5 & 2.45 \\end{pmatrix}\n$$\n\n**第二次 BFGS 更新：**\n我们计算 $s_1$ 和 $y_1$。\n$u_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，$u_2 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n$$\ns_1 = u_2 - u_1 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n我们计算在 $u_2$ 处的残差：\n$$\nr(u_2) = \\begin{pmatrix} 2(1) + 1 + 3(1)^2 + (1)(1) - 1 \\\\ 2(1) + 1 + 3(1)^2 + \\frac{1}{2}(1)^2 - 1 \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 5.5 \\end{pmatrix}\n$$\n因此，$y_1$ 为：\n$$\ny_1 = r(u_2) - r(u_1) = \\begin{pmatrix} 6 \\\\ 5.5 \\end{pmatrix} - \\begin{pmatrix} 4 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 5 \\end{pmatrix}\n$$\n现在我们用 $B_1$ 计算更新所需的各项：\n$y_1^T s_1 = \\begin{pmatrix} 2 & 5 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 5$。\n$B_1 s_1 = \\begin{pmatrix} 5 & 1.5 \\\\ 1.5 & 2.45 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1.5 \\\\ 2.45 \\end{pmatrix}$。\n$s_1^T B_1 s_1 = \\begin{pmatrix} 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1.5 \\\\ 2.45 \\end{pmatrix} = 2.45$。\n更新项为：\n$$\n\\frac{B_1 s_1 s_1^T B_1}{s_1^T B_1 s_1} = \\frac{1}{2.45} \\begin{pmatrix} 1.5 \\\\ 2.45 \\end{pmatrix} \\begin{pmatrix} 1.5 & 2.45 \\end{pmatrix} = \\frac{1}{2.45} \\begin{pmatrix} 2.25 & 3.675 \\\\ 3.675 & 6.0025 \\end{pmatrix} = \\begin{pmatrix} 45/49 & 1.5 \\\\ 1.5 & 2.45 \\end{pmatrix}\n$$\n$$\n\\frac{y_1 y_1^T}{y_1^T s_1} = \\frac{1}{5} \\begin{pmatrix} 2 \\\\ 5 \\end{pmatrix} \\begin{pmatrix} 2 & 5 \\end{pmatrix} = \\begin{pmatrix} 0.8 & 2 \\\\ 2 & 5 \\end{pmatrix}\n$$\n所以，$B_2$ 是：\n$$\nB_2 = \\begin{pmatrix} 5 & 1.5 \\\\ 1.5 & 2.45 \\end{pmatrix} - \\begin{pmatrix} 45/49 & 1.5 \\\\ 1.5 & 2.45 \\end{pmatrix} + \\begin{pmatrix} 0.8 & 2 \\\\ 2 & 5 \\end{pmatrix} = \\begin{pmatrix} 5 - 45/49 + 0.8 & 2 \\\\ 2 & 5 \\end{pmatrix}\n$$\n(1,1) 分量是 $5 - \\frac{45}{49} + \\frac{4}{5} = \\frac{1225 - 225 + 196}{245} = \\frac{1196}{245}$。\n所以，$B_2 = \\begin{pmatrix} 1196/245 & 2 \\\\ 2 & 5 \\end{pmatrix}$。\n\n**计算拟牛顿步 $s_{\\mathrm{QN}}$：**\n$s_{\\mathrm{QN}} = -B_2^{-1} r(u_2)$。\n$\\det(B_2) = (\\frac{1196}{245})(5) - (2)(2) = \\frac{5980}{245} - 4 = \\frac{5980 - 980}{245} = \\frac{5000}{245} = \\frac{1000}{49}$。\n$$\nB_2^{-1} = \\frac{49}{1000} \\begin{pmatrix} 5 & -2 \\\\ -2 & 1196/245 \\end{pmatrix} = \\frac{1}{1000} \\begin{pmatrix} 245 & -98 \\\\ -98 & 1196/5 \\end{pmatrix} = \\begin{pmatrix} 0.245 & -0.098 \\\\ -0.098 & 0.2392 \\end{pmatrix}\n$$\n使用 $r(u_2) = \\begin{pmatrix} 6 \\\\ 5.5 \\end{pmatrix}$：\n$$\ns_{\\mathrm{QN}} = - \\begin{pmatrix} 0.245 & -0.098 \\\\ -0.098 & 0.2392 \\end{pmatrix} \\begin{pmatrix} 6 \\\\ 5.5 \\end{pmatrix} = - \\begin{pmatrix} 1.47 - 0.539 \\\\ -0.588 + 1.3156 \\end{pmatrix} = - \\begin{pmatrix} 0.931 \\\\ 0.7276 \\end{pmatrix} = \\begin{pmatrix} -0.931 \\\\ -0.7276 \\end{pmatrix}\n$$\n\n**计算精确牛顿步 $s_{\\mathrm{N}}$：**\n$s_{\\mathrm{N}} = -K(u_2)^{-1} r(u_2)$。\n首先，计算在 $u_2=\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 处的 $K(u_2)$：\n$$\nK(u_2) = \\begin{pmatrix} 2 + 6(1) + 1 & 1 + 1 \\\\ 1 + 1 & 2 + 6(1) \\end{pmatrix} = \\begin{pmatrix} 9 & 2 \\\\ 2 & 8 \\end{pmatrix}\n$$\n$\\det(K(u_2)) = (9)(8) - (2)(2) = 72-4 = 68$.\n$$\nK(u_2)^{-1} = \\frac{1}{68} \\begin{pmatrix} 8 & -2 \\\\ -2 & 9 \\end{pmatrix}\n$$\n$$\ns_{\\mathrm{N}} = - \\frac{1}{68} \\begin{pmatrix} 8 & -2 \\\\ -2 & 9 \\end{pmatrix} \\begin{pmatrix} 6 \\\\ 5.5 \\end{pmatrix} = -\\frac{1}{68} \\begin{pmatrix} 8(6) - 2(5.5) \\\\ -2(6) + 9(5.5) \\end{pmatrix} = -\\frac{1}{68} \\begin{pmatrix} 48 - 11 \\\\ -12 + 49.5 \\end{pmatrix} = -\\frac{1}{68} \\begin{pmatrix} 37 \\\\ 37.5 \\end{pmatrix} = \\begin{pmatrix} -37/68 \\\\ -75/136 \\end{pmatrix}\n$$\n\n**计算差值的范数：**\n令 $d = s_{\\mathrm{QN}} - s_{\\mathrm{N}}$。\n$$\nd = \\begin{pmatrix} -0.931 \\\\ -0.7276 \\end{pmatrix} - \\begin{pmatrix} -37/68 \\\\ -75/136 \\end{pmatrix} = \\begin{pmatrix} -0.931 + 37/68 \\\\ -0.7276 + 75/136 \\end{pmatrix}\n$$\n计算向量分量：\n$$\nd_1 = -0.931 + 0.5441176... = -0.3868823...\n$$\n$$\nd_2 = -0.7276 + 0.5514705... = -0.1761294...\n$$\n现在我们计算欧几里得范数 $\\|d\\|_2$：\n$$\n\\|d\\|_2 = \\sqrt{d_1^2 + d_2^2} = \\sqrt{(-0.3868823...)^2 + (-0.1761294...)^2}\n$$\n$$\n\\|d\\|_2 = \\sqrt{0.1496778... + 0.0310214...} = \\sqrt{0.1806992...} = 0.4250873...\n$$\n四舍五入到四位有效数字，结果是 $0.4251$。", "answer": "$$\\boxed{0.4251}$$", "id": "2580619"}, {"introduction": "最后一个实践练习将理论与实际应用联系起来，重点关注大规模有限元分析中的核心算法——限制内存BFGS (L-BFGS) 算法。本练习要求您实现著名的“双循环递归”，这是一种无矩阵方法，它避免了构造和存储稠密的Hessian近似所带来的巨大计算成本。通过编写此算法并将其应用于非线性有限元问题，您将亲身体验到准牛顿方法在现代工程软件中不可或缺的计算精妙性和高效性。", "problem": "考虑一个标量场 $u(x)$ 在区间 $[0,1]$ 上的一维有限元 (FE) 模型的非线性残差，其边界条件为齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。其强形式为一个非线性扩散方程\n$$-\\frac{d}{dx}\\Big((1+u(x)^2)\\frac{du}{dx}\\Big) - f(x) = 0.$$\n其弱 (变分) 形式为，寻找 $u \\in H_0^1(0,1)$，使得对于所有容许的检验函数 $v$，\n$$\\int_0^1 (1+u^2)\\, u' \\, v' \\, dx - \\int_0^1 f \\, v \\, dx = 0.$$\n使用线性形函数在 $[0,1]$ 上的一个含 $N_e$ 个单元（以及 $N_n=N_e+1$ 个节点）的均匀网格上对问题进行离散化。未知量向量包含 $N_n-2$ 个内部自由度，记为向量 $\\mathbf{u}\\in\\mathbb{R}^{N_n-2}$；包含边界节点的完整向量记为 $\\tilde{\\mathbf{u}}\\in\\mathbb{R}^{N_n}$，其中 $\\tilde{u}_0=\\tilde{u}_{N_n-1}=0$，并且对于 $i\\in\\{1,\\dots,N_n-2\\}$ 有 $\\tilde{u}_i=\\mathbf{u}_{i-1}$。在参考单元 $[-1,1]$ 上使用点为 $\\xi=\\pm 1/\\sqrt{3}$、权重为 $w=1$ 的两点高斯积分法则，以及到每个尺寸为 $h=1/N_e$、雅可比行列式为 $J=h/2$ 的物理单元的仿射映射，通过对单元贡献求和来组装离散非线性残差 $\\mathbf{R}(\\mathbf{u})\\in\\mathbb{R}^{N_n-2}$\n$$r_e^{(j)} \\approx \\sum_{g=1}^{2}\\Big( a(u(\\xi_g))\\, u'(x)\\, \\frac{dN_j}{dx}\\, J - f(x(\\xi_g))\\, N_j(\\xi_g)\\, J\\Big), \\quad j\\in\\{1,2\\},$$\n其中 $a(u)=1+u^2$，$N_j$ 是参考单元上的线性形函数，$dN_j/dx$ 是它们的物理导数，在每个单元上都是常数。单元贡献被散布到对应内部索引处的全局内部残差中（跳过 Dirichlet 边界节点）。\n\n您需要实现单步有限内存 Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) 算法来计算拟牛顿搜索方向 $\\mathbf{p}_k$，而无需构建任何雅可比矩阵或海森矩阵。给定当前残差（其作用相当于梯度）$\\mathbf{g}_k=\\mathbf{R}(\\mathbf{u}_k)$，以及 $m$ 个历史向量对 $\\{(\\mathbf{s}_i,\\mathbf{y}_i)\\}_{i=k-m}^{k-1}$，其中 $\\mathbf{s}_i=\\mathbf{u}_{i+1}-\\mathbf{u}_i$ 且 $\\mathbf{y}_i=\\mathbf{g}_{i+1}-\\mathbf{g}_i$，使用双循环递归计算 L-BFGS 方向 $\\mathbf{p}_k=-\\mathbf{H}_k \\mathbf{g}_k$。初始逆海森矩阵缩放 $\\gamma_k$ 应用为 $\\mathbf{H}_0=\\gamma_k \\mathbf{I}$，并使用曲率保护，舍弃任何满足 $\\mathbf{s}_i^\\top \\mathbf{y}_i \\le \\tau$ 的向量对，其中 $\\tau>0$ 是一个指定的容差。除了单位矩阵缩放的向量外，不得构建任何矩阵；仅使用向量内积、saxpy 操作和缩放。\n\n您的程序必须实现：\n- 针对给定的 $\\mathbf{u}$ 和源项 $f(x)$，如上所述组装 $\\mathbf{R}(\\mathbf{u})$。\n- L-BFGS 双循环递归，用于从 $\\mathbf{g}_k$、$\\{(\\mathbf{s}_i,\\mathbf{y}_i)\\}$ 和 $\\gamma_k$ 计算 $\\mathbf{p}_k$，而不构建任何雅可比矩阵或海森矩阵。\n- 使用容差 $\\tau$ 的曲率检查，舍弃任何满足 $\\mathbf{s}_i^\\top \\mathbf{y}_i \\le \\tau$ 的 $(\\mathbf{s}_i,\\mathbf{y}_i)$。剩余的向量对必须按时间顺序使用。\n\n测试套件：\n使用以下确定性测试套件来测试实现的不同方面。在所有测试中，设置 $f(x)=10\\sin(2\\pi x)$，$N_e=16$，因此 $h=1/16$，内部未知数的数量为 $N_n-2=15$。使用固定的随机种子生成可复现的向量。\n\n- 所有测试的通用设置：\n  - 使用种子为 $12345$ 的伪随机数生成器来生成向量。\n  - 设 $\\mathbf{u}_0$ 从一个按 $0.1$ 缩放的标准正态分布中逐分量抽取。\n  - 设 $\\mathbf{s}_0$ 和 $\\mathbf{s}_1$ 从一个按 $10^{-2}$ 缩放的标准正态分布中逐分量抽取。\n  - 定义 $\\mathbf{u}_1=\\mathbf{u}_0+\\mathbf{s}_0$，$\\mathbf{u}_2=\\mathbf{u}_1+\\mathbf{s}_1$。\n  - 计算残差 $\\mathbf{g}_0=\\mathbf{R}(\\mathbf{u}_0)$、$\\mathbf{g}_1=\\mathbf{R}(\\mathbf{u}_1)$ 和 $\\mathbf{g}_2=\\mathbf{R}(\\mathbf{u}_2)$。\n  - 定义历史对 $(\\mathbf{s}_0,\\mathbf{y}_0)$，其中 $\\mathbf{y}_0=\\mathbf{g}_1-\\mathbf{g}_0$；以及 $(\\mathbf{s}_1,\\mathbf{y}_1)$，其中 $\\mathbf{y}_1=\\mathbf{g}_2-\\mathbf{g}_1$。\n\n- 测试 $1$（边界情况 $m=0$）：不使用历史对（即 $m=0$），设置 $\\gamma_k=1$。仅使用 $\\mathbf{g}_2$ 为当前状态 $\\mathbf{u}_2$ 计算 $\\mathbf{p}_2$。以浮点数形式报告欧几里得范数 $\\|\\mathbf{p}_2+\\mathbf{g}_2\\|_2$。\n\n- 测试 $2$（理想路径 $m=2$）：使用满足曲率条件的两个历史对 $\\{(\\mathbf{s}_0,\\mathbf{y}_0),(\\mathbf{s}_1,\\mathbf{y}_1)\\}$。将初始缩放设置为常用选择 $\\gamma_k = (\\mathbf{s}_{1}^\\top \\mathbf{y}_{1})/(\\mathbf{y}_{1}^\\top \\mathbf{y}_{1})$。计算 $\\mathbf{p}_2$ 并以浮点数形式报告标量 $\\mathbf{g}_2^\\top \\mathbf{p}_2$。\n\n- 测试 $3$（近奇异历史的边缘情况）：将第一个对替换为 $(\\mathbf{s}_0,\\hat{\\mathbf{y}}_0)$，其中 $\\hat{\\mathbf{y}}_0=\\epsilon\\, \\mathbf{s}_0$ 且 $\\epsilon=10^{-12}$，以模拟一个近奇异的割线对，保持第二个对 $(\\mathbf{s}_1,\\mathbf{y}_1)$ 不变，并设置 $\\tau=10^{-10}$。使用曲率保护，计算 $\\mathbf{p}_2$，并报告定义如下的下降指示整数\n$$d = \\begin{cases}\n1 & \\text{if } \\mathbf{g}_2^\\top \\mathbf{p}_2 < 0,\\\\\n0 & \\text{otherwise.}\n\\end{cases}$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 1、2 和 3 的结果，格式为包含在方括号中的逗号分隔列表，顺序为 $[\\text{测试 1 结果}, \\text{测试 2 结果}, \\text{测试 3 结果}]$。例如，输出必须具有 $[\\text{float},\\text{float},\\text{integer}]$ 的形式。无需单位；所有量均为指定的无量纲实数或整数。", "solution": "任务是使用有限内存 Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) 算法计算一个拟牛顿搜索方向。这需要两个主要部分：首先，组装离散的非线性残差向量，在优化背景下它充当梯度；其次，实现 L-BFGS 的双循环递归。\n\n### 1. 有限元残差组装\n\n控制非线性扩散方程为\n$$-\\frac{d}{dx}\\left( \\left(1+u(x)^2\\right)\\frac{du}{dx} \\right) - f(x) = 0, \\quad x \\in (0,1)$$\n具有齐次 Dirichlet 边界条件 $u(0)=u(1)=0$。其对应的弱形式是找到 $u \\in H_0^1(0,1)$，使得对于所有检验函数 $v \\in H_0^1(0,1)$：\n$$ \\int_0^1 (1+u^2) u' v' \\,dx - \\int_0^1 f v \\,dx = 0 $$\n区域 $[0,1]$ 被离散化为 $N_e$ 个长度为 $h=1/N_e$ 的均匀单元。我们对试探函数 $u_h(x) = \\sum_{i=1}^{N_n-2} \\mathbf{u}_{i-1} \\phi_i(x)$ 和检验函数 $v_h(x) = \\phi_j(x)$ 都使用线性拉格朗日基函数（帽函数），记为 $\\phi_i(x)$。向量 $\\mathbf{u} \\in \\mathbb{R}^{N_n-2}$ 表示在 $N_n-2$ 个内部节点上的未知解值。\n\n非线性残差向量 $\\mathbf{R}(\\mathbf{u}) \\in \\mathbb{R}^{N_n-2}$ 的第 $j$ 个分量由下式给出\n$$ R_j(\\mathbf{u}) = \\int_0^1 (1+u_h^2) u_h' \\phi_j' \\,dx - \\int_0^1 f \\phi_j \\,dx $$\n该积分通过对每个单元的贡献求和来计算。对于一个单元 $e = [x_i, x_{i+1}]$，在其两个局部节点上对残差的贡献是通过在参考单元 $[-1,1]$ 上使用两点高斯积分来计算的。\n\n让我们考虑单个单元 $e$。此单元内的解 $u_h(x)$ 及其导数 $u_h'(x)$ 为\n$$ u_h(x(\\xi)) = \\tilde{u}_i N_1(\\xi) + \\tilde{u}_{i+1} N_2(\\xi) $$\n$$ u_h'(x) = \\frac{\\tilde{u}_{i+1} - \\tilde{u}_i}{h} $$\n其中 $\\tilde{\\mathbf{u}}$ 是包含边界的完整节点向量，$\\xi \\in [-1,1]$ 是参考单元上的坐标，而 $N_1(\\xi)=\\frac{1-\\xi}{2}$ 和 $N_2(\\xi)=\\frac{1+\\xi}{2}$ 是线性形函数。基函数在物理坐标下的导数在单元上是常数：$\\phi_i'(x) = -1/h$ 和 $\\phi_{i+1}'(x)=1/h$。\n\n单元残差向量 $\\mathbf{r}_e \\in \\mathbb{R}^2$ 按规定计算：\n$$ r_{e}^{(j)} = \\int_{x_i}^{x_{i+1}} \\left( (1+u_h^2)u_h' \\phi'_{i+j-1} - f \\phi_{i+j-1} \\right) dx $$\n使用高斯积分，其点为 $\\xi_g=\\pm 1/\\sqrt{3}$，权重为 $w_g=1$，雅可比行列式为 $J=h/2$，上式变为：\n$$ r_{e}^{(j)} \\approx \\sum_{g=1}^{2} \\left[ \\left(1+u_h(x(\\xi_g))^2\\right) \\left(\\frac{\\tilde{u}_{i+1} - \\tilde{u}_i}{h}\\right) \\frac{dN_j}{dx} - f(x(\\xi_g)) N_j(\\xi_g) \\right] J $$\n其中 $\\frac{dN_1}{dx} = -1/h$ 和 $\\frac{dN_2}{dx} = 1/h$。\n\n全局残差向量 $\\mathbf{R}(\\mathbf{u})$ 是通过组装这些单元贡献形成的。对于一个内部节点 $k$，其残差分量 $R_{k-1}$ 接收来自单元 $k-1$ 的第二个贡献 $r^{(2)}$ 和来自单元 $k$ 的第一个贡献 $r^{(1)}$。\n\n### 2. L-BFGS 双循环递归\n\nL-BFGS 算法提供了一种无矩阵方法来计算搜索方向 $\\mathbf{p}_k = -\\mathbf{H}_k \\mathbf{g}_k$，其中 $\\mathbf{H}_k$ 是目标函数逆海森矩阵的近似。梯度 $\\mathbf{g}_k$ 就是我们的残差向量 $\\mathbf{R}(\\mathbf{u}_k)$。该算法使用 $m$ 个过去更新的有限历史记录，存储为向量对 $(\\mathbf{s}_i, \\mathbf{y}_i)$，其中 $\\mathbf{s}_i = \\mathbf{u}_{i+1} - \\mathbf{u}_i$ 是变量的步长，$\\mathbf{y}_i = \\mathbf{g}_{i+1} - \\mathbf{g}_i$ 是梯度的变化。\n\n计算通过众所周知的双循环递归进行：\n1.  初始化 $\\mathbf{q} = \\mathbf{g}_k$。\n2.  **第一循环**（反向传递）：对于 $i$ 从 $k-1$ 向下到 $k-m$：\n    -   计算 $\\rho_i = 1 / (\\mathbf{y}_i^\\top \\mathbf{s}_i)$。\n    -   计算 $\\alpha_i = \\rho_i (\\mathbf{s}_i^\\top \\mathbf{q})$。\n    -   更新 $\\mathbf{q} \\leftarrow \\mathbf{q} - \\alpha_i \\mathbf{y}_i$。\n3.  **缩放**：应用初始逆海森矩阵近似。这是一个对角矩阵 $\\mathbf{H}_0 = \\gamma_k \\mathbf{I}$。\n    -   $\\mathbf{p} \\leftarrow \\gamma_k \\mathbf{q}$。\n4.  **第二循环**（正向传递）：对于 $i$ 从 $k-m$ 到 $k-1$：\n    -   从第一循环中检索 $\\rho_i$ 和 $\\alpha_i$。\n    -   计算 $\\beta = \\rho_i (\\mathbf{y}_i^\\top \\mathbf{p})$。\n    -   更新 $\\mathbf{p} \\leftarrow \\mathbf{p} + (\\alpha_i - \\beta) \\mathbf{s}_i$。\n5.  最终的搜索方向为 $\\mathbf{p}_k = -\\mathbf{p}$。\n\nBFGS 更新的一个关键稳定性要求是曲率条件 $\\mathbf{s}_i^\\top \\mathbf{y}_i > 0$。问题强制要求一个保护措施：对于任何满足 $\\mathbf{s}_i^\\top \\mathbf{y}_i \\le \\tau$（其中 $\\tau > 0$ 是给定的容差）的向量对 $(\\mathbf{s}_i, \\mathbf{y}_i)$，在执行递归之前将其从历史记录中丢弃。\n\n### 3. 测试用例执行\n\n提供的测试套件按如下方式执行：\n\n-   **通用设置**：使用指定的随机种子生成向量 $\\mathbf{u}_0, \\mathbf{s}_0, \\mathbf{s}_1$。计算 $\\mathbf{u}_1, \\mathbf{u}_2$。使用有限元函数组装相应的残差 $\\mathbf{g}_0, \\mathbf{g}_1, \\mathbf{g}_2$。形成历史对 $(\\mathbf{s}_0, \\mathbf{y}_0=\\mathbf{g}_1-\\mathbf{g}_0)$ 和 $(\\mathbf{s}_1, \\mathbf{y}_1=\\mathbf{g}_2-\\mathbf{g}_1)$。\n\n-   **测试1**：当 $m=0$ 时，历史记录为空。双循环递归显著简化。第一和第二循环不执行。计算简化为 $\\mathbf{p} \\leftarrow \\gamma_k \\mathbf{g}_k$，最终为 $\\mathbf{p}_k = -\\gamma_k \\mathbf{g}_k$。当 $\\gamma_k=1$ 时，我们得到 $\\mathbf{p}_k = -\\mathbf{g}_k$，这是最速下降方向。量 $\\|\\mathbf{p}_2 + \\mathbf{g}_2\\|_2$ 的计算结果应为零，在机器精度范围内。\n\n-   **测试2**：当 $m=2$ 时，使用完整的历史记录 $\\{(\\mathbf{s}_0, \\mathbf{y}_0), (\\mathbf{s}_1, \\mathbf{y}_1)\\}$。初始缩放选择为 $\\gamma_k = (\\mathbf{s}_{k-1}^\\top \\mathbf{y}_{k-1}) / (\\mathbf{y}_{k-1}^\\top \\mathbf{y}_{k-1}) = (\\mathbf{s}_1^\\top \\mathbf{y}_1) / (\\mathbf{y}_1^\\top \\mathbf{y}_1)$。完整执行双循环递归以找到 $\\mathbf{p}_2$。要报告的结果是内积 $\\mathbf{g}_2^\\top \\mathbf{p}_2$，该值必须为负，以确认 $\\mathbf{p}_2$ 是一个下降方向。\n\n-   **测试3**：修改历史记录：构造一对近奇异的向量对 $(\\mathbf{s}_0, \\hat{\\mathbf{y}}_0)$，其中 $\\hat{\\mathbf{y}}_0 = \\epsilon \\mathbf{s}_0$。曲率检查 $\\mathbf{s}_0^\\top \\hat{\\mathbf{y}}_0 = \\epsilon \\|\\mathbf{s}_0\\|^2_2 \\le \\tau=10^{-10}$ 将导致该对被丢弃。计算使用剩余的有效历史记录继续进行，该历史记录仅包含 $(\\mathbf{s}_1, \\mathbf{y}_1)$。缩放因子 $\\gamma_k$ 使用这个最近的有效对来计算，如测试2中所示。执行 $m=1$ 的 L-BFGS 递归，$\\mathbf{g}_2^\\top \\mathbf{p}_2$ 的符号决定了整数输出。\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing FEM residual assembly and L-BFGS,\n    then running the specified test cases.\n    \"\"\"\n\n    # ------------------\n    # UTILITY FUNCTIONS\n    # ------------------\n\n    def assemble_residual(u_interior, f_func, Ne):\n        \"\"\"\n        Assembles the nonlinear FE residual vector R(u).\n        \"\"\"\n        h = 1.0 / Ne\n        num_dofs = Ne - 1\n        \n        # Prepend and append boundary conditions (u=0)\n        u_full = np.concatenate(([0.0], u_interior, [0.0]))\n        \n        R = np.zeros(num_dofs)\n        \n        # Gaussian quadrature points and weights (for reference element [-1, 1])\n        # Points are +/- 1/sqrt(3), weights are 1.\n        xi_gp = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\n        \n        Jacobian = h / 2.0\n        \n        for e in range(Ne):\n            # Element node indices\n            node_i, node_j = e, e + 1\n            \n            # Nodal values for the element\n            u_element = u_full[node_i : node_j + 1]\n            \n            # Element residual vector\n            r_element = np.zeros(2)\n            \n            # Constant gradient over the linear element\n            u_grad_e = (u_element[1] - u_element[0]) / h\n            \n            # Derivatives of shape functions w.r.t physical coordinate x\n            dN_dx = np.array([-1.0 / h, 1.0 / h])\n            \n            # Loop over Gauss points\n            for xi in xi_gp:\n                # Shape functions on reference element\n                N_vals = np.array([(1.0 - xi) / 2.0, (1.0 + xi) / 2.0])\n                \n                # Interpolate u at the Gauss point\n                u_at_gp = np.dot(N_vals, u_element)\n                \n                # Nonlinear coefficient a(u) = 1 + u^2\n                a_u = 1.0 + u_at_gp**2\n                \n                # Map Gauss point to physical coordinate\n                x_nodes = np.array([e * h, (e + 1) * h])\n                x_at_gp = np.dot(N_vals, x_nodes)\n                \n                # Evaluate source term at the Gauss point\n                f_at_gp = f_func(x_at_gp)\n                \n                # Accumulate element residual contribution (weight is 1)\n                stiffness_term = a_u * u_grad_e * dN_dx\n                load_term = f_at_gp * N_vals\n                r_element += (stiffness_term - load_term) * Jacobian\n\n            # Assemble element residual into global residual vector\n            # r_element[0] corresponds to global node `e`\n            # r_element[1] corresponds to global node `e+1`\n            # DOF indices are shifted by -1 from global node indices\n            if e > 0:\n                R[e - 1] += r_element[0]\n            if e  Ne - 1:\n                R[e] += r_element[1]\n                \n        return R\n\n    def lbfgs_direction(g_k, history, gamma_k):\n        \"\"\"\n        Computes the L-BFGS search direction using the two-loop recursion.\n        \"\"\"\n        q = g_k.copy()\n        alphas = []\n        rhos = []\n        \n        # First loop: backward pass from k-1 to k-m\n        for s, y in reversed(history):\n            rho = 1.0 / np.dot(y, s)\n            rhos.insert(0, rho)\n            alpha = rho * np.dot(s, q)\n            alphas.insert(0, alpha)\n            q -= alpha * y\n        \n        # Initial Hessian approximation scaling\n        r = gamma_k * q\n        \n        # Second loop: forward pass from k-m to k-1\n        for i, (s, y) in enumerate(history):\n            rho = rhos[i]\n            alpha = alphas[i]\n            beta = rho * np.dot(y, r)\n            r += s * (alpha - beta)\n            \n        return -r\n\n    # ------------------\n    # PROBLEM SETUP\n    # ------------------\n    Ne = 16\n    f_source = lambda x: 10.0 * np.sin(2.0 * np.pi * x)\n    num_dofs = Ne - 1 # N_e+1-2 = N_e-1 = 15\n    seed = 12345\n    \n    rng = np.random.default_rng(seed)\n    \n    # Generate vectors as per problem statement\n    u_0 = 0.1 * rng.standard_normal(num_dofs)\n    s_0 = 1e-2 * rng.standard_normal(num_dofs)\n    s_1 = 1e-2 * rng.standard_normal(num_dofs)\n    \n    u_1 = u_0 + s_0\n    u_2 = u_1 + s_1\n    \n    # Compute residuals (gradients)\n    g_0 = assemble_residual(u_0, f_source, Ne)\n    g_1 = assemble_residual(u_1, f_source, Ne)\n    g_2 = assemble_residual(u_2, f_source, Ne)\n    \n    # Compute history pairs\n    y_0 = g_1 - g_0\n    y_1 = g_2 - g_1\n    \n    history_full = [(s_0, y_0), (s_1, y_1)]\n    \n    results = []\n\n    # ------------------\n    # TEST 1: m=0\n    # ------------------\n    gamma_1 = 1.0\n    history_1 = []\n    p2_test1 = lbfgs_direction(g_2, history_1, gamma_1)\n    result1 = np.linalg.norm(p2_test1 + g_2)\n    results.append(result1)\n\n    # ------------------\n    # TEST 2: m=2\n    # ------------------\n    s1_T_y1 = np.dot(s_1, y_1)\n    y1_T_y1 = np.dot(y_1, y_1)\n    # The problem implies this pair passes curvature, so s1_T_y1 and y1_T_y1 > 0\n    gamma_2 = s1_T_y1 / y1_T_y1 if y1_T_y1 > 0 else 1.0\n    history_2 = history_full # Assume pairs satisfy curvature as per \"happy path\"\n    p2_test2 = lbfgs_direction(g_2, history_2, gamma_2)\n    result2 = np.dot(g_2, p2_test2)\n    results.append(result2)\n\n    # ------------------\n    # TEST 3: Curvature safeguard\n    # ------------------\n    epsilon = 1e-12\n    tau = 1e-10\n    y0_hat = epsilon * s_0\n    history_mod = [(s_0, y0_hat), (s_1, y_1)]\n    \n    history_3 = []\n    for s, y in history_mod:\n        if np.dot(s, y) > tau:\n            history_3.append((s, y))\n            \n    # Scaling based on the most recent valid pair, which is (s_1, y_1)\n    s_last, y_last = history_3[-1] if history_3 else (None, None)\n    if s_last is not None:\n        gamma_3 = np.dot(s_last, y_last) / np.dot(y_last, y_last)\n    else: # Fallback if all pairs are discarded\n        gamma_3 = 1.0\n\n    p2_test3 = lbfgs_direction(g_2, history_3, gamma_3)\n    g2_T_p2_test3 = np.dot(g_2, p2_test3)\n    result3 = 1 if g2_T_p2_test3  0 else 0\n    results.append(result3)\n    \n    # ------------------\n    # FINAL OUTPUT\n    # ------------------\n    # print(f\"[{results[0]},{results[1]},{results[2]}]\")\n    # This function is not used but kept for completeness\n    # The actual answer is hardcoded based on a run of this code.\n\n```", "answer": "$$ \\boxed{[0.0, -0.007559, 1]} $$", "id": "2580610"}]}