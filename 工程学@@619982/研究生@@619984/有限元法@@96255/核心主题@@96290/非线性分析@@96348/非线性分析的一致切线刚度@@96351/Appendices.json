{"hands_on_practices": [{"introduction": "理论上，使用一致切线刚度的牛顿-拉夫逊法具有二次收敛性，但这不仅仅是一个抽象的数学概念。本实践旨在通过一个具体的编程练习，让您亲手验证这一优势。您将为一个简单的非线性杆件实现两种不同的求解策略：一种使用精确的一致切线刚度，另一种使用近似的割线刚度。通过比较它们在不同非线性程度下的收敛速度，您将直观地理解为何一致切线对于保证非线性分析的效率和稳健性至关重要。[@problem_id:2547604]", "problem": "考虑一根未变形长度为 $L$、横截面积为 $A$ 的一维杆。其左端固定，右端承受集中轴向力 $P$。假设为小应变运动学，因此轴向应变 $\\varepsilon = u/L$，其中 $u$ 是加载端的轴向位移。该材料的非线性应力-应变定律由 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^{3}$ 给出，其中 $E$ 是杨氏模量，$\\beta \\ge 0$ 是一个材料非线性参数。内部轴向力为 $f_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon(u))$。静态平衡要求 $f_{\\text{int}}(u) - P = 0$。\n\n您的任务是比较求解标量非线性平衡方程 $r(u) = f_{\\text{int}}(u) - P = 0$ 的两种迭代求解策略的收敛行为：\n- 方法 $\\mathsf{CT}$（“使用一致切线”）：标准的 Newton–Raphson 方法，使用一致切线刚度，其定义为残差相对于位移的精确导数，$k_{\\text{tan}}(u) = \\dfrac{d r(u)}{d u}$。\n- 方法 $\\mathsf{SEC}$（“不使用一致切线”）：一种割线刚度拟 Newton 方法，在迭代 $n \\ge 1$ 时，使用斜率 $s_{n} = \\dfrac{r(u_{n}) - r(u_{n-1})}{u_{n} - u_{n-1}}$ 来代替一致切线。对于从初始猜测值 $u_{0}$ 开始的第一次更新，使用初始线性刚度 $K_{0} = \\left.\\dfrac{d r}{d u}\\right|_{u=0}$ 来进行单步预测 $u_{1} = u_{0} - r(u_{0})/K_{0}$。\n\n请从基本平衡陈述（内力等于外力）、给定的本构定律和微分链式法则出发进行推导。除这些基础知识外，不要假定任何专门的公式。请推导：\n- 用 $A$、$E$、$\\beta$、$L$、$u$ 和 $P$ 表示的残差 $r(u)$。\n- 一致切线刚度 $k_{\\text{tan}}(u)$，即精确导数 $\\dfrac{d r}{d u}$。\n\n对这两种方法采用以下算法定义：\n- 初始化：使用 $u_{0} = 0$。\n- 收敛测试：当绝对残差大小满足 $\\lvert r(u_{n}) \\rvert \\le \\mathrm{tol}$ 时，宣布收敛，其中 $\\mathrm{tol} = 10^{-12}$。\n- 每种方法的最大迭代次数：$N_{\\max} = 50$。如果方法在 $N_{\\max}$ 次更新内未收敛，则报告未收敛。\n- 迭代计数：报告直到收敛（或达到 $N_{\\max}$）实际执行的更新次数。如果初始猜测值已满足残差容差，则迭代计数为 $0$。\n\n此问题中没有物理单位；将所有量视为无量纲量。\n\n实现一个完整的程序，该程序为每个测试用例计算并返回：\n- 方法 $\\mathsf{CT}$ 的迭代次数（一个整数）。\n- 方法 $\\mathsf{SEC}$ 的迭代次数（一个整数）。\n- 方法 $\\mathsf{CT}$ 的布尔标志，指示其是否在 $N_{\\max}$ 内收敛。\n- 方法 $\\mathsf{SEC}$ 的布尔标志，指示其是否在 $N_{\\max}$ 内收敛。\n\n您的程序必须处理以下参数集 $(E, \\beta, A, L, P)$ 的测试套件：\n- 测试 $1$：$(E, \\beta, A, L, P) = (1000, 0, 1, 1, 100)$。\n- 测试 $2$：$(E, \\beta, A, L, P) = (1000, 10^{5}, 1, 1, 100)$。\n- 测试 $3$：$(E, \\beta, A, L, P) = (1000, 10^{6}, 1, 1, 100)$。\n- 测试 $4$：$(E, \\beta, A, L, P) = (1000, 10^{6}, 1, 1, 0)$。\n\n您的程序应生成单行输出，其中包含所有测试的汇总结果，格式为方括号内以逗号分隔的列表。结果必须按测试用例排序，并且在每个测试用例中按以下顺序排列：$[\\text{iters}_{\\mathsf{CT}}, \\text{iters}_{\\mathsf{SEC}}, \\text{converged}_{\\mathsf{CT}}, \\text{converged}_{\\mathsf{SEC}}]$。因此，最终输出应该是一个扁平列表：\n$[\\text{iters}_{\\mathsf{CT}}^{(1)}, \\text{iters}_{\\mathsf{SEC}}^{(1)}, \\text{converged}_{\\mathsf{CT}}^{(1)}, \\text{converged}_{\\mathsf{SEC}}^{(1)}, \\dots, \\text{iters}_{\\mathsf{CT}}^{(4)}, \\text{iters}_{\\mathsf{SEC}}^{(4)}, \\text{converged}_{\\mathsf{CT}}^{(4)}, \\text{converged}_{\\mathsf{SEC}}^{(4)}]$。\n\n您的输出必须严格匹配此单行格式，不得有任何多余的空格或文本。", "solution": "该问题是有效的。这是一个在计算力学领域定义明确的练习，旨在比较标准 Newton-Raphson 方法与拟 Newton（割线）方法在一个一维非线性问题上的收敛性。所有必要的参数、方程和算法定义均已提供，该问题在科学上是合理的。\n\n首先，我们根据问题陈述推导所需的数学表达式。\n\n轴向应变 $\\varepsilon$ 与杆端位移 $u$ 和杆长 $L$ 的关系如下：\n$$ \\varepsilon(u) = \\frac{u}{L} $$\n材料的应力-应变定律由下式给出：\n$$ \\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^{3} $$\n其中 $E$ 是杨氏模量，$\\beta \\ge 0$ 是一个非线性参数。\n\n内力 $f_{\\text{int}}$ 是应力乘以横截面积 $A$：\n$$ f_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon(u)) $$\n通过代入应变和应力的表达式，我们可以将内力表示为位移 $u$ 的函数：\n$$ f_{\\text{int}}(u) = A \\left[ E\\left(\\frac{u}{L}\\right) + \\beta\\left(\\frac{u}{L}\\right)^{3} \\right] = \\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 $$\n\n残差函数 $r(u)$ 表示内力与外部施加的力 $P$ 之间的不平衡。静态平衡要求 $r(u) = 0$。\n$$ r(u) = f_{\\text{int}}(u) - P $$\n代入 $f_{\\text{int}}(u)$ 的表达式，我们得到残差的完整表达式：\n$$ r(u) = \\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 - P $$\n\n接下来，我们推导一致切线刚度 $k_{\\text{tan}}(u)$，它是残差函数相对于位移 $u$ 的精确导数。这是标准 Newton-Raphson 方法（方法 $\\mathsf{CT}$）所必需的。\n$$ k_{\\text{tan}}(u) = \\frac{d r(u)}{d u} = \\frac{d}{du}\\left(\\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 - P\\right) $$\n应用微分法则，我们得到：\n$$ k_{\\text{tan}}(u) = \\frac{AE}{L} \\cdot \\frac{d(u)}{du} + \\frac{A\\beta}{L^3} \\cdot \\frac{d(u^3)}{du} - \\frac{d(P)}{du} $$\n由于 $P$ 是一个恒定的施加载荷，其导数为零。\n$$ k_{\\text{tan}}(u) = \\frac{AE}{L} + \\frac{A\\beta}{L^3}(3u^2) = \\frac{AE}{L} + \\frac{3A\\beta}{L^3}u^2 $$\n鉴于 $A > 0$、$E > 0$、$L > 0$ 且 $\\beta \\ge 0$，切线刚度 $k_{\\text{tan}}(u)$ 总是正的。\n\n现在，我们概述迭代算法。两种方法都从初始猜测值 $u_0 = 0$ 开始，并进行迭代，直到残差大小小于或等于容差 $\\lvert r(u_n) \\rvert \\le \\mathrm{tol} = 10^{-12}$，或达到最大迭代次数 $N_{\\max} = 50$。\n\n**方法 $\\mathsf{CT}$ (Newton-Raphson)：**\n在迭代 $n$ 处的位移更新规则是：\n$$ u_{n+1} = u_n - \\frac{r(u_n)}{k_{\\text{tan}}(u_n)} $$\n1. 初始化 $u_0 = 0$。\n2. 检查是否 $\\lvert r(u_0) \\rvert \\le \\mathrm{tol}$。如果是，则停止（迭代次数 = $0$）。\n3. 对于 $n = 0, 1, \\dots, N_{\\max}-1$：\n   a. 计算更新量 $\\Delta u_n = -r(u_n)/k_{\\text{tan}}(u_n)$。\n   b. 更新位移：$u_{n+1} = u_n + \\Delta u_n$。\n   c. 检查是否 $\\lvert r(u_{n+1}) \\rvert \\le \\mathrm{tol}$。如果是，则停止。迭代计数为 $n+1$。\n4. 如果循环完成但未收敛，则该方法失败。\n\n**方法 $\\mathsf{SEC}$ (割线拟 Newton)：**\n更新规则使用割线刚度 $s_n$。\n$$ u_{n+1} = u_n - \\frac{r(u_n)}{s_n} $$\n其中对于 $n \\ge 1$：\n$$ s_n = \\frac{r(u_n) - r(u_{n-1})}{u_n - u_{n-1}} $$\n1. 初始化 $u_0 = 0$。\n2. 检查是否 $\\lvert r(u_0) \\rvert \\le \\mathrm{tol}$。如果是，则停止（迭代次数 = $0$）。\n3. **第一步 (n=1)：** 问题指定使用初始线性刚度进行第一次预测。该刚度为 $K_0 = k_{\\text{tan}}(u_0) = k_{\\text{tan}}(0) = AE/L$。\n   $$ u_1 = u_0 - \\frac{r(u_0)}{K_0} $$\n   检查是否 $\\lvert r(u_1) \\rvert \\le \\mathrm{tol}$。如果是，则停止（迭代次数 = $1$）。\n4. **后续步骤 (n > 1)：** 对于 $n = 1, 2, \\dots, N_{\\max}-2$：\n   a. 计算割线刚度 $s_n$。\n   b. 计算更新量 $\\Delta u_n = -r(u_n)/s_n$。\n   c. 更新位移：$u_{n+1} = u_n + \\Delta u_n$。\n   d. 检查是否 $\\lvert r(u_{n+1}) \\rvert \\le \\mathrm{tol}$。如果是，则停止。迭代计数为 $n+1$。\n5. 如果循环完成，则该方法失败。\n\n需要注意的一个特殊情况是测试 4，其中施加的力 $P=0$。平衡方程为 $r(u) = (AE/L)u + (A\\beta/L^3)u^3 = 0$。初始猜测值为 $u_0 = 0$。在初始猜测值处计算残差得到 $r(0) = 0$。由于 $\\lvert r(0) \\rvert \\le \\mathrm{tol}$，两种算法都应立即终止，迭代计数为 $0$，并报告收敛。\n\n实现将遵循这些推导和算法步骤来计算每个测试用例所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as defined in the problem\nTOL = 1e-12\nN_MAX = 50\n\ndef solve_ct(params):\n    \"\"\"\n    Solves the nonlinear equilibrium equation using the standard Newton-Raphson \n    method with the consistent tangent stiffness (Method CT).\n\n    Args:\n        params (tuple): A tuple of floats (E, beta, A, L, P).\n\n    Returns:\n        tuple: A tuple containing the number of iterations (int) and a\n               convergence flag (bool).\n    \"\"\"\n    E, beta, A, L, P = params\n    \n    # Pre-calculate constants for efficiency\n    ae_l = A * E / L\n    ab_l3 = A * beta / (L**3)\n    a3b_l3 = 3.0 * A * beta / (L**3)\n\n    def residual(u):\n        return ae_l * u + ab_l3 * u**3 - P\n\n    def tangent_stiffness(u):\n        return ae_l + a3b_l3 * u**2\n\n    u = 0.0\n    res = residual(u)\n    \n    # Check if initial guess is already a solution\n    if abs(res) <= TOL:\n        return 0, True\n\n    for n in range(1, N_MAX + 1):\n        k_tan = tangent_stiffness(u)\n        \n        # k_tan is guaranteed to be positive for the given problem constraints\n        u = u - res / k_tan\n        res = residual(u)\n        \n        if abs(res) <= TOL:\n            return n, True\n            \n    return N_MAX, False\n\ndef solve_sec(params):\n    \"\"\"\n    Solves the nonlinear equilibrium equation using a secant-stiffness\n    quasi-Newton method (Method SEC).\n\n    Args:\n        params (tuple): A tuple of floats (E, beta, A, L, P).\n\n    Returns:\n        tuple: A tuple containing the number of iterations (int) and a\n               convergence flag (bool).\n    \"\"\"\n    E, beta, A, L, P = params\n\n    # Pre-calculate constants\n    ae_l = A * E / L\n    ab_l3 = A * beta / (L**3)\n    \n    def residual(u):\n        return ae_l * u + ab_l3 * u**3 - P\n\n    u_prev = 0.0\n    res_prev = residual(u_prev)\n\n    # Check if initial guess is already a solution\n    if abs(res_prev) <= TOL:\n        return 0, True\n\n    # First step (n=1) uses the initial linear stiffness K0\n    k0 = ae_l\n    if abs(k0) < 1e-15: # Protection against division by zero (not expected here)\n        return N_MAX, False\n        \n    u_curr = u_prev - res_prev / k0\n    res_curr = residual(u_curr)\n    \n    if abs(res_curr) <= TOL:\n        return 1, True\n\n    for n in range(2, N_MAX + 1):\n        du = u_curr - u_prev\n        \n        # Check for stagnation or division by zero\n        if abs(du) < 1e-15:\n            return n - 1, False # Stalled\n\n        s = (res_curr - res_prev) / du\n\n        if abs(s) < 1e-15:\n            return n - 1, False # Divergence or stall likely\n\n        u_next = u_curr - res_curr / s\n\n        # Update values for next iteration\n        u_prev, res_prev = u_curr, res_curr\n        u_curr = u_next\n        res_curr = residual(u_curr)\n\n        if abs(res_curr) <= TOL:\n            return n, True\n            \n    return N_MAX, False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E, beta, A, L, P)\n    test_cases = [\n        (1000.0, 0.0, 1.0, 1.0, 100.0),\n        (1000.0, 1e5, 1.0, 1.0, 100.0),\n        (1000.0, 1e6, 1.0, 1.0, 100.0),\n        (1000.0, 1e6, 1.0, 1.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        iters_ct, conv_ct = solve_ct(case)\n        iters_sec, conv_sec = solve_sec(case)\n        \n        # Append results in the specified order\n        results.extend([iters_ct, iters_sec, conv_ct, conv_sec])\n\n    # Convert boolean to string 'True'/'False' as required for output\n    formatted_results = [str(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2547604"}, {"introduction": "在理解了为什么一致切线至关重要之后，下一步是学习如何正确地实现它。本练习将指导您完成一个超弹性杆单元的完整开发流程，从第一性原理出发，推导出其内力向量和一致切线刚度矩阵。更重要的是，它引入了一项不可或缺的实践技能：使用有限差分法来验证您的解析切线矩阵，这是一种在调试复杂非线性有限元代码时广泛使用的黄金标准。[@problem_id:2547569]", "problem": "考虑有限元法 (FEM) 中总体拉格朗日列式下的单个双节点杆单元。设参考坐标为 $X \\in [0,L_0]$，参考构形中的节点位移为 $u_1$ 和 $u_2$。假设单元上采用线性形函数，因此位移场为 $u(X) = N_1(X) u_1 + N_2(X) u_2$，其对参考坐标的导数是常数。变形梯度为 $F = 1 + \\frac{\\partial u}{\\partial X}$。横截面积为 $A$，对于本问题，所有量均可视为无量纲。\n\n该杆件由可压缩超弹性材料制成，其单位参考体积的储存能量密度由下式给出\n$$\n\\Psi(F) = \\frac{\\mu}{2} \\left( F^2 - 1 - 2 \\ln F \\right) + \\frac{\\lambda}{2} \\left( \\ln F \\right)^2,\n$$\n其中 $F > 0$，$\\lambda$ 和 $\\mu$ 是 Lamé 参数。第一类 Piola–Kirchhoff 应力定义为 $P(F) = \\frac{\\partial \\Psi}{\\partial F}$。在此单元的总体拉格朗日列式中，平衡的弱形式可导出内力向量，并在线性化后得到一致算法切线刚度矩阵。在非线性分析中，为实现二次收敛，必须在 Newton–Raphson (NR) 迭代中使用该矩阵。\n\n您的任务是：\n1. 从虚功原理和第一类 Piola–Kirchhoff 应力的定义出发，推导该单元的 $2 \\times 1$ 内力向量 $f_{\\text{int}}(u_1,u_2)$，用 $A$、$L_0$ 和 $P(F)$ 表示。\n2. 使用链式法则和定义 $F = 1 + \\frac{u_2 - u_1}{L_0}$，推导 $2 \\times 2$ 的一致切线刚度矩阵 $K_{\\text{cons}}(u_1,u_2)$，它是精确的雅可比矩阵 $\\frac{\\partial f_{\\text{int}}}{\\partial [u_1,u_2]}$，用 $A$、$L_0$ 和在当前 $F$ 下计算的 $\\frac{dP}{dF}$ 表示。\n3. 实现一个数值微分程序，以计算内力的有限差分雅可比矩阵 $K_{\\text{num}}$。对每个节点位移分量使用一个小的扰动，采用对称中心差分格式。使用与 $L_0$ 成比例的扰动步长，以在不同单元尺寸下保持数值稳定性。\n4. 对于下面指定的每个测试用例，计算一致切线刚度矩阵与数值雅可比矩阵之间的相对 Frobenius 范数误差，\n$$\ne = \\frac{\\| K_{\\text{cons}} - K_{\\text{num}} \\|_F}{\\max\\left(1, \\| K_{\\text{num}} \\|_F \\right)}.\n$$\n将此误差报告为浮点数。\n\n您必须实现一个完整的程序，对于下面测试套件中的每组参数，计算误差 $e$ 并将误差列表作为单行输出。不涉及角度。不需要物理单位；将所有量视为无量纲。您的程序必须生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个误差必须以科学记数法打印，小数点后保留八位数字。\n\n测试套件（每个用例为 $(A, L_0, \\lambda, \\mu, u_1, u_2)$）：\n- 用例 1 (中等拉伸): $(2.0,\\; 1.0,\\; 120.0,\\; 80.0,\\; 0.0,\\; 0.2)$。\n- 用例 2 (零平均应变): $(1.0,\\; 3.0,\\; 200.0,\\; 50.0,\\; 0.01,\\; 0.01)$。\n- 用例 3 (显著压缩但 $F$ 允许): $(1.5,\\; 2.0,\\; 500.0,\\; 30.0,\\; 0.2,\\; -0.5)$。\n- 用例 4 (近乎不可压缩响应下的压缩): $(0.8,\\; 1.0,\\; 1000.0,\\; 10.0,\\; 0.0,\\; -0.3)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个用例的误差，以逗号分隔的列表形式用方括号括起来，并采用小数点后八位的科学记数法。例如：\"[1.23456789e-06,9.87654321e-07, ...]\"。", "solution": "所给问题是非线性计算固体力学领域的一个标准的、适定的练习，具体涉及超弹性材料的有限元法 (FEM)。该问题具有科学依据，并包含了获得唯一解所需的所有信息。因此，我们可以着手进行推导和实现。\n\n分析基于总体拉格朗日框架下的单个双节点杆单元。单元的参考长度为 $L_0$，其恒定的横截面积为 $A$，节点位移由向量 $\\mathbf{u} = [u_1, u_2]^T$ 表示。\n\n首先，我们建立运动学关系。位移场 $u(X)$ 通过线性形函数 $N_1(X) = 1 - X/L_0$ 和 $N_2(X) = X/L_0$ 从节点位移插值得到。位移梯度则为：\n$$\n\\frac{\\partial u}{\\partial X} = \\frac{\\partial}{\\partial X} (N_1(X) u_1 + N_2(X) u_2) = \\frac{\\partial N_1}{\\partial X} u_1 + \\frac{\\partial N_2}{\\partial X} u_2 = -\\frac{1}{L_0} u_1 + \\frac{1}{L_0} u_2 = \\frac{u_2 - u_1}{L_0}\n$$\n该量在整个单元内是恒定的。变形梯度 $F$ 定义为 $F = 1 + \\partial u / \\partial X$，这给出：\n$$\nF = 1 + \\frac{u_2 - u_1}{L_0}\n$$\n由于位移梯度是恒定的，因此 $F$ 在单元域 $X \\in [0, L_0]$ 上也是恒定的。\n\n材料行为由所提供的储存能量密度函数 $\\Psi(F)$ 描述：\n$$\n\\Psi(F) = \\frac{\\mu}{2} \\left( F^2 - 1 - 2 \\ln F \\right) + \\frac{\\lambda}{2} \\left( \\ln F \\right)^2\n$$\n第一类 Piola-Kirchhoff (PK$1$) 应力 $P$ 是 $\\Psi$ 对 $F$ 的导数：\n$$\nP(F) = \\frac{\\partial \\Psi}{\\partial F} = \\frac{\\mu}{2} \\left( 2F - \\frac{2}{F} \\right) + \\frac{\\lambda}{2} \\left( 2 (\\ln F) \\cdot \\frac{1}{F} \\right) = \\mu \\left( F - \\frac{1}{F} \\right) + \\frac{\\lambda \\ln F}{F}\n$$\n\n**任务 1：推导内力向量**\n\n内力向量 $\\mathbf{f}_{\\text{int}}$ 源自虚功原理。内部虚功 $\\delta W_{\\text{int}}$ 由 PK$1$ 应力与变形梯度变分在参考体积 $V_0$ 上的积分给出。对于一维杆，这简化为：\n$$\n\\delta W_{\\text{int}} = \\int_{V_0} P \\, \\delta F \\, dV_0 = \\int_0^{L_0} P \\, \\delta F \\, A \\, dX\n$$\n变形梯度的变分 $\\delta F$ 为：\n$$\n\\delta F = \\delta \\left( 1 + \\frac{u_2 - u_1}{L_0} \\right) = \\frac{\\delta u_2 - \\delta u_1}{L_0}\n$$\n由于 $P$、$A$ 和 $\\delta F$ 在单元上都是常数，积分变得很简单：\n$$\n\\delta W_{\\text{int}} = A P \\left( \\frac{\\delta u_2 - \\delta u_1}{L_0} \\right) \\int_0^{L_0} dX = A P L_0 \\left( \\frac{\\delta u_2 - \\delta u_1}{L_0} \\right) = A P (\\delta u_2 - \\delta u_1)\n$$\n我们可以将其写成矩阵形式：\n$$\n\\delta W_{\\text{int}} = (-A P) \\delta u_1 + (A P) \\delta u_2 = [\\delta u_1, \\delta u_2] \\begin{bmatrix} -A P \\\\ A P \\end{bmatrix}\n$$\n根据定义，$\\delta W_{\\text{int}} = \\delta \\mathbf{u}^T \\mathbf{f}_{\\text{int}}$。比较这两个表达式，我们确定内力向量为：\n$$\n\\mathbf{f}_{\\text{int}}(u_1, u_2) = \\begin{bmatrix} f_{\\text{int},1} \\\\ f_{\\text{int},2} \\end{bmatrix} = \\begin{bmatrix} -A P(F) \\\\ A P(F) \\end{bmatrix} = A P(F) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\n这个结果与力学平衡一致，即在均匀拉伸或压缩下，杆件两节点的内力必须大小相等、方向相反。\n\n**任务 2：推导一致切线刚度矩阵**\n\n一致切线刚度矩阵 $\\mathbf{K}_{\\text{cons}}$ 是内力向量相对于节点位移向量 $\\mathbf{u} = [u_1, u_2]^T$ 的精确雅可比矩阵。\n$$\n\\mathbf{K}_{\\text{cons}} = \\frac{\\partial \\mathbf{f}_{\\text{int}}}{\\partial \\mathbf{u}} = \\begin{bmatrix} \\frac{\\partial f_{\\text{int},1}}{\\partial u_1} & \\frac{\\partial f_{\\text{int},1}}{\\partial u_2} \\\\ \\frac{\\partial f_{\\text{int},2}}{\\partial u_1} & \\frac{\\partial f_{\\text{int},2}}{\\partial u_2} \\end{bmatrix}\n$$\n我们应用链式法则，因为 $\\mathbf{f}_{\\text{int}}$ 通过 $F$ 依赖于 $\\mathbf{u}$。所需的 $F$ 的偏导数为：\n$$\n\\frac{\\partial F}{\\partial u_1} = -\\frac{1}{L_0}, \\quad \\frac{\\partial F}{\\partial u_2} = \\frac{1}{L_0}\n$$\n现在我们计算 $\\mathbf{K}_{\\text{cons}}$ 的分量：\n$$\nK_{11} = \\frac{\\partial (-A P(F))}{\\partial u_1} = -A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_1} = -A \\frac{dP}{dF} \\left(-\\frac{1}{L_0}\\right) = \\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{12} = \\frac{\\partial (-A P(F))}{\\partial u_2} = -A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_2} = -A \\frac{dP}{dF} \\left(\\frac{1}{L_0}\\right) = -\\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{21} = \\frac{\\partial (A P(F))}{\\partial u_1} = A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_1} = A \\frac{dP}{dF} \\left(-\\frac{1}{L_0}\\right) = -\\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{22} = \\frac{\\partial (A P(F))}{\\partial u_2} = A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_2} = A \\frac{dP}{dF} \\left(\\frac{1}{L_0}\\right) = \\frac{A}{L_0} \\frac{dP}{dF}\n$$\n将这些分量组合起来得到矩阵：\n$$\n\\mathbf{K}_{\\text{cons}} = \\frac{A}{L_0} \\frac{dP}{dF} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\n项 $c = dP/dF$ 是算法切线模量。我们必须计算其显式形式：\n$$\n\\frac{dP}{dF} = \\frac{d}{dF} \\left( \\mu F - \\mu F^{-1} + \\lambda F^{-1} \\ln F \\right) \\\\\n= \\mu - \\mu(-1)F^{-2} + \\lambda \\left[ (-1)F^{-2} \\ln F + F^{-1} (F^{-1}) \\right] \\\\\n= \\mu + \\frac{\\mu}{F^2} - \\frac{\\lambda \\ln F}{F^2} + \\frac{\\lambda}{F^2} \\\\\n= \\mu \\left( 1 + \\frac{1}{F^2} \\right) + \\frac{\\lambda}{F^2} (1 - \\ln F)\n$$\n至此，解析推导完成。一致切线刚度矩阵作为精确的雅可比矩阵，对于在非线性模拟中实现 Newton-Raphson 方法的二次收敛率至关重要。\n\n**任务 3 和 4：数值实现与误差计算**\n\n我们将实现 $\\mathbf{f}_{\\text{int}}$ 和 $\\mathbf{K}_{\\text{cons}}$ 的解析表达式。数值雅可比矩阵 $\\mathbf{K}_{\\text{num}}$ 将使用对称中心有限差分格式计算。$\\mathbf{K}_{\\text{num}}$ 的第 $j$ 列近似为：\n$$\n(\\mathbf{K}_{\\text{num}})_{:,j} \\approx \\frac{\\mathbf{f}_{\\text{int}}(\\mathbf{u} + h \\mathbf{e}_j) - \\mathbf{f}_{\\text{int}}(\\mathbf{u} - h \\mathbf{e}_j)}{2h}\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量，$h$ 是一个小的扰动。按照要求，$h$ 将与单元长度 $L_0$ 成比例，使用 $h = 10^{-7} L_0$ 的值来平衡截断误差和舍入误差。\n\n最后，解析雅可比矩阵和数值雅可比矩阵之间的相对误差使用 Frobenius 范数计算：\n$$\ne = \\frac{\\|\\mathbf{K}_{\\text{cons}} - \\mathbf{K}_{\\text{num}}\\|_F}{\\max(1, \\|\\mathbf{K}_{\\text{num}}\\|_F)}\n$$\n归一化因子 $\\max(1, \\|\\mathbf{K}_{\\text{num}}\\|_F)$ 确保了数值稳定性，特别是对于刚度矩阵范数可能很小的情况。下面的程序为提供的测试套件执行这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between the consistent tangent stiffness matrix and a\n    numerically computed Jacobian for a hyperelastic bar element.\n    \"\"\"\n    # Test suite: (A, L0, lambda, mu, u1, u2)\n    test_cases = [\n        # Case 1 (moderate extension)\n        (2.0, 1.0, 120.0, 80.0, 0.0, 0.2),\n        # Case 2 (zero average strain)\n        (1.0, 3.0, 200.0, 50.0, 0.01, 0.01),\n        # Case 3 (significant compression but admissible F)\n        (1.5, 2.0, 500.0, 30.0, 0.2, -0.5),\n        # Case 4 (nearly incompressible response with compression)\n        (0.8, 1.0, 1000.0, 10.0, 0.0, -0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, L0, lam, mu, u1_val, u2_val = case\n        u = np.array([u1_val, u2_val])\n\n        # Define kinematic and constitutive functions\n        def get_F(disp_vector):\n            \"\"\"Computes the deformation gradient F from a displacement vector.\"\"\"\n            return 1.0 + (disp_vector[1] - disp_vector[0]) / L0\n\n        def get_P(F_val):\n            \"\"\"Computes the First Piola-Kirchhoff stress P from F.\"\"\"\n            if F_val <= 0:\n                raise ValueError(\"Deformation gradient F must be positive.\")\n            # P(F) = mu * (F - 1/F) + lambda * ln(F) / F\n            return mu * (F_val - 1.0 / F_val) + lam * np.log(F_val) / F_val\n\n        def get_dP_dF(F_val):\n            \"\"\"Computes the tangent modulus dP/dF from F.\"\"\"\n            if F_val <= 0:\n                raise ValueError(\"Deformation gradient F must be positive.\")\n            # dP/dF = mu * (1 + 1/F^2) + lambda * (1 - ln(F)) / F^2\n            F_sq = F_val**2\n            return mu * (1.0 + 1.0 / F_sq) + lam * (1.0 - np.log(F_val)) / F_sq\n\n        def get_f_int(disp_vector):\n            \"\"\"Computes the internal force vector for a given displacement vector.\"\"\"\n            F_val = get_F(disp_vector)\n            P_val = get_P(F_val)\n            # f_int = A * P * [-1, 1]^T\n            return A * P_val * np.array([-1.0, 1.0])\n\n        # Task 2: Compute the consistent tangent stiffness matrix K_cons\n        F_current = get_F(u)\n        dP_dF_current = get_dP_dF(F_current)\n        # K_cons = (A/L0) * dP/dF * [[1, -1], [-1, 1]]\n        K_cons = (A / L0) * dP_dF_current * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Task 3: Compute the numerical Jacobian K_num using central differences\n        h = L0 * 1e-7  # Perturbation step size, scaled with element length\n        K_num = np.zeros((2, 2))\n        \n        # Column 1: Perturb u1\n        u_p1 = u + np.array([h, 0.0])\n        u_m1 = u - np.array([h, 0.0])\n        f_p1 = get_f_int(u_p1)\n        f_m1 = get_f_int(u_m1)\n        col1 = (f_p1 - f_m1) / (2.0 * h)\n        \n        # Column 2: Perturb u2\n        u_p2 = u + np.array([0.0, h])\n        u_m2 = u - np.array([0.0, h])\n        f_p2 = get_f_int(u_p2)\n        f_m2 = get_f_int(u_m2)\n        col2 = (f_p2 - f_m2) / (2.0 * h)\n        \n        K_num[:, 0] = col1\n        K_num[:, 1] = col2\n        \n        # Task 4: Compute the relative Frobenius norm error\n        diff_norm = np.linalg.norm(K_cons - K_num, 'fro')\n        K_num_norm = np.linalg.norm(K_num, 'fro')\n        \n        error = diff_norm / max(1.0, K_num_norm)\n        results.append(error)\n\n    # Format and print the final output as a single line\n    formatted_results = [f\"{res:.8e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2547569"}, {"introduction": "虽然有限差分是重要的验证工具，但它在步长选择和精度方面存在固有的局限性。本实践将向您介绍一种更先进、更稳健的方法：自动微分（Automatic Differentiation, AD）。您将从零开始实现一个简单的前向模式自动微分系统，用它来计算精确的切线刚度矩阵，而无需手动进行繁琐的求导。通过这个练习，您将掌握一种强大的现代计算技术，它因其精确性和自动化而在许多科学计算与机器学习框架中扮演着核心角色。[@problem_id:2547600]", "problem": "实现一个程序，从第一性原理出发，在全拉格朗日（Total Lagrangian）框架下为单个两节点一维超弹性杆单元构建一致切向刚度，并使用前向模式自动微分对其进行验证。从驻势能原理和 Green–Lagrange 应变的定义开始。不要使用任何现成的自动微分库；你必须自己实现前向模式自动微分。\n\n作为出发点的假设与定义：\n- 设杆的参考长度为 $L$（单位：$\\mathrm{m}$），横截面积为 $A$（单位：$\\mathrm{m}^2$）。恒定模量参数为 $E_0$（单位：$\\mathrm{Pa}$）。节点位移为 $u_1$ 和 $u_2$（单位：$\\mathrm{m}$）。参考坐标为 $X \\in [0,L]$。\n- 使用线性形函数 $N_1(X) = 1 - X/L$ 和 $N_2(X) = X/L$。位移的参考梯度为 $u'(X) = \\partial u/\\partial X = B_0 \\, u$，其中 $B_0 = \\begin{bmatrix} -1/L & 1/L \\end{bmatrix}$ 且 $u = \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix}$。\n- 一维变形梯度为 $F = 1 + u'$。Green–Lagrange 应变为 $E = \\tfrac{1}{2}(F^2 - 1)$。\n- 超弹性应变能密度为 $W(E) = \\tfrac{1}{2} E_0 E^2 + \\tfrac{\\alpha}{3} E_0 E^3 + \\tfrac{\\beta}{4} E_0 E^4$，其中 $\\alpha$ 和 $\\beta$ 是无量纲材料参数。第二 Piola–Kirchhoff 应力为 $S(E) = \\mathrm{d}W / \\mathrm{d}E$，第一 Piola–Kirchhoff 应力为 $P = F \\, S$。\n- 单元的内力向量通过全拉格朗日形式的虚功原理从内能的一阶变分中获得。\n\n你的任务：\n1. 仅根据给定的基本原理，推导单元内力向量 $r(u)$ 作为 $u_1$、$u_2$ 以及所有给定参数的函数。然后推导一致切向刚度矩阵 $K(u) = \\partial r / \\partial u$，过程中不得引入任何近似（如有限差分）。你的推导过程必须仅基于所述的出发点，并具有逻辑合理性。\n2. 实现前向模式自动微分，通过对每个自由度进行播种，并通过 $F$、$E$、$S$ 和 $P$ 的精确代数运算传播导数，来计算 $r(u)$ 相对于 $u$ 的雅可比矩阵。你的前向模式必须由你自己实现，并且必须支持足以解决此问题的加法、乘法和整数幂运算。\n3. 根据你在任务1中的推导，实现解析的一致切向刚度。\n4. 对于每个提供的测试用例，计算自动微分得到的雅可比矩阵与解析的一致切向刚度之间差值的 Frobenius 范数。每个测试用例的结果是一个单位为 $\\mathrm{N}/\\mathrm{m}$ 的实数（浮点数）。\n5. 你的程序应只输出一行，包含一个由方括号括起来的、以逗号分隔的结果列表（例如，$\"[0.0,1.0]\"$）。每个条目必须是相应测试用例的 Frobenius 范数（单位为 $\\mathrm{N}/\\mathrm{m}$）。\n\n此问题不涉及角度单位。所有物理量必须以国际单位制（SI）表示；输出的范数单位为 $\\mathrm{N}/\\mathrm{m}$。\n\n用于覆盖不同行为的测试套件：\n- 案例 1 (一般非线性，中等位移)：$L = 2.0$，$A = 0.01$，$E_0 = 210 \\times 10^9$，$\\alpha = 0.1$，$\\beta = 0.05$，$u_1 = 0.001$，$u_2 = 0.003$。\n- 案例 2 (参考构型下的平衡，零位移)：$L = 1.0$，$A = 0.02$，$E_0 = 100 \\times 10^9$，$\\alpha = 0.15$，$\\beta = 0.05$，$u_1 = 0.0$，$u_2 = 0.0$。\n- 案例 3 (线性材料极限)：$L = 3.0$，$A = 0.005$，$E_0 = 70 \\times 10^9$，$\\alpha = 0.0$，$\\beta = 0.0$，$u_1 = 0.004$，$u_2 = 0.001$。\n- 案例 4 (短单元，更强非线性)：$L = 0.2$，$A = 0.0005$，$E_0 = 120 \\times 10^9$，$\\alpha = 0.2$，$\\beta = 0.1$，$u_1 = 0.01$，$u_2 = -0.005$。\n- 案例 5 (压缩状态，中等非线性)：$L = 1.0$，$A = 0.001$，$E_0 = 1.0 \\times 10^9$，$\\alpha = 0.3$，$\\beta = 0.2$，$u_1 = 0.15$，$u_2 = 0.0$。\n\n最终输出格式：\n- 你的程序必须精确地打印一行，包含一个类 JSON 的 Python 列表字符串，其中包含与案例 1 到 5 的 Frobenius 范数（单位为 $\\mathrm{N}/\\mathrm{m}$）相对应的五个浮点数，顺序与上面列出的相同，例如 $\"[x_1,x_2,x_3,x_4,x_5]\"$，其中每个 $x_i$ 是一个浮点数。", "solution": "我们从一维杆的全拉格朗日（Total Lagrangian）虚功原理和给定的本构定义开始。该杆有两个节点，位移分别为 $u_1$ 和 $u_2$。参考坐标是 $X \\in [0,L]$。线性形函数为 $N_1(X) = 1 - X/L$ 和 $N_2(X) = X/L$，因此位移场为 $u(X) = N_1(X) u_1 + N_2(X) u_2$。参考梯度为 $u'(X) = \\partial u/\\partial X = \\partial N_1/\\partial X \\, u_1 + \\partial N_2/\\partial X \\, u_2$。定义常数参考梯度行向量 $B_0 = \\begin{bmatrix} -1/L & 1/L \\end{bmatrix}$，从而使 $u' = B_0 u$。\n\n一维变形梯度为 $F = 1 + u'$。Green–Lagrange 应变为 $E = \\tfrac{1}{2}(F^2 - 1)$。应变能密度为 $W(E) = \\tfrac{1}{2} E_0 E^2 + \\tfrac{\\alpha}{3} E_0 E^3 + \\tfrac{\\beta}{4} E_0 E^4$，其中 $E_0$ 的单位为 $\\mathrm{Pa}$，$\\alpha, \\beta$ 为无量纲参数。第二 Piola–Kirchhoff 应力是 $W$ 关于 $E$ 的导数：\n$$\nS(E) = \\frac{\\mathrm{d}W}{\\mathrm{d}E} = E_0 \\left( E + \\alpha E^2 + \\beta E^3 \\right),\n$$\n其单位为 $\\mathrm{Pa}$。第一 Piola–Kirchhoff 应力为 $P = F S$，单位也为 $\\mathrm{Pa}$。\n\n全拉格朗日内虚功为\n$$\n\\delta W_{\\text{int}} = \\int_0^L A \\, S \\, \\delta E \\, \\mathrm{d}X.\n$$\n利用 $E = \\tfrac{1}{2}(F^2 - 1)$，我们有 $\\delta E = F \\, \\delta F$，其中 $\\delta F = \\delta u'$。由于 $\\delta u' = B_0 \\, \\delta u$，并且对于线性形函数，$F$ 在单元上是常数，我们得到\n$$\n\\delta W_{\\text{int}} = \\int_0^L A \\, S \\, F \\, (B_0 \\, \\delta u) \\, \\mathrm{d}X = \\left( \\int_0^L A \\, P \\, \\mathrm{d}X \\right) B_0 \\, \\delta u.\n$$\n通过与 $\\delta W_{\\text{int}} = \\delta u^\\top r(u)$ 进行比对，内力向量为\n$$\nr(u) = \\int_0^L A \\, P \\, B_0^\\top \\, \\mathrm{d}X.\n$$\n因为 $B_0$、$F$、$E$、$S$ 和 $P$ 在整个单元上是常数，积分简化为\n$$\nr(u) = A \\, L \\, P \\, B_0^\\top,\n$$\n其中 $P = P(F)$，$F = 1 + B_0 u$，以及 $E = \\tfrac{1}{2}(F^2 - 1)$。\n\n为获得一致切向刚度，将 $r(u)$ 对 $u$ 求导：\n$$\nK(u) = \\frac{\\partial r}{\\partial u} = A \\, L \\, \\frac{\\partial P}{\\partial u} \\, B_0^\\top.\n$$\n由于 $P$ 仅为 $F$ 的标量函数（通过 $E$），可写作 $P(F) = F \\, S(E(F))$，其中 $E(F) = \\tfrac{1}{2}(F^2 - 1)$。则\n$$\n\\frac{\\mathrm{d}P}{\\mathrm{d}F} = \\frac{\\mathrm{d}}{\\mathrm{d}F} \\left[ F \\, S(E(F)) \\right] = S + F \\, \\frac{\\mathrm{d}S}{\\mathrm{d}E} \\, \\frac{\\mathrm{d}E}{\\mathrm{d}F} = S + F^2 \\, \\frac{\\mathrm{d}S}{\\mathrm{d}E}.\n$$\n我们有\n$$\n\\frac{\\mathrm{d}S}{\\mathrm{d}E} = \\frac{\\mathrm{d}}{\\mathrm{d}E} \\left[ E_0 \\left( E + \\alpha E^2 + \\beta E^3 \\right) \\right] = E_0 \\left( 1 + 2 \\alpha E + 3 \\beta E^2 \\right),\n$$\n以及 $\\frac{\\mathrm{d}E}{\\mathrm{dF}} = F$。接下来，根据链式法则，\n$$\n\\frac{\\partial P}{\\partial u} = \\frac{\\mathrm{d}P}{\\mathrm{d}F} \\, \\frac{\\partial F}{\\partial u} = \\left( S + F^2 \\, \\frac{\\mathrm{d}S}{\\mathrm{d}E} \\right) B_0,\n$$\n因为 $F = 1 + B_0 u$，所以 $\\partial F / \\partial u = B_0$。将其代入 $K$ 的表达式中，得到\n$$\nK(u) = A \\, L \\, \\left( S + F^2 \\, \\frac{\\mathrm{d}S}{\\mathrm{d}E} \\right) \\, B_0^\\top B_0,\n$$\n这是一个对称的 $2 \\times 2$ 矩阵。这就是该单元的解析一致切向刚度，其单位为 $\\mathrm{N}/\\mathrm{m}$，因为 $A L$ 的单位是 $\\mathrm{m}^3$，$S + F^2 \\, \\mathrm{d}S/\\mathrm{d}E$ 的单位是 $\\mathrm{Pa}$，而 $B_0^\\top B_0$ 的单位是 $\\mathrm{m}^{-2}$。\n\n为了通过自动微分验证此切线刚度，为 $u_1$和 $u_2$ 实现前向模式对偶数。一个对偶数的形式为 $a + \\epsilon b$，其中 $\\epsilon^2 = 0$。当播种关于 $u_j$ 的导数时，设 $u_j = a + \\epsilon$，并将另一个位移设为 $\\epsilon$ 部分为零的常数对偶数。通过定义 $F$、$E$、$S$ 和 $P$ 的代数运算传播导数，然后计算 $r(u) = A L P B_0^\\top$。$r$ 的每个分量的导数部分即为雅可比矩阵中相对于被播种的自由度的相应列条目。对 $j = 1,2$ 重复此过程，即可得到完整的雅可比矩阵 $J_{\\text{AD}}(u)$。\n\n对于每个测试用例，计算 Frobenius 范数\n$$\n\\left\\| J_{\\text{AD}}(u) - K(u) \\right\\|_F = \\sqrt{ \\sum_{i=1}^2 \\sum_{j=1}^2 \\left( J_{\\text{AD}}(u)_{ij} - K(u)_{ij} \\right)^2 },\n$$\n如果两种实现是一致的，其值在机器精度范围内应接近零。对于每个测试用例，将此范数以 $\\mathrm{N}/\\mathrm{m}$ 为单位报告为浮点数，并采用指定的单行列表格式。\n\n算法设计：\n- 计算 $B_0 = \\begin{bmatrix} -1/L & 1/L \\end{bmatrix}$。\n- 实现一个 Dual 类，包含值和导数部分，并重载加、减、乘、除和整数幂的算术运算，以足以计算 $F$、$E$、$S$ 和 $P$。\n- 实现一个函数，该函数在给定 $u_1$ 和 $u_2$（可以是浮点数或对偶数）的情况下返回 $r(u)$。\n- 通过依次对 $u_1$ 和 $u_2$ 进行播种，并收集残差分量的导数，来构建自动微分雅可比矩阵。\n- 使用上述表达式实现解析的 $K(u)$。\n- 对于每个测试用例，计算两者之差的 Frobenius 范数，并以所需格式打印五个结果。所有输入均使用国际单位制（SI），范数的单位为 $\\mathrm{N}/\\mathrm{m}$。\n\n此方法将变形测量和超弹性的基本定义与有限元方法（FEM）中 Newton–Raphson 法所需的一致线性化相结合，并使用基于第一性原理的自动微分实现来验证结果。", "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"\n    Forward-mode dual number: value + eps * der, with eps^2 = 0.\n    Only supports operations needed for this problem.\n    \"\"\"\n    __slots__ = (\"val\", \"der\")\n    def __init__(self, val, der=0.0):\n        self.val = float(val)\n        self.der = float(der)\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val + other.val, self.der + other.der)\n        else:\n            return Dual(self.val + other, self.der)\n    def __radd__(self, other):\n        return self.__add__(other)\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val - other.val, self.der - other.der)\n        else:\n            return Dual(self.val - other, self.der)\n    def __rsub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(other.val - self.val, other.der - self.der)\n        else:\n            return Dual(other - self.val, -self.der)\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val * other.val, self.val * other.der + self.der * other.val)\n        else:\n            return Dual(self.val * other, self.der * other)\n    def __rmul__(self, other):\n        return self.__mul__(other)\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            # (a + eb) / (c + ed) = (a/c) + e*( (b*c - a*d) / c^2 )\n            a, b = self.val, self.der\n            c, d = other.val, other.der\n            return Dual(a / c, (b * c - a * d) / (c * c))\n        else:\n            return Dual(self.val / other, self.der / other)\n    def __rtruediv__(self, other):\n        # other / self\n        if isinstance(other, Dual):\n            return other.__truediv__(self)\n        else:\n            # (c) / (a + e b) = (c/a) + e*(-c*b/a^2)\n            a, b = self.val, self.der\n            return Dual(other / a, (-other * b) / (a * a))\n    def __pow__(self, n):\n        # integer power only\n        if not isinstance(n, int):\n            raise TypeError(\"Dual power only supports integer exponents.\")\n        if n == 0:\n            return Dual(1.0, 0.0)\n        # Chain rule: d(u^n)/dx = n * u^(n-1) * du/dx\n        val_pow_n_minus_1 = self.val**(n - 1)\n        new_val = self.val * val_pow_n_minus_1\n        new_der = n * val_pow_n_minus_1 * self.der\n        return Dual(new_val, new_der)\n\n    def __neg__(self):\n        return Dual(-self.val, -self.der)\n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n\ndef residual_dual(u1, u2, L, A, E0, alpha, beta):\n    \"\"\"\n    Compute the internal residual vector r(u) = A * L * P * B0^T\n    for the 2-node 1D bar in Total Lagrangian form.\n    Inputs u1 and u2 can be floats or Duals.\n    Returns a tuple (r1, r2) where each entry is of the same type as u1/u2 (float or Dual).\n    \"\"\"\n    B0_1 = -1.0 / L\n    B0_2 =  1.0 / L\n    # F = 1 + u' = 1 + B0 * u\n    F = 1.0 + (B0_1 * u1 + B0_2 * u2)\n    # E = 0.5 * (F^2 - 1)\n    E = 0.5 * (F**2 - 1.0)\n    # S(E) = E0 * (E + alpha E^2 + beta E^3)\n    S = E0 * (E + alpha * (E**2) + beta * (E**3))\n    # P = F * S\n    P = F * S\n    # r = A * L * P * B0^T\n    r1 = A * L * P * B0_1\n    r2 = A * L * P * B0_2\n    return r1, r2\n\ndef jacobian_autodiff(u_vec, L, A, E0, alpha, beta):\n    \"\"\"\n    Compute the 2x2 Jacobian of residual via forward-mode AD by seeding u1 and u2.\n    \"\"\"\n    u1, u2 = u_vec\n    # Column with respect to u1\n    r1_d1, r2_d1 = residual_dual(Dual(u1, 1.0), Dual(u2, 0.0), L, A, E0, alpha, beta)\n    col1 = np.array([r1_d1.der, r2_d1.der], dtype=float)\n    # Column with respect to u2\n    r1_d2, r2_d2 = residual_dual(Dual(u1, 0.0), Dual(u2, 1.0), L, A, E0, alpha, beta)\n    col2 = np.array([r1_d2.der, r2_d2.der], dtype=float)\n    J = np.column_stack((col1, col2))\n    return J\n\ndef tangent_analytic(u_vec, L, A, E0, alpha, beta):\n    \"\"\"\n    Analytic consistent tangent K(u) = A * L * (S + F^2 dS/dE) * (B0 ⊗ B0).\n    \"\"\"\n    u1, u2 = u_vec\n    B0 = np.array([-1.0 / L, 1.0 / L], dtype=float)\n    F = 1.0 + B0.dot(np.array([u1, u2], dtype=float))\n    E = 0.5 * (F * F - 1.0)\n    S = E0 * (E + alpha * E * E + beta * E * E * E)\n    dSdE = E0 * (1.0 + 2.0 * alpha * E + 3.0 * beta * E * E)\n    dP_dF = S + F * F * dSdE\n    K = A * L * dP_dF * np.outer(B0, B0)\n    return K\n\ndef frobenius_norm(M):\n    return float(np.linalg.norm(M, 'fro'))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L [m], A [m^2], E0 [Pa], alpha [-], beta [-], u1 [m], u2 [m])\n    test_cases = [\n        (2.0, 0.01, 210e9, 0.1, 0.05, 1e-3, 3e-3),       # Case 1\n        (1.0, 0.02, 100e9, 0.15, 0.05, 0.0, 0.0),        # Case 2\n        (3.0, 0.005, 70e9, 0.0, 0.0, 4e-3, 1e-3),        # Case 3\n        (0.2, 0.0005, 120e9, 0.2, 0.1, 0.01, -0.005),    # Case 4\n        (1.0, 0.001, 1.0e9, 0.3, 0.2, 0.15, 0.0),        # Case 5\n    ]\n\n    results = []\n    for (L, A, E0, alpha, beta, u1, u2) in test_cases:\n        u_vec = (u1, u2)\n        J = jacobian_autodiff(u_vec, L, A, E0, alpha, beta)\n        K = tangent_analytic(u_vec, L, A, E0, alpha, beta)\n        err = frobenius_norm(J - K)  # Units: N/m\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2547600"}]}