{"hands_on_practices": [{"introduction": "掌握有限应变运动学的核心在于能够从给定的变形映射出发，熟练计算关键的运动学量。这个练习将引导您完成一个经典的简单剪切变形案例，通过从头推导变形梯度 $\\mathbf{F}$、右 Cauchy-Green 变形张量 $\\mathbf{C}$ 以及 Green-Lagrange 应变张量 $\\mathbf{E}$，您将亲身体验有限应变理论如何揭示线性理论中被忽略的二阶效应，例如剪切引起的法向应变。[@problem_id:2558923]", "problem": "考虑一个连续体中的均匀单剪切运动，其从具有物质坐标 $\\boldsymbol{X} = (X_{1}, X_{2}, X_{3})$ 的参考构型到具有空间坐标 $\\boldsymbol{x} = (x_{1}, x_{2}, x_{3})$ 的当前构型的映射由下式给出\n$$\nx_{1} = X_{1} + \\kappa X_{2}, \\quad x_{2} = X_{2}, \\quad x_{3} = X_{3},\n$$\n其中 $\\kappa$ 是一个常数剪切参数。严格从变形梯度、右柯西-格林变形张量和格林-拉格朗日应变张量的运动学定义出发，推导变形梯度，然后计算右柯西-格林张量 $\\boldsymbol{C}$ 和格林-拉格朗日应变张量 $\\boldsymbol{E}$。用 $\\kappa$ 表示 $\\boldsymbol{E}$ 的剪切分量 $E_{12}$ 和正应变分量 $E_{11}$、$E_{22}$ 和 $E_{33}$。\n\n将您的最终答案表示为一个包含有序项的单个行向量\n$$\n\\big[C_{11},\\; C_{12},\\; C_{22},\\; C_{33},\\; E_{11},\\; E_{12},\\; E_{22},\\; E_{33}\\big],\n$$\n并用 $\\kappa$ 进行符号化表示。不需要进行数值近似，这些运动学量也没有单位。", "solution": "在尝试任何求解之前，将对问题陈述进行验证。\n\n首先，提取已知条件：\n- 物质坐标：$\\boldsymbol{X} = (X_{1}, X_{2}, X_{3})$。\n- 空间坐标：$\\boldsymbol{x} = (x_{1}, x_{2}, x_{3})$。\n- 变形映射：$x_{1} = X_{1} + \\kappa X_{2}$，$x_{2} = X_{2}$，$x_{3} = X_{3}$。\n- 参数 $\\kappa$ 是一个常数。\n- 任务是推导变形梯度 $\\boldsymbol{F}$、右柯西-格林变形张量 $\\boldsymbol{C}$ 和格林-拉格朗日应变张量 $\\boldsymbol{E}$。\n- 最终输出必须是特定分量的行向量：$\\big[C_{11},\\; C_{12},\\; C_{22},\\; C_{33},\\; E_{11},\\; E_{12},\\; E_{22},\\; E_{33}\\big]$。\n\n接下来，对问题进行验证。\n该问题描述了均匀单剪切变形，这是有限应变连续介质力学中的一个标准和基本概念。所要求的变形梯度 $\\boldsymbol{F}$、右柯西-格林张量 $\\boldsymbol{C}$ 和格林-拉格朗日应变张量 $\\boldsymbol{E}$ 的定义都是标准的运动学量。该问题是自洽的、数学上一致的、有科学依据且适定的。它不违反任何物理定律，没有歧义，并包含了获得唯一解所需的所有信息。因此，该问题被认为是**有效的**。\n\n求解过程通过逐步应用所需运动学张量的定义来进行。\n\n变形梯度张量 $\\boldsymbol{F}$ 通过关系式 $d\\boldsymbol{x} = \\boldsymbol{F} d\\boldsymbol{X}$，将参考构型中的无穷小矢量 $d\\boldsymbol{X}$ 与其在当前构型中的对应矢量 $d\\boldsymbol{x}$ 联系起来。$\\boldsymbol{F}$ 的分量定义为 $F_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}$。\n使用给定的映射，对 $i,j \\in \\{1, 2, 3\\}$ 计算各分量如下：\n$F_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}} (X_{1} + \\kappa X_{2}) = 1$\n$F_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}} (X_{1} + \\kappa X_{2}) = \\kappa$\n$F_{13} = \\frac{\\partial x_{1}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}} (X_{1} + \\kappa X_{2}) = 0$\n$F_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}} (X_{2}) = 0$\n$F_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}} (X_{2}) = 1$\n$F_{23} = \\frac{\\partial x_{2}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}} (X_{2}) = 0$\n$F_{31} = \\frac{\\partial x_{3}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}} (X_{3}) = 0$\n$F_{32} = \\frac{\\partial x_{3}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}} (X_{3}) = 0$\n$F_{33} = \\frac{\\partial x_{3}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}} (X_{3}) = 1$\n\n变形梯度张量的矩阵形式为：\n$$\n\\boldsymbol{F} = \\begin{pmatrix} 1 & \\kappa & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\n接下来，计算右柯西-格林变形张量 $\\boldsymbol{C}$。其定义为 $\\boldsymbol{C} = \\boldsymbol{F}^{T}\\boldsymbol{F}$，其中 $\\boldsymbol{F}^{T}$ 是 $\\boldsymbol{F}$ 的转置。\n$$\n\\boldsymbol{F}^{T} = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\kappa & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\n\\boldsymbol{C} = \\boldsymbol{F}^{T}\\boldsymbol{F} = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\kappa & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\kappa & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} (1)(1) + (0)(0) + (0)(0) & (1)(\\kappa) + (0)(1) + (0)(0) & (1)(0) + (0)(0) + (0)(1) \\\\ (\\kappa)(1) + (1)(0) + (0)(0) & (\\kappa)(\\kappa) + (1)(1) + (0)(0) & (\\kappa)(0) + (1)(0) + (0)(1) \\\\ (0)(1) + (0)(0) + (1)(0) & (0)(\\kappa) + (0)(1) + (1)(0) & (0)(0) + (0)(0) + (1)(1) \\end{pmatrix}\n$$\n$$\n\\boldsymbol{C} = \\begin{pmatrix} 1 & \\kappa & 0 \\\\ \\kappa & 1 + \\kappa^{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n从该矩阵中，我们确定所需的分量：\n$C_{11} = 1$\n$C_{12} = \\kappa$\n$C_{22} = 1 + \\kappa^{2}$\n$C_{33} = 1$\n\n最后，推导格林-拉格朗日应变张量 $\\boldsymbol{E}$。其定义为 $\\boldsymbol{E} = \\frac{1}{2}(\\boldsymbol{C} - \\boldsymbol{I})$，其中 $\\boldsymbol{I}$ 是二阶单位张量。\n$$\n\\boldsymbol{E} = \\frac{1}{2} \\left( \\begin{pmatrix} 1 & \\kappa & 0 \\\\ \\kappa & 1 + \\kappa^{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0 & \\kappa & 0 \\\\ \\kappa & \\kappa^{2} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{E} = \\begin{pmatrix} 0 & \\frac{\\kappa}{2} & 0 \\\\ \\frac{\\kappa}{2} & \\frac{\\kappa^{2}}{2} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n$\\boldsymbol{E}$ 的分量为：\n$E_{11} = 0$\n$E_{12} = \\frac{\\kappa}{2}$\n$E_{22} = \\frac{\\kappa^{2}}{2}$\n$E_{33} = 0$\n\n注意到，单剪切变形引起了一个非零的正应变分量 $E_{22} = \\frac{\\kappa^{2}}{2}$。这是有限应变理论的一个特点，它与忽略了此类二阶效应的无穷小应变理论有所区别。\n\n将所需分量组合成指定的行向量格式，构建最终答案。\n各分量为：\n$C_{11} = 1$\n$C_{12} = \\kappa$\n$C_{22} = 1 + \\kappa^{2}$\n$C_{33} = 1$\n$E_{11} = 0$\n$E_{12} = \\frac{\\kappa}{2}$\n$E_{22} = \\frac{\\kappa^{2}}{2}$\n$E_{33} = 0$\n行向量为 $\\big[1,\\; \\kappa,\\; 1+\\kappa^{2},\\; 1,\\; 0,\\; \\frac{\\kappa}{2},\\; \\frac{\\kappa^{2}}{2},\\; 0\\big]$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & \\kappa & 1+\\kappa^{2} & 1 & 0 & \\frac{\\kappa}{2} & \\frac{\\kappa^{2}}{2} & 0 \\end{pmatrix}}\n$$", "id": "2558923"}, {"introduction": "在工程实践中，我们常常需要在精确的有限应变理论和简化的线性应变理论之间做出选择。本练习通过一个具体的平面剪切问题，让您定量地比较 Green-Lagrange 应变张量 $\\mathbf{E}$ 与线性应变张量 $\\boldsymbol{\\varepsilon}$ 的差异。通过计算不同剪切量下的误差，您将对线性理论的适用范围以及有限应变描述的必要性形成深刻的直观理解。[@problem_id:2558928]", "problem": "在有限元法 (FEM) 的背景下，考虑一个由变形梯度 $F \\in \\mathbb{R}^{2 \\times 2}$ 表征的均匀平面变形，其表达式为\n$$\nF = \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix},\n$$\n其中 $\\kappa \\in \\mathbb{R}$ 是一个恒定的剪切参数。仅使用有限应变运动学的基本定义，完成以下任务：\n\n1. 从右 Cauchy–Green 变形张量定义 $C = F^{\\mathsf{T}} F$ 和 Green–Lagrange 应变定义 $E = \\tfrac{1}{2}(C - I)$ 出发，推导出 $E$ 作为 $\\kappa$ 的显式函数。\n\n2. 对于同一映射，通过 $x = F X$ 定义位移场，使得位移梯度为 $\\nabla_X u = F - I$。使用线性化小应变定义 $\\varepsilon = \\tfrac{1}{2}(\\nabla_X u + \\nabla_X u^{\\mathsf{T}})$，推导出 $\\varepsilon$ 作为 $\\kappa$ 的显式函数。\n\n3. 为了量化有限应变运动学和线性化运动学之间的差异，设比较度量为二者之差的 Frobenius 范数，\n$$\ns(\\kappa) := \\| E - \\varepsilon \\|_F.\n$$\n计算当 $\\kappa = 0.2$ 和 $\\kappa = 1$ 时 $s(\\kappa)$ 的值。应变是无量纲的，因此将这两个值作为无量纲数报告。\n\n以单行矩阵 $\\begin{pmatrix} s(0.2) & s(1) \\end{pmatrix}$ 的形式提供最终答案。不包括单位。无需四舍五入；给出精确的小数值。", "solution": "我们从有限应变理论中的基本运动学定义开始。\n\n1. 计算 Green–Lagrange 应变 $E$。\n- 右 Cauchy–Green 变形张量定义为 $C = F^{\\mathsf{T}} F$。对于\n$$\nF = \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix},\n$$\n我们有\n$$\nF^{\\mathsf{T}} = \\begin{bmatrix} 1 & 0 \\\\ \\kappa & 1 \\end{bmatrix},\n\\quad\nC = F^{\\mathsf{T}} F = \\begin{bmatrix} 1 & 0 \\\\ \\kappa & 1 \\end{bmatrix} \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix}\n= \\begin{bmatrix} 1 & \\kappa \\\\ \\kappa & \\kappa^{2} + 1 \\end{bmatrix}.\n$$\n- Green–Lagrange 应变为 $E = \\tfrac{1}{2}(C - I)$，因此\n$$\nE = \\tfrac{1}{2} \\left( \\begin{bmatrix} 1 & \\kappa \\\\ \\kappa & \\kappa^{2} + 1 \\end{bmatrix} - \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\right)\n= \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & \\kappa^{2} \\end{bmatrix}.\n$$\n\n2. 计算线性化小应变 $\\varepsilon$。\n- 对于均匀变形 $x = F X$，位移为 $u = x - X = (F - I) X$，因此相对于参考构型的位移梯度为 $\\nabla_X u = F - I$。\n- 对于 $F = \\begin{bmatrix} 1 & \\kappa \\\\ 0 & 1 \\end{bmatrix}$，我们有\n$$\n\\nabla_X u = F - I = \\begin{bmatrix} 0 & \\kappa \\\\ 0 & 0 \\end{bmatrix}.\n$$\n- 线性化小应变张量为 $\\varepsilon = \\tfrac{1}{2}(\\nabla_X u + \\nabla_X u^{\\mathsf{T}})$，所以\n$$\n\\varepsilon = \\tfrac{1}{2} \\left( \\begin{bmatrix} 0 & \\kappa \\\\ 0 & 0 \\end{bmatrix} + \\begin{bmatrix} 0 & 0 \\\\ \\kappa & 0 \\end{bmatrix} \\right)\n= \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & 0 \\end{bmatrix}.\n$$\n\n3. 定义并计算比较度量。\n- 矩阵 $A$ 的 Frobenius 范数为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^{2}}$。\n- 考虑其差值\n$$\nE - \\varepsilon = \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & \\kappa^{2} \\end{bmatrix} - \\tfrac{1}{2} \\begin{bmatrix} 0 & \\kappa \\\\ \\kappa & 0 \\end{bmatrix}\n= \\tfrac{1}{2} \\begin{bmatrix} 0 & 0 \\\\ 0 & \\kappa^{2} \\end{bmatrix}.\n$$\n- 因此，\n$$\ns(\\kappa) = \\|E - \\varepsilon\\|_F = \\left\\| \\tfrac{1}{2} \\begin{bmatrix} 0 & 0 \\\\ 0 & \\kappa^{2} \\end{bmatrix} \\right\\|_F\n= \\tfrac{1}{2} \\sqrt{0^{2} + 0^{2} + 0^{2} + (\\kappa^{2})^{2}}\n= \\tfrac{1}{2} \\kappa^{2}.\n$$\n- 计算指定值：\n$$\ns(0.2) = \\tfrac{1}{2} (0.2)^{2} = \\tfrac{1}{2} \\cdot 0.04 = 0.02,\n\\quad\ns(1) = \\tfrac{1}{2} (1)^{2} = 0.5.\n$$\n\n所要求的最终答案是具有精确小数值的行矩阵 $\\begin{pmatrix} s(0.2) & s(1) \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}0.02 & 0.5\\end{pmatrix}}$$", "id": "2558928"}, {"introduction": "任何有效的应变度量都必须满足客观性原理，即在刚体运动下应变为零。Green-Lagrange 应变张量 $\\mathbf{E}$ 的一个核心优势就在于其内在满足这一特性。这个计算实践要求您编写一个程序，在有限元框架下从基本原理出发，数值验证不同类型的单元在经历纯刚体旋转时，计算出的 $\\mathbf{E}$ 在机器精度内确实为零，从而将理论概念与计算实现紧密联系起来。[@problem_id:2558930]", "problem": "考虑在刚体运动下，有限元法中的大应变运动学。设参考构型由物质坐标 $\\mathbf{X}$ 参数化，当前构型由空间坐标 $\\mathbf{x}$ 参数化。变形梯度定义为 $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$。右 Cauchy-Green 张量为 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$，Green-Lagrange 应变为 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$。在纯刚性旋转下，Green-Lagrange 应变必须恒等于零。\n\n您的任务是编写一个程序，对几个经受纯旋转（可能带有平移）的有限元网格，数值验证此不变性。验证必须从基本原理出发：从 $\\mathbf{F}$ 和 $\\mathbf{E}$ 的定义开始，并使用链式法则构建单元级映射。避免引入任何未经推导的简化公式。\n\n为每个测试用例实现以下步骤：\n- 根据指定的参数构造一个旋转映射 $\\mathbf{R}$（二维或三维），并定义一个刚体运动 $\\mathbf{x}(\\mathbf{X}) = \\mathbf{R}\\,\\mathbf{X} + \\mathbf{c}$，其中 $\\mathbf{c}$ 是一个常数平移向量。角度必须以弧度为单位进行解释。\n- 对于每个单元，使用等参概念和链式法则，在适当的积分点上计算变形梯度 $\\mathbf{F}$。具体来说：\n  - 对于线性单纯元（二维中的线性三角形和三维中的线性四面体），需认识到其在 $\\mathbf{X}$ 中的插值是仿射的，因此 $\\mathbf{F}$ 在单元内是常数；根据节点值所蕴含的离散映射来一致地计算它。\n  - 对于二维中的双线性四边形单元，通过组合从母坐标到 $\\mathbf{X}$ 和到 $\\mathbf{x}$ 的映射，在一组 Gauss 点上计算 $\\mathbf{F}$，并使用链式法则得到 $\\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$。\n- 对于每个积分点，计算 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ 和 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$，然后在单元中的所有积分点和所有张量分量上，取 $\\mathbf{E}$ 分量的最大绝对值。\n- 将此最大值与指定的容差 $\\tau = 10^{-12}$ 进行比较。如果该值小于或等于 $\\tau$，则该测试用例的结果为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n使用以下测试套件。在每种情况下，程序必须通过将指定的刚体运动应用于给定的参考节点坐标，来内部生成当前节点坐标。所有角度均以弧度为单位给出，输出必须是无量纲的布尔值。\n\n- 测试用例 $1$（二维线性三角形）：\n  - 参考节点 $\\mathbf{X}_1 = [0,0]$，$\\mathbf{X}_2 = [1,0]$，$\\mathbf{X}_3 = [0.2,0.8]$。\n  - 绕原点的旋转角 $\\alpha = 0.7$，平移 $\\mathbf{c} = [0.3,-0.4]$。\n- 测试用例 $2$（在 $2 \\times 2$ Gaussian 积分点上求值的二维双线性四边形）：\n  - 按顺序的参考节点 $\\mathbf{X}_1 = [0.0,0.0]$，$\\mathbf{X}_2 = [2.0,0.5]$，$\\mathbf{X}_3 = [2.1,1.8]$，$\\mathbf{X}_4 = [-0.2,1.5]$。\n  - 旋转角 $\\alpha = 0.3$，平移 $\\mathbf{c} = [-0.1,0.2]$。\n- 测试用例 $3$（三维线性四面体）：\n  - 参考节点 $\\mathbf{X}_1 = [0.0,0.0,0.0]$，$\\mathbf{X}_2 = [1.0,0.1,0.0]$，$\\mathbf{X}_3 = [0.2,1.1,0.3]$，$\\mathbf{X}_4 = [0.1,0.2,1.2]$。\n  - 绕轴 $\\mathbf{u} = [1,2,3]$ 旋转角度 $\\theta = 0.9$，平移 $\\mathbf{c} = [0.5,-0.4,0.3]$。\n- 测试用例 $4$（在 $2 \\times 2$ Gaussian 积分点上求值的二维双线性四边形，半转的边界情况）：\n  - 按顺序的参考节点 $\\mathbf{X}_1 = [-1.0,0.0]$，$\\mathbf{X}_2 = [1.0,0.2]$，$\\mathbf{X}_3 = [1.5,1.3]$，$\\mathbf{X}_4 = [-0.5,1.0]$。\n  - 旋转角 $\\alpha = \\pi$，平移 $\\mathbf{c} = [1.0,-2.0]$。\n- 测试用例 $5$（二维线性三角形，单位旋转）：\n  - 参考节点 $\\mathbf{X}_1 = [0.0,0.0]$，$\\mathbf{X}_2 = [2.0,0.0]$，$\\mathbf{X}_3 = [0.0,1.0]$。\n  - 旋转角 $\\alpha = 0.0$，平移 $\\mathbf{c} = [10.0,10.0]$。\n- 测试用例 $6$（三维线性四面体，整周转）：\n  - 参考节点 $\\mathbf{X}_1 = [0.0,0.0,0.0]$，$\\mathbf{X}_2 = [0.8,0.1,0.0]$，$\\mathbf{X}_3 = [0.2,0.9,0.4]$，$\\mathbf{X}_4 = [0.1,0.3,1.1]$。\n  - 绕轴 $\\mathbf{u} = [0.0,1.0,1.0]$ 旋转角度 $\\theta = 2\\pi$，平移 $\\mathbf{c} = [-0.3,0.2,-0.1]$。\n\n您的程序必须：\n- 通过将指定的刚体运动应用于参考节点，为每个测试构建当前构型。\n- 如前所述计算变形梯度和 Green-Lagrange 应变。\n- 对于每个测试，返回一个布尔值，指示该测试中 $\\mathbf{E}$ 的最大绝对分量是否小于或等于 $\\tau = 10^{-12}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True}\\right]$）。该列表必须恰好包含 $6$ 个布尔值，每个测试用例一个，并按上述顺序排列。", "solution": "问题陈述提出了一个植根于连续介质力学和有限元法基本原理的数值验证任务。在提供解决方案之前，必须严格确定其有效性。\n\n该问题具有科学依据。它涉及大应变运动学，这是连续介质力学的一块基石。所提供的变形梯度 $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$、右 Cauchy-Green 张量 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$ 以及 Green-Lagrange 应变张量 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$ 的定义都是标准且正确的。其核心前提，即对于纯刚体运动 $\\mathbf{E}$ 必须恒等于零，是一个基本且可证明的事实。刚体运动由映射 $\\mathbf{x}(\\mathbf{X}) = \\mathbf{R}\\mathbf{X} + \\mathbf{c}$ 描述，其中 $\\mathbf{R}$ 是一个满足 $\\mathbf{R}^{\\mathsf{T}}\\mathbf{R} = \\mathbf{I}$ 的常数旋转张量，$\\mathbf{c}$ 是一个常数平移向量。因此，变形梯度为 $\\mathbf{F} = \\frac{\\partial}{\\partial \\mathbf{X}}(\\mathbf{R}\\mathbf{X} + \\mathbf{c}) = \\mathbf{R}$。所以，$\\mathbf{C} = \\mathbf{R}^{\\mathsf{T}}\\mathbf{R} = \\mathbf{I}$，这导致 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{I}) = \\mathbf{0}$。该问题要求使用有限元结构对此解析结果进行数值验证，这是计算力学中用于代码验证的标准且有意义的程序。\n\n该问题是适定且自洽的。它为每个测试用例提供了所有必要信息：单元类型、参考节点坐标以及刚体运动的参数。计算过程有足够详细的说明，包括使用等参公式、变形梯度的链式法则以及四边形单元的特定积分规则。通过将计算出的应变分量的最大绝对值与指定的容差 $\\tau = 10^{-12}$ 进行比较，给出了一个清晰、客观的成功标准。没有内部矛盾、歧义或缺失数据。所有的科学和数学前提都是合理的。\n\n因此，该问题被认为是有效的。现在将提出一个解决方案。\n\n解决方法如下。对于每个测试用例，我们首先通过将指定的刚体运动 $\\mathbf{x}_i = \\mathbf{R}\\mathbf{X}_i + \\mathbf{c}$ 应用于参考节点坐标 $\\mathbf{X}_i$ 来计算当前节点坐标 $\\mathbf{x}_i$。旋转矩阵 $\\mathbf{R}$ 和平移向量 $\\mathbf{c}$ 是根据给定参数构造的。任务的核心是在有限元框架内计算变形梯度 $\\mathbf{F}$。\n\n等参公式将母坐标 $\\boldsymbol{\\xi}$ 中的简单母单元映射到参考构型 $\\mathbf{X}(\\boldsymbol{\\xi})$ 和当前构型 $\\mathbf{x}(\\boldsymbol{\\xi})$ 中的物理单元。这些映射使用形函数 $N_i(\\boldsymbol{\\xi})$ 从节点值进行插值：\n$$ \\mathbf{X}(\\boldsymbol{\\xi}) = \\sum_{i} N_i(\\boldsymbol{\\xi}) \\mathbf{X}_i \\quad \\text{和} \\quad \\mathbf{x}(\\boldsymbol{\\xi}) = \\sum_{i} N_i(\\boldsymbol{\\xi}) \\mathbf{x}_i $$\n变形梯度 $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$ 使用链式法则计算：\n$$ \\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} \\left( \\frac{\\partial \\mathbf{X}}{\\partial \\boldsymbol{\\xi}} \\right)^{-1} $$\n此处，$\\frac{\\partial \\mathbf{X}}{\\partial \\boldsymbol{\\xi}} = \\mathbf{J}_X$ 是从母坐标到参考坐标映射的雅可比矩阵，而 $\\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}} = \\mathbf{J}_x$ 是从母坐标到当前坐标映射的雅可比矩阵。因此，$\\mathbf{F} = \\mathbf{J}_x \\mathbf{J}_X^{-1}$。问题正确地要求从基本原理执行此计算，而不是使用解析捷径 $\\mathbf{F}=\\mathbf{R}$，以验证数值实现本身的正确性。\n\n对于线性单纯元（二维中的三角形，三维中的四面体），形函数是线性的，因此雅可比矩阵 $\\mathbf{J}_X$ 和 $\\mathbf{J}_x$ 在整个单元内是常数。对于 $d$ 维空间中具有节点 $1, 2, \\ldots, d+1$ 的单纯形，雅可比矩阵可以直接由从一个公共节点（例如节点 1）出发形成的边向量构造：\n$$ \\mathbf{J}_X = [ \\mathbf{X}_2 - \\mathbf{X}_1, \\ldots, \\mathbf{X}_{d+1} - \\mathbf{X}_1 ] $$\n对于 $\\mathbf{J}_x$ 也类似。变形梯度 $\\mathbf{F}$ 则在单元内是常数。\n\n对于双线性四边形单元，映射不是仿射的，并且 $\\mathbf{F}$ 不是常数。它必须在特定的积分点上进行计算。对于 $2 \\times 2$ Gauss 积分，我们在四个点 $(\\xi_k, \\eta_k) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ 处计算 $\\mathbf{F}$。在每个点上，雅可比矩阵使用形函数的梯度来计算：\n$$ \\mathbf{J}_X(\\xi_k, \\eta_k) = \\begin{bmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} X_{i,1} & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} X_{i,1} \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\xi} X_{i,2} & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} X_{i,2} \\end{bmatrix} $$\n其中导数在 $(\\xi_k, \\eta_k)$ 处求值。$\\mathbf{J}_x$ 的计算方式类似。\n\n旋转矩阵的构造如下：\n在二维中，对于逆时针旋转角度 $\\alpha$：\n$$ \\mathbf{R} = \\begin{bmatrix} \\cos\\alpha & -\\sin\\alpha \\\\ \\sin\\alpha & \\cos\\alpha \\end{bmatrix} $$\n在三维中，对于绕单位轴 $\\hat{\\mathbf{u}}$ 旋转角度 $\\theta$，Rodrigues 公式给出：\n$$ \\mathbf{R} = \\cos\\theta \\, \\mathbf{I} + \\sin\\theta \\, [\\hat{\\mathbf{u}}]_\\times + (1-\\cos\\theta) \\, (\\hat{\\mathbf{u}} \\otimes \\hat{\\mathbf{u}}) $$\n其中 $[\\hat{\\mathbf{u}}]_\\times$是 $\\hat{\\mathbf{u}}$ 的叉积矩阵。\n\n在每个所需点（对于单纯形是单元中心，对于四边形是每个 Gauss 点）计算出 $\\mathbf{F}$ 后，计算相应的 Green-Lagrange 应变张量 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} - \\mathbf{I})$。然后，将给定测试用例中所有计算出的 $\\mathbf{E}$ 张量的所有分量的最大绝对值与容差 $\\tau=10^{-12}$ 进行比较。如果此最大值小于或等于 $\\tau$，则结果为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。对六个指定的测试用例中的每一个都实施此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix_2d(angle):\n    \"\"\"Constructs a 2D rotation matrix.\"\"\"\n    return np.array([\n        [np.cos(angle), -np.sin(angle)],\n        [np.sin(angle), np.cos(angle)]\n    ])\n\ndef get_rotation_matrix_3d(axis, angle):\n    \"\"\"Constructs a 3D rotation matrix using Rodrigues' formula.\"\"\"\n    u = np.asarray(axis)\n    norm_u = np.linalg.norm(u)\n    if norm_u == 0:\n        return np.eye(3)\n    u = u / norm_u\n    \n    I = np.eye(3)\n    u_cross = np.array([\n        [0, -u[2], u[1]],\n        [u[2], 0, -u[0]],\n        [-u[1], u[0], 0]\n    ])\n    u_outer = np.outer(u, u)\n    \n    R = np.cos(angle) * I + np.sin(angle) * u_cross + (1 - np.cos(angle)) * u_outer\n    return R\n\ndef verify_triangle_2d(X_nodes, angle, trans_vec):\n    \"\"\"Verifies Green-Lagrange strain for a 2D linear triangle.\"\"\"\n    R = get_rotation_matrix_2d(angle)\n    x_nodes = (R @ X_nodes.T).T + trans_vec\n\n    # For linear triangles, F is constant.\n    # J_X = [X2-X1, X3-X1] as columns\n    J_X = (X_nodes[1:] - X_nodes[0]).T\n    J_x = (x_nodes[1:] - x_nodes[0]).T\n\n    F = J_x @ np.linalg.inv(J_X)\n    C = F.T @ F\n    I = np.eye(2)\n    E = 0.5 * (C - I)\n    \n    return np.max(np.abs(E))\n\ndef verify_quad_2d(X_nodes, angle, trans_vec):\n    \"\"\"Verifies Green-Lagrange strain for a 2D bilinear quadrilateral.\"\"\"\n    R = get_rotation_matrix_2d(angle)\n    x_nodes = (R @ X_nodes.T).T + trans_vec\n\n    # 2x2 Gauss quadrature points\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    \n    max_E_abs = 0.0\n\n    for xi, eta in gauss_points:\n        # Shape function derivatives w.r.t. parent coordinates (xi, eta)\n        # N_i(xi, eta) = 0.25 * (1 + xi_i*xi) * (1 + eta_i*eta)\n        # d(N_i)/d(xi) = 0.25 * xi_i * (1 + eta_i*eta)\n        # d(N_i)/d(eta) = 0.25 * eta_i * (1 + xi_i*xi)\n        dN_dxi = np.array([\n            -0.25 * (1 - eta),\n             0.25 * (1 - eta),\n             0.25 * (1 + eta),\n            -0.25 * (1 + eta)\n        ])\n        dN_deta = np.array([\n            -0.25 * (1 - xi),\n            -0.25 * (1 + xi),\n             0.25 * (1 + xi),\n             0.25 * (1 - xi)\n        ])\n        \n        # Jacobian from parent to reference and current configurations\n        J_X = np.zeros((2, 2))\n        J_X[0, 0] = np.dot(dN_dxi, X_nodes[:, 0])\n        J_X[0, 1] = np.dot(dN_deta, X_nodes[:, 0])\n        J_X[1, 0] = np.dot(dN_dxi, X_nodes[:, 1])\n        J_X[1, 1] = np.dot(dN_deta, X_nodes[:, 1])\n        \n        J_x = np.zeros((2, 2))\n        J_x[0, 0] = np.dot(dN_dxi, x_nodes[:, 0])\n        J_x[0, 1] = np.dot(dN_deta, x_nodes[:, 0])\n        J_x[1, 0] = np.dot(dN_dxi, x_nodes[:, 1])\n        J_x[1, 1] = np.dot(dN_deta, x_nodes[:, 1])\n        \n        F = J_x @ np.linalg.inv(J_X)\n        C = F.T @ F\n        I = np.eye(2)\n        E = 0.5 * (C - I)\n        \n        max_E_abs = max(max_E_abs, np.max(np.abs(E)))\n        \n    return max_E_abs\n\ndef verify_tetrahedron_3d(X_nodes, axis, angle, trans_vec):\n    \"\"\"Verifies Green-Lagrange strain for a 3D linear tetrahedron.\"\"\"\n    R = get_rotation_matrix_3d(axis, angle)\n    x_nodes = (R @ X_nodes.T).T + trans_vec\n\n    # For linear tetrahedra, F is constant.\n    J_X = (X_nodes[1:] - X_nodes[0]).T\n    J_x = (x_nodes[1:] - x_nodes[0]).T\n    \n    F = J_x @ np.linalg.inv(J_X)\n    C = F.T @ F\n    I = np.eye(3)\n    E = 0.5 * (C - I)\n    \n    return np.max(np.abs(E))\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    tolerance = 1e-12\n\n    test_cases = [\n        # Test case 1\n        {\n            'type': 'tri2d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0], [1.0, 0.0], [0.2, 0.8]]),\n                'angle': 0.7, \n                'trans_vec': np.array([0.3, -0.4])\n            }\n        },\n        # Test case 2\n        {\n            'type': 'quad2d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0], [2.0, 0.5], [2.1, 1.8], [-0.2, 1.5]]),\n                'angle': 0.3, \n                'trans_vec': np.array([-0.1, 0.2])\n            }\n        },\n        # Test case 3\n        {\n            'type': 'tet3d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0, 0.0], [1.0, 0.1, 0.0], [0.2, 1.1, 0.3], [0.1, 0.2, 1.2]]),\n                'axis': np.array([1, 2, 3]), \n                'angle': 0.9, \n                'trans_vec': np.array([0.5, -0.4, 0.3])\n            }\n        },\n        # Test case 4\n        {\n            'type': 'quad2d', \n            'params': {\n                'X_nodes': np.array([[-1.0, 0.0], [1.0, 0.2], [1.5, 1.3], [-0.5, 1.0]]),\n                'angle': np.pi, \n                'trans_vec': np.array([1.0, -2.0])\n            }\n        },\n        # Test case 5\n        {\n            'type': 'tri2d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0], [2.0, 0.0], [0.0, 1.0]]),\n                'angle': 0.0, \n                'trans_vec': np.array([10.0, 10.0])\n            }\n        },\n        # Test case 6\n        {\n            'type': 'tet3d', \n            'params': {\n                'X_nodes': np.array([[0.0, 0.0, 0.0], [0.8, 0.1, 0.0], [0.2, 0.9, 0.4], [0.1, 0.3, 1.1]]),\n                'axis': np.array([0.0, 1.0, 1.0]), \n                'angle': 2 * np.pi, \n                'trans_vec': np.array([-0.3, 0.2, -0.1])\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_E = 0.0\n        if case['type'] == 'tri2d':\n            max_E = verify_triangle_2d(**case['params'])\n        elif case['type'] == 'quad2d':\n            max_E = verify_quad_2d(**case['params'])\n        elif case['type'] == 'tet3d':\n            max_E = verify_tetrahedron_3d(**case['params'])\n        \n        results.append(max_E = tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2558930"}]}