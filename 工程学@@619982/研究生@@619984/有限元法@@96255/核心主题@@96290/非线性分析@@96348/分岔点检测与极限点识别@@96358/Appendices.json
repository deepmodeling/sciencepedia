{"hands_on_practices": [{"introduction": "理论学习的最佳方式莫过于通过简化模型来掌握核心思想。本练习引导你分析一个简单的双自由度 (2-DOF) 非线性系统的势能，并推导出其平衡方程（残差向量 $R(u,\\lambda)$）和切线刚度矩阵 $K_T(u,\\lambda)$。通过求解 $\\det K_T = 0$ 的条件，你将亲手计算出系统在平凡平衡路径上发生分岔的临界载荷参数，从而直观地理解分岔点作为平衡路径失稳点的本质。[@problem_id:2542980]", "problem": "考虑一个无量纲的双自由度有限元 (FE) 离散化，其节点位移向量为 $u = \\begin{pmatrix} u_{1} & u_{2} \\end{pmatrix}^{\\mathsf{T}}$，以及一个标量载荷参数 $\\lambda$。设该系统的总势能定义为\n$$\n\\Pi(u,\\lambda) \\;=\\; \\frac{1}{2}\\,k\\,(u_{1}^{2}+u_{2}^{2}) \\;+\\; \\frac{c}{2}\\,(u_{1}-u_{2})^{2} \\;+\\; \\frac{\\gamma}{4}\\,(u_{1}^{4}+u_{2}^{4}) \\;-\\; \\frac{\\lambda}{2}\\,g\\,(u_{1}^{2}+u_{2}^{2}),\n$$\n其中 $k>0$，$c>0$，$g>0$ 和 $\\gamma \\ge 0$ 为常数。该能量模型描述了一对具有线性耦合和载荷相关几何软化项的对称非线性弹簧。\n\n利用平衡状态下总势能的驻值性，构建有限元残差向量 $R(u,\\lambda)$，其为 $\\Pi(u,\\lambda)$ 相对于 $u$ 的梯度，并计算一致切线刚度矩阵 $K_{T}(u,\\lambda)$，其为雅可比矩阵 $\\partial R/\\partial u$。然后将 $K_{T}(u,\\lambda)$ 特化到平凡平衡分支 $u=\\begin{pmatrix} 0 & 0 \\end{pmatrix}^{\\mathsf{T}}$，并确定所有使得 $\\det K_{T}(0,\\lambda)=0$ 的参数值 $\\lambda$。\n\n答案要求：\n- 以单行矩阵的形式给出两个临界参数值 $\\lambda$ 的集合作为最终答案。\n- 无需数值取整；请给出精确表达式。\n- 所有量均为无量纲，因此无需单位。", "solution": "该问题经验证在科学上是合理的、提法得当的、客观且完整的。这是非线性有限元分析中关于分岔点检测的一个标准练习。我们开始求解。\n\n系统的总势能由下式给出：\n$$\n\\Pi(u,\\lambda) = \\frac{1}{2} k (u_{1}^{2}+u_{2}^{2}) + \\frac{c}{2} (u_{1}-u_{2})^{2} + \\frac{\\gamma}{4} (u_{1}^{4}+u_{2}^{4}) - \\frac{\\lambda}{2} g (u_{1}^{2}+u_{2}^{2})\n$$\n其中 $u = \\begin{pmatrix} u_{1} & u_{2} \\end{pmatrix}^{\\mathsf{T}}$ 是节点位移向量，$\\lambda$ 是载荷参数，$k, c, g, \\gamma$ 是常数，且满足 $k>0$, $c>0$, $g>0$ 以及 $\\gamma \\ge 0$。\n\n平衡条件是势能的驻值条件，即 $\\delta \\Pi = 0$。这要求 $\\Pi$ 相对于位移向量 $u$ 的梯度为零。该梯度即为残差向量 $R(u, \\lambda)$。\n$$\nR(u, \\lambda) = \\nabla_{u} \\Pi(u, \\lambda) = \\begin{pmatrix} \\frac{\\partial \\Pi}{\\partial u_{1}} \\\\ \\frac{\\partial \\Pi}{\\partial u_{2}} \\end{pmatrix}\n$$\n我们计算其偏导数：\n$$\n\\frac{\\partial \\Pi}{\\partial u_{1}} = k u_{1} + c(u_{1}-u_{2}) + \\gamma u_{1}^{3} - \\lambda g u_{1} = (k+c-\\lambda g)u_{1} - c u_{2} + \\gamma u_{1}^{3}\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial u_{2}} = k u_{2} + c(u_{1}-u_{2})(-1) + \\gamma u_{2}^{3} - \\lambda g u_{2} = -c u_{1} + (k+c-\\lambda g)u_{2} + \\gamma u_{2}^{3}\n$$\n因此，残差向量为：\n$$\nR(u, \\lambda) = \\begin{pmatrix} (k+c-\\lambda g)u_{1} - c u_{2} + \\gamma u_{1}^{3} \\\\ -c u_{1} + (k+c-\\lambda g)u_{2} + \\gamma u_{2}^{3} \\end{pmatrix}\n$$\n接下来，我们计算一致切线刚度矩阵 $K_{T}(u, \\lambda)$，它是残差向量 $R$ 关于位移向量 $u$ 的雅可比矩阵。\n$$\nK_{T}(u, \\lambda) = \\frac{\\partial R}{\\partial u} = \\begin{pmatrix} \\frac{\\partial R_{1}}{\\partial u_{1}} & \\frac{\\partial R_{1}}{\\partial u_{2}} \\\\ \\frac{\\partial R_{2}}{\\partial u_{1}} & \\frac{\\partial R_{2}}{\\partial u_{2}} \\end{pmatrix}\n$$\n切线刚度矩阵的各分量为：\n$$\n\\frac{\\partial R_{1}}{\\partial u_{1}} = k+c-\\lambda g + 3\\gamma u_{1}^{2}\n$$\n$$\n\\frac{\\partial R_{1}}{\\partial u_{2}} = -c\n$$\n$$\n\\frac{\\partial R_{2}}{\\partial u_{1}} = -c\n$$\n$$\n\\frac{\\partial R_{2}}{\\partial u_{2}} = k+c-\\lambda g + 3\\gamma u_{2}^{2}\n$$\n由此得到切线刚度矩阵：\n$$\nK_{T}(u, \\lambda) = \\begin{pmatrix} k+c-\\lambda g + 3\\gamma u_{1}^{2} & -c \\\\ -c & k+c-\\lambda g + 3\\gamma u_{2}^{2} \\end{pmatrix}\n$$\n问题要求我们分析平凡平衡分支上的稳定性，该分支由 $u = \\begin{pmatrix} 0 & 0 \\end{pmatrix}^{\\mathsf{T}}$ 定义。我们通过将 $u_{1}=0$ 和 $u_{2}=0$ 代入残差向量来检验这确实是一条平衡路径：$R(0, \\lambda) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，该式对任意 $\\lambda$ 均成立。\n\n现在，我们通过令 $u_{1}=0$ 和 $u_{2}=0$ 将切线刚度矩阵 $K_{T}$ 特化到该平凡路径上：\n$$\nK_{T}(0, \\lambda) = \\begin{pmatrix} k+c-\\lambda g & -c \\\\ -c & k+c-\\lambda g \\end{pmatrix}\n$$\n平凡路径上的分岔点（临界点）发生在切线刚度矩阵奇异时。该条件在数学上表示为 $\\det K_{T}(0, \\lambda)=0$。\n我们计算其行列式：\n$$\n\\det K_{T}(0, \\lambda) = (k+c-\\lambda g)(k+c-\\lambda g) - (-c)(-c) = (k+c-\\lambda g)^{2} - c^{2}\n$$\n令行列式为零，得到关于 $\\lambda$ 临界值的方程：\n$$\n(k+c-\\lambda g)^{2} - c^{2} = 0\n$$\n这是一个平方差公式，可以因式分解为：\n$$\n\\left[ (k+c-\\lambda g) - c \\right] \\left[ (k+c-\\lambda g) + c \\right] = 0\n$$\n如果任一因子为零，则该方程成立。\n\n情况1：\n$$\n(k+c-\\lambda g) - c = 0 \\implies k - \\lambda g = 0 \\implies \\lambda g = k\n$$\n这给出了第一个临界值：\n$$\n\\lambda_{1} = \\frac{k}{g}\n$$\n情况2：\n$$\n(k+c-\\lambda g) + c = 0 \\implies k+2c - \\lambda g = 0 \\implies \\lambda g = k+2c\n$$\n这给出了第二个临界值：\n$$\n\\lambda_{2} = \\frac{k+2c}{g}\n$$\n由于题目说明 $k>0$, $c>0$ 和 $g>0$，所以两个临界值 $\\lambda_{1}$ 和 $\\lambda_{2}$ 均为正且不相等。这些参数值使得平凡平衡路径失去稳定性。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{k}{g} & \\frac{k+2c}{g} \\end{pmatrix}}\n$$", "id": "2542980"}, {"introduction": "掌握了代数系统的分岔条件后，我们将这一概念应用于连续体结构的有限元分析。本实践要求你从基本原理出发，为经典的欧拉-伯努利梁单元推导其弹性刚度矩阵和几何刚度矩阵。通过将连续结构的屈曲问题转化为一个离散的广义特征值问题，你将能够计算出单单元模型预测的临界屈曲载荷，并与精确解进行比较，这对于理解离散化误差和有限元法在稳定性分析中的应用至关重要。[@problem_id:2543000]", "problem": "一根长度为 $L$、抗弯刚度为 $EI$ 的均匀等截面 Euler–Bernoulli 梁，其形心轴受到大小为 $N$ 的恒定端部轴向压力作用。假设为小应变和小转动，并忽略剪切变形。梁的两端为简支支撑，模型化为 $w(0)=0$, $w(L)=0$，且端部转动不受约束。将屈曲的检测视为一个平衡分岔问题，其特征为总势能二阶变分失去正定性，或者等效地，切线刚度的最小特征值变为零。\n\n使用有限元法（FEM），采用单个双节点 Euler–Bernoulli 梁单元，对横向位移 $w(x)$ 进行 Hermite 三次插值，节点自由度（DOFs）为 $x=0$ 处的 $w_{1}$、$\\theta_{1}$ 和 $x=L$ 处的 $w_{2}$、$\\theta_{2}$。请从第一性原理出发，按以下步骤进行：\n- 从虚功原理以及由力 $N$ 引起的几何非线性的线性化出发，推导用 Hermite 形函数表示的一致单元弯曲刚度和几何（初应力）刚度。\n- 组装单元切线刚度，通过约束 $w_{1}=0$ 和 $w_{2}=0$，同时保持 $\\theta_{1}$ 和 $\\theta_{2}$ 自由，来施加简支边界条件，并写出所得到的针对转动自由度的简化广义特征值问题。\n- 求解此简化问题，以获得预测分岔的最低临界载荷 $N_{\\mathrm{cr}}^{\\mathrm{FE}}$。\n\n设简支梁的 Euler 屈曲载荷解析解为 $N_{\\mathrm{cr}}^{\\mathrm{exact}}=\\pi^{2} EI / L^{2}$。作为最终答案，请报告单个无量纲比值\n$$\nr \\;=\\; \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}}.\n$$\n请将最终结果表示为精确的闭式解析表达式。不要进行四舍五入或近似计算。", "solution": "该问题陈述具有科学依据，是适定且客观的。它提出了一个计算结构力学中的标准问题，特别是弹性屈曲的有限元分析。所有需要的数据和条件都已提供，不存在矛盾或谬误。该问题是有效的。我们按照要求从第一性原理出发进行求解。\n\n分析基于承受轴向压力 $N$ 的 Euler-Bernoulli 梁的线性化虚功原理。切线刚度矩阵 $\\mathbf{K}_T$ 是标准弹性（弯曲）刚度矩阵 $\\mathbf{K}_E$ 和几何（初应力）刚度矩阵 $\\mathbf{K}_G$ 的和。当 $\\mathbf{K}_T$ 失去正定性时发生屈曲分岔，这等效于寻找使得特征值问题 $(\\mathbf{K}_E - \\mathbf{K}_G(N)) \\mathbf{d} = \\mathbf{0}$ 存在非零解 $\\mathbf{d} \\neq \\mathbf{0}$ 的最小载荷 $N$。由于 $\\mathbf{K}_G$ 与 $N$ 线性相关，我们可以写成 $\\mathbf{K}_G = N \\mathbf{K}_{G0}$，问题就变成了一个标准线性特征值问题 $(\\mathbf{K}_E - N_{\\mathrm{cr}} \\mathbf{K}_{G0}) \\mathbf{d} = \\mathbf{0}$，其中 $N_{\\mathrm{cr}}$ 是临界载荷。\n\n使用一个长度为 $L$ 的双节点梁单元。横向位移场 $w(x)$ 使用 Hermite 三次形函数进行插值。节点自由度（DOFs）为 $\\mathbf{d} = [w_1, \\theta_1, w_2, \\theta_2]^T$，其中 $w_1 = w(0)$，$\\theta_1 = w'(0)$，$w_2 = w(L)$，以及 $\\theta_2 = w'(L)$。位移由 $w(x) = \\mathbf{N}(x) \\mathbf{d}$ 给出，其中 $\\mathbf{N}(x) = [H_1(x), H_2(x), H_3(x), H_4(x)]$ 是形函数向量。用无量纲坐标 $\\xi = x/L$ 表示，它们是：\n$$ H_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 $$\n$$ H_2(\\xi) = L(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ H_3(\\xi) = 3\\xi^2 - 2\\xi^3 $$\n$$ H_4(\\xi) = L(-\\xi^2 + \\xi^3) $$\n\n对于梁柱，考虑弯曲和轴向力效应的内虚功，其线性化形式为：\n$$ \\delta W_{\\mathrm{int}} = \\int_0^L \\delta\\epsilon_{xx} \\sigma_{xx} dA dx = \\int_0^L EI \\delta w'' w'' dx + \\int_0^L N \\delta w' w' dx $$\n其中 $w''$ 是曲率，$w'$ 是转角。第一项产生弹性刚度矩阵 $\\mathbf{K}_E$，第二项产生几何刚度矩阵 $\\mathbf{K}_G$。\n\n弹性刚度矩阵 $\\mathbf{K}_E$ 的分量由弯曲应变能推导得出：\n$$ K_{E,ij} = EI \\int_0^L H_i''(x) H_j''(x) dx = EI \\int_0^1 H_i''(\\xi L) H_j''(\\xi L) L d\\xi $$\n在单元域 $[0, L]$ 上计算这些标准积分，得到矩阵：\n$$ \\mathbf{K}_E = \\frac{EI}{L^3} \\begin{pmatrix} 12 & 6L & -12 & 6L \\\\ 6L & 4L^2 & -6L & 2L^2 \\\\ -12 & -6L & 12 & -6L \\\\ 6L & 2L^2 & -6L & 4L^2 \\end{pmatrix} $$\n\n几何刚度矩阵 $\\mathbf{K}_G = N \\mathbf{K}_{G0}$ 的分量由轴向力 $N$ 因构件转动所做的功推导得出：\n$$ K_{G,ij} = \\int_0^L N H_i'(x) H_j'(x) dx = N \\int_0^1 H_i'(\\xi L) H_j'(\\xi L) L d\\xi $$\n因此，矩阵 $\\mathbf{K}_{G0}$ 为：\n$$ K_{G0,ij} = \\int_0^L H_i'(x) H_j'(x) dx $$\n计算这些积分得到：\n$$ \\mathbf{K}_G = \\frac{N}{30L} \\begin{pmatrix} 36 & 3L & -36 & 3L \\\\ 3L & 4L^2 & -3L & -L^2 \\\\ -36 & -3L & 36 & -3L \\\\ 3L & -L^2 & -3L & 4L^2 \\end{pmatrix} $$\n\n问题指定了简支边界条件，即 $w(0)=w_1=0$ 和 $w(L)=w_2=0$。这些约束消去了第一和第三个自由度。特征值问题被简化到自由转动自由度 $\\theta_1$ 和 $\\theta_2$ 构成的子空间。我们提取 $\\mathbf{K}_E$ 和 $\\mathbf{K}_G$ 中对应于第二行、第四行和第二列、第四列的子矩阵。\n简化后的弹性刚度矩阵 $\\mathbf{K}_{E, red}$ 为：\n$$ \\mathbf{K}_{E, red} = \\frac{EI}{L^3} \\begin{pmatrix} 4L^2 & 2L^2 \\\\ 2L^2 & 4L^2 \\end{pmatrix} = \\frac{EI}{L} \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} $$\n简化后的几何刚度矩阵 $\\mathbf{K}_{G, red}$ 为：\n$$ \\mathbf{K}_{G, red} = \\frac{N}{30L} \\begin{pmatrix} 4L^2 & -L^2 \\\\ -L^2 & 4L^2 \\end{pmatrix} = \\frac{NL}{30} \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} $$\n\n针对临界载荷 $N = N_{\\mathrm{cr}}^{\\mathrm{FE}}$ 的简化特征值问题是：\n$$ (\\mathbf{K}_{E, red} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\mathbf{K}_{G0, red}) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\n代入矩阵得到：\n$$ \\left( \\frac{EI}{L} \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\frac{L}{30} \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} \\right) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\n为获得非零解，该矩阵的行列式必须为零。我们定义一个无量纲特征值 $\\lambda = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{30EI}$。特征方程变为：\n$$ \\det \\left( \\begin{pmatrix} 4 & 2 \\\\ 2 & 4 \\end{pmatrix} - \\lambda \\begin{pmatrix} 4 & -1 \\\\ -1 & 4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det \\begin{pmatrix} 4 - 4\\lambda & 2 + \\lambda \\\\ 2 + \\lambda & 4 - 4\\lambda \\end{pmatrix} = 0 $$\n$$ (4 - 4\\lambda)^2 - (2 + \\lambda)^2 = 0 $$\n这个方程可以作为平方差进行因式分解：\n$$ [4(1-\\lambda) - (2+\\lambda)] [4(1-\\lambda) + (2+\\lambda)] = 0 $$\n这会导出 $\\lambda$ 的两个可能解：\n1. $4 - 4\\lambda - 2 - \\lambda = 0 \\implies 2 - 5\\lambda = 0 \\implies \\lambda_1 = \\frac{2}{5}$\n2. $4 - 4\\lambda + 2 + \\lambda = 0 \\implies 6 - 3\\lambda = 0 \\implies \\lambda_2 = 2$\n\n最低临界载荷对应于最小的特征值 $\\lambda_1$。\n$$ N_{\\mathrm{cr}}^{\\mathrm{FE}} = \\frac{30EI}{L^2} \\lambda_1 = \\frac{30EI}{L^2} \\left(\\frac{2}{5}\\right) = \\frac{12EI}{L^2} $$\n简支梁的 Euler 屈曲载荷解析解由 $N_{\\mathrm{cr}}^{\\mathrm{exact}} = \\frac{\\pi^2 EI}{L^2}$ 给出。\n\n所要求的比值 $r$ 是：\n$$ r = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}} = \\frac{12EI/L^2}{\\pi^2EI/L^2} = \\frac{12}{\\pi^2} $$\n这一结果表明，由于其多项式形函数，单个有限元模型过于刚硬，高估了真实的屈曲载荷。误差约为 21.6%。需要更多的单元才能收敛到精确解。", "answer": "$$\n\\boxed{\\frac{12}{\\pi^2}}\n$$", "id": "2543000"}, {"introduction": "本综合性编程练习将前面的概念提升到一个完整的计算分析工作流中。你将为一个对称的平面圆拱结构编写一个有限元程序，以计算其最低的两个屈曲载荷因子及其对应的模态。此练习不仅涵盖了单元矩阵的坐标变换、全局矩阵的组装和边界条件的应用，还引入了利用群论思想对屈曲模态进行对称性分类的先进技术，这对于深刻理解和解释复杂工程结构中的失稳现象非常有价值。[@problem_id:2542913]", "problem": "给定一个使用欧拉-伯努利梁有限元法建模的对称平面圆拱。您的任务是实现一个完整、可运行的程序，该程序能够组装弹性刚度矩阵和初始应力几何刚度矩阵，计算给定压缩轴向力模式下的两个最低分岔（线性化屈曲）载荷因子及其模态振型，并通过投影到群不变子空间上，将每个模态根据其相对于拱跨中反射的对称性进行分类。\n\n请基于以下基本原理进行开发：\n\n- 线性化屈曲问题源于总势能的二次变分。在采用节点位移向量 $\\mathbf{u}$ 的有限元离散化中，存在预应力状态时的稳定性算子是弹性刚度 $\\mathbf{K}$ 与初始应力几何刚度 $\\mathbf{K}_\\sigma$ 之和。对于大小为 $P$ 的压缩载荷（假设其按固定轴力分布进行缩放），离散化的线性屈曲条件为\n$$\n\\left( \\mathbf{K} - P\\,\\mathbf{K}_\\sigma \\right)\\boldsymbol{\\phi} = \\mathbf{0},\n$$\n这等价于广义特征值问题\n$$\n\\mathbf{K}\\,\\boldsymbol{\\phi} = \\lambda\\,\\mathbf{K}_\\sigma\\,\\boldsymbol{\\phi}, \\quad \\lambda = P.\n$$\n- 对于一个长度为 $L$、杨氏模量为 $E$、横截面积为 $A$、截面二次矩为 $I$ 的二维欧拉-伯努利梁单元，其局部弹性刚度矩阵 $\\mathbf{k}_e^{\\text{loc}}$ 由以下经过充分检验的表达式组装而成\n$$\n\\mathbf{k}_e^{\\text{loc}} =\n\\begin{bmatrix}\n\\frac{EA}{L} & 0 & 0 & -\\frac{EA}{L} & 0 & 0 \\\\\n0 & \\frac{12EI}{L^3} & \\frac{6EI}{L^2} & 0 & -\\frac{12EI}{L^3} & \\frac{6EI}{L^2} \\\\\n0 & \\frac{6EI}{L^2} & \\frac{4EI}{L} & 0 & -\\frac{6EI}{L^2} & \\frac{2EI}{L} \\\\\n-\\frac{EA}{L} & 0 & 0 & \\frac{EA}{L} & 0 & 0 \\\\\n0 & -\\frac{12EI}{L^3} & -\\frac{6EI}{L^2} & 0 & \\frac{12EI}{L^3} & -\\frac{6EI}{L^2} \\\\\n0 & \\frac{6EI}{L^2} & \\frac{2EI}{L} & 0 & -\\frac{6EI}{L^2} & \\frac{4EI}{L}\n\\end{bmatrix}.\n$$\n- 对于一个沿单元承受恒定压缩轴向力 $P>0$ 的欧拉-伯努利梁单元，其一致初始应力几何刚度矩阵为\n$$\n\\mathbf{k}_\\sigma^{\\text{loc}}(P) = \\frac{P}{30L}\\begin{bmatrix}\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 36 & 3L & 0 & -36 & 3L \\\\\n0 & 3L & 4L^2 & 0 & -3L & -L^2 \\\\\n0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & -36 & -3L & 0 & 36 & -3L \\\\\n0 & 3L & -L^2 & 0 & -3L & 4L^2\n\\end{bmatrix}.\n$$\n对于广义特征值问题，使用单位压缩力下的几何刚度\n$$\n\\mathbf{k}_\\sigma^{\\text{loc}} := \\mathbf{k}_\\sigma^{\\text{loc}}(P=1),\n$$\n因此，在方程 $\\mathbf{K}\\boldsymbol{\\phi} = \\lambda\\,\\mathbf{K}_\\sigma\\boldsymbol{\\phi}$ 中，临界载荷因子为 $\\lambda$。\n- 使用基于单元弦杆的标准正交方向余弦，将局部单元矩阵转换到全局坐标系，组装全局矩阵，并施加边界条件以模拟铰接支座：即两端节点的平移均被固定，而转动是自由的。\n\n对称性分类要求：\n\n- 该拱相对于其中间位置的竖直轴线反射对称。令 $\\mathcal{G}$ 表示由反射算子 $\\mathbf{R}$ 生成的二阶对称群。作用于全局节点位移向量的 $\\mathbf{R}$ 按如下方式构造。对于一个切向单位向量为 $\\hat{\\mathbf{t}}$、法向单位向量为 $\\hat{\\mathbf{n}}$（平面内）的节点，通过将全局分量 $(u_x,u_y,\\theta)$ 投影到 $(\\hat{\\mathbf{t}},\\hat{\\mathbf{n}},\\theta)$ 上来定义局部平移分量 $(u_t,u_n,\\theta)$。在关于跨中轴线反射时，局部分量的变换关系为\n$$\n(u_t,u_n,\\theta) \\mapsto (-u_t,\\,u_n,\\,-\\theta),\n$$\n然后被映射回镜像节点的全局分量。对称和反对称投影算子为\n$$\n\\mathbf{P}_{\\text{sym}} = \\tfrac{1}{2}(\\mathbf{I}+\\mathbf{R}), \\quad\n\\mathbf{P}_{\\text{anti}} = \\tfrac{1}{2}(\\mathbf{I}-\\mathbf{R}).\n$$\n给定一个模态向量 $\\boldsymbol{\\phi}$，如果 $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 \\ge \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$，则将其归类为对称模态，否则为反对称模态。\n\n几何形状与离散化：\n\n- 该拱位于一个半径为 $R$、总中心角为 $\\Phi$ 的圆上，节点角度在区间 $\\alpha \\in [-\\Phi/2,\\Phi/2]$ 内均匀分布，其坐标为\n$$\nx(\\alpha) = R\\sin(\\alpha), \\quad y(\\alpha) = R\\cos(\\alpha).\n$$\n节点角度为 $\\alpha$ 处的切向和法向单位向量为\n$$\n\\hat{\\mathbf{t}}(\\alpha) = (\\cos\\alpha,\\,-\\sin\\alpha), \\quad \\hat{\\mathbf{n}}(\\alpha) = (\\sin\\alpha,\\,\\cos\\alpha).\n$$\n使用 $n_e$ 个直线梁单元连接连续的节点。\n\n数值步骤与约束：\n\n- 从单元在全局坐标系下的贡献组装 $\\mathbf{K}$ 和 $\\mathbf{K}_\\sigma$。\n- 通过消除两端节点的平移自由度 $u_x$ 和 $u_y$ 来施加铰接边界条件；端节点的转动保持自由。\n- 通过在简化的自由度上将其转换为标准形式 $\\mathbf{K}^{-1}\\mathbf{K}_\\sigma$ 来稳健地求解广义特征值问题。如果 $\\mu$ 是 $\\mathbf{K}^{-1}\\mathbf{K}_\\sigma$ 的一个特征值，则屈曲载荷因子为 $\\lambda = 1/\\mu$。选择两个最小的正 $\\lambda$（等价于两个最大的正 $\\mu$）及其对应的特征向量。\n\n角度单位和物理单位：\n\n- 所有角度必须使用弧度制。\n- 采用一个一致的无量纲单位制，其中 $E$、$A$、$I$、$R$ 和 $\\Phi$ 如下文给定。将载荷因子 $\\lambda$ 作为纯数（无量纲）报告。\n\n测试集：\n\n- 使用以下三种情况。对于每种情况，计算两个最低的分岔载荷因子 $\\lambda_1 \\le \\lambda_2$，并使用上述投影算子准则将其模态振型分类为对称（$1$）或反对称（$0$）。每种情况指定 $(R,\\Phi,E,A,I,n_e)$：\n\n    - 情况 1 (标准情况): $R=1.0$, $\\Phi=1.6$, $E=1.0$, $A=1.0$, $I=10^{-3}$, $n_e=40$.\n    - 情况 2 (抗弯刚度较小): $R=1.0$, $\\Phi=1.2$, $E=1.0$, $A=1.0$, $I=5\\times 10^{-4}$, $n_e=40$.\n    - 情况 3 (跨度较大): $R=1.0$, $\\Phi=2.0$, $E=1.0$, $A=1.0$, $I=2\\times 10^{-3}$, $n_e=60$.\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，形式为逗号分隔的列表。每个测试用例的结果是一个包含四个条目的列表，顺序为 $[\\lambda_1, s_1, \\lambda_2, s_2]$，其中 $\\lambda_i$ 四舍五入到六位小数，$s_i$ 对称时为 $1$，反对称时为 $0$。格式示例：[[0.123456,1,0.234567,0],[...],[...]]。", "solution": "该问题要求确定对称圆拱的两个最低线性化屈曲载荷和相应的模态振型，该圆拱使用有限元法进行离散。模态需要根据其对称性进行分类。对问题陈述的验证确认了其科学上是合理的、适定的，并包含了唯一解所需的所有信息。我们继续进行基于原理的求解方法推导。\n\n线性化屈曲方程的离散形式表示为一个广义特征值问题：\n$$\n\\mathbf{K}\\boldsymbol{\\phi} = \\lambda\\mathbf{K}_\\sigma\\boldsymbol{\\phi}\n$$\n其中 $\\mathbf{K}$ 是弹性刚度矩阵，$\\mathbf{K}_\\sigma$ 是对应于单位载荷的几何刚度矩阵，$\\lambda$ 是临界屈曲载荷因子，$\\boldsymbol{\\phi}$ 是相应的屈曲模态振型（特征向量）。\n\n**1. 离散化与几何构型**\n\n拱的几何形状由其半径 $R$ 和总圆心角 $\\Phi$ 定义。拱的中线由角度 $\\alpha \\in [-\\Phi/2, \\Phi/2]$ 参数化，其笛卡尔坐标由下式给出：\n$$\nx(\\alpha) = R\\sin(\\alpha), \\quad y(\\alpha) = R\\cos(\\alpha)\n$$\n该结构被离散为 $n_e$ 个直线欧拉-伯努利梁单元，连接 $n_n = n_e + 1$ 个节点。节点在角度上均匀分布。节点 $i$ （对于 $i \\in \\{0, 1, \\dots, n_e\\}$）的角度位置为：\n$$\n\\alpha_i = -\\frac{\\Phi}{2} + i \\frac{\\Phi}{n_e}\n$$\n每个节点的坐标 $(x_i, y_i)$ 使用上述几何方程计算。每个节点在平面内拥有三个自由度 (DOF)：两个平移 $(u_x, u_y)$ 和一个转动 ($\\theta$)。系统的总自由度数为 $3n_n$。\n\n**2. 单元刚度矩阵与坐标变换**\n\n对于连接节点 $i$ 和 $i+1$ 的每个单元，我们首先在其局部坐标系 $(x', y')$ 中计算其属性，其中 $x'$ 轴与单元的弦杆对齐。\n单元长度 $L$ 是其两个节点之间的欧几里得距离：\n$$\nL = \\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}\n$$\n单元局部 $x'$ 轴相对于全局 $x$ 轴的方向由角度 $\\theta_e$ 给出：\n$$\n\\theta_e = \\text{atan2}(y_{i+1}-y_i, x_{i+1}-x_i)\n$$\n局部弹性刚度矩阵 $\\mathbf{k}_e^{\\text{loc}}$ 和局部几何刚度矩阵 $\\mathbf{k}_\\sigma^{\\text{loc}}$ 在问题陈述中已给出。它们是 $6 \\times 6$ 的矩阵，对应于单元两个节点在其局部坐标系中的自由度 $(u'_1, v'_1, \\theta'_1, u'_2, v'_2, \\theta'_2)$。\n\n为了组装全局系统矩阵，这些局部矩阵必须被转换到全局坐标系中。这是通过一个变换矩阵 $\\mathbf{T}$ 实现的。对于一个二维梁单元，在 `d_loc = T d_glob` 约定下，全局刚度矩阵通过合同变换 `K_glob = T^T K_loc T` 计算。变换矩阵 $\\mathbf{T}$ 是一个 $6 \\times 6$ 的分块对角矩阵：\n$$\n\\mathbf{T} = \\begin{bmatrix} \\mathbf{\\Lambda} & \\mathbf{0} \\\\ \\mathbf{0} & \\mathbf{\\Lambda} \\end{bmatrix}, \\quad \\text{其中} \\quad \\mathbf{\\Lambda} = \\begin{bmatrix} \\cos\\theta_e & \\sin\\theta_e & 0 \\\\ -\\sin\\theta_e & \\cos\\theta_e & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}\n$$\n于是，在全局坐标系中的单元刚度矩阵 $\\mathbf{k}_e^{\\text{glob}}$ 和 $\\mathbf{k}_\\sigma^{\\text{glob}}$ 通过合同变换计算得到：\n$$\n\\mathbf{k}_e^{\\text{glob}} = \\mathbf{T}^T \\mathbf{k}_e^{\\text{loc}} \\mathbf{T}\n$$\n$$\n\\mathbf{k}_\\sigma^{\\text{glob}} = \\mathbf{T}^T \\mathbf{k}_\\sigma^{\\text{loc}} \\mathbf{T}\n$$\n\n**3. 全局系统组装与边界条件**\n\n大小为 $3n_n \\times 3n_n$ 的全局刚度矩阵 $\\mathbf{K}$ 和 $\\mathbf{K}_\\sigma$ 是通过对所有单元的全局矩阵贡献求和来构建的。这是一个标准的直接刚度法组装过程，其中 $\\mathbf{k}^{\\text{glob}}$ 的条目根据单元的节点连接性被添加到全局矩阵的相应位置。\n\n拱的两端（节点 $0$ 和 $n_e$）由铰支座支撑，这意味着平移位移受到约束，而转动是自由的。边界条件为：\n$$\nu_x=0, u_y=0 \\quad \\text{在节点 } 0\n$$\n$$\nu_x=0, u_y=0 \\quad \\text{在节点 } n_e\n$$\n通过从全局矩阵中移除与这四个固定自由度相对应的行和列来施加这些条件，从而得到简化的矩阵 $\\mathbf{K}_{\\text{free}}$ 和 $\\mathbf{K}_{\\sigma, \\text{free}}$。最终的系统仅涉及自由度。\n\n**4. 特征值问题求解**\n\n问题陈述指定通过将其转换为标准特征值问题来求解广义特征值问题。自由度的屈曲方程为：\n$$\n\\mathbf{K}_{\\text{free}}\\boldsymbol{\\phi}_{\\text{free}} = \\lambda\\mathbf{K}_{\\sigma, \\text{free}}\\boldsymbol{\\phi}_{\\text{free}}\n$$\n由于结构被恰当约束，$\\mathbf{K}_{\\text{free}}$ 是正定的，因此是可逆的。因此我们可以写出：\n$$\n\\mathbf{K}_{\\text{free}}^{-1}\\mathbf{K}_{\\sigma, \\text{free}}\\boldsymbol{\\phi}_{\\text{free}} = \\frac{1}{\\lambda}\\boldsymbol{\\phi}_{\\text{free}}\n$$\n令 $\\mu = 1/\\lambda$，我们求解标准特征值问题 $\\mathbf{A}\\mathbf{x} = \\mu\\mathbf{x}$，其中 $\\mathbf{A} = \\mathbf{K}_{\\text{free}}^{-1}\\mathbf{K}_{\\sigma, \\text{free}}$，$\\mathbf{x} = \\boldsymbol{\\phi}_{\\text{free}}$。计算特征值 $\\mu$。临界屈曲载荷因子 $\\lambda$ 是这些特征值的倒数。我们寻找两个最小的正 $\\lambda$ 值，这对应于两个最大的正 $\\mu$ 值。相应的特征向量 $\\boldsymbol{\\phi}_{\\text{free}}$ 是限制在自由度上的模态振型。完整的模态振型向量 $\\boldsymbol{\\phi}$ 通过在固定自由度的位置重新插入零来重构。\n\n**5. 对称性分类**\n\n该拱关于 $y$ 轴反射对称。这种对称性由一个作用于全局自由度向量 $\\boldsymbol{\\phi}$ 的算子 $\\mathbf{R}$ 表示。对于一个按节点划分的自由度向量 $\\boldsymbol{\\phi} = [\\boldsymbol{\\phi}_0^T, \\boldsymbol{\\phi}_1^T, \\dots, \\boldsymbol{\\phi}_{n_e}^T]^T$，反射算子将节点 $i$ 的自由度映射到反射节点 $j=n_e-i$ 的变换后自由度。\n\n问题基于局部切向和法向坐标定义了反射变换。按照指定的过程，我们可以推导出将节点 $i$ 的位移自由度 $(u_x, u_y)_i$ 映射到节点 $j=n_e-i$ 的 $(u'_x, u'_y)_j$ 的变换块。可以发现此变换是一个简单的反射：$(u'_x, u'_y)_j = (-u_x, u_y)_i$。转动自由度的变换为 $\\theta_j = -\\theta_i$。因此，将自由度从节点 $i$ 映射到节点 $j$ 的 $\\mathbf{R}$ 的 $3 \\times 3$ 子块是 $\\text{diag}(-1, 1, -1)$。完整的矩阵 $\\mathbf{R}$ 是一个在其反对角线上由这些块组成的分块置换矩阵。\n\n构建好算子 $\\mathbf{R}$ 后，我们定义对称和反对称投影算子：\n$$\n\\mathbf{P}_{\\text{sym}} = \\frac{1}{2}(\\mathbf{I} + \\mathbf{R}), \\quad \\mathbf{P}_{\\text{anti}} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{R})\n$$\n一个任意的模态振型 $\\boldsymbol{\\phi}$ 可以分解为其对称和反对称分量：$\\boldsymbol{\\phi} = \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi} + \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}$。如果一个模态的对称部分的范数大于或等于其反对称部分的范数，则该模态被归类为对称模态，否则为反对称模态：\n\\begin{itemize}\n    \\item 对称 ($s=1$): 如果 $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 \\ge \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$\n    \\item 反对称 ($s=0$): 如果 $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 < \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$\n\\end{itemize}\n此过程应用于两个计算出的屈曲模态 $\\boldsymbol{\\phi}_1$ 和 $\\boldsymbol{\\phi}_2$，以确定它们的对称性分类 $s_1$ 和 $s_2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases specified\n    in the problem statement.\n    \"\"\"\n\n    def analyze_arch(R, Phi, E, A, I, n_e):\n        \"\"\"\n        Performs FEM buckling analysis for a single circular arch case.\n\n        Args:\n            R (float): Arch radius.\n            Phi (float): Total arch angle in radians.\n            E (float): Young's modulus.\n            A (float): Cross-sectional area.\n            I (float): Second moment of area.\n            n_e (int): Number of elements.\n\n        Returns:\n            list: A list containing [lambda_1, s_1, lambda_2, s_2],\n                  where lambda_i are the buckling loads and s_i are the\n                  symmetry classifications (1 for symmetric, 0 for antisymmetric).\n        \"\"\"\n        n_n = n_e + 1\n        dofs_per_node = 3\n        total_dofs = n_n * dofs_per_node\n\n        # 1. Discretization and Nodal Coordinates\n        alphas = np.linspace(-Phi / 2.0, Phi / 2.0, n_n)\n        coords = np.zeros((n_n, 2))\n        coords[:, 0] = R * np.sin(alphas)\n        coords[:, 1] = R * np.cos(alphas)\n\n        # Initialize global stiffness matrices\n        K_global = np.zeros((total_dofs, total_dofs))\n        K_sigma_global = np.zeros((total_dofs, total_dofs))\n\n        # 2. Element-by-Element Assembly\n        for i in range(n_e):\n            node1_idx, node2_idx = i, i + 1\n            node1_coords, node2_coords = coords[node1_idx], coords[node2_idx]\n            \n            dx = node2_coords[0] - node1_coords[0]\n            dy = node2_coords[1] - node1_coords[1]\n            L = math.sqrt(dx**2 + dy**2)\n            \n            # Element orientation\n            angle = math.atan2(dy, dx)\n            c, s = math.cos(angle), math.sin(angle)\n            \n            # Local elastic stiffness matrix\n            ke_loc = np.zeros((6, 6))\n            EA_L = E * A / L\n            EI_L = E * I / L\n            EI_L2 = E * I / L**2\n            EI_L3 = E * I / L**3\n\n            ke_loc[0, 0] = EA_L\n            ke_loc[0, 3] = -EA_L\n            ke_loc[3, 0] = -EA_L\n            ke_loc[3, 3] = EA_L\n\n            ke_loc[1, 1] = 12 * EI_L3\n            ke_loc[1, 2] = 6 * EI_L2\n            ke_loc[1, 4] = -12 * EI_L3\n            ke_loc[1, 5] = 6 * EI_L2\n            ke_loc[2, 1] = 6 * EI_L2\n            ke_loc[2, 2] = 4 * EI_L\n            ke_loc[2, 4] = -6 * EI_L2\n            ke_loc[2, 5] = 2 * EI_L\n            ke_loc[4, 1] = -12 * EI_L3\n            ke_loc[4, 2] = -6 * EI_L2\n            ke_loc[4, 4] = 12 * EI_L3\n            ke_loc[4, 5] = -6 * EI_L2\n            ke_loc[5, 1] = 6 * EI_L2\n            ke_loc[5, 2] = 2 * EI_L\n            ke_loc[5, 4] = -6 * EI_L2\n            ke_loc[5, 5] = 4 * EI_L\n\n            # Local geometric stiffness matrix (for P=1)\n            ksigma_loc = np.zeros((6, 6))\n            _30L = 30 * L\n            ksigma_loc[1, 1] = 36 / _30L\n            ksigma_loc[1, 2] = 3 * L / _30L\n            ksigma_loc[1, 4] = -36 / _30L\n            ksigma_loc[1, 5] = 3 * L / _30L\n            ksigma_loc[2, 1] = 3 * L / _30L\n            ksigma_loc[2, 2] = 4 * L**2 / _30L\n            ksigma_loc[2, 4] = -3 * L / _30L\n            ksigma_loc[2, 5] = -L**2 / _30L\n            ksigma_loc[4, 1] = -36 / _30L\n            ksigma_loc[4, 2] = -3 * L / _30L\n            ksigma_loc[4, 4] = 36 / _30L\n            ksigma_loc[4, 5] = -3 * L / _30L\n            ksigma_loc[5, 1] = 3 * L / _30L\n            ksigma_loc[5, 2] = -L**2 / _30L\n            ksigma_loc[5, 4] = -3 * L / _30L\n            ksigma_loc[5, 5] = 4 * L**2 / _30L\n\n            # Transformation matrix T for d_loc = T d_glob\n            Lambda = np.array([[c, s, 0], [-s, c, 0], [0, 0, 1]])\n            T_transform = np.zeros((6, 6))\n            T_transform[0:3, 0:3] = Lambda\n            T_transform[3:6, 3:6] = Lambda\n            \n            # Transform and assemble using K_glob = T^T K_loc T\n            ke_glob = T_transform.T @ ke_loc @ T_transform\n            ksigma_glob = T_transform.T @ ksigma_loc @ T_transform\n            \n            dof_indices = np.array([\n                dofs_per_node * node1_idx, dofs_per_node * node1_idx + 1, dofs_per_node * node1_idx + 2,\n                dofs_per_node * node2_idx, dofs_per_node * node2_idx + 1, dofs_per_node * node2_idx + 2\n            ])\n            \n            K_global[np.ix_(dof_indices, dof_indices)] += ke_glob\n            K_sigma_global[np.ix_(dof_indices, dof_indices)] += ksigma_glob\n\n        # 3. Boundary Conditions\n        fixed_dofs = [0, 1, dofs_per_node * n_e, dofs_per_node * n_e + 1]\n        all_dofs = np.arange(total_dofs)\n        free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n        \n        K_free = K_global[np.ix_(free_dofs, free_dofs)]\n        K_sigma_free = K_sigma_global[np.ix_(free_dofs, free_dofs)]\n        \n        # 4. Eigenvalue Problem\n        # Following problem statement: convert to standard eigenproblem\n        try:\n            K_free_inv = np.linalg.inv(K_free)\n        except np.linalg.LinAlgError:\n            return [np.nan, -1, np.nan, -1] # Indicates failure\n            \n        A = K_free_inv @ K_sigma_free\n        \n        mu_vals, eig_vecs_free = np.linalg.eig(A)\n\n        # Filter for positive real eigenvalues mu=1/lambda\n        # and sort to find largest mu (smallest lambda)\n        valid_eigs = []\n        for j, mu in enumerate(mu_vals):\n            if np.isreal(mu) and mu.real > 1e-9: # Filter out non-positive and trivial\n                valid_eigs.append((mu.real, eig_vecs_free[:, j]))\n        \n        # Sort by mu in descending order to get smallest lambda first\n        valid_eigs.sort(key=lambda x: x[0], reverse=True)\n        \n        if len(valid_eigs)  2:\n             return [np.nan, -1, np.nan, -1]\n\n        # 5. Extract results and reconstruct full eigenvectors\n        lambda_vals = [1.0 / eig[0] for eig in valid_eigs[:2]]\n        \n        # Ensure lambda1 = lambda2\n        buckling_results = []\n        if lambda_vals[0] > lambda_vals[1]:\n            lambda_vals = [lambda_vals[1], lambda_vals[0]]\n            eig_vecs_to_process = [valid_eigs[1][1], valid_eigs[0][1]]\n        else:\n            eig_vecs_to_process = [valid_eigs[0][1], valid_eigs[1][1]]\n\n        # 6. Symmetry Classification\n        R_matrix = np.zeros((total_dofs, total_dofs))\n        R_block = np.diag([-1.0, 1.0, -1.0])\n        \n        for i in range(n_n):\n            j = n_e - i # Reflected node index\n            i_start, j_start = i * dofs_per_node, j * dofs_per_node\n            R_matrix[j_start:j_start+3, i_start:i_start+3] = R_block\n\n        I_matrix = np.identity(total_dofs)\n        P_sym = 0.5 * (I_matrix + R_matrix)\n        P_anti = 0.5 * (I_matrix - R_matrix)\n\n        for k in range(2):\n            lambda_val = lambda_vals[k]\n            eig_vec_free = eig_vecs_to_process[k]\n            \n            phi_full = np.zeros(total_dofs, dtype=float)\n            phi_full[free_dofs] = eig_vec_free.real\n            phi_full /= np.linalg.norm(phi_full)\n            \n            phi_sym = P_sym @ phi_full\n            phi_anti = P_anti @ phi_full\n            \n            norm_sym = np.linalg.norm(phi_sym)\n            norm_anti = np.linalg.norm(phi_anti)\n            \n            symmetry_class = 1 if norm_sym >= norm_anti else 0\n            buckling_results.extend([round(lambda_val, 6), symmetry_class])\n\n        return buckling_results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.6, 1.0, 1.0, 1e-3, 40),\n        (1.0, 1.2, 1.0, 1.0, 5e-4, 40),\n        (1.0, 2.0, 1.0, 1.0, 2e-3, 60),\n    ]\n\n    results = []\n    for case in test_cases:\n        R, Phi, E, A, I, n_e = case\n        result = analyze_arch(R, Phi, E, A, I, n_e)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string representation\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2542913"}]}