{"hands_on_practices": [{"introduction": "理解大变形需要将纯粹的材料拉伸与刚体运动分离开来。本练习使用连续介质力学的基石——极分解定理，将变形梯度张量 $F$ 分解为一个旋转张量 $R$ 和一个拉伸张量 $U$。通过将此方法应用于看似简单的有限剪切变形案例，您将揭示其中内含的刚体旋转，从而对大应变运动学获得更深刻的直观理解。[@problem_id:2573030]", "problem": "考虑一个连续体的平面单剪切变形，其运动 $\\boldsymbol{\\varphi}:\\mathbb{R}^{2}\\to\\mathbb{R}^{2}$ 在笛卡尔坐标系下由下式给出\n$$\nx_{1} = X_{1} + \\gamma X_{2}, \\quad x_{2} = X_{2},\n$$\n其中 $\\gamma \\in \\mathbb{R}$ 是一个给定的剪切参数，$\\mathbf{X} = (X_{1},X_{2})$ 是参考坐标，而 $\\mathbf{x} = (x_{1},x_{2})$ 是当前坐标。令 $\\mathbf{F} = \\nabla_{\\! \\mathbf{X}} \\boldsymbol{\\varphi}$ 为变形梯度。使用右极分解将 $\\mathbf{F}$ 写为 $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$，其中 $\\mathbf{R}$ 是一个旋转张量，$\\mathbf{U}$ 是一个对称正定右拉伸张量。仅从运动学定义 $\\mathbf{F} = \\partial \\boldsymbol{\\varphi}/\\partial \\mathbf{X}$ 和 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F} = \\mathbf{U}^{2}$ 出发，推导 $\\mathbf{R}$ 和 $\\mathbf{U}$ 关于 $\\gamma$ 的显式闭合表达式，并确定与 $\\mathbf{R}$ 相关的由剪切引起的刚体旋转角 $\\phi$。假设在物理相关的分支上，$\\phi(\\gamma)$ 随 $\\phi(0) = 0$ 连续变化。请给出旋转角 $\\phi(\\gamma)$ 作为 $\\gamma$ 的函数，单位为弧度，作为你的最终答案。最终的方框答案中不要包含单位。", "solution": "该问题陈述科学严谨、定义明确、客观，并包含了求得唯一解所需的全部信息。这是有限变形运动学中的一个标准问题。因此，下面开始推导过程。\n\n运动由映射 $\\boldsymbol{\\varphi}(\\mathbf{X}) = \\mathbf{x}$ 给出，其分量为：\n$$\nx_{1} = X_{1} + \\gamma X_{2}\n$$\n$$\nx_{2} = X_{2}\n$$\n变形梯度张量 $\\mathbf{F}$ 定义为 $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$，其分量为 $F_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}$。我们计算 $\\mathbf{F}$ 的分量：\n$$\nF_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{1} + \\gamma X_{2}) = 1\n$$\n$$\nF_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{1} + \\gamma X_{2}) = \\gamma\n$$\n$$\nF_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{2}) = 0\n$$\n$$\nF_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{2}) = 1\n$$\n以矩阵形式表示，变形梯度为：\n$$\n\\mathbf{F} = \\begin{pmatrix} 1 & \\gamma \\\\ 0 & 1 \\end{pmatrix}\n$$\n右柯西-格林变形张量 $\\mathbf{C}$ 定义为 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$。我们计算 $\\mathbf{C}$：\n$$\n\\mathbf{C} = \\begin{pmatrix} 1 & 0 \\\\ \\gamma & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\gamma \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} (1)(1)+(0)(0) & (1)(\\gamma)+(0)(1) \\\\ (\\gamma)(1)+(1)(0) & (\\gamma)(\\gamma)+(1)(1) \\end{pmatrix} = \\begin{pmatrix} 1 & \\gamma \\\\ \\gamma & 1+\\gamma^{2} \\end{pmatrix}\n$$\n右极分解为 $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$，其中 $\\mathbf{U}$ 是右拉伸张量，由 $\\mathbf{C}$ 的唯一正定平方根给出，即 $\\mathbf{U} = \\sqrt{\\mathbf{C}}$。对于一个 $2 \\times 2$ 对称正定矩阵 $\\mathbf{A}$，其平方根由以下公式给出：\n$$\n\\sqrt{\\mathbf{A}} = \\frac{1}{\\sqrt{\\operatorname{tr}(\\mathbf{A}) + 2\\sqrt{\\det(\\mathbf{A})}}} (\\mathbf{A} + \\sqrt{\\det(\\mathbf{A})}\\mathbf{I})\n$$\n对于我们的张量 $\\mathbf{C}$，我们有其迹 $\\operatorname{tr}(\\mathbf{C}) = 1 + (1+\\gamma^{2}) = 2+\\gamma^{2}$ 及行列式 $\\det(\\mathbf{C}) = (1)(1+\\gamma^{2}) - (\\gamma)(\\gamma) = 1$。\n将这些代入 $\\mathbf{U} = \\sqrt{\\mathbf{C}}$ 的公式中：\n$$\n\\mathbf{U} = \\frac{1}{\\sqrt{(2+\\gamma^{2}) + 2\\sqrt{1}}} \\left( \\mathbf{C} + \\sqrt{1}\\mathbf{I} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} (\\mathbf{C} + \\mathbf{I})\n$$\n$$\n\\mathbf{U} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\left( \\begin{pmatrix} 1 & \\gamma \\\\ \\gamma & 1+\\gamma^{2} \\end{pmatrix} + \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2 & \\gamma \\\\ \\gamma & 2+\\gamma^{2} \\end{pmatrix}\n$$\n这就是右拉伸张量 $\\mathbf{U}$ 的显式表达式。\n\n接下来，我们从关系式 $\\mathbf{R} = \\mathbf{F}\\mathbf{U}^{-1}$ 中求出旋转张量 $\\mathbf{R}$。首先，我们计算 $\\mathbf{U}$ 的逆矩阵。由于 $\\det(\\mathbf{U}) = \\det(\\sqrt{\\mathbf{C}}) = \\sqrt{\\det(\\mathbf{C})} = 1$，我们可以使用行列式为 1 的 $2 \\times 2$ 矩阵的逆矩阵公式：\n$$\n\\mathbf{U}^{-1} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2} & -\\gamma \\\\ -\\gamma & 2 \\end{pmatrix}\n$$\n现在我们计算 $\\mathbf{R}$：\n$$\n\\mathbf{R} = \\mathbf{F}\\mathbf{U}^{-1} = \\begin{pmatrix} 1 & \\gamma \\\\ 0 & 1 \\end{pmatrix} \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2} & -\\gamma \\\\ -\\gamma & 2 \\end{pmatrix}\n$$\n$$\n\\mathbf{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} (1)(2+\\gamma^{2})+(\\gamma)(-\\gamma) & (1)(-\\gamma)+(\\gamma)(2) \\\\ (0)(2+\\gamma^{2})+(1)(-\\gamma) & (0)(-\\gamma)+(1)(2) \\end{pmatrix}\n$$\n$$\n\\mathbf{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}-\\gamma^{2} & -\\gamma+2\\gamma \\\\ -\\gamma & 2 \\end{pmatrix} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2 & \\gamma \\\\ -\\gamma & 2 \\end{pmatrix}\n$$\n这就是旋转张量 $\\mathbf{R}$ 的显式表达式。\n一个通用的二维逆时针旋转角 $\\phi$ 由以下矩阵表示：\n$$\n\\mathbf{R}(\\phi) = \\begin{pmatrix} \\cos\\phi & -\\sin\\phi \\\\ \\sin\\phi & \\cos\\phi \\end{pmatrix}\n$$\n通过将我们计算出的 $\\mathbf{R}$ 的分量与此标准形式进行比较，我们可以确定 $\\phi$：\n$$\n\\cos\\phi = \\frac{2}{\\sqrt{4+\\gamma^{2}}}\n$$\n$$\n-\\sin\\phi = \\frac{\\gamma}{\\sqrt{4+\\gamma^{2}}} \\implies \\sin\\phi = \\frac{-\\gamma}{\\sqrt{4+\\gamma^{2}}}\n$$\n为了求出 $\\phi$，我们可以计算其正切值：\n$$\n\\tan\\phi = \\frac{\\sin\\phi}{\\cos\\phi} = \\frac{-\\gamma/\\sqrt{4+\\gamma^{2}}}{2/\\sqrt{4+\\gamma^{2}}} = -\\frac{\\gamma}{2}\n$$\n这就给出了旋转角 $\\phi$ 作为剪切参数 $\\gamma$ 的函数：\n$$\n\\phi(\\gamma) = \\arctan\\left(-\\frac{\\gamma}{2}\\right)\n$$\n利用 $\\arctan(-x) = -\\arctan(x)$ 的性质，我们可以将其写为：\n$$\n\\phi(\\gamma) = -\\arctan\\left(\\frac{\\gamma}{2}\\right)\n$$\n我们必须根据给定的物理约束来验证此解，即 $\\phi(\\gamma)$ 随 $\\phi(0) = 0$ 连续变化。函数 $\\phi(\\gamma) = -\\arctan(\\gamma/2)$ 对所有 $\\gamma \\in \\mathbb{R}$ 都是连续的。在 $\\gamma=0$ 时，我们有 $\\phi(0) = -\\arctan(0) = 0$。该条件得到满足。因此，该表达式代表了物理相关的旋转角。负号表示对于正剪切 $\\gamma > 0$，所引起的刚体旋转是顺时针的。", "answer": "$$\\boxed{-\\arctan\\left(\\frac{\\gamma}{2}\\right)}$$", "id": "2573030"}, {"introduction": "在计算力学中，大转动不是一次性施加的，而是在多个时间步内增量累积而成的。本练习介绍了此过程的标准方法：使用增量自旋向量的指数映射来更新旋转矩阵。通过执行这一核心计算，您将了解指数映射这一抽象概念如何在实践中用于精确地积分有限转动，这是开发或理解非线性有限元求解器的关键技能。[@problem_id:2573017]", "problem": "在有限元方法框架内，一个经历大转动的刚体通过旋转张量的乘法更新进行时间积分。设当前步的旋转为旋转张量 $R_n \\in \\mathbb{R}^{3 \\times 3}$，表示绕固定z轴旋转角度 $\\varphi_n$，其中 $\\varphi_n=\\pi/6$。在该时间步内的增量自旋由轴向量 $\\Delta \\omega \\in \\mathbb{R}^3$ 给出，其分量为 $\\Delta \\omega = [0.3,\\;0.4,\\;0.0]^{\\mathsf{T}}$，单位为弧度。增量旋转定义为相关斜对称矩阵的矩阵指数，即 $\\Delta R = \\exp([\\Delta \\omega]_{\\times})$，其中对于任意 $v \\in \\mathbb{R}^3$，$[v]_{\\times}$ 是一个 $3 \\times 3$ 的斜对称矩阵，使得对于所有 $u \\in \\mathbb{R}^3$ 都有 $[v]_{\\times} u = v \\times u$。更新后的旋转为 $R_{n+1}=\\Delta R\\,R_n$。仅使用矩阵指数、斜对称叉乘算子和旋转性质的定义来构建增量旋转并进行更新。你可以假设 $R_n$ 是绕z轴旋转角度 $\\varphi_n$ 的精确旋转矩阵。\n\n计算更新后的旋转矩阵 $R_{n+1}$ 的 $(3,1)$ 元。用初等函数和常数给出你的最终结果的精确解析表达式；不要进行数值近似。无需单位。角度以弧度为单位。", "solution": "该问题是有效的，因为它在科学上基于刚体运动学原理，数据充分且一致，表述适定，并以客观的数学语言表达。它需要直接应用旋转矩阵及其合成的标准公式。\n\n目标是计算更新后旋转矩阵 $R_{n+1}$ 的 $(3,1)$ 元，该矩阵由乘法更新法则 $R_{n+1} = \\Delta R \\, R_n$ 给出。\n\n根据矩阵乘法的定义，$R_{n+1}$ 的 $(3,1)$ 元是 $\\Delta R$ 的第三行与 $R_n$ 的第一列的点积：\n$$\n(R_{n+1})_{31} = \\sum_{k=1}^{3} (\\Delta R)_{3k} (R_n)_{k1} = (\\Delta R)_{31} (R_n)_{11} + (\\Delta R)_{32} (R_n)_{21} + (\\Delta R)_{33} (R_n)_{31}\n$$\n\n首先，我们必须确定矩阵 $R_n$。它被定义为绕固定z轴旋转角度 $\\varphi_n = \\frac{\\pi}{6}$ 的旋转矩阵。此类旋转的一般形式为：\n$$\nR_z(\\varphi) = \\begin{pmatrix} \\cos\\varphi & -\\sin\\varphi & 0 \\\\ \\sin\\varphi & \\cos\\varphi & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n代入 $\\varphi = \\varphi_n = \\frac{\\pi}{6}$，我们得到：\n$$\nR_n = \\begin{pmatrix} \\cos(\\frac{\\pi}{6}) & -\\sin(\\frac{\\pi}{6}) & 0 \\\\ \\sin(\\frac{\\pi}{6}) & \\cos(\\frac{\\pi}{6}) & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{\\sqrt{3}}{2} & -\\frac{1}{2} & 0 \\\\ \\frac{1}{2} & \\frac{\\sqrt{3}}{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n因此，$R_n$ 的第一列是 $\\begin{pmatrix} (R_n)_{11} & (R_n)_{21} & (R_n)_{31} \\end{pmatrix}^{\\mathsf{T}} = \\begin{pmatrix} \\frac{\\sqrt{3}}{2} & \\frac{1}{2} & 0 \\end{pmatrix}^{\\mathsf{T}}$。\n\n接下来，我们必须确定增量旋转矩阵 $\\Delta R = \\exp([\\Delta \\omega]_{\\times})$。这是一个由轴向量 $\\Delta \\omega$ 定义的旋转。旋转角 $\\theta$ 是该向量的模，旋转轴 $k$ 是其方向。\n给定的增量自旋向量是 $\\Delta \\omega = \\begin{pmatrix} 0.3 & 0.4 & 0.0 \\end{pmatrix}^{\\mathsf{T}}$。最好使用精确分数来计算：$\\Delta \\omega = \\begin{pmatrix} \\frac{3}{10} & \\frac{4}{10} & 0 \\end{pmatrix}^{\\mathsf{T}}$。\n旋转的模为：\n$$\n\\theta = \\|\\Delta \\omega\\| = \\sqrt{\\left(\\frac{3}{10}\\right)^2 + \\left(\\frac{4}{10}\\right)^2 + 0^2} = \\sqrt{\\frac{9}{100} + \\frac{16}{100}} = \\sqrt{\\frac{25}{100}} = \\frac{5}{10} = \\frac{1}{2}\n$$\n定义旋转轴的单位向量是：\n$$\nk = \\frac{\\Delta \\omega}{\\|\\Delta \\omega\\|} = \\frac{1}{1/2} \\begin{pmatrix} 3/10 \\\\ 4/10 \\\\ 0 \\end{pmatrix} = 2 \\begin{pmatrix} 3/10 \\\\ 4/10 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 3/5 \\\\ 4/5 \\\\ 0 \\end{pmatrix}\n$$\n设 $k$ 的分量为 $k_1 = \\frac{3}{5}$，$k_2 = \\frac{4}{5}$ 和 $k_3 = 0$。\n\n矩阵 $\\Delta R$ 可以使用 Rodrigues 旋转公式构建，该公式是矩阵指数 $\\exp(\\theta[k]_{\\times})$ 的闭式表达式：\n$$\n\\Delta R = I + (\\sin\\theta) [k]_{\\times} + (1-\\cos\\theta) [k]_{\\times}^2\n$$\n其中 $I$ 是 $3 \\times 3$ 单位矩阵，$[k]_{\\times}$ 是与向量 $k$ 相关的斜对称矩阵。\n我们需要 $\\Delta R$ 的第三行。单位矩阵 $I$ 的第三行是 $\\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}$。\n斜对称矩阵 $[k]_{\\times}$ 是：\n$$\n[k]_{\\times} = \\begin{pmatrix} 0 & -k_3 & k_2 \\\\ k_3 & 0 & -k_1 \\\\ -k_2 & k_1 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 4/5 \\\\ 0 & 0 & -3/5 \\\\ -4/5 & 3/5 & 0 \\end{pmatrix}\n$$\n$[k]_{\\times}$ 的第三行是 $\\begin{pmatrix} -\\frac{4}{5} & \\frac{3}{5} & 0 \\end{pmatrix}$。\n矩阵 $[k]_{\\times}^2$ 可以计算为 $k k^{\\mathsf{T}} - I$。它的第三行由 $\\begin{pmatrix} k_3 k_1 & k_3 k_2 & k_3^2 - 1 \\end{pmatrix}$ 给出。因为 $k_3=0$，这简化为 $\\begin{pmatrix} 0 & 0 & -1 \\end{pmatrix}$。\n\n现在我们组合 $\\Delta R$ 的第三行，记作 $(\\Delta R)_{3*}$：\n$$\n(\\Delta R)_{3*} = \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix} + \\sin\\left(\\frac{1}{2}\\right) \\begin{pmatrix} -\\frac{4}{5} & \\frac{3}{5} & 0 \\end{pmatrix} + \\left(1-\\cos\\left(\\frac{1}{2}\\right)\\right) \\begin{pmatrix} 0 & 0 & -1 \\end{pmatrix}\n$$\n$$\n(\\Delta R)_{3*} = \\begin{pmatrix} -\\frac{4}{5}\\sin\\left(\\frac{1}{2}\\right) & \\frac{3}{5}\\sin\\left(\\frac{1}{2}\\right) & 1 - \\left(1-\\cos\\left(\\frac{1}{2}\\right)\\right) \\end{pmatrix}\n$$\n$$\n(\\Delta R)_{3*} = \\begin{pmatrix} -\\frac{4}{5}\\sin\\left(\\frac{1}{2}\\right) & \\frac{3}{5}\\sin\\left(\\frac{1}{2}\\right) & \\cos\\left(\\frac{1}{2}\\right) \\end{pmatrix}\n$$\n\n最后，我们通过计算 $\\Delta R$ 的第三行和 $R_n$ 的第一列的点积来计算 $(R_{n+1})_{31}$：\n$$\n(R_{n+1})_{31} = \\left(-\\frac{4}{5}\\sin\\left(\\frac{1}{2}\\right)\\right) \\left(\\frac{\\sqrt{3}}{2}\\right) + \\left(\\frac{3}{5}\\sin\\left(\\frac{1}{2}\\right)\\right) \\left(\\frac{1}{2}\\right) + \\left(\\cos\\left(\\frac{1}{2}\\right)\\right) (0)\n$$\n$$\n(R_{n+1})_{31} = -\\frac{4\\sqrt{3}}{10}\\sin\\left(\\frac{1}{2}\\right) + \\frac{3}{10}\\sin\\left(\\frac{1}{2}\\right)\n$$\n$$\n(R_{n+1})_{31} = \\left(\\frac{3 - 4\\sqrt{3}}{10}\\right) \\sin\\left(\\frac{1}{2}\\right)\n$$\n这就是所求矩阵元的精确解析表达式。", "answer": "$$\\boxed{\\frac{3 - 4\\sqrt{3}}{10}\\sin\\left(\\frac{1}{2}\\right)}$$", "id": "2573017"}, {"introduction": "虽然指数映射提供了更新旋转的方法，但在数千个步长上累积这些更新会引入数值误差，导致旋转矩阵失去其关键的正交性。这项高级实践将挑战您实现并比较两种流行的数值方案：直接矩阵更新和更稳健的基于四元数的方法。通过这个编程练习，您将亲身体验数值漂移问题，并领会为何在图形学、机器人学和计算动力学的大规模模拟中，使用四元数来保证稳定性和准确性具有实际优势。[@problem_id:2573012]", "problem": "实现一个程序，用于比较三维大位移大转动运动学中的两种旋转更新方案。这两种方案是：(i) 带每步重新归一化的单位四元数复合更新，以及 (ii) 使用每步旋转向量的矩阵指数进行旋转矩阵更新，在累积过程中不进行任何重新正交化。目的是评估两种方案在多次增量更新后的数值稳定性和精度。\n\n您必须从以下基本依据开始：\n- 刚性旋转运动学由一个正常正交矩阵 $R \\in \\mathrm{SO}(3)$ 表示，满足 $R^{\\mathsf{T}} R = I$ 和 $\\det(R) = 1$。\n- 一个小的增量旋转可以用旋转向量 $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ 表示，其范数是旋转角度（以弧度为单位），其方向是旋转轴。\n- 反对称矩阵 $[\\boldsymbol{\\varphi}]_{\\times}$ 的矩阵指数将旋转向量 $\\boldsymbol{\\varphi}$ 映射到 $R = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)$。\n- 一个范数为单位的单位四元数 $q \\in \\mathbb{R}^4$ 表示 $\\mathrm{SO}(3)$ 中的一个旋转，四元数乘法复合旋转；对 $q$ 进行归一化可以保持其单位长度。\n\n任务要求：\n1. 实现一个函数，给定一个以弧度为单位的每步旋转向量 $\\boldsymbol{\\varphi}_k$，构造相关的单位四元数增量，并将其与当前四元数复合。每次复合后，重新归一化四元数。使用单位四元数进行初始化。最后，将四元数转换为旋转矩阵 $R_{\\mathrm{quat}}$。\n2. 实现一个函数，给定相同的每步旋转向量 $\\boldsymbol{\\varphi}_k$，使用矩阵指数 $\\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ 构造相应的增量旋转矩阵（对小角度使用数值稳定的公式），并将其左乘到当前旋转矩阵上，不进行任何重新正交化。使用单位矩阵进行初始化。最后，将累积的矩阵表示为 $R_{\\mathrm{mat}}$。\n3. 对于下面指定的每个测试用例，计算以下量化诊断指标：\n   - 每种方法的正交性误差：$e_{\\mathrm{orth}}(R) = \\left\\|R^{\\mathsf{T}} R - I\\right\\|_F$。\n   - 每种方法的行列式偏差：$e_{\\det}(R) = \\left|\\det(R) - 1\\right|$。\n   - 相对于参考旋转矩阵 $R_{\\mathrm{ref}}$ 的旋转角度误差：$e_{\\angle}(R, R_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\dfrac{\\mathrm{tr}\\left(R^{\\mathsf{T}} R_{\\mathrm{ref}}\\right) - 1}{2}, -1, 1\\right)\\right)$，以弧度表示。\n4. 参考旋转 $R_{\\mathrm{ref}}$：\n   - 对于每步旋转向量恒定的测试用例，精确的参考值为 $R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$，因为当增量旋转向量恒定时，指数是可交换的。这里，$N$ 是步数。\n   - 对于每步旋转向量随步数变化的测试用例，将 $R_{\\mathrm{ref}}$ 定义为精确乘积 $\\widehat{R} = \\prod_{k=1}^{N} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$（在有限精度下计算）在 $\\mathrm{SO}(3)$ 上的正交投影（通过使用奇异值分解的极分解）。这样可以定义一个稳定的、无需步内重新正交化的参考值。\n\n角度单位要求：\n- 所有角度和旋转向量都必须以弧度处理。所有报告的角度误差都必须以弧度表示。\n\n测试套件：\n使用以下四个测试用例。对于每个用例，每步旋转向量以弧度为单位给出，$N$ 是步数。\n- 测试 1（恒定增量，多轴）：\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.001,\\,-0.002,\\,0.0015\\,]$, $N = 10000$。\n  - 参考值：$R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$。\n- 测试 2（恒定增量，单轴，中等步长）：\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.01,\\,0.0,\\,0.0\\,]$, $N = 3000$。\n  - 参考值：$R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$。\n- 测试 3（时变增量，非对易累积）：\n  - 对于 $k = 0,1,\\dots,N-1$ 且 $N=8000$，定义 $\\boldsymbol{\\varphi}_k = s \\,[\\,\\cos(\\alpha k),\\, \\sin(\\alpha k),\\, 0.5\\,]$，其中 $s = 0.002$ 且 $\\alpha = 0.005$。\n  - 参考值：令 $\\widehat{R} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$，并将 $R_{\\mathrm{ref}}$ 定义为通过对 $\\widehat{R}$ 进行极分解得到的最接近的旋转。\n- 测试 4（近零增量，极端小角度鲁棒性）：\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,10^{-12},\\, -2\\times 10^{-12},\\, 3\\times 10^{-12}\\,]$, $N = 1000$。\n  - 参考值：$R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$。\n\n您的程序必须：\n- 为四元数增量和矩阵指数实现数值稳定的小角度公式，以避免当 $\\|\\boldsymbol{\\varphi}\\| \\to 0$ 时出现除以零的情况。\n- 为每个测试用例按以下顺序生成六个诊断指标（作为浮点数）：\n  1. $e_{\\mathrm{orth}}(R_{\\mathrm{quat}})$\n  2. $e_{\\mathrm{orth}}(R_{\\mathrm{mat}})$\n  3. $e_{\\det}(R_{\\mathrm{quat}})$\n  4. $e_{\\det}(R_{\\mathrm{mat}})$\n  5. $e_{\\angle}(R_{\\mathrm{quat}}, R_{\\mathrm{ref}})$（以弧度为单位）\n  6. $e_{\\angle}(R_{\\mathrm{mat}}, R_{\\mathrm{ref}})$（以弧度为单位）\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有四个测试用例的串联结果，格式为方括号内以逗号分隔的列表。该列表必须包含 24 个浮点数，其顺序按照每个测试用例指定的顺序以及测试 1 到 4 的顺序排列（例如，$[r_1,r_2,\\dots,r_{24}]$）。不得打印任何额外文本。", "solution": "我们将构建基于刚性旋转运动学以及斜对称矩阵李代数与旋转矩阵李群之间的指数映射。一个旋转矩阵 $R \\in \\mathrm{SO}(3)$ 满足 $R^{\\mathsf{T}}R = I$ 和 $\\det(R) = 1$。当 $\\theta \\neq 0$ 时，旋转向量 $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ 编码了一个绕单位轴 $\\mathbf{u} = \\boldsymbol{\\varphi}/\\theta$ 旋转角度为 $\\theta = \\|\\boldsymbol{\\varphi}\\|$ 的旋转。相关的斜对称矩阵是 $[\\boldsymbol{\\varphi}]_{\\times}$，对于 $\\boldsymbol{\\varphi} = [\\varphi_1,\\varphi_2,\\varphi_3]^{\\mathsf{T}}$ 定义为\n$$\n[\\boldsymbol{\\varphi}]_{\\times} =\n\\begin{bmatrix}\n0 & -\\varphi_3 & \\varphi_2\\\\\n\\varphi_3 & 0 & -\\varphi_1\\\\\n-\\varphi_2 & \\varphi_1 & 0\n\\end{bmatrix}.\n$$\n矩阵指数通过以下方式为每步旋转向量 $\\boldsymbol{\\varphi}$ 提供更新：\n$$\nR_{\\mathrm{inc}} = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)\n= I + \\frac{\\sin \\theta}{\\theta}[\\boldsymbol{\\varphi}]_{\\times}\n+ \\frac{1 - \\cos \\theta}{\\theta^2}[\\boldsymbol{\\varphi}]_{\\times}^2,\n$$\n其中 $I$ 是单位矩阵，$\\theta = \\|\\boldsymbol{\\varphi}\\|$。此表示源自 Rodrigues' rotation formula。对于小 $\\theta$，我们使用级数展开来避免除以零：\n$$\n\\frac{\\sin \\theta}{\\theta} = 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120} + \\mathcal{O}(\\theta^6), \\quad\n\\frac{1 - \\cos \\theta}{\\theta^2} = \\frac{1}{2} - \\frac{\\theta^2}{24} + \\frac{\\theta^4}{720} + \\mathcal{O}(\\theta^6).\n$$\n那么，不带重新正交化的基于矩阵的累积过程是：\n$R_{k+1}^{\\mathrm{mat}} = R_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\, R_k^{\\mathrm{mat}}$, $R_0^{\\mathrm{mat}} = I$.\n由于浮点误差，重复乘法可能导致结果偏离 $\\mathrm{SO}(3)$，造成 $R^{\\mathsf{T}}R \\neq I$ 和 $\\det(R) \\neq 1$。\n\n或者，一个单位四元数 $q = [q_0,q_1,q_2,q_3]^{\\mathsf{T}}$ 在约束 $\\|q\\|=1$ 下表示相同的旋转，通过一个光滑同态映射到一个旋转矩阵。与旋转向量 $\\boldsymbol{\\varphi}$ 相关的四元数增量是：\n$$\nq_{\\mathrm{inc}} = \\begin{bmatrix}\n\\cos(\\theta/2)\\\\\n\\mathbf{u} \\, \\sin(\\theta/2)\n\\end{bmatrix}, \\quad \\theta = \\|\\boldsymbol{\\varphi}\\|, \\ \\mathbf{u} = \n\\begin{cases}\n\\boldsymbol{\\varphi}/\\theta, & \\theta \\neq 0,\\\\\n[0,0,0]^{\\mathsf{T}}, & \\theta = 0,\n\\end{cases}\n$$\n带有小角度稳定化处理：\n$$\n\\frac{\\sin(\\theta/2)}{\\theta} = \\frac{1}{2} - \\frac{\\theta^2}{48} + \\frac{\\theta^4}{3840} + \\mathcal{O}(\\theta^6).\n$$\n旋转的四元数复合对应于四元数乘法 $\\otimes$。累积过程如下：\n$q_{k+1} = q_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\otimes q_k$, $q_0 = [1,0,0,0]^{\\mathsf{T}}$,\n并进行显式归一化：\n$$\nq_{k+1} \\leftarrow \\frac{q_{k+1}}{\\|q_{k+1}\\|},\n$$\n以减轻浮点漂移。最终的旋转矩阵是 $R_{\\mathrm{quat}} = \\mathcal{R}(q_N)$，其中 $\\mathcal{R}(\\cdot)$ 是四元数到旋转的映射，当 $q$ 长度为单位时，该映射保持正交性。\n\n为了验证和评估稳定性，我们为任意 $3\\times 3$ 矩阵 $R$ 定义以下诊断指标：\n- 正交性误差 $e_{\\mathrm{orth}}(R) = \\|R^{\\mathsf{T}}R - I\\|_F$（弗罗贝尼乌斯范数）。\n- 行列式偏差 $e_{\\det}(R) = |\\det(R) - 1|$。\n- 相对于参考值 $R_{\\mathrm{ref}}$ 的旋转角度误差：\n$$\ne_{\\angle}(R, R_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\frac{\\operatorname{tr}(R^{\\mathsf{T}} R_{\\mathrm{ref}}) - 1}{2}, \\,-1,\\, 1\\right)\\right),\n$$\n它给出相对旋转 $\\Delta R = R^{\\mathsf{T}} R_{\\mathrm{ref}}$ 的主角度（以弧度为单位）。裁剪（Clipping）操作确保了数值鲁棒性，以防止舍入误差超出反余弦函数的定义域。\n\n对于恒定的每步增量 $\\boldsymbol{\\varphi}_{\\text{step}}$，精确参考值为：\n$$\nR_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right),\n$$\n因为 $[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}$ 与自身可交换，所以有 $\\left(\\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)\\right)^N = \\exp\\left(N \\,[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)$。对于时变增量 $\\boldsymbol{\\varphi}_k$，非对易性使其没有封闭形式的解。因此，我们计算乘积：\n$$\n\\widehat{R} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right),\n$$\n并通过极分解将其投影到 $\\mathrm{SO}(3)$ 上。令 $\\widehat{R} = U \\Sigma V^{\\mathsf{T}}$ 为奇异值分解，那么最接近的旋转（在弗罗贝尼乌斯范数下）是：\n$R_{\\mathrm{ref}} = U \\, \\operatorname{diag}(1,1,\\operatorname{sign}(\\det(UV^{\\mathsf{T}}))) \\, V^{\\mathsf{T}}$.\n\n算法设计：\n1. 实现一个鲁棒的函数，使用对于小 $\\theta$ 的 $\\sin\\theta/\\theta$ 和 $(1-\\cos\\theta)/\\theta^2$ 的级数展开，将 $\\boldsymbol{\\varphi}$ 映射到 $R_{\\mathrm{inc}}$。\n2. 实现四元数增量映射，对小 $\\theta$ 使用 $\\sin(\\theta/2)/\\theta$ 的鲁棒评估，并通过四元数乘法进行复合，每步之后进行归一化。\n3. 对每个测试用例模拟两种累积过程，以获得 $R_{\\mathrm{quat}}$ 和 $R_{\\mathrm{mat}}$。\n4. 构建参考值 $R_{\\mathrm{ref}}$：\n   - 对于恒定情况：作为在 $N \\boldsymbol{\\varphi}_{\\text{step}}$ 处的单个指数。\n   - 对于变化情况：作为指数直积的极因子。\n5. 为 $R_{\\mathrm{quat}}$ 和 $R_{\\mathrm{mat}}$ 计算诊断指标 $e_{\\mathrm{orth}}$、 $e_{\\det}$ 和 $e_{\\angle}$。\n6. 按指定顺序输出 24 个浮点数结果：\n   - 对于每个测试 $i \\in \\{1,2,3,4\\}$，输出 $[\\,e_{\\mathrm{orth}}(R_{\\mathrm{quat}}^{(i)}),\\ e_{\\mathrm{orth}}(R_{\\mathrm{mat}}^{(i)}),\\ e_{\\det}(R_{\\mathrm{quat}}^{(i)}),\\ e_{\\det}(R_{\\mathrm{mat}}^{(i)}),\\ e_{\\angle}(R_{\\mathrm{quat}}^{(i)}, R_{\\mathrm{ref}}^{(i)}),\\ e_{\\angle}(R_{\\mathrm{mat}}^{(i)}, R_{\\mathrm{ref}}^{(i)})\\,]$。\n   将四个子列表串联成一个单一列表，并作为单行打印。\n\n预期定性结果：\n- 带每步归一化的四元数方法应在所有测试中将 $e_{\\mathrm{orth}}$ 和 $e_{\\det}$ 维持在机器精度附近，展现出高数值稳定性。\n- 不带重新正交化的矩阵指数累积预计会随着步数的增加而表现出增大的 $e_{\\mathrm{orth}}$ 和 $e_{\\det}$，表明其偏离了 $\\mathrm{SO}(3)$。\n- 在各个测试中，四元数方法的角度误差 $e_{\\angle}$ 通常应小于或与矩阵方法相当；在步数很多或接近奇异构型（例如长序列或极小角度，此时稳定的级数展开至关重要）的情况下，差异会变得更加明显。\n\n所有角度都必须以弧度表示。除角度单位外，不涉及其他物理单位。程序必须精确打印一行：一个包含 24 个指定浮点数的单一列表，不含任何额外文本。", "answer": "```python\nimport numpy as np\n\ndef skew(v):\n    \"\"\"Return the 3x3 skew-symmetric matrix of a 3-vector v.\"\"\"\n    vx, vy, vz = v\n    return np.array([[0.0, -vz,  vy],\n                     [vz,  0.0, -vx],\n                     [-vy, vx,  0.0]], dtype=float)\n\ndef safe_sinc(x):\n    \"\"\"Return sin(x)/x with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax < 1e-8:\n        x2 = x*x\n        # 1 - x^2/6 + x^4/120\n        return 1.0 - x2/6.0 + x2*x2/120.0\n    return np.sin(x)/x\n\ndef safe_one_minus_cos_over_x2(x):\n    \"\"\"Return (1-cos(x))/x^2 with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax < 1e-8:\n        x2 = x*x\n        # 1/2 - x^2/24 + x^4/720\n        return 0.5 - x2/24.0 + x2*x2/720.0\n    return (1.0 - np.cos(x))/(x*x)\n\ndef exp_rotvec(phi):\n    \"\"\"\n    Compute rotation matrix R = exp([phi]_x) using Rodrigues' formula with\n    stable small-angle handling.\n    \"\"\"\n    theta = np.linalg.norm(phi)\n    A = skew(phi)\n    if theta < 1e-16:\n        # Very small, R ~ I + A\n        return np.eye(3) + A\n    a = safe_sinc(theta)\n    b = safe_one_minus_cos_over_x2(theta)\n    return np.eye(3) + a * A + b * (A @ A)\n\ndef quat_mul(p, q):\n    \"\"\"Hamilton product p ⊗ q for quaternions p=[w,x,y,z], q=[w,x,y,z].\"\"\"\n    pw, px, py, pz = p\n    qw, qx, qy, qz = q\n    w = pw*qw - px*qx - py*qy - pz*qz\n    x = pw*qx + px*qw + py*qz - pz*qy\n    y = pw*qy - px*qz + py*qw + pz*qx\n    z = pw*qz + px*qy - py*qx + pz*qw\n    return np.array([w, x, y, z], dtype=float)\n\ndef quat_normalize(q):\n    n = np.linalg.norm(q)\n    if n == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    return q / n\n\ndef rotvec_to_quat(phi):\n    \"\"\"Map rotation vector phi to unit quaternion q = [w, x, y, z].\"\"\"\n    theta = np.linalg.norm(phi)\n    if theta < 1e-16:\n        # q ≈ [1, 0.5*phi]\n        return quat_normalize(np.array([1.0, 0.5*phi[0], 0.5*phi[1], 0.5*phi[2]], dtype=float))\n    half = 0.5 * theta\n    # sin(half)/theta stabilized\n    s = np.sin(half)\n    c = np.cos(half)\n    scale = s / theta\n    q = np.array([c, scale*phi[0], scale*phi[1], scale*phi[2]], dtype=float)\n    return quat_normalize(q)\n\ndef quat_to_R(q):\n    \"\"\"Convert unit quaternion q=[w,x,y,z] to rotation matrix.\"\"\"\n    w, x, y, z = q\n    # Normalize to avoid drift\n    n = w*w + x*x + y*y + z*z\n    if n == 0.0:\n        w, x, y, z = 1.0, 0.0, 0.0, 0.0\n        n = 1.0\n    s = 2.0 / n\n    wx, wy, wz = s*w*x, s*w*y, s*w*z\n    xx, xy, xz = s*x*x, s*x*y, s*x*z\n    yy, yz, zz = s*y*y, s*y*z, s*z*z\n    R = np.array([\n        [1.0 - (yy + zz), xy - wz,       xz + wy      ],\n        [xy + wz,         1.0 - (xx + zz), yz - wx     ],\n        [xz - wy,         yz + wx,       1.0 - (xx + yy)]\n    ], dtype=float)\n    return R\n\ndef orthogonality_error(R):\n    E = R.T @ R - np.eye(3)\n    return float(np.linalg.norm(E, ord='fro'))\n\ndef det_deviation(R):\n    return float(abs(np.linalg.det(R) - 1.0))\n\ndef angle_error(R, Rref):\n    RtR = R.T @ Rref\n    tr = (np.trace(RtR) - 1.0) / 2.0\n    tr = max(-1.0, min(1.0, tr))\n    return float(np.arccos(tr))\n\ndef project_to_SO3(R):\n    \"\"\"Project a matrix to the nearest rotation matrix via SVD-based polar decomposition.\"\"\"\n    U, S, Vt = np.linalg.svd(R)\n    M = U @ Vt\n    if np.linalg.det(M) < 0.0:\n        # Fix reflection\n        D = np.diag([1.0, 1.0, -1.0])\n        M = U @ D @ Vt\n    return M\n\ndef accumulate_quaternion(increments):\n    q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    for phi in increments:\n        q_inc = rotvec_to_quat(phi)\n        q = quat_mul(q_inc, q)\n        q = quat_normalize(q)\n    return quat_to_R(q)\n\ndef accumulate_matrix(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return R\n\ndef reference_constant(phi_step, N):\n    phi_tot = phi_step * N\n    return exp_rotvec(phi_tot)\n\ndef reference_varying(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return project_to_SO3(R)\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: constant increments, multi-axis\n    phi_step1 = np.array([0.001, -0.002, 0.0015], dtype=float)\n    N1 = 10000\n    inc1 = [phi_step1 for _ in range(N1)]\n    Rref1 = reference_constant(phi_step1, N1)\n    tests.append((inc1, Rref1))\n\n    # Test 2: constant increments, single-axis\n    phi_step2 = np.array([0.01, 0.0, 0.0], dtype=float)\n    N2 = 3000\n    inc2 = [phi_step2 for _ in range(N2)]\n    Rref2 = reference_constant(phi_step2, N2)\n    tests.append((inc2, Rref2))\n\n    # Test 3: varying increments\n    N3 = 8000\n    s = 0.002\n    alpha = 0.005\n    inc3 = []\n    for k in range(N3):\n        vk = np.array([np.cos(alpha * k), np.sin(alpha * k), 0.5], dtype=float)\n        inc3.append(s * vk)\n    Rref3 = reference_varying(inc3)\n    tests.append((inc3, Rref3))\n\n    # Test 4: near-zero increments\n    phi_step4 = np.array([1e-12, -2e-12, 3e-12], dtype=float)\n    N4 = 1000\n    inc4 = [phi_step4 for _ in range(N4)]\n    Rref4 = reference_constant(phi_step4, N4)\n    tests.append((inc4, Rref4))\n\n    return tests\n\ndef solve():\n    tests = build_test_cases()\n    results = []\n    for increments, Rref in tests:\n        Rq = accumulate_quaternion(increments)\n        Rm = accumulate_matrix(increments)\n\n        e_orth_q = orthogonality_error(Rq)\n        e_orth_m = orthogonality_error(Rm)\n        e_det_q = det_deviation(Rq)\n        e_det_m = det_deviation(Rm)\n        e_ang_q = angle_error(Rq, Rref)\n        e_ang_m = angle_error(Rm, Rref)\n\n        results.extend([e_orth_q, e_orth_m, e_det_q, e_det_m, e_ang_q, e_ang_m])\n\n    # Print as a single line list, comma-separated, no spaces\n    # Format floats with scientific notation for consistency\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2573012"}]}