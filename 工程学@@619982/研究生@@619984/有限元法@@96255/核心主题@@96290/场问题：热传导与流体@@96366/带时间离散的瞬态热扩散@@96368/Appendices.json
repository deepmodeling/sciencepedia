{"hands_on_practices": [{"introduction": "理论与实践的结合是检验理解的试金石。本练习旨在通过一种称为“制造解法”的基本验证技术，来巩固您对瞬态热扩散问题的有限元离散化的理解。通过从头推导一个简单一维问题的解析解，并将其与有限元 eigenmodes 的离散阻尼率进行比较，您将能深刻体会到空间和时间离散化如何引入数值误差，以及如何量化这种误差。这个过程不仅是验证代码正确性的关键步骤，也是连接连续物理世界与离散数值模型的重要桥梁。[@problem_id:2607785]", "problem": "考虑一根长度为 $L>0$、热扩散率为 $\\alpha>0$ 的均匀杆中的一维瞬态热传导。温度场 $u(x,t)$ 满足齐次 Dirichlet 边界条件 $u(0,t)=0$ 和 $u(L,t)=0$（对所有 $t\\ge 0$ 成立）。初始条件为单一正弦模态 $u(x,0)=\\sin\\!\\left(\\frac{m\\pi x}{L}\\right)$，其中模态指数 $m\\in\\mathbb{N}$。\n\n从局部能量守恒原理和傅里叶定律出发，推导 $u(x,t)$ 的控制偏微分方程（PDE），并论证在该边界条件下连续特征函数是空间正弦模态。通过变量分离法和正交性，推导给定初始条件下模态振幅的解析时间演化。\n\n接下来，用 $N\\in\\mathbb{N}$ 个尺寸为 $h=L/N$ 的单元对空间域进行均匀离散，并采用标准的、带有一致质量矩阵的分段线性有限元方法（FEM）来近似 $u(x,t)$。令 $M$ 和 $K$ 分别表示所得的质量矩阵和刚度矩阵。证明在内部节点索引 $j=1,2,\\dots,N-1$ 处分量为 $\\sin\\!\\left(\\frac{jm\\pi}{N}\\right)$ 的内部网格正弦向量是矩阵束 $(K,M)$ 的广义特征向量，并推导相应的广义特征值的闭式解，该解是关于 $N$、$L$ 和 $m$ 的函数。\n\n使用时间步长为 $\\Delta t>0$ 的后向欧拉（BE）方法对半离散系统 $M \\dot{\\boldsymbol{U}}(t)+\\alpha K \\boldsymbol{U}(t)=\\boldsymbol{0}$ 进行时间离散，并将所得的单步更新公式应用于单一离散特征模态。定义此离散模态的单步放大因子，并将其与从相同模态在长度为 $\\Delta t$ 的时间间隔上的连续解析解得到的精确单步放大因子进行比较。\n\n最后，取连续问题中的 $m$ 与离散模态指数相匹配，并假设 $1\\le m \\le N-1$，推导离散单步放大因子与精确单步放大因子之比 $\\mathcal{R}$ 的单一闭式解析表达式，该表达式以 $\\alpha$、$L$、$N$、$m$ 和 $\\Delta t$ 表示。将您的最终结果表述为单一闭式表达式。$\\mathcal{R}$ 无需单位，也无需四舍五入。", "solution": "所述问题具有科学依据，是适定的、客观且自洽的。这是一个关于偏微分方程数值方法分析的标准练习，尽管包含多个部分。所有参数都已明确定义，任务要求基于数学物理和数值分析的既定原理进行严格推导。因此，该问题是有效的，将提供解答。\n\n首先，我们推导一维热传导的控制偏微分方程（PDE）。我们考虑杆内从 $x$ 到 $x+\\Delta x$ 的一个微元段。局部能量守恒原理指出，该体积内内能的时间变化率等于穿过其边界的净热通量。设 $A$ 为横截面积，$\\rho$ 为密度，$c$ 为比热容。内能为 $\\int_x^{x+\\Delta x} c \\rho A u(x',t) dx'$。热通量由傅里叶定律给出，$q(x,t) = -k \\frac{\\partial u}{\\partial x}$，其中 $k$ 是热导率。能量平衡方程为：\n$$ \\frac{d}{dt} \\int_x^{x+\\Delta x} c \\rho A u(x',t) dx' = A q(x,t) - A q(x+\\Delta x, t) $$\n假设 $c, \\rho, A$ 为常数，我们有：\n$$ \\int_x^{x+\\Delta x} c \\rho A \\frac{\\partial u}{\\partial t} dx' = A \\left( -k \\frac{\\partial u}{\\partial x} \\bigg|_x - \\left( -k \\frac{\\partial u}{\\partial x} \\bigg|_{x+\\Delta x} \\right) \\right) $$\n两边同除以 $A \\Delta x$ 并取 $\\Delta x \\to 0$ 的极限，我们在左边运用微积分基本定理，在右边运用导数的定义：\n$$ c \\rho \\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( k \\frac{\\partial u}{\\partial x} \\right) $$\n对于均匀杆，$k$ 是常数。定义热扩散率 $\\alpha = k/(c\\rho)$，我们得到热方程：\n$$ \\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2} $$\n为求解析解，我们使用变量分离法，假设解的形式为 $u(x,t) = X(x)T(t)$。代入 PDE 得到 $X(x)T'(t) = \\alpha X''(x)T(t)$。分离变量可得：\n$$ \\frac{T'(t)}{\\alpha T(t)} = \\frac{X''(x)}{X(x)} = -\\lambda^2 $$\n为了在齐次 Dirichlet 边界条件 $u(0,t)=u(L,t)=0$ 下有非平凡解，分离常数必须为负。空间问题是算子 $-\\frac{d^2}{dx^2}$ 的一个特征值问题：\n$$ X''(x) + \\lambda^2 X(x) = 0, \\quad X(0)=0, \\quad X(L)=0 $$\n通解为 $X(x) = C_1 \\cos(\\lambda x) + C_2 \\sin(\\lambda x)$。条件 $X(0)=0$ 意味着 $C_1=0$。条件 $X(L)=0$ 意味着 $C_2 \\sin(\\lambda L) = 0$。为了得到非平凡解（$C_2 \\neq 0$），必须有 $\\sin(\\lambda L)=0$，这要求 $\\lambda L = m\\pi$，其中 $m \\in \\mathbb{N}$ 是整数。特征值为 $\\lambda_m^2 = \\left(\\frac{m\\pi}{L}\\right)^2$，对应的特征函数为 $X_m(x) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$。这些就是空间正弦模态。\n\n时间问题是 $T'(t) + \\alpha \\lambda_m^2 T(t) = 0$，其解为 $T_m(t) = T_m(0) \\exp(-\\alpha \\lambda_m^2 t)$。完整解是这些模态的叠加。给定初始条件 $u(x,0) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$，我们看到只存在一个模态。解析解为：\n$$ u(x,t) = \\sin\\left(\\frac{m\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 t\\right) $$\n在时间间隔 $\\Delta t$ 内，精确的单步放大因子是振幅衰减的系数，即：\n$$ G_{\\text{exact}} = \\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right) $$\n现在我们进行有限元离散化。该 PDE 的弱形式是：寻找 $u \\in H^1_0([0,L])$，使得对于所有检验函数 $v \\in H^1_0([0,L])$，都有：\n$$ \\int_0^L \\frac{\\partial u}{\\partial t} v \\,dx + \\alpha \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial v}{\\partial x} \\,dx = 0 $$\n在一个单元尺寸为 $h=L/N$ 的均匀网格上，使用分段线性有限元基 $\\{\\phi_j(x)\\}_{j=1}^{N-1}$，我们近似 $u(x,t) \\approx u_h(x,t) = \\sum_{j=1}^{N-1} U_j(t) \\phi_j(x)$。这导出了半离散系统 $M \\dot{\\boldsymbol{U}}(t)+\\alpha K \\boldsymbol{U}(t)=\\boldsymbol{0}$，其中一致质量矩阵 $M$ 和刚度矩阵 $K$ 的元素为：\n$$ M_{ij} = \\int_0^L \\phi_i \\phi_j \\,dx, \\quad K_{ij} = \\int_0^L \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx} \\,dx $$\n对于一维均匀网格上的帽函数，这些矩阵是三对角的，其元素为：$M_{ii} = \\frac{2h}{3}$，$M_{i,i\\pm 1} = \\frac{h}{6}$，$K_{ii} = \\frac{2}{h}$，以及 $K_{i,i\\pm 1} = -\\frac{1}{h}$。\n\n我们必须证明，对于 $j=1, \\dots, N-1$，分量为 $(v_m)_j = \\sin\\left(\\frac{jm\\pi}{N}\\right)$ 的离散正弦向量 $\\boldsymbol{v}_m$ 是 $(K,M)$ 的广义特征向量，并求出满足 $K\\boldsymbol{v}_m = \\Lambda_m M\\boldsymbol{v}_m$ 的特征值 $\\Lambda_m$。我们计算 $K$ 和 $M$ 在 $\\boldsymbol{v}_m$ 上的作用。对于第 $j$ 个分量：\n$$ (K\\boldsymbol{v}_m)_j = \\frac{1}{h}\\left[-\\sin\\left(\\frac{(j-1)m\\pi}{N}\\right) + 2\\sin\\left(\\frac{jm\\pi}{N}\\right) - \\sin\\left(\\frac{(j+1)m\\pi}{N}\\right)\\right] $$\n使用恒等式 $\\sin(A-B)+\\sin(A+B) = 2\\sin(A)\\cos(B)$，上式可简化为：\n$$ (K\\boldsymbol{v}_m)_j = \\frac{1}{h}\\left[2\\sin\\left(\\frac{jm\\pi}{N}\\right) - 2\\sin\\left(\\frac{jm\\pi}{N}\\right)\\cos\\left(\\frac{m\\pi}{N}\\right)\\right] = \\frac{2}{h}\\left(1 - \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)(v_m)_j $$\n对于质量矩阵：\n$$ (M\\boldsymbol{v}_m)_j = \\frac{h}{6}\\left[\\sin\\left(\\frac{(j-1)m\\pi}{N}\\right) + 4\\sin\\left(\\frac{jm\\pi}{N}\\right) + \\sin\\left(\\frac{(j+1)m\\pi}{N}\\right)\\right] $$\n$$ (M\\boldsymbol{v}_m)_j = \\frac{h}{6}\\left[2\\sin\\left(\\frac{jm\\pi}{N}\\right)\\cos\\left(\\frac{m\\pi}{N}\\right) + 4\\sin\\left(\\frac{jm\\pi}{N}\\right)\\right] = \\frac{h}{3}\\left(2 + \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)(v_m)_j $$\n正弦向量确实是这两个矩阵的特征向量。广义特征值 $\\Lambda_m$ 是它们各自特征值的比值：\n$$ \\Lambda_m = \\frac{\\frac{2}{h}\\left(1 - \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)}{\\frac{h}{3}\\left(2 + \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)} = \\frac{6}{h^2}\\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)} $$\n代入 $h=L/N$，广义特征值为：\n$$ \\Lambda_m = \\frac{6N^2}{L^2} \\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)} $$\n接下来，我们使用后向欧拉方法对半离散系统进行时间离散。对于单个特征模态，系统简化为关于模态振幅 $c(t)$ 的标量常微分方程 $c'(t) + \\alpha \\Lambda_m c(t) = 0$。将步长为 $\\Delta t$ 的后向欧拉法应用于形式为 $\\dot{y}=-\\lambda y$ 的方程，得到 $y^{n+1} = y^n - \\lambda \\Delta t y^{n+1}$，这给出了更新式 $y^{n+1} = (1+\\lambda\\Delta t)^{-1} y^n$。在这里，$\\lambda = \\alpha \\Lambda_m$。离散单步放大因子是：\n$$ G_{\\text{discrete}} = \\frac{1}{1 + \\alpha \\Lambda_m \\Delta t} = \\frac{1}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}} $$\n最后，我们计算离散放大因子与精确放大因子之比 $\\mathcal{R}$。\n$$ \\mathcal{R} = \\frac{G_{\\text{discrete}}}{G_{\\text{exact}}} = \\frac{\\left(1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}\\right)^{-1}}{\\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)} $$\n这可简化为最终表达式：\n$$ \\mathcal{R} = \\frac{\\exp\\left(\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}} $$\n这就是所要求的 $\\mathcal{R}$ 的闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{\\exp\\left(\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)}}}\n$$", "id": "2607785"}, {"introduction": "数值方法在理论上可能表现优异，但在实践中可能会遇到意想不到的挑战。本练习将引导您通过编码实践，探索一个著名且重要的数值现象：Crank-Nicolson 格式在处理强梯度问题时可能产生的非物理振荡和对解的正性保持的失败。通过在一个具有尖锐初始条件的二维热传导问题中观察并分析这些虚假振荡，您将亲身体会到时间步长、网格尺寸和解的光滑度之间的微妙相互作用。这有助于培养一种批判性的视角，即认识到即使是无条件稳定的方法，也未必总能保证解的物理真实性。[@problem_id:2607746]", "problem": "你需要实现一个瞬态热扩散求解器，该求解器在锐角三角剖分上使用连续分片线性基函数，并采用有限元方法。目标是设计一个具有强梯度的测试用例，评估 Crank-Nicolson 时间离散化在锐角三角剖分上是否保持有限元解的正性，并解释任何观察到的振荡。你的程序必须从第一性原理出发组装空间算子，并直接对解进行时间步进。\n\n从以下基本物理和数学基础开始：\n- 连续介质中的能量守恒：对于温度场 $u(\\boldsymbol{x},t)$、导热系数 $\\kappa$、密度 $\\rho$ 和热容 $c$，无源情况下的能量平衡方程为 $\\rho c\\, \\partial_t u - \\nabla \\cdot (\\kappa \\nabla u) = 0$。\n- 傅里叶热传导定律：热通量为 $\\boldsymbol{q} = -\\kappa \\nabla u$。\n- 假设经过无量纲化后，$\\rho c = 1$ 和 $\\kappa = 1$，因此控制方程简化为在域 $\\Omega$ 内的 $\\partial_t u - \\Delta u = 0$，边界 $\\partial \\Omega$ 上具有齐次 Dirichlet 边界条件 $u=0$。\n\n你必须：\n- 在一个顶点为 $(0,0)$、$(1,0)$ 和 $(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})$ 的等边三角形域 $\\Omega$ 上，推导初始边界值问题的弱形式。在一个通过将等边三角形细分为 $N \\times N$ 个均匀子三角形（所有内角严格小于 $90^\\circ$）得到的协调、形状规则的锐角三角剖分上，使用连续分片线性的试探函数和检验函数。使用一致质量矩阵。\n- 使用 Crank-Nicolson 方法对时间进行离散化，时间步长为 $\\Delta t$，源项为零，即对半离散系统应用梯形法则。通过消除边界自由度，在每个时间步强施加 Dirichlet 边界条件。\n- 使用初始条件 $u(\\boldsymbol{x},0) = \\exp\\!\\big(-\\|\\boldsymbol{x}-\\boldsymbol{x}_c\\|^2/(2\\sigma^2)\\big)$，其中 $\\boldsymbol{x}_c$ 是顶顶点 $(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})$，并在边界节点处设置 $u=0$ 以与边界条件保持一致。对于较小的 $\\sigma$，此选择会产生强的空间梯度。\n- 通过跟踪所有时间步的最小和最大节点值，评估数值解随时间变化的正性，并计算一个布尔值，指示解是否在容差 $\\varepsilon = 10^{-12}$ 内保持非负。此外，使用模拟过程中遇到的全局最小值和最大值，计算一个下冲比率，定义为 $r = \\max(0,-\\min u)/\\max u$，其中最大值取自所有节点和所有时间步。如果 $\\max u$ 在容差范围内为零，则定义 $r=0$ 以避免除以零。\n\n你的程序必须从第一性原理出发实现以下内容：\n- 在 $\\Omega$ 上对热方程进行分部积分后，并在 $\\partial \\Omega$ 上 $u=0$ 的弱形式。\n- 使用三角形上的线性形函数组装全局一致质量矩阵和刚度矩阵。\n- 半离散系统的 Crank-Nicolson 更新。\n- 使用网格的点阵描述来识别等边三角剖分的边界节点。\n\n你必须在以下参数值 $(N,\\Delta t, n_{\\text{steps}}, \\sigma)$ 的测试套件上运行求解器：\n- 案例 1：$(12, 5\\times 10^{-4}, 40, 0.04)$。\n- 案例 2：$(12, 5\\times 10^{-3}, 4, 0.02)$。\n- 案例 3：$(8, 1\\times 10^{-2}, 3, 0.015)$。\n- 案例 4：$(20, 1\\times 10^{-3}, 20, 0.04)$。\n\n对于每个案例，你必须：\n- 如上所述，组装每边有 $N$ 个细分的网格。\n- 从高斯分布初始化 $u^0$，并在边界节点处强制 $u=0$。\n- 使用时间步长 $\\Delta t$，通过 Crank-Nicolson 方法推进 $n_{\\text{steps}}$ 步。\n- 记录所有节点和时间步上的全局最小值 $m$ 和最大值 $M$，计算布尔值 $\\text{nonneg} = (m \\ge -\\varepsilon)$（其中 $\\varepsilon = 10^{-12}$），并计算如上定义的下冲比率 $r$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。对于每个测试用例，按此顺序输出一个形式为 $[m, M, \\text{nonneg}, r]$ 的列表，其中 $m$ 和 $M$ 是浮点数，$\\text{nonneg}$ 是一个布尔值，$r$ 是一个浮点数。总输出必须是这些按案例排列的列表的列表，例如：\n\"[ [m1,M1,nonneg1,r1], [m2,M2,nonneg2,r2], [m3,M3,nonneg3,r3], [m4,M4,nonneg4,r4] ]\"\n所有数字都是无量纲的；不需要物理单位。\n\n你的实现必须是一个完整的、可按規定运行的程序。不允许用户输入；所有参数均如上所述。你的代码必须仅依赖于允许的库，并且必须符合本任务其他地方说明的执行环境。", "solution": "所提出的问题是在偏微分方程数值解领域中一个适定且有科学依据的练习。它要求在一个特定的域几何上实现一个用于瞬态热方程的有限元方法 (FEM) 求解器。所有必需的物理定律、数学公式和数值参数都已提供。问题要求分析一个关键的数值属性，即 Crank-Nicolson 时间步进格式在锐角三角剖分上的正性保持，这是数值分析中的一个经典课题。网格的锐角性质以及时间步长相对于网格间距的大小对此属性至关重要，这一前提是正确的。该问题是有效的，我将着手提供一个完整的解决方案。\n\n推导和实现将遵循以下步驟：\n1.  **弱形式**：控制方程是无量纲化的热方程，$\\partial_t u - \\Delta u = 0$，在域 $\\Omega$ 内，具有齐次 Dirichlet 边界条件 $u=0$ on $\\partial\\Omega$。为推导弱形式，我们将方程乘以一个来自 Sobolev 空间 $H_0^1(\\Omega)$（即一阶导数平方可积且在边界 $\\partial\\Omega$ 上为零的函数空间）的检验函数 $v$，并在 $\\Omega$ 上积分：\n    $$ \\int_{\\Omega} (\\partial_t u) v \\, d\\boldsymbol{x} - \\int_{\\Omega} (\\Delta u) v \\, d\\boldsymbol{x} = 0 $$\n    对第二项应用格林第一恒等式（分部积分）可得：\n    $$ \\int_{\\Omega} (\\Delta u) v \\, d\\boldsymbol{x} = - \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} + \\int_{\\partial\\Omega} (\\nabla u \\cdot \\boldsymbol{n}) v \\, dS $$\n    由于检验函数 $v \\in H_0^1(\\Omega)$，因此在边界 $\\partial\\Omega$ 上 $v=0$，这使得边界积分为零。于是弱形式为：求 $u(\\cdot, t) \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$：\n    $$ \\int_{\\Omega} (\\partial_t u) v \\, d\\boldsymbol{x} + \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} = 0 $$\n\n2.  **空间离散化 (FEM)**：我们在一个有限维子空间 $V_h \\subset H_0^1(\\Omega)$ 中寻找近似解 $u_h(\\boldsymbol{x}, t)$。我们将 $u_h$ 定义为与网格内部节点相关联的基函数 $\\phi_j(\\boldsymbol{x})$ 的线性组合：\n    $$ u_h(\\boldsymbol{x}, t) = \\sum_{j \\in \\mathcal{I}} U_j(t) \\phi_j(\\boldsymbol{x}) $$\n    其中 $\\mathcal{I}$ 是内部节点的索引集，$U_j(t)$ 是代表这些节点上温度的未知、随时间变化的系数。通过选择检验函数 $v$ 为基函数 $\\phi_i$（其中 $i \\in \\mathcal{I}$），即伽辽金方法，我们得到一个常微分方程（ODE）组：\n    $$ \\sum_{j \\in \\mathcal{I}} \\left(\\int_{\\Omega} \\phi_i \\phi_j \\, d\\boldsymbol{x}\\right) \\frac{dU_j}{dt} + \\sum_{j \\in \\mathcal{I}} \\left(\\int_{\\Omega} \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\boldsymbol{x}\\right) U_j(t) = 0, \\quad \\forall i \\in \\mathcal{I} $$\n    这就是半离散系统，写成矩阵形式为：\n    $$ M \\frac{d\\boldsymbol{U}}{dt} + K \\boldsymbol{U} = \\boldsymbol{0} $$\n    其中 $\\boldsymbol{U}(t)$ 是节点值 $\\{U_j(t)\\}_{j \\in \\mathcal{I}}$ 的向量。矩阵 $M$ 和 $K$ 分别是限制在内部自由度上的一致质量矩阵和刚度矩阵。它们的项为：\n    $$ M_{ij} = \\int_{\\Omega} \\phi_i \\phi_j \\, d\\boldsymbol{x}, \\quad K_{ij} = \\int_{\\Omega} \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\boldsymbol{x} $$\n\n3.  **时间离散化 (Crank–Nicolson)**：我们使用时间步长为 $\\Delta t$ 的梯形法则（Crank–Nicolson 格式）对时间导数进行离散化，其中 $\\boldsymbol{U}^n \\approx \\boldsymbol{U}(n\\Delta t)$：\n    $$ M \\frac{\\boldsymbol{U}^{n+1} - \\boldsymbol{U}^n}{\\Delta t} + K \\frac{\\boldsymbol{U}^{n+1} + \\boldsymbol{U}^n}{2} = \\boldsymbol{0} $$\n    重新整理各项以求解下一时间步的未知状态 $\\boldsymbol{U}^{n+1}$，得到线性系统：\n    $$ \\left(M + \\frac{\\Delta t}{2} K\\right) \\boldsymbol{U}^{n+1} = \\left(M - \\frac{\\Delta t}{2} K\\right) \\boldsymbol{U}^n $$\n    这个系统必须在每个时间步求解。左侧的矩阵是常数，因此为了提高效率可以预先计算其分解。\n\n4.  **单元矩阵**：全局矩阵 $M$ 和 $K$ 是通过对局部单元矩阵 $M^e$ 和 $K^e$ 的贡献求和来组装的。对于使用边长为 $h = 1/N$ 的等边三角形进行的均匀三角剖分，所有单元矩阵都是相同的。每个单元的面积是 $A = \\frac{\\sqrt{3}}{4}h^2$。对于分片线性 ($\\mathbb{P}_1$) 基函数，单元刚度矩阵和质量矩阵为：\n    $$ K^e = \\frac{1}{2\\sqrt{3}} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix}, \\quad M^e = \\frac{A}{12} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} = \\frac{\\sqrt{3}h^2}{48} \\begin{pmatrix} 2 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 2 \\end{pmatrix} $$\n    刚度矩阵 $K^e$ 具有非正的非对角项，其组装得到的全局刚度矩阵 $K$ 对于锐角三角剖分是一个 M-矩阵。这个性质对于离散极值原理至关重要。然而，Crank-Nicolson 更新矩阵 $(M + \\frac{\\Delta t}{2} K)^{-1} (M - \\frac{\\Delta t}{2} K)$ 并不保证正性，除非满足关于 $\\Delta t$ 的某个条件。具体来说，如果矩阵 $M - \\frac{\\Delta t}{2} K$ 是非负的，则正性得以保持，这施加了一个形式为 $\\Delta t \\le C h^2$ 的类 CFL 条件。问题的案例旨在探究这个条件：具有较大 $\\Delta t$ 的案例预计会违反该条件并产生非物理振荡（下冲），即使初始条件处处非负，也会导致出现负的温度值。\n\n5.  **实现策略**：\n    - **网格**：将顶点为 $(0,0)$、$(1,0)$ 和 $(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$ 的等边三角形域三角剖分成 $N^2$ 个更小的等边三角形。节点使用重心坐标系生成。一个节点 $\\boldsymbol{x}_{ijk}$ 定义为 $\\boldsymbol{x}_{ijk} = \\frac{i}{N}(0,0) + \\frac{j}{N}(1,0) + \\frac{k}{N}(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$，其中 $i,j,k$ 是非负整数且 $i+j+k=N$。我们可以使用 $(j,k)$ 作为独立索引 ($j,k \\ge 0$, $j+k \\le N$)。\n    - **组装**：通过遍历所有单元并将局部单元矩阵的贡献加到相应的全局索引上，来组装全局矩阵 $M$ 和 $K$。\n    - **边界条件**：通过识别所有边界节点（在重心索引中 $i=0$ 或 $j=0$ 或 $k=0$）并将线性系统限制为仅内部节点，来强制施加 Dirichlet 边界条件 ($u=0$)。\n    - **时间推进**：通过在所有内部节点坐标上评估高斯函数并设置边界节点为 0，来构造初始条件向量 $\\boldsymbol{U}^0$。然后，通过重复求解 Crank-Nicolson 线性系统，模拟进行 $n_{\\text{steps}}$ 步。\n    - **分析**：在模拟过程中，从 $t=0$到 $t_{final}$ 的每个时间步，都会跟踪所有节点（内部和边界）的最小和最大节点值。这些值用于计算最终所需的度量指标：全局最小值 $m$、全局最大值 $M$、表示正性的布尔值 `nonneg` 以及下冲比率 $r$。\n\n下面的程序从第一性原理出发实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM solver for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, n_steps, sigma)\n        (12, 5e-4, 40, 0.04),\n        (12, 5e-3, 4, 0.02),\n        (8, 1e-2, 3, 0.015),\n        (20, 1e-3, 20, 0.04),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        N, dt, n_steps, sigma = params\n        result = run_simulation(N, dt, n_steps, sigma)\n        all_results.append(result)\n\n    # Format the final output string\n    # E.g., [[-2.3e-05, 0.9, False, 2.5e-05], ...]\n    # using f-strings for demonstration of format. The exact values will be computed.\n    result_str = \"[\" + \", \".join([\n        f\"[{m:.8e}, {M:.8e}, {str(nonneg).lower()}, {r:.8e}]\"\n        for m, M, nonneg, r in all_results\n    ]) + \"]\"\n    print(result_str)\n\ndef run_simulation(N, dt, n_steps, sigma):\n    \"\"\"\n    Runs a single simulation for the transient heat equation using FEM.\n    \n    Args:\n        N (int): Number of subdivisions along each edge of the domain.\n        dt (float): Time step size.\n        n_steps (int): Number of time steps to perform.\n        sigma (float): Standard deviation of the initial Gaussian pulse.\n\n    Returns:\n        tuple: A tuple containing (m, M, nonneg, r) for the simulation.\n    \"\"\"\n    TOL = 1.0e-12\n\n    # 1. Mesh Generation\n    # Vertices of the main equilateral triangle\n    v1 = np.array([0.0, 0.0])\n    v2 = np.array([1.0, 0.0])\n    v3 = np.array([0.5, np.sqrt(3.0) / 2.0])\n\n    # Generate nodes using barycentric coordinates\n    nodes = []\n    node_map = {}  # maps (j, k) -> node_idx\n    idx_counter = 0\n    for k in range(N + 1):\n        for j in range(N - k + 1):\n            i = N - j - k\n            coord = (j / N) * v2 + (k / N) * v3  # v1 is origin\n            nodes.append(coord)\n            node_map[(j, k)] = idx_counter\n            idx_counter += 1\n    nodes = np.array(nodes)\n    num_nodes = len(nodes)\n\n    # Generate elements (triangles)\n    elements = []\n    # \"Up\" pointing triangles\n    for k in range(N):\n        for j in range(N - k):\n            v_idx1 = node_map[(j, k)]\n            v_idx2 = node_map[(j + 1, k)]\n            v_idx3 = node_map[(j, k + 1)]\n            elements.append([v_idx1, v_idx2, v_idx3])\n    # \"Down\" pointing triangles\n    for k in range(N - 1):\n        for j in range(N - k - 1):\n            v_idx1 = node_map[(j + 1, k)]\n            v_idx2 = node_map[(j + 1, k + 1)]\n            v_idx3 = node_map[(j, k + 1)]\n            elements.append([v_idx1, v_idx2, v_idx3])\n    \n    # Identify interior and boundary nodes\n    interior_nodes_indices = []\n    boundary_nodes_indices = []\n    for k in range(N + 1):\n        for j in range(N - k + 1):\n            i = N - j - k\n            idx = node_map[(j, k)]\n            if i > 0 and j > 0 and k > 0:\n                interior_nodes_indices.append(idx)\n            else:\n                boundary_nodes_indices.append(idx)\n\n    # 2. Assemble Matrices\n    h = 1.0 / N\n    area = np.sqrt(3.0) / 4.0 * h**2\n    \n    # Element stiffness matrix for equilateral triangle\n    K_e = (1.0 / (2.0 * np.sqrt(3.0))) * np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]])\n    # Element mass matrix\n    M_e = (area / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    M = np.zeros((num_nodes, num_nodes))\n    K = np.zeros((num_nodes, num_nodes))\n\n    for el in elements:\n        for i in range(3):\n            for j in range(3):\n                gi, gj = el[i], el[j]\n                M[gi, gj] += M_e[i, j]\n                K[gi, gj] += K_e[i, j]\n    \n    # Extract submatrices for interior nodes\n    ix = np.ix_(interior_nodes_indices, interior_nodes_indices)\n    M_int = M[ix]\n    K_int = K[ix]\n    \n    # 3. Initial Condition\n    u0 = np.zeros(num_nodes)\n    xc = v3\n    for i in range(num_nodes):\n        if i in interior_nodes_indices:\n            dist_sq = np.sum((nodes[i] - xc)**2)\n            u0[i] = np.exp(-dist_sq / (2.0 * sigma**2))\n    \n    global_min = np.min(u0)\n    global_max = np.max(u0)\n\n    u_int = u0[interior_nodes_indices]\n\n    # 4. Time Stepping\n    A = M_int + (dt / 2.0) * K_int\n    B = M_int - (dt / 2.0) * K_int\n    \n    # Pre-factorize A\n    lu, piv = lu_factor(A)\n    \n    u_current_full = np.copy(u0)\n\n    for step in range(n_steps):\n        rhs = B @ u_int\n        u_int = lu_solve((lu, piv), rhs)\n        \n        # Update full solution vector and track min/max\n        u_current_full[interior_nodes_indices] = u_int\n        step_min = np.min(u_current_full)\n        step_max = np.max(u_current_full)\n        \n        if step_min  global_min:\n            global_min = step_min\n        if step_max > global_max:\n            global_max = step_max\n\n    # 5. Compute final metrics\n    m = global_min\n    M = global_max\n    \n    nonneg = m >= -TOL\n    \n    if M  TOL:\n        r = 0.0\n    else:\n        r = max(0.0, -m) / M\n        \n    return m, M, nonneg, r\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2607746"}, {"introduction": "在真实的科学与工程计算中，效率与精度同样重要。对于动态演化的物理问题，如移动的热锋面，使用固定的时间步长往往是低效的。本练习将带您进入自适应时间步长控制这一高级领域，这是一种根据解的局部行为动态调整计算量的强大技术。通过实现一个基于步长加倍法的误差估计器来控制 Crank-Nicolson 方法的时间步，您将学习如何让求解器“智能化”，使其在解变化剧烈时自动采用小步长以保证精度，在解平滑时采用大步长以提高效率。分析时间步长与物理锋面速度之间的相关性，将为您揭示自适应方法在捕捉复杂物理现象时的强大能力。[@problem_id:2607783]", "problem": "考虑一个具有局部移动热源的、在一维固定空间域上的瞬态热扩散问题。其控制偏微分方程为热传导方程\n$$\n\\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + s(x,t), \\quad x \\in (0,L), \\; t \\in (0,T],\n$$\n边界条件为齐次 Dirichlet 边界条件\n$$\nu(0,t) = 0, \\quad u(L,t) = 0, \\quad t \\in (0,T],\n$$\n初始条件为\n$$\nu(x,0) = 0, \\quad x \\in [0,L].\n$$\n源项是一个移动的高斯函数，其形式为\n$$\ns(x,t) = A \\exp\\!\\left(-\\frac{\\left(x - x_c(t)\\right)^2}{2\\sigma^2}\\right),\n$$\n其中高斯函数的中心按如下方式移动\n$$\nx_c(t) = x_0 + v t,\n$$\n其中 $v$ 是恒定速度参数。假设 $k = 1$，$L = 1$，$T = 0.5$，$A = 10$，$\\sigma = 0.05$ 以及 $x_0 = 0.2$。在整个问题中，空间网格取为 $[0,L]$ 的一个均匀划分，包含 $N_e = 100$ 个线性有限元（即 $N_n = 101$ 个节点），并使用带有连续分段线性基函数的标准 Galerkin 方法；使用一致质量矩阵。\n\n任务：\n1. 从上述偏微分方程的强形式和边界/初始条件出发，推导其弱形式以及关于有限元系数的时间半离散常微分方程组。不要使用任何简便公式；从加权余量的定义开始，进行分部积分，并仔细论证在给定边界条件下对边界项的处理。\n2. 从半离散系统出发，推导一种基于步长加倍法的、带局部误差控制的可变步长 Crank–Nicolson 时间离散格式。其接受准则必须由以下误差估计定义：给定一个尺寸为 $\\Delta t$ 的完整步和两个尺寸为 $\\Delta t/2$ 的半步，计算这两个步末解的差值，并将该差值的质量矩阵加权欧几里得范数除以未知量个数的平方根，定义为标量误差。使用此误差作为局部截断误差的代理。设计一个时间步长控制器，当误差最多为给定容差时接受该步，并使用适用于局部误差为 $\\mathcal{O}(\\Delta t^3)$ 阶方法的幂次法则更新下一步长 $\\Delta t_{\\text{new}}$。您的控制器还必须强制执行最小和最大时间步长以及有界的增长/收缩因子，以避免极端变化。\n3. 在一个已接受的时间层级，将“前沿位置”定义为分段常数有限元梯度（由相邻节点值计算）的绝对值最大的网格单元的中点。对于一系列已接受的步，索引为 $i = 1, 2, \\dots, M$，其对应的步长为 $\\Delta t_i$，相应的前沿位置为 $x^{\\text{front}}_{i-1}$ 和 $x^{\\text{front}}_{i}$，定义瞬时前沿速度大小为\n$$\n\\lvert v^{\\text{front}}_i \\rvert = \\frac{\\left|x^{\\text{front}}_{i} - x^{\\text{front}}_{i-1}\\right|}{\\Delta t_i}.\n$$\n为了量化步长控制如何跟随前沿速度，定义追踪度量时间序列为\n$$\ny_i = \\frac{1}{\\varepsilon + \\lvert v^{\\text{front}}_i \\rvert},\n$$\n其中正则化参数 $\\varepsilon = 10^{-8}$ 用于避免除以零。计算在区间 $(0,T]$ 内所有已接受步的两个序列 $\\{\\Delta t_i\\}$ 和 $\\{y_i\\}$ 之间的皮尔逊相关系数。如果任一序列的方差为零，则定义相关系数为 $0$。\n4. 实现完整的有限元求解器，包括可变步长 Crank-Nicolson 格式和步长加倍控制器。使用以下控制器和数值参数：初始时间步 $\\Delta t_0 = 10^{-3}$，最小步长 $\\Delta t_{\\min} = 10^{-4}$，最大步长 $\\Delta t_{\\max} = 2\\times 10^{-2}$，容差 $\\text{tol} = 10^{-4}$，安全因子 $\\eta = 0.9$，最大增长因子 $g_{\\max} = 2.0$，以及最小收缩因子 $g_{\\min} = 0.5$。当一个步被接受时，使用来自两个半步的更精确的解进行推进。如有必要，通过缩短最后一步来确保精确达到最终时间 $T$。\n5. 测试套件。对以下三种速度运行求解器\n$$\nv \\in \\{0.0, \\; 0.4, \\; 0.8\\},\n$$\n所有其他参数均按前述固定。按所述计算每种情况下的相关系数。输出为无量纲实数。\n6. 要求的最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试套件中速度的顺序排列，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$\n不应打印任何额外文本。\n\n注：\n- 此问题中不涉及角度，因此不需要角度单位。\n- 输出为无物理单位的纯数。\n- 通过执行所述的接受/拒绝逻辑并限制时间步长来确保科学真实性；不要依赖任何未说明的公式。", "solution": "所提出的问题是偏微分方程数值解的一个标准练习，具体涉及瞬态热传导方程。它要求应用有限元法（FEM）进行空间离散，并采用自适应隐式时间步进格式进行时间演化。该问题定义明确，科学上合理，并包含了唯一数值解所需的所有参数。我们着手进行推导和实现。\n\n**1. 弱形式与空间离散**\n\n该问题由一维热传导方程的强形式控制：\n$$\n\\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + s(x,t), \\quad x \\in (0,L), \\; t \\in (0,T]\n$$\n边界条件为齐次 Dirichlet 条件 $u(0,t) = u(L,t) = 0$，初始条件为零 $u(x,0) = 0$。\n\n为了推导弱形式，我们将该偏微分方程乘以一个来自合适函数空间的任意检验函数 $w(x)$，并在空间域 $\\Omega = (0,L)$ 上积分。检验函数选自 Sobolev 空间 $H_0^1(0,L)$，该空间由平方可积、一阶导数平方可积且在边界 $x=0$ 和 $x=L$ 处为零的函数组成。这得到了加权余量陈述：\n$$\n\\int_0^L \\left( \\frac{\\partial u}{\\partial t} - k \\frac{\\partial^2 u}{\\partial x^2} - s(x,t) \\right) w(x) \\, dx = 0 \\quad \\forall w \\in H_0^1(0,L)\n$$\n我们对扩散项应用分部积分，以降低空间导数的阶数，并将一个导数从解 $u$ 转移到检验函数 $w$：\n$$\n- \\int_0^L \\frac{\\partial^2 u}{\\partial x^2} w(x) \\, dx = \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial w}{\\partial x} \\, dx - \\left[ \\frac{\\partial u}{\\partial x} w(x) \\right]_0^L\n$$\n边界项 $\\left[ \\frac{\\partial u}{\\partial x} w(x) \\right]_0^L = \\frac{\\partial u}{\\partial x}(L,t)w(L) - \\frac{\\partial u}{\\partial x}(0,t)w(0)$ 恒等于零，因为根据检验空间 $H_0^1(0,L)$ 的定义，$w(0)=0$ 且 $w(L)=0$。这导出了问题的弱形式：求 $u(t) \\in H^1(0,L)$，满足 $u(0,t)=u(L,t)=0$，使得对于所有 $w \\in H_0^1(0,L)$：\n$$\n\\int_0^L \\frac{\\partial u}{\\partial t} w \\, dx + k \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial w}{\\partial x} \\, dx = \\int_0^L s(x,t) w \\, dx\n$$\n对于有限元法，我们在由分段线性基函数 $N_j(x)$ 张成的有限维子空间 $V_h \\subset H^1(0,L)$ 中逼近解 $u(x,t)$：\n$$\nu_h(x,t) \\approx \\sum_{j=1}^{N_n} U_j(t) N_j(x)\n$$\n其中 $U_j(t)$ 是随时间变化的节点值。边界条件 $u(0,t)=0$ 和 $u(L,t)=0$ 强制 $U_1(t)=0$ 和 $U_{N_n}(t)=0$，剩下 $N_{dof} = N_n-2$ 个内部节点值作为未知量。伽辽金方法对检验空间使用相同的基函数，即对每个内部节点 $i \\in \\{2, \\ldots, N_n-1\\}$，有 $w(x) = N_i(x)$。将此近似代入弱形式，得到一个常微分方程组（ODEs）：\n$$\n\\sum_{j=2}^{N_n-1} \\left( \\int_0^L N_i N_j \\, dx \\right) \\frac{dU_j}{dt} + k \\sum_{j=2}^{N_n-1} \\left( \\int_0^L \\frac{dN_i}{dx} \\frac{dN_j}{dx} \\, dx \\right) U_j = \\int_0^L s(x,t) N_i \\, dx\n$$\n这就是半离散系统，可以表示为矩阵形式：\n$$\nM \\frac{d\\mathbf{U}}{dt} + k K \\mathbf{U} = \\mathbf{F}(t)\n$$\n其中 $\\mathbf{U}(t)$ 是包含 $N_{dof}$ 个未知内部节点值的向量。系统矩阵为：\n-   **一致质量矩阵**: $M_{ij} = \\int_0^L N_i(x) N_j(x) \\, dx$\n-   **刚度矩阵**: $K_{ij} = \\int_0^L \\frac{dN_i}{dx}\\frac{dN_j}{dx} \\, dx$\n-   **载荷向量**: $F_i(t) = \\int_0^L s(x,t) N_i(x) \\, dx$\n\n**2. 时间离散与自适应步长控制**\n\n该半离散常微分方程组使用 Crank–Nicolson 方法求解，这是一种二阶精确的隐式格式。在时间上从 $t_n$ 离散到 $t_{n+1} = t_n + \\Delta t$，该格式为：\n$$\nM \\frac{\\mathbf{U}_{n+1} - \\mathbf{U}_n}{\\Delta t} = \\frac{1}{2}\\left[ (\\mathbf{F}_n - kK\\mathbf{U}_n) + (\\mathbf{F}_{n+1} - kK\\mathbf{U}_{n+1}) \\right]\n$$\n重新整理以分离出未知向量 $\\mathbf{U}_{n+1}$，得到在每个时间步需要求解的线性系统：\n$$\n\\left( M + \\frac{k\\Delta t}{2}K \\right) \\mathbf{U}_{n+1} = \\left( M - \\frac{k\\Delta t}{2}K \\right) \\mathbf{U}_n + \\frac{\\Delta t}{2}(\\mathbf{F}_n + \\mathbf{F}_{n+1})\n$$\n通过步长加倍法实现自适应时间步进。Crank-Nicolson 方法的局部截断误差（LTE）为 $\\mathcal{O}(\\Delta t^3)$。我们在 $t_{n+1}$ 计算两个解：$\\mathbf{U}_{n+1}^{(1)}$ 使用一个尺寸为 $\\Delta t$ 的步长，而 $\\mathbf{U}_{n+1}^{(2)}$ 使用两个尺寸为 $\\Delta t/2$ 的步长。差分向量 $\\mathbf{d} = \\mathbf{U}_{n+1}^{(2)} - \\mathbf{U}_{n+1}^{(1)}$ 可作为 LTE 的估计。标量误差度量定义为该差值的质量矩阵加权范数：\n$$\n\\text{err} = \\frac{\\sqrt{\\mathbf{d}^T M \\mathbf{d}}}{\\sqrt{N_{dof}}}\n$$\n如果 $\\text{err} \\le \\text{tol}$，则该步被接受，并使用更精确的结果推进解：$\\mathbf{U}_{n+1} = \\mathbf{U}_{n+1}^{(2)}$。否则，该步被拒绝，并使用一个更小的 $\\Delta t$ 重复计算。新的步长根据误差缩放特性计算：\n$$\n\\Delta t_{\\text{new}} = \\eta \\, \\Delta t \\left( \\frac{\\text{tol}}{\\text{err}} \\right)^{1/3}\n$$\n其中 $\\eta$ 是一个安全因子。为确保控制器的稳定性，步长进一步受到指定的最小值/最大值以及增长/收缩因子的限制。\n\n**3. 实现与最终分析**\n\n该算法在 Python 中实现。矩阵 $M$ 和 $K$ 是为内部自由度组装的。载荷向量 $\\mathbf{F}(t)$ 需要对源项与每个基函数的乘积进行数值积分，`scipy.integrate.quad` 适合此任务。时间步进循环执行自适应 Crank–Nicolson 格式，直到达到最终时间 $T$。在每个接受的步中，前沿位置被识别为梯度大小最大的单元的中点。最后，计算已接受时间步序列 $\\{\\Delta t_i\\}$ 与追踪度量 $\\{y_i\\}$（定义为前沿速度的倒数）之间的皮尔逊相关系数。对每个指定的源速度 $v$ 执行此分析。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve_for_v(v_val, params):\n    \"\"\"\n    Solves the 1D transient heat equation for a given source speed v.\n    \"\"\"\n    # --- Problem Parameters ---\n    k, L, T_final, A, sigma, x0 = params['phys']\n    v = v_val\n\n    # --- Numerical Parameters ---\n    Ne, TOL, DT_INIT, DT_MIN, DT_MAX, ETA, G_MAX, G_MIN, EPS_REG = params['num']\n    Nn = Ne + 1\n    Ndof = Nn - 2\n    h = L / Ne\n\n    # --- Spatial Grid ---\n    nodes = np.linspace(0, L, Nn)\n\n    # --- Assemble Mass and Stiffness Matrices (for interior nodes) ---\n    M = np.zeros((Ndof, Ndof))\n    K = np.zeros((Ndof, Ndof))\n\n    diag_M = 2 * h / 3\n    offdiag_M = h / 6\n    diag_K = 2 / h\n    offdiag_K = -1 / h\n\n    for i in range(Ndof):\n        M[i, i] = diag_M\n        K[i, i] = diag_K\n        if i > 0:\n            M[i, i-1] = offdiag_M\n            K[i, i-1] = offdiag_K\n        if i  Ndof - 1:\n            M[i, i+1] = offdiag_M\n            K[i, i+1] = offdiag_K\n\n    # --- Source Term Functions ---\n    def source_center(t):\n        return x0 + v * t\n\n    def source_func(x, t):\n        xc = source_center(t)\n        return A * np.exp(-(x - xc)**2 / (2 * sigma**2))\n\n    # --- Force Vector Calculation ---\n    memo_F = {}\n    def get_force_vector(t):\n        if t in memo_F:\n            return memo_F[t]\n\n        F = np.zeros(Ndof)\n        for i_dof in range(Ndof):\n            i_glob = i_dof + 1\n            x_prev, x_curr, x_next = nodes[i_glob-1], nodes[i_glob], nodes[i_glob+1]\n            \n            def N_left(x): return (x - x_prev) / h\n            def N_right(x): return (x_next - x) / h\n            \n            integral_left, _ = quad(lambda x: source_func(x, t) * N_left(x), x_prev, x_curr, epsabs=1e-9)\n            integral_right, _ = quad(lambda x: source_func(x, t) * N_right(x), x_curr, x_next, epsabs=1e-9)\n            \n            F[i_dof] = integral_left + integral_right\n        \n        memo_F[t] = F\n        return F\n\n    # --- Front Location Calculation ---\n    def get_front_location(U_full):\n        grads = np.abs(np.diff(U_full)) / h\n        max_grad_elem_idx = np.argmax(grads)\n        return (nodes[max_grad_elem_idx] + nodes[max_grad_elem_idx + 1]) / 2\n\n    # --- Time Marching Loop ---\n    t = 0.0\n    dt = DT_INIT\n    U = np.zeros(Ndof)\n\n    initial_elem_idx = int(np.floor(x0 / h))\n    x_front_0 = (nodes[initial_elem_idx] + nodes[initial_elem_idx+1]) / 2.0\n    \n    accepted_steps = []\n    front_locations = [x_front_0]\n\n    while t  T_final:\n        final_step = False\n        if t + dt >= T_final:\n            dt = T_final - t\n            final_step = True\n        \n        if dt  1e-12: break\n\n        # --- Step Doubling ---\n        dt_full = dt\n        A1 = M + (k * dt_full / 2) * K\n        F_n = get_force_vector(t)\n        F_n1 = get_force_vector(t + dt_full)\n        b1 = (M - (k * dt_full / 2) * K) @ U + (dt_full / 2) * (F_n + F_n1)\n        U_n1_1 = np.linalg.solve(A1, b1)\n\n        dt_half = dt / 2\n        A2 = M + (k * dt_half / 2) * K\n        F_n_half = get_force_vector(t + dt_half)\n        \n        b2_1 = (M - (k * dt_half / 2) * K) @ U + (dt_half / 2) * (F_n + F_n_half)\n        U_n_half = np.linalg.solve(A2, b2_1)\n        \n        b2_2 = (M - (k * dt_half / 2) * K) @ U_n_half + (dt_half / 2) * (F_n_half + F_n1)\n        U_n1_2 = np.linalg.solve(A2, b2_2)\n\n        # --- Error Estimation ---\n        d = U_n1_2 - U_n1_1\n        err = np.sqrt(np.dot(d, M @ d) / Ndof)\n        \n        # --- Step Control ---\n        if err = TOL or final_step:\n            t += dt\n            U = U_n1_2\n            \n            accepted_steps.append(dt)\n            U_full = np.concatenate(([0], U, [0]))\n            front_loc = get_front_location(U_full)\n            front_locations.append(front_loc)\n\n            if final_step: break\n                \n            if err  1e-12:\n                dt_new = G_MAX * dt\n            else:\n                dt_new = ETA * dt * (TOL / err)**(1/3.0)\n            \n            dt = np.clip(dt_new, G_MIN * dt, G_MAX * dt)\n            dt = np.clip(dt, DT_MIN, DT_MAX)\n\n        else:\n            if err  1e-12:\n                dt_new = G_MIN * dt\n            else:\n                dt_new = ETA * dt * (TOL / err)**(1/3.0)\n            dt = np.clip(dt_new, G_MIN * dt, G_MAX * dt)\n            dt = np.clip(dt, DT_MIN, DT_MAX)\n\n    # --- Post-processing: Correlation Calculation ---\n    delta_t_seq = np.array(accepted_steps)\n    front_loc_seq = np.array(front_locations)\n    \n    if len(delta_t_seq)  2: return 0.0\n\n    front_speeds = np.abs(np.diff(front_loc_seq)) / delta_t_seq\n    y_seq = 1.0 / (EPS_REG + front_speeds)\n\n    if np.var(delta_t_seq) == 0 or np.var(y_seq) == 0:\n        return 0.0\n    else:\n        return np.corrcoef(delta_t_seq, y_seq)[0, 1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    params = {\n        'phys': (1.0, 1.0, 0.5, 10.0, 0.05, 0.2), # k, L, T, A, sigma, x0\n        'num': (100, 1.0e-4, 1.0e-3, 1.0e-4, 2.0e-2, 0.9, 2.0, 0.5, 1.0e-8) # Ne, TOL, ...\n    }\n    \n    test_cases_v = [0.0, 0.4, 0.8]\n    results = [solve_for_v(v, params) for v in test_cases_v]\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2607783"}]}