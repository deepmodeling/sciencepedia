{"hands_on_practices": [{"introduction": "在深入研究复杂的数值模拟之前，理解水平集方法的基本运动学方程与物理定律之间的联系至关重要。这个练习将引导你通过一个经典的理想化场景——二维圆形晶粒在曲率驱动下的收缩——来完成一次纯粹的解析推导。通过这个实践，你将手动计算法向速度 $V_n$ 和曲率 $\\kappa$ 等关键量，并将它们与水平集演化方程 $\\phi_t + V_n |\\nabla \\phi| = 0$ 联系起来，从而深化对界面动力学核心原理的理解 [@problem_id:2654310]。", "problem": "考虑一个多晶薄膜中的环形晶粒，其边界被建模为平面上的一个光滑闭合曲线 $\\Gamma(t)$。设界面由一个有符号距离函数 $\\phi(x,y,t)$ 的零水平集表示，选择 $\\phi(x,y,t) = \\sqrt{x^{2}+y^{2}} - R(t)$，使得在晶粒外部 $\\phi > 0$，内部 $\\phi < 0$，且 $\\Gamma(t) = \\{(x,y): \\phi(x,y,t) = 0\\}$。在固体力学中，界面因毛细作用而通过曲率驱动的运动进行演化，其法向速度为\n$$\nV_{n} = - M \\, \\gamma \\, \\kappa,\n$$\n其中 $M$ 是迁移率（单位为 $\\mathrm{m^{2}/(N \\cdot s)}$），$\\gamma$ 是单位长度的边界能（线张力，单位为 $\\mathrm{N}$），$\\kappa$ 是在 $\\Gamma(t)$ 上计算的标量曲率，$\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$。水平集方法通过偏微分方程（PDE）将法向速度与水平集函数联系起来\n$$\n\\phi_{t} + V_{n} \\, |\\nabla \\phi| = 0.\n$$\n仅从这些定义和基本关系出发，推导半径 $R(t)$ 的演化定律，并在初始半径为 $R(0) = R_{0}$ 的条件下求解。使用您推导的解，计算晶粒坍缩成一个点时的消失时间 $t^{\\ast}$，即 $R(t^{\\ast}) = 0$，参数如下：\n- $R_{0} = 50 \\,\\mu\\mathrm{m}$，\n- $M = 1.0 \\times 10^{-9}\\,\\mathrm{m^{2}/(N \\cdot s)}$，\n- $\\gamma = 1.0\\,\\mathrm{N}$。\n以 $\\mathrm{s}$ 为单位表示最终时间，并将答案四舍五入到三位有效数字。", "solution": "该问题陈述已经过验证，是有效的。它在科学上基于连续介质力学和水平集方法的原理，是数学上适定的，并且所有提供的数据都是自洽的，足以得到唯一解。因此，我们可以进行推导。\n\n该问题要求推导一个环形晶粒半径 $R(t)$ 的演化定律，其边界由函数 $\\phi(x,y,t) = \\sqrt{x^{2}+y^{2}} - R(t)$ 的零水平集描述。该演化由水平集方程和法向速度的物理定律控制。\n\n首先，我们从水平集函数 $\\phi$ 计算必要的几何量。为方便起见，可使用径向坐标 $r = \\sqrt{x^{2}+y^{2}}$ 来表示 $\\phi$，即 $\\phi(r,t) = r - R(t)$。\n\n$\\phi$ 的梯度计算如下：\n$$\n\\nabla \\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{x}{\\sqrt{x^{2}+y^{2}}}, \\frac{y}{\\sqrt{x^{2}+y^{2}}} \\right) = \\left( \\frac{x}{r}, \\frac{y}{r} \\right)\n$$\n该矢量是向外的单位径向矢量，$\\hat{\\mathbf{r}}$。\n\n梯度的模长为：\n$$\n|\\nabla \\phi| = \\sqrt{\\left(\\frac{x}{r}\\right)^{2} + \\left(\\frac{y}{r}\\right)^{2}} = \\sqrt{\\frac{x^{2}+y^{2}}{r^{2}}} = 1\n$$\n正如对于有符号距离函数所预期的那样，除了原点外，这对所有点都成立。\n\n水平集的单位法向量 $\\mathbf{n}$ 由下式给出：\n$$\n\\mathbf{n} = \\frac{\\nabla \\phi}{|\\nabla \\phi|} = \\nabla \\phi = \\hat{\\mathbf{r}}\n$$\n\n曲率 $\\kappa$ 定义为单位法向量的散度：\n$$\n\\kappa = \\nabla \\cdot \\mathbf{n} = \\frac{\\partial}{\\partial x}\\left(\\frac{x}{r}\\right) + \\frac{\\partial}{\\partial y}\\left(\\frac{y}{r}\\right)\n$$\n$$\n\\kappa = \\left( \\frac{1}{r} - \\frac{x^{2}}{r^{3}} \\right) + \\left( \\frac{1}{r} - \\frac{y^{2}}{r^{3}} \\right) = \\frac{2}{r} - \\frac{x^{2}+y^{2}}{r^{3}} = \\frac{2}{r} - \\frac{r^{2}}{r^{3}} = \\frac{1}{r}\n$$\n该问题要求在界面 $\\Gamma(t)$ 上计算 $\\kappa$，其中 $r = R(t)$。因此，在晶粒边界上：\n$$\n\\kappa = \\frac{1}{R(t)}\n$$\n\n接下来，我们计算水平集演化方程 $\\phi_{t} + V_{n} \\, |\\nabla \\phi| = 0$ 中的各项。$\\phi$ 对时间 $t$ 的偏导数为：\n$$\n\\phi_{t} = \\frac{\\partial}{\\partial t} \\left( \\sqrt{x^{2}+y^{2}} - R(t) \\right) = -\\frac{dR}{dt}\n$$\n\n将 $\\phi_{t}$ 和 $|\\nabla \\phi|$ 代入水平集方程可得：\n$$\n-\\frac{dR}{dt} + V_{n} (1) = 0 \\implies V_{n} = \\frac{dR}{dt}\n$$\n此结果证实了界面沿向外法线 $\\mathbf{n}$ 方向的法向速度 $V_{n}$ 正是半径 $R(t)$ 的变化率。\n\n该问题提供了由毛细作用引起的法向速度的物理定律：\n$$\nV_{n} = - M \\, \\gamma \\, \\kappa\n$$\n代入界面上的曲率表达式 $\\kappa = 1/R(t)$：\n$$\nV_{n} = - \\frac{M\\gamma}{R(t)}\n$$\n\n通过令 $V_{n}$ 的两个表达式相等，我们得到控制半径 $R(t)$ 演化的常微分方程（ODE）：\n$$\n\\frac{dR}{dt} = - \\frac{M\\gamma}{R(t)}\n$$\n\n这是一个可分离的常微分方程。我们在初始条件 $R(0) = R_{0}$ 下求解它。\n$$\nR \\, dR = -M\\gamma \\, dt\n$$\n将两边从初始状态 $(t=0, R=R_{0})$ 积分到一般状态 $(t, R(t))$：\n$$\n\\int_{R_{0}}^{R(t)} R' \\, dR' = \\int_{0}^{t} -M\\gamma \\, dt'\n$$\n$$\n\\left[ \\frac{1}{2}(R')^{2} \\right]_{R_{0}}^{R(t)} = -M\\gamma [t']_{0}^{t}\n$$\n$$\n\\frac{1}{2}R(t)^{2} - \\frac{1}{2}R_{0}^{2} = -M\\gamma t\n$$\n求解 $R(t)$，我们得到半径的演化定律：\n$$\nR(t)^{2} = R_{0}^{2} - 2M\\gamma t\n$$\n$$\nR(t) = \\sqrt{R_{0}^{2} - 2M\\gamma t}\n$$\n\n消失时间 $t^{\\ast}$ 是晶粒消失的时间，即 $R(t^{\\ast})=0$。在我们的解中令 $R(t^{\\ast})=0$：\n$$\n0 = R_{0}^{2} - 2M\\gamma t^{\\ast}\n$$\n$$\nt^{\\ast} = \\frac{R_{0}^{2}}{2M\\gamma}\n$$\n\n最后，我们代入给定的数值参数来计算 $t^{\\ast}$。参数必须使用统一的国际单位制（SI）单位。\n$R_{0} = 50 \\,\\mu\\mathrm{m} = 5.0 \\times 10^{-5}\\,\\mathrm{m}$\n$M = 1.0 \\times 10^{-9}\\,\\mathrm{m^{2}/(N \\cdot s)}$\n$\\gamma = 1.0\\,\\mathrm{N}$\n\n$$\nt^{\\ast} = \\frac{(5.0 \\times 10^{-5})^{2}}{2 \\cdot (1.0 \\times 10^{-9}) \\cdot (1.0)} = \\frac{25 \\times 10^{-10}}{2.0 \\times 10^{-9}} = \\frac{2.5 \\times 10^{-9}}{2.0 \\times 10^{-9}}\\,\\mathrm{s}\n$$\n$$\nt^{\\ast} = 1.25\\,\\mathrm{s}\n$$\n该值已按要求表示为三位有效数字。", "answer": "$$\\boxed{1.25}$$", "id": "2654310"}, {"introduction": "从解析的理想世界过渡到数值计算的现实，我们会发现离散化不可避免地会引入误差，尤其是在计算曲率这类几何量时。本练习旨在解决水平集方法在实践中的一个核心挑战：如何在笛卡尔网格上精确地计算几何信息。你将通过编码实现一个关键的修正技术——符号距离函数重置（re-initialization），它通过求解一个 Hamilton-Jacobi 方程来强制执行 Eikonal 方程 $|\\nabla \\phi| = 1$，从而显著提高曲率计算的精度 [@problem_id:2654323]。", "problem": "考虑一个二维无量纲方形域 $\\Omega=[0,1]\\times[0,1]$，该区域由一个包含 $N\\times N$ 个节点的均匀笛卡尔网格进行离散，网格间距为 $h=\\frac{1}{N-1}$。一个界面 $\\Gamma$ 由一个标量场 $\\phi(x,y)$ 的零水平集隐式表示，其中 $\\phi$ 是一个符号距离函数，在界面内部为负，外部为正。在用于优化和固体力学中界面的水平集方法中，像曲率这样的几何量会出现在敏感性分析和界面正则化中，而这些量的离散近似会引入依赖于 $h$ 和离散格式的几何诱导误差。本练习旨在研究基准离散曲率误差以及一种基于符号距离重初始化的修正方法，并要求您计算该修正方法带来的误差减少量。\n\n您必须实现一个完整的程序，该程序针对一系列圆形界面，计算基准离散平均曲率及其误差，应用一个重初始化偏微分方程 (PDE) 来修正离散几何误差，重新计算曲率，并报告每个测试案例中修正后误差与基准误差的比率。\n\n物理和数值设置如下。\n\n- 界面 $\\Gamma$ 是一个半径为 $R$、中心在 $(x_c,y_c)$ 的圆，其符号距离场为\n$$\n\\phi_0(x,y)=\\sqrt{(x-x_c)^2+(y-y_c)^2}-R.\n$$\n- 对于一个圆，其精确的平均曲率（符号法向朝外的平面曲线的曲率）是一个常数，等于\n$$\n\\kappa_{\\text{exact}}=\\frac{1}{R}.\n$$\n- 网格节点上的离散曲率从第一性原理出发，通过单位法向量的散度这一定义来计算。令 $\\nabla \\phi=(\\phi_x,\\phi_y)$ 表示梯度，单位法向量为 $n=\\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|}$，其中 $\\|\\nabla \\phi\\|=\\sqrt{\\phi_x^2+\\phi_y^2}$。那么\n$$\n\\kappa=\\nabla\\cdot n=\\frac{\\partial n_x}{\\partial x}+\\frac{\\partial n_y}{\\partial y}.\n$$\n在网格上，内部使用二阶中心差分，边界使用一阶单边差分。为避免除以零，将范数正则化为 $\\|\\nabla \\phi\\|_\\varepsilon=\\sqrt{\\phi_x^2+\\phi_y^2+\\varepsilon^2}$，其中 $\\varepsilon=\\alpha h$，$\\alpha$ 是一个无量纲常数，并设 $n=\\nabla \\phi/\\|\\nabla \\phi\\|_\\varepsilon$。\n\n- 基准离散曲率误差通过界面周围一个窄带内的均方根 (RMS) 误差来量化。该窄带定义为\n$$\n\\mathcal{B}=\\{(i,j)\\ \\text{grid nodes}\\ :\\ |\\phi_0(x_i,y_j)|\\le 2h\\}.\n$$\n如果 $M$ 是 $\\mathcal{B}$ 中的节点数，定义\n$$\nE_{\\text{base}}=\\left(\\frac{1}{M}\\sum_{(i,j)\\in\\mathcal{B}}\\left(\\kappa_{ij}-\\kappa_{\\text{exact}}\\right)^2\\right)^{1/2}.\n$$\n\n- 修正方法是一种符号距离重初始化，它在伪时间 $\\tau$ 中强制满足程函方程 $\\|\\nabla \\phi\\|=1$，同时保持 $\\phi=0$ 等值线不变。从 $\\phi(x,y,0)=\\phi_0(x,y)$ 开始，演化以下方程\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} = s(\\phi_0)\\left(1-\\|\\nabla \\phi\\|\\right),\n$$\n其中 $s(\\phi_0)$ 是一个平滑符号函数。使用关于 $\\|\\nabla \\phi\\|$ 的一阶迎风 Godunov 通量和在 $\\tau$ 方向上的显式欧拉步来离散这个 Hamilton-Jacobi (HJ) 方程。令 $D^+_x\\phi$ 和 $D^-_x\\phi$ 分别表示 $x$ 方向的前向和后向单边有限差分，$y$ 方向同理，并在边界处采用齐次诺伊曼 (Neumann) 处理。对每个节点，定义\n$$\ns(\\phi_0)=\\frac{\\phi_0}{\\sqrt{\\phi_0^2+h^2}}.\n$$\n对于 Godunov 通量，对每个节点定义：\n- 如果 $s(\\phi_0)\\ge 0$,\n$$\nG=\\sqrt{\\max\\left(\\left(\\max(D^-_x\\phi,0)\\right)^2,\\left(\\min(D^+_x\\phi,0)\\right)^2\\right)+\\max\\left(\\left(\\max(D^-_y\\phi,0)\\right)^2,\\left(\\min(D^+_y\\phi,0)\\right)^2\\right)}.\n$$\n- 如果 $s(\\phi_0)< 0$,\n$$\nG=\\sqrt{\\max\\left(\\left(\\min(D^-_x\\phi,0)\\right)^2,\\left(\\max(D^+_x\\phi,0)\\right)^2\\right)+\\max\\left(\\left(\\min(D^-_y\\phi,0)\\right)^2,\\left(\\max(D^+_y\\phi,0)\\right)^2\\right)}.\n$$\n那么一个显式步为\n$$\n\\phi^{n+1}=\\phi^n-\\Delta \\tau\\, s(\\phi_0)\\,(G-1).\n$$\n使用伪时间步长 $\\Delta \\tau=\\beta h$，其中 $\\beta=\\beta_0\\in(0,1)$，并推进一个固定的步数 $N_\\tau$。\n\n- 重初始化后，在同一个窄带 $\\mathcal{B}$ 中计算修正后的曲率和相关的 RMS 误差：\n$$\nE_{\\text{corr}}=\\left(\\frac{1}{M}\\sum_{(i,j)\\in\\mathcal{B}}\\left(\\kappa^{\\text{corr}}_{ij}-\\kappa_{\\text{exact}}\\right)^2\\right)^{1/2}.\n$$\n\n- 每个测试案例所关注的量是以下比率\n$$\n\\rho=\\frac{E_{\\text{corr}}}{E_{\\text{base}}}.\n$$\n如果 $E_{\\text{base}}$ 在数值上与零无法区分，则按惯例定义 $\\rho=1$。\n\n需要实现的数值细节：\n- 使用 $\\varepsilon=\\alpha h$，其中 $\\alpha=0.5$。\n- 使用 $\\beta_0=0.3$ 和 $N_\\tau=120$。\n- 对 $\\partial\\Omega$ 处的所有有限差分使用齐次诺伊曼边界条件，通过一阶单边差分实现。\n\n测试套件：\n对于以下每个参数元组 $(N,R,x_c,y_c)$，按照上述方法计算 $\\rho$。所有量都是无量纲的。\n\n- 案例 1：$(N,R,x_c,y_c)=(129,0.3,0.37,0.41)$，一个中等分辨率、圆心未与网格对齐的圆。\n- 案例 2：$(N,R,x_c,y_c)=(33,0.3,0.37,0.41)$，一个粗网格。\n- 案例 3：$(N,R,x_c,y_c)=(129,0.08,0.5,0.5)$，一个半径接近网格尺度的小圆。\n- 案例 4：$(N,R,x_c,y_c)=(129,0.3,0.15,0.5)$，一个界面与边界相交的圆。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述案例的顺序排列，即\n$$\n[\\rho_1,\\rho_2,\\rho_3,\\rho_4].\n$$\n每个 $\\rho_k$ 必须作为浮点数输出。没有物理单位；所有值都是无量纲的。不出现角度。任何地方都不能出现百分比；每个比率 $\\rho_k$ 都是一个纯数。", "solution": "所述问题是水平集应用中数值方法的一个适定且科学上合理的练习。它内容完备，指定了所有必要的参数、方程和算法。任务是实现一个预定的数值方案，以量化经过符号距离重初始化过程后界面曲率近似的改进程度。该问题是有效的，将遵循指定的方法构建解决方案。\n\n问题的核心在于笛卡尔网格上几何量和微分算子的离散化。我们将从初始设置到最终误差分析，详细说明每个计算步骤。\n\n**1. 离散化和初始状态**\n\n域 $\\Omega = [0,1] \\times [0,1]$ 被离散化为一个包含 $N \\times N$ 个节点的网格。两个方向上的网格间距均一，由 $h = 1 / (N-1)$ 给出。网格节点 $(x_i, y_j)$ 的坐标由 $x_i = i h$ 和 $y_j = j h$ 给出，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。\n\n初始界面是一个半径为 $R$、中心在 $(x_c, y_c)$ 的圆。该界面被隐式地表示为初始符号距离函数 (SDF) $\\phi_0$ 的零等值线：\n$$\n\\phi_0(x,y) = \\sqrt{(x-x_c)^2 + (y-y_c)^2} - R\n$$\n在每个网格节点 $(x_i, y_j)$ 上计算这个解析函数，得到离散场 $\\phi_{0,ij}$。\n\n**2. 基准曲率和误差计算**\n\n平均曲率 $\\kappa$ 定义为单位法向量场的散度，即 $\\kappa = \\nabla \\cdot n$。单位法向量 $n$ 从水平集函数的梯度计算得出，即 $n = \\nabla\\phi / \\|\\nabla\\phi\\|$。当 $\\|\\nabla\\phi\\|$ 接近零时（这可能发生在远离界面处或由于数值伪影），必须避免除以零。因此，使用正则化的范数：\n$$\nn = \\frac{\\nabla\\phi}{\\|\\nabla\\phi\\|_\\varepsilon} \\quad \\text{其中} \\quad \\|\\nabla\\phi\\|_\\varepsilon = \\sqrt{(\\phi_x)^2 + (\\phi_y)^2 + \\varepsilon^2}\n$$\n正则化参数为 $\\varepsilon = \\alpha h$，其中指定的常数 $\\alpha=0.5$。\n\n计算 $\\nabla\\phi = (\\phi_x, \\phi_y)$ 和散度 $\\nabla \\cdot n$ 所需的导数使用有限差分进行近似。问题指定内部节点使用二阶中心差分，边界处使用一阶单边差分。对于网格上的一个通用场 $f(x,y)$，在节点 $(i,j)$ 处的偏导数 $\\partial f / \\partial x$ 计算如下：\n- $ \\frac{f_{i+1,j} - f_{i-1,j}}{2h} $ 对于 $i \\in \\{1, \\dots, N-2\\}$ (内部)。\n- $ \\frac{f_{1,j} - f_{0,j}}{h} $ 对于 $i=0$ (边界)。\n- $ \\frac{f_{N-1,j} - f_{N-2,j}}{h} $ 对于 $i=N-1$ (边界)。\n同样的差分格式也适用于沿 $j$ 索引的 $y$ 方向导数。此方案首先应用于从 $\\phi_0$ 计算 $\\nabla\\phi_0$，然后再次应用于从法向量场 $n$ 的分量计算 $\\nabla \\cdot n$。\n\n基准曲率场 $\\kappa_{ij}$ 是从初始符号距离函数 $\\phi_0$ 计算得出的。这个数值曲率的准确性通过与圆的精确解析曲率 $\\kappa_{\\text{exact}} = 1/R$ 进行比较来评估。误差通过界面附近一个窄带 $\\mathcal{B}$ 上的均方根 (RMS) 误差来量化：\n$$\n\\mathcal{B} = \\{ (i,j) \\text{ nodes} \\mid |\\phi_0(x_i, y_j)| \\le 2h \\}\n$$\n基准 RMS 误差 $E_{\\text{base}}$ 为：\n$$\nE_{\\text{base}} = \\sqrt{\\frac{1}{M} \\sum_{(i,j) \\in \\mathcal{B}} (\\kappa_{ij} - \\kappa_{\\text{exact}})^2}\n$$\n其中 $M$ 是窄带 $\\mathcal{B}$ 中节点的总数。\n\n**3. 符号距离重初始化**\n\n离散的符号距离函数 $\\phi_0$ 仅在连续意义上是真正的距离函数。在网格上，其离散梯度大小 $\\|\\nabla \\phi_0\\|$ 可能会偏离 $1$。这种偏差会在曲率计算中引入误差。重初始化过程通过演化场 $\\phi$ 以在网格上更好地满足程函方程 $\\|\\nabla\\phi\\| = 1$，同时保持零水平集静止。这是通过求解 Hamilton-Jacobi PDE 实现的：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + s(\\phi_0)( \\|\\nabla \\phi\\| - 1 ) = 0\n$$\n对于一个伪时间 $\\tau$。项 $s(\\phi_0)$ 是一个平滑符号函数，它决定了信息流动的方向（从界面向内或向外）：\n$$\ns(\\phi_0) = \\frac{\\phi_0}{\\sqrt{\\phi_0^2 + h^2}}\n$$\n这个 PDE 被数值求解。伪时间演化使用显式欧拉方法：\n$$\n\\phi^{k+1} = \\phi^k - \\Delta\\tau \\cdot s(\\phi_0) (G - 1)\n$$\n其中 $G$ 是 $\\|\\nabla\\phi\\|$ 的数值近似，时间步长为 $\\Delta\\tau = \\beta h$，且 $\\beta=0.3$。演化进行 $N_\\tau = 120$ 步。\n\n空间项 $\\|\\nabla\\phi\\|$ 使用一阶 Godunov 通量进行离散，这是一种适用于 Hamilton-Jacobi 方程的迎风格式。该格式根据 $s(\\phi_0)$ 的符号选择合适的单边差分，$s(\\phi_0)$ 的符号决定了特征线的方向。设 $D^\\pm_x \\phi$ 和 $D^\\pm_y \\phi$ 为前向/后向有限差分。Godunov 通量 $G$ 定义如下：\n- 对于 $s(\\phi_0) \\ge 0$ (向外传播):\n$$ G = \\sqrt{\\max\\left((\\max(D^-_x\\phi,0))^2,(\\min(D^+_x\\phi,0))^2\\right)+\\max\\left((\\max(D^-_y\\phi,0))^2,(\\min(D^+_y\\phi,0))^2\\right)} $$\n- 对于 $s(\\phi_0) < 0$ (向内传播):\n$$ G = \\sqrt{\\max\\left((\\min(D^-_x\\phi,0))^2,(\\max(D^+_x\\phi,0))^2\\right)+\\max\\left((\\min(D^-_y\\phi,0))^2,(\\max(D^+_y\\phi,0))^2\\right)} $$\n单边差分 $D^\\pm_x \\phi$、$D^\\pm_y \\phi$ 使用齐次诺伊曼边界条件。通过在差分格式需要域外点时将导数设置为零来实现。例如，在左边界 $i=0$ 处，$D^-_x\\phi$ 设置为 $0$。在右边界 $i=N-1$ 处，$D^+_x\\phi$ 设置为 $0$。\n\n**4. 修正误差和最终比率**\n\n经过 $N_\\tau$ 步后，重初始化产生一个修正后的场 $\\phi_{\\text{corr}}$。使用这个新场，采用与计算基准曲率完全相同的过程来计算修正后的曲率场 $\\kappa^{\\text{corr}}$。然后，在由初始场 $\\phi_0$ 定义的同一个窄带 $\\mathcal{B}$ 上计算修正后的RMS误差 $E_{\\text{corr}}$：\n$$\nE_{\\text{corr}} = \\sqrt{\\frac{1}{M} \\sum_{(i,j) \\in \\mathcal{B}} (\\kappa^{\\text{corr}}_{ij} - \\kappa_{\\text{exact}})^2}\n$$\n每个测试案例的最终结果是修正后误差与基准误差的比率：\n$$\n\\rho = \\frac{E_{\\text{corr}}}{E_{\\text{base}}}\n$$\n$\\rho < 1$ 的值表示重初始化过程成功减少了离散曲率计算中的几何诱导误差。如果 $E_{\\text{base}}$ 在数值上为零，我们取 $\\rho=1$。至此，算法完成。", "answer": "```python\nimport numpy as np\n\ndef compute_gradient(phi, h):\n    \"\"\"\n    Computes the gradient of a 2D scalar field phi using second-order\n    central differences in the interior and first-order at boundaries.\n    \"\"\"\n    N = phi.shape[0]\n    grad_x = np.zeros_like(phi)\n    grad_y = np.zeros_like(phi)\n\n    # Gradient in x-direction\n    grad_x[:, 1:-1] = (phi[:, 2:] - phi[:, :-2]) / (2.0 * h)\n    grad_x[:, 0] = (phi[:, 1] - phi[:, 0]) / h\n    grad_x[:, -1] = (phi[:, -1] - phi[:, -2]) / h\n\n    # Gradient in y-direction\n    grad_y[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2.0 * h)\n    grad_y[0, :] = (phi[1, :] - phi[0, :]) / h\n    grad_y[-1, :] = (phi[-1, :] - phi[-2, :]) / h\n\n    return grad_x, grad_y\n\ndef compute_divergence(vx, vy, h):\n    \"\"\"\n    Computes the divergence of a 2D vector field (vx, vy) using second-order\n    central differences in the interior and first-order at boundaries.\n    \"\"\"\n    dvx_dx = np.zeros_like(vx)\n    dvy_dy = np.zeros_like(vy)\n\n    # Partial derivative of vx w.r.t. x\n    dvx_dx[:, 1:-1] = (vx[:, 2:] - vx[:, :-2]) / (2.0 * h)\n    dvx_dx[:, 0] = (vx[:, 1] - vx[:, 0]) / h\n    dvx_dx[:, -1] = (vx[:, -1] - vx[:, -2]) / h\n\n    # Partial derivative of vy w.r.t. y\n    dvy_dy[1:-1, :] = (vy[2:, :] - vy[:-2, :]) / (2.0 * h)\n    dvy_dy[0, :] = (vy[1, :] - vy[0, :]) / h\n    dvy_dy[-1, :] = (vy[-1, :] - vy[-2, :]) / h\n\n    return dvx_dx + dvy_dy\n    \ndef get_one_sided_diffs(phi, h):\n    \"\"\"\n    Computes first-order one-sided differences with homogeneous Neumann BCs.\n    \"\"\"\n    # D_x^+ phi\n    dx_p = (np.roll(phi, -1, axis=1) - phi) / h\n    dx_p[:, -1] = 0.0\n\n    # D_x^- phi\n    dx_m = (phi - np.roll(phi, 1, axis=1)) / h\n    dx_m[:, 0] = 0.0\n\n    # D_y^+ phi\n    dy_p = (np.roll(phi, -1, axis=0) - phi) / h\n    dy_p[-1, :] = 0.0\n\n    # D_y^- phi\n    dy_m = (phi - np.roll(phi, 1, axis=0)) / h\n    dy_m[0, :] = 0.0\n    \n    return dx_p, dx_m, dy_p, dy_m\n\ndef compute_curvature(phi, h, alpha):\n    \"\"\"Computes the curvature from the level set field phi.\"\"\"\n    epsilon = alpha * h\n    grad_phi_x, grad_phi_y = compute_gradient(phi, h)\n    \n    norm_grad_phi_eps = np.sqrt(grad_phi_x**2 + grad_phi_y**2 + epsilon**2)\n    \n    # Avoid division by zero, although epsilon should prevent it.\n    # Set norm to 1.0 where it's zero to avoid NaN.\n    norm_grad_phi_eps[norm_grad_phi_eps < 1e-15] = 1.0\n\n    nx = grad_phi_x / norm_grad_phi_eps\n    ny = grad_phi_y / norm_grad_phi_eps\n    \n    kappa = compute_divergence(nx, ny, h)\n    return kappa\n\ndef solve_case(params):\n    \"\"\"\n    Runs the full simulation for a single test case.\n    \"\"\"\n    N, R, xc, yc = params\n    alpha = 0.5\n    beta0 = 0.3\n    N_tau = 120\n\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 1. Initial State and Baseline Error\n    phi0 = np.sqrt((X - xc)**2 + (Y - yc)**2) - R\n    kappa_exact = 1.0 / R\n\n    kappa_base = compute_curvature(phi0, h, alpha)\n    \n    narrow_band_mask = np.abs(phi0) <= 2.0 * h\n    M = np.sum(narrow_band_mask)\n\n    if M == 0:\n        # Handle cases where the band is empty, though unlikely.\n        return 1.0\n\n    error_sq_base = (kappa_base[narrow_band_mask] - kappa_exact)**2\n    E_base = np.sqrt(np.sum(error_sq_base) / M)\n    \n    if E_base < 1e-15:\n        return 1.0\n\n    # 2. Reinitialization\n    phi = phi0.copy()\n    s_phi0 = phi0 / np.sqrt(phi0**2 + h**2)\n    dt = beta0 * h\n\n    for _ in range(N_tau):\n        dx_p, dx_m, dy_p, dy_m = get_one_sided_diffs(phi, h)\n        \n        # Godunov flux for s >= 0\n        term_x_pos = np.maximum(np.maximum(dx_m, 0.0)**2, np.minimum(dx_p, 0.0)**2)\n        term_y_pos = np.maximum(np.maximum(dy_m, 0.0)**2, np.minimum(dy_p, 0.0)**2)\n        G_pos = np.sqrt(term_x_pos + term_y_pos)\n        \n        # Godunov flux for s < 0\n        term_x_neg = np.maximum(np.minimum(dx_m, 0.0)**2, np.maximum(dx_p, 0.0)**2)\n        term_y_neg = np.maximum(np.minimum(dy_m, 0.0)**2, np.maximum(dy_p, 0.0)**2)\n        G_neg = np.sqrt(term_x_neg + term_y_neg)\n        \n        G = np.where(s_phi0 >= 0, G_pos, G_neg)\n        \n        phi -= dt * s_phi0 * (G - 1.0)\n\n    # 3. Corrected Error\n    phi_corr = phi\n    kappa_corr = compute_curvature(phi_corr, h, alpha)\n    \n    error_sq_corr = (kappa_corr[narrow_band_mask] - kappa_exact)**2\n    E_corr = np.sqrt(np.sum(error_sq_corr) / M)\n    \n    rho = E_corr / E_base\n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test cases: (N, R, x_c, y_c)\n    test_cases = [\n        (129, 0.3, 0.37, 0.41),  # Case 1\n        (33, 0.3, 0.37, 0.41),   # Case 2\n        (129, 0.08, 0.5, 0.5),   # Case 3\n        (129, 0.3, 0.15, 0.5),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        rho = solve_case(case)\n        results.append(rho)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2654323"}, {"introduction": "水平集方法在拓扑优化领域的强大能力，来源于其处理复杂几何演化的灵活性，而这通常依赖于高效的、基于梯度的优化算法。本练习将引导你进入这一前沿应用，学习如何使用强大的伴随方法（adjoint method）来推导和计算目标函数（如结构柔度）相对于设计变量的梯度。此外，你还将实践梯度校验（gradient check）这一开发和调试优化代码时必不可少的验证步骤，确保你计算出的伴随梯度与数值差分结果一致 [@problem_id:2654352]。", "problem": "您将使用一个标量椭圆模型，在固体力学中为一个基于水平集方法的材料优化代理模型实现并评估其数值微分的精度。物理背景是一个二维域，其中材料分布由一个水平集函数隐式定义，结构响应则由一个替代线性弹性问题的标量椭圆偏微分方程（PDE）建模。您的任务是：使用伴随法推导类柔度目标函数关于水平集参数的梯度，对该PDE和梯度进行一致的离散化，并将伴随法梯度与不同步长下的有限差分近似结果进行比较。在本问题中，所有量均视为无量纲，因此无需进行物理单位转换。\n\n本问题的基础是标量椭圆PDE形式的平衡律、柔度的变分定义以及链式法则/伴随法。请仅从以下基本原理和定义出发：\n- 在单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 中，具有空间变化传导系数的标量椭圆PDE为 $-\\nabla \\cdot (k(\\mathbf{x}) \\nabla u(\\mathbf{x})) = s(\\mathbf{x})$，并在边界 $\\partial \\Omega$ 上满足Dirichlet边界条件 $u = 0$。\n- 类柔度泛函为 $J = \\int_{\\Omega} s(\\mathbf{x})\\, u(\\mathbf{x}) \\, d\\mathbf{x}$。\n- 设计由一个水平集函数 $\\phi(\\mathbf{x};\\boldsymbol{\\alpha})$ 编码，该函数由径向基函数构建，传导系数通过对 $\\phi$ 应用平滑的Heaviside函数来定义。\n- 链式法则和伴随法将 $J$ 关于 $\\boldsymbol{\\alpha}$ 的导数与状态解 $u$ 和伴随解 $p$ 联系起来。\n\n待实现的模型规格：\n- 传导系数为 $k(\\mathbf{x}) = k_{\\text{void}} + \\left(k_{\\text{solid}} - k_{\\text{void}}\\right) \\rho(\\mathbf{x})$，其中 $\\rho(\\mathbf{x}) = H_{\\varepsilon}(\\phi(\\mathbf{x};\\boldsymbol{\\alpha}))$ 是水平集的平滑Heaviside函数。\n- 水平集为 $\\phi(\\mathbf{x};\\boldsymbol{\\alpha}) = \\sum_{j=1}^{M} \\alpha_j R_j(\\mathbf{x})$，其中高斯径向基函数为 $R_j(\\mathbf{x}) = \\exp\\!\\left(-\\frac{\\|\\mathbf{x}-\\mathbf{c}_j\\|^2}{\\sigma^2}\\right)$，中心点为 $\\mathbf{c}_j \\in \\Omega$，宽度为 $\\sigma$。\n- 平滑的Heaviside函数为：若 $\\phi \\le -\\varepsilon$，则 $H_{\\varepsilon}(\\phi) = 0$；若 $\\phi \\ge \\varepsilon$，则 $H_{\\varepsilon}(\\phi) = 1$；对于 $|\\phi| < \\varepsilon$，则 $H_{\\varepsilon}(\\phi) = \\frac{1}{2}\\left(1 + \\frac{\\phi}{\\varepsilon} + \\frac{1}{\\pi}\\sin\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right)$。其导数（平滑的Dirac delta函数）为：若 $|\\phi| \\ge \\varepsilon$，则 $\\delta_{\\varepsilon}(\\phi) = 0$；对于 $|\\phi| < \\varepsilon$，则 $\\delta_{\\varepsilon}(\\phi) = \\frac{1}{2\\varepsilon}\\left(1 + \\cos\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right)\\right)$。\n\n离散模型和数值要求：\n- 在一个 $N \\times N$ 的内部点均匀网格上离散化PDE，网格间距为 $h = \\frac{1}{N+1}$，并在边界点上施加齐次Dirichlet边界值 $u=0$。使用带有可变系数的五点差分格式和内部面上的算术平均来组装 $-\\nabla \\cdot (k \\nabla u)$ 的离散算子；在与边界相邻的面上，取面上的传导系数为内部单元的传导系数。\n- 使用恒定源项 $s(\\mathbf{x}) \\equiv 1$。\n- 通过Riemann和 $J \\approx \\sum_{i} s_i u_i h^2$ 计算离散柔度 $J$。\n- 从第一性原理（PDE、柔度定义和伴随法）出发，推导并实现伴随法梯度 $\\frac{dJ}{d\\alpha_j}$。对包含 $|\\nabla u|^2$ 的积分使用一致的离散近似：在内部使用中心差分，并通过Dirichlet值填充以保证边界处的单边一致性。\n\n设计参数化：\n- 使用 $M = 3$ 个径向基函数，中心点为 $\\mathbf{c}_1 = (0.3, 0.3)$，$\\mathbf{c}_2 = (0.7, 0.3)$，$\\mathbf{c}_3 = (0.5, 0.7)$。\n- 使用宽度 $\\sigma = 0.15$。\n- 使用基准设计向量 $\\boldsymbol{\\alpha}_0 = [0.2, -0.3, 0.1]$。\n- 使用传导系数值 $k_{\\text{solid}} = 1.0$ 和 $k_{\\text{void}} = 10^{-3}$。\n\nHeaviside平滑：\n- 使用 $\\varepsilon = 2 h$ 作为Heaviside函数的平滑半宽。\n\n用于比较的数值微分格式实现：\n- 分量 $j$ 的前向差分：$\\left(\\frac{\\partial J}{\\partial \\alpha_j}\\right)_{\\text{FD}} \\approx \\frac{J(\\boldsymbol{\\alpha}_0 + h_{\\text{fd}} \\mathbf{e}_j) - J(\\boldsymbol{\\alpha}_0)}{h_{\\text{fd}}}$。\n- 分量 $j$ 的中心差分：$\\left(\\frac{\\partial J}{\\partial \\alpha_j}\\right)_{\\text{CD}} \\approx \\frac{J(\\boldsymbol{\\alpha}_0 + h_{\\text{fd}} \\mathbf{e}_j) - J(\\boldsymbol{\\alpha}_0 - h_{\\text{fd}} \\mathbf{e}_j)}{2 h_{\\text{fd}}}$。\n\n误差度量：\n- 对于梯度向量 $\\mathbf{g}_{\\text{ref}}$ 和 $\\mathbf{g}_{\\text{num}}$，计算逐分量的相对误差 $e_j = \\frac{|g_{\\text{num},j} - g_{\\text{ref},j}|}{\\max(|g_{\\text{ref},j}|, \\tau)}$，其中使用一个小的容差 $\\tau = 10^{-12}$ 以避免除以零，并报告各分量中的最大值 $\\max_j e_j$。\n- 对于方向 $\\mathbf{v}$ (其中 $\\|\\mathbf{v}\\|_2 = 1$) 的方向导数检验，将中心差分方向导数 $\\frac{J(\\boldsymbol{\\alpha}_0 + h_{\\text{fd}} \\mathbf{v}) - J(\\boldsymbol{\\alpha}_0 - h_{\\text{fd}} \\mathbf{v})}{2 h_{\\text{fd}}}$ 与内积 $\\mathbf{g}_{\\text{ref}} \\cdot \\mathbf{v}$ 进行比较，并报告其绝对误差。\n\n测试套件：\n- 使用以下四个测试用例，每个用例产生一个实数值结果：\n    1. 网格尺寸 $N = 31$，中心差分步长 $h_{\\text{fd}} = 10^{-4}$；报告在 $\\boldsymbol{\\alpha}_0$ 处评估的中心差分梯度与伴随法梯度之间的最大逐分量相对误差。\n    2. 网格尺寸 $N = 31$，中心差分步长 $h_{\\text{fd}} = 10^{-1}$；报告在 $\\boldsymbol{\\alpha}_0$ 处评估的中心差分梯度与伴随法梯度之间的最大逐分量相对误差。\n    3. 网格尺寸 $N = 31$，前向差分步长 $h_{\\text{fd}} = 10^{-8}$；报告在 $\\boldsymbol{\\alpha}_0$ 处评估的前向差分梯度与伴随法梯度之间的最大逐分量相对误差。\n    4. 网格尺寸 $N = 31$，中心差分步长 $h_{\\text{fd}} = 10^{-6}$，固定方向 $\\mathbf{v} = \\frac{1}{\\|\\tilde{\\mathbf{v}}\\|_2}\\tilde{\\mathbf{v}}$ (其中 $\\tilde{\\mathbf{v}} = [0.5, -0.7, 0.2]$)；报告中心差分方向导数与 $\\mathbf{g}_{\\text{ref}} \\cdot \\mathbf{v}$ 之间的绝对误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，`[result1,result2,result3,result4]`），结果的顺序与上面列出的四个测试用例完全一致。所有结果都是无量纲实数。", "solution": "该问题陈述已经过严格验证，并被确定为有效。它在科学上植根于连续介质力学和数值分析的原理，特别是关于使用水平集方法的拓扑优化和通过伴随法进行的灵敏度分析。该问题是适定的、客观的，并为数值实验提供了一套完整且一致的规范。它是一个实质性的、可验证的计算问题，并非琐碎或定义不清。因此，我们可以开始进行解答。\n\n问题的核心是计算类柔度目标函数关于定义材料分布的设计参数的梯度。设计由一个水平集函数参数化，结构响应由一个标量椭圆PDE控制。我们将首先使用连续伴随法推导梯度的表达式，然后详细说明用于数值实现的一致离散化方法。\n\n系统的状态由域 $\\Omega = (0,1) \\times (0,1)$ 上的标量椭圆PDE的解 $u(\\mathbf{x})$ 描述：\n$$ -\\nabla \\cdot (k(\\mathbf{x}) \\nabla u(\\mathbf{x})) = s(\\mathbf{x}) $$\n边界条件为齐次Dirichlet边界条件 $u=0$ on $\\partial\\Omega$。传导系数 $k(\\mathbf{x})$ 通过水平集函数 $\\phi(\\mathbf{x}; \\boldsymbol{\\alpha})$ 依赖于设计参数 $\\boldsymbol{\\alpha}$。目标泛函定义为：\n$$ J = \\int_{\\Omega} s(\\mathbf{x}) u(\\mathbf{x}) \\, d\\mathbf{x} $$\n我们寻求梯度 $\\frac{dJ}{d\\boldsymbol{\\alpha}}$。使用伴随法，我们引入一个带有伴随变量（拉格朗日乘子） $p(\\mathbf{x})$ 的拉格朗日函数 $\\mathcal{L}$：\n$$ \\mathcal{L}(u, p, \\boldsymbol{\\alpha}) = J(u, \\boldsymbol{\\alpha}) + \\int_{\\Omega} p \\left(\\nabla \\cdot (k(\\boldsymbol{\\alpha}) \\nabla u) + s\\right) \\, d\\mathbf{x} $$\n如果状态方程和伴随方程都得到满足，目标函数关于设计参数 $\\alpha_j$ 的全导数由拉格朗日函数的偏导数给出。我们首先通过要求 $\\mathcal{L}$ 对状态变量 $u$ 的Gâteaux导数对于所有容许的变分 $\\delta u$ 为零来建立伴随方程：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial u}(\\delta u) = \\int_{\\Omega} s \\, \\delta u \\, d\\mathbf{x} + \\int_{\\Omega} p \\, \\nabla \\cdot (k \\nabla \\delta u) \\, d\\mathbf{x} = 0 $$\n对第二项两次应用分部积分法，并利用在 $\\partial\\Omega$ 上 $\\delta u = 0$ 的事实，我们得到：\n$$ \\int_{\\Omega} p \\, \\nabla \\cdot (k \\nabla \\delta u) \\, d\\mathbf{x} = \\int_{\\Omega} (\\nabla \\cdot (k \\nabla p)) \\delta u \\, d\\mathbf{x} $$\n因此，关于Gâteaux导数的条件变为：\n$$ \\int_{\\Omega} \\left(s + \\nabla \\cdot (k \\nabla p)\\right) \\delta u \\, d\\mathbf{x} = 0 $$\n由于此式必须对任何容许的 $\\delta u$ 成立，我们得到伴随方程：\n$$ -\\nabla \\cdot (k(\\boldsymbol{\\alpha}) \\nabla p) = s $$\n伴随边界条件为 $p=0$ on $\\partial\\Omega$。对于此特定问题，伴随方程与状态方程相同，这意味着伴随解等于状态解，即 $p=u$。这是此类目标泛函的自伴随问题的一个特征。\n\n在伴随方程满足的条件下，目标函数的梯度通过取拉格朗日函数对 $\\alpha_j$ 的偏导数得到：\n$$ \\frac{dJ}{d\\alpha_j} = \\frac{\\partial \\mathcal{L}}{\\partial \\alpha_j} = \\int_{\\Omega} p \\, \\nabla \\cdot \\left( \\frac{\\partial k}{\\partial \\alpha_j} \\nabla u \\right) \\, d\\mathbf{x} $$\n应用分部积分法并利用在 $\\partial\\Omega$ 上 $p=0$，此式变为：\n$$ \\frac{dJ}{d\\alpha_j} = - \\int_{\\Omega} \\frac{\\partial k}{\\partial \\alpha_j} (\\nabla p \\cdot \\nabla u) \\, d\\mathbf{x} $$\n代入 $p=u$，我们得到：\n$$ \\frac{dJ}{d\\alpha_j} = - \\int_{\\Omega} \\frac{\\partial k}{\\partial \\alpha_j} |\\nabla u|^2 \\, d\\mathbf{x} $$\n连续推导的最后一步是求出 $\\frac{\\partial k}{\\partial \\alpha_j}$。根据给定的模型规格并使用链式法则：\n$$ \\frac{\\partial k}{\\partial \\alpha_j} = \\frac{\\partial k}{\\partial \\rho} \\frac{\\partial \\rho}{\\partial \\phi} \\frac{\\partial \\phi}{\\partial \\alpha_j} $$\n其中 $\\rho(\\mathbf{x}) = H_{\\varepsilon}(\\phi(\\mathbf{x};\\boldsymbol{\\alpha}))$。各项分别为：\n- $\\frac{\\partial k}{\\partial \\rho} = k_{\\text{solid}} - k_{\\text{void}}$\n- $\\frac{\\partial \\rho}{\\partial \\phi} = \\delta_{\\varepsilon}(\\phi)$，即平滑的Dirac delta函数。\n- $\\frac{\\partial \\phi}{\\partial \\alpha_j} = R_j(\\mathbf{x})$，即第 $j$ 个径向基函数。\n\n将这些代入梯度表达式，得到梯度分量的最终连续形式：\n$$ \\frac{dJ}{d\\alpha_j} = - (k_{\\text{solid}} - k_{\\text{void}}) \\int_{\\Omega} \\delta_{\\varepsilon}(\\phi(\\mathbf{x};\\boldsymbol{\\alpha})) R_j(\\mathbf{x}) |\\nabla u|^2 \\, d\\mathbf{x} $$\n\n为了进行数值实现，我们使用一个包含 $N \\times N$ 个内部点的均匀网格来离散化域 $\\Omega$，网格间距为 $h = 1/(N+1)$。状态方程使用五点有限差分格式进行离散化，得到一个稀疏线性系统 $\\mathbf{A}(\\boldsymbol{\\alpha})\\mathbf{u} = \\mathbf{s}$，其中 $\\mathbf{u}$ 是内部网格点上的解向量，$\\mathbf{s}$ 是源项值的向量，所有点的 $s_{i,j}=1$。刚度矩阵 $\\mathbf{A}$ 基于单元面上传导系数 $k$ 的算术平均构建，并遵循指定规则，即边界处面上的传导系数取为相邻内部单元的传导系数。\n\n一旦求解出状态方程得到 $\\mathbf{u}$，我们就可以计算梯度。问题要求我们对灵敏度积分使用一致的离散近似。我们将通过在内部网格点上进行Riemann和来计算此积分：\n$$ \\frac{dJ}{d\\alpha_j} \\approx - (k_{\\text{solid}} - k_{\\text{void}}) h^2 \\sum_{i=1}^{N} \\sum_{l=1}^{N} \\left( \\delta_{\\varepsilon}(\\phi_{i,l}) R_{j, i,l} |\\nabla u|^2_{i,l} \\right) $$\n其中索引 $(i,l)$ 遍历 $N \\times N$ 的内部网格。$|\\nabla u|^2_{i,l}$ 项使用二阶中心差分计算。为了一致地处理与边界相邻的点，离散解向量 $\\mathbf{u}$ 被重塑为一个 $N \\times N$ 的数组，并填充一层零以表示齐次Dirichlet边界条件。这使得中心差分格式可以统一应用于所有内部点。\n\n总体算法如下：\n1. 对于给定的设计向量 $\\boldsymbol{\\alpha}$，在网格上评估水平集函数 $\\phi$ 和传导系数场 $k$。\n2. 基于传导系数场 $k$ 组装稀疏刚度矩阵 $\\mathbf{A}$。\n3. 求解线性系统 $\\mathbf{A}\\mathbf{u} = \\mathbf{s}$，得到离散状态解 $\\mathbf{u}$。\n4. 使用在零填充解数组上的中心差分计算离散梯度场 $|\\nabla u|^2$。\n5. 对于每个设计参数 $\\alpha_j$，通过对灵敏度表达式进行求和来数值积分，从而评估梯度分量 $\\frac{dJ}{d\\alpha_j}$。\n\n然后，将这个基于伴随法的梯度 $\\mathbf{g}_{\\text{ref}}$ 与使用前向和中心有限差分格式对不同步长 $h_{\\text{fd}}$ 计算出的梯度进行比较，如测试套件中所指定。计算规定的误差度量（逐分量相对误差和方向导数绝对误差）以验证实现。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Implements and assesses numerical differentiation for a level set based material\n    optimization problem in solid mechanics.\n    \"\"\"\n\n    class LevelSetSolver:\n        \"\"\"\n        A class to solve the scalar elliptic PDE and compute sensitivities.\n        \"\"\"\n        def __init__(self, N, M, c, sigma, k_solid, k_void):\n            self.N = N\n            self.M = M\n            self.c = np.array(c)\n            self.sigma = sigma\n            self.k_solid = k_solid\n            self.k_void = k_void\n\n            self.h = 1.0 / (N + 1)\n            self.epsilon = 2.0 * self.h\n\n            # Create grid coordinates\n            x_coords = np.linspace(self.h, 1.0 - self.h, N)\n            self.x_grid, self.y_grid = np.meshgrid(x_coords, x_coords)\n\n            # Pre-compute RBFs on the grid\n            self.R = np.zeros((M, N, N))\n            for j in range(M):\n                dist_sq = (self.x_grid - self.c[j, 0])**2 + (self.y_grid - self.c[j, 1])**2\n                self.R[j] = np.exp(-dist_sq / self.sigma**2)\n\n        def H_eps(self, phi):\n            \"\"\" Smoothed Heaviside function. \"\"\"\n            H = np.zeros_like(phi)\n            mask_le = phi <= -self.epsilon\n            mask_ge = phi >= self.epsilon\n            mask_mid = np.abs(phi) < self.epsilon\n\n            H[mask_le] = 0.0\n            H[mask_ge] = 1.0\n            phi_mid = phi[mask_mid]\n            H[mask_mid] = 0.5 * (1.0 + phi_mid / self.epsilon + (1.0 / np.pi) * np.sin(np.pi * phi_mid / self.epsilon))\n            return H\n\n        def delta_eps(self, phi):\n            \"\"\" Smoothed Dirac delta function. \"\"\"\n            delta = np.zeros_like(phi)\n            mask_mid = np.abs(phi) < self.epsilon\n            phi_mid = phi[mask_mid]\n            delta[mask_mid] = (1.0 / (2.0 * self.epsilon)) * (1.0 + np.cos(np.pi * phi_mid / self.epsilon))\n            return delta\n\n        def get_k_field_and_phi(self, alpha):\n            \"\"\" Calculates conductivity k(x) and level set phi(x) for a given alpha. \"\"\"\n            phi = np.tensordot(alpha, self.R, axes=1)\n            rho = self.H_eps(phi)\n            k = self.k_void + (self.k_solid - self.k_void) * rho\n            return k, phi\n\n        def assemble_A(self, k):\n            \"\"\" Assembles the sparse stiffness matrix A.\"\"\"\n            N = self.N\n            h = self.h\n            A = lil_matrix((N * N, N * N))\n            \n            # Iterate through interior grid points\n            for i in range(N):  # y-index\n                for j in range(N):  # x-index\n                    idx = i * N + j  # 1D index\n\n                    # Conductivity at faces using specified rules\n                    # West face (x-dir)\n                    k_W = k[i, j] if j == 0 else (k[i, j] + k[i, j - 1]) / 2.0\n                    # East face (x-dir)\n                    k_E = k[i, j] if j == N - 1 else (k[i, j] + k[i, j + 1]) / 2.0\n                    # South face (y-dir)\n                    k_S = k[i, j] if i == 0 else (k[i, j] + k[i - 1, j]) / 2.0\n                    # North face (y-dir)\n                    k_N = k[i, j] if i == N - 1 else (k[i, j] + k[i + 1, j]) / 2.0\n                    \n                    # Fill matrix A based on 5-point stencil\n                    A[idx, idx] = (k_W + k_E + k_S + k_N)\n                    if j > 0: A[idx, idx - 1] = -k_W  # West neighbor\n                    if j < N - 1: A[idx, idx + 1] = -k_E  # East neighbor\n                    if i > 0: A[idx, idx - N] = -k_S  # South neighbor\n                    if i < N - 1: A[idx, idx + N] = -k_N  # North neighbor\n\n            return csc_matrix(A / h**2)\n\n        def solve_state(self, alpha):\n            \"\"\" Solves the PDE for the state variable u. \"\"\"\n            k, phi = self.get_k_field_and_phi(alpha)\n            A = self.assemble_A(k)\n            s = np.ones(self.N * self.N)\n            u_flat = spsolve(A, s)\n            u = u_flat.reshape((self.N, self.N))\n            return u, k, phi\n\n        def compute_J(self, u):\n            \"\"\" Computes the objective functional J. \"\"\"\n            return self.h**2 * np.sum(u)\n\n        def calculate_J_at_alpha(self, alpha):\n            \"\"\" Utility function to get J directly from an alpha vector. \"\"\"\n            u, _, _ = self.solve_state(alpha)\n            return self.compute_J(u)\n\n        def compute_adjoint_gradient(self, alpha):\n            \"\"\" Computes the gradient of J w.r.t. alpha using the adjoint method. \"\"\"\n            u, _, phi = self.solve_state(alpha)\n            \n            N, h = self.N, self.h\n            \n            # Pad u with zero boundary values for gradient calculation\n            u_padded = np.zeros((N + 2, N + 2))\n            u_padded[1:-1, 1:-1] = u\n\n            # Compute gradient of u using centered differences on padded array\n            du_dy = (u_padded[2:, 1:-1] - u_padded[:-2, 1:-1]) / (2.0 * h)\n            du_dx = (u_padded[1:-1, 2:] - u_padded[1:-1, :-2]) / (2.0 * h)\n            grad_u_sq = du_dx**2 + du_dy**2\n\n            delta = self.delta_eps(phi)\n            \n            # Calculate each component of the gradient vector\n            grad_J = np.zeros(self.M)\n            for j in range(self.M):\n                integrand = delta * self.R[j] * grad_u_sq\n                grad_J[j] = -(self.k_solid - self.k_void) * np.sum(integrand) * h**2\n            \n            return grad_J\n\n    # Problem parameters\n    N = 31\n    M = 3\n    c = [[0.3, 0.3], [0.7, 0.3], [0.5, 0.7]]\n    sigma = 0.15\n    alpha_0 = np.array([0.2, -0.3, 0.1])\n    k_solid = 1.0\n    k_void = 1e-3\n    tau = 1e-12\n\n    # Initialize solver\n    solver = LevelSetSolver(N, M, c, sigma, k_solid, k_void)\n    \n    # Calculate reference gradient using the adjoint method\n    g_ref = solver.compute_adjoint_gradient(alpha_0)\n\n    results = []\n\n    # Test Case 1: Central difference, h_fd = 1e-4\n    h_fd_1 = 1e-4\n    g_cd_1 = np.zeros(M)\n    for j in range(M):\n        alpha_plus = alpha_0.copy(); alpha_plus[j] += h_fd_1\n        alpha_minus = alpha_0.copy(); alpha_minus[j] -= h_fd_1\n        g_cd_1[j] = (solver.calculate_J_at_alpha(alpha_plus) - solver.calculate_J_at_alpha(alpha_minus)) / (2.0 * h_fd_1)\n    rel_error_1 = np.abs(g_cd_1 - g_ref) / np.maximum(np.abs(g_ref), tau)\n    results.append(np.max(rel_error_1))\n\n    # Test Case 2: Central difference, h_fd = 1e-1\n    h_fd_2 = 1e-1\n    g_cd_2 = np.zeros(M)\n    for j in range(M):\n        alpha_plus = alpha_0.copy(); alpha_plus[j] += h_fd_2\n        alpha_minus = alpha_0.copy(); alpha_minus[j] -= h_fd_2\n        g_cd_2[j] = (solver.calculate_J_at_alpha(alpha_plus) - solver.calculate_J_at_alpha(alpha_minus)) / (2.0 * h_fd_2)\n    rel_error_2 = np.abs(g_cd_2 - g_ref) / np.maximum(np.abs(g_ref), tau)\n    results.append(np.max(rel_error_2))\n\n    # Test Case 3: Forward difference, h_fd = 1e-8\n    h_fd_3 = 1e-8\n    g_fd_3 = np.zeros(M)\n    J_0 = solver.calculate_J_at_alpha(alpha_0)\n    for j in range(M):\n        alpha_plus = alpha_0.copy(); alpha_plus[j] += h_fd_3\n        g_fd_3[j] = (solver.calculate_J_at_alpha(alpha_plus) - J_0) / h_fd_3\n    rel_error_3 = np.abs(g_fd_3 - g_ref) / np.maximum(np.abs(g_ref), tau)\n    results.append(np.max(rel_error_3))\n\n    # Test Case 4: Directional derivative check\n    h_fd_4 = 1e-6\n    v_tilde = np.array([0.5, -0.7, 0.2])\n    v = v_tilde / np.linalg.norm(v_tilde)\n    alpha_plus = alpha_0 + h_fd_4 * v\n    alpha_minus = alpha_0 - h_fd_4 * v\n    dir_deriv_cd = (solver.calculate_J_at_alpha(alpha_plus) - solver.calculate_J_at_alpha(alpha_minus)) / (2.0 * h_fd_4)\n    dir_deriv_adj = np.dot(g_ref, v)\n    abs_error_4 = np.abs(dir_deriv_cd - dir_deriv_adj)\n    results.append(abs_error_4)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "2654352"}]}