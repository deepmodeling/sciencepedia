{"hands_on_practices": [{"introduction": "在许多降阶建模方法中，第一步是从高保真模拟数据（即“快照”）中提取一个紧凑的基。本练习的核心是“本征正交分解”(Proper Orthogonal Decomposition, POD) 技术，它旨在解决一个关键问题：如何确定保留多少个基向量才足够？通过一个在力学中具有直观物理意义的能量准则，我们将学习如何量化并选择一个最优的降阶基，以在保证精度的前提下最大程度地压缩数据。[@problem_id:2679837]", "problem": "考虑瞬态弹性动力学中的降阶建模问题，其中一组位移或速度快照的能量含量是根据一个代表离散化能量内积的对称正定（SPD）加权来评估的。令 $X \\in \\mathbb{R}^{n \\times m}$ 为一个快照矩阵，其列为状态快照；令 $W \\in \\mathbb{R}^{n \\times n}$ 为一个定义了加权内积 $\\langle u,v \\rangle_W = u^\\top W v$ 的 SPD 矩阵。目标是确定在 $W$-内积下，$X$ 的总能量含量中有多少被一个最优秩-$r$ 子空间的前 $r$ 个模态所捕获，并选择最小的 $r$，使得舍弃的能量分数最多为指定的容差 $\\varepsilon$。所有量均为无量纲分数；不需要物理单位。问题不涉及角度；不需要角度单位。\n\n仅从内积、正交投影和加权范数中的能量等线性代数基本原理出发，推导在 $W$-内积下与 $X$ 相关的最佳 $r$ 维子空间所捕获的累积能量含量的度量。利用该推导设计一个算法，为每个测试用例 $(X,W,\\varepsilon)$ 计算：\n- 满足舍弃能量分数小于或等于 $\\varepsilon$ 的最小整数 $r \\ge 0$，以及\n- 该 $r$ 值下实现的舍弃能量分数。\n\n如果在 $W$-内积下 $X$ 的总能量为零，则定义 $r = 0$ 且舍弃能量分数为 $0$。将舍弃能量分数表示为四舍五入到 $10$ 位小数的小数。\n\n您的程序必须解决以下测试套件。每个用例都明确提供了 $X$、$W$ 和 $\\varepsilon$。\n\n测试用例 #1：\n- $n = 5$, $m = 4$。\n- $W_1 = I_5$。\n- $$X_1 = \\begin{bmatrix}\n1.5 & 0.0 & 0.0 & 0.0 \\\\\n0.0 & 1.2 & 0.0 & 0.0 \\\\\n0.1 & 0.0 & 0.9 & 0.0 \\\\\n0.0 & 0.1 & 0.0 & 0.6 \\\\\n0.05 & 0.02 & 0.01 & 0.01\n\\end{bmatrix}$$。\n- $\\varepsilon_1 = 0.1$。\n\n测试用例 #2：\n- $n = 5$, $m = 3$。\n- $W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$。\n- $$X_2 = \\begin{bmatrix}\n1.0 & 0.5 & 0.2 \\\\\n0.0 & 0.4 & 0.0 \\\\\n0.0 & 0.0 & 0.3 \\\\\n0.2 & 0.0 & 0.1 \\\\\n0.0 & 0.0 & 0.05\n\\end{bmatrix}$$。\n- $\\varepsilon_2 = 0.01$。\n\n测试用例 #3（秩亏快照）：\n- $n = 5$, $m = 3$。\n- $W_3 = I_5$。\n- $$X_3 = \\begin{bmatrix}\n1.0 & 1.0 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.5 & 0.5 & 0.0 \\\\\n0.0 & 0.0 & 0.0 \\\\\n0.2 & 0.2 & 0.0\n\\end{bmatrix}$$。\n- $\\varepsilon_3 = 0$。\n\n测试用例 #4（完整 SPD 加权）：\n- $n = 5$, $m = 2$。\n- $$W_4 = \\begin{bmatrix}\n2.0 & 0.3 & 0.0 & 0.0 & 0.0 \\\\\n0.3 & 1.5 & 0.2 & 0.0 & 0.0 \\\\\n0.0 & 0.2 & 1.2 & 0.1 & 0.0 \\\\\n0.0 & 0.0 & 0.1 & 1.1 & 0.05 \\\\\n0.0 & 0.0 & 0.0 & 0.05 & 1.0\n\\end{bmatrix}$$。\n- $$X_4 = \\begin{bmatrix}\n0.5 & 0.1 \\\\\n0.1 & 0.4 \\\\\n0.0 & 0.3 \\\\\n0.2 & 0.0 \\\\\n0.0 & 0.1\n\\end{bmatrix}$$。\n- $\\varepsilon_4 = 0.5$。\n\n对于每个测试用例，您的程序必须：\n- 计算满足舍弃能量分数小于或等于 $\\varepsilon$ 的最小 $r$，\n- 计算该 $r$ 值下的舍弃能量分数，四舍五入到 $10$ 位小数，\n- 以 $[r, \\text{discarded}]$ 形式的列表输出该用例的结果。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含所有测试用例的结果，结果为逗号分隔的列表，并用方括号括起。每个测试用例的结果本身也是一个用方括号括起的列表。例如，输出必须具有 $[[r_1,\\text{discarded}_1],[r_2,\\text{discarded}_2],[r_3,\\text{discarded}_3],[r_4,\\text{discarded}_4]]$ 的形式，行内任何地方都没有空格。", "solution": "对问题陈述进行有效性分析。\n\n步骤1：提取已知条件\n- 一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$，其列为状态快照。\n- 一个对称正定（SPD）加权矩阵 $W \\in \\mathbb{R}^{n \\times n}$。\n- 一个加权内积，定义为 $\\langle u,v \\rangle_W = u^\\top W v$。\n- 一个舍弃能量分数的容差 $\\varepsilon$。\n- 目标是找到最小的整数 $r \\ge 0$，使得最优秩-$r$ 子空间舍弃的能量分数 $\\le \\varepsilon$。\n- 每个测试用例的输出是一对值：$[r, \\text{achieved discarded fraction}]$。\n- 一个特殊条件：如果 $X$ 的总能量为零，则 $r=0$ 并且舍弃分数为 $0$。\n- 提供了四个测试用例，其中包含明确的矩阵 $X_i, W_i$ 和容差 $\\varepsilon_i$。\n\n测试用例1：$X_1 \\in \\mathbb{R}^{5 \\times 4}$，$W_1 = I_5$，$\\varepsilon_1 = 0.1$。\n测试用例2：$X_2 \\in \\mathbb{R}^{5 \\times 3}$，$W_2 = \\mathrm{diag}(2.0, 1.0, 0.5, 1.5, 1.0)$，$\\varepsilon_2 = 0.01$。\n测试用例3：$X_3 \\in \\mathbb{R}^{5 \\times 3}$，$W_3 = I_5$，$\\varepsilon_3 = 0$。\n测试用例4：$X_4 \\in \\mathbb{R}^{5 \\times 2}$，$W_4$ 是一个完整 SPD 矩阵，$\\varepsilon_4 = 0.5$。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据充分**：该问题在代数及其在固体力学降阶建模（特别是本征正交分解或 POD）中的应用方面有充分的理论基础。使用与系统能量（例如动能或势能）相对应的加权内积是标准做法。\n- **问题适定**：该问题是适定的。最优子空间的存在性得到保证，并且找到它的方法（与奇异值或特征值分解相关）是既定的。所提供的数据足以找到 $r$ 和相应分数的唯一解。\n- **客观性**：问题陈述客观，具有精确的数学定义，没有主观语言。\n- 问题没有违反任何无效性标准。它是可形式化的、完整的、现实的，并且需要基于基本原理的非平凡推理。\n\n步骤3：结论与行动\n该问题是有效的。将提供一个完整的、有理有据的解决方案。\n\n**解的推导**\n\n我们的任务是找到一个最优的秩-$r$ 子空间，以最佳方式逼近一组快照 $\\{x_i\\}_{i=1}^m$，这些快照是矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 的列。逼近的质量通过所捕获的能量含量来衡量，其中能量通过加权内积 $\\langle u, v \\rangle_W = u^\\top W v$ 及其导出的范数 $\\|u\\|_W = \\sqrt{u^\\top W u}$ 来定义。矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 是对称正定的（SPD）。\n\n$1$. 总能量含量：\n单个快照向量 $x_i$ 的能量是其范数的平方，$\\|x_i\\|_W^2 = x_i^\\top W x_i$。整个快照集的总能量含量是各个快照能量的总和：\n$$ E_{total} = \\sum_{i=1}^{m} \\|x_i\\|_W^2 = \\sum_{i=1}^{m} x_i^\\top W x_i $$\n这个和可以用迹算子来表示。矩阵乘积 $X^\\top W X$ 的第 $i$ 个对角元素恰好是 $x_i^\\top W x_i$。因此，总能量是该乘积的迹：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) $$\n\n$2$. 变换到标准欧几里得空间：\n在一般加权内积下寻找最优子空间的问题，可以通过将其转换为标准欧几里得内积（其中 $\\langle u,v \\rangle = u^\\top v$）下的等效问题来简化。\n因为 $W$ 是 SPD 矩阵，所以它允许唯一的 Cholesky 分解 $W = L L^\\top$，其中 $L$ 是一个具有正对角元的实数下三角矩阵。加权内积可以重写为：\n$$ \\langle u, v \\rangle_W = u^\\top W v = u^\\top (L L^\\top) v = (L^\\top u)^\\top (L^\\top v) $$\n此表达式表明，向量 $u$ 和 $v$ 的 $W$-内积等价于变换后向量 $\\tilde{u} = L^\\top u$ 和 $\\tilde{v} = L^\\top v$ 的标准欧几里得内积。\n\n因此，在 $W$-范数下为原始快照 $X = [x_1, \\dots, x_m]$ 寻找最优表示，等价于在标准欧几里得范数下为变换后的快照 $\\tilde{X} = L^\\top X = [L^\\top x_1, \\dots, L^\\top x_m]$ 寻找最优表示。总能量在此变换下保持不变：\n$$ E_{total} = \\mathrm{Tr}(X^\\top W X) = \\mathrm{Tr}(X^\\top L L^\\top X) = \\mathrm{Tr}((L^\\top X)^\\top(L^\\top X)) = \\mathrm{Tr}(\\tilde{X}^\\top \\tilde{X}) = \\|\\tilde{X}\\|_F^2 $$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n\n$3$. 最优子空间与奇异值分解 (SVD)：\n根据 Eckart-Young-Mirsky 定理，矩阵 $\\tilde{X}$ 在弗罗贝尼乌斯范数下的最佳秩-$r$ 逼近由其截断奇异值分解（SVD）给出。设 $\\tilde{X}$ 的 SVD 为 $\\tilde{X} = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是由奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 组成的对角矩阵。\n最优秩-$r$ 子空间由 $U$ 的前 $r$ 列张成。该子空间所捕获的能量是 $\\tilde{X}$ 在该子空间上投影的弗罗贝尼乌斯范数的平方。这等于前 $r$ 个奇异值的平方和：\n$$ E_r = \\sum_{i=1}^{r} \\sigma_i^2 $$\n\n$4$. 与特征值问题的关系：\n计算 $\\tilde{X}$ 的完整 SVD 在计算上可能非常耗时，特别是当 $n$ 很大时。有一种更直接的方法。$\\tilde{X}$ 的奇异值的平方是矩阵 $\\tilde{X}^\\top \\tilde{X}$ 的特征值。这个较小的矩阵，称为相关矩阵，维度为 $m \\times m$：\n$$ C = \\tilde{X}^\\top \\tilde{X} = (L^\\top X)^\\top(L^\\top X) = X^\\top L L^\\top X = X^\\top W X $$\n令 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$ 为对称半正定矩阵 $C = X^\\top W X$ 的特征值。那么，对于 $i=1, \\dots, m$，有 $\\lambda_i = \\sigma_i^2$。\n\n$5$. 舍弃能量分数：\n总能量是 $C$ 的所有特征值之和：$E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n前 $r$ 个模态捕获的能量为 $E_r = \\sum_{i=1}^{r} \\lambda_i$。\n舍弃的能量是余下的部分：$E_{discarded}(r) = E_{total} - E_r = \\sum_{i=r+1}^{m} \\lambda_i$。\n因此，秩-$r$ 逼近的舍弃能量分数为：\n$$ f_d(r) = \\frac{E_{discarded}(r)}{E_{total}} = \\frac{\\sum_{i=r+1}^{m} \\lambda_i}{\\sum_{i=1}^{m} \\lambda_i} $$\n\n$6$. 算法设计：\n基于以上推导，找到满足 $f_d(r) \\le \\varepsilon$ 的最小整数 $r \\ge 0$ 的算法如下：\n1.  给定矩阵 $X$、$W$ 和容差 $\\varepsilon$。\n2.  构造相关矩阵 $C = X^\\top W X$。\n3.  计算 $C$ 的特征值。由于 $C$ 是对称的，其所有特征值都是实数。由于它也是半正定的，所有特征值都是非负的。\n4.  按降序对特征值进行排序：$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。\n5.  计算总能量 $E_{total} = \\sum_{i=1}^{m} \\lambda_i$。\n6.  如果 $E_{total}$ 在数值上为零，问题陈述规定返回 $r=0$ 和舍弃分数 $0.0$。\n7.  从 $r=0$ 到 $m$ 遍历可能的秩。对于每个 $r$：\n    a. 计算捕获的能量 $E_r = \\sum_{i=1}^{r} \\lambda_i$。（对于 $r=0$，$E_0=0$）。\n    b. 计算舍弃的能量分数 $f_d(r) = (E_{total} - E_r) / E_{total}$。\n    c. 如果 $f_d(r) \\le \\varepsilon$，则此 $r$ 值是所需的最小秩。算法终止并返回此 $r$ 和计算出的 $f_d(r)$。\n由于舍弃的能量分数是 $r$ 的单调非增函数，此迭代保证能找到最小的 $r$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    # Test case #1\n    X1 = np.array([\n        [1.5, 0.0, 0.0, 0.0],\n        [0.0, 1.2, 0.0, 0.0],\n        [0.1, 0.0, 0.9, 0.0],\n        [0.0, 0.1, 0.0, 0.6],\n        [0.05, 0.02, 0.01, 0.01]\n    ])\n    W1 = np.identity(5)\n    epsilon1 = 0.1\n\n    # Test case #2\n    X2 = np.array([\n        [1.0, 0.5, 0.2],\n        [0.0, 0.4, 0.0],\n        [0.0, 0.0, 0.3],\n        [0.2, 0.0, 0.1],\n        [0.0, 0.0, 0.05]\n    ])\n    W2 = np.diag([2.0, 1.0, 0.5, 1.5, 1.0])\n    epsilon2 = 0.01\n\n    # Test case #3\n    X3 = np.array([\n        [1.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.5, 0.5, 0.0],\n        [0.0, 0.0, 0.0],\n        [0.2, 0.2, 0.0]\n    ])\n    W3 = np.identity(5)\n    epsilon3 = 0.0\n\n    # Test case #4\n    X4 = np.array([\n        [0.5, 0.1],\n        [0.1, 0.4],\n        [0.0, 0.3],\n        [0.2, 0.0],\n        [0.0, 0.1]\n    ])\n    W4 = np.array([\n        [2.0, 0.3, 0.0, 0.0, 0.0],\n        [0.3, 1.5, 0.2, 0.0, 0.0],\n        [0.0, 0.2, 1.2, 0.1, 0.0],\n        [0.0, 0.0, 0.1, 1.1, 0.05],\n        [0.0, 0.0, 0.0, 0.05, 1.0]\n    ])\n    epsilon4 = 0.5\n\n    test_cases = [\n        (X1, W1, epsilon1),\n        (X2, W2, epsilon2),\n        (X3, W3, epsilon3),\n        (X4, W4, epsilon4)\n    ]\n\n    results = []\n    for X, W, epsilon in test_cases:\n        result = compute_optimal_rank(X, W, epsilon)\n        results.append(result)\n\n    # Format the final output string without spaces.\n    inner_results_str = [f\"[{r},{d}]\" for r, d in results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\ndef compute_optimal_rank(X, W, epsilon):\n    \"\"\"\n    Computes the smallest rank r and the corresponding discarded energy fraction.\n\n    Args:\n        X (np.ndarray): Snapshot matrix of size n x m.\n        W (np.ndarray): SPD weighting matrix of size n x n.\n        epsilon (float): Tolerance for the discarded energy fraction.\n\n    Returns:\n        list: A list containing [r, discarded_fraction].\n    \"\"\"\n    # Form the m x m correlation matrix C = X^T * W * X\n    C = X.T @ W @ X\n\n    # The eigenvalues of C are the squared singular values of L^T * X.\n    # We use eigh for symmetric matrices, which is numerically stable and efficient.\n    # It returns eigenvalues in ascending order.\n    eigenvalues = linalg.eigh(C, eigvals_only=True)\n    \n    # Sort eigenvalues in descending order\n    eigenvalues = np.sort(eigenvalues)[::-1]\n    \n    # Total energy is the sum of all eigenvalues.\n    total_energy = np.sum(eigenvalues)\n\n    # Handle the case where total energy is zero.\n    if np.isclose(total_energy, 0.0):\n        return [0, 0.0]\n\n    # Number of snapshots (and maximum possible rank)\n    m = X.shape[1]\n\n    # Iterate from r=0 to m to find the smallest r satisfying the condition.\n    cumulative_energy = 0.0\n    for r in range(m + 1):\n        if r == 0:\n            retained_energy = 0.0\n        else:\n            # For a given r, we retain the first r largest eigenvalues.\n            retained_energy = np.sum(eigenvalues[:r])\n\n        discarded_fraction = (total_energy - retained_energy) / total_energy\n        \n        # Check against the tolerance.\n        if discarded_fraction <= epsilon:\n            # Found the minimal r. Round the fraction and return.\n            return [r, round(discarded_fraction, 10)]\n    \n    # This part should not be reached for epsilon >= 0, as for r=m,\n    # the discarded fraction is 0. It's included for robustness.\n    return [m, 0.0]\n\nsolve()\n```", "id": "2679837"}, {"introduction": "学会了如何构建基之后，下一步自然是利用它通过伽辽金投影(Galerkin projection)创建一个更小、更快的动力学系统。然而，这个过程并非万无一失，甚至可能隐藏着危险。本练习将通过一个经典的数值实验，揭示一个降阶建模中的重要陷阱：一个完全稳定的全阶模型，在经过投影后，其降阶模型却可能变得不稳定并最终“爆炸”。理解这一现象对于构建可靠的降阶模型至关重要。[@problem_id:2432128]", "problem": "要求您实现一个完整的降阶建模数值实验，以演示以下现象：一个本征正交分解 (POD) 基在重构一个稳定的全阶线性时不变系统的训练快照时可能表现出色，但通过 Galerkin 投影得到的降阶模型 (ROM) 在进行时间积分时却可能产生不稳定的、会发散的动力学。\n\n您的实现必须从全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数域上进行，并使用标准的欧几里得内积。在整个实验中，您将使用 $n=2$。\n\n基本定义和要求：\n- 本征正交分解 (POD) 基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1) & \\mathbf{x}(t_2) & \\cdots & \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解 (SVD) $\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取为 $\\mathbf{U}$ 的前 $r$ 列。\n- Galerkin 投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}。\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 的演化遵循\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t)。\n$$\n- 时间积分：对全阶模型和 ROM 均使用经典的四阶 Runge–Kutta 方法，并采用固定时间步长 $h>0$。将初始条件设置为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照收集：在训练区间 $[0,T_{\\text{train}}]$ 上以恒定时间步长 $h$ 对全阶模型进行积分，在每一步采样状态以构成 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对 POD 重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示 Frobenius 范数。\n- 发散检测：在测试区间 $[0,T_{\\text{test}}]$ 上以相同的 $h$ 对全阶模型和 ROM 进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或任何分量变为非数值 (not-a-number) 或无穷大，则声明一个解“已发散”。使用阈值 $M=10^6$。\n\n为引发 ROM 不稳定性而构造的强迫项：\n- 对于每个测试，您必须按如下方式构造常数强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（以任意但确定的方式处理并列情况）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}。\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的且 $\\mathbf{S}$ 的最大特征值为正时，用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 获得的标量 ROM 具有降阶动力学 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}>0$ 和 $b_r=-a_r$，这是不稳定的，会从 $z(0)=0$ 发散。\n\n所有测试通用的数值设定：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典的四阶 Runge–Kutta 方法。\n- 对所有向量范数使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试套件：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上收集快照以形成 $\\mathbf{Q}$，然后构建 ROM 并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 $1$ (高度非正规，秩为 $1$ 的 POD):\n  - $$\\mathbf{A}=\\begin{bmatrix}-0.1 & \\alpha \\\\ 0 & -1.0\\end{bmatrix}$$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $2$ (高度非正规，秩为 $2$ 的 POD):\n  - $$\\mathbf{A}=\\begin{bmatrix}-0.1 & \\alpha \\\\ 0 & -1.0\\end{bmatrix}$$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $3$ (对称负定，秩为 $1$ 的 POD):\n  - $$\\mathbf{A}=\\begin{bmatrix}-1.0 & 0.0 \\\\ 0.0 & -2.0\\end{bmatrix}$$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 $4$ (更高程度的非正规，秩为 $1$ 的 POD):\n  - $$\\mathbf{A}=\\begin{bmatrix}-0.1 & \\alpha \\\\ 0 & -1.0\\end{bmatrix}$$，其中 $\\alpha=120.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n\n要求输出：\n- 对每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$，四舍五入到六位小数，\n  - 一个布尔值，指示 ROM 是否在 $[0,T_{\\text{test}}]$ 上发散，\n  - 一个布尔值，指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发散。\n- 将所有测试的结果聚合为单行，形式为用方括号括起来的逗号分隔列表，顺序与测试顺序相同。示例格式：`[[0.123456,true,false],[0.000000,false,false],...]`。", "solution": "用户提出了一个计算工程问题，具体涉及从本征正交分解 (POD) 和 Galerkin 投影导出的降阶模型 (ROM) 的稳定性。任务是通过数值实验来演示一种已知的失效模式：尽管全阶模型 (FOM) 是稳定的，但 ROM 却可能不稳定。这种现象是由高度非正规算子控制的系统的典型特征。\n\n问题陈述已经过验证，被认为是科学上合理、适定且完整的。所有定义、参数和程序都规定得足够清晰，可以得到唯一且可验证的解。我们将着手进行分析和实现。\n\n问题的核心在于矩阵 $\\mathbf{A}$ 的谱与其数值范围（或值域）之间的区别，后者定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，其稳定性由 $\\mathbf{A}$ 的特征值（谱，$\\sigma(\\mathbf{A})$）决定。如果所有特征值都具有负实部，系统就是稳定的，并且当 $t\\to\\infty$ 时 $\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围为这种瞬态行为提供了深刻见解。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到右半平面，表明存在瞬态能量增长的可能。\n\n使用秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 进行 Galerkin 投影，将 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 转换为 ROM $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。ROM的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键在于，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围内，但不一定在其谱的凸包内。如果数值范围 $W(\\mathbf{A})$ 跨入右半平面，就有可能找到一个投影子空间（基为 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 具有正实部的特征值，从而使 ROM 不稳定。\n\n问题的构造旨在暴露这种病态问题。FOM 是稳定的（$\\mathbf{A}$ 的特征值为 $\\{-0.1, -1.0\\}$）。选择强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 是为了使 FOM 的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是对应于 $\\mathbf{S}$ 最大特征值的特征向量。这将系统动力学推向最大瞬态增长的方向。由此产生的快照将由该方向主导，导致主 POD 模态（$\\mathbf{Q}$ 的第一列）与 $\\mathbf{q}$ 对齐。对于秩为 1 的 ROM（$r=1$），降阶矩阵 $\\mathbf{A}_r$ 变为一个标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，则 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试 1 和测试 4 中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S}) > 0$，从而导致一个不稳定的 ROM。\n\n每个测试案例的计算步骤如下：\n$1$. 定义系统参数：矩阵 $\\mathbf{A}$、ROM 秩 $r$ 以及时间区间 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n$2$. 构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。求其特征值和特征向量。设 $\\mathbf{q}$ 为对应于最大特征值的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n$3$. 生成训练数据：使用经典的四阶 Runge-Kutta 方法，从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始，在时间区间 $[0, T_{\\text{train}}]$ 上对 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 进行积分。将每个时间步的状态收集到快照矩阵 $\\mathbf{X}$ 中。\n$4$. 计算 POD 基：对快照矩阵进行奇异值分解 (SVD)，$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n$5$. 计算重构误差：相对 Frobenius 范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n$6$. 构建 ROM：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n$7$. 进行测试的时间积分：FOM 和 ROM 都从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$, $\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上进行积分。在积分过程中，每一步都检查状态向量的欧几里得范数是否超过发散阈值 $M=10^6$。\n$8$. 记录结果：测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示 ROM 是否发散的布尔值，以及一个指示 FOM 是否发散的布尔值。\n\n测试的预期结果：\n- **测试 1**：（$\\mathbf{A}$ 非正规, $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的 ROM。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM 发散，而 FOM 不发散。\n- **测试 2**：（$\\mathbf{A}$ 非正规, $r=2$）：这里，$r=n=2$。POD 基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度量级）。ROM 在动力学上与 FOM 等价，只是在不同的基下表示。由于 FOM 是稳定的，ROM 也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，ROM 和 FOM 均不发散。\n- **测试 3**：（$\\mathbf{A}$ 对称, $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值 $\\{-1.0, -2.0\\}$ 的凸包。因此，数值范围是实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必须为负。ROM 将是稳定的。我们预期两个模型都不会发散。\n- **测试 4**：（$\\mathbf{A}$ 更高程度非正规, $r=1$）：与测试 1 类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有一个更大的正特征值。ROM 的不稳定性应该更加显著。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM 发散，而 FOM 不发散。\n\n现在将实现上述逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if np.linalg.norm(y) > M or not np.all(np.isfinite(y)):\n                blew_up = True\n                # Continue collecting snapshots to see the blow-up, if needed for X\n                # But stop checking once blown up.\n                while len(snapshots) < num_steps + 1:\n                    snapshots.append(y.copy()) # Append the diverging state\n                    y = rk4_step(lti_rhs, y, h, A, b) # Could become inf/nan\n                return np.array(snapshots).T, True\n\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1]>1:\n         norm_X_sq = np.sum(s**2)\n         if norm_X_sq > 0:\n            norm_err_sq = np.sum(s[r:]**2)\n            eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n         else:\n            eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432128"}, {"introduction": "现实世界的工程问题往往需要分析系统在一系列参数（如材料属性或载荷）下的行为，为每个参数都进行一次完整的模拟是不切实际的。本练习介绍了一种强大的“贪心算法”，用于智能地构建一个能在整个参数空间内都有效的降阶基。我们将学习如何利用基于残差的误差估计器来指导基的构建过程，这正是“认证降阶模型”方法的基石。[@problem_id:2679813]", "problem": "考虑一根长度为 $L$、横截面积恒为 $A$ 的一维、准静态、线性弹性杆，其处于小应变状态。该杆左端固定，即 $u(0)=0$，右端 $x=L$ 处承受大小为 $P$ 的拉伸力。杨氏模量 $E$ 沿杆均匀分布。令 $\\mu=(E,P)$ 表示参数对。控制方程源自线性动量平衡和胡克定律：强形式的平衡方程为\n$$\n\\dfrac{d}{dx}\\left(\\sigma A\\right)=0\n$$\n，本构关系为 $\\sigma=E \\varepsilon$，运动学关系为 $\\varepsilon=\\dfrac{du}{dx}$。其弱形式为：求解 $u\\in V=\\{v\\in H^1(0,L)\\,|\\,v(0)=0\\}$，使得对于所有 $v\\in V$，均有\n$$\n\\int_0^L E A \\frac{du}{dx}\\frac{dv}{dx}\\,dx = P\\, v(L).\n$$\n使用协调的线性有限元方法，在包含 $N$ 个单元的均匀网格上对弱形式进行离散化，节点间距为 $h=L/N$。在施加 $x=0$ 处的本质边界条件后，令 $u_h\\in\\mathbb{R}^{n}$ 表示节点未知量向量，其中自由度数量为 $n=N$。由此产生的线性系统为\n$$\nK(E)\\, u_h = f(P),\n$$\n其中刚度矩阵为 $K(E)=E\\,K_0$，载荷向量为 $f(P)=P\\,f_0$，$K_0$ 和 $f_0$ 是由网格、$A$、Dirichlet 和 Neumann 边界条件决定的、与参数无关的矩阵/向量。\n\n您的任务是实现一种基于贪心算法的降阶建模方法，该算法构建一个降阶空间，并根据真实解（全阶解）验证一个基于残差的误差估计器。您的实现必须遵循以下规范。\n\n1. 有限元真实模型。\n   - 使用长度 $L=1$ 米，横截面积 $A=1$ 平方米。\n   - 使用包含 $N=200$ 个线性单元的均匀网格。\n   - 施加 $u(0)=0$ 和在 $x=L$ 处大小为 $P$ 的拉力。等效的有限元右端项在最后一个自由节点上有一个大小为 $P$ 的贡献。\n   - 组装 $E=1$ 时的 $K_0$ 和 $P=1$ 时的 $f_0$，以满足 $K(E)=E\\,K_0$ 和 $f(P)=P\\,f_0$。\n\n2. 能量范数和基于残差的误差估计器。\n   - 对于给定的参数 $\\mu=(E,P)$ 和任意离散向量 $w\\in\\mathbb{R}^n$，定义能量范数 $\\|w\\|_{E}:=\\sqrt{w^\\top K(E)\\, w}$。\n   - 令 $u_h(\\mu)$ 为 $K(E)\\,u_h=f(P)$ 的真实解，令 $u_r(\\mu)$ 为通过 Galerkin 投影到由矩阵 $V\\in\\mathbb{R}^{n\\times r}$（$r\\ll n$）的列向量所张成的降阶空间上得到的降阶解。残差为 $r(\\mu)=f(P)-K(E)\\,u_r(\\mu)$。\n   - 定义基于残差的误差估计器为\n     $$\n     \\eta(\\mu) := \\sqrt{r(\\mu)^\\top K(E)^{-1} r(\\mu)}.\n     $$\n     对于 Galerkin 投影，该量等于误差的能量范数，即 $\\eta(\\mu)=\\|u_h(\\mu)-u_r(\\mu)\\|_{E}$。为计算 $\\eta(\\mu)$，求解辅助系统 $K(E)\\, z(\\mu) = r(\\mu)$ 并计算 $\\eta(\\mu)=\\sqrt{r(\\mu)^\\top z(\\mu)}$。\n\n3. 贪心降阶基构造。\n   - 定义参数的训练集 $\\mathcal{P}_{\\mathrm{train}}$。$E$ 的单位为帕斯卡，$P$ 的单位为牛顿。令 $E\\in\\{7.0\\times 10^{10},\\,1.0\\times 10^{11},\\,1.5\\times 10^{11},\\,2.1\\times 10^{11}\\}$ 且 $P\\in\\{1.0\\times 10^{3},\\,5.0\\times 10^{4},\\,1.0\\times 10^{5}\\}$，构成一个包含12个点的网格。\n   - 将降阶基初始化为空向量集。\n   - 在每次贪心迭代中：\n     - 对于每个 $\\mu\\in\\mathcal{P}_{\\mathrm{train}}$，在当前降阶空间中计算降阶解 $u_r(\\mu)$（如果空间为空，则设 $u_r(\\mu)=0$）。\n     - 通过求解 $K(E)\\, z(\\mu)=r(\\mu)$ 并设 $\\eta(\\mu)=\\sqrt{r(\\mu)^\\top z(\\mu)}$ 来计算残差 $r(\\mu)$ 和估计器 $\\eta(\\mu)$。\n     - 计算相对估计器 $\\eta_{\\mathrm{rel}}(\\mu):=\\dfrac{\\eta(\\mu)}{\\|u_h(\\mu)\\|_{E}}$。此处，通过求解 $K(E)\\,u_h(\\mu)=f(P)$ 并计算 $\\sqrt{f(P)^\\top u_h(\\mu)}$ 来计算 $\\|u_h(\\mu)\\|_{E}$。\n     - 选择使得 $\\eta_{\\mathrm{rel}}(\\mu)$ 在 $\\mathcal{P}_{\\mathrm{train}}$ 上最大化的参数 $\\mu^\\star$。如果最大相对估计器小于容差 $\\varepsilon=10^{-10}$ 或基维度达到 $r_{\\max}=10$，则终止。否则，用真实解快照 $u_h(\\mu^\\star)$ 扩充降阶基，该快照需要相对于由 $K_0$ 导出的内积（即 $\\langle w_1,w_2\\rangle_{0} := w_1^\\top K_0\\, w_2$）进行正交归一化。\n   - 使用标准的修正 Gram–Schmidt 方法来维持 $V$ 的列向量关于 $K_0$ 的正交归一性。\n\n4. 在线评估和验证。\n   - 在构造 $V$ 之后，对于任意 $\\mu$，通过求解降阶系统来计算降阶解\n     $$\n     (V^\\top K(E)\\, V) a(\\mu) = V^\\top f(P), \\quad u_r(\\mu)=V\\, a(\\mu).\n     $$\n   - 通过计算真实的相对能量范数误差 $\\dfrac{\\|u_h(\\mu)-u_r(\\mu)\\|_E}{\\|u_h(\\mu)\\|_E}$ 和估计的相对误差 $\\dfrac{\\eta(\\mu)}{\\|u_h(\\mu)\\|_E}$，来验证基于残差的估计器与真实误差的一致性；对于 Galerkin 投影，二者在数值舍入误差范围内是相等的。\n\n5. 单位和输出。\n   - $L$ 的单位为米，$A$ 的单位为平方米，$E$ 的单位为帕斯卡，$P$ 的单位为牛顿，$u$ 的单位为米。误差和相对误差是无量纲的。将最终输出表示为无量纲的十进制数。\n   - 不使用角度单位。\n\n6. 测试套件和要求的最终输出格式。\n   - 使用上述训练集和贪心过程构建降阶空间。\n   - 然后评估以下三个测试案例：\n     - 案例1：$\\mu_1=(E,P)=(1.2\\times 10^{11},\\,7.5\\times 10^{4})$。\n     - 案例2：$\\mu_2=(E,P)=(7.0\\times 10^{10},\\,1.0\\times 10^{5})$。\n     - 案例3：$\\mu_3=(E,P)=(2.1\\times 10^{11},\\,1.0\\times 10^{3})$。\n   - 对于每个案例 $i\\in\\{1,2,3\\}$，计算真实的相对能量范数误差 $\\dfrac{\\|u_h(\\mu_i)-u_r(\\mu_i)\\|_E}{\\|u_h(\\mu_i)\\|_E}$。\n   - 您的程序应生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起。例如，输出格式为 `[1.23456789e-06,2.34567890e-06,3.45678901e-06]`。", "solution": "我们从一维小应变线性弹性的第一性原理出发。无体力时的平衡方程为 $\\dfrac{d}{dx}(\\sigma A)=0$，其中 $\\sigma$ 是 Cauchy 应力，$A$ 是横截面积。本构法则是线性弹性的胡克定律 $\\sigma=E\\,\\varepsilon$，其中 $E$ 是杨氏模量，$\\varepsilon$ 是轴向应变。运动学关系为 $\\varepsilon=\\dfrac{du}{dx}$，其中 $u$ 是轴向位移。本质边界条件是 $u(0)=0$，自然边界条件是 $\\sigma(L)A=P$，其中 $P$ 是在 $x=L$ 处施加的轴向拉力。\n\n将强形式乘以一个测试函数 $v\\in V=\\{w\\in H^1(0,L)\\mid w(0)=0\\}$ 并进行分部积分，我们得到弱形式：求解 $u\\in V$，使得\n$$\n\\int_0^L E A \\frac{du}{dx}\\frac{dv}{dx}\\,dx = P\\, v(L) \\quad \\text{for all } v\\in V.\n$$\n此双线性形式在 $V$ 上是矫顽的(coercive)，因为对于任意 $w\\in V$，有 $\\int_0^L E A \\left(\\frac{dw}{dx}\\right)^2 dx \\ge \\alpha \\int_0^L \\left(\\frac{dw}{dx}\\right)^2 dx$，矫顽常数 $\\alpha=E A>0$。相关的能量半范数为 $\\|w\\|_{E}:=\\sqrt{\\int_0^L E A (w')^2 \\, dx}$。\n\n我们使用协调的线性有限元方法，在均匀网格上对弱形式进行离散化。令 $N$ 为单元数量，$n=N$ 为施加 $u(0)=0$ 后的自由度数量。全局刚度矩阵可以写为 $K(E)=E\\,K_0$，其中 $(K_0)_{ij}=\\int_0^L A \\phi_i' \\phi_j' \\, dx$，$\\phi_i$ 是在网格上定义的节点形函数。对于具有线性单元和 $A=1$ 的均匀网格，单元刚度为 $k_e = \\dfrac{1}{h}\\begin{bmatrix} 1 & -1\\\\ -1 & 1\\end{bmatrix}$，其中 $h=L/N$。组装后得到一个 $n\\times n$ 的对称正定矩阵 $K_0$。右端项 $f(P)$ 对 $P$ 是线性的，对于右端的纯拉力，有 $f(P)=P\\, f_0$，其中 $f_0$ 在最后一个自由节点处为单位值，其他位置为零。真实解（全阶解）$u_h(\\mu)$ 满足 $K(E)\\,u_h = f(P)$。\n\n为衡量误差，我们采用与参数相关的双线性形式所关联的能量范数：对于任意向量 $w\\in\\mathbb{R}^n$，定义 $\\|w\\|_E=\\sqrt{w^\\top K(E) w}$。请注意，由于 $K(E)u_h=f(P)$，有 $\\|u_h\\|_E=\\sqrt{u_h^\\top K(E) u_h} = \\sqrt{u_h^\\top f(P)}$。这避免了在离散层面进行显式求积。\n\n接下来我们定义一个降阶模型。令 $V\\in\\mathbb{R}^{n\\times r}$ 为一组（关于某个固定内积）列正交归一的基，其张成降阶空间。我们选择 $K_0$ 作为正交归一化的度量，因为它与参数无关，并能反映 $E=1$ 时的应变能。具体来说，对于任意 $w_1,w_2\\in\\mathbb{R}^n$，定义 $\\langle w_1,w_2\\rangle_0 = w_1^\\top K_0 w_2$。对于给定的参数 $\\mu=(E,P)$，降阶 Galerkin 系统为\n$$\n(V^\\top K(E) V) a(\\mu) = V^\\top f(P), \\quad u_r(\\mu) = V a(\\mu),\n$$\n该系统在 $K(E)$-正交的意义上最小化残差。残差为 $r(\\mu)=f(P)-K(E)u_r(\\mu)$。对于对称正定的 $K(E)$ 和 Galerkin 降阶解，误差 $e(\\mu)=u_h(\\mu)-u_r(\\mu)$ 的能量范数满足\n$$\n\\|e(\\mu)\\|_E^2 = e(\\mu)^\\top K(E) e(\\mu) = e(\\mu)^\\top r(\\mu) = r(\\mu)^\\top K(E)^{-1} r(\\mu).\n$$\n最后一个等式由 $K(E) e(\\mu) = r(\\mu)$ 得出。因此，能量范数下一个精确的、基于残差的误差估计器为\n$$\n\\eta(\\mu) = \\sqrt{r(\\mu)^\\top K(E)^{-1} r(\\mu)},\n$$\n它可以通过求解 $K(E) z(\\mu) = r(\\mu)$ 并设 $\\eta(\\mu)=\\sqrt{r(\\mu)^\\top z(\\mu)}$ 来计算。相对误差为 $\\eta_{\\mathrm{rel}}(\\mu) = \\dfrac{\\eta(\\mu)}{\\|u_h(\\mu)\\|_E}$，其中 $\\|u_h(\\mu)\\|_E=\\sqrt{f(P)^\\top u_h(\\mu)}$，而 $u_h(\\mu)$ 是通过求解 $K(E) u_h(\\mu)=f(P)$ 得到的。\n\n现在我们描述构造 $V$ 的贪心算法。令训练集为\n$$\n\\mathcal{P}_{\\mathrm{train}} = \\{(E,P)\\,:\\, E\\in\\{7.0\\times 10^{10},\\,1.0\\times 10^{11},\\,1.5\\times 10^{11},\\,2.1\\times 10^{11}\\},\\; P\\in\\{1.0\\times 10^{3},\\,5.0\\times 10^{4},\\,1.0\\times 10^{5}\\}\\}.\n$$\n将 $V$ 初始化为零列矩阵。在每次迭代中：\n- 对于每个 $\\mu\\in\\mathcal{P}_{\\mathrm{train}}$，如果 $V$ 非空，则通过求解降阶系统计算 $u_r(\\mu)$；否则，设 $u_r(\\mu)=0$。构造 $r(\\mu)=f(P)-K(E)u_r(\\mu)$。通过求解 $K(E) z(\\mu)=r(\\mu)$ 并计算 $\\sqrt{r(\\mu)^\\top z(\\mu)}$ 来得到 $\\eta(\\mu)$。通过求解 $K(E) u_h(\\mu)=f(P)$ 并计算 $\\|u_h(\\mu)\\|_E=\\sqrt{f(P)^\\top u_h(\\mu)}$ 来得到相对误差估计器 $\\eta_{\\mathrm{rel}}(\\mu)$。\n- 找出使 $\\eta_{\\mathrm{rel}}(\\mu)$ 最大化的参数 $\\mu^\\star$。如果 $\\max_{\\mu}\\eta_{\\mathrm{rel}}(\\mu) < \\varepsilon$（容差 $\\varepsilon=10^{-10}$），或基维度达到 $r_{\\max}=10$，则停止。\n- 否则，通过求解 $K(E) u_h(\\mu^\\star)=f(P)$ 计算 $u_h(\\mu^\\star)$，并使用修正 Gram–Schmidt 方法，使其相对于 $V$ 的当前列向量在 $K_0$ 内积下正交。将其归一化至单位 $K_0$ 范数，并作为新的一列附加到 $V$。\n\n对于当前问题，$K(E)=E K_0$ 且 $f(P)=P f_0$，其中 $E$和$P$是标量。真实解的形式为 $u_h(\\mu)=\\dfrac{P}{E} u_\\mathrm{ref}$，其中 $u_\\mathrm{ref}=K_0^{-1} f_0$。因此，解流形 $\\{u_h(\\mu)\\}_{\\mu\\in\\mathcal{P}}$ 是一维的，由 $u_\\mathrm{ref}$ 张成。因此，贪心算法在添加一个快照后就会终止，因为维度 $r=1$ 的降阶空间已经捕捉了整个解流形，真实的相对能量范数误差将在数值舍入误差范围内为零。基于残差的估计器等于 Galerkin 投影的真实能量误差，因此将验证这一结论。\n\n在在线阶段，对于任何给定的参数 $\\mu=(E,P)$，我们从降阶系统计算出 $u_r(\\mu)$，然后通过构造 $u_h(\\mu)$ 和 $u_r(\\mu)$并使用由 $K(E)$ 导出的离散能量范数，来评估相对能量范数误差 $\\dfrac{\\|u_h(\\mu)-u_r(\\mu)\\|_E}{\\|u_h(\\mu)\\|_E}$。\n\n最后，我们必须为以下三个测试案例生成结果：\n- $\\mu_1=(1.2\\times 10^{11},\\,7.5\\times 10^{4})$,\n- $\\mu_2=(7.0\\times 10^{10},\\,1.0\\times 10^{5})$,\n- $\\mu_3=(2.1\\times 10^{11},\\,1.0\\times 10^{3})$.\n对于每一个案例，我们计算真实的相对能量范数误差，并打印一个单行列表 $[\\text{val}_1,\\text{val}_2,\\text{val}_3]$，其中每个值都以科学记数法格式化，小数点后精确到八位。由于解流形的一维特性，当使用单个降阶基向量时，每个值都应处于数值舍入误差的水平，在双精度下实际上为零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_1d_bar_K0_f0(N_elements: int, L: float = 1.0, A: float = 1.0):\n    \"\"\"\n    Assemble parameter-independent stiffness K0 and load f0 for a 1D bar of length L, area A.\n    Dirichlet at x=0 enforced by removing the first DOF; traction of magnitude 1 at x=L.\n    Returns:\n        K0 (ndarray): (n x n) stiffness with E=1, where n = N_elements.\n        f0 (ndarray): (n,) load with P=1, unit traction at right end.\n    \"\"\"\n    h = L / N_elements\n    n_free = N_elements  # after removing the fixed DOF at x=0\n    K0 = np.zeros((n_free, n_free), dtype=float)\n    # Element stiffness for E=1, A given\n    ke = (A / h) * np.array([[1.0, -1.0],\n                             [-1.0, 1.0]], dtype=float)\n    # Assemble global K0 (with first DOF removed)\n    # Global indices for full system would be 0..N_elements, with DOF 0 fixed.\n    # Free DOFs correspond to nodes 1..N_elements. Element connectivity:\n    # element e connects nodes e-1 and e in full system.\n    for e in range(N_elements):\n        # Full DOF indices\n        i_full = e      # left node index in full system\n        j_full = e + 1  # right node index in full system\n        # Map to free dof indices (subtract 1 because DOF 0 is fixed and removed)\n        # If index == 0, it's fixed and not assembled into free matrix.\n        dofs = []\n        if i_full != 0:\n            dofs.append(i_full - 1)\n        else:\n            dofs.append(None)\n        dofs.append(j_full - 1)  # j_full is never 0\n        # Assemble considering boundary removal\n        # Local dofs: 0 -> i_full, 1 -> j_full\n        for a in range(2):\n            for b in range(2):\n                ia = dofs[a]\n                ib = dofs[b]\n                val = ke[a, b]\n                if ia is not None and ib is not None:\n                    K0[ia, ib] += val\n                # Contributions involving fixed DOF are moved to RHS in general,\n                # but since u(0)=0, there is no RHS contribution here.\n    # Assemble f0 for unit traction P=1 at x=L: equivalent nodal force at last node only\n    f0 = np.zeros(n_free, dtype=float)\n    f0[-1] = 1.0 * A  # with A=1, this is 1.0\n    return K0, f0\n\ndef solve_truth(K0, f0, E, P):\n    \"\"\"\n    Solve the truth system K(E) u = f(P) with K(E) = E K0, f(P) = P f0.\n    \"\"\"\n    # K(E) = E * K0, f(P) = P * f0\n    # Solve E*K0 u = P f0 => K0 u = (P/E) f0 => u = (P/E) * K0^{-1} f0\n    rhs = (P / E) * f0\n    # Solve K0 u = rhs\n    u = np.linalg.solve(K0, rhs)\n    return u\n\ndef energy_norm(u, K0, E):\n    \"\"\"\n    Compute energy norm ||u||_E = sqrt(u^T K(E) u) with K(E) = E K0.\n    \"\"\"\n    return np.sqrt(E * np.dot(u, K0 @ u))\n\ndef rom_solve(V, K0, f0, E, P):\n    \"\"\"\n    Solve reduced system for given parameter mu=(E,P).\n    Returns reduced solution u_r and residual r.\n    \"\"\"\n    if V.size == 0:\n        n = K0.shape[0]\n        u_r = np.zeros(n, dtype=float)\n        # residual r = f - Ku_r = f since u_r=0\n        r = (P * f0).copy()\n        return u_r, r\n    # Reduced matrices\n    # K(E) = E K0, f = P f0\n    KV = E * (V.T @ K0 @ V)\n    fv = V.T @ (P * f0)\n    # Solve reduced system KV a = fv\n    a = np.linalg.solve(KV, fv)\n    u_r = V @ a\n    # Residual r = f - K u_r\n    r = (P * f0) - E * (K0 @ u_r)\n    return u_r, r\n\ndef gram_schmidt_K0(V, s, K0, tol=1e-14):\n    \"\"\"\n    Modified Gram-Schmidt orthonormalization of vector s against columns of V with respect to inner product <x,y> = x^T K0 y.\n    Returns normalized vector q. If the norm is too small, returns None.\n    \"\"\"\n    q = s.copy()\n    if V.size != 0:\n        for i in range(V.shape[1]):\n            vi = V[:, i]\n            alpha = vi @ (K0 @ q)\n            q = q - alpha * vi\n    norm = np.sqrt(q @ (K0 @ q))\n    if norm < tol:\n        return None\n    q = q / norm\n    return q\n\ndef build_reduced_basis(K0, f0, training_params, tol=1e-10, rmax=10):\n    \"\"\"\n    Greedy algorithm to build K0-orthonormal reduced basis V.\n    Returns V and a log of max relative error per iteration.\n    \"\"\"\n    V = np.zeros((K0.shape[0], 0), dtype=float)\n    max_rel_errors = []\n    while True:\n        rel_errors = []\n        # Precompute ROM solutions and residual estimators over training set\n        for (E, P) in training_params:\n            # ROM solution and residual\n            u_r, r = rom_solve(V, K0, f0, E, P)\n            # Auxiliary solve for estimator eta = sqrt(r^T K^{-1} r)\n            # K(E) = E K0 => solve E K0 z = r => K0 z = r / E\n            z = np.linalg.solve(K0, r / E)\n            eta = np.sqrt(np.dot(r, z))\n            # Compute denominator ||u_h||_E = sqrt(f^T u_h) via truth solve\n            u_h = solve_truth(K0, f0, E, P)\n            den = np.sqrt(np.dot(P * f0, u_h))\n            rel_eta = eta / den if den > 0 else 0.0\n            rel_errors.append((rel_eta, (E, P), u_h))\n        # Select max error parameter\n        rel_vals = [re[0] for re in rel_errors]\n        kmax = int(np.argmax(rel_vals))\n        max_rel = rel_vals[kmax]\n        max_rel_errors.append(max_rel)\n        if (max_rel < tol) or (V.shape[1] >= rmax):\n            break\n        # Augment basis with snapshot at maximizing parameter\n        u_h_star = rel_errors[kmax][2]\n        q = gram_schmidt_K0(V, u_h_star, K0)\n        if q is None:\n            break\n        V = np.column_stack((V, q))\n    return V, max_rel_errors\n\ndef main():\n    # Problem parameters\n    L = 1.0  # meters\n    A = 1.0  # m^2\n    N_elements = 200\n\n    # Assemble parameter-independent matrices\n    K0, f0 = assemble_1d_bar_K0_f0(N_elements, L=L, A=A)\n\n    # Training set for greedy\n    E_vals = [7.0e10, 1.0e11, 1.5e11, 2.1e11]\n    P_vals = [1.0e3, 5.0e4, 1.0e5]\n    training_params = [(E, P) for E in E_vals for P in P_vals]\n\n    # Build reduced basis\n    V, max_rel_errors = build_reduced_basis(K0, f0, training_params, tol=1e-10, rmax=10)\n\n    # Test cases\n    test_cases = [\n        (1.2e11, 7.5e4),  # Case 1\n        (7.0e10, 1.0e5),  # Case 2\n        (2.1e11, 1.0e3),  # Case 3\n    ]\n\n    # Evaluate true relative energy-norm error for each test case\n    results = []\n    for (E, P) in test_cases:\n        # Truth\n        u_h = solve_truth(K0, f0, E, P)\n        # ROM\n        u_r, r = rom_solve(V, K0, f0, E, P)\n        # True error in energy norm ||e||_E\n        e = u_h - u_r\n        num = energy_norm(e, K0, E)\n        den = energy_norm(u_h, K0, E)\n        rel_err = num / den if den > 0 else 0.0\n        # Format with scientific notation and exactly eight digits after decimal point\n        results.append(f\"{rel_err:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "2679813"}]}