{"hands_on_practices": [{"introduction": "在反问题中，一个常见的误区是认为只要测量数据足够精确，就能得到准确的参数估计。然而，如果用于反演分析的物理模型本身存在错误（即模型错配），即使是完美无瑕的数据也可能导致系统性的偏差。本实践通过一个一维杆的合成反问题，清晰地揭示了这一核心挑战。[@problem_id:2650379] 通过亲手操作，您将量化一个看似微小的模型假设错误——泊松比的错误指定——如何对杨氏模量的辨识结果造成显著且系统的影响，从而深刻理解模型假设验证在参数辨识中的关键作用。", "problem": "考虑一个一维辨识问题，对象为一根长度为 $L$、横截面积恒为 $A$ 的长棱柱杆，其杨氏模量 $E(x)$ 沿空间变化。该杆受到侧向约束，使得其变形处于单轴应变状态。在 $x=L$ 处，该杆受到恒定的轴向力 $P$ 作用，且满足 $u(0)=0$，其中 $u(x)$ 表示轴向位移。假设为线性弹性和小应变。您将使用一个已知的真实模量场 $E_{\\mathrm{true}}(x)$ 和真实的泊松比 $\\nu_{\\mathrm{true}}$ 来生成合成的（无噪声的）位移数据，然后在假设一个可能不正确的泊松比 $\\nu_{\\mathrm{assumed}}$ 的情况下，对 $E(x)$ 进行局部（逐点）逆向辨识。您的目标是计算恢复的模量场中完全由泊松比错误指定所引起的平均相对偏差。\n\n推导和算法必须仅从以下基本原理出发：\n- 一维线性动量平衡：在没有体力的情况下，$\\dfrac{d \\sigma_{xx}}{dx} = 0$，其中 $\\sigma_{xx}(x)$ 是轴向 Cauchy 应力。\n- 小应变运动学：$\\epsilon_{xx}(x) = \\dfrac{du}{dx}$，其中 $\\epsilon_{xx}(x)$ 是轴向应变。\n- 三维线性各向同性弹性（Hooke 定律）：$\\boldsymbol{\\sigma} = 2 \\mu \\boldsymbol{\\epsilon} + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I}$，其中 Lamé 参数为 $\\mu = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$，$E$ 为杨氏模量，$\\nu$ 为泊松比。\n- 单轴应变条件：$\\epsilon_{yy} = \\epsilon_{zz} = 0$。\n\n在这些原理的基础上，您必须构建一个合成正向模型以生成 $u(x)$，然后构建一个逆向估计器，从 $u(x)$、$P$ 和 $A$ 中恢复 $E(x)$，同时在逆向步骤中明确假设一个可能与 $\\nu_{\\mathrm{true}}$ 不同的值 $\\nu_{\\mathrm{assumed}}$。不应添加观测噪声；唯一的误差来源必须是逆向步骤中错误指定的泊松比。\n\n固定的物理和数值设置（请精确使用以下参数）：\n- 几何与载荷：$L = 1 \\ \\mathrm{m}$，$A = 1 \\times 10^{-4} \\ \\mathrm{m}^2$，$P = 3 \\times 10^{3} \\ \\mathrm{N}$。\n- 真实模量场：$E_{\\mathrm{true}}(x) = E_{0} \\left[ 1 + 0.4 \\sin\\left(2 \\pi \\dfrac{x}{L}\\right) + 0.2 \\cos\\left(4 \\pi \\dfrac{x}{L}\\right) \\right]$，其中 $E_{0} = 70 \\times 10^{9} \\ \\mathrm{Pa}$。\n- 离散化：在 $[0,L]$ 上使用 $N = 1001$ 个均匀间隔点。\n\n正向（合成）模型说明（推导并实现）：\n- 根据线性动量平衡，轴向应力在空间上是恒定的，等于 $\\sigma_{xx}(x) = \\dfrac{P}{A}$。\n- 在三维线性弹性定律中使用单轴应变条件，确定连接 $\\sigma_{xx}(x)$、$\\epsilon_{xx}(x)$、$E_{\\mathrm{true}}(x)$ 和 $\\nu_{\\mathrm{true}}$ 的关系式。使用该关系式计算 $\\epsilon_{xx}^{\\mathrm{true}}(x)$，然后通过积分 $\\epsilon_{xx}^{\\mathrm{true}}(x)$ 并结合 $u^{\\mathrm{true}}(0)=0$ 来计算 $u^{\\mathrm{true}}(x)$。\n\n逆向（恢复）模型说明（推导并实现）：\n- 给定 $u^{\\mathrm{true}}(x)$，通过离散差分数值近似计算 $\\epsilon_{xx}(x)$。\n- 使用相同的单轴应变关系，但采用 $\\nu_{\\mathrm{assumed}}$ 和已知的 $\\sigma_{xx} = \\dfrac{P}{A}$，逐点恢复一个场 $E_{\\mathrm{rec}}(x)$。\n\n需报告的偏差度量：\n- 计算逐点相对偏差 $b(x) = \\dfrac{E_{\\mathrm{rec}}(x) - E_{\\mathrm{true}}(x)}{E_{\\mathrm{true}}(x)}$，并报告每个测试案例的平均相对偏差 $\\overline{b} = \\dfrac{1}{N} \\sum_{i=1}^{N} b(x_i)$。\n- 将每个平均相对偏差表示为小数（不带百分号）。\n\n测试套件（按此顺序独立评估每个案例）：\n- 案例 1：$\\nu_{\\mathrm{true}} = 0.30$，$\\nu_{\\mathrm{assumed}} = 0.30$。\n- 案例 2：$\\nu_{\\mathrm{true}} = 0.30$，$\\nu_{\\mathrm{assumed}} = 0.25$。\n- 案例 3：$\\nu_{\\mathrm{true}} = 0.45$，$\\nu_{\\mathrm{assumed}} = 0.30$。\n- 案例 4：$\\nu_{\\mathrm{true}} = -0.20$，$\\nu_{\\mathrm{assumed}} = 0.20$。\n- 案例 5：$\\nu_{\\mathrm{true}} = 0.49$，$\\nu_{\\mathrm{assumed}} = 0.48$。\n\n您的程序必须：\n- 完全按照规定实现正向和逆向步骤。\n- 对所有物理量（米、牛顿、帕斯卡）使用 $\\mathrm{SI}$ 单位；报告的平均相对偏差是无量纲的，必须以小数形式输出。\n- 生成单行输出，其中包含上述五个案例的平均相对偏差值，以方括号括起来的逗号分隔列表形式，并按规定顺序排列。在打印前将每个值四舍五入到六位小数，例如 $[0.000000,0.123456,\\dots]$。", "solution": "分析从指定的基础连续介质力学原理开始。目标是量化由于泊松比 $\\nu$ 的错误指定而在逆向辨识的杨氏模量 $E(x)$ 中产生的偏差。\n\n首先，我们为指定的单轴应变状态建立一维本构关系。三维线性各向同性弹性定律由下式给出：\n$$\n\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\epsilon}\n$$\n其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\boldsymbol{\\epsilon}$ 是无穷小应变张量，$\\mathbf{I}$ 是二阶单位张量，$\\lambda$ 和 $\\mu$ 是 Lamé 参数。它们与杨氏模量 $E$ 和泊松比 $\\nu$ 的关系如下：\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\n问题陈述了单轴应变条件，这意味着应变张量的分量为 $\\epsilon_{xx}(x) \\neq 0$ 且 $\\epsilon_{yy} = \\epsilon_{zz} = \\epsilon_{xy} = \\epsilon_{yz} = \\epsilon_{zx} = 0$。因此，应变张量的迹为 $\\mathrm{tr}(\\boldsymbol{\\epsilon}) = \\epsilon_{xx}$。应力张量的轴向分量 $\\sigma_{xx}$ 于是为：\n$$\n\\sigma_{xx} = \\lambda \\epsilon_{xx} + 2 \\mu \\epsilon_{xx} = (\\lambda + 2\\mu) \\epsilon_{xx}\n$$\n项 $M = \\lambda + 2\\mu$ 是P波模量，它在单轴应变条件下充当等效的一维弹性模量。我们用 $E$ 和 $\\nu$ 表示 $M$：\n$$\nM = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)} + 2 \\left( \\frac{E}{2(1+\\nu)} \\right) = \\frac{E}{1+\\nu} \\left( \\frac{\\nu}{1-2\\nu} + 1 \\right) = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)}\n$$\n因此，一维本构定律为：\n$$\n\\sigma_{xx}(x) = M(x) \\epsilon_{xx}(x) = \\frac{E(x)(1-\\nu)}{(1+\\nu)(1-2\\nu)} \\epsilon_{xx}(x)\n$$\n请注意，$E$ 以及因此 $M$ 都是空间坐标 $x$ 的函数。\n\n在没有体力的情况下，一维线性动量平衡为 $\\frac{d\\sigma_{xx}}{dx} = 0$。这意味着轴向应力 $\\sigma_{xx}$ 沿杆的长度是恒定的。给定在端点 $x=L$ 处施加的力 $P$ 和恒定的横截面积 $A$，应力是均匀的：\n$$\n\\sigma_{xx}(x) = \\frac{P}{A}\n$$\n\n求解过程分两个阶段：一个用于生成合成数据的正向模型，以及一个用于辨识目标参数的逆向模型。\n\n1.  **正向模型：合成位移数据的生成**\n    我们使用真实的材料属性 $E_{\\mathrm{true}}(x)$ 和 $\\nu_{\\mathrm{true}}$ 来计算真实的应变场 $\\epsilon_{xx}^{\\mathrm{true}}(x)$。根据导出的本构定律：\n    $$\n    \\epsilon_{xx}^{\\mathrm{true}}(x) = \\frac{\\sigma_{xx}}{M_{\\mathrm{true}}(x)} = \\frac{P}{A} \\left( \\frac{(1+\\nu_{\\mathrm{true}})(1-2\\nu_{\\mathrm{true}})}{E_{\\mathrm{true}}(x)(1-\\nu_{\\mathrm{true}})} \\right)\n    $$\n    其中 $E_{\\mathrm{true}}(x) = E_{0} \\left[ 1 + 0.4 \\sin\\left(2 \\pi \\frac{x}{L}\\right) + 0.2 \\cos\\left(4 \\pi \\frac{x}{L}\\right) \\right]$。轴向位移 $u^{\\mathrm{true}}(x)$ 是通过对应变场进行积分，并考虑边界条件 $u(0)=0$ 得到的：\n    $$\n    u^{\\mathrm{true}}(x) = \\int_0^x \\epsilon_{xx}^{\\mathrm{true}}(s) \\, ds\n    $$\n    此积分在 $N=1001$ 个点的离散网格上进行数值计算。\n\n2.  **逆向模型：杨氏模量的恢复**\n    逆向过程使用合成位移数据 $u^{\\mathrm{true}}(x)$ 来恢复杨氏模量，但这是在假设一个可能不正确的泊松比 $\\nu_{\\mathrm{assumed}}$ 的前提下进行的。\n    首先，通过对位移场进行数值微分来估计应变场：$\\epsilon_{xx}^{\\mathrm{num}}(x) = \\frac{du^{\\mathrm{true}}}{dx}$。这是用有限差分近似来完成的。\n    接下来，我们重排本构方程以求解恢复的模量 $E_{\\mathrm{rec}}(x)$。该模型假设关系为 $\\sigma_{xx} = M_{\\mathrm{rec}}(x) \\epsilon_{xx}^{\\mathrm{num}}(x)$，其中 $M_{\\mathrm{rec}}(x)$ 基于 $E_{\\mathrm{rec}}(x)$ 和 $\\nu_{\\mathrm{assumed}}$：\n    $$\n    E_{\\mathrm{rec}}(x) = M_{\\mathrm{rec}}(x) \\frac{(1+\\nu_{\\mathrm{assumed}})(1-2\\nu_{\\mathrm{assumed}})}{1-\\nu_{\\mathrm{assumed}}}\n    $$\n    代入 $M_{\\mathrm{rec}}(x) = \\frac{\\sigma_{xx}}{\\epsilon_{xx}^{\\mathrm{num}}(x)}$，我们得到：\n    $$\n    E_{\\mathrm{rec}}(x) = \\frac{P}{A} \\frac{1}{\\epsilon_{xx}^{\\mathrm{num}}(x)} \\left( \\frac{(1+\\nu_{\\mathrm{assumed}})(1-2\\nu_{\\mathrm{assumed}})}{1-\\nu_{\\mathrm{assumed}}} \\right)\n    $$\n    这个方程允许对杨氏模量场进行逐点恢复。\n\n3.  **偏差分析**\n    逐点相对偏差定义为 $b(x) = \\frac{E_{\\mathrm{rec}}(x) - E_{\\mathrm{true}}(x)}{E_{\\mathrm{true}}(x)} = \\frac{E_{\\mathrm{rec}}(x)}{E_{\\mathrm{true}}(x)} - 1$。\n    如果我们忽略由数值微分引入的小误差，使得 $\\epsilon_{xx}^{\\mathrm{num}}(x) \\approx \\epsilon_{xx}^{\\mathrm{true}}(x)$，我们可以推导出偏差的解析表达式。将 $\\epsilon_{xx}^{\\mathrm{true}}(x)$ 的表达式代入 $E_{\\mathrm{rec}}(x)$ 的恢复方程中：\n    $$\n    E_{\\mathrm{rec}}(x) \\approx E_{\\mathrm{true}}(x) \\left[ \\frac{(1+\\nu_{\\mathrm{true}})(1-2\\nu_{\\mathrm{true}})}{1-\\nu_{\\mathrm{true}}} \\right]^{-1} \\left[ \\frac{(1+\\nu_{\\mathrm{assumed}})(1-2\\nu_{\\mathrm{assumed}})}{1-\\nu_{\\mathrm{assumed}}} \\right]\n    $$\n    因此，相对偏差近似为常数，并且与 $x$ 无关：\n    $$\n    b(x) \\approx \\frac{F(\\nu_{\\mathrm{assumed}})}{F(\\nu_{\\mathrm{true}})} - 1, \\quad \\text{其中 } F(\\nu) = \\frac{(1+\\nu)(1-2\\nu)}{1-\\nu}\n    $$\n    需要报告的量是平均相对偏差 $\\overline{b}$，它是通过对每个测试案例中所有 $N$ 个网格点上的 $b(x_i)$ 进行平均计算得出的。由于解析偏差近乎为常数，平均值将非常接近该理论预测，仅存在由数值积分和微分误差引起的微小偏差。\n\n最终的算法是通过对测试套件中的每一对 $(\\nu_{\\mathrm{true}}, \\nu_{\\mathrm{assumed}})$ 执行这些步骤来实现的。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Computes the mean relative bias in recovered Young's modulus due to\n    Poisson's ratio misspecification in a 1D inverse problem.\n    \"\"\"\n    # Fixed physical and numerical settings\n    L = 1.0  # m\n    A = 1.0e-4  # m^2\n    P = 3.0e3  # N\n    E0 = 70.0e9  # Pa\n    N = 1001  # number of points\n\n    # Discretization\n    x = np.linspace(0, L, N)\n    \n    # Ground-truth modulus field\n    E_true = E0 * (1.0 + 0.4 * np.sin(2.0 * np.pi * x / L) + 0.2 * np.cos(4.0 * np.pi * x / L))\n    \n    # Constant axial stress\n    sigma_xx = P / A\n\n    # Test cases: (nu_true, nu_assumed)\n    test_cases = [\n        (0.30, 0.30),\n        (0.30, 0.25),\n        (0.45, 0.30),\n        (-0.20, 0.20),\n        (0.49, 0.48),\n    ]\n\n    results = []\n\n    def poisson_factor_F(nu):\n        \"\"\"\n        Calculates the factor F(nu) that relates the P-wave modulus M to\n        Young's modulus E as M = E / F(nu).\n        F(nu) = (1-nu) / ((1+nu)*(1-2*nu))\n        The problem derivation uses the inverse of this for convenience,\n        let's call it G(nu) for implementation.\n        G(nu) = (1+nu)*(1-2*nu) / (1-nu)\n        \"\"\"\n        if nu == 1.0 or nu == 0.5 or nu == -1.0:\n            return np.nan # Prevent division by zero / instability\n        return (1.0 + nu) * (1.0 - 2.0 * nu) / (1.0 - nu)\n\n    for nu_true, nu_assumed in test_cases:\n        # --- FORWARD MODEL ---\n        # 1. Compute true strain field\n        # The 1D constitutive law for uniaxial strain is sigma_xx = M * eps_xx,\n        # where M = E * (1-nu) / ((1+nu)*(1-2*nu)).\n        # Rearranging for strain: eps_xx = sigma_xx * ((1+nu)*(1-2*nu)) / (E * (1-nu))\n        factor_for_strain_calc = poisson_factor_F(nu_true)\n        eps_xx_true = (sigma_xx / E_true) * factor_for_strain_calc\n        \n        # 2. Compute true displacement by integrating strain\n        # u(x) = integral from 0 to x of eps(s) ds, with u(0)=0.\n        u_true = cumulative_trapezoid(eps_xx_true, x, initial=0.0)\n        \n        # --- INVERSE MODEL ---\n        # 1. Numerically differentiate displacement to get strain\n        # eps_num(x) = du/dx\n        eps_xx_num = np.gradient(u_true, x)\n        \n        # 2. Recover Young's modulus E_rec\n        # From the constitutive law, E_rec = sigma_xx / eps_xx_num * factor_for_strain_calc(nu_assumed)\n        factor_for_E_rec = poisson_factor_F(nu_assumed)\n        \n        # To avoid potential division by zero if eps_xx_num is ever zero\n        # (not expected here, but good practice).\n        # We know eps_xx is strictly positive for P>0.\n        E_rec = (sigma_xx / eps_xx_num) * factor_for_E_rec\n        \n        # --- BIAS CALCULATION ---\n        # Calculate pointwise relative bias\n        relative_bias = (E_rec - E_true) / E_true\n        \n        # Calculate mean relative bias\n        mean_relative_bias = np.mean(relative_bias)\n        \n        results.append(mean_relative_bias)\n        \n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2650379"}, {"introduction": "真实的实验数据很少遵循理想的高斯分布，常常受到异常值（outliers）的污染，这些异常值可能源于传感器故障、记录错误或短暂的实验扰动。传统的最小二乘法对此类异常值极为敏感，单个错误的测量点就可能严重扭曲辨识结果。本实践将引导您超越标准的最小二乘法，探索和实现更强大的稳健估计方法。[@problem_id:2650354] 您将通过迭代重加权最小二乘（IRLS）算法，实现基于Huber损失和Student-t损失的参数估计器，并直观地比较它们与最小二乘法在面对含有异常数据时的表现，从而掌握处理不完美实验数据的实用技能。", "problem": "考虑一根长度为 $L$、横截面积为 $A$ 的一维轴向受载等截面杆，其材料为线性弹性、均匀、各向同性的，杨氏模量为 $E$。在施加的轴向力 $F$ 作用下，轴向应力为 $\\sigma = F/A$，轴向应变为 $\\varepsilon = \\sigma/E$，杆端缩短（轴向位移）为 $u = \\varepsilon L$。结合这些定义，得到正向模型 $u = FL/(AE)$。假设我们试图在存在测量噪声和可能的离群值的情况下，从多组载荷-位移测量值 $\\{(F_i, u_i^{\\mathrm{obs}})\\}_{i=1}^N$ 中识别 $E$。为了得到一个关于未知量的线性反问题，定义柔度 $p = 1/E$，从而每个数据点的正向模型变为 $u_i = c_i p$，其中 $c_i = F_i L / A$。\n\n该反问题是通过最小化残差 $r_i(p) = u_i^{\\mathrm{obs}} - c_i p$ 上的数据失配损失之和，从数据 $\\{(c_i, u_i^{\\mathrm{obs}})\\}_{i=1}^N$ 中估计 $E$（等价于 $p$）。从线性弹性和最大似然估计的原理出发，构建以下三种估计器：\n- 一个高斯（最小二乘）估计器，它最小化 $\\sum_{i=1}^N \\rho_{\\mathrm{G}}(r_i)$，其中 $\\rho_{\\mathrm{G}}(r) = \\tfrac{1}{2}(r/s)^2$（$s$ 为任意正常数标度）。\n- 一个 Huber 估计器，它最小化 $\\sum_{i=1}^N \\rho_{\\mathrm{H}}(r_i)$，其中 $\\rho_{\\mathrm{H}}(r)$ 是阈值为 $\\delta$ 的 Huber 损失。使用一个稳健的、数据驱动的阈值，具体为 $\\delta = 1.345\\, s$，其中 $s$ 是在每次迭代中估计的稳健残差标度，计算方式为 $s = 1.4826 \\, \\mathrm{MAD}(r)$，$\\mathrm{MAD}(r) = \\mathrm{median}_i(|r_i - \\mathrm{median}_j(r_j)|)$。如有需要，可使用一个严格为正的数值下限以避免除以零。\n- 一个 Student-t 估计器，它最小化 $\\sum_{i=1}^N \\rho_{\\mathrm{t}}(r_i)$，其中 $\\rho_{\\mathrm{t}}(r) = \\tfrac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\dfrac{r^2}{\\nu s^2}\\right)$，$\\nu$ 为自由度，稳健标度 $s$ 的计算同上。\n\n您的任务是，从第一性原理出发，推导高斯情况下的正规方程以及 Huber 和 Student-t 情况的一阶最优性条件，并实现一个算法，该算法能够：\n- 以闭式解形式计算高斯估计值。\n- 使用从影响函数 $\\psi(r) = \\partial \\rho(r)/\\partial r$ 推导出的迭代重加权最小二乘（IRLS）程序求解 Huber 和 Student-t 情况。使用 $w_i = \\psi(r_i)/r_i$ 作为迭代权重，并在每次迭代中通过加权最小二乘法更新 $p$。在每次迭代中重新计算稳健标度 $s$，对于 Huber 损失，还需重新计算阈值 $\\delta$。对 Student-t 损失使用固定的 $\\nu$。迭代直至 $p$ 的变化小于用户选择的容差或达到最大迭代次数。在优化过程中强制施加物理容许性约束 $E > 0$（等价于 $p > 0$）。\n\n$E$ 的最终答案以吉帕斯卡（GPa）为单位表示，并四舍五入到三位小数。\n\n测试套件。使用以下物理上一致的参数和观测数据。在所有案例中，取 $L = 2$ m，$A = 10^{-4}$ m$^2$，真实模量 $E_{\\mathrm{true}} = 210$ GPa，该值仅用于生成无噪声的正向响应，对于反演求解器是未知的。\n\n- 案例 $\\#1$（行为良好的数据）：$N = 4$，载荷 $\\{F_i\\} = [5000, 10000, 15000, 20000]$ N。对应的无噪声位移为 $[FL/(AE_{\\mathrm{true}})] = [c_i/E_{\\mathrm{true}}] = [10^8, 2\\cdot 10^8, 3\\cdot 10^8, 4\\cdot 10^8]/(210\\cdot 10^9)$ m。观测位移包含小噪声：$u^{\\mathrm{obs}} = [0.0004763904761904762, 0.0009522809523809524, 0.0014287214285714286, 0.0019047119047619049]$ m。\n- 案例 $\\#2$（两个大的离群值）：载荷与案例 $\\#1$ 相同。观测位移：$u^{\\mathrm{obs}} = [0.0004763904761904762, 0.0014522809523809524, 0.0008287214285714286, 0.0019047119047619049]$ m。\n- 案例 $\\#3$（接近零的载荷和一个严重离群值）：$N = 4$，载荷 $\\{F_i\\} = [0, 2000, 4000, 30000]$ N。观测位移：$u^{\\mathrm{obs}} = [0.0000001, 0.0001906761904761905, 0.000380852380952381, 0.001857142857142857]$ m。\n\n对于 Student-t 损失，所有案例均使用 $\\nu = 3$。对于 Huber，按照规定在每次迭代中根据稳健标度 $s$ 计算 $\\delta$。对于所有三种案例，您可以使用高斯（最小二乘）估计值来初始化迭代方法。使用任何合理的数值容差和迭代上限，以确保对这些数据收敛。\n\n最终输出格式。您的程序应生成单行输出，按顺序包含案例 $\\#1$ 到 $\\#3$ 的结果。每个案例的结果是在高斯、Huber 和 Student-t 损失下估计出的模量（以 GPa 为单位）的三元组，四舍五入到三位小数，并聚合为单个列表的列表，例如：\n- 输出形状：$\\big[[E_{\\mathrm{G},1}, E_{\\mathrm{H},1}, E_{\\mathrm{t},1}], [E_{\\mathrm{G},2}, E_{\\mathrm{H},2}, E_{\\mathrm{t},2}], [E_{\\mathrm{G},3}, E_{\\mathrm{H},3}, E_{\\mathrm{t},3}]\\big]$。\n- 单位说明：所有条目均以 GPa 表示。\n- 四舍五入说明：将每个条目四舍五入到恰好三位小数。\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[[210.000,210.000,210.000],[...],...]\"）。", "solution": "**求解推导**\n\n目标是找到使总损失 $J(p) = \\sum_{i=1}^N \\rho(r_i(p))$ 最小化的柔度 $p$，其中 $r_i(p) = u_i^{\\mathrm{obs}} - c_i p$。最小值的的一阶必要条件是目标函数对未知参数 $p$ 的导数必须为零：\n$$\n\\frac{dJ}{dp} = \\sum_{i=1}^N \\frac{d\\rho(r_i)}{dr_i} \\frac{dr_i}{dp} = 0\n$$\n残差的导数是 $\\frac{dr_i}{dp} = -c_i$。损失函数 $\\rho$ 对其参数的导数是影响函数 $\\psi(r) = d\\rho/dr$。因此，最优性条件为：\n$$\n\\sum_{i=1}^N \\psi(r_i) (-c_i) = 0 \\quad \\implies \\quad \\sum_{i=1}^N c_i \\psi(r_i(p)) = 0\n$$\n\n**1. 高斯（最小二乘）估计器**\n对于高斯情况，损失为 $\\rho_{\\mathrm{G}}(r) = \\frac{1}{2s^2} r^2$。对于最小化问题，常数因子 $\\frac{1}{2s^2}$ 可以忽略，因此我们实际上是最小化 $J_{LS}(p) = \\sum_{i=1}^N r_i^2$。影响函数是 $\\psi_{\\mathrm{G}}(r) = r$。\n代入最优性条件：\n$$\n\\sum_{i=1}^N c_i r_i = \\sum_{i=1}^N c_i (u_i^{\\mathrm{obs}} - c_i p) = 0\n$$\n对 $p$ 进行整理，得到正规方程：\n$$\n\\left(\\sum_{i=1}^N c_i^2\\right) p = \\sum_{i=1}^N c_i u_i^{\\mathrm{obs}}\n$$\n这给出了最小二乘估计 $p_{\\mathrm{LS}}$ 的闭式解：\n$$\np_{\\mathrm{LS}} = \\frac{\\sum_{i=1}^N c_i u_i^{\\mathrm{obs}}}{\\sum_{i=1}^N c_i^2} = \\frac{\\mathbf{c}^T \\mathbf{u}^{\\mathrm{obs}}}{\\mathbf{c}^T \\mathbf{c}}\n$$\n其中 $\\mathbf{c} = [c_1, \\dots, c_N]^T$ 且 $\\mathbf{u}^{\\mathrm{obs}} = [u_1^{\\mathrm{obs}}, \\dots, u_N^{\\mathrm{obs}}]^T$。\n\n**2. 用于稳健估计器的迭代重加权最小二乘（IRLS）**\n对于 Huber 和 Student-t 估计器，最优性条件 $\\sum_i c_i \\psi(r_i(p)) = 0$ 是关于 $p$ 的非线性方程，需要迭代求解。IRLS 算法通过定义一个权重函数 $w(r) = \\psi(r)/r$ 来推导。然后，最优性条件可以重写为：\n$$\n\\sum_{i=1}^N c_i w(r_i) r_i = \\sum_{i=1}^N c_i w(r_i) (u_i^{\\mathrm{obs}} - c_i p) = 0\n$$\n如果权重 $w_i$ 保持不变，此方程对 $p$ 是线性的。这启发了一个迭代过程。在第 $k+1$ 次迭代时，给定估计值 $p^{(k)}$，我们计算残差 $r_i^{(k)}$，然后计算权重 $w_i^{(k)} = w(r_i^{(k)})$，并解出新的估计值 $p^{(k+1)}$：\n$$\n\\left(\\sum_{i=1}^N w_i^{(k)} c_i^2\\right) p^{(k+1)} = \\sum_{i=1}^N w_i^{(k)} c_i u_i^{\\mathrm{obs}}\n$$\n$$\np^{(k+1)} = \\frac{\\sum_{i=1}^N w_i^{(k)} c_i u_i^{\\mathrm{obs}}}{\\sum_{i=1}^N w_i^{(k)} c_i^2} = \\frac{\\mathbf{c}^T \\mathbf{W}^{(k)} \\mathbf{u}^{\\mathrm{obs}}}{\\mathbf{c}^T \\mathbf{W}^{(k)} \\mathbf{c}}\n$$\n其中 $\\mathbf{W}^{(k)}$ 是对角元素为 $w_i^{(k)}$ 的对角矩阵。迭代持续进行直到收敛，即 $|p^{(k+1)} - p^{(k)}|$ 小于预设的容差。\n\n**2.1. Huber 估计器**\nHuber 影响函数为 $\\psi_{\\mathrm{H}}(r) = \\mathrm{min}(|r|, \\delta) \\, \\mathrm{sgn}(r)$。因此，权重函数为：\n$$\nw_{\\mathrm{H}}(r) = \\frac{\\psi_{\\mathrm{H}}(r)}{r} = \\begin{cases} 1 & |r| \\le \\delta \\\\ \\delta/|r| & |r| > \\delta \\end{cases} = \\mathrm{min}(1, \\delta/|r|)\n$$\n在每次 IRLS 迭代中，根据当前残差 $\\mathbf{r}^{(k)}$ 计算稳健标度 $s^{(k)}$，并将阈值更新为 $\\delta^{(k)} = 1.345 s^{(k)}$。这些值用于计算权重 $w_i^{(k)}$。\n\n**2.2. Student-t 估计器**\n损失函数为 $\\rho_{\\mathrm{t}}(r) = \\frac{\\nu+1}{2}\\log(1 + \\frac{r^2}{\\nu s^2})$。其影响函数为：\n$$\n\\psi_{\\mathrm{t}}(r) = \\frac{d\\rho_t}{dr} = \\frac{\\nu+1}{2} \\cdot \\frac{1}{1 + r^2/(\\nu s^2)} \\cdot \\frac{2r}{\\nu s^2} = \\frac{(\\nu+1)r}{\\nu s^2 + r^2}\n$$\n相应的权重函数为：\n$$\nw_{\\mathrm{t}}(r) = \\frac{\\psi_{\\mathrm{t}}(r)}{r} = \\frac{\\nu+1}{\\nu s^2 + r^2}\n$$\n在每次 IRLS 迭代中，根据当前残差 $\\mathbf{r}^{(k)}$ 计算稳健标度 $s^{(k)}$，然后用它来计算权重 $w_i^{(k)}$。\n\n**3. 物理容许性**\n物理约束 $E > 0$ 意味着 $p > 0$。在 IRLS 更新中，分母 $\\sum w_i c_i^2$ 保证为正，因为对于 Huber 和 Student-t 估计器，$w_i > 0$ 且 $c_i^2 \\ge 0$。对于物理上合理的数据，其中施加的力 $F_i$（以及因此的 $c_i$）和测量的位移 $u_i^{\\mathrm{obs}}$ 具有相同的符号，期望分子 $\\sum w_i c_i u_i^{\\mathrm{obs}}$ 为正。如果数值更新产生 $p \\le 0$，则通过将其限制在一个小的正值 $\\epsilon_p > 0$，将其投影到容许集上。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Young's modulus E using Gaussian, Huber, and Student's-t estimators\n    for three different data cases.\n    \"\"\"\n    # Common physical parameters\n    L = 2.0  # m\n    A = 1.0e-4  # m^2\n\n    # Test suite containing three cases\n    test_cases = [\n        {\n            \"F\": np.array([5000, 10000, 15000, 20000]),  # N\n            \"u_obs\": np.array([0.0004763904761904762, 0.0009522809523809524, \n                               0.0014287214285714286, 0.0019047119047619049])  # m\n        },\n        {\n            \"F\": np.array([5000, 10000, 15000, 20000]),  # N\n            \"u_obs\": np.array([0.0004763904761904762, 0.0014522809523809524, \n                               0.0008287214285714286, 0.0019047119047619049])  # m\n        },\n        {\n            \"F\": np.array([0, 2000, 4000, 30000]),  # N\n            \"u_obs\": np.array([0.0000001, 0.0001906761904761905, \n                               0.000380852380952381, 0.001857142857142857])  # m\n        }\n    ]\n\n    # IRLS algorithm parameters\n    nu = 3.0  # Degrees of freedom for Student's-t loss\n    tol = 1.0e-12  # Convergence tolerance for compliance p\n    max_iter = 100  # Maximum number of iterations\n    s_floor = 1.0e-12  # Numerical floor for robust scale s\n    p_floor = 1.0e-15  # Numerical floor for compliance p (to enforce p > 0)\n\n    all_results = []\n\n    for case in test_cases:\n        F = case[\"F\"]\n        u_obs = case[\"u_obs\"]\n        c = F * L / A  # Model coefficients\n\n        # --- Gaussian (Least-Squares) Estimator ---\n        # Closed-form solution: p_ls = (c^T u_obs) / (c^T c)\n        p_ls_numerator = np.dot(c, u_obs)\n        p_ls_denominator = np.dot(c, c)\n        p_ls = p_ls_numerator / p_ls_denominator if p_ls_denominator > 0 else 0.0\n        \n        # Ensure physical admissibility\n        p_ls = max(p_ls, p_floor)\n        E_g_gpa = (1.0 / p_ls) / 1.0e9\n\n        case_results = [E_g_gpa]\n\n        # --- Huber Estimator (IRLS) ---\n        p_h = p_ls  # Initialize with LS estimate\n        for _ in range(max_iter):\n            r = u_obs - c * p_h\n            \n            # Robust scale estimation (MAD)\n            med_r = np.median(r)\n            mad = np.median(np.abs(r - med_r))\n            s = max(1.4826 * mad, s_floor)\n            delta = 1.345 * s\n\n            # Calculate weights\n            abs_r = np.abs(r)\n            # Handle r_i -> 0 case by setting weight to 1\n            weights_h = np.ones_like(r)\n            nonzero_r_mask = abs_r > 1e-12\n            weights_h[nonzero_r_mask] = np.minimum(1.0, delta / abs_r[nonzero_r_mask])\n            \n            # Weighted least squares update\n            numerator = np.dot(c, weights_h * u_obs)\n            denominator = np.dot(c, weights_h * c)\n            \n            p_h_new = numerator / denominator if denominator > 0 else p_h\n            p_h_new = max(p_h_new, p_floor)  # Enforce positivity\n\n            if np.abs(p_h_new - p_h) < tol:\n                p_h = p_h_new\n                break\n            \n            p_h = p_h_new\n        \n        E_h_gpa = (1.0 / p_h) / 1.0e9\n        case_results.append(E_h_gpa)\n        \n        # --- Student's-t Estimator (IRLS) ---\n        p_t = p_ls  # Initialize with LS estimate\n        for _ in range(max_iter):\n            r = u_obs - c * p_t\n\n            # Robust scale estimation (MAD)\n            med_r = np.median(r)\n            mad = np.median(np.abs(r - med_r))\n            s = max(1.4826 * mad, s_floor)\n            \n            # Calculate weights\n            weights_t = (nu + 1.0) / (nu * s**2 + r**2)\n            \n            # Weighted least squares update\n            numerator = np.dot(c, weights_t * u_obs)\n            denominator = np.dot(c, weights_t * c)\n\n            p_t_new = numerator / denominator if denominator > 0 else p_t\n            p_t_new = max(p_t_new, p_floor) # Enforce positivity\n\n            if np.abs(p_t_new - p_t) < tol:\n                p_t = p_t_new\n                break\n            \n            p_t = p_t_new\n\n        E_t_gpa = (1.0 / p_t) / 1.0e9\n        case_results.append(E_t_gpa)\n        \n        all_results.append(case_results)\n\n    # Format the final output string according to the problem specification\n    final_output_parts = []\n    for case_res_list in all_results:\n        formatted_list = [f\"{val:.3f}\" for val in case_res_list]\n        final_output_parts.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(final_output_parts)}]\")\n\nsolve()\n```", "id": "2650354"}, {"introduction": "在解决了模型误差和数据污染问题之后，参数辨识的下一个高级主题是“我们应该进行什么样的实验来最有效地确定未知参数？”。不同的实验方案为辨识同一组参数所提供的信息量可能存在天壤之别。本实践引入了贝叶斯实验设计的思想，通过量化参数后验不确定性来评估和比较不同实验设计的“价值”。[@problem_id:2650344] 您将针对一个经典的Mooney-Rivlin超弹性模型，分析单轴拉伸、双轴拉伸和剪切测试在辨识材料参数$C_{10}$和$C_{01}$时的优劣。通过计算后验协方差矩阵的迹，您将学会如何从被动的数据分析者转变为主动的实验策略设计者，这是从反问题求解到科学研究方法论的关键一步。", "problem": "考虑一个不可压缩、各向同性的超弹性固体，其模型由 Mooney–Rivlin 储存能密度描述，表达式为 $W = C_{10} (I_{1} - 3) + C_{01} (I_{2} - 3)$，其中 $C_{10}$ 和 $C_{01}$ 是待辨识的未知材料参数，$I_{1}$ 和 $I_{2}$ 分别是左 Cauchy–Green 张量 $\\boldsymbol{B}$ 的第一和第二不变量。对于储存能为 $W(I_{1}, I_{2})$ 的不可压缩各向同性超弹性材料，其 Cauchy 应力由标准公式给出：$\\boldsymbol{\\sigma} = -p \\boldsymbol{I} + 2 \\frac{\\partial W}{\\partial I_1} \\boldsymbol{B} - 2 \\frac{\\partial W}{\\partial I_2} \\boldsymbol{B}^{-1}$，其中 $p$ 是一个施加不可压缩性约束的拉格朗日乘子。在三种典型的试验类型中，主拉伸比或变形梯度规定如下：(i) 单轴拉伸，主拉伸比为 $\\lambda_{1} = \\lambda$, $\\lambda_{2} = \\lambda_{3} = \\lambda^{-1/2}$；(ii) 等双轴拉伸，主拉伸比为 $\\lambda_{1} = \\lambda_{2} = \\lambda$, $\\lambda_{3} = \\lambda^{-2}$；(iii) 简单剪切，变形梯度为 $\\boldsymbol{F} = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$。测量的 Cauchy 应力分量（单轴拉伸的轴向应力、等双轴拉伸的面内应力以及简单剪切的剪切分量 $\\sigma_{12}$）可以表示为 $(C_{10}, C_{01})$ 和所施加的应变度量 $\\lambda$ 或 $\\gamma$ 的确定性函数，这些函数由本构律、不可压缩性约束和无牵引力的侧向边界条件推导得出。假设在每个测量的应力分量上存在附加的、独立的、同分布的零均值高斯测量噪声，其标准差已知，为 $\\sigma_{\\text{noise}}$ 兆帕 (MPa)。假设参数向量 $\\boldsymbol{\\theta} = [C_{10}, C_{01}]^{\\mathsf{T}}$ 服从零均值高斯先验分布，其先验协方差为 $\\boldsymbol{\\Sigma}_{0} = \\operatorname{diag}(0.25, 0.25)$，单位为 $(\\text{MPa})^{2}$。\n\n使用一个关于设计的局部贝叶斯线性模型（该模型对于这些试验是精确的，因为测量的应力是关于 $C_{10}$ 和 $C_{01}$ 的仿射函数），在具有雅可比矩阵 $\\boldsymbol{J}$（其中 J 的行是每次测量中测量的应力对参数的灵敏度）和噪声方差 $\\sigma_{\\text{noise}}^{2}$ 的设计下，Fisher 信息矩阵为 $\\boldsymbol{J}^{\\mathsf{T}} \\boldsymbol{J} / \\sigma_{\\text{noise}}^{2}$，近似后验协方差为 $\\boldsymbol{\\Sigma}_{\\text{post}} = \\left(\\boldsymbol{\\Sigma}_{0}^{-1} + \\boldsymbol{J}^{\\mathsf{T}} \\boldsymbol{J} / \\sigma_{\\text{noise}}^{2}\\right)^{-1}$。将设计的期望后验方差定义为 $\\operatorname{tr}(\\boldsymbol{\\Sigma}_{\\text{post}})$，单位为 $(\\text{MPa})^{2}$。\n\n您的任务是实现一个程序，该程序针对下方测试套件中的每个试验设计，使用在指定试验运动学下 Mooney–Rivlin 模型的相应应力-应变关系构建雅可比矩阵 $\\boldsymbol{J}$，计算 $\\boldsymbol{\\Sigma}_{\\text{post}}$，并返回 $\\operatorname{tr}(\\boldsymbol{\\Sigma}_{\\text{post}})$。\n\n用作推导基础的基本定律和核心定义：\n- Mooney–Rivlin 储存能的定义：$W = C_{10} (I_{1} - 3) + C_{01} (I_{2} - 3)$。\n- 不可压缩超弹性材料的 Cauchy 应力：$\\boldsymbol{\\sigma} = -p \\boldsymbol{I} + 2 \\frac{\\partial W}{\\partial I_1} \\boldsymbol{B} - 2 \\frac{\\partial W}{\\partial I_2} \\boldsymbol{B}^{-1}$，其中 $\\boldsymbol{B} = \\boldsymbol{F} \\boldsymbol{F}^{\\mathsf{T}}$。\n- 对于单轴和等双轴拉伸，无牵引力的横向应力决定了压力 $p$。\n- 对于简单剪切，剪切应力分量 $\\sigma_{12}$ 与 $p$ 无关。\n\n精确定义用于每个试验的应力分量：\n- 单轴拉伸：测量的轴向 Cauchy 应力 $\\sigma_{\\text{uni}}(\\lambda; C_{10}, C_{01})$，作为拉伸比 $\\lambda$ 的函数。\n- 等双轴拉伸：测量的面内 Cauchy 应力 $\\sigma_{\\text{biax}}(\\lambda; C_{10}, C_{01})$，作为拉伸比 $\\lambda$ 的函数。\n- 简单剪切：测量的剪切 Cauchy 应力 $\\sigma_{12}(\\gamma; C_{10}, C_{01})$，作为剪切量 $\\gamma$ 的函数。\n\n您必须推导出计算雅可比矩阵行向量 $\\partial \\sigma / \\partial C_{10}$ 和 $\\partial \\sigma / \\partial C_{01}$ 所需的显式形式。\n\n测试套件：\n- 案例 $1$（单轴拉伸，中等范围和噪声）：使用 $n = 11$ 个均匀分布在 $\\lambda \\in [1.0, 1.6]$ 范围内的拉伸比，$\\sigma_{\\text{noise}} = 0.1$ MPa。\n- 案例 $2$（等双轴拉伸，中等范围和噪声）：使用 $n = 11$ 个均匀分布在 $\\lambda \\in [1.0, 1.3]$ 范围内的拉伸比，$\\sigma_{\\text{noise}} = 0.1$ MPa。\n- 案例 $3$（简单剪切，中等范围和噪声）：使用 $n = 11$ 个均匀分布在 $\\gamma \\in [0.0, 0.8]$ 范围内的剪切量，$\\sigma_{\\text{noise}} = 0.1$ MPa。\n- 案例 $4$（单轴拉伸，窄范围但低噪声）：使用 $n = 5$ 个均匀分布在 $\\lambda \\in [1.0, 1.2]$ 范围内的拉伸比，$\\sigma_{\\text{noise}} = 0.02$ MPa。\n- 案例 $5$（混合设计）：结合 $n_{\\text{uni}} = 6$ 个均匀分布在 $\\lambda \\in [1.0, 1.6]$ 内的单轴拉伸比和 $n_{\\text{biax}} = 6$ 个均匀分布在 $\\lambda \\in [1.0, 1.3]$ 内的等双轴拉伸比，所有测量的 $\\sigma_{\\text{noise}} = 0.1$ MPa。在计算 $\\boldsymbol{\\Sigma}_{\\text{post}}$ 之前，将所有测量值堆叠成一个单一的雅可比矩阵。\n\n所有拉伸比 $\\lambda$ 和剪切量 $\\gamma$ 都是无量纲的，所有应力都以兆帕 (MPa) 为单位。先验协方差 $\\boldsymbol{\\Sigma}_{0}$ 的单位是 $(\\text{MPa})^{2}$。对于每个案例，计算标量 $\\operatorname{tr}(\\boldsymbol{\\Sigma}_{\\text{post}})$，单位为 $(\\text{MPa})^{2}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为案例 $1$ 到 $5$（例如 $[v_{1},v_{2},v_{3},v_{4},v_{5}]$），其中每个 $v_{i}$ 是 $\\operatorname{tr}(\\boldsymbol{\\Sigma}_{\\text{post}})$ 的值，单位为 $(\\text{MPa})^{2}$，四舍五入到六位小数。", "solution": "目标是计算 Mooney-Rivlin 超弹性固体材料参数 $\\boldsymbol{\\theta} = [C_{10}, C_{01}]^{\\mathsf{T}}$ 在五种不同试验设计下的期望后验方差，其定义为 $\\operatorname{tr}(\\boldsymbol{\\Sigma}_{\\text{post}})$。后验协方差由贝叶斯线性模型的公式给出：\n$$\n\\boldsymbol{\\Sigma}_{\\text{post}} = \\left(\\boldsymbol{\\Sigma}_{0}^{-1} + \\frac{\\boldsymbol{J}^{\\mathsf{T}} \\boldsymbol{J}}{\\sigma_{\\text{noise}}^{2}}\\right)^{-1}\n$$\n此处，$\\boldsymbol{\\Sigma}_{0} = \\operatorname{diag}(0.25, 0.25) \\, (\\text{MPa})^2$ 是先验协方差，因此其逆矩阵为 $\\boldsymbol{\\Sigma}_{0}^{-1} = \\operatorname{diag}(4, 4) \\, (\\text{MPa})^{-2}$。$\\sigma_{\\text{noise}}$ 项是测量噪声的标准差，而 $\\boldsymbol{J}$ 是雅可比矩阵，其行是测量的应力分量相对于参数 $C_{10}$ 和 $C_{01}$ 的灵敏度。\n\n核心任务是推导雅可比矩阵各行的解析表达式，这需要为三种试验构型中的每一种推导测量应力。Mooney-Rivlin 储存能函数为 $W = C_{10}(I_1 - 3) + C_{01}(I_2 - 3)$。应力计算所需的偏导数为：\n$$\n\\frac{\\partial W}{\\partial I_1} = C_{10}, \\quad \\frac{\\partial W}{\\partial I_2} = C_{01}\n$$\n对于不可压缩材料，Cauchy 应力张量为 $\\boldsymbol{\\sigma} = -p\\boldsymbol{I} + 2 \\frac{\\partial W}{\\partial I_1} \\boldsymbol{B} - 2 \\frac{\\partial W}{\\partial I_2} \\boldsymbol{B}^{-1}$，其中 $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}}$ 是左 Cauchy-Green 变形张量，$p$ 是静水压力。对于指定的模型，此表达式变为：\n$$\n\\boldsymbol{\\sigma} = -p\\boldsymbol{I} + 2C_{10}\\boldsymbol{B} - 2C_{01}\\boldsymbol{B}^{-1}\n$$\n此表达式对于参数 $C_{10}$ 和 $C_{01}$ 是线性的。因此，每次试验中测量的应力 $\\sigma_{\\text{meas}}$ 将呈现 $\\sigma_{\\text{meas}} = f(\\text{strain})C_{10} + g(\\text{strain})C_{01}$ 的形式。因此，构成雅可比矩阵 $\\boldsymbol{J}$ 的各行的灵敏度为 $[\\frac{\\partial \\sigma_{\\text{meas}}}{\\partial C_{10}}, \\frac{\\partial \\sigma_{\\text{meas}}}{\\partial C_{01}}] = [f(\\text{strain}), g(\\text{strain})]$。\n\n**1. 单轴拉伸**\n主拉伸比为 $\\lambda_1 = \\lambda$ 和 $\\lambda_2 = \\lambda_3 = \\lambda^{-1/2}$。左 Cauchy-Green 张量 $\\boldsymbol{B}$ 及其逆矩阵为对角阵：\n$$\n\\boldsymbol{B} = \\operatorname{diag}(\\lambda^2, \\lambda^{-1}, \\lambda^{-1}), \\quad \\boldsymbol{B}^{-1} = \\operatorname{diag}(\\lambda^{-2}, \\lambda, \\lambda)\n$$\n主应力为 $\\sigma_{ii} = -p + 2C_{10}B_{ii} - 2C_{01}(B^{-1})_{ii}$。轴向应力为 $\\sigma_{11}$，横向应力为 $\\sigma_{22}$ 和 $\\sigma_{33}$。根据无牵引力的边界条件 $\\sigma_{22} = \\sigma_{33} = 0$，我们从 $\\sigma_{22} = 0$ 求解压力 $p$：\n$$\n0 = -p + 2C_{10}\\lambda^{-1} - 2C_{01}\\lambda \\implies p = 2C_{10}\\lambda^{-1} - 2C_{01}\\lambda\n$$\n测量的轴向应力 $\\sigma_{\\text{uni}} = \\sigma_{11}$ 则为：\n$$\n\\sigma_{\\text{uni}} = -(2C_{10}\\lambda^{-1} - 2C_{01}\\lambda) + 2C_{10}\\lambda^2 - 2C_{01}\\lambda^{-2}\n$$\n$$\n\\sigma_{\\text{uni}} = 2(\\lambda^2 - \\lambda^{-1})C_{10} + 2(\\lambda - \\lambda^{-2})C_{01}\n$$\n对应于给定拉伸比 $\\lambda$ 的雅可比矩阵的行向量为 $[2(\\lambda^2 - \\lambda^{-1}), 2(\\lambda - \\lambda^{-2})]$。\n\n**2. 等双轴拉伸**\n主拉伸比为 $\\lambda_1 = \\lambda_2 = \\lambda$ 和 $\\lambda_3 = \\lambda^{-2}$。张量 $\\boldsymbol{B}$ 和 $\\boldsymbol{B}^{-1}$ 为：\n$$\n\\boldsymbol{B} = \\operatorname{diag}(\\lambda^2, \\lambda^2, \\lambda^{-4}), \\quad \\boldsymbol{B}^{-1} = \\operatorname{diag}(\\lambda^{-2}, \\lambda^{-2}, \\lambda^4)\n$$\n测量的面内应力为 $\\sigma_{\\text{biax}} = \\sigma_{11} = \\sigma_{22}$。横向应力为 $\\sigma_{33}$，在无牵引力条件下为零。我们从 $\\sigma_{33} = 0$ 求解 $p$：\n$$\n0 = -p + 2C_{10}\\lambda^{-4} - 2C_{01}\\lambda^4 \\implies p = 2C_{10}\\lambda^{-4} - 2C_{01}\\lambda^4\n$$\n将 $p$ 代入 $\\sigma_{11}$ 的表达式中：\n$$\n\\sigma_{\\text{biax}} = -(2C_{10}\\lambda^{-4} - 2C_{01}\\lambda^4) + 2C_{10}\\lambda^2 - 2C_{01}\\lambda^{-2}\n$$\n$$\n\\sigma_{\\text{biax}} = 2(\\lambda^2 - \\lambda^{-4})C_{10} + 2(\\lambda^4 - \\lambda^{-2})C_{01}\n$$\n对应于给定拉伸比 $\\lambda$ 的雅可比矩阵的行向量为 $[2(\\lambda^2 - \\lambda^{-4}), 2(\\lambda^4 - \\lambda^{-2})]$。\n\n**3. 简单剪切**\n变形梯度为 $\\boldsymbol{F} = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$。张量 $\\boldsymbol{B}$ 和 $\\boldsymbol{B}^{-1}$ 为：\n$$\n\\boldsymbol{B} = \\begin{bmatrix} 1+\\gamma^2 & \\gamma & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}, \\quad \\boldsymbol{B}^{-1} = \\begin{bmatrix} 1 & -\\gamma & 0 \\\\ -\\gamma & 1+\\gamma^2 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}\n$$\n测量的剪切应力分量 $\\sigma_{12}$ 与压力 $p$ 无关：\n$$\n\\sigma_{12} = 2C_{10}B_{12} - 2C_{01}(B^{-1})_{12} = 2C_{10}(\\gamma) - 2C_{01}(-\\gamma)\n$$\n$$\n\\sigma_{12} = (2\\gamma)C_{10} + (2\\gamma)C_{01}\n$$\n对应于给定剪切量 $\\gamma$ 的雅可比矩阵的行向量为 $[2\\gamma, 2\\gamma]$。这两列是相同的，这表明仅凭简单剪切数据无法唯一地区分 $C_{10}$ 和 $C_{01}$，只能区分它们的和。贝叶斯先验对这种病态问题进行了正则化。\n\n**计算流程**\n对于五个案例中的每一个，执行以下算法：\n1.  为指定范围和数据点数量生成应变度量（$\\lambda$ 或 $\\gamma$）的数组。\n2.  通过遍历应变度量并使用上述推导的表达式计算相应的行来构造雅可比矩阵 $\\boldsymbol{J}$。对于混合模式案例，计算单轴和等双轴子设计的雅可比矩阵并垂直堆叠。\n3.  从数据中计算 Fisher 信息矩阵 $\\boldsymbol{H} = \\boldsymbol{J}^{\\mathsf{T}} \\boldsymbol{J} / \\sigma_{\\text{noise}}^2$。\n4.  计算后验协方差矩阵 $\\boldsymbol{\\Sigma}_{\\text{post}} = (\\boldsymbol{\\Sigma}_{0}^{-1} + \\boldsymbol{H})^{-1}$。\n5.  计算其迹 $\\operatorname{tr}(\\boldsymbol{\\Sigma}_{\\text{post}})$，它代表参数的总期望后验方差。\n\n该流程在随附的程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the derivation and calculation for identifying Mooney-Rivlin parameters.\n    For each of the five experimental designs, it constructs the Jacobian,\n    computes the posterior covariance matrix using a Bayesian linear model,\n    and calculates its trace. The results are printed in the specified format.\n    \"\"\"\n\n    # Prior inverse covariance matrix, units of (MPa)^-2, derived from\n    # Sigma_0 = diag(0.25, 0.25).\n    SIGMA0_INV = np.array([[4.0, 0.0], [0.0, 4.0]])\n\n    def get_uniaxial_jacobian(lambdas: np.ndarray) -> np.ndarray:\n        \"\"\"Constructs the Jacobian for uniaxial tension tests.\"\"\"\n        num_points = len(lambdas)\n        J = np.zeros((num_points, 2))\n        for i, lam in enumerate(lambdas):\n            # Sensitivity of axial stress w.r.t. C10\n            J[i, 0] = 2 * (lam**2 - 1 / lam)\n            # Sensitivity of axial stress w.r.t. C01\n            J[i, 1] = 2 * (lam - 1 / lam**2)\n        return J\n\n    def get_equibiaxial_jacobian(lambdas: np.ndarray) -> np.ndarray:\n        \"\"\"Constructs the Jacobian for equibiaxial tension tests.\"\"\"\n        num_points = len(lambdas)\n        J = np.zeros((num_points, 2))\n        for i, lam in enumerate(lambdas):\n            # Sensitivity of in-plane stress w.r.t. C10\n            J[i, 0] = 2 * (lam**2 - 1 / lam**4)\n            # Sensitivity of in-plane stress w.r.t. C01\n            J[i, 1] = 2 * (lam**4 - 1 / lam**2)\n        return J\n\n    def get_shear_jacobian(gammas: np.ndarray) -> np.ndarray:\n        \"\"\"Constructs the Jacobian for simple shear tests.\"\"\"\n        num_points = len(gammas)\n        J = np.zeros((num_points, 2))\n        for i, gam in enumerate(gammas):\n            # Sensitivity of shear stress w.r.t. C10\n            J[i, 0] = 2 * gam\n            # Sensitivity of shear stress w.r.t. C01\n            J[i, 1] = 2 * gam\n        return J\n\n    def compute_trace_post_cov(J: np.ndarray, sigma_noise: float) -> float:\n        \"\"\"Computes the trace of the posterior covariance matrix.\"\"\"\n        # Fisher information from the likelihood, units of (MPa)^-2.\n        H = J.T @ J / (sigma_noise**2)\n        # Posterior inverse covariance (prior + likelihood), units of (MPa)^-2.\n        Sigma_post_inv = SIGMA0_INV + H\n        # Posterior covariance, units of (MPa)^2.\n        Sigma_post = np.linalg.inv(Sigma_post_inv)\n        # Expected posterior variance, defined as tr(Sigma_post).\n        return np.trace(Sigma_post)\n\n    test_cases = [\n        {'type': 'uniaxial', 'n': 11, 'range': [1.0, 1.6], 'sigma_noise': 0.1},\n        {'type': 'equibiaxial', 'n': 11, 'range': [1.0, 1.3], 'sigma_noise': 0.1},\n        {'type': 'shear', 'n': 11, 'range': [0.0, 0.8], 'sigma_noise': 0.1},\n        {'type': 'uniaxial', 'n': 5, 'range': [1.0, 1.2], 'sigma_noise': 0.02},\n        {'type': 'mixed', 'n_uni': 6, 'range_uni': [1.0, 1.6],\n                           'n_biax': 6, 'range_biax': [1.0, 1.3], 'sigma_noise': 0.1}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'uniaxial':\n            strains = np.linspace(case['range'][0], case['range'][1], case['n'])\n            J = get_uniaxial_jacobian(strains)\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        elif case['type'] == 'equibiaxial':\n            strains = np.linspace(case['range'][0], case['range'][1], case['n'])\n            J = get_equibiaxial_jacobian(strains)\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        elif case['type'] == 'shear':\n            strains = np.linspace(case['range'][0], case['range'][1], case['n'])\n            J = get_shear_jacobian(strains)\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        elif case['type'] == 'mixed':\n            strains_uni = np.linspace(case['range_uni'][0], case['range_uni'][1], case['n_uni'])\n            J_uni = get_uniaxial_jacobian(strains_uni)\n            strains_biax = np.linspace(case['range_biax'][0], case['range_biax'][1], case['n_biax'])\n            J_biax = get_equibiaxial_jacobian(strains_biax)\n            J = np.vstack([J_uni, J_biax])\n            trace = compute_trace_post_cov(J, case['sigma_noise'])\n        results.append(trace)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2650344"}]}