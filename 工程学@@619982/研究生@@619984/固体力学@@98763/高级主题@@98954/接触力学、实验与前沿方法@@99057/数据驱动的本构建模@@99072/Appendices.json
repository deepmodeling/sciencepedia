{"hands_on_practices": [{"introduction": "在数据驱动的本构建模中，一个核心挑战是确保模型能遵守诸如客观性和各向同性等基本物理定律。与其寄希望于模型从原始数据中自行学习这些对称性，一种更严谨的方法是通过精心选择模型的输入特征来直接施加这些约束。本练习将探索有限变形理论中的基本运动学量——右柯西-格林张量 $C$ 的主不变量，并阐明为何它们构成了任何各向同性超弹性模型的坚实理论基础。[@problem_id:2629384]", "problem": "各向同性超弹性材料的数据驱动代理模型必须满足材料坐标系无关性（客观性）和各向同性。在有限变形的设定下，一种常见的方法是通过右柯西-格林张量 $C$ 对变形进行编码，并使用其主不变量作为不变特征。考虑均匀单剪切变形，其变形梯度为\n$$\nF=\\begin{pmatrix}1 & \\gamma & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1\\end{pmatrix},\n$$\n其中 $\\gamma \\in \\mathbb{R}$ 是剪切参数。仅从右柯西-格林张量 $C=F^{\\mathsf{T}}F$ 的运动学定义和二阶张量 $C$ 的主不变量的定义出发，\n- 计算 $C$，\n- 计算 $C$ 的三个主不变量 $I_{1}$、$I_{2}$ 和 $I_{3}$，\n- 并且，利用各向同性张量函数的基本表示定理，确定 $C$ 的哪些标量不变量足以表示任何可压缩各向同性超弹性储能密度，以及在不可压缩极限下该集合如何简化。\n\n从连续介质运动学和不变性要求的基本原理出发，清晰地解释你的推理过程。为了数据驱动本构模型的目的，简要论证为什么这些不变量构成了一个合适的特征集。\n\n你最终报告的答案必须是包含三个主不变量（作为 $\\gamma$ 的函数）的行向量，写作 $\\begin{pmatrix}I_{1} & I_{2} & I_{3}\\end{pmatrix}$。不需要单位，也不需要四舍五入。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 变形梯度：$F=\\begin{pmatrix}1 & \\gamma & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1\\end{pmatrix}$，其中 $\\gamma \\in \\mathbb{R}$。\n- 右柯西-格林张量的定义：$C=F^{\\mathsf{T}}F$。\n- 任务1：计算 $C$。\n- 任务2：计算 $C$ 的三个主不变量 $I_{1}$、$I_{2}$ 和 $I_{3}$。\n- 任务3：使用各向同性张量函数的表示定理，论证用于表示可压缩和不可压缩各向同性超弹性储能密度函数的标量不变量集合。\n- 任务4：论证为什么这些不变量对于数据驱动本构模型是一个合适的特征集。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于连续介质力学的原理，特别是有限变形运动学和材料对称性理论。该问题是适定的，具有一套清晰明确的指令和定义，可以导出一个唯一且有意义的解。该问题是客观的，不含任何主观或推测性内容。这是固体力学中的一个标准的、基础的练习，并且与数据驱动本构模型这一前沿课题直接相关。所有定义都是标准的，数学步骤均可严格验证。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供一个完整的、有理有据的解答。\n\n按要求系统地进行求解。\n\n首先，我们根据给定的变形梯度 $F$ 计算右柯西-格林张量 $C$。定义为 $C = F^{\\mathsf{T}}F$。\n给定的变形梯度为：\n$$\nF = \\begin{pmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n其转置 $F^{\\mathsf{T}}$ 为：\n$$\nF^{\\mathsf{T}} = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n现在，我们执行矩阵乘法 $C = F^{\\mathsf{T}}F$：\n$$\nC = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1\\cdot1 + 0\\cdot0 + 0\\cdot0 & 1\\cdot\\gamma + 0\\cdot1 + 0\\cdot0 & 1\\cdot0 + 0\\cdot0 + 0\\cdot1 \\\\ \\gamma\\cdot1 + 1\\cdot0 + 0\\cdot0 & \\gamma\\cdot\\gamma + 1\\cdot1 + 0\\cdot0 & \\gamma\\cdot0 + 1\\cdot0 + 0\\cdot1 \\\\ 0\\cdot1 + 0\\cdot0 + 1\\cdot0 & 0\\cdot\\gamma + 0\\cdot1 + 1\\cdot0 & 0\\cdot0 + 0\\cdot0 + 1\\cdot1 \\end{pmatrix}\n$$\n此计算得出右柯西-格林张量：\n$$\nC = \\begin{pmatrix} 1 & \\gamma & 0 \\\\ \\gamma & 1+\\gamma^{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n接下来，我们计算 $C$ 的三个主不变量，记为 $I_{1}$、$I_{2}$ 和 $I_{3}$。对于三维空间中的二阶张量 $C$，其一般定义为：\n$I_1(C) = \\mathrm{tr}(C)$\n$I_2(C) = \\frac{1}{2} [(\\mathrm{tr}(C))^2 - \\mathrm{tr}(C^2)]$ 或等价地，主子式之和。\n$I_3(C) = \\det(C)$\n\n第一个不变量 $I_1$ 是 $C$ 的迹：\n$$\nI_1 = \\mathrm{tr}(C) = C_{11} + C_{22} + C_{33} = 1 + (1+\\gamma^2) + 1 = 3 + \\gamma^2\n$$\n第三个不变量 $I_3$ 是 $C$ 的行列式：\n$$\nI_3 = \\det(C) = \\det\\begin{pmatrix} 1 & \\gamma & 0 \\\\ \\gamma & 1+\\gamma^{2} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n沿第三列展开得到：\n$$\nI_3 = 1 \\cdot \\det\\begin{pmatrix} 1 & \\gamma \\\\ \\gamma & 1+\\gamma^{2} \\end{pmatrix} = 1 \\cdot (1(1+\\gamma^2) - \\gamma \\cdot \\gamma) = 1+\\gamma^2 - \\gamma^2 = 1\n$$\n这个结果是预料之中的，因为 $I_3 = (\\det(F))^2$，且对于给定的单剪切变形，$\\det(F) = 1$。这表明该变形是等容的（体积保持不变）。\n\n第二个不变量 $I_2$ 计算为 $C$ 的主子式之和：\n$$\nI_2 = \\det\\begin{pmatrix} C_{22} & C_{23} \\\\ C_{32} & C_{33} \\end{pmatrix} + \\det\\begin{pmatrix} C_{11} & C_{13} \\\\ C_{31} & C_{33} \\end{pmatrix} + \\det\\begin{pmatrix} C_{11} & C_{12} \\\\ C_{21} & C_{22} \\end{pmatrix}\n$$\n$$\nI_2 = \\det\\begin{pmatrix} 1+\\gamma^2 & 0 \\\\ 0 & 1 \\end{pmatrix} + \\det\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} + \\det\\begin{pmatrix} 1 & \\gamma \\\\ \\gamma & 1+\\gamma^2 \\end{pmatrix}\n$$\n$$\nI_2 = (1+\\gamma^2) + 1 + (1+\\gamma^2 - \\gamma^2) = (1+\\gamma^2) + 1 + 1 = 3 + \\gamma^2\n$$\n因此，对于单剪切，我们发现一个特殊情况，即 $I_1 = I_2$。主不变量为：\n$I_1 = 3 + \\gamma^2$\n$I_2 = 3 + \\gamma^2$\n$I_3 = 1$\n\n现在，我们讨论储能密度函数 $\\Psi$ 的表示。\n对于超弹性材料，$\\Psi = \\Psi(F)$。材料坐标系无关性（客观性）原理要求能量与叠加的刚体转动无关。这意味着 $\\Psi$ 只能是变形中拉伸部分的函数，而拉伸部分由右柯西-格林张量 $C = F^{\\mathsf{T}}F$ 描述。因此，我们写作 $\\Psi = \\hat{\\Psi}(C)$。\n对于各向同性材料，能量函数还必须与参考构型的转动无关，即对于所有旋转张量 $Q$，都有 $\\hat{\\Psi}(Q^{\\mathsf{T}}CQ) = \\hat{\\Psi}(C)$。对称张量的各向同性标量函数的表示定理（Cauchy-Rivlin-Ericksen 定理）指出，此类函数可以表示为其张量主不变量的函数。\n因此，对于**可压缩各向同性超弹性材料**，储能密度必须具有以下形式：\n$$\n\\Psi = \\Psi(I_1, I_2, I_3)\n$$\n这三个标量不变量的集合 $(I_1, I_2, I_3)$ 足以表示任何此类材料定律。\n\n在**不可压缩极限**下，材料被约束为没有体积变化，这意味着 $\\det(F) = J = 1$。正如我们已经确定的，$I_3 = J^2$，因此不可压缩性约束等价于代数约束 $I_3=1$。当施加此约束时，$I_3$ 不再是一个独立的变量。因此，**不可压缩各向同性超弹性材料**的储能密度简化为前两个不变量的函数：\n$$\n\\Psi = \\Psi(I_1, I_2)\n$$\n约束 $I_3=1$ 是通过一个拉格朗日乘子来实现的，该乘子通常被解释为静水压力 $p$，它对储存的能量没有贡献。\n\n最后，我们论证使用这些不变量作为数据驱动本构模型特征的合理性。\n1.  **物理原理的强制执行**：通过使用不变量 $(I_1, I_2, I_3)$ 作为旨在学习函数 $\\Psi$ 的机器学习模型（例如神经网络）的输入特征，可以自动强制执行材料坐标系无关性和各向同性。这些不变量的任何函数，根据其构造，都是客观的和各向同性的。这样做将基本的物理定律硬编码到模型中，这是一种比期望模型从原始张量分量中学习这些对称性更为稳健的方法。\n2.  **降维**：变形状态由 $C$ 完全描述，它有6个独立分量。不变量将这个6维输入空间减少到3维空间（对于不可压缩材料，则为2维）。这极大地简化了学习任务，降低了过拟合的风险，并减少了训练可靠模型所需的实验数据量，这个概念对于减轻“维度灾难”至关重要。\n3.  **完备性**：主不变量集合构成了一个完整基。这意味着它们是一个完备的集合，使用它们不会丢失关于变形状态的任何信息（在旋转意义上）。因此，模型被提供了预测能量所需的所有必要信息。\n\n总而言之，右柯西-格林张量的主不变量不仅仅是变量的便捷选择；它们为构建与力学基本原理一致的各向同性材料的数据驱动模型奠定了理论上严谨的基础。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3+\\gamma^{2} & 3+\\gamma^{2} & 1 \\end{pmatrix}}\n$$", "id": "2629384"}, {"introduction": "虽然使用不变量是构建客观模型的一种有效途径，但拥有一种能够*验证*此属性的方法也至关重要，尤其是在处理复杂模型架构或排查潜在的实现错误时。本练习将指导您从第一原理出发，为应力模型设计并实现一个关于旋转等变性（即客观性）的数值检验，从而能够明确地区分物理上一致的模型与存在缺陷的模型。[@problem_id:2629347]", "problem": "您的任务是为固体力学中一个数据驱动的第一类 Piola–Kirchhoff 应力模型，设计并实现一种程序化的旋转等变性验证。将所有物理量视为无量纲。使用以下基本原理：物质标架无关性原理，该原理断言，单位参考体积的储存能量密度在叠加的刚体旋转下保持不变。目标是：从第一性原理出发，推导应力必须满足的正确旋转变换律；定义一个严格的数值接受准则；并实现一个确定性的测试套件，用以评估多个输入案例。\n\n此验证问题纯粹是数学和逻辑问题：您将实现两个从变形梯度到第一类 Piola–Kirchhoff 应力的参数化映射，定义一组来自 $3$ 阶特殊正交群 (SO) 的旋转矩阵，并在一组给定的旋转上检验旋转等变性条件。\n\n定义和约束：\n- 令 $F \\in \\mathbb{R}^{3 \\times 3}$ 表示变形梯度。\n- 令 $P(F) \\in \\mathbb{R}^{3 \\times 3}$ 表示模型预测的第一类 Piola–Kirchhoff 应力。\n- 令 $Q \\in \\mathrm{SO}(3)$ 表示一个真・正交张量，满足 $Q^{\\mathsf{T}} Q = I$ 和 $\\det(Q) = 1$。\n- 在叠加刚体旋转下，第一类 Piola–Kirchhoff 应力的旋转等变性要求对于所有 $Q \\in \\mathrm{SO}(3)$，一个客观模型必须满足从物质标架无关性推导出的相应变换律。\n- 矩阵 $A$ 的 Frobenius 范数为 $\\|A\\|_{\\mathrm{F}} = \\sqrt{\\sum_{i,j} A_{ij}^{2}}$。\n\n待测试的模型族：\n1. 等变不变量映射：定义 $C(F) = F^{\\mathsf{T}} F$ 且\n   $$P_{\\theta}(F) = a_{0} F + a_{1} F C(F) + a_{2} F \\left(C(F)\\right)^{2},$$\n   其中参数为 $\\theta = (a_{0}, a_{1}, a_{2}) \\in \\mathbb{R}^{3}$。该映射仅通过 $C(F)$ 依赖于 $F$，因此其设计意图是满足正确的旋转变换性质。\n2. 引入一个固定的实验室坐标系方向 $b \\in \\mathbb{R}^{3}$ 而违反客观性的扰动非等变映射：\n   $$\\tilde{P}_{\\theta,\\delta}(F) = P_{\\theta}(F) + \\delta \\, b \\otimes \\left(F b\\right),$$\n   其中 $(b \\otimes v)_{ij} = b_{i} v_{j}$，$b = [1, 0, 0]^{\\mathsf{T}}$，且 $\\delta \\ge 0$ 是一个标量扰动幅度。\n\n旋转集：\n使用以下确定性的旋转集合。所有角度必须以弧度为单位进行解释。\n- 绕 $z$ 轴旋转，角度为 $\\theta \\in \\{0, \\pi/3, \\pi/2\\}$：\n  $$R_{z}(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}.$$\n- 绕 $x$ 轴旋转，角度为 $\\pi$：\n  $$R_{x}(\\pi) = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{bmatrix}.$$\n- 绕 $y$ 轴旋转，角度为 $-\\pi/4$：\n  $$R_{y}(-\\pi/4) = \\begin{bmatrix} \\cos(\\pi/4) & 0 & -\\sin(\\pi/4) \\\\ 0 & 1 & 0 \\\\ \\sin(\\pi/4) & 0 & \\cos(\\pi/4) \\end{bmatrix}.$$\n\n接受准则：\n- 对于给定的 $F$ 和给定的模型 $M(\\cdot)$ (即 $P_{\\theta}$ 或 $\\tilde{P}_{\\theta,\\delta}$)，定义在旋转集 $\\mathcal{Q}$ 上的最坏情况相对等变性误差为\n  $$\\mathrm{err}(F; M, \\mathcal{Q}) = \\max_{Q \\in \\mathcal{Q}} \\frac{\\left\\| M(QF) - Q \\, M(F) \\right\\|_{\\mathrm{F}}}{\\max\\left(\\left\\|M(F)\\right\\|_{\\mathrm{F}}, 10^{-12}\\right)}.$$\n- 如果 $\\mathrm{err}(F; M, \\mathcal{Q}) \\le \\varepsilon$，则模型通过对该 $F$ 的测试，其中容差为 $\\varepsilon = 10^{-9}$。\n\n测试套件：\n- 使用参数矢量 $\\theta = (a_{0}, a_{1}, a_{2}) = (0.5, -0.1, 0.03)$。\n- 使用以下变形梯度：\n  1. $F_{1} = \\begin{bmatrix} 1.1 & 0.2 & 0.0 \\\\ 0.0 & 0.9 & 0.1 \\\\ 0.0 & 0.0 & 1.2 \\end{bmatrix}$。\n  2. $F_{2} = \\begin{bmatrix} 10^{-3} & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.5 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$。\n  3. $F_{3} = \\begin{bmatrix} 1.0 & -0.3 & 0.2 \\\\ 0.1 & 1.2 & 0.4 \\\\ -0.2 & 0.0 & 0.8 \\end{bmatrix}$。\n  4. $F_{4} = I = \\begin{bmatrix} 1.0 & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$。\n- 构建五个测试用例，每个用例包含一个模型选择、一个变形梯度，以及（如果适用）一个扰动幅度：\n  1. 等变模型 $P_{\\theta}$，使用 $F = F_{1}$。\n  2. 等变模型 $P_{\\theta}$，使用 $F = F_{2}$。\n  3. 等变模型 $P_{\\theta}$，使用 $F = F_{4}$。\n  4. 扰动模型 $\\tilde{P}_{\\theta,\\delta}$，使用 $F = F_{3}$ 和 $\\delta = 5 \\times 10^{-2}$。\n  5. 扰动模型 $\\tilde{P}_{\\theta,\\delta}$，使用 $F = F_{1}$ 和 $\\delta = 10^{-12}$。\n\n计算与输出：\n- 实现上述定义的旋转集 $\\mathcal{Q}$ 的确定性生成。\n- 对于每个测试用例，计算 $\\mathrm{err}(F; M, \\mathcal{Q})$ 并检查其是否小于或等于 $\\varepsilon = 10^{-9}$。\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的五个布尔结果，格式为方括号内的逗号分隔列表，例如 $[ \\mathrm{True}, \\mathrm{False}, \\dots ]$。\n- 角度以弧度为单位。所有物理量均为无量纲。不允许外部输入；程序必须按原样运行，并只打印结果行。", "solution": "该问题要求为第一类 Piola–Kirchhoff 应力模型设计并实现一种程序化的旋转等变性验证。此任务必须从第一性原理出发，特别是物质标架无关性原理。\n\n**1. 旋转等变性条件的推导**\n\n物质标架无关性原理，也称为客观性原理，假定材料的本构律必须独立于观察者的参考系。对于超弹性材料，这通过标量储存能量密度函数 $\\Psi$ 来表达，该函数依赖于变形梯度 $F \\in \\mathbb{R}^{3 \\times 3}$。观察者从一个参考系变换到一个由真・正交张量 $Q \\in \\mathrm{SO}(3)$（其中 $Q^{\\mathsf{T}}Q = I$ 且 $\\det(Q)=1$）旋转的参考系时，变形梯度变换为 $F' = QF$。客观性要求储存能量（一个物理标量）在此类变换下保持不变：\n$$ \\Psi(F) = \\Psi(QF) \\quad \\forall Q \\in \\mathrm{SO}(3) $$\n第一类 Piola–Kirchhoff (PK1) 应力张量 $P$ 定义为储存能量密度相对于变形梯度的导数：\n$$ P_{ij}(F) = \\frac{\\partial \\Psi}{\\partial F_{ij}}(F) $$\n为了推导 $P(F)$ 的变换律，我们将客观性条件 $\\Psi(F) = \\Psi(QF)$ 对 $F$ 求导。一个严谨的方法是使用方向导数。令 $H \\in \\mathbb{R}^{3 \\times 3}$ 为一个任意扰动。$\\Psi$ 在 $F$ 点沿 $H$ 方向的方向导数由迹内积给出：\n$$ D\\Psi(F)[H] = \\mathrm{tr}\\left( \\left(\\frac{\\partial \\Psi}{\\partial F}(F)\\right)^{\\mathsf{T}} H \\right) = \\mathrm{tr}(P(F)^{\\mathsf{T}} H) $$\n对客观性条件右侧的 $\\Psi(QF)$ 应用链式法则，我们求得其在 $H$ 方向上对 $F$ 的导数：\n$$ D\\Psi(QF)[QH] = \\mathrm{tr}(P(QF)^{\\mathsf{T}} (QH)) $$\n由于 $\\Psi(F) = \\Psi(QF)$，它们的导数必须相等：\n$$ \\mathrm{tr}(P(F)^{\\mathsf{T}} H) = \\mathrm{tr}(P(QF)^{\\mathsf{T}} Q H) $$\n对右侧使用迹的循环性质 $\\mathrm{tr}(ABC) = \\mathrm{tr}(BCA)$，我们得到：\n$$ \\mathrm{tr}(P(F)^{\\mathsf{T}} H) = \\mathrm{tr}(H P(QF)^{\\mathsf{T}} Q) $$\n该等式必须对任意矩阵 $H$ 成立。这只有在迹内与 $H$ 相乘的项相同时才可能，这意味着：\n$$ P(F)^{\\mathsf{T}} = P(QF)^{\\mathsf{T}} Q $$\n对两边取转置得到 $P(F) = (P(QF)^{\\mathsf{T}} Q)^{\\mathsf{T}} = Q^{\\mathsf{T}} P(QF)$。最后，左乘 $Q$ 并使用正交矩阵的性质 $QQ^{\\mathsf{T}}=I$，我们得到第一类 Piola–Kirchhoff 应力的最终变换律：\n$$ P(QF) = Q P(F) $$\n这就是任何客观的 PK1 应力本构模型 $M(\\cdot)$ 都必须满足的旋转等变性条件。问题中涉及 $\\| M(QF) - Q M(F) \\|_{\\mathrm{F}}$ 的误差度量，正确地将这一物理要求形式化了。\n\n**2. 本构模型的分析**\n\n我们根据推导出的等变性条件来分析给定的两个模型。\n\n**模型 1: 等变不变量映射**\n该模型定义为 $P_{\\theta}(F) = a_{0} F + a_{1} F C(F) + a_{2} F (C(F))^{2}$，其中 $C(F) = F^{\\mathsf{T}} F$ 是右 Cauchy-Green 张量。为验证其客观性，我们考察其在变换 $F \\to QF$ 下的行为。首先，右 Cauchy-Green 张量的变换如下：\n$$ C(QF) = (QF)^{\\mathsf{T}}(QF) = F^{\\mathsf{T}}Q^{\\mathsf{T}}QF = F^{\\mathsf{T}}IF = F^{\\mathsf{T}}F = C(F) $$\n它是不变量。现在，将 $QF$ 代入模型方程：\n$$ P_{\\theta}(QF) = a_{0}(QF) + a_{1}(QF)C(QF) + a_{2}(QF)(C(QF))^{2} $$\n因为 $C(QF) = C(F)$，我们可以写成：\n$$ P_{\\theta}(QF) = a_{0}QF + a_{1}QFC(F) + a_{2}QF(C(F))^{2} = Q \\left( a_{0}F + a_{1}FC(F) + a_{2}F(C(F))^{2} \\right) = Q P_{\\theta}(F) $$\n该模型恒等地满足等变性条件。在数值测试中测量的任何误差都将源于浮点精度限制，并预计远低于容差 $\\varepsilon = 10^{-9}$。\n\n**模型 2: 扰动非等变映射**\n这个模型，$\\tilde{P}_{\\theta,\\delta}(F) = P_{\\theta}(F) + \\delta \\, b \\otimes (F b)$，引入了对一个固定向量 $b = [1, 0, 0]^{\\mathsf{T}}$ 的依赖。我们来测试其变换性质：\n$$ \\tilde{P}_{\\theta,\\delta}(QF) = P_{\\theta}(QF) + \\delta \\, b \\otimes ((QF)b) = Q P_{\\theta}(F) + \\delta \\, b \\otimes (Q F b) $$\n等变性条件要求 $\\tilde{P}_{\\theta,\\delta}(QF) = Q \\tilde{P}_{\\theta,\\delta}(F)$。我们计算此要求等式的右侧：\n$$ Q \\tilde{P}_{\\theta,\\delta}(F) = Q (P_{\\theta}(F) + \\delta \\, b \\otimes (F b)) = Q P_{\\theta}(F) + \\delta Q (b \\otimes (F b)) $$\n利用矩阵 $Q$ 作用于张量积的性质 $Q(u \\otimes v) = (Qu) \\otimes v$，我们发现 $Q (b \\otimes (F b)) = (Qb) \\otimes (Fb)$。因此，为使模型具有等变性，我们需要：\n$$ Q P_{\\theta}(F) + \\delta \\, b \\otimes (Q F b) = Q P_{\\theta}(F) + \\delta \\, (Qb) \\otimes (Fb) $$\n这简化为 $b \\otimes (Q F b) = (Qb) \\otimes (Fb)$，这在 $Q \\neq I$ 时通常不成立，因为 $b$ 是一个固定向量，而 $Qb$ 不是。引入固定方向向量 $b$ 破坏了客观性。对于 $\\delta > 0$，此模型将产生非零的等变性误差，其大小将决定它是否通过数值测试。\n\n**3. 验证的算法设计**\n\n验证过程被实现为一个确定性算法。\n- 首先，按规定构造包含五个旋转矩阵的集合 $\\mathcal{Q}$。\n- 实现两个函数，每个模型（$P_{\\theta}$ 和 $\\tilde{P}_{\\theta,\\delta}$）一个，用于为给定的变形梯度 $F$ 计算应力张量。\n- 定义一个误差计算函数。它以模型、$F$ 和旋转集 $\\mathcal{Q}$ 作为输入。对于给定的 $F$ 和模型 $M$，它计算参考应力 $M(F)$ 及其 Frobenius 范数。然后，它遍历所有 $Q \\in \\mathcal{Q}$，计算相对误差 $\\left\\| M(QF) - Q M(F) \\right\\|_{\\mathrm{F}} / \\max(\\left\\|M(F)\\right\\|_{\\mathrm{F}}, 10^{-12})$。该函数返回在整个 $\\mathcal{Q}$ 集合中找到的最大相对误差。\n- 主脚本定义了五个测试用例。它遍历这些用例，使用适当的模型、$F$ 和参数（$\\theta$, $\\delta$）调用误差函数。\n- 将每个用例计算出的误差与容差 $\\varepsilon = 10^{-9}$ 进行比较。记录一个布尔结果（`True` 表示通过，`False` 表示失败）。\n- 最后，将收集到的五个布尔结果列表格式化为所需的输出字符串。这为每个模型对物质标架无关性的遵守情况提供了一个清晰、可验证且基于原理的评估。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a deterministic test suite to verify the rotational equivariance\n    of two families of first Piola-Kirchhoff stress models.\n    \"\"\"\n\n    # --- Problem Definitions ---\n\n    # Model parameters\n    theta = (0.5, -0.1, 0.03)  # (a0, a1, a2)\n    b = np.array([1.0, 0.0, 0.0])\n\n    # Acceptance criterion\n    epsilon = 1e-9\n\n    # --- Constitutive Models ---\n\n    def model_p(F, a0, a1, a2):\n        \"\"\"Equivariant invariant-based mapping.\"\"\"\n        # Right Cauchy-Green tensor C = F^T F\n        C = F.T @ F\n        # P = a0*F + a1*F*C + a2*F*C^2\n        # Use np.linalg.matrix_power for C^2\n        P = a0 * F + a1 * (F @ C) + a2 * (F @ np.linalg.matrix_power(C, 2))\n        return P\n\n    def model_p_tilde(F, a0, a1, a2, delta, b_vec):\n        \"\"\"Perturbed non-equivariant mapping.\"\"\"\n        P_base = model_p(F, a0, a1, a2)\n        # Perturbation: delta * (b outer (F*b))\n        perturbation = delta * np.outer(b_vec, F @ b_vec)\n        return P_base + perturbation\n\n    # --- Rotation Set Generation ---\n\n    def get_rotation_set():\n        \"\"\"Generates the deterministic set of rotation matrices Q.\"\"\"\n        Q_set = []\n        \n        # Rotations about z-axis\n        for angle in [0, np.pi/3, np.pi/2]:\n            c, s = np.cos(angle), np.sin(angle)\n            Rz = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n            Q_set.append(Rz)\n            \n        # Rotation about x-axis by pi\n        c, s = np.cos(np.pi), np.sin(np.pi)\n        Rx = np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        Q_set.append(Rx)\n        \n        # Rotation about y-axis by -pi/4\n        # The problem statement gives the matrix directly. We implement it\n        # R_y(-pi/4) = [[cos(pi/4), 0, -sin(pi/4)], [0, 1, 0], [sin(pi/4), 0, cos(pi/4)]]\n        angle = -np.pi / 4\n        # Standard rotation matrix for angle alpha is [[c,0,s],[0,1,0],[-s,0,c]]\n        c, s = np.cos(angle), np.sin(angle)\n        Ry = np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        # This is equivalent to the matrix in the problem description.\n        Q_set.append(Ry)\n        \n        return Q_set\n\n    # --- Error Calculation ---\n\n    def calculate_equivariance_error(model_func, F, Q_set, params):\n        \"\"\"\n        Computes the worst-case relative equivariance error for a given model and F.\n        \"\"\"\n        # Calculate reference stress P(F)\n        M_F = model_func(F, **params)\n        \n        # Denominator for relative error, with stability guard\n        norm_M_F = np.linalg.norm(M_F, 'fro')\n        denominator = max(norm_M_F, 1e-12)\n        \n        max_error = 0.0\n        for Q in Q_set:\n            # Deformation gradient in rotated frame\n            QF = Q @ F\n            \n            # Stress in rotated frame: M(QF)\n            M_QF = model_func(QF, **params)\n            \n            # Rotated stress from reference frame: Q * M(F)\n            Q_M_F = Q @ M_F\n            \n            # Error norm\n            error_norm = np.linalg.norm(M_QF - Q_M_F, 'fro')\n            \n            # Relative error\n            relative_error = error_norm / denominator\n            \n            if relative_error > max_error:\n                max_error = relative_error\n                \n        return max_error\n    \n    # --- Test Suite Execution ---\n    \n    # Deformation Gradients\n    F1 = np.array([[1.1, 0.2, 0.0], [0.0, 0.9, 0.1], [0.0, 0.0, 1.2]])\n    F2 = np.array([[1e-3, 0.0, 0.0], [0.0, 1.0, 0.5], [0.0, 0.0, 1.0]])\n    F3 = np.array([[1.0, -0.3, 0.2], [0.1, 1.2, 0.4], [-0.2, 0.0, 0.8]])\n    F4 = np.identity(3)\n\n    # Test cases definition\n    test_cases = [\n        {'model': 'P', 'F': F1, 'delta': None},\n        {'model': 'P', 'F': F2, 'delta': None},\n        {'model': 'P', 'F': F4, 'delta': None},\n        {'model': 'P_tilde', 'F': F3, 'delta': 5e-2},\n        {'model': 'P_tilde', 'F': F1, 'delta': 1e-12},\n    ]\n\n    Q_set = get_rotation_set()\n    results = []\n\n    a0, a1, a2 = theta\n    \n    for case in test_cases:\n        F = case['F']\n        \n        if case['model'] == 'P':\n            params = {'a0': a0, 'a1': a1, 'a2': a2}\n            error = calculate_equivariance_error(model_p, F, Q_set, params)\n        else: # P_tilde\n            delta = case['delta']\n            params = {'a0': a0, 'a1': a1, 'a2': a2, 'delta': delta, 'b_vec': b}\n            error = calculate_equivariance_error(model_p_tilde, F, Q_set, params)\n        \n        # Check against tolerance\n        passed = (error <= epsilon)\n        results.append(passed)\n\n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2629347"}, {"introduction": "最后的这个练习将展示一个针对不同材料行为——塑性——的完整端到端数据驱动建模流程。您将从带有噪声的实验数据出发，学习如何通过将凸性约束嵌入优化问题中来拟合具有物理意义的屈服面，并最终使用该模型预测材料在新加载条件下的响应。[@problem_id:2629338]", "problem": "给定一个初始未知的、凸性的、率无关的、理想塑性材料在平面应力且剪应力为零状态下的带噪声的屈服点测量数据。任务是通过数据拟合一个凸屈服面来构建一个数据驱动的本构模型，然后使用相关联塑性流动法则为指定的加载步计算塑性应变增量。该建模必须强制执行从最大塑性耗散原理和容许应力集的凸性推导出的凸性和正交流动法则。您编写的程序必须是一个完整的、可运行的程序，能够执行此端到端过程，并返回指定测试套件的结果。\n\n基本原理和假设：\n- 该材料被建模为小应变，在屈服前为线性弹性，其后为理想塑性。平面应力下的弹性关系由应力与应变之间的线性本构关系给出。在剪应力为零的平面应力状态下，Cauchy 应力矢量为 $\\sigma = [\\sigma_{xx}, \\sigma_{yy}]^\\top$，单位为帕斯卡。\n- 在平面应力中，法向分量的弹性刚度矩阵为\n$$\n\\mathbf{C} = \\frac{E}{1-\\nu^2} \\begin{bmatrix}\n1 & \\nu \\\\\n\\nu & 1\n\\end{bmatrix},\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。柔度矩阵是 $\\mathbf{C}$ 的逆矩阵，在本问题中不需要显式使用。\n- 屈服面未知但为凸的，并通过作为半空间交集的凸多胞体来近似\n$$\n\\mathcal{Y} = \\{\\sigma \\in \\mathbb{R}^2 \\mid n_i \\cdot \\sigma \\le \\alpha_i,\\ i=1,\\dots,m\\},\n$$\n其中 $n_i \\in \\mathbb{R}^2$ 是已知的单位外法线，$\\alpha_i \\in \\mathbb{R}_{\\ge 0}$ 是待从数据中拟合的未知支撑值。根据构造，$\\mathcal{Y}$ 是凸的。相应的凸屈服函数是基于支撑函数的表达式\n$$\nf(\\sigma;\\alpha) = \\max_{i=1,\\dots,m} \\left(n_i \\cdot \\sigma - \\alpha_i\\right).\n$$\n- 流动是相关联的：塑性应变增量满足从最大塑性耗散原理推导出的正交流动法则，即\n$$\n\\Delta \\varepsilon^p = \\Delta \\gamma \\, \\partial_\\sigma f(\\sigma;\\alpha),\n$$\n其中 $\\Delta \\gamma \\ge 0$ 是塑性乘子。对于多面体屈服函数，$\\partial_\\sigma f$ 是一个次梯度；当只有单个面 $j$ 被激活时，$\\partial_\\sigma f = n_j$。\n\n数据拟合步骤（强制凸性）：\n- 给定带噪声的测量值 $\\{s_k\\}_{k=1}^N$，每个 $s_k \\in \\mathbb{R}^2$ 的单位为帕斯卡，这些点本应位于真实（未知）的光滑屈服面上，但包含了噪声。您必须通过拟合一个具有面 $\\{(n_i,\\alpha_i)\\}_{i=1}^m$ 的多胞体来强制执行凸性，该多胞体能在保持紧致的同时最好地包含数据。为此，您将求解一个带有非负松弛变量 $\\{t_k\\}_{k=1}^N$ 的线性规划（LP）问题，这些松弛变量表示将 $s_k$ 包含在可行多胞体内所需的最小向外平移：\n- 变量：$\\alpha_i \\ge 0$ (对于 $i=1,\\dots,m$) 和 $t_k \\ge 0$ (对于 $k=1,\\dots,N$）。\n- 确保带松弛包含的约束条件：对于所有 $i=1,\\dots,m$ 和 $k=1,\\dots,N$，\n$$\nn_i \\cdot s_k \\le \\alpha_i + t_k.\n$$\n- 获得一个紧致且与数据一致的多胞体的目标：最小化\n$$\n\\sum_{i=1}^m \\alpha_i + \\lambda \\sum_{k=1}^N t_k,\n$$\n其中 $\\lambda > 0$ 是下面给出的预设权重。该目标旨在减小 $\\alpha_i$（紧致性）并惩罚松弛量（数据失配），从而强制实现凸性和对带噪声屈服数据的紧密拟合。\n\n回映算法步骤（强制正交流动）：\n- 对于给定的弹性试探应力 $\\sigma_{\\mathrm{tr}}$，计算拟合的屈服函数值 $f(\\sigma_{\\mathrm{tr}};\\alpha)$。如果 $f(\\sigma_{\\mathrm{tr}};\\alpha) \\le 0$，则该增量是弹性的，$\\Delta \\varepsilon^p = [0,0]^\\top$。\n- 否则，识别唯一的最大化索引 $j^\\star$，使得 $f(\\sigma_{\\mathrm{tr}};\\alpha) = n_{j^\\star} \\cdot \\sigma_{\\mathrm{tr}} - \\alpha_{j^\\star}$ 严格大于所有其他面。然后，根据相关联流动法则，并在更新后的应力处强制执行一致性条件 $f(\\sigma;\\alpha)=0$，塑性乘子为\n$$\n\\Delta \\gamma = \\frac{n_{j^\\star} \\cdot \\sigma_{\\mathrm{tr}} - \\alpha_{j^\\star}}{n_{j^\\star}^\\top \\mathbf{C} \\, n_{j^\\star}},\n$$\n塑性应变增量为\n$$\n\\Delta \\varepsilon^p = \\Delta \\gamma \\, n_{j^\\star}.\n$$\n- 更新后的应力为 $\\sigma = \\sigma_{\\mathrm{tr}} - \\mathbf{C} \\Delta \\varepsilon^p$，根据构造，该应力在激活面上满足 $f(\\sigma;\\alpha)=0$。如果最大值处出现多个面并列的情况，您可以选择索引最小的面来确定性地打破平局；所提供的测试套件避免了精确并列的情况。\n\n所有量均采用国际单位制。应力单位为帕斯卡（Pa），应变为无量纲。如果在内部使用角度，单位为弧度。\n\n您的程序要使用的参数、数据和测试套件：\n- 弹性常数： $E = 210 \\times 10^9$ Pa，$\\nu = 0.3$。\n- 面的数量：$m = 16$。单位法线 $n_i = [\\cos \\varphi_i,\\ \\sin \\varphi_i]^\\top$，其中 $\\varphi_i = \\frac{\\pi}{8} i$，对于 $i=0,1,\\dots,15$。\n- 松弛惩罚权重：$\\lambda = 1000$。\n- 带噪声的屈服数据点 $s_k = [\\sigma_{xx}^{(k)}, \\sigma_{yy}^{(k)}]^\\top$，单位为帕斯卡，对于 $k=1,\\dots,12$：\n  1. $[408 \\times 10^6,\\ 0]$\n  2. $[341.410 \\times 10^6,\\ 154 \\times 10^6]$\n  3. $[206 \\times 10^6,\\ 252.808 \\times 10^6]$\n  4. $[0,\\ 310 \\times 10^6]$\n  5. $[-204 \\times 10^6,\\ 265.808 \\times 10^6]$\n  6. $[-341.410 \\times 10^6,\\ 147 \\times 10^6]$\n  7. $[-409 \\times 10^6,\\ 0]$\n  8. $[-339.410 \\times 10^6,\\ -154 \\times 10^6]$\n  9. $[-206 \\times 10^6,\\ -267.808 \\times 10^6]$\n  10. $[0,\\ -309 \\times 10^6]$\n  11. $[204 \\times 10^6,\\ -254.808 \\times 10^6]$\n  12. $[343.410 \\times 10^6,\\ -144 \\times 10^6]$\n- 加载测试用例（试探应力）$\\sigma_{\\mathrm{tr}}$，单位为帕斯卡：\n  1. $[50 \\times 10^6,\\ 50 \\times 10^6]$\n  2. $[450 \\times 10^6,\\ 0]$\n  3. $[200 \\times 10^6,\\ 350 \\times 10^6]$\n  4. $[380 \\times 10^6,\\ 280 \\times 10^6]$\n\n您的程序必须：\n1. 根据给定的 $\\{n_i\\}$ 和 $\\{s_k\\}$，使用上述目标和约束来构建线性规划（LP）问题，以拟合 $\\{\\alpha_i\\}_{i=1}^m$ 和 $\\{t_k\\}_{k=1}^N$，并求解该问题。\n2. 对于测试套件中的每个试探应力，按照上述方法计算塑性应变增量 $\\Delta \\varepsilon^p$。将塑性应变增量表示为无量纲数。\n3. 生成单行输出，其中包含四个测试用例的结果列表，每个结果都是一个双元素列表 $[\\Delta \\varepsilon_{xx}^p,\\ \\Delta \\varepsilon_{yy}^p]$，按此顺序排列，两个元素均为浮点数。最终格式必须是单行，用方括号括起来的逗号分隔列表。例如：“[[v11,v12],[v21,v22],[v31,v32],[v41,v42]]”。\n\n确保程序是自包含的，仅使用执行环境中指定的库，并且不需要用户输入。必须使用给定的数据和常数计算输出，并将塑性应变增量完全按照指定格式作为无量纲浮点数在单行输出中报告。", "solution": "问题陈述已解析并验证。该问题具有科学依据，提法恰当且内容自包含。它提出了一个计算弹塑性力学中标准的（尽管是简化的）问题，特别关注数据驱动的屈服面识别和回映算法的应用。其公式符合连续介质力学和凸分析的原理。我们可以着手求解。\n\n该问题分两个连续阶段解决：\n1.  **屈服面识别**：通过求解一个线性规划（LP）问题，将一个凸多面体屈服面拟合到所提供的带噪声数据点 $\\{s_k\\}_{k=1}^N$。此步骤确定了定义屈服面的未知支撑值 $\\{\\alpha_i\\}_{i=1}^m$。\n2.  **塑性流动计算**：对于每个给定的弹性试探应力 $\\sigma_{\\mathrm{tr}}$，使用拟合的屈服面来确定塑性响应。如果试探应力位于屈服面之外，则采用基于相关联流动法则的回映算法来计算塑性应变增量 $\\Delta \\varepsilon^p$。\n\n**第一阶段：用于屈服面拟合的线性规划**\n\n屈服面 $\\mathcal{Y}$ 被建模为一个凸多胞体，即 $m$ 个半空间的交集：\n$$\n\\mathcal{Y} = \\{\\sigma \\in \\mathbb{R}^2 \\mid n_i \\cdot \\sigma \\le \\alpha_i, \\quad i=1, \\dots, m\\}\n$$\n在此，单位法向量 $\\{n_i\\}_{i=1}^m$ 是预设的，而支撑值 $\\{\\alpha_i\\}_{i=1}^m$ 是待从数据 $\\{s_k\\}_{k=1}^N$ 中确定的未知参数。相应的屈服函数是 $f(\\sigma; \\alpha) = \\max_{i} (n_i \\cdot \\sigma - \\alpha_i)$。当 $f(\\sigma; \\alpha)=0$ 时，材料发生屈服。\n\n为了从带噪声的数据中找到最优的 $\\{\\alpha_i\\}$，我们构建一个线性规划问题。目标是找到一个包含所有数据点并允许一定误差的紧致屈服面（即较小的 $\\alpha_i$）。这通过引入非负松弛变量 $\\{t_k\\}_{k=1}^N$ 来实现，这些变量用于衡量每个数据点的违规程度。约束条件确保每个数据点 $s_k$（可能因松弛量相关的向量而向外移动）都位于拟合的多胞体内。这表示为：\n$$\nn_i \\cdot s_k \\le \\alpha_i + t_k \\quad \\forall i \\in \\{1,\\dots,m\\}, \\forall k \\in \\{1,\\dots,N\\}\n$$\n目标是最小化支撑值（促进紧致性，一种正则化形式）和松弛变量（促进数据保真度）的加权和：\n$$\n\\text{minimize} \\quad \\sum_{i=1}^m \\alpha_i + \\lambda \\sum_{k=1}^N t_k\n$$\n约束条件为 $\\alpha_i \\ge 0$ 和 $t_k \\ge 0$。参数 $\\lambda > 0$ 用于平衡屈服面的尺寸和拟合优度之间的权衡。\n\n该问题被转换为标准线性规划形式 `min c'x`，约束条件为 `A_ub x <= b_ub` 和 `x >= 0`。变量向量为 $x = [\\alpha_1, \\dots, \\alpha_m, t_1, \\dots, t_N]^\\top$。\n- 目标向量 $c$ 的前 $m$ 个分量等于 $1$，后 $N$ 个分量等于 $\\lambda$。\n- 约束条件可以重写为 $-\\alpha_i - t_k \\le -n_i \\cdot s_k$。对于每一对 $(i, k)$，这在不等式约束矩阵 `A_ub` 和向量 `b_ub` 中定义了一行。具体来说，对于与 $(i,k)$ 对应的行，变量 $\\alpha_i$ 所在的列为 $-1$，变量 $t_k$ 所在的列为 $-1$，所有其他项为 $0$，`b_ub` 中对应的项为 $-n_i \\cdot s_k$。\n- 所有变量的下界均为 $0$。\n\n使用 `scipy.optimize.linprog` 对该线性规划问题进行数值求解，以获得 $\\alpha_i$ 的最优值。\n\n**第二阶段：回映算法**\n\n一旦屈服面参数 $\\{\\alpha_i\\}$ 已知，我们就可以计算给定加载增量的塑性响应。在位移驱动的有限元背景下，这对应于给定的总应变增量。标准程序涉及弹性预测-塑性修正方案，即所谓的回映算法。\n\n给定一个状态 $(\\sigma_{old}, \\varepsilon^p_{old})$ 和一个总应变增量 $\\Delta \\varepsilon$，我们首先计算一个弹性试探应力：\n$$\n\\sigma_{\\mathrm{tr}} = \\sigma_{old} + \\mathbf{C} \\Delta \\varepsilon\n$$\n在本问题中，每个测试用例的 $\\sigma_{\\mathrm{tr}}$ 都是直接给定的。平面应力的弹性刚度矩阵 $\\mathbf{C}$ 为：\n$$\n\\mathbf{C} = \\frac{E}{1-\\nu^2} \\begin{bmatrix}\n1 & \\nu \\\\\n\\nu & 1\n\\end{bmatrix}\n$$\n\n接下来，我们在试探应力处评估屈服函数：$f(\\sigma_{\\mathrm{tr}}; \\alpha) = \\max_i(n_i \\cdot \\sigma_{\\mathrm{tr}} - \\alpha_i)$。\n- 如果 $f(\\sigma_{\\mathrm{tr}}; \\alpha) \\le 0$，则试探应力位于屈服面内部或其上。该步骤是纯弹性的，塑性应变增量为零：$\\Delta \\varepsilon^p = [0, 0]^\\top$。\n- 如果 $f(\\sigma_{\\mathrm{tr}}; \\alpha) > 0$，则试探应力位于屈服面之外，这是不允许的。必须发生塑性变形，以使应力状态返回到屈服面上。更新后的应力为 $\\sigma_{\\mathrm{final}} = \\sigma_{\\mathrm{tr}} - \\mathbf{C} \\Delta\\varepsilon^p$。\n\n塑性应变增量由强制正交性的相关联流动法则给出：\n$$\n\\Delta\\varepsilon^p = \\Delta\\gamma \\, \\partial_\\sigma f(\\sigma_{\\mathrm{final}})\n$$\n其中 $\\Delta\\gamma \\ge 0$ 是塑性乘子。对于我们的多面体屈服函数，如果只有一个面 $j^\\star$ 是激活的（即，$n_{j^\\star} \\cdot \\sigma_{\\mathrm{tr}} - \\alpha_{j^\\star}$ 是唯一的最大值），则次梯度就是该面的外法线，$\\partial_\\sigma f = n_{j^\\star}$。\n\n最终应力状态必须满足一致性条件 $f(\\sigma_{\\mathrm{final}}; \\alpha) = 0$。具体来说，它必须位于激活面上：\n$$\nn_{j^\\star} \\cdot \\sigma_{\\mathrm{final}} - \\alpha_{j^\\star} = 0\n$$\n将 $\\sigma_{\\mathrm{final}} = \\sigma_{\\mathrm{tr}} - \\Delta\\gamma \\mathbf{C} n_{j^\\star}$ 代入一致性条件，得到：\n$$\nn_{j^\\star} \\cdot (\\sigma_{\\mathrm{tr}} - \\Delta\\gamma \\mathbf{C} n_{j^\\star}) - \\alpha_{j^\\star} = 0\n$$\n重新整理以求解塑性乘子 $\\Delta\\gamma$：\n$$\nn_{j^\\star} \\cdot \\sigma_{\\mathrm{tr}} - \\alpha_{j^\\star} = \\Delta\\gamma (n_{j^\\star}^\\top \\mathbf{C} n_{j^\\star})\n$$\n分子恰好是激活面上的屈服函数值 $f_{j^\\star}(\\sigma_{\\mathrm{tr}})$。因此：\n$$\n\\Delta\\gamma = \\frac{n_{j^\\star} \\cdot \\sigma_{\\mathrm{tr}} - \\alpha_{j^\\star}}{n_{j^\\star}^\\top \\mathbf{C} n_{j^\\star}}\n$$\n计算出 $\\Delta\\gamma$ 后，即可求得塑性应变增量：\n$$\n\\Delta\\varepsilon^p = \\Delta\\gamma \\, n_{j^\\star}\n$$\n将此过程应用于测试套件中的每个试探应力，以获得所需结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the data-driven constitutive modeling problem.\n    1. Fits a convex polyhedral yield surface to noisy data using Linear Programming.\n    2. Computes plastic strain increments for given trial stresses using a return mapping algorithm.\n    \"\"\"\n\n    # --- Givens from the problem statement ---\n\n    # Elastic constants\n    E = 210e9  # Young's modulus in Pa\n    nu = 0.3   # Poisson's ratio\n\n    # Yield surface model parameters\n    m = 16  # Number of faces for the polytope\n    lambda_penalty = 1000.0  # Slack penalty weight\n\n    # Noisy yield data points {s_k}\n    s_data = np.array([\n        [408e6, 0],\n        [341.410e6, 154e6],\n        [206e6, 252.808e6],\n        [0, 310e6],\n        [-204e6, 265.808e6],\n        [-341.410e6, 147e6],\n        [-409e6, 0],\n        [-339.410e6, -154e6],\n        [-206e6, -267.808e6],\n        [0, -309e6],\n        [204e6, -254.808e6],\n        [343.410e6, -144e6]\n    ])\n    N = s_data.shape[0]\n\n    # Trial stresses for return mapping\n    sigma_trs = np.array([\n        [50e6, 50e6],\n        [450e6, 0],\n        [200e6, 350e6],\n        [380e6, 280e6]\n    ])\n\n    # --- Stage 1: Yield Surface Fitting via Linear Programming ---\n\n    # Generate unit normal vectors for the yield surface faces\n    angles = np.linspace(0, 2 * np.pi * (m - 1) / m, m)\n    n_vectors = np.array([np.cos(angles), np.sin(angles)]).T\n\n    # Set up the Linear Programming problem\n    # Variables: x = [alpha_1, ..., alpha_m, t_1, ..., t_N]\n    num_vars = m + N\n    \n    # Objective function: min (sum(alpha_i) + lambda * sum(t_k))\n    c = np.concatenate([np.ones(m), np.full(N, lambda_penalty)])\n\n    # Constraints: n_i . s_k <= alpha_i + t_k  =>  -alpha_i - t_k <= -n_i . s_k\n    num_constraints = m * N\n    A_ub = np.zeros((num_constraints, num_vars))\n    b_ub = np.zeros(num_constraints)\n\n    for i in range(m):\n        for k in range(N):\n            row_idx = i * N + k\n            A_ub[row_idx, i] = -1.0      # Coefficient for alpha_i\n            A_ub[row_idx, m + k] = -1.0  # Coefficient for t_k\n            b_ub[row_idx] = -np.dot(n_vectors[i], s_data[k])\n\n    # Bounds: alpha_i >= 0, t_k >= 0\n    bounds = [(0, None)] * num_vars\n\n    # Solve the LP\n    lp_result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if not lp_result.success:\n        raise RuntimeError(\"Linear programming solver failed to find a solution.\")\n\n    # Extract the fitted support values {alpha_i}\n    alphas = lp_result.x[:m]\n\n    # --- Stage 2: Return Mapping for Plastic Strain Calculation ---\n\n    # Construct the plane stress elastic stiffness matrix C\n    C_factor = E / (1 - nu**2)\n    C_matrix = C_factor * np.array([[1, nu], [nu, 1]])\n\n    results = []\n    for sigma_tr in sigma_trs:\n        # Evaluate yield function f(sigma_tr) = max_i(n_i . sigma_tr - alpha_i)\n        face_values = np.dot(n_vectors, sigma_tr) - alphas\n        f_val = np.max(face_values)\n        \n        if f_val <= 0:\n            # Elastic case: no plastic strain\n            delta_eps_p = np.array([0.0, 0.0])\n        else:\n            # Plastic case: return mapping required\n            j_star = np.argmax(face_values)\n            n_active = n_vectors[j_star]\n            \n            # Calculate plastic multiplier delta_gamma\n            denominator = n_active.T @ C_matrix @ n_active\n            delta_gamma = f_val / denominator\n            \n            # Calculate plastic strain increment\n            delta_eps_p = delta_gamma * n_active\n            \n        results.append(delta_eps_p.tolist())\n\n    # Format output as a single-line string\n    # e.g., \"[[v11,v12],[v21,v22],[v31,v32],[v41,v42]]\"\n    output_str = \"[\" + \",\".join([f\"[{v[0]},{v[1]}]\" for v in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2629338"}]}