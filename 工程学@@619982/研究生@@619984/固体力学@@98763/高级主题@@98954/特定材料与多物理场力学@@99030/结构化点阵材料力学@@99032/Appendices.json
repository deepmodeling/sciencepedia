{"hands_on_practices": [{"introduction": "点阵材料的力学稳定性不仅取决于其组成材料的强度，更深层次上由其几何构型决定。本练习将引导你运用线性代数的基本原理，来形式化这一核心思想。通过推导运动学（机构，$m$）与静力学（自应力状态，$s$）之间的深刻联系，你将掌握一个强大的计数法则，用于判断周期性桁架是稳定、欠约束还是超静定的 [@problem_id:2660252]。", "problem": "一个二维卡戈梅点阵由刚性、铰接杆件的无限周期性排列形成，这些杆件在六边形网格上组装成三角形。考虑一个周期性原胞，在无限点阵中，根据标准晶体学计数约定，该原胞每个晶胞计数一次包含 $n_{n} = 3$ 个不同节点和 $n_{b} = 6$ 个不同杆件。该点阵是平面的，节点是理想无摩擦铰链，杆件是不可伸长的。假设其具有与卡戈梅网络一致的一般几何构型（除了卡戈梅结构固有的共线性外，没有意外的共线性），并将研究限制在零布洛赫波矢情况（均匀的、晶胞周期的形变），采用周期性边界条件，使得晶胞范围的刚性平移和旋转不作为允许的内禀机构出现。\n\n定义 $m$ 为零波矢下每个晶胞的独立无穷小机构的数量（零杆件伸长模式），定义 $s$ 为每个晶胞的独立自应力态的数量（产生零节点合力的非平凡杆件张力）。设 $\\mathbf{C}$ 表示将节点位移分量映射到杆件伸长量的协调矩阵，设 $\\mathbf{A} = \\mathbf{C}^{\\mathsf{T}}$ 表示将杆件张力映射到节点力的平衡（静力）矩阵。\n\n仅从以下几点出发：\n- 一个自由平面节点具有 $d = 2$ 个位移分量的运动学计数。\n- 由秩-零度定理推导出的 $\\mathbf{C}$ 和 $\\mathbf{A}$ 的零度与秩之间的线性代数关系。\n- $m$ 和 $s$ 关于 $\\mathbf{C}$ 和 $\\mathbf{A}$ 的零空间的物理定义。\n\n推导出此周期性卡戈梅晶胞的标量 $m-s$ 并计算其数值。只报告 $m-s$ 的值。不需要四舍五入。最终答案必须是一个不带单位的整数。", "solution": "问题陈述已经过验证，是有效的。该问题有科学依据、提法恰当、客观且内部一致。它提供了推导所要求的量 $m-s$ 所需的所有必要信息。我们现在开始求解。\n\n该问题涉及周期性力学框架中无穷小机构与自应力态之间的关系。推导过程仅依赖于线性代数原理和所提供的定义。\n\n设 $\\mathbf{u}$ 为晶胞的节点位移分量向量。对于一个二维系统（$d=2$），每个晶胞有 $n_{n}$ 个节点，总自由度为 $d n_{n}$。问题陈述中说明，分析是在零布洛赫波矢下进行的，并且应用了周期性边界条件，从而排除了晶胞范围的刚性平移和旋转。因此，位移向量 $\\mathbf{u}$ 的维数是 $d n_{n}$。\n给定 $n_{n} = 3$ 和 $d=2$，$\\mathbf{u}$ 的维数是 $d n_{n} = 2 \\times 3 = 6$。所以 $\\mathbf{u} \\in \\mathbb{R}^{6}$。\n\n设 $\\mathbf{e}$ 为杆件伸长量向量。晶胞包含 $n_{b}$ 个杆件。给定 $n_{b} = 6$，伸长量向量 $\\mathbf{e}$ 的维数是 $6$。所以 $\\mathbf{e} \\in \\mathbb{R}^{6}$。\n\n协调矩阵 $\\mathbf{C}$ 根据线性关系 $\\mathbf{e} = \\mathbf{C} \\mathbf{u}$ 将节点位移映射到杆件伸长量。为了使此映射有效，矩阵 $\\mathbf{C}$ 的维度必须是 $n_{b} \\times (d n_{n})$，即 $6 \\times 6$。\n\n独立无穷小机构的数量 $m$ 定义为不引起任何杆件伸长（$\\mathbf{e} = \\mathbf{0}$）的独立非零位移向量 $\\mathbf{u}$ 的数量。这些是点阵的零能形变模式。在数学上，这些向量 $\\mathbf{u}$ 构成了协调矩阵 $\\mathbf{C}$ 的零空间（或核）。此类独立模式的数量即为此零空间的维数。\n$$m = \\dim(\\operatorname{null}(\\mathbf{C}))$$\n\n现在，考虑静力平衡。设 $\\mathbf{t}$ 为 $n_{b} = 6$ 个杆件中的标量张力向量，因此 $\\mathbf{t} \\in \\mathbb{R}^{6}$。设 $\\mathbf{f}$ 为 $n_{n}=3$ 个节点上的合力向量。由于每个节点有 $d=2$ 个力分量，力向量 $\\mathbf{f}$ 的维数是 $d n_{n} = 6$，因此 $\\mathbf{f} \\in \\mathbb{R}^{6}$。\n\n平衡矩阵 $\\mathbf{A}$ 将杆件张力映射到节点力：$\\mathbf{f} = \\mathbf{A} \\mathbf{t}$。$\\mathbf{A}$ 的维度必须是 $(d n_{n}) \\times n_{b}$，即 $6 \\times 6$。问题中指出 $\\mathbf{A} = \\mathbf{C}^{\\mathsf{T}}$，这是来自虚功原理的一个基本结果，确保了运动学和静力学之间的一致性。\n\n自应力态的数量 $s$ 定义为在所有节点上产生零合力（$\\mathbf{f} = \\mathbf{0}$）的独立非零张力向量 $\\mathbf{t}$ 的数量。这些是具有内应力但无外部载荷的平衡状态。在数学上，这些向量 $\\mathbf{t}$ 构成了平衡矩阵 $\\mathbf{A}$ 的零空间。此类独立状态的数量即为此零空间的维数。\n$$s = \\dim(\\operatorname{null}(\\mathbf{A}))$$\n\n我们现在将线性代数中的秩-零度定理应用于矩阵 $\\mathbf{C}$ 和 $\\mathbf{A}$。\n对于有 $d n_{n}$ 列的矩阵 $\\mathbf{C}$：\n$$\\operatorname{rank}(\\mathbf{C}) + \\dim(\\operatorname{null}(\\mathbf{C})) = d n_{n}$$\n代入 $m$ 的定义：\n$$\\operatorname{rank}(\\mathbf{C}) + m = d n_{n} \\quad (1)$$\n\n对于有 $n_{b}$ 列的矩阵 $\\mathbf{A}$：\n$$\\operatorname{rank}(\\mathbf{A}) + \\dim(\\operatorname{null}(\\mathbf{A})) = n_{b}$$\n代入 $s$ 的定义：\n$$\\operatorname{rank}(\\mathbf{A}) + s = n_{b} \\quad (2)$$\n\n任何矩阵的一个基本性质是其秩等于其转置矩阵的秩。由于给定 $\\mathbf{A} = \\mathbf{C}^{\\mathsf{T}}$，可得：\n$$\\operatorname{rank}(\\mathbf{A}) = \\operatorname{rank}(\\mathbf{C}^{\\mathsf{T}}) = \\operatorname{rank}(\\mathbf{C})$$\n\n设 $r = \\operatorname{rank}(\\mathbf{C}) = \\operatorname{rank}(\\mathbf{A})$ 为这两个矩阵的共同秩。\n从方程(1)中，我们可以将 $m$ 表示为：\n$$m = d n_{n} - r$$\n从方程(2)中，我们可以将 $s$ 表示为：\n$$s = n_{b} - r$$\n\n问题要求解量 $m - s$。我们将 $s$ 的表达式从 $m$ 的表达式中减去：\n$$m - s = (d n_{n} - r) - (n_{b} - r)$$\n$$m - s = d n_{n} - r - n_{b} + r$$\n$$m - s = d n_{n} - n_{b}$$\n这个结果是周期性点阵的一个一般关系，通常被称为 Maxwell-Calladine 指数定理。\n\n我们已知平面卡戈梅点阵晶胞的以下数值：\n- 空间维度：$d = 2$。\n- 每个晶胞的节点数：$n_{n} = 3$。\n- 每个晶胞的杆件数：$n_{b} = 6$。\n\n将这些值代入推导出的表达式：\n$$m - s = (2)(3) - 6$$\n$$m - s = 6 - 6$$\n$$m - s = 0$$\n\n对于指定的周期性卡戈梅晶胞，标量 $m - s$ 的值为 $0$。", "answer": "$$\\boxed{0}$$", "id": "2660252"}, {"introduction": "在掌握了线性稳定性分析之后，我们进入大变形和非线性的世界。许多超材料的奇异性能，如形状记忆和可编程刚度，源于其非线性的能量景观。本练习剖析了一个经典的力学模型，通过分析其势能函数 $U(q)$，你将亲手揭示一个简单的几何结构如何产生具有多个稳定平衡点的复杂能量景观，这是设计具有可切换力学特性材料的第一步 [@problem_id:2660237]。", "problem": "考虑一个平面内理想化的构筑晶格单胞，它由一个活动节点和两个相同的铰接细长杆件组成，杆件连接到两个固定支座。固定支座位于笛卡尔坐标系中的坐标 $\\left(-a,\\,0\\right)$ 和 $\\left(a,\\,0\\right)$ 处。活动节点被约束沿竖直对称线 $x=0$ 移动，其竖直位置为广义坐标 $q$。每个细长杆件被建模为一个轴向线性弹性弹簧，其轴向刚度为 $k$，自然（无应力）长度为 $l_{0}$。杆件通过理想无摩擦的销钉连接，不承受任何弯矩。系统没有外部载荷；系统中唯一的能量是杆件的轴向应变能。假设 $l_{0} > a$，以便该单胞能通过几何不相容性表现出双稳态特性。\n\n从固体力学的第一性原理出发，即几何运动学和轴向弹簧的应变能，推导单胞的总势能 $U(q)$ 作为广义坐标 $q$ 的函数。通过求解 $\\mathrm{d}U/\\mathrm{d}q=0$ 来确定所有驻点，并用二阶导数检验法对它们进行分类。在给定的几何条件 $l_{0} > a$ 下，找出两个稳定平衡点以及位于连接两个稳定态的最小能量路径上的不稳定平衡点。\n\n将两个稳定态之间的能垒定义为位于它们之间的不稳定平衡点与任一稳定平衡点之间的总势能差。以闭式解形式计算该能垒。\n\n以 $k$、$a$ 和 $l_{0}$ 的单个符号表达式报告能垒。如果进行数值计算，假设 $k$ 的单位为牛顿每米，$a$ 和 $l_{0}$ 的单位为米，则能量以焦耳表示。不要四舍五入；提供精确的符号结果。", "solution": "问题陈述是一个将固体力学基本原理应用于简单双稳态结构系统的适定练习。它具有科学依据、内容自洽，并且没有任何逻辑矛盾或事实错误。所有必需的参数和约束都已明确定义。因此，该问题是有效的，将从第一性原理出发推导求解。\n\n该系统由一个位于坐标 $\\left(0, q\\right)$ 的活动节点构成，该节点通过两个相同的杆件连接到位于 $\\left(-a, 0\\right)$ 和 $\\left(a, 0\\right)$ 的固定支座。节点的竖直位置 $q$ 是唯一的广义坐标。\n\n首先，我们建立运动学关系。每个杆件的长度 $l$ 是广义坐标 $q$ 的函数。根据勾股定理，活动节点 $\\left(0, q\\right)$ 与固定支座（例如 $\\left(a, 0\\right)$）之间的距离由下式给出：\n$$\nl(q) = \\sqrt{\\left(a - 0\\right)^{2} + \\left(0 - q\\right)^{2}} = \\sqrt{a^{2} + q^{2}}\n$$\n由于对称性，两个杆件的长度相同。\n\n接下来，我们建立系统的势能。每个杆件是一个轴向弹簧，刚度为 $k$，自然长度为 $l_{0}$。单个弹簧中存储的应变能 $U_{s}$ 是其伸长量的函数，伸长量是其当前长度 $l(q)$ 与自然长度 $l_{0}$ 之差。线性弹簧的应变能公式为：\n$$\nU_{s} = \\frac{1}{2} k \\left(l(q) - l_{0}\\right)^{2}\n$$\n系统的总势能 $U(q)$ 是两个相同杆件中应变能的总和。由于没有外部载荷，总势能完全是应变能。\n$$\nU(q) = 2 \\times U_{s} = 2 \\times \\frac{1}{2} k \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)^{2}\n$$\n$$\nU(q) = k \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)^{2}\n$$\n此表达式表示单胞总势能作为广义坐标 $q$ 的函数。\n\n为找到平衡构型，我们必须找到势能函数 $U(q)$ 的驻点。这可以通过求 $U(q)$ 对 $q$ 的一阶导数的根来实现。使用微分链式法则：\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}q} = k \\cdot 2 \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right) \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}q}\\left(\\sqrt{a^{2} + q^{2}}\\right)\n$$\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}q} = 2k \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right) \\left(\\frac{1}{2\\sqrt{a^{2} + q^{2}}} \\cdot 2q\\right)\n$$\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}q} = \\frac{2kq \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)}{\\sqrt{a^{2} + q^{2}}}\n$$\n令 $\\frac{\\mathrm{d}U}{\\mathrm{d}q} = 0$ 以求驻点：\n$$\n\\frac{2kq \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)}{\\sqrt{a^{2} + q^{2}}} = 0\n$$\n如果分子为零，则该方程成立。有两种可能性：\n1. $q = 0$。\n2. $\\sqrt{a^{2} + q^{2}} - l_{0} = 0 \\implies \\sqrt{a^{2} + q^{2}} = l_{0}$。\n对第二种可能性的两边进行平方，得到 $a^{2} + q^{2} = l_{0}^{2}$，从而得出 $q^{2} = l_{0}^{2} - a^{2}$。这给出了 $q$ 的两个解：\n$$\nq = \\pm\\sqrt{l_{0}^{2} - a^{2}}\n$$\n这些解是实数，因为问题陈述了 $l_{0} > a$，这确保了 $l_{0}^{2} - a^{2} > 0$。\n因此，存在三个驻点：$q_{1} = 0$，$q_{2} = \\sqrt{l_{0}^{2} - a^{2}}$ 和 $q_{3} = -\\sqrt{l_{0}^{2} - a^{2}}$。\n\n为了对这些驻点进行分类，我们使用二阶导数检验法。我们计算势能的二阶导数 $\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}$。\n从 $\\frac{\\mathrm{d}U}{\\mathrm{d}q} = 2k\\left(q - \\frac{ql_{0}}{\\sqrt{a^{2} + q^{2}}}\\right)$ 出发：\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\frac{\\mathrm{d}}{\\mathrm{d}q}\\left(q - ql_{0}\\left(a^{2} + q^{2}\\right)^{-1/2}\\right)\n$$\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\left[1 - l_{0}\\left(\\left(a^{2} + q^{2}\\right)^{-1/2} + q \\cdot \\left(-\\frac{1}{2}\\right)\\left(a^{2} + q^{2}\\right)^{-3/2}(2q)\\right)\\right]\n$$\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\left[1 - l_{0}\\left(\\frac{1}{\\sqrt{a^{2} + q^{2}}} - \\frac{q^{2}}{\\left(a^{2} + q^{2}\\right)^{3/2}}\\right)\\right]\n$$\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\left[1 - \\frac{a^{2}l_{0}}{\\left(a^{2} + q^{2}\\right)^{3/2}}\\right] = 2k \\left(1 - \\frac{a^{2}l_{0}}{\\left(a^{2} + q^{2}\\right)^{3/2}}\\right)\n$$\n现在我们在每个驻点处判断二阶导数的符号。\n- 对于 $q = 0$：\n$$\n\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q=0} = 2k \\left(1 - \\frac{a^{2}l_{0}}{\\left(a^{2}\\right)^{3/2}}\\right) = 2k \\left(1 - \\frac{a^{2}l_{0}}{a^{3}}\\right) = 2k \\left(1 - \\frac{l_{0}}{a}\\right)\n$$\n由于 $l_{0} > a$，我们有 $\\frac{l_{0}}{a} > 1$，这意味着 $\\left(1 - \\frac{l_{0}}{a}\\right) < 0$。因此，$\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q=0} < 0$，表明 $q = 0$ 对应一个不稳定平衡点（势能的局部极大值）。\n\n- 对于 $q = \\pm\\sqrt{l_{0}^{2} - a^{2}}$：\n对于这些点，我们有 $q^{2} = l_{0}^{2} - a^{2}$，这意味着 $a^{2} + q^{2} = l_{0}^{2}$。将此代入二阶导数表达式：\n$$\n\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q^{2}=l_{0}^{2}-a^{2}} = 2k \\left(1 - \\frac{a^{2}l_{0}}{\\left(l_{0}^{2}\\right)^{3/2}}\\right) = 2k \\left(1 - \\frac{a^{2}l_{0}}{l_{0}^{3}}\\right) = 2k \\left(1 - \\frac{a^{2}}{l_{0}^{2}}\\right)\n$$\n由于 $l_{0} > a$，我们有 $l_{0}^{2} > a^{2}$ 且 $\\frac{a^{2}}{l_{0}^{2}} < 1$。因此，$\\left(1 - \\frac{a^{2}}{l_{0}^{2}}\\right) > 0$。所以，$\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q=\\pm\\sqrt{l_0^2-a^2}} > 0$，表明这两点对应稳定平衡点（势能的局部极小值）。\n\n两个稳定平衡点位于 $q_{\\text{stable}} = \\pm\\sqrt{l_{0}^{2} - a^{2}}$，连接它们的不稳定平衡点位于 $q_{\\text{unstable}} = 0$。\n\n能垒 $\\Delta U$ 是不稳定平衡点和稳定平衡点之间的势能差。\n首先，我们求出稳定平衡点 $q_{\\text{stable}}$ 处的能量：\n$$\nU(q_{\\text{stable}}) = k \\left(\\sqrt{a^{2} + \\left(l_{0}^{2} - a^{2}\\right)} - l_{0}\\right)^{2} = k \\left(\\sqrt{l_{0}^{2}} - l_{0}\\right)^{2} = k \\left(l_{0} - l_{0}\\right)^{2} = 0\n$$\n在稳定平衡点处，能量为零，因为此时杆件处于其自然、无应力的长度 $l_{0}$。\n\n接下来，我们求出不稳定平衡点 $q_{\\text{unstable}} = 0$ 处的能量：\n$$\nU(q_{\\text{unstable}}) = U(0) = k \\left(\\sqrt{a^{2} + 0^{2}} - l_{0}\\right)^{2} = k \\left(a - l_{0}\\right)^{2}\n$$\n能垒是其差值：\n$$\n\\Delta U = U(q_{\\text{unstable}}) - U(q_{\\text{stable}}) = k \\left(a - l_{0}\\right)^{2} - 0 = k \\left(a - l_{0}\\right)^{2}\n$$\n该表达式等价于 $k \\left(l_{0} - a\\right)^{2}$。\n这是将杆件从其稳定、无应变的构型压缩到 $q=0$ 处的平坦构型所需的能量，从而克服几何锁定以跃迁到另一个稳定状态。", "answer": "$$\n\\boxed{k\\left(l_{0} - a\\right)^{2}}\n$$", "id": "2660237"}, {"introduction": "单个构元的设计是基础，但将它们集成为宏观系统后会涌现出怎样的新行为？本计算实践将前一练习中的非线性构元串联起来，模拟一个一维超材料长带的力学响应。你将编程实现麦克斯韦构造（Maxwell construction），并观察由双稳态单元相互作用产生的相变传播和力-位移曲线上的“麦克斯韦平台”等集体行为，从而搭建起从单胞设计到宏观材料响应之间的桥梁 [@problem_id:2660275]。", "problem": "考虑一个由 $N$ 个相同的、可弹性变形的单元串联组成的一维长条。每个单元被设计成双稳态，其无量纲弹性储能函数 $U(s;\\alpha)$ 是单元标量伸长量 $s$ 的函数，由下式给出\n$$\nU(s;\\alpha) = \\frac{(s^2 - 1)^2}{4} + \\alpha s\n$$\n其中 $\\alpha$ 是一个无量纲倾斜参数，使一个势阱相对于另一个发生偏置。该长条受到准静态位移控制，总伸长量为预设的 $\\Delta$，惯性和耗散可忽略不计。施加的反作用力 $F$ 是一个 Lagrange 乘子，用于强制满足串联单元的相容性条件。\n\n从最小势能原理和串联系统的基本平衡出发，必须确定在全局能量最小化下的载荷-位移路径 $F(\\Delta)$，并找出单个单元的两个共存平衡态具有相等 Gibbs 自由能的 Maxwell 点。仅使用无量纲变量；不需要物理单位。\n\n基本原理：\n- 在共同力 $F$ 作用下，一个单元的力-伸长量平稳性可从 Gibbs 自由能 $G(s;F) = U(s;\\alpha) - F s$ 的最小值得到。平稳性满足\n$$\n\\frac{dU}{ds}(s;\\alpha) = F\n$$\n- 对于在预设总伸长量 $\\Delta$ 下处于平衡状态的串联单元，力 $F$ 对所有单元都是共同的，且相容性条件为\n$$\n\\sum_{i=1}^N s_i = \\Delta\n$$\n其中每个 $s_i$ 都是 $G(\\cdot;F)$ 的一个局部极小值点。\n- Maxwell 力 $F_M$ 由 $G(\\cdot;F)$ 的两个共存局部极小值点 $s_a(F)$ 和 $s_b(F)$（其中 $s_a(F)  s_b(F)$）的等能量条件定义：\n$$\nG(s_a(F_M);F_M) = G(s_b(F_M);F_M)\n$$\n\n程序需要的目标推导与计算：\n- 对于给定的 $(N,\\alpha)$，计算 Maxwell 力 $F_M$ 以及相应的共存单元伸长量 $s_a(F_M)$ 和 $s_b(F_M)$，分别表示为 $s_{aM}$ 和 $s_{bM}$。\n- 在位移控制下，能量最小化的载荷-位移路径 $F(\\Delta)$ 由以下分段定义：\n  - 对于 $\\Delta \\le N\\, s_{aM}$，由 $\\Delta = N\\, s_a(F)$ 隐式决定的单相左势阱分支。\n  - 对于 $N\\, s_{aM} \\le \\Delta \\le N\\, s_{bM}$，载荷处于一个平台区 $F(\\Delta) = F_M$，此时为左、右势阱的混合状态。\n  - 对于 $\\Delta \\ge N\\, s_{bM}$，由 $\\Delta = N\\, s_b(F)$ 隐式决定的单相右势阱分支。\n这里 $s_a(F)$ 和 $s_b(F)$ 是当 $G(\\cdot;F)$ 存在两个局部极小值点时的值；在双稳态范围之外，唯一的极小值点被一致地用作左分支或右分支。\n\n您的程序必须：\n- 根据第一性原理，通过数值计算实现上述平衡条件，以计算出 $F_M$、$s_{aM}$ 和 $s_{bM}$，不得使用任何预先推导的简化公式。\n- 对于每个测试用例，在三个预设的总伸长量下评估 $F(\\Delta)$：\n  1. 一个左分支值\n  $$\n  \\Delta_L = N\\, s_{aM} - \\frac{1}{4}\\, N \\left(s_{bM} - s_{aM}\\right),\n  $$\n  2. 一个平台中点值\n  $$\n  \\Delta_M = \\frac{N}{2}\\left(s_{aM} + s_{bM}\\right),\n  $$\n  3. 一个右分支值\n  $$\n  \\Delta_R = N\\, s_{bM} + \\frac{1}{4}\\, N \\left(s_{bM} - s_{aM}\\right).\n  $$\n  报告相应的反作用力 $F(\\Delta_L)$、$F(\\Delta_M)$ 和 $F(\\Delta_R)$。\n\n数值说明：\n- 所有计算都是无量纲的。不需要物理单位。\n- 所有报告的数值结果均表示为四舍五入到 $6$ 位小数的浮点数。\n\n测试套件：\n- 使用以下三组参数集 $(N,\\alpha)$：\n  - 情况 1：$(N,\\alpha) = (8, 0)$。\n  - 情况 2：$(N,\\alpha) = (10, 0.1)$。\n  - 情况 3：$(N,\\alpha) = (6, -0.2)$。\n\n对于每种情况，您的程序必须输出一个包含 $6$ 个浮点数的列表\n$$\n\\left[F_M,\\; s_{aM},\\; s_{bM},\\; F(\\Delta_L),\\; F(\\Delta_M),\\; F(\\Delta_R)\\right],\n$$\n其中每个条目都如上文定义，四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 将这三种情况的列表聚合到单行中，形成一个列表的列表，逗号后无空格，例如\n$$\n\\left[\\left[\\cdot\\right],\\left[\\cdot\\right],\\left[\\cdot\\right]\\right].\n$$\n您的程序应生成单行输出，其中包含此聚合列表，并严格按照方括号、逗号分隔的格式打印，不含任何额外文本。", "solution": "我们从一个由设计的双稳态单元组成的串联系统的最小势能原理出发，推导其载荷-位移响应。单个单元的无量纲储能为\n$$\nU(s;\\alpha) = \\frac{(s^2-1)^2}{4} + \\alpha s\n$$\n其导数和曲率为\n$$\n\\frac{dU}{ds}(s;\\alpha) = s^3 - s + \\alpha,\\quad \\frac{d^2U}{ds^2}(s) = 3 s^2 - 1\n$$\n在共同力 $F$ 作用下，Gibbs 自由能为\n$$\nG(s;F) = U(s;\\alpha) - F s\n$$\n$G$ 的平稳点满足\n$$\n\\frac{dG}{ds} = \\frac{dU}{ds} - F = 0 \\;\\;\\Longleftrightarrow\\;\\; s^3 - s + \\alpha = F\n$$\n这个三次方程根据 $F$ 和 $\\alpha$ 的值，有一个或三个实数根。局部极小值点对应于具有正曲率 $d^2U/ds^2 = 3 s^2 - 1 > 0$ 的根，即 $|s| > 1/\\sqrt{3}$。用 $s_a(F)$ 和 $s_b(F)$ 表示两个局部极小值点，当两者都存在时，按 $s_a(F)  s_b(F)$ 排序。在双稳态范围之外，只有一个唯一的极小值点；在这种情况下，我们一致地将势垒左侧的极小值点取为 $s_a(F)$，将势垒右侧的极小值点取为 $s_b(F)$（如果适用）。\n\n对于在预设总伸长量 $\\Delta$ 下的 $N$ 个相同串联单元，通过在相容性约束条件下最小化总能量来找到平衡状态，\n$$\n\\min_{s_1,\\dots,s_N}\\;\\sum_{i=1}^N U(s_i;\\alpha)\\quad \\text{subject to}\\quad \\sum_{i=1}^N s_i = \\Delta\n$$\n为该约束引入 Lagrange 乘子 $F$，得到 Lagrangian 函数\n$$\n\\mathcal{L} = \\sum_{i=1}^N \\left(U(s_i;\\alpha) - F s_i\\right) + F \\Delta = \\sum_{i=1}^N G(s_i;F) + F \\Delta\n$$\n关于每个 $s_i$ 的平稳性条件强制要求\n$$\n\\frac{dU}{ds}(s_i;\\alpha) = F\\quad \\text{for all } i\n$$\n也就是说，每个 $s_i$ 都必须是 $G(\\cdot;F)$ 的一个平稳点（实际上是局部极小值点）。因此，在双稳态范围内的给定力 $F$ 下，每个单元独立地选择两个极小化伸长量 $s_a(F)$ 或 $s_b(F)$ 中的一个。如果有 $k$ 个单元处于右势阱的极小值点，而 $N-k$ 个单元处于左势阱的极小值点，则相容性条件得出\n$$\n\\Delta = (N-k)\\, s_a(F) + k\\, s_b(F)\n$$\n在固定力 $F$ 的情况下，对每个单元进行最小化后，最小化的 Lagrangian 函数为\n$$\n\\mathcal{L}_{\\min}(F,k) = (N-k)\\, G(s_a(F);F) + k\\, G(s_b(F);F) + F \\Delta\n$$\n为了确定 Maxwell 力，回想一下，在位移控制下的混合平台区，当力 $F$ 使得单个单元的两个相具有相等的 Gibbs 自由能时，系统达到全局能量最小值。因此，Maxwell 力 $F_M$ 由等能量条件定义\n$$\nG(s_a(F_M);F_M) = G(s_b(F_M);F_M)\n$$\n在 $F = F_M$ 时，左、右极小值点的任何混合比例 $k$ 都会得到相同的总和 $(N-k)G(s_a(F_M);F_M)+kG(s_b(F_M);F_M)$，因此 $\\mathcal{L}_{\\min}(F_M,k) = N\\, G(s_a(F_M);F_M) + F_M \\Delta$ 与 $k$ 无关。在 $F_M$ 处，通过将 $k$ 从 $0$ 变到 $N$，容许的总伸长量范围覆盖了区间\n$$\n\\Delta \\in \\left[N\\, s_a(F_M),\\; N\\, s_b(F_M)\\right]\n$$\n因此，在位移控制下，能量最小化的载荷-位移路径是分段的：\n- 对于 $\\Delta \\le N s_a(F_M)$，系统保持在单相左势阱分支，其中 $F$ 由 $\\Delta = N s_a(F)$ 隐式确定, 这会得到 $F(\\Delta)  F_M$。\n- 对于 $N s_a(F_M) \\le \\Delta \\le N s_b(F_M)$，反作用力被锁定在 Maxwell 力 $F(\\Delta) = F_M$ 上，混合比例可变。\n- 对于 $\\Delta \\ge N s_b(F_M)$，系统处于单相右势阱分支，其中 $F$ 由 $\\Delta = N s_b(F)$ 决定, 因此 $F(\\Delta) > F_M$。\n\n算法实现：\n1. 对于给定的 $\\alpha$，通过求解 $s^3 - s + \\alpha = F$ 来计算任意力 $F$ 下 $G(\\cdot;F)$ 的实数平稳点。在实数根中，使用 $3 s^2 - 1 > 0$ 来识别局部极小值点，并对它们进行排序以在可用时提取 $s_a(F)$ 和 $s_b(F)$。定义单元的 Gibbs 能量值 $G(s_a(F);F)$ 和 $G(s_b(F);F)$。\n2. 通过对函数\n$$\n\\phi(F) = G(s_b(F);F) - G(s_a(F);F),\n$$\n进行求根来确定 $F_M$，求解范围限制在存在两个极小值点的力 $F$ 的区间内。通过在对称范围内扫描 $F$，直到检测到 $\\phi(F)$ 符号相反的点，可以找到一个稳健的包围区间。然后，使用二分法类型的算法（例如，Brent 方法）可以得出 $F_M$。共存伸长量 $s_{aM}$ 和 $s_{bM}$ 分别为 $s_a(F_M)$ 和 $s_b(F_M)$。\n3. 对于任何预设的 $\\Delta$，按分段规则计算反作用力 $F(\\Delta)$：\n   - 如果 $\\Delta  N s_{aM}$，通过求解 $N s_a(F) = \\Delta$ 来反转左分支以得到 $F$，使用一个单调包围区间 $(F_{\\min}, F_M)$，其中 $F_{\\min}$ 选择足够小的负值，并在需要时扩展，直到该区间包含 $N s_a(F) - \\Delta$ 的符号变化。\n   - 如果 $N s_{aM} \\le \\Delta \\le N s_{bM}$，返回 $F(\\Delta) = F_M$。\n   - 如果 $\\Delta > N s_{bM}$，通过求解 $N s_b(F) = \\Delta$ 来反转右分支以得到 $F$，使用一个单调包围区间 $(F_M, F_{\\max})$，其中 $F_{\\max}$ 选择足够大的值，并在需要时扩展。\n\n测试套件评估：\n对于每种情况 $(N,\\alpha)$，计算 $F_M$、$s_{aM}$ 和 $s_{bM}$。然后在以下位置评估反作用力：\n$$\n\\Delta_L = N s_{aM} - \\frac{1}{4} N (s_{bM} - s_{aM}),\\quad\n\\Delta_M = \\frac{N}{2}(s_{aM} + s_{bM}),\\quad\n\\Delta_R = N s_{bM} + \\frac{1}{4} N (s_{bM} - s_{aM}).\n$$\n根据构造，$\\Delta_L$ 位于左侧单相分支上，$\\Delta_M$ 位于 Maxwell 平台上，$\\Delta_R$ 位于右侧单相分支上。对于每个测试用例，程序报告列表\n$$\n\\left[F_M,\\; s_{aM},\\; s_{bM},\\; F(\\Delta_L),\\; F(\\Delta_M),\\; F(\\Delta_R)\\right],\n$$\n所有条目均四舍五入到 $6$ 位小数。最终输出将三个列表聚合为一个列表的列表，打印在单行上，不含额外文本。\n\n该方法直接编码了串联双稳态晶格条带的第一性原理变分结构，通过相等的 Gibbs 能量来确定 Maxwell 点，并构建了包括双稳态单元之间相混合引起的平台区在内的位移控制响应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# Nondimensional single-cell energy and derivatives\ndef U(s, alpha):\n    return 0.25 * (s**2 - 1.0)**2 + alpha * s\n\ndef dU(s, alpha):\n    return s**3 - s + alpha\n\ndef d2U(s):\n    return 3.0 * s**2 - 1.0\n\ndef gibbs(s, F, alpha):\n    return U(s, alpha) - F * s\n\ndef real_roots_cubic(coeffs, tol_im=1e-12):\n    roots = np.roots(coeffs)\n    real = []\n    for r in roots:\n        if abs(r.imag)  tol_im:\n            real.append(r.real)\n    return real\n\ndef minima_at_force(F, alpha):\n    # Solve dU/ds - F = 0 = s^3 - s + (alpha - F) = 0\n    coeffs = [1.0, 0.0, -1.0, alpha - F]\n    roots = real_roots_cubic(coeffs)\n    # Identify minima by positive curvature\n    mins = []\n    for s in roots:\n        if d2U(s)  0:\n            mins.append(s)\n    mins.sort()\n    return mins  # could be length 1 or 2\n\ndef s_a(F, alpha):\n    mins = minima_at_force(F, alpha)\n    if len(mins) == 0:\n        # Numerically extremely rare; fallback: choose stationary point with largest curvature\n        coeffs = [1.0, 0.0, -1.0, alpha - F]\n        roots = real_roots_cubic(coeffs)\n        if not roots:\n            return np.nan\n        curvatures = [(d2U(s), s) for s in roots]\n        curvatures.sort()  # ascending by curvature\n        # pick the one with positive curvature if any, else the smallest s\n        for c, s in curvatures:\n            if c  0:\n                return s\n        return min(roots)\n    # left minimum is the smallest\n    return mins[0]\n\ndef s_b(F, alpha):\n    mins = minima_at_force(F, alpha)\n    if len(mins) == 0:\n        coeffs = [1.0, 0.0, -1.0, alpha - F]\n        roots = real_roots_cubic(coeffs)\n        if not roots:\n            return np.nan\n        curvatures = [(d2U(s), s) for s in roots]\n        curvatures.sort()\n        for c, s in reversed(curvatures):\n            if c  0:\n                return s\n        return max(roots)\n    # right minimum is the largest\n    return mins[-1]\n\ndef diff_gibbs(F, alpha):\n    # G_b - G_a\n    sa = s_a(F, alpha)\n    sb = s_b(F, alpha)\n    Ga = gibbs(sa, F, alpha)\n    Gb = gibbs(sb, F, alpha)\n    return Gb - Ga\n\ndef has_two_minima(F, alpha):\n    return len(minima_at_force(F, alpha)) = 2\n\ndef bracket_maxwell(alpha, F_span_init=2.0, max_span=50.0, ngrid=1001):\n    span = F_span_init\n    while span = max_span:\n        Fs = np.linspace(-span, span, ngrid)\n        vals = []\n        Fs_two = []\n        for F in Fs:\n            if has_two_minima(F, alpha):\n                Fs_two.append(F)\n                vals.append(diff_gibbs(F, alpha))\n        if len(Fs_two) = 2:\n            vals = np.array(vals)\n            Fs_two = np.array(Fs_two)\n            # Look for sign change\n            sign = np.sign(vals)\n            for i in range(len(vals) - 1):\n                if sign[i] == 0.0:\n                    # exact zero at grid point, create tiny bracket around it\n                    F0 = Fs_two[i]\n                    return (F0 - 1e-3, F0 + 1e-3)\n                if sign[i] * sign[i+1]  0:\n                    return (Fs_two[i], Fs_two[i+1])\n            # If no adjacent sign change, try global min/max signs\n            if vals.min()  0 and vals.max()  0:\n                # find indices of min and max to form a wide bracket\n                i_min = np.argmin(vals)\n                i_max = np.argmax(vals)\n                F_lo = min(Fs_two[i_min], Fs_two[i_max])\n                F_hi = max(Fs_two[i_min], Fs_two[i_max])\n                return (F_lo, F_hi)\n        span *= 1.5\n    # As a fallback, assume small tilt and near-symmetric; bracket around zero\n    return (-1.0, 1.0)\n\ndef find_maxwell(alpha):\n    F_lo, F_hi = bracket_maxwell(alpha)\n    # Ensure the bracket lies where two minima exist; shrink if necessary\n    def phi(F):\n        return diff_gibbs(F, alpha)\n    # If phi at endpoints have same sign, try to adjust endpoints inward to two-min region\n    # Use brentq with a safe guard\n    try:\n        FM = brentq(phi, F_lo, F_hi, maxiter=200, xtol=1e-12, rtol=1e-12)\n    except ValueError:\n        # Try to gently expand or shift bracket\n        expand = 0.5\n        for k in range(20):\n            a = F_lo - expand\n            b = F_hi + expand\n            try:\n                FM = brentq(phi, a, b, maxiter=200, xtol=1e-12, rtol=1e-12)\n                break\n            except ValueError:\n                expand *= 1.5\n        else:\n            # As a last resort, sample near zero and pick closest to zero diff\n            Fs = np.linspace(F_lo, F_hi, 1001)\n            diffs = np.array([abs(phi(F)) for F in Fs])\n            FM = Fs[np.argmin(diffs)]\n    saM = s_a(FM, alpha)\n    sbM = s_b(FM, alpha)\n    return FM, saM, sbM\n\ndef invert_branch_for_force(N, alpha, Delta, branch, FM, tol=1e-12):\n    # g(F) = N*s_branch(F) - Delta; solve g(F)=0 with bracketing\n    if branch == 'left':\n        def sbranch(F): return s_a(F, alpha)\n        # start bracket [FM-10, FM]\n        a = FM - 10.0\n        b = FM\n    elif branch == 'right':\n        def sbranch(F): return s_b(F, alpha)\n        a = FM\n        b = FM + 10.0\n    else:\n        raise ValueError(\"branch must be 'left' or 'right'\")\n\n    def g(F):\n        return N * sbranch(F) - Delta\n\n    # Ensure sign change\n    ga = g(a)\n    gb = g(b)\n    # Expand if needed\n    attempts = 0\n    while ga * gb  0 and attempts  50:\n        if branch == 'left':\n            a -= 10.0\n            ga = g(a)\n        else:\n            b += 10.0\n            gb = g(b)\n        attempts += 1\n    # If still no sign change, try symmetric expansion\n    if ga * gb  0:\n        a2 = a - 100.0\n        b2 = b + 100.0\n        ga2 = g(a2)\n        gb2 = g(b2)\n        if ga2 * gb2  0:\n            # As fallback, use monotone root finding by scanning\n            Fs = np.linspace(a2, b2, 5001)\n            Gs = np.array([g(F) for F in Fs])\n            idx = np.argmin(np.abs(Gs))\n            return Fs[idx]\n        else:\n            a, b = a2, b2\n            ga, gb = ga2, gb2\n    # Now solve with brentq\n    F_sol = brentq(g, a, b, xtol=tol, rtol=tol, maxiter=200)\n    return F_sol\n\ndef reaction_force(N, alpha, Delta, FM, saM, sbM, tol=1e-10):\n    left_thresh = N * saM\n    right_thresh = N * sbM\n    if Delta  left_thresh - tol:\n        return invert_branch_for_force(N, alpha, Delta, branch='left', FM=FM)\n    elif Delta  right_thresh + tol:\n        return invert_branch_for_force(N, alpha, Delta, branch='right', FM=FM)\n    else:\n        return FM\n\ndef compute_case(N, alpha):\n    FM, saM, sbM = find_maxwell(alpha)\n    # Define prescribed total extensions\n    Delta_L = N * saM - 0.25 * N * (sbM - saM)\n    Delta_M = 0.5 * N * (saM + sbM)\n    Delta_R = N * sbM + 0.25 * N * (sbM - saM)\n    FL = reaction_force(N, alpha, Delta_L, FM, saM, sbM)\n    FMid = reaction_force(N, alpha, Delta_M, FM, saM, sbM)\n    FR = reaction_force(N, alpha, Delta_R, FM, saM, sbM)\n    # Round to 6 decimals\n    out = [FM, saM, sbM, FL, FMid, FR]\n    out = [round(x + 0.0, 6) for x in out]\n    return out\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 0.0),\n        (10, 0.1),\n        (6, -0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, alpha = case\n        res = compute_case(N, alpha)\n        results.append(res)\n\n    # Format without spaces after commas\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n    s = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(s)\n\nsolve()\n```", "id": "2660275"}]}