{"hands_on_practices": [{"introduction": "在任何扩展有限元法 (XFEM) 的实现中，首要的关键步骤是精确地识别裂纹在网格中的位置，并据此对单元和节点进行分类。这个分类过程决定了哪些单元需要增强，以及应用何种特定类型的增强函数（例如，Heaviside函数或裂尖渐近函数）。本练习提供了一套基于水平集函数的具体算法，引导你完成这一至关重要的“簿记”任务，为后续的刚度矩阵和载荷向量计算奠定基础 [@problem_id:2637826]。", "problem": "您将收到一个用于扩展有限元法 (XFEM) 的平面裂纹的双水平集表示。该表示使用两个符号距离场：一个法向水平集 $\\phi(\\mathbf{x})$ 用于表示裂纹面，一个切向水平集 $\\psi(\\mathbf{x})$ 用于表示裂纹前缘（尖端）坐标。裂纹集由以下基本定义确定：\n- 实际裂纹面（内部，即已断裂的材料）是集合 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0, \\ \\psi(\\mathbf{x})  0\\}$。\n- 裂纹尖端是点集 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0, \\ \\psi(\\mathbf{x}) = 0\\}$。\n\n在节点离散化中，您将获得网格节点 $\\{i\\}$ 上的节点值 $\\{\\phi_i\\}$ 和 $\\{\\psi_i\\}$。对于每个具有节点索引集 $\\mathcal{N}(e)$ 的单元 $e$，您必须根据 $\\{\\phi_i\\}_{i \\in \\mathcal{N}(e)}$ 和 $\\{\\psi_i\\}_{i \\in \\mathcal{N}(e)}$ 的符号模式，将该单元精确地分到以下互斥类别中的一类：\n- 标准单元 ($0$)：无需与裂纹相关的富集。\n- 裂化单元 ($1$)：实际裂纹穿过单元的至少一个顶点（节点），但单元内部未被裂纹分割且不包含尖端。\n- Heaviside 单元 ($2$)：实际裂纹面分割了单元内部（裂纹面两侧位移不连续），且该单元不包含尖端。\n- 尖端单元 ($3$)：该单元包含裂纹尖端（需要近尖端渐近富集）。\n\n使用以下考虑容差的鲁棒逻辑准则。设容差为 $\\varepsilon = 10^{-7}$。定义考虑容差的符号函数\n$$\n\\operatorname{sgn}_\\varepsilon(a) = \n\\begin{cases}\n-1,  a  -\\varepsilon,\\\\\n0,  |a| \\le \\varepsilon,\\\\\n+1,  a  \\varepsilon.\n\\end{cases}\n$$\n对于单元 $e$，定义考虑容差的符号集合\n$$\nS_\\phi(e) = \\{\\operatorname{sgn}_\\varepsilon(\\phi_i) \\mid i \\in \\mathcal{N}(e)\\}, \\quad\nS_\\psi(e) = \\{\\operatorname{sgn}_\\varepsilon(\\psi_i) \\mid i \\in \\mathcal{N}(e)\\}.\n$$\n定义布尔谓词\n- $\\text{has\\_sign\\_change}(S) \\equiv (\\min S = -1) \\wedge (\\max S = +1)$，\n- $\\text{all\\_behind\\_tip}(e) \\equiv \\max\\{\\psi_i \\mid i \\in \\mathcal{N}(e)\\}  -\\varepsilon$。\n\n然后使用以下规则对单元进行分类：\n1. 当且仅当 $\\text{has\\_sign\\_change}(S_\\phi(e))$ 和 $\\text{has\\_sign\\_change}(S_\\psi(e))$ 时，为尖端单元 ($3$)。\n2. 当且仅当 $\\text{has\\_sign\\_change}(S_\\phi(e))$ 和 $\\text{all\\_behind\\_tip}(e)$ 为真且该单元不是尖端单元时，为 Heaviside 单元 ($2$)。\n3. 当且仅当该单元既不是尖端单元也不是 Heaviside 单元，且存在某个节点 $j \\in \\mathcal{N}(e)$ 满足 $|\\phi_j| \\le \\varepsilon$ 和 $\\psi_j  -\\varepsilon$ 时，为裂化单元 ($1$)。\n4. 否则为标准单元 ($0$)。\n\n接下来，根据每个节点 $i$ 在富集单元中的成员关系及其自身的水平集值，将其精确地分到以下互斥类别中的一类：\n- 标准节点 ($0$)。\n- 裂化节点 ($1$)。\n- Heaviside 节点 ($2$)。\n- 尖端节点 ($3$)。\n\n对节点使用以下具有优先顺序的规则，容差同样为 $\\varepsilon$：\n1. 尖端节点 ($3$)：节点 $i$ 属于至少一个尖端单元。\n2. 裂化节点 ($1$)：$|\\phi_i| \\le \\varepsilon$ 且 $\\psi_i  -\\varepsilon$。\n3. Heaviside 节点 ($2$)：节点 $i$ 属于至少一个 Heaviside 单元。\n4. 标准节点 ($0$)：以上条件均不适用。\n\n请在程序中实现这些规则，并将其应用于以下测试套件。网格由节点水平集值和单元连接性定义。所有数值均为无量纲单位。\n\n测试套件：\n- 容差：$\\varepsilon = 10^{-7}$。\n- 由 $i \\in \\{0,1,\\dots,11\\}$ 索引的节点及其 $(\\phi_i,\\psi_i)$ 对：\n  - $i=0$: $(+0.3,\\ -0.5)$\n  - $i=1$: $(-0.4,\\ -0.6)$\n  - $i=2$: $(+0.2,\\ -0.1)$\n  - $i=3$: $(-0.1,\\ -0.2)$\n  - $i=4$: $(0.0,\\ -0.3)$\n  - $i=5$: $(+0.2,\\ +0.1)$\n  - $i=6$: $(-0.2,\\ +0.2)$\n  - $i=7$: $(+0.05,\\ -0.05)$\n  - $i=8$: $(+0.3,\\ +0.4)$\n  - $i=9$: $(-0.3,\\ +0.3)$\n  - $i=10$: $(+10^{-8},\\ -0.4)$\n  - $i=11$: $(0.0,\\ 0.0)$\n- 由 $e \\in \\{0,1,2,3,4,5\\}$ 索引的单元及其节点索引集 $\\mathcal{N}(e)$：\n  - $e=0$: $\\{0,1,2\\}$\n  - $e=1$: $\\{2,5,6\\}$\n  - $e=2$: $\\{2,4,5\\}$\n  - $e=3$: $\\{5,8,9\\}$\n  - $e=4$: $\\{0,2,7\\}$\n  - $e=5$: $\\{2,6,11\\}$\n\n您的程序必须：\n- 精确实现上述逻辑准则，并使用指定的容差 $\\varepsilon$。\n- 生成两个整数列表：\n  - 第一个列表按索引顺序 $e=0$ 到 $e=5$ 包含单元分类，使用整数代码 $0$ (标准)，$1$ (裂化)，$2$ (Heaviside)，$3$ (尖端)。\n  - 第二个列表按索引顺序 $i=0$ 到 $i=11$ 包含节点分类，使用相同的整数代码映射。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含两个列表，格式为一个由逗号分隔的列表，并用方括号括起来，即确切格式为 $[[a_0,a_1,\\dots,a_5],[b_0,b_1,\\dots,b_{11}]]$，不含空格。\n- 每个 $a_e$ 和 $b_i$ 都必须是整数。\n\n不应读取用户输入。程序必须是自包含的，并能确定性地运行。", "solution": "所提出的问题是计算力学领域一个适定的、有科学依据的练习，具体涉及使用扩展有限元法 (XFEM) 进行裂纹分析时对有限元及其节点进行分类。所有定义、规则和数据都已提供，从而可以得出一个确定性且可验证的解。该问题是有效的。\n\n求解过程分为两个主要阶段：首先，对每个单元进行分类；其次，根据指定的逻辑准则对每个节点进行分类。\n\n基本参数是容差 $\\varepsilon = 10^{-7}$ 和节点水平集值 $(\\phi_i, \\psi_i)$。\n\n首先，我们使用以下函数为每个节点的水平集值建立考虑容差的符号：\n$$\n\\operatorname{sgn}_\\varepsilon(a) = \n\\begin{cases}\n-1,  a  -\\varepsilon \\\\\n0,  |a| \\le \\varepsilon \\\\\n+1,  a  \\varepsilon\n\\end{cases}\n$$\n所有 12 个节点的符号预计算如下：\n- 节点 $0: (\\phi_0, \\psi_0) = (+0.3, -0.5) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_0), \\operatorname{sgn}_\\varepsilon(\\psi_0)) = (+1, -1)$\n- 节点 $1: (\\phi_1, \\psi_1) = (-0.4, -0.6) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_1), \\operatorname{sgn}_\\varepsilon(\\psi_1)) = (-1, -1)$\n- 节点 $2: (\\phi_2, \\psi_2) = (+0.2, -0.1) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\psi_2)) = (+1, -1)$\n- 节点 $3: (\\phi_3, \\psi_3) = (-0.1, -0.2) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_3), \\operatorname{sgn}_\\varepsilon(\\psi_3)) = (-1, -1)$\n- 节点 $4: (\\phi_4, \\psi_4) = (0.0, -0.3) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_4), \\operatorname{sgn}_\\varepsilon(\\psi_4)) = (0, -1)$\n- 节点 $5: (\\phi_5, \\psi_5) = (+0.2, +0.1) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_5), \\operatorname{sgn}_\\varepsilon(\\psi_5)) = (+1, +1)$\n- 节点 $6: (\\phi_6, \\psi_6) = (-0.2, +0.2) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_6), \\operatorname{sgn}_\\varepsilon(\\psi_6)) = (-1, +1)$\n- 节点 $7: (\\phi_7, \\psi_7) = (+0.05, -0.05) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_7), \\operatorname{sgn}_\\varepsilon(\\psi_7)) = (+1, -1)$\n- 节点 $8: (\\phi_8, \\psi_8) = (+0.3, +0.4) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_8), \\operatorname{sgn}_\\varepsilon(\\psi_8)) = (+1, +1)$\n- 节点 $9: (\\phi_9, \\psi_9) = (-0.3, +0.3) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_9), \\operatorname{sgn}_\\varepsilon(\\psi_9)) = (-1, +1)$\n- 节点 $10: (\\phi_{10}, \\psi_{10}) = (+10^{-8}, -0.4) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_{10}), \\operatorname{sgn}_\\varepsilon(\\psi_{10})) = (0, -1)$\n- 节点 $11: (\\phi_{11}, \\psi_{11}) = (0.0, 0.0) \\implies (\\operatorname{sgn}_\\varepsilon(\\phi_{11}), \\operatorname{sgn}_\\varepsilon(\\psi_{11})) = (0, 0)$\n\n**阶段 1：单元分类**\n\n我们使用已定义的规则来分析每个单元 $e \\in \\{0, \\dots, 5\\}$，这些规则因其结构而互斥。\n\n- **单元 $e=0, \\mathcal{N}(0)=\\{0, 1, 2\\}$**：\n  - $S_\\phi(0)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_0), \\operatorname{sgn}_\\varepsilon(\\phi_1), \\operatorname{sgn}_\\varepsilon(\\phi_2)\\} = \\{+1, -1, +1\\}$。\n  - $S_\\psi(0)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_0), \\operatorname{sgn}_\\varepsilon(\\psi_1), \\operatorname{sgn}_\\varepsilon(\\psi_2)\\} = \\{-1, -1, -1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(0))$ 为真。$\\text{has\\_sign\\_change}(S_\\psi(0))$ 为假。因此，不是尖端单元。\n  - $\\text{all\\_behind\\_tip}(0)$ 为真，因为 $\\max\\{\\psi_0, \\psi_1, \\psi_2\\} = -0.1  -\\varepsilon$。\n  - 规则 2 适用：$\\text{has\\_sign\\_change}(S_\\phi)$ 为真且 $\\text{all\\_behind\\_tip}(e)$ 为真。\n  - 分类：**Heaviside 单元 (2)**。\n\n- **单元 $e=1, \\mathcal{N}(1)=\\{2, 5, 6\\}$**：\n  - $S_\\phi(1)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_5), \\operatorname{sgn}_\\varepsilon(\\phi_6)\\} = \\{+1, +1, -1\\}$。\n  - $S_\\psi(1)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_5), \\operatorname{sgn}_\\varepsilon(\\psi_6)\\} = \\{-1, +1, +1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(1))$ 为真。$\\text{has\\_sign\\_change}(S_\\psi(1))$ 为真。\n  - 规则 1 适用。\n  - 分类：**尖端单元 (3)**。\n\n- **单元 $e=2, \\mathcal{N}(2)=\\{2, 4, 5\\}$**：\n  - $S_\\phi(2)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_4), \\operatorname{sgn}_\\varepsilon(\\phi_5)\\} = \\{+1, 0, +1\\}$。\n  - $S_\\psi(2)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_4), \\operatorname{sgn}_\\varepsilon(\\psi_5)\\} = \\{-1, -1, +1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(2))$ 为假。不是尖端单元或 Heaviside 单元。\n  - 检查规则 3：对于节点 $j=4$，有 $|\\phi_4|=0.0 \\le \\varepsilon$ 且 $\\psi_4=-0.3  -\\varepsilon$。该条件满足。\n  - 分类：**裂化单元 (1)**。\n\n- **单元 $e=3, \\mathcal{N}(3)=\\{5, 8, 9\\}$**：\n  - $S_\\phi(3)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_5), \\operatorname{sgn}_\\varepsilon(\\phi_8), \\operatorname{sgn}_\\varepsilon(\\phi_9)\\} = \\{+1, +1, -1\\}$。\n  - $S_\\psi(3)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_5), \\operatorname{sgn}_\\varepsilon(\\psi_8), \\operatorname{sgn}_\\varepsilon(\\psi_9)\\} = \\{+1, +1, +1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(3))$ 为真，但 $\\text{has\\_sign\\_change}(S_\\psi(3))$ 为假。不是尖端单元。\n  - $\\text{all\\_behind\\_tip}(3)$ 为假，因为 $\\max\\{\\psi_5, \\psi_8, \\psi_9\\} = 0.4  -\\varepsilon$。不是 Heaviside 单元。\n  - 检查规则 3：没有节点 $j \\in \\{5, 8, 9\\}$ 满足 $|\\phi_j| \\le \\varepsilon$。不是裂化单元。\n  - 规则 4 适用。\n  - 分类：**标准单元 (0)**。\n\n- **单元 $e=4, \\mathcal{N}(4)=\\{0, 2, 7\\}$**：\n  - $S_\\phi(4)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_0), \\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_7)\\} = \\{+1, +1, +1\\}$。\n  - $S_\\psi(4)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_0), \\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_7)\\} = \\{-1, -1, -1\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(4))$ 为假。不是尖端单元或 Heaviside 单元。\n  - 检查规则 3：没有节点 $j \\in \\{0, 2, 7\\}$ 满足 $|\\phi_j| \\le \\varepsilon$。不是裂化单元。\n  - 规则 4 适用。\n  - 分类：**标准单元 (0)**。\n\n- **单元 $e=5, \\mathcal{N}(5)=\\{2, 6, 11\\}$**：\n  - $S_\\phi(5)=\\{\\operatorname{sgn}_\\varepsilon(\\phi_2), \\operatorname{sgn}_\\varepsilon(\\phi_6), \\operatorname{sgn}_\\varepsilon(\\phi_{11})\\} = \\{+1, -1, 0\\}$。\n  - $S_\\psi(5)=\\{\\operatorname{sgn}_\\varepsilon(\\psi_2), \\operatorname{sgn}_\\varepsilon(\\psi_6), \\operatorname{sgn}_\\varepsilon(\\psi_{11})\\} = \\{-1, +1, 0\\}$。\n  - $\\text{has\\_sign\\_change}(S_\\phi(5))$ 为真。$\\text{has\\_sign\\_change}(S_\\psi(5))$ 为真。\n  - 规则 1 适用。\n  - 分类：**尖端单元 (3)**。\n\n最终的单元分类列表为 $[2, 3, 1, 0, 0, 3]$。\n\n**阶段 2：节点分类**\n\n我们根据具有优先顺序的规则对每个节点 $i \\in \\{0, \\dots, 11\\}$ 进行分类。为此，首先构建一个节点到其所属单元的映射。\n- 尖端单元为 $\\{1, 5\\}$。\n- Heaviside 单元为 $\\{0\\}$。\n\n- **节点 0**：位于单元 $\\{0, 4\\}$ 中。规则 1 (尖端)：否。规则 2 (裂化, $|\\phi_0| \\le \\varepsilon \\land \\psi_0  -\\varepsilon $): 否 ($|\\phi_0|=0.3$)。规则 3 (Heaviside)：是，位于单元 $0$ 中。分类：**Heaviside (2)**。\n- **节点 1**：位于单元 $\\{0\\}$ 中。规则 1 (尖端)：否。规则 2 (裂化)：否 ($|\\phi_1|=0.4$)。规则 3 (Heaviside)：是，位于单元 $0$ 中。分类：**Heaviside (2)**。\n- **节点 2**：位于单元 $\\{0, 1, 2, 4, 5\\}$ 中。规则 1 (尖端)：是，位于单元 $1$ 和 $5$ 中。分类：**尖端 (3)**。\n- **节点 3**：不在任何单元中。规则 1：否。规则 2：否 ($|\\phi_3|=0.1$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 4**：位于单元 $\\{2\\}$ 中。规则 1：否。规则 2：是 ($|\\phi_4|=0.0 \\le \\varepsilon$ 且 $\\psi_4=-0.3  -\\varepsilon$)。分类：**裂化 (1)**。\n- **节点 5**：位于单元 $\\{1, 2, 3\\}$ 中。规则 1：是，位于单元 $1$ 中。分类：**尖端 (3)**。\n- **节点 6**：位于单元 $\\{1, 5\\}$ 中。规则 1：是，位于单元 $1$ 和 $5$ 中。分类：**尖端 (3)**。\n- **节点 7**：位于单元 $\\{4\\}$ 中。规则 1：否。规则 2：否 ($|\\phi_7|=0.05$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 8**：位于单元 $\\{3\\}$ 中。规则 1：否。规则 2：否 ($|\\phi_8|=0.3$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 9**：位于单元 $\\{3\\}$ 中。规则 1：否。规则 2：否 ($|\\phi_9|=0.3$)。规则 3：否。规则 4：是。分类：**标准 (0)**。\n- **节点 10**：不在任何单元中。规则 1：否。规则 2：是 ($|\\phi_{10}|=10^{-8} \\le \\varepsilon$ 且 $\\psi_{10}=-0.4  -\\varepsilon$)。分类：**裂化 (1)**。\n- **节点 11**：位于单元 $\\{5\\}$ 中。规则 1：是，位于单元 $5$ 中。分类：**尖端 (3)**。\n\n最终的节点分类列表为 $[2, 2, 3, 0, 1, 3, 3, 0, 0, 0, 1, 3]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements XFEM element and node classification based on level-set values.\n    \"\"\"\n    # Define problem data\n    TOL = 1e-7\n    NODES = np.array([\n        [+0.3,   -0.5],    # 0\n        [-0.4,   -0.6],    # 1\n        [+0.2,   -0.1],    # 2\n        [-0.1,   -0.2],    # 3\n        [0.0,    -0.3],    # 4\n        [+0.2,   +0.1],    # 5\n        [-0.2,   +0.2],    # 6\n        [+0.05,  -0.05],   # 7\n        [+0.3,   +0.4],    # 8\n        [-0.3,   +0.3],    # 9\n        [1e-8,   -0.4],    # 10\n        [0.0,    0.0],     # 11\n    ])\n    ELEMENTS = [\n        [0, 1, 2],  # 0\n        [2, 5, 6],  # 1\n        [2, 4, 5],  # 2\n        [5, 8, 9],  # 3\n        [0, 2, 7],  # 4\n        [2, 6, 11], # 5\n    ]\n\n    # --- Helper functions ---\n    def sgn_eps(a, eps):\n        if a  -eps:\n            return -1\n        if a > eps:\n            return 1\n        return 0\n\n    def has_sign_change(s):\n        return min(s) == -1 and max(s) == 1\n\n    def all_behind_tip(psi_vals, eps):\n        return max(psi_vals)  -eps\n\n    # --- Stage 1: Element Classification ---\n    elem_classifications = []\n    \n    for e_idx, node_indices in enumerate(ELEMENTS):\n        phi_vals = NODES[node_indices, 0]\n        psi_vals = NODES[node_indices, 1]\n\n        s_phi = {sgn_eps(p, TOL) for p in phi_vals}\n        s_psi = {sgn_eps(p, TOL) for p in psi_vals}\n\n        is_tip = has_sign_change(s_phi) and has_sign_change(s_psi)\n        \n        if is_tip:\n            elem_classifications.append(3) # Tip element\n            continue\n\n        is_heaviside = has_sign_change(s_phi) and all_behind_tip(psi_vals, TOL)\n        \n        if is_heaviside:\n            elem_classifications.append(2) # Heaviside element\n            continue\n\n        is_cracked = False\n        for node_idx in node_indices:\n            phi_node, psi_node = NODES[node_idx]\n            if abs(phi_node) = TOL and psi_node  -TOL:\n                is_cracked = True\n                break\n        \n        if is_cracked:\n            elem_classifications.append(1) # Cracked element\n        else:\n            elem_classifications.append(0) # Standard element\n\n    # --- Stage 2: Node Classification ---\n    \n    # Build a map from node index to a list of elements it belongs to\n    num_nodes = len(NODES)\n    node_to_elems = {i: [] for i in range(num_nodes)}\n    for e_idx, node_indices in enumerate(ELEMENTS):\n        for n_idx in node_indices:\n            node_to_elems[n_idx].append(e_idx)\n            \n    node_classifications = []\n    \n    for i in range(num_nodes):\n        # Rule 1: Tip node (belongs to at least one tip element)\n        is_tip_node = False\n        for e_idx in node_to_elems[i]:\n            if elem_classifications[e_idx] == 3:\n                is_tip_node = True\n                break\n        if is_tip_node:\n            node_classifications.append(3)\n            continue\n            \n        # Rule 2: Cracked node (based on its own level-set values)\n        phi_i, psi_i = NODES[i]\n        is_cracked_node = abs(phi_i) = TOL and psi_i  -TOL\n        if is_cracked_node:\n            node_classifications.append(1)\n            continue\n            \n        # Rule 3: Heaviside node (belongs to at least one Heaviside element)\n        is_heaviside_node = False\n        for e_idx in node_to_elems[i]:\n            if elem_classifications[e_idx] == 2:\n                is_heaviside_node = True\n                break\n        if is_heaviside_node:\n            node_classifications.append(2)\n            continue\n            \n        # Rule 4: Standard node (otherwise)\n        node_classifications.append(0)\n    \n    # Final output formatting\n    elem_str = ','.join(map(str, elem_classifications))\n    node_str = ','.join(map(str, node_classifications))\n    print(f\"[[{elem_str}],[{node_str}]]\")\n\nsolve()\n```", "id": "2637826"}, {"introduction": "在识别出需要增强的单元之后，下一步便是计算它们对系统总刚度矩阵的贡献。这个过程是XFEM计算的核心，因为它涉及到如何修正标准的应变-位移关系以包含不连续性。本练习将深入探讨一个被Heaviside函数增强的单元，指导你推导其刚度矩阵，并特别关注标准自由度与增强自由度之间的耦合项，让你亲手实践如何在子区域上进行数值积分 [@problem_id:2637785]。", "problem": "一个处于平面应变状态的二维、均质、各向同性、线弹性实体，使用边长为 $a$、单位厚度 $t=1$ 的四节点双线性四边形单元进行离散。该单元与全局坐标轴对齐，占据正方形区域 $[0,a]\\times[0,a]$。材料的杨氏模量为 $E$，泊松比为 $\\nu$。该单元被一条无牵引力的直裂纹切割，使得单元面积的 $f_{-}$ 部分位于裂纹的负侧，剩余的 $f_{+}=1-f_{-}$ 部分位于裂纹的正侧。在此区域，Heaviside 富集函数 $H(\\boldsymbol{x})$ 分别等于 $-1$ 和 $+1$。节点 1 处的 Heaviside 值为 $H_{1}=+1$（即节点 1 位于正侧）。\n\n采用扩展有限元法 (XFEM) 的位移近似，使用了带有 Heaviside 富集的单位分解。使用标准节点位移 $\\{\\boldsymbol{u}_{i}\\}$ 和富集自由度 (DOF) $\\{\\boldsymbol{a}_{j}\\}$，富集位移场为\n$$\n\\boldsymbol{u}(\\boldsymbol{x})=\\sum_{i=1}^{4} N_{i}(\\boldsymbol{x})\\,\\boldsymbol{u}_{i}+\\sum_{j\\in\\mathcal{J}} N_{j}(\\boldsymbol{x})\\big(H(\\boldsymbol{x})-H_{j}\\big)\\,\\boldsymbol{a}_{j},\n$$\n其中 $\\mathcal{J}$ 是 Heaviside 富集节点的集合，$N_{i}$ 是双线性形函数。小应变张量满足\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{x})=\\mathcal{L}\\,\\boldsymbol{u}(\\boldsymbol{x}),\n$$\n其中微分算子 $\\mathcal{L}$ 以平面应变的常规方式将位移映射到应变。本构关系为 $\\boldsymbol{\\sigma}=\\boldsymbol{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{D}$ 是平面应变弹性矩阵。忽略 $H(\\boldsymbol{x})$ 的分布梯度（该梯度仅在裂纹线上有支撑，并且对无牵引力裂纹的域刚度没有贡献），该单元被积分为两个 $H(\\boldsymbol{x})$ 为常数的不相交子域的并集。\n\n任务：\n1. 从线弹性的弱形式出发，用应变-位移矩阵表示耦合标准自由度和富集自由度的单元刚度贡献，并写出在 $H(\\boldsymbol{x})$ 为常数的子域上节点 $i$ 的应变-位移矩阵 $\\boldsymbol{B}_{i}^{\\mathrm{std}}$ 和 $\\boldsymbol{B}_{i}^{H}$。清晰地指出 Heaviside 富集是如何在每个子域上修正应变-位移关系的。\n2. 考虑单个 Heaviside 富集节点 $i=1$，计算单元刚度矩阵中耦合节点 1 的标准 $x$-自由度与节点 1 的富集 $x$-自由度的标量项，记为 $K_{(1x),(1a_{x})}^{(e)}$。在每个子域上使用单点积分，应变-位移矩阵在单元形心处求值。单元边长为 $a=10\\,\\mathrm{mm}$，$E=210\\times 10^{3}\\,\\mathrm{N/mm}^{2}$，$\\nu=0.30$，$f_{-}=0.40$，厚度 $t=1\\,\\mathrm{mm}$。用 $\\mathrm{N/mm}$ 表示最终答案，并四舍五入到四位有效数字。\n\n边长为 $a$ 的正方形上双线性形函数在形心处的梯度有用数据：在形心处，节点 1 的导数为\n$$\n\\frac{\\partial N_{1}}{\\partial x}=-\\frac{1}{2a},\\qquad \\frac{\\partial N_{1}}{\\partial y}=-\\frac{1}{2a}.\n$$", "solution": "该问题要求在扩展有限元法 (XFEM) 的背景下，分析一个用 Heaviside 函数富集的四边形单元的刚度矩阵。首先，对问题的正确性进行验证，确认其有效后，再推导求解。\n\n题目陈述提出了两项任务。第一项是概念性的，要求推导耦合刚度项并确定应变-位移矩阵。第二项是计算一个特定的刚度矩阵分量。\n\n对于第一项任务，我们从虚功原理开始。一个单元的内部虚功由下式给出\n$$ \\delta W_{\\text{int}}^{(e)} = \\int_{\\Omega^{(e)}} \\delta\\boldsymbol{\\varepsilon}^{T} \\boldsymbol{\\sigma} \\, d\\Omega $$\n其中 $\\boldsymbol{\\sigma}$ 是应力张量, $\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量, $\\Omega^{(e)}$ 是单元域。使用线弹性本构关系 $\\boldsymbol{\\sigma} = \\boldsymbol{D} \\boldsymbol{\\varepsilon}$，上式变为\n$$ \\delta W_{\\text{int}}^{(e)} = \\int_{\\Omega^{(e)}} \\delta\\boldsymbol{\\varepsilon}^{T} \\boldsymbol{D} \\boldsymbol{\\varepsilon} \\, d\\Omega $$\n位移场 $\\boldsymbol{u}(\\boldsymbol{x})$ 和虚位移场 $\\delta\\boldsymbol{u}(\\boldsymbol{x})$ 使用 XFEM 单位分解框架近似表示为：\n$$ \\boldsymbol{u}(\\boldsymbol{x})=\\sum_{i=1}^{4} N_{i}(\\boldsymbol{x})\\,\\boldsymbol{u}_{i}+\\sum_{j\\in\\mathcal{J}} N_{j}(\\boldsymbol{x})\\big(H(\\boldsymbol{x})-H_{j}\\big)\\,\\boldsymbol{a}_{j} $$\n$$ \\delta\\boldsymbol{u}(\\boldsymbol{x})=\\sum_{i=1}^{4} N_{i}(\\boldsymbol{x})\\,\\delta\\boldsymbol{u}_{i}+\\sum_{j\\in\\mathcal{J}} N_{j}(\\boldsymbol{x})\\big(H(\\boldsymbol{x})-H_{j}\\big)\\,\\delta\\boldsymbol{a}_{j} $$\n这里，$\\boldsymbol{u}_i$ 是标准节点位移，$\\boldsymbol{a}_j$ 是富集节点集 $\\mathcal{J}$ 的富集自由度 (DOF)。应变场 $\\boldsymbol{\\varepsilon} = \\mathcal{L}\\boldsymbol{u}$ 是通过应用对称梯度算子 $\\mathcal{L}$ 得到的。关键的是，题目说明要忽略 $H(\\boldsymbol{x})$ 梯度的分布部分，这对于无牵引力裂纹是标准处理程序。因此，$\\nabla(N_j(H-H_j)) \\approx (\\nabla N_j)(H-H_j)$。这导出了应变场：\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{x}) \\approx \\sum_{i=1}^{4} (\\mathcal{L}N_i) \\boldsymbol{u}_i + \\sum_{j\\in\\mathcal{J}} (H(\\boldsymbol{x})-H_j) (\\mathcal{L}N_j) \\boldsymbol{a}_j $$\n这可以写成矩阵形式：\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\sum_{i=1}^{4} \\boldsymbol{B}_{i}^{\\mathrm{std}} \\boldsymbol{u}_i + \\sum_{j\\in\\mathcal{J}} (H(\\boldsymbol{x})-H_j) \\boldsymbol{B}_{j}^{\\mathrm{std}} \\boldsymbol{a}_j $$\n其中 $\\boldsymbol{B}_{i}^{\\mathrm{std}}$ 是节点 $i$ 的标准应变-位移矩阵：\n$$ \\boldsymbol{B}_{i}^{\\mathrm{std}}(\\boldsymbol{x}) = \\begin{pmatrix} \\frac{\\partial N_{i}}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_{i}}{\\partial y} \\\\ \\frac{\\partial N_{i}}{\\partial y}  \\frac{\\partial N_{i}}{\\partial x} \\end{pmatrix} $$\n节点 $j$ 处的富集自由度对应变的贡献由 $\\boldsymbol{B}_{j}^{H}\\boldsymbol{a}_j$ 给出。从上面的应变表达式，我们确定在任何 $H(\\boldsymbol{x})$ 为常数的子域上的富集应变-位移矩阵为：\n$$ \\boldsymbol{B}_{j}^{H}(\\boldsymbol{x}) = \\big(H(\\boldsymbol{x}) - H_j\\big) \\boldsymbol{B}_{j}^{\\mathrm{std}}(\\boldsymbol{x}) $$\nHeaviside 富集通过将标准 $\\boldsymbol{B}$ 矩阵乘以分段常数因子 $(H(\\boldsymbol{x}) - H_j)$ 来修正应变-位移关系。\n\n将离散化的应变和虚应变代入内功表达式，得到单元刚度矩阵。节点 $i$ 的标准自由度 ($\\boldsymbol{u}_i$) 和节点 $j$ 的富集自由度 ($\\boldsymbol{a}_j$) 之间的耦合子矩阵由虚功表达式中的交叉项导出：$\\int_{\\Omega^{(e)}} (\\delta\\boldsymbol{\\varepsilon}^{\\text{std},i})^T \\boldsymbol{D} \\boldsymbol{\\varepsilon}^{\\text{enr},j} \\, d \\Omega$。这给出了所要求的刚度贡献：\n$$ \\boldsymbol{K}_{ij}^{\\mathrm{std}-H} = \\int_{\\Omega^{(e)}} (\\boldsymbol{B}_{i}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{j}^{H} \\, t \\, dA = \\int_{\\Omega^{(e)}} \\big(H(\\boldsymbol{x}) - H_j\\big) (\\boldsymbol{B}_{i}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{j}^{\\mathrm{std}} \\, t \\, dA $$\n这完成了第一项任务。\n\n对于第二项任务，我们必须计算特定的刚度项 $K_{(1x),(1a_{x})}^{(e)}$，它耦合了节点 1 的标准 $x$-自由度和节点 1 的富集 $x$-自由度。因此，相关节点为 $i=j=1$。刚度子矩阵为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} = \\int_{\\Omega^{(e)}} \\big(H(\\boldsymbol{x}) - H_1\\big) (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA $$\n域 $\\Omega^{(e)}$ 被分成两个子域：$H(\\boldsymbol{x})=-1$ 的 $\\Omega_{-}^{(e)}$ 和 $H(\\boldsymbol{x})=+1$ 的 $\\Omega_{+}^{(e)}$。已知 $H_1 = +1$。积分变为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} = \\int_{\\Omega_{-}^{(e)}} (-1 - 1) (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA + \\int_{\\Omega_{+}^{(e)}} (+1 - 1) (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA $$\n在 $\\Omega_{+}^{(e)}$ 上的积分为零。这简化为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} = -2 \\int_{\\Omega_{-}^{(e)}} (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\, t \\, dA $$\n我们对该积分使用单元形心 $\\boldsymbol{x}_c$ 处的单点积分。子域 $\\Omega_{-}^{(e)}$ 的面积为 $A_{-} = f_{-} A_{\\text{elem}} = f_{-} a^2$。近似值为：\n$$ \\boldsymbol{K}_{11}^{\\mathrm{std}-H} \\approx -2 \\, t \\, (f_{-} a^2) \\left[ (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}} \\right]_{\\boldsymbol{x}_c} $$\n项 $K_{(1x),(1a_{x})}^{(e)}$ 是这个 $2 \\times 2$ 矩阵的 $(1,1)$ 分量。设矩阵乘积为 $\\boldsymbol{M} = (\\boldsymbol{B}_{1}^{\\mathrm{std}})^T \\boldsymbol{D} \\boldsymbol{B}_{1}^{\\mathrm{std}}$。我们要求解分量 $M_{11}$。\n平面应变的弹性矩阵 $\\boldsymbol{D}$ 为：\n$$ \\boldsymbol{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{pmatrix} $$\n令 $D_{11} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)}$ 且 $D_{33} = \\frac{E}{2(1+\\nu)}$。\nB 矩阵在形心处的值，使用给定的导数 $\\frac{\\partial N_1}{\\partial x} = -\\frac{1}{2a}$ 和 $\\frac{\\partial N_1}{\\partial y} = -\\frac{1}{2a}$，为：\n$$ \\boldsymbol{B}_{1}^{\\mathrm{std}}|_{\\boldsymbol{x}_c} = \\begin{pmatrix} -1/(2a)  0 \\\\ 0  -1/(2a) \\\\ -1/(2a)  -1/(2a) \\end{pmatrix} $$\n乘积 $\\boldsymbol{M}$ 的 $(1,1)$ 分量是：\n$$ M_{11} = \\left( \\frac{\\partial N_1}{\\partial x} \\right)^2 D_{11} + \\left( \\frac{\\partial N_1}{\\partial y} \\right)^2 D_{33} = \\left(-\\frac{1}{2a}\\right)^2 D_{11} + \\left(-\\frac{1}{2a}\\right)^2 D_{33} = \\frac{1}{4a^2} (D_{11} + D_{33}) $$\n将此代入 $K_{(1x),(1a_{x})}^{(e)}$ 的表达式中：\n$$ K_{(1x),(1a_{x})}^{(e)} \\approx -2 \\, t \\, (f_{-} a^2) \\left[ \\frac{1}{4a^2} (D_{11} + D_{33}) \\right] = - \\frac{1}{2} f_{-} t (D_{11} + D_{33}) $$\n如预期的那样，$a^2$ 项被消掉了。现在我们合并 $(D_{11} + D_{33})$ 的各项：\n$$ D_{11} + D_{33} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} + \\frac{E}{2(1+\\nu)} = \\frac{E}{(1+\\nu)} \\left( \\frac{2(1-\\nu) + (1-2\\nu)}{2(1-2\\nu)} \\right) = \\frac{E(3-4\\nu)}{2(1+\\nu)(1-2\\nu)} $$\n刚度分量的最终符号表达式为：\n$$ K_{(1x),(1a_{x})}^{(e)} = - \\frac{1}{2} f_{-} t \\left( \\frac{E(3-4\\nu)}{2(1+\\nu)(1-2\\nu)} \\right) = - \\frac{E f_{-} t (3-4\\nu)}{4(1+\\nu)(1-2\\nu)} $$\n现在，我们代入给定的数值：$E=210\\times 10^{3}\\,\\mathrm{N/mm}^{2}$，$\\nu=0.30$，$f_{-}=0.40$，以及 $t=1\\,\\mathrm{mm}$。\n$$ K_{(1x),(1a_{x})}^{(e)} = - \\frac{(210 \\times 10^{3}) (0.40) (1) (3 - 4 \\times 0.30)}{4(1+0.30)(1 - 2 \\times 0.30)} $$\n$$ K_{(1x),(1a_{x})}^{(e)} = - \\frac{(210 \\times 10^{3}) (0.40) (1.8)}{4(1.3)(0.4)} = - \\frac{151200}{2.08} \\approx -72692.30769 \\, \\mathrm{N/mm} $$\n将结果四舍五入到四位有效数字，得到 $-72690 \\, \\mathrm{N/mm}$。", "answer": "$$\\boxed{-72690}$$", "id": "2637785"}, {"introduction": "一个完整的有限元模型不仅需要刚度矩阵（线性方程组 $K U = F$ 的“左侧”），还需要精确的载荷向量（方程组的“右侧”）。当裂纹与承受外部载荷的边界相交时，如何处理这些力成为一个实际的挑战。本练习着重于处理部分被裂纹“切断”的Neumann边界条件，演示如何正确推导一致性节点载荷向量，确保施加的牵引力功被准确无误地分配到节点上 [@problem_id:2637765]。", "problem": "考虑一个二维小应变线弹性体，该物体通过线性有限元离散化，并使用扩展有限元法 (XFEM) 进行Heaviside丰富，以表示一个无牵引力的裂纹。设某一边界边为一直线段，其长度为 $L$，由弧长坐标 $s \\in [0, L]$ 参数化，在 $s=0$ 和 $s=L$ 处有两个节点。一个均匀的给定牵引力 $\\mathbf{t}(s) = t_{0}\\,\\mathbf{e}_{y}$ 作为 Neumann 边界条件作用在此边上，其中 $t_{0}  0$ 是一个常数，$\\mathbf{e}_{y}$ 是 $y$ 方向的单位向量。\n\n一条直线裂纹与该边相交于 $s = s_{a}$ 和 $s = s_{b}$ 两点，其中 $0 \\leq s_{a}  s_{b} \\leq L$。中间子段 $[s_{a}, s_{b}]$ 是新产生的裂纹口，并且是无牵引力的；因此，Neumann 牵引力仅施加在可见的子段 $[0, s_{a}] \\cup [s_{b}, L]$ 上。沿该边的有限元插值使用与两个边界节点相关的标准线性边形函数 $N_{1}(s) = 1 - \\frac{s}{L}$ 和 $N_{2}(s) = \\frac{s}{L}$，以及每个节点的标准两个平移自由度 $(x,y)$。假设父单元中存在 Heaviside 丰富，但对于此边界牵引力，没有外部牵引力施加于丰富自由度上。\n\n从线弹性力学的虚功原理和 Neumann 边界条件的一致荷载向量的定义出发，推导此边界边对全局系统贡献的 $4 \\times 1$ 单元一致节点荷载向量的封闭形式表达式，该向量按 $\\left[r_{1x},\\, r_{1y},\\, r_{2x},\\, r_{2y}\\right]^{\\mathsf{T}}$ 顺序排列，并用 $L$、$s_{a}$、$s_{b}$ 和 $t_{0}$ 表示。您的推导必须明确说明由裂纹引起的边界部分移除，并证明在此 XFEM 丰富存在的情况下，该公式如何避免牵引力功的双重计算或遗漏。\n\n将您的最终答案表示为单个解析表达式。不需要进行数值计算或四舍五入。最终表达式中不应包含物理单位。如果出现角度，应以弧度为单位。", "solution": "该问题是有效的，因为它在科学上基于线弹性力学和有限元法，具有完整且一致的给定条件，因而是一个适定问题，并且以客观、正式的语言表述。我们可以开始求解。\n\n一致节点荷载向量 $\\mathbf{r}$ 的推导始于虚功原理。由给定牵引力向量 $\\mathbf{t}$ 在边界 $\\Gamma_t$ 上所做的外力虚功 $\\delta W_{ext}$ 由以下公式给出：\n$$ \\delta W_{ext} = \\int_{\\Gamma_t} \\mathbf{t} \\cdot \\delta\\mathbf{u} \\, d\\Gamma $$\n在有限元法的背景下，虚位移场 $\\delta\\mathbf{u}$ 是通过形函数从虚节点位移 $\\delta\\mathbf{d}$ 插值得到的。问题规定，为了计算此外力功的贡献，我们只考虑标准的、非丰富的自由度。因此，沿边界边的位移场使用标准线性形函数 $N_1(s)$ 和 $N_2(s)$ 进行近似：\n$$ \\mathbf{u}(s) = \\begin{pmatrix} u_x(s) \\\\ u_y(s) \\end{pmatrix} = \\begin{pmatrix} N_1(s)  0 \\\\ 0  N_1(s) \\end{pmatrix} \\begin{pmatrix} d_{1x} \\\\ d_{1y} \\end{pmatrix} + \\begin{pmatrix} N_2(s)  0 \\\\ 0  N_2(s) \\end{pmatrix} \\begin{pmatrix} d_{2x} \\\\ d_{2y} \\end{pmatrix} $$\n这可以写成矩阵形式 $\\mathbf{u}(s) = \\mathbf{N}(s) \\mathbf{d}$，其中 $\\mathbf{d} = \\left[d_{1x}, d_{1y}, d_{2x}, d_{2y}\\right]^{\\mathsf{T}}$ 是节点位移向量，$\\mathbf{N}(s)$ 是形函数矩阵：\n$$ \\mathbf{N}(s) = \\begin{pmatrix} N_1(s)  0  N_2(s)  0 \\\\ 0  N_1(s)  0  N_2(s) \\end{pmatrix} $$\n虚位移为 $\\delta\\mathbf{u}(s) = \\mathbf{N}(s) \\delta\\mathbf{d}$。将其代入虚功表达式，我们得到：\n$$ \\delta W_{ext} = \\int_{\\Gamma_t} \\mathbf{t}^{\\mathsf{T}} (\\mathbf{N}(s) \\delta\\mathbf{d}) \\, ds = \\delta\\mathbf{d}^{\\mathsf{T}} \\int_{\\Gamma_t} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t} \\, ds $$\n根据定义，$\\delta W_{ext} = \\delta\\mathbf{d}^{\\mathsf{T}} \\mathbf{r}$，其中 $\\mathbf{r}$ 是一致节点荷载向量。因此，\n$$ \\mathbf{r} = \\int_{\\Gamma_t} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) \\, ds $$\n问题指出，牵引力 $\\mathbf{t}(s) = t_0 \\, \\mathbf{e}_y$ 仅施加在子段 $[0, s_a] \\cup [s_b, L]$ 上。因此，积分域 $\\Gamma_t$ 是这两个区间的并集。积分必须相应地拆分：\n$$ \\mathbf{r} = \\int_{0}^{s_a} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) \\, ds + \\int_{s_b}^{L} \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) \\, ds $$\n向量和矩阵如下所示：\n$$ \\mathbf{t}(s) = \\begin{pmatrix} 0 \\\\ t_0 \\end{pmatrix}, \\quad N_1(s) = 1 - \\frac{s}{L}, \\quad N_2(s) = \\frac{s}{L} $$\n形函数矩阵的转置是：\n$$ \\mathbf{N}(s)^{\\mathsf{T}} = \\begin{pmatrix} N_1(s)  0 \\\\ 0  N_1(s) \\\\ N_2(s)  0 \\\\ 0  N_2(s) \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{s}{L}  0 \\\\ 0  1 - \\frac{s}{L} \\\\ \\frac{s}{L}  0 \\\\ 0  \\frac{s}{L} \\end{pmatrix} $$\n被积函数变为：\n$$ \\mathbf{N}(s)^{\\mathsf{T}} \\mathbf{t}(s) = \\begin{pmatrix} 1 - \\frac{s}{L}  0 \\\\ 0  1 - \\frac{s}{L} \\\\ \\frac{s}{L}  0 \\\\ 0  \\frac{s}{L} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ t_0 \\end{pmatrix} = t_0 \\begin{pmatrix} 0 \\\\ 1 - \\frac{s}{L} \\\\ 0 \\\\ \\frac{s}{L} \\end{pmatrix} $$\n荷载向量 $\\mathbf{r} = \\left[r_{1x}, r_{1y}, r_{2x}, r_{2y}\\right]^{\\mathsf{T}}$ 的分量是通过在指定域上对该向量的分量进行积分来计算的。\n$x$ 方向的分量为零，这与纯 $y$ 方向牵引力的预期相符：\n$$ r_{1x} = \\int_{\\Gamma_t} 0 \\, ds = 0 $$\n$$ r_{2x} = \\int_{\\Gamma_t} 0 \\, ds = 0 $$\n$y$ 方向上作用于节点 1 的力 $r_{1y}$ 为：\n$$ r_{1y} = \\int_{0}^{s_a} t_0 \\left(1 - \\frac{s}{L}\\right) ds + \\int_{s_b}^{L} t_0 \\left(1 - \\frac{s}{L}\\right) ds $$\n$$ r_{1y} = t_0 \\left[ s - \\frac{s^2}{2L} \\right]_{0}^{s_a} + t_0 \\left[ s - \\frac{s^2}{2L} \\right]_{s_b}^{L} $$\n$$ r_{1y} = t_0 \\left( \\left(s_a - \\frac{s_a^2}{2L}\\right) - 0 \\right) + t_0 \\left( \\left(L - \\frac{L^2}{2L}\\right) - \\left(s_b - \\frac{s_b^2}{2L}\\right) \\right) $$\n$$ r_{1y} = t_0 \\left( s_a - \\frac{s_a^2}{2L} + \\frac{L}{2} - s_b + \\frac{s_b^2}{2L} \\right) = \\frac{t_0}{2L} \\left( 2Ls_a - s_a^2 + L^2 - 2Ls_b + s_b^2 \\right) $$\n$$ r_{1y} = \\frac{t_0}{2L} \\left( L^2 - 2L(s_b - s_a) + s_b^2 - s_a^2 \\right) $$\n$y$ 方向上作用于节点 2 的力 $r_{2y}$ 为：\n$$ r_{2y} = \\int_{0}^{s_a} t_0 \\left(\\frac{s}{L}\\right) ds + \\int_{s_b}^{L} t_0 \\left(\\frac{s}{L}\\right) ds $$\n$$ r_{2y} = t_0 \\left[ \\frac{s^2}{2L} \\right]_{0}^{s_a} + t_0 \\left[ \\frac{s^2}{2L} \\right]_{s_b}^{L} $$\n$$ r_{2y} = t_0 \\left( \\frac{s_a^2}{2L} - 0 \\right) + t_0 \\left( \\frac{L^2}{2L} - \\frac{s_b^2}{2L} \\right) $$\n$$ r_{2y} = \\frac{t_0}{2L} \\left( s_a^2 + L^2 - s_b^2 \\right) $$\n\n对于外力功的计算，通过正确定义积分域 $\\Gamma_t = [0, s_a] \\cup [s_b, L]$，考虑了裂纹导致的边界部分移除。裂纹口段 $[s_a, s_b]$ 是无牵引力的，因此对功积分的贡献为零。\n\n该公式避免了重复计算或遗漏功，因为计算是基于有限元法中的标准、一致的程序。外加牵引力所做的功通过在牵引力非零的精确边界段上积分来完全计算。然后，通过虚功原理，将得到的功一致地分配给节点自由度。问题指出，牵引力功仅与标准自由度相关，这意味着丰富自由度上没有直接施加的外部节点力。这是一个常见且物理上合理的假设，即外部宏观荷载作用于由标准有限元节点表示的块体材料连续介质上，而不是作用于裂纹面丰富的数学抽象上。裂纹的几何存在通过调整后的积分限完全捕捉，而运动学丰富（Heaviside函数）则按照指示被正确地从外部荷载向量的计算中排除，从而防止了任何形式的重复计算或功的错误归属。\n\n最终组装的荷载向量为：\n$$ \\mathbf{r} = \\begin{pmatrix} 0 \\\\ \\frac{t_0}{2L} (L^2 - 2L(s_b - s_a) + s_b^2 - s_a^2) \\\\ 0 \\\\ \\frac{t_0}{2L} (L^2 + s_a^2 - s_b^2) \\end{pmatrix} $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 \\\\\n\\frac{t_0}{2L} (L^2 - 2L(s_b - s_a) + s_b^2 - s_a^2) \\\\\n0 \\\\\n\\frac{t_0}{2L} (L^2 + s_a^2 - s_b^2)\n\\end{pmatrix}\n}\n$$", "id": "2637765"}]}