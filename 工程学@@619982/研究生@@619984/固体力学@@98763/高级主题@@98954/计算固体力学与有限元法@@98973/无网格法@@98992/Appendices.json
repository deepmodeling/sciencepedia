{"hands_on_practices": [{"introduction": "在构建完整的求解器之前，我们必须验证我们核心近似方案的正确性。线性再生性质是用于求解二阶偏微分方程的任何近似方法的基石，确保其具备最基本的一致性。本练习 [@problem_id:2662008] 为您的移动最小二乘 (Moving Least Squares, MLS) 实现提供了一个关键的“单元测试”，通过验证形函数能否精确地表示线性场，为后续方法的收敛性奠定基础。", "problem": "要求您通过一个完全可复现的数值实验，在二维情况下验证移动最小二乘（MLS）无网格形函数的线性再生特性。考虑一组节点 $\\{\\mathbf{x}_I\\}_{I=1}^N \\subset \\mathbb{R}^2$ 和一个权重函数 $w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h)$，其光滑长度为 $h>0$。使用线性多项式基 $p(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$。MLS 形函数 $\\{\\phi_I(\\mathbf{x})\\}_{I=1}^N$ 的定义使得标量场 $u(\\mathbf{x})$ 的 MLS 近似为 $\\widehat{u}(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x}) u_I$，其中 $u_I = u(\\mathbf{x}_I)$。线性再生特性指出，如果 $u(\\mathbf{x})$ 是任意线性函数 $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x}$（其中 $a \\in \\mathbb{R}$ 且 $\\mathbf{b} \\in \\mathbb{R}^2$），则对于所有矩量矩阵可逆的 $\\mathbf{x}$，都有 $\\widehat{u}(\\mathbf{x}) = u(\\mathbf{x})$。\n\n您的程序必须使用高斯权重实现 MLS 形函数\n$$\nw(r;h) = \\exp\\!\\left(-\\left(\\frac{r}{h}\\right)^2\\right),\n$$\n其中 $r=\\|\\mathbf{x}-\\mathbf{x}_I\\|_2$ 且 $h>0$ 是光滑长度。设 $P \\in \\mathbb{R}^{N\\times 3}$ 是以 $p(\\mathbf{x}_I)^{\\mathsf{T}}$ 为行的矩阵，而 $W(\\mathbf{x}) \\in \\mathbb{R}^{N\\times N}$ 是以 $w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h)$ 为对角元素的对角矩阵。定义矩量矩阵 $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P \\in \\mathbb{R}^{3\\times 3}$。在 $\\mathbf{x}$ 处的 MLS 形函数行向量是\n$$\n\\boldsymbol{\\phi}(\\mathbf{x})^{\\mathsf{T}} = G(\\mathbf{x})^{\\mathsf{T}} p(\\mathbf{x}), \\quad \\text{其中 } G(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) \\in \\mathbb{R}^{3\\times N}.\n$$\n等价地，对于每个节点 $I$，标量形函数为 $\\phi_I(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} A(\\mathbf{x})^{-1} w(\\|\\mathbf{x}-\\mathbf{x}_I\\|;h) p(\\mathbf{x}_I)$。\n\n编写一个程序，对于指定的节点集、光滑长度和测试点，计算以下两个和式\n$$\nS_0(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x})\\, a,\\qquad S_1(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x})\\, \\mathbf{b}\\cdot \\mathbf{x}_I,\n$$\n并将 $S_0(\\mathbf{x}) + S_1(\\mathbf{x})$ 与精确的线性值 $a + \\mathbf{b}\\cdot \\mathbf{x}$ 进行比较。对于每个测试，报告在指定的评估点集上的最大绝对误差是否低于容差 $\\varepsilon=10^{-10}$。\n\n实现以下四个测试。所有坐标均在 $\\mathbb{R}$ 中且无量纲，因此不需要物理单位。不涉及角度。程序必须是确定性的；请使用提供的随机种子。\n\n- 测试 1 (规则网格，中等光滑，内部点)：\n  - 节点：$[0,1]\\times[0,1]$ 上的规则 $5\\times 5$ 张量网格，即，对于 $i,j\\in\\{0,1,2,3,4\\}$，$\\mathbf{x}_{i,j} = \\left(\\frac{i}{4}, \\frac{j}{4}\\right)$，因此 $N=25$。\n  - 光滑长度: $h=0.30$。\n  - 线性函数参数: $a=1.2345$, $\\mathbf{b} = (-0.5,\\, 2.2)$。\n  - 评估点：在 $[0,1]^2$ 内均匀随机生成的 $M=200$ 个点，使用种子 $11$。\n  - 输出：一个布尔值，指示 $\\max_{\\mathbf{x}} |(S_0(\\mathbf{x})+S_1(\\mathbf{x}))-(a+\\mathbf{b}\\cdot \\mathbf{x})| \\le \\varepsilon$ 是否成立。\n\n- 测试 2 (规则网格，小光滑，内部点)：\n  - 节点：与测试 1 相同的 $5\\times 5$ 网格。\n  - 光滑长度: $h=0.12$。\n  - 线性函数参数: $a=-0.9$, $\\mathbf{b}=(2.0,\\,1.5)$。\n  - 评估点：在 $[0,1]^2$ 内均匀随机生成的 $M=200$ 个点，使用种子 $22$。\n  - 输出：与测试 1 相同的布尔值。\n\n- 测试 3 (抖动网格，中等光滑，内部点)：\n  - 节点：从一个 $6\\times 6$ 网格 $\\mathbf{x}_{i,j}=\\left(\\frac{i}{5},\\frac{j}{5}\\right)$（其中 $i,j\\in\\{0,1,2,3,4,5\\}$）开始，然后为每个坐标添加 $[-0.04,0.04]$ 内的独立均匀抖动；将坐标裁剪到 $[0,1]$ 区间。使用抖动种子 $333$。\n  - 光滑长度: $h=0.25$。\n  - 线性函数参数: $a=0.0$, $\\mathbf{b}=(1.0,\\,-1.0)$。\n  - 评估点：在 $[0,1]^2$ 内均匀随机生成的 $M=400$ 个点，使用种子 $33$。\n  - 输出：与测试 1 相同的布尔值。\n\n- 测试 4 (规则网格，边界集中点)：\n  - 节点：与测试 1 相同的 $5\\times 5$ 网格。\n  - 光滑长度: $h=0.20$。\n  - 线性函数参数: $a=0.3$, $\\mathbf{b}=(0.2,\\,-0.4)$。\n  - 评估点：九个点 $\\{(0,0),(1,0),(0,1),(1,1),(0.5,0),(0.5,1),(0,0.5),(1,0.5),(0.5,0.5)\\}$。\n  - 输出：与测试 1 相同的布尔值。\n\n您的程序应生成单行输出，其中包含四个布尔结果，以逗号分隔，并用方括号括起来（例如，\"[True,True,True,True]\"）。布尔值必须完全按照测试 1 到测试 4 的顺序出现，并且每个布尔值都必须通过将该测试的最大绝对误差与 $\\varepsilon=10^{-10}$ 进行比较来计算。", "solution": "The problem statement is parsed and validated.\n\n**1. Givens Extraction**\n\n- **Method**: Moving Least Squares (MLS) in two dimensions, $\\mathbb{R}^2$.\n- **Property to Verify**: Linear reproduction for an approximant $\\widehat{u}(\\mathbf{x}) = \\sum_{I=1}^N \\phi_I(\\mathbf{x}) u_I$ of a linear scalar field $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x}$.\n- **Nodes**: A set of $N$ points $\\{\\mathbf{x}_I\\}_{I=1}^N \\subset \\mathbb{R}^2$.\n- **Basis**: Linear polynomial basis $p(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$.\n- **Weight Function**: Gaussian, $w(r;h) = \\exp(-(r/h)^2)$, where $r=\\|\\mathbf{x}-\\mathbf{x}_I\\|_2$ and $h$ is the smoothing length.\n- **Moment Matrix**: $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P$, where $P$ is the $N\\times 3$ matrix of basis functions evaluated at nodes, and $W(\\mathbf{x})$ is the $N\\times N$ diagonal matrix of weights.\n- **Shape Functions**: The vector of shape functions is $\\boldsymbol{\\phi}(\\mathbf{x})^{\\mathsf{T}} = p(\\mathbf{x})^{\\mathsf{T}} A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x})$.\n- **Verification Task**: For four specified tests, calculate the maximum absolute error $|\\left(\\sum_I \\phi_I(\\mathbf{x}) u_I\\right) - u(\\mathbf{x})|$ over a set of evaluation points and determine if this maximum error is less than or equal to a tolerance $\\varepsilon=10^{-10}$.\n- **Test $1$**: $5\\times 5$ regular grid, $h=0.30$, $a=1.2345$, $\\mathbf{b} = (-0.5, 2.2)$, $200$ random evaluation points (seed $11$).\n- **Test $2$**: $5\\times 5$ regular grid, $h=0.12$, $a=-0.9$, $\\mathbf{b}=(2.0, 1.5)$, $200$ random evaluation points (seed $22$).\n- **Test $3$**: $6\\times 6$ jittered grid (seed $333$), $h=0.25$, $a=0.0$, $\\mathbf{b}=(1.0, -1.0)$, $400$ random evaluation points (seed $33$).\n- **Test $4$**: $5\\times 5$ regular grid, $h=0.20$, $a=0.3$, $\\mathbf{b}=(0.2, -0.4)$, $9$ specific boundary and interior evaluation points.\n\n**2. Validation**\n\nThe problem statement is scientifically sound and computationally verifiable. It describes a standard numerical experiment in the field of computational mechanics to validate a correct implementation of the Moving Least Squares method. All definitions and formulas are standard and correct. All test cases are well-defined with all necessary parameters, data, and random seeds for reproducibility. The problem is self-contained, consistent, and free of any logical or scientific flaws.\n\n**3. Verdict**\n\nThe problem is **valid**. I will proceed with a complete solution.\n\n**Solution Derivation**\n\nThe objective is to numerically verify the linear reproduction property of Moving Least Squares (MLS) shape functions. This property dictates that if the function being approximated, $u(\\mathbf{x})$, is a member of the polynomial basis used to construct the approximation, the MLS approximant $\\widehat{u}(\\mathbf{x})$ must be identical to $u(\\mathbf{x})$.\n\nThe MLS approximation $\\widehat{u}(\\mathbf{x})$ is constructed as $\\widehat{u}(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x})$, where $p(\\mathbf{x}) = [1, x, y]^{\\mathsf{T}}$ is the linear basis and $\\boldsymbol{\\alpha}(\\mathbf{x})$ is a vector of coefficients determined by minimizing a weighted least-squares functional. This minimization leads to the expression $\\boldsymbol{\\alpha}(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) \\mathbf{u}$, where $\\mathbf{u}$ is the vector of nodal values $u_I = u(\\mathbf{x}_I)$.\n\nLet us consider a general linear function, $u(\\mathbf{x}) = a + \\mathbf{b}\\cdot \\mathbf{x} = a + b_x x + b_y y$. This function is an element of the space spanned by the basis $p(\\mathbf{x})$. We can write it as $u(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{c}$, where the coefficient vector is $\\boldsymbol{c} = [a, b_x, b_y]^{\\mathsf{T}}$. The value of this function at node $I$ is $u_I = u(\\mathbf{x}_I) = p(\\mathbf{x}_I)^{\\mathsf{T}} \\boldsymbol{c}$. The vector of all nodal values is thus $\\mathbf{u} = P\\boldsymbol{c}$.\n\nSubstituting this expression for $\\mathbf{u}$ into the formula for $\\boldsymbol{\\alpha}(\\mathbf{x})$ yields:\n$$\n\\boldsymbol{\\alpha}(\\mathbf{x}) = A(\\mathbf{x})^{-1} P^{\\mathsf{T}} W(\\mathbf{x}) (P\\boldsymbol{c})\n$$\nBy definition, the moment matrix is $A(\\mathbf{x}) = P^{\\mathsf{T}} W(\\mathbf{x}) P$. Substituting this into the equation gives:\n$$\n\\boldsymbol{\\alpha}(\\mathbf{x}) = (P^{\\mathsf{T}} W(\\mathbf{x}) P)^{-1} (P^{\\mathsf{T}} W(\\mathbf{x}) P) \\boldsymbol{c} = A(\\mathbf{x})^{-1} A(\\mathbf{x}) \\boldsymbol{c} = \\boldsymbol{c}\n$$\nThis holds if and only if the moment matrix $A(\\mathbf{x})$ is invertible. The result shows that the coefficient vector $\\boldsymbol{\\alpha}(\\mathbf{x})$ is constant and equal to $\\boldsymbol{c}$. The MLS approximant is then:\n$$\n\\widehat{u}(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x}) = p(\\mathbf{x})^{\\mathsf{T}} \\boldsymbol{c} = u(\\mathbf{x})\n$$\nThis confirms theoretically that $\\widehat{u}(\\mathbf{x}) = u(\\mathbf{x})$. The numerical experiment must verify that the computational error $|\\widehat{u}(\\mathbf{x}) - u(\\mathbf{x})|$ is on the order of machine precision, here bounded by the tolerance $\\varepsilon = 10^{-10}$.\n\nThe numerical implementation will proceed as follows for each test case.\nFirst, the required node set $\\{\\mathbf{x}_I\\}$, evaluation point set $\\{\\mathbf{x}_{\\text{eval}}\\}$, smoothing length $h$, and linear function parameters $a$ and $\\mathbf{b}$ are generated. The constant $N \\times 3$ matrix $P$ is constructed, with row $I$ being $[1, x_I, y_I]$. The vector of nodal values $\\mathbf{u}$ is computed, with entry $I$ being $u_I = a + \\mathbf{b}\\cdot\\mathbf{x}_I$.\n\nThen, for each evaluation point $\\mathbf{x}_{\\text{eval}}$:\n$1$. The distances $r_I = \\|\\mathbf{x}_{\\text{eval}} - \\mathbf{x}_I\\|$ are computed for all nodes $I=1, \\dots, N$.\n$2$. The corresponding weights $w_I = \\exp(-(r_I/h)^2)$ are calculated. These form the diagonal of the matrix $W(\\mathbf{x}_{\\text{eval}})$.\n$3$. The $3\\times 3$ moment matrix $A(\\mathbf{x}_{\\text{eval}}) = P^{\\mathsf{T}} W(\\mathbf{x}_{\\text{eval}}) P$ is assembled. This is efficiently computed as $\\sum_{I=1}^N w_I p(\\mathbf{x}_I) p(\\mathbf{x}_I)^{\\mathsf{T}}$.\n$4$. The coefficient vector $\\boldsymbol{\\alpha}(\\mathbf{x}_{\\text{eval}})$ is computed by solving the linear system $A(\\mathbf{x}_{\\text{eval}}) \\boldsymbol{\\alpha} = P^{\\mathsf{T}} W(\\mathbf{x}_{\\text{eval}}) \\mathbf{u}$. This is equivalent to calculating $\\boldsymbol{\\alpha} = A(\\mathbf{x}_{\\text{eval}})^{-1} (P^{\\mathsf{T}} (W(\\mathbf{x}_{\\text{eval}})\\mathbf{u}))$.\n$5$. The MLS approximant is calculated as $\\widehat{u}(\\mathbf{x}_{\\text{eval}}) = p(\\mathbf{x}_{\\text{eval}})^{\\mathsf{T}} \\boldsymbol{\\alpha}(\\mathbf{x}_{\\text{eval}})$.\n$6$. The exact value $u(\\mathbf{x}_{\\text{eval}}) = a + \\mathbf{b}\\cdot\\mathbf{x}_{\\text{eval}}$ is determined.\n$7$. The absolute error $|\\widehat{u}(\\mathbf{x}_{\\text{eval}}) - u(\\mathbf{x}_{\\text{eval}})|$ is computed.\n\nAfter iterating through all evaluation points, the maximum absolute error is found and compared against the tolerance $\\varepsilon=10^{-10}$. The boolean result of this comparison is reported for each of the four tests.", "answer": "```python\nimport numpy as np\n\ndef run_mls_reproduction_test(nodes, h, a, b_vec, eval_points, tol):\n    \"\"\"\n    Performs a numerical test of the MLS linear reproduction property.\n\n    Args:\n        nodes (np.ndarray): N-by-2 array of node coordinates.\n        h (float): Smoothing length for the Gaussian weight function.\n        a (float): Constant term of the linear function u(x) = a + b.x.\n        b_vec (np.ndarray): 2-element array for the linear term of u(x).\n        eval_points (np.ndarray): M-by-2 array of evaluation point coordinates.\n        tol (float): Error tolerance for the verification.\n\n    Returns:\n        bool: True if the max absolute error is within the tolerance, False otherwise.\n    \"\"\"\n    N = nodes.shape[0]\n\n    # Construct the P matrix (N x 3) where row I is [1, x_I, y_I]\n    P = np.hstack([np.ones((N, 1)), nodes])\n\n    # Pre-compute nodal values of the linear function u_I = a + b . x_I\n    u_nodes = a + nodes @ b_vec\n\n    max_error = 0.0\n\n    for x_eval in eval_points:\n        # Calculate distances from the evaluation point to all nodes\n        dists = np.linalg.norm(x_eval - nodes, axis=1)\n        \n        # Calculate Gaussian weights\n        weights = np.exp(-(dists / h)**2)\n\n        # Assemble the moment matrix A(x) = P^T W(x) P\n        # W is a diagonal matrix, so W*P is equivalent to scaling rows of P by weights.\n        # A more efficient way is P.T @ (weights_as_column * P)\n        A = P.T @ (weights[:, np.newaxis] * P)\n\n        # The problem setup ensures A is invertible. For robustness, one\n        # might check the determinant or condition number.\n        # If det(A) is close to zero, numerical issues may arise.\n        if np.linalg.det(A) < 1e-30:\n            # This indicates a potential singularity; the reproduction would fail.\n            # We set a large error to ensure the test fails.\n            max_error = np.inf\n            break\n            \n        # Invert the moment matrix\n        A_inv = np.linalg.inv(A)\n\n        # Calculate the coefficient vector alpha(x) = A(x)^-1 * P^T * W(x) * u\n        # The term W(x) * u is an element-wise product of weights and nodal values\n        pT_W_u = P.T @ (weights * u_nodes)\n        alpha = A_inv @ pT_W_u\n\n        # Calculate the MLS approximation at x_eval\n        # p_eval is the basis vector [1, x, y] at the evaluation point\n        p_eval = np.array([1.0, x_eval[0], x_eval[1]])\n        u_hat = p_eval @ alpha\n\n        # Calculate the exact value of the linear function\n        u_exact = a + x_eval @ b_vec\n\n        # Compute the absolute error and update the maximum\n        error = np.abs(u_hat - u_exact)\n        if error > max_error:\n            max_error = error\n\n    return max_error <= tol\n\ndef solve():\n    \"\"\"\n    Sets up and runs the four test cases specified in the problem,\n    and prints the results in the required format.\n    \"\"\"\n    TOLERANCE = 1e-10\n\n    # --- Test Case Data Generation ---\n\n    # Nodes for Tests 1, 2, 4: Regular 5x5 grid\n    grid_pts_5x5 = np.linspace(0.0, 1.0, 5)\n    X5, Y5 = np.meshgrid(grid_pts_5x5, grid_pts_5x5)\n    nodes_5x5 = np.vstack([X5.ravel(), Y5.ravel()]).T\n\n    # Nodes for Test 3: Jittered 6x6 grid\n    grid_pts_6x6 = np.linspace(0.0, 1.0, 6)\n    X6, Y6 = np.meshgrid(grid_pts_6x6, grid_pts_6x6)\n    nodes_6x6_base = np.vstack([X6.ravel(), Y6.ravel()]).T\n    rng_jitter = np.random.default_rng(333)\n    jitter = rng_jitter.uniform(-0.04, 0.04, size=nodes_6x6_base.shape)\n    nodes_6x6_jittered = np.clip(nodes_6x6_base + jitter, 0.0, 1.0)\n    \n    # Evaluation points for Test 4\n    eval_pts_test4 = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0],\n        [0.5, 0.0], [0.5, 1.0], [0.0, 0.5], [1.0, 0.5],\n        [0.5, 0.5]\n    ])\n\n    test_cases_params = [\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.30,\n            \"a\": 1.2345,\n            \"b\": np.array([-0.5, 2.2]),\n            \"eval_points\": np.random.default_rng(11).uniform(0.0, 1.0, size=(200, 2))\n        },\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.12,\n            \"a\": -0.9,\n            \"b\": np.array([2.0, 1.5]),\n            \"eval_points\": np.random.default_rng(22).uniform(0.0, 1.0, size=(200, 2))\n        },\n        {\n            \"nodes\": nodes_6x6_jittered,\n            \"h\": 0.25,\n            \"a\": 0.0,\n            \"b\": np.array([1.0, -1.0]),\n            \"eval_points\": np.random.default_rng(33).uniform(0.0, 1.0, size=(400, 2))\n        },\n        {\n            \"nodes\": nodes_5x5,\n            \"h\": 0.20,\n            \"a\": 0.3,\n            \"b\": np.array([0.2, -0.4]),\n            \"eval_points\": eval_pts_test4\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result = run_mls_reproduction_test(\n            params[\"nodes\"],\n            params[\"h\"],\n            params[\"a\"],\n            params[\"b\"],\n            params[\"eval_points\"],\n            TOLERANCE\n        )\n        results.append(result)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "2662008"}, {"introduction": "在验证了近似方案的有效性之后，我们现在可以着手构建一个完整的求解器。本练习将应用无单元伽辽金 (Element-Free Galerkin, EFG) 方法，该方法将 MLS 近似与伽辽金弱形式相结合，以求解一个一维弹性静力学问题。通过从第一性原理出发实现一个一维杆求解器 [@problem_id:2662012]，您将综合运用无网格方法的所有核心要素：形函数的构建、背景网格上的数值积分以及基本边界条件的施加。", "problem": "实现一个完整的一维无单元伽辽金 (EFG) 求解器，用于求解线性弹性静力学中的棱柱杆问题。该杆占据区间 $\\left[0,L\\right]$，具有恒定的杨氏模量 $E$ 和横截面积 $A$，承受恒定的体力密度 $b$（单位体积的力），并具有本质（Dirichlet）边界条件 $u(0)=0$ 和 $u(L)=\\bar{u}$。使用移动最小二乘 (MLS) 近似，配合线性多项式基和紧支集权函数来构造无网格形函数，并通过拉格朗日乘子法施加本质边界条件。在 $L^2$ 意义下，将计算得到的位移场与解析解进行比较。所有输入必须采用国际单位制 (SI)：$E$ 的单位为帕斯卡，$A$ 的单位为 $\\mathrm{m}^2$，$L$ 的单位为 $\\mathrm{m}$，$b$ 的单位为 $\\mathrm{N}/\\mathrm{m}^3$，$\\bar{u}$ 的单位为 $\\mathrm{m}$。最终输出必须是无量纲量。\n\n出发点（基本依据）：使用小应变、线性弹性、材料属性恒定的一维杆的平衡强形式，表示为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(EA\\,\\frac{\\mathrm{d}u}{\\mathrm{d}x}\\right)+A\\,b=0\\quad\\text{in}\\ \\left(0,L\\right),\n$$\n以及本质边界条件 $u(0)=0$ 和 $u(L)=\\bar{u}$。通过乘以一个容许的虚位移 $v$ 并在域上积分来推导弱形式。从弱形式出发，构建 EFG 离散化，使用 MLS 近似（线性多项式基、紧支集权函数）、用于数值积分的背景（基于单元的）高斯求积，以及用于本质边界条件的拉格朗日乘子。不要使用任何跳过从弱形式推导过程的、预先推导出的无网格刚度或形函数公式。\n\n数值方法要求：\n- 使用 MLS 近似，基函数为线性基 $p(x)=[1,x]^{\\top}$，权函数为紧支集光滑权函数，其影响域半径为 $d=\\alpha\\,h$，其中 $h$ 是节点间距，$\\alpha>0$ 是一个给定的无量纲影响参数。\n- 使用划分区间 $\\left[0,L\\right]$ 的背景单元进行数值求积；根据每个测试用例的指示，在每个单元上采用 $2$ 点或 $3$ 点的 Gauss–Legendre 求积。\n- 通过拉格朗日乘子施加本质边界条件，从而得到一个增广线性系统。不要通过直接代入来消去自由度，因为 EFG 形函数在边界上不满足克罗内克-德尔塔 (Kronecker-delta) 性质。\n- 通过求解带有给定本质边界条件的常微分方程，计算恒定 $E$、$A$ 和 $b$ 时的解析位移场。\n- 通过域上位移的相对 $L^2$ 误差来衡量精度，其定义为\n$$\n\\varepsilon_{L^2}=\\sqrt{\\frac{\\int_{0}^{L}\\left(u_h(x)-u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}{\\int_{0}^{L}\\left(u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}},\n$$\n使用与组装时相同的背景高斯求积来近似计算该误差。将每个测试用例的此误差报告为浮点数。\n\n测试套件：\n您的程序必须求解以下四个测试用例，并将结果汇总到单行输出中。\n\n- 测试 1 (具有中等体力的一般情况)：\n  - $E=70\\times 10^9$, $A=5\\times 10^{-4}$, $L=1.0$, $b=1\\times 10^4$, $\\bar{u}=1\\times 10^{-3}$, 节点数 $n=31$, 影响参数 $\\alpha=2.0$, 每单元高斯点数 $=3$。\n- 测试 2 (零体力，纯运动学边界数据)：\n  - $E=210\\times 10^9$, $A=1\\times 10^{-3}$, $L=2.0$, $b=0.0$, $\\bar{u}=2\\times 10^{-3}$, $n=21$, $\\alpha=2.0$, 每单元高斯点数 $=2$。\n- 测试 3 ($x=L$ 处位移为零且体力非零)：\n  - $E=100\\times 10^9$, $A=2\\times 10^{-4}$, $L=0.5$, $b=2\\times 10^5$, $\\bar{u}=0.0$, $n=15$, $\\alpha=2.5$, 每单元高斯点数 $=3$。\n- 测试 4 (为探究鲁棒性采用较粗的离散化)：\n  - $E=200\\times 10^9$, $A=8\\times 10^{-4}$, $L=1.5$, $b=5\\times 10^4$, $\\bar{u}=5\\times 10^{-4}$, $n=7$, $\\alpha=2.5$, 每单元高斯点数 $=3$。\n\n用于验证的解析解：\n对于恒定的 $E$、$A$ 和 $b$，解析位移 $u_{\\mathrm{exact}}(x)$ 是 $EA\\,u''(x)+A\\,b=0$ 在 $u(0)=0$ 和 $u(L)=\\bar{u}$ 条件下的解。该解具有二次形式\n$$\nu_{\\mathrm{exact}}(x)=-\\frac{b}{2E}\\,x^2+\\left(\\frac{\\bar{u}}{L}+\\frac{bL}{2E}\\right)x.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表... 每个条目必须是对应一个测试用例的相对 $L^2$ 误差 $\\varepsilon_{L^2}$，以科学记数法书写，小数点后恰好有 $6$ 位数字（例如，`[1.234567e-04,2.345678e-05,...]`）。条目的顺序必须与上述测试用例的顺序相同。\n\n澄清与约束：\n- 不涉及角度，因此不需要角度单位。\n- 所有报告的误差都是无量纲的。\n- 您的实现必须是自包含的，除了指定的输入外，不得依赖任何外部数据。", "solution": "对问题描述进行了严格审查，认定其有效。它提出了一个适定的一维线性弹性静力学边值问题，并为此提供了一套完整的物理参数、边界条件和数值规格。任务是构建并应用无单元伽辽金 (EFG) 求解器，这是计算力学中一种标准的、科学上可靠的方法。该问题是客观、自包含的，并且没有科学或逻辑上的不一致之处。\n\n求解过程首先从控制微分方程推导积分弱形式。随后，使用移动最小二乘 (MLS) 近似来建立 EFG 离散化。通过拉格朗日乘子法施加本质边界条件，得到一个增广线性方程组。该系统使用数值求积进行组装，然后求解。最后，通过计算与所提供解析解的相对 $L^2$ 误差来量化数值解的精度。\n\n对于轴向刚度 $EA$ 和体力密度 $b$ 恒定的一维杆，其平衡方程的强形式为：\n$$\nEA \\frac{\\mathrm{d}^2u}{\\mathrm{d}x^2} + Ab = 0 \\quad \\text{for} \\ x \\in (0, L)\n$$\n并带有本质边界条件 $u(0)=0$ 和 $u(L)=\\bar{u}$。\n\n为推导弱形式，我们用一个任意的虚位移（检验函数）$v(x)$ 乘以方程，并在域 $\\Omega = [0, L]$ 上积分：\n$$\n\\int_{0}^{L} v \\left( EA \\frac{\\mathrm{d}^2u}{\\mathrm{d}x^2} + Ab \\right) \\mathrm{d}x = 0\n$$\n对第一项应用分部积分得到：\n$$\n\\int_{0}^{L} EA v \\frac{\\mathrm{d}^2u}{\\mathrm{d}x^2} \\mathrm{d}x = \\left[ EA v \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\right]_0^L - \\int_{0}^{L} EA \\frac{\\mathrm{d}v}{\\mathrm{d}x} \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\mathrm{d}x\n$$\n将其代回，得到弱形式：寻找满足本质边界条件的 $u$，使得对于所有容许的 $v$：\n$$\n\\int_{0}^{L} EA \\frac{\\mathrm{d}v}{\\mathrm{d}x} \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\mathrm{d}x = \\int_{0}^{L} v Ab \\, \\mathrm{d}x + \\left[ v EA \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\right]_0^L\n$$\n变分法或最小势能原理是等效的。势能泛函 $\\Pi$ 为：\n$$\n\\Pi(u) = \\frac{1}{2} \\int_{0}^{L} EA \\left( \\frac{\\mathrm{d}u}{\\mathrm{d}x} \\right)^2 \\mathrm{d}x - \\int_{0}^{L} u Ab \\, \\mathrm{d}x\n$$\n解 $u(x)$ 在满足边界条件的约束下使 $\\Pi(u)$ 最小化。\n\n在无单元伽辽金法中，位移场 $u(x)$ 由一个使用移动最小二乘 (MLS) 格式构建的试探函数 $u_h(x)$ 来近似。域被一组 $n$ 个节点 $\\{x_I\\}_{I=1}^n$ 离散化。近似解 $u_h(x)$ 表示为形函数 $\\Phi_I(x)$ 和节点参数值 $\\hat{u}_I$ 的线性组合：\n$$\nu_h(x) = \\sum_{I=1}^{n} \\Phi_I(x) \\hat{u}_I = \\mathbf{\\Phi}(x)^\\top \\hat{\\mathbf{u}}\n$$\nMLS 形函数 $\\Phi_I(x)$ 的构造如下。在任意点 $x$，近似解被局部表示为一个多项式，此处选择为线性多项式：$u_h(x, \\mathbf{a}) = \\mathbf{p}(x)^\\top \\mathbf{a}(x)$，其中 $\\mathbf{p}(x) = [1, x]^\\top$ 是基向量，$\\mathbf{a}(x)$ 是系数。这些系数通过最小化局部近似与节点参数 $\\hat{u}_I$ 之间差异的加权离散 $L_2$ 范数来确定：\n$$\nJ(\\mathbf{a}) = \\sum_{I=1}^{n} w(x - x_I) \\left[ \\mathbf{p}(x_I)^\\top \\mathbf{a}(x) - \\hat{u}_I \\right]^2\n$$\n其中 $w$ 是一个紧支集权函数。驻值条件 $\\frac{\\partial J}{\\partial \\mathbf{a}} = \\mathbf{0}$ 产生系数 $\\mathbf{a}(x) = \\mathbf{M}(x)^{-1} \\mathbf{B}(x) \\hat{\\mathbf{u}}$，其中矩量矩阵 $\\mathbf{M}(x)$ 和矩阵 $\\mathbf{B}(x)$ 定义为：\n$$\n\\mathbf{M}(x) = \\sum_{I=1}^{n} w(x-x_I) \\mathbf{p}(x_I) \\mathbf{p}(x_I)^\\top\n$$\n$$\n\\mathbf{B}(x)_{iJ} = w(x-x_J) p_i(x_J)\n$$\n因此，形函数向量为 $\\mathbf{\\Phi}(x)^\\top = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\mathbf{B}(x)$，由此可得节点 $I$ 的单个形函数为：\n$$\n\\Phi_I(x) = \\mathbf{p}(x)^\\top \\mathbf{M}(x)^{-1} \\mathbf{p}(x_I) w(x-x_I)\n$$\n弱形式需要形函数的导数，可通过链式法则求得：\n$$\n\\Phi_I'(x) = \\left( (\\mathbf{p}')^\\top \\mathbf{M}^{-1} - \\mathbf{p}^\\top \\mathbf{M}^{-1} \\mathbf{M}' \\mathbf{M}^{-1} \\right) \\mathbf{p}(x_I) w(x-x_I) + \\left( \\mathbf{p}^\\top \\mathbf{M}^{-1} \\mathbf{p}(x_I) \\right) w'(x-x_I)\n$$\n其中 $\\mathbf{p}'(x)=[0, 1]^\\top$，$\\mathbf{M}'(x) = \\sum_I w'(x-x_I) \\mathbf{p}(x_I)\\mathbf{p}(x_I)^\\top$。在本实现中，使用四次样条权函数，其定义在归一化距离 $s = |x-x_I|/d \\in [0, 1]$ 上，其中 $d$ 是影响域半径。\n\nMLS 形函数的一个关键性质是 $\\Phi_I(x_J) \\neq \\delta_{IJ}$（克罗内克-德尔塔）。因此，不能通过简单设置节点参数值来施加本质边界条件。我们使用拉格朗日乘子法。引入增广势能泛函 $\\Pi^*$：\n$$\n\\Pi^*(\\hat{\\mathbf{u}}, \\boldsymbol{\\lambda}) = \\Pi(u_h) + \\lambda_1 \\left( \\sum_{I=1}^{n} \\Phi_I(0)\\hat{u}_I - 0 \\right) + \\lambda_2 \\left( \\sum_{I=1}^{n} \\Phi_I(L)\\hat{u}_I - \\bar{u} \\right)\n$$\n其中 $\\boldsymbol{\\lambda} = [\\lambda_1, \\lambda_2]^\\top$ 是拉格朗日乘子向量。驻值条件 $\\frac{\\partial \\Pi^*}{\\partial \\hat{\\mathbf{u}}} = \\mathbf{0}$ 和 $\\frac{\\partial \\Pi^*}{\\partial \\boldsymbol{\\lambda}} = \\mathbf{0}$ 导出一个分块矩阵系统：\n$$\n\\begin{pmatrix}\n\\mathbf{K} & \\mathbf{G}^\\top \\\\\n\\mathbf{G} & \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\hat{\\mathbf{u}} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{f} \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\n该系统的各部分定义如下：\n- 刚度矩阵 $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$:\n$$K_{IJ} = \\int_{0}^{L} EA \\, \\Phi_I'(x) \\Phi_J'(x) \\, \\mathrm{d}x$$\n- 力向量 $\\mathbf{f} \\in \\mathbb{R}^{n}$:\n$$f_I = \\int_{0}^{L} AB \\, \\Phi_I(x) \\, \\mathrm{d}x$$\n- 约束矩阵 $\\mathbf{G} \\in \\mathbb{R}^{2 \\times n}$:\n$$G_{1I} = \\Phi_I(0), \\quad G_{2I} = \\Phi_I(L)$$\n- 给定位移向量 $\\mathbf{d} \\in \\mathbb{R}^{2}$:\n$$\\mathbf{d} = \\begin{bmatrix} 0 \\\\ \\bar{u} \\end{bmatrix}$$\n\n$\\mathbf{K}$ 和 $\\mathbf{f}$ 的积分是使用 Gauss-Legendre 求积在划分域 $[0, L]$ 的背景单元网格上进行数值计算的。同样的求积方案也用于计算相对 $L^2$ 误差的分子和分母：\n$$\n\\varepsilon_{L^2} = \\sqrt{\\frac{\\int_{0}^{L}\\left(u_h(x)-u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}{\\int_{0}^{L}\\left(u_{\\mathrm{exact}}(x)\\right)^2\\,\\mathrm{d}x}}\n$$\n求解增广系统得到节点参数 $\\hat{\\mathbf{u}}$ 后，在每个求积点计算位移场 $u_h(x)$ 以评估误差积分。用于比较的解析解为：\n$$\nu_{\\mathrm{exact}}(x)=-\\frac{b}{2E}\\,x^2+\\left(\\frac{\\bar{u}}{L}+\\frac{bL}{2E}\\right)x\n$$\n此过程为解决该问题并评估 EFG 方法的精度提供了一个完整的框架。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D Element-Free Galerkin (EFG) solver for a prismatic bar\n    with Lagrange multipliers for essential boundary conditions.\n    \"\"\"\n\n    def efg_solver(E, A, L, b, u_bar, n, alpha, n_gauss):\n        \"\"\"\n        Core EFG solver for a single test case.\n        \"\"\"\n        # 1. Discretization and parameters\n        nodes = np.linspace(0, L, n)\n        h = L / (n - 1) if n > 1 else L\n        d = alpha * h  # Support radius of the weight function\n\n        # Quartic spline weight function and its derivative\n        def weight_function(s):\n            if s > 1.0:\n                return 0.0, 0.0\n            s2, s3, s4 = s * s, s * s * s, s * s * s * s\n            w = 1.0 - 6.0 * s2 + 8.0 * s3 - 3.0 * s4\n            dw_ds = -12.0 * s + 24.0 * s2 - 12.0 * s3\n            return w, dw_ds\n\n        def compute_mls_shape_functions(x, nodes, d):\n            \"\"\"\n            Computes MLS shape functions and their derivatives at a point x.\n            \"\"\"\n            p_basis = np.array([1.0, x])\n            dp_basis = np.array([0.0, 1.0])\n            \n            influential_nodes_idx = np.where(np.abs(x - nodes) < d)[0]\n            \n            nonlocal n\n            phis = np.zeros(n)\n            dphis = np.zeros(n)\n\n            if len(influential_nodes_idx) < 2:  # Need at least 2 nodes for linear basis\n                return phis, dphis\n            \n            p_matrix_I = np.ones((len(influential_nodes_idx), 2))\n            p_matrix_I[:, 1] = nodes[influential_nodes_idx]\n\n            M = np.zeros((2, 2))\n            dM = np.zeros((2, 2))\n            \n            weights = np.zeros(len(influential_nodes_idx))\n            dweights_dx = np.zeros(len(influential_nodes_idx))\n\n            for i, node_idx in enumerate(influential_nodes_idx):\n                s = np.abs(x - nodes[node_idx]) / d\n                w_val, dw_ds_val = weight_function(s)\n                weights[i] = w_val\n                dweights_dx[i] = dw_ds_val * np.sign(x - nodes[node_idx]) / d\n                \n                p_node = np.array([[1.0], [nodes[node_idx]]])\n                pp_T = p_node @ p_node.T\n                M += w_val * pp_T\n                dM += dweights_dx[i] * pp_T\n\n            try:\n                M_inv = np.linalg.inv(M)\n            except np.linalg.LinAlgError:\n                return phis, dphis\n            \n            psi_T = p_basis.T @ M_inv\n            dpsi_T = dp_basis.T @ M_inv - p_basis.T @ M_inv @ dM @ M_inv\n\n            for i, node_idx in enumerate(influential_nodes_idx):\n                p_node = np.array([1.0, nodes[node_idx]])\n                phi_val = psi_T @ p_node * weights[i]\n                dphi_val = dpsi_T @ p_node * weights[i] + psi_T @ p_node * dweights_dx[i]\n                phis[node_idx] = phi_val\n                dphis[node_idx] = dphi_val\n\n            return phis, dphis\n\n        # 2. Gaussian Quadrature Setup\n        gauss_points, gauss_weights = np.polynomial.legendre.leggauss(n_gauss)\n        cells = np.array([nodes[:-1], nodes[1:]]).T\n\n        # 3. System Assembly\n        K = np.zeros((n, n))\n        f = np.zeros(n)\n        \n        for cell_start, cell_end in cells:\n            cell_len = cell_end - cell_start\n            for gp, gw in zip(gauss_points, gauss_weights):\n                x_gp = cell_start + (gp + 1) * cell_len / 2.0\n                w_gp = gw * cell_len / 2.0\n                \n                phis, dphis = compute_mls_shape_functions(x_gp, nodes, d)\n                \n                # Check for influential nodes at the Gauss point\n                influential_idx = np.where(phis != 0)[0]\n                if len(influential_idx) == 0:\n                    continue\n\n                dphis_vec = dphis[influential_idx]\n                K_contrib = E * A * np.outer(dphis_vec, dphis_vec)\n                f_contrib = A * b * phis[influential_idx]\n\n                ix = np.ix_(influential_idx, influential_idx)\n                K[ix] += K_contrib * w_gp\n                f[influential_idx] += f_contrib * w_gp\n\n        # 4. Lagrange Multiplier Constraints\n        G = np.zeros((2, n))\n        G[0, :], _ = compute_mls_shape_functions(0.0, nodes, d)\n        G[1, :], _ = compute_mls_shape_functions(L, nodes, d)\n\n        d_bc = np.array([0.0, u_bar])\n\n        # 5. Form and Solve Augmented System\n        size = n + 2\n        A_aug = np.zeros((size, size))\n        b_aug = np.zeros(size)\n\n        A_aug[:n, :n] = K\n        A_aug[n:, :n] = G\n        A_aug[:n, n:] = G.T\n        \n        b_aug[:n] = f\n        b_aug[n:] = d_bc\n        \n        try:\n            sol = np.linalg.solve(A_aug, b_aug)\n        except np.linalg.LinAlgError:\n            return np.nan # Indicate failure\n\n        u_hat = sol[:n]\n\n        # 6. Error Calculation\n        def analytical_solution(x, E, A, L, b, u_bar):\n            if E == 0: return np.nan\n            c1 = u_bar / L + b * L / (2.0 * E)\n            c2 = 0\n            return -b * x**2 / (2.0 * E) + c1 * x + c2\n\n        num_integral = 0.0\n        den_integral = 0.0\n\n        for cell_start, cell_end in cells:\n            cell_len = cell_end - cell_start\n            for gp, gw in zip(gauss_points, gauss_weights):\n                x_gp = cell_start + (gp + 1) * cell_len / 2.0\n                w_gp = gw * cell_len / 2.0\n\n                phis, _ = compute_mls_shape_functions(x_gp, nodes, d)\n                u_h = phis @ u_hat\n                u_exact = analytical_solution(x_gp, E, A, L, b, u_bar)\n\n                num_integral += (u_h - u_exact)**2 * w_gp\n                den_integral += u_exact**2 * w_gp\n\n        if den_integral == 0.0:\n            return 0.0 if num_integral == 0.0 else np.inf\n        \n        rel_l2_error = np.sqrt(num_integral / den_integral)\n        return rel_l2_error\n\n    test_cases = [\n        # (E, A, L, b, u_bar, n, alpha, n_gauss)\n        (70e9, 5e-4, 1.0, 1e4, 1e-3, 31, 2.0, 3),\n        (210e9, 1e-3, 2.0, 0.0, 2e-3, 21, 2.0, 2),\n        (100e9, 2e-4, 0.5, 2e5, 0.0, 15, 2.5, 3),\n        (200e9, 8e-4, 1.5, 5e4, 5e-4, 7, 2.5, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = efg_solver(*case)\n        results.append(\"{:.6e}\".format(error))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2662012"}, {"introduction": "最后的步骤是验证我们的方法在处理更真实、多维问题时的有效性。分片检验 (patch test) 是计算力学领域的黄金标准，用以检验数值方法能否精确再生常应变状态。成功完成这个二维常应变分片检验 [@problem_id:2661977]，意味着您的 EFG 实现是一个有效且稳健的工具，能够解决二维连续介质力学问题，从而保证了其正确性和收敛性。", "problem": "设计并执行一个二维常应变片检验，该检验使用带有线性移动最小二乘 (MLS) 基的无单元伽辽金 (EFG) 法。您的程序必须在一个矩形域上使用无网格离散化方法组装并求解线弹性问题，然后通过测量恢复的应变场中的误差来验证片检验。必须满足以下要求。\n\n物理设置与控制方程：\n- 考虑在矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上的小应变、静态、平面应力线弹性问题，其中 $L_x = L_y = 1\\,\\mathrm{m}$。\n- 使用杨氏模量 $E = 1.0\\times 10^{5}\\,\\mathrm{Pa}$ 和泊松比 $\\nu = 0.25$。\n- 弱形式源于无体力时的线性动量平衡：找到位移场 $\\boldsymbol{u}$，使得对于所有容许的检验函数 $\\boldsymbol{v}$，都有 $\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v})^{T} \\boldsymbol{C} \\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\boldsymbol{v}^{T} \\bar{\\boldsymbol{t}}\\,\\mathrm{d}\\Gamma$，其中 $\\boldsymbol{C}$ 是平面应力弹性矩阵，$\\boldsymbol{\\varepsilon}$ 是对称小应变张量。在片检验中，在整个边界 $\\partial\\Omega$ 上施加本质 (狄利克雷) 边界条件 $\\boldsymbol{u} = \\boldsymbol{u}^{\\mathrm{exact}}$，并设置 $\\bar{\\boldsymbol{t}} = \\boldsymbol{0}$。\n- 使用能够产生常应变的精确线性位移场：\n  - 选择目标常应变 $\\varepsilon_{xx}^{\\star} = 1.25\\times 10^{-3}$，$\\varepsilon_{yy}^{\\star} = -7.5\\times 10^{-4}$，以及 $\\varepsilon_{xy}^{\\star} = 5.0\\times 10^{-4}$。\n  - 施加精确位移场 $\\boldsymbol{u}^{\\mathrm{exact}}(x,y) = \\begin{bmatrix} u_x \\\\ u_y \\end{bmatrix} = \\begin{bmatrix} \\varepsilon_{xx}^{\\star}\\,x + \\varepsilon_{xy}^{\\star}\\,y \\\\ \\varepsilon_{xy}^{\\star}\\,x + \\varepsilon_{yy}^{\\star}\\,y \\end{bmatrix}$ (单位：米)，使得 $\\varepsilon_{xx} = \\varepsilon_{xx}^{\\star}$，$\\varepsilon_{yy} = \\varepsilon_{yy}^{\\star}$，以及 $\\varepsilon_{xy} = \\varepsilon_{xy}^{\\star}$ 为常数。\n\n通过无单元伽辽金 (EFG) 进行离散：\n- 使用 $N_x \\times N_y$ 个节点的均匀矩形节点布局，节点坐标位于 $(x_i,y_j)$，其中 $x_i = i\\,h_x$, $y_j = j\\,h_y$, $h_x = L_x/(N_x-1)$, $h_y = L_y/(N_y-1)$，且 $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$。\n- 使用移动最小二乘 (MLS) 法和线性基 $\\boldsymbol{p}(x,y) = [\\,1,\\;x,\\;y\\,]^{T}$ 构建试探空间和检验空间。\n- 使用径向紧支权函数，节点 $k$ 的节点支持半径为 $d_k = \\alpha_s \\max(h_x,h_y)$，并使用 Wendland $C^2$ 权函数 $w(q) = (1-q)^4(1+4q)$ (当 $0 \\le q \\le 1$ 时)，否则 $w(q)=0$，其中 $q = r/d_k$，$r$ 是计算点到节点的欧几里得距离。其导数为 $w'(q) = -20\\,q\\,(1-q)^3$ (当 $0 \\le q \\le 1$ 时)。\n- 对于每个计算点 $(x,y)$，定义矩量矩阵 $\\boldsymbol{A}(x,y) = \\sum_k w_k(x,y)\\,\\boldsymbol{p}_k \\boldsymbol{p}_k^{T}$，其中 $\\boldsymbol{p}_k = [\\,1,\\;x_k,\\;y_k\\,]^{T}$。节点 $k$ 的 MLS 形函数为 $\\phi_k(x,y) = \\boldsymbol{p}(x,y)^{T}\\,\\boldsymbol{A}(x,y)^{-1}\\,w_k(x,y)\\,\\boldsymbol{p}_k$，其梯度通过使用乘法法则对 $\\phi_k$ 分别求关于 $x$ 和 $y$ 的导数得到，并利用 $\\partial \\boldsymbol{A}^{-1}/\\partial x = -\\boldsymbol{A}^{-1} (\\partial \\boldsymbol{A}/\\partial x) \\boldsymbol{A}^{-1}$，对 $y$ 的求导也类似。\n- 组装全局刚度矩阵 $\\boldsymbol{K} = \\int_{\\Omega} \\boldsymbol{B}^{T}\\,\\boldsymbol{C}\\,\\boldsymbol{B}\\,\\mathrm{d}\\Omega$，其中 $\\boldsymbol{B}$ 由形函数梯度构建：对于节点 $k$，$\\boldsymbol{B}_k = \\begin{bmatrix} \\partial\\phi_k/\\partial x & 0 \\\\ 0 & \\partial\\phi_k/\\partial y \\\\ \\partial\\phi_k/\\partial y & \\partial\\phi_k/\\partial x \\end{bmatrix}$，且 $\\boldsymbol{B} = [\\boldsymbol{B}_1\\;\\boldsymbol{B}_2\\;\\dots]$。在每个矩形单元上使用阶数为 $n_g \\times n_g$ 的张量积高斯求积，进行结构化背景单元积分，并通过适当的雅可比因子从参考正方形映射到物理单元。\n- 在位于边界 $\\partial\\Omega$ 上的所有节点上使用罚函数法施加本质边界条件 $\\boldsymbol{u} = \\boldsymbol{u}^{\\mathrm{exact}}$：将罚项 $\\alpha_p$ 加到 $\\boldsymbol{K}$ 相应的对角线元素上，并将 $\\alpha_p\\,u^{\\mathrm{exact}}$ 加到右手边向量的相应元素上。使用 $\\alpha_p = \\beta\\,E$，其中 $\\beta > 0$ 是用户指定的无量纲因子。\n\n片检验验证：\n- 在求解线性系统得到节点未知数后，在一组采样点（使用相同的背景求积点）上评估从数值解重构的应变场，其中数值应变为 $\\varepsilon_{xx}^{h} = \\sum_k (\\partial\\phi_k/\\partial x)\\,u_{x,k}$，$\\varepsilon_{yy}^{h} = \\sum_k (\\partial\\phi_k/\\partial y)\\,u_{y,k}$，以及 $\\varepsilon_{xy}^{h} = \\tfrac{1}{2}\\left(\\sum_k (\\partial\\phi_k/\\partial y)\\,u_{x,k} + \\sum_k (\\partial\\phi_k/\\partial x)\\,u_{y,k}\\right)$。计算所有采样点上的最大绝对误差，\n  $$e_{\\max} = \\max_{\\text{samples}} \\left( \\max\\left( \\left| \\varepsilon_{xx}^{h} - \\varepsilon_{xx}^{\\star} \\right|,\\; \\left| \\varepsilon_{yy}^{h} - \\varepsilon_{yy}^{\\star} \\right|,\\; \\left| \\varepsilon_{xy}^{h} - \\varepsilon_{xy}^{\\star} \\right| \\right) \\right),$$\n  该误差是无量纲的。\n- 通过将 $e_{\\max}$ 与容差 $\\tau$ 进行比较来定义通过/失败：如果 $e_{\\max} \\le \\tau$，则测试通过，否则失败。\n\n积分方案与数值细节：\n- 使用平面应力，弹性矩阵为 $\\boldsymbol{C} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}$。\n- 所有距离单位为 $\\mathrm{m}$，位移单位为 $\\mathrm{m}$，刚度单位为 $\\mathrm{N/m}$，应力单位为 $\\mathrm{Pa}$，应变为无量纲。误差 $e_{\\max}$ 是无量纲的。\n- 本问题不使用角度。\n\n测试套件与要求输出：\n- 实现以下三个测试案例，每个案例参数为 $(N_x,N_y,\\alpha_s,n_g,\\beta,\\tau)$:\n  - 案例 A (理想情况): $(N_x,N_y) = (5,5)$，$\\alpha_s = 2.5$，$n_g = 2$，$\\beta = 10^{6}$，$\\tau = 1.0\\times 10^{-4}$。\n  - 案例 B (更粗的节点网格): $(N_x,N_y) = (3,3)$，$\\alpha_s = 2.0$，$n_g = 2$，$\\beta = 10^{5}$，$\\tau = 2.0\\times 10^{-4}$。\n  - 案例 C (更密的网格，更高阶的求积): $(N_x,N_y) = (6,6)$，$\\alpha_s = 2.0$，$n_g = 3$，$\\beta = 10^{6}$，$\\tau = 5.0\\times 10^{-5}$。\n- 对于每个案例，计算 $e_{\\max}$，然后输出一个布尔值结果，表示通过 ($\\mathrm{True}$) 如果 $e_{\\max} \\le \\tau$，否则失败 ($\\mathrm{False}$)。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个案例的布尔通过/失败结果，格式为逗号分隔的列表，并用方括号括起来（例如，`[True,False,True]`）。不应打印任何额外文本。\n\n您的程序必须是一个单一、完整、可运行的脚本，该脚本使用线性基构建 MLS 形函数，使用指定的背景积分组装 EFG 刚度矩阵，应用罚函数边界条件，求解节点位移，评估应变误差度量，并报告通过/失败结果。通过稳健地处理 $\\boldsymbol{A}(x,y)$ 的奇异性（例如，在求逆前加上一个小的单位矩阵倍数）来确保数值稳定性，并确保所有评估都遵守指定的物理单位。将所有最终应变和误差表示为无量纲量；如果检查任何中间值，位移必须以 $\\mathrm{m}$ 为单位，但程序的最终输出仅包含布尔值。代码不得要求用户输入。数值算法必须如上所述从第一性原理出发实现，不依赖预构建的无网格软件包。", "solution": "该问题要求设计并实现一个针对无单元伽辽金 (EFG) 法的二维片检验，以验证其再现恒定应变状态的能力。该问题具有坚实的科学基础，是适定的且完备的。所有必要的物理参数、数值设置和验证标准都已提供。我们着手进行求解。\n\n所测试的基本原理是，一个用于固体力学的数值方法必须能够精确地（在数值精度范围内）表示一个恒定应变状态。对于建立在线性多项式基上的近似，这等同于能够精确地再现任意线性位移场。预期带有线性移动最小二乘 (MLS) 基的 EFG 方法能通过此测试。\n\n解决方案按以下步骤构建：\n1.  定义平面应力下线弹性的控制方程。\n2.  使用 MLS 方案对区域进行离散化并近似位移场。\n3.  使用背景单元高斯求积进行数值积分，从弱形式推导 EFG 方程组。\n4.  使用罚函数法施加本质边界条件。\n5.  求解得到的线性系统，并从数值位移场计算应变。\n6.  通过将计算出的应变与精确的恒定目标应变进行比较来进行验证。\n\n**1. 控制方程与弱形式**\n\n对于占据区域 $\\Omega$ 的线弹性体，在静态平衡且无体力的情况下，线性动量平衡表示为 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量。平面应力的本构关系为 $\\boldsymbol{\\sigma} = \\boldsymbol{C} \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon}$ 是小应变张量。应变-位移关系为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla\\boldsymbol{u} + (\\nabla\\boldsymbol{u})^T)$。在 Voigt 记法中，平面应力的材料刚度矩阵 $\\boldsymbol{C}$ 为：\n$$\n\\boldsymbol{C} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。应变和应力向量为 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, 2\\varepsilon_{xy}]^T$ 和 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^T$。注意，问题使用的定义中，应变向量的第三个分量是工程剪切应变 $\\gamma_{xy} = 2\\varepsilon_{xy}$。然而，$\\boldsymbol{B}$ 矩阵的定义和剪切应变的计算与张量分量 $\\varepsilon_{xy}$ 是一致的。我们将谨慎使用 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}]^T$ 的定义来构建我们的公式，其对应的 $\\boldsymbol{C}$ 矩阵最后一个对角项为 $E/(1+\\nu)$。为了与给定的 $\\boldsymbol{C}$ 矩阵保持一致，我们必须使用工程剪切应变 $\\gamma_{xy}$。让我们重新检查问题中的 B 矩阵。$\\boldsymbol{B}_k = \\begin{bmatrix} \\partial\\phi_k/\\partial x & 0 \\\\ 0 & \\partial\\phi_k/\\partial y \\\\ \\partial\\phi_k/\\partial y & \\partial\\phi_k/\\partial x \\end{bmatrix}$。该矩阵将节点位移关联到应变分量：$\\boldsymbol{\\varepsilon} = \\boldsymbol{B}_k \\boldsymbol{d}_k = [\\partial\\phi_k/\\partial x\\, u_x, \\partial\\phi_k/\\partial y\\, u_y, \\partial\\phi_k/\\partial y\\, u_x + \\partial\\phi_k/\\partial x\\, u_y]^T$。第三个分量确实是 $\\gamma_{xy}$。因此，我们使用 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ 和给定的 $\\boldsymbol{C}$ 矩阵。目标剪切应变以 $\\varepsilon_{xy}^\\star$ 给出，因此目标工程剪切应变为 $\\gamma_{xy}^\\star = 2\\varepsilon_{xy}^\\star$。\n\n平衡方程的弱形式通过虚功原理得到。对于虚位移场 $\\boldsymbol{v}$，我们有：\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{v})^{T} \\boldsymbol{C} \\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\boldsymbol{v}^{T} \\bar{\\boldsymbol{t}}\\,\\mathrm{d}\\Gamma\n$$\n对于本问题，在整个边界 $\\partial\\Omega$ 上规定了本质边界条件 $\\boldsymbol{u} = \\boldsymbol{u}^{\\mathrm{exact}}$，因此牵引力边界 $\\partial\\Omega_t$ 为空，右手边的积分为零。精确位移场是线性的，$\\boldsymbol{u}^{\\mathrm{exact}}(x,y) = [\\varepsilon_{xx}^{\\star}x + \\varepsilon_{xy}^{\\star}y, \\varepsilon_{xy}^{\\star}x + \\varepsilon_{yy}^{\\star}y]^T$，它产生一个恒定的应变场 $\\varepsilon_{xx}=\\varepsilon_{xx}^{\\star}$，$\\varepsilon_{yy}=\\varepsilon_{yy}^{\\star}$，以及 $\\varepsilon_{xy}=\\varepsilon_{xy}^{\\star}$ (或 $\\gamma_{xy}=2\\varepsilon_{xy}^{\\star}$)。\n\n**2. EFG 离散与 MLS 近似**\n\n在 EFG 方法中，位移场 $\\boldsymbol{u}(x,y)$ 通过形函数 $\\phi_k(x,y)$ 和节点位移参数 $\\boldsymbol{d}_k=[u_{x,k}, u_{y,k}]^T$ 的线性组合来近似：\n$$\n\\boldsymbol{u}^h(x,y) = \\sum_{k=1}^{N} \\phi_k(x,y) \\boldsymbol{d}_k\n$$\n形函数 $\\phi_k(x,y)$ 是使用移动最小二乘 (MLS) 法构建的。对于任何点 $\\boldsymbol{x}=(x,y)$，通过找到系数 $\\boldsymbol{a}(\\boldsymbol{x})$ 来构造近似，该系数最小化近似值与节点参数之间误差的加权离散 $L_2$ 范数：\n$$\nJ = \\sum_{k=1}^{N} w_k(\\boldsymbol{x}) \\left( \\boldsymbol{p}(\\boldsymbol{x}_k)^T \\boldsymbol{a}(\\boldsymbol{x}) - d_k \\right)^2\n$$\n其中 $\\boldsymbol{p}(\\boldsymbol{x}) = [1, x, y]^T$ 是线性基， $w_k(\\boldsymbol{x})$ 是以节点 $\\boldsymbol{x}_k$ 为中心的紧支权函数，$d_k$ 是标量节点参数。最小化过程得到节点 $k$ 的 MLS 形函数：\n$$\n\\phi_k(\\boldsymbol{x}) = \\boldsymbol{p}(\\boldsymbol{x})^T \\boldsymbol{A}(\\boldsymbol{x})^{-1} w_k(\\boldsymbol{x}) \\boldsymbol{p}(\\boldsymbol{x}_k)\n$$\n其中矩量矩阵 $\\boldsymbol{A}(\\boldsymbol{x})$ 定义为：\n$$\n\\boldsymbol{A}(\\boldsymbol{x}) = \\sum_{j=1}^{N} w_j(\\boldsymbol{x}) \\boldsymbol{p}(\\boldsymbol{x}_j) \\boldsymbol{p}(\\boldsymbol{x}_j)^T\n$$\n权函数是指定的 Wendland $C^2$ 函数：$w(q) = (1-q)^4(1+4q)$，对于 $q = \\|\\boldsymbol{x}-\\boldsymbol{x}_k\\|/d_k \\le 1$。\n\n计算应变需要形函数的梯度。它们通过使用乘法法则和链式法则对 $\\phi_k(\\boldsymbol{x})$ 关于空间坐标求导得到：\n$$\n\\frac{\\partial \\phi_k}{\\partial x} = \\frac{\\partial \\boldsymbol{p}^T}{\\partial x} \\boldsymbol{A}^{-1} w_k \\boldsymbol{p}_k + \\boldsymbol{p}^T \\frac{\\partial \\boldsymbol{A}^{-1}}{\\partial x} w_k \\boldsymbol{p}_k + \\boldsymbol{p}^T \\boldsymbol{A}^{-1} \\frac{\\partial w_k}{\\partial x} \\boldsymbol{p}_k\n$$\n其中 $\\frac{\\partial\\boldsymbol{p}^T}{\\partial x} = [0, 1, 0]$，$\\frac{\\partial w_k}{\\partial x} = w'(q_k)\\frac{\\partial q_k}{\\partial x}$，以及 $\\frac{\\partial \\boldsymbol{A}^{-1}}{\\partial x} = -\\boldsymbol{A}^{-1} \\frac{\\partial \\boldsymbol{A}}{\\partial x} \\boldsymbol{A}^{-1}$，其中 $\\frac{\\partial \\boldsymbol{A}}{\\partial x} = \\sum_{j=1}^{N} \\frac{\\partial w_j}{\\partial x} \\boldsymbol{p}_j \\boldsymbol{p}_j^T$。关于 $y$ 的导数有类似的表达式。\n\n**3. 通过数值积分进行系统组装**\n\n将 $\\boldsymbol{u}$ 的离散近似和虚位移 $\\boldsymbol{v}$（根据 Galerkin 方法使用相同的形函数）代入弱形式，得到线性系统 $\\boldsymbol{K}\\boldsymbol{d}=\\boldsymbol{F}$。全局刚度矩阵 $\\boldsymbol{K}$ 是节点贡献的组装：\n$$\n\\boldsymbol{K} = \\sum_{k=1}^N \\sum_{l=1}^N \\boldsymbol{K}_{kl}, \\quad \\text{其中} \\quad \\boldsymbol{K}_{kl} = \\int_{\\Omega} \\boldsymbol{B}_k^T \\boldsymbol{C} \\boldsymbol{B}_l \\, \\mathrm{d}\\Omega\n$$\n这里，$\\boldsymbol{d}$ 是全局节点位移向量，$\\boldsymbol{B}_k$ 是节点 $k$ 的应变-位移矩阵：\n$$\n\\boldsymbol{B}_k =\n\\begin{bmatrix}\n\\frac{\\partial\\phi_k}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial\\phi_k}{\\partial y} \\\\\n\\frac{\\partial\\phi_k}{\\partial y} & \\frac{\\partial\\phi_k}{\\partial x}\n\\end{bmatrix}\n$$\n$\\boldsymbol{K}$ 的积分通过在背景积分单元网格上使用高斯求积进行数值计算。对于矩形单元，使用一维 Gauss-Legendre 法则的张量积。域 $\\Omega$ 上的积分是所有单元上积分的总和：\n$$\n\\int_{\\Omega} f(\\boldsymbol{x})\\, \\mathrm{d}\\Omega = \\sum_{e=1}^{N_{cells}} \\int_{\\Omega_e} f(\\boldsymbol{x})\\, \\mathrm{d}\\Omega_e \\approx \\sum_{e=1}^{N_{cells}} \\sum_{q=1}^{n_g^2} f(\\boldsymbol{x}_q) w_q J_e\n$$\n其中 $\\boldsymbol{x}_q$ 和 $w_q$ 是物理单元中的求积点和权重，$J_e$ 是从参考正方形 $[-1,1]^2$到物理单元 $\\Omega_e$ 的映射的雅可比行列式。\n\n**4. 边界条件**\n\n使用罚函数法在边界 $\\partial\\Omega$ 上的所有节点上施加本质边界条件。对于对应于边界节点的自由度 $i$，刚度矩阵 $\\boldsymbol{K}$ 和力向量 $\\boldsymbol{F}$ 修改如下：\n$$\nK_{ii} \\leftarrow K_{ii} + \\alpha_p\n$$\n$$\nF_i \\leftarrow F_i + \\alpha_p u^{\\mathrm{exact}}_i\n$$\n其中 $\\alpha_p$ 是一个大的罚参数（这里是 $\\alpha_p = \\beta E$），$u^{\\mathrm{exact}}_i$ 是该自由度上规定的精确位移。由于来自弱形式的原始力向量 $\\boldsymbol{F}$ 为零，最终的力向量仅包含来自罚项的贡献。\n\n**5. 求解与验证**\n\n组装好 $\\boldsymbol{K}$ 和 $\\boldsymbol{F}$ 后，求解线性系统 $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{F}$ 以获得全局位移向量 $\\boldsymbol{d}$。\n\n如果数值解能精确地再现恒定应变场，则片检验通过。我们在一些内部采样点（为此使用高斯求积点）上，根据计算出的节点位移 $\\boldsymbol{d}$ 来评估应变。数值计算的应变分量为：\n$$\n\\varepsilon_{xx}^h(\\boldsymbol{x}) = \\sum_{k=1}^N \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial x} u_{x,k}\n$$\n$$\n\\varepsilon_{yy}^h(\\boldsymbol{x}) = \\sum_{k=1}^N \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial y} u_{y,k}\n$$\n$$\n\\varepsilon_{xy}^h(\\boldsymbol{x}) = \\frac{1}{2} \\sum_{k=1}^N \\left( \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial y} u_{x,k} + \\frac{\\partial\\phi_k(\\boldsymbol{x})}{\\partial x} u_{y,k} \\right)\n$$\n在所有采样点上的最大绝对误差计算如下：\n$$\ne_{\\max} = \\max_{\\text{samples}} \\left( \\max\\left( \\left| \\varepsilon_{xx}^{h} - \\varepsilon_{xx}^{\\star} \\right|,\\; \\left| \\varepsilon_{yy}^{h} - \\varepsilon_{yy}^{\\star} \\right|,\\; \\left| \\varepsilon_{xy}^{h} - \\varepsilon_{xy}^{\\star} \\right| \\right) \\right)\n$$\n如果 $e_{\\max} \\le \\tau$，则测试通过，其中 $\\tau$ 是指定的容差。通过的结果表明 EFG 的实现正确地包含了线性基，从而能够精确地再现恒定应变场，这是连续介质力学中一个有效的数值方法的基本要求。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the EFG patch test for all specified cases.\n    \"\"\"\n\n    # --- Constants and Exact Solution ---\n    E = 1.0e5  # Young's modulus in Pa\n    NU = 0.25  # Poisson's ratio\n    LX, LY = 1.0, 1.0  # Domain dimensions in m\n\n    # Target constant strains (dimensionless)\n    EPS_XX_STAR = 1.25e-3\n    EPS_YY_STAR = -7.5e-4\n    EPS_XY_STAR = 5.0e-4 # Tensor component\n    GAMMA_XY_STAR = 2.0 * EPS_XY_STAR # Engineering shear strain\n\n    # Plane stress elasticity matrix C for [exx, eyy, gxy]^T\n    C_mat = (E / (1.0 - NU**2)) * np.array([\n        [1.0, NU, 0.0],\n        [NU, 1.0, 0.0],\n        [0.0, 0.0, (1.0 - NU) / 2.0]\n    ])\n\n    # Exact displacement field function\n    def u_exact(x, y):\n        ux = EPS_XX_STAR * x + EPS_XY_STAR * y\n        uy = EPS_XY_STAR * x + EPS_YY_STAR * y\n        return np.array([ux, uy])\n\n    # --- Test Cases ---\n    test_cases = [\n        # (Nx, Ny, alpha_s, n_g, beta, tau), Case A\n        (5, 5, 2.5, 2, 1.0e6, 1.0e-4),\n        # Case B\n        (3, 3, 2.0, 2, 1.0e5, 2.0e-4),\n        # Case C\n        (6, 6, 2.0, 3, 1.0e6, 5.0e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, alpha_s, n_g, beta, tau = case\n        e_max = run_patch_test(\n            Nx, Ny, alpha_s, n_g, beta,\n            LX, LY, E, C_mat, u_exact,\n            EPS_XX_STAR, EPS_YY_STAR, EPS_XY_STAR\n        )\n        results.append(e_max <= tau)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_patch_test(Nx, Ny, alpha_s, n_g, beta, Lx, Ly, E, C, u_exact_func,\n                   eps_xx_star, eps_yy_star, eps_xy_star):\n    \"\"\"\n    Executes a single EFG patch test case.\n    \"\"\"\n\n    # --- Nodal and Grid Setup ---\n    hx = Lx / (Nx - 1)\n    hy = Ly / (Ny - 1)\n    nodes = np.array([(i * hx, j * hy) for j in range(Ny) for i in range(Nx)])\n    num_nodes = Nx * Ny\n    num_dofs = 2 * num_nodes\n    support_radius = alpha_s * max(hx, hy)\n\n    # --- Background Integration Grid ---\n    num_cells_x = Nx - 1\n    num_cells_y = Ny - 1\n    gauss_pts, gauss_wts = np.polynomial.legendre.leggauss(n_g)\n    \n    K = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n\n    # --- Assembly ---\n    for j in range(num_cells_y):\n        for i in range(num_cells_x):\n            x_min, y_min = i * hx, j * hy\n            jac_det = (hx * hy) / 4.0\n\n            for eta in gauss_pts:\n                for xi in gauss_pts:\n                    # Map from reference to physical coordinates\n                    gx = x_min + (1.0 + xi) * hx / 2.0\n                    gy = y_min + (1.0 + eta) * hy / 2.0\n                    \n                    # Get MLS shape functions and derivatives at this Gauss point\n                    phi, dphidx, dphidy = mls_shape_derivatives(gx, gy, nodes, support_radius)\n                    \n                    influencing_nodes_idx = np.where(phi != 0)[0]\n                    \n                    # Assemble stiffness matrix contributions\n                    for k_idx in influencing_nodes_idx:\n                        Bk = np.array([\n                            [dphidx[k_idx], 0],\n                            [0, dphidy[k_idx]],\n                            [dphidy[k_idx], dphidx[k_idx]]\n                        ])\n                        \n                        for l_idx in influencing_nodes_idx:\n                            Bl = np.array([\n                                [dphidx[l_idx], 0],\n                                [0, dphidy[l_idx]],\n                                [dphidy[l_idx], dphidx[l_idx]]\n                            ])\n                            \n                            integrand = Bk.T @ C @ Bl\n                            k_sub = integrand * jac_det * np.interp(xi, gauss_pts, gauss_wts) * np.interp(eta, gauss_pts, gauss_wts)\n                            \n                            # Add to global K\n                            dof_xk, dof_yk = 2 * k_idx, 2 * k_idx + 1\n                            dof_xl, dof_yl = 2 * l_idx, 2 * l_idx + 1\n                            K[dof_xk, dof_xl] += k_sub[0, 0]\n                            K[dof_xk, dof_yl] += k_sub[0, 1]\n                            K[dof_yk, dof_xl] += k_sub[1, 0]\n                            K[dof_yk, dof_yl] += k_sub[1, 1]\n\n    # --- Apply Penalty Boundary Conditions ---\n    alpha_p = beta * E\n    boundary_nodes_mask = (nodes[:, 0] == 0) | (nodes[:, 0] == Lx) | \\\n                          (nodes[:, 1] == 0) | (nodes[:, 1] == Ly)\n    boundary_nodes_idx = np.where(boundary_nodes_mask)[0]\n\n    for node_idx in boundary_nodes_idx:\n        x_node, y_node = nodes[node_idx]\n        u_ex = u_exact_func(x_node, y_node)\n        \n        dof_x, dof_y = 2 * node_idx, 2 * node_idx + 1\n        \n        K[dof_x, dof_x] += alpha_p\n        K[dof_y, dof_y] += alpha_p\n        \n        F[dof_x] += alpha_p * u_ex[0]\n        F[dof_y] += alpha_p * u_ex[1]\n\n    # --- Solve Linear System ---\n    try:\n        displacements = np.linalg.solve(K, F)\n    except np.linalg.LinAlgError:\n        return np.inf # Return infinite error if system is singular\n\n    # --- Verification ---\n    max_error = 0.0\n    for j in range(num_cells_y):\n        for i in range(num_cells_x):\n            x_min, y_min = i * hx, j * hy\n\n            for eta in gauss_pts:\n                for xi in gauss_pts:\n                    gx = x_min + (1.0 + xi) * hx / 2.0\n                    gy = y_min + (1.0 + eta) * hy / 2.0\n\n                    phi, dphidx, dphidy = mls_shape_derivatives(gx, gy, nodes, support_radius)\n                    influencing_nodes_idx = np.where(phi != 0)[0]\n                    \n                    eps_xx_h, eps_yy_h, gamma_xy_h = 0.0, 0.0, 0.0\n                    for k_idx in influencing_nodes_idx:\n                        ux_k = displacements[2 * k_idx]\n                        uy_k = displacements[2 * k_idx + 1]\n                        \n                        eps_xx_h += dphidx[k_idx] * ux_k\n                        eps_yy_h += dphidy[k_idx] * uy_k\n                        gamma_xy_h += dphidy[k_idx] * ux_k + dphidx[k_idx] * uy_k\n                    \n                    eps_xy_h = 0.5 * gamma_xy_h\n\n                    error = max(\n                        abs(eps_xx_h - eps_xx_star),\n                        abs(eps_yy_h - eps_yy_star),\n                        abs(eps_xy_h - eps_xy_star)\n                    )\n                    if error > max_error:\n                        max_error = error\n\n    return max_error\n\n\ndef mls_shape_derivatives(x, y, nodes, support_radius):\n    \"\"\"\n    Computes MLS shape functions and their gradients at a point (x, y).\n    \"\"\"\n    num_nodes = len(nodes)\n    p_basis = np.array([1.0, x, y])\n    dp_dx = np.array([0.0, 1.0, 0.0])\n    dp_dy = np.array([0.0, 0.0, 1.0])\n\n    distances = np.linalg.norm(nodes - np.array([x, y]), axis=1)\n    q = distances / support_radius\n    \n    influencing_mask = q < 1.0\n    influencing_indices = np.where(influencing_mask)[0]\n\n    A = np.zeros((3, 3))\n    dA_dx = np.zeros((3, 3))\n    dA_dy = np.zeros((3, 3))\n\n    weights = np.zeros(num_nodes)\n    dwd_x = np.zeros(num_nodes)\n    dwd_y = np.zeros(num_nodes)\n    \n    for i in influencing_indices:\n        qi = q[i]\n        weights[i] = (1 - qi)**4 * (1 + 4 * qi)\n        \n        # Derivative of weight w.r.t q\n        dw_dq = -20.0 * qi * (1 - qi)**3\n        \n        # Derivatives of q w.r.t x, y\n        dr_dx = (x - nodes[i, 0]) / (distances[i] + 1e-15)\n        dr_dy = (y - nodes[i, 1]) / (distances[i] + 1e-15)\n        dq_dx = dr_dx / support_radius\n        dq_dy = dr_dy / support_radius\n\n        dwd_x[i] = dw_dq * dq_dx\n        dwd_y[i] = dw_dq * dq_dy\n\n        p_node = np.array([1.0, nodes[i, 0], nodes[i, 1]])\n        p_outer_p = np.outer(p_node, p_node)\n        \n        A += weights[i] * p_outer_p\n        dA_dx += dwd_x[i] * p_outer_p\n        dA_dy += dwd_y[i] * p_outer_p\n    \n    try:\n        # A small regularization can be added if A is ill-conditioned\n        A_inv = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        # Not enough influencing nodes\n        return np.zeros(num_nodes), np.zeros(num_nodes), np.zeros(num_nodes)\n\n    dA_inv_dx = -A_inv @ dA_dx @ A_inv\n    dA_inv_dy = -A_inv @ dA_dy @ A_inv\n\n    phi = np.zeros(num_nodes)\n    dphi_dx = np.zeros(num_nodes)\n    dphi_dy = np.zeros(num_nodes)\n\n    for i in influencing_indices:\n        p_node = np.array([1.0, nodes[i, 0], nodes[i, 1]])\n        \n        term1 = p_basis @ A_inv\n        term2 = weights[i] * p_node\n        phi[i] = term1 @ term2\n\n        # Derivatives\n        dterm1_dx = dp_dx @ A_inv + p_basis @ dA_inv_dx\n        dterm1_dy = dp_dy @ A_inv + p_basis @ dA_inv_dy\n        \n        dphi_dx[i] = dterm1_dx @ term2 + term1 @ (dwd_x[i] * p_node)\n        dphi_dy[i] = dterm1_dy @ term2 + term1 @ (dwd_y[i] * p_node)\n\n    return phi, dphi_dx, dphi_dy\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2661977"}]}