{"hands_on_practices": [{"introduction": "在有限元分析中，核心步骤之一是将各个单元的物理特性（如刚度）组合成一个描述整个系统行为的全局矩阵。本练习将通过一个简单的一维杆系统，让您亲手实践“直接刚度法”的精髓——叠加原理。通过手动组装这个 3x3 的全局刚度矩阵，您将直观地理解单元刚度矩阵如何在共享节点处进行累加，为掌握更复杂的自动化计算流程奠定坚实的基础 [@problem_id:2115177]。", "problem": "考虑一个一维力学系统，该系统由两个不同的单元和三个节点（按顺序标记为 1、2 和 3）建模。\n- 单元 (1) 连接节点 1 和节点 2。其行为由一个 2x2 的单元刚度矩阵 $k^{(1)}$ 描述，该矩阵关联其两个节点上的力与位移。\n- 单元 (2) 连接节点 2 和节点 3。其行为由一个 2x2 的单元刚度矩阵 $k^{(2)}$ 描述。\n\n给定的单元刚度矩阵为：\n$$ k^{(1)} = \\begin{pmatrix} k_1 & -k_1 \\\\ -k_1 & k_1 \\end{pmatrix} \\quad \\text{和} \\quad k^{(2)} = \\begin{pmatrix} k_2 & -k_2 \\\\ -k_2 & k_2 \\end{pmatrix} $$\n其中，$k_1$ 和 $k_2$ 是表示每个单元刚度的正实数常量。\n\n组装整个三节点系统的 3x3 全局刚度矩阵 $K$。该全局矩阵通过方程 $F = KU$ 将全局节点力向量 $F = (F_1, F_2, F_3)^T$ 与全局节点位移向量 $U = (u_1, u_2, u_3)^T$ 关联起来。\n\n请用 $k_1$ 和 $k_2$ 表示你的答案，形式为一个 3x3 矩阵。", "solution": "我们使用标准的有限元组装原理，通过叠加单元贡献来组装全局刚度矩阵。设全局位移向量为 $U = (u_{1}, u_{2}, u_{3})^{T}$，全局力向量为 $F = (F_{1}, F_{2}, F_{3})^{T}$。对于每个单元 $(e)$，其局部（或单元）位移向量为 $U^{(e)}$，单元刚度矩阵为 $k^{(e)}$，其对全局刚度矩阵的贡献通过连接矩阵 $A^{(e)}$ 形成，使得 $U^{(e)} = A^{(e)} U$ 且\n$$\nK = \\sum_{e} A^{(e) T} k^{(e)} A^{(e)}.\n$$\n\n对于连接节点 1 和 2 的单元 (1)，其连接矩阵为\n$$\nA^{(1)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix}, \\quad k^{(1)} = \\begin{pmatrix} k_{1} & -k_{1} \\\\ -k_{1} & k_{1} \\end{pmatrix}.\n$$\n计算\n$$\nk^{(1)} A^{(1)} = \\begin{pmatrix} k_{1} & -k_{1} \\\\ -k_{1} & k_{1} \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\end{pmatrix},\n$$\n然后\n$$\nK^{(1)} = A^{(1) T} \\left(k^{(1)} A^{(1)}\\right) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\end{pmatrix} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}.\n$$\n\n对于连接节点 2 和 3 的单元 (2)，其连接矩阵为\n$$\nA^{(2)} = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}, \\quad k^{(2)} = \\begin{pmatrix} k_{2} & -k_{2} \\\\ -k_{2} & k_{2} \\end{pmatrix}.\n$$\n计算\n$$\nk^{(2)} A^{(2)} = \\begin{pmatrix} k_{2} & -k_{2} \\\\ -k_{2} & k_{2} \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix},\n$$\n然后\n$$\nK^{(2)} = A^{(2) T} \\left(k^{(2)} A^{(2)}\\right) = \\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}.\n$$\n\n将各单元的贡献相加，得到全局刚度矩阵\n$$\nK = K^{(1)} + K^{(2)} = \\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1} + k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}.\n$$\n此矩阵 $K$ 满足三节点系统的方程 $F = K U$。", "answer": "$$\\boxed{\\begin{pmatrix} k_{1} & -k_{1} & 0 \\\\ -k_{1} & k_{1}+k_{2} & -k_{2} \\\\ 0 & -k_{2} & k_{2} \\end{pmatrix}}$$", "id": "2115177"}, {"introduction": "手动组装适用于简单的教学示例，但现实世界的工程问题通常涉及数以千计的单元，必须依赖计算机程序来高效、准确地完成组装。这个实践练习要求您将前一个练习中的叠加逻辑转化为通用的计算算法，编写一段代码来处理不同的单元连接关系和自由度。这是从理论走向实践的关键一步，也是成为一名合格的计算工程师所必备的编程技能 [@problem_id:2378075]。", "problem": "要求您实现一个完整的、可运行的程序，该程序根据给定的单元刚度矩阵和连接关系数组，为线性弹性问题组装全局刚度矩阵。组装过程必须遵循计算固体力学和线性弹性力学的基本原理，并反映离散平衡方程是如何由每个有限元的贡献构建而成的。\n\n您的实现必须且仅基于以下基本原理：\n- 虚功原理，该原理在通过合适的形函数进行空间离散化后，会导出一个形式为 $K u = f$ 的线性系统，其中 $K$ 是全局刚度矩阵，$u$ 是全局位移向量，$f$ 是全局力向量。\n- 每个节点的自由度 (DOF) 的定义，以及每个单元贡献一个局部刚度矩阵，该矩阵仅耦合其自身节点的自由度这一概念。\n\n不要在问题陈述中使用任何预先推导的组装“捷径”公式。相反，您应从上述基本原理中推断出，全局刚度矩阵是通过在正确的全局自由度位置上，对作用于相同全局自由度的所有单元贡献进行求和而产生的。\n\n您的程序必须：\n- 以程序内部硬编码数据的形式，接受一个测试用例列表。每个测试用例需指定：\n  - 节点数 $N_{\\text{nodes}}$。\n  - 每个节点的自由度数 $n_{\\text{dof}}$。\n  - 一个连接关系数组，为每个单元列出其连接的全局节点索引。节点索引从零开始。\n  - 一列大小适中的单元刚度矩阵 $K_e$（每个单元一个），其单位采用国际单位制 (SI) 中的牛顿/米 ($\\mathrm{N/m}$)。全局刚度矩阵的单位也必须是 $\\mathrm{N/m}$，但您必须输出纯数字条目，不打印单位。\n- 使用定义将单元级自由度映射到全局自由度：节点 $n$ 的第 $d$ 个自由度（$d \\in \\{0,\\dots,n_{\\text{dof}}-1\\}$）对应于全局索引 $g = n \\cdot n_{\\text{dof}} + d$。\n- 根据连接关系映射，通过将每个单元的局部刚度矩阵条目加到全局矩阵中的相应位置来组装全局刚度矩阵。\n- 对于每个测试用例，生成完整的、已组装的全局刚度矩阵，并按行优先顺序将其展平成一个单一的数字列表。\n\n测试套件（所有刚度值单位为 $\\mathrm{N/m}$；打印原始数值，不带单位）：\n\n- 测试用例 $1$（一维杆单元，“理想情况”）：\n  - $N_{\\text{nodes}} = 3$， $n_{\\text{dof}} = 1$。\n  - 连接关系：两个单元，节点对分别为 $\\big(0,1\\big)$ 和 $\\big(1,2\\big)$。\n  - 单元刚度矩阵：\n    - 对于单元 $\\big(0,1\\big)$：$K_e^{(1)} = 10 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$。\n    - 对于单元 $\\big(1,2\\big)$：$K_e^{(2)} = 20 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$。\n  - 全局刚度矩阵大小为 $3 \\times 3$，应输出为 $9$ 个数字。\n\n- 测试用例 $2$（二维，每节点两个自由度，分块结构组装）：\n  - $N_{\\text{nodes}} = 3$， $n_{\\text{dof}} = 2$。\n  - 连接关系：两个单元，节点对分别为 $\\big(0,1\\big)$ 和 $\\big(1,2\\big)$。\n  - 形式为 $k \\begin{bmatrix} I & -I \\\\ -I & I \\end{bmatrix}$ 的单元刚度矩阵（每个为 $4 \\times 4$），其中 $I$ 是 $2 \\times 2$ 的单位矩阵：\n    - 对于单元 $\\big(0,1\\big)$：$k = 3$。\n    - 对于单元 $\\big(1,2\\big)$：$k = 5$。\n  - 全局刚度矩阵大小为 $6 \\times 6$，应输出为 $36$ 个数字。\n\n- 测试用例 $3$（一维杆链，内部累积，边界条件边缘行为）：\n  - $N_{\\text{nodes}} = 4$， $n_{\\text{dof}} = 1$。\n  - 连接关系：三个单元，节点对分别为 $\\big(0,1\\big)$、$\\big(1,2\\big)$ 和 $\\big(2,3\\big)$。\n  - 单元刚度矩阵：\n    - $K_e^{(1)} = 2 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$，\n    - $K_e^{(2)} = 4 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$，\n    - $K_e^{(3)} = 6 \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$。\n  - 全局刚度矩阵大小为 $4 \\times 4$，应输出为 $16$ 个数字。\n\n- 测试用例 $4$（非连续节点索引和一个 $3$ 节点单元）：\n  - $N_{\\text{nodes}} = 4$， $n_{\\text{dof}} = 1$。\n  - 连接关系：一个单元，节点三元组为 $\\big(0,2,3\\big)$。\n  - 单元刚度矩阵（一个对称的 $3 \\times 3$ 矩阵）：\n    - $K_e^{(1)} = \\begin{bmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{bmatrix}$。\n  - 全局刚度矩阵大小为 $4 \\times 4$，应输出为 $16$ 个数字。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个列表项对应一个测试用例，并且其本身是按行优先顺序展平的全局刚度矩阵条目列表。例如，形式为 $\\big[$ 测试用例1的列表, 测试用例2的列表, 测试用例3的列表, 测试用例4的列表 $\\big]$ 的一行。\n- 所有数值输出必须打印为代表 $\\mathrm{N/m}$ 的纯数字；不要打印单位，不要进行四舍五入或格式化为科学记数法，除非编程语言的默认行为要求这样做。", "solution": "所提出的问题是构建一个全局刚度矩阵，这是线性弹性力学有限元法 (FEM) 中的一个基本步骤。这项任务不仅仅是一项编程练习，更是在离散化连续体中对物理叠加原理的直接实现。\n\n这个过程由虚功原理严格推导得出，最终形成一个线性代数方程组 $K u = f$。\n\n全局刚度矩阵（记为 $K$）将全局节点位移向量 $u$ 与全局节点力向量 $f$ 联系起来。矩阵 $K$ 封装了整个离散化结构的刚度特性。它是由每个独立有限元的刚度贡献系统性地叠加而形成的。系统的总内虚功是其组成单元内虚功的总和。这个可加性原理直接转化为全局刚度矩阵的组装过程：\n$$\nK = \\sum_{e} \\mathcal{L}_e^T K_e \\mathcal{L}_e\n$$\n此处，$K_e$ 是单元 $e$ 在其自身局部坐标系中的刚度矩阵，$\\mathcal{L}_e$ 是一个布尔定位矩阵，它将单元 $e$ 的局部自由度 (DOF) 映射到它们在全局自由度系统中的相应位置。在计算实践中，为了采用更高效的直接刚度组装算法，通常会绕过显式构建 $\\mathcal{L}_e$ 的过程，而这正是我们将要形式化的算法。\n\n系统中的总自由度数 $N_{DOF}$ 是节点数 $N_{\\text{nodes}}$ 与每节点自由度数 $n_{\\text{dof}}$ 的乘积，即 $N_{DOF} = N_{\\text{nodes}} \\cdot n_{\\text{dof}}$。因此，全局刚度矩阵 $K$ 是一个大小为 $N_{DOF} \\times N_{DOF}$ 的方阵。我们首先将 $K$ 初始化为该维度的零矩阵。\n\n组装算法的核心在于从单元的局部自由度索引到系统的全局自由度索引的映射。该映射由两条信息决定：单元的连接关系数组和每个节点上自由度的既定排序。问题指定了一个标准映射：全局节点 $n$ 的第 $d$ 个自由度（其中 $d$ 是一个从 $0$ 到 $n_{\\text{dof}}-1$ 的零基索引）对应于全局自由度索引 $g = n \\cdot n_{\\text{dof}} + d$。\n\n让我们考虑一个单元 $e$，它连接了一组具有全局索引 $\\{N_1, N_2, \\dots, N_m\\}$ 的 $m$ 个节点。其单元刚度矩阵 $K_e$ 的大小为 $(m \\cdot n_{\\text{dof}}) \\times (m \\cdot n_{\\text{dof}})$。该矩阵的一个条目 $K_e[i, j]$ 代表了单元的第 $i$ 个和第 $j$ 个局部自由度之间的耦合。我们的目标是将此贡献加到全局矩阵 $K$ 的正确位置。\n\n局部行索引 $i$（从 $0$ 到 $m \\cdot n_{\\text{dof}}-1$）对应于单元上某个特定节点的特定自由度。我们可以通过整除和取模运算将该索引分解为一个局部节点索引 $a$ 和该节点处的一个局部自由度索引 $p$：\n- 局部节点索引：$a = \\lfloor i / n_{\\text{dof}} \\rfloor$。此处，$a \\in \\{0, 1, \\dots, m-1\\}$。\n- 节点处的局部自由度索引：$p = i \\pmod{n_{\\text{dof}}}$。此处，$p \\in \\{0, 1, \\dots, n_{\\text{dof}}-1\\}$。\n\n单元 $e$ 的连接关系数组提供了与局部节点索引 $a$ 对应的全局节点索引。设连接关系由元组 $(N_1, N_2, \\dots, N_m)$ 给出。全局节点索引 $N_a$ 是此元组中的第 $(a+1)$ 项（此处描述使用基于1的索引，而计算中使用基于0的索引）。\n\n使用提供的全局自由度映射规则，与局部行索引 $i$ 对应的全局行索引 $g_r$ 是：\n$$\ng_r = N_a \\cdot n_{\\text{dof}} + p\n$$\n类似地，对于局部列索引 $j$，我们确定相应的全局列索引 $g_c$：\n- 局部节点索引：$b = \\lfloor j / n_{\\text{dof}} \\rfloor$。\n- 局部自由度索引：$q = j \\pmod{n_{\\text{dof}}}$。\n- 全局节点索引：$N_b$。\n- 全局列索引：$g_c = N_b \\cdot n_{\\text{dof}} + q$。\n\n因此，组装规则就是将贡献累加到全局矩阵中。对于每个单元 $e$ 及其局部刚度矩阵中的每一个条目 $K_e[i, j]$，我们按如下方式更新全局刚度矩阵：\n$$\nK[g_r, g_c] \\leftarrow K[g_r, g_c] + K_e[i, j]\n$$\n对网格中的所有单元重复此过程。最终得到的矩阵 $K$ 正确地表示了整个装配体的组合刚度，并反映了单元之间的连接关系和共享自由度。共享一个单元的节点，其在 $K$ 中的相应条目将接收到该单元刚度矩阵的贡献，从而正确地耦合了它们的行为。如果一个节点是多个单元的一部分，其在全局刚度矩阵中的对角项会累积所有相连单元的刚度贡献，这在物理上是必然的。\n\n要实现的算法是这一逻辑的直接转换：\n1.  确定总自由度数 $N_{DOF} = N_{\\text{nodes}} \\cdot n_{\\text{dof}}$，并将全局刚度矩阵 $K$ 初始化为一个大小为 $N_{DOF} \\times N_{DOF}$ 的零矩阵。\n2.  遍历输入中提供的每个单元 $e$。\n3.  对于每个单元，获取其连接关系数组（其节点的全局索引）及其单元刚度矩阵 $K_e$。\n4.  遍历单元刚度矩阵 $K_e$ 的每一行 $i$ 和每一列 $j$。\n5.  对于每一对 $(i, j)$，使用上述映射逻辑计算相应的全局行索引 $g_r$ 和全局列索引 $g_c$。\n6.  将值 $K_e[i, j]$ 加到全局刚度矩阵的条目 $K[g_r, g_c]$ 上。\n7.  在遍历所有单元后，矩阵 $K$ 就被完全组装好了。最后一步是将其按行优先顺序展平成一个一维列表以供输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_stiffness(n_nodes, n_dof, connectivity, element_stiffness_matrices):\n    \"\"\"\n    Assembles the global stiffness matrix from element stiffness matrices.\n\n    Args:\n        n_nodes (int): The total number of nodes in the mesh.\n        n_dof (int): The number of degrees of freedom per node.\n        connectivity (list of tuples): A list where each tuple contains the \n                                       zero-based global node indices for an element.\n        element_stiffness_matrices (list of numpy.ndarray): A list of element \n                                                            stiffness matrices.\n\n    Returns:\n        numpy.ndarray: The assembled global stiffness matrix.\n    \"\"\"\n    total_dofs = n_nodes * n_dof\n    K_global = np.zeros((total_dofs, total_dofs), dtype=float)\n\n    # Iterate over each element to assemble its contribution to the global matrix\n    for elem_idx, elem_nodes in enumerate(connectivity):\n        K_e = element_stiffness_matrices[elem_idx]\n        num_elem_nodes = len(elem_nodes)\n        elem_dofs = num_elem_nodes * n_dof\n\n        # Map local DOFs to global DOFs and add stiffness contribution\n        for i in range(elem_dofs):\n            for j in range(elem_dofs):\n                # Decompose local DOF index 'i' into local node and local DOF type\n                local_node_row = i // n_dof\n                local_dof_row = i % n_dof\n                # Get the global node index from the connectivity array\n                global_node_row = elem_nodes[local_node_row]\n                # Calculate the global DOF index\n                global_dof_row = global_node_row * n_dof + local_dof_row\n\n                # Repeat for the column index 'j'\n                local_node_col = j // n_dof\n                local_dof_col = j % n_dof\n                global_node_col = elem_nodes[local_node_col]\n                global_dof_col = global_node_col * n_dof + local_dof_col\n\n                # Add the element's stiffness contribution to the global matrix\n                K_global[global_dof_row, global_dof_col] += K_e[i, j]\n                \n    return K_global\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for global stiffness matrix assembly.\n    \"\"\"\n    I2 = np.identity(2)\n    test_cases = [\n        # Test Case 1: 1D bar elements\n        {\n            \"n_nodes\": 3,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 1), (1, 2)],\n            \"element_stiffness_matrices\": [\n                10.0 * np.array([[1, -1], [-1, 1]]),\n                20.0 * np.array([[1, -1], [-1, 1]]),\n            ],\n        },\n        # Test Case 2: 2D elements with 2 DOFs/node\n        {\n            \"n_nodes\": 3,\n            \"n_dof\": 2,\n            \"connectivity\": [(0, 1), (1, 2)],\n            \"element_stiffness_matrices\": [\n                3.0 * np.block([[I2, -I2], [-I2, I2]]),\n                5.0 * np.block([[I2, -I2], [-I2, I2]]),\n            ],\n        },\n        # Test Case 3: 1D bar chain\n        {\n            \"n_nodes\": 4,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 1), (1, 2), (2, 3)],\n            \"element_stiffness_matrices\": [\n                2.0 * np.array([[1, -1], [-1, 1]]),\n                4.0 * np.array([[1, -1], [-1, 1]]),\n                6.0 * np.array([[1, -1], [-1, 1]]),\n            ],\n        },\n        # Test Case 4: Nonconsecutive nodes, 3-node element\n        {\n            \"n_nodes\": 4,\n            \"n_dof\": 1,\n            \"connectivity\": [(0, 2, 3)],\n            \"element_stiffness_matrices\": [\n                np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]]),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K_global = assemble_stiffness(\n            case[\"n_nodes\"],\n            case[\"n_dof\"],\n            case[\"connectivity\"],\n            case[\"element_stiffness_matrices\"],\n        )\n        # Flatten the matrix in row-major order and convert to a list of floats\n        flattened_list = K_global.flatten().tolist()\n        results.append(flattened_list)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2378075"}, {"introduction": "成功组装全局刚度矩阵 $K$ 后，理解其内在的物理和数学属性至关重要。本练习引导我们思考一个看似反常但至关重要的问题：为什么在施加任何位移约束之前，一个自由浮动结构的全局刚度矩阵必然是奇异的？通过将矩阵的奇异性与结构的刚体运动（即不产生应变的平移和旋转）联系起来，您将深刻理解施加边界条件为何是获得唯一解的物理和数学必然要求 [@problem_id:2172618]。", "problem": "一名工程专业的学生正在编写一个程序，以使用有限元法（FEM）进行结构分析。该程序的目标是求解静力平衡方程 $[K]\\mathbf{d} = \\mathbf{f}$，其中 $[K]$ 是全局刚度矩阵，$\\mathbf{d}$ 是节点位移向量，$\\mathbf{f}$ 是施加的节点力向量。该学生首先为三维空间中的一根自由浮动的弹性梁组装了全局刚度矩阵 $[K]$，但尚未施加任何支座或位移边界条件。当他们试图通过求解 $[K]$ 的逆矩阵来测试代码时，程序失败了，并正确地识别出该矩阵是奇异的。\n\n以下哪个陈述为无约束结构的全局刚度矩阵 $[K]$ 必须是奇异的提供了正确的物理解释？\n\nA. 结构可以进行刚体运动（平移和旋转），而不会产生任何内应力或应变。\n\nB. 在矩阵组装过程中累积的数值舍入误差导致其行列式恰好为零。\n\nC. 外力向量 $\\mathbf{f}$ 当前为零向量，而右端项为零的线性系统总是具有奇异矩阵。\n\nD. 材料属性（如杨氏模量和泊松比）尚未指定，导致矩阵元素未定义。\n\nE. 将连续梁离散为有限数量的单元是一种近似，这种近似在模型中引入了固有的奇异性。", "solution": "我们从线性弹性有限元平衡方程 $[K]\\mathbf{d}=\\mathbf{f}$ 开始，其中全局刚度矩阵 $[K]$ 由单元贡献组装而成。在标准的小应变线性弹性理论中，每个单元的刚度可以写成变分形式\n$$\n[K] \\;=\\; \\int_{\\Omega} \\mathbf{B}^{T}[D]\\mathbf{B}\\, \\mathrm{d}V,\n$$\n其中 $\\mathbf{B}$ 是应变-位移矩阵，$[D]$ 是本构（材料）矩阵。由节点位移 $\\mathbf{d}$ 引起的应变为 $\\boldsymbol{\\epsilon}=\\mathbf{B}\\mathbf{d}$，应力为 $\\boldsymbol{\\sigma}=[D]\\boldsymbol{\\epsilon}$。\n\n对于三维空间中的任何刚体运动，位移场不产生应变：如果 $\\mathbf{d}_{\\mathrm{rb}}$ 对应于整个无约束结构的刚体平移或旋转，那么\n$$\n\\boldsymbol{\\epsilon} \\;=\\; \\mathbf{B}\\mathbf{d}_{\\mathrm{rb}} \\;=\\; \\mathbf{0}\n\\quad \\Rightarrow \\quad\n\\boldsymbol{\\sigma} \\;=\\; [D]\\boldsymbol{\\epsilon} \\;=\\; \\mathbf{0}.\n$$\n将 $\\mathbf{d}_{\\mathrm{rb}}$ 代入刚度作用的定义中，\n$$\n[K]\\mathbf{d}_{\\mathrm{rb}} \\;=\\; \\int_{\\Omega} \\mathbf{B}^{T}[D]\\mathbf{B}\\,\\mathbf{d}_{\\mathrm{rb}}\\, \\mathrm{d}V\n\\;=\\; \\int_{\\Omega} \\mathbf{B}^{T}[D]\\bigl(\\mathbf{B}\\mathbf{d}_{\\mathrm{rb}}\\bigr)\\, \\mathrm{d}V\n\\;=\\; \\int_{\\Omega} \\mathbf{B}^{T}[D]\\mathbf{0}\\, \\mathrm{d}V\n\\;=\\; \\mathbf{0}.\n$$\n因此，每个非平凡的刚体模态 $\\mathbf{d}_{\\mathrm{rb}}\\neq\\mathbf{0}$ 都位于 $[K]$ 的零空间中。等效地，应变能\n$$\nU(\\mathbf{d}) \\;=\\; \\tfrac{1}{2}\\,\\mathbf{d}^{T}[K]\\mathbf{d}\n\\;=\\; \\tfrac{1}{2}\\int_{\\Omega} \\boldsymbol{\\epsilon}^{T}[D]\\boldsymbol{\\epsilon}\\,\\mathrm{d}V\n$$\n对于刚体运动为零，因此相关的瑞利商给出一个零特征值。零空间中存在至少一个非零向量意味着 $[K]$ 是奇异的。对于一个自由的3D物体，存在六个独立的刚体模态（三个平移和三个旋转），因此 $[K]$ 的零度（nullity）至少为六。\n\n因此，正确的物理解释是，无约束结构允许不引起应变或应力的刚体运动，从而产生零能模态，并因此导致一个奇异的刚度矩阵。\n\n为什么其他选项是错误的：\n- B: 舍入误差不会系统地产生一个精确为零的行列式；奇异性是由于零能模态引起的物理属性，而不是数值偶然性。\n- C: 右端项为零 $\\mathbf{f}=\\mathbf{0}$ 并不意味着 $[K]$ 是奇异的；许多非奇异系统都有齐次解 $\\mathbf{d}=\\mathbf{0}$。\n- D: 虽然缺少材料属性会妨碍 $[K]$ 的形成，但一旦 $[D]$ 被定义，奇异性是由边界条件引起的，而不是由未定义的条目引起的。\n- E: 离散化本身不会导致奇异性；在施加适当的位移边界条件后，组装的 $[K]$ 变为正定的（或至少在经过适当的约束处理后变为非奇异的）。", "answer": "$$\\boxed{A}$$", "id": "2172618"}]}