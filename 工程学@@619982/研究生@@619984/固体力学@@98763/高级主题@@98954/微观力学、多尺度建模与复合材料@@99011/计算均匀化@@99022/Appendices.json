{"hands_on_practices": [{"introduction": "计算均匀化的核心思想之一是将宏观物理量视为其在代表性体积单元（RVE）上微观对应量的体积平均。本练习将这一基本原则应用于应力张量，提供了一个具体的数值计算实践。通过这个直接的计算，你将掌握如何从一个分区域的微观应力场中确定等效的宏观应力，这是将均匀化理论应用于实际问题的第一步 [@problem_id:2623558]。", "problem": "在一个二维平面应力设置中，一个代表性体积单元（RVE）被用于有限元平方（FE²）计算均匀化框架。该RVE被划分为$3$个不相交的子域$\\Omega_{\\mu}^{(k)}$，$k=1,2,3$，每个子域都具有恒定的微观Cauchy应力$\\boldsymbol{\\sigma}_{k}$和已知的体积$V_k$。假设微观场满足无体力作用下的静力平衡、适当的容许边界条件，并且强制执行Hill–Mandel宏观均匀性条件。\n\n子域的体积为$V_1 = 2$ mm$^3$，$V_2 = 3$ mm$^3$，$V_3 = 5$ mm$^3$。微观应力张量（单位：兆帕）为\n$$\n\\boldsymbol{\\sigma}_1=\\begin{pmatrix}120 & 30\\\\ 30 & 60\\end{pmatrix},\\quad\n\\boldsymbol{\\sigma}_2=\\begin{pmatrix}-40 & 20\\\\ 20 & 100\\end{pmatrix},\\quad\n\\boldsymbol{\\sigma}_3=\\begin{pmatrix}80 & -10\\\\ -10 & 40\\end{pmatrix}.\n$$\n\n使用此类RVE的宏观Cauchy应力的一阶均匀化定义，计算宏观应力张量$\\boldsymbol{\\Sigma}$。以Voigt次序$[\\Sigma_{11},\\,\\Sigma_{22},\\,\\Sigma_{12}]$报告您的最终答案（注意：不施加工程剪切因子），单位为兆帕。将您的分量四舍五入至四位有效数字。以单行矩阵的形式提供您的最终答案。", "solution": "对问题陈述进行验证。\n\n逐字提取已知条件：\n- 一个二维平面应力设置下的代表性体积单元(RVE)。\n- 框架为有限元平方(FE²)。\n- RVE被划分为$3$个不相交的子域$\\Omega_{\\mu}^{(k)}$，其中$k=1,2,3$。\n- 每个子域具有恒定的微观Cauchy应力$\\boldsymbol{\\sigma}_{k}$。\n- 每个子域具有已知的体积$V_k$。\n- 微观场满足无体力作用下的静力平衡和容许边界条件。\n- 强制执行Hill–Mandel宏观均匀性条件。\n- 子域体积：$V_1 = 2$ mm$^3$，$V_2 = 3$ mm$^3$，$V_3 = 5$ mm$^3$。\n- 微观应力张量（单位：兆帕(MPa)）：\n$$\n\\boldsymbol{\\sigma}_1=\\begin{pmatrix}120 & 30\\\\ 30 & 60\\end{pmatrix},\\quad\n\\boldsymbol{\\sigma}_2=\\begin{pmatrix}-40 & 20\\\\ 20 & 100\\end{pmatrix},\\quad\n\\boldsymbol{\\sigma}_3=\\begin{pmatrix}80 & -10\\\\ -10 & 40\\end{pmatrix}.\n$$\n- 任务：计算宏观应力张量$\\boldsymbol{\\Sigma}$。\n- 报告格式：Voigt次序$[\\Sigma_{11},\\,\\Sigma_{22},\\,\\Sigma_{12}]$，四舍五入至四位有效数字，单位为MPa。\n\n验证结论：\n该问题是连续介质力学中一个有效且适定的问题。它在科学上基于一阶计算均匀化理论。所有必要数据均已提供，不存在内部矛盾或含糊之处。微观应力张量是对称的，这符合Cauchy应力张量的要求。给定的条件，如静力平衡和Hill–Mandel条件，是FE²方法中的标准条件，并确保了均匀化拟设的有效性。该问题是宏观应力基本定义的直接应用。\n\n解答过程如下。\n\n在一阶均匀化理论中，宏观Cauchy应力张量（表示为$\\boldsymbol{\\Sigma}$）被定义为微观Cauchy应力张量$\\boldsymbol{\\sigma}$在代表性体积单元（RVE）域$\\Omega$上的体积平均值。RVE的总体积为$V$。该定义用积分形式表示为：\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{V} \\int_{\\Omega} \\boldsymbol{\\sigma}(\\mathbf{x}) \\, dV\n$$\n该定义是Hill-Mandel宏观均匀性条件的直接推论，该条件将宏观应力功率与微观应力功率的体积平均值相等同。\n\n问题陈述指出，RVE域被划分为3个不相交的子域$\\Omega_k$，其中$k \\in \\{1, 2, 3\\}$，使得$\\Omega = \\cup_{k=1}^{3} \\Omega_k$且当$i \\neq j$时$\\Omega_i \\cap \\Omega_j = \\emptyset$。总体积$V$是子域体积$V_k$的总和：\n$$\nV = V_1 + V_2 + V_3\n$$\n$\\boldsymbol{\\Sigma}$的积分可以分解为在这些子域上的积分之和：\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{V} \\left( \\int_{\\Omega_1} \\boldsymbol{\\sigma}(\\mathbf{x}) \\, dV + \\int_{\\Omega_2} \\boldsymbol{\\sigma}(\\mathbf{x}) \\, dV + \\int_{\\Omega_3} \\boldsymbol{\\sigma}(\\mathbf{x}) \\, dV \\right)\n$$\n一个关键的简化条件是：在每个子域内，微观应力张量是恒定的，即对于$\\mathbf{x} \\in \\Omega_k$，有$\\boldsymbol{\\sigma}(\\mathbf{x}) = \\boldsymbol{\\sigma}_k$。因此，每个子域上的积分简化为常数应力张量与子域体积的乘积：\n$$\n\\int_{\\Omega_k} \\boldsymbol{\\sigma}_k \\, dV = \\boldsymbol{\\sigma}_k \\int_{\\Omega_k} \\, dV = \\boldsymbol{\\sigma}_k V_k\n$$\n将此结果代入$\\boldsymbol{\\Sigma}$的表达式，得到微观应力张量的体积加权平均值：\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{V} \\sum_{k=1}^{3} \\boldsymbol{\\sigma}_k V_k = \\sum_{k=1}^{3} \\frac{V_k}{V} \\boldsymbol{\\sigma}_k\n$$\n令$f_k = V_k / V$为第$k$个子域的体积分数。那么宏观应力为：\n$$\n\\boldsymbol{\\Sigma} = f_1 \\boldsymbol{\\sigma}_1 + f_2 \\boldsymbol{\\sigma}_2 + f_3 \\boldsymbol{\\sigma}_3\n$$\n我们现在代入给定的数值。首先，我们计算总体积$V$：\n$$\nV = V_1 + V_2 + V_3 = 2 \\, \\text{mm}^3 + 3 \\, \\text{mm}^3 + 5 \\, \\text{mm}^3 = 10 \\, \\text{mm}^3\n$$\n接下来，我们计算体积分数：\n$$\nf_1 = \\frac{V_1}{V} = \\frac{2}{10} = 0.2\n$$\n$$\nf_2 = \\frac{V_2}{V} = \\frac{3}{10} = 0.3\n$$\n$$\nf_3 = \\frac{V_3}{V} = \\frac{5}{10} = 0.5\n$$\n体积分数之和为$f_1+f_2+f_3 = 0.2+0.3+0.5 = 1$，符合预期。\n\n现在，我们计算宏观应力张量$\\boldsymbol{\\Sigma}$的分量。\n分量$\\Sigma_{11}$为：\n$$\n\\Sigma_{11} = f_1 \\sigma_{1,11} + f_2 \\sigma_{2,11} + f_3 \\sigma_{3,11} = (0.2)(120) + (0.3)(-40) + (0.5)(80)\n$$\n$$\n\\Sigma_{11} = 24 - 12 + 40 = 52 \\, \\text{MPa}\n$$\n分量$\\Sigma_{22}$为：\n$$\n\\Sigma_{22} = f_1 \\sigma_{1,22} + f_2 \\sigma_{2,22} + f_3 \\sigma_{3,22} = (0.2)(60) + (0.3)(100) + (0.5)(40)\n$$\n$$\n\\Sigma_{22} = 12 + 30 + 20 = 62 \\, \\text{MPa}\n$$\n分量$\\Sigma_{12}$为：\n$$\n\\Sigma_{12} = f_1 \\sigma_{1,12} + f_2 \\sigma_{2,12} + f_3 \\sigma_{3,12} = (0.2)(30) + (0.3)(20) + (0.5)(-10)\n$$\n$$\n\\Sigma_{12} = 6 + 6 - 5 = 7 \\, \\text{MPa}\n$$\n由于所有微观应力张量都是对称的，因此得到的宏观应力张量也是对称的，故$\\Sigma_{21} = \\Sigma_{12} = 7 \\, \\text{MPa}$。完整的宏观应力张量为：\n$$\n\\boldsymbol{\\Sigma} = \\begin{pmatrix} 52 & 7 \\\\ 7 & 62 \\end{pmatrix} \\, \\text{MPa}\n$$\n问题要求答案以Voigt表示法$[\\Sigma_{11}, \\Sigma_{22}, \\Sigma_{12}]$给出，各分量四舍五入到四位有效数字。\n计算出的分量为$52$、$62$和$7$。以四位有效数字表示，它们是：\n$$\n\\Sigma_{11} = 52.00\n$$\n$$\n\\Sigma_{22} = 62.00\n$$\n$$\n\\Sigma_{12} = 7.000\n$$\n因此，所要求格式的最终答案是包含这些值的行矩阵。", "answer": "$$\n\\boxed{\\begin{pmatrix} 52.00 & 62.00 & 7.000 \\end{pmatrix}}\n$$", "id": "2623558"}, {"introduction": "在掌握了基本的平均法则之后，关键的下一步是确保我们复杂的数值工具（如FE²程序）能够正确工作。“斑块测试”（Patch Test）是验证任何有限元代码准确性的基本工具。本练习让你像代码开发者一样思考，要求你为FE²实现设计一个全面的斑块测试，以证明代码能够为一个均匀材料精确地重现已知的简单解析解 [@problem_id:2623524]。", "problem": "考虑一种用于小应变线性弹性的两尺度计算均匀化方案，称为平方有限元法 (FE²)。设微观域，称为代表性体积单元 (RVE)，由 $\\Omega_{\\mu} \\subset \\mathbb{R}^{d}$ 表示，其边界为 $\\partial \\Omega_{\\mu}$，外单位法向量为 $\\mathbf{n}$。微观本构关系是线性的，具有恒定的四阶弹性张量 $\\mathbb{C}$，体力为 $\\mathbf{b}=\\mathbf{0}$，并且满足小应变运动学关系 $\\boldsymbol{\\varepsilon}=\\operatorname{sym}\\nabla \\mathbf{u}$。宏观单元承受一个均匀、恒定（在空间上恒定）的宏观应变张量 $\\overline{\\boldsymbol{E}}$，该应变通过与 Hill–Mandel 宏观均匀性条件一致的适当边界条件传递给 RVE。目标是设计一个斑块测试（patch test），当施加这个均匀宏观应变时，该测试能在 RVE 上产生完全均匀的微观应力和一个零波动场，并指定一套必须满足的完整诊断性检查，以断定 FE² 实现通过了斑块测试。\n\n下面哪个选项给出了这样一个斑块测试的正确且完整的设计，包括必需的微观边界条件和一套最小且充分的诊断性检查？\n\nA. 选择 $\\Omega_{\\mu}$ 为任何具有均匀线性弹性材料的单连通域，即 $\\mathbb{C}$ 在 $\\Omega_{\\mu}$ 中是常数。施加运动学一致边界条件 (KUBC)：在 $\\partial \\Omega_{\\mu}$ 上指定一个仿射位移 $\\mathbf{u}(\\mathbf{x})=\\overline{\\boldsymbol{H}}\\,\\mathbf{x}$，其中 $\\operatorname{sym}(\\overline{\\boldsymbol{H}})=\\overline{\\boldsymbol{E}}$。等效地，求解波动场 $\\widetilde{\\mathbf{u}}=\\mathbf{u}-\\overline{\\boldsymbol{H}}\\,\\mathbf{x}$，其中在 $\\partial \\Omega_{\\mu}$ 上 $\\widetilde{\\mathbf{u}}=\\mathbf{0}$。如果在严格的数值容差范围内满足以下条件，则宣布斑块测试通过：\n- 波动场范数可忽略不计，例如，在无量纲单位下 $\\|\\widetilde{\\mathbf{u}}\\|_{H^{1}(\\Omega_{\\mu})} \\le \\varepsilon$，其中 $\\varepsilon \\approx 10^{-12}$。\n- 微观应力是均匀的，并等于对宏观应变的本构响应，即 $\\operatorname{Var}_{\\Omega_{\\mu}}[\\boldsymbol{\\sigma}]=0$ 且逐点满足 $\\boldsymbol{\\sigma}(\\mathbf{x})=\\mathbb{C}:\\overline{\\boldsymbol{E}}$。\n- Hill–Mandel 能量一致性在机器精度下成立，$\\overline{\\boldsymbol{\\sigma}}:\\overline{\\boldsymbol{E}}=\\frac{1}{|\\Omega_{\\mu}|}\\int_{\\Omega_{\\mu}}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega$，其中 $\\overline{\\boldsymbol{\\sigma}}=\\frac{1}{|\\Omega_{\\mu}|}\\int_{\\Omega_{\\mu}}\\boldsymbol{\\sigma}\\,\\mathrm{d}\\Omega$。\n- 从微观问题计算出的宏观一致切线模量等于 $\\mathbb{C}$，即在一个小的范数容差内 $\\mathbb{C}^{\\text{hom}}=\\mathbb{C}$。\n- 离散微观平衡残差范数在非线性求解器容差范围内消失，且边界反力与均匀应力引起的 $\\boldsymbol{\\sigma}\\,\\mathbf{n}$ 相对应。\n\nB. 选择 $\\Omega_{\\mu}$ 为具有分段常数张量 $\\mathbb{C}_{1}$ 和 $\\mathbb{C}_{2}$ 的强非均匀两相复合材料。在一个平行六面体 RVE 上施加周期性边界条件 (PBC)，强制实施周期性位移和反周期性牵引力。如果体积平均值满足 $\\langle \\boldsymbol{\\varepsilon} \\rangle=\\overline{\\boldsymbol{E}}$ 和 $\\langle \\boldsymbol{\\sigma} \\rangle=\\overline{\\boldsymbol{\\sigma}}$，并且 Hill–Mandel 等式在平均意义上成立，则宣布斑块测试通过，而不管波动场是否非零以及微观应力是否非均匀。\n\nC. 选择均匀的 $\\Omega_{\\mu}$。在整个 $\\partial \\Omega_{\\mu}$ 上施加均匀牵引力边界条件 $\\mathbf{t}=\\overline{\\boldsymbol{\\sigma}}\\,\\mathbf{n}$，其中 $\\overline{\\boldsymbol{\\sigma}}=\\mathbb{C}:\\overline{\\boldsymbol{E}}$。如果反力之和为零，平均微观应变等于 $\\overline{\\boldsymbol{E}}$，并且从反力计算出的宏观应力等于 $\\overline{\\boldsymbol{\\sigma}}$，则宣布斑块测试通过。\n\nD. 选择均匀且矩形的 $\\Omega_{\\mu}$。施加带有仿射部分 $\\overline{\\boldsymbol{H}}\\,\\mathbf{x}$ 和周期性位移波动的周期性边界条件 (PBC)。如果 Hill–Mandel 条件成立且体积平均微观应变等于 $\\overline{\\boldsymbol{E}}$，则宣布斑块测试通过，而不检查波动场的消失、应力均匀性或一致切线模量与 $\\mathbb{C}$ 的相等性。\n\n选择正确的选项。", "solution": "问题陈述要求在小应变线性弹性的背景下，为一种两尺度计算均匀化 (FE²) 方案设计一个斑块测试。这种测试的目标是验证数值实现能否正确复现一个已知的、简单的解析解。需要复现的具体案例是均匀材料的情况，其中均匀的宏观应变应导致均匀的微观场。\n\n首先，我们必须验证问题陈述的有效性。\n\n**步骤1：提取已知条件**\n- **方案：** 两尺度计算均匀化 (FE²)。\n- **物理背景：** 小应变线性弹性。\n- **RVE：** $\\Omega_{\\mu} \\subset \\mathbb{R}^{d}$，边界为 $\\partial \\Omega_{\\mu}$，外单位法向量为 $\\mathbf{n}$。\n- **本构关系：** 线性弹性，具有恒定的四阶弹性张量 $\\mathbb{C}$。\n- **体力：** $\\mathbf{b}=\\mathbf{0}$。\n- **运动学：** $\\boldsymbol{\\varepsilon}=\\operatorname{sym}\\nabla \\mathbf{u}$。\n- **宏观加载：** 一个均匀、恒定的宏观应变张量 $\\overline{\\boldsymbol{E}}$。\n- **耦合：** 与 Hill–Mandel 宏观均匀性条件一致的边界条件。\n- **目标：** 设计一个斑块测试，施加 $\\overline{\\boldsymbol{E}}$ 能产生：\n    1. 均匀的微观应力。\n    2. RVE 上的零波动场。\n- **任务：** 指定测试设计和一套用于判断测试是否通过的完整诊断性检查。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述在科学上是合理的、适定的和客观的。它基于计算多尺度力学的既定理论。斑块测试的概念是数值方法中，特别是有限元分析中，一个标准且必要的验证程序。问题要求设计这样一个测试，这是一个基于所提供的物理和数学框架的、定义明确的概念性任务。给出的条件是自洽的，并且足以制定有效斑块测试的要求。未发现任何缺陷。\n\n**结论：** 问题是**有效的**。\n\n现在我们继续推导解答并评估各个选项。\n\n**基于原理的推导**\n在 FE² 的背景下，斑块测试用于验证其实现能够精确地恢复与均匀材料对应的平凡解。\n\n微观问题的控制方程是在没有体力的情况下的平衡方程：\n$$\n\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0} \\quad \\text{in } \\Omega_{\\mu}\n$$\n本构关系和运动学关系为：\n$$\n\\boldsymbol{\\sigma} = \\mathbb{C}:\\boldsymbol{\\varepsilon}\n$$\n$$\n\\boldsymbol{\\varepsilon} = \\operatorname{sym}(\\nabla \\mathbf{u}) = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T)\n$$\n由于材料是均匀的，弹性张量 $\\mathbb{C}$ 在整个 $\\Omega_{\\mu}$ 内是常数。我们假设一个均匀应变场 $\\boldsymbol{\\varepsilon}(\\mathbf{x}) = \\overline{\\boldsymbol{E}}$，其中 $\\overline{\\boldsymbol{E}}$ 是一个常数张量。这导致一个均匀应力场 $\\boldsymbol{\\sigma}(\\mathbf{x}) = \\mathbb{C}:\\overline{\\boldsymbol{E}}$。一个常数应力张量的散度为零，$\\nabla \\cdot (\\mathbb{C}:\\overline{\\boldsymbol{E}}) = \\mathbf{0}$，因此平衡方程在域内恒等满足。\n\n产生均匀应变 $\\overline{\\boldsymbol{E}}$ 的位移场 $\\mathbf{u}(\\mathbf{x})$ 必须满足 $\\operatorname{sym}(\\nabla \\mathbf{u}) = \\overline{\\boldsymbol{E}}$。$\\nabla\\mathbf{u}$ 的通解为 $\\nabla\\mathbf{u} = \\overline{\\boldsymbol{E}} + \\overline{\\mathbf{W}}$，其中 $\\overline{\\mathbf{W}}$ 是代表刚体旋转的任意常数反对称张量。对此进行积分得到一个仿射位移场：\n$$\n\\mathbf{u}(\\mathbf{x}) = (\\overline{\\boldsymbol{E}} + \\overline{\\mathbf{W}})\\mathbf{x} + \\mathbf{c} = \\overline{\\boldsymbol{H}}\\mathbf{x} + \\mathbf{c}\n$$\n其中 $\\overline{\\boldsymbol{H}} = \\overline{\\boldsymbol{E}} + \\overline{\\mathbf{W}}$ 是一个常数张量，$\\mathbf{c}$ 是代表刚体平移的常数向量。\n\n波动场 $\\widetilde{\\mathbf{u}}$ 通常通过分解 $\\mathbf{u}(\\mathbf{x}) = \\overline{\\boldsymbol{E}}\\mathbf{x} + \\widetilde{\\mathbf{u}}(\\mathbf{x})$ 来定义。为了使问题产生零波动场，我们需要 $\\widetilde{\\mathbf{u}}(\\mathbf{x}) = \\mathbf{0}$。这对应于位移场 $\\mathbf{u}(\\mathbf{x}) = \\overline{\\boldsymbol{E}}\\mathbf{x}$（忽略了必须由边界条件约束的刚体运动）。\n\n为确保 $\\mathbf{u}(\\mathbf{x}) = \\overline{\\boldsymbol{E}}\\mathbf{x}$是微尺度边值问题 (BVP) 的唯一解，我们必须施加适当的边界条件。任何与 Hill–Mandel 条件一致的边界条件集（例如，运动学一致边界条件 (KUBC)、周期性边界条件 (PBC) 或静态一致边界条件 (SUBC)），对于一个均匀的 RVE，都应产生这种均匀状态。\n\n一套完整的诊断性检查必须验证数值代码复现了该解析解的所有方面，并满足基本的一致性条件。这些检查应包括：\n1. 计算出的位移场必须对应于零波动，即 $\\|\\widetilde{\\mathbf{u}}\\|$ 应接近机器精度。\n2. 计算出的应力和应变场必须是均匀的，其值分别为 $\\boldsymbol{\\sigma} = \\mathbb{C}:\\overline{\\boldsymbol{E}}$ 和 $\\boldsymbol{\\varepsilon} = \\overline{\\boldsymbol{E}}$。\n3. 微观应力的体积平均值 $\\overline{\\boldsymbol{\\sigma}} = \\frac{1}{|\\Omega_{\\mu}|}\\int_{\\Omega_{\\mu}}\\boldsymbol{\\sigma}\\,\\mathrm{d}\\Omega$ 必须等于 $\\mathbb{C}:\\overline{\\boldsymbol{E}}$。\n4. Hill–Mandel 条件 $\\overline{\\boldsymbol{\\sigma}}:\\overline{\\boldsymbol{E}} = \\frac{1}{|\\Omega_{\\mu}|}\\int_{\\Omega_{\\mu}}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega$ 必须在机器精度下得到满足。\n5. 计算出的均匀化切线模量 $\\mathbb{C}^{\\text{hom}} = \\partial \\overline{\\boldsymbol{\\sigma}} / \\partial \\overline{\\boldsymbol{E}}$ 必须等于微观切线模量 $\\mathbb{C}$。\n6. 标准的有限元求解检查，例如平衡残差消失和正确的边界反力，必须通过。\n\n现在我们基于这个框架评估给出的选项。\n\n**逐项分析选项**\n\n**A. 选择 $\\Omega_{\\mu}$ 为任何具有均匀线性弹性材料的单连通域...**\n- **测试设置：** 正确地选择了均匀材料（$\\mathbb{C}$ 为常数）。KUBC，指定为仿射位移 $\\mathbf{u}(\\mathbf{x})=\\overline{\\boldsymbol{H}}\\,\\mathbf{x}$ 在 $\\partial \\Omega_{\\mu}$ 上（其中 $\\operatorname{sym}(\\overline{\\boldsymbol{H}})=\\overline{\\boldsymbol{E}}$），是一个有效的边界条件，它强制施加了所需的宏观应变，并且其精确解就是该仿射场本身，从而导致零波动场 $\\widetilde{\\mathbf{u}}=\\mathbf{0}$（假设 $\\overline{\\mathbf{H}}=\\overline{\\boldsymbol{E}}$ 或使用了适当的波动场定义）。\n- **诊断性检查：** 检查列表是全面且正确的。\n    - 检查波动场范数 $\\|\\widetilde{\\mathbf{u}}\\|_{H^{1}(\\Omega_{\\mu})}$ 是否可忽略，验证了是否恢复了正确的位移场。\n    - 检查应力方差为零及其值等于 $\\mathbb{C}:\\overline{\\boldsymbol{E}}$，验证了应力场。\n    - 检查 Hill–Mandel 条件验证了多尺度耦合的基本能量一致性。\n    - 检查 $\\mathbb{C}^{\\text{hom}}=\\mathbb{C}$ 验证了宏观切线模量实现的正确性，这对宏观问题的收敛至关重要。\n    - 检查平衡残差和边界反力确认了底层求解器工作正常。\n这套诊断性检查既是充分的也是最小的，因为每项检查都测试了 FE² 算法的一个不同且关键的部分。\n**结论：正确。**\n\n**B. 选择 $\\Omega_{\\mu}$ 为强非均匀两相复合材料...**\n- **测试设置：** 该选项建议使用非均匀 RVE。在非均匀材料中，均匀的宏观应变 $\\overline{\\boldsymbol{E}}$ 会引起非均匀的微观应力和应变场，以及非零的波动场 $\\widetilde{\\mathbf{u}}$。斑块测试的目的恰恰是验证代码在*均匀*介质中复现已知*均匀*解的能力。使用非均匀材料构成了一种不同类型的验证问题，而不是其基本意义上的斑块测试。\n- **诊断性检查：** 这些检查仅限于平均量和 Hill-Mandel 条件，明确忽略了场的非均匀性。这忽略了斑块测试的主要目的。\n**结论：不正确。**\n\n**C. 选择均匀的 $\\Omega_{\\mu}$。施加均匀牵引力边界条件...**\n- **测试设置：** 正确地选择了均匀材料。均匀牵引力边界条件 (SUBC)，$\\mathbf{t}=\\overline{\\boldsymbol{\\sigma}}\\,\\mathbf{n}$ 其中 $\\overline{\\boldsymbol{\\sigma}}=\\mathbb{C}:\\overline{\\boldsymbol{E}}$，是 KUBC 的一个有效替代方案。对于这个 BVP，均匀应力状态 $\\boldsymbol{\\sigma}=\\overline{\\boldsymbol{\\sigma}}$ 和均匀应变状态 $\\boldsymbol{\\varepsilon}=\\overline{\\boldsymbol{E}}$ 构成了一个有效的解。\n- **诊断性检查：** 这套检查存在严重缺陷，是不完整的。它提到检查反力之和为零（这对于指定牵引力的情况定义不明确），平均微观应变等于 $\\overline{\\boldsymbol{E}}$（正确），以及从反力计算出的宏观应力等于 $\\overline{\\boldsymbol{\\sigma}}$（循环论证）。最重要的是，它没有指定检查所得应力和应变场的*均匀性*、波动场（相对于仿射解）的消失，以及均匀化切线模量 $\\mathbb{C}^{\\text{hom}} = \\mathbb{C}$ 的正确性。一个不验证精确局部场恢复情况的斑块测试是不充分的。\n**结论：不正确。**\n\n**D. 选择均匀且矩形的 $\\Omega_{\\mu}$。施加周期性边界条件 (PBC)...**\n- **测试设置：** 正确地选择了均匀材料。周期性边界条件是斑块测试的另一个有效选择。对于均匀 RVE，PBC 也应导致均匀场和零波动场（在刚体运动的意义上）。\n- **诊断性检查：** 这个选项有明确且致命的缺陷，因为它声明测试通过的标准是“而不检查波动场的消失、应力均匀性或一致切线模量与 $\\mathbb{C}$ 的相等性”。省略这些检查完全违背了斑块测试的宗旨。只验证平均量和 Hill-Mandel 条件不足以保证实现的正确性，因为场解中的局部误差或切线计算中的误差将无法被检测到。\n**结论：不正确。**\n\n**结论**\n选项 A 为 FE² 实现的斑块测试提供了唯一正确且完整的描述。它正确地指定了一个有效的设置（均匀 RVE 和 KUBC），以及一套最小且充分的诊断性检查，涵盖了数值实现的所有关键方面：解场、本构响应、跨尺度能量条件以及宏观切线刚度。", "answer": "$$\\boxed{A}$$", "id": "2623524"}, {"introduction": "掌握了基本概念和验证方法后，我们现在来处理FE²中一个更高级也更关键的方面：计算一致性切线模量（consistent tangent modulus）。这个切线模量对于宏观模拟的效率和收敛性至关重要。本编码练习将指导你从第一性原理出发，推导并实现这个切线模量，然后使用有限差分法——计算科学中的一种标准技术——来验证你的实现 [@problem_id:2623507]。", "problem": "实现一个基于一阶双尺度有限元方法（FE²）的验证程序，用以在宏观尺度上通过有限差分评估均匀化切线模量的一致性。在小应变固体力学框架下，使用周期性代表体积单元（RVE）进行分析。推导必须严格从基本平衡原理和变分原理出发。程序必须是自洽的，能够计算微观尺度的平衡及其线性化，并将一致均匀化切线与通过扰动宏观应变获得的有限差分近似进行比较。本问题中的所有量均为无量纲。\n\n假设与定义：\n- 考虑一个面积为 $|\\Omega|=1$ 的单位正方形RVE $\\Omega \\subset \\mathbb{R}^2$。运动学为小应变、平面应变。微观位移场分解为 $\\boldsymbol{u}(\\boldsymbol{x}) = \\bar{\\boldsymbol{E}} \\boldsymbol{x} + \\boldsymbol{w}(\\boldsymbol{x})$，其中 $\\bar{\\boldsymbol{E}}$ 是施加的恒定宏观应变张量，$\\boldsymbol{w}$ 是一个均值为零的周期性涨落。小应变张量为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\mathsf{T}})$。\n- RVE在$2 \\times 2$的均匀网格上使用双线性四边形有限元进行离散化，通过识别相对的边界节点来施加$\\boldsymbol{w}$的周期性，并固定一个参考节点以消除$\\boldsymbol{w}$的刚体平移。\n- 本构法则是基于线性弹性基底和体积三次扰动构建的非均质、各向同性、可压缩、小应变超弹性模型。在每个材料点处，\n  $$\n  W(\\boldsymbol{\\varepsilon}) = \\tfrac{1}{2}\\,\\boldsymbol{\\varepsilon}:\\mathbb{C}_{\\text{lin}}:\\boldsymbol{\\varepsilon} + \\tfrac{\\beta}{3}\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})^3,\n  $$\n  其中 $\\mathbb{C}_{\\text{lin}}$ 是由拉梅（Lamé）参数 $(\\lambda,\\mu)$ 定义的平面应变各向同性刚度张量，$\\beta \\ge 0$ 是一个标量参数。柯西（Cauchy）应力为 $\\boldsymbol{\\sigma} = \\partial W / \\partial \\boldsymbol{\\varepsilon} = \\mathbb{C}_{\\text{lin}}:\\boldsymbol{\\varepsilon} + \\beta\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})^2\\,\\boldsymbol{I}$，一致材料切线为 $\\mathbb{C} = \\partial \\boldsymbol{\\sigma}/\\partial \\boldsymbol{\\varepsilon} = \\mathbb{C}_{\\text{lin}} + 2\\beta\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})\\,\\boldsymbol{I}\\otimes\\boldsymbol{I}$。使用张量到Voigt映射，其向量分量为 $[\\varepsilon_{11},\\varepsilon_{22},\\varepsilon_{12}]^{\\mathsf{T}}$ 和 $[\\sigma_{11},\\sigma_{22},\\sigma_{12}]^{\\mathsf{T}}$ （注意 $\\varepsilon_{12}$ 是张量剪切，而非工程剪切）。在此平面应变映射中，线性刚度为\n  $$\n  \\mathbb{C}_{\\text{lin}}^{\\text{Voigt}} =\n  \\begin{bmatrix}\n  \\lambda + 2\\mu & \\lambda & 0\\\\\n  \\lambda & \\lambda + 2\\mu & 0\\\\\n  0 & 0 & 2\\mu\n  \\end{bmatrix}.\n  $$\n- RVE是非均质的：根据单元中心坐标，在$2 \\times 2$的单元上以棋盘格模式分配材料A和B。中心位于 $(x-0.5)(y-0.5) \\ge 0$ 所在象限的单元使用材料A，其余使用材料B。材料A的参数为 $(\\lambda_A,\\mu_A,\\beta_A)$，材料B的参数为 $(\\lambda_B,\\mu_B,\\beta_B)$。\n\n微观尺度弱形式与平衡：\n- 具有周期性$\\boldsymbol{w}$的微观尺度虚功原理要求\n  $$\n  \\delta \\Pi(\\boldsymbol{w};\\bar{\\boldsymbol{E}}) = \\int_{\\Omega} \\boldsymbol{\\sigma}(\\bar{\\boldsymbol{E}} + \\boldsymbol{\\varepsilon}(\\boldsymbol{w})) : \\boldsymbol{\\varepsilon}(\\delta \\boldsymbol{w})\\,\\mathrm{d}V = 0\n  $$\n  对所有周期性容许的$\\delta \\boldsymbol{w}$成立。使用双线性形函数离散化$\\boldsymbol{w}$，组装残差向量$\\boldsymbol{R}(\\boldsymbol{w};\\bar{\\boldsymbol{E}})$及其雅可比矩阵（切线）$\\boldsymbol{K}_{ww} = \\partial \\boldsymbol{R}/\\partial \\boldsymbol{w}$，并用牛顿（Newton）法求解$\\boldsymbol{R} = \\boldsymbol{0}$。\n\n宏观响应与一致线性化：\n- 均匀化柯西（Cauchy）应力是体积平均\n  $$\n  \\bar{\\boldsymbol{\\sigma}}(\\bar{\\boldsymbol{E}}) = \\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}(\\bar{\\boldsymbol{E}} + \\boldsymbol{\\varepsilon}(\\boldsymbol{w}(\\bar{\\boldsymbol{E}})))\\,\\mathrm{d}V.\n  $$\n- 对耦合问题在收敛的微观尺度平衡点进行线性化，以获得一致均匀化切线 $\\mathbb{C}^{\\text{eff}} = \\partial \\bar{\\boldsymbol{\\sigma}} / \\partial \\bar{\\boldsymbol{E}}$。从残差算子的线性化和应用于微观平衡的隐函数定理出发，仅使用基本定义和链式法则，推导出将$\\mathrm{d}\\boldsymbol{w}$的影响凝聚到$\\mathbb{C}^{\\text{eff}}$中的表达式。在程序中，使用有限元离散化和从微观线性化组装的矩阵块来实现所得的表达式。不使用任何外部提供的最终公式。\n\n有限差分验证：\n- 通过中心有限差分近似$\\partial \\bar{\\boldsymbol{\\sigma}} / \\partial \\bar{\\boldsymbol{E}}$来验证$\\mathbb{C}^{\\text{eff}}$。对于宏观应变向量 $\\bar{\\boldsymbol{E}}_{\\mathrm{vec}} = [\\bar{E}_{11},\\bar{E}_{22},\\bar{E}_{12}]^{\\mathsf{T}}$的每个分量$j$，计算\n  $$\n  \\left.\\frac{\\partial \\bar{\\boldsymbol{\\sigma}}}{\\partial \\bar{E}_j}\\right|_{\\text{FD}} \\approx \\frac{\\bar{\\boldsymbol{\\sigma}}(\\bar{\\boldsymbol{E}}+\\delta\\,\\boldsymbol{e}_j) - \\bar{\\boldsymbol{\\sigma}}(\\bar{\\boldsymbol{E}}-\\delta\\,\\boldsymbol{e}_j)}{2\\delta},\n  $$\n  其中$\\delta$是一个小标量，$\\boldsymbol{e}_j$是分量$j$方向的单位向量。对每个扰动后的宏观应变，使用牛顿（Newton）法重新平衡微观问题。\n\n数值与实现细节：\n- 对每个双线性单元使用$2 \\times 2$高斯（Gauss）求积。使用与张量剪切分量 $\\varepsilon_{12} = \\tfrac{1}{2}(\\partial u_1/\\partial y + \\partial u_2/\\partial x)$一致的标准小应变B矩阵。\n- 通过识别$\\boldsymbol{w}$的相对边界节点来施加周期性，并通过在原点节点固定$\\boldsymbol{w}=\\boldsymbol{0}$来消除刚体平移。不施加任何额外的边界牵引力；在构成本构模型中，宏观应变以$\\boldsymbol{\\varepsilon} = \\bar{\\boldsymbol{E}} + \\boldsymbol{\\varepsilon}(\\boldsymbol{w})$的形式加性地进入微观应变。\n- 使用牛顿（Newton）法求解非线性微观尺度系统，设置固定的残差范数收敛容差和合理的最大迭代次数，以确保对给定的测试套件具有稳健的收敛性。\n\n测试套件：\n实现您的程序以运行以下三个测试案例。对于每个测试，通过微观线性化计算解析一致均匀化切线$\\mathbb{C}^{\\text{eff}}$，计算有限差分近似，并报告两个$3\\times 3$矩阵之间的最大相对Frobenius范数误差，\n$$\n\\mathrm{err} = \\frac{\\|\\mathbb{C}^{\\text{eff}} - \\mathbb{C}^{\\text{FD}}\\|_{\\mathrm{F}}}{\\max(\\|\\mathbb{C}^{\\text{eff}}\\|_{\\mathrm{F}},\\,10^{-14})}.\n$$\n在所有测试中使用相同的网格、周期性和材料分配规则。所有量均为无量纲。\n\n- 测试1（一般非均质，混合加载）：\n  - 材料A：$(\\lambda_A,\\mu_A,\\beta_A) = (1200,\\,800,\\,5\\times 10^{4})$。\n  - 材料B：$(\\lambda_B,\\mu_B,\\beta_B) = (600,\\,400,\\,2\\times 10^{4})$。\n  - 宏观应变向量 $\\bar{\\boldsymbol{E}}_{\\mathrm{vec}} = [10^{-3},\\,-5\\times 10^{-4},\\,2\\times 10^{-3}]^{\\mathsf{T}}$。\n  - 有限差分步长 $\\delta = 10^{-7}$。\n\n- 测试2（纯剪切，检查迹为零时体积非线性的失效）：\n  - 材料与测试1相同。\n  - 宏观应变向量 $\\bar{\\boldsymbol{E}}_{\\mathrm{vec}} = [0,\\,0,\\,10^{-3}]^{\\mathsf{T}}$。\n  - 有限差分步长 $\\delta = 10^{-7}$。\n\n- 测试3（零宏观应变下的近线性区域）：\n  - 材料与测试1相同。\n  - 宏观应变向量 $\\bar{\\boldsymbol{E}}_{\\mathrm{vec}} = [0,\\,0,\\,0]^{\\mathsf{T}}$。\n  - 有限差分步长 $\\delta = 10^{-7}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试的误差值，格式为逗号分隔的列表，并用方括号括起（例如：\"[e1,e2,e3]\"）。每个条目必须是浮点数。\n\n科学真实性：\n- 所有建模选择和参数都与小应变超弹性、一阶周期性均匀化以及标准有限元离散化一致。不需要外部数据，且所有量均为无量纲。\n\n交付成果：\n- 一个完整、可运行的程序，该程序能构建网格、施加周期性、使用牛顿（Newton）法组装和求解微观尺度平衡、从微观尺度线性化计算解析一致均匀化切线、通过$\\bar{\\boldsymbol{E}}$的有限差分进行验证，并按指定格式输出三个误差值。", "solution": "我们从一阶双尺度有限元方法（FE²）和小应变运动学出发。运动学假设为 $\\boldsymbol{u}(\\boldsymbol{x}) = \\bar{\\boldsymbol{E}} \\boldsymbol{x} + \\boldsymbol{w}(\\boldsymbol{x})$，其中$\\bar{\\boldsymbol{E}}$在代表体积单元（RVE）$\\Omega$上为常数，$\\boldsymbol{w}$是均值为零的周期性函数。小应变张量为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\mathsf{T}})$，因此局部微观应变场表示为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\bar{\\boldsymbol{E}} + \\boldsymbol{\\varepsilon}(\\boldsymbol{w}(\\boldsymbol{x}))$。周期性涨落的选择确保了Hill–Mandel宏观均匀性条件。\n\n本构模型及其一致切线：\n我们采用一个超弹性应变能密度\n$$\nW(\\boldsymbol{\\varepsilon}) = \\tfrac{1}{2}\\,\\boldsymbol{\\varepsilon}:\\mathbb{C}_{\\text{lin}}:\\boldsymbol{\\varepsilon} + \\tfrac{\\beta}{3}\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})^3,\n$$\n其中$\\mathbb{C}_{\\text{lin}}$是由拉梅（Lamé）常数$(\\lambda,\\mu)$参数化的各向同性平面应变刚度张量，$\\beta \\ge 0$引入了一个体积三次非线性项。柯西（Cauchy）应力和一致切线通过微分得到：\n$$\n\\boldsymbol{\\sigma} = \\frac{\\partial W}{\\partial \\boldsymbol{\\varepsilon}} = \\mathbb{C}_{\\text{lin}}:\\boldsymbol{\\varepsilon} + \\beta\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})^2\\,\\boldsymbol{I},\\quad\n\\mathbb{C} = \\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\boldsymbol{\\varepsilon}} = \\mathbb{C}_{\\text{lin}} + 2\\beta\\,(\\operatorname{tr}\\boldsymbol{\\varepsilon})\\,\\boldsymbol{I}\\otimes\\boldsymbol{I}.\n$$\n在包含张量剪切的Voigt表示法中，平面应变线性刚度为\n$$\n\\mathbb{C}_{\\text{lin}}^{\\text{Voigt}} =\n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0\\\\\n\\lambda & \\lambda + 2\\mu & 0\\\\\n0 & 0 & 2\\mu\n\\end{bmatrix},\n$$\n非线性附加项为\n$$\n\\mathbb{C}_{\\text{nl}}^{\\text{Voigt}} =\n\\begin{bmatrix}\n2\\beta\\,\\operatorname{tr}\\boldsymbol{\\varepsilon} & 2\\beta\\,\\operatorname{tr}\\boldsymbol{\\varepsilon} & 0\\\\\n2\\beta\\,\\operatorname{tr}\\boldsymbol{\\varepsilon} & 2\\beta\\,\\operatorname{tr}\\boldsymbol{\\varepsilon} & 0\\\\\n0 & 0 & 0\n\\end{bmatrix}.\n$$\n\n微观尺度弱形式与离散化：\n微观平衡源于总势能在周期性变分$\\delta \\boldsymbol{w}$下的驻值性：\n$$\n\\delta \\Pi(\\boldsymbol{w};\\bar{\\boldsymbol{E}}) = \\int_{\\Omega}\\boldsymbol{\\sigma}(\\bar{\\boldsymbol{E}} + \\boldsymbol{\\varepsilon}(\\boldsymbol{w})):\\boldsymbol{\\varepsilon}(\\delta \\boldsymbol{w})\\,\\mathrm{d}V = 0.\n$$\n使用双线性四边形单元和相关的$C^0$形函数离散化$\\boldsymbol{w}$。令$\\boldsymbol{w}_h$表示节点涨落未知量向量（经过周期性识别并固定一个参考节点后）。有限元残差为\n$$\n\\boldsymbol{R}(\\boldsymbol{w}_h; \\bar{\\boldsymbol{E}}) = \\sum_{e}\\int_{\\Omega_e} \\boldsymbol{B}_e^{\\mathsf{T}}(\\boldsymbol{x})\\,\\boldsymbol{\\sigma}(\\bar{\\boldsymbol{E}} + \\boldsymbol{B}_e(\\boldsymbol{x})\\boldsymbol{w}_{e})\\,\\mathrm{d}V,\n$$\n其中$\\boldsymbol{B}_e$是将单元节点位移映射到应变向量 $[\\varepsilon_{11},\\varepsilon_{22},\\varepsilon_{12}]^{\\mathsf{T}}$（使用张量剪切$\\varepsilon_{12} = \\tfrac{1}{2}\\left(\\partial u_1/\\partial y + \\partial u_2/\\partial x\\right)$）的标准小应变矩阵。牛顿（Newton）线性化得到切线\n$$\n\\boldsymbol{K}_{ww} = \\frac{\\partial \\boldsymbol{R}}{\\partial \\boldsymbol{w}_h} = \\sum_e \\int_{\\Omega_e}\\boldsymbol{B}_e^{\\mathsf{T}}\\,\\mathbb{C}(\\bar{\\boldsymbol{E}} + \\boldsymbol{B}_e\\boldsymbol{w}_e)\\,\\boldsymbol{B}_e\\,\\mathrm{d}V,\n$$\n牛顿法通过迭代 $\\boldsymbol{K}_{ww}\\,\\Delta \\boldsymbol{w}_h = -\\boldsymbol{R}$ 达到平衡。\n\n宏观应力与一致切线：\n均匀化柯西（Cauchy）应力是体积平均\n$$\n\\bar{\\boldsymbol{\\sigma}}(\\bar{\\boldsymbol{E}}) = \\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}\\left(\\bar{\\boldsymbol{E}} + \\boldsymbol{B}(\\boldsymbol{x})\\boldsymbol{w}_h(\\bar{\\boldsymbol{E}})\\right)\\,\\mathrm{d}V,\n$$\n其单元级贡献通过求积计算。为获得宏观一致切线 $\\mathbb{C}^{\\text{eff}} = \\partial \\bar{\\boldsymbol{\\sigma}}/\\partial \\bar{\\boldsymbol{E}}$，我们对$\\bar{\\boldsymbol{\\sigma}}$进行线性化：\n$$\n\\mathrm{d}\\bar{\\boldsymbol{\\sigma}} = \\frac{1}{|\\Omega|}\\int_{\\Omega}\\mathbb{C}\\,\\mathrm{d}\\boldsymbol{\\varepsilon}\\,\\mathrm{d}V\n= \\frac{1}{|\\Omega|}\\int_{\\Omega}\\mathbb{C}\\left(\\mathrm{d}\\bar{\\boldsymbol{E}} + \\boldsymbol{B}\\,\\mathrm{d}\\boldsymbol{w}_h\\right)\\mathrm{d}V.\n$$\n涨落增量$\\mathrm{d}\\boldsymbol{w}_h$不是独立的，因为在扰动下微观尺度残差必须保持为零。线性化微观尺度残差得到\n$$\n\\mathrm{d}\\boldsymbol{R} = \\boldsymbol{K}_{ww}\\,\\mathrm{d}\\boldsymbol{w}_h + \\boldsymbol{K}_{wE}\\,\\mathrm{d}\\bar{\\boldsymbol{E}} = \\boldsymbol{0},\n$$\n其中\n$$\n\\boldsymbol{K}_{wE} = \\frac{\\partial \\boldsymbol{R}}{\\partial \\bar{\\boldsymbol{E}}} = \\sum_e \\int_{\\Omega_e}\\boldsymbol{B}_e^{\\mathsf{T}}\\,\\mathbb{C}\\,\\mathrm{d}V,\n$$\n因此 $\\mathrm{d}\\boldsymbol{w}_h = -\\boldsymbol{K}_{ww}^{-1}\\boldsymbol{K}_{wE}\\,\\mathrm{d}\\bar{\\boldsymbol{E}}$。代回到$\\mathrm{d}\\bar{\\boldsymbol{\\sigma}}$中得到\n$$\n\\mathrm{d}\\bar{\\boldsymbol{\\sigma}} = \\left[\\frac{1}{|\\Omega|}\\int_{\\Omega}\\mathbb{C}\\,\\mathrm{d}V\\right]\\mathrm{d}\\bar{\\boldsymbol{E}}\n-\n\\left[\\frac{1}{|\\Omega|}\\int_{\\Omega}\\mathbb{C}\\,\\boldsymbol{B}\\,\\mathrm{d}V\\right]\\boldsymbol{K}_{ww}^{-1}\\left[\\sum_e \\int_{\\Omega_e}\\boldsymbol{B}_e^{\\mathsf{T}}\\,\\mathbb{C}\\,\\mathrm{d}V\\right]\\mathrm{d}\\bar{\\boldsymbol{E}}.\n$$\n一旦微观尺度平衡被求解，这就为一致均匀化切线提供了一个可计算的表达式。在矩阵块表示法中，定义\n$$\n\\boldsymbol{S}_E = \\frac{1}{|\\Omega|}\\int_{\\Omega}\\mathbb{C}\\,\\mathrm{d}V,\\quad\n\\boldsymbol{S}_w = \\frac{1}{|\\Omega|}\\int_{\\Omega}\\mathbb{C}\\,\\boldsymbol{B}\\,\\mathrm{d}V,\\quad\n\\boldsymbol{K}_{wE} = \\int_{\\Omega}\\boldsymbol{B}^{\\mathsf{T}}\\,\\mathbb{C}\\,\\mathrm{d}V,\n$$\n得到\n$$\n\\mathbb{C}^{\\text{eff}} = \\boldsymbol{S}_E - \\boldsymbol{S}_w\\,\\boldsymbol{K}_{ww}^{-1}\\,\\boldsymbol{K}_{wE}.\n$$\n所有项都是在收敛的微观尺度状态下通过有限元组装的。\n\n有限差分验证：\n对于给定的$\\bar{\\boldsymbol{E}}$，通过求解 $\\bar{\\boldsymbol{E}}\\pm \\delta \\boldsymbol{e}_j$ 处的微观尺度平衡并构造\n$$\n\\left.\\frac{\\partial \\bar{\\boldsymbol{\\sigma}}}{\\partial \\bar{E}_j}\\right|_{\\text{FD}} \\approx \\frac{\\bar{\\boldsymbol{\\sigma}}(\\bar{\\boldsymbol{E}}+\\delta \\boldsymbol{e}_j) - \\bar{\\boldsymbol{\\sigma}}(\\bar{\\boldsymbol{E}}-\\delta \\boldsymbol{e}_j)}{2\\delta}.\n$$\n来执行 $\\partial \\bar{\\boldsymbol{\\sigma}}/\\partial \\bar{E}_j$ 的中心有限差分近似。收集这些列以构成$\\mathbb{C}^{\\text{FD}}$，并使用相对Frobenius范数误差与$\\mathbb{C}^{\\text{eff}}$进行比较\n$$\n\\mathrm{err} = \\frac{\\|\\mathbb{C}^{\\text{eff}} - \\mathbb{C}^{\\text{FD}}\\|_{\\mathrm{F}}}{\\max(\\|\\mathbb{C}^{\\text{eff}}\\|_{\\mathrm{F}},\\,10^{-14})}.\n$$\n\n算法设计：\n- 在单位正方形上构建一个均匀的$2\\times 2$网格，组装单元连接性和坐标。\n- 通过将$x=1$的节点映射到$x=0$，$y=1$的节点映射到$y=0$来实现周期性识别，以形成主节点；通过固定原点处主节点的涨落来消除刚体模式。\n- 对于每个测试案例，使用单元中心坐标通过棋盘格分配方式设置非均质材料参数。\n- 给定$\\bar{\\boldsymbol{E}}$，使用牛顿（Newton）法求解微观尺度平衡：\n  1. 使用当前$\\boldsymbol{w}_h$通过高斯（Gauss）求积组装残差$\\boldsymbol{R}$和切线$\\boldsymbol{K}_{ww}$。\n  2. 求解$\\boldsymbol{K}_{ww}\\,\\Delta \\boldsymbol{w}_h = -\\boldsymbol{R}$并更新$\\boldsymbol{w}_h$。\n  3. 当残差范数低于预设容差或达到最大迭代次数时停止。\n- 收敛后，组装$\\boldsymbol{S}_E$、$\\boldsymbol{S}_w$、$\\boldsymbol{K}_{wE}$，计算$\\mathbb{C}^{\\text{eff}} = \\boldsymbol{S}_E - \\boldsymbol{S}_w\\,\\boldsymbol{K}_{ww}^{-1}\\,\\boldsymbol{K}_{wE}$，再计算$\\bar{\\boldsymbol{\\sigma}}$。\n- 对于有限差分，将$\\bar{\\boldsymbol{E}}$的每个分量扰动$\\pm \\delta$，重新求解微观尺度平衡，并从$\\bar{\\boldsymbol{\\sigma}}$的中心差分中组装$\\mathbb{C}^{\\text{FD}}$。\n- 将每个测试的相对误差$\\mathrm{err}$报告为浮点数。将三个误差汇总到指定格式的单行中。\n\n测试套件覆盖范围：\n- 测试1考察了一般非均质、非线性、混合加载状态，并验证了完整的凝聚过程。\n- 测试2是零体积应变的纯剪切状态，它会停用三次体积非线性（因为$\\operatorname{tr}\\boldsymbol{\\varepsilon}=0$），重点考察剪切一致性和张量剪切的映射。\n- 测试3处于零宏观应变状态，旨在探究近线性区域，并确保周期性微观涨落解和线性化得到正确处理。\n\n所有计算都是无量纲的，不出现角度，也不需要物理单位。最终输出必须是包含三个误差值的单行列表格式。", "answer": "```python\nimport numpy as np\n\n# FE^2 microscale verification by finite differences of macro strain Ebar\n# Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used)\n\ndef gauss_quadrature_2x2():\n    g = 1.0 / np.sqrt(3.0)\n    pts = [(-g, -g), (g, -g), (g, g), (-g, g)]\n    wts = [1.0, 1.0, 1.0, 1.0]\n    return pts, wts\n\ndef shape_Q4(xi, eta):\n    # Bilinear Q4 shape functions and derivatives wrt xi, eta\n    N = np.array([\n        0.25 * (1 - xi) * (1 - eta),  # N1\n        0.25 * (1 + xi) * (1 - eta),  # N2\n        0.25 * (1 + xi) * (1 + eta),  # N3\n        0.25 * (1 - xi) * (1 + eta)   # N4\n    ])\n    dN_dxi = np.array([\n        -0.25 * (1 - eta),\n         0.25 * (1 - eta),\n         0.25 * (1 + eta),\n        -0.25 * (1 + eta)\n    ])\n    dN_deta = np.array([\n        -0.25 * (1 - xi),\n        -0.25 * (1 + xi),\n         0.25 * (1 + xi),\n         0.25 * (1 - xi)\n    ])\n    return N, dN_dxi, dN_deta\n\ndef plane_strain_C_lin(lambda_, mu):\n    # Voigt with tensorial shear [e11, e22, e12]\n    C = np.array([\n        [lambda_ + 2*mu, lambda_, 0.0],\n        [lambda_, lambda_ + 2*mu, 0.0],\n        [0.0, 0.0, 2*mu]\n    ])\n    return C\n\nclass MicroModel:\n    def __init__(self, nx=2, ny=2):\n        # Build unit square mesh with nx x ny elements\n        self.nx = nx\n        self.ny = ny\n        self.nnx = nx + 1\n        self.nny = ny + 1\n        self.nnode = self.nnx * self.nny\n        # Node coordinates\n        xs = np.linspace(0.0, 1.0, self.nnx)\n        ys = np.linspace(0.0, 1.0, self.nny)\n        coords = np.zeros((self.nnode, 2))\n        nid = 0\n        for j in range(self.nny):\n            for i in range(self.nnx):\n                coords[nid, 0] = xs[i]\n                coords[nid, 1] = ys[j]\n                nid += 1\n        self.coords = coords\n        # Connectivity: Q4 elements\n        conn = []\n        for ey in range(ny):\n            for ex in range(nx):\n                n0 = ey * self.nnx + ex\n                n1 = n0 + 1\n                n2 = n1 + self.nnx\n                n3 = n0 + self.nnx\n                conn.append([n0, n1, n2, n3])\n        self.conn = np.array(conn, dtype=int)\n        self.nelem = self.conn.shape[0]\n        # Precompute quadrature\n        self.qpts, self.qwts = gauss_quadrature_2x2()\n        # Periodic mapping and DOF mapping\n        self._build_periodic_mapping()\n        # Initialize material assignment flags per element (checkerboard)\n        self.mat_flag = np.zeros(self.nelem, dtype=int)\n        self._compute_element_centers_and_flags()\n        # Material parameters placeholders\n        self.matA = (0.0, 0.0, 0.0)  # (lambda, mu, beta)\n        self.matB = (0.0, 0.0, 0.0)\n\n    def _build_periodic_mapping(self):\n        # Identify periodic node sets (x=1 -> x=0, y=1 -> y=0)\n        tol = 1e-12\n        canon = []\n        for a in range(self.nnode):\n            x, y = self.coords[a]\n            cx = 0.0 if abs(x - 1.0) < tol else x\n            cy = 0.0 if abs(y - 1.0) < tol else y\n            canon.append((round(cx, 12), round(cy, 12)))\n        # Map canonical coord to master node (first encountered minimal index)\n        key_to_master = {}\n        for a, key in enumerate(canon):\n            if key not in key_to_master:\n                key_to_master[key] = a\n        # Build node->master mapping\n        node_to_master = np.zeros(self.nnode, dtype=int)\n        for a, key in enumerate(canon):\n            node_to_master[a] = key_to_master[key]\n        self.node_to_master = node_to_master\n        # Fix reference at origin master\n        ref_key = (0.0, 0.0)\n        ref_master = key_to_master[ref_key]\n        self.ref_master = ref_master\n        # Build reduced DOF map: 2 DOFs per master node except reference fixed (-1)\n        master_nodes = sorted(set(node_to_master.tolist()))\n        dof_map = -np.ones(2 * self.nnode, dtype=int)\n        counter = 0\n        for m in master_nodes:\n            for comp in range(2):\n                if m == ref_master:\n                    # fixed DOF\n                    continue\n                ridx = counter\n                counter += 1\n                # Assign this reduced DOF to all node DOFs that map to this master\n                for a in range(self.nnode):\n                    if node_to_master[a] == m:\n                        dof_map[2*a + comp] = ridx\n        self.dof_map = dof_map\n        self.ndof_red = counter\n\n    def _compute_element_centers_and_flags(self):\n        # Compute centers and checkerboard assignment\n        centers = np.zeros((self.nelem, 2))\n        for e in range(self.nelem):\n            nodes = self.conn[e]\n            xy = self.coords[nodes]\n            centers[e] = np.mean(xy, axis=0)\n        self.centers = centers\n        # Checkerboard: (x-0.5)*(y-0.5) >= 0 -> Material A, else B\n        flags = []\n        for c in centers:\n            val = (c[0] - 0.5) * (c[1] - 0.5)\n            flags.append(0 if val < 0 else 1)  # 1 for A, 0 for B\n        self.mat_flag = np.array(flags, dtype=int)\n\n    def set_materials(self, matA, matB):\n        self.matA = matA\n        self.matB = matB\n\n    def _gather_full_w(self, w_red):\n        # Scatter reduced unknowns into full nodal array with periodic mapping\n        w_full = np.zeros(2 * self.nnode)\n        for a in range(self.nnode):\n            for comp in range(2):\n                midx = self.node_to_master[a]\n                dof = 2*midx + comp\n                ridx = self.dof_map[2*a + comp]\n                if ridx >= 0:\n                    w_full[2*a + comp] = w_red[ridx]\n                else:\n                    w_full[2*a + comp] = 0.0\n        return w_full\n\n    def _material_params(self, e):\n        if self.mat_flag[e] == 1:\n            return self.matA\n        else:\n            return self.matB\n\n    def assemble_R_K(self, Ebar_vec, w_red):\n        # Assemble residual R and tangent K_ww for given Ebar and w\n        R = np.zeros(self.ndof_red)\n        K = np.zeros((self.ndof_red, self.ndof_red))\n        w_full = self._gather_full_w(w_red)\n        for e in range(self.nelem):\n            nodes = self.conn[e]\n            xye = self.coords[nodes]\n            # Element DOF indices (full)\n            edofs_full = np.zeros(2*len(nodes), dtype=int)\n            for i, a in enumerate(nodes):\n                edofs_full[2*i] = 2*a\n                edofs_full[2*i+1] = 2*a + 1\n            # Reduced DOF indices mapping\n            edofs_red = self.dof_map[edofs_full]\n            # Material parameters\n            lam, mu, beta = self._material_params(e)\n            C_lin = plane_strain_C_lin(lam, mu)\n            # Element contributions\n            Re = np.zeros(len(edofs_red))\n            Ke = np.zeros((len(edofs_red), len(edofs_red)))\n            # Quadrature\n            for (xi, eta), wt in zip(self.qpts, self.qwts):\n                N, dN_dxi, dN_deta = shape_Q4(xi, eta)\n                # Jacobian\n                J = np.zeros((2, 2))\n                J[0, 0] = np.dot(dN_dxi, xye[:, 0])\n                J[0, 1] = np.dot(dN_dxi, xye[:, 1])\n                J[1, 0] = np.dot(dN_deta, xye[:, 0])\n                J[1, 1] = np.dot(dN_deta, xye[:, 1])\n                detJ = np.linalg.det(J)\n                invJ = np.linalg.inv(J)\n                # Gradients wrt x,y\n                dN = np.vstack((dN_dxi, dN_deta)).T  # 4x2\n                grad = dN @ invJ.T  # 4x2: [dN_dx, dN_dy]\n                # Build B matrix (3 x 8) for tensorial shear\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dNdx = grad[i, 0]\n                    dNdy = grad[i, 1]\n                    B[0, 2*i]   = dNdx\n                    B[1, 2*i+1] = dNdy\n                    B[2, 2*i]   = 0.5 * dNdy\n                    B[2, 2*i+1] = 0.5 * dNdx\n                # Local w at element nodes\n                we = w_full[edofs_full]\n                # Compute strain: Ebar + B * we\n                eps = Ebar_vec + B @ we\n                tr = eps[0] + eps[1]\n                # Local tangent and stress\n                C = C_lin.copy()\n                C[0, 0] += 2.0 * beta * tr\n                C[0, 1] += 2.0 * beta * tr\n                C[1, 0] += 2.0 * beta * tr\n                C[1, 1] += 2.0 * beta * tr\n                sigma = C_lin @ eps + np.array([beta * tr * tr, beta * tr * tr, 0.0])\n                # Residual and tangent contributions\n                dV = detJ * wt\n                BT = B.T\n                Re += BT @ sigma * dV\n                Ke += BT @ C @ B * dV\n            # Scatter to global with reduced DOF mapping\n            nloc = len(edofs_red)\n            for i in range(nloc):\n                ri = edofs_red[i]\n                if ri >= 0:\n                    R[ri] += Re[i]\n                    for j in range(nloc):\n                        rj = edofs_red[j]\n                        if rj >= 0:\n                            K[ri, rj] += Ke[i, j]\n        return R, K\n\n    def assemble_sigma_bar_and_linearization(self, Ebar_vec, w_red):\n        # Assemble sigma_bar, S_E, S_w, K_wE, and K_ww at converged state\n        w_full = self._gather_full_w(w_red)\n        sigma_bar = np.zeros(3)\n        S_E = np.zeros((3, 3))\n        S_w = np.zeros((3, self.ndof_red))\n        K_wE = np.zeros((self.ndof_red, 3))\n        K_ww = np.zeros((self.ndof_red, self.ndof_red))\n        for e in range(self.nelem):\n            nodes = self.conn[e]\n            xye = self.coords[nodes]\n            edofs_full = np.zeros(2*len(nodes), dtype=int)\n            for i, a in enumerate(nodes):\n                edofs_full[2*i] = 2*a\n                edofs_full[2*i+1] = 2*a + 1\n            edofs_red = self.dof_map[edofs_full]\n            lam, mu, beta = self._material_params(e)\n            C_lin = plane_strain_C_lin(lam, mu)\n            for (xi, eta), wt in zip(self.qpts, self.qwts):\n                N, dN_dxi, dN_deta = shape_Q4(xi, eta)\n                J = np.zeros((2, 2))\n                J[0, 0] = np.dot(dN_dxi, xye[:, 0])\n                J[0, 1] = np.dot(dN_dxi, xye[:, 1])\n                J[1, 0] = np.dot(dN_deta, xye[:, 0])\n                J[1, 1] = np.dot(dN_deta, xye[:, 1])\n                detJ = np.linalg.det(J)\n                invJ = np.linalg.inv(J)\n                dN = np.vstack((dN_dxi, dN_deta)).T\n                grad = dN @ invJ.T\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dNdx = grad[i, 0]\n                    dNdy = grad[i, 1]\n                    B[0, 2*i]   = dNdx\n                    B[1, 2*i+1] = dNdy\n                    B[2, 2*i]   = 0.5 * dNdy\n                    B[2, 2*i+1] = 0.5 * dNdx\n                we = w_full[edofs_full]\n                eps = Ebar_vec + B @ we\n                tr = eps[0] + eps[1]\n                C = C_lin.copy()\n                C[0, 0] += 2.0 * beta * tr\n                C[0, 1] += 2.0 * beta * tr\n                C[1, 0] += 2.0 * beta * tr\n                C[1, 1] += 2.0 * beta * tr\n                sigma = C_lin @ eps + np.array([beta * tr * tr, beta * tr * tr, 0.0])\n                dV = detJ * wt\n                # Averages and blocks\n                sigma_bar += sigma * dV  # volume average later\n                S_E += C * dV\n                BT = B.T\n                # Assemble S_w columns\n                # S_w is (3 x ndof_red): add C @ B columns into mapped columns\n                CB = C @ B\n                for loc_col in range(B.shape[1]):\n                    rcol = edofs_red[loc_col]\n                    if rcol >= 0:\n                        S_w[:, rcol] += CB[:, loc_col] * dV\n                # Assemble K_wE rows\n                # K_wE is (ndof_red x 3): add B^T @ C rows into mapped rows\n                BTC = BT @ C  # (8 x 3)\n                for loc_row in range(BT.shape[0]):\n                    rrow = edofs_red[loc_row]\n                    if rrow >= 0:\n                        K_wE[rrow, :] += BTC[loc_row, :] * dV\n                # Assemble K_ww\n                Ke = BT @ C @ B * dV\n                nloc = len(edofs_red)\n                for i in range(nloc):\n                    ri = edofs_red[i]\n                    if ri < 0:\n                        continue\n                    for j in range(nloc):\n                        rj = edofs_red[j]\n                        if rj < 0:\n                            continue\n                        K_ww[ri, rj] += Ke[i, j]\n        # Normalize volume average\n        sigma_bar /= 1.0  # |Omega|=1\n        S_E /= 1.0\n        S_w /= 1.0\n        return sigma_bar, S_E, S_w, K_wE, K_ww\n\n    def newton_solve(self, Ebar_vec, w0=None, tol=1e-12, maxit=50):\n        if w0 is None:\n            w = np.zeros(self.ndof_red)\n        else:\n            w = w0.copy()\n        for it in range(maxit):\n            R, K = self.assemble_R_K(Ebar_vec, w)\n            normR = np.linalg.norm(R)\n            if normR < tol:\n                return w, True, it+1, normR\n            try:\n                dw = np.linalg.solve(K, -R)\n            except np.linalg.LinAlgError:\n                # Try pseudo-inverse fallback\n                dw = -np.linalg.pinv(K) @ R\n            w += dw\n        # Final check\n        R, _ = self.assemble_R_K(Ebar_vec, w)\n        return w, (np.linalg.norm(R) < tol), maxit, np.linalg.norm(R)\n\ndef run_test_case(Ebar_vec, delta, matA, matB):\n    # Build model\n    model = MicroModel(nx=2, ny=2)\n    model.set_materials(matA, matB)\n    # Solve base state\n    w, ok, iters, res = model.newton_solve(Ebar_vec, w0=None, tol=1e-12, maxit=60)\n    # Assemble analytical consistent tangent via micro linearization\n    sigma_bar, S_E, S_w, K_wE, K_ww = model.assemble_sigma_bar_and_linearization(Ebar_vec, w)\n    # Solve for condensed term\n    try:\n        sol = np.linalg.solve(K_ww, K_wE)\n    except np.linalg.LinAlgError:\n        sol = np.linalg.pinv(K_ww) @ K_wE\n    C_eff = S_E - S_w @ sol\n    # Finite-difference approximation\n    C_fd = np.zeros((3, 3))\n    # Use base solution as initial guess for perturbed solves\n    for j in range(3):\n        e = np.zeros(3)\n        e[j] = 1.0\n        E_plus = Ebar_vec + delta * e\n        E_minus = Ebar_vec - delta * e\n        # Solve plus\n        w_plus, okp, _, _ = model.newton_solve(E_plus, w0=w, tol=1e-12, maxit=60)\n        sig_plus, _, _, _, _ = model.assemble_sigma_bar_and_linearization(E_plus, w_plus)\n        # Solve minus\n        w_minus, okm, _, _ = model.newton_solve(E_minus, w0=w, tol=1e-12, maxit=60)\n        sig_minus, _, _, _, _ = model.assemble_sigma_bar_and_linearization(E_minus, w_minus)\n        C_fd[:, j] = (sig_plus - sig_minus) / (2.0 * delta)\n    # Relative Frobenius-norm error\n    num = np.linalg.norm(C_eff - C_fd, ord='fro')\n    den = max(np.linalg.norm(C_eff, ord='fro'), 1e-14)\n    rel_err = num / den\n    return rel_err\n\ndef solve():\n    # Define test cases\n    matA = (1200.0, 800.0, 5.0e4)  # (lambda, mu, beta)\n    matB = (600.0, 400.0, 2.0e4)\n    test_cases = [\n        # (Ebar_vec, delta)\n        (np.array([1.0e-3, -5.0e-4, 2.0e-3]), 1.0e-7),  # Test 1\n        (np.array([0.0, 0.0, 1.0e-3]), 1.0e-7),         # Test 2\n        (np.array([0.0, 0.0, 0.0]), 1.0e-7),            # Test 3\n    ]\n    results = []\n    for Ebar_vec, delta in test_cases:\n        err = run_test_case(Ebar_vec, delta, matA, matB)\n        results.append(err)\n    # Print as a single line list\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2623507"}]}