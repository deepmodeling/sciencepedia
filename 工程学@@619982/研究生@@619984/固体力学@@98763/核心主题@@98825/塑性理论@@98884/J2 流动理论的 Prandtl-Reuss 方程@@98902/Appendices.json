{"hands_on_practices": [{"introduction": "理论是计算的基石。在着手编写复杂的数值模型之前，通过一个经典的解析问题来巩固对基本原理的理解至关重要。本练习将引导你从最基本的Prandtl-Reuss方程出发，为一个简单的单轴拉伸-卸载过程推导出残余应变的表达式，从而将应变分解、硬化法则和弹性卸载等抽象概念与一个可测量的工程量直接联系起来。这个“纸笔”练习不仅可以加深你对本构关系物理意义的理解，其结果也可作为后续验证数值代码的黄金标准 [@problem_id:2673839]。", "problem": "考虑一个遵循关联Prandtl–Reuss方程的小应变、各向同性弹塑性固体，其流动理论为基于第二偏应力不变量（$J_2$）的流动理论，并伴有线性各向同性硬化。总小应变张量可加法分解为 $\\boldsymbol{\\varepsilon}=\\boldsymbol{\\varepsilon}^{e}+\\boldsymbol{\\varepsilon}^{p}$，且弹性响应为线性，杨氏模量为 $E$。屈服函数为带有各向同性硬化的von Mises型函数，即 $f(\\boldsymbol{\\sigma},\\bar{\\varepsilon}^{p})=\\sigma_{\\mathrm{eq}}-\\sigma_{y}(\\bar{\\varepsilon}^{p})\\le 0$，其中 $\\sigma_{\\mathrm{eq}}=\\sqrt{\\tfrac{3}{2}\\,\\mathbf{s}:\\mathbf{s}}$ 是由偏应力 $\\mathbf{s}$ 构建的等效应力，$\\sigma_{y}(\\bar{\\varepsilon}^{p})=\\sigma_{y0}+H\\,\\bar{\\varepsilon}^{p}$，其中 $\\sigma_{y0}$ 为恒定的初始屈服强度，$H$ 为硬化模量。塑性流动是关联的（Prandtl–Reuss），等效塑性应变定义为 $d\\bar{\\varepsilon}^{p}=\\sqrt{\\tfrac{2}{3}\\,d\\boldsymbol{\\varepsilon}^{p}:d\\boldsymbol{\\varepsilon}^{p}}$。\n\n沿 $x_1$ 方向进行单轴拉伸试验：试样被单调应变至总轴向应变 $\\varepsilon_{\\max}$，该应变严格大于弹性屈服应变，然后在无反向塑性流动的情况下卸载至零应力。假设为小应变，且加载过程中的应力状态为单轴拉伸，其中 $\\sigma_{11}=\\sigma>0$，$\\sigma_{22}=\\sigma_{33}=0$，且所有剪应力均为零。\n\n根据上述模型的基本原理，推导完全卸载后的剩余轴向应变 $\\varepsilon_{\\mathrm{res}}$ 的表达式，该表达式应以 $E$、$H$、$\\sigma_{y0}$ 和 $\\varepsilon_{\\max}$ 表示。然后使用 $E=200\\,\\mathrm{GPa}$、$\\sigma_{y0}=300\\,\\mathrm{MPa}$、$H=1.2\\,\\mathrm{GPa}$ 和 $\\varepsilon_{\\max}=0.015$ 对其进行求值。你可以假定 $\\varepsilon_{\\max}>\\sigma_{y0}/E$，以确保卸载前发生塑性变形。将最终数值答案四舍五入至四位有效数字，并表示为无量纲小数（无单位）。", "solution": "我们从小时变加法分解 $\\boldsymbol{\\varepsilon}=\\boldsymbol{\\varepsilon}^{e}+\\boldsymbol{\\varepsilon}^{p}$ 和线性弹性理论出发。在单轴应力 $\\sigma_{11}=\\sigma>0$ 状态下，我们有轴向弹性关系\n$$\n\\sigma=E\\,\\varepsilon^{e}_{11}=E\\left(\\varepsilon_{11}-\\varepsilon^{p}_{11}\\right).\n$$\n带有线性各向同性硬化的von Mises屈服函数为\n$$\nf(\\boldsymbol{\\sigma},\\bar{\\varepsilon}^{p})=\\sigma_{\\mathrm{eq}}-\\sigma_{y}(\\bar{\\varepsilon}^{p})=\\sigma_{\\mathrm{eq}}-\\big(\\sigma_{y0}+H\\bar{\\varepsilon}^{p}\\big)\\le 0.\n$$\n对于单轴应力 $\\sigma_{22}=\\sigma_{33}=0$，偏应力分量为 $s_{11}=\\tfrac{2}{3}\\sigma$，$s_{22}=s_{33}=-\\tfrac{1}{3}\\sigma$，从而得到 $\\sigma_{\\mathrm{eq}}=\\sqrt{\\tfrac{3}{2}\\,\\mathbf{s}:\\mathbf{s}}=|\\sigma|=\\sigma$（当 $\\sigma>0$ 时）。\n\n关联Prandtl–Reuss流动法则为\n$$\nd\\boldsymbol{\\varepsilon}^{p}=d\\lambda\\,\\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}=d\\lambda\\,\\frac{3}{2}\\,\\frac{\\mathbf{s}}{\\sigma_{\\mathrm{eq}}}.\n$$\n根据等效塑性应变的定义，\n$$\nd\\bar{\\varepsilon}^{p}=\\sqrt{\\tfrac{2}{3}\\,d\\boldsymbol{\\varepsilon}^{p}:d\\boldsymbol{\\varepsilon}^{p}}=\\sqrt{\\tfrac{2}{3}\\left(d\\lambda\\,\\tfrac{3}{2}\\,\\tfrac{\\mathbf{s}}{\\sigma_{\\mathrm{eq}}}\\right):\\left(d\\lambda\\,\\tfrac{3}{2}\\,\\tfrac{\\mathbf{s}}{\\sigma_{\\mathrm{eq}}}\\right)}=d\\lambda,\n$$\n因此 $d\\bar{\\varepsilon}^{p}=d\\lambda$。在单轴拉伸（$\\sigma>0$）中，轴向塑性应变增量可由流动方向得出：\n$$\nd\\varepsilon^{p}_{11}=d\\lambda\\,\\frac{3}{2}\\frac{s_{11}}{\\sigma_{\\mathrm{eq}}}=d\\lambda\\,\\frac{3}{2}\\frac{(2/3)\\sigma}{\\sigma}=d\\lambda=d\\bar{\\varepsilon}^{p}.\n$$\n因此，在单调单轴拉伸过程中，轴向塑性应变等于等效塑性应变，即 $\\varepsilon^{p}_{11}=\\bar{\\varepsilon}^{p}$（指其累积值）。\n\n在塑性加载期间（$f=0$ 且加载继续），一致性条件 $df=0$ 给出\n$$\nd\\sigma_{\\mathrm{eq}}-H\\,d\\bar{\\varepsilon}^{p}=0.\n$$\n由于 $\\sigma_{\\mathrm{eq}}=\\sigma$（当 $\\sigma>0$），我们有 $d\\sigma=H\\,d\\bar{\\varepsilon}^{p}$。根据弹性理论，\n$$\nd\\sigma=E\\big(d\\varepsilon_{11}-d\\varepsilon^{p}_{11}\\big)=E\\big(d\\varepsilon_{11}-d\\bar{\\varepsilon}^{p}\\big).\n$$\n令二者相等，\n$$\nE\\big(d\\varepsilon_{11}-d\\bar{\\varepsilon}^{p}\\big)=H\\,d\\bar{\\varepsilon}^{p}\\quad\\Longrightarrow\\quad d\\bar{\\varepsilon}^{p}=\\frac{E}{E+H}\\,d\\varepsilon_{11}.\n$$\n当 $\\sigma=\\sigma_{y0}$ 时开始发生塑性变形，这对应于弹性屈服应变\n$$\n\\varepsilon_{y}=\\frac{\\sigma_{y0}}{E}.\n$$\n从初始屈服点（$\\varepsilon_{11}=\\varepsilon_{y}$，$\\bar{\\varepsilon}^{p}=0$）积分到加载结束时达到的最大总应变 $\\varepsilon_{11}=\\varepsilon_{\\max}$，\n$$\n\\bar{\\varepsilon}^{p}\\big|_{\\mathrm{end}}=\\int_{\\varepsilon_{y}}^{\\varepsilon_{\\max}}\\frac{E}{E+H}\\,d\\varepsilon_{11}=\\frac{E}{E+H}\\,\\big(\\varepsilon_{\\max}-\\varepsilon_{y}\\big).\n$$\n此时，应力等于当前屈服应力。对于率无关各向同性硬化模型，在无反向加载的卸载条件下，卸载至零应力的过程是弹性的（不产生新的塑性应变）。因此，当卸载至 $\\sigma\\to 0$ 时，弹性应变消失（$\\varepsilon^{e}_{11}\\to 0$），剩余应变为纯塑性应变：\n$$\n\\varepsilon_{\\mathrm{res}}=\\varepsilon^{p}_{11}\\big|_{\\mathrm{end}}=\\bar{\\varepsilon}^{p}\\big|_{\\mathrm{end}}=\\frac{E}{E+H}\\left(\\varepsilon_{\\max}-\\frac{\\sigma_{y0}}{E}\\right).\n$$\n\n现在进行数值计算。将模量转换为一致的单位（例如 $\\mathrm{MPa}$）：$E=200\\,\\mathrm{GPa}=200{,}000\\,\\mathrm{MPa}$，$H=1.2\\,\\mathrm{GPa}=1{,}200\\,\\mathrm{MPa}$，以及 $\\sigma_{y0}=300\\,\\mathrm{MPa}$。弹性屈服应变为\n$$\n\\varepsilon_{y}=\\frac{\\sigma_{y0}}{E}=\\frac{300}{200{,}000}=0.0015.\n$$\n塑性因子为\n$$\n\\frac{E}{E+H}=\\frac{200{,}000}{200{,}000+1{,}200}=\\frac{200{,}000}{201{,}200}=\\frac{500}{503}\\approx 0.9940357853.\n$$\n因此，\n$$\n\\varepsilon_{\\mathrm{res}}=\\frac{E}{E+H}\\left(\\varepsilon_{\\max}-\\varepsilon_{y}\\right)=\\left(\\frac{500}{503}\\right)\\left(0.015-0.0015\\right)=\\left(\\frac{500}{503}\\right)(0.0135)\\approx 0.0134194831.\n$$\n将结果四舍五入至四位有效数字并表示为无量纲小数，剩余应变为 $0.01342$。", "answer": "$$\\boxed{0.01342}$$", "id": "2673839"}, {"introduction": "从理论到代码的桥梁是数值算法，而在塑性力学中，返回映射算法（Return Mapping Algorithm）是核心。本练习旨在揭示该算法深刻的数学内涵：它等价于一个约束优化问题，即在应力空间中寻找离“试探应力”最近的屈服面上的点。通过分别实现该问题的解析解（径向返回）和迭代数值解，你将亲手验证这一等价性，从而从几何和变分原理的高度理解返回映射算法的本质，为处理更复杂的塑性模型打下坚实的基础 [@problem_id:2673804]。", "problem": "考虑微小应变、率无关、关联 von Mises 塑性（也称为偏应力第二不变量 (J2) 塑性），其流动法则为 Prandtl–Reuss 法则，且为理想塑性（无硬化）。令 Cauchy 应力为对称张量 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$，其偏量部分为 $\\mathbf{s} = \\operatorname{dev}(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\tfrac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})\\mathbf{I}$，静水压力为 $p = \\tfrac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})$。von Mises 屈服函数为\n$$\nf(\\boldsymbol{\\sigma}) = \\sqrt{\\tfrac{3}{2}}\\,\\|\\mathbf{s}\\|_F - \\sigma_y \\le 0,\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数，$\\sigma_y > 0$ 为屈服应力。关联塑性的 Prandtl–Reuss 流动法则指定塑性应变增量的方向为应力空间中屈服面的外法线方向。\n\n对于固定的时间步长和给定的弹性预测（试探应力）$\\boldsymbol{\\sigma}^{\\text{tr}}$，该理想塑性模型在偏应力空间中的增量变分原理可简化为以下凸最小化问题：\n- 在满足 $\\operatorname{tr}(\\mathbf{s})=0$ 的偏应力 $\\mathbf{s} \\in \\mathbb{R}^{3 \\times 3}$ 上最小化目标函数\n$$\n\\Phi(\\mathbf{s}) = \\tfrac{1}{2}\\,\\|\\mathbf{s} - \\mathbf{s}^{\\text{tr}}\\|_F^2\n$$\n并满足 von Mises 容许性约束\n$$\n\\sqrt{\\tfrac{3}{2}}\\,\\|\\mathbf{s}\\|_F \\le \\sigma_y.\n$$\n注意，对于此模型和时间步，静水压力部分 $p = \\tfrac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma}^{\\text{tr}})$ 不受塑性流动影响而保持不变，因此完整的更新后应力为 $\\boldsymbol{\\sigma} = \\mathbf{s} + p\\,\\mathbf{I}$。\n\n您的任务是实现：\n1) 针对上述偏应力空间中的最小化问题，实现一个数值求解器。该求解器应使用迭代投影梯度法（或同等稳健的一阶方法），并能对任意试探偏应力 $\\mathbf{s}^{\\text{tr}}$ 收敛到唯一的最小化子。\n2) 通过在时间步结束时强制实施 Prandtl–Reuss 流动方向和一致性条件，推导出一个解析闭式映射（在偏应力空间中通常称为“径向返回”）。\n3) 一个验证程序，对每个给定的试探应力，计算：\n   - 数值最小化得到的偏应力 $\\mathbf{s}^{\\star}_{\\text{num}}$ 及相应的更新后全应力 $\\boldsymbol{\\sigma}_{\\text{num}} = \\mathbf{s}^{\\star}_{\\text{num}} + p\\,\\mathbf{I}$，\n   - 解析法得到的偏应力 $\\mathbf{s}^{\\star}_{\\text{rad}}$ 及更新后全应力 $\\boldsymbol{\\sigma}_{\\text{rad}} = \\mathbf{s}^{\\star}_{\\text{rad}} + p\\,\\mathbf{I}$，\n   - 两种方法的塑性乘子增量 $\\Delta\\gamma$，由理想塑性下 Prandtl–Reuss 方程的一致性条件定义，其中剪切模量为 $\\mu$（详见下文）。\n最后，为每个测试用例报告一个布尔值，当且仅当两种方法得到的更新后全应力和塑性乘子增量在规定的数值容差内一致时，该值为真。\n\n您可以使用的理论基础：\n- 小应变线性弹性：$\\boldsymbol{\\sigma} = \\mathbb{C}:(\\boldsymbol{\\varepsilon}-\\boldsymbol{\\varepsilon}^p)$，其中拉梅剪切模量 $\\mu = \\tfrac{E}{2(1+\\nu)}$ 由杨氏模量 $E$ 和泊松比 $\\nu$ 导出。\n- 偏/静水分解 $\\boldsymbol{\\sigma} = \\mathbf{s} + p\\,\\mathbf{I}$，Frobenius 范数 $\\|\\cdot\\|_F$，以及基本的凸优化原理（严格凸目标函数在凸可行集上的存在性和唯一性）。\n- J2 塑性的关联流动（Prandtl–Reuss）：塑性应变增量方向垂直于屈服面，当步长为塑性时，步末的一致性条件决定了塑性乘子增量 $\\Delta\\gamma$。\n\n材料常数和单位：\n- 使用 $E = 210 \\times 10^9$ 帕斯卡，$\\nu = 0.3$，因此 $\\mu = \\tfrac{E}{2(1+\\nu)}$ 帕斯卡。\n- 使用屈服应力 $\\sigma_y = 400 \\times 10^6$ 帕斯卡。\n- 下面提供的所有应力单位均为帕斯卡。输出的布尔值是无量纲的。\n\n测试集（试探应力）：\n令 $\\mathbf{I}$ 表示 $3 \\times 3$ 单位矩阵。定义以下 $3 \\times 3$ 对称试探应力 $\\boldsymbol{\\sigma}^{\\text{tr}}_k$：\n- 情况 1 (内部): $\\mathbf{s}_1^{\\text{tr}} = \\operatorname{diag}(100\\!\\times\\!10^6,\\,-50\\!\\times\\!10^6,\\,-50\\!\\times\\!10^6)$, $p_1 = 50\\!\\times\\!10^6$, $\\boldsymbol{\\sigma}^{\\text{tr}}_1 = \\mathbf{s}_1^{\\text{tr}} + p_1 \\mathbf{I}$。\n- 情况 2 (屈服面上): $\\mathbf{s}_2^{\\text{tr}} = \\sigma_y \\,\\operatorname{diag}\\!\\big(\\tfrac{2}{3},\\,-\\tfrac{1}{3},\\,-\\tfrac{1}{3}\\big)$, $p_2 = -20\\!\\times\\!10^6$, $\\boldsymbol{\\sigma}^{\\text{tr}}_2 = \\mathbf{s}_2^{\\text{tr}} + p_2 \\mathbf{I}$。\n- 情况 3 (略微超出): $\\mathbf{s}_3^{\\text{tr}} = 1.05\\,\\mathbf{s}_2^{\\text{tr}}$, $p_3 = 30\\!\\times\\!10^6$, $\\boldsymbol{\\sigma}^{\\text{tr}}_3 = \\mathbf{s}_3^{\\text{tr}} + p_3 \\mathbf{I}$。\n- 情况 4 (远超出): 令 $r_y = \\sqrt{\\tfrac{2}{3}}\\,\\sigma_y$ 且 $a = \\tfrac{3\\,r_y}{\\sqrt{2}}$。设 $\\mathbf{s}_4^{\\text{tr}} = \\operatorname{diag}(a,\\,-a,\\,0)$, $p_4 = -100\\!\\times\\!10^6$, $\\boldsymbol{\\sigma}^{\\text{tr}}_4 = \\mathbf{s}_4^{\\text{tr}} + p_4 \\mathbf{I}$。\n- 情况 5 (零): $\\boldsymbol{\\sigma}^{\\text{tr}}_5 = \\mathbf{0}$。\n- 情况 6 (纯静水压力): $\\boldsymbol{\\sigma}^{\\text{tr}}_6 = 120\\!\\times\\!10^6\\,\\mathbf{I}$。\n- 情况 7 (带非对角项的外部点):\n$$\n\\mathbf{s}_7^{\\text{tr}} = 10^8\\begin{bmatrix}\n2 & -1 & 0.5\\\\\n-1 & -3 & 0.2\\\\\n0.5 & 0.2 & 1\n\\end{bmatrix},\\quad\np_7 = 15\\!\\times\\!10^6,\\quad \\boldsymbol{\\sigma}^{\\text{tr}}_7 = \\mathbf{s}_7^{\\text{tr}} + p_7 \\mathbf{I}.\n$$\n\n验证和输出规范：\n- 对于每个情况 $k \\in \\{1,\\dots,7\\}$，通过数值求解 $\\mathbf{s}$ 中的最小化问题，然后加上不变的静水压力部分 $p\\,\\mathbf{I}$ 来重构全应力，从而计算 $\\boldsymbol{\\sigma}_{\\text{num}}$。同时，根据数值最小化子所蕴含的 Prandtl–Reuss 一致性条件计算 $\\Delta\\gamma_{\\text{num}}$。\n- 与此同时，根据理想塑性的 Prandtl–Reuss 方程推导出的闭式径向映射，计算解析返回应力 $\\boldsymbol{\\sigma}_{\\text{rad}}$ 及相应的塑性乘子增量 $\\Delta\\gamma_{\\text{rad}}$。\n- 对于每个情况，评估一个布尔值，当且仅当以下两个条件同时满足时，该值为真：\n  1) $\\boldsymbol{\\sigma}_{\\text{num}}$ 和 $\\boldsymbol{\\sigma}_{\\text{rad}}$ 之间的相对 Frobenius 范数差异不大于 $10^{-10}$，以及\n  2) $\\Delta\\gamma_{\\text{num}}$ 和 $\\Delta\\gamma_{\\text{rad}}$ 之间的相对差异不大于 $10^{-12}$（对于弹性步，允许的精确值为零）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如：`[True,False,True,...]`）。\n\n角度单位不适用。不涉及百分比。最终的布尔值是无量纲的。", "solution": "本问题是计算固体力学中一个标准且适定的问题，具体涉及率无关 $J_2$ 理想塑性的返回映射算法的实现。核心任务是找到一个试探偏应力状态在 von Mises 屈服面上的最近点投影，该屈服面在主应力空间中是一个椭球体，而在配备了 Frobenius 范数的偏应力张量空间中是一个球面。我们被要求使用两种方法——一种是解析闭式解，另一种是迭代数值方法——来解决这个问题，并验证它们的一致性。\n\n首先，我们建立数学框架。Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 被加法分解为其偏量部分 $\\mathbf{s}$ 和静水压力部分 $p\\mathbf{I}$，其中 $\\mathbf{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})\\mathbf{I}$ 且 $p = \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})$。对于 $J_2$ 流动理论，静水压力响应是纯弹性的，因此塑性流动不影响压力，即 $p = p^{\\text{tr}}$。问题因此简化到偏应力空间中。\n\nvon Mises 屈服准则由 $f(\\boldsymbol{\\sigma}) = \\sqrt{\\frac{3}{2}}\\|\\mathbf{s}\\|_F - \\sigma_y \\le 0$ 给出。容许的偏应力集合是在五维对称偏张量空间中以原点为中心的闭球，由约束 $\\|\\mathbf{s}\\|_F \\le \\sqrt{\\frac{2}{3}}\\sigma_y$ 定义。我们将此球的半径定义为 $r_y = \\sqrt{\\frac{2}{3}}\\sigma_y$。\n\n问题是在约束 $\\|\\mathbf{s}\\|_F \\le r_y$ 下最小化目标函数 $\\Phi(\\mathbf{s}) = \\frac{1}{2}\\|\\mathbf{s} - \\mathbf{s}^{\\text{tr}}\\|_F^2$。这是一个将点 $\\mathbf{s}^{\\text{tr}}$ 投影到闭合凸集（半径为 $r_y$ 的球）上的经典欧几里得投影问题。\n\n**解析解（径向返回映射）**\n\n解 $\\mathbf{s}^\\star$ 的存在性和唯一性由目标函数的严格凸性以及可行集的闭合凸性保证。该解可以通过考察 Karush-Kuhn-Tucker (KKT) 条件找到，但对于到球上的投影，其解在几何上是直观的。\n\n设试探屈服函数值为 $f^{\\text{tr}} = \\sqrt{\\frac{3}{2}}\\|\\mathbf{s}^{\\text{tr}}\\|_F - \\sigma_y$。存在两种情况：\n\n1.  **弹性步**：如果 $f^{\\text{tr}} \\le 0$，这等价于 $\\|\\mathbf{s}^{\\text{tr}}\\|_F \\le r_y$，则试探应力 $\\mathbf{s}^{\\text{tr}}$ 已经在容许区域内。由于 $\\mathbf{s}^{\\text{tr}}$ 是 $\\Phi(\\mathbf{s})$ 的无约束最小化子，它也是有约束的最小化子。因此，更新后的偏应力为 $\\mathbf{s}^\\star_{\\text{rad}} = \\mathbf{s}^{\\text{tr}}$。此时没有塑性变形，因此塑性乘子增量为 $\\Delta\\gamma_{\\text{rad}} = 0$。\n\n2.  **塑性步**：如果 $f^{\\text{tr}} > 0$，即 $\\|\\mathbf{s}^{\\text{tr}}\\|_F > r_y$，则试探应力在屈服面之外。球内距离 $\\mathbf{s}^{\\text{tr}}$ 最近的点位于边界（屈服面）上，并且从原点出发的方向与 $\\mathbf{s}^{\\text{tr}}$ 相同。这就是“径向返回”的概念。通过将 $\\mathbf{s}^{\\text{tr}}$ 按比例缩放回球的表面来获得解：\n    $$\n    \\mathbf{s}^\\star_{\\text{rad}} = r_y \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F} = \\sqrt{\\frac{2}{3}}\\sigma_y \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F}.\n    $$\n    相应的塑性乘子增量 $\\Delta\\gamma_{\\text{rad}}$ 从离散的本构方程确定。弹性预测-塑性修正格式给出的更新后应力为 $\\mathbf{s} = \\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\boldsymbol{\\varepsilon}^p$，其中 $\\mu$ 是剪切模量。$J_2$ 塑性的关联流动法则表明 $\\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\gamma \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\Delta\\gamma \\sqrt{\\frac{3}{2}}\\frac{\\mathbf{s}}{\\|\\mathbf{s}\\|_F}$。将此代入应力更新公式，并利用在塑性步中 $\\mathbf{s}$ 与 $\\mathbf{s}^{\\text{tr}}$ 共线的事实（即，对于 $\\mathbf{s}^{\\text{tr}} \\neq \\mathbf{0}$，有 $\\frac{\\mathbf{s}}{\\|\\mathbf{s}\\|_F} = \\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F}$）：\n    $$\n    \\mathbf{s} = \\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\gamma \\sqrt{\\frac{3}{2}}\\frac{\\mathbf{s}^{\\text{tr}}}{\\|\\mathbf{s}^{\\text{tr}}\\|_F}.\n    $$\n    对两边取 Frobenius 范数可得 $\\|\\mathbf{s}\\|_F = \\|\\mathbf{s}^{\\text{tr}}\\|_F - 2\\mu\\Delta\\gamma\\sqrt{\\frac{3}{2}}$。由于最终状态在屈服面上，$\\|\\mathbf{s}\\|_F = r_y = \\sqrt{\\frac{2}{3}}\\sigma_y$。求解 $\\Delta\\gamma$ 可得：\n    $$\n    \\Delta\\gamma_{\\text{rad}} = \\frac{\\|\\mathbf{s}^{\\text{tr}}\\|_F - r_y}{2\\mu\\sqrt{3/2}} = \\frac{\\|\\mathbf{s}^{\\text{tr}}\\|_F - \\sqrt{2/3}\\sigma_y}{2\\mu\\sqrt{3/2}} = \\frac{\\sqrt{3/2}\\|\\mathbf{s}^{\\text{tr}}\\|_F - \\sigma_y}{3\\mu} = \\frac{f^{\\text{tr}}}{3\\mu}.\n    $$\n\n在两种情况下，完整的更新后应力都重构为 $\\boldsymbol{\\sigma}_{\\text{rad}} = \\mathbf{s}^\\star_{\\text{rad}} + p^{\\text{tr}}\\mathbf{I}$。\n\n**数值解（投影梯度法）**\n\n该问题使用投影梯度法进行数值求解，这是一种适用于约束凸优化的一阶迭代算法。迭代公式如下：\n$$\n\\mathbf{s}_{k+1} = P_C(\\mathbf{s}_k - \\alpha \\nabla\\Phi(\\mathbf{s}_k)),\n$$\n其中 $P_C$ 是到可行集 $C = \\{\\mathbf{s} \\in \\mathbb{R}^{3 \\times 3} \\mid \\operatorname{tr}(\\mathbf{s})=0, \\|\\mathbf{s}\\|_F \\le r_y\\}$ 的投影算子，$\\alpha$ 是步长。目标函数的梯度为 $\\nabla\\Phi(\\mathbf{s}) = \\mathbf{s} - \\mathbf{s}^{\\text{tr}}$。迭代变为：\n$$\n\\mathbf{s}_{k+1} = P_C((1-\\alpha)\\mathbf{s}_k + \\alpha \\mathbf{s}^{\\text{tr}}).\n$$\n一个偏张量 $\\mathbf{T}$ 的投影 $P_C(\\mathbf{T})$ 就是将其径向返回到半径为 $r_y$ 的球上：$P_C(\\mathbf{T}) = \\min\\left(1, \\frac{r_y}{\\|\\mathbf{T}\\|_F}\\right)\\mathbf{T}$。为保证收敛，步长 $\\alpha$ 必须在 $(0, 2/L)$ 范围内，其中 L 是梯度的 Lipschitz 常数。对于我们的问题，$L=1$，所以任何 $\\alpha \\in (0, 2)$ 都能保证收敛。我们选择 $\\alpha=0.5$ 以保证稳健性，并用 $\\mathbf{s}_0 = \\mathbf{0}$ 进行初始化。迭代持续进行，直到变化量 $\\|\\mathbf{s}_{k+1} - \\mathbf{s}_k\\|_F$ 低于指定的容差。\n\n令收敛的数值解为 $\\mathbf{s}^\\star_{\\text{num}}$。为求得相应的塑性乘子 $\\Delta\\gamma_{\\text{num}}$，我们重排应力更新方程 $\\mathbf{s}^\\star_{\\text{num}} = \\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\boldsymbol{\\varepsilon}^p$。用 $\\mathbf{s}^\\star_{\\text{num}}$ 作内积（Frobenius 点积）可得：\n$$\n\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F^2 = \\mathbf{s}^\\star_{\\text{num}}:\\mathbf{s}^{\\text{tr}} - 2\\mu\\Delta\\gamma_{\\text{num}}\\sqrt{\\frac{3}{2}}\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F.\n$$\n求解 $\\Delta\\gamma_{\\text{num}}$（当 $\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F > 0$ 时）：\n$$\n\\Delta\\gamma_{\\text{num}} = \\frac{\\mathbf{s}^\\star_{\\text{num}}:\\mathbf{s}^{\\text{tr}} - \\|\\mathbf{s}^\\star_{\\text{num}}\\|_F^2}{2\\mu\\sqrt{3/2}\\|\\mathbf{s}^\\star_{\\text{num}}\\|_F}.\n$$\n这个公式是通用的。如果是弹性步，数值解会收敛到 $\\mathbf{s}^\\star_{\\text{num}} = \\mathbf{s}^{\\text{tr}}$，导致分子为零，因此 $\\Delta\\gamma_{\\text{num}} = 0$。如果是塑性步，它提供了与数值解一致的值。对于 $\\mathbf{s}^{\\text{tr}}=\\mathbf{0}$，解为 $\\mathbf{s}^\\star_{\\text{num}}=\\mathbf{0}$ 且 $\\Delta\\gamma_{\\text{num}}=0$。全应力为 $\\boldsymbol{\\sigma}_{\\text{num}} = \\mathbf{s}^\\star_{\\text{num}} + p^{\\text{tr}}\\mathbf{I}$。\n\n**验证**\n\n对于每个测试用例，我们计算两种方法的结果，并根据两个标准验证它们的一致性：\n1.  全应力张量 Frobenius 范数的相对差异：$\\frac{\\|\\boldsymbol{\\sigma}_{\\text{num}} - \\boldsymbol{\\sigma}_{\\text{rad}}\\|_F}{\\|\\boldsymbol{\\sigma}_{\\text{rad}}\\|_F} \\le 10^{-10}$。如果 $\\|\\boldsymbol{\\sigma}_{\\text{rad}}\\|_F=0$，则检查绝对差异 $\\|\\boldsymbol{\\sigma}_{\\text{num}}\\|_F$ 是否低于容差。\n2.  塑性乘子之间的相对差异：$\\frac{|\\Delta\\gamma_{\\text{num}} - \\Delta\\gamma_{\\text{rad}}|}{|\\Delta\\gamma_{\\text{rad}}|} \\le 10^{-12}$。如果 $\\Delta\\gamma_{\\text{rad}}=0$，则检查绝对值 $|\\Delta\\gamma_{\\text{num}}|$ 是否低于一个小的容差。\n\n当且仅当两个条件都满足时，报告布尔值 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the J2 plasticity problem using analytical and numerical methods,\n    and verifies their agreement for a suite of test cases.\n    \"\"\"\n\n    # Material constants\n    E = 210e9  # Young's modulus in Pa\n    NU = 0.3   # Poisson's ratio\n    SIGMA_Y = 400e6  # Yield stress in Pa\n    MU = E / (2.0 * (1.0 + NU))  # Shear modulus in Pa\n    # Radius of the yield surface in deviatoric stress space\n    R_Y = np.sqrt(2.0/3.0) * SIGMA_Y\n\n    def get_deviatoric(sigma):\n        \"\"\"Computes the deviatoric part of a 3x3 stress tensor.\"\"\"\n        return sigma - (1.0/3.0) * np.trace(sigma) * np.eye(3)\n\n    def get_pressure(sigma):\n        \"\"\"Computes the hydrostatic pressure from a 3x3 stress tensor.\"\"\"\n        return (1.0/3.0) * np.trace(sigma)\n\n    def frobenius_norm(tensor):\n        \"\"\"Computes the Frobenius norm of a tensor.\"\"\"\n        return np.linalg.norm(tensor, 'fro')\n\n    def solve_analytical(sigma_tr):\n        \"\"\"\n        Computes the updated stress and plastic multiplier using the\n        analytical radial return method.\n        \"\"\"\n        s_tr = get_deviatoric(sigma_tr)\n        p = get_pressure(sigma_tr)\n        \n        norm_s_tr = frobenius_norm(s_tr)\n        \n        # Check if trial stress is inside or on the yield surface\n        yield_func_val = np.sqrt(3.0/2.0) * norm_s_tr - SIGMA_Y\n        \n        if yield_func_val <= 1e-12:  # Elastic or on-surface step\n            s_star = s_tr\n            delta_gamma = 0.0\n        else:  # Plastic step\n            s_star = R_Y * s_tr / norm_s_tr\n            delta_gamma = (np.sqrt(3.0/2.0) * norm_s_tr - SIGMA_Y) / (3.0 * MU)\n\n        sigma_star = s_star + p * np.eye(3)\n        return sigma_star, delta_gamma\n\n    def solve_numerical(sigma_tr, alpha=0.5, tol=1e-15, max_iter=1000):\n        \"\"\"\n        Computes the updated stress and plastic multiplier using a\n        projected gradient method.\n        \"\"\"\n        s_tr = get_deviatoric(sigma_tr)\n        p = get_pressure(sigma_tr)\n\n        s_num = np.zeros((3, 3))  # Initial guess s_0 = 0\n\n        for _ in range(max_iter):\n            s_old = s_num\n            # Gradient descent step\n            s_arg = (1.0 - alpha) * s_old + alpha * s_tr\n            \n            # Projection onto the feasible set\n            norm_s_arg = frobenius_norm(s_arg)\n            if norm_s_arg > R_Y:\n                s_num = R_Y * s_arg / norm_s_arg\n            else:\n                s_num = s_arg\n            \n            # Convergence check\n            norm_s_old = frobenius_norm(s_old)\n            if frobenius_norm(s_num - s_old) < tol * (1.0 + norm_s_old):\n                break\n        \n        # Compute the corresponding plastic multiplier\n        norm_s_num = frobenius_norm(s_num)\n        if norm_s_num < 1e-15:\n            delta_gamma_num = 0.0\n        else:\n            dot_product = np.sum(s_num * s_tr)  # s_num : s_tr\n            numerator = dot_product - norm_s_num**2\n            denominator = 2.0 * MU * np.sqrt(3.0/2.0) * norm_s_num\n            delta_gamma_num = numerator / denominator\n\n        sigma_num = s_num + p * np.eye(3)\n        return sigma_num, delta_gamma_num\n\n    # Define test cases\n    I = np.eye(3)\n    s1_tr = np.diag([100e6, -50e6, -50e6])\n    p1 = 50e6\n    s2_tr = SIGMA_Y * np.diag([2.0/3.0, -1.0/3.0, -1.0/3.0])\n    p2 = -20e6\n    s3_tr = 1.05 * s2_tr\n    p3 = 30e6\n    a = np.sqrt(3.0) * SIGMA_Y\n    s4_tr = np.diag([a, -a, 0.0])\n    p4 = -100e6\n    s7_tr = 1e8 * np.array([[2.0, -1.0,  0.5],\n                             [-1.0, -3.0, 0.2],\n                             [0.5,  0.2, 1.0]])\n    p7 = 15e6\n\n    test_cases_tr = [\n        s1_tr + p1 * I,\n        s2_tr + p2 * I,\n        s3_tr + p3 * I,\n        s4_tr + p4 * I,\n        np.zeros((3, 3)),\n        120e6 * I,\n        s7_tr + p7 * I\n    ]\n\n    results = []\n    \n    TOL_STRESS = 1e-10\n    TOL_GAMMA_REL = 1e-12\n    TOL_GAMMA_ABS = 1e-15\n\n    for sigma_tr in test_cases_tr:\n        # Analytical solution\n        sigma_rad, delta_gamma_rad = solve_analytical(sigma_tr)\n        \n        # Numerical solution\n        sigma_num, delta_gamma_num = solve_numerical(sigma_tr)\n        \n        # Verification\n        # 1. Stress comparison\n        norm_sigma_rad = frobenius_norm(sigma_rad)\n        norm_diff_sigma = frobenius_norm(sigma_num - sigma_rad)\n        \n        if norm_sigma_rad < 1e-15:\n            sigma_ok = norm_diff_sigma < TOL_STRESS\n        else:\n            sigma_ok = (norm_diff_sigma / norm_sigma_rad) <= TOL_STRESS\n            \n        # 2. Plastic multiplier comparison\n        if abs(delta_gamma_rad) < TOL_GAMMA_ABS:\n            gamma_ok = abs(delta_gamma_num) < TOL_GAMMA_ABS\n        else:\n            gamma_ok = abs(delta_gamma_num - delta_gamma_rad) / abs(delta_gamma_rad) <= TOL_GAMMA_REL\n\n        results.append(sigma_ok and gamma_ok)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2673804"}, {"introduction": "最后一个练习是一项综合性的计算任务，它将前面学到的理论和算法知识融会贯通，指导你构建并严格验证一个包含线性硬化的单轴弹塑性本构模型。在计算力学中，仅仅实现一个模型是远远不够的，必须通过一系列精心设计的测试来确保其能准确反映材料的关键物理行为。这个练习将引导你编写一个“本构驱动程序”，并通过加载、卸载和再加载等测试用例，系统地检验模型的弹性响应、塑性流动以及屈服面的演化是否正确，这是成为一名合格的计算力学工程师所必需的实践技能 [@problem_id:2673864]。", "problem": "设计并实现一个由 Prandtl-Reuss 方程控制、具有线性各向同性硬化的关联 von Mises（第二偏应力不变量，J2）小应变弹塑性模型的单轴本构更新。目标是通过一个加载-卸载-再加载的数值实验，验证所实现的模型表现出弹性卸载特性，并在再加载时能正确恢复屈服面。解决方案必须基于基本原理，并且除了下面指定的基础理论外，不得依赖任何预先组合好的公式。所有应力必须以兆帕（MPa）为单位，所有应变均为无量纲。本问题不涉及角度。所有最终输出必须是布尔值。\n\n待使用的基础理论：\n- 运动学：小应变加法分解 $\\,\\varepsilon = \\varepsilon^{e} + \\varepsilon^{p}\\,$, 其中 $\\,\\varepsilon\\,$ 是总应变，$\\,\\varepsilon^{e}\\,$ 是弹性应变，$\\,\\varepsilon^{p}\\,$ 是塑性应变。\n- 线性弹性：$\\,\\sigma = E\\,\\varepsilon^{e} = E(\\varepsilon - \\varepsilon^{p})\\,$, 其中 $\\,\\sigma\\,$ 是 Cauchy 应力，$\\,E\\,$ 是杨氏模量。\n- Von Mises 屈服条件 (J2)：一般形式为 $\\,f(\\sigma,\\alpha) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(\\alpha) \\le 0\\,$, 其中 $\\,\\sigma_{\\mathrm{eq}} = \\sqrt{\\tfrac{3}{2}}\\,\\|s\\|\\,$ 是等效应力，$\\,s\\,$ 是偏应力，$\\,\\sigma_{y}(\\alpha)\\,$ 是取决于硬化变量 $\\,\\alpha\\,$ 的当前屈服应力。\n- 关联流动法则 (Prandtl-Reuss)：$\\,\\dot{\\varepsilon}^{p} = \\dot{\\lambda}\\,\\dfrac{\\partial f}{\\partial \\sigma}\\,$, 其中满足 $\\,\\dot{\\lambda} \\ge 0\\,$, $\\,f \\le 0\\,$ 及 $\\,\\dot{\\lambda}\\,f = 0\\,$ (Kuhn–Tucker 条件)，并且在塑性加载期间满足一致性条件 $\\,\\dot{\\lambda}\\,\\dot{f} = 0\\,$。\n- 线性各向同性硬化：$\\,\\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\,\\alpha\\,$, 其中 $\\,\\sigma_{y0}\\,$ 是初始屈服应力，$\\,H\\,$ 是硬化模量。对于 J2 关联塑性，硬化变量 $\\,\\alpha\\,$ 是累积等效塑性应变，其变化率满足 $\\,\\dot{\\alpha} = \\dot{\\lambda}\\,$。\n\n在单轴应力状态下，可以利用 von Mises 等效应力等于轴向应力的绝对值 (即 $\\,\\sigma_{\\mathrm{eq}} = |\\sigma|\\,$) 以及关联流动法则意味着塑性应变沿轴向发生且其符号由轴向应力决定这一事实，将通用的 J2 关系一致地简化为一维。程序必须实现一个增量式返回映射更新算法，该算法在每个指定的总应变步下，强制执行屈服条件和带硬化的流动法则，在适用时遵循弹性域的规定，并在需要时执行塑性修正。\n\n您的程序必须：\n- 实现一个单轴更新函数，该函数将一系列总应变 $\\,\\{\\varepsilon_{n}\\}\\,$ 和材料参数 $\\,E\\,$, $\\,\\sigma_{y0}\\,$, $\\,H\\,$ 作为输入，并从 $\\,\\varepsilon^{p}_{0} = 0\\,$ 和 $\\,\\alpha_{0} = 0\\,$ 开始计算。\n- 在每一步 $\\,n\\,$，通过强制执行基础理论（弹性预测，以及在需要时进行与关联 J2 塑性和线性各向同性硬化一致的塑性修正），计算应力 $\\,\\sigma_{n}\\,$、塑性应变 $\\,\\varepsilon^{p}_{n}\\,$ 和硬化变量 $\\,\\alpha_{n}\\,$。\n- 在屈服评估中使用鲁棒的容差，并为下面要求的检查报告布尔值。\n\n测试套件：\n实现以下四个独立的测试用例，每个用例都由材料参数和指定的应变路径定义。所有应力单位为 MPa，应变为无量纲。\n\n- 测试 A（塑性加载后的弹性卸载验证）：\n  - 材料：$\\,E = 210000\\,$, $\\,\\sigma_{y0} = 300\\,$, $\\,H = 1200\\,$.\n  - 应变路径：$\\,\\left[\\,0.0,\\, 0.0020,\\, 0.0010,\\, 0.0\\,\\right]\\,$.\n  - 要求的布尔输出：当且仅当在从 $\\,0.0020\\,$ 卸载到 $\\,0.0\\,$ 的过程中以下两个条件都成立时，结果为真：\n    - 塑性应变 $\\,\\varepsilon^{p}\\,$ 在 $\\,10^{-10}\\,$ 的相对容差内保持不变。\n    - 每个卸载段上的割线斜率 $\\,\\dfrac{\\Delta \\sigma}{\\Delta \\varepsilon}\\,$ 在 $\\,10^{-8}\\,$ 的相对容差内等于 $\\,E\\,$。\n\n- 测试 B（纯弹性加载-卸载）：\n  - 材料：$\\,E = 70000\\,$, $\\,\\sigma_{y0} = 300\\,$, $\\,H = 500\\,$.\n  - 应变路径：$\\,\\left[\\,0.0,\\, 0.0020,\\, 0.0\\,\\right]\\,$.\n  - 要求的布尔输出：当且仅当以下条件成立时，结果为真：\n    - 在所有步骤中，$\\,\\varepsilon^{p} = 0\\,$（在 $\\,10^{-14}\\,$ 的绝对容差内）。\n    - 加载和卸载段上的割线斜率 $\\,\\dfrac{\\Delta \\sigma}{\\Delta \\varepsilon}\\,$ 均在 $\\,10^{-12}\\,$ 的相对容差内等于 $\\,E\\,$。\n\n- 测试 C（接近屈服初始点的加载下的屈服边界处理）：\n  - 材料：$\\,E = 200000\\,$, $\\,\\sigma_{y0} = 250\\,$, $\\,H = 1000\\,$.\n  - 应变路径：$\\,\\left[\\,0.0,\\, 0.0012505\\,\\right]\\,$.\n  - 要求的布尔输出：当且仅当以下条件成立时，结果为真：\n    - 在最后一步，屈服函数残差 $\\,r = |\\sigma| - (\\sigma_{y0} + H\\,\\alpha)\\,$ 满足 $\\,|r| \\le 10^{-9}\\,$。\n    - 硬化变量从零增加，即 $\\,\\alpha > 0\\,$。\n\n- 测试 D（从塑性状态弹性卸载后再加载时的再屈服应力恢复）：\n  - 材料：$\\,E = 200000\\,$, $\\,\\sigma_{y0} = 250\\,$, $\\,H = 1000\\,$.\n  - 应变路径阶段：\n    - 加载至塑性状态，然后弹性卸载至接近零应力的状态：$\\,\\left[\\,0.0,\\, 0.0025,\\, 0.001244\\,\\right]\\,$。\n    - 记录在初次加载峰值（$\\varepsilon = 0.0025$）时的塑性应变 $\\,\\varepsilon^{p}_{\\star}\\,$ 和硬化变量 $\\,\\alpha_{\\star}\\,$。\n    - 理论上，再屈服将发生在总应变达到初次加载峰值应变时。定义预测再屈服点 $\\,\\varepsilon_{\\mathrm{pred}} = 0.0025\\,$。\n    - 从卸载后的状态开始，使用跨越该预测点的两个总应变步骤进行再加载：$\\,0.0025 - 10^{-6}\\,$ 和 $\\,0.0025 + 10^{-6}\\,$。\n  - 要求的布尔输出：当且仅当以下所有条件都成立时，结果为真：\n    - 在 $\\,0.0025 - 10^{-6}\\,$ 处，该步是弹性的：$\\,\\alpha\\,$ 在 $\\,10^{-12}\\,$ 的绝对容差内等于 $\\,\\alpha_{\\star}\\,$。\n    - 在 $\\,0.0025 + 10^{-6}\\,$ 处，屈服函数残差 $\\,r = |\\sigma| - (\\sigma_{y0} + H\\,\\alpha)\\,$ 满足 $\\,|r| \\le 10^{-9}\\,$ 并且 $\\,\\alpha > \\alpha_{\\star}\\,$。\n\n您的程序必须生成单行输出，其中包含测试 A-D 的四个布尔结果，格式为方括号括起来的逗号分隔列表（例如，“[True,False,True,True]”）。", "solution": "该问题要求为具有线性各向同性硬化的单轴、小应变、关联 $J_2$ 弹塑性模型设计并实现一个本构更新算法。该实现的有效性将通过一系列四个数值实验来验证。\n\n问题陈述具有科学依据、提法恰当且完整。它描述了连续介质塑性力学中的一个标准模型，提供了所有必要的方程、材料参数、初始条件和加载历史。验证标准是客观且可通过数值验证的。因此，该问题是有效的，其解将从所提供的基本原理中推导出来。\n\n解决方案的核心是基于后向欧拉积分格式的增量更新过程，通常称为返回映射算法。该算法包括一个弹性预测步，以及在屈服条件被违反时的一个塑性修正步。我们将为指定的一维情况推导此算法。\n\n设一个时间增量（步 $n$）开始时的状态已知：$(\\sigma_{n}, \\varepsilon^{p}_{n}, \\alpha_{n})$。给定该增量步结束时的总应变 $\\varepsilon_{n+1}$。我们的目标是计算状态 $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$。\n\n从 $n$ 到 $n+1$ 增量步上离散化的基本关系如下：\n1.  应变加法分解：$\\varepsilon_{n+1} = \\varepsilon^{e}_{n+1} + \\varepsilon^{p}_{n+1}$\n2.  线性弹性应力-应变关系：$\\sigma_{n+1} = E \\cdot \\varepsilon^{e}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n3.  离散流动法则：$\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\varepsilon^{p} = \\varepsilon^{p}_{n} + \\Delta\\lambda \\cdot \\text{sign}(\\sigma_{n+1})$\n4.  离散硬化定律：$\\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\lambda$\n5.  屈服条件：$f_{n+1} = |\\sigma_{n+1}| - (\\sigma_{y0} + H \\alpha_{n+1}) \\le 0$\n6.  Kuhn-Tucker 加载/卸载条件：$\\Delta\\lambda \\ge 0$, $f_{n+1} \\le 0$, $\\Delta\\lambda \\cdot f_{n+1} = 0$\n\n此处，$\\Delta\\lambda$ 是塑性乘子增量，它量化了该步内的塑性流动量。项 $\\text{sign}(\\sigma_{n+1})$ 源于对单轴情况下 $\\partial f/\\partial \\sigma = \\partial |\\sigma|/\\partial \\sigma$ 的求值。\n\n算法在每个增量步中按两个主要阶段进行。\n\n**第 1 步：弹性预测**\n首先，我们假设整个应变增量是纯弹性的。这等同于将塑性乘子增量设为零，即 $\\Delta\\lambda = 0$。计算得到的“试探”状态为：\n- 试探塑性应变：$\\varepsilon^{p, \\text{tr}}_{n+1} = \\varepsilon^{p}_{n}$\n- 试探硬化变量：$\\alpha^{\\text{tr}}_{n+1} = \\alpha_{n}$\n- 试探应力：$\\sigma^{\\text{tr}}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p, \\text{tr}}_{n+1}) = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$\n\n**第 2 步：屈服检查与塑性修正**\n接下来，我们检查该试探应力是否违反了由增量步开始时状态所定义的屈服条件。我们在试探状态下评估屈服函数：\n$$f^{\\text{tr}} = |\\sigma^{\\text{tr}}_{n+1}| - \\sigma_{y}(\\alpha_{n}) = |\\sigma^{\\text{tr}}_{n+1}| - (\\sigma_{y0} + H \\alpha_{n})$$\n\n有两种可能的结果：\n\n**情况 I：弹性步 ($f^{\\text{tr}} \\le 0$)**\n如果试探屈服函数不为正，则试探应力在屈服面内部或其上。弹性步的假设是正确的。增量步结束时的状态即为试探状态：\n- $\\sigma_{n+1} = \\sigma^{\\text{tr}}_{n+1}$\n- $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}$\n- $\\alpha_{n+1} = \\alpha_{n}$\n在这种情况下，$\\Delta\\lambda = 0$，满足 Kuhn-Tucker 条件。\n\n**情况 II：塑性步 ($f^{\\text{tr}} > 0$)**\n如果试探屈服函数为正，则试探应力位于屈服面之外，这在物理上是不允许的。必须发生塑性变形，以将应力状态拉回到屈服面上。状态必须被更新以满足一致性条件 $f_{n+1} = 0$。这就是塑性修正或“返回映射”步。\n\n我们必须找到满足控制方程的非负值 $\\Delta\\lambda$。将流动法则 (3) 代入弹性定律 (2)：\n$$\\sigma_{n+1} = E (\\varepsilon_{n+1} - (\\varepsilon^{p}_{n} + \\Delta\\lambda \\cdot \\text{sign}(\\sigma_{n+1})))$$\n认识到 $\\sigma^{\\text{tr}}_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$，并且对于这个简单模型，在修正过程中应力方向不改变符号，因此 $\\text{sign}(\\sigma_{n+1}) = \\text{sign}(\\sigma^{\\text{tr}}_{n+1})$，我们有：\n$$\\sigma_{n+1} = \\sigma^{\\text{tr}}_{n+1} - E \\cdot \\Delta\\lambda \\cdot \\text{sign}(\\sigma^{\\text{tr}}_{n+1})$$\n对两边取绝对值，得到：\n$$|\\sigma_{n+1}| = |\\sigma^{\\text{tr}}_{n+1}| - E \\cdot \\Delta\\lambda$$\n\n最终应力必须位于更新后的屈服面上，因此根据屈服条件 (5) 和硬化定律 (4)：\n$$|\\sigma_{n+1}| = \\sigma_{y0} + H \\alpha_{n+1} = \\sigma_{y0} + H (\\alpha_{n} + \\Delta\\lambda)$$\n\n将 $|\\sigma_{n+1}|$ 的两个表达式相等：\n$$|\\sigma^{\\text{tr}}_{n+1}| - E \\cdot \\Delta\\lambda = \\sigma_{y0} + H \\alpha_{n} + H \\cdot \\Delta\\lambda$$\n我们现在可以求解未知的一致性参数 $\\Delta\\lambda$：\n$$|\\sigma^{\\text{tr}}_{n+1}| - (\\sigma_{y0} + H \\alpha_{n}) = (E + H) \\Delta\\lambda$$\n左边恰好是试探屈服函数 $f^{\\text{tr}}$。因此：\n$$\\Delta\\lambda = \\frac{f^{\\text{tr}}}{E + H} = \\frac{|\\sigma^{\\text{tr}}_{n+1}| - (\\sigma_{y0} + H \\alpha_{n})}{E + H}$$\n由于我们处于塑性情况（$f^{\\text{tr}} > 0$），并且 $E$ 和 $H$ 都是非负的材料常数（$E>0$），因此 $\\Delta\\lambda > 0$，这与 Kuhn-Tucker 条件一致。\n\n确定 $\\Delta\\lambda$ 后，更新状态变量：\n1.  硬化变量：$\\alpha_{n+1} = \\alpha_{n} + \\Delta\\lambda$\n2.  塑性应变：$\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\lambda \\cdot \\text{sign}(\\sigma^{\\text{tr}}_{n+1})$\n3.  应力：$\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n\n至此，更新算法的推导完成。该算法是鲁棒的，将用于执行所需的数值实验。对于每个测试用例，指定的应变路径将被离散化，并使用此逻辑增量式地更新状态。然后，每一步的最终状态将用于验证问题陈述中列出的条件。", "answer": "```python\nimport numpy as np\n\ndef _uniaxial_update_step(current_state, next_total_strain, E, sigy0, H):\n    \"\"\"\n    Performs a single incremental update step for the uniaxial J2 model.\n\n    Args:\n        current_state (tuple): (sigma_n, ep_n, alpha_n).\n        next_total_strain (float): Total strain at step n+1.\n        E (float): Young's modulus.\n        sigy0 (float): Initial yield stress.\n        H (float): Hardening modulus.\n\n    Returns:\n        tuple: (sigma_n+1, ep_n+1, alpha_n+1).\n    \"\"\"\n    _, ep_n, alpha_n = current_state\n\n    # Elastic predictor\n    sig_tr = E * (next_total_strain - ep_n)\n\n    # Yield function check\n    f_tr = np.abs(sig_tr) - (sigy0 + H * alpha_n)\n\n    if f_tr <= 1e-12:  # Using a small tolerance for floating point comparisons\n        # Elastic step\n        sig_n1 = sig_tr\n        ep_n1 = ep_n\n        alpha_n1 = alpha_n\n    else:\n        # Plastic corrector\n        delta_lambda = f_tr / (E + H)\n        alpha_n1 = alpha_n + delta_lambda\n        # np.sign(0) is 0, which is correct for sig_tr = 0\n        ep_n1 = ep_n + delta_lambda * np.sign(sig_tr)\n        sig_n1 = E * (next_total_strain - ep_n1)\n\n    return sig_n1, ep_n1, alpha_n1\n\ndef run_simulation(material_params, strain_path, initial_state=(0.0, 0.0, 0.0)):\n    \"\"\"\n    Runs a full simulation over a given strain path.\n\n    Args:\n        material_params (tuple): (E, sigy0, H).\n        strain_path (list): Sequence of total strains.\n        initial_state (tuple): Initial state (sigma, ep, alpha).\n\n    Returns:\n        tuple: (strains, sigmas, eps, alphas) history lists.\n    \"\"\"\n    E, sigy0, H = material_params\n    \n    strains = list(strain_path)\n    sigmas = [initial_state[0]]\n    eps = [initial_state[1]]  # Plastic strains\n    alphas = [initial_state[2]]\n\n    current_state = initial_state\n    for i in range(len(strains) - 1):\n        next_strain = strains[i+1]\n        next_state = _uniaxial_update_step(current_state, next_strain, E, sigy0, H)\n        \n        sigmas.append(next_state[0])\n        eps.append(next_state[1])\n        alphas.append(next_state[2])\n        current_state = next_state\n        \n    return strains, np.array(sigmas), np.array(eps), np.array(alphas)\n\n\ndef test_A():\n    \"\"\"Elastic unloading verification after plastic loading.\"\"\"\n    E, sigy0, H = 210000.0, 300.0, 1200.0\n    strain_path = [0.0, 0.0020, 0.0010, 0.0]\n    strains, sigmas, eps, _ = run_simulation((E, sigy0, H), strain_path)\n\n    # Unloading occurs from state 1 to 2, and 2 to 3.\n    # Check 1: Plastic strain remains constant during unloading.\n    # ep_1 is the plastic strain after first load, it should not be zero.\n    ep_check1 = np.isclose(eps[2], eps[1], rtol=1e-10, atol=0)\n    ep_check2 = np.isclose(eps[3], eps[2], rtol=1e-10, atol=0)\n    ep_const_check = ep_check1 and ep_check2 and eps[1] > 1e-9\n\n    # Check 2: Secant slope on unloading segments equals E.\n    # Avoid division by zero, although strain diffs are non-zero here.\n    slope12 = (sigmas[2] - sigmas[1]) / (strains[2] - strains[1])\n    slope_check1 = np.isclose(slope12, E, rtol=1e-8, atol=0)\n    \n    slope23 = (sigmas[3] - sigmas[2]) / (strains[3] - strains[2])\n    slope_check2 = np.isclose(slope23, E, rtol=1e-8, atol=0)\n    \n    slope_E_check = slope_check1 and slope_check2\n    \n    return ep_const_check and slope_E_check\n\ndef test_B():\n    \"\"\"Purely elastic loading-unloading.\"\"\"\n    E, sigy0, H = 70000.0, 300.0, 500.0\n    strain_path = [0.0, 0.0020, 0.0]\n    strains, sigmas, eps, _ = run_simulation((E, sigy0, H), strain_path)\n\n    # Check 1: Plastic strain is zero throughout.\n    ep_zero_check = np.all(np.abs(eps) <= 1e-14)\n    \n    # Check 2: Secant slopes on loading and unloading equal E.\n    slope01 = (sigmas[1] - sigmas[0]) / (strains[1] - strains[0])\n    slope12 = (sigmas[2] - sigmas[1]) / (strains[2] - strains[1])\n    \n    slope_load_check = np.isclose(slope01, E, rtol=1e-12, atol=0)\n    slope_unload_check = np.isclose(slope12, E, rtol=1e-12, atol=0)\n    slope_E_check = slope_load_check and slope_unload_check\n\n    return ep_zero_check and slope_E_check\n\ndef test_C():\n    \"\"\"Yield boundary handling at near-onset loading.\"\"\"\n    E, sigy0, H = 200000.0, 250.0, 1000.0\n    strain_path = [0.0, 0.0012505]\n    _, sigmas, _, alphas = run_simulation((E, sigy0, H), strain_path)\n\n    final_sigma = sigmas[-1]\n    final_alpha = alphas[-1]\n\n    # Check 1: Yield function residual is near zero.\n    residual = np.abs(final_sigma) - (sigy0 + H * final_alpha)\n    residual_check = abs(residual) <= 1e-9\n\n    # Check 2: Hardening variable has increased.\n    hardening_check = final_alpha > 0\n\n    return residual_check and hardening_check\n\ndef test_D():\n    \"\"\"Re-yield stress recovery upon reloading.\"\"\"\n    E, sigy0, H = 200000.0, 250.0, 1000.0\n    material_params = (E, sigy0, H)\n    \n    # Stage 1: Load to a plastic state and unload elastically.\n    load_unload_path = [0.0, 0.0025, 0.001244]\n    _, sig_hist1, ep_hist1, alpha_hist1 = run_simulation(material_params, load_unload_path)\n    \n    ep_star = ep_hist1[1]  # at peak strain\n    alpha_star = alpha_hist1[1] # at peak strain\n\n    # State at the end of unloading\n    initial_state_reload = (sig_hist1[2], ep_hist1[2], alpha_hist1[2])\n\n    # Stage 2: Define reloading path\n    # Predicted re-yield strain is the peak strain of the previous load\n    eps_pred = 0.0025\n    eps_A = eps_pred - 1e-6\n    eps_B = eps_pred + 1e-6\n    \n    reload_path = [load_unload_path[-1], eps_A, eps_B]\n    \n    # Stage 3: Run reloading simulation\n    _, sig_hist2, _, alpha_hist2 = run_simulation(material_params, reload_path, initial_state=initial_state_reload)\n\n    # Check 1: Step to eps_A is elastic\n    # alpha at eps_A (index 1 in reload history) should equal alpha_star\n    alpha_A = alpha_hist2[1]\n    check_elastic = np.isclose(alpha_A, alpha_star, atol=1e-12, rtol=0)\n\n    # Check 2: Step to eps_B is plastic\n    sig_B = sig_hist2[2]\n    alpha_B = alpha_hist2[2]\n    \n    # Yield function residual check\n    residual_B = np.abs(sig_B) - (sigy0 + H * alpha_B)\n    check_residual = abs(residual_B) <= 1e-9\n    \n    # Hardening increase check\n    check_hardening = alpha_B > alpha_star\n    \n    check_plastic = check_residual and check_hardening\n    \n    return check_elastic and check_plastic\n\n\ndef solve():\n    \"\"\"\n    Executes all test cases and prints the results in the required format.\n    \"\"\"\n    results = [test_A(), test_B(), test_C(), test_D()]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2673864"}]}