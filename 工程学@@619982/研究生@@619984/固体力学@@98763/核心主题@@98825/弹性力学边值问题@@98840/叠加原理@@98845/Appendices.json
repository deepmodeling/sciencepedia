{"hands_on_practices": [{"introduction": "静态超定结构在工程中无处不在，但仅靠静力平衡方程无法求解。叠加原理允许我们将这些复杂问题分解为我们已知解的、更简单的静态确定问题。本练习将巩固您运用叠加原理和变形协调条件求解超定结构中未知反力的能力，这是结构分析的一项基本技能。[@problem_id:630180]", "problem": "一根长度为 $L$、抗弯刚度为恒定值 $EI$ 的均匀梁，其一端 $x=0$ 处为固定（悬臂）端，另一端 $x=L$ 处搁在一个简支支座（一个支柱）上。这种结构被称为简支悬臂梁。该梁承受一个竖向分布荷载 $w(x)$，其集度从固定端的 $w_1$ 线性变化到支承端的 $w_2$。因此，荷载分布由下式给出：\n$$\nw(x) = w_1 + (w_2 - w_1) \\frac{x}{L}\n$$\n这是一个静不定系统。为了求解支座反力，必须考虑梁的挠度。叠加原理是进行此分析的一种有效方法。\n\n使用叠加原理，推导位于 $x=L$ 处简支支座的竖向反力 $R_B$ 的表达式。\n\n为方便推导，下面提供了一些标准荷载工况下，长度为 $L$ 的悬臂梁在自由端的向下挠度：\n1.  自由端承受集中荷载 $P$：$\\delta_P = \\frac{PL^3}{3EI}$\n2.  承受集度为恒定值 $w$ 的均布荷载：$\\delta_w = \\frac{wL^4}{8EI}$\n3.  承受三角形分布荷载，固定端集度为 $0$，自由端集度为 $w_{max}$：$\\delta_{tri} = \\frac{w_{max}L^4}{30EI}$", "solution": "我们将一个悬臂梁上的实际线性变化荷载与一个在 $x=L$ 处的向上集中反力 $R_B$ 进行叠加，并强制 $x=L$ 处的挠度为零。\n\n1. 分解荷载\n   $$w(x)=w_1+\\frac{w_2-w_1}{L}x\n     =\\underbrace{w_1}_{\\text{均布}}+\\underbrace{\\frac{w_2-w_1}{L}x}_{\\text{三角形}}。$$\n\n2. 由均布部分引起的自由端（$x=L$）挠度\n   $$\\delta_{\\rm uni}\n     =\\frac{w_1L^4}{8EI}。$$\n\n3. 由三角形部分引起的挠度（固定端为零，自由端为 $w_2-w_1$）\n   $$\\delta_{\\rm tri}\n     =\\frac{(w_2-w_1)L^4}{30EI}。$$\n\n4. 由自由端的向上集中荷载 $R_B$ 引起的挠度（以向下为正）\n   $$\\delta_{R_B}\n     =-\\,\\frac{R_B\\,L^3}{3EI}。$$\n\n5. 变形协调条件：$x=L$ 处的总挠度为零\n   $$\\delta_{\\rm uni}+\\delta_{\\rm tri}+\\delta_{R_B}=0\n   \\;\\Longrightarrow\\;\n   \\frac{w_1L^4}{8EI}+\\frac{(w_2-w_1)L^4}{30EI}-\\frac{R_B\\,L^3}{3EI}=0。$$\n\n6. 求解 $R_B$\n   $$\\frac{L^4}{EI}\\Bigl(\\frac{w_1}{8}+\\frac{w_2-w_1}{30}\\Bigr)\n     =\\frac{R_B\\,L^3}{3EI}\n   \\;\\Longrightarrow\\;\n   R_B\n     =3L\\Bigl(\\frac{w_1}{8}+\\frac{w_2-w_1}{30}\\Bigr)\n     =\\frac{L\\,(11w_1+4w_2)}{40}。$$", "answer": "$$\\boxed{\\frac{L\\,(11w_1+4w_2)}{40}}$$", "id": "630180"}, {"introduction": "叠加原理的应用远不止分析梁的受力，它在连续介质力学中也是分析复杂应力状态的强大工具。本练习演示了如何叠加已知的应力场——在此案例中是由远场载荷和内部压力引起的应力场——来确定几何不连续点周围的最终应力分布。掌握这项技能使您能够分析和控制应力集中，这对于预防材料失效和设计耐用构件至关重要。[@problem_id:630098]", "problem": "一块无限、薄、各向同性、线弹性的板含有一个半径为 $R$ 的圆孔。该板受到远场双轴应力场的作用，主应力 $\\sigma_x$ 和 $\\sigma_y$ 分别沿笛卡尔坐标轴 $x$ 和 $y$ 方向作用。此外，孔的边界承受均匀的内压 $p$。\n\n无限板中圆孔周围在不同载荷情况下，极坐标 $(r, \\theta)$ 下的应力分量如下所示。角度 $\\theta$ 从 $x$ 轴正方向逆时针测量。\n\n1.  对于沿 $x$ 轴作用的远场单轴拉伸 $\\sigma_0$，孔边界（$r=R$）处的切向应力由 Kirsch 方程给出：\n    $$ \\sigma_{\\theta\\theta}(R, \\theta) = \\sigma_0 (1 - 2\\cos(2\\theta)) $$\n2.  对于施加在孔边界上的均匀内压 $p$，且无穷远处应力为零的情况，Lamé 解给出的边界切向应力为：\n    $$ \\sigma_{\\theta\\theta}(R) = p $$\n\n利用叠加原理，推导一个用 $\\sigma_x$ 和 $\\sigma_y$ 表示内压 $p$ 的表达式，该表达式使得孔边界处的最小切向应力等于零。可假定 $\\sigma_x > \\sigma_y > 0$。", "solution": "我们叠加三种载荷情况：沿 $x$ 轴的远场拉伸 $\\sigma_x$，沿 $y$ 轴的远场拉伸 $\\sigma_y$，以及内压 $p$。\n\n1. 沿 $x$ 轴的远场单轴拉伸 $\\sigma_x$ (Kirsch)：\n$$\n\\sigma_{\\theta\\theta}^{(x)}(R,\\theta)=\\sigma_x\\bigl(1-2\\cos2\\theta\\bigr).\n$$\n\n2. 沿 $y$ 轴的远场单轴拉伸 $\\sigma_y$ 等效于 Kirsch 解中 $\\theta\\to\\theta+\\tfrac\\pi2$ 的情况：\n$$\n\\sigma_{\\theta\\theta}^{(y)}(R,\\theta)\n=\\sigma_y\\bigl[1-2\\cos2(\\theta+\\tfrac\\pi2)\\bigr]\n=\\sigma_y\\bigl(1+2\\cos2\\theta\\bigr).\n$$\n\n3. 均匀内压 $p$ 给出\n$$\n\\sigma_{\\theta\\theta}^{(p)}(R)=p.\n$$\n\n根据叠加原理，\n$$\n\\sigma_{\\theta\\theta}(R,\\theta)\n=\\sigma_x(1-2\\cos2\\theta)+\\sigma_y(1+2\\cos2\\theta)+p\n=\\bigl(\\sigma_x+\\sigma_y+p\\bigr)+2(\\sigma_y-\\sigma_x)\\cos2\\theta.\n$$\n\n因为 $\\sigma_x>\\sigma_y$，所以系数 $2(\\sigma_y-\\sigma_x)<0$，因此当 $\\cos2\\theta=1$ 时出现最小值：\n$$\n\\sigma_{\\min}\n=(\\sigma_x+\\sigma_y+p)+2(\\sigma_y-\\sigma_x)\n=-\\sigma_x+3\\sigma_y+p.\n$$\n\n要求 $\\sigma_{\\min}=0$ 可得\n$$\np=\\sigma_x-3\\sigma_y.\n$$", "answer": "$$\\boxed{\\sigma_x-3\\sigma_y}$$", "id": "630098"}, {"introduction": "在现代工程实践中，我们常使用有限元等计算方法来分析复杂结构在多种载荷工况下的响应。本练习将叠加原理转化为一种高效的计算算法，其核心是使用影响向量（即对单位载荷的响应）。您将通过预先计算少数几个关键响应，然后线性组合它们，从而在无需重复进行昂贵模拟的情况下，快速求解多种不同载荷组合下的问题。这项实践将理论力学与实用的计算工程联系起来，揭示了基本原理如何能够极大地提高数值分析的效率。[@problem_id:2699158]", "problem": "一个离散线性弹性系统由一个对称正定刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 建模，该矩阵通过线性平衡方程 $K u = f$ 将节点位移向量 $u \\in \\mathbb{R}^{n}$ 与节点力向量 $f \\in \\mathbb{R}^{n}$ 联系起来。根据映射 $f \\mapsto u$ 的线性，叠加原理成立。要求您通过从小规模的典范影响解集合中组合响应，来高效地计算多种稀疏载荷模式下的响应，而无需显式构造 $K^{-1}$，并且在每个测试用例中对 $K$ 的重构分解不超过一次。假设 $K$ 是时不变的，且与 $f$ 无关。\n\n从基本动量平衡和线性弹性假设出发：离散系统的平衡遵循 $K u = f$，其中 $K$ 源于稳定的线性本构关系和相容的运动学，因此 $K$ 是对称正定的。利用这些原理，从第一性原理出发，设计一种通过利用线性特性来最小化跨多个载荷模式的重复工作的算法。除通用线性代数外，请勿使用任何特定于问题领域的预封装快捷方式。\n\n您的程序必须使用从0开始的自由度索引来解决以下测试套件。必须遵守所有物理单位：刚度项的单位是牛顿/米 ($\\mathrm{N/m}$)，力的单位是牛顿 ($\\mathrm{N}$)，位移的单位是米 ($\\mathrm{m}$)，应变能的单位是焦耳 ($\\mathrm{J}$)。对于每个测试用例，预先计算一个最小的典范影响响应集合，然后，对于每种载荷模式，使用叠加法从这些影响响应中组合出位移向量。对于每种载荷模式，只报告单位为焦耳的总应变能 $U = \\tfrac{1}{2} f^{\\mathsf{T}} u$。将每个应变能以焦耳为单位表示为四舍五入到六位小数的小数。\n\n您的程序在每个测试用例中必须满足的约束：\n- 每个测试用例最多对 $K$ 进行一次矩阵分解。\n- 不显式构造 $K^{-1}$。\n- 通过预先计算与一组指定的可加载自由度相对应的影响响应来使用叠加法。\n- 每个给定的载荷向量仅在指定的可加载自由度上具有非零项。\n\n测试套件。共有 $3$ 个独立的测试用例。对于每个测试用例，都指定了刚度矩阵 $K$、可加载自由度索引集合 $\\mathcal{I}$ 和载荷向量列表 $\\{ f^{(j)} \\}$。索引是从0开始的，向量按坐标顺序列出。\n\n- 测试用例 1：\n  - 尺寸 $n = 4$。\n  - 刚度\n    $$K_1 = 1000 \\cdot\n    \\begin{bmatrix}\n    2 & -1 & 0 & 0 \\\\\n    -1 & 2 & -1 & 0 \\\\\n    0 & -1 & 2 & -1 \\\\\n    0 & 0 & -1 & 2\n    \\end{bmatrix} \\quad [\\mathrm{N/m}].$$\n  - 可加载索引 $\\mathcal{I}_1 = \\{0, 3\\}$。\n  - 载荷向量（单位：牛顿）：\n    $$f_1^{(1)} = \\begin{bmatrix} 100 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\n      f_1^{(2)} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 50 \\end{bmatrix}, \\quad\n      f_1^{(3)} = \\begin{bmatrix} 60 \\\\ 0 \\\\ 0 \\\\ 40 \\end{bmatrix}, \\quad\n      f_1^{(4)} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.$$\n\n- 测试用例 2：\n  - 尺寸 $n = 5$。\n  - 刚度\n    $$K_2 = 1500 \\cdot\n    \\begin{bmatrix}\n    2 & -1 & 0 & 0 & 0 \\\\\n    -1 & 2 & -1 & 0 & 0 \\\\\n    0 & -1 & 2 & -1 & 0 \\\\\n    0 & 0 & -1 & 2 & -1 \\\\\n    0 & 0 & 0 & -1 & 2\n    \\end{bmatrix} \\quad [\\mathrm{N/m}].$$\n  - 可加载索引 $\\mathcal{I}_2 = \\{1, 4\\}$。\n  - 载荷向量（单位：牛顿）：\n    $$f_2^{(1)} = \\begin{bmatrix} 0 \\\\ 120 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\n      f_2^{(2)} = \\begin{bmatrix} 0 \\\\ 80 \\\\ 0 \\\\ 0 \\\\ 40 \\end{bmatrix}, \\quad\n      f_2^{(3)} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 100 \\end{bmatrix}, \\quad\n      f_2^{(4)} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.$$\n\n- 测试用例 3：\n  - 尺寸 $n = 3$。\n  - 刚度\n    $$K_3 = 500 \\cdot\n    \\begin{bmatrix}\n    2 & -1 & 0 \\\\\n    -1 & 2 & -1 \\\\\n    0 & -1 & 2\n    \\end{bmatrix} \\quad [\\mathrm{N/m}].$$\n  - 可加载索引 $\\mathcal{I}_3 = \\{1\\}$。\n  - 载荷向量（单位：牛顿）：\n    $$f_3^{(1)} = \\begin{bmatrix} 0 \\\\ 75 \\\\ 0 \\end{bmatrix}, \\quad\n      f_3^{(2)} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\n      f_3^{(3)} = \\begin{bmatrix} 0 \\\\ 150 \\\\ 0 \\end{bmatrix}.$$\n\n要求输出。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应每个测试用例有一个条目，顺序与上文相同。每个条目必须是一个小数列表，其中每个数字是对应载荷向量（按给定顺序）的应变能 $U = \\tfrac{1}{2} f^{\\mathsf{T}} u$（单位：焦耳），四舍五入到六位小数。例如，总体格式应为\n$$[\\,[U_{1}^{(1)}, U_{1}^{(2)}, \\dots],\\ [U_{2}^{(1)}, U_{2}^{(2)}, \\dots],\\ [U_{3}^{(1)}, U_{3}^{(2)}, \\dots]\\,],$$\n其中所有 $U$ 均以 $\\mathrm{J}$ 为单位，表示为四舍五入到六位小数的小数。", "solution": "在尝试解决方案之前，对问题进行验证。\n\n### 步骤 1: 提取已知条件\n- **控制方程**：离散线性弹性系统由平衡方程 $K u = f$ 控制，其中 $K \\in \\mathbb{R}^{n \\times n}$ 是对称正定刚度矩阵， $u \\in \\mathbb{R}^{n}$ 是节点位移向量， $f \\in \\mathbb{R}^{n}$ 是节点力向量。\n- **叠加原理**：映射 $f \\mapsto u$ 的线性被明确说明。\n- **应变能**：总应变能由公式 $U = \\tfrac{1}{2} f^{\\mathsf{T}} u$ 给出。\n- **方法约束**：\n    1.  每个测试用例最多对 $K$ 进行一次矩阵分解。\n    2.  不显式计算矩阵的逆 $K^{-1}$。\n    3.  通过预先计算对典范载荷的响应来使用叠加法。\n    4.  载荷向量是稀疏的，仅在指定的可加载自由度 (DOF) 上有非零项。\n- **测试用例**：提供了三个测试用例。每个测试用例包括一个刚度矩阵 $K$，一组可加载自由度索引 $\\mathcal{I}$，以及一个载荷向量列表 $\\{ f^{(j)} \\}$。\n    - **测试用例 1**：\n        - $n = 4$\n        - $K_1 = 1000 \\cdot [[2, -1, 0, 0], [-1, 2, -1, 0], [0, -1, 2, -1], [0, 0, -1, 2]]$ $\\mathrm{N/m}$\n        - $\\mathcal{I}_1 = \\{0, 3\\}$\n        - $f_1^{(1)} = [100, 0, 0, 0]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_1^{(2)} = [0, 0, 0, 50]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_1^{(3)} = [60, 0, 0, 40]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_1^{(4)} = [0, 0, 0, 0]^{\\mathsf{T}}$ $\\mathrm{N}$\n    - **测试用例 2**：\n        - $n = 5$\n        - $K_2 = 1500 \\cdot [[2, -1, 0, 0, 0], [-1, 2, -1, 0, 0], [0, -1, 2, -1, 0], [0, 0, -1, 2, -1], [0, 0, 0, -1, 2]]$ $\\mathrm{N/m}$\n        - $\\mathcal{I}_2 = \\{1, 4\\}$\n        - $f_2^{(1)} = [0, 120, 0, 0, 0]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_2^{(2)} = [0, 80, 0, 0, 40]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_2^{(3)} = [0, 0, 0, 0, 100]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_2^{(4)} = [0, 0, 0, 0, 0]^{\\mathsf{T}}$ $\\mathrm{N}$\n    - **测试用例 3**：\n        - $n = 3$\n        - $K_3 = 500 \\cdot [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]$ $\\mathrm{N/m}$\n        - $\\mathcal{I}_3 = \\{1\\}$\n        - $f_3^{(1)} = [0, 75, 0]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_3^{(2)} = [0, 0, 0]^{\\mathsf{T}}$ $\\mathrm{N}$, $f_3^{(3)} = [0, 150, 0]^{\\mathsf{T}}$ $\\mathrm{N}$\n- **输出要求**：对于每个测试用例，以嵌套列表格式报告每个载荷向量的应变能列表，四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题建立在线性弹性和结构力学的基本原理之上，即离散系统的平衡方程 $K u = f$ 和作为线性直接结果的叠加原理。所提供的刚度矩阵是对称的，并且（对于这种结构是众所周知的）是正定的，与稳定的弹性系统一致。应变能的定义 $U = \\tfrac{1}{2} f^{\\mathsf{T}} u$ 对于线性弹性系统是正确的。该问题在科学上是合理的。\n- **良态性**：刚度矩阵 $K$ 被说明为对称正定，这意味着它是可逆的。因此，对于任何给定的力向量 $f$，都存在一个唯一的位移向量 $u = K^{-1}f$。该问题是良态的（或适定的）。\n- **客观性**：该问题使用精确的数学符号和客观的物理量进行描述。没有主观或模糊的陈述。\n- **完整性和一致性**：为每个测试用例提供了所有必要的数据（$K$, $\\mathcal{I}$, $f^{(j)}$）和公式。对求解方法的约束定义清晰且不矛盾。该问题是自包含且一致的。\n- **可行性**：数值和矩阵结构是力学学术问题中的标准形式。没有物理上不可能的条件或量纲不一致的数据。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它具有科学基础，是良态的、客观的和完整的。将根据要求，通过利用叠加原理来构建解决方案。\n\n### 解决方案推导\n静态、离散线性弹性系统的控制方程是\n$$K u = f$$\n其中 $K$ 是刚度矩阵，$u$ 是位移向量，$f$ 是力向量。由于 $K$ 是一个常数矩阵，这代表了从力空间到位移空间的线性变换。形式解为 $u = K^{-1}f$。这种线性导致了叠加原理的产生。\n\n问题指明，对于任何给定的测试用例，所有施加的载荷向量 $f$ 仅在一小组固定的自由度（DOF）上具有非零分量，该自由度集合由索引集 $\\mathcal{I}$ 表示。设第 $k$ 个自由度的典范基向量为 $e_k$，它是一个在索引 $k$ 处为 $1$、其他位置为 $0$ 的向量。任何这样的载荷向量 $f$ 都可以表示为这些基向量（对于 $k \\in \\mathcal{I}$）的线性组合：\n$$f = \\sum_{k \\in \\mathcal{I}} f_k e_k$$\n其中 $f_k$ 是施加在自由度 $k$ 上的力的大小。\n\n根据叠加原理，对组合载荷 $f$ 的位移响应 $u$ 是对每个独立载荷分量的缩放响应之和：\n$$u = K^{-1}f = K^{-1} \\left( \\sum_{k \\in \\mathcal{I}} f_k e_k \\right) = \\sum_{k \\in \\mathcal{I}} f_k (K^{-1} e_k)$$\n\n这种结构提示了一种有效的计算策略。我们可以预先计算一组“影响向量”。一个影响向量，我们记作 $u^{(k)}$，是系统在单个自由度 $k$ 上施加单位载荷时的位移响应。在数学上，$u^{(k)}$ 是线性方程组\n$$K u^{(k)} = e_k$$\n的解。因此，$u^{(k)} = K^{-1}e_k$。请注意，$u^{(k)}$ 只是逆矩阵 $K^{-1}$ 的第 $k$ 列。然而，问题禁止显式计算 $K^{-1}$。取而代之的是，我们可以对每个 $k \\in \\mathcal{I}$ 求解方程组 $K u^{(k)} = e_k$ 以找到所需的影响向量。\n\n一旦预先计算出影响向量集合 $\\{u^{(k)} \\mid k \\in \\mathcal{I}\\}$，对于任何给定的载荷向量 $f^{(j)}$，其位移响应 $u^{(j)}$ 可以通过线性组合快速组装出来：\n$$u^{(j)} = \\sum_{k \\in \\mathcal{I}} f_k^{(j)} u^{(k)}$$\n其中 $f_k^{(j)}$ 是向量 $f^{(j)}$ 的第 $k$ 个分量。\n\n最后，使用其定义计算每个载荷工况的应变能 $U^{(j)}$：\n$$U^{(j)} = \\frac{1}{2} (f^{(j)})^{\\mathsf{T}} u^{(j)}$$\n\n每个测试用例的总体算法如下：\n1.  **预计算**：\n    a.  对刚度矩阵 $K$ 进行一次分解。由于 $K$ 是对称正定的，Cholesky分解 ($K = LL^{\\mathsf{T}}$) 是最高效的选择。这次单次分解遵守了问题约束。\n    b.  对于可加载自由度集合 $\\mathcal{I}$ 中的每个索引 $k$：\n        i.  构造单位载荷向量 $e_k$。\n        ii. 求解线性方程组 $K u^{(k)} = e_k$ 以找到影响向量 $u^{(k)}$。这可以通过使用预先计算的 Cholesky 因子（前向和后向代换）来高效完成，从而避免了重构分解和显式求逆。\n    c.  存储计算出的影响向量 $\\{u^{(k)}\\}_{k \\in \\mathcal{I}}$。\n\n2.  **响应计算**：\n    a.  对于测试用例中提供的每个载荷向量 $f^{(j)}$：\n        i.  将总位移向量 $u^{(j)}$ 初始化为零向量。\n        ii. 通过对每个可加载自由度的贡献求和来组装总位移：$u^{(j)} = \\sum_{k \\in \\mathcal{I}} f_k^{(j)} u^{(k)}$。\n        iii. 计算应变能：$U^{(j)} = \\frac{1}{2} (f^{(j)})^{\\mathsf{T}} u^{(j)}$。\n    b.  收集测试用例中所有载荷向量计算出的能量。\n\n该算法通过在每个测试用例中仅执行一次分解、避免显式矩阵求逆以及利用叠加原理为多个载荷情景高效计算响应，满足了所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cho_factor, cho_solve\n\ndef solve():\n    \"\"\"\n    Solves a series of linear elastic problems using the principle of superposition.\n    For each test case, it pre-computes influence vectors for a set of loadable\n    degrees of freedom and then assembles the response for various load patterns.\n    The final output is the strain energy for each load pattern.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"K\": 1000.0 * np.array([\n                [2, -1, 0, 0],\n                [-1, 2, -1, 0],\n                [0, -1, 2, -1],\n                [0, 0, -1, 2]\n            ]),\n            \"loadable_indices\": [0, 3],\n            \"load_vectors\": [\n                np.array([100.0, 0, 0, 0]),\n                np.array([0, 0, 0, 50.0]),\n                np.array([60.0, 0, 0, 40.0]),\n                np.array([0, 0, 0, 0])\n            ]\n        },\n        {\n            \"K\": 1500.0 * np.array([\n                [2, -1, 0, 0, 0],\n                [-1, 2, -1, 0, 0],\n                [0, -1, 2, -1, 0],\n                [0, 0, -1, 2, -1],\n                [0, 0, 0, -1, 2]\n            ]),\n            \"loadable_indices\": [1, 4],\n            \"load_vectors\": [\n                np.array([0, 120.0, 0, 0, 0]),\n                np.array([0, 80.0, 0, 0, 40.0]),\n                np.array([0, 0, 0, 0, 100.0]),\n                np.array([0, 0, 0, 0, 0])\n            ]\n        },\n        {\n            \"K\": 500.0 * np.array([\n                [2, -1, 0],\n                [-1, 2, -1],\n                [0, -1, 2]\n            ]),\n            \"loadable_indices\": [1],\n            \"load_vectors\": [\n                np.array([0, 75.0, 0]),\n                np.array([0, 0, 0]),\n                np.array([0, 150.0, 0])\n            ]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        K = case[\"K\"]\n        loadable_indices = case[\"loadable_indices\"]\n        load_vectors = case[\"load_vectors\"]\n        n = K.shape[0]\n        \n        # Precomputation Step\n        # 1. Factorize the stiffness matrix K = L L^T once.\n        # Since K is symmetric positive-definite, Cholesky factorization is used.\n        try:\n            c, low = cho_factor(K, lower=True)\n        except np.linalg.LinAlgError:\n            # This should not happen for the given valid matrices.\n            # Handle error gracefully if it occurs in a general case.\n            all_results.append([])\n            continue\n\n        # 2. Compute and store influence vectors for each loadable DOF.\n        # An influence vector u_k is the response to a unit load e_k at DOF k.\n        influence_vectors = {}\n        for k in loadable_indices:\n            # Create the unit load vector e_k.\n            e_k = np.zeros(n)\n            e_k[k] = 1.0\n            \n            # Solve K u_k = e_k using the precomputed Cholesky factorization.\n            u_k = cho_solve((c, low), e_k)\n            influence_vectors[k] = u_k\n\n        # Response Calculation Step\n        case_energies = []\n        for f in load_vectors:\n            # Assemble the total displacement u using superposition.\n            u = np.zeros(n)\n            for k in loadable_indices:\n                force_component = f[k]\n                if force_component != 0.0:\n                    u += force_component * influence_vectors[k]\n            \n            # Calculate strain energy U = 0.5 * f^T * u.\n            energy = 0.5 * np.dot(f, u)\n            \n            # Round to six decimal places as required.\n            case_energies.append(round(energy, 6))\n            \n        all_results.append(case_energies)\n\n    # Format the final output string exactly as specified.\n    # The str() of a list of lists is close, we just remove spaces.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2699158"}]}