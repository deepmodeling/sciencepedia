{"hands_on_practices": [{"introduction": "掌握卷积的第一步是将其可视化。本练习将引导你通过“翻转与滑动”的图形化方法，手动计算两个离散时间序列的卷积 [@problem_id:2862227]。这个基本实践旨在通过将抽象的卷积和公式 $y[n] = \\sum_{k} x[k] h[n-k]$ 转化为具体的操作步骤，来建立你对线性时不变（LTI）系统响应的直观理解。通过这种方式，你将深刻体会到系统的输出是如何由输入信号与系统脉冲响应的相互作用逐点生成的。", "problem": "考虑一个离散时间线性时不变（LTI）系统，其输入为有限长度序列 $x[n]$，冲激响应为有限长度序列 $h[n]$。唯一允许使用的基本事实是：(i) 任何离散时间信号 $x[n]$ 都可以表示为移位单位冲激的叠加，$x[n]=\\sum_{k \\in \\mathbb{Z}} x[k]\\,\\delta[n-k]$，其中 $\\delta[n]$ 是克罗内克（Kronecker）$\\delta$ 函数；(ii) 时不变性意味着对 $\\delta[n-k]$ 的响应是 $h[n-k]$。由此，可以推断出如何计算一个 LTI 系统的输出 $y[n]$。请仅使用此逻辑链及其引出的“翻转和平移”图形解释法，对由以下方式定义的特定有限序列 $x[n]$ 和 $h[n]$ 求值 $y[n]$：\n$x[n]=1$（对于 $n \\in \\{0,1,2\\}$）且其他情况下 $x[n]=0$，但中间的采样点被缩放以使 $x[1]=2$；以及\n$h[n]=1$（对于 $n \\in \\{0,1\\}$）且其他情况下 $h[n]=0$。\n也就是说，$x[n]$ 在索引 $n \\in \\{0,1,2\\}$ 处的采样值为 $\\{1,2,1\\}$，$h[n]$ 在索引 $n \\in \\{0,1\\}$ 处的采样值为 $\\{1,1\\}$。请通过明确地构建翻转后的核 $h[-k]$ 并将其在 $x[k]$ 上滑动，在每个移位 $n$ 处将 $y[n]$ 作为内积来计算，从而完成求值。在每一步中，需明确指出决定哪些项有贡献的支撑集约束。请将 $y[n]$ 的非零采样值按 $n$ 递增的顺序，以对应连续整数 $n$ 的值的单个行向量形式报告。在推导过程中，不得使用变换域的快捷方法或预先记忆的卷积长度公式；必须仅依赖于上述基本定义以及由它们引出的图形化“翻转和平移”求值法。最终答案必须是仅包含采样值的行向量，不带索引或单位。", "solution": "在尝试求解之前，需对问题陈述进行有效性验证。\n\n### 步骤 1：提取已知条件\n-   **系统类型**：离散时间线性时不变（LTI）系统。\n-   **输入信号**：$x[n]$ 是一个有限长度序列，定义为 $x[n]=1$（对于 $n \\in \\{0, 1, 2\\}$）且其他情况下 $x[n]=0$，并经过修改使 $x[1]=2$。这指定了在 $n \\in \\{0, 1, 2\\}$ 上的序列采样值为 $\\{1, 2, 1\\}$。\n-   **冲激响应**：$h[n]$ 是一个有限长度序列，定义为 $h[n]=1$（对于 $n \\in \\{0, 1\\}$）且其他情况下 $h[n]=0$。这指定了在 $n \\in \\{0, 1\\}$ 上的序列采样值为 $\\{1, 1\\}$。\n-   **基本原理**：\n    1.  任何离散时间信号 $x[n]$ 都可以表示为移位单位冲激的叠加：$x[n]=\\sum_{k \\in \\mathbb{Z}} x[k]\\,\\delta[n-k]$，其中 $\\delta[n]$ 是克罗内克（Kronecker）$\\delta$ 函数。\n    2.  对于 LTI 系统，对移位冲激 $\\delta[n-k]$ 的响应是移位的冲激响应 $h[n-k]$。\n-   **要求方法**：必须使用从基本原理推导出的“翻转和平移”图形解释法来计算输出 $y[n]$。这涉及明确地构建翻转后的核 $h[-k]$ 并将其在 $x[k]$ 上滑动，在每个移位 $n$ 处将 $y[n]$ 作为内积进行计算。\n-   **约束条件**：不得使用变换域方法或预先记忆的公式（例如，用于计算卷积序列长度的公式）。推导过程必须完全依赖于所提供的原理。\n-   **输出格式**：将 $y[n]$ 的非零采样值报告为单个行向量。\n\n### 步骤 2：使用提取的已知条件进行验证\n基于以下标准，该问题被认定为有效：\n-   **科学基础**：该问题是线性系统理论中的一个标准练习，基于离散卷积的基本定义。所提供的所有原理都是正确的，并且是信号处理领域的核心内容。\n-   **适定性**：输入信号 $x[n]$ 和冲激响应 $h[n]$ 的定义明确无误。任务是计算它们的卷积，这是一个定义明确的数学运算，对于给定的有限长度序列有唯一的结果。\n-   **客观性**：问题使用精确的数学语言陈述，没有主观性或模糊性。\n-   **完整性**：提供了解决问题所需的所有必要信息。\n-   **一致性**：问题陈述中没有矛盾之处。对求解方法的约束虽然严格，但与巩固第一性原理的教学目标相一致。\n\n### 步骤 3：结论与行动\n问题有效。现在开始推导解法。\n\n对于一个输入为 $x[n]$、冲激响应为 $h[n]$ 的 LTI 系统，其输出 $y[n]$ 可通过应用线性与时不变性原理来确定。首先，如给定条件，输入信号可被分解为一系列经过缩放和移位的单位冲激之和：\n$$x[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\delta[n-k]$$\n设系统由算子 $L\\{\\cdot\\}$ 表示。输出为 $y[n] = L\\{x[n]\\}$。根据线性性质，算子可以分配到求和运算及常数系数 $x[k]$ 上：\n$$y[n] = L\\left\\{\\sum_{k=-\\infty}^{\\infty} x[k] \\delta[n-k]\\right\\} = \\sum_{k=-\\infty}^{\\infty} x[k] L\\{\\delta[n-k]\\}$$\n系统对单位冲激 $\\delta[n]$ 的响应是冲激响应 $h[n] = L\\{\\delta[n]\\}$。根据时不变性，对时间移位的冲激 $\\delta[n-k]$ 的响应是相应时间移位的冲激响应，即 $h[n-k] = L\\{\\delta[n-k]\\}$。将此代入 $y[n]$ 的表达式，得到离散卷积和：\n$$y[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]$$\n该公式规定了计算每个时间索引 $n$ 处输出采样值的方法。它是输入信号 $x[k]$ 与时间翻转并移位的冲激响应 $h[n-k]$ 在索引 $k$ 上的内积。这就是“翻转和平移”求值法的基础。\n\n给定的具体信号为：\n-   输入信号 $x[k]$ 的非零值为 $x[0]=1$、$x[1]=2$ 和 $x[2]=1$。$x[k]$ 的支撑集是索引集合 $\\{0, 1, 2\\}$。\n-   冲激响应 $h[k]$ 的非零值为 $h[0]=1$ 和 $h[1]=1$。$h[k]$ 的支撑集是索引集合 $\\{0, 1\\}$。\n\n我们通过以下步骤对每个整数值 $n$ 计算 $y[n]$：\n1.  **翻转**：将冲激响应 $h[k]$ 进行时间翻转得到 $h[-k]$。采样值 $h[0]=1$ 仍在索引 $k=0$ 处，采样值 $h[1]=1$ 移动到索引 $k=-1$ 处。因此，$h[-k]$ 在 $k \\in \\{-1, 0\\}$ 处有非零值。\n2.  **平移**：将翻转后的序列 $h[-k]$ 移位 $n$ 得到 $h[n-k]$。$h[m]$ 的非零值是在 $m=0,1$ 时。因此对于 $h[n-k]$，其非零值应在 $n-k=0$ 和 $n-k=1$ 时，这意味着 $k=n$ 和 $k=n-1$。$h[n-k]$ 作为 $k$ 的函数的支撑集是集合 $\\{n-1, n\\}$。\n3.  **相乘求和**：对于每个 $n$，形成乘积 $x[k]h[n-k]$ 并对所有 $k$ 求和。只有当 $x[k]$ 和 $h[n-k]$ 的支撑集有非空交集时，求和结果才非零。$x[k]$ 的支撑集是 $\\{0, 1, 2\\}$，$h[n-k]$ 的支撑集是 $\\{n-1, n\\}$。仅当 $n$ 的取值使得 $\\{0, 1, 2\\} \\cap \\{n-1, n\\} \\neq \\emptyset$ 时，才存在重叠。此条件在 $n$ 从 $0$ 到 $3$ 的范围内成立。对于所有其他 $n$，输出 $y[n]$ 为零。我们现在计算非零值。\n\n-   **当 $n=0$ 时**：\n    $h[0-k] = h[-k]$ 的支撑集是 $\\{-1, 0\\}$。与 $x[k]$ 的支撑集的交集是 $\\{0\\}$。\n    $$y[0] = \\sum_{k=-\\infty}^{\\infty} x[k] h[-k] = \\dots + x[-1]h[1] + x[0]h[0] + x[1]h[-1] + \\dots$$\n    求和中唯一的非零项是 $k=0$ 的情况。\n    $$y[0] = x[0]h[0] = (1)(1) = 1$$\n\n-   **当 $n=1$ 时**：\n    $h[1-k]$ 的支撑集是 $\\{0, 1\\}$。与 $x[k]$ 的支撑集的交集是 $\\{0, 1\\}$。\n    $$y[1] = \\sum_{k=-\\infty}^{\\infty} x[k] h[1-k] = x[0]h[1] + x[1]h[0]$$\n    $$y[1] = (1)(1) + (2)(1) = 1 + 2 = 3$$\n\n-   **当 $n=2$ 时**：\n    $h[2-k]$ 的支撑集是 $\\{1, 2\\}$。与 $x[k]$ 的支撑集的交集是 $\\{1, 2\\}$。\n    $$y[2] = \\sum_{k=-\\infty}^{\\infty} x[k] h[2-k] = x[1]h[1] + x[2]h[0]$$\n    $$y[2] = (2)(1) + (1)(1) = 2 + 1 = 3$$\n\n-   **当 $n=3$ 时**：\n    $h[3-k]$ 的支撑集是 $\\{2, 3\\}$。与 $x[k]$ 的支撑集的交集是 $\\{2\\}$。\n    $$y[3] = \\sum_{k=-\\infty}^{\\infty} x[k] h[3-k] = x[2]h[1]$$\n    $$y[3] = (1)(1) = 1$$\n\n-   **当 $n \\ge 4$ 时**：\n    $h[n-k]$ 的支撑集是 $\\{n-1, n\\}$。由于 $n \\ge 4$，则 $n-1 \\ge 3$。与 $x[k]$ 的支撑集 $\\{0, 1, 2\\}$ 的交集为空。因此，对于所有 $n \\ge 4$，$y[n]=0$。\n\n-   **当 $n < 0$ 时**：\n    $h[n-k]$ 的支撑集是 $\\{n-1, n\\}$。由于 $n < 0$， $n-1$ 和 $n$ 都小于 $0$。与 $x[k]$ 的支撑集的交集为空。因此，对于所有 $n < 0$，$y[n]=0$。\n\n最终得到的输出序列 $y[n]$ 在 $n \\in \\{0, 1, 2, 3\\}$ 上有非零采样值。采样值序列为 $y[0]=1$、$y[1]=3$、$y[2]=3$ 和 $y[3]=1$。所要求的输出是这些值的行向量。", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 3 & 3 & 1 \\end{pmatrix}}$$", "id": "2862227"}, {"introduction": "将离散域的直观理解扩展到连续域是掌握卷积的关键一步。本练习要求你处理连续时间信号，首先使用图形化的“翻转与滑动”方法来确定积分的边界，从而分段求解卷积积分 [@problem_id:2862220]。随后，你将通过分部积分法等解析技巧来验证你的图形化结果，这种结合不仅能加深你对卷积积分物理意义的理解，还能提升你处理连续 LTI 系统的分析能力。", "problem": "一个连续时间线性时不变 (LTI) 系统的冲激响应由矩形脉冲 $h(t) = u(t) - u(t-1)$ 给出，其中 $u(t)$ 是单位阶跃函数。输入为斜坡函数 $x(t) = t\\,u(t)$。令 $(x*h)(t)$ 表示 $x(t)$ 和 $h(t)$ 的卷积。\n\n仅从连续时间 LTI 系统的卷积定义和单位阶跃函数的定义出发，完成以下任务：\n\n1) 基于 $h(t-\\tau)$ 的支撑集与 $x(\\tau)$ 的重叠情况，使用图形化的翻转平移法，通过在乘积 $x(\\tau)\\,h(t-\\tau)$ 不为零的范围内直接计算积分，来确定所有实数 $t$ 对应的 $(x*h)(t)$。你的推理过程应明确指出导致卷积表达式形式不同的各个 $t$ 的区间。\n\n2) 从相同的卷积定义出发，采用对 $\\tau$ 的分部积分法，并利用 $h(\\cdot)$ 对其自变量的反导数，重新解析推导 $(x*h)(t)$。请谨慎处理单位阶跃函数及其分布导数，并对边界项进行合理解释。\n\n3) 将你的最终结果表示为一个关于 $t$ 和 $u(\\cdot)$ 的、对所有实数 $t$ 都有效的单一闭式解析表达式。不要使用任何预先制表的卷积对。无需进行数值取整。最终答案必须写成单一的解析表达式。", "solution": "该问题陈述经核实具有科学依据、是良定的且客观的。它提出了一个线性系统理论中的标准任务，没有矛盾或歧义。因此，我们可以开始求解。\n\n输入信号 $x(t)$ 与系统冲激响应 $h(t)$ 的卷积定义为：\n$$ y(t) = (x*h)(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau $$\n给定的函数是输入信号 $x(t) = t\\,u(t)$ 和冲激响应 $h(t) = u(t) - u(t-1)$。此处，$u(t)$ 是单位阶跃函数，定义为当 $t \\ge 0$ 时 $u(t) = 1$，当 $t < 0$ 时 $u(t) = 0$。\n\n函数 $x(\\tau) = \\tau u(\\tau)$ 是一个从 $\\tau=0$ 开始的斜坡函数。当 $\\tau < 0$ 时它为零，当 $\\tau \\ge 0$ 时它等于 $\\tau$。\n函数 $h(\\tau) = u(\\tau) - u(\\tau-1)$ 是一个在区间 $[0, 1)$ 上幅度为单位1的矩形脉冲。\n\n我们将按要求分三部分解决该问题。\n\n**1) 图形化的翻转平移法求值**\n\n为了计算卷积积分，我们首先求出函数 $h(t-\\tau)$。它是将 $h(\\tau)$ 时间反转得到 $h(-\\tau)$（一个在区间 $(-1, 0]$ 上的矩形脉冲），然后再将其平移 $t$ 得到的。因此，$h(t-\\tau)$ 是一个在区间 $(t-1, t]$ 上幅度为单位1的矩形脉冲。只有在 $x(\\tau)$ 的支撑集（即 $\\tau \\ge 0$）和 $h(t-\\tau)$ 的支撑集（即 $t-1 < \\tau \\le t$）重叠的地方，积分才不为零。我们针对平移参数 $t$ 的不同范围来分析乘积 $x(\\tau)h(t-\\tau)$。\n\n情况 1：$t < 0$\n区间 $(t-1, t]$ 完全位于 $\\tau$ 轴的负半轴。由于对于所有 $\\tau < 0$ 都有 $x(\\tau) = 0$，所以乘积 $x(\\tau)h(t-\\tau)$ 对所有 $\\tau$ 都为零。\n$$ y(t) = \\int_{-\\infty}^{\\infty} 0 \\, d\\tau = 0 $$\n\n情况 2：$0 \\le t < 1$\n区间 $(t-1, t]$ 与 $x(\\tau)$ 的非零区域部分重叠。下限 $t-1$ 为负数或零，而上限 $t$ 在 $[0, 1)$ 内。重叠发生在 $\\tau \\in [0, t]$。在这个区间内，$x(\\tau) = \\tau$ 且 $h(t-\\tau) = 1$。\n$$ y(t) = \\int_{0}^{t} \\tau \\cdot 1 \\, d\\tau = \\left[ \\frac{1}{2}\\tau^{2} \\right]_{0}^{t} = \\frac{1}{2}t^{2} $$\n\n情况 3：$t \\ge 1$\n此时区间 $(t-1, t]$ 完全位于 $\\tau$ 轴的非负半轴，因为 $t-1 \\ge 0$。重叠发生在脉冲的整个宽度上，即 $\\tau \\in [t-1, t]$。在这个区间上，$x(\\tau) = \\tau$ 且 $h(t-\\tau)=1$。\n$$ y(t) = \\int_{t-1}^{t} \\tau \\cdot 1 \\, d\\tau = \\left[ \\frac{1}{2}\\tau^{2} \\right]_{t-1}^{t} = \\frac{1}{2}\\left( t^{2} - (t-1)^{2} \\right) = \\frac{1}{2}\\left( t^{2} - (t^{2} - 2t + 1) \\right) = \\frac{1}{2}(2t - 1) = t - \\frac{1}{2} $$\n\n综合这些结果，得到卷积的分段表达式：\n$$ y(t) = \\begin{cases} 0 & \\text{当 } t < 0 \\\\ \\frac{1}{2}t^{2} & \\text{当 } 0 \\le t < 1 \\\\ t - \\frac{1}{2} & \\text{当 } t \\ge 1 \\end{cases} $$\n\n**2) 使用分部积分法进行解析推导**\n\n我们现在对卷积积分使用分部积分法来重新推导结果：\n$$ y(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau $$\n令 $U = x(\\tau)$ 和 $dV = h(t-\\tau)d\\tau$。则 $dU = x'(\\tau)d\\tau$ 并且 $V = \\int h(t-\\tau)d\\tau$。\n输入信号的导数是 $x'(t) = \\frac{d}{dt}(t\\,u(t)) = 1 \\cdot u(t) + t \\cdot \\delta(t)$。利用筛选性质，$t\\,\\delta(t) = 0 \\cdot \\delta(t) = 0$，所以 $x'(\\tau) = u(\\tau)$。\n对于积分 $V$，令 $s = t-\\tau$，这意味着 $d\\tau = -ds$。\n$$ V(\\tau) = \\int h(t-\\tau)d\\tau = \\int h(s)(-ds) = - \\int h(s)ds $$\n令 $H(s) = \\int_{-\\infty}^{s} h(\\lambda)d\\lambda$。那么 $V(\\tau) = -H(t-\\tau)$。函数 $H(s)$ 是矩形脉冲 $h(s) = u(s) - u(s-1)$ 的积分：\n$$ H(s) = \\int_{-\\infty}^{s} (u(\\lambda) - u(\\lambda-1))d\\lambda = s\\,u(s) - (s-1)u(s-1) $$\n这个函数 $H(s)$ 是一个三角脉冲：当 $0 \\le s < 1$ 时为 $s$，当 $s \\ge 1$ 时为 $1$，当 $s < 0$ 时为 $0$。\n\n应用分部积分公式 $\\int U dV = [UV] - \\int V dU$：\n$$ y(t) = \\left[ x(\\tau) \\cdot (-H(t-\\tau)) \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} (-H(t-\\tau)) x'(\\tau) d\\tau $$\n$$ y(t) = - \\left[ x(\\tau)H(t-\\tau) \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} H(t-\\tau) u(\\tau) d\\tau $$\n我们必须计算边界项。乘积 $x(\\tau)H(t-\\tau) = (\\tau u(\\tau)) H(t-\\tau)$ 仅在两个函数都非零时才非零。这要求 $\\tau \\ge 0$ 和 $t-\\tau \\ge 0$，即 $0 \\le \\tau \\le t$。在这个有限区间之外，该乘积恒等于零。因此，当 $\\tau \\to \\pm\\infty$ 时，边界项的值为零。\n\n卷积简化为：\n$$ y(t) = \\int_{-\\infty}^{\\infty} H(t-\\tau) u(\\tau) d\\tau = \\int_{0}^{\\infty} H(t-\\tau) d\\tau $$\n这个积分可以通过换元来计算。令 $s = t-\\tau$，所以 $d\\tau = -ds$。当 $\\tau=0$ 时，$s=t$。当 $\\tau \\to \\infty$ 时，$s \\to -\\infty$。\n$$ y(t) = \\int_{t}^{-\\infty} H(s)(-ds) = \\int_{-\\infty}^{t} H(s) ds $$\n所以，输出 $y(t)$ 是三角脉冲 $H(s)$ 从 $-\\infty$ 到 $t$ 的曲线下面积。我们可以通过分段积分 $H(s)$ 来计算它。回顾一下，$H(s)$ 在 $s<0$ 时为 $0$，在 $0 \\le s < 1$ 时为 $s$，在 $s \\ge 1$ 时为 $1$：\n- 如果 $t<0$：$y(t) = \\int_{-\\infty}^{t} 0 \\, ds = 0$。\n- 如果 $0 \\le t < 1$：$y(t) = \\int_{-\\infty}^{0} 0 \\, ds + \\int_{0}^{t} s \\, ds = \\left[ \\frac{1}{2}s^{2} \\right]_{0}^{t} = \\frac{1}{2}t^{2}$。\n- 如果 $t \\ge 1$：$y(t) = \\int_{0}^{1} s \\, ds + \\int_{1}^{t} 1 \\, ds = \\left[ \\frac{1}{2}s^{2} \\right]_{0}^{1} + \\left[ s \\right]_{1}^{t} = \\frac{1}{2} + (t-1) = t - \\frac{1}{2}$。\n这些结果与图形法得到的结果完全相同。\n\n另外，我们可以使用奇异函数来写出 $y(t) = \\int_{-\\infty}^{t} H(s)ds$。\n$$ y(t) = \\int_{-\\infty}^{t} (s\\,u(s) - (s-1)u(s-1)) ds = \\int_{-\\infty}^{t} s\\,u(s)\\,ds - \\int_{-\\infty}^{t} (s-1)u(s-1)\\,ds $$\n认识到斜坡函数 $r(t)=t\\,u(t)$ 的积分是抛物线函数 $p(t)=\\frac{1}{2}t^{2}u(t)$，该表达式变为：\n$$ y(t) = \\frac{1}{2}t^{2}u(t) - \\frac{1}{2}(t-1)^{2}u(t-1) $$\n\n**3) 最终的闭式表达式**\n\n从分部积分法推导出的表达式已经是满足要求的、对所有 $t \\in \\mathbb{R}$ 都有效的单一闭式解析表达式。这个表达式紧凑地表示了之前推导出的分段函数。\n$$ y(t) = \\frac{1}{2}t^{2}u(t) - \\frac{1}{2}(t-1)^{2}u(t-1) $$\n这是最终结果。它由一个从 $t=0$ 开始的抛物线函数和一个从 $t=1$ 开始的、带负号的、时间平移的抛物线函数构成，这正确地生成了所要求的输出波形。", "answer": "$$\n\\boxed{\\frac{1}{2}t^{2}u(t) - \\frac{1}{2}(t-1)^{2}u(t-1)}\n$$", "id": "2862220"}, {"introduction": "这个实践将卷积从一个纯粹的分析工具转变为一个强大的设计工具，要求你将卷积运算表示为矩阵-向量乘积——这是信号处理中一个至关重要的思想转换。通过构建一个最小二乘问题来从输入和期望输出中“反求”系统的脉冲响应，你将学习到如何进行系统辨识或设计 FIR 滤波器 [@problem_id:2862210]。这是一个动手编程练习，旨在连接理论与实践，展示卷积如何在解决实际工程逆问题中发挥核心作用。", "problem": "给定一个具有有限脉冲响应（FIR）的离散时间线性时不变（LTI）系统的基本定义。对于任意长度为 $M$ 的有限脉冲响应 $h[n]$，系统对于输入 $x[n]$ 的输出 $y[n]$ 为卷积和\n$$\ny[n] = (h * x)[n] = \\sum_{k=0}^{M-1} h[k]\\,x[n-k],\n$$\n其中，在其指定的有限支撑集之外的 $x[n]$ 采样点均视为零。目标是设计 $h[n]$，使得系统输出在有限索引集上近似一个给定的期望序列 $d[n]$。形式上，对于给定的观测窗口 $\\mathcal{N} = \\{0,1,\\dots,N-1\\}$，找到一个 FIR 向量 $h \\in \\mathbb{R}^M$，使其最小化\n$$\nJ(h) = \\sum_{n=0}^{N-1} \\left(\\sum_{k=0}^{M-1} h[k]\\,x[n-k] - d[n]\\right)^2.\n$$\n这是一个最小二乘问题，可以解释为有限区间反卷积，其中未知的脉冲响应 $h[n]$ 是根据 $x[n]$ 和 $d[n]$ 推断出来的。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n- 构建由观测窗口 $\\mathcal{N}$ 上的卷积和所隐含的卷积设计矩阵。\n- 计算使 $J(h)$ 最小化的最小二乘解 $h$。\n- 将该方法应用于下面的每个测试用例。\n- 输出结果 $h$ 向量，其元素四舍五入到 $6$ 位小数。\n\n假设和约定：\n- 对于所有求和，在其指定的有限支撑集之外的信号均视为零。\n- 所有索引均为整数。本问题不涉及物理单位。\n- 本问题不涉及角度。\n- 所有计算必须以双精度浮点数进行，结果四舍五入到 $6$ 位小数。\n\n测试套件（三个用例）：\n- 用例 A（超定、无噪声、持续激励输入）：\n  - FIR 长度 $M_A = 3$，窗口长度 $N_A = 10$。\n  - 对于 $n \\in \\{0,\\dots,9\\}$ 的输入序列 $x_A[n]$ 为\n    $$\n    x_A = [\\,2,-1,0,3,-2,1,4,0,-1,2\\,].\n    $$\n  - 真实 FIR $h_A^{\\text{true}}$ 为\n    $$\n    h_A^{\\text{true}} = [\\,0.4,-0.1,0.25\\,].\n    $$\n  - 对于 $n \\in \\{0,\\dots,9\\}$ 的期望序列 $d_A[n]$ 由卷积和生成\n    $$\n    d_A[n] = \\sum_{k=0}^{2} h_A^{\\text{true}}[k]\\,x_A[n-k],\n    $$\n    并约定对于任何在 $\\{0,\\dots,9\\}$ 之外的索引 $m$，$x_A[m]=0$。\n\n- 用例 B（欠定、期望输出为零）：\n  - FIR 长度 $M_B = 3$，窗口长度 $N_B = 2$。\n  - 对于 $n \\in \\{0,1\\}$ 的输入序列 $x_B[n]$ 为\n    $$\n    x_B = [\\,1,-1\\,].\n    $$\n  - 对于 $n \\in \\{0,1\\}$ 的期望序列 $d_B[n]$ 为\n    $$\n    d_B = [\\,0,0\\,].\n    $$\n\n- 用例 C（通过克罗内克δ输入实现单位反卷积）：\n  - FIR 长度 $M_C = 4$，窗口长度 $N_C = 6$。\n  - 对于 $n \\in \\{0,\\dots,5\\}$ 的输入序列 $x_C[n]$ 为\n    $$\n    x_C = [\\,1,0,0,0,0,0\\,].\n    $$\n  - 对于 $n \\in \\{0,\\dots,5\\}$ 的期望序列 $d_C[n]$ 为\n    $$\n    d_C = [\\,0.2,0.8,-0.5,1.0,0.0,0.3\\,].\n    $$\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 这个外层列表中的每个元素对应一个测试用例，并且其本身必须是一个估计的 FIR 系数列表 $[\\,h[0],h[1],\\dots,h[M-1]\\,]$，其中每个系数都四舍五入到 $6$ 位小数。\n- 因此，最终格式看起来像一个列表的列表，例如，一个包含 $3$ 个内层列表的外层列表，对应 $3$ 个测试用例。\n\n解释要求：\n- 计算出解后，从概念上将其解释为有限区间反卷积：最小二乘估计恢复了脉冲响应，当该脉冲响应与给定输入进行卷积时，能够在指定窗口上最精确地再现期望序列。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个内层列表包含按 A、B、C 顺序排列的某个测试用例的四舍五入后的系数。", "solution": "所给出的问题是有效的。这是一个数字信号处理和系统辨识中的标准、适定问题，具体来说是使用最小二乘准则设计有限脉冲响应（FIR）滤波器。\n\n目标是找到FIR滤波器系数，用向量 $\\mathbf{h} \\in \\mathbb{R}^M$ 表示，使得在有限观测窗口内，滤波器输出与期望序列 $\\mathbf{d}$ 之间的平方误差之和最小化。代价函数表示为：\n$$\nJ(\\mathbf{h}) = \\sum_{n=0}^{N-1} \\left( y[n] - d[n] \\right)^2 = \\sum_{n=0}^{N-1} \\left(\\sum_{k=0}^{M-1} h[k]\\,x[n-k] - d[n]\\right)^2\n$$\n此处，$x[n]$ 是输入信号，$d[n]$ 是期望输出信号，$M$ 是 FIR 滤波器 $h[n]$的长度，$N$ 是观测数量。我们需要求解 $\\mathbf{h} = [h[0], h[1], \\dots, h[M-1]]^T$。\n\n这是一个经典的线性最小二乘问题。为了解决它，我们必须首先将输出 $y[n]$ 和未知系数 $h[k]$ 之间的关系表示成矩阵向量形式。对于观测窗口 $\\mathcal{N} = \\{0, 1, \\dots, N-1\\}$ 中的每个时间索引 $n$，输出 $y[n]$ 是滤波器系数 $h[k]$ 的线性组合：\n$$\ny[n] = x[n]h[0] + x[n-1]h[1] + \\dots + x[n-(M-1)]h[M-1]\n$$\n我们可以将所有 $n \\in \\mathcal{N}$ 的这种情况写成一个单一的矩阵方程 $\\mathbf{y} = \\mathbf{Xh}$，其中 $\\mathbf{y} \\in \\mathbb{R}^N$ 是输出向量，$\\mathbf{h} \\in \\mathbb{R}^M$ 是滤波器系数向量，而 $\\mathbf{X}$ 是一个 $N \\times M$ 的矩阵，称为卷积矩阵。$\\mathbf{X}$ 的元素由 $X_{n,k} = x[n-k]$ 给出，其中 $n \\in \\{0, \\dots, N-1\\}$ 且 $k \\in \\{0, \\dots, M-1\\}$。约定是，在其指定支撑集之外的任何索引 $m$，$x[m]=0$。\n\n代价函数随后可以用向量符号表示为残差向量的欧几里得范数的平方：\n$$\nJ(\\mathbf{h}) = \\|\\mathbf{Xh} - \\mathbf{d}\\|_2^2\n$$\n其中 $\\mathbf{d} = [d[0], d[1], \\dots, d[N-1]]^T$ 是期望输出采样点的向量。使该表达式最小化的向量 $\\mathbf{h}$ 就是最小二乘解。虽然这个解可以形式化地用 $\\mathbf{X}$ 的伪逆写为 $\\mathbf{h} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{d}$（假设 $\\mathbf{X}^T\\mathbf{X}$ 可逆），但使用如 QR 分解或奇异值分解（SVD）等方法来求解此系统在数值上更稳定和通用。这些方法在标准数值库中都有实现，并且能正确处理超定（$N > M$）和欠定（$N < M$）系统。\n\n为每个测试用例求解 $\\mathbf{h}$ 的步骤如下：\n1.  根据给定的参数 $M$、$N$ 和输入信号 $x[n]$，构建 $N \\times M$ 的卷积矩阵 $\\mathbf{X}$。\n2.  构建期望输出向量 $\\mathbf{d} \\in \\mathbb{R}^N$。\n3.  求解线性最小二乘问题 $\\min_{\\mathbf{h}} \\|\\mathbf{Xh} - \\mathbf{d}\\|_2^2$ 以找到最优的滤波器系数向量 $\\mathbf{h}$。\n\n我们现在将此过程应用于 3 个指定的用例。\n\n用例 A：$M_A = 3$，$N_A = 10$。输入 $x_A[n]$ 已给定。期望信号 $d_A[n]$ 是通过将一个已知的滤波器 $h_A^{\\text{true}} = [0.4, -0.1, 0.25]$ 与 $x_A[n]$ 进行卷积生成的。我们构建 $10 \\times 3$ 的卷积矩阵 $\\mathbf{X}_A$ 和期望向量 $\\mathbf{d}_A$。由于 $N_A > M_A$，这是一个超定系统。由于数据是由模型本身生成的且无噪声，并且输入足够丰富（持续激励），最小二乘解预期将高精度地恢复 $h_A^{\\text{true}}$。\n\n用例 B：$M_B = 3$，$N_B = 2$。给定 $x_B[n]$ 和 $d_B[n] = [0, 0]$。我们构建 $2 \\times 3$ 的卷积矩阵 $\\mathbf{X}_B$。由于 $N_B < M_B$，这是一个欠定系统。将存在一个仿射子空间的解能完美满足 $\\mathbf{Xh}=\\mathbf{d}$。标准的最小二乘求解器将返回具有最小欧几里得范数 $\\|\\mathbf{h}\\|_2$ 的唯一解。方程为 $h[0] = 0$ 和 $-h[0] + h[1] = 0$，这意味着 $h[0]=h[1]=0$。系数 $h[2]$ 不影响输出，因此最小范数解将设置 $h[2]=0$。因此，我们预期 $\\mathbf{h}_B = [0, 0, 0]^T$。\n\n用例 C：$M_C = 4$，$N_C = 6$。输入是 $x_C[n] = [1, 0, 0, 0, 0, 0]$，这是一个在 $n=0$ 处的离散时间脉冲（克罗内克δ）。任何滤波器 $h[n]$ 与脉冲 $\\delta[n]$ 的卷积都是滤波器本身：$(h * \\delta)[n] = h[n]$。因此，对于 $n \\in \\{0, 1, 2, 3\\}$，系统输出为 $y[n] = h[n]$，而对于 $n \\ge 4$，$y[n]=0$。$6 \\times 4$ 的卷积矩阵 $\\mathbf{X}_C$ 将是一个 $\\mathbf{I}_{4 \\times 4}$ 单位矩阵叠加在一个 $2 \\times 4$ 零矩阵之上。最小二乘问题变为最小化 $\\sum_{n=0}^{3} (h[n] - d_C[n])^2 + \\sum_{n=4}^{5} (0 - d_C[n])^2$。最优解就是 $h[n] = d_C[n]$，其中 $n \\in \\{0, 1, 2, 3\\}$。来自 $n \\ge 4$ 的误差贡献与 $\\mathbf{h}$ 无关，是最小可实现误差的一部分。我们预期 $\\mathbf{h}_C = [0.2, 0.8, -0.5, 1.0]^T$。\n\n这个从 $x$ 和 $d$ 中寻找 $\\mathbf{h}$ 的过程是系统辨识的一种形式，或者等价地，是反卷积。我们通过计算“反演”与 $x[n]$ 卷积的效果，来恢复在指定的有限区间 $\\mathcal{N}$ 上能够最好地解释期望信号 $d[n]$ 的滤波器 $h[n]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the least-squares FIR filter for three test cases.\n    \"\"\"\n\n    # Define the test cases based on the problem statement.\n    # Note: For Case A, the desired signal 'd' is generated from a true filter.\n    # For Cases B and C, 'd' is given directly.\n    \n    # Case A: Overdetermined, noise-free\n    M_A = 3\n    N_A = 10\n    x_A = np.array([2.0, -1.0, 0.0, 3.0, -2.0, 1.0, 4.0, 0.0, -1.0, 2.0])\n    h_A_true = np.array([0.4, -0.1, 0.25])\n    # Generate the desired signal d_A by convolving h_true with x_A.\n    # The convolution sum y[n] = sum_k h[k]x[n-k] corresponds to np.convolve(h, x).\n    # We take the first N_A samples of the full convolution result.\n    d_A = np.convolve(h_A_true, x_A, mode='full')[:N_A]\n\n    # Case B: Underdetermined, zero desired output\n    M_B = 3\n    N_B = 2\n    x_B = np.array([1.0, -1.0])\n    d_B = np.array([0.0, 0.0])\n\n    # Case C: Identity deconvolution\n    M_C = 4\n    N_C = 6\n    x_C = np.array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    d_C = np.array([0.2, 0.8, -0.5, 1.0, 0.0, 0.3])\n    \n    test_cases = [\n        {'M': M_A, 'N': N_A, 'x': x_A, 'd': d_A},\n        {'M': M_B, 'N': N_B, 'x': x_B, 'd': d_B},\n        {'M': M_C, 'N': N_C, 'x': x_C, 'd': d_C},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        M = case['M']\n        N = case['N']\n        x = case['x']\n        d = case['d']\n\n        # Construct the N x M convolution matrix X.\n        # The entry at (n, k) is x[n-k], where x is zero outside its support.\n        X = np.zeros((N, M))\n        for n in range(N):\n            for k in range(M):\n                idx = n - k\n                if 0 <= idx < len(x):\n                    X[n, k] = x[idx]\n        \n        # Solve the linear least-squares problem: min ||Xh - d||^2.\n        # np.linalg.lstsq returns a tuple; the solution vector h is the first element.\n        h_solution = np.linalg.lstsq(X, d, rcond=None)[0]\n        \n        # Round the resulting filter coefficients to 6 decimal places.\n        h_rounded = np.round(h_solution, 6)\n        \n        # Append the list of coefficients to the overall results.\n        results.append(h_rounded.tolist())\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., \"[[c1_h0, c1_h1], [c2_h0, c2_h1]]\"\n    output_str = str(results).replace(\" \", \"\")\n    \n    print(output_str)\n\nsolve()\n```", "id": "2862210"}]}