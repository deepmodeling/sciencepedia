{"hands_on_practices": [{"introduction": "本练习提供了一个应用几何原理的具体实践。我们将从推导单位圆上零点的一个关键恒等式出发，然后利用它来计算陷波滤波器的一个关键设计参数——半峰全宽（Full Width at Half Maximum, FWHM）。这个练习将 $z$ 平面中的几何距离与可量化的滤波器性能指标直接联系起来。[@problem_id:2874556]", "problem": "考虑一个离散时间线性时不变系统，其有理传递函数通过离散时间傅里叶变换 (DTFT) 在复平面单位圆上求值。几何求值原理指出，在角频率 $\\omega$ 处的频率响应幅值，由复平面中点 $e^{j\\omega}$ 到该传递函数的零点和极点的欧几里得距离乘积之比给出。\n\n1) 从该几何原理和三角学中的和角公式出发。对于一个在单位圆上 $z_{0}=e^{j\\omega_{0}}$ 处有单个零点的系统，利用复平面的几何关系推导以下恒等式：\n$$\n\\left|e^{j\\omega}-e^{j\\omega_{0}}\\right| \\;=\\; 2\\left|\\sin\\!\\left(\\frac{\\omega-\\omega_{0}}{2}\\right)\\right|.\n$$\n简要解释此恒等式，说明单位圆零点如何在 $\\omega=\\omega_{0}$ 处的频率响应幅值中产生一个陷波。\n\n2) 现在将零点沿径向移动至 $z_{0}=r\\,e^{j\\omega_{0}}$，其中 $0<r\\leq 1$，并考虑以下单零点传递函数：\n$$\nH(z)\\;=\\;K\\,\\bigl(1 - z_{0}\\,z^{-1}\\bigr),\n$$\n其中实数增益 $K>0$ 的选择是为了归一化远离陷波点的幅值，使得\n$$\n\\bigl|H\\!\\left(e^{j(\\omega_{0}+\\pi)}\\right)\\bigr| \\;=\\; 1.\n$$\n使用相同的几何距离解释，将 $\\bigl|H(e^{j\\omega})\\bigr|$ 表示为频率偏移 $\\Delta\\!\\omega=\\omega-\\omega_{0}$ 和半径 $r$ 的函数，并以此定义和计算陷波的半高全宽 (FWHM)。这里的 FWHM 定义为，当 $\\bigl|H(e^{j\\omega})\\bigr|$ 等于相对于远离陷波点的归一化幅值的半功率电平 $2^{-1/2}$ 时，围绕 $\\omega_{0}$ 对称的两个频率之间的总宽度（以弧度为单位）。说明存在此类半功率交点时 $r$ 需满足的任何条件，并以 $r$ 的函数形式确定 FWHM 的闭式解。\n\n你的最终答案必须是 FWHM（以弧度为单位）的单个闭式解析表达式，用 $r$ 表示。不需要数值近似，也不应进行四舍五入。", "solution": "如题所述，该问题逻辑一致，其科学基础是数字信号处理的原理，且问题是适定的。所有给定的信息足以得出一个唯一解。因此，我们将进行严格的推导。\n\n首先，我们解决第1部分的恒等式推导。题目要求我们证明，对于单位圆上位于 $z_{0}=e^{j\\omega_{0}}$ 的单个零点，从单位圆上一点 $e^{j\\omega}$ 到此零点的欧几里得距离由 $|e^{j\\omega}-e^{j\\omega_{0}}| = 2|\\sin(\\frac{\\omega-\\omega_{0}}{2})|$ 给出。\n我们从表达式 $|e^{j\\omega}-e^{j\\omega_{0}}|$ 开始。直接的几何方法最为有效。我们提出一个对应于两个角度平均值的复指数项：\n$$\ne^{j\\omega}-e^{j\\omega_{0}} = e^{j\\frac{\\omega+\\omega_{0}}{2}} \\left( e^{j\\frac{\\omega-\\omega_{0}}{2}} - e^{-j\\frac{\\omega-\\omega_{0}}{2}} \\right).\n$$\n使用欧拉公式，我们回顾恒等式 $\\sin(\\theta) = \\frac{e^{j\\theta} - e^{-j\\theta}}{2j}$，这意味着 $e^{j\\theta} - e^{-j\\theta} = 2j\\sin(\\theta)$。将此应用于我们的表达式，得到：\n$$\ne^{j\\omega}-e^{j\\omega_{0}} = e^{j\\frac{\\omega+\\omega_{0}}{2}} \\left( 2j\\sin\\left(\\frac{\\omega-\\omega_{0}}{2}\\right) \\right).\n$$\n现在我们计算两边的模。积的模等于模的积：\n$$\n|e^{j\\omega}-e^{j\\omega_{0}}| = \\left|e^{j\\frac{\\omega+\\omega_{0}}{2}}\\right| \\left|2j\\right| \\left|\\sin\\left(\\frac{\\omega-\\omega_{0}}{2}\\right)\\right|.\n$$\n任何复指数 $e^{j\\phi}$ 的模恒为 $1$，$2j$ 的模为 $|2j| = \\sqrt{0^2 + 2^2} = 2$。因此，我们便得到了所求的恒等式：\n$$\n|e^{j\\omega}-e^{j\\omega_{0}}| = 1 \\cdot 2 \\cdot \\left|\\sin\\left(\\frac{\\omega-\\omega_{0}}{2}\\right)\\right| = 2\\left|\\sin\\left(\\frac{\\omega-\\omega_{0}}{2}\\right)\\right|.\n$$\n对此恒等式的解释是直观的。一个系统的频率响应幅值 $|H(e^{j\\omega})|$ 与点 $e^{j\\omega}$ 到该系统零点的距离成正比。对于位于 $e^{j\\omega_0}$ 的单个零点，其幅值响应与 $2|\\sin(\\frac{\\omega-\\omega_0}{2})|$ 成正比。当频率 $\\omega$ 等于 $\\omega_0$ 时，由于 $\\sin(0) = 0$，此距离为零。这在频率响应中产生了一个完美的零点，或称“陷波”，从而完全衰减掉频率为 $\\omega_0$ 的信号分量。随着 $\\omega$ 远离 $\\omega_0$，幅值增加，这是陷波滤波器的典型特征。\n\n接下来，在第2部分，我们分析传递函数为 $H(z) = K(1 - z_0 z^{-1})$ 的系统，其中零点为 $z_0 = r e^{j\\omega_0}$，$0 < r \\le 1$ 且 $K > 0$。频率响应为 $H(e^{j\\omega}) = K(1 - r e^{j\\omega_0} e^{-j\\omega})$。根据几何原理，频率响应的幅值由增益 $K$ 乘以点 $e^{j\\omega}$ 到零点 $z_0$ 的距离给出。\n$$\n|H(e^{j\\omega})| = K |e^{j\\omega} - z_0| = K |e^{j\\omega} - r e^{j\\omega_0}|.\n$$\n为计算此幅值，我们求其平方：\n$$\n|e^{j\\omega} - r e^{j\\omega_0}|^2 = (e^{j\\omega} - r e^{j\\omega_0})(e^{-j\\omega} - r e^{-j\\omega_0}) = 1 - r e^{j(\\omega-\\omega_0)} - r e^{-j(\\omega-\\omega_0)} + r^2 = 1 + r^2 - 2r \\cos(\\omega - \\omega_0).\n$$\n令 $\\Delta\\omega = \\omega - \\omega_0$，频率响应的幅值平方为 $|H(e^{j\\omega})|^2 = K^2 (1 + r^2 - 2r \\cos(\\Delta\\omega))$。\n增益 $K$ 由归一化条件 $|H(e^{j(\\omega_0+\\pi)})| = 1$ 确定。在此频率下，$\\Delta\\omega = (\\omega_0+\\pi) - \\omega_0 = \\pi$，且 $\\cos(\\pi) = -1$。\n$$\n|H(e^{j(\\omega_0+\\pi)})|^2 = 1^2 = K^2 (1 + r^2 - 2r(-1)) = K^2 (1 + 2r + r^2) = K^2(1+r)^2.\n$$\n取平方根并利用 $K>0, r>0$，我们得到 $1 = K(1+r)$，即 $K = \\frac{1}{1+r}$。\n因此，归一化后的幅值响应为：\n$$\n|H(e^{j\\omega})| = \\frac{\\sqrt{1 + r^2 - 2r \\cos(\\Delta\\omega)}}{1+r}.\n$$\n半高全宽 (FWHM) 是频率位于半功率电平时两点之间的宽度 $2\\Delta\\omega_{1/2}$，该电平是相对于归一化最大值的。参考幅值为 $1$，因此半功率电平为 $1/\\sqrt{2}$。我们令 $|H(e^{j\\omega})| = \\frac{1}{\\sqrt{2}}$，然后求解对应的频率偏移，记为 $\\Delta\\omega_{1/2}$。\n$$\n\\frac{\\sqrt{1 + r^2 - 2r \\cos(\\Delta\\omega_{1/2})}}{1+r} = \\frac{1}{\\sqrt{2}}.\n$$\n两边平方，得到：\n$$\n\\frac{1 + r^2 - 2r \\cos(\\Delta\\omega_{1/2})}{(1+r)^2} = \\frac{1}{2}.\n$$\n我们求解 $\\cos(\\Delta\\omega_{1/2})$：\n$$\n2(1 + r^2 - 2r \\cos(\\Delta\\omega_{1/2})) = (1+r)^2 = 1 + 2r + r^2\n$$\n$$\n2 + 2r^2 - 4r \\cos(\\Delta\\omega_{1/2}) = 1 + 2r + r^2\n$$\n$$\n4r \\cos(\\Delta\\omega_{1/2}) = (2 + 2r^2) - (1 + 2r + r^2) = 1 - 2r + r^2 = (1-r)^2\n$$\n$$\n\\cos(\\Delta\\omega_{1/2}) = \\frac{(1-r)^2}{4r}.\n$$\n要使 $\\Delta\\omega_{1/2}$ 存在实数解，我们必须有 $|\\cos(\\Delta\\omega_{1/2})| \\le 1$。由于 $r > 0$ 且 $(1-r)^2 \\ge 0$，该表达式是非负的。我们只需检查以下条件：\n$$\n\\frac{(1-r)^2}{4r} \\le 1 \\implies (1-r)^2 \\le 4r \\implies 1 - 2r + r^2 \\le 4r \\implies r^2 - 6r + 1 \\le 0.\n$$\n二次方程 $x^2 - 6x + 1 = 0$ 的根是 $x = 3 \\pm 2\\sqrt{2}$。由于该抛物线开口向上，此不等式在两根之间对 $r$ 成立：$3 - 2\\sqrt{2} \\le r \\le 3 + 2\\sqrt{2}$。考虑到题设约束 $0 < r \\le 1$，存在半功率交点的条件是这些区间的交集，即 $3 - 2\\sqrt{2} \\le r \\le 1$。\n\n在此条件下，半宽 $\\Delta\\omega_{1/2}$ 可通过取反余弦求得。根据余弦函数的对称性，存在两个解 $\\pm \\Delta\\omega_{1/2}$，对称地分布在 $\\Delta\\omega=0$ 两侧。\n$$\n\\Delta\\omega_{1/2} = \\arccos\\left(\\frac{(1-r)^2}{4r}\\right).\n$$\n半高全宽 (FWHM) 是总宽度，即这两个解之间的差：$\\Delta\\omega_{1/2} - (-\\Delta\\omega_{1/2}) = 2\\Delta\\omega_{1/2}$。\n因此，FWHM 为：\n$$\n\\text{FWHM} = 2 \\arccos\\left(\\frac{(1-r)^2}{4r}\\right).\n$$\n这是陷波的 FWHM 作为零点径向位置 $r$ 的函数的最终闭式表达式。", "answer": "$$\\boxed{2\\arccos\\left(\\frac{(1-r)^{2}}{4r}\\right)}$$", "id": "2874556"}, {"introduction": "在基础的距离概念之上，本练习挑战我们对谐振系统的直观理解。对于一个具有一对共轭复极点的二阶系统，其频率响应的峰值未必与极点角重合。通过几何方法分析到两个极点的距离如何相互作用，你将能判断峰值频率的偏移方向，从而更深入地理解整个极零图是如何塑造系统行为的。[@problem_id:1722830]", "problem": "一个稳定的、因果的、二阶离散时间线性时不变（LTI）系统由传递函数 $H(z)$ 表征。该系统有一对位于 $p_1 = re^{j\\theta_0}$ 和 $p_2 = re^{-j\\theta_0}$ 的共轭复极点，以及两个位于原点 $z=0$ 的零点。传递函数可以写作：\n$$\nH(z) = \\frac{K z^2}{(z - re^{j\\theta_0})(z - re^{-j\\theta_0})}\n$$\n其中 $K$ 是一个正实数常数。极点半径 $r$ 的约束条件是 $0 < r < 1$，极点角 $\\theta_0$ 的约束条件是 $0 < \\theta_0 < \\frac{\\pi}{2}$。\n\n该系统的频率响应由离散时间傅里叶变换（DTFT）$H(e^{j\\omega})$ 给出，其中 $\\omega$ 是实频率变量。设 $\\omega_{peak}$ 为在 $0 \\le \\omega \\le \\pi$ 范围内使频率响应的幅值 $|H(e^{j\\omega})|$ 达到最大的频率。\n\n根据系统零极点图对 DTFT 的几何评估，确定峰值频率 $\\omega_{peak}$ 和极点角 $\\theta_0$ 之间的关系。\n\nA. $\\omega_{peak} < \\theta_0$\n\nB. $\\omega_{peak} = \\theta_0$\n\nC. $\\omega_{peak} > \\theta_0$\n\nD. 该关系取决于增益 $K$ 的值。\n\nE. 如果没有 $r$ 和 $\\theta_0$ 的具体数值，则无法确定该关系。", "solution": "对于频率响应，将 $z=e^{j\\omega}$ 代入 $H(z)$ 以得到\n$$\nH(e^{j\\omega})=\\frac{K e^{j2\\omega}}{\\left(e^{j\\omega}-r e^{j\\theta_{0}}\\right)\\left(e^{j\\omega}-r e^{-j\\theta_{0}}\\right)}.\n$$\n在单位圆上，由于 $|e^{j2\\omega}|=1$，所以幅值为\n$$\n|H(e^{j\\omega})|=\\frac{K}{\\left|e^{j\\omega}-r e^{j\\theta_{0}}\\right|\\left|e^{j\\omega}-r e^{-j\\theta_{0}}\\right|}.\n$$\n因此，当到两个极点的距离之积最小时， $|H(e^{j\\omega})|$ 达到峰值。定义\n$$\nA(\\omega)=\\left|e^{j\\omega}-r e^{j\\theta_{0}}\\right|^{2}=1+r^{2}-2r\\cos(\\omega-\\theta_{0}),\n$$\n$$\nB(\\omega)=\\left|e^{j\\omega}-r e^{-j\\theta_{0}}\\right|^{2}=1+r^{2}-2r\\cos(\\omega+\\theta_{0}),\n$$\n并设\n$$\nP(\\omega)=A(\\omega)B(\\omega).\n$$\n在 $0\\leq\\omega\\leq\\pi$ 上最大化 $|H(e^{j\\omega})|$ 等价于最小化 $P(\\omega)$。使用 $\\cos(\\omega\\pm\\theta_{0})$ 展开后的乘积形式：\n$$\nA(\\omega)=1+r^{2}-2r\\left(\\cos\\omega\\cos\\theta_{0}+\\sin\\omega\\sin\\theta_{0}\\right),\n$$\n$$\nB(\\omega)=1+r^{2}-2r\\left(\\cos\\omega\\cos\\theta_{0}-\\sin\\omega\\sin\\theta_{0}\\right).\n$$\n那么\n$$\nP(\\omega)=\\left(1+r^{2}-2r\\cos\\omega\\cos\\theta_{0}\\right)^{2}-4r^{2}\\sin^{2}\\omega\\,\\sin^{2}\\theta_{0}.\n$$\n使用 $\\sin^{2}\\omega=1-\\cos^{2}\\omega$ 并化简，\n$$\nP(\\omega)=4r^{2}\\cos^{2}\\omega-4r(1+r^{2})\\cos\\theta_{0}\\cos\\omega+\\left[(1+r^{2})^{2}-4r^{2}\\sin^{2}\\theta_{0}\\right].\n$$\n令 $X=\\cos\\omega\\in[-1,1]$。这是一个关于 $X$ 的凸二次函数：\n$$\nP(X)=4r^{2}X^{2}-4r(1+r^{2})\\cos\\theta_{0}\\,X+\\text{const}.\n$$\n无约束最小值点位于\n$$\nX^{\\ast}=\\frac{(1+r^{2})\\cos\\theta_{0}}{2r}.\n$$\n由于 $0<r<1$，因子 $(1+r^{2})/(2r)=(r+1/r)/2>1$，并且由于 $0<\\theta_{0}<\\pi/2$，我们有 $\\cos\\theta_{0}\\in(0,1)$，因此 $X^{\\ast}>\\cos\\theta_{0}>0$。因此，在 $X\\in[-1,1]$ 上的有约束最小值点为\n$$\n\\cos\\omega_{\\text{peak}}=\\min\\left\\{1,\\; \\frac{(1+r^{2})\\cos\\theta_{0}}{2r}\\right\\}.\n$$\n在任一情况下，\n- 如果 $\\frac{(1+r^{2})\\cos\\theta_{0}}{2r}\\leq 1$，那么 $\\cos\\omega_{\\text{peak}}=\\frac{(1+r^{2})\\cos\\theta_{0}}{2r}>\\cos\\theta_{0}$，因此 $\\omega_{\\text{peak}}<\\theta_{0}$，因为 $\\cos$ 函数在 $[0,\\pi]$ 上是严格递减的，\n- 如果 $\\frac{(1+r^{2})\\cos\\theta_{0}}{2r}>1$，那么 $\\omega_{\\text{peak}}=0<\\theta_{0}$。\n\n因此对于所有的 $0<r<1$ 和 $0<\\theta_{0}<\\pi/2$，\n$$\n\\omega_{\\text{peak}}<\\theta_{0}.\n$$\n此外，正增益 $K$ 仅缩放幅值，不影响使其最大化的频率。所以，正确的关系是 $\\omega_{\\text{peak}}<\\theta_{0}$。", "answer": "$$\\boxed{A}$$", "id": "1722830"}, {"introduction": "最后的这个练习旨在弥合理论分析与实际实现之间的鸿沟。你将设计并编写一个算法，直接应用几何方法从极零点列表计算频率响应。此外，你将探索一个关键的现实世界问题：由相近的极零点对消引起的数值不稳定性，并实现一个更稳定的算法，在计算环境中检验你的理论知识。[@problem_id:2874596]", "problem": "设计并实现一个程序，该程序对于一个具有有理系统函数的离散时间、线性时不变（LTI）单输入单输出系统，在给定其极点和零点列表以及一个标量增益的情况下，使用几何方法在指定的角频率上评估其离散时间频率响应的幅度和相位，并分析在接近极零点对消（pole-zero cancellations）处的数值稳定性。所有角度必须以弧度为单位。\n\n从以下基本原理出发：\n- $Z$变换和离散时间傅里叶变换（DTFT）的定义，其中频率响应是通过在单位圆 $z=e^{j\\omega}$ 上计算系统函数 $H(z)$ 得到的。\n- 经过充分验证的事实，即一个有理系统函数 $H(z)$ 可以被分解为其复增益、零点和极点的乘积形式。\n\n您的任务是：\n- 基于上述原理，推导一种在单位圆上计算频率响应的计算方法，该方法使用形如 $e^{j\\omega}-a$ 的预计算向量，其中 $a$ 是任意零点或极点。清晰地阐述如何从这些向量中几何地获得幅度 $|H(e^{j\\omega})|$ 和相位 $\\angle H(e^{j\\omega})$。\n- 提出两种算法实现：\n  - 一种使用预计算向量 $e^{j\\omega}-a$ 的直接乘积评估方法（朴素几何乘积法）。\n  - 一种数值稳定的评估方法，该方法累加各因子的复对数，并通过在适当时使用 $ \\log(1+x) $ 计算比率来合并相近的零-极点对，此过程同样使用预计算的向量 $e^{j\\omega}-a$。设计必须解决当一个零点和一个极点彼此接近且同时接近单位圆上的评估点时可能出现的有效位数损失问题。\n- 通过在指定的频率网格上比较两种实现的结​​果来量化数值稳定性。对于每个测试用例，计算：\n  - 网格上的最大相对幅度差异，定义为 $\\max_{\\omega} \\frac{\\left||H_{\\text{stab}}(e^{j\\omega})|-|H_{\\text{naive}}(e^{j\\omega})|\\right|}{\\max(|H_{\\text{stab}}(e^{j\\omega})|,\\epsilon)}$，其中 $\\epsilon$ 是一个小的正常数，以避免除以零。\n  - 网格上的最大绝对相位差异，定义为两种方法之间的主值缠绕相位差 $\\Delta\\phi(\\omega)$ 在 $\\omega$ 上的本质上确界，其中相位差被缠绕到区间 $[-\\pi,\\pi]$ 内。\n\n您的程序必须：\n- 预先计算每个频率和每个零点或极点 $a$ 的向量 $e^{j\\omega}-a$，并将其作为基本构建模块。\n- 实现朴素几何乘积法和稳定的对数累加法，后者使用配对容差 $\\tau_{\\text{pair}}$ 并在 $x$ 的幅度很小时通过复数 $\\log(1+x)$ 计算来处理相近抵消。\n- 对于每个测试用例，输出两个浮点数值：\n  - 在整个网格上的最大相对幅度差异。\n  - 在整个网格上的最大绝对缠绕相位差异（以弧度为单位）。\n\n测试套件：\n每个测试用例提供复增益 $K \\in \\mathbb{C}$、零点列表 $\\{z_k\\}$、极点列表 $\\{p_\\ell\\}$ 和角频率网格 $\\{\\omega_m\\}$。\n\n- 测试用例 1（顺利路径，中等阶数，特征点分离良好）：\n  - $K = 1$\n  - 零点：$\\{0.5 e^{j 0.3},\\, 0.5 e^{-j 0.3}\\}$\n  - 极点：$\\{0.8 e^{j 0.5},\\, 0.8 e^{-j 0.5}\\}$\n  - 频率网格：$\\{\\omega_m\\}_{m=0}^{512}$ 其中 $\\omega_m = \\pi \\cdot \\frac{m}{512}$\n- 测试用例 2（在特定角度处发生近对消）：\n  - $K = 1$\n  - 零点：$\\{0.94999999\\, e^{j 0.4},\\, 0.94999999\\, e^{-j 0.4}\\}$\n  - 极点：$\\{0.95\\, e^{j 0.4},\\, 0.95\\, e^{-j 0.4}\\}$\n  - 频率网格：$\\{0,\\, 0.1,\\, 0.3,\\, 0.4 - 10^{-6},\\, 0.4,\\, 0.4 + 10^{-6},\\, 1.0,\\, \\pi\\}$\n- 测试用例 3（具有多个近对消对的高阶系统）：\n  - $K = 1$\n  - 零点：$\\{(0.9999998) e^{j 0.2},\\, (0.9999998) e^{-j 0.2},\\, (0.9999998) e^{j 0.7},\\, (0.9999998) e^{-j 0.7},\\, (0.9999998) e^{j 1.3},\\, (0.9999998) e^{-j 1.3},\\, (0.9999998) e^{j 2.2},\\, (0.9999998) e^{-j 2.2}\\}$\n  - 极点：$\\{(0.9999999) e^{j 0.2},\\, (0.9999999) e^{-j 0.2},\\, (0.9999999) e^{j 0.7},\\, (0.9999999) e^{-j 0.7},\\, (0.9999999) e^{j 1.3},\\, (0.9999999) e^{-j 1.3},\\, (0.9999999) e^{j 2.2},\\, (0.9999999) e^{-j 2.2}\\}$\n  - 频率网格：$\\{\\omega_m\\}_{m=0}^{2048}$ 其中 $\\omega_m = \\pi \\cdot \\frac{m}{2048}$\n\n角度单位要求：\n- 所有角度（包括指数函数内部的角度、相位输出和频率网格）都必须以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、包含6个浮点数的逗号分隔列表，顺序为 $[M_1, P_1, M_2, P_2, M_3, P_3]$，其中 $M_i$ 是测试用例 $i$ 的最大相对幅度差异，$P_i$ 是测试用例 $i$ 的最大绝对缠绕相位差异（以弧度为单位）。", "solution": "问题陈述已经过验证，并被认定为有效。它在科学上基于线性系统理论和数字信号处理的原理，问题定义良好，具有明确的目标和约束，并以客观、正式的语言表述。它解决的是数值计算中的一个实际问题。对于像 $\\epsilon$ 和 $\\tau_{\\text{pair}}$ 这样的数值容差的轻微未明确之处是可以接受的，因为它们的选择是算法实现中的一个标准部分。我将继续进行推导和求解。\n\n我将为实现选择以下常数：\n- 用于识别近对消零-极点对的配对容差：$\\tau_{\\text{pair}} = 10^{-6}$。\n- 用于幅度差异计算的正则化常数：$\\epsilon = 10^{-12}$。\n\n### 1. 几何评估的理论基础\n\n一个具有有理系统函数 $H(z)$ 的离散时间、线性时不变（LTI）系统可以表示为因式分解形式或零-极点-增益形式。假设零点数量 $M$ 和极点数量 $N$ 是有限的，其形式为：\n$$ H(z) = K \\frac{\\prod_{k=1}^{M} (z - z_k)}{\\prod_{\\ell=1}^{N} (z - p_\\ell)} $$\n其中 $\\{z_k\\}$ 是零点，$\\{p_\\ell\\}$ 是极点，$K$ 是系统的复增益。\n\n频率响应 $H(e^{j\\omega})$ 是通过在单位圆上评估系统函数 $H(z)$ 得到的，即代入 $z = e^{j\\omega}$，其中 $\\omega$ 是以弧度为单位的角频率。\n$$ H(e^{j\\omega}) = K \\frac{\\prod_{k=1}^{M} (e^{j\\omega} - z_k)}{\\prod_{\\ell=1}^{N} (e^{j\\omega} - p_\\ell)} $$\n\n乘积中的每一项，如 $(e^{j\\omega} - z_k)$ 或 $(e^{j\\omega} - p_\\ell)$，都是一个复数。在几何上，它表示一个从零点 $z_k$ 或极点 $p_\\ell$ 出发，终止于复平面单位圆上点 $e^{j\\omega}$ 的向量。问题陈述正确地将这些向量确定为计算的基本构建模块。\n\n频率响应的幅度 $|H(e^{j\\omega})|$ 是这些复数项幅度的乘积和商：\n$$ |H(e^{j\\omega})| = |K| \\frac{\\prod_{k=1}^{M} |e^{j\\omega} - z_k|}{\\prod_{\\ell=1}^{N} |e^{j\\omega} - p_\\ell|} $$\n在几何上， $|e^{j\\omega} - a|$ 是从点 $a$（一个零点或极点）到单位圆上点 $e^{j\\omega}$ 的欧几里得距离。因此，幅度响应是从零点到评估点的距离的乘积，除以从极点到评估点的距离的乘积，再按 $|K|$ 进行缩放。\n\n频率响应的相位 $\\angle H(e^{j\\omega})$ 是这些复数项的相位（角度）的和与差：\n$$ \\angle H(e^{j\\omega}) = \\angle K + \\sum_{k=1}^{M} \\angle(e^{j\\omega} - z_k) - \\sum_{\\ell=1}^{N} \\angle(e^{j\\omega} - p_\\ell) $$\n在几何上，$\\angle(e^{j\\omega} - a)$ 是从点 $a$ 到点 $e^{j\\omega}$ 的向量的角度。\n\n### 2. 算法实现\n\n基于上述公式，指定了两种计算方法。\n\n#### 2.1. 朴素几何乘积法\n该算法是频率响应公式的直接实现。对于指定网格中的每个角频率 $\\omega$：\n1.  计算复数值 $z_{\\text{eval}} = e^{j\\omega}$。\n2.  预计算从每个零点 $z_k$ 和每个极点 $p_\\ell$ 出发的向量：$v_{z,k} = z_{\\text{eval}} - z_k$ 和 $v_{p,\\ell} = z_{\\text{eval}} - p_\\ell$。\n3.  将所有零点向量相乘计算分子：$N(\\omega) = \\prod_{k=1}^{M} v_{z,k}$。\n4.  将所有极点向量相乘计算分母：$D(\\omega) = \\prod_{\\ell=1}^{N} v_{p,\\ell}$。\n5.  频率响应为 $H_{\\text{naive}}(e^{j\\omega}) = K \\cdot N(\\omega) / D(\\omega)$。\n\n这种方法简单直接，但容易出现数值病态问题。在高阶系统中，直接乘积可能导致浮点数上溢或下溢。更关键的是，当一个零点 $z_k$ 和一个极点 $p_\\ell$ 几乎重合时（$z_k \\approx p_\\ell$），它们对应的向量贡献 $v_{z,k}$ 和 $v_{p,\\ell}$ 将几乎相等，特别是对于远离该对的评估点 $e^{j\\omega}$。此时，比率 $v_{z,k}/v_{p,\\ell}$ 变成了两个几乎相等的数相除，这可能导致相对精度的严重损失。\n\n#### 2.2. 数值稳定的对数方法\n该方法旨在通过在对数域中操作来减轻朴素方法固有的数值不稳定性。频率响应的对数为：\n$$ \\log H(e^{j\\omega}) = \\log K + \\sum_{k=1}^{M} \\log(e^{j\\omega} - z_k) - \\sum_{\\ell=1}^{N} \\log(e^{j\\omega} - p_\\ell) $$\n这将乘法和除法转换为了加法和减法，有助于避免上溢/下溢。然而，它引入了一个新问题：对几乎相等的数的对数进行减法运算，即 $\\log(A) - \\log(B)$ 其中 $A \\approx B$，同样会遭受灾难性抵消（catastrophic cancellation）的影响。\n\n为了解决这个问题，我们首先识别并配对邻近的零-极点对。采用了一种稳健的贪心策略：\n1.  构建所有未配对零点和极点的列表。\n2.  迭代地在所有剩余未配对元素中找到距离 $|z_k - p_\\ell|$ 最小的零-极点对 $(z_k, p_\\ell)$。\n3.  如果此最小距离小于容差 $\\tau_{\\text{pair}}$，则形成一对 $(z_k, p_\\ell)$，将其添加至配对列表，并从未配对列表中移除这两个元素。\n4.  重复此过程，直到无法再形成满足容差 $\\tau_{\\text{pair}}$ 的配对。\n\n然后，对每个频率 $\\omega$，$\\log H(e^{j\\omega})$ 的计算按以下步骤进行：\n1.  用 $\\log K$ 初始化一个用于存储对数响应的复数累加器。\n2.  对于每个未配对的零点 $z_k$，将 $\\log(e^{j\\omega} - z_k)$ 加到累加器中。\n3.  对于每个未配对的极点 $p_\\ell$，从累加器中减去 $\\log(e^{j\\omega} - p_\\ell)$。\n4.  对于每个配对的零-极点 $(z_k, p_\\ell)$，它们对对数响应的总贡献为 $\\log(e^{j\\omega} - z_k) - \\log(e^{j\\omega} - p_\\ell) = \\log\\left(\\frac{e^{j\\omega} - z_k}{e^{j\\omega} - p_\\ell}\\right)$。为了稳定地计算它，参数可重写为：\n    $$ \\frac{e^{j\\omega} - z_k}{e^{j\\omega} - p_\\ell} = \\frac{(e^{j\\omega} - p_\\ell) + (p_\\ell - z_k)}{e^{j\\omega} - p_\\ell} = 1 + \\frac{p_\\ell - z_k}{e^{j\\omega} - p_\\ell} $$\n    因此，要加到对数累加器上的项是 $\\log\\left(1 + \\frac{p_\\ell - z_k}{e^{j\\omega} - p_\\ell}\\right)$。该计算使用一个专门的 `log1p` 函数来执行，该函数即使在 $|x| \\ll 1$ 的情况下也能精确计算 $\\log(1+x)$。当 $|e^{j\\omega} - p_\\ell| \\gg |p_\\ell - z_k|$ 时，即当评估频率远离近对消对时，就会出现这种情况。\n\n最后，通过取指数来恢复稳定的频率响应：$H_{\\text{stab}}(e^{j\\omega}) = \\exp(\\log H(e^{j\\omega}))$。\n\n### 3. 差异量化\n\n为了量化数值稳定性的改善，使用两个在给定频率网格 $\\{\\omega_m\\}$ 上评估的指标来比较两种算法的结果：\n\n1.  **最大相对幅度差异：**\n    $$ M = \\max_{m} \\frac{\\left||H_{\\text{stab}}(e^{j\\omega_m})|-|H_{\\text{naive}}(e^{j\\omega_m})|\\right|}{\\max(|H_{\\text{stab}}(e^{j\\omega_m})|,\\epsilon)} $$\n    该指标衡量幅度的最大相对误差，通过稳定方法的幅度进行归一化，以提供一个有意义的尺度。小常数 $\\epsilon$ 可以防止除以零。\n\n2.  **最大绝对缠绕相位差异：**\n    计算每个频率下的相位差 $\\Delta\\phi(\\omega_m) = \\angle H_{\\text{stab}}(e^{j\\omega_m}) - \\angle H_{\\text{naive}}(e^{j\\omega_m})$。为了确保对角度进行有意义的比较，必须将此差异缠绕到主区间 $[-\\pi, \\pi]$ 内。缠绕后的相位差由 $\\Delta\\phi_{\\text{wrapped}} = (\\Delta\\phi + \\pi) \\pmod{2\\pi} - \\pi$ 给出。该指标是此缠绕差异在整个网格上的最大绝对值：\n    $$ P = \\max_{m} |\\Delta\\phi_{\\text{wrapped}}(\\omega_m)| $$\n\n这些指标将揭示朴素方法的精度在哪些频率和条件下会下降，从而证明稳定对数方法的有效性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    It defines test cases, computes frequency responses using two methods,\n    and calculates discrepancy metrics.\n    \"\"\"\n\n    def pair_poles_zeros(zeros, poles, tol):\n        \"\"\"\n        Pairs zeros and poles that are closer than a given tolerance.\n        Uses a robust greedy algorithm that repeatedly finds the globally closest\n        pole-zero pair, pairs them, and removes them from consideration.\n        \"\"\"\n        p_unmatched = list(poles)\n        z_unmatched = list(zeros)\n        pairs = []\n\n        while z_unmatched and p_unmatched:\n            # Create a distance matrix for all remaining unpaired elements\n            distances = np.abs(np.array(z_unmatched)[:, np.newaxis] - np.array(p_unmatched))\n            \n            # Find the indices of the minimum distance\n            min_idx = np.unravel_index(np.argmin(distances, axis=None), distances.shape)\n            z_idx, p_idx = min_idx\n            \n            min_dist = distances[z_idx, p_idx]\n            \n            if min_dist < tol:\n                # Pair them and remove from unmatched lists\n                pairs.append((z_unmatched.pop(z_idx), p_unmatched.pop(p_idx)))\n            else:\n                # No more pairs are within the tolerance\n                break\n                \n        return pairs, z_unmatched, p_unmatched\n\n    def naive_method(K, zeros, poles, freqs):\n        \"\"\"\n        Computes the frequency response using a direct product of complex vectors.\n        \"\"\"\n        H = np.zeros_like(freqs, dtype=np.complex128)\n        zeros_arr = np.array(zeros, dtype=np.complex128)\n        poles_arr = np.array(poles, dtype=np.complex128)\n        \n        for i, w in enumerate(freqs):\n            z_eval = np.exp(1j * w)\n            \n            # Precompute vectors from zeros and poles\n            # Add a small epsilon to denominator to avoid division by zero if a pole is on the grid point\n            v_zeros = z_eval - zeros_arr\n            v_poles = z_eval - poles_arr\n            \n            num = np.prod(v_zeros) if len(v_zeros) > 0 else 1.0\n            den = np.prod(v_poles) if len(v_poles) > 0 else 1.0\n\n            if np.abs(den) < 1e-100: # Effectively zero, pole on unit circle\n                H[i] = np.inf + 0j\n            else:\n                H[i] = K * num / den\n        return H\n\n    def stable_method(K, zeros, poles, freqs, tol_pair):\n        \"\"\"\n        Computes the frequency response using a stabilized logarithmic accumulation,\n        handling near-cancelling pole-zero pairs with the log1p function.\n        \"\"\"\n        pairs, unpaired_z, unpaired_p = pair_poles_zeros(zeros, poles, tol_pair)\n        \n        log_H = np.zeros_like(freqs, dtype=np.complex128)\n        log_K = np.log(K) if K != 0 else -np.inf\n\n        unpaired_z_arr = np.array(unpaired_z, dtype=np.complex128)\n        unpaired_p_arr = np.array(unpaired_p, dtype=np.complex128)\n\n        for i, w in enumerate(freqs):\n            z_eval = np.exp(1j * w)\n            log_h_val = log_K\n            \n            # Unpaired zeros\n            if unpaired_z_arr.size > 0:\n                v_uz = z_eval - unpaired_z_arr\n                log_h_val += np.sum(np.log(v_uz))\n\n            # Unpaired poles\n            if unpaired_p_arr.size > 0:\n                v_up = z_eval - unpaired_p_arr\n                if np.any(np.abs(v_up) < 1e-100):\n                    log_H[i] = np.inf\n                    continue\n                log_h_val -= np.sum(np.log(v_up))\n\n            # Paired terms\n            for z, p in pairs:\n                v_p = z_eval - p\n                if np.abs(v_p) < 1e-100:\n                    log_h_val = np.inf\n                    break\n                # Evaluate log(1 + (p-z)/(z_eval-p))\n                x = (p - z) / v_p\n                log_h_val += np.log1p(x)\n\n            if np.isinf(log_h_val):\n                log_H[i] = np.inf\n                continue\n\n            log_H[i] = log_h_val\n            \n        return np.exp(log_H)\n\n    def wrap_phase_diff(diff):\n        \"\"\"Wraps a phase difference to the interval [-pi, pi].\"\"\"\n        return (diff + np.pi) % (2 * np.pi) - np.pi\n\n    # --- Test Suite Definition ---\n    # Common parameters\n    epsilon = 1e-12\n    tau_pair = 1e-6\n    \n    test_cases = [\n        # Test Case 1: Well-separated features\n        {\n            \"K\": 1.0,\n            \"zeros\": [0.5 * np.exp(1j * 0.3), 0.5 * np.exp(-1j * 0.3)],\n            \"poles\": [0.8 * np.exp(1j * 0.5), 0.8 * np.exp(-1j * 0.5)],\n            \"freqs\": np.linspace(0, np.pi, 513)\n        },\n        # Test Case 2: Near cancellation\n        {\n            \"K\": 1.0,\n            \"zeros\": [0.94999999 * np.exp(1j * 0.4), 0.94999999 * np.exp(-1j * 0.4)],\n            \"poles\": [0.95 * np.exp(1j * 0.4), 0.95 * np.exp(-1j * 0.4)],\n            \"freqs\": np.array([0, 0.1, 0.3, 0.4 - 1e-6, 0.4, 0.4 + 1e-6, 1.0, np.pi])\n        },\n        # Test Case 3: Higher order with multiple near-cancellation pairs\n        {\n            \"K\": 1.0,\n            \"zeros\": [(0.9999998 * np.exp(1j * angle)) for angle in [0.2, -0.2, 0.7, -0.7, 1.3, -1.3, 2.2, -2.2]],\n            \"poles\": [(0.9999999 * np.exp(1j * angle)) for angle in [0.2, -0.2, 0.7, -0.7, 1.3, -1.3, 2.2, -2.2]],\n            \"freqs\": np.linspace(0, np.pi, 2049)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        K, zeros, poles, freqs = case[\"K\"], case[\"zeros\"], case[\"poles\"], case[\"freqs\"]\n        \n        # Calculate responses\n        H_naive = naive_method(K, zeros, poles, freqs)\n        H_stab = stable_method(K, zeros, poles, freqs, tau_pair)\n        \n        # Calculate magnitudes and phases\n        mag_naive = np.abs(H_naive)\n        mag_stab = np.abs(H_stab)\n        phase_naive = np.angle(H_naive)\n        phase_stab = np.angle(H_stab)\n        \n        # Compute magnitude discrepancy\n        # Filter out infs that might result from poles on the unit circle\n        valid_indices = np.isfinite(mag_naive) & np.isfinite(mag_stab)\n        mag_discrepancy = np.abs(mag_stab[valid_indices] - mag_naive[valid_indices]) / np.maximum(mag_stab[valid_indices], epsilon)\n        max_mag_discrepancy = np.max(mag_discrepancy) if mag_discrepancy.size > 0 else 0.0\n        \n        # Compute phase discrepancy\n        phase_difference = phase_stab[valid_indices] - phase_naive[valid_indices]\n        wrapped_phase_diff = np.abs(wrap_phase_diff(phase_difference))\n        max_phase_discrepancy = np.max(wrapped_phase_diff) if wrapped_phase_diff.size > 0 else 0.0\n\n        results.extend([max_mag_discrepancy, max_phase_discrepancy])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2874596"}]}