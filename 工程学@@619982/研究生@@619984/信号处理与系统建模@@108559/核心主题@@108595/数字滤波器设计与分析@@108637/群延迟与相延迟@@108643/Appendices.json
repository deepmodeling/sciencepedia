{"hands_on_practices": [{"introduction": "我们从最基本的系统——一个纯时间移位系统——开始。这个练习旨在巩固相位延迟（$\\tau_p$）和群延迟（$\\tau_g$）的基本定义。通过分析这个理想的非色散系统，你将理解线性相位响应如何对应于所有频率分量的恒定延迟，这是无失真传输的基石。[@problem_id:1723782]", "problem": "一个线性时不变 (LTI) 系统被设计用作“预测器”，其产生的输出信号是其输入信号在时间上超前的版本。该系统的输入输出关系由以下方程给出：\n$$y(t) = x(t + t_0)$$\n其中 $x(t)$ 是输入信号，$y(t)$ 是输出信号，$t_0$ 是一个正实数常量，表示时间超前的量。\n\n该系统虽然是非因果的，因此在实时情况下是物理上不可实现的，但它是信号处理理论中的一个基本概念。你的任务是分析其在频域中的行为。\n\n确定该系统的相延迟 $\\tau_p(\\omega)$ 和群延迟 $\\tau_g(\\omega)$ 的表达式，将其表示为角频率 $\\omega$和时间超前量 $t_0$ 的函数。\n\n将你的答案呈现为一个双元素行矩阵，其中第一个元素是相延迟 $\\tau_p(\\omega)$ 的表达式，第二个元素是群延迟 $\\tau_g(\\omega)$ 的表达式。", "solution": "要确定系统的相延迟和群延迟，我们首先需要找到其频率响应 $H(\\omega)$。频率响应是系统冲激响应 $h(t)$ 的傅里叶变换。\n\n冲激响应 $h(t)$ 是当输入为狄拉克δ函数 $x(t) = \\delta(t)$ 时系统的输出。将此代入系统的输入输出关系，可得：\n$$h(t) = \\delta(t + t_0)$$\n现在，我们计算 $h(t)$ 的傅里叶变换来求 $H(\\omega)$：\n$$H(\\omega) = \\mathcal{F}\\{h(t)\\} = \\int_{-\\infty}^{\\infty} h(t) e^{-j\\omega t} dt = \\int_{-\\infty}^{\\infty} \\delta(t + t_0) e^{-j\\omega t} dt$$\n利用狄拉克δ函数的筛选特性，即 $\\int_{-\\infty}^{\\infty} \\delta(t - a) f(t) dt = f(a)$，我们可以计算该积分。在我们的例子中，δ函数中心位于 $t = -t_0$。因此，我们有：\n$$H(\\omega) = e^{-j\\omega(-t_0)} = e^{j\\omega t_0}$$\n频率响应 $H(\\omega)$ 可以用极坐标形式表示为 $H(\\omega) = |H(\\omega)| e^{j\\theta(\\omega)}$，其中 $|H(\\omega)|$ 是幅频响应，$\\theta(\\omega)$是相频响应。\n对于 $H(\\omega) = e^{j\\omega t_0}$，其幅值为 $|H(\\omega)| = |e^{j\\omega t_0}| = 1$。相频响应为：\n$$\\theta(\\omega) = \\omega t_0$$\n相延迟 $\\tau_p(\\omega)$ 定义为相频响应除以角频率的负值：\n$$\\tau_p(\\omega) = -\\frac{\\theta(\\omega)}{\\omega}$$\n代入我们的 $\\theta(\\omega)$ 表达式：\n$$\\tau_p(\\omega) = -\\frac{\\omega t_0}{\\omega} = -t_0$$\n群延迟 $\\tau_g(\\omega)$ 定义为相频响应对角频率的导数的负值：\n$$\\tau_g(\\omega) = -\\frac{d\\theta(\\omega)}{d\\omega}$$\n代入我们的 $\\theta(\\omega)$ 表达式并对 $\\omega$ 求导：\n$$\\tau_g(\\omega) = -\\frac{d}{d\\omega}(\\omega t_0) = -t_0$$\n相延迟和群延迟都是常数，等于 $-t_0$。这个负值表示时间上的超前，这与系统的定义 $y(t) = x(t+t_0)$ 是一致的。一个 $-t_0$ 的延迟等效于一个 $t_0$ 的超前。\n\n相延迟为 $-t_0$ 意味着输入信号的每一个单独的频率分量（正弦波）在输出端会提前 $t_0$ 秒出现。群延迟为 $-t_0$ 意味着一个窄带频率的包络也会在没有失真的情况下超前 $t_0$ 秒。\n\n最终答案是一个包含相延迟和群延迟表达式的双元素行矩阵。\n第一个元素：$\\tau_p(\\omega) = -t_0$\n第二个元素：$\\tau_g(\\omega) = -t_0$", "answer": "$$\\boxed{\\begin{pmatrix} -t_0 & -t_0 \\end{pmatrix}}$$", "id": "1723782"}, {"introduction": "接下来，我们从简单的延迟系统转向一个更实际的滤波器组件：全通滤波器。此问题探讨了一个系统，其幅度响应是恒定的，但相位响应是非线性的，从而导致群延迟随频率变化。通过计算这个滤波器的群延迟，你将获得关于系统如何引入*色散*的第一手经验，即不同频率分量被延迟不同时间，这是信号失真的一个关键来源。[@problem_id:1723771]", "problem": "在电信和音频工程中，全通滤波器是用于修改系统相位响应而不改变其幅值响应的关键部件。它们通常用作相位均衡器，以补偿不必要的时间延迟和信号失真。\n\n考虑一个一阶模拟全通滤波器，其在拉普拉斯域中的传递函数如下：\n$$ H(s) = \\frac{a-s}{s+a} $$\n其中，$s$ 是复频率，$a$ 是一个定义滤波器特性的正常数。参数 $a$ 的单位是弧度/秒。\n\n滤波器的群延迟，记为 $\\tau_g(\\omega)$，量化了信号不同频率分量的振幅包络所经历的时间延迟。其形式上定义为滤波器相位响应 $\\phi(\\omega)$ 相对于角频率 $\\omega$ 的负导数。恒定的群延迟对于保持复杂信号的形状至关重要。\n\n确定一个正角频率 $\\omega_0$，在该频率下，此全通滤波器的群延迟恰好是其在直流（$\\omega=0$）处值的一半。请用参数 $a$ 表示你的答案 $\\omega_0$。", "solution": "对于传递函数为 $H(s) = \\frac{a - s}{s + a}$ 且 $a > 0$ 的一阶全通滤波器，通过代入 $s = j\\omega$ 来计算其频率响应，可得 $H(j\\omega) = \\frac{a - j\\omega}{a + j\\omega}$。相位响应是分子和分母的相角之差：\n$$\n\\phi(\\omega) = \\arg(a - j\\omega) - \\arg(a + j\\omega) = -\\arctan\\!\\left(\\frac{\\omega}{a}\\right) - \\arctan\\!\\left(\\frac{\\omega}{a}\\right) = -2\\,\\arctan\\!\\left(\\frac{\\omega}{a}\\right).\n$$\n群延迟定义为 $\\tau_{g}(\\omega) = -\\frac{d\\phi(\\omega)}{d\\omega}$。使用求导法则 $\\frac{d}{d\\omega}\\arctan(u) = \\frac{1}{1+u^{2}}\\frac{du}{d\\omega}$，并令 $u = \\frac{\\omega}{a}$ 且 $\\frac{du}{d\\omega} = \\frac{1}{a}$，可得\n$$\n\\frac{d\\phi}{d\\omega} = -2 \\cdot \\frac{1}{1+(\\omega/a)^{2}} \\cdot \\frac{1}{a} = -\\frac{2a}{a^{2}+\\omega^{2}},\n$$\n因此\n$$\n\\tau_{g}(\\omega) = -\\frac{d\\phi}{d\\omega} = \\frac{2a}{a^{2}+\\omega^{2}}.\n$$\n在直流（DC）时，$\\tau_{g}(0) = \\frac{2a}{a^{2}} = \\frac{2}{a}$。我们寻求 $\\omega_{0} > 0$ 使得 $\\tau_{g}(\\omega_{0}) = \\frac{1}{2}\\tau_{g}(0) = \\frac{1}{a}$。建立方程并求解：\n$$\n\\frac{2a}{a^{2}+\\omega_{0}^{2}} = \\frac{1}{a}\n\\;\\;\\Longrightarrow\\;\\;\n2a^{2} = a^{2} + \\omega_{0}^{2}\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{0}^{2} = a^{2}\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{0} = a,\n$$\n其中取正根。", "answer": "$$\\boxed{a}$$", "id": "1723771"}, {"introduction": "最后，我们将从解析计算过渡到实际的计算任务。这个实践要求你以数值方式实现群延迟和相位延迟的定义，处理如相位展开和有限差分近似等实际挑战。通过编写代码，你将在抽象理论和实际应用之间架起一座桥梁，培养分析真实或仿真系统数据的关键技能，因为在这些场景中，我们通常无法获得解析形式的频率响应。[@problem_id:2875342]", "problem": "您的任务是设计并实现一个程序，用于计算与线性时不变系统的离散时间频率响应相关的两个延迟指标：相位延迟和群延迟。您的程序必须在一个规定的角频率网格上，对复频率响应的采样值进行操作，通过提取展开相位并对其相对于角频率进行数值微分来完成计算。角频率的单位必须是“弧度/样本”。不允许用户输入；所有参数必须在程序内部定义，并且输出必须按要求的格式打印。\n\n起点与约束。仅使用离散时间线性时不变系统和离散时间傅里叶变换（DTFT）的基本定义。频率响应是系统冲激响应的DTFT，是角频率的复函数。相位定义为此复函数的辐角。冲激响应中的直接时间平移会引入一个频率相关的复指数因子。从这些基础出发构建所有推理，避免使用任何作为最终目标给出的快捷公式。基于这些基础，推导出从展开相位中获取两个延迟指标的计算过程，并在一组均匀的角频率网格上稳健地实现它，注意时移特性所隐含的符号约定。不要为目标量假设任何特殊的解析形式；而是通过相位展开和数值微分从采样数据中提取它们。确保数值微分与以“弧度/样本”为单位的角频率一致，并使用能处理边界的有限差分法实现。以数学上一致的方式处理角频率为零的特殊情况。\n\n频率网格。使用一个包含 $N_\\omega = 4097$ 个角频率 $\\{\\omega_k\\}_{k=0}^{N_\\omega-1}$ 的均匀间隔网格，覆盖闭区间 $[0,\\pi]$（单位为“弧度/样本”）。也即，$\\omega_0 = 0$ 且 $\\omega_{N_\\omega-1} = \\pi$。\n\n代码中需实现的步骤。\n- 对于所有 $\\omega_k$，给定采样值 $H(e^{j\\omega_k})$，计算主值相位 $\\phi_{\\mathrm{pv}}(\\omega_k)$ 作为每个 $k$ 对应的 $H(e^{j\\omega_k})$ 的辐角，单位为弧度。\n- 对相位进行展开，得到连续的 $\\phi(\\omega_k)$，以消除 $k$ 值间 $2\\pi$ 的不连续性。\n- 使用内部点的中心有限差分和边界点的适当单边差分，对展开相位关于 $\\omega$ 进行数值微分，以获得所有 $\\omega_k$ 处的数值导数。\n- 使用与线性时不变系统DTFT的时移特性一致的标准符号约定，将相位斜率转换为其中一个延迟指标。\n- 在定义有意义的情况下，直接根据展开相位和角频率定义第二个延迟指标；在 $\\omega_0 = 0$ 处，使用从基于斜率的延迟计算出的极限值，以避免除以零。\n\n测试套件。通过在采样点上解析地构造 $H(e^{j\\omega})$ 来实现三个测试系统。对每个系统，在规定的网格上计算两种延迟指标，然后计算一个单一的标量诊断量，该诊断量将包含在聚合输出中返回。\n\n- 测试 A（纯整数样本延迟）。令 $n_0 = 7$。定义 $H_A(e^{j\\omega}) = e^{-j\\omega n_0}$。在网格上计算基于斜率的延迟后，计算索引 $k \\in \\{5,6,\\dots,N_\\omega-6\\}$ 范围内与 $n_0$ 的最大绝对偏差，以避免边界伪影。将此最大偏差报告为一个以样本为单位的浮点数。\n\n- 测试 B（一阶低通，稳定极点严格位于单位圆内）。令 $\\alpha = 0.9$。定义 $H_B(e^{j\\omega}) = \\dfrac{1-\\alpha}{1 - \\alpha e^{-j\\omega}}$。计算两种延迟指标。在最小正角频率 $\\omega_1$ 处（即索引 $k=1$ 处），计算两种延迟指标之间的绝对差。将此绝对差报告为一个以样本为单位的浮点数。\n\n- 测试 C（一阶稳定全通）。令 $a = 0.6$。定义 $H_C(e^{j\\omega}) = \\dfrac{a - e^{-j\\omega}}{1 - a e^{-j\\omega}}$。在整个网格上计算基于斜率的延迟，然后计算其在所有 $k$ 上的算术平均值。将该平均值与 $1$ 之间的绝对差报告为一个以样本为单位的浮点数。\n\n角度与单位。所有角度单位为弧度，所有角频率单位为“弧度/样本”，延迟指标单位为样本。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{测试 A 结果}, \\text{测试 B 结果}, \\text{测试 C 结果}]$。例如，输出必须类似于 $[x_A,x_B,x_C]$，包含三个浮点数，无其他文本。\n\n您的解决方案必须实现为一个完整的、可运行的程序，并遵循指定的执行环境。", "solution": "问题陈述已经过严格验证，被认为是有效的。它科学地植根于离散时间信号处理的原理，问题定义清晰且提供了所有必要信息，并且表述客观。因此，我们着手构建解决方案。\n\n问题的核心是为一个离散时间线性时不变（LTI）系统计算两个延迟度量——群延迟和相位延迟。这些度量源自系统的频率响应，即其冲激响应 $h(n)$ 的离散时间傅里叶变换（DTFT）。\n\n设频率响应表示为 $H(e^{j\\omega})$，其中 $\\omega$ 是角频率，单位为“弧度/样本”。$H(e^{j\\omega})$ 是一个复函数，可以表示为极坐标形式：\n$$ H(e^{j\\omega}) = |H(e^{j\\omega})| e^{j\\phi(\\omega)} $$\n其中 $|H(e^{j\\omega})|$ 是幅度响应，$\\phi(\\omega)$ 是相位响应。\n\n群延迟和相位延迟的定义源于DTFT的时移特性。考虑一个冲激响应 $h(n)$ 及其延迟版本 $h_d(n) = h(n-n_0)$，其中 $n_0$ 是一个以样本为单位的恒定整数延迟。$h_d(n)$ 的DTFT是：\n$$ H_d(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} h(n-n_0) e^{-j\\omega n} $$\n通过变量代换 $m = n-n_0$，我们得到：\n$$ H_d(e^{j\\omega}) = \\sum_{m=-\\infty}^{\\infty} h(m) e^{-j\\omega (m+n_0)} = e^{-j\\omega n_0} \\sum_{m=-\\infty}^{\\infty} h(m) e^{-j\\omega m} = H(e^{j\\omega}) e^{-j\\omega n_0} $$\n延迟后系统的相位是 $\\phi_d(\\omega) = \\phi(\\omega) - \\omega n_0$。一个恒定的时间延迟 $n_0$ 引入了一个斜率为 $-n_0$ 的线性相位分量。此关系确立了延迟定义的符号约定。\n\n**群延迟** $\\tau_g(\\omega)$ 量化了通过系统的信号包络的延迟，定义为相位对频率变化率的负值：\n$$ \\tau_g(\\omega) = -\\frac{d\\phi(\\omega)}{d\\omega} $$\n对于纯延迟系统，其相位 $\\phi(\\omega) = - \\omega n_0$（假设原始系统相位为零），群延迟为 $\\tau_g(\\omega) = -(-n_0) = n_0$，这正确地恢复了恒定的时间平移。\n\n**相位延迟** $\\tau_p(\\omega)$ 量化了正弦信号载波频率的延迟，定义为：\n$$ \\tau_p(\\omega) = -\\frac{\\phi(\\omega)}{\\omega} $$\n对于纯延迟系统，$\\tau_p(\\omega) = -(-\\omega n_0 / \\omega) = n_0$。对于像纯延迟这样的非色散系统，群延迟和相位延迟是相同的。\n\n在 $\\omega=0$ 处，相位延迟的定义会产生不定式 $0/0$，因为对于任何实值冲激响应，$\\phi(0)=0$。该点的值由极限确定，可以使用洛必达法则进行计算：\n$$ \\lim_{\\omega \\to 0} \\tau_p(\\omega) = \\lim_{\\omega \\to 0} \\left( -\\frac{\\phi(\\omega)}{\\omega} \\right) = -\\left. \\frac{d\\phi(\\omega)}{d\\omega} \\right|_{\\omega=0} = \\tau_g(0) $$\n这证实了问题中指定的处理 $\\omega=0$ 情况的步骤。\n\n计算过程在一个由 $N_\\omega = 4097$ 个频率点组成的离散网格 $\\{\\omega_k\\}_{k=0}^{N_\\omega-1}$ 上执行，这些频率点均匀分布在 $[0, \\pi]$ 区间内。频率步长为 $\\Delta\\omega = \\pi / (N_\\omega - 1)$。\n\n1.  **相位提取**：对于给定的复频率响应 $H(e^{j\\omega_k})$，使用 `atan2` 函数计算主值相位 $\\phi_{\\mathrm{pv}}(\\omega_k)$，该函数将相位映射到区间 $(-\\pi, \\pi]$ 内。\n2.  **相位展开**：主值相位可能包含 $\\pm 2\\pi$ 的人为跳变。通过“展开”操作恢复连续相位函数 $\\phi(\\omega_k)$，该操作包括对连续元素加上或减去 $2\\pi$ 的整数倍，以消除大于阈值（通常为 $\\pi$）的跳变。\n3.  **群延迟的数值微分**：使用有限差分法近似导数 $d\\phi/d\\omega$。\n    - 对于内部点 ($k=1, \\dots, N_\\omega - 2$)：使用二阶精度的中心差分：\n      $$ \\left.\\frac{d\\phi}{d\\omega}\\right|_{\\omega_k} \\approx \\frac{\\phi(\\omega_{k+1}) - \\phi(\\omega_{k-1})}{2 \\Delta\\omega} $$\n    - 对于边界点 ($k=0$ 和 $k=N_\\omega-1$)：使用一阶精度的单边差分：\n      $$ \\left.\\frac{d\\phi}{d\\omega}\\right|_{\\omega_0} \\approx \\frac{\\phi(\\omega_1) - \\phi(\\omega_0)}{\\Delta\\omega}, \\quad \\left.\\frac{d\\phi}{d\\omega}\\right|_{\\omega_{N_\\omega-1}} \\approx \\frac{\\phi(\\omega_{N_\\omega-1}) - \\phi(\\omega_{N_\\omega-2})}{\\Delta\\omega} $$\n    群延迟则为 $\\tau_g(\\omega_k) = - (d\\phi/d\\omega)|_{\\omega_k}$。\n4.  **相位延迟计算**：对于 $k > 0$，相位延迟直接计算为 $\\tau_p(\\omega_k) = -\\phi(\\omega_k)/\\omega_k$。在 $k=0$ 处，我们设置 $\\tau_p(\\omega_0) = \\tau_g(\\omega_0)$。\n\n对三个测试用例的分析如下：\n- **测试 A：纯整数延迟**。系统为 $H_A(e^{j\\omega}) = e^{-j\\omega n_0}$，其中 $n_0=7$。解析相位为 $\\phi(\\omega) = -7\\omega$，解析群延迟为 $\\tau_g(\\omega) = 7$（对所有 $\\omega$）。指定的诊断指标测量在频率范围内部数值群延迟计算的最大误差，避开精度较低的边界近似。\n- **测试 B：一阶低通滤波器**。系统为 $H_B(e^{j\\omega}) = \\frac{1-\\alpha}{1 - \\alpha e^{-j\\omega}}$，其中 $\\alpha=0.9$。这是一个色散系统，意味着其相位响应不随频率线性变化。因此，对于 $\\omega > 0$，有 $\\tau_g(\\omega) \\neq \\tau_p(\\omega)$。诊断指标测量在第一个非零频率点 $\\omega_1$ 处这两种延迟之间的差值，从而为系统在低频下的色散程度提供一个量化度量。\n- **测试 C：一阶全通滤波器**。系统为 $H_C(e^{j\\omega}) = \\frac{a - e^{-j\\omega}}{1 - a e^{-j\\omega}}$，其中 $a=0.6$。其幅度响应对于所有 $\\omega$ 均为 $|H_C(e^{j\\omega})|=1$。群延迟不是恒定的；其解析形式为 $\\tau_g(\\omega) = \\frac{1-a^2}{1+a^2-2a\\cos\\omega}$。该系统的一个关键特性是其在区间 $[0, \\pi]$ 上的平均群延迟恰好为 $1$：\n  $$ \\bar{\\tau_g} = \\frac{1}{\\pi} \\int_0^\\pi \\tau_g(\\omega) \\, d\\omega = \\frac{1-a^2}{\\pi} \\int_0^\\pi \\frac{d\\omega}{1+a^2-2a\\cos\\omega} = \\frac{1-a^2}{\\pi} \\left[ \\frac{\\pi}{1-a^2} \\right] = 1 $$\n  诊断指标计算了在网格上数值计算出的群延迟值 $\\{\\tau_g(\\omega_k)\\}$ 的算术平均值，这是对该积分的离散近似。该数值平均值与理论值 $1$ 之间的绝对差测试了在整个频率范围内群延迟计算的总体精度。\n\n接下来将基于这些原理进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes phase and group delays for three test systems and reports diagnostic quantities.\n    \"\"\"\n    N_omega = 4097\n    omega = np.linspace(0, np.pi, N_omega)\n    delta_omega = np.pi / (N_omega - 1)\n\n    def compute_delays(H, omega_grid, delta_omega_val):\n        \"\"\"\n        Computes group and phase delay from a complex frequency response.\n\n        Args:\n            H (np.ndarray): Complex frequency response samples.\n            omega_grid (np.ndarray): The angular frequency grid.\n            delta_omega_val (float): The spacing of the frequency grid.\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]: A tuple containing the group delay and phase delay.\n        \"\"\"\n        # Step 1: Compute principal-value phase\n        phi_pv = np.angle(H)\n\n        # Step 2: Unwrap the phase\n        phi_uw = np.unwrap(phi_pv)\n\n        # Step 3: Numerically differentiate for group delay\n        # np.gradient uses centered differences for interior and one-sided for boundaries.\n        # This matches the problem specification.\n        # tau_g = -d(phi)/d(omega)\n        dphi_domega = np.gradient(phi_uw, delta_omega_val)\n        tau_g = -dphi_domega\n\n        # Step 4: Compute phase delay\n        # tau_p = -phi/omega\n        # To avoid division by zero at omega=0, we suppress the warning and handle it separately.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            tau_p = -phi_uw / omega_grid\n        \n        # Handle the special case at omega = 0 using the limiting value, tau_g(0).\n        if omega_grid[0] == 0:\n            tau_p[0] = tau_g[0]\n\n        return tau_g, tau_p\n\n    # --- Test Cases ---\n    results = []\n\n    # Test A: Pure integer sample delay\n    n0 = 7.0\n    H_A = np.exp(-1j * omega * n0)\n    tau_g_A, _ = compute_delays(H_A, omega, delta_omega)\n    # Diagnostic: max absolute deviation from n0, avoiding boundary artifacts.\n    # The spec is k in {5, ..., N_omega-6}. In Python slicing this is [5:N_omega-5]\n    deviation_A = np.max(np.abs(tau_g_A[5:N_omega-5] - n0))\n    results.append(deviation_A)\n\n    # Test B: First-order low-pass filter\n    alpha = 0.9\n    H_B = (1 - alpha) / (1 - alpha * np.exp(-1j * omega))\n    tau_g_B, tau_p_B = compute_delays(H_B, omega, delta_omega)\n    # Diagnostic: absolute difference between the two delays at the smallest positive frequency (k=1)\n    diff_B = np.abs(tau_g_B[1] - tau_p_B[1])\n    results.append(diff_B)\n\n    # Test C: First-order stable all-pass\n    a = 0.6\n    # Note: A small epsilon is added to the denominator to prevent potential floating point issues\n    # if the denominator becomes exactly zero, although it is not expected for this H(w).\n    denominator_C = 1 - a * np.exp(-1j * omega)\n    H_C = (a - np.exp(-1j * omega)) / denominator_C\n    tau_g_C, _ = compute_delays(H_C, omega, delta_omega)\n    # Diagnostic: absolute difference between the arithmetic mean of tau_g and 1.\n    mean_tau_g_C = np.mean(tau_g_C)\n    diff_C = np.abs(mean_tau_g_C - 1.0)\n    results.append(diff_C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2875342"}]}