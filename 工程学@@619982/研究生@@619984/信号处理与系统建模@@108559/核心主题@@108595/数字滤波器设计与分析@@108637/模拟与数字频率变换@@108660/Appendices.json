{"hands_on_practices": [{"introduction": "本练习聚焦于IIR滤波器设计的基石：双线性变换（Bilinear Transform, BLT）。你将从第一性原理出发，推导模拟频率和数字频率之间的非线性映射关系，并理解“频率预畸变”（frequency prewarping）技术如何确保滤波器的关键频率（如截止频率）得到精确定位。掌握这项实践是准确地将模拟滤波器指标转换到数字域的必备技能。[@problem_id:2852447]", "problem": "一个阶数为$N$、截止（半功率）弧度频率为$\\Omega_{c}$的模拟低通巴特沃斯原型，将通过双线性变换（BLT）转换为一个数字无限冲激响应（IIR）滤波器。应用BLT时，采样周期为$T$，并使用了模拟预畸，以使最终得到的数字滤波器在单位圆上具有一个精确的期望数字截止弧度频率$\\omega_{c,\\mathrm{des}}$。\n\n请仅从以下核心定义出发：(i) BLT是从复$s$平面到复$z$平面的共形映射，以及(ii)通过将$s$限制在虚轴$s=j\\Omega$上并将$z$限制在单位圆$z=\\exp(j\\omega)$上来评估模拟到数字的频率对应关系，完成以下任务：\n\n1. 在约束条件$s=j\\Omega$和$z=\\exp(j\\omega)$下，推导由BLT引起的模拟到数字的频率映射关系$\\Omega \\leftrightarrow \\omega$，不假设任何特定的滤波器阶数。根据此映射关系，推导出必须使用的预畸模拟截止频率$\\Omega_{p}$，以使所设计的数字滤波器的截止频率精确地等于指定的$\\omega_{c,\\mathrm{des}}$。\n\n2. 使用推导的结果，确定在预畸和BLT之后达到的精确数字截止频率$\\omega_{c}^{\\star}$。首先用$\\omega_{c,\\mathrm{des}}$和$T$的符号形式表示，然后根据具体的设计参数\n$\\{N=6,\\ \\Omega_{c}=1\\ \\text{rad/s},\\ T=10^{-3}\\ \\text{s},\\ \\omega_{c,\\mathrm{des}}=0.45\\pi\\ \\text{radians/sample}\\}$ 对其进行数值计算。\n解释为什么在使用预畸时，$N$和$\\Omega_{c}$的值不会改变所达到的数字截止频率的精确性。\n\n报告你的$\\omega_{c}^{\\star}$最终数值答案，单位为弧度/样本，四舍五入到四位有效数字。", "solution": "该问题陈述是有效的。这是一个在数字信号处理领域中适定的、有科学依据的问题，它要求推导和应用与使用双线性变换（BLT）进行IIR滤波器设计相关的基本原理。所有必要信息均已提供，问题没有矛盾或歧义。\n\n分析按要求分两部分进行。\n\n第1部分：频率映射与预畸截止频率的推导\n\n双线性变换提供了从复$s$平面到复$z$平面的映射。包含采样周期$T$的BLT标准定义由以下替换给出：\n$$ s = \\frac{2}{T} \\frac{1 - z^{-1}}{1 + z^{-1}} = \\frac{2}{T} \\frac{z - 1}{z + 1} $$\n为了找到模拟频率$\\Omega$和数字频率$\\omega$之间的关系，我们必须在$s$平面的虚轴$s=j\\Omega$和$z$平面的单位圆$z=\\exp(j\\omega)$上评估此变换。将这些代入BLT方程，得到：\n$$ j\\Omega = \\frac{2}{T} \\frac{\\exp(j\\omega) - 1}{\\exp(j\\omega) + 1} $$\n为简化右侧，我们可以使用双曲正切的恒等式$\\tanh(x) = \\frac{\\exp(2x)-1}{\\exp(2x)+1}$。通过令$x = j\\omega/2$，表达式变为：\n$$ j\\Omega = \\frac{2}{T} \\tanh\\left(\\frac{j\\omega}{2}\\right) $$\n使用双曲正切和三角正切之间的关系$\\tanh(jx) = j\\tan(x)$，我们有：\n$$ j\\Omega = \\frac{2}{T} j\\tan\\left(\\frac{\\omega}{2}\\right) $$\n或者，不使用双曲正切恒等式，我们可以从分子和分母中提出因子$\\exp(j\\omega/2)$：\n$$ j\\Omega = \\frac{2}{T} \\frac{\\exp(j\\omega/2) \\left( \\exp(j\\omega/2) - \\exp(-j\\omega/2) \\right)}{\\exp(j\\omega/2) \\left( \\exp(j\\omega/2) + \\exp(-j\\omega/2) \\right)} $$\n使用欧拉公式$\\exp(j\\theta) - \\exp(-j\\theta) = 2j\\sin(\\theta)$和$\\exp(j\\theta) + \\exp(-j\\theta) = 2\\cos(\\theta)$，其中$\\theta = \\omega/2$，这可以简化为：\n$$ j\\Omega = \\frac{2}{T} \\frac{2j\\sin(\\omega/2)}{2\\cos(\\omega/2)} = \\frac{2}{T} j\\tan\\left(\\frac{\\omega}{2}\\right) $$\n消去两边的虚数单位$j$，得到模拟频率$\\Omega$和数字频率$\\omega$之间的直接非线性映射关系：\n$$ \\Omega = \\frac{2}{T} \\tan\\left(\\frac{\\omega}{2}\\right) $$\n这种线性的模拟频率轴被非线性地映射到数字频率轴上的现象，被称为频率畸变（frequency warping）。\n\n预畸的目的是在感兴趣的特定频率点上抵消这种效应。为确保最终得到的数字滤波器的截止频率精确地位于期望值$\\omega_{c,\\mathrm{des}}$处，我们必须设计一个具有特别选择的截止频率的中间模拟滤波器，我们将其记为预畸模拟截止频率$\\Omega_p$。这个$\\Omega_p$是在BLT下精确地映射到$\\omega_{c,\\mathrm{des}}$的模拟频率。我们通过将$\\omega = \\omega_{c,\\mathrm{des}}$代入导出的映射方程来找到它：\n$$ \\Omega_{p} = \\frac{2}{T} \\tan\\left(\\frac{\\omega_{c,\\mathrm{des}}}{2}\\right) $$\n这就是所需的预畸模拟截止频率的表达式。在应用BLT之前，必须对截止频率为$\\Omega_c$的模拟原型滤波器进行频率缩放，使其具有此截止频率$\\Omega_p$。\n\n第2部分：计算与解释\n\n问题要求计算在预畸和应用BLT之后达到的精确数字截止频率$\\omega_{c}^{\\star}$。预畸步骤正是为此目的而设计的。我们从一个截止频率为$\\Omega_c$的模拟原型开始。然后我们对其频率响应进行缩放，创建一个新的、截止频率为$\\Omega_p = \\frac{2}{T} \\tan(\\omega_{c,\\mathrm{des}}/2)$的模拟滤波器。当BLT应用于这个经过预畸的模拟滤波器时，根据频率映射的定义，其截止频率$\\Omega_p$将被变换为数字频率$\\omega_{c,\\mathrm{des}}$。因此，所达到的数字截止频率$\\omega_{c}^{\\star}$精确地等于期望的数字截止频率$\\omega_{c,\\mathrm{des}}$。\n在符号上，答案是：\n$$ \\omega_{c}^{\\star} = \\omega_{c,\\mathrm{des}} $$\n使用给定的数值参数：\n$$ \\omega_{c,\\mathrm{des}} = 0.45\\pi\\ \\text{radians/sample} $$\n达到的精确数字截止频率是：\n$$ \\omega_{c}^{\\star} = 0.45\\pi \\approx 1.41371669... \\ \\text{radians/sample} $$\n将此值四舍五入到四位有效数字，得到$1.414$ 弧度/样本。\n\n原型滤波器阶数$N$和原型截止频率$\\Omega_c$的值，不会改变所达到的数字截止频率$\\omega_c^{\\star}$的精确性。推理如下：频率映射$\\Omega = \\frac{2}{T}\\tan(\\omega/2)$是双线性变换本身的一个内在数学性质。它描述了频率轴是如何被变换的，而与应用于其上的滤波器传递函数无关。预畸步骤*仅*基于期望的数字截止频率$\\omega_{c,\\mathrm{des}}$和采样周期$T$来明确地计算所需的模拟截止频率$\\Omega_p$。这个步骤有效地将最终截止频率的位置与初始原型的规格（$N$和$\\Omega_c$）解耦。参数$N$和$\\Omega_c$定义了*原型*滤波器的特性（例如，其幅度响应形状和过渡带宽）。虽然这些特性在最终的数字滤波器中以一种畸变的方式被保留，但对原型进行频率缩放以满足预畸截止频率$\\Omega_p$的过程，确保了最终数字滤波器的半功率点精确地落在$\\omega_{c,\\mathrm{des}}$，而无论原型的原始阶数或截止频率如何。", "answer": "$$\n\\boxed{1.414}\n$$", "id": "2852447"}, {"introduction": "双线性变换虽然强大，但并非唯一的设计方法。本练习将它与另一种重要方法——脉冲响应不变法（Impulse Invariance method）——进行严格的对比分析。通过考察这两种变换对直流增益、瞬态响应和频率混叠的不同影响，你将更深刻地理解在特定应用中选择合适变换方法时所涉及的权衡。[@problem_id:2852396]", "problem": "考虑一个连续时间一阶低通原型，其传递函数为 $H_{a}(s)=\\dfrac{\\Omega_{c}}{s+\\Omega_{c}}$，其中 $\\Omega_{c}>0$。基于 $H_{a}(s)$，在采样周期 $T>0$ 下，采用以下两种变换规则设计了两个离散时间线性时不变 (LTI) 滤波器。变换规则采用其标准形式，不进行任何额外的增益归一化或频率预畸变：\n- 冲激不变法：将离散时间冲激响应定义为经过采样和缩放的连续时间冲激响应。\n- 双线性变换：通过将 $s$ 平面的开左半平面映射到 $z$ 平面的开单位圆盘的共形映射来变换复频率变量。\n\n设 $H_{\\mathrm{II}}(z)$ 和 $H_{\\mathrm{BL}}(z)$ 分别表示得到的离散时间传递函数。对于单位阶跃输入 $u[n]$，设 $s_{\\mathrm{II}}[n]$ 和 $s_{\\mathrm{BL}}[n]$ 分别是 $H_{\\mathrm{II}}(z)$ 和 $H_{\\mathrm{BL}}(z)$ 对应的阶跃响应。假设两种设计都得到精确实现，且输入是严格的离散时间信号。下列陈述中哪些是正确的？选择所有适用选项。\n\nA. 对于任何 $T>0$，稳态值 $\\lim_{n\\to\\infty}s_{\\mathrm{II}}[n]$ 严格大于 $1$，而 $\\lim_{n\\to\\infty}s_{\\mathrm{BL}}[n]=1$。这种差异的产生是由于冲激不变法通过样本的矩形和来近似连续时间阶跃积分，而双线性变换将 $z=1$ 映射到 $s=0$，从而精确地保留了直流 (DC) 增益。\n\nB. $H_{\\mathrm{II}}(z)$ 的唯一极点位于 $z=e^{-\\Omega_{c}T}$，而 $H_{\\mathrm{BL}}(z)$ 的唯一极点位于 $z=\\dfrac{1-\\frac{\\Omega_{c}T}{2}}{1+\\frac{\\Omega_{c}T}{2}}$。因此，当 $\\Omega_{c}T>2$ 时，双线性变换的极点为负，并产生非单调（符号交替）的瞬态响应，而冲激不变法的瞬态响应则保持单调。\n\nC. 冲激不变法对所有输入都没有混叠，因此对于所有 $n\\in\\mathbb{Z}_{\\ge 0}$，$s_{\\mathrm{II}}[n]$ 都精确等于采样的连续时间阶跃响应。\n\nD. 在快速采样极限下，即当 $\\Omega_{c}$ 固定且 $T\\to 0^{+}$ 时，控制 $s_{\\mathrm{II}}[n]$ 和 $s_{\\mathrm{BL}}[n]$ 瞬态响应的主导指数因子在 $T$ 的一阶上是一致的，而它们相应的每样本衰减率仅在 $T^{2}$ 阶上存在差异。\n\nE. 双线性变换保持冲激响应下的面积；因此，对于任何 $T>0$，$\\lim_{n\\to\\infty}s_{\\mathrm{BL}}[n]=\\dfrac{\\Omega_{c}T}{1-e^{-\\Omega_{c}T}}$。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   **连续时间原型滤波器**：$H_{a}(s)=\\dfrac{\\Omega_{c}}{s+\\Omega_{c}}$，截止频率 $\\Omega_{c} > 0$。\n-   **采样周期**：$T > 0$。\n-   **设计方法 1 (冲激不变法)**：离散时间冲激响应 $h_{\\mathrm{II}}[n]$ 是经过采样和缩放的连续时间冲激响应 $h_a(t)$。\n-   **设计方法 2 (双线性变换)**：复频率变量 $s$ 通过标准共形映射 $s \\to \\frac{2}{T}\\frac{1-z^{-1}}{1+z^{-1}}$ 进行变换。\n-   **归一化**：未应用额外的增益归一化或频率预畸变。\n-   **离散时间传递函数**：$H_{\\mathrm{II}}(z)$ 和 $H_{\\mathrm{BL}}(z)$。\n-   **输入信号**：单位阶跃序列 $u[n]$。\n-   **输出信号（阶跃响应）**：$s_{\\mathrm{II}}[n]$ 和 $s_{\\mathrm{BL}}[n]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数字信号处理领域（特别是IIR滤波器设计）中有明确的定义。\n-   **科学依据**：该问题使用了标准的“教科书”概念：一阶低通滤波器、冲激不变法和双线性变换。这些是数字信号处理（DSP）中的基本方法。其原理是可靠的。\n-   **适定性**：该问题给出了足够的信息以唯一确定离散时间传递函数 $H_{\\mathrm{II}}(z)$ 和 $H_{\\mathrm{BL}}(z)$。所提出的问题是具体的，可以通过直接计算和分析来回答。\n-   **客观性**：该问题使用精确的数学和工程术语陈述。没有歧义或主观内容。\n\n所有其他的无效性检查均已通过。该问题是一个比较两种常见的模拟到数字滤波器设计技术的标准练习。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导解答。\n\n首先，我们推导传递函数 $H_{\\mathrm{II}}(z)$ 和 $H_{\\mathrm{BL}}(z)$。\n\n**冲激不变法设计 ($H_{\\mathrm{II}}(z)$)**\n1.  模拟原型 $H_a(s)$ 的冲激响应通过拉普拉斯逆变换求得：\n    $$h_a(t) = \\mathcal{L}^{-1}\\left\\{\\frac{\\Omega_{c}}{s+\\Omega_{c}}\\right\\} = \\Omega_{c} e^{-\\Omega_{c} t} u_a(t)$$\n    其中 $u_a(t)$ 是连续时间单位阶跃函数。\n2.  带缩放的冲激不变法将离散时间冲激响应定义为 $h_{\\mathrm{II}}[n] = T \\cdot h_a(nT)$。\n    $$h_{\\mathrm{II}}[n] = T \\left( \\Omega_{c} e^{-\\Omega_{c} nT} u_a(nT) \\right) = T\\Omega_{c} (e^{-\\Omega_{c}T})^n u[n]$$\n    其中 $u[n]$ 是离散时间单位阶跃序列。\n3.  $h_{\\mathrm{II}}[n]$ 的Z变换给出传递函数 $H_{\\mathrm{II}}(z)$:\n    $$H_{\\mathrm{II}}(z) = \\mathcal{Z}\\{h_{\\mathrm{II}}[n]\\} = T\\Omega_{c} \\sum_{n=0}^{\\infty} (e^{-\\Omega_{c}T} z^{-1})^n = \\frac{T\\Omega_{c}}{1 - e^{-\\Omega_{c}T}z^{-1}}$$\n\n**双线性变换设计 ($H_{\\mathrm{BL}}(z)$)**\n1.  双线性变换由代换 $s = \\frac{2}{T}\\frac{1-z^{-1}}{1+z^{-1}}$ 定义。\n2.  我们将其代入 $H_a(s)$:\n    $$H_{\\mathrm{BL}}(z) = H_a\\left(\\frac{2}{T}\\frac{1-z^{-1}}{1+z^{-1}}\\right) = \\frac{\\Omega_c}{\\frac{2}{T}\\frac{1-z^{-1}}{1+z^{-1}} + \\Omega_c}$$\n    将分子和分母同乘以 $T(1+z^{-1})$ 得到：\n    $$H_{\\mathrm{BL}}(z) = \\frac{\\Omega_c T(1+z^{-1})}{2(1-z^{-1}) + \\Omega_c T(1+z^{-1})} = \\frac{\\Omega_c T(1+z^{-1})}{(2+\\Omega_c T) - (2-\\Omega_c T)z^{-1}}$$\n    这可以写成：\n    $$H_{\\mathrm{BL}}(z) = \\frac{\\Omega_c T}{2+\\Omega_c T} \\cdot \\frac{1+z^{-1}}{1 - \\frac{2-\\Omega_c T}{2+\\Omega_c T}z^{-1}}$$\n\n现在我们评估每个陈述。\n\n**A. 对于任何 $T>0$，稳态值 $\\lim_{n\\to\\infty}s_{\\mathrm{II}}[n]$ 严格大于 $1$，而 $\\lim_{n\\to\\infty}s_{\\mathrm{BL}}[n]=1$。这种差异的产生是由于冲激不变法通过样本的矩形和来近似连续时间阶跃积分，而双线性变换将 $z=1$ 映射到 $s=0$，从而精确地保留了直流 (DC) 增益。**\n\n阶跃响应的稳态值可以使用终值定理求得，该定理指出 $\\lim_{n\\to\\infty} s[n] = \\lim_{z\\to 1} (1-z^{-1})S(z)$。对于一个稳定的系统，其输入为 $u[n]$，其Z变换为 $U(z)=\\frac{1}{1-z^{-1}}$，阶跃响应为 $S(z)=H(z)U(z)$，因此稳态值为 $H(1)$。\n\n-   对于冲激不变法：\n    $$s_{\\mathrm{II, ss}} = H_{\\mathrm{II}}(1) = \\frac{T\\Omega_{c}}{1 - e^{-\\Omega_{c}T}}$$\n    令 $x = \\Omega_{c}T > 0$。我们必须将 $\\frac{x}{1-e^{-x}}$ 与 1 进行比较。考虑函数 $f(x) = x - (1-e^{-x})$。在 $x=0$ 处，$f(0)=0$。其导数为 $f'(x) = 1-e^{-x}$。对于 $x>0$，$f'(x)>0$，所以 $f(x)$ 是严格递增的。因此，对于 $x>0$，$f(x) > f(0) = 0$，这意味着 $x > 1-e^{-x}$。由于 $1-e^{-x}>0$，我们可以两边相除得到 $\\frac{x}{1-e^{-x}} > 1$。因此，$s_{\\mathrm{II, ss}} > 1$。\n-   对于双线性变换：\n    $$s_{\\mathrm{BL, ss}} = H_{\\mathrm{BL}}(1) = \\frac{\\Omega_c T(1+1)}{(2+\\Omega_c T) - (2-\\Omega_c T)(1)} = \\frac{2\\Omega_c T}{2+\\Omega_c T - 2 + \\Omega_c T} = \\frac{2\\Omega_c T}{2\\Omega_c T} = 1$$\n陈述中的数值部分是正确的。其推理也是正确的。冲激不变法会产生混叠，因为原型滤波器不是带限的。得到的数字滤波器的直流增益是 $H_{II}(1) = \\sum_{k=-\\infty}^{\\infty} H_a(j \\frac{2\\pi k}{T})$，它将直流增益 $H_a(0)=1$ 与混叠分量相加，使其大于1。双线性变换将模拟域中的直流点 $s=0$ 映射到数字域中的直流点 $z=1$，因此 $H_{\\mathrm{BL}}(1) = H_a(0) = 1$，从而保留了直流增益。\n\n关于A的结论：**正确**。\n\n**B. $H_{\\mathrm{II}}(z)$ 的唯一极点位于 $z=e^{-\\Omega_{c}T}$，而 $H_{\\mathrm{BL}}(z)$ 的唯一极点位于 $z=\\dfrac{1-\\frac{\\Omega_{c}T}{2}}{1+\\frac{\\Omega_{c}T}{2}}$。因此，当 $\\Omega_{c}T>2$ 时，双线性变换的极点为负，并产生非单调（符号交替）的瞬态响应，而冲激不变法的瞬态响应则保持单调。**\n\n极点由传递函数的分母求得。\n-   $H_{\\mathrm{II}}(z)$ 的极点：由 $1 - e^{-\\Omega_{c}T}z^{-1}=0$，我们求得极点 $p_{\\mathrm{II}} = e^{-\\Omega_{c}T}$。\n-   $H_{\\mathrm{BL}}(z)$ 的极点：由 $1 - \\frac{2-\\Omega_c T}{2+\\Omega_c T}z^{-1}=0$，我们求得极点 $p_{\\mathrm{BL}} = \\frac{2-\\Omega_c T}{2+\\Omega_c T} = \\frac{1-\\frac{\\Omega_{c}T}{2}}{1+\\frac{\\Omega_{c}T}{2}}$。\n给出的极点位置是正确的。\n\n现在，我们分析瞬态行为。响应的瞬态部分由形如 $(p)^n$ 的项决定。\n-   由于 $\\Omega_c > 0$ 且 $T > 0$，极点 $p_{\\mathrm{II}} = e^{-\\Omega_{c}T}$ 满足 $0 < p_{\\mathrm{II}} < 1$。它总是实数且为正。瞬态项 $(p_{\\mathrm{II}})^n$ 单调衰减至零，符号不变。因此阶跃响应是单调的。\n-   极点 $p_{\\mathrm{BL}}$ 的符号取决于其分子 $1-\\frac{\\Omega_{c}T}{2}$。\n    -   如果 $\\Omega_{c}T < 2$，那么 $p_{\\mathrm{BL}} > 0$。瞬态是单调的。\n    -   如果 $\\Omega_{c}T > 2$，那么 $p_{\\mathrm{BL}} < 0$。瞬态项 $(p_{\\mathrm{BL}})^n$ 的符号交替变化，导致阶跃响应在其最终值附近振荡。这是一个非单调响应。\n该陈述正确地描述了此行为。\n\n关于B的结论：**正确**。\n\n**C. 冲激不变法对所有输入都没有混叠，因此对于所有 $n\\in\\mathbb{Z}_{\\ge 0}$，$s_{\\mathrm{II}}[n]$ 都精确等于采样的连续时间阶跃响应。**\n\n第一个论断，“冲激不变法对所有输入都没有混叠”，是根本错误的。该方法涉及对模拟冲激响应进行采样。根据采样定理，除非模拟信号是严格带限的，否则此过程会引入混叠。我们原型的频率响应 $|H_a(j\\Omega)| = \\frac{\\Omega_c}{\\sqrt{\\Omega^2+\\Omega_c^2}}$ 具有无限支撑，因此混叠是不可避免的。\n\n第二个论断是第一个论断的推论，也是错误的。我们通过直接比较来验证。\n-   连续时间阶跃响应是 $s_a(t) = \\mathcal{L}^{-1}\\{H_a(s)/s\\} = \\mathcal{L}^{-1}\\{\\frac{1}{s} - \\frac{1}{s+\\Omega_c}\\} = (1 - e^{-\\Omega_c t})u_a(t)$。\n-   采样的连续时间阶跃响应是 $s_a(nT) = (1 - e^{-\\Omega_c nT})u[n]$。\n-   离散时间滤波器的阶跃响应是其冲激响应的累加器：$s_{\\mathrm{II}}[n] = \\sum_{k=0}^n h_{\\mathrm{II}}[k] = \\sum_{k=0}^n T\\Omega_{c} (e^{-\\Omega_{c}T})^k$。这是一个几何级数和：\n    $$s_{\\mathrm{II}}[n] = T\\Omega_{c} \\frac{1 - (e^{-\\Omega_{c}T})^{n+1}}{1 - e^{-\\Omega_{c}T}}$$\n将 $s_{\\mathrm{II}}[n]$ 与 $s_a(nT)$ 进行比较，它们显然不相等。例如，在 $n=0$ 时，$s_a(0) = 0$，而 $s_{\\mathrm{II}}[0] = h_{\\mathrm{II}}[0] = T\\Omega_{c} \\neq 0$。\n\n关于C的结论：**不正确**。\n\n**D. 在快速采样极限下，即当 $\\Omega_{c}$ 固定且 $T\\to 0^{+}$ 时，控制 $s_{\\mathrm{II}}[n]$ 和 $s_{\\mathrm{BL}}[n]$ 瞬态响应的主导指数因子在 $T$ 的一阶上是一致的，而它们相应的每样本衰减率仅在 $T^{2}$ 阶上存在差异。**\n\n“主导指数因子”即是极点 $p_{\\mathrm{II}}$ 和 $p_{\\mathrm{BL}}$。我们分析它们对于小 $T$ 的泰勒级数展开。令 $x = \\Omega_c T$。\n-   $p_{\\mathrm{II}} = e^{-x} = 1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + O(x^4) = 1 - \\Omega_c T + \\frac{(\\Omega_c T)^2}{2} - O(T^3)$。\n-   $p_{\\mathrm{BL}} = \\frac{1-x/2}{1+x/2} = (1-x/2)(1-x/2+(x/2)^2-\\dots) = 1 - x + \\frac{x^2}{2} - \\frac{x^3}{4} + O(x^4) = 1 - \\Omega_c T + \\frac{(\\Omega_c T)^2}{2} - O(T^3)$。\n两个极点都具有 $1 - \\Omega_c T + O(T^2)$ 的形式。它们在 $T$ 的一阶上是一致的。陈述的第一部分是正确的。\n\n“每样本衰减率”可以解释为等效的连续时间衰减常数 $\\gamma$，使得极点为 $p = e^{-\\gamma T}$。因此，$\\gamma = -\\frac{\\ln p}{T}$。\n-   对于冲激不变法：$\\gamma_{\\mathrm{II}} = -\\frac{\\ln(p_{\\mathrm{II}})}{T} = -\\frac{\\ln(e^{-\\Omega_c T})}{T} = \\frac{\\Omega_c T}{T} = \\Omega_c$。这个速率是精确的。\n-   对于双线性变换：$\\gamma_{\\mathrm{BL}} = -\\frac{\\ln(p_{\\mathrm{BL}})}{T} = -\\frac{1}{T} \\ln\\left(\\frac{1 - \\Omega_c T/2}{1 + \\Omega_c T/2}\\right) = \\frac{1}{T} \\ln\\left(\\frac{1 + \\Omega_c T/2}{1 - \\Omega_c T/2}\\right)$。\n对于小的 $y$，使用级数展开 $\\ln(\\frac{1+y}{1-y}) = 2y + \\frac{2y^3}{3} + O(y^5)$，并设 $y = \\frac{\\Omega_c T}{2}$：\n$$\\gamma_{\\mathrm{BL}} = \\frac{1}{T} \\left( 2\\left(\\frac{\\Omega_c T}{2}\\right) + \\frac{2}{3}\\left(\\frac{\\Omega_c T}{2}\\right)^3 + O(T^5) \\right) = \\frac{1}{T} \\left( \\Omega_c T + \\frac{(\\Omega_c T)^3}{12} + O(T^5) \\right) = \\Omega_c + \\frac{\\Omega_c^3}{12}T^2 + O(T^4)$$\n衰减率之差为 $\\gamma_{\\mathrm{BL}} - \\gamma_{\\mathrm{II}} = \\frac{\\Omega_c^3}{12}T^2 + O(T^4)$。差值中的第一个非零项是 $T^2$ 阶的。因此，速率在 $T^2$ 阶上存在差异。陈述的第二部分也是正确的。该分析量化了双线性变换众所周知的频率畸变效应。\n\n关于D的结论：**正确**。\n\n**E. 双线性变换保持冲激响应下的面积；因此，对于任何 $T>0$，$\\lim_{n\\to\\infty}s_{\\mathrm{BL}}[n]=\\dfrac{\\Omega_{c}T}{1-e^{-\\Omega_{c}T}}$。**\n\n对于连续时间系统，“冲激响应下的面积”是 $\\int_{-\\infty}^{\\infty} h_a(t) dt = H_a(0)$。对于离散时间系统，等效的是其冲激响应样本的总和，即 $\\sum_{n=-\\infty}^{\\infty} h[n] = H(1)$。双线性变换确保 $H_{\\mathrm{BL}}(1) = H_a(0)$，所以从这个意义上说，它“保持了面积”。这第一部分是正确的。\n\n结论，“因此，对于任何 $T>0$，$\\lim_{n\\to\\infty}s_{\\mathrm{BL}}[n]=\\dfrac{\\Omega_{c}T}{1-e^{-\\Omega_{c}T}}$”，是不正确的。如在对陈述A的分析中所确立的，双线性变换的稳态阶跃响应是 $\\lim_{n\\to\\infty}s_{\\mathrm{BL}}[n] = H_{\\mathrm{BL}}(1) = H_a(0) = 1$。表达式 $\\dfrac{\\Omega_{c}T}{1-e^{-\\Omega_{c}T}}$ 是冲激不变滤波器的稳态值，即 $s_{\\mathrm{II,ss}}$。该陈述错误地将双线性变换的稳态值等同于冲激不变滤波器的稳态值。\n\n关于E的结论：**不正确**。", "answer": "$$\\boxed{ABD}$$", "id": "2852396"}, {"introduction": "一个理论上完美的滤波器在实际应用中可能因为有限精度运算而失效。最后的这个练习将理论与实现联系起来，探讨滤波器系数中的微小误差（在硬件实现中不可避免）如何导致极点迁移，甚至可能破坏系统稳定性。你将亲手实现一个量化这种灵敏度的方法，这是设计稳健的真实世界系统的一项关键技能。[@problem_id:2852435]", "problem": "考虑一个单输入单输出离散时间线性时不变系统，其经过模数频率变换后的分母由复变量 $z$ 在单项式基下的首一多项式表示，\n$$\np(z) = \\sum_{k=0}^{n} a_k z^k,\\quad a_n = 1,\n$$\n该多项式具有复数根 $\\{r_i\\}_{i=1}^n$（即极点），其中 $n \\in \\mathbb{N}$。假设实现的系数 $\\{\\tilde{a}_k\\}$ 受到加性实现误差的影响，满足逐分量的绝对值界限\n$$\n|\\delta a_k| \\le \\varepsilon \\quad \\text{for all } k \\in \\{0,\\dots,n\\}, \\quad \\text{where } \\delta a_k := \\tilde{a}_k - a_k,\n$$\n对于给定的 $\\varepsilon \\ge 0$。您需要分析一阶根敏感度，并预测相对于单位圆的潜在极点迁移。\n\n仅从以下基本定义出发：\n- 多项式及其导数的定义 $p'(z) = \\sum_{k=1}^{n} k a_k z^{k-1}$，\n- 单复变量的一阶泰勒展开，\n推导并实现一种方法，用以计算每个满足 $p'(r_i) \\neq 0$ 的单根 $r_i$ 的一阶绝对条件数\n$$\n\\kappa_i := \\frac{\\sum_{k=0}^{n} |r_i|^k}{|p'(r_i)|},\n$$\n该条件数在给定的逐分量系数误差模型下提供了扰动界限\n$$\n|\\delta r_i| \\le \\varepsilon \\,\\kappa_i,\n$$\n对于 $p'(r_i) = 0$ 的重根（包括重极点），定义 $\\kappa_i := +\\infty$。\n\n使用这些条件数，通过保守测试来预测可能的极点跨越单位圆的迁移\n$$\n|r_i| + \\varepsilon \\,\\kappa_i \\ge 1,\n$$\n该测试表明存在与模型一致的系数扰动，可将极点 $r_i$ 移动到单位圆上或单位圆外。\n\n您的程序必须：\n- 不接受任何输入，并使用下述固定的测试套件。\n- 对于每个测试用例，计算 $p(z)$ 的所有根 $\\{r_i\\}$、根据上述公式计算相应的 $\\{\\kappa_i\\}$、最大条件数 $\\max_i \\kappa_i$ 以及布尔指标\n$$\n\\text{any\\_cross} := \\bigvee_{i=1}^{n} \\left( |r_i| + \\varepsilon \\,\\kappa_i \\ge 1 \\right).\n$$\n- 为每个测试用例输出一个结果，格式为双元素列表 $[\\text{kappa\\_max}, \\text{any\\_cross}]$，其中 $\\text{kappa\\_max}$ 是四舍五入到六位小数的最大条件数，$\\text{any\\_cross}$ 是一个布尔值。\n\n实现说明：\n- 将 $p(z)$ 视为按上文所述的 $z$ 的升幂排列。如果您的数值求根程序期望降幂排列，您必须在内部转换格式，但不能改变条件数的数学定义，因为该定义对 $p$ 和 $p'$ 使用了升幂表示。\n- 为保证数值鲁棒性，使用一个小的阈值来检测 $p'(r_i) = 0$；如果 $|p'(r_i)|$ 在数值上低于某个阈值，则设置 $\\kappa_i := +\\infty$。\n- 问题描述中出现的角度不被您的程序直接使用；所有系数均以数值形式提供。不需要任何物理单位或角度单位。\n\n测试套件：\n- 情况 A（良阻尼共轭复极点，2次）：\n  - 升幂系数 $[a_0, a_1, a_2] = [\\,$0.64$, \\,$-0.9404564037$, \\,$1.0$\\,]$。\n  - 误差界 $\\varepsilon = $1.0e-6$。\n- 情况 B（近单位圆共轭复极点，2次）：\n  - 升幂系数 $[a_0, a_1, a_2] = [\\,$0.9801$, \\,$-0.3097402407$, \\,$1.0$\\,]$。\n  - 误差界 $\\varepsilon = $2.0e-2$。\n- 情况 C（二重实极点，2次）：\n  - 升幂系数 $[a_0, a_1, a_2] = [\\,$0.9604$, \\,$-1.96$, \\,$1.0$\\,]$。\n  - 误差界 $\\varepsilon = $1.0e-6$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，顺序与上文相同。每个元素本身必须是一个双元素列表 $[\\text{kappa\\_max}, \\text{any\\_cross}]$，其中 $\\text{kappa\\_max}$ 是一个四舍五入到六位小数的浮点数，$\\text{any\\_cross}$ 是一个布尔值。例如，一个有效的格式为\n$$\n[[\\text{float},\\ \\text{bool}],\\ [\\text{float},\\ \\text{bool}],\\ [\\text{float},\\ \\text{bool}]].\n$$", "solution": "该问题要求推导多项式根的一阶扰动界，并应用此界来评估离散时间系统中的极点稳定性。推导过程从微积分的基本原理出发。\n\n设一个多项式定义为 $p(z) = \\sum_{k=0}^{n} a_k z^k$。其系数的扰动 $\\tilde{a}_k = a_k + \\delta a_k$ 会产生一个扰动后的多项式 $\\tilde{p}(z) = p(z) + \\delta p(z)$，其中 $\\delta p(z) = \\sum_{k=0}^{n} \\delta a_k z^k$。如果 $r$ 是 $p(z)$ 的一个单根，即 $p(r)=0$ 且 $p'(r) \\neq 0$，那么扰动后多项式的相应根 $\\tilde{r} = r + \\delta r$ 满足 $\\tilde{p}(\\tilde{r})=0$。这等价于方程 $p(r+\\delta r) + \\delta p(r+\\delta r) = 0$。\n\n对 $p(z)$ 在点 $z=r$ 附近进行一阶泰勒展开，得到 $p(r+\\delta r) \\approx p(r) + p'(r)\\delta r$。由于 $r$ 是一个根，所以 $p(r)=0$，因此上式简化为 $p(r+\\delta r) \\approx p'(r)\\delta r$。对于扰动项 $\\delta p(z)$ 本身是一个小量，我们进行一阶近似 $\\delta p(r+\\delta r) \\approx \\delta p(r) = \\sum_{k=0}^{n} \\delta a_k r^k$。\n\n将这些近似值代入根的条件中，得到一阶关系：\n$$\np'(r)\\delta r + \\sum_{k=0}^{n} \\delta a_k r^k \\approx 0\n$$\n解出根的扰动 $\\delta r$，我们得到：\n$$\n\\delta r \\approx - \\frac{\\sum_{k=0}^{n} \\delta a_k r^k}{p'(r)}\n$$\n为了找到其模 $|\\delta r|$ 的一个界，我们对上述表达式应用三角不等式：\n$$\n|\\delta r| \\approx \\left| \\frac{\\sum_{k=0}^{n} \\delta a_k r^k}{p'(r)} \\right| \\le \\frac{\\sum_{k=0}^{n} |\\delta a_k r^k|}{|p'(r)|} = \\frac{\\sum_{k=0}^{n} |\\delta a_k| |r|^k}{|p'(r)|}\n$$\n根据逐分量误差模型 $|\\delta a_k| \\le \\varepsilon$，我们可以将其代入不等式，以建立最终的扰动界：\n$$\n|\\delta r| \\le \\varepsilon \\frac{\\sum_{k=0}^{n} |r|^k}{|p'(r)|} = \\varepsilon \\,\\kappa\n$$\n其中 $\\kappa_i := \\frac{\\sum_{k=0}^{n} |r_i|^k}{|p'(r_i)|}$ 是根 $r_i$ 的绝对条件数。此推导验证了问题陈述中给出的公式。对于 $p'(r_i)=0$ 的重根，分母为零，表明一阶敏感度为无穷大。因此，在这种情况下，将条件数 $\\kappa_i$ 定义为 $+\\infty$ 是正确的。\n\n实现算法基于这些原理设计。\n首先，对于每个测试用例，定义多项式系数 $\\{a_k\\}$，这些系数是按 $z$ 的升幂提供的。由于 `numpy` 库中的数值例程期望系数按降幂顺序排列，因此在使用前需要将系数列表反转。\n其次，使用 `numpy.roots` 函数计算多项式 $p(z)$ 的根 $\\{r_i\\}$。\n第三，为每个根 $r_i$ 计算其条件数 $\\kappa_i$。这涉及到计算导数 $p'(r_i)$。导数多项式通过 `numpy.polyder` 以编程方式获得，该函数对降幂系数表示进行操作。一个关键的数值考虑是重根的检测。如果导数的模 $|p'(r_i)|$ 小于一个小的数值阈值（此处选择 $10^{-12}$），则根 $r_i$ 被视为重根。在这种情况下，$\\kappa_i$ 被设置为无穷大（`numpy.inf`）。对于单根，$\\kappa_i$ 使用推导出的公式计算。分子 $\\sum_{k=0}^{n} |r_i|^k$ 通过直接求和计算，以确保数值稳定性，特别是对于靠近单位圆的根。\n第四，使用保守测试 $|r_i| + \\varepsilon \\kappa_i \\ge 1$ 评估每个根跨越单位圆的潜在极点迁移。该测试的结果是一个布尔值。然后，通过对多项式所有根的这些单个结果进行逻辑或运算，来确定总的 `any_cross` 标志。\n最后，从计算出的条件数集合中确定最大条件数 $\\kappa_{\\max} = \\max_i \\kappa_i$。对 $[\\kappa_{\\max}, \\text{any\\_cross}]$ 对按要求进行格式化，其中 $\\kappa_{\\max}$ 四舍五入到六位小数。对所有指定的测试用例重复此过程，以生成最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the root sensitivity problem for a fixed suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Well-damped complex-conjugate poles\n        {'coeffs': [0.64, -0.9404564037, 1.0], 'eps': 1.0e-6},\n        # Case B: Near-unit-circle complex-conjugate poles\n        {'coeffs': [0.9801, -0.3097402407, 1.0], 'eps': 2.0e-2},\n        # Case C: Double real pole\n        {'coeffs': [0.9604, -1.96, 1.0], 'eps': 1.0e-6},\n    ]\n\n    results = []\n    \n    # Threshold for detecting a zero derivative (multiple root)\n    DERIVATIVE_ZERO_THRESHOLD = 1e-12\n\n    for case in test_cases:\n        a = case['coeffs']\n        eps = case['eps']\n        n = len(a) - 1\n\n        # The problem defines p(z) with ascending powers, but numpy functions\n        # expect coefficients in descending powers of the variable.\n        coeffs_desc = a[::-1]\n\n        # Find the roots of the polynomial.\n        roots = np.roots(coeffs_desc)\n\n        # Create polynomial objects for p(z) and its derivative p'(z).\n        # This is a robust way to handle derivative evaluation.\n        p_poly = np.poly1d(coeffs_desc)\n        p_prime_poly = np.polyder(p_poly)\n        \n        kappas = []\n        cross_flags = []\n\n        for r in roots:\n            # Evaluate the derivative at the root.\n            p_prime_r = np.polyval(p_prime_poly, r)\n            \n            if np.abs(p_prime_r) < DERIVATIVE_ZERO_THRESHOLD:\n                # For a multiple root, the condition number is infinite.\n                kappa = np.inf\n            else:\n                # Compute the numerator of the condition number formula: sum(|r|^k) for k=0 to n.\n                # Direct summation is numerically robust.\n                numerator = np.sum(np.abs(r)**np.arange(n + 1))\n                kappa = numerator / np.abs(p_prime_r)\n\n            kappas.append(kappa)\n            \n            # Perform the conservative pole migration test.\n            # Python's float handles infinity correctly in comparisons.\n            if np.abs(r) + eps * kappa >= 1.0:\n                cross_flags.append(True)\n            else:\n                cross_flags.append(False)\n        \n        # Determine the maximum condition number and if any pole might cross.\n        kappa_max = np.max(kappas)\n        any_cross = any(cross_flags)\n        \n        # Format the result for this test case as a string.\n        # np.inf is a float; round(np.inf, 6) is still np.inf.\n        # The str representation of np.inf is 'inf'.\n        if kappa_max == np.inf:\n            formatted_kappa = 'inf'\n        else:\n            # Round to six decimal places, ensuring trailing zeros if needed.\n            formatted_kappa = f\"{kappa_max:.6f}\"\n\n        # Boolean to lowercase string 'true'/'false'.\n        formatted_any_cross = str(any_cross).lower()\n        \n        results.append(f\"[{formatted_kappa}, {formatted_any_cross}]\")\n\n    # Final output must be a single line in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2852435"}]}