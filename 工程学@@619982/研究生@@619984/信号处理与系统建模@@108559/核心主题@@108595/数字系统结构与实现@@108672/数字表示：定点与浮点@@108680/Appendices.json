{"hands_on_practices": [{"introduction": "在数字信号处理中，定点表示法因其硬件效率和可预测性而至关重要。本练习将引导你从第一性原理出发，推导一个有符号定点数系统的关键参数——分辨率 $ \\Delta $ 和最大可表示绝对值 $ V_{\\text{abs,max}} $。通过这个过程，你将深刻理解在总位数 $ W $ 固定的情况下，设计者必须在溢出风险和量化精度之间做出的根本性权衡 [@problem_id:2887760]。", "problem": "在一个信号处理链中，使用了一种均匀缩放的有符号定点表示法。该表示法是二进制补码形式，有 $m$ 个整数位（包括符号位）和 $n$ 个小数位，总字长为 $W=m+n$。每个比特位的位置具有与二进制补码一致的二进制权重：符号位的权重为 $-2^{m-1}$，其余整数位的权重为 $2^{m-2},\\dots,2^{0}$，小数位的权重为 $2^{-1},2^{-2},\\dots,2^{-n}$。量化方式为舍入到最近的可表示值（中间步进），并且，除非另有明确说明，否则假定算术运算不会饱和或回绕；相反，我们关心的是实值信号是否会超出可表示的集合（溢出事件）。\n\n从这些定义出发：\n1) 推导分辨率 $\\Delta$，其定义为两个相邻可表示数之间的最小正差。\n2) 推导最大可表示绝对值 $V_{\\text{abs,max}}=\\max\\{|x|:x\\text{ is representable}\\}$，并说明可表示值的闭区间。\n\n现在假设输入信号的幅值有界，满足 $|x(t)|\\leq X_{\\max}$，且总字长 $W$ 是固定的。仅使用二进制权重的基本原理和四舍五入量化的高分辨率模型，在 $m+n=W$ 的约束下，随着整数-小数位划分 $(m,n)$ 的变化，论证溢出和量化误差之间的权衡。特别是，推导有界信号不会发生溢出时 $(m,n)$ 需满足的条件，并解释均方量化误差如何通过 $\\Delta$ 随 $(m,n)$ 变化。\n\n将你的最终答案表示为有序对 $\\left(\\Delta,\\,V_{\\text{abs,max}}\\right)$ 的精确符号形式。不要四舍五入。", "solution": "首先必须对问题陈述进行严格的验证过程。\n\n步骤 1：提取已知条件。\n- 表示法：均匀缩放、有符号定点、二进制补码。\n- 字长：$W=m+n$。\n- 整数位：$m$（包括符号位）。\n- 小数位：$n$。\n- 位权重：符号位权重为 $-2^{m-1}$，其余整数位权重为 $2^{m-2}, \\dots, 2^{0}$，小数位权重为 $2^{-1}, 2^{-2}, \\dots, 2^{-n}$。\n- 量化：舍入到最近的可表示值（中间步进）。\n- 溢出：当实值信号超出可表示集合时发生。不考虑饱和和回绕。\n- 输入信号：有界，满足 $|x(t)| \\le X_{\\max}$。\n- 约束：$W$ 是固定的总字长。\n\n步骤 2：使用提取的已知条件进行验证。\n该问题具有科学依据且提法恰当。它提出了一个数字信号处理中关于定点数系统属性的标准、基本情景。所提供的二进制补码定点表示法的定义是标准的且内部一致。该问题是客观的，使用了精确的技术语言。它没有违反任何科学原理，不基于错误的前提，并且包含了进行严格推导所需的所有必要信息。该问题与信号处理中的数字表示主题直接相关。所提出的问题结构清晰，可以基于基本原理推导出唯一的答案。该问题不包含验证标准中列出的任何缺陷。\n\n步骤 3：结论与行动。\n问题被判定为有效。将提供完整的解答。\n\n在这种定点格式中，一个数 $x$ 由一组 $W=m+n$ 个比特表示，记为 $(b_{m-1}, b_{m-2}, \\dots, b_0, b_{-1}, \\dots, b_{-n})$，其中 $b_i \\in \\{0, 1\\}$。该数的值由其比特的加权和给出：\n$$ x = -b_{m-1}2^{m-1} + \\sum_{i=0}^{m-2} b_i 2^i + \\sum_{j=1}^{n} b_{-j} 2^{-j} $$\n\n1) 分辨率 $\\Delta$ 的推导。\n分辨率 $\\Delta$ 定义为两个相邻可表示数之间的最小正差。这个差对应于最低有效位（LSB）的变化。在这种表示法中，LSB 是权重最小的比特，即权重为 $2^{-n}$ 的 $b_{-n}$。将此位从 $0$ 变为 $1$，而所有其他位保持不变，会使该数的值增加 $2^{-n}$。任何其他的比特变化都将导致至少这么大的数值变化。因此，分辨率就是 LSB 的权重。\n$$ \\Delta = 2^{-n} $$\n\n2) $V_{\\text{abs,max}}$ 和可表示范围的推导。\n为了确定可表示值的范围，我们必须找到可以形成的最大值和最小值。\n\n最大值 $x_{\\max}$ 出现在符号位 $b_{m-1}$ 为 $0$ 且所有其他位都为 $1$ 时：\n$$ x_{\\max} = -0 \\cdot 2^{m-1} + \\sum_{i=0}^{m-2} 1 \\cdot 2^i + \\sum_{j=1}^{n} 1 \\cdot 2^{-j} $$\n第一个和是整数部分的几何级数：$\\sum_{i=0}^{m-2} 2^i = \\frac{2^{m-1}-1}{2-1} = 2^{m-1}-1$。\n第二个和是小数部分的几何级数：$\\sum_{j=1}^{n} 2^{-j} = \\frac{2^{-1}(1-(2^{-1})^n)}{1-2^{-1}} = 1-2^{-n}$。\n结合这些结果：\n$$ x_{\\max} = (2^{m-1}-1) + (1-2^{-n}) = 2^{m-1} - 2^{-n} $$\n\n最小值 $x_{\\min}$ 在二进制补码表示中出现在符号位 $b_{m-1}$ 为 $1$ 且所有其他位都为 $0$ 时：\n$$ x_{\\min} = -1 \\cdot 2^{m-1} + \\sum_{i=0}^{m-2} 0 \\cdot 2^i + \\sum_{j=1}^{n} 0 \\cdot 2^{-j} = -2^{m-1} $$\n\n因此，可表示值的闭区间为 $[x_{\\min}, x_{\\max}] = [-2^{m-1}, 2^{m-1} - 2^{-n}]$。\n\n最大可表示绝对值 $V_{\\text{abs,max}}$ 是此区间中数值的绝对值的最大值。我们比较 $x_{\\min}$ 和 $x_{\\max}$ 的量值：\n$$ |x_{\\min}| = |-2^{m-1}| = 2^{m-1} $$\n$$ |x_{\\max}| = |2^{m-1} - 2^{-n}| = 2^{m-1} - 2^{-n} $$\n由于 $n \\ge 0$，项 $2^{-n}$ 是正的（假设 $n$ 是有限的），这意味着 $|x_{\\max}| < |x_{\\min}|$。\n因此，最大可表示绝对值是最大负数的量值：\n$$ V_{\\text{abs,max}} = 2^{m-1} $$\n\n3) 溢出与量化误差之间的权衡。\n总字长 $W = m+n$ 是固定的。\n\n溢出：如果输入信号 $x(t)$ 超出可表示范围 $[-2^{m-1}, 2^{m-1}-2^{-n}]$，则会发生溢出事件。鉴于输入信号有界，满足 $|x(t)| \\le X_{\\max}$，这意味着其值位于区间 $[-X_{\\max}, X_{\\max}]$ 内。为防止溢出，整个信号区间必须包含在可表示范围内：\n$$ [-X_{\\max}, X_{\\max}] \\subseteq [-2^{m-1}, 2^{m-1}-2^{-n}] $$\n这需要满足两个条件：\n$$ X_{\\max} \\le 2^{m-1}-2^{-n} \\quad \\text{和} \\quad -X_{\\max} \\ge -2^{m-1} $$\n第二个条件等价于 $X_{\\max} \\le 2^{m-1}$。第一个条件 $X_{\\max} \\le 2^{m-1}-2^{-n}$ 更为严格。因此，保证不发生溢出的关于 $(m,n)$ 的严格条件是：\n$$ X_{\\max} \\le 2^{m-1} - 2^{-n} $$\n为了容纳具有较大最大振幅 $X_{\\max}$ 的信号，必须选择足够大的整数位数 $m$。较大的 $m$ 会扩展表示的动态范围，从而降低溢出的风险。\n\n量化误差：通过舍入到最近可表示值进行的量化会引入一个误差 $e_q$，其有界于 $|e_q| \\le \\frac{\\Delta}{2}$。高分辨率量化模型假设 $e_q$ 是在区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 上均匀分布的随机变量。均方误差（MSE），或称量化噪声功率，是此分布的方差：\n$$ \\sigma_q^2 = E[e_q^2] = \\int_{-\\Delta/2}^{\\Delta/2} e^2 \\frac{1}{\\Delta} de = \\frac{1}{\\Delta} \\left[ \\frac{e^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{\\Delta^2}{12} $$\n代入 $\\Delta = 2^{-n}$，均方误差为：\n$$ \\sigma_q^2 = \\frac{(2^{-n})^2}{12} = \\frac{2^{-2n}}{12} $$\n为了最小化量化误差，$\\sigma_q^2$ 必须很小，这要求 $\\Delta$ 很小。这可以通过增加小数位数 $n$ 来实现。\n\n权衡：约束条件是 $m+n=W$，其中 $W$ 是常数。\n- 为了防止给定振幅 $X_{\\max}$ 的信号发生溢出，必须为 $m$ 分配足够的比特数。增加 $m$ 会增大可表示的动态范围，从而降低溢出的风险。\n- 为了提高精度（即减少量化噪声），必须为 $n$ 分配更多的比特数。增加 $n$ 会减小步长 $\\Delta$，从而降低量化误差功率 $\\sigma_q^2$。\n由于 $m$ 和 $n$ 通过固定的和 $W$ 相互耦合，这两个目标是直接冲突的。增加 $m$ 来扩展动态范围会迫使 $n$ 减小，而这会通过增大 $\\Delta$ 及其导致的 $\\sigma_q^2$ 来降低精度。反之，增加 $n$ 来提高精度会迫使 $m$ 减小，而这会缩小动态范围并增加溢出的可能性。这代表了定点系统设计中动态范围和精度之间的基本权衡。对于给定的总字长 $W$，工程师必须选择一个 $(m,n)$ 的划分，既能提供足够的动态范围以避免预期信号电平的溢出，又能为应用提供可接受的精度。", "answer": "$$\n\\boxed{\\begin{pmatrix} 2^{-n} & 2^{m-1} \\end{pmatrix}}\n$$", "id": "2887760"}, {"introduction": "与定点系统不同，浮点表示法提供了巨大的动态范围，使其成为科学计算和许多信号处理应用的首选。本练习将深入探讨 IEEE 754 标准的内部结构，要求你计算 `binary32` 和 `binary64` 格式所能表示的最小和最大正规化数。这个练习不仅能帮助你量化这些格式的动态范围，还能让你直观地感受到浮点数在表示极大和极小数值方面的强大能力 [@problem_id:2887751]。", "problem": "一个数字信号处理系统使用电气与电子工程师协会 (IEEE) 754 二进制浮点格式作为其建模连续时间信号的唯一数值表示。在这些格式中，一个有限规格化浮点数由一个带符号的有效数和一个指数表示，其中有效数有一个隐含的前导比特，指数则采用偏置表示法。具体来说，对于一个具有 $f$ 个小数位和 $w$ 个指数位的格式，其有效数 $m$ 满足 $1 \\leq m < 2$，指数字段使用偏置 $B$ 进行解释，规格化数的无偏指数 $E$ 的范围是一个连续区间，其中排除了全零和全一的指数字段。最大的规格化数使用最大的无偏指数和通过将所有 $f$ 个小数位设为 1 所能获得的最大有效数 $m$。最小的正规格化数使用最小的无偏指数和最小的有效数 $m = 1$。\n\n考虑 `binary32` 和 `binary64` 格式：\n- 对于 `binary32`：有 $1$ 个符号位，$w = 8$ 个指数位，偏置 $B_{32} = 127$，以及 $f = 23$ 个小数位。\n- 对于 `binary64`：有 $1$ 个符号位，$w = 11$ 个指数位，偏置 $B_{64} = 1023$，以及 $f = 52$ 个小数位。\n\n仅使用这些结构性事实和 IEEE 754 标准的第一性原理（规格化有效数的隐含前导 $1$、偏置指数，以及排除非规格化数和特殊值），完成以下任务：\n1. 推导 `binary32` 和 `binary64` 格式中最小的正有限规格化数和最大的有限规格化数，并用 $2$ 的幂以闭合形式表示。\n2. 将幅度动态范围（单位：分贝）定义为 $20 \\log_{10}(x_{\\max}/x_{\\min})$，其中 $x_{\\max}$ 和 $x_{\\min}$ 分别表示该格式中可表示的最大和最小正有限规格化幅度。推导 `binary32` 和 `binary64` 的幅度动态范围（单位：分贝）的精确闭合形式表达式。\n3. 假设一个功率量与幅度的平方成正比，将功率动态范围（单位：分贝）定义为 $10 \\log_{10}(P_{\\max}/P_{\\min})$，其中 $P \\propto x^{2}$。推导 `binary32` 和 `binary64` 的功率动态范围（单位：分贝）的精确闭合形式表达式，并将其与幅度动态范围进行比较。\n\n将所有最终表达式用 $2$ 的幂和 $\\log_{10}(\\cdot)$ 以精确的闭合形式表示，无需进行数值近似。在最终的方框答案中不要包含任何单位。将您的最终答案按顺序 $[x_{\\min}^{(32)},\\, x_{\\max}^{(32)},\\, x_{\\min}^{(64)},\\, x_{\\max}^{(64)},\\, \\mathrm{DR}_{\\mathrm{amp}}^{(32)}\\ \\mathrm{(dB)},\\, \\mathrm{DR}_{\\mathrm{amp}}^{(64)}\\ \\mathrm{(dB)},\\, \\mathrm{DR}_{\\mathrm{pow}}^{(32)}\\ \\mathrm{(dB)},\\, \\mathrm{DR}_{\\mathrm{pow}}^{(64)}\\ \\mathrm{(dB)}]$ 以单行矩阵的形式呈现。", "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n首先，我们逐字提取已知条件：\n- 一个数字信号处理系统使用 IEEE 754 二进制浮点格式。\n- 一个有限规格化浮点数由一个带符号的有效数和一个指数表示，其中有效数有一个隐含的前导比特，指数则采用偏置表示法。\n- 对于一个具有 $f$ 个小数位和 $w$ 个指数位的格式，其有效数 $m$ 满足 $1 \\leq m < 2$。\n- 指数字段使用偏置 $B$ 进行解释。\n- 规格化数的无偏指数 $E$ 的范围是一个连续区间，其中排除了全零和全一的指数字段。\n- 最大的规格化数使用最大的无偏指数和最大的有效数 $m$（所有 $f$ 个小数位都为 $1$）。\n- 最小的正规格化数使用最小的无偏指数和最小的有效数 $m=1$。\n- 对于 `binary32`：$1$ 个符号位，$w = 8$ 个指数位，偏置 $B_{32} = 127$，以及 $f = 23$ 个小数位。\n- 对于 `binary64`：$1$ 个符号位，$w = 11$ 个指数位，偏置 $B_{64} = 1023$，以及 $f = 52$ 个小数位。\n- 任务1：推导 `binary32` 和 `binary64` 的最小正规格化数 ($x_{\\min}$) 和最大有限规格化数 ($x_{\\max}$)。\n- 任务2：为 `binary32` 和 `binary64` 定义并推导幅度动态范围 $\\mathrm{DR}_{\\mathrm{amp}} = 20 \\log_{10}(x_{\\max}/x_{\\min})$。\n- 任务3：定义并推导功率动态范围 $\\mathrm{DR}_{\\mathrm{pow}} = 10 \\log_{10}(P_{\\max}/P_{\\min})$（其中 $P \\propto x^2$），并与幅度动态范围进行比较。\n\n问题被确定为有效。这是一个基于 IEEE 754 浮点运算标准既定原则的良构问题。所有必要的参数（$w$、$f$、$B$）和定义均已提供，所提出的问题明确无误，可以导出一个唯一的、可验证的解。该问题在科学上是合理的、客观的、自包含的。我们将着手进行推导。\n\n一个有限规格化浮点数 $x$ 由以下公式表示：\n$$x = (-1)^s \\times m \\times 2^E$$\n其中 $s$ 是符号位（正数为 $0$，负数为 $1$），$m$ 是有效数，$E$ 是无偏指数。\n\n规格化数的有效数 $m$ 有一个隐含的前导位 $1$。对于 $f$ 个小数位 $b_{f-1}b_{f-2}...b_0$，有效数由下式给出：\n$$m = 1 + \\sum_{i=1}^{f} b_{i} 2^{-i}$$\n规格化数的有效数范围是 $1 \\le m < 2$。\n\n无偏指数 $E$ 是从偏置指数字段 $e$ 计算得出的，它是一个 $w$ 位的无符号整数。其关系为 $E = e - B$，其中偏置 $B = 2^{w-1}-1$。对于规格化数，指数字段 $e$ 不能是全零（$e=0$）或全一（$e=2^w-1$）。因此，$e$ 的范围是 $1 \\le e \\le 2^w-2$。\n\n**1. 最小和最大规格化数的推导**\n\n为了找到最小的正规格化数 $x_{\\min}$，我们将符号位 $s$ 设置为 $0$，并使用最小的可能有效数和最小的可能无偏指数。\n- 最小有效数 ($m_{\\min}$): 这种情况发生在所有小数位都为 $0$ 时。\n  $$m_{\\min} = 1 + \\sum_{i=1}^{f} 0 \\cdot 2^{-i} = 1$$\n- 最小无偏指数 ($E_{\\min}$): 这对应于最小的偏置指数值 $e_{\\min}=1$。\n  $$E_{\\min} = e_{\\min} - B = 1 - B$$\n因此，$x_{\\min}$ 的通用表达式为：\n$$x_{\\min} = 1 \\times 2^{1-B}$$\n\n对于 **`binary32`**：$f=23$，$B_{32}=127$。\n$$x_{\\min}^{(32)} = 2^{1-127} = 2^{-126}$$\n对于 **`binary64`**：$f=52$，$B_{64}=1023$。\n$$x_{\\min}^{(64)} = 2^{1-1023} = 2^{-1022}$$\n\n为了找到最大的有限规格化数 $x_{\\max}$，我们将 $s$ 设置为 $0$，并使用最大的可能有效数和最大的可能无偏指数。\n- 最大有效数 ($m_{\\max}$): 这种情况发生在所有 $f$ 个小数位都为 $1$ 时。\n  $$m_{\\max} = 1 + \\sum_{i=1}^{f} 1 \\cdot 2^{-i} = 1 + (1 - 2^{-f}) = 2 - 2^{-f}$$\n- 最大无偏指数 ($E_{\\max}$): 这对应于最大的偏置指数值 $e_{\\max}=2^w-2$。\n  $$E_{\\max} = e_{\\max} - B = (2^w-2) - (2^{w-1}-1) = 2^w - 2^{w-1} - 1 = 2^{w-1} - 1 = B$$\n因此，$x_{\\max}$ 的通用表达式为：\n$$x_{\\max} = (2 - 2^{-f}) \\times 2^B$$\n\n对于 **`binary32`**：$f=23$，$B_{32}=127$。\n$$x_{\\max}^{(32)} = (2 - 2^{-23}) \\times 2^{127}$$\n对于 **`binary64`**：$f=52$，$B_{64}=1023$。\n$$x_{\\max}^{(64)} = (2 - 2^{-52}) \\times 2^{1023}$$\n\n**2. 幅度动态范围的推导**\n\n幅度动态范围（以分贝为单位）由 $\\mathrm{DR}_{\\mathrm{amp}} = 20 \\log_{10}(x_{\\max}/x_{\\min})$ 给出。我们首先计算比率 $x_{\\max}/x_{\\min}$：\n$$\\frac{x_{\\max}}{x_{\\min}} = \\frac{(2 - 2^{-f}) \\times 2^B}{1 \\times 2^{1-B}} = (2 - 2^{-f}) \\times 2^{B - (1-B)} = (2 - 2^{-f}) \\times 2^{2B-1}$$\n现在，我们将其代入 $\\mathrm{DR}_{\\mathrm{amp}}$ 的公式中：\n$$\\mathrm{DR}_{\\mathrm{amp}} = 20 \\log_{10}\\left( (2 - 2^{-f}) \\times 2^{2B-1} \\right) = 20 \\left( \\log_{10}(2 - 2^{-f}) + \\log_{10}(2^{2B-1}) \\right)$$\n$$\\mathrm{DR}_{\\mathrm{amp}} = 20 \\left( \\log_{10}(2 - 2^{-f}) + (2B-1) \\log_{10}(2) \\right)$$\n\n对于 **`binary32`**：$f=23$，$B_{32}=127$。指数乘数为 $2B_{32}-1 = 2(127)-1 = 254-1 = 253$。\n$$\\mathrm{DR}_{\\mathrm{amp}}^{(32)} = 20 \\left( \\log_{10}(2 - 2^{-23}) + 253 \\log_{10}(2) \\right)$$\n对于 **`binary64`**：$f=52$，$B_{64}=1023$。指数乘数为 $2B_{64}-1 = 2(1023)-1 = 2046-1 = 2045$。\n$$\\mathrm{DR}_{\\mathrm{amp}}^{(64)} = 20 \\left( \\log_{10}(2 - 2^{-52}) + 2045 \\log_{10}(2) \\right)$$\n\n**3. 功率动态范围的推导与比较**\n\n功率动态范围（以分贝为单位）由 $\\mathrm{DR}_{\\mathrm{pow}} = 10 \\log_{10}(P_{\\max}/P_{\\min})$ 给出，其中功率 $P$ 与幅度 $x$ 的平方成正比，即对于某个常数 $k$，有 $P=kx^2$。\n比率 $P_{\\max}/P_{\\min}$ 为：\n$$\\frac{P_{\\max}}{P_{\\min}} = \\frac{k(x_{\\max})^2}{k(x_{\\min})^2} = \\left(\\frac{x_{\\max}}{x_{\\min}}\\right)^2$$\n将此代入 $\\mathrm{DR}_{\\mathrm{pow}}$ 的公式中：\n$$\\mathrm{DR}_{\\mathrm{pow}} = 10 \\log_{10}\\left( \\left(\\frac{x_{\\max}}{x_{\\min}}\\right)^2 \\right) = 10 \\times 2 \\log_{10}\\left(\\frac{x_{\\max}}{x_{\\min}}\\right) = 20 \\log_{10}\\left(\\frac{x_{\\max}}{x_{\\min}}\\right)$$\n经检查，这与幅度动态范围的定义完全相同。\n$$\\mathrm{DR}_{\\mathrm{pow}} = \\mathrm{DR}_{\\mathrm{amp}}$$\n因此，这两种格式的功率动态范围分别等于其各自的幅度动态范围。\n\n对于 **`binary32`**:\n$$\\mathrm{DR}_{\\mathrm{pow}}^{(32)} = \\mathrm{DR}_{\\mathrm{amp}}^{(32)} = 20 \\left( \\log_{10}(2 - 2^{-23}) + 253 \\log_{10}(2) \\right)$$\n对于 **`binary64`**:\n$$\\mathrm{DR}_{\\mathrm{pow}}^{(64)} = \\mathrm{DR}_{\\mathrm{amp}}^{(64)} = 20 \\left( \\log_{10}(2 - 2^{-52}) + 2045 \\log_{10}(2) \\right)$$\n\n比较结果是，对于一个与幅度平方成正比的量，其以分贝为单位的功率动态范围完全等于以分贝为单位的幅度动态范围。这是对数性质的直接结果。\n\n我们汇编最终答案所需的八个表达式。\n- $x_{\\min}^{(32)} = 2^{-126}$\n- $x_{\\max}^{(32)} = (2-2^{-23}) \\times 2^{127}$\n- $x_{\\min}^{(64)} = 2^{-1022}$\n- $x_{\\max}^{(64)} = (2-2^{-52}) \\times 2^{1023}$\n- $\\mathrm{DR}_{\\mathrm{amp}}^{(32)} = 20 ( \\log_{10}(2 - 2^{-23}) + 253 \\log_{10}(2) )$\n- $\\mathrm{DR}_{\\mathrm{amp}}^{(64)} = 20 ( \\log_{10}(2 - 2^{-52}) + 2045 \\log_{10}(2) )$\n- $\\mathrm{DR}_{\\mathrm{pow}}^{(32)} = 20 ( \\log_{10}(2 - 2^{-23}) + 253 \\log_{10}(2) )$\n- $\\mathrm{DR}_{\\mathrm{pow}}^{(64)} = 20 ( \\log_{10}(2 - 2^{-52}) + 2045 \\log_{10}(2) )$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{-126} & (2 - 2^{-23}) \\times 2^{127} & 2^{-1022} & (2 - 2^{-52}) \\times 2^{1023} & 20(\\log_{10}(2 - 2^{-23}) + 253\\log_{10}(2)) & 20(\\log_{10}(2 - 2^{-52}) + 2045\\log_{10}(2)) & 20(\\log_{10}(2 - 2^{-23}) + 253\\log_{10}(2)) & 20(\\log_{10}(2 - 2^{-52}) + 2045\\log_{10}(2))\n\\end{pmatrix}\n}\n$$", "id": "2887751"}, {"introduction": "浮点数虽然具有宽广的动态范围，但并非没有缺陷；它带来了独特的数值稳定性挑战。这个练习旨在揭示一个常见的陷阱——“灾难性抵消” (catastrophic cancellation)，即两个几乎相等的数相减会导致精度的灾难性损失。通过分析一个具体的例子并推导出一个数值稳定的替代算法，你将学会识别并避免这类问题，这是编写可靠的科学与工程代码的一项核心技能 [@problem_id:2887738]。", "problem": "一项计算在电气和电子工程师协会（IEEE）754 浮点算术标准的 `binary64` 格式下进行，采用“向最接近的数舍入，偶数优先”的舍入模式，并且平方根是正确舍入的。回顾一下，`binary64` 的尾数（包括隐藏的前导位）具有 $p=53$ 位的固定精度。对于量级近似为 $2^{k}$ 的数，其末位单位（ULP）为 $2^{k-52}$。令 $\\operatorname{fl}(\\cdot)$ 表示一个实数运算的正确舍入后的 `binary64` 结果。\n\n考虑实数量 $r_{1}=\\sqrt{N+1}$ 和 $r_{2}=\\sqrt{N}$，其中 $N=2^{104}$。定义 `binary64` 数 $a=\\operatorname{fl}(r_{1})$ 和 $b=\\operatorname{fl}(r_{2})$。\n\n(i) 仅使用上述定义以及 ULP 间距和向最接近数舍入的一般性质，构造出 `binary64` 数 $a$ 和 $b$ 的具体值，并证明它们的减法表现出灾难性抵消，即 $\\operatorname{fl}(a-b)$ 无法解析出真实的差值 $r_{1}-r_{2}$。\n\n(ii) 为了量化减法中有效位的损失，定义损失指数\n$$\nK \\triangleq \\left\\lfloor \\log_{2}\\!\\left(\\frac{M}{D}\\right)\\right\\rfloor,\n$$\n其中 $M=\\max\\{|r_{1}|,|r_{2}|\\}$ 且 $D=|r_{1}-r_{2}|$。对于上面指定的 $N$，精确计算 $K$ 的值。\n\n(iii) 推荐并论证一种计算 $r_{1}-r_{2}$ 的数学等价重构形式，该形式能在 `binary64` 中避免灾难性抵消。请从第一性原理出发推导，而非直接引用已知公式，并（从 ULP 和向最接近数舍入的角度定性地）解释为何重构后的计算是数值稳定的。\n\n最终答案只提供第 (ii) 部分的 $K$ 值。结果是一个没有物理单位的精确整数，因此不需要舍入说明。", "solution": "在尝试解答之前，将根据指定标准对问题进行验证。\n\n第 1 步：提取已知条件\n- 计算格式：电气和电子工程师协会（IEEE）754 浮点算术标准的 `binary64` 格式。\n- 舍入模式：向最接近的数舍入，偶数优先。\n- 平方根：正确舍入，记为 $\\operatorname{fl}(\\sqrt{\\cdot})$。\n- 尾数精度：$p=53$ 位（包括隐藏的前导位）。\n- 末位单位（ULP）：对于量级近似为 $2^{k}$ 的数，ULP 为 $2^{k-52}$。\n- 浮点舍入函数：$\\operatorname{fl}(\\cdot)$。\n- 实数量：$r_{1}=\\sqrt{N+1}$ 和 $r_{2}=\\sqrt{N}$。\n- 常数：$N=2^{104}$。\n- 浮点数：$a=\\operatorname{fl}(r_{1})$ 和 $b=\\operatorname{fl}(r_{2})$。\n- 损失指数定义：$K \\triangleq \\left\\lfloor \\log_{2}\\!\\left(\\frac{M}{D}\\right)\\right\\rfloor$，其中 $M=\\max\\{|r_{1}|,|r_{2}|\\}$ 且 $D=|r_{1}-r_{2}|$。\n\n第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，植根于 IEEE 754 定义的数值分析和浮点算术的标准原则。问题提法严谨 (well-posed)，提供了唯一确定所求量所需的所有参数（$N$、$p$、舍入模式）。问题陈述客观，并使用精确、正式的语言。这是一个标准的、非平凡的 (non-trivial) 问题，旨在阐释灾难性抵消现象及其缓解方法，与数值表示这一主题直接相关。检查清单中未发现任何缺陷。\n\n第 3 步：结论与行动\n问题有效。将提供一个完整的、有理有据的解答。\n\n解答过程将依次处理问题的三个部分。\n\n(i) 构造 $a$ 和 $b$ 的具体值并演示灾难性抵消。\n\n首先，我们分析量 $r_{2} = \\sqrt{N} = \\sqrt{2^{104}} = 2^{52}$。在 `binary64` 格式中，一个数表示为 $\\pm (1.f)_{2} \\times 2^{e_{\\text{biased}}-1023}$。值 $2^{52}$ 可以写成 $1.0 \\times 2^{52}$。该表示的尾数为 1 后跟全零，指数为 52。它是一个精确的二进制浮点数。因此，它在 `binary64` 中的表示是精确的：$b = \\operatorname{fl}(r_{2}) = \\operatorname{fl}(2^{52}) = 2^{52}$。\n\n接下来，我们分析量 $r_{1} = \\sqrt{N+1} = \\sqrt{2^{104}+1}$。当 $x$ 很小时，我们使用 $\\sqrt{1+x}$ 的二项式展开：$\\sqrt{1+x} = 1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + O(x^3)$。\n$r_{1} = \\sqrt{2^{104}(1 + 2^{-104})} = 2^{52}\\sqrt{1 + 2^{-104}}$。\n令 $x = 2^{-104}$，我们有：\n$r_{1} = 2^{52} \\left(1 + \\frac{1}{2}(2^{-104}) - \\frac{1}{8}(2^{-104})^2 + \\dots \\right) = 2^{52} \\left(1 + 2^{-105} - 2^{-3} \\cdot 2^{-208} + \\dots \\right) = 2^{52} + 2^{-53} - 2^{-159} + \\dots$。\n$r_1$ 的值略大于 $2^{52}$。我们必须确定它如何舍入为一个 `binary64` 数。浮点数 $b$ 是 $2^{52}$。我们需要找到比 $b$ 大的下一个可表示的 `binary64` 数。\n对于量级在 $2^{52}$ 左右的数，其末位单位是 $\\operatorname{ulp}(2^{52})$。指数为 $E=52$，精度为 $p=53$。ULP 由 $2^{E-(p-1)} = 2^{52-(53-1)} = 2^{0} = 1$ 给出。\n因此，$2^{52}$ 附近的可表示数之间的间隔为 1。将 $r_1$ 夹在中间的两个 `binary64` 数是 $y_{\\text{low}} = 2^{52}$ 和 $y_{\\text{high}} = 2^{52}+1$。\n舍入模式是向最接近的数舍入。$y_{\\text{low}}$ 和 $y_{\\text{high}}$ 之间的中点是 $m = \\frac{y_{\\text{low}}+y_{\\text{high}}}{2} = \\frac{2^{52} + (2^{52}+1)}{2} = 2^{52} + \\frac{1}{2} = 2^{52} + 2^{-1}$。\n我们的值是 $r_{1} = 2^{52} + 2^{-53} - 2^{-159} + \\dots$。由于 $2^{-53} < 2^{-1}$，显然 $r_{1} < m$。\n因此，$r_{1}$ 向下舍入到最接近的可表示数，即 $y_{\\text{low}}$。所以，$a = \\operatorname{fl}(r_{1}) = 2^{52}$。\n这样，我们就构造出了具体的值：$a = 2^{52}$ 和 $b = 2^{52}$。\n计算出的减法结果是 $\\operatorname{fl}(a-b) = \\operatorname{fl}(2^{52}-2^{52}) = \\operatorname{fl}(0) = 0$。\n真实的差值是 $r_{1}-r_{2} = \\sqrt{2^{104}+1} - 2^{52}$。根据我们的展开式，这个差值是 $r_{1}-r_{2} = 2^{-53} - 2^{-159} + \\dots$，这是一个约等于 $2^{-53}$ 的很小的正数。\n计算结果为 0，而真实结果非零。相对误差基本上是无限大。这演示了灾难性抵消：将 $r_1$ 和 $r_2$ 初始舍入为 $a$ 和 $b$ 的过程丢失了它们之间微小差异的所有信息。减法 $\\operatorname{fl}(a-b)$ 无法解析出真实的差值 $r_1-r_2$。\n\n(ii) 计算损失指数 $K$。\n\n损失指数定义为 $K = \\left\\lfloor \\log_{2}\\!\\left(\\frac{M}{D}\\right)\\right\\rfloor$。\n我们有 $M = \\max\\{|r_{1}|,|r_{2}|\\} = \\max\\{\\sqrt{N+1}, \\sqrt{N}\\} = \\sqrt{N+1}$。\n并且 $D = |r_{1}-r_{2}| = \\sqrt{N+1} - \\sqrt{N}$。\n该比值为 $\\frac{M}{D} = \\frac{\\sqrt{N+1}}{\\sqrt{N+1} - \\sqrt{N}}$。\n为简化此表达式，我们将分母 $D$ 的分子和分母同乘以其共轭式：\n$D = \\frac{(\\sqrt{N+1} - \\sqrt{N})(\\sqrt{N+1} + \\sqrt{N})}{\\sqrt{N+1} + \\sqrt{N}} = \\frac{(N+1) - N}{\\sqrt{N+1} + \\sqrt{N}} = \\frac{1}{\\sqrt{N+1} + \\sqrt{N}}$。\n因此，$\\frac{M}{D} = M \\cdot (\\sqrt{N+1} + \\sqrt{N}) = \\sqrt{N+1}(\\sqrt{N+1} + \\sqrt{N}) = (N+1) + \\sqrt{N(N+1)}$。\n代入 $N=2^{104}$：\n$\\frac{M}{D} = (2^{104}+1) + \\sqrt{2^{104}(2^{104}+1)} = 2^{104}+1 + \\sqrt{2^{208}+2^{104}}$。\n我们需要求这个量的以 2 为底的对数的整数部分。令 $Y = \\frac{M}{D}$。\n我们来确定 $Y$ 的界限。\n对于下界：\n$\\sqrt{2^{208}+2^{104}} > \\sqrt{2^{208}} = 2^{104}$。\n所以，$Y > (2^{104}+1) + 2^{104} = 2 \\cdot 2^{104} + 1 = 2^{105} + 1$。\n对于上界，考虑恒等式 $(x+y)^{2} = x^2+2xy+y^2$。令 $x=2^{104}$ 且 $y=1/2=2^{-1}$。\n$(2^{104} + 2^{-1})^2 = (2^{104})^2 + 2(2^{104})(2^{-1}) + (2^{-1})^2 = 2^{208} + 2^{104} + \\frac{1}{4}$。\n由于 $2^{208}+2^{104} < 2^{208}+2^{104}+1/4$，我们有 $\\sqrt{2^{208}+2^{104}} < \\sqrt{(2^{104}+2^{-1})^2} = 2^{104}+2^{-1}$。\n所以，$Y < (2^{104}+1) + (2^{104}+2^{-1}) = 2 \\cdot 2^{104} + 1.5 = 2^{105} + 1.5$。\n我们已经确定了严格的界限 $2^{105} + 1 < Y < 2^{105} + 1.5$。\n取以 2 为底的对数：\n$\\log_{2}(2^{105}+1) < \\log_{2}(Y) < \\log_{2}(2^{105}+1.5)$。\n由于 $2^{105} < 2^{105}+1$，我们有 $\\log_{2}(2^{105}) < \\log_{2}(2^{105}+1)$，这意味着 $105 < \\log_{2}(Y)$。\n同样，由于 $2^{105}+1.5 < 2^{106}$，我们有 $\\log_{2}(Y) < \\log_{2}(2^{106}) = 106$。\n所以，$105 < \\log_{2}(Y) < 106$。\n因此，该值的底函数为 $\\lfloor \\log_{2}(Y) \\rfloor = 105$。\n$K=105$。\n\n(iii) 重构与论证。\n\n$r_{1}-r_{2} = \\sqrt{N+1} - \\sqrt{N}$ 中的灾难性抵消源于两个几乎相等的大数相减。为避免这种情况，我们必须重构表达式以消除减法。这可以通过同乘以并同除以共轭表达式 $\\sqrt{N+1}+\\sqrt{N}$ 来推导：\n$r_{1}-r_{2} = (\\sqrt{N+1} - \\sqrt{N}) \\times \\frac{\\sqrt{N+1}+\\sqrt{N}}{\\sqrt{N+1}+\\sqrt{N}} = \\frac{(N+1)-N}{\\sqrt{N+1}+\\sqrt{N}} = \\frac{1}{\\sqrt{N+1}+\\sqrt{N}}$。\n这就是推荐的重构形式。\n\n论证：重构后的表达式是数值稳定的，因为它用一个良性的加法替换了有问题的减法。\n让我们分析在 `binary64` 中计算 $y = \\frac{1}{\\sqrt{N+1}+\\sqrt{N}}$ 的过程。\n1. 计算 $a = \\operatorname{fl}(\\sqrt{N+1})$ 和 $b = \\operatorname{fl}(\\sqrt{N})$。如第 (i) 部分所示，对于 $N=2^{104}$，这两个值都舍入为同一个值 $2^{52}$。\n2. 计算和 $S = \\operatorname{fl}(a+b) = \\operatorname{fl}(2^{52}+2^{52}) = \\operatorname{fl}(2 \\cdot 2^{52}) = \\operatorname{fl}(2^{53})$。此运算是精确的，因此 $S=2^{53}$。\n3. 计算最终结果 $R = \\operatorname{fl}(1/S) = \\operatorname{fl}(1/2^{53}) = \\operatorname{fl}(2^{-53})$。值 $2^{-53}$ 是 2 的幂，可以精确地表示为一个规格化的 `binary64` 数。所以最终计算结果精确地为 $R=2^{-53}$。\n\n真实值为 $D = \\frac{1}{\\sqrt{2^{104}+1}+2^{52}}$。如第 (i) 部分所示，$\\sqrt{2^{104}+1} = 2^{52}+2^{-53}-\\dots$。\n所以，$D = \\frac{1}{(2^{52}+2^{-53}-\\dots)+2^{52}} = \\frac{1}{2^{53}+2^{-53}-\\dots}$。\n这个值非常接近 $\\frac{1}{2^{53}} = 2^{-53}$。\n重构后计算的相对误差约为 $\\left| \\frac{D-R}{D} \\right| \\approx \\left| \\frac{(2^{-53}(1-2^{-106})) - 2^{-53}}{2^{-53}(1-2^{-106})} \\right| \\approx 2^{-106}$，这个值极小。\n定性地看，原始形式 $\\operatorname{fl}(\\operatorname{fl}(\\sqrt{N+1}) - \\operatorname{fl}(\\sqrt{N}))$ 会失败，因为真实差值 $|r_1-r_2| \\approx 2^{-53}$ 小于计算单个平方根时的舍入误差，后者的数量级为 $\\operatorname{ulp}(\\sqrt{N}) = \\operatorname{ulp}(2^{52}) = 1$。真实差值的所有有效位都丢失了。\n相比之下，重构后的表达式计算 $\\operatorname{fl}(1 / (\\operatorname{fl}(\\sqrt{N+1}) + \\operatorname{fl}(\\sqrt{N})))$。加法 $\\sqrt{N+1}+\\sqrt{N}$ 是数值稳定的，因为它将两个大的、正的、几乎相等的数相加。和的相对误差很小。随后的除法也是一个稳定的运算。新算法保留了信息并得出一个高度精确的结果。", "answer": "$$\n\\boxed{105}\n$$", "id": "2887738"}]}