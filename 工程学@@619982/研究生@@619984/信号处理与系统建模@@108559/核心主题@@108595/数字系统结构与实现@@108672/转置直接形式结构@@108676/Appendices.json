{"hands_on_practices": [{"introduction": "在数字滤波器设计中，同一个传递函数可以通过多种不同的结构来实现。选择哪种结构通常取决于硬件成本、计算效率和数值稳定性等因素。转置结构的一个核心优势在于，它在不改变系统传递函数的前提下，提供了与原结构不同的数值特性。但一个基本问题是：这种结构上的转换是否会增加实现所需的资源？本练习通过一个基本但重要的任务来解答这个问题：清点直接II型（DF-II）和转置直接II型（TDF-II）结构所需的乘法器、加法器和延迟单元的数量。通过这个练习，你将从资源计数的角度直观地理解，转置操作本质上是对已有元件的“重新布线”，而非增加新的元件，这为我们后续深入探讨其代数和数值特性奠定了基础。[@problem_id:2915276]", "problem": "考虑一个因果、线性时不变 (LTI) 离散时间系统，其传递函数为\n$$\nH(z)=\\frac{B(z)}{A(z)}=\\frac{b_{0}+b_{1}z^{-1}+\\cdots+b_{M}z^{-M}}{1+a_{1}z^{-1}+\\cdots+a_{N}z^{-N}},\n$$\n其中 $A(z)$ 是首一的，$M$ 和 $N$ 是非负整数，所有系数 $b_{k}$ ($0\\leq k\\leq M$) 和 $a_{k}$ ($1\\leq k\\leq N$) 均为通用的非零实数（不存在结构性对消）。假设信号分离器是理想的（无成本），每次求和仅使用双输入加法器实现，一元符号变换被吸收到乘法器中。不允许进行超出规范形式的结构优化。\n\n仅利用以下核心事实：(i) 一个由线性常系数差分方程描述的因果 LTI 系统，可以通过互连乘法器、加法器和单位延迟来实现，(ii) $K$ 个信号求和需要 $K-1$ 个双输入加法器，以及 (iii) 线性信号流图的转置定理在反转互连的同时，保持传递函数和线性元件的数量不变，完成以下任务：\n\n1. 在概念上以直接II型 (DF-II) 规范结构实现 $H(z)$，并计算所需的实数乘法器、双输入加法器和单位延迟的总数，用 $M$ 和 $N$ 表示。\n\n2. 应用转置定理得到转置直接II型 (TDF-II) 结构，并再次计算所需的实数乘法器、双输入加法器和单位延迟的总数，用 $M$ 和 $N$ 表示。\n\n3. 解释 DF-II 和 TDF-II 的这些总数是否相等，并说明为什么会这样，即使元件的布局不同。\n\n以单行矩阵 $[n_{\\text{mult}},\\,n_{\\text{add}},\\,n_{\\text{delay}}]$ 的形式给出你的最终答案，作为它们的共同总数，其元素是关于 $M$ 和 $N$ 的符号表达式。不需要进行数值计算，也不涉及单位。", "solution": "问题陈述是数字滤波器规范结构分析中一个适定的练习。它在科学上基于线性系统和数字信号处理的既定原则。所有前提和约束都定义清晰且一致。该问题是有效的。我们着手求解。\n\n该系统由传递函数 $H(z)$ 描述：\n$$\nH(z) = \\frac{Y(z)}{X(z)} = \\frac{B(z)}{A(z)} = \\frac{\\sum_{k=0}^{M} b_k z^{-k}}{1 + \\sum_{k=1}^{N} a_k z^{-k}}\n$$\n其中 $Y(z)$ 和 $X(z)$ 分别是输出和输入信号的Z变换。该传递函数可以分解为一个全极点部分 $H_1(z) = 1/A(z)$ 和一个全零点部分 $H_2(z) = B(z)$。\n\n1.  **直接II型 (DF-II) 实现**\n\n直接II型结构通过级联全极点部分和全零点部分 ($H(z) = H_2(z)H_1(z)$) 来实现系统，并在两个部分之间共享延迟元件，以实现规范实现。设 $w[n]$ 为全极点部分输出的中间信号，其Z变换为 $W(z) = X(z)/A(z)$，系统输出为 $Y(z) = B(z)W(z)$。\n\n相应的差分方程为：\n$$\nA(z)W(z) = X(z) \\implies \\left(1 + \\sum_{k=1}^{N} a_k z^{-k}\\right)W(z) = X(z)\n$$\n在时域中，这给出了中间信号 $w[n]$ 的递归方程：\n$$\nw[n] = x[n] - \\sum_{k=1}^{N} a_k w[n-k]\n$$\n对于输出信号 $y[n]$：\n$$\nY(z) = B(z)W(z) \\implies Y(z) = \\left(\\sum_{k=0}^{M} b_k z^{-k}\\right)W(z)\n$$\n在时域中，这给出了输出的非递归方程：\n$$\ny[n] = \\sum_{k=0}^{M} b_k w[n-k]\n$$\n我们现在根据这两个方程计算所需的元件。\n\n*   **乘法器：** $w[n]$ 的递归方程涉及将 $N$ 个延迟信号 $w[n-1], \\dots, w[n-N]$ 与系数 $a_1, \\dots, a_N$ 相乘。由于问题陈述一元符号变换被吸收到乘法器中，这需要 $N$ 个实数乘法器。$y[n]$ 的非递归方程涉及将信号 $w[n], w[n-1], \\dots, w[n-M]$ 与系数 $b_0, \\dots, b_M$ 相乘。这需要 $M+1$ 个实数乘法器。乘法器的总数为 $n_{\\text{mult}} = N + (M+1) = M+N+1$。\n\n*   **双输入加法器：** $w[n]$ 的计算是 $N+1$ 项的和：$x[n]$ 和 $N$ 个乘积 $-a_k w[n-k]$。根据给定规则，$K$ 个信号求和需要 $K-1$ 个双输入加法器，此计算需要 $(N+1)-1 = N$ 个加法器。$y[n]$ 的计算是 $M+1$ 项的和。这需要 $(M+1)-1 = M$ 个加法器。加法器的总数为 $n_{\\text{add}} = N+M = M+N$。\n\n*   **单位延迟：** DF-II 结构对中间信号 $w[n]$ 使用单一的共享延迟线。递归部分需要高达 $w[n-N]$ 的延迟，而非递归部分需要高达 $w[n-M]$ 的延迟。为了同时满足两者，延迟线的长度必须等于两个阶数中较大的那个。单位延迟元件的总数为 $n_{\\text{delay}} = \\max(M, N)$。\n\n总而言之，对于直接II型实现，元件数量为：\n$n_{\\text{mult}} = M+N+1$\n$n_{\\text{add}} = M+N$\n$n_{\\text{delay}} = \\max(M, N)$\n\n2.  **转置直接II型 (TDF-II) 实现**\n\n转置直接II型结构是通过对直接II型结构的信号流图应用转置定理得出的。问题陈述中给出了一个事实，即该定理“(iii) 在反转互连的同时，保持传递函数和线性元件的数量不变。”线性元件是乘法器、加法器和延迟元件。\n\n因此，转置操作（涉及反转所有信号路径的方向以及将求和节点与分支节点互换）不会改变每种类型元件的总数。它只重新配置了它们的连接性。\n\n基于此原理，TDF-II 结构的元件数量必须与 DF-II 结构的数量相同。\n\n*   **乘法器：** $n_{\\text{mult}} = M+N+1$\n*   **双输入加法器：** $n_{\\text{add}} = M+N$\n*   **单位延迟：** $n_{\\text{delay}} = \\max(M, N)$\n\n3.  **总数相等性及解释**\n\n对于直接II型和转置直接II型结构，实数乘法器、双输入加法器和单位延迟的总数确实是相等的。\n\n这种相等性的根本原因是线性信号流图的转置定理。信号流图是由通过有向支路互连的节点组成的集合。支路代表线性运算，在此背景下是乘以一个常数（乘法器）或乘以 $z^{-1}$（单位延迟）。节点代表信号的分裂（分支节点）或多个信号的求和（求和节点）。\n\n当一个图被转置时，所有支路的方向都会反转。一个有 $K$ 个输入和 $1$ 个输出的求和节点会变成一个有 $1$ 个输入和 $K$ 个输出的分支节点。反之，一个分支节点会变成一个求和节点。代表乘法器和延迟的支路本身保持原位，只是输入和输出互换。\n\n关键的是，正如问题前提中所述，在这种变换下，每种线性元件的总数是不变的。由于 TDF-II 结构根据定义是 DF-II 结构的转置，它们保证拥有相同的元件清单。差异不在于*什么*或*多少*，而在于*哪里*——即这些元件的拓扑排列，这会改变信号的流动和滤波器实现的数值属性（例如其对系数化和舍入噪声的敏感度），但不会改变实现所需的基本元件数量。\n\n因此，两种结构的共同总数为 $[n_{\\text{mult}},\\,n_{\\text{add}},\\,n_{\\text{delay}}] = [M+N+1,\\, M+N,\\, \\max(M,N)]$。", "answer": "$$\n\\boxed{\\begin{pmatrix} M+N+1 & M+N & \\max(M,N) \\end{pmatrix}}\n$$", "id": "2915276"}, {"introduction": "既然我们已经确认转置结构与原结构使用相同数量的计算元件，下一个关键问题是如何正确地执行这种“重新布线”。信号流图的转置操作在状态空间表示中有一个精确的代数对应关系。然而，一个常见的误区是将其简单地等同于只对状态转移矩阵 $A$ 进行转置，而保持输入、输出矩阵 $B$ 和 $C$ 不变。这个练习旨在通过一个具体的反例来澄清这一关键区别。你将推导一个系统的正确转置实现及其传递函数，并将其与“天真”转置（即仅转置 $A$ 矩阵）的结果进行对比。通过这个计算，你将深刻理解为何正确的转置规则 $(A, B, C, D) \\rightarrow (A^T, C^T, B^T, D)$ 是保持系统传递函数不变的必要条件。[@problem_id:2915308]", "problem": "在实现转置直接型结构时，一个常见的误解是将信号流图（SFG）的转置仅仅视为对状态转移矩阵进行矩阵转置。为了澄清这一区别，考虑一个单输入单输出（SISO）的离散时间线性时不变（LTI）状态空间系统\n$$\nx[n+1] = A x[n] + B u[n], \\quad y[n] = C x[n] + D u[n],\n$$\n其中\n$$\nA = \\begin{pmatrix} 0 & 1 \\\\ -\\frac{9}{25} & \\frac{6}{5} \\end{pmatrix},\\quad B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\\quad C = \\begin{pmatrix} 1 & 0 \\end{pmatrix},\\quad D = 0.\n$$\n从传递函数是零初始条件下输出与输入的单边Z变换之比这一基本定义出发，推导给定系统的传递函数 $H(z)$。然后，仅使用信号流图转置的定义（反转所有有向边，互换求和节点与分支节点，同时交换外部输入和输出），确定由信号流图转置产生的相应状态空间四元组，并证明它实现了相同的 $H(z)$。\n\n现在，构造一个朴素实现，该实现仅将状态转移矩阵替换为其转置，而保持其他矩阵不变，即\n$$\n\\tilde{A} = A^{T},\\quad \\tilde{B} = B,\\quad \\tilde{C} = C,\\quad \\tilde{D} = D,\n$$\n并从第一性原理出发，推导其传递函数 $\\tilde{H}(z)$。\n\n将你的最终答案表示为一个分子和分母均为整数系数的关于 $z$ 的单一有理函数。无需四舍五入。", "solution": "所述问题具有科学依据，提法恰当，客观，并包含了获得唯一数学解所需的所有必要信息。它基于线性时不变（LTI）系统理论的既定原理，特别是状态空间表示、传递函数和信号流图（SFG）转置。因此，该问题被认为是有效的，并将提供解答。\n\n问题要求从离散时间LTI状态空间表示中推导几个传递函数。状态空间表示 $(A, B, C, D)$ 与其传递函数 $H(z)$ 之间的基本关系由以下公式给出：\n$$\nH(z) = C(zI - A)^{-1}B + D\n$$\n其中 $I$ 是适当维度的单位矩阵。该公式是通过在零初始条件的假设下对状态方程和输出方程进行单边Z变换推导出来的。\n\n首先，我们推导给定系统的传递函数 $H(z)$：\n$$\nA = \\begin{pmatrix} 0 & 1 \\\\ -\\frac{9}{25} & \\frac{6}{5} \\end{pmatrix},\\quad B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\\quad C = \\begin{pmatrix} 1 & 0 \\end{pmatrix},\\quad D = 0.\n$$\n我们首先计算矩阵 $(zI - A)$：\n$$\nzI - A = z\\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 0 & 1 \\\\ -\\frac{9}{25} & \\frac{6}{5} \\end{pmatrix} = \\begin{pmatrix} z & -1 \\\\ \\frac{9}{25} & z - \\frac{6}{5} \\end{pmatrix}.\n$$\n该矩阵的行列式为：\n$$\n\\det(zI - A) = z\\left(z - \\frac{6}{5}\\right) - (-1)\\left(\\frac{9}{25}\\right) = z^2 - \\frac{6}{5}z + \\frac{9}{25}.\n$$\n那么逆矩阵 $(zI-A)^{-1}$ 是：\n$$\n(zI - A)^{-1} = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} z - \\frac{6}{5} & 1 \\\\ -\\frac{9}{25} & z \\end{pmatrix}.\n$$\n现在，我们可以计算传递函数 $H(z)$：\n$$\nH(z) = \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\left( \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} z - \\frac{6}{5} & 1 \\\\ -\\frac{9}{25} & z \\end{pmatrix} \\right) \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + 0\n$$\n$$\nH(z) = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} (z - \\frac{6}{5})(0) + (1)(1) \\\\ (-\\frac{9}{25})(0) + (z)(1) \\end{pmatrix}\n$$\n$$\nH(z) = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ z \\end{pmatrix} = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}}.\n$$\n接下来，我们考虑通过正确的信号流图转置得到的系统。转置系统的状态空间四元组 $(A_t, B_t, C_t, D_t)$ 与原始系统 $(A, B, C, D)$ 的关系为 $A_t = A^T$, $B_t = C^T$, $C_t = B^T$ 且 $D_t = D$。\n对于给定的系统，这得到：\n$$\nA_t = A^T = \\begin{pmatrix} 0 & -\\frac{9}{25} \\\\ 1 & \\frac{6}{5} \\end{pmatrix}, \\quad B_t = C^T = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad C_t = B^T = \\begin{pmatrix} 0 & 1 \\end{pmatrix}, \\quad D_t = D = 0.\n$$\n这个转置系统的传递函数，我们称之为 $H_t(z)$，由 $H_t(z) = C_t(zI - A_t)^{-1}B_t + D_t$ 给出。我们有 $\\det(zI - A_t) = \\det((zI - A)^T) = \\det(zI - A) = z^2 - \\frac{6}{5}z + \\frac{9}{25}$。\n$$\n(zI - A_t)^{-1} = (zI-A^T)^{-1} = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} z - \\frac{6}{5} & \\frac{9}{25} \\\\ -1 & z \\end{pmatrix}^T = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} z - \\frac{6}{5} & -1 \\\\ \\frac{9}{25} & z \\end{pmatrix}.\n$$\n$$\nH_t(z) = \\begin{pmatrix} 0 & 1 \\end{pmatrix} \\left( \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} z - \\frac{6}{5} & -1 \\\\ \\frac{9}{25} & z \\end{pmatrix} \\right) \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\n$$\nH_t(z) = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} 0 & 1 \\end{pmatrix} \\begin{pmatrix} z - \\frac{6}{5} \\\\ \\frac{9}{25} \\end{pmatrix} = \\frac{\\frac{9}{25}}{z^2 - \\frac{6}{5}z + \\frac{9}{25}}.\n$$\n正如预期的那样，$H_t(z) = H(z)$，这证实了信号流图转置保留了传递函数。\n\n最后，我们分析“朴素”实现，用四元组 $(\\tilde{A}, \\tilde{B}, \\tilde{C}, \\tilde{D})$ 表示，其中：\n$$\n\\tilde{A} = A^{T} = \\begin{pmatrix} 0 & -\\frac{9}{25} \\\\ 1 & \\frac{6}{5} \\end{pmatrix},\\quad \\tilde{B} = B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix},\\quad \\tilde{C} = C = \\begin{pmatrix} 1 & 0 \\end{pmatrix},\\quad \\tilde{D} = D = 0.\n$$\n我们推导其传递函数 $\\tilde{H}(z) = \\tilde{C}(zI - \\tilde{A})^{-1}\\tilde{B} + \\tilde{D}$。矩阵 $(zI - \\tilde{A})^{-1}$ 与先前计算的 $(zI - A_t)^{-1}$ 相同。\n$$\n\\tilde{H}(z) = \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\left( \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} z - \\frac{6}{5} & -1 \\\\ \\frac{9}{25} & z \\end{pmatrix} \\right) \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n$$\n\\tilde{H}(z) = \\frac{1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}} \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ z \\end{pmatrix}\n$$\n$$\n\\tilde{H}(z) = \\frac{-1}{z^2 - \\frac{6}{5}z + \\frac{9}{25}}.\n$$\n这显然与 $H(z)$ 不同，证明了朴素方法的谬误。为了将此结果表示为具有整数系数的有理函数，我们将分子和分母同乘以 $25$：\n$$\n\\tilde{H}(z) = \\frac{25 \\times (-1)}{25 \\times (z^2 - \\frac{6}{5}z + \\frac{9}{25})} = \\frac{-25}{25z^2 - 25(\\frac{6}{5})z + 25(\\frac{9}{25})} = \\frac{-25}{25z^2 - 30z + 9}.\n$$\n这就是朴素构造系统的传递函数。", "answer": "$$\n\\boxed{\\frac{-25}{25z^2 - 30z + 9}}\n$$", "id": "2915308"}, {"introduction": "理论分析和代数推导都表明，正确的转置操作能保持系统的传递函数不变。然而，在工程和科学实践中，“眼见为实”是验证理论的黄金标准。系统的冲激响应是其传递函数在时域的唯一“指纹”，如果两个系统具有完全相同的冲激响应，那么它们在外部表现上就是等价的。本练习将引导你通过编写代码，对多个不同特性的状态空间模型及其转置实现进行数值仿真。你将计算并比较它们的冲激响应，从而在实践中验证转置定理。这个动手实践不仅能巩固你的理论知识，还能让你体验到如何利用计算工具来验证复杂的系统理论。[@problem_id:2915280]", "problem": "给定阶数为 $2$ 的离散时间线性时不变 (LTI) 状态空间实现，每个由一个四元组 $(A,B,C,D)$ 指定，其中 $A \\in \\mathbb{R}^{2 \\times 2}$，$B \\in \\mathbb{R}^{2 \\times 1}$，$C \\in \\mathbb{R}^{1 \\times 2}$，且 $D \\in \\mathbb{R}$。系统动力学由以下状态和输出方程定义：\n$$\nx[k+1] = A\\,x[k] + B\\,u[k], \\quad y[k] = C\\,x[k] + D\\,u[k],\n$$\n初始状态为零 $x[0] = 0$。对于转置直接型结构，将转置实现定义为 $(\\tilde{A},\\tilde{B},\\tilde{C},\\tilde{D}) = (A^{T},C^{T},B^{T},D^{T})$，其中上标 $T$ 表示矩阵转置。考虑单位脉冲输入 $u[k]$，其定义为 $u[0] = 1$ 且对于所有 $k \\ge 1$ 有 $u[k] = 0$。\n\n任务：\n1) 对于每个给定的测试用例 $(A,B,C,D)$，计算 $(\\tilde{A},\\tilde{B},\\tilde{C},\\tilde{D}) = (A^{T},C^{T},B^{T},D^{T})$。\n2) 对于原始实现和转置实现，在零初始状态 $x[0]=0$ 下仿真对单位脉冲输入的响应，并计算 $N$ 个时间步长的输出序列 $\\{y[k]\\}_{k=0}^{N-1}$ 和 $\\{\\tilde{y}[k]\\}_{k=0}^{N-1}$。\n3) 通过检查是否满足以下条件来数值验证脉冲响应是否相同：\n$$\n\\max_{0 \\le k \\le N-1} \\left| y[k] - \\tilde{y}[k] \\right| \\le \\tau,\n$$\n其中 $\\tau$ 是一个微小的非负容差。每个测试用例的验证结果应为一个布尔值，如果不等式成立则为 $\\,\\mathrm{True}\\,$，否则为 $\\,\\mathrm{False}\\,$。\n\n使用以下包含四个二阶单输入单输出 (SISO) 实现的测试套件，其中 $N=12$ 且容差 $\\tau = 10^{-11}$：\n- 测试用例 $1$ (严格真，稳定)：\n$$\nA = \\begin{bmatrix} 0.7 & 0.2 \\\\ -0.1 & 0.9 \\end{bmatrix},\\;\nB = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix},\\;\nC = \\begin{bmatrix} 0.3 & -0.4 \\end{bmatrix},\\;\nD = 0.0.\n$$\n- 测试用例 $2$ (非零直接馈通 $D$)：\n$$\nA = \\begin{bmatrix} 0.5 & -0.3 \\\\ 0.1 & 0.4 \\end{bmatrix},\\;\nB = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix},\\;\nC = \\begin{bmatrix} 1.0 & 0.2 \\end{bmatrix},\\;\nD = 0.25.\n$$\n- 测试用例 $3$ (重复特征值，若尔当形)：\n$$\nA = \\begin{bmatrix} 0.6 & 1.0 \\\\ 0.0 & 0.6 \\end{bmatrix},\\;\nB = \\begin{bmatrix} 0.2 \\\\ 0.3 \\end{bmatrix},\\;\nC = \\begin{bmatrix} -0.5 & 0.7 \\end{bmatrix},\\;\nD = 0.0.\n$$\n- 测试用例 $4$ (边缘情况，零输入到状态耦合)：\n$$\nA = \\begin{bmatrix} 0.8 & 0.0 \\\\ 0.0 & 0.8 \\end{bmatrix},\\;\nB = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix},\\;\nC = \\begin{bmatrix} 0.9 & -0.1 \\end{bmatrix},\\;\nD = -0.3.\n$$\n\n你的程序必须：\n- 在内部构建这四个测试用例。\n- 对每个测试用例，计算转置实现 $(A^{T},C^{T},B^{T},D^{T})$ 并仿真 $N=12$ 个采样点的脉冲响应。\n- 逐元素比较两个输出序列，并计算最大绝对差值。\n- 为每个测试用例返回一个布尔结果，指明最大差值是否至多为 $\\tau = 10^{-11}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果 (例如, $[result_1,result_2,result_3,result_4]$)，其中每个 $result_i$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "所述问题是有效的。它在科学上基于线性系统理论的原理，其给出的条件完整且一致，问题设定良好，并以客观的数学语言表述。我们将着手提供一个解决方案。\n\n需要验证的基本原理是，单输入单输出 (SISO) 线性时不变 (LTI) 系统在一种称为转置的特定状态空间变换下，其输入-输出行为具有不变性。系统的脉冲响应是其输入-输出特性的唯一表征。如果两个系统具有相同的脉冲响应，则它们是外部等效的。\n\n一个离散时间 LTI 系统由状态空间实现 $(A, B, C, D)$ 给出：\n$$\nx[k+1] = A x[k] + B u[k]\n$$\n$$\ny[k] = C x[k] + D u[k]\n$$\n其中 $x[k] \\in \\mathbb{R}^n$ 是在时间 $k$ 的状态向量，$u[k] \\in \\mathbb{R}$ 是输入，$y[k] \\in \\mathbb{R}$ 是输出，矩阵维度为 $A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times 1}$，$C \\in \\mathbb{R}^{1 \\times n}$，以及 $D \\in \\mathbb{R}$。\n\n在Z域中，从输入 $U(z)$ 到输出 $Y(z)$ 的传递函数 $H(z)$ 由以下公式给出：\n$$\nH(z) = C(zI - A)^{-1}B + D\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。\n\n问题将转置实现定义为 $(\\tilde{A}, \\tilde{B}, \\tilde{C}, \\tilde{D}) = (A^T, C^T, B^T, D^T)$。这是系统理论中的一个标准定义，其中 $D^T=D$ 因为 $D$ 是一个标量。转置系统的状态方程为：\n$$\n\\tilde{x}[k+1] = \\tilde{A} \\tilde{x}[k] + \\tilde{B} u[k] = A^T \\tilde{x}[k] + C^T u[k]\n$$\n$$\n\\tilde{y}[k] = \\tilde{C} \\tilde{x}[k] + \\tilde{D} u[k] = B^T \\tilde{x}[k] + D u[k]\n$$\n转置系统的传递函数 $\\tilde{H}(z)$ 是：\n$$\n\\tilde{H}(z) = \\tilde{C}(zI - \\tilde{A})^{-1}\\tilde{B} + \\tilde{D} = B^T(zI - A^T)^{-1}C^T + D\n$$\n使用矩阵恒等式 $(M^{-1})^T = (M^T)^{-1}$，我们可以写出 $(zI - A^T)^{-1} = ((zI - A)^T)^{-1} = ((zI - A)^{-1})^T$。将此代入 $\\tilde{H}(z)$ 的表达式中：\n$$\n\\tilde{H}(z) = B^T((zI - A)^{-1})^T C^T + D\n$$\n使用恒等式 $(MNP)^T = P^T N^T M^T$，我们可以将项 $B^T((zI - A)^{-1})^T C^T$ 识别为一个乘积的转置：\n$$\nB^T((zI - A)^{-1})^T C^T = (C(zI - A)^{-1}B)^T\n$$\n因此，转置系统的传递函数是：\n$$\n\\tilde{H}(z) = (C(zI - A)^{-1}B)^T + D\n$$\n对于一个SISO系统，项 $C(zI - A)^{-1}B$ 是一个 $1 \\times 1$ 矩阵，即一个标量。标量等于其自身的转置。因此，$(C(zI - A)^{-1}B)^T = C(zI - A)^{-1}B$。这导出结论：\n$$\n\\tilde{H}(z) = H(z)\n$$\n由于原始系统和转置系统的传递函数相同，它们的脉冲响应也必须相同。脉冲响应 $\\{h[k]\\}_{k=0}^{\\infty}$ 是传递函数 $H(z)$ 的Z逆变换。该问题要求通过在有限时间范围 $N=12$ 内直接仿真，对这一理论事实（即对于单位脉冲输入，$y[k] = \\tilde{y}[k]$）进行数值验证。\n\n对每个测试用例 $(A, B, C, D)$ 的仿真流程如下：\n$1$. 定义仿真参数：步数 $N=12$ 和容差 $\\tau=10^{-11}$。\n$2$. 构建原始系统矩阵 $(A, B, C, D)$ 和转置系统矩阵 $(\\tilde{A}, \\tilde{B}, \\tilde{C}, \\tilde{D}) = (A^T, C^T, B^T, D)$。\n$3$. 将两个系统的状态向量初始化为零： $x[0] = \\mathbf{0}$ 和 $\\tilde{x}[0] = \\mathbf{0}$。这些是 $\\mathbb{R}^2$ 中的向量。\n$4$. 定义单位脉冲输入：$u[0] = 1$ 且对于 $k \\in \\{1, 2, \\dots, N-1\\}$ 有 $u[k] = 0$。\n$5$. 从 $k=0$到 $N-1$ 迭代仿真两个系统：\n   a. 计算在步骤 $k$ 的输出：\n      - $y[k] = C x[k] + D u[k]$\n      - $\\tilde{y}[k] = \\tilde{C} \\tilde{x}[k] + \\tilde{D} u[k]$\n   b. 将 $y[k]$ 和 $\\tilde{y}[k]$ 存储在它们各自的输出序列中。\n   c. 计算步骤 $k+1$ 的下一个状态：\n      - $x[k+1] = A x[k] + B u[k]$\n      - $\\tilde{x}[k+1] = \\tilde{A} \\tilde{x}[k] + \\tilde{B} u[k]$\n$6$. 完成 $N$ 步的仿真后，计算两个输出序列之间的最大绝对差值：\n$$\n\\Delta_{\\max} = \\max_{0 \\le k \\le N-1} |y[k] - \\tilde{y}[k]|\n$$\n$7$. 如果 $\\Delta_{\\max} \\le \\tau$，则验证成功。如果此条件成立，则该测试用例的结果为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。任何观察到的非零差异都可归因于浮点数值误差，预计该误差将远小于指定的容差 $\\tau$。\n\n此流程将应用于所有四个指定的测试用例。根据理论，所有四个用例的预期结果都应为 $\\mathrm{True}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate(A, B, C, D, N, u_seq):\n    \"\"\"\n    Simulates the output of a discrete-time LTI state-space system.\n\n    Args:\n        A (np.ndarray): State matrix (n x n).\n        B (np.ndarray): Input matrix (n x 1).\n        C (np.ndarray): Output matrix (1 x n).\n        D (float): Direct feedthrough scalar.\n        N (int): Number of time steps to simulate.\n        u_seq (np.ndarray): Input signal sequence of length N.\n\n    Returns:\n        np.ndarray: The output sequence y[k] for k=0 to N-1.\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros((n, 1))\n    y_seq = np.zeros(N)\n\n    for k in range(N):\n        # Calculate output y[k]\n        y_k = C @ x + D * u_seq[k]\n        y_seq[k] = y_k.item()\n        \n        # Update state to x[k+1]\n        x = A @ x + B * u_seq[k]\n        \n    return y_seq\n\n\ndef solve():\n    \"\"\"\n    Solves the problem by verifying the equivalence of impulse responses for\n    four LTI systems and their transpositions.\n    \"\"\"\n    # Define problem parameters\n    N = 12\n    tau = 1e-11\n\n    # Define the unit impulse input sequence\n    u_impulse = np.zeros(N)\n    u_impulse[0] = 1.0\n\n    # Define the four test cases\n    test_cases = [\n        # Test case 1 (strictly proper, stable)\n        {\n            \"A\": np.array([[0.7, 0.2], [-0.1, 0.9]]),\n            \"B\": np.array([[1.0], [0.5]]),\n            \"C\": np.array([[0.3, -0.4]]),\n            \"D\": 0.0,\n        },\n        # Test case 2 (nonzero direct feedthrough D)\n        {\n            \"A\": np.array([[0.5, -0.3], [0.1, 0.4]]),\n            \"B\": np.array([[0.0], [1.0]]),\n            \"C\": np.array([[1.0, 0.2]]),\n            \"D\": 0.25,\n        },\n        # Test case 3 (repeated eigenvalue, Jordan form)\n        {\n            \"A\": np.array([[0.6, 1.0], [0.0, 0.6]]),\n            \"B\": np.array([[0.2], [0.3]]),\n            \"C\": np.array([[-0.5, 0.7]]),\n            \"D\": 0.0,\n        },\n        # Test case 4 (edge case with zero input-to-state coupling)\n        {\n            \"A\": np.array([[0.8, 0.0], [0.0, 0.8]]),\n            \"B\": np.array([[0.0], [0.0]]),\n            \"C\": np.array([[0.9, -0.1]]),\n            \"D\": -0.3,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B, C, D = case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"]\n\n        # 1. Compute the transposed realization\n        At = A.T\n        Bt = C.T\n        Ct = B.T\n        Dt = D  # D is a scalar, so D.T = D\n\n        # 2. Simulate impulse response for both systems\n        y_original = simulate(A, B, C, D, N, u_impulse)\n        y_transposed = simulate(At, Bt, Ct, Dt, N, u_impulse)\n\n        # 3. Verify that the impulse responses are identical\n        max_diff = np.max(np.abs(y_original - y_transposed))\n        verification_result = max_diff = tau\n        results.append(verification_result)\n\n    # Final print statement in the exact required format.\n    # The map(str,...) correctly converts Python's True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2915280"}]}