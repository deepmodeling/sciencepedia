{"hands_on_practices": [{"introduction": "在量化理论中，信噪比（SQNR）是衡量性能的核心指标。我们的第一个实践将带我们回到第一性原理，推导一个基本但至关重要的关系。通过分析一个正弦输入信号，我们将量化当信号幅度未达到转换器满量程时 $SQNR$ 的变化，这是一个在实际系统设计中普遍存在的情景 [@problem_id:2898438]。这项练习旨在巩固你对 $SQNR$ 基本计算的理解，并揭示信号电平对量化性能的直接影响。", "problem": "一个模数转换器 (ADC) 采用一个均匀中置型量化器，其分辨率为 $B$ 位，对称满量程范围为 $\\left[-A_{\\mathrm{FS}},\\,A_{\\mathrm{FS}}\\right]$。该量化器使用四舍五入法，且未过载。假设采用经典的加性、白色、与信号无关的量化噪声模型，其中量化误差在单个量化步长内均匀分布。一个单音正弦信号 $x(t)=A\\cos(\\omega_{0}t)$ 被施加到输入端。\n\n将信号量化噪声比 (SQNR) 定义为输入信号平均功率与量化误差功率之比，并通过 $10\\log_{10}(\\cdot)$ 定义其分贝 (dB) 度量。令 $\\mathrm{SQNR}_{\\mathrm{dB,ref}}$ 为当正弦波使用全部可用峰值振幅，即 $A=A_{\\mathrm{FS}}$ 时的分贝值 SQNR；令 $\\mathrm{SQNR}_{\\mathrm{dB}}(\\gamma)$ 为当正弦波振幅回退至 $A=\\gamma A_{\\mathrm{FS}}$ 以提供波峰因数裕量时的分贝值 SQNR，其中 $\\gamma\\in(0,1)$。\n\n从均匀量化、正弦平均功率和所述噪声模型的第一性原理出发，推导出仅依赖于 $\\gamma$ 的分贝偏移\n$$\\Delta_{\\mathrm{dB}}=\\mathrm{SQNR}_{\\mathrm{dB}}(\\gamma)-\\mathrm{SQNR}_{\\mathrm{dB,ref}}$$\n的闭式表达式。最终答案需以分贝表示。无需进行数值计算，也无需四舍五入。最终答案必须是单个闭式解析表达式。", "solution": "所述问题是有效的。它具有科学依据、是适定的、客观的，并包含了进行严格推导所需的所有必要信息。这是模数转换分析中的一个标准问题。我将根据要求从第一性原理出发进行求解。\n\n问题要求计算分贝偏移 $\\Delta_{\\mathrm{dB}} = \\mathrm{SQNR}_{\\mathrm{dB}}(\\gamma) - \\mathrm{SQNR}_{\\mathrm{dB,ref}}$。我们必须首先推导出信号量化噪声比 (SQNR) 的表达式。\n\n首先，我们确定量化步长大小 $\\Delta$。量化器的分辨率为 $B$ 位，对应于 $L = 2^B$ 个量化电平。满量程范围指定为 $[-A_{\\mathrm{FS}}, A_{\\mathrm{FS}}]$，因此总范围是 $A_{\\mathrm{FS}} - (-A_{\\mathrm{FS}}) = 2A_{\\mathrm{FS}}$。对于均匀量化器，步长大小 $\\Delta$ 是总范围除以电平数：\n$$\n\\Delta = \\frac{2A_{\\mathrm{FS}}}{L} = \\frac{2A_{\\mathrm{FS}}}{2^B}\n$$\n\n接下来，我们计算量化噪声功率 $P_q$。问题指出，量化误差（我们用 $e$ 表示）被建模为在单个量化步长上均匀分布的随机变量。对于使用四舍五入的中置型量化器，任何给定样本的误差都位于区间 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 内。因此，误差 $e$ 的概率密度函数 (PDF) 为：\n$$\np_e(x) = \\begin{cases} \\frac{1}{\\Delta} & \\text{for } -\\frac{\\Delta}{2} \\le x \\le \\frac{\\Delta}{2} \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\n噪声功率 $P_q$ 是量化误差的方差，即 $\\sigma_e^2 = E[e^2] - (E[e])^2$。由于概率密度函数关于零点对称，平均误差为 $E[e] = 0$。因此，功率等于其均方值 $E[e^2]$：\n$$\nP_q = E[e^2] = \\int_{-\\infty}^{\\infty} x^2 p_e(x) \\,dx = \\int_{-\\Delta/2}^{\\Delta/2} x^2 \\frac{1}{\\Delta} \\,dx\n$$\n计算该积分：\n$$\nP_q = \\frac{1}{\\Delta} \\left[ \\frac{x^3}{3} \\right]_{-\\Delta/2}^{\\Delta/2} = \\frac{1}{3\\Delta} \\left( \\left(\\frac{\\Delta}{2}\\right)^3 - \\left(-\\frac{\\Delta}{2}\\right)^3 \\right) = \\frac{1}{3\\Delta} \\left( \\frac{\\Delta^3}{8} + \\frac{\\Delta^3}{8} \\right) = \\frac{1}{3\\Delta} \\left( \\frac{2\\Delta^3}{8} \\right) = \\frac{\\Delta^2}{12}\n$$\n这是均匀分布量化噪声功率的著名结果。\n\n现在，我们确定输入信号的平均功率 $P_x$。信号是一个单音正弦波 $x(t) = A\\cos(\\omega_0 t)$。其平均功率是信号的均方值，在一个周期 $T_0 = 2\\pi/\\omega_0$ 内计算：\n$$\nP_x = \\frac{1}{T_0} \\int_{0}^{T_0} x^2(t) \\,dt = \\frac{1}{T_0} \\int_{0}^{T_0} \\left( A\\cos(\\omega_0 t) \\right)^2 \\,dt = \\frac{A^2}{T_0} \\int_{0}^{T_0} \\cos^2(\\omega_0 t) \\,dt\n$$\n使用三角恒等式 $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$：\n$$\nP_x = \\frac{A^2}{T_0} \\int_{0}^{T_0} \\frac{1}{2}(1 + \\cos(2\\omega_0 t)) \\,dt = \\frac{A^2}{2T_0} \\left[ t + \\frac{\\sin(2\\omega_0 t)}{2\\omega_0} \\right]_{0}^{T_0}\n$$\n正弦项在 $t=0$ 和 $t=T_0$ 处的值都为零。因此，表达式简化为：\n$$\nP_x = \\frac{A^2}{2T_0} (T_0) = \\frac{A^2}{2}\n$$\n\nSQNR 定义为信号功率与量化噪声功率之比：\n$$\n\\mathrm{SQNR} = \\frac{P_x}{P_q} = \\frac{A^2 / 2}{\\Delta^2 / 12} = \\frac{6A^2}{\\Delta^2}\n$$\n我们代入 $\\Delta$ 的表达式：\n$$\n\\mathrm{SQNR} = \\frac{6A^2}{\\left( \\frac{2A_{\\mathrm{FS}}}{2^B} \\right)^2} = \\frac{6A^2 \\cdot (2^B)^2}{4A_{\\mathrm{FS}}^2} = \\frac{3}{2} \\left( \\frac{A}{A_{\\mathrm{FS}}} \\right)^2 2^{2B}\n$$\n这是均匀量化器中正弦信号的 SQNR 通用表达式。\n\n现在我们将其转换为分贝 (dB) 并针对两种指定情况进行评估。分贝度量由 $10\\log_{10}(\\cdot)$ 给出。\n$$\n\\mathrm{SQNR}_{\\mathrm{dB}} = 10\\log_{10}(\\mathrm{SQNR}) = 10\\log_{10}\\left( \\frac{3}{2} \\left( \\frac{A}{A_{\\mathrm{FS}}} \\right)^2 2^{2B} \\right)\n$$\n利用对数的性质：\n$$\n\\mathrm{SQNR}_{\\mathrm{dB}} = 10\\log_{10}\\left(\\frac{3}{2}\\right) + 10\\log_{10}\\left(\\left(\\frac{A}{A_{\\mathrm{FS}}}\\right)^2\\right) + 10\\log_{10}\\left(2^{2B}\\right)\n$$\n$$\n\\mathrm{SQNR}_{\\mathrm{dB}} = 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20\\log_{10}\\left(\\frac{A}{A_{\\mathrm{FS}}}\\right) + 20B\\log_{10}(2)\n$$\n\n对于参考情况，正弦波使用全部峰值振幅，即 $A = A_{\\mathrm{FS}}$。\n$$\n\\mathrm{SQNR}_{\\mathrm{dB,ref}} = 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20\\log_{10}\\left(\\frac{A_{\\mathrm{FS}}}{A_{\\mathrm{FS}}}\\right) + 20B\\log_{10}(2)\n$$\n由于 $\\log_{10}(1)=0$，上式变为：\n$$\n\\mathrm{SQNR}_{\\mathrm{dB,ref}} = 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20B\\log_{10}(2)\n$$\n\n对于回退情况，振幅为 $A = \\gamma A_{\\mathrm{FS}}$，其中 $\\gamma \\in (0,1)$。\n$$\n\\mathrm{SQNR}_{\\mathrm{dB}}(\\gamma) = 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20\\log_{10}\\left(\\frac{\\gamma A_{\\mathrm{FS}}}{A_{\\mathrm{FS}}}\\right) + 20B\\log_{10}(2)\n$$\n$$\n\\mathrm{SQNR}_{\\mathrm{dB}}(\\gamma) = 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20\\log_{10}(\\gamma) + 20B\\log_{10}(2)\n$$\n\n最后，我们计算所需的分贝偏移 $\\Delta_{\\mathrm{dB}}$：\n$$\n\\Delta_{\\mathrm{dB}} = \\mathrm{SQNR}_{\\mathrm{dB}}(\\gamma) - \\mathrm{SQNR}_{\\mathrm{dB,ref}}\n$$\n$$\n\\Delta_{\\mathrm{dB}} = \\left( 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20\\log_{10}(\\gamma) + 20B\\log_{10}(2) \\right) - \\left( 10\\log_{10}\\left(\\frac{3}{2}\\right) + 20B\\log_{10}(2) \\right)\n$$\n除了包含 $\\gamma$ 的项之外，所有其他项都相互消去。\n$$\n\\Delta_{\\mathrm{dB}} = 20\\log_{10}(\\gamma)\n$$\n该表达式仅依赖于 $\\gamma$，符合要求。由于 $\\gamma \\in (0,1)$，$\\log_{10}(\\gamma)$ 是负数，这正确地表明回退信号振幅会降低 SQNR。", "answer": "$$\n\\boxed{20\\log_{10}(\\gamma)}\n$$", "id": "2898438"}, {"introduction": "理论模型是强大的，但真正的工程挑战在于处理不确定性和权衡。在第二个实践中，我们将面对一个更现实的设计问题：如何为一个具有统计特性（高斯分布）的输入信号设置最佳的前置增益。这项练习要求我们在最大化信噪比（$SQNR$）和控制削波（过载）概率之间找到最佳平衡点 [@problem_id:2898405]。通过解决这个约束优化问题，你将学会如何将工程直觉形式化，并理解在系统设计中增益设置的关键权衡。", "problem": "一个均值为零、方差为 $\\sigma_{x}^{2}$ 的宽平稳高斯随机过程 $x[n]$ 通过一个实数标量预增益 $g>0$，产生 $u[n]=g\\,x[n]$。序列 $u[n]$ 被送入一个具有 $B$ 比特、满量程范围为 $[-A, A]$ 的均匀、对称、中置踏板式饱和量化器。该量化器有 $2^{B}$ 个决策区间，覆盖 $[-A, A]$，因此步长为 $\\Delta = \\dfrac{2A}{2^{B}}$。量化器在 $[-A, A]$ 之外饱和。量化后，输出通过因子 $1/g$ 进行反缩放，以产生估计值 $\\hat{x}[n]=\\dfrac{1}{g}\\,Q(g\\,x[n])$。\n\n在无过载区域内，采用高分辨率颗粒噪声模型：对于未饱和的样本，量化器输入端的颗粒量化误差被建模为在 $[-\\Delta/2,\\Delta/2]$ 上独立、零均值、均匀分布，其方差为 $\\Delta^{2}/12$。系统设计者将信号-量化-噪声比（SQNR）定义为信号方差 $\\sigma_{x}^{2}$ 与仅输出颗粒噪声方差的比值（即，过载失真不计入 SQNR），同时施加硬约束，要求削波概率（过载概率）不得超过目标值 $\\varepsilon \\in (0,1)$：\n$$\n\\mathbb{P}\\!\\left(|g\\,x[n]|>A\\right)\\le \\varepsilon.\n$$\n\n仅使用第一性原理和所述的建模假设（不要使用任何预先推导的“捷径”公式来求解答案），执行以下操作：\n\n- 构建约束优化问题，其决策变量为 $g$，目标是最大化反缩放输出端的 SQNR。\n- 根据基本的单调性和建模假设，论证优化器相对于削波概率约束必须处于什么位置。\n- 针对高斯输入 $x[n]\\sim\\mathcal{N}(0,\\sigma_{x}^{2})$ 进行特化，求解该优化问题，得到关于 $A$、$\\sigma_{x}$ 和 $\\varepsilon$ 的最优预增益 $g^{\\star}$ 的闭式解。您可以使用由下式定义的高斯尾部概率函数（$Q$-函数）\n$$\nQ(z)=\\frac{1}{\\sqrt{2\\pi}}\\int_{z}^{\\infty}\\exp\\!\\left(-\\frac{t^{2}}{2}\\right)\\,\\mathrm{d}t,\n$$\n及其函数反函数 $Q^{-1}(\\cdot)$。\n\n将您的最终结果表示为 $g^{\\star}$ 的单一符号表达式。不需要进行数值计算，最终答案也不需要单位。", "solution": "所述问题构成了信号处理领域内一个有效的约束优化练习。我们将对其进行形式化分析。\n\n目标是最大化信号-量化-噪声比（SQNR）。信号功率给定为 $\\sigma_{x}^{2}$。需要考虑的噪声仅是输出颗粒噪声。量化器输入端的量化误差，我们记为 $e_{u}[n]$，由 $e_{u}[n] = Q(u[n]) - u[n]$ 给出，其中 $u[n] = g\\,x[n]$。在非饱和（颗粒）区域，即对于 $|u[n]| \\le A$，该误差被建模为一个在 $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ 上均匀分布的独立、零均值随机过程。因此，该颗粒误差的方差为 $\\sigma_{e_{u}}^{2} = \\frac{(\\Delta/2 - (-\\Delta/2))^{2}}{12} = \\frac{\\Delta^{2}}{12}$。\n\n最终输出为 $\\hat{x}[n] = \\frac{1}{g}Q(g\\,x[n])$。输出端的误差为 $\\hat{e}[n] = \\hat{x}[n] - x[n] = \\frac{1}{g}Q(g\\,x[n]) - x[n] = \\frac{1}{g} \\left( Q(g\\,x[n]) - g\\,x[n] \\right) = \\frac{1}{g}e_{u}[n]$。因此，输出颗粒噪声的方差 $\\sigma_{n_{q}}^{2}$ 与输入颗粒误差的方差通过一个因子 $\\frac{1}{g^2}$ 相关联：\n$$\n\\sigma_{n_{q}}^{2} = \\text{Var}\\left( \\frac{1}{g} e_{u}[n] \\right) = \\frac{1}{g^{2}} \\sigma_{e_{u}}^{2} = \\frac{\\Delta^{2}}{12g^{2}}.\n$$\n量化器步长给定为 $\\Delta = \\frac{2A}{2^{B}}$。将此代入噪声方差的表达式中，得到：\n$$\n\\sigma_{n_{q}}^{2} = \\frac{1}{12g^{2}} \\left( \\frac{2A}{2^{B}} \\right)^{2} = \\frac{4A^{2}}{12g^{2}(2^{B})^{2}} = \\frac{A^{2}}{3g^{2}2^{2B}}.\n$$\nSQNR 定义为信号方差与此输出颗粒噪声方差之比。\n$$\n\\text{SQNR}(g) = \\frac{\\sigma_{x}^{2}}{\\sigma_{n_{q}}^{2}} = \\frac{\\sigma_{x}^{2}}{A^{2}/(3g^{2}2^{2B})} = \\frac{3 \\cdot 2^{2B}\\sigma_{x}^{2}}{A^{2}} g^{2}.\n$$\n现在，我们构建约束优化问题。决策变量是预增益 $g$。目标是在削波概率约束下最大化 $\\text{SQNR}(g)$。\n$$\n\\underset{g>0}{\\text{maximize}} \\quad \\text{SQNR}(g) = \\left( \\frac{3 \\cdot 2^{2B}\\sigma_{x}^{2}}{A^{2}} \\right) g^{2}\n$$\n$$\n\\text{subject to} \\quad \\mathbb{P}\\left(|g\\,x[n]|>A\\right)\\le \\varepsilon.\n$$\n项 $\\frac{3 \\cdot 2^{2B}\\sigma_{x}^{2}}{A^{2}}$ 是一个正常数。因此，最大化 $\\text{SQNR}(g)$ 等价于最大化 $g^{2}$，或者因为 $g > 0$ 而等价于最大化 $g$。目标函数是关于 $g$ 严格单调递增的。\n\n让我们检查约束函数 $C(g) = \\mathbb{P}(|g\\,x[n]|>A) = \\mathbb{P}(|x[n]|>A/g)$。随着增益 $g$ 的增加，阈值 $A/g$ 减小。对于一个均值为零的连续随机变量 $x[n]$，其绝对值超过一个正阈值的概率 $\\mathbb{P}(|x[n]|>c)$ 是该阈值 $c$ 的单调递减函数。因此，随着 $g$ 的增加，$A/g$ 减小，这反过来导致 $C(g)$ 增加。所以，约束函数 $C(g)$ 是 $g$ 的单调递增函数。\n\n我们的任务是在一个由单调递增函数定义的上界约束下，最大化一个单调递增的目标函数。因此，最优解必须位于可行域的边界上，即不等式约束取等号的位置。任何小于该边界值的 $g$ 都会产生较小的 SQNR，而任何大于该边界值的 $g$ 都会违反约束。因此，最优增益 $g^{\\star}$ 必须满足：\n$$\n\\mathbb{P}\\left(|g^{\\star}\\,x[n]|>A\\right) = \\varepsilon.\n$$\n输入信号被指定为零均值高斯过程 $x[n]\\sim\\mathcal{N}(0,\\sigma_{x}^{2})$。为分析该概率，我们通过定义 $Z = x[n]/\\sigma_{x}$ 来标准化随机变量 $x[n]$，其中 $Z \\sim \\mathcal{N}(0,1)$ 是一个标准正态变量。约束方程变为：\n$$\n\\mathbb{P}\\left(\\left|\\frac{x[n]}{\\sigma_{x}}\\right| > \\frac{A}{g^{\\star}\\sigma_{x}}\\right) = \\varepsilon \\implies \\mathbb{P}\\left(|Z| > \\frac{A}{g^{\\star}\\sigma_{x}}\\right) = \\varepsilon.\n$$\n对于一个关于零对称的标准正态分布，其在两个尾部的概率由 $\\mathbb{P}(|Z|>z) = \\mathbb{P}(Z>z) + \\mathbb{P}(Z-z) = 2\\mathbb{P}(Z>z)$ 给出，对于任何 $z>0$。使用所提供的高斯尾部概率函数 $Q(z) = \\mathbb{P}(Z>z)$，该方程变为：\n$$\n2Q\\left(\\frac{A}{g^{\\star}\\sigma_{x}}\\right) = \\varepsilon.\n$$\n求解 $Q$-函数项，我们得到：\n$$\nQ\\left(\\frac{A}{g^{\\star}\\sigma_{x}}\\right) = \\frac{\\varepsilon}{2}.\n$$\n为求得 $Q$-函数的自变量，我们应用其函数反函数 $Q^{-1}(\\cdot)$：\n$$\n\\frac{A}{g^{\\star}\\sigma_{x}} = Q^{-1}\\left(\\frac{\\varepsilon}{2}\\right).\n$$\n最后，我们求解最优预增益 $g^{\\star}$：\n$$\ng^{\\star} = \\frac{A}{\\sigma_{x}Q^{-1}\\left(\\frac{\\varepsilon}{2}\\right)}.\n$$\n这个表达式以给定的参数 $A$、$\\sigma_{x}$ 和 $\\varepsilon$ 表示了最优增益，从而完成了推导。", "answer": "$$\\boxed{\\frac{A}{\\sigma_{x} Q^{-1}\\left(\\frac{\\varepsilon}{2}\\right)}}$$", "id": "2898405"}, {"introduction": "我们分析的基础——量化噪声模型，本身就是一个需要被审视的假设。最后一个实践将引导我们从理论分析转向经验验证，这是一个至关重要的科学步骤。你将设计并实现一个统计检验程序，以判断在不同条件下，量化误差是否真的如模型所假设的那样，是独立于输入信号的白噪声 [@problem_id:2898439]。这项计算性练习将理论与实践联系起来，让你掌握验证信号处理模型有效性的实用技能。", "problem": "给定两个有限长度的实值序列：一个测量输入序列，记为 $x = \\{x_n\\}_{n=0}^{N-1}$，以及一个测量量化误差序列，记为 $e = \\{e_n\\}_{n=0}^{N-1}$。信号处理中广泛使用的高分辨率量化模型假设量化误差是一个近似独立于输入的白噪声序列。您的任务是把这个假设形式化为一个可进行统计检验的复合零假设，并实现一个对给定数据进行操作的检验程序。\n\n将零假设表述如下：量化误差序列 $e$ 在有限滞后内是白噪声，并且与 $x$ 独立，即 $x$ 和 $e$ 之间的互相关在有限滞后内为零。您的检验必须结合两个部分：\n\n- 一个基于自相关的 $e$ 的白度检验，该检验将有限滞后内的样本自相关汇总为单个统计量，并将其与适当的渐近参考分布进行比较。\n- 一个基于互相关的 $x$ 和 $e$ 之间的独立性检验，该检验将有限滞后集上的样本互相关汇总为单个检验统计量，并使用一个保留 $e$ 时间结构的非参数零分布。\n\n决策规则必须是：如果在规定的显著性水平下，任一子检验拒绝原假设，则拒绝零假设。\n\n从协方差、自相关和独立性的核心定义出发，设计并实现以下内容：\n\n1. 定义 $e$ 在滞后 $k$ 处的样本自相关为\n$$\n\\hat{r}_{ee}[k] \\triangleq \\frac{\\sum_{n=k}^{N-1} (e_n - \\bar{e})(e_{n-k} - \\bar{e})}{\\sum_{n=0}^{N-1} (e_n - \\bar{e})^2},\n$$\n其中 $\\bar{e}$ 是 $e$ 的样本均值。使用这些样本自相关构建一个综合型（portmanteau-type）统计量，该统计量汇集了滞后 $k=1,\\dots,h_e$ 上的 $\\hat{r}_{ee}[k]^2$，并在 $e$ 是白噪声的假设下，将其与一个参考分布进行比较。聚合滞后 $h_e$ 必须选择为 $h_e = \\min(16, \\lfloor N/10 \\rfloor)$。\n\n2. 定义 $x$ 和 $e$ 之间在滞后 $k \\geq 0$ 处的样本互相关为\n$$\n\\hat{\\rho}_{xe}[k] \\triangleq \\frac{\\sum_{n=k}^{N-1} (x_{n-k} - \\bar{x})(e_n - \\bar{e})}{\\sqrt{\\sum_{n=0}^{N-1} (x_n - \\bar{x})^2} \\, \\sqrt{\\sum_{n=0}^{N-1} (e_n - \\bar{e})^2}},\n$$\n其中 $\\bar{x}$ 是 $x$ 的样本均值。将 $\\{ \\hat{\\rho}_{xe}[k] \\}_{k=0}^{h_{xe}}$ 汇集成最大绝对值统计量\n$$\nS \\triangleq \\max_{0 \\leq k \\leq h_{xe}} \\left| \\hat{\\rho}_{xe}[k] \\right|, \\quad h_{xe} = \\min(8, \\lfloor N/10 \\rfloor).\n$$\n使用一种置换方案（permutation scheme）为 $S$ 估计 $p$ 值，该方案通过对 $e$ 应用随机循环移位来保留 $e$ 的边际分布和序列相关性。具体来说，从 $\\{0,1,\\dots,N-1\\}$ 中均匀生成 $R$ 个独立的移位 $s^{(1)}, \\dots, s^{(R)}$，构成 $e^{(r)}_n = e_{(n-s^{(r)}) \\bmod N}$，计算相应的 $S^{(r)}$，并通过以下公式估计 $p$ 值：\n$$\n\\hat{p}_{xe} \\triangleq \\frac{1 + \\#\\{ r : S^{(r)} \\ge S \\}}{1 + R}.\n$$\n使用 $R = 499$ 次置换。\n\n3. 将白度 $p$ 值（记为 $\\hat{p}_{\\text{white}}$）和互相关 $p$ 值 $\\hat{p}_{xe}$ 组合成一个在显著性水平 $\\alpha = 0.01$ 下的联合检验：如果 $\\hat{p}_{\\text{white}}  \\alpha$ 或 $\\hat{p}_{xe}  \\alpha$，则拒绝零假设。\n\n此外，对每个测试案例，通过以下公式估计量化噪声功率和信号量化噪声比（signal-to-quantization-noise ratio）：\n$$\n\\widehat{P}_e = \\frac{1}{N} \\sum_{n=0}^{N-1} (e_n - \\bar{e})^2, \n\\qquad\n\\widehat{P}_x = \\frac{1}{N} \\sum_{n=0}^{N-1} (x_n - \\bar{x})^2,\n\\qquad\n\\widehat{\\mathrm{SQNR}} = 10 \\log_{10} \\left( \\frac{\\widehat{P}_x}{\\widehat{P}_e} \\right).\n$$\n\n实现上述检验并将其应用于以下测试套件。在每种情况下，通过定义一个位深度为 $B$、满幅值为 $A$ 的均匀中置（mid-tread）标量量化器来生成 $x$ 和 $e$，如下所示。令 $M = 2^B$，$\\Delta = 2A / M$，并将量化器输出定义为 $y_n = \\mathrm{clip}(\\Delta \\cdot \\mathrm{round}(x_n / \\Delta), -A, A)$，量化误差定义为 $e_n = y_n - x_n$。这里 $\\mathrm{clip}(u, -A, A)$ 将 $u$ 饱和到区间 $[-A, A]$ 内，$\\mathrm{round}(\\cdot)$ 表示四舍五入到最近的整数。正弦波中使用的角度必须是弧度。\n\n使用以下四种情况，每种情况都带有指定的随机种子以保证可复现性：\n\n- 情况1（高分辨率，无过载；预期不拒绝）：$N = 4096$, $A = 1.0$, $B = 12$, $x_n \\sim \\mathcal{N}(0, \\sigma_x^2)$ 独立同分布，其中 $\\sigma_x = A/6$，随机种子 $101$。\n- 情况2（存在过载；预期拒绝）：$N = 4096$, $A = 1.0$, $B = 6$, $x_n \\sim \\mathcal{N}(0, \\sigma_x^2)$ 独立同分布，其中 $\\sigma_x = A$，随机种子 $202$。\n- 情况3（正弦波的粗量化；预期拒绝）：$N = 4096$, $A = 1.0$, $B = 3$, $x_n = 0.95 A \\sin(2\\pi f_0 n / N)$，其中 $f_0 = 37$，确定性信号，角度为弧度。\n- 情况4（短样本，高分辨率；可能因功效有限而无法拒绝）：$N = 128$, $A = 1.0$, $B = 12$, $x_n \\sim \\mathcal{N}(0, \\sigma_x^2)$ 独立同分布，其中 $\\sigma_x = A/6$，随机种子 $404$。\n\n对于高斯输入的情况，使用指定的随机种子和一个现代伪随机数生成器来抽取样本。对于置换检验，使用同一个生成器，并设定一个固定的种子值 $99991$ 来生成随机循环移位。对于每种情况，计算：\n- 白度 $p$ 值 $\\hat{p}_{\\text{white}}$，\n- 互相关 $p$ 值 $\\hat{p}_{xe}$，\n- 在水平 $\\alpha = 0.01$ 下拒绝独立性加白度假设的组合决策，\n- 估计的信号量化噪声比 $\\widehat{\\mathrm{SQNR}}$（单位：分贝）。\n\n您的程序应生成单行输出，其中仅包含四种情况的组合决策，按顺序排列，格式为逗号分隔的 Python布尔值列表，并用方括号括起，例如，「[False,True,True,False]」。不允许有任何其他输出。任何辅助计算（如 $p$ 值和 $\\widehat{\\mathrm{SQNR}}$）都不得打印。", "solution": "该问题要求对常见的高分辨率量化模型假设进行形式化和实现一个统计检验。该模型假定，量化误差序列 $e= \\{e_n\\}_{n=0}^{N-1}$ 是一个独立于输入信号 $x = \\{x_n\\}_{n=0}^{N-1}$ 的白噪声序列。这被形式化为一个复合零假设 $H_0$，即 $e$ 在有限数量的滞后内是白噪声且与 $x$不相关。该检验结合了两个独立的统计程序：一个是针对误差序列 $e$ 的白度检验，另一个是针对 $x$ 和 $e$ 之间独立性的互相关检验。如果在给定的显著性水平 $\\alpha$ 下，任一子检验产生统计上显著的结果，则总体假设 $H_0$ 被拒绝。\n\n该程序设计如下：\n\n首先，对于每个测试案例，根据指定参数生成输入信号 $x = \\{x_n\\}_{n=0}^{N-1}$。对一个位深度为 $B$、满幅值为 $A$ 的均匀中置标量量化器进行建模。量化级别数为 $M = 2^B$，步长为 $\\Delta = 2A/M$。通过将 $x_n$ 映射到 $\\Delta$ 的最近倍数，然后将结果裁剪到范围 $[-A, A]$ 内，来生成量化信号 $y_n$。然后计算量化误差为 $e_n = y_n - x_n$。\n\n接下来进行由两部分组成的假设检验。\n\n1.  **量化误差 $e$ 的白度检验**：\n    此子检验的零假设 $H_{0,\\text{white}}$ 为序列 $\\{e_n\\}$ 是白噪声。这意味着其对于所有非零滞后的自相关均为零。我们使用 Ljung-Box 综合检验（portmanteau test）来检验这一点，该检验汇集了来自多个样本自相关的信息。\n    $e$ 在滞后 $k$ 处的样本自相关定义为：\n    $$\n    \\hat{r}_{ee}[k] \\triangleq \\frac{\\sum_{n=k}^{N-1} (e_n - \\bar{e})(e_{n-k} - \\bar{e})}{\\sum_{n=0}^{N-1} (e_n - \\bar{e})^2}\n    $$\n    其中 $\\bar{e}$ 是 $e$ 的样本均值。Ljung-Box 统计量 $Q$ 汇集了直至最大滞后 $h_e = \\min(16, \\lfloor N/10 \\rfloor)$ 的平方样本自相关：\n    $$\n    Q = N(N+2) \\sum_{k=1}^{h_e} \\frac{\\hat{r}_{ee}[k]^2}{N-k}\n    $$\n    在零假设 $H_{0,\\text{white}}$ 下，统计量 $Q$ 渐近地服从自由度为 $h_e$ 的卡方分布（chi-squared distribution），即 $Q \\sim \\chi^2(h_e)$。$p$ 值 $\\hat{p}_{\\text{white}}$ 是在假设 $H_{0,\\text{white}}$ 为真的情况下，观测到至少与从数据中计算出的检验统计量一样极端的统计量的概率：\n    $$\n    \\hat{p}_{\\text{white}} = P(\\chi^2(h_e) \\geq Q_{\\text{obs}})\n    $$\n    其中 $Q_{\\text{obs}}$ 是该统计量的观测值。一个小的 $p$ 值表明误差序列不是白噪声。\n\n2.  **$x$ 和 $e$ 之间独立性的互相关检验**：\n    此子检验的零假设 $H_{0,\\text{indep}}$ 为序列 $\\{x_n\\}$ 和 $\\{e_n\\}$ 不相关。我们通过检查它们的样本互相关来检验这一点。在滞后 $k \\ge 0$ 处的样本互相关定义为：\n    $$\n    \\hat{\\rho}_{xe}[k] \\triangleq \\frac{\\sum_{n=k}^{N-1} (x_{n-k} - \\bar{x})(e_n - \\bar{e})}{\\sqrt{\\sum_{n=0}^{N-1} (x_n - \\bar{x})^2} \\, \\sqrt{\\sum_{n=0}^{N-1} (e_n - \\bar{e})^2}}\n    $$\n    其中 $\\bar{x}$ 是 $x$ 的样本均值。检验统计量 $S$ 是从 $0$ 到 $h_{xe} = \\min(8, \\lfloor N/10 \\rfloor)$ 的一组滞后上的最大绝对互相关：\n    $$\n    S = \\max_{0 \\leq k \\leq h_{xe}} \\left| \\hat{\\rho}_{xe}[k] \\right|\n    $$\n    $S$ 的理论零分布是难以处理的。因此，采用非参数置换检验（nonparametric permutation test）来估计 $p$ 值。该方法通过打破 $x$ 和 $e$ 之间的时间关系来模拟零假设，同时保留 $e$ 内部的边际分布和序列相关结构。这是通过对原始序列 $e$ 应用独立的随机循环时移，生成 $R = 499$ 个置换后的误差序列 $\\{e^{(r)}_n\\}$ 来实现的。对于每个 $e^{(r)}$，计算一个新的统计量 $S^{(r)}$。$p$ 值 $\\hat{p}_{xe}$ 随后被估计为大于或等于原始观测统计量 $S$ 的置换统计量的比例：\n    $$\n    \\hat{p}_{xe} = \\frac{1 + \\#\\{ r : S^{(r)} \\ge S \\}}{1 + R}\n    $$\n    一个小的 $p$ 值表示输入信号和量化误差之间存在显著的相关性。\n\n3.  **组合决策规则**：\n    总体零假设 $H_0$ 是两个子假设的复合。我们执行一个联合检验：如果有证据反对白度或独立性中的任何一个，则拒绝 $H_0$。在显著性水平 $\\alpha = 0.01$ 下，决策规则是：如果 $\\hat{p}_{\\text{white}}  \\alpha$ 或 $\\hat{p}_{xe}  \\alpha$，则拒绝 $H_0$。\n\n最后，为使分析完整，使用基于样本均值的定义来估计信号功率 $\\widehat{P}_x$、量化噪声功率 $\\widehat{P}_e$ 和信号量化噪声比（$\\widehat{\\mathrm{SQNR}}$）：\n$$\n\\widehat{P}_x = \\frac{1}{N} \\sum_{n=0}^{N-1} (x_n - \\bar{x})^2, \\quad \\widehat{P}_e = \\frac{1}{N} \\sum_{n=0}^{N-1} (e_n - \\bar{e})^2, \\quad \\widehat{\\mathrm{SQNR}} = 10 \\log_{10} \\left( \\frac{\\widehat{P}_x}{\\widehat{P}_e} \\right)\n$$\n将此程序应用于四个指定的测试案例中的每一个，以确定标准量化模型假设是否成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run the hypothesis test for the four specified cases.\n    \"\"\"\n    \n    def quantize(x, A, B):\n        \"\"\"\n        Applies a uniform mid-tread scalar quantizer and computes the error.\n        \n        Args:\n            x (np.ndarray): Input signal.\n            A (float): Full-scale amplitude.\n            B (int): Bit-depth.\n            \n        Returns:\n            np.ndarray: Quantization error sequence e.\n        \"\"\"\n        M = 2**B\n        Delta = 2 * A / M\n        \n        # Quantize by rounding to the nearest multiple of Delta\n        x_quant_indices = np.round(x / Delta)\n        y = Delta * x_quant_indices\n        \n        # Clip to model saturation/overload\n        y = np.clip(y, -A, A)\n        \n        e = y - x\n        return e\n\n    def whiteness_test(e):\n        \"\"\"\n        Performs a Ljung-Box whiteness test on the error sequence e.\n        \n        Args:\n            e (np.ndarray): The error sequence.\n            \n        Returns:\n            float: The p-value of the test.\n        \"\"\"\n        N = len(e)\n        h_e = min(16, N // 10)\n        \n        e_mean = np.mean(e)\n        e_centered = e - e_mean\n        \n        var_e_denom = np.dot(e_centered, e_centered)\n        if var_e_denom == 0:\n            return 1.0 # No variance, cannot be non-white.\n\n        r_ee_sq_terms = []\n        for k in range(1, h_e + 1):\n            # Biased sample autocorrelation\n            num = np.dot(e_centered[k:], e_centered[:-k])\n            r_ee_k = num / var_e_denom\n            r_ee_sq_terms.append(r_ee_k**2 / (N - k))\n            \n        # Ljung-Box Q statistic\n        Q = N * (N + 2) * np.sum(r_ee_sq_terms)\n        \n        # p-value from chi-squared distribution\n        p_value = chi2.sf(Q, h_e)\n        \n        return p_value\n\n    def cross_correlation_test(x, e, R, perm_rng):\n        \"\"\"\n        Performs a permutation-based cross-correlation test.\n        \n        Args:\n            x (np.ndarray): The input signal.\n            e (np.ndarray): The error sequence.\n            R (int): Number of permutations.\n            perm_rng (np.random.Generator): Random number generator for permutations.\n            \n        Returns:\n            float: The p-value of the test.\n        \"\"\"\n        N = len(e)\n        h_xe = min(8, N // 10)\n        \n        x_mean = np.mean(x)\n        e_mean = np.mean(e)\n        x_centered = x - x_mean\n        e_centered = e - e_mean\n        \n        norm_factor = np.sqrt(np.dot(x_centered, x_centered) * np.dot(e_centered, e_centered))\n        if norm_factor == 0:\n            return 1.0\n\n        def compute_max_abs_rho(xc, ec, h, norm):\n            rhos_abs = []\n            for k in range(h + 1):\n                if k == 0:\n                    num = np.dot(xc, ec)\n                else:\n                    num = np.dot(xc[:-k], ec[k:])\n                rhos_abs.append(np.abs(num / norm))\n            return np.max(rhos_abs)\n\n        S_obs = compute_max_abs_rho(x_centered, e_centered, h_xe, norm_factor)\n        \n        # Permutation test\n        count = 0\n        shifts = perm_rng.integers(0, N, size=R)\n        for s_r in shifts:\n            e_perm_centered = np.roll(e_centered, s_r)\n            S_perm = compute_max_abs_rho(x_centered, e_perm_centered, h_xe, norm_factor)\n            if S_perm >= S_obs:\n                count += 1\n                \n        p_value = (1 + count) / (1 + R)\n        return p_value\n\n    test_cases = [\n        {'N': 4096, 'A': 1.0, 'B': 12, 'type': 'gaussian', 'sigma_x_factor': 1/6, 'seed': 101},\n        {'N': 4096, 'A': 1.0, 'B': 6,  'type': 'gaussian', 'sigma_x_factor': 1.0, 'seed': 202},\n        {'N': 4096, 'A': 1.0, 'B': 3,  'type': 'sinusoid', 'f0': 37, 'seed': None},\n        {'N': 128,  'A': 1.0, 'B': 12, 'type': 'gaussian', 'sigma_x_factor': 1/6, 'seed': 404},\n    ]\n\n    alpha = 0.01\n    R = 499\n    perm_seed = 99991\n    perm_rng = np.random.default_rng(perm_seed)\n    \n    results = []\n\n    for case in test_cases:\n        N, A, B = case['N'], case['A'], case['B']\n        \n        if case['type'] == 'gaussian':\n            rng = np.random.default_rng(case['seed'])\n            sigma_x = case['sigma_x_factor'] * A\n            x = rng.normal(loc=0.0, scale=sigma_x, size=N)\n        elif case['type'] == 'sinusoid':\n            f0 = case['f0']\n            n = np.arange(N)\n            x = 0.95 * A * np.sin(2 * np.pi * f0 * n / N)\n\n        e = quantize(x, A, B)\n        \n        p_white = whiteness_test(e)\n        p_xe = cross_correlation_test(x, e, R, perm_rng)\n\n        # Union test: reject if either p-value is below alpha\n        reject_H0 = (p_white  alpha) or (p_xe  alpha)\n        results.append(reject_H0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "2898439"}]}