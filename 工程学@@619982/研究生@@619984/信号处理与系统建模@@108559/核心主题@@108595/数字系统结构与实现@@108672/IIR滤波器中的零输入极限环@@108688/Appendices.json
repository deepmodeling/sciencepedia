{"hands_on_practices": [{"introduction": "理解零输入极限环首先要分析量化如何影响一个简单的一阶系统。本练习将引导你通过分步计算来追踪滤波器的状态，展示“舍入到最近”的规则如何将状态“困”在一个非零值上，从而形成一个稳定的不动点极限环。通过完成这个基础示例 [@problem_id:2917236]，你将对维持这些不必要振荡的核心机制获得一个具体的认识。", "problem": "考虑一个在反馈路径中进行量化且零输入下运行的一阶递归无限冲激响应 (IIR) 滤波器。其零输入动态由下式给出\n$$\ny[n] = Q(a \\cdot y[n-1]), \\quad n \\ge 0,\n$$\n初始条件为\n$$\ny[-1] = 3\\Delta,\n$$\n其中 $a \\in \\mathbb{R}$ 满足 $|a|<1$，$Q(\\cdot)$ 是一个步长为 $\\Delta>0$ 的中踏式均匀量化器，采用“舍入到最近，平局时取最近的偶数可表示值”的规则。量化器 $Q(\\cdot)$ 将任意实数 $x$ 映射到 $\\Delta$ 的最近倍数，即\n$$\nQ(x) = \\Delta \\cdot \\operatorname{round}_{\\mathrm{even}}\\left(\\frac{x}{\\Delta}\\right),\n$$\n其中 $\\operatorname{round}_{\\mathrm{even}}(u)$ 将 $u \\in \\mathbb{R}$ 舍入到最近的整数，并将半整数（平局情况）映射到最近的偶数整数。\n\n设 $a = 0.875$ 且 $\\Delta = 2^{-10}$。仅使用给定的定义和量化反馈在每次迭代中应用的假设，从第一性原理出发，确定序列 $\\{y[n]\\}_{n\\ge 0}$ 所达到的零输入极限环的最终周期和振幅。为此问题，定义周期为满足对所有足够大的 $n$ 都有 $y[n+P]=y[n]$ 的最小正整数 $P$，定义振幅为 $\\max_{0 \\le k < P} |y_{\\infty}[k]|$，其中 $\\{y_{\\infty}[k]\\}_{k=0}^{P-1}$ 是稳态轨道的一个周期。\n\n将您的最终答案表示为一个双元素行矩阵，依次包含周期（无量纲）和振幅（无物理单位）。无需舍入；请提供精确值。", "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n1.  系统动态：$y[n] \\;=\\; Q\\!\\big(a\\,y[n-1]\\big)$，对于 $n \\ge 0$。\n2.  初始条件：$y[-1] \\;=\\; 3\\,\\Delta$。\n3.  滤波器系数：$a = 0.875$。\n4.  量化器定义：$Q(x) \\;=\\; \\Delta \\cdot \\operatorname{round}_{\\mathrm{even}}\\!\\Big(\\frac{x}{\\Delta}\\Big)$。\n5.  量化器步长：$\\Delta = 2^{-10}$。\n6.  舍入规则：$\\operatorname{round}_{\\mathrm{even}}(u)$ 舍入到最近的整数，半整数则舍入到最近的偶数整数。\n7.  目标：确定零输入极限环的周期 $P$ 和振幅。\n\n验证结论：该问题具有科学依据、提法明确且客观。它描述了数字信号处理中由量化引起的极限环的标准情景。所有参数和定义均已提供，构成了一个完整且一致的问题陈述。不存在违反基本原理、逻辑矛盾或含糊不清之处。该问题有效。\n\n我们现在进行求解。滤波器的输出的递归关系由下式给出\n$$y[n] = Q(a\\,y[n-1])$$\n其中量化器 $Q(\\cdot)$ 将其输入映射到步长 $\\Delta$ 的最近整数倍。这意味着输出序列 $y[n]$ 只能取值于集合 $\\{k\\Delta \\mid k \\in \\mathbb{Z}\\}$。\n\n为了方便分析，我们引入一个定义为 $y[n] = k[n] \\Delta$ 的整值序列 $k[n]$。将此代入系统方程，我们得到：\n$$k[n]\\Delta = Q(a \\cdot k[n-1]\\Delta)$$\n使用量化器 $Q(x) = \\Delta \\cdot \\operatorname{round}_{\\mathrm{even}}(x/\\Delta)$ 的定义，我们有\n$$k[n]\\Delta = \\Delta \\cdot \\operatorname{round}_{\\mathrm{even}}\\!\\left(\\frac{a \\cdot k[n-1]\\Delta}{\\Delta}\\right)$$\n两边除以 $\\Delta$（因为 $\\Delta = 2^{-10} \\ne 0$），我们得到整值序列 $k[n]$ 的递推关系：\n$$k[n] = \\operatorname{round}_{\\mathrm{even}}\\!\\big(a \\cdot k[n-1]\\big)$$\n初始条件为 $y[-1] = 3\\Delta$，这对应于初始整数状态 $k[-1] = 3$。滤波器系数给定为 $a = 0.875$。\n\n我们现在从第一性原理出发，从 $n=0$ 的状态开始计算序列 $k[n]$（对于 $n \\ge 0$）。\n对于 $n=0$：\n舍入函数的参数为 $a \\cdot k[-1] = 0.875 \\cdot 3 = 2.625$。\n$$k[0] = \\operatorname{round}_{\\mathrm{even}}(2.625)$$\n值 $2.625$ 不是半整数，因此舍入规则简化为舍入到最近的整数。距离 $2.625$ 最近的整数是 $3$。\n因此，$k[0]=3$。\n\n现在我们计算 $n=1$ 时的状态：\n新状态 $k[0]=3$ 与前一个状态 $k[-1]=3$ 相同。递推关系的输入保持不变。\n$$k[1] = \\operatorname{round}_{\\mathrm{even}}(a \\cdot k[0]) = \\operatorname{round}_{\\mathrm{even}}(0.875 \\cdot 3) = \\operatorname{round}_{\\mathrm{even}}(2.625) = 3$$\n由于系统是确定性的，且状态已返回其先前的值，通过归纳法可以清楚地得出，状态将在所有后续迭代中保持不变。\n$$k[n] = 3 \\quad \\text{for all } n \\ge 0$$\n这意味着输出序列 $y[n]$ 对所有 $n \\ge 0$ 都是常数：\n$$y[n] = k[n]\\Delta = 3\\Delta \\quad \\text{for all } n \\ge 0$$\n序列 $\\{y[n]\\}_{n \\ge 0}$ 是 $\\{3\\Delta, 3\\Delta, 3\\Delta, \\dots\\}$。\n\n常数序列是周期序列。根据问题的定义，周期 $P$ 是使得对于所有足够大的 $n$ 都有 $y[n+P]=y[n]$ 成立的最小正整数。对于常数序列 $y[n]=3\\Delta$，我们有 $y[n+1]=3\\Delta=y[n]$ 对所有 $n \\ge 0$ 成立。满足此条件的最小正整数 $P$ 是 $P=1$。这样的极限环被称为不动点。\n\n稳态轨道是序列的重复部分，在本例中为单个值 $\\{3\\Delta\\}$。我们将此轨道的一个周期表示为 $\\{y_{\\infty}[k]\\}_{k=0}^{P-1}$。当 $P=1$ 时，该集合包含一个元素：\n$$y_{\\infty}[0] = 3\\Delta$$\n极限环的振幅定义为 $\\max_{0 \\le k < P} |y_{\\infty}[k]|$。当 $P=1$ 时，这变为：\n$$\\text{Amplitude} = \\max_{0 \\le k < 1} |y_{\\infty}[k]| = |y_{\\infty}[0]| = |3\\Delta|$$\n鉴于 $\\Delta = 2^{-10}$ 是一个正常数，振幅为 $3\\Delta$。\n$$\\text{Amplitude} = 3 \\cdot 2^{-10}$$\n\n总之，系统从初始条件 $y[-1]=3\\Delta$ 开始，立即进入一个值为 $3\\Delta$ 的不动点极限环。该极限环的周期为 $1$，其振幅为 $3\\Delta = 3 \\cdot 2^{-10}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 3 \\cdot 2^{-10}\n\\end{pmatrix}\n}\n$$", "id": "2917236"}, {"introduction": "虽然舍入会产生极限环，但其他的量化方案可以防止它们。本练习探讨了一个使用截断（truncation）的系统，该方法将小的信号值强制归零，从而在原点周围形成一个“死区”（deadband）。你的任务是分析并推导这个死区的大小，从而深入理解如何通过定点运算中的特定设计选择来抑制极限环 [@problem_id:2917263]。", "problem": "考虑一个以定点运算实现的零输入一阶无限冲激响应 (IIR) 滤波器：\n$$\ny[n] = Q(a \\cdot y[n-1]),\n$$\n其中 $a \\in \\mathbb{R}$ 且 $a \\neq 0$，$Q(\\cdot)$ 是一个步长为 $\\Delta>0$ 的均匀中升型定点量化器，它使用向零截断，并且在工作范围内不发生饱和。该量化器的定义为：\n$$\nQ(x) = \\Delta \\cdot \\mathrm{trunc}\\left(\\frac{x}{\\Delta}\\right),\n$$\n其中向零截断算子 $\\mathrm{trunc}(x)$ 满足：对于 $x \\ge 0$ 时，$\\mathrm{trunc}(x)=\\lfloor x \\rfloor$；对于 $x \\le 0$ 时，$\\mathrm{trunc}(x)=\\lceil x \\rceil$。在零输入极限环的背景下，原点周围的死区是一个非平凡区间，只要状态 $y[n-1]$ 位于该区间内，下一状态就会被量化为零，从而使原点成为一个吸收态。\n\n仅从上述定义出发，证明存在一个有限的死区区间 $(-\\delta,\\delta)$，使得对于所有 $y \\in (-\\delta,\\delta)$ 都有 $Q(a\\,y)=0$，并以 $a$ 和 $\\Delta$ 的函数形式计算 $\\delta$ 的闭式表达式。你的最终答案必须是 $\\delta$ 的一个无单位的单一闭式解析表达式。不需要也不允许进行数值取整。", "solution": "该问题要求推导一个具有特定基于截断的量化器的一阶IIR滤波器的死区区间 $(-\\delta, \\delta)$。死区被定义为能使后续状态被量化为零的状态值 $y$ 的范围。\n\n首先，我们必须确定量化器输出 $Q(x)$ 为零的条件。该量化器的定义为：\n$$\nQ(x) = \\Delta \\,\\mathrm{trunc}\\!\\left(\\frac{x}{\\Delta}\\right)\n$$\n其中 $\\Delta > 0$。要使 $Q(x)$ 等于 $0$，鉴于 $\\Delta \\neq 0$，其充要条件是截断项为零：\n$$\n\\mathrm{trunc}\\!\\left(\\frac{x}{\\Delta}\\right) = 0\n$$\n\n我们必须分析分段定义的截断函数 $\\mathrm{trunc}(z)$ 的行为。令函数的自变量为 $z = x/\\Delta$。\n\n情况1：自变量为非负，$z \\ge 0$。\n函数定义为 $\\mathrm{trunc}(z) = \\lfloor z \\rfloor$。条件 $\\lfloor z \\rfloor = 0$ 成立的充要条件是 $0 \\le z < 1$。\n\n情况2：自变量为非正，$z \\le 0$。\n函数定义为 $\\mathrm{trunc}(z) = \\lceil z \\rceil$。条件 $\\lceil z \\rceil = 0$ 成立的充要条件是 $-1 < z \\le 0$。\n\n结合这两种不相交的情况，条件 $\\mathrm{trunc}(z) = 0$ 对于开区间 $(-1, 1)$ 内的任何 $z$ 都满足。即：\n$$\n\\mathrm{trunc}(z) = 0 \\iff -1 < z < 1\n$$\n将 $z = x/\\Delta$ 代入此不等式，我们得到使量化器输出为零的输入 $x$ 的范围：\n$$\n-1 < \\frac{x}{\\Delta} < 1\n$$\n由于 $\\Delta$ 是一个正常数 ($\\Delta > 0$)，我们可以将不等式的所有部分都乘以 $\\Delta$ 而不改变不等号的方向：\n$$\n-\\Delta < x < \\Delta\n$$\n这个区间 $(-\\Delta, \\Delta)$ 代表了所有被量化器映射到 $0$ 的输入的集合。\n\n现在，我们将此结果应用于给定的IIR滤波器方程 $y[n] = Q(a\\,y[n-1])$。问题要求的是状态值（我们用 $y$ 表示，在递归公式中等价于 $y[n-1]$）的死区。量化器的输入是 $x = a \\cdot y$。为使下一状态为零，该输入必须位于区间 $(-\\Delta, \\Delta)$ 内：\n$$\n-\\Delta < a \\cdot y < \\Delta\n$$\n为了找到 $y$ 的区间，我们必须除以系数 $a$。问题指明 $a \\neq 0$。我们必须考虑 $a$ 的符号。\n\n情况A：$a > 0$。\n将不等式除以一个正数，不等号方向保持不变：\n$$\n-\\frac{\\Delta}{a} < y < \\frac{\\Delta}{a}\n$$\n$y$ 的死区区间是 $(-\\frac{\\Delta}{a}, \\frac{\\Delta}{a})$。\n\n情况B：$a < 0$。\n将不等式除以一个负数，不等号方向反转：\n$$\n\\frac{-\\Delta}{a} > y > \\frac{\\Delta}{a}\n$$\n这等价于写作：\n$$\n\\frac{\\Delta}{a} < y < -\\frac{\\Delta}{a}\n$$\n$y$ 的死区区间是 $(\\frac{\\Delta}{a}, -\\frac{\\Delta}{a})$。\n\n问题陈述将死区定义为一个对称区间 $(-\\delta, \\delta)$，这意味着 $\\delta > 0$。我们必须找到与两种情况都一致的 $\\delta$ 的表达式。\n\n在情况A ($a>0$) 中，我们将 $(-\\frac{\\Delta}{a}, \\frac{\\Delta}{a})$ 与 $(-\\delta, \\delta)$ 进行比较。这得出 $\\delta = \\frac{\\Delta}{a}$。由于 $a>0$，我们可以将其写作 $\\delta = \\frac{\\Delta}{|a|}$。\n\n在情况B ($a<0$) 中，我们将 $(\\frac{\\Delta}{a}, -\\frac{\\Delta}{a})$ 与 $(-\\delta, \\delta)$ 进行比较。这得出 $\\delta = -\\frac{\\Delta}{a}$。由于 $a<0$，我们有 $|a|=-a$，所以我们可以将其写作 $\\delta = \\frac{\\Delta}{-a} = \\frac{\\Delta}{|a|}$。\n\n两种情况都得出了 $\\delta$ 的相同闭式表达式。该区间的存在性得到了证明，因为对于任何 $a \\neq 0$ 和 $\\Delta > 0$，$\\delta = \\frac{\\Delta}{|a|}$ 是一个有限正数，它定义了一个非平凡区间 $(-\\delta, \\delta)$。任何处于此区间内的状态 $y$ 都会导致其后继状态为 $0$，在没有输入的情况下，系统将不再从此状态演化。\n\n因此，$\\delta$ 的值被唯一地确定为 $a$ 和 $\\Delta$ 的函数。", "answer": "$$\\boxed{\\frac{\\Delta}{|a|}}$$", "id": "2917263"}, {"introduction": "除了由量化粒度引起的“小尺度”极限环外，数字滤波器还可能因算术溢出而遭受“大尺度”的振荡。本练习要求你将一个带有回绕（wrap-around）算术的二阶滤波器建模为一个有限状态机，并通过直接枚举来计算其溢出极限环的周期。这种计算实践将状态转移的抽象理论与在定点硬件中实现数字滤波器的具体现实联系起来 [@problem_id:2917290]。", "problem": "给定一个以直接II型（转置）结构实现的离散时间二阶无限冲激响应（IIR）滤波器。该滤波器在零输入和定点二进制补码环绕算术下运行。任务是通过显式地对状态转移进行建模并枚举周期长度，来构造并验证一个长周期的零输入溢出极限环。您的推导和实现必须从第一性原理出发：即滤波器结构、状态更新和算术模型的定义。\n\n考虑标准的二阶IIR差分方程\n$$\ny[n] = b_0 x[n] + b_1 x[n-1] + b_2 x[n-2] - a_1 y[n-1] - a_2 y[n-2],\n$$\n该方程以直接II型（转置）双二阶形式实现。定义两个内部状态如下：在时间索引 $n$ ，令 $v_1[n]$ 和 $v_2[n]$ 表示转置形式中两个单位延迟的输出。在对所有 $n$ 均为零输入 $x[n] = 0$ 的条件下，并假设所有加法和乘法都以 $W$ 位固定字长的有符号二进制补码环绕算术（即在每次线性运算后应用模 $2^W$ 算术）执行，状态更新简化为以下线性时不变映射：\n$$\n\\begin{bmatrix}\nv_1[n] \\\\\nv_2[n]\n\\end{bmatrix}\n\\equiv\n\\begin{bmatrix}\n-a_1 & 1 \\\\\n-a_2 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nv_1[n-1] \\\\\nv_2[n-1]\n\\end{bmatrix}\n\\ \\ \\ (\\mathrm{mod}\\ 2^W),\n$$\n且输出满足 $y[n] \\equiv v_1[n-1]\\ (\\mathrm{mod}\\ 2^W)$。此处，$a_1$ 和 $a_2$ 是恒定的滤波器反馈系数，在所选的定点格式中被量化为精确整数，并且所有算术运算均以模 $2^W$ 环绕方式执行。这在 $2^{2W}$ 个可能的状态对 $(v_1,v_2)$ 的集合上导出一个有限状态机，其有向状态转移图中每个节点的出度均为1。\n\n您的任务是构造一个显式的示例族，这些示例可被证明因环绕而产生长周期的零输入极限环，并通过从指定的初始状态开始，沿轨迹枚举状态转移图来计算确切的周期。您必须遵守以下规定：\n\n- 使用直接II型（转置）结构、环绕算术模型和有限状态确定性动力学的基本定义。除这些以及关于模2的幂的算术的经过充分检验的数论事实外，不要假设任何高级性质。\n\n- 完全按照给定的方式实现状态更新，在每次线性运算后应用模 $2^W$ 环绕。所有计算都是纯粹的模 $2^W$ 无量纲整数；不存在物理单位或角度。\n\n- 对于每个测试用例，从给定的初始状态开始迭代状态转移，直到遇到第一个重复状态，并将检测到的周期长度报告为周期。每个测试用例的答案必须是单个整数。\n\n构建并分析以下五个测试用例，它们实例化了具有经选择以呈现长周期的系数的同一滤波器族。在所有情况下，取 $a_1 = 0$ 和 $a_2 = -25$，并使用零输入 $x[n] = 0$。初始状态 $(v_1[0], v_2[0])$ 按指示选择。状态对 $(v_1[0], v_2[0])$ 被指定为模 $2^W$ 约简后的整数。\n\n- 测试用例1（理想路径，小字长）：$W = 8$, $(v_1[0], v_2[0]) = (1, 5)$。\n- 测试用例2（中等字长）：$W = 12$, $(v_1[0], v_2[0]) = (1, 5)$。\n- 测试用例3（目标字长）：$W = 16$, $(v_1[0], v_2[0]) = (1, 5)$。\n- 测试用例4（边界情况，初始状态为偶数且位于同一不变子空间上）：$W = 16$, $(v_1[0], v_2[0]) = (2, 10)$。\n- 测试用例5（边界情况，偏离特征子空间）：$W = 16$, $(v_1[0], v_2[0]) = (1, 0)$。\n\n您的程序必须为每个测试用例计算所得零输入极限环的整数周期，方法是显式枚举轨迹直到遇到最早的重复状态。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，[$p_1,p_2,p_3,p_4,p_5$]）。\n\n问题陈述中不允许出现提示、快捷公式或预先推导的周期表达式。任何推导都必须源于上述基本原理。本问题陈述中的所有数学符号、变量、运算符和数字均已按要求使用LaTeX定界符表示。", "solution": "该问题要求计算一个特定的二阶数字滤波器中零输入极限环的周期。该滤波器由其在二进制补码环绕算术下的状态空间表示定义，这在数学上等价于整数环（模一个2的幂）上的线性代数。该问题定义明确，并在数字信号处理领域具有坚实的科学基础。\n\n首先，我们对系统动力学进行形式化。系统在时间步 $n$ 的状态由向量 $\\mathbf{v}[n] = \\begin{pmatrix} v_1[n] \\\\ v_2[n] \\end{pmatrix}$ 给出。状态的演化由以下线性递推关系描述：\n$$\n\\begin{pmatrix}\nv_1[n] \\\\\nv_2[n]\n\\end{pmatrix}\n\\equiv\n\\mathbf{A}\n\\begin{pmatrix}\nv_1[n-1] \\\\\nv_2[n-1]\n\\end{pmatrix}\n\\pmod{2^W}\n$$\n其中 $W$ 是字长，$\\mathbf{A}$ 是状态转移矩阵。问题提供了系数 $a_1 = 0$ 和 $a_2 = -25$。直接II型转置结构的状态转移矩阵为：\n$$\n\\mathbf{A} = \\begin{pmatrix} -a_1 & 1 \\\\ -a_2 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 \\\\ 25 & 0 \\end{pmatrix}\n$$\n算术运算以模 $M = 2^W$ 进行。因此，每个分量的状态更新方程为：\n$$\nv_1[n] \\equiv v_2[n-1] \\pmod{2^W}\n$$\n$$\nv_2[n] \\equiv 25 \\cdot v_1[n-1] \\pmod{2^W}\n$$\n系统的状态空间是有限的，包含 $M^2 = (2^W)^2 = 2^{2W}$ 个可能的状态。状态转移是一个确定性函数，将每个状态映射到一个唯一的下一状态。此外，转移矩阵 $\\mathbf{A}$ 的行列式为 $\\det(\\mathbf{A}) = (0)(0) - (1)(25) = -25$。由于 $-25$ 是一个奇数，它与任何2的幂 $M = 2^W$ 互质。这保证了矩阵 $\\mathbf{A}$ 在整数环 $\\mathbb{Z}_{M}$ 上是可逆的。因此，状态转移映射是有限状态空间上的一个置换。这意味着任何状态轨迹都是一个纯粹的循环，没有引入部分。\n\n问题要求针对给定的初始状态，找出此循环的周期。周期定义为满足 $\\mathbf{v}[p] = \\mathbf{v}[0]$ 的最小正整数 $p$。基于上述原理，一个直接且严谨的方法是执行状态轨迹的显式枚举。\n\n算法如下：\n1. 对于每个由字长 $W$ 和初始状态 $\\mathbf{v}[0] = (v_1[0], v_2[0])$ 指定的测试用例，设置模数 $M = 2^W$。\n2. 初始化周期计数器 $p$ 为 0。\n3. 存储初始状态 $\\mathbf{v}_{init} = \\mathbf{v}[0]$。设当前状态为 $\\mathbf{v}_{curr}$，初始化为 $\\mathbf{v}_{init}$。\n4. 进入一个循环，重复应用状态转移并递增周期计数器：\n    a. 递增 $p \\leftarrow p + 1$。\n    b. 使用更新方程从 $\\mathbf{v}_{curr}$ 计算下一个状态 $\\mathbf{v}_{next}$：\n       $v_{1,next} = v_{2,curr}$\n       $v_{2,next} = (25 \\cdot v_{1,curr}) \\pmod{M}$\n    c. 更新当前状态：$\\mathbf{v}_{curr} \\leftarrow \\mathbf{v}_{next}$。\n    d. 将当前状态 $\\mathbf{v}_{curr}$ 与初始状态 $\\mathbf{v}_{init}$进行比较。如果它们相同，则循环完成。循环终止。\n5. 计数器 $p$ 的最终值就是极限环的周期。\n\n对五个指定的测试用例中的每一个执行此过程。实现将使用精确的整数算术和模运算符来正确模拟环绕行为。不使用任何高级数论结果，严格遵守问题中从第一性原理推导和枚举的约束。", "answer": "```python\n# The final answer must be a single, complete, standalone program.\n# This program computes the period of zero-input limit cycles\n# in a second-order IIR filter by explicit state enumeration.\n\n# No external libraries beyond the Python standard library are required.\n# The `numpy` and `scipy` specifications in the prompt are noted,\n# but not necessary for this solution.\n\ndef compute_period(W, v1_0, v2_0):\n    \"\"\"\n    Computes the limit cycle period for a given filter configuration.\n\n    Args:\n        W (int): The fixed-point word length in bits.\n        v1_0 (int): The initial value of the first state variable.\n        v2_0 (int): The initial value of the second state variable.\n\n    Returns:\n        int: The period of the zero-input limit cycle.\n    \"\"\"\n    # The modulus for wrap-around arithmetic is 2^W.\n    # Using bit shift for efficiency.\n    modulus = 1 << W\n\n    # The filter coefficients are a1=0, a2=-25.\n    # The state transition matrix is [[0, 1], [25, 0]].\n    # v1[n] = v2[n-1]\n    # v2[n] = 25 * v1[n-1]\n    feedback_coeff = 25\n\n    # Store the initial state to detect when the cycle completes.\n    v_initial = (v1_0, v2_0)\n    v_current = v_initial\n    \n    period = 0\n    while True:\n        period += 1\n        \n        # Unpack current state\n        v1_curr, v2_curr = v_current\n        \n        # Apply the state transition equations with modulo arithmetic\n        v1_next = v2_curr\n        v2_next = (feedback_coeff * v1_curr) % modulus\n        \n        v_current = (v1_next, v2_next)\n        \n        # A cycle is completed when the state returns to its initial value.\n        # Since the state transition is a permutation, the first repeated\n        # state will be the initial state.\n        if v_current == v_initial:\n            return period\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (W, v1[0], v2[0]).\n    test_cases = [\n        (8, 1, 5),   # Test case 1\n        (12, 1, 5),  # Test case 2\n        (16, 1, 5),  # Test case 3\n        (16, 2, 10), # Test case 4\n        (16, 1, 0),  # Test case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        W, v1_0, v2_0 = case\n        period = compute_period(W, v1_0, v2_0)\n        results.append(period)\n\n    # Final print statement must be in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2917290"}]}