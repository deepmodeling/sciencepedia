{"hands_on_practices": [{"introduction": "在数字系统中，乘法运算无处不在。然而，在何时进行量化——是在乘法之前对操作数进行量化，还是在乘法之后对乘积进行量化——会对最终的系统精度产生截然不同的影响。本练习将通过对两种架构的均方误差（$MSE$）进行严谨的推导和比较，帮助您从根本上理解量化噪声如何引入和传播，并揭示在定点运算中设计决策的重要性 [@problem_id:2893694]。", "problem": "考虑两个独立的、零均值的、无量纲的、广义平稳的实值随机变量 $a$ 和 $b$，其有限方差分别为 $\\sigma_{a}^{2} = \\mathbb{E}[a^{2}]$ 和 $\\sigma_{b}^{2} = \\mathbb{E}[b^{2}]$。要求您比较两种用于产生精确乘积 $z = a b$ 的近似值的架构：\n\n1. 乘法前操作数量化：操作数分别通过步长为 $\\Delta_{a}$ 和 $\\Delta_{b}$ 的中置步长均匀舍入量化器 $Q_{a}$ 和 $Q_{b}$，得到 $a_{q} = Q_{a}(a)$ 和 $b_{q} = Q_{b}(b)$，输出为 $y_{\\mathrm{pre}} = a_{q} b_{q}$。\n\n2. 精确乘法后乘积量化：先计算出精确乘积 $z = a b$，然后由步长为 $\\Delta_{z}$ 的中置步长均匀舍入量化器 $Q_{z}$ 对其进行量化，得到 $y_{\\mathrm{post}} = Q_{z}(z)$。\n\n假设在高分辨率条件下，对每个量化器采用加性噪声模型：$Q_{x}(x) = x + e_{x}$，其中 $e_{x}$ 是信号 $x \\in \\{a,b,z\\}$ 的量化误差。对每个 $x$，将 $e_{x}$ 建模为与 $x$ 及其他误差过程独立、零均值，且在 $[-\\Delta_{x}/2, \\Delta_{x}/2]$ 上均匀分布。具体来说，$\\mathbb{E}[e_{x}] = 0$ 且 $\\mathbb{E}[e_{x}^{2}] = \\Delta_{x}^{2}/12$。\n\n将每种架构相对于精确乘积 $z = a b$ 的总输出均方误差（MSE）定义为 $J_{\\mathrm{pre}} = \\mathbb{E}\\big[(y_{\\mathrm{pre}} - z)^{2}\\big]$ 和 $J_{\\mathrm{post}} = \\mathbb{E}\\big[(y_{\\mathrm{post}} - z)^{2}\\big]$。在计算中保留到量化步长的二阶项，这意味着您必须保留最高为两个量化方差乘积的项（例如，与 $\\Delta_{a}^{2} \\Delta_{b}^{2}$ 成比例的项），并可以忽略任何更高阶的项。\n\n请根据第一性原理和所述假设，推导两种架构输出MSE之差\n$$\n\\Delta J \\triangleq J_{\\mathrm{pre}} - J_{\\mathrm{post}},\n$$\n的闭式解析表达式，该表达式是关于 $\\sigma_{a}^{2}$、$\\sigma_{b}^{2}$、$\\Delta_{a}$、$\\Delta_{b}$ 和 $\\Delta_{z}$ 的函数。请将最终答案表示为单个简化的符号表达式。无需单位。", "solution": "该问题要求对乘法运算中两种不同量化架构的均方误差（MSE）进行比较分析。给定两个独立的、零均值的、广义平稳的随机变量 $a$ 和 $b$，其方差分别为 $\\sigma_{a}^{2}$ 和 $\\sigma_{b}^{2}$。目标是推导 $\\Delta J = J_{\\mathrm{pre}} - J_{\\mathrm{post}}$ 的表达式，其中 $J_{\\mathrm{pre}}$ 和 $J_{\\mathrm{post}}$ 分别是乘法前量化和乘法后量化的MSE。我们将遵循所提供的量化加性噪声模型，并保留到量化方差的二阶项，来分别推导每种MSE的表达式。\n\n首先，我们分析乘法后量化架构。精确乘积为 $z = ab$。该乘积被量化以产生输出 $y_{\\mathrm{post}} = Q_{z}(z)$。根据加性噪声模型，我们可以写出 $y_{\\mathrm{post}} = z + e_{z}$，其中 $e_{z}$ 是与量化器 $Q_{z}$ 相关的量化误差。该误差的属性为 $\\mathbb{E}[e_{z}] = 0$ 和 $\\mathbb{E}[e_{z}^{2}] = \\frac{\\Delta_{z}^{2}}{12}$。\n\n该架构的MSE $J_{\\mathrm{post}}$ 是相对于精确乘积 $z$ 定义的：\n$$\nJ_{\\mathrm{post}} = \\mathbb{E}\\big[(y_{\\mathrm{post}} - z)^{2}\\big]\n$$\n代入 $y_{\\mathrm{post}}$ 的表达式，我们得到：\n$$\nJ_{\\mathrm{post}} = \\mathbb{E}\\big[((z + e_{z}) - z)^{2}\\big] = \\mathbb{E}[e_{z}^{2}]\n$$\n使用给定的量化误差方差，我们得到后量化情况下的 MSE：\n$$\nJ_{\\mathrm{post}} = \\frac{\\Delta_{z}^{2}}{12}\n$$\n在所述模型假设下，此结果是精确的。\n\n接下来，我们分析乘法前量化架构。操作数 $a$ 和 $b$ 首先被量化，得到 $a_{q} = Q_{a}(a)$ 和 $b_{q} = Q_{b}(b)$。使用加性噪声模型，我们有：\n$$\na_{q} = a + e_{a}\n$$\n$$\nb_{q} = b + e_{b}\n$$\n其中 $e_{a}$ 和 $e_{b}$ 是各自的量化误差。它们的属性为 $\\mathbb{E}[e_{a}] = 0$, $\\mathbb{E}[e_{a}^{2}] = \\frac{\\Delta_{a}^{2}}{12}$, $\\mathbb{E}[e_{b}] = 0$, 和 $\\mathbb{E}[e_{b}^{2}] = \\frac{\\Delta_{b}^{2}}{12}$。问题说明误差过程彼此独立，且与信号独立。\n\n该架构的输出是量化后操作数的乘积：\n$$\ny_{\\mathrm{pre}} = a_{q} b_{q} = (a + e_{a})(b + e_{b}) = ab + a e_{b} + b e_{a} + e_{a} e_{b}\n$$\nMSE $J_{\\mathrm{pre}}$ 是该输出与精确乘积 $z = ab$ 之间差的平方的期望值：\n$$\ny_{\\mathrm{pre}} - z = (ab + a e_{b} + b e_{a} + e_{a} e_{b}) - ab = a e_{b} + b e_{a} + e_{a} e_{b}\n$$\n$$\nJ_{\\mathrm{pre}} = \\mathbb{E}\\big[(y_{\\mathrm{pre}} - z)^{2}\\big] = \\mathbb{E}\\big[(a e_{b} + b e_{a} + e_{a} e_{b})^{2}\\big]\n$$\n为了计算这个期望值，我们展开平方项：\n$$\n(a e_{b} + b e_{a} + e_{a} e_{b})^{2} = a^{2}e_{b}^{2} + b^{2}e_{a}^{2} + e_{a}^{2}e_{b}^{2} + 2ab e_{a} e_{b} + 2a e_{a} e_{b}^{2} + 2b e_{a}^{2} e_{b}\n$$\n现在，我们利用 $a, b, e_{a}, e_{b}$ 的相互独立性，以及它们都是零均值信号（除了它们的方差外）这一事实，逐项计算该表达式的期望值。\n\n对角项的期望值为：\n$$\n\\mathbb{E}[a^{2}e_{b}^{2}] = \\mathbb{E}[a^{2}]\\mathbb{E}[e_{b}^{2}] = \\sigma_{a}^{2} \\frac{\\Delta_{b}^{2}}{12}\n$$\n$$\n\\mathbb{E}[b^{2}e_{a}^{2}] = \\mathbb{E}[b^{2}]\\mathbb{E}[e_{a}^{2}] = \\sigma_{b}^{2} \\frac{\\Delta_{a}^{2}}{12}\n$$\n$$\n\\mathbb{E}[e_{a}^{2}e_{b}^{2}] = \\mathbb{E}[e_{a}^{2}]\\mathbb{E}[e_{b}^{2}] = \\left(\\frac{\\Delta_{a}^{2}}{12}\\right)\\left(\\frac{\\Delta_{b}^{2}}{12}\\right) = \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144}\n$$\n交叉乘积项的期望值，它们都至少包含一个零均值随机变量的一阶矩：\n$$\n\\mathbb{E}[2ab e_{a} e_{b}] = 2\\mathbb{E}[a]\\mathbb{E}[b]\\mathbb{E}[e_{a}]\\mathbb{E}[e_{b}] = 2(0)(0)(0)(0) = 0\n$$\n$$\n\\mathbb{E}[2a e_{a} e_{b}^{2}] = 2\\mathbb{E}[a]\\mathbb{E}[e_{a}]\\mathbb{E}[e_{b}^{2}] = 2(0)(0)\\left(\\frac{\\Delta_{b}^{2}}{12}\\right) = 0\n$$\n$$\n\\mathbb{E}[2b e_{a}^{2} e_{b}] = 2\\mathbb{E}[b]\\mathbb{E}[e_{a}^{2}]\\mathbb{E}[e_{b}] = 2(0)\\left(\\frac{\\Delta_{a}^{2}}{12}\\right)(0) = 0\n$$\n将所有项的期望值相加，得到预量化情况下的总 MSE：\n$$\nJ_{\\mathrm{pre}} = \\sigma_{a}^{2} \\frac{\\Delta_{b}^{2}}{12} + \\sigma_{b}^{2} \\frac{\\Delta_{a}^{2}}{12} + \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144}\n$$\n该表达式与保留到量化方差二阶项（即，形如 $\\Delta_{a}^{2}\\Delta_{b}^{2}$ 的乘积）的要求一致。\n\n最后，我们计算两种架构之间的 MSE 之差 $\\Delta J = J_{\\mathrm{pre}} - J_{\\mathrm{post}}$：\n$$\n\\Delta J = \\left( \\sigma_{a}^{2} \\frac{\\Delta_{b}^{2}}{12} + \\sigma_{b}^{2} \\frac{\\Delta_{a}^{2}}{12} + \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144} \\right) - \\left( \\frac{\\Delta_{z}^{2}}{12} \\right)\n$$\n为了将其表示为单个简化的表达式，我们取公分母 144：\n$$\n\\Delta J = \\frac{12\\sigma_{a}^{2} \\Delta_{b}^{2}}{144} + \\frac{12\\sigma_{b}^{2} \\Delta_{a}^{2}}{144} + \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144} - \\frac{12\\Delta_{z}^{2}}{144}\n$$\n$$\n\\Delta J = \\frac{12(\\sigma_{a}^{2} \\Delta_{b}^{2} + \\sigma_{b}^{2} \\Delta_{a}^{2} - \\Delta_{z}^{2}) + \\Delta_{a}^{2}\\Delta_{b}^{2}}{144}\n$$\n该表达式表示在指定假设下，预量化方案和后量化方案之间的均方误差之差。", "answer": "$$\n\\boxed{\\frac{12(\\sigma_{a}^{2} \\Delta_{b}^{2} + \\sigma_{b}^{2} \\Delta_{a}^{2} - \\Delta_{z}^{2}) + \\Delta_{a}^{2}\\Delta_{b}^{2}}{144}}\n$$", "id": "2893694"}, {"introduction": "理论分析的最终目的是指导实际的系统设计。本练习将理论应用于一个经典的二阶无限冲激响应（IIR）滤波器，这是一个在许多信号处理应用中广泛使用的基本模块。您将需要综合考虑两个核心问题：如何通过缩放（Scaling）来防止内部运算的溢出，以及如何精确计算由定点乘法引入的量化噪声，并最终评估系统的信噪比（$SNR$）[@problem_id:2893769]。", "problem": "考虑一个因果、稳定的全极点二阶节，其复共轭极点位于半径为 $r$、角度为 $\\theta$ 的位置，由传递函数描述\n$$\nH(z) \\;=\\; \\frac{1}{1 - 2 r \\cos\\theta \\, z^{-1} + r^{2} z^{-2}} \\;=\\; \\frac{1}{\\bigl(1 - r e^{j\\theta} z^{-1}\\bigr)\\bigl(1 - r e^{-j\\theta} z^{-1}\\bigr)}.\n$$\n该节采用转置直接II型（Direct Form II Transposed）实现，前馈系数为 $b_{0}=1$、$b_{1}=0$、$b_{2}=0$（因此输出等于第一个状态），反馈系数为 $a_{1}=2 r \\cos\\theta$ 和 $a_{2}=-r^{2}$。内部算术采用有符号定点数，总位数为 $B=16$（一个符号位和 $B-1=15$ 个小数位，即 $Q1.15$ 格式），动态范围为 $[-1,\\,1)$，并在每次乘积后进行四舍五入。具体来说，两个反馈乘积 $a_{1} y[n-1]$ 和 $a_{2} y[n-2]$ 均被量化为 $Q1.15$ 格式，量化步长为 $\\Delta = 2^{-(B-1)}$；将其舍入误差表示为 $e_{1}[n]$ 和 $e_{2}[n]$。假设采用标准舍入噪声模型，其中每个 $e_{k}[n]$ 都是在 $\\bigl[-\\tfrac{\\Delta}{2},\\,\\tfrac{\\Delta}{2}\\bigr)$ 上均匀分布的零均值白噪声过程，且与信号以及彼此之间相互独立。输入是一个位于极点角的确定性正弦信号，\n$$\nx[n] \\;=\\; A \\cos(\\theta n),\n$$\n其幅度 $A>0$ 未知。\n\n仅使用线性时不变系统的基本性质、定点量化和正弦稳态分析，对给定的数值参数 $r=0.95$ 和 $\\theta=\\pi/3$ 回答以下问题：\n\n1) 确定最大输入幅度 $A_{\\max}$，以确保在实现的任何位置对任何 $n$ 都不会发生溢出（回想一下，在此实现中，内部状态为 $y[n]$ 和 $y[n-1]$）。论证为什么在所述实现下此条件是充分的。\n\n2) 当以 $A=A_{\\max}$ 运行时，计算输出信噪比 (SNR)，其中信噪比 (SNR) 定义为稳态输出信号功率（仅由 $x[n]$ 引起）与稳态输出噪声功率（仅由 $e_{1}[n]$ 和 $e_{2}[n]$ 引起）之比，以分贝表示。你必须从第一性原理出发，为给定的 $H(z)$ 推导出闭式冲激响应 $h[n]$ 及其能量 $\\sum_{n=0}^{\\infty} h^{2}[n]$，以评估噪声功率。\n\n按如下方式给出最终数值结果：\n- 将 $A_{\\max}$ 表示为纯数（无单位）。\n- 将信噪比表示为分贝 (dB)。\n- 将两个报告值都四舍五入到四位有效数字。\n\n在最终答案中，将这两个数字按 $\\bigl[A_{\\max},\\,\\mathrm{SNR}_{\\mathrm{dB}}\\bigr]$ 的顺序列为一个行向量。", "solution": "在尝试求解之前，将根据所需标准对问题进行验证。\n\n**第1步：提取给定条件**\n- 系统传递函数：$H(z) = \\frac{1}{1 - 2 r \\cos\\theta \\, z^{-1} + r^{2} z^{-2}} = \\frac{1}{\\bigl(1 - r e^{j\\theta} z^{-1}\\bigr)\\bigl(1 - r e^{-j\\theta} z^{-1}\\bigr)}$\n- 系统性质：因果、稳定、全极点、二阶节。\n- 极点位置：半径 $r$，角度 $\\theta$。\n- 实现方式：转置直接II型。\n- 前馈系数：$b_{0}=1$，$b_{1}=0$，$b_{2}=0$。\n- 反馈系数：$a_{1}=2 r \\cos\\theta$，$a_{2}=-r^{2}$。\n- 算术：有符号定点数，$B=16$ 总位数（1个符号位， $B-1=15$ 个小数位，即 Q$1.15$）。\n- 动态范围：$[-1, 1)$。\n- 量化：对 $a_{1} y[n-1]$ 和 $a_{2} y[n-2]$ 的每个乘积进行四舍五入。\n- 舍入误差：两个乘积的舍入误差为 $e_{1}[n]$ 和 $e_{2}[n]$，每个都被建模为在 $\\bigl[-\\frac{\\Delta}{2},\\,\\frac{\\Delta}{2}\\bigr)$ 上均匀分布的零均值白噪声随机过程，其中 $\\Delta = 2^{-(B-1)}$。误差与信号及彼此之间相互独立。\n- 输入信号：$x[n] = A \\cos(\\theta n)$，其中 $A>0$。\n- 数值参数：$r=0.95$，$\\theta=\\pi/3$。\n- 任务：1) 求防止溢出的最大输入幅度 $A_{\\max}$。2) 当 $A=A_{\\max}$ 时，计算输出信噪比 (SNR)（单位为分贝）。\n- 推导要求：必须从第一性原理推导冲激响应 $h[n]$ 及其能量 $\\sum_{n=0}^{\\infty} h^{2}[n]$。\n\n**第2步：使用提取的给定条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了数字信号处理中一个涉及滤波器实现、定标和噪声分析的标准场景。然而，问题陈述中存在一个矛盾。它指定了“转置直接II型”实现，但将量化乘积描述为“$a_{1} y[n-1]$ 和 $a_{2} y[n-2]$”。这些乘积项对应于直接I型实现，由差分方程 $y[n] = x[n] + a_1 y[n-1] + a_2 y[n-2]$ 控制。在标准的转置直接II型实现中，反馈乘积会涉及 $y[n]$ 和 $y[n-1]$。\n\n尽管存在这个矛盾，问题仍然是可解的。整体传递函数 $H(z)$、系数 $a_1$ 和 $a_2$ 以及最终的差分方程 $y[n] = x[n] + a_1 y[n-1] + a_2 y[n-2]$ 彼此是一致的。噪声模型虽然使用了来自不同结构的术语进行描述，但其定义是明确的。我们可以证明，总输出噪声功率与噪声是按照直接I型结构还是转置直接II型结构注入无关。因此，这种模糊性并不妨碍得到唯一解。在传递函数和量化乘积的明确定义优先于实现结构名称的解释下，该问题被认为是有效的。\n\n**第3步：结论与行动**\n问题是有效的。将提供一个完整的解。\n\n**第1部分：确定最大输入幅度 $A_{\\max}$**\n\n为防止溢出，所有内部信号值必须保持在动态范围 $[-1, 1)$ 内。问题陈述将内部状态视为 $y[n]$ 和 $y[n-1]$，这将溢出约束简化为确保输出信号 $y[n]$ 不超出范围。我们必须对所有 $n$ 强制执行 $|y[n]| < 1$。\n\n输入是正弦信号 $x[n] = A \\cos(\\theta n)$。稳态输出 $y_{\\mathrm{ss}}[n]$ 由下式给出\n$$y_{\\mathrm{ss}}[n] = A |H(e^{j\\theta})| \\cos\\bigl(\\theta n + \\arg(H(e^{j\\theta}))\\bigr)$$\n输出的幅度为 $A_{\\mathrm{out}} = A |H(e^{j\\theta})|$。溢出条件是 $A_{\\mathrm{out}} < 1$。因此，最大幅度 $A_{\\max}$ 由极限 $A_{\\max} |H(e^{j\\theta})| = 1$ 确定，得出 $A_{\\max} = 1/|H(e^{j\\theta})|$。\n\n我们必须在输入频率 $\\omega_0=\\theta$ 处评估频率响应 $H(e^{j\\omega})$。\n$$H(e^{j\\theta}) = \\frac{1}{\\bigl(1 - r e^{j\\theta} e^{-j\\theta}\\bigr)\\bigl(1 - r e^{-j\\theta} e^{-j\\theta}\\bigr)} = \\frac{1}{(1-r)(1 - r e^{-j2\\theta})}$$\n其幅值为：\n$$|H(e^{j\\theta})| = \\frac{1}{|1-r| \\cdot |1 - r e^{-j2\\theta}|}$$\n由于 $r=0.95 < 1$，所以 $|1-r| = 1-r$。第二项的幅值为：\n$$|1 - r e^{-j2\\theta}| = \\sqrt{(1 - r\\cos(2\\theta))^2 + (-r\\sin(2\\theta))^2} = \\sqrt{1 - 2r\\cos(2\\theta) + r^2\\cos^2(2\\theta) + r^2\\sin^2(2\\theta)} = \\sqrt{1 - 2r\\cos(2\\theta) + r^2}$$\n代入数值 $r=0.95$ 和 $\\theta=\\pi/3$：\n$\\cos(2\\theta) = \\cos(2\\pi/3) = -1/2$。\n$$|H(e^{j\\pi/3})| = \\frac{1}{(1-0.95)\\sqrt{1 - 2(0.95)(-1/2) + (0.95)^2}} = \\frac{1}{0.05\\sqrt{1 + 0.95 + 0.9025}} = \\frac{1}{0.05\\sqrt{2.8525}} \\approx 11.8418$$\n因此，最大输入幅度为：\n$$A_{\\max} = \\frac{1}{|H(e^{j\\pi/3})|} = 0.05\\sqrt{2.8525} \\approx 0.0844467$$\n充分性论证：我们必须检查没有其他内部节点溢出。如前所述，问题描述包含矛盾。假设采用转置直接II型结构，则另一个加法器的稳态输出为 $g[n]=a_1 y[n] + a_2 y[n-1]$。对于 $|y[n]| \\le 1$，此信号的幅度为 $\\sqrt{a_1^2 + a_2^2 + 2 a_1 a_2 \\cos \\theta} = \\sqrt{(0.95)^2 + (-0.9025)^2 + 2(0.95)(-0.9025)(0.5)} \\approx 0.927 < 1$。因此，对输出节点进行定标就足够了。\n\n**第2部分：信噪比 (SNR) 计算**\n\n信噪比定义为 $\\mathrm{SNR} = 10 \\log_{10}(P_{\\mathrm{signal}} / P_{\\mathrm{noise}})$。\n\n信号功率 $P_{\\mathrm{signal}}$：\n当输入幅度为 $A=A_{\\max}$ 时，输出幅度为 $A_{\\max} |H(e^{j\\theta})| = 1$。输出信号是幅度为1的正弦波。幅度为 $C$ 的正弦波的功率是 $C^2/2$。\n$$P_{\\mathrm{signal}} = \\frac{1^2}{2} = \\frac{1}{2}$$\n\n噪声功率 $P_{\\mathrm{noise}}$：\n两个舍入误差 $e_1[n]$ 和 $e_2[n]$ 被建模为独立的白噪声源。每个噪声源的方差，由于其在 $[-\\Delta/2, \\Delta/2]$ 上均匀分布，为：\n$$\\sigma_e^2 = \\frac{(\\Delta/2 - (-\\Delta/2))^2}{12} = \\frac{\\Delta^2}{12}$$\n当 $B=16$ 时，量化步长为 $\\Delta = 2^{-(B-1)} = 2^{-15}$。\n$$\\sigma_e^2 = \\frac{(2^{-15})^2}{12} = \\frac{2^{-30}}{12}$$\n噪声源被加到系统中。总输出噪声功率 $P_{\\mathrm{noise}}$ 是来自每个源的功率之和。由于系统是线性的且噪声源是独立的，我们可以在输出端将它们的贡献相加。从噪声注入点到输出的传递函数是 $H(z)$。由方差为 $\\sigma_e^2$ 的单个白噪声源引起的输出功率是 $\\sigma_e^2 \\sum_{n=0}^{\\infty} h^2[n]$。因为有两个这样的源，总输出噪声功率是：\n$$P_{\\mathrm{noise}} = (\\sigma_e^2 + \\sigma_e^2) \\sum_{n=0}^\\infty h^2[n] = 2\\sigma_e^2 \\sum_{n=0}^\\infty h^2[n] = \\frac{\\Delta^2}{6} \\sum_{n=0}^\\infty h^2[n]$$\n我们必须推导冲激响应 $h[n]$ 及其能量 $\\sum h^2[n]$。Z变换为 $H(z) = 1/((1-pz^{-1})(1-p^*z^{-1}))$，其中 $p=re^{j\\theta}$。通过部分分式展开，$H(z)=\\frac{C}{1-pz^{-1}} + \\frac{C^*}{1-p^*z^{-1}}$，其中 $C=1/(1-p^*/p) = e^{j\\theta}/(2j\\sin\\theta)$。Z反变换得到：\n$$h[n] = (Cp^n + C^*(p^*)^n)u[n] = 2\\Re\\{Cp^n\\}u[n] = \\frac{r^n}{\\sin\\theta}\\sin((n+1)\\theta)u[n]$$\n冲激响应的能量 $\\sum_{n=0}^\\infty h^2[n]$ 可以使用 Parseval 定理的复围线积分求得，或者通过直接求和（代数运算量很大）求得。对于二阶系统 $H(z)=1/(1-\\alpha_1 z^{-1}-\\alpha_2 z^{-2})$ 的一个标准结果是：\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1+\\alpha_2}{(1-\\alpha_2)((1+\\alpha_2)^2-\\alpha_1^2)}$$\n在我们的系统中，$\\alpha_1=2r\\cos\\theta$ 且 $\\alpha_2=-r^2$。代入这些值可得：\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1-r^2}{(1+r^2)((1-r^2)^2-(2r\\cos\\theta)^2)} = \\frac{1-r^2}{(1+r^2)(1-2r^2+r^4-4r^2\\cos^2\\theta)}$$\n这个表达式可以简化。已知结果可以写成：\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1+r^2}{(1-r^2)(1-2r^2\\cos(2\\theta)+r^4)}$$\n使用 $r=0.95$ 和 $\\theta=\\pi/3$，我们有 $r^2=0.9025$，$r^4\\approx 0.814506$，以及 $\\cos(2\\theta)=-1/2$。\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1+0.9025}{(1-0.9025)(1-2(0.9025)(-0.5)+0.814506)} = \\frac{1.9025}{(0.0975)(1+0.9025+0.814506)} = \\frac{1.9025}{(0.0975)(2.717006)} \\approx 7.18170$$\n现在我们计算噪声功率：\n$$P_{\\mathrm{noise}} = \\frac{(2^{-15})^2}{6} \\times 7.18170 = \\frac{2^{-30}}{6} \\times 7.18170 \\approx 1.19695 \\times 10^{-9}$$\n最后，我们计算以分贝为单位的信噪比：\n$$\\mathrm{SNR} = \\frac{P_{\\mathrm{signal}}}{P_{\\mathrm{noise}}} = \\frac{0.5}{1.19695 \\times 2^{-30}} \\approx \\frac{0.5}{1.19695 \\times 9.313 \\times 10^{-10}} \\approx 4.4855 \\times 10^8$$\n$$\\mathrm{SNR}_{\\mathrm{dB}} = 10 \\log_{10}(\\mathrm{SNR}) = 10 \\log_{10}(4.4855 \\times 10^8) \\approx 86.5186$$\n\n**最终数值结果**\n四舍五入到四位有效数字：\n- $A_{\\max} \\approx 0.08445$\n- $\\mathrm{SNR}_{\\mathrm{dB}} \\approx 86.52 \\, \\mathrm{dB}$\n这些结果以行向量 $[A_{\\max}, \\mathrm{SNR}_{\\mathrm{dB}}]$ 的形式报告。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.08445 & 86.52\n\\end{pmatrix}\n}\n$$", "id": "2893769"}, {"introduction": "理论模型为我们提供了强大的预测工具，但这些模型的假设在多大程度上与实际情况相符？本练习要求您扮演一个完整的系统设计师和验证工程师的角色。首先，您需要根据分析模型来計算满足特定信噪比（$SNR$）性能指标所需的最小字长；然后，您将编写一个蒙特卡洛仿真程序，以统计方式验证您的理论预测在多大比例的情况下能够成功达标 [@problem_id:2893697]。", "problem": "给定一个离散时间线性时不变 (LTI) 系统在乘积量化下的有限冲激响应实现场景，你必须通过分析确定保证目标信噪比 (SNR) 的最小字长，然后通过 Monte Carlo 仿真验证满足目标的随机试验的比例。请仅使用以下基本依据和定义。\n\n假设与定义：\n- 该系统是一个实值有限冲激响应滤波器，其冲激响应系数为 $\\{h[k]\\}_{k=0}^{N-1}$，产生的理想输出为 $s[n] = \\sum_{k=0}^{N-1} h[k]\\,x[n-k]$。\n- 该系统采用乘积量化实现：每个乘积 $h[k]\\,x[n-k]$ 都由一个范围为 $[-1,1)$、步长为 $\\Delta = 2^{1-b}$ 的均匀中置型量化器单独量化为 $b$ 比特。量化后的乘积为 $q(h[k]\\,x[n-k])$，实际输出为 $y[n] = \\sum_{k=0}^{N-1} q(h[k]\\,x[n-k])$。\n- 量化舍入噪声模型：对于每个乘积，量化误差 $e_k[n] = q(h[k]\\,x[n-k]) - h[k]\\,x[n-k]$ 被建模为一个均值为零的白噪声随机过程，其与信号无关，在 $k$ 和 $n$ 上相互独立，方差为 $\\sigma_q^2 = \\Delta^2/12$。\n- 输入信号是一个实正弦信号 $x[n] = A \\sin(\\omega_0 n + \\phi)$，其幅度 $A$ 从 $[A_{\\min},A_{\\max}]$ 中独立均匀抽取，相位 $\\phi$ 从 $[0,2\\pi)$ 中独立均匀抽取。角度以弧度为单位。\n- 理想输出 $s[n]$ 是一个与输入频率 $\\omega_0$ 相同的正弦信号，其幅度为 $A\\,|H(e^{j\\omega_0})|$，其中 $H(e^{j\\omega}) = \\sum_{k=0}^{N-1} h[k]\\,e^{-j\\omega k}$ 是冲激响应的离散时间傅里叶变换。幅度为 $\\alpha$ 的实正弦信号的时间平均功率为 $\\alpha^2/2$。\n- 分贝 (dB) 信噪比定义为 $\\mathrm{SNR_{dB}} = 10 \\log_{10}\\left(\\frac{P_{\\text{signal}}}{P_{\\text{noise}}}\\right)$，其中 $P_{\\text{signal}}$ 和 $P_{\\text{noise}}$ 分别为信号功率和噪声功率。\n\n任务：\n1) 分析确定最小字长。对每个测试用例，从第一性原理推导出最小整数 $b_{\\min}$。该 $b_{\\min}$ 需在参考幅度等于幅度分布的 $p_{\\mathrm{ref}}$-分位数，即 $A_{\\mathrm{ref}} = A_{\\min} + p_{\\mathrm{ref}}(A_{\\max} - A_{\\min})$ 的条件下，保证达到目标 SNR。推理过程只能使用上述假设和定义。\n2) Monte Carlo 验证。对每个测试用例，运行一个包含 $T$ 次试验的仿真。在每次试验中，独立抽取 $A \\sim \\mathcal{U}[A_{\\min},A_{\\max}]$ 和 $\\phi \\sim \\mathcal{U}[0,2\\pi)$，为 $n=0,1,\\dots, M+N-2$ 生成 $x[n] = A \\sin(\\omega_0 n + \\phi)$，并根据所述实现方式为 $M$ 个有效输出样本生成 $s[n]$ 和 $y[n]$。通过在 $M$ 个有效样本上的样本方差比 $\\widehat{\\mathrm{SNR}} = \\frac{\\mathrm{var}(s)}{\\mathrm{var}(y-s)}$ 来估计该次试验的 SNR。如果 $10 \\log_{10}(\\widehat{\\mathrm{SNR}}) \\ge \\mathrm{SNR_{dB}^{target}}$，则该次试验被计为满足目标。如果 $\\mathrm{var}(s)=0$ 或 $\\mathrm{var}(y-s)=0$，则将该试验计为不满足目标。\n3) 对每个测试用例，报告当量化器使用任务1中计算出的 $b_{\\min}$ 比特时，满足目标的试验所占的仿真比例（一个在 $[0,1]$ 范围内的小数）。\n\n均匀量化器详情：\n- 使用一个在 $[-1,1)$ 范围内具有 $2^b$ 个量化级且步长为 $\\Delta = 2^{1-b}$ 的中置型均匀量化器。量化操作为：先四舍五入到最近的网格点，然后如有必要，进行饱和处理至最近的可表示电平，即 $q(v) = \\mathrm{clip}\\!\\left(\\Delta \\cdot \\mathrm{round}\\!\\left(\\frac{v}{\\Delta}\\right), -1+\\frac{\\Delta}{2}, 1-\\frac{\\Delta}{2}\\right)$。\n\n重要约束：\n- 假设 $|h[k]| \\le 1$ 且 $A_{\\max} \\le 1$，因此每个未量化的乘积 $h[k]\\,x[n-k]$ 均位于 $[-1,1]$ 范围内，且在理想条件下量化器不会饱和。\n- 角度必须以弧度处理。\n- 所有百分比形式的输出都必须表示为 $[0,1]$ 范围内的小数。\n\n测试套件：\n为以下三个测试用例提供结果。每个用例都指定了冲激响应系数 $\\{h[k]\\}$、正弦频率 $\\omega_0$、目标 SNR（分贝）、幅度范围 $[A_{\\min},A_{\\max}]$、幅度参考分位数 $p_{\\mathrm{ref}}$、试验次数 $T$ 以及每次试验中使用的有效输出样本数 $M$。\n\n- 用例1（正常路径）：\n  - $h = [0.25,\\,0.25,\\,0.25,\\,0.25]$\n  - $\\omega_0 = 0.2\\pi$\n  - $\\mathrm{SNR_{dB}^{target}} = 40$\n  - $A_{\\min} = 0.5$, $A_{\\max} = 1.0$\n  - $p_{\\mathrm{ref}} = 0.5$\n  - $T = 600$\n  - $M = 4096$\n\n- 用例2（频率响应谷点覆盖）：\n  - $h = [1,\\,-1,\\,1,\\,-1,\\,1,\\,-1,\\,1,\\,-1]$\n  - $\\omega_0 = 0.2\\pi$\n  - $\\mathrm{SNR_{dB}^{target}} = 30$\n  - $A_{\\min} = 0.2$, $A_{\\max} = 0.8$\n  - $p_{\\mathrm{ref}} = 0.5$\n  - $T = 400$\n  - $M = 4096$\n\n- 用例3（幅度下界为零的边界情况）：\n  - $h = [0.8,\\,0.6]$\n  - $\\omega_0 = 0.1\\pi$\n  - $\\mathrm{SNR_{dB}^{target}} = 20$\n  - $A_{\\min} = 0.0$, $A_{\\max} = 1.0$\n  - $p_{\\mathrm{ref}} = 0.9$\n  - $T = 800$\n  - $M = 4096$\n\n确定性要求：\n- 使用固定的伪随机生成器种子 $12345$ 以确保可复现性。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含三个仿真的比例，按测试用例的顺序排列，形式为用方括号括起来的逗号分隔列表，每个比例四舍五入到三位小数。例如，格式必须类似于 $[0.812,0.945,0.903]$。", "solution": "该问题要求确定在乘积量化下的有限冲激响应 (FIR) 滤波器为满足特定信噪比 (SNR) 所需的最小量化器字长，并随后通过 Monte Carlo 仿真验证此结果。该问题是有效的，因为它科学上基于数字信号处理的既定原则，提法明确且提供了所有必要信息，并且陈述客观。\n\n解决方案分为两个主要部分：首先，对最小字长 $b_{\\min}$ 进行分析推导；其次，描述用于验证的 Monte Carlo 仿真方法。\n\n**1. 最小字长 ($b_{\\min}$) 的分析推导**\n\n目标是在参考输入幅度 $A_{\\mathrm{ref}}$ 的条件下，找到满足目标信噪比 $\\mathrm{SNR_{dB}^{target}}$ 的最小整数\n$$H(e^{j\\omega}) = \\sum_{k=0}^{N-1} h[k] e^{-j\\omega k}$$\n输出信号因此为 $s[n] = A |H(e^{j\\omega_0})| \\sin(\\omega_0 n + \\phi')$, 其中 $\\phi'$ 是新的相位。幅度为 $\\alpha$ 的实正弦信号的时间平均功率为 $P = \\alpha^2/2$。因此，输出信号功率为：\n$$P_s = \\frac{\\left( A |H(e^{j\\omega_0})| \\right)^2}{2} = \\frac{A^2 |H(e^{j\\omega_0})|^2}{2}$$\n\n**1.2. 量化噪声功率 ($P_n$)**\n滤波器实现采用乘积量化，即每个乘积项 $h[k]x[n-k]$ 在求和前被量化。实际输出为 $y[n] = \\sum_{k=0}^{N-1} q(h[k]x[n-k])$。总输出误差是实际输出与理想输出之差：\n$$e[n] = y[n] - s[n] = \\sum_{k=0}^{N-1} \\left[ q(h[k]x[n-k]) - h[k]x[n-k] \\right] = \\sum_{k=0}^{N-1} e_k[n]$$\n此处，$e_k[n]$ 是第 $k$ 个乘积在时间 $n$ 的量化误差。根据问题的统计模型，每个 $e_k[n]$ 都是一个均值为零的白噪声随机过程，方差为 $\\sigma_q^2 = \\Delta^2/12$，其中 $\\Delta = 2^{1-b}$ 是量化器步长。假设对于不同的 $k$，误差 $e_k[n]$ 是相互独立的。独立随机变量之和的方差等于它们各自方差之和。因此，总噪声功率 $P_n$（即 $e[n]$ 的方差）为：\n$$P_n = \\sigma_e^2 = \\mathrm{Var}\\left(\\sum_{k=0}^{N-1} e_k[n]\\right) = \\sum_{k=0}^{N-1} \\mathrm{Var}(e_k[n]) = N \\sigma_q^2$$\n代入 $\\sigma_q^2$ 和 $\\Delta$ 的表达式：\n$$P_n = N \\frac{\\Delta^2}{12} = N \\frac{(2^{1-b})^2}{12} = N \\frac{2^{2-2b}}{12} = \\frac{N}{3} 2^{-2b}$$\n\n**1.3. 信噪比 (SNR) 与最小字长**\n线性尺度下的信噪比是信号功率与噪声功率之比：\n$$\\mathrm{SNR} = \\frac{P_s}{P_n} = \\frac{A^2 |H(e^{j\\omega_0})|^2 / 2}{N 2^{-2b} / 3} = \\frac{3 A^2 |H(e^{j\\omega_0})|^2}{2N} 2^{2b}$$\n分贝信噪比为 $\\mathrm{SNR_{dB}} = 10 \\log_{10}(\\mathrm{SNR})$。我们要求在参考幅度 $A = A_{\\mathrm{ref}}$ 时，该值大于或等于目标信噪比 $\\mathrm{SNR_{dB}^{target}}$。\n$$10 \\log_{10}(\\mathrm{SNR}) \\ge \\mathrm{SNR_{dB}^{target}} \\implies \\mathrm{SNR} \\ge 10^{\\mathrm{SNR_{dB}^{target}}/10}$$\n代入 SNR 表达式并求解 $b$：\n$$\\frac{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2}{2N} 2^{2b} \\ge 10^{\\mathrm{SNR_{dB}^{target}}/10}$$\n$$2^{2b} \\ge \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10}$$\n对两边取以2为底的对数，得到：\n$$2b \\ge \\log_2\\left( \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10} \\right)$$\n$$b \\ge \\frac{1}{2} \\log_2\\left( \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10} \\right)$$\n由于字长 $b$ 必须是整数，所需的最小字长 $b_{\\min}$ 是满足此不等式的最小整数：\n$$b_{\\min} = \\left\\lceil \\frac{1}{2} \\log_2\\left( \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10} \\right) \\right\\rceil$$\n对于每个测试用例，我们计算 $A_{\\mathrm{ref}} = A_{\\min} + p_{\\mathrm{ref}}(A_{\\max} - A_{\\min})$，求出 $|H(e^{j\\omega_0})|^2$，并代入给定参数以求得 $b_{\\min}$。\n\n**2. Monte Carlo 仿真方法**\n\n该仿真旨在通过估计满足目标 SNR 的随机试验比例，来验证分析推导出的 $b_{\\min}$。对每个测试用例，重复以下步骤 $T$ 次试验。\n\n**2.1. 试验设置**\n在每次试验中，使用随机参数生成一个输入信号。幅度 $A$ 从均匀分布 $\\mathcal{U}[A_{\\min},A_{\\max}]$ 中抽取，相位 $\\phi$ 从 $\\mathcal{U}[0, 2\\pi)$ 中抽取。使用固定的伪随机数生成器种子 ($12345$) 以确保可复现性。\n\n**2.2. 信号生成**\n对于每次试验，生成以下长度为 $M$ 的信号：\n- **输入信号**：为 $n=0, 1, \\dots, M+N-2$ 生成输入序列 $x[n] = A \\sin(\\omega_0 n + \\phi)$。这为 $M$ 个有效输出样本提供了足够的数据。\n- **理想输出**：通过将输入 $x[n]$ 与滤波器冲激响应 $h[k]$ 进行卷积来计算理想输出 $s[n]$。我们使用卷积的“有效”部分，得到 $M$ 个样本：$s[j] = \\sum_{k=0}^{N-1} h[k]x[j+k]$，其中 $j=0, \\dots, M-1$（根据标准卷积定义，在反转一个序列后）。\n- **量化输出**：通过模拟乘积量化过程生成量化输出 $y[n]$。对于每个输出样本 $j=0, \\dots, M-1$，计算相应的量化乘积之和：\n$$y[j+N-1] = \\sum_{k=0}^{N-1} q(h[k]x[j+N-1-k])$$\n值 $v$ 的量化器函数 $q(v)$ 完全按照规定实现，使用分析推导出的字长 $b=b_{\\min}$：\n$$q(v) = \\mathrm{clip}\\!\\left(\\Delta \\cdot \\mathrm{round}\\!\\left(\\frac{v}{\\Delta}\\right), -1+\\frac{\\Delta}{2}, 1-\\frac{\\Delta}{2}\\right) \\quad \\text{with} \\quad \\Delta = 2^{1-b_{\\min}}$$\n\n**2.3. SNR 估计与验证**\n对于每次试验，计算输出误差序列 $e[n] = y[n] - s[n]$。在 $M$ 个样本上计算理想输出的样本方差 $\\mathrm{var}(s)$ 和误差的样本方差 $\\mathrm{var}(y-s)$。该次试验的估计 SNR 为：\n$$\\widehat{\\mathrm{SNR}} = \\frac{\\mathrm{var}(s)}{\\mathrm{var}(y-s)}$$\n如果一次试验的分贝信噪比达到或超过目标，即 $10 \\log_{10}(\\widehat{\\mathrm{SNR}}) \\ge \\mathrm{SNR_{dB}^{target}}$，则该试验被计为成功。$\\mathrm{var}(s)=0$ 或 $\\mathrm{var}(y-s)=0$ 的试验被计为失败。\n\n**2.4. 最终输出**\n对于给定的测试用例，在所有 $T$ 次试验完成后，最终报告的值是成功试验的比例，计算方法为（成功次数）/ $T$。对所有三个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the analytical minimum word length and then runs a Monte Carlo\n    simulation to find the fraction of trials meeting the SNR target.\n    \"\"\"\n    # Use a single random number generator for all test cases for reproducibility.\n    rng = np.random.default_rng(12345)\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"h\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"w0\": 0.2 * np.pi,\n            \"snr_db_target\": 40.0,\n            \"A_min\": 0.5,\n            \"A_max\": 1.0,\n            \"p_ref\": 0.5,\n            \"T\": 600,\n            \"M\": 4096,\n        },\n        # Case 2 (frequency response dip coverage)\n        {\n            \"h\": np.array([1, -1, 1, -1, 1, -1, 1, -1]),\n            \"w0\": 0.2 * np.pi,\n            \"snr_db_target\": 30.0,\n            \"A_min\": 0.2,\n            \"A_max\": 0.8,\n            \"p_ref\": 0.5,\n            \"T\": 400,\n            \"M\": 4096,\n        },\n        # Case 3 (amplitude edge case with zero lower bound)\n        {\n            \"h\": np.array([0.8, 0.6]),\n            \"w0\": 0.1 * np.pi,\n            \"snr_db_target\": 20.0,\n            \"A_min\": 0.0,\n            \"A_max\": 1.0,\n            \"p_ref\": 0.9,\n            \"T\": 800,\n            \"M\": 4096,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        h = case[\"h\"]\n        w0 = case[\"w0\"]\n        snr_db_target = case[\"snr_db_target\"]\n        A_min = case[\"A_min\"]\n        A_max = case[\"A_max\"]\n        p_ref = case[\"p_ref\"]\n        T = case[\"T\"]\n        M = case[\"M\"]\n        \n        # --- Task 1: Analytical minimum word length ---\n        A_ref = A_min + p_ref * (A_max - A_min)\n        N = len(h)\n        \n        k_indices = np.arange(N)\n        H_w0 = np.sum(h * np.exp(-1j * w0 * k_indices))\n        H_w0_mag_sq = np.abs(H_w0)**2\n\n        # Handle case where gain is zero. Set b_min to a high value as SNR is -inf.\n        if H_w0_mag_sq == 0 or A_ref == 0:\n            b_min = 32 # A practical large number, problem won't be solvable\n        else:\n            snr_linear_target = 10**(snr_db_target / 10.0)\n            # Argument for log2\n            log_arg = ( (2 * N * snr_linear_target) / \n                        (3 * A_ref**2 * H_w0_mag_sq) )\n            \n            b_min = math.ceil(0.5 * np.log2(log_arg)) if log_arg > 0 else 1\n\n        # --- Task 2: Monte Carlo verification ---\n        \n        # Define the quantizer function based on problem specification\n        delta = 2**(1 - b_min)\n        clip_min = -1 + delta / 2\n        clip_max = 1 - delta / 2\n\n        def quantizer(v):\n            quantized_v = delta * np.round(v / delta)\n            return np.clip(quantized_v, clip_min, clip_max)\n\n        success_count = 0\n        for _ in range(T):\n            A = rng.uniform(A_min, A_max)\n            phi = rng.uniform(0, 2 * np.pi)\n            \n            # Generate signals\n            x_len = M + N - 1\n            n_x = np.arange(x_len)\n            x = A * np.sin(w0 * n_x + phi)\n            \n            # Ideal output\n            s = np.convolve(x, h, mode='valid')\n            \n            # Quantized output (product quantization)\n            y = np.zeros(M)\n            for i in range(M):\n                # The convolution sum for y[i]\n                current_sum = 0\n                for k in range(N):\n                    # For output y[i], we need input x[i+N-1-k]\n                    product = h[k] * x[i + N - 1 - k]\n                    current_sum += quantizer(product)\n                y[i] = current_sum\n\n            # Calculate estimated SNR\n            error_signal = y - s\n            var_s = np.var(s)\n            var_e = np.var(error_signal)\n            \n            if var_s > 0 and var_e > 0:\n                snr_est = var_s / var_e\n                snr_est_db = 10 * np.log10(snr_est)\n                if snr_est_db >= snr_db_target:\n                    success_count += 1\n            # else: trial fails if variance is zero (treated as not meeting target)\n\n        # --- Task 3: Report simulated fraction ---\n        fraction_success = success_count / T\n        results.append(fraction_success)\n        \n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2893697"}]}