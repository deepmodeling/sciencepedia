{"hands_on_practices": [{"introduction": "要理解系数定量的影响，一个很好的起点是分析一个简单的场景：单个系数误差如何直接转化为滤波器输出的误差。本练习引导您通过一个思想实验，精确计算一个有限冲激响应 (FIR) 滤波器由于单个系数的截断误差而在其阶跃响应中引入的稳态（或直流）偏差。通过这个练习，您将巩固对线性时不变系统基本属性的理解，并建立“误差滤波器”的核心直觉，即系数误差本身可以被看作一个单独的滤波器，作用于输入信号上 [@problem_id:2858816]。", "problem": "考虑一个长度为$5$的有限冲激响应（FIR）滤波器，其冲激响应系数为 $h[0]=\\frac{1}{4}$，$h[1]=-\\frac{3}{8}$，$h[2]=\\frac{13}{64}$，$h[3]=\\frac{1}{16}$ 以及 $h[4]=-\\frac{1}{32}$。所有系数都将以定点 $Qm.n$ 格式存储，其中 $Qm.n$ 表示一种二进制补码定点表示法，具有 $m$ 个整数位（不包括符号位）和 $n$ 个小数位。假设 $n=5$ 且不发生饱和。除了 $h[2]$ 之外，所有系数都可以在 $Qm.n$ 格式中精确表示。$h[2]$ 通过确定性向零截断进行量化。截断算子定义为\n$$\n\\mathcal{T}_{n}(x) \\triangleq \\mathrm{sgn}(x)\\,\\frac{\\left\\lfloor 2^{n}\\,|x|\\right\\rfloor}{2^{n}}.\n$$\n令 $\\tilde{h}[k]$ 表示存储的（量化的）系数序列，其中对于所有 $k\\neq 2$ 有 $\\tilde{h}[k]=h[k]$，且 $\\tilde{h}[2]=\\mathcal{T}_{5}\\!\\big(h[2]\\big)$。该滤波器由单位阶跃输入 $x[n]=u[n]$ 驱动。将感应的直流（DC）偏置定义为，在相同输入响应下，量化滤波器输出与精确系数滤波器输出之间的稳态差异：\n$$\nb \\triangleq \\lim_{n\\to\\infty}\\big(\\tilde{y}[n]-y[n]\\big),\n$$\n其中 $y[n]$ 和 $\\tilde{y}[n]$ 分别是对应于 $h[k]$ 和 $\\tilde{h}[k]$ 的输出。\n\n仅从线性时不变卷积、定点截断和FIR系统的基本稳定性属性的定义出发，推导 $b$ 的表达式并计算其精确值。将最终答案表示为单个精确实数。无需四舍五入。", "solution": "该问题要求计算当一个具有精确系数的滤波器和一个具有量化系数的滤波器都由单位阶跃输入驱动时，它们输出之间的稳态差异。这个差异被定义为直流（DC）偏置 $b$。\n\n设 $h[k]$ 是精确有限冲激响应（FIR）滤波器的冲激响应，$\\tilde{h}[k]$ 是具有量化系数的滤波器的冲激响应。两个冲激响应的长度均为$5$，因此 $k$ 的范围是从$0$到$4$。一个线性时不变（LTI）系统的输出由其冲激响应与输入信号 $x[n]$ 的卷积给出。\n\n精确滤波器的输出 $y[n]$ 由下式给出：\n$$\ny[n] = (h * x)[n] = \\sum_{k=0}^{4} h[k] x[n-k]\n$$\n量化滤波器的输出 $\\tilde{y}[n]$ 由下式给出：\n$$\n\\tilde{y}[n] = (\\tilde{h} * x)[n] = \\sum_{k=0}^{4} \\tilde{h}[k] x[n-k]\n$$\n直流偏置 $b$ 定义为这两个输出之间的稳态差异：\n$$\nb \\triangleq \\lim_{n\\to\\infty}\\big(\\tilde{y}[n]-y[n]\\big)\n$$\n根据求和算子的线性性质，差异 $\\tilde{y}[n]-y[n]$ 可以表示为：\n$$\n\\tilde{y}[n] - y[n] = \\sum_{k=0}^{4} \\tilde{h}[k] x[n-k] - \\sum_{k=0}^{4} h[k] x[n-k] = \\sum_{k=0}^{4} (\\tilde{h}[k]-h[k]) x[n-k]\n$$\n我们定义系数误差序列 $\\Delta h[k] \\triangleq \\tilde{h}[k]-h[k]$。输出差异即为冲激响应为 $\\Delta h[k]$ 的“误差滤波器”对输入 $x[n]$ 的响应：\n$$\n\\tilde{y}[n] - y[n] = (\\Delta h * x)[n] = \\sum_{k=0}^{4} \\Delta h[k] x[n-k]\n$$\n输入信号为单位阶跃函数 $x[n]=u[n]$，定义为当 $n \\ge 0$ 时 $u[n]=1$，当 $n < 0$ 时 $u[n]=0$。我们必须计算当 $n \\to \\infty$ 时的极限。对于一个长度为$5$的FIR滤波器，卷积和包含 $k \\in \\{0, 1, 2, 3, 4\\}$ 的项 $x[n-k]$。当 $n$ 变得很大时，特别是对于任何 $n \\ge 4$，求和中的所有 $k$ 的参数 $n-k$ 都将是非负的。也就是说，$n-4 \\ge 0$，$n-3 \\ge 0$，依此类推。\n对于 $n \\ge 4$，我们有对于所有 $k \\in \\{0, 1, 2, 3, 4\\}$ 都有 $u[n-k] = 1$。\n因此，对于 $n \\ge 4$，输出差异变为常数：\n$$\n\\tilde{y}[n] - y[n] = \\sum_{k=0}^{4} \\Delta h[k] \\cdot 1 = \\sum_{k=0}^{4} \\Delta h[k]\n$$\n由于该表达式对于所有 $n \\ge 4$ 都是常数，因此当 $n \\to \\infty$ 时的极限就是这个常数值。因此，直流偏置 $b$ 是系数误差之和：\n$$\nb = \\lim_{n\\to\\infty} \\sum_{k=0}^{4} \\Delta h[k] u[n-k] = \\sum_{k=0}^{4} \\Delta h[k]\n$$\n这个结果是FIR滤波器稳定性和阶跃响应性质的直接推论，阶跃响应会达到一个等于滤波器直流增益（其冲激响应系数之和）的稳态值。\n\n问题陈述只有系数 $h[2]$ 被量化，而其他系数保持精确。这意味着：\n$\\Delta h[k] = \\tilde{h}[k] - h[k] = 0$ for $k \\in \\{0, 1, 3, 4\\}$。\n唯一非零的误差系数是 $\\Delta h[2] = \\tilde{h}[2] - h[2]$。\n因此，直流偏置简化为：\n$$\nb = \\Delta h[2]\n$$\n现在我们必须计算 $\\Delta h[2]$。系数 $h[2]=\\frac{13}{64}$ 使用向零截断进行量化，有 $n=5$ 个小数位。截断算子 $\\mathcal{T}_{n}(x)$ 由下式给出：\n$$\n\\mathcal{T}_{n}(x) \\triangleq \\mathrm{sgn}(x)\\,\\frac{\\left\\lfloor 2^{n}\\,|x|\\right\\rfloor}{2^{n}}\n$$\n对于 $x = h[2] = \\frac{13}{64}$，这是一个正值，所以 $\\mathrm{sgn}(x)=1$。当 $n=5$ 时，我们有 $2^n = 2^5 = 32$。量化后的系数 $\\tilde{h}[2]$ 为：\n$$\n\\tilde{h}[2] = \\mathcal{T}_{5}\\left(\\frac{13}{64}\\right) = \\frac{\\left\\lfloor 2^{5} \\cdot \\frac{13}{64}\\right\\rfloor}{2^{5}} = \\frac{\\left\\lfloor 32 \\cdot \\frac{13}{64}\\right\\rfloor}{32}\n$$\n我们计算floor函数内部的项：\n$$\n32 \\cdot \\frac{13}{64} = \\frac{13}{2} = 6.5\n$$\n进行向下取整得到 $\\lfloor 6.5 \\rfloor = 6$。\n所以，量化后的系数是：\n$$\n\\tilde{h}[2] = \\frac{6}{32} = \\frac{3}{16}\n$$\n现在我们计算系数误差 $\\Delta h[2]$：\n$$\n\\Delta h[2] = \\tilde{h}[2] - h[2] = \\frac{3}{16} - \\frac{13}{64}\n$$\n为了减去这两个分数，我们找到一个公分母，即 $64$：\n$$\n\\Delta h[2] = \\frac{3 \\cdot 4}{16 \\cdot 4} - \\frac{13}{64} = \\frac{12}{64} - \\frac{13}{64} = -\\frac{1}{64}\n$$\n最后，如前所述，直流偏置 $b$ 等于这单个非零的系数误差。\n$$\nb = \\Delta h[2] = -\\frac{1}{64}\n$$", "answer": "$$\\boxed{-\\frac{1}{64}}$$", "id": "2858816"}, {"introduction": "与 FIR 滤波器不同，无限冲激响应 (IIR) 滤波器的系数误差可能会产生更严重的后果，例如改变滤波器的稳定性。稳定性由其极点在 $z$ 平面中的位置决定；如果任何极点由于量化而移出单位圆，滤波器就会变得不稳定。本练习旨在通过推导二阶 IIR 滤波器（双二阶节）极点位置（由其半径 $r$ 和角度 $\\theta$ 表示）对分母系数 $a_1$ 和 $a_2$ 的灵敏度，来培养您进行分析性评估的能力。掌握这种灵敏度分析对于设计在硬件实现中对量化效应稳健的 IIR 滤波器至关重要 [@problem_id:2858988]。", "problem": "考虑一个实系数二阶 (biquad) 数字滤波器，其传递函数为\n$$\nH(z) \\;=\\; \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2}},\n$$\n其中 $b_0$、$b_1$、$b_2$、$a_1$ 和 $a_2$ 是实数。假设极点对是共轭复数，因此分母多项式有两个根 $z_p$ 和 $z_p^{\\ast}$，它们严格位于单位圆内且不在实轴上。将一个极点的极坐标表示定义为 $z_p = r \\exp(j \\theta)$，其中半径 $r \\in (0,1)$，角度 $\\theta \\in (0,\\pi)$（以弧度为单位）。\n\n假设系数 $a_1$ 和 $a_2$ 受到微小的有限字长量化扰动，这些扰动被建模为独立的、足够小的微分 $\\mathrm{d}a_1$ 和 $\\mathrm{d}a_2$。将极点不变量 $r$ 和 $\\theta$ 关于 $a_1$ 和 $a_2$ 的局部灵敏度定义为偏导数 $\\frac{\\partial r}{\\partial a_1}$、$\\frac{\\partial r}{\\partial a_2}$、$\\frac{\\partial \\theta}{\\partial a_1}$ 和 $\\frac{\\partial \\theta}{\\partial a_2}$，使得一阶变分满足\n$$\n\\mathrm{d}r \\;\\approx\\; \\frac{\\partial r}{\\partial a_1}\\,\\mathrm{d}a_1 \\;+\\; \\frac{\\partial r}{\\partial a_2}\\,\\mathrm{d}a_2,\\qquad\n\\mathrm{d}\\theta \\;\\approx\\; \\frac{\\partial \\theta}{\\partial a_1}\\,\\mathrm{d}a_1 \\;+\\; \\frac{\\partial \\theta}{\\partial a_2}\\,\\mathrm{d}a_2.\n$$\n\n仅从具有共轭复数根的实系数二次多项式的基本因式分解以及 $r$ 和 $\\theta$ 的定义出发，推导这四个偏导数关于 $a_1$ 和 $a_2$ 的闭式表达式，并满足容许条件 $a_2>0$ 和 $a_1^2<4a_2$。按照 $\\left(\\frac{\\partial r}{\\partial a_1},\\,\\frac{\\partial r}{\\partial a_2},\\,\\frac{\\partial \\theta}{\\partial a_1},\\,\\frac{\\partial \\theta}{\\partial a_2}\\right)$ 的顺序列出你的最终结果。角度必须以弧度表示。无需进行数值计算，只需提供精确的解析表达式。", "solution": "滤波器的极点是分母多项式 $D(z^{-1}) = 1 + a_1 z^{-1} + a_2 z^{-2}$ 的根。这等价于求特征多项式 $P(z) = z^2 + a_1 z + a_2 = 0$ 的根。\n问题陈述，极点是一对共轭复数，记作 $z_p = r \\exp(j\\theta)$ 和 $z_p^{\\ast} = r \\exp(-j\\theta)$，其中 $r \\in (0,1)$ 且 $\\theta \\in (0,\\pi)$。\n\n多项式 $P(z)$ 可以根据其根进行因式分解：\n$$P(z) = (z - z_p)(z - z_p^{\\ast}) = z^2 - (z_p + z_p^{\\ast})z + z_p z_p^{\\ast}$$\n通过将此展开形式的系数与 $z^2 + a_1 z + a_2$ 进行比较，我们建立了系数 $(a_1, a_2)$ 与极点的极坐标表示 $(r, \\theta)$ 之间的关系。\n\n根之和为：\n$$z_p + z_p^{\\ast} = r \\exp(j\\theta) + r \\exp(-j\\theta) = r(\\cos\\theta + j\\sin\\theta) + r(\\cos\\theta - j\\sin\\theta) = 2r\\cos\\theta$$\n根之积为：\n$$z_p z_p^{\\ast} = (r \\exp(j\\theta))(r \\exp(-j\\theta)) = r^2$$\n\n令系数相等，得到以下方程组：\n$$a_1 = -2r\\cos\\theta \\quad (1)$$\n$$a_2 = r^2 \\quad (2)$$\n\n这些方程将 $a_1$ 和 $a_2$ 定义为 $r$ 和 $\\theta$ 的函数。我们需要求 $r$ 和 $\\theta$ 关于 $a_1$ 和 $a_2$ 的偏导数。我们将使用隐函数微分法。我们将 $r$ 和 $\\theta$ 视为 $a_1$ 和 $a_2$ 的函数，并对方程组 $(1)$ 和 $(2)$ 分别关于 $a_1$ 和 $a_2$ 求导。\n\n首先，我们对 $a_1$ 求导：\n$$\\frac{\\partial}{\\partial a_1}(a_1) = 1 = \\frac{\\partial}{\\partial a_1}(-2r\\cos\\theta) = -2\\left(\\frac{\\partial r}{\\partial a_1}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}\\right)$$\n$$\\frac{\\partial}{\\partial a_1}(a_2) = 0 = \\frac{\\partial}{\\partial a_1}(r^2) = 2r\\frac{\\partial r}{\\partial a_1}$$\n\n从第二个微分方程可知，因为 $r \\in (0,1)$，我们有 $r \\neq 0$，这意味着：\n$$\\frac{\\partial r}{\\partial a_1} = 0$$\n将此结果代入第一个微分方程：\n$$1 = -2\\left(0 \\cdot \\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}\\right) = 2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_1}$$\n解出 $\\frac{\\partial \\theta}{\\partial a_1}$ 得：\n$$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{2r\\sin\\theta}$$\n\n接下来，我们对原方程组关于 $a_2$ 求导：\n$$\\frac{\\partial}{\\partial a_2}(a_1) = 0 = \\frac{\\partial}{\\partial a_2}(-2r\\cos\\theta) = -2\\left(\\frac{\\partial r}{\\partial a_2}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}\\right)$$\n$$\\frac{\\partial}{\\partial a_2}(a_2) = 1 = \\frac{\\partial}{\\partial a_2}(r^2) = 2r\\frac{\\partial r}{\\partial a_2}$$\n\n从第二个微分方程，我们求得 $\\frac{\\partial r}{\\partial a_2}$：\n$$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2r}$$\n将此代入第一个微分方程：\n$$0 = -2\\left(\\frac{1}{2r}\\cos\\theta - r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}\\right) = -\\frac{\\cos\\theta}{r} + 2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2}$$\n解出 $\\frac{\\partial \\theta}{\\partial a_2}$：\n$$2r\\sin\\theta\\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{r} \\implies \\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{2r^2\\sin\\theta}$$\n\n推导出的偏导数目前是用 $r$ 和 $\\theta$ 表示的。我们必须将它们转换为仅用 $a_1$ 和 $a_2$ 表示的表达式。\n从方程 $(2)$，我们得到 $r = \\sqrt{a_2}$（因为 $r>0$）。\n从方程 $(1)$，我们得到 $\\cos\\theta = -\\frac{a_1}{2r} = -\\frac{a_1}{2\\sqrt{a_2}}$。\n因为 $\\theta \\in (0,\\pi)$，所以 $\\sin\\theta$ 必须为正。因此：\n$$\\sin\\theta = \\sqrt{1 - \\cos^2\\theta} = \\sqrt{1 - \\left(-\\frac{a_1}{2\\sqrt{a_2}}\\right)^2} = \\sqrt{1 - \\frac{a_1^2}{4a_2}} = \\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}$$\n容许条件 $a_1^2 < 4a_2$ 确保了平方根内的参数为正。\n\n现在我们将这些表达式代回到我们的偏导数结果中。\n\n对于 $\\frac{\\partial r}{\\partial a_1}$：\n结果已经是确定的：$\\frac{\\partial r}{\\partial a_1} = 0$。\n\n对于 $\\frac{\\partial r}{\\partial a_2}$：\n$$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2r} = \\frac{1}{2\\sqrt{a_2}}$$\n\n对于 $\\frac{\\partial \\theta}{\\partial a_1}$：\n$$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{2r\\sin\\theta} = \\frac{1}{2(\\sqrt{a_2})\\left(\\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}\\right)} = \\frac{1}{\\sqrt{4a_2 - a_1^2}}$$\n\n对于 $\\frac{\\partial \\theta}{\\partial a_2}$：\n$$\\frac{\\partial \\theta}{\\partial a_2} = \\frac{\\cos\\theta}{2r^2\\sin\\theta} = \\frac{-\\frac{a_1}{2\\sqrt{a_2}}}{2(a_2)\\left(\\frac{\\sqrt{4a_2 - a_1^2}}{2\\sqrt{a_2}}\\right)} = \\frac{-\\frac{a_1}{2\\sqrt{a_2}}}{\\frac{a_2\\sqrt{4a_2 - a_1^2}}{\\sqrt{a_2}}} = -\\frac{a_1}{2\\sqrt{a_2}} \\cdot \\frac{\\sqrt{a_2}}{a_2\\sqrt{4a_2 - a_1^2}} = -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}}$$\n\n这四个偏导数是：\n$\\frac{\\partial r}{\\partial a_1} = 0$\n$\\frac{\\partial r}{\\partial a_2} = \\frac{1}{2\\sqrt{a_2}}$\n$\\frac{\\partial \\theta}{\\partial a_1} = \\frac{1}{\\sqrt{4a_2 - a_1^2}}$\n$\\frac{\\partial \\theta}{\\partial a_2} = -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}}$\n\n这些就是所要求的用 $a_1$ 和 $a_2$ 表示的闭式表达式。条件 $a_2>0$ 和 $a_1^2<4a_2$ 确保所有表达式都是良定义和实数值。我们现在按指定顺序组合最终答案。", "answer": "$$\\boxed{\\begin{pmatrix} 0 & \\frac{1}{2\\sqrt{a_2}} & \\frac{1}{\\sqrt{4a_2 - a_1^2}} & -\\frac{a_1}{2a_2\\sqrt{4a_2 - a_1^2}} \\end{pmatrix}}$$", "id": "2858988"}, {"introduction": "前面的练习使用了线性模型来分析误差。然而，在真实的定点实现中，每次算术运算后的舍入会引入非线性行为，即使在没有输入信号的情况下，也可能导致不期望的输出振荡，即“极限环”。这个动手实践挑战您编写一个精确的仿真程序，以探索这些非线性现象。通过在有限状态空间上对一个二阶 IIR 滤波器进行建模，您将计算其“死区”的宽度（即系统能从多大的初始扰动中恢复到零状态）以及在零输入下可能出现的最小极限环的幅度，从而将理论分析与数字硬件的实际行为联系起来 [@problem_id:2858969]。", "problem": "给定一类以定点算术实现的离散时间、实系数、二阶无限脉冲响应 (IIR) 系统，其中系数经过量化，且每个基本运算都进行舍入。该系统由直接型递归定义如下\n$$\ny[n] \\;=\\; -a_1\\,y[n-1] \\;-\\; a_2\\,y[n-2] \\;+\\; b_0\\,x[n] \\;+\\; b_1\\,x[n-1] \\;+\\; b_2\\,x[n-2],\n$$\n在零输入条件下，即\n$$\nx[n] \\equiv 0,\n$$\n系统的演化简化为\n$$\ny[n] \\;=\\; -a_1\\,y[n-1] \\;-\\; a_2\\,y[n-2],\n$$\n但此计算在定点环境中进行，每次乘法和加法的结果都将立即舍入到信号字网格并饱和到信号范围。系数在使用前被量化。假设使用以下计算模型。\n\n1. 信号字格式：采用二补数定点格式，有1个符号位和 $F_s$ 个小数位（无整数幅值位）。可表示的信号集合为\n$$\n\\mathcal{Y}_{F_s} \\;=\\; \\left\\{ m \\cdot 2^{-F_s} \\;:\\; m \\in \\mathbb{Z}, \\; -2^{F_s} \\le m \\le 2^{F_s}-1 \\right\\},\n$$\n饱和边界为\n$$\ny_{\\min} \\;=\\; -1, \n\\qquad\ny_{\\max} \\;=\\; 1 - 2^{-F_s}.\n$$\n令 $\\Delta_s \\triangleq 2^{-F_s}$ 表示信号量化步长。\n\n2. 系数字格式：实系数 $a_1$ 和 $a_2$ 通过舍入到 $\\Delta_c \\triangleq 2^{-F_c}$ 的最近倍数（平局情况舍入到最近的偶数量化级别），被量化到 $F_c$ 个小数位。量化后的系数为\n$$\n\\widehat{a}_i \\;=\\; \\operatorname{Q}_c(a_i) \\;=\\; \\operatorname{round\\_to\\_nearest\\_even}\\!\\left(a_i, \\Delta_c\\right), \\quad i \\in \\{1,2\\}.\n$$\n\n3. 算术模型（每次运算后舍入并饱和）：在每个时间点 $n$，计算\n- 两个乘积 $p_1[n] = -\\widehat{a}_1 \\, y[n-1]$ 和 $p_2[n] = -\\widehat{a}_2 \\, y[n-2]$，每个乘积都立即舍入到 $\\Delta_s$ 的最近倍数（平局朝偶数舍入），然后饱和到 $[y_{\\min}, y_{\\max}]$ 范围内，\n- 接着计算一个和 $s[n] = p_1[n] + p_2[n]$，立即饱和到 $[y_{\\min}, y_{\\max}]$ 范围内（由于操作数已在信号网格上，因此无需额外舍入），\n- 最后得到 $y[n] = s[n]$。\n\n4. 信号网格上的状态空间表示：系统在时间 $n$ 的状态是有序对\n$$\n\\mathbf{s}[n] \\triangleq \\big(y[n], \\; y[n-1]\\big) \\in \\mathcal{Y}_{F_s} \\times \\mathcal{Y}_{F_s},\n$$\n下一状态是当前状态的确定性函数，即\n$$\n\\mathbf{s}[n+1] \\;=\\; \\Phi(\\mathbf{s}[n]),\n$$\n该函数由上述算术模型引出。由于状态空间是有限的且动力学是确定性的，每个轨迹最终都将是周期的（收敛到一个不动点或一个非平凡极限环）。\n\n任务所需的定义：\n\n- 沿 $y[-1]$ 轴的死区宽度：考虑零输入并将初始条件限制为\n$$\ny[-2] \\;=\\; 0, \n\\qquad\ny[-1] \\in \\mathcal{Y}_{F_s}.\n$$\n定义\n$$\n\\mathcal{D} \\;=\\; \\left\\{ y[-1] \\in \\mathcal{Y}_{F_s} \\;:\\; \\text{轨迹收敛到零不动点 } (y[n]\\equiv 0) \\right\\}。\n$$\n设 $D$ 为非负数 $d$ 的上确界，使得整个对称区间 $[-d, d] \\cap \\mathcal{Y}_{F_s}$ 都包含在 $\\mathcal{D}$ 中。死区宽度是这个最大对称区间的长度，\n$$\nW_{\\mathrm{dead}} \\;\\triangleq\\; 2D.\n$$\n\n- 最小非零极限环振幅：对于零输入动力学中的任何周期轨道（极限环），将其振幅定义为\n$$\nA(\\text{cycle}) \\;\\triangleq\\; \\max_{n \\text{ on the cycle}} |y[n]|.\n$$\n在所有非零周期中，定义\n$$\nA_{\\min} \\;\\triangleq\\; \\min_{\\text{nonzero cycles}} A(\\text{cycle}).\n$$\n如果不存在非零周期，则定义 $A_{\\min} \\triangleq 0$。\n\n您的任务是编写一个程序，针对给定的参数集 $(a_1, a_2, F_c, F_s)$ 测试套件，在上述模型所隐含的有限状态空间上执行精确的定点仿真，并计算：\n\n- 死区宽度 $W_{\\mathrm{dead}}$（一个与 $y[n]$ 单位相同的实数），\n- 最小非零极限环振幅 $A_{\\min}$（一个与 $y[n]$ 单位相同的实数）。\n\n您必须在系数量化步骤和每次乘法结果处处理“平局朝偶数”的最近舍入规则。所有饱和操作必须符合信号范围 $[y_{\\min}, y_{\\max}]$。和值会被饱和，但在其他方面可以在信号网格上精确表示。\n\n测试套件：\n\n- 案例 1：$a_1 = -1.8$，$a_2 = 0.81$，$F_c = 6$，$F_s = 6$。\n- 案例 2：$a_1 = 0.0$，$a_2 = 0.0$，$F_c = 10$，$F_s = 5$。\n- 案例 3：$a_1 = -1.98$，$a_2 = 0.9801$，$F_c = 10$，$F_s = 7$。\n\n您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例的结果本身必须是一个形如 $[W_{\\mathrm{dead}}, A_{\\min}]$ 的双元素列表，两者都表示为十进制实数。例如，输出格式必须完全是\n$$\n\\big[ [W_1, A_1], [W_2, A_2], [W_3, A_3] \\big].\n$$\n此问题不涉及物理单位。也不涉及角度。除了指定的单行输出外，不要打印任何额外文本。算法必须相对于有限定点模型是精确的；不要使用随机噪声模型或渐近近似。", "solution": "解决方案是通过在系统的有限状态空间上对其动力学进行精确仿真来找到的。核心原则是将定点信号值和算术运算映射到整数运算上，以避免浮点不精确性，并直接处理问题的离散性质。\n\n首先，我们形式化系统的状态及其演化。时间 $n$ 的状态是前两个输出组成的对 $\\mathbf{s}[n-1] = (y[n-1], y[n-2])$。由于信号值 $y$ 属于离散集合 $\\mathcal{Y}_{F_s} = \\{ m \\cdot \\Delta_s : m \\in \\mathbb{Z}, -2^{F_s} \\le m \\le 2^{F_s}-1 \\}$, 其中 $\\Delta_s = 2^{-F_s}$，因此用一个整数对 $(m_{n-1}, m_{n-2})$ 来表示状态是精确且在计算上有利的。整数乘数 $m$ 的范围从 $m_{\\min} = -2^{F_s}$ 到 $m_{\\max} = 2^{F_s}-1$。状态空间是一个包含 $(m_{\\max} - m_{\\min} + 1)^2 = (2 \\cdot 2^{F_s})^2 = 4 \\cdot 2^{2F_s}$ 个状态的有限网格。\n\n状态转移函数 $\\mathbf{s}[n] = \\Phi(\\mathbf{s}[n-1])$ 被实现为一个将整数状态 $(m_{n-1}, m_{n-2})$ 映射到下一个状态 $(m_n, m_{n-1})$ 的函数。新整数乘数 $m_n$ 的计算遵循指定的算术模型：\n1.  **系数的量化**：实系数 $a_1$ 和 $a_2$ 首先通过舍入到 $\\Delta_c = 2^{-F_c}$ 的最近倍数（平局情况舍入到最近的偶数量化级别），被量化为其定点表示 $\\widehat{a}_1$ 和 $\\widehat{a}_2$。此操作在每个测试案例中执行一次。\n    $$\n    \\widehat{a}_i = \\operatorname{round\\_to\\_nearest\\_even}(a_i, \\Delta_c)\n    $$\n2.  **乘积计算**：计算中间乘积 $p_1[n] = -\\widehat{a}_1 y[n-1]$ 和 $p_2[n] = -\\widehat{a}_2 y[n-2]$。在我们的整数模型中，这对应于计算 $-\\widehat{a}_1 m_{n-1} \\Delta_s$ 和 $-\\widehat{a}_2 m_{n-2} \\Delta_s$。\n3.  **舍入**：每个乘积都舍入到 $\\Delta_s$ 的最近倍数。一个中间值 $V$ 被舍入到 $k \\cdot \\Delta_s$，其中 $k$ 是最接近 $V/\\Delta_s$ 的整数。因此，第一个乘积的整数乘数 $m_{p1}$，是通过对值 $-\\widehat{a}_1 m_{n-1}$ 进行舍入得到的：\n    $$\n    m_{p1} = \\operatorname{round\\_half\\_to\\_even}(-\\widehat{a}_1 m_{n-1})\n    $$\n    类似地，$m_{p2} = \\operatorname{round\\_half\\_to\\_even}(-\\widehat{a}_2 m_{n-2})$。Python 3中的标准`round()`函数实现了所需的“平局朝偶数”规则。\n4.  **饱和与求和**：乘积的整数乘数被饱和到 $[m_{\\min}, m_{\\max}]$ 范围。饱和后的乘数 $m_{p1, \\text{sat}}$ 和 $m_{p2, \\text{sat}}$ 然后相加。和值再次被饱和到同一范围，得到新输出的最终整数乘数 $m_n$。\n    $$\n    m_n = \\operatorname{clip}(m_{p1, \\text{sat}} + m_{p2, \\text{sat}}, m_{\\min}, m_{\\max})\n    $$\n\n在一个有限状态空间上，对于一个确定性的状态转移函数，每个轨迹最终都必定会变成周期的，收敛到一个不动点或一个极限环。为了找到这些吸引子及其吸引盆，我们对状态空间进行穷举搜索。我们使用一个二维数组 `fate` 来存储每个状态的最终归宿。我们遍历每个状态 $(m_1, m_2)$。如果其归宿未知，我们就从该状态开始仿真轨迹，并记录路径。当路径遇到一个已被分类的状态，或重复了自身路径中的某个状态时，该路径的仿真终止，从而识别出一个新的周期。然后，新遍历路径中所有状态的归宿都会被记录下来。周期被分为零不动点 $(0,0)$ 或非零极限环，并为后者计算振幅。\n\n最后，我们计算所需的量：\n- **最小非零极限环振幅 ($A_{\\min}$)**：这是为所有已识别的非零极限环计算出的振幅中的最小值。一个周期的振幅定义为该周期内 $\\max|y[n]|$ 的值，其计算方式为 $(\\max|m_n|) \\cdot \\Delta_s$。如果没有发现非零周期，则 $A_{\\min}$ 为 $0$。\n- **死区宽度 ($W_{\\mathrm{dead}}$)**：死区与初始值 $y[-1]$（此时 $y[-2]=0$）的集合 $\\mathcal{D}$ 相关，对于这些初始值，系统会收敛到零不动点。我们找到最大的整数 $M \\ge 0$，使得对于范围在 $[-M, M]$ 内的所有整数乘数 $k$，从状态 $(k, 0)$ 开始的轨迹都收敛到零不动点 $(0,0)$。死区的半宽为 $D = M \\cdot \\Delta_s$，全宽为 $W_{\\mathrm{dead}} = 2D$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the IIR filter analysis problem for a suite of test cases.\n    \"\"\"\n\n    def analyze_system(a1, a2, Fc, Fs):\n        \"\"\"\n        Performs exact fixed-point simulation and analysis for a single system.\n\n        Args:\n            a1 (float): The ideal coefficient a1.\n            a2 (float): The ideal coefficient a2.\n            Fc (int): The number of fractional bits for coefficients.\n            Fs (int): The number of fractional bits for the signal.\n\n        Returns:\n            list: A list containing [W_dead, A_min].\n        \"\"\"\n        # 1. Setup\n        delta_c = 2**(-Fc)\n        delta_s = 2**(-Fs)\n        m_limit = 2**Fs\n        m_min = -m_limit\n        m_max = m_limit - 1\n\n        # Quantize coefficients using round-half-to-even\n        a1_hat = np.round(a1 / delta_c) * delta_c\n        a2_hat = np.round(a2 / delta_c) * delta_c\n\n        # State space representation: integer multipliers (m1, m2)\n        # fate array: 0=unvisited, -1=converges to zero, >0=cycle_id\n        state_space_dim = m_max - m_min + 1\n        fate = np.zeros((state_space_dim, state_space_dim), dtype=np.int32)\n        \n        cycles = {}  # {cycle_id: {'amplitude': float}}\n        cycle_id_counter = 1\n\n        # 2. State Space Traversal\n        for m1_init in range(m_min, m_max + 1):\n            for m2_init in range(m_min, m_max + 1):\n                idx1, idx2 = m1_init + m_limit, m2_init + m_limit\n                \n                if fate[idx1, idx2] != 0:\n                    continue\n\n                # Start a new trajectory simulation\n                s_current = (m1_init, m2_init)\n                path = [s_current]\n                path_dict = {s_current: 0}\n\n                while True:\n                    m_prev1, m_prev2 = s_current\n\n                    # Fixed-point arithmetic using integer multipliers\n                    # round() in Python 3 is round-half-to-even\n                    prod1 = round(-a1_hat * m_prev1)\n                    prod2 = round(-a2_hat * m_prev2)\n                    \n                    prod1_sat = int(np.clip(prod1, m_min, m_max))\n                    prod2_sat = int(np.clip(prod2, m_min, m_max))\n                    \n                    sum_val = prod1_sat + prod2_sat\n                    m_next = int(np.clip(sum_val, m_min, m_max))\n                    \n                    s_next = (m_next, m_prev1)\n                    \n                    next_idx1, next_idx2 = s_next[0] + m_limit, s_next[1] + m_limit\n                    \n                    if fate[next_idx1, next_idx2] != 0:\n                        merged_fate = fate[next_idx1, next_idx2]\n                        for s_in_path in path:\n                            s_idx1 = s_in_path[0] + m_limit\n                            s_idx2 = s_in_path[1] + m_limit\n                            fate[s_idx1, s_idx2] = merged_fate\n                        break\n                    \n                    if s_next in path_dict:\n                        cycle_start_index = path_dict[s_next]\n                        cycle_states = path[cycle_start_index:]\n                        transient_states = path[:cycle_start_index]\n\n                        if len(cycle_states) == 1 and cycle_states[0] == (0, 0):\n                            current_fate = -1\n                        else:\n                            current_fate = cycle_id_counter\n                            max_abs_m = 0\n                            for s_in_cycle in cycle_states:\n                                max_abs_m = max(max_abs_m, abs(s_in_cycle[0]))\n                            \n                            amplitude = max_abs_m * delta_s\n                            cycles[current_fate] = {'amplitude': amplitude}\n                            cycle_id_counter += 1\n\n                        for s in transient_states:\n                            fate[s[0] + m_limit, s[1] + m_limit] = current_fate\n                        for s in cycle_states:\n                            fate[s[0] + m_limit, s[1] + m_limit] = current_fate                        \n                        break\n\n                    path.append(s_next)\n                    path_dict[s_next] = len(path) - 1\n                    s_current = s_next\n\n        # 3. Calculate W_dead\n        m2_idx_zero = 0 + m_limit\n        max_m_deadband = 0\n        if fate[0 + m_limit, m2_idx_zero] == -1:\n            for m in range(1, m_limit):\n                fate_pos = fate[m + m_limit, m2_idx_zero]\n                fate_neg = fate[-m + m_limit, m2_idx_zero]\n                \n                if fate_pos == -1 and fate_neg == -1:\n                    max_m_deadband = m\n                else:\n                    break\n        D = max_m_deadband * delta_s\n        W_dead = 2 * D\n\n        # 4. Calculate A_min\n        all_amplitudes = [c['amplitude'] for c in cycles.values()]\n        A_min = min(all_amplitudes) if all_amplitudes else 0.0\n        \n        return [W_dead, A_min]\n\n    test_cases = [\n        (-1.8, 0.81, 6, 6),\n        (0.0, 0.0, 10, 5),\n        (-1.98, 0.9801, 10, 7),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_system(*case)\n        results.append(result)\n\n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2858969"}]}