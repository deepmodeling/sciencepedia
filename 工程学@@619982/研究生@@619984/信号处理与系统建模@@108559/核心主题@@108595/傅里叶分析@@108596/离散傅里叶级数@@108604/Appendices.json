{"hands_on_practices": [{"introduction": "离散傅里叶级数（DFS）最强大的应用之一，便是通过卷积定理将计算密集的时间域卷积操作，转化为简单的频率域乘积。这个练习将引导你定量地分析和比较这两种方法的计算成本，从而揭示为何以及在何种条件下，基于快速傅里叶变换（FFT）的频率域方法更为高效。通过亲手推导运算量并确定稀疏度盈亏平衡点 [@problem_id:2896155]，你将深刻体会到 DFS 在现代信号处理算法设计中的核心价值。", "problem": "考虑离散时间域中长度为$N$的复数周期序列，并设序列$x[n]$的离散傅里叶级数 (DFS) 由以下分析-合成对定义\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\Big(-j \\frac{2\\pi}{N}kn\\Big), \\quad\nx[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\!\\Big(j \\frac{2\\pi}{N}kn\\Big),\n$$\n其中 $k,n \\in \\{0,1,\\dots,N-1\\}$。两个序列 $x[n]$ 和 $h[n]$ 的长度为$N$的循环卷积为\n$$\ny[n] = \\sum_{m=0}^{N-1} x[m]\\, h[(n-m) \\bmod N].\n$$\n假设 $h[n]$ 是 $K$-稀疏的，意即其 $N$ 个元素中恰好有 $K$ 个非零，并且 $h[n]$ 的支撑集是已知的。你需要比较计算 $y[n]$ 的两种方法：\n- 在时域中利用 $h[n]$ 的稀疏性直接进行循环卷积，以及\n- 一种基于 DFS 的方法，该方法构建 $X[k]$ 并将其与 $H[k]$ 相乘，然后应用逆 DFS 得到 $y[n]$。\n\n假设使用以下计算模型：\n- 计算实数浮点运算次数，单位权重：每次实数加法计为 $1$，每次实数乘法计为 $1$。\n- 一次复数加法等于 $2$ 次实数加法。\n- 一次复数乘法等于 $4$ 次实数乘法和 $2$ 次实数加法，总共 $6$ 次实数运算。\n- DFS 及其逆变换使用基-2 Cooley–Tukey 快速傅里叶变换 (FFT) 实现。一个长度为 $N$ 的基-2 FFT 有 $\\log_2 N$ 个级，每级有 $N/2$ 个蝶形运算，每个蝶形运算恰好包含一次与旋转因子的复数乘法和两次复数加法。\n- $h[n]$ 的 DFS 是预先计算好的，并以 $H[k]$ 的形式提供，因此基于 DFS 的方法的每次评估成本包括对 $x[n]$ 的一次正向 FFT，$N$ 次逐点复数乘法 $X[k]H[k]$ 以及一次用于合成 $y[n]$ 的逆 FFT。\n\n从上述基本定义和任何可以推导出的性质出发，对这两种方法在 $N=4096$ 的特定情况下进行运算次数的比较。确定确切的收支平衡稀疏度 $K_{\\text{be}}$，在该稀疏度下，两种方法进行一次 $y[n]$ 的评估所需的实数运算总次数相同。将你最终的 $K_{\\text{be}}$ 结果以一个数字的形式报告。无需四舍五入。", "solution": "首先需要对所述问题进行验证，以确保其科学上合理、内容完整且定义明确。\n\n已知条件从问题陈述中逐字提取：\n- 序列是复数，周期为$N$。\n- 离散傅里叶级数 (DFS) 的分析方程为 $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp(-j \\frac{2\\pi}{N}kn)$。\n- DFS 的合成方程为 $x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp(j \\frac{2\\pi}{N}kn)$。\n- 索引 $k, n$ 在集合 $\\{0, 1, \\dots, N-1\\}$ 中。\n- 长度为$N$的循环卷积为 $y[n] = \\sum_{m=0}^{N-1} x[m]\\, h[(n-m) \\bmod N]$。\n- 序列 $h[n]$ 是 $K$-稀疏的，意即其 $N$ 个元素中恰好有 $K$ 个非零。\n- $h[n]$ 的支撑集（非零元素的位置）是已知的。\n- 具体长度为 $N=4096$。\n- 计算成本模型计算实数浮点运算 (FLOPS) 次数：\n    - 一次实数加法成本为 $1$ FLOP。\n    - 一次实数乘法成本为 $1$ FLOP。\n    - 一次复数加法等效于 $2$ 次实数加法（$2$ FLOPS）。\n    - 一次复数乘法等效于 $4$ 次实数乘法和 $2$ 次实数加法（$6$ FLOPS）。\n- DFS 及其逆变换使用基-2 Cooley–Tukey 快速傅里叶变换 (FFT) 计算。\n- 一个长度为 $N$ 的基-2 FFT 有 $\\log_2 N$ 个级。\n- 每级有 $N/2$ 个蝶形运算。\n- 每个蝶形运算的计算包含一次复数乘法和两次复数加法。\n- $h[n]$ 的 DFS，记作 $H[k]$，是预先计算的，其成本不包含在比较中。\n- 基于 DFS 的方法成本包括：对 $x[n]$ 的一次正向 FFT，$N$ 次逐点复数乘法，以及对乘积的一次逆 FFT。\n\n该问题是有效的。它在科学上基于数字信号处理的既定原理，特别是离散傅里叶分析和卷积快速算法的理论。该问题定义明确，提供了所有必要的定义、常数（$N=4096$）和一个完整的计算成本模型，从而可以得到一个唯一的、确定性的解。问题陈述是客观的，并使用了精确、标准的术语。没有矛盾、歧义或缺失的信息。使用基-2 FFT 与 $N=4096$ 相符，因为 $4096$ 是 $2$ 的幂（$4096 = 2^{12}$）。\n\n我们开始求解。目标是找到收支平衡稀疏度 $K_{\\text{be}}$，使得直接时域方法的计算成本等于频域（基于FFT）方法的成本。\n\n首先，我们确定直接方法 $C_D$ 的计算成本。循环卷积由下式给出\n$$\ny[n] = \\sum_{m=0}^{N-1} x[m]\\, h[(n-m) \\bmod N].\n$$\n要计算单个输出样本 $y[n]$，此求和涉及 $N$ 次乘法和 $N-1$ 次加法。然而，序列 $h[n]$ 是 $K$-稀疏的。由于 $h[n]$ 的支撑集是已知的，我们可以利用这种稀疏性。设 $h[n]$ 的非零项的索引集合为 $\\mathcal{S}_h = \\{n_1, n_2, \\dots, n_K\\}$。对于给定的 $n$，卷积和简化为仅对 $K$ 项的求和。对于每个 $n \\in \\{0, 1, \\dots, N-1\\}$，计算如下\n$$\ny[n] = \\sum_{i=1}^{K} x[(n-n_i) \\bmod N] \\, h[n_i].\n$$\n对于每个输出样本 $y[n]$，我们执行 $K$ 次复数乘法（求和中的每一项一次）和 $K-1$ 次复数加法来对所得乘积求和。\n以实数运算次数计算一个样本 $y[n]$ 的成本是：\n- $K$ 次复数乘法的成本：$K \\times (4 \\text{ 次实数乘法} + 2 \\text{ 次实数加法}) = K \\times 6 = 6K$ FLOPS。\n- $K-1$ 次复数加法的成本：$(K-1) \\times (2 \\text{ 次实数加法}) = 2K-2$ FLOPS。\n一个样本 $y[n]$ 的总成本是 $6K + (2K-2) = 8K-2$ FLOPS。\n要计算 $n=0, 1, \\dots, N-1$ 的整个输出序列 $y[n]$，我们必须重复此计算 $N$ 次。\n因此，直接方法的总成本是\n$$\nC_D(K) = N(8K-2).\n$$\n\n接下来，我们确定基于 FFT 的方法 $C_F$ 的计算成本。此方法包括三个步骤：\n1. 计算 $x[n]$ 的 DFS：$X[k] = \\text{FFT}(x[n])$。\n2. 在频域中执行逐点乘法：$Y[k] = X[k]H[k]$。\n3. 计算逆 DFS 以获得结果：$y[n] = \\text{IFFT}(Y[k])$。\n\n我们使用提供的模型分析每个步骤的成本。\n一个 $N$ 点基-2 FFT 的成本基于其结构。它有 $\\log_2 N$ 个级，每级有 $N/2$ 个蝶形运算。每个蝶形运算涉及 $1$ 次复数乘法和 $2$ 次复数加法。\n一个蝶形运算的实数运算成本是：\n- $1$ 次复数乘法：$6$ FLOPS。\n- $2$ 次复数加法：$2 \\times 2 = 4$ FLOPS。\n每个蝶形运算的总成本是 $6+4=10$ FLOPS。\n一个 $N$ 点 FFT 的总成本是级的数量乘以每级的蝶形运算数量再乘以每个蝶形运算的成本：\n$$\nC_{\\text{FFT}} = (\\log_2 N) \\times \\Big(\\frac{N}{2}\\Big) \\times 10 = 5N \\log_2 N \\text{ FLOPS}.\n$$\n问题指出逆 FFT 具有相同的实现基础。我们假设其计算成本与正向 FFT 相同。这是一个标准的假设，因为 IFFT 算法仅在指数参数的符号和一个最终的 $1/N$ 缩放因子上有所不同，后者的运算成本与整体相比通常被认为是可忽略的，或者被吸收到算法的各个级中而不改变整体复杂度级别。问题陈述将过程分为三个独立的计算块，这意味着我们按定义将它们的成本相加。\n\n总成本 $C_F$ 是正向 FFT、逐点乘法和逆 FFT 的成本之和。\n- $x[n]$ 的正向 FFT 成本：$5N \\log_2 N$。\n- $N$ 次逐点复数乘法 $X[k]H[k]$ 的成本：$N \\times (6 \\text{ FLOPS/次乘法}) = 6N$。\n- 逆 FFT 成本：$5N \\log_2 N$。\n\n将这些部分相加，得到基于 FFT 的方法的总成本：\n$$\nC_F = 5N \\log_2 N + 6N + 5N \\log_2 N = 10N \\log_2 N + 6N.\n$$\n\n收支平衡点 $K_{\\text{be}}$ 是两种成本相等时的 $K$ 值：$C_D(K_{\\text{be}}) = C_F$。\n$$\nN(8K_{\\text{be}}-2) = 10N \\log_2 N + 6N.\n$$\n由于 $N=4096 \\neq 0$，我们可以将整个方程除以 $N$：\n$$\n8K_{\\text{be}}-2 = 10 \\log_2 N + 6.\n$$\n现在，我们求解 $K_{\\text{be}}$：\n$$\n8K_{\\text{be}} = 10 \\log_2 N + 8.\n$$\n$$\nK_{\\text{be}} = \\frac{10 \\log_2 N + 8}{8} = \\frac{5}{4}\\log_2 N + 1.\n$$\n问题指定 $N=4096$。我们计算 $\\log_2 N$：\n$$\n\\log_2(4096) = \\log_2(2^{12}) = 12.\n$$\n将此值代入 $K_{\\text{be}}$ 的表达式中：\n$$\nK_{\\text{be}} = \\frac{5}{4}(12) + 1 = 5 \\times 3 + 1 = 15 + 1 = 16.\n$$\n因此，当稀疏度为 $K=16$ 时，两种方法的计算成本相同。当 $K16$ 时，直接法更有效。当 $K16$ 时，基于 FFT 的方法更有效。确切的收支平衡稀疏度是 $16$。", "answer": "$$\\boxed{16}$$", "id": "2896155"}, {"introduction": "在了解了 DFS 在算法优化中的威力后，我们来探讨一个现实中的挑战：如何精确地表示带有不连续性（即跳变）的信号。虽然 DFS 理论上可以表示任何周期信号，但使用有限项的级数逼近时，会在跳变点附近产生被称为“吉布斯现象”的振荡和过冲。本练习 [@problem_id:2896135] 是一个编程实践，它要求你构建一个阶跃信号，并通过截断其 DFS 级数来亲眼观察并量化这一现象，这对于建立关于傅里叶级数收敛特性的直观理解至关重要。", "problem": "您的任务是编写一个完整且可运行的程序，该程序构建一个离散时间周期阶跃序列，计算其离散傅里叶级数 (DFS) 的部分和，并定量评估间断点附近的离散时间吉布斯现象。目标是测试您基于第一性原理，对应用于具有跳跃间断点的序列时 DFS 及其部分和的性质进行的推理。\n\n定义和使用的约束条件：\n- 考虑一个周期为 $N \\in \\mathbb{Z}_{0}$ 的复值离散时间序列 $x[n]$。使用标准的离散傅里叶变换 (DFT) 约定（等效于周期序列的离散傅里叶级数 (DFS) 约定），其中复指数的角度以弧度为单位：\n  - 分析式：$X[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi k n / N}$，对于 $k \\in \\{0,1,\\dots,N-1\\}$。\n  - 合成式：$x[n] = \\dfrac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi k n / N}$，对于所有整数 $n$。\n  - 角度必须使用弧度。\n- 通过指定一个上升沿索引 $n_0 \\in \\{0,1,\\dots,N-1\\}$ 和一个活跃持续时间 $L \\in \\{1,2,\\dots,N-1\\}$，来定义一个具有电平 $x_{\\text{low}}$ 和 $x_{\\text{high}}$ 的阶跃序列。周期为 $N$ 的阶跃为\n  $$\n  x[n] =\n  \\begin{cases}\n  x_{\\text{high}},  n \\in \\{ n_0, n_0+1, \\dots, n_0+L-1 \\} \\ (\\text{所有索引按模 } N \\text{ 计算}),\\\\\n  x_{\\text{low}},  \\text{其他情况}.\n  \\end{cases}\n  $$\n  这会在 $n=n_0$ 处产生一个上升跳变（从 $x_{\\text{low}}$ 到 $x_{\\text{high}}$），并在 $n = n_0 + L$ 处产生一个下降跳变（索引按模 $N$ 计算）。假设 $x_{\\text{high}} \\neq x_{\\text{low}}$，因此跳变幅度 $\\Delta \\triangleq x_{\\text{high}} - x_{\\text{low}} \\neq 0$。\n- 对于一个整数部分和阶数 $M$，其中 $M \\in \\{0,1,\\dots,\\lfloor (N-1)/2 \\rfloor\\}$，通过在 DFS 意义上保留 $2M+1$ 个中心谐波 $\\{-M,-M+1,\\dots,0,\\dots,M\\}$ 来定义 DFS 部分和 $x_M[n]$。具体来说，使用 DFT $X[k]$，保留索引 $k \\in \\{0,1,\\dots,M\\} \\cup \\{N-M, \\dots, N-1\\}$，并将所有其他 $X[k]$ 置零；然后通过逆 DFT 合成 $x_M[n]$。这在离散时间设置下得到了 $2M+1$ 项的傅里叶部分和。\n- 为表征在 $n=n_0$ 处上升沿附近的离散时间吉布斯现象，计算 $x_M[n]$ 相对于理想阶跃电平的局部过冲和下冲，并用跳变幅度 $\\Delta$ 进行归一化。设窗口半宽为 $w \\triangleq \\max\\{1, \\lfloor 0.1 N \\rfloor\\}$。考虑索引集合 $\\mathcal{W} \\triangleq \\{ n_0 - w, n_0 - w + 1, \\dots, n_0 + w \\}$，其中索引在模 $N$ 意义下理解。\n  - 过冲比为\n    $$\n    \\rho_{\\text{over}} \\triangleq \\max\\left\\{ 0, \\frac{\\max_{n \\in \\mathcal{W}} x_M[n] - x_{\\text{high}}}{\\Delta} \\right\\}。\n    $$\n  - 下冲比为\n    $$\n    \\rho_{\\text{under}} \\triangleq \\max\\left\\{ 0, \\frac{x_{\\text{low}} - \\min_{n \\in \\mathcal{W}} x_M[n]}{\\Delta} \\right\\}。\n    $$\n  两个比率都必须报告为纯小数（无量纲），而不是百分比。\n\n任务：\n- 从第一性原理出发，实现 $x[n]$ 的构建、其 DFT $X[k]$ 的计算、通过保留 $2M+1$ 个中心谐波构成部分和频谱，以及 $x_M[n]$ 的合成。\n- 然后，为以下参数集的测试套件计算上述定义的 $\\rho_{\\text{over}}$ 和 $\\rho_{\\text{under}}$。每个测试案例以元组 $(N, n_0, L, x_{\\text{low}}, x_{\\text{high}}, M)$ 的形式给出：\n\n测试套件（涵盖典型情况、增加阶数、占空比变化、边界阶数和小周期效应）：\n- 案例 1： $(128, 64, 64, 0, 1, 31)$。\n- 案例 2： $(128, 64, 64, 0, 1, 63)$。\n- 案例 3： $(129, 10, 39, 0, 1, 40)$。\n- 案例 4： $(128, 64, 64, 0, 1, 0)$。\n- 案例 5： $(16, 8, 8, 0, 1, 7)$。\n- 案例 6： $(128, 64, 64, 0, 1, 1)$。\n\n输出规格：\n- 对于每个测试案例，按 $(\\rho_{\\text{over}}, \\rho_{\\text{under}})$ 的顺序输出两个比率，两者均使用标准的四舍五入到最近值的方法，精确到 $6$ 位小数。\n- 将所有案例的结果按测试案例顺序汇总到一个扁平列表中。也就是说，最终输出是包含 $12$ 个小数的单行列表：\n  $$\n  [\\rho_{\\text{over}}^{(1)}, \\rho_{\\text{under}}^{(1)}, \\rho_{\\text{over}}^{(2)}, \\rho_{\\text{under}}^{(2)}, \\dots, \\rho_{\\text{over}}^{(6)}, \\rho_{\\text{under}}^{(6)}].\n  $$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如, $[r_1,r_2,\\dots,r_{12}]$）。整个计算过程中角度必须使用弧度，所有报告的值都是纯小数（无单位，无百分号）。\n\n要求的科学基础：\n- 从上述 DFS 分析和合成定义、截断谐波以形成部分和的概念，以及复指数的正交性等标准性质出发。不要依赖任何预先引用的特例闭合形式作为计算捷径；直接从 DFS 框架推导并实现算法。", "solution": "所述问题是有效的。它在科学上基于既定的离散傅里叶级数 (DFS) 对周期信号的分析原理，在数学上是适定的，并提供了所有必要的参数和定义，且完全客观。不存在不一致、歧义或事实错误。因此，我们将从第一性原理出发，进行严谨的求解。\n\n任务是在离散时间域中数值分析吉布斯现象。这种现象是使用截断的傅里叶级数表示具有跳跃间断点的函数时的一个固有属性。级数的部分和在间断点附近会表现出振荡，或称“波纹”，其中振荡的峰值会超过函数的真实值。我们需要构建一个离散时间周期阶跃序列，使用截断的 DFS 计算其近似值，并量化由此产生的过冲和下冲。\n\n整个过程将直接从所提供的 DFS 分析和合成对的定义中推导出来。\n\n1.  **周期阶跃序列 $x[n]$ 的构建**\n    问题定义了一个周期为 $N$ 的阶跃序列 $x[n]$，它有两个电平：$x_{\\text{low}}$ 和 $x_{\\text{high}}$。该序列从索引 $n_0$ 开始的连续 $L$ 个采样点上处于高电平，在其他位置则处于低电平。索引按模 $N$ 进行解释。\n    要为一组给定的参数 $(N, n_0, L, x_{\\text{low}}, x_{\\text{high}})$ 构建此序列，我们首先创建一个长度为 $N$ 的数值数组，并将其所有元素初始化为 $x_{\\text{low}}$。随后，我们确定对应于高电平部分的索引，即 $\\{n_0, n_0+1, \\dots, n_0+L-1\\}$。使用模 $N$ 算术，这些索引被正确地映射到 $[0, N-1]$ 的范围内。然后将数组在这些特定索引处的元素设置为 $x_{\\text{high}}$。跳变幅度定义为 $\\Delta = x_{\\text{high}} - x_{\\text{low}}$。\n\n2.  **DFS 分析：系数 $X[k]$ 的计算**\n    DFS 分析方程提供了周期序列 $x[n]$ 的频域表示 $X[k]$：\n    $$\n    X[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi k n / N}\n    $$\n    这是离散傅里叶变换 (DFT) 的标准定义。对于数值计算，我们采用快速傅里叶变换 (FFT) 算法，它是该求和过程的一种高效实现。结果是一个包含 $N$ 个复值 DFS 系数的数组 $X$。\n\n3.  **部分和频谱 $X_M[k]$ 的构成**\n    DFS 部分和 $x_M[n]$ 是从一组截断的 DFS 系数合成而来的。问题规定要保留 $2M+1$ 个“中心”谐波。对于长度为 $N$ 的 DFS 频谱，频率索引 $k \\in \\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$ 对应于非负频率，而索引 $k \\in \\{\\lfloor N/2 \\rfloor + 1, \\dots, N-1\\}$ 对应于负频率，其中 $X[N-k]$ 代表对应于 $-k$ 的频率系数。\n    因此，保留从 $-M$ 到 $M$ 的中心谐波等效于保留 $k \\in \\{0, 1, \\dots, M\\}$ 和 $k \\in \\{N-M, \\dots, N-1\\}$ 的系数 $X[k]$。通过将 $X[k]$ 的所有其他系数置零来形成一个新的频谱 $X_M[k]$ 。这实际上是 $X[k]$ 与一个理想低通滤波器掩模的频域相乘。\n\n4.  **DFS 合成：部分和序列 $x_M[n]$ 的计算**\n    部分和序列 $x_M[n]$ 是通过将 DFS 合成公式应用于截断频谱 $X_M[k]$ 得到的：\n    $$\n    x_M[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X_M[k] \\, e^{j 2\\pi k n / N}\n    $$\n    这是离散傅里叶逆变换 (IDFT) 的定义。我们使用快速傅里叶逆变换 (IFFT) 算法进行计算。IFFT 正确地实现了这个合成求和，包括 $1/N$ 的缩放因子。由于原始序列 $x[n]$ 是实值的，并且其频谱的截断保持了共轭对称性（即 $X_M[k] = X_M[N-k]^*$），因此得到的序列 $x_M[n]$ 也必须是实数。数值结果中任何残余的虚部都是由浮点精度误差引起的，必须舍弃。\n\n5.  **吉布斯现象的量化**\n    为了量化过冲和下冲，我们检查 $x_M[n]$ 在 $n=n_0$ 处上升沿间断点周围窗口内的行为。\n    窗口半宽为 $w = \\max\\{1, \\lfloor 0.1 N \\rfloor\\}$。\n    用于分析的索引集合是 $\\mathcal{W} = \\{ n_0 - w, \\dots, n_0, \\dots, n_0 + w\\}$，所有索引均按模 $N$ 计算。\n    在此窗口内，我们找到最大值 $\\max_{n \\in \\mathcal{W}} x_M[n]$ 和最小值 $\\min_{n \\in \\mathcal{W}} x_M[n]$。\n    然后根据提供的公式计算归一化的过冲和下冲比：\n    $$\n    \\rho_{\\text{over}} = \\max\\left\\{ 0, \\frac{\\max_{n \\in \\mathcal{W}} x_M[n] - x_{\\text{high}}}{\\Delta} \\right\\}\n    $$\n    $$\n    \\rho_{\\text{under}} = \\max\\left\\{ 0, \\frac{x_{\\text{low}} - \\min_{n \\in \\mathcal{W}} x_M[n]}{\\Delta} \\right\\}\n    $$\n    对问题陈述中指定的每个测试案例执行这些计算。最终结果四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a discrete-time periodic step sequence, computes its Discrete Fourier Series (DFS)\n    partial sums, and quantitatively evaluates the discrete-time Gibbs phenomenon.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, n0, L, x_low, x_high, M)\n    test_cases = [\n        (128, 64, 64, 0, 1, 31),\n        (128, 64, 64, 0, 1, 63),\n        (129, 10, 39, 0, 1, 40),\n        (128, 64, 64, 0, 1, 0),\n        (16, 8, 8, 0, 1, 7),\n        (128, 64, 64, 0, 1, 1),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, n0, L, x_low, x_high, M = case\n        \n        # Step 1: Construct the periodic step sequence x[n]\n        # Initialize sequence with the low value\n        x = np.full(N, x_low, dtype=float)\n        \n        # Determine indices for the high value, handling wrapping with modulo N\n        high_indices = (n0 + np.arange(L)) % N\n        x[high_indices] = x_high\n\n        # Jump magnitude\n        delta = x_high - x_low\n        # delta must not be zero, though problem statement guarantees this.\n        if np.isclose(delta, 0):\n            # This case will not occur with the given test suite\n            results.extend([0.0, 0.0])\n            continue\n\n        # Step 2: Compute the DFS coefficients X[k] via FFT\n        X = np.fft.fft(x)\n\n        # Step 3: Form the partial sum spectrum X_M[k]\n        # Create a mask to retain the 2M+1 centered harmonics\n        mask = np.zeros(N, dtype=float)\n        # Harmonics from k=0 to k=M\n        mask[0:M + 1] = 1\n        # Corresponding negative harmonics k=-1 to -M, which map to N-1 to N-M\n        if M > 0:\n            mask[N - M:N] = 1\n        \n        X_M = X * mask\n\n        # Step 4: Synthesize the partial sum sequence x_M[n] via IFFT\n        x_M = np.fft.ifft(X_M)\n        \n        # The result should be real; take the real part to discard numerical noise\n        x_M_real = x_M.real\n\n        # Step 5: Quantify the Gibbs phenomenon\n        # Define the analysis window around the discontinuity at n0\n        w = max(1, int(0.1 * N))\n        window_indices = (n0 + np.arange(-w, w + 1)) % N\n        \n        # Get the partial sum values within the window\n        x_M_window = x_M_real[window_indices]\n\n        # Find max and min values in the window\n        max_val_in_window = np.max(x_M_window)\n        min_val_in_window = np.min(x_M_window)\n\n        # Calculate overshoot and undershoot ratios\n        rho_over = max(0.0, (max_val_in_window - x_high) / delta)\n        rho_under = max(0.0, (x_low - min_val_in_window) / delta)\n\n        # Append rounded results to the list\n        results.append(rho_over)\n        results.append(rho_under)\n\n    # Final print statement in the exact required format.\n    # Round to 6 decimal places and format as a string.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2896135"}, {"introduction": "最后，让我们深入傅里叶表示的一个更为根本的性质：幅度和相位所包含的信息。一个信号由其频谱的幅度和相位共同唯一确定，但这两部分信息的重要性是否对等？此练习 [@problem_id:2896131] 将挑战你构建一个思想实验，证明仅凭幅度谱信息不足以唯一地重构原始信号。通过这个构造过程，你将揭示相位信息在信号处理中的关键作用，这个问题在图像处理和密码学等领域被称为“相位恢复问题”。", "problem": "设 $N \\geq 3$ 是一个固定的正整数。考虑长度为 $N$ 的周期序列及其 $N$ 点离散傅里叶级数 (DFS)，定义为\n$$\nX[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-j \\frac{2\\pi}{N} k n\\right), \\quad k=0,1,\\dots,N-1,\n$$\n其逆变换为\n$$\nx[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp\\!\\left(j \\frac{2\\pi}{N} k n\\right), \\quad n=0,1,\\dots,N-1.\n$$\n构造两个明确且不同的 $N$ 周期序列 $x_{1}[n]$ 和 $x_{2}[n]$，使得对于每个谐波指数 $k$，它们的 DFS 幅度相同，即对所有 $k$ 都有 $|X_{1}[k]| = |X_{2}[k]|$，但至少对某个 $k$，它们的相位不同，即对某个 $k$ 有 $\\arg X_{1}[k] \\neq \\arg X_{2}[k]$。您的构造必须直接根据上述 DFS 定义进行证明，而不是通过引用任何未经证明的变换性质。然后，计算平方欧几里得距离\n$$\nD \\triangleq \\sum_{n=0}^{N-1} \\left| x_{1}[n] - x_{2}[n] \\right|^{2}.\n$$\n将您的最终答案表示为单个实数或封闭形式的解析表达式。最后，仅使用基于 DFS 定义的推理，解释您的构造对于仅从 DFS 幅度数据重建信号的唯一性的影响。不需要数值四舍五入，也没有物理单位适用。", "solution": "首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   $N \\geq 3$ 是一个固定的正整数。\n-   长度为 $N$ 的周期序列 $x[n]$。\n-   $N$ 点离散傅里叶级数 (DFS): $X[k] \\triangleq \\sum_{n=0}^{N-1} x[n] \\exp(-j \\frac{2\\pi}{N} k n)$, for $k=0,1,\\dots,N-1$。\n-   逆 DFS: $x[n] \\triangleq \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp(j \\frac{2\\pi}{N} k n)$, for $n=0,1,\\dots,N-1$。\n-   要求构造：两个不同的 $N$ 周期序列 $x_{1}[n]$ 和 $x_{2}[n]$，使得对所有 $k$ 都有 $|X_{1}[k]| = |X_{2}[k]|$，但至少对某个 $k$ 有 $\\arg X_{1}[k] \\neq \\arg X_{2}[k]$。\n-   要求计算：平方欧几里得距离 $D \\triangleq \\sum_{n=0}^{N-1} | x_{1}[n] - x_{2}[n] |^{2}$。\n-   要求解释：基于给定定义，该构造对仅从 DFS 幅度数据重建信号的唯一性的影响。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题是离散时间信号处理中的一个标准练习，基于离散傅里叶级数的基本定义。所有概念在数学上都是合理的。\n-   **适定性：** 问题陈述清晰，提供了所有必要的定义和约束。它要求进行特定的构造和后续计算，这是一个明确定义的任务。约束条件 $N \\geq 3$ 至关重要且已正确指定。\n-   **客观性：** 问题以精确、客观的数学语言表述，没有歧义或主观内容。\n-   该问题不违反任何其他有效性标准。它不是不完整的、矛盾的、不切实际的、不适定的或琐碎的。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供完整的解答。\n\n我们首先构造两个序列 $x_{1}[n]$ 和 $x_{2}[n]$。一个满足要求的简单且标准的例子是使用移位的单位冲激。我们定义序列如下：\n$$x_{1}[n] \\triangleq \\delta[n-1]$$\n$$x_{2}[n] \\triangleq \\delta[n-(N-1)]$$\n其中 $\\delta[m]$ 是离散时间单位冲激（Kronecker δ），当 $m \\equiv 0 \\pmod{N}$ 时为 $1$，否则为 $0$。\n\n现在我们必须仅基于所提供的 DFS 定义进行推理，来验证此构造满足所有陈述的要求。\n$1$. **序列的差异性**：序列 $x_{1}[n]$ 仅在 $n=1$ 时非零，此时 $x_{1}[1]=1$。序列 $x_{2}[n]$ 仅在 $n=N-1$ 时非零，此时 $x_{2}[N-1]=1$。由于问题指定 $N \\geq 3$，索引 $1$ 和 $N-1$ 是不同的。因此，$x_{1}[n]$ 和 $x_{2}[n]$ 是不同的序列。\n\n$2$. **DFS 性质**：我们直接根据定义计算每个序列的 DFS。\n对于 $x_{1}[n]$，其 DFS $X_{1}[k]$ 为：\n$$X_{1}[k] = \\sum_{n=0}^{N-1} \\delta[n-1] \\exp\\left(-j \\frac{2\\pi}{N} k n\\right) = \\exp\\left(-j \\frac{2\\pi}{N} k \\cdot 1\\right) = \\exp\\left(-j \\frac{2\\pi k}{N}\\right)$$\n对于 $x_{2}[n]$，其 DFS $X_{2}[k]$ 为：\n$$X_{2}[k] = \\sum_{n=0}^{N-1} \\delta[n-(N-1)] \\exp\\left(-j \\frac{2\\pi}{N} k n\\right) = \\exp\\left(-j \\frac{2\\pi}{N} k (N-1)\\right) = \\exp\\left(-j 2\\pi k + j \\frac{2\\pi k}{N}\\right) = \\exp\\left(j \\frac{2\\pi k}{N}\\right)$$\n现在我们来考察幅度和相位。\n幅度为：\n$$|X_{1}[k]| = \\left|\\exp\\left(-j \\frac{2\\pi k}{N}\\right)\\right| = 1$$\n$$|X_{2}[k]| = \\left|\\exp\\left(j \\frac{2\\pi k}{N}\\right)\\right| = 1$$\n显然，对所有 $k \\in \\{0, 1, \\dots, N-1\\}$，都有 $|X_{1}[k]| = |X_{2}[k]|$。幅度条件得到满足。\n\n相位为：\n$$\\arg X_{1}[k] = -\\frac{2\\pi k}{N} \\pmod{2\\pi}$$\n$$\\arg X_{2}[k] = \\frac{2\\pi k}{N} \\pmod{2\\pi}$$\n为了使相位不同，我们需要找到一个 $k$，使得 $\\arg X_{1}[k] \\neq \\arg X_{2}[k]$。这等价于 $-\\frac{2\\pi k}{N} \\not\\equiv \\frac{2\\pi k}{N} \\pmod{2\\pi}$，可以简化为要求 $\\frac{4\\pi k}{N}$ 不是 $2\\pi$ 的整数倍，或者说 $\\frac{2k}{N}$ 不是整数。\n我们选择 $k=1$。由于 $N \\geq 3$，值 $\\frac{2(1)}{N} = \\frac{2}{N}$ 不是整数。因此，对于 $k=1$，$\\arg X_{1}[1] = -2\\pi/N$ 和 $\\arg X_{2}[1] = 2\\pi/N$ 确实是不同的。相位条件得到满足。\n\n验证了我们的构造之后，我们现在计算平方欧几里得距离 $D$：\n$$D \\triangleq \\sum_{n=0}^{N-1} \\left| x_{1}[n] - x_{2}[n] \\right|^{2}$$\n差分序列为 $d[n] = x_{1}[n] - x_{2}[n] = \\delta[n-1] - \\delta[n-(N-1)]$。在一个周期 $n \\in \\{0, 1, \\dots, N-1\\}$ 内，该序列包含以下值：\n$$d[n] = \\begin{cases} 1  n=1 \\\\ -1  n=N-1 \\\\ 0  \\text{otherwise} \\end{cases}$$\n这些值的平方幅值之和为：\n$$D = |d[1]|^{2} + |d[N-1]|^{2} + \\sum_{n \\in \\{0, \\dots, N-1\\}, n \\neq 1, n \\neq N-1} |d[n]|^{2} = |1|^{2} + |-1|^{2} + 0 = 1 + 1 = 2$$\n平方欧几里得距离为 $2$。\n\n作为验证，这个结果可以通过 Parseval 定理推导出来，而该定理必须首先根据给定的定义来证明。对于任何序列 $y[n]$ 及其 DFS $Y[k]$：\n$$ \\sum_{n=0}^{N-1} |y[n]|^2 = \\sum_{n=0}^{N-1} y[n] y^*[n] = \\sum_{n=0}^{N-1} \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j\\frac{2\\pi}{N}kn}\\right) \\left(\\frac{1}{N} \\sum_{l=0}^{N-1} Y^*[l] e^{-j\\frac{2\\pi}{N}ln}\\right) $$\n$$ = \\frac{1}{N^2} \\sum_{k=0}^{N-1} \\sum_{l=0}^{N-1} Y[k] Y^*[l] \\left(\\sum_{n=0}^{N-1} e^{j\\frac{2\\pi}{N}(k-l)n}\\right) $$\n当 $k=l$ 时，内层求和等于 $N$，否则为 $0$。这将表达式简化为：\n$$ \\sum_{n=0}^{N-1} |y[n]|^2 = \\frac{1}{N^2} \\sum_{k=0}^{N-1} Y[k] Y^*[k] (N) = \\frac{1}{N} \\sum_{k=0}^{N-1} |Y[k]|^2 $$\n将此应用于我们的差分序列 $d[n]$，其 DFS 为 $D[k] = X_{1}[k] - X_{2}[k]$：\n$$ D = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_{1}[k] - X_{2}[k]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left| e^{-j \\frac{2\\pi k}{N}} - e^{j \\frac{2\\pi k}{N}} \\right|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left| -2j \\sin\\left(\\frac{2\\pi k}{N}\\right) \\right|^2 = \\frac{4}{N} \\sum_{k=0}^{N-1} \\sin^2\\left(\\frac{2\\pi k}{N}\\right) $$\n使用恒等式 $\\sin^2(\\theta) = \\frac{1}{2}(1-\\cos(2\\theta))$：\n$$ D = \\frac{4}{N} \\sum_{k=0}^{N-1} \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{4\\pi k}{N}\\right)\\right) = \\frac{2}{N} \\left( \\sum_{k=0}^{N-1} 1 - \\sum_{k=0}^{N-1} \\cos\\left(\\frac{4\\pi k}{N}\\right) \\right) $$\n第一个和是 $N$。第二个和是几何级数和 $\\sum_{k=0}^{N-1} (\\exp(j\\frac{4\\pi}{N}))^k$ 的实部，由于对于 $N \\geq 3$ 其公比不为 $1$，因此该和为零。所以，$\\sum \\cos(\\dots)=0$。\n$$ D = \\frac{2}{N} (N - 0) = 2 $$\n这证实了直接在时域中计算得到的结果。\n\n最后，我们解释该构造对于仅从 DFS 幅度数据重建信号的唯一性的影响。逆 DFS 定义，$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\exp(j \\frac{2\\pi}{N} k n)$，可以用幅度和相位表示为：\n$$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]| \\exp(j \\arg X[k]) \\exp\\left(j \\frac{2\\pi}{N} k n\\right)$$\n这个公式明确表明，重建序列 $x[n]$ 需要同时知道 DFS 幅度 $|X[k]|$ 和 DFS 相位 $\\arg X[k]$。我们的构造提供了一个具体的反例，说明了仅从幅度进行唯一重建的可能性是不成立的。我们已经证明了存在两个不同的序列 $x_{1}[n]$ 和 $x_{2}[n]$，它们产生相同的 DFS 幅度谱 $|X_{1}[k]| = |X_{2}[k]|$。一个只被提供了这个幅度谱的观察者无法确定原始序列是 $x_{1}[n]$ 还是 $x_{2}[n]$，因为区分它们的相位信息是不可用的。这表明从序列 $x[n]$ 到其 DFS 幅度谱 $|X[k]|$ 的映射不是单射（一对一）的。因此，在没有额外信息或约束（例如最小相位、因果性或信号的已知属性）的情况下，从任意信号的傅里叶幅度中唯一地恢复该信号是根本不可能的。", "answer": "$$\\boxed{2}$$", "id": "2896131"}]}