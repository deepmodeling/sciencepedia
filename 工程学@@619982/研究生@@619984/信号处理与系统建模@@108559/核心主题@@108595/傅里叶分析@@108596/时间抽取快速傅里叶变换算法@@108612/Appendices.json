{"hands_on_practices": [{"introduction": "第一个练习通过一个简单具体的例子，揭开了时间抽取（DIT）FFT算法的神秘面纱。你将亲手执行其初始步骤：通过位倒序对输入进行重排，并计算第一级“蝶形”运算的结果。这项基础实践能让你对算法如何开始变换时域信号有一个切实的理解，并为后续更复杂的阶段建立起直观的认识 [@problem_id:1711383]。", "problem": "使用一个标准的基-2 时域抽取 (DIT) 快速傅里叶变换 (FFT) 算法来分析一个 4 点离散时间信号。该算法首先根据时间索引的位倒序对输入序列 $x[n]$ 进行重排。重排之后，第一个计算阶段通过对位倒序序列的相邻对执行 2 点离散傅里叶变换 (DFT)，产生一个中间序列 $G[n]$。\n\n考虑一个输入序列，其定义为 $x[n] = (1+\\mathrm{j})^{n}$，其中 $n=0, 1, 2, 3$，$\\mathrm{j}$ 是满足 $\\mathrm{j}^2=-1$ 的虚数单位。\n\n计算由 4 点 DIT-FFT 算法第一阶段产生的中间序列 $G[n] = \\{G[0], G[1], G[2], G[3]\\}$ 的四个复数值。将答案表示为四个复数的序列。", "solution": "给定一个 4 点基-2 时域抽取 FFT。在此方法中，该算法首先通过对时间索引进行位倒序来重排输入 $x[n]$，然后对相邻对执行 2 点 DFT，以产生中间序列 $G[n]$。\n\n首先计算输入样本：\n对于 $x[n]=(1+\\mathrm{j})^{n}$，其中 $\\mathrm{j}^{2}=-1$：\n$$\nx[0]=(1+\\mathrm{j})^{0}=1,\\quad\nx[1]=(1+\\mathrm{j})^{1}=1+\\mathrm{j},\n$$\n$$\nx[2]=(1+\\mathrm{j})^{2}=1+2\\mathrm{j}+\\mathrm{j}^{2}=2\\mathrm{j},\\quad\nx[3]=(1+\\mathrm{j})^{3}=(1+\\mathrm{j})\\cdot(1+\\mathrm{j})^{2}=(1+\\mathrm{j})\\cdot 2\\mathrm{j}=2\\mathrm{j}+2\\mathrm{j}^{2}=-2+2\\mathrm{j}.\n$$\n\n接下来对索引 $n\\in\\{0,1,2,3\\}$ 应用位倒序。使用 2 位倒序：\n$$\n0\\,(00)\\to 0\\,(00),\\quad 1\\,(01)\\to 2\\,(10),\\quad 2\\,(10)\\to 1\\,(01),\\quad 3\\,(11)\\to 3\\,(11).\n$$\n因此，位倒序序列为\n$$\n[x[0],\\,x[2],\\,x[1],\\,x[3]]=[1,\\,2\\mathrm{j},\\,1+\\mathrm{j},\\,-2+2\\mathrm{j}].\n$$\n\n第一阶段对相邻对执行 2 点 DFT。对于一对 $(a,b)$，其 2 点 DFT 的结果为\n$$\nA[0]=a+b,\\qquad A[1]=a-b.\n$$\n将此应用于两个相邻对：\n\n第一对： $(a,b)=(1,\\,2\\mathrm{j})$\n$$\nG[0]=1+2\\mathrm{j},\\qquad G[1]=1-2\\mathrm{j}.\n$$\n\n第二对： $(a,b)=(1+\\mathrm{j},\\,-2+2\\mathrm{j})$\n$$\nG[2]=(1+\\mathrm{j})+(-2+2\\mathrm{j})=-1+3\\mathrm{j},\\qquad G[3]=(1+\\mathrm{j})-(-2+2\\mathrm{j})=3-\\mathrm{j}.\n$$\n\n因此，中间序列为\n$$\nG[n]=\\{\\,1+2\\mathrm{j},\\;1-2\\mathrm{j},\\;-1+3\\mathrm{j},\\;3-\\mathrm{j}\\,\\}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}1+2\\mathrm{j} & 1-2\\mathrm{j} & -1+3\\mathrm{j} & 3-\\mathrm{j}\\end{pmatrix}}$$", "id": "1711383"}, {"introduction": "在通过具体计算见证了位倒序的作用后，我们现在将专注于其高效实现——这是任何高性能FFT库中的一项关键任务。这项练习要求你为此置换设计一个“就地”算法，以最小化内存使用。更深层次地，通过分析该置换的循环结构，你将把置换的抽象数学理论与高效算法的具体设计联系起来，这是计算科学中的一项核心技能 [@problem_id:2863858]。", "problem": "给定按时间抽选的快速傅里叶变换 (DIT FFT) 的上下文。DIT FFT 在进行蝶形运算前，通过位反转置换对输入数据进行重排序。设 $N$ 是 2 的幂，即 $N=2^{b}$，其中 $b \\ge 0$ 是一个整数。在索引集合 $\\{0,1,\\dots,N-1\\}$ 上定义位反转置换 $\\pi$ 如下：将索引 $i$ 写成 $b$ 位的二进制形式，将其比特串反转得到另一个 $b$ 位整数，并将该整数记为 $\\pi(i)$。您的任务是设计并分析一个原地算法，用于将此置换应用于一个数组。\n\n从置换、二进制表示和轮换分解的定义出发，完成以下任务：\n\n- 设计一个原地算法，用最小的临时存储空间将置换 $\\pi$ 应用于一个长度为 $N$ 的数组。您的算法必须仅基于上述基本定义，不得依赖于预计算表或长度与 $N$ 成正比的辅助数组。清晰地说明算法关于 $N$ 和 $b$ 的渐近时间复杂度和额外空间复杂度。\n\n- 纯粹从第一性原理出发，分析 $\\pi$ 的轮换结构。确定可能出现的轮换长度，刻画不动点，并推导出不动点数量和非平凡轮换数量作为 $N$ 和 $b$ 的函数的闭式表达式。\n\n- 在一个程序中实现该算法和分析。对于每个测试用例，构建一个长度为 $N$ 的数组 $a$，其元素为 $a[i]=i$ ($i \\in \\{0,1,\\dots,N-1\\}$)，将您的原地置换算法应用于 $a$，并计算：\n  1. 您的原地算法执行的交换次数，以整数形式表示。\n  2. $\\pi$ 的轮换分解中的轮换总数，以整数形式表示。\n  3. $\\pi$ 的不动点数量，以整数形式表示。\n  4. $\\pi$ 的所有轮换中的最大轮换长度，以整数形式表示。\n  5. 一个布尔值，指示最终置换后的数组是否对所有 $j \\in \\{0,1,\\dots,N-1\\}$ 满足 $a[j]=\\pi(j)$。\n\n测试套件与覆盖范围：\n\n- 使用测试套件 $N \\in \\{1,2,8,16\\}$，它覆盖了边界情况 $N=1$、最小的非平凡情况 $N=2$ 以及两个典型的 2 的幂次 $N=8$ 和 $N=16$。\n\n输出规范：\n\n- 您的程序应生成单行输出，其中包含测试套件的结果，格式为一个由方括号括起来的逗号分隔列表。对于按顺序排列的每个 $N$（$N=1, N=2, N=8, N=16$），包含一个由上述五个值组成的列表。例如，输出必须采用以下形式：\n  \"[[value\\_1\\_1,value\\_1\\_2,value\\_1\\_3,value\\_1\\_4,value\\_1\\_5],[value\\_2\\_1,value\\_2\\_2,value\\_2\\_3,value\\_2\\_4,value\\_2\\_5],...]\"，其中每个值都是指定的整数或布尔值。", "solution": "所提供的问题定义明确、科学上合理且内部一致。它提出了一个源于快速傅里叶变换理论的标准算法挑战，尽管该挑战并非微不足道。我们将给出一个完整的解决方案，首先对置换进行结构分析，然后设计原地算法并进行复杂度分析，最后通过一个实现来计算所需的度量指标。\n\n设 $N$ 是 2 的幂，即 $N=2^b$，其中 $b \\ge 0$ 是一个整数。索引集合为 $S = \\{0, 1, \\dots, N-1\\}$。对于任何索引 $i \\in S$，其唯一的 $b$ 位二进制表示为 $(b_{b-1}b_{b-2}\\dots b_1b_0)_2$，其中 $i = \\sum_{k=0}^{b-1} b_k 2^k$。位反转置换 $\\pi: S \\to S$ 的定义为：$\\pi(i)$ 是一个整数，其 $b$ 位二进制表示是 $i$ 的二进制表示的反转。也就是说，如果 $i \\leftrightarrow (b_{b-1}\\dots b_0)_2$，那么 $\\pi(i) \\leftrightarrow (b_0\\dots b_{b-1})_2$。\n\n$\\pi$ 的一个关键性质是它是一个对合（involution），意味着它是自身的逆。将该置换应用两次会返回原始索引：对于所有 $i \\in S$，都有 $\\pi(\\pi(i)) = i$。要证明这一点，只需注意到将 $\\pi(i)$ 的比特串反转即可得到 $i$ 的原始比特串。从群论的角度来看，任何作为对合的置换都可以分解为不相交的长度为 1（不动点）或 2（对换）的轮换。不存在长度大于 2 的轮换。这一观察对于分析和算法设计都至关重要。\n\n我们首先分析 $\\pi$ 的轮换结构。\n\n$\\pi$ 的一个不动点是满足 $\\pi(i)=i$ 的索引 $i$。此等式成立当且仅当 $i$ 的 $b$ 位二进制表示是一个回文串，即 $(b_{b-1}b_{b-2}\\dots b_0)_2 = (b_0b_1\\dots b_{b-1})_2$。这要求对于所有 $k \\in \\{0, 1, \\dots, b-1\\}$，都有 $b_k = b_{b-1-k}$。要计算长度为 $b$ 的此类回文串的数量，我们只需指定前 $\\lceil b/2 \\rceil$ 个比特，因为它们决定了剩余的比特。由于这 $\\lceil b/2 \\rceil$ 个比特中的每一个都可以独立地选择为 0 或 1，因此不动点的数量（记为 $N_{fp}$）为 $2^{\\lceil b/2 \\rceil}$。\n\n被置换的元素总数为 $N$。非不动点的元素必然属于 2-轮换。这些元素的数量为 $N - N_{fp}$。由于每个 2-轮换包含两个元素，因此 2-轮换（对换）的数量为 $(N - N_{fp})/2$。\n\n置换中的轮换总数是 1-轮换和 2-轮换数量之和：\n$$ C_{total} = N_{fp} + \\frac{N - N_{fp}}{2} = \\frac{2N_{fp} + N - N_{fp}}{2} = \\frac{N + N_{fp}}{2} $$\n代入 $N_{fp}$ 的公式，轮换总数为 $\\frac{1}{2}(N + 2^{\\lceil b/2 \\rceil})$。\n\n可能的轮换长度为 1 和 2。如果至少存在一个 2-轮换，则最大轮换长度为 2，否则为 1。2-轮换的数量为正，当且仅当 $N - N_{fp} > 0$，即 $2^b > 2^{\\lceil b/2 \\rceil}$。该不等式可化简为 $b > \\lceil b/2 \\rceil$。\n- 如果 $b$ 是偶数，即 $b=2k$，则不等式为 $2k > k$，这对 $k \\ge 1$（即 $b \\ge 2$）成立。\n- 如果 $b$ 是奇数，即 $b=2k+1$，则不等式为 $2k+1 > k+1$，即 $k>0$，这对 $k \\ge 1$（即 $b \\ge 3$）成立。\n综合以上两点，对于所有 $b \\ge 2$，都存在 2-轮换。对于 $b=0$ ($N=1$) 和 $b=1$ ($N=2$)，我们有 $0 \\ngtr \\lceil 0/2 \\rceil=0$ 和 $1 \\ngtr \\lceil 1/2 \\rceil=1$。因此，对于 $N=1$ 和 $N=2$，所有元素都是不动点。对于 $N \\in \\{1, 2\\}$，最大轮换长度为 1；对于 $N \\ge 4$，最大轮换长度为 2。\n\n接下来，我们设计一个原地算法来应用此置换。设 $a$ 是一个长度为 $N$ 的数组。应用该置换意味着对数组进行变换，使得原先在位置 $k$ 的元素移动到位置 $\\pi(k)$。也就是说，新数组 $a_{new}$ 满足 $a_{new}[\\pi(k)] = a_{old}[k]$，对所有 $k \\in \\{0, \\dots, N-1\\}$ 成立。由于 $\\pi$ 是一个对合，我们可以写出 $k=\\pi(\\pi(k))$ 并代入得到 $a_{new}[\\pi(k)] = a_{old}[\\pi(\\pi(k))]$。令 $j=\\pi(k)$，则上式变为 $a_{new}[j] = a_{old}[\\pi(j)]$。因此，任务是为所有 $j$ 执行原地变换 $a[j] \\leftarrow a[\\pi(j)]$。\n\n由于该置换仅由不动点和对换组成，因此这个变换可以通过对每个对换中的元素进行简单交换来实现。我们可以从 0 到 $N-1$ 遍历索引 $i$。对于每个 $i$，我们计算其置换后的索引 $j=\\pi(i)$。\n- 如果 $i=j$，元素 $a[i]$ 是置换的一个不动点，它不应该被移动。\n- 如果 $i \\neq j$，那么 $(i, j)$ 构成一个 2-轮换，因为 $\\pi(j) = \\pi(\\pi(i)) = i$。为了确保这对元素只被交换一次，我们可以强制一个顺序。通过遍历 $i$ 并且仅在 $i < j$ 时进行交换，我们确保对于每一对满足 $i<j$ 的 $(i,j)$，交换 $a[i]$ 和 $a[j]$ 的操作在循环到索引 $i$ 时执行，而在循环到达索引 $j$ 时被跳过（因为那时 $j > \\pi(j)=i$）。\n\n算法如下：\n1. 对于 $i$ 从 $0$ 到 $N-1$：\n2.   计算 $j = \\pi(i)$。\n3.   如果 $i < j$，则交换 $a[i]$ 和 $a[j]$。\n\n该算法能正确地对数组进行原地置换。它在交换时仅使用一个临时变量，因此其额外空间复杂度为 $O(1)$。\n时间复杂度由循环决定，该循环运行 $N$ 次，且循环内部需要计算 $\\pi(i)$。一个直接的计算 $\\pi(i)$ 的方法是遍历 $i$ 的 $b$ 个比特，这需要 $O(b)$ 的时间。因此，总时间复杂度为 $O(N \\cdot b) = O(N \\log_2 N)$。\n\n问题所要求的输出可以如下计算：\n1. 交换次数等于 2-轮换的数量，即 $(N - N_{fp})/2$。这个值也可以由置换算法直接计数得到。\n2. 轮换总数为 $(N + N_{fp})/2$。\n3. 不动点数量为 $N_{fp} = 2^{\\lceil b/2 \\rceil}$。\n4. 如果 $b \\in \\{0, 1\\}$ (即 $N \\le 2$)，最大轮换长度为 1；如果 $b \\ge 2$ (即 $N \\ge 4$)，最大轮换长度为 2。\n5. 正确性通过检查最终数组 $a$ 是否对所有 $k \\in \\{0, \\dots, N-1\\}$ 满足 $a[k] = \\pi(k)$ 来验证，这里假设初始数组为 $a[k]=k$。该置换算法实现了变换 $a[k] \\leftarrow a[\\pi(k)]$。因此，在初始状态为 $a[k]=k$ 的情况下，最终状态应为 $a[k] = \\pi(k)$，这正是我们需要验证的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bit-reversal permutation problem for the given test suite.\n    \"\"\"\n\n    test_cases = [1, 2, 8, 16]\n\n    final_results = []\n\n    for N in test_cases:\n        # Determine b such that N = 2^b\n        b = N.bit_length() - 1 if N > 0 else 0\n\n        # --- Part 1: In-place permutation algorithm and swap count ---\n\n        def bit_reverse(i, num_bits):\n            \"\"\"Computes the bit-reversal of an integer i for a given bit width.\"\"\"\n            rev_i = 0\n            for k in range(num_bits):\n                if (i >> k) & 1:\n                    rev_i |= 1 << (num_bits - 1 - k)\n            return rev_i\n\n        # Initial array a[i] = i\n        a = list(range(N))\n        \n        num_swaps = 0\n        # Apply the in-place permutation algorithm\n        for i in range(N):\n            j = bit_reverse(i, b)\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n                num_swaps += 1\n\n        # --- Part 3, Output 5: Correctness verification ---\n        \n        is_correct = True\n        for i in range(N):\n            if a[i] != bit_reverse(i, b):\n                is_correct = False\n                break\n        \n        # --- Part 2 & 3: Analytical results ---\n\n        # Number of fixed points (1-cycles)\n        # N_fp = 2^ceil(b/2)\n        num_fixed_points = 2**((b + 1) // 2)\n\n        # Number of 2-cycles\n        num_2_cycles = (N - num_fixed_points) // 2\n        \n        # Total number of cycles = 1-cycles + 2-cycles\n        total_cycles = num_fixed_points + num_2_cycles\n\n        # Maximum cycle length\n        max_cycle_len = 2 if b >= 2 else 1\n\n        # The number of swaps performed must equal the number of 2-cycles.\n        # This serves as an internal consistency check.\n        assert num_swaps == num_2_cycles\n\n        case_results = [\n            num_swaps,\n            total_cycles,\n            num_fixed_points,\n            max_cycle_len,\n            is_correct\n        ]\n        final_results.append(case_results)\n\n    # Format the final output string to not contain spaces inside the lists.\n    # The default str(list) adds spaces, e.g., '[1, 2, 3]'.\n    # The required format has no spaces, e.g., '[1,2,3]'.\n    output_str = str(final_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2863858"}, {"introduction": "在标准的基-2算法之外，还存在着更为高效的变体以降低计算成本。最后一个练习将介绍强大的分裂基FFT算法，它通过更复杂的信号分解方式实现了显著的计算节省。你的任务是分析其递归结构，识别关键的“旋转因子”，并通过计算“非平凡”乘法的数量来精确量化其效率。这项练习将磨练你的算法分析能力，并揭示FFT算法不断优化背后的核心原则 [@problem_id:2863892]。", "problem": "设 $x[n]$ 是一个长度为 $N$ 的序列，其离散傅里叶变换 (DFT) 定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] W_{N}^{nk}$，其中 $W_{N} \\triangleq \\exp(-\\mathrm{j} 2\\pi/N)$ 且 $\\mathrm{j}$ 是虚数单位。时间抽取 (DIT) 分裂基快速傅里叶变换 (FFT) 通过将时间索引分裂为偶数索引和模4的两个奇数余数类来递归地分解 DFT，从而在每一级上得到一个 $N/2$ 点 DFT 和两个 $N/4$ 点 DFT，并通过形式为 $W_{N}^{k}$ 和 $W_{N}^{3k}$ 的旋转因子进行重组。\n\n对于 $N=16$ 的情况，构建分裂基 DIT 流程图，并在每个重组级明确指出乘以 $N/4$ 点子变换输出的旋转因子集合。以弧度为单位，列举出相应的旋转角。当且仅当一个乘数的旋转因子恰好为 $\\pm 1$ 或 $\\pm \\mathrm{j}$（等价于其角度与 $0$、$\\pi/2$、$\\pi$ 或 $3\\pi/2$ 模 $2\\pi$ 同余）时，将该乘数归类为“平凡”的。包含在 $N=16$ 流程图的偶数索引分支中出现的 $N=8$ 子FFT。角度必须以弧度为单位报告。\n\n最后，令 $M$ 表示整个 $N=16$ 分裂基 DIT FFT 流程中由旋转因子引起的非平凡复数乘法的总数（计算递归中所有重组阶段，并对每个旋转因子的乘法计数一次；不计加法或平凡乘数），精确地确定 $M$。你的最终答案必须是这个单个整数 $M$，不带单位。不需要四舍五入。", "solution": "本问题要求分析针对长度为 $N=16$ 序列的时间抽取 (DIT) 分裂基快速傅里叶变换 (FFT) 算法。我们必须确定递归中每个阶段的旋转因子，并确定非平凡复数乘法的总数，记为 $M$。\n\n长度为 $N$ 的离散傅里叶变换 (DFT) 定义为：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] W_{N}^{nk}, \\quad k = 0, 1, \\dots, N-1$$\n其中 $W_N \\triangleq \\exp(-\\mathrm{j} 2\\pi/N)$ 是旋转因子。\n\n分裂基算法通过将时间索引 $n$ 分为偶数索引 ($2n$)、形式为 $4n+1$ 的奇数索引和形式为 $4n+3$ 的奇数索引来分解 DFT 求和。这得到：\n$$X[k] = \\sum_{n=0}^{N/2-1} x[2n]W_N^{2nk} + \\sum_{n=0}^{N/4-1} x[4n+1]W_N^{(4n+1)k} + \\sum_{n=0}^{N/4-1} x[4n+3]W_N^{(4n+3)k}$$\n利用属性 $W_N^{ab} = W_{N/a}^b$，这可以表示为更小的 DFT：\n$$X[k] = \\sum_{n=0}^{N/2-1} x[2n]W_{N/2}^{nk} + W_N^k \\sum_{n=0}^{N/4-1} x[4n+1]W_{N/4}^{nk} + W_N^{3k} \\sum_{n=0}^{N/4-1} x[4n+3]W_{N/4}^{nk}$$\n这表明一个长度为 $N$ 的 DFT 可以由一个长度为 $N/2$ 的 DFT 和两个长度为 $N/4$ 的 DFT 计算得出。这些较小 DFT 的重组需要与旋转因子 $W_N^k$ 和 $W_N^{3k}$ 进行复数乘法。\n\n如果旋转因子为 $\\pm 1$ 或 $\\pm \\mathrm{j}$，则乘法定义为“平凡”的。这对应于旋转角是 $\\pi/2$ 的整数倍。旋转因子 $W_N^p$ 的角度是 $-2\\pi p/N$。为了使该角度成为 $\\pi/2$ 的整数倍，即对于某个整数 $q$ 有 $-2\\pi p/N = q(\\pi/2)$，我们必须有 $4p = -qN$，这意味着 $p$ 必须是 $N/4$ 的整数倍。\n\n我们现在将分析 $N=16$ 分裂基 FFT 的递归结构，以计算非平凡乘法的数量。\n\n**1. $N=16$ 的重组阶段**\n$16$ 点 DFT 的计算基于一个 $8$ 点 DFT 和两个 $4$ 点 DFT。重组过程涉及乘以两个 $4$ 点 DFT 输出的旋转因子。这些因子的索引 $k$ 从 $0$ 到 $N/4-1 = 16/4-1 = 3$。$k=0$ 时的因子是 $W_{16}^0=1$，这是一个平凡乘法，不予计算。我们考虑 $k \\in \\{1, 2, 3\\}$。\n旋转因子集合为 $\\{W_{16}^k | k=1,2,3\\}$ 和 $\\{W_{16}^{3k} | k=1,2,3\\}$。\n\n-   集合 1：$\\{W_{16}^1, W_{16}^2, W_{16}^3\\}$。\n    -   $W_{16}^1$ 的角度：$-2\\pi(1)/16 = -\\pi/8$ 弧度。\n    -   $W_{16}^2$ 的角度：$-2\\pi(2)/16 = -\\pi/4$ 弧度。\n    -   $W_{16}^3$ 的角度：$-2\\pi(3)/16 = -3\\pi/8$ 弧度。\n-   集合 2：$\\{W_{16}^3, W_{16}^6, W_{16}^9\\}$。\n    -   $W_{16}^3$ 的角度：$-2\\pi(3)/16 = -3\\pi/8$ 弧度。\n    -   $W_{16}^6$ 的角度：$-2\\pi(6)/16 = -3\\pi/4$ 弧度。\n    -   $W_{16}^9$ 的角度：$-2\\pi(9)/16 = -9\\pi/8$ 弧度。\n\n这些角度（$-\\pi/8, -\\pi/4, -3\\pi/8, -3\\pi/4, -9\\pi/8$）都不是 $\\pi/2$ 的整数倍。因此，在此阶段的所有 $2 \\times (16/4 - 1) = 2 \\times 3 = 6$ 次复数乘法都是非平凡的。\n\n**2. $N=8$ 子 FFT 的重组阶段**\n$N=16$ 的计算需要一个 $N=8$ 的子 FFT。这个 $8$ 点 DFT 又是通过一个 $4$ 点 DFT 和两个 $2$ 点 DFT 计算得出的。重组乘数为 $W_8^k$ 和 $W_8^{3k}$，其中 $k=0, \\dots, 8/4-1=1$。我们只需要考虑 $k=1$。\n旋转因子集合为 $\\{W_8^1\\}$ 和 $\\{W_8^3\\}$。\n\n-   集合 1：$\\{W_8^1\\}$。\n    -   $W_8^1$ 的角度：$-2\\pi(1)/8 = -\\pi/4$ 弧度。\n-   集合 2：$\\{W_8^3\\}$。\n    -   $W_8^3$ 的角度：$-2\\pi(3)/8 = -3\\pi/4$ 弧度。\n\n$-\\pi/4$ 和 $-3\\pi/4$ 都不是 $\\pi/2$ 的整数倍。因此，这两次乘法都是非平凡的。此阶段的非平凡乘法总数为 $2 \\times (8/4 - 1) = 2 \\times 1 = 2$。\n\n**3. $N=4$ 子 FFT 的重组阶段**\n完整的递归过程涉及多个 $N=4$ 的子 FFT。一个 $N=4$ 的分裂基 FFT 被分解为一个 $2$ 点 DFT 和两个 $1$ 点 DFT。重组乘数将是 $W_4^k$ 和 $W_4^{3k}$，其中 $k=0, \\dots, 4/4-1=0$。由于 $k$ 的范围是空的（因为 $k=0$ 是平凡的），任何 $N=4$ 的子 FFT 的重组阶段都没有乘法。\n\n**4. 非平凡乘法总数 ($M$)**\n非平凡复数乘法的总数 $M$ 是整个递归流程中所有重组阶段此类乘法的总和。设 $M(N)$ 为长度为 $N$ 的 FFT 的非平凡乘法数。\n递归结构如下：\n$$M(N) = M_{recomb}(N) + M(N/2) + 2 \\times M(N/4)$$\n其中 $M_{recomb}(N)$ 是大小为 $N$ 的重组阶段的非平凡乘法数。\n\n-   基本情况：一个 $2$ 点 DFT 只涉及加法和减法，所以 $M(2)=0$。一个 $1$ 点 DFT 是一个恒等操作，所以 $M(1)=0$。\n-   对于 $N=4$：$M_{recomb}(4) = 2 \\times (4/4-1) = 0$。因此，$M(4) = M_{recomb}(4) + M(2) + 2M(1) = 0 + 0 + 2(0) = 0$。\n-   对于 $N=8$：$M_{recomb}(8) = 2$。因此，$M(8) = M_{recomb}(8) + M(4) + 2M(2) = 2 + 0 + 2(0) = 2$。\n-   对于 $N=16$：$M_{recomb}(16) = 6$。因此，$M(16) = M_{recomb}(16) + M(8) + 2M(4) = 6 + 2 + 2(0) = 8$。\n\n整个 $N=16$ 流程的非平凡乘法总数 $M$ 正是 $M(16)$。\n计算过程展开如下：\n- $N=16$ FFT 的顶层分解贡献了 $6$ 次非平凡乘法。\n- 这产生了一个大小为 $N=8$ 的子问题和两个大小为 $N=4$ 的子问题。\n- 这两个 $N=4$ 的子问题各贡献 $M(4)=0$ 次乘法。\n- 那一个 $N=8$ 的子问题贡献了 $M(8)=2$ 次乘法。该子问题本身会分解为更小的 FFT（$N=4$ 和 $N=2$），但它们的贡献已经包含在 $M(8)$ 的值中。\n\n对所有阶段的贡献求和：\n$$M = M_{recomb}(16) + M(8) + 2M(4) = 6 + 2 + 2(0) = 8.$$\n因此，在整个 $N=16$ 分裂基 DIT FFT 流程中，由旋转因子引起的非平凡复数乘法总数为 $8$。", "answer": "$$\\boxed{8}$$", "id": "2863892"}]}