{"hands_on_practices": [{"introduction": "在应用离散时间卡尔曼滤波器之前，我们首先需要一个准确的离散时间模型。本练习将指导您完成一个关键步骤：将一个连续时间的运动学模型转化为其离散时间等效形式。您将利用 Van Loan 方法推导精确的离散时间过程噪声协方差 $Q_d$，这是正确建模动态系统的基础技能。[@problem_id:2912361]", "problem": "一个一维运动学目标通过位置、速度和加速度状态进行建模，构成连续时间线性时不变状态向量 $x(t) = \\begin{pmatrix} p(t) \\\\ v(t) \\\\ a(t) \\end{pmatrix}$。其动力学遵循线性随机微分方程\n$$\n\\dot{x}(t) = F x(t) + L w(t),\n$$\n其中 $F \\in \\mathbb{R}^{3 \\times 3}$ 和 $L \\in \\mathbb{R}^{3 \\times 1}$ 是常数矩阵，而 $w(t)$ 是零均值高斯白噪声过程，其谱密度为 $q \\in \\mathbb{R}_{>0}$，即 $\\mathbb{E}[w(t) w(\\tau)] = q \\,\\delta(t-\\tau)$。该模型是常加速度带随机游走加速度模型，由以下公式指定\n$$\nF = \\begin{pmatrix}\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & 0\n\\end{pmatrix},\n\\qquad\nL = \\begin{pmatrix}\n0 \\\\ 0 \\\\ 1\n\\end{pmatrix}.\n$$\n设采样间隔为 $T \\in \\mathbb{R}_{>0}$。请仅使用关于线性时不变系统和随机过程的基本原理，并应用 Van Loan 方法对连续时间过程噪声进行精确离散时间转换，推导与采样间隔 $T$ 相关联的精确离散时间状态转移矩阵 $A_{d}$ 和精确离散时间过程噪声协方差 $Q_{d}$。您的推导必须从线性时不变系统的状态转移定义和高斯白噪声的特性出发，并且必须在不假设任何现成离散时间公式的情况下，逻辑上证明 Van Loan 方法所内含的积分形式的合理性。\n\n在推导出 $A_{d}$ 和 $Q_{d}$ 的显式闭式表达式后，计算标量 $s$。$s$ 定义为 $Q_{d}$ 的 $(1,1)$ 项，并应简化为以 $q$ 和 $T$ 表示的闭式解析表达式。最终答案仅报告 $s$。无需进行数值代入。最终答案中不要包含单位。如果您选择进行近似，则必须陈述并证明近似的合理性；否则，请提供精确表达式。", "solution": "所给问题是连续时间线性随机系统离散化的一个标准练习。该问题是适定的、科学上合理的，并包含了获得唯一解所需的所有信息。我们将着手进行推导。\n\n该系统由以下线性随机微分方程描述：\n$$\n\\dot{x}(t) = F x(t) + L w(t)\n$$\n其中 $x(t) \\in \\mathbb{R}^3$，$w(t)$ 是一个连续时间高斯白噪声过程，满足 $\\mathbb{E}[w(t)]=0$ 和协方差 $\\mathbb{E}[w(t) w(\\tau)] = q \\delta(t-\\tau)$，其中 $q > 0$。矩阵如下所示：\n$$\nF = \\begin{pmatrix}\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & 0\n\\end{pmatrix}, \\quad L = \\begin{pmatrix}\n0 \\\\ 0 \\\\ 1\n\\end{pmatrix}\n$$\n这个线性时不变（LTI）系统在区间 $[t_k, t_{k+1}]$ 上的解由常数变易法公式给出：\n$$\nx(t_{k+1}) = e^{F(t_{k+1}-t_k)} x(t_k) + \\int_{t_k}^{t_{k+1}} e^{F(t_{k+1}-\\tau)} L w(\\tau) d\\tau\n$$\n我们考虑一个均匀采样间隔 $T = t_{k+1}-t_k$。令 $x_k \\triangleq x(t_k) = x(kT)$。方程变为：\n$$\nx_{k+1} = e^{FT} x_k + \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau)} L w(\\tau) d\\tau\n$$\n这就是离散时间状态空间模型 $x_{k+1} = A_d x_k + w_d_k$，其中状态转移矩阵 $A_d$ 和离散时间过程噪声向量 $w_d_k$ 可确定为：\n$$\nA_d = e^{FT}\n$$\n$$\nw_d_k = \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau)} L w(\\tau) d\\tau\n$$\n离散时间过程噪声协方差 $Q_d$ 定义为 $w_d_k$ 的协方差。由于 $w(t)$ 是零均值的，所以 $w_d_k$ 也是零均值的。因此，$Q_d = \\mathbb{E}[w_d_k w_d_k^T]$。\n$$\nQ_d = \\mathbb{E} \\left[ \\left( \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau_1)} L w(\\tau_1) d\\tau_1 \\right) \\left( \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau_2)} L w(\\tau_2) d\\tau_2 \\right)^T \\right]\n$$\n通过将期望移到积分内部，并利用转置算子的线性性质，我们得到：\n$$\nQ_d = \\int_{kT}^{(k+1)T} \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau_1)} L \\mathbb{E}[w(\\tau_1)w(\\tau_2)] L^T \\left(e^{F((k+1)T-\\tau_2)}\\right)^T d\\tau_1 d\\tau_2\n$$\n代入 $\\mathbb{E}[w(\\tau_1)w(\\tau_2)] = q \\delta(\\tau_1 - \\tau_2)$：\n$$\nQ_d = \\int_{kT}^{(k+1)T} \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau_1)} L (q \\delta(\\tau_1 - \\tau_2)) L^T e^{F^T((k+1)T-\\tau_2)} d\\tau_1 d\\tau_2\n$$\n利用狄拉克 $\\delta$ 函数的筛选特性来计算关于 $\\tau_1$ 的积分：\n$$\nQ_d = q \\int_{kT}^{(k+1)T} e^{F((k+1)T-\\tau_2)} L L^T e^{F^T((k+1)T-\\tau_2)} d\\tau_2\n$$\n我们进行变量替换，令 $s = (k+1)T - \\tau_2$。则 $ds = -d\\tau_2$。当 $\\tau_2=kT$ 时，积分限变为 $s=T$；当 $\\tau_2=(k+1)T$ 时，积分限变为 $s=0$。\n$$\nQ_d = q \\int_{T}^{0} e^{Fs} L L^T e^{F^T s} (-ds) = q \\int_{0}^{T} e^{Fs} L L^T e^{F^T s} ds\n$$\n这就是离散时间过程噪声协方差的基本积分形式。Van Loan 方法通过计算一个增广矩阵的指数，提供了一种同时计算 $A_d$ 和 $Q_d$ 的数值技术。我们将从第一性原理出发证明该方法的合理性。\n\n考虑增广矩阵 $\\mathcal{N} = \\begin{pmatrix} -F & qLL^T \\\\ 0 & F^T \\end{pmatrix}$。我们研究矩阵指数 $\\Phi(T) = \\exp(\\mathcal{N}T)$。令 $\\Phi(t) = \\exp(\\mathcal{N}t) = \\begin{pmatrix} \\Phi_{11}(t) & \\Phi_{12}(t) \\\\ \\Phi_{21}(t) & \\Phi_{22}(t) \\end{pmatrix}$。此矩阵是系统 $\\dot{Z}(t) = \\mathcal{N}Z(t)$ 的状态转移矩阵。根据 $\\mathcal{N}$ 的分块结构，我们可以写出 $\\Phi(t)$ 各分块在初始条件 $\\Phi(0)=I$ 下的微分方程：\n$\\dot{\\Phi}_{11} = -F\\Phi_{11}$，初始条件为 $\\Phi_{11}(0)=I \\implies \\Phi_{11}(t) = e^{-Ft}$。\n$\\dot{\\Phi}_{22} = F^T\\Phi_{22}$，初始条件为 $\\Phi_{22}(0)=I \\implies \\Phi_{22}(t) = e^{F^T t}$。\n$\\dot{\\Phi}_{12} = -F\\Phi_{12} + qLL^T\\Phi_{22}$，初始条件为 $\\Phi_{12}(0)=0$。\n代入 $\\Phi_{22}(t)$，我们得到 $\\dot{\\Phi}_{12}(t) = -F\\Phi_{12}(t) + qLL^T e^{F^T t}$。其解为：\n$$\n\\Phi_{12}(t) = \\int_0^t e^{-F(t-s)} qLL^T e^{F^T s} ds = e^{-Ft} \\int_0^t e^{Fs} qLL^T e^{F^T s} ds\n$$\n在时间 $t=T$ 时，我们有 $\\Phi_{12}(T) = e^{-FT} \\left( q \\int_0^T e^{Fs} L L^T e^{F^T s} ds \\right) = e^{-FT} Q_d$。\n因此，$Q_d = (e^{-FT})^{-1} \\Phi_{12}(T) = e^{FT} \\Phi_{12}(T) = A_d \\Phi_{12}(T)$。此外，$A_d = e^{FT} = (\\Phi_{22}(T)^T)^{-1}$。但 $e^{F^T T} = (e^{FT})^T=A_d^T$，所以 $\\Phi_{22}(T) = A_d^T$ 且 $\\Phi_{11}(T) = A_d^{-1}$。\n因此，Van Loan 方法将 $Q_d$ 的积分编码在 $\\exp(\\mathcal{N}T)$ 的分块 $\\Phi_{12}$ 中。\n\n对于这个问题，矩阵 $F$ 是幂零的。这个性质极大地简化了计算。\n$F^2 = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}$，且 $F^3 = 0$。\n$A_d$ 的矩阵指数可以通过其泰勒级数计算，该级数是有限的：\n$$\nA_d = e^{FT} = I + FT + \\frac{(FT)^2}{2!} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} + T\\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0 \\end{pmatrix} + \\frac{T^2}{2}\\begin{pmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 1 & T & \\frac{T^2}{2} \\\\ 0 & 1 & T \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n幂零性也简化了 $Q_d$ 的被积函数。项 $e^{Fs}$ 变成一个关于 $s$ 的简单多项式：\n$$\ne^{Fs} = I + Fs + \\frac{F^2s^2}{2} = \\begin{pmatrix} 1 & s & \\frac{s^2}{2} \\\\ 0 & 1 & s \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n我们现在直接计算 $Q_d$ 的积分，这是对已证明公式的最有效应用。\n$$\nQ_d = q \\int_0^T (e^{Fs}L)(e^{Fs}L)^T ds\n$$\n首先，我们计算向量 $e^{Fs}L$：\n$$\ne^{Fs}L = \\begin{pmatrix} 1 & s & \\frac{s^2}{2} \\\\ 0 & 1 & s \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{s^2}{2} \\\\ s \\\\ 1 \\end{pmatrix}\n$$\n被积函数是外积 $(e^{Fs}L)(e^{Fs}L)^T$：\n$$\nq \\begin{pmatrix} \\frac{s^2}{2} \\\\ s \\\\ 1 \\end{pmatrix} \\begin{pmatrix} \\frac{s^2}{2} & s & 1 \\end{pmatrix} = q \\begin{pmatrix} \\frac{s^4}{4} & \\frac{s^3}{2} & \\frac{s^2}{2} \\\\ \\frac{s^3}{2} & s^2 & s \\\\ \\frac{s^2}{2} & s & 1 \\end{pmatrix}\n$$\n将该矩阵从 $0$ 到 $T$ 逐元素积分：\n$$\nQ_d = q \\int_0^T \\begin{pmatrix} \\frac{s^4}{4} & \\frac{s^3}{2} & \\frac{s^2}{2} \\\\ \\frac{s^3}{2} & s^2 & s \\\\ \\frac{s^2}{2} & s & 1 \\end{pmatrix} ds = q \\begin{pmatrix} \\frac{T^5}{20} & \\frac{T^4}{8} & \\frac{T^3}{6} \\\\ \\frac{T^4}{8} & \\frac{T^3}{3} & \\frac{T^2}{2} \\\\ \\frac{T^3}{6} & \\frac{T^2}{2} & T \\end{pmatrix}\n$$\n问题要求计算标量 $s$，其定义为 $Q_d$ 的 $(1,1)$ 项。\n$$\ns = (Q_d)_{11} = q \\frac{T^5}{20}\n$$\n这就是所求量的精确闭式表达式。", "answer": "$$\\boxed{q \\frac{T^{5}}{20}}$$", "id": "2912361"}, {"introduction": "一个正确构建的滤波器模型是成功的必要条件，但并非充分条件；系统还必须是“可检测的 (detectable)”，以保证滤波器估计误差的稳定性。这个动手编程练习将让您通过模拟不同属性的系统，亲眼观察一个不可观测的不稳定模式如何导致估计误差发散，这对于设计鲁棒的滤波器至关重要。[@problem_id:2912311]", "problem": "考虑一个离散时间线性高斯状态空间模型，其状态向量为 $x_k \\in \\mathbb{R}^n$，测量值为 $y_k \\in \\mathbb{R}^m$，由以下方程给出：\n$$\nx_{k+1} = A x_k + w_k,\\quad y_k = H x_k + v_k,\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$，$H \\in \\mathbb{R}^{m \\times n}$，$w_k \\sim \\mathcal{N}(0,Q)$ 且 $Q \\succeq 0$，$v_k \\sim \\mathcal{N}(0,R)$ 且 $R \\succ 0$。离散时间 Kalman 滤波器基于此模型，使用递归的预测-更新方法从测量值中估计状态。如果 $A$ 的每个满足 $|\\lambda| \\ge 1$ 的特征值 $\\lambda$ 都对应一个可观测模态，则称矩阵对 $(A,H)$ 是可检测的。\n\n您的任务是实现一个程序，构造一个 $(A,H)$ 不可检测的清晰示例，并定量地展示对于某些初始条件，Kalman 滤波器的估计误差会发散。您还必须包含可检测的对比案例和一个边界案例，以构成一个测试套件，用于探测可检测性和协方差设计的不同方面。您必须从线性高斯模型和条件期望的基本定义出发，并实现基于这些原理推导出的标准离散时间 Kalman 滤波器预测-更新算法。除了最终答案规范中明确允许的包之外，不要假定任何外部包。\n\n您将模拟一个没有过程噪声和测量噪声的真实系统，即 $w_k \\equiv 0$ 且 $v_k \\equiv 0$，这样任何发散都源于结构特性，而非随机扰动。然而，您仍必须为滤波器设计选择半正定 $Q$ 和正定 $R$，以使设计是适定的且在数值上有意义；预测步骤使用 $Q$，更新步骤使用 $R$。对于不可检测的示例，选择 $Q$ 和 $R$，使得由不可观测的不稳定模态引起的发散仅从初始条件就显而易见。\n\n该程序必须实现 Kalman 滤波器递归，并为每个测试案例计算在 $N$ 个时间步后以下两个定量指标：\n1. 最终时刻与初始时刻估计误差范数之比，\n$$\n\\rho_e = \\frac{\\|e_N\\|_2}{\\|e_0\\|_2}, \\quad e_k = x_k - \\hat{x}_{k|k}.\n$$\n2. 最终时刻与初始时刻误差协方差的迹之比（分母中加入一个小的正常数以避免在适用情况下除以零），\n$$\n\\rho_P = \\frac{\\mathrm{tr}(P_N)}{\\mathrm{tr}(P_0) + \\varepsilon},\n$$\n其中 $\\varepsilon$ 是一个小的正常数，您必须在代码中固定其值。\n\n测试套件包含四个案例，其中 $n=2$，$m=1$，时间范围 $N=50$，以及以下系统参数、初始条件和滤波器协方差：\n- 案例1（不可检测，误差发散）：$A = \\mathrm{diag}(1.2, 0.9)$，$H = \\begin{bmatrix}0 & 1\\end{bmatrix}$，$Q = \\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}$，$R = \\begin{bmatrix}10^{-4}\\end{bmatrix}$，$x_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$，$\\hat{x}_{0|0} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$P_0 = \\mathrm{diag}(1,1)$。\n- 案例2（可检测，误差收敛；不稳定模态被观测）：$A = \\mathrm{diag}(1.2, 0.9)$，$H = \\begin{bmatrix}1 & 0\\end{bmatrix}$，$Q = \\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}$，$R = \\begin{bmatrix}10^{-4}\\end{bmatrix}$，$x_0 = \\begin{bmatrix}1 \\\\ 0.5\\end{bmatrix}$，$\\hat{x}_{0|0} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$P_0 = \\mathrm{diag}(1,1)$。\n- 案例3（可检测，不可观测模态稳定）：$A = \\mathrm{diag}(0.8, 1.1)$，$H = \\begin{bmatrix}0 & 1\\end{bmatrix}$，$Q = \\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}$，$R = \\begin{bmatrix}10^{-4}\\end{bmatrix}$，$x_0 = \\begin{bmatrix}1 \\\\ 0.2\\end{bmatrix}$，$\\hat{x}_{0|0} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$P_0 = \\mathrm{diag}(1,1)$。\n- 案例4（边界情况，临界不稳定的不可观测模态）：$A = \\mathrm{diag}(1.0, 0.9)$，$H = \\begin{bmatrix}0 & 1\\end{bmatrix}$，$Q = \\begin{bmatrix}0 & 0 \\\\ 0 & 0\\end{bmatrix}$，$R = \\begin{bmatrix}10^{-4}\\end{bmatrix}$，$x_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$，$\\hat{x}_{0|0} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$，$P_0 = \\mathrm{diag}(1,1)$。\n\n所有角度（如果出现）必须以弧度表示。此问题中没有物理单位。最终程序必须为每个案例计算 $(\\rho_e, \\rho_P)$，并将这8个实值结果聚合到单行打印输出中，形式为一个包含8个浮点数的扁平列表，顺序如下：\n$$\n[\\rho_e^{(1)}, \\rho_P^{(1)}, \\rho_e^{(2)}, \\rho_P^{(2)}, \\rho_e^{(3)}, \\rho_P^{(3)}, \\rho_e^{(4)}, \\rho_P^{(4)}].\n$$\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[r1,r2,r3,r4,r5,r6,r7,r8]”）。", "solution": "该问题要求对离散时间 Kalman 滤波器的稳定性进行分析和实现，其稳定性取决于系统的可检测性。我们首先验证问题陈述，然后着手进行有理有据的求解。该问题在科学上根植于控制与估计理论，问题陈述清晰，所有必要参数均已定义，且是客观的。所提供的测试案例构造正确，可以展示可检测性和滤波器发散的理论概念。因此，该问题被认为是有效的。\n\n我们考虑离散时间线性高斯状态空间模型：\n$$\nx_{k+1} = A x_k + w_k\n$$\n$$\ny_k = H x_k + v_k\n$$\n其中 $k \\in \\mathbb{N}$ 是时间索引，$x_k \\in \\mathbb{R}^n$ 是状态向量，$y_k \\in \\mathbb{R}^m$ 是测量向量。系统矩阵为 $A \\in \\mathbb{R}^{n \\times n}$ 和 $H \\in \\mathbb{R}^{m \\times n}$。过程噪声 $w_k$ 和测量噪声 $v_k$ 被假定为独立的、零均值的白色高斯过程，其协方差分别为 $w_k \\sim \\mathcal{N}(0, Q)$ 和 $v_k \\sim \\mathcal{N}(0, R)$，其中 $Q \\succeq 0$ 且 $R \\succ 0$。\n\n滤波的目标是根据测量的历史记录 $Y_k = \\{y_1, y_2, \\dots, y_k\\}$ 找到状态 $x_k$ 的最佳估计。对于线性高斯系统，在最小均方误差意义下的最优估计是条件期望 $\\hat{x}_{k|k} = E[x_k | Y_k]$。该估计的不确定性由误差协方差矩阵 $P_{k|k} = E[(x_k - \\hat{x}_{k|k})(x_k - \\hat{x}_{k|k})^T | Y_k]$ 来表征。\n\nKalman 滤波器提供了一种递归算法来计算 $\\hat{x}_{k|k}$ 和 $P_{k|k}$。它包括两个步骤：预测和更新。从初始估计 $\\hat{x}_{0|0}$ 和协方差 $P_{0|0}$ 开始，滤波器对 $k=1, 2, \\dots, N$ 迭代计算：\n\n1.  **预测（时间更新）：** 此步骤将状态和协方差估计从时间 $k-1$ 投影到时间 $k$。\n    $$\n    \\hat{x}_{k|k-1} = A \\hat{x}_{k-1|k-1}\n    $$\n    $$\n    P_{k|k-1} = A P_{k-1|k-1} A^T + Q\n    $$\n    这里，$\\hat{x}_{k|k-1}$ 是在给定截至时间 $k-1$ 的测量值时，对时间 $k$ 的预测状态估计，而 $P_{k|k-1}$ 是预测的误差协方差。\n\n2.  **更新（测量更新）：** 此步骤结合新的测量值 $y_k$ 来修正预测的估计。\n    $$\n    \\tilde{y}_k = y_k - H \\hat{x}_{k|k-1} \\quad (\\text{新息})\n    $$\n    $$\n    S_k = H P_{k|k-1} H^T + R \\quad (\\text{新息协方差})\n    $$\n    $$\n    K_k = P_{k|k-1} H^T S_k^{-1} \\quad (\\text{Kalman 增益})\n    $$\n    $$\n    \\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_k \\tilde{y}_k \\quad (\\text{更新后的状态估计})\n    $$\n    $$\n    P_{k|k} = (I - K_k H) P_{k|k-1} \\quad (\\text{更新后的误差协方差})\n    $$\n\nKalman 滤波器的一个基本性质是：对于任意初始条件 $P_{0|0} \\succeq 0$，估计误差协方差 $P_{k|k}$ 有界的充分必要条件是矩阵对 $(A, H)$ 是可检测的。一个系统是可检测的，如果每个不稳定模态（与 $A$ 的一个特征值 $\\lambda$ 相关，其中 $|\\lambda| \\ge 1$）都是可观测的。与特征值 $\\lambda$ 对应的特征向量 $v$ 如果满足 $Hv \\neq 0$，则代表一个可观测模态。如果一个不稳定模态是不可观测的 ($Hv=0$)，滤波器就无法通过测量“看到”这个模态。如果初始状态在该不可观测、不稳定的方向上存在误差分量，滤波器将无法纠正它，误差将根据 $A$ 的不稳定动态增长。与此方向相关的协方差也将发散。\n\n现在，我们将在此理论框架下分析问题陈述中指定的四个测试案例。仿真将使用一个确定性的真实系统，其中 $w_k \\equiv 0$ 且 $v_k \\equiv 0$，因此真实状态演化为 $x_{k+1} = A x_k$，测量值为 $y_k = H x_k$。这将滤波器的结构特性与随机效应分离开来。滤波器本身使用 $Q=0$ 和一个小的 $R > 0$ 进行设计。\n\n让我们检查每个案例的系统属性（$n=2, m=1, N=50$）：\n\n**案例1：不可检测，误差发散**\n-   $A = \\mathrm{diag}(1.2, 0.9)$，$H = \\begin{bmatrix}0 & 1\\end{bmatrix}$。特征值为 $\\lambda_1 = 1.2$（不稳定）和 $\\lambda_2 = 0.9$（稳定）。对应的特征向量为 $v_1 = [1, 0]^T$ 和 $v_2 = [0, 1]^T$。\n-   不稳定模态的可观测性：$H v_1 = \\begin{bmatrix}0 & 1\\end{bmatrix} [1, 0]^T = 0$。该不稳定模态是不可观测的。系统是不可检测的。\n-   初始状态为 $x_0 = [1, 0]^T$，完全处于不可观测、不稳定的方向上。初始估计为 $\\hat{x}_{0|0} = [0, 0]^T$。初始误差 $e_0 = x_0$ 沿此模态方向。滤波器接收到的测量值 $y_k = H A^k x_0 = 0$ 对所有 $k$ 均成立，没有提供关于第一个状态分量的任何信息。估计误差 $e_k$ 预计将以 $1.2^k$ 的速率增长。误差范数比 $\\rho_e$ 和协方差的迹之比 $\\rho_P$ 应显著大于1。\n\n**案例2：可检测，误差收敛**\n-   $A = \\mathrm{diag}(1.2, 0.9)$，$H = \\begin{bmatrix}1 & 0\\end{bmatrix}$。特征值和特征向量与案例1相同。\n-   不稳定模态的可观测性：$H v_1 = \\begin{bmatrix}1 & 0\\end{bmatrix} [1, 0]^T = 1 \\neq 0$。该不稳定模态是可观测的。系统是可检测的。\n-   尽管稳定模态是不可观测的（$H v_2 = 0$），但这不违反可检测性。滤波器可以纠正不稳定方向上的任何误差。稳定、不可观测方向上的任何误差会自然衰减。估计误差和协方差预计将收敛。我们预期 $\\rho_e < 1$ 且 $\\rho_P < 1$。\n\n**案例3：可检测，稳定的不可观测模态**\n-   $A = \\mathrm{diag}(0.8, 1.1)$，$H = \\begin{bmatrix}0 & 1\\end{bmatrix}$。特征值为 $\\lambda_1 = 0.8$（稳定）和 $\\lambda_2 = 1.1$（不稳定）。\n-   不稳定模态对应于特征向量 $v_2 = [0, 1]^T$。其可观测性通过 $H v_2 = \\begin{bmatrix}0 & 1\\end{bmatrix} [0, 1]^T = 1 \\neq 0$ 来检验。该不稳定模态是可观测的。系统是可检测的。\n-   与案例2类似，滤波器是稳定的。不可观测的模态对应于稳定的特征值 $\\lambda_1 = 0.8$。此方向上的任何初始误差都将衰减。我们预期 $\\rho_e < 1$ 且 $\\rho_P < 1$。\n\n**案例4：边界案例，临界不稳定的不可观测模态**\n-   $A = \\mathrm{diag}(1.0, 0.9)$，$H = \\begin{bmatrix}0 & 1\\end{bmatrix}$。特征值为 $\\lambda_1 = 1.0$（临界不稳定）和 $\\lambda_2 = 0.9$（稳定）。\n-   临界不稳定模态的可观测性：$H v_1 = \\begin{bmatrix}0 & 1\\end{bmatrix} [1, 0]^T = 0$。此模态是不可观测的，因此系统是不可检测的。\n-   初始误差为 $e_0 = [1, 0]^T$。真实状态 $x_k = A^k x_0 = x_0$ 是恒定的。测量值为 $y_k = H x_k = 0$。估计值 $\\hat{x}_{k|k}$ 保持为零。因此，误差 $e_k = x_0$ 是恒定的。误差范数不会改变，因此我们预期 $\\rho_e = 1$。由于 $\\lambda_1=1.0$ 且 $Q_{11}=0$，对应于不可观测模态的协方差矩阵分量不会增长。然而，可观测模态的协方差将减小。协方差矩阵的总迹将减小，因此我们预测 $\\rho_P < 1$。\n\n仿真将为每个案例初始化系统和滤波器，运行 $N=50$ 步的递归，然后计算指定的指标：\n-   估计误差范数比：$\\rho_e = \\|e_N\\|_2 / \\|e_0\\|_2$，其中 $e_k = x_k - \\hat{x}_{k|k}$。\n-   误差协方差的迹之比：$\\rho_P = \\mathrm{tr}(P_N) / (\\mathrm{tr}(P_0) + \\varepsilon)$，带有正则化项 $\\varepsilon = 10^{-12}$。\n\n实现将计算所有四个案例的这些值，并按要求报告结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not strictly necessary, numpy.linalg is sufficient.\n\ndef run_kalman_simulation(A, H, Q, R, x0, x0_hat, P0, N):\n    \"\"\"\n    Simulates a linear system and applies a Kalman filter.\n\n    The true system dynamics are deterministic (noise-free), while the filter\n    uses the provided Q and R matrices.\n    \"\"\"\n    # Initialize true state and filter state\n    x = x0.copy()\n    x_hat = x0_hat.copy()\n    P = P0.copy()\n    \n    # Store initial values for metric calculation\n    x_initial = x0.copy()\n    x_hat_initial = x0_hat.copy()\n    P_initial = P0.copy()\n\n    # Identity matrix for covariance update\n    n = A.shape[0]\n    I = np.identity(n)\n\n    # Main filter loop over N time steps\n    for _ in range(N):\n        # 1. Prediction (Time Update)\n        x_hat_pred = A @ x_hat\n        P_pred = A @ P @ A.T + Q\n\n        # 2. True system evolution (deterministic)\n        x = A @ x\n        y = H @ x\n\n        # 3. Update (Measurement Update)\n        innovation = y - H @ x_hat_pred\n        S = H @ P_pred @ H.T + R\n        K = P_pred @ H.T @ np.linalg.inv(S)\n        \n        x_hat = x_hat_pred + K @ innovation\n        P = (I - K @ H) @ P_pred\n\n    # Final values after N steps\n    x_final = x\n    x_hat_final = x_hat\n    P_final = P\n\n    # Calculate metrics\n    e_0 = x_initial - x_hat_initial\n    e_N = x_final - x_hat_final\n\n    norm_e0 = np.linalg.norm(e_0)\n    norm_eN = np.linalg.norm(e_N)\n\n    # Avoid division by zero if initial error is zero\n    rho_e = norm_eN / norm_e0 if norm_e0 > 1e-9 else float('inf')\n\n    trace_P0 = np.trace(P_initial)\n    trace_PN = np.trace(P_final)\n    \n    epsilon = 1e-12\n    rho_P = trace_PN / (trace_P0 + epsilon)\n\n    return rho_e, rho_P\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the specified metrics for each.\n    \"\"\"\n    N = 50\n    # Common parameters for most cases\n    Q_common = np.array([[0.0, 0.0], [0.0, 0.0]])\n    R_common = np.array([[1e-4]])\n    x0_hat_common = np.array([[0.0], [0.0]])\n    P0_common = np.identity(2)\n    \n    test_cases = [\n        # Case 1 (non-detectable, diverging error)\n        {\n            \"A\": np.diag([1.2, 0.9]),\n            \"H\": np.array([[0.0, 1.0]]),\n            \"Q\": Q_common,\n            \"R\": R_common,\n            \"x0\": np.array([[1.0], [0.0]]),\n            \"x0_hat\": x0_hat_common,\n            \"P0\": P0_common,\n            \"N\": N\n        },\n        # Case 2 (detectable, convergent error)\n        {\n            \"A\": np.diag([1.2, 0.9]),\n            \"H\": np.array([[1.0, 0.0]]),\n            \"Q\": Q_common,\n            \"R\": R_common,\n            \"x0\": np.array([[1.0], [0.5]]),\n            \"x0_hat\": x0_hat_common,\n            \"P0\": P0_common,\n            \"N\": N\n        },\n        # Case 3 (detectable, unobservable mode stable)\n        {\n            \"A\": np.diag([0.8, 1.1]),\n            \"H\": np.array([[0.0, 1.0]]),\n            \"Q\": Q_common,\n            \"R\": R_common,\n            \"x0\": np.array([[1.0], [0.2]]),\n            \"x0_hat\": x0_hat_common,\n            \"P0\": P0_common,\n            \"N\": N\n        },\n        # Case 4 (boundary, marginally unstable unobservable mode)\n        {\n            \"A\": np.diag([1.0, 0.9]),\n            \"H\": np.array([[0.0, 1.0]]),\n            \"Q\": Q_common,\n            \"R\": R_common,\n            \"x0\": np.array([[1.0], [0.0]]),\n            \"x0_hat\": x0_hat_common,\n            \"P0\": P0_common,\n            \"N\": N\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rho_e, rho_P = run_kalman_simulation(\n            case[\"A\"], case[\"H\"], case[\"Q\"], case[\"R\"],\n            case[\"x0\"], case[\"x0_hat\"], case[\"P0\"], case[\"N\"]\n        )\n        results.append(rho_e)\n        results.append(rho_P)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2912311"}, {"introduction": "即使模型正确且系统可检测，一个看似无误的滤波器实现也可能因为数值舍入误差而失败。本练习探讨了为什么协方差更新的一个常用简化形式在数值上是不稳定的。您将分析更鲁棒的“Joseph 型”更新公式如何保证协方差矩阵的正定性，这是任何实际滤波器实现中的关键细节。[@problem_id:2912301]", "problem": "考虑线性的、时不变的、离散时间的高斯状态空间模型\n$$\nx_{k} = F x_{k-1} + G w_{k-1}, \\quad y_{k} = H x_{k} + v_{k},\n$$\n其中过程噪声为 $w_{k-1} \\sim \\mathcal{N}(0,Q)$，测量噪声为 $v_{k} \\sim \\mathcal{N}(0,R)$，其中 $Q$ 和 $R$ 是对称半正定 (PSD) 协方差。令 $P_{k|k-1}$ 表示先验协方差，$P_{k|k}$ 表示后验协方差。卡尔曼增益为 $K_{k}$，单位矩阵为 $I$，新息协方差为 $S_{k} \\triangleq H P_{k|k-1} H^{\\top} + R$。假设在通常的卡尔曼滤波器设置中，$P_{k|k-1}$ 和 $R$ 是对称半正定的，并且 $K_{k}$ 是由 $P_{k|k-1}$ 和 $R$ 计算得出的。\n\n根据估计误差 $e$ 的协方差定义 $P \\triangleq \\mathbb{E}\\{ e e^{\\top} \\}$，可以推导出一个协方差更新公式，其形式为对称半正定项之和。在精确算术中以及对于最优卡尔曼增益 $K_{k} = P_{k|k-1} H^{\\top} S_{k}^{-1}$，该协方差更新在代数上等价于以下简化形式\n$$\nP_{k|k} = (I - K_{k} H)\\, P_{k|k-1}.\n$$\n然而，在浮点算术中，用户经常观察到简化更新会丢失精确对称性，甚至丢失半正定性。一个广泛使用的补救方法是使用所谓的 Joseph 稳定形式来计算协方差，该形式被构造为对称半正定项之和。\n\n仅使用关于协方差传播的第一性原理、对称半正定矩阵的性质以及有限精度算术（舍入误差和相消误差）的影响，回答以下问题。下面的陈述中，哪些正确地解释了为什么简化的协方差更新在数值上会失去对称性和半正定性，以及 Joseph 形式如何缓解这个问题？\n\n选择所有适用的选项。\n\nA. 在浮点算术中，乘积 $(I - K_{k} H) P_{k|k-1}$ 并不强制对称性，因为其右侧没有应用转置，并且在精确算术中保证非负性的代数相消在数值上无法实现；微小的非对称舍入和相消误差可能产生轻微的负特征值。Joseph 形式将 $P_{k|k}$ 显式地构造为对称半正定项之和，当 $P_{k|k-1}$ 和 $R$ 是半正定时，这在数值上能保持对称性和半正定性。\n\nB. 只有当过程噪声协方差 $Q$ 是奇异时，简化更新才会失去半正定性。选择严格正定的 $Q$ 可以保证 $(I - K_{k} H) P_{k|k-1}$ 保持半正定，因此如果 $Q \\succ 0$，Joseph 形式就是不必要的。\n\nC. 在精确算术和最优卡尔曼增益下，Joseph 形式和简化形式在代数上是等价的。在浮点算术中，由于舍入误差和相消误差，这种等价性在数值上可能被破坏，因此计算 Joseph 形式更稳定，并倾向于保持协方差矩阵的定义性质。\n\nD. $(I - K_{k} H) P_{k|k-1}$ 中对称性的丧失是因为 $H$ 通常是矩形的。如果 $H$ 是方形且可逆的，那么 $(I - K_{k} H) P_{k|k-1}$ 根据构造就是对称的，这个问题就会消失。\n\nE. 通过将 $P_{k|k}$ 替换为 $\\tfrac{1}{2}\\big[(I - K_{k} H) P_{k|k-1} + \\big((I - K_{k} H) P_{k|k-1}\\big)^{\\top}\\big]$ 进行事后对称化，在数学上等价于 Joseph 形式，因此它无需 Joseph 构造就能完全恢复半正定性。\n\nF. 当新息协方差 $S_{k}$ 是病态时，计算 $(I - K_{k} H) P_{k|k-1}$ 会因为 $P_{k|k-1}$ 和 $K_{k} H P_{k|k-1}$ 之间的相消误差而产生较大的相对误差；Joseph 形式通过将 $P_{k|k}$ 构造为多个独立的对称半正定 Gram 型项之和，避免了这种特定的相消，从而降低了出现伪负特征值的风险。\n\n选择正确的选项。", "solution": "问题陈述经过验证，是有效的。它提出了信号处理领域中一个关于卡尔曼滤波器协方差更新方程数值稳定性的标准、良态问题。其前提在科学上是合理的，术语是精确的。因此，我们可以进行严谨的分析。\n\n后验误差协方差 $P_{k|k}$ 的测量更新基础源于后验估计误差的定义 $e_{k|k} \\triangleq x_k - \\hat{x}_{k|k}$。使用标准的卡尔曼滤波器方程，该误差传播为 $e_{k|k} = (I - K_k H) e_{k|k-1} - K_k v_k$。然后通过取外积的期望 $P_{k|k} = \\mathbb{E}\\{e_{k|k} e_{k|k}^\\top\\}$ 来推导协方差。假设先验误差 $e_{k|k-1}$ 和测量噪声 $v_k$ 不相关，这会得出：\n$$ P_{k|k} = (I - K_k H) \\mathbb{E}\\{e_{k|k-1} e_{k|k-1}^\\top\\} (I - K_k H)^\\top + K_k \\mathbb{E}\\{v_k v_k^\\top\\} K_k^\\top $$\n代入 $\\mathbb{E}\\{e_{k|k-1} e_{k|k-1}^\\top\\} = P_{k|k-1}$ 和 $\\mathbb{E}\\{v_k v_k^\\top\\} = R$，我们得到数值上鲁棒的 **Joseph 稳定形式**：\n$$ P_{k|k} = (I - K_k H) P_{k|k-1} (I - K_k H)^\\top + K_k R K_k^\\top $$\n该形式是两个矩阵的和。鉴于 $P_{k|k-1}$ 和 $R$ 是对称半正定 (PSD) 的，$(I - K_k H) P_{k|k-1} (I - K_k H)^\\top$ 和 $K_k R K_k^\\top$ 这两项也是对称半正定的。两个对称半正定矩阵的和保证是对称且半正定的。这种结构即使在有限精度算术中也能内在地保持协方差矩阵的数学性质。\n\n对于最优卡尔曼增益 $K_{k} = P_{k|k-1} H^{\\top} S_{k}^{-1}$，其中 $S_{k} = H P_{k|k-1} H^{\\top} + R$，Joseph 形式可以在代数上进行简化。\n$$ P_{k|k} = P_{k|k-1} - K_k H P_{k|k-1} - P_{k|k-1} H^\\top K_k^\\top + K_k (H P_{k|k-1} H^\\top + R) K_k^\\top $$\n$$ P_{k|k} = P_{k|k-1} - K_k H P_{k|k-1} - P_{k|k-1} H^\\top K_k^\\top + K_k S_k K_k^\\top $$\n将 $K_k S_k = P_{k|k-1} H^\\top$ 代入最后一项，得到 $K_k S_k K_k^\\top = P_{k|k-1} H^\\top K_k^\\top$。表达式变为：\n$$ P_{k|k} = P_{k|k-1} - K_k H P_{k|k-1} - P_{k|k-1} H^\\top K_k^\\top + P_{k|k-1} H^\\top K_k^\\top = P_{k|k-1} - K_k H P_{k|k-1} $$\n这就得到了问题中所述的**简化形式**：\n$$ P_{k|k} = (I - K_{k} H) P_{k|k-1} $$\n虽然在精确算术中它与 Joseph 形式代数等价，但其数值特性较差。原因有两方面：\n$1$. **对称性丢失**：在浮点算术中，计算出的矩阵乘积 $(I - \\tilde{K}_{k} H) \\tilde{P}_{k|k-1}$ 不保证是对称的，因为矩阵 $(I - \\tilde{K}_{k} H)$ 通常不是对称的，并且在精确算术中确保对称性的代数恒等式 $K_k H P_{k|k-1} = P_{k|k-1} H^\\top K_k^\\top$ 会因舍入误差而被破坏。\n$2$. **半正定性丢失**：形式 $P_{k|k} = P_{k|k-1} - K_k H P_{k|k-1}$ 涉及一次减法。当测量信息量很大时（例如，$R$ 很小），修正项 $K_k H P_{k|k-1}$ 会变得非常接近先验协方差 $P_{k|k-1}$。两个大的、几乎相等的矩阵相减会导致相消误差，这是一种灾难性的相对精度损失。这种数值误差可能导致计算出的矩阵 $\\tilde{P}_{k|k}$ 具有小的负特征值，从而失去半正定性。\n\n现在我们基于此分析来评估每个陈述。\n\nA. 在浮点算术中，乘积 $(I - K_{k} H) P_{k|k-1}$ 并不强制对称性，因为其右侧没有应用转置，并且在精确算术中保证非负性的代数相消在数值上无法实现；微小的非对称舍入和相消误差可能产生轻微的负特征值。Joseph 形式将 $P_{k|k}$ 显式地构造为对称半正定项之和，当 $P_{k|k-1}$ 和 $R$ 是半正定时，这在数值上能保持对称性和半正定性。\n该陈述是正确的。它精确地指出了简化形式的结构在计算上不强制对称性。它正确地注意到，在精确算术中保证非负性的代数性质（这在 Joseph 形式中很明显）在简化形式中丢失了，导致数值误差可能产生负特征值。它准确地描述了 Joseph 形式的结构优势。\n判决：**正确**。\n\nB. 只有当过程噪声协方差 $Q$ 是奇异时，简化更新才会失去半正定性。选择严格正定的 $Q$ 可以保证 $(I - K_{k} H) P_{k|k-1}$ 保持半正定，因此如果 $Q \\succ 0$，Joseph 形式就是不必要的。\n该陈述是不正确的。虽然一个更大、更良态的 $P_{k|k-1}$（这可以通过一个正定的 $Q$ 来促进）可以缓解数值问题，但并不能完全消除它们。当测量非常精确时（$R$ 很小），无论 $Q$ 是否奇异，相消误差的问题都最为严重。数值不稳定性是更新公式结构所固有的，并不仅仅取决于 $Q$ 的奇异性。即使 $Q \\succ 0$，Joseph 形式可能仍然是必要的。\n判决：**不正确**。\n\nC. 在精确算术和最优卡尔曼增益下，Joseph 形式和简化形式在代数上是等价的。在浮点算术中，由于舍入误差和相消误差，这种等价性在数值上可能被破坏，因此计算 Joseph 形式更稳定，并倾向于保持协方差矩阵的定义性质。\n该陈述是对整个问题的正确而简明的总结。在精确算术中的代数等价性是一个标准结果。问题的核心在于，由于对数值误差的不同敏感性，这种等价性在浮点算术中被打破。Joseph 形式更稳定且更好地保持协方差矩阵性质的结论是准确的。\n判决：**正确**。\n\nD. $(I - K_{k} H) P_{k|k-1}$ 中对称性的丧失是因为 $H$ 通常是矩形的。如果 $H$ 是方形且可逆的，那么 $(I - K_{k} H) P_{k|k-1}$ 根据构造就是对称的，这个问题就会消失。\n该陈述是不正确的。无论 $H$ 是方的还是矩形的，矩阵 $(I - K_k H)$ 通常都不是对称的。一个非对称矩阵 $(I - K_k H)$ 和一个对称矩阵 $P_{k|k-1}$ 的乘积通常不是对称的。在精确算术中的对称性是最优增益 $K_k$ 的特定值导致的结果，而不是该表达式的一般结构所致。对称性的丢失是一个数值假象，即使 $H$ 是方的且可逆的，这个问题也仍然会存在。\n判决：**不正确**。\n\nE. 通过将 $P_{k|k}$ 替换为 $\\tfrac{1}{2}\\big[(I - K_{k} H) P_{k|k-1} + \\big((I - K_{k} H) P_{k|k-1}\\big)^{\\top}\\big]$ 进行事后对称化，在数学上等价于 Joseph 形式，因此它无需 Joseph 构造就能完全恢复半正定性。\n该陈述是不正确的。虽然这个过程 $P_{new} = \\frac{1}{2} (P_{old} + P_{old}^\\top)$ 确实能强制对称性，但它不能保证半正定性。一个因数值误差而变得不定的矩阵，在对称化后不一定会变成半正定矩阵；它可能仍然拥有负特征值。这种方法只是对对称性的一个启发式修复，但不是一个恢复所需半正定性质的鲁棒解决方案。它在数值行为或保证方面与 Joseph 形式不等价。\n判决：**不正确**。\n\nF. 当新息协方差 $S_{k}$ 是病态时，计算 $(I - K_{k} H) P_{k|k-1}$ 会因为 $P_{k|k-1}$ 和 $K_{k} H P_{k|k-1}$ 之间的相消误差而产生较大的相对误差；Joseph 形式通过将 $P_{k|k}$ 构造为多个独立的对称半正定 Gram 型项之和，避免了这种特定的相消，从而降低了出现伪负特征值的风险。\n该陈述是正确的。它对失去半正定性的机理提供了深入而准确的解释。一个病态的 $S_k$ 通常对应于高精度的测量，这恰恰是更新项 $K_k H P_{k|k-1}$ 接近 $P_{k|k-1}$ 的场景，从而导致相消误差。该陈述正确地指出，Joseph 形式的 \"Gram 型\" 项（即 $APA^\\top$ 形式）的加性结构绕开了这种显式减法，从而更可靠地保持了半正定性。\n判决：**正确**。", "answer": "$$\\boxed{ACF}$$", "id": "2912301"}]}