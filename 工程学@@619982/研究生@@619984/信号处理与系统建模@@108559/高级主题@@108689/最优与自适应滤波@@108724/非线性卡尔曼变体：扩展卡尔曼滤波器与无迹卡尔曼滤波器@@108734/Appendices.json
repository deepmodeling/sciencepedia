{"hands_on_practices": [{"introduction": "无迹卡尔曼滤波器（UKF）的威力源于其核心的无迹变换（Unscented Transform, UT）。这个练习将带你深入 UT 的内部机制，通过一个简单的二次非线性函数来分析其性能。你将通过解析计算来亲自验证，对于高斯输入，UT 如何能够精确地捕捉输出分布的前两个矩，并探索使其估计精确的参数条件 [@problem_id:2886759]。", "problem": "考虑一个标量随机变量 $x \\sim \\mathcal{N}(\\mu,\\sigma^{2})$，它通过非线性函数 $g(x)=x^{2}$。您将分析输入分布到输出的两种映射：(i) Unscented Kalman Filter 中使用的 Unscented Transform (UT) 和 (ii) 高斯定律下矩的精确变换。请使用以下核心定义。\n\n对于标量 Unscented Transform (UT)，维数 $n=1$ 且调整参数为 $\\alpha>0$，$\\kappa \\in \\mathbb{R}$ 和 $\\beta \\in \\mathbb{R}$，定义\n- 缩放参数 $\\lambda = \\alpha^{2}(n+\\kappa)-n$，\n- sigma 点 $x_{0}=\\mu$，$x_{1}=\\mu+\\sqrt{(n+\\lambda)\\sigma^{2}}$ 和 $x_{2}=\\mu-\\sqrt{(n+\\lambda)\\sigma^{2}}$，\n- 变换后均值的权重 $W_{0}^{(m)}=\\dfrac{\\lambda}{n+\\lambda}$ 和 $W_{i}^{(m)}=\\dfrac{1}{2(n+\\lambda)}$ (对于 $i\\in\\{1,2\\}$)，\n- 变换后协方差的权重 $W_{0}^{(c)}=\\dfrac{\\lambda}{n+\\lambda}+\\left(1-\\alpha^{2}+\\beta\\right)$ 和 $W_{i}^{(c)}=\\dfrac{1}{2(n+\\lambda)}$ (对于 $i\\in\\{1,2\\}$)。\n\n$y=g(x)$ 的 UT 预测均值定义为 $\\bar{y}_{\\mathrm{UT}}=\\sum_{i=0}^{2}W_{i}^{(m)}g(x_{i})$，UT 预测方差为 $S_{\\mathrm{UT}}=\\sum_{i=0}^{2}W_{i}^{(c)}\\left(g(x_{i})-\\bar{y}_{\\mathrm{UT}}\\right)^{2}$。\n\n仅从上述 UT 定义和高斯分布的标准性质出发，以闭式形式推导：\n- 针对 $g(x)=x^{2}$ 的 UT 预测均值 $\\bar{y}_{\\mathrm{UT}}$，\n- 针对 $g(x)=x^{2}$ 的 UT 预测方差 $S_{\\mathrm{UT}}$，\n- 精确均值 $\\mathbb{E}[x^{2}]$，\n- 精确方差 $\\mathrm{Var}[x^{2}]$。\n\n然后比较这些表达式，并在您的推理中确定使 UT 方差与精确方差相匹配的任何参数条件。\n\n将您的最终答案表示为一个单行矩阵，其中依次包含以 $\\mu$、$\\sigma$、$\\alpha$、$\\beta$ 和 $\\kappa$ 表示的四个表达式 $\\left(\\bar{y}_{\\mathrm{UT}},\\,S_{\\mathrm{UT}},\\,\\mathbb{E}[x^{2}],\\,\\mathrm{Var}[x^{2}]\\right)$。不需要数值取整，这些量也没有单位。", "solution": "问题陈述需要经过验证。\n\n**步骤 1：提取已知条件**\n- 一个标量随机变量 $x$ 服从正态分布：$x \\sim \\mathcal{N}(\\mu, \\sigma^{2})$。\n- 非线性函数为 $g(x) = x^{2}$。\n- 维数为 $n=1$。\n- 调整参数为 $\\alpha > 0$，$\\kappa \\in \\mathbb{R}$ 和 $\\beta \\in \\mathbb{R}$。\n- 缩放参数定义为 $\\lambda = \\alpha^{2}(n+\\kappa) - n$。\n- sigma 点为 $x_{0} = \\mu$，$x_{1} = \\mu + \\sqrt{(n+\\lambda)\\sigma^{2}}$ 和 $x_{2} = \\mu - \\sqrt{(n+\\lambda)\\sigma^{2}}$。\n- 变换后均值的权重为 $W_{0}^{(m)} = \\frac{\\lambda}{n+\\lambda}$ 和 $W_{i}^{(m)} = \\frac{1}{2(n+\\lambda)}$ (对于 $i \\in \\{1, 2\\}$)。\n- 变换后协方差的权重为 $W_{0}^{(c)} = \\frac{\\lambda}{n+\\lambda} + (1 - \\alpha^{2} + \\beta)$ 和 $W_{i}^{(c)} = \\frac{1}{2(n+\\lambda)}$ (对于 $i \\in \\{1, 2\\}$)。\n- $y=g(x)$ 的 UT 预测均值为 $\\bar{y}_{\\mathrm{UT}} = \\sum_{i=0}^{2} W_{i}^{(m)} g(x_{i})$。\n- UT 预测方差为 $S_{\\mathrm{UT}} = \\sum_{i=0}^{2} W_{i}^{(c)} (g(x_{i}) - \\bar{y}_{\\mathrm{UT}})^{2}$。\n- 需要推导的是 $\\bar{y}_{\\mathrm{UT}}$、$S_{\\mathrm{UT}}$、$\\mathbb{E}[x^{2}]$ 和 $\\mathrm{Var}[x^{2}]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，是适定且客观的。它基于 Unscented Transform (UT) 的标准公式和高斯分布的统计性质，这些是信号处理和估计理论中的基石概念。该问题是自洽的，提供了所有必要的定义和参数。目标以数学精度陈述，推导过程会得出一组唯一的表达式。不存在逻辑矛盾、事实不健全或含糊不清之处。\n\n**步骤 3：结论与行动**\n问题被视为有效。将提供完整的解答。\n\n**Unscented Transform (UT) 和精确矩的推导**\n\n首先，我们针对给定的维数 $n=1$ 来具体化 UT 参数。\n缩放参数 $\\lambda$ 变为：\n$$ \\lambda = \\alpha^{2}(1+\\kappa) - 1 $$\n复合参数 $n+\\lambda$ 简化为 $1+\\lambda = \\alpha^{2}(1+\\kappa)$。要使 sigma 点为实数，一个隐含的假设是 $(n+\\lambda)\\sigma^{2} \\ge 0$。由于 $\\sigma^{2} \\ge 0$，我们需要 $1+\\lambda \\ge 0$，如果我们假设 $1+\\kappa \\ge 0$，那么由于 $\\alpha^{2}(1+\\kappa) \\ge 0$，该条件成立。问题中没有说明这一点，但对于实值变换来说这是必需的。我们在假设此条件成立的情况下继续。\n\nsigma 点为：\n$$ x_{0} = \\mu $$\n$$ x_{1} = \\mu + \\sqrt{(1+\\lambda)\\sigma^{2}} = \\mu + \\sqrt{\\alpha^{2}(1+\\kappa)\\sigma^{2}} = \\mu + \\alpha\\sqrt{1+\\kappa}\\sigma $$\n$$ x_{2} = \\mu - \\sqrt{(1+\\lambda)\\sigma^{2}} = \\mu - \\sqrt{\\alpha^{2}(1+\\kappa)}\\sigma $$\n\n均值的权重为：\n$$ W_{0}^{(m)} = \\frac{\\lambda}{1+\\lambda} = \\frac{\\alpha^{2}(1+\\kappa) - 1}{\\alpha^{2}(1+\\kappa)} $$\n$$ W_{1}^{(m)} = W_{2}^{(m)} = \\frac{1}{2(1+\\lambda)} = \\frac{1}{2\\alpha^{2}(1+\\kappa)} $$\n\n我们将 sigma 点通过非线性函数 $g(x) = x^{2}$ 进行传播：\n$$ y_{0} = g(x_{0}) = \\mu^{2} $$\n$$ y_{1} = g(x_{1}) = \\left(\\mu + \\alpha\\sqrt{1+\\kappa}\\sigma\\right)^{2} = \\mu^{2} + 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\alpha^{2}(1+\\kappa)\\sigma^{2} $$\n$$ y_{2} = g(x_{2}) = \\left(\\mu - \\alpha\\sqrt{1+\\kappa}\\sigma\\right)^{2} = \\mu^{2} - 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\alpha^{2}(1+\\kappa)\\sigma^{2} $$\n\n**1. UT 预测均值 $\\bar{y}_{\\mathrm{UT}}$**\nUT 预测均值为 $\\bar{y}_{\\mathrm{UT}} = \\sum_{i=0}^{2} W_{i}^{(m)} y_{i}$。\n$$ \\bar{y}_{\\mathrm{UT}} = W_{0}^{(m)}y_{0} + W_{1}^{(m)}y_{1} + W_{2}^{(m)}y_{2} $$\n由于 $W_{1}^{(m)} = W_{2}^{(m)}$，这可以写成：\n$$ \\bar{y}_{\\mathrm{UT}} = W_{0}^{(m)}y_{0} + W_{1}^{(m)}(y_{1} + y_{2}) $$\n和 $y_{1} + y_{2}$ 是：\n$$ y_{1} + y_{2} = \\left(\\mu^{2} + 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\alpha^{2}(1+\\kappa)\\sigma^{2}\\right) + \\left(\\mu^{2} - 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\alpha^{2}(1+\\kappa)\\sigma^{2}\\right) = 2\\mu^{2} + 2\\alpha^{2}(1+\\kappa)\\sigma^{2} $$\n代入权重和传播后的点：\n$$ \\bar{y}_{\\mathrm{UT}} = \\left(\\frac{\\alpha^{2}(1+\\kappa) - 1}{\\alpha^{2}(1+\\kappa)}\\right)\\mu^{2} + \\left(\\frac{1}{2\\alpha^{2}(1+\\kappa)}\\right)\\left(2\\mu^{2} + 2\\alpha^{2}(1+\\kappa)\\sigma^{2}\\right) $$\n$$ \\bar{y}_{\\mathrm{UT}} = \\left(\\frac{\\alpha^{2}(1+\\kappa) - 1}{\\alpha^{2}(1+\\kappa)}\\right)\\mu^{2} + \\frac{1}{\\alpha^{2}(1+\\kappa)}\\mu^{2} + \\sigma^{2} $$\n$$ \\bar{y}_{\\mathrm{UT}} = \\mu^{2}\\left(\\frac{\\alpha^{2}(1+\\kappa) - 1 + 1}{\\alpha^{2}(1+\\kappa)}\\right) + \\sigma^{2} = \\mu^{2}\\left(\\frac{\\alpha^{2}(1+\\kappa)}{\\alpha^{2}(1+\\kappa)}\\right) + \\sigma^{2} $$\n$$ \\bar{y}_{\\mathrm{UT}} = \\mu^{2} + \\sigma^{2} $$\n\n**2. UT 预测方差 $S_{\\mathrm{UT}}$**\nUT 预测方差为 $S_{\\mathrm{UT}} = \\sum_{i=0}^{2} W_{i}^{(c)}(y_{i} - \\bar{y}_{\\mathrm{UT}})^{2}$。\n协方差的权重为：\n$$ W_{0}^{(c)} = \\frac{\\lambda}{1+\\lambda} + (1 - \\alpha^{2} + \\beta) = \\frac{\\alpha^{2}(1+\\kappa)-1}{\\alpha^{2}(1+\\kappa)} + 1 - \\alpha^{2} + \\beta $$\n$$ W_{1}^{(c)} = W_{2}^{(c)} = \\frac{1}{2(1+\\lambda)} = \\frac{1}{2\\alpha^{2}(1+\\kappa)} $$\n我们计算与预测均值的偏差：\n$$ y_{0} - \\bar{y}_{\\mathrm{UT}} = \\mu^{2} - (\\mu^{2} + \\sigma^{2}) = -\\sigma^{2} $$\n$$ y_{1} - \\bar{y}_{\\mathrm{UT}} = \\left(\\mu^{2} + 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\alpha^{2}(1+\\kappa)\\sigma^{2}\\right) - (\\mu^{2} + \\sigma^{2}) = 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\left(\\alpha^{2}(1+\\kappa) - 1\\right)\\sigma^{2} $$\n$$ y_{2} - \\bar{y}_{\\mathrm{UT}} = \\left(\\mu^{2} - 2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\alpha^{2}(1+\\kappa)\\sigma^{2}\\right) - (\\mu^{2} + \\sigma^{2}) = -2\\mu\\alpha\\sqrt{1+\\kappa}\\sigma + \\left(\\alpha^{2}(1+\\kappa) - 1\\right)\\sigma^{2} $$\n注意 $\\alpha^{2}(1+\\kappa)-1 = \\lambda$。所以偏差为：\n$$ y_{1} - \\bar{y}_{\\mathrm{UT}} = 2\\mu\\sqrt{1+\\lambda}\\sigma + \\lambda\\sigma^{2} $$\n$$ y_{2} - \\bar{y}_{\\mathrm{UT}} = -2\\mu\\sqrt{1+\\lambda}\\sigma + \\lambda\\sigma^{2} $$\n方差和为 $S_{\\mathrm{UT}} = W_{0}^{(c)}(-\\sigma^{2})^{2} + W_{1}^{(c)}\\left( (y_{1} - \\bar{y}_{\\mathrm{UT}})^{2} + (y_{2} - \\bar{y}_{\\mathrm{UT}})^{2} \\right)$。\n对于 $i=1,2$ 的偏差平方和为：\n$$ (y_{1} - \\bar{y}_{\\mathrm{UT}})^{2} + (y_{2} - \\bar{y}_{\\mathrm{UT}})^{2} = 2\\left( (2\\mu\\sqrt{1+\\lambda}\\sigma)^{2} + (\\lambda\\sigma^{2})^{2} \\right) = 2\\left( 4\\mu^{2}(1+\\lambda)\\sigma^{2} + \\lambda^{2}\\sigma^{4} \\right) = 8\\mu^{2}(1+\\lambda)\\sigma^{2} + 2\\lambda^{2}\\sigma^{4} $$\n代入方差方程：\n$$ S_{\\mathrm{UT}} = W_{0}^{(c)}\\sigma^{4} + \\frac{1}{2(1+\\lambda)}\\left( 8\\mu^{2}(1+\\lambda)\\sigma^{2} + 2\\lambda^{2}\\sigma^{4} \\right) $$\n$$ S_{\\mathrm{UT}} = W_{0}^{(c)}\\sigma^{4} + 4\\mu^{2}\\sigma^{2} + \\frac{\\lambda^{2}}{1+\\lambda}\\sigma^{4} $$\n现在代入 $W_{0}^{(c)} = \\frac{\\lambda}{1+\\lambda} + 1 - \\alpha^{2} + \\beta$：\n$$ S_{\\mathrm{UT}} = \\left( \\frac{\\lambda}{1+\\lambda} + 1 - \\alpha^{2} + \\beta \\right)\\sigma^{4} + 4\\mu^{2}\\sigma^{2} + \\frac{\\lambda^{2}}{1+\\lambda}\\sigma^{4} $$\n$$ S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + \\left( \\frac{\\lambda + \\lambda^{2}}{1+\\lambda} + 1 - \\alpha^{2} + \\beta \\right)\\sigma^{4} $$\n$$ S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + \\left( \\frac{\\lambda(1 + \\lambda)}{1+\\lambda} + 1 - \\alpha^{2} + \\beta \\right)\\sigma^{4} $$\n$$ S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + (\\lambda + 1 - \\alpha^{2} + \\beta)\\sigma^{4} $$\n最后，代入 $\\lambda = \\alpha^{2}(1+\\kappa) - 1$：\n$$ S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + (\\alpha^{2}(1+\\kappa) - 1 + 1 - \\alpha^{2} + \\beta)\\sigma^{4} $$\n$$ S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + (\\alpha^{2} + \\alpha^{2}\\kappa - \\alpha^{2} + \\beta)\\sigma^{4} $$\n$$ S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + (\\alpha^{2}\\kappa + \\beta)\\sigma^{4} $$\n\n**3. 精确均值 $\\mathbb{E}[x^{2}]$**\n对于任何随机变量 $x$，方差定义为 $\\mathrm{Var}[x] = \\mathbb{E}[x^{2}] - (\\mathbb{E}[x])^{2}$。\n给定 $x \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，我们有 $\\mathbb{E}[x] = \\mu$ 和 $\\mathrm{Var}[x] = \\sigma^{2}$。\n$$ \\sigma^{2} = \\mathbb{E}[x^{2}] - \\mu^{2} $$\n求解二阶矩 $\\mathbb{E}[x^{2}]$：\n$$ \\mathbb{E}[x^{2}] = \\mu^{2} + \\sigma^{2} $$\n与 UT 的结果比较，我们发现 $\\bar{y}_{\\mathrm{UT}} = \\mathbb{E}[x^{2}]$。对于高斯变量的二次函数，Unscented Transform 对其均值的计算是精确的。\n\n**4. 精确方差 $\\mathrm{Var}[x^{2}]$**\n$y=x^{2}$ 的方差由 $\\mathrm{Var}[y] = \\mathbb{E}[y^{2}] - (\\mathbb{E}[y])^{2}$ 给出。\n$$ \\mathrm{Var}[x^{2}] = \\mathbb{E}[(x^{2})^{2}] - (\\mathbb{E}[x^{2}])^{2} = \\mathbb{E}[x^{4}] - (\\mu^{2} + \\sigma^{2})^{2} $$\n我们需要高斯随机变量 $x \\sim \\mathcal{N}(\\mu, \\sigma^{2})$ 的四阶矩 $\\mathbb{E}[x^{4}]$。\n令 $z = (x-\\mu)/\\sigma$，所以 $z \\sim \\mathcal{N}(0, 1)$。那么 $x = \\mu + \\sigma z$。\n$$ \\mathbb{E}[x^{4}] = \\mathbb{E}[(\\mu + \\sigma z)^{4}] = \\mathbb{E}[\\mu^{4} + 4\\mu^{3}(\\sigma z) + 6\\mu^{2}(\\sigma z)^{2} + 4\\mu(\\sigma z)^{3} + (\\sigma z)^{4}] $$\n使用期望的线性和标准正态分布的矩（$\\mathbb{E}[z]=0$, $\\mathbb{E}[z^{2}]=1$, $\\mathbb{E}[z^{3}]=0$, $\\mathbb{E}[z^{4}]=3$）：\n$$ \\mathbb{E}[x^{4}] = \\mu^{4} + 4\\mu^{3}\\sigma\\mathbb{E}[z] + 6\\mu^{2}\\sigma^{2}\\mathbb{E}[z^{2}] + 4\\mu\\sigma^{3}\\mathbb{E}[z^{3}] + \\sigma^{4}\\mathbb{E}[z^{4}] $$\n$$ \\mathbb{E}[x^{4}] = \\mu^{4} + 6\\mu^{2}\\sigma^{2}(1) + \\sigma^{4}(3) = \\mu^{4} + 6\\mu^{2}\\sigma^{2} + 3\\sigma^{4} $$\n现在，将此代入方差表达式：\n$$ \\mathrm{Var}[x^{2}] = (\\mu^{4} + 6\\mu^{2}\\sigma^{2} + 3\\sigma^{4}) - (\\mu^{2} + \\sigma^{2})^{2} $$\n$$ \\mathrm{Var}[x^{2}] = (\\mu^{4} + 6\\mu^{2}\\sigma^{2} + 3\\sigma^{4}) - (\\mu^{4} + 2\\mu^{2}\\sigma^{2} + \\sigma^{4}) $$\n$$ \\mathrm{Var}[x^{2}] = 4\\mu^{2}\\sigma^{2} + 2\\sigma^{4} $$\n\n**UT 方差与精确方差的比较**\n我们比较两个推导出的方差表达式：\n- UT 预测方差：$S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + (\\alpha^{2}\\kappa + \\beta)\\sigma^{4}$\n- 精确方差：$\\mathrm{Var}[x^{2}] = 4\\mu^{2}\\sigma^{2} + 2\\sigma^{4}$\n\n要使这两个表达式对于任何 $\\mu$ 和 $\\sigma$（假设 $\\sigma \\ne 0$）都相同，$\\sigma^{4}$ 项的系数必须相等。\n$$ \\alpha^{2}\\kappa + \\beta = 2 $$\n关于调整参数 $\\alpha$、$\\kappa$ 和 $\\beta$ 的这个条件确保了对于高斯输入，$y=x^{2}$ 的 UT 方差是精确的。满足此条件的一个常见参数选择是 $\\kappa=0$（对于 $n=1$，通常设置为 $3-n$，所以 $\\kappa=2$）和 $\\beta=2$，这是针对高斯分布的标准建议。例如，如果 $n=1$，$\\kappa=2$ 和 $\\beta=0$ 是另一种选择。当 $\\alpha=1, \\kappa=2, \\beta=0$ 时，我们有 $1^{2}(2)+0=2$。当 $\\alpha=1, \\kappa=0, \\beta=2$ 时，我们有 $1^{2}(0)+2=2$。\n\n为最终答案收集最终推导出的表达式。\n- $\\bar{y}_{\\mathrm{UT}} = \\mu^{2} + \\sigma^{2}$\n- $S_{\\mathrm{UT}} = 4\\mu^{2}\\sigma^{2} + (\\alpha^{2}\\kappa + \\beta)\\sigma^{4}$\n- $\\mathbb{E}[x^{2}] = \\mu^{2} + \\sigma^{2}$\n- $\\mathrm{Var}[x^{2}] = 4\\mu^{2}\\sigma^{2} + 2\\sigma^{4}$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\mu^{2} + \\sigma^{2} & 4\\mu^{2}\\sigma^{2} + (\\alpha^{2}\\kappa + \\beta)\\sigma^{4} & \\mu^{2} + \\sigma^{2} & 4\\mu^{2}\\sigma^{2} + 2\\sigma^{4} \\end{pmatrix}}\n$$", "id": "2886759"}, {"introduction": "在将卡尔曼滤波器应用于物理系统时，一个常见的挑战是将连续时间的系统动力学模型转换为滤波器所需的离散时间形式。本练习将指导你完成这一关键步骤，从一个非线性随机微分方程（SDE）出发，推导出其一阶离散时间近似模型。通过这个实践，你将学会如何正确地计算离散过程噪声的协方差，这是确保滤波器性能的关键一环 [@problem_id:2886813]。", "problem": "考虑连续时间非线性随机微分方程\n$$\n\\dot{x}(t) \\;=\\; a\\big(x(t),t\\big) \\;+\\; L\\big(x(t),t\\big)\\,w_c(t),\n$$\n其中 $x(t)\\in\\mathbb{R}^{2}$，$a:\\mathbb{R}^{2}\\times\\mathbb{R}\\to\\mathbb{R}^{2}$，以及 $L:\\mathbb{R}^{2}\\times\\mathbb{R}\\to\\mathbb{R}^{2\\times 2}$。驱动噪声 $w_c(t)$ 是一个零均值向量值高斯白噪声过程，其协方差强度为\n$$\n\\mathbb{E}\\!\\left[w_c(t)\\,w_c^{\\top}(\\tau)\\right] \\;=\\; Q_c\\,\\delta(t-\\tau),\n$$\n其中 $Q_c\\in\\mathbb{R}^{2\\times 2}$ 是对称半正定的，$\\delta(\\cdot)$ 是狄拉克δ分布。这类连续时间模型通常被离散化，以构建扩展卡尔曼滤波器（EKF）和无迹卡尔曼滤波器（UKF）所使用的过程模型。\n\n仅从随机微分方程的积分形式、高斯白噪声作为维纳过程分布导数的定义以及Itô等距性出发，推导一个关于步长 $\\Delta t$ 的一阶离散时间近似，其形式为\n$$\nx_{k+1} \\;\\approx\\; x_k \\;+\\; a\\big(x_k,t_k\\big)\\,\\Delta t \\;+\\; w_k,\n$$\n并给出一个离散时间过程噪声协方差 $\\mathbb{E}\\!\\left[w_k\\,w_k^{\\top}\\right]$ 的显式公式。\n\n然后，对于由下式定义的具体系统\n$$\na(x,t) \\;=\\; \\begin{pmatrix} \\sin(x_1) \\\\ x_1\\,x_2 - t^{2} \\end{pmatrix}, \n\\qquad\nL(x,t) \\;=\\; \\begin{pmatrix} x_1+2 & \\tfrac{1}{2} \\\\ -t & 1+x_2^{2} \\end{pmatrix},\n$$\n其采样时刻 $t_k = 0.2$，状态 $x_k = \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}$，连续时间噪声强度\n$$\nQ_c \\;=\\; \\begin{pmatrix} 0.8 & 0 \\\\ 0 & 1.2 \\end{pmatrix},\n$$\n以及步长 $\\Delta t = 0.1$，计算标量\n$$\n\\operatorname{tr}\\!\\big(Q_k\\big),\n$$\n其中 $Q_k$ 是你在 $(x_k,t_k)$ 处推导得到的一阶离散时间过程噪声协方差。将你的答案四舍五入到四位有效数字。将最终答案表示为纯数（无单位），适用时使用弧度制（此处不出现角度）。", "solution": "所给问题具有科学依据、提法恰当、客观且自洽。它提出了随机系统与非线性滤波领域中的一个标准任务：连续时间Itô随机微分方程（SDE）的离散化。理论推导和后续数值计算所需的所有函数、参数和条件均已提供。该问题遵循Itô微积分和SDE近似理论的既定原则。因此，该问题是有效的，我们继续进行求解。\n\n问题要求对连续时间SDE进行一阶离散化：\n$$\n\\dot{x}(t) = a\\big(x(t),t\\big) + L\\big(x(t),t\\big)\\,w_c(t)\n$$\n这个在工程文献中常见的方程，必须严格地解释为一个Itô SDE。项 $w_c(t)$ 代表一个向量高斯白噪声过程，它是维纳过程 $W(t)$ 的分布导数。$W(t)$ 的协方差由 $\\mathbb{E}[w_c(t)w_c^{\\top}(\\tau)] = Q_c\\,\\delta(t-\\tau)$ 指定，这意味着其基础维纳过程的增量协方差为 $\\mathbb{E}[dW_t dW_t^{\\top}] = Q_c dt$。因此，形式化的Itô SDE为：\n$$\ndx(t) = a(x(t), t) dt + L(x(t), t) dW(t)\n$$\n为推导离散时间模型，我们将此SDE在一个从 $t_k$ 到 $t_{k+1} = t_k + \\Delta t$ 的小时间区间上积分：\n$$\nx(t_{k+1}) - x(t_k) = \\int_{t_k}^{t_{k+1}} a(x(s), s) ds + \\int_{t_k}^{t_{k+1}} L(x(s), s) dW(s)\n$$\n我们记 $x_k = x(t_k)$ 及 $x_{k+1} = x(t_{k+1})$。对于一个小的步长 $\\Delta t$，我们对积分进行近似。最简单的一阶近似（对应于Euler-Maruyama方法）是假设被积函数在区间 $[t_k, t_{k+1}]$ 上是常数，且等于其在区间起点 $t_k$ 处的值。\n\n首先，我们近似漂移项积分：\n$$\n\\int_{t_k}^{t_{k+1}} a(x(s), s) ds \\approx a(x_k, t_k) \\int_{t_k}^{t_{k+1}} ds = a(x_k, t_k) \\Delta t\n$$\n这是一个关于 $\\Delta t$ 的一阶近似。\n\n第二项，即随机积分，构成了离散时间过程噪声，我们将其记为 $w_k$：\n$$\nw_k = \\int_{t_k}^{t_{k+1}} L(x(s), s) dW(s)\n$$\n根据构造，由于 $dW(s)$ 的均值为零，噪声项 $w_k$ 的均值也为零：$\\mathbb{E}[w_k] = 0$。\n\n综合这些结果，我们得到离散时间状态传播模型：\n$$\nx_{k+1} \\approx x_k + a(x_k, t_k) \\Delta t + w_k\n$$\n这就是问题陈述中所要求的结构。\n\n接下来，我们必须求出协方差矩阵 $Q_k = \\mathbb{E}[w_k w_k^{\\top}]$。协方差由下式给出：\n$$\nQ_k = \\mathbb{E}\\left[ \\left( \\int_{t_k}^{t_{k+1}} L(x(s), s) dW(s) \\right) \\left( \\int_{t_k}^{t_{k+1}} L(x(\\tau), \\tau) dW(\\tau) \\right)^{\\top} \\right]\n$$\n我们应用向量值随机积分的Itô等距性，其表述为：\n$$\n\\mathbb{E}\\left[ \\left( \\int_{t_a}^{t_b} \\Phi(s) dW(s) \\right) \\left( \\int_{t_a}^{t_b} \\Phi(s) dW(s) \\right)^{\\top} \\right] = \\mathbb{E}\\left[ \\int_{t_a}^{t_b} \\Phi(s) Q_c \\Phi(s)^{\\top} ds \\right]\n$$\n将此应用于 $w_k$，并令 $\\Phi(s) = L(x(s), s)$，我们得到：\n$$\nQ_k = \\mathbb{E}\\left[ \\int_{t_k}^{t_{k+1}} L(x(s), s) Q_c L(x(s), s)^{\\top} ds \\right]\n$$\n为了保持与漂移项一致的一阶近似，我们用被积函数在区间起点 $(x_k, t_k)$ 的值来近似它。这消除了积分内部及期望中对随机过程 $x(s)$ 的依赖：\n$$\nQ_k \\approx \\int_{t_k}^{t_{k+1}} L(x_k, t_k) Q_c L(x_k, t_k)^{\\top} ds\n$$\n现在，被积函数相对于积分变量 $s$ 是一个常数。计算该积分可得：\n$$\nQ_k = L(x_k, t_k) Q_c L(x_k, t_k)^{\\top} \\Delta t\n$$\n这就是离散时间过程噪声协方差的一阶近似的显式公式。至此，推导完成。\n\n现在，我们对给定的系统进行数值计算。参数为：\n$t_k = 0.2$，$x_k = \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}$，$\\Delta t = 0.1$。\n矩阵函数为：\n$$\nL(x,t) = \\begin{pmatrix} x_1+2 & \\frac{1}{2} \\\\ -t & 1+x_2^2 \\end{pmatrix}, \\qquad Q_c = \\begin{pmatrix} 0.8 & 0 \\\\ 0 & 1.2 \\end{pmatrix}\n$$\n首先，我们在给定的状态和时间上计算 $L(x_k, t_k)$：\n$$\nL_k = L(x_k, t_k) = \\begin{pmatrix} 1+2 & \\frac{1}{2} \\\\ -0.2 & 1+(-2)^2 \\end{pmatrix} = \\begin{pmatrix} 3 & 0.5 \\\\ -0.2 & 1+4 \\end{pmatrix} = \\begin{pmatrix} 3 & 0.5 \\\\ -0.2 & 5 \\end{pmatrix}\n$$\n接下来，我们计算乘积 $L_k Q_c L_k^{\\top}$：\n$$\nL_k Q_c L_k^{\\top} = \\begin{pmatrix} 3 & 0.5 \\\\ -0.2 & 5 \\end{pmatrix} \\begin{pmatrix} 0.8 & 0 \\\\ 0 & 1.2 \\end{pmatrix} \\begin{pmatrix} 3 & 0.5 \\\\ -0.2 & 5 \\end{pmatrix}^{\\top}\n$$\n$$\n= \\begin{pmatrix} 3(0.8) & 0.5(1.2) \\\\ -0.2(0.8) & 5(1.2) \\end{pmatrix} \\begin{pmatrix} 3 & -0.2 \\\\ 0.5 & 5 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 2.4 & 0.6 \\\\ -0.16 & 6 \\end{pmatrix} \\begin{pmatrix} 3 & -0.2 \\\\ 0.5 & 5 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 2.4(3) + 0.6(0.5) & 2.4(-0.2) + 0.6(5) \\\\ -0.16(3) + 6(0.5) & -0.16(-0.2) + 6(5) \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 7.2 + 0.3 & -0.48 + 3 \\\\ -0.48 + 3 & 0.032 + 30 \\end{pmatrix} = \\begin{pmatrix} 7.5 & 2.52 \\\\ 2.52 & 30.032 \\end{pmatrix}\n$$\n最后，我们通过乘以 $\\Delta t$ 来计算 $Q_k$：\n$$\nQ_k = (L_k Q_c L_k^{\\top}) \\Delta t = \\begin{pmatrix} 7.5 & 2.52 \\\\ 2.52 & 30.032 \\end{pmatrix} (0.1) = \\begin{pmatrix} 0.75 & 0.252 \\\\ 0.252 & 3.0032 \\end{pmatrix}\n$$\n问题要求计算该矩阵的迹 $\\operatorname{tr}(Q_k)$：\n$$\n\\operatorname{tr}(Q_k) = 0.75 + 3.0032 = 3.7532\n$$\n结果必须四舍五入到四位有效数字。这个数是 $3.7532$。前四位有效数字是 $3$、$7$、$5$ 和 $3$。第五位有效数字是 $2$，小于 $5$，所以我们舍去。\n最终的数值结果是 $3.753$。", "answer": "$$\n\\boxed{3.753}\n$$", "id": "2886813"}, {"introduction": "处理非加性测量噪声是高级滤波技术中的一个重要课题，而 UKF 在这方面表现出色。本练习提供了一个宝贵的编程实践机会，让你通过实现和比较两种不同的 UKF 策略来解决这个问题。你将亲手构建一个严谨的增广状态 UKF 和一个简化的近似方法，并定量分析它们各自的估计偏差，从而深刻理解在实践中处理复杂噪声模型的权衡与选择 [@problem_id:2886821]。", "problem": "您的任务是针对一个非线性传感问题，在单次测量更新下，实现并比较无迹卡尔曼滤波器（UKF）的两种变体，并量化由加性噪声近似与非加性噪声的增广状态处理所引入的估计器偏差。设定如下。\n\n基本假设和定义：\n- 隐藏状态 $x$ 是一个标量，其先验分布为高斯分布 $x \\sim \\mathcal{N}(m,P)$。\n- 测量模型是非加性的，定义为 $y = \\sqrt{x^2 + v^2}$，其中 $v \\sim \\mathcal{N}(0,R)$ 是一个独立的标量测量噪声。\n- 目标是使用两种UKF变体执行单次贝叶斯测量更新步骤，然后量化偏差。这两种变体是：\n  1. 增广状态UKF：将噪声 $v$ 视为一个额外的状态分量，从而通过对联合变量 $(x,v)$ 的sigma点传播来处理测量非线性。\n  2. 加性噪声近似UKF：将测量模型近似为 $y \\approx h(x) + w$，其中 $h(x) = |x|$ 且 $w \\sim \\mathcal{N}(0,R)$，从而将噪声视为在测量输出端的加性噪声。\n\n您必须使用的基础理论：\n- 针对高斯先验和一般非线性测量的贝叶斯状态估计。\n- 无迹变换（UT），其由确定性的sigma点和相关权重定义，用以近似高斯矩通过非线性函数的传播。以及由该矩传播推导出的无迹卡尔曼滤波器（UKF）的测量更新步骤。请勿假设或使用任何基于线性化的滤波器。请勿假设非加性情况存在闭式表达式；按照UKF原理的要求，通过增广来处理非加性。\n\n问题要求：\n1. 对于每种UKF变体，仅实现测量更新步骤（无时间传播），使用参数 $\\alpha = 0.5$, $\\beta = 2$ 和 $\\kappa = 0$ 的UT。对于增广状态UKF，将增广状态构造为 $(x, v)$，其均值为 $(m, 0)$，协方差为块对角矩阵 $\\mathrm{diag}(P, R)$。\n2. 对于给定的确定性真实状态值 $x_0$，实际测量由 $y(v) = \\sqrt{x_0^2 + v^2}$ 生成，其中 $v \\sim \\mathcal{N}(0,R)$。对于每个给定的 $(x_0, m, P, R)$，将某个UKF变体的条件估计器偏差定义为\n   $$ b = \\mathbb{E}_v[\\hat{x}(y(v)) - x_0], $$\n   其中 $\\hat{x}(y)$ 是UKF在基于观测值 $y$ 的单次测量更新后输出的后验均值。期望是关于真实测量噪声 $v$ 计算的。您必须使用适用于正态分布的高斯求积法，以高精度数值计算此期望。您的程序不得采用蒙特卡洛采样；必须使用具有足够多节点的确定性求积法，以在最终报告的偏差中达到至少 $10^{-6}$ 的数值稳定性和精度水平。\n3. 根据上述规定精确实现两种UKF变体，并为每个测试用例计算 $b_{\\mathrm{aug}}$ 和 $b_{\\mathrm{add}}$，其中 $b_{\\mathrm{aug}}$ 对应于增广状态UKF，$b_{\\mathrm{add}}$ 对应于加性噪声近似UKF。\n\n测试套件：\n- 使用以下四个测试用例，每个都是一个元组 $(x_0, m, P, R)$，其中所有量都是实数标量：\n  - 用例 1: $(x_0, m, P, R) = (\\,1.0,\\,0.8,\\,0.04,\\,0.09\\,)$。\n  - 用例 2: $(x_0, m, P, R) = (\\,0.0,\\,0.0,\\,0.25,\\,0.04\\,)$。\n  - 用例 3: $(x_0, m, P, R) = (\\,1.0,\\,0.0,\\,1.0,\\,4.0\\,)$。\n  - 用例 4: $(x_0, m, P, R) = (\\,2.0,\\,-1.5,\\,0.01,\\,0.25\\,)$。\n\n计算内容：\n- 对每个用例，计算两个浮点数：\n  - $b_{\\mathrm{aug}}$：按上文为增广状态UKF定义的偏差。\n  - $b_{\\mathrm{add}}$：按上文为加性噪声近似UKF定义的偏差。\n\n最终输出格式：\n- 您的程序必须生成一个包含在方括号中的单行逗号分隔列表，按顺序包含所有四个用例的结果，并展平为\n  $$[\\,b_{\\mathrm{aug}}^{(1)},\\,b_{\\mathrm{add}}^{(1)},\\,b_{\\mathrm{aug}}^{(2)},\\,b_{\\mathrm{add}}^{(2)},\\,b_{\\mathrm{aug}}^{(3)},\\,b_{\\mathrm{add}}^{(3)},\\,b_{\\mathrm{aug}}^{(4)},\\,b_{\\mathrm{add}}^{(4)}\\,].$$\n- 每个数字必须打印并四舍五入到恰好 $6$ 位小数。\n- 本问题中没有物理单位。", "solution": "该问题要求对一个具有非加性噪声的非线性估计问题，对比分析两种无迹卡尔曼滤波器（UKF）变体。比较的基础是条件估计器偏差，这是评估估计器性能的一个关键指标。这需要严格实现标准的增广状态UKF和将噪声视为加性的近似UKF，然后对偏差积分进行精确的数值评估。\n\n基本原理是贝叶斯状态估计。给定隐藏状态 $x$ 的先验概率分布 $p(x)$，以及通过似然模型 $p(y|x)$ 与状态关联的测量值 $y$，目标是计算后验分布 $p(x|y) \\propto p(y|x)p(x)$。当先验为高斯分布且系统模型为非线性时，UKF提供了一种近似后验分布均值和协方差的方法。\n\n分析分三个阶段进行：首先，概述通用的UKF测量更新算法；其次，为两种指定的变体具体化此算法；最后，详细说明计算估计器偏差的数值过程。\n\n**1. 无迹卡尔曼滤波器测量更新**\n\n无迹变换（UT）是一种将高斯随机变量通过非线性函数进行传播的算法。它通过在一组最小化的、确定性选择的采样点（称为sigma点）上评估该函数，来近似变换后变量的统计特性。对于一个维度为 $L$、均值为 $m$、协方差为 $P$ 的通用状态向量，sigma点 $\\mathcal{X}_i$ 及其相关权重 $W_i^{(m)}$ (用于均值) 和 $W_i^{(c)}$ (用于协方差) 的生成方式如下。\n\n缩放参数 $\\lambda$ 定义为 $\\lambda = \\alpha^2(L+\\kappa)-L$。\n权重为：\n$$ W_0^{(m)} = \\frac{\\lambda}{L+\\lambda} $$\n$$ W_i^{(m)} = \\frac{1}{2(L+\\lambda)} \\quad \\text{for } i=1,\\dots,2L $$\n$$ W_0^{(c)} = \\frac{\\lambda}{L+\\lambda} + (1 - \\alpha^2 + \\beta) $$\n$$ W_i^{(c)} = W_i^{(m)} \\quad \\text{for } i=1,\\dots,2L $$\nSigma点由均值 $m$ 和协方差 $P$ 生成：\n$$ \\mathcal{X}_0 = m $$\n$$ \\mathcal{X}_i = m + (\\sqrt{(L+\\lambda)P})_i \\quad \\text{for } i=1,\\dots,L $$\n$$ \\mathcal{X}_{i+L} = m - (\\sqrt{(L+\\lambda)P})_i \\quad \\text{for } i=1,\\dots,L $$\n其中 $(\\sqrt{A})_i$ 表示 $A$ 的矩阵平方根（例如，通过Cholesky分解得到）的第 $i$ 列。\n\n对于测量模型 $y = f(x) + w$，其中 $w \\sim \\mathcal{N}(0, R_{noise})$ 是加性噪声，UKF测量更新过程如下：\n1.  通过测量函数传播sigma点：$\\mathcal{Y}_i = f(\\mathcal{X}_i)$。\n2.  计算预测测量均值：$\\hat{y} = \\sum_{i=0}^{2L} W_i^{(m)} \\mathcal{Y}_i$。\n3.  计算预测测量协方差：$P_{yy} = \\sum_{i=0}^{2L} W_i^{(c)} (\\mathcal{Y}_i - \\hat{y})(\\mathcal{Y}_i - \\hat{y})^T + R_{noise}$。\n4.  计算状态-测量互协方差：$P_{xy} = \\sum_{i=0}^{2L} W_i^{(c)} (\\mathcal{X}_i - m)(\\mathcal{Y}_i - \\hat{y})^T$。\n5.  计算卡尔曼增益：$K = P_{xy}P_{yy}^{-1}$。\n6.  更新状态均值和协方差：\n    $$ \\hat{m} = m + K(y_{obs} - \\hat{y}) $$\n    $$ \\hat{P} = P - K P_{yy} K^T $$\n其中 $y_{obs}$ 是观测到的测量值。后验均值 $\\hat{m}$ 即为状态估计 $\\hat{x}$。\n\n**2. UKF变体1：增广状态公式**\n\n给定的测量模型 $y = \\sqrt{x^2 + v^2}$（其中 $v \\sim \\mathcal{N}(0,R)$）是非加性的。在UKF框架内的原则性方法是增广状态向量以包含噪声项。\n增广状态为 $x_a = [x, v]^T$。其先验分布是高斯分布，均值和协方差由下式给出：\n$$ m_a = \\begin{pmatrix} m \\\\ 0 \\end{pmatrix}, \\quad P_a = \\begin{pmatrix} P & 0 \\\\ 0 & R \\end{pmatrix} $$\n增广状态的维度是 $L=2$。测量模型成为增广状态的确定性函数：\n$$ y = g(x_a) = \\sqrt{x_{a,1}^2 + x_{a,2}^2} $$\n测量更新通过将UKF算法应用于此增广系统来进行。关键区别在于测量模型 $g(x_a)$ 现在是无噪声的，因此 $P_{yy}$ 方程中的加性噪声协方差 $R_{noise}$ 为零。\n对于本问题，当 $L=2$ 且给定参数 $\\alpha=0.5, \\beta=2, \\kappa=0$ 时，我们有 $\\lambda = -1.5$。权重为 $W_0^{(m)}=-3$, $W_{1,2,3,4}^{(m)}=1$, $W_0^{(c)}=-0.25$, 以及 $W_{1,2,3,4}^{(c)}=1$。$x_a$ 的sigma点由 $m_a$ 和 $P_a$ 生成。得到的后验均值 $\\hat{m}_a$ 是一个2维向量；状态估计 $\\hat{x}$ 是其第一个分量 $\\hat{m}_{a,1}$。\n\n**3. UKF变体2：加性噪声近似**\n\n该变体通过在测量模型上强加一个简化的加性噪声结构来避免状态增广：\n$$ y \\approx h(x) + w, \\quad \\text{其中 } h(x) = |x| \\text{ 且 } w \\sim \\mathcal{N}(0,R). $$\n这种近似将一个非加性噪声问题转化为一个标准的加性问题，但可能以牺牲精度为代价。UKF更新直接应用于原始状态 $x$，它是一个标量（$L=1$）。\n对于 $L=1$ 和给定参数，我们有 $\\lambda = -0.75$。权重为 $W_0^{(m)}=-3$, $W_{1,2}^{(m)}=2$, $W_0^{(c)}=-0.25$, 以及 $W_{1,2}^{(c)}=2$。UKF更新方程使用状态 $x \\sim \\mathcal{N}(m,P)$、测量函数 $h(x)=|x|$ 和加性噪声协方差 $R_{noise} = R$。\n\n**4. 估计器偏差计算**\n\n条件估计器偏差定义为 $b = \\mathbb{E}_v[\\hat{x}(y(v)) - x_0]$，其中期望是关于真实测量噪声 $v \\sim \\mathcal{N}(0,R)$ 计算的。函数 $\\hat{x}(y)$ 表示由某个UKF变体针对给定测量值 $y$ 计算出的后验均值。测量值 $y(v)$ 是根据真实的物理模型生成的：$y(v) = \\sqrt{x_0^2 + v^2}$。\n\n为了数值计算此期望，我们将其表示为一个积分：\n$$ b = \\int_{-\\infty}^{\\infty} \\left[ \\hat{x}(\\sqrt{x_0^2 + \\nu^2}) - x_0 \\right] \\frac{1}{\\sqrt{2\\pi R}} \\exp\\left(-\\frac{\\nu^2}{2R}\\right) d\\nu $$\n该积分非常适合使用高斯-埃尔米特求积法。我们进行变量替换 $z = \\nu / \\sqrt{2R}$，于是 $d\\nu = \\sqrt{2R} dz$。\n$$ b = \\int_{-\\infty}^{\\infty} \\left[ \\hat{x}(\\sqrt{x_0^2 + 2R z^2}) - x_0 \\right] \\frac{1}{\\sqrt{\\pi}} e^{-z^2} dz $$\n使用高斯-埃尔米特求积的节点 $z_i$ 和权重 $w_i^{\\text{GH}}$，该积分可近似为一个加权和：\n$$ b \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{N_q} w_i^{\\text{GH}} \\left[ \\hat{x}(\\sqrt{x_0^2 + 2R z_i^2}) - x_0 \\right] $$\n其中 $N_q$ 是求积点的数量。必须选择足够大的 $N_q$ 以确保数值精度。对于每个求积节点 $z_i$，计算对应的测量值 $y_i = \\sqrt{x_0^2 + 2R z_i^2}$，执行UKF更新以找到 $\\hat{x}(y_i)$，并将结果累加到总和中。对 $b_{\\mathrm{aug}}$ 和 $b_{\\mathrm{add}}$ 分别执行此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_hermite\n\ndef solve():\n    \"\"\"\n    Implements and compares two Unscented Kalman Filter (UKF) variants for a \n    nonlinear sensing problem and quantifies their estimator bias.\n    \"\"\"\n\n    # --- UKF and Quadrature Parameters ---\n    ALPHA = 0.5\n    BETA = 2.0\n    KAPPA = 0.0\n    QUADRATURE_NODES = 100\n\n    def get_ukf_params(L):\n        \"\"\"Computes sigma point weights and parameters for a given state dimension.\"\"\"\n        lam = ALPHA**2 * (L + KAPPA) - L\n        \n        # Weights for mean\n        wm = np.full(2 * L + 1, 1 / (2 * (L + lam)))\n        wm[0] = lam / (L + lam)\n        \n        # Weights for covariance\n        wc = np.copy(wm)\n        wc[0] += (1 - ALPHA**2 + BETA)\n        \n        gamma = np.sqrt(L + lam)\n        return wm, wc, gamma\n\n    def ukf_additive_update(y_obs, m, P, R):\n        \"\"\"\n        Performs a measurement update for the additive-noise approximation UKF.\n        State dim L=1. Model: y = |x| + w, w ~ N(0,R).\n        \"\"\"\n        L = 1\n        wm, wc, gamma = get_ukf_params(L)\n\n        # Generate sigma points\n        sqrt_P = np.sqrt(P)\n        sigma_points = np.zeros(2 * L + 1)\n        sigma_points[0] = m\n        sigma_points[1] = m + gamma * sqrt_P\n        sigma_points[2] = m - gamma * sqrt_P\n\n        # Propagate sigma points through measurement function h(x) = |x|\n        y_sigma = np.abs(sigma_points)\n        \n        # Predicted measurement\n        y_hat = np.sum(wm * y_sigma)\n        \n        # Predicted measurement covariance\n        P_yy = np.sum(wc * (y_sigma - y_hat)**2) + R\n        \n        # Cross-covariance\n        P_xy = np.sum(wc * (sigma_points - m) * (y_sigma - y_hat))\n        \n        # Kalman gain\n        K = P_xy / P_yy\n        \n        # Update state mean\n        m_post = m + K * (y_obs - y_hat)\n        \n        return m_post\n\n    def ukf_augmented_update(y_obs, m, P, R):\n        \"\"\"\n        Performs a measurement update for the augmented-state UKF.\n        Augmented state: [x, v]^T. State dim L=2. Model: y = sqrt(x^2 + v^2).\n        \"\"\"\n        L = 2\n        wm, wc, gamma = get_ukf_params(L)\n\n        # Augmented prior mean and covariance\n        m_aug = np.array([m, 0.0])\n        P_aug = np.diag([P, R])\n\n        # Generate sigma points\n        # For diagonal P_aug, Cholesky is just sqrt of diagonal\n        sqrt_P_aug_diag = np.sqrt(np.diag(P_aug))\n        \n        sigma_points = np.zeros((2 * L + 1, L))\n        sigma_points[0, :] = m_aug\n        for i in range(L):\n            sigma_points[i + 1, :] = m_aug + gamma * sqrt_P_aug_diag * (np.eye(L)[:, i])\n            sigma_points[i + L + 1, :] = m_aug - gamma * sqrt_P_aug_diag * (np.eye(L)[:, i])\n\n        # Propagate sigma points through g(x,v) = sqrt(x^2 + v^2)\n        x_sigma = sigma_points[:, 0]\n        v_sigma = sigma_points[:, 1]\n        y_sigma = np.sqrt(x_sigma**2 + v_sigma**2)\n\n        # Predicted measurement\n        y_hat = np.sum(wm * y_sigma)\n\n        # Predicted measurement covariance (note: effective noise R is 0)\n        P_yy = np.sum(wc * (y_sigma - y_hat)**2)\n        if P_yy == 0: # Avoid division by zero\n            return m # No update if innovation covariance is zero\n\n        # Cross-covariance (between augmented state and measurement)\n        P_xay = np.zeros(L)\n        for i in range(2 * L + 1):\n            P_xay += wc[i] * (sigma_points[i, :] - m_aug) * (y_sigma[i] - y_hat)\n\n        # Kalman gain\n        K = P_xay / P_yy\n        \n        # Update augmented state mean\n        m_aug_post = m_aug + K * (y_obs - y_hat)\n        \n        # Return only the estimate for the original state x\n        return m_aug_post[0]\n\n    def compute_bias(x0, m, P, R):\n        \"\"\"\n        Computes the conditional estimator bias for both UKF variants\n        using Gauss-Hermite quadrature.\n        \"\"\"\n        nodes, weights = roots_hermite(QUADRATURE_NODES)\n        \n        bias_aug = 0.0\n        bias_add = 0.0\n\n        for i in range(QUADRATURE_NODES):\n            z_i = nodes[i]\n            w_i = weights[i]\n\n            # True noise value for this quadrature point\n            v = np.sqrt(2 * R) * z_i\n            # Corresponding true measurement\n            y_true = np.sqrt(x0**2 + v**2)\n\n            # --- Calculate posterior means for this measurement ---\n            # Augmented UKF\n            x_hat_aug = ukf_augmented_update(y_true, m, P, R)\n            # Additive-approx UKF\n            x_hat_add = ukf_additive_update(y_true, m, P, R)\n\n            # --- Accumulate weighted difference for bias ---\n            bias_aug += w_i * (x_hat_aug - x0)\n            bias_add += w_i * (x_hat_add - x0)\n\n        # Finalize bias calculation (divide by sqrt(pi))\n        bias_aug /= np.sqrt(np.pi)\n        bias_add /= np.sqrt(np.pi)\n\n        return bias_aug, bias_add\n\n    # --- Test Suite ---\n    test_cases = [\n        (1.0, 0.8, 0.04, 0.09),\n        (0.0, 0.0, 0.25, 0.04),\n        (1.0, 0.0, 1.0, 4.0),\n        (2.0, -1.5, 0.01, 0.25),\n    ]\n\n    all_results = []\n    for x0, m, P, R in test_cases:\n        b_aug, b_add = compute_bias(x0, m, P, R)\n        all_results.append(f\"{b_aug:.6f}\")\n        all_results.append(f\"{b_add:.6f}\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2886821"}]}