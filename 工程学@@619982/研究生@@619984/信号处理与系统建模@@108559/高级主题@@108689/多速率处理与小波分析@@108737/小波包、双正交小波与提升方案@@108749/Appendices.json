{"hands_on_practices": [{"introduction": "理论是基础，但亲手实践才能真正巩固理解。本练习将通过最基础的哈尔小波，引导你一步步手动完成信号的分析与重构。通过处理一个简短的符号信号，你将不仅验证哈尔小波变换的完美重构（Perfect Reconstruction）特性，更重要的是，你将直观地看到传统的滤波与下采样操作如何等价于更高效的提升方案（Lifting Scheme）。这个练习旨在为你建立一个坚实的直观基础，让你深刻理解小波变换的核心机制。[@problem_id:2916288]", "id": "2916288", "problem": "考虑一个长度为$4$的离散时间信号，其样本为 $x[0]=\\alpha$，$x[1]=\\beta$，$x[2]=\\gamma$ 和 $x[3]=\\delta$，其中 $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$。设一个双通道分析/合成滤波器组由 Haar 小波构成，该小波可被视为一个标准正交的双正交对特例。分析低通滤波器为 $h_{0}[n]=\\left\\{\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right\\}$，分析高通滤波器为 $h_{1}[n]=\\left\\{\\frac{1}{\\sqrt{2}},-\\frac{1}{\\sqrt{2}}\\right\\}$，二者长度均为 $2$。分析阶段包括滤波和随后的 $2$ 倍下采样，通过将样本分组为不重叠的相邻对来应用，不进行边界环绕处理。合成阶段是分析的精确逆过程，可以通过 Haar 滤波器组的完全重构 (PR) 特性，或者通过反转相应提升方案（含预测和更新算子）中的提升步骤来获得。\n\n任务：\n1) 仅使用线性时不变滤波、$2$ 倍下采样和给定分析滤波器的定义，显式计算第一级近似序列 $a_{1}[k]$ 和细节序列 $d_{1}[k]$（其中 $k\\in\\{0,1\\}$），结果用 $\\alpha,\\beta,\\gamma,\\delta$ 表示。\n2) 直接从第一性原理出发，使用适用于 Haar 情况的分析多相映射的逆或带有分裂-预测-更新-缩放步骤的提升方案的逆，来推导合成关系。使用这些关系符号化地重构 $\\hat{x}[n]$（其中 $n\\in\\{0,1,2,3\\}$），结果用 $\\alpha,\\beta,\\gamma,\\delta$ 表示。\n3) 通过将重构误差能量 $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$ 表示为关于 $\\alpha,\\beta,\\gamma,\\delta$ 的封闭形式表达式，来符号化地验证完全重构 (PR)。你的最终答案必须是这个 $E(\\alpha,\\beta,\\gamma,\\delta)$。\n4) 为数值验证你的符号推导，取具体值 $x[0]=2$，$x[1]=-1$，$x[2]=0$，$x[3]=3$，并计算 $a_{1}[k]$、$d_{1}[k]$ 和 $\\hat{x}[n]$ 的数值，以确认符号化得到的 $E$ 值。无需四舍五入；保留所有出现的 $\\sqrt{2}$ 为精确形式。\n\n将最终答案表示为 $E(\\alpha,\\beta,\\gamma,\\delta)$ 的单个封闭形式表达式，不带单位。不要提供不等式或方程式；只提供表达式。无需四舍五入。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n第 1 步：提取已知条件\n- 信号：一个长度为 $4$ 的离散时间信号，记为 $x[n]$，其样本为 $x[0]=\\alpha$，$x[1]=\\beta$，$x[2]=\\gamma$ 和 $x[3]=\\delta$。参数 $\\alpha, \\beta, \\gamma, \\delta$ 是实数，即 $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$。\n- 滤波器组：一个基于 Haar 小波的双通道分析/合成系统。\n- 分析滤波器：\n  - 低通：$h_{0}[n]=\\left\\{\\frac{1}{\\sqrt{2}},\\frac{1}{\\sqrt{2}}\\right\\}$，对于 $n \\in \\{0, 1\\}$。\n  - 高通：$h_{1}[n]=\\left\\{\\frac{1}{\\sqrt{2}},-\\frac{1}{\\sqrt{2}}\\right\\}$，对于 $n \\in \\{0, 1\\}$。\n- 分析过程：“先滤波，然后进行 $2$ 倍下采样，通过将样本分组为不重叠的相邻对来应用，不进行边界环绕处理。”\n- 合成过程：分析阶段的精确逆过程。\n- 任务 1：计算第一级近似序列 $a_{1}[k]$ 和细节序列 $d_{1}[k]$，其中 $k\\in\\{0,1\\}$。\n- 任务 2：推导合成关系并重构信号 $\\hat{x}[n]$，其中 $n\\in\\{0,1,2,3\\}$。\n- 任务 3：通过找到重构误差能量 $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$ 的封闭形式表达式来验证完全重构 (PR)。\n- 任务 4：使用 $x[0]=2$，$x[1]=-1$，$x[2]=0$，$x[3]=3$ 对符号推导进行数值验证。\n- 最终答案：$E(\\alpha,\\beta,\\gamma,\\delta)$ 的表达式。\n\n第 2 步：使用提取的已知条件进行验证\n- 科学依据：该问题在根本上是合理的。它基于数字信号处理的既定原理，特别是离散小波变换 (DWT)、滤波器组和提升方案，所有这些都是工程学和应用数学中的标准课题。Haar 小波是一个典型的例子。\n- 良定性：该问题是良定的。信号是有限的，滤波器有明确定义，边界处理（“不重叠的相邻对”）也得到了明确的规定。这确保了可以确定唯一的解。\n- 客观性：问题以精确、客观和数学化的语言陈述，没有任何主观或模棱两可的术语。\n\n第 3 步：结论与行动\n该问题是有效的。这是一个离散信号处理中的标准练习，具有科学依据、良定性和客观性。现在将提供完整的解答。\n\n该问题需要一个包含四部分的推导和验证过程。我们将有条不紊地完成每个任务。“将样本分组为不重叠的相邻对”这一短语意味着变换被独立地应用于对 $(x[0], x[1])$ 和对 $(x[2], x[3])$。\n\n任务 1：分析阶段计算\n分析阶段计算近似系数 $a_{1}[k]$ 和细节系数 $d_{1}[k]$。对于基于非重叠块的变换，这等同于将滤波器作用于每对样本。设滤波器系数的索引从 $n=0$ 到 $n=1$。\n\n对于第一对 $(x[0], x[1]) = (\\alpha, \\beta)$，对应于 $k=0$：\n近似系数 $a_{1}[0]$ 使用低通滤波器 $h_0[n]$ 计算得出：\n$$a_{1}[0] = h_{0}[0]x[0] + h_{0}[1]x[1] = \\frac{1}{\\sqrt{2}}\\alpha + \\frac{1}{\\sqrt{2}}\\beta = \\frac{\\alpha+\\beta}{\\sqrt{2}}$$\n细节系数 $d_{1}[0]$ 使用高通滤波器 $h_1[n]$ 计算得出：\n$$d_{1}[0] = h_{1}[0]x[0] + h_{1}[1]x[1] = \\frac{1}{\\sqrt{2}}\\alpha - \\frac{1}{\\sqrt{2}}\\beta = \\frac{\\alpha-\\beta}{\\sqrt{2}}$$\n\n对于第二对 $(x[2], x[3]) = (\\gamma, \\delta)$，对应于 $k=1$：\n近似系数 $a_{1}[1]$ 的计算类似：\n$$a_{1}[1] = h_{0}[0]x[2] + h_{0}[1]x[3] = \\frac{1}{\\sqrt{2}}\\gamma + \\frac{1}{\\sqrt{2}}\\delta = \\frac{\\gamma+\\delta}{\\sqrt{2}}$$\n细节系数 $d_{1}[1]$ 为：\n$$d_{1}[1] = h_{1}[0]x[2] + h_{1}[1]x[3] = \\frac{1}{\\sqrt{2}}\\gamma - \\frac{1}{\\sqrt{2}}\\delta = \\frac{\\gamma-\\delta}{\\sqrt{2}}$$\n\n任务 2：合成阶段推导与重构\n问题要求从第一性原理，特别是逆提升方案，来推导合成关系。首先，我们建立与我们的分析滤波器相对应的正向提升方案。\n\n正向提升方案：\n1.  分裂：信号 $x[n]$ 被分裂为偶数索引样本 $x_e[k] = x[2k]$ 和奇数索引样本 $x_o[k] = x[2k+1]$。\n2.  预测：形成细节信号。为了匹配 $d_1[k] = \\frac{x[2k]-x[2k+1]}{\\sqrt{2}}$，未缩放的细节必须是 $d_1'[k] = x_e[k] - x_o[k] = x[2k] - x[2k+1]$。\n3.  更新：形成近似信号。为了匹配 $a_1[k] = \\frac{x[2k]+x[2k+1]}{\\sqrt{2}}$，未缩放的近似是 $a_1'[k] = \\frac{x[2k]+x[2k+1]}{2}$。我们可以用更新步骤来表示它：$a_1'[k] = x_o[k] + \\frac{1}{2}d_1'[k] = x[2k+1] + \\frac{1}{2}(x[2k]-x[2k+1]) = \\frac{x[2k]+x[2k+1]}{2}$。\n4.  缩放：应用归一化。$d_1[k] = d_1'[k] / \\sqrt{2}$ 且 $a_1[k] = a_1'[k] \\times \\sqrt{2}$。\n\n逆提升方案：\n为了重构信号，我们按相反顺序执行这些步骤。\n1.  逆缩放：我们恢复未缩放的系数 $d_1'[k]$ 和 $a_1'[k]$。\n    $$d_1'[k] = d_1[k] \\times \\sqrt{2}$$\n    $$a_1'[k] = a_1[k] / \\sqrt{2}$$\n2.  逆更新：我们从 $a_1'[k]$ 和 $d_1'[k]$ 恢复奇数索引样本 $x_o[k]$。从更新步骤 $a_1'[k] = x_o[k] + \\frac{1}{2}d_1'[k]$，我们得到：\n    $$\\hat{x}_o[k] = a_1'[k] - \\frac{1}{2}d_1'[k]$$\n3.  逆预测：我们从 $d_1'[k]$ 和现已知的 $\\hat{x}_o[k]$ 恢复偶数索引样本 $x_e[k]$。从预测步骤 $d_1'[k] = x_e[k] - x_o[k]$，我们得到：\n    $$\\hat{x}_e[k] = d_1'[k] + \\hat{x}_o[k]$$\n4.  合并：重构的信号样本是 $\\hat{x}[2k] = \\hat{x}_e[k]$ 和 $\\hat{x}[2k+1] = \\hat{x}_o[k]$。\n\n现在，我们应用这些合成关系来符号化地重构 $\\hat{x}[n]$。\n对于 $k=0$：\n1.  逆缩放：\n    $d_1'[0] = \\left(\\frac{\\alpha-\\beta}{\\sqrt{2}}\\right)\\sqrt{2} = \\alpha-\\beta$\n    $a_1'[0] = \\left(\\frac{\\alpha+\\beta}{\\sqrt{2}}\\right)/\\sqrt{2} = \\frac{\\alpha+\\beta}{2}$\n2.  逆更新 (重构 $\\hat{x}[1]$)：\n    $\\hat{x}[1] = \\hat{x}_o[0] = a_1'[0] - \\frac{1}{2}d_1'[0] = \\frac{\\alpha+\\beta}{2} - \\frac{1}{2}(\\alpha-\\beta) = \\frac{\\alpha+\\beta-\\alpha+\\beta}{2} = \\beta$\n3.  逆预测 (重构 $\\hat{x}[0]$)：\n    $\\hat{x}[0] = \\hat{x}_e[0] = d_1'[0] + \\hat{x}_o[0] = (\\alpha-\\beta) + \\beta = \\alpha$\n\n对于 $k=1$：\n1.  逆缩放：\n    $d_1'[1] = \\left(\\frac{\\gamma-\\delta}{\\sqrt{2}}\\right)\\sqrt{2} = \\gamma-\\delta$\n    $a_1'[1] = \\left(\\frac{\\gamma+\\delta}{\\sqrt{2}}\\right)/\\sqrt{2} = \\frac{\\gamma+\\delta}{2}$\n2.  逆更新 (重构 $\\hat{x}[3]$)：\n    $\\hat{x}[3] = \\hat{x}_o[1] = a_1'[1] - \\frac{1}{2}d_1'[1] = \\frac{\\gamma+\\delta}{2} - \\frac{1}{2}(\\gamma-\\delta) = \\frac{\\gamma+\\delta-\\gamma+\\delta}{2} = \\delta$\n3.  逆预测 (重构 $\\hat{x}[2]$)：\n    $\\hat{x}[2] = \\hat{x}_e[1] = d_1'[1] + \\hat{x}_o[1] = (\\gamma-\\delta) + \\delta = \\gamma$\n\n重构的信号是 $\\hat{x}[n] = \\{\\alpha, \\beta, \\gamma, \\delta\\}$。\n\n任务 3：重构误差能量\n重构误差能量定义为 $E(\\alpha,\\beta,\\gamma,\\delta)=\\sum_{n=0}^{3}\\left(x[n]-\\hat{x}[n]\\right)^{2}$。\n从任务 2 中，我们已经确定重构信号与原始信号相同：\n$\\hat{x}[0]=\\alpha=x[0]$\n$\\hat{x}[1]=\\beta=x[1]$\n$\\hat{x}[2]=\\gamma=x[2]$\n$\\hat{x}[3]=\\delta=x[3]$\n因此，每个采样点的误差为零：$x[n]-\\hat{x}[n]=0$，对于所有 $n \\in \\{0, 1, 2, 3\\}$。\n因此，总误差能量为：\n$$E(\\alpha, \\beta, \\gamma, \\delta) = (x[0]-\\hat{x}[0])^2 + (x[1]-\\hat{x}[1])^2 + (x[2]-\\hat{x}[2])^2 + (x[3]-\\hat{x}[3])^2$$\n$$E(\\alpha, \\beta, \\gamma, \\delta) = (\\alpha-\\alpha)^2 + (\\beta-\\beta)^2 + (\\gamma-\\gamma)^2 + (\\delta-\\delta)^2 = 0^2 + 0^2 + 0^2 + 0^2 = 0$$\n这符号化地证明了 Haar 滤波器组提供了完全重构。误差能量的封闭形式表达式就是 $0$。\n\n任务 4：数值验证\n为了确认符号结果，我们使用具体信号 $x[n] = \\{2, -1, 0, 3\\}$。在这里，$\\alpha=2$，$\\beta=-1$，$\\gamma=0$，$\\delta=3$。\n分析系数：\n$a_{1}[0] = \\frac{2+(-1)}{\\sqrt{2}} = \\frac{1}{\\sqrt{2}}$\n$d_{1}[0] = \\frac{2-(-1)}{\\sqrt{2}} = \\frac{3}{\\sqrt{2}}$\n$a_{1}[1] = \\frac{0+3}{\\sqrt{2}} = \\frac{3}{\\sqrt{2}}$\n$d_{1}[1] = \\frac{0-3}{\\sqrt{2}} = -\\frac{3}{\\sqrt{2}}$\n\n重构：\n$\\hat{x}[0] = \\hat{x}_e[0] = d_1'[0]+\\hat{x}_o[0] = (d_1[0]\\sqrt{2}) + (a_1'[0] - \\frac{1}{2}d_1'[0]) = (\\frac{3}{\\sqrt{2}}\\sqrt{2}) + ((\\frac{1}{\\sqrt{2}}/\\sqrt{2}) - \\frac{1}{2}(\\frac{3}{\\sqrt{2}}\\sqrt{2})) = 3 + (\\frac{1}{2} - \\frac{3}{2}) = 3-1=2$。正确。\n$\\hat{x}[1] = \\hat{x}_o[0] = a_1'[0] - \\frac{1}{2}d_1'[0] = 1-2 = -1$。等等，上面的代数计算有误。\n$\\hat{x}_o[0] = \\frac{1}{2} - \\frac{3}{2} = -1$。因此 $\\hat{x}[1]=-1$。正确。\n$\\hat{x}_e[0] = 3 + (-1) = 2$。因此 $\\hat{x}[0]=2$。正确。\n\n$\\hat{x}[2] = \\hat{x}_e[1] = d_1'[1]+\\hat{x}_o[1] = (d_1[1]\\sqrt{2}) + (a_1'[1] - \\frac{1}{2}d_1'[1]) = (-\\frac{3}{\\sqrt{2}}\\sqrt{2}) + ((\\frac{3}{\\sqrt{2}}/\\sqrt{2}) - \\frac{1}{2}(-\\frac{3}{\\sqrt{2}}\\sqrt{2})) = -3 + (\\frac{3}{2} - \\frac{-3}{2}) = -3+3=0$。正确。\n$\\hat{x}[3] = \\hat{x}_o[1] = \\frac{3}{2} - (-\\frac{3}{2}) = 3$。正确。\n\n重构的信号是 $\\hat{x}[n] = \\{2, -1, 0, 3\\}$，与原始信号相同。数值误差能量 $E$ 为 $0$，确认了符号结果。推导是合理的。最终答案是误差能量 $E(\\alpha,\\beta,\\gamma,\\delta)$ 的符号表达式。", "answer": "$$\n\\boxed{0}\n$$"}, {"introduction": "标准的小波变换对信号频率进行“对数式”划分，但在许多应用中，我们需要更灵活的时频分解。小波包变换（Wavelet Packet Transform）应运而生，它提供了一个包含多种分解方式的“基库”。本练习将指导你实现一个二级小波包分解，并通过编码实践来验证一个核心原理：无论你从包树中选择哪种合法的基（admissible basis），都能精确无误地重构原始信号。这将让你亲身体会到小波包在自适应信号分析中的强大威力与理论完备性。[@problem_id:2916274]", "id": "2916274", "problem": "您的任务是，在双正交框架内，实现并分析一个使用通过提升方案实现的 Haar 基的双层小波包变换 (WPT)。目标是计算直到深度 $2$ 的所有节点系数，并验证当使用匹配的对偶合成时，不同的容许基能够产生完全相同的重构结果。\n\n从以下基本定义和事实开始：\n\n- 提升方案将双正交小波变换实现为一系列可逆的线性步骤。对于一个偶数长度的离散时间信号 $x[n]$，定义奇偶分裂 $e[k] = x[2k]$ 和 $o[k] = x[2k+1]$。\n- 预测算子 $\\mathcal{P}$ 通过 $d[k] = o[k] - e[k]$ 生成细节系数。\n- 更新算子 $\\mathcal{U}$ 通过 $a[k] = e[k] + \\frac{1}{2} d[k]$ 生成粗糙（近似）系数。\n- 合成（对偶）算子可以精确地逆转这些步骤：$e[k] = a[k] - \\frac{1}{2} d[k]$，$o[k] = d[k] + e[k]$，并通过交织恢复原始信号：$x[2k] = e[k]$，$x[2k+1] = o[k]$。\n- 上述分析和合成步骤对构成了通过提升方案实现的双正交 Haar 变换，并实现了完全重构 (PR)。\n- 小波包分解将相同的双通道分裂应用于近似和细节通道，从而生成一个完整的子带二叉树。在深度 $2$ 时，第 $1$ 层的节点是 $A_1$ 和 $D_1$，而第 $2$ 层的四个节点是来自 $A_1$ 的 $AA$、$AD$，以及来自 $D_1$ 的 $DA$、$DD$。\n- 一个容许基是树的叶节点集合，这些叶节点两两不相交，并且它们的并集覆盖了根节点。为了精确重构，每个选定的叶节点都必须通过其路径上匹配的对偶变换进行合成，而未分解叶节点的父节点必须通过逆提升步骤与其兄弟节点结合。\n\n需要完成的任务：\n\n1. 为 Haar 双正交变换实现上述的分析和合成提升步骤。\n2. 实现信号 $x[n]$ 的深度为 $2$ 的小波包分解，以计算所有节点系数 $A_1$、$D_1$、$AA$、$AD$、$DA$、$DD$。\n3. 使用匹配的对偶变换实现依赖于基的重构：\n   - 基 $\\mathcal{B}_1$：统一深度为 $2$ 的叶节点 $\\{AA, AD, DA, DD\\}$。\n   - 基 $\\mathcal{B}_2$：只分裂近似分支 $\\{AA, AD, D_1\\}$。\n   - 基 $\\mathcal{B}_3$：只分裂细节分支 $\\{A_1, DA, DD\\}$。\n   当一个分支被分裂时，重构必须首先将其子节点合成到父节点，然后将第 $1$ 层的节点对合成到根节点。\n4. 对于下面的每个测试用例，计算最大绝对重构误差 $E = \\max_n |x[n] - \\hat{x}[n]|$，并以容差 $\\tau = 10^{-12}$ 验证 $E \\le \\tau$ 是否成立。为每个测试用例报告一个布尔值。\n\n测试套件：\n\n- 使用长度为 $8$ 的信号，这样深度为 $2$ 的分解在无需边界处理的情况下是良定义的。三个信号如下：\n  - $x^{(1)} = [\\, 3.0,\\, 1.0,\\, 0.0,\\, -1.0,\\, 2.0,\\, 4.0,\\, -2.0,\\, 0.5 \\,]$。\n  - $x^{(2)} = [\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0 \\,]$。\n  - $x^{(3)} = [\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0 \\,]$。\n- 将每个信号与每个基 $\\mathcal{B}_1$、$\\mathcal{B}_2$、$\\mathcal{B}_3$ 组合，以获得 $9$ 个测试用例。对于每种情况，输出一个布尔值，指示重构是否通过了容差检查 $E \\le \\tau$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须按以下顺序包含 $9$ 个布尔值：$(x^{(1)}, \\mathcal{B}_1)$、$(x^{(1)}, \\mathcal{B}_2)$、$(x^{(1)}, \\mathcal{B}_3)$、$(x^{(2)}, \\mathcal{B}_1)$、$(x^{(2)}, \\mathcal{B}_2)$、$(x^{(2)}, \\mathcal{B}_3)$、$(x^{(3)}, \\mathcal{B}_1)$、$(x^{(3)}, \\mathcal{B}_2)$、$(x^{(3)}, \\mathcal{B}_3)$。例如，输出格式必须与 $[True,True,True,True,True,True,True,True,True]$ 完全一样，没有多余的空格。", "solution": "我们使用 Haar 基通过提升方案来形式化双层小波包分解和重构，并论证为何使用匹配的对偶变换时，任何容许基都能重构原始信号。\n\n基础算子：\n\n- 奇偶分裂：对于一个偶数长度的离散时间信号 $x[n]$，定义 $e[k] = x[2k]$ 和 $o[k] = x[2k+1]$，其中 $k = 0, 1, \\dots, \\frac{N}{2}-1$。\n- 预测（分析）：细节为 $d[k] = o[k] - e[k]$。这对应于用偶数样本预测奇数样本，并存储预测误差。\n- 更新（分析）：近似为 $a[k] = e[k] + \\frac{1}{2} d[k]$。这利用细节来更新粗尺度，以保持低频矩。\n- 合成（对偶）：逆运算是精确的，通过 $e[k] = a[k] - \\frac{1}{2} d[k]$，然后 $o[k] = d[k] + e[k]$，交织后即可得到 $x[2k] = e[k]$，$x[2k+1] = o[k]$。\n\n分析映射 $(x \\mapsto (a, d))$ 是一个可逆线性算子，其逆运算如上所示；因此，这构成了一个具有完全重构 (PR) 特性的双正交对。通过直接代入，可以立即验证完全重构 (PR) 属性：\n$$\ne[k] = \\Big(e[k] + \\tfrac{1}{2} d[k]\\Big) - \\tfrac{1}{2} d[k] = e[k], \\quad\no[k] = d[k] + e[k] = (o[k] - e[k]) + e[k] = o[k].\n$$\n因此，交织可以精确地再现 $x[n]$。\n\n小波包树：\n\n- $x[n]$ 的第 $1$ 层分解如上所述从 $(e^{(0)}, o^{(0)})$ 计算得出 $(A_1, D_1) = (a^{(1)}, d^{(1)})$。\n- 第 $2$ 层分解通过将相同的提升步骤应用于 $A_1$ 和 $D_1$ 来进行：\n  - 从 $A_1$ 我们通过奇偶分裂和相同的预测-更新对获得 $(AA, AD)$。\n  - 类似地，从 $D_1$ 我们获得 $(DA, DD)$。\n\n令 $\\mathcal{L}$ 表示分析提升算子，$\\mathcal{L}^{-1}$ 表示其合成对偶。在第 $1$ 层，我们将 $\\mathcal{L}$ 应用于 $x$ 以获得 $(A_1, D_1)$。在第 $2$ 层，$\\mathcal{L}$ 被独立地应用于 $A_1$ 和 $D_1$，从而产生四个第二代子节点 $(AA, AD, DA, DD)$。\n\n容许基和重构：\n\n- 一个容许基是一组叶节点，它们对树进行划分，使得根节点的每个原始自由度都被精确地表示一次。深度为 $2$ 的示例如下：\n  - $\\mathcal{B}_1 = \\{ AA, AD, DA, DD \\}$ (一致细化)。\n  - $\\mathcal{B}_2 = \\{ AA, AD, D_1 \\}$ (仅细化近似分支)。\n  - $\\mathcal{B}_3 = \\{ A_1, DA, DD \\}$ (仅细化细节分支)。\n- 使用匹配对偶的重构，会沿着从每个选定叶节点到根节点的路径复合逆提升算子：\n  - 对于 $\\mathcal{B}_1$，合成 $A_1 = \\mathcal{L}^{-1}(AA, AD)$ 和 $D_1 = \\mathcal{L}^{-1}(DA, DD)$，然后 $x = \\mathcal{L}^{-1}(A_1, D_1)$。\n  - 对于 $\\mathcal{B}_2$，合成 $A_1 = \\mathcal{L}^{-1}(AA, AD)$ 并使用原始的 $D_1$，然后 $x = \\mathcal{L}^{-1}(A_1, D_1)$。\n  - 对于 $\\mathcal{B}_3$，合成 $D_1 = \\mathcal{L}^{-1}(DA, DD)$ 并使用原始的 $A_1$，然后 $x = \\mathcal{L}^{-1}(A_1, D_1)$。\n  \n因为每个 $\\mathcal{L}$ 都是可逆的，具有双边逆 $\\mathcal{L}^{-1}$，并且（由于奇偶分裂）不同的分支作用于不相交的索引集，所以线性和块对角结构意味着，只要每个自由度都只被包含一次，沿着选定叶节点路径的任何逆算子复合都会恢复出相同的向量 $x$。更形式化地说，如果我们用 $T$ 表示将 $x$ 映射到 $(AA, AD, DA, DD)$ 的完整第 $2$ 层分析算子，用 $T^{-1}$ 表示其块逆（它首先重构 $(A_1, D_1)$ 然后是 $x$），那么容许基就对应于将 $T$ 剪枝成块三角形式，其逆是通过在细化分支上部分应用 $T^{-1}$ 并直接传递未细化的父节点来获得的。由于所有路径都使用匹配的对偶，净算子是 $\\mathbb{R}^N$ 上的恒等算子。\n\n算法设计：\n\n- 使用显式公式 $d = o - e$，$a = e + \\frac{1}{2}d$ 实现分析提升步骤。\n- 使用 $e = a - \\frac{1}{2}d$，$o = d + e$ 及交织实现合成提升步骤。\n- 通过将分析应用于根节点，然后应用于其两个子节点，来实现深度为 $2$ 的 WPT。\n- 通过沿必要的分支自下而上应用合成，来实现针对选定基的重构。\n- 对于每个测试用例，计算最大绝对误差 $E = \\max_n |x[n] - \\hat{x}[n]|$，并以 $\\tau = 10^{-12}$ 检查 $E \\le \\tau$ 是否成立。\n\n测试套件和预期结果：\n\n- 长度为 8 的信号：$x^{(1)} = [\\, 3.0,\\, 1.0,\\, 0.0,\\, -1.0,\\, 2.0,\\, 4.0,\\, -2.0,\\, 0.5 \\,]$，$x^{(2)} = [\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0,\\, 5.0 \\,]$，$x^{(3)} = [\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0,\\, 1.0,\\, -1.0 \\,]$。\n- 基 $\\mathcal{B}_1$、$\\mathcal{B}_2$、$\\mathcal{B}_3$ 如上定义。\n- 由于合成使用的是分析的精确对偶算子，PR 保证了在精确算术中重构误差完全为零，并且在浮点容差范围内数值上为零。因此，对于 $\\tau = 10^{-12}$，所有 $9$ 个布尔值都应为 $True$。\n\n最终答案中指定的程序实现了这些步骤，并按要求顺序打印出包含 $9$ 个布尔值的单行列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analysis_lifting_haar_biorth(x: np.ndarray):\n    \"\"\"\n    One-level biorthogonal Haar analysis via lifting:\n    - Split into even and odd\n    - Predict: d = o - e\n    - Update:  a = e + 0.5 * d\n    Returns (a, d)\n    \"\"\"\n    e = x[0::2]\n    o = x[1::2]\n    d = o - e\n    a = e + 0.5 * d\n    return a, d\n\ndef synthesis_lifting_haar_biorth(a: np.ndarray, d: np.ndarray):\n    \"\"\"\n    One-level biorthogonal Haar synthesis via lifting:\n    - Invert update: e = a - 0.5 * d\n    - Invert predict: o = d + e\n    - Interleave to reconstruct x\n    Returns reconstructed x\n    \"\"\"\n    e = a - 0.5 * d\n    o = d + e\n    x = np.empty(e.size + o.size, dtype=float)\n    x[0::2] = e\n    x[1::2] = o\n    return x\n\ndef wp2_forward(x: np.ndarray):\n    \"\"\"\n    Two-level wavelet packet decomposition using the above lifting steps.\n    Returns a dictionary with A1, D1, AA, AD, DA, DD.\n    \"\"\"\n    a1, d1 = analysis_lifting_haar_biorth(x)\n    aa, ad = analysis_lifting_haar_biorth(a1)\n    da, dd = analysis_lifting_haar_biorth(d1)\n    return {\n        'A1': a1,\n        'D1': d1,\n        'AA': aa,\n        'AD': ad,\n        'DA': da,\n        'DD': dd\n    }\n\ndef reconstruct_from_basis(coeffs: dict, basis: str):\n    \"\"\"\n    Reconstruct the signal from depth-2 wavelet packet coefficients using different admissible bases:\n    - basis == 'B1': leaves {AA, AD, DA, DD}\n    - basis == 'B2': leaves {AA, AD, D1}\n    - basis == 'B3': leaves {A1, DA, DD}\n    Returns reconstructed signal x_hat.\n    \"\"\"\n    if basis == 'B1':\n        # First synthesize A1 and D1 from their children\n        a1_hat = synthesis_lifting_haar_biorth(coeffs['AA'], coeffs['AD'])\n        d1_hat = synthesis_lifting_haar_biorth(coeffs['DA'], coeffs['DD'])\n        # Then synthesize full signal\n        x_hat = synthesis_lifting_haar_biorth(a1_hat, d1_hat)\n        return x_hat\n    elif basis == 'B2':\n        # Synthesize A1 from AA, AD; use original D1\n        a1_hat = synthesis_lifting_haar_biorth(coeffs['AA'], coeffs['AD'])\n        d1 = coeffs['D1']\n        x_hat = synthesis_lifting_haar_biorth(a1_hat, d1)\n        return x_hat\n    elif basis == 'B3':\n        # Synthesize D1 from DA, DD; use original A1\n        d1_hat = synthesis_lifting_haar_biorth(coeffs['DA'], coeffs['DD'])\n        a1 = coeffs['A1']\n        x_hat = synthesis_lifting_haar_biorth(a1, d1_hat)\n        return x_hat\n    else:\n        raise ValueError(\"Unknown basis identifier\")\n\ndef max_abs_err(x: np.ndarray, y: np.ndarray) -> float:\n    return float(np.max(np.abs(x - y)))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Signals of length 8\n    x1 = np.array([3.0, 1.0, 0.0, -1.0, 2.0, 4.0, -2.0, 0.5], dtype=float)\n    x2 = np.array([5.0]*8, dtype=float)\n    x3 = np.array([1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, -1.0], dtype=float)\n\n    signals = [x1, x2, x3]\n    bases = ['B1', 'B2', 'B3']  # B1: {AA,AD,DA,DD}, B2: {AA,AD,D1}, B3: {A1,DA,DD}\n    tol = 1e-12\n\n    test_cases = []\n    for sig in signals:\n        for b in bases:\n            test_cases.append((sig, b))\n\n    results = []\n    for x, basis in test_cases:\n        coeffs = wp2_forward(x)\n        x_hat = reconstruct_from_basis(coeffs, basis)\n        err = max_abs_err(x, x_hat)\n        results.append(err <= tol)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "从理论走向应用，本练习将带你实现一个在无损压缩领域（如JPEG 2000标准）中至关重要的变换。我们将使用提升方案来实现经典的 Le Gall $5/3$ 双正交小波，并特别关注其整数可逆版本。通过精心处理舍入和边界效应，你将构建一个能够将整数信号精确映射到整数系数的变换，并验证其无损重构的能力。这个实践是理解提升方案如何在实际工程中解决浮点运算局限性、实现真正无损数据处理的关键一步。[@problem_id:2916322]", "id": "2916322", "problem": "设计并实现一个完整、可运行的程序，该程序使用提升方案（lifting scheme）和明确指定的舍入规则，来计算并求逆对应于 Le Gall $5/3$ 双正交小波的整数可逆变换。该程序必须在一组短整数信号上进行数值验证，以确认重建是无损的，并为每个案例报告一个布尔值结果。\n\n从以下基本前提开始：\n- 提升方案将双通道完全重构滤波器组（two-channel perfect reconstruction filter banks）分解为一系列作用于偶数和奇数索引样本的预测和更新步骤。给定一个长度为 $N$ 的输入整数序列 $x$，对其所有有效索引，定义其偶数索引部分 $s$ 和奇数索引部分 $o$ 为 $s[n] = x[2n]$ 和 $o[n] = x[2n+1]$。已知 Le Gall $5/3$ 双正交小波允许一种提升分解，其预测算子与 $-1/2$ 成比例，更新算子与 $1/4$ 成比例。\n- 整数到整数变换（Integer-to-integer transforms）的构建方法是：用整数组合替换实值线性组合，并随之进行指定的舍入操作。这样，在结合相同的边界处理时，正向和逆向步骤都能将整数精确地映射到整数，并最终合成为单位变换。\n\n任务与规范：\n1. 在 $(s,o)$ 上使用两个提升步骤来实现正向变换：\n   - 预测步骤（奇数更新）：使用 $s[n]$ 的邻近值从 $o[n]$ 计算细节样本 $d[n]$，这对应于一个系数为 $-1/2$ 的线性预测，但要通过应用以下舍入规则来确保输出为整数：对于除以 $2$ 的运算，使用平均值的向下取整。具体来说，当计算两个整数 $a$ 和 $b$ 的平均值时, 将其解释为 $\\left\\lfloor \\dfrac{a + b}{2} \\right\\rfloor$。\n   - 更新步骤（偶数更新）：使用邻近的细节样本 $d$ 来优化 $s[n]$，这对应于一个为 $1/4$ 的更新系数，并通过带偏移的向下取整实现四舍五入。具体来说，对于两个整数 $u$ 和 $v$ 的和, 将 $\\dfrac{u+v}{4}$ 解释为 $\\left\\lfloor \\dfrac{u + v + 2}{4} \\right\\rfloor$。\n2. 边界处理：在边界处使用对称延拓（symmetric extension）来处理缺失的邻近值。如果一个邻近值的索引超出了有效范围，则用最近的有效索引替换它。对于细节数组 $d$ 为空的特殊情况（当 $N = 1$ 时发生），将更新贡献定义为 $0$。\n3. 实现逆变换：通过代数上逆转正向提升步骤来实现，使用相同的舍入约定和边界处理方法，并按相反的应用顺序进行。\n4. 验证：对每个测试用例，计算正向变换 $(s,d)$，然后进行逆变换以重构 $\\hat{x}$，并逐元素检查是否完全相等 $\\hat{x} = x$，以生成一个布尔结果。\n5. 测试套件，以覆盖一般情况和边界情况。使用以下输入信号，每个信号都表示为 Python 风格的列表，但为了数学上的清晰，每个整数在此都用 LaTeX 显示：\n   - 案例 $1$（混合符号，奇数长度）：$\\left[\\,7,-3,2,9,-8,1,0\\,\\right]$。\n   - 案例 $2$（短，偶数长度）：$\\left[\\,-3,7\\,\\right]$。\n   - 案例 $3$（单元素）：$\\left[\\,42\\,\\right]$。\n   - 案例 $4$（常数）：$\\left[\\,5,5,5,5,5\\,\\right]$。\n   - 案例 $5$（交替大数值）：$\\left[\\,1000,-1000,1000,-1000,999,-999\\,\\right]$。\n   - 案例 $6$（零和负数，奇数长度）：$\\left[\\,0,-1,0,-1,0\\,\\right]$。\n6. 输出格式：你的程序应产生单行输出，其中包含用逗号分隔的布尔值列表，并用方括号括起来。例如，三个案例的输出应如下所示：$\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True}\\right]$。\n\n你的实现必须是自包含的，使用与指定的基于向下取整的舍入规则一致的整数算术，并使用所述的对称延拓边界规则。不涉及物理单位或角度单位。唯一允许的输出是针对指定测试套件的所需单行布尔值列表，且顺序与提供的一致。", "solution": "在尝试给出解决方案之前，对问题进行验证。\n\n**步骤1：提取已知条件**\n- **变换**：用于 Le Gall $5/3$ 双正交小波的整数可逆变换。\n- **方法**：包含预测步骤和更新步骤的提升方案。\n- **输入信号**：长度为 $N$ 的整数序列 $x$。\n- **信号分解**：$s[n] = x[2n]$（偶数索引样本），$o[n] = x[2n+1]$（奇数索引样本）。\n- **正向变换步骤**：\n  1. **预测（奇数更新）**：从 $o[n]$ 及其在 $s$ 中的邻近值计算细节系数 $d[n]$。该操作对应于一个实值预测子，其系数为 $-\\frac{1}{2}$。两个整数 $a$ 和 $b$ 的平均值舍入规则指定为 $\\left\\lfloor \\frac{a + b}{2} \\right\\rfloor$。\n  2. **更新（偶数更新）**：通过其邻近的细节系数 $d$ 来优化 $s[n]$，从而计算近似系数 $a[n]$。该操作对应于一个实值更新，其系数为 $\\frac{1}{4}$。项 $\\frac{u+v}{4}$ 的舍入规则指定为 $\\left\\lfloor \\frac{u + v + 2}{4} \\right\\rfloor$。\n- **边界处理**：对称延拓，解释为“将越界的邻近值索引替换为最近的有效索引”。对于细节数组 $d$ 为空（当 $N=1$ 时）的特殊情况，定义更新贡献为 $0$。\n- **逆变换**：以相反顺序代数地逆转正向提升步骤，使用相同的舍入和边界处理规则。\n- **验证**：对于每个测试用例信号 $x$，计算正向变换得到 $(a, d)$，然后计算逆变换得到 $\\hat{x}$，并验证 $\\hat{x} = x$ 是否成立。\n- **测试用例**：\n  1. $[7, -3, 2, 9, -8, 1, 0]$\n  2. $[-3, 7]$\n  3. $[42]$\n  4. $[5, 5, 5, 5, 5]$\n  5. $[1000, -1000, 1000, -1000, 999, -999]$\n  6. $[0, -1, 0, -1, 0]$\n- **输出格式**：一个单行，包含一个用方括号括起来的、逗号分隔的测试用例布尔结果列表。\n\n**步骤2：使用提取的已知条件进行验证**\n对问题的有效性进行评估：\n- **科学上成立**：该问题建立在小波理论和提升方案的成熟数学原理之上。Le Gall $5/3$ 小波是双正交小波的一个标准示例，通过提升方案实现是文档详实的技术。使用指定舍入的整数到整数变换是实现无损信号处理的有效方法。\n- **良构的**：该问题被精确地规定。它提供了所有必要的组成部分：输入数据结构、变换方程、精确的整数舍入规则以及边界处理条件。这确保了可以构建一个唯一且可验证的解决方案。\n- **客观的**：该问题以精确、客观的语言陈述，没有歧义或主观论断。\n\n**步骤3：结论与行动**\n问题是**有效的**。它是一个定义明确且自包含的计算信号处理练习。现在将推导解决方案。\n\n### 解决方案推导\n\n通过提升方案实现 Le Gall $5/3$ 整数可逆小波变换，需要仔细构建正向和逆向变换步骤，并严格遵守指定的舍入和边界规则。\n\n**1. 正向变换**\n\n正向变换将一个长度为 $N$ 的输入整数信号 $x$ 映射为一对整数序列：近似系数 $a$ 和细节系数 $d$。\n\n**a. 分裂**\n输入信号 $x$ 首先被分裂为其偶数索引元素 $s$ 和奇数索引元素 $o$：\n$$ s[n] = x[2n], \\quad n \\in [0, \\lceil N/2 \\rceil - 1] $$\n$$ o[n] = x[2n+1], \\quad n \\in [0, \\lfloor N/2 \\rfloor - 1] $$\n$s$ 和 $o$ 的长度分别为 $N_s = \\lceil N/2 \\rceil$ 和 $N_o = \\lfloor N/2 \\rfloor$。\n\n**b. 预测步骤**\n更新奇数样本 $o$ 以产生细节系数 $d$。实值提升步骤为 $d[n] = o[n] - \\frac{1}{2}(s[n] + s[n+1])$。指定的整数实现为：\n$$ d[n] = o[n] - \\left\\lfloor \\frac{s_{left} + s_{right}}{2} \\right\\rfloor $$\n为 $n$ 从 $0$到 $N_o-1$ 的每个值计算此式。邻近值 $s_{left}$ 和 $s_{right}$ 对应于 $s[n]$ 和 $s[n+1]$。需要进行边界处理。\n- 对于 $o[n]$，左邻近值是 $s[n]$，它总是在界内，因为 $n \\le N_o-1 < N_s$。\n- 右邻近值是 $s[n+1]$。如果 $n+1 \\ge N_s$，则索引越界。最近的有效索引是 $N_s-1$。\n因此，邻近值为 $s_{left} = s[n]$ 和 $s_{right} = s[\\min(n+1, N_s-1)]$。\n\n**c. 更新步骤**\n使用新计算的细节系数 $d$ 更新偶数样本 $s$ 以产生近似系数 $a$。实值步骤为 $a[n] = s[n] + \\frac{1}{4}(d[n-1] + d[n])$。指定的整数实现为：\n$$ a[n] = s[n] + \\left\\lfloor \\frac{d_{left} + d_{right} + 2}{4} \\right\\rfloor $$\n为 $n$ 从 $0$ 到 $N_s-1$ 的每个值计算此式。\n- 特殊情况：如果 $N=1$，则 $N_o=0$ 且细节序列 $d$ 为空。问题指定更新为 $0$，所以 $a[0] = s[0]$。\n- 一般情况 ($N_o > 0$)：对于 $s[n]$，邻近值是 $d[n-1]$ 和 $d[n]$。应用边界处理：\n  - 左邻近值 $d_{left}$ 位于索引 $n-1$ 处。如果 $n-1 < 0$，最近的有效索引是 $0$。所以，$d_{left} = d[\\max(0, n-1)]$。\n  - 右邻近值 $d_{right}$ 位于索引 $n$ 处。如果 $n \\ge N_o$，最近的有效索引是 $N_o-1$。所以，$d_{right} = d[\\min(n, N_o-1)]$。\n\n**2. 逆变换**\n\n逆变换通过逆转正向步骤，从系数 $(a, d)$ 重构原始信号 $\\hat{x}$。\n\n**a. 逆更新步骤**\n首先，我们逆转更新步骤以恢复原始的偶数样本，我们将其表示为 $s_{rec}$。这通过减法实现：\n$$ s_{rec}[n] = a[n] - \\left\\lfloor \\frac{d_{left} + d_{right} + 2}{4} \\right\\rfloor $$\n对 $d_{left}$ 和 $d_{right}$ 的边界处理与正向更新步骤中的相同。此操作对 $n$ 从 $0$到 $N_s-1$ 执行。\n\n**b. 逆预测步骤**\n接下来，我们逆转预测步骤以恢复原始的奇数样本 $o_{rec}$。这通过加法实现：\n$$ o_{rec}[n] = d[n] + \\left\\lfloor \\frac{s_{rec, left} + s_{rec, right}}{2} \\right\\rfloor $$\n此操作使用刚恢复的偶数样本 $s_{rec}$。对来自 $s_{rec}$ 的邻近值的边界处理与正向预测步骤中的相同。此操作对 $n$ 从 $0$ 到 $N_o-1$ 执行。\n\n**c. 合并**\n最后，通过交错重构的偶数和奇数样本来形成重构信号 $\\hat{x}$：\n$$ \\hat{x}[2n] = s_{rec}[n] $$\n$$ \\hat{x}[2n+1] = o_{rec}[n] $$\n\n**3. 验证**\n通过逐元素检查原始信号 $x$ 和重构信号 $\\hat{x}$ 是否相等来验证完全重构属性。对于每个测试用例，结果是一个布尔值，指示 $x = \\hat{x}$ 是否成立。由于整数算术被设计为完全可逆的，此检查可验证实现的正确性。所有测试用例都预期产生 `True` 结果。", "answer": "```python\nimport numpy as np\n\ndef forward_lg53(x_in):\n    \"\"\"\n    Computes the forward Le Gall 5/3 integer wavelet transform using the lifting scheme.\n    \"\"\"\n    x = np.array(x_in, dtype=np.int64)\n    N = len(x)\n\n    if N == 0:\n        return np.array([], dtype=np.int64), np.array([], dtype=np.int64)\n\n    # Split the signal into even and odd samples\n    s = x[0::2]\n    o = x[1::2]\n    Ns = len(s)\n    No = len(o)\n\n    # 1. Predict step (odd samples update)\n    # d[n] = o[n] - floor((s[n] + s[n+1]) / 2)\n    d = np.zeros(No, dtype=np.int64)\n    for n in range(No):\n        s_left = s[n]\n        # Boundary handling for the right neighbor\n        s_right_idx = min(n + 1, Ns - 1)\n        s_right = s[s_right_idx]\n        d[n] = o[n] - (s_left + s_right) // 2\n\n    # 2. Update step (even samples update)\n    # a[n] = s[n] + floor((d[n-1] + d[n] + 2) / 4)\n    a = np.zeros(Ns, dtype=np.int64)\n    if No == 0:  # This handles the N=1 case where d is empty\n        a = s.copy()\n    else:\n        for n in range(Ns):\n            # Boundary handling for detail coefficient neighbors\n            d_left_idx = max(0, n - 1)\n            d_right_idx = min(n, No - 1)\n            d_left = d[d_left_idx]\n            d_right = d[d_right_idx]\n            a[n] = s[n] + (d_left + d_right + 2) // 4\n            \n    return a, d\n\ndef inverse_lg53(a, d):\n    \"\"\"\n    Computes the inverse Le Gall 5/3 integer wavelet transform.\n    \"\"\"\n    a = np.array(a, dtype=np.int64)\n    d = np.array(d, dtype=np.int64)\n    Ns = len(a)\n    No = len(d)\n    N = Ns + No\n\n    if N == 0:\n        return np.array([], dtype=np.int64)\n\n    # 1. Inverse Update step (recover s)\n    # s_rec[n] = a[n] - floor((d[n-1] + d[n] + 2) / 4)\n    s_rec = np.zeros(Ns, dtype=np.int64)\n    if No == 0: # Handles N=1 case\n        s_rec = a.copy()\n    else:\n        for n in range(Ns):\n            d_left_idx = max(0, n - 1)\n            d_right_idx = min(n, No - 1)\n            d_left = d[d_left_idx]\n            d_right = d[d_right_idx]\n            s_rec[n] = a[n] - (d_left + d_right + 2) // 4\n\n    # 2. Inverse Predict step (recover o)\n    # o_rec[n] = d[n] + floor((s_rec[n] + s_rec[n+1]) / 2)\n    o_rec = np.zeros(No, dtype=np.int64)\n    for n in range(No):\n        s_left = s_rec[n]\n        s_right_idx = min(n + 1, Ns - 1)\n        s_right = s_rec[s_right_idx]\n        o_rec[n] = d[n] + (s_left + s_right) // 2\n\n    # Merge the recovered even and odd samples\n    x_rec = np.zeros(N, dtype=np.int64)\n    x_rec[0::2] = s_rec\n    x_rec[1::2] = o_rec\n\n    return x_rec\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify perfect reconstruction.\n    \"\"\"\n    test_cases = [\n        # Case 1: mixed signs, odd length\n        [7, -3, 2, 9, -8, 1, 0],\n        # Case 2: short, even length\n        [-3, 7],\n        # Case 3: singleton\n        [42],\n        # Case 4: constant\n        [5, 5, 5, 5, 5],\n        # Case 5: alternating large magnitudes\n        [1000, -1000, 1000, -1000, 999, -999],\n        # Case 6: zeros and negatives, odd length\n        [0, -1, 0, -1, 0],\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert to numpy array with a safe integer type\n        x_original = np.array(case, dtype=np.int64)\n\n        # Perform forward transform\n        approximation_coeffs, detail_coeffs = forward_lg53(x_original)\n\n        # Perform inverse transform\n        x_reconstructed = inverse_lg53(approximation_coeffs, detail_coeffs)\n\n        # Verify perfect reconstruction\n        is_perfect = np.array_equal(x_original, x_reconstructed)\n        results.append(is_perfect)\n\n    # Format the output as specified\n    # The boolean values are capitalized in Python, so they are converted to lowercase\n    # for full compliance with the example format \"[True,False,True]\".\n    # However, Python's str(True) is 'True', which is standard. Example format\n    # is illustrative. We will use standard string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}