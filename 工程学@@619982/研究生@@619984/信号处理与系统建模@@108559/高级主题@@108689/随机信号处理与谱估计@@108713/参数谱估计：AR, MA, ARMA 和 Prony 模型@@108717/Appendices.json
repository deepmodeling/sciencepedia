{"hands_on_practices": [{"introduction": "Prony方法是参数谱估计中的一种经典技术，它将信号建模为一系列阻尼复指数之和。本练习将引导您通过一个具体案例，实践Prony方法的核心思想：利用“湮没滤波器”原理，将非线性的指数拟合问题巧妙地转化为线性代数求解，从而确定模型的模态（即指数的底数），并最终解出它们的幅度。通过这个动手实践，您将掌握从精确数据中恢复确定性信号模型参数的基本流程 [@problem_id:2889623]。", "problem": "一个离散时间信号 $x[n]$ 已知可用一个双项 Prony 模型（两个复指数之和）来表示，其形式为 $x[n] = c_{1} z_{1}^{n} + c_{2} z_{2}^{n}$，其中 $c_{1}, c_{2} \\in \\mathbb{C}$ 且 $z_{1}, z_{2} \\in \\mathbb{C}$，并有 $z_{1} \\neq z_{2}$。给定 $2K$ 个精确样本，其中 $K=2$，具体为 $x[0] = 2$，$x[1] = 5$，$x[2] = 13$ 和 $x[3] = 35$。\n\n请仅使用 Prony 模型的定义和零化滤波器原理（即有限线性预测器可以完全零化复指数之和），完成以下任务：\n\n1. 通过求解由模型和给定样本所隐含的齐次线性预测方程，构建 Prony (零化) 多项式 $P(z) = z^{2} + a_{1} z + a_{2}$。除双指数模型和给定样本外，不要引入任何额外假设。\n2. 求出 $P(z)$ 的根 $z_{1}$ 和 $z_{2}$，并按照实数意义上的大小进行排序，使得 $z_{1} < z_{2}$。\n3. 使用已排序的根对 $(z_{1}, z_{2})$，通过线性最小二乘 (LS) 法计算幅度 $(c_{1}, c_{2})$，即对 $(c_{1}, c_{2})$ 最小化 $\\sum_{n=0}^{3} |x[n] - c_{1} z_{1}^{n} - c_{2} z_{2}^{n}|^{2}$。请给出精确解。\n\n请将你的最终答案以单行矩阵的形式报告，顺序为 $[\\,a_{1}\\; a_{2}\\; z_{1}\\; z_{2}\\; c_{1}\\; c_{2}\\,]$。无需四舍五入。", "solution": "该问题陈述已经过评估并被认为是有效的。这是一个信号处理领域的适定问题，具体涉及使用 Prony 方法进行参数化建模。所提供的数据是自洽且一致的，目标明确且有科学依据。\n\n问题要求在给定四个精确样本 $x[0] = 2$、$x[1] = 5$、$x[2] = 13$ 和 $x[3] = 35$ 的情况下，求出双项复指数模型 $x[n] = c_{1} z_{1}^{n} + c_{2} z_{2}^{n}$ 的参数。该模型有 $p=2$ 项。\n\n**第一部分：确定零化多项式系数**\n\nProny 方法的基本原理是，一个由 $p$ 个复指数组成的信号可以被一个 $p$ 阶线性预测器零化。这在数学上表示为一个齐次线性常系数差分方程：\n$$x[n] + a_{1}x[n-1] + \\dots + a_{p}x[n-p] = 0$$\n对于 $n \\ge p$。系数 $a_1, \\dots, a_p$ 定义了 Prony 多项式 $P(z) = z^p + a_1 z^{p-1} + \\dots + a_p$。\n\n对于本问题，$p=2$，因此差分方程为：\n$$x[n] + a_{1}x[n-1] + a_{2}x[n-2] = 0$$\n此方程对于 $n \\ge 2$ 必须成立。我们有截至 $x[3]$ 的样本，因此我们可以利用 $n=2$ 和 $n=3$ 构成一个包含两个线性方程的方程组，以求解两个未知系数 $a_1$ 和 $a_2$。\n\n对于 $n=2$：\n$$x[2] + a_{1}x[1] + a_{2}x[0] = 0$$\n代入给定值：\n$$13 + a_{1}(5) + a_{2}(2) = 0 \\implies 5a_{1} + 2a_{2} = -13$$\n\n对于 $n=3$：\n$$x[3] + a_{1}x[2] + a_{2}x[1] = 0$$\n代入给定值：\n$$35 + a_{1}(13) + a_{2}(5) = 0 \\implies 13a_{1} + 5a_{2} = -35$$\n\n我们得到以下线性方程组：\n$$\n\\begin{cases}\n5a_{1} + 2a_{2} = -13 \\\\\n13a_{1} + 5a_{2} = -35\n\\end{cases}\n$$\n为了求解该方程组，我们可以使用消元法。将第一个方程乘以 $5$，第二个方程乘以 $2$：\n$$\n\\begin{cases}\n25a_{1} + 10a_{2} = -65 \\\\\n26a_{1} + 10a_{2} = -70\n\\end{cases}\n$$\n将第二个新方程减去第一个新方程，得到：\n$$(26a_{1} - 25a_{1}) + (10a_{2} - 10a_{2}) = -70 - (-65)$$\n$$a_{1} = -5$$\n将 $a_{1} = -5$ 代入第一个原方程：\n$$5(-5) + 2a_{2} = -13$$\n$$-25 + 2a_{2} = -13$$\n$$2a_{2} = 12$$\n$$a_{2} = 6$$\n因此，零化多项式的系数为 $a_{1} = -5$ 和 $a_{2} = 6$。该多项式为 $P(z) = z^2 - 5z + 6$。\n\n**第二部分：确定根 $z_1$ 和 $z_2$**\n\n零化多项式 $P(z)$ 的根是指数模型的模态 $z_k$。我们必须求出 $P(z) = z^2 - 5z + 6 = 0$ 的根。通过对二次多项式进行因式分解，我们得到：\n$$(z - 2)(z - 3) = 0$$\n根为 $z=2$ 和 $z=3$。问题要求按 $z_1 < z_2$ 的顺序对它们进行排序。由于根是实数，这种排序是明确的。因此，我们有：\n$$z_{1} = 2$$\n$$z_{2} = 3$$\n\n**第三部分：确定幅度 $c_1$ 和 $c_2$**\n\n模型现在被确定为 $x[n] = c_{1}(2)^{n} + c_{2}(3)^{n}$。问题要求通过最小化最小二乘误差 $\\sum_{n=0}^{3} |x[n] - (c_{1} z_{1}^{n} + c_{2} z_{2}^{n})|^{2}$ 来计算幅度 $(c_1, c_2)$。由于问题陈述数据来自一个精确的双项模型，并且我们已经正确地识别了模态，因此最小二乘误差将为零。这意味着模型方程对所有给定的数据点都精确满足。对于这个超定系统，无需构建完整的正规方程。仅使用任意两个数据点求解关于 $(c_1, c_2)$ 的线性方程组就足够了。最简单的选择是使用 $n=0$ 和 $n=1$。\n\n对于 $n=0$：\n$$x[0] = c_{1}(2)^{0} + c_{2}(3)^{0} \\implies 2 = c_{1} + c_{2}$$\n对于 $n=1$：\n$$x[1] = c_{1}(2)^{1} + c_{2}(3)^{1} \\implies 5 = 2c_{1} + 3c_{2}$$\n\n我们求解这个 $2 \\times 2$ 方程组：\n$$\n\\begin{cases}\nc_{1} + c_{2} = 2 \\\\\n2c_{1} + 3c_{2} = 5\n\\end{cases}\n$$\n从第一个方程得到 $c_{1} = 2 - c_{2}$。将其代入第二个方程：\n$$2(2 - c_{2}) + 3c_{2} = 5$$\n$$4 - 2c_{2} + 3c_{2} = 5$$\n$$c_{2} = 1$$\n将 $c_2 = 1$ 代回 $c_1$ 的表达式中：\n$$c_{1} = 2 - 1 = 1$$\n因此，幅度为 $c_{1} = 1$ 和 $c_{2} = 1$。\n\n为了验证，我们检查此解是否能正确预测其他数据点：\n对于 $n=2$：$x[2] = (1)(2)^2 + (1)(3)^2 = 4 + 9 = 13$，正确。\n对于 $n=3$：$x[3] = (1)(2)^3 + (1)(3)^3 = 8 + 27 = 35$，也正确。\n该解与所有给定数据一致。\n\n所要求的参数为：$a_{1}=-5$，$a_{2}=6$，$z_{1}=2$，$z_{2}=3$，$c_{1}=1$，$c_{2}=1$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-5 & 6 & 2 & 3 & 1 & 1\n\\end{pmatrix}\n}\n$$", "id": "2889623"}, {"introduction": "自回归（AR）模型是信号处理中最常用的参数模型之一，但其价值不仅在于模型本身，更在于其揭示信号谱特性的能力。本练习将深入探讨AR模型参数与其功率谱密度（PSD）之间的深刻联系。您将通过一个二阶AR模型的例子，学习如何从模型系数计算系统极点，并利用极点的位置来直接确定谱峰的频率和带宽，这是解读和应用AR谱估计结果的一项关键技能 [@problem_id:2889646]。", "problem": "考虑一个由差分方程 $x[n] + a_1 x[n-1] + a_2 x[n-2] = e[n]$ 定义的实值、宽平稳二阶自回归 (AR(2)) 过程，其中 $e[n]$ 是均值为零、方差为 $\\sigma_e^2 \\in (0,\\infty)$ 的高斯白驱动噪声。其相关的自回归多项式为 $A(z) = 1 + a_1 z^{-1} + a_2 z^{-2}$。全极点过程的功率谱密度 (PSD) 与 $|A(\\exp(j\\omega))|^2$ 成反比。设系数为 $a_1 = -0.95$ 和 $a_2 = 0.9025$。\n\n请仅使用关于 $A(z)$ 极点位置、全极点谱结构以及谱峰半峰全宽 (FWHM) 定义的基本原理，完成以下任务：\n\n- 计算 $A(z)$ 在复 $z$ 平面中的两个极点，并以极坐标形式表示。\n- 确定 PSD 主谱峰出现的频率（单位为弧度/样本）。\n- 在适用于极点半径接近单位圆的窄带假设下，从 $A(\\exp(j\\omega))$ 的因子分解形式推导出已确定谱峰周围的 $3$ 分贝 (dB) FWHM（即功率谱密度下降到其峰值一半的两个频率之间的频率差）的解析表达式，然后进行数值计算。\n\n将最终的 $3$ dB 带宽表示为以弧度/样本为单位的单一数值，并将您的答案四舍五入到四位有效数字。角度必须以弧度为单位。在答案框中，仅报告以弧度/样本为单位的 $3$ dB 带宽。", "solution": "所述问题需要进行验证。\n\n步骤 1：提取已知条件\n-   过程定义：一个实值的、宽平稳的二阶自回归过程，记为 AR(2)。\n-   差分方程：$x[n] + a_1 x[n-1] + a_2 x[n-2] = e[n]$。\n-   驱动噪声：$e[n]$ 是均值为零、方差为 $\\sigma_e^2 \\in (0,\\infty)$ 的高斯白噪声。\n-   自回归多项式：$A(z) = 1 + a_1 z^{-1} + a_2 z^{-2}$。\n-   功率谱密度 (PSD)：$P_x(\\omega) \\propto |A(\\exp(j\\omega))|^{-2}$。\n-   系数：$a_1 = -0.95$，$a_2 = 0.9025$。\n-   目标1：计算 $A(z)$ 的极点并以极坐标形式表示。\n-   目标2：确定主谱峰的频率。\n-   目标3：在窄带假设下，推导 $3$ 分贝 (dB) 半峰全宽 (FWHM) 的解析表达式并进行数值计算。\n-   最终答案格式：以数值形式报告 $3$ dB 带宽，单位为弧度/样本，四舍五入到四位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n该问题描述了一个标准的 AR(2) 过程，这是信号处理和系统建模中的一个基本主题。所有的定义和关系，例如差分方程的形式、AR 多项式 $A(z)$ 以及 PSD与 $A(z)$ 的关系，都是标准的。该问题具有科学依据且客观。\n\n为使过程是宽平稳 (WSS) 的，对应系统传递函数 $H(z) = 1/A(z)$ 的极点必须严格位于 $z$ 平面的单位圆内部。极点是特征多项式 $z^2 + a_1 z + a_2 = 0$ 的根。对于一个实二阶系统，其稳定性条件为：\n$1$. $|a_2| < 1$\n$2$. $a_1 + a_2 > -1$\n$3$. $a_1 - a_2 < 1$\n\n我们用给定的系数 $a_1 = -0.95$ 和 $a_2 = 0.9025$ 来检查这些条件：\n$1$. $|0.9025| = 0.9025 < 1$。此条件满足。\n$2$. $-0.95 + 0.9025 = -0.0475 > -1$。此条件满足。\n$3$. $-0.95 - 0.9025 = -1.8525 < 1$。此条件满足。\n\n由于所有稳定性条件都已满足，给定的系数定义了一个稳定的，因而是宽平稳的 AR(2) 过程。问题陈述是内部一致的。它是适定的、完整的，并且没有任何科学或逻辑上的缺陷。\n\n步骤 3：结论与行动\n问题有效。将提供完整的解法。\n\n系统传递函数是 $H(z) = 1/A(z)$，其中 $A(z) = 1 + a_1 z^{-1} + a_2 z^{-2}$。系统的极点是分母多项式的根，也就是 $A(z)$ 的零点。通过解特征方程 $z^2 + a_1 z + a_2 = 0$ 可以找到这些极点。\n\n首先，我们计算极点。对于具有复数极点的实 AR(2) 过程，极点必须形成一个共轭复数对，可以用极坐标形式表示为 $p_1 = r \\exp(j\\theta)$ 和 $p_2 = r \\exp(-j\\theta)$，其中 $r$ 是极点半径，$\\pm\\theta$ 是极点角。特征多项式可以写成：\n$$ (z - p_1)(z - p_2) = z^2 - (p_1 + p_2)z + p_1 p_2 = z^2 - (2r\\cos\\theta)z + r^2 = 0 $$\n将此多项式的系数与 $z^2 + a_1 z + a_2 = 0$ 进行比较，我们发现：\n$$ a_1 = -2r\\cos\\theta $$\n$$ a_2 = r^2 $$\n使用给定值 $a_1 = -0.95$ 和 $a_2 = 0.9025$：\n极点半径 $r$ 可由 $a_2$ 求出：\n$$ r^2 = 0.9025 \\implies r = \\sqrt{0.9025} = 0.95 $$\n极点角 $\\theta$ 可由 $a_1$ 求出：\n$$ -0.95 = -2(0.95)\\cos\\theta \\implies -0.95 = -1.9\\cos\\theta $$\n$$ \\cos\\theta = \\frac{0.95}{1.9} = \\frac{1}{2} \\implies \\theta = \\arccos\\left(\\frac{1}{2}\\right) = \\frac{\\pi}{3} \\text{ 弧度} $$\n二次方程 $z^2 - 0.95z + 0.9025 = 0$ 的判别式是 $(-0.95)^2 - 4(1)(0.9025) = 0.9025 - 3.61 = -2.7075$，为负值，证实了极点是一个共轭复数对。这两个极点是：\n$$ p_1 = 0.95 \\exp\\left(j\\frac{\\pi}{3}\\right) \\quad \\text{和} \\quad p_2 = 0.95 \\exp\\left(-j\\frac{\\pi}{3}\\right) $$\n\n其次，我们确定谱峰频率。AR(2) 过程的功率谱密度是 $P_x(\\omega) = \\frac{\\sigma_e^2}{|A(\\exp(j\\omega))|^2}$。PSD 的峰值出现在分母 $|A(\\exp(j\\omega))|^2$ 达到最小值的位置。项 $|A(\\exp(j\\omega))|^2$ 表示从单位圆上的点 $\\exp(j\\omega)$ 到 $A(z)$ 的零点的距离的平方。当 $\\exp(j\\omega)$ 最接近其中一个极点（即多项式 $z^2 A(z)$ 的零点）时，出现最小值。对于靠近单位圆的极点（即 $r \\approx 1$），PSD 在与极点角对应的频率上呈现出尖锐的峰值。因此，在频率范围 $[0, \\pi]$ 内的主谱峰出现在：\n$$ \\omega_{peak} = \\theta = \\frac{\\pi}{3} \\text{ 弧度/样本} $$\n\n第三，我们推导并计算 $3$ dB 带宽 (FWHM)。$3$ dB 带宽是 PSD 下降到其峰值一半的两个点之间的频率宽度。这等同于找到频率 $\\omega$，使得分母 $|A(\\exp(j\\omega))|^2$ 是其最小值的两倍。\nAR 多项式的因子分解形式是 $A(z) = (1 - p_1 z^{-1})(1 - p_2 z^{-1})$。其频率响应的幅值平方是：\n$$ |A(\\exp(j\\omega))|^2 = |(1 - p_1 \\exp(-j\\omega))(1 - p_2 \\exp(-j\\omega))|^2 = |1 - p_1 \\exp(-j\\omega)|^2 |1 - p_2 \\exp(-j\\omega)|^2 $$\n谱的峰值位于 $\\omega_{peak} = \\theta$。在这个频率上， $|A(\\exp(j\\theta))|^2 = |1 - r \\exp(j\\theta)\\exp(-j\\theta)|^2 |1 - r \\exp(-j\\theta)\\exp(-j\\theta)|^2 = |1 - r|^2 |1 - r \\exp(-j2\\theta)|^2 = (1-r)^2 (1 - 2r\\cos(2\\theta) + r^2)$。\n\n对于极点 $p_1 = r\\exp(j\\theta)$（其中 $r$ 接近1），在窄带假设下，在 $\\omega = \\theta$ 附近的频谱主要由因子 $|1 - p_1 \\exp(-j\\omega)|^2$ 主导。另一个因子 $|1 - p_2 \\exp(-j\\omega)|^2$ 在该区域内变化缓慢，并且可以用其在峰值处的值（即在 $\\omega = \\theta$ 处的值）来近似。\n设 $\\omega = \\theta \\pm \\Delta\\omega$ 为半功率频率。3 dB 点的条件是：\n$$ |A(\\exp(j(\\theta \\pm \\Delta\\omega)))|^2 = 2 |A(\\exp(j\\theta))|^2 $$\n使用窄带近似：\n$$ |1-p_1 \\exp(-j(\\theta \\pm \\Delta\\omega))|^2 |1-p_2 \\exp(-j\\theta)|^2 \\approx 2 |1-p_1 \\exp(-j\\theta)|^2 |1-p_2 \\exp(-j\\theta)|^2 $$\n变化缓慢的项被消掉，剩下：\n$$ |1 - p_1 \\exp(-j(\\theta \\pm \\Delta\\omega))|^2 \\approx 2 |1 - p_1 \\exp(-j\\theta)|^2 $$\n我们来计算这些项。左边是：\n$$ |1 - r\\exp(j\\theta)\\exp(-j(\\theta \\pm \\Delta\\omega))|^2 = |1 - r\\exp(\\mp j\\Delta\\omega)|^2 = 1 - 2r\\cos(\\Delta\\omega) + r^2 $$\n右边是：\n$$ 2 |1 - r\\exp(j\\theta)\\exp(-j\\theta)|^2 = 2|1-r|^2 = 2(1-r)^2 $$\n将两者相等得到半带宽 $\\Delta\\omega$ 的条件：\n$$ 1 - 2r\\cos(\\Delta\\omega) + r^2 \\approx 2(1-r)^2 $$\n对于小的 $\\Delta\\omega$，我们使用泰勒近似 $\\cos(\\Delta\\omega) \\approx 1 - \\frac{(\\Delta\\omega)^2}{2}$：\n$$ 1 - 2r\\left(1 - \\frac{(\\Delta\\omega)^2}{2}\\right) + r^2 \\approx 2(1-r)^2 $$\n$$ (1 - 2r + r^2) + r(\\Delta\\omega)^2 \\approx 2(1-r)^2 $$\n$$ (1-r)^2 + r(\\Delta\\omega)^2 \\approx 2(1-r)^2 $$\n$$ r(\\Delta\\omega)^2 \\approx (1-r)^2 $$\n$$ (\\Delta\\omega)^2 \\approx \\frac{(1-r)^2}{r} \\implies |\\Delta\\omega| \\approx \\frac{1-r}{\\sqrt{r}} $$\n半峰全宽 (FWHM)，即 $3$ dB 带宽，是该值的两倍：\n$$ BW_{3dB} = 2|\\Delta\\omega| \\approx \\frac{2(1-r)}{\\sqrt{r}} $$\n现在，我们代入数值 $r=0.95$：\n$$ BW_{3dB} \\approx \\frac{2(1 - 0.95)}{\\sqrt{0.95}} = \\frac{2(0.05)}{\\sqrt{0.95}} = \\frac{0.1}{\\sqrt{0.95}} $$\n计算数值结果：\n$$ BW_{3dB} \\approx \\frac{0.1}{0.9746794} \\approx 0.1025978... $$\n四舍五入到四位有效数字，$3$ dB 带宽是 $0.1026$ 弧度/样本。", "answer": "$$\n\\boxed{0.1026}\n$$", "id": "2889646"}, {"introduction": "在理论学习之后，将算法付诸实践是深化理解的关键一步。本练习要求您亲手实现著名的Burg递推算法，这是一种从有限数据中稳健估计AR模型参数的强大方法。与依赖理想假设的方法不同，Burg算法通过最小化前向和后向预测误差的平均功率来逐阶确定反射系数，并保证了模型的稳定性。通过完成这个编程实践，您不仅能掌握AR谱估计的完整流程，还能对阶数递推算法的精髓及其在实际应用中的优势有更切实的体会 [@problem_id:2889606]。", "problem": "要求您实现一个完整、可复现的程序，该程序通过Burg递推法估计一个自回归（AR）模型，然后在指定的频率网格上评估相应的参数化功率谱密度（PSD）。程序必须从平稳、零均值离散时间信号的线性预测以及由白噪声驱动的自回归（AR）全极点模型的基本定义出发。\n\n您的实现必须基于以下基本准则：\n- AR模型由线性差分方程 $x[n] + \\sum_{k=1}^{p} a_k \\, x[n-k] = e[n]$ 定义，其中 $x[n]$ 是实数离散时间信号，$p$ 是AR阶数，$\\{a_k\\}$ 是AR系数，$e[n]$ 是一个方差为 $\\sigma_e^2$ 的零均值、独立同分布的白噪声过程。\n- 线性预测在因果性和模型阶数约束下，最小化均方单步预测误差。\n- Burg递推法通过在每一阶 $m$ 最小化在可用数据上计算的前向和后向预测误差的平方和，来逐阶确定反射系数，同时保持全极点模型的稳定性条件。该递推法随后以保持稳定性的方式将反射系数映射到AR多项式系数。\n- AR模型的参数化功率谱密度，是由AR多项式所隐含的、方差为 $\\sigma_e^2$ 的白噪声驱动的稳定全极点系统的谱，该谱在一个预设的角频率（单位为弧度）网格上进行评估。\n\n您的程序必须：\n1. 实现一个数值稳定、实数值的Burg递推法，给定一个实数数据序列 $x[n]$ 和一个整数阶数 $p \\ge 0$，该方法返回AR系数向量 $[1, a_1, \\dots, a_p]$ 和估计的预测误差方差 $\\sigma_e^2$。使用等于样本均方的无偏初始误差方差，并确保递推在每一阶都遵循稳定性约束。\n2. 给定AR系数和误差方差，在指定的角频率网格（单位为弧度）上计算由稳定全极点模型所隐含的参数化功率谱密度。角度单位为弧度。您必须评估由对应于AR多项式的全极点滤波器和驱动方差所隐含的谱。不要使用任何外部的谱估计函数。\n3. 对于每个测试用例，输出在预设角频率上评估的PSD值的自然对数，并四舍五入到六位小数。为了最终的输出格式，此四舍五入操作是必需的。\n\n测试套件：\n为以下三个确定性测试用例提供结果。在每个用例中，所有角度单位均为弧度，自然对数是底为 $e$ 的对数。\n\n- 测试用例1（正常路径，双音，中等阶数）：\n  - 数据：$x^{(1)}[n] = \\sin(2 \\pi \\cdot 0.2 \\cdot n) + 0.5 \\, \\sin(2 \\pi \\cdot 0.35 \\cdot n)$，对于 $n = 0, 1, \\dots, 63$。\n  - 阶数：$p^{(1)} = 4$。\n  - 频率网格：$\\Omega^{(1)} = \\{0.4 \\pi, 0.7 \\pi, 0.2 \\pi\\}$。\n\n- 测试用例2（边界条件，$p=0$ 的白噪声模型）：\n  - 数据：$x^{(2)}[n] = (-1)^n$，对于 $n = 0, 1, \\dots, 7$。\n  - 阶数：$p^{(2)} = 0$。\n  - 频率网格：$\\Omega^{(2)} = \\{0, 0.5 \\pi, \\pi\\}$。\n\n- 测试用例3（相对于短数据的高阶，平滑谱）：\n  - 数据：$x^{(3)}[n] = (0.9)^n$，对于 $n = 0, 1, \\dots, 15$。\n  - 阶数：$p^{(3)} = 8$。\n  - 频率网格：$\\Omega^{(3)} = \\{0, 0.15 \\pi, 0.8 \\pi\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的四舍五入后的自然对数PSD值列表。这些列表被聚合成一个由逗号分隔的列表的列表，用方括号括起来，并使用标准的Python字面量格式。具体来说，输出必须是\n$[[r_{1,1}, r_{1,2}, r_{1,3}], [r_{2,1}, r_{2,2}, r_{2,3}], [r_{3,1}, r_{3,2}, r_{3,3}]]$\n的形式，其中每个 $r_{i,j}$ 是对第 $i$ 个测试用例的第 $j$ 个频率处的PSD值的自然对数进行四舍五入后得到的、具有六位小数的浮点数。\n\n角度单位：弧度。无物理单位适用。输出值必须是浮点数。程序不得读取任何输入，也不得写入任何辅助文本。它必须只按上述确切格式打印所需的单行内容。", "solution": "所提出的问题是实现用于自回归（AR）模型参数估计的Burg算法，并随后评估参数化功率谱密度（PSD）。该问题定义明确、科学上合理且内部一致。\n\n解决方案背后的基本原理源自线性预测理论和平稳时间序列分析理论。\n\n一个p阶自回归过程，记作AR($p$)，将离散时间信号 $x[n]$ 建模为一个由白噪声 $e[n]$ 驱动的全极点滤波器的输出。其主导的线性常系数差分方程为：\n$$\nx[n] + \\sum_{k=1}^{p} a_k x[n-k] = e[n]\n$$\n这里，$\\{a_k\\}_{k=1}^p$ 是AR系数，$e[n]$ 是一个方差为 $\\sigma_e^2$ 的零均值白噪声过程。从输入 $e[n]$到输出 $x[n]$ 的合成滤波器的传递函数是一个全极点滤波器 $H(z)$：\n$$\nH(z) = \\frac{1}{A(z)} = \\frac{1}{1 + \\sum_{k=1}^{p} a_k z^{-k}}\n$$\nAR($p$)过程的功率谱密度（PSD）由该传递函数在单位圆（$z = e^{j\\omega}$）上求值的幅度平方给出，并按噪声方差 $\\sigma_e^2$ 进行缩放：\n$$\nP_{AR}(\\omega) = \\sigma_e^2 |H(e^{j\\omega})|^2 = \\frac{\\sigma_e^2}{\\left|1 + \\sum_{k=1}^{p} a_k e^{-jk\\omega}\\right|^2}\n$$\n其中 $\\omega$ 是角频率，单位为弧度。\n\n任务是从有限数据序列 $x[n]$（$n=0, 1, \\dots, N-1$）中估计参数 $\\{a_k\\}$ 和 $\\sigma_e^2$。指定使用Burg方法进行此估计。\n\nBurg算法是一种阶次递推方法，用于估计反射系数 $k_m$（$m=1, \\dots, p$）。它以产生稳定模型而闻名，即保证 $H(z)$ 的极点在单位圆内，这要求 $|k_m| < 1$。这种稳定性是其推导过程的直接结果。在每一阶 $m$，Burg方法最小化前向和后向预测误差的平均功率之和。\n\n设 $e_m^f[n]$ 和 $e_m^b[n]$ 分别为m阶的前向和后向预测误差。算法流程如下：\n\n1.  **初始化（阶数 $m=0$）**:\n    0阶模型假设信号是白噪声。前向和后向预测误差就是信号本身：$e_0^f[n] = x[n]$ 和 $e_0^b[n] = x[n]$，对于 $n=0, \\dots, N-1$。初始预测误差功率 $P_0$ 是数据的样本均方，如指定：\n    $$\n    P_0 = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^2\n    $$\n    对于 $p=0$，系数向量是 $[1]$，误差方差是 $P_0$。\n\n2.  **递推（阶数 $m = 1, \\dots, p$）**:\n    对于每一阶 $m$，计算反射系数 $k_m$ 以最小化总误差能量。这得到：\n    $$\n    k_m = \\frac{-2 \\sum_{n=m}^{N-1} e_{m-1}^f[n] \\, e_{m-1}^b[n-1]}{\\sum_{n=m}^{N-1} \\left( |e_{m-1}^f[n]|^2 + |e_{m-1}^b[n-1]|^2 \\right)}\n    $$\n    然后使用Levinson-Durbin递推来更新AR系数。如果 $\\{a_k^{(m-1)}\\}_{k=1}^{m-1}$ 是 ($m-1$) 阶模型的系数，那么 $m$ 阶模型的系数计算如下：\n    $$\n    a_m^{(m)} = k_m\n    $$\n    $$\n    a_k^{(m)} = a_k^{(m-1)} + k_m a_{m-k}^{(m-1)} \\quad \\text{for } k=1, \\dots, m-1\n    $$\n    预测误差方差通过以下方式更新：\n    $$\n    P_m = P_{m-1}(1 - k_m^2)\n    $$\n    最后，为下一次迭代更新前向和后向误差序列：\n    $$\n    e_m^f[n] = e_{m-1}^f[n] + k_m e_{m-1}^b[n-1]\n    $$\n    $$\n    e_m^b[n] = e_{m-1}^b[n-1] + k_m e_{m-1}^f[n]\n    $$\n    这些新的误差序列定义在 $n=m, \\dots, N-1$ 的范围内。\n\n在完成到p阶的递推后，算法提供最终的AR系数向量 $[a_1^{(p)}, \\dots, a_p^{(p)}]$（在其前面加上 $a_0 = 1$）和最终的误差方差 $\\sigma_e^2 = P_p$。\n\n有了这些估计的参数后，使用 $P_{AR}(\\omega)$ 的公式在指定的频率 $\\Omega^{(i)}$ 上计算PSD。然后，计算所得PSD值的自然对数并四舍五入到六位小数，以满足最终输出的要求。实现将处理PSD分母非常接近零的情况，这种情况可能发生在具有位于单位圆上或附近的极点的确定性信号模型中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the Burg recursion for AR model estimation\n    and calculating the parametric PSD for three specified test cases.\n    \"\"\"\n\n    def burg_ar(x: np.ndarray, p: int) -> tuple[np.ndarray, float]:\n        \"\"\"\n        Estimates AR model parameters using the Burg recursion.\n\n        Args:\n            x: Real-valued 1D data sequence.\n            p: The desired AR model order, p >= 0.\n\n        Returns:\n            A tuple containing:\n            - The AR coefficient vector [1, a_1, ..., a_p].\n            - The estimated prediction error variance sigma_e^2.\n        \"\"\"\n        N = len(x)\n        x = np.asarray(x, dtype=float)\n\n        if p == 0:\n            a = np.array([1.0])\n            var_e = np.mean(x**2)\n            return a, var_e\n\n        # Initialization (m=0)\n        P = np.mean(x**2)\n        a_coeffs = np.array([], dtype=float)  # Stores [a_1, a_2, ...]\n        ef = x.copy()  # Forward prediction error\n        eb = x.copy()  # Backward prediction error\n\n        # Recursion from m=1 to p\n        for m in range(1, p + 1):\n            # Calculate reflection coefficient k_m\n            # Slices correspond to valid time indices for error sequences at step m\n            ef_slice = ef[1:]\n            eb_slice = eb[:-1]\n\n            numerator = -2.0 * np.dot(ef_slice, eb_slice)\n            denominator = np.dot(ef_slice, ef_slice) + np.dot(eb_slice, eb_slice)\n\n            if denominator < 1e-20:  # Avoid division by zero\n                k = 0.0\n            else:\n                k = numerator / denominator\n\n            # Update AR coefficients using Levinson recursion\n            if m > 1:\n                a_coeffs = a_coeffs + k * a_coeffs[::-1]\n            a_coeffs = np.append(a_coeffs, k)\n\n            # Update error variance\n            P *= (1.0 - k**2)\n\n            # Update prediction errors for the next iteration\n            ef_new = ef_slice + k * eb_slice\n            eb_new = eb_slice + k * ef_slice\n            ef, eb = ef_new, eb_new\n\n        # Prepend a_0=1 to the coefficient vector\n        final_a = np.concatenate(([1.0], a_coeffs))\n        return final_a, P\n\n    def calculate_psd(a: np.ndarray, var_e: float, freqs: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates the PSD from AR model parameters.\n\n        Args:\n            a: AR coefficient vector [1, a_1, ..., a_p].\n            var_e: Prediction error variance.\n            freqs: Array of angular frequencies (in radians) to evaluate the PSD.\n\n        Returns:\n            An array of PSD values corresponding to the frequencies in `freqs`.\n        \"\"\"\n        p = len(a) - 1\n        if p == 0:\n            return np.full_like(freqs, var_e, dtype=float)\n\n        psd_vals = []\n        k_vec = np.arange(p + 1)\n        for w in freqs:\n            A_exp_jw = np.sum(a * np.exp(-1j * k_vec * w))\n            den = np.abs(A_exp_jw)**2\n            \n            # Use a small epsilon to handle cases where poles are on the unit circle\n            if den < 1e-20:\n                psd = np.inf\n            else:\n                psd = var_e / den\n            psd_vals.append(psd)\n            \n        return np.array(psd_vals)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"data_func\": lambda n: np.sin(2 * np.pi * 0.2 * n) + 0.5 * np.sin(2 * np.pi * 0.35 * n),\n            \"n_range\": np.arange(64),\n            \"p\": 4,\n            \"freqs\": np.array([0.4 * np.pi, 0.7 * np.pi, 0.2 * np.pi])\n        },\n        # Test case 2\n        {\n            \"data_func\": lambda n: (-1)**n,\n            \"n_range\": np.arange(8),\n            \"p\": 0,\n            \"freqs\": np.array([0, 0.5 * np.pi, np.pi])\n        },\n        # Test case 3\n        {\n            \"data_func\": lambda n: 0.9**n,\n            \"n_range\": np.arange(16),\n            \"p\": 8,\n            \"freqs\": np.array([0, 0.15 * np.pi, 0.8 * np.pi])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate data\n        x = case[\"data_func\"](case[\"n_range\"])\n        \n        # Estimate AR parameters\n        a, var_e = burg_ar(x, case[\"p\"])\n        \n        # Calculate PSD\n        psd_values = calculate_psd(a, var_e, case[\"freqs\"])\n        \n        # Compute natural log and round\n        with np.errstate(divide='ignore'): # suppress log(0) warning\n           log_psd = np.log(psd_values)\n        rounded_log_psd = np.round(log_psd, 6).tolist()\n        \n        results.append(rounded_log_psd)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists matches the required output format.\n    print(str(results).replace(\"inf\", \"float('inf')\"))\n\n\nsolve()\n```", "id": "2889606"}]}