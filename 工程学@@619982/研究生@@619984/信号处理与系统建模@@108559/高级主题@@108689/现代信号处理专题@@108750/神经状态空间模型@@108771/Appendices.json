{"hands_on_practices": [{"introduction": "神经网络状态空间模型通常在连续时间域中进行理论构建，因为这能更好地捕捉潜在的动态过程。然而，在数字计算机上进行仿真和部署则必须将模型转化为离散时间形式。本练习将指导您完成这一关键的转换过程，带领您从第一性原理出发，推导并实现零阶保持（ZOH）离散化，这是连接连续时间理论与离散时间实践的基础桥梁。 [@problem_id:2886125]", "problem": "给定连续时间线性时不变状态空间模型，作为神经状态空间建模管道的线性主干。该主干由矩阵 $A \\in \\mathbb{R}^{n \\times n}$、$B \\in \\mathbb{R}^{n \\times m}$、$C \\in \\mathbb{R}^{p \\times n}$ 和 $D \\in \\mathbb{R}^{p \\times m}$ 以及采样周期 $\\Delta \\in \\mathbb{R}_{>0}$ 指定。假设输入上存在零阶保持器 (ZOH)，请从第一性原理出发，推导出一个正确的离散时间状态更新和输出方程，该方程将采样时刻 $k \\in \\mathbb{Z}_{\\ge 0}$ 映射到 $k+1$。仅使用线性时不变动力学的基本解和 ZOH 假设作为起点。然后，实现一个程序，用于计算离散时间矩阵 $(A_d,B_d,C_d,D_d)$，并针对给定的分段常数输入，模拟离散时间输出序列。\n\n连续时间模型为\n$x'(t) = A x(t) + B u(t)$ 和 $y(t) = C x(t) + D u(t)$。\n在零阶保持器 (ZOH) 假设下，输入 $u(t)$ 在每个采样区间 $[k\\Delta, (k+1)\\Delta)$ 上保持恒定；将该恒定值表示为 $u_k \\in \\mathbb{R}^m$。离散时间模型的形式为\n$x_{k+1} = A_d x_k + B_d u_k$ 和 $y_k = C_d x_k + D_d u_k$，\n其中 $k \\in \\mathbb{Z}_{\\ge 0}$。\n\n您的程序必须：\n- 根据 ZOH 假设计算 $(A_d,B_d,C_d,D_d)$，不使用任何预先给出的简化公式，而应遵循线性时不变系统的基本解和 ZOH 输入模型进行推导。\n- 对每个测试用例，在给定初始状态 $x_0$ 和一个在 $N$ 步上指定的分段常数输入安排的情况下，模拟输出序列 $\\{y_k\\}_{k=0}^{N-1}$。\n- 对每个测试用例，返回一个实数，该实数等于输出序列的平方和，即 $\\sum_{k=0}^{N-1} \\lVert y_k \\rVert_2^2$，以实数标量形式表示（不涉及物理单位）。\n- 将返回的每个标量四舍五入到恰好 $6$ 位小数。\n\n输入安排以分段列表 $(k_{\\mathrm{start}}, k_{\\mathrm{end}}, v)$ 的形式给出，其中 $k_{\\mathrm{start}}$ 和 $k_{\\mathrm{end}}$ 是满足 $0 \\le k_{\\mathrm{start}} \\le k_{\\mathrm{end}} \\le N-1$ 的整数，$v \\in \\mathbb{R}^m$ 是在闭区间 $\\{k_{\\mathrm{start}}, \\dots, k_{\\mathrm{end}}\\}$ 内对所有整数 $k$ 施加的恒定输入。\n\n测试套件：\n- 测试用例 $1$（正常路径，二阶，严格真）：\n  - $A = \\begin{bmatrix} 0 & 1 \\\\ -2 & -0.5 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 1 & 0 \\end{bmatrix}$, $D = \\begin{bmatrix} 0 \\end{bmatrix}$。\n  - $\\Delta = 0.1$。\n  - $x_0 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$。\n  - $N = 50$。\n  - 输入分段：$(0, 19, [1.0])$, $(20, 49, [0.0])$。\n- 测试用例 $2$（边界情况，A 为零且存在非零直通）：\n  - $A = \\begin{bmatrix} 0 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\end{bmatrix}$, $C = \\begin{bmatrix} 1 \\end{bmatrix}$, $D = \\begin{bmatrix} 0.5 \\end{bmatrix}$。\n  - $\\Delta = 0.25$。\n  - $x_0 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n  - $N = 8$。\n  - 输入分段：$(0, 3, [2.0])$, $(4, 7, [-2.0])$。\n- 测试用例 $3$（振荡边缘动力学）：\n  - $A = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 0.5 \\end{bmatrix}$, $C = \\begin{bmatrix} 0 & 1 \\end{bmatrix}$, $D = \\begin{bmatrix} 0 \\end{bmatrix}$。\n  - $\\Delta = 0.2$。\n  - $x_0 = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$。\n  - $N = 20$。\n  - 输入分段：$(0, 9, [0.3])$, $(10, 19, [0.0])$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内的逗号分隔列表，每个数字都四舍五入到恰好六位小数，且不含任何附加文本。例如：\"[1.234000,5.678900,0.000123]\"。", "solution": "该问题要求推导并实现一种方法，在零阶保持器 (ZOH) 假设下，对连续时间线性时不变 (LTI) 状态空间模型进行离散化。\n\n连续时间模型由以下状态和输出方程给出：\n$$\nx'(t) = A x(t) + B u(t)\n$$\n$$\ny(t) = C x(t) + D u(t)\n$$\n其中 $x(t) \\in \\mathbb{R}^n$ 是状态向量，$u(t) \\in \\mathbb{R}^m$ 是输入向量，$y(t) \\in \\mathbb{R}^p$ 是输出向量。矩阵 $A$、$B$、$C$和$D$具有相容的维度。\n\n目标是找到一个以周期 $\\Delta > 0$ 采样的等效离散时间模型，其形式如下：\n$$\nx_{k+1} = A_d x_k + B_d u_k\n$$\n$$\ny_k = C_d x_k + D_d u_k\n$$\n其中 $x_k = x(k\\Delta)$，$y_k = y(k\\Delta)$，而 $u_k$ 是在区间 $[k\\Delta, (k+1)\\Delta)$ 上的恒定输入值。\n\n推导从连续时间LTI状态方程的基本解开始，该解由常数变易法公式给出。对于初始时间 $t_0$ 和最终时间 $t$，状态为：\n$$\nx(t) = e^{A(t-t_0)} x(t_0) + \\int_{t_0}^{t} e^{A(t-\\tau)} B u(\\tau) d\\tau\n$$\n\n我们将此公式应用于单个采样区间，从 $t_0 = k\\Delta$ 到 $t = (k+1)\\Delta$。区间开始时的状态是 $x(k\\Delta) = x_k$。区间结束时的状态是 $x((k+1)\\Delta) = x_{k+1}$。ZOH 假设指出，对于 $\\tau \\in [k\\Delta, (k+1)\\Delta)$，输入 $u(\\tau)$ 是恒定的，其值为 $u_k$。\n\n将这些代入解的公式中：\n$$\nx_{k+1} = e^{A((k+1)\\Delta - k\\Delta)} x_k + \\int_{k\\Delta}^{(k+1)\\Delta} e^{A((k+1)\\Delta - \\tau)} B u_k d\\tau\n$$\n\n我们可以简化这个表达式。第一项给出了离散系统的状态转移矩阵：\n$$\ne^{A\\Delta} x_k\n$$\n通过观察，我们确定离散时间状态矩阵 $A_d$：\n$$\nA_d = e^{A\\Delta}\n$$\n第二项涉及积分。由于 $u_k$ 在积分区间上是一个常数向量，因此可以将其从积分中提出：\n$$\n\\left( \\int_{k\\Delta}^{(k+1)\\Delta} e^{A((k+1)\\Delta - \\tau)} d\\tau \\right) B u_k\n$$\n为了计算该积分，我们进行变量替换。令 $\\sigma = (k+1)\\Delta - \\tau$。则 $d\\sigma = -d\\tau$。积分限从 $\\tau=k\\Delta \\rightarrow \\sigma=\\Delta$ 和 $\\tau=(k+1)\\Delta \\rightarrow \\sigma=0$ 改变。\n$$\n\\int_{\\Delta}^{0} e^{A\\sigma} (-d\\sigma) = \\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma\n$$\n因此，第二项是 $\\left(\\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma \\right) B u_k$。\n通过与离散时间模型形式进行比较，我们确定离散时间输入矩阵 $B_d$：\n$$\nB_d = \\left( \\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma \\right) B\n$$\n因此，完整的离散时间状态更新方程为：\n$$\nx_{k+1} = (e^{A\\Delta}) x_k + \\left( \\int_{0}^{\\Delta} e^{A\\sigma} d\\sigma \\right) B u_k\n$$\n当 $A$ 可逆时，该积分可以计算为 $A^{-1}(e^{A\\Delta}-I)$，但实现上需要一种更通用且数值上更鲁棒的方法。该方法被称为矩阵指数法或 van Loan 方法，可同时计算 $A_d$ 和 $B_d$。考虑一个大小为 $(n+m) \\times (n+m)$ 的增广矩阵 $M$：\n$$\nM = \\begin{bmatrix} A & B \\\\ 0 & 0 \\end{bmatrix}\n$$\n$M\\Delta$ 的矩阵指数可以使用分块矩阵表示法来表示。指数的级数展开表明：\n$$\ne^{M\\Delta} = \\begin{bmatrix} e^{A\\Delta} & \\left(\\int_0^\\Delta e^{A\\sigma} d\\sigma\\right) B \\\\ 0 & I_m \\end{bmatrix} = \\begin{bmatrix} A_d & B_d \\\\ 0 & I_m \\end{bmatrix}\n$$\n其中 $I_m$ 是 $m \\times m$ 的单位矩阵。这允许通过单次矩阵指数计算来同时求得 $A_d$ 和 $B_d$，即使对于奇异的 $A$ 矩阵，该方法也是鲁棒的。\n\n接下来，我们推导离散时间输出矩阵 $C_d$ 和 $D_d$。离散输出 $y_k$ 是连续输出在时间 $t=k\\Delta$ 处的采样值：\n$$\ny_k = y(k\\Delta) = C x(k\\Delta) + D u(k\\Delta)\n$$\n使用定义 $x_k = x(k\\Delta)$ 和 ZOH 属性 $u(k\\Delta) = u_k$，我们得到：\n$$\ny_k = C x_k + D u_k\n$$\n将其与通用形式 $y_k = C_d x_k + D_d u_k$ 进行比较，我们直接确定：\n$$\nC_d = C\n$$\n$$\nD_d = D\n$$\n至此，推导完成。实现部分将构建增广矩阵 $M$，计算其指数以求得 $A_d$ 和 $B_d$，然后使用所有四个离散矩阵 $(A_d, B_d, C_d, D_d)$ 来模拟系统在 $N$ 步内的响应。对于从 $0$ 到 $N-1$ 的每一步 $k$，计算输出 $y_k$，并累加其欧几里得范数平方的和，即 $\\sum_{k=0}^{N-1} \\lVert y_k \\rVert_2^2$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the problem by discretizing continuous-time state-space models\n    and simulating their response to compute a metric.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"A\": np.array([[0.0, 1.0], [-2.0, -0.5]]),\n            \"B\": np.array([[0.0], [1.0]]),\n            \"C\": np.array([[1.0, 0.0]]),\n            \"D\": np.array([[0.0]]),\n            \"Delta\": 0.1,\n            \"x0\": np.array([1.0, 0.0]),\n            \"N\": 50,\n            \"input_segments\": [(0, 19, [1.0]), (20, 49, [0.0])],\n        },\n        {\n            \"A\": np.array([[0.0]]),\n            \"B\": np.array([[1.0]]),\n            \"C\": np.array([[1.0]]),\n            \"D\": np.array([[0.5]]),\n            \"Delta\": 0.25,\n            \"x0\": np.array([0.0]),\n            \"N\": 8,\n            \"input_segments\": [(0, 3, [2.0]), (4, 7, [-2.0])],\n        },\n        {\n            \"A\": np.array([[0.0, -1.0], [1.0, 0.0]]),\n            \"B\": np.array([[0.0], [0.5]]),\n            \"C\": np.array([[0.0, 1.0]]),\n            \"D\": np.array([[0.0]]),\n            \"Delta\": 0.2,\n            \"x0\": np.array([0.0, 1.0]),\n            \"N\": 20,\n            \"input_segments\": [(0, 9, [0.3]), (10, 19, [0.0])],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A, B, C, D = case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"]\n        Delta, x0, N = case[\"Delta\"], case[\"x0\"], case[\"N\"]\n        input_segments = case[\"input_segments\"]\n\n        n, m = A.shape[1], B.shape[1]\n\n        # Construct the augmented matrix M for ZOH discretization.\n        M = np.zeros((n + m, n + m))\n        M[:n, :n] = A\n        M[:n, n:] = B\n        \n        # Compute the matrix exponential.\n        E = expm(M * Delta)\n        \n        # Extract discrete-time matrices Ad and Bd.\n        Ad = E[:n, :n]\n        Bd = E[:n, n:]\n        \n        # Cd and Dd are the same as C and D for ZOH sampled at t_k.\n        Cd = C\n        Dd = D\n\n        # Construct the full input sequence u_k for k=0...N-1.\n        u_sequence = np.zeros((N, m))\n        for k_start, k_end, v in input_segments:\n            for k in range(k_start, k_end + 1):\n                u_sequence[k, :] = v\n\n        # Simulate the discrete-time system.\n        x_current = x0.copy().reshape(-1, 1)\n        sum_of_squares = 0.0\n\n        for k in range(N):\n            u_k = u_sequence[k].reshape(-1, 1)\n\n            # Calculate output y_k = C_d * x_k + D_d * u_k\n            y_k = Cd @ x_current + Dd @ u_k\n\n            # Accumulate the sum of squares of the L2 norm of the output.\n            sum_of_squares += np.sum(y_k**2)\n\n            # Update state for next step: x_{k+1} = A_d * x_k + B_d * u_k\n            x_current = Ad @ x_current + Bd @ u_k\n            \n        results.append(sum_of_squares)\n\n    # Format the final output string as required.\n    output_str = \"[\" + \",\".join([f\"{r:.6f}\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2886125"}, {"introduction": "拥有了离散时间框架后，下一个核心任务便是从观测数据中“学习”出模型参数。本实践模拟了这一学习过程，您将通过经典的系统辨识方法（何-卡尔曼算法），仅利用输入输出数据来恢复一个状态空间实现。这个过程不仅揭示了神经网络状态空间模型训练的核心思想，还直观地阐释了状态空间实现并非唯一以及它们之间通过相似变换相互关联的重要概念。 [@problem_id:2886056]", "problem": "给定一系列线性时不变状态空间模型，这些模型是具有仿射状态和输出映射的神经状态空间模型的一个特例，即 $f(\\mathbf{x},\\mathbf{u}) = A\\mathbf{x} + B\\mathbf{u}$ 和 $g(\\mathbf{x},\\mathbf{u}) = C\\mathbf{x} + D\\mathbf{u}$。对于每个模型，您必须生成输入输出数据，仅从数据中拟合一个实现 (realization)，然后计算一个相似性变换，将估计的实现与真实值 (ground-truth) 对齐。\n\n基本原理。使用标准的线性时不变状态空间方程和定义：对于离散时间索引 $k \\in \\mathbb{Z}_{\\ge 0}$，状态更新和输出方程为\n$$\n\\mathbf{x}_{k+1} = A \\mathbf{x}_k + B \\mathbf{u}_k, \\quad \\mathbf{y}_k = C \\mathbf{x}_k + D \\mathbf{u}_k,\n$$\n其中状态为 $\\mathbf{x}_k \\in \\mathbb{R}^n$，输入为 $\\mathbf{u}_k \\in \\mathbb{R}^m$，输出为 $\\mathbf{y}_k \\in \\mathbb{R}^p$。脉冲响应（也称为马尔可夫参数）$\\{H_i\\}_{i\\ge 0}$ 满足 $H_0 = D$ 以及当 $i \\ge 1$ 时 $H_i = C A^{i-1} B$。任何两个产生相同输入输出行为的最小实现都通过一个相似性变换相关联：如果 $(\\hat{A},\\hat{B},\\hat{C},\\hat{D})$ 是同一传递行为的另一个实现，则存在一个可逆矩阵 $T \\in \\mathbb{R}^{n \\times n}$，使得 $\\hat{A} = T^{-1} A T$, $\\hat{B} = T^{-1} B$, and $\\hat{C} = C T$，且 $\\hat{D} = D$。\n\n任务。对于下述每个测试用例，请仅从给定的真实值 $(A,B,C,D)$ 生成的输入输出数据出发，执行以下步骤：\n1. 数据生成。使用每个测试用例中指定的固定伪随机种子，在 $\\mathbb{R}^m$ 中生成一个零均值、单位协方差的独立同分布高斯输入序列 $\\{\\mathbf{u}_k\\}_{k=0}^{N-1}$。以初始状态 $\\mathbf{x}_0 = \\mathbf{0}$ 模拟系统，使用精确的状态空间动力学（不添加任何噪声）来产生输出 $\\{\\mathbf{y}_k\\}_{k=0}^{N-1}$。\n2. 马尔可夫参数估计。仅从输入输出数据出发，通过求解一个线性最小二乘问题来估计马尔可夫参数的有限序列 $\\{\\hat{H}_i\\}_{i=0}^{L}$。该问题在时域长度 $L$ 上强制输出与过去输入之间的卷积关系，其中 $L = s + r + 10$，$s$ 和 $r$ 由每个测试用例指定。\n3. 通过块汉克尔矩阵分解恢复实现。使用估计的 $\\{\\hat{H}_i\\}$，构建具有 $s$ 个块行和 $r$ 个块列的块汉克尔 (block Hankel) 矩阵，然后使用奇异值分解 (SVD) 对其进行因式分解，以获得指定状态维度 $n$ 的一个实现 $(\\hat{A},\\hat{B},\\hat{C},\\hat{D})$。\n4. 相似性对齐。计算一个相似性矩阵 $T \\in \\mathbb{R}^{n \\times n}$，通过在最小二乘意义上强制执行线性对齐约束 $T \\hat{B} \\approx B$, $C T \\approx \\hat{C}$ 和 $A T \\approx T \\hat{A}$，将估计的实现与真实值进行最佳对齐。将 $T$ 的未知条目向量化，作为一个单一的线性最小二乘问题求解 $T$。\n5. 定量误差。报告以下三个归一化弗罗贝尼乌斯范数 (Frobenius-norm) 残差的最大值\n$$\n\\varepsilon_A = \\frac{\\lVert A T - T \\hat{A} \\rVert_F}{\\lVert A \\rVert_F + 10^{-12}}, \\quad\n\\varepsilon_B = \\frac{\\lVert T \\hat{B} - B \\rVert_F}{\\lVert B \\rVert_F + 10^{-12}}, \\quad\n\\varepsilon_C = \\frac{\\lVert C T - \\hat{C} \\rVert_F}{\\lVert C \\rVert_F + 10^{-12}},\n$$\n即，为每个测试用例输出 $e = \\max\\{\\varepsilon_A,\\varepsilon_B,\\varepsilon_C\\}$。\n\n测试套件。使用以下三个测试用例。每个用例都指定了 $(A,B,C,D)$、模型维度 $(n,m,p)$、仿真长度 $N$、汉克尔矩阵设计参数 $(s,r)$ 以及用于输入生成的伪随机种子。\n\n- 用例 1 (单输入单输出):\n$$\nA = \\begin{bmatrix} 0.7 & 0.2 \\\\ -0.1 & 0.9 \\end{bmatrix}, \\;\nB = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix}, \\;\nC = \\begin{bmatrix} 1.0 & -0.3 \\end{bmatrix}, \\;\nD = \\begin{bmatrix} 0.1 \\end{bmatrix}.\n$$\n维度: $n = 2$, $m = 1$, $p = 1$。使用 $N = 800$, $s = 5$, $r = 5$, 种子 $= 123$。\n\n- 用例 2 (多输入多输出):\n$$\nA = \\begin{bmatrix} 0.6 & 0.2 & 0.0 \\\\ 0.0 & 0.7 & 0.1 \\\\ 0.0 & -0.2 & 0.8 \\end{bmatrix}, \\;\nB = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\\\ 0.5 & -0.2 \\end{bmatrix}, \\;\nC = \\begin{bmatrix} 1.0 & 0.0 & 0.3 \\\\ 0.2 & 0.8 & -0.1 \\end{bmatrix}, \\;\nD = \\begin{bmatrix} 0.0 & 0.0 \\\\ 0.0 & 0.0 \\end{bmatrix}.\n$$\n维度: $n = 3$, $m = 2$, $p = 2$。使用 $N = 1500$, $s = 6$, $r = 6$, 种子 $= 456$。\n\n- 用例 3 (强调直接馈通):\n$$\nA = \\begin{bmatrix} 0.95 \\end{bmatrix}, \\;\nB = \\begin{bmatrix} 1.2 \\end{bmatrix}, \\;\nC = \\begin{bmatrix} 0.8 \\end{bmatrix}, \\;\nD = \\begin{bmatrix} 0.4 \\end{bmatrix}.\n$$\n维度: $n = 1$, $m = 1$, $p = 1$。使用 $N = 400$, $s = 4$, $r = 4$, 种子 $= 789$。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个用例的三个标量误差 $e$，按顺序排列，四舍五入到小数点后六位，格式为逗号分隔的列表并用方括号括起来，例如 $[0.000123,0.001234,0.012345]$。不应打印任何其他文本。", "solution": "该问题要求从输入输出数据中辨识线性时不变 (LTI) 状态空间模型，并随后将辨识出的模型与一个真实值实现 (ground-truth realization) 进行对齐。这是一个系统辨识中的标准多步流程，每一步都将精确执行。每一步都基于线性系统理论的基本原理。\n\n系统动力学由离散时间状态空间方程描述：\n$$\n\\mathbf{x}_{k+1} = A \\mathbf{x}_k + B \\mathbf{u}_k, \\quad \\mathbf{y}_k = C \\mathbf{x}_k + D \\mathbf{u}_k\n$$\n其中 $\\mathbf{x}_k \\in \\mathbb{R}^n$ 是状态，$\\mathbf{u}_k \\in \\mathbb{R}^m$ 是输入，$\\mathbf{y}_k \\in \\mathbb{R}^p$ 是在时间步 $k$ 的输出。矩阵 $(A, B, C, D)$ 定义了该系统。\n\n对每个测试用例执行的步骤如下：\n\n**步骤 1：数据生成**\n首先，我们模拟系统以生成有限长度的输入输出对历史数据。对于一个给定的测试用例，其参数为 $(A, B, C, D, n, m, p, N, \\text{seed})$，我们按以下方式进行：\n使用指定的种子初始化伪随机数生成器，以确保可复现性。生成一个输入序列 $\\{\\mathbf{u}_k\\}_{k=0}^{N-1}$，其中每个 $\\mathbf{u}_k$ 均独立地从多元标准正态分布 $\\mathcal{N}(\\mathbf{0}, I_m)$ 中抽取。\n将初始状态设为零向量 $\\mathbf{x}_0 = \\mathbf{0}$，使用状态空间方程对系统进行 $k = 0, 1, \\dots, N-1$ 的仿真，以产生输出序列 $\\{\\mathbf{y}_k\\}_{k=0}^{N-1}$。根据问题陈述，不添加过程噪声或测量噪声。\n\n**步骤 2：马尔可夫参数估计**\n一个 LTI 系统的输入输出关系可以通过涉及系统脉冲响应（也称为马尔可夫参数 $\\{H_i\\}_{i \\ge 0}$）的卷积和来表示。该关系由下式给出：\n$$\n\\mathbf{y}_k = \\sum_{i=0}^{\\infty} H_i \\mathbf{u}_{k-i}\n$$\n其中 $H_0 = D$ 且当 $i \\ge 1$ 时 $H_i = C A^{i-1} B$。为了从有限数据进行实际估计，我们在一个时域长度 $L$ 处截断此和：\n$$\n\\mathbf{y}_k \\approx \\sum_{i=0}^{L} \\hat{H}_i \\mathbf{u}_{k-i}\n$$\n我们可以通过求解一个线性最小二乘问题来估计马尔可夫参数序列 $\\{\\hat{H}_i\\}_{i=0}^{L}$。我们为时间步 $k = L, L+1, \\dots, N-1$ 建立一组线性方程。令 $\\mathcal{M} = [\\hat{H}_0, \\hat{H}_1, \\dots, \\hat{H}_L] \\in \\mathbb{R}^{p \\times (L+1)m}$ 为未知参数矩阵。令 $\\mathbf{\\Phi}_k = [\\mathbf{u}_k^T, \\mathbf{u}_{k-1}^T, \\dots, \\mathbf{u}_{k-L}^T]^T \\in \\mathbb{R}^{(L+1)m}$。方程为 $\\mathbf{y}_k^T = \\mathbf{\\Phi}_k^T \\mathcal{M}^T$。我们将这些针对 $k=L, \\dots, N-1$ 的方程堆叠起来，形成一个大型线性系统 $\\mathbf{Y} = \\mathbf{U}_{\\text{reg}} \\mathcal{M}^T$，其中 $\\mathbf{U}_{\\text{reg}} \\in \\mathbb{R}^{(N-L) \\times (L+1)m}$ 是回归矩阵，其行是 $\\mathbf{\\Phi}_k^T$，而 $\\mathbf{Y} \\in \\mathbb{R}^{(N-L) \\times p}$ 是相应输出的矩阵。\n$\\mathcal{M}^T$ 的最小二乘估计是通过求解这个超定系统得到的。从得到的 $\\hat{\\mathcal{M}}$ 中，我们提取出单个的估计马尔可夫参数 $\\hat{H}_0, \\hat{H}_1, \\dots, \\hat{H}_L$。时域长度设为 $L = s + r + 10$，这对于后续的实现步骤来说足够长。\n\n**步骤 3：通过块汉克尔矩阵分解恢复实现**\nHo-Kalman 算法提供了一种从脉冲响应的严格真有理部分（即从 $\\{\\hat{H}_i\\}_{i \\ge 1}$）获得状态空间实现 $(\\hat{A}, \\hat{B}, \\hat{C})$ 的方法。直接馈通项就是 $\\hat{D} = \\hat{H}_0$。\n我们使用估计的马尔可夫参数构建一个大小为 $(s \\cdot p) \\times (r \\cdot m)$ 的块汉克尔矩阵：\n$$\n\\mathcal{H}_{s,r} = \\begin{bmatrix}\n\\hat{H}_1 & \\hat{H}_2 & \\dots & \\hat{H}_r \\\\\n\\hat{H}_2 & \\hat{H}_3 & \\dots & \\hat{H}_{r+1} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\hat{H}_s & \\hat{H}_{s+1} & \\dots & \\hat{H}_{s+r-1}\n\\end{bmatrix}\n$$\n该矩阵可以分解为扩展可观测性矩阵 $\\mathcal{O}_s$ 和扩展可控性矩阵 $\\mathcal{C}_r$ 的乘积：$\\mathcal{H}_{s,r} = \\mathcal{O}_s \\mathcal{C}_r$。\n我们对 $\\mathcal{H}_{s,r} = U \\Sigma V^T$ 进行奇异值分解 (SVD)。对于一个秩为 $n$ 的最小实现，我们将 SVD 截断为最大的 $n$ 个奇异值：$U_n \\in \\mathbb{R}^{sp \\times n}$，$\\Sigma_n \\in \\mathbb{R}^{n \\times n}$，$V_n \\in \\mathbb{R}^{rm \\times n}$。然后通过选择 $\\mathcal{O}_s = U_n \\Sigma_n^{1/2}$ 和 $\\mathcal{C}_r = \\Sigma_n^{1/2} V_n^T$ 给出一个平衡实现。\n从这些因子中，提取系统矩阵：\n- $\\hat{C}$ 是 $\\mathcal{O}_s$ 的前 $p$ 行。\n- $\\hat{B}$ 是 $\\mathcal{C}_r$ 的前 $m$ 列。\n- $\\hat{A}$ 是使用移位的块汉克尔矩阵 $\\mathcal{H}'_{s,r}$（其中所有索引都加 1）找到的，该矩阵满足 $\\mathcal{H}'_{s,r} = \\mathcal{O}_s \\hat{A} \\mathcal{C}_r$。这给出 $\\hat{A} = (\\mathcal{O}_s^\\dagger) \\mathcal{H}'_{s,r} (\\mathcal{C}_r^\\dagger) = \\Sigma_n^{-1/2} U_n^T \\mathcal{H}'_{s,r} V_n \\Sigma_n^{-1/2}$。\n\n**步骤 4：相似性对齐**\n实现 $(\\hat{A}, \\hat{B}, \\hat{C})$ 在一个相似性变换下是正确的。为了将其与真实值 $(A, B, C)$ 进行比较，我们必须找到一个可逆矩阵 $T \\in \\mathbb{R}^{n \\times n}$ 来对齐它们。理想的变换满足 $A = T \\hat{A} T^{-1}$，$B = T \\hat{B}$ 和 $C = \\hat{C} T^{-1}$。重新整理可得到关于 $T$ 的线性方程组：\n1. $A T - T \\hat{A} = 0$\n2. $T \\hat{B} - B = 0$\n3. $C T - \\hat{C} = 0$\n我们在最小二乘意义上找到能够同时最佳满足这三个方程的矩阵 $T$。为了将其表述为一个标准的线性最小二乘问题，我们使用克罗内克积 ($\\otimes$) 将矩阵方程向量化：\n1. $(I_n \\otimes A - \\hat{A}^T \\otimes I_n) \\text{vec}(T) = \\text{vec}(0)$\n2. $(\\hat{B}^T \\otimes I_n) \\text{vec}(T) = \\text{vec}(B)$\n3. $(I_n \\otimes C) \\text{vec}(T) = \\text{vec}(\\hat{C})$\n这三个系统被堆叠成一个单一的大型系统 $\\mathbf{M} \\mathbf{t} \\approx \\mathbf{v}$，其中 $\\mathbf{t} = \\text{vec}(T)$。使用最小二乘法求解这个超定系统以得到 $\\mathbf{t}$，然后将解重塑为 $n \\times n$ 矩阵 $T$。\n\n**步骤 5：定量误差**\n利用计算出的对齐矩阵 $T$，我们使用归一化弗罗贝尼乌斯范数为三个矩阵方程中的每一个量化对齐误差：\n$$\n\\varepsilon_A = \\frac{\\lVert A T - T \\hat{A} \\rVert_F}{\\lVert A \\rVert_F + \\epsilon}, \\quad\n\\varepsilon_B = \\frac{\\lVert T \\hat{B} - B \\rVert_F}{\\lVert B \\rVert_F + \\epsilon}, \\quad\n\\varepsilon_C = \\frac{\\lVert C T - \\hat{C} \\rVert_F}{\\lVert C \\rVert_F + \\epsilon}\n$$\n其中加入 $\\epsilon = 10^{-12}$ 以保证数值稳定性。该测试用例的最终误差是这三个值的最大值，$e = \\max\\{\\varepsilon_A, \\varepsilon_B, \\varepsilon_C\\}$。对所有指定的测试用例重复这整个过程。", "answer": "```python\nimport numpy as np\n\ndef solve_case(A, B, C, D, n, m, p, N, s, r, seed):\n    \"\"\"\n    Solves a single test case for LTI system identification and alignment.\n    \"\"\"\n    # Step 1: Data Generation\n    rng = np.random.default_rng(seed)\n    u = rng.standard_normal(size=(N, m))\n    x = np.zeros((N + 1, n))\n    y = np.zeros((N, p))\n\n    for k in range(N):\n        y[k, :] = (C @ x[k, :]) + (D @ u[k, :])\n        x[k + 1, :] = (A @ x[k, :]) + (B @ u[k, :])\n\n    # Step 2: Markov Parameter Estimation\n    L = s + r + 10\n    num_eqs = N - L\n    \n    # Form regressor matrix U_reg and target Y_target\n    # U_reg has rows [u_k^T, u_{k-1}^T, ..., u_{k-L}^T] for k = L..N-1\n    U_reg = np.zeros((num_eqs, (L + 1) * m))\n    for i in range(L + 1):\n        U_reg[:, i * m:(i + 1) * m] = u[L - i:N - i, :]\n    \n    Y_target = y[L:N, :]\n    \n    # Solve U_reg @ M_hat_T = Y_target for M_hat_T\n    M_hat_T, _, _, _ = np.linalg.lstsq(U_reg, Y_target, rcond=None)\n    \n    M_hat = M_hat_T.T  # Shape: (p, (L + 1) * m)\n    \n    H_hat = [M_hat[:, i * m:(i + 1) * m] for i in range(L + 1)]\n    D_hat = H_hat[0]\n\n    # Step 3: Realization Recovery (Ho-Kalman)\n    H_sys = H_hat[1:]  # Strictly proper part\n    \n    # Build block Hankel matrix\n    H_sr = np.zeros((s * p, r * m))\n    for i in range(s):\n        for j in range(r):\n            if i + j < len(H_sys):\n                H_sr[i * p:(i + 1) * p, j * m:(j + 1) * m] = H_sys[i + j]\n\n    # SVD and truncation\n    U, S_vec, Vt = np.linalg.svd(H_sr, full_matrices=False)\n    U_n = U[:, :n]\n    S_n_vec = S_vec[:n]\n    Vt_n = Vt[:n, :]\n    \n    # Balanced realization factors\n    sqrt_Sigma_n = np.diag(np.sqrt(S_n_vec))\n    Obs = U_n @ sqrt_Sigma_n\n    Ctrl = sqrt_Sigma_n @ Vt_n\n    \n    C_hat = Obs[:p, :]\n    B_hat = Ctrl[:, :m]\n\n    # Shifted Hankel matrix for A_hat\n    H_prime_sr = np.zeros((s * p, r * m))\n    for i in range(s):\n        for j in range(r):\n            if i + j + 1 < len(H_sys):\n                H_prime_sr[i * p:(i + 1) * p, j * m:(j + 1) * m] = H_sys[i + j + 1]\n\n    inv_sqrt_Sigma_n = np.diag(1.0 / np.sqrt(S_n_vec))\n    V_n = Vt_n.T\n    A_hat = inv_sqrt_Sigma_n @ U_n.T @ H_prime_sr @ V_n @ inv_sqrt_Sigma_n\n\n    # Step 4: Similarity Alignment\n    # Form the stacked least-squares problem to solve for vec(T)\n    # A T - T A_hat = 0\n    M_A = np.kron(np.eye(n), A) - np.kron(A_hat.T, np.eye(n))\n    # T B_hat - B = 0  -> (B_hat.T kron I) vec(T) = vec(B)\n    M_B = np.kron(B_hat.T, np.eye(n))\n    # C T - C_hat = 0 -> (I kron C) vec(T) = vec(C_hat)\n    M_C = np.kron(np.eye(n), C)\n    \n    M_stack = np.vstack([M_A, M_B, M_C])\n    \n    v_A = np.zeros(n * n)\n    v_B = B.flatten('F')\n    v_C = C_hat.flatten('F')\n    v_stack = np.concatenate([v_A, v_B, v_C])\n    \n    t_vec, _, _, _ = np.linalg.lstsq(M_stack, v_stack, rcond=None)\n    T = t_vec.reshape((n, n), order='F')\n\n    # Step 5: Quantitative Error\n    eps = 1e-12\n    norm_A = np.linalg.norm(A, 'fro') + eps\n    norm_B = np.linalg.norm(B, 'fro') + eps\n    norm_C = np.linalg.norm(C, 'fro') + eps\n    \n    err_A = np.linalg.norm(A @ T - T @ A_hat, 'fro') / norm_A\n    err_B = np.linalg.norm(T @ B_hat - B, 'fro') / norm_B\n    err_C = np.linalg.norm(C @ T - C_hat, 'fro') / norm_C\n    \n    return max(err_A, err_B, err_C)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"A\": np.array([[0.7, 0.2], [-0.1, 0.9]]),\n            \"B\": np.array([[1.0], [0.5]]),\n            \"C\": np.array([[1.0, -0.3]]),\n            \"D\": np.array([[0.1]]),\n            \"dims\": {\"n\": 2, \"m\": 1, \"p\": 1},\n            \"params\": {\"N\": 800, \"s\": 5, \"r\": 5, \"seed\": 123},\n        },\n        # Case 2\n        {\n            \"A\": np.array([[0.6, 0.2, 0.0], [0.0, 0.7, 0.1], [0.0, -0.2, 0.8]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0], [0.5, -0.2]]),\n            \"C\": np.array([[1.0, 0.0, 0.3], [0.2, 0.8, -0.1]]),\n            \"D\": np.array([[0.0, 0.0], [0.0, 0.0]]),\n            \"dims\": {\"n\": 3, \"m\": 2, \"p\": 2},\n            \"params\": {\"N\": 1500, \"s\": 6, \"r\": 6, \"seed\": 456},\n        },\n        # Case 3\n        {\n            \"A\": np.array([[0.95]]),\n            \"B\": np.array([[1.2]]),\n            \"C\": np.array([[0.8]]),\n            \"D\": np.array([[0.4]]),\n            \"dims\": {\"n\": 1, \"m\": 1, \"p\": 1},\n            \"params\": {\"N\": 400, \"s\": 4, \"r\": 4, \"seed\": 789},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(\n            case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"],\n            case[\"dims\"][\"n\"], case[\"dims\"][\"m\"], case[\"dims\"][\"p\"],\n            case[\"params\"][\"N\"], case[\"params\"][\"s\"], case[\"params\"][\"r\"], case[\"params\"][\"seed\"]\n        )\n        results.append(error)\n    \n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2886056"}, {"introduction": "在辨识或学习到一个状态空间模型后，分析其动态特性是至关重要的一步。频率响应分析是一种强大的工具，它揭示了系统如何对不同频率的输入信号进行放大或衰减。本练习将引导您通过求解线性系统来计算模型的频率响应，从而将抽象的系统矩阵 $(A, B, C, D)$ 与其在频域中的具体行为联系起来，深化您对模型动态特性的理解。 [@problem_id:2886136]", "problem": "给你一系列离散时间单输入单输出 (SISO) 线性状态空间模型，这些模型是神经状态空间模型在平衡点附近的局部线性化结果。一个神经状态空间模型由参数化映射 $f_{\\theta}$ 和 $g_{\\theta}$ 组成，其状态和输出的演化方式为 $x_{k+1} = f_{\\theta}(x_k,u_k)$ 和 $y_k = g_{\\theta}(x_k,u_k)$。在平衡点附近进行小信号近似后，该模型线性化为离散时间线性时不变状态空间形式 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k + D u_k$，其中 $A$、$B$、$C$ 和 $D$ 是在平衡点处求值的雅可比矩阵。\n\n从离散时间信号的 $z$-变换和离散时间傅里叶变换 (DTFT) 的定义出发，并仅使用零初始条件下的线性时不变状态空间方程 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k + D u_k$，推导在单位圆 $z = e^{j\\omega}$ 上从输入 $u_k$ 到输出 $y_k$ 的复频率响应的频域表达式，然后求其幅度响应 $\\lvert H(e^{j\\omega}) \\rvert$。你的算法必须通过求解与 $A$ 的预解阵相关的线性系统来评估每个网格频率点的响应，不得使用任何预先推导的快捷公式。如果相关矩阵是数值奇异或病态的，则将幅度视为 $+\\infty$。\n\n角度单位说明：所有频率 $\\omega$ 的单位均为 弧度/样本。\n\n数值奇异性和病态规则：对于每个频率 $\\omega$，构造矩阵 $M(\\omega) = e^{j\\omega} I - A$。如果 $M(\\omega)$ 在 $2$-范数下的条件数超过 $10^{12}$，或者 $M(\\omega)$ 在数值线性代数中是奇异的（求解失败），则在该 $\\omega$ 处定义 $\\lvert H(e^{j\\omega}) \\rvert = +\\infty$。在最终输出中，将 $+\\infty$ 表示为字符串 $\\,\\text{inf}\\,$。\n\n对于以下每个测试用例，计算在指定频率网格上 $\\lvert H(e^{j\\omega}) \\rvert$ 的最大值。每个测试用例返回一个标量值。当最大值为有限时，将其四舍五入到六位小数。当最大值为无穷大时，打印 $\\,\\text{inf}\\,$。\n\n所有测试用例共用的频率网格是 $\\Omega = [\\,0,\\ \\pi/4,\\ \\pi/2,\\ 3\\pi/4,\\ \\pi\\,]$。\n\n测试套件：\n- 测试用例 $1$（稳定的二阶类振荡器）：\n  - $A_1 = \\begin{bmatrix} 0.7 & -0.4 \\\\ 0.4 & 0.7 \\end{bmatrix}$, $B_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$, $C_1 = \\begin{bmatrix} 1.0 & 0.0 \\end{bmatrix}$, $D_1 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n- 测试用例 $2$（非零直通项）：\n  - $A_2 = \\begin{bmatrix} 0.2 & 0.0 \\\\ 0.0 & 0.5 \\end{bmatrix}$, $B_2 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$, $C_2 = \\begin{bmatrix} 0.5 & -0.5 \\end{bmatrix}$, $D_2 = \\begin{bmatrix} 0.3 \\end{bmatrix}$。\n- 测试用例 $3$（单位圆上的临界极点导致在 $\\omega = 0$ 处产生共振）：\n  - $A_3 = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 0.2 \\end{bmatrix}$, $B_3 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$, $C_3 = \\begin{bmatrix} 1.0 & 0.0 \\end{bmatrix}$, $D_3 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n- 测试用例 $4$（零输入-状态通道；恒零响应）：\n  - $A_4 = \\begin{bmatrix} 0.9 \\end{bmatrix}$, $B_4 = \\begin{bmatrix} 0.0 \\end{bmatrix}$, $C_4 = \\begin{bmatrix} 1.0 \\end{bmatrix}$, $D_4 = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n\n实现要求：\n- 对于每个 $\\omega \\in \\Omega$，设置 $z = e^{j\\omega}$，构造 $M(\\omega) = z I - A$。如果 $M(\\omega)$ 是良态的，则求解 $M(\\omega) X(\\omega) = B$ 得到 $X(\\omega)$，然后根据 $X(\\omega)$ 和给定的矩阵计算复标量 $H(e^{j\\omega})$。取其幅度，并通过取最大值在整个 $\\Omega$ 上进行聚合。\n- 病态阈值：使用 $2$-范数下的条件数截止值 $10^{12}$ 来判断在该频率处是否将 $\\lvert H(e^{j\\omega}) \\rvert$ 设置为 $+\\infty$。\n- 将最终输出表示为每个测试用例一个标量：$\\Omega$ 上的最大幅度。对于有限的最大值，四舍五入到六位小数。对于无穷大的最大值，打印 $\\,\\text{inf}\\,$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含与四个测试用例相对应的四个结果，形式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 遵循上述的四舍五入和无穷大约定。", "solution": "该问题要求对几个离散时间线性时不变 (LTI) 状态空间模型进行频率响应幅度的推导和计算。推导必须从第一性原理（即 $z$-变换的定义）出发，而计算必须遵循一个涉及求解线性系统的特定数值程序。\n\n让我们从给定的离散时间 LTI 系统的状态空间表示开始：\n$$x_{k+1} = A x_k + B u_k$$\n$$y_k = C x_k + D u_k$$\n此处，$k \\in \\mathbb{Z}$ 是时间索引，$x_k \\in \\mathbb{R}^n$ 是状态向量，$u_k \\in \\mathbb{R}$ 是标量输入，$y_k \\in \\mathbb{R}$ 是标量输出。矩阵 $A, B, C, D$ 具有相容的维度：$A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times 1}$，$C \\in \\mathbb{R}^{1 \\times n}$，以及 $D \\in \\mathbb{R}^{1 \\times 1}$。\n\n离散时间序列 $f_k$ 的 $z$-变换定义为 $F(z) = \\mathcal{Z}\\{f_k\\} = \\sum_{k=0}^{\\infty} f_k z^{-k}$，其中 $z$ 是一个复变量。$z$-变换的一个关键特性是时移特性，即对于序列 $f_{k+1}$，其变换为 $\\mathcal{Z}\\{f_{k+1}\\} = z F(z) - z f_0$。\n\n我们给定的条件是零初始状态，即 $x_0 = 0$。对状态和输出方程应用 $z$-变换，我们得到：\n1.  状态方程的变换：\n    $\\mathcal{Z}\\{x_{k+1}\\} = \\mathcal{Z}\\{A x_k + B u_k\\}$\n    使用线性和时移特性，并设 $x_0=0$：\n    $$z X(z) = A X(z) + B U(z)$$\n    其中 $X(z)$、$U(z)$ 和 $Y(z)$ 分别是序列 $x_k$、$u_k$ 和 $y_k$ 的 $z$-变换。\n\n2.  输出方程的变换：\n    $\\mathcal{Z}\\{y_k\\} = \\mathcal{Z}\\{C x_k + D u_k\\}$\n    使用线性特性：\n    $$Y(z) = C X(z) + D U(z)$$\n\n我们的目标是找到传递函数 $H(z) = Y(z)/U(z)$，它表示 $z$-域中的输入-输出关系。为此，我们首先从变换后的状态方程中求解 $X(z)$：\n$$z X(z) - A X(z) = B U(z)$$\n$$(zI - A) X(z) = B U(z)$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。如果矩阵 $(zI - A)$ 是可逆的，我们可以写出：\n$$X(z) = (zI - A)^{-1} B U(z)$$\n矩阵 $(zI - A)^{-1}$ 被称为矩阵 $A$ 的预解阵。\n\n现在，我们将这个 $X(z)$ 的表达式代入到变换后的输出方程中：\n$$Y(z) = C \\left( (zI - A)^{-1} B U(z) \\right) + D U(z)$$\n提取出 $U(z)$：\n$$Y(z) = \\left[ C (zI - A)^{-1} B + D \\right] U(z)$$\n因此，传递函数 $H(z)$ 为：\n$$H(z) = \\frac{Y(z)}{U(z)} = C (zI - A)^{-1} B + D$$\n\n系统的频率响应是通过在复平面的单位圆（其中 $z = e^{j\\omega}$）上评估传递函数 $H(z)$ 得到的。这里，$\\omega$ 是归一化角频率，单位为 弧度/样本，且 $\\omega \\in [-\\pi, \\pi]$。\n$$H(e^{j\\omega}) = C (e^{j\\omega}I - A)^{-1} B + D$$\n频率响应的幅度为 $\\lvert H(e^{j\\omega}) \\rvert$。\n\n问题要求我们避免直接计算矩阵的逆，而是必须求解一个线性方程组。让我们为每个频率 $\\omega$ 定义一个复向量 $X(\\omega)$。这个向量不是状态的 $z$-变换 $X(z)$，而是从它派生出的一个依赖于频率的量。令 $M(\\omega) = e^{j\\omega}I - A$。$H(e^{j\\omega})$ 表达式中的项 $(e^{j\\omega}I - A)^{-1} B$ 可以通过求解以下线性系统来计算：\n$$M(\\omega) X(\\omega) = B$$\n求解向量 $X(\\omega)$。一旦求得 $X(\\omega)$，频率响应就可计算为：\n$$H(e^{j\\omega}) = C X(\\omega) + D$$\n这种方法在数值上比直接求逆更可取。\n\n系统的稳定性和响应特性由 $A$ 的特征值（即系统的极点）决定。如果 $A$ 的某个特征值 $\\lambda_p$ 位于单位圆上，即 $|\\lambda_p|=1$，那么对于某个频率 $\\omega_p$，我们有 $\\lambda_p = e^{j\\omega_p}$。在这个频率下，$z = e^{j\\omega_p} = \\lambda_p$，矩阵 $M(\\omega_p) = e^{j\\omega_p}I - A = \\lambda_p I - A$ 会变得奇异。这对应于单位圆上的一个极点，导致无穷大的响应幅度（共振）。\n\n在数值计算中，真正的奇异性很少见。取而代之的是，我们检查矩阵 $M(\\omega)$ 是否是病态的，这表明它接近奇异。条件数 $\\mathrm{cond}(M)$ 量化了这一点。大的条件数意味着输入中的微小扰动可能导致解的巨大变化，使得线性系统的解不可靠。问题指定了一个 $10^{12}$ 的阈值：如果 $\\mathrm{cond}_2(M(\\omega)) > 10^{12}$，或者数值求解器因奇异性而失败，我们必须将幅度视为无穷大，即 $\\lvert H(e^{j\\omega}) \\rvert = +\\infty$。\n\n总体算法如下：\n对于每个给定的测试用例 $(A, B, C, D)$：\n1.  初始化一个空列表来存储幅度值。\n2.  对于指定网格 $\\Omega = [0, \\pi/4, \\pi/2, 3\\pi/4, \\pi]$ 中的每个频率 $\\omega$：\n    a.  设置 $z = e^{j\\omega}$。\n    b.  构造复数矩阵 $M(\\omega) = zI - A$。\n    c.  计算 $M(\\omega)$ 的 $2$-范数条件数。\n    d.  如果 $\\mathrm{cond}_2(M(\\omega)) > 10^{12}$ 或者使用 $M(\\omega)$ 求解失败，则此频率下的幅度为 $+\\infty$。\n    e.  否则，求解线性系统 $M(\\omega) X(\\omega) = B$ 得到复向量 $X(\\omega)$。\n    f.  计算复标量响应 $H(e^{j\\omega}) = C X(\\omega) + D$。\n    g.  计算幅度 $\\lvert H(e^{j\\omega}) \\rvert$。\n    h.  将计算出的幅度（有限或无穷）添加到列表中。\n3.  找到幅度列表中的最大值。\n4.  如果最大值是有限的，则将其格式化为六位小数。如果是无穷大，则表示为 'inf'。\n此程序将应用于所有测试用例。", "answer": "```python\nimport numpy as np\n\ndef calculate_max_magnitude(A_in, B_in, C_in, D_in, omega_grid, cond_thresh):\n    \"\"\"\n    Calculates the maximum magnitude of the frequency response for a state-space model.\n\n    The function computes the frequency response H(e^jω) = C(e^jω*I - A)^-1 * B + D\n    by solving a linear system for each ω in the grid. It handles ill-conditioning\n    by checking the matrix condition number against a threshold.\n    \"\"\"\n    # Convert input lists to numpy arrays with appropriate types and shapes\n    A = np.array(A_in, dtype=np.float64)\n    B = np.array(B_in, dtype=np.float64).reshape(-1, 1)\n    C = np.array(C_in, dtype=np.float64).reshape(1, -1)\n    D = np.array(D_in, dtype=np.float64).reshape(1, 1)\n    \n    n = A.shape[0]\n    I = np.eye(n, dtype=np.complex128)\n    \n    magnitudes = []\n\n    for omega in omega_grid:\n        z = np.exp(1j * omega)\n        M = z * I - A\n        is_infinite = False\n\n        # Check for singularity or ill-conditioning\n        try:\n            # np.linalg.cond can be expensive, but is required by the problem spec.\n            # A LinAlgError might be raised for exactly singular matrices.\n            cond_num = np.linalg.cond(M)\n            if cond_num > cond_thresh:\n                is_infinite = True\n        except np.linalg.LinAlgError:\n            is_infinite = True\n\n        if is_infinite:\n            magnitudes.append(np.inf)\n            continue\n            \n        # Solve the linear system (zI - A)X = B\n        try:\n            # X(ω) is the frequency-dependent state response vector\n            X_omega = np.linalg.solve(M, B)\n            \n            # H(e^jω) = C*X(ω) + D\n            H_omega = C @ X_omega + D\n            magnitudes.append(np.abs(H_omega[0, 0]))\n        except np.linalg.LinAlgError:\n            # This is a fallback; the condition number check should pre-empt this.\n            magnitudes.append(np.inf)\n            \n    max_mag = np.max(magnitudes)\n    \n    if np.isinf(max_mag):\n        return \"inf\"\n    else:\n        return f\"{max_mag:.6f}\"\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the result for each, printing the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: stable second-order oscillator-like\n        {\n            \"A\": [[0.7, -0.4], [0.4, 0.7]],\n            \"B\": [[1.0], [0.0]],\n            \"C\": [[1.0, 0.0]],\n            \"D\": [[0.0]]\n        },\n        # Test Case 2: nonzero direct term\n        {\n            \"A\": [[0.2, 0.0], [0.0, 0.5]],\n            \"B\": [[1.0], [1.0]],\n            \"C\": [[0.5, -0.5]],\n            \"D\": [[0.3]]\n        },\n        # Test Case 3: marginal pole on the unit circle\n        {\n            \"A\": [[1.0, 0.0], [0.0, 0.2]],\n            \"B\": [[1.0], [0.0]],\n            \"C\": [[1.0, 0.0]],\n            \"D\": [[0.0]]\n        },\n        # Test Case 4: zero input-to-state channel\n        {\n            \"A\": [[0.9]],\n            \"B\": [[0.0]],\n            \"C\": [[1.0]],\n            \"D\": [[0.0]]\n        }\n    ]\n    \n    omega_grid = [0.0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi]\n    cond_thresh = 1e12\n    \n    results = []\n    for case in test_cases:\n        result = calculate_max_magnitude(\n            case[\"A\"], case[\"B\"], case[\"C\"], case[\"D\"], omega_grid, cond_thresh\n        )\n        results.append(result)\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2886136"}]}