{"hands_on_practices": [{"introduction": "虽然沃尔泰拉级数提供了一个通用的非线性系统表示，但其高维核函数可能显得抽象。本练习旨在通过将其与一个结构更直观、应用广泛的模型——维纳（Wiener）模型——联系起来，来揭开其神秘面纱。你将推导一个由线性时不变（LTI）滤波器和静态非线性环节级联组成的维纳系统的沃尔泰拉核，从而深入理解抽象的核函数是如何由系统中更简单的物理或数学模块（如脉冲响应$h(t)$和非线性函数的泰勒级数展开）决定的。[@problem_id:2887040]", "problem": "考虑一个连续时间维纳（Wiener）系统，该系统由一个线性时不变（LTI）子系统后跟一个静态无记忆非线性环节组成。设 LTI 子系统的特征为其冲激响应 $h(t)$，假设 $h(t)$ 是绝对可积且因果的，因此对于任何输入 $x(t)$，中间信号为 $v(t) = \\int_{0}^{\\infty} h(\\sigma)\\,x(t-\\sigma)\\,d\\sigma$。输出为 $y(t) = \\phi(v(t))$，其中 $\\phi$ 是一个标量静态非线性函数，在 $0$ 的邻域内是实解析的，且 $\\phi(0)=0$。\n\n假设该输入-输出映射允许关于零输入进行 Volterra 级数表示，其对称 Volterra 核 $\\{k_{n}\\}_{n\\geq 1}$ 的标准形式为\n$$\ny(t) = \\sum_{n=1}^{\\infty} \\int_{0}^{\\infty}\\cdots\\int_{0}^{\\infty} k_{n}(\\tau_{1},\\ldots,\\tau_{n}) \\prod_{i=1}^{n} x(t-\\tau_{i})\\, d\\tau_{1}\\cdots d\\tau_{n}.\n$$\n从线性时不变性、$\\phi$ 在 $0$ 附近的泰勒展开以及 Volterra 级数是输入-输出泛函在原点唯一的对称多重线性展开的定义出发，证明此维纳系统的 Volterra 核可以用 $h$ 和 $\\phi$ 在 $0$ 处的导数表示。然后，利用此框架，推导二阶 Volterra 核 $k_{2}(\\tau_{1},\\tau_{2})$ 的闭式表达式。\n\n你的最终答案必须是 $k_{2}(\\tau_{1},\\tau_{2})$ 的单个闭式解析表达式。不要求也不允许进行数值近似，且不涉及任何单位。", "solution": "所述问题具有科学依据，提法恰当，并包含足够信息以获得唯一解。我们将着手推导。\n\n该系统是一个维纳（Wiener）模型，由一个线性时不变（LTI）系统后跟一个静态无记忆非线性环节组成。中间信号 $v(t)$ 是具有因果冲激响应 $h(t)$ 和输入 $x(t)$ 的 LTI 模块的输出。它由卷积积分给出：\n$$\nv(t) = \\int_{0}^{\\infty} h(\\sigma) x(t-\\sigma) d\\sigma\n$$\n系统的最终输出 $y(t)$ 是将 $v(t)$ 通过静态非线性环节 $\\phi$ 得到的：\n$$\ny(t) = \\phi(v(t))\n$$\n给定条件 $\\phi$ 是在 $v=0$ 邻域内的实解析函数，且 $\\phi(0)=0$。这允许将 $\\phi(v)$ 在点 $v=0$ 附近进行泰勒级数展开：\n$$\n\\phi(v) = \\sum_{n=1}^{\\infty} \\frac{\\phi^{(n)}(0)}{n!} v^{n}\n$$\n求和从 $n=1$ 开始，因为条件 $\\phi(0)=0$ 意味着零阶项为零。此处，$\\phi^{(n)}(0)$ 表示 $\\phi$ 对其自变量的 $n$ 阶导数在 $0$ 处的值。\n\n将 $y(t) = \\phi(v(t))$ 的表达式代入此级数，我们得到：\n$$\ny(t) = \\sum_{n=1}^{\\infty} \\frac{\\phi^{(n)}(0)}{n!} [v(t)]^{n}\n$$\n现在，我们将 $v(t)$ 的卷积积分代入此表达式：\n$$\ny(t) = \\sum_{n=1}^{\\infty} \\frac{\\phi^{(n)}(0)}{n!} \\left( \\int_{0}^{\\infty} h(\\sigma) x(t-\\sigma) d\\sigma \\right)^{n}\n$$\n积分的 $n$ 次方可以通过使用不同的积分变量写成一个 $n$ 维积分：\n$$\n\\left( \\int_{0}^{\\infty} h(\\sigma) x(t-\\sigma) d\\sigma \\right)^{n} = \\int_{0}^{\\infty} \\cdots \\int_{0}^{\\infty} h(\\tau_{1}) x(t-\\tau_{1}) \\cdots h(\\tau_{n}) x(t-\\tau_{n}) d\\tau_{1} \\cdots d\\tau_{n}\n$$\n这可以通过对涉及 $h$ 的项和涉及 $x$ 的项进行分组来重新整理：\n$$\n\\left( \\int_{0}^{\\infty} h(\\sigma) x(t-\\sigma) d\\sigma \\right)^{n} = \\int_{0}^{\\infty} \\cdots \\int_{0}^{\\infty} \\left( \\prod_{i=1}^{n} h(\\tau_{i}) \\right) \\left( \\prod_{i=1}^{n} x(t-\\tau_{i}) \\right) d\\tau_{1} \\cdots d\\tau_{n}\n$$\n将此代回 $y(t)$ 的级数表达式中：\n$$\ny(t) = \\sum_{n=1}^{\\infty} \\frac{\\phi^{(n)}(0)}{n!} \\int_{0}^{\\infty} \\cdots \\int_{0}^{\\infty} \\left( \\prod_{i=1}^{n} h(\\tau_{i}) \\right) \\left( \\prod_{i=1}^{n} x(t-\\tau_{i}) \\right) d\\tau_{1} \\cdots d\\tau_{n}\n$$\n我们可以将常数系数移入积分内部：\n$$\ny(t) = \\sum_{n=1}^{\\infty} \\int_{0}^{\\infty} \\cdots \\int_{0}^{\\infty} \\left( \\frac{\\phi^{(n)}(0)}{n!} \\prod_{i=1}^{n} h(\\tau_{i}) \\right) \\left( \\prod_{i=1}^{n} x(t-\\tau_{i}) \\right) d\\tau_{1} \\cdots d\\tau_{n}\n$$\n此表达式是 Volterra 级数的形式。问题将系统的 Volterra 级数展开（具有对称核 $k_n$）定义为：\n$$\ny(t) = \\sum_{n=1}^{\\infty} \\int_{0}^{\\infty}\\cdots\\int_{0}^{\\infty} k_{n}(\\tau_{1},\\ldots,\\tau_{n}) \\prod_{i=1}^{n} x(t-\\tau_{i})\\, d\\tau_{1}\\cdots d\\tau_{n}\n$$\n通过比较 $y(t)$ 的两个级数表达式，我们可以将乘以输入乘积的被积因子识别为 Volterra 核。让我们将从我们的展开式中得到的核表示为 $k'_{n}(\\tau_{1},\\ldots,\\tau_{n})$：\n$$\nk'_{n}(\\tau_{1},\\ldots,\\tau_{n}) = \\frac{\\phi^{(n)}(0)}{n!} \\prod_{i=1}^{n} h(\\tau_{i})\n$$\n问题指定 Volterra 核 $k_{n}$ 必须是对称的。一个对称核在其自变量的任何排列下都保持不变。即，对于任何排列 $\\pi$，都有 $k_n(\\tau_1, \\ldots, \\tau_n) = k_n(\\tau_{\\pi(1)}, \\ldots, \\tau_{\\pi(n)})$。\n\n让我们来检验我们推导出的核 $k'_{n}$ 的对称性。项 $\\prod_{i=1}^{n} h(\\tau_{i}) = h(\\tau_{1})h(\\tau_{2})\\cdots h(\\tau_{n})$ 在变量 $\\{\\tau_{1}, \\ldots, \\tau_{n}\\}$ 的任何排列下都是不变的，因为乘法是可交换的。因此，核 $k'_{n}(\\tau_{1},\\ldots,\\tau_{n})$ 本身就是对称的。\n\n一个解析泛函由带对称核的 Volterra 级数表示是唯一的。由于我们推导出的核 $k'_{n}$ 是对称的，它必定是唯一的对称 Volterra 核 $k_{n}$。因此，我们已经确立了维纳系统 $n$ 阶 Volterra 核的一般形式：\n$$\nk_{n}(\\tau_{1},\\ldots,\\tau_{n}) = \\frac{\\phi^{(n)}(0)}{n!} \\prod_{i=1}^{n} h(\\tau_{i})\n$$\n问题特别要求二阶核 $k_{2}(\\tau_{1},\\tau_{2})$。我们通过在通用公式中令 $n=2$ 来得到它：\n$$\nk_{2}(\\tau_{1},\\tau_{2}) = \\frac{\\phi^{(2)}(0)}{2!} \\prod_{i=1}^{2} h(\\tau_{i})\n$$\n展开阶乘和乘积，得到显式形式：\n$$\nk_{2}(\\tau_{1},\\tau_{2}) = \\frac{\\phi^{(2)}(0)}{2} h(\\tau_{1}) h(\\tau_{2})\n$$\n这就是指定维纳系统的二阶对称 Volterra 核的闭式表达式。它可以分解为单变量函数的乘积，这是维纳系统核的一个特征属性。", "answer": "$$\\boxed{\\frac{\\phi^{(2)}(0)}{2} h(\\tau_{1}) h(\\tau_{2})}$$", "id": "2887040"}, {"introduction": "非线性系统与线性系统的关键区别在于它们对正弦输入的响应方式。本练习直接探讨了这一核心差异，要求你分析一个简单的三阶沃尔泰拉模型在双音（two-tone）余弦信号输入下的输出。通过运用三角恒等式进行推导，你将亲眼见证谐波失真（$2\\omega_1, 3\\omega_1$）和互调失真（$\\omega_1 \\pm \\omega_2, 2\\omega_1 \\pm \\omega_2$）等非线性现象的产生过程，这些都是模型中多项式项的直接结果。这个实践过程对于理解通信、音频处理和射频工程等领域中的关键概念至关重要。[@problem_id:2887101]", "problem": "考虑一个具有有限记忆的离散时间三阶Volterra模型，由以下截断Volterra级数定义：\n$$\ny[n] \\;=\\; \\sum_{m=0}^{1} h_{1}[m]\\,x[n-m] \\;+\\; \\sum_{m_{1}=0}^{1}\\sum_{m_{2}=0}^{1} h_{2}[m_{1},m_{2}]\\,x[n-m_{1}]\\,x[n-m_{2}] \\;+\\; \\sum_{m_{1}=0}^{0}\\sum_{m_{2}=0}^{0}\\sum_{m_{3}=0}^{0} h_{3}[m_{1},m_{2},m_{3}]\\,x[n-m_{1}]\\,x[n-m_{2}]\\,x[n-m_{3}]\\,,\n$$\n其非零Volterra核仅在以下位置：\n$$\nh_{1}[0]=\\alpha_{0},\\quad h_{1}[1]=\\alpha_{1},\\quad h_{2}[0,0]=\\beta_{0},\\quad h_{2}[1,1]=\\beta_{1},\\quad h_{3}[0,0,0]=\\gamma\\,,\n$$\n且所有其他核系数恒为零。设输入为一个双音信号：\n$$\nx[n] \\;=\\; A\\cos(\\omega_{1} n) \\;+\\; B\\cos(\\omega_{2} n)\\,,\n$$\n其中 $A,B,\\alpha_{0},\\alpha_{1},\\beta_{0},\\beta_{1},\\gamma \\in \\mathbb{R}$，并且 $\\omega_{1},\\omega_{2}\\in(0,\\pi)$ 是实数角频率（单位为弧度/样本），且 $\\omega_{1}\\neq \\omega_{2}$。从Volterra展开式的定义和标准三角积化和差恒等式出发，推导出 $y[n]$ 的一个完全简化的闭式表达式，该表达式表示为余弦项之和，并用 $A$、$B$、$\\alpha_{0}$、$\\alpha_{1}$、$\\beta_{0}$、$\\beta_{1}$、$\\gamma$、$\\omega_{1}$ 和 $\\omega_{2}$ 明确表示其幅度和相位。在你的推导过程中，明确指出输出端存在的不同角频率。你最终报告的答案必须是 $y[n]$ 的单一解析表达式。不需要进行数值四舍五入，也无需报告单位。", "solution": "该问题陈述是非线性系统分析领域一个适定的练习，并且在科学上是合理的。它是完整、一致的，并且需要直接应用信号处理理论中的既定原理。因此，该问题是有效的。\n\n所指定的离散时间三阶Volterra模型的输出 $y[n]$ 由下式给出：\n$$\ny[n] = \\sum_{m=0}^{1} h_{1}[m]\\,x[n-m] + \\sum_{m_{1}=0}^{1}\\sum_{m_{2}=0}^{1} h_{2}[m_{1},m_{2}]\\,x[n-m_{1}]\\,x[n-m_{2}] + \\sum_{m_{1}=0}^{0}\\sum_{m_{2}=0}^{0}\\sum_{m_{3}=0}^{0} h_{3}[m_{1},m_{2},m_{3}]\\,x[n-m_{1}]\\,x[n-m_{2}]\\,x[n-m_{3}]\n$$\n鉴于非零Volterra核为 $h_{1}[0]=\\alpha_{0}$、$h_{1}[1]=\\alpha_{1}$、$h_{2}[0,0]=\\beta_{0}$、$h_{2}[1,1]=\\beta_{1}$ 和 $h_{3}[0,0,0]=\\gamma$，且所有其他核均为零，系统方程简化为：\n$$\ny[n] = \\left(\\alpha_{0}x[n] + \\alpha_{1}x[n-1]\\right) + \\left(\\beta_{0}x^{2}[n] + \\beta_{1}x^{2}[n-1]\\right) + \\gamma x^{3}[n]\n$$\n我们分别将这三个分量表示为 $y_{1}[n]$、$y_{2}[n]$ 和 $y_{3}[n]$，对应于一阶、二阶和三阶项。输入信号为 $x[n] = A\\cos(\\omega_{1} n) + B\\cos(\\omega_{2} n)$。\n\n**一阶项, $y_{1}[n]$**\n线性项为 $y_{1}[n] = \\alpha_{0}x[n] + \\alpha_{1}x[n-1]$。代入 $x[n]$ 及其延迟版本 $x[n-1] = A\\cos(\\omega_{1}(n-1)) + B\\cos(\\omega_{2}(n-1))$ 的表达式：\n$$\ny_{1}[n] = \\alpha_{0}\\left(A\\cos(\\omega_{1} n) + B\\cos(\\omega_{2} n)\\right) + \\alpha_{1}\\left(A\\cos(\\omega_{1}n - \\omega_{1}) + B\\cos(\\omega_{2}n - \\omega_{2})\\right)\n$$\n此项包含基频 $\\omega_{1}$ 和 $\\omega_{2}$。\n\n**二阶项, $y_{2}[n]$**\n二次项为 $y_{2}[n] = \\beta_{0}x^{2}[n] + \\beta_{1}x^{2}[n-1]$。我们首先计算 $x^{2}[n]$：\n$$\nx^{2}[n] = \\left(A\\cos(\\omega_{1} n) + B\\cos(\\omega_{2} n)\\right)^{2} = A^{2}\\cos^{2}(\\omega_{1} n) + B^{2}\\cos^{2}(\\omega_{2} n) + 2AB\\cos(\\omega_{1} n)\\cos(\\omega_{2} n)\n$$\n使用三角恒等式 $\\cos^{2}(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$ 和 $\\cos(u)\\cos(v) = \\frac{1}{2}(\\cos(u-v) + \\cos(u+v))$，我们得到：\n$$\nx^{2}[n] = A^{2}\\left(\\frac{1}{2} + \\frac{1}{2}\\cos(2\\omega_{1} n)\\right) + B^{2}\\left(\\frac{1}{2} + \\frac{1}{2}\\cos(2\\omega_{2} n)\\right) + 2AB\\left(\\frac{1}{2}\\cos((\\omega_{1}-\\omega_{2})n) + \\frac{1}{2}\\cos((\\omega_{1}+\\omega_{2})n)\\right)\n$$\n$$\nx^{2}[n] = \\frac{A^{2}+B^{2}}{2} + \\frac{A^{2}}{2}\\cos(2\\omega_{1} n) + \\frac{B^{2}}{2}\\cos(2\\omega_{2} n) + AB\\cos((\\omega_{1}-\\omega_{2})n) + AB\\cos((\\omega_{1}+\\omega_{2})n)\n$$\n$x^{2}[n-1]$ 的表达式可通过将 $n$ 替换为 $n-1$ 得到。将这些代入 $y_{2}[n]$ 的表达式中，得到：\n$$\n\\begin{aligned}\ny_{2}[n] &= \\beta_{0}x^{2}[n] + \\beta_{1}x^{2}[n-1] \\\\\n&= (\\beta_{0}+\\beta_{1})\\frac{A^{2}+B^{2}}{2} \\\\\n&\\quad+ \\frac{A^{2}}{2}(\\beta_{0}\\cos(2\\omega_{1} n) + \\beta_{1}\\cos(2\\omega_{1}n - 2\\omega_{1})) \\\\\n&\\quad+ \\frac{B^{2}}{2}(\\beta_{0}\\cos(2\\omega_{2} n) + \\beta_{1}\\cos(2\\omega_{2}n - 2\\omega_{2})) \\\\\n&\\quad+ AB(\\beta_{0}\\cos((\\omega_{1}-\\omega_{2})n) + \\beta_{1}\\cos((\\omega_{1}-\\omega_{2})n - (\\omega_{1}-\\omega_{2}))) \\\\\n&\\quad+ AB(\\beta_{0}\\cos((\\omega_{1}+\\omega_{2})n) + \\beta_{1}\\cos((\\omega_{1}+\\omega_{2})n - (\\omega_{1}+\\omega_{2})))\n\\end{aligned}\n$$\n此项产生一个直流分量（频率为 $0$）、位于 $2\\omega_{1}$ 和 $2\\omega_{2}$ 的二次谐波，以及位于频率 $|\\omega_{1}-\\omega_{2}|$ 和 $\\omega_{1}+\\omega_{2}$ 的二阶互调产物。\n\n**三阶项, $y_{3}[n]$**\n三次项为 $y_{3}[n] = \\gamma x^{3}[n]$。我们展开 $x^{3}[n]$：\n$$\nx^{3}[n] = (A\\cos(\\omega_{1} n) + B\\cos(\\omega_{2} n))^{3} = A^{3}\\cos^{3}(\\omega_{1} n) + 3A^{2}B\\cos^{2}(\\omega_{1} n)\\cos(\\omega_{2} n) + 3AB^{2}\\cos(\\omega_{1} n)\\cos^{2}(\\omega_{2} n) + B^{3}\\cos^{3}(\\omega_{2} n)\n$$\n使用恒等式 $\\cos^{3}(\\theta) = \\frac{1}{4}(3\\cos(\\theta)+\\cos(3\\theta))$ 和 $\\cos^{2}(\\theta)\\cos(\\phi) = \\frac{1}{2}\\cos(\\phi) + \\frac{1}{4}(\\cos(2\\theta-\\phi)+\\cos(2\\theta+\\phi))$，我们展开每一项：\n$$\nA^{3}\\cos^{3}(\\omega_{1} n) = \\frac{3A^{3}}{4}\\cos(\\omega_{1} n) + \\frac{A^{3}}{4}\\cos(3\\omega_{1} n)\n$$\n$$\n3A^{2}B\\cos^{2}(\\omega_{1} n)\\cos(\\omega_{2} n) = 3A^{2}B\\left(\\frac{1}{2}\\cos(\\omega_{2} n) + \\frac{1}{4}\\cos((2\\omega_{1}-\\omega_{2})n) + \\frac{1}{4}\\cos((2\\omega_{1}+\\omega_{2})n)\\right)\n$$\n另外两项可通过对称性求得。对 $x^{3}[n]$ 的所有部分求和并按频率分组：\n- 在 $\\omega_{1}$ 处：$(\\frac{3A^{3}}{4} + \\frac{3AB^{2}}{2})\\cos(\\omega_{1} n) = \\frac{3A}{4}(A^{2}+2B^{2})\\cos(\\omega_{1} n)$\n- 在 $\\omega_{2}$ 处：$(\\frac{3B^{3}}{4} + \\frac{3A^{2}B}{2})\\cos(\\omega_{2} n) = \\frac{3B}{4}(B^{2}+2A^{2})\\cos(\\omega_{2} n)$\n- 在 $3\\omega_{1}$ 处：$\\frac{A^{3}}{4}\\cos(3\\omega_{1} n)$\n- 在 $3\\omega_{2}$ 处：$\\frac{B^{3}}{4}\\cos(3\\omega_{2} n)$\n- 在 $2\\omega_{1} \\pm \\omega_{2}$ 处：$\\frac{3A^{2}B}{4}\\cos((2\\omega_{1}\\pm\\omega_{2})n)$\n- 在 $\\omega_{1} \\pm 2\\omega_{2}$ 处：$\\frac{3AB^{2}}{4}\\cos((\\omega_{1}\\pm 2\\omega_{2})n)$\n\n因此，$y_{3}[n] = \\gamma x^{3}[n]$ 包含位于 $3\\omega_{1}$ 和 $3\\omega_{2}$ 的三次谐波，位于 $|2\\omega_{1}-\\omega_{2}|$、$2\\omega_{1}+\\omega_{2}$、$|\\omega_{1}-2\\omega_{2}|$ 和 $\\omega_{1}+2\\omega_{2}$ 的三阶互调产物，并且也对基频 $\\omega_{1}$ 和 $\\omega_{2}$ 产生贡献。\n\n**总输出信号, $y[n]$**\n总输出 $y[n] = y_{1}[n] + y_{2}[n] + y_{3}[n]$ 是所有推导出的分量之和。明确地说，所产生的不同角频率有：\n$0$ (DC), $\\omega_{1}$, $\\omega_{2}$, $2\\omega_{1}$, $2\\omega_{2}$, $|\\omega_{1}-\\omega_{2}|$, $\\omega_{1}+\\omega_{2}$, $3\\omega_{1}$, $3\\omega_{2}$, $|2\\omega_{1}-\\omega_{2}|$, $2\\omega_{1}+\\omega_{2}$, $|\\omega_{1}-2\\omega_{2}|$, and $\\omega_{1}+2\\omega_{2}$。\n\n合并所有项， $y[n]$ 的最终表达式是一个余弦和。位于 $\\omega_{1}$ 和 $\\omega_{2}$ 的项同时接收来自级数的一阶和三阶部分的贡献。所有其他频率分量均仅由二阶项或三阶项单独产生。\n\n完整的表达式通过对各分量求和构建：\n- 来自 $y_{2}[n]$ 的直流项。\n- 来自 $y_{1}[n]$ 和 $y_{3}[n]$ 的 $\\omega_{1}$ 项。\n- 来自 $y_{1}[n]$ 和 $y_{3}[n]$ 的 $\\omega_{2}$ 项。\n- 所有其他谐波和互调项仅来自 $y_{2}[n]$ 或 $y_{3}[n]$。\n最终的闭式表达式整理如下。", "answer": "$$\n\\boxed{\n\\begin{aligned}\n&(\\beta_{0} + \\beta_{1})\\frac{A^{2}+B^{2}}{2} \\\\\n&+ \\left( A\\alpha_{0} + \\frac{3\\gamma A}{4}(A^{2}+2B^{2}) \\right) \\cos(\\omega_{1} n) + A\\alpha_{1} \\cos(\\omega_{1} n - \\omega_{1}) \\\\\n&+ \\left( B\\alpha_{0} + \\frac{3\\gamma B}{4}(B^{2}+2A^{2}) \\right) \\cos(\\omega_{2} n) + B\\alpha_{1} \\cos(\\omega_{2} n - \\omega_{2}) \\\\\n&+ \\frac{A^{2}}{2}\\left( \\beta_{0}\\cos(2\\omega_{1} n) + \\beta_{1}\\cos(2\\omega_{1} n - 2\\omega_{1}) \\right) \\\\\n&+ \\frac{B^{2}}{2}\\left( \\beta_{0}\\cos(2\\omega_{2} n) + \\beta_{1}\\cos(2\\omega_{2} n - 2\\omega_{2}) \\right) \\\\\n&+ AB\\left( \\beta_{0}\\cos((\\omega_{1}-\\omega_{2})n) + \\beta_{1}\\cos((\\omega_{1}-\\omega_{2})n - (\\omega_{1}-\\omega_{2})) \\right) \\\\\n&+ AB\\left( \\beta_{0}\\cos((\\omega_{1}+\\omega_{2})n) + \\beta_{1}\\cos((\\omega_{1}+\\omega_{2})n - (\\omega_{1}+\\omega_{2})) \\right) \\\\\n&+ \\frac{\\gamma A^{3}}{4}\\cos(3\\omega_{1} n) + \\frac{\\gamma B^{3}}{4}\\cos(3\\omega_{2} n) \\\\\n&+ \\frac{3\\gamma A^{2} B}{4}\\cos((2\\omega_{1}-\\omega_{2})n) + \\frac{3\\gamma A^{2} B}{4}\\cos((2\\omega_{1}+\\omega_{2})n) \\\\\n&+ \\frac{3\\gamma AB^{2}}{4}\\cos((\\omega_{1}-2\\omega_{2})n) + \\frac{3\\gamma AB^{2}}{4}\\cos((\\omega_{1}+2\\omega_{2})n)\n\\end{aligned}\n}\n$$", "id": "2887101"}, {"introduction": "从理论走向实践，我们如何从观测到的输入输出数据中确定系统的模型呢？本练习将带你进入系统辨识的核心问题，这是一个结合了理论推导与数值计算的综合性挑战。你将使用基函数展开来高效地表示系统核，并应用吉洪诺夫正则化（Tikhonov regularization）来确保在数据有限或存在噪声时获得稳定且有意义的解。这项练习不仅能让你掌握现代信号处理与机器学习中的一项基本技术，还能帮助你弥合抽象核函数定义与从真实数据中估计模型的实际挑战之间的鸿沟。[@problem_id:2887120]", "problem": "考虑一个离散时间、单输入单输出模型，其中，时域中的一个有限长度核向量，表示为 $h \\in \\mathbb{R}^{N}$，通过有限基展开 $h = B a$ 来表示，其中 $B \\in \\mathbb{R}^{N \\times M}$ 是一个满列秩矩阵，而 $a \\in \\mathbb{R}^{M}$ 是系数向量。测量的输出样本 $y \\in \\mathbb{R}^{T}$ 通过一个已知的回归矩阵 $\\Phi \\in \\mathbb{R}^{T \\times N}$ 建模为 $y \\approx \\Phi h$。在非线性系统建模中，当近似 Volterra 级数的线性或高阶分量时，会出现这种设定。通过对 $\\Phi$ 进行适当的构造，它也涵盖了 Wiener 和 Hammerstein 模型的回归量（但您无需从输入信号构造 $\\Phi$；请使用下面提供的矩阵）。您需要使用 Tikhonov 正则化来获得稳定的估计。\n\n任务1（从第一性原理推导）：从系数空间中 Tikhonov 正则化最小二乘的定义出发，\n$$\n\\widehat{a} = \\underset{a \\in \\mathbb{R}^{M}}{\\arg\\min}\\ \\left\\| y - \\Phi B a \\right\\|_2^2 + \\lambda \\left\\| D a \\right\\|_2^2,\n$$\n其中 $\\lambda \\geq 0$ 且给定一个惩罚算子 $D \\in \\mathbb{R}^{P \\times M}$，请在时域核空间中推导一个二次惩罚项，使得对于任何满足 $h = B a$ 的 $a$，\n$$\n\\left\\| D a \\right\\|_2^2 = h^{\\top} T h,\n$$\n对于一个仅依赖于 $B$ 和 $D$ 的对称半正定矩阵 $T \\in \\mathbb{R}^{N \\times N}$ 成立。将 $T$ 表示为 $B$、$D$ 以及 $B$ 的 Moore-Penrose (MP) 伪逆的函数。证明该等价性对 $B$ 的值域中的所有 $h$ 都成立。\n\n任务2（估计器的实现）：基于正规方程组，实现一个用于 $a$ 的正则化最小二乘估计器\n$$\n\\widehat{a} = \\underset{a}{\\arg\\min} \\ \\left\\| y - \\Phi B a \\right\\|_2^2 + \\lambda \\left\\| D a \\right\\|_2^2,\n$$\n并返回 $\\widehat{a}$。同时，根据您的推导计算 $T$，并通过数值方法验证以下恒等式\n$$\n\\left\\| D \\widehat{a} \\right\\|_2^2 = (B \\widehat{a})^{\\top} T (B \\widehat{a})\n$$\n报告等式两边的绝对差值。\n\n数值测试套件：对于每个测试，请完全按照说明使用所提供的矩阵和向量。所有过程中均不涉及物理单位。\n\n- 测试用例1（理想路径，单位矩阵惩罚）：\n  - $B \\in \\mathbb{R}^{4 \\times 3}$:\n    $$\n    B = \\begin{bmatrix}\n    0.8 & 0.5 & 0.2\\\\\n    0.6 & 0.1 & -0.3\\\\\n    0.3 & -0.4 & 0.6\\\\\n    0.1 & 0.7 & 0.5\n    \\end{bmatrix}\n    $$\n  - $\\Phi \\in \\mathbb{R}^{6 \\times 4}$:\n    $$\n    \\Phi = \\begin{bmatrix}\n    0.2 & 0.1 & 0.0 & 0.0\\\\\n    0.5 & 0.2 & 0.1 & 0.0\\\\\n    0.1 & -0.3 & 0.2 & 0.1\\\\\n    0.0 & 0.4 & -0.2 & 0.2\\\\\n    -0.1 & 0.1 & 0.3 & -0.2\\\\\n    0.0 & -0.2 & 0.1 & 0.4\n    \\end{bmatrix}\n    $$\n  - $D = I_3$（$3 \\times 3$ 单位矩阵），$\\lambda = 0.25$。\n  - 使用 $a_{\\text{true}} = \\begin{bmatrix}1.0\\\\-0.5\\\\0.3\\end{bmatrix}$ 生成 $y$ 为 $y = \\Phi B a_{\\text{true}}$。\n\n- 测试用例2（边界条件，无正则化）：\n  - $B$ 如测试用例1所示。\n  - $\\Phi \\in \\mathbb{R}^{5 \\times 4}$:\n    $$\n    \\Phi = \\begin{bmatrix}\n    1.0 & 0.0 & 0.0 & 0.0\\\\\n    0.5 & 1.0 & 0.0 & 0.0\\\\\n    0.2 & 0.5 & 1.0 & 0.0\\\\\n    0.1 & 0.2 & 0.5 & 1.0\\\\\n    0.0 & 0.1 & 0.2 & 0.5\n    \\end{bmatrix}\n    $$\n  - $D = I_3$, $\\lambda = 0$。\n  - 使用 $a_{\\text{true}} = \\begin{bmatrix}0.7\\\\0.2\\\\-0.4\\end{bmatrix}$ 生成 $y$ 为 $y = \\Phi B a_{\\text{true}}$。\n\n- 测试用例3（非单位矩阵惩罚，对系数进行平滑）：\n  - $B \\in \\mathbb{R}^{5 \\times 4}$:\n    $$\n    B = \\begin{bmatrix}\n    0.9 & 0.3 & 0.0 & -0.1\\\\\n    0.6 & -0.2 & 0.4 & 0.0\\\\\n    0.2 & 0.5 & -0.3 & 0.1\\\\\n    0.0 & 0.4 & 0.6 & 0.2\\\\\n    -0.1 & 0.1 & 0.2 & 0.8\n    \\end{bmatrix}\n    $$\n  - $\\Phi \\in \\mathbb{R}^{7 \\times 5}$:\n    $$\n    \\Phi = \\begin{bmatrix}\n    0.3 & 0.0 & 0.0 & 0.0 & 0.0\\\\\n    0.6 & 0.3 & 0.0 & 0.0 & 0.0\\\\\n    0.1 & 0.6 & 0.3 & 0.0 & 0.0\\\\\n    -0.2 & 0.1 & 0.6 & 0.3 & 0.0\\\\\n    0.0 & -0.2 & 0.1 & 0.6 & 0.3\\\\\n    0.0 & 0.0 & -0.2 & 0.1 & 0.6\\\\\n    0.0 & 0.0 & 0.0 & -0.2 & 0.1\n    \\end{bmatrix}\n    $$\n  - $D \\in \\mathbb{R}^{3 \\times 4}$（系数的一阶差分算子）：\n    $$\n    D = \\begin{bmatrix}\n    1 & -1 & 0 & 0\\\\\n    0 & 1 & -1 & 0\\\\\n    0 & 0 & 1 & -1\n    \\end{bmatrix}\n    $$\n  - $\\lambda = 0.1$。\n  - 使用 $a_{\\text{true}} = \\begin{bmatrix}0.5\\\\-0.1\\\\0.3\\\\-0.2\\end{bmatrix}$ 生成 $y$ 为 $y = \\Phi B a_{\\text{true}}$。\n\n对于每个测试用例，您的程序必须：\n- 计算使 $\\left\\| y - \\Phi B a \\right\\|_2^2 + \\lambda \\left\\| D a \\right\\|_2^2$ 最小化的 $\\widehat{a}$，\n- 根据您的推导计算 $T$，\n- 计算绝对差值 $\\left| \\left\\| D \\widehat{a} \\right\\|_2^2 - (B \\widehat{a})^{\\top} T (B \\widehat{a}) \\right|$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n- 此列表中的每个元素对应一个测试用例，并且其本身必须是一个包含两个元素列表，形式如下：\n  1. 估计的系数向量 $\\widehat{a}$，每个条目四舍五入到 $6$ 位小数，\n  2. 绝对差值，四舍五入到 $12$ 位小数。\n- 具体来说，整体打印结构必须是：\n  $$\n  \\left[ [\\text{a\\_hat\\_case1}, \\ \\text{diff\\_case1}], \\ [\\text{a\\_hat\\_case2}, \\ \\text{diff\\_case2}], \\ [\\text{a\\_hat\\_case3}, \\ \\text{diff\\_case3}] \\right].\n  $$", "solution": "所提出的问题是使用基函数展开进行正则化系统辨识的一个标准练习。它在数学上是良定义的，在信号处理领域有科学依据，并且为数值求解提供了所有必要的数据。该问题被认为是有效的。\n\n按照要求，解决方案分两部分呈现：首先是理论推导，其次是数值实现的解释。\n\n### 任务1：时域惩罚矩阵 $T$ 的推导\n\n我们的任务是找到一个对称半正定矩阵 $T \\in \\mathbb{R}^{N \\times N}$，使得施加在系数向量 $a \\in \\mathbb{R}^{M}$ 上的惩罚 $\\| D a \\|_2^2$ 等价于施加在核向量 $h \\in \\mathbb{R}^{N}$ 上的二次惩罚 $h^{\\top} T h$，这对基矩阵 $B \\in \\mathbb{R}^{N \\times M}$ 的值域中的所有 $h$ 都成立。$h$ 和 $a$ 之间的关系由 $h = B a$ 给出。\n\n题目说明指出 $B$ 具有满列秩。由于 $B$ 是一个 $N \\times M$ 矩阵，这意味着它的秩为 $M$。$B$ 具有满列秩的一个推论是矩阵 $B^{\\top} B \\in \\mathbb{R}^{M \\times M}$ 是可逆的。这也意味着从系数向量 $a$ 到 $B$ 的值域 $\\mathcal{R}(B)$ 中的核 $h$ 的映射是一一对应的。\n\n对于任何 $h \\in \\mathcal{R}(B)$，都存在唯一的 $a \\in \\mathbb{R}^{M}$ 使得 $h = B a$。我们可以使用 $B$ 的 Moore-Penrose 伪逆（表示为 $B^{+}$）来找到这个唯一的 $a$。对于一个满列秩矩阵，其伪逆是一个左逆，由 $B^{+} = (B^{\\top} B)^{-1} B^{\\top}$ 给出。将此应用于 $h = B a$，我们得到：\n$$ B^{+} h = (B^{\\top} B)^{-1} B^{\\top} (B a) = ((B^{\\top} B)^{-1} (B^{\\top} B)) a = I_M a = a $$\n因此，对于任何 $h \\in \\mathcal{R}(B)$，对应的唯一系数向量是 $a = B^{+} h$。\n\n现在，我们可以用 $h$ 来表示惩罚项 $\\| D a \\|_2^2$。我们将表达式 $a = B^{+} h$ 代入惩罚项中：\n$$ \\| D a \\|_2^2 = \\| D (B^{+} h) \\|_2^2 $$\n向量 $v$ 的欧几里得范数的平方是 $v^{\\top}v$。应用此公式，我们得到：\n$$ \\| D B^{+} h \\|_2^2 = (D B^{+} h)^{\\top} (D B^{+} h) $$\n使用性质 $(XY)^{\\top} = Y^{\\top}X^{\\top}$，我们可以将此表达式重排为关于 $h$ 的二次型：\n$$ (D B^{+} h)^{\\top} (D B^{+} h) = h^{\\top} (B^{+})^{\\top} D^{\\top} D B^{+} h $$\n我们在寻找一个矩阵 $T$ 使得 $\\| D a \\|_2^2 = h^{\\top} T h$。通过将上述表达式与 $h^{\\top} T h$ 进行比较，我们可以确定矩阵 $T$ 为：\n$$ T = (B^{+})^{\\top} D^{\\top} D B^{+} $$\n如此得到的 $T$ 的表达式仅依赖于 $B$（通过 $B^{+}$）和 $D$，符合要求。\n\n我们必须验证 $T$ 是对称且半正定的。\n对称性：我们取 $T$ 的转置。\n$$ T^{\\top} = \\left( (B^{+})^{\\top} D^{\\top} D B^{+} \\right)^{\\top} = (B^{+})^{\\top} (D^{\\top}D)^{\\top} ((B^{+})^{\\top})^{\\top} = (B^{+})^{\\top} D^{\\top} D B^{+} = T $$\n矩阵 $D^{\\top}D$ 是对称的，所以 $(D^{\\top}D)^{\\top} = D^{\\top}D$。因此，$T$ 是一个对称矩阵。\n\n半正定性：对于任何向量 $z \\in \\mathbb{R}^{N}$，我们必须证明 $z^{\\top} T z \\ge 0$。\n$$ z^{\\top} T z = z^{\\top} (B^{+})^{\\top} D^{\\top} D B^{+} z = (D B^{+} z)^{\\top} (D B^{+} z) = \\| D B^{+} z \\|_2^2 $$\n由于任何实向量的欧几里得范数的平方都是非负的，我们有 $\\| D B^{+} z \\|_2^2 \\ge 0$。因此，$T$ 是一个半正定矩阵。\n\n至此推导完成。等价关系 $\\| D a \\|_2^2 = h^{\\top} T h$ 对 $B$ 值域中的任何 $h$ 都成立，其中 $T = (B^{+})^{\\top} D^{\\top} D B^{+}$。\n\n### 任务2：估计器的实现与验证\n\n任务是找到使 Tikhonov 正则化最小二乘代价函数最小化的系数向量 $\\widehat{a}$：\n$$ J(a) = \\| y - \\Phi B a \\|_2^2 + \\lambda \\| D a \\|_2^2 $$\n其中 $\\lambda \\ge 0$。这是一个标准的线性最小二乘问题。令复合回归矩阵为 $X = \\Phi B$。代价函数变为：\n$$ J(a) = \\| y - X a \\|_2^2 + \\lambda \\| D a \\|_2^2 = \\| y - X a \\|_2^2 + \\| \\sqrt{\\lambda} D a \\|_2^2 $$\n通过构造一个增广系统，这可以被表述为一个单一的、无正则化的最小二乘问题。我们寻求最小化 $\\| \\tilde{y} - \\tilde{X} a \\|_2^2$，其中增广矩阵 $\\tilde{X}$ 和增广向量 $\\tilde{y}$ 定义如下：\n$$ \\tilde{X} = \\begin{bmatrix} X \\\\ \\sqrt{\\lambda} D \\end{bmatrix} = \\begin{bmatrix} \\Phi B \\\\ \\sqrt{\\lambda} D \\end{bmatrix}, \\quad \\tilde{y} = \\begin{bmatrix} y \\\\ 0 \\end{bmatrix} $$\n在 $\\tilde{y}$ 中的向量 $0$ 的维度是 $P$，即 $D$ 的行数。这个增广最小二乘问题可以使用标准的数值线性代数库稳健地求解，例如 Python 中的 `numpy.linalg.lstsq`，它可以计算出使残差范数最小化的解 $\\widehat{a}$。\n\n对于每个测试用例，实现将按以下步骤进行：\n1.  从问题数据中构造矩阵 $B$、$\\Phi$ 和 $D$ 以及标量 $\\lambda$。\n2.  生成输出向量 $y = (\\Phi B) a_{\\text{true}}$。\n3.  如上所述构造增广矩阵 $\\tilde{X}$ 和向量 $\\tilde{y}$。\n4.  对增广系统使用最小二乘求解器求解估计的系数向量 $\\widehat{a}$。\n5.  使用 `numpy.linalg.pinv` 计算 $B$ 的 Moore-Penrose 伪逆 $B^{+}$。\n6.  计算惩罚矩阵 $T = (B^{+})^{\\top} D^{\\top} D B^{+}$。\n7.  使用计算出的 $\\widehat{a}$ 计算等式两边，从而数值验证任务1中推导的恒等式：\n    -   等式左边 (LHS)：$\\| D \\widehat{a} \\|_2^2$。\n    -   等式右边 (RHS)：$(B \\widehat{a})^{\\top} T (B \\widehat{a})$。\n8.  计算绝对差值 $| \\text{LHS} - \\text{RHS} |$。\n9.  存储结果向量 $\\widehat{a}$ 和绝对差值，并按要求的精度格式化。\n\n此过程是确定性的，并直接实现了所推导的理论。对于 $\\lambda=0$ 的情况，该方法正确地简化为普通最小二乘法。在所提供的 $\\lambda=0$ 的测试用例中，数据 $y$ 是在没有噪声的情况下生成的，因此 $y$ 位于 $\\Phi B$ 的列空间中，保证了解的存在性。如果存在多个解（即，如果 $\\Phi B$ 是秩亏的），`lstsq` 函数将提供最小范数解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the regularized least-squares problem for three test cases,\n    computes the T-matrix, and verifies the penalty equivalence.\n    \"\"\"\n    \n    # Test Case 1: happy path, identity penalty\n    B1 = np.array([\n        [0.8, 0.5, 0.2],\n        [0.6, 0.1, -0.3],\n        [0.3, -0.4, 0.6],\n        [0.1, 0.7, 0.5]\n    ])\n    Phi1 = np.array([\n        [0.2, 0.1, 0.0, 0.0],\n        [0.5, 0.2, 0.1, 0.0],\n        [0.1, -0.3, 0.2, 0.1],\n        [0.0, 0.4, -0.2, 0.2],\n        [-0.1, 0.1, 0.3, -0.2],\n        [0.0, -0.2, 0.1, 0.4]\n    ])\n    D1 = np.identity(3)\n    lambda1 = 0.25\n    a_true1 = np.array([1.0, -0.5, 0.3])\n\n    # Test Case 2: boundary condition, no regularization\n    B2 = B1\n    Phi2 = np.array([\n        [1.0, 0.0, 0.0, 0.0],\n        [0.5, 1.0, 0.0, 0.0],\n        [0.2, 0.5, 1.0, 0.0],\n        [0.1, 0.2, 0.5, 1.0],\n        [0.0, 0.1, 0.2, 0.5]\n    ])\n    D2 = np.identity(3)\n    lambda2 = 0.0\n    a_true2 = np.array([0.7, 0.2, -0.4])\n\n    # Test Case 3: non-identity penalty, smoothing\n    B3 = np.array([\n        [0.9, 0.3, 0.0, -0.1],\n        [0.6, -0.2, 0.4, 0.0],\n        [0.2, 0.5, -0.3, 0.1],\n        [0.0, 0.4, 0.6, 0.2],\n        [-0.1, 0.1, 0.2, 0.8]\n    ])\n    Phi3 = np.array([\n        [0.3, 0.0, 0.0, 0.0, 0.0],\n        [0.6, 0.3, 0.0, 0.0, 0.0],\n        [0.1, 0.6, 0.3, 0.0, 0.0],\n        [-0.2, 0.1, 0.6, 0.3, 0.0],\n        [0.0, -0.2, 0.1, 0.6, 0.3],\n        [0.0, 0.0, -0.2, 0.1, 0.6],\n        [0.0, 0.0, 0.0, -0.2, 0.1]\n    ])\n    D3 = np.array([\n        [1, -1, 0, 0],\n        [0, 1, -1, 0],\n        [0, 0, 1, -1]\n    ])\n    lambda3 = 0.1\n    a_true3 = np.array([0.5, -0.1, 0.3, -0.2])\n\n    test_cases = [\n        (B1, Phi1, D1, lambda1, a_true1),\n        (B2, Phi2, D2, lambda2, a_true2),\n        (B3, Phi3, D3, lambda3, a_true3)\n    ]\n    \n    results = []\n\n    for B, Phi, D, lam, a_true in test_cases:\n        # Generate the measurement vector y\n        X = Phi @ B\n        y = X @ a_true\n\n        # --- Estimate a_hat ---\n        # Form the augmented least-squares system\n        # X_tilde * a = y_tilde\n        sqrt_lam = np.sqrt(lam)\n        \n        # Get dimensions for augmented system\n        T_dim, M = X.shape\n        P_dim = D.shape[0] if D.ndim > 1 else (1 if D.ndim == 1 else 0)\n\n        X_tilde = np.vstack((X, sqrt_lam * D))\n        y_tilde = np.zeros(T_dim + P_dim)\n        y_tilde[:T_dim] = y\n        \n        # Solve for a_hat using lstsq for numerical stability\n        a_hat = np.linalg.lstsq(X_tilde, y_tilde, rcond=None)[0]\n\n        # --- Compute T and verify the identity ---\n        # Compute Moore-Penrose pseudoinverse of B\n        B_pinv = np.linalg.pinv(B)\n        \n        # Compute T matrix\n        T = B_pinv.T @ D.T @ D @ B_pinv\n        \n        # Compute h_hat\n        h_hat = B @ a_hat\n        \n        # Left-hand side of the identity: ||D * a_hat||^2\n        lhs = np.linalg.norm(D @ a_hat)**2\n        \n        # Right-hand side of the identity: h_hat^T * T * h_hat\n        rhs = h_hat.T @ T @ h_hat\n        \n        # Compute the absolute difference\n        diff = np.abs(lhs - rhs)\n        \n        # Format results as specified\n        formatted_a_hat = [f'{x:.6f}' for x in a_hat]\n        formatted_diff = f'{diff:.12f}'\n        \n        results.append(f\"[{formatted_a_hat}, {formatted_diff}]\")\n\n    # Final print statement in the exact required format.\n    # The string representation of list in python adds spaces, need to build it manually.\n    print(f\"[{','.join(results)}]\")\n\n# Calling solve() is not standard in this environment, but the logic is self-contained.\n# A function wrapping the logic is good practice. The executor will run the code.\ntry:\n    solve()\nexcept Exception as e:\n    print(e)\n```", "id": "2887120"}]}