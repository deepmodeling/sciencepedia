{"hands_on_practices": [{"introduction": "理解台阶状表面的几何构型是分析其独特性质的第一步。本练习将引导你完成一个基础推导，将倾斜表面的宏观错切角 $\\theta$ 与其微观平台宽度 $L$ 联系起来 [@problem_id:2790786]。掌握这种几何关系对于量化解读实验数据和建立切合实际的理论模型至关重要。", "problem": "一个 Miller 指数为 $(111)$ 的近邻面心立方表面，是通过将晶体朝面内晶向 $[\\bar{1}10]$ 方向错切一个小角度 $\\theta$ 而制备的。所得表面由一系列周期性的单原子台阶构成，这些台阶被宽度为 $L$ 的平坦平台所分隔，台阶边缘是直的，并且平行于一个与 $[\\bar{1}10]$ 方向垂直的方向。假设每个台阶的高度等于相邻 $(111)$ 晶面之间的晶面间距。对于一个晶格常数为 $a$ 的面心立方晶格，其 $(111)$ 晶面的晶面间距为 $d_{111}=a/\\sqrt{3}$。\n\n请从几何第一性原理出发，基于“表面斜率等于单个台阶-平台周期内的垂直上升高度与水平前进距离之比”这一关系，并仅使用上述给定的晶面间距数据，推导平台宽度 $L$ 作为错切角 $\\theta$ 和晶格常数 $a$ 的函数的闭式表达式。\n\n将您的最终答案表示为 $L(\\theta,a)$ 关于 $a$ 和 $\\theta$ 的单个解析表达式。取 $\\theta$ 的单位为弧度，$a$ 的单位为米。最终表达式中不包含单位。", "solution": "用户提供了一个问题陈述，在尝试解答之前需要对其进行验证。\n\n**步骤1：提取已知条件**\n- 晶格为面心立方（FCC），晶格常数为 $a$。\n- 表面是一个近邻 $(111)$ 面。\n- 晶体朝面内方向 $[\\bar{1}10]$ 被错切了一个小角度 $\\theta$。\n- 表面由一列周期性的单原子台阶和宽度为 $L$ 的平坦平台组成。\n- 台阶高度等于 $(111)$ 晶面的晶面间距 $d_{111}$。\n- 已知 $d_{111} = a/\\sqrt{3}$。\n- 目标是推导 $L$ 作为 $\\theta$ 和 $a$ 的函数的表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n对问题进行严格的有效性审查。\n\n- **科学依据：** 该问题基于晶体学和表面科学中公认的标准近邻表面模型。错切晶体形成规则的台阶和平台阵列的概念是该领域的基础。对于FCC晶格，晶面间距公式 $d_{111} = a/\\sqrt{3}$ 在事实上是正确的，并且可以从基本的X射线衍射理论推导出来。所有概念都牢固地植根于固态物理学。\n- **适定性：** 该问题提供了所有必要信息，以在宏观错切角 $\\theta$ 和台阶-平台结构的微观尺寸（台阶高度 $h$ 和平台宽度 $L$）之间建立几何关系。该关系是唯一的，并能导出一个唯一的、稳定的 $L$ 解。\n- **客观性：** 该问题以精确、客观的语言陈述。所有术语如‘面心立方’、‘Miller指数’、‘晶面间距’、‘晶格常数’和‘错切角’在科学上都有明确无误的定义。\n\n**步骤3：结论与行动**\n问题陈述在科学上是合理的、适定的，并且没有矛盾或含糊之处。它代表了表面晶体学中一个标准的、基础的练习。因此，该问题被判定为**有效**，并将提供解答。\n\n推导从几何第一性原理开始。近邻表面的横截面可以被看作是一系列重复的直角三角形。表面的宏观斜率由错切角 $\\theta$ 定义。这个角度将表面形貌的平均“垂直上升距离”(rise)与平均“水平前进距离”(run)关联起来。\n\n对于单个台阶-平台单元，“垂直上升距离”即为台阶高度，我们用 $h$ 表示。“水平前进距离”即为平台宽度 $L$。错切角 $\\theta$、台阶高度 $h$ 和平台宽度 $L$ 之间的关系由正切函数的定义给出：\n$$\n\\tan(\\theta) = \\frac{\\text{rise}}{\\text{run}} = \\frac{h}{L}\n$$\n问题陈述中说明台阶是单原子高度的。对于 $(111)$ 表面，单原子台阶高度对应于相邻 $(111)$ 晶面之间的间距。该晶面间距被指定为 $d_{111}$。因此，台阶高度 $h$ 为：\n$$\nh = d_{111}\n$$\n问题还提供了在晶格常数为 $a$ 的FCC晶格中该晶面间距的公式：\n$$\nd_{111} = \\frac{a}{\\sqrt{3}}\n$$\n结合这些事实，我们可以将台阶高度 $h$ 设为此值：\n$$\nh = \\frac{a}{\\sqrt{3}}\n$$\n现在，我们将台阶高度 $h$ 的这个表达式代入我们的三角关系式中：\n$$\n\\tan(\\theta) = \\frac{h}{L} = \\frac{\\frac{a}{\\sqrt{3}}}{L}\n$$\n任务是求解平台宽度 $L$。我们可以通过代数方法重新排列这个方程：\n$$\nL \\cdot \\tan(\\theta) = \\frac{a}{\\sqrt{3}}\n$$\n将 $L$ 单独置于等式一侧，得到平台宽度作为晶格常数 $a$ 和错切角 $\\theta$ 的函数的最终表达式：\n$$\nL(\\theta, a) = \\frac{a}{\\sqrt{3} \\tan(\\theta)}\n$$\n这就是所要求的闭式表达式。关于错切方向 $[\\bar{1}10]$ 的信息确认了该几何结构与FCC $(111)$ 表面的标准晶体学惯例一致，但计算本身并不需要此信息，因为它仅依赖于垂直台阶高度和水平平台宽度。", "answer": "$$\\boxed{\\frac{a}{\\sqrt{3} \\tan(\\theta)}}$$", "id": "2790786"}, {"introduction": "在定义了静态表面结构之后，我们现在转向其上发生的动态过程。本问题探讨了吸附原子在平台上的基本扩散过程，使用了从密度泛函理论计算中获得的典型能量值 [@problem_id:2790766]。通过分析势能面，你将学会识别最小能量路径并计算活化能垒 $E_m$，这是理解晶体生长、催化和表面输运现象的一项关键技能。", "problem": "一个孤立吸附原子在面心立方 (fcc) $(111)$ 平台上相邻的三重空位之间扩散。密度泛函理论 (DFT) 计算给出了势能面上相关局域极值的势能如下（以 fcc 空位极小值的能量为参考）：\n- fcc 空位极小值：$E_{\\mathrm{fcc}} = 0.000~\\mathrm{eV}$，\n- 六方密堆 (hcp) 空位局域极小值：$E_{\\mathrm{hcp}} = 0.032~\\mathrm{eV}$，\n- 连接 fcc 和 hcp 的桥位一阶鞍点：$E_{\\mathrm{b}}^{\\ddagger} = 0.218~\\mathrm{eV}$。\n\n假设谐振子过渡态理论 (TST) 成立，其中从能量为 $E_{\\min}$ 的极小值点跨越能量为 $E^{\\ddagger}$ 的唯一鞍点的元跳跃速率由活化能为 $\\Delta E = E^{\\ddagger} - E_{\\min}$ 的阿伦尼乌斯因子决定，并忽略极小值点和鞍点之间的振动自由能差。吸附原子可以在相邻的 fcc 空位之间移动，可以通过跨越直接连接两个 fcc 极小值点的桥位鞍点的直接单次跳跃（如果存在这样的鞍点），或者通过一个两步序列 $ \\mathrm{fcc} \\rightarrow \\mathrm{hcp} \\rightarrow \\mathrm{fcc}$，其中每一步跳跃都跨越一个连接相应初始和最终极小值点的桥位鞍点。\n\n基于这些原理和提供的 DFT 能量，确定从一个初始 fcc 空位到邻近 fcc 空位的净扩散所需的最小活化能 $E_{m}$，优化过程考虑所有仅由给定位置（fcc 和 hcp）及其连接桥位鞍点组成的序列。在你的推理中，评估任何使用给定 hcp 中间位置的多步路径是否能产生比单次跳跃路径更低的有效活化能垒。\n\n以 $\\mathrm{eV}$ 为单位，将你的最终答案表示为单个数字。无需四舍五入；按给定值使用。", "solution": "首先对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 体系：孤立吸附原子在 fcc $(111)$ 平台上相邻三重空位之间的扩散。\n- 势能（以 $E_{\\mathrm{fcc}}$ 为参考）：\n  - fcc 空位极小值：$E_{\\mathrm{fcc}} = 0.000~\\mathrm{eV}$\n  - hcp 空位局域极小值：$E_{\\mathrm{hcp}} = 0.032~\\mathrm{eV}$\n  - 桥位一阶鞍点：$E_{\\mathrm{b}}^{\\ddagger} = 0.218~\\mathrm{eV}$\n- 理论框架：谐振子过渡态理论 (TST)。\n- 跳跃速率模型：活化能为 $\\Delta E = E^{\\ddagger} - E_{\\min}$ 的阿伦尼乌斯因子。\n- 假设：忽略振动自由能差。\n- 扩散路径：\n  - 直接单次跳跃 $\\mathrm{fcc} \\rightarrow \\mathrm{fcc}$（如果存在）。\n  - 两步序列 $\\mathrm{fcc} \\rightarrow \\mathrm{hcp} \\rightarrow \\mathrm{fcc}$。\n- 目标：确定从一个初始 $\\mathrm{fcc}$ 位置到邻近 $\\mathrm{fcc}$ 位置的净扩散的最小活化能 $E_{m}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在科学上是合理的。它描述了表面科学中的一个标准情景，使用了正确的术语（fcc(111)、空位、鞍点）和成熟的理论（TST、DFT 导出的能量）。\n- **适定性**：该问题是适定的。它提供了足够的数据和明确的目标，从而可以得到一个唯一且有意义的解。\n- **客观性**：该问题使用精确的定量语言进行了客观陈述。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个将过渡态理论概念应用于晶体表面多步反应坐标的标准练习。将提供解答。\n\n该问题要求确定一个吸附原子在 $\\mathrm{fcc}(111)$ 表面上从一个面心立方 ($\\mathrm{fcc}$) 空位扩散到邻近 $\\mathrm{fcc}$ 空位的最小活化能 $E_m$。$\\mathrm{fcc}(111)$ 表面的晶体结构决定了高对称性位置的连通性。一个 $\\mathrm{fcc}$ 空位被三个六方密堆 ($\\mathrm{hcp}$) 空位所包围，而这些 hcp 空位又被 $\\mathrm{fcc}$ 空位所包围。两个相邻 $\\mathrm{fcc}$ 位置之间通过单个桥式鞍点的直接跳跃在拓扑上是不可能的。相邻 $\\mathrm{fcc}$ 位置之间扩散的低能路径必须经过一个中间的 $\\mathrm{hcp}$ 位置。因此，相关的扩散路径是两步序列：$\\mathrm{fcc} \\rightarrow \\mathrm{hcp} \\rightarrow \\mathrm{fcc}$。问题中的条件从句，“如果存在这样的鞍点直接连接两个 fcc 极小值点”，正确地暗示了这条路径可能不存在，这迫使我们对给定的位置网络进行严格分析。\n\n这个两步过程的势能剖面是根据提供的能量构建的。初始 $\\mathrm{fcc}$ 位置的能量是参考能量，$E_{\\mathrm{fcc}} = 0.000~\\mathrm{eV}$。\n\n该过程涉及两次元跳跃：\n$1.$ 第一次跳跃是 $\\mathrm{fcc} \\rightarrow \\mathrm{hcp}$。吸附原子从一个 $\\mathrm{fcc}$ 极小值点（能量 $E_{\\mathrm{fcc}}$）通过一个桥位鞍点（能量 $E_{\\mathrm{b}}^{\\ddagger}$）跃迁到邻近的 $\\mathrm{hcp}$ 极小值点（能量 $E_{\\mathrm{hcp}}$）。此单步的活化能 $\\Delta E_{1}$ 为：\n$$ \\Delta E_{1} = E_{\\mathrm{b}}^{\\ddagger} - E_{\\mathrm{fcc}} = 0.218~\\mathrm{eV} - 0.000~\\mathrm{eV} = 0.218~\\mathrm{eV} $$\n这次跳跃后，吸附原子处于 $\\mathrm{hcp}$ 局域极小值点，这是整个过程的一个中间态。\n\n$2.$ 第二次跳跃是 $\\mathrm{hcp} \\rightarrow \\mathrm{fcc}$。吸附原子从 $\\mathrm{hcp}$ 中间态移动到最终的 $\\mathrm{fcc}$ 位置，再次跨越一个桥位鞍点。此步的活化能 $\\Delta E_{2}$ 是相对于中间态的能量计算的：\n$$ \\Delta E_{2} = E_{\\mathrm{b}}^{\\ddagger} - E_{\\mathrm{hcp}} = 0.218~\\mathrm{eV} - 0.032~\\mathrm{eV} = 0.186~\\mathrm{eV} $$\n\n对于一个多步过程，总的有效活化能 $E_m$ 定义为沿整个反应坐标必须克服的最高能垒，该能垒是从初始稳定态的能量开始测量的。我们必须找出 $\\mathrm{fcc} \\rightarrow \\mathrm{hcp} \\rightarrow \\mathrm{fcc}$ 序列的最低能量路径上的势能全局最大值。相关的能级是：\n- 初始态 ($E_{\\mathrm{initial}}$)：$E_{\\mathrm{fcc}} = 0.000~\\mathrm{eV}$\n- 中间态 ($E_{\\mathrm{inter}}$)：$E_{\\mathrm{hcp}} = 0.032~\\mathrm{eV}$\n- 过渡态 ($E^{\\ddagger}$)：$E_{\\mathrm{b}}^{\\ddagger} = 0.218~\\mathrm{eV}$\n\n能量剖面从 $E=0.000~\\mathrm{eV}$ 开始，上升到一个位于 $E=0.218~\\mathrm{eV}$ 的鞍点，下降到一个位于 $E=0.032~\\mathrm{eV}$ 的中间极小值，再次上升到第二个位于 $E=0.218~\\mathrm{eV}$ 的鞍点，最后下降到位于 $E=0.000~\\mathrm{eV}$ 的最终态。整个路径上的最高能量点是桥位鞍点的能量 $E_{\\mathrm{b}}^{\\ddagger}$。\n\n因此，从一个初始 $\\mathrm{fcc}$ 位置到邻近位置的净扩散的有效活化能 $E_m$ 是这个最大能量与初始能量之间的差值：\n$$ E_m = E_{\\mathrm{b}}^{\\ddagger} - E_{\\mathrm{fcc}} $$\n代入给定的数值：\n$$ E_m = 0.218~\\mathrm{eV} - 0.000~\\mathrm{eV} = 0.218~\\mathrm{eV} $$\n关于多步路径是否能提供更低能垒的评估已由本分析回答。由于相邻 $\\mathrm{fcc}$ 位置之间的直接单次跳跃路径在几何上是被禁止的，因此由给定位置组成的两步路径是唯一可行的路线。其活化能由路径上的最高能垒决定，即从初始 $\\mathrm{fcc}$ 势阱中跳出的那一步。因此，扩散的最小活化能由这个速率决定步骤决定。", "answer": "$$\\boxed{0.218}$$", "id": "2790766"}, {"introduction": "超越单原子动力学，台阶边缘的集体行为由其热力学性质决定。这个高级实践将挑战你将台阶边建模为具有取向依赖线张力 $\\beta(\\theta)$ 的连续线 [@problem_id:2790696]。你将实现一个数据分析流程，用以拟合一个物理模型到模拟的DFT数据，确定关键的台阶刚度参数 $\\tilde{\\beta}(\\theta)$，并执行严格的不确定性量化，这真实地反映了现代计算材料研究中的核心任务。", "problem": "您将获得合成的、通过密度泛函理论 (DFT) 计算的形成能数据。这些数据是关于一个具有四重对称性的晶体表面上的直台阶边缘段的。这些能量值因计算近似而带有已知的单西格玛不确定度。假设采用连续线张力描述，其中单位长度的台阶自由能（用 $\\beta(\\theta)$ 表示）依赖于台阶相对于固定晶轴的取向角 $\\theta$。对于长度为 $L$、取向为 $\\theta$ 的直台阶段，其形成能建模为\n$$\nE \\approx \\beta(\\theta)\\,L,\n$$\n其中 $E$ 带有独立的、标准差为 $\\sigma$ 的高斯测量误差。\n\n从基本定义出发，$\\beta(\\theta)$ 是直台阶单位长度的线自由能。回想一下，对于各向异性界面，控制法向力和曲率稳定性的毛细作用涉及各向异性刚度 $\\tilde{\\beta}(\\theta)$，其定义为\n$$\n\\tilde{\\beta}(\\theta) \\equiv \\beta(\\theta) + \\frac{d^2 \\beta(\\theta)}{d\\theta^2}.\n$$\n该二阶导数产生于各向异性线的自由能密度中，线张力在无穷小旋转下的角度依赖性，而此旋转与曲率耦合。\n\n假设线张力采用四重对称的参数化形式：\n$$\n\\beta(\\theta) = b_0 + b_4 \\cos(4\\theta),\n$$\n其中未知系数 $b_0$ 和 $b_4$ 将通过对数据在高斯误差下进行最大似然估计来推断，这等价于对独立观测值使用权重 $w_i = 1/\\sigma_i^2$ 的加权线性最小二乘法。参数协方差应通过加权最小二乘估计量中的正规矩阵的逆矩阵来计算。通过线性误差传播，将此参数不确定性传播到在指定评估角度下的 $\\beta(\\theta)$ 和 $\\tilde{\\beta}(\\theta)$，以获得它们的标准差（单西格玛误差棒）。角度以弧度为单位。所有长度必须以纳米 (nm) 为单位处理，能量以电子伏特 (eV) 为单位，并以 $\\mathrm{eV/nm}$ 为单位报告 $\\beta$ 和 $\\tilde{\\beta}$。\n\n实现一个程序，使用以下数据集（每个数据集是一个测试用例）并执行下述任务。\n\n每个观测的数据格式为：$(\\theta, L, E, \\sigma)$，其中 $\\theta$ 以弧度为单位， $L$ 以 $\\mathrm{nm}$ 为单位， $E$ 以 $\\mathrm{eV}$ 为单位， $\\sigma$ 以 $\\mathrm{eV}$ 为单位。\n\n测试套件：\n- 案例 1（良态，中等各向异性）：\n  - $(0.0000000000,\\; 5.0,\\; 1.1000000000,\\; 0.020)$\n  - $(0.3926990817,\\; 4.0,\\; 0.8400000000,\\; 0.015)$\n  - $(0.7853981634,\\; 6.0,\\; 1.2000000000,\\; 0.020)$\n  - $(0.1963495408,\\; 3.0,\\; 0.6512132034,\\; 0.010)$\n  - $(0.5890486225,\\; 7.0,\\; 1.4205025254,\\; 0.025)$\n- 案例 2（各向同性极限）：\n  - $(0.0000000000,\\; 10.0,\\; 1.8000000000,\\; 0.050)$\n  - $(0.2617993878,\\; 8.0,\\; 1.4400000000,\\; 0.040)$\n  - $(0.5235987756,\\; 12.0,\\; 2.1600000000,\\; 0.060)$\n  - $(0.7853981634,\\; 7.0,\\; 1.2600000000,\\; 0.030)$\n- 案例 3（小各向异性，非均匀不确定度）：\n  - $(0.1963495408,\\; 6.0,\\; 1.8424264068,\\; 0.030)$\n  - $(0.0000000000,\\; 9.0,\\; 2.7900000000,\\; 0.020)$\n  - $(0.5890486225,\\; 5.5,\\; 1.6111091271,\\; 0.040)$\n  - $(0.3926990817,\\; 7.5,\\; 2.2500000000,\\; 0.050)$\n\n任务：\n1. 对于每种情况，通过最小化\n   $$\n   \\chi^2(b_0,b_4) = \\sum_{i} \\frac{\\left[E_i - L_i \\beta(\\theta_i)\\right]^2}{\\sigma_i^2},\n   $$\n   来估计 $(b_0,b_4)$，其中 $\\beta(\\theta)=b_0 + b_4\\cos(4\\theta)$。使用最大似然（加权最小二乘）估计量，并从加权正规矩阵的逆矩阵计算 $2\\times 2$ 参数协方差矩阵。\n2. 对于每种情况，在角度 $\\theta \\in \\{0,\\; \\pi/8,\\; \\pi/4\\}$ 处评估 $\\beta(\\theta)$ 和 $\\tilde{\\beta}(\\theta)$，并通过参数协方差进行线性误差传播，计算它们的单西格玛标准差。使用关系式\n   $$\n   \\tilde{\\beta}(\\theta) = \\beta(\\theta) + \\frac{d^2\\beta(\\theta)}{d\\theta^2}.\n   $$\n   对于给定的参数化形式，必须精确计算 $\\frac{d^2\\beta}{d\\theta^2}$，并将其与 $\\beta(\\theta)$ 结合，以获得每个评估角度下的 $\\tilde{\\beta}(\\theta)$。\n3. 以 $\\mathrm{eV/nm}$ 为单位报告所有 $\\beta$ 和 $\\tilde{\\beta}$ 的值及其标准差。角度以弧度为单位。将数值输出为十进制浮点数，并四舍五入到小数点后六位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有三种情况的结果，这些结果被聚合和扁平化为一个用方括号括起来的逗号分隔列表。\n- 对于每种情况，按顺序附加以下十二个值：\n  - $\\beta(0)$、$\\mathrm{std}[\\beta(0)]$、$\\beta(\\pi/8)$、$\\mathrm{std}[\\beta(\\pi/8)]$、$\\beta(\\pi/4)$、$\\mathrm{std}[\\beta(\\pi/4)]$、$\\tilde{\\beta}(0)$、$\\mathrm{std}[\\tilde{\\beta}(0)]$、$\\tilde{\\beta}(\\pi/8)$、$\\mathrm{std}[\\tilde{\\beta}(\\pi/8)]$、$\\tilde{\\beta}(\\pi/4)$、$\\mathrm{std}[\\tilde{\\beta}(\\pi/4)]$。\n- 按此顺序串联案例 1、案例 2、然后是案例 3 的结果。\n- 示例模式（非实际数字）：\n  $$\n  [\\beta_1(0),s\\beta_1(0),\\beta_1(\\pi/8),s\\beta_1(\\pi/8),\\beta_1(\\pi/4),s\\beta_1(\\pi/4),\\tilde{\\beta}_1(0),s\\tilde{\\beta}_1(0),\\tilde{\\beta}_1(\\pi/8),s\\tilde{\\beta}_1(\\pi/8),\\tilde{\\beta}_1(\\pi/4),s\\tilde{\\beta}_1(\\pi/4),\\;\\beta_2(0),\\dots,\\;\\beta_3(0),\\dots].\n  $$\n所有输出必须以 $\\mathrm{eV/nm}$ 为单位，四舍五入到小数点后六位。角度以弧度为单位。", "solution": "我们从基本定义开始：线张力 $\\beta(\\theta)$ 是取向角为 $\\theta$ 的直台阶段单位长度的自由能。对于长度为 $L$ 的直台阶段，在忽略末端效应和扭折激发的情况下，连续近似中的过剩自由能为 $E = \\beta(\\theta) L$。密度泛函理论 (DFT) 提供了在指定 $(\\theta_i,L_i)$ 下计算的形成能 $E_i$，其不确定度为 $\\sigma_i$，我们将其视为独立高斯误差的单西格玛标准差。\n\n线的各向异性毛细作用意味着对曲率的响应不仅取决于 $\\beta(\\theta)$，还取决于 $\\beta$ 如何随取向变化。考虑一个微小旋转 $\\theta \\to \\theta + \\delta \\theta$；自由能密度的变化为 $\\delta \\beta = \\beta'(\\theta)\\delta\\theta + \\tfrac{1}{2}\\beta''(\\theta)\\delta\\theta^2 + \\dots$，弯曲线上力的平衡涉及与曲率成正比的项，以及切向化学势对取向的导数。对旋转自由度进行积分至二阶项，可得到著名的界面线各向异性刚度的 Herring 关系式：\n$$\n\\tilde{\\beta}(\\theta) \\equiv \\beta(\\theta) + \\frac{d^2 \\beta(\\theta)}{d\\theta^2},\n$$\n该刚度是毛细作用驱动的法向力中与曲率相乘的系数。稳定性要求对于所有支持平滑平衡形状的 $\\theta$，都有 $\\tilde{\\beta}(\\theta) > 0$。\n\n参数化和线性模型。在具有四重对称性的晶体表面（例如，面心立方 (100) 面）上，与对称性一致的最低阶傅里叶表示为\n$$\n\\beta(\\theta) = b_0 + b_4 \\cos(4\\theta),\n$$\n其中未知系数 $b_0$ 和 $b_4$ 的单位为 $\\mathrm{eV/nm}$。测量的能量遵循以下关系\n$$\nE_i = L_i \\beta(\\theta_i) + \\varepsilon_i = L_i \\left( b_0 + b_4 \\cos(4\\theta_i) \\right) + \\varepsilon_i,\n$$\n其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_i^2)$ 是独立的高斯误差。这是一个关于参数的线性回归。定义设计矩阵 $\\mathbf{X}\\in\\mathbb{R}^{N\\times 2}$ 和数据向量 $\\mathbf{y}\\in\\mathbb{R}^N$ 如下\n$$\n\\mathbf{X}_i = \\begin{bmatrix} L_i & L_i \\cos(4\\theta_i) \\end{bmatrix}, \\quad \\mathbf{y}_i = E_i,\n$$\n以及权重 $w_i = \\sigma_i^{-2}$，因此 $\\mathbf{W} = \\mathrm{diag}(w_1,\\dots,w_N)$。最大似然（加权最小二乘）估计量求解以下问题\n$$\n\\hat{\\mathbf{b}} = \\arg\\min_{\\mathbf{b}} (\\mathbf{y}-\\mathbf{X}\\mathbf{b})^\\top \\mathbf{W} (\\mathbf{y}-\\mathbf{X}\\mathbf{b}),\n$$\n其闭式解为\n$$\n\\hat{\\mathbf{b}} = (\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{W} \\mathbf{y},\n$$\n参数协方差为\n$$\n\\mathrm{Cov}(\\hat{\\mathbf{b}}) = (\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X})^{-1}.\n$$\n后者源于已知噪声方差的线性高斯模型的克拉默-拉奥下界，并且对于加权最小二乘最大似然估计量而言是精确的。\n\n$\\beta(\\theta)$ 和 $\\tilde{\\beta}(\\theta)$ 的不确定性传播。对于任何评估角度 $\\theta$，$\\beta(\\theta)$ 是参数的线性函数：\n$$\n\\beta(\\theta) = \\begin{bmatrix} 1 & \\cos(4\\theta) \\end{bmatrix} \\mathbf{b}.\n$$\n因此，如果我们定义行向量 $\\mathbf{a}(\\theta) = \\begin{bmatrix} 1 & \\cos(4\\theta)\\end{bmatrix}$，则估计量 $\\hat{\\beta}(\\theta)$ 的方差为\n$$\n\\mathrm{Var}[\\hat{\\beta}(\\theta)] = \\mathbf{a}(\\theta) \\, \\mathrm{Cov}(\\hat{\\mathbf{b}})\\, \\mathbf{a}(\\theta)^\\top,\n$$\n单西格玛误差棒是其平方根。\n\n对于刚度，计算该参数化形式的精确二阶导数：\n$$\n\\frac{d^2 \\beta(\\theta)}{d\\theta^2} = -16\\, b_4 \\cos(4\\theta),\n$$\n因此\n$$\n\\tilde{\\beta}(\\theta) = \\beta(\\theta) + \\frac{d^2\\beta}{d\\theta^2} = b_0 - 15\\, b_4 \\cos(4\\theta).\n$$\n这同样是 $\\mathbf{b}$ 的线性函数，其行向量为 $\\tilde{\\mathbf{a}}(\\theta) = \\begin{bmatrix} 1 & -15\\cos(4\\theta) \\end{bmatrix}$。因此\n$$\n\\mathrm{Var}[\\hat{\\tilde{\\beta}(\\theta)}] = \\tilde{\\mathbf{a}}(\\theta)\\, \\mathrm{Cov}(\\hat{\\mathbf{b}})\\, \\tilde{\\mathbf{a}}(\\theta)^\\top.\n$$\n\n算法：\n1. 对于每个数据集，使用 $\\cos(4\\theta_i)$ 从 $(\\theta_i,L_i)$ 构建 $\\mathbf{X}$，从 $E_i$ 组装 $\\mathbf{y}$，并从 $\\sigma_i$ 构造 $\\mathbf{W}$。\n2. 使用上述公式计算 $\\hat{\\mathbf{b}}$ 和 $\\mathrm{Cov}(\\hat{\\mathbf{b}})$。\n3. 对于评估角度 $\\theta \\in \\{0,\\pi/8,\\pi/4\\}$，通过线性传播公式计算 $\\hat{\\beta}(\\theta)$ 和 $\\hat{\\tilde{\\beta}}(\\theta)$ 及其单西格玛标准差。\n4. 以 $\\mathrm{eV/nm}$ 为单位报告所有值。将每个值四舍五入到小数点后六位，以生成稳定、无歧义的浮点数。\n5. 将案例 1、案例 2、然后案例 3 的结果按规定顺序聚合成一个单一的扁平化列表：\n   $\\beta(0)$、$\\mathrm{std}[\\beta(0)]$、$\\beta(\\pi/8)$、$\\mathrm{std}[\\beta(\\pi/8)]$、$\\beta(\\pi/4)$、$\\mathrm{std}[\\beta(\\pi/4)]$、$\\tilde{\\beta}(0)$、$\\mathrm{std}[\\tilde{\\beta}(0)]$、$\\tilde{\\beta}(\\pi/8)$、$\\mathrm{std}[\\tilde{\\beta}(\\pi/8)]$、$\\tilde{\\beta}(\\pi/4)$、$\\mathrm{std}[\\tilde{\\beta}(\\pi/4)]$。\n   \n科学真实性与解释。$\\tilde{\\beta}(\\theta)$ 的正性是毛细作用驱动的取向稳定性的一个一致性要求；可以使用拟合的参数和传播的不确定性进行后验检查。DFT 不确定性仅通过 $\\mathbf{W}$ 进入模型，所得的参数协方差清晰地量化了计算不确定性如何传播到 $\\beta$ 和 $\\tilde{\\beta}$ 的误差棒上。\n\n实现仅使用线性代数，并采取了标准的数值条件预防措施（测试用例确保了设计矩阵是满秩的）。所有角度均以弧度为单位，所有能量、长度和最终的线张力均使用指定的物理单位，从而保证 $\\beta$ 和 $\\tilde{\\beta}$ 的输出单位符合要求的 $\\mathrm{eV/nm}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef weighted_least_squares(X, y, sigma):\n    \"\"\"\n    Solve for b in y = X b with weights w_i = 1/sigma_i^2.\n    Returns (b_hat, Cov_b).\n    \"\"\"\n    w = 1.0 / (sigma ** 2)\n    W = np.diag(w)\n    XtW = X.T @ W\n    XtWX = XtW @ X\n    XtWy = XtW @ y\n    # Solve normal equations\n    try:\n        XtWX_inv = np.linalg.inv(XtWX)\n    except np.linalg.LinAlgError:\n        # Fallback using pseudo-inverse for numerical safety\n        XtWX_inv = np.linalg.pinv(XtWX)\n    b_hat = XtWX_inv @ XtWy\n    Cov_b = XtWX_inv\n    return b_hat, Cov_b\n\ndef evaluate_with_uncertainty(b_hat, Cov_b, thetas):\n    \"\"\"\n    For each theta in thetas, compute:\n    - beta(theta) and its std\n    - tilde_beta(theta) and its std\n    Returns arrays beta_vals, beta_stds, tbeta_vals, tbeta_stds.\n    \"\"\"\n    beta_vals = []\n    beta_stds = []\n    tbeta_vals = []\n    tbeta_stds = []\n    for th in thetas:\n        c4 = np.cos(4.0 * th)\n        a = np.array([1.0, c4])             # for beta(theta)\n        at = np.array([1.0, -15.0 * c4])    # for tilde_beta(theta) = b0 - 15 b4 cos(4 theta)\n        beta_th = a @ b_hat\n        var_beta = a @ Cov_b @ a\n        tbeta_th = at @ b_hat\n        var_tbeta = at @ Cov_b @ at\n        beta_vals.append(beta_th)\n        beta_stds.append(np.sqrt(max(var_beta, 0.0)))\n        tbeta_vals.append(tbeta_th)\n        tbeta_stds.append(np.sqrt(max(var_tbeta, 0.0)))\n    return np.array(beta_vals), np.array(beta_stds), np.array(tbeta_vals), np.array(tbeta_stds)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a list of tuples: (theta [rad], L [nm], E [eV], sigma [eV])\n    case1 = [\n        (0.0000000000, 5.0, 1.1000000000, 0.020),\n        (0.3926990817, 4.0, 0.8400000000, 0.015),\n        (0.7853981634, 6.0, 1.2000000000, 0.020),\n        (0.1963495408, 3.0, 0.6512132034, 0.010),\n        (0.5890486225, 7.0, 1.4205025254, 0.025),\n    ]\n    case2 = [\n        (0.0000000000, 10.0, 1.8000000000, 0.050),\n        (0.2617993878, 8.0, 1.4400000000, 0.040),\n        (0.5235987756, 12.0, 2.1600000000, 0.060),\n        (0.7853981634, 7.0, 1.2600000000, 0.030),\n    ]\n    case3 = [\n        (0.1963495408, 6.0, 1.8424264068, 0.030),\n        (0.0000000000, 9.0, 2.7900000000, 0.020),\n        (0.5890486225, 5.5, 1.6111091271, 0.040),\n        (0.3926990817, 7.5, 2.2500000000, 0.050),\n    ]\n\n    test_cases = [case1, case2, case3]\n\n    eval_thetas = np.array([0.0, np.pi/8.0, np.pi/4.0], dtype=float)\n\n    results = []\n    for case in test_cases:\n        data = np.array(case, dtype=float)\n        theta = data[:, 0]\n        L = data[:, 1]\n        E = data[:, 2]\n        sigma = data[:, 3]\n\n        # Build design matrix X with columns [L, L*cos(4*theta)]\n        c4 = np.cos(4.0 * theta)\n        X = np.column_stack([L, L * c4])\n        y = E\n\n        b_hat, Cov_b = weighted_least_squares(X, y, sigma)\n\n        beta_vals, beta_stds, tbeta_vals, tbeta_stds = evaluate_with_uncertainty(b_hat, Cov_b, eval_thetas)\n\n        # Append in the required order for this case:\n        # beta(0), std beta(0), beta(pi/8), std, beta(pi/4), std,\n        # tilde_beta(0), std, tilde_beta(pi/8), std, tilde_beta(pi/4), std\n        # Round to 6 decimals as required.\n        ordered = [\n            beta_vals[0], beta_stds[0],\n            beta_vals[1], beta_stds[1],\n            beta_vals[2], beta_stds[2],\n            tbeta_vals[0], tbeta_stds[0],\n            tbeta_vals[1], tbeta_stds[1],\n            tbeta_vals[2], tbeta_stds[2],\n        ]\n        results.extend([f\"{val:.6f}\" for val in ordered])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2790696"}]}