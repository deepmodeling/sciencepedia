{"hands_on_practices": [{"introduction": "原子力显微镜 (AFM) 是纳米力学中的关键工具，但其测量的准确性依赖于精确校准。本实践将应用贝叶斯线性回归这一基础的概率机器学习方法，从含噪声数据中确定 AFM 的偏转灵敏度 $S$。通过完成此练习，您不仅将学会估计校准参数，还将学会如何严格地量化和传递其不确定性，这是进行稳健实验分析的一项关键技能。[@problem_id:2777620]", "problem": "原子力显微镜（AFM）的偏转灵敏度校准，旨在将光电二极管电压与在刚性参考表面上的垂直压电位移关联起来。您将使用已知高斯噪声的贝叶斯线性回归构建一个概率校准曲线，然后量化从源悬臂切换到目标悬臂时的校准传递不确定度。建模假设和任务如下。\n\n建模假设：\n- 测量模型是线性的：表面接近位移（单位为纳米nm），表示为 $z$（$\\mathrm{nm}$），与光电二极管电压 $V$（$\\mathrm{V}$）通过 $z = \\alpha + \\beta V + \\epsilon$ 相关联，其中 $\\epsilon$ 是加性零均值高斯噪声，其已知方差为 $\\sigma^2$（$\\mathrm{nm}^2$）。此处，$\\alpha$ 是截距（$\\mathrm{nm}$），$\\beta$ 是偏转灵敏度（$\\mathrm{nm/V}$）。\n- 对 $\\theta = [\\alpha,\\beta]^T$ 设置高斯先验：$\\theta \\sim \\mathcal{N}(m_0, V_0)$，其中 $m_0 \\in \\mathbb{R}^2$ 且 $V_0 \\in \\mathbb{R}^{2 \\times 2}$ 为正定矩阵。\n- 切换悬臂时，目标悬臂的参数 $\\theta_t$ 被建模为对源悬臂后验参数 $\\theta_s$ 的一个高斯扰动：$\\theta_t = \\theta_s + \\delta$，其中 $\\delta \\sim \\mathcal{N}(0, T)$，且 $T \\in \\mathbb{R}^{2 \\times 2}$ 为半正定矩阵。这意味着目标悬臂的传递先验为 $\\theta_t \\sim \\mathcal{N}(m_s, V_s + T)$，其中 $(m_s, V_s)$ 是源后验均值和协方差。\n\n每个测试用例的计算任务：\n1. 使用指定的先验和提供的源数据集 $(V_s, z_s)$，通过计算 $(\\alpha,\\beta)$ 的后验均值和协方差来构建源悬臂的校准曲线。报告 $\\beta$ 的后验均值（$\\mathrm{nm/V}$），作为校准曲线的源偏转灵敏度估计值。\n2. 对于目标悬臂，使用传递先验 $\\mathcal{N}(m_s, V_s + T)$ 和目标数据集 $(V_t, z_t)$ 来计算后验。对于每个指定的查询电压 $V^\\star$，计算 $z$ 的后验预测均值（$\\mathrm{nm}$）。\n3. 按如下方式量化每个 $V^\\star$ 处的校准传递不确定度。令 $\\mathrm{Var}_T(z^\\star)$ 为使用包含切换协方差 $T$ 的传递先验计算出的 $V^\\star$ 处的后验预测方差，并令 $\\mathrm{Var}_0(z^\\star)$ 为使用相同目标数据但将 $T$ 设置为零矩阵（即无切换不确定度，使用源后验作为先验）计算出的后验预测方差。定义校准传递不确定度为\n$U(V^\\star) = \\sqrt{\\max\\{0, \\mathrm{Var}_T(z^\\star) - \\mathrm{Var}_0(z^\\star)\\}}$（$\\mathrm{nm}$）。\n\n您的程序必须使用任何现代编程语言实现上述内容，并采用以下测试套件和参数。将已知噪声标准差 $\\sigma$ 视为每个案例的指定值。所有案例使用相同的先验 $(m_0, V_0)$。所有数组均已明确给出，必须原样使用，不得修改。\n\n所有测试用例的通用先验：\n- $m_0 = [0.0, 40.0]^T$\n- $V_0 = \\mathrm{diag}([100.0, 100.0])$\n\n测试用例 1：\n- 源数据 $(V_s, z_s)$:\n  - $V_s = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]$ in $\\mathrm{V}$\n  - $z_s = [0.52, 10.02, 19.75, 29.27, 38.94, 48.48]$ in $\\mathrm{nm}$\n- 目标数据 $(V_t, z_t)$:\n  - $V_t = [0.15, 0.5, 0.9]$ in $\\mathrm{V}$\n  - $z_t = [7.76, 25.32, 45.29]$ in $\\mathrm{nm}$\n- 已知噪声: $\\sigma = 0.3$ in $\\mathrm{nm}$\n- 切换协方差 $T = \\mathrm{diag}([0.5^2, 3.0^2])$，单位为 $\\mathrm{nm}^2$ 和 $(\\mathrm{nm/V})^2$\n- 查询电压: $V^\\star \\in \\{0.3, 1.2\\}$ in $\\mathrm{V}$\n\n测试用例 2：\n- 源数据 $(V_s, z_s)$:\n  - $V_s = [0.0, 0.5, 1.0, 1.5]$ in $\\mathrm{V}$\n  - $z_s = [0.01, 7.52, 15.02, 22.57]$ in $\\mathrm{nm}$\n- 目标数据 $(V_t, z_t)$:\n  - $V_t = [0.2]$ in $\\mathrm{V}$\n  - $z_t = [3.02]$ in $\\mathrm{nm}$\n- 已知噪声: $\\sigma = 0.2$ in $\\mathrm{nm}$\n- 切换协方差 $T = \\mathrm{diag}([0.2^2, 1.5^2])$\n- 查询电压: $V^\\star \\in \\{0.2, 1.0\\}$ in $\\mathrm{V}$\n\n测试用例 3：\n- 源数据 $(V_s, z_s)$:\n  - $V_s = [0.0, 0.25, 0.5, 0.75]$ in $\\mathrm{V}$\n  - $z_s = [-1.00, 12.70, 26.56, 40.21]$ in $\\mathrm{nm}$\n- 目标数据 $(V_t, z_t)$:\n  - $V_t = [0.1, 0.7]$ in $\\mathrm{V}$\n  - $z_t = [5.53, 41.48]$ in $\\mathrm{nm}$\n- 已知噪声: $\\sigma = 0.25$ in $\\mathrm{nm}$\n- 切换协方差 $T = \\mathrm{diag}([0.8^2, 5.0^2])$\n- 查询电压: $V^\\star \\in \\{0.0, 0.5, 1.0\\}$ in $\\mathrm{V}$\n\n要求的输出和单位：\n- 对于每个测试用例，输出一个列表，其第一个元素是源偏转灵敏度 $\\beta$ 的后验均值（$\\mathrm{nm/V}$），其后是针对每个 $V^\\star$ 的 $z$ 的后验预测均值（$\\mathrm{nm}$）和校准传递不确定度 $U(V^\\star)$（$\\mathrm{nm}$）组成的对，按上面提供 $V^\\star$ 值的顺序排列。\n- 所有数值输出必须以指定单位表示，并四舍五入到恰好六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的、以逗号分隔的结果列表，其中每个测试用例贡献一个如上所述的、由方括号括起来的、以逗号分隔的子列表。例如：\"[[case1_item1,case1_item2,...],[case2_item1,...],[case3_item1,...]]\"。确保每个浮点数小数点后恰好有六位数字。", "solution": "该问题是应用贝叶斯统计（特别是关于线性回归）中一个标准的、适定的练习。它在纳米力学领域有坚实的科学基础，用于校准原子力显微镜。我们将进行正式的求解。\n\n问题的核心在于将贝叶斯推断应用于线性模型。光电二极管电压 $V$ 和压电位移 $z$ 之间的关系由以下线性方程给出：\n$$\nz = \\alpha + \\beta V + \\epsilon\n$$\n其中 $\\theta = [\\alpha, \\beta]^T$ 是模型参数（截距和灵敏度），$\\epsilon$ 是加性高斯噪声，其均值为零，已知方差为 $\\sigma^2$，即 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n这可以用矩阵表示法来表达。对于一组 $N$ 个观测值 $(V_i, z_i)$，我们可以写成 $z_i = \\phi_i^T \\theta + \\epsilon_i$，其中 $\\phi_i = [1, V_i]^T$。对于整个数据集 $D = \\{(V_i, z_i)\\}_{i=1}^N$ 的似然函数是：\n$$\np(z | \\theta, X, \\sigma^2) = (2\\pi\\sigma^2)^{-N/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(z - X\\theta)^T(z - X\\theta)\\right)\n$$\n其中 $z = [z_1, ..., z_N]^T$ 是位移测量向量，$X$ 是一个 $N \\times 2$ 的设计矩阵，其行是 $\\phi_i^T$。\n\n对参数 $\\theta$ 设置一个高斯先验 $\\theta \\sim \\mathcal{N}(m_0, V_0)$。根据贝叶斯定理，后验分布与似然和先验的乘积成正比：$p(\\theta|D) \\propto p(z|\\theta)p(\\theta)$。对于共轭的高斯先验和似然，$\\theta$ 的后验分布也是一个高斯分布，$\\theta | D \\sim \\mathcal{N}(m_N, V_N)$，其后验均值 $m_N$ 和协方差 $V_N$ 由以下公式给出：\n$$\nV_N = \\left( V_0^{-1} + \\frac{1}{\\sigma^2} X^T X \\right)^{-1}\n$$\n$$\nm_N = V_N \\left( V_0^{-1} m_0 + \\frac{1}{\\sigma^2} X^T z \\right)\n$$\n这些公式提供了在观测到数据后更新我们对参数 $\\theta$ 信念的机制。\n\n计算任务按如下步骤执行：\n\n1.  **源悬臂校准**：我们首先计算源悬臂参数 $\\theta_s = [\\alpha_s, \\beta_s]^T$ 的后验分布。我们使用指定的通用先验 $(m_0, V_0)$ 和源数据集 $(V_s, z_s)$。我们从 $V_s$ 构建源设计矩阵 $X_s$，并应用更新方程来找到源后验均值 $m_s$ 和协方差 $V_s$。估计的源偏转灵敏度是后验均值向量 $m_s$ 的第二个分量。\n\n2.  **目标悬臂的后验预测均值**：当切换到目标悬臂时，假定其参数是源参数的一个扰动。这通过目标参数 $\\theta_t$ 的一个传递先验来建模：\n    $$\n    \\theta_t \\sim \\mathcal{N}(m_s, V_s + T)\n    $$\n    其中 $T$ 是指定的切换协方差矩阵。然后使用目标数据集 $(V_t, z_t)$ 更新这个新先验，以获得目标后验分布 $\\theta_t | D_t \\sim \\mathcal{N}(m_t, V_t)$。\n    对于一个新的查询电压 $V^\\star$，我们形成一个设计向量 $\\phi^\\star = [1, V^\\star]^T$。相应位移 $z^\\star$ 的后验预测分布是一个高斯分布。其均值，即我们的预测值，由下式给出：\n    $$\n    E[z^\\star | D_t, V^\\star] = (\\phi^\\star)^T m_t\n    $$\n\n3.  **校准传递不确定度**：这个量度量了由悬臂切换过程引入的额外不确定度，该过程由矩阵 $T$ 捕捉。我们在两种条件下计算 $z^\\star$ 的后验预测方差。\n    首先，使用包含 $T$ 的完整传递先验，方差为：\n    $$\n    \\mathrm{Var}_T(z^\\star) = \\sigma^2 + (\\phi^\\star)^T V_t \\phi^\\star\n    $$\n    这里，$V_t$ 是使用先验协方差 $V_s + T$ 计算出的目标后验协方差。$\\sigma^2$ 项解释了新测量的观测噪声。\n    其次，我们通过将 $T$ 设置为零矩阵来计算基线方差 $\\mathrm{Var}_0(z^\\star)$。这对应于切换没有引入额外不确定度的情况；源后验直接用作目标的先验。此计算产生一个不同的目标后验协方差，我们称之为 $V_{t,0}$，方差为：\n    $$\n    \\mathrm{Var}_0(z^\\star) = \\sigma^2 + (\\phi^\\star)^T V_{t,0} \\phi^\\star\n    $$\n    然后，校准传递不确定度的定义和计算如下：\n    $$\n    U(V^\\star) = \\sqrt{\\max\\{0, \\mathrm{Var}_T(z^\\star) - \\mathrm{Var}_0(z^\\star)\\}} = \\sqrt{\\max\\{0, (\\phi^\\star)^T (V_t - V_{t,0}) \\phi^\\star\\}}\n    $$\n实现将为每个指定的测试用例系统地应用这些矩阵计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AFM calibration problem using Bayesian linear regression\n    for the provided test cases.\n    \"\"\"\n\n    # Common prior parameters\n    m0 = np.array([0.0, 40.0])\n    V0 = np.diag([100.0, 100.0])\n\n    test_cases = [\n        {\n            \"Vs\": np.array([0.0, 0.2, 0.4, 0.6, 0.8, 1.0]),\n            \"zs\": np.array([0.52, 10.02, 19.75, 29.27, 38.94, 48.48]),\n            \"Vt\": np.array([0.15, 0.5, 0.9]),\n            \"zt\": np.array([7.76, 25.32, 45.29]),\n            \"sigma\": 0.3,\n            \"T\": np.diag([0.5**2, 3.0**2]),\n            \"V_star\": [0.3, 1.2],\n        },\n        {\n            \"Vs\": np.array([0.0, 0.5, 1.0, 1.5]),\n            \"zs\": np.array([0.01, 7.52, 15.02, 22.57]),\n            \"Vt\": np.array([0.2]),\n            \"zt\": np.array([3.02]),\n            \"sigma\": 0.2,\n            \"T\": np.diag([0.2**2, 1.5**2]),\n            \"V_star\": [0.2, 1.0],\n        },\n        {\n            \"Vs\": np.array([0.0, 0.25, 0.5, 0.75]),\n            \"zs\": np.array([-1.00, 12.70, 26.56, 40.21]),\n            \"Vt\": np.array([0.1, 0.7]),\n            \"zt\": np.array([5.53, 41.48]),\n            \"sigma\": 0.25,\n            \"T\": np.diag([0.8**2, 5.0**2]),\n            \"V_star\": [0.0, 0.5, 1.0],\n        },\n    ]\n\n    def bayesian_update(prior_mean, prior_cov, V_data, z_data, sigma2):\n        \"\"\"\n        Computes the posterior mean and covariance for a linear model.\n        \"\"\"\n        X_data = np.vstack((np.ones_like(V_data), V_data)).T\n        prior_cov_inv = np.linalg.inv(prior_cov)\n        \n        # Posterior covariance\n        post_cov_inv = prior_cov_inv + (1.0 / sigma2) * X_data.T @ X_data\n        post_cov = np.linalg.inv(post_cov_inv)\n        \n        # Posterior mean\n        post_mean = post_cov @ (prior_cov_inv @ prior_mean + (1.0 / sigma2) * X_data.T @ z_data)\n        \n        return post_mean, post_cov\n\n    all_results = []\n    for case in test_cases:\n        Vs, zs = case[\"Vs\"], case[\"zs\"]\n        Vt, zt = case[\"Vt\"], case[\"zt\"]\n        sigma = case[\"sigma\"]\n        T = case[\"T\"]\n        V_star_list = case[\"V_star\"]\n        sigma2 = sigma**2\n        \n        case_outputs = []\n\n        # 1. Source cantilever calibration\n        ms_post, Vs_post = bayesian_update(m0, V0, Vs, zs, sigma2)\n        source_beta_mean = ms_post[1]\n        case_outputs.append(source_beta_mean)\n        \n        # 2. & 3. Target cantilever posterior and uncertainty\n        \n        # Compute target posterior with transfer uncertainty T\n        mt_post_T, Vt_post_T = bayesian_update(ms_post, Vs_post + T, Vt, zt, sigma2)\n        \n        # Compute target posterior without transfer uncertainty (T=0)\n        # The prior covariance is just the source posterior covariance Vs_post.\n        _ , Vt_post_0 = bayesian_update(ms_post, Vs_post, Vt, zt, sigma2)\n        \n        for v_star in V_star_list:\n            phi_star = np.array([1.0, v_star])\n            \n            # Posterior predictive mean\n            pred_mean = phi_star @ mt_post_T\n            \n            # Predictive variances for uncertainty calculation\n            pred_var_T_component = phi_star.T @ Vt_post_T @ phi_star\n            pred_var_0_component = phi_star.T @ Vt_post_0 @ phi_star\n            \n            # Calibration transfer uncertainty\n            variance_diff = pred_var_T_component - pred_var_0_component\n            uncertainty = np.sqrt(max(0, variance_diff))\n            \n            case_outputs.append(pred_mean)\n            case_outputs.append(uncertainty)\n            \n        all_results.append(case_outputs)\n\n    # Format output string\n    formatted_results = []\n    for result_list in all_results:\n        formatted_list = [f\"{x:.6f}\" for x in result_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2777620"}, {"introduction": "从动态实验中提取诸如粘附能 $W$ 之类的基本材料特性，通常涉及复杂的非线性模型。这项高级实践将向您介绍哈密顿蒙特卡洛 (Hamiltonian Monte Carlo, HMC) 算法，这是一种用于贝叶斯推断的强大工具，可用于从模拟的动态力谱数据中估计粘附功。通过从零开始实现 HMC，您将亲身体验这种用于探索复杂概率分布并从噪声测量中获得物理参数稳健估计的先进采样方法。[@problem_id:2777678]", "problem": "实现一个完整、可运行的程序，使用哈密顿蒙特卡洛 (Hamiltonian Monte Carlo, HMC) 方法，根据动态加载下纳米级接触中的带噪声拉脱力数据，推断单位面积黏附能的后验分布，并计算在新的加载速率下拉脱力的后验预测均值。请基于以下基本原理进行推导和算法构建。\n\n假设在半径为 $R$ 的球形针尖与平坦基底之间存在一个轴对称的纳米级接触，其中在零加载速率下的准静态拉脱力遵循 Johnson–Kendall–Roberts (JKR) 理论的预测。JKR 接触力学给出的零加载速率下拉脱力与单位面积的黏附功 $W$ 成正比，表示为\n$$\nF_{0}(W) = \\frac{3}{2}\\pi R W .\n$$\n在动态加载下，遵循动态力谱学的 Bell–Evans 模型，引入一个与加载速率 $r$ 的自然对数成比例的热激活修正项，得到预期的拉脱力\n$$\n\\mu(W, r) = F_{0}(W) + \\frac{k_{\\mathrm{B}} T}{x_{\\mathrm{b}}} \\ln\\!\\left(\\frac{r}{r_{\\mathrm{ref}}}\\right) ,\n$$\n其中，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$x_{\\mathrm{b}}$ 是有效键长，$r_{\\mathrm{ref}}$ 是参考加载速率。设在加载速率 $r_{i}$ 下观测到的拉脱力 $F_{i}$ 可被建模为\n$$\nF_{i} \\mid W \\sim \\mathcal{N}\\!\\big(\\mu(W, r_{i}), \\sigma_{n}^{2}\\big) ,\n$$\n并具有已知标准差 $\\sigma_{n}$ 的独立高斯噪声。\n\n为确保 $W$ 的正性，使用 $\\theta = \\ln W$ 进行重参数化。对 $\\theta$ 设置一个高斯先验分布，\n$$\n\\theta \\sim \\mathcal{N}(m_{\\theta}, s_{\\theta}^{2}) .\n$$\n你的程序必须：\n- 根据上述定义，推导并实现负对数后验概率 $U(\\theta)$ 及其梯度 $\\nabla_{\\theta} U(\\theta)$（不要使用自动微分）。\n- 实现使用蛙跳积分器和单位质量的哈密顿蒙特卡洛方法，从后验分布 $p(\\theta \\mid \\{(r_{i}, F_{i})\\})$ 中进行采样。\n- 使用 $\\theta$ 的后验样本，通过对后验分布求期望，计算在指定的新加载速率 $r_{\\star}$ 下的后验预测平均力。由于观测噪声的均值为零，在 $r_{\\star}$ 处的后验预测均值为：\n$$\n\\mathbb{E}\\left[F_{\\star} \\mid \\{(r_{i}, F_{i})\\}\\right] = \\mathbb{E}_{\\theta \\mid \\text{data}}\\left[\\mu\\!\\left(e^{\\theta}, r_{\\star}\\right)\\right] .\n$$\n\n始终使用国际单位制 (SI)。所有力必须以牛顿 (Newtons) 为单位报告。不涉及角度。不涉及百分比。最终的数值输出必须是浮点数，单位为牛顿 (Newtons)。\n\n所有测试用例使用的常量：\n- 玻尔兹曼常数 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$。\n- 温度 $T = 298\\ \\mathrm{K}$。\n- 有效键长 $x_{\\mathrm{b}} = 1.0\\times 10^{-10}\\ \\mathrm{m}$。\n- 参考加载速率 $r_{\\mathrm{ref}} = 1.0\\ \\mathrm{N/s}$。\n- 针尖半径 $R = 3.0\\times 10^{-8}\\ \\mathrm{m}$。\n- $\\theta$ 的先验均值和标准差：$m_{\\theta} = \\ln(0.25)$ 和 $s_{\\theta} = 0.5$。\n- HMC 超参数：步长 $\\epsilon = 0.01$，蛙跳步数 $L = 25$，预烧期采样次数 $N_{\\mathrm{burn}} = 1000$，后验采样次数 $N_{\\mathrm{samples}} = 3000$，单位质量。\n\n每个测试用例的数据生成协议：\n- 对每个案例，首先计算无噪声的均值 $\\mu(W_{\\mathrm{true}}, r_{i})$，然后使用指定的数据生成随机种子添加标准差为 $\\sigma_{n}$ 的独立高斯噪声，从而生成合成的观测力。为保证可复现性，使用提供的固定随机数生成器种子。\n\n后验采样协议：\n- 在 $\\theta_{0} = m_{\\theta}$ 处初始化 HMC。\n- 使用指定的 HMC 随机种子进行动量变量采样和接受/拒绝步骤。\n\n后验预测协议：\n- 对每个测试用例，使用 $\\theta$ 的后验样本计算在三个新的加载速率 $r_{\\star} \\in \\{10^{0}, 10^{3}, 10^{6}\\}\\ \\mathrm{N/s}$ 下的后验预测均值。\n\n测试套件：\n- 案例 1：\n  - 真实黏附能 $W_{\\mathrm{true}} = 0.20\\ \\mathrm{J/m^{2}}$。\n  - 噪声标准差 $\\sigma_{n} = 2.0\\times 10^{-10}\\ \\mathrm{N}$。\n  - 加载速率 $r_{i} \\in \\{10^{-1}, 10^{0}, 10^{1}, 10^{2}, 10^{3}, 10^{4}, 10^{5}, 10^{6}\\}\\ \\mathrm{N/s}$。\n  - 数据生成种子 $s_{\\mathrm{data}} = 12345$。\n  - HMC 种子 $s_{\\mathrm{hmc}} = 24680$。\n- 案例 2：\n  - 真实黏附能 $W_{\\mathrm{true}} = 0.15\\ \\mathrm{J/m^{2}}$。\n  - 噪声标准差 $\\sigma_{n} = 5.0\\times 10^{-10}\\ \\mathrm{N}$。\n  - 加载速率 $r_{i} \\in \\{10^{0}, 10^{6}\\}\\ \\mathrm{N/s}$。\n  - 数据生成种子 $s_{\\mathrm{data}} = 54321$。\n  - HMC 种子 $s_{\\mathrm{hmc}} = 13579$。\n- 案例 3：\n  - 真实黏附能 $W_{\\mathrm{true}} = 0.35\\ \\mathrm{J/m^{2}}$。\n  - 噪声标准差 $\\sigma_{n} = 3.0\\times 10^{-10}\\ \\mathrm{N}$。\n  - 加载速率 $r_{i} \\in \\{10^{-2}, 10^{-1}, 10^{0}, 10^{3}, 10^{5}, 10^{7}\\}\\ \\mathrm{N/s}$。\n  - 数据生成种子 $s_{\\mathrm{data}} = 2023$。\n  - HMC 种子 $s_{\\mathrm{hmc}} = 97531$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含一个列表的列表。对于按顺序排列的每个测试用例 (案例 1、案例 2、案例 3)，按顺序输出一个包含三个浮点数的列表，这些浮点数等于在新的加载速率 $r_{\\star} \\in \\{10^{0}, 10^{3}, 10^{6}\\}\\ \\mathrm{N/s}$ 下的后验预测均值 (单位为牛顿)。将这三个针对每个案例的列表聚合到一个外层列表中。例如，一个语法正确的输出如下所示：\n$$\n[[f_{11},f_{12},f_{13}],[f_{21},f_{22},f_{23}],[f_{31},f_{32},f_{33}]]\n$$\n其中每个 $f_{jk}$ 是一个以牛顿为单位的浮点数。打印的行必须只包含这个用括号括起来并用逗号分隔的列表。", "solution": "该问题已经过验证，并被认定为有效。其科学基础是接触力学 (Johnson–Kendall–Roberts 理论) 和动态力谱学 (Bell–Evans 模型) 的既定原理。该问题在数学上是适定的，提供了一个完整且一致的贝叶斯推断框架。所有参数、常数和程序步骤都已明确指定，使得问题明确且自洽。实现一个哈密顿蒙特卡洛采样器以从合成数据中推断物理参数，是计算物理和统计学中一个标准且重要的课题。我现在开始提供解决方案。\n\n问题的核心是从带噪声的拉脱力测量值中推断黏附功 $W$ 的后验分布，然后使用该后验分布来预测在新的加载速率下的力。为确保正性，我们使用重参数化的变量 $\\theta = \\ln W$。\n\n### 1. 贝叶斯模型构建\n\n给定观测数据 $D = \\{(r_i, F_i)\\}_{i=1}^N$，$\\theta$ 的后验分布由贝叶斯定理给出：\n$$\np(\\theta \\mid D) \\propto p(D \\mid \\theta) p(\\theta)\n$$\n其中 $p(D \\mid \\theta)$ 是似然， $p(\\theta)$ 是先验。\n\n**似然**：观测力 $F_i$ 被建模为独立的、以平均力 $\\mu(W, r_i)$ 为中心、已知方差为 $\\sigma_n^2$ 的高斯随机变量。通过代换 $W = e^\\theta$，单个数据点 $(r_i, F_i)$ 的似然为：\n$$\np(F_i \\mid \\theta) = \\mathcal{N}\\big(F_i; \\mu(e^\\theta, r_i), \\sigma_n^2\\big) = \\frac{1}{\\sqrt{2\\pi\\sigma_n^2}} \\exp\\left(-\\frac{(F_i - \\mu(e^\\theta, r_i))^2}{2\\sigma_n^2}\\right)\n$$\n平均力 $\\mu(e^\\theta, r_i)$ 由下式给出：\n$$\n\\mu(e^\\theta, r_i) = \\frac{3}{2}\\pi R e^\\theta + \\frac{k_{\\mathrm{B}} T}{x_{\\mathrm{b}}} \\ln\\left(\\frac{r_i}{r_{\\mathrm{ref}}}\\right)\n$$\n由于观测是独立的，总似然是各单个似然的乘积：\n$$\np(D \\mid \\theta) = \\prod_{i=1}^N p(F_i \\mid \\theta)\n$$\n\n**先验**：对 $\\theta$ 设置一个高斯先验：\n$$\np(\\theta) = \\mathcal{N}(\\theta; m_\\theta, s_\\theta^2) = \\frac{1}{\\sqrt{2\\pi s_\\theta^2}} \\exp\\left(-\\frac{(\\theta - m_\\theta)^2}{2s_\\theta^2}\\right)\n$$\n\n**后验**：对数后验是对数似然和对数先验的和。忽略与 $\\theta$ 无关的常数项：\n$$\n\\ln p(\\theta \\mid D) \\propto -\\sum_{i=1}^N \\frac{(F_i - \\mu(e^\\theta, r_i))^2}{2\\sigma_n^2} - \\frac{(\\theta - m_\\theta)^2}{2s_\\theta^2}\n$$\n\n### 2. 用于 HMC 的势能及其梯度\n\n哈密顿蒙特卡洛 (HMC) 需要定义一个势能函数 $U(\\theta)$，即负对数后验概率。\n$$\nU(\\theta) = - \\ln p(\\theta \\mid D) = \\frac{1}{2\\sigma_n^2} \\sum_{i=1}^N (F_i - \\mu(e^\\theta, r_i))^2 + \\frac{1}{2s_\\theta^2} (\\theta - m_\\theta)^2\n$$\nHMC 算法还需要势能相对于参数 $\\theta$ 的梯度，记为 $\\nabla_\\theta U(\\theta) = \\frac{dU}{d\\theta}$。应用链式法则：\n$$\n\\frac{dU}{d\\theta} = \\frac{1}{2\\sigma_n^2} \\sum_{i=1}^N 2(F_i - \\mu(e^\\theta, r_i)) \\cdot \\left(-\\frac{d\\mu(e^\\theta, r_i)}{d\\theta}\\right) + \\frac{1}{2s_\\theta^2} \\cdot 2(\\theta - m_\\theta)\n$$\n我们需要 $\\mu(e^\\theta, r_i)$ 对 $\\theta$ 的导数：\n$$\n\\frac{d\\mu(e^\\theta, r_i)}{d\\theta} = \\frac{d}{d\\theta} \\left( \\frac{3}{2}\\pi R e^\\theta + \\frac{k_{\\mathrm{B}} T}{x_{\\mathrm{b}}} \\ln\\left(\\frac{r_i}{r_{\\mathrm{ref}}}\\right) \\right) = \\frac{3}{2}\\pi R e^\\theta\n$$\n将其代回梯度表达式，得到：\n$$\n\\frac{dU}{d\\theta} = -\\frac{1}{\\sigma_n^2} \\sum_{i=1}^N (F_i - \\mu(e^\\theta, r_i)) \\left(\\frac{3}{2}\\pi R e^\\theta\\right) + \\frac{\\theta - m_\\theta}{s_\\theta^2}\n$$\n这可以重写为：\n$$\n\\frac{dU}{d\\theta} = \\frac{1}{\\sigma_n^2} \\left[ \\sum_{i=1}^N (\\mu(e^\\theta, r_i) - F_i) \\right] \\left(\\frac{3}{2}\\pi R e^\\theta\\right) + \\frac{\\theta - m_\\theta}{s_\\theta^2}\n$$\n为了运行 HMC 采样器，这些关于 $U(\\theta)$ 和 $\\frac{dU}{d\\theta}$ 的表达式需要进行数值实现。\n\n### 3. 哈密顿蒙特卡洛算法\n\nHMC 是一种马尔可夫链蒙特卡洛方法，它利用哈密顿动力学在参数空间中提出新的移动。状态由位置 $\\theta$ 和一个虚构的动量 $p$ 描述。哈密顿量为 $H(\\theta, p) = U(\\theta) + K(p)$，其中 $K(p) = p^2/(2m)$ 是动能。对于本问题，我们使用单位质量，即 $m=1$。\n\n生成一个样本的算法如下：\n1.  **动量采样**：从标准正态分布中抽取一个新的动量值 $p \\sim \\mathcal{N}(0, 1)$。\n2.  **蛙跳积分**：从当前位置 $\\theta_{\\text{curr}}$ 和新动量 $p$ 开始，用步长 $\\epsilon$ 模拟 $L$ 步的动力学过程。蛙跳积分器将哈密顿方程离散化：\n    a. 动量的半步更新：$p \\leftarrow p - (\\epsilon/2) \\nabla_\\theta U(\\theta)$\n    b. 位置的全步更新：$\\theta \\leftarrow \\theta + \\epsilon \\cdot p$\n    c. 重复 $L-1$ 次：\n        i. 动量的全步更新：$p \\leftarrow p - \\epsilon \\nabla_\\theta U(\\theta)$\n        ii. 位置的全步更新：$\\theta \\leftarrow \\theta + \\epsilon \\cdot p$\n    d. 动量的最后半步更新：$p \\leftarrow p - (\\epsilon/2) \\nabla_\\theta U(\\theta)$\n    这个序列得到一个提议状态 $(\\theta_{\\text{prop}}, p_{\\text{prop}})$。\n3.  **Metropolis-Hastings 接受步骤**：根据哈密顿量的变化来接受或拒绝该提议，以确保细致平衡。接受概率 $\\alpha$ 为：\n    $$\n    \\alpha = \\min\\left(1, \\exp\\left(H(\\theta_{\\text{curr}}, p) - H(\\theta_{\\text{prop}}, p_{\\text{prop}})\\right)\\right)\n    $$\n    抽取一个随机数 $u \\in [0, 1]$。如果 $u < \\alpha$，则新状态为 $\\theta_{\\text{next}} = \\theta_{\\text{prop}}$；否则，状态保持为 $\\theta_{\\text{next}} = \\theta_{\\text{curr}}$。\n\n这个过程重复 $N_{\\text{burn}} + N_{\\text{samples}}$ 次迭代。前 $N_{\\text{burn}}$ 个样本（预烧期）被丢弃，以使马尔可夫链收敛到平稳分布，随后的 $N_{\\text{samples}}$ 个样本被保留作为后验分布 $p(\\theta \\mid D)$ 的样本。\n\n### 4. 后验预测推断\n\n一旦我们有了后验样本 $\\{\\theta^{(j)}\\}_{j=1}^{N_{\\text{samples}}}$，我们就可以计算在新加载速率 $r_\\star$ 下的新观测值 $F_\\star$ 的后验预测分布。问题要求计算后验预测均值 $\\mathbb{E}[F_\\star \\mid D]$。由于观测噪声模型 $\\mathcal{N}$ 的均值为零，这个期望简化为对均值函数 $\\mu$ 的后验期望：\n$$\n\\mathbb{E}[F_\\star \\mid D] = \\mathbb{E}_{\\theta \\mid D}\\left[\\mu(e^\\theta, r_\\star)\\right]\n$$\n这个期望可以通过对后验样本进行蒙特卡洛平均来近似：\n$$\n\\mathbb{E}[F_\\star \\mid D] \\approx \\frac{1}{N_{\\text{samples}}} \\sum_{j=1}^{N_{\\text{samples}}} \\mu(e^{\\theta^{(j)}}, r_\\star)\n$$\n其中\n$$\n\\mu(e^{\\theta^{(j)}}, r_\\star) = \\frac{3}{2}\\pi R e^{\\theta^{(j)}} + \\frac{k_{\\mathrm{B}} T}{x_{\\mathrm{b}}} \\ln\\left(\\frac{r_\\star}{r_{\\mathrm{ref}}}\\right)\n$$\n对每个指定的新加载速率 $r_\\star$ 执行此计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Global constants (SI units)\n    K_B = 1.380649e-23  # Boltzmann constant [J/K]\n    T = 298.0  # Temperature [K]\n    X_B = 1.0e-10  # Effective bond length [m]\n    R_REF = 1.0  # Reference loading rate [N/s]\n    R_TIP = 3.0e-8  # Tip radius [m]\n    M_THETA = np.log(0.25)  # Prior mean for theta\n    S_THETA = 0.5  # Prior std dev for theta\n    \n    # HMC hyperparameters\n    EPSILON = 0.01\n    L_STEPS = 25\n    N_BURN = 1000\n    N_SAMPLES = 3000\n\n    # Calculated constants\n    THERMAL_FORCE_CONST = K_B * T / X_B\n    JKR_CONST = 1.5 * np.pi * R_TIP\n\n    test_cases = [\n        {\n            \"W_true\": 0.20, \"sigma_n\": 2.0e-10,\n            \"r_i\": np.array([1e-1, 1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6]),\n            \"s_data\": 12345, \"s_hmc\": 24680,\n        },\n        {\n            \"W_true\": 0.15, \"sigma_n\": 5.0e-10,\n            \"r_i\": np.array([1e0, 1e6]),\n            \"s_data\": 54321, \"s_hmc\": 13579,\n        },\n        {\n            \"W_true\": 0.35, \"sigma_n\": 3.0e-10,\n            \"r_i\": np.array([1e-2, 1e-1, 1e0, 1e3, 1e5, 1e7]),\n            \"s_data\": 2023, \"s_hmc\": 97531,\n        },\n    ]\n\n    r_predict = np.array([1e0, 1e3, 1e6])\n    all_results = []\n\n    for case in test_cases:\n        # Generate synthetic data\n        rng_data = np.random.default_rng(case[\"s_data\"])\n        \n        def mean_force_model(W, r):\n            return JKR_CONST * W + THERMAL_FORCE_CONST * np.log(r / R_REF)\n\n        mu_true = mean_force_model(case[\"W_true\"], case[\"r_i\"])\n        noise = rng_data.normal(0, case[\"sigma_n\"], size=mu_true.shape)\n        F_obs = mu_true + noise\n\n        # Define potential energy and its gradient\n        F_obs_data, r_obs_data, sigma_n_sq = F_obs, case[\"r_i\"], case[\"sigma_n\"]**2\n        s_theta_sq = S_THETA**2\n        \n        def U_potential(theta):\n            W = np.exp(theta)\n            mu = mean_force_model(W, r_obs_data)\n            log_likelihood_term = np.sum((F_obs_data - mu)**2) / (2.0 * sigma_n_sq)\n            log_prior_term = (theta - M_THETA)**2 / (2.0 * s_theta_sq)\n            return log_likelihood_term + log_prior_term\n\n        def grad_U_potential(theta):\n            W = np.exp(theta)\n            mu = mean_force_model(W, r_obs_data)\n            d_mu_d_theta = JKR_CONST * W\n            \n            grad_log_likelihood = np.sum(mu - F_obs_data) * d_mu_d_theta / sigma_n_sq\n            grad_log_prior = (theta - M_THETA) / s_theta_sq\n            return grad_log_likelihood + grad_log_prior\n\n        # Run HMC\n        rng_hmc = np.random.default_rng(case[\"s_hmc\"])\n        theta_current = M_THETA\n        samples = []\n\n        for i in range(N_BURN + N_SAMPLES):\n            p_current = rng_hmc.normal(0, 1)\n            q_proposal, p_proposal = theta_current, p_current\n\n            # Leapfrog integration\n            p_proposal -= 0.5 * EPSILON * grad_U_potential(q_proposal)\n            for _ in range(L_STEPS - 1):\n                q_proposal += EPSILON * p_proposal\n                p_proposal -= EPSILON * grad_U_potential(q_proposal)\n            q_proposal += EPSILON * p_proposal\n            p_proposal -= 0.5 * EPSILON * grad_U_potential(q_proposal)\n            \n            p_proposal = -p_proposal\n\n            # Metropolis-Hastings acceptance step\n            H_current = U_potential(theta_current) + 0.5 * p_current**2\n            H_proposal = U_potential(q_proposal) + 0.5 * p_proposal**2\n            \n            alpha = min(1.0, np.exp(H_current - H_proposal))\n\n            if rng_hmc.random() < alpha:\n                theta_current = q_proposal\n\n            if i >= N_BURN:\n                samples.append(theta_current)\n        \n        theta_samples = np.array(samples)\n\n        # Posterior predictive mean\n        W_samples = np.exp(theta_samples)\n        case_predictive_means = []\n        for r_p in r_predict:\n            predictive_forces = mean_force_model(W_samples, r_p)\n            case_predictive_means.append(np.mean(predictive_forces))\n        \n        all_results.append(case_predictive_means)\n\n    print(str(all_results).replace(\" \", \"\"))\n\n\nsolve()\n```", "id": "2777678"}]}