{"hands_on_practices": [{"introduction": "理解复杂系统通常始于对其基本组成单元的建模。我们可以通过组合已知的势能函数来估算氢键的强度（即解离能）。本练习将指导您通过结合范德华相互作用和静电相互作用，为一个氢键构建一个简化的势能模型，并从中推导出其解离能。这个过程可以锻炼您将数学模型应用于物理现象的核心技能。[@problem_id:123489]", "problem": "一个简化的氢键（例如 N-H···O 键）一维模型，将相互作用势能描述为两个重原子（N和O）之间距离 $r$ 的函数。该势能 $U(r)$ 是一个范德华项和一个静电项之和。\n\n1.  范德华相互作用由标准的 Lennard-Jones (LJ) 势描述：\n    $$\n    U_{LJ}(r) = 4\\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right]\n    $$\n    此处，$\\epsilon$ 是 LJ 势阱的深度，$\\sigma$ 是 LJ 势为零时的距离。\n\n2.  氢键的定向、强静电特性通过以下有效吸引势进行建模：\n    $$\n    U_{elec}(r) = -\\frac{A}{r^6}\n    $$\n    其中 $A$ 是一个正常数，代表这种特定静电相互作用的强度。\n\nN-O 相互作用的总势能是这两项贡献之和：\n$$\nU(r) = U_{LJ}(r) + U_{elec}(r)\n$$\n\n解离能 $D_e$ 定义为将两个重原子从其平衡距离 $r_e$ 分离至无限远所需的能量。鉴于无限远分离时的势能为零，解离能等于平衡距离处势能的负值，即 $D_e = -U(r_e)$。\n\n计算此氢键模型的解离能 $D_e$。请用参数 $\\epsilon$、$\\sigma$ 和 $A$ 将您的答案表示为封闭形式的解析表达式。", "solution": "解离能由 $ D_e = -U(r_e) $ 给出，其中 $ r_e $ 是满足 $ \\frac{dU}{dr} \\big|_{r=r_e} = 0 $ 的平衡距离。总势能为：\n\n$$\nU(r) = 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right] - \\frac{A}{r^6}\n$$\n\n将 $ U(r) $ 用 $ r^{-6} $ 改写为：\n\n$$\nU(r) = 4\\epsilon \\sigma^{12} r^{-12} - 4\\epsilon \\sigma^6 r^{-6} - A r^{-6} = 4\\epsilon \\sigma^{12} (r^{-6})^2 - (4\\epsilon \\sigma^6 + A) r^{-6}\n$$\n\n设 $ x = r^{-6} $，则：\n\n$$\nU = 4\\epsilon \\sigma^{12} x^2 - (4\\epsilon \\sigma^6 + A) x\n$$\n\n关于 $ r $ 的导数为：\n\n$$\n\\frac{dU}{dr} = \\frac{dU}{dx} \\frac{dx}{dr} = \\left[ 8\\epsilon \\sigma^{12} x - (4\\epsilon \\sigma^6 + A) \\right] \\cdot (-6 r^{-7})\n$$\n\n在平衡时，$ \\frac{dU}{dr} = 0 $，这意味着：\n\n$$\n8\\epsilon \\sigma^{12} x_e - (4\\epsilon \\sigma^6 + A) = 0\n$$\n\n其中 $ x_e = r_e^{-6} $。求解 $ x_e $：\n\n$$\nx_e = \\frac{4\\epsilon \\sigma^6 + A}{8\\epsilon \\sigma^{12}}\n$$\n\n现在，计算 $ U(r_e) $：\n\n$$\nU(r_e) = 4\\epsilon \\sigma^{12} x_e^2 - (4\\epsilon \\sigma^6 + A) x_e\n$$\n\n代入 $ x_e $：\n\n$$\nU(r_e) = 4\\epsilon \\sigma^{12} \\left( \\frac{4\\epsilon \\sigma^6 + A}{8\\epsilon \\sigma^{12}} \\right)^2 - (4\\epsilon \\sigma^6 + A) \\left( \\frac{4\\epsilon \\sigma^6 + A}{8\\epsilon \\sigma^{12}} \\right)\n$$\n\n化简：\n\n$$\nU(r_e) = 4\\epsilon \\sigma^{12} \\cdot \\frac{(4\\epsilon \\sigma^6 + A)^2}{64 \\epsilon^2 \\sigma^{24}} - \\frac{(4\\epsilon \\sigma^6 + A)^2}{8\\epsilon \\sigma^{12}} = \\frac{(4\\epsilon \\sigma^6 + A)^2}{16\\epsilon \\sigma^{12}} - \\frac{(4\\epsilon \\sigma^6 + A)^2}{8\\epsilon \\sigma^{12}}\n$$\n\n\n$$\nU(r_e) = \\frac{(4\\epsilon \\sigma^6 + A)^2}{\\sigma^{12}} \\left( \\frac{1}{16\\epsilon} - \\frac{1}{8\\epsilon} \\right) = \\frac{(4\\epsilon \\sigma^6 + A)^2}{\\sigma^{12}} \\left( -\\frac{1}{16\\epsilon} \\right) = -\\frac{(4\\epsilon \\sigma^6 + A)^2}{16\\epsilon \\sigma^{12}}\n$$\n\n因此，解离能为：\n\n$$\nD_e = -U(r_e) = \\frac{(4\\epsilon \\sigma^6 + A)^2}{16\\epsilon \\sigma^{12}}\n$$\n\n展开分子：\n\n$$\n(4\\epsilon \\sigma^6 + A)^2 = 16\\epsilon^2 \\sigma^{12} + 8\\epsilon \\sigma^6 A + A^2\n$$\n\n所以：\n\n$$\nD_e = \\frac{16\\epsilon^2 \\sigma^{12} + 8\\epsilon \\sigma^6 A + A^2}{16\\epsilon \\sigma^{12}} = \\epsilon + \\frac{A}{2\\sigma^6} + \\frac{A^2}{16\\epsilon \\sigma^{12}}\n$$", "answer": "$$\n\\boxed{\\epsilon + \\frac{A}{2\\sigma^{6}} + \\frac{A^{2}}{16\\epsilon \\sigma^{12}}}\n$$", "id": "123489"}, {"introduction": "从经典的势能描述过渡到量子力学，我们可以揭示氢键更深层次的物理效应。氢键形成的一个关键实验特征是供体化学键（例如O-H键）伸缩振动频率的红移（即频率降低）。本练习将运用一级微扰理论来计算这一频率变化，从而在量子理论与光谱观测之间建立起一座具体的桥梁。通过这个练习，您可以亲手验证氢键的形成是如何削弱原有共价键的。[@problem_id:174548]", "problem": "一个孤立的 O-H 共价键的伸缩振动模式被建模为一个一维量子谐振子。该体系的约化质量为 $m$，经典角频率为 $\\omega_0$。这个未受扰动体系的势能为 $V_0(x) = \\frac{1}{2}m\\omega_0^2 x^2$，其中 $x$ 是键长与其平衡值之间的位移。\n\n当这个 O-H 基团参与形成一个线性氢键（例如 O-H···A，其中 A 是一个氢键受体）时，控制质子沿键轴运动的势能会发生改变。这个变化被建模为一个微扰 $V_{pert}(x)$，它被加到原始势能上。该微扰由下式给出：\n$$\nV_{pert}(x) = -\\frac{1}{2}\\delta k\\, x^2 + \\beta x^4\n$$\n此处，$\\delta k$ 和 $\\beta$ 是小的正常数。$-\\frac{1}{2}\\delta k\\, x^2$ 项代表 O-H 键的减弱（其力常数的减小），而 $\\beta x^4$ 项是一个正的非谐性修正，以确保势能在大位移时仍然是束缚的。\n\n使用一级不含时微扰理论，计算由该微扰引起的基频振动跃迁（即从基态 $n=0$ 到第一激发态 $n=1$ 的跃迁）角频率的变化量 $\\Delta\\omega$。", "solution": "未受扰动的哈密顿量为\n$$H_0=\\frac{p^2}{2m}+\\frac12m\\omega_0^2x^2\\,, $$\n其本征能量为\n$$E_n^{(0)}=\\hbar\\omega_0\\Bigl(n+\\tfrac12\\Bigr)\\,. $$\n\n微扰项为\n$$V_{\\rm pert}(x)=-\\tfrac12\\,\\delta k\\,x^2+\\beta\\,x^4\\,. $$\n\n根据一级微扰理论，能级 $n$ 的能量修正为\n$$\\Delta E_n=\\langle n|V_{\\rm pert}|n\\rangle\n=-\\tfrac12\\,\\delta k\\,\\langle n|x^2|n\\rangle\n+\\beta\\,\\langle n|x^4|n\\rangle\\,. $$\n\n我们使用标准谐振子的矩阵元：\n$$\\langle n|x^2|n\\rangle\n=\\frac{\\hbar}{2m\\omega_0}(2n+1)\\,, $$\n$$\\langle n|x^4|n\\rangle\n=\\Bigl(\\frac{\\hbar}{2m\\omega_0}\\Bigr)^2\\,(3+6n+6n^2)\\,. $$\n\n因此\n$$\\Delta E_0\n=-\\tfrac12\\,\\delta k\\,\\frac{\\hbar}{2m\\omega_0}\n+\\beta\\Bigl(\\frac{\\hbar}{2m\\omega_0}\\Bigr)^2\\,3, $$\n$$\\Delta E_1\n=-\\tfrac12\\,\\delta k\\,\\frac{3\\hbar}{2m\\omega_0}\n+\\beta\\Bigl(\\frac{\\hbar}{2m\\omega_0}\\Bigr)^2\\,15. $$\n\n跃迁能量 $E_1-E_0$ 的变化量为\n$$\\Delta(E_1-E_0)=\\Delta E_1-\\Delta E_0\n=-\\frac{\\hbar\\,\\delta k}{2m\\omega_0}\n+12\\,\\beta\\Bigl(\\frac{\\hbar}{2m\\omega_0}\\Bigr)^2\\,. $$\n\n最后，$0\\to1$ 跃迁的角频率变化量为\n$$\n\\Delta\\omega=\\frac{\\Delta(E_1-E_0)}{\\hbar}\n=-\\frac{\\delta k}{2m\\omega_0}\n+12\\,\\beta\\,\\frac{1}{\\hbar}\\Bigl(\\frac{\\hbar}{2m\\omega_0}\\Bigr)^2\n=-\\frac{\\delta k}{2m\\omega_0}\n+\\frac{3\\beta\\hbar}{m^2\\omega_0^2}\\,. $$", "answer": "$$\\boxed{-\\frac{\\delta k}{2m\\omega_0}+\\frac{3\\beta\\hbar}{m^2\\omega_0^2}}$$", "id": "174548"}, {"introduction": "在掌握了单个氢键的静态模型后，我们进一步探索其在多体系统（如液固界面）中的动态行为。在这些真实且复杂的环境中，氢键在不断地形成和断裂。本练习将引入时间相关函数——统计力学中的一个核心工具，指导您通过分析模拟轨迹数据来计算氢键的平均寿命。这项实践将为您提供现代计算表面科学研究中处理和分析数据的直接经验。[@problem_id:2773802]", "problem": "给定一个液固界面上氢键（HB）存在的离散时间表示。对于一个由 $\\alpha$ 索引的供体-受体对系综，定义二元指示函数 $h_{\\alpha}(t)$：如果 $\\alpha$ 对之间的特定氢键在时间 $t$ 存在，则其值为 $1$，否则为 $0$。考虑一个持续时间为 $N$ 个时间步长的均匀采样轨迹，采样周期为 $\\Delta t$，因此 $t_n = n\\,\\Delta t$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。下面提供的所有数组都已筛选，仅包含界面氢键。\n\n仅使用以下基本原理：\n- 将双时相关性定义为在初始状态条件下对系综进行的平均。\n- 使用间距为 $\\Delta t$ 的离散和对时间积分进行黎曼和近似。\n\n为延迟指数 $k \\in \\{0,1,\\dots,N-1\\}$，将间歇性和连续性氢键时间相关函数定义为对所有有效时间起点和对的条件期望：\n- 间歇性相关函数 $C_{\\mathrm{i}}(k\\,\\Delta t)$ 是在时间 $t_n$ 存在氢键的条件下，在时间 $t_{n+k}$ 氢键仍然存在的条件概率，该概率在所有对和所有满足 $n+k \\le N-1$ 的有效时间起点 $n$ 上取平均。形式上，\n$$\nC_{\\mathrm{i}}(k\\,\\Delta t) \\equiv \\left\\langle \\frac{h_{\\alpha}(t_{n+k})}{1} \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}.\n$$\n- 连续性存活相关函数 $C_{\\mathrm{c}}(k\\,\\Delta t)$ 是在时间 $t_n$ 存在氢键的条件下，该氢键在整个区间 $[t_n, t_{n+k}]$ 内保持未断裂的条件概率，该概率在所有对和所有有效时间起点上取平均。使用乘积来确保键合不中断，\n$$\nC_{\\mathrm{c}}(k\\,\\Delta t) \\equiv \\left\\langle \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s}) \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}.\n$$\n如果对于给定的 $k$ 没有有效的时间起点（即，不存在满足 $h_{\\alpha}(t_n)=1$ 和 $n+k \\le N-1$ 的 $\\alpha,n$），则定义 $C_{\\mathrm{i}}(k\\,\\Delta t)=0$ 和 $C_{\\mathrm{c}}(k\\,\\Delta t)=0$。\n\n将平均氢键寿命定义为相关函数的时间积分，\n$$\n\\tau \\equiv \\int_{0}^{\\infty} C(t)\\,dt,\n$$\n并从离散轨迹中，通过黎曼和来估计它，\n$$\n\\tau \\approx \\sum_{k=0}^{N-1} C(k\\,\\Delta t)\\,\\Delta t,\n$$\n分别对间歇性和连续性定义进行计算。\n\n实现一个程序，对每个提供的测试用例，使用上述定义计算间歇性和连续性寿命。所有最终寿命以皮秒（ps）为单位表示，并四舍五入到小数点后六位。\n\n输入作为一组测试用例直接嵌入在程序中。每个测试用例指定了 $\\Delta t$（单位为ps）和一个氢键指示序列列表，每个序列对应一个对，长度为 $N$。请严格使用以下测试套件：\n\n- 测试用例 A（正常路径，间歇性重键合）：\n  - $\\Delta t = 0.5\\,\\mathrm{ps}$\n  - 对数 $M=2$\n  - 轨迹：\n    - 对 1：$\\{1,1,0,1,1,0\\}$\n    - 对 2：$\\{0,1,0,1,0,1\\}$\n- 测试用例 B（边界情况，始终键合）：\n  - $\\Delta t = 0.2\\,\\mathrm{ps}$\n  - 对数 $M=2$\n  - 轨迹：\n    - 对 1：$\\{1,1,1,1,1\\}$\n    - 对 2：$\\{1,1,1,1,1\\}$\n- 测试用例 C（边界情况，从未键合）：\n  - $\\Delta t = 0.5\\,\\mathrm{ps}$\n  - 对数 $M=3$\n  - 轨迹：\n    - 对 1：$\\{0,0,0,0\\}$\n    - 对 2：$\\{0,0,0,0\\}$\n    - 对 3：$\\{0,0,0,0\\}$\n- 测试用例 D（边缘情况，立即断裂且不重键合）：\n  - $\\Delta t = 1.0\\,\\mathrm{ps}$\n  - 对数 $M=1$\n  - 轨迹：\n    - 对 1：$\\{1,0,0,0\\}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其值按以下顺序排列：\n- 对于每个测试用例，按 A、B、C、D 的顺序，先追加连续性寿命 $\\tau_{\\mathrm{c}}$，然后追加间歇性寿命 $\\tau_{\\mathrm{i}}$，两者均以 ps 为单位，并四舍五入到小数点后六位。\n- 因此，输出具有扁平结构 $[\\tau_{\\mathrm{c}}^{\\mathrm{A}},\\tau_{\\mathrm{i}}^{\\mathrm{A}},\\tau_{\\mathrm{c}}^{\\mathrm{B}},\\tau_{\\mathrm{i}}^{\\mathrm{B}},\\tau_{\\mathrm{c}}^{\\mathrm{C}},\\tau_{\\mathrm{i}}^{\\mathrm{C}},\\tau_{\\mathrm{c}}^{\\mathrm{D}},\\tau_{\\mathrm{i}}^{\\mathrm{D}}]$，不含空格。", "solution": "问题陈述已经过仔细审查，并被确认为是有效的。它提出了一个来自物理化学领域，关于氢键统计力学的定义明确、有科学依据的任务。所提供的间歇性和连续性相关函数的定义，以及通过黎曼和计算寿命的方法，都是标准的且在数学上无歧义的。测试用例所需的所有参数和数据均已提供，使得该问题是自洽且可解的。\n\n我们继续从所提供的第一性原理推导计算算法。问题定义了两种关于氢键（HB）存在性的时间相关函数：$C_{\\mathrm{i}}(t)$ 和 $C_{\\mathrm{c}}(t)$。它们被定义为对由 $\\alpha$ 索引的供体-受体对系综和离散时间起点 $t_n=n\\Delta t$ 的条件期望。\n\n二元指示函数 $h_{\\alpha}(t_n)$ 的值是：如果对 $\\alpha$ 的氢键在时间 $t_n$ 存在，则为 $1$，否则为 $0$。每个对 $\\alpha$ 的轨迹是一个长度为 $N$ 的序列 $\\{h_{\\alpha}(t_n)\\}_{n=0}^{N-1}$。\n\n对于延迟时间 $k\\Delta t$，间歇性相关函数由下式给出：\n$$\nC_{\\mathrm{i}}(k\\,\\Delta t) = \\left\\langle h_{\\alpha}(t_{n+k}) \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}\n$$\n连续性相关函数为：\n$$\nC_{\\mathrm{c}}(k\\,\\Delta t) = \\left\\langle \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s}) \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}\n$$\n\n符号 $\\langle \\cdot \\rangle_{\\alpha,n}$ 表示对所有对 $\\alpha$ 和所有有效时间起点 $n$ 进行平均。对于一个延迟指数 $k$，如果 $n+k \\leq N-1$，则时间起点 $t_n$ 是有效的。条件期望 $\\langle X | A \\rangle$ 的计算方法是：将条件 $A$ 为真的所有事件的结果 $X$ 相加，然后除以此类事件的总数。\n\n将此应用于我们的离散系统，对于给定的延迟指数 $k \\in \\{0, 1, \\dots, N-1\\}$，我们必须对所有对 $\\alpha \\in \\{1, \\dots, M\\}$ 和所有时间起点 $n \\in \\{0, 1, \\dots, N-1-k\\}$ 进行求和。\n\n两个相关函数的分母是在有效时间起点存在氢键的实例总数，它作为归一化因子。这可以表示为：\n$$\n\\text{Denominator}(k) = \\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_n)\n$$\n如果对于给定的 $k$，此分母为零，则相关函数定义为零。\n\n对于间歇性相关函数 $C_{\\mathrm{i}}$，其分子是在 $t_n$ 存在氢键的条件下，在延迟时间 $t_{n+k}$ 的氢键存在指示符之和。这等价于对乘积 $h_{\\alpha}(t_{n+k}) h_{\\alpha}(t_n)$ 求和：\n$$\n\\text{Numerator}_{\\mathrm{i}}(k) = \\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_{n+k}) h_{\\alpha}(t_n)\n$$\n\n对于连续性相关函数 $C_{\\mathrm{c}}$，其分子要求氢键在整个区间 $[t_n, t_{n+k}]$ 内持续未断裂。这通过对区间内指示函数的乘积来体现：\n$$\n\\text{Numerator}_{\\mathrm{c}}(k) = \\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} \\left( \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s}) \\right)\n$$\n请注意，该乘积项隐含地包括了条件 $h_{\\alpha}(t_n)=1$，因为只要有任何一项为零，整个乘积就为零。\n\n因此，相关函数的完整表达式为：\n$$\nC_{\\mathrm{i}}(k\\Delta t) = \\frac{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_{n+k}) h_{\\alpha}(t_n)}{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_n)}\n$$\n$$\nC_{\\mathrm{c}}(k\\Delta t) = \\frac{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s})}{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_n)}\n$$\n\n最后，平均氢键寿命 $\\tau$ 是通过对所有计算出的延迟时间上的相应相关函数进行黎曼和来估计的：\n$$\n\\tau \\approx \\sum_{k=0}^{N-1} C(k\\,\\Delta t)\\,\\Delta t\n$$\n这将分别使用 $C_{\\mathrm{i}}$ 和 $C_{\\mathrm{c}}$ 来计算 $\\tau_{\\mathrm{i}}$ 和 $\\tau_{\\mathrm{c}}$。\n\n实现将包含一个函数，该函数以轨迹和时间步长 $\\Delta t$ 作为输入。轨迹表示为一个 $M \\times N$ 矩阵。该函数将循环遍历从 $0$ 到 $N-1$ 的每个延迟指数 $k$。对于每个 $k$，它将通过迭代所有对 $\\alpha$ 和所有有效时间起点 $n$ 来计算分子和分母。在计算出数组 $C_{\\mathrm{i}}(k\\Delta t)$ 和 $C_{\\mathrm{c}}(k\\Delta t)$ 后，它将执行最终的求和并乘以 $\\Delta t$，以获得寿命 $\\tau_{\\mathrm{i}}$ 和 $\\tau_{\\mathrm{c}}$。然后，每个测试用例的结果将按指定格式进行格式化。", "answer": "```python\nimport numpy as np\n\ndef calculate_lifetimes(trajectories: list[list[int]], delta_t: float) -> tuple[float, float]:\n    \"\"\"\n    Computes the continuous and intermittent HB lifetimes from trajectory data.\n\n    Args:\n        trajectories: A list of lists, where each inner list is a binary\n                      indicator sequence h_alpha(t) for a donor-acceptor pair.\n        delta_t: The time step between trajectory frames, in picoseconds.\n\n    Returns:\n        A tuple containing (tau_c, tau_i), the continuous and intermittent\n        lifetimes in picoseconds.\n    \"\"\"\n    if not trajectories or not trajectories[0]:\n        return 0.0, 0.0\n\n    h = np.array(trajectories, dtype=np.int8)\n    num_pairs, num_steps = h.shape\n\n    C_intermittent = np.zeros(num_steps, dtype=np.float64)\n    C_continuous = np.zeros(num_steps, dtype=np.float64)\n\n    for k in range(num_steps):\n        numerator_i = 0\n        numerator_c = 0\n        denominator = 0\n        \n        # The maximum valid time origin index 'n' for a given lag 'k'\n        max_n = num_steps - 1 - k\n        if max_n < 0:\n            continue\n\n        for alpha in range(num_pairs):\n            for n in range(max_n + 1):\n                # Condition: HB exists at the time origin t_n\n                if h[alpha, n] == 1:\n                    denominator += 1\n                    \n                    # Intermittent case: check for HB existence at t_{n+k}\n                    if h[alpha, n + k] == 1:\n                        numerator_i += 1\n                        \n                    # Continuous case: check for uninterrupted HB from t_n to t_{n+k}\n                    # The product is 1 if and only if all elements are 1.\n                    if np.all(h[alpha, n : n + k + 1] == 1):\n                        numerator_c += 1\n                        \n        if denominator > 0:\n            C_intermittent[k] = numerator_i / denominator\n            C_continuous[k] = numerator_c / denominator\n        # If denominator is 0, correlation is defined as 0. Arrays are pre-filled with 0.\n\n    # Calculate lifetimes using Riemann sum approximation\n    tau_i = np.sum(C_intermittent) * delta_t\n    tau_c = np.sum(C_continuous) * delta_t\n    \n    return tau_c, tau_i\n\ndef solve():\n    \"\"\"\n    Runs the predefined test suite and prints the results in the specified format.\n    \"\"\"\n    test_cases = {\n        'A': {\n            'delta_t': 0.5,\n            'trajectories': [\n                [1, 1, 0, 1, 1, 0],\n                [0, 1, 0, 1, 0, 1]\n            ]\n        },\n        'B': {\n            'delta_t': 0.2,\n            'trajectories': [\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1]\n            ]\n        },\n        'C': {\n            'delta_t': 0.5,\n            'trajectories': [\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ]\n        },\n        'D': {\n            'delta_t': 1.0,\n            'trajectories': [\n                [1, 0, 0, 0]\n            ]\n        }\n    }\n\n    results = []\n    case_order = ['A', 'B', 'C', 'D']\n\n    for case_id in case_order:\n        case = test_cases[case_id]\n        tau_c, tau_i = calculate_lifetimes(case['trajectories'], case['delta_t'])\n        \n        # Append results formatted to six decimal places\n        results.append(f\"{tau_c:.6f}\")\n        results.append(f\"{tau_i:.6f}\")\n        \n    # Print the final output in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2773802"}]}