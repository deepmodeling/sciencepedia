{"hands_on_practices": [{"introduction": "在我们深入探讨处理复杂几何体的视角因子代数之前，回归其最基本的物理和数学定义是至关重要的。本练习将引导我们从视角因子的双重面积分定义出发，分析一个看似复杂但具有高度对称性的球形空腔。通过这个过程，我们将发现一个关于球形闭曲面内部辐射传递的深刻而优美的性质，这不仅能锻炼我们从第一性原理推导问题的能力，也为理解更高级的代数方法奠定了坚实的基础。[@problem_id:2537088]", "problem": "一个半径为 $R$ 的中空球形腔体被抽成真空。其内壁是一个完美的漫-灰表面。壁面被划分为三个不相交的区域，由围绕一个固定轴的球面极角定义：一个由 $0 \\le \\theta \\le \\alpha$ 定义的北极冠 $\\mathcal{N}$，一个由 $\\pi - \\alpha \\le \\theta \\le \\pi$ 定义的南极冠 $\\mathcal{S}$，以及由 $\\alpha < \\theta < \\pi - \\alpha$ 定义的剩余赤道带 $\\mathcal{E}$。该封闭体中没有其他表面。假设所有辐射都是漫反射，并遵循兰伯特余弦定律。设 $\\alpha \\in (0,\\pi/2)$ 以弧度为单位。\n\n从漫射表面的辐射角系数（视场因子）的基本定义出发，并且不使用任何预先制表的角系数公式，确定从北极冠到南极冠的角系数 $F_{\\mathcal{N}\\to\\mathcal{S}}$，并用 $\\alpha$ 将最终结果表示为单一的闭式解析表达式。不需要进行数值计算，也不需要四舍五入。角度应以弧度解释。", "solution": "问题陈述已经过评估，并被确定为有效。这是一个辐射传热中定义明确的问题，基于已有的物理原理和数学定义，没有不一致或模糊之处。我们可以开始求解。\n\n该问题要求确定两个不相交表面——北极冠 $\\mathcal{N}$ 和南极冠 $\\mathcal{S}$ ——之间的角系数 $F_{\\mathcal{N}\\to\\mathcal{S}}$，这两个表面是空心球内表面的一部分。计算必须从漫射表面的角系数的基本定义出发，不能使用预先制表的公式。\n\n从表面 $A_1$ 到表面 $A_2$ 的角系数由以下双重面积分定义：\n$$F_{1\\to 2} = \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos\\beta_1 \\cos\\beta_2}{\\pi L^2} dA_2 dA_1$$\n其中 $dA_1$ 和 $dA_2$ 分别是表面 $A_1$ 和 $A_2$ 上的微元面积，$L$ 是连接 $dA_1$ 和 $dA_2$ 的直线段长度，$\\beta_1$ 和 $\\beta_2$ 是该直线段与微元面积 $dA_1$ 和 $dA_2$ 的法线之间的夹角。\n\n我们首先分析对于半径为 $R$ 的球体内表面上的任意两点，其几何核 $\\frac{\\cos\\beta_1 \\cos\\beta_2}{\\pi L^2}$。设坐标系的原点为球心。设 $dA_1$ 和 $dA_2$ 的位置向量分别为 $\\vec{r}_1$ 和 $\\vec{r}_2$，其中 $|\\vec{r}_1| = |\\vec{r}_2| = R$。在这些点上，内表面的法线指向球心，因此 $\\hat{n}_1 = -\\vec{r}_1/R$ 且 $\\hat{n}_2 = -\\vec{r}_2/R$。\n\n连接 $dA_1$ 到 $dA_2$ 的向量为 $\\vec{L} = \\vec{r}_2 - \\vec{r}_1$。其模长的平方为：\n$$L^2 = |\\vec{r}_2 - \\vec{r}_1|^2 = (\\vec{r}_2 - \\vec{r}_1) \\cdot (\\vec{r}_2 - \\vec{r}_1) = |\\vec{r}_2|^2 + |\\vec{r}_1|^2 - 2 \\vec{r}_1 \\cdot \\vec{r}_2$$\n设 $\\gamma$ 是位置向量 $\\vec{r}_1$ 和 $\\vec{r}_2$ 之间的夹角。则 $\\vec{r}_1 \\cdot \\vec{r}_2 = |\\vec{r}_1||\\vec{r}_2|\\cos\\gamma = R^2\\cos\\gamma$。\n$$L^2 = R^2 + R^2 - 2R^2\\cos\\gamma = 2R^2(1-\\cos\\gamma)$$\n使用半角恒等式 $1-\\cos\\gamma = 2\\sin^2(\\gamma/2)$，我们得到 $L^2 = 4R^2\\sin^2(\\gamma/2)$。\n\n角度 $\\beta_1$ 是法线 $\\hat{n}_1$ 和直线 $\\vec{L}$ 之间的夹角。\n$$\\cos\\beta_1 = \\hat{n}_1 \\cdot \\frac{\\vec{L}}{L} = \\left(-\\frac{\\vec{r}_1}{R}\\right) \\cdot \\left(\\frac{\\vec{r}_2 - \\vec{r}_1}{L}\\right) = \\frac{-\\vec{r}_1 \\cdot \\vec{r}_2 + \\vec{r}_1 \\cdot \\vec{r}_1}{RL} = \\frac{-R^2\\cos\\gamma + R^2}{RL} = \\frac{R(1-\\cos\\gamma)}{L}$$\n代入 $L = 2R\\sin(\\gamma/2)$ 和 $1-\\cos\\gamma = 2\\sin^2(\\gamma/2)$：\n$$\\cos\\beta_1 = \\frac{R(2\\sin^2(\\gamma/2))}{2R\\sin(\\gamma/2)} = \\sin(\\gamma/2)$$\n角度 $\\beta_2$ 是法线 $\\hat{n}_2$ 和直线 $-\\vec{L}$（从 $dA_2$ 指向 $dA_1$）之间的夹角。\n$$\\cos\\beta_2 = \\hat{n}_2 \\cdot \\frac{-\\vec{L}}{L} = \\left(-\\frac{\\vec{r}_2}{R}\\right) \\cdot \\left(\\frac{\\vec{r}_1 - \\vec{r}_2}{L}\\right) = \\frac{-\\vec{r}_2 \\cdot \\vec{r}_1 + \\vec{r}_2 \\cdot \\vec{r}_2}{RL} = \\frac{-R^2\\cos\\gamma + R^2}{RL} = \\sin(\\gamma/2)$$\n球体的一个关键几何特性是，连接表面上任意两点的弦与通往这两点的半径所成的角度相等。由于法线与半径共线，因此角度 $\\beta_1$ 和 $\\beta_2$ 相等。\n\n现在我们将这些表达式代回核中：\n$$\\frac{\\cos\\beta_1 \\cos\\beta_2}{\\pi L^2} = \\frac{\\sin(\\gamma/2) \\sin(\\gamma/2)}{\\pi (4R^2\\sin^2(\\gamma/2))} = \\frac{\\sin^2(\\gamma/2)}{4\\pi R^2\\sin^2(\\gamma/2)} = \\frac{1}{4\\pi R^2}$$\n这是一个非凡的结果：对于球形封闭体，角系数积分的核是一个常数，与 $dA_1$ 和 $dA_2$ 的位置无关。球体的总表面积为 $A_{total} = 4\\pi R^2$。核就是 $1/A_{total}$。\n\n现在我们来计算角系数 $F_{\\mathcal{N}\\to\\mathcal{S}}$。设表面 1 为北极冠 $\\mathcal{N}$，表面 2 为南极冠 $\\mathcal{S}$。\n$$F_{\\mathcal{N}\\to\\mathcal{S}} = \\frac{1}{A_{\\mathcal{N}}} \\int_{A_{\\mathcal{N}}} \\int_{A_{\\mathcal{S}}} \\frac{1}{4\\pi R^2} dA_{\\mathcal{S}} dA_{\\mathcal{N}}$$\n由于被积函数是常数，积分变得非常简单：\n$$F_{\\mathcal{N}\\to\\mathcal{S}} = \\frac{1}{A_{\\mathcal{N}}(4\\pi R^2)} \\left(\\int_{A_{\\mathcal{N}}} dA_{\\mathcal{N}}\\right) \\left(\\int_{A_{\\mathcal{S}}} dA_{\\mathcal{S}}\\right) = \\frac{1}{A_{\\mathcal{N}}(4\\pi R^2)} (A_{\\mathcal{N}})(A_{\\mathcal{S}}) = \\frac{A_{\\mathcal{S}}}{4\\pi R^2}$$\n因此，从球体内表面上的任意一个表面到另一个不相交的表面的角系数，就是接收表面的面积与球体总面积之比。\n\n下一步是计算南极冠的面积 $A_{\\mathcal{S}}$。表面 $\\mathcal{S}$ 由球面极角范围 $\\pi - \\alpha \\le \\theta \\le \\pi$ 定义。球坐标系中的微元面积为 $dA = R^2 \\sin\\theta \\,d\\theta\\,d\\phi$。\n$$A_{\\mathcal{S}} = \\int_{0}^{2\\pi} \\int_{\\pi-\\alpha}^{\\pi} R^2 \\sin\\theta \\,d\\theta\\,d\\phi = 2\\pi R^2 \\int_{\\pi-\\alpha}^{\\pi} \\sin\\theta \\,d\\theta$$\n$$A_{\\mathcal{S}} = 2\\pi R^2 [-\\cos\\theta]_{\\pi-\\alpha}^{\\pi} = 2\\pi R^2 [-\\cos(\\pi) - (-\\cos(\\pi-\\alpha))]$$\n因为 $\\cos(\\pi) = -1$ 且 $\\cos(\\pi-\\alpha) = -\\cos\\alpha$，我们有：\n$$A_{\\mathcal{S}} = 2\\pi R^2 [-(-1) - (-(-\\cos\\alpha))] = 2\\pi R^2 (1 - \\cos\\alpha)$$\n\n最后，我们将这个面积代入角系数的表达式中：\n$$F_{\\mathcal{N}\\to\\mathcal{S}} = \\frac{A_{\\mathcal{S}}}{4\\pi R^2} = \\frac{2\\pi R^2 (1 - \\cos\\alpha)}{4\\pi R^2} = \\frac{1 - \\cos\\alpha}{2}$$\n为了提供最紧凑的闭式表达式，我们使用三角半角恒等式 $1 - \\cos\\alpha = 2\\sin^2(\\alpha/2)$。\n$$F_{\\mathcal{N}\\to\\mathcal{S}} = \\frac{2\\sin^2(\\alpha/2)}{2} = \\sin^2(\\frac{\\alpha}{2})$$\n这就是从北极冠到南极冠的角系数的最终解析表达式。", "answer": "$$\n\\boxed{\\sin^2\\left(\\frac{\\alpha}{2}\\right)}\n$$", "id": "2537088"}, {"introduction": "直接积分计算视角因子在面对复杂几何形状时往往变得异常繁琐甚至不可行。此时，视角因子代数，包括求和法则、对称性法则和互易法则，便显示出其强大的威力。这个练习提供了一个绝佳的例子：一个圆柱体和一无限大平面。通过巧妙地构想一个虚拟的闭合曲面（闭曲面增强法）并应用对称性，我们可以绕开复杂的积分，以纯粹的代数和逻辑推理得到答案。这个过程深刻地揭示了如何通过抽象思维将难题化繁为简。[@problem_id:2537099]", "problem": "一个半径为 $R$、长度为 $L$ 的正圆柱体，其轴线与一个无限延伸的漫灰等温平面平行，中心线到该平面的距离为 $h$。除此以外，周围环境为空（无其他表面）。所有表面均为漫灰、不透明的，且介质不参与辐射。圆柱体的圆形边缘薄到可以忽略不计；只考虑圆柱的侧表面。请仅使用漫射角（视）系数的基本定义、封闭体求和法则、相互关系以及不依赖于表格公式的对称性论证，确定从整个圆柱侧表面到无限平面的角系数 $F_{c \\to p}$。你的推导必须从角系数的第一性原理出发，并且必须为你所使用的任何封闭体增补或对称性操作提供合理解释。最终答案必须表示为一个实数。不需要四舍五入。角系数是无量纲的；不要报告任何单位。", "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **几何体1**：一个正圆柱体，记为表面'c'，半径为 $R$，长度为 $L$。只考虑其侧表面积 $A_c = 2\\pi R L$。\n- **几何体2**：一个无限延伸的平面，记为表面'p'。\n- **布局**：圆柱体的轴线与平面'p'平行。圆柱体轴线与平面之间的距离为 $h$。\n- **表面特性**：所有表面均为漫灰、不透明的。介质不参与辐射。\n- **周围环境**：空间在其他方面是空的，这意味着未射向'p'的辐射会逃逸到一个零温度的热沉。\n- **目标**：确定从圆柱侧表面到无限平面的角系数 $F_{c \\to p}$。\n- **方法论约束**：推导过程只能使用角系数的基本定义、封闭体求和法则、相互关系和对称性论证。禁止使用表格公式。任何几何增补或对称性操作都必须给出合理解释。\n- **答案格式**：最终答案必须是一个实数。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，涉及辐射传热的标准原理。问题提法得当，因为几何形状和目标都已明确定义。尽管存在符号参数（$R, L, h$），但要求给出单一数值答案，这表明解将与这些具体尺寸无关，这是涉及无限大表面和对称性问题中的常见结果。对推导方法的约束是明确的，指导求解策略走向概念性证明而非直接积分。该问题没有矛盾、歧义和事实错误。\n\n**结论与行动**\n该问题被判定为**有效**。将按照规定的方法论提供解答。\n\n**角系数 $F_{c \\to p}$ 的推导**\n\n角系数，或称视界因子，$F_{i \\to j}$ 定义为离开漫射表面 $A_i$ 的辐射中直接到达表面 $A_j$ 的那部分比例。我们需要求的是 $F_{c \\to p}$。\n\n给定的系统由圆柱体'c'和无限大平面'p'组成，它们不构成一个封闭体。离开圆柱体但未射向平面的辐射会逃逸到空无一物的周围环境中。为了使用角系数代数的强大工具，特别是求和法则来解决这个问题，我们必须首先构造一个真正的封闭体。\n\n这可以通过**封闭体增补**方法来完成。我们引入一个虚构的表面，以完成围绕圆柱体'c'的封闭体。\n设无限大平面'p'为表面 $A_1$。我们建立一个坐标系，其中平面 $A_1$ 是 $z=0$ 平面。圆柱体'c'的轴线平行于 $xy$ 平面，并位于恒定高度 $z=h$ 处。\n\n现在我们引入第二个虚构的无限大平面，记为表面 $A_2$，位于 $z=2h$ 处。该平面与 $A_1$ 平行。这个构造创建了一个由两个无限大平行平面 $A_1$ 和 $A_2$ 形成的封闭体，圆柱体'c'正好位于正中间。任何离开圆柱体'c'表面的辐射现在必须被平面 $A_1$ 或平面 $A_2$ 拦截，因为没有其他逃逸路径。\n\n对于封闭体内的任何表面'c'，角系数的**求和法则**指出，从'c'到封闭体所有表面（包括其自身）的角系数之和必须等于1。将此规则应用于我们增补的系统：\n$$F_{c \\to 1} + F_{c \\to 2} + F_{c \\to c} = 1$$\n其中 $F_{c \\to 1}$ 是从圆柱体到平面 $A_1$ 的角系数（即我们所求的量 $F_{c \\to p}$），而 $F_{c \\to 2}$ 是从圆柱体到虚构平面 $A_2$ 的角系数。\n\n圆柱体的侧表面是一个**凸面**。凸面无法“看到”其自身的任何部分。因此，圆柱体对自身的角系数为零：\n$$F_{c \\to c} = 0$$\n将此结果代入求和法则，方程简化为：\n$$F_{c \\to 1} + F_{c \\to 2} = 1$$\n\n接下来，我们应用**对称性论证**，这是问题陈述所允许的。该封闭体由两个相同的无限大平面 $A_1$ 和 $A_2$ 组成。圆柱体'c'的轴线正好位于它们之间的正中间。圆柱体轴线到平面 $A_1$ 的距离为 $h$，同样，其轴线到平面 $A_2$ 的距离为 $|2h - h| = h$。由于这种几何对称性，圆柱体对平面 $A_1$ 的“视角”与其对平面 $A_2$ 的“视角”是相同的。对于圆柱体表面上的任何面积微元，其相对于平面 $A_1$ 的位置和方向与其相对于平面 $A_2$ 的位置和方向呈镜像关系。因此，从整个圆柱体表面'c'辐射的能量中，到达平面 $A_1$ 的部分必须等于到达平面 $A_2$ 的部分。因此我们可以陈述：\n$$F_{c \\to 1} = F_{c \\to 2}$$\n只要圆柱体是对称放置的，这个结论就与圆柱体的具体尺寸（$R, L$）及其与平面的距离（$h$）无关。\n\n现在我们将对称性论证的结果代回到简化的求和法则中：\n$$F_{c \\to 1} + F_{c \\to 1} = 1$$\n$$2 F_{c \\to 1} = 1$$\n解出 $F_{c \\to 1}$ 得：\n$$F_{c \\to 1} = \\frac{1}{2}$$\n\n由于 $F_{c \\to 1}$ 是从圆柱体到原始无限大平面'p'的角系数，我们已经求得了所需量：\n$$F_{c \\to p} = \\frac{1}{2}$$\n这个结果是一个常数，与圆柱体的半径、长度以及与平面的距离无关，这与问题要求提供单一数值答案的要求相符。该推导完全依赖于求和法则以及应用于增补封闭体的合理解释的对称性论证，因此遵守了所有方法论上的约束。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "2537099"}, {"introduction": "虽然解析方法和简单的代数技巧在许多理想化场景中非常有效，但现实世界中的工程问题常常涉及无法用简单函数描述的任意复杂几何体。在这种情况下，数值方法成为不可或缺的工具。本练习旨在引导您从零开始，基于高斯求积法实现一个计算三维空间中平面多边形之间视角因子的数值算法。这不仅是解决真实辐射传热问题的核心技能，也让您能够亲手验证视角因子代数（如互易性和叠加性）在数值解中的体现，从而加深对理论的理解。[@problem_id:2537093]", "problem": "你的任务是设计并实现一个数值算法，用于计算三维空间中平面平行四边形之间的漫射几何角系数，并使用高斯求积法验证其代数关系和收敛性。该问题必须从角系数的积分定义和基本几何关系等第一性原理出发来解决。你必须为一组固定的测试集输出具体的数值结果。\n\n基本原理：\n- 对于两个视线无遮挡的漫射、灰体表面 $A_1$ 和 $A_2$ ，它们之间的角系数 $F_{1 \\to 2}$ 定义为\n$$\nF_{1 \\to 2} = \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos\\theta_1 \\, \\cos\\theta_2}{\\pi \\, R^2} \\, \\mathrm{d}A_2 \\, \\mathrm{d}A_1,\n$$\n其中 $\\theta_1$ 是 $A_1$ 上一点的外法线单位向量与到 $A_2$ 上一点的视线之间的夹角，$\\theta_2$ 是 $A_2$ 上一点的外法线单位向量与到 $A_1$ 上一点的视线之间的夹角，而 $R$ 是这两点之间的距离。该积分使用的可见因子为 $1$（无遮挡），以及基本辐射角系数被积函数 $\\left(\\cos\\theta_1 \\cos\\theta_2\\right)/\\left(\\pi R^2\\right)$。\n\n- 互易性：$A_1 F_{1 \\to 2} = A_2 F_{2 \\to 1}$。\n\n- 可加性（分割）：如果 $A_1$ 被分割成不相交的子区域 $A_{1k}$，则 $F_{1 \\to 2} = \\sum_k \\left(\\frac{A_{1k}}{A_1}\\right) F_{1k \\to 2}$。\n\n平面表面的几何模型：\n- 一个平面平行四边形表面 $S$ 由一个原点 $\\mathbf{o} \\in \\mathbb{R}^3$ 和两个张成向量 $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{R}^3$（单位为米）表示，其参数化形式为\n$$\n\\mathbf{r}(u,v) = \\mathbf{o} + u \\, \\mathbf{a} + v \\, \\mathbf{b}, \\quad u \\in [0,1], \\; v \\in [0,1].\n$$\n- 面积为 $A = \\|\\mathbf{a} \\times \\mathbf{b}\\|$。外法线单位向量为 $\\mathbf{n} = s \\, \\frac{\\mathbf{a} \\times \\mathbf{b}}{\\|\\mathbf{a} \\times \\mathbf{b}\\|}$，其中 $s \\in \\{+1,-1\\}$ 用于选择表面的发射侧（外法线符号）。所有长度单位均为米。角系数为无量纲。\n\n数值求积要求：\n- 使用在 $[0,1]$ 区间上每个参数的 $n$ 阶张量积 Gauss–Legendre 求积法来近似该二重积分。如果 $\\{x_i, w_i\\}_{i=1}^n$ 是在 $[-1,1]$ 上的标准 Gauss–Legendre 节点和权重，通过 $u_i = \\frac{x_i+1}{2}$ 映射到 $[0,1]$，权重为 $\\tilde{w}_i = \\frac{w_i}{2}$。对每个表面的 $(u,v)$ 使用张量积，然后在两个表面之间使用张量积，以近似\n$$\n\\iint_{A_1} \\iint_{A_2} \\cdot \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1 \\approx \\sum_{i,j=1}^n \\sum_{p,q=1}^n \\left(\\tilde{w}_i \\tilde{w}_j A_1\\right) \\left(\\tilde{w}_p \\tilde{w}_q A_2\\right) \\, \\frac{\\cos\\theta_1 \\cos\\theta_2}{\\pi R^2}.\n$$\n- 对于任何满足 $\\cos\\theta_1 \\le 0$ 或 $\\cos\\theta_2 \\le 0$ 的求积点对，其贡献必须为 $0$（背面之间没有相互辐射交换）。\n\n待实现的算法任务：\n1. 实现一个例程，根据 $(\\mathbf{o}, \\mathbf{a}, \\mathbf{b}, s)$ 构造一个表面，并计算其面积 $A$ 和外法线单位向量 $\\mathbf{n}$。\n2. 实现一个例程，使用 $n$ 阶 Gauss–Legendre 节点在 $[0,1]$ 上生成求积点，并为给定表面构建张量积点和权重。\n3. 实现一个函数，使用上述求积公式计算 $F_{1 \\to 2}$。\n4. 实现将一个表面沿 $\\mathbf{a}$ 方向分割成两个等面积的子表面，并数值验证可加性关系。\n\n测试集：\n按顺序计算以下四个结果，并按指定格式输出。所有坐标单位均为米。使用可见因子等于 $1$。\n\n- 测试 $1$（互易性，平行偏移矩形）：\n  - 表面 $S_1$：$\\mathbf{o}_1 = (-1.0,-0.5,0.0)$，$\\mathbf{a}_1 = (2.0,0.0,0.0)$，$\\mathbf{b}_1 = (0.0,1.0,0.0)$，$s_1=+1$。\n  - 表面 $S_2$：$\\mathbf{o}_2 = (-0.8,-0.6,0.5)$，$\\mathbf{a}_2 = (2.0,0.0,0.0)$，$\\mathbf{b}_2 = (0.0,1.0,0.0)$，$s_2=-1$。\n  - 使用求积阶数 $n=8$ 计算 $F_{1 \\to 2}$ 和 $F_{2 \\to 1}$。以浮点数形式输出绝对互易性残差 $\\left|A_1 F_{1 \\to 2} - A_2 F_{2 \\to 1}\\right|$。\n\n- 测试 $2$（收敛性，垂直矩形）：\n  - 表面 $S_1$：$\\mathbf{o}_1 = (-0.5,-0.5,0.0)$，$\\mathbf{a}_1 = (1.0,0.0,0.0)$，$\\mathbf{b}_1 = (0.0,1.0,0.0)$，$s_1=+1$。\n  - 表面 $S_2$：$\\mathbf{o}_2 = (1.0,-0.5,0.0)$，$\\mathbf{a}_2 = (0.0,1.0,0.0)$，$\\mathbf{b}_2 = (0.0,0.0,2.0)$，$s_2=-1$。\n  - 使用 $n \\in \\{2,4,6,8\\}$ 计算 $F_{1 \\to 2}$。令 $\\Delta_{8,6} = |F_{1 \\to 2}^{(n=8)} - F_{1 \\to 2}^{(n=6)}|$ 和 $\\Delta_{6,4} = |F_{1 \\to 2}^{(n=6)} - F_{1 \\to 2}^{(n=4)}|$。输出 $\\left(\\Delta_{8,6} < 5\\times 10^{-4}\\right)$ AND $\\left(\\Delta_{6,4} < 2\\times 10^{-3}\\right)$ 的布尔值。\n\n- 测试 $3$（可加性/分割，对于 $S_2$ 和分割后的 $S_1$，几何形状与测试 $1$ 相同）：\n  - 将测试 $1$ 中的 $S_1$ 沿 $\\mathbf{a}_1$ 方向分割成两个等面积的子表面。使用 $n=8$ 计算整个 $S_1$ 的 $F_{1 \\to 2}$，并对两个子表面使用 $n=8$ 计算面积加权和 $\\left(\\frac{A_{1a}}{A_1}\\right) F_{1a \\to 2} + \\left(\\frac{A_{1b}}{A_1}\\right) F_{1b \\to 2}$。以浮点数形式输出绝对差值。\n\n- 测试 $4$（小角系数边缘情况，远场平行小正方形）：\n  - 表面 $S_1$：$\\mathbf{o}_1 = (-0.1,-0.1,0.0)$，$\\mathbf{a}_1 = (0.2,0.0,0.0)$，$\\mathbf{b}_1 = (0.0,0.2,0.0)$，$s_1=+1$。\n  - 表面 $S_2$：$\\mathbf{o}_2 = (-0.1,-0.1,5.0)$，$\\mathbf{a}_2 = (0.2,0.0,0.0)$，$\\mathbf{b}_2 = (0.0,0.2,0.0)$，$s_2=-1$。\n  - 使用 $n=8$ 计算 $F_{1 \\to 2}$。输出此浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含测试 $1$–$4$ 的结果，以逗号分隔的列表形式包含在方括号内，无空格，且顺序如上所述。例如，输出必须是 $[r_1,b_2,r_3,f_4]$ 的形式，其中 $r_1$ 和 $r_3$ 是浮点数，$b_2$ 是布尔值，$f_4$ 是浮点数。不应打印任何额外文本。", "solution": "对所述问题进行验证。\n\n**步骤 1：提取的已知条件**\n- 角系数积分：$F_{1 \\to 2} = \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos\\theta_1 \\, \\cos\\theta_2}{\\pi \\, R^2} \\, \\mathrm{d}A_2 \\, \\mathrm{d}A_1$。\n- 角系数代数：互易性 $A_1 F_{1 \\to 2} = A_2 F_{2 \\to 1}$ 和可加性 $F_{1 \\to 2} = \\sum_k \\left(\\frac{A_{1k}}{A_1}\\right) F_{1k \\to 2}$。\n- 表面表示：由一个原点 $\\mathbf{o}$ 和两个张成向量 $\\mathbf{a}, \\mathbf{b}$ 参数化的平面平行四边形，形式为 $\\mathbf{r}(u,v) = \\mathbf{o} + u \\, \\mathbf{a} + v \\, \\mathbf{b}$，其中 $u, v \\in [0,1]$。外法线单位向量为 $\\mathbf{n} = s \\, (\\mathbf{a} \\times \\mathbf{b}) / \\|\\mathbf{a} \\times \\mathbf{b}\\|$，其中 $s \\in \\{+1, -1\\}$。面积为 $A = \\|\\mathbf{a} \\times \\mathbf{b}\\|$。\n- 数值方法：n阶张量积Gauss-Legendre求积。将区间 $[-1,1]$ 上的节点 $\\{x_i\\}$ 通过 $u_i = (x_i+1)/2$ 映射到 $[0,1]$，权重 $\\{w_i\\}$ 通过 $\\tilde{w}_i = w_i/2$ 映射。\n- 求积条件：若 $\\cos\\theta_1 \\le 0$ 或 $\\cos\\theta_2 \\le 0$，则微分贡献为零。\n- 测试集：提供了四个特定的测试用例，用于验证互易性、收敛性、可加性和小角系数配置。\n\n**步骤 2：验证**\n- **科学依据**：该问题具有坚实的理论基础。它基于既定的辐射传热原理，并使用标准的数学和数值技术。角系数的定义、其性质、几何表示以及Gauss-Legendre求积的选择都是教科书级别的标准。\n- **适定性**：该问题是适定的。每个测试的输入都被明确定义，所需的输出也是无歧义的。对于每个指定的求积阶数，都存在唯一的数值解。\n- **客观性**：该问题以精确、客观的数学和物理语言陈述，没有任何主观性或歧义。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个在计算物理学中定义明确的任务，要求从第一性原理出发实现一个数值算法。将提供一个解决方案。\n\n**基于原理的解决方案设计**\n\n任务是计算角系数 $F_{1 \\to 2}$，这是一个无量纲量，表示离开表面 $A_1$ 的辐射中直接到达表面 $A_2$ 的部分。控制方程是两个表面上的一个四维积分。\n\n首先，我们必须用参数坐标来表示这个积分。表面 $S_1$ 上的一个点 $\\mathbf{r}_1$ 由 $\\mathbf{r}_1(u_1, v_1) = \\mathbf{o}_1 + u_1 \\mathbf{a}_1 + v_1 \\mathbf{b}_1$ 给出，表面 $S_2$ 上的点 $\\mathbf{r}_2(u_2, v_2)$ 类似。微分面积元为 $\\mathrm{d}A_1 = \\|\\mathbf{a}_1 \\times \\mathbf{b}_1\\| \\, \\mathrm{d}u_1 \\, \\mathrm{d}v_1 = A_1 \\, \\mathrm{d}u_1 \\, \\mathrm{d}v_1$ 和 $\\mathrm{d}A_2 = A_2 \\, \\mathrm{d}u_2 \\, \\mathrm{d}v_2$。将这些代入 $F_{1 \\to 2}$ 的定义中得到：\n$$\nF_{1 \\to 2} = \\frac{1}{A_1} \\int_0^1 \\int_0^1 \\int_0^1 \\int_0^1 \\frac{\\cos\\theta_1 \\cos\\theta_2}{\\pi R^2} (A_2 \\, \\mathrm{d}u_2 \\mathrm{d}v_2) (A_1 \\, \\mathrm{d}u_1 \\mathrm{d}v_1)\n$$\n这可以简化为在超立方体 $[0,1]^4$ 上的纯参数积分：\n$$\nF_{1 \\to 2} = A_2 \\int_0^1 \\int_0^1 \\int_0^1 \\int_0^1 \\frac{\\cos\\theta_1 \\cos\\theta_2}{\\pi R^2} \\, \\mathrm{d}u_1 \\mathrm{d}v_1 \\mathrm{d}u_2 \\mathrm{d}v_2\n$$\n这里，对于每个四元组 $(u_1, v_1, u_2, v_2)$，我们有：\n- $S_1$ 上的点：$\\mathbf{r}_1 = \\mathbf{o}_1 + u_1\\mathbf{a}_1 + v_1\\mathbf{b}_1$\n- $S_2$ 上的点：$\\mathbf{r}_2 = \\mathbf{o}_2 + u_2\\mathbf{a}_2 + v_2\\mathbf{b}_2$\n- 点间向量：$\\mathbf{R} = \\mathbf{r}_2 - \\mathbf{r}_1$\n- 距离：$R = \\|\\mathbf{R}\\|$\n- 夹角余弦：$\\cos\\theta_1 = \\mathbf{n}_1 \\cdot \\frac{\\mathbf{R}}{R}$ 和 $\\cos\\theta_2 = \\mathbf{n}_2 \\cdot \\frac{-\\mathbf{R}}{R}$\n\n为了数值计算这个积分，我们采用一个 $n$ 阶 Gauss-Legendre 求积法，在四个维度 $(u_1, v_1, u_2, v_2)$ 上形成张量积。设 $\\{u_k, \\tilde{w}_k\\}_{k=1}^n$ 分别是从标准区间 $[-1,1]$ 映射到 $[0,1]$ 的求积节点和权重。该积分由以下和式近似：\n$$\nF_{1 \\to 2} \\approx A_2 \\sum_{i=1}^n \\sum_{j=1}^n \\sum_{p=1}^n \\sum_{q=1}^n (\\tilde{w}_i \\tilde{w}_j \\tilde{w}_p \\tilde{w}_q) \\left[ \\frac{\\cos\\theta_{1,ijpq} \\cos\\theta_{2,ijpq}}{\\pi R_{ijpq}^2} \\right]\n$$\n其中，括号中的项是在对应于节点 $(u_i, u_j, u_p, u_q)$ 的点上求值的被积函数，如果可见性失效（$\\cos\\theta_1 \\le 0$ 或 $\\cos\\theta_2 \\le 0$），则其值设为 $0$。\n\n实现将按以下结构进行：\n1.  定义一个 `Surface` 类来封装平行四边形的几何属性：其原点 $\\mathbf{o}$、张成向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，以及法线符号参数 $s$。该类将计算并存储其面积 $A$ 和外法线单位向量 $\\mathbf{n}$。\n2.  一个辅助函数将使用 `scipy.special.roots_legendre` 在 $[0,1]$ 上生成所需的 Gauss-Legendre 节点和权重，并使用缓存以防止对相同阶数 $n$ 的重复计算。\n3.  核心计算函数 `compute_view_factor` 实现数值积分。为实现高性能，该函数使用 `numpy` 进行向量化。它为每个表面生成 $n^2$ 个求积点和权重的完整集合。然后，使用矩阵和张量运算，在一次性计算中完成所有 $n^4$ 个成对相互作用、距离、夹角余弦和最终的加权和，从而避免显式的、缓慢的 Python 循环。这是进行严肃数值工作的唯一可接受方法。\n4.  四个测试用例将顺序执行。测试 $1$ 和测试 $3$ 验证了互易性和可加性这两个关键的代数性质，证明了公式的自洽性。测试 $2$ 确认了数值求积的收敛性，这是可靠数值方法的必要条件。测试 $4$ 评估算法在角系数很小的远场情况下的性能。\n\n最终的 Python 代码实现了此设计，以计算测试集所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the view factor calculations and tests.\n    \"\"\"\n    \n    # Use a cache for Gauss-Legendre quadrature data to avoid recomputation\n    gl_cache = {}\n\n    class Surface:\n        \"\"\"\n        Represents a planar parallelogram surface in 3D space.\n        \"\"\"\n        def __init__(self, o, a, b, s):\n            self.o = np.array(o, dtype=float)\n            self.a = np.array(a, dtype=float)\n            self.b = np.array(b, dtype=float)\n            self.s = s\n            \n            cross_prod = np.cross(self.a, self.b)\n            self.area = np.linalg.norm(cross_prod)\n            \n            if self.area < 1e-12:\n                # Handle degenerate parallelograms\n                self.normal = np.array([0.0, 0.0, 0.0])\n            else:\n                self.normal = self.s * cross_prod / self.area\n\n    def get_gauss_legendre(n, cache):\n        \"\"\"\n        Generates Gauss-Legendre nodes and weights for the interval [0, 1].\n        Results are cached to improve performance.\n        \"\"\"\n        if n not in cache:\n            nodes_m11, weights_m11 = roots_legendre(n)\n            nodes_01 = (nodes_m11 + 1.0) / 2.0\n            weights_01 = weights_m11 / 2.0\n            cache[n] = (nodes_01, weights_01)\n        return cache[n]\n\n    def compute_view_factor(s1, s2, n, cache):\n        \"\"\"\n        Computes the view factor F_{1->2} using n-order Gauss-Legendre quadrature.\n        \"\"\"\n        nodes, weights = get_gauss_legendre(n, cache)\n\n        # Generate n x n grid of parametric coordinates and weights for each surface\n        u_grid, v_grid = np.meshgrid(nodes, nodes)\n        wu_grid, wv_grid = np.meshgrid(weights, weights)\n\n        # Flatten grids to get 1D arrays of n^2 points/weights\n        u_flat = u_grid.flatten()\n        v_flat = v_grid.flatten()\n        w_flat = (wu_grid * wv_grid).flatten()\n\n        # Generate n^2 quadrature points in R^3 for each surface\n        # pts1 and pts2 will have shape (n^2, 3)\n        pts1 = s1.o + u_flat[:, np.newaxis] * s1.a + v_flat[:, np.newaxis] * s1.b\n        pts2 = s2.o + u_flat[:, np.newaxis] * s2.a + v_flat[:, np.newaxis] * s2.b\n        \n        # Vectorized calculation over all n^2 x n^2 point pairs\n        # R_vec has shape (n^2, n^2, 3) where R_vec[i, j, :] = pts2[j] - pts1[i]\n        R_vec = pts2[np.newaxis, :, :] - pts1[:, np.newaxis, :]\n        \n        # R_norm has shape (n^2, n^2)\n        R_norm = np.linalg.norm(R_vec, axis=2)\n        \n        # Avoid division by zero for coincident points (theoretically non-occurring here)\n        R_norm_safe = np.where(R_norm < 1e-12, 1.0, R_norm)\n\n        # cos(theta) calculations in a vectorized way\n        # Shape of both is (n^2, n^2)\n        cos_theta1 = np.dot(R_vec, s1.normal) / R_norm_safe\n        cos_theta2 = np.dot(-R_vec, s2.normal) / R_norm_safe\n        \n        # Apply visibility condition: contribution is zero if not mutually visible\n        valid_mask = (cos_theta1 > 0) & (cos_theta2 > 0)\n        \n        # Integrand kernel\n        kernel = (cos_theta1 * cos_theta2) / (np.pi * R_norm_safe**2)\n        \n        # Combine weights for 4D integration\n        # w_combined[i, j] = w_flat[i] * w_flat[j]\n        w_combined = w_flat[:, np.newaxis] * w_flat[np.newaxis, :]\n        \n        # Perform summation\n        integral_sum = np.sum(w_combined * kernel * valid_mask)\n        \n        # Final view factor\n        F12 = s2.area * integral_sum\n        return F12\n\n    # --- Test Suite Execution ---\n    results = []\n\n    # Test 1: Reciprocity\n    s1_t1 = Surface(o=[-1.0, -0.5, 0.0], a=[2.0, 0.0, 0.0], b=[0.0, 1.0, 0.0], s=1)\n    s2_t1 = Surface(o=[-0.8, -0.6, 0.5], a=[2.0, 0.0, 0.0], b=[0.0, 1.0, 0.0], s=-1)\n    n_t1 = 8\n    F12_t1 = compute_view_factor(s1_t1, s2_t1, n_t1, gl_cache)\n    F21_t1 = compute_view_factor(s2_t1, s1_t1, n_t1, gl_cache)\n    reciprocity_residual = abs(s1_t1.area * F12_t1 - s2_t1.area * F21_t1)\n    results.append(reciprocity_residual)\n\n    # Test 2: Convergence\n    s1_t2 = Surface(o=[-0.5, -0.5, 0.0], a=[1.0, 0.0, 0.0], b=[0.0, 1.0, 0.0], s=1)\n    s2_t2 = Surface(o=[1.0, -0.5, 0.0], a=[0.0, 1.0, 0.0], b=[0.0, 0.0, 2.0], s=-1)\n    orders = [2, 4, 6, 8]\n    f_vals = {n: compute_view_factor(s1_t2, s2_t2, n, gl_cache) for n in orders}\n    delta_86 = abs(f_vals[8] - f_vals[6])\n    delta_64 = abs(f_vals[6] - f_vals[4])\n    convergence_check = (delta_86 < 5e-4) and (delta_64 < 2e-3)\n    results.append(convergence_check)\n\n    # Test 3: Additivity\n    n_t3 = 8\n    # Partition surface s1_t1 from Test 1\n    a1_half = s1_t1.a / 2.0\n    s1a_t3 = Surface(s1_t1.o, a1_half, s1_t1.b, s1_t1.s)\n    s1b_t3 = Surface(s1_t1.o + a1_half, a1_half, s1_t1.b, s1_t1.s)\n    \n    F_1_2_t3 = compute_view_factor(s1_t1, s2_t1, n_t3, gl_cache)\n    F_1a_2_t3 = compute_view_factor(s1a_t3, s2_t1, n_t3, gl_cache)\n    F_1b_2_t3 = compute_view_factor(s1b_t3, s2_t1, n_t3, gl_cache)\n\n    # Since areas of sub-surfaces are equal (A_1a = A_1b = A_1/2)\n    F_sum_t3 = 0.5 * F_1a_2_t3 + 0.5 * F_1b_2_t3\n    additivity_residual = abs(F_1_2_t3 - F_sum_t3)\n    results.append(additivity_residual)\n\n    # Test 4: Small-factor edge case\n    s1_t4 = Surface(o=[-0.1, -0.1, 0.0], a=[0.2, 0.0, 0.0], b=[0.0, 0.2, 0.0], s=1)\n    s2_t4 = Surface(o=[-0.1, -0.1, 5.0], a=[0.2, 0.0, 0.0], b=[0.0, 0.2, 0.0], s=-1)\n    n_t4 = 8\n    F12_t4 = compute_view_factor(s1_t4, s2_t4, n_t4, gl_cache)\n    results.append(F12_t4)\n    \n    # Final output format\n    # Convert boolean to lowercase 'true'/'false' for output consistency.\n    results[1] = str(results[1]).lower()\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2537093"}]}