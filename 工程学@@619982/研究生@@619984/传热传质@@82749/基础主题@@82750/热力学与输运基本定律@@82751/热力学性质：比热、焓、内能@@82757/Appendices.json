{"hands_on_practices": [{"introduction": "在深入研究复杂的热力学过程之前，我们必须牢固掌握基本概念。本练习旨在阐明比内能 ($u$) 和比焓 ($h$) 这两个关键热力学性质之间的根本区别。通过推导和计算，您将亲身体会到对于不可压缩物质（如液体和固体），$pv$ 项的量级，并理解在何种情况下可以近似认为 $u \\approx h$ [@problem_id:2532114]。", "problem": "一个简单的、单相的闭口系统经历一个准静态的状态变化，并可以被建模为性质均匀的简单可压缩物质。以简单可压缩系统的热力学第一和第二定律以及比焓的标准热力学定义为基本出发点，推导一个连接比内能 $u$、比焓 $h$、压力 $p$ 和比容 $v$ 的微分的通用关系式。\n\n然后，将你的结果应用于密度恒定（即比容 $v$ 恒定）的不可压缩物质，并得到以 $p$ 和密度 $\\rho$ 表示的差值 $h - u$ 的代数表达式。\n\n最后，在压力 $p = 1$ 巴、温度 $T = 300$ K 的条件下，取液态水的密度为 $\\rho = 996.6\\,\\text{kg}\\,\\text{m}^{-3}$，计算该差值的大小。使用 $1\\,\\text{bar} = 1.000 \\times 10^{5}\\,\\text{Pa}$，并将最终的能量差值以 $\\text{J}\\,\\text{kg}^{-1}$ 为单位表示。将答案四舍五入至四位有效数字。", "solution": "问题陈述在科学上是合理的，提法恰当，并包含了完整求解所需的所有信息。这是一个热力学导论中的标准问题。\n\n第一个任务是推导一个连接比内能 ($u$)、比焓 ($h$)、压力 ($p$) 和比容 ($v$) 的微分的通用关系式。我们从比焓 $h$ 的定义开始，它是一个热力学性质，定义如下：\n$$\nh \\equiv u + pv\n$$\n这个定义适用于任何相态的任何纯物质。为了找到这些性质的微分之间的关系，我们对 $h$ 的表达式进行微分。对 $pv$ 项使用乘积法则，我们得到：\n$$\ndh = d(u + pv) = du + d(pv) = du + p dv + v dp\n$$\n这个方程 $dh = du + p dv + v dp$，是连接四个微分量 $du$、$dh$、$dp$ 和 $dv$ 的通用关系式。因为它是由状态函数推导出来的，所以它是一个全微分。这个关系式是基础的，并且不依赖于过程路径。\n\n作为背景知识，对于一个准静态（可逆）过程，运用第一和第二定律，我们有第一个 Gibbs 关系式：$du = Tds - pdv$。将此代入 $h$ 的微分式，可得到第二个 Gibbs 关系式，$dh = (Tds - pdv) + pdv + vdp = Tds + vdp$。然而，问题明确要求的是一个连接 $u, h, p, v$ 及其微分的关系式，对此，$dh = du + p dv + v dp$ 是最直接的答案。\n\n第二个任务是将此结果应用于不可压缩物质。不可压缩物质的定义是其比容 $v$（因此其密度 $\\rho=1/v$）为常数的约束条件。\n$$\nv = \\text{constant} \\implies dv = 0\n$$\n将 $dv = 0$ 代入通用关系式 $dh = du + p dv + v dp$，我们得到适用于不可压缩物质的特定关系式：\n$$\ndh = du + v dp\n$$\n这可以写成 $d(h-u) = v dp$ 的形式，它表明了对于不可压缩物质，比焓和比内能之差是如何随压力而变化的。\n\n第三个任务是找到以 $p$ 和 $\\rho$ 表示的差值 $h - u$ 的代数表达式。我们回到焓的定义：\n$$\nh = u + pv\n$$\n整理这个方程直接得到差值：\n$$\nh - u = pv\n$$\n这个简单的代数关系是普适的。对于不可压缩物质的特殊情况，比容 $v$ 是一个常数参数。为了用密度 $\\rho$ 来表示它，我们使用定义 $\\rho = 1/v$：\n$$\nh - u = \\frac{p}{\\rho}\n$$\n这就是所要求的表达式。这个结果与微分形式 $d(h-u) = v dp$ 的积分是一致的。从压力为 $p_0=0$ 且设定 $u_0=0$（因此 $h_0=0$）的参考状态开始积分，我们发现 $\\int_{0}^{h-u} d(h'-u') = \\int_{0}^{p} v dp'$，这给出 $h-u = vp = p/\\rho$。因此，该表达式是可靠的。\n\n最后的任务是计算在指定条件下液态水的 $h - u$ 的大小。\n给定的数据如下：\n- 压力: $p = 1 \\text{ bar} = 1.000 \\times 10^{5} \\text{ Pa}$\n- 密度: $\\rho = 996.6 \\text{ kg m}^{-3}$\n\n我们将这些值代入推导出的表达式 $h - u = p/\\rho$。必须正确处理单位。一个帕斯卡（$Pa$）等于一个牛顿每平方米（$\\text{N m}^{-2}$），一个焦耳（$J$）等于一个牛顿米（$\\text{N m}$）。\n$$\nh - u = \\frac{1.000 \\times 10^{5} \\text{ Pa}}{996.6 \\text{ kg m}^{-3}} = \\frac{1.000 \\times 10^{5} \\text{ N m}^{-2}}{996.6 \\text{ kg m}^{-3}}\n$$\n计算得出：\n$$\nh - u = 100.34116... \\text{ N m kg}^{-1} = 100.34116... \\text{ J kg}^{-1}\n$$\n问题要求答案四舍五入到四位有效数字，这与给定数据的精度（$1.000$ 和 $996.6$ 都有四位有效数字）是一致的。\n将结果四舍五入到四位有效数字，我们得到：\n$$\nh - u = 100.3 \\text{ J kg}^{-1}\n$$", "answer": "$$\n\\boxed{100.3}\n$$", "id": "2532114"}, {"introduction": "将热力学原理应用于工程实践时，我们常常面临一个关键抉择：何时可以使用恒定比热的简化模型？本练习将通过一个实际的空气加热过程，带您量化这一简化所带来的误差。您将对比使用恒定比热（量热完全气体）和使用随温度变化的表格数据（热完全气体）计算热传递的差异，从而深刻理解在处理大温差问题时精确物性数据的重要性 [@problem_id:2532089]。", "problem": "一个稳态流、恒压的气体加热器将一股干燥空气流从入口温度 $T_{1} = 300\\,\\mathrm{K}$ 加热到出口温度 $T_{2} = 2000\\,\\mathrm{K}$。忽略动能和势能的变化，并将空气视为理想气体。现需要比较两种对所需传热率的预测：\n\n1. 量热全气体模型，该模型假设定压比热容为一常数，其值等于在 $T_{1}$ 时的值，即 $c_{p,0} = 1006\\,\\mathrm{J/(kg\\cdot K)}$。\n2. 热全气体模型，该模型使用一个与温度相关的 $c_{p}(T)$，此函数通过对以下干燥空气的列表值进行线性插值构建（$c_{p}$ 的单位是 $\\mathrm{J/(kg\\cdot K)}$，$T$ 的单位是 $\\mathrm{K}$）：\n$$(T,c_{p}) \\in \\{(300,1006),\\,(600,1040),\\,(900,1100),\\,(1200,1160),\\,(1500,1220),\\,(1800,1270),\\,(2000,1310)\\}.$$\n假设 $c_{p}(T)$ 在每对相邻的列表温度之间线性变化，并且只使用所提供的数据。\n\n从第一性原理出发，使用稳态流热力学第一定律和理想气体焓的定义，推导出每种模型下传热率预测的表达式，然后计算量热全气体预测相对于热全气体基准的有符号相对误差。将有符号相对误差表示为\n$$\\varepsilon = \\frac{\\dot{Q}_{\\text{caloric}} - \\dot{Q}_{\\text{thermal}}}{\\dot{Q}_{\\text{thermal}}},$$\n并以无量纲小数形式报告。将最终答案四舍五入至四位有效数字。不要使用百分号。如果引入了质量流量 $\\dot{m}$，最终报告的 $\\varepsilon$ 必须不依赖于 $\\dot{m}$。", "solution": "首先验证问题，确保其科学上合理且提法得当。该问题基于应用于开放系统的热力学第一定律，并利用了理想气体比热容的标准模型（量热全气体和热全气体）。所提供的空气比热容数据在物理上是现实的，且温度范围与燃气轮机等工程应用相关。该问题是自洽的，提供了计算出唯一、有意义结果所需的所有数据和条件。问题中没有矛盾、歧义或违反物理原理之处。该问题被认为是有效的，可以制定解决方案。\n\n分析始于应用于控制容积的稳态流热力学第一定律。能量平衡由下式给出：\n$$ \\dot{Q} - \\dot{W}_{s} = \\dot{m} \\left( (h_{2} - h_{1}) + \\frac{V_{2}^{2} - V_{1}^{2}}{2} + g(z_{2} - z_{1}) \\right) $$\n其中 $\\dot{Q}$ 是传入系统的传热率，$\\dot{W}_{s}$ 是系统所做的轴功功率，$\\dot{m}$ 是质量流量，$h$ 是比焓，$V$ 是速度，$z$ 是高度。\n\n根据问题陈述，该系统是一个气体加热器，因此没有轴功，即 $\\dot{W}_{s} = 0$。动能和势能的变化可以忽略，因此 $\\frac{V_{2}^{2} - V_{1}^{2}}{2} \\approx 0$ 且 $g(z_{2} - z_{1}) \\approx 0$。第一定律简化为：\n$$ \\dot{Q} = \\dot{m} (h_{2} - h_{1}) = \\dot{m} \\Delta h $$\n比传热量 $q$ 是单位质量的传热量：\n$$ q = \\frac{\\dot{Q}}{\\dot{m}} = h_{2} - h_{1} $$\n对于理想气体，比焓的变化仅是温度的函数。比焓的微分变化为 $dh = c_{p}(T) dT$，其中 $c_{p}(T)$ 是定压比热容。从入口温度 $T_{1}$ 到出口温度 $T_{2}$ 的总比焓变化可通过积分求得：\n$$ \\Delta h = \\int_{T_{1}}^{T_{2}} c_{p}(T) dT $$\n因此，比传热量为 $q = \\int_{T_{1}}^{T_{2}} c_{p}(T) dT$。我们将针对所提出的两种模型计算该积分。\n\n模型 1：量热全气体\n在此模型中，假设比热容为一常数，其值等于初始温度 $T_{1} = 300\\,\\mathrm{K}$ 时的值。该值为 $c_{p,0} = 1006\\,\\mathrm{J/(kg \\cdot K)}$。比传热量的积分变为：\n$$ q_{\\text{caloric}} = \\int_{T_{1}}^{T_{2}} c_{p,0} dT = c_{p,0} \\int_{T_{1}}^{T_{2}} dT = c_{p,0} (T_{2} - T_{1}) $$\n代入给定值 $T_{1} = 300\\,\\mathrm{K}$ 和 $T_{2} = 2000\\,\\mathrm{K}$：\n$$ q_{\\text{caloric}} = (1006\\,\\mathrm{J/(kg \\cdot K)}) \\times (2000\\,\\mathrm{K} - 300\\,\\mathrm{K}) = 1006 \\times 1700\\,\\mathrm{J/kg} = 1710200\\,\\mathrm{J/kg} $$\n\n模型 2：热全气体\n在此模型中，$c_{p}(T)$ 是一个与温度相关的分段线性函数，由所提供的数据点定义。为了求得比传热量 $q_{\\text{thermal}}$，我们必须将此分段函数从 $T_{1} = 300\\,\\mathrm{K}$ 到 $T_{2} = 2000\\,\\mathrm{K}$ 进行积分。该积分是每个线性段上积分的总和。对于温度 $T_{i}$ 和 $T_{i+1}$ 之间的任意段，线性函数 $c_p(T)$ 的积分是梯形的面积：\n$$ \\int_{T_{i}}^{T_{i+1}} c_{p}(T) dT = \\frac{c_{p}(T_{i}) + c_{p}(T_{i+1})}{2} (T_{i+1} - T_{i}) $$\n总比传热量是从 $T_{1}$ 到 $T_{2}$ 所有分段上这些面积的总和。数据点为 $(300, 1006)$, $(600, 1040)$, $(900, 1100)$, $(1200, 1160)$, $(1500, 1220)$, $(1800, 1270)$ 和 $(2000, 1310)$。\n计算过程是六个区间的总和：\n\\begin{align*} q_{\\text{thermal}} = & \\frac{1006 + 1040}{2} (600 - 300) + \\frac{1040 + 1100}{2} (900 - 600) \\\\ & + \\frac{1100 + 1160}{2} (1200 - 900) + \\frac{1160 + 1220}{2} (1500 - 1200) \\\\ & + \\frac{1220 + 1270}{2} (1800 - 1500) + \\frac{1270 + 1310}{2} (2000 - 1800) \\end{align*}\n$$ q_{\\text{thermal}} = (1023)(300) + (1070)(300) + (1130)(300) + (1190)(300) + (1245)(300) + (1290)(200) $$\n$$ q_{\\text{thermal}} = 306900 + 321000 + 339000 + 357000 + 373500 + 258000 $$\n$$ q_{\\text{thermal}} = 1955400\\,\\mathrm{J/kg} $$\n\n有符号相对误差\n量热全气体模型相对于热全气体模型的有符号相对误差 $\\varepsilon$ 定义为：\n$$ \\varepsilon = \\frac{\\dot{Q}_{\\text{caloric}} - \\dot{Q}_{\\text{thermal}}}{\\dot{Q}_{\\text{thermal}}} $$\n由于 $\\dot{Q} = \\dot{m} q$，质量流量 $\\dot{m}$ 从表达式中消去：\n$$ \\varepsilon = \\frac{\\dot{m} q_{\\text{caloric}} - \\dot{m} q_{\\text{thermal}}}{\\dot{m} q_{\\text{thermal}}} = \\frac{q_{\\text{caloric}} - q_{\\text{thermal}}}{q_{\\text{thermal}}} $$\n代入计算出的 $q_{\\text{caloric}}$ 和 $q_{\\text{thermal}}$ 的值：\n$$ \\varepsilon = \\frac{1710200 - 1955400}{1955400} = \\frac{-245200}{1955400} $$\n$$ \\varepsilon \\approx -0.125396338... $$\n将结果四舍五入至四位有效数字，得到：\n$$ \\varepsilon = -0.1254 $$\n负号表示定比热容模型严重低估了达到指定温升所需的传热量，因为它忽略了空气在较高温度下比热容的增加。", "answer": "$$\\boxed{-0.1254}$$", "id": "2532089"}, {"introduction": "在现代计算流体动力学 (CFD) 和其他热力学模拟中，能量通常是一个守恒量，而温度则需要通过能量反算得到。本练习将引导您实现一个核心的计算任务：开发一个稳健的数值算法，从给定的比焓值 $h^{\\star}$ 反演求解温度 $T$。通过实践牛顿迭代法及其全局化策略，您将掌握将热力学理论与工程计算模拟紧密结合的关键技能 [@problem_id:2532137]。", "problem": "要求您实现并分析在计算流体力学背景下，一种量热非完美气体的温度相关比焓的数值反演。该反演是从比焓到温度的转换，其中定压比热是温度的函数。算法核心必须是牛顿迭代法，具有明确定义的停止准则和一个全局化策略，以保证在指定的温度区间内具有稳健的行为。\n\n基本原理如下：\n- 对于一个单相物质，当其被建模为具有温度相关定压比热的完美气体时，比焓的定义满足微分关系 $dh = c_p(T)\\, dT$。因此，设参考状态温度为 $T_{\\mathrm{ref}}$ 且参考焓值为零，焓作为温度的函数由下式给出：\n$$\nh(T) = \\int_{T_{\\mathrm{ref}}}^{T} c_p(\\theta)\\, d\\theta.\n$$\n- 假设 $c_p(T)$ 的多项式模型为：\n$$\nc_p(T) = a + b\\,T + c\\,T^2,\n$$\n其中 $a$、$b$ 和 $c$ 是国际单位制（SI）中的常数，$c_p$ 的单位为 $\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$，$T$ 的单位为 $\\mathrm{K}$。\n\n任务要求：\n1. 推导出一个牛顿迭代法，用于在给定目标焓值 $h^\\star$ 的情况下求解温度 $T$，方法是仅使用上述基本定义来构建一个标量求根问题 $r(T)=0$。您的推导必须从第一性原理出发，不得假设任何简化公式。说明您将要实现的停止准则，以及一个全局化策略，以确保当原始牛顿步长超出指定的温度区间时算法的稳健性。\n2. 根据下文给出的特定模型数据实现该迭代。您的实现必须先验地检查根是否被限定在区间内，并且必须采用一种安全保障措施，该措施根据需要将牛顿步长与回溯和二分法相结合。\n3. 对此模型，从数学上分析牛顿迭代法收敛的条件，并讨论两种初始猜测策略的效果。然后，使用提供的测试套件对这些策略进行数值评估。\n\n模型数据和单位：\n- 使用单位：$T$ 为 $\\mathrm{K}$，$h$ 为 $\\mathrm{J}\\,\\mathrm{kg}^{-1}$，$c_p$ 为 $\\mathrm{J}\\,\\mathrm{kg}^{-1}\\,\\mathrm{K}^{-1}$。\n- 设 $T_{\\mathrm{ref}} = 298.15$。\n- 设 $a = 850.0$，$b = 0.1$，$c = 1.0\\times 10^{-4}$。\n- 在此选择下，$c_p(T) > 0$ 在与燃烧和高温气体动力学相关的宽温度范围内成立，且 $h(T)$ 是严格单调递增的，这确保了在任何 $c_p(T)$ 保持为正的区间上都存在唯一的反函数。\n- 在计算 $h(T)$ 时，使用由基本原理推导出的闭式积分形式。\n\n数值算法输入和规则：\n- 温度区间：$T_{\\min} = 200.0$ 和 $T_{\\max} = 2500.0$。\n- 收敛容差：\n  - 温度增量容差：$\\varepsilon_T = 10^{-10}$，单位 $\\mathrm{K}$。\n  - 残差容差：$\\varepsilon_h = 10^{-6}$，单位 $\\mathrm{J}\\,\\mathrm{kg}^{-1}$。\n- 最大迭代次数：$N_{\\max} = 50$。\n- 全局化策略：\n  - 如果原始牛顿步长会超出 $[T_{\\min},T_{\\max}]$ 区间，则执行回溯线搜索（步长衰减），并在必要时回退到使用当前包含根的区间进行二分法步长计算。\n  - 根据已接受的迭代点的残差符号更新区间，以维持对根的有效包围。\n\n待比较的初始猜测策略：\n- 策略 $\\mathrm{S1}$（参考点线性化）：$T_0^{\\mathrm{S1}} = T_{\\mathrm{ref}} + h^\\star / c_p(T_{\\mathrm{ref}})$。\n- 策略 $\\mathrm{S2}$（可行区间的中点）：$T_0^{\\mathrm{S2}} = \\tfrac{1}{2}(T_{\\min}+T_{\\max})$。\n- 在所有情况下，将初始猜测值限定在区间内。\n\n测试套件：\n- 对于每个测试，程序必须通过精确计算积分 $h(T_{\\mathrm{true}})$，从一个已知的“真实”温度 $T_{\\mathrm{true}}$ 构建目标焓 $h^\\star$，然后尝试通过反演算法恢复该温度。使用以下真实温度集：\n  - 情况 1：$T_{\\mathrm{true}} = 900.0$。\n  - 情况 2：$T_{\\mathrm{true}} = 300.0$。\n  - 情况 3：$T_{\\mathrm{true}} = 2200.0$。\n  - 情况 4：$T_{\\mathrm{true}} = 250.0$。\n  - 情况 5：$T_{\\mathrm{true}} = 1500.0$。\n\n程序输出要求：\n- 对于每种情况，运行两种初始猜测策略 $\\mathrm{S1}$ 和 $\\mathrm{S2}$，并为每种策略返回计算出的温度（单位 K）、所用迭代次数以及一个表示是否在规定容差下收敛的布尔标志。\n- 温度以 K 为单位，四舍五入至六位小数。迭代次数必须是整数。收敛标志必须是布尔值。\n- 您的程序应生成单行输出，包含一个逗号分隔的 Python 风格的列表之列表，每个子列表对应一个测试用例的结果。每个子列表的格式必须是\n  $[T^{\\mathrm{S1}}, n^{\\mathrm{S1}}, \\mathrm{conv}^{\\mathrm{S1}}, T^{\\mathrm{S2}}, n^{\\mathrm{S2}}, \\mathrm{conv}^{\\mathrm{S2}}]$，\n  其中 $T^{\\mathrm{S1}}$ 和 $T^{\\mathrm{S2}}$ 是以 K 为单位、四舍五入到六位小数的浮点数，$n^{\\mathrm{S1}}$ 和 $n^{\\mathrm{S2}}$ 是整数，而 $\\mathrm{conv}^{\\mathrm{S1}}$ 和 $\\mathrm{conv}^{\\mathrm{S2}}$ 是布尔值。\n- 例如，最终输出格式必须类似于\n  $[[T_1^{\\mathrm{S1}}, n_1^{\\mathrm{S1}}, \\mathrm{conv}_1^{\\mathrm{S1}}, T_1^{\\mathrm{S2}}, n_1^{\\mathrm{S2}}, \\mathrm{conv}_1^{\\mathrm{S2}}],\\dots]$\n  ，占单行，无任何附加文本。", "solution": "经评估，该问题陈述有效。其科学基础扎根于热力学原理，问题提法适定（well-posed），所提供的模型保证了唯一解的存在，并且其表述是客观的。所有数据和算法要求均完整且一致。因此，我们可以着手求解。\n\n任务是针对量热非完美气体，找出给定比焓 $h^\\star$ 所对应的温度 $T$。比焓 $h$ 与温度 $T$ 之间的关系由定压比热 $c_p(T)$ 定义。\n\n首先，我们建立 $h$ 和 $T$ 之间的显式函数关系。其定义为 $dh = c_p(T) dT$。将此式从参考温度 $T_{\\mathrm{ref}}$ 积分到任意温度 $T$，并设参考焓值为零，可得：\n$$\nh(T) = \\int_{T_{\\mathrm{ref}}}^{T} c_p(\\theta)\\, d\\theta\n$$\n比热由一个多项式模型给出：\n$$\nc_p(T) = a + bT + cT^2\n$$\n将此模型代入 $h(T)$ 的积分中，我们执行积分运算：\n$$\nh(T) = \\int_{T_{\\mathrm{ref}}}^{T} (a + b\\theta + c\\theta^2)\\, d\\theta = \\left[ a\\theta + \\frac{b}{2}\\theta^2 + \\frac{c}{3}\\theta^3 \\right]_{T_{\\mathrm{ref}}}^{T}\n$$\n这得到了比焓的闭式表达式：\n$$\nh(T) = \\left( aT + \\frac{b}{2}T^2 + \\frac{c}{3}T^3 \\right) - \\left( aT_{\\mathrm{ref}} + \\frac{b}{2}T_{\\mathrm{ref}}^2 + \\frac{c}{3}T_{\\mathrm{ref}}^3 \\right)\n$$\n为方便起见，我们可以定义一个原函数 $H(T) = aT + \\frac{b}{2}T^2 + \\frac{c}{3}T^3$，从而 $h(T) = H(T) - H(T_{\\mathrm{ref}})$。\n\n将此关系反演以求给定 $h^\\star$ 对应的 $T$ 的问题，等价于求解残差函数 $r(T)$ 的根：\n$$\nr(T) = h(T) - h^\\star = 0\n$$\n为了使用 Newton 方法求解此问题，我们需要残差函数的导数 $r'(T)$。根据微积分基本定理，一个积分对其积分上限的导数等于被积函数在该上限处的值。\n$$\nr'(T) = \\frac{d}{dT} \\left( \\int_{T_{\\mathrm{ref}}}^{T} c_p(\\theta)\\, d\\theta - h^\\star \\right) = c_p(T)\n$$\n因此，$r'(T) = a + bT + cT^2$。用于求根 $T$ 的 Newton 迭代由以下递归公式给出：\n$$\nT_{k+1} = T_k - \\frac{r(T_k)}{r'(T_k)} = T_k - \\frac{h(T_k) - h^\\star}{c_p(T_k)}\n$$\n其中 $T_k$ 是第 $k$ 次迭代时的温度。\n\n该数值算法必须是稳健的。需要一个全局化策略来确保即使初始猜测远离根时也能收敛。指定的温度区间为 $[T_{\\min}, T_{\\max}] = [200.0, 2500.0]$。将实现一个混合的 Newton-二分法算法。\n首先，我们必须通过检查 $r(T_{\\min})$ 和 $r(T_{\\max})$ 是否异号来验证区间内是否存在根。根据给定的常数 $a = 850.0$、$b = 0.1$ 和 $c = 1.0 \\times 10^{-4}$，导数 $c_p(T)$ 是一个开口向上的抛物线，其最小值点在 $T = -b/(2c) = -500.0$ K。对于 $T \\ge 200.0$ K，$c_p(T) > 0$ 成立，因此 $h(T)$ 是严格单调递增的。这保证了如果 $h^\\star$ 位于 $h(T_L)$ 和 $h(T_R)$ 之间，则在任何区间 $[T_L, T_R]$ 内都存在唯一的根。\n\n算法流程如下：\n1.  初始化迭代次数 $k = 0$，温度区间 $[T_L, T_R] = [T_{\\min}, T_{\\max}]$，并根据所选策略（S1或S2）确定初始猜测 $T_0$，将其限定在区间内。\n2.  在从 $T_k$ 开始的每次迭代 $k$ 中：\n    a. 计算残差 $r(T_k)$ 及其导数 $c_p(T_k)$。\n    b. 计算 Newton 步长 $\\Delta T_k = -r(T_k)/c_p(T_k)$ 和提议的下一个迭代点 $T_{\\text{prop}} = T_k + \\Delta T_k$。\n    c. 如果提议的迭代点 $T_{\\text{prop}}$ 落在了当前的搜索区间 $[T_L, T_R]$ 之外，则拒绝原始的 Newton 步长，改为采用更保守的二分法步长：$T_{k+1} = T_L + 0.5(T_R - T_L)$。\n    d. 否则，接受 Newton 步长：$T_{k+1} = T_{\\text{prop}}$。\n    e. 为下一次迭代更新包围区间。通过评估新迭代点残差的符号 $r(T_{k+1})$ 来缩小区间。如果 $\\text{sign}(r(T_{k+1})) = \\text{sign}(r(T_L))$，则新的左边界变为 $T_L = T_{k+1}$。否则，新的右边界变为 $T_R = T_{k+1}$。这确保了根始终被包围。\n3.  如果达到收敛条件，或达到最大迭代次数 $N_{\\max} = 50$，则迭代终止。收敛定义为满足以下两个条件之一：\n    a. 温度变化量小于容差：$|T_{k+1} - T_k| < \\varepsilon_T = 10^{-10}$ K。\n    b. 焓残差的绝对值小于容差：$|r(T_{k+1})| = |h(T_{k+1}) - h^\\star| < \\varepsilon_h = 10^{-6}$ J/kg。\n\n此处 Newton 方法的数学收敛条件是有利的。函数 $r(T)$ 的二阶导数为 $r''(T) = c_p'(T) = b + 2cT$。对于所有 $T > -b/(2c) = -500.0$ K，$r''(T)>0$ 成立。这意味着 $r(T)$ 在整个关注的温度范围 $[200.0, 2500.0]$ 上是一个凸函数。对于凸函数，从任何使得 $r(T_0)>0$ 的起始点 $T_0$ 出发，Newton 方法都保证收敛到唯一的根，并且从 $T_0 < T^\\star$ 的起始点出发会快速收敛。所实现的全局化策略提供了一个额外的稳健性层，即使在不太理想的情况下也能保证收敛。\n\n我们分析两种初始猜测策略：\n- **策略 S1**：$T_0^{\\mathrm{S1}} = T_{\\mathrm{ref}} + h^\\star / c_p(T_{\\mathrm{ref}})$。这个猜测是基于在参考状态 $(T_{\\mathrm{ref}}, h=0)$ 附近对反函数 $T(h)$ 的一阶泰勒级数展开。它使用参考温度下的比热来线性化问题。这个“有信息”的猜测当真实温度 $T_{\\mathrm{true}}$ 接近 $T_{\\mathrm{ref}} = 298.15$ K 时，预计将非常准确，并且在 $c_p(T)$ 与 $c_p(T_{\\mathrm{ref}})$ 偏离不大的温度范围内，它也应保持为一个良好的估计。\n- **策略 S2**：$T_0^{\\mathrm{S2}} = \\tfrac{1}{2}(T_{\\min}+T_{\\max}) = 1350.0$ K。这个“无信息”的猜测被固定在可行温度区间的中点，与目标焓 $h^\\star$ 无关。这是一个安全但可能效率不高的起点，特别是当真实根位于区间边界附近时。\n\n由于其物理基础，我们预计策略 S1 的表现会更优，迭代次数在整个测试套件中会更少。策略 S2 的性能将强烈依赖于真实温度与区间中点的接近程度。由于所实现算法的稳健性，预计两种策略都将成功收敛。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a Newton-Raphson-based solver for inverting a\n    temperature-dependent specific enthalpy function for a calorically imperfect gas.\n    The solution is derived from first principles and includes a robust globalization\n    strategy combining Newton steps with bisection.\n    \"\"\"\n\n    # --- Model Data and Constants ---\n    a = 850.0  # J/kg/K\n    b = 0.1    # J/kg/K^2\n    c = 1.0e-4 # J/kg/K^3\n    T_ref = 298.15  # K\n\n    # --- Numerical Algorithm Parameters ---\n    T_min = 200.0  # K\n    T_max = 2500.0 # K\n    eps_T = 1.0e-10 # K\n    eps_h = 1.0e-6  # J/kg\n    N_max = 50\n\n    # --- Pre-calculate reference enthalpy primitive ---\n    H_T_ref = a * T_ref + (b / 2.0) * T_ref**2 + (c / 3.0) * T_ref**3\n\n    def c_p(T):\n        \"\"\"Calculates specific heat at constant pressure, c_p(T).\"\"\"\n        return a + b * T + c * T**2\n\n    def h(T):\n        \"\"\"Calculates specific enthalpy, h(T), relative to T_ref.\"\"\"\n        H_T = a * T + (b / 2.0) * T**2 + (c / 3.0) * T**3\n        return H_T - H_T_ref\n\n    def invert_h_to_T(h_target, initial_guess_strategy):\n        \"\"\"\n        Inverts h(T) = h_target to find T using a robust Newton's method.\n        \"\"\"\n        # --- A priori root bracketing check ---\n        # With the given constants, h(T) is strictly increasing for T > 0.\n        if not (h(T_min) = h_target = h(T_max)):\n            # This should not happen with the given test cases.\n            return T_min, N_max, False\n\n        # --- Determine initial guess T_0 ---\n        if initial_guess_strategy == 'S1':\n            T_0 = T_ref + h_target / c_p(T_ref)\n        elif initial_guess_strategy == 'S2':\n            T_0 = 0.5 * (T_min + T_max)\n        else:\n            raise ValueError(\"Invalid initial guess strategy.\")\n\n        # Clamp initial guess to the global bracket\n        T_k = np.clip(T_0, T_min, T_max)\n\n        # --- Initialize Globalization Bracket ---\n        T_L, T_R = T_min, T_max\n        r_L = h(T_L) - h_target\n\n        for n_iter in range(1, N_max + 1):\n            # Calculate residual and derivative at current iterate T_k\n            r_k = h(T_k) - h_target\n            r_prime_k = c_p(T_k)\n\n            # Avoid division by zero, though c_p(T) > 0 in the bracket\n            if abs(r_prime_k)  1e-12:\n                break\n\n            # --- Hybrid Newton-Bisection Step ---\n            # Proposed Newton step\n            delta_T = -r_k / r_prime_k\n            T_prop = T_k + delta_T\n\n            # Globalization: check if Newton step is within the current bracket\n            if T_prop = T_L or T_prop >= T_R:\n                # Fallback to bisection\n                T_k_plus_1 = T_L + 0.5 * (T_R - T_L)\n            else:\n                # Accept Newton step\n                T_k_plus_1 = T_prop\n\n            # --- Check for Convergence ---\n            r_k_plus_1 = h(T_k_plus_1) - h_target\n            temp_step = abs(T_k_plus_1 - T_k)\n\n            if temp_step  eps_T or abs(r_k_plus_1)  eps_h:\n                return T_k_plus_1, n_iter, True\n            \n            # --- Update Bracket for Next Iteration ---\n            if r_k_plus_1 * r_L > 0:\n                T_L = T_k_plus_1\n                r_L = r_k_plus_1\n            else:\n                T_R = T_k_plus_1\n            \n            # Prepare for next iteration\n            T_k = T_k_plus_1\n\n        # If loop finishes, convergence was not achieved\n        return T_k, N_max, False\n\n    # --- Test Suite ---\n    test_cases_T_true = [900.0, 300.0, 2200.0, 250.0, 1500.0]\n    \n    results = []\n    for T_true in test_cases_T_true:\n        h_star = h(T_true)\n        \n        # Run with Strategy S1\n        T_s1, n_s1, conv_s1 = invert_h_to_T(h_star, 'S1')\n        \n        # Run with Strategy S2\n        T_s2, n_s2, conv_s2 = invert_h_to_T(h_star, 'S2')\n        \n        case_result = [\n            round(T_s1, 6), n_s1, conv_s1,\n            round(T_s2, 6), n_s2, conv_s2\n        ]\n        results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # The output format is a python-style list of lists string representation.\n    # The str() of a list automatically handles spacing and True/False boolean representation.\n    # The result is joined to form the final string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2532137"}]}