{"hands_on_practices": [{"introduction": "离散坐标法的基础在于将对连续立体角的积分，近似为在一组有限离散方向上的加权和。本实践将指导您为一个在许多工程应用中十分常见的轴对称系统构建这样一个求积组。通过将一维的高斯-勒让德 (Gauss-Legendre) 求积映射到整个球面，并确保其满足正确的归一化条件，您将对角度离散化的执行方式及其对方法准确性的重要性，有一个具体的理解。[@problem_id:2528233]", "problem": "一个辐射参与介质采用离散坐标法 (DOM) 处理，假设关于一个固定轴具有轴对称性，因此比强度的任何角向依赖性都可以仅写作方向余弦 $\\mu=\\cos\\theta$ 的函数。设立体角元为 $d\\Omega=\\sin\\theta\\,d\\theta\\,d\\phi$，其中极角 $\\theta\\in[0,\\pi]$，方位角 $\\phi\\in[0,2\\pi)$。考虑使用在 $\\mu\\in[-1,1]$ 上的 $N$ 点一维Gauss–Legendre求积来近似一个光滑标量函数 $f(\\mu)$ 的立体角积分。\n\n任务：\n1) 从 $d\\Omega$ 的定义和变量代换 $\\mu=\\cos\\theta$ 出发，推导 $f(\\mu)$ 的全立体角积分的轴对称表示，并陈述常值函数 $f(\\mu)=1$ 在整个球面上积分的相应精确归一化条件。\n2) 设在 $\\mu\\in[-1,1]$ 上的一维Gauss–Legendre求积由节点 $\\{\\mu_{n}\\}_{n=1}^{N}$ 和权重 $\\{w_{n}\\}_{n=1}^{N}$ 表征，使得对于足够光滑的 $g$，有 $\\int_{-1}^{1}g(\\mu)\\,d\\mu\\approx\\sum_{n=1}^{N}w_{n}g(\\mu_{n})$。确定与相同节点 $\\{\\mu_{n}\\}$ 配对的立体角权重 $\\{W_{n}\\}_{n=1}^{N}$，使得离散近似 $\\int_{4\\pi} f\\,d\\Omega\\approx\\sum_{n=1}^{N}W_{n}f(\\mu_{n})$ 能在整个球面上精确地积分 $f(\\mu)=1$。\n3) 考虑 $N=3$ 的特例。计算在 $\\mu\\in[-1,1]$ 上的Gauss–Legendre节点 $\\{\\mu_{n}\\}_{n=1}^{3}$ 和相应的一维权重 $\\{w_{n}\\}_{n=1}^{3}$，然后根据第 (2) 部分的结果计算映射的立体角权重 $\\{W_{n}\\}_{n=1}^{3}$。将节点按 $\\mu_{1}<\\mu_{2}<\\mu_{3}$ 的递增顺序排列，并报告最终的有序行向量 $\\big[W_{1}\\;\\;W_{2}\\;\\;W_{3}\\big]$。\n\n答案规格：\n- 提供精确表达式；不要近似 $\\pi$。\n- 最终权重以球面度为单位表示。\n- 你的最终答案必须是单一的行向量 $\\big[W_{1}\\;\\;W_{2}\\;\\;W_{3}\\big]$，形式为封闭解，不得有任何四舍五入。", "solution": "所述问题提法恰当，有科学依据，并包含了获得唯一解所需的所有信息。我们直接进行推导和计算。\n\n问题分为三个部分，我们将依次解决。\n\n1) 轴对称立体角积分表示及其归一化的推导。\n\n仅依赖于方向余弦 $\\mu = \\cos\\theta$ 的函数 $f(\\mu)$ 的立体角积分由下式给出：\n$$\n\\int_{4\\pi} f(\\mu) \\, d\\Omega\n$$\n其中 $d\\Omega = \\sin\\theta \\, d\\theta \\, d\\phi$ 是球坐标系中的立体角微分元。角度范围为 $\\theta \\in [0, \\pi]$ 和 $\\phi \\in [0, 2\\pi)$。代入 $d\\Omega$ 的表达式，积分为：\n$$\n\\int_{0}^{2\\pi} \\int_{0}^{\\pi} f(\\cos\\theta) \\sin\\theta \\, d\\theta \\, d\\phi\n$$\n由于被积函数 $f(\\cos\\theta)$ 与方位角 $\\phi$ 无关，因此可以先直接对 $\\phi$ 进行积分：\n$$\n\\int_{0}^{2\\pi} d\\phi = 2\\pi\n$$\n这使得我们只剩下一个关于极角 $\\theta$ 的一维积分：\n$$\n\\int_{4\\pi} f(\\mu) \\, d\\Omega = 2\\pi \\int_{0}^{\\pi} f(\\cos\\theta) \\sin\\theta \\, d\\theta\n$$\n现在我们进行从 $\\theta$到 $\\mu = \\cos\\theta$ 的变量代换。其微分为 $d\\mu = -\\sin\\theta \\, d\\theta$。积分限也必须进行变换：\n- 当 $\\theta = 0$ 时, $\\mu = \\cos(0) = 1$。\n- 当 $\\theta = \\pi$ 时, $\\mu = \\cos(\\pi) = -1$。\n\n将这些代入积分，我们得到：\n$$\n2\\pi \\int_{1}^{-1} f(\\mu) (-d\\mu) = 2\\pi \\int_{-1}^{1} f(\\mu) \\, d\\mu\n$$\n这就是全立体角积分的轴对称表示。\n\n对于归一化条件，我们考虑常值函数 $f(\\mu) = 1$。在整个球面上的积分必须得到总立体角 $4\\pi$ 球面度。使用我们推导的公式：\n$$\n\\int_{4\\pi} 1 \\, d\\Omega = 2\\pi \\int_{-1}^{1} 1 \\, d\\mu = 2\\pi \\left[ \\mu \\right]_{-1}^{1} = 2\\pi (1 - (-1)) = 2\\pi(2) = 4\\pi\n$$\n结果正确，从而验证了所推导的公式和归一化。\n\n2) 立体角求积权重 $W_{n}$ 的确定。\n\n问题提出使用一个 $N$ 点求积来近似立体角积分：\n$$\n\\int_{4\\pi} f(\\mu) \\, d\\Omega \\approx \\sum_{n=1}^{N} W_{n} f(\\mu_{n})\n$$\n使用第 (1) 部分的结果，我们有精确关系：\n$$\n\\int_{4\\pi} f(\\mu) \\, d\\Omega = 2\\pi \\int_{-1}^{1} f(\\mu) \\, d\\mu\n$$\n右侧的积分将通过在区间 $[-1, 1]$ 上由节点 $\\{\\mu_n\\}$ 和权重 $\\{w_n\\}$ 定义的 $N$ 点Gauss-Legendre求积来近似：\n$$\n\\int_{-1}^{1} g(\\mu) \\, d\\mu \\approx \\sum_{n=1}^{N} w_{n} g(\\mu_{n})\n$$\n将此应用于我们的函数 $f(\\mu)$，我们得到近似：\n$$\n2\\pi \\int_{-1}^{1} f(\\mu) \\, d\\mu \\approx 2\\pi \\sum_{n=1}^{N} w_{n} f(\\mu_{n})\n$$\n通过比较立体角积分的两个求积公式，\n$$\n\\sum_{n=1}^{N} W_{n} f(\\mu_{n}) \\approx 2\\pi \\sum_{n=1}^{N} w_{n} f(\\mu_{n})\n$$\n并要求此关系对任何足够光滑的函数 $f(\\mu)$ 都成立，我们可以确定每一项 $f(\\mu_n)$ 的系数：\n$$\nW_{n} = 2\\pi w_{n}\n$$\n这给出了用标准一维Gauss-Legendre权重 $w_n$ 表示的立体角权重 $W_n$。为了验证这一点，我们检查该求积是否能精确积分 $f(\\mu) = 1$。对于 $f(\\mu)=1$，求积和为 $\\sum_{n=1}^{N} W_n$。为了精确，这个和必须等于 $4\\pi$。\n$$\n\\sum_{n=1}^{N} W_{n} = \\sum_{n=1}^{N} 2\\pi w_{n} = 2\\pi \\sum_{n=1}^{N} w_{n}\n$$\nGauss-Legendre求积的一个基本性质是，它可以精确地积分最高为 $2N-1$ 次的多项式。对于 $N \\ge 1$，这包括常值函数（0次多项式）。因此，权重的和是精确的：\n$$\n\\sum_{n=1}^{N} w_{n} = \\int_{-1}^{1} 1 \\, d\\mu = 2\n$$\n将此代入 $W_n$ 的和的表达式中：\n$$\n\\sum_{n=1}^{N} W_{n} = 2\\pi (2) = 4\\pi\n$$\n条件得到满足。因此关系式 $W_n = 2\\pi w_n$ 是正确的。\n\n3) 对于 $N=3$ 的计算。\n\n对于 $N=3$，Gauss-Legendre求积节点 $\\{\\mu_n\\}$ 是3次Legendre多项式 $P_3(\\mu)$ 的根。Legendre多项式由递推关系 $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$ 定义，其中 $P_0(x)=1$ 和 $P_1(x)=x$。这给出：\n$$\nP_3(\\mu) = \\frac{1}{2}(5\\mu^3 - 3\\mu)\n$$\n通过令 $P_3(\\mu) = 0$ 来求根：\n$$\n\\frac{1}{2}\\mu(5\\mu^2 - 3) = 0\n$$\n这得到的根为 $\\mu = 0$ 和 $\\mu = \\pm\\sqrt{\\frac{3}{5}}$。按递增顺序排列，节点为：\n$$\n\\mu_1 = -\\sqrt{\\frac{3}{5}}, \\quad \\mu_2 = 0, \\quad \\mu_3 = \\sqrt{\\frac{3}{5}}\n$$\n相应的权重 $\\{w_n\\}$ 由公式 $w_n = \\frac{2}{(1-\\mu_n^2)[P_N'(\\mu_n)]^2}$ 给出。对于 $N=3$，我们需要 $P_3(\\mu)$ 的导数：\n$$\nP_3'(\\mu) = \\frac{d}{d\\mu}\\left(\\frac{1}{2}(5\\mu^3 - 3\\mu)\\right) = \\frac{1}{2}(15\\mu^2 - 3)\n$$\n现在我们计算权重：\n对于节点 $\\mu_1 = -\\sqrt{3/5}$ 和 $\\mu_3 = \\sqrt{3/5}$，我们有 $\\mu_{1,3}^2 = 3/5$。\n$$\nP_3'(\\mu_{1,3}) = \\frac{1}{2}\\left(15\\left(\\frac{3}{5}\\right) - 3\\right) = \\frac{1}{2}(9-3) = 3\n$$\n权重是：\n$$\nw_1 = w_3 = \\frac{2}{(1 - 3/5)[3]^2} = \\frac{2}{(2/5)(9)} = \\frac{10}{18} = \\frac{5}{9}\n$$\n对于节点 $\\mu_2 = 0$：\n$$\nP_3'(\\mu_2) = \\frac{1}{2}(15(0)^2 - 3) = -\\frac{3}{2}\n$$\n权重是：\n$$\nw_2 = \\frac{2}{(1 - 0^2)[-3/2]^2} = \\frac{2}{9/4} = \\frac{8}{9}\n$$\n一维权重为 $\\{w_1, w_2, w_3\\} = \\{5/9, 8/9, 5/9\\}$。\n\n最后，我们使用关系式 $W_n = 2\\pi w_n$ 计算立体角权重 $\\{W_n\\}$。它们的单位是球面度。\n$$\nW_1 = 2\\pi w_1 = 2\\pi \\left(\\frac{5}{9}\\right) = \\frac{10\\pi}{9}\n$$\n$$\nW_2 = 2\\pi w_2 = 2\\pi \\left(\\frac{8}{9}\\right) = \\frac{16\\pi}{9}\n$$\n$$\nW_3 = 2\\pi w_3 = 2\\pi \\left(\\frac{5}{9}\\right) = \\frac{10\\pi}{9}\n$$\n最终答案是这些权重的有序行向量。\n$$\n\\begin{pmatrix} W_1 & W_2 & W_3 \\end{pmatrix} = \\begin{pmatrix} \\frac{10\\pi}{9} & \\frac{16\\pi}{9} & \\frac{10\\pi}{9} \\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{10\\pi}{9} & \\frac{16\\pi}{9} & \\frac{10\\pi}{9} \\end{pmatrix}}\n$$", "id": "2528233"}, {"introduction": "当辐射传递方程在空间和角度上被离散化后，挑战就转变为求解由此产生的大型代数方程组。离散坐标法采用一种高效的“扫描” (sweep) 算法，沿着辐射传播的方向逐个单元求解辐射强度。本实践将深入探讨扫描算法的内在逻辑，要求您将为非结构化网格创建有效扫描顺序的任务，视为一个拓扑排序问题来解决。掌握这一概念对于理解 DOM 求解器的实现原理，以及为何其能有效处理复杂几何形状至关重要。[@problem_id:2528194]", "problem": "您需要实现一个程序，用于在非结构化二维网格上为辐射传热中的离散纵标法 (DOM) 构建扫描序列。该序列必须通过对迁移项所引起的单元依赖关系进行拓扑排序，从而遵循给定离散方向的迎风格式。\n\n从给定离散方向（由单位向量 $\\hat{\\boldsymbol{s}} \\in \\mathbb{R}^2$ 表示）的稳态辐射传输方程 (RTE) 的迁移项开始：\n$$\n\\hat{\\boldsymbol{s}} \\cdot \\nabla I(\\boldsymbol{x}, \\hat{\\boldsymbol{s}}) + \\kappa I(\\boldsymbol{x}, \\hat{\\boldsymbol{s}}) = S(\\boldsymbol{x}, \\hat{\\boldsymbol{s}}),\n$$\n其中 $I$ 是辐射强度，$\\kappa$ 是吸收系数，$S$ 是源项。在对单元 $\\{ \\mathcal{C}_i \\}_{i=0}^{N-1}$ 进行有限体积离散化时，每个面 $f \\in \\mathcal{F}_i$ 具有外向面法向量 $\\boldsymbol{n}_{i,f}$，迁移项采用迎风格式处理：对于单元 $i$ 的每个面 $f$，如果 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < 0$ 且该面是与相邻单元 $j$ 共享的内部面，则单元 $i$ 中的值依赖于穿过该面的迎风邻居 $j$ 中的值。如果该面是边界面且 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < 0$，则入流边界强度是已知的，不产生依赖关系。$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} > 0$ 的面对于单元 $i$ 是出流面，无依赖关系。$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} = 0$ 的面是切向面，在排序时可视为无耦合。\n\n在单元上定义一个有向图，其顶点为 $\\{0,1,\\dots,N-1\\}$。对于每个单元 $i$ 和每个面 $f \\in \\mathcal{F}_i$：\n- 如果该面是与邻居 $j$ 共享的内部面且 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < 0$，则添加一条有向边 $j \\to i$。\n- 如果该面是边界面且 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < 0$，则不添加边（边界入流已知）。\n- 如果 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} \\ge 0$，则不添加边。\n\n那么，扫描序列就是此有向无环图的任意一种拓扑排序，该排序将每个单元列在其所有迎风依赖项（前驱）之后。为确保当多个单元同时符合条件时行为的确定性，通过递增的投影中心坐标 $t_i = \\boldsymbol{x}_i \\cdot \\hat{\\boldsymbol{s}}$ 来处理并列情况；如果仍然存在并列，则通过递增的单元标识符 $i$ 来处理。\n\n实现上述逻辑，并为以下三个测试用例计算扫描序列。在每个用例中，网格由以下内容指定：\n- 一组单元标识符。\n- 单元中心坐标 $\\boldsymbol{x}_i \\in \\mathbb{R}^2$。\n- 对于每个单元 $i$，一个面列表。每个面由一个外向法向量 $\\boldsymbol{n}_{i,f} \\in \\mathbb{R}^2$ 和一个相邻单元标识符 $j$（内部面）或表示边界面​​的值 $\\varnothing$ 给出。\n\n使用以下测试套件。所有向量分量都是无量纲的，并以实数形式给出。离散方向向量的分量也以实数形式给出。您必须使用严格容差 $\\varepsilon = 10^{-12}$ 来处理切向条件：一个面被视为入流面，当且仅当 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < -\\varepsilon$；被视为出流面，当且仅当 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} > \\varepsilon$；否则为切向（无依赖关系）。用于处理并列情况的投影使用 $t_i = \\boldsymbol{x}_i \\cdot \\hat{\\boldsymbol{s}}$。\n\n测试用例 1（结构化 $2 \\times 2$ 网格，向右扫描）：\n- 单元和中心点：\n  - $0$: $\\boldsymbol{x}_0 = (0.5, 0.5)$\n  - $1$: $\\boldsymbol{x}_1 = (1.5, 0.5)$\n  - $2$: $\\boldsymbol{x}_2 = (0.5, 1.5)$\n  - $3$: $\\boldsymbol{x}_3 = (1.5, 1.5)$\n- 每个单元的面（每个条目是 $(\\boldsymbol{n}_{i,f}, \\text{neighbor})$，其中 neighbor $\\in \\{0,1,2,3\\}$ 或 $\\varnothing$）：\n  - 单元 $0$: $[ ((-1,0), \\varnothing),\\ ((+1,0), 1),\\ ((0,-1), \\varnothing),\\ ((0,+1), 2) ]$\n  - 单元 $1$: $[ ((-1,0), 0),\\ ((+1,0), \\varnothing),\\ ((0,-1), \\varnothing),\\ ((0,+1), 3) ]$\n  - 单元 $2$: $[ ((-1,0), \\varnothing),\\ ((+1,0), 3),\\ ((0,-1), 0),\\ ((0,+1), \\varnothing) ]$\n  - 单元 $3$: $[ ((-1,0), 2),\\ ((+1,0), \\varnothing),\\ ((0,-1), 1),\\ ((0,+1), \\varnothing) ]$\n- 方向：$\\hat{\\boldsymbol{s}} = (1, 0)$\n\n测试用例 2（非结构化三角形链，对角扫描）：\n- 单元和中心点：\n  - $0$: $\\boldsymbol{x}_0 = (0.0, 0.0)$\n  - $1$: $\\boldsymbol{x}_1 = (1.0, 1.0)$\n  - $2$: $\\boldsymbol{x}_2 = (2.0, 2.0)$\n- 每个单元的面：\n  - 单元 $0$: $[ ((+1,+1), 1),\\ ((-1,0), \\varnothing),\\ ((0,-1), \\varnothing) ]$\n  - 单元 $1$: $[ ((-1,-1), 0),\\ ((+1,+1), 2),\\ ((-1,+1), \\varnothing) ]$\n  - 单元 $2$: $[ ((-1,-1), 1),\\ ((+1,0), \\varnothing),\\ ((0,+1), \\varnothing) ]$\n- 方向：$\\hat{\\boldsymbol{s}} = (1, 1)$\n\n测试用例 3（切向内部面，向上扫描）：\n- 单元和中心点：\n  - $0$: $\\boldsymbol{x}_0 = (0.5, 0.5)$\n  - $1$: $\\boldsymbol{x}_1 = (1.5, 0.5)$\n- 每个单元的面：\n  - 单元 $0$: $[ ((-1,0), \\varnothing),\\ ((+1,0), 1),\\ ((0,-1), \\varnothing),\\ ((0,+1), \\varnothing) ]$\n  - 单元 $1$: $[ ((-1,0), 0),\\ ((+1,0), \\varnothing),\\ ((0,-1), \\varnothing),\\ ((0,+1), \\varnothing) ]$\n- 方向：$\\hat{\\boldsymbol{s}} = (0, 1)$\n\n您的程序必须：\n- 为每个测试用例构建如上定义的有向依赖图。\n- 计算一个遵循依赖关系的拓扑顺序。当任何步骤中有多个单元的入度为零时，选择具有最小 $t_i = \\boldsymbol{x}_i \\cdot \\hat{\\boldsymbol{s}}$ 的单元；如果仍然并列，则选择最小的标识符 $i$。\n- 以整数列表的形式输出每个测试用例的扫描顺序。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个表示扫描顺序中单元标识符的整数列表。例如，格式必须与 $[[\\dots],[\\dots],[\\dots]]$ 完全一样，各项之间用逗号分隔，且无附加文本。\n\n预期的输出数据类型是整数列表。此问题中无需报告物理单位。未使用角度；所有方向都通过其向量分量指定。输出中的所有数字都应为对应于单元标识符的整数。", "solution": "所提出的问题是输运现象计算方法领域中一个适定的标准任务。它要求为应用于辐射传输方程 (RTE) 的离散纵标法 (DOM) 构建一个扫描序列。扫描序列是计算单元的一种特定排序，它遵循信息流，这是一个由迎风原理决定的概念。该序列等效于表示单元依赖关系的有向图的拓扑排序。\n\n控制方程是在特定离散方向 $\\hat{\\boldsymbol{s}}$ 下的二维稳态 RTE：\n$$\n\\hat{\\boldsymbol{s}} \\cdot \\nabla I(\\boldsymbol{x}, \\hat{\\boldsymbol{s}}) + \\kappa I(\\boldsymbol{x}, \\hat{\\boldsymbol{s}}) = S(\\boldsymbol{x}, \\hat{\\boldsymbol{s}})\n$$\n在有限体积离散化中，单元 $\\mathcal{C}_i$ 中的强度 $I$ 与其邻居耦合。这种耦合的方向由方向向量 $\\hat{\\boldsymbol{s}}$ 和单元 $\\mathcal{C}_i$ 的面 $f$ 的外向法向量 $\\boldsymbol{n}_{i,f}$ 的点积的符号决定。如果 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < 0$，该面是一个入流面，对单元 $\\mathcal{C}_i$ 的计算依赖于来自单元外部的信息。如果这个面与相邻单元 $\\mathcal{C}_j$ 共享，则单元 $\\mathcal{C}_i$ 依赖于单元 $\\mathcal{C}_j$。这就建立了一个有向依赖关系 $j \\to i$。\n\n该问题要求实现一个特定算法来确定这个扫描顺序，该算法是 Kahn 拓扑排序算法的一个变种。其过程如下：\n\n1.  **依赖图构建**：对于给定的网格和方向 $\\hat{\\boldsymbol{s}}$，构建一个有向图 $G = (V, E)$。顶点 $V$ 是单元标识符 $\\{0, 1, \\dots, N-1\\}$。当且仅当单元 $\\mathcal{C}_i$ 与邻居 $\\mathcal{C}_j$ 共享一个内部面，并且满足条件 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f} < -\\varepsilon$ 时，才向边集 $E$ 中添加一条有向边 $j \\to i$，其中 $\\boldsymbol{n}_{i,f}$ 是从单元 $\\mathcal{C}_i$ 在该面上的外向法线，$\\varepsilon = 10^{-12}$ 是指定的数值容差。\n\n2.  **拓扑排序**：计算拓扑排序。该算法迭代进行：\n    a. 计算所有顶点（单元）的入度。\n    b. 维护一个入度为零的顶点队列。这些是准备好处理的单元。\n    c. 当队列中有多个单元时，必须应用确定性的并列处理规则。选择具有最小投影中心坐标 $t_i = \\boldsymbol{x}_i \\cdot \\hat{\\boldsymbol{s}}$ 的单元。如果仍然并列，则选择具有最小数值标识符 $i$ 的单元。\n    d. 将所选单元从队列中移除并添加到最终的排序列表中。\n    e. 将其在图中的所有后继单元的入度减一。如果任何后继单元的入度变为零，则将其添加到队列中。\n    f. 重复此过程，直到队列为空。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1：结构化 $2 \\times 2$ 网格，$\\hat{\\boldsymbol{s}} = (1, 0)$**\n\n单元为 $\\{0, 1, 2, 3\\}$。方向向量为 $\\hat{\\boldsymbol{s}} = (1, 0)$。用于处理并列情况的投影是 $t_i = \\boldsymbol{x}_i \\cdot \\hat{\\boldsymbol{s}}$：\n- $t_0 = (0.5, 0.5) \\cdot (1, 0) = 0.5$\n- $t_1 = (1.5, 0.5) \\cdot (1, 0) = 1.5$\n- $t_2 = (0.5, 1.5) \\cdot (1, 0) = 0.5$\n- $t_3 = (1.5, 1.5) \\cdot (1, 0) = 1.5$\n\n点积 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f}$ 决定了依赖关系：\n- 对于单元 $1$，与邻居 $0$ 的面：法向量为 $\\boldsymbol{n}_{1,f}=(-1, 0)$。$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{1,f} = (1,0) \\cdot (-1,0) = -1 < -\\varepsilon$。这产生了一个依赖关系 $0 \\to 1$。\n- 对于单元 $3$，与邻居 $2$ 的面：法向量为 $\\boldsymbol{n}_{3,f}=(-1, 0)$。$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{3,f} = (1,0) \\cdot (-1,0) = -1 < -\\varepsilon$。这产生了一个依赖关系 $2 \\to 3$。\n- 所有其他内部面的法向量都与 $\\hat{\\boldsymbol{s}}$ 正交，导致点积为零，这被视为切向（无依赖关系）。\n\n生成的图有边 $\\{0 \\to 1, 2 \\to 3\\}$。初始入度为：$ind(0)=0, ind(1)=1, ind(2)=0, ind(3)=1$。\n\n排序过程如下：\n1.  零入度单元的初始队列：$\\{0, 2\\}$。处理并列：$t_0 = 0.5$ 且 $t_2 = 0.5$。投影出现并列。次要并列处理规则是单元 ID：$0 < 2$。选择单元 $0$。扫描顺序：$[0]$。\n2.  处理单元 $0$。其后继单元 $1$ 的入度减为 $0$。可用单元的队列变为 $\\{1, 2\\}$。\n3.  在单元 $1$ 和 $2$ 之间选择。处理并列：$t_1 = 1.5, t_2 = 0.5$。由于 $t_2 < t_1$，选择单元 $2$。扫描顺序：$[0, 2]$。\n4.  处理单元 $2$。其后继单元 $3$ 的入度减为 $0$。队列变为 $\\{1, 3\\}$。\n5.  在单元 $1$ 和 $3$ 之间选择。处理并列：$t_1 = 1.5, t_3 = 1.5$。投影出现并列。次要并列处理规则：$1 < 3$。选择单元 $1$。扫描顺序：$[0, 2, 1]$。\n6.  唯一剩下的单元是 $3$。选择它。扫描顺序：$[0, 2, 1, 3]$。\n\n测试用例 1 的最终扫描顺序是 $[0, 2, 1, 3]$。\n\n**测试用例 2：非结构化三角形链，$\\hat{\\boldsymbol{s}} = (1, 1)$**\n\n单元为 $\\{0, 1, 2\\}$。方向向量为 $\\hat{\\boldsymbol{s}} = (1, 1)$。用于处理并列情况的投影是：\n- $t_0 = (0, 0) \\cdot (1, 1) = 0$\n- $t_1 = (1, 1) \\cdot (1, 1) = 2$\n- $t_2 = (2, 2) \\cdot (1, 1) = 4$\n\n依赖关系由 $\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{i,f}$ 决定：\n- 对于单元 $1$，与邻居 $0$ 的面：法向量为 $\\boldsymbol{n}_{1,f}=(-1, -1)$。$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{1,f} = (1,1) \\cdot (-1,-1) = -2 < -\\varepsilon$。依赖关系 $0 \\to 1$。\n- 对于单元 $2$，与邻居 $1$ 的面：法向量为 $\\boldsymbol{n}_{2,f}=(-1, -1)$。$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{2,f} = (1,1) \\cdot (-1,-1) = -2 < -\\varepsilon$。依赖关系 $1 \\to 2$。\n- 其他面要么是出流、切向，要么是边界入流，不产生依赖关系。\n\n该图是一个简单的链：$0 \\to 1 \\to 2$。初始入度为：$ind(0)=0, ind(1)=1, ind(2)=1$。\n\n排序过程很直接，因为从没有多个选择：\n1.  初始队列：$\\{0\\}$。选择 $0$。扫描顺序：$[0]$。\n2.  单元 $1$ 的入度变为 $0$。队列：$\\{1\\}$。选择 $1$。扫描顺序：$[0, 1]$。\n3.  单元 $2$ 的入度变为 $0$。队列：$\\{2\\}$。选择 $2$。扫描顺序：$[0, 1, 2]$。\n\n测试用例 2 的最终扫描顺序是 $[0, 1, 2]$。\n\n**测试用例 3：切向内部面，$\\hat{\\boldsymbol{s}} = (0, 1)$**\n\n单元为 $\\{0, 1\\}$。方向向量为 $\\hat{\\boldsymbol{s}} = (0, 1)$。用于处理并列情况的投影是：\n- $t_0 = (0.5, 0.5) \\cdot (0, 1) = 0.5$\n- $t_1 = (1.5, 0.5) \\cdot (0, 1) = 0.5$\n\n单元 $0$ 和 $1$ 之间的面，对于单元 $0$ 的法向量为 $\\boldsymbol{n}_{0,f}=(+1,0)$，对于单元 $1$ 的法向量为 $\\boldsymbol{n}_{1,f}=(-1,0)$。\n- 对于单元 $0$：$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{0,f} = (0,1) \\cdot (1,0) = 0$。\n- 对于单元 $1$：$\\hat{\\boldsymbol{s}} \\cdot \\boldsymbol{n}_{1,f} = (0,1) \\cdot (-1,0) = 0$。\n两个点积都为 $0$，落在切向容差 $[-\\varepsilon, +\\varepsilon]$ 内。因此，这个面不产生依赖关系。所有其他面要么是边界入流，要么是出流。最终的依赖图没有边。\n\n初始入度为 $ind(0)=0$ 和 $ind(1)=0$。\n\n排序过程如下：\n1.  初始队列：$\\{0, 1\\}$。处理并列：$t_0 = 0.5$ 且 $t_1 = 0.5$。投影并列。次要并列处理规则（单元 ID）：$0 < 1$。选择单元 $0$。扫描顺序：$[0]$。\n2.  队列现在只包含单元 $1$。选择它。扫描顺序：$[0, 1]$。\n\n测试用例 3 的最终扫描顺序是 $[0, 1]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sweep_schedule(cells, faces_per_cell, direction_vector, tolerance):\n    \"\"\"\n    Constructs a sweep schedule for the Discrete Ordinates Method.\n\n    This involves building a dependency graph based on upwinding rules for a given\n    sweep direction and then performing a topological sort on that graph with\n    specific tie-breaking rules.\n    \"\"\"\n    num_cells = len(cells)\n    cell_ids = sorted(cells.keys())\n    \n    # Use numpy arrays for vector operations\n    cell_centers = {cid: np.array(c) for cid, c in cells.items()}\n    s_vec = np.array(direction_vector)\n    \n    # 1. Calculate tie-breaking projections\n    projections = {cid: np.dot(cell_centers[cid], s_vec) for cid in cell_ids}\n    \n    # 2. Build the dependency graph\n    # Adjacency list: adj[j] contains list of cells i that depend on j (j -> i)\n    adj = {cid: [] for cid in cell_ids}\n    # In-degree for each cell\n    in_degrees = {cid: 0 for cid in cell_ids}\n    \n    for i in cell_ids:\n        for face_normal, neighbor_j in faces_per_cell[i]:\n            # A dependency j -> i is created if cell i has an inflow face\n            # from an internal neighbor j.\n            \n            # Boundary faces have neighbor_j as None and create no dependencies\n            if neighbor_j is None:\n                continue\n            \n            n_vec = np.array(face_normal)\n            dot_product = np.dot(s_vec, n_vec)\n            \n            # Inflow condition: s . n_i,f < -epsilon.\n            # Normal n_i,f is for cell i, neighbor is j.\n            # This means information flows from j to i. Add edge j -> i.\n            if dot_product < -tolerance:\n                adj[neighbor_j].append(i)\n                in_degrees[i] += 1\n                \n    # 3. Perform topological sort (Kahn's algorithm)\n    # The queue contains all cells with an in-degree of 0.\n    queue = [cid for cid in cell_ids if in_degrees[cid] == 0]\n    \n    sorted_order = []\n    \n    while queue:\n        # Sort the queue to apply tie-breaking rules:\n        # 1. Minimum projected coordinate t_i\n        # 2. Minimum cell identifier i\n        queue.sort(key=lambda cid: (projections[cid], cid))\n        \n        # Dequeue the cell with the highest priority (first in sorted list)\n        u = queue.pop(0)\n        sorted_order.append(u)\n        \n        # For each neighbor v of u, update in-degrees\n        # Graph stores u -> v, so v is a successor of u\n        for v in adj[u]:\n            in_degrees[v] -= 1\n            if in_degrees[v] == 0:\n                queue.append(v)\n                \n    # The graph must be a DAG, so the sort should include all cells.\n    if len(sorted_order) != num_cells:\n        # This should not occur for valid DOM sweep problems.\n        raise ValueError(\"The dependency graph contains a cycle.\")\n        \n    return sorted_order\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the sweep schedule for each.\n    \"\"\"\n    \n    # Define the tolerance for tangential flow\n    epsilon = 1e-12\n\n    # Test Case 1\n    cells_1 = {\n        0: (0.5, 0.5), 1: (1.5, 0.5),\n        2: (0.5, 1.5), 3: (1.5, 1.5)\n    }\n    faces_1 = {\n        0: [ ((-1.0, 0.0), None), ((1.0, 0.0), 1), ((0.0, -1.0), None), ((0.0, 1.0), 2) ],\n        1: [ ((-1.0, 0.0), 0),   ((1.0, 0.0), None),((0.0, -1.0), None), ((0.0, 1.0), 3) ],\n        2: [ ((-1.0, 0.0), None), ((1.0, 0.0), 3), ((0.0, -1.0), 0),   ((0.0, 1.0), None) ],\n        3: [ ((-1.0, 0.0), 2),   ((1.0, 0.0), None),((0.0, -1.0), 1),   ((0.0, 1.0), None) ]\n    }\n    direction_1 = (1.0, 0.0)\n\n    # Test Case 2\n    cells_2 = {\n        0: (0.0, 0.0), 1: (1.0, 1.0), 2: (2.0, 2.0)\n    }\n    faces_2 = {\n        0: [ ((1.0, 1.0), 1), ((-1.0, 0.0), None), ((0.0, -1.0), None) ],\n        1: [ ((-1.0, -1.0), 0), ((1.0, 1.0), 2), ((-1.0, 1.0), None) ],\n        2: [ ((-1.0, -1.0), 1), ((1.0, 0.0), None), ((0.0, 1.0), None) ]\n    }\n    direction_2 = (1.0, 1.0)\n    \n    # Test Case 3\n    cells_3 = {\n        0: (0.5, 0.5), 1: (1.5, 0.5)\n    }\n    faces_3 = {\n        0: [ ((-1.0, 0.0), None), ((1.0, 0.0), 1), ((0.0, -1.0), None), ((0.0, 1.0), None) ],\n        1: [ ((-1.0, 0.0), 0), ((1.0, 0.0), None), ((0.0, -1.0), None), ((0.0, 1.0), None) ]\n    }\n    direction_3 = (0.0, 1.0)\n    \n    test_cases = [\n        (cells_1, faces_1, direction_1),\n        (cells_2, faces_2, direction_2),\n        (cells_3, faces_3, direction_3)\n    ]\n\n    results = []\n    for cells, faces, direction in test_cases:\n        result = compute_sweep_schedule(cells, faces, direction, epsilon)\n        results.append(result)\n\n    # Format output as a string representation of a list of lists.\n    # e.g., [[0, 2, 1, 3],[0, 1, 2],[0, 1]]\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Remove spaces for exact format matching\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "2528194"}, {"introduction": "一个正确实现的数值求解器必须能够证明，它能以预期的理论收敛阶数收敛到控制方程的真实解。本实践介绍了“人造解方法” (Method of Manufactured Solutions, MMS)，这是一种用于代码验证的严谨且标准的程序。您将首先为人造一个非平凡的强度解析解，然后推导使其成为辐射传递方程 (RTE) 精确解的对应源项，并最终使用这个人造解作为基准，来数值地验证您的离散化格式的精度阶数。这一过程对于建立任何科学模拟代码的可信度都是至关重要的。[@problem_id:2528240]", "problem": "考虑一个非散射、非发射、吸收介质中的稳态、灰体辐射传输方程（Radiative Transfer Equation (RTE)），该介质位于一个单连通域中，并且在构造人造残差的公式中不涉及边界：\n$$\\mathbf{s}\\cdot\\nabla I(\\mathbf{x},\\mathbf{s}) + \\beta I(\\mathbf{x},\\mathbf{s}) = S(\\mathbf{x},\\mathbf{s}),$$\n其中 $I(\\mathbf{x},\\mathbf{s})$ 是单位球面上方向 $\\mathbf{s}$ 的辐射强度，$\\beta$ 是一个常数消光系数，$S$ 是一个我们将通过人造解法构造的体积源。请使用无量纲单位（即，不需要物理单位），并以弧度作为角度单位。\n\n您需要构造一个人造解，并从上述 RTE 出发，仅使用基本定义和代数方法，推导出相应的源项 $S(\\mathbf{x},\\mathbf{s})$。设人造解在空间和角度上是可分离的：\n$$I(\\mathbf{x},\\mathbf{s}) = F(\\mathbf{x})\\,G(\\mu),\\quad \\mathbf{x}=(x,y,z)\\in[0,1]^3,\\quad \\mu=\\cos\\theta=s_z,$$\n其中\n$$F(\\mathbf{x})=\\sin(\\pi x)\\,\\cos(\\pi y)\\,e^{z},\\qquad G(\\mu)=1+c\\,\\mu^4,$$\n且常数消光系数 $\\beta>0$。这里 $\\theta$ 是相对于 $z$ 轴的极角，因此 $\\mu=s_z$ 是方向向量 $\\mathbf{s}=(s_x,s_y,s_z)$ 的 $z$ 分量。\n\n任务：\n1) 从上述稳态、灰体 RTE 出发，推导与给定人造解 $I(\\mathbf{x},\\mathbf{s})$ 对应的源项 $S(\\mathbf{x},\\mathbf{s})$，用 $F$、其空间导数、$G$、$\\mathbf{s}$ 和 $\\beta$ 表示。您的推导必须从 RTE 的基本定义开始，并应用乘法法则；不要借助任何预先推导的人造源项公式。\n\n2) 定义标量通量\n$$\\phi(\\mathbf{x})=\\int_{4\\pi} I(\\mathbf{x},\\mathbf{s})\\,\\mathrm{d}\\Omega,$$\n并通过显式计算角度积分，求得其对于上述 $I(\\mathbf{x},\\mathbf{s})$ 的精确解析表达式。\n\n3) 为验证空间和角度的精度阶，请在单个程序中实现以下计算测试，并报告所要求的输出。所有角度必须用弧度表示，所有输出均为无量纲实数。\n\n- 空间离散导数精度测试（二阶中心差分）：\n  - 将输运方向固定为单位向量\n    $$\\mathbf{s}_0=\\dfrac{(0.7,-0.2,0.68)}{\\|(0.7,-0.2,0.68)\\|_2}.$$\n  - 在 $[0,1]^3$ 上使用均匀笛卡尔网格，每个坐标方向有 $N\\in\\{21,41\\}$ 个点，网格间距为 $h=1/(N-1)$。\n  - 在内部网格节点（沿每个轴的索引从 $1$ 到 $N-2$），通过对人造解 $I(\\mathbf{x},\\mathbf{s}_0)$ 应用二阶中心差分来近似迁移项 $\\mathbf{s}_0\\cdot\\nabla I$：\n    $$D_h[I](\\mathbf{x}_{i,j,k};\\mathbf{s}_0)=s_{0x}\\,\\dfrac{I_{i+1,j,k}-I_{i-1,j,k}}{2h}+s_{0y}\\,\\dfrac{I_{i,j+1,k}-I_{i,j-1,k}}{2h}+s_{0z}\\,\\dfrac{I_{i,j,k+1}-I_{i,j,k-1}}{2h}.$$\n  - 在内部节点上构造离散残差\n    $$R_h(\\mathbf{x}_{i,j,k}) = D_h[I](\\mathbf{x}_{i,j,k};\\mathbf{s}_0)+\\beta\\,I(\\mathbf{x}_{i,j,k},\\mathbf{s}_0)-S(\\mathbf{x}_{i,j,k},\\mathbf{s}_0),$$\n    其中 $S$ 是任务 $1$ 中得到的精确人造源项。\n  - 报告内部节点上的离散 $\\ell^2$ 误差，\n    $$E_h=\\left(\\dfrac{1}{M}\\sum_{\\text{interior}} R_h^2\\right)^{1/2},$$\n    其中 $M$ 是内部节点的数量。计算 $N=21$ 和 $N=41$ 时的 $E_{h}$，以及观测阶\n    $$p=\\dfrac{\\log(E_{h,21}/E_{h,41})}{\\log(2)}.$$\n\n- 角度求积精度测试（单位球面上的张量积求积）：\n  - 在点 $\\mathbf{x}_0=(0.37,0.41,0.29)$ 处，使用张量积离散纵标求积（Discrete Ordinates Method (DOM)）来近似标量通量：\n    $$\\phi_{N_\\mu,K_\\varphi}(\\mathbf{x}_0)=\\sum_{i=1}^{N_\\mu}\\sum_{j=1}^{K_\\varphi} w_i\\,w^\\varphi_j\\, I\\!\\left(\\mathbf{x}_0,\\mathbf{s}(\\mu_i,\\varphi_j)\\right),$$\n    其中 $\\{(\\mu_i,w_i)\\}_{i=1}^{N_\\mu}$ 是 $[-1,1]$ 上的 Gauss-Legendre 点和权重，$\\{\\varphi_j\\}_{j=1}^{K_\\varphi}$ 是 $[0,2\\pi)$ 上等距分布的方位角，其梯形权重为 $w^\\varphi_j=2\\pi/K_\\varphi$，$\\mathbf{s}(\\mu,\\varphi)$ 是由极角余弦 $\\mu$ 和方位角 $\\varphi$ 定义的方向。\n  - 使用 $(N_\\mu,K_\\varphi)\\in\\{(2,8),(3,8)\\}$。\n  - 报告绝对角度求积误差\n    $$\\varepsilon_{2}=\\left|\\phi_{2,8}(\\mathbf{x}_0)-\\phi(\\mathbf{x}_0)\\right|,\\qquad \\varepsilon_{3}=\\left|\\phi_{3,8}(\\mathbf{x}_0)-\\phi(\\mathbf{x}_0)\\right|,$$\n    以及误差比 $\\varepsilon_{2}/\\max(\\varepsilon_{3},10^{-16})$ 以避免除以零。\n\n使用参数值 $c=0.3$ 和 $\\beta=0.7$。您的程序必须按指定顺序计算并输出以下所有六个量：\n- $N=21$ 时的 $E_{h}$，\n- $N=41$ 时的 $E_{h}$，\n- 观测阶 $p$，\n- $\\varepsilon_{2}$,\n- $\\varepsilon_{3}$,\n- 比率 $\\varepsilon_2/\\max(\\varepsilon_3,10^{-16})$。\n\n最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4,result5,result6]\"）。", "solution": "所述问题已经过验证，并被确认为有效。在数值辐射传输领域，这是一个适定的、有科学依据的、客观的问题表述。它信息完整、逻辑一致，并为获得唯一解提供了所有必要信息。我们继续进行推导和计算任务。\n\n控制方程是用于非散射、非发射、吸收介质的稳态、灰体辐射传输方程（RTE）：\n$$ \\mathbf{s}\\cdot\\nabla I(\\mathbf{x},\\mathbf{s}) + \\beta I(\\mathbf{x},\\mathbf{s}) = S(\\mathbf{x},\\mathbf{s}) $$\n指定的人造解为 $I(\\mathbf{x},\\mathbf{s}) = F(\\mathbf{x})G(\\mu)$，其中 $\\mathbf{x}=(x,y,z) \\in [0,1]^3$，$\\mu = \\cos\\theta = s_z$，$\\beta > 0$ 是一个常数，函数如下：\n$$ F(\\mathbf{x})=\\sin(\\pi x)\\cos(\\pi y)e^{z} $$\n$$ G(\\mu)=1+c\\mu^4 $$\n\n**1. 人造源项 $S(\\mathbf{x},\\mathbf{s})$ 的推导**\n\n人造解法要求将所选的 $I(\\mathbf{x},\\mathbf{s})$ 形式代入 RTE，并求解使人造解成为所得方程精确解的源项 $S(\\mathbf{x},\\mathbf{s})$。\n\n首先，我们必须计算迁移项 $\\mathbf{s}\\cdot\\nabla I$。我们对 $I = FG$ 应用梯度算子的乘法法则：\n$$ \\nabla I(\\mathbf{x},\\mathbf{s}) = \\nabla [F(\\mathbf{x})G(\\mu)] $$\n由于 $G(\\mu)$ 仅依赖于方向分量 $s_z$ 而不依赖于空间坐标 $\\mathbf{x}$，因此在空间梯度算子 $\\nabla$ 的作用下，它被视为常数。\n$$ \\nabla I(\\mathbf{x},\\mathbf{s}) = G(\\mu)\\nabla F(\\mathbf{x}) $$\n迁移项是方向向量 $\\mathbf{s}$ 与该梯度的点积：\n$$ \\mathbf{s}\\cdot\\nabla I(\\mathbf{x},\\mathbf{s}) = \\mathbf{s} \\cdot [G(\\mu)\\nabla F(\\mathbf{x})] = G(\\mu) [\\mathbf{s}\\cdot\\nabla F(\\mathbf{x})] $$\n现在，我们将此表达式代回 RTE：\n$$ G(\\mu)[\\mathbf{s}\\cdot\\nabla F(\\mathbf{x})] + \\beta [F(\\mathbf{x})G(\\mu)] = S(\\mathbf{x},\\mathbf{s}) $$\n提出公因子 $G(\\mu)$，得到人造源项的解析表达式：\n$$ S(\\mathbf{x},\\mathbf{s}) = G(\\mu) [\\mathbf{s}\\cdot\\nabla F(\\mathbf{x}) + \\beta F(\\mathbf{x})] $$\n为了得到显式形式，我们计算 $F(\\mathbf{x})$ 的梯度：\n$$ \\nabla F(\\mathbf{x}) = \\left( \\frac{\\partial F}{\\partial x}, \\frac{\\partial F}{\\partial y}, \\frac{\\partial F}{\\partial z} \\right) $$\n偏导数如下：\n$$ \\frac{\\partial F}{\\partial x} = \\frac{\\partial}{\\partial x} [\\sin(\\pi x)\\cos(\\pi y)e^{z}] = \\pi\\cos(\\pi x)\\cos(\\pi y)e^{z} $$\n$$ \\frac{\\partial F}{\\partial y} = \\frac{\\partial}{\\partial y} [\\sin(\\pi x)\\cos(\\pi y)e^{z}] = -\\pi\\sin(\\pi x)\\sin(\\pi y)e^{z} $$\n$$ \\frac{\\partial F}{\\partial z} = \\frac{\\partial}{\\partial z} [\\sin(\\pi x)\\cos(\\pi y)e^{z}] = \\sin(\\pi x)\\cos(\\pi y)e^{z} = F(\\mathbf{x}) $$\n点积 $\\mathbf{s}\\cdot\\nabla F(\\mathbf{x})$ 为：\n$$ \\mathbf{s}\\cdot\\nabla F(\\mathbf{x}) = s_x\\frac{\\partial F}{\\partial x} + s_y\\frac{\\partial F}{\\partial y} + s_z\\frac{\\partial F}{\\partial z} = e^z [s_x \\pi\\cos(\\pi x)\\cos(\\pi y) - s_y \\pi\\sin(\\pi x)\\sin(\\pi y) + s_z \\sin(\\pi x)\\cos(\\pi y)] $$\n最后，源项的完整表达式为：\n$$ S(\\mathbf{x},\\mathbf{s}) = (1+c s_z^4) \\left( e^z [s_x \\pi\\cos(\\pi x)\\cos(\\pi y) - s_y \\pi\\sin(\\pi x)\\sin(\\pi y) + s_z \\sin(\\pi x)\\cos(\\pi y)] + \\beta \\sin(\\pi x)\\cos(\\pi y)e^{z} \\right) $$\n\n**2. 标量通量 $\\phi(\\mathbf{x})$ 的推导**\n\n标量通量 $\\phi(\\mathbf{x})$ 定义为辐射强度 $I(\\mathbf{x},\\mathbf{s})$ 在所有立体角上的积分：\n$$ \\phi(\\mathbf{x}) = \\int_{4\\pi} I(\\mathbf{x},\\mathbf{s})\\,\\mathrm{d}\\Omega $$\n代入人造解 $I(\\mathbf{x},\\mathbf{s}) = F(\\mathbf{x})G(\\mu)$:\n$$ \\phi(\\mathbf{x}) = \\int_{4\\pi} F(\\mathbf{x})G(\\mu)\\,\\mathrm{d}\\Omega $$\n由于 $F(\\mathbf{x})$ 与角度变量无关，可以从积分中提出：\n$$ \\phi(\\mathbf{x}) = F(\\mathbf{x}) \\int_{4\\pi} G(\\mu)\\,\\mathrm{d}\\Omega $$\n球坐标 $(\\theta, \\varphi)$ 中的立体角微分为 $\\mathrm{d}\\Omega = \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\varphi$。由于 $\\mu=\\cos\\theta$，我们有 $\\mathrm{d}\\mu = -\\sin\\theta\\,\\mathrm{d}\\theta$。积分限为 $\\varphi \\in [0, 2\\pi]$ 和 $\\mu \\in [-1, 1]$。\n$$ \\int_{4\\pi} G(\\mu)\\,\\mathrm{d}\\Omega = \\int_0^{2\\pi} \\int_{-1}^{1} G(\\mu)\\,\\mathrm{d}\\mu\\,\\mathrm{d}\\varphi $$\n函数 $G(\\mu)=1+c\\mu^4$ 与方位角 $\\varphi$ 无关，因此对 $\\varphi$ 的内层积分得到一个因子 $2\\pi$：\n$$ \\int_{4\\pi} G(\\mu)\\,\\mathrm{d}\\Omega = 2\\pi \\int_{-1}^{1} (1+c\\mu^4)\\,\\mathrm{d}\\mu $$\n计算该定积分：\n$$ \\int_{-1}^{1} (1+c\\mu^4)\\,\\mathrm{d}\\mu = \\left[ \\mu + c\\frac{\\mu^5}{5} \\right]_{-1}^{1} = \\left(1 + \\frac{c}{5}\\right) - \\left(-1 - \\frac{c}{5}\\right) = 2 + \\frac{2c}{5} $$\n将此结果代回：\n$$ \\int_{4\\pi} G(\\mu)\\,\\mathrm{d}\\Omega = 2\\pi \\left(2 + \\frac{2c}{5}\\right) = 4\\pi \\left(1 + \\frac{c}{5}\\right) $$\n因此，标量通量的精确解析表达式为：\n$$ \\phi(\\mathbf{x}) = 4\\pi \\left(1 + \\frac{c}{5}\\right) F(\\mathbf{x}) = 4\\pi \\left(1 + \\frac{c}{5}\\right) \\sin(\\pi x)\\cos(\\pi y)e^{z} $$\n\n**3. 计算验证流程**\n\n验证测试将按以下方式实施。\n\n**空间精度测试：**\n计算内部网格节点 $\\mathbf{x}_{i,j,k}$ 处的离散残差 $R_h$。迁移项 $\\mathbf{s}_0\\cdot\\nabla I$ 通过二阶中心差分格式 $D_h[I]$ 进行近似。在所需的网格点上计算精确的人造解 $I$ 和源项 $S$。\n对于 $N=21$ 和 $N=41$ 点的网格，在 $(N-2)^3$ 个内部节点上计算残差的离散 $L^2$-范数 $E_h$。然后使用公式 $p = \\log(E_{h,21}/E_{h,41})/\\log(2)$ 计算观测到的精度阶 $p$，其中网格间距比为 $h_{21}/h_{41} = (1/20)/(1/40) = 2$。对于二阶格式， $p$ 的期望值约为 2。\n\n**角度求积精度测试：**\n使用推导出的解析公式计算点 $\\mathbf{x}_0=(0.37, 0.41, 0.29)$ 处的精确标量通量 $\\phi(\\mathbf{x}_0)$。数值近似值 $\\phi_{N_\\mu, K_\\varphi}(\\mathbf{x}_0)$ 通过张量积求积计算。\n$$ \\phi_{N_\\mu,K_\\varphi}(\\mathbf{x}_0) = \\sum_{i=1}^{N_\\mu}\\sum_{j=1}^{K_\\varphi} w_i\\,w^\\varphi_j\\, I(\\mathbf{x}_0, \\mathbf{s}(\\mu_i,\\varphi_j)) $$\n由于 $I(\\mathbf{x},\\mathbf{s}) = F(\\mathbf{x})G(\\mu)$ 且由于对称性，方位角积分是精确的，因此上式可简化为：\n$$ \\phi_{N_\\mu,K_\\varphi}(\\mathbf{x}_0) = F(\\mathbf{x}_0) \\left( \\sum_{j=1}^{K_\\varphi} w_j^\\varphi \\right) \\left( \\sum_{i=1}^{N_\\mu} w_i G(\\mu_i) \\right) = 2\\pi F(\\mathbf{x}_0) \\sum_{i=1}^{N_\\mu} w_i (1+c\\mu_i^4) $$\n其中 $(\\mu_i, w_i)$ 是 Gauss-Legendre 求积点和权重。此计算针对 $(N_\\mu, K_\\varphi) = (2,8)$ 和 $(3,8)$ 进行。一个 $N$ 点的 Gauss-Legendre 求积对于次数最高为 $2N-1$ 的多项式是精确的。$G(\\mu)$ 是一个 4 次多项式。因此，$N_\\mu=2$ 的求积会有误差，而 $N_\\mu=3$ 的求积（对 5 次多项式精确）将精确到机器精度，从而得到 $\\varepsilon_3 \\approx 0$。然后计算绝对误差 $\\varepsilon_2$ 和 $\\varepsilon_3$，以及它们的比值。\n计算中将使用给定的参数 $c=0.3$ 和 $\\beta=0.7$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    # Define constants and parameters from the problem statement\n    C_PARAM = 0.3\n    BETA_PARAM = 0.7\n    \n    # --- Function Definitions for Manufactured Solution ---\n\n    def F_func(x, y, z):\n        return np.sin(np.pi * x) * np.cos(np.pi * y) * np.exp(z)\n\n    def dFdx_func(x, y, z):\n        return np.pi * np.cos(np.pi * x) * np.cos(np.pi * y) * np.exp(z)\n\n    def dFdy_func(x, y, z):\n        return -np.pi * np.sin(np.pi * x) * np.sin(np.pi * y) * np.exp(z)\n\n    def dFdz_func(x, y, z):\n        return F_func(x, y, z)\n\n    def G_func(mu, c):\n        return 1.0 + c * mu**4\n\n    def I_manufactured(x, y, z, s_vec, c):\n        _, _, sz = s_vec\n        return F_func(x, y, z) * G_func(sz, c)\n\n    def S_manufactured(x, y, z, s_vec, c, beta):\n        sx, sy, sz = s_vec\n        gradF_dot_s = sx * dFdx_func(x,y,z) + sy * dFdy_func(x,y,z) + sz * dFdz_func(x,y,z)\n        source = G_func(sz, c) * (gradF_dot_s + beta * F_func(x, y, z))\n        return source\n\n    # ---\n    # Task 3.1: Spatial discrete derivative accuracy test\n    # ---\n\n    s0_unnormalized = np.array([0.7, -0.2, 0.68])\n    s0 = s0_unnormalized / np.linalg.norm(s0_unnormalized)\n    s0x, s0y, s0z = s0\n\n    grid_sizes = [21, 41]\n    spatial_errors = []\n\n    for N in grid_sizes:\n        h = 1.0 / (N - 1)\n        grid_points = np.linspace(0.0, 1.0, N)\n        num_interior_nodes = (N - 2)**3\n        sum_sq_residual = 0.0\n\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                for k in range(1, N - 1):\n                    xi, yj, zk = grid_points[i], grid_points[j], grid_points[k]\n                    \n                    # Approximate the streaming term with centered differences\n                    I_xp1 = I_manufactured(grid_points[i+1], yj, zk, s0, C_PARAM)\n                    I_xm1 = I_manufactured(grid_points[i-1], yj, zk, s0, C_PARAM)\n                    I_yp1 = I_manufactured(xi, grid_points[j+1], zk, s0, C_PARAM)\n                    I_ym1 = I_manufactured(xi, grid_points[j-1], zk, s0, C_PARAM)\n                    I_zp1 = I_manufactured(xi, yj, grid_points[k+1], s0, C_PARAM)\n                    I_zm1 = I_manufactured(xi, yj, grid_points[k-1], s0, C_PARAM)\n                    \n                    Dh_I = s0x * (I_xp1 - I_xm1) / (2 * h) + \\\n                           s0y * (I_yp1 - I_ym1) / (2 * h) + \\\n                           s0z * (I_zp1 - I_zm1) / (2 * h)\n                           \n                    # Extinction term\n                    beta_I = BETA_PARAM * I_manufactured(xi, yj, zk, s0, C_PARAM)\n                    \n                    # Exact source term\n                    S_val = S_manufactured(xi, yj, zk, s0, C_PARAM, BETA_PARAM)\n                    \n                    # Discrete residual\n                    residual = Dh_I + beta_I - S_val\n                    sum_sq_residual += residual**2\n        \n        l2_error = np.sqrt(sum_sq_residual / num_interior_nodes)\n        spatial_errors.append(l2_error)\n        \n    E_h21, E_h41 = spatial_errors\n    \n    # Ratio of grid spacings is 2, so log(h1/h2) = log(2)\n    p_observed = np.log(E_h21 / E_h41) / np.log(2.0)\n\n    # ---\n    # Task 3.2: Angular quadrature accuracy test\n    # ---\n\n    x0, y0, z0 = 0.37, 0.41, 0.29\n\n    # Exact scalar flux from Task 2\n    F_at_x0 = F_func(x0, y0, z0)\n    phi_exact = 4.0 * np.pi * (1.0 + C_PARAM / 5.0) * F_at_x0\n\n    quad_cases = [(2, 8), (3, 8)]\n    angular_abs_errors = []\n\n    for N_mu, K_phi in quad_cases:\n        mu_points, mu_weights = roots_legendre(N_mu)\n        \n        # Simplified quadrature sum as derived in the solution\n        # The integral over phi is 2*pi since the integrand G is independent of phi\n        integral_G = np.sum(mu_weights * G_func(mu_points, C_PARAM))\n        phi_numeric = 2.0 * np.pi * F_at_x0 * integral_G\n        \n        angular_abs_errors.append(np.abs(phi_numeric - phi_exact))\n\n    eps2, eps3 = angular_abs_errors\n    \n    # Calculate the ratio, avoiding division by zero\n    error_ratio = eps2 / np.maximum(eps3, 1e-16)\n\n    # --- Final Output ---\n    results = [E_h21, E_h41, p_observed, eps2, eps3, error_ratio]\n    \n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2528240"}]}