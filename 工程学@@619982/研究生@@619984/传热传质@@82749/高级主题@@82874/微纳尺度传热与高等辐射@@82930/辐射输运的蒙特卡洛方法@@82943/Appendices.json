{"hands_on_practices": [{"introduction": "在编写任何蒙特卡洛模拟代码之前，我们必须先将介质的物理属性转化为一个概率论的框架。本次练习 [@problem_id:2508024] 旨在建立吸收系数（$\\kappa$）和散射系数（$\\sigma_s$）等确定性物理量与模拟中所使用的核心概率量——例如单次散射反照率（$\\omega$）和平均自由程（$\\ell$）——之间的基本联系。掌握这些概念对于从第一性原理出发，正确地模拟光子轨迹至关重要。", "problem": "一个空间均匀、等温的灰体参与介质占据了一个厚度为 $L$ 的平板。该介质具有恒定的吸收系数 $\\kappa$ 和散射系数 $\\sigma_{s}$，两者都按单位长度定义。在蒙特卡罗（MC）辐射输运中，相互作用事件之间的光子自由程是从一个由总衰减（消光）系数决定的指数分布中抽样的，而相互作用类型则是根据吸收和散射的相对概率进行抽样。\n\n从沿射线段的能量守恒基本陈述出发（在均匀介质中这导出了比尔-朗伯衰减），并利用吸收和散射是从来未碰撞光束中移除能量的唯一过程，完成以下任务：\n\n1. 从这些第一性原理出发，用 $\\kappa$ 和 $\\sigma_{s}$ 推导消光系数 $\\beta$ 和单次散射反照率 $\\omega$ 的表达式，其中 $\\omega$ 是指一次相互作用是散射事件而非吸收事件的条件概率。\n\n2. 使用由比尔-朗伯衰减所隐含的指数自由程分布，推导平均自由程 $\\ell$ 作为 $\\beta$ 的函数。\n\n3. 对于一个特定的均匀介质，其 $\\kappa=0.2\\ \\mathrm{m}^{-1}$ 和 $\\sigma_{s}=0.8\\ \\mathrm{m}^{-1}$，平板厚度 $L=0.1\\ \\mathrm{m}$，计算 $\\omega$（无量纲）、$\\beta$（单位为 $\\mathrm{m}^{-1}$）、$\\ell$（单位为 $\\mathrm{m}$）以及光学厚度 $\\tau=\\beta L$（无量纲）的数值。然后，根据 $\\tau$ 相对于 1 的大小，说明该平板是光学薄还是光学厚，并从第一性原理出发证明你的分类。\n\n将你的数值答案四舍五入到四位有效数字。用 $\\mathrm{m}^{-1}$ 表示 $\\beta$，用 $\\mathrm{m}$ 表示 $\\ell$。按 $\\left[\\omega,\\ \\beta,\\ \\ell,\\ \\tau\\right]$ 的顺序报告你的最终数值结果。", "solution": "该问题陈述经证实具有科学依据、是适定且客观的。它基于辐射输运理论的基本原理，并为得到唯一解提供了所有必要信息。\n\n该问题要求从第一性原理出发推导基本辐射特性，然后对一个特定情况进行数值计算。\n\n第1部分：消光系数 $\\beta$ 和单次散射反照率 $\\omega$ 的推导。\n\n对于光谱强度为 $I$ 的辐射束在参与介质中穿过路径长度 $ds$ 时的能量守恒基本陈述由辐射输运方程给出。对于没有发射源项的未碰撞光束，强度变化 $dI$ 仅由吸收和散射引起的衰减造成。强度下降率与局部强度 $I$ 成正比。\n\n在路径 $ds$ 上由吸收引起的强度减少为 $dI_{abs} = -\\kappa I ds$，其中 $\\kappa$ 是吸收系数。\n在路径 $ds$ 上因散射出光束方向而引起的强度减少为 $dI_{scat} = -\\sigma_{s} I ds$，其中 $\\sigma_{s}$ 是散射系数。\n\n由于吸收和散射是从未碰撞光束中移除能量的唯一过程，总的强度变化是这两种效应的总和：\n$$dI = dI_{abs} + dI_{scat} = -\\kappa I ds - \\sigma_{s} I ds = -(\\kappa + \\sigma_{s}) I ds$$\n这就是比尔-朗伯定律的微分形式。项 $(\\kappa + \\sigma_{s})$ 代表每单位路径长度发生相互作用（吸收或散射）的总概率。这个总衰减系数被定义为消光系数 $\\beta$。\n因此，从第一性原理出发，消光系数是吸收系数和散射系数的和：\n$$\\beta = \\kappa + \\sigma_{s}$$\n单次散射反照率 $\\omega$ 被定义为一个随机选择的相互作用事件是散射事件的条件概率。在一个只发生吸收和散射的介质中，散射事件的“速率”与 $\\sigma_{s}$ 成正比，吸收事件的“速率”与 $\\kappa$ 成正比。总的相互作用事件速率与 $\\kappa + \\sigma_{s} = \\beta$ 成正比。\n因此，散射事件的概率是散射速率与总相互作用速率之比：\n$$\\omega = \\frac{\\sigma_{s}}{\\kappa + \\sigma_{s}} = \\frac{\\sigma_{s}}{\\beta}$$\n\n第2部分：平均自由程 $\\ell$ 的推导。\n\n比尔-朗伯定律 $dI/I = -\\beta ds$ 可以在从 $s=0$ 到距离 $s$ 的路径上进行积分，以求得未碰撞光束的强度 $I(s)$，假设在 $s=0$ 处的初始强度为 $I_0$：\n$$\\int_{I_0}^{I(s)} \\frac{dI}{I} = \\int_0^s -\\beta ds' \\implies \\ln\\left(\\frac{I(s)}{I_0}\\right) = -\\beta s$$\n$$I(s) = I_0 \\exp(-\\beta s)$$\n从蒙特卡罗方法的概率角度来看，分数 $I(s)/I_0$ 代表了光子行进距离 $s$ 而不发生相互作用的概率。设 $P(s)$ 为此生存概率：\n$$P(s) = \\exp(-\\beta s)$$\n自由程长度的概率密度函数（PDF）$p(s)$ 描述了光子在距离 $s$ 处发生第一次相互作用的概率。这可以通过考虑在无穷小区间 $[s, s+ds]$ 内发生相互作用的概率来求得，该概率是生存到距离 $s$ 的概率乘以在生存到 $s$ 的条件下在 $ds$ 内发生相互作用的条件概率。后者是 $\\beta ds$。\n$$p(s) ds = P(s) \\times (\\beta ds) = \\beta \\exp(-\\beta s) ds$$\n所以，自由程长度的PDF为 $p(s) = \\beta \\exp(-\\beta s)$（对于 $s \\ge 0$）。这是指数分布。\n平均自由程 $\\ell$ 是路径长度 $s$ 的期望值，通过计算该分布的一阶矩得到：\n$$\\ell = E[s] = \\int_0^\\infty s \\cdot p(s) ds = \\int_0^\\infty s \\beta \\exp(-\\beta s) ds$$\n这个积分使用分部积分法 $\\int u dv = uv - \\int v du$ 求解。设 $u=s$ 和 $dv = \\beta \\exp(-\\beta s) ds$。那么 $du = ds$ 且 $v = -\\exp(-\\beta s)$。\n$$\\ell = \\left[s (-\\exp(-\\beta s))\\right]_0^\\infty - \\int_0^\\infty (-\\exp(-\\beta s)) ds$$\n第一项在两个极限处的值都为零：根据洛必达法则，$\\lim_{s \\to \\infty} (-s \\exp(-\\beta s)) = 0$，而在 $s=0$ 处该项为 $0$。\n$$\\ell = \\int_0^\\infty \\exp(-\\beta s) ds = \\left[-\\frac{1}{\\beta} \\exp(-\\beta s)\\right]_0^\\infty$$\n$$\\ell = \\left(-\\frac{1}{\\beta} \\exp(-\\infty)\\right) - \\left(-\\frac{1}{\\beta} \\exp(0)\\right) = (0) - \\left(-\\frac{1}{\\beta}\\right) = \\frac{1}{\\beta}$$\n因此，平均自由程是消光系数的倒数。\n\n第3部分：数值计算和分类。\n\n给定具体数值：\n吸收系数 $\\kappa = 0.2\\ \\mathrm{m}^{-1}$\n散射系数 $\\sigma_{s} = 0.8\\ \\mathrm{m}^{-1}$\n平板厚度 $L = 0.1\\ \\mathrm{m}$\n\n我们计算 $\\beta$、$\\omega$、$\\ell$ 和 $\\tau$ 的数值，并四舍五入到四位有效数字。\n\n消光系数 $\\beta$：\n$$\\beta = \\kappa + \\sigma_{s} = 0.2\\ \\mathrm{m}^{-1} + 0.8\\ \\mathrm{m}^{-1} = 1.0\\ \\mathrm{m}^{-1}$$\n四舍五入到四位有效数字，$\\beta = 1.000\\ \\mathrm{m}^{-1}$。\n\n单次散射反照率 $\\omega$：\n$$\\omega = \\frac{\\sigma_{s}}{\\beta} = \\frac{0.8\\ \\mathrm{m}^{-1}}{1.0\\ \\mathrm{m}^{-1}} = 0.8$$\n四舍五入到四位有效数字，$\\omega = 0.8000$。这是一个无量纲量。\n\n平均自由程 $\\ell$：\n$$\\ell = \\frac{1}{\\beta} = \\frac{1}{1.0\\ \\mathrm{m}^{-1}} = 1.0\\ \\mathrm{m}$$\n四舍五入到四位有效数字，$\\ell = 1.000\\ \\mathrm{m}$。\n\n光学厚度 $\\tau$：\n$$\\tau = \\beta L = (1.0\\ \\mathrm{m}^{-1})(0.1\\ \\mathrm{m}) = 0.1$$\n四舍五入到四位有效数字，$\\tau = 0.1000$。这是一个无量纲量。\n\n基于光学厚度的分类：\n光学厚度 $\\tau$ 是一个无量纲的度量，它量化了介质在给定物理长度 $L$ 上的衰减能力。它可以被解释为物理路径长度 $L$ 与平均自由程 $\\ell$ 的比值，因为 $\\tau = \\beta L = (1/\\ell)L = L/\\ell$。\n在本例中，$\\tau = 0.1000$。\n\n分类是基于 $\\tau$ 相对于 1 的大小：\n- 如果 $\\tau \\ll 1$，介质被认为是**光学薄**的。\n- 如果 $\\tau \\gg 1$，介质被认为是**光学厚**的。\n- 如果 $\\tau \\approx 1$，介质处于中间区域。\n\n这里，$\\tau = 0.1000$，远小于1。因此，该平板被分类为**光学薄**的。\n\n从第一性原理出发的证明：平均自由程 $\\ell = 1.000\\ \\mathrm{m}$ 代表了光子在与介质相互作用之前行进的平均距离。该平板的物理厚度为 $L = 0.1\\ \\mathrm{m}$。由于平板的厚度仅为光子在相互作用前行进的平均距离的十分之一（$L = 0.1 \\ell$），因此进入平板的光子极有可能完全穿过它而不被吸收或散射。光子无碰撞地穿过平板的概率是 $P(L) = \\exp(-\\tau) = \\exp(-0.1) \\approx 0.9048$，这意味着超过 $90\\%$ 的光子不受阻碍地通过。根据定义，一个对入射辐射如此大程度上透明的介质是光学薄的。", "answer": "$$\\boxed{\\begin{pmatrix} 0.8000 & 1.000 & 1.000 & 0.1000 \\end{pmatrix}}$$", "id": "2508024"}, {"introduction": "掌握了核心的概率参数后，我们就可以着手构建一个完整的模拟程序。本次练习 [@problem_id:2508047] 将指导您为简单的一维平板几何编写一个“模拟”蒙特卡洛（Analog Monte Carlo）程序，从而实现光子从发射到最终被吸收或逃逸的整个生命周期。通过追踪光子历史来计算特定物理量，例如经过不同次数散射后透射的能量份额，是该领域计算物理学家的一项基本功。", "problem": "您的任务是设计并实现一个无偏蒙特卡洛估计器，用以计算在均匀平板中，入射辐射能量在经历恰好一次体散射事件后和经历两次或更多次体散射事件后，到达背面探测器的期望分数。介质是均匀、不发射、各向同性散射的，且折射率与外部匹配，因此界面是无反射的。输运在三维空间中建模，但几何结构在空间上是一维的。\n\n请使用以下基本建模假设作为唯一允许的出发点：\n- 线性输运与指数衰减：光子在不发生相互作用的情况下行进自由程长度 $s$ 的概率密度为 $p(s) = \\sigma_t \\exp(-\\sigma_t s)$，其中 $\\sigma_t \\, [\\mathrm{m^{-1}}]$ 是消光系数。单次散射反照率为 $\\omega = \\sigma_s / \\sigma_t \\in [0,1]$，其中 $\\sigma_s \\, [\\mathrm{m^{-1}}]$ 是散射系数。\n- 在相互作用点，光子以概率 $\\omega$ 发生弹性散射；以概率 $1-\\omega$ 被吸收并终止。对于三维空间中的各向同性散射，相对于平板法线的新传播方向余弦在 $[-1,1]$ 上均匀分布。\n- 边界条件：平板占据 $x \\in [0,H]$ 的空间，厚度为 $H \\, [\\mathrm{m}]$。入射平面位于 $x=0$，出射平面（探测器平面）位于 $x=H$。界面是透射的，无折射或反射。入射辐射能量是单位能量、垂直入射、均匀覆盖入射平面的准直光束。当使用 $N$ 个历史时，每个蒙特卡洛粒子历史代表入射单位能量的 $1/N$ 分数。\n\n定义关注量如下。令 $K$ 为一个随机变量，等于一个历史在出射或被吸收前所经历的体散射事件次数。令 $E_{\\text{back},1}$ 表示单位入射能量在经历恰好 $K=1$ 次散射事件后，到达并穿过位于 $x=H$ 的背面的期望分数。令 $E_{\\text{back},\\ge 2}$ 表示在经历 $K \\ge 2$ 次散射事件后，到达并穿过位于 $x=H$ 的背面的期望分数。$K=0$ 的未散射透射不属于这些量的一部分。\n\n您的任务是：\n- 从上述基本陈述中，推导出一个路径指示函数估计器，其数学期望分别等于 $E_{\\text{back},1}$ 和 $E_{\\text{back},\\ge 2}$。\n- 实现一个模拟蒙特卡洛算法，该算法在 $x=0$ 处以方向余弦 $+\\!1$ 发射历史，使用参数 $\\sigma_t$ 抽样自由程，使用 $\\omega$ 执行相互作用，并处理各向同性散射。角度单位使用弧度。为每个历史追踪 $K$，如果历史在 $x=H$ 处出射且 $K=1$，则记录对 $E_{\\text{back},1}$ 的贡献为 $1/N$；类似地，如果它在 $x=H$ 处出射且 $K \\ge 2$，则对 $E_{\\text{back},\\ge 2}$ 贡献 $1/N$。如果一个历史在 $x=0$ 处出射或被吸收，则它不作任何贡献。\n- 使用固定的随机数种子以确保可复现性。\n\n物理单位和角度单位：\n- $H$ 的单位为 $\\mathrm{m}$，$\\sigma_t$ 的单位为 $\\mathrm{m^{-1}}$。所得的能量分数 $E_{\\text{back},1}$ 和 $E_{\\text{back},\\ge 2}$ 是无量纲的。\n- 使用的任何角度都必须以弧度为单位。\n\n测试套件：\n为以下参数集运行您的程序，每个参数集使用 $N=80000$ 个历史和随机数种子 $12345$。\n- 情况 A (正常路径)：$\\sigma_t = 1.0 \\,\\mathrm{m^{-1}}$，$H = 1.0 \\,\\mathrm{m}$，$\\omega = 0.5$。\n- 情况 B (光学厚、高反照率)：$\\sigma_t = 2.0 \\,\\mathrm{m^{-1}}$，$H = 3.0 \\,\\mathrm{m}$，$\\omega = 0.9$。\n- 情况 C (边界情况、纯吸收)：$\\sigma_t = 1.0 \\,\\mathrm{m^{-1}}$，$H = 1.0 \\,\\mathrm{m}$，$\\omega = 0.0$。\n\n要求的最终输出格式：\n- 您的程序必须产生单行输出，其中包含一个结果列表，每个测试用例一个条目，而每个条目本身是包含两个小数 $[E_{\\text{back},1},E_{\\text{back},\\ge 2}]$ 的列表，四舍五入到 $6$ 位小数。外部列表必须按情况 A、B、C 的顺序排列。例如：$[[0.123456,0.234567],[0.010203,0.040506],[0.000000,0.000000]]$。\n\n角度单位要求：\n- 所有角度必须以弧度为单位。\n\n不允许有其他输出或格式。", "solution": "所提出的问题是计算物理领域中一个适定且有科学依据的练习，具体涉及应用蒙特卡洛方法解决辐射输运问题。问题陈述经核实是完整、一致和客观的。因此，我们将着手推导所需的估计器并设计相应的模拟算法。\n\n该物理系统是一个厚度为 $H$ 的均匀、不发射、各向同性散射的平板。辐射垂直入射到 $x=0$ 的表面。我们的任务是估计在经历恰好一次（$E_{\\text{back},1}$）或两次及以上（$E_{\\text{back},\\ge 2}$）散射事件后，从背面 $x=H$ 出射的入射能量的分数。\n\n蒙特卡洛方法模拟大量单个能量包（或称“光子”）的概率行为。在一维平板几何结构中，光子的状态由其位置 $x \\in [0, H]$ 和其方向余弦 $\\mu \\in [-1, 1]$ 定义，其中 $\\mu$ 是光子传播矢量与x轴正向之间夹角的余弦。每个历史都从入射平面 $x_0 = 0$ 开始，方向垂直于表面，即 $\\mu_0 = 1$。光子经历的散射事件次数 $K$ 初始化为 $K=0$。\n\n模拟的核心是一个追踪单个光子生命周期的循环：\n\n1.  **路径长度抽样**：光子在下一次相互作用前行进一个随机距离 $s$。此自由程长度的概率密度函数由指数衰减定律给出，$p(s) = \\sigma_t \\exp(-\\sigma_t s)$，其中 $\\sigma_t$ 是消光系数。该分布使用逆变换采样法进行抽样。给定一个均匀分布的随机数 $R_s \\in (0,1)$，路径长度计算如下：\n    $$\n    s = -\\frac{\\ln(R_s)}{\\sigma_t}\n    $$\n    然后，根据光子的当前位置 $x$ 和方向 $\\mu$ 计算其潜在的新位置 $x'$：\n    $$\n    x' = x + s \\cdot \\mu\n    $$\n\n2.  **边界穿越**：我们必须检查光子的路径是否穿过平板的边界。\n    - 如果 $x' \\ge H$，光子从背面（探测器）出射。历史终止。我们根据 $K$ 的值对事件进行计分。\n    - 如果 $x' \\le 0$，光子从正面（后向散射）出射。历史终止，不对关注量做任何贡献。\n    - 如果 $0 < x' < H$，则在平板内部发生相互作用。光子的位置更新为 $x \\leftarrow x'$。\n\n3.  **相互作用事件**：在相互作用点，光子要么散射，要么被吸收。这由单次散射反照率 $\\omega = \\sigma_s / \\sigma_t$ 决定。抽样一个均匀随机数 $R_\\omega \\in [0,1)$。\n    - 如果 $R_\\omega < \\omega$，光子发生散射。我们将散射计数器加一，$K \\leftarrow K+1$。对于各向同性散射，新的方向余弦 $\\mu'$ 从 $[-1, 1]$ 上的均匀分布中抽样。这通过抽样另一个随机数 $R_\\mu \\in [0,1)$ 并设置 $\\mu' = 2R_\\mu - 1$ 来实现。光子的状态用这个新方向更新，$\\mu \\leftarrow \\mu'$，然后模拟从步骤1继续。\n    - 如果 $R_\\omega \\ge \\omega$，光子被吸收。历史终止。\n\n4.  **估计器构建**：问题要求一个无偏指示函数估计器。对于总共 $N$ 个模拟历史，这等同于一个模拟蒙特卡洛方案。期望值 $E_{\\text{back},1}$ 通过在 $x=H$ 处以恰好一次散射出射的历史所占的比例来估计。令 $I_{1,i}$ 为第 $i$ 个历史的指示变量：\n    $$\n    I_{1,i} = \\begin{cases} 1, & \\text{如果历史 } i \\text{ 在 } x=H \\text{ 处出射且 } K=1 \\\\ 0, & \\text{其他情况} \\end{cases}\n    $$\n    $E_{\\text{back},1}$ 的估计器是 $N$ 个历史的样本均值：\n    $$\n    \\hat{E}_{\\text{back},1} = \\frac{1}{N} \\sum_{i=1}^{N} I_{1,i} = \\frac{N_{K=1}}{N}\n    $$\n    其中 $N_{K=1}$ 是满足该条件的历总数。\n\n    类似地，对于经过两次或更多次散射后透射的能量分数，估计器为：\n    $$\n    \\hat{E}_{\\text{back},\\ge 2} = \\frac{1}{N} \\sum_{i=1}^{N} I_{\\ge 2,i} = \\frac{N_{K\\ge 2}}{N}\n    $$\n    其中 $I_{\\ge 2,i}$ 是历史在 $x=H$ 处以 $K \\ge 2$ 出射的指示变量，$N_{K\\ge 2}$ 是相应的计数。\n\n提供的 Python 代码实现了此算法。它遍历每个指定的测试用例，使用固定的随机数种子运行 $N=80000$ 个历史以保证可复现性，并计算两个估计器。对于纯吸收情况（$\\omega = 0$），不会发生散射（任何透射光子的 $K$ 将始终为 $0$），因此我们正确地预期并验证了 $\\hat{E}_{\\text{back},1} = 0$ 和 $\\hat{E}_{\\text{back},\\ge 2} = 0$。最终结果按要求格式化为六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(slab_thickness, extinction_coeff, albedo, num_histories, rng):\n    \"\"\"\n    Performs an analog Monte Carlo simulation for radiative transport in a 1D slab.\n\n    Args:\n        slab_thickness (float): The thickness H of the slab [m].\n        extinction_coeff (float): The extinction coefficient sigma_t [m^-1].\n        albedo (float): The single-scattering albedo omega.\n        num_histories (int): The number of photon histories to simulate.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        list: A list containing two floats [E_back_1, E_back_ge2].\n    \"\"\"\n    transmitted_k1 = 0\n    transmitted_k_ge2 = 0\n\n    for _ in range(num_histories):\n        # Initialize photon state for a new history\n        x = 0.0      # Position, starting at the entrance plane\n        mu = 1.0     # Direction cosine, normal incidence\n        k = 0        # Number of scattering events\n        is_alive = True\n\n        while is_alive:\n            # Sample the free path length s using inverse transform sampling\n            # rng.random() samples from [0.0, 1.0). If it returns 0.0, log(0) is -inf,\n            # leading to an infinite path length s, which is physically correct.\n            s = -np.log(rng.random()) / extinction_coeff\n            \n            # Calculate the potential new position\n            x_new = x + s * mu\n            \n            # Check for boundary crossing or interaction\n            if x_new >= slab_thickness:  # Photon transmitted through the back face\n                if k == 1:\n                    transmitted_k1 += 1\n                elif k >= 2:\n                    transmitted_k_ge2 += 1\n                is_alive = False  # Terminate history\n            elif x_new <= 0:  # Photon back-scattered through the front face\n                is_alive = False  # Terminate history\n            else:  # Interaction occurs inside the slab\n                x = x_new\n                \n                # Determine if the photon scatters or is absorbed\n                if rng.random() < albedo:  # Scattering event\n                    k += 1\n                    # Sample new direction for isotropic scattering\n                    # The new direction cosine is uniformly distributed in [-1, 1]\n                    mu = 2.0 * rng.random() - 1.0\n                else:  # Absorption event\n                    is_alive = False  # Terminate history\n                    \n    # Calculate the estimated fractions of transmitted energy\n    e_back_1 = transmitted_k1 / num_histories\n    e_back_ge2 = transmitted_k_ge2 / num_histories\n    \n    return [e_back_1, e_back_ge2]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the required format.\n    \"\"\"\n    # Define the simulation parameters from the problem statement\n    num_histories = 80000\n    random_seed = 12345\n    \n    # Define the test cases from the problem statement.\n    # Format: (H [m], sigma_t [m^-1], omega)\n    test_cases = [\n        # Case A: Happy path\n        (1.0, 1.0, 0.5),\n        # Case B: Optically thick, high albedo\n        (3.0, 2.0, 0.9),\n        # Case C: Boundary case, pure absorption\n        (1.0, 1.0, 0.0)\n    ]\n\n    # Initialize the random number generator for reproducibility\n    rng = np.random.default_rng(random_seed)\n\n    all_results = []\n    for H, sigma_t, omega in test_cases:\n        result_pair = run_simulation(H, sigma_t, omega, num_histories, rng)\n        all_results.append(result_pair)\n\n    # Format the final output string precisely as required\n    case_strings = []\n    for e1, e2 in all_results:\n        s1 = f\"{e1:.6f}\"\n        s2 = f\"{e2:.6f}\"\n        case_strings.append(f\"[{s1},{s2}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2508047"}, {"introduction": "现实世界的问题很少涉及均匀介质，因此简单的模拟程序往往难以胜任。本次练习 [@problem_id:2508013] 旨在解决一个关键的实际挑战：如何在非均匀介质（通常用网格单元表示）中精确追踪光子。您将重点开发一种稳健的逐单元射线追踪算法，该算法是正确累积光学厚度并确定相互作用位置的关键，对于将蒙特卡洛方法应用于复杂、真实的几何模型至关重要。", "problem": "给定一个三维、轴对齐的矩形域，它被离散化为一个均匀的笛卡尔单元格网格，并具有分段常数的消光系数。一个单一、笔直、无散射的蒙特卡洛射线从域内一个点以给定方向发射。射线的自由程是依据光学厚度进行采样的。您的任务是，从第一性原理出发，推导并实现一个物理上精确的、逐单元格的遍历算法，该算法沿射线穿过连续的单元格累积光学厚度，直到光学厚度预算耗尽（发生碰撞事件）或射线离开该域（无碰撞）。\n\n在推导过程中，请使用以下基本原理：\n- 沿特征线的仅含消光的辐射传输方程（RTE）：在具有消光系数 $\\kappa_e(\\mathbf{x})$ 的介质中，对于一个小的路径长度段 $ds$，辐射强度的衰减遵循 $dI/ds = -\\kappa_e I$，这意味着 Beer–Lambert 衰减。在具有恒定 $\\kappa_e$ 的均匀介质中，经过距离 $s$ 后的生存概率为 $\\exp(-\\kappa_e s)$。\n- 光学厚度自由程的逆变换采样：光学自由程 $\\tau$ 服从指数分布，其概率密度函数为 $p(\\tau) = \\exp(-\\tau)$（$\\tau \\ge 0$）。给定一个均匀随机变量 $\\xi \\in (0,1)$，$\\tau$ 的采样公式为 $\\tau = -\\ln(1 - \\xi)$。\n- 分段常数消光：在每个网格单元 $C$ 中，消光系数 $\\kappa_e$ 是恒定的，在 $C$ 内长度为 $s_C$ 的几何路段上累积的光学厚度为 $\\tau_C = \\kappa_e s_C$。\n\n您的算法目标是：\n- 给定域内的起始位置 $\\mathbf{x}_0$、单位长度（无量纲）的方向向量 $\\hat{\\boldsymbol{\\omega}}$ 以及一个采样的光学厚度预算 $\\tau^\\star$，沿射线遍历单元格并累积光学厚度，直到事件发生。\n- 在每个单元格内，计算沿射线到下一个相交单元格面的几何路径长度，并使用该单元格局部的恒定 $\\kappa_e$ 计算相应的光学厚度贡献。\n- 判断碰撞是发生在当前单元格内，还是射线穿越到下一个单元格，并进行迭代，直到发生碰撞或射线离开域。\n\n几何与物理规格：\n- 域是轴对齐的立方体 $[0,L_x) \\times [0,L_y) \\times [0,L_z)$，其中 $L_x = L_y = L_z = $ $1.0$（单位：米）。\n- 网格是均匀的，每个轴向有 $N_x = N_y = N_z = $ $2$ 个单元格，因此每个单元格的尺寸为 $\\Delta x = \\Delta y = \\Delta z = $ $0.5$（单位：米）。\n- 消光系数 $\\kappa_e$（单位：米⁻¹）在每个单元格内是分段常数，单元格索引为 $(i_x,i_y,i_z) \\in \\{0,1\\}^3$，其值如下：\n  - $\\kappa_e(0,0,0) = $ $2.0$,\n  - $\\kappa_e(1,0,0) = $ $1.0$,\n  - $\\kappa_e(0,1,0) = $ $0.2$,\n  - $\\kappa_e(1,1,0) = $ $0.4$,\n  - $\\kappa_e(0,0,1) = $ $0.5$,\n  - $\\kappa_e(1,0,1) = $ $3.0$,\n  - $\\kappa_e(0,1,1) = $ $0.1$,\n  - $\\kappa_e(1,1,1) = $ $0.2$.\n\n碰撞判定规则：\n- 设处理当前单元格前剩余的光学厚度预算为 $\\tau_{\\mathrm{rem}}$。设在当前单元格内，沿射线到下一个单元格面的几何距离为 $s_{\\mathrm{face}}$（单位：米）。该单元格到该面的光学厚度贡献为 $\\tau_{\\mathrm{face}} = \\kappa_e s_{\\mathrm{face}}$。\n- 如果 $\\tau_{\\mathrm{rem}} \\le \\tau_{\\mathrm{face}}$，则判定在当前单元格内发生碰撞，碰撞点距离当前位置的距离为 $s_\\mathrm{col} = \\tau_{\\mathrm{rem}}/\\kappa_e$，然后停止。\n- 如果 $\\tau_{\\mathrm{rem}} > \\tau_{\\mathrm{face}}$，则将 $\\tau_{\\mathrm{rem}}$ 更新为 $\\tau_{\\mathrm{rem}} \\leftarrow \\tau_{\\mathrm{rem}} - \\tau_{\\mathrm{face}}$，将射线推进到单元格面，沿相交轴进入相邻单元格，并继续。\n- 如果下一步移动将使射线离开域，则终止并判定无碰撞。\n\n单位与归一化：\n- 所有方向必须是单位向量，以确保沿射线的几何距离以米为单位。距离必须以米为单位报告。光学厚度是无量纲的。\n\n角度单位：\n- 不适用；方向以单位向量的分量形式提供。\n\n测试套件：\n实现您的算法，并将其应用于以下五个测试用例。在每个案例中，光学厚度预算是根据给定的 $\\xi$ 使用 $\\tau^\\star = -\\ln(1 - \\xi)$ 进行采样的。\n\n- 案例 1（穿过一个单元格面后发生碰撞）：\n  - $\\mathbf{x}_0 = [$ $0.1$, $0.1$, $0.1$ $]$ （单位：米），\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $1.0$, $0.0$, $0.0$ $]$ （无量纲），\n  - $\\xi = $ $0.6321205588285577$ （因此 $\\tau^\\star$ 恰好为 $1.0$）。\n- 案例 2（恰好在单元格面发生碰撞；边界相等情况）：\n  - $\\mathbf{x}_0 = [$ $0.1$, $0.1$, $0.1$ $]$ （单位：米），\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $1.0$, $0.0$, $0.0$ $]$ （无量纲），\n  - $\\xi = $ $0.5506710358827784$ （因此 $\\tau^\\star$ 恰好为 $0.8$）。\n- 案例 3（无碰撞；在预算耗尽前离开域）：\n  - $\\mathbf{x}_0 = [$ $0.25$, $0.75$, $0.75$ $]$ （单位：米），\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $0.0$, $-1.0$, $0.0$ $]$ （无量纲），\n  - $\\xi = $ $0.6321205588285577$ （因此 $\\tau^\\star$ 恰好为 $1.0$）。\n- 案例 4（轴对齐且有一个零分量；在当前单元格内碰撞）：\n  - $\\mathbf{x}_0 = [$ $0.3$, $0.3$, $0.3$ $]$ （单位：米），\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $0.0$, $1.0$, $0.0$ $]$ （无量纲），\n  - $\\xi = $ $0.048770575499285984$ （因此 $\\tau^\\star$ 恰好为 $0.05$）。\n- 案例 5（具有负分量和零分量的斜向遍历）：\n  - $\\mathbf{x}_0 = [$ $0.8$, $0.9$, $0.1$ $]$ （单位：米），\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $-1.0$, $-1.0$, $0.0$ $]$ （无量纲；归一化为单位长度），\n  - $\\xi = $ $0.09516258196404048$ （因此 $\\tau^\\star$ 恰好为 $0.1$）。\n\n每个测试用例的所需输出：\n- 一个包含四个条目的列表，顺序如下：\n  - 一个布尔值，指示是否在域内发生碰撞。\n  - 沿射线传播直到事件（碰撞或离开）发生的总几何距离，以米为单位，表示为浮点数。\n  - 事件发生时累积的光学厚度，表示为浮点数（如果发生碰撞，则等于采样预算；否则等于截至离开时积分的光学厚度，严格小于采样预算）。\n  - 事件发生所在单元格的整数索引三元组 $[i_x,i_y,i_z]$。如果事件是离开（无碰撞），则报告射线离开时所在的最后一个域内单元格的索引。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个测试用例的结果列表，每个案例的结果本身也是一个按上述顺序排列的列表。最外层必须是单个 Python 风格的列表字面量，例如： \n  \"[[case1_result_list],[case2_result_list],...,[case5_result_list]]\"。", "solution": "我们从仅含消光的介质中沿特征线的辐射传输方程（RTE）开始。设 $I(s)$ 表示在具有消光系数 $\\kappa_e(\\mathbf{x}) \\ge 0$ 的介质中，由几何路径长度 $s$ 参数化的射线上的辐射强度。在一个无穷小段 $ds$上，RTE简化为 $dI/ds = -\\kappa_e I$，对于均匀段，该方程积分得到 Beer-Lambert 定律：$I(s) = I(0)\\exp(-\\kappa_e s)$。到 $s$ 处的生存概率是 $\\exp(-\\kappa_e s)$，这意味着定义为 $\\tau(s) = \\int_0^s \\kappa_e(\\mathbf{x}(u))\\,du$ 的光学厚度是可加的且无量纲的。对于一个具有恒定 $\\kappa_e$ 的均匀单元格 $C$，在其中穿过的几何距离为 $s_C$，光学厚度增量为 $\\tau_C = \\kappa_e s_C$。\n\n在蒙特卡洛自由程采样中，到碰撞点的光学厚度是一个单位速率的指数随机变量。如果 $\\xi \\sim \\mathcal{U}(0,1)$，则采样的光学预算为 $\\tau^\\star = -\\ln(1 - \\xi)$。给定 $\\xi$，这个选择是确定性的。碰撞事件发生在使路径积分 $\\tau(s)$ 达到 $\\tau^\\star$ 的最小 $s \\ge 0$ 处，即 $\\tau(s) = \\tau^\\star$，前提是射线保持在域内；否则，当射线以 $\\tau(s_{\\mathrm{exit}}) < \\tau^\\star$ 到达域边界时，它将在没有碰撞的情况下离开。\n\n由于 $\\kappa_e(\\mathbf{x})$ 在轴对齐的单元格网格上是分段常数，我们可以将沿射线的 $\\tau$ 积分分解为对连续单元格的求和。设域为 $[0,L_x) \\times [0,L_y) \\times [0,L_z)$，其中 $L_x=L_y=L_z=$ $1.0$，在每个维度上均匀离散为 $N_x=N_y=N_z=$ $2$ 个单元格，得到单元格尺寸 $\\Delta x=\\Delta y=\\Delta z=$ $0.5$。对于单元格索引 $(i_x,i_y,i_z)\\in \\{0,1\\}^3$，已指定了消光系数值 $\\kappa_e$。射线由域内的一个初始点 $\\mathbf{x}_0$ 和一个单位长度的方向 $\\hat{\\boldsymbol{\\omega}}$ 定义。射线方程为 $\\mathbf{x}(s) = \\mathbf{x}_0 + s\\hat{\\boldsymbol{\\omega}}$。\n\n我们需要一个稳健的算法来遍历单元格并累积光学厚度。针对轴对齐网格的标准数字差分分析器（DDA）算法提供了一种高效的方法，可以根据单元格内的位置和方向，计算沿射线到下一个单元格面的几何距离。设 $\\hat{\\boldsymbol{\\omega}}=(\\omega_x,\\omega_y,\\omega_z)$，并假设射线当前位于单元格 $(i_x,i_y,i_z)$ 中。定义步进符号 $s_x=\\operatorname{sign}(\\omega_x)$，约定 $s_x\\in\\{-1,0,1\\}$，对 $s_y$ 和 $s_z$ 也类似。对于每个轴，定义：\n- 如果 $\\omega_x>0$，下一个与 $\\hat{\\mathbf{e}}_x$ 正交的平面位于 $x = (i_x+1)\\Delta x$，到该平面的几何距离为\n$$\nt^{\\max}_x = \\frac{(i_x+1)\\Delta x - x_0}{\\omega_x},\n$$\n其中 $x_0$ 是当前的 $x$ 坐标。如果 $\\omega_x<0$，下一个平面位于 $x = i_x\\Delta x$，距离为\n$$\nt^{\\max}_x = \\frac{x_0 - i_x\\Delta x}{|\\omega_x|}.\n$$\n如果 $\\omega_x=0$，则设 $t^{\\max}_x=+\\infty$。此后，连续的 $x$ 轴对齐平面之间的增量距离为\n$$\nt^{\\Delta}_x = \\begin{cases}\n\\frac{\\Delta x}{|\\omega_x|}, & \\omega_x\\neq 0,\\\\\n+\\infty, & \\omega_x=0.\n\\end{cases}\n$$\n类似地定义 $t^{\\max}_y,t^{\\Delta}_y$ 和 $t^{\\max}_z,t^{\\Delta}_z$。\n\n设 $s_{\\mathrm{tot}}$ 表示从 $\\mathbf{x}_0$ 已行进的几何距离，$\\tau_{\\mathrm{rem}}$ 表示在碰撞前剩余待消耗的光学预算，初始化为 $\\tau_{\\mathrm{rem}}=\\tau^\\star$。在当前单元格的每次迭代中：\n1. 计算从 $\\mathbf{x}_0$ 沿射线到下一个单元格面的绝对距离 $t_{\\mathrm{face}} = \\min\\{t^{\\max}_x,t^{\\max}_y,t^{\\max}_z\\}$。当前单元格内的增量几何距离为 $s_{\\mathrm{cell}} = t_{\\mathrm{face}} - s_{\\mathrm{tot}}$。\n2. 该单元格到该面的光学贡献为 $\\tau_{\\mathrm{face}} = \\kappa_e(i_x,i_y,i_z)\\, s_{\\mathrm{cell}}$。\n3. 如果 $\\tau_{\\mathrm{rem}} \\le \\tau_{\\mathrm{face}}$，则在当前单元格内发生碰撞，几何增量为\n$$\ns_{\\mathrm{col}} = \\frac{\\tau_{\\mathrm{rem}}}{\\kappa_e(i_x,i_y,i_z)},\n$$\n因此总行进距离变为 $s_{\\mathrm{tot}} \\leftarrow s_{\\mathrm{tot}} + s_{\\mathrm{col}}$，然后因碰撞而停止。\n4. 否则，将 $\\tau_{\\mathrm{rem}}$ 递减为 $\\tau_{\\mathrm{rem}} \\leftarrow \\tau_{\\mathrm{rem}} - \\tau_{\\mathrm{face}}$，将 $s_{\\mathrm{tot}}$ 推进到 $t_{\\mathrm{face}}$，并确定哪个轴实现了 $t_{\\mathrm{face}}$ 的最小值。如果多个轴完全相等，任何能防止重复计算的一致性平局打破规则都是可接受的；为了数值稳定性，我们考虑严格最小值。如果沿该轴前进会离开网格（例如，当 x 轴是最小化轴时，$i_x + s_x$ 落在 $\\{0,1\\}$ 之外），则射线在距离 $s_{\\mathrm{tot}}$ 处离开域，无碰撞。否则，将相应索引按步进符号递增，例如，对于 x 轴，$i_x \\leftarrow i_x + s_x$，并为所选轴更新 DDA 累加器 $t^{\\max}_x \\leftarrow t^{\\max}_x + t^{\\Delta}_x$。从步骤 1 开始重复。\n5. 方向是单位向量，因此所有 $t$ 和 $s$ 的单位都是米。光学厚度保持无量纲。\n\n该算法直接在单元格上对路径积分 $\\tau(s)$ 进行分段线性积分，遵循了光学厚度的可加性以及 $\\tau^\\star$ 的指数采样。在相等情况下的决策规则，即 $\\tau_{\\mathrm{rem}} = \\tau_{\\mathrm{face}}$，会在当前单元格的面上产生一次碰撞，这在物理上是一致的，因为碰撞事件是沿路径连续采样的。\n\n我们现在解释每个测试用例：\n\n- 案例 1：$\\mathbf{x}_0=[$ $0.1$, $0.1$, $0.1$ $]$，$\\hat{\\boldsymbol{\\omega}}=[$ $1$, $0$, $0$ $]$，$\\tau^\\star=$ $1$。当前单元格为 $(0,0,0)$，$\\kappa_e=$ $2.0$。到 $x=$ $0.5$ 的距离为 $s=$ $0.4$，到该面的光学厚度为 $\\tau_{\\mathrm{face}}=$ $0.8$。由于 $\\tau^\\star > \\tau_{\\mathrm{face}}$，移动到 $(1,0,0)$，剩余预算为 $1.0-0.8=$ $0.2$。在 $(1,0,0)$ 中，$\\kappa_e=$ $1.0$，因此碰撞发生在 $s_{\\mathrm{col}}=0.2/1.0=$ $0.2$ 处。总距离为 $0.4+0.2=$ $0.6$，在单元格 $(1,0,0)$ 中发生碰撞。\n\n- 案例 2：同样的几何结构，但 $\\tau^\\star=$ $0.8$。在 $(0,0,0)$ 中，到面的光学厚度恰好为 $\\tau_{\\mathrm{face}}=$ $0.8$。根据相等规则，在当前单元格内，于距离 $s=$ $0.4$ 的单元格面处发生碰撞；报告单元格 $(0,0,0)$。\n\n- 案例 3：$\\mathbf{x}_0=[$ $0.25$, $0.75$, $0.75$ $]$，$\\hat{\\boldsymbol{\\omega}}=[$ $0$, $-1$, $0$ $]$，$\\tau^\\star=$ $1$。从 $(0,1,1)$ 开始，$\\kappa_e=$ $0.1$；到 $y=$ $0.5$ 的距离为 $s=$ $0.25$，$\\tau_{\\mathrm{face}}=$ $0.025$。步进（因为沿-y方向移动）到 $(0,0,1)$，剩余预算为 $0.975$。在 $(0,0,1)$ 中，$\\kappa_e=$ $0.5$；到 $y=$ $0$ 处域出口的距离为 $s=$ $0.5$，$\\tau_{\\mathrm{face}}=$ $0.25$。射线离开域而无碰撞，因为 $0.025+0.25=$ $0.275 < 1.0$。总距离为 $0.25+0.5=$ $0.75$，最后一个域内单元格为 $(0,0,1)$，离开时累积的光学厚度为 $0.275$。\n\n- 案例 4：$\\mathbf{x}_0=[$ $0.3$, $0.3$, $0.3$ $]$，$\\hat{\\boldsymbol{\\omega}}=[$ $0$, $1$, $0$ $]$，$\\tau^\\star=$ $0.05$。在 $(0,0,0)$ 中，$\\kappa_e=$ $2.0$，到 $y=$ $0.5$ 的距离为 $s=$ $0.2$，因此 $\\tau_{\\mathrm{face}}=$ $0.4$。由于 $\\tau^\\star < \\tau_{\\mathrm{face}}$，碰撞发生在当前单元格内，距离为 $s_{\\mathrm{col}}=0.05/2.0=$ $0.025$。总距离为 $0.025$，在 $(0,0,0)$ 中发生碰撞。\n\n- 案例 5：$\\mathbf{x}_0=[$ $0.8$, $0.9$, $0.1$ $]$，$\\hat{\\boldsymbol{\\omega}}$ 与 $[$ $-1$, $-1$, $0$ $]$ 成比例，归一化为单位长度；$\\tau^\\star=$ $0.1$。在 $(1,1,0)$ 中，$\\kappa_e=$ $0.4$，到下一个面的距离为 $s_x=$ $(0.8-0.5)/|\\omega_x|=$ $0.3\\sqrt{2}$ 和 $s_y=$ $(0.9-0.5)/|\\omega_y|=$ $0.4\\sqrt{2}$，因此第一个面穿越是沿 x 轴，距离为 $s\\approx 0.424264$。到该面的相应光学厚度为 $\\tau_{\\mathrm{face}}\\approx 0.4\\times 0.424264\\approx 0.1697056$。由于 $\\tau^\\star<\\tau_{\\mathrm{face}}$，碰撞发生在 $(1,1,0)$ 内部，距离为 $s_{\\mathrm{col}}=0.1/0.4=$ $0.25$。总距离为 $0.25$，在 $(1,1,0)$ 中发生碰撞。\n\n实现细节：\n- 将每个输入方向归一化为单位长度，以确保几何和光学计算使用一致的单位。\n- 使用半开区间域以避免上边界的模糊性，并将当前单元格初始化为 $i_\\alpha = \\min(\\max(\\lfloor x_{0,\\alpha}/\\Delta \\alpha \\rfloor,0),N_\\alpha-1)$，其中 $\\alpha\\in\\{x,y,z\\}$。\n- 如上所述实现 DDA 累加器 $t^{\\max}_\\alpha$ 和 $t^{\\Delta}_\\alpha$。跟踪 $s_{\\mathrm{tot}}$、$\\tau_{\\mathrm{rem}}$，并在一个步进会使单元格索引沿最小化轴移出 $\\{0,1\\}$ 范围时确定为离开。\n- 所需的输出直接来自终止时的状态：碰撞标志、$s_{\\mathrm{tot}}$、累积的光学厚度（碰撞时等于 $\\tau^\\star$，离开时等于 $\\tau^\\star - \\tau_{\\mathrm{rem}}$），以及当前单元格的索引三元组。\n\n根据此推导构建的程序将生成所要求的每个案例的输出，并将它们聚合到指定的单行列表格式中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sample_tau_from_xi(xi: float) -> float:\n    # Optical thickness sample via inverse transform: tau = -ln(1 - xi)\n    # Assumes 0 < xi < 1\n    return -np.log(1.0 - xi)\n\ndef normalize(v: np.ndarray) -> np.ndarray:\n    n = np.linalg.norm(v)\n    if n == 0.0:\n        raise ValueError(\"Direction vector must be non-zero.\")\n    return v / n\n\ndef in_bounds(ix, iy, iz, nx, ny, nz):\n    return (0 <= ix < nx) and (0 <= iy < ny) and (0 <= iz < nz)\n\ndef ray_traverse_to_event(x0, w, xi, kappa_grid, L, N):\n    \"\"\"\n    Perform cell-by-cell traversal accumulating optical thickness until collision or exit.\n\n    Parameters:\n        x0: np.array shape (3,), starting position in meters.\n        w: np.array shape (3,), ray direction (will be normalized).\n        xi: float, uniform in (0,1) used to sample optical thickness tau* = -ln(1 - xi).\n        kappa_grid: np.ndarray shape (Nx,Ny,Nz), extinction coefficients in 1/m.\n        L: tuple (Lx,Ly,Lz) domain lengths in meters.\n        N: tuple (Nx,Ny,Nz) number of cells per axis.\n\n    Returns:\n        (collision: bool, distance: float, tau_accum: float, cell_index: [ix,iy,iz])\n    \"\"\"\n    # Normalize direction to ensure distances are in meters.\n    w = normalize(w.astype(float))\n    Lx, Ly, Lz = L\n    Nx, Ny, Nz = N\n    dx = np.array([Lx / Nx, Ly / Ny, Lz / Nz], dtype=float)\n\n    # Initial cell indices (clamp to valid range)\n    ix = int(np.clip(np.floor(x0[0] / dx[0]), 0, Nx - 1))\n    iy = int(np.clip(np.floor(x0[1] / dx[1]), 0, Ny - 1))\n    iz = int(np.clip(np.floor(x0[2] / dx[2]), 0, Nz - 1))\n\n    # Sanity: start must be in bounds\n    if not in_bounds(ix, iy, iz, Nx, Ny, Nz):\n        raise ValueError(\"Start position is not inside the domain.\")\n\n    # Step directions\n    step_x = 0 if w[0] == 0.0 else (1 if w[0] > 0.0 else -1)\n    step_y = 0 if w[1] == 0.0 else (1 if w[1] > 0.0 else -1)\n    step_z = 0 if w[2] == 0.0 else (1 if w[2] > 0.0 else -1)\n\n    # Initialize tMax and tDelta for DDA\n    # Compute distance from current position to next plane along each axis.\n    def initial_tmax(pos, dir_comp, i, d):\n        if dir_comp > 0.0:\n            next_plane = (i + 1) * d\n            return (next_plane - pos) / dir_comp\n        elif dir_comp < 0.0:\n            next_plane = i * d\n            return (pos - next_plane) / (-dir_comp)\n        else:\n            return np.inf\n\n    def delta_t(dir_comp, d):\n        return (d / abs(dir_comp)) if dir_comp != 0.0 else np.inf\n\n    tMax_x = initial_tmax(x0[0], w[0], ix, dx[0])\n    tMax_y = initial_tmax(x0[1], w[1], iy, dx[1])\n    tMax_z = initial_tmax(x0[2], w[2], iz, dx[2])\n\n    tDelta_x = delta_t(w[0], dx[0])\n    tDelta_y = delta_t(w[1], dx[1])\n    tDelta_z = delta_t(w[2], dx[2])\n\n    # Optical-thickness budget\n    tau_star = sample_tau_from_xi(xi)\n    tau_rem = tau_star\n\n    # Accumulated geometric distance\n    s_tot = 0.0\n\n    eps = 1e-15  # numerical tolerance\n\n    while True:\n        # Current cell extinction\n        kappa = float(kappa_grid[ix, iy, iz])\n\n        # Compute distance to next face from the ray origin and incremental distance in current cell\n        tface_abs = min(tMax_x, tMax_y, tMax_z)\n        s_cell = tface_abs - s_tot\n        if s_cell < -1e-14:\n            # Should not happen; numerical guard\n            s_cell = 0.0\n\n        # Optical thickness to that face\n        tau_face = kappa * s_cell\n\n        # Collision decision\n        if tau_rem <= tau_face + eps:\n            # Collision occurs within this cell at distance s_col from current location\n            # Clamp at zero kappa (degenerate) would be problematic; but all kappas are > 0 here.\n            if kappa <= 0.0:\n                # Degenerate case: no extinction; treat as infinite path in this cell -> exit\n                # But not applicable for given test suite.\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            s_col = tau_rem / kappa\n            s_tot += s_col\n            # Accumulated optical thickness equals tau_star at collision\n            return (True, s_tot, tau_star, [ix, iy, iz])\n\n        # Otherwise, advance to the face, decrement remaining tau, and step to the next cell\n        tau_rem -= tau_face\n        s_tot = tface_abs\n\n        # Determine which axis to step along\n        # Use strict comparisons to avoid double-stepping; ties will step the first matching axis.\n        if tMax_x <= tMax_y and tMax_x <= tMax_z:\n            # Stepping across x-face\n            next_ix = ix + step_x\n            # Check domain exit\n            if next_ix < 0 or next_ix >= Nx:\n                # Exiting domain from current cell\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            ix = next_ix\n            tMax_x += tDelta_x\n        elif tMax_y <= tMax_x and tMax_y <= tMax_z:\n            # Stepping across y-face\n            next_iy = iy + step_y\n            if next_iy < 0 or next_iy >= Ny:\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            iy = next_iy\n            tMax_y += tDelta_y\n        else:\n            # Stepping across z-face\n            next_iz = iz + step_z\n            if next_iz < 0 or next_iz >= Nz:\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            iz = next_iz\n            tMax_z += tDelta_z\n\n\ndef solve():\n    # Domain and grid specification\n    L = (1.0, 1.0, 1.0)   # meters\n    N = (2, 2, 2)         # cells per axis\n    # Extinction coefficients per cell (Nx,Ny,Nz) in 1/m\n    kappa = np.zeros(N, dtype=float)\n    # Assign values as specified\n    kappa[0,0,0] = 2.0\n    kappa[1,0,0] = 1.0\n    kappa[0,1,0] = 0.2\n    kappa[1,1,0] = 0.4\n    kappa[0,0,1] = 0.5\n    kappa[1,0,1] = 3.0\n    kappa[0,1,1] = 0.1\n    kappa[1,1,1] = 0.2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (x0, w, xi)\n        (np.array([0.1, 0.1, 0.1], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float), 0.6321205588285577),\n        (np.array([0.1, 0.1, 0.1], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float), 0.5506710358827784),\n        (np.array([0.25, 0.75, 0.75], dtype=float), np.array([0.0, -1.0, 0.0], dtype=float), 0.6321205588285577),\n        (np.array([0.3, 0.3, 0.3], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float), 0.048770575499285984),\n        (np.array([0.8, 0.9, 0.1], dtype=float), np.array([-1.0, -1.0, 0.0], dtype=float), 0.09516258196404048),\n    ]\n\n    results = []\n    for x0, w, xi in test_cases:\n        collision, dist, tau_accum, cell_idx = ray_traverse_to_event(x0, w, xi, kappa, L, N)\n        # Build per-case result list as specified\n        results.append([bool(collision), float(dist), float(tau_accum), [int(cell_idx[0]), int(cell_idx[1]), int(cell_idx[2])]])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2508013"}]}