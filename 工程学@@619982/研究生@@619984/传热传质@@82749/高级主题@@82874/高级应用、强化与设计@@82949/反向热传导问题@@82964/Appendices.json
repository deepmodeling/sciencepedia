{"hands_on_practices": [{"introduction": "任何逆问题的解的质量都取决于其所依赖的正向模型。不准确或不稳定的正向模拟会引入伪影，而反演算法会将其误解为物理效应，从而导致错误的结果。本实践的重点是分析一种常见的显式数值格式的稳定性，以理解其局限性以及这些局限性如何影响整个逆热传导问题（IHCP）。这是在解决逆问题本身之前必须掌握的基础步骤。[@problem_id:2497720]", "problem": "一个一维（$1$D）半无限大固体占据 $x \\ge 0$ 的空间，其温度场遵循热传导方程 $\\partial T/\\partial t = \\alpha\\,\\partial^{2}T/\\partial x^{2}$，其中热扩散系数 $\\alpha$ 为常数。在一个热传导反问题（IHCP）中，需要通过在固定位置 $x=x_{m}$ 处的内部温度测量值，来估计在 $x=0$ 处未知的表面热流 $q(t)$。该估计过程通过重复求解正向模型并使用基于梯度的优化方法来完成。该正向模型在均匀空间网格 $x_{i}=i\\,\\Delta x$ 上进行离散化，并采用前向欧拉法进行时间推进，其中空间导数使用二阶中心差分格式进行近似。\n\n仅从热传导方程、所述的离散格式以及线性常系数格式的傅里叶放大因子的定义出发，完成以下任务：\n\n- 通过冯·诺依曼稳定性分析，推导该显式格式的充分必要稳定性条件，并将其表示为关于无量纲时间步长参数 $r=\\alpha\\,\\Delta t/\\Delta x^{2}$ 的一个不等式。由此，确定使 $\\Delta t_{\\max}=C\\,\\Delta x^{2}/\\alpha$ 成立的常数 $C$ 的最大允许值。\n\n- 使用你的结果，计算在给定值 $\\Delta x=8.0\\times 10^{-4}\\,\\text{m}$ 和 $\\alpha=8.5\\times 10^{-6}\\,\\text{m}^{2}\\,\\text{s}^{-1}$ 下的最大稳定时间步长。将最终数值答案以秒为单位表示，并四舍五入到 $4$ 位有效数字。\n\n- 基于你推导出的放大因子，解释当选择接近稳定性极限的 $\\Delta t$ 时，会对以下方面产生何种影响：(i) 正向解中空间温度梯度的准确性；(ii) 当对 $q(t)$ 采用标准的二次数据失配和 Tikhonov 正则化时，在 IHCP 反演中使用的梯度的稳定性和条件。你的解释必须基于该格式的谱特性，且不得假定任何无法从你的放大因子推导出的结论。\n\n请仅提供最大稳定时间步长的数值作为最终答案，按要求以秒为单位并四舍五入到 $4$ 位有效数字。所有的中间推导和讨论都应在你的解答中呈现。", "solution": "该问题要求一个包含三部分的回答：首先，推导一维热传导方程的时间前向、空间中心（FTCS）离散格式的稳定性条件；其次，为给定参数计算最大稳定时间步长；第三，解释在热传导反问题（IHCP）的背景下，在接近此稳定性极限时运行所带来的后果。整个分析必须是自洽的，从控制偏微分方程出发。\n\n一维热传导方程如下：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n其中 $T$ 是温度，$t$ 是时间，$x$ 是空间坐标，$\\alpha$ 是恒定的热扩散系数。\n\n我们在均匀网格上离散化此方程，其中 $T(x_i, t_n) \\equiv T_i^n$，$x_i = i \\Delta x$，$t_n = n \\Delta t$。对时间导数使用前向欧拉格式，对空间导数使用二阶中心差分格式，我们得到 FTCS 格式：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2}\n$$\n为求解下一时间步的温度 $T_i^{n+1}$ 进行移项，可得：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\n我们定义无量纲时间步长参数，或称傅里叶数，为 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。方程于是简化为：\n$$\nT_i^{n+1} = T_i^n + r \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\n\n为进行冯·诺依曼稳定性分析，我们考虑温度场的单个傅里叶模式的演化。我们将时间步 $n$ 的温度表示为这些模式的叠加。一个典型的模式具有以下形式：\n$$\nT_i^n = A^n(k) \\exp(I k x_i)\n$$\n其中 $A^n(k)$ 是波数为 $k$ 的模式在时间步 $n$ 的振幅，$I$ 是虚数单位（$I^2 = -1$）。为使格式稳定，任何模式的振幅都不能随时间增长，这意味着放大因子 $G(k) = A^{n+1}(k) / A^n(k)$ 的模必须对所有可能的波数 $k$ 满足 $|G(k)| \\le 1$。\n\n将傅里叶模式代入离散方程：\n$$\nA^{n+1} \\exp(I k i \\Delta x) = A^n \\exp(I k i \\Delta x) + r \\left( A^n \\exp(I k (i+1) \\Delta x) - 2A^n \\exp(I k i \\Delta x) + A^n \\exp(I k (i-1) \\Delta x) \\right)\n$$\n两边同除以非零项 $A^n \\exp(I k i \\Delta x)$，我们得到放大因子 $G(k)$ 的表达式：\n$$\nG(k) = \\frac{A^{n+1}}{A^n} = 1 + r \\left( \\exp(I k \\Delta x) - 2 + \\exp(-I k \\Delta x) \\right)\n$$\n使用欧拉恒等式 $\\exp(I\\theta) + \\exp(-I\\theta) = 2\\cos(\\theta)$，我们可以简化括号中的项：\n$$\nG(k) = 1 + r \\left( 2\\cos(k \\Delta x) - 2 \\right) = 1 - 2r \\left( 1 - \\cos(k \\Delta x) \\right)\n$$\n应用三角半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$\nG(k) = 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n稳定性条件是 $|G(k)| \\le 1$。因为 $r > 0$ 且 $\\sin^2(\\cdot) \\ge 0$，所以项 $4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$ 是非负的。这意味着 $G(k)$ 始终为实数且 $G(k) \\le 1$。因此，稳定性条件简化为单个不等式：\n$$\nG(k) \\ge -1\n$$\n$$\n1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\ge -1\n$$\n$$\n2 \\ge 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n$$\nr \\le \\frac{2}{4 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)} = \\frac{1}{2 \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)}\n$$\n该不等式必须对所有可能的波数 $k$ 成立。最严格的，即“最坏情况”下的条件，发生在 $\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$ 取最大值时。$\\sin^2(\\cdot)$ 的最大值为 $1$。这发生在网格能解析的最高频率模式，即 $k \\Delta x = \\pi$ 时。\n将此最大值代入不等式，得到充分必要稳定性条件：\n$$\nr \\le \\frac{1}{2}\n$$\n根据定义 $r=\\alpha\\,\\Delta t/\\Delta x^{2}$，这意味着：\n$$\n\\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{1}{2} \\frac{(\\Delta x)^2}{\\alpha}\n$$\n由此，最大允许时间步长为 $\\Delta t_{\\max} = \\frac{1}{2} \\frac{(\\Delta x)^2}{\\alpha}$。将此与形式 $\\Delta t_{\\max}=C\\,\\Delta x^{2}/\\alpha$ 进行比较，我们发现常数的最大允许值为 $C = 1/2$。\n\n接下来，我们为给定值 $\\Delta x = 8.0 \\times 10^{-4}\\,\\text{m}$ 和 $\\alpha = 8.5 \\times 10^{-6}\\,\\text{m}^{2}\\,\\text{s}^{-1}$ 计算最大稳定时间步长。\n$$\n\\Delta t_{\\max} = \\frac{1}{2} \\frac{(\\Delta x)^2}{\\alpha} = \\frac{1}{2} \\frac{(8.0 \\times 10^{-4}\\,\\text{m})^2}{8.5 \\times 10^{-6}\\,\\text{m}^{2}\\,\\text{s}^{-1}}\n$$\n$$\n\\Delta t_{\\max} = \\frac{1}{2} \\frac{64.0 \\times 10^{-8}}{8.5 \\times 10^{-6}} \\,\\text{s} = \\frac{32.0 \\times 10^{-8}}{8.5 \\times 10^{-6}} \\,\\text{s} = \\frac{32.0}{8.5} \\times 10^{-2} \\,\\text{s}\n$$\n$$\n\\Delta t_{\\max} \\approx 3.764705... \\times 10^{-2} \\,\\text{s}\n$$\n四舍五入到 $4$ 位有效数字，我们得到 $\\Delta t_{\\max} = 0.03765\\,\\text{s}$。\n\n最后，我们基于推导出的放大因子 $G(k) = 1 - 4r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$，来解释选择接近此稳定性极限的 $\\Delta t$ 所带来的后果。\n\n(i) 对正向解中空间温度梯度准确性的影响：\n当 $r$ 接近其极限值 $1/2$ 时，最高频率模式（$k \\Delta x = \\pi$）的放大因子趋近于 $G(\\pi/\\Delta x) = 1 - 4(\\frac{1}{2}) \\sin^2(\\frac{\\pi}{2}) = 1 - 2 = -1$。放大因子为 $-1$ 意味着该模式的振幅不会衰减；相反，它的大小得以保持，但其符号在每个时间步都会翻转。这对应于一种非物理的高频“棋盘状”振荡（例如，在相邻网格点处正负扰动交替出现的空间分布，且整个模式在每个时间步都翻转符号）。热传导方程的真实物理是扩散性的，意味着高频分量应迅速衰减。当 $r \\approx 1/2$ 时，数值格式未能耗散这些模式，从而引入了显著误差，表现为空间振荡。使用有限差分（如 $\\frac{\\partial T}{\\partial x}|_i \\approx \\frac{T_{i+1} - T_{i-1}}{2\\Delta x}$）计算的空间梯度对此类高频内容极为敏感。这些数值振荡的存在将完全破坏计算出的梯度，使其被虚假噪声（而非真实的物理梯度）所主导。因此，在稳定性极限附近运行会严重降低空间梯度的准确性。\n\n(ii) 对 IHCP 反演中使用的梯度的稳定性和条件的影响：\nIHCP 本质上是不适定问题，因为从内部数据反求边界条件 $q(t)$ 需要放大数据中被扩散过程自然且强烈衰减的高频信息。对这种衰减过程进行反演对噪声高度敏感。\n如上所述，当用 $r \\approx 1/2$ 求解正向模型时，它会将自身的高频数值噪声引入到计算的温度场 $T(x_m, t)$ 中。用于 IHCP 的基于梯度的优化算法利用这个计算出的温度与测量温度之间的失配来更新对 $q(t)$ 的估计。梯度计算（通常通过伴随方法完成）会将正向解中的数值噪声解释为必须由边界热流 $q(t)$ 来解释的真实信号。这会迫使优化算法在对 $q(t)$ 的估计中引入虚假的高频振荡，以试图匹配数值噪声。这使得失配泛函的梯度不稳定且高度振荡。反问题的条件数本已很差，而正向求解器的数值不稳定性使其急剧恶化。尽管 Tikhonov 正则化旨在通过惩罚 $q(t)$ 的范数或半范数来抑制此类振荡解，但在稳定性边缘运行的正向求解器会产生如此强烈的数值假象，以至于正则化可能不足以抑制它们，或者可能需要一个不切实际的大正则化参数，而这反过来又会过度平滑估计的热流，从而破坏任何有用的细节。总之，数值格式在 $r \\approx 1/2$ 时的谱缺陷直接污染了数据失配的梯度，导致了一个不稳定且不适定的反演过程。", "answer": "$$\n\\boxed{0.03765}\n$$", "id": "2497720"}, {"introduction": "许多现实世界中的传热问题都是非线性的，例如，当材料属性依赖于温度时。本实践将超越简单的线性情况，进入更真实的非线性逆热传导问题场景。您将推导并应用高斯-牛顿（Gauss-Newton）和列文伯格-马夸特（Levenberg-Marquardt）方法，它们是解决此类问题的核心算法，让您亲身体验迭代优化的核心过程。[@problem_id:2497725]", "problem": "考虑一个厚度为 $L$ 的一维平板，其空间坐标为 $x \\in [0,L]$。其热导率依赖于温度，$k(T) = k_0 \\left(1 + \\beta \\left(T - T_{\\mathrm{ref}}\\right)\\right)$，密度 $\\rho$ 和热容 $c_p$ 为常数。正向传热模型由瞬态能量平衡方程\n$$\n\\rho c_p \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(k(T)\\,\\frac{\\partial T}{\\partial x}\\right),\n$$\n控制，并服从于给定的初始温度场和边界条件。在边界 $x=0$ 处，热通量 $q(t)$ 未知，并通过一个固定的时间基被一个系数向量 $\\mathbf{m} \\in \\mathbb{R}^M$ 参数化，使得 $q(t;\\mathbf{m}) = \\sum_{j=1}^M m_j \\,\\varphi_j(t)$。在 $x=x_m$ 和离散时间点 $t_1,\\dots,t_N$ 处可获得温度测量值，从而产生数据 $\\mathbf{d} \\in \\mathbb{R}^N$。将正向响应映射 $\\mathbf{y}(\\mathbf{m}) \\in \\mathbb{R}^N$ 定义为在 $(x_m,t_i)$，$i=1,\\dots,N$ 处的模型预测温度向量。\n\n由于 $k(T)$ 依赖于 $T$，正向映射 $\\mathbf{y}(\\mathbf{m})$ 是非线性的。逆热传导问题 (Inverse Heat Conduction Problem, IHCP) 被构建为一个 Tikhonov 正则化的加权非线性最小二乘优化问题：\n$$\n\\min_{\\mathbf{m} \\in \\mathbb{R}^M} \\; \\Phi(\\mathbf{m}) \\equiv \\frac{1}{2}\\left\\| \\mathbf{W}\\left(\\mathbf{y}(\\mathbf{m}) - \\mathbf{d}\\right) \\right\\|_2^2 + \\frac{\\gamma}{2}\\left\\|\\mathbf{L}\\left(\\mathbf{m} - \\mathbf{m}_0\\right)\\right\\|_2^2,\n$$\n其中 $\\mathbf{W} \\in \\mathbb{R}^{N \\times N}$ 是一个对称正定加权矩阵，$\\gamma>0$ 是一个正则化参数，$\\mathbf{L} \\in \\mathbb{R}^{P \\times M}$ 是一个正则化算子，$\\mathbf{m}_0$ 是先验。\n\n任务：\n- 从 $\\Phi(\\mathbf{m})$ 的定义、模型残差的一阶泰勒展开以及最小二乘原理出发，推导 Gauss–Newton 步 $\\mathbf{s}_{\\mathrm{GN}}$，其为一个关于雅可比矩阵和残差向量的线性系统的解。\n- 通过引入阻尼参数 $\\lambda \\ge 0$ 和对角缩放矩阵 $\\mathbf{D} \\succ \\mathbf{0}$，推导 Levenberg–Marquardt (LM) 步 $\\mathbf{s}_{\\mathrm{LM}}$ 作为一个修正的正规方程。清晰地说明 $\\mathbf{D}$ 如何进入该系统。\n- 简要讨论两种处理由 $k(T)$ 引起的非凸性的全局化策略：使用充分下降条件的回溯线搜索，以及基于实际减少量与预测减少量之比的信赖域策略。陈述一个充分下降条件，并给出 Gauss–Newton 二次模型下预测减少量的表达式。\n- 数值微实例：在当前迭代点 $\\mathbf{m}^{(k)}$，假设白化残差和白化雅可比矩阵（即右乘 $\\mathbf{W}$ 之后）为\n$$\n\\mathbf{r} \\equiv \\mathbf{W}\\left(\\mathbf{y}(\\mathbf{m}^{(k)}) - \\mathbf{d}\\right) = \\begin{bmatrix} 0.4 \\\\ -0.2 \\end{bmatrix}, \\qquad\n\\mathbf{J} \\equiv \\mathbf{W}\\,\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{m}}(\\mathbf{m}^{(k)}) = \\begin{bmatrix} 1.0 & 0.5 \\\\ 0.2 & 0.8 \\end{bmatrix}.\n$$\n使用 Tikhonov 项，其中 $\\gamma = 0.1$，$\\mathbf{L} = \\mathbf{I}$，并假设 $\\mathbf{m}^{(k)} = \\mathbf{m}_0$，因此正则化梯度项在 $\\mathbf{m}^{(k)}$ 处为零。对于 LM 缩放，取 $\\mathbf{D} = \\mathrm{diag}\\!\\left(\\mathbf{J}^{\\top}\\mathbf{J}\\right)$，阻尼 $\\lambda = 0.5$。计算 Gauss–Newton 步 $\\mathbf{s}_{\\mathrm{GN}}$ 和 Levenberg–Marquardt 步 $\\mathbf{s}_{\\mathrm{LM}}$，然后计算比值\n$$\n\\eta \\equiv \\frac{\\|\\mathbf{s}_{\\mathrm{LM}}\\|_2}{\\|\\mathbf{s}_{\\mathrm{GN}}\\|_2}.\n$$\n将 $\\eta$ 的最终答案表示为一个无量纲实数，并四舍五入到四位有效数字。", "solution": "此问题要求为一个源于逆热传导问题(IHCP)的非线性最小二乘问题推导优化步骤，并进行数值计算。问题陈述已经过验证，被认为是科学上合理、适定且完整的。我们接下来进行严格的、分步的求解。\n\n首先，我们处理 Gauss–Newton 和 Levenberg–Marquardt 更新步的推导。需要最小化的目标函数是\n$$\n\\Phi(\\mathbf{m}) = \\frac{1}{2}\\left\\| \\mathbf{W}\\left(\\mathbf{y}(\\mathbf{m}) - \\mathbf{d}\\right) \\right\\|_2^2 + \\frac{\\gamma}{2}\\left\\|\\mathbf{L}\\left(\\mathbf{m} - \\mathbf{m}_0\\right)\\right\\|_2^2.\n$$\n我们定义白化模型残差 $\\mathbf{r}(\\mathbf{m}) = \\mathbf{W}(\\mathbf{y}(\\mathbf{m}) - \\mathbf{d})$ 和正则化残差 $\\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}) = \\mathbf{L}(\\mathbf{m} - \\mathbf{m}_0)$。现在目标函数为 $\\Phi(\\mathbf{m}) = \\frac{1}{2}\\|\\mathbf{r}(\\mathbf{m})\\|_2^2 + \\frac{\\gamma}{2}\\|\\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m})\\|_2^2$。\n\n为了推导迭代更新，我们考虑一个迭代点 $\\mathbf{m}^{(k)}$，并寻求一个步长 $\\mathbf{s}$ 使得 $\\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} + \\mathbf{s}$ 能最小化 $\\Phi$。Gauss–Newton 方法基于非线性残差 $\\mathbf{r}(\\mathbf{m})$ 在 $\\mathbf{m}^{(k)}$ 附近的线性近似。一阶泰勒展开给出\n$$\n\\mathbf{r}(\\mathbf{m}^{(k)} + \\mathbf{s}) \\approx \\mathbf{r}(\\mathbf{m}^{(k)}) + \\mathbf{J}^{(k)}\\mathbf{s},\n$$\n其中 $\\mathbf{J}^{(k)} \\equiv \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{m}}(\\mathbf{m}^{(k)}) = \\mathbf{W} \\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{m}}(\\mathbf{m}^{(k)})$ 是在 $\\mathbf{m}^{(k)}$ 处的白化雅可比矩阵。正则化残差已经是关于 $\\mathbf{m}$ 的线性函数，所以\n$$\n\\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)} + \\mathbf{s}) = \\mathbf{L}(\\mathbf{m}^{(k)} + \\mathbf{s} - \\mathbf{m}_0) = \\mathbf{L}(\\mathbf{m}^{(k)} - \\mathbf{m}_0) + \\mathbf{L}\\mathbf{s} = \\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)}) + \\mathbf{L}\\mathbf{s}.\n$$\n将这些近似代入目标函数，得到关于步长 $\\mathbf{s}$ 的 $\\Phi$ 的二次模型：\n$$\n\\widehat{\\Phi}(\\mathbf{s}) = \\frac{1}{2}\\left\\| \\mathbf{r}(\\mathbf{m}^{(k)}) + \\mathbf{J}^{(k)}\\mathbf{s} \\right\\|_2^2 + \\frac{\\gamma}{2}\\left\\| \\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)}) + \\mathbf{L}\\mathbf{s} \\right\\|_2^2.\n$$\n为了找到最小化该二次模型的步长 $\\mathbf{s}_{\\mathrm{GN}}$，我们将其关于 $\\mathbf{s}$ 的梯度设为零：$\\nabla_{\\mathbf{s}}\\widehat{\\Phi}(\\mathbf{s}) = \\mathbf{0}$。\n$$\n\\nabla_{\\mathbf{s}}\\widehat{\\Phi}(\\mathbf{s}) = (\\mathbf{J}^{(k)})^\\top \\left( \\mathbf{r}(\\mathbf{m}^{(k)}) + \\mathbf{J}^{(k)}\\mathbf{s} \\right) + \\gamma \\mathbf{L}^\\top \\left( \\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)}) + \\mathbf{L}\\mathbf{s} \\right) = \\mathbf{0}.\n$$\n重新整理各项以求解 $\\mathbf{s}$，我们得到用于计算 $\\mathbf{s}_{\\mathrm{GN}}$ 步的 Gauss–Newton 正规方程：\n$$\n\\left( (\\mathbf{J}^{(k)})^\\top \\mathbf{J}^{(k)} + \\gamma \\mathbf{L}^\\top \\mathbf{L} \\right) \\mathbf{s}_{\\mathrm{GN}} = - \\left( (\\mathbf{J}^{(k)})^\\top \\mathbf{r}(\\mathbf{m}^{(k)}) + \\gamma \\mathbf{L}^\\top \\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)}) \\right).\n$$\n左边的矩阵是 $\\Phi$ 的 Hessian 矩阵的正则化 Gauss–Newton 近似。右边的向量是 $\\Phi$ 在 $\\mathbf{m}^{(k)}$ 处的梯度的负值。\n\nLevenberg–Marquardt (LM) 方法修改了 Gauss–Newton 步以提高鲁棒性，特别是当 Gauss–Newton Hessian 矩阵是病态的或非正定时。它引入了一个阻尼参数 $\\lambda \\ge 0$ 和一个对角缩放矩阵 $\\mathbf{D} \\succ \\mathbf{0}$。LM 步 $\\mathbf{s}_{\\mathrm{LM}}$ 是以下修正线性系统的解：\n$$\n\\left( (\\mathbf{J}^{(k)})^\\top \\mathbf{J}^{(k)} + \\gamma \\mathbf{L}^\\top \\mathbf{L} + \\lambda \\mathbf{D} \\right) \\mathbf{s}_{\\mathrm{LM}} = - \\left( (\\mathbf{J}^{(k)})^\\top \\mathbf{r}(\\mathbf{m}^{(k)}) + \\gamma \\mathbf{L}^\\top \\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)}) \\right).\n$$\n项 $\\lambda \\mathbf{D}$ 起到类似信赖域正则化的作用。当 $\\lambda$ 很大时，步长很小且指向最速下降方向。当 $\\lambda$ 很小时，步长接近 Gauss–Newton 步 $\\mathbf{s}_{\\mathrm{GN}}$。缩放矩阵 $\\mathbf{D}$，通常选择为 $\\mathbf{D} = \\mathrm{diag}((\\mathbf{J}^{(k)})^\\top \\mathbf{J}^{(k)})$，确保阻尼被适当地应用于不同尺度的参数。\n\n由于 $k(T)$ 的非线性，目标函数 $\\Phi(\\mathbf{m})$ 可能是非凸的，Gauss–Newton 或 LM 步可能不会导致 $\\Phi$ 的下降。需要全局化策略。两种常见的策略是：\n1.  **回溯线搜索**：计算一个搜索方向 $\\mathbf{s}$（例如 $\\mathbf{s}_{\\mathrm{GN}}$）。然后，寻找一个步长 $\\alpha \\in (0, 1]$ 以确保目标函数有充分的下降。新的迭代点是 $\\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} + \\alpha\\mathbf{s}$。必须满足一个充分下降条件，例如 Armijo 条件：\n    $$\n    \\Phi(\\mathbf{m}^{(k)} + \\alpha\\mathbf{s}) \\le \\Phi(\\mathbf{m}^{(k)}) + c_1 \\alpha \\nabla\\Phi(\\mathbf{m}^{(k)})^\\top \\mathbf{s},\n    $$\n    其中 $c_1 \\in (0, 1)$ 是一个很小的常数，通常为 $c_1=10^{-4}$。从 $\\alpha=1$ 开始，并不断减小它直到条件满足为止。\n2.  **信赖域策略**：在每个迭代点 $\\mathbf{m}^{(k)}$，构建一个二次模型 $q_k(\\mathbf{s})$（例如 Gauss–Newton 模型 $\\widehat{\\Phi}(\\mathbf{s})$），该模型仅在半径 $\\Delta_k > 0$ 内被认为是 $\\Phi(\\mathbf{m}^{(k)}+\\mathbf{s})$ 的良好近似。通过最小化 $q_k(\\mathbf{s})$ 且满足 $\\|\\mathbf{s}\\| \\le \\Delta_k$ 来找到步长 $\\mathbf{s}_k$。步长的质量通过实际减少量与预测减少量之比 $\\rho_k = \\frac{\\text{ared}_k}{\\text{pred}_k}$ 来评估。实际减少量是 $\\text{ared}_k = \\Phi(\\mathbf{m}^{(k)}) - \\Phi(\\mathbf{m}^{(k)} + \\mathbf{s}_k)$。在 Gauss–Newton 二次模型下，预测减少量是模型函数 $q_k$ 的下降量，由下式给出：\n    $$\n    \\text{pred}_k = q_k(\\mathbf{0}) - q_k(\\mathbf{s}_k) = - \\nabla\\Phi(\\mathbf{m}^{(k)})^\\top \\mathbf{s}_k - \\frac{1}{2}\\mathbf{s}_k^\\top \\mathbf{H}_{\\mathrm{GN}} \\mathbf{s}_k,\n    $$\n    其中 $\\mathbf{H}_{\\mathrm{GN}} = (\\mathbf{J}^{(k)})^\\top \\mathbf{J}^{(k)} + \\gamma \\mathbf{L}^\\top \\mathbf{L}$ 是 Gauss-Newton Hessian 近似。根据 $\\rho_k$ 的值，决定接受或拒绝该步长，并为下一次迭代更新信赖域半径 $\\Delta_k$。\n\n最后，我们对该微实例进行数值计算。\n给定的数据是：\n$\\mathbf{r} = \\begin{bmatrix} 0.4 \\\\ -0.2 \\end{bmatrix}$，$\\mathbf{J} = \\begin{bmatrix} 1.0 & 0.5 \\\\ 0.2 & 0.8 \\end{bmatrix}$，$\\gamma = 0.1$，$\\mathbf{L} = \\mathbf{I}$，$\\lambda = 0.5$。\n假设 $\\mathbf{m}^{(k)} = \\mathbf{m}_0$ 意味着正则化残差 $\\mathbf{r}_{\\mathrm{reg}}(\\mathbf{m}^{(k)}) = \\mathbf{L}(\\mathbf{m}^{(k)} - \\mathbf{m}_0) = \\mathbf{0}$。这使得两个步长的线性系统的右端项 (RHS) 都简化为 $-\\mathbf{J}^\\top \\mathbf{r}$。\n\n首先，计算右端项向量：\n$$\n\\mathbf{J}^\\top \\mathbf{r} = \\begin{bmatrix} 1.0 & 0.2 \\\\ 0.5 & 0.8 \\end{bmatrix} \\begin{bmatrix} 0.4 \\\\ -0.2 \\end{bmatrix} = \\begin{bmatrix} (1.0)(0.4) + (0.2)(-0.2) \\\\ (0.5)(0.4) + (0.8)(-0.2) \\end{bmatrix} = \\begin{bmatrix} 0.4 - 0.04 \\\\ 0.2 - 0.16 \\end{bmatrix} = \\begin{bmatrix} 0.36 \\\\ 0.04 \\end{bmatrix}.\n$$\n因此，右端项是 $-\\begin{bmatrix} 0.36 \\\\ 0.04 \\end{bmatrix}$。\n\n接下来，计算 Gauss–Newton 系统的矩阵 $\\mathbf{H}_{\\mathrm{GN}} = \\mathbf{J}^\\top\\mathbf{J} + \\gamma\\mathbf{L}^\\top\\mathbf{L}$：\n$$\n\\mathbf{J}^\\top\\mathbf{J} = \\begin{bmatrix} 1.0 & 0.2 \\\\ 0.5 & 0.8 \\end{bmatrix} \\begin{bmatrix} 1.0 & 0.5 \\\\ 0.2 & 0.8 \\end{bmatrix} = \\begin{bmatrix} 1.0^2 + 0.2^2 & (1.0)(0.5) + (0.2)(0.8) \\\\ (0.5)(1.0) + (0.8)(0.2) & 0.5^2 + 0.8^2 \\end{bmatrix} = \\begin{bmatrix} 1.04 & 0.66 \\\\ 0.66 & 0.89 \\end{bmatrix}.\n$$\n$$\n\\mathbf{H}_{\\mathrm{GN}} = \\begin{bmatrix} 1.04 & 0.66 \\\\ 0.66 & 0.89 \\end{bmatrix} + 0.1 \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 1.14 & 0.66 \\\\ 0.66 & 0.99 \\end{bmatrix}.\n$$\n通过求解 $\\mathbf{H}_{\\mathrm{GN}} \\mathbf{s}_{\\mathrm{GN}} = -\\mathbf{J}^\\top \\mathbf{r}$ 来找到 Gauss–Newton 步 $\\mathbf{s}_{\\mathrm{GN}}$：\n$$\n\\begin{bmatrix} 1.14 & 0.66 \\\\ 0.66 & 0.99 \\end{bmatrix} \\mathbf{s}_{\\mathrm{GN}} = \\begin{bmatrix} -0.36 \\\\ -0.04 \\end{bmatrix}.\n$$\n该矩阵的行列式是 $\\det(\\mathbf{H}_{\\mathrm{GN}}) = (1.14)(0.99) - (0.66)^2 = 1.1286 - 0.4356 = 0.693$。\n解是 $\\mathbf{s}_{\\mathrm{GN}} = \\frac{1}{0.693} \\begin{bmatrix} 0.99 & -0.66 \\\\ -0.66 & 1.14 \\end{bmatrix} \\begin{bmatrix} -0.36 \\\\ -0.04 \\end{bmatrix} = \\frac{1}{0.693} \\begin{bmatrix} -0.3564 + 0.0264 \\\\ 0.2376 - 0.0456 \\end{bmatrix} = \\frac{1}{0.693} \\begin{bmatrix} -0.33 \\\\ 0.192 \\end{bmatrix}$。\nL2 范数的平方是 $\\|\\mathbf{s}_{\\mathrm{GN}}\\|_2^2 = \\frac{(-0.33)^2 + (0.192)^2}{(0.693)^2} = \\frac{0.1089 + 0.036864}{0.480249} = \\frac{0.145764}{0.480249} \\approx 0.303527$。\n因此，$\\|\\mathbf{s}_{\\mathrm{GN}}\\|_2 \\approx \\sqrt{0.303527} \\approx 0.550933$。\n\n现在，我们计算 Levenberg–Marquardt 步 $\\mathbf{s}_{\\mathrm{LM}}$。缩放矩阵是 $\\mathbf{D} = \\mathrm{diag}(\\mathbf{J}^\\top\\mathbf{J}) = \\mathrm{diag}\\left(\\begin{bmatrix} 1.04 & 0.66 \\\\ 0.66 & 0.89 \\end{bmatrix}\\right) = \\begin{bmatrix} 1.04 & 0 \\\\ 0 & 0.89 \\end{bmatrix}$。\nLM 矩阵是 $\\mathbf{H}_{\\mathrm{LM}} = \\mathbf{H}_{\\mathrm{GN}} + \\lambda\\mathbf{D}$：\n$$\n\\mathbf{H}_{\\mathrm{LM}} = \\begin{bmatrix} 1.14 & 0.66 \\\\ 0.66 & 0.99 \\end{bmatrix} + 0.5 \\begin{bmatrix} 1.04 & 0 \\\\ 0 & 0.89 \\end{bmatrix} = \\begin{bmatrix} 1.14+0.52 & 0.66 \\\\ 0.66 & 0.99+0.445 \\end{bmatrix} = \\begin{bmatrix} 1.66 & 0.66 \\\\ 0.66 & 1.435 \\end{bmatrix}.\n$$\nLM 步 $\\mathbf{s}_{\\mathrm{LM}}$ 通过求解 $\\mathbf{H}_{\\mathrm{LM}} \\mathbf{s}_{\\mathrm{LM}} = -\\mathbf{J}^\\top \\mathbf{r}$ 得到：\n$$\n\\begin{bmatrix} 1.66 & 0.66 \\\\ 0.66 & 1.435 \\end{bmatrix} \\mathbf{s}_{\\mathrm{LM}} = \\begin{bmatrix} -0.36 \\\\ -0.04 \\end{bmatrix}.\n$$\n行列式是 $\\det(\\mathbf{H}_{\\mathrm{LM}}) = (1.66)(1.435) - (0.66)^2 = 2.3821 - 0.4356 = 1.9465$。\n解是 $\\mathbf{s}_{\\mathrm{LM}} = \\frac{1}{1.9465} \\begin{bmatrix} 1.435 & -0.66 \\\\ -0.66 & 1.66 \\end{bmatrix} \\begin{bmatrix} -0.36 \\\\ -0.04 \\end{bmatrix} = \\frac{1}{1.9465} \\begin{bmatrix} -0.5166 + 0.0264 \\\\ 0.2376 - 0.0664 \\end{bmatrix} = \\frac{1}{1.9465} \\begin{bmatrix} -0.4902 \\\\ 0.1712 \\end{bmatrix}$。\nL2 范数的平方是 $\\|\\mathbf{s}_{\\mathrm{LM}}\\|_2^2 = \\frac{(-0.4902)^2 + (0.1712)^2}{(1.9465)^2} = \\frac{0.24029604 + 0.02930944}{3.78886225} = \\frac{0.26960548}{3.78886225} \\approx 0.0711576$。\n因此，$\\|\\mathbf{s}_{\\mathrm{LM}}\\|_2 \\approx \\sqrt{0.0711576} \\approx 0.266754$。\n\n最后，我们计算比值 $\\eta$：\n$$\n\\eta = \\frac{\\|\\mathbf{s}_{\\mathrm{LM}}\\|_2}{\\|\\mathbf{s}_{\\mathrm{GN}}\\|_2} \\approx \\frac{0.266754}{0.550933} \\approx 0.484186.\n$$\n四舍五入到四位有效数字，得到 $\\eta \\approx 0.4842$。", "answer": "$$\\boxed{0.4842}$$", "id": "2497725"}, {"introduction": "这项综合性实践将正向建模和灵敏度分析整合到一个强大的实验设计框架中。您将构建一个完整的仿真工具，以确定所提出的实验设置是否能够成功地同时辨识多个未知的热物理性质。通过计算费雪信息矩阵（Fisher Information Matrix）并应用统计判据，您将学会如何定量评估参数的“可辨识性”（identifiability），这是确保实验能够产生有意义结果的关键步骤。[@problem_id:2497727]", "problem": "考虑一个总厚度为 $L=L_1+L_2$ 的一维双层平板固体，其左侧为第 $1$ 层，热导率为 $k_1$，密度为 $\\rho_1$，比热为 $c_{p,1}$，厚度为 $L_1$；右侧为第 $2$ 层，热导率为 $k_2$，密度为 $\\rho_2$，比热为 $c_{p,2}$，厚度为 $L_2$。各层之间以有限的热接触电阻 $R_{\\mathrm{int}}$（单位为 $\\mathrm{m^2\\,K/W}$）结合。位于 $x=0$ 的左边界承受一个给定的、随时间变化的表面热通量 $q''(t)$，而位于 $x=L$ 的右边界暴露在温度为 $T_{\\infty}$、对流换热系数为 $h$ 的环境空气中。初始温度是均匀的，等于 $T_{\\infty}$。假设横截面积为单位面积。\n\n从各层的一维瞬态热传导方程出发，\n$ \\rho_i c_{p,i}\\,\\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(k_i\\,\\frac{\\partial T}{\\partial x}\\right) \\quad \\text{for} \\quad x\\in\\text{layer } i,\\; i\\in\\{1,2\\}, $\n边界条件为\n$ -k_1 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=0} = q''(t),\\quad -k_2 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L} = h\\left(T(L,t)-T_{\\infty}\\right), $\n以及位于 $x=L_1$ 接触面处的界面条件，\n$ -k_1 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L_1^-} = -k_2 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L_1^+} = q_{\\mathrm{int}}(t),\\quad T(L_1^+,t) - T(L_1^-,t) = q_{\\mathrm{int}}(t) R_{\\mathrm{int}}. $\n\n你需要提出并评估一个逆热传导识别实验，该实验使用多个瞬态热激励 $q''(t)$，在存在标准差已知的加性、独立同分布高斯测量噪声的情况下，从背面温度 $T(L,t)$ 的测量值中解耦未知参数矢量 $ \\boldsymbol{\\theta}=\\big[k_1,\\,k_2,\\,R_{\\mathrm{int}}\\big]^{\\top} $。$ \\boldsymbol{\\theta} $ 的可识别性将通过 Fisher 信息矩阵进行评估。\n\n你的程序必须从第一性原理出发实现以下步骤，不得使用任何黑箱逆问题求解器：\n\n- 空间半离散化：通过将每层 $i$ 划分成 $N_i$ 个宽度为 $\\Delta x_i=L_i/N_i$ 的均匀控制体积，并将节点置于控制体积的中心，为每个节点编写瞬态能量平衡方程，从而推导一个半离散状态空间模型。在导热系数分别为 $k_j$ 和 $k_{j+1}$、宽度分别为 $\\Delta x_j$ 和 $\\Delta x_{j+1}$ 的相邻节点 $j$ 和 $j+1$ 之间，节点间的热阻必须离散化为\n$ R_{j+\\frac{1}{2}} = \\frac{\\Delta x_j}{2 k_j} + \\frac{\\Delta x_{j+1}}{2 k_{j+1}} + R_{\\mathrm{int},\\,j+\\frac{1}{2}}, $\n其中，仅在材料界面处 $ R_{\\mathrm{int},\\,j+\\frac{1}{2}}=R_{\\mathrm{int}} $，而在所有其他界面处 $ R_{\\mathrm{int},\\,j+\\frac{1}{2}}=0 $。相应的热导为 $ G_{j+\\frac{1}{2}} = 1/R_{j+\\frac{1}{2}} $。组装全局热容矩阵 $ \\mathbf{C} $（其对角线元素为 $ C_j=\\rho_j c_{p,j}\\,\\Delta x_j $）和由 $ G_{j+\\frac{1}{2}} $ 定义的具有三对角结构的对称热导矩阵 $ \\mathbf{K} $。通过在节点 $j=1$ 处添加热通量 $q''(t)$ 作为源项来施加左侧 Neumann 边界条件，并通过在最后一个节点处添加一个连接到 $T_{\\infty}$ 的边界热导 $h$ 来施加右侧对流边界条件。\n\n- 时间积分：从初始条件 $ T(x,0)=T_{\\infty} $ 出发，在每个实验持续时间内，使用 Crank–Nicolson 方法对半离散系统 $ \\mathbf{C}\\,\\dot{\\mathbf{T}}(t) + \\mathbf{K}\\,\\mathbf{T}(t) = \\mathbf{f}(t) $ 进行时间推进，以获得在指定时间采样的背面温度 $ y(t)=T(L,t) $。对源项 $ \\mathbf{f}(t) $ 使用梯形法则。\n\n- 灵敏度和 Fisher 信息：对于一个给定的、由一个或多个激励信号 $ q''_m(t) $ 及相应的测量时间网格组成的实验设计，通过前向有限差分法来近似灵敏度矢量 $ \\partial y/\\partial \\theta_\\ell $，其中对 $ \\boldsymbol{\\theta} $ 的每个分量 $ \\theta_\\ell $ 独立施加一个相对扰动步长 $ \\epsilon_\\ell $，并为每次扰动重新计算正向模型。将所有激励下的所有测量值堆叠成一个矢量 $ \\mathbf{y} $，并将相应的灵敏度矢量堆叠成雅可比矩阵 $ \\mathbf{S} $。对于方差为 $ \\sigma_T^2 $ 的独立高斯噪声，计算 Fisher 信息矩阵\n$ \\mathbf{F} = \\frac{1}{\\sigma_T^2}\\,\\mathbf{S}^{\\top}\\mathbf{S}. $\n\n- 可识别性判定准则：将 Cramér–Rao 下界协方差定义为 $ \\mathbf{C}_{\\mathrm{CRLB}} = \\mathbf{F}^{-1} $（如果 $ \\mathbf{F} $ 是非奇异的），否则定义为 $ \\mathbf{C}_{\\mathrm{CRLB}} = \\mathbf{F}^{+} $（Moore–Penrose 伪逆）。使用真实参数值 $ \\boldsymbol{\\theta}_{\\star} $，对于一个给定的设计，如果以下两个条件都成立，则声明三元组 $ \\boldsymbol{\\theta} $ 是可识别的：\n    - 在 $ \\ell_2 $ 范数下的条件数 $ \\kappa(\\mathbf{F}) $ 满足 $ \\kappa(\\mathbf{F}) \\le 10^{12} $。\n    - 边际相对标准差，定义为 $ r_\\ell = \\sqrt{[\\mathbf{C}_{\\mathrm{CRLB}}]_{\\ell\\ell}}\\,/\\,\\max(|\\theta_{\\star,\\ell}|,\\,\\theta_{\\min}) $（其中 $ \\theta_{\\min}=10^{-12} $），对所有的 $ \\ell\\in\\{1,2,3\\} $ 均满足 $ r_\\ell \\le 0.2 $。\n\n所有测试用例均使用以下常量：\n- 环境温度 $ T_{\\infty} = 293\\ \\mathrm{K} $。\n- 对流换热系数 $ h = 15\\ \\mathrm{W\\,m^{-2}\\,K^{-1}} $。\n- 测量噪声标准差 $ \\sigma_T = 0.02\\ \\mathrm{K} $。\n- 离散化节点 $ N_1=20 $，$ N_2=30 $。\n- 时间步长 $ \\Delta t = 0.001\\ \\mathrm{s} $。\n- 测量采样间隔 $ \\Delta t_{\\mathrm{samp}} = 0.01\\ \\mathrm{s} $。\n- 有限差分相对步长 $ \\epsilon_{k_1}=\\epsilon_{k_2}=10^{-2} $，$ \\epsilon_{R}=10^{-2} $，并设有绝对下限 $ \\delta_{R}=10^{-7}\\ \\mathrm{m^2\\,K/W} $。\n\n将激励信号定义为方波脉冲：\n$ q''(t) = q_0 $ for $ 0 \\le t  t_{\\mathrm{on}} $，以及 $ q''(t) = 0 $ for $ t \\ge t_{\\mathrm{on}} $，在总持续时间 $ t_{\\mathrm{end}} $ 内进行模拟。\n\n你的程序必须评估以下三个实验设计（测试套件），每个设计的材料属性均以国际单位制表示：\n\n- 测试用例 1（单次激励，中等接触电阻）：\n    - 材料与几何：$ L_1=2\\times 10^{-3}\\ \\mathrm{m} $，$ L_2=3\\times 10^{-3}\\ \\mathrm{m} $，$ k_1=200\\ \\mathrm{W\\,m^{-1}\\,K^{-1}} $，$ k_2=20\\ \\mathrm{W\\,m^{-1}\\,K^{-1}} $，$ \\rho_1=8000\\ \\mathrm{kg\\,m^{-3}} $，$ c_{p,1}=500\\ \\mathrm{J\\,kg^{-1}\\,K^{-1}} $，$ \\rho_2=1200\\ \\mathrm{kg\\,m^{-3}} $，$ c_{p,2}=1400\\ \\mathrm{J\\,kg^{-1}\\,K^{-1}} $，$ R_{\\mathrm{int}}=1\\times 10^{-4}\\ \\mathrm{m^2\\,K/W} $。\n    - 激励集：一个脉冲，参数为 $ q_0=8\\times 10^{4}\\ \\mathrm{W\\,m^{-2}} $，$ t_{\\mathrm{on}}=0.3\\ \\mathrm{s} $，$ t_{\\mathrm{end}}=1.2\\ \\mathrm{s} $。\n\n- 测试用例 2（多次激励以解耦参数）：\n    - 材料与几何同测试用例 1。\n    - 激励集：三个脉冲，作为独立的实验进行模拟并汇总结果：\n        - 激励 A：$ q_0=1.2\\times 10^{5}\\ \\mathrm{W\\,m^{-2}} $，$ t_{\\mathrm{on}}=0.05\\ \\mathrm{s} $，$ t_{\\mathrm{end}}=0.5\\ \\mathrm{s} $。\n        - 激励 B：$ q_0=7\\times 10^{4}\\ \\mathrm{W\\,m^{-2}} $，$ t_{\\mathrm{on}}=0.2\\ \\mathrm{s} $，$ t_{\\mathrm{end}}=1.0\\ \\mathrm{s} $。\n        - 激励 C：$ q_0=5\\times 10^{4}\\ \\mathrm{W\\,m^{-2}} $，$ t_{\\mathrm{on}}=0.6\\ \\mathrm{s} $，$ t_{\\mathrm{end}}=2.0\\ \\mathrm{s} $。\n\n- 测试用例 3（近乎完美接触，对 $ R_{\\mathrm{int}} $ 的可识别性构成挑战）：\n    - 同测试用例 2，但 $ R_{\\mathrm{int}}=1\\times 10^{-6}\\ \\mathrm{m^2\\,K/W} $。\n\n程序要求：\n- 完全按照描述实现半离散模型的组装和 Crank–Nicolson 时间积分器，其中热导 $ G_{j+\\frac{1}{2}} = 1/R_{j+\\frac{1}{2}} $ 在适当位置使用半控制体积电阻和界面电阻。\n- 使用指定的扰动大小，通过前向有限差分法近似灵敏度。\n- 构建 Fisher 信息矩阵并评估可识别性判定准则。\n- 对于每个测试用例，计算一个布尔值，以指示 $ \\big[k_1,k_2,R_{\\mathrm{int}}\\big] $ 在所述准则下是否可识别。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、按测试用例 $1$ 至 $3$ 顺序排列的逗号分隔列表形式的结果，其中每个条目是相应测试用例的布尔可识别性判定结果（例如，$[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True} ]$）。不应打印任何额外文本。", "solution": "我们从每个均质层 $i\\in\\{1,2\\}$ 的一维瞬态热传导方程开始，\n$ \\rho_i c_{p,i} \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\!\\left(k_i \\frac{\\partial T}{\\partial x}\\right), $\n其在 $x=0$ 和 $x=L$ 处的边界条件为\n$ -k_1 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=0} = q''(t), \\quad -k_2 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L} = h \\left(T(L,t)-T_{\\infty}\\right), $\n以及在接触面 $x=L_1$ 处，热通量连续，但存在一个与热通量成正比的有限温跃，\n$ -k_1 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L_1^-} = -k_2 \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=L_1^+} = q_{\\mathrm{int}}(t), $\n$ T(L_1^+,t)-T(L_1^-,t) = q_{\\mathrm{int}}(t) R_{\\mathrm{int}}. $\n我们假设横截面积为单位面积，初始条件为 $ T(x,0) = T_{\\infty} $。\n\n为了构建一个适用于逆向分析的、鲁棒且物理上忠实的数值正向模型，我们使用有限体积法。设第 $i$ 层被划分为 $N_i$ 个宽度均匀的控制体积 $\\Delta x_i=L_i/N_i$，节点温度 $T_j(t)$ 位于每个控制体积的中心。节点 $j$ 的能量平衡方程为\n$ C_j \\frac{\\mathrm{d} T_j}{\\mathrm{d} t} = \\sum_{\\text{faces}} G_{j+\\frac{1}{2}} \\left( T_{j+1}-T_j \\right) + \\sum_{\\text{faces}} G_{j-\\frac{1}{2}} \\left( T_{j-1}-T_j \\right) + s_j(t), $\n其中节点热容为 $ C_j = \\rho_j c_{p,j} \\Delta x_j $。在相邻控制体积 $j$ 和 $j+1$ 之间的每个内部界面上，热阻包括两个半控制体积的传导热阻，并且如果该界面与材料界面重合，还包括界面电阻：\n$ R_{j+\\frac{1}{2}} = \\frac{\\Delta x_j}{2 k_j} + \\frac{\\Delta x_{j+1}}{2 k_{j+1}} + R_{\\mathrm{int},\\,j+\\frac{1}{2}}, $\n其中在 $ x=L_1 $ 处 $ R_{\\mathrm{int},\\,j+\\frac{1}{2}}=R_{\\mathrm{int}} $，在其他地方 $ R_{\\mathrm{int},\\,j+\\frac{1}{2}}=0 $。相应的热导为 $ G_{j+\\frac{1}{2}} = 1/R_{j+\\frac{1}{2}} $。左侧 Neumann 边界在节点 $j=1$ 处贡献了一个源项 $ s_1(t)=q''(t) $，而最后一个节点 $j=N=N_1+N_2$ 处的右侧对流边界被整合为一个额外的边界热导 $ G_{\\mathrm{conv}}=h $，连接到一个温度固定为 $ T_{\\infty} $ 的环境节点，这会修改最后一行的平衡方程，使其包含 $ +h ( T_{\\infty} - T_N ) $，在线性形式中通过将 $ h $ 加到热导矩阵的对角线上并将 $ h T_{\\infty} $ 加到源矢量中来表示。\n\n将所有节点温度收集到 $ \\mathbf{T}(t)\\in\\mathbb{R}^N $中，半离散系统为\n$ \\mathbf{C} \\,\\dot{\\mathbf{T}}(t) + \\mathbf{K}\\,\\mathbf{T}(t) = \\mathbf{f}(t), $\n其中 $ \\mathbf{C}=\\mathrm{diag}(C_1,\\dots,C_N) $ 为对角矩阵，$ \\mathbf{K} $ 是由 $ G_{j\\pm \\frac{1}{2}} $ 和对流贡献组装的对称三对角矩阵，源矢量 $ \\mathbf{f}(t) $ 中 $ f_1(t)=q''(t) $ 且 $ f_N(t) $ 包含 $ h T_{\\infty} $。\n\n对于时间积分，我们采用 Crank–Nicolson 格式（梯形法则），对于从 $ t^n $ 到 $ t^{n+1}=t^n+\\Delta t $ 的一个时间步，其形式为\n$ \\left( \\mathbf{C} + \\frac{\\Delta t}{2}\\mathbf{K} \\right)\\mathbf{T}^{n+1} = \\left( \\mathbf{C} - \\frac{\\Delta t}{2}\\mathbf{K} \\right)\\mathbf{T}^{n} + \\frac{\\Delta t}{2}\\left( \\mathbf{f}^{n+1}+\\mathbf{f}^{n} \\right). $\n定义 $ \\mathbf{A}=\\mathbf{C} + \\frac{\\Delta t}{2}\\mathbf{K} $ 和 $ \\mathbf{B}=\\mathbf{C} - \\frac{\\Delta t}{2}\\mathbf{K} $。由于 $ \\mathbf{A} $ 在一次实验中是常数，我们对 $ \\mathbf{A} $ 进行一次分解（例如，通过$\\mathrm{LU}$分解），然后在每个时间步求解。测量值是在规定的采样时间记录的背面温度 $ y(t)=T_N(t) $，并带有噪声 $ \\eta(t) \\sim \\mathcal{N}(0,\\sigma_T^2) $。\n\n对于一个给定的、包含 $ M $ 个激励 $ q''_m(t) $ 及相应采样计划的实验设计，我们从 $ \\mathbf{T}(0)=T_{\\infty}\\mathbf{1} $ 开始模拟每次激励，以获得一个堆叠的测量矢量 $ \\mathbf{y}\\in\\mathbb{R}^{n_y} $。为了构建关于 $ \\boldsymbol{\\theta}=\\big[k_1,k_2,R_{\\mathrm{int}}\\big]^{\\top} $ 的雅可比矩阵 $ \\mathbf{S}\\in\\mathbb{R}^{n_y\\times 3} $，我们计算前向有限差分：对于每个分量 $ \\theta_\\ell $，我们施加扰动 $ \\Delta \\theta_\\ell = \\epsilon_\\ell \\max(|\\theta_\\ell|,\\delta_\\ell) $，其中 $ \\epsilon_{k_1}=\\epsilon_{k_2}=10^{-2} $，$ \\epsilon_{R}=10^{-2} $，以及 $ \\delta_R=10^{-7}\\ \\mathrm{m^2\\,K/W} $；然后我们使用扰动后的参数重新运行所有激励，以获得 $ \\mathbf{y}^{(\\ell)} $，并将 $ \\mathbf{S} $ 的第 $ \\ell $ 列设置为 $ \\big(\\mathbf{y}^{(\\ell)}-\\mathbf{y}\\big)/\\Delta \\theta_\\ell $。假设高斯噪声独立且方差为 $ \\sigma_T^2 $，Fisher 信息矩阵为\n$ \\mathbf{F} = \\frac{1}{\\sigma_T^2}\\mathbf{S}^{\\top}\\mathbf{S}. $\n\n可识别性由两个准则来判断。首先，Fisher 矩阵不应是病态的：$ \\ell_2 $ 范数条件数 $ \\kappa(\\mathbf{F}) $ 应满足 $ \\kappa(\\mathbf{F}) \\le 10^{12} $。其次，Cramér–Rao 下界协方差 $ \\mathbf{C}_{\\mathrm{CRLB}} $（当 $ \\mathbf{F} $ 可逆时取 $ \\mathbf{F}^{-1} $，否则取 Moore–Penrose 伪逆 $ \\mathbf{F}^{+} $）可以推导出边际标准差 $ \\sigma_{\\theta_\\ell} = \\sqrt{[\\mathbf{C}_{\\mathrm{CRLB}}]_{\\ell\\ell}} $。我们通过 $ r_\\ell = \\sigma_{\\theta_\\ell} / \\max(|\\theta_{\\star,\\ell}|,\\theta_{\\min}) $（其中 $ \\theta_{\\min}=10^{-12} $）将这些值与真实量级进行比较，并要求对所有的 $ \\ell\\in\\{1,2,3\\} $ 均满足 $ r_\\ell \\le 0.2 $。必须同时满足这两个条件，才会返回布尔值 $ \\mathrm{True} $ 表示可识别。\n\n程序的算法设计：\n- 使用指定的 $ N_1 $，$ N_2 $，$ L_1 $，$ L_2 $，$ k_1 $，$ k_2 $，$ R_{\\mathrm{int}} $，$ \\rho_i $，$ c_{p,i} $，$ h $ 和 $ T_{\\infty} $，为每组参数组装一次空间离散化。\n- 对于每个由 $ q_0 $，$ t_{\\mathrm{on}} $ 和 $ t_{\\mathrm{end}} $ 定义的激励信号 $ q''(t) $，使用 $ \\Delta t $ 从 $ t=0 $ 积分到 $ t=t_{\\mathrm{end}} $，并以 $ \\Delta t_{\\mathrm{samp}} $ 的增量采样 $ y(t) $。对每个扰动参数重复正向模拟，以填充灵敏度列。\n- 堆叠所有实验中的所有模拟测量值，计算 $ \\mathbf{S} $、$ \\mathbf{F} $、$ \\kappa(\\mathbf{F}) $ 和 $ \\mathbf{C}_{\\mathrm{CRLB}} $。\n- 使用双条件准则判定可识别性，并为每个测试用例返回一个布尔值。\n\n三个指定的测试用例探究了可识别性的互补方面。测试用例 1 使用单个中等持续时间的脉冲，这通常会使 $ k_1 $、$ k_2 $ 和 $ R_{\\mathrm{int}} $ 的效应纠缠在一起，可能导致 $ \\mathbf{F} $ 接近奇异。测试用例 2 引入了具有不同时间尺度和幅值的多个激励，这丰富了灵敏度方向并改善了 $ \\mathbf{F} $ 的条件数。测试用例 3 将 $ R_{\\mathrm{int}} $ 减小了两个数量级，这削弱了界面的可测量影响，即使在多次激励下，也对 $ R_{\\mathrm{int}} $ 的可识别性构成了挑战。程序实现了这一逻辑，并输出一个包含三个布尔值的列表 $[b_1,b_2,b_3]$，对应于三种设计的可识别性结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef assemble_matrices(L1, L2, N1, N2, k1, k2, rho1, cp1, rho2, cp2, R_int, h, T_inf):\n    \"\"\"\n    Assemble capacity matrix C (diagonal), conductance matrix K (tridiagonal),\n    and source vector template for convection contribution at the right boundary.\n    Unit area is assumed.\n    \"\"\"\n    # Grid\n    dx1 = L1 / N1\n    dx2 = L2 / N2\n    N = N1 + N2\n    dx = np.concatenate([np.full(N1, dx1), np.full(N2, dx2)])\n    k_cells = np.concatenate([np.full(N1, k1), np.full(N2, k2)])\n    rho_cells = np.concatenate([np.full(N1, rho1), np.full(N2, rho2)])\n    cp_cells = np.concatenate([np.full(N1, cp1), np.full(N2, cp2)])\n    C = (rho_cells * cp_cells * dx)\n\n    # Build tridiagonal K from face conductances\n    K = np.zeros((N, N), dtype=float)\n\n    # Faces between nodes: j between 0..N-2 for face j+1/2 between node j and j+1\n    for j in range(N - 1):\n        # Half-cell resistances on each side\n        R_face = dx[j] / (2.0 * k_cells[j]) + dx[j + 1] / (2.0 * k_cells[j + 1])\n        # Add interfacial resistance at the interface between layers\n        if j == N1 - 1:\n            R_face += R_int\n        G = 1.0 / R_face\n        K[j, j] += G\n        K[j + 1, j + 1] += G\n        K[j, j + 1] -= G\n        K[j + 1, j] -= G\n\n    # Right convective boundary at node N-1\n    K[-1, -1] += h\n    # Source template is zero except for adding h*T_inf at last node each step\n    f_conv = np.zeros(N, dtype=float)\n    f_conv[-1] = h * T_inf\n\n    return C, K, f_conv\n\ndef crank_nicolson_sim(C, K, f_conv, q_of_t, T_inf, dt, t_end, tsamp):\n    \"\"\"\n    Simulate T evolution under heat flux q_of_t(t) at left boundary using Crank-Nicolson.\n    Returns sampled back-face temperature vector y over sampling times.\n    \"\"\"\n    N = C.size\n    # Matrices\n    A = np.diag(C) + 0.5 * dt * K\n    B = np.diag(C) - 0.5 * dt * K\n    lu, piv = lu_factor(A)\n\n    # Time stepping\n    n_steps = int(np.round(t_end / dt))\n    n_samp = int(np.floor(t_end / tsamp)) + 1\n    y = np.zeros(n_samp, dtype=float)\n    T = np.full(N, T_inf, dtype=float)\n\n    # Sampling times\n    sample_times = np.linspace(0.0, t_end, n_samp)\n    next_sample_index = 0\n    next_sample_time = sample_times[next_sample_index]\n\n    # Record initial measurement\n    y[next_sample_index] = T[-1]\n    next_sample_index += 1\n    next_sample_time = sample_times[next_sample_index] if next_sample_index  n_samp else None\n\n    t = 0.0\n    for n in range(n_steps):\n        t_n = t\n        t_np1 = t + dt\n\n        # Build sources at t_n and t_np1\n        f_n = f_conv.copy()\n        f_np1 = f_conv.copy()\n        # Left Neumann flux as source at node 0\n        f_n[0] += q_of_t(t_n)\n        f_np1[0] += q_of_t(t_np1)\n\n        rhs = B @ T + 0.5 * dt * (f_n + f_np1)\n        T = lu_solve((lu, piv), rhs)\n\n        # Advance time\n        t = t_np1\n\n        # Sample as many times as needed within this step (account for dt being smaller than tsamp)\n        while next_sample_time is not None and t >= next_sample_time - 1e-12:\n            y[next_sample_index] = T[-1]\n            next_sample_index += 1\n            if next_sample_index  n_samp:\n                next_sample_time = sample_times[next_sample_index]\n            else:\n                next_sample_time = None\n\n    return y\n\ndef build_excitation(q0, t_on, t_end):\n    def q_of_t(t):\n        return q0 if (0.0 = t  t_on) else 0.0\n    return q_of_t, t_end\n\ndef fisher_information_and_identifiability(params, excitations, constants):\n    \"\"\"\n    Compute Fisher information matrix for the given parameter set and excitation design.\n    Return identifiability boolean based on the stated rule.\n    \"\"\"\n    # Unpack parameters and constants\n    L1, L2 = params['L1'], params['L2']\n    k1, k2, Rint = params['k1'], params['k2'], params['Rint']\n    rho1, cp1 = params['rho1'], params['cp1']\n    rho2, cp2 = params['rho2'], params['cp2']\n    N1, N2 = constants['N1'], constants['N2']\n    h, Tinf = constants['h'], constants['Tinf']\n    dt, tsamp, sigma_T = constants['dt'], constants['tsamp'], constants['sigma_T']\n    # Perturbation sizes\n    eps_k = constants['eps_k']\n    eps_R = constants['eps_R']\n    delta_R = constants['delta_R']\n\n    # Assemble base matrices once per parameter set\n    C, K, f_conv = assemble_matrices(L1, L2, N1, N2, k1, k2, rho1, cp1, rho2, cp2, Rint, h, Tinf)\n\n    # Simulate base outputs and build stack of measurements y\n    y_list = []\n    # Also store sample counts to reconstruct stacking for perturbed runs\n    sample_lengths = []\n    for (q0, t_on, t_end) in excitations:\n        qfun, tend = build_excitation(q0, t_on, t_end)\n        y = crank_nicolson_sim(C, K, f_conv, qfun, Tinf, dt, tend, tsamp)\n        y_list.append(y)\n        sample_lengths.append(len(y))\n    y_stack = np.concatenate(y_list, axis=0)\n    ny = y_stack.size\n\n    # Sensitivity matrix S (ny x 3)\n    S = np.zeros((ny, 3), dtype=float)\n\n    # Parameter perturbations and simulations\n    # 1) Perturb k1\n    dk1 = eps_k * max(abs(k1), 1e-20)\n    Ck1, Kk1, fcv = assemble_matrices(L1, L2, N1, N2, k1 + dk1, k2, rho1, cp1, rho2, cp2, Rint, h, Tinf)\n    y_cols = []\n    for (q0, t_on, t_end), slen in zip(excitations, sample_lengths):\n        qfun, tend = build_excitation(q0, t_on, t_end)\n        y_pert = crank_nicolson_sim(Ck1, Kk1, fcv, qfun, Tinf, dt, tend, tsamp)\n        y_cols.append(y_pert)\n    yk1 = np.concatenate(y_cols, axis=0)\n    S[:, 0] = (yk1 - y_stack) / dk1\n\n    # 2) Perturb k2\n    dk2 = eps_k * max(abs(k2), 1e-20)\n    Ck2, Kk2, fcv = assemble_matrices(L1, L2, N1, N2, k1, k2 + dk2, rho1, cp1, rho2, cp2, Rint, h, Tinf)\n    y_cols = []\n    for (q0, t_on, t_end), slen in zip(excitations, sample_lengths):\n        qfun, tend = build_excitation(q0, t_on, t_end)\n        y_pert = crank_nicolson_sim(Ck2, Kk2, fcv, qfun, Tinf, dt, tend, tsamp)\n        y_cols.append(y_pert)\n    yk2 = np.concatenate(y_cols, axis=0)\n    S[:, 1] = (yk2 - y_stack) / dk2\n\n    # 3) Perturb R_int\n    dR = max(eps_R * max(abs(Rint), delta_R), delta_R)\n    CR, KR, fcv = assemble_matrices(L1, L2, N1, N2, k1, k2, rho1, cp1, rho2, cp2, Rint + dR, h, Tinf)\n    y_cols = []\n    for (q0, t_on, t_end), slen in zip(excitations, sample_lengths):\n        qfun, tend = build_excitation(q0, t_on, t_end)\n        y_pert = crank_nicolson_sim(CR, KR, fcv, qfun, Tinf, dt, tend, tsamp)\n        y_cols.append(y_pert)\n    yR = np.concatenate(y_cols, axis=0)\n    S[:, 2] = (yR - y_stack) / dR\n\n    # Fisher information matrix\n    F = (S.T @ S) / (sigma_T ** 2)\n\n    # Condition number and CRLB\n    # Use SVD for condition number for numerical robustness\n    try:\n        svals = np.linalg.svd(F, compute_uv=False)\n    except np.linalg.LinAlgError:\n        # If SVD fails, mark as not identifiable\n        return False\n    smax = np.max(svals)\n    smin = np.min(svals)\n    # Avoid division by zero\n    if smin = 0.0:\n        kappa = np.inf\n    else:\n        kappa = smax / smin\n\n    # CRLB via inverse if possible, else pseudoinverse\n    if np.isfinite(kappa) and kappa  1e15:\n        try:\n            Finv = np.linalg.inv(F)\n        except np.linalg.LinAlgError:\n            Finv = np.linalg.pinv(F, rcond=1e-12)\n    else:\n        Finv = np.linalg.pinv(F, rcond=1e-12)\n\n    stds = np.sqrt(np.clip(np.diag(Finv), a_min=0.0, a_max=np.inf))\n\n    # Relative standard deviations\n    theta = np.array([k1, k2, Rint], dtype=float)\n    denom = np.maximum(np.abs(theta), 1e-12)\n    rel_stds = stds / denom\n\n    # Identifiability rule\n    identifiable = (kappa = 1e12) and np.all(rel_stds = 0.2)\n    return bool(identifiable)\n\ndef solve():\n    # Constants shared across cases\n    constants = {\n        'Tinf': 293.0,        # K\n        'h': 15.0,            # W/m^2-K\n        'N1': 20,\n        'N2': 30,\n        'dt': 0.001,          # s\n        'tsamp': 0.01,        # s\n        'sigma_T': 0.02,      # K\n        'eps_k': 1e-2,\n        'eps_R': 1e-2,\n        'delta_R': 1e-7\n    }\n\n    # Test case 1: single excitation\n    params1 = {\n        'L1': 2e-3, 'L2': 3e-3,\n        'k1': 200.0, 'k2': 20.0,\n        'rho1': 8000.0, 'cp1': 500.0,\n        'rho2': 1200.0, 'cp2': 1400.0,\n        'Rint': 1e-4\n    }\n    excitations1 = [\n        (8e4, 0.3, 1.2)  # q0, t_on, t_end\n    ]\n\n    # Test case 2: multiple excitations\n    params2 = params1.copy()\n    excitations2 = [\n        (1.2e5, 0.05, 0.5),\n        (7e4, 0.2, 1.0),\n        (5e4, 0.6, 2.0)\n    ]\n\n    # Test case 3: same as 2 but very small Rint\n    params3 = params2.copy()\n    params3['Rint'] = 1e-6\n    excitations3 = excitations2\n\n    test_cases = [\n        (params1, excitations1),\n        (params2, excitations2),\n        (params3, excitations3),\n    ]\n\n    results = []\n    for params, excitations in test_cases:\n        ident = fisher_information_and_identifiability(params, excitations, constants)\n        results.append(ident)\n\n    # Final print statement in the exact required format.\n    # Booleans will be printed as True/False with capital T/F per Python string conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2497727"}]}