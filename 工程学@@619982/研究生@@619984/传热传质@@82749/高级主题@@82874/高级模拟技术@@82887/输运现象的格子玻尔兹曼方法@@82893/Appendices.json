{"hands_on_practices": [{"introduction": "从物理问题到格子-玻尔兹曼方法（LBM）模拟的转换，第一步也是最关键的一步，是建立物理单位与格子单位之间的尺度关系。这个过程的核心是确保关键的无量纲数，如雷诺数（$Re$）和佩克莱数（$Pe$），在物理系统和数值模型中保持不变。通过这个练习[@problem_id:2500937]，你将亲手实践如何根据给定的物理参数（如流速、粘度和几何尺寸）来选择合适的格子离散参数（$\\Delta x$ 和 $\\Delta t$），并计算出Bhatnagar–Gross–Krook（BGK）模型所需的松弛时间（$\\tau_\\nu$ 和 $\\tau_T$）。", "problem": "一个长度为 $L$、高度为 $H$ 的二维受热通道中，一种被动标量在特征速度为 $U$ 的稳态流作用下发生平流。流体的运动黏度为 $\\nu$，热扩散率为 $\\alpha$。您将使用单弛豫时间 Bhatnagar–Gross–Krook (BGK) 模型和二维九速 (D2Q9) 格子为动量和标量输运建立一个格子玻尔兹曼方法 (LBM) 模拟。格子离散声速满足 $c_s^2 = 1/3$。雷诺数 (Re) 和佩克莱数 (Pe) 定义为 $Re = UL/\\nu$ 和 $Pe = UL/\\alpha$。\n\n给定以下物理属性和几何尺寸：\n- $L = 0.100\\,\\mathrm{m}$，$H = 0.010\\,\\mathrm{m}$，\n- $U = 0.50\\,\\mathrm{m/s}$，\n- $\\nu = 1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$，\n- $\\alpha = 2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$，\n\n设计一个包含 $N_{x} = 1000$ 个节点的格子，使其均匀分布在长度 $L$ 上（使用方形格子，以便两个方向上的格子间距均为 $\\Delta x = L/N_{x}$）。为保持较小的可压缩性误差，选择特征格子速度为 $U_{\\ell b} = 0.050$（以格子单位计）。利用在格子单位中计算的雷诺数和佩克莱数必须等于其物理值的相似性要求，确定与此选择一致的时间步长 $\\Delta t$，然后计算表示给定 $\\nu$ 和 $\\alpha$ 所需的动量和温度的 BGK 弛豫时间 $\\tau_{\\nu}$ 和 $\\tau_{T}$。\n\n将最终答案表示为一个无单位的行矩阵 $\\left(\\tau_{\\nu},\\ \\tau_{T}\\right)$。将您的答案四舍五入到五位有效数字。", "solution": "所述问题在科学上是合理的、适定的、客观的，并包含足够的信息以得到唯一解。这是一个应用格子玻尔兹曼方法 (LBM) 标度关系的标准练习。因此，我将进行推导。\n\nLBM 模拟的核心原理是无量纲数（如雷诺数 ($Re$) 和佩克莱数 ($Pe$)）在物理系统与其格子表示之间保持不变。这要求将物理量（长度、时间、质量）与其在格子单位中的对应量进行一致的标度转换。\n\n首先，我们定义格子参数。通道的物理长度为 $L = 0.100\\,\\mathrm{m}$，通过 $N_{x} = 1000$ 个节点进行离散化。这定义了格子间距 $\\Delta x$，即相邻格子节点之间的物理距离。\n$$\n\\Delta x = \\frac{L}{N_{x}} = \\frac{0.100\\,\\mathrm{m}}{1000} = 1.0 \\times 10^{-4}\\,\\mathrm{m}\n$$\n问题指定了方形格子，因此两个维度上的间距是相同的。\n\n接下来，我们必须确定模拟时间步长 $\\Delta t$。这可以通过将物理特征速度 $U = 0.50\\,\\mathrm{m/s}$ 与指定的格子单位特征速度 $U_{\\ell b} = 0.050$ 联系起来求得。物理速度 ($v_{p}$) 和格子速度 ($v_{\\ell b}$) 之间的转换关系为 $v_{p} = v_{\\ell b} \\frac{\\Delta x}{\\Delta t}$。将此应用于特征速度：\n$$\nU = U_{\\ell b} \\frac{\\Delta x}{\\Delta t}\n$$\n求解时间步长 $\\Delta t$：\n$$\n\\Delta t = \\frac{U_{\\ell b} \\Delta x}{U} = \\frac{0.050 \\times (1.0 \\times 10^{-4}\\,\\mathrm{m})}{0.50\\,\\mathrm{m/s}} = 1.0 \\times 10^{-5}\\,\\mathrm{s}\n$$\n\n在确定了标度因子 $\\Delta x$ 和 $\\Delta t$ 之后，我们可以将物理输运系数——运动黏度 $\\nu$ 和热扩散率 $\\alpha$——转换为它们在格子单位中的等效值 $\\nu_{\\ell b}$ 和 $\\alpha_{\\ell b}$。这些量的单位为长度$^2$/时间，其转换公式为：\n$$\n\\nu_{\\ell b} = \\frac{\\nu \\Delta t}{\\Delta x^{2}} \\quad \\text{和} \\quad \\alpha_{\\ell b} = \\frac{\\alpha \\Delta t}{\\Delta x^{2}}\n$$\n代入给定的物理值和计算出的标度因子：\n$\\nu = 1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$\n$\\alpha = 2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$\n$$\n\\nu_{\\ell b} = \\frac{(1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}) \\times (1.0 \\times 10^{-5}\\,\\mathrm{s})}{(1.0 \\times 10^{-4}\\,\\mathrm{m})^{2}} = \\frac{1.5 \\times 10^{-10}}{1.0 \\times 10^{-8}} = 0.015\n$$\n$$\n\\alpha_{\\ell b} = \\frac{(2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}) \\times (1.0 \\times 10^{-5}\\,\\mathrm{s})}{(1.0 \\times 10^{-4}\\,\\mathrm{m})^{2}} = \\frac{2.2 \\times 10^{-10}}{1.0 \\times 10^{-8}} = 0.022\n$$\n这些是在格子模拟中黏度和扩散率的无量纲值。\n\n最后，我们使用单弛豫时间 Bhatnagar–Gross–Krook (BGK) 模型对于 D2Q9 格子的关系式，来求得所需的弛豫时间 $\\tau_{\\nu}$ 和 $\\tau_{T}$。对于此模型，格子单位中的输运系数通过以下方式与它们各自的弛豫时间相关联：\n$$\n\\nu_{\\ell b} = c_{s}^{2} (\\tau_{\\nu} - 0.5)\n$$\n$$\n\\alpha_{\\ell b} = c_{s}^{2} (\\tau_{T} - 0.5)\n$$\n问题指定格子声速的平方为 $c_{s}^{2} = 1/3$。现在我们可以求解弛豫时间。\n\n对于动量弛豫时间 $\\tau_{\\nu}$：\n$$\n\\tau_{\\nu} = \\frac{\\nu_{\\ell b}}{c_{s}^{2}} + 0.5 = \\frac{0.015}{1/3} + 0.5 = 3 \\times 0.015 + 0.5 = 0.045 + 0.5 = 0.545\n$$\n对于温度（被动标量）弛豫时间 $\\tau_{T}$：\n$$\n\\tau_{T} = \\frac{\\alpha_{\\ell b}}{c_{s}^{2}} + 0.5 = \\frac{0.022}{1/3} + 0.5 = 3 \\times 0.022 + 0.5 = 0.066 + 0.5 = 0.566\n$$\n问题要求答案四舍五入到五位有效数字。\n$\\tau_{\\nu} = 0.54500$\n$\\tau_{T} = 0.56600$\n\n最终答案以行矩阵的形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.54500 & 0.56600 \\end{pmatrix}}\n$$", "id": "2500937"}, {"introduction": "在实现了数值算法之后，验证其正确性和精度是至关重要的一步。这个实践练习[@problem_id:2500947]将指导你完成一个标准的网格加密研究（grid refinement study），以验证一维标量格子-玻尔兹曼方法的收敛阶。你将通过模拟一个扩散热脉冲的演化，并将数值解与精确解析解进行比较，从而定量地评估该方法在空间和时间上的精度。这个过程是计算流体力学中验证代码可靠性的基本技能。", "problem": "一个一维扩散热脉冲在周期性域上根据热方程演化。考虑一个长度为 $L$ 的周期性区间上的标量温度场 $T(x,t)$，该场由方程 $\\partial_t T = \\alpha \\,\\partial_{xx} T$ 控制，其中 $\\alpha$ 是常数热扩散系数。我们将使用基于单松弛时间 Bhatnagar–Gross–Krook (BGK) 模型的一维三速（D1Q3）格子玻尔兹曼方法（LBM）來近似该标量场的演化。D1Q3 模型采用物理单位下的离散粒子速度 $e_i \\in \\{-c, 0, +c\\}$、求积权重 $w_0 = 2/3$ 和 $w_{\\pm 1} = 1/6$，以及用于该标量的线性平衡分布 $f_i^{\\mathrm{eq}} = w_i \\, T$。格子声速满足 $c_s^2 = c^2/3$。在与宏观热方程一致的扩散标度下，热扩散系数通过 $\\alpha = c_s^2 \\, (\\tau - 1/2)\\,\\Delta t$ 与格子参数相关联，其中 $\\tau$ 是无量纲松弛时间，$\\Delta t$ 是物理时间步长。对于具有 $N_x$ 个节点和网格间距 $\\Delta x = L/N_x$ 的均匀网格，当 $c = \\Delta x/\\Delta t$ 时，D1Q3 中的迁移是精确的，这意味着在网格细化时，为了保持 $\\alpha$ 固定，需要满足耦合关系 $\\Delta t = \\frac{\\Delta x^2}{3\\alpha}\\,(\\tau - 1/2)$。\n\n初始条件和精确解。设初始温度为一个周期性高斯脉冲，其振幅为 $A$，宽度参数为 $\\sigma_0$，中心位于 $x_0 = L/2$。其 $2J+1$ 镜像周期近似为\n$$\nT(x,0) \\;=\\; A\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2}\\right).\n$$\n通过线性叠加和热方程的基本解，时间 $t$ 对应的周期性精确解为\n$$\nT_{\\mathrm{exact}}(x,t) \\;=\\; A\\sqrt{\\frac{\\sigma_0^2}{\\sigma_0^2 + 4\\alpha t}} \\;\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2 + 4\\alpha t}\\right).\n$$\n所有量都是无量纲的，因此所有最终数值应作为无单位数报告。\n\n离散化和误差范数。在周期性网格上实现带有 BGK 碰撞和精确迁移的标量 D1Q3 LBM。宏观温度是零阶矩 $T = \\sum_i f_i$。通过 $f_i(x,0) = w_i \\, T(x,0)$ 初始化粒子分布函数。演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步，以近似 $t^\\ast = N_t \\Delta t$ 时的解。使用离散 $L^2$ 范数比较数值解 $T_\\mathrm{num}(x,t^\\ast)$ 和精确解 $T_\\mathrm{exact}(x,t^\\ast)$\n$$\nE \\;=\\; \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k,t^\\ast) - T_{\\mathrm{exact}}(x_k,t^\\ast)\\right]^2 \\right)^{1/2}.\n$$\n\n观测到的精度阶。使用 $N_x \\in \\{64,128,256,512\\}$ 进行网格细化研究，同时通过上述扩散标度关系保持 $\\alpha$ 不变。对于每次细化，计算误差 $E$、网格间距 $\\Delta x$ 和时间步长 $\\Delta t$。估计：\n- 观测到的空间精度阶 $p_x$，即 $\\log E$ 相对于 $\\log \\Delta x$ 的最小二乘线性拟合的斜率；\n- 观测到的时间精度阶 $p_t$，即 $\\log E$ 相对于 $\\log \\Delta t$ 的最小二乘线性拟合的斜率。\n由于在扩散标度下 $\\Delta t \\propto \\Delta x^2$，两次拟合都必须在同一组细化数据上进行，以便分别表征误差如何随 $\\Delta x$ 和 $\\Delta t$ 变化。\n\n测试套件。使用以下三组参数集，每组的域长度 $L=1$，中心 $x_0=L/2$，镜像数 $J=6$：\n- 情况 A（基线）：$\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n- 情况 B（较低扩散系数）：$\\alpha=0.005$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n- 情况 C（更尖锐的脉冲）：$\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.03$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n\n程序要求。编写一个完整的程序，该程序：\n- 为每种情况和 $N_x \\in \\{64,128,256,512\\}$ 实现上述 D1Q3 标量 LBM。\n- 对每种情况，计算在不同细化程度下的数组 $\\{E\\}$, $\\{\\Delta x\\}$ 和 $\\{\\Delta t\\}$，然后使用最小二乘拟合返回 $(p_x, p_t)$。\n- 其唯一输出为一行，包含六个浮点数值 $[p_x^{(A)},p_t^{(A)},p_x^{(B)},p_t^{(B)},p_x^{(C)},p_t^{(C)}]$，按此顺序排列，每个值四舍五入到三位小数，格式为方括号内以逗号分隔的列表。\n\n角度单位和物理单位。不存在角度量，并且所有变量都是无量纲的。不应报告任何物理单位；所有输出都是纯数字。\n\n您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且自洽的。它提出了一个标准的数值分析任务，涉及将格子玻尔兹曼方法（LBM）应用于一维热方程。所有参数、方程和程序都已明确且正确地指定，足以得出一个唯一的解。因此，我们着手推导和实现该解法。\n\n该问题要求在长度为 $L$ 的一维周期性域上对标量热扩散方程进行数值求解，\n$$\n\\partial_t T = \\alpha \\,\\partial_{xx} T\n$$\n指定的方法是带有 Bhatnagar-Gross-Krook (BGK) 碰撞算子的 D1Q3 格子玻尔兹曼模型。\n\nD1Q3 模型将速度空间离散为三个方向，$i \\in \\{0, 1, 2\\}$，分别对应微观粒子速度 $e_0 = 0$、$e_1 = +c$ 和 $e_2 = -c$。粒子分布函数 $f_i(x,t)$ 的演化由格子玻尔兹曼方程控制：\n$$\nf_i(x+e_i\\Delta t, t+\\Delta t) - f_i(x,t) = -\\frac{1}{\\tau} (f_i(x,t) - f_i^{\\mathrm{eq}}(x,t))\n$$\n其中 $\\tau$ 是无量纲松弛时间，$f_i^{\\mathrm{eq}}$ 是局部平衡分布。方程左侧代表粒子向相邻格点的迁移，而右侧代表因碰撞而向平衡态的松弛。\n\n对于标量扩散过程，平衡分布是宏观标量场（在此情况下为温度 $T$）的线性函数。它由 $f_i^{\\mathrm{eq}} = w_i T$ 给出，其中 $w_i$ 是求积权重。对于 D1Q3 模型，这些权重为 $w_0 = 2/3$ 和 $w_{1,2} = 1/6$。宏观温度通过分布函数的零阶矩恢复：\n$$\nT(x,t) = \\sum_{i=0}^{2} f_i(x,t)\n$$\n可以验证 $\\sum_i f_i^{\\mathrm{eq}} = \\sum_i w_i T = T(\\sum_i w_i) = T(2/3 + 1/6 + 1/6) = T$，这确保了在碰撞过程中标量 $T$ 的局域守恒。\n\n数值算法在每个时间增量中分两步进行：碰撞和迁移。\n1.  **碰撞步**：在每个网格节点 $x_k$ 计算碰撞后的分布函数 $f_i^{\\ast}$：\n    $$\n    f_i^{\\ast}(x_k, t) = f_i(x_k, t) - \\frac{1}{\\tau} (f_i(x_k, t) - f_i^{\\mathrm{eq}}(x_k, t))\n    $$\n    首先，从当前的分布函数计算宏观温度 $T(x_k,t) = \\sum_i f_i(x_k,t)$。然后，确定平衡分布 $f_i^{\\mathrm{eq}}(x_k,t) = w_i T(x_k,t)$，最后应用碰撞更新。\n\n2.  **迁移步**：碰撞后的分布函数根据其速度传播到相邻节点。当格子速度设置为 $c = \\Delta x/\\Delta t$（其中 $\\Delta x$ 是网格间距，$\\Delta t$ 是时间步长）时，粒子在一个时间步内精确地从一个节点移动到其相邻节点。对于周期性域，这通过循环移位实现：\n    $$\n    f_0(x_k, t+\\Delta t) = f_0^{\\ast}(x_k, t) \\\\\n    f_1(x_k, t+\\Delta t) = f_1^{\\ast}(x_{k-1}, t) \\\\\n    f_2(x_k, t+\\Delta t) = f_2^{\\ast}(x_{k+1}, t)\n    $$\n    索引 $k-1$ 和 $k+1$ 通过周期性环绕进行处理。\n\n模拟在时间 $t=0$ 初始化。初始温度场 $T(x,0)$ 由高斯函数的周期性总和给出。初始粒子分布被设置为与该场处于局部平衡：$f_i(x_k, 0) = f_i^{\\mathrm{eq}}(x_k, 0) = w_i T(x_k, 0)$。然后，模拟演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步。在实际的最终时间 $t^{\\ast} = N_t \\Delta t$ 计算最终的数值温度剖面 $T_{\\mathrm{num}}(x_k, t^{\\ast})$。\n\n问题指定了一个扩散标度关系，以在网格细化过程中保持物理热扩散系数 $\\alpha$ 不变。该关系为：\n$$\n\\alpha = c_s^2 (\\tau - 1/2) \\Delta t\n$$\n其中 $c_s^2 = c^2/3 = (\\Delta x/\\Delta t)^2/3$ 是格子声速的平方。将 $c_s^2$ 代入 $\\alpha$ 的表达式并求解 $\\Delta t$，得到时间步长和网格间距之间的显式耦合关系：\n$$\n\\Delta t = \\frac{\\Delta x^2}{3\\alpha} (\\tau - 1/2)\n$$\n该关系意味着 $\\Delta t \\propto \\Delta x^2$。\n\n使用网格尺寸 $N_x \\in \\{64, 128, 256, 512\\}$ 进行网格细化研究。对于每个 $N_x$，计算网格间距 $\\Delta x=L/N_x$ 和相应的时间步长 $\\Delta t$。运行模拟，并使用离散 $L^2$ 范数计算与在 $t^{\\ast}$ 处求值的给定精确解相比的误差 $E$：\n$$\nE = \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k, t^{\\ast}) - T_{\\mathrm{exact}}(x_k, t^{\\ast})\\right]^2 \\right)^{1/2}\n$$\n精度阶由误差定标律的假设 $E \\approx C (\\Delta x)^{p_x}$ 确定，其中 $C$ 为某个常数，$p_x$ 为空间精度阶。取对数得到 $\\log E \\approx \\log C + p_x \\log \\Delta x$。因此，空间精度阶 $p_x$ 是 $\\log E$ 相对于 $\\log \\Delta x$ 的最小二乘线性拟合的斜率。类似地，由于 $\\Delta t \\propto \\Delta x^2$，我们有 $\\log E \\approx \\log C' + p_t \\log \\Delta t$，其中 $p_t = p_x/2$。时间精度阶 $p_t$ 是 $\\log E$ 相对于 $\\log \\Delta t$ 的拟合斜率。将为指定的三个测试案例分别计算这两个斜率。用于扩散的 LBM-BGK 格式在空间上预期为二阶精度，因此我们预计 $p_x \\approx 2.0$，从而 $p_t \\approx 1.0$。\n\n实现过程首先定义用于初始条件和精确解析解的函数。一个主模拟函数封装了针对一组给定物理和数值参数的 LBM 算法。对每个细化级别调用此函数。收集由此产生的误差和网格参数。最后，对经过对数转换的数据执行线性回归，以提取观测到的精度阶，然后报告这些精度阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef setup_exact_solution_function(L, A, sigma0, alpha, J, x0):\n    \"\"\"\n    Creates a function that computes the exact solution for a given time t.\n    \"\"\"\n    def get_exact_solution(x_grid, t):\n        if t == 0:\n            var_term = sigma0**2\n            time_prefactor = A\n        else:\n            var_term = sigma0**2 + 4 * alpha * t\n            time_prefactor = A * np.sqrt(sigma0**2 / var_term)\n\n        if var_term == 0:\n            # Handle the case of a delta function, though not expected here.\n            T_exact = np.zeros_like(x_grid)\n            idx = np.abs(x_grid - x0).argmin()\n            T_exact[idx] = np.inf\n            return T_exact\n\n        T_exact = np.zeros_like(x_grid)\n        for j in range(-J, J + 1):\n            T_exact += np.exp(-((x_grid - x0 + j * L)**2) / var_term)\n        \n        return time_prefactor * T_exact\n\n    return get_exact_solution\n\n\ndef run_lbm_and_get_error(Nx, L, alpha, tau, T_final, A, sigma0, J, x0):\n    \"\"\"\n    Runs a single D1Q3 LBM simulation and computes the L2 error.\n    \"\"\"\n    # Grid and time parameters\n    dx = L / Nx\n    dt = (dx**2 / (3 * alpha)) * (tau - 0.5)\n    Nt = int(round(T_final / dt))\n    t_star = Nt * dt\n    x = np.linspace(0, L, Nx, endpoint=False) + dx / 2.0\n\n    # LBM parameters\n    w = np.array([2./3., 1./6., 1./6.]) # w0, w+, w-\n    omega = 1.0 / tau\n\n    # Initialization\n    exact_solution_func = setup_exact_solution_function(L, A, sigma0, alpha, J, x0)\n    T0 = exact_solution_func(x, 0)\n    \n    # Populations f0, f+, f-\n    f0 = w[0] * T0\n    f1 = w[1] * T0\n    f2 = w[2] * T0\n    \n    # Main time-stepping loop\n    for _ in range(Nt):\n        # Macroscopic temperature\n        T = f0 + f1 + f2\n        \n        # Collision\n        f0_eq = w[0] * T\n        f1_eq = w[1] * T\n        f2_eq = w[2] * T\n        \n        f0 = f0 - omega * (f0 - f0_eq)\n        f1 = f1 - omega * (f1 - f1_eq)\n        f2 = f2 - omega * (f2 - f2_eq)\n        \n        # Streaming\n        f1 = np.roll(f1, 1)  # moves right\n        f2 = np.roll(f2, -1) # moves left\n\n    # Final numerical temperature\n    T_num = f0 + f1 + f2\n    \n    # Exact solution at final time\n    T_exact = exact_solution_func(x, t_star)\n    \n    # L2 Error calculation\n    error = np.sqrt(dx * np.sum((T_num - T_exact)**2))\n    \n    return error, dx, dt\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute orders of accuracy.\n    \"\"\"\n    test_cases = [\n        # Case A (baseline)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case B (lower diffusivity)\n        {\"alpha\": 0.005, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case C (sharper pulse)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.03, \"A\": 1.0, \"T_final\": 0.02},\n    ]\n\n    # Shared parameters\n    L = 1.0\n    x0 = L / 2.0\n    J = 6\n    Nx_refinements = [64, 128, 256, 512]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        errors = []\n        dxs = []\n        dts = []\n        \n        for Nx in Nx_refinements:\n            error, dx, dt = run_lbm_and_get_error(Nx, L, **case_params, J=J, x0=x0)\n            errors.append(error)\n            dxs.append(dx)\n            dts.append(dt)\n        \n        # Log-transform data for linear regression\n        log_errors = np.log(np.array(errors))\n        log_dxs = np.log(np.array(dxs))\n        log_dts = np.log(np.array(dts))\n        \n        # Perform linear regression to find slopes (orders of accuracy)\n        px_res = linregress(log_dxs, log_errors)\n        pt_res = linregress(log_dts, log_errors)\n        \n        px = px_res.slope\n        pt = pt_res.slope\n        \n        all_results.extend([px, pt])\n\n    # Format the final output string\n    # [px_A, pt_A, px_B, pt_B, px_C, pt_C] rounded to 3 decimal places\n    output_str = f\"[{','.join([f'{r:.3f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2500947"}, {"introduction": "实际的输运现象问题往往涉及复杂的几何边界，这给格子-玻尔兹曼方法的应用带来了挑战。虽然简单的周期性边界或直线边界易于处理，但精确地模拟流体与曲面边界的相互作用是保证模拟精度的关键。这个高级实践[@problem_id:2500986]深入探讨了曲面边界处理的一个核心问题：如何在使用插值反弹格式（Interpolated Bounce-Back）时，校正由边界曲率引入的误差，从而恢复数值格式的二阶精度。你将通过理论推导和数值实验，亲自量化并修正这种误差，这是提升 LBM 模拟真实物理系统能力的重要一步。", "problem": "考虑由能量平衡控制的被动标量的热传导，在没有对流的情况下，温度场 $T(\\mathbf{x},t)$ 满足 $\\partial T/\\partial t = \\alpha \\nabla^2 T + S$，其中 $\\alpha$ 是热扩散系数，$S$ 是源项。关注光滑弯曲等温边界（狄利克雷条件）附近的局部稳态行为，壁面温度为 $T_{\\mathrm{w}}$。引入局部标准正交 Frenet 标架 $(s,n)$，其中 $n$ 是离壁面的外法向坐标，$s$ 是沿壁面的切向坐标。对于局部切向均匀场（即 $\\partial/\\partial s = 0$），拉普拉斯算子简化为 $\\nabla^2 T = \\partial^2 T/\\partial n^2 + \\kappa \\partial T/\\partial n$，其中 $\\kappa$ 是关注点边界的有符号曲率（从流体侧看，局部凸边界的曲率为正）。\n\n在用于标量输运的格子玻尔兹曼方法 (Lattice Boltzmann Method, LBM) 中，一种广泛用于弯曲壁面的边界处理方法是插值反弹 (Interpolated Bounce-Back, IBB)。考虑一个穿过壁面的格子链接，其中流体节点距离壁面的法向距离为 $q\\,\\Delta x$，其中 $q\\in(0,1)$，$\\Delta x$ 是空间步长。对于温度为 $T_{\\mathrm{w}}$ 的等温壁面和温度为 $T_{\\mathrm{f}}$ 的邻近流体节点，一个常见的、几何一致的壁面法向温度梯度（用于计算热通量）估计量是以下有限差分商\n$$\nG_{\\mathrm{naive}}(\\Delta x; \\kappa, q) \\equiv \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}.\n$$\n相应的壁面法向热通量为 $q_n = -k\\, G$，其中 $k$ 是热导率。在 IBB 格式中，$G_{\\mathrm{naive}}$ 通过 $q$ 捕捉了偏离格点的交点效应，但忽略了曲率引起的耦合。\n\n您的任务是：\n\n- 从局部标架中的稳态法向扩散方程 $\\partial^2 T/\\partial n^2 + \\kappa\\, \\partial T/\\partial n = 0$ 和关于壁面位置 $n=0$ 的泰勒展开出发，推导 $G_{\\mathrm{naive}}$ 以 $\\Delta x$ 幂次表示的主阶截断误差。然后，提出一个考虑曲率的修正估计量 $G_{\\mathrm{corr}}(\\Delta x; \\kappa, q)$，以恢复壁面法向梯度的二阶 $\\Delta x$ 精度。该修正必须通过系统地消除泰勒展开中主导的曲率诱导偏差项来获得。\n- 为了在不模拟完整格子玻尔兹曼方法的情况下生成具体的、可测试的数值，考虑由以下边值问题定义的构造局部精确解\n$$\n\\frac{\\partial^2 T}{\\partial n^2} + \\kappa\\, \\frac{\\partial T}{\\partial n} = 0,\\quad T(0) = T_{\\mathrm{w}},\\quad \\left.\\frac{\\partial T}{\\partial n}\\right|_{n=0} = G_{\\ast},\n$$\n其中 $\\kappa \\neq 0$ 为常数，$G_{\\ast}$ 为恒定的预设壁面法向梯度。其精确解为\n$$\nT(n) = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{-\\kappa n} - 1\\right).\n$$\n特别地，在位于 $n = -q\\,\\Delta x$（流体内）的流体节点处，精确温度为\n$$\nT_{\\mathrm{f}} = T(-q\\,\\Delta x) = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{\\kappa\\, q\\, \\Delta x} - 1\\right).\n$$\n使用此精确的 $T_{\\mathrm{f}}$ 来评估壁面法向梯度的数值估计量，而无需演化任何瞬态格式。\n\n- 定义绝对误差\n$$\nE_{\\mathrm{naive}}(\\Delta x; \\kappa, q) \\equiv \\left| G_{\\mathrm{naive}}(\\Delta x; \\kappa, q) - G_{\\ast} \\right|,\\qquad\nE_{\\mathrm{corr}}(\\Delta x; \\kappa, q) \\equiv \\left| G_{\\mathrm{corr}}(\\Delta x; \\kappa, q) - G_{\\ast} \\right|.\n$$\n对于每个估计量，通过对加密序列上的 $\\log E$ 与 $\\log \\Delta x$ 进行最小二乘线性回归，计算观测收敛阶 $p$。\n\n- 使用以下曲率和交点参数以及网格加密的测试套件：\n    - 曲率和交点对 $(\\kappa, q)$：\n        $$\n        (\\kappa, q) \\in \\left\\{ (1.0, 0.3),\\ (0.5, 0.8),\\ (-1.0, 0.4),\\ (2.0, 0.1) \\right\\}.\n        $$\n    - 网格间距的加密序列：\n        $$\n        \\Delta x \\in \\left\\{ 1/10,\\ 1/20,\\ 1/40,\\ 1/80 \\right\\}.\n        $$\n    - 使用 $T_{\\mathrm{w}} = 0$ 和 $G_{\\ast} = 1$（无量纲单位），以及 $k=1$，从而使热通量的大小等于梯度的大小。只需报告梯度的收敛阶；$p$ 是无量纲的，不需要单位。\n\n- 程序要求：\n    - 实现朴素估计量和您推导的曲率修正估计量。\n    - 对于测试套件中的每个 $(\\kappa,q)$，计算在指定加密序列上的观测收敛阶 $p_{\\mathrm{naive}}$ 和 $p_{\\mathrm{corr}}$。\n    - 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，顺序为\n      $[p_{\\mathrm{naive},1}, p_{\\mathrm{corr},1}, p_{\\mathrm{naive},2}, p_{\\mathrm{corr},2}, p_{\\mathrm{naive},3}, p_{\\mathrm{corr},3}, p_{\\mathrm{naive},4}, p_{\\mathrm{corr},4}]$，\n      其中下标索引按上面给出的顺序遍历四个 $(\\kappa,q)$ 案例。\n\n所有计算都以无量纲形式进行。将最终输出明确表示为上述方括号列表的单个 Python `print` 语句。", "solution": "题目陈述经过严格审查，确认有效。它在科学上基于热传递和数值分析的原理，问题设定良好，目标明确，并提供了一套独立、一致的数据和定义。使用构造解是验证数值格式精度阶数的标准而严谨的技术。因此，我们可以进行正式求解。\n\n任务是推导壁面法向温度梯度的曲率修正估计量，并与一个更简单的朴素估计量进行比较，以验证其数值收敛特性。\n\n让我们从局部 Frenet 标架 $(s,n)$ 中的稳态、切向均匀能量平衡方程开始，其中 $n$ 是法向坐标：\n$$\n\\frac{d^2 T}{d n^2} + \\kappa \\frac{d T}{d n} = 0\n$$\n在此，$T(n)$ 是沿法向的温度分布，$\\kappa$ 是局部壁面曲率。边界位于 $n=0$ 处且为等温，因此 $T(0) = T_{\\mathrm{w}}$。真实的壁面法向梯度记为 $G_{\\ast} = \\left.\\frac{dT}{dn}\\right|_{n=0}$。\n\n从在壁面 $n=0$ 处求值的控制方程，我们可以将二阶导数与一阶导数联系起来：\n$$\n\\left.\\frac{d^2 T}{d n^2}\\right|_{n=0} = -\\kappa \\left.\\frac{d T}{d n}\\right|_{n=0} = -\\kappa G_{\\ast}\n$$\n我们可以通过对控制方程关于 $n$ 求导来找到更高阶的导数：\n$$\n\\frac{d^3 T}{d n^3} = -\\kappa \\frac{d^2 T}{d n^2} = (-\\kappa)(-\\kappa G(n)) = \\kappa^2 \\frac{d T}{d n}\n$$\n其中 $G(n) = \\frac{dT}{dn}$。在壁面处，$\\left.\\frac{d^3 T}{d n^3}\\right|_{n=0} = \\kappa^2 G_{\\ast}$。\n\n现在我们构造温度 $T(n)$ 在壁面位置 $n=0$ 附近的泰勒级数展开：\n$$\nT(n) = T(0) + n \\left.\\frac{dT}{dn}\\right|_{n=0} + \\frac{n^2}{2!} \\left.\\frac{d^2T}{dn^2}\\right|_{n=0} + \\frac{n^3}{3!} \\left.\\frac{d^3T}{dn^3}\\right|_{n=0} + \\mathcal{O}(n^4)\n$$\n代入已知值和推导出的导数关系：\n$$\nT(n) = T_{\\mathrm{w}} + n G_{\\ast} - \\frac{n^2}{2} \\kappa G_{\\ast} + \\frac{n^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(n^4)\n$$\n所考虑的流体节点距离壁面的法向距离为 $q\\,\\Delta x$。由于 $n$ 是外法线，域内的流体节点位于 $n = -q\\,\\Delta x$。计算此流体节点处的温度，$T_{\\mathrm{f}} = T(-q\\,\\Delta x)$：\n$$\nT_{\\mathrm{f}} = T_{\\mathrm{w}} + (-q\\,\\Delta x) G_{\\ast} - \\frac{(-q\\,\\Delta x)^2}{2} \\kappa G_{\\ast} - \\frac{(-q\\,\\Delta x)^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n$$\nT_{\\mathrm{f}} = T_{\\mathrm{w}} - q\\,\\Delta x\\, G_{\\ast} - \\frac{q^2 \\Delta x^2}{2} \\kappa G_{\\ast} - \\frac{q^3 \\Delta x^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n重新整理以求差值 $T_{\\mathrm{w}} - T_{\\mathrm{f}}$：\n$$\nT_{\\mathrm{w}} - T_{\\mathrm{f}} = q\\,\\Delta x\\, G_{\\ast} + \\frac{\\kappa q^2 \\Delta x^2}{2} G_{\\ast} + \\frac{\\kappa^2 q^3 \\Delta x^3}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n朴素梯度估计量定义为 $G_{\\mathrm{naive}} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}$。代入展开式：\n$$\nG_{\\mathrm{naive}} = \\frac{1}{q\\,\\Delta x} \\left( q\\,\\Delta x\\, G_{\\ast} + \\frac{\\kappa q^2 \\Delta x^2}{2} G_{\\ast} + \\frac{\\kappa^2 q^3 \\Delta x^3}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^4) \\right)\n$$\n$$\nG_{\\mathrm{naive}} = G_{\\ast} + \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^3)\n$$\n该估计量的截断误差为 $G_{\\mathrm{naive}} - G_{\\ast} = \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\mathcal{O}(\\Delta x^2)$。此误差关于 $\\Delta x$ 是一阶的，因此我们预期收敛阶为 $p=1$。这就是主导的曲率诱导偏差。\n\n为了恢复二阶精度，我们必须消除这个主导误差项。从 $G_{\\mathrm{naive}}$ 的表达式，我们可以写出：\n$$\nG_{\\ast} = G_{\\mathrm{naive}} - \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\mathcal{O}(\\Delta x^2)\n$$\n为了消除右侧的未知量 $G_{\\ast}$，我们可以代入其最低阶近似 $G_{\\ast} \\approx G_{\\mathrm{naive}}$，这是允许的，因为它只会引入更高阶的误差。然而，一种更系统的方法是重新整理表达式 $T_{\\mathrm{w}} - T_{\\mathrm{f}}$：\n$$\nT_{\\mathrm{w}} - T_{\\mathrm{f}} = q\\,\\Delta x\\, G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\mathcal{O}(\\Delta x^3) \\right)\n$$\n求解 $G_{\\ast}$：\n$$\nG_{\\ast} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\mathcal{O}(\\Delta x^2) \\right)} = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{\\kappa q \\Delta x}{2} + \\mathcal{O}(\\Delta x^2)}\n$$\n这启发我们定义一个二阶精度的曲率修正估计量 $G_{\\mathrm{corr}}$：\n$$\nG_{\\mathrm{corr}}(\\Delta x; \\kappa, q) = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{\\kappa q \\Delta x}{2}}\n$$\n让我们验证这个新估计量的精度。我们代入 $G_{\\mathrm{naive}}$ 的完整展开式：\n$$\nG_{\\mathrm{corr}} = \\frac{G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\mathcal{O}(\\Delta x^3)\\right)}{1 + \\frac{\\kappa q \\Delta x}{2}}\n$$\n使用几何级数展开 $\\frac{1}{1+z} = 1 - z + z^2 - \\dots$，其中 $z = \\frac{\\kappa q \\Delta x}{2}$：\n$$\nG_{\\mathrm{corr}} = G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\dots\\right) \\left(1 - \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\dots\\right)\n$$\n按 $\\Delta x$ 的幂次展开并收集项：\n- $\\Delta x^0$ 阶项： $G_{\\ast} \\cdot 1 \\cdot 1 = G_{\\ast}$。\n- $\\Delta x^1$ 阶项： $G_{\\ast} \\left( -\\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa q \\Delta x}{2} \\right) = 0$。一阶误差项被成功消除。\n- $\\Delta x^2$ 阶项： $G_{\\ast} \\left( \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\frac{\\kappa^2 q^2 \\Delta x^2}{4} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} \\right) = G_{\\ast} \\frac{\\kappa^2 q^2 \\Delta x^2}{6}$。\n\n因此，修正估计量的展开式是：\n$$\nG_{\\mathrm{corr}} = G_{\\ast} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^3)\n$$\n截断误差为 $G_{\\mathrm{corr}} - G_{\\ast} = \\mathcal{O}(\\Delta x^2)$，这证实了该估计量是二阶精度的。我们预期数值收敛阶为 $p=2$。\n\n对于问题的数值部分，我们将实现以下公式：\n1.  位于 $n=-q\\Delta x$ 处的精确流体温度 $T_{\\mathrm{f}}$ 由构造解给出：\n    $$T_{\\mathrm{f}} = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{\\kappa\\, q\\, \\Delta x} - 1\\right)$$\n2.  朴素估计量计算如下：\n    $$G_{\\mathrm{naive}} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}$$\n3.  曲率修正估计量为：\n    $$G_{\\mathrm{corr}} = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{1}{2}\\kappa q \\Delta x}$$\n4.  绝对误差为 $E_{\\mathrm{naive}} = |G_{\\mathrm{naive}} - G_{\\ast}|$ 和 $E_{\\mathrm{corr}} = |G_{\\mathrm{corr}} - G_{\\ast}|$。\n5.  收敛阶 $p$ 是 $\\log E$ 对 $\\log \\Delta x$ 进行线性最小二乘拟合的斜率。\n\n所有计算都将使用指定的参数 $T_{\\mathrm{w}}=0$、$G_{\\ast}=1$ 以及所提供的 $(\\kappa, q)$ 和 $\\Delta x$ 集合来执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convergence orders for naive and curvature-corrected\n    wall-normal gradient estimators.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.3),  # (kappa, q) pair 1\n        (0.5, 0.8),  # (kappa, q) pair 2\n        (-1.0, 0.4), # (kappa, q) pair 3\n        (2.0, 0.1),  # (kappa, q) pair 4\n    ]\n\n    # Refinement sequence for the grid spacing.\n    dx_values = np.array([1/10, 1/20, 1/40, 1/80])\n    \n    # Constants for the manufactured solution.\n    Tw = 0.0\n    G_star = 1.0\n\n    results = []\n\n    for kappa, q in test_cases:\n        errors_naive = []\n        errors_corr = []\n\n        for dx in dx_values:\n            # 1. Calculate the exact fluid temperature Tf at the fluid node n = -q*dx\n            # using the provided manufactured solution.\n            # T_f = T_w + (G_star / -kappa) * (e^(kappa*q*dx) - 1)\n            # Since kappa is guaranteed to be non-zero, no division-by-zero check is needed.\n            Tf = Tw + (G_star / -kappa) * (np.exp(kappa * q * dx) - 1.0)\n            \n            # 2. Calculate the naive gradient estimator G_naive.\n            # G_naive = (T_w - T_f) / (q*dx)\n            G_naive = (Tw - Tf) / (q * dx)\n            \n            # 3. Calculate the curvature-corrected gradient estimator G_corr.\n            # G_corr = G_naive / (1 + 0.5 * kappa * q * dx)\n            G_corr = G_naive / (1.0 + 0.5 * kappa * q * dx)\n            \n            # 4. Calculate the absolute errors for both estimators.\n            E_naive = np.abs(G_naive - G_star)\n            E_corr = np.abs(G_corr - G_star)\n            \n            errors_naive.append(E_naive)\n            errors_corr.append(E_corr)\n\n        # 5. Compute the convergence orders p_naive and p_corr.\n        # This is done by a linear least-squares regression of log(E) vs log(dx).\n        # The slope of this regression is the convergence order p.\n        log_dx = np.log(dx_values)\n        \n        # For the naive estimator\n        log_E_naive = np.log(np.array(errors_naive))\n        # np.polyfit with degree 1 returns [slope, intercept]\n        p_naive = np.polyfit(log_dx, log_E_naive, 1)[0]\n        \n        # For the corrected estimator\n        log_E_corr = np.log(np.array(errors_corr))\n        p_corr = np.polyfit(log_dx, log_E_corr, 1)[0]\n        \n        results.extend([p_naive, p_corr])\n\n    # Final print statement in the exact required format.\n    # The output format is a single line: [p_naive1,p_corr1,p_naive2,p_corr2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2500986"}]}