{"hands_on_practices": [{"introduction": "要从根本上理解生殖隔离的增强机制，关键在于量化其演化动态。此练习引导你通过构建一个经典的群体遗传学模型，来推导出选择性偏好等位基因入侵并扩散所需的临界条件[@problem_id:2748821]。通过这个练习，你将亲手计算出，避免产生不适杂种后代的收益，必须在多大程度上超过择偶挑剔性本身所带来的成本，从而为增强的发生建立一个坚实的理论基础。", "problem": "考虑一个具有离散、不重叠世代和对称迁移的双亚群种群。在每一代中，每个亚群中有比例为 $m$ 的个体是来自另一个亚群的迁移者，交配在迁移后于各自亚群内发生。个体由一个谱系身份来表征，该身份决定了交配是同谱系（相同谱系）还是异谱系（不同谱系）。同谱系交配产生的后代相对生存力为 $1$，而异谱系交配产生的杂交后代相对生存力为 $1 - s$，其中 $s \\in [0,1]$ 是针对杂交后代的选择系数。假设谱系身份能够可靠地表达，因此在迁移之后，给定亚群中潜在的异谱系配偶比例为 $m$，同谱系配偶比例为 $1 - m$。\n\n此外，还有一个偏好基因座，有两个等位基因：一个是随机与可用伴侣交配的非选择性等位基因，另一个是实行完美选型交配（即只与同谱系个体交配）但会产生一个繁殖力成本 $c \\in [0,1)$ 的选择性等位基因，该成本会以乘法方式减少产生的合子数量。假设选择性等位基因初始时是稀有的，并且不改变交配池的组成。假设适应度由交配成功率、繁殖力和后代生存力等多个部分相乘决定。\n\n如果选择性等位基因在稀有时具有边际适应度优势，则称生殖隔离的强化过程发生。仅使用上述假设和定义，推导出临界阈值 $s^\\ast$ 作为 $m$ 和 $c$ 的函数，使得强化过程发生的充分必要条件是 $s > s^\\ast$。请将您的最终答案表示为 $s^\\ast$ 关于 $m$ 和 $c$ 的闭式解析表达式。不需要进行数值计算。", "solution": "该问题要求推导合子后隔离的临界阈值 $s^\\ast$，当选择压力超过该阈值时，一个促进选型交配的等位基因将成功入侵种群。这是一个强化问题，通过比较稀有的“选择性”等位基因的适应度与原有的“非选择性”等位基因的适应度来分析。如果选择性等位基因的边际适应度更高，它就会入侵。\n\n我们根据个体在偏好基因座上携带的等位基因来定义其相对适应度 $W$。根据问题陈述，适应度由繁殖力和所产后代的平均生存力的乘积决定。我们考虑的是选择性等位基因稀有的情况。\n\n首先，我们计算原有的非选择性等位基因的适应度，记为 $W_{NC}$。携带该等位基因的个体与亚群中可用的伴侣随机交配。迁移之后，潜在的同谱系配偶比例为 $1-m$，潜在的异谱系配偶比例为 $m$。非选择性等位基因不带来直接的繁殖力成本，因此其相对繁殖力为 $1$。\n\n一个非选择性个体的后代平均生存力是基于其交配情况的加权平均值：\n-   比例为 $1-m$ 的交配是同谱系交配，产生的后代相对生存力为 $1$。\n-   比例为 $m$ 的交配是异谱系交配，产生的杂交后代相对生存力为 $1-s$。\n\n因此，平均后代生存力 $V_{NC}$ 为：\n$$V_{NC} = (1-m) \\cdot 1 + m \\cdot (1-s) = 1 - ms$$\n非选择性等位基因的总相对适应度 $W_{NC}$ 是其相对繁殖力与平均后代生存力的乘积：\n$$W_{NC} = 1 \\cdot V_{NC} = 1 - ms$$\n\n接下来，我们计算稀有的入侵性选择性等位基因的适应度，记为 $W_{C}$。该等位基因实行完美选型交配，意味着携带它的个体只与同谱系个体交配。因为该等位基因是稀有的，我们假设它不会耗尽可用的同谱系配偶库，并且总能找到配偶。因此，所有后代都来自同谱系交配，相对生存力为 $1$。\n\n然而，选择性等位基因会产生一个繁殖力成本 $c$，使产生的合子数量减少一个因子 $1-c$。因此，选择性等位基因的相对繁殖力为 $1-c$。\n\n选择性等位基因的总相对适应度 $W_{C}$ 是其降低的繁殖力与后代（最大）生存力的乘积：\n$$W_{C} = (1-c) \\cdot 1 = 1-c$$\n\n如果选择性等位基因在稀有时能够扩散，则生殖隔离的强化过程就会发生。这种情况发生在它的适应度大于原有的非选择性等位基因的适应度时，即 $W_{C} > W_{NC}$。我们可以将这个条件表示为以下不等式：\n$$1-c > 1-ms$$\n这个不等式代表了强化的基本权衡：选择性的内在成本 $c$ 必须小于通过不产生不适应的杂交后代而避免的适应度损失。对于一个随机交配的个体来说，杂交带来的预期适应度损失是杂交率 $m$ 和针对杂交后代的选择成本 $s$ 的乘积。\n\n为了找到关于 $s$ 的条件，我们解这个不等式。两边同时减去 $1$ 得到：\n$$-c > -ms$$\n两边同时乘以 $-1$ 会使不等号反向：\n$$c  ms$$\n假设存在迁移（$m > 0$），我们可以两边除以 $m$ 来分离出 $s$：\n$$s > \\frac{c}{m}$$\n这个不等式明确了强化过程发生的条件。临界阈值 $s^\\ast$ 是使得两个等位基因的适应度相等（$W_C = W_{NC}$）时的 $s$ 值。强化发生的充分必要条件是 $s > s^\\ast$。因此，临界阈值由下式给出：\n$$s^\\ast = \\frac{c}{m}$$", "answer": "$$\\boxed{\\frac{c}{m}}$$", "id": "2748821"}, {"introduction": "在野外观察到的演化模式往往可以由多种理论来解释，例如，同域分布中更强的合子前隔离可能是增强的结果，也可能是生态性状置换的副产品。这个练习将带你进入演化生物学家的现实挑战：如何利用有限的数据来区分这些竞争性假说[@problem_id:2748801]。你将学习并应用贝叶斯模型比较这一强大的统计工具，量化数据对不同假说的支持程度，从而做出更稳健的科学推断。", "problem": "在两种亲缘关系很近的昆虫物种的次级接触区内，给定两个独立的关于生殖隔离模式的定量总结，这些总结是基于许多种群对聚合而成的。第一个总结，记为 $S_{1}$，是同域和异域之间合子前隔离的标准化差异（正值表示同域中的合子前隔离更强）。第二个总结，记为 $S_{2}$，是同域和异域之间性状-环境耦合的Fisher $z$变换差异（正值表示同域中生态性状匹配更强）。假设 $S_{1}$ 和 $S_{2}$ 在其潜在效应参数给定的条件下是条件独立的，并且它们的抽样误差近似服从已知标准差的高斯分布。\n\n需要使用贝叶斯因子比较两个竞争性的进化假说：生殖隔离的强化（模型 $\\mathcal{R}$）和生态性状置换（模型 $\\mathcal{E}$）。为这些总结假设了以下生成模型：\n\n- 在模型 $\\mathcal{R}$（强化）下：\n  - $S_{1} \\mid \\delta \\sim \\mathcal{N}(\\delta, \\sigma_{1}^{2})$，其中 $\\delta \\sim \\mathcal{N}(\\mu_{\\delta \\mathcal{R}}, \\tau_{\\delta}^{2})$ 且 $\\mu_{\\delta \\mathcal{R}} = 0.8$，\n  - $S_{2} \\mid \\theta \\sim \\mathcal{N}(\\theta, \\sigma_{2}^{2})$，其中 $\\theta \\sim \\mathcal{N}(\\mu_{\\theta \\mathcal{R}}, \\tau_{\\theta}^{2})$ 且 $\\mu_{\\theta \\mathcal{R}} = 0$。\n\n- 在模型 $\\mathcal{E}$（生态性状置换）下：\n  - $S_{1} \\mid \\delta \\sim \\mathcal{N}(\\delta, \\sigma_{1}^{2})$，其中 $\\delta \\sim \\mathcal{N}(\\mu_{\\delta \\mathcal{E}}, \\tau_{\\delta}^{2})$ 且 $\\mu_{\\delta \\mathcal{E}} = 0$，\n  - $S_{2} \\mid \\theta \\sim \\mathcal{N}(\\theta, \\sigma_{2}^{2})$，其中 $\\theta \\sim \\mathcal{N}(\\mu_{\\theta \\mathcal{E}}, \\tau_{\\theta}^{2})$ 且 $\\mu_{\\theta \\mathcal{E}} = 0.9$。\n\n假设先验标准差在模型间共享，为 $\\tau_{\\delta} = 0.5$ 和 $\\tau_{\\theta} = 0.5$，抽样标准差为 $\\sigma_{1} = 0.35$ 和 $\\sigma_{2} = 0.30$。观测到的总结值为 $S_{1} = 1.10$ 和 $S_{2} = 0.85$。\n\n从贝叶斯定理和贝叶斯因子作为边际似然比的定义出发，计算支持强化假说相对于生态性状置换假说的贝叶斯因子 $BF_{\\mathcal{R},\\mathcal{E}}$。将 $S_{1}$ 和 $S_{2}$ 在给定模型参数下视为独立，并在每个模型下显式地对潜效应参数进行积分。将最终答案四舍五入到四位有效数字。", "solution": "该问题要求计算贝叶斯因子 $BF_{\\mathcal{R},\\mathcal{E}}$，以比较两个竞争性的进化假说：强化（$\\mathcal{R}$）和生态性状置换（$\\mathcal{E}$），给定两个观测到的数据总结 $S_1$ 和 $S_2$。\n\n首先，我们对问题陈述进行验证。\n已知条件如下：\n数据：$S_1 = 1.10$, $S_2 = 0.85$。\n抽样分布的标准差：$\\sigma_1 = 0.35$, $\\sigma_2 = 0.30$。\n先验分布的标准差：$\\tau_\\delta = 0.5$, $\\tau_\\theta = 0.5$。\n模型 $\\mathcal{R}$（强化）：\n$S_1 \\mid \\delta \\sim \\mathcal{N}(\\delta, \\sigma_1^2)$，其中 $\\delta \\sim \\mathcal{N}(\\mu_{\\delta\\mathcal{R}}, \\tau_\\delta^2)$，$\\mu_{\\delta\\mathcal{R}} = 0.8$。\n$S_2 \\mid \\theta \\sim \\mathcal{N}(\\theta, \\sigma_2^2)$，其中 $\\theta \\sim \\mathcal{N}(\\mu_{\\theta\\mathcal{R}}, \\tau_\\theta^2)$，$\\mu_{\\theta\\mathcal{R}} = 0$。\n模型 $\\mathcal{E}$（生态性状置换）：\n$S_1 \\mid \\delta \\sim \\mathcal{N}(\\delta, \\sigma_1^2)$，其中 $\\delta \\sim \\mathcal{N}(\\mu_{\\delta\\mathcal{E}}, \\tau_\\delta^2)$，$\\mu_{\\delta\\mathcal{E}} = 0$。\n$S_2 \\mid \\theta \\sim \\mathcal{N}(\\theta, \\sigma_2^2)$，其中 $\\theta \\sim \\mathcal{N}(\\mu_{\\theta\\mathcal{E}}, \\tau_\\theta^2)$，$\\mu_{\\theta\\mathcal{E}} = 0.9$。\n问题假设在给定模型参数的条件下 $S_1$ 和 $S_2$ 是独立的。这意味着它们的联合边际似然是它们各自边际似然的乘积。\n\n该问题具有科学依据，使用了演化生物学的标准概念（强化、性状置换）和标准的统计方法（贝叶斯模型选择）。问题陈述清晰，为得到唯一解提供了所有必要信息。语言客观而精确。该问题是有效的。\n\n支持模型 $\\mathcal{R}$ 相对于模型 $\\mathcal{E}$ 的贝叶斯因子定义为它们的边际似然之比：\n$$BF_{\\mathcal{R},\\mathcal{E}} = \\frac{p(S_1, S_2 | \\mathcal{R})}{p(S_1, S_2 | \\mathcal{E})}$$\n鉴于在每个模型下 $S_1$ 和 $S_2$ 的生成过程是独立的，模型 $\\mathcal{M}$ 的联合边际似然可以分解为：\n$$p(S_1, S_2 | \\mathcal{M}) = p(S_1 | \\mathcal{M}) p(S_2 | \\mathcal{M})$$\n因此，贝叶斯因子可以写成：\n$$BF_{\\mathcal{R},\\mathcal{E}} = \\frac{p(S_1 | \\mathcal{R}) p(S_2 | \\mathcal{R})}{p(S_1 | \\mathcal{E}) p(S_2 | \\mathcal{E})}$$\n我们必须计算每个模型下每个数据总结的边际似然。对于一个通用的总结 $S$、一个潜参数 $\\lambda$ 和一个模型 $\\mathcal{M}$，其结构为：\n似然：$S \\mid \\lambda \\sim \\mathcal{N}(\\lambda, \\sigma^2)$\n先验：$\\lambda \\sim \\mathcal{N}(\\mu, \\tau^2)$\n边际似然 $p(S|\\mathcal{M})$ 是通过对潜参数 $\\lambda$ 进行积分得到的：\n$$p(S|\\mathcal{M}) = \\int_{-\\infty}^{\\infty} p(S \\mid \\lambda) p(\\lambda | \\mathcal{M}) d\\lambda$$\n这是一个高斯-高斯共轭模型的标准结果。$S$ 的边际分布也是高斯分布：\n$$S \\sim \\mathcal{N}(\\mu, \\sigma^2 + \\tau^2)$$\n边际似然是这个得到的高斯分布的概率密度函数（PDF），在观测值 $S$ 处的取值：\n$$p(S|\\mathcal{M}) = \\frac{1}{\\sqrt{2\\pi(\\sigma^2 + \\tau^2)}} \\exp\\left(-\\frac{(S - \\mu)^2}{2(\\sigma^2 + \\tau^2)}\\right)$$\n\n让我们定义 $S_1$ 和 $S_2$ 的总方差：\n对于 $S_1$：$V_1 = \\sigma_1^2 + \\tau_\\delta^2 = (0.35)^2 + (0.5)^2 = 0.1225 + 0.25 = 0.3725$。\n对于 $S_2$：$V_2 = \\sigma_2^2 + \\tau_\\theta^2 = (0.30)^2 + (0.5)^2 = 0.09 + 0.25 = 0.34$。\n\n现在我们可以写出四个边际似然项：\n在模型 $\\mathcal{R}$ 下：\n$p(S_1 | \\mathcal{R}) = \\frac{1}{\\sqrt{2\\pi V_1}} \\exp\\left(-\\frac{(S_1 - \\mu_{\\delta\\mathcal{R}})^2}{2V_1}\\right)$\n$p(S_2 | \\mathcal{R}) = \\frac{1}{\\sqrt{2\\pi V_2}} \\exp\\left(-\\frac{(S_2 - \\mu_{\\theta\\mathcal{R}})^2}{2V_2}\\right)$\n\n在模型 $\\mathcal{E}$ 下：\n$p(S_1 | \\mathcal{E}) = \\frac{1}{\\sqrt{2\\pi V_1}} \\exp\\left(-\\frac{(S_1 - \\mu_{\\delta\\mathcal{E}})^2}{2V_1}\\right)$\n$p(S_2 | \\mathcal{E}) = \\frac{1}{\\sqrt{2\\pi V_2}} \\exp\\left(-\\frac{(S_2 - \\mu_{\\theta\\mathcal{E}})^2}{2V_2}\\right)$\n\n将这些代入贝叶斯因子的表达式中，归一化常数 $\\frac{1}{\\sqrt{2\\pi V_1}}$ 和 $\\frac{1}{\\sqrt{2\\pi V_2}}$ 会消掉：\n$$BF_{\\mathcal{R},\\mathcal{E}} = \\frac{\\exp\\left(-\\frac{(S_1 - \\mu_{\\delta\\mathcal{R}})^2}{2V_1}\\right) \\exp\\left(-\\frac{(S_2 - \\mu_{\\theta\\mathcal{R}})^2}{2V_2}\\right)}{\\exp\\left(-\\frac{(S_1 - \\mu_{\\delta\\mathcal{E}})^2}{2V_1}\\right) \\exp\\left(-\\frac{(S_2 - \\mu_{\\theta\\mathcal{E}})^2}{2V_2}\\right)}$$\n这可以简化为：\n$$BF_{\\mathcal{R},\\mathcal{E}} = \\exp\\left( -\\frac{1}{2} \\left[ \\frac{(S_1 - \\mu_{\\delta\\mathcal{R}})^2 - (S_1 - \\mu_{\\delta\\mathcal{E}})^2}{V_1} + \\frac{(S_2 - \\mu_{\\theta\\mathcal{R}})^2 - (S_2 - \\mu_{\\theta\\mathcal{E}})^2}{V_2} \\right] \\right)$$\n现在我们代入数值：\n$S_1 = 1.10$, $S_2 = 0.85$。\n$\\mu_{\\delta\\mathcal{R}} = 0.8$, $\\mu_{\\delta\\mathcal{E}} = 0$。\n$\\mu_{\\theta\\mathcal{R}} = 0$, $\\mu_{\\theta\\mathcal{E}} = 0.9$。\n$V_1 = 0.3725$, $V_2 = 0.34$。\n\n我们来计算方括号内的项。\n对于 $S_1$ 部分：\n$$\\frac{(1.10 - 0.8)^2 - (1.10 - 0)^2}{0.3725} = \\frac{(0.3)^2 - (1.1)^2}{0.3725} = \\frac{0.09 - 1.21}{0.3725} = \\frac{-1.12}{0.3725}$$\n对于 $S_2$ 部分：\n$$\\frac{(0.85 - 0)^2 - (0.85 - 0.9)^2}{0.34} = \\frac{(0.85)^2 - (-0.05)^2}{0.34} = \\frac{0.7225 - 0.0025}{0.34} = \\frac{0.72}{0.34}$$\n这两个部分的总和是：\n$$\\frac{-1.12}{0.3725} + \\frac{0.72}{0.34} \\approx -3.0067114 + 2.1176471 = -0.8890643$$\n最后，我们计算贝叶斯因子：\n$$BF_{\\mathcal{R},\\mathcal{E}} = \\exp\\left( -\\frac{1}{2} (-0.8890643) \\right) = \\exp(0.44453215) \\approx 1.559773$$\n四舍五入到四位有效数字，结果是 $1.560$。这个值表明，在强化模型（$\\mathcal{R}$）下观测到这些数据的可能性大约是在生态性状置换模型（$\\mathcal{E}$）下的 $1.56$ 倍。", "answer": "$$\\boxed{1.560}$$", "id": "2748801"}, {"introduction": "解析模型为我们提供了关于增强机制的核心见解，但它们通常忽略了如遗传漂变、基因连锁以及其他随机因素的复杂影响。本练习旨在通过构建一个计算机模拟实验，让你亲身体验这些复杂性如何影响增强的演化结局[@problem_id:2748819]。你将设计并实施一个包含选择、迁移、交配和遗传漂变的完整生命周期模拟，以探索在更现实的条件下，增强成功建立的概率。", "problem": "考虑一个关于增强（由于对杂种的选择压力而导致的合子前隔离的演化）的双种群、离散世代模型，该模型包含三个双等位基因座：两个分化的生态屏障基因座 $X \\in \\{0,1\\}$ 和 $Y \\in \\{0,1\\}$，以及一个偏好基因座 $R \\in \\{0,1\\}$。这两个种群被标记为 $d \\in \\{0,1\\}$。在种群 $d=0$ 中，局域适应的等位基因是 $X=1$ 和 $Y=1$；在种群 $d=1$ 中，局域适应的等位基因是 $X=0$ 和 $Y=0$。该模型假设成年个体为单倍体，通过有性繁殖产生后代，配对是随机的，但当 $R=1$ 时会进行选择性交配，存在针对局域适应不良等位基因的生存力选择，以及种群间的对称迁移。\n\n基本原理与定义：\n- 每个成年个体是一个携带单倍型 $(R,X,Y) \\in \\{0,1\\}^3$ 的单倍体配子。一个世代包括交配、后代产生、生存力选择、迁移和普查。\n- 连锁不平衡 (LD) 是为种群内屏障基因座 $X$ 和 $Y$ 定义的，由 $D = f_{11} f_{00} - f_{10} f_{01}$ 计算，其中 $f_{xy}$ 是 $X=x$ 和 $Y=y$ 的 $XY$ 单倍型的频率。\n- 生存力选择在两个屏障基因座上是乘性的：在种群 $d$ 中，一个单倍体后代在 $(X,Y)$ 上与局域最优型有 $k$ 个错配，其生存力为 $w = (1 - s)^k$，其中 $s \\in [0,1)$ 是每个等位基因的选择系数，$k \\in \\{0,1,2\\}$ 是后代 $(X,Y)$ 与种群 $d=0$ 中的局域最优型 $(1,1)$ 或种群 $d=1$ 中的局域最优型 $(0,0)$ 之间的错配数量。\n- 交配与选择性偏好：成年个体随机配对，但在种群 $d$ 中，拥有 $R=1$ 的成年个体会提高携带该种群局域最优屏障单倍型的潜在配偶的权重。具体来说，设 $\\alpha \\in [0,1)$ 为选择强度。对于种群 $d$ 中一个 $R=1$ 的选择者，如果一个潜在配偶拥有该种群的局域最优 $(X,Y)$ 单倍型，则选择该配偶的概率与 $(1+\\alpha)$ 成正比，否则与 $(1-\\alpha)$ 成正比；对于 $R=0$ 的选择者，所有配偶被选择的概率均等（与其当前频率成正比）。\n- 偏好代价：拥有 $R=1$ 的成年个体会承受一个生育力代价 $c \\in [0,1)$，具体表现为其预期交配次数减少一个因子 $(1-c)$。\n- 无单倍型内重组的后代形成：每次交配产生一个单倍体后代，该后代有 $1/2$ 的概率是母本单倍型，有 $1/2$ 的概率是父本单倍型。这在配偶选择层面上实现了基因混合，同时避免了单倍型内的额外重组。\n- 迁移：生存力选择之后，每个种群中一小部分比例为 $m \\in [0,1/2]$ 的存活者会迁移到另一个种群。\n- 普查：通过对迁移后的种群组成进行多项式抽样，将每个种群的规模重新调整为固定大小 $N$，这实现了一个 Wright–Fisher 抽样步骤。\n\n初始化：\n- 在每个种群内部，使用指定的初始连锁不平衡 $D_0 \\in [-1/4,1/4]$ 以及边际等位基因频率 $P(X=1)=1/2$ 和 $P(Y=1)=1/2$ 来初始化屏障单倍型频率。初始屏障单倍型频率为\n$$\nf_{11}(0) = \\tfrac{1}{4} + D_0,\\quad\nf_{10}(0) = \\tfrac{1}{4} - D_0,\\quad\nf_{01}(0) = \\tfrac{1}{4} - D_0,\\quad\nf_{00}(0) = \\tfrac{1}{4} + D_0.\n$$\n- 所有初始成年个体都拥有 $R=0$，例外情况是在种群 $d=0$ 中引入一个 $R=1$ 的拷贝，方法是替换一个（根据上述屏障单倍型频率抽取的）随机选择的成年个体，从而使得偏好等位基因的初始频率在种群 $d=0$ 中为 $1/N$，在种群 $d=1$ 中为 $0$。\n\n量化“增强的建立”：\n- 设 $\\theta \\in (0,1)$ 为建立阈值，$T$ 为模拟的世代数。我们将“建立”定义为在第 $T$ 代时，两个种群中 $R=1$ 的全局频率至少为 $\\theta$ 的事件。\n- 对于固定的参数 $(m,s,D_0)$，将增强建立的概率定义为满足建立标准的独立重复模拟所占的比例。\n\n需要实现的算法要求：\n- 使用一个有限种群的 Wright–Fisher 抽样方案，种群大小为 $N$，并遵循上述生命周期。\n- 在每个世代和每个种群中：\n  1. 在对 $R=1$ 的个体施加生育力代价 $(1-c)$ 后，确定每种单倍型类型的有效选择者数量。\n  2. 对于每种选择者单倍型类型，根据上述定义的偏好加权配偶分布来抽样选择配偶。\n  3. 对于每次交配，以各 $1/2$ 的概率将单倍体后代抽样为母本或父本单倍型。\n  4. 通过将后代数量乘以 $(1-s)^k$ 来施加生存力选择，其中 $k$ 是相对于局域最优型而言适应不良的屏障等位基因的数量。\n  5. 在种群之间施加迁移率为 $m$ 的对称迁移。\n  6. 通过多项式抽样将每个种群重新抽样至种群大小 $N$。\n\n- 初始连锁不平衡 $D_0$ 必须满足 $D_0 \\in [-1/4,1/4]$，以确保所有初始频率均为非负数。\n\n数值规定：\n- 每个种群的种群大小使用 $N = 200$。\n- 世代数使用 $T = 150$。\n- 选择强度使用 $\\alpha = 0.6$。\n- 生育力代价使用 $c = 0.01$。\n- 建立阈值使用 $\\theta = 0.8$。\n- 每个参数集的独立重复次数使用 $R_{\\mathrm{rep}} = 64$。\n- 将每个参数集的增强建立的估计概率表示为 $[0,1]$ 范围内的小数（而不是百分比）。\n\n测试集：\n提供一个程序，使用上述模型和数值规定，为下列每个参数集 $(m,s,D_0)$ 计算增强建立的概率。程序必须按相同顺序输出结果：\n1. $(m,s,D_0) = (0.0,\\ 0.1,\\ 0.0)$。\n2. $(m,s,D_0) = (0.05,\\ 0.0,\\ 0.1)$。\n3. $(m,s,D_0) = (0.05,\\ 0.2,\\ 0.2)$。\n4. $(m,s,D_0) = (0.2,\\ 0.2,\\ 0.2)$。\n5. $(m,s,D_0) = (0.05,\\ 0.2,\\ -0.2)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是按上述顺序列出的第 $i$ 个测试用例的估计概率（一个小数）。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上植根于演化群体遗传学的原理，特别是增强理论。该模型是良定的，所有参数、初始条件和动态过程都有明确无误的定义。整个设置是自洽的、逻辑一致的，并且没有科学或事实上的不健全之处。它代表了理论生物学中一个标准的、尽管是特定的计算问题，可以通过直接模拟来解决。\n\n任务是计算在不同参数组合下，偏好等位基因 $R=1$ 的建立概率。所采用的方法是实现一个随机的、离散世代的 Wright-Fisher 模拟，该模拟精确遵循指定的生命周期。对于每个参数集，此过程将重复进行 $R_{\\mathrm{rep}} = 64$ 次独立重复，以估计建立概率。\n\n系统状态由两个种群（$d \\in \\{0, 1\\}$）中每种可能单倍型 $(R,X,Y)$（共8种）的个体数量来描述。我们可以使用映射 $(R,X,Y) \\to 4R + 2X + Y$ 将单倍型从 0 索引到 7。因此，每个种群的群体由一个包含8个整数计数的向量表示，其总和为种群大小 $N=200$。\n\n模拟按以下步骤进行：\n\n**1. 初始化**\n对于每次重复模拟，两个种群的群体都将被初始化。\n- 基于初始连锁不平衡 $D_0$，计算四种屏障单倍型 $(X,Y)$ 的频率：$f_{11} = \\tfrac{1}{4} + D_0$，$f_{10} = \\tfrac{1}{4} - D_0$，$f_{01} = \\tfrac{1}{4} - D_0$ 和 $f_{00} = \\tfrac{1}{4} + D_0$。所有个体最初都拥有非偏好等位基因 $R=0$。\n- 对于每个种群，通过从具有这些频率的多项式分布中抽样，生成一个包含 $N=200$ 个个体的初始群体。这决定了具有 $R=0$ 的单倍型（索引为 0, 1, 2, 3）的数量。\n- 在种群 $d=0$ 中引入一个突变等位基因 $R=1$。这是通过从种群 $d=0$ 的初始 $N$ 个个体中随机选择一个个体，并将其 $R$ 等位基因从 0 更改为 1 来完成的。这意味着其单倍型索引 $i \\in \\{0,1,2,3\\}$ 变为 $i+4$。因此，$R=1$ 等位基因的初始频率在种群 $d=0$ 中为 $1/N$，在种群 $d=1$ 中为 0。\n\n**2. 世代循环**\n模拟运行 $T=150$ 个世代。在每个世代中，每个种群依次发生以下生命周期事件：\n\n**2a. 交配与后代产生**\n为了产生新一代的 $N$ 个后代，模拟了 $N$ 次交配。\n- **选择者确定**：选择个体作为“选择者”（母亲）。拥有偏好等位基因 $R=1$ 的个体生育力较低，通过将其被选中的概率降低一个因子 $(1-c)$ 来实现。根据这些经代价调整的频率抽样出 $N$ 个选择者。\n- **配偶选择**：每个选择者从大小为 $N$ 的整个种群中选择一个“被选中的”配偶（父亲）。\n    - 如果选择者拥有等位基因 $R=0$，则根据其在种群中的频率随机选择配偶。\n    - 如果选择者拥有等位基因 $R=1$，其选择是选择性的。如果配偶携带局域最优的 $(X,Y)$ 单倍型（即在种群 $d=0$ 中为 $(1,1)$；在种群 $d=1$ 中为 $(0,0)$），则选择该配偶的概率加权为 $(1+\\alpha)$，否则加权为 $(1-\\alpha)$。\n- **后代形成**：对于 $N$ 个交配对中的每一个，都会产生一个单倍体后代。后代的单倍型以各 $1/2$ 的概率随机选择为母亲的单倍型或父亲的单倍型。此过程生成一个包含 $N$ 个新后代的池。\n\n**2b. 生存力选择**\n后代的生存取决于其生态屏障等位基因 $(X,Y)$。\n- 在种群 $d$ 中，一个后代的生存力是 $w = (1-s)^k$，其中 $k \\in \\{0,1,2\\}$ 是其屏障等位基因与局域最优型不匹配的数量，$s$ 是每个等位基因的选择系数。例如，在种群 $d=0$ 中，最优型为 $(X,Y)=(1,1)$，一个单倍型为 $(X,Y)=(0,1)$ 的个体有 $k=1$ 个错配。\n- 每种单倍型的后代数量乘以其相应的生存力，得出每种类型的预期存活者数量。\n\n**2c. 迁移**\n每个种群中比例为 $m$ 的存活个体会迁移到另一个种群。由于迁移是对称的，种群 $d=0$ 迁移后的组成是其自身存活者的 $(1-m)$ 加上来自种群 $d=1$ 的存活者的 $m$。种群 $d=1$ 的组成则相应地更新。\n\n**2d. 普查 (Wright-Fisher 抽样)**\n一个世代的最后一步是密度依赖性调节，建模为多项式抽样。\n- 计算每个种群迁移后池中所有单倍型的相对频率。\n- 从由这些频率定义的多项式分布中为每个种群抽样出一个恰好包含 $N=200$ 个成年个体的新群体。这构成了下一代开始时的成年群体。\n\n**3. 建立标准**\n在 $T=150$ 个世代后，一次重复的模拟结束。评估偏好等位基因 $R=1$ 是否建立。\n- $R=1$ 等位基因的全局频率计算为两个种群中 $R=1$ 个体的总数除以总种群大小 $2N$。\n- 如果该全局频率大于或等于阈值 $\\theta=0.8$，则认为该等位基因在该次重复中已建立。\n- 对于给定的参数集，最终输出是在 $R_{\\mathrm{rep}}=64$ 次重复中发生建立的比例。这提供了增强建立概率的数值估计。\n\n这个模拟框架将使用 Python 实现，并利用 NumPy 库进行高效的数值和随机运算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    # Numerical specifications from the problem statement\n    N = 200        # Population size per deme\n    T = 150        # Number of generations\n    alpha = 0.6    # Assortative strength\n    c = 0.01       # Fertility cost of preference\n    theta = 0.8    # Establishment threshold for R=1 allele frequency\n    R_rep = 64     # Number of independent replicates\n    \n    # Haplotype mapping: (R,X,Y) - 4*R + 2*X + Y\n    # (0,0,0) - 0, (0,0,1) - 1, (0,1,0) - 2, (0,1,1) - 3\n    # (1,0,0) - 4, (1,0,1) - 5, (1,1,0) - 6, (1,1,1) - 7\n\n    # Mismatch vectors for viability selection\n    # k = number of mismatches relative to local optimum\n    # Deme 0 optimum: (1,1). (X,Y) for indices 0,1,2,3 are (0,0),(0,1),(1,0),(1,1)\n    k_xy_deme0 = np.array([2, 1, 1, 0])\n    mismatch_vector_0 = np.concatenate([k_xy_deme0, k_xy_deme0])\n    \n    # Deme 1 optimum: (0,0)\n    k_xy_deme1 = np.array([0, 1, 1, 2])\n    mismatch_vector_1 = np.concatenate([k_xy_deme1, k_xy_deme1])\n\n    mismatch_vectors = [mismatch_vector_0, mismatch_vector_1]\n\n    # Preference masks for assortative mating\n    # is_optimal_mate[j] is True if haplotype j has the locally optimal (X,Y)\n    is_optimal_mate_0 = np.array([0,0,0,1,0,0,0,1], dtype=bool) # Optimum (1,1)\n    is_optimal_mate_1 = np.array([1,0,0,0,1,0,0,0], dtype=bool) # Optimum (0,0)\n    \n    optimal_mate_masks = [is_optimal_mate_0, is_optimal_mate_1]\n\n    test_cases = [\n        (0.0, 0.1, 0.0),\n        (0.05, 0.0, 0.1),\n        (0.05, 0.2, 0.2),\n        (0.2, 0.2, 0.2),\n        (0.05, 0.2, -0.2),\n    ]\n\n    results = []\n    for params in test_cases:\n        m, s, D0 = params\n        prob = run_replicates(params, N, T, alpha, c, theta, R_rep, \n                              mismatch_vectors, optimal_mate_masks)\n        results.append(prob)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_replicates(params, N, T, alpha, c, theta, R_rep, \n                   mismatch_vectors, optimal_mate_masks):\n    \"\"\"\n    Runs all replicates for a single parameter set.\n    \"\"\"\n    m, s, D0 = params\n    establishment_count = 0\n\n    # Pre-calculate viabilities as they are constant for a given 's'\n    viabilities = [(1 - s) ** mv for mv in mismatch_vectors]\n\n    for _ in range(R_rep):\n        pop0, pop1 = initialize_populations(D0, N)\n        \n        for _ in range(T):\n            pop0, pop1 = run_one_generation(pop0, pop1, N, m, alpha, c,\n                                            viabilities, optimal_mate_masks)\n\n        global_r1_freq = (np.sum(pop0[4:]) + np.sum(pop1[4:])) / (2 * N)\n        if global_r1_freq >= theta:\n            establishment_count += 1\n            \n    return establishment_count / R_rep\n\ndef initialize_populations(D0, N):\n    \"\"\"\n    Initializes populations for two demes for one replicate.\n    \"\"\"\n    f11 = 0.25 + D0\n    f10 = 0.25 - D0\n    f01 = 0.25 - D0\n    f00 = 0.25 + D0\n    \n    # Ensure frequencies are valid\n    initial_barrier_freqs = np.array([f00, f01, f10, f11])\n    initial_barrier_freqs = np.maximum(0, initial_barrier_freqs)\n    initial_barrier_freqs /= np.sum(initial_barrier_freqs)\n\n    pop0 = np.zeros(8, dtype=int)\n    pop1 = np.zeros(8, dtype=int)\n    \n    pop0[0:4] = np.random.multinomial(N, initial_barrier_freqs)\n    pop1[0:4] = np.random.multinomial(N, initial_barrier_freqs)\n\n    # Introduce a single R=1 mutant in deme 0\n    if N > 0:\n        # Probabilities of R=0 haplotypes in deme 0\n        victim_probs = pop0[0:4] / N\n        # Choose one R=0 haplotype to mutate\n        victim_draw = np.random.multinomial(1, victim_probs)\n        victim_idx_r0 = np.where(victim_draw == 1)[0][0]\n        \n        pop0[victim_idx_r0] -= 1\n        pop0[victim_idx_r0 + 4] += 1\n        \n    return pop0, pop1\n\ndef run_one_generation(pop0_in, pop1_in, N, m, alpha, c, viabilities, \n                       optimal_mate_masks):\n    \"\"\"\n    Simulates one full generation (mating, selection, migration, census).\n    \"\"\"\n    survivors0 = process_deme(pop0_in, 0, N, alpha, c, viabilities[0], optimal_mate_masks[0])\n    survivors1 = process_deme(pop1_in, 1, N, alpha, c, viabilities[1], optimal_mate_masks[1])\n\n    post_mig_0 = (1 - m) * survivors0 + m * survivors1\n    post_mig_1 = m * survivors0 + (1 - m) * survivors1\n    \n    # Census (Wright-Fisher sampling)\n    sum_post_mig_0 = np.sum(post_mig_0)\n    if sum_post_mig_0 > 0:\n        freqs0 = post_mig_0 / sum_post_mig_0\n        pop0_out = np.random.multinomial(N, freqs0)\n    else:\n        pop0_out = np.zeros(8, dtype=int)\n\n    sum_post_mig_1 = np.sum(post_mig_1)\n    if sum_post_mig_1 > 0:\n        freqs1 = post_mig_1 / sum_post_mig_1\n        pop1_out = np.random.multinomial(N, freqs1)\n    else:\n        pop1_out = np.zeros(8, dtype=int)\n        \n    return pop0_out, pop1_out\n\ndef process_deme(pop_in, deme_id, N, alpha, c, viability_vector, optimal_mate_mask):\n    \"\"\"\n    Processes a single deme through mating and viability selection.\n    \"\"\"\n    if np.sum(pop_in) == 0:\n        return np.zeros(8)\n        \n    # 1. Mating\n    # 1a. Effective choosers (accounting for cost c)\n    effective_choosers = pop_in.astype(float)\n    effective_choosers[4:] *= (1 - c)\n    total_eff_choosers = np.sum(effective_choosers)\n    if total_eff_choosers == 0:\n        return np.zeros(8)\n    chooser_probs = effective_choosers / total_eff_choosers\n    \n    # 1b. Mate choice probabilities\n    mate_freqs = pop_in / N\n    mate_choice_probs_R0 = mate_freqs\n    \n    weights_R1 = np.full(8, 1 - alpha)\n    weights_R1[optimal_mate_mask] = 1 + alpha\n    unnorm_probs_R1 = mate_freqs * weights_R1\n    sum_unnorm_probs_R1 = np.sum(unnorm_probs_R1)\n    mate_choice_probs_R1 = unnorm_probs_R1 / sum_unnorm_probs_R1 if sum_unnorm_probs_R1 > 0 else mate_freqs\n\n    # 1c. Offspring production\n    chooser_counts = np.random.multinomial(N, chooser_probs)\n    offspring_counts = np.zeros(8, dtype=int)\n\n    # R=0 choosers\n    n_choosers_r0 = np.sum(chooser_counts[0:4])\n    if n_choosers_r0 > 0:\n        maternal_haps = np.repeat(np.arange(4), chooser_counts[0:4])\n        paternal_haps = np.random.choice(8, size=n_choosers_r0, p=mate_choice_probs_R0)\n        is_maternal = np.random.rand(n_choosers_r0) > 0.5\n        offspring_haps = np.where(is_maternal, maternal_haps, paternal_haps)\n        offspring_counts += np.bincount(offspring_haps, minlength=8)\n\n    # R=1 choosers\n    n_choosers_r1 = np.sum(chooser_counts[4:8])\n    if n_choosers_r1 > 0:\n        maternal_haps = np.repeat(np.arange(4, 8), chooser_counts[4:8])\n        paternal_haps = np.random.choice(8, size=n_choosers_r1, p=mate_choice_probs_R1)\n        is_maternal = np.random.rand(n_choosers_r1) > 0.5\n        offspring_haps = np.where(is_maternal, maternal_haps, paternal_haps)\n        offspring_counts += np.bincount(offspring_haps, minlength=8)\n\n    # 2. Viability Selection\n    survivors = offspring_counts * viability_vector\n    return survivors\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2748819"}]}