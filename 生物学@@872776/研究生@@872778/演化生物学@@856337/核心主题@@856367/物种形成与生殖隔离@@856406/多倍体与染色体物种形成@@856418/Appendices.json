{"hands_on_practices": [{"introduction": "多倍体物种形成始于一个罕见的事件：一个多倍体个体的形成。理解这一事件的发生频率是评估其进化可行性的第一步。这个练习 [@problem_id:2744643] 运用基本概率论来构建一个模型，计算由未减数配子形成同源四倍体合子的频率。通过这个练习，你将学会如何从第一性原理出发建立一个简单的群体遗传学模型，并揭示减数分裂错误率和交配系统等基本参数如何影响多倍体的初始出现。", "problem": "在一个大的、随机交配的、雌雄同体的二倍体植物种群中，考虑在一个繁殖季节内合子的形成。每个个体都产生雄配子和雌配子。在配子发生过程中，每个配子独立地发生减数分裂失败，成为未减数（倍性 $2n$）配子的概率为 $u \\in [0,1]$，成为减数（倍性 $n$）配子的概率为 $1-u$。有比例为 $s \\in [0,1]$ 的合子由单个个体的自花受精形成，其余比例为 $1-s$ 的合子由不同个体间的随机交配形成。假设：\n- 个体内和个体间的配子发生事件是独立的（即使在同一个亲本内，雄性和雌性减数分裂也是独立的）。\n- 合子的倍性是亲本配子倍性的总和。\n- 在此设定中，只有两个未减数配子的结合才能产生同源四倍体（$4n$）合子。其他形成 $4n$ 的途径（例如，合子形成后的体细胞加倍）不存在。\n- 此处考虑的所有具有相容倍性等级的合子在形成时都是存活的。\n\n使用减数分裂分离的基本原理和全概率定律，推导新形成的合子中同源四倍体所占的期望比例 $R_{4n}(u,s)$，用 $u$ 和 $s$ 表示。将你的答案表示为关于 $u$ 和 $s$ 的单个闭式表达式。不要以百分比报告；以 $[0,1]$ 区间内的小数或分数形式提供表达式。无需进行数值四舍五入。", "solution": "目标是确定新形成的合子中同源四倍体所占的期望比例，我们将其表示为 $R_{4n}(u,s)$。问题陈述指出，同源四倍体（$4n$）合子仅由两个未减数（$2n$）配子的融合形成。任何单个配子成为未减数配子的概率为 $u$。\n\n我们可以使用全概率定律来解决这个问题。合子的形成可以划分为两个互斥事件：\n1.  自花受精（事件 $S$），其发生概率为 $P(S) = s$。\n2.  异交或随机交配（事件 $O$），其发生概率为 $P(O) = 1-s$。\n\n设 $Z_{4n}$ 为合子是同源四倍体的事件。该事件的总概率是其在不同受精模式下的条件概率，按这些模式的概率加权求和：\n$$\nR_{4n}(u,s) = P(Z_{4n}) = P(Z_{4n} | S) P(S) + P(Z_{4n} | O) P(O)\n$$\n我们现在必须确定条件概率 $P(Z_{4n} | S)$ 和 $P(Z_{4n} | O)$。\n\n**情况 1：自花受精（以事件 $S$ 为条件）**\n在这种情况下，单个亲本个体提供雄配子和雌配子。当且仅当这两个配子都是未减数（$2n$）时，才会产生 $4n$ 合子。设 $M_{2n}$ 为雄配子未减数的事件， $F_{2n}$ 为雌配子未减数的事件。每个事件的概率为 $P(M_{2n}) = u$ 和 $P(F_{2n}) = u$。\n问题明确指出，“即使在同一个亲本内，雄性和雌性减数分裂也是独立的”。因此，来自单个自花受精亲本的两个配子都是未减数的概率是它们各自概率的乘积：\n$$\nP(Z_{4n} | S) = P(M_{2n} \\cap F_{2n} | S) = P(M_{2n} | S) \\cdot P(F_{2n} | S) = u \\cdot u = u^{2}\n$$\n\n**情况 2：异交（以事件 $O$ 为条件）**\n在这种情况下，合子由从种群中随机选择的两个不同个体产生的配子形成。一个个体提供雄配子，另一个个体提供雌配子。同样，要形成 $4n$ 合子，两个配子都必须是未减数（$2n$）的。\n问题陈述配子发生事件在“个体间”是独立的。从任何随机选择的个体中取出一个配子，其为未减数的概率是 $u$。因此，来自一个亲本的雄配子是未减数的概率为 $u$，来自另一个亲本的雌配子是未减数的概率也为 $u$。由于它们的独立性，联合概率为：\n$$\nP(Z_{4n} | O) = P(M_{2n} \\cap F_{2n} | O) = P(M_{2n} | O) \\cdot P(F_{2n} | O) = u \\cdot u = u^{2}\n$$\n\n现在，我们将这些条件概率代入全概率公式：\n$$\nR_{4n}(u,s) = P(Z_{4n} | S) \\cdot s + P(Z_{4n} | O) \\cdot (1-s)\n$$\n$$\nR_{4n}(u,s) = u^{2} \\cdot s + u^{2} \\cdot (1-s)\n$$\n提出公因式 $u^{2}$：\n$$\nR_{4n}(u,s) = u^{2} (s + (1-s))\n$$\n$$\nR_{4n}(u,s) = u^{2} (1)\n$$\n$$\nR_{4n}(u,s) = u^{2}\n$$\n结果表明，在问题所提供的严格独立性假设下，新形成的同源四倍体合子的比例与自交率 $s$ 无关。形成 $4n$ 合子的概率仅仅是两个独立的减数分裂失败事件发生的概率，每个对合子有贡献的配子各发生一次，而不管这些配子是来自一个还是两个亲本。", "answer": "$$\n\\boxed{u^{2}}\n$$", "id": "2744643"}, {"introduction": "一旦多倍体形成，它们常常与其二倍体祖先共存，形成混合倍性群体。“三倍体桥梁”——即三倍体杂种的形成及其与亲本的回交——是潜在基因流的关键途径，这既可能阻碍也可能促进物种形成。这个问题 [@problem_id:2744681] 将我们的模型扩展到一个动态情景，要求你计算三倍体的形成速率以及随后通过此桥梁在不同倍性水平之间的基因流速率。这个实践为你提供了一个定量框架，用以理解合子后生殖隔离以及不同细胞型接触带的复杂动态。", "problem": "考虑一个同源多倍体植物，其种群中存在两种常驻细胞型：倍性为 $2x$ 的二倍体和倍性为 $4x$ 的四倍体。它们共同存在于一个大型、随机交配、雌雄同体的种群中。设成年个体的细胞型频率，$2x$ 的频率为 $f_{2}$，$4x$ 的频率为 $f_{4}$，且 $f_{2}+f_{4}=1$。假设以下基本事实和简化假定成立，这些都在许多同源多倍体系统中得到了充分支持：\n\n- 在随机交配（配子随机结合）条件下，$2x$ 和 $4x$ 细胞型之间的异型配对预期比例为 $2 f_{2} f_{4}$；同型配对的比例分别为 $f_{2}^{2}$ 和 $f_{4}^{2}$。\n- 二倍体 ($2x$) 产生单倍体 ($x$) 配子；四倍体 ($4x$) 产生二倍体 ($2x$) 配子；$2x$ 或 $4x$ 均不产生未减数配子。\n- 异型交配 $2x \\times 4x$ 产生能存活至繁殖阶段的三倍体 ($3x$) 合子；同型交配分别产生 $2x$ 或 $4x$ 合子。\n- 三倍体的减数分裂是多体的，且同源染色体分离无偏向。在产生任何可存活配子的条件下，一个三倍体产生整倍体 $x$ 配子和 $2x$ 配子的概率相等，各为 $1/2$；非整倍体配子无生活力，予以忽略。\n- 定义三倍体育性参数 $\\phi \\in [0,1]$ 为：涉及一个三倍体亲本和一个 $2x$ 或 $4x$ 亲本的交配，产生任何可存活的整倍体合子的单次交配概率（计算该交配可能产生的两种整倍体后代）。因此，在这样一次成功交配的条件下，后代属于其交配对象细胞型（对于 $3x \\times 2x$ 交配，后代为 $2x$；对于 $3x \\times 4x$ 交配，后代为 $4x$）的概率为 $1/2$。\n\n在此框架内：\n\n1) 在随机交配条件下，推导当前代中三倍体合子的预期比例 $R_{3}$，作为 $f_{2}$ 和 $f_{4}$ 的函数。\n\n2) 仅使用上述假设和参数 $\\phi$，推导三倍体桥对跨倍性基因流的每代贡献。这被定义为下一代所有合子中，通过 $3x$ 与 $4x$ 亲本回交而进入 $4x$ 类型的比例（记为 $m_{2\\to 4}$），以及通过 $3x$ 与 $2x$ 亲本回交而进入 $2x$ 类型的比例（记为 $m_{4\\to 2}$）。假设所考虑的连续两代中细胞型频率近似恒定（因此三倍体在下一代中遇到的交配对象按 $f_{2}$ 和 $f_{4}$ 的比例分布），并且每次交配最多产生一个合子。\n\n用 $f_{2}$、$f_{4}$ 和 $\\phi$ 表示你的最终答案。按 $R_{3}$、$m_{2\\to 4}$、$m_{4\\to 2}$ 的顺序，将最终表达式以单行矩阵的形式给出。不需要进行数值近似。", "solution": "该问题要求推导与二倍体和四倍体细胞型共存的种群遗传学相关的三个量：三倍体形成的初始速率，以及由产生的三倍体介导的倍性水平之间的基因流速率。\n\n**第1部分：三倍体合子的预期比例 ($R_{3}$)**\n\n初始种群由频率分别为 $f_{2}$ 和 $f_{4}$ 的二倍体 ($2x$) 和四倍体 ($4x$) 个体组成，满足 $f_{2} + f_{4} = 1$。交配通过配子的随机结合发生。三倍体 ($3x$) 合子仅由二倍体和四倍体个体之间的异型交配形成。一个二倍体个体 ($2x$) 产生单倍体 ($x$) 配子。一个四倍体个体 ($4x$) 产生二倍体 ($2x$) 配子。一个 $x$ 配子和一个 $2x$ 配子的融合产生一个 $3x$ 合子。\n问题陈述，种群中异型配对 ($2x \\times 4x$) 的预期比例为 $2 f_{2} f_{4}$。假设这些交配的育性为基准（归一化为1），则新一代中三倍体合子的比例等于产生它们的交配比例。\n因此，三倍体合子的预期比例，记为 $R_{3}$，是：\n$$R_{3} = 2 f_{2} f_{4}$$\n\n**第2部分：三倍体桥对基因流的贡献 ($m_{2\\to 4}$ 和 $m_{4\\to 2}$)**\n\n这些量被定义为下一代所有合子中，通过三倍体回交途径产生的特定合子所占的比例。\n\n**$m_{2\\to 4}$ 的计算 (基因从 $2x$ 流向 $4x$)**\n该途径需要一系列事件：\n1.  形成一个三倍体：这发生在 $2x \\times 4x$ 杂交中，其在总合子库中的产生速率为 $R_{3} = 2f_{2}f_{4}$。\n2.  三倍体与四倍体 ($4x$) 交配：在随机交配下，其概率为 $f_{4}$。\n3.  交配成功：这次 $3x \\times 4x$ 交配必须是可育的，产生一个可存活的整倍体合子，概率为 $\\phi$。\n4.  产生一个 $4x$ 后代：在一次成功交配的条件下，后代必须是四倍体。$3x$ 亲本产生 $x$ 和 $2x$ 配子（概率各为 $1/2$），$4x$ 亲本产生 $2x$ 配子。可能的整倍体后代为 $x+2x=3x$ 和 $2x+2x=4x$。两者概率相等，因此产生 $4x$ 合子的条件概率是 $1/2$。\n\n将这些概率相乘，得到总比例：\n$$m_{2\\to 4} = (2f_{2}f_{4}) \\times (f_{4}) \\times (\\phi) \\times \\left(\\frac{1}{2}\\right) = f_{2}f_{4}^{2}\\phi$$\n\n**$m_{4\\to 2}$ 的计算 (基因从 $4x$ 流向 $2x$)**\n该途径同样需要一系列事件：\n1.  形成一个三倍体：产生速率为 $R_{3} = 2f_{2}f_{4}$。\n2.  三倍体与二倍体 ($2x$) 交配：概率为 $f_{2}$。\n3.  交配成功：概率为 $\\phi$。\n4.  产生一个 $2x$ 后代：在一次成功交配的条件下，后代必须是二倍体。$3x$ 亲本产生 $x$ 和 $2x$ 配子（概率各为 $1/2$），$2x$ 亲本产生 $x$ 配子。可能的整倍体后代为 $x+x=2x$ 和 $2x+x=3x$。两者概率相等，因此产生 $2x$ 合子的条件概率是 $1/2$。\n\n将这些概率相乘，得到总比例：\n$$m_{4\\to 2} = (2f_{2}f_{4}) \\times (f_{2}) \\times (\\phi) \\times \\left(\\frac{1}{2}\\right) = f_{2}^{2}f_{4}\\phi$$\n\n所求三个量的最终表达式为：\n-   $R_{3} = 2f_{2}f_{4}$\n-   $m_{2\\to 4} = f_{2}f_{4}^{2}\\phi$\n-   $m_{4\\to 2} = f_{2}^{2}f_{4}\\phi$\n\n这些结果以单行矩阵的形式呈现。", "answer": "$$ \\boxed{ \\begin{pmatrix} 2f_{2}f_{4} & f_{2}f_{4}^{2}\\phi & f_{2}^{2}f_{4}\\phi \\end{pmatrix} } $$", "id": "2744681"}, {"introduction": "在自然界中识别多倍体物种形成需要综合分析不同类型的数据。我们如何将染色体计数和杂交育性数据结合起来，进行严谨的推断？这项练习 [@problem_id:2744638] 要求你将生物学假设转化为一个形式化的计算流程。它利用数学标准来区分多倍体物种形成与其他现象（如非整倍性或染色体重排）。这项综合性实践将你从理论建模引向数据驱动的推断，这是现代生物学家的一项关键技能，它迫使你思考如何操作化复杂的生物学概念并构建一个稳健的决策工具。", "problem": "您会收到几个独立的测试用例。在每个测试用例中，都有一组由 $i \\in \\{1,\\dots,N\\}$ 索引的种群。对于每个种群 $i$，您会得到一个整数染色体数 $c_i \\in \\mathbb{N}$ 和一个成对杂交育性对称矩阵 $F \\in [0,1]^{N \\times N}$，其中 $F_{ij}$ 在一个从0到1的无量纲尺度上量化了种群 $i$ 和 $j$ 之间杂交的相对育性（1表示完全育性，与种群内杂交相同）。目标是实现一个数学上严谨的决策流程，以推断数据是否与多倍体物种形成事件最为一致，并排除基于非整倍性或染色体多态性的解释。\n\n需要使用的基本生物学基础：\n- 全基因组复制意味着不同分化细胞型之间的染色体数量按整数倍性因子缩放。在数学上，存在一个基数 $g \\in \\mathbb{N}$ 和整数乘数 $m_i \\in \\mathbb{N}$，使得对于每个 $i$ 都有 $c_i \\approx m_i g$。\n- 不同倍性水平之间的杂交育性通常会显著降低，而相同倍性水平内的杂交通常是可育的。因此，在共享相同推断乘数 $m_i$ 的组内，育性预计会很高，而在具有不同 $m_i$ 的组间，育性预计会很低。\n- 非整倍性意味着在其他方面相似的染色体数量上存在小的偏差（例如 $\\pm 1$），而群体间没有整数倍数结构，并且通常不伴随按染色体数量划分的强烈、离散的育性分离。\n- 染色体多态性（例如结构重排）可以在染色体数量相同或几乎相同的情况下降低育性，并可能产生分支内高育性、分支间低育性的模式，即使所有 $c_i$ 都相等（或几乎相等）。\n\n设计并实现一个程序，对每个测试用例应用以下纯粹用数学术语表述的逻辑：\n\n- 通过整数格点近似进行倍性模型拟合：\n  - 对于候选基数 $g \\in \\{2,3,\\dots,\\min_i c_i\\}$，通过 $m_i(g) = \\max\\{1, \\operatorname{round}(c_i / g)\\}$ 定义整数乘数，并通过 $r_i(g) = |c_i - m_i(g)\\,g|$ 定义所有 $i$ 的残差。\n  - 令平均绝对残差为 $\\bar r(g) = \\frac{1}{N} \\sum_{i=1}^N r_i(g)$。\n  - 将最佳拟合基数 $g^\\star$ 定义为候选集上 $\\bar r(g)$ 的一个最小值点。\n  - 如果 $\\bar r(g^\\star) \\le \\delta$ 并且推断出的乘数 $\\{m_i(g^\\star)\\}$ 产生至少两个不同的组，则接受该倍性模型拟合。\n\n- 给定推断乘数的育性分离检验：\n  - 使用由 $m_i(g^\\star)$ 导出的划分，将组内平均育性 $\\mu_{\\mathrm{within}}$ 定义为所有满足 $m_i(g^\\star) = m_j(g^\\star)$ 的无序对 $(i,j)$（其中 $i  j$）的 $F_{ij}$ 的平均值，并将组间平均育性 $\\mu_{\\mathrm{between}}$ 定义为所有满足 $m_i(g^\\star) \\ne m_j(g^\\star)$ 的无序对 $(i,j)$（其中 $i  j$）的 $F_{ij}$ 的平均值。\n  - 如果至少存在一对组内配对和一对组间配对，并且 $\\mu_{\\mathrm{within}} \\ge \\theta_w$ 且 $\\mu_{\\mathrm{between}} \\le \\theta_b$，则接受育性分离。\n\n- 染色体多态性替代方案：\n  - 如果倍性模型接受失败或育性分离检验失败，检查染色体数量是否几乎相同：$\\max_i c_i - \\min_i c_i \\le 1$。\n  - 如果几乎相同，则确定是否存在一种将种群划分为两个非空组的双分区，该分区能产生与上述阈值相同的组内与组间育性分离。形式上，对于 $\\{1,\\dots,N\\}$ 的所有非平凡双分区（划分为 $A$ 和 $B$，其中 $A \\ne \\emptyset$, $B \\ne \\emptyset$, $A \\cup B = \\{1,\\dots,N\\}$, $A \\cap B = \\emptyset$），计算 $A$ 内部或 $B$ 内部所有无序对的平均育性（合并的组内平均值）以及一个索引在 $A$ 中另一个在 $B$ 中的所有无序对的平均育性。如果存在至少一个双分区，使得合并的组内平均值至少为 $\\theta_w$ 且组间平均值至多为 $\\theta_b$，则接受染色体多态性解释。\n\n- 每个测试用例的最终分类：\n  - 如果倍性模型拟合被接受，并且（基于乘数的）育性分离检验也被接受，则输出 $2$。\n  - 否则，如果染色体多态性替代方案被接受，则输出 $1$。\n  - 否则，输出 $0$（与非整倍体或其他非多倍体解释一致）。\n\n对所有测试用例使用以下固定阈值：\n- 绝对残差容忍度 $\\delta = 1.0$。\n- 组内育性阈值 $\\theta_w = 0.7$。\n- 组间育性阈值 $\\theta_b = 0.2$。\n\n您的程序必须解决以下四个测试用例并汇总其分类结果：\n\n- 测试用例 1：\n  - 染色体数量 $c = [\\,14,\\,14,\\,28,\\,28,\\,42,\\,42\\,]$。\n  - 育性矩阵 $F$ 定义为：对所有 $i$， $F_{ii} = 1$；对于第一组中两个 $c = 14$ 的种群内的配对，$F_{ij} = 0.92$；对于两个 $c = 28$ 的种群内的配对，$F_{ij} = 0.93$；对于两个 $c = 42$ 的种群内的配对，$F_{ij} = 0.91$；对于所有属于不同数量组的配对 $(i,j)$（$i \\ne j$），$F_{ij} = 0.08$。\n\n- 测试用例 2：\n  - 染色体数量 $c = [\\,14,\\,15,\\,16,\\,15\\,]$。\n  - 育性矩阵 $F$ 定义为：对所有 $i$，$F_{ii} = 1$；对所有 $i \\ne j$，$F_{ij} = 0.5$。\n\n- 测试用例 3：\n  - 染色体数量 $c = [\\,14,\\,14,\\,14,\\,14,\\,14,\\,14\\,]$。\n  - 育性矩阵 $F$ 由两个各有三个种群的分支定义：对于前三个索引和后三个索引，当 $i \\ne j$ 且在同一分支内时，$F_{ij} = 0.9$；对于跨分支的配对，$F_{ij} = 0.1$；且 $F_{ii} = 1$。\n\n- 测试用例 4：\n  - 染色体数量 $c = [\\,24,\\,24,\\,48,\\,48,\\,49\\,]$。\n  - 育性矩阵 $F$ 定义为：对所有 $i$，$F_{ii} = 1$；对于两个 $c = 24$ 的种群配对，$F_{ij} = 0.93$；对于两个 $c = 48$ 的种群配对，$F_{ij} = 0.92$；对于 $c = 49$ 的种群与两个 $c = 48$ 的种群中每一个的配对，$F_{ij} = 0.72$；对于所有24染色体数组与48或49染色体数组之间的配对，$F_{ij} = 0.08$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号内以逗号分隔的列表，例如 $[2,0,1,2]$。输出值必须是整数。\n\n不涉及物理单位。不涉及角度。不得使用百分比；所有育性量均为 $[0,1]$ 区间内的无单位小数。", "solution": "该问题要求根据所提供的决策流程和阈值，对四个测试用例进行分类。以下是每个案例的逐步分析。\n\n**测试用例 1**\n- $c = [14, 14, 28, 28, 42, 42]$\n- **倍性模型拟合**: 染色体数是7的倍数。选择最优基数 $g^\\star=14$（给出完美拟合 $\\bar r(14)=0$ 的最大基数）。$\\bar r(14)=0 \\le \\delta=1.0$。推断的乘数为 $m=\\{1,1,2,2,3,3\\}$，包含3个不同的组。因此，倍性模型被接受。\n- **育性分离检验**: 基于 $m=\\{1,1,2,2,3,3\\}$ 的分组，组内平均育性 $\\mu_{\\mathrm{within}} = (0.92+0.93+0.91)/3 = 0.92$。组间平均育性 $\\mu_{\\mathrm{between}} = 0.08$。$\\mu_{\\mathrm{within}} \\ge 0.7$ 且 $\\mu_{\\mathrm{between}} \\le 0.2$。检验通过。\n- **结论**: 输出 **2**。\n\n**测试用例 2**\n- $c = [14, 15, 16, 15]$\n- **倍性模型拟合**: 对候选基数进行测试，发现 $g^\\star=5$ 时平均残差最小，$\\bar r(5) = (|14-15|+|15-15|+|16-15|+|15-15|)/4 = 0.5$。虽然 $\\bar r(5) \\le \\delta=1.0$，但推断的乘数为 $m=\\{3,3,3,3\\}$，只产生一个组。因此，倍性模型被拒绝。\n- **染色体多态性**: 染色体数差异为 $\\max(c)-\\min(c)=16-14=2$，大于1。该替代方案不适用。\n- **结论**: 输出 **0**。\n\n**测试用例 3**\n- $c = [14, 14, 14, 14, 14, 14]$\n- **倍性模型拟合**: 所有染色体数相同，因此只能推断出一个乘数组。倍性模型被拒绝。\n- **染色体多态性**: 染色体数差异为 $14-14=0 \\le 1$。该替代方案适用。育性矩阵清楚地显示了两个集团：$A=\\{1,2,3\\}$ 和 $B=\\{4,5,6\\}$。对于这个双分区：组内平均育性 $\\mu_{\\mathrm{within}} = 0.9$，组间平均育性 $\\mu_{\\mathrm{between}} = 0.1$。$\\mu_{\\mathrm{within}} \\ge 0.7$ 且 $\\mu_{\\mathrm{between}} \\le 0.2$。该替代方案被接受。\n- **结论**: 输出 **1**。\n\n**测试用例 4**\n- $c = [24, 24, 48, 48, 49]$\n- **倍性模型拟合**: 最优基数为 $g^\\star=24$。$\\bar r(24) = (|24-24|+|24-24|+|48-48|+|48-48|+|49-48|)/5 = 0.2$。$\\bar r(24) \\le \\delta=1.0$。推断的乘数为 $m=\\{1,1,2,2,2\\}$，产生两个不同的组。倍性模型被接受。\n- **育性分离检验**: 基于 $m$ 的分组为 $A=\\{1,2\\}$ 和 $B=\\{3,4,5\\}$。组内平均育性 $\\mu_{\\mathrm{within}} = (F_{12} + F_{34} + F_{35} + F_{45})/4 = (0.93+0.92+0.72+0.72)/4 = 0.8225$。组间平均育性 $\\mu_{\\mathrm{between}}$（A与B之间）为 $0.08$。$\\mu_{\\mathrm{within}} \\ge 0.7$ 且 $\\mu_{\\mathrm{between}} \\le 0.2$。检验通过。\n- **结论**: 输出 **2**。\n\n综上所述，四个测试用例的分类结果为 $[2, 0, 1, 2]$。以下是实现此逻辑的Python代码。\n\n```python\nimport numpy as np\nimport itertools\n\ndef classify_speciation(c_list, F):\n    \"\"\"\n    Classifies speciation mechanism based on chromosome counts and fertility matrix.\n    \n    Returns:\n        2: Polyploid speciation\n        1: Chromosomal polymorphism\n        0: Other (e.g., aneuploidy)\n    \"\"\"\n    c = np.array(c_list)\n    N = len(c)\n    delta = 1.0\n    theta_w = 0.7\n    theta_b = 0.2\n\n    # Step 1: Ploidy-model fit\n    min_r_bar = float('inf')\n    \n    # Candidate base counts g must be at least 2.\n    # If minimum chromosome count is less than 2, this test cannot be performed.\n    min_c = np.min(c)\n    if min_c  2:\n        g_star = -1\n    else:\n        g_candidates = range(2, min_c + 1)\n        g_minimizers = []\n        for g in g_candidates:\n            # Using np.round which rounds to nearest even for .5 cases\n            m = np.maximum(1, np.round(c / g)).astype(int)\n            r = np.abs(c - m * g)\n            r_bar = np.mean(r)\n            \n            if abs(r_bar - min_r_bar)  1e-9: # Comparing floats\n                g_minimizers.append(g)\n            elif r_bar  min_r_bar:\n                min_r_bar = r_bar\n                g_minimizers = [g]\n\n        g_star = max(g_minimizers) if g_minimizers else -1\n\n    ploidy_model_accepted = False\n    if g_star != -1:\n        m_star = np.maximum(1, np.round(c / g_star)).astype(int)\n        unique_multipliers = np.unique(m_star)\n        if min_r_bar = delta and len(unique_multipliers) > 1:\n            ploidy_model_accepted = True\n\n    # Step 2: Fertility separation test\n    fertility_separation_accepted = False\n    if ploidy_model_accepted:\n        m_star = np.maximum(1, np.round(c / g_star)).astype(int)\n        \n        within_fertilities = []\n        between_fertilities = []\n\n        for i in range(N):\n            for j in range(i + 1, N):\n                if m_star[i] == m_star[j]:\n                    within_fertilities.append(F[i, j])\n                else:\n                    between_fertilities.append(F[i, j])\n        \n        if within_fertilities and between_fertilities:\n            mu_within = np.mean(within_fertilities)\n            mu_between = np.mean(between_fertilities)\n            \n            if mu_within >= theta_w and mu_between = theta_b:\n                fertility_separation_accepted = True\n\n    # Final Classification Rule 1\n    if ploidy_model_accepted and fertility_separation_accepted:\n        return 2\n\n    # Step 3: Chromosomal polymorphism alternative\n    chromo_poly_accepted = False\n    if np.max(c) - np.min(c) = 1:\n        # Generate all non-trivial bipartitions. To avoid duplicates, fix one element (e.g., 0)\n        # in the first set and generate all non-empty, non-full subsets of the rest.\n        other_elements = list(range(1, N))\n        for k in range(len(other_elements) + 1):\n            for subset in itertools.combinations(other_elements, k):\n                set_A_indices = set([0] + list(subset))\n                \n                # Bipartition must be non-trivial\n                if len(set_A_indices) == N or len(set_A_indices) == 0:\n                    continue\n\n                set_B_indices = set(range(N)) - set_A_indices\n                \n                within_fertilities_pooled = []\n                # Pairs within A\n                if len(set_A_indices) > 1:\n                    for i, j in itertools.combinations(set_A_indices, 2):\n                        within_fertilities_pooled.append(F[i, j])\n                # Pairs within B\n                if len(set_B_indices) > 1:\n                    for i, j in itertools.combinations(set_B_indices, 2):\n                        within_fertilities_pooled.append(F[i, j])\n                \n                between_fertilities_pooled = []\n                for i in set_A_indices:\n                    for j in set_B_indices:\n                        between_fertilities_pooled.append(F[i, j])\n\n                if not within_fertilities_pooled or not between_fertilities_pooled:\n                    continue\n\n                mu_within_pooled = np.mean(within_fertilities_pooled)\n                mu_between_pooled = np.mean(between_fertilities_pooled)\n                \n                if mu_within_pooled >= theta_w and mu_between_pooled = theta_b:\n                    chromo_poly_accepted = True\n                    break\n            if chromo_poly_accepted:\n                break\n    \n    # Final Classification Rule 2  3\n    if chromo_poly_accepted:\n        return 1\n    \n    return 0\n\ndef solve():\n    # Define the test cases\n    test_cases = [\n        # Test case 1\n        {\n            \"c\": [14, 14, 28, 28, 42, 42],\n            \"F\": np.array([\n                [1.00, 0.92, 0.08, 0.08, 0.08, 0.08],\n                [0.92, 1.00, 0.08, 0.08, 0.08, 0.08],\n                [0.08, 0.08, 1.00, 0.93, 0.08, 0.08],\n                [0.08, 0.08, 0.93, 1.00, 0.08, 0.08],\n                [0.08, 0.08, 0.08, 0.08, 1.00, 0.91],\n                [0.08, 0.08, 0.08, 0.08, 0.91, 1.00]\n            ])\n        },\n        # Test case 2\n        {\n            \"c\": [14, 15, 16, 15],\n            \"F\": np.array([\n                [1.0, 0.5, 0.5, 0.5],\n                [0.5, 1.0, 0.5, 0.5],\n                [0.5, 0.5, 1.0, 0.5],\n                [0.5, 0.5, 0.5, 1.0]\n            ])\n        },\n        # Test case 3\n        {\n            \"c\": [14, 14, 14, 14, 14, 14],\n            \"F\": np.array([\n                [1.0, 0.9, 0.9, 0.1, 0.1, 0.1],\n                [0.9, 1.0, 0.9, 0.1, 0.1, 0.1],\n                [0.9, 0.9, 1.0, 0.1, 0.1, 0.1],\n                [0.1, 0.1, 0.1, 1.0, 0.9, 0.9],\n                [0.1, 0.1, 0.1, 0.9, 1.0, 0.9],\n                [0.1, 0.1, 0.1, 0.9, 0.9, 1.0]\n            ])\n        },\n        # Test case 4\n        {\n            \"c\": [24, 24, 48, 48, 49],\n            \"F\": np.array([\n                [1.00, 0.93, 0.08, 0.08, 0.08],\n                [0.93, 1.00, 0.08, 0.08, 0.08],\n                [0.08, 0.08, 1.00, 0.92, 0.72],\n                [0.08, 0.08, 0.92, 1.00, 0.72],\n                [0.08, 0.08, 0.72, 0.72, 1.00]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_speciation(case[\"c\"], case[\"F\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The function call is commented out to prevent execution in this context,\n# but the code is complete and represents the solution logic.\n# solve()\n```", "answer": "[2,0,1,2]", "id": "2744638"}]}