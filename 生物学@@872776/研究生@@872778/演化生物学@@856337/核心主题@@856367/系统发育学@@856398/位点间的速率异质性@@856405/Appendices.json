{"hands_on_practices": [{"introduction": "要真正掌握一个统计模型，最好的方法之一就是亲手实现其数据生成过程。这个练习将引导您从头开始，在给定的系统发育树上模拟序列在JC69+Γ模型下的演化。通过从伽马分布中抽取位点特异性速率，并将其与分支长度结合以确定最终的替代概率，您将对速率异质性模型的核心机制建立起具体而深入的理解[@problem_id:2747214]。", "problem": "你需要实现一个完整且可复现的算法，该算法使用 Jukes–Cantor $1969$ (JC$69$) 模型，在具有位点间伽马（Gamma）分布且均值为 1 的速率异质性（记作 JC$69$+$\\Gamma$）的条件下，模拟一个固定有根树上的 DNA 序列演化，然后验证所实现的位点速率分布。该实现必须遵循连续时间马尔可夫链的构建方法。\n\n从以下基础开始：\n- 一个在有限状态空间上的连续时间马尔可夫链，其瞬时速率矩阵为 $Q$，沿着长度为 $t$ 的分支通过转移概率矩阵 $P(t) = \\exp(Qt)$ 进行演化，其中 $\\exp$ 表示矩阵指数。\n- JC$69$ 模型具有相等的稳态碱基频率 $\\pi_i = 1/4$ (对于 $i \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$) 和一个瞬时速率矩阵 $Q$。该矩阵满足：当 $i \\neq j$ 时，$Q_{ij} = \\mu$；当 $i = j$ 时，$Q_{ii} = -3\\mu$。该矩阵经过缩放，使得平均替换率为 $1$，即 $\\sum_i \\pi_i (-Q_{ii}) = 1$，这意味着 $\\mu = 1/3$。\n- 在 JC$69$ 模型下，沿时间 $t$ 的转移概率具有封闭形式：当 $i=j$ 时，$P_{ii}(t) = 1/4 + 3/4 \\exp(-4t/3)$；当 $i \\neq j$ 时，$P_{ij}(t) = 1/4 - 1/4 \\exp(-4t/3)$。\n- 对于位点间伽马分布的速率异质性，位点特异性速率 $r$ 从一个伽马分布中抽取，其形状参数为 $\\alpha$，尺度参数为 $\\theta$，使得均值为 1，即 $\\mathbb{E}[r] = \\alpha \\theta = 1$。设置 $\\theta = 1/\\alpha$，则方差为 $\\operatorname{Var}(r) = \\alpha \\theta^2 = 1/\\alpha$。\n\n算法规范：\n- 设状态空间为 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，编码为 $\\{0,1,2,3\\}$。\n- 对于每个位点 $s \\in \\{1,\\dots,S\\}$，从 $\\text{Gamma}(\\alpha, \\theta)$ 分布中抽取一个速率 $r_s$，其中 $\\theta = 1/\\alpha$。\n- 对每个位点独立地从稳态分布 $(1/4,1/4,1/4,1/4)$ 中抽样来分配根节点的状态。\n- 对于每个分支长度为 $t_{uv}$ 的有向边 $(u \\to v)$ 和给定的位点速率 $r_s$，通过在有效时间 $r_s t_{uv}$（即 $P(r_s t_{uv})$）下计算的 JC$69$ 转移矩阵的相应行中进行抽样，将状态从父节点 $u$ 传播到子节点 $v$。\n- 对于任何长度为 $t=0$ 的分支，强制 $P(0)$ 等于单位矩阵，因此子节点必须以概率 $1$ 继承父节点的状态。\n\n树与参数：\n- 使用一个有根树，其节点集为 $\\{0,1,2,3,4\\}$，根节点为 $0$，有向边为 $(0 \\to 1)$（长度 $t_{01} = 0.1$）、$(1 \\to 2)$（长度 $t_{12} = 0.3$）、$(1 \\to 3)$（长度 $t_{13} = 0.3$）以及 $(0 \\to 4)$（长度 $t_{04} = 0.2$）。叶节点为 $\\{2,3,4\\}$。所有分支长度均以平均速率为 $1$ 时每个位点的期望替换数为单位。\n- 对所有随机抽取使用固定的伪随机数生成器种子 $20231105$，以确保结果的可复现性。\n\n实现的速率分布验证：\n- 给定 $S$ 个抽取的速率 $\\{r_s\\}_{s=1}^S$，计算样本均值 $\\bar r = \\frac{1}{S}\\sum_{s=1}^S r_s$ 和无偏样本方差 $s^2 = \\frac{1}{S-1}\\sum_{s=1}^S (r_s - \\bar r)^2$。\n- 对于给定的 $\\alpha$，使用绝对误差容限 $\\varepsilon_{\\text{mean}}$ 和 $\\varepsilon_{\\text{var}}$，将 $\\bar r$ 与理论均值 $1$ 进行比较，并将 $s^2$ 与理论方差 $1/\\alpha$ 进行比较。\n- 此外，通过检查以下两点来验证 JC$69$ 转移矩阵的构建：对于任意正速率 $r$ 和时间 $t$，$P(rt)$ 的每一行之和在一个小的容限内等于 $1$；以及 $P(0)$ 在一个小的容限内是单位矩阵。\n\n你的程序必须实现上述算法，并生成单行输出，将以下测试套件的结果汇总为一个用方括号括起来的逗号分隔列表：\n\n- 测试 $1$（速率验证，高异质性）：$\\alpha = 0.5$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.01$，$\\varepsilon_{\\text{var}} = 0.05$。输出一个布尔值，表示 $|\\bar r - 1| \\le 0.01$ 和 $|s^2 - 2.0| \\le 0.05$ 是否同时成立。\n- 测试 $2$（速率验证，低异质性）：$\\alpha = 5.0$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.005$，$\\varepsilon_{\\text{var}} = 0.01$。输出一个布尔值，表示 $|\\bar r - 1| \\le 0.005$ 和 $|s^2 - 0.2| \\le 0.01$ 是否同时成立。\n- 测试 $3$（转移矩阵随机性）：对于 $N = 25$ 个独立抽取的对 $(r,t)$，其中 $r$ 在 $[0,3]$ 上均匀分布，$t$ 在 $[0,2]$ 上均匀分布，计算 $P(rt)$ 并检查行和与 $1$ 的最大绝对偏差是否至多为 $\\varepsilon_{\\text{row}} = 10^{-12}$。输出一个布尔值，表示此条件在所有 $N$ 次抽取中是否都成立。\n- 测试 $4$（零长度分支单位性）：对于 $N = 25$ 个在 $[0,3]$ 上均匀分布的独立抽取的速率 $r$，检查 $P(0)$ 是否等于单位矩阵，其最大绝对逐元素偏差至多为 $\\varepsilon_{\\text{id}} = 10^{-12}$。输出一个布尔值，表示此条件在所有 $N$ 次抽取中是否都成立。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含按顺序排列的四个测试用例的布尔结果，格式为一个用方括号括起来的逗号分隔列表（例如，`[True, False, True, True]`）。不应产生任何其他输出。", "solution": "我们根据连续时间马尔可夫链的第一性原理以及 Jukes–Cantor $1969$ (JC$69$) 模型和伽马分布的性质来设计算法和验证方法。\n\n1. JC$69$ 速率矩阵缩放与转移概率：\n   - 在 JC$69$ 模型中，瞬时速率矩阵 $Q$ 的非对角线元素为 $Q_{ij} = \\mu$（当 $i \\neq j$），对角线元素为 $Q_{ii} = -3\\mu$。稳态分布是均匀的，$\\pi = (1/4,1/4,1/4,1/4)$。\n   - 在稳态下的平均替换率为 $\\sum_{i=1}^4 \\pi_i (-Q_{ii}) = \\sum_{i=1}^4 (1/4) \\cdot 3\\mu = 3\\mu$。为了强制每单位时间的平均替换率为 $1$，我们设置 $3\\mu = 1$，因此 $\\mu = 1/3$。\n   - 转移概率矩阵 $P(t) = \\exp(Qt)$ 在 JC$69$ 模型下有封闭形式：当 $i=j$ 时，$P_{ii}(t) = 1/4 + 3/4 \\exp(-4t/3)$；当 $i \\neq j$ 时，$P_{ij}(t) = 1/4 - 1/4 \\exp(-4t/3)$。这是由 $Q$ 的谱分解得出的，其中有一个特征值为 $0$（对应特征向量 $\\mathbf{1}$），以及在正交子空间上的三个相同的特征值 $-4/3$，从而得出上述表达式。\n\n2. 通过伽马分布实现位点间速率异质性：\n   - 令 $r$ 表示位点特异性相对速率。为模拟异质性，我们从 $\\text{Gamma}(\\alpha, \\theta)$ 分布中抽取 $r$，其中 $\\alpha$ 为形状参数，$\\theta$ 为尺度参数。\n   - 我们选择 $\\theta = 1/\\alpha$，使得 $\\mathbb{E}[r] = \\alpha \\theta = \\alpha \\cdot (1/\\alpha) = 1$，即平均速率为 1。\n   - 方差为 $\\operatorname{Var}(r) = \\alpha \\theta^2 = \\alpha \\cdot (1/\\alpha^2) = 1/\\alpha$，这是验证的关键理论目标。\n\n3. 沿树的逐位点连续时间马尔可夫链演化：\n   - 对于每个位点 $s \\in \\{1,\\dots,S\\}$：从 $\\text{Gamma}(\\alpha, 1/\\alpha)$ 中抽取 $r_s$。从 $\\pi = (1/4,1/4,1/4,1/4)$ 中抽取根节点状态。对于每个长度为 $t_{uv}$ 的分支 $(u \\to v)$，计算有效时间 $\\tau_{uv,s} = r_s t_{uv}$，并使用上述封闭形式构建 JC$69$ 转移矩阵 $P(\\tau_{uv,s})$。然后，从由父节点状态索引的 $P(\\tau_{uv,s})$ 的行所给出的分类分布中抽样，得到子节点 $v$ 的状态。\n   - 该过程与连续时间马尔可夫链的时间变换性质一致：将每个分支的时间按 $r_s$ 进行缩放，等同于将生成元按 $r_s$ 进行缩放，这正是使用位点特异性速率的效果。\n\n4. 实现的速率分布验证：\n   - 给定抽取的速率 $\\{r_s\\}$，计算样本均值 $\\bar r = \\frac{1}{S}\\sum_{s=1}^{S} r_s$ 和无偏样本方差 $s^2 = \\frac{1}{S-1}\\sum_{s=1}^{S} (r_s - \\bar r)^2$。\n   - 对于指定的 $\\alpha$，将 $\\bar r$ 与理论均值 $1$ 进行比较，将 $s^2$ 与理论方差 $1/\\alpha$ 进行比较。我们指定绝对误差容限 $\\varepsilon_{\\text{mean}}$ 和 $\\varepsilon_{\\text{var}}$，并且要求 $|\\bar r - 1| \\le \\varepsilon_{\\text{mean}}$ 和 $|s^2 - 1/\\alpha| \\le \\varepsilon_{\\text{var}}$ 同时满足才算通过。\n   - 额外的算法验证可以增强其正确性：随机性：对于任意 $r \\ge 0$ 和 $t \\ge 0$，计算出的 $P(rt)$ 矩阵的行和必须为 $1$。因为封闭形式的构造强制 $P_{ii} = 1/4 + 3/4 e^{-4rt/3}$ 且当 $i \\neq j$ 时 $P_{ij} = 1/4 - 1/4 e^{-4rt/3}$，所以在精确算术中，每行的和恰好是 $(1/4 + 3/4 e) + 3(1/4 - 1/4 e) = 1$。在浮点运算中，我们要求偏差不超过一个小的容限 $\\varepsilon_{\\text{row}}$。\n   - 零长度分支的单位性：对于任何速率 $r$，$P(r \\cdot 0) = P(0)$ 必须等于单位矩阵，即 $\\exp(Q \\cdot 0) = I$。从封闭形式来看，代入 $t=0$ 得到 $e^{-4 \\cdot 0/3} = 1$，因此 $P_{ii}(0) = 1/4 + 3/4 \\cdot 1 = 1$ 且当 $i \\neq j$ 时 $P_{ij}(0) = 1/4 - 1/4 \\cdot 1 = 0$。我们在容限 $\\varepsilon_{\\text{id}}$ 内检查这一点。\n\n5. 测试套件设计与输出：\n   - 测试 $1$：$\\alpha = 0.5$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.01$，$\\varepsilon_{\\text{var}} = 0.05$。理论方差为 $1/\\alpha = 2.0$。输出一个布尔值的通过/失败结果。\n   - 测试 $2$：$\\alpha = 5.0$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.005$，$\\varepsilon_{\\text{var}} = 0.01$。理论方差为 $1/\\alpha = 0.2$。输出一个布尔值的通过/失败结果。\n   - 测试 $3$：抽取 $N = 25$ 对 $(r,t)$，其中 $r \\sim \\text{Uniform}[0,3]$ 且 $t \\sim \\text{Uniform}[0,2]$。对每一对，计算 $P(rt)$ 并检查行和与 $1$ 的最大绝对偏差是否至多为 $\\varepsilon_{\\text{row}} = 10^{-12}$。输出一个布尔值，表示所有抽取是否都通过。\n   - 测试 $4$：抽取 $N = 25$ 个速率 $r \\sim \\text{Uniform}[0,3]$，并验证 $P(0)$ 在 $\\varepsilon_{\\text{id}} = 10^{-12}$ 的容限内等于单位矩阵。输出一个布尔值，表示所有抽取是否都通过。\n\n实现说明：\n- 使用固定的伪随机种子 $20231105$ 以使结果具有确定性。\n- 在序列模拟程序中使用给定的带有分支长度的有根树；尽管分布验证不需要模拟序列，但必须按照描述实现序列模拟函数以反映该算法。\n- 最终程序必须打印单行结果，包含四个用方括号括起来并用逗号分隔的布尔值，不得有任何其他文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Fixed RNG for reproducibility as mandated by the problem statement.\nRNG = np.random.default_rng(20231105)\n\n# State mapping: 0,1,2,3 correspond to A,C,G,T (any consistent mapping suffices for JC69).\nNUM_STATES = 4\n\ndef draw_gamma_rates(n_sites: int, alpha: float, rng: np.random.Generator) - np.ndarray:\n    \"\"\"\n    Draw n_sites rates from Gamma(shape=alpha, scale=1/alpha) so that E[r]=1 and Var[r]=1/alpha.\n    \"\"\"\n    scale = 1.0 / alpha\n    return rng.gamma(shape=alpha, scale=scale, size=n_sites)\n\ndef jc69_transition_matrix(effective_time: float) - np.ndarray:\n    \"\"\"\n    Construct the JC69 transition matrix P(t) at time 'effective_time' = r * t.\n    JC69 scaling uses mu=1/3 so that average rate is 1, giving exponent -4 t / 3.\n    \"\"\"\n    e = np.exp(-4.0 * effective_time / 3.0)\n    P = np.full((NUM_STATES, NUM_STATES), 0.25 - 0.25 * e, dtype=float)\n    # Set diagonal entries\n    diag_val = 0.25 + 0.75 * e\n    for i in range(NUM_STATES):\n        P[i, i] = diag_val\n    return P\n\ndef simulate_sequences_on_tree(n_sites: int,\n                               alpha: float,\n                               edges: list[tuple[int, int, float]],\n                               root: int,\n                               rng: np.random.Generator) - dict[int, np.ndarray]:\n    \"\"\"\n    Simulate sequences under JC69+Gamma on a rooted directed tree.\n    edges: list of (parent, child, branch_length) with branch lengths in expected substitutions/site.\n    Returns a dictionary mapping node - sequence array of length n_sites with states in {0,1,2,3}.\n    \"\"\"\n    # Prepare adjacency and topological order from root.\n    children = {}\n    parents = {}\n    nodes = set([root])\n    for u, v, t in edges:\n        children.setdefault(u, []).append((v, t))\n        parents[v] = u\n        nodes.add(u); nodes.add(v)\n    # Derive a topological order (BFS from root suffices as edges are directed away from root).\n    topo_order = []\n    queue = [root]\n    visited = set()\n    while queue:\n        u = queue.pop(0)\n        if u in visited:\n            continue\n        visited.add(u)\n        topo_order.append(u)\n        for (v, _) in children.get(u, []):\n            queue.append(v)\n\n    # Draw site-specific rates.\n    rates = draw_gamma_rates(n_sites, alpha, rng)\n\n    # Initialize sequences per node.\n    seqs = {node: np.empty(n_sites, dtype=np.int8) for node in nodes}\n\n    # Root states sampled from stationary distribution (uniform over 4 states).\n    seqs[root] = rng.integers(low=0, high=NUM_STATES, size=n_sites, endpoint=False, dtype=np.int8)\n\n    # Propagate down the tree per site.\n    for u in topo_order:\n        for (v, t) in children.get(u, []):\n            parent_states = seqs[u]\n            child_states = np.empty(n_sites, dtype=np.int8)\n            if t == 0.0:\n                # Identity transition: child copies parent.\n                child_states[:] = parent_states\n            else:\n                # For each site, compute P(r*t) and sample child state conditional on parent state.\n                # To keep memory low, process in chunks.\n                chunk = 4096\n                for start in range(0, n_sites, chunk):\n                    end = min(start + chunk, n_sites)\n                    parent_chunk = parent_states[start:end]\n                    rates_chunk = rates[start:end]\n                    # For each site in chunk, compute P and sample.\n                    for idx in range(end - start):\n                        tau = rates_chunk[idx] * t\n                        P = jc69_transition_matrix(tau)\n                        p_row = P[parent_chunk[idx], :]\n                        # Sample according to probabilities in p_row.\n                        # Use choice with p; ensure numerical stability by normalizing.\n                        p_row = p_row / p_row.sum()\n                        child_states[start + idx] = rng.choice(NUM_STATES, p=p_row)\n            seqs[v] = child_states\n    return seqs\n\ndef sample_mean_and_unbiased_variance(x: np.ndarray) - tuple[float, float]:\n    \"\"\"\n    Return sample mean and unbiased sample variance (denominator n-1).\n    \"\"\"\n    mean = float(np.mean(x))\n    # Unbiased sample variance\n    var = float(np.var(x, ddof=1))\n    return mean, var\n\ndef test_rate_validation(alpha: float, n_sites: int, tol_mean: float, tol_var: float, rng: np.random.Generator) - bool:\n    \"\"\"\n    Draw rates and validate that sample mean and sample variance match 1 and 1/alpha within tolerances.\n    \"\"\"\n    rates = draw_gamma_rates(n_sites, alpha, rng)\n    mean, var = sample_mean_and_unbiased_variance(rates)\n    target_mean = 1.0\n    target_var = 1.0 / alpha\n    return (abs(mean - target_mean) = tol_mean) and (abs(var - target_var) = tol_var)\n\ndef test_stochasticity_row_sums(n_trials: int, tol_row: float, rng: np.random.Generator) - bool:\n    \"\"\"\n    Randomly draw rates and times, compute P(r*t), and check row sums within tolerance.\n    \"\"\"\n    max_dev = 0.0\n    for _ in range(n_trials):\n        r = rng.uniform(0.0, 3.0)\n        t = rng.uniform(0.0, 2.0)\n        P = jc69_transition_matrix(r * t)\n        row_sums = P.sum(axis=1)\n        dev = float(np.max(np.abs(row_sums - 1.0)))\n        if dev  max_dev:\n            max_dev = dev\n        if dev  tol_row:\n            return False\n    return True\n\ndef test_identity_zero_branch(n_trials: int, tol_id: float, rng: np.random.Generator) - bool:\n    \"\"\"\n    For random rates, check that P(0) equals identity within tolerance.\n    \"\"\"\n    I = np.eye(NUM_STATES)\n    for _ in range(n_trials):\n        _ = rng.uniform(0.0, 3.0)  # rate r (unused because t=0 forces tau=0)\n        P0 = jc69_transition_matrix(0.0)\n        if np.max(np.abs(P0 - I))  tol_id:\n            return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: alpha=0.5, n_sites=200000, tol_mean=0.01, tol_var=0.05\n    res1 = test_rate_validation(alpha=0.5, n_sites=200000, tol_mean=0.01, tol_var=0.05, rng=RNG)\n    results.append(res1)\n\n    # Test 2: alpha=5.0, n_sites=200000, tol_mean=0.005, tol_var=0.01\n    res2 = test_rate_validation(alpha=5.0, n_sites=200000, tol_mean=0.005, tol_var=0.01, rng=RNG)\n    results.append(res2)\n\n    # Test 3: stochasticity of transition matrices, N=25, tol_row=1e-12\n    res3 = test_stochasticity_row_sums(n_trials=25, tol_row=1e-12, rng=RNG)\n    results.append(res3)\n\n    # Test 4: identity at zero branch length, N=25, tol_id=1e-12\n    res4 = test_identity_zero_branch(n_trials=25, tol_id=1e-12, rng=RNG)\n    results.append(res4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Implement the tree structure and simulation functions as required by the problem statement.\n# Although not directly used in the tests above (which focus on rate validation and matrix checks),\n# the following demonstrates the sequence simulation algorithm on the specified rooted tree.\ndef _demo_sequence_simulation():\n    # Rooted tree as specified: nodes {0,1,2,3,4}, root=0, edges with lengths.\n    root = 0\n    edges = [\n        (0, 1, 0.1),\n        (1, 2, 0.3),\n        (1, 3, 0.3),\n        (0, 4, 0.2),\n    ]\n    # Simulate a small alignment to verify procedure (not printed).\n    _ = simulate_sequences_on_tree(n_sites=10, alpha=0.5, edges=edges, root=root, rng=RNG)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2747214"}, {"introduction": "在理解了模型如何生成数据之后，下一步是学习如何计算观测数据在该模型下出现的概率，这是系统发育推断的核心。本练习聚焦于似然性计算的关键环节：Felsenstein的“剪枝算法”(pruning algorithm)。通过为一个特定速率类别下的单个位点手动计算部分似然性(partial likelihood)，您将具体地掌握这个基础递归算法的运作方式，体会信息是如何从树的末端向根部传递的[@problem_id:2747174]。", "problem": "考虑一个位点在一个二叉系统发育树上，遵循 Jukes–Cantor 1969 (JC69) 核苷酸替换模型进行演化。设一个内部节点 $v$ 有两个子节点 $c_{1}$ 和 $c_{2}$，它们通过长度相等的边相连，边长为 $t = 0.2$（单位为每个位点的期望替换数）。假设位点间的速率异质性通过具有相对速率的有限混合类别进行建模，且该位点属于相对速率为 $r = 1.5$ 的类别。对于 JC69 模型，沿着长度为 $t$ 的边的转移概率由下式给出\n$$\nP_{xy}(t) \\;=\\; \\frac{1}{4} \\;+\\; \\left(\\delta_{xy} - \\frac{1}{4}\\right)\\exp\\!\\left(-\\frac{4t}{3}\\right),\n$$\n其中 $\\delta_{xy}$ 是克罗内克 δ。对于相对速率 $r$，有效分支长度按 $r$ 进行缩放，即用 $rt$ 代替 $t$。\n\n假设在该位点和该类别下，子节点处的部分似然向量为\n$$\n\\boldsymbol{L}^{(1)} \\;=\\; \\big(L^{(1)}_{A},L^{(1)}_{C},L^{(1)}_{G},L^{(1)}_{T}\\big) \\;=\\; (0.8,\\,0.1,\\,0.05,\\,0.05),\n$$\n$$\n\\boldsymbol{L}^{(2)} \\;=\\; \\big(L^{(2)}_{A},L^{(2)}_{C},L^{(2)}_{G},L^{(2)}_{T}\\big) \\;=\\; (0.2,\\,0.3,\\,0.4,\\,0.1),\n$$\n按核苷酸顺序 $(A,C,G,T)$。\n\n使用核苷酸上连续时间齐次马尔可夫链的剪枝递归算法，\n$$\nL_{v}(x) \\;=\\; \\prod_{i=1}^{2}\\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{xy}(rt)\\,L^{(i)}_{y}\\right),\n$$\n数值计算父节点的部分似然 $L_{v}(A)$。将最终答案四舍五入至六位有效数字。以不带单位的纯数字形式表示您的答案。", "solution": "题目陈述经评估有效。其科学基础在于分子系统发育学原理，问题定义明确、客观且内部一致。所有计算唯一、有意义解所需的数据和公式均已提供。因此，我们可以进行计算。\n\n目标是根据内部节点 $v$ 的两个子节点 $c_{1}$ 和 $c_{2}$ 的部分似然，计算节点 $v$ 的部分似然 $L_{v}(A)$。节点 $v$ 的状态指定为核苷酸 $A$。\n\n所提供的剪枝递归公式为：\n$$\nL_{v}(x) \\;=\\; \\prod_{i=1}^{2}\\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{xy}(rt)\\,L^{(i)}_{y}\\right)\n$$\n对于特定状态 $x=A$，该公式变为：\n$$\nL_{v}(A) \\;=\\; \\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(1)}_{y}\\right) \\times \\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(2)}_{y}\\right)\n$$\n让我们将乘积中的两项表示为 $S_{1}$ 和 $S_{2}$：\n$$\nS_{1} \\;=\\; \\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(1)}_{y}\n$$\n$$\nS_{2} \\;=\\; \\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(2)}_{y}\n$$\n因此，$L_{v}(A) = S_{1} \\times S_{2}$。\n\n首先，我们计算有效分支长度。给定分支长度为 $t = 0.2$，位点特异性相对速率为 $r = 1.5$。因此，有效分支长度为：\n$$\nt_{\\text{eff}} \\;=\\; rt \\;=\\; 1.5 \\times 0.2 \\;=\\; 0.3\n$$\n接下来，我们确定在此有效分支长度下，Jukes-Cantor (JC69) 模型的转移概率。通用公式为：\n$$\nP_{xy}(t_{\\text{eff}}) \\;=\\; \\frac{1}{4} \\;+\\; \\left(\\delta_{xy} - \\frac{1}{4}\\right)\\exp\\!\\left(-\\frac{4t_{\\text{eff}}}{3}\\right)\n$$\n其中 $\\delta_{xy}$ 是克罗内克 δ。我们关心的是从状态 $A$ 到状态 $y \\in \\{A,C,G,T\\}$ 的转移。\n\n指数函数的参数是：\n$$\n-\\frac{4t_{\\text{eff}}}{3} \\;=\\; -\\frac{4 \\times 0.3}{3} \\;=\\; -0.4\n$$\n对于从 $A$ 到 $A$ 的转移（匹配），$\\delta_{AA} = 1$：\n$$\nP_{AA}(0.3) \\;=\\; \\frac{1}{4} \\;+\\; \\left(1 - \\frac{1}{4}\\right)\\exp(-0.4) \\;=\\; 0.25 \\;+\\; 0.75\\exp(-0.4)\n$$\n对于从 $A$ 到任何其他核苷酸 $y \\in \\{C,G,T\\}$ 的转移（错配），$\\delta_{Ay} = 0$：\n$$\nP_{Ay}(0.3) \\;=\\; \\frac{1}{4} \\;+\\; \\left(0 - \\frac{1}{4}\\right)\\exp(-0.4) \\;=\\; 0.25 \\;-\\; 0.25\\exp(-0.4)\n$$\n让我们将 $P_{A \\to A} = P_{AA}(0.3)$ 和当 $y \\ne A$ 时 $P_{A \\to \\text{mismatch}} = P_{Ay}(0.3)$。\n\n现在我们计算 $S_{1}$ 和 $S_{2}$。子节点 $c_{1}$ 的部分似然向量为 $\\boldsymbol{L}^{(1)} = (0.8,\\,0.1,\\,0.05,\\,0.05)$。\n$$\nS_{1} \\;=\\; P_{AA}(0.3)L^{(1)}_{A} \\;+\\; P_{AC}(0.3)L^{(1)}_{C} \\;+\\; P_{AG}(0.3)L^{(1)}_{G} \\;+\\; P_{AT}(0.3)L^{(1)}_{T}\n$$\n$$\nS_{1} \\;=\\; P_{A \\to A} \\cdot L^{(1)}_{A} \\;+\\; P_{A \\to \\text{mismatch}} \\cdot (L^{(1)}_{C} + L^{(1)}_{G} + L^{(1)}_{T})\n$$\n代入数值：\n$L^{(1)}_{A} = 0.8$，且 $L^{(1)}_{C} + L^{(1)}_{G} + L^{(1)}_{T} = 0.1 + 0.05 + 0.05 = 0.2$。\n$$\nS_{1} \\;=\\; \\left(0.25 + 0.75\\exp(-0.4)\\right) \\times 0.8 \\;+\\; \\left(0.25 - 0.25\\exp(-0.4)\\right) \\times 0.2\n$$\n$$\nS_{1} \\;=\\; 0.2 + 0.6\\exp(-0.4) \\;+\\; 0.05 - 0.05\\exp(-0.4)\n$$\n$$\nS_{1} \\;=\\; 0.25 \\;+\\; 0.55\\exp(-0.4)\n$$\n子节点 $c_{2}$ 的部分似然向量为 $\\boldsymbol{L}^{(2)} = (0.2,\\,0.3,\\,0.4,\\,0.1)$。\n$$\nS_{2} \\;=\\; P_{A \\to A} \\cdot L^{(2)}_{A} \\;+\\; P_{A \\to \\text{mismatch}} \\cdot (L^{(2)}_{C} + L^{(2)}_{G} + L^{(2)}_{T})\n$$\n代入数值：\n$L^{(2)}_{A} = 0.2$，且 $L^{(2)}_{C} + L^{(2)}_{G} + L^{(2)}_{T} = 0.3 + 0.4 + 0.1 = 0.8$。\n$$\nS_{2} \\;=\\; \\left(0.25 + 0.75\\exp(-0.4)\\right) \\times 0.2 \\;+\\; \\left(0.25 - 0.25\\exp(-0.4)\\right) \\times 0.8\n$$\n$$\nS_{2} \\;=\\; 0.05 + 0.15\\exp(-0.4) \\;+\\; 0.2 - 0.2\\exp(-0.4)\n$$\n$$\nS_{2} \\;=\\; 0.25 \\;-\\; 0.05\\exp(-0.4)\n$$\n现在，我们计算最终的部分似然 $L_{v}(A) = S_{1} \\times S_{2}$：\n$$\nL_{v}(A) \\;=\\; \\left(0.25 + 0.55\\exp(-0.4)\\right) \\times \\left(0.25 - 0.05\\exp(-0.4)\\right)\n$$\n展开这个乘积：\n$$\nL_{v}(A) \\;=\\; 0.25^{2} \\;-\\; 0.25 \\times 0.05\\exp(-0.4) \\;+\\; 0.55\\exp(-0.4) \\times 0.25 \\;-\\; 0.55\\exp(-0.4) \\times 0.05\\exp(-0.4)\n$$\n$$\nL_{v}(A) \\;=\\; 0.0625 \\;+\\; \\left(0.1375 - 0.0125\\right)\\exp(-0.4) \\;-\\; 0.0275\\exp(-0.8)\n$$\n$$\nL_{v}(A) \\;=\\; 0.0625 \\;+\\; 0.125\\exp(-0.4) \\;-\\; 0.0275\\exp(-0.8)\n$$\n我们现在代入指数项的数值。\n$$\n\\exp(-0.4) \\approx 0.6703200458\n$$\n$$\n\\exp(-0.8) \\approx 0.4493289641\n$$\n将这些值代入 $L_{v}(A)$ 的表达式中：\n$$\nL_{v}(A) \\approx 0.0625 \\;+\\; 0.125 \\times 0.6703200458 \\;-\\; 0.0275 \\times 0.4493289641\n$$\n$$\nL_{v}(A) \\approx 0.0625 \\;+\\; 0.0837900057 \\;-\\; 0.0123565465\n$$\n$$\nL_{v}(A) \\approx 0.1462900057 \\;-\\; 0.0123565465\n$$\n$$\nL_{v}(A) \\approx 0.1339334592\n$$\n题目要求答案四舍五入至六位有效数字。前六位有效数字是 $1, 3, 3, 9, 3, 3$。第七位数字是 $4$，小于 $5$，因此我们向下舍入。\n$$\nL_{v}(A) \\approx 0.133933\n$$", "answer": "$$\\boxed{0.133933}$$", "id": "2747174"}, {"introduction": "在真实的系统发育分析中，我们不仅需要应用模型，更要在众多候选模型中做出选择，以最好地解释数据。这个练习将我们带入统计模型选择的领域，利用赤池信息准则(Akaike Information Criterion, AIC)来评估和比较模型。您将权衡两个关于跨数据分区（例如密码子的不同位置）的速率异质性的竞争性假设，这反映了现代系统发育学研究中平衡模型拟合度与复杂性的常见挑战[@problem_id:2747265]。", "problem": "考虑对一个比对序列进行密码子分区的系统发育分析，该序列被划分为 $3$ 个位点分区（例如，密码子位置），每个分区都在时间可逆替换过程下建模，并使用离散伽马分布（记为 $+G$）来模拟位点间的速率变异。我们比较了两种位点间速率异质性的模型：\n\n- 模型 $\\mathcal{M}_{\\text{linked}}$：单个伽马形状参数 $\\alpha$ 在 $3$ 个分区之间共享（关联）。\n- 模型 $\\mathcal{M}_{\\text{unlinked}}$：每个分区都有自己的伽马形状参数 $\\alpha_{p}$，$p \\in \\{1,2,3\\}$（在分区之间不关联）。\n\n两个模型都通过最大似然法对同一数据进行拟合。最大化对数似然值和总参数数量（包括所有共享和分区特有的参数，如枝长和替换参数）如下：\n- $\\ell_{\\text{linked}} = -9000$，$k_{\\text{linked}} = 70$，\n- $\\ell_{\\text{unlinked}} = -8950$，$k_{\\text{unlinked}} = 72$。\n\n使用基于期望 Kullback–Leibler 散度的赤池信息准则，计算准则值的差值\n$$\\Delta \\mathrm{AIC} \\equiv \\mathrm{AIC}(\\mathcal{M}_{\\text{linked}}) - \\mathrm{AIC}(\\mathcal{M}_{\\text{unlinked}})。$$\n请将您的答案报告为单个实数，无单位。由于结果是精确的，因此无需进行舍入。", "solution": "所提出的问题在科学上是合理的、内容完整的且提法明确。它要求计算两个相互竞争的系统发育模型 $\\mathcal{M}_{\\text{linked}}$ 和 $\\mathcal{M}_{\\text{unlinked}}$ 之间的赤池信息准则 (AIC) 值的差。这是统计模型选择中的一个标准程序。\n\n一个模型 $\\mathcal{M}$ 的赤池信息准则定义为：\n$$ \\mathrm{AIC} = 2k - 2\\ell $$\n其中 $k$ 是模型中独立调整的参数数量，$\\ell$ 是该模型对数似然函数的最大化值。该准则提供了一个估计，用于衡量当使用给定模型来表示生成数据的过程时所损失的信息；较低的 AIC 值表示模型在拟合优度和复杂性之间取得了更好的预期平衡。\n\n对于这两个模型，我们给出了以下数值：\n\n对于关联模型 $\\mathcal{M}_{\\text{linked}}$：\n参数数量为 $k_{\\text{linked}} = 70$。\n最大化对数似然值为 $\\ell_{\\text{linked}} = -9000$。\n\n对于非关联模型 $\\mathcal{M}_{\\text{unlinked}}$：\n参数数量为 $k_{\\text{unlinked}} = 72$。\n最大化对数似然值为 $\\ell_{\\text{unlinked}} = -8950$。\n\n首先，我们计算关联模型的 AIC 值，$\\mathrm{AIC}(\\mathcal{M}_{\\text{linked}})$：\n$$ \\mathrm{AIC}(\\mathcal{M}_{\\text{linked}}) = 2k_{\\text{linked}} - 2\\ell_{\\text{linked}} = 2(70) - 2(-9000) = 140 + 18000 = 18140 $$\n\n接下来，我们计算非关联模型的 AIC 值，$\\mathrm{AIC}(\\mathcal{M}_{\\text{unlinked}})$：\n$$ \\mathrm{AIC}(\\mathcal{M}_{\\text{unlinked}}) = 2k_{\\text{unlinked}} - 2\\ell_{\\text{unlinked}} = 2(72) - 2(-8950) = 144 + 17900 = 18044 $$\n\n目标是计算差值 $\\Delta \\mathrm{AIC} \\equiv \\mathrm{AIC}(\\mathcal{M}_{\\text{linked}}) - \\mathrm{AIC}(\\mathcal{M}_{\\text{unlinked}})$。\n使用计算出的 AIC 值：\n$$ \\Delta \\mathrm{AIC} = 18140 - 18044 = 96 $$\n\n或者，我们可以直接通过参数和对数似然值的差值来计算这个差：\n$$ \\Delta \\mathrm{AIC} = \\mathrm{AIC}(\\mathcal{M}_{\\text{linked}}) - \\mathrm{AIC}(\\mathcal{M}_{\\text{unlinked}}) = (2k_{\\text{linked}} - 2\\ell_{\\text{linked}}) - (2k_{\\text{unlinked}} - 2\\ell_{\\text{unlinked}}) $$\n$$ \\Delta \\mathrm{AIC} = 2(k_{\\text{linked}} - k_{\\text{unlinked}}) - 2(\\ell_{\\text{linked}} - \\ell_{\\text{unlinked}}) $$\n我们已知 $\\Delta k = k_{\\text{linked}} - k_{\\text{unlinked}} = 70 - 72 = -2$ 且 $\\Delta \\ell = \\ell_{\\text{linked}} - \\ell_{\\text{unlinked}} = -9000 - (-8950) = -50$。\n将这些差值代入 $\\Delta \\mathrm{AIC}$ 的表达式中：\n$$ \\Delta \\mathrm{AIC} = 2(-2) - 2(-50) = -4 - (-100) = -4 + 100 = 96 $$\n两种方法得到相同的结果。$\\Delta \\mathrm{AIC}$ 的正值表示 $\\mathrm{AIC}(\\mathcal{M}_{\\text{linked}})$ 大于 $\\mathrm{AIC}(\\mathcal{M}_{\\text{unlinked}})$，这意味着即使在对其增加的两个参数进行惩罚后，非关联模型仍然为数据提供了显著更好的拟合。", "answer": "$$\\boxed{96}$$", "id": "2747265"}]}