{"hands_on_practices": [{"introduction": "非同义替换率($D_N$)与同义替换率($D_S$)之比是检测蛋白质编码基因选择压力的关键指标。通常认为，$D_N/D_S  1$ 表示纯化选择，$D_N/D_S  1$ 表示正选择，而 $D_N/D_S = 1$ 则符合中性演化的预期。然而，这一基准预期依赖于对突变过程的简化假设。本练习 [@problem_id:1527820] 将通过一个假设场景，挑战您去探索一个非选择性过程——突变偏向性——如何能够导致 $D_N/D_S$ 比率小于1，从而突显出在推断选择时，构建一个严谨的零假设模型是何等重要。", "problem": "在分子进化中，非同义替换率与同义替换率之比（$D_N/D_S$）是衡量作用于蛋白质编码基因上选择压力的一个关键指标。在中性进化下，该比率预期为1，而小于1的比率通常意味着净化选择。然而，如果潜在的突变过程存在偏向性，这一预期可能不成立。\n\n考虑一个细菌中的假设基因，已知其进化是完全中性的，这意味着所有发生的突变，无论其对氨基酸序列的影响如何，都以相同的概率被固定下来。该细菌的脱氧核糖核酸（DNA）中的突变过程表现出强烈的偏向性。任何特定转换（两个嘌呤A↔G之间，或两个嘧啶C↔T之间的突变）的概率是任何特定颠换（一个嘌呤和一个嘧啶之间的突变）概率的 $\\kappa=5$ 倍。\n\n为简化起见，我们只分析发生在密码子第三位的突变。该基因由大量的两种类型的密码子按以下比例组成：\n- 75%是“1型”密码子，以编码谷氨酸的`GAA`为例。在第三位上，`GAA`可以突变为：\n    - `GAG`（也编码谷氨酸，同义变化）\n    - `GAC`（编码天冬氨酸，非同义变化）\n    - `GAT`（也编码天冬氨酸，非同义变化）\n- 25%是“2型”密码子，以编码异亮氨酸的`ATA`为例。在第三位上，`ATA`可以突变为：\n    - `ATG`（编码甲硫氨酸，非同义变化）\n    - `ATC`（也编码异亮氨酸，同义变化）\n    - `ATT`（也编码异亮氨酸，同义变化）\n\n在中性进化的假设下，分化率之比 $D_N/D_S$ 等于整个基因中发生的非同义突变总期望数与同义突变总期望数之比。计算该基因的预期 $D_N/D_S$ 比率。将最终答案四舍五入到三位有效数字。", "solution": "在中性进化下，所有突变的固定概率相同，因此分化率之比 $D_N/D_S$ 等于整个基因中发生的非同义突变与同义突变期望数之比。因为我们只分析密码子的第三位，且两种密码子类型的该位置均为A，所以每个位点有三种可能的单核苷酸变化：一个转换 $A \\to G$ 和两个颠换 $A \\to C$ 及 $A \\to T$。设任何特定颠换的速率（或单位时间内的概率）为 $\\mu$，则特定转换的速率为 $\\mu_{ts}=\\kappa \\mu$，其中 $\\kappa=5$。\n\n对于1型密码子（比例为 $f_{1}=\\frac{3}{4}$），第三位的变化是：$A \\to G$ 为同义（转换），$A \\to C$ 为非同义（颠换），$A \\to T$ 为非同义（颠换）。因此，每个1型位点预期的同义和非同义突变率分别为\n$$\nS_{1}=\\kappa \\mu,\\qquad N_{1}=2\\mu.\n$$\n对于2型密码子（比例为 $f_{2}=\\frac{1}{4}$），第三位的变化是：$A \\to G$ 为非同义（转换），$A \\to C$ 为同义（颠换），$A \\to T$ 为同义（颠换）。因此，\n$$\nS_{2}=2\\mu,\\qquad N_{2}=\\kappa \\mu.\n$$\n按密码子类型频率加权，整个基因的总预期非同义和同义突变率分别为\n$$\nN_{\\text{tot}}=f_{1}N_{1}+f_{2}N_{2}=f_{1}(2\\mu)+f_{2}(\\kappa \\mu)=\\mu\\left(2f_{1}+\\kappa f_{2}\\right),\n$$\n$$\nS_{\\text{tot}}=f_{1}S_{1}+f_{2}S_{2}=f_{1}(\\kappa \\mu)+f_{2}(2\\mu)=\\mu\\left(\\kappa f_{1}+2f_{2}\\right).\n$$\n因此\n$$\n\\frac{D_{N}}{D_{S}}=\\frac{N_{\\text{tot}}}{S_{\\text{tot}}}=\\frac{2f_{1}+\\kappa f_{2}}{\\kappa f_{1}+2f_{2}}.\n$$\n代入 $f_{1}=\\frac{3}{4}$，$f_{2}=\\frac{1}{4}$ 和 $\\kappa=5$，\n$$\n\\frac{D_{N}}{D_{S}}=\\frac{2\\cdot \\frac{3}{4}+5\\cdot \\frac{1}{4}}{5\\cdot \\frac{3}{4}+2\\cdot \\frac{1}{4}}=\\frac{\\frac{3}{2}+\\frac{5}{4}}{\\frac{15}{4}+\\frac{2}{4}}=\\frac{\\frac{11}{4}}{\\frac{17}{4}}=\\frac{11}{17}\\approx 0.6470588.\n$$\n四舍五入到三位有效数字，结果为 $0.647$。", "answer": "$$\\boxed{0.647}$$", "id": "1527820"}, {"introduction": "在认识到简单的 $D_N/D_S$ 比率可能具有误导性之后，我们可以采用更稳健的方法来运用中性理论。麦克唐纳-克雷特曼（McDonald-Kreitman, MK）检验通过比较物种间的分化和物种内的多态性，来识别正选择的印记，而不是仅仅依赖一个比率。本练习 [@problem_id:2859585] 提供了一个应用这一强大检验的实践机会，它将指导您推导适应性替换比例（$\\alpha$）的估计量，并分析一个模拟真实情况的数据集，从而将中性理论作为检验适应性假说的有力工具。", "problem": "一项比较群体基因组学研究收集了一个焦点物种和一个近缘外群的 $8$ 个基因的编码序列数据。对于每个基因 $i$，数据包括焦点物种内非同义位点（$P_{N,i}$）和同义位点（$P_{S,i}$）上分离的多态性位点计数，以及焦点物种与外群之间非同义位点（$D_{N,i}$）和同义位点（$D_{S,i}$）上的固定差异计数。分子进化的中性理论断言，长期替换率等于中性突变率，并且在中性条件下，在对突变机会进行适当标准化后，非同义与同义变化的比率在种内多态性和种间分化时间尺度上预期是相同的。在 McDonald–Kreitman (MK) 框架中，将适应性非同义替换的比例 $\\alpha$ 定义为无法由中性预期解释的非同义固定差异的比例，该中性预期是根据种内非同义与同义多态性的比率推断的。\n\n使用这些原理和以上定义，完成以下任务：\n- 从第一性原理出发，推导一个依赖于合并计数 $P_{N}=\\sum_{i=1}^{8} P_{N,i}$、$P_{S}=\\sum_{i=1}^{8} P_{S,i}$、$D_{N}=\\sum_{i=1}^{8} D_{N,i}$ 和 $D_{S}=\\sum_{i=1}^{8} D_{S,i}$ 的 $\\alpha$ 估计量。\n- 使用提供的每个基因的数据，计算 $\\alpha$ 的点估计值。\n- 概述一种通过重抽样基因来评估该估计量不确定性的非参数 bootstrap 策略，并推导出以 bootstrap 重复估计值表示的 bootstrap 标准误的封闭形式表达式。\n\n每个基因的 MK 计数如下：\n- 基因 $1$：$P_{N,1}=5$, $P_{S,1}=22$, $D_{N,1}=12$, $D_{S,1}=20$。\n- 基因 $2$：$P_{N,2}=3$, $P_{S,2}=24$, $D_{N,2}=15$, $D_{S,2}=22$。\n- 基因 $3$：$P_{N,3}=7$, $P_{S,3}=21$, $D_{N,3}=18$, $D_{S,3}=29$。\n- 基因 $4$：$P_{N,4}=4$, $P_{S,4}=26$, $D_{N,4}=20$, $D_{S,4}=34$。\n- 基因 $5$：$P_{N,5}=6$, $P_{S,5}=28$, $D_{N,5}=25$, $D_{S,5}=36$。\n- 基因 $6$：$P_{N,6}=2$, $P_{S,6}=23$, $D_{N,6}=14$, $D_{S,6}=29$。\n- 基因 $7$：$P_{N,7}=8$, $P_{S,7}=20$, $D_{N,7}=23$, $D_{S,7}=30$。\n- 基因 $8$：$P_{N,8}=3$, $P_{S,8}=26$, $D_{N,8}=18$, $D_{S,8}=20$。\n\n以小数形式报告 $\\alpha$ 的数值点估计，并将答案四舍五入到四位有效数字。不需要单位。", "solution": "该问题要求在 McDonald–Kreitman (MK) 检验的框架内，推导并应用适应性非同义替换比例（记为 $\\alpha$）的估计量。首先必须确定问题陈述的有效性。\n\n### 问题验证\n\n**第一步：提取的已知条件**\n- 从一个焦点物种和一个外群中收集了 $8$ 个基因的数据。\n- 对于每个基因 $i$，数据为：\n    - $P_{N,i}$：非同义多态性位点计数。\n    - $P_{S,i}$：同义多态性位点计数。\n    - $D_{N,i}$：非同义固定差异计数。\n    - $D_{S,i}$：同义固定差异计数。\n- 合并计数定义为：$P_{N}=\\sum_{i=1}^{8} P_{N,i}$、$P_{S}=\\sum_{i=1}^{8} P_{S,i}$、$D_{N}=\\sum_{i=1}^{8} D_{N,i}$ 和 $D_{S}=\\sum_{i=1}^{8} D_{S,i}$。\n- 中性理论断言：“在中性条件下，非同义与同义变化的比率在种内多态性和种间分化时间尺度上预期是相同的”。\n- $\\alpha$ 的定义：“无法由中性预期解释的非同义固定差异的比例，该中性预期是根据种内非同义与同义多态性的比率推断的”。\n- 提供的每个基因的数据：\n    - 基因 $1$：$P_{N,1}=5$, $P_{S,1}=22$, $D_{N,1}=12$, $D_{S,1}=20$。\n    - 基因 $2$：$P_{N,2}=3$, $P_{S,2}=24$, $D_{N,2}=15$, $D_{S,2}=22$。\n    - 基因 $3$：$P_{N,3}=7$, $P_{S,3}=21$, $D_{N,3}=18$, $D_{S,3}=29$。\n    - 基因 $4$：$P_{N,4}=4$, $P_{S,4}=26$, $D_{N,4}=20$, $D_{S,4}=34$。\n    - 基因 $5$：$P_{N,5}=6$, $P_{S,5}=28$, $D_{N,5}=25$, $D_{S,5}=36$。\n    - 基因 $6$：$P_{N,6}=2$, $P_{S,6}=23$, $D_{N,6}=14$, $D_{S,6}=29$。\n    - 基因 $7$：$P_{N,7}=8$, $P_{S,7}=20$, $D_{N,7}=23$, $D_{S,7}=30$。\n    - 基因 $8$：$P_{N,8}=3$, $P_{S,8}=26$, $D_{N,8}=18$, $D_{S,8}=20$。\n\n**第二步：使用提取的已知条件进行验证**\n- 该问题具有科学依据，基于分子进化的中性理论和 McDonald-Kreitman 检验，这些都是群体遗传学的基石概念。\n- 问题提法明确。它提供了清晰的定义、完整的数据集和一系列可以找到唯一解的具体任务（推导、计算和程序概述）。\n- 问题陈述是客观的，并使用了精确的科学术语。没有主观或含糊不清的主张。\n- 所提供的数据是离散计数，适合此类分析，且数值合理。没有矛盾或缺失任何必要信息。\n\n**第三步：结论与行动**\n该问题被判定为**有效**。它在科学上是合理的，说明是完整的，逻辑上是一致的。我现在将继续进行解答。\n\n### 解答推导与计算\n\n**第一部分：$\\alpha$ 估计量的推导**\n\n分子进化的中性理论提出，分子水平上绝大多数的进化变化是由选择性中性突变体的随机遗传漂变引起的。一个关键的预测是，如果所有突变都是中性的，非同义替换与同义替换的比率应随时间保持恒定。这意味着，在一个物种内部观察到的非同义 ($N$) 与同义 ($S$) 变化的比例（多态性, $P$）应与在物种之间观察到的比例（分化, $D$）相同，在考虑了每种突变类型的可用位点数之后。\n\n中性预期可以正式表述为：\n$$ \\frac{D_{N, \\text{neutral}}}{D_S} = \\frac{P_N}{P_S} $$\n在这里，$D_{N, \\text{neutral}}$ 代表如果所有非同义突变都是中性的，预期的非同义固定差异数。$D_S$ 是同义固定差异数，通常被假定为中性并作为基线。$P_N$ 和 $P_S$ 分别是非同义和同义多态性数，它们反映了当前的突变输入，并被假定为大部分是中性或弱有害的。\n\n观察到的非同义固定差异总数 $D_N$ 是中性固定（$D_{N, \\text{neutral}}$）和因正选择（即适应性）而固定（$D_{N, \\text{adaptive}}$）的总和：\n$$ D_N = D_{N, \\text{neutral}} + D_{N, \\text{adaptive}} $$\n\n从中性预期，我们可以解出预期的中性非同义固定差异数：\n$$ D_{N, \\text{neutral}} = D_S \\frac{P_N}{P_S} $$\n\n问题将 $\\alpha$ 定义为适应性的非同义固定差异所占的比例。在数学上，这表示为：\n$$ \\alpha = \\frac{D_{N, \\text{adaptive}}}{D_N} $$\n\n将 $D_{N, \\text{adaptive}} = D_N - D_{N, \\text{neutral}}$ 代入 $\\alpha$ 的表达式中，得到：\n$$ \\alpha = \\frac{D_N - D_{N, \\text{neutral}}}{D_N} = 1 - \\frac{D_{N, \\text{neutral}}}{D_N} $$\n\n最后，代入基于中性预期的 $D_{N, \\text{neutral}}$ 表达式，我们得到 $\\alpha$ 的估计量：\n$$ \\hat{\\alpha} = 1 - \\frac{D_S P_N}{D_N P_S} $$\n这就是从第一性原理推导出的所需估计量。\n\n**第二部分：$\\alpha$ 点估计值的计算**\n\n首先，我们必须根据8个基因的逐基因数据计算合并计数。\n$$ P_N = \\sum_{i=1}^{8} P_{N,i} = 5 + 3 + 7 + 4 + 6 + 2 + 8 + 3 = 38 $$\n$$ P_S = \\sum_{i=1}^{8} P_{S,i} = 22 + 24 + 21 + 26 + 28 + 23 + 20 + 26 = 190 $$\n$$ D_N = \\sum_{i=1}^{8} D_{N,i} = 12 + 15 + 18 + 20 + 25 + 14 + 23 + 18 = 145 $$\n$$ D_S = \\sum_{i=1}^{8} D_{S,i} = 20 + 22 + 29 + 34 + 36 + 29 + 30 + 20 = 220 $$\n\n现在，将这些合并计数代入 $\\alpha$ 的估计量中：\n$$ \\hat{\\alpha} = 1 - \\frac{(220)(38)}{(145)(190)} = 1 - \\frac{8360}{27550} $$\n计算该分数：\n$$ \\frac{8360}{27550} \\approx 0.303448275... $$\n因此，$\\alpha$ 的点估计值为：\n$$ \\hat{\\alpha} \\approx 1 - 0.303448275... = 0.696551724... $$\n按要求四舍五入到四位有效数字：\n$$ \\hat{\\alpha} \\approx 0.6966 $$\n\n**第三部分：非参数 bootstrap 策略和标准误表达式**\n\n为了评估估计量 $\\hat{\\alpha}$ 的不确定性，采用通过重抽样基因的非参数 bootstrap 程序是合适的。重抽样的单位是整个基因，因为单个基因的计数（$P_N, P_S, D_N, D_S$）不是独立的。\n\n策略如下：\n$1$. 原始数据集包含 $N=8$ 个观测值，其中每个观测值 $i$ 是一个包含四个计数的向量：$\\text{gene}_i = (P_{N,i}, P_{S,i}, D_{N,i}, D_{S,i})$。\n\n$2$. 通过从原始基因集中有放回地抽样 $N=8$ 个基因，生成一个 bootstrap 重复数据集。设第 $b$ 个 bootstrap 样本为 $\\{\\text{gene}_1^{(b)}, \\text{gene}_2^{(b)}, ..., \\text{gene}_8^{(b)}\\}$。\n\n$3$. 对于每个 bootstrap 重复 $b$，通过对重抽样的基因求和来计算合并计数：\n$$ P_N^{(b)} = \\sum_{j=1}^{8} P_{N,j}^{(b)}, \\quad P_S^{(b)} = \\sum_{j=1}^{8} P_{S,j}^{(b)}, \\quad D_N^{(b)} = \\sum_{j=1}^{8} D_{N,j}^{(b)}, \\quad D_S^{(b)} = \\sum_{j=1}^{8} D_{S,j}^{(b)} $$\n\n$4$. 为此重复计算 $\\alpha$ 的 bootstrap 重复估计值：\n$$ \\hat{\\alpha}^{(b)} = 1 - \\frac{D_S^{(b)} P_N^{(b)}}{D_N^{(b)} P_S^{(b)}} $$\n\n$5$. 重复步骤 $2$-$4$ 大量次，例如 $B$ 次（$B \\ge 1000$），以获得 bootstrap 估计值的一个分布 $\\{\\hat{\\alpha}^{(1)}, \\hat{\\alpha}^{(2)}, ..., \\hat{\\alpha}^{(B)}\\}$。\n\nbootstrap 标准误 $SE_{\\text{boot}}(\\hat{\\alpha})$ 是此 bootstrap 估计值分布的标准差。以 bootstrap 重复估计值表示的此标准误的封闭形式表达式由样本标准差公式给出：\n$$ SE_{\\text{boot}}(\\hat{\\alpha}) = \\sqrt{\\frac{1}{B-1} \\sum_{b=1}^{B} (\\hat{\\alpha}^{(b)} - \\bar{\\alpha}_{\\text{boot}})^2} $$\n其中 $\\bar{\\alpha}_{\\text{boot}}$ 是 bootstrap 重复估计值的平均值：\n$$ \\bar{\\alpha}_{\\text{boot}} = \\frac{1}{B} \\sum_{b=1}^{B} \\hat{\\alpha}^{(b)} $$\n该表达式为点估计 $\\hat{\\alpha}$ 提供了所要求的统计不确定性度量。", "answer": "$$\\boxed{0.6966}$$", "id": "2859585"}, {"introduction": "所有的分子演化分析，包括MK检验和分子钟，都依赖于底层的核苷酸替换数学模型，例如JC69或K80模型。错误地指定模型可能会系统性地影响距离估计，从而导致对演化速率和选择模式的错误推断。这个高级计算练习 [@problem_id:2859543] 要求您亲自实现这些模型，并执行一项敏感性分析，以量化模型选择错误如何扭曲演化分析的结果，这是任何演化生物学研究者都必须掌握的一项批判性技能。", "problem": "你的任务是构建一个完全指定的敏感性分析，以量化核苷酸突变模型的错误指定如何对中性进化距离估计产生偏差，并改变分子钟检验的结果。请在中性分子进化理论的框架下进行，其中中性替换根据核苷酸上的连续时间马尔可夫链累积，且位点是独立同分布的。假设碱基的平稳频率相等且时间可逆。使用两个特定模型：Jukes–Cantor 模型 (JC69) 和 Kimura 双参数模型 (K80)。你的程序必须从基本原理出发实现以下步骤。\n\n1. 预期位点模式概率的模型基础：\n   - 在 Kimura 双参数模型 (K80) 下，有两个速率参数：每个位点每单位时间的转换速率 $\\alpha$ 和每个位点每单位时间的颠换速率 $\\beta$，且具有相等的平稳分布。对速率矩阵进行归一化，使得每个位点每单位时间的预期替换数为 1；即强制要求 $2\\beta + \\alpha = 1$。定义转换与颠换的速率比 $\\kappa = \\alpha / \\beta$，这意味着 $\\alpha = \\kappa/(2+\\kappa)$ 和 $\\beta = 1/(2+\\kappa)$。\n   - 对于任何一对由总进化路径长度 $t$（以每个位点的预期替换数度量）分隔的序列，将一个位点是转换差异的概率建模为 $P(t,\\kappa)$，是颠换差异的概率建模为 $Q(t,\\kappa)$。这些都基于经过上述归一化的 K80 速率矩阵的连续时间马尔可夫链。\n   - 在 Jukes–Cantor 模型 (JC69) 下，一个核苷酸可能发生的所有 3 种变化都以相等的速率发生。使用相同的归一化约定：每个位点每单位时间的预期替换数为 1。对于由路径长度 $t$ 分隔的一对序列，总体差异概率为 $p(t)$，而转换与颠换的概率则由对称性得出。\n\n2. 需要实现的距离估计算法：\n   - JC69 校正距离估计量：根据 $L$ 个位点上观察到的总体差异比例 $p$，返回一个估计的进化距离 $\\widehat{d}_{\\mathrm{JC}}(p)$。\n   - K80 校正距离估计量：根据 $L$ 个位点上观察到的转换和颠换比例 $(P,Q)$，返回一个估计的进化距离 $\\widehat{d}_{\\mathrm{K80}}(P,Q)$。\n   - 当真实模型是 JC69 时，通过对称性从 $p$ 构造用于 K80 估计量的 $(P,Q)$。当真实模型是 K80 时，通过 $p = P+Q$ 构造用于 JC69 估计量的 $p$。\n\n3. 通过 delta 方法计算抽样方差：\n   - 假设位点是独立同分布的。\n   - 对于 JC69，将每个位点的观察结果视为一个指示“不同”或“相同”的伯努利变量，其成功概率为 $p$，以获得 $\\mathrm{Var}(\\widehat{p})$，然后通过 delta 方法，使用估计量对 $p$ 的导数来获得 $\\mathrm{Var}(\\widehat{d}_{\\mathrm{JC}})$。\n   - 对于 K80，将位点结果视为一个具有“转换差异”、“颠换差异”和“无差异”类别以及概率 $(P,Q,1-P-Q)$ 的多项分布。使用 $(\\widehat{P},\\widehat{Q})$ 的 $2\\times 2$ 协方差矩阵和 K80 距离估计量关于 $(P,Q)$ 的梯度，通过 delta 方法计算 $\\mathrm{Var}(\\widehat{d}_{\\mathrm{K80}})$。\n\n4. 分子钟检验规范：\n   - 考虑三个分类单元：两个内群分类单元 $1$ 和 $2$，以及一个外群 $O$。设从内群的最近共同祖先到 $1$ 和 $2$ 的分支长度分别为 $t_1$ 和 $t_2$，设从根到 $O$ 的分支长度为 $t_0$。分子钟对末端到外群距离的预测是 $d_{1O} = t_1 + t_0$ 和 $d_{2O} = t_2 + t_0$。为评估对模型错误指定的敏感性，分别在每个估计量（JC69 和 K80）下，通过比较估计距离 $\\widehat{d}_{1O}$ 和 $\\widehat{d}_{2O}$，对零假设 $H_0: d_{1O} = d_{2O}$ 进行双样本 $z$ 检验。假设通过从长度为 $L_1$ 的基因座估计 $\\widehat{d}_{1O}$ 和从长度为 $L_2$ 的不同基因座估计 $\\widehat{d}_{2O}$ 来实现独立性。在零假设下，使用检验统计量\n     $$\n     Z \\;=\\; \\frac{\\widehat{d}_{1O} - \\widehat{d}_{2O}}{\\sqrt{\\mathrm{Var}(\\widehat{d}_{1O}) + \\mathrm{Var}(\\widehat{d}_{2O})}},\n     $$\n     如果在双侧 $\\alpha$ 水平下 $|Z|  z_{1-\\alpha/2}$，则拒绝 $H_0$。使用 $\\alpha = 0.05$ 和标准正态分位数 $z_{0.975}$。\n\n5. 配对距离的偏差量化：\n   - 对于由已知总路径长度 $t_{\\mathrm{pair}}$ 分隔的单对序列，当观察结果在指定的真实模型和参数集下生成时，计算偏差 $b_{\\mathrm{JC}} = \\widehat{d}_{\\mathrm{JC}} - t_{\\mathrm{pair}}$ 和 $b_{\\mathrm{K80}} = \\widehat{d}_{\\mathrm{K80}} - t_{\\mathrm{pair}}$。使用预期频率（即，代入模型的预期 $(P,Q)$ 或 $p$ 而非随机计数）来将模型错误指定的偏差与抽样误差分离开。\n\n6. 实现说明：\n   - 所有计算都必须以无单位的比例或以“每个位点的预期替换数”度量的进化距离表示。不涉及物理单位。\n   - 你的程序必须根据指定的参数确定性地计算期望值；不要模拟每个位点的结果。使用来自连续时间马尔可夫模型的解析概率。\n\n测试套件：\n为以下三种情况实现上述分析。在每种情况下，计算并汇总：\n- 单对分析的配对偏差 $b_{\\mathrm{JC}}$ 和 $b_{\\mathrm{K80}}$，以及\n- 两个布尔值，分别表示使用 $\\alpha=0.05$ 的双样本 $z$ 检验时，分子钟的 $H_0$ 在 JC69 和 K80 模型下是否被拒绝。\n\n提供最终输出为单行，包含一个逗号分隔的列表，其中包含三种情况的结果，每种情况的结果都是 $[\\;b_{\\mathrm{JC}},\\;b_{\\mathrm{K80}},\\;\\text{reject\\_clock\\_JC},\\;\\text{reject\\_clock\\_K80}\\;]$ 形式的列表。\n\n- 情况 A (理想情况；K80 下的中等分歧)：\n  - 真实模型: K80\n  - $\\kappa = 4$\n  - 配对分析: $t_{\\mathrm{pair}} = 0.5$, $L = 1000000$\n  - 分子钟检验: $t_1 = 0.25$, $t_2 = 0.35$, $t_0 = 0.7$, $L_1 = 3000$, $L_2 = 3000$\n\n- 情况 B (接近饱和的边缘情况；K80 下的强转换偏差)：\n  - 真实模型: K80\n  - $\\kappa = 10$\n  - 配对分析: $t_{\\mathrm{pair}} = 1.2$, $L = 1000000$\n  - 分子钟检验: $t_1 = 0.2$, $t_2 = 0.4$, $t_0 = 1.0$, $L_1 = 2200$, $L_2 = 2200$\n\n- 情况 C (模型对称；JC69 是真实模型)：\n  - 真实模型: JC69\n  - $\\kappa = 1$\n  - 配对分析: $t_{\\mathrm{pair}} = 0.5$, $L = 1000000$\n  - 分子钟检验: $t_1 = 0.3$, $t_2 = 0.5$, $t_0 = 0.6$, $L_1 = 5000$, $L_2 = 5000$\n\n最终输出格式：\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表的结果，其中每个元素本身就是一个格式为 $[\\;b_{\\mathrm{JC}},\\;b_{\\mathrm{K80}},\\;\\text{reject\\_clock\\_JC},\\;\\text{reject\\_clock\\_K80}\\;]$ 的列表。例如：$[[0.0,0.0,\\mathrm{False},\\mathrm{True}],[\\dots],[\\dots]]$。所有实数必须以 Python 的默认字符串格式按小数形式打印。输出中任何地方都不需要单位，也不允许使用百分号。", "solution": "该问题要求对进化距离估计和分子钟检验的模型错误指定进行敏感性分析。该分析在分子进化中性理论的框架下进行，使用 Jukes-Cantor (JC69) 和 Kimura 双参数 (K80) 模型。解决方案将从基本原理推导得出。\n\n### 1. 模型基础：替换概率\n\n我们将核苷酸替换建模为连续时间马尔可夫过程。进化距离 $t$ 定义为每个位点的预期替换数。这要求对瞬时速率矩阵 $\\mathbf{Q}$进行归一化，使得平均替换速率 $\\lambda = -\\sum_{i} \\pi_i Q_{ii}$ 等于 $1$。在碱基平稳频率相等（$\\pi_i = 1/4$）的情况下，这简化为 $\\lambda = -(1/4)\\sum_i Q_{ii} = 1$。\n\n#### Kimura 双参数 (K80) 模型\nK80 模型区分了转换（在嘌呤 $\\{A,G\\}$ 或嘧啶 $\\{C,T\\}$ 内部的替换）和颠换（嘌呤和嘧啶之间的替换）。设 $\\alpha$ 为转换速率，$\\beta$ 为颠换速率。速率矩阵为：\n$$\n\\mathbf{Q}_{\\text{K80}} = \\begin{pmatrix}\n-(\\alpha+2\\beta)  \\beta  \\alpha  \\beta \\\\\n\\beta  -(\\alpha+2\\beta)  \\beta  \\alpha \\\\\n\\alpha  \\beta  -(\\alpha+2\\beta)  \\beta \\\\\n\\beta  \\alpha  \\beta  -(\\alpha+2\\beta)\n\\end{pmatrix}\n$$\n归一化条件是 $\\alpha + 2\\beta = 1$。转换与颠换的速率比为 $\\kappa = \\alpha/\\beta$。代入归一化条件得到 $\\kappa\\beta + 2\\beta = 1$，从而得出作为 $\\kappa$ 函数的速率：\n$$\n\\alpha = \\frac{\\kappa}{2+\\kappa}, \\quad \\beta = \\frac{1}{2+\\kappa}\n$$\n有限时间间隔 $t$ 的概率矩阵为 $\\mathbf{P}(t) = e^{\\mathbf{Q}t}$。元素 $P_{ij}(t)$ 给出在时间 0 时为核苷酸 $i$ 的位点，在时间 $t$ 后观察到核苷酸 $j$ 的概率。对于 K80 模型，这些概率是：\n- $P_{ii}(t) = \\frac{1}{4} + \\frac{1}{4}e^{-4\\beta t} + \\frac{1}{2}e^{-2(\\alpha+\\beta)t}$ (相同核苷酸)\n- $P_{ij}(t) = \\frac{1}{4} + \\frac{1}{4}e^{-4\\beta t} - \\frac{1}{2}e^{-2(\\alpha+\\beta)t}$ (转换变化)\n- $P_{ik}(t) = \\frac{1}{4} - \\frac{1}{4}e^{-4\\beta t}$ (颠換变化)\n\n假设碱基频率相等，显示转换差异的位点预期比例 $P(t,\\kappa)$是所有可能的转换对概率之和，例如 $4 \\times \\pi_A P_{AG}(t) = P_{AG}(t)$。显示颠换差异的位点预期比例 $Q(t,\\kappa)$是所有 8 种颠换对的概率之和，即 $8 \\times \\pi_A P_{AC}(t) = 2 P_{AC}(t)$。\n因此，使用归一化速率：\n$$\nP(t,\\kappa) = \\frac{1}{4} + \\frac{1}{4}e^{-\\frac{4t}{2+\\kappa}} - \\frac{1}{2}e^{-\\frac{2(\\kappa+1)t}{2+\\kappa}}\n$$\n$$\nQ(t,\\kappa) = \\frac{1}{2} \\left(1 - e^{-\\frac{4t}{2+\\kappa}}\\right)\n$$\n\n#### Jukes-Cantor (JC69) 模型\nJC69 模型假设所有替换都以相同的速率 $\\mu$ 发生。它是 K80 模型在 $\\alpha=\\beta$ (即 $\\kappa=1$) 时的特例。归一化条件 $\\alpha+2\\beta=1$ 变为 $3\\mu=1$，所以 $\\mu=1/3$。在时间 $t$ 后观察到位点差异的概率由下式给出：\n$$\np(t) = \\frac{3}{4}\\left(1 - e^{-4t/3}\\right)\n$$\n根据对称性，这些差异中预期有三分之一是转换，三分之二是颠换。\n$P_{\\text{JC69}}(t) = p(t)/3 = \\frac{1}{4}\\left(1 - e^{-4t/3}\\right)$\n$Q_{\\text{JC69}}(t) = 2p(t)/3 = \\frac{1}{2}\\left(1 - e^{-4t/3}\\right)$\n当 $\\kappa=1$ 时，这些与 K80 模型的 $P(t,\\kappa)$ 和 $Q(t,\\kappa)$ 公式相匹配。\n\n### 2. 距离估计\n距离估计量是通过对概率函数求逆以解出 $t$ 来推导的。\n\n#### JC69 距离估计量\n从 $p = \\frac{3}{4}\\left(1 - e^{-4d/3}\\right)$，我们解出距离 $d$：\n$$\n\\widehat{d}_{\\mathrm{JC}}(p) = -\\frac{3}{4} \\ln\\left(1 - \\frac{4}{3}p\\right)\n$$\n此估计量对于观察到的比例 $p  3/4$ 是有效的。\n\n#### K80 距离估计量\n从 $P(t,\\kappa)$ 和 $Q(t,\\kappa)$ 的方程中，我们可以看到：\n$1 - 2Q = e^{-\\frac{4t}{2+\\kappa}}$\n$1 - 2P - Q = e^{-\\frac{2(\\kappa+1)t}{2+\\kappa}}$\n在不知道 $\\kappa$ 的情况下，无法从中解出 $t$。然而，另一种不需要 $\\kappa$ 的代数操作可以得到标准的 K80 距離估計量：\n$$\n\\widehat{d}_{\\mathrm{K80}}(P,Q) = -\\frac{1}{2}\\ln(1-2P-Q) - \\frac{1}{4}\\ln(1-2Q)\n$$\n此公式在 $Q  1/2$ 和 $2P+Q  1$ 时有效。当真实模型是 JC69（观察到 $p$）时，我们在 K80 估计量中使用 $P=p/3$ 和 $Q=2p/3$。此代换显示 $\\widehat{d}_{\\mathrm{K80}}(p/3, 2p/3) = \\widehat{d}_{\\mathrm{JC}}(p)$，证实了 JC69 是 K80 的嵌套模型。\n\n### 3. 通过 Delta 方法计算抽样方差\n距离估计量的方差使用 delta 方法近似。\n\n#### $\\widehat{d}_{\\mathrm{JC}}$ 的方差\n从 $L$ 个位点观察到的比例 $\\widehat{p}$ 的方差为 $\\mathrm{Var}(\\widehat{p}) = p(1-p)/L$。距离的方差是：\n$$\n\\mathrm{Var}(\\widehat{d}_{\\mathrm{JC}}) \\approx \\left( \\frac{\\partial \\widehat{d}_{\\mathrm{JC}}}{\\partial p} \\right)^2 \\mathrm{Var}(\\widehat{p}) = \\left( \\frac{1}{1-4p/3} \\right)^2 \\frac{p(1-p)}{L}\n$$\n\n#### $\\widehat{d}_{\\mathrm{K80}}$ 的方差\n转换、颠换和相同位点的计数遵循多项分布。观察到的比例 $(\\widehat{P}, \\widehat{Q})$ 的协方差矩阵是：\n$$\n\\mathrm{Cov}(\\widehat{P}, \\widehat{Q}) = \\frac{1}{L} \\begin{pmatrix} P(1-P)  -PQ \\\\ -PQ  Q(1-Q) \\end{pmatrix}\n$$\n$\\widehat{d}_{\\mathrm{K80}}$ 的梯度是 $\\nabla d = \\left(\\frac{\\partial d}{\\partial P}, \\frac{\\partial d}{\\partial Q}\\right)^T$，其中：\n$$\n\\frac{\\partial d}{\\partial P} = \\frac{1}{1-2P-Q}, \\quad \\frac{\\partial d}{\\partial Q} = \\frac{1}{2(1-2P-Q)} + \\frac{1}{2(1-2Q)}\n$$\n方差由二次型 $\\mathrm{Var}(\\widehat{d}_{\\mathrm{K80}}) \\approx (\\nabla d)^T \\mathrm{Cov}(\\widehat{P}, \\widehat{Q}) (\\nabla d)$ 给出：\n$$\n\\mathrm{Var}(\\widehat{d}_{\\mathrm{K80}}) \\approx \\frac{1}{L} \\left[ \\left(\\frac{\\partial d}{\\partial P}\\right)^2 P(1-P) + \\left(\\frac{\\partial d}{\\partial Q}\\right)^2 Q(1-Q) - 2\\left(\\frac{\\partial d}{\\partial P}\\right)\\left(\\frac{\\partial d}{\\partial Q}\\right)PQ \\right]\n$$\n\n### 4. 分子钟检验与偏差量化\n对于分析，我们使用从真实模型推导出的预期比例，以将偏差与抽样误差分离开。\n\n- **偏差**：给定一个真實模型和距離 $t_{\\text{pair}}$，我們首先計算預期比例（$P,Q$ 或 $p$）。然後我們將（可能错误指定的）距离估计量应用于这些比例，以获得估计距离 $\\widehat{d}$。偏差为 $b = \\widehat{d} - t_{\\text{pair}}$。如果估计量与真实模型匹配，则偏差为零。\n\n- **分子钟检验**：我们检验零假设 $H_0: d_{1O} = d_{2O}$，其中 $d_{1O} = t_1+t_0$ 和 $d_{2O} = t_2+t_0$。检验统计量是：\n  $$\n  Z = \\frac{\\widehat{d}_{1O} - \\widehat{d}_{2O}}{\\sqrt{\\mathrm{Var}(\\widehat{d}_{1O}) + \\mathrm{Var}(\\widehat{d}_{2O})}}\n  $$\n  这里，$\\widehat{d}$ 值是根据真实距离 $d_{1O}$ 和 $d_{2O}$ 的预期比例估计出的距离，方差是使用这些相同的比例和各自的序列长度 $L_1$ 和 $L_2$ 计算的。我们在显著性水平 $\\alpha=0.05$ 下，如果 $|Z| > z_{0.975} \\approx 1.95996$，则拒绝 $H_0$。\n\n实现将通过为这些推导出的公式创建函数，并将它们应用于指定的测试用例来进行。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\n# Use a strict academic tone for functions, adhering to the persona.\n# All mathematical entities are expressed in code, following the derived formulas.\n\ndef get_k80_probs(t, kappa):\n    \"\"\"\n    Computes expected transition (P) and transversion (Q) proportions under the K80 model.\n    t: evolutionary distance\n    kappa: transition/transversion rate ratio\n    \"\"\"\n    if kappa = 0:\n        raise ValueError(\"Kappa must be positive.\")\n    \n    alpha = kappa / (2 + kappa)\n    beta = 1 / (2 + kappa)\n    \n    # Corrected K80 probability formulas derived from first principles\n    # P(t,k) = 1/4 + 1/4*exp(-4*beta*t) - 1/2*exp(-2*(alpha+beta)*t)\n    # Q(t,k) = 1/2 * (1 - exp(-4*beta*t))\n    # Time t is distance in expected substitutions per site, consistent with normalization alpha+2*beta=1.\n\n    exp_term1 = np.exp(-4 * beta * t)\n    exp_term2 = np.exp(-2 * (alpha + beta) * t)\n\n    P = 0.25 + 0.25 * exp_term1 - 0.5 * exp_term2\n    Q = 0.5 * (1 - exp_term1)\n    \n    return P, Q\n\ndef get_jc69_prob(t):\n    \"\"\"\n    Computes expected total difference proportion (p) under the JC69 model.\n    t: evolutionary distance\n    \"\"\"\n    # p(t) = 3/4 * (1 - exp(-4/3 * t))\n    p = 0.75 * (1 - np.exp(-4/3 * t))\n    return p\n\ndef dist_jc69(p):\n    \"\"\"\n    Estimates distance using the JC69 correction.\n    p: observed proportion of differences\n    \"\"\"\n    # d = -3/4 * log(1 - 4/3 * p)\n    arg = 1 - (4/3) * p\n    if arg = 0:\n        return np.inf\n    return -0.75 * np.log(arg)\n\ndef dist_k80(P, Q):\n    \"\"\"\n    Estimates distance using the K80 correction.\n    P, Q: observed proportions of transitions and transversions\n    \"\"\"\n    # d = -1/2*log(1-2P-Q) - 1/4*log(1-2Q)\n    arg1 = 1 - 2 * P - Q\n    arg2 = 1 - 2 * Q\n    if arg1 = 0 or arg2 = 0:\n        return np.inf\n    return -0.5 * np.log(arg1) - 0.25 * np.log(arg2)\n\ndef var_jc69(p, L):\n    \"\"\"\n    Computes variance of the JC69 distance estimator via the delta method.\n    p: expected proportion of differences\n    L: sequence length\n    \"\"\"\n    # Var(d_JC) = (1 / (1 - 4p/3))^2 * (p(1-p)/L)\n    if p = 0.75:\n        return np.inf\n    deriv_term = 1 / (1 - (4/3) * p)\n    var_p = p * (1 - p) / L\n    return (deriv_term**2) * var_p\n\ndef var_k80(P, Q, L):\n    \"\"\"\n    Computes variance of the K80 distance estimator via the delta method.\n    P, Q: expected proportions of transitions and transversions\n    L: sequence length\n    \"\"\"\n    # Var(d_K80) = (grad_d)' * Cov(P,Q) * (grad_d)\n    if 1 - 2 * Q = 0 or 1 - 2 * P - Q = 0:\n        return np.inf\n\n    # Gradient components\n    d_dP = 1 / (1 - 2 * P - Q)\n    d_dQ = 0.5 / (1 - 2 * P - Q) + 0.5 / (1 - 2 * Q)\n    \n    # Covariance matrix components of (P_hat, Q_hat)\n    var_P = P * (1 - P) / L\n    var_Q = Q * (1 - Q) / L\n    cov_PQ = -P * Q / L\n    \n    variance = (d_dP**2 * var_P) + (d_dQ**2 * var_Q) + (2 * d_dP * d_dQ * cov_PQ)\n    return variance\n\ndef solve():\n    \"\"\"\n    Main function to execute the sensitivity analysis for all test cases.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A\n        {\"true_model\": \"K80\", \"kappa\": 4, \"t_pair\": 0.5, \"L_pair\": 1000000,\n         \"t1\": 0.25, \"t2\": 0.35, \"t0\": 0.7, \"L1\": 3000, \"L2\": 3000},\n        # Case B\n        {\"true_model\": \"K80\", \"kappa\": 10, \"t_pair\": 1.2, \"L_pair\": 1000000,\n         \"t1\": 0.2, \"t2\": 0.4, \"t0\": 1.0, \"L1\": 2200, \"L2\": 2200},\n        # Case C\n        {\"true_model\": \"JC69\", \"kappa\": 1, \"t_pair\": 0.5, \"L_pair\": 1000000,\n         \"t1\": 0.3, \"t2\": 0.5, \"t0\": 0.6, \"L1\": 5000, \"L2\": 5000},\n    ]\n\n    z_crit = norm.ppf(1 - 0.05 / 2) # z_{0.975}\n    results = []\n\n    for case in test_cases:\n        # --- 1. Pairwise Bias Analysis ---\n        if case[\"true_model\"] == \"K80\":\n            P_true, Q_true = get_k80_probs(case[\"t_pair\"], case[\"kappa\"])\n            p_misspecified = P_true + Q_true\n            \n            d_jc_est = dist_jc69(p_misspecified)\n            d_k80_est = dist_k80(P_true, Q_true)\n            \n        elif case[\"true_model\"] == \"JC69\":\n            p_true = get_jc69_prob(case[\"t_pair\"])\n            P_misspecified, Q_misspecified = p_true / 3, 2*p_true / 3\n\n            d_jc_est = dist_jc69(p_true)\n            d_k80_est = dist_k80(P_misspecified, Q_misspecified)\n        \n        b_jc = d_jc_est - case[\"t_pair\"]\n        b_k80 = d_k80_est - case[\"t_pair\"]\n        \n        # --- 2. Molecular Clock Test ---\n        d1O = case[\"t1\"] + case[\"t0\"]\n        d2O = case[\"t2\"] + case[\"t0\"]\n        \n        # JC69 Clock Test\n        if case[\"true_model\"] == \"K80\":\n            P1, Q1 = get_k80_probs(d1O, case[\"kappa\"])\n            p1 = P1 + Q1\n            P2, Q2 = get_k80_probs(d2O, case[\"kappa\"])\n            p2 = P2 + Q2\n        else: # True model is JC69\n            p1 = get_jc69_prob(d1O)\n            p2 = get_jc69_prob(d2O)\n            \n        d1O_jc = dist_jc69(p1)\n        d2O_jc = dist_jc69(p2)\n        var1_jc = var_jc69(p1, case[\"L1\"])\n        var2_jc = var_jc69(p2, case[\"L2\"])\n        \n        Z_jc = (d1O_jc - d2O_jc) / np.sqrt(var1_jc + var2_jc)\n        reject_clock_jc = abs(Z_jc)  z_crit\n\n        # K80 Clock Test\n        if case[\"true_model\"] == \"K80\":\n            P1, Q1 = get_k80_probs(d1O, case[\"kappa\"])\n            P2, Q2 = get_k80_probs(d2O, case[\"kappa\"])\n        else: # True model is JC69\n            p1_true = get_jc69_prob(d1O)\n            P1, Q1 = p1_true/3, 2*p1_true/3\n            p2_true = get_jc69_prob(d2O)\n            P2, Q2 = p2_true/3, 2*p2_true/3\n            \n        d1O_k80 = dist_k80(P1, Q1)\n        d2O_k80 = dist_k80(P2, Q2)\n        var1_k80 = var_k80(P1, Q1, case[\"L1\"])\n        var2_k80 = var_k80(P2, Q2, case[\"L2\"])\n\n        Z_k80 = (d1O_k80 - d2O_k80) / np.sqrt(var1_k80 + var2_k80)\n        reject_clock_k80 = abs(Z_k80)  z_crit\n\n        results.append([b_jc, b_k80, reject_clock_jc, reject_clock_k80])\n\n    # Format the final output as a single string\n    result_str = ','.join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2859543"}]}