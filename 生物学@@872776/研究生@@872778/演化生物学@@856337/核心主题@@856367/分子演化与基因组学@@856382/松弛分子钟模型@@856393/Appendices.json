{"hands_on_practices": [{"introduction": "在深入研究复杂的放松型分子钟模型之前，我们必须首先牢固掌握其基础——严格分子钟。这个练习将引导您完成严格分子钟的基本计算。通过解决这个简单的理想化情景[@problem_id:2749326]，您将为时间、分支长度和进化速率之间的核心关系（即$距离 = 速率 \\times 时间$）建立坚实的直觉，这对于后续理解和应用更复杂的速率变异模型至关重要。", "problem": "一个四分类单元的超度量系统发育树在严格分子钟下关联了分类单元 $A$、$B$、$C$ 和 $D$。其拓扑结构为 $((A,B),(C,D))$，且该树是超度量树，所有尖端的总尖端到根时间 $T$ 均相同。单次校准将根节点（所有四个分类单元的最近共同祖先 (MRCA)）的年龄固定在 $T_{\\mathrm{root}} = 12$ 百万年（Myr）。沿着从现在到根的每条路径，分支时长（单位：百万年）如下：\n- 对于分类单元 $A$ 和 $B$：从其分支的 MRCA 到尖端的每条悬垂支的时长为 $7$，从该分支的 MRCA 到根的内部支的时长为 $5$。\n- 对于分类单元 $C$ 和 $D$：从其分支的 MRCA 到尖端的每条悬垂支的时长为 $8$，从该分支的 MRCA 到根的内部支的时长为 $4$。\n根据构造，该树是超度量的，因为 $7+5=12$ 且 $8+4=12$。\n\n根据在 Jukes-Cantor (JC69) 模型下分析的比对结果，沿每条完整的尖端到根路径的校正距离估计为 $d_{A}=0.84$、$d_{B}=0.84$、$d_{C}=0.84$ 和 $d_{D}=0.84$（每位点替换数）。\n\n假设存在一个严格分子钟，其全局速率为 $r$（单位：每位点替换数/百万年），因此在时长 $\\Delta t$ 内沿任何谱系累积的每位点预期替换数与时间成线性关系，比例常数为 $r$。在 JC69 模型下，校正的路径距离等于沿该路径累积的每位点预期总替换数。\n\n计算：\n1. 全局速率 $r$（单位：每位点替换数/百万年）。\n2. 两个内部节点的年龄（单位：百万年前）：$(A,B)$ 的 MRCA 和 $(C,D)$ 的 MRCA。\n\n按顺序 $\\big(r,\\ \\text{age}_{(A,B)},\\ \\text{age}_{(C,D)}\\big)$ 报告这三个值。将您的答案四舍五入至三位有效数字。$r$ 的单位为每位点替换数/百万年，节点年龄的单位为百万年。在最终报告的元组中不要包含单位。", "solution": "首先将验证问题的正确性和一致性。\n\n**步骤 1：提取已知条件**\n- **拓扑结构**：一个四分类单元树，其拓扑为 $((A,B),(C,D))$。\n- **分子钟模型**：严格分子钟，具有单一全局速率 $r$。\n- **树的属性**：该系统发育树是超度量的。\n- **根节点年龄**：根节点（$(A,B,C,D)$ 的 MRCA）的年龄为 $T_{\\mathrm{root}} = 12$ 百万年（Myr）。\n- **$(A,B)$ 分支的时长**：\n    - 悬垂支时长（$(A,B)$ 的 MRCA 到尖端）：$7$ 百万年。\n    - 内部支时长（根到 $(A,B)$ 的 MRCA）：$5$ 百万年。\n- **$(C,D)$ 分支的时长**：\n    - 悬垂支时长（$(C,D)$ 的 MRCA 到尖端）：$8$ 百万年。\n    - 内部支时长（根到 $(C,D)$ 的 MRCA）：$4$ 百万年。\n- **路径时间一致性**：从根到任何尖端的总时间是恒定的：$7+5=12$ 百万年和 $8+4=12$ 百万年。这与超度量属性和根节点年龄一致。\n- **遗传距离**：在 Jukes-Cantor (JC69) 模型下，校正后的尖端到根距离为 $d_{A}=0.84$、$d_{B}=0.84$、$d_{C}=0.84$ 和 $d_{D}=0.84$（每位点替换数）。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它描述了分子系统发育学中的一个标准场景。前提是严格分子钟，即遗传距离在所有谱系中以恒定速率 $r$ 随时间线性累积。该树被指定为超度量树，意味着从根到每个尖端的总时间是相同的。所提供的分支时长（$7+5=12$ 和 $8+4=12$）与所述的根节点年龄 $T_{\\mathrm{root}} = 12$ 百万年一致。从根到尖端的校正遗传距离对所有分类单元都相等（$d=0.84$），这是严格分子钟在超度量树上的必然结果。该问题内部一致，并包含计算所要求数量的所有必要信息。没有逻辑矛盾或事实错误。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n**求解过程**\n\n该问题要求计算三个值：全局替换速率 $r$，以及两个内部节点的年龄，这两个节点分别是分支 $(A,B)$ 和 $(C,D)$ 的最近共同祖先（MRCA）。\n\n**1. 全局速率 $r$ 的计算**\n在严格分子钟下，沿谱系累积的预期遗传距离 $d$（单位：每位点替换数）与时间跨度 $T$（单位：百万年）成正比。比例常数是替换速率 $r$（单位：每位点替换数/百万年）。该关系表示为：\n$$d = r \\times T$$\n问题陈述从根到任何尖端的总时间为 $T = 12$ 百万年。它还提供了任何从根到尖端路径对应的校正遗传距离为 $d = 0.84$（每位点替换数）。因此，我们可以求解速率 $r$：\n$$r = \\frac{d}{T}$$\n代入给定值：\n$$r = \\frac{0.84}{12} \\text{ substitutions per site per Myr}$$\n$$r = 0.07 \\text{ substitutions per site per Myr}$$\n问题要求答案四舍五入至三位有效数字。用标准科学记数法表示为：\n$$r = 7.00 \\times 10^{-2} \\text{ substitutions per site per Myr}$$\n\n**2. 节点年龄的计算**\n系统发育树中节点的年龄定义为从该节点到现在的时间。树的尖端代表现在，可以设为时间 $0$。\n\n**A. $(A,B)$ 的 MRCA 的年龄**\n问题陈述，对于分类单元 $A$ 和 $B$，从它们的 MRCA 到尖端的悬垂支的时长为 $7$ 百万年。根据定义，该时长代表从 MRCA 事件到现在所经过的时间。因此，$(A,B)$ 的 MRCA 的年龄为：\n$$\\text{age}_{(A,B)} = 7 \\text{ Myr}$$\n这可以使用内部支的信息进行验证。根节点的年龄为 $12$ 百万年。连接根节点与 $(A,B)$ 的 MRCA 的内部支的时长为 $5$ 百万年。该节点的年龄是其父节点的年龄减去连接支的时长：\n$$\\text{age}_{(A,B)} = T_{\\mathrm{root}} - \\Delta t_{\\text{internal}, (A,B)} = 12 - 5 = 7 \\text{ Myr}$$\n这些值是一致的。保留三位有效数字，年龄为 $7.00$ 百万年。\n\n**B. $(C,D)$ 的 MRCA 的年龄**\n类似地，对于分类单元 $C$ 和 $D$，从它们的 MRCA 到尖端的悬垂支的时长为 $8$ 百万年。这个时长就是该节点的年龄。\n$$\\text{age}_{(C,D)} = 8 \\text{ Myr}$$\n使用 $4$ 百万年的内部支时长来验证这一点：\n$$\\text{age}_{(C,D)} = T_{\\mathrm{root}} - \\Delta t_{\\text{internal}, (C,D)} = 12 - 4 = 8 \\text{ Myr}$$\n这些值再次一致。保留三位有效数字，年龄为 $8.00$ 百万年。\n\n**最终值**\n按指定顺序 $\\big(r,\\ \\text{age}_{(A,B)},\\ \\text{age}_{(C,D)}\\big)$ 并四舍五入至三位有效数字的所求值为：\n- $r = 7.00 \\times 10^{-2}$\n- $\\text{age}_{(A,B)} = 7.00$\n- $\\text{age}_{(C,D)} = 8.00$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n7.00 \\times 10^{-2}  7.00  8.00\n\\end{pmatrix}\n}\n$$", "id": "2749326"}, {"introduction": "现实世界的数据很少严格遵循单一的进化速率。本练习模拟了分子定年分析中的一个常见挑战：如何协调遗传数据与化石校准证据之间的潜在冲突。通过分析这个问题[@problem_id:2749316]中提出的情景，您将更深入地理解非相关对数正态（UCLN）模型如何利用速率异质性（由参数 $\\sigma^2$ 量化）来解决这种矛盾，并学会批判性地评估数据和校准先验之间的相互作用。", "problem": "在一个拓扑结构为 $\\left((A,B),C\\right)$ 的三分类单元树的分子定年分析中，序列数据产生的从根节点到每个叶节点的估计谱系距离（单位：每位点替换数）约为 $D_A \\approx 0.12$、$D_B \\approx 0.11$ 和 $D_C \\approx 0.10$。您采用了一个不相关对数正态（UCLN）放松型钟，其中分支特异性瞬时速率 $r_i$ 从一个对数尺度上，方差参数为 $\\sigma^2$ 的对数正态分布中独立同分布（i.i.d.）地抽取。您在两个节点上设置了化石校准先验：$A$ 和 $B$ 的分化时间，软性最小值为 $T_{AB} \\ge 25$ 百万年（Ma）；以及根节点年龄，软性最大值为 $T_{\\text{root}} \\le 27$ Ma。树先验是一个标准的具有弥散超参数的出生–死亡过程。所有校准都以具有软性边界的概率性先验实现，而非硬性约束。\n\n请考虑以下基本事实：（i）沿一个分支的期望替换数等于时间跨度乘以该分支的特异性速率；以及（ii）在 UCLN 模型中，增加 $\\sigma^2$ 会给予分支间更极端的速率差异更大的先验权重。您还可以选择执行留一校准交叉验证，即移除一个校准先验，用剩余的校准拟合模型，并检查被排除节点的年龄的后验预测分布。\n\n仅使用这些基本考量，分析给定的校准和数据对 $\\sigma^2$ 后验的可能联合效应，并确定合理的建模或数据论证对策。以下哪些陈述与上述原则最为一致？\n\nA. 在不相关对数正态（UCLN）模型下，由 $T_{AB} \\ge 25$ Ma 和 $T_{\\text{root}} \\le 27$ Ma 以及观测到的 $D_A$、$D_B$ 和 $D_C$ 所产生的冲突，将倾向于推高对数速率方差 $\\sigma^2$ 的后验，因为只有显著的速率异质性才能调和长的分化前持续时间与相对较小的累积替换数。\n\nB. 留一校准交叉验证倾向于标记出一个不一致的校准：如果排除 $A$–$B$ 校准，仅用根节点校准来拟合模型，那么 $T_{AB}$ 的后验预测值可能会远低于 $25$ Ma；反之，如果排除根节点校准，可能会产生一个超过 $27$ Ma 的 $T_{\\text{root}}$ 后验预测值，从而揭示冲突。\n\nC. 解决这一冲突最合适的补救措施是为 $\\sigma^2$ 固定一个非常大的先验，以便模型总是能容许足够的速率变化来满足所有校准；这能防止偏差并提高定年精度。\n\nD. 一种可辩护的对策包括重新审视化石依据（系统发育位置和地层背景），并且，如果有必要，软化或放宽校准先验（例如，使用更宽的对数正态或偏移伽马分布）以更好地反映不确定性，这可以减少 $\\sigma^2$ 的病态膨胀。\n\nE. 在 UCLN 模型下，随着 $\\sigma^2$ 的增加，分化时间的后验必然会变窄，因为速率异质性解决了冲突，因此总是能减少节点年龄的不确定性。\n\n选择所有适用项。", "solution": "在尝试解答之前，必须先确定问题陈述的有效性。\n\n### 第一步：提取已知条件\n-   **拓扑结构**：一个三分类单元树 `((A,B),C)`。\n-   **数据**：从根节点到每个叶节点的估计谱系距离为 `$D_A \\approx 0.12$`、`$D_B \\approx 0.11$` 和 `$D_C \\approx 0.10$` 每位点替换数。\n-   **分子钟模型**：不相关对数正态（UCLN）放松型钟。分支特异性速率 `$r_i$` 从一个对数正态分布中独立同分布（i.i.d.）地抽取。该分布的对数尺度方差为 `$\\sigma^2$`。\n-   **校准**：\n    1.  A 和 B 的分化时间：`$T_{AB} \\ge 25$` 百万年（Ma），实现为软性最小先验。\n    2.  根节点年龄：`$T_{\\text{root}} \\le 27$` Ma，实现为软性最大先验。\n-   **树先验**：具有弥散超参数的出生–死亡过程。\n-   **方法论事实**：\n    1.  期望替换数 = 时间跨度 `$\\times$` 分支速率。\n    2.  在 UCLN 模型中增加 `$\\sigma^2$` 会给予分支间更大的速率差异更大的先验权重。\n    3.  留一校准交叉验证是一种可用的技术。\n\n### 第二步：使用提取的已知条件进行验证\n该问题描述了贝叶斯分子定年中的一个标准场景。所有概念——UCLN 模型、`$\\sigma^2$`、出生-死亡先验、化石校准、谱系距离——都是现代系统发育学的基础。该问题具有科学依据且是客观的。\n\n问题的核心在于序列数据和校准先验之间可能存在的冲突。让我们来分析一下。设根节点为 `$R$`，`$(A,B)$` 的祖先节点为 `$N$`。根节点的年龄为 `$T_R = T_{\\text{root}}$`，节点 `$N$` 的年龄为 `$T_N = T_{AB}$`。\n校准施加了强先验，使得 `$T_{AB}$` 被推向 `$\\ge 25$` Ma 的值，而 `$T_{\\text{root}}$` 被推向 `$\\le 27$` Ma 的值。这使得通往 `$(A,B)$` 的干分支（stem branch）的时间跨度 `$t_{stemAB} = T_{\\text{root}} - T_{AB}$` 被限制得非常短（例如，`$\\approx 2$` Ma）。相比之下，通往 `$A$` 和 `$B$` 的末端分支具有很长的时间跨度 `$t_A = t_B = T_{AB} \\approx 25$` Ma，而通往 `$C$` 的分支的时间跨度为 `$t_C = T_{\\text{root}} \\approx 27$` Ma。\n\n序列数据包含从根节点到叶节点的距离：`$D_A \\approx 0.12$`、`$D_B \\approx 0.11$`、`$D_C \\approx 0.10$`。这些值非常相似，表明数据是“类时钟的”（clock-like）。在严格分子钟（`$\\sigma^2=0$`）下，所有从根到叶的距离必须相等（`$D_A = D_B = D_C = r \\cdot T_{\\text{root}}$`）。观测数据（`$0.12 \\neq 0.11 \\neq 0.10$`）已经违反了严格分子钟，因此需要一定程度的速率变化（`$\\sigma^2  0$`）。\n\n当与校准结合时，冲突更为严重。到叶节点 `C` 的总距离是 `$D_C = r_C \\cdot t_C \\approx r_C \\cdot 27$`。这意味着速率 `$r_C \\approx 0.10/27 \\approx 0.0037$` 替换数/位点/百万年。到叶节点 `$A$` 的总距离是 `$D_A = r_{stemAB} \\cdot t_{stemAB} + r_A \\cdot t_A \\approx r_{stemAB} \\cdot 2 + r_A \\cdot 25$`。为了将 `$D_A \\approx 0.12$` 与这些极不相等的时间跨度（`$2$` Ma 和 `$25$` Ma）调和起来，速率 `$r_{stemAB}$` 和 `$r_A$` 必须彼此之间和/或与 `$r_C$` 有显著不同。例如，短干分支上的极高速率必须由长末端分支上的极低速率来补偿，反之亦然。这种显著的速率差异只有在方差参数 `$\\sigma^2$` 很大的情况下才能被模型所容纳。\n\n这种近乎时钟样的数据与在分支间施加非时钟样时间分布的校准之间的冲突，是系统发育学中一个有效、明确且常见的问题。问题陈述没有缺陷；它准确地描述了一种需要仔细分析的情况。\n\n### 第三步：结论与行动\n问题是有效的。将推导出一个解决方案。\n\n### 推导与选项分析\n\n问题设定产生了一个冲突。校准在树上强制了一个特定的时间结构：一个非常短的内部分支（`$t_{stemAB} \\approx 2$` Ma）和非常长的末端分支（`$t_A, t_B \\approx 25$` Ma；`$t_C \\approx 27$` Ma）。然而，遗传数据显示，沿着这些时间结构迥异的路径累积的总变化几乎相等（`$D_A \\approx D_B \\approx D_C$`）。为了满足每个分支的基本方程 `距离 = 速率 * 时间`，模型必须推断出高度异质性的速率。具体来说，为了在短的干分支上累积总距离的显著部分，其速率 `$r_{stemAB}$` 需要远高于长末端分支上的速率。或者，如果 `$r_{stemAB}$` 很低，那么末端速率 `$r_A, r_B$` 必须足够高以解释总距离。在任何一种情况下，这些假定从同一对数正态分布中抽取的速率 `$r_A, r_B, r_C, r_{stemAB}$` 必须非常不同。UCLN 模型容纳这一点的唯一方法是采用一个较高的方差参数 `$\\sigma^2$` 值，该参数明确允许分支间存在较大的速率差异。\n\n**A. 在不相关对数正态（UCLN）模型下，由 `$T_{AB} \\ge 25$` Ma 和 `$T_{\\text{root}} \\le 27$` Ma 以及观测到的 `$D_A$`、`$D_B$` 和 `$D_C$` 所产生的冲突，将倾向于推高对数速率方差 `$\\sigma^2$` 的后验，因为只有显著的速率异质性才能调和长的分化前持续时间与相对较小的累积替换数。**\n该陈述准确地诊断了情况。“冲突”是指校准施加的时间结构与几乎相等的根到叶距离之间的矛盾。如上所述，这种冲突在 UCLN 框架内只能通过引入跨分支的显著速率异质性来解决。`$\\sigma^2$` 的较高后验估计是直接后果，因为该参数控制模型允许的速率变化程度。“长的分化前持续时间”的措辞略有歧义，但在上下文中正确地指出了分支持续时间的不对称性。\n**结论：正确。**\n\n**B. 留一校准交叉验证倾向于标记出一个不一致的校准：如果排除 `$A$–$B$` 校准，仅用根节点校准来拟合模型，那么 `$T_{AB}$` 的后验预测值可能会远低于 `$25$` Ma；反之，如果排除根节点校准，可能会产生一个超过 `$27$` Ma 的 `$T_{\\text{root}}$` 后验预测值，从而揭示冲突。**\n这描述了识别先验-数据冲突的标准程序。\n1.  如果我们移除 `$T_{AB} \\ge 25$` Ma 的先验，年龄 `$T_{AB}$` 将主要由序列数据和树先验（出生-死亡）来告知。像出生-死亡过程这样的树先验通常倾向于将分化事件置于较近的过去，而不是久远的过去。近乎时钟样的数据没有提供强烈的信号将 `$T_{AB}$` 放置得如此接近根节点。因此，`$T_{AB}$` 的后验很可能远小于 `$25$` Ma。\n2.  反之，如果我们移除 `$T_{\\text{root}} \\le 27$` Ma 的先验但保留 `$T_{AB} \\ge 25$` Ma，模型将由一个非常古老的 `$A-B$` 分化年龄锚定。根节点必须更古老（`$T_{\\text{root}}  T_{AB}$`）。为了解释干分支上观测到的遗传距离 `$r_{stemAB} \\cdot (T_{\\text{root}}-T_{AB})$`（必须为正），`$T_{\\text{root}}-T_{AB}$` 必须被赋予一个非零的持续时间。考虑到树中总的进化量（`$D \\approx 0.1$`）和典型的进化速率，将此距离换算为时间可能表明总的时间深度（`$T_{\\text{root}}$`）大于 `$27$` Ma。因此，`$T_{\\text{root}}$` 的后验预测值很可能会超过 `$27$` Ma。\n这两种情况都揭示了两个校准之间的强烈冲突，这正是交叉验证旨在检测的。\n**结论：正确。**\n\n**C. 解决这一冲突最合适的补救措施是为 `$\\sigma^2$` 固定一个非常大的先验，以便模型总是能容许足够的速率变化来满足所有校准；这能防止偏差并提高定年精度。**\n这个建议在科学上和统计上都是不合理的。通过固定一个参数（或使用一个非常强的先验）来强行拟合以适应冲突，是忽略潜在问题的方式，而不是补救它。膨胀的 `$\\sigma^2$` 是冲突的一个症状。虽然允许 `$\\sigma^2$` 很高会使模型收敛，但它是通过援引一个可能不切实际的极端速率波动性的生物学场景来实现的。这并不能“防止偏差”；它可能通过强制一个有问题的进化模型而引入严重偏差。此外，增加的速率异质性（高 `$\\sigma^2$`）放松了遗传距离和时间之间的联系，这会 *增加* 而不是减少定年估计的不确定性（即，加宽后验区间）。声称提高精度是错误的。\n**结论：错误。**\n\n**D. 一种可辩护的对策包括重新审视化石依据（系统发育位置和地层背景），并且，如果有必要，软化或放宽校准先验（例如，使用更宽的对数正态或偏移伽马分布）以更好地反映不确定性，这可以减少 `$\\sigma^2$` 的病态膨胀。**\n这描述了对数据-先验冲突的正确科学和统计响应。当模型显示存在冲突时，第一步是批判性地重新评估输入，特别是校准先验，因为它们是对外部证据（化石）的解释。这包括仔细审查化石在系统发育树中的位置及其地质年龄的确定性。如果重新审查表明原始先验过于严格（即太“紧”），正确的做法是使用更能代表真实不确定性的先验（例如，通过使用方差更大或边界更软的分布）。这使得模型有更大的灵活性来找到一个能更好地平衡序列数据和校准信息的解决方案，从而减轻了在其他地方援引极端参数值的需要（即 `$\\sigma^2$` 的“病态膨胀”）。\n**结论：正确。**\n\n**E. 在 UCLN 模型下，随着 `$\\sigma^2$` 的增加，分化时间的后验必然会变窄，因为速率异质性解决了冲突，因此总是能减少节点年龄的不确定性。**\n这个陈述是根本错误的。参数 `$\\sigma^2$` 量化了进化速率的不确定性。一个更大的 `$\\sigma^2$` 意味着任何给定分支上的速率更难预测。由于分化时间 `$t$` 是通过遗传距离 `$d$` 和速率 `$r$` 计算的（`$t = d/r$`），`$r$` 中更大的不确定性直接转化为 `$t$` 中更大的不确定性。因此，增加 `$\\sigma^2$` 通常会导致分化时间的后验分布更宽，而不是更窄，反映了精度的降低。声称解决冲突会减少不确定性的前提被误用了；在这里，“解决”是通过在关键模型组件（速率）中引入更多不确定性来实现的。\n**结论：错误。**", "answer": "$$\\boxed{ABD}$$", "id": "2749316"}, {"introduction": "为了真正掌握放松型分子钟，通过计算实践来观察其内部工作机制是无价的。这项编程练习[@problem_id:2749338]将指导您构建贝叶斯分析的核心部分，即寻找最大后验（MAP）估计。您将编写代码，在给定UCLN模型和校准先验的情况下，找出能最佳解释数据的速率和年龄，从而亲身体验这些复杂的数学理论如何转化为具体的进化见解。", "problem": "在一个不相关对数正态 (UCLN) 放松型分子钟模型下，考虑一个具有 $5$ 个分类单元的有根系统发育树。其目标是使用简化的分支长度观测模型和固定的拓扑结构，评估带有根节点年龄软最大界限的校准先验如何影响速率和年龄的后验众数。你编写的程序必须通过求解一个约束优化问题，为多种校准设置计算根节点年龄的后验众数（最大后验，MAP）和平均分支速率的后验众数。\n\n基本原理如下。\n\n- 替换沿分支的累积是瞬时速率与所用时间的乘积，因此期望分支长度（单位：每个位点的替换数）等于速率乘以时间。对于具有速率 $r_i$ 和持续时间 $d_i$ 的单个分支 $i$，期望长度为 $r_i d_i$。\n- 对于一个固定的拓扑结构，其中分支持续时间由节点年龄关联，观测到的分支长度 $\\{b_i\\}$ 被视为期望长度的含噪声测量。在多位点近似（中心极限定理）下，使用高斯观测模型：\n  $$b_i \\mid r_i, d_i \\sim \\mathcal{N}(r_i d_i, \\sigma^2),$$\n  其中已知方差 $\\sigma^2$ 在所有分支间共享。\n- 在不相关对数正态 (UCLN) 模型下，特定分支的速率是独立的，并服从对数正态分布：\n  $$\\log r_i \\sim \\mathcal{N}(\\mu_r, s_r^2),$$\n  对每个分支 $i$ 独立。\n- 根节点年龄 $t_R$ 有一个对数正态基础先验\n  $$\\log t_R \\sim \\mathcal{N}(\\mu_T, s_T^2),$$\n  该先验乘以一个在最大值 $M$ 处的软最大界限惩罚\n  $$w(t_R; M, k) = \\exp\\!\\big(-k \\cdot \\max(0, t_R - M)\\big),$$\n  其中 $k$ 控制软界限的强度。其他内部节点的年龄在由树序约束定义的可行域上具有弥散均匀先验。\n\n树的拓扑结构和参数化。\n\n- 有根二分拓扑结构为 $((A,B),(C,(D,E)))$，根节点为 $R$，内部节点为 $X=\\mathrm{MRCA}(A,B)$、$Y=\\mathrm{MRCA}(D,E)$ 和 $Z=\\mathrm{MRCA}(C,Y)$。\n- 设节点 $R$、$X$、$Z$ 和 $Y$ 的内部节点年龄分别为 $t_R$、$t_{AB}$、$t_{CDE}$ 和 $t_{DE}$。叶尖年龄为 $0$。约束条件为\n  $$t_R \\ge t_{AB} \\ge 0,\\quad t_R \\ge t_{CDE} \\ge t_{DE} \\ge 0.$$\n- $8$ 个分支及其持续时间为：\n  - 分支 1：$R \\to X$，持续时间 $d_1 = t_R - t_{AB}$。\n  - 分支 2：$R \\to Z$，持续时间 $d_2 = t_R - t_{CDE}$。\n  - 分支 3：$X \\to A$，持续时间 $d_3 = t_{AB} - 0$。\n  - 分支 4：$X \\to B$，持续时间 $d_4 = t_{AB} - 0$。\n  - 分支 5：$Z \\to C$，持续时间 $d_5 = t_{CDE} - 0$。\n  - 分支 6：$Z \\to Y$，持续时间 $d_6 = t_{CDE} - t_{DE}$。\n  - 分支 7：$Y \\to D$，持续时间 $d_7 = t_{DE} - 0$。\n  - 分支 8：$Y \\to E$，持续时间 $d_8 = t_{DE} - 0$。\n\n数据和超参数。\n\n- 观测到的分支长度（单位：每个位点的替换数）固定为\n  $$\\mathbf{b} = (b_1,\\dots,b_8) = (0.0044,\\, 0.0019,\\, 0.0063,\\, 0.0060,\\, 0.0096,\\, 0.0045,\\, 0.0030,\\, 0.00255).$$\n- 观测噪声标准差为 $\\sigma = 0.0002$（因此方差 $\\sigma^2 = 4\\times 10^{-8}$）。\n- UCLN 速率先验参数为 $\\mu_r = \\log(0.01)$ 和 $s_r = 0.25$。\n- 根节点年龄的基础对数正态先验参数为 $\\mu_T = \\log(1.0) = 0$ 和 $s_T = 0.5$。\n\n后验和优化。\n\n- 设 $\\mathbf{r} = (r_1,\\dots,r_8)$ 且 $\\mathbf{t} = (t_R,t_{AB},t_{CDE},t_{DE})$。后验密度（在忽略不依赖于变量的归一化常数的情况下）为\n  $$p(\\mathbf{r}, \\mathbf{t} \\mid \\mathbf{b}) \\propto \\left[\\prod_{i=1}^8 \\exp\\!\\left(-\\frac{(b_i - r_i d_i)^2}{2 \\sigma^2}\\right)\\right] \\cdot \\left[\\prod_{i=1}^8 \\frac{1}{r_i} \\exp\\!\\left(-\\frac{(\\log r_i - \\mu_r)^2}{2 s_r^2}\\right)\\right] \\cdot \\frac{1}{t_R}\\exp\\!\\left(-\\frac{(\\log t_R - \\mu_T)^2}{2 s_T^2}\\right)\\cdot w(t_R;M,k),$$\n  受限于 $\\mathbf{t}$ 的树序约束和 $\\mathbf{r}$ 的正性。你的程序应通过最小化负对数后验，为每个校准设置 $(M,k)$ 计算联合 MAP $(\\mathbf{r}^\\star, \\mathbf{t}^\\star)$。\n- 要最小化的负对数后验（去除不依赖于参数的加法常数）为\n  $$\\mathcal{L}(\\mathbf{r}, \\mathbf{t}) = \\sum_{i=1}^8 \\frac{(b_i - r_i d_i)^2}{2 \\sigma^2} + \\sum_{i=1}^8 \\left[\\frac{(\\log r_i - \\mu_r)^2}{2 s_r^2} + \\log r_i\\right] + \\left[\\frac{(\\log t_R - \\mu_T)^2}{2 s_T^2} + \\log t_R\\right] + k \\cdot \\max(0, t_R - M),$$\n  约束条件为 $t_R \\ge t_{AB} \\ge 0$、$t_R \\ge t_{CDE} \\ge t_{DE} \\ge 0$ 以及对所有 $i$ 都有 $r_i  0$。\n\n任务。\n\n- 实现一个约束优化，以获取测试套件中每个校准对 $(M,k)$ 的联合 MAP。\n- 对每个 MAP 解，提取：\n  - 根节点年龄的后验众数 $t_R^\\star$（单位：时间单位），以及\n  - 平均分支速率的后验众数 $\\bar{r}^\\star = \\frac{1}{8}\\sum_{i=1}^8 r_i^\\star$（单位：每个位点每个时间单位的替换数）。\n- 使用以下校准设置测试套件：\n  - 案例 1（松散界限）：$M = 2.0$，$k = 0.1$。\n  - 案例 2（中等界限）：$M = 1.0$，$k = 5.0$。\n  - 案例 3（非常紧的界限）：$M = 0.7$，$k = 20.0$。\n\n科学真实性要求。\n\n- 解应遵守所有关于节点年龄的约束，以保持分支持续时间为非负。\n- 所有年龄必须以时间单位报告，所有速率必须以每个位点每个时间单位的替换数报告。\n- 不涉及角度。\n- 将任何比率或比例表示为十进制数。\n\n最终输出规范。\n\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 对于上述顺序中的每个测试用例 $i$，首先输出 $t_R^\\star$（单位：时间单位），然后输出 $\\bar{r}^\\star$（单位：每个位点每个时间单位的替换数）。\n- 在打印前将每个数值四舍五入到六位小数。\n- 因此，最终输出必须按此顺序包含 $2 \\times 3 = 6$ 个浮点数：$[t_{R,1}^\\star, \\bar{r}_1^\\star, t_{R,2}^\\star, \\bar{r}_2^\\star, t_{R,3}^\\star, \\bar{r}_3^\\star]$。", "solution": "我们从一个基本关系开始：沿一个分支累积的每个位点的期望替换数等于瞬时替换速率与该分支所用时间的乘积。用 $r_i$ 表示分支 $i$ 上的速率，用 $d_i$ 表示分支 $i$ 的持续时间（时间长度）。那么期望分支长度为 $r_i d_i$。我们假设从序列数据比对中测得的分支长度 $b_i$ 在期望值附近近似呈高斯分布，且所有分支共享方差 $\\sigma^2$：$b_i \\mid r_i, d_i \\sim \\mathcal{N}(r_i d_i, \\sigma^2)$。这种高斯近似可以通过中心极限定理来证明，该定理应用于标准替换模型下的多个位点，从而为分支长度产生近似正态的估计误差。\n\n在不相关对数正态 (UCLN) 放松型钟模型下，特定分支的速率是独立的，且 $\\log r_i \\sim \\mathcal{N}(\\mu_r, s_r^2)$。这个先验捕捉了分支间的速率异质性，同时围绕由 $\\mu_r$ 设定的基准速率尺度为中心。对于时间，我们为根节点年龄 $t_R$ 设置一个基础对数正态先验，$\\log t_R \\sim \\mathcal{N}(\\mu_T, s_T^2)$，这反映了其正支撑域和乘性可变性。为了在 $M$ 处建立一个软最大界限模型，我们将基础先验乘以一个惩罚因子 $w(t_R; M, k) = \\exp\\big(-k \\max(0, t_R - M)\\big)$；当 $t_R \\le M$ 时，惩罚因子等于 $1$，而当 $t_R  M$ 时，先验密度以速率 $k$ 近似指数衰减。其余内部节点的年龄在由树序约束定义的可行集上服从弥散均匀先验。这些约束确保所有分支持续时间为非负：$t_R \\ge t_{AB} \\ge 0$ 和 $t_R \\ge t_{CDE} \\ge t_{DE} \\ge 0$。\n\n通过贝叶斯定理结合似然和先验，可以得到一个与其乘积成正比的后验密度。去除不涉及参数的归一化常数后，为联合 MAP 估计量要最小化的负对数后验是\n$$\n\\mathcal{L}(\\mathbf{r}, \\mathbf{t})\n=\n\\sum_{i=1}^8 \\frac{(b_i - r_i d_i)^2}{2 \\sigma^2}\n+ \\sum_{i=1}^8 \\left[\\frac{(\\log r_i - \\mu_r)^2}{2 s_r^2} + \\log r_i\\right]\n+ \\left[\\frac{(\\log t_R - \\mu_T)^2}{2 s_T^2} + \\log t_R\\right]\n+ k \\cdot \\max(0, t_R - M),\n$$\n受限于对所有 $i$ 都有 $r_i  0$ 以及上述年龄约束。第一项压缩了观测值 $b_i$ 和期望值 $r_i d_i$ 之间的预测误差。第二项实现了 UCLN 先验，包含 $\\log r_i$ 的二次惩罚和雅可比项 $\\log r_i$。第三项是关于 $t_R$ 的基础对数正态先验及其雅可比项 $\\log t_R$。最后一项是软界限惩罚，当 $t_R$ 超过 $M$ 时激活，并由 $k$ 缩放。\n\n持续时间 $d_i$ 是节点年龄 $\\mathbf{t} = (t_R, t_{AB}, t_{CDE}, t_{DE})$ 的线性函数：\n- $d_1 = t_R - t_{AB}$，\n- $d_2 = t_R - t_{CDE}$，\n- $d_3 = t_{AB}$，\n- $d_4 = t_{AB}$，\n- $d_5 = t_{CDE}$，\n- $d_6 = t_{CDE} - t_{DE}$，\n- $d_7 = t_{DE}$，\n- $d_8 = t_{DE}$。\n\n算法设计如下。\n\n- 参数化和约束：我们对向量 $(\\log r_1,\\dots,\\log r_8, t_R, t_{AB}, t_{CDE}, t_{DE})$ 进行优化，通过对数参数化使用显式界限 $r_i  0$，并使用线性不等式约束来强制执行祖先年龄排序，即 $t_R - t_{AB} \\ge \\epsilon$、$t_R - t_{CDE} \\ge \\epsilon$、$t_{CDE} - t_{DE} \\ge \\epsilon$、$t_{AB} \\ge \\epsilon$、$t_{DE} \\ge \\epsilon$，其中 $\\epsilon  0$ 是一个小数，用以保持持续时间的严格正性。附加的箱式界限将年龄保持在合理的搜索域内。\n- 目标函数评估：对于给定的参数，计算持续时间 $d_i$、速率 $r_i = \\exp(\\log r_i)$ 和具有固定 $\\sigma^2$ 的高斯残差平方和项，然后加上 UCLN 和基础对数正态惩罚，以及软最大值惩罚 $k \\max(0, t_R - M)$。如果任何持续时间为非正数，则施加一个大的惩罚以强制可行性。\n- 数值优化：使用约束非线性优化来最小化 $\\mathcal{L}$。诸如序列最小二乘规划 (SLSQP) 之类的方法可以处理带有线性不等式约束和箱式界限的平滑目标函数。软界限项在 $t_R = M$ 处是连续但非光滑的，SLSQP 在实践中可以容忍这种情况。\n- 初始化：从基准速率和一个合理的年龄配置附近开始：对所有 $i$ 有 $\\log r_i \\approx \\log(0.01)$，$t_R \\approx 1.0$，$t_{AB} \\approx 0.6$，$t_{CDE} \\approx 0.8$，$t_{DE} \\approx 0.3$。\n- 输出：在优化器的解 $(\\mathbf{r}^\\star, \\mathbf{t}^\\star)$ 处，计算 $t_R^\\star$ 和 $\\bar{r}^\\star = \\frac{1}{8}\\sum_{i=1}^8 r_i^\\star$。将每个值四舍五入到六位小数。\n\n测试套件案例的解释：\n\n- 案例 1 中 $M=2.0$ 且 $k=0.1$，对 $t_R$ 施加了一个弱的、松散的上限，因此似然和 UCLN 先验主要决定 $t_R^\\star$ 和 $\\bar{r}^\\star$。\n- 案例 2 中 $M=1.0$ 且 $k=5.0$，将 $t_R$ 锚定在 1.0 时间单位附近，如果仅靠似然会偏好更大的值，则该设置会将 MAP 根年龄向下拉，并相应地向上或向下调整 $\\bar{r}^\\star$ 以使 $r_i d_i$ 与观测到的 $b_i$ 一致。\n- 案例 3 中 $M=0.7$ 且 $k=20.0$，施加了一个非常紧的软最大值；优化器必须将 $t_R^\\star$ 压缩到 0.7 以下或附近，从而提高速率以维持 $r_i d_i \\approx b_i$。因此，我们预期相对于更松散的案例，$t_R^\\star$ 会减小，而 $\\bar{r}^\\star$ 会增大。\n\n程序为每个 $(M,k)$ 对实现此约束 MAP 估计，并按指定顺序打印包含六个四舍五入值的单行列表。年龄以时间单位报告，速率以每个位点每个时间单位的替换数报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize, NonlinearConstraint, Bounds\n\ndef solve():\n    # Data: observed branch lengths (substitutions per site)\n    b = np.array([0.0044, 0.0019, 0.0063, 0.0060, 0.0096, 0.0045, 0.0030, 0.00255], dtype=float)\n    sigma = 0.0002  # observation noise std\n\n    # UCLN prior hyperparameters\n    mu_r = np.log(0.01)\n    s_r = 0.25\n\n    # Root age base lognormal prior parameters\n    mu_T = 0.0  # log(1.0)\n    s_T = 0.5\n\n    # Tree structure: durations from node ages\n    def durations(t):\n        tR, tAB, tCDE, tDE = t\n        d = np.empty(8, dtype=float)\n        d[0] = tR - tAB       # R-X\n        d[1] = tR - tCDE      # R-Z\n        d[2] = tAB            # X-A\n        d[3] = tAB            # X-B\n        d[4] = tCDE           # Z-C\n        d[5] = tCDE - tDE     # Z-Y\n        d[6] = tDE            # Y-D\n        d[7] = tDE            # Y-E\n        return d\n\n    # Soft penalty term for root age: k * max(0, tR - M)\n    def soft_penalty(tR, M, k):\n        excess = tR - M\n        return k * excess if excess  0.0 else 0.0\n\n    # Negative log posterior (up to additive constant)\n    def neg_log_posterior(x, M, k):\n        # x = [log r_1..log r_8, tR, tAB, tCDE, tDE]\n        y = x[:8]\n        t = x[8:]\n        tR, tAB, tCDE, tDE = t\n        # Enforce basic positivity inside objective to avoid invalid logs\n        if tR = 0 or tAB = 0 or tCDE = 0 or tDE = 0:\n            return 1e20\n        d = durations(t)\n        # If any duration is non-positive, penalize heavily (constraints should prevent this)\n        if np.any(d = 0):\n            return 1e20\n        r = np.exp(y)\n        # Likelihood term\n        resid = b - r * d\n        ll_term = 0.5 * np.sum((resid / sigma) ** 2)\n        # UCLN prior on rates: sum_i [ (y_i - mu_r)^2/(2 s_r^2) + y_i ]\n        prior_rates = np.sum(((y - mu_r) ** 2) / (2.0 * s_r ** 2) + y)\n        # Root age base lognormal prior: [(log tR - mu_T)^2/(2 s_T^2) + log tR]\n        prior_root = ((np.log(tR) - mu_T) ** 2) / (2.0 * s_T ** 2) + np.log(tR)\n        # Soft maximum penalty\n        soft = soft_penalty(tR, M, k)\n        return ll_term + prior_rates + prior_root + soft\n\n    # Constraints: enforce tree-order and positivity of durations\n    eps = 1e-6\n    def cons_fun(x):\n        tR, tAB, tCDE, tDE = x[8], x[9], x[10], x[11]\n        # c = 0\n        return np.array([\n            tR - tAB - eps,\n            tR - tCDE - eps,\n            tCDE - tDE - eps,\n            tAB - eps,\n            tDE - eps\n        ], dtype=float)\n\n    nonlin_con = NonlinearConstraint(cons_fun, lb=0.0, ub=np.inf)\n\n    # Bounds: for log rates and ages\n    y_lower = np.full(8, np.log(1e-5))\n    y_upper = np.full(8, np.log(1.0))  # upper rate bound 1 subs/site/time unit\n    # Ages between tiny positive and 5.0 time units\n    t_lower = np.array([1e-6, 1e-6, 1e-6, 1e-6], dtype=float)\n    t_upper = np.array([5.0, 5.0, 5.0, 5.0], dtype=float)\n    lower_bounds = np.concatenate([y_lower, t_lower])\n    upper_bounds = np.concatenate([y_upper, t_upper])\n    bounds = Bounds(lower_bounds, upper_bounds)\n\n    # Initial guess: log rates near baseline, ages plausible\n    y0 = np.full(8, mu_r)\n    t0 = np.array([1.0, 0.6, 0.8, 0.3], dtype=float)\n    x0 = np.concatenate([y0, t0])\n\n    # Test suite: (M, k) pairs\n    test_cases = [\n        (2.0, 0.1),  # loose\n        (1.0, 5.0),  # moderate\n        (0.7, 20.0)  # very tight\n    ]\n\n    results = []\n    for M, k in test_cases:\n        obj = lambda x: neg_log_posterior(x, M, k)\n        res = minimize(\n            obj,\n            x0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=[nonlin_con],\n            options={'maxiter': 2000, 'ftol': 1e-12, 'disp': False}\n        )\n        # If not successful, try a different method or perturb initial guess\n        if not res.success:\n            # Slight perturbation and retry\n            x0_perturb = x0.copy()\n            x0_perturb[:8] += np.random.default_rng(42).normal(scale=0.05, size=8)\n            x0_perturb[8:] += np.array([0.05, -0.05, 0.0, 0.0])\n            res = minimize(\n                obj,\n                x0_perturb,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[nonlin_con],\n                options={'maxiter': 3000, 'ftol': 1e-12, 'disp': False}\n            )\n\n        x_star = res.x\n        y_star = x_star[:8]\n        t_star = x_star[8:]\n        r_star = np.exp(y_star)\n        tR_star = t_star[0]\n        rbar_star = float(np.mean(r_star))\n\n        # Round to six decimals\n        tR_rounded = float(f\"{tR_star:.6f}\")\n        rbar_rounded = float(f\"{rbar_star:.6f}\")\n        results.append(tR_rounded)\n        results.append(rbar_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda v: f'{v:.6f}', results))}]\")\n\nsolve()\n```", "id": "2749338"}]}