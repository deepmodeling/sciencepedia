{"hands_on_practices": [{"introduction": "研究距离隔离（Isolation by Distance, IBD）的第一步，是统计检验遗传距离与地理距离之间是否存在正相关关系。由于成对数据的非独立性，曼特尔检验（Mantel test）是完成此任务的标准工具。本练习将检验你解读曼特尔检验关键输出（相关系数 $r$ 和 p 值）并对空间遗传结构得出有效结论的能力 [@problem_id:1942014]。", "problem": "一个种群遗传学家团队正在研究一种分布在一个小群岛上的岛屿壁虎，*Gekko insularis*。他们假设种群间的基因流受到海洋的限制，这种模式被称为距离隔离（Isolation by Distance, IBD），即地理上相距较远的种群在遗传上也更具差异。为了检验这一假设，研究人员从几个不同种群的个体中收集了组织样本。他们使用一组中性遗传标记计算了成对的遗传距离，并测量了岛屿之间以公里为单位的直线地理距离。然后，他们进行了一次Mantel检验，以评估遗传距离矩阵和地理距离矩阵之间的相关性。该检验得出的相关系数为 $r = 0.60$，p值为 $p = 0.002$。\n\n根据这些统计结果，以下哪个结论最准确？\n\nA. 该种群是泛交的，意味着个体在整个群岛范围内随机交配，不存在显著的种群结构。\n\nB. 结果证明，岛屿间的地理距离是观测到的遗传差异的直接且唯一的原因。\n\nC. 遗传距离和地理距离之间存在统计上显著的正相关关系，这与距离隔离的假说相符。\n\nD. p值为 $0.002$ 表明，遗传距离和地理距离之间的相关性由随机机会产生的概率为0.2%。\n\nE. 种群间遗传距离变异的60%可由它们之间的地理距离解释。", "solution": "我们得到了一个比较遗传距离矩阵和地理距离矩阵的Mantel检验的输出结果：相关系数 $r = 0.60$ 和p值 $p = 0.002$。Mantel检验评估的是零假设 $H_{0}$，即两个距离矩阵之间没有关联。通常通过置换来评估，以获得在 $H_{0}$ 成立的条件下，得到一个与观测到的 $r$ 一样极端或更极端的相关性的概率 $p$。\n\n步骤1：解释相关系数。\n- 统计量 $r = 0.60$ 表示遗传距离和地理距离之间存在一个中等到强度的正相关。这表明，在样本中，地理上相距较远的种群对在遗传上也倾向于更具差异。\n\n步骤2：解释与 $H_{0}$ 相关的p值。\n- p值 $p = 0.002$ 是在 $H_{0}$（矩阵间无关联）成立的条件下，通过随机置换得到一个至少与 $r = 0.60$ 一样极端的相关性的概率。由于 $0.002$ 小于常见的显著性水平（例如 $\\alpha = 0.05$），我们拒绝 $H_{0}$，并得出结论，观测到的正相关关系在统计上是显著的。\n\n步骤3：根据正确的统计解释评估每个选项。\n- 选项A声称存在泛交（在整个群岛范围内随机交配）且无种群结构。一个显著的正Mantel相关性与此相矛盾；距离隔离意味着存在结构，而非泛交。因此A是错误的。\n- 选项B断言地理距离是唯一原因。Mantel检验建立的是关联性，而不是因果关系；未测量的协变量或空间自相关也可能起作用。因此B是错误的。\n- 选项C指出，遗传距离和地理距离之间存在统计上显著的正相关关系，这与距离隔离的假说相符。这与对 $r = 0.60$ 和 $p = 0.002$ 的解释相匹配。因此C是正确的。\n- 选项D将p值解释为观测到的相关性由随机机会产生的概率。严格来说，p值是 $\\Pr(\\text{数据与观测值一样极端或更极端} \\mid H_{0})$，而不是 $\\Pr(H_{0} \\mid \\text{数据})$。声称p值是观测到的相关性“由随机机会产生”的概率，是将这两者混为一谈，是一种常见但错误的解释。因此D是错误的。\n- 选项E断言，种群间遗传距离变异的60%是由地理距离解释的。即使在标准的皮尔逊相关中，方差解释的比例也应为 $r^{2} = 0.36$，而不是 $0.60$。此外，对于基于距离矩阵的Mantel相关，将 $r^{2}$ 解释为方差解释比例是不合适的。因此E是错误的。\n\n结论：唯一准确的陈述是，遗传距离和地理距离之间存在与距离隔离假说相符的、统计上显著的正相关关系。", "answer": "$$\\boxed{C}$$", "id": "1942014"}, {"introduction": "一个显著的距离隔离模式不仅仅是统计上的相关性，它还包含了关于潜在微观演化过程的定量信息。根据 Wright 和 Malécot 的理论工作，遗传距离与地理距离之间关系的斜率与邻域大小（neighborhood size）直接相关，并因此与扩散规模（dispersal scale）相关。本问题挑战你推导这一关系，并用它来估算扩散标准差（dispersal standard deviation, $\\sigma$），这是生态学和演化中的一个关键参数 [@problem_id:2727650]。", "problem": "一个连续的随机交配成体种群，在一个大型二维栖息地中处于漂变-迁移平衡状态，这符合 Wright–Malécot 的因距离隔离框架。设成体密度为 $D$（成体/平方公里），亲子散布为二元正态分布，其径向标准差为 $\\sigma$（公里/代）。邻域大小定义为 $N_{b} = 4 \\pi D \\sigma^{2}$。根据经验，您计算了一个标准化的成对遗传距离，对于个体间距离 $r$，该遗传距离与 $\\ln(r)$ 呈渐近线性关系，并对该标准化距离与 $\\ln(r)$ 进行普通最小二乘回归拟合，得到估计斜率 $\\hat{b}$。根据经典的二维因距离隔离理论，在大型栖息地和局部谱系结构不占主导地位的距离下，该斜率与邻域大小成反比。\n\n从邻域大小的定义和上述渐近二维因距离隔离关系出发（不使用任何额外的捷径），推导出一个以 $D$ 和 $\\hat{b}$ 表示的闭式估计量 $\\hat{\\sigma}$。然后，使用 $D = 12$ 成体/平方公里和 $\\hat{b} = 0.0085$，计算 $\\hat{\\sigma}$ 的数值。\n\n将最终数值答案以公里/代为单位表示，并四舍五入至四位有效数字。最终答案必须是一个数字。", "solution": "问题陈述经核实具有科学依据、提法恰当且客观。这是一个基于 Wright–Malécot 因距离隔离（IBD）理论的群体遗传学标准问题。我们将进行推导和计算。\n\n该问题要求从遗传距离对地理距离对数的回归估计斜率中，推导出亲子散布标准差的估计量 $\\hat{\\sigma}$。基本原理已在问题陈述中给出。\n\n首先，问题陈述指出，对于一个处于漂变-迁移平衡的大型二维栖息地，特定的标准化成对遗传距离对个体间分离距离的自然对数 $\\ln(r)$ 的回归斜率，与邻域大小 $N_b$ 成反比。在经典的 Wright–Malécot 二维连续体理论中，此关系精确为：\n$$ b = \\frac{1}{N_{b}} $$\n其中 $b$ 是理论斜率。问题提供了一个通过普通最小二乘回归得到的经验估计斜率 $\\hat{b}$。我们使用此估计值，通过反转该关系来构建邻域大小的估计量 $\\hat{N}_b$：\n$$ \\hat{N}_{b} = \\frac{1}{\\hat{b}} $$\n\n其次，问题给出了邻域大小 $N_b$ 的定义，其由成体种群密度 $D$ 和亲子散布的径向标准差 $\\sigma$ 表示：\n$$ N_{b} = 4 \\pi D \\sigma^{2} $$\n该定义对应于面积为 $4 \\pi \\sigma^{2}$（半径为 $2 \\sigma$）的圆内的个体数量。\n\n为了推导 $\\sigma$ 的估计量，我们将邻域大小的两个表达式相等。我们用估计量 $\\hat{N}_b$ 代替 $N_b$，用估计量 $\\hat{\\sigma}$ 代替 $\\sigma$：\n$$ \\hat{N}_{b} = 4 \\pi D \\hat{\\sigma}^{2} $$\n现在，我们将以 $\\hat{b}$ 表示的 $\\hat{N}_b$ 的表达式代入：\n$$ \\frac{1}{\\hat{b}} = 4 \\pi D \\hat{\\sigma}^{2} $$\n我们的目标是找到 $\\hat{\\sigma}$ 的闭式表达式。我们重新整理方程以分离出 $\\hat{\\sigma}^{2}$：\n$$ \\hat{\\sigma}^{2} = \\frac{1}{4 \\pi D \\hat{b}} $$\n对两边取平方根，得到径向散布标准差的估计量：\n$$ \\hat{\\sigma} = \\sqrt{\\frac{1}{4 \\pi D \\hat{b}}} = \\frac{1}{\\sqrt{4 \\pi D \\hat{b}}} $$\n这就是所要求的以 $D$ 和 $\\hat{b}$ 表示的 $\\sigma$ 的闭式估计量。\n\n接下来，我们必须使用所提供的数据计算 $\\hat{\\sigma}$ 的数值：\n- 成体密度，$D = 12$ 成体/平方公里。\n- 估计斜率，$\\hat{b} = 0.0085$。\n\n将这些值代入我们推导出的估计量中：\n$$ \\hat{\\sigma} = \\frac{1}{\\sqrt{4 \\pi (12) (0.0085)}} $$\n我们计算平方根内的项：\n$$ 4 \\times \\pi \\times 12 \\times 0.0085 = 48 \\times 0.0085 \\times \\pi = 0.408 \\pi $$\n使用更精确的 $\\pi$ 值，$\\pi \\approx 3.14159265$：\n$$ 0.408 \\times 3.14159265 \\approx 1.2817698 $$\n现在我们计算 $\\hat{\\sigma}$：\n$$ \\hat{\\sigma} \\approx \\frac{1}{\\sqrt{1.2817698}} \\approx \\frac{1}{1.1321527} \\approx 0.8832745 \\text{ km} $$\n$D$ 的单位是 成体/平方公里，因此 $\\hat{\\sigma}$ 的结果单位是公里。此散布距离的时间范围是每代，正如对 $\\sigma$ 的规定。\n\n问题要求最终答案四舍五入至四位有效数字。\n$$ \\hat{\\sigma} \\approx 0.8833 \\text{ km} $$\n这就是估计的径向散布标准差的最终数值。", "answer": "$$\n\\boxed{0.8833}\n$$", "id": "2727650"}, {"introduction": "真实世界的空间遗传模式并非总是简单的线性梯度，距离隔离也并非是构建种群结构的唯一过程。我们常常必须判断，一个连续的 IBD 模型还是一个离散的种群聚类模型能更好地解释数据。这个高级实践将指导你实现一个交叉验证（cross-validation）框架——一种稳健的模型选择方法，从而基于预测能力来定量地比较这些相互竞争的假说 [@problem_id:2727647]。", "problem": "您将获得三个小型合成数据集，其中包含带标签的个体、它们的二维地理坐标，以及一个观测到的成对遗传距离对称矩阵，其对角线为零。您的任务是实现一个确定性的交叉验证模型选择程序，该程序仅根据样本外成對遗传距离的预测准确性，在离散双聚类模型和连续的距离隔离 (IBD) 线性模型之间进行选择。\n\n从以下基本原理开始：\n\n- 有限的扩散和遗传漂变会产生一种空间模式，即在距离隔离 (IBD) 下，预期的遗传距离往往随着地理距离的增加而增加。在其最简单的线性化形式中，在均匀的景观中，两个个体之间的预期遗传距离大致随其地理距离线性增加。\n- 离散的种群结构会在遗传距离中产生阶梯状模式，聚类内部的距离较小，聚类之间的距离较大。\n- 预测模型选择应依赖于通过交叉验证估计的样本外误差，以避免过拟合并反映泛化能力。\n\n您必须实现并比较以下两个模型：\n\n- 连续IBD线性模型：对于每对无序个体 $(i,j)$，预测的遗传距離为 $\\hat{D}_{ij} = \\hat{\\alpha} + \\hat{\\beta} \\cdot \\Delta_{ij}$，其中 $\\Delta_{ij}$ 是根据个体 $i$ 和 $j$ 的坐标计算出的欧氏地理距离，而 $(\\hat{\\alpha}, \\hat{\\beta})$ 仅通过对训练对进行普通最小二乘法获得。\n\n- 离散双聚类模型：每个个体 $i$ 被分配一个聚类标签 $c_i \\in \\{0,1\\}$，并有约束条件 $c_0 = 0$ 以消除标签对称性，且两个聚类都必须非空。对于一个固定的分配 $c$，如果 $c_i = c_j$，模型预测 $\\hat{D}_{ij} = \\hat{w}$；如果 $c_i \\neq c_j$，模型预测 $\\hat{D}_{ij} = \\hat{b}$。其中 $(\\hat{w}, \\hat{b})$ 是该分配下，落入相应类别（聚类内和聚类间）的训练对的观测距离的均值。为了拟合模型，需要搜索所有有效的分配，并选择使训练均方误差最小化的分配，然后使用在该最佳分配下从训练集估计出的 $\\hat{w}$ 和 $\\hat{b}$ 来计算验证集的预测值。\n\n定义 $N$ 个带标签的个体 $\\{0,1,\\dots,N-1\\}$。您将对三个独立的数据集执行模型选择，每个数据集都给定个体数量 $N$、交叉验证折数 $F$ 和一个种子 $s$。\n\n您的任务是实现一个 $F$-折交叉验证程序。使用以下确定性函数将每对唯一的无序个体 $(i, j)$（其中 $i<j$）分配到一个折叠中：\n$$ \\text{fold\\_idx}(i,j) = \\big((i \\cdot N + j) + s\\big) \\bmod F $$\n对于每个折 $f \\in \\{0, \\dots, F-1\\}$，将折 $f$ 中的所有对作为验证集，其余所有对作为训练集。在训练集上拟合每个模型，然后在验证集上计算其均方误差 (MSE)。一个模型的总交叉验证误差是其在所有 $F$ 个折上的平均 MSE。\n\n如果 IBD 模型的交叉验证 MSE 小于或等于聚类模型的 MSE (即 $\\mathrm{CV\\_MSE}_{\\text{IBD}} \\le \\mathrm{CV\\_MSE}_{\\text{cluster}}$)，则选择 IBD 模型。否则，选择聚类模型。您的输出应该是一个包含三个整数的列表，其中每个整数代表相应数据集的模型选择结果：IBD 模型为1，聚类模型为0。", "solution": "该问题要求实现一个确定性的交叉验证程序，以在一组个体中描述地理距离和遗传距离之间关系的两个竞争模型之间进行选择。这两个模型是连续的距离隔离（IBD）线性模型和离散的双聚类模型。选择基于样本外预测准确性，通过均方误差（MSE）进行量化。\n\n该程序实现如下。对于每个数据集，由个体数量 $N$、交叉验证折数 $F$、一个种子 $s$、一组地理坐标 $\\{ (x_i, y_i) \\}_{i=0}^{N-1}$ 和一个成对遗传距离矩阵 $D=[D_{ij}]$ 定义，我们首先处理所有唯一的无序个体对 $(i, j)$，其中 $i < j$。对于每对个体，计算其欧氏地理距离 $\\Delta_{ij}$。然后使用给定公式 $\\phi(i,j) = \\big((i \\cdot N + j) + s\\big) \\bmod F$ 将每对个体确定性地分配到一个折叠索引 $f \\in \\{0, 1, \\dots, F-1\\}$。\n\n交叉验证通过遍历每个折 $f$ 来进行。所有对的集合被划分为一个训练集和一个验证集 $H_f$。训练集包含所有满足 $\\phi(i,j) \\neq f$ 的对 $(i,j)$，验证集包含所有满足 $\\phi(i,j) = f$ 的对。对于每个折，两个模型都在训练集上进行拟合，并在验证集上评估其预测性能。\n\n第一个模型是连续IBD线性模型，由方程 $\\hat{D}_{ij} = \\hat{\\alpha} + \\hat{\\beta} \\cdot \\Delta_{ij}$ 描述。对于每个训练集，使用普通最小二乘法（OLS）估计参数 $(\\hat{\\alpha}, \\hat{\\beta})$。这在计算上是通过从训练对的地理距离构建一个设计矩阵并求解得到的线性系统来实现的，`numpy.linalg.lstsq`为此提供了一个稳健的解决方案。该函数找到系数 $(\\hat{\\alpha}, \\hat{\\beta})$，使训练对上的残差平方和 $\\sum (D_{ij} - \\hat{D}_{ij})^2$ 最小化。然后，使用拟合好的模型来预测验证集 $H_f$ 中各对的遗传距离。该折的均方误差 $\\mathrm{MSE}_f^{\\text{IBD}}$ 计算为 $\\frac{1}{|H_f|}\\sum_{(i,j)\\in H_f}\\big(D_{ij} - \\hat{D}_{ij}\\big)^2$。\n\n第二个模型是离散双聚类模型。其在每个折内的拟合过程更为复杂。它需要详尽搜索将 $N$ 个个体划分为两个非空聚类的最优分区。为确保唯一性并满足问题约束，我们强制规定个体0始终在聚类0中（$c_0=0$），并且两个聚类都非空。这相当于测试所有 $2^{N-1}-1$ 种将剩余 $N-1$ 个个体分配到两个聚类之一的方法，使得至少有一个个体被分配到聚类1。对于这些候选聚类分配中的每一个，模型参数 $(\\hat{w}, \\hat{b})$ 都是从训练数据中估计出来的。$\\hat{w}$ 是训练对中个体 $i$ 和 $j$ 处于同一聚类时的遗传距离 $D_{ij}$ 的均值，而 $\\hat{b}$ 是它们处于不同聚类时的均值。然后计算此分配的训练MSE。导致最小训练MSE的聚类分配被选为当前折的最优分配，并保留其相应的参数，记为 $(\\hat{w}_f, \\hat{b}_f)$。然后使用这些参数来预测验证对的距离：如果个体 $i$ 和 $j$ 在最优分配下属于同一聚类，则验证对 $(i,j)$ 的预测值为 $\\hat{w}_f$，否则为 $\\hat{b}_f$。然后计算该折的验证MSE，$\\mathrm{MSE}_f^{\\text{cluster}}$。在特殊情况下，如果给定分配的训练集缺少某种类型的对（例如，没有聚类内对），则使用训练集中所有遗传距离的平均值作为相应参数的稳健估计。\n\n在遍历所有 $F$ 个折之后，每个模型的总体交叉验证误差计算为其特定折MSE的平均值：$\\mathrm{CV\\_MSE} = \\frac{1}{F} \\sum_{f=0}^{F-1} \\mathrm{MSE}_f$。\n\n最终的模型选择基于这些交叉验证误差。如果IBD线性模型的误差小于或等于聚类模型的误差（考虑到容差 $\\varepsilon = 10^{-9}$），则优先选择IBD线性模型。也就是说，如果 $\\mathrm{CV\\_MSE}_{\\text{IBD}} - \\mathrm{CV\\_MSE}_{\\text{cluster}} \\le \\varepsilon$，则数据集的输出为 $1$。否则，优先选择离散双聚类模型，输出为 $0$。将此完整程序应用于提供的三个数据集中的每一个，以生成最终的结果列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a deterministic cross-validation model selection procedure to choose\n    between a continuous IBD-linear model and a discrete two-cluster model for\n    three synthetic datasets.\n    \"\"\"\n\n    def process_dataset(N, F, s, coords_list, D_matrix):\n        \"\"\"\n        Processes a single dataset to determine the preferred model.\n\n        Returns:\n            int: 1 if the IBD-linear model is preferred, 0 otherwise.\n        \"\"\"\n        coords = np.array(coords_list, dtype=float)\n        D = np.array(D_matrix, dtype=float)\n\n        # 1. Generate all unique pairs and assign them to folds.\n        pairs = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                geo_dist = np.linalg.norm(coords[i] - coords[j])\n                gen_dist = D[i, j]\n                fold_idx = ((i * N + j) + s) % F\n                pairs.append({'i': i, 'j': j, 'geo_dist': geo_dist, 'gen_dist': gen_dist, 'fold': fold_idx})\n        \n        # 2. Calculate cross-validated MSE for the IBD-linear model.\n        ibd_mse = calculate_ibd_cv_mse(pairs, F)\n        \n        # 3. Calculate cross-validated MSE for the discrete two-cluster model.\n        cluster_mse = calculate_cluster_cv_mse(pairs, F, N)\n        \n        # 4. Compare model errors and make a selection.\n        if ibd_mse - cluster_mse <= 1e-9:\n            return 1\n        else:\n            return 0\n\n    def calculate_ibd_cv_mse(pairs, F):\n        \"\"\"Calculates the cross-validated MSE for the IBD-linear model.\"\"\"\n        fold_mses = []\n        for f in range(F):\n            train_pairs = [p for p in pairs if p['fold'] != f]\n            valid_pairs = [p for p in pairs if p['fold'] == f]\n            \n            if not valid_pairs:\n                continue\n            \n            # Handle empty training set (unlikely for problems' parameters)\n            if not train_pairs:\n                all_gen_dists = np.array([p['gen_dist'] for p in pairs])\n                mean_gen_dist = np.mean(all_gen_dists) if len(all_gen_dists) > 0 else 0\n                valid_gen_dists = np.array([p['gen_dist'] for p in valid_pairs])\n                mse = np.mean((valid_gen_dists - mean_gen_dist)**2) if len(valid_gen_dists) > 0 else 0\n                fold_mses.append(mse)\n                continue\n\n            train_geo = np.array([p['geo_dist'] for p in train_pairs])\n            train_gen = np.array([p['gen_dist'] for p in train_pairs])\n            \n            # Fit OLS model using numpy.linalg.lstsq for robustness.\n            A = np.vstack([train_geo, np.ones(len(train_geo))]).T\n            try:\n                beta, alpha = np.linalg.lstsq(A, train_gen, rcond=None)[0]\n            except np.linalg.LinAlgError:\n                alpha = np.mean(train_gen) if len(train_gen) > 0 else 0\n                beta = 0\n\n            # Predict on validation set and compute MSE.\n            valid_geo = np.array([p['geo_dist'] for p in valid_pairs])\n            valid_gen = np.array([p['gen_dist'] for p in valid_pairs])\n            pred_gen = beta * valid_geo + alpha\n            mse = np.mean((valid_gen - pred_gen)**2)\n            fold_mses.append(mse)\n            \n        return np.mean(fold_mses) if fold_mses else 0\n\n    def calculate_cluster_cv_mse(pairs, F, N):\n        \"\"\"Calculates the cross-validated MSE for the discrete two-cluster model.\"\"\"\n        fold_mses = []\n        \n        # Generate all valid cluster assignments (c_0=0, both clusters non-empty).\n        num_assignments_to_check = 2**(N - 1)\n        assignments = []\n        for i in range(1, num_assignments_to_check):\n            assignment = [0] * N\n            for j in range(1, N):\n                if (i >> (j - 1)) & 1:\n                    assignment[j] = 1\n            assignments.append(tuple(assignment))\n\n        for f in range(F):\n            train_pairs = [p for p in pairs if p['fold'] != f]\n            valid_pairs = [p for p in pairs if p['fold'] == f]\n            \n            if not valid_pairs:\n                continue\n            \n            # Handle empty training set.\n            if not train_pairs:\n                all_gen_dists = np.array([p['gen_dist'] for p in pairs])\n                mean_gen_dist = np.mean(all_gen_dists) if len(all_gen_dists) > 0 else 0\n                valid_gen_dists = np.array([p['gen_dist'] for p in valid_pairs])\n                mse = np.mean((valid_gen_dists - mean_gen_dist)**2) if len(valid_gen_dists) > 0 else 0\n                fold_mses.append(mse)\n                continue\n                \n            train_gen_dists_all = [p['gen_dist'] for p in train_pairs]\n            overall_train_mean = np.mean(train_gen_dists_all)\n\n            min_train_mse = float('inf')\n            best_params = (overall_train_mean, overall_train_mean)\n            best_assignment = assignments[0] if assignments else tuple([0] * N)\n            \n            # Find the best assignment by minimizing training MSE.\n            for c in assignments:\n                train_within = [p['gen_dist'] for p in train_pairs if c[p['i']] == c[p['j']]]\n                train_between = [p['gen_dist'] for p in train_pairs if c[p['i']] != c[p['j']]]\n                \n                w_hat = np.mean(train_within) if train_within else overall_train_mean\n                b_hat = np.mean(train_between) if train_between else overall_train_mean\n\n                train_sq_err = 0\n                for p in train_pairs:\n                    pred = w_hat if c[p['i']] == c[p['j']] else b_hat\n                    train_sq_err += (p['gen_dist'] - pred)**2\n                \n                current_train_mse = train_sq_err / len(train_pairs)\n                \n                if current_train_mse < min_train_mse:\n                    min_train_mse = current_train_mse\n                    best_params = (w_hat, b_hat)\n                    best_assignment = c\n            \n            w_hat_f, b_hat_f = best_params\n            c_f = best_assignment\n            \n            # Predict on validation set and compute MSE.\n            valid_sq_err = 0\n            if valid_pairs:\n                for p in valid_pairs:\n                    pred = w_hat_f if c_f[p['i']] == c_f[p['j']] else b_hat_f\n                    valid_sq_err += (p['gen_dist'] - pred)**2\n                mse = valid_sq_err / len(valid_pairs)\n            else:\n                mse = 0\n            \n            fold_mses.append(mse)\n            \n        return np.mean(fold_mses) if fold_mses else 0\n\n    # Define Test Cases\n    # Dataset A\n    N_A = 6\n    coords_A = [(float(i), 0.0) for i in range(N_A)]\n    D_A = np.zeros((N_A, N_A))\n    for i in range(N_A):\n        for j in range(i + 1, N_A):\n            dist = 0.1 + 0.2 * abs(coords_A[i][0] - coords_A[j][0])\n            D_A[i, j] = D_A[j, i] = dist\n    \n    # Dataset B\n    N_B = 6\n    coords_B = [(0.0, 0.0), (3.0, 0.0), (1.0, 0.0), (0.5, 0.0), (2.0, 0.0), (3.5, 0.0)]\n    clusters_B = {0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1} # True clusters for D generation\n    D_B = np.zeros((N_B, N_B))\n    for i in range(N_B):\n        for j in range(i + 1, N_B):\n            dist = 0.1 if clusters_B[i] == clusters_B[j] else 0.6\n            D_B[i, j] = D_B[j, i] = dist\n\n    # Dataset C\n    N_C = 5\n    coords_C = [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0), (2.0, 0.0)]\n    D_C = np.full((N_C, N_C), 0.3)\n    np.fill_diagonal(D_C, 0)\n\n    test_cases = [\n        (6, 3, 7, coords_A, D_A),  # Dataset A\n        (6, 3, 11, coords_B, D_B), # Dataset B\n        (5, 3, 3, coords_C, D_C)   # Dataset C\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_dataset(*case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2727647"}]}