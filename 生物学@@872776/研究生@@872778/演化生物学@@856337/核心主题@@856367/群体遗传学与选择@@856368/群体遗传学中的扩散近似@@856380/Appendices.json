{"hands_on_practices": [{"introduction": "新突变的最终命运是演化生物学的一个核心问题。本练习将通过扩散近似来推导有利等位基因的固定概率，从而探索这一问题。更进一步，本练习要求您将此复杂的连续模型与更简单的离散Galton-Watson分支过程联系起来，从而深刻理解为何这些不同的数学框架在处理稀有等位基因时会得出相似的预测[@problem_id:2700938]。", "problem": "考虑一个根据 Wright–Fisher 模型演化的随机交配二倍体种群，其普查规模恒定为 $N$ 且世代不重叠。在一个常染色体位点上，一个新等位基因 $A$ 的单拷贝出现在一个原本对等位基因 $a$ 固定的种群中。假设存在乘性生存力选择，基因型适应度分别为 $w_{aa} = 1$、$w_{Aa} = 1 + s$ 和 $w_{AA} = 1 + 2s$，其中 $0  s \\ll 1$ 是 $A$ 的每个等位基因的适应度优势。令 $p \\in [0,1]$ 表示等位基因 $A$ 的频率。\n\n在扩散近似下（将离散世代缩放为连续时间，其中 $N$ 较大，$s$ 较小，但允许 $Ns$ 为任意阶），从 Wright–Fisher 模型的第一性原理出发：\n\n1. 在上述选择方案下，为等位基因频率过程推导主导阶的漂移项 $M(p)$ 和扩散项 $V(p)$。\n2. 使用一维扩散的向后 Kolmogorov 方程，推导并求解等位基因 $A$ 的固定概率 $u(p)$ 的边界值问题，其中 $u(p)$ 定义为在当前频率为 $p$ 的情况下 $A$ 最终固定的概率，吸收边界条件为 $u(0)=0$ 和 $u(1)=1$。\n3. 在初始频率 $p_{0} = \\frac{1}{2N}$ 处计算 $u(p)$，以获得一个仅用 $N$ 和 $s$ 表示的单一、封闭形式的解析表达式。此表达式即为所要求的最终答案。\n\n然后，将初始的稀有等位基因阶段建模为一个 Galton–Watson 分支过程，在该过程中，每个 $A$ 的拷贝在下一代产生随机数量的 $A$ 拷贝。在 Wright–Fisher 抽样下，论证该后代分布的人均均值和方差（精确到 $s$ 的主导阶），并推导该分支过程的存活概率（精确到 $s$ 的一阶）。在不改变最终表达式的情况下，解释在 $N$ 较大和 $s$ 较小的适当联合极限下，扩散结果如何简化为分支过程的预测。\n\n将所求的固定概率表示为一个用 $N$ 和 $s$ 表示的精确解析表达式。不要四舍五入或近似。无需单位。", "solution": "该问题有科学依据，提法恰当且客观。这是理论种群遗传学中的一个经典问题，因此是有效的。\n\n解答过程按提示要求分为三个部分。首先，我们推导漂移和扩散系数，并求解相应的向后 Kolmogorov 方程以得到固定概率 $u(p)$。其次，我们计算一个新突变的该概率。第三，我们使用分支过程近似来分析该系统，并将其与扩散结果进行协调。\n\n**1. 漂移和扩散系数的推导**\n令 $p$ 为一个规模恒定为 $N$ 的随机交配二倍体种群中等位基因 $A$ 的频率。基因型 $aa$、$Aa$ 和 $AA$ 的适应度分别为 $w_{aa} = 1$、$w_{Aa} = 1+s$ 和 $w_{AA} = 1+2s$，其中 $0  s \\ll 1$。\n在 Hardy-Weinberg 平衡的假设下，选择前各基因型的频率分别为 $(1-p)^2$、$2p(1-p)$ 和 $p^2$。种群的平均适应度为：\n$$ \\bar{w} = (1-p)^2 w_{aa} + 2p(1-p) w_{Aa} + p^2 w_{AA} $$\n$$ \\bar{w} = (1-p)^2 (1) + 2p(1-p)(1+s) + p^2(1+2s) $$\n$$ \\bar{w} = (1-2p+p^2) + (2p-2p^2)(1+s) + p^2(1+2s) $$\n$$ \\bar{w} = 1-2p+p^2 + 2p+2sp-2p^2-2sp^2 + p^2+2sp^2 = 1+2sp $$\n选择之后，等位基因 $A$ 的频率（记为 $p'$）由下式给出：\n$$ p' = \\frac{p^2 w_{AA} + p(1-p) w_{Aa}}{\\bar{w}} = \\frac{p^2(1+2s) + p(1-p)(1+s)}{1+2sp} $$\n$$ p' = \\frac{p^2+2sp^2 + p-p^2+sp-sp^2}{1+2sp} = \\frac{p+sp+sp^2}{1+2sp} = \\frac{p(1+s+sp)}{1+2sp} $$\n由选择引起的一代内的等位基因频率变化为 $\\Delta p_{sel} = p' - p$：\n$$ \\Delta p_{sel} = \\frac{p(1+s+sp)}{1+2sp} - p = \\frac{p(1+s+sp) - p(1+2sp)}{1+2sp} = \\frac{sp-sp^2}{1+2sp} = \\frac{sp(1-p)}{1+2sp} $$\n由于 $s \\ll 1$，我们可以将其近似到 $s$ 的主导阶：$\\Delta p_{sel} \\approx sp(1-p)$。\n下一代是通过从频率为 $p'$ 的选择后基因库中进行 $2N$ 个配子的二项抽样形成的。一代内等位基因频率的总变化 $\\Delta p$ 的期望值（以 $p$ 为条件）为：\n$$ \\mathbb{E}[\\Delta p | p] = \\mathbb{E}[p_{t+1}-p_t | p_t=p] = p' - p \\approx sp(1-p) $$\n这种变化的方差主要由随机抽样（遗传漂变）决定：\n$$ \\text{Var}(\\Delta p | p) = \\text{Var}\\left(\\frac{K}{2N} \\mid p\\right) = \\frac{1}{(2N)^2} \\text{Var}(K) $$\n其中 $K$ 是下一代中 $A$ 等位基因的数量，服从二项分布 $K \\sim \\text{Binomial}(2N, p')$。\n$$ \\text{Var}(\\Delta p | p) = \\frac{2Np'(1-p')}{(2N)^2} = \\frac{p'(1-p')}{2N} $$\n在主导阶上，$p' \\approx p$，因此 $\\text{Var}(\\Delta p | p) \\approx \\frac{p(1-p)}{2N}$。\n这些是每代 $p$ 变化的均值和方差的主导阶表达式。漂移项为 $M_{\\text{gen}}(p) = sp(1-p)$，扩散项为 $V_{\\text{gen}}(p) = \\frac{p(1-p)}{2N}$。\n\n**2. 求解固定概率的边界值问题**\n当前频率为 $p$ 的等位基因的固定概率 $u(p)$ 遵循向后 Kolmogorov 方程。对于最终固定概率，该方程简化为稳态常微分方程：\n$$ M_{\\text{gen}}(p) \\frac{du}{dp} + \\frac{1}{2} V_{\\text{gen}}(p) \\frac{d^2u}{dp^2} = 0 $$\n代入推导出的系数：\n$$ sp(1-p) \\frac{du}{dp} + \\frac{1}{2} \\frac{p(1-p)}{2N} \\frac{d^2u}{dp^2} = 0 $$\n对于 $p \\in (0, 1)$，我们可以除以 $p(1-p)$:\n$$ s \\frac{du}{dp} + \\frac{1}{4N} \\frac{d^2u}{dp^2} = 0 \\implies \\frac{d^2u}{dp^2} + 4Ns \\frac{du}{dp} = 0 $$\n令 $v(p) = \\frac{du}{dp}$。该方程变为一阶线性常微分方程：$\\frac{dv}{dp} + 4Ns v = 0$。其解为 $v(p) = C_1 \\exp(-4Nsp)$。\n对 $v(p)$ 积分以求得 $u(p)$：\n$$ u(p) = \\int C_1 \\exp(-4Nsp) \\,dp = -\\frac{C_1}{4Ns}\\exp(-4Nsp) + C_2 $$\n令 $K_1 = -C_1/(4Ns)$ 和 $K_2=C_2$。则 $u(p) = K_1 \\exp(-4Nsp) + K_2$。我们应用边界条件 $u(0)=0$（如果等位基因不存在，则必然丢失）和 $u(1)=1$（如果等位基因已固定，则必然固定）。\n$u(0) = 0 \\implies K_1 \\exp(0) + K_2 = 0 \\implies K_1 + K_2 = 0 \\implies K_2 = -K_1$。\n$u(1) = 1 \\implies K_1 \\exp(-4Ns) + K_2 = 1$。\n将 $K_2 = -K_1$ 代入第二个方程：\n$K_1 \\exp(-4Ns) - K_1 = 1 \\implies K_1 (\\exp(-4Ns)-1) = 1 \\implies K_1 = \\frac{1}{\\exp(-4Ns)-1}$。\n因此，$K_2 = -\\frac{1}{\\exp(-4Ns)-1}$。\n作为 $p$ 的函数的固定概率为：\n$$ u(p) = \\frac{\\exp(-4Nsp)}{\\exp(-4Ns)-1} - \\frac{1}{\\exp(-4Ns)-1} = \\frac{\\exp(-4Nsp)-1}{\\exp(-4Ns)-1} = \\frac{1-\\exp(-4Nsp)}{1-\\exp(-4Ns)} $$\n\n**3. 计算新突变的固定概率**\n在一个大小为 $N$ 的种群中，一个新等位基因 $A$ 的单拷贝对应于初始频率 $p_0 = \\frac{1}{2N}$。将此代入 $u(p)$ 的解中：\n$$ u\\left(\\frac{1}{2N}\\right) = \\frac{1 - \\exp\\left(-4Ns \\cdot \\frac{1}{2N}\\right)}{1 - \\exp(-4Ns)} = \\frac{1 - \\exp(-2s)}{1 - \\exp(-4Ns)} $$\n这就是所要求的封闭形式解析表达式。\n\n**与分支过程的协调**\n当等位基因 $A$ 稀有时，其命运可以建模为一个 Galton-Watson 分支过程，其中每个等位基因拷贝在下一代产生随机数量的后代拷贝。我们推导这个后代分布的均值和方差。\n等位基因 $A$ 的一个单拷贝存在时的频率为 $p_0 = \\frac{1}{2N}$。选择后的频率是 $p' = \\frac{p_0(1+s+sp_0)}{1+2sp_0} \\approx \\frac{1/(2N)(1+s)}{1+s/N}$。\n下一代的后代拷贝数 $K$ 服从二项分布 $K \\sim \\text{Binomial}(2N, p')$。\n每个亲本拷贝的平均后代数为 $\\mu = \\mathbb{E}[K] = 2Np' = 2N \\frac{1/(2N)(1+s)}{1+s/N} = \\frac{1+s}{1+s/N}$。\n对于大的 $N$，$\\mu \\approx 1+s$。\n后代数量的方差为 $\\sigma^2 = \\text{Var}(K) = 2Np'(1-p') = \\mu(1-p') = \\mu(1-\\mu/(2N))$。\n对于大的 $N$，$\\sigma^2 \\approx \\mu \\approx 1+s$。\n对于一个平均后代数 $\\mu$ 从上方趋近于 $1$ 的分支过程，其存活概率 $\\pi$ 由 $\\pi \\approx \\frac{2(\\mu-1)}{\\sigma^2}$ 给出。\n使用我们对小 $s$ 和大 $N$ 的主导阶近似（$\\mu \\approx 1+s$，$\\sigma^2 \\approx 1$）：\n$$ \\pi \\approx \\frac{2((1+s)-1)}{1} = 2s $$\n这是 Haldane 关于存活概率的经典结果。\n现在，我们展示扩散结果如何简化为这个预测。分支过程近似在极大种群（$N \\to \\infty$）的极限下是有效的，此时稀有等位基因的不同谱系不会相互干扰。在此极限下，参数 $4Ns \\to \\infty$（因为 $s0$）。\n我们扩散结果的分母变为 $\\lim_{N\\to\\infty} (1 - \\exp(-4Ns)) = 1-0 = 1$。\n固定概率变为：\n$$ \\lim_{N\\to\\infty} u\\left(\\frac{1}{2N}\\right) = \\frac{1 - \\exp(-2s)}{1} = 1 - \\exp(-2s) $$\n这个表达式 $1 - \\exp(-2s)$ 是增长率为 $s$ 的连续时间分支过程的精确存活概率。对于小的 $s$，我们可以使用泰勒展开：\n$$ 1 - \\exp(-2s) = 1 - \\left(1 - 2s + \\frac{(2s)^2}{2!} - \\dots\\right) \\approx 2s $$\n因此，在 $N$ 较大和 $s$ 较小的联合极限下（特别是在 $Ns \\to \\infty$ 的情况下），一般的扩散结果收敛于简单分支过程模型的一阶预测。\n更仔细的分析表明，极限 $1-\\exp(-2s)$ 对应于一个后代均值和方差为 $\\mu=\\sigma^2=1+s$ 的分支过程，其存活概率为 $\\pi \\approx \\frac{2s}{1+s} \\approx 2s-2s^2$。$1-\\exp(-2s)$ 的泰勒展开式为 $2s-2s^2+...$，这显示了更深层次的一致性。", "answer": "$$\\boxed{\\frac{1 - \\exp(-2s)}{1 - \\exp(-4Ns)}}$$", "id": "2700938"}, {"introduction": "除了了解固定或丢失的最终概率外，我们通常还对这些事件发生的时间尺度感兴趣。本练习通过推导等位基因丢失或固定所需时间的期望值，深入探讨了遗传漂变的动态过程。您还将探索一个更精妙的概念：在等位基因最终固定的条件下，到达固定所需的平均时间[@problem_id:2700930]，这是一个揭示成功与不成功等位基因不同时间路径的关键结果。", "problem": "考虑一个单双等位基因座的赖特-费雪（WF）扩散近似，该基因座存在于一个随机交配、有效种群大小恒为 $N$ 的种群中，无突变，无显性。令 $X_{t} \\in [0,1]$ 表示在（连续）时间 $t$（以世代为单位）时等位基因 $A$ 的频率。在中性（无选择）条件下，作用于二阶连续可微测试函数 $f$ 的柯尔莫哥洛夫后向算子为\n$$\n\\mathcal{L} f(x) \\;=\\; \\frac{x(1-x)}{4N}\\, f^{\\prime\\prime}(x),\n$$\n其在 $x=0$ 和 $x=1$ 处有吸收边界。\n\n从该算子和具有吸收边界的一维扩散的吸收时间基本定义出发，完成以下任务：\n\n1) 推导无条件平均吸收时间 $T(x)$ 满足的常微分方程，其中 $T(x)$ 是从 $X_{0}=x$ 开始的 $X_{t}$ 到达任一边界 $\\{0,1\\}$ 的期望时间，并在适当的边界条件下求解该方程。\n\n2) 令 $u(x)$ 为从 $x$ 开始时等位基因 $A$ 的固定概率，并使用马尔可夫过程的条件化原理（使用 $h=u$ 的 Doob $h$-变换）构建以最终在 $x=1$ 处固定为条件的过程的后向算子。从此变换后的算子出发，推导以固定为条件的平均固定时间（记为 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$）的微分方程，并结合适当的边界和正则性条件求解，以获得一个闭式表达式。\n\n3) 在 $N = 1.0 \\times 10^{5}$ 和初始等位基因频率 $x_{0} = 0.01$ 的条件下，计算这两个表达式的值，并报告这两个数值（无条件平均吸收时间和以固定为条件的平均固定时间），单位为世代。将您的答案四舍五入到四位有效数字。\n\n您的最终答案必须是按顺序 $(T(x_{0}),\\, T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x_{0}))$ 排列的一对数字。", "solution": "所述问题需根据既定的科学和数学严谨性原则进行验证。\n\n逐字提取给定条件：\n-   模型：单双等位基因座的赖特-费雪（WF）扩散近似。\n-   种群：随机交配，有效大小恒为 $N$。\n-   遗传参数：无突变，无显性，无选择（中性）。\n-   状态变量：$X_{t} \\in [0,1]$ 是连续时间 $t$（以世代为单位）的等位基因频率。\n-   算子：柯尔莫哥洛夫后向算子为 $\\mathcal{L} f(x) = \\frac{x(1-x)}{4N}\\, f^{\\prime\\prime}(x)$。\n-   边界：在 $x=0$ 和 $x=1$ 处吸收。\n-   待推导的量：\n    1.  无条件平均吸收时间，$T(x)$。\n    2.  以固定为条件的平均固定时间，$T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$。\n-   数值计算参数：$N = 1.0 \\times 10^{5}$，初始频率 $x_{0} = 0.01$。\n\n验证评估：\n该问题具有科学依据，是群体遗传学领域的一个经典问题，基于 Sewall Wright 和 Motoo Kimura 发展的扩散理论。当时间以世代为单位衡量时，所提供的柯尔莫哥洛夫算子对于中性过程是正确的。该问题是适定的、客观的，并包含足够的信息以获得唯一解。平均吸收时间和条件固定时间的概念是标准的，可以使用所提供的算子和随机过程的基本理论来求解。该问题没有逻辑矛盾、事实错误和歧义。\n\n验证结论：问题有效。我们继续进行推导和求解。\n\n第一部分：无条件平均吸收时间，$T(x)$\n\n对于从 $x$ 开始的一维扩散过程，其无条件平均吸收时间 $T(x)$ 由 Dynkin 公式决定，该公式导出了以下常微分方程（ODE）：\n$$\n\\mathcal{L} T(x) = -1\n$$\n代入给定的算子 $\\mathcal{L}$，我们得到：\n$$\n\\frac{x(1-x)}{4N} T^{\\prime\\prime}(x) = -1\n$$\n其中 $T^{\\prime\\prime}(x)$ 是 $T(x)$ 关于 $x$ 的二阶导数。该方程对 $x \\in (0,1)$ 有效。\n整理后，我们得到：\n$$\nT^{\\prime\\prime}(x) = -\\frac{4N}{x(1-x)}\n$$\n在 $x=0$ 和 $x=1$ 处的边界是吸收边界。如果过程从吸收边界开始，吸收时间为 $0$。因此，边界条件为：\n$$\nT(0) = 0 \\quad \\text{和} \\quad T(1) = 0\n$$\n我们将 $T^{\\prime\\prime}(x)$ 对 $x$ 积分一次。使用部分分式分解 $\\frac{1}{x(1-x)} = \\frac{1}{x} + \\frac{1}{1-x}$：\n$$\nT^{\\prime}(x) = \\int -\\frac{4N}{x(1-x)} dx = -4N \\int \\left(\\frac{1}{x} + \\frac{1}{1-x}\\right) dx = -4N \\left(\\ln(x) - \\ln(1-x)\\right) + C_1\n$$\n进行第二次积分：\n$$\nT(x) = \\int \\left(-4N(\\ln(x) - \\ln(1-x)) + C_1\\right) dx\n$$\n使用标准积分 $\\int \\ln(u) du = u \\ln(u) - u$，我们发现：\n$$\nT(x) = -4N \\left[ (x\\ln(x) - x) - (-(1-x)\\ln(1-x) - x) \\right] + C_1 x + C_2\n$$\n$$\nT(x) = -4N \\left( x\\ln(x) + (1-x)\\ln(1-x) \\right) + C_1 x + C_2\n$$\n为了确定常数 $C_1$ 和 $C_2$，我们应用边界条件。我们使用极限 $\\lim_{u\\to 0^+} u\\ln(u) = 0$。\n在 $x=0$ 处：\n$$\n\\lim_{x\\to 0^+} T(x) = -4N \\left( 0 + 1\\ln(1) \\right) + C_1(0) + C_2 = C_2\n$$\n由 $T(0)=0$，我们得到 $C_2=0$。\n在 $x=1$ 处：\n$$\n\\lim_{x\\to 1^-} T(x) = -4N \\left( 1\\ln(1) + 0 \\right) + C_1(1) + C_2 = C_1 + C_2\n$$\n由 $T(1)=0$ 和 $C_2=0$，我们得到 $C_1=0$。\n因此，无条件平均吸收时间为：\n$$\nT(x) = -4N \\left( x \\ln(x) + (1-x)\\ln(1-x) \\right)\n$$\n\n第二部分：以固定为条件的平均固定时间，$T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$\n\n首先，我们确定固定概率 $u(x)$，它满足方程 $\\mathcal{L} u(x) = 0$，边界条件为 $u(0)=0$（丢失）和 $u(1)=1$（固定）。\n$$\n\\frac{x(1-x)}{4N} u^{\\prime\\prime}(x) = 0\n$$\n对于 $x \\in (0,1)$，这意味着 $u^{\\prime\\prime}(x)=0$。积分两次得到 $u(x) = C_1 x + C_2$。\n应用边界条件：$u(0)=0 \\implies C_2=0$，以及 $u(1)=1 \\implies C_1=1$。\n因此，固定概率为 $u(x)=x$。\n\n为了找到以固定为条件的动力学，我们使用 Doob $h$-变换，其中 $h(x) = u(x) = x$。作用于测试函数 $f(x)$ 的条件化过程的后向算子 $\\mathcal{L}^*$ 由下式给出：\n$$\n\\mathcal{L}^* f(x) = \\frac{1}{u(x)} \\mathcal{L} (u(x)f(x))\n$$\n我们来计算 $\\mathcal{L}(x f(x))$：\n$g(x) = x f(x)$ 的二阶导数是 $g^{\\prime\\prime}(x) = \\frac{d}{dx} (f(x) + xf^{\\prime}(x)) = 2f^{\\prime}(x) + xf^{\\prime\\prime}(x)$。\n$$\n\\mathcal{L}(x f(x)) = \\frac{x(1-x)}{4N} (2f^{\\prime}(x) + xf^{\\prime\\prime}(x))\n$$\n将此代入 $\\mathcal{L}^*$ 的表达式中：\n$$\n\\mathcal{L}^* f(x) = \\frac{1}{x} \\left[ \\frac{x(1-x)}{4N} (2f^{\\prime}(x) + xf^{\\prime\\prime}(x)) \\right] = \\frac{x(1-x)}{4N} f^{\\prime\\prime}(x) + \\frac{1-x}{2N} f^{\\prime}(x)\n$$\n以最终固定为条件的平均固定时间 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$ 满足 $\\mathcal{L}^* T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x) = -1$。\n$$\n\\frac{x(1-x)}{4N} T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime\\prime}(x) + \\frac{1-x}{2N} T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime}(x) = -1\n$$\n对于 $x \\in (0,1)$，我们可以乘以 $\\frac{4N}{1-x}$：\n$$\nx T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime\\prime}(x) + 2 T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime}(x) = -\\frac{4N}{1-x}\n$$\n这是一个关于 $v(x) = T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime}(x)$ 的一阶线性常微分方程。左侧可以写成 $(x^2 v(x))' / x$。积分因子法更直接。令 $v(x) = T_{\\mathrm{fix}\\mid \\mathrm{fix}}'(x)$。方程为 $v' + \\frac{2}{x} v = -\\frac{4N}{x(1-x)}$。积分因子为 $\\exp(\\int \\frac{2}{x} dx) = x^2$。乘以 $x^2$ 得到：\n$$\nx^2 v'(x) + 2x v(x) = \\frac{d}{dx}(x^2 v(x)) = -\\frac{4Nx}{1-x} = 4N - \\frac{4N}{1-x}\n$$\n对 $x$ 积分：\n$$\nx^2 v(x) = 4Nx + 4N \\ln(1-x) + C_1\n$$\n$$\nv(x) = T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime}(x) = \\frac{4N}{x} + \\frac{4N\\ln(1-x)}{x^2} + \\frac{C_1}{x^2}\n$$\n条件化过程在 $x=1$ 处被吸收，而 $x=0$ 处的边界变得不可达（反射）。当 $x \\to 0^+$ 时，平均时间 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$ 必须保持有限。如果 $C_1 \\neq 0$，导数中的项 $C_1/x^2$ 将导致 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$ 在 $x=0$ 附近出现 $1/x$ 类型的发散。因此，正则性要求 $C_1=0$。\n所以，$T_{\\mathrm{fix}\\mid \\mathrm{fix}}^{\\prime}(x) = \\frac{4N}{x} + \\frac{4N\\ln(1-x)}{x^2}$。\n积分以求得 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x)$：\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(x) = \\int \\left(\\frac{4N}{x} + \\frac{4N\\ln(1-x)}{x^2}\\right) dx = 4N \\ln(x) + 4N \\int \\frac{\\ln(1-x)}{x^2} dx + C_2\n$$\n第二个积分通过分部积分法求解：$\\int u dv = uv - \\int v du$。令 $u=\\ln(1-x)$ 和 $dv=x^{-2}dx$。则 $du = \\frac{-1}{1-x}dx$ 且 $v=-x^{-1}$。\n$$\n\\int \\frac{\\ln(1-x)}{x^2} dx = -\\frac{\\ln(1-x)}{x} - \\int \\frac{1}{x(1-x)} dx = -\\frac{\\ln(1-x)}{x} - \\ln(x) + \\ln(1-x)\n$$\n将其代回：\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(x) = 4N \\ln(x) + 4N \\left( -\\frac{\\ln(1-x)}{x} - \\ln(x) + \\ln(1-x) \\right) + C_2\n$$\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(x) = -4N \\frac{\\ln(1-x)}{x} + 4N \\ln(1-x) + C_2 = -4N \\frac{1-x}{x} \\ln(1-x) + C_2\n$$\n条件化过程的边界条件是在 $x=1$ 处吸收，所以 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(1)=0$。\n取 $x \\to 1^-$ 的极限：\n$$\n\\lim_{x\\to 1^-} T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x) = \\lim_{x\\to 1^-} \\left( -4N \\frac{1-x}{x} \\ln(1-x) \\right) + C_2 = 0 + C_2\n$$\n这意味着 $C_2=0$。\n以固定为条件的平均固定时间为：\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(x) = -4N \\frac{1-x}{x} \\ln(1-x)\n$$\n\n第三部分：数值计算\n\n给定 $N = 1.0 \\times 10^5$ 和 $x_0 = 0.01$。\n\n1) 无条件平均吸收时间 $T(x_0)$：\n$$\nT(0.01) = -4(1.0 \\times 10^5) \\left( 0.01 \\ln(0.01) + (1-0.01)\\ln(1-0.01) \\right)\n$$\n$$\nT(0.01) = -4.0 \\times 10^5 \\left( 0.01 \\ln(0.01) + 0.99 \\ln(0.99) \\right)\n$$\n使用计算器：$\\ln(0.01) \\approx -4.60517$ 和 $\\ln(0.99) \\approx -0.0100503$。\n$$\nT(0.01) \\approx -4.0 \\times 10^5 \\left( 0.01(-4.60517) + 0.99(-0.0100503) \\right)\n$$\n$$\nT(0.01) \\approx -4.0 \\times 10^5 \\left( -0.0460517 - 0.0099498 \\right) = -4.0 \\times 10^5(-0.0560015) \\approx 22400.6\n$$\n四舍五入到四位有效数字，$T(x_0) = 2.240 \\times 10^4$ 世代。\n\n2) 以固定为条件的平均固定时间 $T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x_0)$：\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(0.01) = -4(1.0 \\times 10^5) \\frac{1-0.01}{0.01} \\ln(1-0.01)\n$$\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(0.01) = -4.0 \\times 10^5 \\frac{0.99}{0.01} \\ln(0.99) = -4.0 \\times 10^5 \\times 99 \\times \\ln(0.99)\n$$\n$$\nT_{\\mathrm{fix}\\mid \\mathrm{fix}}(0.01) \\approx -4.0 \\times 10^5 \\times 99 \\times (-0.0100503) \\approx 397993.3\n$$\n四舍五入到四位有效数字，$T_{\\mathrm{fix}\\mid \\mathrm{fix}}(x_0) = 3.980 \\times 10^5$ 世代。", "answer": "$$\n\\boxed{(2.240 \\times 10^4, 3.980 \\times 10^5)}\n$$", "id": "2700930"}, {"introduction": "扩散理论的威力不仅在于预测单个等位基因的轨迹，还在于解释整个基因组的变异模式。这个高级练习通过处理在突变、选择和漂变共同作用下等位基因频率的稳态分布，将理论与应用联系起来。您的任务是建立一个统计框架，以位点频率谱（SFS）的形式分析多态性数据，并执行最大似然估计来推断自然选择的强度[@problem_id:2700942]。", "problem": "您需要为一个在基因选择和双向突变作用下，遵循 Wright–Fisher 扩散演化的双等位基因座，实现一个基于扩散近似的推断引擎。您的任务是利用扩散过程的平稳分布，推导、实现并评估位点频率谱（SFS）的似然，然后为一组测试用例计算标度化选择参数的单参数最大似然估计（MLE）。\n\n从群体遗传学中的以下标准基本前提开始：\n- 考虑一个有效群体大小为 $N$ 的群体，其中等位基因 $\\mathsf{1}$ 的频率 $x \\in (0,1)$ 在基因选择系数 $s$ 和双向突变率 $u$（从 $\\mathsf{1}$ 到 $\\mathsf{0}$）与 $v$（从 $\\mathsf{0}$ 到 $\\mathsf{1}$）的作用下，遵循 Wright–Fisher 扩散。该扩散的无穷小均值和方差分别为 $m(x) = s\\,x(1-x) + v(1-x) - u x$ 和 $V(x) = \\frac{x(1-x)}{2N}$。\n- 平稳密度 $\\pi(x)$ 满足在边界处概率通量为零的平稳 Fokker–Planck (FP) 方程。使用在零通量边界条件下，具有漂移 $m(x)$ 和方差 $V(x)$ 的一维扩散的标准通解来获得 $\\pi(x)$。\n\n在此基础上，完成以下所有任务：\n1) 推导平稳密度（可忽略归一化常数），并用标度化参数 $\\alpha = 4 N v$、$\\beta = 4 N u$ 和 $\\kappa = 4 N s$ 表示。然后，对于从群体中抽取的规模为 $n$ 的样本，推导样本中等位基因 $\\mathsf{1}$ 计数 $i \\in \\{0,1,\\dots,n\\}$ 的抽样分布的混合表示。抽样概率 $p_i(\\alpha,\\beta,\\kappa;n)$ 必须表示为二项抽样核与平稳密度的乘积在 $x \\in (0,1)$ 上的积分。您的推导必须有理有据，不得预设目标公式；应从 FP 平稳解形式 $p(x) \\propto \\frac{1}{V(x)} \\exp\\left(\\int^x \\frac{2 m(y)}{V(y)} \\, dy\\right)$ 开始，通过代数运算进行。您可以使用经过验证的特殊函数恒等式来计算积分，但必须证明其适用性。\n2) 对于给定的 $(\\alpha,\\beta,\\kappa,n)$，为所有 $i \\in \\{0,1,\\dots,n\\}$ 实现抽样概率 $p_i(\\alpha,\\beta,\\kappa;n)$ 的数值稳定计算，可采用以下任一方法：\n   - 使用积分 $\\int_0^1 x^{a-1} (1-x)^{b-1} e^{\\kappa x} \\, dx$ 以 Beta 函数和 Kummer 合流超几何函数表示的恒等式，并结合精确的二项式系数，或者\n   - 采用高精度数值积分法，确保所有相关积分在 $x \\in (0,1)$ 上的绝对精度至少为 $10^{-10}$。\n   无论采用哪种方法，您的实现都必须通过在对数域中处理乘法项来避免数值下溢和上溢，并通过对所有 $i$ 的未归一化权重进行归一化，以获得一个和为 $1$ 的有效离散概率向量。\n3) 给定观测到的 SFS 计数 $X_0,\\dots,X_n$，其中 $\\sum_{i=0}^n X_i = L$ 个位点，将对数似然 $\\ell(\\kappa)$ 定义为\n$$\n\\ell(\\kappa) \\;=\\; \\sum_{i=0}^{n} X_i \\,\\log p_i(\\alpha,\\beta,\\kappa;n),\n$$\n其中 $(\\alpha,\\beta,n)$ 已知且固定。实现一个稳健的一维数值优化算法，在闭区间 $[\\kappa_{\\min},\\kappa_{\\max}]$ 上找到最大化点 $\\widehat{\\kappa}$。您必须能处理任意非负整数计数，包括某些类别中计数为零的情况，并确保计算出的概率向量的所有条目均为严格正数，从而使 $\\ell(\\kappa)$ 是良定义的。报告 $\\widehat{\\kappa}$，四舍五入至六位小数。\n\n测试套件与答案规格：\n- 使用以下三个测试用例。在每个测试用例中，程序必须为指定的 $(n,\\alpha,\\beta)$ 和计数 $(X_0,\\dots,X_n)$ 计算最大似然估计 $\\widehat{\\kappa}$，搜索范围限制在区间 $[\\kappa_{\\min},\\kappa_{\\max}]$ 内。\n\n  - 测试用例 1：\n    - 样本大小：$n = 10$。\n    - 标度化突变参数：$\\alpha = 1.0$，$\\beta = 1.0$。\n    - 选择参数搜索范围：$\\kappa_{\\min} = -6.0$，$\\kappa_{\\max} = 6.0$。\n    - 观测计数值向量 $(X_0,\\dots,X_{10})$：\n      $[\\,10,\\,10,\\,10,\\,10,\\,10,\\,10,\\,10,\\,10,\\,10,\\,10,\\,10\\,]$。\n\n  - 测试用例 2：\n    - 样本大小：$n = 10$。\n    - 标度化突变参数：$\\alpha = 1.0$，$\\beta = 1.0$。\n    - 选择参数搜索范围：$\\kappa_{\\min} = -6.0$，$\\kappa_{\\max} = 6.0$。\n    - 观测计数值向量 $(X_0,\\dots,X_{10})$：\n      $[\\,2,\\,4,\\,6,\\,8,\\,10,\\,12,\\,14,\\,16,\\,18,\\,20,\\,22\\,]$。\n\n  - 测试用例 3：\n    - 样本大小：$n = 20$。\n    - 标度化突变参数：$\\alpha = 0.5$，$\\beta = 2.0$。\n    - 选择参数搜索范围：$\\kappa_{\\min} = -10.0$，$\\kappa_{\\max} = 10.0$。\n    - 观测计数值向量 $(X_0,\\dots,X_{20})$：\n      $[\\,42,\\,40,\\,38,\\,36,\\,34,\\,32,\\,30,\\,28,\\,26,\\,24,\\,22,\\,20,\\,18,\\,16,\\,14,\\,12,\\,10,\\,8,\\,6,\\,4,\\,2\\,]$。\n\n- 您的程序必须实现上述数值稳定的计算方法，并按顺序为每个测试用例返回 MLE $\\widehat{\\kappa}$，作为一个四舍五入到六位小数的实数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，例如：\n  $[\\,\\widehat{\\kappa}_1,\\,\\widehat{\\kappa}_2,\\,\\widehat{\\kappa}_3\\,]$,\n  其中每个 $\\widehat{\\kappa}_j$ 都精确到小数点后六位。", "solution": "所提出的问题是计算群体遗传学中一个良定且有科学依据的任务。它要求推导 Wright-Fisher 扩散的平稳分布，随后计算位点频率谱（SFS）的似然，并实现针对标度化选择参数 $\\kappa$ 的最大似然估计（MLE）过程。我们将首先进行系统性推导，然后描述数值实现。\n\n此分析的基础是一维 Fokker-Planck 方程，它描述了等位基因频率的概率密度函数 $p(x,t)$ 的演化。平稳分布 $\\pi(x)$ 是当 $t \\to \\infty$ 时该方程的解，此时 $\\frac{\\partial p}{\\partial t} = 0$。对于一个具有无穷小均值 $m(x)$ 和方差 $V(x)$ 的扩散过程，在 $x=0$ 和 $x=1$ 处满足零通量边界条件的平稳解由下式给出：\n$$\n\\pi(x) = \\frac{C}{V(x)} \\exp\\left( \\int \\frac{2 m(x')}{V(x')} \\, dx' \\right)\n$$\n其中 $C$ 是一个归一化常数，确保 $\\int_0^1 \\pi(x) \\, dx = 1$。\n\n问题给出了一个双等位基因座在基因选择和双向突变下的漂移和扩散系数：\n$$\nm(x) = s\\,x(1-x) + v(1-x) - u x\n$$\n$$\nV(x) = \\frac{x(1-x)}{2N}\n$$\n此处，$x$ 是等位基因 $\\mathsf{1}$ 的频率，$s$ 是选择系数，$u$ 和 $v$ 分别是 $\\mathsf{1} \\to \\mathsf{0}$ 和 $\\mathsf{0} \\to \\mathsf{1}$ 的突变率，$N$ 是有效群体大小。\n\n首先，我们计算被积函数 $\\frac{2 m(x')}{V(x')}$：\n$$\n\\frac{2 m(x')}{V(x')} = \\frac{2 \\left( s\\,x'(1-x') + v(1-x') - u x' \\right)}{\\frac{x'(1-x')}{2N}} = 4N \\left( s + \\frac{v}{x'} - \\frac{u}{1-x'} \\right)\n$$\n引入标准的标度化参数 $\\kappa = 4Ns$、$\\alpha = 4Nv$ 和 $\\beta = 4Nu$，表达式变为：\n$$\n\\frac{2 m(x')}{V(x')} = \\kappa + \\frac{\\alpha}{x'} - \\frac{\\beta}{1-x'}\n$$\n接下来，我们对 $x'$ 执行不定积分：\n$$\n\\int \\left( \\kappa + \\frac{\\alpha}{x'} - \\frac{\\beta}{1-x'} \\right) dx' = \\kappa x' + \\alpha \\ln(x') + \\beta \\ln(1-x') + \\text{const.}\n$$\n将此结果代回 $\\pi(x)$ 的公式，并将常数并入主归一化常数 $C'$，我们得到：\n$$\n\\pi(x) \\propto \\frac{1}{\\frac{x(1-x)}{2N}} \\exp\\left( \\kappa x + \\alpha \\ln x + \\beta \\ln(1-x) \\right)\n$$\n$$\n\\pi(x) \\propto \\frac{1}{x(1-x)} e^{\\kappa x} x^{\\alpha} (1-x)^{\\beta}\n$$\n这可以简化为此模型众所周知的平稳分布：\n$$\n\\pi(x) = C^{-1} x^{\\alpha-1} (1-x)^{\\beta-1} e^{\\kappa x}\n$$\n其中 $C = \\int_0^1 x'^{\\alpha-1} (1-x')^{\\beta-1} e^{\\kappa x'} \\, dx'$ 是归一化常数。\n\n给定从群体中抽取的规模为 $n$ 的样本，观测到等位基因 $\\mathsf{1}$ 的次数（记为 $i$）在群体频率 $x$ 给定的条件下，遵循二项分布：\n$$\nP(i | x) = \\binom{n}{i} x^i (1-x)^{n-i}\n$$\n观测到 $i$ 个衍生等位基因的边际概率 $p_i$ 是通过对所有可能的群体频率 $x$ 进行积分得到的，并以平稳分布 $\\pi(x)$ 加权：\n$$\np_i(\\alpha,\\beta,\\kappa;n) = \\int_0^1 P(i | x) \\pi(x) \\, dx = \\int_0^1 \\binom{n}{i} x^i (1-x)^{n-i} \\left( C^{-1} x^{\\alpha-1} (1-x)^{\\beta-1} e^{\\kappa x} \\right) \\, dx\n$$\n合并各项，我们得到抽样概率的混合表示：\n$$\np_i = C^{-1} \\binom{n}{i} \\int_0^1 x^{i+\\alpha-1} (1-x)^{n-i+\\beta-1} e^{\\kappa x} \\, dx\n$$\n概率 $p_i$ 的总和必须为 $1$。与其显式计算涉及特殊函数的归一化常数 $C$，我们可以定义未归一化的权重 $w_i$ 并对其进行数值归一化：\n$$\nw_i = \\binom{n}{i} \\int_0^1 x^{i+\\alpha-1} (1-x)^{n-i+\\beta-1} e^{\\kappa x} \\, dx\n$$\n然后，概率为 $p_i = w_i / \\sum_{j=0}^n w_j$。这种方法在数值上更稳健。\n\n在实现中，将按照规定使用高精度数值积分法计算积分。直接计算 $w_i$ 项容易出现数值下溢或上溢。因此，所有计算都在对数域中进行。\n未归一化权重的对数为：\n$$\n\\log w_i = \\log \\binom{n}{i} + \\log \\left( \\int_0^1 x^{i+\\alpha-1} (1-x)^{n-i+\\beta-1} e^{\\kappa x} \\, dx \\right)\n$$\n对数二项式系数 $\\log \\binom{n}{i}$ 使用 `gammaln` 函数计算以保持精度。积分使用 `scipy.integrate.quad` 并设置高精度容差进行计算。当 $\\alpha1$ 或 $\\beta1$ 时，此方法对于在边界 $x=0$ 或 $x=1$ 处可能出现的可积奇点是稳健的。\n\n计算出对数权重向量 $[\\log w_0, \\dots, \\log w_n]$ 后，通过 log-sum-exp 技巧获得对数概率 $\\log p_i$，以防止归一化过程中的数值不稳定：\n$$\n\\log p_i = \\log w_i - \\log\\left(\\sum_{j=0}^{n} e^{\\log w_j}\\right) = \\log w_i - \\left( L_{\\max} + \\log\\left(\\sum_{j=0}^{n} e^{\\log w_j - L_{\\max}}\\right) \\right)\n$$\n其中 $L_{\\max} = \\max_j(\\log w_j)$。\n\n对于给定的 $\\kappa$，观测到的 SFS 数据 $X = [X_0, \\dots, X_n]$ 的对数似然为：\n$$\n\\ell(\\kappa) = \\sum_{i=0}^{n} X_i \\log p_i(\\alpha,\\beta,\\kappa;n)\n$$\n我们的目标是找到最大似然估计 $\\widehat{\\kappa}$，它在指定区间 $[\\kappa_{\\min}, \\kappa_{\\max}]$ 上使该函数最大化。这通过使用数值优化器最小化负对数似然 $-\\ell(\\kappa)$ 来实现。对于这种一维有界优化问题，使用 `scipy.optimize.minimize_scalar` 的 'bounded' 方法是合适的工具。\n\n最终算法如下：\n1. 对每个测试用例，定义一个目标函数 `neg_log_likelihood(kappa)`，它以 $\\kappa$ 作为输入。\n2. 在此函数内部，使用上述基于数值积分和对数空间的方法计算对数概率向量 $[\\log p_0, \\dots, \\log p_n]$。\n3. 计算负对数似然 $-\\sum_{i=0}^{n} X_i \\log p_i$ 并返回它。\n4. 将此目标函数连同边界 $[\\kappa_{\\min}, \\kappa_{\\max}]$ 传递给 `scipy.optimize.minimize_scalar`。\n5. 优化器返回使函数最小化的值 $\\widehat{\\kappa}$，该值对应于 MLE。\n6. 按要求报告结果，四舍五入至六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize_scalar\n\ndef _calculate_log_sfs(kappa: float, n: int, alpha: float, beta: float) - np.ndarray:\n    \"\"\"\n    Computes the logarithm of the site frequency spectrum (SFS) probabilities, log(p_i).\n    \n    This function calculates the probability p_i of observing i derived alleles in a sample\n    of size n, under the stationary distribution of a Wright-Fisher diffusion with\n    selection (kappa), and bidirectional mutation (alpha, beta).\n\n    The calculation is performed in log-space to maintain numerical stability.\n    The integral part of the formula is computed using high-accuracy numerical quadrature.\n    \"\"\"\n    # Precompute log binomial coefficients for all i from 0 to n\n    log_binom_coeffs = gammaln(n + 1) - gammaln(np.arange(n + 1) + 1) - gammaln(n - np.arange(n + 1) + 1)\n\n    log_unnorm_probs = np.zeros(n + 1)\n\n    for i in range(n + 1):\n        # Define exponents for the integrand\n        a = i + alpha\n        b = n - i + beta\n        \n        # The integrand is x^(a-1) * (1-x)^(b-1) * exp(kappa*x).\n        # We define it inside the loop to capture the current values of a, b, and kappa.\n        def integrand(x: float) - float:\n            # The exponents a-1 and b-1 can be negative if alpha or beta are  1,\n            # creating integrable singularities at x=0 or x=1. `quad` handles this.\n            return x**(a - 1) * (1 - x)**(b - 1) * np.exp(kappa * x)\n        \n        # Perform numerical integration with high precision.\n        # The problem requires at least 1e-10 absolute accuracy.\n        integral_val, _ = quad(integrand, 0, 1, epsabs=1e-12, epsrel=1e-12)\n        \n        # Safeguard against numerical underflow where integral becomes non-positive.\n        if integral_val = 0:\n            log_unnorm_probs[i] = -np.inf\n        else:\n            log_unnorm_probs[i] = log_binom_coeffs[i] + np.log(integral_val)\n\n    # Normalize the probabilities using the log-sum-exp trick for stability\n    max_log_prob = np.max(log_unnorm_probs)\n    \n    # If all probabilities underflow to -inf, this would cause an error.\n    # Return uniform log-probabilities as a failsafe.\n    if not np.isfinite(max_log_prob):\n        return np.full(n + 1, -np.log(n + 1))\n        \n    log_shifted_probs = log_unnorm_probs - max_log_prob\n    log_norm_const = max_log_prob + np.log(np.sum(np.exp(log_shifted_probs)))\n    \n    log_sfs = log_unnorm_probs - log_norm_const\n    return log_sfs\n\ndef make_neg_log_likelihood(counts: list[int], n: int, alpha: float, beta: float):\n    \"\"\"\n    Factory function that creates the negative log-likelihood function for a given dataset.\n    This allows us to pass a simple one-parameter function to the optimizer.\n    \"\"\"\n    counts_arr = np.array(counts, dtype=float)\n    \n    # Memoization cache to store results for previously computed kappa values\n    memo = {}\n\n    def neg_log_likelihood(kappa: float) - float:\n        if kappa in memo:\n            return memo[kappa]\n\n        # Calculate log probabilities of the SFS for the given kappa\n        log_p = _calculate_log_sfs(kappa, n, alpha, beta)\n        \n        # Calculate the log-likelihood as the dot product of counts and log-probabilities.\n        # This correctly handles cases where X_i = 0.\n        log_likelihood = np.dot(counts_arr, log_p)\n        \n        # The optimizer minimizes, so we return the negative log-likelihood.\n        # Handle cases where log-likelihood is -inf (i.e., probability is zero)\n        if not np.isfinite(log_likelihood):\n            result = np.inf\n        else:\n            result = -log_likelihood\n        \n        memo[kappa] = result\n        return result\n        \n    return neg_log_likelihood\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute MLE for kappa.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 10, \"alpha\": 1.0, \"beta\": 1.0, \n            \"kappa_min\":-6.0, \"kappa_max\": 6.0,\n            \"counts\": [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]\n        },\n        {\n            \"n\": 10, \"alpha\": 1.0, \"beta\": 1.0,\n            \"kappa_min\": -6.0, \"kappa_max\": 6.0,\n            \"counts\": [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]\n        },\n        {\n            \"n\": 20, \"alpha\": 0.5, \"beta\": 2.0,\n            \"kappa_min\": -10.0, \"kappa_max\": 10.0,\n            \"counts\": [42, 40, 38, 36, 34, 32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Create the objective function for the current test case\n        neg_log_lik = make_neg_log_likelihood(\n            counts=case[\"counts\"],\n            n=case[\"n\"],\n            alpha=case[\"alpha\"],\n            beta=case[\"beta\"]\n        )\n\n        # Find the minimum of the negative log-likelihood within the specified bounds\n        opt_result = minimize_scalar(\n            neg_log_lik,\n            bounds=(case[\"kappa_min\"], case[\"kappa_max\"]),\n            method='bounded'\n        )\n        \n        # The MLE kappa is the value that minimizes the function\n        kappa_mle = opt_result.x\n        results.append(kappa_mle)\n\n    # Format the final output as specified\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2700942"}]}