{"hands_on_practices": [{"introduction": "理论学习之后，首要的动手实践是将适应度的抽象定义转化为具体的、可预测的计算。本练习将指导你完成这一基本步骤，在一个简化的单倍体群体模型中，根据给定的基因型适应度和初始频率，精确计算下一代群体的基因频率和平均适应度。通过这个计算 ([@problem_id:2832271])，你将掌握自然选择如何直接塑造群体遗传构成的核心机制。", "problem": "一个大的、充分混合的无性单倍体种群由三种基因型组成，索引为 $i \\in \\{1,2,3\\}$。在没有突变、迁移或遗传漂变的单个、离散、不重叠的世代生活史中，每种基因型 $i$ 都有一个恒定的赖特适应度 $w_i$，该适应度决定了其对下一代的预期贡献。在第 $t$ 代开始时，基因型频率向量为 $(p_1, p_2, p_3)$，且满足 $p_1 + p_2 + p_3 = 1$。选择通过差异性存活/繁殖起作用，因此基因型 $i$ 的存活后代预期数量与 $w_i$ 乘以基因型 $i$ 的亲本数量成正比。令 $\\bar{w}$ 表示种群平均适应度（按当前频率加权的各基因型个体平均成功率），令 $(p_1', p_2', p_3')$ 表示经过选择和归一化后第 $t+1$ 代开始时的基因型频率。\n\n在一个特定实验中，第 $t$ 代时三种基因型的适应度为 $w = (1.00, 1.05, 0.98)$，初始频率为 $(p_1, p_2, p_3) = (0.5, 0.3, 0.2)$。严格根据上述定义（基因型贡献与 $w_i$ 成正比，且频率必须归一化为总和等于 1），计算下一代的频率向量 $(p_1', p_2', p_3')$ 和下一代的平均适应度 $\\bar{w}'$。\n\n将您的最终数值结果以单行向量 $(p_1', p_2', p_3', \\bar{w}')$ 的形式报告，每个条目四舍五入到四位有效数字。将条目表示为纯小数（不带百分号）。不应报告其他任何量。", "solution": "该问题提出了一个针对单倍体、无性种群的离散时间群体遗传学标准模型。任务是在给定三种基因型的初始频率和适应度值的情况下，计算下一代的基因型频率和种群平均适应度。问题陈述具有科学依据，提法明确，并包含了所有必要信息。因此，该问题是有效的。\n\n设第 $t$ 代的种群由三种基因型的频率向量 $\\boldsymbol{p} = (p_1, p_2, p_3)$ 描述，其中 $\\sum_{i=1}^{3} p_i = 1$。相应的赖特适应度由向量 $\\boldsymbol{w} = (w_1, w_2, w_3)$ 给出。问题陈述指出，每种基因型对下一代的预期贡献与其适应度和当前频率成正比。\n\n设第 $t$ 代开始时的总种群大小为 $N$。基因型 $i$ 的个体数量为 $N_i = p_i N$。基因型 $i$ 产生的后代数量（我们将其表示为 $N'_i$）与 $w_i N_i$ 成正比。因此，我们可以写成 $N'_i = C w_i N_i$，其中 $C$ 是对所有基因型都相同的比例常数。\n\n在归一化之前，后代总个体数是所有基因型数量的总和：\n$$N' = \\sum_{i=1}^{3} N'_i = \\sum_{i=1}^{3} C w_i N_i = C \\sum_{i=1}^{3} w_i (p_i N) = C N \\sum_{i=1}^{3} w_i p_i$$\n下一代基因型 $i$ 的频率 $p'_i$ 是其后代数量与后代总数的比率：\n$$p'_i = \\frac{N'_i}{N'} = \\frac{C w_i N_i}{\\sum_{j=1}^{3} C w_j N_j} = \\frac{w_i (p_i N)}{\\sum_{j=1}^{3} w_j (p_j N)}$$\n常数 $C$ 和 $N$ 相互抵消，得到基本递推关系：\n$$p'_i = \\frac{p_i w_i}{\\sum_{j=1}^{3} p_j w_j}$$\n分母是第 $t$ 代的种群平均适应度，定义为个体适应度的加权平均值：\n$$\\bar{w} = \\sum_{i=1}^{3} p_i w_i$$\n因此，第 $t+1$ 代基因型 $i$ 的频率由下式给出：\n$$p'_i = \\frac{p_i w_i}{\\bar{w}}$$\n第 $t$ 代的给定数据为：\n- 频率： $(p_1, p_2, p_3) = (0.5, 0.3, 0.2)$\n- 适应度： $(w_1, w_2, w_3) = (1.00, 1.05, 0.98)$\n\n首先，我们计算第 $t$ 代的平均适应度 $\\bar{w}$：\n$$\\bar{w} = p_1 w_1 + p_2 w_2 + p_3 w_3$$\n$$\\bar{w} = (0.5)(1.00) + (0.3)(1.05) + (0.2)(0.98) = 0.500 + 0.315 + 0.196 = 1.011$$\n现在我们可以计算下一代的频率 $(p'_1, p'_2, p'_3)$：\n$$p'_1 = \\frac{p_1 w_1}{\\bar{w}} = \\frac{(0.5)(1.00)}{1.011} = \\frac{0.500}{1.011} \\approx 0.4945598...$$\n$$p'_2 = \\frac{p_2 w_2}{\\bar{w}} = \\frac{(0.3)(1.05)}{1.011} = \\frac{0.315}{1.011} \\approx 0.3115727...$$\n$$p'_3 = \\frac{p_3 w_3}{\\bar{w}} = \\frac{(0.2)(0.98)}{1.011} = \\frac{0.196}{1.011} \\approx 0.1938674...$$\n问题要求将这些值四舍五入到四位有效数字：\n- $p'_1 \\approx 0.4946$\n- $p'_2 \\approx 0.3116$\n- $p'_3 \\approx 0.1939$\n\n接下来，我们必须计算第 $t+1$ 代种群的平均适应度，记为 $\\bar{w}'$。这是使用新计算的频率 $(p'_1, p'_2, p'_3)$ 来计算的：\n$$\\bar{w}' = p'_1 w_1 + p'_2 w_2 + p'_3 w_3$$\n为避免舍入误差的传播，我们应该代入 $p'_i$ 的精确表达式：\n$$\\bar{w}' = \\sum_{i=1}^{3} p'_i w_i = \\sum_{i=1}^{3} \\left(\\frac{p_i w_i}{\\bar{w}}\\right) w_i = \\frac{1}{\\bar{w}} \\sum_{i=1}^{3} p_i w_i^2$$\n我们首先计算总和 $\\sum_{i=1}^{3} p_i w_i^2$：\n$$\\sum_{i=1}^{3} p_i w_i^2 = (0.5)(1.00)^2 + (0.3)(1.05)^2 + (0.2)(0.98)^2$$\n$$\\sum_{i=1}^{3} p_i w_i^2 = (0.5)(1.0000) + (0.3)(1.1025) + (0.2)(0.9604)$$\n$$\\sum_{i=1}^{3} p_i w_i^2 = 0.50000 + 0.33075 + 0.19208 = 1.02283$$\n现在，我们可以求出 $\\bar{w}'$：\n$$\\bar{w}' = \\frac{1.02283}{1.011} \\approx 1.01170128...$$\n四舍五入到四位有效数字得到：\n- $\\bar{w}' \\approx 1.012$\n\n最终结果是行向量 $(p'_1, p'_2, p'_3, \\bar{w}')$，每个条目四舍五入到四位有效数字。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4946  0.3116  0.1939  1.012\n\\end{pmatrix}\n}\n$$", "id": "2832271"}, {"introduction": "虽然单基因座模型是理论基石，但真实的基因组包含着众多相互作用的基因。这个练习将引导你探索一个更复杂的双基因座系统，其中基因间的上位性效应和重组共同作用，可能导致群体平均适应度下降 ([@problem_id:2714095])。这一反直觉的结果挑战了对费雪基本定理的过度简化理解，并凸显了在分析进化动态时考虑基因连锁和相互作用的必要性。", "problem": "考虑一个单倍体双基因座系统，其位点为 $A/a$ 和 $B/b$。在每一代中，生存力选择发生在重组之前。四种单倍型 $AB$, $Ab$, $aB$, 和 $ab$ 具有恒定的基因型特异性绝对生存力 $w_{AB}$, $w_{Ab}$, $w_{aB}$, 和 $w_{ab}$，它们编码了如下的正向上位性：$w_{AB} = 1 + s$, $w_{Ab} = 1 - c$, $w_{aB} = 1 - c$, 和 $w_{ab} = 1 + s$，其中 $s = 0.2$ 且 $c = 0.1$。假设在繁殖过程中发生自由重组 $r = 0.5$。在第 $t$ 代开始时，单倍型频率为 $x_{AB}(t) = 0.49$, $x_{Ab}(t) = 0.01$, $x_{aB}(t) = 0.01$, 和 $x_{ab}(t) = 0.49$。\n\n将第 $t$ 代开始时的平均绝对适应度定义为 $\\bar{w}_t = \\sum_{h \\in \\{AB, Ab, aB, ab\\}} x_h(t)\\, w_h$，同样地，下一代开始时的平均绝对适应度为 $\\bar{w}_{t+1} = \\sum_{h} x_h(t+1)\\, w_h$，其中 $x_h(t+1)$ 是由第 $t$ 代中被选择的配子形成的重组后单倍型频率。仅使用生存力选择、重组和单倍型频率的标准定义，计算在此生命周期下一个世代内平均绝对适应度的精确净变化量 $\\Delta \\bar{w} = \\bar{w}_{t+1} - \\bar{w}_t$。请以一个精确的数字（一个最简分数）给出你的最终答案。此外，请在您的解题过程中简要解释这个例子如何规避了经典结果（即选择下平均适应度增加）所要求的假设。", "solution": "问题要求计算一个单倍体双基因座系统在一个世代内平均绝对适应度的精确净变化量 $\\Delta \\bar{w} = \\bar{w}_{t+1} - \\bar{w}_t$。解答需要按照指定的生命周期进行分步计算：先生存力选择，然后重组。\n\n首先，我们列出给定的参数和初始条件。\n绝对生存力为：\n$w_{AB} = 1 + s = 1 + 0.2 = 1.2 = \\frac{6}{5}$\n$w_{Ab} = 1 - c = 1 - 0.1 = 0.9 = \\frac{9}{10}$\n$w_{aB} = 1 - c = 1 - 0.1 = 0.9 = \\frac{9}{10}$\n$w_{ab} = 1 + s = 1 + 0.2 = 1.2 = \\frac{6}{5}$\n\n重组率为 $r = 0.5 = \\frac{1}{2}$。\n\n在第 $t$ 代开始时，单倍型频率为：\n$x_{AB}(t) = 0.49 = \\frac{49}{100}$\n$x_{Ab}(t) = 0.01 = \\frac{1}{100}$\n$x_{aB}(t) = 0.01 = \\frac{1}{100}$\n$x_{ab}(t) = 0.49 = \\frac{49}{100}$\n\n总频率为 $\\sum_h x_h(t) = \\frac{49}{100} + \\frac{1}{100} + \\frac{1}{100} + \\frac{49}{100} = \\frac{100}{100} = 1$，符合要求。\n\n第一步是计算第 $t$ 代开始时的平均绝对适应度 $\\bar{w}_t$。\n$$ \\bar{w}_t = \\sum_{h} x_h(t) w_h $$\n$$ \\bar{w}_t = x_{AB}(t)w_{AB} + x_{Ab}(t)w_{Ab} + x_{aB}(t)w_{aB} + x_{ab}(t)w_{ab} $$\n$$ \\bar{w}_t = \\left(\\frac{49}{100}\\right)\\left(\\frac{6}{5}\\right) + \\left(\\frac{1}{100}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{1}{100}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{49}{100}\\right)\\left(\\frac{6}{5}\\right) $$\n$$ \\bar{w}_t = 2 \\left[ \\frac{294}{500} + \\frac{9}{1000} \\right] = 2 \\left[ \\frac{588}{1000} + \\frac{9}{1000} \\right] = 2 \\left( \\frac{597}{1000} \\right) = \\frac{1194}{1000} = \\frac{597}{500} $$\n\n接下来，我们计算生存力选择后的单倍型频率，记为 $x'_h$。这些是重组前配子库中的频率。\n$$ x'_h = \\frac{x_h(t) w_h}{\\bar{w}_t} $$\n对于 $AB$ 单倍型：\n$$ x'_{AB} = \\frac{(\\frac{49}{100})(\\frac{6}{5})}{\\frac{597}{500}} = \\frac{\\frac{294}{500}}{\\frac{597}{500}} = \\frac{294}{597} = \\frac{98}{199} $$\n根据对称性， $x'_{ab} = x'_{AB} = \\frac{98}{199}$。\n对于 $Ab$ 单倍型：\n$$ x'_{Ab} = \\frac{(\\frac{1}{100})(\\frac{9}{10})}{\\frac{597}{500}} = \\frac{\\frac{9}{1000}}{\\frac{1194}{1000}} = \\frac{9}{1194} = \\frac{3}{398} $$\n根据对称性， $x'_{aB} = x'_{Ab} = \\frac{3}{398}$。\n我们可以检查它们的和是否为 $1$：$2 \\times \\frac{98}{199} + 2 \\times \\frac{3}{398} = \\frac{196}{199} + \\frac{3}{199} = \\frac{199}{199} = 1$。\n\n现在，我们对重组进行建模。第 $t+1$ 代开始时的频率，记为 $x_h(t+1)$，由选择后的频率 $x'_h$ 形成。递归方程为：\n$x_{AB}(t+1) = x'_{AB} - r D'$\n$x_{Ab}(t+1) = x'_{Ab} + r D'$\n$x_{aB}(t+1) = x'_{aB} + r D'$\n$x_{ab}(t+1) = x'_{ab} - r D'$\n其中 $D'$ 是选择后的连锁不平衡系数：\n$$ D' = x'_{AB} x'_{ab} - x'_{Ab} x'_{aB} = \\left(\\frac{98}{199}\\right)^2 - \\left(\\frac{3}{398}\\right)^2 $$\n为了简化，我们注意到 $\\frac{98}{199} = \\frac{196}{398}$。\n$$ D' = \\left(\\frac{196}{398}\\right)^2 - \\left(\\frac{3}{398}\\right)^2 = \\frac{196^2 - 3^2}{398^2} = \\frac{(196-3)(196+3)}{(2 \\times 199)^2} = \\frac{193 \\times 199}{4 \\times 199^2} = \\frac{193}{4 \\times 199} = \\frac{193}{796} $$\n对于相引单倍型，重组引起的变化是 $-rD'$；对于相斥单倍型，重组引起的变化是 $+rD'$。当 $r=1/2$ 时：\n$$ rD' = \\frac{1}{2} \\times \\frac{193}{796} = \\frac{193}{1592} $$\n现在我们求第 $t+1$ 代的频率：\n$$ x_{AB}(t+1) = x'_{AB} - rD' = \\frac{98}{199} - \\frac{193}{1592} = \\frac{98 \\times 8}{199 \\times 8} - \\frac{193}{1592} = \\frac{784 - 193}{1592} = \\frac{591}{1592} $$\n根据对称性， $x_{ab}(t+1) = \\frac{591}{1592}$。\n$$ x_{Ab}(t+1) = x'_{Ab} + rD' = \\frac{3}{398} + \\frac{193}{1592} = \\frac{3 \\times 4}{398 \\times 4} + \\frac{193}{1592} = \\frac{12 + 193}{1592} = \\frac{205}{1592} $$\n根据对称性， $x_{aB}(t+1) = \\frac{205}{1592}$。\n\n接下来，我们计算第 $t+1$ 代开始时的平均绝对适应度 $\\bar{w}_{t+1}$。\n$$ \\bar{w}_{t+1} = \\sum_{h} x_h(t+1) w_h $$\n$$ \\bar{w}_{t+1} = \\left(\\frac{591}{1592}\\right)\\left(\\frac{6}{5}\\right) + \\left(\\frac{205}{1592}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{205}{1592}\\right)\\left(\\frac{9}{10}\\right) + \\left(\\frac{591}{1592}\\right)\\left(\\frac{6}{5}\\right) $$\n$$ \\bar{w}_{t+1} = \\frac{1}{1592} \\left[ 2 \\times 591 \\times \\frac{6}{5} + 2 \\times 205 \\times \\frac{9}{10} \\right] $$\n$$ \\bar{w}_{t+1} = \\frac{1}{1592} \\left[ \\frac{7092}{5} + \\frac{3690}{10} \\right] = \\frac{1}{1592} \\left[ \\frac{7092}{5} + \\frac{1845}{5} \\right] = \\frac{1}{1592} \\left[ \\frac{8937}{5} \\right] = \\frac{8937}{7960} $$\n\n最后，我们计算平均绝对适应度的净变化量 $\\Delta \\bar{w}$。\n$$ \\Delta \\bar{w} = \\bar{w}_{t+1} - \\bar{w}_t = \\frac{8937}{7960} - \\frac{597}{500} $$\n为了对这两个分数进行减法运算，我们找到一个公分母。$7960 = 2^3 \\times 5 \\times 199$ 且 $500 = 2^2 \\times 5^3$。最小公倍数为 $2^3 \\times 5^3 \\times 199 = 199000$。\n$$ \\Delta \\bar{w} = \\frac{8937 \\times (199000/7960)}{199000} - \\frac{597 \\times (199000/500)}{199000} $$\n$$ \\Delta \\bar{w} = \\frac{8937 \\times 25}{199000} - \\frac{597 \\times 398}{199000} $$\n$$ 8937 \\times 25 = 223425 $$\n$$ 597 \\times 398 = 237606 $$\n$$ \\Delta \\bar{w} = \\frac{223425 - 237606}{199000} = \\frac{-14181}{199000} $$\n分子的质因数为 $14181 = 3 \\times 4727$。分母的质因数为 $199000 = 2^3 \\times 5^3 \\times 199$。没有公因数，所以该分数是最简形式。\n\n平均适应度总是增加的经典结果，通常被看作是Fisher自然选择基本定理的简化解释，并非普遍适用。在这个例子中，由于**上位性**和**重组**的相互作用，该结果被规避了。\n适应度景观表现出强烈的正向上位性：“相引”单倍型 $AB$ 和 $ab$ 的适应度 ($w=1.2$) 显著高于“相斥”单倍型 $Ab$ 和 $aB$ ($w=0.9$)。群体开始时处于正连锁不平衡状态 ($D(t) = 0.49^2 - 0.01^2 = 0.24 > 0$)，这意味着适应性强的单倍型过量。选择的作用是进一步富集这些单倍型，这在世代内增加了平均适应度。然而，重组的作用是打破这些有利的等位基因组合，产生更多适应性较差的相斥单倍型。在这个具体案例中，由重组引起的平均适应度下降幅度大于由选择引起的上升幅度，导致从一代到下一代的平均适应度出现净减少（$\\Delta \\bar{w}  0$）。这表明，在具有上位性的多基因座系统中，重组可以导致平均适应度下降，使群体偏离适应度峰值。", "answer": "$$ \\boxed{-\\frac{14181}{199000}} $$", "id": "2714095"}, {"introduction": "现代进化生物学的核心挑战之一是从带有噪声的时间序列数据中估计选择系数。本练习将理论与实践相结合，要求你构建一个状态空间模型，以区分选择、遗传漂变和测序错误这三个过程的信号 ([@problem_id:2714110])。通过完成这个计算任务，你将掌握从经验数据中进行进化参数推断的基本方法，这是一项在当代定量进化研究中至关重要的技能。", "problem": "您的任务是构建一个结合了 Wright–Fisher 漂变和选择的离散时间状态空间模型，并用它从包含测序错误的等位基因计数时间序列中推断未知的选择系数。您的程序必须实现以下模型和推断过程，然后报告指定测试套件的结果。\n\n模型规范\n\n- 隐藏状态：令 $K_t \\in \\{0,1,\\dots,2N_e\\}$ 表示在离散世代 $t$ 时焦点等位基因的潜在计数，其中 $N_e$ 是有效种群大小，$2N_e$ 是二倍体基因拷贝数。\n\n- 选择与繁殖：假设每个世代都有基因选择作用于焦点等位基因，选择系数为 $s$，产生漂变前的等位基因频率\n$$\np^{\\text{sel}}_t = \\frac{p_t (1+s)}{1 + s p_t},\n$$\n其中 $p_t = K_t/(2N_e)$。然后通过抽样（遗传漂变）产生下一代的计数\n$$\nK_{t+1} \\sim \\mathrm{Binomial}\\!\\left(2N_e,\\, p^{\\text{sel}}_t\\right).\n$$\n\n- 带测序错误的观测模型：在每个世代 $t$，您观测到总共 $R_t$ 个测序读数中，焦点等位基因的读数计数为 $X_t$，每个读数的对称错误率为 $\\varepsilon$。在测序中将一个读数判断为焦点等位基因的概率是\n$$\nq_t = \\varepsilon + (1 - 2\\varepsilon) p_t.\n$$\n在给定 $K_t$ 的条件下，观测值为\n$$\nX_t \\sim \\mathrm{Binomial}(R_t, q_t).\n$$\n\n- 先验：对初始隐藏状态使用无信息先验，$K_0 \\sim \\mathrm{Uniform}\\{0,1,\\dots, 2N_e\\}$。\n\n推断目标与方法\n\n- 目标：未知的选择系数 $s$。\n\n- 似然：给定观测计数的 $s$ 的边际似然是通过对所有隐藏状态轨迹求和得到的。使用类似于隐马尔可夫模型（HMM）中的前向算法计算此边际似然：通过 Wright–Fisher (WF) 转移核迭代传播关于 $K_t$ 的预测分布，并在每个时间点使用二项观测似然进行更新。\n\n- 点估计：返回在一个候选值网格上使边际似然最大化的值 $s^\\star$。\n\n模型基础\n\n- 使用经典的带选择的 Wright–Fisher 模型和用于漂变的二项抽样。\n\n- 对测序计数使用带对称误判概率 $\\varepsilon$ 的二项模型。\n\n- 所有计算都应基于概率和概率质量函数，并在需要时通过对数伽马函数进行数值稳定的评估。\n\n测试套件\n\n对于下方的每种情况，首先使用上述精确的生成模型模拟一个合成时间序列，然后执行推断以通过网格搜索估计 $s$。模拟和推断都必须使用相同的 $N_e$、$\\varepsilon$、读数深度 $\\{R_t\\}$、时间点数 $T$ 和初始等位基因频率 $p_0$。模拟协议如下：\n\n- 初始化 $K_0 \\sim \\mathrm{Binomial}(2N_e, p_0)$。\n\n- 对于 $t = 0,1,\\dots,T-1$：\n    - 生成 $X_t \\sim \\mathrm{Binomial}(R_t, \\varepsilon + (1 - 2\\varepsilon) K_t/(2N_e))$。\n    - 计算 $p^{\\text{sel}}_t = \\frac{(K_t/(2N_e)) (1+s_{\\text{true}})}{1 + s_{\\text{true}} (K_t/(2N_e))}$。\n    - 抽样 $K_{t+1} \\sim \\mathrm{Binomial}(2N_e, p^{\\text{sel}}_t)$。\n\n每种情况使用固定的伪随机种子以确保确定性。然后，给定观测到的 $\\{X_t\\}$ 和 $\\{R_t\\}$，通过在网格 $s \\in \\{-0.200, -0.195, \\dots, 0.200\\}$ 上最大化边际似然来估计 $s$。\n\n提供以下三种情况的结果：\n\n- 情况 A（理想情况，正选择）：\n    - $N_e = 100$，$s_{\\text{true}} = 0.050$，$\\varepsilon = 0.010$，$p_0 = 0.100$，$T = 7$ 个时间点。\n    - 读数深度：对于所有 $t \\in \\{0,\\dots,6\\}$，$R_t = 120$。\n    - 随机种子：$1337$。\n\n- 情况 B（边界情况，中性选择）：\n    - $N_e = 80$，$s_{\\text{true}} = 0.000$，$\\varepsilon = 0.020$，$p_0 = 0.500$，$T = 7$ 个时间点。\n    - 按时间的读数深度：$R = [60, 80, 100, 120, 80, 60, 100]$。\n    - 随机种子：$7$。\n\n- 情况 C（低错误率和不同深度的负选择）：\n    - $N_e = 120$，$s_{\\text{true}} = -0.030$，$\\varepsilon = 0.005$，$p_0 = 0.200$，$T = 7$ 个时间点。\n    - 按时间的读数深度：$R = [100, 100, 150, 150, 120, 120, 100]$。\n    - 随机种子：$2021$。\n\n实现细节和输出格式\n\n- 在适当情况下，通过对数伽马函数对二项概率质量函数进行数值稳定的评估。\n\n- 将所有限制在 $[0,1]$ 范围内的概率通过裁剪到一个小的开区间（如 $[10^{-12}, 1 - 10^{-12}]$）来处理，以避免数值问题。\n\n- 最终输出必须是单行，包含一个逗号分隔的三个选定最大化器 $[s^\\star_A, s^\\star_B, s^\\star_C]$ 的列表，每个都是四舍五入到三位小数的浮点数，并用方括号括起来。\n\n- 本问题不涉及物理单位。\n\n- 本问题不使用角度。\n\n- 可接受分数或小数；不要使用百分号。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[0.045,0.000,-0.030]”）。", "solution": "我们构建一个状态空间模型，其中隐藏的种群遗传过程遵循带选择的 Wright–Fisher 动态，观测过程遵循带对称测序错误的二项抽样。在世代 $t$ 的隐藏状态是等位基因计数 $K_t \\in \\{0, \\dots, 2N_e\\}$，对应的等位基因频率为 $p_t = K_t/(2N_e)$。\n\n基本原理与模型构建\n\n1. 带选择的 Wright–Fisher 转移。在选择系数为 $s$ 的基因选择下，焦点等位基因的相对适应度为 $1+s$。漂变前经过选择后的频率是\n$$\np^{\\text{sel}}_t = \\frac{p_t (1+s)}{1 + s p_t},\n$$\n该公式源自单倍体或加性二倍体（基因型）场景中的标准生存力选择。漂变通过对 $2N_e$ 个基因拷贝进行二项抽样来建模：\n$$\nK_{t+1} \\mid K_t \\sim \\mathrm{Binomial}\\!\\left(2N_e,\\, p^{\\text{sel}}_t\\right).\n$$\n这定义了一个在 $\\{0,\\dots,2N_e\\}$ 上的时间齐次马尔可夫链，其转移核为\n$$\n\\Pr(K_{t+1} = k' \\mid K_t = k; s) = \\binom{2N_e}{k'} \\left(p^{\\text{sel}}(k; s)\\right)^{k'} \\left(1 - p^{\\text{sel}}(k; s)\\right)^{2N_e - k'},\n$$\n其中 $p^{\\text{sel}}(k; s) = \\frac{(k/(2N_e)) (1+s)}{1 + s (k/(2N_e))}$。\n\n2. 带测序错误的观测模型。给定真实频率 $p_t = K_t/(2N_e)$ 和对称的单次读取错误概率 $\\varepsilon$，单次读取被判断为焦点等位基因的概率为\n$$\nq_t = \\varepsilon + (1 - 2\\varepsilon) p_t,\n$$\n这是因为一次读取正确的概率为 $1-\\varepsilon$，被翻转的概率为 $\\varepsilon$；在双等位基因情况下，这导致了对 $p_t$ 的线性变换。给定在时间 $t$ 的总读数为 $R_t$，观测到的计数 $X_t$ 的分布为\n$$\nX_t \\mid K_t \\sim \\mathrm{Binomial}(R_t, q_t).\n$$\n\n3. 先验。我们对初始状态使用无信息先验，$K_0 \\sim \\mathrm{Uniform}\\{0,\\dots,2N_e\\}$，反映了对初始等位基因计数缺乏先验知识。这个先验既不是转移的共轭先验，也不是观测的共轭先验，但对于通过对状态求和来进行有原则的似然计算是足够的。\n\n通过前向算法计算边际似然\n\n令 $\\boldsymbol{\\alpha}_t(k) = \\Pr(K_t = k \\mid X_{0:t}; s)$ 表示在并入时间 $t$ 的观测后得到的滤波分布。前向递归过程如下：\n\n- 在 $t=0$ 初始化：\n$$\n\\tilde{\\alpha}_0(k) = \\Pr(K_0 = k) \\cdot \\Pr(X_0 \\mid K_0 = k; \\varepsilon, R_0),\n$$\n其中对于所有 $k$，$\\Pr(K_0 = k) = 1/(2N_e+1)$。通过 $Z_0 = \\sum_{k} \\tilde{\\alpha}_0(k)$ 进行归一化，得到 $\\boldsymbol{\\alpha}_0(k) = \\tilde{\\alpha}_0(k)/Z_0$。将 $\\log Z_0$ 累加到总对数似然中。\n\n- 对于 $t \\ge 1$ 的归纳：\n    - 预测：\n    $$\n    \\pi_t(k') = \\sum_{k=0}^{2N_e} \\boldsymbol{\\alpha}_{t-1}(k) \\cdot \\Pr(K_t = k' \\mid K_{t-1} = k; s).\n    $$\n    - 用观测更新：\n    $$\n    \\tilde{\\alpha}_t(k') = \\pi_t(k') \\cdot \\Pr(X_t \\mid K_t = k'; \\varepsilon, R_t),\n    $$\n    随后通过 $Z_t = \\sum_{k'} \\tilde{\\alpha}_t(k')$ 进行归一化，并设置 $\\boldsymbol{\\alpha}_t(k') = \\tilde{\\alpha}_t(k')/Z_t$。将 $\\log Z_t$ 累加到总对数似然中。\n\n总边际对数似然为\n$$\n\\log \\mathcal{L}(s) = \\sum_{t=0}^{T-1} \\log Z_t,\n$$\n因为每个归一化常数 $Z_t$ 对应于在参数 $s$ 下，给定过去观测值时当前观测值 $X_t$ 的预测概率。\n\n数值稳定评估\n\n- 对于二项概率质量函数 $\\binom{n}{k} p^k (1-p)^{n-k}$，使用对数伽马函数计算 $\\log \\binom{n}{k}$：$\\log \\binom{n}{k} = \\Gamma(n+1) - \\Gamma(k+1) - \\Gamma(n-k+1)$，以 $\\log \\Gamma(\\cdot)$（即 $\\mathrm{gammaln}$）表示。\n\n- 在形成转移矩阵的行和发射向量时，在对数空间中计算概率，仅在必要时减去合适的偏移量后才取指数，并将 $p$ 和 $q$ 裁剪到 $[10^{-12}, 1 - 10^{-12}]$ 以避免 $\\log 0$。\n\n点估计\n\n- 定义一个候选选择系数的网格 $s \\in \\{-0.200, -0.195, \\dots, 0.200\\}$。\n\n- 对于网格上的每个 $s$，构建转移核并运行前向算法来计算 $\\log \\mathcal{L}(s)$。\n\n- 选择最大似然估计（MLE）$s^\\star = \\arg\\max_s \\log \\mathcal{L}(s)$。\n\n测试套件的模拟\n\n对于每种情况，使用相同的模型模拟一个数据集：\n\n- 初始化 $K_0 \\sim \\mathrm{Binomial}(2N_e, p_0)$。\n\n- 对于 $t = 0,\\dots,T-1$：\n    - 生成 $X_t \\sim \\mathrm{Binomial}(R_t, \\varepsilon + (1-2\\varepsilon) K_t/(2N_e))$。\n    - 计算 $p^{\\text{sel}}_t = \\frac{(K_t/(2N_e))(1+s_{\\text{true}})}{1 + s_{\\text{true}} (K_t/(2N_e))}$。\n    - 抽样 $K_{t+1} \\sim \\mathrm{Binomial}(2N_e, p^{\\text{sel}}_t)$。\n\n使用指定的固定种子以保证可复现性。\n\n算法结构\n\n- 对于每种情况，使用给定的参数和种子生成观测计数。\n\n- 对于每种情况，遍历 $s$ 网格，为每个 $s$ 构建一次转移矩阵，并使用对 $K_0$ 的均匀先验通过前向递归计算边际对数似然。\n\n- 记录使对数似然最大化的 $s$，四舍五入到三位小数。\n\n输出\n\n- 生成单行，包含三种情况下按顺序排列的三个 MLE，格式为用方括号括起来的逗号分隔列表，例如 $[0.045, 0.000, -0.030]$，每个值四舍五入到三位小数。\n\n这种方法将 Wright–Fisher 漂变与选择的基本定义以及二项观测噪声整合到一个有原则的隐马尔可夫模型似然中，从而能够从带噪声的等位基因计数时间序列中一致地推断选择系数。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef rng(seed):\n    # Simple wrapper for NumPy Generator for reproducibility\n    return np.random.default_rng(seed)\n\ndef log_binom_coeff(n, k):\n    # log binomial coefficient log(C(n,k))\n    return gammaln(n + 1.0) - gammaln(k + 1.0) - gammaln(n - k + 1.0)\n\ndef build_transition_matrix(Ne, s):\n    \"\"\"\n    Build the (2Ne+1) x (2Ne+1) transition matrix T where\n    T[i, j] = P(K_{t+1} = j | K_t = i; s)\n    Using genic selection and Wright-Fisher sampling.\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    T = np.zeros((S, S), dtype=np.float64)\n    # Precompute log binomial coefficients for columns j\n    j = np.arange(S)\n    logC = log_binom_coeff(twoN, j)\n    # For each row i (state k=i)\n    i = np.arange(S)\n    p = i / twoN\n    # Selection-transformed frequency\n    denom = 1.0 + s * p\n    # Avoid division by zero for s near -1\n    denom = np.clip(denom, 1e-12, np.inf)\n    p_sel = p * (1.0 + s) / denom\n    p_sel = np.clip(p_sel, 1e-12, 1.0 - 1e-12)\n    # Fill each row: Binomial(twoN, p_sel[i]) across all j\n    for idx in range(S):\n        ps = p_sel[idx]\n        # log pmf for all j\n        logpmf = logC + j * np.log(ps) + (twoN - j) * np.log(1.0 - ps)\n        # exponentiate safely (values are well-behaved for twoN up to ~300)\n        row = np.exp(logpmf)\n        # Normalize to avoid small numerical drift\n        row_sum = row.sum()\n        if row_sum == 0.0 or not np.isfinite(row_sum):\n            # Fallback normalization in extreme edge cases\n            m = np.max(logpmf)\n            row = np.exp(logpmf - m)\n            row_sum = row.sum()\n        T[idx, :] = row / row_sum\n    return T\n\ndef emission_log_probs_vector(Ne, epsilon, R, X):\n    \"\"\"\n    For a single timepoint with observed X out of R, return a vector of\n    log-likelihoods log P(X | K=k) for k in 0..2Ne, with q = eps + (1-2eps)*p\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    k = np.arange(S)\n    p = k / twoN\n    q = epsilon + (1.0 - 2.0 * epsilon) * p\n    q = np.clip(q, 1e-12, 1.0 - 1e-12)\n    # log binomial pmf\n    logC_RX = log_binom_coeff(R, X)\n    loglik = logC_RX + X * np.log(q) + (R - X) * np.log(1.0 - q)\n    return loglik  # shape (S,)\n\ndef forward_loglikelihood(Ne, epsilon, R_list, X_list, s):\n    \"\"\"\n    Compute the marginal log-likelihood log L(s) via the forward algorithm\n    with a uniform prior over K_0.\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    T = build_transition_matrix(Ne, s)\n    # Initial prior over K_0\n    pi = np.full(S, 1.0 / S, dtype=np.float64)\n    logL = 0.0\n    T_steps = len(X_list)\n    for t in range(T_steps):\n        # Emission update\n        loge = emission_log_probs_vector(Ne, epsilon, R_list[t], X_list[t])\n        # Work in linear space via stable exponentiation\n        m = np.max(loge)\n        e = np.exp(loge - m)\n        # alpha_tilde = pi * e\n        alpha_tilde = pi * e\n        Z = alpha_tilde.sum()\n        if Z == 0.0 or not np.isfinite(Z):\n            # Degenerate; avoid failure by small floor\n            Z = 1e-300\n        logZ = np.log(Z) + m  # account for offset m\n        logL += logZ\n        alpha = alpha_tilde / Z\n        # Prediction to next time (skip after last observation)\n        if t  T_steps - 1:\n            pi = alpha @ T\n            # Numerical safety normalization\n            ssum = pi.sum()\n            if ssum > 0:\n                pi = pi / ssum\n            else:\n                pi = np.full(S, 1.0 / S, dtype=np.float64)\n    return logL\n\ndef simulate_case(Ne, s_true, p0, epsilon, R_list, T, seed):\n    \"\"\"\n    Simulate a dataset:\n    - Initialize K0 ~ Binomial(2Ne, p0)\n    - For t = 0..T-1:\n        - Observe X_t ~ Binomial(R_t, q_t) with q_t = eps + (1-2 eps) * p_t\n        - Compute p_sel and sample K_{t+1} ~ Binomial(2Ne, p_sel)\n    Returns observed counts X_list.\n    \"\"\"\n    twoN = 2 * Ne\n    S = twoN + 1\n    gen = rng(seed)\n    K = gen.binomial(twoN, p0)\n    X_list = []\n    for t in range(T):\n        p = K / twoN\n        q = epsilon + (1.0 - 2.0 * epsilon) * p\n        q = np.clip(q, 1e-12, 1.0 - 1e-12)\n        X = gen.binomial(R_list[t], q)\n        X_list.append(int(X))\n        # Selection and drift to next generation\n        denom = 1.0 + s_true * p\n        denom = max(denom, 1e-12)\n        p_sel = p * (1.0 + s_true) / denom\n        p_sel = float(np.clip(p_sel, 1e-12, 1.0 - 1e-12))\n        K = gen.binomial(twoN, p_sel)\n    return X_list\n\ndef estimate_s_MLE(Ne, epsilon, R_list, X_list, s_grid):\n    best_s = None\n    best_logL = -np.inf\n    for s in s_grid:\n        logL = forward_loglikelihood(Ne, epsilon, R_list, X_list, s)\n        if logL > best_logL:\n            best_logL = logL\n            best_s = s\n    return best_s, best_logL\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Ne, s_true, epsilon, p0, T, R_list, seed)\n    test_cases = [\n        (100, 0.050, 0.010, 0.100, 7, [120]*7, 1337),                        # Case A\n        (80,  0.000, 0.020, 0.500, 7, [60, 80, 100, 120, 80, 60, 100], 7),   # Case B\n        (120, -0.030, 0.005, 0.200, 7, [100, 100, 150, 150, 120, 120, 100], 2021),  # Case C\n    ]\n\n    # Grid of s to search\n    s_grid = np.round(np.arange(-0.200, 0.200 + 0.0005, 0.005), 3)  # ensure inclusive endpoint\n\n    results = []\n    for (Ne, s_true, epsilon, p0, T, R_list, seed) in test_cases:\n        # Simulate observed counts\n        X_list = simulate_case(Ne, s_true, p0, epsilon, R_list, T, seed)\n        # Estimate s by MLE on the grid\n        s_hat, _ = estimate_s_MLE(Ne, epsilon, R_list, X_list, s_grid)\n        # Round to three decimals for output\n        results.append(f\"{s_hat:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "answer": "$$ \\boxed{[0.045, 0.000, -0.030]} $$", "id": "2714110"}]}