{"hands_on_practices": [{"introduction": "现代历史生物地理学模型（如DEC模型）的核心是连续时间马尔可夫链（CTMC），它描述了物种地理分布随时间演化的过程。这个过程的“引擎”是一个称为瞬时速率矩阵（$Q$ 矩阵）的数学对象，它定义了所有可能的地理区系范围之间转换的速率。本练习将引导您从第一性原理出发，基于扩散（$d$）和局域灭绝（$e$）这两个基本参数，亲手构建$Q$矩阵，从而将生物学假设转化为模型的数学语言，巩固您对模型内部工作机制的理解。[@problem_id:2762387]", "problem": "在历史生物地理学的扩散-灭绝-支系形成 (DEC) 模型中，仅考虑在一个包含区域 $\\{A, B\\}$ 的景观上的渐变性变化（谱系内变化）。设状态空间为可能分布区的集合 $\\{\\varnothing, A, B, AB\\}$，其中 $\\varnothing$ 表示无区域占据，$A$ 和 $B$ 分别表示占据单个区域，$AB$ 表示同时占据两个区域。假设渐变性扩散以每个缺失区域为 $d$ 的瞬时速率增加一个缺失区域，而渐变性局域灭绝以每个已占据区域为 $e$ 的瞬时速率移除一个已占据区域。假设不允许同步变化（即一次只能获得或失去一个区域），从空分布区 $\\varnothing$ 没有跃迁（即 $\\varnothing$ 相对于渐变性变化是吸收性的），并且区域间的扩散是对称的。\n\n使用连续时间马尔可夫链 (CTMC) 框架，其中瞬时速率矩阵 $Q$ 的非对角线元素由瞬时跃迁速率给出，对角线元素的设置使得每行之和为 $0$，推导此 DEC 渐变过程的瞬时速率矩阵 $Q$，其行和列的顺序为 $(\\varnothing, A, B, AB)$。明确列出所有非零的非对角线元素。\n\n最后，使用您推导出的 $Q$ 计算 $Q$ 的迹，结果表示为关于 $d$ 和 $e$ 的闭式解析表达式。仅报告此最终表达式；无需进行数值计算或四舍五入。[@problem_id:150]", "solution": "问题陈述已提交以供验证。\n\n步骤 1：提取已知条件。\n- 模型：扩散-灭绝-支系形成 (DEC) 模型，仅考虑渐变性（谱系内）变化。\n- 景观：区域集合 $\\{A, B\\}$。\n- 状态空间：可能分布区的集合为 $\\{\\varnothing, A, B, AB\\}$，其中 $\\varnothing$ 表示无占据， $A$ 表示占据区域 $A$， $B$ 表示占据区域 $B$，$AB$ 表示同时占据两个区域。\n- 扩散速率：渐变性扩散以每个缺失区域为 $d$ 的瞬时速率增加一个缺失区域。\n- 灭绝速率：渐变性局域灭绝以每个已占据区域为 $e$ 的瞬时速率移除一个已占据区域。\n- 约束条件：\n    1. 一次只允许单个区域的变化（获得或失去）；不允许同步变化。\n    2. 空分布区 $\\varnothing$ 是一个相对于渐变性变化的吸收态。\n    3. 区域间的扩散是对称的。\n- 框架：连续时间马尔可夫链 (CTMC)。\n- 瞬时速率矩阵 $Q$：非对角线元素 $Q_{ij}$ ($i \\neq j$) 是从状态 $i$ 到状态 $j$ 的瞬时跃迁速率。对角线元素 $Q_{ii}$ 的设置使得每行之和为 $0$。\n- 矩阵顺序：$Q$ 的行和列按 $(\\varnothing, A, B, AB)$ 顺序排列。\n- 任务 1：推导瞬时速率矩阵 $Q$。\n- 任务 2：明确列出 $Q$ 的所有非零非对角线元素。\n- 任务 3：计算 $Q$ 的迹 $\\text{tr}(Q)$，作为闭式解析表达式。\n\n步骤 2：使用提取的已知条件进行验证。\n- 科学依据：该问题基于已确立的理论。DEC 模型及其作为连续时间马尔可夫链的表示，是历史生物地理学和计算系统发育学领域的标准基础工具。该模型设置是分布区演化过程的一个简化但有效的表示。\n- 适定性：该问题是适定的。构建跃迁速率的规则是明确的，并且足以唯一确定速率矩阵 $Q$ 的所有元素。迹的计算是对所得矩阵的一个明确定义的数学运算。\n- 客观性：该问题以精确、客观和量化的术语陈述。不存在主观或基于观点的论断。\n\n步骤 3：结论与行动。\n该问题有效。这是将 CTMC 原理应用于生物学模型的标准练习。开始求解。\n\n该问题要求为描述渐变性分布区演化的 CTMC 构建一个 $4 \\times 4$ 的瞬时速率矩阵 $Q$。状态排序为 $S_1 = \\varnothing$，$S_2 = A$，$S_3 = B$，以及 $S_4 = AB$。对于 $i \\neq j$，$Q_{ij}$ 元素表示从状态 $i$ 到状态 $j$ 的瞬时跃迁速率。对角线元素 $Q_{ii}$ 是离开状态 $i$ 的所有速率之和的负值。\n\n我们逐行构建该矩阵。\n\n第 1 行：从状态 $S_1 = \\varnothing$ 的跃迁。\n问题陈述指出 $\\varnothing$ 是一个吸收态。这意味着谱系不能无中生有（没有从 $\\varnothing$ 跃迁出去的可能）。\n因此，所有非对角线速率均为零：\n$Q_{12} = 0$，$Q_{13} = 0$，$Q_{14} = 0$。\n对角线元素为 $Q_{11} = -(Q_{12} + Q_{13} + Q_{14}) = 0$。\n\n第 2 行：从状态 $S_2 = A$ 的跃迁。\n- 到 $S_1 = \\varnothing$：这是一个灭绝事件。状态 $A$ 有 1 个已占据区域。速率为每个已占据区域 $e$。因此，失去这单个区域的速率是 $1 \\times e = e$。所以，$Q_{21} = e$。\n- 到 $S_3 = B$：此跃迁需要同时失去区域 $A$ 并获得区域 $B$。问题禁止同步变化。所以，$Q_{23} = 0$。\n- 到 $S_4 = AB$：这是一个扩散事件。状态 $A$ 缺少 1 个区域 ($B$)。速率为每个缺失区域 $d$。因此，获得区域 $B$ 的速率是 $1 \\times d = d$。所以，$Q_{24} = d$。\n对角线元素是 $Q_{22} = -(Q_{21} + Q_{23} + Q_{24}) = -(e + 0 + d) = -(d+e)$。\n\n第 3 行：从状态 $S_3 = B$ 的跃迁。\n- 到 $S_1 = \\varnothing$：这是一个灭绝事件。状态 $B$ 有 1 个已占据区域。速率为每个已占据区域 $e$。因此，失去这个区域的速率是 $1 \\times e = e$。所以，$Q_{31} = e$。\n- 到 $S_2 = A$：与 $A \\to B$ 一样，此跃迁需要同步的失去和获得，这是不允许的。所以，$Q_{32} = 0$。\n- 到 $S_4 = AB$：这是一个扩散事件。状态 $B$ 缺少 1 个区域 ($A$)。速率为每个缺失区域 $d$。因此，获得区域 $A$ 的速率是 $1 \\times d = d$。所以，$Q_{34} = d$。\n对角线元素是 $Q_{33} = -(Q_{31} + Q_{32} + Q_{34}) = -(e + 0 + d) = -(d+e)$。\n\n第 4 行：从状态 $S_4 = AB$ 的跃迁。\n- 到 $S_1 = \\varnothing$：这需要同时失去 2 个区域，这是不允许的。所以，$Q_{41} = 0$。\n- 到 $S_2 = A$：这是一个灭绝事件，区域 $B$ 失去。状态 $AB$ 有 2 个已占据区域。灭绝速率为每个区域 $e$。失去区域 $B$ 这个特定事件的速率是 $e$。所以，$Q_{42} = e$。\n- 到 $S_3 = B$：这是一个灭绝事件，区域 $A$ 失去。失去区域 $A$ 这个特定事件的速率是 $e$。所以，$Q_{43} = e$。\n- 离开状态 $AB$ 的总速率是所有可能的单次变化事件速率之和。由于没有缺失的区域，扩散是不可能的。灭绝可以通过失去 $A$（速率 $e$）或失去 $B$（速率 $e$）发生。因此，总的离开速率为 $e+e=2e$。\n对角线元素是 $Q_{44} = -(Q_{41} + Q_{42} + Q_{43}) = -(0 + e + e) = -2e$。\n\n将这些元素组合起来，得到完整的瞬时速率矩阵 $Q$：\n$$\nQ = \\begin{pmatrix}\n0   0   0   0 \\\\\ne   -(d+e)  0   d \\\\\ne   0  -(d+e)  d \\\\\n0   e   e   -2e\n\\end{pmatrix}\n$$\n\n问题要求列出所有非零的非对角线元素。它们是：\n- $Q_{21} = e$ (从 $A$ 的灭绝)\n- $Q_{24} = d$ (从 $A$ 的扩散)\n- $Q_{31} = e$ (从 $B$ 的灭绝)\n- $Q_{34} = d$ (从 $B$ 的扩散)\n- $Q_{42} = e$ (从 $AB$ 到 $A$ 的灭绝)\n- $Q_{43} = e$ (从 $AB$ 到 $B$ 的灭绝)\n\n最后，我们必须计算 $Q$ 的迹，记为 $\\text{tr}(Q)$。迹是矩阵对角线元素之和。\n$$\n\\text{tr}(Q) = Q_{11} + Q_{22} + Q_{33} + Q_{44}\n$$\n代入推导出的值：\n$$\n\\text{tr}(Q) = 0 + \\left(-(d+e)\\right) + \\left(-(d+e)\\right) + \\left(-2e\\right)\n$$\n$$\n\\text{tr}(Q) = -d - e - d - e - 2e\n$$\n$$\n\\text{tr}(Q) = -2d - 4e\n$$\n这就是所要求的矩阵 $Q$ 的迹的闭式解析表达式。", "answer": "$$\n\\boxed{-2d - 4e}\n$$", "id": "2762387"}, {"introduction": "在掌握了生物地理学模型的内部机制后，一项至关重要的技能是如何批判性地应用它。模型的优劣取决于其假设的合理性，而忽略地质历史等外部证据可能导致与事实相悖的荒谬结论。本练习设置了一个真实情景，展示了一个简化模型在分析中如何失效，旨在挑战您识别模型结果与地质事实之间的矛盾，并学会运用时间分层（time-stratification）这一标准方法来修正模型。[@problem_id:2762446]", "problem": "一位研究人员正在拟合一个时间非齐次连续时间马尔可夫链 (CTMC) 模型，以研究一个分布在两个区域（大陆 $M$ 和海洋岛屿 $I$）的演化支的地理分布范围演化。在该模型中，分布范围之间的转换由随时间变化的扩散速率 $d(t)$ 和一个随时间变化的邻接矩阵 $\\mathbf{A}(t)$ 驱动，该矩阵编码了两个区域在时间 $t$（时间以百万年前，即 Ma 为单位测量）是否地理上相连或可达。该研究人员最初拟合了一个未分层模型，该模型假设扩散速率恒定 $d(t)=d$ 且邻接关系不随时间变化（完全邻接）$\\mathbf{A}(t)=\\mathbf{1}$，同时保持灭绝速率 $e$ 在整个时间内恒定。\n\n该系统的已知地质情况如下：海洋岛屿 $I$ 是一个火山岛，在 $3$ Ma 首次出现在海平面以上，而大陆 $M$ 一直存在。一个经过良好校准的分子系统发育分析表明，该演化支中两个姐妹谱系的冠群分化发生在 $8$ Ma；如今，一个谱系是 $I$ 的特有种，另一个是 $M$ 的特有种。\n\n在未分层模型的拟合下，8 Ma 节点上的最大似然祖先分布范围被推断为 $M+I$（同时占据两个区域）。这一推断与地质记录相矛盾。\n\n哪个选项正确地指出了矛盾之处，并描述了当 $d(t)$ 受到地质学所施加的邻接变化的约束后，应采取的适当修正方法？\n\nA. 矛盾在于 8 Ma 时的地理隔离需要一个从未存在过的预先存在的陆桥。修正方法是为 $t3$ Ma 增加灭绝速率 $e$，以便 $I$ 在出现后迅速消失；不需要对 $d(t)$ 或 $\\mathbf{A}(t)$ 进行约束。\n\nB. 矛盾在于，尽管 $I$ 直到 3 Ma 才存在，但推断将 $I$ 置于 8 Ma 的祖先分布范围内。修正方法是通过在 $\\mathbf{A}(t)$ 中为 $t3$ Ma（即 $I$ 出现之前）设置扩散乘数 $m_{MI}(t)=0$ 来进行时间分层，这迫使当时的 $d_{MI}(t)=d\\cdot m_{MI}(t)=0$；这禁止了在 3 Ma 之前对 $I$ 的占据或向 $I$ 的扩散，从而得出 8 Ma 时的祖先分布范围为 $M$，以及随后在 3 Ma 之后，岛屿谱系向 $I$ 扩散。\n\nC. 矛盾在于模型允许在 3 Ma 之前在 $M$ 上发生灭绝。修正方法是为 $t3$ Ma 设置 $e(t)=0$，这样谱系在岛屿出现前就不能在 $M$ 上灭绝；相反，应为 $t3$ Ma 增加 $d(t)$ 以鼓励对 $I$ 的早期定殖。\n\nD. 矛盾在于模型未能在 8 Ma 时允许奠基者事件成种。修正方法是通过为 $t8$ Ma 设置非常高的 $d(t)$，在 8 Ma 时强制进行以 $M$ 和 $I$ 为子代分布范围的地理隔离分裂，因为高 $d(t)$ 会使所有分裂实际上都成为地理隔离分裂，而不管邻接性如何。", "solution": "问题将首先经过严格验证。\n\n**步骤1：提取已知信息**\n-   模型类型：时间非齐次连续时间马尔可夫链 (CTMC)。\n-   地理区域：大陆 $M$ 和海洋岛屿 $I$。\n-   模型参数：随时间变化的扩散速率 $d(t)$，随时间变化的邻接矩阵 $\\mathbf{A}(t)$，以及恒定的灭绝速率 $e$。\n-   时间尺度：$t$ 以百万年前（Ma）为单位测量。\n-   未分层模型假设：$d(t) = d$（恒定），$\\mathbf{A}(t) = \\mathbf{1}$（完全邻接，其中 $\\mathbf{1}$ 是一个全为1的矩阵），且 $e$ 恒定。\n-   地质数据：岛屿 $I$ 在 3 Ma 出现。大陆 $M$ 一直存在。\n-   系统发育数据：两个姐妹谱系的冠群分化发生在 8 Ma。一个谱系是 $I$ 的特有种，另一个是 $M$ 的特有种。\n-   未分层模型的结果：8 Ma 节点的最大似然祖先分布范围被推断为 $M+I$。\n-   前提：在 8 Ma 推断出分布范围 $M+I$ 与地质记录相矛盾。\n-   目标：通过地质学上关于邻接性的信息来约束 $d(t)$，从而找出对矛盾的正确陈述以及对模型的适当修正。\n\n**步骤2：使用提取的已知信息进行验证**\n问题陈述具有科学依据、提法得当且客观。\n-   **科学依据**：该问题使用了历史生物地理学和系统发育学中的标准概念和模型。CTMC 模型，如扩散-灭绝-成种 (DEC) 模型及其扩展，是祖先分布范围估计的主要工具。所呈现的情景——一个简单模型的推断与外部地质数据之间的冲突——是科学建模中一个常见且现实的问题，需要对模型进行改进。\n-   **提法得当**：该问题结构清晰。它提供了一组初始条件、一个模型、一个观察结果（系统发育模式）、一个来自简单模型的冲突结果，以及可验证的外部数据（地质学）。它要求在已建立的框架内给出一个逻辑解决方案，这是一项明确定义的任务。该问题导向一个唯一的、概念上合理的答案。\n-   **客观性与清晰度**：术语精确且为领域内标准（例如，CTMC、祖先分布范围、时间分层、邻接矩阵）。没有歧义或主观陈述。\n-   **一致性与完整性**：所有必要信息都已提供。矛盾源于模型的应用，而非问题前提的内部不一致。就所提问题而言，前提（系统发育、地质学、模型结果）是连贯的。\n\n**步骤3：结论与行动**\n问题陈述有效。我将继续推导解决方案。\n\n问题的核心在于生物地理学模型的输出与既定地质事实之间的冲突。未分层模型通过假设恒定的扩散速率 $d$ 和不随时间变化的完全邻接 $\\mathbf{A}(t) = \\mathbf{1}$，在对地质历史一无所知的情况下运行。这个模型“相信”区域 $I$ 一直存在，并且一直可以从区域 $M$ 到达。\n\n具体的矛盾是对物理现实的直接违背。模型推断 8 Ma 时的祖先分布范围为 $M+I$。这意味着祖先谱系在 8 百万年前占据了海洋岛屿 $I$。然而，地质数据表明岛屿 $I$ 在那个时候并不存在；它直到 3 Ma 才从海中出现。对于陆生或淡水生物来说，占据一个不存在的陆地是物理上不可能的。因此，这个推断在事实上是错误的，而且是荒谬的。\n\n修正必须涉及将地质信息整合到 CTMC 模型中，以防止这种不可能的推断。在这个建模框架中，两个区域之间（例如，从 $M$ 到 $I$）的扩散速率由邻接矩阵 $\\mathbf{A}(t)$ 调节。有效扩散速率通常计算为基础速率与邻接矩阵中乘数的乘积。设 $d_{MI}(t)$ 为时间 $t$ 时从 $M$ 到 $I$ 的扩散速率。它由 $d_{MI}(t) = d(t) \\cdot m_{MI}(t)$ 给出，其中 $m_{MI}(t)$ 是 $\\mathbf{A}(t)$ 中的相应元素。\n\n为了模拟地质现实，必须使用时间分层的方法。地质历史被划分为不同的时期或时间段。对于岛屿出现之前的任何时间 $t$（即，对于 $t  3$ Ma），岛屿 $I$ 是不可达的。这在模型中通过将任何通往 $I$ 的路线的扩散乘数设置为零来强制执行。因此，对于所有 $t  3$ Ma，乘数 $m_{MI}(t)$ 必须设置为 $0$。这迫使进入 $I$ 的有效扩散速率为 $d_{MI}(t) = d(t) \\cdot 0 = 0$。\n\n通过正确参数化邻接矩阵 $\\mathbf{A}(t)$ 以反映地质历史，模型被约束，使得对于任何时间 $t  3$ Ma，任何包含 $I$ 的分布范围的概率都为零。在 8 Ma 时，$M+I$ 祖先分布范围的似然值变为 $0$。模型随后将正确推断，8 Ma 时的祖先分布范围必须是当时存在的范围，考虑到后代分布，最简约的推断是 $M$。然后，当前的分布可以通过相关谱系的成员在岛屿形成后的某个时间 $t  3$ Ma，从大陆 $M$ 到岛屿 $I$ 的后续扩散事件来解释。\n\n现在，我将评估每个选项。\n\nA. 矛盾在于 8 Ma 时的地理隔离需要一个从未存在过的预先存在的陆桥。修正方法是为 $t3$ Ma 增加灭绝速率 $e$，以便 $I$ 在出现后迅速消失；不需要对 $d(t)$ 或 $\\mathbf{A}(t)$ 进行约束。\n该选项不正确。主要矛盾不是关于陆桥，而是关于区域 $I$ 的存在本身。无论连接性如何，在 8 Ma 时 $M+I$ 的分布范围都是不可能的。提议的修正方法是无稽之谈。增加岛上的灭绝速率会使定殖更加困难，而不是解释其目前的占据情况。时间范围 $t  3$ Ma 是在出现*之前*，而“出现之后”对应于 $t  3$ Ma。整个陈述在逻辑和时间上都非常混乱。**不正确**。\n\nB. 矛盾在于，尽管 $I$ 直到 3 Ma 才存在，但推断将 $I$ 置于 8 Ma 的祖先分布范围内。修正方法是通过在 $\\mathbf{A}(t)$ 中为 $t3$ Ma（即 $I$ 出现之前）设置扩散乘数 $m_{MI}(t)=0$ 来进行时间分层，这迫使当时的 $d_{MI}(t)=d\\cdot m_{MI}(t)=0$；这禁止了在 3 Ma 之前对 $I$ 的占据或向 $I$ 的扩散，从而得出 8 Ma 时的祖先分布范围为 $M$，以及随后在 3 Ma 之后，岛屿谱系向 $I$ 扩散。\n该选项完全正确。它准确地陈述了根本矛盾：推断占据了一个不存在的地点。提议的修正方法正是将此类地质约束纳入 CTMC 生物地理模型的标准且正确的方法。通过为岛屿存在之前的时间段（$t  3$ Ma）设置扩散乘数为 $0$，使得模型在该期间不可能推断出在岛屿上的存在。这迫使模型转向一个更合理的情景：在 8 Ma 时，祖先分布在范围 $M$，随后在岛屿形成后向 $I$ 扩散。**正确**。\n\nC. 矛盾在于模型允许在 3 Ma 之前在 $M$ 上发生灭绝。修正方法是为 $t3$ Ma 设置 $e(t)=0$，这样谱系在岛屿出现前就不能在 $M$ 上灭绝；相反，应为 $t3$ Ma 增加 $d(t)$ 以鼓励对 $I$ 的早期定殖。\n该选项不正确。允许在大陆 $M$ 上发生灭绝没有矛盾；这是一个自然过程。提议的修正方法是武断的，且没有生物学依据。设置 $e(t)=0$ 是一个严重的约束，在问题描述中没有任何基础。为 $t3$ Ma 增加 $d(t)$ 对于向岛屿 $I$ 定殖是徒劳的，因为在该时间段内岛屿不存在。该选项错误地识别了问题并提出了一个不合逻辑的解决方案。**不正确**。\n\nD. 矛盾在于模型未能在 8 Ma 时允许奠基者事件成种。修正方法是通过为 $t8$ Ma 设置非常高的 $d(t)$，在 8 Ma 时强制进行以 $M$ 和 $I$ 为子代分布范围的地理隔离分裂，因为高 $d(t)$ 会使所有分裂实际上都成为地理隔离分裂，而不管邻接性如何。\n该选项不正确。首先，矛盾并非模型“未能允许”某种成种模式，而是其推断在事实上是不可能的。其次，提议的修正方法与所需方法相反；它试图“强制”执行一个在地质上不可能的情景（在 8 Ma 时范围为 $M+I$ 并导致分裂）。第三，所提供的理论依据是错误的：高扩散速率 $d(t)$ 通过增加同域性和基因流来*对抗*分布范围的破碎化和地理隔离，它们不会导致地理隔离。这一陈述揭示了对生物地理过程和模型的基本误解。**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2762446"}, {"introduction": "除了重建祖先的地理分布范围，我们常常还希望检验特定的生物地理学假说，例如，隔离成种（vicariance）在一个谱系演化中的作用是否超出了随机预期的水平。本练习将带您进入统计假设检验的领域，要求您通过计算机模拟来编程实现一个零模型。对于研究者而言，开发和编写此类检验程序是一项强大的技能，它使您能够针对自己的数据提出并验证独特的科学问题。[@problem_id:2762450]", "problem": "给定一个固定的有根二分系统发育树，其叶尖集合带有标签，并且每个叶尖都有一个观察到的生物地理区域存在-缺失分配。设叶尖集合为 $\\{0,1,\\dots,n-1\\}$，有限的区域集合为 $\\mathcal{A}=\\{0,1,\\dots,m-1\\}$。对于每个叶尖 $i\\in\\{0,\\dots,n-1\\}$，观察到的分布区是一个子集 $S_i\\subseteq \\mathcal{A}$，其分布区大小为 $r_i=|S_i|$。当且仅当一对叶尖 $(a,b)$ 的最近共同祖先恰好以这两个叶尖为其直接子代时，它们被称为一个姐妹对。在一个严格的二分树中，姐妹对就是所谓的樱桃节点，即具有两个叶尖子代的内部节点。\n\n定义统计量 $D$ 为具有不相交分布区的姐妹对的数量：\n$$\nD=\\sum_{(a,b)\\in \\mathrm{Cherries}(T)} \\mathbf{1}\\big(S_a\\cap S_b=\\varnothing\\big),\n$$\n其中 $\\mathrm{Cherries}(T)$ 是固定树 $T$ 中的姐妹对集合，而 $\\mathbf{1}(\\cdot)$ 是指示函数。\n\n您必须实现一个零模型，该模型在固定的系统发育树上将叶尖区域标签随机化，同时保持每个叶尖的分布区大小完全不变。形式上，在零假设下，对于每个叶尖 $i$，从 $\\mathcal{A}$ 的所有基数为 $r_i$ 的子集集合中，均匀随机地抽取一个新的分布区 $S_i'$，且各叶尖的抽取过程相互独立。这在保持所有 $i$ 的 $r_i$ 不变的同时，消除了区域同一性中的任何系统发育信号。对于每次随机化 $k\\in\\{1,\\dots,N_{\\mathrm{sim}}\\}$，计算\n$$\nD^{(k)}=\\sum_{(a,b)\\in \\mathrm{Cherries}(T)} \\mathbf{1}\\big(S_a^{\\prime(k)}\\cap S_b^{\\prime(k)}=\\varnothing\\big).\n$$\n\n给定从数据中观察到的 $D_{\\mathrm{obs}}$ 和模拟值 $\\{D^{(k)}\\}_{k=1}^{N_{\\mathrm{sim}}}$，使用加一校正计算单侧蒙特卡洛 $p$ 值：\n$$\np_{\\mathrm{upper}}=\\frac{1+\\sum_{k=1}^{N_{\\mathrm{sim}}}\\mathbf{1}(D^{(k)}\\ge D_{\\mathrm{obs}})}{N_{\\mathrm{sim}}+1},\\qquad\np_{\\mathrm{lower}}=\\frac{1+\\sum_{k=1}^{N_{\\mathrm{sim}}}\\mathbf{1}(D^{(k)}\\le D_{\\mathrm{obs}})}{N_{\\mathrm{sim}}+1}.\n$$\n这里，$p_{\\mathrm{upper}}$ 检验与零模型相比，处于不同区域的姐妹对是否过多，而 $p_{\\mathrm{lower}}$ 则检验是否存在不足。\n\n您的任务是编写一个完整的程序，为下面的测试套件中的每种情况计算 $\\big(p_{\\mathrm{upper}},p_{\\mathrm{lower}}\\big)$。对第一个测试用例使用精确的随机种子 $1729$，后续每个测试用例的种子依次递增 $1$（即种子为 $1729,1730,1731,1732$）。对每个测试用例，使用 $N_{\\mathrm{sim}}=10000$ 次零模型随机化。\n\n每棵树由其有向的父-子关系集合 $(u\\to v,w)$ 表示，其中 $u$ 是一个内部节点，$(v,w)$ 是其两个子节点。叶尖的索引始终为 $0$ 到 $n-1$，内部节点的索引为 $n,n+1,\\dots$。樱桃节点恰好是那些作为某个内部节点 $u$ 的子节点出现的 $(v,w)$ 对，其中 $v$ 和 $w$ 都是 $\\{0,\\dots,n-1\\}$ 中的叶尖。\n\n测试套件：\n\n- 测试用例 1：\n  - 区域：$m=3$ 因此 $\\mathcal{A}=\\{0,1,2\\}$。\n  - 树的边：$(4\\to 0,1)$, $(5\\to 2,3)$, $(6\\to 4,5)$。\n  - 叶尖分布区：$S_0=\\{0\\}$, $S_1=\\{0\\}$, $S_2=\\{1\\}$, $S_3=\\{2\\}$。\n  - 模拟次数：$N_{\\mathrm{sim}}=10000$。\n  - 种子：$1729$。\n\n- 测试用例 2：\n  - 区域：$m=4$ 因此 $\\mathcal{A}=\\{0,1,2,3\\}$。\n  - 树的边：$(6\\to 0,1)$, $(7\\to 2,3)$, $(8\\to 4,5)$, $(9\\to 6,7)$, $(10\\to 8,9)$。\n  - 叶尖分布区：$S_0=\\{0,1\\}$, $S_1=\\{1,2\\}$, $S_2=\\{0\\}$, $S_3=\\{1\\}$, $S_4=\\{1,2,3\\}$, $S_5=\\{0\\}$。\n  - 模拟次数：$N_{\\mathrm{sim}}=10000$。\n  - 种子：$1730$。\n\n- 测试用例 3：\n  - 区域：$m=2$ 因此 $\\mathcal{A}=\\{0,1\\}$。\n  - 树的边：$(4\\to 0,1)$, $(5\\to 2,3)$, $(6\\to 4,5)$。\n  - 叶尖分布区：$S_0=\\{0\\}$, $S_1=\\{0,1\\}$, $S_2=\\{1\\}$, $S_3=\\{1\\}$。\n  - 模拟次数：$N_{\\mathrm{sim}}=10000$。\n  - 种子：$1731$。\n\n- 测试用例 4：\n  - 区域：$m=3$ 因此 $\\mathcal{A}=\\{0,1,2\\}$。\n  - 树的边：$(4\\to 0,1)$, $(5\\to 2,3)$, $(6\\to 4,5)$。\n  - 叶尖分布区：$S_0=\\{0\\}$, $S_1=\\{1\\}$, $S_2=\\{1\\}$, $S_3=\\{2\\}$。\n  - 模拟次数：$N_{\\mathrm{sim}}=10000$。\n  - 种子：$1732$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个双元素列表 $[p_{\\mathrm{upper}},p_{\\mathrm{lower}}]$，其中两个数字都四舍五入到 $6$ 位小数。例如，输出应具有以下形式\n  $$\n  \\big[[p_{\\mathrm{upper},1},p_{\\mathrm{lower},1}],[p_{\\mathrm{upper},2},p_{\\mathrm{lower},2}],[p_{\\mathrm{upper},3},p_{\\mathrm{lower},3}],[p_{\\mathrm{upper},4},p_{\\mathrm{lower},4}]\\big].\n  $$\n本问题不涉及任何物理单位或角度。所有数值答案必须以小数形式（而非百分比）打印。", "solution": "用户提交了一个问题以供验证和求解。该问题经评估为有效。\n\n### 问题验证\n\n按照协议对问题陈述进行了全面验证。\n\n#### 步骤 1：提取已知信息\n\n以下是明确提供的数据和定义：\n-   一个固定的有根二分系统发育树 $T$，其叶尖集合为 $\\{0,1,\\dots,n-1\\}$。\n-   一个有限的生物地理区域集合 $\\mathcal{A}=\\{0,1,\\dots,m-1\\}$。\n-   对于每个叶尖 $i$，一个观察到的分布区 $S_i\\subseteq \\mathcal{A}$，其大小为 $r_i=|S_i|$。\n-   一个姐妹对 $(a,b)$ 被定义为一个共同内部节点（一个樱桃节点）的两个叶尖子代。\n-   关注的统计量是 $D$，即具有不相交分布区的姐妹对的数量：\n    $$\n    D=\\sum_{(a,b)\\in \\mathrm{Cherries}(T)} \\mathbf{1}\\big(S_a\\cap S_b=\\varnothing\\big)\n    $$\n-   指定了一个零模型：对于每个叶尖 $i$，从 $\\mathcal{A}$ 的所有基数为 $r_i$ 的子集中均匀随机地抽取一个新的分布区 $S_i'$，且各叶尖的抽取过程相互独立。\n-   随机化 $k$ 的模拟统计量为：\n    $$\n    D^{(k)}=\\sum_{(a,b)\\in \\mathrm{Cherries}(T)} \\mathbf{1}\\big(S_a^{\\prime(k)}\\cap S_b^{\\prime(k)}=\\varnothing\\big)\n    $$\n-   模拟次数为 $N_{\\mathrm{sim}}$。\n-   需要使用加一校正计算单侧蒙特卡洛 $p$ 值：\n    $$\n    p_{\\mathrm{upper}}=\\frac{1+\\sum_{k=1}^{N_{\\mathrm{sim}}}\\mathbf{1}(D^{(k)}\\ge D_{\\mathrm{obs}})}{N_{\\mathrm{sim}}+1},\\qquad\n    p_{\\mathrm{lower}}=\\frac{1+\\sum_{k=1}^{N_{\\mathrm{sim}}}\\mathbf{1}(D^{(k)}\\le D_{\\mathrm{obs}})}{N_{\\mathrm{sim}}+1}\n    $$\n-   树由父-子关系 $(u\\to v,w)$ 表示。叶尖的索引为 $\\{0,\\dots,n-1\\}$。\n-   提供了一个包含四个案例的测试套件，每个案例都指定了区域数 $m$、树的边、叶尖分布区、$N_{\\mathrm{sim}}=10000$ 以及一个用于可复现性的特定随机种子。\n-   强制规定了结果的特定输出格式。\n\n#### 步骤 2：使用提取的已知信息进行验证\n\n依据验证标准对问题陈述进行评估：\n\n-   **科学依据**：该问题在科学上是合理的。它描述了一种置换检验，这是计算生物学中一种标准的统计方法，应用于系统发育地理学中关于姐妹物种空间分布的经典问题。所用的零模型是检验关于系统发育性状演化假说的成熟方法。问题不含伪科学和事实错误。\n-   **适定性**：问题是适定的。每个测试用例所需的所有参数、数据和定义都已提供。目标陈述清晰，计算过程在算法上已明确指定，保证了对于每个测试用例（给定固定的随机种子），都存在唯一的解。\n-   **客观性**：问题是用精确、客观和数学化的语言表述的，没有任何主观或模糊的陈述。\n\n该问题没有表现出任何无效标志。这是一个完整、一致且具有科学相关性的计算任务。\n\n#### 步骤 3：结论与行动\n\n**结论**：问题有效。\n**行动**：着手制定一个完整且合理的解决方案。\n\n### 解决方案设计\n\n该问题要求实现一个蒙特卡洛置换检验，以计算在系统发育树上观察到的生物地理学模式的统计显著性。每个测试用例的总体流程如下。\n\n1.  **解析输入数据**：对于每个测试用例，我们必须解析区域数 $m$、树结构以及观察到的叶尖分布区。叶尖数量 $n$ 可从叶尖分布区列表的长度推导出。树的边以元组 $(u, v, w)$ 的形式给出，表示 $u \\to v, w$。叶尖分布区 $S_i$ 以列表形式给出，应转换为集合以便进行高效的交集运算。\n\n2.  **识别姐妹对（樱桃节点）**：姐妹对（或樱桃节点）是指其两个子代均为叶尖的内部节点。叶尖的索引范围是 $0$ 到 $n-1$。我们遍历所提供的树边 $(u, v, w)$。如果两个子节点 $v$ 和 $w$ 都小于 $n$，则该对 $(v,w)$ 构成一个樱桃节点。将这些对收集到一个列表 $\\mathrm{Cherries}(T)$ 中。\n\n3.  **计算观察统计量 ($D_{\\mathrm{obs}}$)**：观察统计量 $D_{\\mathrm{obs}}$ 是具有不相交地理分布区的姐妹对的数量。我们遍历已识别的樱桃节点列表。对于每个对 $(a,b) \\in \\mathrm{Cherries}(T)$，我们检查它们观察到的分布区 $S_a$ 和 $S_b$ 的交集是否为空，即 $S_a \\cap S_b = \\varnothing$。这类对的总数即为 $D_{\\mathrm{obs}}$。\n    $$\n    D_{\\mathrm{obs}} = \\sum_{(a,b)\\in \\mathrm{Cherries}(T)} \\mathbf{1}(S_a \\cap S_b = \\varnothing)\n    $$\n\n4.  **执行蒙特卡洛模拟**：这是零模型分析的核心。我们执行 $N_{\\mathrm{sim}}$ 次独立模拟。对于每次模拟 $k \\in \\{1, \\dots, N_{\\mathrm{sim}}\\}$：\n    a.  **生成随机化分布区**：对于每个叶尖 $i \\in \\{0, \\dots, n-1\\}$，我们必须生成一个新的随机化分布区 $S_i^{\\prime(k)}$。这是通过从所有可用区域集合 $\\mathcal{A} = \\{0, \\dots, m-1\\}$ 中不放回地抽取一个大小为 $r_i = |S_i|$ 的样本来完成的。对每个叶尖独立重复此过程，为系统发育树创建一整套随机化分布区。使用带有种子的伪随机数生成器以确保可复现性。\n    b.  **计算模拟统计量 ($D^{(k)}$)**：使用随机化分布区 $\\{S_i^{\\prime(k)}\\}_{i=0}^{n-1}$，我们以与计算 $D_{\\mathrm{obs}}$ 相同的方式计算统计量 $D^{(k)}$：\n        $$\n        D^{(k)} = \\sum_{(a,b)\\in \\mathrm{Cherries}(T)} \\mathbf{1}(S_a^{\\prime(k)} \\cap S_b^{\\prime(k)} = \\varnothing)\n        $$\n    c.  **存储结果**：存储值 $D^{(k)}$，它构成了该统计量的零分布。\n\n5.  **计算 $p$ 值**：在所有 $N_{\\mathrm{sim}}$ 次模拟完成后，我们得到了一个零分布 $\\{D^{(k)}\\}_{k=1}^{N_{\\mathrm{sim}}}$。我们将观察统计量 $D_{\\mathrm{obs}}$ 与此分布进行比较。单侧 $p$ 值使用提供的公式计算，其中包括“加一”校正，以避免 $p$ 值为 $0$ 并处理 $D_{\\mathrm{obs}}$ 比任何模拟值都更极端的情况。\n    -   上尾 $p$ 值，检验不相交姐妹对是否过多，其计算公式为：\n        $$\n        p_{\\mathrm{upper}}=\\frac{1+\\sum_{k=1}^{N_{\\mathrm{sim}}}\\mathbf{1}(D^{(k)}\\ge D_{\\mathrm{obs}})}{N_{\\mathrm{sim}}+1}\n        $$\n    -   下尾 $p$ 值，检验不相交姐妹对是否过少（即重叠姐妹对是否过多），其计算公式为：\n        $$\n        p_{\\mathrm{lower}}=\\frac{1+\\sum_{k=1}^{N_{\\mathrm{sim}}}\\mathbf{1}(D^{(k)}\\le D_{\\mathrm{obs}})}{N_{\\mathrm{sim}}+1}\n        $$\n\n此流程将应用于所提供的测试套件中的每个测试用例，使用指定的参数来生成最终结果。实现将使用 `numpy` 库以进行高效的随机抽样。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_permutation_test(m, tree_edges, tip_ranges, N_sim, seed):\n    \"\"\"\n    Performs a permutation test for a single test case.\n\n    Args:\n        m (int): The total number of areas.\n        tree_edges (list of tuples): Parent-to-children relations (u, v, w).\n        tip_ranges (list of lists): Observed ranges for each tip.\n        N_sim (int): Number of simulations.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        tuple: A tuple containing (p_upper, p_lower).\n    \"\"\"\n    num_tips = len(tip_ranges)\n    observed_ranges_sets = [set(r) for r in tip_ranges]\n    range_sizes = [len(r) for r in observed_ranges_sets]\n    all_areas = np.arange(m)\n\n    # 1. Identify sister pairs (cherries)\n    cherries = []\n    for _, child1, child2 in tree_edges:\n        if child1  num_tips and child2  num_tips:\n            cherries.append((child1, child2))\n\n    # 2. Calculate the observed statistic D_obs\n    d_obs = 0\n    for tip_a, tip_b in cherries:\n        if not observed_ranges_sets[tip_a].intersection(observed_ranges_sets[tip_b]):\n            d_obs += 1\n\n    # 3. Perform Monte Carlo simulations\n    rng = np.random.default_rng(seed)\n    d_sims = np.zeros(N_sim, dtype=int)\n\n    for k in range(N_sim):\n        # Generate randomized ranges for all tips for this simulation\n        random_ranges = []\n        for i in range(num_tips):\n            size = range_sizes[i]\n            if size > m: # Should not happen in a valid problem\n                random_subset = set()\n            else:\n                random_subset = set(rng.choice(all_areas, size=size, replace=False))\n            random_ranges.append(random_subset)\n\n        # Calculate D for this simulation\n        d_k = 0\n        for tip_a, tip_b in cherries:\n            if not random_ranges[tip_a].intersection(random_ranges[tip_b]):\n                d_k += 1\n        d_sims[k] = d_k\n\n    # 4. Compute p-values\n    # p_upper tests for D_obs being significantly large\n    count_ge = np.sum(d_sims >= d_obs)\n    p_upper = (1 + count_ge) / (N_sim + 1)\n    \n    # p_lower tests for D_obs being significantly small\n    count_le = np.sum(d_sims = d_obs)\n    p_lower = (1 + count_le) / (N_sim + 1)\n\n    return round(p_upper, 6), round(p_lower, 6)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"m\": 3,\n            \"tree_edges\": [(4, 0, 1), (5, 2, 3), (6, 4, 5)],\n            \"tip_ranges\": [[0], [0], [1], [2]],\n            \"seed\": 1729,\n        },\n        {\n            \"m\": 4,\n            \"tree_edges\": [(6, 0, 1), (7, 2, 3), (8, 4, 5), (9, 6, 7), (10, 8, 9)],\n            \"tip_ranges\": [[0, 1], [1, 2], [0], [1], [1, 2, 3], [0]],\n            \"seed\": 1730,\n        },\n        {\n            \"m\": 2,\n            \"tree_edges\": [(4, 0, 1), (5, 2, 3), (6, 4, 5)],\n            \"tip_ranges\": [[0], [0, 1], [1], [1]],\n            \"seed\": 1731,\n        },\n        {\n            \"m\": 3,\n            \"tree_edges\": [(4, 0, 1), (5, 2, 3), (6, 4, 5)],\n            \"tip_ranges\": [[0], [1], [1], [2]],\n            \"seed\": 1732,\n        },\n    ]\n\n    N_sim = 10000\n    results = []\n\n    for case in test_cases:\n        p_upper, p_lower = run_permutation_test(\n            case[\"m\"],\n            case[\"tree_edges\"],\n            case[\"tip_ranges\"],\n            N_sim,\n            case[\"seed\"]\n        )\n        results.append([p_upper, p_lower])\n\n    # Final print statement in the exact required format.\n    # The repr() function gives a string representation of the list,\n    # and we remove spaces to match the compact format.\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2762450"}]}