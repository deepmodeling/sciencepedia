{"hands_on_practices": [{"introduction": "进化生物学家常常像侦探一样，从现存生物的零散线索中重建遥远的过去。这个练习将你置于一个发现新细胞器的情景中，挑战你综合利用多种生物学证据——从膜结构到蛋白质输入机制——来推断其进化起源。通过这项练习 [@problem_id:2703178]，你将学会如何评估和权衡不同的证据，即使在最直接的证据（如细胞器基因组）缺失的情况下，也能做出科学上最合理的推断。", "problem": "一个新描述的真核生物谱系含有一个膜结合区室，暂时命名为Organelle X。多种独立的检测方法（长读长基因组测序、细胞器富集组分测序以及超灵敏荧光脱氧核糖核酸（DNA）染色）在能够轻易检测到对照分类群中核DNA和线粒体DNA的条件下，均反复未能在Organelle X中检测到任何DNA。然而，比较细胞生物学揭示了该谱系中几个物种的Organelle X共同具有以下特征：\n\n- 一层双层膜包被，其外膜与内质网或核膜均不连续，内膜带有嵴状内陷。\n- 一套特化的蛋白质输入系统，由一个与细菌Omp家族蛋白同源的β-桶状孔道、一个分拣与组装机器（SAM，也称为β-桶状蛋白外膜转运酶（TOB））同源物，以及一个内膜转运酶（TIM）样复合物组成；输入的底物具有N端、两亲性、富含精氨酸的靶向肽，这些肽在输入后被切割。\n- 内膜心磷脂富集，并通过使用FtsZ样环状结构进行二分裂来增殖。\n- 编码Organelle X蛋白质的核基因与α-变形菌同源物显示出强烈的系统发育亲缘性；许多基因携带细胞器靶向信号，并在细胞器生物发生过程中表达上调。\n\n自生假说认为新细胞器是通过宿主内膜系统的内部分化和内陷产生的，而内共生理论则认为其起源于一个被吞噬的细菌，随后经历了简化演化、广泛的内共生基因转移至细胞核，并演化出蛋白质靶向和输入机器以重新靶向编码的蛋白质。仅根据上述证据，关于Organelle X的自生假说的可行性，哪项结论得到了最好的支持，为什么？\n\nA. 自生假说仍然可行，因为双层膜可以通过内陷形成，且缺少细胞器基因组与内共生起源相矛盾。\n\nB. 自生假说非常不被支持；最简约的解释是内共生起源，并通过内共生基因转移导致基因组完全丢失，这一点由细菌型输入机器、细菌脂质特征、二分裂以及核编码细胞器蛋白与α-变形菌的系统发育亲缘性所证实。\n\nC. 自生假说和内共生假说同样合理；由于没有常驻的细胞器基因组，其起源无法推断，且蛋白质输入系统可以从通用的内膜转运子趋同演化而来。\n\nD. 只有当输入机器与真核内膜系统同源，且脂质与典型的内质网特征相匹配时，自生假说才可行；因为观察到的机器和脂质都类似细菌，所以该数据集不支持自生起源。", "solution": "从核心定义和经过充分检验的演化原则开始：\n\n- 根据内共生理论，线粒体和质体等细胞器起源于宿主细胞吞噬一个细菌。随着时间的推移，广泛的内共生基因转移将许多基因移至细胞核，细胞器基因组经历了简化演化，并演化出了蛋白质靶向和输入途径，以将核编码的蛋白质送回细胞器。经验上，线粒体衍生的细胞器可以完全失去其基因组（例如，mitosomes和一些hydrogenosomes），同时保留双层膜、通过裂殖进行分裂、细菌型脂质（如心磷脂）以及特化的输入机器（例如，外膜转运酶（TOM）、分拣与组装机器（SAM）/β-桶状蛋白外膜转运酶（TOB）以及内膜转运酶（TIM）系统）。\n- 自生假说提出，细胞器起源于宿主内膜系统的内部分化和内陷。预测的特征将包括源自真核内膜系统组分，脂质成分具有内质网和高尔基体的特征而非细菌的特征，缺少细菌分裂系统（例如，FtsZ），以及蛋白质转运系统与真核内膜转运子（例如，Sec61）同源，而非与细菌外膜组装系统（例如，构成SAM/TOB基础的Omp85家族）同源。\n\n将这些原则应用于观察结果：\n\n- 双层膜：仅此一点并非决定性的，因为吞噬和内陷都可以产生双层膜。因此，这一特征本身既不能独特地支持也不能排除任何一种假说。\n- 蛋白质输入机器：存在一个β-桶状孔道和一个与细菌Omp家族蛋白有明确同源性的SAM/TOB同源物，外加一个TIM样复合物以及带有N端两亲性、富含精氨酸靶向肽的底物，这些共同特征与经典的线粒体蛋白质输入、组装系统及靶向信号相匹配。这些系统在系统发育和结构上与细菌外膜组装（Omp85家族）相关，并非真核内质网转运子的简单衍生物。这是支持内共生起源以及基因转移至细胞核后演化出细胞器特异性输入的有力证据。\n- 脂质与分裂：心磷脂富集（一种在细菌和线粒体内膜中丰富，但在内质网衍生膜中不常见的脂质），以及利用FtsZ样系统进行二分裂，这些都是线粒体和质体中保留的经典细菌特征。这些特征与完全源自宿主内膜系统的自生起源不符。\n- 核基因系统发育：在系统发育树中嵌套于α-变形菌内的核编码Organelle X蛋白，强烈支持内共生基因从一个α-变形菌祖先转移到宿主细胞核，随后通过N端靶向肽重新靶向到该细胞器。\n\n关键在于，缺少常驻的细胞器基因组并不能驳斥内共生，因为在大规模基因转移后发生基因组丢失是线粒体衍生细胞器中简化演化的一个有据可查的结果。因此，细菌型输入机器、细菌样脂质成分、细菌式分裂以及核编码细胞器蛋白的α-变形菌系统发育亲缘性这些特征的结合，与内共生起源随后基因组完全丢失的观点一致。根据自生假说，人们会预期输入系统和膜成分源自真核内膜而非细菌同源物；观察到的数据集与这些预期相矛盾。\n\n逐项分析选项：\n\n- 选项A：双层膜确实可以通过内陷形成；然而，缺少细胞器基因组并不与内共生矛盾，因为在内共生基因转移后可能会发生完整的基因组丢失。此外，数据集包含了细菌型输入机器、细菌脂质和细菌式分裂，这些都与纯粹的自生起源不符。结论——不正确。\n\n- 选项B：该选项整合了关键证据：细菌型输入机器（与Omp家族相关的SAM/TOB和TIM样系统，以及线粒体式的靶向肽）、细菌脂质特征（心磷脂富集）、使用FtsZ样结构的二分裂，以及核编码细胞器蛋白的α-变形菌系统发育亲缘性。它正确地将基因组缺失解释为与通过简化演化和内共生基因转移实现的内共生起源相容。结论——正确。\n\n- 选项C：该选项认为两种假说同样合理，并假设输入系统可以从通用的内膜转运子趋同演化而来。与细菌Omp家族机器的特异同源性以及脂质和分裂特征反驳了这种从真核系统趋同演化的可能性，而细胞器靶向蛋白与α-变形菌的系统发育亲缘性则明确支持内共生。结论——不正确。\n\n- 选项D：该选项陈述了一个条件，准确地指出了要使自生假说保持可行需要什么（源自真核内膜的输入系统和典型的内质网脂质谱），并得出结论，因为观察到的机器和脂质都类似细菌，所以自生起源不受支持。尽管是以条件句的形式表述，它得出的经验性结论与选项B相同。然而，问题要求根据证据给出支持度最高的结论并评估可行性；选项D的结构含蓄地承认了自生假说在此处不受支持，但它更像是一个方法论陈述，而不是对数据集的直接结论。在这两者之间，选项B更直接、更全面地利用所有列出的证据（包括系统发育信号和分裂模式）来证明内共生解释。结论——不是最佳答案，因为它不够完整，也不是最直接合理的结论。\n\n因此，支持度最高的选择是内共生起源并伴随基因组丢失，这在本案例中不支持自生假说。", "answer": "$$\\boxed{B}$$", "id": "2703178"}, {"introduction": "在确认了内共生起源的证据之后，一个核心问题是：为什么这次事件如此重要？Lane-Martin的生物能学假说认为，线粒体的内共生是一场能量革命，为真核生物的复杂性铺平了道路。这个练习 [@problem_id:2703253] 提供了一个将这一宏大理论转化为定量模型的机会，你将从第一性原理出发，推导出一个连接细胞参数（如膜面积和体积）与每个基因可用能量的表达式。这项实践旨在训练你将抽象的进化理论具象化为可检验的数学框架的能力。", "problem": "Lane–Martin生物能量学理论的一个核心预测是，内共生通过使腺苷三磷酸（ATP）的产生与呼吸膜面积成比例，而许多细胞成本与细胞体积成比例，从而将能量供应与基因组大小解耦。考虑一个处于稳态的真核细胞，其中线粒体供应细胞使用的所有ATP。设用于呼吸的总线粒体内膜面积为 $A_{r}$，设净ATP合成速率密度（单位时间单位呼吸膜面积的ATP分子数，已考虑质子泄漏和耦合效率）为 $j_{r}$。因此，线粒体总ATP产生速率为 $J_{\\mathrm{prod}} = j_{r} A_{r}$。假设基础细胞ATP需求与细胞体积 $V$ 成比例，密度为 $m_{v}$（单位时间单位体积的ATP分子数），因此基础需求为 $J_{\\mathrm{basal}} = m_{v} V$。此外，维持线粒体脱氧核糖核酸（mtDNA）会产生一个ATP成本，每个mtDNA分子每单位时间为 $s_{m}$，每个细胞有 $C_{m}$ 个mtDNA分子，从而产生一个mtDNA特异性成本 $J_{\\mathrm{mtDNA}} = s_{m} C_{m}$。假设在稳态下，可用于驱动所有与基因相关的细胞工作的净ATP是差值 $J_{\\mathrm{net}} = J_{\\mathrm{prod}} - (J_{\\mathrm{basal}} + J_{\\mathrm{mtDNA}})$。\n\n设每个细胞的核基因拷贝总数（包括倍性）为 $G_{N}$，对于所考虑的细胞类型，该值被视为一个常数。设每个mtDNA分子编码 $g_{m}$ 个基因，因此mtDNA基因拷贝总数为 $g_{m} C_{m}$。将每基因ATP供应量 $\\Phi$ 定义为单位时间稳态下可用的净ATP除以必须维持和表达的基因拷贝总数，即总基因拷贝数 $G_{N} + g_{m} C_{m}$。\n\n从这些定义和稳态假设出发，除了产量与面积、成本与体积和拷贝数成比例的定比关系外，不引用任何专门的结果，推导出 $\\Phi$ 作为 $A_{r}$、$V$ 和 $C_{m}$ 以及常数 $j_{r}$、$m_{v}$、$s_{m}$、$g_{m}$ 和 $G_{N}$ 的函数的单一闭式解析表达式。将最终答案表示为一个解析表达式。不要在最终表达式中包含单位。你可以假设在 $J_{\\mathrm{prod}} > J_{\\mathrm{basal}} + J_{\\mathrm{mtDNA}}$ 的情况下，以确保 $\\Phi$ 为正。", "solution": "题目要求我们基于产量与膜面积、成本与体积和拷贝数成比例的基本定比原理，推导每基因ATP供应量（记为 $\\Phi$）的表达式。\n\n根据定义，线粒体供应的总ATP产生速率由净ATP合成速率密度和总呼吸膜面积的乘积给出：\n$$\nJ_{\\mathrm{prod}} = j_{r} A_{r}.\n$$\n稳态细胞ATP需求分为两部分。首先，是与细胞体积成比例的基础维持成本：\n$$\nJ_{\\mathrm{basal}} = m_{v} V,\n$$\n其中 $m_{v}$ 是每单位体积的ATP需求密度。其次，是与维持、复制和表达线粒体脱氧核糖核酸（mtDNA）相关的成本，该成本与mtDNA分子数量成线性比例：\n$$\nJ_{\\mathrm{mtDNA}} = s_{m} C_{m},\n$$\n其中 $s_{m}$ 是每个mtDNA分子每单位时间的ATP成本，而 $C_{m}$ 是mtDNA拷贝数。\n\n在稳态假设下，可用于驱动与基因相关的细胞工作的净ATP等于产量减去需求之和：\n$$\nJ_{\\mathrm{net}} = J_{\\mathrm{prod}} - \\bigl(J_{\\mathrm{basal}} + J_{\\mathrm{mtDNA}}\\bigr) = j_{r} A_{r} - m_{v} V - s_{m} C_{m}.\n$$\n\n接下来，我们形式化分母：必须维持和表达的基因拷贝总数。每个细胞的核基因拷贝数（包括倍性）被视为一个常数 $G_{N}$。每个mtDNA分子携带 $g_{m}$ 个基因，因此mtDNA基因拷贝数为 $g_{m} C_{m}$。因此，总基因拷贝数为\n$$\nG_{\\mathrm{tot}} = G_{N} + g_{m} C_{m}.\n$$\n\n根据所提供的定义，每基因ATP供应量 $\\Phi$ 是单位时间内可用的净ATP除以总基因拷贝数：\n$$\n\\Phi = \\frac{J_{\\mathrm{net}}}{G_{\\mathrm{tot}}}.\n$$\n代入 $J_{\\mathrm{net}}$ 和 $G_{\\mathrm{tot}}$ 的表达式，我们得到\n$$\n\\Phi(A_{r}, V, C_{m}; j_{r}, m_{v}, s_{m}, g_{m}, G_{N}) = \\frac{j_{r} A_{r} - m_{v} V - s_{m} C_{m}}{G_{N} + g_{m} C_{m}}.\n$$\n\n我们可以简要验证量纲一致性。分子的单位是每单位时间的ATP：$j_{r} A_{r}$ 是每单位时间的ATP， $m_{v} V$ 和 $s_{m} C_{m}$ 也是。分母是基因拷贝数的纯计数。因此，$\\Phi$ 的单位是每单位时间每个基因拷贝的ATP，这与预期相符。假设的 $j_{r} A_{r} > m_{v} V + s_{m} C_{m}$ 条件确保了 $\\Phi > 0$。\n\n这个表达式体现了Lane–Martin的直觉：增加呼吸膜面积 $A_{r}$ 会提高 $\\Phi$，增加细胞体积 $V$ 会通过提高维持成本来降低 $\\Phi$，而增加mtDNA拷贝数 $C_{m}$ 则会带来一种权衡，因为它既增加了分子的成本项，又增加了分母的基因数，除非伴随着 $A_{r}$ 或 $j_{r}$ 的补偿性增加，否则通常会趋向于减少 $\\Phi$。", "answer": "$$\\boxed{\\frac{j_{r} A_{r} - m_{v} V - s_{m} C_{m}}{G_{N} + g_{m} C_{m}}}$$", "id": "2703253"}, {"introduction": "现代进化生物学研究在很大程度上依赖于从海量基因组数据中提取信号的能力。追踪真核生物基因组的镶嵌式祖源——区分哪些基因来自宿主，哪些来自内共生体——是研究内共生理论的核心任务。这个练习 [@problem_id:2703240] 提供了一个真实的计算挑战：你将实现一个基于似然的方法，根据基因的系统发育信号对其进行分类，并检验一个关于细胞器靶向蛋白的关键假说。通过这项实践，你将掌握生物信息学和统计推断方面的基本技能。", "problem": "给定一个精选的核基因家族数据集，其中包含近似古菌与细菌起源的系统发育基因组学信号的汇总统计数据，以及指示预测的细胞器靶向（线粒体或质体）的二元注释。您的任务是形式化一个基于推理第一性原理的似然分类检验，并以统计学上严谨的方式评估在被分类为细菌起源的基因中，细胞器靶向蛋白是否富集。\n\n推导过程应基于以下经过充分检验的事实和核心定义：\n- 在存在抽样异质性的情况下，跨演化支的同源物检测计数可以建模为在给定速率参数下源自独立的泊松过程，这是比较基因组学中对计数数据的标准假设。\n- 最大似然（ML）原则和似然比框架：给定两个相互竞争的假设，在每个假设下计算出的似然比值为在广泛的正则性条件下提供了一个最优的检验统计量。\n- 用于 $2 \\times 2$ 列联表的 Fisher 精确检验是一种用于富集分析的精确检验，适用于小计数值。\n\n分类建模假设：\n- 对于每个基因家族 $i$，您观察到一对非负整数 $(b_i, a_i)$，分别代表在细菌和古菌参考集中，通过标准化的同源性搜索流程得到的显著同源物检测数量。您还观察到一个用于预测细胞器靶向的二元指示符 $t_i \\in \\{0,1\\}$。\n- 令 $s_B > 0$ 和 $s_A > 0$ 表示细菌和古菌参考集的抽样工作量缩放因子，用于校正参考集覆盖范围的差异。\n- 令 $\\theta > 0$ 表示当基因的真实起源与某个演化支匹配时的预期检测率乘数，令 $\\varepsilon > 0$ 表示在不匹配的演化支中的预期检测率乘数，且 $\\theta > \\varepsilon$。\n- 在细菌起源假设 $H_B$ 下，$(b_i, a_i)$ 的预期速率为 $(\\lambda_B, \\lambda_A) = (\\theta s_B, \\varepsilon s_A)$。在古菌起源假设 $H_A$ 下，预期速率为 $(\\lambda_B, \\lambda_A) = (\\varepsilon s_B, \\theta s_A)$。\n- 假设在给定起源的条件下，$b_i$ 和 $a_i$ 相互独立；每个都以其相应的速率建模为泊松随机变量。\n\n分类任务：\n- 从第一性原理出发，使用两个假设下的泊松似然，并假设 $H_B$ 和 $H_A$ 具有相等的先验概率，推导出基因 $i$ 的对数似然比统计量\n  \n$$\n  \\mathrm{LLR}_i = \\log \\frac{L\\big((b_i,a_i) \\mid H_B\\big)}{L\\big((b_i,a_i) \\mid H_A\\big)},\n  $$\n- 定义一个确定性划分规则：如果 $\\mathrm{LLR}_i \\ge 0$，则将基因 $i$ 分类为细菌起源，否则分类为古菌起源。\n\n富集分析任务：\n- 在对所有基因进行分类后，构建一个 $2 \\times 2$ 列联表，其行对应于推断的类别（细菌 vs. 古菌），列表示是否为细胞器靶向：\n  \n$$\n  \\begin{array}{cc}\n  \\text{细菌类别中靶向的}  \\text{细菌类别中非靶向的} \\\\\n  \\text{古菌类别中靶向的}  \\text{古菌类别中非靶向的}\n  \\end{array}\n  $$\n\n- 对备择假设（在细菌类别中，细胞器靶向的比值比高于古菌类别）执行单侧 Fisher 精确检验。\n- 如果任一类别包含零个基因（即没有基因被分类到该类别中），则按照惯例将 p 值定义为 $1.0$。否则，计算精确的单侧 p 值。\n- 以小数形式（而非百分比）报告 p 值，四舍五入到小数点后恰好六位。\n\n输入规范（嵌入式测试套件）：\n对于每个测试用例，您将获得 $(\\theta, \\varepsilon, s_B, s_A)$ 以及一个以三元组 $(b_i, a_i, t_i)$ 表示的基因家族列表。\n\n测试用例 1（具有平衡抽样和强信号的理想路径）：\n- 参数：$\\theta = 2.5$, $\\varepsilon = 0.1$, $s_B = 1.0$, $s_A = 1.0$.\n- 基因家族 $(b_i, a_i, t_i)$:\n  - $(5, 0, 1)$, $(4, 1, 1)$, $(3, 0, 1)$, $(6, 1, 1)$,\n  - $(2, 0, 0)$, $(3, 1, 1)$, $(4, 0, 1)$, $(5, 2, 0)$,\n  - $(0, 4, 0)$, $(1, 5, 0)$, $(0, 3, 0)$, $(1, 4, 0)$.\n\n测试用例 2（具有弱信号和相同计数的边界情况）：\n- 参数：$\\theta = 1.2$, $\\varepsilon = 1.0$, $s_B = 1.0$, $s_A = 1.0$.\n- 基因家族 $(b_i, a_i, t_i)$:\n  - $(0, 0, 1)$, $(1, 1, 0)$, $(2, 2, 1)$,\n  - $(1, 0, 0)$, $(0, 1, 1)$, $(1, 2, 0)$.\n\n测试用例 3（通过 $s_B, s_A$ 校正的抽样不平衡边缘案例）：\n- 参数：$\\theta = 2.0$, $\\varepsilon = 0.2$, $s_B = 5.0$, $s_A = 1.0$.\n- 基因家族 $(b_i, a_i, t_i)$:\n  - $(6, 4, 0)$, $(7, 5, 0)$, $(10, 0, 1)$, $(8, 1, 1)$,\n  - $(12, 0, 1)$, $(5, 3, 1)$, $(1, 2, 0)$, $(9, 0, 1)$.\n\n程序要求：\n- 严格按照规定实现分类和富集分析。\n- 对每个测试用例，生成一个列表 $[N_B, N_A, p]$，其中 $N_B$ 是被分类为细菌起源的基因数量（一个整数），$N_A$ 是被分类为古菌起源的基因数量（一个整数），$p$ 是单侧 Fisher 精确检验的 p 值，四舍五入到小数点后六位（一个浮点数）。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，该结果是以逗号分隔并用方括号括起来的列表。每个测试用例的项目必须是 $[N_B, N_A, p]$ 形式的子列表。例如：$[[N_{B,1},N_{A,1},p_1],[N_{B,2},N_{A,2},p_2],[N_{B,3},N_{A,3},p_3]]$。", "solution": "我们使用最大似然（ML）原则和泊松计数模型来形式化一个系统发育基因组学划分检验，然后使用 Fisher 精确检验来进行富集检验。\n\n基础建模与推导：\n- 对于基因 $i$，令观测计数为 $b_i \\in \\mathbb{Z}_{\\ge 0}$ 和 $a_i \\in \\mathbb{Z}_{\\ge 0}$，分别对应于细菌和古菌的同源物检测。在细菌起源假设 $H_B$ 下，我们假定泊松速率为 $\\lambda_B^{(B)} = \\theta s_B$ 和 $\\lambda_A^{(B)} = \\varepsilon s_A$。在古菌起源假设 $H_A$ 下，我们假定 $\\lambda_B^{(A)} = \\varepsilon s_B$ 和 $\\lambda_A^{(A)} = \\theta s_A$。这些速率编码了一个被广泛支持的预期，即在匹配的演化支中同源物检测更为频繁（速率乘数为 $\\theta$），而在不匹配的演化支中则较不频繁（速率乘数为 $\\varepsilon$），同时通过 $s_B$ 和 $s_A$ 校正抽样偏差。\n- 假设独立性，在 $H_B$ 下的似然函数为\n  \n$$\n  L\\big((b_i,a_i)\\mid H_B\\big) = \\mathrm{Poisson}(b_i \\mid \\lambda_B^{(B)}) \\cdot \\mathrm{Poisson}(a_i \\mid \\lambda_A^{(B)}),\n  $$\n\n  在 $H_A$ 下，\n  \n$$\n  L\\big((b_i,a_i)\\mid H_A\\big) = \\mathrm{Poisson}(b_i \\mid \\lambda_B^{(A)}) \\cdot \\mathrm{Poisson}(a_i \\mid \\lambda_A^{(A)}).\n  $$\n\n- 泊松概率质量函数为 $P(X=k)=\\frac{\\lambda^k e^{-\\lambda}}{k!}$。取对数并以相等的先验概率构建对数似然比，得到\n  \n$$\n  \\mathrm{LLR}_i = \\log \\frac{L\\big((b_i,a_i)\\mid H_B\\big)}{L\\big((b_i,a_i)\\mid H_A\\big)}\n  = b_i \\log \\frac{\\lambda_B^{(B)}}{\\lambda_B^{(A)}} + a_i \\log \\frac{\\lambda_A^{(B)}}{\\lambda_A^{(A)}} - \\big(\\lambda_B^{(B)} - \\lambda_B^{(A)}\\big) - \\big(\\lambda_A^{(B)} - \\lambda_A^{(A)}\\big).\n  $$\n\n  该表达式是通过消去阶乘项并从泊松对数似然函数中合并同类项得到的。\n\n分类规则：\n- 在 $H_B$ 和 $H_A$ 具有相等先验概率的情况下，阈值为 1 的似然比检验对应于 $\\mathrm{LLR}_i \\ge 0$ 支持 $H_B$。因此，如果 $\\mathrm{LLR}_i \\ge 0$，我们将基因 $i$ 分类为细菌起源，否则分类为古菌起源。\n\n富集分析：\n- 分类后，我们在细菌类别中统计细胞器靶向基因的数量 $x_B = \\sum_{i \\in \\text{B-class}} \\mathbb{I}(t_i = 1)$ 和非靶向基因数 $n_B - x_B$，其中 $n_B$ 是细菌类别的大小。类似地，在古菌类别中，有 $x_A$ 个靶向基因和 $n_A - x_A$ 个非靶向基因。\n- 我们构建 $2 \\times 2$ 表\n  \n$$\n  \\begin{pmatrix}\n  x_B  n_B - x_B \\\\\n  x_A  n_A - x_A\n  \\end{pmatrix}\n  $$\n\n  并应用单侧 Fisher 精确检验，其备择假设为在细菌类别中靶向的比值比大于在古菌类别中的比值比。如果 $n_B = 0$ 或 $n_A = 0$，我们按照惯例将 p 值设为 $1.0$，因为缺少可比较的基线。\n- 我们报告的 p 值四舍五入到小数点后恰好六位。\n\n在代码中实现的算法步骤：\n- 对每个测试用例，给定 $\\theta$、$\\varepsilon$、$s_B$ 和 $s_A$，计算 $\\lambda_B^{(B)} = \\theta s_B$、$\\lambda_A^{(B)} = \\varepsilon s_A$、$\\lambda_B^{(A)} = \\varepsilon s_B$ 和 $\\lambda_A^{(A)} = \\theta s_A$。\n- 对每个基因 $(b_i, a_i, t_i)$，使用推导出的公式计算 $\\mathrm{LLR}_i$，并根据 $\\mathrm{LLR}_i$ 的符号进行分类。\n- 汇总计数 $n_B, n_A, x_B, x_A$。\n- 计算细菌类别中富集的单侧 Fisher 精确检验 p 值，如果某个类别为空，则返回 $1.0$。\n- 对每个测试用例，输出 $[N_B, N_A, p]$，其中 $N_B = n_B$，$N_A = n_A$，$p$ 是四舍五入后的 p 值。\n- 按顺序打印一行，包含三个测试用例结果列表的列表。\n\n该设计从计数数据的基本概率建模出发，并应用 ML 原则进行分类，随后使用精确的非参数检验进行富集分析。抽样工作量参数 $(s_B, s_A)$ 校正了参考集的不平衡，确保了在数据库覆盖不均的情况下分析的科学真实性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import fisher_exact\n\ndef llr_for_gene(b, a, theta, epsilon, sB, sA):\n    \"\"\"\n    Compute log-likelihood ratio LLR = log L(data|HB) - log L(data|HA)\n    Under HB: lambdas = (theta*sB, epsilon*sA)\n    Under HA: lambdas = (epsilon*sB, theta*sA)\n    \"\"\"\n    # Rates under both hypotheses\n    lamB_HB = theta * sB\n    lamA_HB = epsilon * sA\n    lamB_HA = epsilon * sB\n    lamA_HA = theta * sA\n\n    # To avoid any numerical issues, work in log space. All rates are positive by construction.\n    # LLR derived from Poisson log-likelihoods:\n    # b*log(lamB_HB/lamB_HA) + a*log(lamA_HB/lamA_HA) - (lamB_HB - lamB_HA) - (lamA_HB - lamA_HA)\n    term_b = 0.0 if b == 0 else b * (np.log(lamB_HB) - np.log(lamB_HA))\n    term_a = 0.0 if a == 0 else a * (np.log(lamA_HB) - np.log(lamA_HA))\n    offset = (lamB_HB - lamB_HA) + (lamA_HB - lamA_HA)\n    return term_b + term_a - offset\n\ndef classify_genes(gene_data, theta, epsilon, sB, sA):\n    \"\"\"\n    Classify each gene as bacterial (LLR >= 0) or archaeal (LLR  0).\n    gene_data: list of (b, a, t)\n    Returns: lists of indices for bacterial and archaeal classes, and targeted counts\n    \"\"\"\n    bacterial_indices = []\n    archaeal_indices = []\n    targeted_b = 0\n    targeted_a = 0\n\n    for idx, (b, a, t) in enumerate(gene_data):\n        llr = llr_for_gene(b, a, theta, epsilon, sB, sA)\n        if llr >= 0.0:\n            bacterial_indices.append(idx)\n            if t == 1:\n                targeted_b += 1\n        else:\n            archaeal_indices.append(idx)\n            if t == 1:\n                targeted_a += 1\n\n    return bacterial_indices, archaeal_indices, targeted_b, targeted_a\n\ndef enrichment_p_value(n_b, x_b, n_a, x_a):\n    \"\"\"\n    Compute one-sided Fisher exact test p-value for enrichment of targeting in bacterial class.\n    Returns p-value (float). If either class has zero genes, returns 1.0 by convention.\n    \"\"\"\n    if n_b == 0 or n_a == 0:\n        return 1.0\n    table = np.array([[x_b, n_b - x_b],\n                      [x_a, n_a - x_a]], dtype=int)\n    # One-sided: odds of targeting higher in bacterial\n    _, p = fisher_exact(table, alternative='greater')\n    # Ensure finite numeric value\n    if not np.isfinite(p):\n        p = 1.0\n    return float(p)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a dict with parameters and gene data list of (b, a, t).\n    test_cases = [\n        {\n            \"theta\": 2.5, \"epsilon\": 0.1, \"sB\": 1.0, \"sA\": 1.0,\n            \"genes\": [\n                (5,0,1),(4,1,1),(3,0,1),(6,1,1),\n                (2,0,0),(3,1,1),(4,0,1),(5,2,0),\n                (0,4,0),(1,5,0),(0,3,0),(1,4,0),\n            ],\n        },\n        {\n            \"theta\": 1.2, \"epsilon\": 1.0, \"sB\": 1.0, \"sA\": 1.0,\n            \"genes\": [\n                (0,0,1),(1,1,0),(2,2,1),\n                (1,0,0),(0,1,1),(1,2,0),\n            ],\n        },\n        {\n            \"theta\": 2.0, \"epsilon\": 0.2, \"sB\": 5.0, \"sA\": 1.0,\n            \"genes\": [\n                (6,4,0),(7,5,0),(10,0,1),(8,1,1),\n                (12,0,1),(5,3,1),(1,2,0),(9,0,1),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        theta = case[\"theta\"]\n        epsilon = case[\"epsilon\"]\n        sB = case[\"sB\"]\n        sA = case[\"sA\"]\n        genes = case[\"genes\"]\n\n        b_idx, a_idx, x_b, x_a = classify_genes(genes, theta, epsilon, sB, sA)\n        n_b = len(b_idx)\n        n_a = len(a_idx)\n        pval = enrichment_p_value(n_b, x_b, n_a, x_a)\n        # Round p-value to exactly 6 digits after decimal\n        pval_str = f\"{pval:.6f}\"\n        # Prepare result list: [N_B, N_A, p]\n        results.append([n_b, n_a, pval_str])\n\n    # Final print statement in the exact required format.\n    # Ensure p-values remain as decimals and not re-cast to float with scientific notation.\n    out_items = []\n    for res in results:\n        n_b, n_a, p = res\n        out_items.append(f\"[{n_b},{n_a},{p}]\")\n    print(f\"[{','.join(out_items)}]\")\n\nsolve()\n```", "id": "2703240"}]}