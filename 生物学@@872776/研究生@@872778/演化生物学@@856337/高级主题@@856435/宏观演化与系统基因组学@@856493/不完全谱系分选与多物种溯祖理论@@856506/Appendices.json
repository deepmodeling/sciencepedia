{"hands_on_practices": [{"introduction": "理论的最佳试金石是实践。本章将通过一系列动手实践，带你深入探索不完全谱系分选和多物种溯祖模型的关键概念。第一个练习是构建整个多物种溯祖模型框架的基石。我们将从第一性原理出发，推导并在代码中模拟谱系在单个种群内的溯祖过程，特别是合并事件之间的等待时间。通过亲手实现这个过程，你将对谱系合并的随机性建立起深刻而直观的理解，这是掌握更复杂场景的基础。[@problem_id:2726286]", "problem": "您需要在一个经典的恒定大小 Wright–Fisher 模型框架下，针对一个大小为 $n=5$ 的样本，在恒定的二倍体有效种群大小 $N_e$ 条件下，实现一个中性溯祖谱系的模拟。该模拟代表了多物种溯祖（MSC）框架所假设的分支内过程，MSC 是用于研究不完全谱系分选的标准模型。您的程序必须通过从第一性原理正确推导当存在 $k$ 个祖先谱系时（$k$ 从 $5$ 递减到 $2$）的等待时间分布，来模拟溯祖间隔。推导需在两种可能的时间尺度下进行：代，以及以 $2N_e$ 缩放的溯祖时间单位。您的推导必须仅基于核心定义和已充分验证的事实：恒定大小二倍体种群中的溯祖过程定义、中性条件下的每对谱系溯祖率，以及独立指数等待时间最小值的分布性质。在推导中不要使用任何现成的或简化的公式。\n\n您的程序必须：\n- 为 $n=5$ 的样本实现一个通用的溯祖间隔模拟器，将 $k$ 从 $5$ 递减到 $2$，在恒定的 $N_e$ 下运行。\n- 支持两种时间单位选项：\n  - $u=\\text{\"gen\"}$：时间以代为单位。\n  - $u=\\text{\"coal\"}$：时间以溯祖单位为单位，其中一个溯祖单位等于 $2N_e$ 代。\n- 使用指定的伪随机种子以确保可复现性。\n- 为每个测试用例返回一个包含 $4$ 个浮点数的列表，对应于所要求单位 $u$ 下的模拟溯祖间隔 $(T_5,T_4,T_3,T_2)$。\n\n您在推导和实现中必须满足的科学和数学要求：\n- 从以下基本依据出发：\n  - 在一个恒定大小的二倍体 Wright–Fisher 种群中，每一对无序的祖先谱系以一个由 $N_e$ 决定的恒定速率（每代）发生溯祖。\n  - 当有 $k$ 个谱系时，存在 $\\binom{k}{2}$ 对无序的谱系对。\n  - 独立指数等待时间的最小值服从指数分布，且哪个事件最先发生与该最小值本身是独立的。\n- 以此为基础，推导当存在 $k$ 个谱系时，每个溯祖间隔 $T_k$ 的分布。明确指出以代和以溯祖单位为尺度的速率参数，并阐明这些单位之间的换算关系。根据您推导的分布，给出每种尺度下 $T_k$ 的期望值。\n- 将您的推导转化为一个正确的模拟算法，该算法使用为所选单位 $u$ 选择的适当速率来抽取 $T_k$（$k=5,4,3,2$）。\n- 通过将所有参数保持在合理的生物学范围内并遵守中性溯祖假设，来确保科学真实性。\n\n测试套件：\n您的程序必须在内部按所列顺序运行以下测试用例（不要求用户输入），并将结果汇总到单行输出中，具体格式如下。每个测试用例是一个元组 $(n,N_e,u,\\text{seed})$，其中所有用例的 $n=5$：\n- 用例 1：$(5,\\,10000,\\,\\text{\"coal\"},\\,12345)$。\n- 用例 2：$(5,\\,50000,\\,\\text{\"gen\"},\\,20231102)$。\n- 用例 3：$(5,\\,500,\\,\\text{\"gen\"},\\,42)$。\n- 用例 4：$(5,\\,10000,\\,\\text{\"gen\"},\\,0)$。\n\n单位：\n- 当 $u=\\text{\"gen\"}$ 时，以代为单位报告时间。\n- 当 $u=\\text{\"coal\"}$ 时，以溯祖单位报告时间，其中一个单位等于 $2N_e$ 代。\n\n答案类型和最终输出格式：\n- 对于每个测试用例，返回一个包含 $4$ 个浮点数的列表 $(T_5,T_4,T_3,T_2)$。\n- 您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例的四个浮点数的列表。例如，一个有效的输出形状是：[[t51,t41,t31,t21],[t52,t42,t32,t22],[t53,t43,t33,t23],[t54,t44,t34,t24]]。\n- 浮点数可以以标准的未舍入形式打印。\n\n您的解决方案必须包括：\n- 从上述基本依据出发，对溯祖间隔分布进行的有原则的推导。\n- 清晰的算法步骤描述。\n- 完整的程序，该程序执行模拟并为指定的测试套件生成所需的单行输出。", "solution": "该问题要求在中性 Wright-Fisher 模型下，针对一个大小为 $n=5$ 的谱系样本，在恒定的二倍体有效种群大小 $N_e$ 条件下，推导并模拟溯祖间隔等待时间。推导必须从第一性原理出发，并且模拟必须是可复现的，支持以代和溯祖单位两种时间单位。\n\n首先，我们将推导溯祖间隔时间 $T_k$ 的分布，即 $k$ 个祖先谱系中任意两个发生溯祖的等待时间。\n\n基本假设如下：\n$1$. 我们考虑一个大小恒定的二倍体种群，包含 $N_e$ 个个体，即每代有 $2N_e$ 个基因拷贝。\n$2$. 我们向后追溯一个大小为 $k$ 的谱系样本的祖先。\n$3$. 在中性 Wright-Fisher 模型下，第 $t+1$ 代的每个谱系从第 $t$ 代的 $2N_e$ 个基因拷贝中均匀随机地选择其亲本。\n\n考虑两个特定的谱系。它们在上一代选择同一个亲本基因拷贝的概率是 $1/(2N_e)$。它们不选择同一个亲本的概率是 $1 - 1/(2N_e)$。因此，溯祖事件在每一代中都是一个伯努利试验。直到第一次成功（溯祖）的时间服从成功概率为 $p = 1/(2N_e)$ 的几何分布。对于较大的有效种群大小 $N_e$（这是溯祖理论中的一个标准假设），这个离散时间的几何过程可以很好地被一个连续时间的指数等待过程所近似。该指数过程的速率 $\\lambda_{\\text{pair}}$ 等于在单个时间步长内事件发生的概率。因此，单对谱系的溯祖速率为：\n$$ \\lambda_{\\text{pair}} = \\frac{1}{2N_e} \\text{ 每代} $$\n这对特定谱系发生溯祖的等待时间是一个服从此速率的指数随机变量。\n\n现在，考虑有 $k$ 个不同祖先谱系的情况。当这些谱系中的任何一对找到共同祖先时，就会发生溯祖事件。不同无序谱系对的数量由二项式系数给出：\n$$ \\binom{k}{2} = \\frac{k(k-1)}{2} $$\n这 $\\binom{k}{2}$ 对中的每一对都代表了一次独立的溯祖事件机会。直到*下一个*溯祖事件发生前的总时间 $T_k$，是这 $\\binom{k}{2}$ 对谱系各自等待时间的最小值。指数分布的一个基本性质指出，一组独立指数随机变量的最小值本身也是一个指数随机变量。其速率是各个速率的总和。\n\n由于每对谱系以 $\\lambda_{\\text{pair}} = 1/(2N_e)$ 每代的速率发生溯祖，因此任何一对谱系的总溯祖速率 $\\lambda_k$ 是所有谱系对速率的总和：\n$$ \\lambda_k^{\\text{gen}} = \\binom{k}{2} \\times \\lambda_{\\text{pair}} = \\frac{k(k-1)}{2} \\times \\frac{1}{2N_e} = \\frac{k(k-1)}{4N_e} \\text{ 每代} $$\n因此，以代为单位测量的溯祖间隔时间 $T_k$ 是一个速率为 $\\lambda_k^{\\text{gen}}$ 的指数随机变量：\n$$ T_k(\\text{gen}) \\sim \\text{Exp}\\left(\\frac{k(k-1)}{4N_e}\\right) $$\n以代为单位的期望等待时间是速率的倒数：\n$$ E[T_k(\\text{gen})] = \\frac{1}{\\lambda_k^{\\text{gen}}} = \\frac{4N_e}{k(k-1)} $$\n\n接下来，我们推导以溯祖时间单位度量的分布。一个溯祖时间单位定义为 $2N_e$ 代。设 $t_{\\text{gen}}$ 是以代为单位的时间，而 $t_{\\text{coal}}$ 是以溯祖单位为单位的时间。它们的关系是：\n$$ t_{\\text{coal}} = \\frac{t_{\\text{gen}}}{2N_e} $$\n如果一个随机变量 $X$ 服从速率为 $\\lambda$ 的指数分布，那么经过尺度变换的随机变量 $Y = cX$ 服从速率为 $\\lambda/c$ 的指数分布。为了将速率从代转换为溯祖单位，我们使用缩放因子 $c = 1/(2N_e)$。新的速率 $\\lambda_k^{\\text{coal}}$ 是：\n$$ \\lambda_k^{\\text{coal}} = \\lambda_k^{\\text{gen}} \\times (2N_e) = \\left(\\frac{k(k-1)}{4N_e}\\right) \\times (2N_e) = \\frac{k(k-1)}{2} = \\binom{k}{2} $$\n因此，当时间以溯祖单位度量时，溯祖间隔时间 $T_k$ 服从一个速率与种群大小无关的指数分布：\n$$ T_k(\\text{coal}) \\sim \\text{Exp}\\left(\\binom{k}{2}\\right) $$\n以溯祖单位为单位的期望等待时间是：\n$$ E[T_k(\\text{coal})] = \\frac{1}{\\lambda_k^{\\text{coal}}} = \\frac{1}{\\binom{k}{2}} = \\frac{2}{k(k-1)} $$\n\n模拟算法的步骤如下。对于每个由 $(n, N_e, u, \\text{seed})$ 指定的测试用例：\n$1$. 使用提供的 `seed` 初始化伪随机数生成器，以确保可复现性。\n$2$. 模拟过程在时间上向后迭代，从 $k=n$ 递减到 $k=2$。对于本问题，$n=5$，因此循环对 $k \\in \\{5, 4, 3, 2\\}$ 运行。\n$3$. 在每次迭代 $k$ 中，根据指定的时间单位 $u$ 计算速率参数 $\\lambda_k$：\n    - 如果 $u = \\text{\"gen\"}$，速率为 $\\lambda_k^{\\text{gen}} = \\frac{k(k-1)}{4N_e}$。\n    - 如果 $u = \\text{\"coal\"}$，速率为 $\\lambda_k^{\\text{coal}} = \\binom{k}{2} = \\frac{k(k-1)}{2}$。\n$4$. 从具有所计算速率 $\\lambda_k$ 的指数分布中抽取一个随机变量 $T_k$。这可以通过逆变换采样法实现，即 $T_k = -\\ln(U) / \\lambda_k$，其中 $U \\sim \\text{Uniform}(0,1)$ 是一个均匀分布随机变量。在实践中，我们使用实现了此方法的库函数，例如 `numpy.random.exponential`，它接受一个尺度参数 $\\beta = 1/\\lambda_k$。\n$5$. 存储模拟出的时间 $T_k$。循环完成后，结果是一个包含四个时间间隔的列表：$(T_5, T_4, T_3, T_2)$。\n$6$. 对所有测试用例重复此过程，并将结果汇总成一个单一格式化的输出字符串。", "answer": "```python\nimport numpy as np\n\ndef simulate_coalescent_intervals(n, Ne, unit, seed):\n    \"\"\"\n    Simulates intercoalescent intervals for a sample of size n.\n\n    Args:\n        n (int): The initial sample size.\n        Ne (int): The diploid effective population size.\n        unit (str): The time unit, either \"gen\" (generations) or \"coal\" (coalescent units).\n        seed (int): The seed for the pseudorandom number generator.\n\n    Returns:\n        list[float]: A list of simulated intercoalescent intervals [T_n, T_{n-1}, ..., T_2].\n    \"\"\"\n    # 1. Initialize the pseudorandom number generator with the given seed.\n    rng = np.random.default_rng(seed)\n    \n    intervals = []\n    \n    # 2. Loop for k from n down to 2.\n    for k in range(n, 1, -1):\n        # 3. Calculate the rate parameter lambda_k.\n        num_pairs = k * (k - 1) / 2\n        \n        if unit == \"gen\":\n            # As derived, lambda_gen = k(k-1) / (4*Ne)\n            if Ne = 0:\n                raise ValueError(\"Effective population size Ne must be positive.\")\n            rate = num_pairs / (2 * Ne)\n        elif unit == \"coal\":\n            # For time in coalescent units, the rate is kC2.\n            rate = num_pairs\n        else:\n            raise ValueError(\"Unit must be 'gen' or 'coal'.\")\n            \n        # The scale parameter for numpy's exponential is 1/rate.\n        scale = 1.0 / rate\n        \n        # 4. Draw a random variate from the exponential distribution.\n        t_k = rng.exponential(scale)\n        \n        # 5. Store the simulated time.\n        intervals.append(t_k)\n        \n    return intervals\n\ndef solve():\n    \"\"\"\n    Runs the simulation for a predefined set of test cases and prints the results.\n    \"\"\"\n    # Define the test suite as specified in the problem statement.\n    # Each case is a tuple: (n, Ne, unit, seed)\n    test_cases = [\n        (5, 10000, \"coal\", 12345),\n        (5, 50000, \"gen\", 20231102),\n        (5, 500, \"gen\", 42),\n        (5, 10000, \"gen\", 0)\n    ]\n\n    # Aggregate results from all test cases.\n    all_results = []\n    for n, Ne, unit, seed in test_cases:\n        result = simulate_coalescent_intervals(n, Ne, unit, seed)\n        all_results.append(result)\n\n    # Format the final output string as per the problem requirements.\n    # The format is [[t51,t41,t31,t21],[t52,t42,t32,t22],...].\n    # str() on a list of lists creates spaces, which must be removed.\n    final_output = str(all_results).replace(\" \", \"\")\n    \n    print(final_output)\n\nsolve()\n```", "id": "2726286"}, {"introduction": "在掌握了单个种群内的溯祖过程后，我们现在将其扩展到物种树的背景下，探究谱系分选的核心现象：基因树与物种树的冲突。这个练习要求你构建一个具体的数据集，其中每个基因座都支持一个不同的进化历史，然后运用多物种溯祖模型来解释这个看似矛盾的现象。通过这个实践，你将巩固对不完全谱系分选（ILS）作为基因树冲突主要来源的理解，并锻炼推导这些事件发生概率的分析能力。[@problem_id:2726274]", "problem": "考虑一个有三个物种（标记为 $A$、$B$ 和 $C$）的有根物种树，其物种树拓扑为 $(A,B)\\mid C$。假设每个物种采样一个单倍体谱系，所有分支上的有效种群大小恒定且相等，基因座内无重组，基因座间自由重组。设分隔 $A$ 和 $B$ 的祖先种群与 $C$ 的内部分支长度为 $T$ 个合并单位，其中时间由相应的有效种群大小进行缩放，使得 $k$ 个谱系间的合并等待时间服从速率为 $\\binom{k}{2}$ 的指数分布。\n\n任务：\n1) 构筑一个跨越物种 $A$、$B$ 和 $C$ 的最小三基因座数据集（每个基因座一个短的比对序列），使得当独立分析每个基因座时，每个基因座支持三种可能拓扑 $(A,B)\\mid C$、$(A,C)\\mid B$ 和 $(B,C)\\mid A$ 中不同的一个有根基因树拓扑。您的数据集应在标准突变模型（例如，无限位点模型）下具有科学合理性，并通过指出哪个简约信息位点支持每个基因座推断出的基因树来证明其合理性。\n2) 使用多物种合并模型（MSC; Multispecies Coalescent）下的不完全谱系分选，从机理上解释一个内部分支长度为 $T$ 的单一物种树 $(A,B)\\mid C$ 如何能在三个独立的基因座上产生三种不同的有根基因树。\n3) 从合并理论的第一性原理（合并的指数等待时间，以及当三个谱系存在于同一祖先种群中时配对的对称性）出发，推导一个封闭形式的解析表达式，表示在 3 个独立的基因座上，观察到三种有根拓扑各出现一次的概率。您的最终答案必须是一个只含 $T$ 的简化解析表达式，不含数值近似或单位。不要使用任何预先记忆的快捷公式；从上面给出的基本合并假设中推导出您需要的一切。", "solution": "我们首先在无限位点模型下构建一个明确、合理的三基因座数据集，该数据集在三个基因座上产生三种不同的有根基因树。然后，我们解释为什么在具有不完全谱系分选的多物种合并模型（MSC; Multispecies Coalescent）下，这种不一致性是预料之中的。最后，我们从第一性原理出发，推导出三个独立基因座恰好一次性产生所有三种不同有根拓扑的概率，该概率是内部分支长度 $T$（以合并单位计）的函数。\n\n步骤 1：构建一个最小数据集。\n在无限位点模型下，一个将衍生状态置于支撑一对分类单元的分支上的双等位基因位点，为该分类单元对作为一个分支提供了简约性支持。对于三个分类单元，每个基因座一个信息性双等位基因位点就足够了。因此，我们可以提出以下比对序列，其中 $0$ 表示祖先状态，$1$ 表示衍生状态：\n\n- 基因座 $1$：$((A,B),C)$\n  - 位点模式：$A=1,\\ B=1,\\ C=0$。这个单一的简约信息位点支持 $((A,B),C)$。\n\n- 基因座 $2$：$((A,C),B)$\n  - 位点模式：$A=1,\\ B=0,\\ C=1$。这支持 $((A,C),B)$。\n\n- 基因座 $3$：$((B,C),A)$\n  - 位点模式：$A=0,\\ B=1,\\ C=1$。这支持 $((B,C),A)$。\n\n每个基因座都恰好有一个简约信息位点，与三种可能的有根基因树之一相符，并且这三个基因座共同实现了所有三种拓扑。\n\n步骤 2：为什么在 MSC 模型下，不一致的基因树与单一物种树是一致的。\n考虑内部分支长度为 $T$（以合并单位计）的物种树 $((A,B),C)$。从 $A$、$B$ 和 $C$ 各采样一个谱系。在 $A$ 和 $B$ 的祖先内部分支上，两个谱系 $A$ 和 $B$ 可以在到达 $A$、$B$ 和 $C$ 的共同祖先种群之前发生合并。如果 $A$ 和 $B$ 在这个内部分支上合并，那么该基因座的基因树必定是 $((A,B),C)$。如果它们未能在此内部分支上合并，那么所有三个谱系 $A$、$B$ 和 $C$ 将同时进入更深层的祖先种群；根据 3 个谱系合并过程的可交换性和对称性，第一次合并事件以 $1/3$ 的概率选择任意一对。因此，在未能在内部分支上合并的条件下，三种拓扑 $((A,B),C)$、$((A,C),B)$ 和 $((B,C),A)$ 中的每一种都以 $1/3$ 的概率发生。因此，即使物种树是 $((A,B),C)$，由于不完全谱系分选，不一致的基因树 $((A,C),B)$ 和 $((B,C),A)$ 也会以非零概率出现，尤其是在 $T$ 很小的时候。\n\n步骤 3：推导在三个基因座上观察到所有三种拓扑的概率。\n我们只使用基本的合并假设：\n\n- 在一个分支上，当同一群体中存在 $k$ 个谱系时，到下一次合并事件的等待时间服从速率为 $\\binom{k}{2}$ 的指数分布。\n- 如果三个谱系同时进入同一群体，由于可交换性，第一次合并事件以相等的概率 $1/3$ 将任意一对组合在一起。\n\n设 $T$ 为 $A$ 和 $B$ 的祖先内部分支的长度（以合并单位计），该分支是所有三个物种共同祖先的后代。\n\n对于单个基因座：\n- 谱系 $A$ 和 $B$ 在长度为 $T$ 的内部分支上不合并的概率是 $\\exp(-\\binom{2}{2} T) = \\exp(-T)$，因为该分支上有 $k=2$ 个谱系（$A$ 和 $B$），合并速率为 $\\binom{2}{2}=1$。\n- 以互补概率 $1-\\exp(-T)$，$A$ 和 $B$ 在内部分支上合并，产生基因树 $((A,B),C)$。\n- 如果 $A$ 和 $B$ 未能在内部分支上合并（概率为 $\\exp(-T)$），那么三个谱系 $A$、$B$ 和 $C$ 将一同进入祖先种群。第一次合并事件涉及任意一对的概率均为 $1/3$。因此，在内部分支上未能合并的条件下，三种有根基因树拓扑中的每一种都以 $1/3$ 的概率发生。\n\n因此，令 $p$ 表示每个基因座上基因树与物种树 $((A,B),C)$ 一致的概率，令 $q$ 表示每个不一致拓扑 $((A,C),B)$ 或 $((B,C),A)$ 的概率，我们有\n$$\np = \\left(1 - \\exp(-T)\\right) + \\exp(-T)\\cdot \\frac{1}{3}\n= 1 - \\frac{2}{3}\\exp(-T),\n$$\n$$\nq = \\exp(-T)\\cdot \\frac{1}{3} = \\frac{1}{3}\\exp(-T).\n$$\n\n在 3 个独立的基因座上（基因座间自由重组），我们观察到三种拓扑各出现一次的概率，等于在这些基因座上任何包含一个 $((A,B),C)$、一个 $((A,C),B)$ 和一个 $((B,C),A)$ 的有序拓扑分配的概率。对于一个特定的排序，概率是 $p\\cdot q\\cdot q$。这三个类别在 3 个基因座上有 $3! = 6$ 种不同的排列。因此，总概率是\n$$\n6\\,p\\,q^{2} = 6\\left(1 - \\frac{2}{3}\\exp(-T)\\right)\\left(\\frac{1}{3}\\exp(-T)\\right)^{2}.\n$$\n我们可以简化这个表达式：\n$$\n6\\left(1 - \\frac{2}{3}\\exp(-T)\\right)\\left(\\frac{1}{9}\\exp(-2T)\\right)\n= \\frac{6}{9}\\exp(-2T)\\left(1 - \\frac{2}{3}\\exp(-T)\\right)\n= \\frac{2}{3}\\exp(-2T) - \\frac{4}{9}\\exp(-3T).\n$$\n\n两种形式都是关于 $T$ 的有效封闭表达式。根据构造，这个概率量化了在多物种合并模型下，单个物种树如何在三个不连锁的基因座上产生三个不同的有根基因树，这与步骤 1 中的示例数据集一致。\n\n因此，所需的概率作为 $T$ 的函数是\n$$\n\\frac{2}{3}\\exp(-2T)\\left(1 - \\frac{2}{3}\\exp(-T)\\right),\n$$\n等价地，\n$$\n\\frac{2}{3}\\exp(-2T) - \\frac{4}{9}\\exp(-3T).\n$$", "answer": "$$\\boxed{\\frac{2}{3}\\exp(-2T)-\\frac{4}{9}\\exp(-3T)}$$", "id": "2726274"}, {"introduction": "在真实的基因组数据分析中，不完全谱系分选并非基因树冲突的唯一来源，基因渗入等过程同样会产生不一致的信号。这个高级练习将让你扮演数据科学家的角色，面对一个实际的挑战：如何从观测到的基因树拓扑结构频率中，区分并量化ILS和基因渗入各自的贡献。通过推导和实现一个期望最大化（EM）算法，你将学习到一种在现代系统发育基因组学中广泛应用的强大统计建模技术，从而能够从全基因组数据中获得更精细的进化推断。[@problem_id:2726261]", "problem": "考虑一个由四个物种组成的单一无根四分类群，其基因树拓扑有三种可能，分别表示为 $\\mathcal{T}_s$（与物种树匹配的一致性拓扑）、$\\mathcal{T}_1$ 和 $\\mathcal{T}_2$（两种不一致的替代拓扑）。在多物种溯祖模型下，对于一个内部枝长为 $t$（以溯祖单位计量）的对称四分类群，一个随机取样的中性位点具有基因树拓扑 $\\mathcal{T}_s$ 的概率为 $p_s(t) = 1 - \\tfrac{2}{3} e^{-t}$，而每种不一致拓扑的概率分别为 $p_a(t) = \\tfrac{1}{3} e^{-t}$ 和 $p_b(t) = \\tfrac{1}{3} e^{-t}$。假设在 $L$ 个独立位点上，我们观察到的基因树拓扑计数为 $\\mathbf{n} = (n_s, n_1, n_2)$，其中 $n_s$ 是支持 $\\mathcal{T}_s$ 的位点数， $n_1$ 是支持 $\\mathcal{T}_1$ 的位点数， $n_2$ 是支持 $\\mathcal{T}_2$ 的位点数，且 $L = n_s + n_1 + n_2$。\n\n我们为每个位点的拓扑分布假设一个双组分混合模型：一个是不完全谱系分选（ILS）组分，其分布为 $\\mathbf{p}^{\\mathrm{ILS}}(t) = \\big(p_s(t), p_a(t), p_b(t)\\big)$；另一个是基因渗入引起的拓扑组分，其在 $\\{\\mathcal{T}_s,\\mathcal{T}_1,\\mathcal{T}_2\\}$ 上具有已知的分布 $\\mathbf{q} = (q_s, q_1, q_2)$。设 $\\pi \\in [0,1]$ 为基因渗入组分的混合比例（以小数表示，非百分比），则每个位点上拓扑的边际分布为\n$$\n\\mathbf{m}(\\pi, t) \\;=\\; (1-\\pi)\\,\\mathbf{p}^{\\mathrm{ILS}}(t) \\;+\\; \\pi\\,\\mathbf{q}.\n$$\n假设在给定 $(\\pi,t)$ 的情况下，各位点是独立同分布的，并且对于每种情景，$\\mathbf{q}$ 和 $t$ 都是已知的常数。给定观测计数 $\\mathbf{n}$ 时 $\\pi$ 的似然是一个多项分布，其类别概率为 $\\mathbf{m}(\\pi,t)$。\n\n您的任务是：\n- 为每个位点 $\\ell \\in \\{1,\\dots,L\\}$ 构建一个潜变量模型，其中包含一个隐藏指示变量 $z_\\ell \\in \\{0,1\\}$，$z_\\ell = 1$ 表示位点 $\\ell$ 来自基因渗入组分，$z_\\ell = 0$ 表示来自 ILS 组分。推导用于估计最大似然值 $\\hat{\\pi}$ 的期望最大化 (EM) 算法更新步骤，并将 $\\mathbf{q}$ 和 $t$ 视为已知。您必须从对称四分类群的多物种溯祖概率定义以及已知组分分布的有限混合模型的标准完全数据对数似然出发。在这些基础之外，不得引入任何额外的简化公式。\n- 实现一个程序，对于下方的每个测试用例，使用初始化值 $\\pi^{(0)} = 0.5$ 通过 EM 算法计算 $\\hat{\\pi}$，迭代直至 $\\pi$ 的绝对变化小于 $\\varepsilon = 10^{-12}$ 或达到 $10{,}000$ 次迭代的最大限制，以先到者为准。为确保数值稳定性，每次更新后将迭代值约束在闭区间 $[10^{-12}, 1 - 10^{-12}]$ 内。\n\n测试套件。对于每个测试用例，您将获得：内部枝长 $t$（以溯祖单位计），基因渗入组分分布 $\\mathbf{q}$，以及观测到的计数 $\\mathbf{n} = (n_s, n_1, n_2)$。在每种情况下，将 $\\mathbf{q}$ 视为固定且精确已知的，并使用上述多物种溯祖表达式计算 $\\mathbf{p}^{\\mathrm{ILS}}(t)$。然后运行 EM 算法从 $\\mathbf{n}$ 估计 $\\hat{\\pi}$。\n- 情况 1：$t = 1.0$, $\\mathbf{q} = (0, 1, 0)$, $\\mathbf{n} = (528, 386, 86)$。\n- 情况 2：$t = 0.5$, $\\mathbf{q} = (0, 1, 0)$, $\\mathbf{n} = (357, 121, 122)$。\n- 情况 3：$t = 1.5$, $\\mathbf{q} = (0, 1, 0), \\mathbf{n} = (34, 763, 3)$。\n- 情况 4：$t = 0.05$, $\\mathbf{q} = (0, 1, 0), \\mathbf{n} = (329, 386, 285)$。\n- 情况 5：$t = 0.8$, $\\mathbf{q} = (0, 0, 1), \\mathbf{n} = (630, 135, 435)$。\n\n您的程序必须生成单行输出，其中包含估计的混合比例，形式为一个用方括号括起来的逗号分隔列表，每个估计值四舍五入到小数点后恰好六位，并按上述情况的顺序排列。例如，输出必须采用以下格式\n$[\\hat{\\pi}_1,\\hat{\\pi}_2,\\hat{\\pi}_3,\\hat{\\pi}_4,\\hat{\\pi}_5]$，\n其中每个 $\\hat{\\pi}_i$ 都是一个小数点后恰好有六位的小数。不涉及物理单位，比例必须是小数，而不是百分比。", "solution": "该问题要求推导并实现一个期望最大化 (EM) 算法，以估计一个用于基因树拓扑的双组分混合模型中的混合比例 $\\pi$。该模型结合了不完全谱系分选 (ILS) 和基因渗入。\n\n### 模型设定\n\n对于一个四分类群，可能的无根基因树拓扑集合为 $\\{\\mathcal{T}_s, \\mathcal{T}_1, \\mathcal{T}_2\\}$。\n拓扑的分布是两个组分的混合：\n\n1.  **ILS 组分：** 其概率由对称四分类群的多物种溯祖模型控制，内部枝长为 $t$（以溯祖单位计）。令 $\\mathbf{p}^{\\mathrm{ILS}}(t) = (p_s(t), p_1(t), p_2(t))$，其中：\n    $$ p_s(t) = 1 - \\tfrac{2}{3} e^{-t} $$\n    $$ p_1(t) = p_2(t) = \\tfrac{1}{3} e^{-t} $$\n    这些分别是与物种树一致的拓扑 ($\\mathcal{T}_s$) 和两种不一致拓扑 ($\\mathcal{T}_1, \\mathcal{T}_2$) 的概率。为简化符号，由于 $t$ 是一个已知常数，我们将 $p_j(t)$ 记为 $p_j$，其中 $j \\in \\{s, 1, 2\\}$。\n\n2.  **基因渗入组分：** 该组分在这些拓扑上有一个已知的、固定的分布，记为 $\\mathbf{q} = (q_s, q_1, q_2)$。\n\n待估计的参数是 $\\pi \\in [0, 1]$，即基因渗入组分的混合比例。观测到拓扑 $j \\in \\{s, 1, 2\\}$ 的边际概率是：\n$$ m_j(\\pi) = (1-\\pi)p_j + \\pi q_j $$\n\n观测数据包括在 $L = n_s + n_1 + n_2$ 个独立位点上三种拓扑的计数 $\\mathbf{n} = (n_s, n_1, n_2)$。\n\n### 潜变量表述\n\n为了推导 EM 算法，我们为每个位点 $\\ell \\in \\{1, \\dots, L\\}$ 引入一个潜指示变量 $z_\\ell \\in \\{0, 1\\}$。\n-   $z_\\ell = 0$，如果位点 $\\ell$ 来自 ILS 组分。\n-   $z_\\ell = 1$，如果位点 $\\ell$ 来自基因渗入组分。\n\n单个位点 $\\ell$ 的观测数据是其拓扑，我们可以用一个指示向量 $\\mathbf{y}_\\ell$ 来表示（例如，$(1,0,0)$ 表示 $\\mathcal{T}_s$）。位点 $\\ell$ 的完全数据是数据对 $(\\mathbf{y}_\\ell, z_\\ell)$。一个位点的完全数据的概率是：\n$$ P(\\mathbf{y}_\\ell, z_\\ell | \\pi) = [ (1-\\pi)P(\\mathbf{y}_\\ell | z_\\ell=0) ]^{1-z_\\ell} [ \\pi P(\\mathbf{y}_\\ell | z_\\ell=1) ]^{z_\\ell} $$\n如果位点 $\\ell$ 的拓扑是 $j$，那么 $P(\\mathbf{y}_\\ell=\\text{拓扑 }j | z_\\ell=0) = p_j$ 且 $P(\\mathbf{y}_\\ell=\\text{拓扑 }j | z_\\ell=1) = q_j$。\n\n### 完全数据对数似然\n\n所有 $L$ 个位点的完全数据对数似然是每个独立完全观测值的对数概率之和：\n$$ \\mathcal{L}_c(\\pi) = \\sum_{\\ell=1}^{L} \\log P(\\mathbf{y}_\\ell, z_\\ell | \\pi) = \\sum_{\\ell=1}^{L} \\left[ (1-z_\\ell) \\log(1-\\pi) + (1-z_\\ell)\\log p(\\mathbf{y}_\\ell) + z_\\ell \\log(\\pi) + z_\\ell \\log q(\\mathbf{y}_\\ell) \\right] $$\n其中 $p(\\mathbf{y}_\\ell)$ 和 $q(\\mathbf{y}_\\ell)$ 分别是位点 $\\ell$ 的观测拓扑在 ILS 和基因渗入组分下的概率。\n\n按 $\\pi$ 对各项进行分组：\n$$ \\mathcal{L}_c(\\pi) = \\left( \\sum_{\\ell=1}^{L} (1-z_\\ell) \\right) \\log(1-\\pi) + \\left( \\sum_{\\ell=1}^{L} z_\\ell \\right) \\log(\\pi) + C $$\n其中 $C$ 包含不依赖于 $\\pi$ 的项。令 $N_0 = \\sum_{\\ell=1}^{L} (1-z_\\ell)$ 和 $N_1 = \\sum_{\\ell=1}^{L} z_\\ell$ 分别为来自 ILS 组分和基因渗入组分的未观测到的位点总数。\n$$ \\mathcal{L}_c(\\pi) = N_0 \\log(1-\\pi) + N_1 \\log(\\pi) + C $$\n\n### 期望最大化 (EM) 算法推导\n\nEM 算法是一个迭代过程，由一个期望 (E) 步骤和一个最大化 (M) 步骤组成。\n\n**E-步骤：**\n在第 $k+1$ 次迭代的 E-步骤中，我们计算完全数据对数似然关于潜变量 $Z = \\{z_\\ell\\}$ 的后验分布的期望，该后验分布是给定观测数据 $Y = \\{\\mathbf{y}_\\ell\\}$ 和当前参数估计 $\\pi^{(k)}$ 的。这就是 Q-函数：\n$$ Q(\\pi | \\pi^{(k)}) = E_{Z|Y, \\pi^{(k)}}[\\mathcal{L}_c(\\pi)] $$\n由于期望的线性性质，我们只需要潜变量 $z_\\ell$ 的期望。令 $\\gamma_\\ell^{(k)} = E[z_\\ell | \\mathbf{y}_\\ell, \\pi^{(k)}]$。这是在给定观测拓扑和当前估计 $\\pi^{(k)}$ 的条件下，位点 $\\ell$ 属于基因渗入组分的后验概率。\n使用贝叶斯定理：\n$$ \\gamma_\\ell^{(k)} = P(z_\\ell=1 | \\mathbf{y}_\\ell, \\pi^{(k)}) = \\frac{ P(\\mathbf{y}_\\ell | z_\\ell=1) P(z_\\ell=1 | \\pi^{(k)}) }{ P(\\mathbf{y}_\\ell | \\pi^{(k)}) } $$\n$\\gamma_\\ell^{(k)}$ 的值仅取决于位点 $\\ell$ 的拓扑。对于一个拓扑为 $j \\in \\{s, 1, 2\\}$ 的位点，这个责任 (responsibility) 是：\n$$ \\gamma_j^{(k)} = \\frac{ \\pi^{(k)} q_j }{ (1-\\pi^{(k)})p_j + \\pi^{(k)}q_j } $$\nQ-函数变为：\n$$ Q(\\pi | \\pi^{(k)}) = E_{Z|Y, \\pi^{(k)}}[N_0 \\log(1-\\pi) + N_1 \\log(\\pi)] + C' $$\n$$ Q(\\pi | \\pi^{(k)}) = E[N_0] \\log(1-\\pi) + E[N_1] \\log(\\pi) + C' $$\n期望计数为：\n$E[N_1] = E[\\sum_{\\ell=1}^L z_\\ell] = \\sum_{\\ell=1}^L E[z_\\ell | \\mathbf{y}_\\ell, \\pi^{(k)}] = \\sum_{j \\in \\{s,1,2\\}} n_j \\gamma_j^{(k)}$。\n$E[N_0] = L - E[N_1]$。\n\n**M-步骤：**\n在 M-步骤中，我们找到使 $Q(\\pi | \\pi^{(k)})$ 最大化的 $\\pi$ 值，从而得到下一个估计值 $\\pi^{(k+1)}$。我们将 $Q(\\pi | \\pi^{(k)})$ 对 $\\pi$ 求导并令其为零：\n$$ \\frac{\\partial Q}{\\partial \\pi} = -\\frac{E[N_0]}{1-\\pi} + \\frac{E[N_1]}{\\pi} = 0 $$\n解出 $\\pi$ 得：\n$$ \\pi = \\frac{E[N_1]}{E[N_0] + E[N_1]} = \\frac{E[N_1]}{L} $$\n因此，$\\pi$ 的更新规则是：\n$$ \\pi^{(k+1)} = \\frac{1}{L} \\sum_{j \\in \\{s,1,2\\}} n_j \\gamma_j^{(k)} $$\n代入 $\\gamma_j^{(k)}$ 的表达式：\n$$ \\pi^{(k+1)} = \\frac{1}{L} \\sum_{j \\in \\{s,1,2\\}} n_j \\left( \\frac{\\pi^{(k)} q_j}{(1-\\pi^{(k)})p_j + \\pi^{(k)}q_j} \\right) $$\n\n此迭代过程以 $\\pi^{(0)}=0.5$ 为初值启动，并重复进行直至收敛，收敛定义为 $|\\pi^{(k+1)} - \\pi^{(k)}|  \\varepsilon = 10^{-12}$。为确保数值稳定性，将 $\\pi$ 的中间值约束在 $[10^{-12}, 1-10^{-12}]$ 内。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all given test cases.\n    It computes the maximum likelihood estimate of the introgression proportion pi\n    for each case using an Expectation-Maximization (EM) algorithm.\n    \"\"\"\n\n    def estimate_pi(t, q, n, pi0, tol, max_iter, clip_val):\n        \"\"\"\n        Estimates the mixing proportion pi using the EM algorithm.\n\n        Args:\n            t (float): Internal branch length in coalescent units.\n            q (tuple): The introgression component distribution (q_s, q_1, q_2).\n            n (tuple): The observed gene-tree counts (n_s, n_1, n_2).\n            pi0 (float): Initial value for pi.\n            tol (float): Convergence tolerance.\n            max_iter (int): Maximum number of iterations.\n            clip_val (float): Value for numerical stability clipping.\n\n        Returns:\n            float: The estimated mixing proportion pi.\n        \"\"\"\n        ns, n1, n2 = n\n        qs, q1, q2 = q\n        L = float(ns + n1 + n2)\n\n        # A case with no data has no basis for an estimate; return initial.\n        if L == 0:\n            return pi0\n\n        # Pre-calculate ILS probabilities (p_s, p_1, p_2)\n        # Note: p_1 = p_2 for symmetric quartet\n        e_neg_t = np.exp(-t)\n        p_s = 1.0 - (2.0 / 3.0) * e_neg_t\n        p_a = (1.0 / 3.0) * e_neg_t\n        p = np.array([p_s, p_a, p_a])\n        \n        q_vec = np.array([qs, q1, q2])\n        n_vec = np.array([ns, n1, n2])\n\n        pi_k = pi0\n\n        for _ in range(max_iter):\n            # E-step: Calculate responsibilities (posterior probabilities gamma_j)\n            # gamma_j = P(locus is from introgression | locus has topology j)\n            \n            # Denominator for Bayes' rule: m_j = (1-pi)*p_j + pi*q_j\n            denom = (1.0 - pi_k) * p + pi_k * q_vec\n            \n            responsibilities = np.zeros(3)\n            # Numerator: pi * q_j\n            num = pi_k * q_vec\n            \n            # Calculate gamma_j where denom is non-zero to avoid division by zero.\n            # If denom[j] is 0, it implies n_vec[j] must be 0 for a valid model,\n            # so the contribution to the sum is 0.\n            safe_indices = denom > 1e-100 # Use a small threshold for safety\n            responsibilities[safe_indices] = num[safe_indices] / denom[safe_indices]\n\n            # M-step: Update pi\n            # Expected number of loci from the introgression component\n            n1_exp = np.sum(n_vec * responsibilities)\n            \n            pi_new = n1_exp / L\n            \n            # Enforce numerical stability constraints\n            pi_k_plus_1 = np.clip(pi_new, clip_val, 1.0 - clip_val)\n\n            # Check for convergence\n            if np.abs(pi_k_plus_1 - pi_k)  tol:\n                pi_k = pi_k_plus_1\n                break\n            \n            pi_k = pi_k_plus_1\n\n        return pi_k\n\n    # Test suite from the problem statement\n    test_cases = [\n        {'t': 1.0, 'q': (0.0, 1.0, 0.0), 'n': (528, 386, 86)},\n        {'t': 0.5, 'q': (0.0, 1.0, 0.0), 'n': (357, 121, 122)},\n        {'t': 1.5, 'q': (0.0, 1.0, 0.0), 'n': (34, 763, 3)},\n        {'t': 0.05, 'q': (0.0, 1.0, 0.0), 'n': (329, 386, 285)},\n        {'t': 0.8, 'q': (0.0, 0.0, 1.0), 'n': (630, 135, 435)}\n    ]\n\n    # Algorithm parameters\n    pi0 = 0.5\n    tolerance = 1e-12\n    max_iterations = 10000\n    clip_value = 1e-12\n\n    results = []\n    for case in test_cases:\n        pi_hat = estimate_pi(\n            case['t'], case['q'], case['n'],\n            pi0, tolerance, max_iterations, clip_value\n        )\n        results.append(pi_hat)\n        \n    # Format the output as specified: a list of strings, each with 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2726261"}]}