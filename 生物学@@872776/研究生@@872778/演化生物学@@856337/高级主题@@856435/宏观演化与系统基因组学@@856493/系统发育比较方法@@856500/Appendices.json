{"hands_on_practices": [{"introduction": "为了在物种间进行有效的性状比较，我们必须首先解决因共同祖先而产生的数据非独立性问题。系统发育独立比较法 (Phylogenetically Independent Contrasts, PIC) 是解决此问题的基石方法。本练习将引导您完成计算一个基本独立比较值的过程，从而为更复杂的分析打下坚实的基础。[@problem_id:1761373]", "problem": "一位进化生物学家正在研究一小组圣甲虫的体型进化。她为三个物种构建了系统发育树并收集了体型数据：*Rhinoceps ferox*、*Goliathus parvus* 和 *Chalcosoma medius*。系统发育关系如下：*R. ferox* 和 *G. parvus* 是姐妹种，它们的共同祖先代表了一个与 *C. medius* 互为姐妹群的分支。\n\n分支长度代表进化时间（单位：百万年，Myr），具体如下：\n- 从 *R. ferox* 和 *G. parvus* 的共同祖先到现今 *R. ferox* 的分支长度为 2 Myr。\n- 从 *R. ferox* 和 *G. parvus* 的共同祖先到现今 *G. parvus* 的分支长度为 2 Myr。\n- 从该三物种树的根节点到 *R. ferox* 和 *G. parvus* 的共同祖先的分支长度为 3 Myr。\n- 从树的根节点到现今 *C. medius* 的分支长度为 5 Myr。\n\n这些物种的平均成年体长为：\n- *Rhinoceps ferox*：45.5 毫米\n- *Goliathus parvus*：52.1 毫米\n- *Chalcosoma medius*：38.0 毫米\n\n为了准备比较分析，必须计算体长性状的系统发育独立比较值。使用该方法的标准算法，计算在此三物种树的根节点处计算的独立比较的数值。假设性状进化遵循布朗运动模型。答案请四舍五入至三位有效数字。", "solution": "题目要求计算一个三物种树的根节点的系统发育独立比较值。我们将使用 Felsenstein 的算法，该算法从树的末端（叶节点）向根节点进行计算。\n\n为清晰起见，我们用符号表示物种、它们的性状值和分支长度。\n设物种 A 为 *Rhinoceps ferox*，物种 B 为 *Goliathus parvus*，物种 C 为 *Chalcosoma medius*。\n性状值（体长）为：\n$x_A = 45.5$ 毫米\n$x_B = 52.1$ 毫米\n$x_C = 38.0$ 毫米\n\n分支长度为：\n- 通向物种 A 的末端分支，$v_A = 2$ Myr。\n- 通向物种 B 的末端分支，$v_B = 2$ Myr。\n- 通向物种 C 的末端分支，$v_C = 5$ Myr。\n- 通向 A 和 B 共同祖先（我们称之为节点1）的内部分支，其长度为 $v_{1, \\text{stem}} = 3$ Myr。\n\n对于这棵树，该算法包括两个主要部分：首先，计算姐妹种A和B之间的比较值，并估计它们共同祖先（节点1）的状态；其次，计算节点1和物种C之间的比较值。\n\n**步骤 1：计算姐妹种 A 和 B 之间的比较值。**\n第一个独立比较值 $C_1$ 是 A 和 B 性状值的差异，通过其分支长度之和的平方根进行标准化。减法的顺序是任意的；我们将计算 $x_B - x_A$。\n$$\nC_1 = \\frac{x_B - x_A}{\\sqrt{v_A + v_B}}\n$$\n代入数值：\n$$\nC_1 = \\frac{52.1 - 45.5}{\\sqrt{2 + 2}} = \\frac{6.6}{\\sqrt{4}} = \\frac{6.6}{2} = 3.3\n$$\n\n**步骤 2：估计共同祖先（节点 1）处的性状值。**\n节点 1 处的性状值 $x_1$ 是其后代性状值的加权平均，权重为相应分支长度的倒数。\n$$\nx_1 = \\frac{\\frac{1}{v_A}x_A + \\frac{1}{v_B}x_B}{\\frac{1}{v_A} + \\frac{1}{v_B}}\n$$\n由于 $v_A = v_B = 2$，这可以简化为算术平均值：\n$$\nx_1 = \\frac{x_A + x_B}{2} = \\frac{45.5 + 52.1}{2} = \\frac{97.6}{2} = 48.8\n$$\n因此，节点 1 处祖先的估计体长为 48.8 毫米。\n\n**步骤 3：更新节点 1 的分支长度。**\n在下一步计算中，节点 1 现在扮演着一个叶节点的角色。其分支长度需要进行调整，以解释步骤 2 中估计引入的方差。新的分支长度 $v'_1$ 是其原始主干分支长度加上一个与从它延伸出的分支长度相关的项。\n$$\nv'_1 = v_{1, \\text{stem}} + \\frac{v_A v_B}{v_A + v_B}\n$$\n代入数值：\n$$\nv'_1 = 3 + \\frac{2 \\times 2}{2 + 2} = 3 + \\frac{4}{4} = 3 + 1 = 4\n$$\n节点 1 调整后的分支长度为 4 Myr。\n\n**步骤 4：计算根节点的比较值。**\n最后一步是计算树根节点的比较值。这个比较值 $C_{\\text{root}}$ 是在新表征的节点 1 和剩余物种 C 之间计算的。我们使用它们各自的性状值（$x_1$ 和 $x_C$）和分支长度（$v'_1$ 和 $v_C$）。\n$$\nC_{\\text{root}} = \\frac{x_1 - x_C}{\\sqrt{v'_1 + v_C}}\n$$\n代入计算出的和给定的数值：\n$$\nC_{\\text{root}} = \\frac{48.8 - 38.0}{\\sqrt{4 + 5}} = \\frac{10.8}{\\sqrt{9}} = \\frac{10.8}{3} = 3.6\n$$\n在根节点计算的独立比较值为 3.6。\n\n**步骤 5：最终四舍五入。**\n题目要求答案保留三位有效数字。计算值为 3.6，表示为三位有效数字即为 3.60。", "answer": "$$\\boxed{3.60}$$", "id": "1761373"}, {"introduction": "虽然独立比较法 (IC) 具有开创性意义，但系统发育广义最小二乘法 (Phylogenetic Generalized Least Squares, PGLS) 提供了一个更为通用和灵活的框架。一个核心的理论要点是，在布朗运动模型下，IC 回归与 PGLS 得到的结果是等价的。本练习旨在通过一个具体的例子，让您亲手计算并验证这一重要结论，从而深刻理解这两种方法之间的内在联系。[@problem_id:2742873]", "problem": "考虑一个平衡的四分类单元系统发育树，其拓扑结构为 $\\big((A,B),(C,D)\\big)$，其中所有枝长均为 $1$（即，每个叶尖到根的距离为 $2$，姐妹对共享一个长度为 $1$ 的内部枝，并且两个分支 $(A,B)$ 和 $(C,D)$ 之间没有共享的枝长）。在叶尖处测量了两个连续性状 $X$ 和 $Y$，观测值如下：\n- $X_{A}=1$, $X_{B}=5$, $X_{C}=2$, $X_{D}=8$,\n- $Y_{A}=2$, $Y_{B}=12$, $Y_{C}=3$, $Y_{D}=14$.\n\n假设一个性状演化的布朗运动模型，其方差与枝长成正比，且无测量误差。使用以下基本原则：\n- 在已知系统发育树上的布朗运动下，一个叶尖值的方差等于从根到该叶尖的总路径长度，两个叶尖之间的协方差等于从根到它们最近共同祖先的共享路径长度。\n- 对于Felsenstein的系统发育独立对比（IC），在一个分叉点，其后代性状值为 $x_{i}$ 和 $x_{j}$，到该节点的枝长为 $v_{i}$ 和 $v_{j}$，则重建的祖先值为 $(x_{i}/v_{i}+x_{j}/v_{j})/(1/v_{i}+1/v_{j})$，相应的方差为 $1/(1/v_{i}+1/v_{j})$。该节点的标准化对比为 $(x_{i}-x_{j})/\\sqrt{v_{i}+v_{j}}$，对于更高节点的对比，到祖先的枝长是原始内部枝长加上重建的方差。\n- 在具有独立同分布误差的过原点普通最小二乘法中，对于数据对 $(U_{X,k},U_{Y,k})$，斜率估计量为 $\\hat{\\beta}=\\sum_{k} U_{X,k}U_{Y,k}/\\sum_{k} U_{X,k}^{2}$，残差方差估计为 $\\hat{s}^{2}=\\sum_{k} \\hat{\\epsilon}_{k}^{2}/(n-1)$，且 $\\mathrm{SE}(\\hat{\\beta})=\\sqrt{\\hat{s}^{2}/\\sum_{k} U_{X,k}^{2}}$，其中 $n$ 是对比的数量。\n- 在系统发育广义最小二乘法（PGLS）中，响应向量为 $y$，预测向量为 $x$，协方差矩阵为 $V=\\sigma^{2}C$（由布朗运动模型和树隐含），在带截距的模型中，广义最小二乘估计量为 $(X^{\\top}V^{-1}X)^{-1}X^{\\top}V^{-1}y$，其中 $X=[\\mathbf{1}\\ \\ x]$。估计的残差方差为 $\\hat{s}^{2}=(y-X\\hat{\\beta})^{\\top}V^{-1}(y-X\\hat{\\beta})/(n-p)$，其中 $p=2$，斜率的标准误是 $\\hat{s}^{2}(X^{\\top}V^{-1}X)^{-1}$ 中斜率对角元素的平方根。\n\n任务：\n1) 计算由给定树和布朗运动假设所隐含的 $X$ 和 $Y$ 的三个标准化独立对比。然后拟合过原点的回归 $U_{Y}=\\beta\\,U_{X}+\\epsilon$ 以获得独立对比估计 $\\hat{\\beta}_{\\mathrm{IC}}$ 及其标准误。\n\n2) 构建在给定树上布朗运动下叶尖值的系统发育协方差矩阵 $C$，计算 $V^{-1}$（在一个比例常数范围内），并拟合带截距的PGLS以获得斜率 $\\hat{\\beta}_{\\mathrm{PGLS}}$ 及其 standard error。\n\n3) 证明对于此数据集，两个斜率估计是相同的，并且两个标准误也是相同的，从而经验性地证明在匹配假设下，独立对比和系统发育广义最小二乘法的等价性。\n\n报告共同的斜率估计 $\\hat{\\beta}$ 作为最简分数作为您的最终答案。不包括单位，也不要四舍五入；给出精确值。", "solution": "所述问题具有科学依据，提法恰当，客观且自成体系。它代表了系统发育比较方法中的一个标准练习，提供了所有必要的数据、模型和公式。验证清单中的缺陷均不存在。因此，该问题被认为是有效的，并将提供完整解答。\n\n该系统发育树是一个平衡的四分类单元树，拓扑结构为 $\\big((A,B),(C,D)\\big)$。所有枝长均为 $1$。设根为 $R$，物种 $A$ 和 $B$ 的最近共同祖先（MRCA）为节点 $N_{AB}$，$C$ 和 $D$ 的MRCA为节点 $N_{CD}$。所述枝长为 $l(R, N_{AB}) = 1$, $l(R, N_{CD}) = 1$, $l(N_{AB}, A) = 1$, $l(N_{AB}, B) = 1$, $l(N_{CD}, C) = 1$ 和 $l(N_{CD}, D) = 1$。该结构与每个叶尖到根的距离为 $2$ 的条件一致。\n\n提供的性状数据是向量 $X = \\begin{pmatrix} X_A \\\\ X_B \\\\ X_C \\\\ X_D \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 5 \\\\ 2 \\\\ 8 \\end{pmatrix}$ 和 $Y = \\begin{pmatrix} Y_A \\\\ Y_B \\\\ Y_C \\\\ Y_D \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 12 \\\\ 3 \\\\ 14 \\end{pmatrix}$。\n\n**任务1: Felsenstein的独立对比 (IC)**\n我们计算 $n-1 = 4-1 = 3$ 个标准化独立对比。\n\n在节点 $N_{AB}$ 处的对比：\n从该节点到后代 $A$ 和 $B$ 的枝长为 $v_A = 1$ 和 $v_B = 1$。\n性状 $X$ 的标准化对比为 $U_{X,1} = \\frac{X_A - X_B}{\\sqrt{v_A + v_B}} = \\frac{1-5}{\\sqrt{1+1}} = \\frac{-4}{\\sqrt{2}} = -2\\sqrt{2}$。\n性状 $Y$ 的标准化对比为 $U_{Y,1} = \\frac{Y_A - Y_B}{\\sqrt{v_A + v_B}} = \\frac{2-12}{\\sqrt{1+1}} = \\frac{-10}{\\sqrt{2}} = -5\\sqrt{2}$。\n在 $N_{AB}$ 处 $X$ 的估计祖先状态为 $X_{N_{AB}} = \\frac{X_A/v_A + X_B/v_B}{1/v_A + 1/v_B} = \\frac{1/1 + 5/1}{1/1 + 1/1} = \\frac{6}{2} = 3$。\n对于 $Y$，它是 $Y_{N_{AB}} = \\frac{Y_A/v_A + Y_B/v_B}{1/v_A + 1/v_B} = \\frac{2/1 + 12/1}{1/1 + 1/1} = \\frac{14}{2} = 7$。\n该估计的方差为 $Var_{N_{AB}} = \\frac{1}{1/v_A + 1/v_B} = \\frac{1}{1/1 + 1/1} = \\frac{1}{2}$。\n\n在节点 $N_{CD}$ 处的对比：\n枝长为 $v_C = 1$ 和 $v_D = 1$。\n$U_{X,2} = \\frac{X_C - X_D}{\\sqrt{v_C + v_D}} = \\frac{2-8}{\\sqrt{1+1}} = \\frac{-6}{\\sqrt{2}} = -3\\sqrt{2}$。\n$U_{Y,2} = \\frac{Y_C - Y_D}{\\sqrt{v_C + v_D}} = \\frac{3-14}{\\sqrt{1+1}} = \\frac{-11}{\\sqrt{2}}$。\n$X_{N_{CD}} = \\frac{X_C/v_C + X_D/v_D}{1/v_C + 1/v_D} = \\frac{2/1 + 8/1}{1/1 + 1/1} = \\frac{10}{2} = 5$。\n$Y_{N_{CD}} = \\frac{Y_C/v_C + Y_D/v_D}{1/v_C + 1/v_D} = \\frac{3/1 + 14/1}{1/1 + 1/1} = \\frac{17}{2}$。\n$Var_{N_{CD}} = \\frac{1}{1/v_C + 1/v_D} = \\frac{1}{1/1 + 1/1} = \\frac{1}{2}$。\n\n在根节点 $R$ 处的对比：\n后代是节点 $N_{AB}$ 和 $N_{CD}$。根据问题描述更新枝长：$v_{N_{AB}} = l(R,N_{AB}) + Var_{N_{AB}} = 1 + \\frac{1}{2} = \\frac{3}{2}$ 和 $v_{N_{CD}} = l(R,N_{CD}) + Var_{N_{CD}} = 1 + \\frac{1}{2} = \\frac{3}{2}$。\n$U_{X,3} = \\frac{X_{N_{AB}} - X_{N_{CD}}}{\\sqrt{v_{N_{AB}} + v_{N_{CD}}}} = \\frac{3-5}{\\sqrt{3/2 + 3/2}} = \\frac{-2}{\\sqrt{3}}$。\n$U_{Y,3} = \\frac{Y_{N_{AB}} - Y_{N_{CD}}}{\\sqrt{v_{N_{AB}} + v_{N_{CD}}}} = \\frac{7 - 17/2}{\\sqrt{3/2 + 3/2}} = \\frac{-3/2}{\\sqrt{3}} = -\\frac{\\sqrt{3}}{2}$。\n\n拟合过原点的回归 $U_Y = \\beta U_X + \\epsilon$：\n斜率估计量为 $\\hat{\\beta}_{\\mathrm{IC}} = \\frac{\\sum_{k=1}^3 U_{X,k} U_{Y,k}}{\\sum_{k=1}^3 U_{X,k}^2}$。\n$\\sum U_{X,k}^2 = (-2\\sqrt{2})^2 + (-3\\sqrt{2})^2 + (-\\frac{2}{\\sqrt{3}})^2 = 8 + 18 + \\frac{4}{3} = 26 + \\frac{4}{3} = \\frac{78+4}{3} = \\frac{82}{3}$。\n$\\sum U_{X,k} U_{Y,k} = (-2\\sqrt{2})(-5\\sqrt{2}) + (-3\\sqrt{2})(-\\frac{11}{\\sqrt{2}}) + (-\\frac{2}{\\sqrt{3}})(-\\frac{\\sqrt{3}}{2}) = 20 + 33 + 1 = 54$。\n$\\hat{\\beta}_{\\mathrm{IC}} = \\frac{54}{82/3} = \\frac{54 \\times 3}{82} = \\frac{162}{82} = \\frac{81}{41}$。\n\n$\\hat{\\beta}_{\\mathrm{IC}}$ 的标准误：\n$SE(\\hat{\\beta}_{\\mathrm{IC}}) = \\sqrt{\\frac{\\hat{s}^2}{\\sum U_{X,k}^2}}$，其中对于 $n=3$ 个对比，$\\hat{s}^2 = \\frac{\\sum \\hat{\\epsilon}_k^2}{n-1}$。\n$\\sum \\hat{\\epsilon}_k^2 = \\sum U_{Y,k}^2 - \\frac{(\\sum U_{X,k}U_{Y,k})^2}{\\sum U_{X,k}^2}$。\n$\\sum U_{Y,k}^2 = (-5\\sqrt{2})^2 + (-\\frac{11}{\\sqrt{2}})^2 + (-\\frac{\\sqrt{3}}{2})^2 = 50 + \\frac{121}{2} + \\frac{3}{4} = \\frac{200+242+3}{4} = \\frac{445}{4}$。\n$\\sum \\hat{\\epsilon}_k^2 = \\frac{445}{4} - \\frac{54^2}{82/3} = \\frac{445}{4} - \\frac{2916 \\times 3}{82} = \\frac{445}{4} - \\frac{8748}{82} = \\frac{445}{4} - \\frac{4374}{41} = \\frac{445 \\times 41 - 4374 \\times 4}{164} = \\frac{18245 - 17496}{164} = \\frac{749}{164}$。\n$\\hat{s}^2 = \\frac{749/164}{3-1} = \\frac{749}{328}$。\n$SE(\\hat{\\beta}_{\\mathrm{IC}})^2 = \\frac{\\hat{s}^2}{\\sum U_{X,k}^2} = \\frac{749/328}{82/3} = \\frac{749 \\times 3}{328 \\times 82} = \\frac{2247}{26896}$。\n$SE(\\hat{\\beta}_{\\mathrm{IC}}) = \\sqrt{\\frac{2247}{26896}}$。\n\n**任务2: 系统发育广义最小二乘法 (PGLS)**\nPGLS 模型是带截距的 $y = X\\beta + \\epsilon$，其中 $E[\\epsilon]=0$ 且 $Var[\\epsilon]=V=\\sigma^2 C$。矩阵 $C$ 是从枝长导出的系统发育协方差矩阵。对于叶尖 $i$ 和 $j$，$C_{ij}$ 是从根到其最近共同祖先的共享路径长度。$C_{ii}$ 是从根到叶尖 $i$ 的路径长度。\n$$C = \\begin{pmatrix} 2  & 1  & 0  & 0 \\\\ 1  & 2  & 0  & 0 \\\\ 0  & 0  & 2  & 1 \\\\ 0  & 0  & 1  & 2 \\end{pmatrix}$$\n这是一个分块对角矩阵。其逆矩阵是由各分块的逆矩阵构成的分块对角矩阵。$\\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$ 的逆矩阵是 $\\frac{1}{3}\\begin{pmatrix} 2 & -1 \\\\ -1 & 2 \\end{pmatrix}$。\n$$C^{-1} = \\frac{1}{3} \\begin{pmatrix} 2  & -1  & 0  & 0 \\\\ -1  & 2  & 0  & 0 \\\\ 0  & 0  & 2  & -1 \\\\ 0  & 0  & -1  & 2 \\end{pmatrix}$$\n设计矩阵 $X$ 和响应向量 $y$ 为：\n$$X = \\begin{pmatrix} 1  & 1 \\\\ 1  & 5 \\\\ 1  & 2 \\\\ 1  & 8 \\end{pmatrix}, \\quad y = \\begin{pmatrix} 2 \\\\ 12 \\\\ 3 \\\\ 14 \\end{pmatrix}$$\nGLS 估计量为 $\\hat{\\beta}_{\\mathrm{PGLS}} = (X^\\top V^{-1} X)^{-1} X^\\top V^{-1} y$。未知方差标量 $\\sigma^2$ 在此表达式中被消去，因此我们使用 $C^{-1}$ 代替 $V^{-1}$。\n$X^\\top C^{-1} = \\frac{1}{3} \\begin{pmatrix} 1  & 1  & 1  & 1 \\\\ 1  & 5  & 2  & 8 \\end{pmatrix} \\begin{pmatrix} 2  & -1  & 0  & 0 \\\\ -1  & 2  & 0  & 0 \\\\ 0  & 0  & 2  & -1 \\\\ 0  & 0  & -1  & 2 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 1  & 1  & 1  & 1 \\\\ -3  & 9  & -4  & 14 \\end{pmatrix}$。\n$X^\\top C^{-1} X = \\frac{1}{3} \\begin{pmatrix} 1  & 1  & 1  & 1 \\\\ -3  & 9  & -4  & 14 \\end{pmatrix} \\begin{pmatrix} 1  & 1 \\\\ 1  & 5 \\\\ 1  & 2 \\\\ 1  & 8 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 4  & 16 \\\\ 16  & 146 \\end{pmatrix}$。\n令 $A = X^\\top C^{-1} X$。其逆矩阵为 $A^{-1} = 3 \\left(\\begin{pmatrix} 4 & 16 \\\\ 16 & 146 \\end{pmatrix}\\right)^{-1} = 3 \\frac{1}{4 \\cdot 146 - 16^2} \\begin{pmatrix} 146  & -16 \\\\ -16  & 4 \\end{pmatrix} = \\frac{3}{328} \\begin{pmatrix} 146  & -16 \\\\ -16  & 4 \\end{pmatrix}$。\n$X^\\top C^{-1} y = \\frac{1}{3} \\begin{pmatrix} 1  & 1  & 1  & 1 \\\\ -3  & 9  & -4  & 14 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 12 \\\\ 3 \\\\ 14 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 31 \\\\ 286 \\end{pmatrix}$。\n$\\hat{\\beta}_{\\mathrm{PGLS}} = A^{-1} (X^\\top C^{-1} y) = \\frac{3}{328} \\begin{pmatrix} 146  & -16 \\\\ -16  & 4 \\end{pmatrix} \\frac{1}{3} \\begin{pmatrix} 31 \\\\ 286 \\end{pmatrix} = \\frac{1}{328} \\begin{pmatrix} 146 \\cdot 31 - 16 \\cdot 286 \\\\ -16 \\cdot 31 + 4 \\cdot 286 \\end{pmatrix} = \\frac{1}{328} \\begin{pmatrix} 4526 - 4576 \\\\ -496 + 1144 \\end{pmatrix} = \\frac{1}{328} \\begin{pmatrix} -50 \\\\ 648 \\end{pmatrix}$。\n斜率的估计是第二个分量：$\\hat{\\beta}_{\\mathrm{PGLS}} = \\frac{648}{328} = \\frac{81}{41}$。\n\n$\\hat{\\beta}_{\\mathrm{PGLS}}$ 的标准误：\n估计的残差方差为 $\\hat{s}^2 = \\frac{(y - X\\hat{\\beta})^\\top C^{-1} (y - X\\hat{\\beta})}{n-p}$，其中 $n=4, p=2$。分子是 $\\mathrm{SSE} = y^\\top C^{-1} y - \\hat{\\beta}^\\top X^\\top C^{-1} y$。\n$y^\\top C^{-1}y = \\frac{1}{3} \\begin{pmatrix} 2  & 12  & 3  & 14 \\end{pmatrix} \\begin{pmatrix} 2  & -1  & 0  & 0 \\\\ -1  & 2  & 0  & 0 \\\\ 0  & 0  & 2  & -1 \\\\ 0  & 0  & -1  & 2 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 12 \\\\ 3 \\\\ 14 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} -8  & 22  & -8  & 25 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 12 \\\\ 3 \\\\ 14 \\end{pmatrix} = \\frac{1}{3}(-16+264-24+350) = \\frac{574}{3}$。\n$\\hat{\\beta}^\\top X^\\top C^{-1} y = \\frac{1}{328} \\begin{pmatrix} -50  & 648 \\end{pmatrix} \\frac{1}{3} \\begin{pmatrix} 31 \\\\ 286 \\end{pmatrix} = \\frac{1}{984}(-50 \\cdot 31 + 648 \\cdot 286) = \\frac{1}{984}(-1550 + 185328) = \\frac{183778}{984} = \\frac{91889}{492}$。\n$\\mathrm{SSE} = \\frac{574}{3} - \\frac{91889}{492} = \\frac{574 \\cdot 164}{492} - \\frac{91889}{492} = \\frac{94136 - 91889}{492} = \\frac{2247}{492} = \\frac{749}{164}$。\n$\\hat{s}^2_{\\mathrm{PGLS}} = \\frac{749/164}{4-2} = \\frac{749}{328}$。\n$\\hat{\\beta}$ 的估计方差-协方差矩阵为 $\\hat{s}^2 (X^\\top C^{-1} X)^{-1}$。斜率估计的方差是第 $(2,2)$ 个元素。\n$SE(\\hat{\\beta}_{\\mathrm{PGLS}})^2 = \\hat{s}^2_{\\mathrm{PGLS}} \\cdot \\left((X^\\top C^{-1}X)^{-1}\\right)_{22} = \\frac{749}{328} \\cdot \\left(\\frac{3}{328} \\begin{pmatrix} 146  & -16 \\\\ -16  & 4 \\end{pmatrix}\\right)_{22} = \\frac{749}{328} \\cdot \\frac{3 \\cdot 4}{328} = \\frac{749 \\cdot 12}{328^2} = \\frac{749 \\cdot 3}{328 \\cdot 82} = \\frac{2247}{26896}$。\n$SE(\\hat{\\beta}_{\\mathrm{PGLS}}) = \\sqrt{\\frac{2247}{26896}}$。\n\n**任务3: 比较**\n来自独立对比的斜率估计为 $\\hat{\\beta}_{\\mathrm{IC}} = \\frac{81}{41}$。\n来自系统发育广义最小二乘法的斜率估计为 $\\hat{\\beta}_{\\mathrm{PGLS}} = \\frac{81}{41}$。\n两者是相同的。\n来自独立对比的标准误的平方为 $SE(\\hat{\\beta}_{\\mathrm{IC}})^2 = \\frac{2247}{26896}$。\n来自PGLS的标准误的平方为 $SE(\\hat{\\beta}_{\\mathrm{PGLS}})^2 = \\frac{2247}{26896}$。\n这两者也是相同的。\n此分析经验性地证明了，当两种方法的基础演化模型（布朗运动）和系统发育树相同时，Felsenstein的独立对比法（使用过原点回归）和系统发育广义最小二乘法（使用截距项）在数学上是等价的。\n共同的斜率估计为 $\\frac{81}{41}$。", "answer": "$$\\boxed{\\frac{81}{41}}$$", "id": "2742873"}, {"introduction": "现代系统发育比较分析不仅要校正系统发育关系，还需要确定最能描述性状演化过程的模型。本练习将带您进入计算生物学的前沿，通过编写代码来模拟不同演化模型（如布朗运动与 Ornstein-Uhlenbeck 模型）下的性状数据。您将评估检测系统发育信号的统计效力，并使用 AIC 等标准进行模型选择，这些都是当今演化生物学研究中不可或缺的实用技能。[@problem_id:2742906]", "problem": "您需要为系统发育比较方法实现一个完整的模拟与推断流程，以评估检测系统发育信号和区分演化模型的能力。具体来说，您将在一个超度量、完全平衡、有根的二叉系统发育树上，模拟在具有不同强度稳定选择的奥恩斯坦-乌伦贝克 (OU) 过程中演化的连续性状，然后评估 (i) 使用似然比检验通过 Pagel 的 lambda ($\\lambda$) 检测非零系统发育信号的功效，以及 (ii) 使用赤池信息准则 (AIC) 时，OU 模型优于布朗运动 (BM) 模型的频率。统计估计将通过专门针对仅含截距模型的系统发育广义最小二乘法 (PGLS) 进行。\n\n定义与基本原理：\n- 布朗运动 (BM)：一种具有独立增量的连续时间高斯过程。沿着长度为 $t$ 的分支，增加的方差为 $\\sigma^2 t$，两个叶尖之间的协方差等于 $\\sigma^2$ 乘以从根到它们最近共同祖先 (MRCA) 的时间。\n- 奥恩斯坦-乌伦贝克 (OU) 过程：其随机微分方程为 $dX_t = -\\alpha (X_t - \\theta)\\,dt + \\sigma\\,dB_t$，其中 $\\alpha \\ge 0$ 是朝向最适值 $\\theta$ 的吸引强度，$\\sigma > 0$ 是扩散速率，而 $B_t$ 是标准布朗运动。在一个高度为 $T$ 的超度量树上，假设根部均值为 $\\mu$ 且最适值恒定，则叶尖向量服从多元正态分布，其均值向量为 $\\,\\mu \\mathbf{1}\\,$，协方差结构由 OU 过程决定。\n- Pagel 的 lambda ($\\lambda$)：一个标量，用于重新缩放 BM 系统发育协方差矩阵的非对角线元素，同时保持对角线元素不变。在仅含截距模型下，通过最大化性状向量在协方差 $\\Sigma(\\lambda)$ 下的多元正态似然来估计 $\\lambda$。\n- 系统发育广义最小二乘法 (PGLS)：一个广义最小二乘框架，其中误差协方差 $\\Sigma$ 是由演化模型决定的系统发育协方差。对于仅含截距模型，均值和方差参数的最大似然估计是通过使用 $\\Sigma$ 的广义最小二乘法获得的。\n- 赤池信息准则 (AIC)：对于一个具有最大化对数似然 $\\ell$ 和 $k$ 个自由参数的模型，$\\mathrm{AIC} = 2k - 2\\ell$。较小的 AIC 值表示更优的模型。\n\n树与协方差构建：\n- 考虑一个具有 $n = 2^D$ 个叶尖、总高度 $T=1$、每层分支长度均为 $1/D$ 的超度量、完全平衡、有根二叉树，其中 $D = \\log_2 n$。对于两个叶尖 $i$ 和 $j$，令 $t_{ij}$ 为从根到它们 MRCA 的时间。在这棵树上，$t_{ij}$ 等于它们最近共同祖先的深度（以层数计）除以 $D$。\n- 在扩散参数为 $\\sigma^2$ 的 BM 模型下，叶尖 $i$ 和 $j$ 之间的协方差为 $\\Sigma^{\\mathrm{BM}}_{ij} = \\sigma^2 t_{ij}$ (当 $i \\ne j$ 时)，方差为 $\\Sigma^{\\mathrm{BM}}_{ii} = \\sigma^2 T$。\n- 在高度为 $T$ 的超度量树上，参数为 $(\\alpha, \\sigma^2)$ 的 OU 模型下，当 $i \\ne j$ 时，\n  $$\\Sigma^{\\mathrm{OU}}_{ij} = \\frac{\\sigma^2}{2\\alpha} \\exp\\!\\big(-\\alpha (2T - 2 t_{ij})\\big)\\,\\big(1 - e^{-2\\alpha t_{ij}}\\big),$$\n  且\n  $$\\Sigma^{\\mathrm{OU}}_{ii} = \\frac{\\sigma^2}{2\\alpha} \\big(1 - e^{-2\\alpha T}\\big).$$\n  当 $\\alpha \\to 0$ 时，该模型收敛于上述协方差的 BM 模型。\n\n似然与估计：\n- 令 $\\mathbf{y} \\in \\mathbb{R}^n$ 表示模拟的性状向量，$\\mathbf{1}$ 表示元素全为 1 的 $n$ 维向量。对于给定的正定矩阵 $V$ 和一个正的尺度参数 $s^2$，假设 $\\Sigma = s^2 V$。在均值为 $\\mu \\mathbf{1}$ 的多元正态似然下，当 $V$ 固定时，广义最小二乘估计量为：\n  $$\\hat{\\mu} = \\frac{\\mathbf{1}^\\top V^{-1} \\mathbf{y}}{\\mathbf{1}^\\top V^{-1} \\mathbf{1}}, \\quad \\hat{s}^2 = \\frac{1}{n}(\\mathbf{y} - \\hat{\\mu}\\mathbf{1})^\\top V^{-1} (\\mathbf{y} - \\hat{\\mu}\\mathbf{1}).$$\n  相应的剖面对数似然为\n  $$\\ell(V \\mid \\mathbf{y}) = -\\frac{1}{2} \\left[n \\log(2\\pi) + n \\log\\!\\left(\\frac{1}{n}(\\mathbf{y} - \\hat{\\mu}\\mathbf{1})^\\top V^{-1} (\\mathbf{y} - \\hat{\\mu}\\mathbf{1})\\right) + \\log|V| + n \\right].$$\n- 对于 BM 模型，取 $V^{\\mathrm{BM}}$，其中 $V^{\\mathrm{BM}}_{ii} = T$ 且当 $i \\ne j$ 时 $V^{\\mathrm{BM}}_{ij} = t_{ij}$，因此 $\\Sigma^{\\mathrm{BM}} = \\sigma^2 V^{\\mathrm{BM}}$，此时 $s^2 = \\sigma^2$。\n- 对于 OU 模型，在 $\\alpha$ 固定时，记 $\\Sigma^{\\mathrm{OU}}(\\alpha) = s^2 V^{\\mathrm{OU}}(\\alpha)$，其中 $s^2 = \\sigma^2/(2\\alpha)$，且 $V^{\\mathrm{OU}}(\\alpha)$ 的元素为 $V^{\\mathrm{OU}}_{ii}(\\alpha) = 1 - e^{-2\\alpha T}$ 和当 $i \\ne j$ 时 $V^{\\mathrm{OU}}_{ij}(\\alpha) = \\exp\\!\\big(-\\alpha (2T - 2 t_{ij})\\big)\\,\\big(1 - e^{-2\\alpha t_{ij}}\\big)$。OU 对数似然则为 $\\ell(\\alpha) = \\ell(V^{\\mathrm{OU}}(\\alpha) \\mid \\mathbf{y})$，需在 $\\alpha > 0$ 的范围内进行数值最大化。\n- 对于 BM 模型下的 $\\lambda$ 估计，设置 $V^{\\mathrm{BM}}(\\lambda)$，其中 $V_{ii} = T$ 且当 $i \\ne j$ 时 $V_{ij}(\\lambda) = \\lambda\\, t_{ij}$，并在 $\\lambda \\in [0,1]$ 的范围内最大化 $\\ell(\\lambda) = \\ell(V^{\\mathrm{BM}}(\\lambda) \\mid \\mathbf{y})$。\n\n系统发育信号的假设检验：\n- 使用似然比统计量 $\\,\\Lambda = 2(\\ell(\\hat{\\lambda}) - \\ell(0))\\,$ 检验 $H_0: \\lambda = 0$ 与 $H_1: \\lambda \\in (0,1]$，其中 $\\hat{\\lambda}$ 是在 $[0,1]$ 区间内的最大化估计值。由于 $\\lambda = 0$ 位于参数空间的边界上，应在显著性水平 $0.05$ 下使用适用于单侧检验的混合临界值，拒绝域为 $\\Lambda > 2.71$。\n\n通过 AIC 进行模型选择：\n- 计算 $\\mathrm{AIC}_{\\mathrm{BM}} = 2k_{\\mathrm{BM}} - 2 \\ell_{\\mathrm{BM}}$，其中 $k_{\\mathrm{BM}} = 2$ (截距 $\\mu$ 和方差尺度 $s^2$)，以及 $\\mathrm{AIC}_{\\mathrm{OU}} = 2k_{\\mathrm{OU}} - 2 \\ell_{\\mathrm{OU}}$，其中 $k_{\\mathrm{OU}} = 3$ (截距 $\\mu$、方差尺度 $s^2$ 和 $\\alpha$)。选择 AIC 值较小的模型。\n\n模拟协议：\n- 对于每次重复，模拟 $\\mathbf{y} \\sim \\mathcal{N}(\\mu \\mathbf{1}, \\Sigma)$，其中 $\\mu = 0$，$T = 1$，$\\sigma^2 = 1$。\n- 当 $\\alpha = 0$ 时，使用 BM 模型；当 $\\alpha > 0$ 时，使用上述指定的协方差的 OU 模型。\n- 使用固定的随机数生成器种子以确保输出是确定性的。\n\n您的程序必须：\n1. 为指定的 $n$ 构建平衡超度量树，并计算 MRCA 时间矩阵 $t_{ij}$。\n2. 对每个测试案例，运行指定次数的重复，并计算：\n   - 使用上述似然比检验，在显著性水平 $0.05$ 下拒绝 $H_0: \\lambda = 0$ 的估计功效（拒绝的重复实验所占的比例）。\n   - $\\mathrm{AIC}_{\\mathrm{OU}} < \\mathrm{AIC}_{\\mathrm{BM}}$ 的重复实验所占的比例。\n3. 对 $\\alpha$ 和 $\\lambda$ 使用数值最大化方法，其中 $\\alpha$ 的界限为 $[10^{-6}, 10]$，$\\lambda$ 的界限为 $[0,1]$。您可以显式地评估端点值，以防最大值出现在边界上。\n\n测试套件：\n- 案例 1 (BM 边界)：$n = 8$，$\\alpha = 0.0$，重复次数 $= 200$。\n- 案例 2 (中等 OU)：$n = 8$，$\\alpha = 0.5$，重复次数 $= 200$。\n- 案例 3 (更大树上的强 OU)：$n = 16$，$\\alpha = 1.0$，重复次数 $= 200$。\n\n随机性与可复现性：\n- 在所有模拟中，为随机数生成器使用固定的种子 $s = 12345$，以使输出是确定性的。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例贡献一个双元素列表 $[\\text{功效}, \\text{选择}]$，其中两项都是四舍五入到三位小数的浮点数。对于上述三个测试案例，您的输出必须类似于：\n  - 示例格式：[[x1,y1],[x2,y2],[x3,y3]]\n  - 其中，$xk$ 是案例 $k$ 中拒绝 $H_0: \\lambda = 0$ 的估计功效，$yk$ 是案例 $k$ 中 OU 模型被 AIC 偏好的重复实验比例。", "solution": "该问题提出了一个在演化生物学领域，特别是系统发育比较方法领域中，有效且定义明确的计算任务。它在科学上基于已建立的统计模型——布朗运动 (BM) 和奥恩斯坦-乌伦贝克 (OU)——以及标准的推断技术，如系统发育广义最小二乘法 (PGLS)、Pagel 的 $\\lambda$ 和赤池信息准则 (AIC)。所有参数、模型、树结构和统计程序都以足够的数学精度进行了定义，并与科学文献保持一致。该问题是自包含的、客观的且计算上可行的。因此，我将提供一个完整的解决方案。\n\n该解决方案包含一个有四个主要阶段的流程：(i) 构建系统发育协方差结构，(ii) 模拟连续性状数据，(iii) 模型参数的最大似然估计，以及 (iv) 通过假设检验和模型选择进行统计评估。\n\n**1. 系统发育树与协方差结构**\n\n问题指定了一个具有 $n=2^D$ 个叶尖、总高度为 $T=1$ 的完全平衡、超度量二叉树。从根到任意两个叶尖 $i$ 和 $j$ 的最近共同祖先 (MRCA) 的时间记为 $t_{ij}$。该值由它们 MRCA 节点的深度决定。我们可以构建一个包含这些时间的 $n \\times n$ 矩阵。对于从 $0$ 到 $n-1$ 索引的两个叶尖，它们 MRCA 的深度（从根开始的层数，根在第 $0$ 层）可以使用它们的位表示来计算。时间 $t_{ij}$ 是该层数除以总层数 $D = \\log_2 n$。对于 $i=j$ 的情况，MRCA 是叶尖本身，时间为 $T=1$，所以 $t_{ii}=1$。这个时间矩阵是编码系统发育的基本结构。\n\n这个时间矩阵用于参数化不同演化模型下性状的期望协方差。\n- **布朗运动 (BM):** 协方差矩阵为 $\\Sigma^{\\mathrm{BM}}$，其中叶尖 $i$ 和 $j$ 处性状的协方差与它们共享的历史成正比：$\\Sigma^{\\mathrm{BM}}_{ij} = \\sigma^2 t_{ij}$。方差为 $\\Sigma^{\\mathrm{BM}}_{ii} = \\sigma^2 T$。\n- **奥恩斯坦-乌伦贝克 (OU):** 该模型增加了一个朝向最适值 $\\theta$ 的确定性拉力。协方差矩阵 $\\Sigma^{\\mathrm{OU}}$ 取决于这个拉力的强度 $\\alpha$，其元素由问题陈述中的公式给出。当 $\\alpha \\to 0$ 时，拉力消失，$\\Sigma^{\\mathrm{OU}}$ 收敛于 $\\Sigma^{\\mathrm{BM}}$。\n\n**2. 性状模拟**\n\n在模拟的每次重复中，会生成一个连续性状值的向量 $\\mathbf{y} \\in \\mathbb{R}^n$。这是通过从一个多元正态分布 $\\mathbf{y} \\sim \\mathcal{N}(\\mu\\mathbf{1}, \\Sigma)$ 中抽样实现的，其中 $\\mathbf{1}$ 是一个元素全为 1 的向量。模拟参数固定为均值 $\\mu=0$ 和扩散速率 $\\sigma^2=1$。协方差矩阵 $\\Sigma$ 根据真实模型是 BM (如果 $\\alpha=0$) 还是 OU (如果 $\\alpha > 0$) 来设置为 $\\Sigma^{\\mathrm{BM}}$ 或 $\\Sigma^{\\mathrm{OU}}$。\n\n**3. 通过 PGLS 进行最大似然估计**\n\n推断程序的核心是仅含截距 PGLS 模型的剖面对数似然函数。给定一个性状向量 $\\mathbf{y}$ 和一个相对协方差结构矩阵 $V$ (其中完整协方差矩阵为 $\\Sigma = s^2 V$)，均值 ($\\mu$) 和总速率 ($s^2$) 的冗余参数可以使用广义最小二乘法进行估计，并随后从似然函数中“剖分出去”。得到的剖面对数似然 $\\ell(V \\mid \\mathbf{y})$ 由以下公式给出：\n$$\n\\ell(V \\mid \\mathbf{y}) = -\\frac{1}{2} \\left[n \\log(2\\pi) + n \\log(\\hat{s}^2) + \\log|V| + n \\right]\n$$\n其中 $\\hat{s}^2 = \\frac{1}{n}(\\mathbf{y} - \\hat{\\mu}\\mathbf{1})^\\top V^{-1} (\\mathbf{y} - \\hat{\\mu}\\mathbf{1})$ 且 $\\hat{\\mu} = (\\mathbf{1}^\\top V^{-1} \\mathbf{y}) / (\\mathbf{1}^\\top V^{-1} \\mathbf{1})$。此函数通过数值最大化来为感兴趣的模型找到最佳拟合参数。\n\n- **估计 Pagel 的 $\\lambda$**：矩阵 $V$ 定义为 $V^{\\mathrm{BM}}(\\lambda)$，其中 BM 时间矩阵的非对角线元素按 $\\lambda \\in [0, 1]$ 进行缩放。我们找到使 $\\ell(V^{\\mathrm{BM}}(\\lambda) \\mid \\mathbf{y})$ 最大化的 $\\hat{\\lambda}$。\n- **估计 OU 参数 $\\alpha$**：矩阵 $V$ 定义为 $V^{\\mathrm{OU}}(\\alpha)$，它通过从 OU 协方差公式中分解出速率参数 $s^2 = \\sigma^2/(2\\alpha)$ 而得到。我们在区间 $[10^{-6}, 10]$ 上找到使 $\\ell(V^{\\mathrm{OU}}(\\alpha) \\mid \\mathbf{y})$ 最大化的 $\\hat{\\alpha}$。\n\n数值优化使用 `scipy.optimize.minimize_scalar` 对负对数似然函数进行。为确保稳健性，还会评估参数空间边界处的似然，并与优化器的结果进行比较。\n\n**4. 统计评估**\n\n为每个模拟数据集计算两个关键的统计量。\n\n- **检测系统发育信号的功效**：我们检验原假设 $H_0: \\lambda=0$ (无系统发育信号；性状独立) 与备择假设 $H_1: \\lambda > 0$。似然比检验 (LRT) 统计量为 $\\Lambda = 2(\\ell(\\hat{\\lambda}) - \\ell(\\lambda=0))$。由于 $H_0$ 位于参数空间的边界上，$\\Lambda$ 的零分布是 $\\chi^2_0$ 分布（在 0 处的点质量）和 $\\chi^2_1$ 分布的 $50:50$ 混合。对于 $0.05$ 的显著性水平，临界值为 $2.71$。如果 $\\Lambda > 2.71$，则拒绝 $H_0$。功效是指当数据由具有系统发育结构的模拟生成时，正确拒绝 $H_0$ 的重复实验所占的比例。\n\n- **模型选择频率**：我们使用赤池信息准则 (AIC) 比较 BM 模型和 OU 模型的拟合优度：$\\mathrm{AIC} = 2k - 2\\ell$，其中 $k$ 是估计参数的数量。\n - 对于 BM，$k_{\\mathrm{BM}}=2$ (参数 $\\mu, \\sigma^2$)。其 AIC 为 $\\mathrm{AIC}_{\\mathrm{BM}} = 4 - 2\\ell_{\\mathrm{BM}}$，其中 $\\ell_{\\mathrm{BM}}$ 是数据在 BM 模型下的对数似然。\n - 对于 OU，$k_{\\mathrm{OU}}=3$ (参数 $\\mu, \\sigma^2, \\alpha$)。其 AIC 为 $\\mathrm{AIC}_{\\mathrm{OU}} = 6 - 2\\ell_{\\mathrm{OU}}$，其中 $\\ell_{\\mathrm{OU}}$ 是在 $\\alpha$ 上最大化的对数似然。\n选择 AIC 较小的模型。我们计算 $\\mathrm{AIC}_{\\mathrm{OU}} < \\mathrm{AIC}_{\\mathrm{BM}}$ 的重复实验所占的比例。这表明更复杂的 OU 模型被偏好的频率，当真实的生成过程具有更强的稳定选择（更大的 $\\alpha$）时，预计该频率会增加。\n\n该实现将这些步骤封装到一个单一的、确定性的流程中，利用固定的随机种子来确保所有模拟的可复现性。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef get_mrca_times(n):\n    \"\"\"\n    Constructs the matrix of MRCA times for a balanced binary tree with n tips.\n    Total tree height T=1.\n    \"\"\"\n    if not (n > 0 and (n  (n - 1) == 0)):\n        raise ValueError(\"n must be a power of 2.\")\n    D = int(np.log2(n))\n    if D == 0:\n        return np.array([[1.0]])\n        \n    times = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                times[i, j] = 1.0\n            else:\n                # The level of MRCA: 0 for root, D-1 for sister tips\n                xor_val = i ^ j\n                # Distance from tips to MRCA is floor(log2(xor_val)) + 1\n                # Depth from root to MRCA is D - (floor(log2(xor_val)) + 1)\n                mrca_level = D - 1 - int(np.floor(np.log2(xor_val)))\n                t_ij = mrca_level / D\n                times[i, j] = t_ij\n                times[j, i] = t_ij\n    return times\n\ndef get_ou_V(mrca_times, alpha):\n    \"\"\"Constructs the V matrix for the OU model, with s^2 factored out.\"\"\"\n    n = mrca_times.shape[0]\n    V = np.zeros((n, n))\n    T = 1.0 # Total tree height\n    \n    # Diagonal elements\n    diag_val = 1 - np.exp(-2 * alpha * T)\n    V.flat[::n+1] = diag_val\n    \n    # Off-diagonal elements\n    for i in range(n):\n        for j in range(i + 1, n):\n            t_ij = mrca_times[i, j]\n            val = np.exp(-alpha * (2 * T - 2 * t_ij)) * (1 - np.exp(-2 * alpha * t_ij))\n            V[i, j] = val\n            V[j, i] = val\n    return V\n\ndef get_lambda_V(mrca_times, lam):\n    \"\"\"Constructs the V matrix for the Pagel's lambda model.\"\"\"\n    V = lam * mrca_times\n    np.fill_diagonal(V, 1.0)\n    return V\n\ndef log_likelihood(y, V):\n    \"\"\"Calculates the PGLS profile log-likelihood for an intercept-only model.\"\"\"\n    n = len(y)\n    ones = np.ones(n)\n    try:\n        V_inv = np.linalg.inv(V)\n        sign, log_det_V = np.linalg.slogdet(V)\n        if sign = 0:\n            return -np.inf\n    except np.linalg.LinAlgError:\n        return -np.inf\n\n    one_V_inv_one = ones.T @ V_inv @ ones\n    one_V_inv_y = ones.T @ V_inv @ y\n    \n    mu_hat = one_V_inv_y / one_V_inv_one\n    \n    res = y - mu_hat * ones\n    s2_hat = (res.T @ V_inv @ res) / n\n    \n    if s2_hat = 0:\n        return -np.inf\n        \n    logL = -0.5 * (n * np.log(2 * np.pi) + n * np.log(s2_hat) + log_det_V + n)\n    return logL\n\ndef estimate_param(y, mrca_times, param_type):\n    \"\"\"Generic function to estimate lambda or alpha by maximizing log-likelihood.\"\"\"\n    if param_type == 'lambda':\n        bounds = (0, 1)\n        V_func = get_lambda_V\n    elif param_type == 'alpha':\n        bounds = (1e-6, 10)\n        V_func = lambda t, p: get_ou_V(t, p) if p > 1e-9 else t # Use BM as limit\n    else:\n        raise ValueError(\"Invalid param_type\")\n\n    def neg_logL(param, y_data, times):\n        V = V_func(times, param)\n        return -log_likelihood(y_data, V)\n\n    res = minimize_scalar(neg_logL, args=(y, mrca_times), bounds=bounds, method='bounded')\n    \n    # Check boundaries explicitly\n    logL_low = -neg_logL(bounds[0], y, mrca_times)\n    logL_high = -neg_logL(bounds[1], y, mrca_times)\n    \n    best_logL = -res.fun\n    best_param = res.x\n    \n    if logL_low > best_logL:\n        best_logL = logL_low\n        best_param = bounds[0]\n    \n    if logL_high > best_logL:\n        best_logL = logL_high\n        best_param = bounds[1]\n        \n    return best_param, best_logL\n\ndef run_simulation(n, alpha_true, replicates, rng):\n    \"\"\"Runs one full simulation case.\"\"\"\n    mrca_times = get_mrca_times(n)\n    mu_true, sigma2_true, T = 0.0, 1.0, 1.0\n\n    if alpha_true == 0.0:\n        true_cov = sigma2_true * mrca_times\n    else:\n        true_cov = np.zeros((n, n))\n        diag_val = (sigma2_true / (2 * alpha_true)) * (1 - np.exp(-2 * alpha_true * T))\n        np.fill_diagonal(true_cov, diag_val)\n        for i in range(n):\n            for j in range(i + 1, n):\n                t_ij = mrca_times[i, j]\n                val = (sigma2_true / (2*alpha_true)) * np.exp(-alpha_true * (2*T - 2*t_ij)) * (1 - np.exp(-2*alpha_true*t_ij))\n                true_cov[i, j] = true_cov[j, i] = val\n\n    rejected_h0_count = 0\n    ou_preferred_count = 0\n    \n    mean_vec = np.zeros(n)\n\n    for _ in range(replicates):\n        y = rng.multivariate_normal(mean=mean_vec, cov=true_cov)\n        \n        # Power for lambda\n        _, logL_hat_lambda = estimate_param(y, mrca_times, 'lambda')\n        logL_lambda0 = log_likelihood(y, get_lambda_V(mrca_times, 0.0))\n        \n        lrt_stat = 2 * (logL_hat_lambda - logL_lambda0)\n        if max(0, lrt_stat) > 2.71:\n            rejected_h0_count += 1\n            \n        # AIC for BM vs OU\n        logL_bm = log_likelihood(y, mrca_times)\n        aic_bm = 2 * 2 - 2 * logL_bm\n        \n        _, logL_ou = estimate_param(y, mrca_times, 'alpha')\n        aic_ou = 2 * 3 - 2 * logL_ou\n        \n        if aic_ou  aic_bm:\n            ou_preferred_count += 1\n            \n    power = rejected_h0_count / replicates\n    selection_frac = ou_preferred_count / replicates\n    \n    return [round(power, 3), round(selection_frac, 3)]\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    # Use a fixed seed for the random number generator across all simulations\n    rng = np.random.default_rng(12345)\n    \n    test_cases = [\n        # (n, alpha_true, replicates)\n        (8, 0.0, 200),\n        (8, 0.5, 200),\n        (16, 1.0, 200),\n    ]\n\n    all_results = []\n    for n, alpha, reps in test_cases:\n        result = run_simulation(n, alpha, reps, rng)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string and remove spaces for compact output.\n    print(str(all_results).replace(' ', ''))\n\nsolve()\n```", "answer": "[[0.055,0.030],[0.970,0.210],[1.000,0.655]]", "id": "2742906"}]}