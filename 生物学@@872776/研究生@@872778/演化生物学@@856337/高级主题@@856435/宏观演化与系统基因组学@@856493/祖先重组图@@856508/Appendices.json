{"hands_on_practices": [{"introduction": "溯祖过程向后追溯血缘关系，它在自身独特的时间和重组单位下运行，这与离散的世代数和每个碱基的重组率有所不同。本练习将引导你从第一性原理出发，推导这些关键的定标关系。通过理解溯祖时间如何与世代数关联，以及群体复合重组率 $\\rho$ 如何由有效种群大小 $N_e$ 和物理重组率 $r$ 产生，你将对控制祖先重组图结构的核心参数建立更深刻的直觉。[@problem_id:2755751]", "problem": "考虑一个大小恒定、随机交配的二倍体赖特-费舍尔（Wright–Fisher）群体，其有效群体大小为 $N_{e}$。设沿长度为 $L$ 个碱基对的线性基因组区域的重组过程为：在正向时间中，每次减数分裂根据泊松过程生成交换，其速率为每个碱基每代 $r$，因此在该区域内单次减数分裂的预期交换数量为 $rL$。在祖先重组图（ARG）所基于的连续时间扩散极限下，对于二倍体，溯祖时间是以 $2N_{e}$ 代为单位来度量的。\n\n从这些基本定义出发，并且不假设任何现成的标度公式，完成以下任务：\n\n1.  通过选择时间尺度，使得成对溯祖率为1的量级，来推导离散世代和溯祖时间单位之间的映射关系。解释为什么这意味着在ARG中，溯祖时间 $t_{c}$ 与世代数 $t_{g}$ 的关系为 $t_{c}$ 是 $t_{g}$ 按 $N_{e}$ 的一个常数倍进行缩放的结果，并确定这个倍数。\n\n2.  使用相同的第一性原理标度论证，用 $N_{e}$、$r$ 和 $L$ 表示以溯祖时间单位计量的每个谱系在该区域的重组率。由此，用 $N_{e}$、$r$ 和 $L$ 定义ARG文献中使用的常规无量纲标度重组参数，记为 $\\rho$。\n\n3.  对于一个具体的群体，其 $N_{e}=1.43 \\times 10^{4}$，每碱基每代重组率 $r=1.25 \\times 10^{-8}$，区域长度 $L=1.3 \\times 10^{6}$ 个碱基对，计算 $\\rho$ 的数值。将 $\\rho$ 视为无量纲量，并以纯数字形式报告。将最终数值答案四舍五入到四位有效数字。\n\n请展示第1-2部分的推导过程，但为了评分，请仅报告第3部分中 $\\rho$ 的值作为最终答案。", "solution": "该任务要求在进行数值计算之前，从第一性原理出发推导基本的标度参数。\n\n首先，我们来推导溯祖过程中的时间标度。我们考虑一个大小恒定、随机交配的二倍体群体，其有效群体大小为 $N_{e}$。这对应于每一代有 $2N_{e}$ 个基因拷贝。让我们向后追溯两个不同的基因谱系。在任何给定的世代中，这两个谱系源自前一世代中同一个亲本基因拷贝的概率——即溯祖事件——为 $p_{coal} = \\frac{1}{2N_{e}}$。因此，它们在单个世代中不发生溯祖的概率为 $1 - p_{coal} = 1 - \\frac{1}{2N_{e}}$。\n\n在 $t_{g}$ 个离散世代后，这两个谱系仍未发生溯祖的概率由 $P(T > t_{g}) = \\left(1 - \\frac{1}{2N_{e}}\\right)^{t_{g}}$ 给出。为了获得连续时间扩散极限，我们考虑 $N_{e}$ 很大（$N_{e} \\to \\infty$）的情况，并对时间进行重新标度。设连续溯祖时间 $t_{c}$ 通过一个标度常数 $\\tau$ 与离散世代数 $t_{g}$ 相关联，使得 $t_{g} = \\tau t_{c}$。那么，作为 $t_{c}$ 的函数的存活概率为 $P(T_{c} > t_{c}) = \\left(1 - \\frac{1}{2N_{e}}\\right)^{\\tau t_{c}}$。\n\n为了使该表达式在 $N_{e} \\to \\infty$ 时有一个非平凡的极限，我们利用基本数学极限 $\\lim_{n \\to \\infty} (1 - x/n)^{n} = \\exp(-x)$。我们将概率重写为：\n$$P(T_{c} > t_{c}) = \\left[ \\left(1 - \\frac{1}{2N_{e}}\\right)^{2N_{e}} \\right]^{\\frac{\\tau t_{c}}{2N_{e}}}$$\n当 $N_{e} \\to \\infty$ 时，方括号中的项收敛于 $\\exp(-1)$。因此，存活概率趋近于：\n$$P(T_{c} > t_{c}) = \\exp\\left(-\\frac{\\tau t_{c}}{2N_{e}}\\right)$$\n问题要求选择的时间尺度应使成对溯祖率为1的量级。这意味着等待溯祖的时间应遵循一个速率参数为 $\\lambda=1$ 的标准指数分布。这种分布的生存函数是 $\\exp(-t_{c})$。将其与我们推导的表达式进行比较，我们必须强制要求指数为 $-t_{c}$。这意味着 $\\frac{\\tau}{2N_{e}} = 1$，从而得出 $\\tau = 2N_{e}$。\n因此，正确的时间标度是 $t_{g} = 2N_{e} t_{c}$，或者等价地，$t_{c} = \\frac{t_{g}}{2N_{e}}$。这表明溯祖时间是以 $2N_{e}$ 个世代为单位来度量的。$N_{e}$ 的常数倍数是 $2$。\n\n第二，我们推导标度重组参数 $\\rho$。在单次减数分裂中，据称交换沿长度为 $L$ 的基因组区域根据泊松过程发生，速率为每个碱基 $r$。因此，该区域的预期交换数量为 $R = rL$。这表示该片段每次减数分裂每代的重组率。\n现在，考虑一个向后追溯的单一祖先谱系。在每一代，这个谱系都是一个二倍体祖先的一部分。在产生该祖先的减数分裂过程中，携带我们谱系的染色体与其同源伙伴之间可能发生重组。这个使祖先片段破碎的事件，对于该特定谱系，在每一代中以速率 $R = rL$ 发生。因此，以世代为单位的每个谱系的重组率为 $\\lambda_{rec,g} = rL$。\n\n为了用溯祖时间单位表示这个速率，我们必须使用时间转换因子。速率与时间成反比变换，以确保在小区间内事件发生的概率是不变的。设 $\\lambda_{rec,c}$ 是以溯祖单位计的速率。那么，关系式 $\\lambda_{rec,c} dt_{c} = \\lambda_{rec,g} dt_{g}$ 必须成立。这给出：\n$$\\lambda_{rec,c} = \\lambda_{rec,g} \\frac{dt_{g}}{dt_{c}}$$\n根据我们之前的推导，我们有标度关系 $\\frac{dt_{g}}{dt_{c}} = 2N_{e}$。代入此式，我们得到以溯祖时间单位计量的每个谱系在该区域的重组率：\n$$\\lambda_{rec,c} = (rL)(2N_{e}) = 2N_{e}rL$$\n问题接下来要求定义常规的无量纲标度重组参数 $\\rho$。该参数的定义与群体突变参数 $\\theta = 4N_{e}\\mu$ 类似，代表了重组对一对序列在群体范围内的影响。我们考虑两个随机抽样的谱系。在它们找到共同祖先之前，它们作为一对不同的谱系存在一段时间 $T_{MRCA}$，其期望值为 $E[T_{MRCA}] = 2N_{e}$ 个世代。在这段时间内，重组可能发生在任一谱系上。由于每个谱系的速率是每代 $rL$，影响这对谱系的总重组率为每代 $2 \\times rL$。\n在这对谱系溯祖之前，其历史中预期发生的重组事件总数是这个总速率与期望时间的乘积：\n$$E[\\text{recombinations}] = (2rL) \\times E[T_{MRCA}] = (2rL) \\times (2N_{e}) = 4N_{e}rL$$\n这个量代表了一对谱系的重组事件与溯祖事件的比率，是标度重组参数的标准定义：\n$$\\rho = 4N_{e}rL$$\n\n第三，我们使用给定的数据计算 $\\rho$ 的数值：$N_{e} = 1.43 \\times 10^{4}$，$r = 1.25 \\times 10^{-8}$ 每碱基每代，以及 $L = 1.3 \\times 10^{6}$ 个碱基对。\n我们将这些值代入推导出的公式：\n$$\\rho = 4 \\times (1.43 \\times 10^{4}) \\times (1.25 \\times 10^{-8}) \\times (1.3 \\times 10^{6})$$\n将数值系数和10的幂分组：\n$$\\rho = (4 \\times 1.43 \\times 1.25 \\times 1.3) \\times 10^{4 - 8 + 6}$$\n$$\\rho = (5.72 \\times 1.25 \\times 1.3) \\times 10^{2}$$\n$$\\rho = (7.15 \\times 1.3) \\times 10^{2}$$\n$$\\rho = 9.295 \\times 10^{2}$$\n$$\\rho = 929.5$$\n问题要求答案四舍五入到四位有效数字。我们的结果 $929.5$ 已经是这个形式。", "answer": "$$\\boxed{929.5}$$", "id": "2755751"}, {"introduction": "我们已经建立了理论参数，但如何从真实的遗传数据中直接检测重组的印记呢？本练习将介绍经典的“四配子检验法”，这是识别历史重组事件确定性证据的基石。你将分析一个小的单倍型数据集，计算哈德森-卡普兰下界（Hudson–Kaplan bound）$R_m$，它为解释观测到的遗传变异所需的最少重组事件数量提供了一个明确的估计。这项实践将抽象的祖先重组图理论与序列数据中具体的遗传足迹联系起来。[@problem_id:2755740]", "problem": "在无限位点模型下，如果一个样本集在两个双等位基因位点 $i$ 和 $j$（其中 $i  j$）上同时表现出所有四种可能的单倍型（00、01、10 和 11），则称这两个位点是不相容的。这种不相容性是历史重组事件的证据。一个简化的重组下界可以通过计算必须包含重组事件的相邻位点区间的数量来确定。如果至少有一对不相容的位点 $(u, v)$ 跨越一个区间 $[i, i+1)$（即 $u \\le i  v$），那么该区间内必然发生过至少一次重组。\n\n您的任务是分析以下在 $m=5$ 个有序位点上的 $n=6$ 个单倍型数据，并计算必须包含重组事件的相邻区间的总数。\n$$\nH = \\begin{pmatrix}\n0  0  0  0  0\\\\\n0  0  1  1  0\\\\\n0  1  0  1  1\\\\\n1  0  0  1  0\\\\\n1  1  0  0  1\\\\\n0  1  1  0  1\n\\end{pmatrix}\n$$\n最终答案应为必须发生重组的区间的总数。", "solution": "该问题要求在无限位点模型下对单倍型数据进行分析，以确定重组事件数量的下界。我们将按顺序完成各项任务。给定数据包含在 $m=5$ 个有序位点上的 $n=6$ 个单倍型，由矩阵 $H$ 表示：\n$$\nH = \\begin{pmatrix}\n0  0  0  0  0\\\\\n0  0  1  1  0\\\\\n0  1  0  1  1\\\\\n1  0  0  1  0\\\\\n1  1  0  0  1\\\\\n0  1  1  0  1\n\\end{pmatrix}\n$$\n其中列对应于位点 $s_1, s_2, s_3, s_4, s_5$，行对应于观测到的单倍型。\n\n**1. 识别不相容的位点对**\n\n我们对所有 $i  j$ 的位点对 $(s_i, s_j)$ 应用四配子检验。\n*   $(s_1, s_2)$: 出现 (0,0), (0,1), (1,0), (1,1)。**不相容**。\n*   $(s_1, s_3)$: 出现 (0,0), (0,1), (1,0)。相容。\n*   $(s_1, s_4)$: 出现 (0,0), (0,1), (1,1)。相容。\n*   $(s_1, s_5)$: 出现 (0,0), (0,1), (1,1)。相容。\n*   $(s_2, s_3)$: 出现 (0,0), (0,1), (1,0), (1,1)。**不相容**。\n*   $(s_2, s_4)$: 出现 (0,0), (0,1), (1,1), (1,0)。**不相容**。\n*   $(s_2, s_5)$: 出现 (0,0), (0,1), (1,1)。相容。\n*   $(s_3, s_4)$: 出现 (0,0), (1,1), (0,1), (1,0)。**不相容**。\n*   $(s_3, s_5)$: 出现 (0,0), (1,0), (0,1), (1,1)。**不相容**。\n*   $(s_4, s_5)$: 出现 (0,0), (1,0), (1,1), (0,1)。**不相容**。\n\n不相容的位点对集合 $I$ 为：$\\{(1,2), (2,3), (2,4), (3,4), (3,5), (4,5)\\}$。\n\n**2. 检查每个区间是否需要重组**\n\n我们检查每个相邻区间 $[i, i+1)$ 是否被上述任何不相容对 $(u,v)$ 所跨越（即 $u \\le i  v$）。\n\n*   **区间 [1, 2)**: $i=1$。不相容对 $(1,2)$ 跨越此区间（$1 \\le 1  2$）。因此，该区间**需要**重组。\n*   **区间 [2, 3)**: $i=2$。不相容对 $(2,3)$ 和 $(2,4)$ 跨越此区间（例如，对 $(2,3)$ 有 $2 \\le 2  3$）。因此，该区间**需要**重组。\n*   **区间 [3, 4)**: $i=3$。不相容对 $(2,4)$, $(3,4)$, 和 $(3,5)$ 跨越此区间（例如，对 $(3,4)$ 有 $3 \\le 3  4$）。因此，该区间**需要**重组。\n*   **区间 [4, 5)**: $i=4$。不相容对 $(3,5)$ 和 $(4,5)$ 跨越此区间（例如，对 $(4,5)$ 有 $4 \\le 4  5$）。因此，该区间**需要**重组。\n\n**3. 计算需要重组的区间总数**\n\n所有四个相邻区间 $[1,2), [2,3), [3,4), [4,5)$ 都必须包含至少一次重组事件。\n\n因此，必须发生重组的区间的总数为 4。", "answer": "$$\\boxed{4}$$", "id": "2755740"}, {"introduction": "虽然像 $R_m$ 这样的下界信息丰富，但现代群体遗传学更依赖于复杂的概率方法来推断染色体上的“血缘镶嵌模式”。最后的这项练习将介绍一种强大的计算方法——Li and Stephens 复制模型，它能近似地模拟祖先重组图。通过实现一个隐马尔可夫模型（HMM），你将学习如何为一个单倍型推断最可能的祖先复制路径，并将复制模板之间的切换视为重组断点的近似位置。这项练习展示了如何运用实用的计算工具来近似和推断复杂的谱系历史。[@problem_id:2755679]", "problem": "给定一个焦点（查询）单倍型和一组供体单倍型在单核苷酸多态性（SNP）序列上的分阶段二元单倍型。假设一个隐马尔可夫模型 (HMM)，该模型按如下方式近似与祖先重组图 (ARG) 一致的沿基因组的复制过程：位点 $i$ 处的隐藏状态指示在该位点正在复制哪个供体单倍型，相邻位点之间的转换捕捉可能切换供体的重组事件，而位点 $i$ 处的发射是给定供体等位基因的情况下观察到焦点等位基因的概率，其中包含一个小的突变或错配概率。此 HMM 是 Li and Stephens 复制模型的一个特例，该模型通过将复制来源的切换建模为重组断点的近似来近似基因组上的谱系关系。\n\n基本和核心定义：\n- 令焦点单倍型为一个二元等位基因序列 $x_{1:L} \\in \\{0,1\\}^L$，并有 $K$ 个供体单倍型 $d^{(1)}_{1:L},\\dots,d^{(K)}_{1:L} \\in \\{0,1\\}^L$，所有单倍型都对齐到相同的 $L$ 个 SNP 位置。\n- HMM 的隐藏状态为 $S_i \\in \\{1,\\dots,K\\}$，其中 $S_i = k$ 表示在位点 $i$ 处，焦点单倍型从供体 $k$ 复制。\n- 初始分布是均匀的，$p(S_1 = k) = 1/K$ 对所有 $k \\in \\{1,\\dots,K\\}$ 成立。\n- 转换概率是位置同质的：对于相邻位点间给定的重组概率 $r \\in [0,1]$，\n$$\np(S_{i+1} = k \\mid S_i = j) = \n\\begin{cases}\n1 - r,  \\text{if } k=j,\\\\\n\\dfrac{r}{K-1},  \\text{if } k \\neq j,\n\\end{cases}\n$$\n对所有 $i \\in \\{1,\\dots,L-1\\}$ 和 $j,k \\in \\{1,\\dots,K\\}$ 成立。\n- 发射概率使用对称的错配（突变）率 $\\varepsilon \\in (0,0.5)$：\n$$\np(x_i \\mid S_i = k) =\n\\begin{cases}\n1 - \\varepsilon,  \\text{if } x_i = d^{(k)}_i,\\\\\n\\varepsilon,  \\text{if } x_i \\neq d^{(k)}_i,\n\\end{cases}\n$$\n对所有 $i \\in \\{1,\\dots,L\\}$ 和 $k \\in \\{1,\\dots,K\\}$ 成立。\n\n任务：\n- 实现缩放的前向-后向算法，以计算所有位点 $i \\in \\{1,\\dots,L\\}$ 和供体 $k \\in \\{1,\\dots,K\\}$ 的后验边际概率 $p(S_i = k \\mid x_{1:L})$。\n- 通过在每个位点 $i$ 选择供体索引 $\\hat{k}_i = \\arg\\max_{k \\in \\{1,\\dots,K\\}} p(S_i = k \\mid x_{1:L})$ 来执行后验解码。如果出现完全平局，则选择最小的索引 $k$。\n- 将解码路径中的切换解释为近似的重组断点：每当 $\\hat{k}_{i} \\neq \\hat{k}_{i-1}$ 时，在位点索引 $i$ 处（使用基于 1 的索引）记录一个断点（即，新的复制供体从位点 $i$ 开始）。为每个测试用例按升序报告所有这些索引。\n\n要硬编码的输入规范：\n- 每个单倍型都以长度为 $L$ 的二元字符串形式提供，字符在 $\\{0,1\\}$ 中。程序不得读取输入；相反，它必须使用下面定义的测试套件。\n\n测试套件：\n- 案例 1（正常路径，单一清晰切换）：\n  - 焦点：$\\texttt{0000011111}$\n  - 供体：$\\left[\\texttt{0000000000}, \\texttt{1111111111}\\right]$\n  - 参数：$r = 0.05$, $\\varepsilon = 0.01$\n- 案例 2（无切换，尽管重组率高但等位基因强匹配）：\n  - 焦点：$\\texttt{0101010101}$\n  - 供体：$\\left[\\texttt{0101010101}, \\texttt{1010101010}\\right]$\n  - 参数：$r = 0.5$, $\\varepsilon = 0.01$\n- 案例 3（边缘情况：供体相同，平局处理）：\n  - 焦点：$\\texttt{0011001100}$\n  - 供体：$\\left[\\texttt{0011001100}, \\texttt{0011001100}\\right]$\n  - 参数：$r = 0.2$, $\\varepsilon = 0.1$\n- 案例 4（两次切换，清晰片段）：\n  - 焦点：$\\texttt{0000111100}$\n  - 供体：$\\left[\\texttt{0000000000}, \\texttt{1111111111}\\right]$\n  - 参数：$r = 0.02$, $\\varepsilon = 0.01$\n\n输出规范：\n- 对于每个测试用例，输出一个整数列表，其中包含按升序排列的基于 1 的断点位点索引。\n- 将所有测试用例的结果按上述顺序汇总到一个列表中。\n- 您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，例如，对于上述四个案例，输出为 $\\texttt{[[6],[],[],[5,9]]}$。\n\n假设：\n- 所有单倍型都已分阶段并对齐，每个测试用例的长度 $L$ 一致。\n- 供体数量满足 $K \\ge 2$。\n- 所有概率均有效：$r \\in [0,1]$, $\\varepsilon \\in (0,0.5)$。\n\n您的任务：\n- 编写一个完整、可运行的程序，实现上述 HMM 后验解码，并以所描述的精确最终输出格式为提供的测试套件输出断点。", "solution": "所提出的问题是隐马尔可夫模型 (HMM) 在群体遗传学问题中的一个适定应用，具体而言是从单倍型数据推断祖先复制路径。它是 Li and Stephens 模型的一个变体，该模型近似了祖先重组图 (ARG) 的复杂谱系过程。该问题具有科学依据，在数学上是一致的，并且得到了充分的规定。因此，我们着手进行形式化的求解。\n\n目标是计算后验边际概率 $p(S_i = k \\mid x_{1:L})$，其中隐藏状态 $S_i$ 代表在位点 $i$ 复制的供体单倍型 $k$，给定观测到的焦点单倍型 $x_{1:L}$。这是 HMM 的一个标准推断任务，其典型方法是前向-后向算法。为了防止数值下溢（在长序列上乘以许多小概率时很常见），我们必须实现该算法的缩放版本。\n\n首先，我们对 HMM 的组成部分进行形式化。\n设 $K$ 为供体单倍型的数量，$L$ 为 SNP 位点的数量。焦点单倍型是一个向量 $x \\in \\{0, 1\\}^L$。供体单倍型构成一个矩阵 $D \\in \\{0, 1\\}^{K \\times L}$。\n\n1.  **初始状态分布**：在第一个位点 ($i=1$) 从任何供体 $k$ 复制的初始概率是均匀的。这由一个长度为 $K$ 的向量 $\\pi$ 表示：\n    $$ \\pi_k = p(S_1 = k) = \\frac{1}{K} \\quad \\text{for } k \\in \\{1,\\dots,K\\} $$\n\n2.  **转换矩阵**：从位点 $i$ 复制供体 $j$ 转换到在位点 $i+1$ 复制供体 $k$ 的概率由一个 $K \\times K$ 的位置同质转换矩阵 $T$ 给出，其中 $T_{jk} = p(S_{i+1} = k \\mid S_i = j)$。对于重组概率 $r$，其元素为：\n    $$\n    T_{jk} = \n    \\begin{cases}\n    1 - r,  \\text{if } k=j, \\\\\n    \\frac{r}{K-1},  \\text{if } k \\neq j.\n    \\end{cases}\n    $$\n    该矩阵是对称且双随机的。\n\n3.  **发射概率**：在位点 $i$ 观察到等位基因 $x_i$ 的概率，假定焦点单倍型正在从供体 $k$ 复制，为 $p(x_i \\mid S_i = k)$。对于对称的错配率 $\\varepsilon$，其表达式为：\n    $$\n    p(x_i \\mid S_i = k) = \n    \\begin{cases}\n    1 - \\varepsilon,  \\text{if } x_i = d^{(k)}_i, \\\\\n    \\varepsilon,  \\text{if } x_i \\neq d^{(k)}_i.\n    \\end{cases}\n    $$\n    为便于实现，我们预先计算一个大小为 $K \\times L$ 的发射概率矩阵 $E$，其中 $E_{ki} = p(x_i \\mid S_i = k)$。\n\n求解过程通过实现缩放的前向-后向算法来进行。\n\n**缩放的前向传递 (Alpha-Pass)**\n\n前向变量 $\\alpha_i(k) = p(x_{1:i}, S_i = k)$ 是观察到截至位点 $i$ 的序列且在位点 $i$ 处于状态 $k$ 的联合概率。为避免下溢，我们计算一个缩放变量 $\\hat{\\alpha}_i(k) = p(S_i = k \\mid x_{1:i})$，即给定截至位点 $i$ 的序列，处于状态 $k$ 的后验概率。缩放通过归一化常数 $c_i = p(x_i \\mid x_{1:i-1})$ 实现。\n\n初始化 ($i=1$):\n令 $\\hat{\\alpha}_1$ 为长度为 $K$ 的列向量。未缩放的前向概率为 $\\alpha'_1(k) = \\pi_k E_{k1}$。缩放常数为 $c_1 = \\sum_{j=1}^K \\alpha'_1(j)$。缩放后的前向变量为 $\\hat{\\alpha}_1(k) = \\frac{\\alpha'_1(k)}{c_1}$。\n\n递推 ($i=2, \\dots, L$):\n未缩放的变量通过对先前状态求和并乘以发射概率来计算：$\\alpha'_i(k) = \\left( \\sum_{j=1}^K \\hat{\\alpha}_{i-1}(j) T_{ji} \\right) E_{ki}$。然后对其进行缩放：\n$$ c_i = \\sum_{k=1}^K \\alpha'_i(k) $$\n$$ \\hat{\\alpha}_i(k) = \\frac{\\alpha'_i(k)}{c_i} $$\n我们存储所有 $i$ 的缩放前向向量 $\\hat{\\alpha}_{:,i}$ 和所有 $i$ 的缩放常数 $c_i$。\n\n**缩放的后向传递 (Beta-Pass)**\n\n后向变量 $\\beta_i(k) = p(x_{i+1:L} \\mid S_i = k)$ 是在位点 $i$ 处于状态 $k$ 的条件下，观察到从位点 $i+1$ 到末尾的序列的概率。我们使用从前向传递中得到的相同缩放常数 $c_i$ 来计算缩放变量 $\\hat{\\beta}_i(k)$。\n\n初始化 ($i=L$):\n$$ \\hat{\\beta}_{L}(k) = 1 \\quad \\text{for all } k=1,\\dots,K. $$\n\n递推 ($i=L-1, \\dots, 1$):\n缩放后向变量的递推公式为：\n$$ \\hat{\\beta}_{i}(j) = \\frac{1}{c_{i+1}} \\sum_{k=1}^K T_{jk} E_{k,i+1} \\hat{\\beta}_{i+1}(k) $$\n此传递计算并存储所有位点 $i$ 的 $\\hat{\\beta}_{i}$。\n\n**后验解码与断点识别**\n\n在位点 $i$ 处于状态 $k$ 的后验边际概率由以下公式给出：\n$$ p(S_i = k \\mid x_{1:L}) = \\frac{\\alpha_i(k)\\beta_i(k)}{p(x_{1:L})} $$\n使用缩放变量，此式得以简化。乘积 $\\hat{\\alpha}_i(k) \\hat{\\beta}_i(k)$ 与后验概率成正比。我们在每个位点 $i$ 对每个状态 $k$ 计算该乘积，然后进行归一化。\n$$ \\gamma_i(k) = \\hat{\\alpha}_i(k) \\hat{\\beta}_i(k) $$\n$$ p(S_i=k \\mid x_{1:L}) = \\frac{\\gamma_i(k)}{\\sum_{j=1}^K \\gamma_i(j)} $$\n对于每个位点 $i$，我们通过找到具有最高后验概率的状态来执行后验解码：\n$$ \\hat{k}_i = \\operatorname{arg\\,max}_{k \\in \\{1,\\dots,K\\}} p(S_i = k \\mid x_{1:L}) $$\n问题规定，平局通过选择最小的状态索引 $k$ 来解决。\n\n如果解码状态与前一个位点相比发生变化，则在位点 $i$（使用基于 1 的索引）处识别出一个重组断点：\n$$ \\hat{k}_{i} \\neq \\hat{k}_{i-1} \\quad \\text{for } i \\in \\{2, \\dots, L\\} $$\n对每个测试用例，所有这些位点的索引都按升序收集。\n实现将封装此逻辑，遍历提供的测试用例，并以所需格式生成最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the HMM problem for all test cases.\n    It orchestrates the execution for each case and formats the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"focal\": \"0000011111\",\n            \"donors\": [\"0000000000\", \"1111111111\"],\n            \"params\": {\"r\": 0.05, \"eps\": 0.01},\n        },\n        {\n            \"focal\": \"0101010101\",\n            \"donors\": [\"0101010101\", \"1010101010\"],\n            \"params\": {\"r\": 0.5, \"eps\": 0.01},\n        },\n        {\n            \"focal\": \"0011001100\",\n            \"donors\": [\"0011001100\", \"0011001100\"],\n            \"params\": {\"r\": 0.2, \"eps\": 0.1},\n        },\n        {\n            \"focal\": \"0000111100\",\n            \"donors\": [\"0000000000\", \"1111111111\"],\n            \"params\": {\"r\": 0.02, \"eps\": 0.01},\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        focal_str = case[\"focal\"]\n        donors_str = case[\"donors\"]\n        r = case[\"params\"][\"r\"]\n        eps = case[\"params\"][\"eps\"]\n        \n        breakpoints = run_hmm_decoder(focal_str, donors_str, r, eps)\n        results.append(breakpoints)\n\n    formatted_parts = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_parts)}]\")\n\n\ndef run_hmm_decoder(focal_str, donors_str, r, eps):\n    \"\"\"\n    Implements the scaled Forward-Backward algorithm for a single test case.\n    \n    Args:\n        focal_str (str): The focal haplotype as a binary string.\n        donors_str (list[str]): A list of donor haplotypes as binary strings.\n        r (float): The recombination probability.\n        eps (float): The symmetric miscopy/mutation rate.\n        \n    Returns:\n        list[int]: A list of 1-based breakpoint indices.\n    \"\"\"\n    focal = np.array([int(c) for c in focal_str], dtype=np.int8)\n    donors = np.array([[int(c) for c in d] for d in donors_str], dtype=np.int8)\n    \n    L = len(focal)\n    K = len(donors)\n\n    # Transition matrix (T_ij = p(S_t+1=j | S_t=i))\n    if K > 1:\n        T = np.full((K, K), r / (K - 1))\n        np.fill_diagonal(T, 1 - r)\n    else: # Handle K=1 case\n        T = np.array([[1.0]])\n\n    # Emission matrix (E_ki = p(x_i | S_i=k))\n    E = np.zeros((K, L))\n    for k in range(K):\n        matches = (focal == donors[k])\n        E[k, matches] = 1 - eps\n        E[k, ~matches] = eps\n    \n    # Scaled Forward Pass\n    alpha_hat = np.zeros((K, L))\n    c = np.zeros(L)\n    \n    pi = np.full(K, 1.0/K)\n    alpha_prime_0 = pi * E[:, 0]\n    c[0] = np.sum(alpha_prime_0)\n    alpha_hat[:, 0] = alpha_prime_0 / c[0]\n    \n    for i in range(1, L):\n        alpha_prime_i = (alpha_hat[:, i - 1] @ T) * E[:, i]\n        c[i] = np.sum(alpha_prime_i)\n        alpha_hat[:, i] = alpha_prime_i / c[i]\n        \n    # Scaled Backward Pass\n    beta_hat = np.zeros((K, L))\n    \n    beta_hat[:, L - 1] = 1.0\n    \n    for i in range(L - 2, -1, -1):\n        beta_hat[:, i] = (T @ (E[:, i + 1] * beta_hat[:, i + 1])) / c[i + 1]\n    \n    # Posterior Decoding\n    gamma = alpha_hat * beta_hat\n    decoded_path = np.argmax(gamma, axis=0)\n    \n    # Breakpoint Identification\n    breakpoints = []\n    for i in range(1, L):\n        if decoded_path[i] != decoded_path[i-1]:\n            breakpoints.append(i + 1)\n            \n    return breakpoints\n    \nsolve()\n```", "id": "2755679"}]}