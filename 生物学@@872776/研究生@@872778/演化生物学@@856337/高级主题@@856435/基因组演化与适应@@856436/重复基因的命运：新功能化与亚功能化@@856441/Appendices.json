{"hands_on_practices": [{"introduction": "要理解重复基因为何有时能被保留下来，我们首先需要定量地把握它们最普遍的命运：通过退化突变沦为无功能的“假基因”。这个练习将引导你从群体遗传学的基本原理出发，推导出基因丢失的“倒计时”，即一个冗余基因在被随机遗传漂变清除之前，其预期的生存时间。通过这个计算，你将深刻体会到重复基因所面临的巨大淘汰压力。[@problem_id:2712752]", "problem": "考虑一个新出现的基因重复，该重复在一个二倍体种群中被固定。该种群由一个具有恒定有效种群大小 $N_{e}$ 的 Wright–Fisher 模型描述。重复发生后，两个旁系同源基因在功能上是冗余的，并且不存在针对冗余性的正选择或负选择：只要另一个拷贝保持功能，失去一个拷贝的功能对适合度没有影响。假设每个单倍体、每代、每个基因座上，使一个拷贝完全失活（功能丧失，LoF）的突变率为 $\\mu_{L}$，并假设没有回复突变或重新激活，没有基因转换，且两个基因座相互独立。将“重复基因对的假基因化”定义为任一旁系同源基因上的LoF等位基因在种群中固定的时间点，此时所有个体中的一个拷贝在功能上丧失，只留下一个功能性拷贝。\n\n仅从以下基本事实出发：\n- 在一个 Wright–Fisher 种群中，一个新出现的中性等位基因的初始频率为 $p$，其固定概率也为 $p$。\n- 在一个有效种群大小为 $N_{e}$ 的种群中，每个基因座上每代产生的新中性突变数量为 $2N_{e}\\mu$（二倍体），其中 $\\mu$ 是每个单倍体、每代、每个基因座的突变率。\n- 当固定事件稀少且独立时，中性固定的过程可以被建模为一个泊松过程，其速率等于新中性等位基因的产生速率与其固定概率的乘积。\n\n推导：\n1) 生存函数 $S(T)$，即经过 $T$ 代后，重复基因对仍然保留两个功能性拷贝（即未发生假基因化）的概率。该函数应表示为 $T$ 和 $\\mu_{L}$ 的函数，并明确通过 $N_{e}$ 来考虑遗传漂变。\n2) 直至假基因化的期望时间 $\\mathbb{E}[T_{\\text{pseudo}}]$，以代为单位表示。\n\n请将您的最终答案以单个闭合形式的解析表达式给出，该表达式包含在一个单行矩阵 $\\bigl(S(T), \\mathbb{E}[T_{\\text{pseudo}}]\\bigr)$ 中，并仅用 $\\mu_{L}$ 和 $T$ 进行简化。不需要数值近似。期望时间以代为单位表示。在您的方框最终答案中不要包含任何单位。", "solution": "首先将对问题陈述进行严格的验证程序。\n\n**第 1 步：提取已知条件**\n- **模型：** 二倍体 Wright–Fisher 模型。\n- **种群大小：** 恒定的有效种群大小 $N_{e}$。\n- **初始状态：** 一个新出现的基因重复在种群中被固定。两个旁系同源基因在功能上是冗余的。\n- **选择条件：** 只要另一个拷贝保持功能，一个拷贝的功能丧失（LoF）是中性的。\n- **突变率：** 每个单倍体、每代、每个基因座上，发生完全 LoF 突变的速率为 $\\mu_{L}$。\n- **假设：** 没有回复突变或重新激活；没有基因转换；两个基因座相互独立。\n- **定义：** “重复基因对的假基因化”是指任一旁系同源基因上的LoF等位基因在种群中固定的事件。该事件发生的时间为 $T_{\\text{pseudo}}$。\n- **基本事实：**\n    1. 一个初始频率为 $p$ 的新中性等位基因的固定概率为 $p$。\n    2. 在一个二倍体种群中，每个基因座上每代产生的新中性突变数量为 $2N_{e}\\mu$。\n    3. 中性固定的过程可以被建模为一个泊松过程，其速率等于新中性等位基因的产生速率与其固定概率的乘积。\n- **要求推导：**\n    1. 生存函数 $S(T)$，即经过 $T$ 代后两个拷贝均保持功能的概率。\n    2. 直至假基因化的期望时间 $\\mathbb{E}[T_{\\text{pseudo}}]$。\n- **最终答案约束：** 最终答案必须是一个包含两项结果的单行矩阵，且仅用 $\\mu_{L}$ 和 $T$ 表示。\n\n**第 2 步：问题验证**\n该问题具有科学依据，借鉴了群体遗传学的基本原理，特别是应用于重复基因命运的中性分子进化理论。这是一个经典且成熟的问题结构，通常与 Lynch 和 Conery 提出的模型相关联。该问题定义明确，所有必需的参数（$\\mu_{L}$，$N_{e}$）和假设（二倍体 Wright-Fisher 模型，中性，无回复突变）都已清晰陈述。语言精确客观。所提供的“基本事实”是群体遗传学理论的基石，并以逻辑一致的方式指导推导过程。设置并无矛盾之处；最终要求在答案中不包含 $N_{e}$ 是中性替换率计算的直接结果，而问题正引导解答者进行此项计算。该问题并非无足轻重，因为它要求正确综合多个概念：突变、遗传漂变、固定概率和泊松过程。因此，该问题被视为有效。\n\n**第 3 步：求解推导**\n任务是确定一个冗余基因对在其一个拷贝因功能丧失（LoF）等位基因的固定而假基因化之前的生存函数和期望寿命。固定过程由遗传漂变驱动。\n\n首先，我们必须确定在单个基因座上发生假基因化的速率。根据问题陈述，LoF 突变是中性的。我们已获得计算此类中性等位基因替换率所需的基本原理。\n\n让我们考虑两个旁系同源基因座中的一个。\n1. 在该基因座上，每代新 LoF 突变的产生速率，是种群中的基因拷贝总数（对于大小为 $N_{e}$ 的二倍体种群，为 $2N_{e}$）与每个拷贝的突变率（$\\mu_{L}$）的乘积。\n    每个基因座每代新 LoF 突变的速率 = $2N_{e}\\mu_{L}$。\n\n2. 一个新突变产生于单条染色体上。在一个大小为 $N_{e}$ 的二倍体种群中，该基因座共有 $2N_{e}$ 个基因拷贝。因此，一个新出现的突变等位基因的初始频率 $p$ 为：\n    $$p = \\frac{1}{2N_{e}}$$\n\n3. 根据基本事实，一个中性等位基因的固定概率等于其初始频率。\n    $$P_{\\text{fix}} = p = \\frac{1}{2N_{e}}$$\n\n4. 中性等位基因的固定速率，我们称之为替换率，是新突变产生速率与其固定概率的乘积。我们将单个基因座的该速率表示为 $\\lambda_{1}$。\n    $$\\lambda_{1} = (\\text{Rate of new mutations}) \\times (P_{\\text{fix}})$$\n    $$\\lambda_{1} = (2N_{e}\\mu_{L}) \\times \\left(\\frac{1}{2N_{e}}\\right) = \\mu_{L}$$\n这是中性理论的一个经典结果：中性替换率等于每个配子每代的的中性突变率。请注意，有效种群大小 $N_{e}$ 已被消去，这与最终答案的指令是一致的。因此，单个基因拷贝的假基因化速率为 $\\mu_{L}$。\n\n接下来，我们考虑重复基因对。基因对的假基因化被定义为在两个旁系同源基因中的*任一个*上发生 LoF 等位基因的固定。问题陈述指出两个基因座是独立的。每个基因座上的固定过程是一个速率为 $\\lambda_{1} = \\mu_{L}$ 的泊松过程。\n\n我们关心的事件是在基因座1或基因座2上首次发生固定。对于两个速率分别为 $\\lambda_{A}$ 和 $\\lambda_{B}$ 的独立泊松过程，在*任一*过程中发生第一个事件的时间呈指数分布，其速率为 $\\Lambda = \\lambda_{A} + \\lambda_{B}$。\n\n在我们的情况下，两个基因座的速率相同：$\\lambda_{1} = \\lambda_{2} = \\mu_{L}$。\n因此，基因对的总假基因化速率 $\\Lambda$ 为：\n$$\\Lambda = \\mu_{L} + \\mu_{L} = 2\\mu_{L}$$\n\n现在我们可以推导所需的两个量。\n\n**1) 生存函数 $S(T)$**\n生存函数 $S(T)$ 是指到第 $T$ 代为止，没有发生假基因化事件的概率。对于一个速率为 $\\Lambda$ 的泊松过程，在长度为 $T$ 的区间内观察到零个事件的概率由泊松分布公式中 $k=0$ 的情况给出：\n$$P(k=0; \\Lambda T) = \\frac{(\\Lambda T)^{0} \\exp(-\\Lambda T)}{0!} = \\exp(-\\Lambda T)$$\n因此，生存函数为：\n$$S(T) = \\exp(-\\Lambda T)$$\n代入 $\\Lambda = 2\\mu_{L}$：\n$$S(T) = \\exp(-2\\mu_{L}T)$$\n\n**2) 假基因化的期望时间 $\\mathbb{E}[T_{\\text{pseudo}}]$**\n在一个速率为 $\\Lambda$ 的泊松过程中，到第一个事件发生的时间遵循指数分布。该等待时间 $t$ 的概率密度函数是 $f(t) = \\Lambda \\exp(-\\Lambda t)$。速率参数为 $\\Lambda$ 的指数分布的期望值（或均值）是 $\\frac{1}{\\Lambda}$。\n因此，基因对直至假基因化的期望时间是：\n$$\\mathbb{E}[T_{\\text{pseudo}}] = \\frac{1}{\\Lambda}$$\n代入 $\\Lambda = 2\\mu_{L}$：\n$$\\mathbb{E}[T_{\\text{pseudo}}] = \\frac{1}{2\\mu_{L}}$$\n\n两个结果 $S(T)$ 和 $\\mathbb{E}[T_{\\text{pseudo}}]$ 仅用 $\\mu_{L}$ 和 $T$ 表示，符合要求。", "answer": "$$\\boxed{\\begin{pmatrix} \\exp(-2\\mu_{L}T)  \\frac{1}{2\\mu_{L}} \\end{pmatrix}}$$", "id": "2712752"}, {"introduction": "新功能化是重复基因逃脱假基因化命运、得以保留的关键途径之一，它本质上是一场与基因退化“时钟”的赛跑。这项练习要求你计算一个有利的新功能出现并最终在群体中固定的预期等待时间。这个结果为我们评估新功能化这一演化路径的可行性，提供了一个定量的分析框架。[@problem_id:2712805]", "problem": "一个新复制的基因对在一个泛交的二倍体种群中分离，该种群根据 Wright–Fisher 模型演化，具有恒定的有效种群大小 $N$ 和非重叠的世代。考虑通过单个有益突变发生的新功能化，该突变在该重复基因对的任一成员上为突变携带者赋予了由选择系数 $s$ 量化的基因性、半显性的选择优势。假设在每一代，对于每个单倍体基因组，这类新功能化的有益突变在该重复基因对内任何位置产生的每代速率为 $\\mu_{b}$，且 $\\mu_{b} \\ll 1$ 和 $s \\ll 1$。你可以使用广泛接受的近似公式来计算在一个大的二倍体 Wright–Fisher 种群中，在基因选择下一个新产生的半显性有益突变的固定概率，即 $P_{\\text{fix}}(s) \\approx 2s$，前提是其有效性范围得到遵守。\n\n从 Wright–Fisher 过程的定义、稀有突变事件的独立性，以及突变供给与在种群中固定之间的关系出发，推导首次成功新功能化事件（定义为最终固定的第一个新功能化突变）的预期等待时间（以代为单位）。将你的最终答案表示为一个以 $N$、$\\mu_{b}$ 和 $s$ 表示的闭式解析表达式。\n\n最后，简要描述在何种参数范围和模型假设下你的表达式预计是准确的，并突出相对于现实中也可能发生亚功能化的重复基因演化而言，该模型的任何关键局限性。你的最终数值表达式不应包含任何单位；时间单位是代。", "solution": "问题陈述经过验证。\n\n从陈述中逐字提取的已知条件：\n1.  **种群与模型**：一个泛交的二倍体种群，根据 Wright–Fisher 模型演化。\n2.  **种群大小**：恒定的有效种群大小 $N$。\n3.  **世代**：非重叠。\n4.  **演化过程**：通过单个有益突变实现新功能化。\n5.  **选择**：基因性的、半显性的选择优势，由选择系数 $s$ 量化。\n6.  **突变目标**：重复基因对的任一成员。\n7.  **突变率**：对于每个单倍体基因组，在重复基因对的任何位置，每代产生新功能化有益突变的速率为 $\\mu_{b}$。\n8.  **参数约束**：$\\mu_{b} \\ll 1$ 和 $s \\ll 1$。\n9.  **给定的近似**：一个新产生的半显性有益突变的固定概率为 $P_{\\text{fix}}(s) \\approx 2s$，适用于大的二倍体 Wright–Fisher 种群。\n10. **目标**：推导首次成功新功能化事件的预期等待时间（以代为单位），该事件定义为最终固定的第一个新功能化突变。\n11. **附加任务**：描述推导出的表达式准确性所依赖的参数范围和模型假设，并突出其局限性。\n\n验证结论：\n该问题具有科学依据、提法明确且客观。它基于种群遗传学的基本原理，即 Wright–Fisher 模型、突变、选择和遗传漂变。新功能化、选择系数和固定概率等概念在演化生物学中是标准概念。问题提供了所有必要的参数（$N$、$\\mu_{b}$、$s$）和一个著名的固定概率近似公式，使其自洽且可解。其表述中没有科学或事实上的不健全之处，没有矛盾，也没有歧义。该问题是演化动力学中的一个标准理论练习。因此，该问题被判定为**有效**。\n\n求解过程如下。\n目标是确定预期等待时间（以代为单位），直到第一个新功能化突变出现并走向固定。这个过程可以被建模为一系列独立的伯努利试验，其中每一代都是一次试验。在给定的一代中，“成功”是指一个新的新功能化突变出现并且注定要被固定的事件。在这样的序列中，第一次成功的等待时间遵循几何分布。如果 $p$ 是在任何单一代中成功的概率，则预期等待时间 $E[T]$ 由 $E[T] = \\frac{1}{p}$ 给出。\n\n我们的首要任务是计算这个概率 $p$。这个概率是两个量的乘积：\n1.  每代新功能化突变进入种群的速率。\n2.  任何一个这样的新突变最终在种群中固定的概率。\n\n让我们计算第一个量。种群是二倍体，有效大小为 $N$。这意味着种群中有 $2N$ 个单倍体基因组。每个单倍体基因组每代产生新功能化突变的速率为 $\\mu_{b}$。假设突变事件是独立且稀有的（$\\mu_b \\ll 1$），则在整个种群中一代内出现的新功能化突变的期望数量是基因拷贝数与每个拷贝的突变率的乘积。\n设 $\\Lambda_{\\text{mut}}$ 为突变供给速率。\n$$\n\\Lambda_{\\text{mut}} = (2N) \\times \\mu_{b} = 2N\\mu_{b}\n$$\n这个量代表每代进入种群的平均新有益突变数量。\n\n接下来，我们考虑第二个量：固定概率。问题提供了对于一个选择系数为 $s$ 的新产生的半显性有益突变的固定概率的近似值：\n$$\nP_{\\text{fix}}(s) \\approx 2s\n$$\n这是 Kimura 扩散理论的一个经典结果，适用于选择较弱（$s \\ll 1$）但在大种群中足以克服随机遗传漂变（具体来说，$2Ns \\gg 1$）的情况。\n\n在单一代中成功事件的概率 $p$，是注定要固定的突变产生的速率。这是突变供给速率与每个突变的固定概率的乘积。\n$$\np = \\Lambda_{\\text{mut}} \\times P_{\\text{fix}}(s)\n$$\n代入各项的表达式：\n$$\np \\approx (2N\\mu_{b}) \\times (2s) = 4N\\mu_{b}s\n$$\n这是在任何给定代中启动一次成功的新功能化的概率。\n\n最后，根据几何分布的性质，第一次此类事件的预期等待时间 $E[T]$ 是该概率的倒数。\n$$\nE[T] = \\frac{1}{p} = \\frac{1}{4N\\mu_{b}s}\n$$\n该表达式给出了一个新功能化突变出现并固定所需的预期世代数。\n\n现在，我们必须描述该结果的参数范围和局限性。\n该表达式的有效性依赖于几个关键假设：\n1.  **Wright–Fisher 模型**：种群根据 Wright–Fisher 模型演化，该模型假设恒定的有效种群大小 $N$、非重叠的世代和随机交配（泛交）。\n2.  **固定的参数范围**：近似公式 $P_{\\text{fix}}(s) \\approx 2s$ 在选择较弱（$s \\ll 1$）但仍能有效对抗漂变的大种群中有效。形式化条件是 $2Ns \\gg 1$。如果选择太弱（$2Ns \\le 1$），漂变将占主导地位，固定概率会低得多，趋近于中性值 $\\frac{1}{2N}$。\n3.  **连续清除机制**：该推导隐含地假设有益突变的产生足够稀少，以至于它们不会相互竞争。这就是“连续清除”机制，即一个有益突变在下一个出现之前就已经固定。这要求成功突变输入的速率必须远小于 $1$，即 $p = 4N\\mu_{b}s \\ll 1$。一个更严格的条件是，等待一个新成功突变的时间（$E[T]$）远长于这样一个突变固定的时间（$T_{\\text{fix}} \\approx \\frac{2}{s}\\ln(2N)$）。这个条件 $E[T] \\gg T_{\\text{fix}}$ 确保了当下一个成功突变出现时，种群对于野生型等位基因实际上是单态的。如果 $4N\\mu_b s$ 不小，多个有益突变可能同时分离，导致克隆干扰，这会减缓适应速度并增加等待时间。\n4.  **突变性质**：假设只有一种类型的有益突变是可能的，其具有特定的速率 $\\mu_{b}$ 和选择系数 $s$。该模型将新功能化视为单步过程。\n\n此模型相对于现实的重复基因演化的主要局限性：\n1.  **忽略其他命运**：该模型只考虑了新功能化。实际上，重复基因最可能的命运是通过退化性突变发生的非功能化（变成假基因），这些突变的发生率远高于有益突变。第二个主要命运，亚功能化（祖先功能的划分），也被忽略了。一个完整的模型必须考虑这些不同演化路径之间的竞争。重复基因对必须持续足够长的时间才能发生新功能化，这意味着非功能化的速率相对于新功能化的速率必须足够低。推导出的等待时间是以重复基因对不丢失为条件的。\n2.  **简化的遗传学**：模型假设存在一个具有恒定、基因性选择系数 $s$ 的单个有益突变。现实世界中的新功能化可能是一个涉及多个突变的多步过程。此外，选择优势可能不是恒定的；它可能依赖于环境或遗传背景（上位效应）。\n3.  **重复基因的稳定性**：推导假设重复基因对是基因组中的一个稳定实体，作为突变的恒定目标。实际上，重复基因常常通过非等位同源重组而快速丢失。该模型未包含整个重复基因座的基因丢失率。\n\n总之，对于一个大的、理想化的种群，在其中新功能化突变稀有但受到强选择，并且重复基因的其他演化命运被忽略的情况下，所推导的表达式是新功能化等待时间的精确近似。", "answer": "$$\\boxed{\\frac{1}{4N\\mu_{b}s}}$$", "id": "2712805"}, {"introduction": "重复基因的最终命运并非孤立决定，而是不同演化路径相互竞争的结果。这项计算实践将指导你构建一个演化模拟模型，以探索诸如功能成本、收益以及基因间的相互作用（上位性）等因素，如何影响新功能化与亚功能化之间的平衡。通过亲手实现这个模型，你将获得一个关于基因重复后演化动态的更综合、更生动的视角。[@problem_id:2712820]", "problem": "您将实现并分析一个最小进化模型，该模型用于研究重复基因在具有可调上位性的复合适应度函数下经历选择的过程，并将适应性结果分类为新功能化或亚功能化。该模型必须被完全指定，在给定随机种子的情况下是确定性的，并通过模拟求解。所有输出必须是数值型且可复现的。\n\n定义与基本原理：\n- 从强选择弱突变（SSWM）近似下的原则出发，适应性进化通过顺序固定增加绝对适应度的单个突变来进行。在此机制下，适应性行走是在一个固定的适应度景观上的贪婪爬山过程，直到达到一个没有有益单步邻居的局部最优点。\n- 用三个功能（两个祖先亚功能和一个潜在新功能）的二元存在或缺失来表示两个重复基因拷贝的基因型。对于拷贝索引 $j \\in \\{1,2\\}$ 和功能索引 $i \\in \\{1,2,N\\}$，令 $x_{j i} \\in \\{0,1\\}$ 表示功能 $i$ 在拷贝 $j$ 中的存在（$1$）或缺失（$0$）。紧随重复事件之后的初始状态为 $x_{11}=1$, $x_{12}=1$, $x_{1N}=0$, $x_{21}=1$, $x_{22}=1$, $x_{2N}=0$。\n- 令 $r \\in [0,1]$ 为一个上位性参数，它控制任意功能在两个拷贝间的冗余性所带来的收益递减效应。定义每个功能的冗余响应函数 $g:\\{0,1,2\\}\\to\\mathbb{R}_{\\ge 0}$ 为 $g(0)=0$，$g(1)=1$，$g(2)=2-r$。因此，$r=0$ 表示跨拷贝的累加收益，$r=1$ 表示完全冗余，即同一功能的第二个拷贝不提供额外收益。\n- 令 $b_10$，$b_20$ 和 $b_N0$ 分别为功能 $1$、$2$ 和 $N$ 的单位功能收益系数。令 $c \\ge 0$ 为单位功能单位拷贝的成本。生物体适应度函数为\n$$\nW(x) \\;=\\; b_1 \\, g(x_{11}+x_{21}) \\;+\\; b_2 \\, g(x_{12}+x_{22}) \\;+\\; b_N \\, g(x_{1N}+x_{2N})\n\\;-\\; c \\sum_{j=1}^{2}\\sum_{i\\in\\{1,2,N\\}} x_{j i}.\n$$\n- 适应性行走按以下方式进行（SSWM 贪婪爬山）：\n    1. 从当前状态 $x$ 出发，枚举所有通过翻转恰好一个比特位 $x_{j i}\\mapsto 1-x_{j i}$ 得到的 $6$ 个单步邻居。\n    2. 计算每个邻居相对于当前状态的适应度差异 $\\Delta W$。\n    3. 如果最大 $\\Delta W$ 为正，则移动到达到该最大值的某个邻居。如果存在平局，则通过按 $(j,i)$ 的字典序扫描邻居来确定性地打破平局，其中 $j$ 从 $1$ 增加到 $2$，$i$ 的顺序为 $1,2,N$，并选择遇到的第一个达到最大 $\\Delta W$ 的邻居。\n    4. 如果没有邻居的 $\\Delta W0$，则停止；当前状态是单步突变下的一个局部最优点。\n- 跨重复实验的景观随机性：\n    - 祖先收益系数 $b_1$ 和 $b_2$ 从形状参数为 $k_b=2$、尺度参数为 $\\theta_b=\\mu_b/k_b$ 的伽马分布中独立抽取，因此 $\\mathbb{E}[b_1]=\\mathbb{E}[b_2]=\\mu_b$。\n    - 新功能收益 $b_N$ 从形状参数为 $k_b=2$、尺度参数为 $\\theta_N=\\mu_N/k_b$ 的伽马分布中抽取，因此 $\\mathbb{E}[b_N]=\\mu_N$。\n    - 景观的所有其他方面由 $(r,c)$ 固定。\n- 在局部最优点的结果分类：\n    - 定义覆盖指示符 $y_1=\\mathbf{1}\\{x_{11}+x_{21}\\ge 1\\}$ 和 $y_2=\\mathbf{1}\\{x_{12}+x_{22}\\ge 1\\}$，以及新功能拷贝数 $n_N = x_{1N}+x_{2N}$。\n    - 当且仅当 $n_N=1$，$y_1=1$，$y_2=1$，并且至少一个重复拷贝完全保留了两个祖先功能，即 $\\max\\{\\;x_{11}+x_{12},\\; x_{21}+x_{22}\\;\\}=2$ 时，记录为新功能化。\n    - 当且仅当 $n_N=0$，$y_1=1$，$y_2=1$，并且每个重复拷贝精确保留一个祖先亚功能，即 $x_{11}+x_{12}=1$ 且 $x_{21}+x_{22}=1$ 时，记录为亚功能化。\n    - 任何其他结果（包括祖先功能覆盖丢失、完全冗余保留或两个重复拷贝都获得新功能）均记录为“皆非”。\n- 频率通过 $R$ 次独立重复实验的经验比例来衡量，并且必须表示为 $[0,1]$ 范围内的小数。\n\n必需的算法任务：\n- 实现上述适应性行走和分类过程。\n- 对每个测试用例，运行 $R$ 次重复实验。在每次重复实验中，按规定独立抽取 $b_1$，$b_2$ 和 $b_N$。对测试用例索引 $i\\in\\{0,1,2,3\\}$（从零开始），使用由 $S_i=S+10\\cdot i$ 设定的种子来初始化一个伪随机数生成器，其中 $S$ 是下面给出的基础种子。在每个测试用例内，使用单个生成器实例顺序抽取所有重复实验的随机变量，以确保确定性。\n- 对于每个测试用例，输出一个数对 $[\\text{neo\\_freq},\\text{sub\\_freq}]$，分别给出被分类为新功能化和亚功能化的重复实验所占的比例。将每个频率四舍五入到 6 位小数。\n\n测试套件：\n- 使用以下 4 个测试用例，参数为 $(r,c,\\mu_b,\\mu_N,R,S)$：\n    1. $r=1.0$, $c=0.1$, $\\mu_b=1.0$, $\\mu_N=0.1$, $R=200$, $S=137$。\n    2. $r=1.0$, $c=0.1$, $\\mu_b=1.0$, $\\mu_N=2.0$, $R=200$, $S=137$。\n    3. $r=0.0$, $c=0.1$, $\\mu_b=1.0$, $\\mu_N=0.1$, $R=200$, $S=137$。\n    4. $r=0.5$, $c=0.2$, $\\mu_b=1.0$, $\\mu_N=1.0$, $R=200$, $S=137$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个双元素列表，顺序与测试套件相同，例如，\"[[a,b],[c,d],[e,f],[g,h]]\"。值 $a,b,c,d,e,f,g,h$ 必须是按上述规定四舍五入后的小数频率。不得打印任何其他文本。", "solution": "问题陈述已经过严格评估，并被认为是有效的。它在科学上植根于理论进化生物学的既定原则，特别是强选择弱突变（SSWM）近似下的基因重复研究。该问题是良定的，所有参数、函数、初始条件和算法程序，包括确定性平局打破规则和伪随机数生成，都得到了严谨而清晰的规定。该模型是自洽的、计算上可行的，并且没有矛盾或歧义。\n\n任务是实现一个适应度景观上适应性行走的计算模拟，以确定一个重复基因对的进化命运。该模拟将针对多个参数集（测试用例）执行，并且对于每个参数集，将在一系列随机重复实验中计算两种特定结果——新功能化和亚功能化——的频率。\n\n模型的核心是基因型及其相关的适应度函数。两个基因拷贝的基因型由一个6维二元向量表示，$x = (x_{11}, x_{12}, x_{1N}, x_{21}, x_{22}, x_{2N}) \\in \\{0,1\\}^6$。这里，$x_{ji}=1$ 表示拷贝 $j \\in \\{1,2\\}$ 拥有功能 $i \\in \\{1,2,N\\}$，其中功能 $1$ 和 $2$ 是祖先亚功能，$N$ 是一个潜在的新功能。重复后的初始状态固定为 $x_{initial} = (1, 1, 0, 1, 1, 0)$，意味着两个拷贝最初都拥有两个祖先亚功能，但没有新功能。\n\n适应度 $W(x)$ 定义为每个功能的收益总和减去维持任何功能活跃拷贝的总成本。适应度函数由下式给出：\n$$\nW(x) \\;=\\; b_1 \\, g(x_{11}+x_{21}) \\;+\\; b_2 \\, g(x_{12}+x_{22}) \\;+\\; b_N \\, g(x_{1N}+x_{2N})\n\\;-\\; c \\sum_{j=1}^{2}\\sum_{i\\in\\{1,2,N\\}} x_{j i}\n$$\n其中 $b_1, b_2, b_N$ 是相应功能的收益系数，$c$ 是每个功能、每个拷贝的成本。函数 $g(s)$ 模拟冗余效应，其中 $s$ 是给定功能的总拷贝数。它定义为 $g(0)=0$, $g(1)=1$, 和 $g(2)=2-r$。参数 $r \\in [0,1]$ 调节上位性水平：$r=0$ 对应于累加收益（无冗余效应），而 $r=1$ 表示完全冗余，即功能的第二个拷贝不提供额外收益。\n\n进化过程被建模为在该适应度景观上的贪婪适应性行走，与 SSWM 机制一致。从初始基因型 $x_{initial}$ 开始，算法以离散步骤进行。在每一步中，评估所有 $6$ 个单突变邻居，这些邻居是因单个比特位翻转 ($x_{ji} \\mapsto 1-x_{ji}$) 而不同的基因型。如果有任何邻居提供适应度增加（$\\Delta W  0$），基因型将转换到具有严格最大适应度增益的邻居。如果出现最大正 $\\Delta W$ 的平局，则通过按索引对 $(j,i)$（其中 $j \\in \\{1,2\\}$，$i \\in \\{1,2,N\\}$）的字典序扫描来打破平局，选择遇到的第一个这样的邻居。此过程重复进行，直到基因型达到一个局部适应度最优点，该最优点定义为没有任何单突变邻居具有更高适应度的状态。\n\n适应度景观本身在重复实验中是随机的。对于给定测试用例中的 $R$ 次重复实验，每次实验的收益系数都从特定的概率分布中抽取。祖先收益 $b_1$ 和 $b_2$ 从形状参数为 $k_b=2$、尺度参数为 $\\theta_b=\\mu_b/k_b$ 的伽马分布中独立抽取，其中 $\\mu_b$ 是指定的平均收益。新功能收益 $b_N$ 从形状参数同样为 $k_b=2$ 但尺度参数为 $\\theta_N=\\mu_N/k_b$ 的伽马分布中抽取，其中 $\\mu_N$ 是其平均值。通过为每个测试用例 $i$ 使用特定种子 $S_i = S + 10 \\cdot i$ 来为伪随机数生成器（PRNG）设定种子，使得这种随机性变得可复现。\n\n在达到局部最优点后，最终的基因型被分为三类之一。设最终状态为 $x_{final}$。我们定义祖先功能覆盖指示符 $y_1=\\mathbf{1}\\{x_{11}+x_{21}\\ge 1\\}$ 和 $y_2=\\mathbf{1}\\{x_{12}+x_{22}\\ge 1\\}$，以及新功能拷贝数 $n_N = x_{1N}+x_{2N}$。\n-   **新功能化**：当且仅当新功能被一个拷贝获得，两个祖先功能在基因对中都得以保留，并且至少有一个拷贝保持了完全的祖先状态（即没有丢失任何一个祖先功能）时，宣告为新功能化：$n_N=1$，且 $y_1=1$，且 $y_2=1$，且 $\\max\\{x_{11}+x_{12}, x_{21}+x_{22}\\} = 2$。\n-   **亚功能化**：当且仅当未获得新功能，两个祖先功能都得以保留，并且每个拷贝都特化为一个祖先功能时，宣告为亚功能化：$n_N=0$，且 $y_1=1$，且 $y_2=1$，且 $x_{11}+x_{12}=1$，且 $x_{21}+x_{22}=1$。\n-   任何其他终点基因型均归类为**皆非**。\n\n每个测试用例的最终输出包含新功能化和亚功能化的经验频率，计算方法为导致每种结果的重复实验次数占总重复实验次数 $R$ 的比例。这些频率必须四舍五入到6位小数。\n\n实现将按以下步骤进行：首先定义一个函数，用于为任意给定的基因型 $x$ 和参数集 $(b_1, b_2, b_N, r, c)$ 计算适应度。第二个函数将封装适应性行走过程，通过迭代地寻找最佳邻居并更新状态，直到达到局部最优点。第三个函数将根据指定规则对最终状态进行分类。主程序将遍历所有测试用例，并对每个用例运行指定数量的重复模拟，汇总结果，并计算所需的频率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef g(s, r):\n    \"\"\"Calculates the per-function redundancy response.\"\"\"\n    if s == 0:\n        return 0.0\n    elif s == 1:\n        return 1.0\n    elif s == 2:\n        return 2.0 - r\n    return 0.0 # Should not be reached with binary genotypes\n\ndef calculate_fitness(x, b_coeffs, r, c):\n    \"\"\"\n    Calculates the organismal fitness for a given genotype.\n    x: genotype vector [x11, x12, x1N, x21, x22, x2N]\n    b_coeffs: benefit coefficients [b1, b2, bN]\n    r: epistasis parameter\n    c: cost parameter\n    \"\"\"\n    b1, b2, bN = b_coeffs\n    \n    # Sum of functions across copies\n    s1 = x[0] + x[3]\n    s2 = x[1] + x[4]\n    sN = x[2] + x[5]\n    \n    benefit = b1 * g(s1, r) + b2 * g(s2, r) + bN * g(sN, r)\n    cost = c * np.sum(x)\n    \n    return benefit - cost\n\ndef classify_outcome(x_final):\n    \"\"\"\n    Classifies the final genotype as neofunctionalization, subfunctionalization, or neither.\n    x_final: The genotype at the local optimum.\n    \"\"\"\n    x11, x12, x1N, x21, x22, x2N = x_final\n    \n    y1 = (x11 + x21) >= 1\n    y2 = (x12 + x22) >= 1\n    nN = x1N + x2N\n    \n    # Neofunctionalization condition\n    anc_sum_copy1 = x11 + x12\n    anc_sum_copy2 = x21 + x22\n    is_neo = (nN == 1) and y1 and y2 and (max(anc_sum_copy1, anc_sum_copy2) == 2)\n    if is_neo:\n        return 'neo'\n        \n    # Subfunctionalization condition\n    is_sub = (nN == 0) and y1 and y2 and (anc_sum_copy1 == 1) and (anc_sum_copy2 == 1)\n    if is_sub:\n        return 'sub'\n        \n    return 'neither'\n\ndef run_simulation(r, c, mu_b, mu_N, R, seed):\n    \"\"\"\n    Runs R replicates of the adaptive walk simulation for a given parameter set.\n    \"\"\"\n    k_b = 2.0\n    theta_b = mu_b / k_b\n    theta_N = mu_N / k_b\n    \n    rng = np.random.default_rng(seed)\n    \n    neo_count = 0\n    sub_count = 0\n    \n    for _ in range(R):\n        # Draw benefit coefficients for this replicate\n        b1, b2 = rng.gamma(shape=k_b, scale=theta_b, size=2)\n        bN = rng.gamma(shape=k_b, scale=theta_N)\n        b_coeffs = [b1, b2, bN]\n        \n        # Initial state\n        x_current = np.array([1, 1, 0, 1, 1, 0], dtype=int)\n        \n        # Adaptive walk\n        while True:\n            current_fitness = calculate_fitness(x_current, b_coeffs, r, c)\n            \n            # Find all neighbors and their delta_W\n            delta_ws = []\n            for i in range(6):\n                x_neighbor = x_current.copy()\n                x_neighbor[i] = 1 - x_neighbor[i]\n                delta_ws.append(calculate_fitness(x_neighbor, b_coeffs, r, c) - current_fitness)\n\n            max_delta_w = max(delta_ws) if delta_ws else -1.0\n\n            if max_delta_w > 0:\n                # Find the first neighbor that achieves this max_delta_w\n                for i in range(6):\n                    if np.isclose(delta_ws[i], max_delta_w):\n                        x_neighbor_to_move = x_current.copy()\n                        x_neighbor_to_move[i] = 1 - x_neighbor_to_move[i]\n                        x_current = x_neighbor_to_move\n                        break # Move and continue the walk\n            else:\n                # Local optimum reached\n                break\n        \n        x_final = x_current\n        outcome = classify_outcome(x_final)\n        \n        if outcome == 'neo':\n            neo_count += 1\n        elif outcome == 'sub':\n            sub_count += 1\n            \n    neo_freq = neo_count / R\n    sub_freq = sub_count / R\n    \n    return [neo_freq, sub_freq]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Parameters: (r, c, mu_b, mu_N, R, S)\n    test_cases = [\n        (1.0, 0.1, 1.0, 0.1, 200, 137),\n        (1.0, 0.1, 1.0, 2.0, 200, 137),\n        (0.0, 0.1, 1.0, 0.1, 200, 137),\n        (0.5, 0.2, 1.0, 1.0, 200, 137),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        r, c, mu_b, mu_N, R, S = case\n        seed = S + 10 * i\n        result = run_simulation(r, c, mu_b, mu_N, R, seed)\n        results.append(result)\n\n    # Format output as specified\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2712820"}]}