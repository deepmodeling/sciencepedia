{"hands_on_practices": [{"introduction": "第一个练习是理解生灭模型的基石。我们将推导基因家族的绝灭概率，这是由基因重复率（$\\lambda$）和丢失率（$\\mu$）之间的相互作用决定的一个基本量。掌握这个推导[@problem_id:2694516]，能让你深入理解该过程的核心动态，也是在处理更复杂应用之前必不可少的第一步。", "problem": "考虑一个连续时间线性生灭分支过程，该过程用于模拟一个基因家族的大小。每个基因拷贝以单位拷贝速率 $\\lambda > 0$（基因复制）独立地进行复制，并以单位拷贝速率 $\\mu > 0$（基因丢失）被丢失。假设这些速率随时间恒定，谱系在过程历史的条件下独立演化（分支特性），并且除了通过复制外，没有来自家族外部的新增基因。令 $t \\ge 0$ 表示时间，并假设该家族在时间 $t=0$ 时起始有 $i \\in \\mathbb{N}$ 个拷贝。定义 $q_{1}(t)$ 为从时间 $0$ 的单个拷贝开始，到时间 $t$ 时基因家族灭绝（大小为 $0$）的概率。\n\n仅从过程的马尔可夫性质和后代谱系的独立性出发，在 $\\lambda \\ne \\mu$ 的假设下，推导出 $q_{1}(t)$ 的封闭形式表达式。然后，利用分支特性，将从 $i$ 个拷贝开始到时间 $t$ 时的灭绝概率 $q_{i}(t)$ 用 $q_{1}(t)$ 来表示。提供一个关于 $\\lambda$、$\\mu$、$t$ 和 $i$ 的 $q_{i}(t)$ 的单一封闭形式解析表达式。无需进行数值计算或四舍五入，最终表达式中不应包含任何单位。", "solution": "问题陈述描述了一个连续时间线性生灭过程，这是随机理论中的一个标准模型。该问题具有科学依据，提法明确，客观，并包含了获得唯一解所需的所有信息。这是一个有效的数学生物学问题。\n\n令 $N(t)$ 表示在时间 $t$ 的基因拷贝数。我们需要求出在给定初始拷贝数为 $i$ 的情况下，到时间 $t$ 时灭绝的概率，我们将其记为 $q_{i}(t) = P(N(t) = 0 | N(0) = i)$。参数为单位拷贝复制速率 $\\lambda > 0$ 和单位拷贝丢失速率 $\\mu > 0$，并有约束条件 $\\lambda \\ne \\mu$。\n\n首先，我们推导从单个拷贝开始的灭绝概率 $q_{1}(t)$ 的表达式。我们可以通过考虑过程在一个无穷小时间间隔 $\\Delta t$ 内的演化，来建立 $q_{1}(t)$ 的微分方程。根据全概率定律，对区间 $[0, \\Delta t)$ 内发生的事件进行条件化：\n$q_{1}(t + \\Delta t) = P(N(t+\\Delta t)=0 | N(0)=1)$。\n\n$[0, \\Delta t)$ 内的事件有：\n1.  发生一次复制，概率为 $\\lambda \\Delta t + o(\\Delta t)$，产生 $2$ 个拷贝。根据分支特性和时间同质性，要使家族在时间 $t+\\Delta t$ 前灭绝，两个独立的谱系必须在剩余的时间 $t$ 内都灭绝。此事件的概率为 $(q_1(t))^2$。\n2.  发生一次丢失，概率为 $\\mu \\Delta t + o(\\Delta t)$，产生 $0$ 个拷贝。家族已经灭绝，所以灭绝概率为 $1$。\n3.  没有事件发生，概率为 $1 - (\\lambda + \\mu)\\Delta t + o(\\Delta t)$。家族仍有 $1$ 个拷贝。要使其在时间 $t+\\Delta t$ 前灭绝，这个单一谱系必须在剩余的时间 $t$ 内灭绝。该概率为 $q_1(t)$。\n\n结合这些可能性，我们写出：\n$$ q_{1}(t+\\Delta t) = (\\lambda \\Delta t) [q_{1}(t)]^2 + (\\mu \\Delta t) \\cdot 1 + [1 - (\\lambda + \\mu)\\Delta t] q_{1}(t) + o(\\Delta t) $$\n整理各项：\n$$ \\frac{q_{1}(t+\\Delta t) - q_{1}(t)}{\\Delta t} = \\lambda [q_{1}(t)]^2 - (\\lambda + \\mu) q_{1}(t) + \\mu + \\frac{o(\\Delta t)}{\\Delta t} $$\n当 $\\Delta t \\to 0$ 时取极限，我们得到常微分方程：\n$$ \\frac{dq_{1}}{dt} = \\lambda q_{1}^2 - (\\lambda + \\mu)q_{1} + \\mu $$\n这是一个黎卡提方程（Riccati equation）。方程右边是关于 $q_1$ 的二次式，可以进行因式分解。方程 $\\lambda x^2 - (\\lambda + \\mu)x + \\mu = 0$ 的根是 $x=1$ 和 $x=\\mu/\\lambda$。因此，方程可写为：\n$$ \\frac{dq_{1}}{dt} = \\lambda (q_{1} - 1)(q_{1} - \\frac{\\mu}{\\lambda}) $$\n初始条件是在时间 $t=0$ 时，家族包含一个拷贝，因此并未灭绝。所以，$q_{1}(0) = P(N(0)=0 | N(0)=1) = 0$。\n\n我们求解这个可分离变量的微分方程：\n$$ \\frac{dq_{1}}{(q_{1} - 1)(q_{1} - \\frac{\\mu}{\\lambda})} = \\lambda dt $$\n对左侧使用部分分式分解，其中 $\\frac{1}{(x-1)(x-\\mu/\\lambda)} = \\frac{A}{x-1} + \\frac{B}{x-\\mu/\\lambda}$，我们得到 $A = \\frac{1}{1-\\mu/\\lambda} = \\frac{\\lambda}{\\lambda-\\mu}$ 和 $B = \\frac{1}{\\mu/\\lambda-1} = \\frac{\\lambda}{\\mu-\\lambda}$。因为 $\\lambda \\ne \\mu$，所以这些系数是良定义的。\n$$ \\int \\left( \\frac{\\lambda/(\\lambda-\\mu)}{q_{1}-1} - \\frac{\\lambda/(\\lambda-\\mu)}{q_{1}-\\mu/\\lambda} \\right) dq_{1} = \\int \\lambda dt $$\n$$ \\frac{1}{\\lambda-\\mu} \\left[ \\ln|q_{1}-1| - \\ln|q_{1}-\\mu/\\lambda| \\right] = t + C $$\n其中 $C$ 是积分常数。\n$$ \\ln\\left|\\frac{q_{1}-1}{q_{1}-\\mu/\\lambda}\\right| = (\\lambda - \\mu)t + C' $$\n使用初始条件 $q_{1}(0) = 0$：\n$$ \\ln\\left|\\frac{0-1}{0-\\mu/\\lambda}\\right| = C' \\implies \\ln\\left|\\frac{\\lambda}{\\mu}\\right| = C' $$\n因为 $\\lambda > 0$ 且 $\\mu > 0$，我们有 $C' = \\ln(\\lambda/\\mu)$。\n将 $C'$ 代回：\n$$ \\ln\\left|\\frac{q_{1}-1}{q_{1}-\\mu/\\lambda}\\right| = (\\lambda - \\mu)t + \\ln(\\frac{\\lambda}{\\mu}) $$\n由于 $q_{1}(t)$ 是一个从未灭绝状态开始的概率，对于有限的 $t>0$，有 $0 \\le q_{1}(t)  1$。因此，$(q_{1}-1)$ 是负的。项 $(q_{1}-\\mu/\\lambda)$ 也是负的（因为 $q_1(t)$ 从 $0$ 逼近其较小的稳态值），所以它们的比值为正。我们可以去掉绝对值符号。\n$$ \\frac{q_{1}-1}{q_{1}-\\mu/\\lambda} = \\exp((\\lambda - \\mu)t) \\cdot \\frac{\\lambda}{\\mu} $$\n现在我们求解 $q_{1}(t)$：\n$$ \\mu(q_{1}-1) = \\lambda(q_{1}-\\mu/\\lambda)\\exp((\\lambda - \\mu)t) $$\n$$ \\mu q_{1} - \\mu = (\\lambda q_{1} - \\mu)\\exp((\\lambda - \\mu)t) $$\n$$ (\\mu - \\lambda\\exp((\\lambda - \\mu)t))q_{1} = \\mu - \\mu\\exp((\\lambda - \\mu)t) $$\n$$ q_{1}(t) = \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} $$\n这就是从一个拷贝开始的灭绝概率的封闭形式表达式。\n\n接下来，我们求从 $i$ 个拷贝开始时的灭绝概率 $q_{i}(t)$。问题指明了谱系是独立演化的（分支特性）。因此，在 $t=0$ 时从 $i$ 个拷贝开始，等价于开始 $i$ 个独立的生灭过程，每个过程都由单个拷贝引发。要使整个家族在时间 $t$ 灭绝，这 $i$ 个独立的谱系中的每一个都必须在时间 $t$ 前灭绝。\n这个复合事件的概率是各个独立事件概率的乘积：\n$$ q_{i}(t) = P(\\text{谱系 } 1 \\text{ 灭绝}) \\times \\dots \\times P(\\text{谱系 } i \\text{ 灭绝}) $$\n$$ q_{i}(t) = [q_{1}(t)]^i $$\n最后，我们将 $q_{1}(t)$ 的表达式代入，得到 $q_{i}(t)$ 的单一封闭形式表达式：\n$$ q_{i}(t) = \\left( \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} \\right)^i $$\n该表达式给出了一个从 $i$ 个成员开始的基因家族，在时间 $t$ 前灭绝的概率，它是复制速率 $\\lambda$、丢失速率 $\\mu$、时间 $t$ 和初始大小 $i$ 的函数。", "answer": "$$\\boxed{\\left( \\frac{\\mu(1 - \\exp((\\lambda-\\mu)t))}{\\mu - \\lambda\\exp((\\lambda-\\mu)t)} \\right)^{i}}$$", "id": "2694516"}, {"introduction": "理论模型必须谨慎地应用于真实世界的数据，而这些数据往往会受到观测偏差的影响。这个练习[@problem_id:2694480]探讨了比较基因组学中一个关键问题：确定性偏误（ascertainment bias），即我们的分析常常集中于那些存活至今的基因家族。你将运用对模型动态的理解，来量化这种抽样偏差如何系统性地扭曲进化速率的估计值，这对该领域的任何研究人员来说都是至关重要的一课。", "problem": "一个基因家族沿着一个具有两个分类单元的物种树演化，在过去的 $t$ 时刻发生了一次物种形成事件，产生了两个长度均为 $t$ 的后代谱系。在物种形成节点处，该家族恰好有一个基因拷贝，从那时起，每个后代谱系都作为一个连续时间线性生死过程独立演化，其每个拷贝的复制速率为 $\\lambda$，每个拷贝的丢失速率为 $\\mu$，且 $\\lambda  \\mu$（一个亚临界状态）。基因拷贝数为整数值，并根据线性生死过程的分支特性进行演化。\n\n在比较基因组学中，一种常见的确定实践是只保留那些在两个现存分类单元中至少一个里存在的基因家族。假设我们分析了一个非常大的此类已确定家族的集合，并通过将跨家族的平均每个分类单元的基因数与生死过程的无条件均值相匹配来朴素地估计 $\\lambda$，而忽略了确定过程。具体来说，令 $\\bar{n}$ 表示所有家族中 $(N_A + N_B)/2$ 的经验平均值，其中 $N_A$ 和 $N_B$ 是两个分类单元中的现存拷贝数。净增长率的朴素估计量为 $\\hat{r}_{\\text{naive}} = \\frac{1}{t} \\ln(\\bar{n})$，复制速率的朴素估计量为 $\\hat{\\lambda}_{\\text{naive}} = \\mu + \\hat{r}_{\\text{naive}}$。相比之下，真实的复制速率是 $\\lambda$。\n\n从线性生死过程和 Kolmogorov 向前方程的核心定义出发，推导一个从单个拷贝开始的谱系在时间 $t$ 前灭绝的概率 $p_0(t)$，以及在时间 $t$ 的拷贝数的无条件均值 $m(t)$。利用这些结果，在至少一个分类单元保留了该家族的确定条件下，计算朴素估计量的大样本期望，并由此获得渐近偏差 $\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] - \\lambda$ 作为 $\\lambda$、$\\mu$ 和 $t$ 的闭式函数。\n\n最后，当 $\\lambda = 0.1$ 每百万年，$\\mu = 0.3$ 每百万年，以及 $t = 10$ 百万年时，对此偏差进行数值评估。报告以“每百万年”为单位的偏差数值，四舍五入到四位有效数字。在最终的方框答案中不要包含单位。", "solution": "该问题是有效的。这是一个数理演化生物学中的适定问题，它基于生死过程的标准理论，并处理了比较基因组学中的一个常见问题，即确定性偏差。所有必要信息都已提供，问题没有科学或逻辑上的缺陷。\n\n解决方案分几步进行：\n1.  对于从单个拷贝开始的线性生死过程，推导其无条件平均基因家族大小 $m(t)$ 和灭绝概率 $p_0(t)$。\n2.  描述确定条件，并计算一个家族被确定的概率。\n3.  在此确定条件下，推导每个分类单元基因数 $\\bar{n}$ 的大样本期望，我们将其记为 $\\bar{n}_{\\text{cond}}$。\n4.  将此结果代入朴素估计量 $\\hat{\\lambda}_{\\text{naive}}$ 的公式中，以求出其大样本期望 $\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}]$。\n5.  计算渐近偏差 $\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] - \\lambda$。\n6.  使用所提供的参数值对偏差进行数值评估。\n\n令 $N(t)$ 为单个谱系在时间 $t$ 的基因拷贝数。该过程是一个线性生死过程，其每个拷贝的复制（出生）速率为 $\\lambda$，每个拷贝的丢失（死亡）速率为 $\\mu$。初始条件为 $N(0)=1$。\n\n**步骤 1：无条件均值和灭绝概率**\n\n平均拷贝数 $m(t) = \\mathbb{E}[N(t)]$ 根据以下微分方程演化：\n$$\n\\frac{dm(t)}{dt} = (\\lambda - \\mu)m(t)\n$$\n在初始条件 $m(0)=1$ 下，解为：\n$$\nm(t) = \\exp((\\lambda - \\mu)t)\n$$\n在时间 $t$ 前灭绝的概率 $p_0(t) = \\mathbb{P}(N(t)=0 | N(0)=1)$ 可以通过求解该概率的 Kolmogorov 向后方程得到，这是一个 Riccati 方程：\n$$\n\\frac{dp_0(t)}{dt} = \\mu - (\\lambda+\\mu)p_0(t) + \\lambda p_0(t)^2\n$$\n在初始条件 $p_0(0)=0$ 下，解为：\n$$\np_0(t) = \\frac{\\mu(\\exp((\\lambda - \\mu)t) - 1)}{\\lambda\\exp((\\lambda - \\mu)t) - \\mu}\n$$\n这是线性生死过程的一个标准结果。\n\n**步骤 2：确定条件**\n\n令 $N_A$ 和 $N_B$ 为两个后代谱系在时间 $t$ 的拷贝数。两个谱系都在时间 $0$（物种形成事件）时从一个拷贝开始，并独立演化了 $t$ 时间。如果一个家族在至少一个分类单元中存在，它就会被确定，即事件 $\\mathcal{A} = \\{N_A > 0 \\text{ or } N_B > 0\\}$ 发生。\n\n其互补事件 $\\mathcal{A}^c = \\{N_A = 0 \\text{ and } N_B = 0\\}$ 对应于该家族在两个谱系中都灭绝。由于独立性，其概率为：\n$$\n\\mathbb{P}(\\mathcal{A}^c) = \\mathbb{P}(N_A=0) \\mathbb{P}(N_B=0) = p_0(t) \\cdot p_0(t) = p_0(t)^2\n$$\n因此，被确定的概率为：\n$$\n\\mathbb{P}(\\mathcal{A}) = 1 - \\mathbb{P}(\\mathcal{A}^c) = 1 - p_0(t)^2\n$$\n\n**步骤 3：条件平均基因数**\n\n问题将 $\\bar{n}$ 定义为在一个大的已确定家族集合中 $\\frac{N_A + N_B}{2}$ 的经验平均值。在大样本极限下，$\\bar{n}$ 收敛于条件期望 $\\bar{n}_{\\text{cond}} = \\mathbb{E}\\left[\\frac{N_A + N_B}{2} \\Big| \\mathcal{A}\\right]$。根据条件期望的定义：\n$$\n\\bar{n}_{\\text{cond}} = \\frac{1}{2} \\mathbb{E}[N_A + N_B | \\mathcal{A}] = \\frac{1}{2} \\frac{\\mathbb{E}[(N_A + N_B)\\mathbb{I}(\\mathcal{A})]}{\\mathbb{P}(\\mathcal{A})}\n$$\n其中 $\\mathbb{I}(\\mathcal{A})$ 是事件 $\\mathcal{A}$ 的指示函数。分子可以简化为：\n$$\n\\mathbb{E}[(N_A + N_B)\\mathbb{I}(\\mathcal{A})] = \\mathbb{E}[N_A + N_B] - \\mathbb{E}[(N_A + N_B)\\mathbb{I}(\\mathcal{A}^c)]\n$$\n第二项为零，因为在事件 $\\mathcal{A}^c$ 上，我们有 $N_A=0$ 和 $N_B=0$，所以 $N_A+N_B=0$。第一项是无条件期望：\n$$\n\\mathbb{E}[N_A + N_B] = \\mathbb{E}[N_A] + \\mathbb{E}[N_B] = m(t) + m(t) = 2m(t)\n$$\n因此，分子为 $2m(t)$。将其代回 $\\bar{n}_{\\text{cond}}$ 的表达式中：\n$$\n\\bar{n}_{\\text{cond}} = \\frac{1}{2} \\frac{2m(t)}{1 - p_0(t)^2} = \\frac{m(t)}{1 - p_0(t)^2}\n$$\n\n**步骤 4：渐近朴素估计量**\n\n复制速率的朴素估计量由 $\\hat{\\lambda}_{\\text{naive}} = \\mu + \\frac{1}{t}\\ln(\\bar{n})$ 给出。在大样本极限下，其期望可以通过将 $\\bar{n}$ 替换为 $\\bar{n}_{\\text{cond}}$ 求得：\n$$\n\\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] = \\mu + \\frac{1}{t} \\ln(\\bar{n}_{\\text{cond}}) = \\mu + \\frac{1}{t} \\ln\\left(\\frac{m(t)}{1 - p_0(t)^2}\\right)\n$$\n\n**步骤 5：渐近偏差**\n\n渐近偏差是估计量的期望值与真实值 $\\lambda$ 之间的差值：\n$$\n\\text{Bias} = \\mathbb{E}[\\hat{\\lambda}_{\\text{naive}}] - \\lambda = \\mu - \\lambda + \\frac{1}{t} \\ln\\left(\\frac{m(t)}{1 - p_0(t)^2}\\right)\n$$\n代入 $m(t)$ 和 $p_0(t)$ 的表达式：\n$$\n\\text{Bias} = \\mu - \\lambda + \\frac{1}{t} \\ln\\left( \\frac{\\exp((\\lambda - \\mu)t)}{1 - \\left(\\frac{\\mu(\\exp((\\lambda-\\mu)t)-1)}{\\lambda \\exp((\\lambda-\\mu)t)-\\mu}\\right)^2} \\right)\n$$\n这就是所求的偏差的闭式表达式。\n\n**步骤 6：数值评估**\n\n给定 $\\lambda = 0.1$, $\\mu = 0.3$, 和 $t = 10$。单位（每百万年，百万年）是一致的。\n首先，我们计算指数部分：\n$$\n(\\lambda - \\mu)t = (0.1 - 0.3) \\times 10 = -0.2 \\times 10 = -2\n$$\n接下来，我们计算 $p_0(t)$：\n$$\np_0(10) = \\frac{0.3(\\exp(-2)-1)}{0.1\\exp(-2)-0.3}\n$$\n使用 $\\exp(-2) \\approx 0.13533528$：\n$$\np_0(10) \\approx \\frac{0.3(0.13533528 - 1)}{0.1(0.13533528) - 0.3} = \\frac{0.3(-0.86466472)}{0.013533528 - 0.3} = \\frac{-0.259399416}{-0.286466472} \\approx 0.9055113\n$$\n现在我们计算偏差。首先重写偏差公式会更简单：\n$$\n\\text{Bias} = \\mu - \\lambda + \\frac{1}{t} \\left[ \\ln(m(t)) - \\ln(1 - p_0(t)^2) \\right]\n$$\n$$\n\\text{Bias} = \\mu - \\lambda + \\frac{1}{t} \\left[ (\\lambda-\\mu)t - \\ln(1 - p_0(t)^2) \\right]\n$$\n$$\n\\text{Bias} = \\mu - \\lambda + (\\lambda - \\mu) - \\frac{1}{t}\\ln(1-p_0(t)^2) = -\\frac{1}{t}\\ln(1-p_0(t)^2)\n$$\n现在我们代入数值：\n$$\np_0(10)^2 \\approx (0.9055113)^2 \\approx 0.8200508\n$$\n$$\n1 - p_0(10)^2 \\approx 1 - 0.8200508 = 0.1799492\n$$\n$$\n\\ln(1 - p_0(10)^2) \\approx \\ln(0.1799492) \\approx -1.715058\n$$\n最后，我们计算偏差：\n$$\n\\text{Bias} \\approx -\\frac{1}{10} (-1.715058) = 0.1715058\n$$\n四舍五入到四位有效数字，偏差为 $0.1715$。", "answer": "$$\\boxed{0.1715}$$", "id": "2694480"}, {"introduction": "从头开始构建仿真是为随机过程建立直觉的有效方法。在最后的这个练习[@problem_id:2694477]中，你将把生灭过程的数学理论转化为在系统发育树上运行的具体、事件驱动的仿真程序。这项动手编程任务不仅巩固了模型的基本原理（如其马尔可夫性质），还为你提供了可以亲手探索基因家族演化的实用工具。", "problem": "要求您设计并实现一个精确的事件驱动模拟，用于模拟沿着一棵有根分叉树的基因拷贝数的线性生灭过程。每个基因拷贝以恒定的单位拷贝复制率 $\\lambda \\ge 0$ 独立地进行复制，并以恒定的单位拷贝丢失率 $\\mu \\ge 0$ 独立地发生丢失。这个在非负整数上进行的过程是一个连续时间马尔可夫链 (CTMC)，其中如果当前拷贝数是 $n \\in \\{0,1,2,\\dots\\}$，那么总事件率为 $n(\\lambda + \\mu)$，下一个事件是复制的概率为 $\\lambda/(\\lambda+\\mu)$，是丢失的概率为 $\\mu/(\\lambda+\\mu)$。当 $n=0$ 时，过程被吸收。在一个物种形成节点，当前的拷贝数会相同地传递给两个后代分支，从那时起，在给定节点拷贝数的条件下，两个后代谱系独立演化。利用指数等待时间的无记忆性和连续时间马尔可夫链的马尔可夫性质，来证明为什么在以节点处的拷贝数为条件的​​情况下，后代分支可以被独立模拟，以及为什么节点拷贝数是一个充分状态变量。\n\n您的程序必须从上述第一性原理出发，实现以下内容：\n- 一个函数，用于模拟在长度为 $t \\ge 0$ 的单个分支上的连续时间马尔可夫链。模拟从一个整数初始拷贝数 $n_0 \\ge 0$ 开始，使用速率为 $n(\\lambda+\\mu)$ 的精确指数等待时间，并分别以概率 $\\lambda/(\\lambda+\\mu)$ 和 $\\mu/(\\lambda+\\mu)$ 选择事件结果。如果 $t=0$ 或 $n_0=0$，该分支立即终止，不发生任何事件。\n- 一个将此分支模拟扩展到有根分叉树的递归：沿着长度为 $t_{\\mathrm{stem}}$ 的根茎进行模拟，然后在每个物种形成节点将实现的拷贝数相同地传递给两个子节点，独立模拟每个子分支，并持续进行直到到达叶尖。叶尖的输出必须是终止时间点上实现的拷贝数。为确保可复现性，请使用固定的伪随机数生成器种子，其值为 $2025$。\n- 对输出的叶尖拷贝数进行确定性的从左到右聚合，其中“从左到右”指在每次分叉时先访问左子节点再访问右子节点的前序遍历。\n\n您的实现必须是通用的，但您必须在以下包含三棵树和参数集的测试套件上进行演示。在每种情况下，将按从左到右顺序排列的叶尖拷贝数整数列表作为该情况的一个结果进行报告。\n\n测试用例 $1$（具有零长度分支的单次分叉）：\n- 参数：$\\lambda=0.6$，$\\mu=0.2$，$n_0=1$。\n- 树：根茎长度 $t_{\\mathrm{stem}}=0.5$；然后分叉成两个叶尖，分支长度分别为 $0.0$（左）和 $0.7$（右）。\n\n测试用例 $2$（具有两次分叉和以丢失为主导的动力学的不平衡树）：\n- 参数：$\\lambda=0.3$，$\\mu=0.7$，$n_0=2$。\n- 树：根茎长度 $t_{\\mathrm{stem}}=1.0$；然后分叉，左子节点为分支长度 $0.4$ 的叶尖，右子节点为分支长度 $0.3$ 的内部节点；该内部节点再分叉成两个叶尖，分支长度分别为 $0.5$（左）和 $0.2$（右）。\n\n测试用例 $3$（不平衡树上的纯出生 Yule 动力学）：\n- 参数：$\\lambda=1.2$，$\\mu=0.0$，$n_0=1$。\n- 树：根茎长度 $t_{\\mathrm{stem}}=0.0$；然后分叉，左子节点为分支长度 $0.4$ 的叶尖，右子节点为分支长度 $0.1$ 的内部节点；该内部节点再分叉成两个叶尖，分支长度分别为 $0.2$（左）和 $0.3$（右）。\n\n您的程序必须是自包含的（无输入），并使用固定的随机种子 $2025$。最终所需的输出是单行，包含三个用例结果的列表，每个结果本身是按从左到右顺序排列的叶尖拷贝数整数列表。格式必须是单行、无空格、表示为列表的列表的字符串，例如：[[a,b],[c,d,e],[f,g,h]]。输出中不需要物理单位。每个测试用例的答案必须是整数列表，聚合输出必须是一个包含这三个列表（按 1 到 3 的顺序）的单一列表。", "solution": "我们从基因拷贝数线性生灭过程的定义开始，它是在状态空间 $\\{0,1,2,\\dots\\}$ 上的一个连续时间马尔可夫链 (CTMC)。如果 $N(t)$ 表示时间 $t$ 的拷贝数，那么对于 $n \\ge 1$，转移率为 $q_{n,n+1}=n\\lambda$、$q_{n,n-1}=n\\mu$ 和 $q_{n,n}=-n(\\lambda+\\mu)$，而 $q_{0,0}=0$ 表示在零处被吸收。精确模拟基于两个基本性质：\n\n$1.$ 指数等待时间是无记忆的。当过程处于状态 $n \\ge 1$ 时，到下一个事件的等待时间 $\\Delta$ 服从速率为 $n(\\lambda+\\mu)$ 的指数分布，因此对于 $s,t \\ge 0$，有 $\\Pr(\\Delta  s+t \\mid \\Delta  s)=\\Pr(\\Deltat)$。\n\n$2.$ 给定在下一次跳跃时发生一个事件，事件的类型是独立决定的，其概率与速率成正比：复制的概率为 $\\lambda/(\\lambda+\\mu)$，丢失的概率为 $\\mu/(\\lambda+\\mu)$。这源于竞争泊松过程的稀疏化性质：$n$ 个拷贝中的每一个都拥有两个独立的指数时钟，速率分别为单位拷贝 $\\lambda$ 和 $\\mu$，所有 $2n$ 个时钟的并集产生了总速率 $n(\\lambda+\\mu)$；然后根据相对速率选择事件类型。\n\n因此，在长度为 $t \\ge 0$ 的单个有限分支上的事件驱动模拟，通过从 $N(0)=n_0$ 开始迭代以下步骤进行：以速率 $N(\\cdot)(\\lambda+\\mu)$ 抽样一个指数等待时间；如果等待时间将超过剩余的分支时间，则停止并返回当前拷贝数；否则，将时间推进到跳跃点，并以概率 $\\lambda/(\\lambda+\\mu)$ 将拷贝数更新为 $+1$ 或以概率 $\\mu/(\\lambda+\\mu)$ 更新为 $-1$。如果拷贝数达到 $0$，过程被吸收，不再发生任何事件。\n\n为了扩展到分叉树，考虑一个有根树，它有一个长度为 $t_{\\mathrm{stem}}$ 的根茎，后随分叉。该扩展依赖于两个原则：\n\n$1.$ 节点处的马尔可夫充分性。对于在时间 $s$ 出现的节点，该节点下方树上的未来演化仅通过状态 $N(s)$ 依赖于过去的历史。形式上，对于任何 $u \\ge 0$，CTMC 的马尔可夫性质意味着 $\\Pr(N(s+u)=k \\mid \\mathcal{F}_s)=\\Pr(N(s+u)=k \\mid N(s))$，其中 $\\mathcal{F}_s$ 是由截至时间 $s$ 的过程生成的 $\\sigma$-代数。因此，节点的拷贝数是继续过程的充分统计量。\n\n$2.$ 后代谱系的条件独立性。在分叉时间 $s$，控制左后代分支事件的指数时钟集合与控制右后代分支的集合是独立的，因为它们对应于不相交的拷贝集合和不相交的未来时间区间。给定 $N(s)=n$，每个后代分支的初始状态是 $n$，并且两个后代过程由为每个分支构建的独立泊松时钟驱动。因此，对于分别为左右后代路径的任意可测函数 $f$ 和 $g$，有 $\\mathbb{E}[f \\cdot g \\mid N(s)=n]=\\mathbb{E}[f \\mid N(s)=n] \\cdot \\mathbb{E}[g \\mid N(s)=n]$。这验证了在以节点拷贝数为条件的​​情况下独立模拟每个分支，并在物种形成时将节点拷贝数相同地传递给两个子节点的做法是正确的。\n\n算法设计：\n\n$1.$ 单分支模拟器。给定 $(n_0, t, \\lambda, \\mu)$，初始化已用时间 $\\tau=0$ 和 $n=n_0$。如果 $t=0$ 或 $n=0$，返回 $n$。否则，在每一步计算总速率 $r=n(\\lambda+\\mu)$，抽样 $\\delta \\sim \\mathrm{Exponential}(r)$。如果 $\\tau+\\delta \\ge t$，停止并返回 $n$。否则设置 $\\tau \\leftarrow \\tau+\\delta$。抽样一个均匀分布变量 $U \\sim \\mathrm{Uniform}(0,1)$；如果 $U  \\lambda/(\\lambda+\\mu)$，设置 $n \\leftarrow n+1$；否则设置 $n \\leftarrow n-1$。如果 $n=0$，停止并返回 $0$。重复此过程。\n\n$2.$ 树递归。给定一个有根分叉树的规范，其包含一个长度为 $t_{\\mathrm{stem}}$ 的根茎，并且在每个内部节点都有带有分支长度的左、右子边，按以下方式进行。首先，从 $n_0$ 开始，沿着根茎模拟单分支过程，持续时间为 $t_{\\mathrm{stem}}$；将结果拷贝数称为 $n_{\\mathrm{root}}$。在任何具有输入拷贝数 $n_{\\mathrm{in}}$ 的内部节点，沿着左边的分支长度独立模拟，以获得子节点端点的左拷贝数；如果该子节点是叶尖，则记录该拷贝数；如果该子节点本身是一个内部节点，则将该拷贝数传递给它的两个子节点并进行递归。对右子节点进行类似的模拟。在每次分叉时先访问左子节点再访问右子节点的前序遍历定义了报告叶尖拷贝数的确定性从左到右顺序。\n\n$3.$ 随机性与可复现性。所有指数和均匀分布的随机变量均由一个以种子 $2025$ 初始化的伪随机数生成器生成。这确保了每次运行的输出都相同。\n\n正确性证明：\n\n- 单分支模拟器实现了 CTMC 的精确跳跃时间，因为在每个状态 $n$，都以速率 $n(\\lambda+\\mu)$ 抽样指数等待时间，并且事件类型是根据其瞬时概率 $\\lambda/(\\lambda+\\mu)$ 和 $\\mu/(\\lambda+\\mu)$ 来选择的。\n- 节点处的马尔可夫充分性源于 CTMC 的马尔可夫性质：给定当前状态，未来状态的条件分布不依赖于过去。因此，节点拷贝数足以在后代分支上重新启动该过程。\n- 后代谱系的条件独立性是因为，给定 $N(s)=n$，两个后代过程由在不相交的时间域和不相交的拷贝集合上的独立指数时钟集合驱动；根据构造，它们的未来演化在以节点状态为条件的​​情况下是独立的。\n\n测试套件中的边界情况：\n\n- 测试用例 1 包含一个零长度分支 ($t=0.0$)；模拟器必须立即为该叶尖返回输入的节点拷贝数。\n- 测试用例 2 是以丢失为主导的 ($\\mu>\\lambda$)，使得灭绝可能性很高；模拟器必须正确处理在 0 处的吸收，并在适用时将零传播到后代分支。\n- 测试用例 3 是纯出生过程 ($\\mu=0.0$)，用于检验只有复制发生的情况。\n\n输出规范：\n\n- 对于每个测试用例，结果是一个整数列表，等于按从左到右顺序实现的叶尖拷贝数。\n- 程序必须打印单行，其中包含按 1,2,3 顺序排列的三个用例结果的列表，无空格，格式为 [[a,b],[c,d,e],[f,g,h]]。\n\n由于使用了相同的固定种子 $2025$ 并且模拟是精确的，因此对于指定的参数和树，程序的输出是确定性的和可复现的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_branch(n0, t, lam, mu, rng):\n    \"\"\"\n    Exact event-driven simulation of a linear birth-death process on a single branch.\n\n    Parameters:\n        n0 (int): initial copy count at branch start.\n        t (float): branch length (time).\n        lam (float): per-copy duplication rate.\n        mu (float): per-copy loss rate.\n        rng (np.random.Generator): random number generator.\n\n    Returns:\n        int: copy count at the end of the branch.\n    \"\"\"\n    n = int(n0)\n    if t == 0.0 or n == 0:\n        return n\n    total_rate_per_copy = lam + mu\n    # If total_rate_per_copy == 0, no events can occur; return current n.\n    if total_rate_per_copy == 0.0:\n        return n\n    elapsed = 0.0\n    while n > 0:\n        rate = n * total_rate_per_copy\n        # Sample exponential waiting time with mean 1/rate\n        dt = rng.exponential(1.0 / rate)\n        if elapsed + dt >= t:\n            break\n        elapsed += dt\n        # Decide event type\n        if rng.random()  (lam / total_rate_per_copy):\n            n += 1  # duplication\n        else:\n            n -= 1  # loss\n    return n\n\ndef simulate_tree(tree, n0, lam, mu, rng):\n    \"\"\"\n    Simulate the birth-death process on a bifurcating rooted tree.\n    Tree representation:\n        {\n          'stem_length': float,\n          'left': {'branch_length': float, 'node': internal_or_none},\n          'right': {'branch_length': float, 'node': internal_or_none}\n        }\n    Internal node representation (no stem_length):\n        {\n          'left': {'branch_length': float, 'node': internal_or_none},\n          'right': {'branch_length': float, 'node': internal_or_none}\n        }\n    Tips are represented by {'branch_length': ..., 'node': None}.\n\n    Returns:\n        list[int]: tip counts in left-to-right preorder traversal.\n    \"\"\"\n    # Simulate along the stem to get the count at the root bifurcation\n    n_at_root = simulate_branch(n0, tree['stem_length'], lam, mu, rng)\n\n    tip_counts = []\n\n    def recurse(n_in, internal_node):\n        # Simulate left child\n        left = internal_node['left']\n        n_left_end = simulate_branch(n_in, left['branch_length'], lam, mu, rng)\n        if left['node'] is None:\n            tip_counts.append(n_left_end)\n        else:\n            recurse(n_left_end, left['node'])\n        # Simulate right child\n        right = internal_node['right']\n        n_right_end = simulate_branch(n_in, right['branch_length'], lam, mu, rng)\n        if right['node'] is None:\n            tip_counts.append(n_right_end)\n        else:\n            recurse(n_right_end, right['node'])\n\n    root_internal = {'left': tree['left'], 'right': tree['right']}\n    recurse(n_at_root, root_internal)\n    return tip_counts\n\ndef format_no_space_nested_list(nested):\n    \"\"\"\n    Format a (possibly nested) list into a string with no spaces.\n    \"\"\"\n    if isinstance(nested, list):\n        return \"[\" + \",\".join(format_no_space_nested_list(x) for x in nested) + \"]\"\n    else:\n        return str(nested)\n\ndef build_test_cases():\n    # Test case 1\n    case1_tree = {\n        'stem_length': 0.5,\n        'left':  {'branch_length': 0.0, 'node': None},\n        'right': {'branch_length': 0.7, 'node': None},\n    }\n    case1 = {\n        'lam': 0.6,\n        'mu': 0.2,\n        'n0': 1,\n        'tree': case1_tree\n    }\n\n    # Test case 2\n    # Root -> left tip (0.4), right internal (0.3) -> two tips (0.5, 0.2)\n    case2_internal = {\n        'left':  {'branch_length': 0.5, 'node': None},\n        'right': {'branch_length': 0.2, 'node': None}\n    }\n    case2_tree = {\n        'stem_length': 1.0,\n        'left':  {'branch_length': 0.4, 'node': None},\n        'right': {'branch_length': 0.3, 'node': case2_internal},\n    }\n    case2 = {\n        'lam': 0.3,\n        'mu': 0.7,\n        'n0': 2,\n        'tree': case2_tree\n    }\n\n    # Test case 3\n    # Root -> left tip (0.4), right internal (0.1) -> two tips (0.2, 0.3)\n    case3_internal = {\n        'left':  {'branch_length': 0.2, 'node': None},\n        'right': {'branch_length': 0.3, 'node': None}\n    }\n    case3_tree = {\n        'stem_length': 0.0,\n        'left':  {'branch_length': 0.4, 'node': None},\n        'right': {'branch_length': 0.1, 'node': case3_internal},\n    }\n    case3 = {\n        'lam': 1.2,\n        'mu': 0.0,\n        'n0': 1,\n        'tree': case3_tree\n    }\n\n    return [case1, case2, case3]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    # Fixed seed for reproducibility\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for case in test_cases:\n        lam = case['lam']\n        mu = case['mu']\n        n0 = case['n0']\n        tree = case['tree']\n        tip_counts = simulate_tree(tree, n0, lam, mu, rng)\n        results.append(tip_counts)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_no_space_nested_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2694477"}]}