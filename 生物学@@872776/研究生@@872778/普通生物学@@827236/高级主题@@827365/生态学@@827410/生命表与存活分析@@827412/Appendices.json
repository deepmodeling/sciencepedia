{"hands_on_practices": [{"introduction": "理解死亡率模式最直接的方法是追踪一个从出生开始的群体（即队列）。本练习将让你亲手实践，将原始的存活数量数据转换成一个完整的生命表，并计算关键指标，如存活率 ($l_x$) 和特定时期内的预期寿命。这项实践有助于你建立将人口学原始数据转化为存活指标的基础理解。[@problem_id:2811963]", "problem": "一个大小为 $100$ 人的封闭队列在整数年龄 $x \\in \\{0,1,2,3,4,5\\}$ 时被观察，其队列人数为 $\\{n_x\\} = (100,80,61,50,43,40)$，表示在每个年龄 $x$ 开始时的存活人数。考虑对于 $x \\in \\{0,1,2,3,4\\}$ 的一年期年龄区间 $[x,x+1)$。仅使用生存分析和离散时间生命表理论中的基本定义，完成以下任务：\n\n- 将生存函数 $l_x$ 定义为初始队列中在年龄 $x$ 开始时存活的比例，将区间内的死亡人数 $d_x$ 定义为相邻 $l_x$ 值之间的减少量，将给定存活至年龄 $x$ 时在 $[x,x+1)$ 区间内的条件死亡概率定义为 $q_x$，将给定存活至年龄 $x$ 时在 $[x,x+1)$ 区间内的条件生存概率定义为 $p_x$。\n- 假定每个区间内的死亡呈均匀分布（这是一种标准近似，与区间内死亡力恒定相符），因此在每个单位长度区间 $[x,x+1)$ 内的生存人年数满足 $L_x=(l_x+l_{x+1})/2$。\n- 基于所构建的生命表量，根据第一性原理计算在观察窗口 $[0,5)$ 内的出生时预期寿命，该值被解释为该队列中新生儿从出生到 5 岁的预期存活年数。\n\n报告出生时预期寿命的最终值（以年为单位），并将您的答案四舍五入至四位有效数字。请勿在最终的方框答案中包含单位。", "solution": "对问题陈述进行验证。\n\n逐字提取给定条件：\n- 一个大小为 $100$ 人的封闭队列被观察。\n- 整数年龄为 $x \\in \\{0,1,2,3,4,5\\}$。\n- 队列人数为 $\\{n_x\\} = (100,80,61,50,43,40)$，其中 $n_x$ 是在年龄 $x$ 开始时的存活人数。\n- 年龄区间为对于 $x \\in \\{0,1,2,3,4\\}$ 的一年期区间 $[x,x+1)$。\n- 生存函数 $l_x$ 定义为初始队列中在年龄 $x$ 开始时存活的比例。\n- 区间内的死亡人数 $d_x$ 是相邻 $l_x$ 值之间的减少量。\n- 条件死亡概率 $q_x$ 是给定存活至年龄 $x$ 时在 $[x,x+1)$ 内的死亡概率。\n- 条件生存概率 $p_x$ 是给定存活至年龄 $x$ 时在 $[x,x+1)$ 内的生存概率。\n- 假定每个区间内的死亡呈均匀分布（UDD）。\n- 一个区间内的生存人年数为 $L_x=(l_x+l_{x+1})/2$。\n- 目标是计算在观察窗口 $[0,5)$ 内的出生时预期寿命，该值被解释为从出生到 5 岁的预期存活年数。\n- 最终答案必须四舍五入至四位有效数字。\n\n该问题被确定为有效。它在科学上基于人口统计学和生存分析的既定原则。问题提法清晰，提供了计算所需量所必需的所有数据和定义（$n_x$，UDD 假设）。数据是一致的，因为存活人数 $\\{n_x\\}$ 是一个单调不增序列。语言客观而精确。该问题是生命表构建和分析中的一个标准练习。\n\n我们开始解题。\n\n首先，我们根据给定的队列数据构建基本的生命表函数。初始队列大小，即基数，为 $n_0=100$。生存函数 $l_x$ 定义为初始队列中在年龄 $x$ 开始时存活的比例。因此，$l_x = n_x / n_0$。此生命表的基数为 $l_0 = n_0/n_0 = 100/100 = 1$。\n\n对于 $x \\in \\{0,1,2,3,4,5\\}$，$l_x$ 的值为：\n$$l_0 = \\frac{100}{100} = 1.0$$\n$$l_1 = \\frac{80}{100} = 0.8$$\n$$l_2 = \\frac{61}{100} = 0.61$$\n$$l_3 = \\frac{50}{100} = 0.50$$\n$$l_4 = \\frac{43}{100} = 0.43$$\n$$l_5 = \\frac{40}{100} = 0.40$$\n\n根据题目要求，我们还定义了其他基本量，尽管并非所有量都对最终计算是必需的。对于一个以 $l_x$ 人开始的队列，在区间 $[x, x+1)$ 内的死亡人数为 $d_x = l_x - l_{x+1}$。给定存活至年龄 $x$ 时，在 $[x, x+1)$ 区间内的条件死亡概率为 $q_x = d_x/l_x$。条件生存概率为 $p_x = 1 - q_x = l_{x+1}/l_x$。\n\n主要目标是计算在观察窗口 $[0,5)$ 内的出生时预期寿命。这被解释为新生儿从 0 岁到 5 岁的预期存活年数。该量被称为从 0 岁开始的 5 年期临时预期寿命，记作 $e_{0:5\\rceil}$。其计算方法是，将队列在 0 岁至 5 岁之间所经历的总生存人年数，除以队列在 0 岁时的初始人数。\n年龄 $x$ 和 $x+k$ 之间的总生存人年数为 $\\sum_{i=x}^{x+k-1} L_i$。因此，临时预期寿命由下式给出：\n$$e_{0:5\\rceil} = \\frac{\\sum_{x=0}^{4} L_x}{l_0}$$\n此处，$L_x$ 代表在年龄区间 $[x,x+1)$ 内的生存人年数。题目指定了公式 $L_x = (l_x+l_{x+1})/2$，这是在假定每个一年期区间内死亡呈均匀分布（UDD）下的标准计算方法。\n\n我们现在计算从 $x=0$ 到 $x=4$ 的每个区间的 $L_x$ 值：\n$$L_0 = \\frac{l_0 + l_1}{2} = \\frac{1.0 + 0.8}{2} = \\frac{1.8}{2} = 0.9$$\n$$L_1 = \\frac{l_1 + l_2}{2} = \\frac{0.8 + 0.61}{2} = \\frac{1.41}{2} = 0.705$$\n$$L_2 = \\frac{l_2 + l_3}{2} = \\frac{0.61 + 0.50}{2} = \\frac{1.11}{2} = 0.555$$\n$$L_3 = \\frac{l_3 + l_4}{2} = \\frac{0.50 + 0.43}{2} = \\frac{0.93}{2} = 0.465$$\n$$L_4 = \\frac{l_4 + l_5}{2} = \\frac{0.43 + 0.40}{2} = \\frac{0.83}{2} = 0.415$$\n\n接下来，我们将这些值相加，求出从 0 岁到 5 岁的总生存人年数：\n$$\\sum_{x=0}^{4} L_x = L_0 + L_1 + L_2 + L_3 + L_4$$\n$$\\sum_{x=0}^{4} L_x = 0.9 + 0.705 + 0.555 + 0.465 + 0.415 = 3.04$$\n\n计算出的总和是一个精确值，源自精确的有理数。最后，我们计算指定窗口内的预期寿命：\n$$e_{0:5\\rceil} = \\frac{\\sum_{x=0}^{4} L_x}{l_0} = \\frac{3.04}{1.0} = 3.04$$\n\n题目要求答案四舍五入至四位有效数字。精确值为 $3.04$，它有三位有效数字。为了将此值表示为四位有效数字，我们必须在末尾添加一个零，得到 $3.040$。\n在观察窗口 $[0,5)$ 内的出生时预期寿命为 $3.040$ 年。", "answer": "$$\n\\boxed{3.040}\n$$", "id": "2811963"}, {"introduction": "在现实中，完整追踪一个队列直到所有成员死亡往往是不切实际的。本练习将介绍一种更常见的方法：基于某一年份收集的“快照”式数据（横截面数据）来构建时期生命表。你将学习如何处理中心死亡率 ($m_x$) 并将其转换为死亡概率 ($q_x$)，这是分析大多数公开人口统计数据时的一项关键技能。[@problem_id:2811952]", "problem": "一项关于某个小型哺乳动物物种的野外研究，记录了在单个日历年内，以一岁为年龄组的年龄结构计数、死亡数和风险人时。假设对于 $x \\in \\{0,1,2,3,4\\}$ 为一年的闭区间，对于 $x=5+$ 为一个开放式区间，每个闭区间内的风险（死亡力）为分段常数，并且在开放式区间内风险为常数。年中计数为 $N_x$，年内观察到的死亡数为 $D_x$，人时暴露量为 $E_x$（单位为人年）。数据如下：\n\n- $x=0$: $(N_0, D_0, E_0) = (\\,950,\\,38,\\,950\\,)$\n- $x=1$: $(N_1, D_1, E_1) = (\\,980,\\,5,\\,980\\,)$\n- $x=2$: $(N_2, D_2, E_2) = (\\,990,\\,4,\\,990\\,)$\n- $x=3$: $(N_3, D_3, E_3) = (\\,1000,\\,6,\\,1000\\,)$\n- $x=4$: $(N_4, D_4, E_4) = (\\,980,\\,10,\\,980\\,)$\n- $x=5+$: $(N_5, D_5, E_5) = (\\,500,\\,50,\\,500\\,)$\n\n使用为每个年龄组定义的中心死亡率 $m_x = D_x / E_x$ 构建一个时期生命表。通过经典的 $a_x$ 调整关系式来近似区间内的死亡概率 $q_x$\n$$\nq_x \\approx \\frac{m_x}{1 + (1-a_x)\\,m_x}\n$$\n对于所有闭合的一年期区间，$a_x = 0.5$。设生命表的基数 $l_0 = 1$。对于每个闭区间，使用生存人年的标准恒等式\n$$\nL_x = l_{x+1} + a_x\\,d_x,\n$$\n其中 $d_x = l_x\\,q_x$。对于 $x=5+$ 的开放式区间，取 $q_{5}=1$ 并假设 5 岁以后的风险为常数。\n\n使用这些要素和假设，计算出生时期望寿命 $e_0$，其中 $e_0 = T_0/l_0$ 且 $T_0$ 是生命表中 0 岁及以上年龄的总生存人年。以年为单位表示你的最终结果，并将答案四舍五入到四位有效数字。", "solution": "题目陈述提出了人口学中的一个标准任务：根据死亡和暴露的横截面数据构建时期生命表。我们必须首先验证问题的完整性。\n\n**问题验证**\n\n给定条件是：\n- 年龄组：$x \\in \\{0, 1, 2, 3, 4\\}$（闭合的一年期区间）和 $x = 5+$（开放式区间）。\n- 每个年龄组 $x$ 的数据：年中计数 $N_x$、死亡数 $D_x$ 和人时暴露量 $E_x$。\n  - $x=0: (N_0, D_0, E_0) = (950, 38, 950)$\n  - $x=1: (N_1, D_1, E_1) = (980, 5, 980)$\n  - $x=2: (N_2, D_2, E_2) = (990, 4, 990)$\n  - $x=3: (N_3, D_3, E_3) = (1000, 6, 1000)$\n  - $x=4: (N_4, D_4, E_4) = (980, 10, 980)$\n  - $x=5+: (N_5, D_5, E_5) = (500, 50, 500)$\n- 定义和假设：\n  - 中心死亡率：$m_x = D_x / E_x$。\n  - 在区间 $[x, x+1)$ 内的死亡概率：$q_x \\approx \\frac{m_x}{1 + (1-a_x)m_x}$。\n  - 分离因子：对于 $x \\in \\{0, 1, 2, 3, 4\\}$，$a_x = 0.5$。\n  - 生命表基数：$l_0 = 1$。\n  - 在 $[x, x+1)$ 内的生存人年：$L_x = l_{x+1} + a_x d_x$。\n  - 对于开放式区间 $x=5+$，陈述中要求“取 $q_5=1$”并“假设 5 岁以后的风险为常数”。\n\n该问题具有科学依据，使用了生命表分析中的标准定义和近似方法。它提法明确且自成体系。在“取 $q_5=1$”这一指令中存在一个微小的歧义。这不应被解释为区间 $[5, 6)$ 的死亡概率，因为这将与问题对开放式组别 $5+$ 的定义相矛盾，而应被解释为一个同义反复的陈述，即在最后的开放式区间 $[5, \\infty)$ 内死亡的概率为 1。在这个最终年龄组中进行计算的操作性假设是“恒定风险”，这意味着 5 岁时的期望寿命是中心死亡率的倒数，即 $e_5 = 1/m_{5+}$。根据这一标准的人口学解释，该问题是完全有效的。我们继续进行求解。\n\n**求解推导**\n\n目标是计算出生时期望寿命 $e_0 = T_0 / l_0$。我们将逐步构建生命表。\n\n**第 1 步：计算中心死亡率 ($m_x$)**\n\n每个年龄组的中心死亡率是 $m_x = D_x / E_x$。\n- $m_0 = \\frac{38}{950} = 0.04$\n- $m_1 = \\frac{5}{980} = \\frac{1}{196} \\approx 0.005102$\n- $m_2 = \\frac{4}{990} = \\frac{2}{495} \\approx 0.004040$\n- $m_3 = \\frac{6}{1000} = 0.006$\n- $m_4 = \\frac{10}{980} = \\frac{1}{98} \\approx 0.010204$\n- $m_{5+} = \\frac{50}{500} = 0.1$\n\n**第 2 步：计算死亡概率 ($q_x$)**\n\n对于闭区间（$x=0$ 到 $4$），我们使用给定的公式，其中 $a_x=0.5$：\n$q_x = \\frac{m_x}{1 + (1-0.5)m_x} = \\frac{m_x}{1 + 0.5m_x}$。\n\n- $q_0 = \\frac{0.04}{1 + 0.5(0.04)} = \\frac{0.04}{1.02} = \\frac{38}{969} \\approx 0.03921569$\n- $q_1 = \\frac{1/196}{1 + 0.5(1/196)} = \\frac{1/196}{1 + 1/392} = \\frac{2}{393} \\approx 0.00508906$\n- $q_2 = \\frac{2/495}{1 + 0.5(2/495)} = \\frac{2/495}{1 + 1/495} = \\frac{2}{496} = \\frac{1}{248} \\approx 0.00403226$\n- $q_3 = \\frac{0.006}{1 + 0.5(0.006)} = \\frac{0.006}{1.003} = \\frac{6}{1003} \\approx 0.00598205$\n- $q_4 = \\frac{1/98}{1 + 0.5(1/98)} = \\frac{1/98}{1 + 1/196} = \\frac{2}{197} \\approx 0.01015228$\n\n对于开放式区间 $5+$，根据定义，最终死亡的概率为 $q_{5+} = 1$。\n\n**第 3 步：构建生命表列 ($l_x$ 和 $d_x$)**\n\n我们从基数 $l_0 = 1$ 开始，迭代计算每个年龄的存活人数 ($l_x$) 和死亡人数 ($d_x = l_x q_x$)。\n\n- 年龄 $0$：$l_0 = 1$。\n  $d_0 = l_0 q_0 = 1 \\times 0.03921569 = 0.03921569$。\n  $l_1 = l_0 - d_0 = 1 - 0.03921569 = 0.96078431$。\n- 年龄 $1$：$l_1 = 0.96078431$。\n  $d_1 = l_1 q_1 = 0.96078431 \\times 0.00508906 = 0.00488950$。\n  $l_2 = l_1 - d_1 = 0.96078431 - 0.00488950 = 0.95589481$。\n- 年龄 $2$：$l_2 = 0.95589481$。\n  $d_2 = l_2 q_2 = 0.95589481 \\times 0.00403226 = 0.00385441$。\n  $l_3 = l_2 - d_2 = 0.95589481 - 0.00385441 = 0.95204040$。\n- 年龄 $3$：$l_3 = 0.95204040$。\n  $d_3 = l_3 q_3 = 0.95204040 \\times 0.00598205 = 0.00569502$。\n  $l_4 = l_3 - d_3 = 0.95204040 - 0.00569502 = 0.94634538$。\n- 年龄 $4$：$l_4 = 0.94634538$。\n  $d_4 = l_4 q_4 = 0.94634538 \\times 0.01015228 = 0.00960683$。\n  $l_5 = l_4 - d_4 = 0.94634538 - 0.00960683 = 0.93673855$。\n\n**第 4 步：计算生存人年 ($L_x$)**\n\n对于闭区间（$x=0$ 到 $4$），公式 $L_x = l_{x+1} + a_x d_x$ 在 $a_x = 0.5$ 的条件下等价于 $L_x = 0.5 (l_x + l_{x+1})$。\n- $L_0 = 0.5 (l_0 + l_1) = 0.5 (1 + 0.96078431) = 0.98039216$。\n- $L_1 = 0.5 (l_1 + l_2) = 0.5 (0.96078431 + 0.95589481) = 0.95833956$。\n- $L_2 = 0.5 (l_2 + l_3) = 0.5 (0.95589481 + 0.95204040) = 0.95396761$。\n- $L_3 = 0.5 (l_3 + l_4) = 0.5 (0.95204040 + 0.94634538) = 0.94919289$。\n- $L_4 = 0.5 (l_4 + l_5) = 0.5 (0.94634538 + 0.93673855) = 0.94154197$。\n\n对于开放式区间 $5+$，恒定风险率 $\\mu_{5+}$ 的假设意味着中心死亡率 $m_{5+}$ 是该风险的一个估计量，即 $m_{5+} \\approx \\mu_{5+}$。达到 5 岁者的期望寿命为 $e_5 = 1/\\mu_{5+} \\approx 1/m_{5+}$。5 岁以上的总生存人年为 $L_{5+} = T_5 = l_5 e_5$。\n- $L_{5+} = l_5 / m_{5+} = 0.93673855 / 0.1 = 9.3673855$。\n\n**第 5 步：计算总生存人年 ($T_x$)**\n\n年龄 $x$ 及以上的总生存人年是 $T_x = \\sum_{y=x}^{\\omega} L_y$，其中 $\\omega$ 表示最后一个年龄组。我们通过从最高年龄向下求和来计算这个值。\n- $T_5 = L_{5+} = 9.3673855$。\n- $T_4 = L_4 + T_5 = 0.94154197 + 9.3673855 = 10.30892747$。\n- $T_3 = L_3 + T_4 = 0.94919289 + 10.30892747 = 11.25812036$。\n- $T_2 = L_2 + T_3 = 0.95396761 + 11.25812036 = 12.21208797$。\n- $T_1 = L_1 + T_2 = 0.95833956 + 12.21208797 = 13.17042753$。\n- $T_0 = L_0 + T_1 = 0.98039216 + 13.17042753 = 14.15081969$。\n\n**第 6 步：计算出生时期望寿命 ($e_0$)**\n\n出生时期望寿命是 $e_0 = T_0 / l_0$。由于基数 $l_0 = 1$，我们有 $e_0 = T_0$。\n$e_0 = 14.15081969$ 年。\n\n题目要求将结果四舍五入到四位有效数字。\n$e_0 \\approx 14.15$。", "answer": "$$\n\\boxed{14.15}\n$$", "id": "2811952"}, {"introduction": "生命表为我们提供了对存活情况的描述，而参数模型则能让我们用几个参数来总结存活模式并进行预测。本练习将指导你使用非线性最小二乘法，将经典的衰老模型——Gompertz模型——拟合到存活数据上。这将帮助你跨越从描述性分析到推断性建模的鸿沟。[@problem_id:2811928]", "problem": "您将获得一个队列在整数年龄处的离散观测存活率值，您必须使用非线性最小二乘法 (NLS) 在存活率尺度上拟合一个参数化风险模型。其生物学背景是 Gompertz 风险，这在存活分析中常用。该风险函数由两个正参数指定：一个初始风险水平和一个老化率。用作起点的核心定义如下。风险函数 $\\,\\mu(x)\\,$ 由关系式 $\\,\\mu(x) = -\\dfrac{d}{dx}\\log S(x)\\,$ 定义，其中 $\\,S(x)\\,$ 是年龄 $\\,x\\,$ 的存活函数，且 $\\,S(x)\\in(0,1]\\,$ 是一个满足 $\\,S(0)=1\\,$ 的非增函数。对于 Gompertz 模型，风险函数为 $\\,\\mu(x)=\\alpha e^{\\beta x}\\,$, 其中 $\\,\\alpha0\\,$ 且 $\\,\\beta0\\,$。您必须推导由此风险所隐含的相应存活函数 $\\,S(x)\\,$，然后通过在存活率尺度上最小化残差平方和来拟合参数 $\\,(\\alpha,\\beta)\\,$。\n\n具体而言，对于给定的年龄数据集 $\\,\\{x_i\\}_{i=0}^{n}\\,$ 和观测存活率值 $\\,\\{S_i\\}_{i=0}^{n}\\,$（其中 $\\,S_i=S(x_i)\\,$），您必须求解以下关于 $\\,\\alpha0\\,$ 和 $\\,\\beta0\\,$ 的无约束最小化问题：最小化\n$$\n\\sum_{i=0}^{n} \\left(S_i - \\widehat{S}(x_i;\\alpha,\\beta)\\right)^2,\n$$\n其中 $\\,\\widehat{S}(x;\\alpha,\\beta)\\,$ 是由风险 $\\,\\mu(x)=\\alpha e^{\\beta x}\\,$ 所隐含的存活函数，从基本关系 $\\,\\mu(x) = -\\dfrac{d}{dx}\\log S(x)\\,$ 推导得出。您必须强制 $\\,\\alpha0\\,$ 且 $\\,\\beta0\\,$。\n\n您的程序必须为以下三个测试用例解决此问题，每个用例都具有整数年龄 $\\,x\\in\\{0,1,2,3,4,5\\}\\,$ 和指定的存活率值。所有存活率值都必须视为 $[0,1]$ 上的小数（绝不能是百分比）。\n\n- 测试用例 A (经验数据)：年龄 $\\,x\\in\\{0,1,2,3,4,5\\}\\,$，观测存活率值为\n$$\n\\{S_0,S_1,S_2,S_3,S_4,S_5\\}=\\{1.0,\\,0.9,\\,0.78,\\,0.61,\\,0.45,\\,0.30\\}.\n$$\n\n- 测试用例 B (模型生成，精确值)：年龄 $\\,x\\in\\{0,1,2,3,4,5\\}\\,$，数据精确地由参数为 $\\,\\alpha=0.2\\,$ 和 $\\,\\beta=0.3\\,$ 的 Gompertz 风险在这些年龄处生成。具体来说，使用推导出的 $\\,\\widehat{S}(x;\\alpha,\\beta)\\,$ 在 $\\,x\\in\\{0,1,2,3,4,5\\}\\,$ 且 $\\,(\\alpha,\\beta)=(0.2,0.3)\\,$ 时进行求值来构建存活率值，并将这些值视为待观测的 $\\,\\{S_i\\}\\,$，然后使用 NLS 将其拟合回模型。\n\n- 测试用例 C (模型生成，近指数)：年龄 $\\,x\\in\\{0,1,2,3,4,5\\}\\,$，数据精确地由参数为 $\\,\\alpha=0.1\\,$ 和 $\\,\\beta=0.01\\,$ 的 Gompertz 风险在这些年龄处生成。与测试用例 B 一样，使用推导出的 $\\,\\widehat{S}(x;\\alpha,\\beta)\\,$ 在 $\\,x\\in\\{0,1,2,3,4,5\\}\\,$ 且 $\\,(\\alpha,\\beta)=(0.1,0.01)\\,$ 时构建存活率值，然后通过 NLS 拟合模型。\n\n实现和算法要求：\n- 从定义 $\\,\\mu(x) = -\\dfrac{d}{dx}\\log S(x)\\,$ 和 $\\,\\mu(x)=\\alpha e^{\\beta x}\\,$ 开始，推导出 $\\,\\widehat{S}(x;\\alpha,\\beta)\\,$，然后按所述在存活率尺度上建立 NLS 目标。\n- 通过例如使用 $\\,\\alpha=\\exp(\\theta_1)\\,$ 和 $\\,\\beta=\\exp(\\theta_2)\\,$ 进行重新参数化，并在 $\\,\\theta_1,\\theta_2\\in\\mathbb{R}\\,$ 上进行优化，来明确地强制 $\\,\\alpha0\\,$ 和 $\\,\\beta0\\,$。\n- 使用适合 NLS 的确定性优化程序。由于目标函数是光滑的，标准的信赖域或 Levenberg-Marquardt 方法是合适的。\n- 数值输出必须四舍五入到 $\\,6\\,$ 位小数。\n- 单位：存活率值为无单位的比例。不使用物理单位和百分比。\n\n最终输出规范：\n- 对于每个测试用例，将拟合的参数对报告为一个双元素列表 $[\\hat{\\alpha},\\hat{\\beta}]$，其中每个值都四舍五入到 $\\,6\\,$ 位小数。\n- 您的程序应生成单行输出，其中包含按 A、B、C 顺序排列的三个拟合参数对的结果，形式为类 JSON 列表。例如，输出格式必须是\n$$\n[[\\hat{\\alpha}_A,\\hat{\\beta}_A],[\\hat{\\alpha}_B,\\hat{\\beta}_B],[\\hat{\\alpha}_C,\\hat{\\beta}_C]]\n$$\n无任何附加文本。确保严格遵守此单行格式，每个浮点数渲染为 $\\,6\\,$ 位小数。\n\n边界和边缘情况覆盖的基本原理：\n- 测试用例 A 提供了一个经验性的、有噪声的场景，用于评估在存活率尺度上的常规拟合。\n- 测试用例 B 提供了一个精确的模型生成场景，用于在没有噪声的情况下评估参数的可辨识性和数值恢复能力。\n- 测试用例 C 提供了一个具有非常小的 $\\,\\beta\\,$ 的近指数风险情况，用于测试当 $\\,\\beta\\to 0^+\\,$ 时的数值稳定性。\n\n您的算法必须在所有三个测试用例上成功，并严格遵守输出格式。", "solution": "问题陈述是有效的。它在存活分析中指定了一项定义明确的任务：使用非线性最小二乘法 (NLS) 将 Gompertz 风险模型拟合到离散的存活数据。模型、定义和目标函数都是该领域的标准，并以数学精度进行指定。该问题具有科学依据、逻辑上一致，并提供了所有必要的数据和约束。三个测试用例设计良好，用于评估拟合过程的稳健性。我现在将开始提供解决方案。\n\n问题的核心是通过将相应的存活函数 $\\widehat{S}(x;\\alpha,\\beta)$ 拟合到一组在年龄 $\\{x_i\\}$ 处的观测存活概率 $\\{S_i\\}$，来估计 Gompertz 风险模型 $\\mu(x) = \\alpha e^{\\beta x}$ 的参数 $\\alpha$ 和 $\\beta$。\n\n首先，我们必须从给定的基本关系推导出存活函数 $\\widehat{S}(x;\\alpha,\\beta)$：\n$$\n\\mu(x) = -\\frac{d}{dx}\\log S(x)\n$$\n通过将此关系式从年龄 0 积分到年龄 x，并强制初始条件 $S(0)=1$（这意味着 $\\log S(0)=0$），我们得到 $\\log S(x)$ 的表达式。设 t 为积分变量。\n$$\n\\int_0^x \\frac{d}{dt}\\log S(t) \\,dt = \\log S(x) - \\log S(0) = \\log S(x)\n$$\n并且，\n$$\n\\log S(x) = \\int_0^x -\\mu(t) \\,dt\n$$\n代入 Gompertz 风险函数 $\\mu(t) = \\alpha e^{\\beta t}$，我们有：\n$$\n\\log S(x) = - \\int_0^x \\alpha e^{\\beta t} \\,dt = -\\alpha \\left[ \\frac{e^{\\beta t}}{\\beta} \\right]_0^x\n$$\n计算该定积分得出：\n$$\n\\log S(x) = -\\frac{\\alpha}{\\beta} \\left( e^{\\beta x} - e^{\\beta \\cdot 0} \\right) = -\\frac{\\alpha}{\\beta} \\left( e^{\\beta x} - 1 \\right)\n$$\n对两边取指数，得到 Gompertz 存活函数：\n$$\n\\widehat{S}(x; \\alpha, \\beta) = \\exp\\left( -\\frac{\\alpha}{\\beta} (e^{\\beta x} - 1) \\right)\n$$\n这就是将要拟合到数据的理论模型函数 $\\widehat{S}(x;\\alpha,\\beta)$。\n\n拟合过程是非线性最小二乘法 (NLS)。我们必须找到参数值 $(\\hat{\\alpha}, \\hat{\\beta})$，以最小化观测存活率值 $S_i$ 与我们的模型 $\\widehat{S}(x_i;\\alpha,\\beta)$ 预测的值之间的残差平方和 (SSR)：\n$$\n\\min_{\\alpha  0, \\beta  0} \\text{SSR}(\\alpha, \\beta) = \\min_{\\alpha  0, \\beta  0} \\sum_{i=0}^{n} \\left(S_i - \\widehat{S}(x_i;\\alpha,\\beta)\\right)^2\n$$\n约束 $\\alpha  0$ 和 $\\beta  0$ 对于模型具有生物学意义至关重要（初始风险和老化率必须为正）。一个强制这些正性约束的标准且稳健的方法是重新参数化模型。令：\n$$\n\\alpha = e^{\\theta_1} \\quad \\text{and} \\quad \\beta = e^{\\theta_2}\n$$\n现在优化是针对无约束的实值参数 $\\theta_1$ 和 $\\theta_2$ 进行的。目标函数变为最小化残差向量 $\\mathbf{r}$ 的平方和，其中每个分量为 $r_i(\\theta_1, \\theta_2) = S_i - \\widehat{S}(x_i; e^{\\theta_1}, e^{\\theta_2})$。\n\n对于数值实现，Levenberg-Marquardt 或信赖域算法是合适的。我们将为此使用 `scipy.optimize.least_squares`。当 $\\beta$ 很小时，项 $(e^{\\beta x} - 1)/\\beta$ 会出现数值稳定性问题。为避免潜在的精度损失，存活函数中指数的参数 $-\\frac{\\alpha}{\\beta}(e^{\\beta x} - 1)$ 计算为 $-\\frac{\\alpha}{\\beta} \\cdot \\text{expm1}(\\beta x)$，使用 `numpy.expm1` 函数，该函数即使对于很小的 $y$ 也能精确计算 $e^y-1$。\n\n该过程应用于三个测试用例中的每一个。对于测试用例 B 和 C，“观测”的存活数据 $\\{S_i\\}$ 首先使用指定的真实参数 $(\\alpha, \\beta)$ 和推导出的存活函数 $\\widehat{S}(x;\\alpha,\\beta)$ 生成。然后将 NLS 过程应用于这些生成的数据，以验证优化过程能够恢复已知的真实参数，从而证实实现的正确性及其数值稳定性。对于所有情况，一旦找到最优参数 $(\\hat{\\theta}_1, \\hat{\\theta}_2)$，它们将被转换回原始参数空间以获得最终估计值 $(\\hat{\\alpha}, \\hat{\\beta}) = (e^{\\hat{\\theta}_1}, e^{\\hat{\\theta}_2})$。最终报告的值按规定四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves for the Gompertz parameters alpha and beta for three test cases\n    using Nonlinear Least Squares on the survivorship scale.\n    \"\"\"\n\n    def gompertz_survivorship(thetas, x):\n        \"\"\"\n        Calculates the Gompertz survivorship function S(x).\n        Parameters are log-transformed: alpha = exp(theta1), beta = exp(theta2).\n        Uses a numerically stable calculation for the exponent.\n        \"\"\"\n        # Note: thetas = [theta1, theta2]\n        alpha = np.exp(thetas[0])\n        beta = np.exp(thetas[1])\n        \n        # When beta is very small, direct computation of (exp(beta*x)-1)/beta\n        # can be unstable. Using np.expm1(y) for exp(y)-1 offers better precision for small y.\n        # The exponent's argument is -(alpha/beta) * (exp(beta*x) - 1).\n        # We compute this as -(alpha/beta) * np.expm1(beta * x).\n        # This handles the beta - 0 limit correctly, approaching -alpha*x.\n        if np.abs(beta)  1e-9: # Handle the limit case for numerical stability\n            exponent_arg = -alpha * x\n        else:\n            exponent_arg = - (alpha / beta) * np.expm1(beta * x)\n        \n        return np.exp(exponent_arg)\n\n    def residuals(thetas, x_data, s_data):\n        \"\"\"\n        Calculates the residuals between observed and predicted survivorship.\n        This is the objective function for scipy.optimize.least_squares.\n        \"\"\"\n        s_predicted = gompertz_survivorship(thetas, x_data)\n        return s_data - s_predicted\n\n    def solve_case(x_data, s_data, initial_guess_thetas):\n        \"\"\"\n        Performs the NLS optimization for a single data case.\n        \"\"\"\n        result = least_squares(\n            fun=residuals,\n            x0=initial_guess_thetas,\n            args=(x_data, s_data),\n            method='trf', # Trust Region Reflective algorithm, robust for this task.\n            bounds=([-np.inf, -np.inf], [np.inf, np.inf])\n        )\n        \n        # Extract optimal log-parameters and convert back\n        theta1_hat, theta2_hat = result.x\n        alpha_hat = np.exp(theta1_hat)\n        beta_hat = np.exp(theta2_hat)\n        \n        return [alpha_hat, beta_hat]\n\n    # --- Test Case Definitions ---\n\n    # Test Case A: Empirical Data\n    x_a = np.array([0, 1, 2, 3, 4, 5], dtype=float)\n    s_a = np.array([1.0, 0.9, 0.78, 0.61, 0.45, 0.30], dtype=float)\n    # Initial guess based on simple approximation from data\n    # alpha ~ -log(S(1)) = -log(0.9) ~ 0.1\n    # beta is an aging rate, 0.3 is a reasonable guess.\n    initial_guess_a = [np.log(0.1), np.log(0.3)]\n\n    # Test Case B: Model-generated, exact\n    x_b = np.array([0, 1, 2, 3, 4, 5], dtype=float)\n    alpha_b_true, beta_b_true = 0.2, 0.3\n    # S(x) = exp(-(alpha/beta)*(exp(beta*x)-1))\n    s_b = np.exp(-(alpha_b_true / beta_b_true) * np.expm1(beta_b_true * x_b))\n    # Perturbed initial guess to test convergence\n    initial_guess_b = [np.log(0.25), np.log(0.25)]\n\n    # Test Case C: Model-generated, near-exponential (small beta)\n    x_c = np.array([0, 1, 2, 3, 4, 5], dtype=float)\n    alpha_c_true, beta_c_true = 0.1, 0.01\n    s_c = np.exp(-(alpha_c_true / beta_c_true) * np.expm1(beta_c_true * x_c))\n    # Perturbed initial guess\n    initial_guess_c = [np.log(0.11), np.log(0.011)]\n\n    test_cases = [\n        (x_a, s_a, initial_guess_a),\n        (x_b, s_b, initial_guess_b),\n        (x_c, s_c, initial_guess_c),\n    ]\n\n    results = []\n    for x_data, s_data, initial_guess in test_cases:\n        result_pair = solve_case(x_data, s_data, initial_guess)\n        results.append(result_pair)\n\n    # Format the final output string as specified\n    formatted_strings = [f\"[{item[0]:.6f},{item[1]:.6f}]\" for item in results]\n    print(f\"[[{','.join(formatted_strings)}]]\")\n\nsolve()\n```", "id": "2811928"}]}