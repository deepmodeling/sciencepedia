{"hands_on_practices": [{"introduction": "碳水化合物的巨大生物学功能部分源于其惊人的结构多样性。这种多样性的基础在于其单体（单糖）的立体化学。本练习将引导你从第一性原理出发，通过分析一个典型的醛己糖中的手性中心，来量化这种固有的复杂性。通过此练习，你将掌握应用立体化学基本规则（例如 $2^n$ 法则）来预测和分类同分异构体的核心技能 [@problem_id:2781394]。", "problem": "开链醛己糖是一种单糖，其在碳 $C_1$ 处有一个醛基，并具有由6个碳原子（$C_1$ 到 $C_6$）组成的线性骨架。在开链醛己糖的开链形式中，立体生成（手性）中心位于 $C_2$、$C_3$、$C_4$ 和 $C_5$。假设为标准价态且不发生取代基重排；仅关注开链形式的构型立体化学（忽略在异头中心的环化和异头物形成）。\n\n从立体化学和对称性的基本原理出发（立体生成中心的定义、对映异构体是互为镜像但不能重叠的，需要在每个立体生成中心进行构型翻转、非对映异构体是除对映异构体之外的立体异构体，以及内镜面可通过产生内消旋体来减少不同立体异构体数量的标准），推导开链醛己糖的不同开链立体异构体的总数。通过分析 $C_1$（醛基）和 $C_6$（伯醇）处官能团的不等价性以及取代基的线性序列所施加的对称性约束，论证是否存在任何可能的内消旋体。\n\n然后：\n- 将总集合划分为对映异构体对，并确定此类对的数量。\n- 计算所有不同开链立体异构体之间的无序非对映异构体对的数量（即，所有非对映异构体的不同立体异构体的无序对）。\n- 对于一个固定的参考立体异构体，计算其非对映异构体中，在4个立体生成中心里恰好有 $k$ 个中心构型不同（其中 $k \\in \\{1,2,3\\}$）的数量。\n\n将您的最终答案以一个单行矩阵的形式报告，该矩阵按以下顺序包含6个条目：立体异构体的总数、对映异构体对的数量、无序非对映异构体对的数量，然后是（对于参考立体异构体）$k=1$、$k=2$ 和 $k=3$ 时的三个计数。无需四舍五入。答案无单位。", "solution": "该问题要求对开链醛己糖的立体异构现象进行分析。其基本结构是一个6碳链，在 $C_1$ 处有一个醛基，在 $C_6$ 处有一个伯醇。问题陈述正确地指出了碳原子 $C_2$、$C_3$、$C_4$ 和 $C_5$ 是立体生成（手性）中心。因此，立体生成中心总数为 $n=4$。\n\n首先，我们必须确定可能的立体异构体总数。根据 van 't Hoff 法则，对于一个具有 $n$ 个立体生成中心的分子，其立体异构体的最大数量为 $2^n$。当所有立体异构体都不是内消旋化合物时，可以达到这个最大值。内消旋化合物是一种含有立体生成中心的非手性化合物。其非手性是由于分子内存在对称元素（如对称面），使得该分子与其镜像可以重合。对于一个线性分子，对称面通常要求分子的两端在结构上是相同的。开链醛己糖的通用结构为 $\\text{CHO}-(\\text{CHOH})_4-\\text{CH}_2\\text{OH}$。$C_1$ 处的官能团是醛基（$-CHO$），而链末端的基团是 $C_6$ 所在的伯醇部分（$-CH_2OH$）。由于这两个末端基团不同，该分子从一端到另一端是固有不对称的。无论立体生成中心的构型如何，都无法在分子中画出内对称面。因此，开链醛己糖不可能存在内消旋化合物。在有 $n=4$ 个立体生成中心且无内消旋体的情况下，不同立体异构体的总数恰好为 $N = 2^n = 2^4 = 16$。\n\n其次，我们确定对映异构体对的数量。由于所有16种立体异构体都是手性的（因为不存在内消旋体），每一种都必须有一个不能重叠的镜像，即其对映异构体。因此，这16种立体异构体的集合可以被划分为若干对对映异构体。此类对的数量是立体异构体总数除以2。\n对映异构体对的数量 $= \\frac{N}{2} = \\frac{16}{2} = 8$。\n\n第三，我们计算无序非对映异构体对的数量。一对立体异构体可以是对映异构体对，也可以是非对映异构体对。从一个包含 $N$ 个项目的集合中可以形成的不同立体异构体的无序对的总数由二项式系数 $\\binom{N}{2}$ 给出。\n总对数 $= \\binom{16}{2} = \\frac{16!}{2!(16-2)!} = \\frac{16 \\times 15}{2} = 120$。\n这个120对的总数包括了对映异构体对和非对映异构体对。我们已经确定有8对对映异构体对。其余的对必然是非对映异构体对。\n无序非对映异构体对的数量 $= (\\text{总对数}) - (\\text{对映异构体对的数量}) = 120 - 8 = 112$。\n\n最后，我们考虑一个固定的参考立体异构体，并计算其非对映异构体中，在 $k$ 个立体生成中心处构型不同的数量，其中 $k \\in \\{1, 2, 3\\}$。一个立体异构体由其在 $n=4$ 个手性中心上每一个的具体构型（$R$ 或 $S$）所定义。参考异构体的对映异构体是在所有4个中心上构型都翻转的异构体。非对映异构体是除对映异构体之外的立体异构体，意味着它们的构型在部分（但非全部）手性中心上发生了翻转。\n与参考异构体在 $n=4$ 个中心中恰好有 $k$ 个中心构型不同的非对映异构体的数量，是一个选择哪 $k$ 个中心进行翻转的组合问题。这由二项式系数 $\\binom{n}{k}$ 给出。\n\n对于 $k=1$：在恰好一个立体生成中心上构型不同的非对映异构体数量，由从4个中心中选择1个中心进行翻转的方式数给出。\n$k=1$ 时的数量 $= \\binom{4}{1} = \\frac{4!}{1!(4-1)!} = 4$。\n这些也被称为参考分子的差向异构体。\n\n对于 $k=2$：在恰好两个立体生成中心上构型不同的非对映异构体数量，由从4个中心中选择2个中心进行翻转的方式数给出。\n$k=2$ 时的数量 $= \\binom{4}{2} = \\frac{4!}{2!(4-2)!} = \\frac{4 \\times 3}{2} = 6$。\n\n对于 $k=3$：在恰好三个立体生成中心上构型不同的非对映异构体数量，由从4个中心中选择3个中心进行翻转的方式数给出。这等同于选择1个中心不进行翻转。\n$k=3$ 时的数量 $= \\binom{4}{3} = \\frac{4!}{3!(4-3)!} = 4$。\n\n作为检验，参考异构体的非对映异构体总数是 $k \\in \\{1, 2, 3\\}$ 的和，即 $4+6+4=14$。这与立体异构体总数（$16$）减去参考异构体本身（$1$）及其对映异构体（$1$）的结果一致，确实是 $16-2=14$。\n\n最终结果是：\n- 立体异构体总数：$16$。\n- 对映异构体对的数量：$8$。\n- 无序非对映异构体对的数量：$112$。\n- 在 $k=1$ 个中心处构型不同的非对映异构体数量：$4$。\n- 在 $k=2$ 个中心处构型不同的非对映异构体数量：$6$。\n- 在 $k=3$ 个中心处构型不同的非对映异构体数量：$4$。", "answer": "$$\\boxed{\\begin{pmatrix} 16 & 8 & 112 & 4 & 6 & 4 \\end{pmatrix}}$$", "id": "2781394"}, {"introduction": "单糖单元通过糖苷键连接形成寡糖和多糖，正是这些连接方式的多样性赋予了聚糖复杂的生物学功能。这个练习模拟了自然界的组合逻辑，要求你计算仅用 D-葡萄糖这一种单体可以构建出多少种不同的双糖。这个看似简单的计数问题，实则揭示了糖苷键的形成原理，并让你深刻体会到糖类的结构多样性是如何从几个基本的化学选择中涌现出来的 [@problem_id:2781416]。", "problem": "单一单体D-葡萄糖可形成环状半缩醛，在碳$1$上形成一个具有$\\alpha$和$\\beta$两种可能构型的立体异构异头中心。二糖通过一个O-糖苷键形成，其中供体残基的异头碳$1$与受体残基上某个含羟基的碳上的氧原子发生缩醛化。在水溶液中，D-葡萄糖主要采取吡喃糖环的形式，而还原性二糖在其还原端残基上保留一个可以发生变旋的自由异头碳；这种变旋不被视为形成不同的化合物，因为它不改变共价结构。\n\n仅使用D-吡喃葡萄糖作为供体和受体残基，并计算由以下因素决定的不同结构异构体（而非构象异构体）的数量：\n- 受体残基上的连接位置（限制为O-$2$、O-$3$、O-$4$或O-$6$），以及\n- 参与糖苷键的供体异头碳的$\\alpha$或$\\beta$异头构型，\n\n计算在排除连接两个异头碳的任何糖苷键（即排除$1\\leftrightarrow1$连接）的情况下，可以得到的不同二糖的总数。将两个D-吡喃葡萄糖残基视为除了在糖苷键中作为供体与受体的角色不同之外不可区分的单体，并且不要将仅因颠倒哪个相同残基写在左侧或右侧而不同的物质计为不同。忽略所有仅由围绕糖苷键的构象旋转异构体或椅式翻转产生的差异，并忽略自由还原端的瞬时$\\alpha/\\beta$变旋。\n\n以单个整数形式提供最终计数。不需要单位。不要四舍五入。", "solution": "该问题要求计算在特定规则下，由两个D-吡喃葡萄糖单体可以形成的不同二糖的数量。我们必须首先验证其前提，然后进行系统性枚举。该问题在科学上是合理的、定义明确的，并包含足够的信息以获得唯一解。\n\n让我们解构这种二糖的形成过程。单体单元是D-吡喃葡萄糖。二糖的形成涉及两个这样的单元，一个作为糖基供体，另一个作为糖基受体。\n\n$1$. **供体残基**提供其异头碳，即碳-$1$（$C_1$），以形成糖苷键。问题指明，该异头碳的立体化学是所得二糖的一个决定性特征。糖苷键的两种可能构型是$\\alpha$和$\\beta$。因此，连接的异头构型有$N_{\\text{anomer}} = 2$种选择。\n\n$2$. **受体残基**提供一个羟基（$-\\text{OH}$）以形成糖苷键。在一个D-吡喃葡萄糖分子中，碳$C_1$、$C_2$、$C_3$、$C_4$和$C_6$上都有可用的羟基。问题对连接位置施加了两个限制：\n    a) 受体羟基必须位于以下碳原子之一：$C_2$、$C_3$、$C_4$或$C_6$。这给出了四种可能的羟基：O-$2$、O-$3$、O-$4$或O-$6$。\n    b) 两个异头碳之间的连接（$1 \\leftrightarrow 1$连接）被明确排除。这与第一个限制是一致的，因为受体$C_1$上的羟基不在允许的集合中。\n\n因此，在受体残基上有$N_{\\text{linkage}} = 4$个可能的位置来形成糖苷键。\n\n问题要求计算“不同的结构异构体”，但随后立即澄清这种区分是“由受体残基上的连接位置……和异头构型……决定的”。这是一个操作性定义。根据这个定义，如果两个二糖在糖苷键的异头构型（$\\alpha$对$\\beta$）或供体连接到的受体残基的碳原子（$C_2$、$C_3$、$C_4$或$C_6$）上有所不同，则它们被认为是不同的。\n\n例如，$\\alpha$-D-吡喃葡萄糖基-($1 \\to 4$)-D-吡喃葡萄糖（麦芽糖）和$\\beta$-D-吡喃葡萄糖基-($1 \\to 4$)-D-吡喃葡萄糖（纤维二糖）在键的异头构型上不同，因此被计为不同。麦芽糖和$\\alpha$-D-吡喃葡萄糖基-($1 \\to 6$)-D-吡喃葡萄糖（异麦芽糖）在连接位置上不同，也被计为不同。\n\n不同二糖的总数是每个决定性特征的独立选择数量的乘积。异头构型的选择与连接位置的选择是相互独立的。\n\n不同二糖的总数 = (异头构型的数量) $\\times$ (连接位置的数量)\n设$N$为总数。\n$$N = N_{\\text{anomer}} \\times N_{\\text{linkage}}$$\n代入我们已确定的值：\n$$N = 2 \\times 4$$\n$$N = 8$$\n\n排除$1 \\leftrightarrow 1$连接确保了所有生成的二糖都是还原糖，因为受体残基的异头碳仍然是半缩醛基团的一部分。这在分子中产生了一种内在的不对称性：一个残基是非还原性的糖基单元（一个缩醛），另一个是还原性的葡萄糖单元（一个半缩醛）。因此，这两个残基在结构上是不等价的，不存在因对称性而导致的重复计数。指令“不要将仅因颠倒哪个相同残基写在左侧或右侧而不同的物质计为不同”是一个标准的告诫，旨在避免将同一分子的不同画法视为不同的异构体，并且不需要对结果进行任何除法运算。\n\n这八种不同的二糖是：\n-   $\\alpha(1 \\to 2)$ 和 $\\beta(1 \\to 2)$\n-   $\\alpha(1 \\to 3)$ 和 $\\beta(1 \\to 3)$\n-   $\\alpha(1 \\to 4)$ 和 $\\beta(1 \\to 4)$\n-   $\\alpha(1 \\to 6)$ 和 $\\beta(1 \\to 6)$\n\n每一对代表了对于一个给定的连接位置，两种异头构型的组合。由于有四个可能的连接位置，总数确实为$8$。", "answer": "$$\\boxed{8}$$", "id": "2781416"}, {"introduction": "糖类的二维化学结构图无法完全体现其在三维空间中的动态行为，而这种动态行为对其生物学功能至关重要。糖苷键的构象灵活性主要由两个二面角（$\\phi$ 和 $\\psi$）决定，其能量图景决定了寡糖的优势构象。本练习将指导你采用分子力学中的一个简化模型，通过编程计算来构建一个双糖的势能面，并识别出与实验观测结果相符的稳定构象异构体。这项实践让你得以一窥计算结构生物学的强大能力，理解理论模型如何预测并解释分子的三维结构与性质 [@problem_id:2781427]。", "problem": "要求您根据二面角扭转的第一性原理定义和扭转能量学的标准分子力学表示，实现一个程序。该程序为由两个二面角（$\\phi$ 和 $\\psi$）定义的双糖连接构建一个二维糖苷键扭转能量面，识别该能量面上的不同局部极小值，并评估这些极小值是否在指定的角度容差内对应于一组给定的实验观察到的旋转异构体。您的实现必须是通用的，并且仅依赖于周期性扭转项和简单的耦合项，具体如下所述。最终输出必须是汇总每个测试用例通过或失败状态的单行文本。\n\n基本原理：\n- 两个碳水化合物单体之间的糖苷键可以用两个二面角来描述，通常表示为 $\\phi$ 和 $\\psi$。每个二面角都是一个在 $\\left[-180, 180\\right)$ 度范围内的循环变量。\n- 在分子力学 (MM) 表示中，构象能量作为二面角的函数是周期性的，并且可以很好地通过余弦项的傅里叶级数来近似，这是一个广泛接受的用于表示分子内扭转能量学的模型。\n- 构象旋转异构体对应于势能面上的局部极小值；识别极小值是确定可能构象的一种有原则的替代方法。\n\n要实现的能量模型：\n- 设 $\\theta$ 是一个以度为单位的角度。在进行三角函数求值时，将所有角度转换为弧度。\n- 对于单个二面角 $\\theta$，一个扭转项由下式给出：\n$$\nE_{\\text{tors}}(\\theta) \\;=\\; \\sum_{n \\in \\mathcal{N}} V_n \\,\\bigl(1 - \\cos(n \\,\\theta - \\delta_n)\\bigr),\n$$\n其中 $n$ 是一个正整数周期性， $V_n$ 是一个以千焦耳/摩尔 (kJ/mol) 为单位的振幅， $\\delta_n$ 是一个以弧度为单位的相位偏移。在输入中，振幅 $V_n$ 以 kJ/mol 给出，相位 $\\delta_n$ 以度给出；您的程序必须在使用前将所有度数转换为弧度。表达式 $1 - \\cos(\\cdot)$ 是无量纲的，所以 $E_{\\text{tors}}$ 的单位是 kJ/mol。\n- 对于两个耦合的二面角 $\\phi$ 和 $\\psi$，一个简单的耦合项由下式给出：\n$$\nE_{\\text{coup}}(\\phi,\\psi) \\;=\\; \\sum_{m} V^{(c)}_m \\,\\bigl(1 - \\cos(a_m \\,\\phi + b_m \\,\\psi - \\delta^{(c)}_m)\\bigr),\n$$\n其中 $a_m$ 和 $b_m$ 是整数， $V^{(c)}_m$ 的单位是 kJ/mol， $\\delta^{(c)}_m$ 是以弧度为单位（以度提供，需转换）。总能量为：\n$$\nE(\\phi,\\psi) \\;=\\; E_{\\phi}(\\phi) + E_{\\psi}(\\psi) + E_{\\text{coup}}(\\phi,\\psi).\n$$\n\n计算要求：\n- 在一个规则网格上采样能量，其中 $\\phi \\in \\{-180, -175, \\dots, 175\\}$ 度，$\\psi \\in \\{-180, -175, \\dots, 175\\}$ 度；也就是说，在每个维度的 $\\left[-180, 180\\right)$ 范围内使用 $\\Delta = 5$ 度的步长。计算每个网格点的 $E(\\phi,\\psi)$，单位为 kJ/mol。\n- 在二维环面上（周期性边界条件）识别局部极小值。如果一个网格点的能量严格小于其 $8$ 个直接邻居（在边界处回绕）的能量，则该点为局部极小值。\n- 对附近的极小值进行聚类，以避免多次计算单个势阱。使用环形聚类规则：如果两个极小值 $(\\phi_1,\\psi_1)$ 和 $(\\phi_2,\\psi_2)$ 在两个坐标上的环形距离都 $\\le \\tau_c$ 度，则将它们视为相同。其中，角度差 $\\Delta$ 的环形距离定义为 $\\min\\{|\\Delta|, 360 - |\\Delta|\\}$。使用 $\\tau_c = 15$ 度。\n- 从聚类后的极小值集合中，为每个案例选择能量最低的 $L$ 个不同极小值，与提供的观察到的旋转异构体列表进行比较。\n- 如果预测的极小值 $(\\phi^\\ast,\\psi^\\ast)$ 与观察到的旋转异构体 $(\\phi^{\\text{obs}},\\psi^{\\text{obs}})$ 的两个环形距离 $d(\\phi^\\ast,\\phi^{\\text{obs}})$ 和 $d(\\psi^\\ast,\\psi^{\\text{obs}})$ 都 $\\le \\tau_m$ 度，则认为它们匹配。使用 $\\tau_m = 20$ 度。\n- 对每个案例，返回一个布尔值，指示所有观察到的旋转异构体是否都至少被前 $L$ 个预测的最低能量极小值中的一个所匹配。\n\n单位和数值规格：\n- 在最终报告和匹配标准中，角度必须以度为单位；三角函数求值内部必须使用弧度。\n- 能量单位为千焦耳/摩尔 (kJ/mol)。\n- 最终的布尔值输出是无单位的。\n\n测试套件（四个案例）：\n对于每个案例，给定一组 $\\phi$ 的扭转参数、一组 $\\psi$ 的扭转参数、可选的耦合项、一个用于考虑的不同最低能量极小值数量的 $L$ 值，以及一个待匹配的观察到的旋转异构体列表。\n\n符号表示：\n- 每个 $\\phi$ 扭转项是一个三元组 $(n, V, \\delta)$，其中 $n$ 是整数周期性，振幅 $V$ 以 kJ/mol 为单位，相位 $\\delta$ 以度为单位。\n- 每个 $\\psi$ 扭转项同样是 $(n, V, \\delta)$。\n- 每个耦合项是一个四元组 $(a, b, V, \\delta)$，其中 $a$ 和 $b$ 是整数，振幅 $V$ 以 kJ/mol 为单位，相位 $\\delta$ 以度为单位。\n\n案例 1：\n- $\\phi$ 项： $(3,\\, 2.0,\\, 180)$ 和 $(1,\\, 1.5,\\, 60)$。\n- $\\psi$ 项： $(3,\\, 1.5,\\, 270)$ 和 $(1,\\, 1.8,\\, 90)$。\n- 耦合项： $(1,\\,-1,\\, 0.2,\\, 0)$。\n- $L = 1$。\n- 观察到的旋转异构体： $\\bigl[(60,\\, 90)\\bigr]$。\n\n案例 2：\n- $\\phi$ 项： $(3,\\, 2.0,\\, 180)$ 和 $(1,\\, 1.5,\\, -60)$。\n- $\\psi$ 项： $(3,\\, 1.0,\\, 180)$ 和 $(1,\\, 2.0,\\, 180)$。\n- 耦合项： $(1,\\,-1,\\, 0.1,\\, 0)$。\n- $L = 1$。\n- 观察到的旋转异构体： $\\bigl[(-60,\\, 180)\\bigr]$。\n\n案例 3：\n- $\\phi$ 项： $(3,\\, 2.0,\\, 0)$ 和 $(1,\\, 1.0,\\, 0)$。\n- $\\psi$ 项： $(3,\\, 2.0,\\, 0)$ 和 $(1,\\, 1.0,\\, 0)$。\n- 耦合项： $(1,\\,-1,\\, 0.3,\\, 0)$。\n- $L = 1$。\n- 观察到的旋转异构体： $\\bigl[(0,\\, 0)\\bigr]$。\n\n案例 4：\n- $\\phi$ 项： $(3,\\, 2.0,\\, 180)$ 和 $(2,\\, 0.6,\\, 180)$。\n- $\\psi$ 项： $(3,\\, 2.0,\\, 180)$ 和 $(1,\\, 1.2,\\, -60)$。\n- 耦合项： $(1,\\,-1,\\, 0.3,\\, 0)$。\n- $L = 2$。\n- 观察到的旋转异构体： $\\bigl[(-60,\\, -60),\\ (60,\\, -60)\\bigr]$。\n\n算法约束：\n- 使用网格步长 $\\Delta = 5$ 度。\n- 使用聚类阈值 $\\tau_c = 15$ 度。\n- 使用匹配容差 $\\tau_m = 20$ 度。\n- 使用严格不等式来测试局部极小值与其 $8$ 个邻居。\n- 在两个维度上都使用回绕来解决周期性问题。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的 Python 布尔值列表（例如，\"[True,False,True,True]\"）。该列表必须按测试案例 1 到 4 的顺序排列。", "solution": "该问题陈述经过了严格验证，被确定为科学上合理、定义明确且完整。它提出了结构生物学中的一个标准计算任务：分析双糖连接的势能面以识别稳定构象。解决方案按照指定的方法进行，我将详细说明。\n\n问题的核心是计算和分析由两个二面角 $\\phi$ 和 $\\psi$ 描述的糖苷键的构象能量面 $E(\\phi, \\psi)$。分析过程包括识别低能构象（旋转异构体），并将它们与一组实验观察到的结构进行比较。\n\n总势能 $E(\\phi, \\psi)$ 由三个分量的和给出：\n$$\nE(\\phi,\\psi) \\;=\\; E_{\\phi}(\\phi) + E_{\\psi}(\\psi) + E_{\\text{coup}}(\\phi,\\psi)\n$$\n其中 $E_{\\phi}(\\phi)$ 和 $E_{\\psi}(\\psi)$ 是单个二面角的固有扭转能，而 $E_{\\text{coup}}(\\phi,\\psi)$ 是描述它们之间耦合的项。\n\n单个角度 $\\theta$ 的扭转能被建模为一个傅里叶级数：\n$$\nE_{\\text{tors}}(\\theta) \\;=\\; \\sum_{n \\in \\mathcal{N}} V_n \\,\\bigl(1 - \\cos(n \\,\\theta_r - \\delta_{n,r})\\bigr)\n$$\n在这里，$\\theta_r$ 是以弧度为单位的角度，提供的参数是周期性 $n$、振幅 $V_n$（单位为 kJ/mol）和相位偏移 $\\delta_n$（单位为度），后者必须转换为弧度（$\\delta_{n,r}$）。\n\n耦合能量的定义类似：\n$$\nE_{\\text{coup}}(\\phi,\\psi) \\;=\\; \\sum_{m} V^{(c)}_m \\,\\bigl(1 - \\cos(a_m \\,\\phi_r + b_m \\,\\psi_r - \\delta^{(c)}_{m,r})\\bigr)\n$$\n其中 $\\phi_r$ 和 $\\psi_r$ 是以弧度为单位的二面角，$a_m$ 和 $b_m$ 是整数系数，$V^{(c)}_m$ 是振幅（单位为 kJ/mol），而 $\\delta^{(c)}_m$ 是相位偏移（单位为度），也需要转换为弧度（$\\delta^{(c)}_{m,r}$）。\n\n对于每个测试案例，解决方案通过以下步骤序列执行：\n\n1.  **构象空间的离散化**：将连续的二维 $(\\phi, \\psi)$ 空间离散化为一个规则网格。角度 $\\phi$ 和 $\\psi$ 在循环域 $\\left[-180, 180\\right)$ 度上以 $\\Delta = 5$ 度的步长进行采样。这会产生一个 $72 \\times 72$ 的构象状态网格，其中网格点为 $(\\phi_i, \\psi_j)$，且 $\\phi_i, \\psi_j \\in \\{-180, -175, \\dots, 175\\}$。\n\n2.  **能量面的计算**：对于网格上的每个点 $(\\phi_i, \\psi_j)$，使用提供的能量模型计算总势能 $E(\\phi_i, \\psi_j)$。所有输入到三角函数的角度都首先从度转换为弧度。此过程生成一个 $72 \\times 72$ 的矩阵，代表势能面。\n\n3.  **局部极小值的识别**：在能量面上搜索局部极小值。如果一个网格点 $(i, j)$ 的能量 $E(\\phi_i, \\psi_j)$ 严格小于其所有八个直接邻居的能量，则该点被识别为局部极小值。二面角的周期性要求边界条件以回绕（环形）拓扑处理。对于一个大小为 $N \\times N$ 的网格，点 $(i, j)$ 的邻居的索引为 $(i', j')$，其中 $i' \\in \\{(i-1)\\pmod N, i, (i+1)\\pmod N\\}$ 且 $j' \\in \\{(j-1)\\pmod N, j, (j+1)\\pmod N\\}$，不包括 $(i, j)$ 本身。每个已识别的极小值的坐标和能量都会被存储。\n\n4.  **极小值的聚类**：局部极小值的集合可能包含多个属于同一个宽能量势阱的点。为了识别不同的构象状态，需要对这些极小值进行聚类。首先按能量升序对极小值进行排序。然后，应用贪心聚类算法。选择能量最低的未聚类极小值作为新簇的代表。所有其他与该代表“接近”的未聚类极小值都被分配到其簇中，并从作为代表的进一步考虑中移除。接近度由环形距离确定，对于角度差 $\\Delta\\theta$，定义为 $d(\\theta_1, \\theta_2) = \\min\\{|\\Delta\\theta|, 360 - |\\Delta\\theta|\\}$。如果两个极小值在 $\\phi$ 和 $\\psi$ 坐标上的环形距离都小于或等于聚类阈值 $\\tau_c = 15$ 度，则认为它们属于同一个簇。此过程为每个构象势阱生成一个唯一的、能量最低的代表列表。\n\n5.  **选择与匹配**：从唯一簇代表的列表中，选择能量最低的前 $L$ 个极小值作为预测的旋转异构体。然后，将每个提供的观察到的旋转异构体与这组 $L$ 个预测的旋转异构体进行比较。如果存在至少一个预测的旋转异构体 $(\\phi^\\ast, \\psi^\\ast)$，使得在两个维度上的环形距离都满足匹配容差 $\\tau_m = 20$ 度，即 $d(\\phi^\\ast, \\phi^{\\text{obs}}) \\le \\tau_m$ 和 $d(\\psi^\\ast, \\psi^{\\text{obs}}) \\le \\tau_m$，则认为一个观察到的旋转异构体 $(\\phi^{\\text{obs}}, \\psi^{\\text{obs}})$ 被匹配。\n\n6.  **最终判定**：对于一个给定的测试案例，当且仅当每个观察到的旋转异构体都被前 $L$ 个预测的旋转异构体中的至少一个成功匹配时，结果为 `True`。否则，结果为 `False`。然后，所有测试案例的布尔结果被汇集成一个单一列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases for glycosidic torsion energy surface analysis.\n    \"\"\"\n\n    # Test suite data as specified in the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"phi_terms\": [(3, 2.0, 180), (1, 1.5, 60)],\n            \"psi_terms\": [(3, 1.5, 270), (1, 1.8, 90)],\n            \"coup_terms\": [(1, -1, 0.2, 0)],\n            \"L\": 1,\n            \"obs_rotamers\": [(60, 90)],\n        },\n        # Case 2\n        {\n            \"phi_terms\": [(3, 2.0, 180), (1, 1.5, -60)],\n            \"psi_terms\": [(3, 1.0, 180), (1, 2.0, 180)],\n            \"coup_terms\": [(1, -1, 0.1, 0)],\n            \"L\": 1,\n            \"obs_rotamers\": [(-60, 180)],\n        },\n        # Case 3\n        {\n            \"phi_terms\": [(3, 2.0, 0), (1, 1.0, 0)],\n            \"psi_terms\": [(3, 2.0, 0), (1, 1.0, 0)],\n            \"coup_terms\": [(1, -1, 0.3, 0)],\n            \"L\": 1,\n            \"obs_rotamers\": [(0, 0)],\n        },\n        # Case 4\n        {\n            \"phi_terms\": [(3, 2.0, 180), (2, 0.6, 180)],\n            \"psi_terms\": [(3, 2.0, 180), (1, 1.2, -60)],\n            \"coup_terms\": [(1, -1, 0.3, 0)],\n            \"L\": 2,\n            \"obs_rotamers\": [(-60, -60), (60, -60)],\n        },\n    ]\n\n    # Global parameters\n    GRID_STEP = 5\n    CLUSTER_TOL = 15\n    MATCH_TOL = 20\n\n    results = []\n\n    def calculate_energy(phi_deg, psi_deg, phi_terms, psi_terms, coup_terms):\n        \"\"\"Calculates the total potential energy for a given (phi, psi) pair.\"\"\"\n        phi_rad = np.deg2rad(phi_deg)\n        psi_rad = np.deg2rad(psi_deg)\n        \n        energy = 0.0\n        \n        # Phi torsional terms\n        for n, V, delta_deg in phi_terms:\n            delta_rad = np.deg2rad(delta_deg)\n            energy += V * (1.0 - np.cos(n * phi_rad - delta_rad))\n            \n        # Psi torsional terms\n        for n, V, delta_deg in psi_terms:\n            delta_rad = np.deg2rad(delta_deg)\n            energy += V * (1.0 - np.cos(n * psi_rad - delta_rad))\n            \n        # Coupling terms\n        for a, b, V, delta_deg in coup_terms:\n            delta_rad = np.deg2rad(delta_deg)\n            energy += V * (1.0 - np.cos(a * phi_rad + b * psi_rad - delta_rad))\n            \n        return energy\n\n    def circular_dist(a1_deg, a2_deg):\n        \"\"\"Calculates the circular distance between two angles in degrees.\"\"\"\n        diff = np.abs(a1_deg - a2_deg)\n        return min(diff, 360.0 - diff)\n\n    for case in test_cases:\n        # Define the grid\n        angles = np.arange(-180, 180, GRID_STEP)\n        grid_size = len(angles)\n        energy_surface = np.zeros((grid_size, grid_size))\n\n        # 1. Calculate energy surface\n        for i, phi in enumerate(angles):\n            for j, psi in enumerate(angles):\n                energy_surface[i, j] = calculate_energy(\n                    phi, psi, case[\"phi_terms\"], case[\"psi_terms\"], case[\"coup_terms\"]\n                )\n\n        # 2. Find local minima\n        local_minima = []\n        for i in range(grid_size):\n            for j in range(grid_size):\n                is_min = True\n                current_energy = energy_surface[i, j]\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        if di == 0 and dj == 0:\n                            continue\n                        \n                        ni = (i + di + grid_size) % grid_size\n                        nj = (j + dj + grid_size) % grid_size\n                        \n                        if current_energy >= energy_surface[ni, nj]:\n                            is_min = False\n                            break\n                    if not is_min:\n                        break\n                \n                if is_min:\n                    local_minima.append(\n                        {\"phi\": angles[i], \"psi\": angles[j], \"energy\": current_energy}\n                    )\n\n        # 3. Cluster minima\n        local_minima.sort(key=lambda m: m[\"energy\"])\n        \n        clustered_minima = []\n        is_clustered = [False] * len(local_minima)\n\n        for i in range(len(local_minima)):\n            if is_clustered[i]:\n                continue\n            \n            rep = local_minima[i]\n            clustered_minima.append(rep)\n            is_clustered[i] = True\n            \n            for j in range(i + 1, len(local_minima)):\n                if is_clustered[j]:\n                    continue\n                \n                candidate = local_minima[j]\n                d_phi = circular_dist(rep[\"phi\"], candidate[\"phi\"])\n                d_psi = circular_dist(rep[\"psi\"], candidate[\"psi\"])\n                \n                if d_phi = CLUSTER_TOL and d_psi = CLUSTER_TOL:\n                    is_clustered[j] = True\n\n        # 4. Select top L minima\n        top_minima = clustered_minima[:case[\"L\"]]\n\n        # 5. Match with observed rotamers\n        num_obs = len(case[\"obs_rotamers\"])\n        if num_obs == 0:\n            results.append(True)\n            continue\n            \n        matched_flags = [False] * num_obs\n        \n        for i, obs in enumerate(case[\"obs_rotamers\"]):\n            obs_phi, obs_psi = obs\n            \n            for pred in top_minima:\n                d_phi = circular_dist(obs_phi, pred[\"phi\"])\n                d_psi = circular_dist(obs_psi, pred[\"psi\"])\n                \n                if d_phi = MATCH_TOL and d_psi = MATCH_TOL:\n                    matched_flags[i] = True\n                    break\n        \n        results.append(all(matched_flags))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2781427"}]}