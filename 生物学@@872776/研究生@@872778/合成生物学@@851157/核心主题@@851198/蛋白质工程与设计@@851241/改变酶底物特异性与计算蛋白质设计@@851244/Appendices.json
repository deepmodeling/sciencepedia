{"hands_on_practices": [{"introduction": "改变酶的功能始于理解能量与反应速率之间的深刻联系。酶通过稳定反应的过渡态来加速反应，从而降低活化能垒。这项基础练习要求您量化这一核心效应，即根据一个计算预测出的特定过渡态稳定化能量（$\\Delta\\Delta G^{\\ddagger}$），计算催化效率（$k_{\\text{cat}}/K_M$）的预期倍数变化[@problem_id:2713840]。掌握这种计算是将计算能量预测转化为可测量的动力学结果的关键第一步。", "problem": "在一项旨在改变底物特异性的计算蛋白质设计活动中，你在一个酶的活性位点设计了一个单氨基酸取代，以优先稳定非天然底物 $S_2$ 的过渡态。设计模型预测，在温度 $T = 298~\\text{K}$ 时，对于 $S_2$ 的催化限速步骤，活化自由能的变化为 $\\Delta\\Delta G^{\\ddagger} = \\Delta G^{\\ddagger}_{\\text{mut}} - \\Delta G^{\\ddagger}_{\\text{wt}} = -1.80~\\text{kcal}\\cdot\\text{mol}^{-1}$。假设基态结合不变，因此对于底物 $S_2$，米氏常数 $K_M$ 不受突变的影响。使用过渡态理论和标准的热力学-统计学推理，确定突变体与野生型之间对于 $S_2$ 的催化效率 $k_{\\text{cat}}/K_M$ 的预期倍数变化。使用气体常数 $R = 1.987 \\times 10^{-3}~\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}$。将答案表示为无量纲的倍数变化，并四舍五入到三位有效数字。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n第一步：提取已知条件。\n- 系统涉及野生型酶 (wt) 和突变型酶 (mut)。\n- 目标底物是一种非天然底物，记为 $S_2$。\n- 对于 $S_2$ 的催化限速步骤，活化自由能的变化给定为 $\\Delta\\Delta G^{\\ddagger} = \\Delta G^{\\ddagger}_{\\text{mut}} - \\Delta G^{\\ddagger}_{\\text{wt}} = -1.80~\\text{kcal}\\cdot\\text{mol}^{-1}$。\n- 温度恒定为 $T = 298~\\text{K}$。\n- 提供了一个明确的假设：对于底物 $S_2$，米氏常数 $K_M$ 不受突变的影响。\n- 气体常数的值为 $R = 1.987 \\times 10^{-3}~\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}$。\n- 目标是确定突变体相对于野生型的催化效率 $\\frac{k_{\\text{cat}}}{K_M}$ 的无量纲倍数变化，并四舍五入到三位有效数字。\n\n第二步：使用提取的已知条件进行验证。\n- 科学依据：该问题根本上基于过渡态理论和 Michaelis-Menten 酶动力学，这是物理化学和生物化学的基石。通过突变改变酶的特异性这一情景是计算蛋白质设计和合成生物学的主要目标。提供的能量、温度和气体常数的数值在物理上是现实且一致的。该问题在科学上是合理的。\n- 良定性：该问题是良定的。它要求一个具体、可计算的量（催化效率的倍数变化），并提供了所有必要的数据和一个关键的简化假设（$\\Delta K_M = 0$），以得出唯一解。\n- 客观性：该问题以精确、客观和定量的术语陈述，没有任何主观或模糊的语言。\n\n第三步：结论与行动。\n该问题是有效的。这是一个生物物理化学中的标准、定义明确的问题，可以使用既定原理解决。我们现在开始求解。\n\n问题的核心在于反应速率常数与其活化自由能之间的关系，这由过渡态理论描述。对于一个酶促反应，催化速率常数 $k_{\\text{cat}}$ 通过 Eyring 方程与限速步骤的活化自由能 $\\Delta G^{\\ddagger}$ 相关：\n$$ k_{\\text{cat}} = \\kappa \\frac{k_B T}{h} \\exp\\left(-\\frac{\\Delta G^{\\ddagger}}{RT}\\right) $$\n其中 $\\kappa$ 是透射系数（通常假设为 $1$），$k_B$ 是 Boltzmann 常数，$h$ 是 Planck 常数，$R$ 是气体常数，$T$ 是绝对温度。为了我们的目的，指前因子 $\\kappa \\frac{k_B T}{h}$ 可以被视为一个常数 $A$。\n$$ k_{\\text{cat}} = A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}}{RT}\\right) $$\n我们被要求计算催化效率的倍数变化，其定义为突变型酶的催化效率与野生型酶的催化效率之比。\n$$ \\text{倍数变化} = \\frac{(k_{\\text{cat}}/K_M)_{\\text{mut}}}{(k_{\\text{cat}}/K_M)_{\\text{wt}}} $$\n问题明确指出基态结合不变，这意味着对于底物 $S_2$，野生型和突变型酶的米氏常数 $K_M$ 是相同的。也就是说，$(K_M)_{\\text{mut}} = (K_M)_{\\text{wt}}$。因此，在倍数变化的表达式中，$K_M$ 项相互抵消：\n$$ \\text{倍数变化} = \\frac{(k_{\\text{cat}})_{\\text{mut}}}{(k_{\\text{cat}})_{\\text{wt}}} $$\n现在，我们将过渡态理论中 $k_{\\text{cat}}$ 的表达式代入突变型和野生型酶。\n$$ \\text{倍数变化} = \\frac{A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\text{mut}}}{RT}\\right)}{A \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\text{wt}}}{RT}\\right)} $$\n指前因子 $A$ 被抵消，我们可以合并指数项：\n$$ \\text{倍数变化} = \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\text{mut}}}{RT} + \\frac{\\Delta G^{\\ddagger}_{\\text{wt}}}{RT}\\right) $$\n$$ \\text{倍数变化} = \\exp\\left(-\\frac{\\Delta G^{\\ddagger}_{\\text{mut}} - \\Delta G^{\\ddagger}_{\\text{wt}}}{RT}\\right) $$\n指数的分子项是给定的活化自由能变化 $\\Delta\\Delta G^{\\ddagger}$。\n$$ \\text{倍数变化} = \\exp\\left(-\\frac{\\Delta\\Delta G^{\\ddagger}}{RT}\\right) $$\n我们现在将提供的数值代入此表达式。\n已知：\n- $\\Delta\\Delta G^{\\ddagger} = -1.80~\\text{kcal}\\cdot\\text{mol}^{-1}$\n- $R = 1.987 \\times 10^{-3}~\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}$\n- $T = 298~\\text{K}$\n\n首先，我们计算指数的值：\n$$ -\\frac{\\Delta\\Delta G^{\\ddagger}}{RT} = -\\frac{-1.80~\\text{kcal}\\cdot\\text{mol}^{-1}}{(1.987 \\times 10^{-3}~\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1})(298~\\text{K})} $$\n单位如指数函数的自变量所要求的那样相互抵消。\n$$ \\text{指数} = \\frac{1.80}{1.987 \\times 10^{-3} \\times 298} = \\frac{1.80}{0.592126} \\approx 3.04000 $$\n现在，我们计算倍数变化：\n$$ \\text{倍数变化} = \\exp(3.04000) \\approx 20.9056 $$\n问题要求答案四舍五入到三位有效数字，这与输入值 $\\Delta\\Delta G^{\\ddagger} = -1.80$ 的精度一致。\n$$ \\text{倍数变化} \\approx 20.9 $$\n$\\Delta\\Delta G^{\\ddagger}$ 的负号表示突变稳定了过渡态，这预计会增加催化速率，导致倍数变化大于 $1$。我们的结果与这一物理预期一致。", "answer": "$$\n\\boxed{20.9}\n$$", "id": "2713840"}, {"introduction": "除了提高对单一底物的催化活性，蛋白质设计的关键目标之一是重塑酶的*选择性*，即它对不同竞争底物的偏好程度。本练习深入探讨了这一挑战，要求您模拟活性位点中一个精确的几何变化如何差异性地影响两种竞争底物的活化能[@problem_id:2713850]。通过应用线性自由能关系（LFER），您将预测选择性的最终倍数变化，这展示了一种用于理性设计底物特异性的强大建模方法。", "problem": "一种工程酶正在被设计，以改变其在两种竞争性底物（表示为底物$A$和底物$B$）之间的底物特异性。一项计算性再设计提议，将一个催化酸侧链沿供体-受体轴移动一个位移$\\Delta x = +0.5\\,\\text{\\AA}$，这使得氢键供体-受体距离增加了$0.5\\,\\text{\\AA}$。假设以下基本原理和建模假设，这些原理和假设根植于经过充分检验的动力学和热力学理论：\n\n1. 根据过渡态理论（TST），对于每种底物 $i \\in \\{A,B\\}$，其催化效率 $k_{\\text{cat}}/K_{M}$ 与 $\\exp\\!\\left(-\\Delta G_{i}^{\\ddagger}/(R T)\\right)$ 成正比，其中 $\\Delta G_{i}^{\\ddagger}$ 是活化自由能，$R$ 是理想气体常数，$T$ 是绝对温度。假设任何指前因子都与底物无关，并且在所考虑的微扰下保持不变，因此催化效率的比率由活化自由能的差异决定。\n2. 对于每种底物 $i$，几何位移 $x$ 与活化自由能之间存在线性自由能关系（LFER），其形式为 $\\Delta G_{i}^{\\ddagger}(x) = \\Delta G_{i}^{\\ddagger}(0) + m_{i}\\,x$，其中 $m_{i}$ 是特定于底物的斜率。正的 $m_{i}$ 意味着增加供体-受体距离会提高 $\\Delta G_{i}^{\\ddagger}$。\n\n对局部过渡态氢键的量子力学/分子力学标定得到特定于底物的斜率 $m_{A} = 1.8\\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{\\AA}^{-1}$ 和 $m_{B} = 0.6\\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{\\AA}^{-1}$。设绝对温度为 $T = 298\\,\\text{K}$，并使用理想气体常数 $R = 1.987 \\times 10^{-3}\\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。\n\n将选择性定义为催化效率之比 $\\sigma = \\left(k_{\\text{cat}}/K_{M}\\right)_{A} \\big/ \\left(k_{\\text{cat}}/K_{M}\\right)_{B}$。在上述假设下，计算由位移 $\\Delta x = +0.5\\,\\text{\\AA}$ 导致的选择性倍数变化 $\\sigma_{\\text{new}}/\\sigma_{\\text{old}}$。将最终答案表示为一个无量纲数，并四舍五入至四位有效数字。", "solution": "该问题已经过验证，被认为是科学上合理的、问题是适定的，并且没有矛盾。它展示了过渡态理论（TST）和线性自由能关系（LFERs）在计算酶设计问题中的一个标准应用。所有必要的数据都已提供。因此，我们可以进行形式化的求解。\n\n对于底物 $i$（其中 $i \\in \\{A, B\\}$），其催化效率由比率 $k_{\\text{cat}}/K_{M}$ 给出。根据所述的TST原理，该效率与包含活化自由能 $\\Delta G_i^\\ddagger$ 的指数项成正比。我们可以将此关系写为：\n$$ \\left(\\frac{k_{\\text{cat}}}{K_{M}}\\right)_i = C \\exp\\left(-\\frac{\\Delta G_i^\\ddagger}{RT}\\right) $$\n其中 $C$ 是指前因子，假设它对两种底物都是常数，并且在指定的微扰下保持不变。$R$ 是理想气体常数，$T$ 是绝对温度。\n\n选择性 $\\sigma$ 定义为底物 $A$ 与底物 $B$ 的催化效率之比：\n$$ \\sigma = \\frac{\\left(k_{\\text{cat}}/K_{M}\\right)_{A}}{\\left(k_{\\text{cat}}/K_{M}\\right)_{B}} $$\n将TST表达式代入此定义，我们得到：\n$$ \\sigma = \\frac{C \\exp\\left(-\\frac{\\Delta G_A^\\ddagger}{RT}\\right)}{C \\exp\\left(-\\frac{\\Delta G_B^\\ddagger}{RT}\\right)} $$\n常数 $C$ 被消去，这与问题的假设一致。利用指数函数的性质，可简化为：\n$$ \\sigma = \\exp\\left(-\\frac{\\Delta G_A^\\ddagger}{RT} + \\frac{\\Delta G_B^\\ddagger}{RT}\\right) = \\exp\\left(-\\frac{\\Delta G_A^\\ddagger - \\Delta G_B^\\ddagger}{RT}\\right) $$\n该表达式将选择性与两种底物的活化自由能之差联系起来。\n\n我们被要求计算由位移 $\\Delta x$ 引起的选择性倍数变化 $\\sigma_{\\text{new}} / \\sigma_{\\text{old}}$。“旧”状态对应于初始位置，我们可以表示为 $x=0$，“新”状态对应于最终位置 $x=\\Delta x$。\n\n旧状态下的选择性为：\n$$ \\sigma_{\\text{old}} = \\exp\\left(-\\frac{\\Delta G_A^\\ddagger(0) - \\Delta G_B^\\ddagger(0)}{RT}\\right) $$\n在新状态下，经过位移 $\\Delta x$ 后的选择性为：\n$$ \\sigma_{\\text{new}} = \\exp\\left(-\\frac{\\Delta G_A^\\ddagger(\\Delta x) - \\Delta G_B^\\ddagger(\\Delta x)}{RT}\\right) $$\n倍数变化是这两个量的比值：\n$$ \\frac{\\sigma_{\\text{new}}}{\\sigma_{\\text{old}}} = \\frac{\\exp\\left(-\\frac{\\Delta G_A^\\ddagger(\\Delta x) - \\Delta G_B^\\ddagger(\\Delta x)}{RT}\\right)}{\\exp\\left(-\\frac{\\Delta G_A^\\ddagger(0) - \\Delta G_B^\\ddagger(0)}{RT}\\right)} $$\n再次应用指数函数的性质 $\\exp(u)/\\exp(v) = \\exp(u-v)$，我们得到：\n$$ \\frac{\\sigma_{\\text{new}}}{\\sigma_{\\text{old}}} = \\exp\\left( \\frac{-\\left(\\Delta G_A^\\ddagger(\\Delta x) - \\Delta G_B^\\ddagger(\\Delta x)\\right) + \\left(\\Delta G_A^\\ddagger(0) - \\Delta G_B^\\ddagger(0)\\right)}{RT} \\right) $$\n重新整理指数的分子中的项，得到：\n$$ \\frac{\\sigma_{\\text{new}}}{\\sigma_{\\text{old}}} = \\exp\\left( -\\frac{\\left(\\Delta G_A^\\ddagger(\\Delta x) - \\Delta G_A^\\ddagger(0)\\right) - \\left(\\Delta G_B^\\ddagger(\\Delta x) - \\Delta G_B^\\ddagger(0)\\right)}{RT} \\right) $$\n问题陈述了线性自由能关系控制着活化能随位移的变化：\n$$ \\Delta G_i^\\ddagger(x) = \\Delta G_i^\\ddagger(0) + m_i x $$\n由此，位移 $\\Delta x$ 引起的活化自由能变化为 $\\Delta G_i^\\ddagger(\\Delta x) - \\Delta G_i^\\ddagger(0) = m_i \\Delta x$。我们可以将此代入选择性倍数变化的表达式中：\n$$ \\frac{\\sigma_{\\text{new}}}{\\sigma_{\\text{old}}} = \\exp\\left( -\\frac{m_A \\Delta x - m_B \\Delta x}{RT} \\right) $$\n$$ \\frac{\\sigma_{\\text{new}}}{\\sigma_{\\text{old}}} = \\exp\\left( -\\frac{(m_A - m_B)\\Delta x}{RT} \\right) $$\n这个最终的符号表达式包含了所有给定的量。现在我们代入提供的数值：\n$m_A = 1.8\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{\\AA}^{-1}$\n$m_B = 0.6\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{\\AA}^{-1}$\n$\\Delta x = +0.5\\,\\text{\\AA}$\n$R = 1.987 \\times 10^{-3}\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}$\n$T = 298\\,\\text{K}$\n\n首先，我们计算指数中的各项。斜率之差为：\n$$ m_A - m_B = (1.8 - 0.6)\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{\\AA}^{-1} = 1.2\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{\\AA}^{-1} $$\n分子代表活化能的差异变化，为：\n$$ (m_A - m_B)\\Delta x = (1.2\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{\\AA}^{-1}) \\times (0.5\\,\\text{\\AA}) = 0.6\\,\\text{kcal}\\cdot\\text{mol}^{-1} $$\n分母代表热能标度，为：\n$$ RT = (1.987 \\times 10^{-3}\\,\\text{kcal}\\cdot\\text{mol}^{-1}\\cdot\\text{K}^{-1}) \\times (298\\,\\text{K}) \\approx 0.592126\\,\\text{kcal}\\cdot\\text{mol}^{-1} $$\n现在，我们计算指数的值：\n$$ -\\frac{(m_A - m_B)\\Delta x}{RT} = -\\frac{0.6}{0.592126} \\approx -1.013297 $$\n最后，我们计算倍数变化：\n$$ \\frac{\\sigma_{\\text{new}}}{\\sigma_{\\text{old}}} = \\exp(-1.013297) \\approx 0.362942 $$\n按照要求四舍五入到四位有效数字，结果是 $0.3629$。正位移 $\\Delta x$ 加上 $m_A > m_B$ 的条件，使得底物 $A$ 的活化能垒增加得比底物 $B$ 多，从而降低了酶对底物 $A$ 相对于底物 $B$ 的选择性。", "answer": "$$\n\\boxed{0.3629}\n$$", "id": "2713850"}, {"introduction": "从理论模型到实际编码，这项最后的练习让您亲身体验计算蛋白质设计师的角色。您将需要实现一个算法，来解决一个基于结构的设计中的核心问题：寻找一套全新的侧链构象（旋转异构体），以便在不引入空间位阻冲突的情况下容纳一个更大的底物类似物[@problem_id:2713890]。这个动手编程任务清晰地展示了如何将空间位阻和构象选择等抽象物理化学原理，转化为一个可解的、具体的组合优化问题，从而揭示了蛋白质设计软件算法核心的一角。", "problem": "您的任务是实现一个几何组合求解器，用于解决一个简化的蛋白质设计问题，该问题与通过侧链旋转异构体变化来改变酶的底物特异性相关。在硬球空间位阻模型中，每个原子被近似为一个球体。残基的每个侧链旋转异构体由一组有限的伪原子球体给出，这些球体近似了侧链的包络。底物类似物引入了一个额外的球形取代基，该取代基必须在不发生空间位阻冲突的情况下被容纳。\n\n基本原理：\n- 在硬球模型中，两个球心分别位于 $\\mathbf{x} \\in \\mathbb{R}^3$ 和 $\\mathbf{y} \\in \\mathbb{R}^3$，半径分别为 $a \\in \\mathbb{R}_{\\ge 0}$ 和 $b \\in \\mathbb{R}_{\\ge 0}$ 的球体发生冲突，当且仅当 $\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2  a + b$。\n- 侧链旋转异构体是离散的构象；为每个残基选择一个旋转异构体，即可固定其侧链伪原子的几何构型。\n\n数学公式化：\n- 有 $N$ 个残基，由 $i \\in \\{1,\\dots,N\\}$ 索引。残基 $i$ 有 $K_i$ 个旋转异构体，由 $k \\in \\{0,1,\\dots,K_i-1\\}$ 索引。残基 $i$ 的旋转异构体 $k$ 包含 $M_{i,k}$ 个伪原子，其球心为 $\\{\\mathbf{x}_{i,k,m}\\}_{m=1}^{M_{i,k}} \\subset \\mathbb{R}^3$，半径为 $\\{a_{i,k,m}\\}_{m=1}^{M_{i,k}} \\subset \\mathbb{R}_{\\ge 0}$。\n- 底物类似物的额外取代基是一个球体，其球心为 $\\mathbf{s} \\in \\mathbb{R}^3$，半径为 $r \\in \\mathbb{R}_{\\ge 0}$。\n- 一种选择是指为每个残基精确地选择一个旋转异构体。设二元决策变量为 $y_{i,k} \\in \\{0,1\\}$，且对于所有 $i$ 满足 $\\sum_{k=0}^{K_i-1} y_{i,k} = 1$。\n- 避免与底物冲突：对于任意选定的旋转异构体 $(i,k)$ 以及任意 $m \\in \\{1,\\dots,M_{i,k}\\}$，要求 $\\lVert \\mathbf{x}_{i,k,m} - \\mathbf{s} \\rVert_2 \\ge a_{i,k,m} + r$。\n- 避免残基间冲突：对于任意两个不同的残基 $i \\ne j$、其选定的旋转异构体 $(i,k)$ 和 $(j,\\ell)$，以及任意 $m \\in \\{1,\\dots,M_{i,k}\\}$，$n \\in \\{1,\\dots,M_{j,\\ell}\\}$，要求 $\\lVert \\mathbf{x}_{i,k,m} - \\mathbf{x}_{j,\\ell,n} \\rVert_2 \\ge a_{i,k,m} + a_{j,\\ell,n}$。\n- 基线（野生型）构象是指对于每个残基 $i$ 都选择 $k=0$。定义一个构象的成本为 $C = \\sum_{i=1}^{N} \\left(1 - y_{i,0}\\right)$，它计算了与基线相比发生变化的残基数量。目标是在满足避免冲突约束的前提下，最小化 $C$。\n- 如果不存在可行的构象，则返回一个不可行指示符。\n\n几何与单位：\n- 所有坐标 $\\mathbf{x}_{i,k,m}$ 和 $\\mathbf{s}$ 的单位均为埃（Angstrom）。所有半径 $a_{i,k,m}$ 和 $r$ 的单位均为埃。所有距离均为以埃为单位的欧几里得距离。您的程序必须使用严格不等式 $\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2  a + b$ 作为冲突定义来执行精确的冲突检查。\n\n您的任务：\n- 实现一个程序，对于下方的每个测试用例，计算为了在没有任何冲突的情况下容纳额外的取代基，相对于基线必须改变旋转异构体的最小残基数量，如果不存在可行构象，则返回 $-1$。\n- 最终输出格式要求为单行文本，包含所有测试用例结果的列表，形式为逗号分隔并用方括号括起来，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。\n- 输出中沒有物理單位，因為輸出的是整數。\n\n测试套件（请精确使用以下4个用例）：\n\n- 测试用例1（正常路径）：\n  - 取代基：球心 $\\mathbf{s} = (\\,0.0,\\,0.0,\\,0.0\\,)$，半径 $r = 1.5$。\n  - 残基1：\n    - 旋转异构体0：一个伪原子，位于 $(\\,1.5,\\,0.0,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,5.0,\\,0.0,\\,0.0\\,)$，半径 $1.7$。\n  - 残基2：\n    - 旋转异构体0：一个伪原子，位于 $(\\,0.0,\\,1.5,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,0.0,\\,4.8,\\,0.0\\,)$，半径 $1.7$。\n  - 残基3：\n    - 旋转异构体0：一个伪原子，位于 $(\\,0.0,\\,0.0,\\,4.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,0.0,\\,0.0,\\,2.0\\,)$，半径 $1.7$。\n\n- 测试用例2（无需更改）：\n  - 取代基：球心 $\\mathbf{s} = (\\,0.0,\\,0.0,\\,0.0\\,)$，半径 $r = 1.2$。\n  - 残基1：\n    - 旋转异构体0：一个伪原子，位于 $(\\,4.0,\\,0.0,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,5.0,\\,0.0,\\,0.0\\,)$，半径 $1.7$。\n  - 残基2：\n    - 旋转异构体0：一个伪原子，位于 $(\\,0.0,\\,4.0,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,0.0,\\,5.0,\\,0.0\\,)$，半径 $1.7$。\n  - 残基3：\n    - 旋转异构体0：一个伪原子，位于 $(\\,0.0,\\,0.0,\\,4.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,0.0,\\,0.0,\\,5.0\\,)$，半径 $1.7$。\n\n- 测试用例3（因一个残基没有可接受的旋转异构体而不可行）：\n  - 取代基：球心 $\\mathbf{s} = (\\,0.0,\\,0.0,\\,0.0\\,)$，半径 $r = 2.0$。\n  - 残基1：\n    - 旋转异构体0：一个伪原子，位于 $(\\,2.0,\\,0.0,\\,0.0\\,)$，半径 $1.5$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,2.2,\\,0.0,\\,0.0\\,)$，半径 $1.5$。\n  - 残基2：\n    - 旋转异构体0：一个伪原子，位于 $(\\,0.0,\\,4.0,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,0.0,\\,5.0,\\,0.0\\,)$，半径 $1.7$。\n\n- 测试用例4（相互作用导致需要额外更改）：\n  - 取代基：球心 $\\mathbf{s} = (\\,0.0,\\,0.0,\\,0.0\\,)$，半径 $r = 1.5$。\n  - 残基A（视为残基1）：\n    - 旋转异构体0：一个伪原子，位于 $(\\,3.6,\\,0.0,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,0.0,\\,3.6,\\,0.0\\,)$，半径 $1.7$。\n  - 残基B（视为残基2）：\n    - 旋转异构体0：一个伪原子，位于 $(\\,0.0,\\,1.5,\\,0.0\\,)$，半径 $1.7$。\n    - 旋转异构体1：一个伪原子，位于 $(\\,3.6,\\,0.0,\\,0.0\\,)$，半径 $1.7$。\n\n对于每个测试用例，计算相对于基线（旋转异构体索引为0）需要改变旋转异构体的最小残基数量，以满足所有避免冲突的约束。如果不存在可行构象，则返回 $-1$。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是测试用例 $i$ 的整数结果。", "solution": "所呈现的问题是一个良定义的组合优化问题，其根植于计算蛋白质设计（合成生物学的一个分支学科）的原理。其结构在科学上是合理的，依赖于已建立的用于空间相互作用的硬球模型，并且所有必要的参数都已提供，从而使该问题可以进行形式化求解。\n\n任务是为 $N$ 个残基中的每一个找到一个侧链旋转异构体的选择，这个选择集合能够共同避免空间位阻冲突，同时最小化与基线（野生型）构象的偏离数量。一个构象的成本定义为 $C = \\sum_{i=1}^{N} (1 - y_{i,0})$，其中 $y_{i,0}$ 是一个二元变量，指示残基 $i$ 是否处于其基线旋转异构体（索引为 $k=0$）。该成本函数量化了与原始状态相比的“突变”或变化的数量。\n\n该系统受两组几何约束的制约，这两组约束都源自硬球模型。两个球心分别为 $\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^3$、半径分别为 $a, b \\in \\mathbb{R}_{\\ge 0}$ 的球体，当且仅当其球心之间的欧几里得距离小于其半径之和时，定义为发生冲突：$\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2  a + b$。为了提高计算效率，此检查更容易通过比较平方量来实现：$\\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2^2  (a + b)^2$。\n\n约束条件如下：\n1. **避免底物与残基的冲突：** 对于残基 $i$ 的任何选定旋转异构体 $k$，其每个组成部分的伪原子（球心 $\\mathbf{x}_{i,k,m}$，半径 $a_{i,k,m}$）都不得与底物的取代基球体（球心 $\\mathbf{s}$，半径 $r$）发生冲突。这表示为对于所有原子 $m$，$\\lVert \\mathbf{x}_{i,k,m} - \\mathbf{s} \\rVert_2 \\ge a_{i,k,m} + r$。\n2. **避免残基间的冲突：** 对于任意两个不同的残基 $i$ 和 $j$，其选定的旋转异构体分别为 $k$ 和 $\\ell$，它们各自的任何组成伪原子都不得相互冲突。这表示为对于所有原子对 $(m, n)$，$\\lVert \\mathbf{x}_{i,k,m} - \\mathbf{x}_{j,\\ell,n} \\rVert_2 \\ge a_{i,k,m} + a_{j,\\ell,n}$。\n\n一个旋转异构体构象是一个选择向量 $(k_1, k_2, \\dots, k_N)$，其中 $k_i$ 是为残基 $i$ 选择的旋转异构体的索引。所有可能构象的集合构成了搜索空间。对于一个有 $N$ 个残基的系统，其中残基 $i$ 拥有 $K_i$ 个可能的旋转异构体，这个离散搜索空间的总大小为 $\\prod_{i=1}^{N} K_i$。\n\n对于所提供的测试用例，残基数量 $N$（为2或3）和每个残基的旋转异构体数量 $K_i$（总是2）都很小。这导致了一个非常小的搜索空间（例如，对于一个3残基系统，总共有 $2^3 = 8$ 种构象）。因此，对所有可能的构象进行穷举搜索（或暴力枚举）是一种计算上可行且完全严谨的方法，可以找到最优解。如果存在可行解，这种方法保证能找到全局最小成本。\n\n算法流程如下：\n1. 初始化一个最小成本变量 $\\text{min\\_cost}$，其值大于任何可能的成本，例如 $N+1$ 或无穷大。\n2. 生成每一种可能的旋转异构体构象。一个构象是一个元组 $(k_1, k_2, \\dots, k_N)$，其中 $k_i \\in \\{0, 1, \\dots, K_i-1\\}$。这可以通过系统性的方法实现，例如，通过计算每个残基的旋转异构体索引集的笛卡尔积。\n3. 对于每一种生成的构象：\n    a. 假定该构象有效。\n    b. 检查与底物的冲突：对于每个残基 $i \\in \\{1,\\dots,N\\}$，遍历其指定旋转异构体 $k_i$ 的所有伪原子，并验证与底物球体的非冲突条件。如果检测到冲突，则该构象无效；继续处理下一个构象。\n    c. 如果未发现与底物的冲突，则检查残基间的冲突：对于每一对唯一的不同残基 $(i, j)$（其中 $i \\ne j$），遍历所有伪原子对（一个来自旋转异构体 $k_i$，一个来自旋转异构体 $k_j$），并验证非冲突条件。如果检测到冲突，则该构象无效；继续处理下一个构象。\n    d. 如果该构象被判定为有效（即无冲突），则计算其成本：$C = \\sum_{i=1}^{N} \\mathbb{I}(k_i \\ne 0)$，其中 $\\mathbb{I}$ 是指示函数。更新 $\\text{min\\_cost} = \\min(\\text{min\\_cost}, C)$。\n4. 在评估完所有可能的构象后，如果 $\\text{min\\_cost}$ 仍保持其初始高值，则意味着不存在可行的、无冲突的构象。在这种情况下，结果为 $-1$。否则，$\\text{min\\_cost}$ 的最终值就是所需的最少突变数，即为解。\n\n这个确定性算法通过系统地探索完整的、有限的解空间，并识别出成本最低的可行解，从而正确地解决了所提出的问题。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product, combinations\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        # Test case 1 (happy path)\n        {\n            'substrate': {'center': np.array([0.0, 0.0, 0.0]), 'radius': 1.5},\n            'residues': [\n                # Residue 1\n                [\n                    [{'center': np.array([1.5, 0.0, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([5.0, 0.0, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n                # Residue 2\n                [\n                    [{'center': np.array([0.0, 1.5, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([0.0, 4.8, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n                # Residue 3\n                [\n                    [{'center': np.array([0.0, 0.0, 4.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([0.0, 0.0, 2.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n            ]\n        },\n        # Test case 2 (no changes needed)\n        {\n            'substrate': {'center': np.array([0.0, 0.0, 0.0]), 'radius': 1.2},\n            'residues': [\n                # Residue 1\n                [\n                    [{'center': np.array([4.0, 0.0, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([5.0, 0.0, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n                # Residue 2\n                [\n                    [{'center': np.array([0.0, 4.0, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([0.0, 5.0, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n                # Residue 3\n                [\n                    [{'center': np.array([0.0, 0.0, 4.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([0.0, 0.0, 5.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n            ]\n        },\n        # Test case 3 (infeasible due to one residue)\n        {\n            'substrate': {'center': np.array([0.0, 0.0, 0.0]), 'radius': 2.0},\n            'residues': [\n                # Residue 1\n                [\n                    [{'center': np.array([2.0, 0.0, 0.0]), 'radius': 1.5}], # Rotamer 0\n                    [{'center': np.array([2.2, 0.0, 0.0]), 'radius': 1.5}], # Rotamer 1\n                ],\n                # Residue 2\n                [\n                    [{'center': np.array([0.0, 4.0, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([0.0, 5.0, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n            ]\n        },\n        # Test case 4 (interaction-induced extra change needed)\n        {\n            'substrate': {'center': np.array([0.0, 0.0, 0.0]), 'radius': 1.5},\n            'residues': [\n                # Residue A (1)\n                [\n                    [{'center': np.array([3.6, 0.0, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([0.0, 3.6, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n                # Residue B (2)\n                [\n                    [{'center': np.array([0.0, 1.5, 0.0]), 'radius': 1.7}], # Rotamer 0\n                    [{'center': np.array([3.6, 0.0, 0.0]), 'radius': 1.7}], # Rotamer 1\n                ],\n            ]\n        }\n    ]\n\n    results = [solve_case(case) for case in test_cases_data]\n    # Final print statement in the exact required format.\n    # print(f\"[{','.join(map(str, results))}]\") # This would print the answer.\n\ndef clashes(sphere1, sphere2):\n    \"\"\"\n    Checks if two spheres clash based on the hard-sphere model.\n    Uses squared distances for efficiency.\n    \"\"\"\n    center1, r1 = sphere1['center'], sphere1['radius']\n    center2, r2 = sphere2['center'], sphere2['radius']\n    dist_sq = np.sum((center1 - center2)**2)\n    radii_sum_sq = (r1 + r2)**2\n    return dist_sq  radii_sum_sq\n\ndef is_assignment_valid(assignment, substrate, residues):\n    \"\"\"\n    Checks if a given rotamer assignment is valid (clash-free).\n    \"\"\"\n    # Check for substrate clashes\n    for i, rot_idx in enumerate(assignment):\n        rotamer = residues[i][rot_idx]\n        for atom in rotamer:\n            if clashes(atom, substrate):\n                return False\n\n    # Check for inter-residue clashes\n    num_residues = len(residues)\n    if num_residues  2:\n        return True\n    \n    for i, j in combinations(range(num_residues), 2):\n        rotamer_i = residues[i][assignment[i]]\n        rotamer_j = residues[j][assignment[j]]\n        for atom_i in rotamer_i:\n            for atom_j in rotamer_j:\n                if clashes(atom_i, atom_j):\n                    return False\n    return True\n\ndef solve_case(case_data):\n    \"\"\"\n    Solves a single test case by exhaustively searching all rotamer assignments.\n    \"\"\"\n    substrate = case_data['substrate']\n    residues = case_data['residues']\n    \n    # Generate all possible rotamer assignments using itertools.product\n    rotamer_indices_per_residue = [range(len(res)) for res in residues]\n    all_assignments = product(*rotamer_indices_per_residue)\n    \n    min_cost = float('inf')\n    \n    # Iterate through every possible assignment\n    for assignment in all_assignments:\n        if is_assignment_valid(assignment, substrate, residues):\n            # If the assignment is valid, calculate its cost\n            cost = sum(1 for rot_idx in assignment if rot_idx > 0)\n            # Update the minimum cost found so far\n            if cost  min_cost:\n                min_cost = cost\n                \n    return min_cost if min_cost != float('inf') else -1\n\nif __name__ == '__main__':\n    solve()\n\n```", "answer": "[2,0,-1,2]", "id": "2713890"}]}