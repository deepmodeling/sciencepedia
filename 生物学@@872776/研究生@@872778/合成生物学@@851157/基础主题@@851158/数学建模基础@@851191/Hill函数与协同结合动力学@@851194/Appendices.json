{"hands_on_practices": [{"introduction": "希尔方程是模拟协同性的基石，但它通常以一个唯象方程的形式出现。本练习将希尔方程与一个更基础的、力学上的顺序配体结合模型联系起来。通过推导系统的精确行为并拟合一个有效的希尔函数，你将更深刻地理解希尔参数 $n$ 和 $K$ 在微观解离常数方面的真正含义 [@problem_id:2744319]。", "problem": "您需要从第一性原理出发，推导并实现一个拥有两个配体结合位点的单一受体的平衡分数位点占据率。该受体根据质量作用定律依次结合一种配体。请在巨正则系综下，使用受体状态的结合多项式进行研究，并假设存在宏观逐步解离常数。然后，使用您推导出的精确平衡表达式，校准一个有效的 Hill 模型，该模型能够在广泛的配体浓度范围内近似精确的占据率。\n\n假设与定义：\n- 受体有两个等效的物理位点，它们按顺序结合配体，其宏观逐步解离常数 $K_{d1}$ 和 $K_{d2}$ 由未结合配体的受体、单配体结合的受体和双配体结合的受体在平衡状态下的质量作用平衡来定义。\n- 设游离配体浓度为 $L$，单位为纳摩尔 (nM)。\n- 分数位点占据率 $Y(L)$ 是每个受体上结合配体的期望数除以 $2$，为无量纲量。\n- 待拟合的有效 Hill 模型是双参数族 $Y_{\\mathrm{Hill}}(L) = \\dfrac{L^{n}}{K^{n} + L^{n}}$，其中 $n$（无量纲）是 Hill 指数，$K$（单位为 nM）是 Hill 模型的半饱和常数。\n\n任务 A（推导与精确计算）：\n- 从质量作用定律和顺序结合的宏观逐步解离常数的定义出发，推导 $Y(L)$ 作为 $L$、$K_{d1}$ 和 $K_{d2}$ 的函数的精确表达式，不假设非协同性。您的推导必须从可容许的受体状态构建的结合多项式开始，并且 $Y(L)$ 必须通过将期望占据数按位点数归一化得到。\n- 实现您推导出的精确 $Y(L)$。\n\n任务 B（有效 Hill 拟合）：\n- 使用非线性最小二乘法，将 $Y_{\\mathrm{Hill}}(L)$ 的参数 $n$ 和 $K$ 拟合到在跨越六个数量级的对数间隔 $L$ 值网格上计算出的精确 $Y(L)$。\n- 使用一个从 $10^{-3}$ nM 到 $10^{3}$ nM 的 $L$ 值拟合网格，在 400 个对数间隔点上采样。目标是最小化该网格上精确 $Y(L)$ 和 $Y_{\\mathrm{Hill}}(L)$ 之间的无加权残差平方和。\n- 将拟合约束在 $n \\in [0.1, 4.0]$ 和 $K \\in [10^{-6}, 10^{6}]$ nM 范围内。选择合理的初始猜测值。\n\n使用的参数值：\n- $K_{d1} = 10$ nM。\n- $K_{d2} = 2$ nM。\n\n测试套件：\n- 计算以下五个配体浓度（单位均为 nM）下的精确 $Y(L)$：$L \\in \\{0, 0.01, 2, 10, 1000\\}$。\n- 按照上述规定拟合有效 Hill 模型，以获得估计值 $\\hat{n}$ 和 $\\hat{K}$。\n- 程序必须返回一个包含这些结果的浮点数列表：$[Y(0), Y(0.01), Y(2), Y(10), Y(1000), \\hat{n}, \\hat{K}]$。\n\n单位与格式：\n- 所有浓度 $L$、$K_{d1}$、$K_{d2}$ 以及拟合的 $\\hat{K}$ 均使用纳摩尔 (nM) 作为单位。分数占据率 $Y(L)$ 和 $\\hat{n}$ 是无量纲的。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个值都四舍五入到六位小数，例如：$[x_1,x_2,x_3,x_4,x_5,x_6,x_7]$，其中每个 $x_i$ 都是小数点后有六位数的小数表示，且不附加单位。\n\n科学真实性与约束条件：\n- 您的推导必须严格基于质量作用定律和宏观逐步解离常数的定义。除非从您使用这些参数的推导中可以得出，否则不要假设独立结合。\n- 在实现和拟合过程中，确保在指定的 $L$ 值范围内的数值稳定性。", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于化学平衡和统计力学的原理，问题设定良好，目标明确，并提供了一套完整且一致的数据和定义。该问题是生物物理化学中的一个标准练习，并且可以按所述方式解决。\n\n解决方案按要求分为两部分：首先，推导精确的分数位点占据率；其次，拟合有效 Hill 模型的数值程序。\n\n**A部分：精确分数位点占据率 $Y(L)$ 的推导**\n\n该系统由一个受体 $R$ 和一个配体 $L$ 组成，受体有两个相同的配体结合位点。结合是顺序的，意味着配体一个接一个地结合。受体的状态有未结合配体的（$R$）、单配体结合的（$RL$）和双配体结合的（$RL_2$）。这些状态之间的平衡由质量作用定律和宏观逐步解离常数 $K_{d1}$ 和 $K_{d2}$ 控制。\n\n第一个平衡反应是第一个配体的结合：\n$$R + L \\rightleftharpoons RL$$\n此步骤的宏观解离常数定义为：\n$$K_{d1} = \\frac{[R][L]}{[RL]} \\quad (1)$$\n其中 $[R]$、$[L]$ 和 $[RL]$ 分别是未结合配体的受体、游离配体和单配体结合的受体的平衡浓度。\n\n第二个平衡反应是第二个配体的结合：\n$$RL + L \\rightleftharpoons RL_2$$\n这第二步的宏观解离常数为：\n$$K_{d2} = \\frac{[RL][L]}{[RL_2]} \\quad (2)$$\n其中 $[RL_2]$ 是双配体结合的受体的平衡浓度。\n\n为了确定分数占据率，我们首先描述受体各状态的相对布居。使用结合多项式可以很方便地做到这一点，这也是该系统巨正则系综处理方法的核心。我们将已结合配体的状态浓度 $[RL]$ 和 $[RL_2]$ 用未结合配体的受体浓度 $[R]$ 和游离配体浓度 $L$ 来表示。\n\n根据方程 $(1)$：\n$$[RL] = \\frac{[R]L}{K_{d1}}$$\n根据方程 $(2)$：\n$$[RL_2] = \\frac{[RL]L}{K_{d2}}$$\n将 $[RL]$ 的表达式代入 $[RL_2]$ 的方程中：\n$$[RL_2] = \\left(\\frac{[R]L}{K_{d1}}\\right) \\frac{L}{K_{d2}} = \\frac{[R]L^2}{K_{d1}K_{d2}}$$\n\n所有受体物种的总浓度 $[R]_{\\text{total}}$ 是各个状态浓度的总和：\n$$[R]_{\\text{total}} = [R] + [RL] + [RL_2] = [R] + \\frac{[R]L}{K_{d1}} + \\frac{[R]L^2}{K_{d1}K_{d2}}$$\n提出因子 $[R]$ 后得到：\n$$[R]_{\\text{total}} = [R] \\left( 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} \\right)$$\n括号中的项是结合多项式 $P(L)$：\n$$P(L) = 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}}$$\n\n每个受体上结合的配体平均数 $\\langle \\nu \\rangle$ 是结合配体数量的统计期望值。它的计算方法是将每个状态下结合的配体数（$0$、$1$ 或 $2$）乘以观察到该状态的概率后求和。一个状态的概率是其浓度除以总受体浓度。\n$$\\langle \\nu \\rangle = \\frac{(0 \\cdot [R]) + (1 \\cdot [RL]) + (2 \\cdot [RL_2])}{[R]_{\\text{total}}}$$\n代入 $[RL]$、$[RL_2]$ 和 $[R]_{\\text{total}}$ 的表达式：\n$$\\langle \\nu \\rangle = \\frac{ \\frac{[R]L}{K_{d1}} + 2 \\frac{[R]L^2}{K_{d1}K_{d2}} }{ [R] \\left( 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} \\right) }$$\n$[R]$ 项被消掉，只留下一个依赖于 $L$ 和解离常数的表达式：\n$$\\langle \\nu \\rangle = \\frac{ \\frac{L}{K_{d1}} + \\frac{2L^2}{K_{d1}K_{d2}} }{ 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} }$$\n这个表达式也可以通过关系式 $\\langle \\nu \\rangle = L \\frac{d}{dL} \\ln(P(L))$ 从结合多项式推导出来。\n\n问题将分数位点占据率 $Y(L)$ 定义为每个受体上结合的配体平均数除以总位点数（即 $N=2$）。\n$$Y(L) = \\frac{\\langle \\nu \\rangle}{N} = \\frac{\\langle \\nu \\rangle}{2}$$\n代入 $\\langle \\nu \\rangle$ 的表达式：\n$$Y(L) = \\frac{1}{2} \\left( \\frac{ \\frac{L}{K_{d1}} + \\frac{2L^2}{K_{d1}K_{d2}} }{ 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} } \\right) = \\frac{ \\frac{L}{2K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} }{ 1 + \\frac{L}{K_{d1}} + \\frac{L^2}{K_{d1}K_{d2}} }$$\n这就是分数位点占据率的最终精确表达式。为了便于实现，通过将分子和分母同乘以 $K_{d1}K_{d2}$ 来消去分母，这在数值上是有利的：\n$$Y(L) = \\frac{ \\frac{L K_{d2}}{2} + L^2 }{ K_{d1}K_{d2} + L K_{d2} + L^2 }$$\n给定参数值 $K_{d1} = 10\\,\\text{nM}$ 和 $K_{d2} = 2\\,\\text{nM}$：\n$$Y(L) = \\frac{ L + L^2 }{ 20 + 2L + L^2 }$$\n\n**B部分：拟合有效 Hill 模型**\n\n任务是将双参数 Hill 方程 $Y_{\\text{Hill}}(L)$ 拟合到上面推导出的精确占据函数 $Y(L)$。\n$$Y_{\\text{Hill}}(L) = \\frac{L^n}{K^n + L^n}$$\n这里，$n$ 是 Hill 指数，$K$ 是有效半饱和常数。拟合是在指定的配体浓度网格上使用非线性最小二乘法进行的。\n\n1.  **数据生成**：生成一个包含 400 个配体浓度 $L_i$ 的网格，浓度范围从 $10^{-3}\\,\\text{nM}$ 到 $10^{3}\\,\\text{nM}$，呈对数间隔分布。对于每个 $L_i$，使用推导出的公式（其中 $K_{d1} = 10$，$K_{d2} = 2$）计算精确的分数占据率 $Y_i = Y(L_i)$。\n2.  **非线性最小二乘法**：目标是找到参数 $\\hat{n}$ 和 $\\hat{K}$，以最小化精确模型和 Hill 近似模型之间的残差平方和 (SSR)：\n    $$\\text{SSR}(n, K) = \\sum_{i=1}^{400} \\left( Y_i - Y_{\\text{Hill}}(L_i; n, K) \\right)^2$$\n    该优化受限于约束条件 $n \\in [0.1, 4.0]$ 和 $K \\in [10^{-6}, 10^{6}]$。\n3.  **初始猜测值**：迭代优化算法需要为参数 $(n, K)$ 提供合理的初始猜测值 ($p_0$)。\n    -   由于 $K_{d1}  K_{d2}$，协同性为正，因此我们预期 $n  1$。初始猜测值 $n_0=1.5$ 是合适的。\n    -   参数 $K$ 是 $Y_{\\text{Hill}}(L)$ 等于 $0.5$ 时的配体浓度。精确半饱和浓度（$Y(L) = 0.5$）为 $L_{0.5} = \\sqrt{K_{d1}K_{d2}} = \\sqrt{10 \\cdot 2} = \\sqrt{20} \\approx 4.47\\,\\text{nM}$。这可作为一个极佳的初始猜测值，$K_0=4.5$。\n\n实现将使用 `scipy.optimize.curve_fit` 来执行此约束非线性回归。\n\n最后，程序将计算在特定配体浓度 $L \\in \\{0, 0.01, 2, 10, 1000\\}\\,\\text{nM}$ 下的精确占据率 $Y(L)$，并附加上拟合的参数 $\\hat{n}$ 和 $\\hat{K}$，以生成最终的输出列表。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Derives and implements the exact fractional occupancy for a two-site receptor,\n    then fits an effective Hill model to the exact curve.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    # Macroscopic stepwise dissociation constants in nM.\n    Kd1 = 10.0\n    Kd2 = 2.0\n\n    # Ligand concentrations for test suite evaluation in nM.\n    L_test = [0.0, 0.01, 2.0, 10.0, 1000.0]\n\n    # --- Task A: Exact Fractional Occupancy ---\n\n    def Y_exact(L, k1, k2):\n        \"\"\"\n        Calculates the exact fractional site occupancy for a two-site receptor.\n\n        Args:\n            L (float or np.ndarray): Free ligand concentration(s) in nM.\n            k1 (float): First macroscopic dissociation constant in nM.\n            k2 (float): Second macroscopic dissociation constant in nM.\n\n        Returns:\n            float or np.ndarray: The fractional site occupancy (dimensionless).\n        \"\"\"\n        # Derived from first principles: Y(L) = (L/(2*k1) + L^2/(k1*k2)) / (1 + L/k1 + L^2/(k1*k2))\n        # Numerically stable form: Y(L) = (L*k2/2 + L^2) / (k1*k2 + L*k2 + L^2)\n        # For Kd1=10, Kd2=2, this simplifies to: Y(L) = (L + L^2) / (20 + 2L + L^2)\n        \n        # Handle the L=0 case to avoid 0/0 or precision issues, although the formula is robust.\n        L = np.asarray(L)\n        # The numerator of the rational function based on the simplified form for the specific parameters.\n        numerator = (L * k2 / 2.0) + L**2\n        # The denominator of the rational function\n        denominator = (k1 * k2) + (k2 * L) + L**2\n        \n        # Create an output array of zeros\n        occupancy = np.zeros_like(L, dtype=float)\n        # Avoid division by zero, though denominator is always positive for L>=0\n        non_zero_denom = denominator != 0\n        occupancy[non_zero_denom] = numerator[non_zero_denom] / denominator[non_zero_denom]\n        \n        # If L was a scalar, return a scalar\n        if occupancy.ndim == 0:\n            return float(occupancy)\n        return occupancy\n\n    # Calculate exact occupancies for the test suite\n    Y_test_values = [Y_exact(l, Kd1, Kd2) for l in L_test]\n\n    # --- Task B: Effective Hill Model Fit ---\n\n    def Y_hill(L, n, K):\n        \"\"\"\n        The two-parameter Hill equation for fractional occupancy.\n\n        Args:\n            L (float or np.ndarray): Free ligand concentration(s) in nM.\n            n (float): Hill coefficient (dimensionless).\n            K (float): Half-saturation constant in nM.\n\n        Returns:\n            float or np.ndarray: The approximate fractional occupancy.\n        \"\"\"\n        # To avoid overflow with large L and n, reformulate as 1 / (1 + (K/L)^n)\n        # However, for L=0, (K/L) is inf. So, we use the standard form and handle L=0.\n        L = np.asarray(L)\n        kn = K**n\n        ln = L**n\n        # Pre-allocate result array\n        occupancy = np.zeros_like(L, dtype=float)\n        # Calculate where denominator is non-zero\n        denom = kn + ln\n        non_zero_denom = denom != 0\n        occupancy[non_zero_denom] = ln[non_zero_denom] / denom[non_zero_denom]\n        \n        return occupancy\n        \n\n    # 1. Generate data for fitting\n    # Grid of L values: 400 points, log-spaced from 10^-3 to 10^3 nM.\n    L_grid = np.logspace(-3, 3, 400)\n    # Corresponding exact Y values\n    Y_data = Y_exact(L_grid, Kd1, Kd2)\n\n    # 2. Perform nonlinear least squares fitting\n    # Initial guesses: n_0=1.5 (positive cooperativity), K_0=sqrt(Kd1*Kd2)\n    p0 = [1.5, np.sqrt(Kd1 * Kd2)]\n    # Bounds for parameters: n in [0.1, 4.0], K in [1e-6, 1e6]\n    bounds = ([0.1, 1e-6], [4.0, 1e6])\n\n    # Use scipy.optimize.curve_fit\n    try:\n        popt, _ = curve_fit(Y_hill, L_grid, Y_data, p0=p0, bounds=bounds)\n        n_fit, K_fit = popt\n    except RuntimeError:\n        # Fallback in case the optimization fails, though it is not expected here\n        n_fit, K_fit = np.nan, np.nan\n\n    # --- Assemble and Format Final Output ---\n    # Aggregate results: [Y(0), Y(0.01), Y(2), Y(10), Y(1000), n_hat, K_hat]\n    results = Y_test_values + [n_fit, K_fit]\n\n    # Format the output string with 6 decimal places for each value\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2744319"}, {"introduction": "在生物系统中，信号分子很少处于一个充分混合、浓度均匀的溶液中，它们的浓度常在空间上变化。本实践将反应-扩散模型与希尔函数相结合，以在更真实的物理空间背景下探究受体的激活过程 [@problem_id:2744294]。你将学习求解细胞周围稳态的配体浓度分布，并了解局部产生和降解如何创造一个直接决定受体占有率的微环境，这一概念对于理解自分泌和旁分泌信号至关重要。", "problem": "考虑一种在单个半径为 $R$ 的球形细胞周围介质中扩散和降解的胞外配体。细胞膜以恒定的表面通量 $J_{\\text{prod}}$ 均匀地产生配体，并包含一种膜受体，其分数占有率由协同结合动力学决定。假设以下物理上真实且自洽的建模假设。\n\n- 几何与场：配体浓度呈球形对称，对于径向距离 $r \\ge R$，表示为 $L(r)$。远场、充分混合的整体浓度为 $L_g$，称为全局配体浓度。\n- 输运与反应：配体在细胞外空间中进行扩散（扩散系数为 $D$）和一级降解（速率常数为 $k_{\\text{deg}}$）。\n- 膜生成：细胞膜提供了一个均匀的配体生成通量边界条件 $-D\\,\\partial L/\\partial r|_{r=R} = J_{\\text{prod}}$。\n- 受体结合：受体不会显著隔离配体（即，受体结合不会扰动浓度场）。受体分数占有率 $\\theta$ 由 Hill 函数建模，该函数具有解离常数 $K_d$ 和 Hill 系数 $n$，并在膜上的局部配体浓度 $L(R)$ 处进行计算。\n- 首字母缩略词首次使用时必须定义：偏微分方程 (partial differential equation, PDE)，常微分方程 (ordinary differential equation, ODE)。\n\n任务。从质量守恒和 Fick 扩散第二定律出发，结合一级降解项，为 $L(r)$ 建立稳态偏微分方程 (PDE)，在 $r=R$ 和 $r \\to \\infty$ 处施加物理上正确的边界条件，并解析求解稳态浓度分布 $L(r)$。由此，求得膜浓度 $L(R)$ 作为 $D$、$k_{\\text{deg}}$、$R$、$J_{\\text{prod}}$ 和 $L_g$ 的函数。然后，使用具有 Hill 系数 $n$ 的协同结合的 Hill 函数定义，计算稳态受体占有率\n$$\n\\theta \\;=\\; \\frac{\\left(L(R)\\right)^{n}}{K_d^{\\,n}+\\left(L(R)\\right)^{n}}.\n$$\n\n单位和数值要求。\n\n- 浓度使用微摩尔/升 ($\\mu\\text{M}$)，长度使用微米 ($\\mu\\text{m}$)，时间使用秒 ($\\text{s}$)，$D$ 使用 $\\mu\\text{m}^2/\\text{s}$，$k_{\\text{deg}}$ 使用 $\\text{s}^{-1}$，$J_{\\text{prod}}$ 使用 $\\mu\\text{M}\\cdot\\mu\\text{m}/\\text{s}$。输出 $\\theta$ 是无量纲的。\n- 不涉及角度，因此不需要角度单位。\n- 所有 $\\theta$ 的最终数值输出必须四舍五入到恰好 $6$ 位小数。\n\n测试集。您的程序必须为以下参数集 $(D, k_{\\text{deg}}, R, J_{\\text{prod}}, K_d, n, L_g)$ 计算 $\\theta$，这些参数均使用上述单位表示。\n\n- 情况 $1$：$(200,\\,0.02,\\,5,\\,2.0,\\,0.5,\\,2,\\,0.3)$。\n- 情况 $2$：$(200,\\,0.02,\\,5,\\,0.0,\\,0.5,\\,2,\\,0.3)$。\n- 情况 $3$：$(200,\\,0.00,\\,5,\\,2.0,\\,0.5,\\,2,\\,0.0)$。\n- 情况 $4$：$(200,\\,0.50,\\,5,\\,5.0,\\,0.5,\\,1,\\,0.1)$。\n- 情况 $5$：$(200,\\,1.00,\\,5,\\,0.1,\\,0.5,\\,3,\\,1.0)$。\n- 情况 $6$：$(200,\\,0.05,\\,5,\\,1.0,\\,1.0,\\,3,\\,10.0)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是为情况 $i$ 计算并四舍五入到恰好 6 位小数的 $\\theta$ 值。", "solution": "我们根据质量守恒和 Fick 定律来构建问题，然后考虑协同结合平衡。\n\n1. 输运-反应模型和边界条件。\n\n- 设 $L(r)$ 表示稳态配体浓度，是半径 $r \\ge R$ 的函数。描述带有以及降解的扩散过程的控制性稳态偏微分方程 (PDE) 为\n$$\n0 \\;=\\; D\\,\\nabla^2 L(r)\\;-\\;k_{\\text{deg}}\\,L(r).\n$$\n- 根据球对称性，拉普拉斯算子简化为\n$$\n\\nabla^2 L(r) \\;=\\; \\frac{1}{r^2}\\frac{d}{dr}\\!\\left(r^2 \\frac{dL}{dr}\\right),\n$$\n因此，稳态常微分方程 (ODE) 为\n$$\n0 \\;=\\; D\\,\\frac{1}{r^2}\\frac{d}{dr}\\!\\left(r^2 \\frac{dL}{dr}\\right)\\;-\\;k_{\\text{deg}}\\,L(r), \\quad r \\ge R.\n$$\n- 在膜上 ($r=R$) 的边界条件将扩散通量与给定的生成通量等同起来：\n$$\n-\\,D\\,\\left.\\frac{dL}{dr}\\right|_{r=R} \\;=\\; J_{\\text{prod}}.\n$$\n- 远场边界条件将浓度设定为全局整体值：\n$$\n\\lim_{r\\to\\infty} L(r) \\;=\\; L_g.\n$$\n\n2. 稳态常微分方程的解。\n\n定义参数\n$$\n\\lambda \\;=\\; \\sqrt{\\frac{k_{\\text{deg}}}{D}},\n$$\n并明确当 $k_{\\text{deg}}=0$ 时，$\\lambda = 0$。引入分解 $L(r) = L_g + u(r)$，使得当 $r\\to\\infty$ 时 $u(r)\\to 0$。函数 $u(r)$ 满足\n$$\n0 \\;=\\; D\\,\\frac{1}{r^2}\\frac{d}{dr}\\!\\left(r^2 \\frac{du}{dr}\\right)\\;-\\;k_{\\text{deg}}\\,u(r).\n$$\n球对称的衰减解具有以下形式\n$$\nu(r) \\;=\\; \\frac{A\\,e^{-\\lambda\\,(r-R)}}{r},\n$$\n其中 $A$ 是一个由膜通量决定的常数。求导可得，\n$$\n\\frac{du}{dr} \\;=\\; A\\,\\left[-\\,\\frac{\\lambda\\,e^{-\\lambda\\,(r-R)}}{r}\\;-\\;\\frac{e^{-\\lambda\\,(r-R)}}{r^2}\\right].\n$$\n应用膜边界条件可得\n$$\n-\\,D\\,\\left.\\frac{dL}{dr}\\right|_{r=R}\n\\;=\\;\n-\\,D\\,\\left.\\frac{du}{dr}\\right|_{r=R}\n\\;=\\;\nD\\,A\\,\\left(\\frac{\\lambda}{R}+\\frac{1}{R^2}\\right)\n\\;=\\;\nJ_{\\text{prod}},\n$$\n这给出\n$$\nA \\;=\\; \\frac{J_{\\text{prod}}}{D\\left(\\frac{\\lambda}{R}+\\frac{1}{R^2}\\right)}.\n$$\n因此，膜浓度为\n$$\nL(R) \\;=\\; L_g \\;+\\; \\frac{A}{R}\n\\;=\\;\nL_g \\;+\\; \\frac{J_{\\text{prod}}}{R\\,D\\left(\\frac{\\lambda}{R}+\\frac{1}{R^2}\\right)}\n\\;=\\;\nL_g \\;+\\; \\frac{J_{\\text{prod}}}{D\\left(\\lambda+\\frac{1}{R}\\right)}.\n$$\n对于 $k_{\\text{deg}}=0$ 的特殊情况，有 $\\lambda=0$，上述表达式的极限为\n$$\nL(R) \\;=\\; L_g \\;+\\; \\frac{J_{\\text{prod}}\\,R}{D},\n$$\n这也可以从拉普拉斯方程的解 $u(r)=A/r$（其中 $A=J_{\\text{prod}}\\,R^2/D$）直接恢复得到。\n\n3. 协同结合与受体占有率。\n\n对于一个在平衡状态下由 Hill 模型描述的具有 $n$ 配体协同结合的受体，被占据受体的比例为\n$$\n\\theta \\;=\\; \\frac{\\left(L_{\\text{loc}}\\right)^{n}}{K_d^{\\,n}+\\left(L_{\\text{loc}}\\right)^{n}},\n$$\n其中 $L_{\\text{loc}} = L(R)$ 是膜上的局部配体浓度。此 Hill 形式源于质量作用定律，考虑平衡反应 $R + n\\,L \\rightleftharpoons RL_n$，其宏观解离常数为 $K_d$（对于 $n$ 个配体，则为 $K_d$ 的 $n$ 次方），这可得出 $[RL_n]/[R_{\\text{tot}}] = L^n/(K_d^n+L^n)$。\n\n4. 算法步骤。\n\n给定 $(D, k_{\\text{deg}}, R, J_{\\text{prod}}, K_d, n, L_g)$：\n\n- 计算 $\\lambda = \\sqrt{k_{\\text{deg}}/D}$。\n- 计算 $L(R) = L_g + J_{\\text{prod}}/\\left(D\\left(\\lambda + 1/R\\right)\\right)$。当 $k_{\\text{deg}}=0$ 时，该式连续地简化为 $L(R)=L_g+J_{\\text{prod}}\\,R/D$。\n- 计算 $\\theta = \\left(L(R)\\right)^n/\\left(K_d^n + \\left(L(R)\\right)^n\\right)$。\n- 将最终的 $\\theta$ 四舍五入到恰好 6 位小数。\n\n5. 应用于测试集。\n\n将上述步骤应用于指定的六种情况中的每一种。程序必须输出单行，其中包含按顺序排列的六个四舍五入后的值，以逗号分隔并用方括号括起来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef membrane_concentration(D, k_deg, R, J_prod, L_g):\n    \"\"\"\n    Compute steady-state ligand concentration at the membrane L(R) for\n    spherical symmetry with uniform production flux and first-order degradation.\n\n    Parameters\n    ----------\n    D : float\n        Diffusion coefficient (μm^2/s).\n    k_deg : float\n        First-order degradation rate (1/s).\n    R : float\n        Cell radius (μm).\n    J_prod : float\n        Membrane production flux (μM·μm/s).\n    L_g : float\n        Far-field global concentration (μM).\n\n    Returns\n    -------\n    L_R : float\n        Steady-state concentration at the membrane (μM).\n    \"\"\"\n    # Handle general case, including k_deg = 0 which yields lambda = 0.\n    # lambda = sqrt(k_deg / D)\n    if k_deg  0:\n        raise ValueError(\"k_deg must be nonnegative.\")\n    if D = 0 or R = 0:\n        raise ValueError(\"D and R must be positive.\")\n\n    lam = np.sqrt(k_deg / D) if k_deg > 0 else 0.0\n\n    # L(R) = L_g + J_prod / ( D * (lam + 1/R) )\n    denom = D * (lam + 1.0 / R)\n    # denom is strictly positive for D>0, R>0, lam>=0\n    L_R = L_g + J_prod / denom\n    return L_R\n\n\ndef hill_occupancy(L_local, K_d, n):\n    \"\"\"\n    Compute receptor occupancy using the Hill function.\n\n    Parameters\n    ----------\n    L_local : float\n        Local ligand concentration (μM).\n    K_d : float\n        Dissociation constant (μM).\n    n : float\n        Hill coefficient (dimensionless).\n\n    Returns\n    -------\n    theta : float\n        Fractional occupancy (dimensionless, in [0,1]).\n    \"\"\"\n    if K_d  0 or n = 0:\n        raise ValueError(\"K_d must be nonnegative and n must be positive.\")\n\n    # Handle degenerate cases robustly\n    if L_local = 0.0:\n        return 0.0\n    if K_d == 0.0:\n        # If K_d = 0, any positive L yields full occupancy in the Hill model\n        return 1.0\n\n    num = L_local ** n\n    den = (K_d ** n) + num\n    theta = num / den\n    # Clamp to [0,1] for numerical safety\n    return min(max(theta, 0.0), 1.0)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (D, k_deg, R, J_prod, K_d, n, L_g)\n    test_cases = [\n        (200.0, 0.02, 5.0, 2.0, 0.5, 2.0, 0.3),   # Case 1\n        (200.0, 0.02, 5.0, 0.0, 0.5, 2.0, 0.3),   # Case 2\n        (200.0, 0.00, 5.0, 2.0, 0.5, 2.0, 0.0),   # Case 3\n        (200.0, 0.50, 5.0, 5.0, 0.5, 1.0, 0.1),   # Case 4\n        (200.0, 1.00, 5.0, 0.1, 0.5, 3.0, 1.0),   # Case 5\n        (200.0, 0.05, 5.0, 1.0, 1.0, 3.0, 10.0),  # Case 6\n    ]\n\n    results = []\n    for D, k_deg, R, J_prod, K_d, n, L_g in test_cases:\n        L_R = membrane_concentration(D, k_deg, R, J_prod, L_g)\n        theta = hill_occupancy(L_R, K_d, n)\n        results.append(f\"{theta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2744294"}, {"introduction": "从实验数据中提取可靠的参数值是定量生物学的核心挑战之一，而统计方法的选择会显著影响结果。本练习在一个含有真实的、非均匀噪声的合成数据集上，比较了三种关键的参数估计方法——普通最小二乘法（OLS）、加权最小二乘法（WLS）和贝叶斯推断 [@problem_id:2744316]。通过这种比较分析，你将理解每种方法的假设和局限性，并认识到为什么正确地为误差结构建模（正如WLS和贝叶斯方法所做的那样）对于准确和稳健的参数估计至关重要。", "problem": "您的任务是为合成生物学中的一个协同结合模型，使用具有异方差误差的合成数据，实现并比较三种参数估计方法。该模型是源于快速平衡结合和质量作用定律的希尔函数输入输出关系。在配体浓度为 $x$ 时的可观测响应为\n$$\ny(x;\\theta) \\equiv \\frac{V_{\\max} \\, x^{n}}{K^{n} + x^{n}},\n$$\n其中参数向量为 $\\theta = (V_{\\max},K,n)$，且 $V_{\\max}  0$，$K  0$，$n  0$。您将根据以下公式生成合成观测数据 $\\{(x_i, y_i)\\}_{i=1}^{N}$：\n$$\ny_i = y(x_i;\\theta^\\star) + \\varepsilon_i,\n$$\n其中 $\\theta^\\star$ 是给定测试用例的真实参数，$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2(x_i))$ 是独立的、具有异方差的高斯误差，其方差依赖于 $x$ 但不依赖于 $\\theta$。异方差标准差定义为\n$$\n\\sigma(x) = \\sigma_0 \\left(1 + \\beta \\frac{x}{x + s}\\right),\n$$\n其中 $\\sigma_0$、$\\beta$ 和 $s$ 是已知的正常数。\n\n根据基本原理：\n- 在快速平衡条件下，具有希尔系数 $n$ 的协同系统中占据位点的分数是结合多项式项的比率，这在通过 $V_{\\max}$ 缩放后，导致了上述响应 $y(x;\\theta)$ 的希尔函数形式。\n- 普通最小二乘法 (OLS) 对应于在独立、同分布、具有恒定方差的高斯误差下的最大似然估计。它最小化未加权的残差平方和。\n- 加权最小二乘法 (WLS) 对应于在具有已知、非恒定方差的独立高斯误差下的最大似然估计。它使用根据 $\\sigma^2(x)$ 构建的已知权重，最小化一个方差加权的残差平方和。\n- 贝叶斯推断将高斯似然（具有异方差但与 $\\theta$ 无关的方差）和先验信念相结合，以获得 $\\theta$ 的后验分布。为强制正性，对参数的对数值，即 $z = (\\log V_{\\max}, \\log K, \\log n)$，设置独立的法向先验。\n\n您的程序必须：\n1.  为下面的每个测试用例生成合成数据集，通过从 $\\mathcal{N}(0,\\sigma^2(x_i))$ 中独立抽样 $\\varepsilon_i$ 来实现。为保证可复现性，使用固定的随机种子 $123456$（所有用例都使用此同一种子；不要在用例之间重置种子）。在指定的区间 $[x_{\\min}, x_{\\max}]$（包含端点）上，使用一个包含 $N$ 个点的均匀网格上的 $x_i$ 值。\n2.  实现 $\\theta$ 的三种估计器：\n    -   普通最小二乘法 (OLS)：对 $\\theta$ 最小化 $\\sum_{i=1}^{N} \\left(y_i - y(x_i;\\theta)\\right)^2$。\n    -   加权最小二乘法 (WLS)：对 $\\theta$ 最小化 $\\sum_{i=1}^{N} \\left(\\frac{y_i - y(x_i;\\theta)}{\\sigma(x_i)}\\right)^2$，使用上面定义的已知 $\\sigma(x)$。\n    -   贝叶斯（拉普拉斯近似后验）：对 $z = (\\log V_{\\max}, \\log K, \\log n)$ 设置独立的法向先验，其均值和标准差为\n        $$\n        \\mu_V = \\log(1.0), \\quad \\tau_V = 1.5,\\quad\n        \\mu_K = \\log(50.0), \\quad \\tau_K = 1.5,\\quad\n        \\mu_n = \\log(2.0), \\quad \\tau_n = 1.0.\n        $$\n        使用具有已知异方差的高斯似然，并通过最小化负对数后验来计算最大后验 (MAP) 估计 $z_{\\text{MAP}}$。然后，通过在 $z_{\\text{MAP}}$ 处评估的负对数后验的海森矩阵的逆，使用拉普拉斯近似法将 $z_{\\text{MAP}}$ 周围的后验近似为一个多元正态分布。在此近似下，$z$ 的后验分布为 $\\mathcal{N}(\\mu_z, \\Sigma_z)$，其中 $\\mu_z \\approx z_{\\text{MAP}}$。通过 $\\theta_i = \\exp(z_i)$ 分量式地转换回参数空间，会得到近似的对数正态边际后验。使用对数正态矩和分位数来计算：\n        -   一个由每个分量的后验均值给出的 $\\theta$ 估计：对于分量 $i$，$\\mathbb{E}[\\theta_i] \\approx \\exp(\\mu_{z,i} + \\tfrac{1}{2}\\Sigma_{z,ii})$。\n        -   每个分量 $i$ 的 $95\\%$ 水平边际可信区间，由 $[\\exp(\\mu_{z,i} - 1.96\\sqrt{\\Sigma_{z,ii}}), \\exp(\\mu_{z,i} + 1.96\\sqrt{\\Sigma_{z,ii}})]$ 给出。\n    在所有优化中，通过在 $z$ 空间中优化并通过指数函数映射回来强制正性。使用数值稳定的方法。必要时，限制在 $z$ 空间中一个宽泛但有限的盒子内，等效于 $V_{\\max} \\in [0.1, 5.0]$，$K \\in [0.1, 300.0]$，$n \\in [0.2, 6.0]$。\n\n3.  对于每个测试用例，计算以下量化输出：\n    -   相对于真实 $\\theta^\\star$，在所有参数上具有最小均方根相对误差的方法的索引，定义为\n        $$\n        \\mathrm{RRMSE}(\\widehat{\\theta}) \\equiv \\sqrt{\\frac{1}{3}\\sum_{j=1}^{3} \\left(\\frac{\\widehat{\\theta}_j - \\theta^\\star_j}{\\theta^\\star_j}\\right)^2 }.\n        $$\n        报告与排序 $[ \\text{OLS}, \\text{WLS}, \\text{Bayes} ]$ 映射到 $[0,1,2]$ 相对应的索引。\n    -   一个布尔值，指示WLS是否相对于OLS严格改进了方差加权的残差平方和，即是否\n        $$\n        \\sum_{i=1}^{N} \\left(\\frac{y_i - y(x_i;\\widehat{\\theta}_{\\mathrm{WLS}})}{\\sigma(x_i)}\\right)^2  \\sum_{i=1}^{N} \\left(\\frac{y_i - y(x_i;\\widehat{\\theta}_{\\mathrm{OLS}})}{\\sigma(x_i)}\\right)^2.\n        $$\n    -   一个包含三个布尔值的列表，指示 $\\theta$ 的每个分量（即，按此顺序的 $V_{\\max}$、$K$、$n$）的 $95\\%$ 水平贝叶斯可信区间是否包含真实值。\n\n测试套件（请精确使用这些值；所有数字都应解释为实标量）：\n-   用例 1：\n    -   真实参数 $\\theta^\\star = (V_{\\max},K,n) = (1.0, 30.0, 2.5)$。\n    -   网格：$N = 40$，$x_{\\min} = 0.0$，$x_{\\max} = 200.0$，均匀间隔，包含端点。\n    -   噪声参数：$\\sigma_0 = 0.03$，$\\beta = 2.0$，$s = 50.0$。\n-   用例 2：\n    -   真实参数 $\\theta^\\star = (V_{\\max},K,n) = (0.8, 10.0, 4.0)$。\n    -   网格：$N = 30$，$x_{\\min} = 0.0$，$x_{\\max} = 60.0$，均匀间隔，包含端点。\n    -   噪声参数：$\\sigma_0 = 0.02$，$\\beta = 3.0$，$s = 20.0$。\n-   用例 3：\n    -   真实参数 $\\theta^\\star = (V_{\\max},K,n) = (1.5, 100.0, 1.0)$。\n    -   网格：$N = 35$，$x_{\\min} = 0.0$，$x_{\\max} = 300.0$，均匀间隔，包含端点。\n    -   噪声参数：$\\sigma_0 = 0.05$，$\\beta = 1.5$，$s = 80.0$。\n\n实现要求：\n-   在生成任何噪声之前使用固定的随机种子 $123456$，以便所有噪声抽取都是可复现的。不要在用例之间更改种子。\n-   在 $z$ 空间中进行优化，其中 $z = (\\log V_{\\max}, \\log K, \\log n)$，并通过指数函数映射到 $\\theta$。对平滑函数使用标准的数值优化方法。确保在 $x=0$ 附近的数值稳定性。\n-   对于贝叶斯-拉普拉斯近似，通过使用有限差分法数值逼近在 $z_{\\text{MAP}}$ 处的负对数后验的二阶导数来计算海森矩阵，并将其求逆以获得 $\\Sigma_z$。如果由于数值误差导致海森矩阵不是正定的，则添加一个小的对角抖动以进行稳定。\n\n最终输出格式：\n-   您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个形式为 $[m, b, [c_V, c_K, c_n]]$ 的列表，其中 $m$ 是如上定义的方法索引，$b$ 是WLS改进的布尔值，$[c_V, c_K, c_n]$ 是三个参数的覆盖布尔值。因此，总输出必须是按用例 1、2 和 3 的顺序排列的三个此类列表的列表，例如：$[[m_1,b_1,[c_{V,1},c_{K,1},c_{n,1}]],[m_2,b_2,[c_{V,2},c_{K,2},c_{n,2}]],[m_3,b_3,[c_{V,3},c_{K,3},c_{n,3}]]]$。", "solution": "该问题提出了一个在系统生物学和生物统计学领域中有效且适定的计算任务。它要求为由希尔函数描述的协同结合模型，实现并比较三种参数估计方法——普通最小二乘法 (OLS)、加权最小二乘法 (WLS) 和通过拉普拉斯近似的贝叶斯推断。该问题具有科学依据，所有模型、假设和程序都是该领域的标准方法。所有必要的参数和条件都已提供，确保了结果的唯一性和可验证性。\n\n问题的核心是给定一组合成数据点 $\\{(x_i, y_i)\\}_{i=1}^{N}$，估计希尔函数的参数向量 $\\theta = (V_{\\max}, K, n)$，\n$$\ny(x;\\theta) = \\frac{V_{\\max} \\, x^{n}}{K^{n} + x^{n}},\n$$\n数据由具有真实参数 $\\theta^\\star$ 的模型生成，并受到独立、异方差的高斯噪声污染：\n$$\ny_i = y(x_i;\\theta^\\star) + \\varepsilon_i, \\quad \\text{其中} \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2(x_i)).\n$$\n噪声的标准差 $\\sigma(x)$ 是配体浓度 $x$ 的一个已知函数：\n$$\n\\sigma(x) = \\sigma_0 \\left(1 + \\beta \\frac{x}{x + s}\\right),\n$$\n其中 $\\sigma_0, \\beta, s$ 是给定的常数。\n\n为了强制参数的正性约束（$V_{\\max}  0, K  0, n  0$），估计在参数的对数空间中进行，即 $z = (\\log V_{\\max}, \\log K, \\log n)$。模型被重新参数化为 $y(x;\\theta(z))$。为了数值稳定性，希尔函数实现为 $y(x;z) = \\exp(z_1) \\frac{r^{\\exp(z_3)}}{1 + r^{\\exp(z_3)}}$，其中 $r = x / \\exp(z_2)$。所有优化都是在指定的边界内对 $z$ 进行的。\n\n三种估计程序由其目标函数定义，通过最小化这些函数来找到参数估计值。\n\n1.  **普通最小二乘法 (OLS)**：此方法假设误差方差恒定（同方差），对应于寻找最小化残差平方和的参数。OLS 目标函数为：\n    $$\n    S_{\\text{OLS}}(z) = \\sum_{i=1}^{N} \\left(y_i - y(x_i; \\theta(z))\\right)^2.\n    $$\n    OLS 估计值为 $\\widehat{\\theta}_{\\text{OLS}} = \\exp(\\arg\\min_{z} S_{\\text{OLS}}(z))$。\n\n2.  **加权最小二乘法 (WLS)**：此方法正确地考虑了已知的噪声异方差性。它对应于指定高斯噪声模型下的最大似然估计 (MLE)。目标是最小化残差平方和，其中每个残差由相应标准差的倒数加权。WLS 目标函数为：\n    $$\n    S_{\\text{WLS}}(z) = \\sum_{i=1}^{N} \\left(\\frac{y_i - y(x_i; \\theta(z))}{\\sigma(x_i)}\\right)^2 = \\sum_{i=1}^{N} w_i^2 \\left(y_i - y(x_i; \\theta(z))\\right)^2,\n    $$\n    其中权重为 $w_i = 1/\\sigma(x_i)$。WLS 估计值为 $\\widehat{\\theta}_{\\text{WLS}} = \\exp(\\arg\\min_{z} S_{\\text{WLS}}(z))$。\n\n3.  **使用拉普拉斯近似的贝叶斯推断**：此方法将似然（如 WLS 中）与参数的先验信念相结合。问题指定了对变换后参数 $z_j \\sim \\mathcal{N}(\\mu_j, \\tau_j^2)$ 的独立正态先验。给定数据 $y$ 时 $z$ 的后验分布由贝叶斯定理给出：$P(z|y) \\propto P(y|z) P(z)$。目标是通过最小化负对数后验来找到最大后验 (MAP) 估计 $z_{\\text{MAP}}$：\n    $$\n    L(z) = -\\log P(z|y) \\propto -\\log P(y|\\theta(z)) - \\log P(z).\n    $$\n    忽略常数项，这等价于最小化：\n    $$\n    L(z) \\propto \\frac{1}{2} \\sum_{i=1}^{N} \\left(\\frac{y_i - y(x_i; \\theta(z))}{\\sigma(x_i)}\\right)^2 + \\frac{1}{2} \\sum_{j=1}^{3} \\left(\\frac{z_j - \\mu_j}{\\tau_j}\\right)^2.\n    $$\n    找到 $z_{\\text{MAP}} = \\arg\\min_z L(z)$ 后，后验分布由一个多元正态分布 $\\mathcal{N}(\\mu_z, \\Sigma_z)$ 近似，其中 $\\mu_z = z_{\\text{MAP}}$，协方差矩阵 $\\Sigma_z$ 是在 MAP 处评估的负对数后验的海森矩阵的逆：\n    $$\n    \\Sigma_z = \\left( \\nabla_z^2 L(z) \\big|_{z=z_{\\text{MAP}}} \\right)^{-1}.\n    $$\n    海森矩阵使用有限差分进行数值计算。贝叶斯点估计是 $\\theta$ 的后验均值，对于得到的对数正态边际分布，其值为 $\\mathbb{E}[\\theta_j] \\approx \\exp(\\mu_{z,j} + \\frac{1}{2}\\Sigma_{z,jj})$。$95\\%$ 的边际可信区间由 $[\\exp(\\mu_{z,j} \\pm 1.96\\sqrt{\\Sigma_{z,jj}})]$ 给出。\n\n对于每个测试用例，程序首先使用固定的随机种子生成合成数据以保证可复现性。然后，它使用数值优化器（`scipy.optimize.minimize` 及 `L-BFGS-B` 方法）应用这三种估计程序。最后，它计算所需的度量指标：\n-   每种方法的均方根相对误差 (RRMSE)，以确定最佳的点估计。\n-   一个布尔值检查，以确认 WLS 在方差加权的残差平方和方面是否比 OLS 提供了更好的拟合。\n-   一个布尔值列表，指示真实参数是否被 $95\\%$ 的贝叶斯可信区间所包含。\n\n以下 Python 代码实现了这一完整过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Implements and compares OLS, WLS, and Bayesian parameter estimation\n    for the Hill function model with heteroscedastic noise.\n    \"\"\"\n    RNG = np.random.default_rng(123456)\n\n    def hill_function_z(x, z):\n        Vmax, K, n = np.exp(z)\n        result = np.zeros_like(x, dtype=float)\n        mask = x > 0\n        if np.any(mask):\n            ratio = x[mask] / K\n            ratio_n = np.power(ratio, n)\n            result[mask] = Vmax * ratio_n / (1.0 + ratio_n)\n        return result\n\n    def noise_std_dev(x, sigma0, beta, s):\n        return sigma0 * (1.0 + beta * x / (x + s))\n\n    def compute_hessian(f, x, h=1e-5):\n        n = len(x)\n        hessian = np.zeros((n, n))\n        f_x = f(x)\n        for i in range(n):\n            x_plus_h_i = x.copy(); x_plus_h_i[i] += h\n            x_minus_h_i = x.copy(); x_minus_h_i[i] -= h\n            hessian[i, i] = (f(x_plus_h_i) - 2 * f_x + f(x_minus_h_i)) / (h**2)\n            for j in range(i + 1, n):\n                x_pp = x.copy(); x_pp[i] += h; x_pp[j] += h\n                x_pm = x.copy(); x_pm[i] += h; x_pm[j] -= h\n                x_mp = x.copy(); x_mp[i] -= h; x_mp[j] += h\n                x_mm = x.copy(); x_mm[i] -= h; x_mm[j] -= h\n                val = (f(x_pp) - f(x_pm) - f(x_mp) + f(x_mm)) / (4 * h * h)\n                hessian[i, j] = val\n                hessian[j, i] = val\n        return hessian\n\n    test_cases = [\n        {'id': 1, 'theta_star': (1.0, 30.0, 2.5), 'grid': (40, 0.0, 200.0), 'noise': (0.03, 2.0, 50.0)},\n        {'id': 2, 'theta_star': (0.8, 10.0, 4.0), 'grid': (30, 0.0, 60.0), 'noise': (0.02, 3.0, 20.0)},\n        {'id': 3, 'theta_star': (1.5, 100.0, 1.0), 'grid': (35, 0.0, 300.0), 'noise': (0.05, 1.5, 80.0)}\n    ]\n\n    prior_params = {\n        'means': np.log(np.array([1.0, 50.0, 2.0])),\n        'stds': np.array([1.5, 1.5, 1.0])\n    }\n\n    bounds_theta = np.array([[0.1, 5.0], [0.1, 300.0], [0.2, 6.0]])\n    bounds_z = np.log(bounds_theta)\n    opt_bounds = list(zip(bounds_z[:, 0], bounds_z[:, 1]))\n    \n    z0 = prior_params['means']\n    all_results = []\n\n    for case in test_cases:\n        theta_star = np.array(case['theta_star'])\n        N, x_min, x_max = case['grid']\n        sigma0, beta, s_noise = case['noise']\n\n        x_obs = np.linspace(x_min, x_max, N)\n        y_true = hill_function_z(x_obs, np.log(theta_star))\n        sigma_vals = noise_std_dev(x_obs, sigma0, beta, s_noise)\n        noise = RNG.normal(0, sigma_vals)\n        y_obs = y_true + noise\n\n        def obj_ols(z):\n            y_pred = hill_function_z(x_obs, z)\n            return np.sum((y_obs - y_pred)**2)\n\n        weights = 1.0 / sigma_vals\n        def obj_wls(z):\n            y_pred = hill_function_z(x_obs, z)\n            return np.sum((weights * (y_obs - y_pred))**2)\n        \n        prior_ivars = 1.0 / (prior_params['stds']**2)\n        def obj_bayes_neg_log_post(z):\n            log_likelihood_term = obj_wls(z)\n            log_prior_term = np.sum(prior_ivars * ((z - prior_params['means'])**2))\n            return 0.5 * (log_likelihood_term + log_prior_term)\n\n        res_ols = minimize(obj_ols, z0, method='L-BFGS-B', bounds=opt_bounds)\n        theta_ols = np.exp(res_ols.x)\n\n        res_wls = minimize(obj_wls, z0, method='L-BFGS-B', bounds=opt_bounds)\n        theta_wls = np.exp(res_wls.x)\n\n        res_bayes = minimize(obj_bayes_neg_log_post, z0, method='L-BFGS-B', bounds=opt_bounds)\n        z_map = res_bayes.x\n\n        hessian_neg_log_post = compute_hessian(obj_bayes_neg_log_post, z_map)\n\n        eigvals = np.linalg.eigvalsh(hessian_neg_log_post)\n        if np.any(eigvals = 1e-9):\n            hessian_neg_log_post += np.eye(len(z_map)) * 1e-6\n        \n        try:\n            cov_z = np.linalg.inv(hessian_neg_log_post)\n        except np.linalg.LinAlgError:\n            cov_z = np.linalg.pinv(hessian_neg_log_post, rcond=1e-15)\n\n        theta_bayes = np.exp(z_map + 0.5 * np.diag(cov_z))\n\n        estimates = {'OLS': theta_ols, 'WLS': theta_wls, 'Bayes': theta_bayes}\n        rrmse = {name: np.sqrt(np.mean(((est - theta_star) / theta_star)**2)) for name, est in estimates.items()}\n        method_order = ['OLS', 'WLS', 'Bayes']\n        rrmse_values = [rrmse[name] for name in method_order]\n        best_method_idx = np.argmin(rrmse_values)\n\n        wls_rss_at_wls_est = obj_wls(res_wls.x)\n        wls_rss_at_ols_est = obj_wls(res_ols.x)\n        wls_improves = wls_rss_at_wls_est  wls_rss_at_ols_est\n\n        mu_z, sigma_z_diag_sqrt = z_map, np.sqrt(np.abs(np.diag(cov_z)))\n        coverage = []\n        for i in range(3):\n            lower_bound = np.exp(mu_z[i] - 1.96 * sigma_z_diag_sqrt[i])\n            upper_bound = np.exp(mu_z[i] + 1.96 * sigma_z_diag_sqrt[i])\n            is_covered = (lower_bound = theta_star[i] = upper_bound)\n            coverage.append(is_covered)\n        \n        all_results.append([best_method_idx, bool(wls_improves), [bool(c) for c in coverage]])\n    \n    def format_case_result(res):\n        m, b, c_list = res\n        c_list_str = f\"[{','.join(str(c).lower() for c in c_list)}]\"\n        return f\"[{m},{str(b).lower()},{c_list_str}]\"\n    \n    final_output_str = f\"[{','.join(format_case_result(r) for r in all_results)}]\"\n    final_output_str = final_output_str.replace(\"True\", \"true\").replace(\"False\", \"false\") # Ensure lowercase bools\n    print(final_output_str)\n\nsolve()\n```", "id": "2744316"}]}