{"hands_on_practices": [{"introduction": "深入理解调控翻译后修饰的酶（如激酶和磷酸酶）的动力学特性，是定量研究细胞信号转导的基础。本练习旨在通过一个典型的酶动力学问题，帮助您应用米氏方程来计算磷酸化反应的初始速率，并分析竞争性抑制剂的影响。掌握这些核心计算技能对于药物研发和定量生物学模型的建立至关重要。[@problem_id:2760895]", "problem": "一种合成蛋白激酶催化磷酸基团从三磷酸腺苷（ATP）转移到肽底物上。实验在无细胞系统中进行，条件是肽底物饱和，因此ATP是唯一动力学相关的底物。假设ATP的结合和转换遵循经典的单底物稳态动力学，并且下述抑制剂竞争性地结合于ATP位点。\n\n在这些条件下，给定以下ATP的参数：催化转换数 $k_{\\text{cat}} = 10\\,\\mathrm{s}^{-1}$，米氏常数 $K_{M} = 5\\,\\mu\\mathrm{M}$，总活性酶浓度 $[E]_{t} = 50\\,\\mathrm{nM}$，以及初始ATP浓度 $[S]_{0} = 2\\,\\mu\\mathrm{M}$。向体系中加入一种小分子ATP位点抑制剂，其抑制常数 $K_{i} = 100\\,\\mathrm{nM}$，最终浓度为 $[I] = 500\\,\\mathrm{nM}$。\n\n从标准的单底物酶反应方案出发，利用稳态近似和米氏常数的定义，首先推导出无抑制剂时的初始速率 $v_{0}$，然后推导出存在竞争性抑制剂（该抑制剂结合于游离酶的ATP位点）时的初始速率 $v_{i}$。使用您推导出的表达式，根据上述参数值计算 $v_{0}$ 的数值以及初始速率的倍数变化 $v_{i}/v_{0}$。将 $v_{0}$ 以 $\\mu\\mathrm{M}\\,\\mathrm{s}^{-1}$ 为单位表示，但最终答案只报告倍数变化 $v_{i}/v_{0}$。将您报告的最终数值四舍五入到四位有效数字。倍数变化是无量纲的，报告时无需任何单位。", "solution": "所述问题在科学上是合理的、提法明确，并包含唯一解所需的所有信息。所提供的概念和参数在酶动力学领域是标准的。\n我将首先从第一性原理推导所需的速率方程，然后进行数值计算。\n\n遵循米氏动力学的单底物酶催化反应的基本反应方案是：\n$$ E + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} ES \\xrightarrow{k_{\\text{cat}}} E + P $$\n其中 $E$ 是酶，$S$ 是底物，$ES$ 是酶-底物复合物，$P$ 是产物。底物结合、解离和催化的速率常数分别为 $k_1$、$k_{-1}$ 和 $k_{\\text{cat}}$。\n\n为推导初始速率 $v_0$，我们应用稳态近似，该近似假定中间复合物 $[ES]$ 的浓度随时间保持不变。\n$$ \\frac{d[ES]}{dt} = 0 $$\n$ES$ 的生成速率是 $k_1[E][S]$，其分解速率是 $(k_{-1} + k_{\\text{cat}})[ES]$。在稳态下：\n$$ k_1[E][S] = (k_{-1} + k_{\\text{cat}})[ES] $$\n重新整理可得：\n$$ [E][S] = \\frac{k_{-1} + k_{\\text{cat}}}{k_1} [ES] $$\n米氏常数 $K_M$ 定义为 $K_M = \\frac{k_{-1} + k_{\\text{cat}}}{k_1}$。因此：\n$$ [E][S] = K_M [ES] $$\n总酶浓度 $[E]_t$ 是游离酶 $[E]$ 和结合在复合物中的酶 $[ES]$ 的浓度之和。\n$$ [E]_t = [E] + [ES] $$\n由此，我们将游离酶浓度表示为 $[E] = [E]_t - [ES]$。将此代入稳态表达式中：\n$$ ([E]_t - [ES])[S] = K_M [ES] $$\n$$ [E]_t[S] - [ES][S] = K_M [ES] $$\n$$ [E]_t[S] = [ES](K_M + [S]) $$\n解出 $[ES]$：\n$$ [ES] = \\frac{[E]_t[S]}{K_M + [S]} $$\n初始反应速率 $v_0$ 是产物的生成速率，它与活性复合物 $[ES]$ 的浓度成正比。\n$$ v_0 = k_{\\text{cat}}[ES] $$\n代入 $[ES]$ 的表达式，我们得到在无抑制剂情况下的初始速率的米氏方程：\n$$ v_0 = \\frac{k_{\\text{cat}}[E]_t[S]}{K_M + [S]} $$\n\n接下来，我们考虑竞争性抑制的情况。竞争性抑制剂 $I$ 可逆地结合到游离酶 $E$ 上与底物相同的位点，形成无活性的酶-抑制剂复合物 $EI$。\n$$ E + I \\underset{k_{-i}}{\\stackrel{k_i}{\\rightleftharpoons}} EI $$\n抑制常数 $K_i$ 是此平衡的解离常数：\n$$ K_i = \\frac{[E][I]}{[EI]} $$\n在抑制剂存在下，总酶守恒方程必须考虑 $EI$ 复合物：\n$$ [E]_t = [E] + [ES] + [EI] $$\n根据 $K_i$ 的定义，我们有 $[EI] = \\frac{[E][I]}{K_i}$。将此代入守恒方程：\n$$ [E]_t = [E] + [ES] + \\frac{[E][I]}{K_i} = [E]\\left(1 + \\frac{[I]}{K_i}\\right) + [ES] $$\n$[ES]$ 的稳态条件保持不变：$[E] = K_M \\frac{[ES]}{[S]}$。代入这个 $[E]$ 的表达式：\n$$ [E]_t = K_M \\frac{[ES]}{[S]}\\left(1 + \\frac{[I]}{K_i}\\right) + [ES] $$\n提取公因式 $[ES]$：\n$$ [E]_t = [ES]\\left[ \\frac{K_M}{[S]}\\left(1 + \\frac{[I]}{K_i}\\right) + 1 \\right] = [ES] \\left[ \\frac{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]}{[S]} \\right] $$\n解出抑制剂存在时的 $[ES]$：\n$$ [ES] = \\frac{[E]_t[S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]} $$\n抑制剂存在时的初始速率 $v_i$ 仍然由 $v_i = k_{\\text{cat}}[ES]$ 给出。因此：\n$$ v_i = \\frac{k_{\\text{cat}}[E]_t[S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]} $$\n这样就完成了所需的推导。\n\n现在，我们来计算数值。给定的参数是：\n$k_{\\text{cat}} = 10\\,\\mathrm{s}^{-1}$\n$K_{M} = 5\\,\\mu\\mathrm{M}$\n$[E]_{t} = 50\\,\\mathrm{nM} = 0.05\\,\\mu\\mathrm{M}$\n$[S]_{0} = 2\\,\\mu\\mathrm{M}$ (在方程中用 $[S]$ 表示 $[S]_0$)\n$K_{i} = 100\\,\\mathrm{nM} = 0.1\\,\\mu\\mathrm{M}$\n$[I] = 500\\,\\mathrm{nM} = 0.5\\,\\mu\\mathrm{M}$\n\n首先，我们计算无抑制剂时的初始速率 $v_0$：\n$$ v_0 = \\frac{k_{\\text{cat}}[E]_t[S]}{K_M + [S]} = \\frac{(10\\,\\mathrm{s}^{-1})(0.05\\,\\mu\\mathrm{M})(2\\,\\mu\\mathrm{M})}{5\\,\\mu\\mathrm{M} + 2\\,\\mu\\mathrm{M}} = \\frac{1\\,\\mu\\mathrm{M}^2\\mathrm{s}^{-1}}{7\\,\\mu\\mathrm{M}} = \\frac{1}{7}\\,\\mu\\mathrm{M}\\,\\mathrm{s}^{-1} $$\n其数值约为 $0.1429\\,\\mu\\mathrm{M}\\,\\mathrm{s}^{-1}$。\n\n接下来，我们计算初始速率的倍数变化 $v_i/v_0$。我们可以通过将 $v_i$ 的方程除以 $v_0$ 的方程来推导这个比值的一般表达式：\n$$ \\frac{v_i}{v_0} = \\frac{\\frac{k_{\\text{cat}}[E]_t[S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]}}{\\frac{k_{\\text{cat}}[E]_t[S]}{K_M + [S]}} = \\frac{K_M + [S]}{K_M\\left(1 + \\frac{[I]}{K_i}\\right) + [S]} $$\n现在，我们将数值代入此表达式。首先，计算代表抑制剂效应的无量纲因子：\n$$ 1 + \\frac{[I]}{K_i} = 1 + \\frac{0.5\\,\\mu\\mathrm{M}}{0.1\\,\\mu\\mathrm{M}} = 1 + 5 = 6 $$\n现在，将此值与其他参数一起代入倍数变化表达式中：\n$$ \\frac{v_i}{v_0} = \\frac{5\\,\\mu\\mathrm{M} + 2\\,\\mu\\mathrm{M}}{ (5\\,\\mu\\mathrm{M})(6) + 2\\,\\mu\\mathrm{M} } = \\frac{7\\,\\mu\\mathrm{M}}{30\\,\\mu\\mathrm{M} + 2\\,\\mu\\mathrm{M}} = \\frac{7}{32} $$\n精确数值为 $7/32 = 0.21875$。\n问题要求将此值四舍五入到四位有效数字。\n$$ \\frac{v_i}{v_0} \\approx 0.2188 $$\n这是最终答案。", "answer": "$$\\boxed{0.2188}$$", "id": "2760895"}, {"introduction": "细胞内的信号调控通常涉及具有多个翻译后修饰位点的蛋白质，这些位点共同构成复杂的动态系统。本练习将带领您从单个酶促反应的分析，扩展到对一个级联磷酸化系统的建模。通过构建常微分方程（ODE）模型，您将探索系统的稳态特性，例如不同磷酸化修饰亚型的稳态分布，是如何由激酶和磷酸酶活性的相互作用所决定的。[@problem_id:2760847]", "problem": "一个合成信号模块中的底物带有恰好三个磷酸化位点，这些位点以严格的层级顺序进行修饰：激酶从位点 $1$ 到位点 $3$ 顺序添加磷酸基团，产生异构体 $S_0 \\rightarrow S_1 \\rightarrow S_2 \\rightarrow S_3$，而磷酸酶则以相反的顺序 $S_3 \\rightarrow S_2 \\rightarrow S_1 \\rightarrow S_0$ 去除磷酸基团。假设在充分混合条件下，总底物量恒定，且激酶和磷酸酶的浓度不随时间变化。以质量作用动力学定律作为唯一的动力学假设，以总底物守恒作为唯一的约束条件，建立一个最小常微分方程（ODE）模型，并用它来计算当激酶浓度变化时，各异构体的稳态分数。\n\n从以下基本依据出发：\n- 质量作用动力学定律：基元反应的速率与其反应物浓度的乘积以及一个非负速率常数成正比。\n- 总底物守恒：如果 $[S_0]$, $[S_1]$, $[S_2]$, $[S_3]$ 是各异构体的浓度，那么 $[S_0] + [S_1] + [S_2] + [S_3] = S_{\\mathrm{tot}}$ 是一个常数。\n- 充分混合、浓度不随时间变化的激酶 $[K]$ 和磷酸酶 $[P]$ 意味着每一步都遵循伪一级速率。\n\n需纳入模型的假设：\n- 激酶步骤：$S_0 \\xrightarrow{k_1 [K]} S_1$, $S_1 \\xrightarrow{k_2 [K]} S_2$, $S_2 \\xrightarrow{k_3 [K]} S_3$。\n- 磷酸酶步骤：$S_1 \\xrightarrow{h_1 [P]} S_0$, $S_2 \\xrightarrow{h_2 [P]} S_1$, $S_3 \\xrightarrow{h_3 [P]} S_2$。\n- 所有的 $k_i$ 和 $h_i$ 均为非负实常数。\n- 层级顺序禁止任何旁路反应（即不能跳过中间状态）。\n\n任务：\n- 根据这些假设，推导关于 $[S_0](t)$, $[S_1](t)$, $[S_2](t)$, $[S_3](t)$ 的最小ODE系统。\n- 从第一性原理出发，确定稳态分数 $f_i = [S_i]^*/S_{\\mathrm{tot}}$（其中 $i \\in \\{0,1,2,3\\}$）作为 $[K]$, $[P]$, $\\{k_i\\}$ 和 $\\{h_i\\}$ 的函数，其中 $[S_i]^*$ 表示稳态浓度。\n- 实现一个程序，在给定以下常数的情况下，为每个测试的激酶浓度计算稳态分数。您可以使用从ODE推导出的解析解，或者使用一个强制平稳性和守恒性的数值稳健的线性系统解法。\n\n所有测试用例中使用的常数：\n- 磷酸酶浓度 $[P] = 1.0$（任意浓度单位）。\n- 激酶催化速率常数 $k_1 = 1.0$, $k_2 = 0.5$, $k_3 = 0.2$（任意一致的单位）。\n- 磷酸酶催化速率常数 $h_1 = 1.0$, $h_2 = 1.0$, $h_3 = 1.0$（任意一致的单位）。\n- 总底物 $S_{\\mathrm{tot}}$ 可以设为任意正值；报告分数，使得 $f_0 + f_1 + f_2 + f_3 = 1$。\n\n测试组（激酶浓度 $[K]$）：\n- 情况 A（边界情况，无磷酸化驱动）：$[K] = 0.0$。\n- 情况 B（低激酶浓度）：$[K] = 0.05$。\n- 情况 C（中等激酶浓度）：$[K] = 1.0$。\n- 情况 D（高激酶浓度）：$[K] = 100.0$。\n\n要求输出：\n- 对于每种情况，输出稳态分数列表 $[f_0,f_1,f_2,f_3]$，每个值四舍五入到六位小数。\n- 将四种情况的结果，按照上面列出的相同顺序，汇总到单行中，格式为一个由方括号括起来的、以逗号分隔的列表的列表，例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n- 所有报告的量都是在 $[0,1]$ 区间内的无量纲分数。", "solution": "所述问题具有科学依据，是适定的，并包含了获得唯一解所需的所有信息。这是化学动力学和系统生物学中的一个标准练习，基于质量作用动力学和守恒定律的基本原理。因此，该问题是有效的。我们继续进行推导和求解。\n\n该系统描述了一个存在于四种磷酸化状态的底物，分别表示为 $S_0$（未磷酸化）、$S_1$（单磷酸化）、$S_2$（双磷酸化）和 $S_3$（三磷酸化）。其动力学由一个顺序、层级的磷酸化-去磷酸化机制所控制。\n\n反应网络如下：\n$$\nS_0 \\underset{h_1 [P]}{\\stackrel{k_1 [K]}{\\rightleftharpoons}} S_1 \\underset{h_2 [P]}{\\stackrel{k_2 [K]}{\\rightleftharpoons}} S_2 \\underset{h_3 [P]}{\\stackrel{k_3 [K]}{\\rightleftharpoons}} S_3\n$$\n此处，$[S_i]$ 代表异构体 $i$ 的浓度，$[K]$ 是激酶浓度，$[P]$ 是磷酸酶浓度。磷酸化的动力学常数是 $k_1$, $k_2$ 和 $k_3$，而去磷酸化的动力学常数是 $h_1$, $h_2$ 和 $h_3$。\n\n应用质量作用动力学定律，并将酶浓度 $[K]$ 和 $[P]$ 视为恒定参数（伪一级动力学），我们建立描述各异构体浓度变化率的常微分方程（ODE）系统：\n$$\n\\frac{d[S_0]}{dt} = -k_1 [K] [S_0] + h_1 [P] [S_1]\n$$\n$$\n\\frac{d[S_1]}{dt} = k_1 [K] [S_0] - (k_2 [K] + h_1 [P]) [S_1] + h_2 [P] [S_2]\n$$\n$$\n\\frac{d[S_2]}{dt} = k_2 [K] [S_1] - (k_3 [K] + h_2 [P]) [S_2] + h_3 [P] [S_3]\n$$\n$$\n\\frac{d[S_3]}{dt} = k_3 [K] [S_2] - h_3 [P] [S_3]\n$$\n该系统受总底物守恒的约束：\n$$\n[S_0](t) + [S_1](t) + [S_2](t) + [S_3](t) = S_{\\mathrm{tot}}\n$$\n将这四个微分方程相加，得到 $\\frac{d}{dt} \\sum_{i=0}^{3} [S_i] = 0$，这证实了 $S_{\\mathrm{tot}}$ 是一个守恒量。\n\n为求稳态浓度（表示为 $[S_i]^*$），我们将所有时间导数设为零：$\\frac{d[S_i]}{dt} = 0$ (对 $i \\in \\{0, 1, 2, 3\\}$)。这将得到一个线性代数方程组。由于该系统是一个线性链，稳态条件意味着细致平衡，即每个反应步骤的正向通量和反向通量相等。\n从 $\\frac{d[S_0]}{dt} = 0$，我们有：\n$$\nk_1 [K] [S_0]^* = h_1 [P] [S_1]^* \\implies [S_1]^* = \\frac{k_1 [K]}{h_1 [P]} [S_0]^*\n$$\n将此结果代入 $\\frac{d[S_1]}{dt} = 0$ 的方程，可以发现前两项相互抵消，剩下：\n$$\nk_2 [K] [S_1]^* = h_2 [P] [S_2]^* \\implies [S_2]^* = \\frac{k_2 [K]}{h_2 [P]} [S_1]^*\n$$\n类似地，从 $\\frac{d[S_2]}{dt} = 0$：\n$$\nk_3 [K] [S_2]^* = h_3 [P] [S_3]^* \\implies [S_3]^* = \\frac{k_3 [K]}{h_3 [P]} [S_2]^*\n$$\n$\\frac{d[S_3]}{dt} = 0$ 的方程给出了相同的最终关系。\n\n我们为每一步 $i$ 定义激酶与磷酸酶活性的无量纲比率：\n$$\n\\alpha_i = \\frac{k_i [K]}{h_i [P]} \\quad \\text{for } i \\in \\{1, 2, 3\\}\n$$\n使用这些比率，我们可以将所有稳态浓度用 $[S_0]^*$ 表示：\n$$\n[S_1]^* = \\alpha_1 [S_0]^*\n$$\n$$\n[S_2]^* = \\alpha_2 [S_1]^* = \\alpha_2 \\alpha_1 [S_0]^*\n$$\n$$\n[S_3]^* = \\alpha_3 [S_2]^* = \\alpha_3 \\alpha_2 \\alpha_1 [S_0]^*\n$$\n现在，我们应用守恒定律来求解 $[S_0]^*$：\n$$\nS_{\\mathrm{tot}} = [S_0]^* + [S_1]^* + [S_2]^* + [S_3]^* = [S_0]^* (1 + \\alpha_1 + \\alpha_1 \\alpha_2 + \\alpha_1 \\alpha_2 \\alpha_3)\n$$\n任务是求出稳态分数 $f_i = [S_i]^* / S_{\\mathrm{tot}}$。我们可以直接从上述关系中推导出这些分数。令分母为 $D = 1 + \\alpha_1 + \\alpha_1 \\alpha_2 + \\alpha_1 \\alpha_2 \\alpha_3$。\n分数为：\n$$\nf_0 = \\frac{[S_0]^*}{S_{\\mathrm{tot}}} = \\frac{1}{D}\n$$\n$$\nf_1 = \\frac{[S_1]^*}{S_{\\mathrm{tot}}} = \\frac{\\alpha_1 [S_0]^*}{S_{\\mathrm{tot}}} = \\frac{\\alpha_1}{D}\n$$\n$$\nf_2 = \\frac{[S_2]^*}{S_{\\mathrm{tot}}} = \\frac{\\alpha_1 \\alpha_2 [S_0]^*}{S_{\\mathrm{tot}}} = \\frac{\\alpha_1 \\alpha_2}{D}\n$$\n$$\nf_3 = \\frac{[S_3]^*}{S_{\\mathrm{tot}}} = \\frac{\\alpha_1 \\alpha_2 \\alpha_3 [S_0]^*}{S_{\\mathrm{tot}}} = \\frac{\\alpha_1 \\alpha_2 \\alpha_3}{D}\n$$\n这些解析表达式为计算稳态分数提供了一种直接而稳健的方法。另一种方法是数值求解线性方程组，在这里没有必要，但对于解析解难以处理的更复杂网络，这将是一种有效的方法。\n\n所提供的 Python 脚本将实现这些推导出的公式，使用给定的动力学参数来计算每个指定的激酶浓度 $[K]$ 测试用例的分数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state fractions of a 3-site phosphorylation system\n    for different kinase concentrations.\n    \"\"\"\n\n    # Define the constants from the problem statement.\n    P = 1.0  # Phosphatase concentration\n    k_rates = [1.0, 0.5, 0.2]  # Kinase catalytic rate constants [k1, k2, k3]\n    h_rates = [1.0, 1.0, 1.0]  # Phosphatase catalytic rate constants [h1, h2, h3]\n\n    # Define the test cases for kinase concentration [K].\n    test_cases = [\n        0.0,    # Case A: No kinase\n        0.05,   # Case B: Low kinase\n        1.0,    # Case C: Moderate kinase\n        100.0   # Case D: High kinase\n    ]\n\n    results = []\n    for K in test_cases:\n        # The analytical solution for the steady-state fractions is derived from\n        # the principle of detailed balance at steady state for a linear reaction chain.\n        # We first calculate the ratio of kinase to phosphatase activity for each step.\n        alpha1 = (k_rates[0] * K) / (h_rates[0] * P)\n        alpha2 = (k_rates[1] * K) / (h_rates[1] * P)\n        alpha3 = (k_rates[2] * K) / (h_rates[2] * P)\n\n        # The steady-state fractions f_i = [S_i] / S_tot are given by:\n        # f0 = 1 / D\n        # f1 = alpha1 / D\n        # f2 = alpha1 * alpha2 / D\n        # f3 = alpha1 * alpha2 * alpha3 / D\n        # where D is the normalization factor ensuring the sum of fractions is 1.\n\n        # Calculate the terms corresponding to the relative population of each state.\n        term0 = 1.0\n        term1 = alpha1\n        term2 = alpha1 * alpha2\n        term3 = alpha1 * alpha2 * alpha3\n\n        # Calculate the denominator D, which is the sum of these terms.\n        # Since term0 is always 1.0, D is always >= 1.0, preventing division by zero.\n        D = term0 + term1 + term2 + term3\n\n        # Calculate the fractions.\n        f0 = term0 / D\n        f1 = term1 / D\n        f2 = term2 / D\n        f3 = term3 / D\n\n        # Store the fractions, rounded to six decimal places as required.\n        fractions = [round(f, 6) for f in [f0, f1, f2, f3]]\n        results.append(fractions)\n\n    # Final print statement in the exact required format: a string representation\n    # of a list of lists, with inner lists separated by commas.\n    # e.g., [[f0A,f1A,...],[f0B,f1B,...],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2760847"}, {"introduction": "在翻译后修饰的研究中，一个核心挑战是理解激酶如何识别其特异性底物。本练习介绍了一种计算生物学方法，利用线性回归和机器学习原理（岭回归、交叉验证）来解决这一问题。您将学习如何从一组肽底物的磷酸化速率实验数据中，构建一个能够预测激酶特异性的位置特异性评分矩阵（PSSM），从而架起实验数据与分子识别定量模型之间的桥梁。[@problem_id:2760883]", "problem": "给定一组固定长度的合成短肽底物及其由激酶催化的磷酸化速率。在一个用于序列特异性蛋白质-配体相互作用的标准热力学亲和力模型中，肽 $i$ 的速率 $r_i$ 被建模为与 $\\exp(-\\Delta G_i / (R T))$ 成正比，其中 $\\Delta G_i$ 是结合自由能，$R$ 是普适气体常数，$T$ 是绝对温度。假设自由能可按位置加性分解为 $\\Delta G_i = \\sum_{p=1}^{L} E_{p, a(i,p)} + E_0$，其中 $L$ 是肽的长度，$a(i,p)$ 是肽 $i$ 中位置 $p$ 处的氨基酸，$E_{p, a}$ 是位置特异性贡献，$E_0$ 是一个基线项。由此可得，速率的自然对数 $y_i = \\ln r_i$ 可以由一个线性模型 $y_i \\approx b + \\sum_{p=1}^{L} w_{p, a(i,p)}$ 很好地近似，其中 $b$ 是一个截距，$w_{p, a}$ 是构成位置特异性评分矩阵 (PSSM) 的未知权重。该线性模型的估计可以被构建为一个带 $\\ell_2$ 正则化（岭回归）的正则化最小二乘问题，这等效于对权重施加一个零均值高斯先验。\n\n你的任务是实现一个程序，给定一个固定的数据集，包含长度 $L=7$ 的肽序列及其测量的磷酸化速率 $r_i$（单位为 $\\mathrm{s}^{-1}$），通过对每个位置氨基酸的独热编码求解岭正则化线性回归，从而推断出位置特异性评分矩阵，并使用皮尔逊相关系数在留出数据上通过 $k$ 折交叉验证评估其预测能力。交叉验证必须是确定性的，折的分配由 $f(i) = i \\bmod k$ 定义，其中 $i$ 是序列列表中从零开始的索引。在每一折中，在训练集上拟合模型，并在测试集上计算预测结果。如果测试折内真实响应或预测值的标准差为零，则按照惯例将该折的皮尔逊相关系数定义为 $0$。对于每个指定的测试用例，报告各折皮尔逊相关系数的平均值，结果为单个浮点数。\n\n需要实现的模型和编码细节：\n- 使用包含 $20$ 种标准氨基酸的字母表，顺序固定为 $[ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y}]$。\n- 通过拼接各位置的独热编码，将每个肽表示为一个长度为 $L \\times 20$ 的独热编码设计向量，并在最后追加一个常量 $1$ 作为特征以充当截距，总计 $L \\times 20 + 1$ 个特征。\n- 对于给定的正则化强度 $\\lambda > 0$，通过求解岭回归正规方程来估计权重向量 $\\hat{\\mathbf{w}}$\n$$\n\\hat{\\mathbf{w}} = \\arg\\min_{\\mathbf{w}} \\left\\| \\mathbf{y} - \\mathbf{X}\\mathbf{w} \\right\\|_2^2 + \\lambda \\left\\| \\mathbf{w} \\right\\|_2^2,\n$$\n其中 $\\mathbf{X}$ 是设计矩阵，$\\mathbf{y}$ 根据测试用例包含速率的自然对数或速率本身。使用闭式解\n$$\n\\hat{\\mathbf{w}} = \\left( \\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I} \\right)^{-1} \\mathbf{X}^\\top \\mathbf{y},\n$$\n其中 $\\mathbf{I}$ 是适当维度的单位矩阵。使用相同的 $\\lambda$ 惩罚所有系数（包括截距），以确保在多重共线性下的数值稳定性。\n\n评估指标：\n- 对于一个测试折，其真实响应为 $\\{ y_j \\}_{j \\in \\mathcal{T}}$，预测值为 $\\{ \\hat{y}_j \\}_{j \\in \\mathcal{T}}$，计算皮尔逊相关系数\n$$\nr = \\frac{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})(\\hat{y}_j - \\overline{\\hat{y}})}{\\sqrt{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})^2} \\sqrt{\\sum_{j \\in \\mathcal{T}} (\\hat{y}_j - \\overline{\\hat{y}})^2}},\n$$\n其中 $\\bar{y}$ 和 $\\overline{\\hat{y}}$ 是测试折上的均值。如果任一分母为零或折的大小小于 $2$，则定义 $r = 0$。\n\n数据集：\n- 肽长度 $L = 7$；位置 $4$ 是磷酸受体丝氨酸，并像其他任何位置一样被包含在编码中。\n- 数据集包含 $N = 24$ 个序列及其测量的速率 $r_i$（单位为 $\\mathrm{s}^{-1}$），如下所列。每个序列是基于 20 个字母的字母表的一个字符串。中心位置 $4$ 始终是 $\\mathrm{S}$。\n\n序列（按顺序）和速率 $r_i$（单位为 $\\mathrm{s}^{-1}$）：\n1. A A A S A A A → $0.135335283$\n2. R A A S A A A → $0.272531793$\n3. A R A S A A A → $0.223130160$\n4. A K A S A A A → $0.223130160$\n5. A A P S A A A → $0.082084999$\n6. A A A S P A A → $0.367879441$\n7. A A A S A D A → $0.067205513$\n8. A A A S A E A → $0.067205513$\n9. A A A S A A P → $0.082084999$\n10. R R A S P D P → $0.367879441$\n11. R K P S A E A → $0.135335283$\n12. A A A S P D A → $0.182683524$\n13. R A P S P A P → $0.272531793$\n14. A K A S P E P → $0.182683524$\n15. R K A S P A A → $1.221402758$\n16. A A A S P E A → $0.182683524$\n17. R A A S P A A → $0.740818221$\n18. A R A S A D P → $0.067205513$\n19. A A P S P A A → $0.223130160$\n20. R R P S P E A → $0.367879441$\n21. R A A S A E P → $0.082084999$\n22. A K P S P D P → $0.110803158$\n23. R K P S P D P → $0.223130160$\n24. A A A S P A P → $0.223130160$\n\n测试套件：\n实现程序以运行以下参数设置，每个设置定义一个测试用例。对于一个测试用例，如果标志 $t = 1$（开启对数转换），则响应向量为 $y_i = \\ln r_i$；如果 $t = 0$（无转换），则为 $y_i = r_i$。\n- 用例 1：$\\lambda = 0.5$, $k = 4$, $t = 1$。\n- 用例 2：$\\lambda = 5.0$, $k = 4$, $t = 1$。\n- 用例 3：$\\lambda = 0.5$, $k = 24$, $t = 1$。\n- 用例 4：$\\lambda = 0.5$, $k = 4$, $t = 0$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个用例的平均皮尔逊相关系数，格式为方括号内以逗号分隔的列表（例如，“[0.95,0.90,0.10,0.80]”）。每个条目必须是标准十进制表示法的浮点数。不应打印任何其他文本。", "solution": "该问题要求实现一个正则化线性回归模型，以根据肽的氨基酸序列预测其磷酸化速率。解决方案将使用确定性的 $k$ 折交叉验证方案进行验证。我将首先验证问题陈述，然后基于统计建模和线性代数的基本原理提供一个完整的解决方案。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n- **模型：** 速率的自然对数 $y_i = \\ln r_i$ 可由一个线性模型 $y_i \\approx b + \\sum_{p=1}^{L} w_{p, a(i,p)}$ 近似。\n- **任务：** 使用岭回归求解模型权重 $\\mathbf{w}$，并使用 $k$ 折交叉验证评估预测能力。\n- **数据集：** 提供了一组 $N=24$ 个长度为 $L=7$ 的肽及其对应的速率 $r_i$。中心位置（索引 $3$，或位置 $4$）始终是丝氨酸 (S)。\n- **特征编码：** 每个肽被转换为一个长度为 $L \\times 20 + 1 = 141$ 的特征向量，该向量使用对 $L=7$ 个位置上 $20$ 种标准氨基酸的独热编码，并加上一个常量特征 $1$ 用于模型截距。\n- **回归：** 使用岭回归，其闭式解为 $\\hat{\\mathbf{w}} = \\left( \\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I} \\right)^{-1} \\mathbf{X}^\\top \\mathbf{y}$。所有系数，包括截距，都由正则化参数 $\\lambda$ 进行惩罚。\n- **评估：** $k$ 折交叉验证，采用确定性折分配 ($i \\bmod k$)。评估指标为皮尔逊相关系数，在各折上取平均值。\n- **特殊条件：** 如果一个折的大小小于 $2$ 或者真实值或预测值的标准差为零，则该折的皮尔逊相关系数定义为 $0$。\n- **响应变量 ($y_i$)：** 可以是 $r_i$（原始速率，用例 $t=0$）或 $\\ln r_i$（对数速率，用例 $t=1$）。\n- **测试用例：** 指定了四个用例，具有不同的正则化强度 $\\lambda$、折数 $k$ 和响应变换标志 $t$。\n  - 用例 1：$\\lambda = 0.5$, $k = 4$, $t = 1$。\n  - 用例 2：$\\lambda = 5.0$, $k = 4$, $t = 1$。\n  - 用例 3：$\\lambda = 0.5$, $k = 24$, $t = 1$。\n  - 用例 4：$\\lambda = 0.5$, $k = 4$, $t = 0$。\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题基于一个标准的生物物理模型，其中结合自由能在序列位置上可加性分解。由此得到的速率常数对数的线性近似是分子生物学中定量模型（如位置特异性评分矩阵，PSSMs）的基石。\n- **良定性：** 该问题在数学上是良定的。它提供了完整的数据集、精确的模型、唯一的估计程序（岭回归的闭式解）以及确定性的评估协议。正则化项 $\\lambda \\mathbf{I}$（其中 $\\lambda > 0$）确保矩阵 $\\mathbf{X}^\\top \\mathbf{X} + \\lambda \\mathbf{I}$ 是可逆的，这至关重要，因为特征数量（$P=141$）超过了数据点数量（$N=24$），导致 $\\mathbf{X}^\\top \\mathbf{X}$ 是奇异的。\n- **客观性：** 问题陈述完全客观，使用了精确的数学和计算术语。\n- **结论：** 该问题没有科学缺陷、歧义或矛盾。这是一个在计算生物学中定义明确的标准问题。\n\n**结论：** 该问题有效。\n\n### 基于原理的解决方案设计\n\n该解决方案首先将生物序列转化为适合线性代数的数值格式，然后在交叉验证框架内应用指定的回归技术，以评估其预测性能。\n\n**1. 模型构建与特征工程**\n\n物理模型假设磷酸化速率 $r_i$ 与结合自由能 $\\Delta G_i$ 的关系为 $r_i \\propto \\exp(-\\Delta G_i / (RT))$，其中 $R$ 是气体常数，$T$ 是温度。自由能被假定为每个位置上每个氨基酸贡献的加和函数：$\\Delta G_i = E_0 + \\sum_{p=1}^{L} E_{p, a(i,p)}$。将这些结合起来可得：\n$$\n\\ln r_i = \\text{const} - \\frac{1}{RT} \\left( E_0 + \\sum_{p=1}^{L} E_{p, a(i,p)} \\right)\n$$\n这是一个形式为 $y_i = b + \\sum_{p=1}^{L} w_{p, a(i,p)}$ 的线性模型，其中 $y_i = \\ln r_i$，$b$ 是一个组合了常数的截距项，$w_{p,a}$ 是与能量贡献 $-E_{p,a}/(RT)$ 成正比的权重。\n\n为了求解这个线性模型，每个肽序列被转换成一个数值特征向量 $\\mathbf{x}_i$。我们使用独热编码。对于一个长度为 $L=7$、字母表大小为 $20$ 个氨基酸的肽，这将创建一个 $7 \\times 20 = 140$ 个元素的二元向量。每个向量附加一个额外的常量特征 $1$ 以容纳截距项 $b$。这产生了一个长度为 $P = 141$ 的特征向量 $\\mathbf{x}_i$。整个数据集由一个大小为 $N \\times P$（即 $24 \\times 141$）的设计矩阵 $\\mathbf{X}$ 表示。\n\n**2. 使用岭回归进行参数估计**\n\n权重向量 $\\mathbf{w}$（长度为 $141$，包括截距）通过最小化岭回归目标函数来估计，该函数平衡了训练数据上的平方误差和对权重大小的惩罚：\n$$\n\\hat{\\mathbf{w}} = \\arg\\min_{\\mathbf{w}} \\sum_{i=1}^{N_{\\text{train}}} (y_i - \\mathbf{x}_i^\\top \\mathbf{w})^2 + \\lambda \\sum_{j=1}^{P} w_j^2\n$$\n在矩阵表示法中，即为 $\\hat{\\mathbf{w}} = \\arg\\min_{\\mathbf{w}} \\left\\| \\mathbf{y} - \\mathbf{X}\\mathbf{w} \\right\\|_2^2 + \\lambda \\left\\| \\mathbf{w} \\right\\|_2^2$。问题指定使用直接的解析解，该解通过将目标函数的梯度设为零推导得出：\n$$\n\\hat{\\mathbf{w}} = \\left( \\mathbf{X}_{\\text{train}}^\\top \\mathbf{X}_{\\text{train}} + \\lambda \\mathbf{I} \\right)^{-1} \\mathbf{X}_{\\text{train}}^\\top \\mathbf{y}_{\\text{train}}\n$$\n这里，$\\mathbf{I}$ 是一个 $P \\times P$ 的单位矩阵。根据指示，此公式惩罚所有权重，包括截距。\n\n**3. 通过交叉验证进行评估**\n\n模型的预测能力使用 $k$ 折交叉验证进行评估。将 $N=24$ 个样本的数据集根据样本索引 $i$（从 $0$ 到 $23$）划分为 $k$ 个不相交的测试集（折）：样本 $i$ 属于第 $i \\bmod k$ 折。\n对于每一折 $j \\in \\{0, \\dots, k-1\\}$：\n- 模型在所有其他折的数据（训练集）上进行训练。\n- 训练好的模型用于对留出的第 $j$ 折（测试集）进行预测 $\\hat{\\mathbf{y}}_{\\text{test}}$。\n- 该折的性能由皮尔逊相关系数 $r_{\\text{fold}}$ 量化：\n  $$\n  r = \\frac{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})(\\hat{y}_j - \\overline{\\hat{y}})}{\\sqrt{\\sum_{j \\in \\mathcal{T}} (y_j - \\bar{y})^2} \\sqrt{\\sum_{j \\in \\mathcal{T}} (\\hat{y}_j - \\overline{\\hat{y}})^2}}\n  $$\n- 根据问题规则，如果测试折的大小小于 $2$（如 $k=24$ 的情况）或者真实响应 $\\mathbf{y}_{\\text{test}}$ 或预测值 $\\hat{\\mathbf{y}}_{\\text{test}}$ 的标准差为零，则 $r_{\\text{fold}}$ 取为 $0$。\n\n对于给定的测试用例 $(\\lambda, k, t)$，最终报告的值是 $k$ 个折相关系数的算术平均值。\n\n**4. 算法实现**\n\n总体算法如下：\n1. 定义氨基酸字母表、肽长度 $L=7$ 和特征数 $P=141$ 的常量。\n2. 实现一个函数，将肽字符串列表编码为 $N \\times P$ 的设计矩阵 $\\mathbf{X}$。\n3. 对于四个测试用例中的每一个：\n    a. 根据变换标志 $t$ 准备 $N \\times 1$ 的响应向量 $\\mathbf{y}$（使用原始速率 $\\mathbf{r}$ 或对数速率 $\\ln \\mathbf{r}$）。\n    b. 初始化一个空列表以存储各折的相关系数。\n    c. 从 `fold_idx = 0` 循环到 $k-1$：\n        i. 使用 $i \\bmod k$ 规则将 $\\mathbf{X}$ 和 $\\mathbf{y}$ 分割为 $\\mathbf{X}_{\\text{train}}$、$\\mathbf{y}_{\\text{train}}$、$\\mathbf{X}_{\\text{test}}$ 和 $\\mathbf{y}_{\\text{test}}$。\n        ii. 使用岭回归公式在训练数据上计算权重向量 $\\hat{\\mathbf{w}}$。\n        iii. 计算预测值 $\\hat{\\mathbf{y}}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\hat{\\mathbf{w}}$。\n        iv. 计算该折的皮尔逊相关系数并将其附加到列表中。\n    d. 计算各折相关系数的平均值。\n4. 存储每个用例的平均相关系数，并以指定格式打印最终结果。当 $k=24$ 时，构成留一法交叉验证，并且由于每个测试折仅包含一个样本，根据定义，每个折的相关系数为 $0$。因此，此用例的平均相关系数将为 $0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ridge regression problem for peptide phosphorylation rates\n    using k-fold cross-validation as specified.\n    \"\"\"\n    \n    # --- 1. Define Constants and Dataset ---\n    AA_ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\n    AA_TO_IDX = {aa: i for i, aa in enumerate(AA_ALPHABET)}\n    PEPTIDE_LENGTH = 7\n    N_AMINO_ACIDS = len(AA_ALPHABET)\n    N_FEATURES = PEPTIDE_LENGTH * N_AMINO_ACIDS + 1  # +1 for intercept\n\n    SEQUENCES = [\n        \"AAASAAA\", \"RAASAAA\", \"ARASAAA\", \"AKASAAA\", \"AAPSAAA\", \"AAASPAA\", \n        \"AAASADA\", \"AAASAEA\", \"AAASAAP\", \"RRASPDP\", \"RKPSAEA\", \"AAASPDA\",\n        \"RAPSPAP\", \"AKASPEP\", \"RKASPAA\", \"AAASPEA\", \"RAASPAA\", \"ARASADP\",\n        \"AAPSPAA\", \"RRPSPEA\", \"RAASAEP\", \"AKPSPDP\", \"RKPSPDP\", \"AAASPAP\"\n    ]\n    RATES = np.array([\n        0.135335283, 0.272531793, 0.223130160, 0.223130160, 0.082084999,\n        0.367879441, 0.067205513, 0.067205513, 0.082084999, 0.367879441,\n        0.135335283, 0.182683524, 0.272531793, 0.182683524, 1.221402758,\n        0.182683524, 0.740818221, 0.067205513, 0.223130160, 0.367879441,\n        0.082084999, 0.110803158, 0.223130160, 0.223130160\n    ])\n\n    test_cases = [\n        # (lambda, k, t)\n        (0.5, 4, 1),\n        (5.0, 4, 1),\n        (0.5, 24, 1),\n        (0.5, 4, 0),\n    ]\n\n    # --- 2. Helper Functions ---\n    def encode_peptides(peptides):\n        \"\"\"Converts peptide sequences into a one-hot encoded design matrix.\"\"\"\n        n_peptides = len(peptides)\n        X = np.zeros((n_peptides, N_FEATURES))\n        for i, peptide in enumerate(peptides):\n            for p, aa in enumerate(peptide):\n                if aa in AA_TO_IDX:\n                    aa_idx = AA_TO_IDX[aa]\n                    feature_idx = p * N_AMINO_ACIDS + aa_idx\n                    X[i, feature_idx] = 1.0\n        # Add the constant feature for the intercept\n        X[:, -1] = 1.0\n        return X\n\n    def pearson_correlation(y_true, y_pred):\n        \"\"\"Computes Pearson correlation coefficient with specified edge cases.\"\"\"\n        if len(y_true)  2:\n            return 0.0\n        \n        std_true = np.std(y_true)\n        std_pred = np.std(y_pred)\n        \n        if std_true == 0.0 or std_pred == 0.0:\n            return 0.0\n        \n        corr_matrix = np.corrcoef(y_true, y_pred)\n        return corr_matrix[0, 1]\n\n    def run_cross_validation(X, y, k, lambda_reg):\n        \"\"\"Performs k-fold cross-validation and returns the average Pearson correlation.\"\"\"\n        n_samples = X.shape[0]\n        indices = np.arange(n_samples)\n        fold_correlations = []\n\n        for i in range(k):\n            test_mask = (indices % k) == i\n            train_mask = ~test_mask\n            \n            X_train, X_test = X[train_mask], X[test_mask]\n            y_train, y_test = y[train_mask], y[test_mask]\n\n            if X_train.shape[0] == 0 or X_test.shape[0] == 0:\n                continue\n\n            # Solve for weights using the normal equations for ridge regression\n            XT_X = X_train.T @ X_train\n            identity = np.identity(N_FEATURES)\n            # The inverse part: (X^T X + lambda I)^-1\n            inv_matrix = np.linalg.inv(XT_X + lambda_reg * identity)\n            # The full solution for weights: (X^T X + lambda I)^-1 X^T y\n            w_hat = inv_matrix @ X_train.T @ y_train\n\n            # Make predictions on the test set\n            y_pred = X_test @ w_hat\n\n            # Calculate and store the Pearson correlation for the fold\n            corr = pearson_correlation(y_test, y_pred)\n            fold_correlations.append(corr)\n\n        return np.mean(fold_correlations) if fold_correlations else 0.0\n\n    # --- 3. Main Logic ---\n    X_full = encode_peptides(SEQUENCES)\n    results = []\n\n    for lambda_val, k_val, t_val in test_cases:\n        # Prepare the response vector y based on the transform flag 't'\n        if t_val == 1:\n            y_full = np.log(RATES)\n        else: # t_val == 0\n            y_full = RATES.copy()\n        \n        avg_corr = run_cross_validation(X_full, y_full, k_val, lambda_val)\n        results.append(avg_corr)\n\n    # --- 4. Final Output ---\n    # Format the output as a comma-separated list in brackets.\n    output_str = f\"[{','.join(f'{res:.10f}'.rstrip('0').rstrip('.') for res in results)}]\"\n    \n    # A quick replacement to ensure \"0.\" format for numbers like \".123\"\n    # and handle the zero case correctly from the calculation of Case 3.\n    final_output = []\n    for r in results:\n        if r == 0:\n            final_output.append(\"0.0\")\n        else:\n            final_output.append(str(r))\n\n    print(f\"[{','.join(final_output)}]\")\n\n\nsolve()\n```", "id": "2760883"}]}