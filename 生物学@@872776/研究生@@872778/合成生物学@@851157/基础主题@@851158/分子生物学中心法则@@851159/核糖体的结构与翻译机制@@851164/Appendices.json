{"hands_on_practices": [{"introduction": "理论知识告诉我们，tRNA的丰度是决定翻译延伸速度的关键因素。本实践练习提供了一个定量的动力学框架，用于模拟和预测过表达特定tRNA对整个蛋白质组翻译动态的全局影响 [@problem_id:2770659]。通过构建这个模型，您将学习如何量化资源（tRNA）的重新分配如何同时改变蛋白质的合成速率和翻译的保真度。", "problem": "要求您通过应用一个基于基本原理的密码子解码动力学模型，来形式化并计算过表达一种特定转运RNA (tRNA) 对全局核糖体翻译动力学的影响。您的程序必须实现以下基于基本原理的模型，从第一性原理推导所需量，并为提供的测试套件生成数值预测。所有最终输出均为无量纲的浮点小数。\n\n基本依据与建模假设：\n- 中心法则确立了信使RNA (mRNA) 由核糖体翻译，核糖体使用携带氨基酸的转运RNA (tRNA) 分子来解码密码子。\n- 在一个最小解码动力学模型中，密码子识别步骤可以由质量作用定律的比例关系来近似：成功解码一个密码子的速率与能和该密码子正确配对的同源tRNA的浓度（丰度）成正比。能形成非沃森-克里克配对或摆动样配对的近同源tRNA可能会以低得多的概率被（错误地）接受。\n- 我们将每个密码子的解码视为一个有效的一级过程，其有效速率是同源和近同源tRNA丰度的加权和。近同源tRNA的贡献通过一个惩罚因子进行降权。\n\n定义：\n- 设存在 $N_c$ 种密码子类型，索引为 $c \\in \\{0,1,\\dots,N_c-1\\}$，以及 $N_t$ 种tRNA，索引为 $t \\in \\{0,1,\\dots,N_t-1\\}$。\n- 对于每个密码子 $c$，令 $C_c$ 为同源tRNA索引的集合，$N_c$ 为近同源tRNA索引的集合。令 $p \\in (0,1)$ 为近同源惩罚，建模为近同源贡献的一个乘法因子。\n- 令 $a \\in \\mathbb{R}_{+}^{N_t}$ 为基线tRNA丰度向量。将特定tRNA $t^\\star$ 过表达一个因子 $f \\ge 1$ 以获得修改后的向量 $a'$。考虑两种模式：\n  - 无归一化：对于 $t \\ne t^\\star$，$a'_t = a_t$；对于 $t = t^\\star$，$a'_{t^\\star} = f \\, a_{t^\\star}$。\n  - 归一化以保持总tRNA质量：如上计算 $\\tilde{a}$，然后重新缩放以保持总丰度，$a'' = \\tilde{a} \\cdot \\frac{\\sum_{t} a_t}{\\sum_{t} \\tilde{a}_t}$。使用 $a''$ 作为修改后的向量。\n- 在tRNA向量 $x$ 下，密码子 $c$ 的有效解码速率为\n  $$ r_c(x) = k_e \\left( \\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t \\right), $$\n  其中 $k_e$ 是一个恒定的动力学比例因子。对于本问题，设 $k_e = 1$（任意单位），从而使速率和时间在内部保持一致，但最终输出为无量纲量。\n- 密码子 $c$ 的停留时间为 $\\tau_c(x) = 1 / r_c(x)$。\n- 考虑 $G$ 个基因，每个基因 $g \\in \\{1,\\dots,G\\}$ 是一个密码子索引序列 $\\{c_i^{(g)}\\}_{i=1}^{L_g}$，其中 $L_g$ 是基因 $g$ 中的密码子数量。基因 $g$ 的延伸时间为\n  $$ T_g(x) = \\sum_{i=1}^{L_g} \\tau_{c_i^{(g)}}(x). $$\n- 基因 $g$ 的起始速率为 $k_{\\mathrm{init},g}$ (单位 $\\mathrm{s}^{-1}$)。起始等待时间为 $\\tau_{\\mathrm{init},g} = 1 / k_{\\mathrm{init},g}$。一个简单的循环时间近似给出了基因 $g$ 每个完整蛋白质的平均合成时间为\n  $$ \\tau_{\\mathrm{cycle},g}(x) = \\tau_{\\mathrm{init},g} + T_g(x). $$\n  基因 $g$ 的平均合成速率则为\n  $$ J_g(x) = \\frac{1}{\\tau_{\\mathrm{cycle},g}(x)}. $$\n- 在 $x$ 下的总蛋白质组合成通量为\n  $$ S(x) = \\sum_{g=1}^{G} J_g(x). $$\n- 在 $x$ 下，密码子 $c$ 的近同源掺入概率为\n  $$ P_{\\mathrm{nc},c}(x) = \\frac{p \\sum_{t \\in N_c} x_t}{\\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t}, $$\n  约定如果分母为 $0$，则 $P_{\\mathrm{nc},c}(x) = 0$。\n- 每次翻译基因 $g$ 的预期近同源计数为\n  $$ E_g(x) = \\sum_{i=1}^{L_g} P_{\\mathrm{nc},c_i^{(g)}}(x). $$\n- 蛋白质组加权的近同源分数为\n  $$ F(x) = \\frac{\\sum_{g=1}^{G} J_g(x)\\, E_g(x)}{\\sum_{g=1}^{G} J_g(x)\\, L_g}. $$\n\n任务：\n- 对于下面测试套件中的每组参数，计算基线指标（$x = a$）和扰动后指标（$x =$ 在指定归一化模式下将 $t^\\star$ 过表达因子 $f$ 后的修改向量）。报告以下两个倍数变化：\n  - $S$-倍数变化 $= S(x_{\\mathrm{pert}}) / S(x_{\\mathrm{base}})$。\n  - $F$-倍数变化 $= F(x_{\\mathrm{pert}}) / F(x_{\\mathrm{base}})$。\n- 所有输出均为无量纲的浮点小数。\n\n所有测试共享的模型常数和结构：\n- 密码子数量 $N_c = 5$，索引为 $c \\in \\{0,1,2,3,4\\}$。\n- tRNA种类数量 $N_t = 3$，索引为 $t \\in \\{0,1,2\\}$。\n- 按密码子划分的同源和近同源集合：\n  - $C_0 = \\{0\\}$, $N_0 = \\{1\\}$。\n  - $C_1 = \\{0\\}$, $N_1 = \\{1\\}$。\n  - $C_2 = \\{1\\}$, $N_2 = \\{0\\}$。\n  - $C_3 = \\{2\\}$, $N_3 = \\varnothing$。\n  - $C_4 = \\{2\\}$, $N_4 = \\{0\\}$。\n- 基因和起始速率：\n  - $G = 3$ 个基因。\n  - 基因 $1$：密码子序列 $\\{0,1,2,0,1,2,3,4\\}$，长度 $L_1 = 8$，起始速率 $k_{\\mathrm{init},1} = 0.5 \\ \\mathrm{s}^{-1}$。\n  - 基因 $2$：密码子序列 $\\{3,3,4,4,3,4\\}$，长度 $L_2 = 6$，起始速率 $k_{\\mathrm{init},2} = 0.8 \\ \\mathrm{s}^{-1}$。\n  - 基因 $3$：密码子序列 $\\{2,2,2,0,1,0,1\\}$，长度 $L_3 = 7$，起始速率 $k_{\\mathrm{init},3} = 0.3 \\ \\mathrm{s}^{-1}$。\n- 基线tRNA丰度向量 $a = [30, 15, 10]$，单位为任意丰度单位。\n\n测试套件（每个测试定义 $(t^\\star, f, \\text{normalize}, p)$）：\n- 测试 $1$：$t^\\star = 1$, $f = 1$, $\\text{normalize} = \\text{False}$, $p = 0.02$。\n- 测试 $2$：$t^\\star = 1$, $f = 3$, $\\text{normalize} = \\text{True}$, $p = 0.02$。\n- 测试 $3$：$t^\\star = 1$, $f = 3$, $\\text{normalize} = \\text{False}$, $p = 0.02$。\n- 测试 $4$：$t^\\star = 0$, $f = 10$, $\\text{normalize} = \\text{True}$, $p = 0.10$。\n\n您的程序必须：\n- 完全按照上述规定实现模型。\n- 对于每个测试，计算相对于基线 $x = a$（使用该测试的 $p$ 和归一化设置）的两个倍数变化：$S$-倍数变化和 $F$-倍数变化（注意，当 $f=1$ 时，倍数变化应恰好为 $1$）。\n- 生成单行输出，包含一个用方括号括起来的逗号分隔列表，其顺序为\n  $$[S\\text{-fold}_1, F\\text{-fold}_1, S\\text{-fold}_2, F\\text{-fold}_2, S\\text{-fold}_3, F\\text{-fold}_3, S\\text{-fold}_4, F\\text{-fold}_4].$$\n- 每个浮点数应四舍五入到 $6$ 位小数。", "solution": "问题陈述在计算系统生物学领域提出了一个有效且定义明确的挑战。它要求实现一个核糖体翻译的动力学模型，以定量评估tRNA过表达对全局蛋白质合成效率和准确性的影响。该模型是根据该领域常用的第一性原理构建的，例如用于密码子解码的质量作用动力学和用于蛋白质合成速率的简单循环时间近似。所有必要的参数、定义和函数都已提供，没有歧义或矛盾。该问题具有科学依据、客观且自成体系，因此允许一个直接而严谨的解决方案。\n\n我们将首先形式化模型中定义的所有量的计算。主要目标是计算两个指标：总蛋白质组合成通量，记为 $S(x)$，以及蛋白质组加权的近同源分数，$F(x)$，其中 $x$ 代表tRNA丰度向量。这些指标将针对基线tRNA丰度向量 $a$ 和一个由过表达特定tRNA产生的扰动向量 $x_{\\text{pert}}$ 进行计算。\n\n**1. 基本量：解码速率和停留时间**\n解码密码子 $c$ 的速率取决于其同源tRNA（集合 $C_c$）和近同源tRNA（集合 $N_c$）的浓度。给定动力学比例常数 $k_e = 1$ 和近同源惩罚 $p$，有效解码速率 $r_c(x)$ 为：\n$$ r_c(x) = \\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t $$\n解码密码子 $c$ 所需的平均时间，即停留时间 $\\tau_c(x)$，是该速率的倒数，这是遵循一级动力学过程的标准假设：\n$$ \\tau_c(x) = \\frac{1}{r_c(x)} $$\n提供的tRNA丰度是严格为正的，这确保了对于所有至少有一个同源或近同源tRNA的密码子，$r_c(x)  0$ 且 $\\tau_c(x)$ 是一个有限的正值。\n\n**2. 基因水平指标：延伸时间和合成速率**\n对于一个由密码子序列 $\\{c_i^{(g)}\\}_{i=1}^{L_g}$ 定义的基因 $g$，核糖体合成多肽链所需的总时间，即延伸时间 $T_g(x)$，是其序列中每个密码子停留时间的总和：\n$$ T_g(x) = \\sum_{i=1}^{L_g} \\tau_{c_i^{(g)}}(x) $$\n一个完整蛋白质的合成涉及起始和延伸两个过程。平均循环时间 $\\tau_{\\mathrm{cycle},g}(x)$ 是起始等待时间 $\\tau_{\\mathrm{init},g} = 1/k_{\\mathrm{init},g}$ 和延伸时间的总和：\n$$ \\tau_{\\mathrm{cycle},g}(x) = \\tau_{\\mathrm{init},g} + T_g(x) $$\n基因 $g$ 的蛋白质合成速率 $J_g(x)$，代表蛋白质生产通量，是循环时间的倒数：\n$$ J_g(x) = \\frac{1}{\\tau_{\\mathrm{cycle},g}(x)} $$\n\n**3. 蛋白质组水平指标：总通量和错误分数**\n总蛋白质组合成通量 $S(x)$，是系统中所有基因合成速率的总和：\n$$ S(x) = \\sum_{g=1}^{G} J_g(x) $$\n翻译并非完全精确。在密码子 $c$ 处由于近同源tRNA而掺入错误氨基酸的概率 $P_{\\mathrm{nc},c}(x)$ 是近同源解码速率与总解码速率的比值：\n$$ P_{\\mathrm{nc},c}(x) = \\frac{p \\sum_{t \\in N_c} x_t}{\\sum_{t \\in C_c} x_t + p \\sum_{t \\in N_c} x_t} = p \\cdot \\tau_c(x) \\sum_{t \\in N_c} x_t $$\n在单次翻译基因 $g$ 过程中，此类错误的期望数 $E_g(x)$ 是该基因序列上这些概率的总和：\n$$ E_g(x) = \\sum_{i=1}^{L_g} P_{\\mathrm{nc},c_i^{(g)}}(x) $$\n翻译不忠实性的全局度量，即蛋白质组加权的近同源分数 $F(x)$，是所有基因的近同源掺入总速率除以所有密码子掺入的总速率。其公式为：\n$$ F(x) = \\frac{\\sum_{g=1}^{G} J_g(x)\\, E_g(x)}{\\sum_{g=1}^{G} J_g(x)\\, L_g} $$\n这个量代表每个密码子的平均错误概率，按每个基因的表达水平和长度加权。\n\n**4. tRNA丰度扰动**\n该问题分析了系统对将特定tRNA $t^\\star$ 过表达一个因子 $f \\ge 1$ 的响应。基线状态由tRNA丰度向量 $x_{\\text{base}} = a$ 定义。扰动状态向量 $x_{\\text{pert}}$ 通过以下两种方式之一生成：\n- **无归一化：** tRNA $t^\\star$ 的丰度增加，而其他tRNA的丰度保持不变：\n  $$ (x_{\\text{pert}})_t = \\begin{cases} f \\cdot a_{t^\\star}  \\text{if } t = t^\\star \\\\ a_t  \\text{if } t \\ne t^\\star \\end{cases} $$\n- **归一化：** 首先如上创建中间向量 $\\tilde{a}$。然后，对所有分量进行重新缩放，以保持基线状态的总tRNA质量 $\\sum_t a_t$：\n  $$ x_{\\text{pert}} = \\tilde{a} \\cdot \\frac{\\sum_{t} a_t}{\\sum_{t} \\tilde{a}_t} $$\n\n**5. 计算策略**\n对于由 $(t^\\star, f, \\text{normalize}, p)$ 指定的每个测试用例，执行以下步骤：\n1.  使用 $x_{\\text{base}} = a$ 和测试用例中的 $p$ 值计算基线指标 $S(x_{\\text{base}})$ 和 $F(x_{\\text{base}})$。\n2.  根据给定的 $t^\\star$、$f$ 和归一化模式计算扰动后的tRNA向量 $x_{\\text{pert}}$。\n3.  使用这个新向量和相同的 $p$ 值计算扰动后的指标 $S(x_{\\text{pert}})$ 和 $F(x_{\\text{pert}})$。\n4.  最终结果是倍数变化：$S\\text{-fold} = S(x_{\\mathrm{pert}}) / S(x_{\\mathrm{base}})$ 和 $F\\text{-fold} = F(x_{\\mathrm{pert}}) / F(x_{\\mathrm{base}})$。除以零不是问题，因为在给定的问题参数下，基线指标不会为零。\n\n对于测试 $1$，其中 $f=1$，扰动为空（$x_{\\text{pert}} = x_{\\text{base}}$），正确地得出 $1.0$ 的倍数变化。这为实现提供了一个必要的合理性检查。所有测试用例的数值结果均由提供的程序计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the kinetic model of translation to compute the effects of tRNA overexpression.\n    \"\"\"\n    # --- Shared Model Constants and Structures ---\n    N_c = 5  # Number of codon types\n    N_t = 3  # Number of tRNA species\n    G = 3    # Number of genes\n\n    # Cognate and near-cognate sets (0-indexed)\n    cognate_sets = [[0], [0], [1], [2], [2]]\n    near_cognate_sets = [[1], [1], [0], [], [0]]\n\n    # Gene definitions\n    genes = [\n        {'seq': np.array([0, 1, 2, 0, 1, 2, 3, 4]), 'k_init': 0.5},\n        {'seq': np.array([3, 3, 4, 4, 3, 4]), 'k_init': 0.8},\n        {'seq': np.array([2, 2, 2, 0, 1, 0, 1]), 'k_init': 0.3}\n    ]\n    gene_lengths = np.array([len(g['seq']) for g in genes])\n    k_init_inv = np.array([1.0 / g['k_init'] for g in genes])\n    gene_sequences = [g['seq'] for g in genes]\n\n    # Baseline tRNA abundance vector\n    a_base = np.array([30.0, 15.0, 10.0])\n    total_trna_base = np.sum(a_base)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (t_star, f, normalize, p)\n        (1, 1.0, False, 0.02),\n        (1, 3.0, True, 0.02),\n        (1, 3.0, False, 0.02),\n        (0, 10.0, True, 0.10)\n    ]\n\n    # Pre-calculate sums for cognate and near-cognate tRNA indices\n    # This avoids repeated lookups and allows for vectorized calculations\n    cognate_masks = np.zeros((N_c, N_t), dtype=bool)\n    near_cognate_masks = np.zeros((N_c, N_t), dtype=bool)\n    for c in range(N_c):\n        if cognate_sets[c]:\n            cognate_masks[c, cognate_sets[c]] = True\n        if near_cognate_sets[c]:\n            near_cognate_masks[c, near_cognate_sets[c]] = True\n    \n    def calculate_metrics(x, p):\n        \"\"\"\n        Calculates all model metrics for a given tRNA vector x and penalty p.\n        \"\"\"\n        # 1. Codon decoding rates and probabilities\n        cognate_sums = cognate_masks @ x\n        near_cognate_sums = near_cognate_masks @ x\n\n        r_c = cognate_sums + p * near_cognate_sums\n        \n        # Handle division by zero, although not expected here\n        tau_c = np.divide(1.0, r_c, out=np.zeros_like(r_c), where=r_c!=0)\n        \n        rate_of_nc_incorp = p * near_cognate_sums\n        p_nc_c = np.divide(rate_of_nc_incorp, r_c, out=np.zeros_like(r_c), where=r_c!=0)\n\n        # 2. Gene-level metrics\n        T_g = np.array([np.sum(tau_c[seq]) for seq in gene_sequences])\n        tau_cycle_g = k_init_inv + T_g\n        J_g = 1.0 / tau_cycle_g\n        E_g = np.array([np.sum(p_nc_c[seq]) for seq in gene_sequences])\n\n        # 3. Proteome-level metrics\n        S = np.sum(J_g)\n        \n        F_numerator = np.sum(J_g * E_g)\n        F_denominator = np.sum(J_g * gene_lengths)\n        \n        F = F_numerator / F_denominator if F_denominator != 0 else 0.0\n        \n        return S, F\n\n    results = []\n    \n    for t_star, f, normalize, p in test_cases:\n        # Calculate baseline metrics for the current test's p\n        S_base, F_base = calculate_metrics(a_base, p)\n\n        # Generate perturbed tRNA vector\n        x_pert = np.copy(a_base)\n        x_pert[t_star] *= f\n\n        if normalize:\n            total_trna_pert = np.sum(x_pert)\n            if total_trna_pert != 0:\n                x_pert *= (total_trna_base / total_trna_pert)\n        \n        # Calculate perturbed metrics\n        S_pert, F_pert = calculate_metrics(x_pert, p)\n\n        # Compute and append fold-changes\n        S_fold = S_pert / S_base if S_base != 0 else 0.0\n        F_fold = F_pert / F_base if F_base != 0 else 0.0\n        \n        results.extend([S_fold, F_fold])\n\n    # Format output to 6 decimal places and print\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2770659"}, {"introduction": "在tRNA丰度的基础上，更进一步的调控层在于其功能状态，即氨酰化（“充电”）水平。本练习引入了更为精确的米氏动力学模型，以探索细胞应激如何通过改变tRNA充电水平，从而选择性地重编程具有不同密码子偏好性的基因的翻译 [@problem_id:2770734]。这个实践将帮助您理解翻译速率如何动态地响应细胞内部的生理状态变化。", "problem": "您正在模拟应激条件下转运RNA (tRNA) 的负载动态如何改变核糖体延伸，从而影响具有不同密码子组成的基因的蛋白质产量。您必须明确并严格地使用以下基本出发点来推导您的算法：(i) 分子生物学中心法则指出，翻译是通过核糖体解码信使RNA (mRNA) 上的密码子来生产蛋白质的，每个密码子对应一个氨基酸；(ii) 每个延伸步骤都需要一个同源的氨酰-tRNA（负载tRNA）作为三元复合物的一部分被递送；(iii) 核糖体催化的肽键形成和解码过程相对于同源三元复合物的浓度是一个可饱和过程，并且可以很好地用米氏-孟顿动力学来描述。假设密码子类别 $i$ 的三元复合物的可用性与相应tRNA池的负载分数 $f_i$ 成正比。将任何总比例常数视为在比率中被抵消，因此无需估算。\n\n此问题中的定义：\n- 存在 $3$ 个密码子类别，索引为 $i \\in \\{1,2,3\\}$。对于一个给定的基因，设 $n_i$ 为类别 $i$ 的密码子数量，因此总长度为 $L = \\sum_{i=1}^{3} n_i$ 个密码子。\n- 基线负载分数为 $f_i^{(0)} \\in (0,1]$。在特定应激条件下，负载分数通过应激缩放因子 $s_i  0$ 进行乘法变化，并以完全负载为上限：$f_i^{(s)} = \\min\\{1,\\; f_i^{(0)} \\cdot s_i\\}$。不进行跨类别的重新归一化。\n- 对于密码子类别 $i$，核糖体的延伸转换率是与负载分数成正比的同源三元复合物浓度的饱和函数。设 $k_{\\text{cat}}$ 为最大转换率（单位为 $\\mathrm{s}^{-1}$），$K_M$ 为米氏常数（单位为任意浓度单位，已归一化，以便负载分数可用作比例替代物）；每次翻译事件的起始开销是一个恒定时间 $t_{\\text{init}}$（单位为 $\\mathrm{s}$），与延伸动力学无关。\n- 对于在某个条件（基线或应激）下，具有密码子数 $\\{n_i\\}$ 和负载分数 $\\{f_i\\}$ 的基因，总延伸时间是所有密码子上每个密码子停留时间之和，而每条mRNA的蛋白质生产速率 $R$ 是起始时间与总延伸时间之和的倒数。\n- 每个测试用例要报告的指标是指定基因和条件下，应激与基线之间蛋白质产量的倍数变化，定义为 $\\rho = R^{(s)} / R^{(0)}$，这是一个无量纲量。\n\n您的任务：\n- 仅从上述原则出发，推导一个显式算法，用于计算任何给定参数集的 $\\rho$。\n- 在一个程序中实现此算法，以评估以下测试套件。对于每个测试用例，计算倍数变化 $\\rho$ 并将报告值四舍五入到 $6$ 位小数。报告的倍数变化没有物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[0.923451,1.102300,1.000000,0.750000]\"）。\n\n常数和测试套件：\n- 在所有测试用例中，有 $3$ 个密码子类别，其密码子数 $(n_1,n_2,n_3)$、基线负载分数 $(f_1^{(0)},f_2^{(0)},f_3^{(0)})$ 和应激缩放因子 $(s_1,s_2,s_3)$ 均已给定。使用给定的 $k_{\\text{cat}}$ 和 $K_M$ 以及起始时间 $t_{\\text{init}}$。\n- 测试用例 1 （平衡组成，中度应激使负载从类别 3 转移，并略微偏向类别 2）：$(n_1,n_2,n_3) = (100,100,100)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.6,1.05,0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n- 测试用例 2 （基因富含应激耗尽的类别 3）：$(n_1,n_2,n_3) = (60,40,300)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.6,1.05,0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n- 测试用例 3 （基因富含略微有利的类别 2）：$(n_1,n_2,n_3) = (60,300,40)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.6,1.05,0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n- 测试用例 4 （边界情况，类别 1 使用率为零，类别 1 和 3 严重耗尽，类别 2 强烈增加且必须以完全负载为上限）：$(n_1,n_2,n_3) = (0,200,200)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.05,1.5,0.05)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.05$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n\n最终输出格式：\n- 您的程序必须精确打印一行：一个包含四个按测试用例顺序排列的四舍五入倍数变化值的列表字面量，格式为用方括号括起来的逗号分隔列表。", "solution": "在尝试任何解决方案之前，对问题陈述进行了严格验证。\n\n### 步骤 1：提取给定信息\n\n明确提供了以下数据、定义和条件：\n- **密码子类别**：$3$ 个类别，索引为 $i \\in \\{1,2,3\\}$。\n- **基因组成**：对于一个给定的基因，$n_i$ 是类别 $i$ 的密码子数量。总长度为 $L = \\sum_{i=1}^{3} n_i$。\n- **基线负载分数**：$f_i^{(0)} \\in (0,1]$。\n- **应激诱导的负载分数**：$f_i^{(s)} = \\min\\{1,\\; f_i^{(0)} \\cdot s_i\\}$，其中 $s_i  0$ 是应激缩放因子。不发生重新归一化。\n- **延伸动力学**：核糖体对密码子类别 $i$ 的延伸转换率遵循米氏-孟顿动力学，其中同源三元复合物的浓度与负载分数 $f_i$ 成正比。\n- **动力学参数**：$k_{\\text{cat}}$ 是最大转换率（单位为 $\\mathrm{s}^{-1}$），$K_M$ 是米氏常数。\n- **起始时间**：每次翻译事件需要一个恒定的开销时间 $t_{\\text{init}}$（单位为 $\\mathrm{s}$）。\n- **总延伸时间**：所有密码子上每个密码子停留时间之和。\n- **蛋白质生产速率**：对于具有密码子数 $\\{n_i\\}$ 和负载分数 $\\{f_i\\}$ 的基因，每条mRNA的速率 $R$ 是起始时间与总延伸时间之和的倒数。\n- **指标**：蛋白质产量的倍数变化，$\\rho = R^{(s)} / R^{(0)}$，其中 $R^{(s)}$ 和 $R^{(0)}$ 分别是应激和基线条件下的速率。\n- **测试用例 1**：$(n_1,n_2,n_3) = (100,100,100)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.6,1.05,0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n- **测试用例 2**：$(n_1,n_2,n_3) = (60,40,300)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.6,1.05,0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n- **测试用例 3**：$(n_1,n_2,n_3) = (60,300,40)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.6,1.05,0.4)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.2$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n- **测试用例 4**：$(n_1,n_2,n_3) = (0,200,200)$, $(f_1^{(0)},f_2^{(0)},f_3^{(0)}) = (0.7,0.8,0.9)$, $(s_1,s_2,s_3) = (0.05,1.5,0.05)$, $k_{\\text{cat}} = 12\\,\\mathrm{s}^{-1}$, $K_M = 0.05$, $t_{\\text{init}} = 0.5\\,\\mathrm{s}$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据指定标准对问题进行评估：\n1.  **科学依据**：该问题基于分子生物学中心法则，并采用米氏-孟顿模型来描述酶动力学。这是生物物理学和分子系统生物学中用于建模翻译延伸的标准且成熟的框架。这些假设在科学上是合理的，没有违反基本原则。\n2.  **适定性**：问题提供了计算唯一解所需的所有必要定义、常数和参数。变量之间的关系被明确定义。对参数的约束（$f_i^{(0)} \\in (0,1]$, $s_i  0$）避免了如除以零之类的数学奇点。\n3.  **客观性**：问题以精确、定量的术语陈述。目标是基于清晰阐述的模型计算一个特定的、数值定义好的指标（$\\rho$）。它没有主观或模糊的语言。\n4.  **完整性与一致性**：设置既完整又自洽。测试用例没有缺失参数，也没有相互矛盾的约束。\n5.  **现实性**：虽然是对真实生物复杂性的简化，但该模型是翻译动力学的一个合理且常用的表示。参数值在现实的生物物理范围内。\n\n该问题不存在任何列出的缺陷。它是一项直接的生物物理建模任务。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。将推导并实施一个解决方案。\n\n### 算法推导\n\n目标是计算蛋白质生产速率的倍数变化，$\\rho = R^{(s)} / R^{(0)}$。这需要从给定的原则中推导出速率 $R$ 的表达式。\n\n$1$. 蛋白质生产速率 $R$ 定义为合成单个多肽链所需总时间的倒数。这个总时间 $T_{\\text{total}}$ 是恒定的起始时间 $t_{\\text{init}}$ 和总延伸时间 $T_{\\text{elong}}$ 之和。\n$$ R = \\frac{1}{T_{\\text{total}}} = \\frac{1}{t_{\\text{init}} + T_{\\text{elong}}} $$\n\n$2$. 总延伸时间 $T_{\\text{elong}}$ 是翻译mRNA序列中每个密码子所需单个时间之和。对于一个具有 $n_i$ 个类别 $i$ 密码子的基因，这表示为：\n$$ T_{\\text{elong}} = \\sum_{i=1}^{3} n_i \\cdot \\tau_i $$\n其中 $\\tau_i$ 是类别 $i$ 单个密码子的平均停留时间或处理时间。\n\n$3$. 停留时间 $\\tau_i$ 是类别 $i$ 延伸速率的倒数，我们将其表示为 $k_i$。\n$$ \\tau_i = \\frac{1}{k_i} $$\n问题陈述该延伸速率相对于同源三元复合物的浓度遵循米氏-孟顿动力学。该复合物的浓度被假定为与负载tRNA分数 $f_i$ 成正比。速率 $k_i$ 的米氏-孟顿方程为：\n$$ k_i = k_{\\text{cat}} \\frac{[S]}{K_M + [S]} $$\n其中 $[S]$ 代表底物浓度。根据问题明确的归一化规则，我们用 $f_i$ 替代 $[S]$。\n$$ k_i = k_{\\text{cat}} \\frac{f_i}{K_M + f_i} $$\n该速率的单位是 $\\mathrm{s}^{-1}$，因此停留时间 $\\tau_i$ 的单位正确地为秒。\n\n$4$. 将 $k_i$ 的表达式代入 $\\tau_i$ 的方程中：\n$$ \\tau_i = \\frac{1}{k_{\\text{cat}} \\frac{f_i}{K_M + f_i}} = \\frac{K_M + f_i}{k_{\\text{cat}} \\cdot f_i} $$\n\n$5$. 现在，将此 $\\tau_i$ 的表达式代入总延伸时间 $T_{\\text{elong}}$ 的公式中：\n$$ T_{\\text{elong}}(\\{f_i\\}, \\{n_i\\}) = \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i}{k_{\\text{cat}} \\cdot f_i} \\right) $$\n现在，对负载分数集 $\\{f_i\\}$ 和密码子数集 $\\{n_i\\}$ 的依赖关系是明确的。\n\n$6$. 因此，合成一个蛋白质的总时间是：\n$$ T_{\\text{total}}(\\{f_i\\}, \\{n_i\\}) = t_{\\text{init}} + \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i}{k_{\\text{cat}} \\cdot f_i} \\right) $$\n\n$7$. 我们必须计算两种条件下的总时间：基线 (0) 和应激 (s)。\n- 对于基线条件，负载分数为 $\\{f_i^{(0)}\\}$。总时间为：\n$$ T_{\\text{total}}^{(0)} = t_{\\text{init}} + \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i^{(0)}}{k_{\\text{cat}} \\cdot f_i^{(0)}} \\right) $$\n- 对于应激条件，负载分数 $\\{f_i^{(s)}\\}$ 计算为 $f_i^{(s)} = \\min\\{1, f_i^{(0)} \\cdot s_i\\}$。总时间为：\n$$ T_{\\text{total}}^{(s)} = t_{\\text{init}} + \\sum_{i=1}^{3} n_i \\left( \\frac{K_M + f_i^{(s)}}{k_{\\text{cat}} \\cdot f_i^{(s)}} \\right) $$\n\n$8$. 各自的蛋白质生产速率为 $R^{(0)} = 1 / T_{\\text{total}}^{(0)}$ 和 $R^{(s)} = 1 / T_{\\text{total}}^{(s)}$。所要求的倍数变化 $\\rho$ 是这些速率的比值：\n$$ \\rho = \\frac{R^{(s)}}{R^{(0)}} = \\frac{1 / T_{\\text{total}}^{(s)}}{1 / T_{\\text{total}}^{(0)}} = \\frac{T_{\\text{total}}^{(0)}}{T_{\\text{total}}^{(s)}} $$\n\n这是该算法的最终显式公式。实现过程将为每个测试用例计算 $T_{\\text{total}}^{(0)}$ 和 $T_{\\text{total}}^{(s)}$，然后计算它们的比率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the fold-change in protein output between stress and baseline conditions\n    for a series of test cases based on a Michaelis-Menten model of ribosome elongation.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries for clarity.\n    # Each dictionary contains all parameters for one test case.\n    test_cases = [\n        {\n            \"n\": np.array([100, 100, 100]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.6, 1.05, 0.4]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.2,\n            \"t_init\": 0.5\n        },\n        {\n            \"n\": np.array([60, 40, 300]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.6, 1.05, 0.4]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.2,\n            \"t_init\": 0.5\n        },\n        {\n            \"n\": np.array([60, 300, 40]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.6, 1.05, 0.4]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.2,\n            \"t_init\": 0.5\n        },\n        {\n            \"n\": np.array([0, 200, 200]),\n            \"f0\": np.array([0.7, 0.8, 0.9]),\n            \"s\": np.array([0.05, 1.5, 0.05]),\n            \"k_cat\": 12.0,\n            \"K_M\": 0.05,\n            \"t_init\": 0.5\n        }\n    ]\n\n    results = []\n\n    def calculate_total_time(n, f, k_cat, K_M, t_init):\n        \"\"\"\n        Helper function to calculate the total time for protein synthesis.\n        \"\"\"\n        # Calculate per-codon dwell time tau_i = (K_M + f_i) / (k_cat * f_i)\n        # The problem constraints ensure f_i > 0, so no division by zero.\n        # Vectorized calculation for efficiency.\n        tau = (K_M + f) / (k_cat * f)\n        \n        # Calculate total elongation time T_elong = sum(n_i * tau_i)\n        T_elong = np.sum(n * tau)\n        \n        # Return total time: initiation + elongation\n        return t_init + T_elong\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        n, f0, s = case[\"n\"], case[\"f0\"], case[\"s\"]\n        k_cat, K_M, t_init = case[\"k_cat\"], case[\"K_M\"], case[\"t_init\"]\n\n        # Calculate charged fractions under stress, capped at 1.0\n        fs = np.minimum(1.0, f0 * s)\n        \n        # Calculate total synthesis time for baseline condition\n        total_time_0 = calculate_total_time(n, f0, k_cat, K_M, t_init)\n        \n        # Calculate total synthesis time for stress condition\n        total_time_s = calculate_total_time(n, fs, k_cat, K_M, t_init)\n        \n        # The fold-change rho is the ratio of rates, which is the inverse ratio of total times.\n        # rho = R_s / R_0 = (1 / total_time_s) / (1 / total_time_0) = total_time_0 / total_time_s\n        rho = total_time_0 / total_time_s\n        \n        results.append(rho)\n\n    # Format the final output as a comma-separated list of values rounded to 6 decimal places,\n    # enclosed in square brackets. Using f-string formatting to ensure 6 decimal places.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2770734"}, {"introduction": "最后，我们将视野扩展到一个完整的系统级模型，考察翻译调控如何整合到更广泛的细胞信号网络中。本练习旨在模拟外部信号（氧化应激）如何通过一个酶促网络（tRNA修饰酶）传播，从而协同调控翻译的起始和延伸阶段 [@problem_id:2770762]。通过这个模拟，您将深入理解蛋白质的最终产出如何受限于整个翻译过程中的动态瓶颈。", "problem": "要求您构建并实现一个基于基本原理的、最小化的定量模型，用以描述在合成生物学背景下，转移核糖核酸（tRNA）修饰酶的活性如何与氧化应激耦合，从而重编程翻译过程。该模型必须仅使用基础定律和经过充分检验的事实：(i) 用于酶修饰动力学的质量作用定律和米氏（Michaelis-Menten）型动力学，(ii) 指出蛋白质合成通过核糖体起始和延伸进行的中心法则，以及 (iii) 单个信使核糖核酸（mRNA）上的核糖体通量受限于起始和延伸中最慢的环节。\n\n基于基本原理的假设和定义：\n- 氧化应激由一个标量水平 $S$ 表示，该水平与活性氧（ROS）的浓度成正比。活性氧（ROS）通过类似竞争性抑制的双曲线关系降低 tRNA 修饰酶的活性浓度。如果 $E_{\\mathrm{t}}$ 是总酶浓度，$K_{i}$ 是抑制常数，那么活性浓度为 $E_{\\mathrm{act}}(S) = \\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}$。\n- 特定 tRNA 池中的一部分（比例为 $m \\in [0,1]$）被修饰。修饰由酶以与 $E_{\\mathrm{act}}(S)$ 成正比的有效一级速率添加，并以一级速率被移除（去修饰/更新）。设 $k_{\\mathrm{mod}}$ 为修饰速率常数，$k_{\\mathrm{demod}}$ 为去修饰速率常数。根据质量作用动力学，该比例的动态变化为\n  $$\\frac{dm}{dt} = k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m\\big) - k_{\\mathrm{demod}}\\,m.$$\n  在稳态时，令 $\\dfrac{dm}{dt} = 0$，解出稳态比例 $m^{\\ast}(S)$。\n- 修饰比例 $m^{\\ast}(S)$ 影响一部分密码子（“敏感”密码子）在核糖体 A 位点的延伸过程。设 $v_{\\mathrm{s,low}}$ 为特定 tRNA 未修饰时每个密码子的延伸速率，$v_{\\mathrm{s,high}}$ 为其完全修饰时的速率。一个与占据率一致的最小插值为\n  $$v_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big)\\,m^{\\ast}(S).$$\n  不依赖此修饰的密码子具有一个恒定的单位密码子延伸速率 $v_{\\mathrm{non}}$。\n- 一个含有 $n_{\\mathrm{sens}}$ 个敏感密码子和 $n_{\\mathrm{non}}$ 个非敏感密码子的转录本，其预期总延伸时间为\n  $$T_{\\mathrm{el}}(S) = \\frac{n_{\\mathrm{sens}}}{v_{\\mathrm{sens}}(S)} + \\frac{n_{\\mathrm{non}}}{v_{\\mathrm{non}}}.$$\n- 起始过程受到氧化应激的下调，这与真核起始因子2（eIF2）三元复合物的可用性降低相一致。使用一个具有基础起始速率 $I_{0}$ 和常数 $K_{\\mathrm{init}}$ 的双曲线抑制模型，每个 mRNA 的起始速率为\n  $$I(S) = \\frac{I_{0}}{1 + S/K_{\\mathrm{init}}}.$$\n- 每个 mRNA 的蛋白质生产速率受限于最慢的阶段，得出\n  $$R(S) = \\min\\!\\left(I(S), \\frac{1}{T_{\\mathrm{el}}(S)}\\right).$$\n  以“蛋白质/秒/mRNA”为单位报告 $R(S)$。\n\n任务：\n1. 严格从上述定义出发，根据稳态条件推导出 $m^{\\ast}(S)$，然后推导出相关量 $v_{\\mathrm{sens}}(S)$、$T_{\\mathrm{el}}(S)$、$I(S)$，并最终推导出 $R(S)$。\n2. 实现一个程序，为下列每个测试用例计算 $R(S)$。所有速率的单位均为“每秒”，应激水平 $S$ 使用任意非负单位，密码子计数是无量纲的。将最终的蛋白质生产速率以“蛋白质/秒/mRNA”为单位，表示为四舍五入到六位小数的浮点数。\n\n测试套件（每个用例是一个元组，顺序为：$(S, E_{\\mathrm{t}}, K_{i}, k_{\\mathrm{mod}}, k_{\\mathrm{demod}}, I_{0}, K_{\\mathrm{init}}, v_{\\mathrm{non}}, v_{\\mathrm{s,low}}, v_{\\mathrm{s,high}}, n_{\\mathrm{non}}, n_{\\mathrm{sens}})$）：\n- 案例 A（基线，中等敏感密码子含量）：$(S{=}\\,0.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,240,\\ n_{\\mathrm{sens}}{=}\\,60)$。\n- 案例 B（高应激，相同基因）：$(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,240,\\ n_{\\mathrm{sens}}{=}\\,60)$。\n- 案例 C（高应激，所有密码子均敏感）：$(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,0,\\ n_{\\mathrm{sens}}{=}\\,300)$。\n- 案例 D（高应激，无敏感密码子）：$(S{=}\\,2.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,300,\\ n_{\\mathrm{sens}}{=}\\,0)$。\n- 案例 E（低应激，极快去修饰，酶池减少，混合密码子含量）：$(S{=}\\,0.2,\\ E_{\\mathrm{t}}{=}\\,0.5,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,5.0,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,150,\\ n_{\\mathrm{sens}}{=}\\,150)$。\n- 案例 F（极端应激，起始限制区，富含敏感密码子）：$(S{=}\\,10.0,\\ E_{\\mathrm{t}}{=}\\,1.0,\\ K_{i}{=}\\,0.5,\\ k_{\\mathrm{mod}}{=}\\,1.0,\\ k_{\\mathrm{demod}}{=}\\,0.1,\\ I_{0}{=}\\,0.5,\\ K_{\\mathrm{init}}{=}\\,0.5,\\ v_{\\mathrm{non}}{=}\\,15.0,\\ v_{\\mathrm{s,low}}{=}\\,4.0,\\ v_{\\mathrm{s,high}}{=}\\,25.0,\\ n_{\\mathrm{non}}{=}\\,120,\\ n_{\\mathrm{sens}}{=}\\,180)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[r_{A},r_{B},r_{C},r_{D},r_{E},r_{F}]$，其中每个 $r_{\\cdot}$ 是对应案例的 $R(S)$ 值，四舍五入到六位小数，并以“蛋白质/秒/mRNA”为单位表示。", "solution": "该问题陈述已根据科学合理性、良态性（well-posedness）和客观性的指定标准进行了严格验证。研究发现，该问题是自洽的、逻辑一致的，并且基于已确立的生物物理和生物化学原理。该模型虽然经过简化，但它有效地形式化了氧化应激与翻译调控之间的耦合关系。因此，该问题被视为有效，并将推导出完整的解法。\n\n任务是推导出每个 mRNA 的蛋白质生产速率（表示为 $R(S)$）作为氧化应激水平 $S$ 函数的显式解析表达式，然后为一组给定的参数计算该值。推导过程将遵循问题陈述中定义的一系列步骤。\n\n首先，我们推导修饰 tRNA 的稳态比例 $m^{\\ast}(S)$。修饰比例 $m$ 的动力学由以下常微分方程给出：\n$$\n\\frac{dm}{dt} = k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m\\big) - k_{\\mathrm{demod}}\\,m\n$$\n在稳态时，$\\frac{dm}{dt} = 0$。设 $m^{\\ast}$ 为稳态比例。我们求解得到的代数方程以获得 $m^{\\ast}$：\n$$\nk_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)\\,\\big(1 - m^{\\ast}\\big) - k_{\\mathrm{demod}}\\,m^{\\ast} = 0\n$$\n$$\nk_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) = m^{\\ast} \\left( k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) + k_{\\mathrm{demod}} \\right)\n$$\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S)}{k_{\\mathrm{mod}}\\,E_{\\mathrm{act}}(S) + k_{\\mathrm{demod}}}\n$$\n活性酶浓度 $E_{\\mathrm{act}}(S)$ 本身是应激水平 $S$ 的函数：\n$$\nE_{\\mathrm{act}}(S) = \\frac{E_{\\mathrm{t}}}{1 + S/K_{i}}\n$$\n将此式代入 $m^{\\ast}(S)$ 的表达式中：\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,\\left(\\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}\\right)}{k_{\\mathrm{mod}}\\,\\left(\\dfrac{E_{\\mathrm{t}}}{1 + S/K_{i}}\\right) + k_{\\mathrm{demod}}}\n$$\n将分子和分母同乘以 $(1 + S/K_{i})$ 可简化表达式：\n$$\nm^{\\ast}(S) = \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}}}{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}} + k_{\\mathrm{demod}}\\,(1 + S/K_{i})}\n$$\n此表达式给出了修饰 tRNA 的稳态比例作为应激水平 $S$ 和相关系统参数的函数。\n\n其次，我们确定敏感密码子的有效延伸速率 $v_{\\mathrm{sens}}(S)$。该速率定义为未修饰 ($v_{\\mathrm{s,low}}$) 和完全修饰 ($v_{\\mathrm{s,high}}$) tRNA 速率之间的线性插值，权重为修饰 tRNA 的比例 $m^{\\ast}(S)$：\n$$\nv_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big)\\,m^{\\ast}(S)\n$$\n代入我们推导出的 $m^{\\ast}(S)$ 表达式：\n$$\nv_{\\mathrm{sens}}(S) = v_{\\mathrm{s,low}} + \\big(v_{\\mathrm{s,high}} - v_{\\mathrm{s,low}}\\big) \\, \\frac{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}}}{k_{\\mathrm{mod}}\\,E_{\\mathrm{t}} + k_{\\mathrm{demod}}\\,(1 + S/K_{i})}\n$$\n\n第三，我们计算包含 $n_{\\mathrm{sens}}$ 个敏感密码子和 $n_{\\mathrm{non}}$ 个非敏感密码子的转录本的总延伸时间 $T_{\\mathrm{el}}(S)$。总时间是解码每种类型密码子所用时间的总和：\n$$\nT_{\\mathrm{el}}(S) = \\frac{n_{\\mathrm{sens}}}{v_{\\mathrm{sens}}(S)} + \\frac{n_{\\mathrm{non}}}{v_{\\mathrm{non}}}\n$$\n非敏感密码子的速率 $v_{\\mathrm{non}}$ 是恒定的。总延伸速率（单位：核糖体/秒）是该时间的倒数，即 $1/T_{\\mathrm{el}}(S)$。\n\n第四，我们考虑起始速率 $I(S)$，它也受氧化应激下调：\n$$\nI(S) = \\frac{I_{0}}{1 + S/K_{\\mathrm{init}}}\n$$\n此处，$I_{0}$ 是无应激时的基础起始速率，$K_{\\mathrm{init}}$ 是该过程的抑制常数。\n\n最后，总蛋白质生产速率 $R(S)$ 由翻译过程的瓶颈决定，即起始速率和有效延伸速率中的较小者：\n$$\nR(S) = \\min\\!\\left(I(S), \\frac{1}{T_{\\mathrm{el}}(S)}\\right)\n$$\n在密码子总数为零（$n_{\\mathrm{sens}} + n_{\\mathrm{non}} = 0$）的情况下，延伸时间 $T_{\\mathrm{el}}(S)$ 将为零，导致延伸速率为无穷大。在这种情况下，生产速率仅由起始过程限制，即 $R(S) = I(S)$。然而，所有提供的测试用例都具有非零的密码子数。\n结合所有推导出的部分，对于一组给定的参数，最终的计算步骤如下：\n1. 使用其推导公式计算 $m^{\\ast}(S)$。\n2. 使用 $m^{\\ast}(S)$ 的值计算 $v_{\\mathrm{sens}}(S)$。\n3. 计算 $T_{\\mathrm{el}}(S)$。如果 $n_{\\mathrm{sens}}=0$ 或 $n_{\\mathrm{non}}=0$，则必须特别注意，此时求和中的相应项为零。\n4. 计算 $I(S)$。\n5. 将 $R(S)$ 确定为 $I(S)$ 和 $1 / T_{\\mathrm{el}}(S)$ 中的较小者。\n\n这些步骤在提供的程序中实现，用于计算每个测试用例的蛋白质生产速率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the protein production rate R(S) for each case\n    and prints the results in the specified format.\n    \"\"\"\n\n    # Test suite from the problem statement.\n    # Each tuple contains parameters in the order:\n    # (S, E_t, K_i, k_mod, k_demod, I_0, K_init, v_non, v_s_low, v_s_high, n_non, n_sens)\n    test_cases = [\n        # Case A (baseline, moderate sensitive codon content)\n        (0.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 240, 60),\n        # Case B (high stress, same gene)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 240, 60),\n        # Case C (high stress, all codons sensitive)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 0, 300),\n        # Case D (high stress, no codons sensitive)\n        (2.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 300, 0),\n        # Case E (low stress, very fast demodification, reduced enzyme pool, mixed codon content)\n        (0.2, 0.5, 0.5, 1.0, 5.0, 0.5, 0.5, 15.0, 4.0, 25.0, 150, 150),\n        # Case F (extreme stress, initiation-limited regime, sensitive-enriched)\n        (10.0, 1.0, 0.5, 1.0, 0.1, 0.5, 0.5, 15.0, 4.0, 25.0, 120, 180),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_production_rate(case)\n        results.append(result)\n\n    # Format the results as a comma-separated list of strings,\n    # each rounded to six decimal places, enclosed in brackets.\n    str_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\ndef calculate_production_rate(params):\n    \"\"\"\n    Calculates the protein production rate R(S) based on the derived model.\n\n    Args:\n        params (tuple): A tuple of parameters for a single test case.\n\n    Returns:\n        float: The calculated protein production rate R(S).\n    \"\"\"\n    S, E_t, K_i, k_mod, k_demod, I_0, K_init, v_non, v_s_low, v_s_high, n_non, n_sens = params\n\n    # Step 1: Calculate the steady-state fraction of modified tRNA, m*(S)\n    # m_star = (k_mod * E_t) / (k_mod * E_t + k_demod * (1 + S / K_i))\n    if K_i == 0:\n        # Avoid division by zero; if K_i is 0, any S > 0 fully inhibits the enzyme.\n        m_star_numerator = k_mod * E_t\n        m_star_denominator = np.inf if S > 0 else (k_mod * E_t + k_demod)\n    else:\n        m_star_numerator = k_mod * E_t\n        m_star_denominator = k_mod * E_t + k_demod * (1.0 + S / K_i)\n\n    if m_star_denominator == 0:\n        m_star = 1.0 # This case should not happen with positive parameters\n    else:\n        m_star = m_star_numerator / m_star_denominator\n\n    # Step 2: Calculate the elongation rate for sensitive codons, v_sens(S)\n    # v_sens = v_s_low + (v_s_high - v_s_low) * m_star\n    v_sens = v_s_low + (v_s_high - v_s_low) * m_star\n\n    # Step 3: Calculate the total elongation time, T_el(S)\n    t_el_sens = 0.0\n    if n_sens > 0:\n        if v_sens > 0:\n            t_el_sens = n_sens / v_sens\n        else: # Should not happen with positive rates\n            return 0.0\n\n    t_el_non = 0.0\n    if n_non > 0:\n        if v_non > 0:\n            t_el_non = n_non / v_non\n        else: # Should not happen with positive rates\n            return 0.0\n    \n    T_el = t_el_sens + t_el_non\n\n    # Calculate the effective elongation rate, R_el(S)\n    if T_el > 0:\n        R_el = 1.0 / T_el\n    else:\n        # If there are no codons, elongation is instantaneous.\n        R_el = np.inf\n\n    # Step 4: Calculate the initiation rate, I(S)\n    # I_S = I_0 / (1 + S / K_init)\n    if K_init == 0:\n        I_S = 0.0 if S > 0 else I_0\n    else:\n        I_S = I_0 / (1.0 + S / K_init)\n\n    # Step 5: The overall production rate R(S) is the minimum of initiation and elongation rates\n    R_S = np.minimum(I_S, R_el)\n    \n    return R_S\n\n# Execute the main function\nsolve()\n```", "id": "2770762"}]}