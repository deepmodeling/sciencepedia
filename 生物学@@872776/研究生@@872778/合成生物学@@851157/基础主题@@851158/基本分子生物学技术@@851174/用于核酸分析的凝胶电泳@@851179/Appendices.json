{"hands_on_practices": [{"introduction": "凝胶电泳是分子生物学中的基石技术，但要将条带在凝胶上的位置转化为可靠的核酸片段大小估计，则需要一种严谨的定量方法。本练习的核心是利用片段迁移距离 $d$ 与其以碱基对（bp）为单位的长度 $s$ 的对数 $\\log_{10}(s)$ 之间的经验线性关系。您将通过实践线性回归来校准标准曲线，并应用统计学中的误差传播原理，为您估算的目标片段大小提供一个置信区间，从而量化最终结果的不确定性。掌握这项技能对于准确解读凝胶数据至关重要，它构成了所有定量凝胶分析的基础 [@problem_id:2740371]。", "problem": "一个合成生物学实验室使用平板凝胶电泳来测定脱氧核糖核酸（DNA）片段的大小。在一个实际范围内，由于聚合物凝胶基质中尺寸依赖性的筛分效应，片段的迁移距离（单位：毫米，mm）根据经验可以很好地被模拟为其长度（单位：碱基对，bp）的以10为底的对数的近似线性函数。假设存在以下经验模型：测得的迁移距离 $d$（单位：mm）与未知的片段大小 $s$（单位：bp）通过一个线性关系相关联\n$$\nd = a + b \\,\\log_{10}(s) + \\varepsilon,\n$$\n其中 $a$ 和 $b$ 是未知的实数参数，$\\varepsilon$ 是一个加性噪声项。假设对于ladder条带，$\\varepsilon$ 是均值为0、方差未知的独立同分布高斯随机变量，并且已知的ladder大小是精确的（即没有不确定性）。一个目标条带的测量迁移距离 $d^\\star$ 具有一个独立的高斯测量误差，其已知标准差为 $\\sigma_{d^\\star}$。\n\n您的任务是编写一个程序，对于每个提供的测试用例，从第一性原理出发执行以下步骤：\n- 通过普通最小二乘法将线性模型 $d = a + b \\,\\log_{10}(s)$ 拟合到ladder数据，这在 $d$ 的独立高斯噪声模型下是最大似然估计。从数据中估计参数向量 $\\theta = (a,b)^\\top$ 和残差方差 $\\sigma^2$。\n- 给定一个测量迁移距离为 $d^\\star$ 的目标条带，通过模型反演 $x^\\star = (d^\\star - a)/b$ 执行反向预测，以估计 $x^\\star = \\log_{10}(s^\\star)$。将 $a$ 和 $b$ 视为估计的（随机的）量，并使用一阶泰勒展开（Delta方法）将其不确定性传播到 $x^\\star$，同时将目标测量误差 $\\sigma_{d^\\star}$ 作为对 $x^\\star$ 方差的额外独立贡献包括在内。\n- 使用具有回归拟合中适当自由度的学生t分布，为 $x^\\star$ 构建一个双侧 $(1-\\alpha)$ 置信区间。通过 $s^\\star = 10^{x^\\star}$ 将此区间转换回碱基对单位，因此区间端点为 $10^{x^\\star \\pm t_{\\alpha/2,\\nu}\\,\\mathrm{SE}(x^\\star)}$。以碱基对为单位报告点估计和置信限。\n- 将每个测试用例的最终结果表示为整数碱基对，通过四舍五入到最接近的整数。\n\n使用的基本依据和约束：\n- 使用经验上和广泛接受的观察结果：对于平板凝胶，在固定的缓冲液和凝胶组成下，在一个实际的尺寸范围内，迁移距离 $d$ 与 $\\log_{10}(s)$ 近似呈线性关系。\n- 使用高斯噪声下的普通最小二乘法的定义和性质，以及用于不确定性传播的一阶误差传播（泰勒展开）。\n- 使用具有 $\\nu = n-2$ 自由度的学生t分布来解释参数不确定性，其中 $n$ 是ladder条带的数量。\n\n每个测试用例的输入规范（如下提供；无外部输入）：\n- 一个ladder大小列表，单位为碱基对 $[s_1,\\dots,s_n]$，值为精确值。\n- 一个测量的ladder迁移距离列表，单位为毫米 $[d_1,\\dots,d_n]$，具有独立、相同但未知的方差的高斯噪声。\n- 一个目标条带的测量迁移距离 $d^\\star$，单位为毫米，及其测量标准差 $\\sigma_{d^\\star}$，单位为毫米。\n- 一个由 $\\alpha = 0.05$ 指定的置信水平（即 $95\\%$ 置信度）。\n\n计算要求：\n- 将 $d$ 作为响应变量，$x=\\log_{10}(s)$ 作为预测变量进行回归。\n- 通过最小化残差平方和来估计参数。\n- 从回归中估计 $(a,b)$ 的协方差，并使用一阶Delta方法来近似 $x^\\star = (d^\\star - a)/b$ 的方差，包括来自 $d^\\star$ 的独立测量误差（方差为 $\\sigma_{d^\\star}^2$）的加性贡献。\n- 使用具有 $\\nu = n-2$ 自由度的学生t分位数构建 $x^\\star$ 的 $(1-\\alpha)$ 置信区间，然后如上所述转换为碱基对。\n- 将 $s^\\star$ 及其两个置信限四舍五入到最接近的整数碱基对。\n\n单位：\n- 所有迁移距离必须以毫米（mm）为单位处理。\n- 所有片段大小必须以碱基对（bp）为单位报告。\n- 所有置信区间必须在四舍五入后报告为整数碱基对。\n\n测试套件：\n为以下三个测试用例中的每一个提供结果。在每个案例中，$\\alpha$ 固定为 $0.05$。\n\n- 案例 A：\n  - Ladder大小 (bp): $[100,200,400,800,1500,3000]$。\n  - Ladder测量距离 (mm): $[60.4,53.3,48.2,41.6,37.1,30.3]$。\n  - 目标测量距离 (mm): $d^\\star = 45.0$。\n  - 目标测量标准差 (mm): $\\sigma_{d^\\star} = 0.5$。\n\n- 案例 B（样本量边界情况，只有三个ladder条带且目标噪声较高）：\n  - Ladder大小 (bp): $[500,1500,4500]$。\n  - Ladder测量距离 (mm): $[46.72,37.33,29.94]$。\n  - 目标测量距离 (mm): $d^\\star = 35.0$。\n  - 目标测量标准差 (mm): $\\sigma_{d^\\star} = 1.0$。\n\n- 案例 C（轻微外推，超出最大ladder大小）：\n  - Ladder大小 (bp): $[50,100,200,400,800]$。\n  - Ladder测量距离 (mm): $[77.625,69.8,63.0,54.7,47.5]$。\n  - 目标测量距离 (mm): $d^\\star = 45.0$。\n  - 目标测量标准差 (mm): $\\sigma_{d^\\star} = 0.3$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，每个结果是一个由整数（全部以碱基对为单位）组成的三元组 $[s^\\star,\\mathrm{low},\\mathrm{high}]$，没有额外的空白。例如：$[[123,100,150],[\\dots],[\\dots]]$。", "solution": "该问题要求根据凝胶电泳数据估计脱氧核糖核酸（DNA）片段的大小及其相应的置信区间。这是一个统计学中经典的反向预测或校准问题，将从第一性原理出发进行求解。\n\n分析的基础是将迁移距离 $d$（单位：mm）与片段大小 $s$（单位：bp）的以10为底的对数关联起来的经验线性模型：\n$$\nd = a + b \\,x + \\varepsilon, \\quad \\text{where} \\quad x = \\log_{10}(s)\n$$\n这里，$a$ 和 $b$ 是模型参数，$\\varepsilon$ 代表测量噪声，假设为均值为0、方差 $\\sigma^2$ 未知的独立同分布（i.i.d.）高斯随机变量。\n\n程序按以下步骤构建：\n1.  使用普通最小二乘法（OLS）对提供的ladder数据估计参数 $a$ 和 $b$。\n2.  估计残差方差 $\\sigma^2$。\n3.  对于一个测量距离为 $d^\\star$ 的目标条带，执行反向预测以估计其对数大小 $x^\\star = \\log_{10}(s^\\star)$。\n4.  传播来自估计参数 $(\\hat{a}, \\hat{b})$ 和目标测量 $d^\\star$ 的不确定性，以计算估计的对数大小的标准误 $\\mathrm{SE}(\\hat{x}^\\star)$。\n5.  使用学生t分布构建 $x^\\star$ 的 $(1-\\alpha)$ 置信区间。\n6.  将点估计和置信限从对数尺度转换回原始的碱基对尺度，并四舍五入到最接近的整数。\n\n**步骤1：普通最小二乘法（OLS）参数估计**\n给定一组包含 $n$ 个ladder条带的数据，其大小 $s_i$ 已知，测量距离为 $d_i$，我们首先将大小转换为对数尺度：$x_i = \\log_{10}(s_i)$。ladder数据的线性方程组为：\n$$\nd_i = a + b x_i + \\varepsilon_i, \\quad \\text{for} \\quad i = 1, \\dots, n\n$$\n用矩阵表示为 $\\mathbf{d} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon}$，其中：\n$$\n\\mathbf{d} = \\begin{pmatrix} d_1 \\\\ \\vdots \\\\ d_n \\end{pmatrix}, \\quad\n\\mathbf{X} = \\begin{pmatrix} 1  x_1 \\\\ \\vdots  \\vdots \\\\ 1  x_n \\end{pmatrix}, \\quad\n\\boldsymbol{\\theta} = \\begin{pmatrix} a \\\\ b \\end{pmatrix}, \\quad\n\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_1 \\\\ \\vdots \\\\ \\varepsilon_n \\end{pmatrix}\n$$\nOLS估计量 $\\hat{\\boldsymbol{\\theta}}$ 最小化残差平方和 $SSR = \\sum_{i=1}^n (d_i - (a + b x_i))^2$。在高斯噪声假设下，这对应于最大似然估计。解由正规方程给出：\n$$\n\\hat{\\boldsymbol{\\theta}} = \\begin{pmatrix} \\hat{a} \\\\ \\hat{b} \\end{pmatrix} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{d}\n$$\n参数估计 $\\hat{\\boldsymbol{\\theta}}$ 的协方差矩阵是 $\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}}) = \\sigma^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}$。\n\n**步骤2：残差方差的估计**\n未知方差 $\\sigma^2$ 使用残差平方和进行估计。残差由 $\\mathbf{e} = \\mathbf{d} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$ 给出。$\\sigma^2$ 的无偏估计量是均方误差 $s_e^2$：\n$$\ns_e^2 = \\frac{\\mathbf{e}^\\top \\mathbf{e}}{n-p} = \\frac{1}{n-2} \\sum_{i=1}^n (d_i - (\\hat{a} + \\hat{b} x_i))^2\n$$\n其中 $p=2$ 是模型中的参数数量（$a$ 和 $b$）。分母 $\\nu = n-2$ 代表残差的自由度。那么，参数的估计协方差矩阵为 $\\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\theta}}) = s_e^2 (\\mathbf{X}^\\top \\mathbf{X})^{-1}$。\n\n**步骤3：目标片段的反向预测**\n对于一个测量的迁移距离为 $d^\\star$ 的目标片段，我们反转拟合的模型以获得其对数大小的点估计 $\\hat{x}^\\star$：\n$$\n\\hat{x}^\\star = \\frac{d^\\star - \\hat{a}}{\\hat{b}}\n$$\n以碱基对为单位的大小点估计为 $s^\\star = 10^{\\hat{x}^\\star}$。\n\n**步骤4：使用Delta方法进行不确定性传播**\n$\\hat{x}^\\star$ 的方差来自两个独立的来源：估计参数 $(\\hat{a}, \\hat{b})$ 的不确定性和目标距离 $d^\\star$ 的测量不确定性（其给定方差为 $\\sigma_{d^\\star}^2$）。我们使用一阶泰勒展开（Delta方法）来近似这个方差。\n令反向预测的函数为 $g(a, b, d^\\star) = \\frac{d^\\star - a}{b}$。总方差是每个来源方差的总和：\n$$\n\\mathrm{Var}(\\hat{x}^\\star) \\approx \\mathrm{Var}_{(\\hat{a},\\hat{b})}(\\hat{x}^\\star) + \\mathrm{Var}_{d^\\star}(\\hat{x}^\\star)\n$$\n来自参数不确定性的方差近似为：\n$$\n\\mathrm{Var}_{(\\hat{a},\\hat{b})}(\\hat{x}^\\star) \\approx \\begin{pmatrix} \\frac{\\partial g}{\\partial a} \\\\ \\frac{\\partial g}{\\partial b} \\end{pmatrix}^\\top \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\theta}}) \\begin{pmatrix} \\frac{\\partial g}{\\partial a} \\\\ \\frac{\\partial g}{\\partial b} \\end{pmatrix}\n$$\n在估计值处计算的偏导数为：\n$$\n\\frac{\\partial g}{\\partial a} = -\\frac{1}{\\hat{b}}, \\quad \\frac{\\partial g}{\\partial b} = -\\frac{d^\\star - \\hat{a}}{\\hat{b}^2} = -\\frac{\\hat{x}^\\star}{\\hat{b}}\n$$\n因此，来自模型参数的方差贡献为：\n$$\n\\frac{1}{\\hat{b}^2} \\begin{pmatrix} 1  \\hat{x}^\\star \\end{pmatrix} \\widehat{\\mathrm{Cov}}(\\hat{\\boldsymbol{\\theta}}) \\begin{pmatrix} 1 \\\\ \\hat{x}^\\star \\end{pmatrix} = \\frac{s_e^2}{\\hat{b}^2} \\begin{pmatrix} 1  \\hat{x}^\\star \\end{pmatrix} (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\begin{pmatrix} 1 \\\\ \\hat{x}^\\star \\end{pmatrix}\n$$\n在回归分析中，这是一个标准结果：对于向量 $\\mathbf{v} = (1, v_2)^\\top$，有 $\\mathbf{v}^\\top (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{v} = \\frac{1}{n} + \\frac{(v_2 - \\bar{x})^2}{\\sum(x_i - \\bar{x})^2}$。在这里，$v_2 = \\hat{x}^\\star$。所以，该项变为：\n$$\n\\mathrm{Var}_{(\\hat{a},\\hat{b})}(\\hat{x}^\\star) \\approx \\frac{s_e^2}{\\hat{b}^2} \\left[ \\frac{1}{n} + \\frac{(\\hat{x}^\\star - \\bar{x})^2}{\\sum_{i=1}^n(x_i - \\bar{x})^2} \\right]\n$$\n来自目标测量 $d^\\star$ 的方差为：\n$$\n\\mathrm{Var}_{d^\\star}(\\hat{x}^\\star) \\approx \\left(\\frac{\\partial g}{\\partial d^\\star}\\right)^2 \\mathrm{Var}(d^\\star) = \\left(\\frac{1}{\\hat{b}}\\right)^2 \\sigma_{d^\\star}^2\n$$\n结合两个独立的来源，$\\hat{x}^\\star$ 的总估计方差为：\n$$\n\\widehat{\\mathrm{Var}}(\\hat{x}^\\star) = \\frac{s_e^2}{\\hat{b}^2} \\left[ \\frac{1}{n} + \\frac{(\\hat{x}^\\star - \\bar{x})^2}{\\sum_{i=1}^n(x_i - \\bar{x})^2} \\right] + \\frac{\\sigma_{d^\\star}^2}{\\hat{b}^2}\n$$\n估计的标准误为 $\\mathrm{SE}(\\hat{x}^\\star) = \\sqrt{\\widehat{\\mathrm{Var}}(\\hat{x}^\\star)}$。\n\n**步骤5：置信区间的构建**\n因为方差 $\\sigma^2$ 是从数据中估计的，我们使用具有 $\\nu = n-2$ 自由度的学生t分布来构建置信区间。真实对数大小 $x^\\star$ 的双侧 $(1-\\alpha)$ 置信区间为：\n$$\n\\hat{x}^\\star \\pm t_{\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{x}^\\star)\n$$\n其中 $t_{\\alpha/2, \\nu}$ 是具有 $\\nu$ 自由度的t分布的上 $(\\alpha/2)$-分位数。\n\n**步骤6：转换和最终结果**\n将 $x^\\star$ 的点估计和置信区间转换回碱基对尺度：\n- 点估计：$s^\\star = 10^{\\hat{x}^\\star}$\n- 置信限：$[s_{low}, s_{high}] = [10^{\\hat{x}^\\star - t_{\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{x}^\\star)}, 10^{\\hat{x}^\\star + t_{\\alpha/2, \\nu} \\cdot \\mathrm{SE}(\\hat{x}^\\star)}]$\n最后，按要求将这三个值（$s^\\star, s_{low}, s_{high}$）四舍五入到最接近的整数。这完成了正式的步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef calculate_size_and_ci(ladder_sizes, ladder_dists, d_star, sigma_d_star, alpha):\n    \"\"\"\n    Calculates DNA fragment size and confidence interval from gel electrophoresis data.\n\n    Args:\n        ladder_sizes (list or np.ndarray): Sizes of ladder fragments in base pairs (bp).\n        ladder_dists (list or np.ndarray): Measured migration distances of ladder fragments in mm.\n        d_star (float): Measured migration distance of the target fragment in mm.\n        sigma_d_star (float): Standard deviation of the target fragment's distance measurement in mm.\n        alpha (float): Significance level for the confidence interval (e.g., 0.05 for 95% CI).\n\n    Returns:\n        list: A list containing [s_star, s_low, s_high], all rounded to the nearest integer.\n    \"\"\"\n    s_ladder = np.array(ladder_sizes, dtype=np.float64)\n    d_ladder = np.array(ladder_dists, dtype=np.float64)\n    n = len(s_ladder)\n\n    # Step 1: OLS Parameter Estimation\n    # The predictor variable is x = log10(s)\n    x_ladder = np.log10(s_ladder)\n    \n    # Construct the design matrix X\n    X = np.c_[np.ones(n), x_ladder]\n    \n    # Calculate OLS estimator for theta = [a, b]^T\n    # theta_hat = inv(X^T * X) * X^T * d\n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n        theta_hat = XTX_inv @ X.T @ d_ladder\n    except np.linalg.LinAlgError:\n        # This case should not happen with the given test data\n        return [np.nan, np.nan, np.nan]\n        \n    a_hat, b_hat = theta_hat\n\n    # Step 2: Estimate Residual Variance\n    # Degrees of freedom for residuals\n    nu = n - 2\n    if nu == 0:\n        # Not enough data points for regression\n        return [np.nan, np.nan, np.nan]\n        \n    # Calculate residuals\n    d_predicted = X @ theta_hat\n    residuals = d_ladder - d_predicted\n    \n    # Estimate residual variance (mean squared error)\n    s_e_sq = np.sum(residuals**2) / nu\n\n    # Step 3: Inverse Prediction for the Target Fragment\n    # Point estimate for the log-size x_star\n    x_star_hat = (d_star - a_hat) / b_hat\n\n    # Step 4: Uncertainty Propagation\n    # Calculate terms needed for the variance of x_star_hat\n    x_bar = np.mean(x_ladder)\n    S_xx = np.sum((x_ladder - x_bar)**2)\n\n    # Variance from parameter uncertainty\n    var_from_params = (s_e_sq / b_hat**2) * (1/n + (x_star_hat - x_bar)**2 / S_xx)\n    \n    # Variance from target measurement uncertainty\n    var_from_d_star = (sigma_d_star**2) / b_hat**2\n\n    # Total variance of x_star_hat\n    var_x_star = var_from_params + var_from_d_star\n    \n    # Standard error of x_star_hat\n    se_x_star = np.sqrt(var_x_star)\n\n    # Step 5: Confidence Interval Construction\n    # Find the critical t-value for a (1-alpha) confidence interval\n    t_critical = t.ppf(1 - alpha / 2, df=nu)\n\n    # Margin of error for x_star\n    margin_of_error = t_critical * se_x_star\n\n    # Confidence interval for x_star\n    x_low = x_star_hat - margin_of_error\n    x_high = x_star_hat + margin_of_error\n\n    # Step 6: Transform back to base pairs and round\n    # Point estimate for size s_star\n    s_star_est = 10**x_star_hat\n    \n    # Confidence limits for s_star\n    s_low_est = 10**x_low\n    s_high_est = 10**x_high\n\n    # Round to nearest integer\n    s_star_rounded = int(np.round(s_star_est))\n    s_low_rounded = int(np.round(s_low_est))\n    s_high_rounded = int(np.round(s_high_est))\n\n    return [s_star_rounded, s_low_rounded, s_high_rounded]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"ladder_sizes\": [100, 200, 400, 800, 1500, 3000],\n            \"ladder_dists\": [60.4, 53.3, 48.2, 41.6, 37.1, 30.3],\n            \"d_star\": 45.0,\n            \"sigma_d_star\": 0.5,\n            \"alpha\": 0.05\n        },\n        {\n            \"ladder_sizes\": [500, 1500, 4500],\n            \"ladder_dists\": [46.72, 37.33, 29.94],\n            \"d_star\": 35.0,\n            \"sigma_d_star\": 1.0,\n            \"alpha\": 0.05\n        },\n        {\n            \"ladder_sizes\": [50, 100, 200, 400, 800],\n            \"ladder_dists\": [77.625, 69.8, 63.0, 54.7, 47.5],\n            \"d_star\": 45.0,\n            \"sigma_d_star\": 0.3,\n            \"alpha\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_size_and_ci(\n            case[\"ladder_sizes\"],\n            case[\"ladder_dists\"],\n            case[\"d_star\"],\n            case[\"sigma_d_star\"],\n            case[\"alpha\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, so we need to convert each inner list to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2740371"}, {"introduction": "在科学研究中，单一的实验结果往往不足以得出结论，可重复性是衡量研究可靠性的关键。当我们在不同的凝胶上对相同的样品进行电泳时，总会观察到测量结果的差异。本练习将引导您使用方差分析（ANOVA）这一强大的统计工具，特别是通过一个双向随机效应模型 $Y_{g,s} = \\mu + A_g + B_s + \\varepsilon_{g,s}$，来剖析实验总变异的来源。您将学习如何将总方差分解为由凝胶间差异（$\\sigma_A^2$）、样品间固有差异（$\\sigma_B^2$）和随机残留误差（$\\sigma_\\varepsilon^2$）所贡献的组分。通过量化这些方差组分 [@problem_id:2740424]，我们能识别实验噪声的主要来源，这对于优化实验方案、评估检测方法的稳健性以及设计更可靠的实验至关重要。", "problem": "给定从同一组样品在多个凝膠上运行得到的核酸条带的重复琼脂糖凝胶电泳测量值。在合成生物学工作流程中，表观条带大小（以碱基对计）和条带强度（以任意单位计）都受到样品内在因素和凝胶间差异的影响。请使用平衡双因素随机效应框架，在对数转换尺度上对数据进行建模，以量化可归因于凝胶、样品和残差效应的方差分量。\n\n基本假设与定义：\n- 核酸的电泳迁移率近似与分子大小的对数成比例。为稳定方差并使效应线性化，请对表观大小和强度测量值应用自然对数。令 $Y_{g,s}$ 表示凝胶索引为 $g \\in \\{1,\\dots,G\\}$ 且样品索引为 $s \\in \\{1,\\dots,S\\}$ 的对数转换后的测量值。\n- 对每个响应（分别针对对数大小和对数强度）采用加性双因素随机效应模型：\n$$Y_{g,s} = \\mu + A_g + B_s + \\varepsilon_{g,s},$$\n其中 $\\mu$ 是一个固定截距，$A_g \\sim \\mathcal{N}(0,\\sigma_A^2)$ 是随机凝胶效应，$B_s \\sim \\mathcal{N}(0,\\sigma_B^2)$ 是随机样品效应，$\\varepsilon_{g,s} \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$ 是残差（包括泳道间差异和未建模的交互作用）。\n- 对于每个单元格只有一个观测值、$G$ 个凝胶和 $S$ 个样品的平衡设计，双因素方差分析分解得出以下平方和：\n  - 令 $\\bar{Y}_{g\\cdot}$ 为凝胶 $g$ 上各样品的均值，$\\bar{Y}_{\\cdot s}$ 为样品 $s$ 在各凝胶上的均值，$\\bar{Y}_{\\cdot\\cdot}$ 为总均值。\n  - 定义\n    $$SS_A = S \\sum_{g=1}^{G} \\left(\\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot\\cdot}\\right)^2,\\quad SS_B = G \\sum_{s=1}^{S} \\left(\\bar{Y}_{\\cdot s} - \\bar{Y}_{\\cdot\\cdot}\\right)^2,$$\n    $$SS_E = \\sum_{g=1}^{G}\\sum_{s=1}^{S} \\left(Y_{g,s} - \\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot s} + \\bar{Y}_{\\cdot\\cdot}\\right)^2.$$\n  - 自由度为 $df_A = G-1$，$df_B = S-1$，$df_E = (G-1)(S-1)$，均方为 $MS_A = SS_A/df_A$，$MS_B = SS_B/df_B$，$MS_E = SS_E/df_E$。\n- 模型下的期望均方为\n  $$\\mathbb{E}[MS_A] = \\sigma_\\varepsilon^2 + S \\sigma_A^2,\\quad \\mathbb{E}[MS_B] = \\sigma_\\varepsilon^2 + G \\sigma_B^2,\\quad \\mathbb{E}[MS_E] = \\sigma_\\varepsilon^2.$$\n- 使用矩法，通过将观测均方与其期望值相等来获得方差分量估计值。通过在零处截断来强制非负性：如果任何估计值为负，则将其设为零。\n\n任务：\n- 对于每个响应（对数大小和对数强度）以及下述每个测试用例，计算方差分量 $\\hat{\\sigma}_A^2$（凝胶间变异性）、$\\hat{\\sigma}_B^2$（样品间变异性）和 $\\hat{\\sigma}_\\varepsilon^2$（残差）。\n- 将主要方差来源识别为 $\\{\\hat{\\sigma}_A^2,\\hat{\\sigma}_B^2,\\hat{\\sigma}_\\varepsilon^2\\}$ 中最大值的索引，编码为整数：$0$ 代表凝胶，$1$ 代表样品，$2$ 代表残差。\n\n输入数据和单位：\n- 表观大小以碱基对（bp）为单位，强度以任意单位（a.u.）为单位。分析前对两者应用自然对数。不需要其他单位转换，最终数值答案是对数尺度上的方差（无量纲）。\n\n测试套件：\n- 案例 $1$（$G=3$, $S=4$）。大小（bp），按凝胶（行）和样品（列）排列：\n  $$\\begin{bmatrix}\n  505  748  1007  1490\\\\\n  495  760  990  1510\\\\\n  500  752  1003  1498\n  \\end{bmatrix}$$\n  强度（a.u.），按凝胶（行）和样品（列）排列：\n  $$\\begin{bmatrix}\n  1.20  0.85  1.50  1.10\\\\\n  1.10  0.80  1.55  1.05\\\\\n  1.25  0.90  1.45  1.00\n  \\end{bmatrix}$$\n- 案例 $2$（$G=3$, $S=4$）。大小（bp）：\n  $$\\begin{bmatrix}\n  1001  1002  1003  1004\\\\\n  1000  1001  1002  1003\\\\\n  1002  1003  1004  1005\n  \\end{bmatrix}$$\n  强度（a.u.）：\n  $$\\begin{bmatrix}\n  0.50  0.60  0.70  0.80\\\\\n  0.51  0.61  0.71  0.81\\\\\n  0.49  0.59  0.69  0.79\n  \\end{bmatrix}$$\n- 案例 $3$（$G=3$, $S=4$）。大小（bp）：\n  $$\\begin{bmatrix}\n  800  805  795  798\\\\\n  820  825  815  818\\\\\n  780  785  775  778\n  \\end{bmatrix}$$\n  强度（a.u.）：\n  $$\\begin{bmatrix}\n  0.80  0.82  0.79  0.81\\\\\n  1.60  1.62  1.58  1.61\\\\\n  0.40  0.42  0.39  0.41\n  \\end{bmatrix}$$\n\n输出规格：\n- 对于每个测试用例，生成一个列表，按对数大小然后是对数强度的顺序包含：$[\\hat{\\sigma}_A^2,\\hat{\\sigma}_B^2,\\hat{\\sigma}_\\varepsilon^2,\\text{dominant\\_index}]$。连接两种响应的结果，使每个案例生成一个长度为 $8$ 的列表，格式为 $[\\hat{\\sigma}_{A,\\text{size}}^2,\\hat{\\sigma}_{B,\\text{size}}^2,\\hat{\\sigma}_{\\varepsilon,\\text{size}}^2,\\text{dom}_{\\text{size}},\\hat{\\sigma}_{A,\\text{int}}^2,\\hat{\\sigma}_{B,\\text{int}}^2,\\hat{\\sigma}_{\\varepsilon,\\text{int}}^2,\\text{dom}_{\\text{int}}]$。\n- 将所有方差分量四舍五入到 $6$ 位小数。主要方差索引必须是如上定义的整数。\n- 您的程序应生成单行输出，包含用方括号括起来的逗号分隔列表形式的结果（例如，$ [result1,result2,result3] $），其中每个 $resultk$ 是案例 $k$ 的 Python 风格列表。\n\n无需用户输入；按提供的方式硬编码测试套件，并相应地计算输出。", "solution": "问题陈述经过严格验证。所有给定信息都已被提取和审查，以确保其科学合理性、完整性和清晰度。\n\n### 步骤1：提取给定信息\n- **模型**：平衡双因素随机效应模型，$Y_{g,s} = \\mu + A_g + B_s + \\varepsilon_{g,s}$，其中 $g \\in \\{1,\\dots,G\\}$ 且 $s \\in \\{1,\\dots,S\\}$。\n- **响应变量**：$Y_{g,s}$ 是测量数据（表观大小或强度）的自然对数。\n- **随机效应**：凝胶效应 $A_g \\sim \\mathcal{N}(0,\\sigma_A^2)$，样品效应 $B_s \\sim \\mathcal{N}(0,\\sigma_B^2)$，以及残差效应 $\\varepsilon_{g,s} \\sim \\mathcal{N}(0,\\sigma_\\varepsilon^2)$。\n- **方差分析 (ANOVA) 公式**：\n  - 凝胶的平方和 ($A$)：$SS_A = S \\sum_{g=1}^{G} (\\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot\\cdot})^2$。\n  - 样品的平方和 ($B$)：$SS_B = G \\sum_{s=1}^{S} (\\bar{Y}_{\\cdot s} - \\bar{Y}_{\\cdot\\cdot})^2$。\n  - 残差的平方和 ($E$)：$SS_E = \\sum_{g=1}^{G}\\sum_{s=1}^{S} (Y_{g,s} - \\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot s} + \\bar{Y}_{\\cdot\\cdot})^2$。\n  - 自由度：$df_A = G-1$，$df_B = S-1$，$df_E = (G-1)(S-1)$。\n  - 均方：$MS_A = SS_A/df_A$，$MS_B = SS_B/df_B$，$MS_E = SS_E/df_E$。\n- **估计方法**：从期望均方导出的方差分量的矩法估计量：\n  - $\\mathbb{E}[MS_A] = \\sigma_\\varepsilon^2 + S \\sigma_A^2 \\implies \\hat{\\sigma}_A^2 = (MS_A - MS_E)/S$。\n  - $\\mathbb{E}[MS_B] = \\sigma_\\varepsilon^2 + G \\sigma_B^2 \\implies \\hat{\\sigma}_B^2 = (MS_B - MS_E)/G$。\n  - $\\mathbb{E}[MS_E] = \\sigma_\\varepsilon^2 \\implies \\hat{\\sigma}_\\varepsilon^2 = MS_E$。\n- **约束**：通过将任何负的方差估计值设置为 $0$ 来强制非负性。\n- **任务**：对于每个测试用例和每个响应（大小和强度），计算 $\\{\\hat{\\sigma}_A^2, \\hat{\\sigma}_B^2, \\hat{\\sigma}_\\varepsilon^2\\}$ 并识别主要方差分量（索引 $0$ 代表凝胶，$1$ 代表样品，$2$ 代表残差）。\n- **数据**：三个测试用例，$G=3$，$S=4$，提供了大小（bp）和强度（a.u.）的矩阵。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题将标准统计模型（双因素随机效应方差分析）应用于分子生物学中的一个常见实验场景（凝胶电泳数据分析）。对大小和强度使用对数转换是稳定方差和实现线性化的有效且常用的做法。模型、方差分析分解和矩法估计都是统计学中的基本概念。它在科学上是合理的。\n- **良态的**：问题提供了完整的数据集和用于计算所需结果的确定性算法。对于每个测试用例，都存在唯一解。\n- **客观性**：语言精确且无主观性。所有术语都有明确定义。\n\n### 步骤3：结论与行动\n该问题是有效的。它是一个定义明确的计算任务，基于既定的统计学原理及其在生物学中的应用。解题过程执行如下。\n\n### 解题方法\n任务是为一个双因素随机效应模型执行方差分量分析。对于对数转换后的表观大小和对数转换后的强度数据，该过程是相同的。对于每个数据矩阵，执行以下步骤：\n\n1.  **数据转换**：给定一个大小为 $G \\times S$ 的数据矩阵 $D$，分析在对数转换后的矩阵 $Y$ 上进行，其中每个元素是 $Y_{g,s} = \\ln(D_{g,s})$。\n\n2.  **均值计算**：我们计算 $Y$ 在不同维度上的均值：\n    - 总均值，$\\bar{Y}_{\\cdot\\cdot} = \\frac{1}{GS} \\sum_{g=1}^{G} \\sum_{s=1}^{S} Y_{g,s}$。\n    - 每个凝胶的均值（行均值），$\\bar{Y}_{g\\cdot} = \\frac{1}{S} \\sum_{s=1}^{S} Y_{g,s}$，对于 $g=1, \\dots, G$。\n    - 每个样品的均值（列均值），$\\bar{Y}_{\\cdot s} = \\frac{1}{G} \\sum_{g=1}^{G} Y_{g,s}$，对于 $s=1, \\dots, S$。\n\n3.  **平方和（SS）计算**：使用计算出的均值，根据提供的公式，我们获得两个因素（凝胶和样品）和残差的平方和：\n    - $SS_A = S \\sum_{g=1}^{G} (\\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot\\cdot})^2$\n    - $SS_B = G \\sum_{s=1}^{S} (\\bar{Y}_{\\cdot s} - \\bar{Y}_{\\cdot\\cdot})^2$\n    - $SS_E = \\sum_{g=1}^{G}\\sum_{s=1}^{S} (Y_{g,s} - \\bar{Y}_{g\\cdot} - \\bar{Y}_{\\cdot s} + \\bar{Y}_{\\cdot\\cdot})^2$\n\n4.  **均方（MS）计算**：通过将平方和除以它们各自的自由度，将它们转换为均方：\n    - $df_A = G-1$，$df_B = S-1$，$df_E = (G-1)(S-1)$。\n    - $MS_A = SS_A / df_A$。\n    - $MS_B = SS_B / df_B$。\n    - $MS_E = SS_E / df_E$。\n\n5.  **方差分量估计**：通过求解从期望均方导出的方程组来估计方差分量。应用非负性约束。\n    - $\\hat{\\sigma}_\\varepsilon^2 = MS_E$。\n    - $\\hat{\\sigma}_A^2 = \\max(0, (MS_A - MS_E)/S)$。\n    - $\\hat{\\sigma}_B^2 = \\max(0, (MS_B - MS_E)/G)$。\n\n6.  **主要方差识别**：通过在估计的分量 $\\{\\hat{\\sigma}_A^2, \\hat{\\sigma}_B^2, \\hat{\\sigma}_\\varepsilon^2\\}$ 中找到最大值来确定主要方差来源。结果编码为整数索引：$0$ 表示主要凝胶效应 ($\\hat{\\sigma}_A^2$)，$1$ 表示主要样品效应 ($\\hat{\\sigma}_B^2$)，$2$ 表示主要残差效应 ($\\hat{\\sigma}_\\varepsilon^2$)。\n\n该程序被实现并应用于问题陈述中指定的所有测试用例。", "answer": "```python\nimport numpy as np\n\ndef analyze_variance(data_matrix):\n    \"\"\"\n    Performs a two-way random-effects ANOVA to estimate variance components.\n\n    Args:\n        data_matrix (np.ndarray): A GxS matrix of measurements, where G is the\n                                  number of gels and S is the number of samples.\n\n    Returns:\n        tuple: A tuple containing (sigma_A_sq, sigma_B_sq, sigma_eps_sq, dominant_idx),\n               representing gel variance, sample variance, residual variance, and the\n               index of the dominant variance component.\n    \"\"\"\n    # 1. Data Transformation\n    Y = np.log(data_matrix)\n    G, S = Y.shape\n\n    # 2. Calculation of Means\n    grand_mean = np.mean(Y)\n    gel_means = np.mean(Y, axis=1)\n    sample_means = np.mean(Y, axis=0)\n\n    # 3. Calculation of Sums of Squares (SS)\n    ss_a = S * np.sum((gel_means - grand_mean)**2)\n    ss_b = G * np.sum((sample_means - grand_mean)**2)\n    \n    # Calculate residuals for SS_E\n    residuals = Y - gel_means[:, np.newaxis] - sample_means[np.newaxis, :] + grand_mean\n    ss_e = np.sum(residuals**2)\n\n    # 4. Calculation of Mean Squares (MS)\n    df_a = G - 1\n    df_b = S - 1\n    df_e = (G - 1) * (S - 1)\n\n    ms_a = ss_a / df_a if df_a > 0 else 0\n    ms_b = ss_b / df_b if df_b > 0 else 0\n    ms_e = ss_e / df_e if df_e > 0 else 0\n\n    # 5. Estimation of Variance Components\n    sigma_eps_sq = ms_e\n    sigma_a_sq = max(0, (ms_a - ms_e) / S)\n    sigma_b_sq = max(0, (ms_b - ms_e) / G)\n\n    # 6. Identification of Dominant Variance\n    variances = [sigma_a_sq, sigma_b_sq, sigma_eps_sq]\n    dominant_idx = np.argmax(variances)\n\n    return sigma_a_sq, sigma_b_sq, sigma_eps_sq, dominant_idx\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"sizes\": np.array([\n                [505, 748, 1007, 1490],\n                [495, 760, 990, 1510],\n                [500, 752, 1003, 1498]\n            ]),\n            \"intensities\": np.array([\n                [1.20, 0.85, 1.50, 1.10],\n                [1.10, 0.80, 1.55, 1.05],\n                [1.25, 0.90, 1.45, 1.00]\n            ])\n        },\n        # Case 2\n        {\n            \"sizes\": np.array([\n                [1001, 1002, 1003, 1004],\n                [1000, 1001, 1002, 1003],\n                [1002, 1003, 1004, 1005]\n            ]),\n            \"intensities\": np.array([\n                [0.50, 0.60, 0.70, 0.80],\n                [0.51, 0.61, 0.71, 0.81],\n                [0.49, 0.59, 0.69, 0.79]\n            ])\n        },\n        # Case 3\n        {\n            \"sizes\": np.array([\n                [800, 805, 795, 798],\n                [820, 825, 815, 818],\n                [780, 785, 775, 778]\n            ]),\n            \"intensities\": np.array([\n                [0.80, 0.82, 0.79, 0.81],\n                [1.60, 1.62, 1.58, 1.61],\n                [0.40, 0.42, 0.39, 0.41]\n            ])\n        }\n    ]\n\n    all_case_results = []\n    for case in test_cases:\n        size_results = analyze_variance(case[\"sizes\"])\n        intensity_results = analyze_variance(case[\"intensities\"])\n        \n        # Combine results for the case\n        combined_results = size_results + intensity_results\n        \n        # Format the list of 8 results into the required string format\n        formatted_list = [\n            f\"{combined_results[0]:.6f}\", f\"{combined_results[1]:.6f}\", f\"{combined_results[2]:.6f}\", str(combined_results[3]),\n            f\"{combined_results[4]:.6f}\", f\"{combined_results[5]:.6f}\", f\"{combined_results[6]:.6f}\", str(combined_results[7])\n        ]\n        \n        case_result_str = \"[\" + \",\".join(formatted_list) + \"]\"\n        all_case_results.append(case_result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_case_results)}]\")\n\nsolve()\n```", "id": "2740424"}, {"introduction": "一个精心设计的实验能节省宝贵的时间和资源，并产出清晰明确的结果。对于凝胶电泳而言，选择合适的凝胶浓度 $C$、电场强度 $E$ 和电泳时间 $t$ 对成功分离目标片段至关重要，尤其是当片段大小相近时。本练习将带您从数据分析转向实验的预测性设计，利用描述核酸迁移率 $\\mu(L,C)$ 和扩散效应 $D(L,C)$ 的物理模型，进行“计算机模拟”电泳实验。通过定义一个量化条带分离度的指标 $R_{ij}$，您将以计算的方式在一个参数网格中搜索最优的实验条件组合。这种基于模型的设计方法 [@problem_id:2740396] 代表了向预测性生物工程的转变，使我们能够理性地优化实验，挑战分离技术的极限，并从源头上确保实验的成功率。", "problem": "设计一个程序，该程序在给定多组具有重叠尺寸范围的聚合酶链式反应（PCR）扩增子长度的情况下，选择电泳分离参数，以利用核酸在筛分基质中迁移和谱带展宽的基本物理模型来最大化分辨率。您的程序必须在凝胶浓度、电场和运行时间的离散网格上进行搜索，以确定能够最大化一个明确定义的目标函数的参数组合，该目标函数反映了泳道上相邻谱带间最差情况下的成对分辨率。不考虑任何操作程序；该任务纯粹是基于计算和模型的。\n\n从以下基础出发，该基础得到了双链脱氧核糖核酸（DNA）在典型凝胶电泳条件下的大量实验和理论支持：\n\n- 在自由溶液中，长双链DNA的电泳迁移率由于电荷-摩擦比近似恒定而大致与大小无关；将自由溶液迁移率表示为 $\\mu_{\\mathrm{fs}}$，单位为 $\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$。\n- 在琼脂糖等多聚物筛分基质中，Ferguson 关系指出，对于固定的片段大小，$\\log \\mu$ 随凝胶浓度的增加而近似线性下降。一个与大小相关的延迟系数捕捉了较大片段增强的筛分效应。\n- 在均匀电场 $E$ 下，经过时间 $t$ 后的迁移距离为 $x = v \\, t$，其中 $v = \\mu E$，$\\mu$ 是依赖于大小和凝胶的迁移率。$x$ 的单位选择为 $\\mathrm{mm}$。\n- 谱带展宽至少源于两个方面：初始上样宽度和扩散。将谱带方差建模为与初始半峰全宽相关的方差、随时间累积的扩散方差以及一个小的仪器方差本底之和。扩散系数 $D$ 是片段大小和凝胶浓度的递减函数。在时间 $t$ 内，扩散方差的贡献为 $2 D t$，单位为 $\\mathrm{length^2}$。\n\n为使问题完全明确且可测试，采用以下具体的模型选择：\n\n- 使用迁移率模型\n$$\n\\mu(L,C) \\;=\\; \\mu_{\\mathrm{fs}} \\, \\exp\\!\\left(-\\kappa \\, C \\,\\left(\\frac{L}{L_0}\\right)^{\\beta}\\right),\n$$\n其中 $L$ 是片段长度（单位：碱基对），$C$ 是琼脂糖凝胶浓度（表示为重量/体积百分比），$\\mu_{\\mathrm{fs}} = 3.0 \\times 10^{-4} \\;\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$，$\\kappa = 1.2 \\;\\mathrm{percent^{-1}}$，$L_0 = 1000 \\;\\mathrm{bp}$，以及 $\\beta = 0.45$。\n- 使用扩散模型\n$$\nD(L,C) \\;=\\; \\frac{D_0}{1 + \\left(\\frac{L}{L_d}\\right)^{\\delta}} \\,\\exp(-d_c \\, C),\n$$\n其中 $D_0 = 1.5 \\times 10^{-7} \\;\\mathrm{cm^2 \\, s^{-1}}$，$L_d = 100 \\;\\mathrm{bp}$，$\\delta = 0.6$，以及 $d_c = 0.3 \\;\\mathrm{percent^{-1}}$。\n- 通过乘以 $10$ 将位置从 $\\mathrm{cm}$ 转换为 $\\mathrm{mm}$。通过乘以 $100$ 将方差从 $\\mathrm{cm^2}$ 转换为 $\\mathrm{mm^2}$。\n- 设初始半峰全宽为 $w_0$（单位：$\\mathrm{mm}$），并使用高斯等效标准差 $\\sigma_0 = \\dfrac{w_0}{2 \\sqrt{2 \\ln 2}}$。设仪器方差本底为 $\\sigma_{\\mathrm{inst}}^2$，其中 $\\sigma_{\\mathrm{inst}}$ 单位为 $\\mathrm{mm}$。\n- 对于给定的参数三元组 $(C,E,t)$，计算谱带 $i$ 的位置为\n$$\nx_i \\;=\\; 10 \\,\\mu(L_i,C)\\, E \\, t,\n$$\n单位为 $\\mathrm{mm}$，方差为\n$$\n\\sigma_i^2 \\;=\\; \\sigma_0^2 \\;+\\; 2 D(L_i,C) \\, t \\times 100 \\;+\\; \\sigma_{\\mathrm{inst}}^2,\n$$\n单位为 $\\mathrm{mm^2}$。\n- 定义相邻谱带 $i$ 和 $j$（按 $x$ 排序后相邻）之间的成对分辨率为\n$$\nR_{ij} \\;=\\; \\frac{|x_i - x_j|}{2 \\sqrt{\\sigma_i^2 + \\sigma_j^2}}.\n$$\n- 对于每个参数三元组 $(C,E,t)$，按字典序定义要最大化的目标如下。设 $A$ 为泳道上所有相邻对的 $R_{ij}$ 的最小值。设 $B$ 为这些 $R_{ij}$ 的算术平均值。最大化 $A$；如果两个参数三元组的 $A$ 值在 $10^{-9}$ 的容差内相等，则选择具有较大 $B$ 值的那个；如果仍然持平，则选择具有较小 $C$ 值的那个，然后是较小 $E$ 值，再然后是较小 $t$ 值。\n- 强制执行几何有效性约束。设 $x_{\\min}$ 和 $x_{\\max}$ 分别为最小和最大谱带位置。仅当 $x_{\\min} \\ge m_{\\mathrm{start}}$ 且 $x_{\\max} \\le L_{\\mathrm{gel}} - m_{\\mathrm{end}}$ 时，分离才有效，其中 $m_{\\mathrm{start}}$ 和 $m_{\\mathrm{end}}$ 是以 $\\mathrm{mm}$ 为单位的边距，$L_{\\mathrm{gel}}$ 是以 $\\mathrm{mm}$ 为单位的泳道长度。如果无效，则从考虑中丢弃该参数三元组。\n\n您的程序必须评估提供的一组测试案例。对于每个案例，输入是片段长度列表、$C$（百分比）、$E$（$\\mathrm{V/cm}$）和 $t$（$\\mathrm{s}$）的离散网格、泳道长度 $L_{\\mathrm{gel}}$（$\\mathrm{mm}$）、起始和末端边距 $m_{\\mathrm{start}}$ 和 $m_{\\mathrm{end}}$（$\\mathrm{mm}$），以及上样参数 $w_0$ 和 $\\sigma_{\\mathrm{inst}}$（$\\mathrm{mm}$）。温度固定在 $T = 298 \\;\\mathrm{K}$，且未在模型中显式出现。对于每个案例，您的程序必须输出所选的最优元组 $(C^\\star, E^\\star, t^\\star, A^\\star)$，其中 $A^\\star$ 是最优的最小相邻分辨率，格式为列表 $[C^\\star, E^\\star, t^\\star, A^\\star]$。然后将所有案例的列表聚合到单行中。\n\n将 $C^\\star$ 表示为不带百分号的百分比小数，将 $E^\\star$ 表示为 $\\mathrm{V/cm}$，将 $t^\\star$ 表示为 $\\mathrm{s}$，将 $A^\\star$ 表示为无量纲数。将 $C^\\star$ 和 $E^\\star$ 四舍五入到三位小数，将 $t^\\star$ 输出为整数，并将 $A^\\star$ 四舍五入到三位小数。\n\n需实现的测试套件：\n\n- 案例 1：\n    - 片段长度（单位：碱基对）：$[320, 345, 410, 500, 620, 710]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.8, 1.2, 1.6, 2.0]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[6.0, 8.0, 10.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[2400, 3600, 4800]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$60$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 1.0$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n- 案例 2：\n    - 片段长度（单位：碱基对）：$[100, 180, 250, 400, 700, 1200, 1800]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.5, 1.0, 1.5, 2.0, 2.5]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[5.0, 7.0, 9.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[3000, 4200, 5400]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$70$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 0.8$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n- 案例 3：\n    - 片段长度（单位：碱基对）：$[500, 510, 520, 600]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.6, 0.9, 1.2, 1.5, 1.8, 2.1]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[6.0, 7.0, 8.0, 9.0, 10.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[2700, 3300, 3900, 4500]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$60$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 0.6$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n- 案例 4：\n    - 片段长度（单位：碱基对）：$[80, 90, 100, 3000]$。\n    - 凝胶浓度网格 $C$（百分比）：$[0.8, 1.3, 1.8, 2.3]$。\n    - 电场网格 $E$（单位：$\\mathrm{V/cm}$）：$[4.0, 6.0, 8.0]$。\n    - 时间网格 $t$（单位：$\\mathrm{s}$）：$[3600, 5400, 7200]$。\n    - 泳道长度 $L_{\\mathrm{gel}}$（单位：$\\mathrm{mm}$）：$80$。\n    - 边距 $m_{\\mathrm{start}} = 5$ 和 $m_{\\mathrm{end}} = 5$（单位：$\\mathrm{mm}$）。\n    - 上样半峰全宽 $w_0 = 0.9$ 和仪器标准差 $\\sigma_{\\mathrm{inst}} = 0.05$（单位：$\\mathrm{mm}$）。\n\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表，每个案例的结果格式化为列表 $[C^\\star,E^\\star,t^\\star,A^\\star]$。例如，对于两个假设的案例，一个有效的输出格式为 $[[0.800,6.000,3600,1.234],[1.600,8.000,4800,0.987]]$。", "solution": "问题陈述已经过严格验证，并被确定为有效。它具有科学依据、问题明确、客观且内部一致，提出了一个基于已建立的DNA凝胶电泳物理模型的可解计算优化任务。因此，我们将着手提供一个完整的、有原则的解决方案。\n\n该问题要求设计一种算法，以确定最优的电泳分离参数 $(C, E, t)$——分别为凝胶浓度、电场强度和运行时间——从而最大化给定一组脱氧核糖核酸（DNA）片段的可分辨性。优化是通过对这些参数的离散集合进行网格搜索来执行的。该解决方案基于DNA迁移和谱带展宽的定量物理模型。\n\n每个测试案例的算法流程如下：\n\n1.  **系统初始化**：\n    对于每个测试案例，我们给定一组DNA片段长度 $\\{L_i\\}$，$C$、$E$ 和 $t$ 的离散网格，以及实验常数：泳道长度 $L_{\\mathrm{gel}}$、边距 $m_{\\mathrm{start}}$ 和 $m_{\\mathrm{end}}$、初始谱带宽度 $w_0$ 以及仪器噪声标准差 $\\sigma_{\\mathrm{inst}}$。\n    由上样宽度 $w_0$（单位：mm）贡献的初始方差对于给定实验中的所有谱带都是恒定的。假设为高斯谱带轮廓，初始谱带标准差 $\\sigma_0$ 由 $\\sigma_0 = \\frac{w_0}{2 \\sqrt{2 \\ln 2}}$ 给出，其方差为 $\\sigma_0^2$。仪器方差本底给定为 $\\sigma_{\\mathrm{inst}}^2$。\n\n2.  **参数网格搜索**：\n    算法的核心是对所提供的离散网格中所有可能的参数组合 $(C, E, t)$ 进行系统性搜索。对于每个参数三元组，我们评估其有效性。\n\n3.  **物理模型评估**：\n    对于给定的参数三元组 $(C, E, t)$ 和每个长度为 $L_i$（单位：碱基对）的DNA片段，我们计算其最终位置 $x_i$ 和谱带方差 $\\sigma_i^2$。\n\n    a.  **电泳迁移率**：使用指定关系计算迁移率 $\\mu(L_i, C)$，单位为 $\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$：\n        $$\n        \\mu(L_i,C) = \\mu_{\\mathrm{fs}} \\, \\exp\\!\\left(-\\kappa \\, C \\,\\left(\\frac{L_i}{L_0}\\right)^{\\beta}\\right)\n        $$\n        其中 $\\mu_{\\mathrm{fs}} = 3.0 \\times 10^{-4} \\;\\mathrm{cm^2 \\, V^{-1} \\, s^{-1}}$，$\\kappa = 1.2 \\;\\mathrm{percent^{-1}}$，$L_0 = 1000 \\;\\mathrm{bp}$，以及 $\\beta = 0.45$。\n\n    b.  **迁移距离**：迁移距离 $x_i$（单位：mm）由迁移率 $\\mu(L_i, C)$、电场 $E$（单位：V/cm）和时间 $t$（单位：s）计算得出：\n        $$\n        x_i = 10 \\cdot \\mu(L_i,C) \\cdot E \\cdot t\n        $$\n        因子 $10$ 将结果从 $\\mathrm{cm}$ 转换为 $\\mathrm{mm}$。\n\n    c.  **扩散系数**：扩散系数 $D(L_i, C)$（单位：$\\mathrm{cm^2 \\, s^{-1}}$）计算如下：\n        $$\n        D(L_i,C) = \\frac{D_0}{1 + \\left(\\frac{L_i}{L_d}\\right)^{\\delta}} \\exp(-d_c \\, C)\n        $$\n        其中 $D_0 = 1.5 \\times 10^{-7} \\;\\mathrm{cm^2 \\, s^{-1}}$，$L_d = 100 \\;\\mathrm{bp}$，$\\delta = 0.6$，以及 $d_c = 0.3 \\;\\mathrm{percent^{-1}}$。\n\n    d.  **谱带方差**：谱带的总方差 $\\sigma_i^2$（单位：$\\mathrm{mm^2}$）是初始方差、扩散方差和仪器方差之和：\n        $$\n        \\sigma_i^2 = \\sigma_0^2 + 200 \\cdot D(L_i,C) \\cdot t + \\sigma_{\\mathrm{inst}}^2\n        $$\n        因子 $200$ 源于扩散方差项 $2 D t$（单位：$\\mathrm{cm^2}$）通过乘以 $100$ 转换为 $\\mathrm{mm^2}$。\n\n4.  **约束验证与目标计算**：\n    a.  **几何约束**：计算完所有片段的位置 $\\{x_i\\}$ 后，我们确定最小和最大位置，$x_{\\min} = \\min(\\{x_i\\})$ 和 $x_{\\max} = \\max(\\{x_i\\})$。只有当满足几何约束时，参数三元组 $(C, E, t)$ 才被认为是有效的：\n        $$\n        x_{\\min} \\ge m_{\\mathrm{start}} \\quad \\text{和} \\quad x_{\\max} \\le L_{\\mathrm{gel}} - m_{\\mathrm{end}}\n        $$\n        如果一个三元组无效，它将被丢弃，算法继续处理下一个三元组。\n\n    b.  **分辨率计算**：对于一个有效的三元组，我们评估其分离质量。首先根据片段的迁移距离 $x_i$ 对其进行排序。然后计算排序后列表中每对相邻谱带 $(i, j)$ 之间的成对分辨率 $R_{ij}$：\n        $$\n        R_{ij} = \\frac{|x_i - x_j|}{2 \\sqrt{\\sigma_i^2 + \\sigma_j^2}}\n        $$\n\n    c.  **目标函数**：从所有相邻对分辨率的集合 $\\{R_{ij}\\}$ 中，我们计算主要和次要目标度量：\n        -   主要目标 $A$：最小分辨率，$A = \\min(\\{R_{ij}\\})$。这代表了泳道上最差的分离情况。\n        -   次要目标 $B$：分辨率的算术平均值，$B = \\mathrm{mean}(\\{R_{ij}\\})$。\n\n5.  **字典序优化**：\n    算法维护已找到的最佳参数集 $(C^\\star, E^\\star, t^\\star)$ 及其对应的目标值 $(A^\\star, B^\\star)$。对于每个新的有效参数集 $(C, E, t)$ 及其目标 $(A, B)$，执行字典序比较以更新最优解：\n    1.  如果 $A > A^\\star + 10^{-9}$，则新集合更优。\n    2.  如果 $|A - A^\\star| \\le 10^{-9}$，且 $B > B^\\star$，则新集合更优。\n    3.  如果 $B$ 也持平，且 $C < C^\\star$，则新集合更优。\n    4.  如果 $C$ 也持平，且 $E < E^\\star$，则新集合更优。\n    5.  如果 $E$ 也持平，且 $t < t^\\star$，则新集合更优。\n\n    此过程保证从网格中选出唯一的最佳参数集。\n\n6.  **输出生成**：\n    在搜索完整个网格后，存储最优参数 $(C^\\star, E^\\star, t^\\star)$ 和对应的最佳最小分辨率 $A^\\star$。对所有测试案例重复此过程。最终结果根据指定精度进行格式化（$C^\\star$、$E^\\star$ 和 $A^\\star$ 保留 $3$ 位小数；$t^\\star$ 为整数），并按要求编译成单个输出字符串。", "answer": "```python\nimport numpy as np\n\n# Define physical and model constants as per the problem statement.\nMU_FS = 3.0e-4  # cm^2 V^-1 s^-1\nKAPPA = 1.2     # percent^-1\nL0 = 1000.0     # bp\nBETA = 0.45\n\nD0 = 1.5e-7     # cm^2 s^-1\nLD = 100.0      # bp\nDELTA = 0.6\nDC = 0.3        # percent^-1\nTOLERANCE = 1e-9\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation and solving process for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"lengths\": [320, 345, 410, 500, 620, 710],\n            \"C_grid\": [0.8, 1.2, 1.6, 2.0],\n            \"E_grid\": [6.0, 8.0, 10.0],\n            \"t_grid\": [2400, 3600, 4800],\n            \"L_gel\": 60.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 1.0,\n            \"sigma_inst\": 0.05\n        },\n        {\n            \"lengths\": [100, 180, 250, 400, 700, 1200, 1800],\n            \"C_grid\": [0.5, 1.0, 1.5, 2.0, 2.5],\n            \"E_grid\": [5.0, 7.0, 9.0],\n            \"t_grid\": [3000, 4200, 5400],\n            \"L_gel\": 70.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 0.8,\n            \"sigma_inst\": 0.05\n        },\n        {\n            \"lengths\": [500, 510, 520, 600],\n            \"C_grid\": [0.6, 0.9, 1.2, 1.5, 1.8, 2.1],\n            \"E_grid\": [6.0, 7.0, 8.0, 9.0, 10.0],\n            \"t_grid\": [2700, 3300, 3900, 4500],\n            \"L_gel\": 60.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 0.6,\n            \"sigma_inst\": 0.05\n        },\n        {\n            \"lengths\": [80, 90, 100, 3000],\n            \"C_grid\": [0.8, 1.3, 1.8, 2.3],\n            \"E_grid\": [4.0, 6.0, 8.0],\n            \"t_grid\": [3600, 5400, 7200],\n            \"L_gel\": 80.0,\n            \"m_start\": 5.0,\n            \"m_end\": 5.0,\n            \"w0\": 0.9,\n            \"sigma_inst\": 0.05\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        best_solution = {\n            \"params\": None,\n            \"A\": -1.0,\n            \"B\": -1.0\n        }\n\n        # Pre-calculate constant variance terms\n        sigma0_sq = (case[\"w0\"] / (2 * np.sqrt(2 * np.log(2))))**2\n        sigma_inst_sq = case[\"sigma_inst\"]**2\n        \n        # Grid search over all parameter combinations\n        for C in case[\"C_grid\"]:\n            for E in case[\"E_grid\"]:\n                for t in case[\"t_grid\"]:\n                    \n                    bands_data = []\n                    for L in case[\"lengths\"]:\n                        # Calculate mobility\n                        mu = MU_FS * np.exp(-KAPPA * C * (L / L0)**BETA)\n                        \n                        # Calculate diffusion coefficient\n                        D = (D0 / (1 + (L / LD)**DELTA)) * np.exp(-DC * C)\n                        \n                        # Calculate position in mm\n                        x = 10.0 * mu * E * t\n                        \n                        # Calculate variance in mm^2\n                        sigma_sq = sigma0_sq + 200.0 * D * t + sigma_inst_sq\n\n                        bands_data.append({\"x\": x, \"var\": sigma_sq})\n                    \n                    positions = [b[\"x\"] for b in bands_data]\n                    x_min, x_max = min(positions), max(positions)\n\n                    # Check geometric validity constraint\n                    if x_min < case[\"m_start\"] or x_max > (case[\"L_gel\"] - case[\"m_end\"]):\n                        continue\n\n                    # Sort bands by position to find adjacent pairs\n                    bands_data.sort(key=lambda b: b[\"x\"])\n                    \n                    # Calculate pairwise resolvabilities\n                    resolvabilities = []\n                    for i in range(len(bands_data) - 1):\n                        b1 = bands_data[i]\n                        b2 = bands_data[i+1]\n                        \n                        delta_x = b2[\"x\"] - b1[\"x\"]\n                        sum_var = b1[\"var\"] + b2[\"var\"]\n                        \n                        R_ij = delta_x / (2 * np.sqrt(sum_var))\n                        resolvabilities.append(R_ij)\n                        \n                    # Calculate objective functions A and B\n                    A = min(resolvabilities)\n                    B = np.mean(resolvabilities)\n\n                    # Lexicographical comparison to find the optimal solution\n                    if best_solution[\"params\"] is None:\n                         best_solution[\"params\"] = (C, E, t)\n                         best_solution[\"A\"] = A\n                         best_solution[\"B\"] = B\n                    else:\n                        best_A, best_B = best_solution[\"A\"], best_solution[\"B\"]\n                        best_C, best_E, best_t = best_solution[\"params\"]\n                        is_better = False\n                        \n                        # Maximize A\n                        if A > best_A + TOLERANCE:\n                            is_better = True\n                        elif abs(A - best_A) <= TOLERANCE:\n                            # Maximize B\n                            if B > best_B:\n                                is_better = True\n                            elif B == best_B:\n                                # Minimize C\n                                if C < best_C:\n                                    is_better = True\n                                elif C == best_C:\n                                    # Minimize E\n                                    if E < best_E:\n                                        is_better = True\n                                    elif E == best_E:\n                                        # Minimize t\n                                        if t < best_t:\n                                            is_better = True\n                            \n                        if is_better:\n                            best_solution[\"params\"] = (C, E, t)\n                            best_solution[\"A\"] = A\n                            best_solution[\"B\"] = B\n        \n        C_star, E_star, t_star = best_solution[\"params\"]\n        A_star = best_solution[\"A\"]\n        \n        all_results.append([C_star, E_star, t_star, A_star])\n\n    # Format the final output string exactly as specified\n    inner_list_strs = []\n    for r in all_results:\n        C_val, E_val, t_val, A_val = r\n        s = f\"[{C_val:.3f},{E_val:.3f},{int(t_val)},{A_val:.3f}]\"\n        inner_list_strs.append(s)\n    \n    final_output = f\"[{','.join(inner_list_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2740396"}]}