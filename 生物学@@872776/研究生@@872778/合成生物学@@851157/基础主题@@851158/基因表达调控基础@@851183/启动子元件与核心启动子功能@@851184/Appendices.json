{"hands_on_practices": [{"introduction": "本练习为定量理解启动子强度奠定了基础。通过将一个简单的加性自由能模型应用于细菌启动子 [@problem_id:2764635]，您将学习到像 $-10$ 和 $-35$ 盒这样的独立DNA元件如何对RNA聚合酶的总结合亲和力做出贡献。这个练习强化了一个重要的生物物理学原理：复杂的生物学功能通常可以被分解为更简单的、独立相互作用的总和。", "problem": "在细菌启动子的转录起始的热力学占据模型中，RNA聚合酶（RNAP）的结合被视为一个可逆的平衡过程，其中RNAP结合态的统计权重由玻尔兹曼统计决定。当不同的启动子接触点相互独立时，每个接触点对自由能的贡献是可加的。考虑一个启动子结构，其对RNAP结合自由能有四种贡献：-10元件、-35元件、-10和-35之间的间隔区长度/几何结构，以及上游启动子（UP）元件。一个缺乏所有这四种特征的参考启动子被用来定义结合自由能标度的零点。对于一个特定的工程改造启动子，测得的每个特征对RNAP结合自由能的贡献（相对于参考启动子）如下：\n- -10元件：$-4\\,k_{\\mathrm{B}}T$\n- -35元件：$-3\\,k_{\\mathrm{B}}T$\n- 间隔区错配罚分：$+2\\,k_{\\mathrm{B}}T$\n- 上游启动子（UP）元件：$-1\\,k_{\\mathrm{B}}T$\n这里，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。在这些接触点满足标准独立性假设的情况下，该工程改造启动子相对于参考启动子的RNAP结合自由能的净变化是多少？请用一个带符号的数字来表示你的答案，单位为 $k_{\\mathrm{B}}T$（在最终填写时不要包含单位）。请提供精确值，无需四舍五入。", "solution": "其基本基础是结合平衡的统计力学。对于一个结合到位点上的大分子，能量为 $E$ 的微观态的统计权重与 $\\exp(-\\beta E)$ 成正比，其中 $\\beta = 1/(k_{\\mathrm{B}}T)$。结合自由能变化 $\\Delta G$ 通过 $\\Delta G = -k_{\\mathrm{B}}T \\ln K$ 定义了平衡常数，并且对于独立的子系统，总配分函数可以因子分解。\n\n具体来说，如果不同的、无相互作用的接触点在形成时各自贡献一个自由能变化 $\\Delta G_{i}$，那么结合复合物相对于未结合状态的总统计权重是来自每个接触点的权重的乘积：\n$$\nw_{\\text{bound}} = \\prod_{i} \\exp\\!\\left(-\\beta \\Delta G_{i}\\right) = \\exp\\!\\left(-\\beta \\sum_{i} \\Delta G_{i}\\right).\n$$\n对上式取 $-k_{\\mathrm{B}}T \\ln(\\cdot)$ 运算，得到总自由能变化：\n$$\n\\Delta G_{\\text{total}} = \\sum_{i} \\Delta G_{i}.\n$$\n因此，在独立性假设下，自由能是相加的。\n\n在这个问题中，每个特征的贡献已经以 $k_{\\mathrm{B}}T$ 为单位给出了自由能：\n- -10元件：$\\Delta G_{-10} = -4\\,k_{\\mathrm{B}}T$，\n- -35元件：$\\Delta G_{-35} = -3\\,k_{\\mathrm{B}}T$，\n- 间隔区错配罚分：$\\Delta G_{\\text{spacer}} = +2\\,k_{\\mathrm{B}}T$，\n- 上游启动子（UP）元件：$\\Delta G_{\\text{UP}} = -1\\,k_{\\mathrm{B}}T$。\n\n相对于参考启动子的RNAP结合自由能的净变化为\n$$\n\\Delta G_{\\text{total}} \\;=\\; \\Delta G_{-10} + \\Delta G_{-35} + \\Delta G_{\\text{spacer}} + \\Delta G_{\\text{UP}}\n\\;=\\; (-4 - 3 + 2 - 1)\\,k_{\\mathrm{B}}T\n\\;=\\; -6\\,k_{\\mathrm{B}}T.\n$$\n题目要求答案以 $k_{\\mathrm{B}}T$ 为单位，用一个带符号的数字表示（在最终填写时省略单位），所以所需的数值是-6。", "answer": "$$\\boxed{-6}$$", "id": "2764635"}, {"introduction": "从相对简单的原核生物转向更为复杂的真核生物，本练习挑战您将分子机器的知识应用于一类不同的启动子。在无TATA盒的启动子上，转录机器的招募依赖于一套涉及多个亚基的、复杂的蛋白质-DNA相互作用逻辑 [@problem_id:2764685]。这个问题将提高您基于机制进行推理的能力，帮助您理解核心启动子结构如何决定起始前复合物的组装路径。", "problem": "你正在为一个合成构建体设计一个最小真核核心启动子，旨在驱动RNA聚合酶II (Pol II)的转录。你组装的序列在$+1$位置包含一个典型的起始子(Inr)，在$+28$到$+32$位置包含一个强下游启动子元件(DPE)，但在经典的$-31$到$-26$窗口处缺少一个TATA盒。请仅使用转录起始的基本原理和通用转录因子的既定作用，预测TATA结合蛋白(TBP)最可能如何被招募到此启动子上，并证明该机制的合理性。选择唯一的最佳陈述。\n\n- A. TBP的招募将主要由转录因子IID (TFIID)内的TBP相关因子(TAFs)介导，因为TAFs与$+1$处的Inr和$+28$至$+32$处的DPE直接接触，将TFIID锚定在无TATA盒的核心启动子上，并为预起始复合物的组装定位TBP。\n- B. TBP将直接识别并结合DPE以替代TATA盒，因为DPE是一个下游TBP结合位点，能够独立于TFIID催化预起始复合物的形成。\n- C. TBP的招募将主要由转录因子IIB (TFIIB)介导，TFIIB识别一个功能上替代TATA盒的B识别元件(BRE)，从而即使在没有TFIID–DNA接触的情况下也能招募TBP。\n- D. TBP的招募将独立于TFIID，因为中介体(Mediator)直接识别$+28$到$+32$处的DPE，并将TBP递送到启动子，无需TAF–DNA相互作用。\n- E. TBP的招募将主要由上游序列特异性激活子驱动，其激活域直接接触TBP，使得TAF–DNA相互作用在无TATA盒的Inr+DPE启动子上变得可有可无。\n\n假设通用转录因子具有经典作用、中心法则成立，以及一个既定观察：不同的核心启动子元件决定了不同的转录因子识别模式。不要假设超出后生动物中Pol II转录起始常规所需因子之外的特殊辅助因子。", "solution": "该问题陈述已通过验证。\n\n**第1步：提取已知条件**\n-   正在为一个合成构建体设计一个最小真核核心启动子。\n-   该启动子旨在驱动RNA聚合酶II (Pol II)的转录。\n-   启动子序列在转录起始位点（标记为$+1$）的中心包含一个典型的起始子(Inr)元件。\n-   启动子序列在$+28$到$+32$位置包含一个强下游启动子元件(DPE)。\n-   启动子明确缺少在典型区域$-31$到$-26$的TATA盒。\n-   问题要求预测TATA结合蛋白(TBP)被招募到这种特定启动子配置的最可能机制。\n-   分析必须基于转录起始的基本原理以及后生动物中通用转录因子(GTFs)的经典作用。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据。所描述的启动子结构——包含一个起始子（Inr）和一个下游启动子元件（DPE）但缺少TATA盒——代表了在后生动物中（特别是在发育基因和管家基因中）发现的一类特征明确的RNA聚合酶II启动子。提到的组分（Pol II, TBP, TFIID, TAFs, Inr, DPE）都是分子生物学领域已确立的实体。该问题陈述清晰，提供了一个明确的场景，并要求基于既定机制进行预测。它没有歧义、矛盾或基于错误的假设。施加的约束条件将分析引向转录起始的标准教科书模型，确保了客观性。\n\n**第3步：结论与行动**\n该问题有效。解答将从第一性原理出发推导正确机制，并评估每个选项。\n\n**解答推导**\nRNA聚合酶II (Pol II)转录起始的核心任务是在核心启动子上组装预起始复合物(PIC)。TATA结合蛋白(TBP)是通用转录因子TFIID的一个亚基，在催化此组装过程中起着至关重要的作用。\n\n在含有TATA盒的启动子中，TBP直接结合到TATA序列（共有序列为$TATA(A/T)A(A/T)R$），导致DNA急剧弯曲，并作为招募其他GTFs的平台。然而，本问题中的启动子明确是“无TATA盒”的。因此，必须有另一种机制负责将TBP招募到转录起始位点。\n\n问题陈述该启动子包含另外两个核心启动子元件：位于$+1$的起始子(Inr)和位于$+28$到$+32$的下游启动子元件(DPE)。这些元件为转录机器提供了替代的识别位点。识别这些无TATA盒启动子结构的关键因子是多亚基TFIID复合物。TFIID由TBP和大约$14$个TBP相关因子(TAFs)组成。\n\n针对无TATA盒、含DPE的启动子，既定模型如下：\n$1$. TFIID复合物通过其TAF亚基与序列特异性接触来识别核心启动子，而不是通过TBP。\n$2$. 具体来说，Inr元件由TFIID的TAF1和TAF2亚基识别。\n$3$. DPE元件由TAF6和TAF9亚基的异二聚体识别。\n$4$. 这些TAFs与Inr和DPE序列的协同结合，将整个TFIID复合物牢固地锚定在启动子上。\n$5$. 由于TBP是TFIID的化学计量组分，这种TFIID的锚定有效地构成了TBP到启动子区域的招募。在这种情况下，TBP被正确定位在起始位点附近，但由于没有TATA盒，它不与DNA发生序列特异性接触。\n\n这个TFIID-启动子复合物随后形成稳定的支架，PIC的其余组分，包括TFIIA、TFIIB、Pol II/TFIIF、TFIIE和TFIIH，在其上组装以起始转录。\n\n因此，TBP被招募到无TATA盒的Inr+DPE启动子的主要机制是TAFs识别Inr和DPE元件，进而将包括TBP在内的整个TFIID复合物带到DNA上。\n\n**选项评估**\n\n**A. TBP的招募将主要由转录因子IID (TFIID)内的TBP相关因子(TAFs)介导，因为TAFs与$+1$处的Inr和$+28$至$+32$处的DPE直接接触，将TFIID锚定在无TATA盒的核心启动子上，并为预起始复合物的组装定位TBP。**\n该陈述准确地描述了既定机制。TFIID内的TAFs识别Inr和DPE元件，这些相互作用负责将包括TBP在内的整个TFIID复合物招募到这类启动子上。这是经典途径。\n**结论：正确。**\n\n**B. TBP将直接识别并结合DPE以替代TATA盒，因为DPE是一个下游TBP结合位点，能够独立于TFIID催化预起始复合物的形成。**\n该陈述在事实上是错误的。TBP识别并结合TATA盒。DPE是由TFIID的TAF6和TAF9亚基特异性识别的。TBP不结合DPE。此外，在这种情况下，TBP“独立于TFIID”起作用的想法是不合逻辑的，因为TBP是TFIID的一部分。\n**结论：错误。**\n\n**C. TBP的招募将主要由转录因子IIB (TFIIB)介导，TFIIB识别一个功能上替代TATA盒的B识别元件(BRE)，从而即使在没有TFIID–DNA接触的情况下也能招募TBP。**\n该陈述因多个原因而错误。首先，问题没有说明存在B识别元件(BRE)。其次，BRE是与TATA盒协同作用的，由TFIIB识别以稳定TBP的结合；它不能在DPE驱动的启动子上“功能上替代”TATA盒以独立招募TBP。在Inr+DPE启动子上的主要识别事件涉及TFIID，而不是TFIIB。\n**结论：错误。**\n\n**D. TBP的招募将独立于TFIID，因为中介体(Mediator)直接识别$+28$到$+32$处的DPE，并将TBP递送到启动子，无需TAF–DNA相互作用。**\n该陈述错误地描述了中介体复合物的功能。中介体是一个大型共激活因子复合物，主要功能是在结合于增强子上的序列特异性转录激活子和启动子上的基础转录机器之间架起桥梁。它不直接识别像DPE这样的核心启动子元件，也不负责“递送”TBP到启动子。TFIID是核心启动子的主要识别因子。\n**结论：错误。**\n\n**E. TBP的招募将主要由上游序列特异性激活子驱动，其激活域直接接触TBP，使得TAF–DNA相互作用在无TATA盒的Inr+DPE启动子上变得可有可无。**\n虽然激活子与TBP（或TAFs）之间的相互作用是转录调控的一个重要方面，但这是一种增强或调控机制，而不是核心启动子识别的基本机制。声称这些相互作用使得TAF–DNA相互作用“可有可无”是错误的。对于Inr+DPE启动子，TAFs对这些特定DNA序列的识别是起始的决定性和必要特征。没有这些接触，TFIID将无法稳定地招募到这种特定的启动子结构上。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2764685"}, {"introduction": "任何合成部件的真正考验是其在活细胞中的表现，其功能不可避免地会受到其基因组环境的影响。最后一个练习从理论模型转向数据分析的实际挑战 [@problem_id:2764696]。您将实现一种计算方法，从实验数据中将启动子的内在强度与位置依赖性效应解耦出来，这是稳健地表征和工程化基因线路的一项基本技能。", "problem": "设计并实现一个程序，该程序能够利用多个独立的基因组插入位点，根据一组在这些位点上整合的启动子的转录输出测量值，解卷积出启动子的内在本征强度和基因组环境效应。请从以下基本依据出发：分子生物学中心法则（脱氧核糖核酸到核糖核酸到蛋白质），以及一个广泛使用的观察结果，即在稳态报告基因检测中，当信使核糖核酸的翻译和降解速度远快于转录起始的时间尺度时，稳态报告信号与转录起始速率成正比。在合成生物学中，对于核心启动子功能，一个标准且经过充分检验的假设是，内在本征启动子强度和基因组环境对转录速率的贡献是乘性的，因此经过对数变换后，它们的贡献是加性的。在此基础上，对于在插入位点 $j$ 的启动子 $i$ 在重复实验 $r$ 中测得的对数表达量，可以建模为一个内在本征启动子项、一个位点环境项和一个均值为零的残差之和。\n\n您的任务是，对于下述每个测试用例，从基于已知真实值构建的合成数据集中恢复内在启动子强度和位点效应。请仅使用线性代数推理，并实现一个在可识别性约束下最小化残差平方和的估计量。\n\n数学模型与可识别性：\n- 设共有 $P$ 个启动子，$S$ 个位点，以及每个启动子-位点组合有 $R$ 次重复实验。\n- 设 $\\alpha_i$ 为启动子 $i \\in \\{0,1,\\ldots,P-1\\}$ 在对数尺度上的内在本征强度。\n- 设 $\\beta_j$ 为位点 $j \\in \\{0,1,\\ldots,S-1\\}$ 在对数尺度上的位点效应。\n- 设 $\\varepsilon_{i,j,r}$ 是一个根据每个测试用例指定方式构建的确定性均值为零的残差。\n- 测得的对数表达量为\n$$\ny_{i,j,r} = \\alpha_i + \\beta_j + \\varepsilon_{i,j,r}.\n$$\n- 施加可识别性约束\n$$\n\\sum_{i=0}^{P-1} \\alpha_i = 0, \\qquad \\sum_{j=0}^{S-1} \\beta_j = 0.\n$$\n- 通过最小化下式来估计 $(\\alpha_i)_{i=0}^{P-1}$ 和 $(\\beta_j)_{j=0}^{S-1}$\n$$\n\\sum_{i=0}^{P-1} \\sum_{j=0}^{S-1} \\sum_{r=0}^{R-1} \\left(y_{i,j,r} - \\alpha_i - \\beta_j\\right)^2\n$$\n并服从上述两个线性等式约束。\n\n测试套件（所有值均为无单位的对数表达量单位）：\n\n情况 A（通用，平衡）：\n- $P = 5$, $S = 4$, $R = 2$。\n- 真实内在启动子向量\n$$\n\\boldsymbol{\\alpha}^{\\star} = (-0.40, -0.10, 0.00, 0.20, 0.30),\n$$\n满足 $\\sum_i \\alpha_i^{\\star} = 0$。\n- 真实位点环境向量\n$$\n\\boldsymbol{\\beta}^{\\star} = (-0.30, -0.10, 0.15, 0.25),\n$$\n满足 $\\sum_j \\beta_j^{\\star} = 0$。\n- 残差通过以下方式确定性地定义\n$$\n\\varepsilon_{i,j,r} = \\delta \\cdot (-1)^r \\cdot \\frac{i - j}{P+S}, \\quad \\delta = 0.02,\n$$\n其中 $i \\in \\{0,1,2,3,4\\}$, $j \\in \\{0,1,2,3\\}$, $r \\in \\{0,1\\}$。\n\n情况 B（边界情况：无位点效应）：\n- $P = 4$, $S = 3$, $R = 3$。\n- 真实内在启动子向量\n$$\n\\boldsymbol{\\alpha}^{\\star} = (-0.30, -0.05, 0.10, 0.25), \\quad \\sum_i \\alpha_i^{\\star} = 0.\n$$\n- 真实位点环境向量\n$$\n\\boldsymbol{\\beta}^{\\star} = (0.00, 0.00, 0.00).\n$$\n- 残差：\n$$\n\\varepsilon_{i,j,r} = \\delta \\cdot (-1)^r \\cdot \\frac{i - j}{P+S}, \\quad \\delta = 0.015,\n$$\n其中 $i \\in \\{0,1,2,3\\}$, $j \\in \\{0,1,2\\}$, $r \\in \\{0,1,2\\}$。\n\n情况 C（边缘情况：单次重复，更强的位点变异）：\n- $P = 6$, $S = 5$, $R = 1$。\n- 真实内在启动子向量\n$$\n\\boldsymbol{\\alpha}^{\\star} = (-0.50, -0.20, -0.05, 0.10, 0.25, 0.40), \\quad \\sum_i \\alpha_i^{\\star} = 0.\n$$\n- 真实位点环境向量\n$$\n\\boldsymbol{\\beta}^{\\star} = (-0.40, -0.15, -0.05, 0.20, 0.40), \\quad \\sum_j \\beta_j^{\\star} = 0.\n$$\n- 残差：\n$$\n\\varepsilon_{i,j,0} = \\delta \\cdot \\frac{i - j}{P+S}, \\quad \\delta = 0.03,\n$$\n其中 $i \\in \\{0,1,2,3,4,5\\}$, $j \\in \\{0,1,2,3,4\\}$。\n\n程序要求：\n- 对每种情况，根据上述定义构建所有的 $y_{i,j,r}$。\n- 在和为零的约束下，为 $(\\alpha_i)$ 和 $(\\beta_j)$ 构建并求解约束最小二乘估计问题。\n- 对每种情况，计算启动子估计值和位点估计值的均方根误差（RMSE）：\n$$\n\\operatorname{RMSE}_{\\alpha} = \\sqrt{\\frac{1}{P}\\sum_{i=0}^{P-1} \\left(\\widehat{\\alpha}_i - \\alpha_i^{\\star}\\right)^2}, \\quad\n\\operatorname{RMSE}_{\\beta} = \\sqrt{\\frac{1}{S}\\sum_{j=0}^{S-1} \\left(\\widehat{\\beta}_j - \\beta_j^{\\star}\\right)^2}.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 条目必须按以下顺序排列：\n$$\n[\\operatorname{RMSE}_{\\alpha}^{(A)}, \\operatorname{RMSE}_{\\beta}^{(A)}, \\operatorname{RMSE}_{\\alpha}^{(B)}, \\operatorname{RMSE}_{\\beta}^{(B)}, \\operatorname{RMSE}_{\\alpha}^{(C)}, \\operatorname{RMSE}_{\\beta}^{(C)}].\n$$\n- 每个值必须四舍五入到六位小数，并以不带任何单位的小数十进制数形式打印。", "solution": "该问题要求从模拟的基因表达数据中解卷积出内在启动子强度和基因组环境效应。所提供的模型是定量生物学中的一个标准线性模型，其中测量量的对数是各贡献因素的总和。我将首先验证问题陈述，然后提出一个完整的解析解，该解将通过计算方式实现。\n\n该问题已经过验证，被认为是科学上合理、适定且完整的。它代表了统计遗传学和合成生物学中的一个标准参数估计任务，被表述为一个约束最小二乘优化问题。\n\n对于在位点 $j$ 的启动子 $i$ 在重复实验 $r$ 中测得的对数表达量 $y_{i,j,r}$，其模型由下式给出：\n$$\ny_{i,j,r} = \\alpha_i + \\beta_j + \\varepsilon_{i,j,r}\n$$\n其中 $\\alpha_i$ 是内在启动子强度，$\\beta_j$ 是位点效应，$\\varepsilon_{i,j,r}$ 是一个残差项。给定 $P$ 个启动子，$S$ 个位点，以及每个组合的 $R$ 次重复实验。参数 $(\\alpha_i)_{i=0}^{P-1}$ 和 $(\\beta_j)_{j=0}^{S-1}$ 将通过最小化残差平方和（RSS）来估计：\n$$\n\\text{RSS} = \\sum_{i=0}^{P-1} \\sum_{j=0}^{S-1} \\sum_{r=0}^{R-1} \\left(y_{i,j,r} - \\alpha_i - \\beta_j\\right)^2\n$$\n此估计受可识别性约束的限制，这些约束消除了加性模型中固有的模糊性（例如，给所有 $\\alpha_i$ 加上一个常数，再从所有 $\\beta_j$ 中减去该常数，并不会改变它们的和）。约束条件为：\n$$\n\\sum_{i=0}^{P-1} \\alpha_i = 0, \\qquad \\sum_{j=0}^{S-1} \\beta_j = 0\n$$\n这是一个经典的约束优化问题，可以使用拉格朗日乘数法来解决。拉格朗日函数 $\\mathcal{L}$ 构建如下：\n$$\n\\mathcal{L}(\\boldsymbol{\\alpha}, \\boldsymbol{\\beta}, \\lambda_1, \\lambda_2) = \\sum_{i=0}^{P-1} \\sum_{j=0}^{S-1} \\sum_{r=0}^{R-1} (y_{i,j,r} - \\alpha_i - \\beta_j)^2 - \\lambda_1 \\sum_{i=0}^{P-1} \\alpha_i - \\lambda_2 \\sum_{j=0}^{S-1} \\beta_j\n$$\n为了找到最优参数，我们将 $\\mathcal{L}$ 对每个 $\\alpha_k$ 和 $\\beta_l$ 的偏导数设为零。\n\n对于 $\\alpha_k$：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\alpha_k} = -2 \\sum_{j=0}^{S-1} \\sum_{r=0}^{R-1} (y_{k,j,r} - \\alpha_k - \\beta_j) - \\lambda_1 = 0\n$$\n$$\n\\sum_{j=0}^{S-1} \\sum_{r=0}^{R-1} (y_{k,j,r} - \\alpha_k - \\beta_j) = -\\frac{\\lambda_1}{2}\n$$\n$$\nSR\\alpha_k + R\\sum_{j=0}^{S-1}\\beta_j = \\sum_{j,r}y_{k,j,r} + \\frac{\\lambda_1}{2}\n$$\n使用约束 $\\sum_j \\beta_j = 0$，上式简化为：\n$$\nSR\\alpha_k = y_{k..} + \\frac{\\lambda_1}{2}\n$$\n其中 $y_{k..} = \\sum_{j,r} y_{k,j,r}$。\n\n对于 $\\beta_l$：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\beta_l} = -2 \\sum_{i=0}^{P-1} \\sum_{r=0}^{R-1} (y_{i,l,r} - \\alpha_i - \\beta_l) - \\lambda_2 = 0\n$$\n$$\n PR\\beta_l + R\\sum_{i=0}^{P-1}\\alpha_i = \\sum_{i,r}y_{i,l,r} + \\frac{\\lambda_2}{2}\n$$\n使用约束 $\\sum_i \\alpha_i = 0$，上式简化为：\n$$\nPR\\beta_l = y_{.l.} + \\frac{\\lambda_2}{2}\n$$\n其中 $y_{.l.} = \\sum_{i,r} y_{i,l,r}$。\n\n现在，我们通过再次使用约束来求解拉格朗日乘子 $\\lambda_1$ 和 $\\lambda_2$。将关于 $\\alpha_k$ 的方程对所有 $k$求和：\n$$\nSR\\sum_{k=0}^{P-1}\\alpha_k = \\sum_{k=0}^{P-1} y_{k..} + P\\frac{\\lambda_1}{2}\n$$\n$$\n0 = y_{...} + P\\frac{\\lambda_1}{2} \\implies \\lambda_1 = -\\frac{2y_{...}}{P}\n$$\n其中 $y_{...} = \\sum_{i,j,r} y_{i,j,r}$。\n\n将关于 $\\beta_l$ 的方程对所有 $l$求和：\n$$\nPR\\sum_{l=0}^{S-1}\\beta_l = \\sum_{l=0}^{S-1} y_{.l.} + S\\frac{\\lambda_2}{2}\n$$\n$$\n0 = y_{...} + S\\frac{\\lambda_2}{2} \\implies \\lambda_2 = -\\frac{2y_{...}}{S}\n$$\n将 $\\lambda_1$ 代回到关于 $\\alpha_k$ 的方程中：\n$$\nSR\\hat{\\alpha}_k = y_{k..} - \\frac{y_{...}}{P} \\implies \\hat{\\alpha}_k = \\frac{y_{k..}}{SR} - \\frac{y_{...}}{PSR}\n$$\n令 $\\bar{y}_{k..} = \\frac{y_{k..}}{SR}$ 为启动子 $k$ 的平均表达量，$\\bar{y}_{...} = \\frac{y_{...}}{PSR}$ 为总平均值。$\\alpha_k$ 的估计量为：\n$$\n\\hat{\\alpha}_k = \\bar{y}_{k..} - \\bar{y}_{...}\n$$\n类似地，将 $\\lambda_2$ 代回到关于 $\\beta_l$ 的方程中：\n$$\nPR\\hat{\\beta}_l = y_{.l.} - \\frac{y_{...}}{S} \\implies \\hat{\\beta}_l = \\frac{y_{.l.}}{PR} - \\frac{y_{...}}{PSR}\n$$\n令 $\\bar{y}_{.l.} = \\frac{y_{.l.}}{PR}$ 为位点 $l$ 的平均表达量。$\\beta_l$ 的估计量为：\n$$\n\\hat{\\beta}_l = \\bar{y}_{.l.} - \\bar{y}_{...}\n$$\n这些估计量是带有和为零约束的双因素方差分析（ANOVA）模型中的标准解。它们非常直观：给定启动子的效应是其平均表达量减去总平均表达水平后的校正值。\n\n实现计划如下：\n1. 对每个测试用例，使用提供的真实参数 $\\boldsymbol{\\alpha}^{\\star}$、$\\boldsymbol{\\beta}^{\\star}$ 和指定的确定性残差函数 $\\varepsilon_{i,j,r}$，生成大小为 $(P, S, R)$ 的完整数据张量 $y_{i,j,r}$。\n2. 计算所需的均值：总均值 $\\bar{y}_{...}$、各启动子的均值 $\\bar{y}_{i..}$ 和各位点的均值 $\\bar{y}_{.j.}$。\n3. 应用推导出的公式计算估计参数 $\\widehat{\\boldsymbol{\\alpha}}$ 和 $\\widehat{\\boldsymbol{\\beta}}$。\n4. 针对启动子和位点估计值，计算其与真实值之间的均方根误差（RMSE）：\n$$\n\\operatorname{RMSE}_{\\alpha} = \\sqrt{\\frac{1}{P}\\sum_{i=0}^{P-1} \\left(\\widehat{\\alpha}_i - \\alpha_i^{\\star}\\right)^2}\n$$\n$$\n\\operatorname{RMSE}_{\\beta} = \\sqrt{\\frac{1}{S}\\sum_{j=0}^{S-1} \\left(\\widehat{\\beta}_j - \\beta_j^{\\star}\\right)^2}\n$$\n5. 将所有测试用例的结果整合到指定的输出格式中。这是一个完全基于上述解析解的计算过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General, balanced\n        {\n            \"name\": \"A\",\n            \"P\": 5, \"S\": 4, \"R\": 2,\n            \"alpha_star\": np.array([-0.40, -0.10, 0.00, 0.20, 0.30]),\n            \"beta_star\": np.array([-0.30, -0.10, 0.15, 0.25]),\n            \"delta\": 0.02,\n            \"residual_func\": lambda i, j, r, P, S, delta: delta * ((-1) ** r) * (i - j) / (P + S),\n        },\n        # Case B: Boundary, no site effect\n        {\n            \"name\": \"B\",\n            \"P\": 4, \"S\": 3, \"R\": 3,\n            \"alpha_star\": np.array([-0.30, -0.05, 0.10, 0.25]),\n            \"beta_star\": np.array([0.00, 0.00, 0.00]),\n            \"delta\": 0.015,\n            \"residual_func\": lambda i, j, r, P, S, delta: delta * ((-1) ** r) * (i - j) / (P + S),\n        },\n        # Case C: Edge, single replicate\n        {\n            \"name\": \"C\",\n            \"P\": 6, \"S\": 5, \"R\": 1,\n            \"alpha_star\": np.array([-0.50, -0.20, -0.05, 0.10, 0.25, 0.40]),\n            \"beta_star\": np.array([-0.40, -0.15, -0.05, 0.20, 0.40]),\n            \"delta\": 0.03,\n            \"residual_func\": lambda i, j, r, P, S, delta: delta * (i - j) / (P + S),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        rmse_alpha, rmse_beta = estimate_and_evaluate(case)\n        results.extend([rmse_alpha, rmse_beta])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef estimate_and_evaluate(params):\n    \"\"\"\n    Generates data, estimates parameters, and computes RMSE for a single case.\n    \"\"\"\n    P = params[\"P\"]\n    S = params[\"S\"]\n    R = params[\"R\"]\n    alpha_star = params[\"alpha_star\"]\n    beta_star = params[\"beta_star\"]\n    delta = params[\"delta\"]\n    residual_func = params[\"residual_func\"]\n\n    # 1. Construct the data tensor y_ijr\n    y_data = np.zeros((P, S, R))\n    for i in range(P):\n        for j in range(S):\n            for r in range(R):\n                residual = residual_func(i, j, r, P, S, delta)\n                y_data[i, j, r] = alpha_star[i] + beta_star[j] + residual\n\n    # 2. Compute the means\n    # Grand mean\n    y_grand_mean = np.mean(y_data)\n    # Mean per promoter (averaging over sites and replicates)\n    y_promoter_means = np.mean(y_data, axis=(1, 2))\n    # Mean per site (averaging over promoters and replicates)\n    y_site_means = np.mean(y_data, axis=(0, 2))\n\n    # 3. Apply the derived estimators\n    alpha_hat = y_promoter_means - y_grand_mean\n    beta_hat = y_site_means - y_grand_mean\n\n    # 4. Compute the Root Mean Squared Error (RMSE)\n    rmse_alpha = np.sqrt(np.mean((alpha_hat - alpha_star) ** 2))\n    rmse_beta = np.sqrt(np.mean((beta_hat - beta_star) ** 2))\n    \n    return rmse_alpha, rmse_beta\n\nsolve()\n```", "id": "2764696"}]}