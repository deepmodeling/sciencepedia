{"hands_on_practices": [{"introduction": "在微生物定向进化实验中，我们通常在恒化器或浊度仪等连续培养系统中测量生长速率。然而，经典的群体遗传学模型通常基于离散的世代进行构建。本练习旨在建立这两种框架之间的关键联系，通过推导将连续时间的马尔萨斯参数（$m$）转换成离散世代的选择系数（$s$），从而能够利用实验室数据来定量预测等位基因频率的演变 [@problem_id:2761924]。", "problem": "在一个恒浊器实验中，一种经过改造以携带一个替代性启动子等位基因的大量无性单倍体微生物有两种基因型在竞争：参考基因型 $a$ 和修饰基因型 $A$。在恒定环境条件下，且单代内的频率依赖效应可忽略不计，假设每种基因型 $i \\in \\{A,a\\}$ 在短时间间隔内都遵循与密度无关的指数增长，其丰度 $N_{i}(t)$ 满足常微分方程 $dN_{i}/dt = m_{i} N_{i}$，其中 $m_{i}$ 是马尔萨斯参数（单位时间的对数增长率）。在持续时间为 $\\tau$ 的离散不重叠的世代中，绝对适应度 $W_{i}$ 通过 $N_{i}(g+1) = W_{i} N_{i}(g)$ 定义。在单代内的群体遗传学计算中，如果只考虑生存力选择（无突变、迁移或漂变），且 $p$ 表示一代开始时基因型 $A$ 的频率，那么下一代的频率由 $p' = \\dfrac{p W_{A}}{p W_{A} + (1-p) W_{a}}$ 给出。\n\n你测量到两种基因型之间存在恒定的增长率差异 $\\Delta m = m_{A} - m_{a}$，其值为 $\\Delta m = 0.05 \\,\\mathrm{h}^{-1}$，代际时间为 $\\tau = 1.5 \\,\\mathrm{h}$。基因型 $A$ 的初始频率为 $p = 0.2$。请从上述定义出发，推导连接 $m_{i}$ 与 $W_{i}$ 的关系，然后用 $\\Delta m$ 和 $\\tau$ 表示离散世代选择系数 $s$（由 $W_{A} = (1+s) W_{a}$ 定义）。使用此关系，计算工程改造的等位基因 $A$ 的预期单代等位基因频率变化 $\\Delta p = p' - p$。\n\n将 $\\Delta p$ 的最终数值答案表示为无单位的小数，并四舍五入至四位有效数字。", "solution": "该问题要求基于连续时间指数增长模型和离散时间群体遗传学定义，推导单代等位基因频率的变化量 $\\Delta p$。第一步是验证问题陈述的有效性。\n\n该问题在科学上是合理的，提法明确且客观。它提供了微生物群体遗传学中的一个标准场景，在该场景中，两种群体增长模型（一种是连续时间的，另一种是离散世代的）必须得到协调。所有必要的定义和参数均已提供，包括马尔萨斯增长的微分方程 $dN_{i}/dt = m_{i} N_{i}$；离散世代框架下绝对适应度 $W_{i}$ 的定义 $N_{i}(g+1) = W_{i} N_{i}(g)$；选择作用下频率变化的公式 $p' = \\frac{p W_{A}}{p W_{A} + (1-p) W_{a}}$；通过 $W_{A} = (1+s) W_{a}$ 定义的选择系数 $s$；以及所有必需的参数值：$\\Delta m = m_{A} - m_{a} = 0.05 \\,\\mathrm{h}^{-1}$，代际时间 $\\tau = 1.5 \\,\\mathrm{h}$，初始频率 $p = 0.2$。该问题是自洽的、一致的，并且需要一个标准的、非平凡的推导。因此，该问题有效，将提供解答。\n\n第一个任务是建立马尔萨斯参数 $m_{i}$ 和绝对适应度 $W_{i}$ 之间的关系。基因型 $i$ 在时间间隔 $t$ 内的连续增长由常微分方程 $dN_{i}/dt = m_{i} N_{i}$ 的解来描述。分离变量并积分得到 $\\int_{N_{i}(0)}^{N_{i}(t)} \\frac{dN_{i}}{N_{i}} = \\int_{0}^{t} m_{i} dt'$，从而得出 $\\ln(N_{i}(t)) - \\ln(N_{i}(0)) = m_{i} t$，即 $N_{i}(t) = N_{i}(0) \\exp(m_{i} t)$。\n在持续时间为 $\\tau$ 的单代内，种群大小从该代开始时的 $N_{i}(g)$ 变为结束时的 $N_{i}(g+1)$。在连续时间框架中，这等价于时间 $\\tau$ 相对于时间 $0$ 的种群大小。因此，我们有 $N_{i}(g+1) = N_{i}(g) \\exp(m_{i} \\tau)$。\n问题通过离散世代方程 $N_{i}(g+1) = W_{i} N_{i}(g)$ 来定义绝对适应度 $W_{i}$。通过比较 $N_{i}(g+1)$ 的这两个表达式，我们得出基本关系式：\n$$W_{i} = \\exp(m_{i} \\tau)$$\n\n接下来，我们必须用增长率差异 $\\Delta m$ 和代际时间 $\\tau$ 来表示选择系数 $s$。选择系数由 $W_{A} = (1+s) W_{a}$ 定义。由此，我们可以写出 $1+s = \\frac{W_{A}}{W_{a}}$。\n将关系式 $W_{i} = \\exp(m_{i} \\tau)$ 代入每个基因型：\n$$1+s = \\frac{\\exp(m_{A} \\tau)}{\\exp(m_{a} \\tau)} = \\exp(m_{A} \\tau - m_{a} \\tau) = \\exp((m_{A}-m_{a})\\tau)$$\n已知 $\\Delta m = m_{A} - m_{a}$，上式简化为：\n$$1+s = \\exp(\\Delta m \\tau)$$\n因此，选择系数 $s$ 由下式给出：\n$$s = \\exp(\\Delta m \\tau) - 1$$\n\n最后一步是推导单代等位基因频率变化 $\\Delta p = p' - p$ 的表达式。下一代等位基因 $A$ 的频率 $p'$ 由 $p' = \\frac{p W_{A}}{p W_{A} + (1-p) W_{a}}$ 给出。为了简化此表达式，我们可以将分子和分母同除以 $W_{a}$：\n$$p' = \\frac{p (W_{A}/W_{a})}{p (W_{A}/W_{a}) + (1-p)}$$\n使用定义式 $W_{A}/W_{a} = 1+s$，我们得到：\n$$p' = \\frac{p(1+s)}{p(1+s) + (1-p)} = \\frac{p(1+s)}{p+ps+1-p} = \\frac{p(1+s)}{1+ps}$$\n现在我们计算 $\\Delta p = p' - p$：\n$$\\Delta p = \\frac{p(1+s)}{1+ps} - p = \\frac{p(1+s) - p(1+ps)}{1+ps} = \\frac{p+ps - p - p^2s}{1+ps} = \\frac{ps - p^2s}{1+ps}$$\n对分子进行因式分解，得到选择作用下等位基因频率变化的标准形式：\n$$\\Delta p = \\frac{ps(1-p)}{1+ps}$$\n\n我们现在有了计算 $\\Delta p$ 数值所需的所有公式。给定值为 $\\Delta m = 0.05 \\,\\mathrm{h}^{-1}$，$\\tau = 1.5 \\,\\mathrm{h}$ 和 $p = 0.2$。\n首先，我们计算选择系数 $s$：\n$$s = \\exp(\\Delta m \\tau) - 1 = \\exp(0.05 \\times 1.5) - 1 = \\exp(0.075) - 1$$\n现在，将 $p$ 和 $s$ 的值代入 $\\Delta p$ 的表达式中：\n$$\\Delta p = \\frac{(0.2)s(1-0.2)}{1+(0.2)s} = \\frac{(0.2)(0.8)s}{1+0.2s} = \\frac{0.16s}{1+0.2s}$$\n代入 $s$ 的表达式：\n$$\\Delta p = \\frac{0.16 (\\exp(0.075) - 1)}{1 + 0.2 (\\exp(0.075) - 1)}$$\n对表达式进行数值计算：\n$s = \\exp(0.075) - 1 \\approx 1.0778841 - 1 = 0.0778841$\n$$\\Delta p \\approx \\frac{0.16 \\times 0.0778841}{1 + 0.2 \\times 0.0778841} = \\frac{0.01246146}{1 + 0.01557682} = \\frac{0.01246146}{1.01557682} \\approx 0.01227041$$\n按要求将结果四舍五入至四位有效数字，得到 $0.01227$。", "answer": "$$\\boxed{0.01227}$$", "id": "2761924"}, {"introduction": "在实验室进化实验中，种群大小很少保持恒定，尤其是在涉及稀释和传代的方案中，种群瓶颈是常见现象。本练习将引导你推导在种群大小随时间波动时有效种群大小（$N_e$）的计算方法。你将发现，有效种群大小由各世代种群大小的调和平均数决定，这意味着种群瓶颈对遗传漂变的强度有着不成比例的巨大影响，这是任何进行定向进化研究的合成生物学家都必须掌握的核心概念 [@problem_id:2761883]。", "problem": "一个合成生物学实验室正在对一种单倍体工程细菌进行定向进化实验。该种群在一个充分混合的环境中繁殖了 $T$ 个不重叠的世代，其标记基因座与编辑构建体连锁，并表现出中性动态。由于实验传代和刻意的文库筛选，普查规模 $N_t$ 在各代之间有所不同。假设：\n- 单倍体无性繁殖，\n- 每代随机抽取 $N_t$ 个基因组（无选择、突变或迁移），\n- 该标记是选择中性的，追踪它仅为量化随机漂变，\n- 该过程遵循具有可变普查规模的 Wright-Fisher 型模型的经典随机抽样逻辑。\n\n从每代等位基因拷贝都是从当前基因库中随机抽样，以及方差通过全方差定律随世代累积这些基本事实出发，从第一性原理推导出一个恒定有效种群大小 $N_e$ 的表达式。在 $T$ 个世代内，该有效种群大小产生的等位基因频率累积中性漂变与观测到的可变规模过程相同。\n\n然后，将您的结果应用于以下经过瓶颈的 $T = 10$ 个世代的传代方案：\n$$\n\\{N_t\\}_{t=1}^{10} = \\{2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 500,\\, 500,\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8}\\}.\n$$\n根据您的推导，计算此方案所隐含的 $N_e$。将您的最终数值答案表示为一个纯数（无单位），并四舍五入到 $4$ 位有效数字。", "solution": "该问题陈述具有科学依据，提法恰当且客观。它描述了群体遗传学中的一个经典情景——种群规模波动对遗传漂变的影响，并将其置于一个合理的合成生物学背景中。该模型是一个标准的不重叠世代的 Wright-Fisher 过程，任务是推导有效种群大小 $N_e$，这是一个量化漂变幅度的基本概念。所有假设和数据都已提供，内部一致，并允许得到一个唯一且有意义的解。因此，该问题是有效的。\n\n我们从第一性原理开始推导。\n\n该过程被建模为一个单倍体种群的 Wright-Fisher 模型，其普查规模 $N_t$ 在每一代 $t$ 都会变化。设 $p_t$ 为第 $t$ 代一个选择中性标记等位基因的频率。第 $t+1$ 代的种群是通过从第 $t$ 代种群中随机抽取 $N_{t+1}$ 个个体（或基因组）形成的。这是一个二项抽样过程。\n\n随机遗传漂变的累积效应通过等位基因频率方差的变化来衡量，这与预期杂合度随时间的衰减直接相关。对于单倍体种群，我们可以使用一个类似的量 $H_t^{\\text{exp}} = E[p_t(1 - p_t)]$，它代表在第 $t$ 代种群中基因多样性的期望。\n\n让我们推导 $H_t^{\\text{exp}}$ 的递推关系。给定第 $t$ 代的等位基因频率 $p_t$，第 $t+1$ 代的频率 $p_{t+1}$ 是一个随机变量。由于没有选择或突变，$p_{t+1}$ 的条件期望为 $E[p_{t+1} | p_t] = p_t$。\n\n$p_{t+1}$ 的条件方差源于对 $N_{t+1}$ 个个体的二项抽样，由下式给出：\n$$\n\\text{Var}(p_{t+1} | p_t) = \\frac{p_t(1 - p_t)}{N_{t+1}}\n$$\n我们可以使用期望值法则（law of the unconscious statistician）和关系式 $\\text{Var}(X) = E[X^2] - (E[X])^2$ 来求出 $p_{t+1}(1 - p_{t+1})$ 的条件期望：\n$$\nE[p_{t+1}^2 | p_t] = \\text{Var}(p_{t+1} | p_t) + (E[p_{t+1} | p_t])^2 = \\frac{p_t(1 - p_t)}{N_{t+1}} + p_t^2\n$$\n因此：\n$$\nE[p_{t+1}(1 - p_{t+1}) | p_t] = E[p_{t+1} | p_t] - E[p_{t+1}^2 | p_t] = p_t - \\left(\\frac{p_t(1 - p_t)}{N_{t+1}} + p_t^2\\right)\n$$\n简化此表达式，我们得到：\n$$\nE[p_{t+1}(1 - p_{t+1}) | p_t] = p_t(1 - p_t) - \\frac{p_t(1 - p_t)}{N_{t+1}} = p_t(1 - p_t)\\left(1 - \\frac{1}{N_{t+1}}\\right)\n$$\n根据全期望定律，$E[X] = E[E[X|Y]]$，我们可以对 $p_t$ 的分布取期望：\n$$\nE[p_{t+1}(1 - p_{t+1})] = E[p_t(1 - p_t)] \\left(1 - \\frac{1}{N_{t+1}}\\right)\n$$\n这就给出了 $H_{t+1}^{\\text{exp}}$ 的递推关系：\n$$\nH_{t+1}^{\\text{exp}} = H_t^{\\text{exp}} \\left(1 - \\frac{1}{N_{t+1}}\\right)\n$$\n将此关系从第 $0$ 代迭代到第 $T$ 代：\n$$\nH_T^{\\text{exp}} = H_0^{\\text{exp}} \\prod_{t=1}^{T} \\left(1 - \\frac{1}{N_t}\\right)\n$$\n现在，我们将有效种群大小 $N_e$ 定义为一个大小恒定的假想种群的大小，该种群在 $T$ 个世代内会经历与实际情况相同的累积漂变量。对于这样一个种群，预期杂合度的衰减将是：\n$$\nH_T^{\\text{exp}} = H_0^{\\text{exp}} \\left(1 - \\frac{1}{N_e}\\right)^T\n$$\n将可变规模过程和恒定规模过程的表达式相等，得到：\n$$\n\\prod_{t=1}^{T} \\left(1 - \\frac{1}{N_t}\\right) = \\left(1 - \\frac{1}{N_e}\\right)^T\n$$\n这是该近交有效种群大小的精确定义。为了得到一个更易于处理的表达式，我们假设 $N_t$ 通常很大，使得 $1/N_t \\ll 1$。在这种情况下，对于小的 $x$，近似式 $\\ln(1 - x) \\approx -x$ 是有效的。对两边取自然对数：\n$$\n\\sum_{t=1}^{T} \\ln\\left(1 - \\frac{1}{N_t}\\right) = T \\ln\\left(1 - \\frac{1}{N_e}\\right)\n$$\n应用该近似，得到：\n$$\n\\sum_{t=1}^{T} \\left(-\\frac{1}{N_t}\\right) \\approx T \\left(-\\frac{1}{N_e}\\right)\n$$\n这可以简化为：\n$$\n\\frac{T}{N_e} = \\sum_{t=1}^{T} \\frac{1}{N_t}\n$$\n求解 $N_e$，我们得到有效种群大小的表达式，即普查规模在时间段内的调和平均数：\n$$\nN_e = \\frac{T}{\\sum_{t=1}^{T} \\frac{1}{N_t}}\n$$\n这就是从第一性原理推导出的所需表达式。\n\n现在我们将此结果应用于给定的 $T = 10$ 个世代的传代方案。普查规模序列为：\n$$\n\\{N_t\\}_{t=1}^{10} = \\{2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 500,\\, 500,\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8},\\, 2.0 \\times 10^{8}\\}\n$$\n该序列包含 $8$ 个 $N_t = 2.0 \\times 10^8$ 的世代和 $2$ 个 $N_t = 500$ 的世代。我们计算普查规模倒数之和：\n$$\n\\sum_{t=1}^{10} \\frac{1}{N_t} = 8 \\times \\left(\\frac{1}{2.0 \\times 10^8}\\right) + 2 \\times \\left(\\frac{1}{500}\\right)\n$$\n$$\n\\sum_{t=1}^{10} \\frac{1}{N_t} = \\frac{8}{2.0 \\times 10^8} + \\frac{2}{500} = 4.0 \\times 10^{-8} + 0.004\n$$\n$$\n\\sum_{t=1}^{10} \\frac{1}{N_t} = 0.00400004\n$$\n现在，我们计算 $N_e$：\n$$\nN_e = \\frac{10}{0.00400004} \\approx 2499.975\n$$\n将此结果四舍五入到 $4$ 位有效数字，我们得到 $2500$。这个结果表明，有效种群大小受到最小种群规模（瓶颈）不成比例的影响。", "answer": "$$\n\\boxed{2500}\n$$", "id": "2761883"}, {"introduction": "合成生物学使我们能够构建和筛选大规模的基因变体文库，并测量它们的适应度，从而获得丰富的基因型-表型数据。本练习将带你进入适应度景观的定量建模世界，这是一个核心的计算实践。你将学习如何通过对实验数据拟合一个包含加性效应和成对上位性效应的线性模型，来量化不同位点突变之间的相互作用，并预测未见基因型的适应度 [@problem_id:2761900]。", "problem": "给定来自一个合成启动子文库的基因型-适应度数据，其中基因型被编码为二进制向量，适应度以实数值衡量。假设基因型-适应度图谱可以由一个加性加成对上位性模型很好地近似，其形式为\n$$\nw(\\mathbf{x}) \\;=\\; \\beta_0 \\;+\\; \\sum_{i=1}^{L} \\beta_i x_i \\;+\\; \\sum_{1 \\le i  j \\le L} \\beta_{ij} x_i x_j,\n$$\n其中，$L$ 是位点数，$\\mathbf{x} \\in \\{0,1\\}^L$ 编码一个基因型，在每个位点上使用 $0$ 表示参考等位基因，使用 $1$ 表示替代等位基因，$w(\\mathbf{x})$ 是适应度，$\\beta_0$ 是截距，$\\beta_i$ 是加性效应，$\\beta_{ij}$ 是成对上位性效应。您的任务是实现一个程序，对于每个给定的数据集，使用特征 $[1, x_1, \\dots, x_L, x_1 x_2, x_1 x_3, \\dots, x_{L-1} x_L]$ 构建适当的线性设计矩阵，通过普通最小二乘法拟合模型，通过留一法交叉验证（LOOCV）量化泛化误差，并预测指定未见基因型的适应度。\n\n使用的基本依据和假设：\n- 基因型-表型映射在这些特征上是线性建模的，这与数量遗传学中关于加性贡献和上位性贡献的标准定义一致。\n- 通过最小化残差平方和（普通最小二乘法）来拟合系数，这将得到使 $\\sum_{n=1}^{N} \\left(w^{(n)} - \\hat{w}^{(n)}\\right)^2$ 最小化的系数向量，其中 $N$ 是观测到的基因型数量。\n- 使用 Moore–Penrose 伪逆或等效的数值稳定的普通最小二乘法求解器来处理超定和欠定情况。\n- 通过留一法交叉验证（LOOCV）量化预测性能，其定义为：每次留出一个样本，用其余样本进行训练，然后对留出的样本进行预测，所得到的预测误差平方的平均值。具体来说，LOOCV 均方误差（LOOCV-MSE）为\n$$\n\\mathrm{LOOCV\\text{-}MSE} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} \\left( w^{(n)} - \\hat{w}_{-n}^{(n)} \\right)^2,\n$$\n其中 $\\hat{w}_{-n}^{(n)}$ 是使用除样本 $n$ 之外的所有样本拟合的模型对样本 $n$ 的预测值。\n- 计算 LOOCV-MSE 后，在完整的训练集上重新拟合模型，然后为指定的未见基因型预测适应度。\n\n您的程序必须为以下测试套件实现上述过程。在每种情况下，基因型都以长度为 $L$ 的二进制向量给出，适应度值为实数。您必须：\n- 按列顺序 $[1, x_1, \\dots, x_L, x_1 x_2, x_1 x_3, \\dots, x_{L-1} x_L]$ 构建设计矩阵。\n- 对每个训练折和最终的全数据拟合使用普通最小二乘法进行拟合。\n- 计算所有训练样本的 LOOCV-MSE。\n- 为提供的未见基因型预测适应度。\n- 将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例 A：\n  - $L = 4$\n  - 训练基因型 $\\mathbf{x}^{(n)}$ 和适应度 $w^{(n)}$：\n    - $[0,0,0,0] \\to 1.0$\n    - $[0,0,0,1] \\to 1.1$\n    - $[0,0,1,0] \\to 1.2$\n    - $[0,0,1,1] \\to 1.55$\n    - $[0,1,0,0] \\to 0.7$\n    - $[0,1,0,1] \\to 0.7$\n    - $[0,1,1,0] \\to 1.2$\n    - $[1,0,0,0] \\to 1.5$\n    - $[1,0,0,1] \\to 1.6$\n    - $[1,0,1,0] \\to 1.5$\n    - $[1,1,0,0] \\to 1.6$\n    - $[1,1,1,1] \\to 2.15$\n    - $[1,1,1,0] \\to 1.9$\n  - 待预测的未见基因型： $[0,1,1,1]$ 和 $[1,0,1,1]$。\n- 案例 B：\n  - $L = 3$\n  - 训练基因型 $\\mathbf{x}^{(n)}$ 和适应度 $w^{(n)}$：\n    - $[0,0,0] \\to 0.8$\n    - $[0,0,1] \\to 1.1$\n    - $[0,1,0] \\to 0.7$\n    - $[0,1,1] \\to 1.2$\n    - $[1,0,0] \\to 1.0$\n    - $[1,0,1] \\to 0.9$\n    - $[1,1,0] \\to 1.4$\n  - 待预测的未见基因型： $[1,1,1]$。\n- 案例 C：\n  - $L = 5$\n  - 训练基因型 $\\mathbf{x}^{(n)}$ 和适应度 $w^{(n)}$：\n    - $[0,0,0,0,0] \\to 2.0$\n    - $[0,0,0,0,1] \\to 2.15$\n    - $[0,0,0,1,0] \\to 2.0$\n    - $[0,0,0,1,1] \\to 2.15$\n    - $[0,0,1,0,0] \\to 2.05$\n    - $[0,0,1,0,1] \\to 2.20$\n    - $[0,0,1,1,0] \\to 2.05$\n    - $[0,1,0,0,0] \\to 1.8$\n    - $[0,1,0,0,1] \\to 1.95$\n    - $[0,1,0,1,0] \\to 1.8$\n    - $[0,1,1,0,0] \\to 1.85$\n    - $[0,1,1,1,0] \\to 1.85$\n    - $[1,0,0,0,0] \\to 2.1$\n    - $[1,0,0,0,1] \\to 2.25$\n    - $[1,0,0,1,0] \\to 2.1$\n    - $[1,0,1,0,0] \\to 2.15$\n    - $[1,1,0,0,0] \\to 1.9$\n    - $[1,1,1,1,1] \\to 2.1$\n  - 待预测的未见基因型： $[1,0,1,0,1]$ 和 $[0,1,1,0,1]$。\n\n实现细节和输出：\n- 在每个折和最终拟合中使用普通最小二乘法拟合 $\\boldsymbol{\\beta}$。\n- 使用留一法交叉验证（LOOCV）为每个案例计算一个 LOOCV-MSE。\n- 计算 LOOCV-MSE 后，在完整训练集上进行拟合，并按给定顺序为列出的未见基因型生成预测。\n- 程序必须生成单行输出，其中包含结果，格式为一个包含三个方括号列表的逗号分隔列表，每个案例一个。每个案例列表必须包含 LOOCV-MSE，后跟未见基因型的预测值，所有数值均四舍五入到 $6$ 位小数。例如，最终格式必须是：\n\"[caseA_list,caseB_list,caseC_list]\"。", "solution": "我们使用一个加性加成对上位性线性模型来建模基因型-适应度关系。该方法的基本依据源于数量遗传学和进化论：可归因于等位基因的适应度差异可以分解为加性贡献和相互作用项（上位性），这与遗传方差的标准分解一致。在合成生物学背景下，跨启动子位置或基序的二进制基因型提供了输入变量，而观测到的适应度是一个可测量的表型。\n\n1. 模型和设计矩阵。对于一个基因型 $\\mathbf{x} = [x_1,\\dots,x_L] \\in \\{0,1\\}^L$，我们定义线性预测器\n$$\n\\hat{w}(\\mathbf{x}) \\;=\\; \\beta_0 \\;+\\; \\sum_{i=1}^{L} \\beta_i x_i \\;+\\; \\sum_{1 \\le i  j \\le L} \\beta_{ij} x_i x_j.\n$$\n对于 $N$ 个观测值，将响应收集在 $\\mathbf{y} \\in \\mathbb{R}^N$ 中，并构建一个设计矩阵 $\\mathbf{X} \\in \\mathbb{R}^{N \\times P}$，其中 $P = 1 + L + \\frac{L(L-1)}{2}$，其列的固定顺序为 $[1, x_1, \\dots, x_L, x_1 x_2, x_1 x_3, \\dots, x_{L-1} x_L]$。$\\mathbf{X}$ 的每一行对应一个观测到的基因型。\n\n2. 最小二乘拟合。普通最小二乘（OLS）估计 $\\hat{\\boldsymbol{\\beta}}$ 最小化残差平方和\n$$\nS(\\boldsymbol{\\beta}) \\;=\\; \\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}\\|_2^2 \\;=\\; \\sum_{n=1}^{N}\\left(y^{(n)} - \\mathbf{x}^{(n)\\top}\\boldsymbol{\\beta}\\right)^2.\n$$\n一阶最优性条件给出了正规方程 $\\mathbf{X}^\\top \\mathbf{X} \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^\\top \\mathbf{y}$。当 $\\mathbf{X}^\\top \\mathbf{X}$ 可逆时，$\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1}\\mathbf{X}^\\top \\mathbf{y}$。在一般情况下（包括欠定或秩亏情况），我们可以使用 Moore–Penrose 伪逆来获得最小范数解\n$$\n\\hat{\\boldsymbol{\\beta}} \\;=\\; \\mathbf{X}^+ \\mathbf{y},\n$$\n在超定满秩情况下，该解与 OLS 解一致，并在其他情况下提供了一致的选择。在数值上，这是通过用于最小二乘的稳定线性代数例程来实现的。\n\n3. 留一法交叉验证（LOOCV）。为了在不重复使用留出数据的情况下估计泛化误差，我们执行 LOOCV：\n- 对于每个 $n \\in \\{1,\\dots,N\\}$，通过移除第 $n$ 个样本来构造 $\\mathbf{X}_{-n}$ 和 $\\mathbf{y}_{-n}$。\n- 在 $(\\mathbf{X}_{-n}, \\mathbf{y}_{-n})$ 上通过 OLS 拟合 $\\hat{\\boldsymbol{\\beta}}_{-n}$。\n- 使用 $\\hat{w}_{-n}^{(n)} = \\mathbf{x}^{(n)\\top} \\hat{\\boldsymbol{\\beta}}_{-n}$ 预测留出的样本。\n- 累加平方误差 $\\left(y^{(n)} - \\hat{w}_{-n}^{(n)}\\right)^2$。\n然后，LOOCV 均方误差为\n$$\n\\mathrm{LOOCV\\text{-}MSE} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} \\left( y^{(n)} - \\hat{w}_{-n}^{(n)} \\right)^2.\n$$\n如果真实数据完全由假设模型生成，并且每个训练折都能产生唯一的 OLS 解以恢复真实参数，那么 LOOCV 误差将为 $0$。在欠定折中，伪逆提供了拟合训练样本的最小范数解，但如果解不是由训练子集唯一确定的，那么对留出点的预测可能会偏离真实值。\n\n4. 最终拟合和对未见基因型的预测。计算 LOOCV-MSE 后，我们在完整数据集上重新拟合以获得 $\\hat{\\boldsymbol{\\beta}}$，然后使用 $\\hat{w}(\\mathbf{x}^{\\mathrm{(unseen)}}) = \\mathbf{x}^{\\mathrm{(unseen)}\\top} \\hat{\\boldsymbol{\\beta}}$ 并采用相同的特征顺序，为每个提供的未见基因型 $\\mathbf{x}^{\\mathrm{(unseen)}}$ 进行预测。这利用了所有训练信息，并在模型下产生我们的最佳点估计。\n\n5. 每个案例的算法步骤：\n- 解析 $L$、训练基因型列表 $\\{\\mathbf{x}^{(n)}\\}_{n=1}^{N}$ 和 $\\mathbf{y}$。\n- 按指定的列顺序构建 $\\mathbf{X}$。\n- 通过在 $\\mathbf{X}_{-n}$、$\\mathbf{y}_{-n}$ 上重复求解最小二乘并预测留出的样本来执行 LOOCV，然后计算 LOOCV-MSE。\n- 在完整的 $\\mathbf{X}$、$\\mathbf{y}$ 上进行拟合以得到 $\\hat{\\boldsymbol{\\beta}}$，并为未见基因型进行预测。\n- 将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n6. 输出。对于每个案例，输出一个列表，其第一个条目是 LOOCV-MSE，后续条目是按所提供顺序排列的未见基因型的预测值。将三个案例列表聚合成一个列表的列表，并以 `\"[caseA_list,caseB_list,caseC_list]\"` 的格式在一行中打印。所有浮点数必须四舍五入到 $6$ 位小数。不涉及物理单位，也不涉及角度。所有比例（如有）必须表示为小数，而不是百分比。\n\n这种方法通过量化加性贡献和成对上位性贡献对适应度的影响，通过最小二乘法从数据中估计这些贡献，并利用交叉验证评估预测性能以防止过拟合，同时利用假设的模型结构，将进化和自然选择的原理应用于合成生物学数据。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef build_design_matrix(X_bin):\n    \"\"\"\n    Build the design matrix with columns:\n    [1, x1, ..., xL, x1*x2, x1*x3, ..., x_{L-1}*xL]\n    X_bin: array of shape (N, L) with binary entries 0/1.\n    Returns: array of shape (N, P).\n    \"\"\"\n    N, L = X_bin.shape\n    cols = [np.ones((N, 1))]\n    cols.append(X_bin.astype(float))\n    if L > 1:\n        interaction_terms = []\n        for i, j in itertools.combinations(range(L), 2):\n            interaction_terms.append((X_bin[:, i] * X_bin[:, j]).reshape(-1, 1))\n        if interaction_terms:\n            cols.append(np.hstack(interaction_terms))\n    return np.hstack(cols)\n\ndef solve_case(L, training_data, unseen_genotypes):\n    \"\"\"\n    Solves one case: performs LOOCV and final prediction.\n    \"\"\"\n    N = len(training_data)\n    train_X_bin = np.array([g for g, f in training_data])\n    train_y = np.array([f for g, f in training_data])\n\n    # LOOCV\n    errors_sq = []\n    for i in range(N):\n        X_loo_bin = np.delete(train_X_bin, i, axis=0)\n        y_loo = np.delete(train_y, i)\n        \n        x_held_out_bin = train_X_bin[i:i+1, :]\n        y_held_out = train_y[i]\n\n        X_design_loo = build_design_matrix(X_loo_bin)\n        x_design_held_out = build_design_matrix(x_held_out_bin)\n\n        beta_loo = np.linalg.lstsq(X_design_loo, y_loo, rcond=None)[0]\n        \n        y_pred = x_design_held_out @ beta_loo\n        errors_sq.append((y_held_out - y_pred[0])**2)\n    \n    loocv_mse = np.mean(errors_sq)\n\n    # Final fit on all data\n    X_design_full = build_design_matrix(train_X_bin)\n    beta_full = np.linalg.lstsq(X_design_full, train_y, rcond=None)[0]\n\n    # Predict on unseen genotypes\n    unseen_X_bin = np.array(unseen_genotypes)\n    unseen_X_design = build_design_matrix(unseen_X_bin)\n    predictions = unseen_X_design @ beta_full\n\n    return [round(loocv_mse, 6)] + [round(p, 6) for p in predictions]\n\ndef main_logic():\n    \"\"\"\n    Main logic to solve all cases and produce the final output string.\n    This function is for encapsulation and is not called directly by the execution environment.\n    \"\"\"\n    # Case A\n    L_A = 4\n    data_A = [\n        ([0,0,0,0], 1.0), ([0,0,0,1], 1.1), ([0,0,1,0], 1.2), ([0,0,1,1], 1.55),\n        ([0,1,0,0], 0.7), ([0,1,0,1], 0.7), ([0,1,1,0], 1.2), ([1,0,0,0], 1.5),\n        ([1,0,0,1], 1.6), ([1,0,1,0], 1.5), ([1,1,0,0], 1.6), ([1,1,1,1], 2.15),\n        ([1,1,1,0], 1.9)\n    ]\n    unseen_A = [[0,1,1,1], [1,0,1,1]]\n    result_A = solve_case(L_A, data_A, unseen_A)\n\n    # Case B\n    L_B = 3\n    data_B = [\n        ([0,0,0], 0.8), ([0,0,1], 1.1), ([0,1,0], 0.7),\n        ([0,1,1], 1.2), ([1,0,0], 1.0), ([1,0,1], 0.9), ([1,1,0], 1.4)\n    ]\n    unseen_B = [[1,1,1]]\n    result_B = solve_case(L_B, data_B, unseen_B)\n\n    # Case C\n    L_C = 5\n    data_C = [\n        ([0,0,0,0,0], 2.0), ([0,0,0,0,1], 2.15), ([0,0,0,1,0], 2.0), ([0,0,0,1,1], 2.15),\n        ([0,0,1,0,0], 2.05), ([0,0,1,0,1], 2.20), ([0,0,1,1,0], 2.05), ([0,1,0,0,0], 1.8),\n        ([0,1,0,0,1], 1.95), ([0,1,0,1,0], 1.8), ([0,1,1,0,0], 1.85), ([0,1,1,1,0], 1.85),\n        ([1,0,0,0,0], 2.1), ([1,0,0,0,1], 2.25), ([1,0,0,1,0], 2.1), ([1,0,1,0,0], 2.15),\n        ([1,1,0,0,0], 1.9), ([1,1,1,1,1], 2.1)\n    ]\n    unseen_C = [[1,0,1,0,1], [0,1,1,0,1]]\n    result_C = solve_case(L_C, data_C, unseen_C)\n    \n    # This is to generate the required output string as per the problem description,\n    # but the code itself is the content for the answer tag.\n    # The actual output string would be:\n    # f\"[{result_A}, {result_B}, {result_C}]\"\n    # Example: \"[[0.015192, 1.4, 1.85], [0.002857, 1.3], [0.000632, 2.3, 1.995455]]\"\n\nif __name__ == '__main__':\n    # This block is for local testing and will not be executed in the evaluation environment.\n    main_logic()\n```", "id": "2761900"}]}