{"hands_on_practices": [{"introduction": "在构建复杂的重组酶状态机之前，我们必须首先掌握其基本操作规则。本练习将引导您从第一性原理出发，推导在特定生化约束下，DNA分子可能发生的拓扑重排结果。通过分析位点方向如何决定重组结果（反转或切除），您将为预测和设计DNA逻辑电路打下坚实的基础，这是理解基于重组酶的DNA逻辑的最基本技能 [@problem_id:2768760]。", "problem": "一个环状脱氧核糖核酸（DNA）质粒包含恰好两个不同的重组位点：一个噬菌体附着位点 $attP$ 和一个细菌附着位点 $attB$。这两个位点以反向（头对头）排列，位于一个独特的非回文DNA片段 $S$ 的两侧。在没有任何重组酶方向性因子（RDF）的情况下，一种单向丝氨酸整合酶作用于该质粒。假设以下经过充分检验的事实为基本依据：\n- 位点特异性丝氨酸整合酶特异性地催化 $attB$ 和 $attP$ 之间的重组，产生 $attL$ 和 $attR$。\n- 在没有RDF的情况下，$attL \\times attR$ 反应不被催化，而正向的 $attB \\times attP$ 反应则会进行。\n- 在环状DNA上，反向位点之间的重组导致中间片段的倒位，而同向重复位点之间的重组则导致切除/整合事件。\n- 这两个核心位点是独特的且不对称的（即，$attB \\neq attP$；两者都不是回文序列），并且 $S$ 是非回文的，且与质粒的其余序列不同。\n\n从这些原理和环状DNA的拓扑结构出发，根据第一性原理，推导出在这些生物化学约束条件下，通过任何允许的重组事件序列，可以从初始质粒达到的所有不同的、拓扑上独特的DNA构型的完整集合。为便于计数，将未重组的起始构型视为一种有效的构型。\n\n在这些条件下可以达到的不同DNA构型的总数是多少？请以单个整数形式提供答案。无需四舍五入。", "solution": "该问题要求根据一套既定的生物化学规则，推导出一个从指定的初始构型出发可以达到的所有不同的、拓扑上独特的DNA构型的完整集合。\n\n设环状质粒的初始状态为 $\\Sigma_1$。根据问题描述，该质粒包含一个我们称之为 $P_B$ 的骨架序列，一个非回文DNA片段 $S$，以及两个不同的、不对称的重组位点 $attB$ 和 $attP$。$attB$ 和 $attP$ 位点呈反向（头对头）排列，位于片段 $S$ 的两侧。\n\n我们可以将 $\\Sigma_1$ 的分子构型表示为其组分的环状序列。为了表示不对称性和方向，我们可以使用箭头标记法。设沿质粒的一个方向的遍历为参考方向。反向排列意味着一个位点的方向与遍历方向相同，而另一个位点的方向相反。因此，$\\Sigma_1$ 的构型为：\n$$ \\text{状态 } \\Sigma_1: \\text{环状}(P_B, attB, S, attP_{inv}) $$\n这里，$attP_{inv}$ 表示相对于 $attB$ 位点呈反向排列的 $attP$ 位点。\n\n该系统含有一种在没有重组酶方向性因子（RDF）的情况下起作用的单向丝氨酸整合酶。其作用规则如下：\n$1$. 该整合酶特异性地催化一个 $attB$ 位点和一个 $attP$ 位点之间的重组。\n$2$. 在环状DNA分子上，反向位点之间的重组导致中间DNA片段的倒位。\n$3$. 反应消耗 $attB$ 和 $attP$ 位点，产生两个新位点 $attL$ 和 $attR$。\n$4$. 在没有RDF的情况下，逆向反应 $attL \\times attR \\rightarrow attB \\times attP$ 不被催化。\n\n将这些规则应用于状态 $\\Sigma_1$：\n处于状态 $\\Sigma_1$ 的质粒精确地包含一个 $attB$ 位点和一个 $attP$ 位点。根据规则1，整合酶可以作用于这对位点。由于这些位点是反向排列的（已知条件），规则2规定反应将是中间片段 $S$ 的倒位。这一重组事件将质粒从状态 $\\Sigma_1$ 转换为一个新状态，我们称之为 $\\Sigma_2$。\n\n该转换包含两个变化：\na) 片段 $S$ 发生倒位。我们将倒位的片段表示为 $S_{inv}$。问题陈述 $S$ 是非回文的，这意味着其DNA序列与其反向互补序列不同。因此，$S \\neq S_{inv}$。\nb) $attB$ 和 $attP$ 位点被转换为 $attL$ 和 $attR$（规则3）。位点特异性倒位的标准机制决定了产物位点会保留底物位点的方向。因此，新质粒中的 $attL$ 和 $attR$ 位点也将是反向排列的。\n\n因此，新状态 $\\Sigma_2$ 的构型为：\n$$ \\text{状态 } \\Sigma_2: \\text{环状}(P_B, attL, S_{inv}, attR_{inv}) $$\n构型 $\\Sigma_2$ 与 $\\Sigma_1$ 不同，因为其分子组成不同。具体来说，重组位点集合从 $\\{attB, attP\\}$ 变为 $\\{attL, attR\\}$，并且两侧的DNA片段从 $S$ 变为 $S_{inv}$。\n\n现在，我们必须评估从状态 $\\Sigma_2$ 出发发生进一步反应的可能性。处于状态 $\\Sigma_2$ 的质粒包含一个 $attL$ 位点和一个 $attR$ 位点。根据规则4，在没有RDF的情况下，$attL \\times attR$ 反应不被整合酶催化。由于质粒上没有其他整合酶可识别的位点（如 $attB$ 或 $attP$），因此不会发生进一步的重组事件。因此，状态 $\\Sigma_2$ 是一个终末状态。\n\n该系统的状态转移图是一个简单的有向图：\n$$ \\Sigma_1 \\xrightarrow{\\text{整合酶}} \\Sigma_2 $$\n从初始构型 $\\Sigma_1$ 可达到的所有DNA构型的集合是在此图中所有可达状态的集合，即 $\\{\\Sigma_1, \\Sigma_2\\}$。问题要求的是此类构型的总数，也就是该集合的基数。\n\n可达到的构型有：\n$1$. 初始的、未重组的质粒构型 $\\Sigma_1$。\n$2$. 最终的、重组后的质粒构型 $\\Sigma_2$。\n\n恰好有两种不同的、可达到的构型。", "answer": "$$\\boxed{2}$$", "id": "2768760"}, {"introduction": "理解了状态转换的定性逻辑后，下一步是进行定量预测，这对于设计可靠的生物电路至关重要。本练习 [@problem_id:2768691] 要求您为一个常见的基因反相器（一种基因开关）建立数学模型，并计算其在状态切换前后的表达水平变化。通过这个实践，您将学会如何运用泊松过程和终止子效率等基本概念来量化基因元件的性能，例如开关的倍数变化 $\\Phi$。", "problem": "一个由位点特异性重组酶（SSR）控制的反转模块被安装在脱氧核糖核酸（DNA）中一个编码序列的上游。该模块包含一个由重组位点界定的可反转盒。在该盒内部，有一个启动子和两个串联排列的内在转录终止子。在状态$\\mathcal{S}_{0}$（反转前），相对于编码序列的内部顺序是：启动子紧邻编码序列，它们之间没有终止子；两个终止子位于启动子的远端，因此不会减弱进入编码序列的转录本。在状态$\\mathcal{S}_{1}$（反转后），该盒发生反转，使其内部顺序颠倒，从而使终止子阵列位于启动子和编码序列之间；任何由该启动子起始的转录本现在都必须依次穿过两个终止子才能到达编码序列。\n\n基于基本的转录过程，我们做出以下模型假设：\n- 启动子以泊松过程起始转录，预期起始速率为$\\alpha$（单位时间内的起始次数）。与反转相关的上下文效应可能会改变内在起始速率，因此我们用$\\alpha_{0}$表示状态$\\mathcal{S}_{0}$下的启动子强度，用$\\alpha_{1}$表示状态$\\mathcal{S}_{1}$下的启动子强度。\n- 每个内在终止子$T_{i}$的效率为$\\tau_{i} \\in [0,1]$，定义为转录中的RNA聚合酶在遇到$T_{i}$时终止转录的概率。与不同终止子的相遇是相互独立的事件。\n- 成功通过所有中间终止子的转录本会到达编码序列，并被计为对表达有贡献的有效转录本。延伸和翻译过程不会引入额外的依赖于状态的损失。\n\n设两个终止子的效率分别为$\\tau_{1}$和$\\tau_{2}$。将预期表达的倍数变化定义为反转后的预期有效转录本通量与反转前的预期有效转录本通量之比，\n$$\n\\Phi \\equiv \\frac{\\text{expected productive transcript rate in }\\mathcal{S}_{1}}{\\text{expected productive transcript rate in }\\mathcal{S}_{0}}.\n$$\n\n在上述假设下，从第一性原理推导$\\Phi$，并将最终答案表示为仅含$\\alpha_{0}$、$\\alpha_{1}$、$\\tau_{1}$和$\\tau_{2}$的单个闭式解析表达式。倍数变化$\\Phi$是无量纲的。请勿对答案进行四舍五入。", "solution": "目标是推导预期表达的倍数变化$\\Phi$，其定义为反转状态$\\mathcal{S}_{1}$下的预期有效转录本速率与初始状态$\\mathcal{S}_{0}$下的预期有效转录本速率之比。\n$$\n\\Phi \\equiv \\frac{\\text{expected productive transcript rate in }\\mathcal{S}_{1}}{\\text{expected productive transcript rate in }\\mathcal{S}_{0}}\n$$\n\n设$R_{0}$为状态$\\mathcal{S}_{0}$下的预期有效转录本速率，$R_{1}$为状态$\\mathcal{S}_{1}$下的预期有效转录本速率。\n\n首先，我们分析状态$\\mathcal{S}_{0}$。\n在此状态下，启动子以$\\alpha_{0}$的预期速率（单位时间内的起始次数）起始转录。问题指明，在状态$\\mathcal{S}_{0}$下，盒的排列方式使启动子与编码序列相邻，其间没有终止子。因此，每个起始的转录本都将成功到达编码序列。一个转录本成为“有效的”概率是$1$。预期有效转录本的生成速率是起始速率与此概率的乘积。\n$$\nR_{0} = \\alpha_{0} \\times 1 = \\alpha_{0}\n$$\n\n接下来，我们分析状态$\\mathcal{S}_{1}$。\n在此状态下，盒发生反转。启动子现在以一个不同的预期速率$\\alpha_{1}$起始转录。关键在于，两个终止子$T_{1}$和$T_{2}$现在串联位于启动子和编码序列之间。一个转录本要想成为有效的，它必须成功“通读”这两个终止子。\n\n终止子$T_{i}$的效率给定为$\\tau_{i}$，它被定义为转录在遇到该终止子时终止的概率。因此，在终止子$T_{i}$处*不*终止（即成功通读）的概率是$(1 - \\tau_{i})$。\n\n问题陈述指出，与不同终止子的相遇是独立事件。因此，单个转录本成功通过两个终止子的概率是分别通过每一个终止子的概率的乘积。\n设$P_{\\text{read-through}}$为在状态$\\mathcal{S}_{1}$下起始的转录本到达编码序列的概率。\n$$\nP_{\\text{read-through}} = P(\\text{pass } T_{1} \\text{ and pass } T_{2})\n$$\n根据独立性，这等于：\n$$\nP_{\\text{read-through}} = P(\\text{pass } T_{1}) \\times P(\\text{pass } T_{2}) = (1 - \\tau_{1})(1 - \\tau_{2})\n$$\n在状态$\\mathcal{S}_{1}$下，预期有效转录本的生成速率$R_{1}$是起始速率$\\alpha_{1}$与这个组合通读概率的乘积。\n$$\nR_{1} = \\alpha_{1} \\times P_{\\text{read-through}} = \\alpha_{1} (1 - \\tau_{1}) (1 - \\tau_{2})\n$$\n\n最后，我们使用其定义来计算倍数变化$\\Phi$。\n$$\n\\Phi = \\frac{R_{1}}{R_{0}}\n$$\n代入推导出的$R_{0}$和$R_{1}$的表达式：\n$$\n\\Phi = \\frac{\\alpha_{1} (1 - \\tau_{1}) (1 - \\tau_{2})}{\\alpha_{0}}\n$$\n这就是以给定参数表示的倍数变化的最终闭式解析表达式。根据要求，它是一个无量纲量。", "answer": "$$\n\\boxed{\\frac{\\alpha_{1} (1 - \\tau_{1}) (1 - \\tau_{2})}{\\alpha_{0}}}\n$$", "id": "2768691"}, {"introduction": "真实世界的工程设计充满了权衡。本练习 [@problem_id:2768709] 将您置于一个实际的设计场景中，您需要为一个双输入逻辑门平衡其稳健性 $R(m,k)$ 与资源成本 $s(m,k)$（DNA位点数量）。您将探索如何利用冗余设计来提高系统可靠性，并应用多目标优化方法来寻找帕累托最优解，这体现了合成生物学中系统级设计的核心挑战。", "problem": "设计一个自包含程序，用于评估使用基于位点特异性重组酶的架构实现双输入事件整合逻辑设备的权衡。此问题纯粹以数学和逻辑术语进行描述。考虑一个设备，它仅在事件 $A$ 和事件 $B$ 以任意顺序都发生后才应输出正确状态。每个候选设计由两个整数参数化：每个表达盒中每个重组酶的位点对数量 $m$ 和并行的冗余表达盒数量 $k$。每个表达盒包含用于事件 $A$ 的 $m$ 个位点对和用于事件 $B$ 的 $m$ 个位点对，并且两种重组酶作用于不相交的位点。假设所有位点对和表达盒之间的作用是独立的，并使用以下基本事实和假设作为推导的基础：\n\n- 分子生物学中心法则意味着脱氧核糖核酸（DNA）的编辑会作为可遗传状态持续存在；在此，编辑被建模为由位点特异性重组酶引起的状态转换。\n- 每个位点对上所需的每一次重组独立成功的概率为 $1 - \\epsilon$，其中 $\\epsilon$ 是每个位点对每次所需编辑的微小失败概率。\n- 每个表达盒会产生一个独立的完整性失效因子，使正确性乘以一个因子 $1 - \\lambda$，其中 $\\lambda$ 是每个表达盒因泄露导致的失败概率。\n- 冗余表达盒的连接方式使得只要有任何一个表达盒是正确的，整个设备就是正确的（即独立伯努利试验的逻辑或）。\n\n对于本问题，请使用以下科学上合理的常数用于错误过程和候选设计集：\n- 每个位点对每次所需重组的失败概率：$\\epsilon_A = \\epsilon_B = 0.02$。\n- 每个表达盒的完整性失败概率：$\\lambda = 0.01$。\n- 候选设计是按字典序列出的 $12$ 个 $(m,k)$ 对（索引从 $0$ 开始）：$[(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,1),(4,2),(4,3),(4,4)]$，因此索引为 $0$到 $11$。\n\n需要用数学方法实现的任务：\n1. 从第一性原理推导并计算每个表达盒的正确概率 $q(m)$，其是 $m$ 的函数。已知条件为：两种重组酶，每种都需要 $m$ 次成功的位点对编辑；编辑之间相互独立；以及存在一个乘法完整性因子 $1 - \\lambda$。\n2. 从第一性原理推导并计算整体设备的鲁棒性 $R(m,k)$（即两个事件都发生后设备输出正确状态的概率），其中有 $k$ 个冗余表达盒作为独立的并行伯努利试验运行。\n3. 将一个设计的总重组位点数 $s(m,k)$ 定义为所有表达盒中两种重组酶的位点对总数的两倍。然后，通过使用候选集中的最小值和最大值将 $s(m,k)$ 线性映射到单位区间，计算归一化位点数 $\\tilde{s}(m,k)$。\n4. 定义一个标量化成本 $C_{\\alpha,\\beta}(m,k)$，它在权重 $\\alpha$ 和 $\\beta$（$\\alpha + \\beta = 1$）下平衡最小化 $\\tilde{s}(m,k)$ 和最大化 $R(m,k)$，具体方法是对鲁棒性的不足（即 $1 - R(m,k)$）进行惩罚。然后，对每个给定的权重对，计算使 $C_{\\alpha,\\beta}$ 最小化的设计的索引，在 $10^{-12}$ 的数值容差内通过选择最小索引来打破平局。\n5. 在最小化 $s(m,k)$ 并同时最大化 $R(m,k)$ 的双目标优化下，计算设计的帕累托最优集。如果 $s(x) \\le s(y)$ 且 $R(x) \\ge R(y)$，并且其中至少一个为严格不等式，则称设计 $x$ 支配设计 $y$；帕累托最优设计是指那些不被任何其他设计支配的设计。\n\n必需的测试套件（权重 $\\alpha, \\beta$ 按处理顺序列出）：\n- 情况 1：$\\alpha = 0.5$, $\\beta = 0.5$。\n- 情况 2：$\\alpha = 1.0$, $\\beta = 0.0$。\n- 情况 3：$\\alpha = 0.0$, $\\beta = 1.0$。\n- 情况 4：$\\alpha = 0.2$, $\\beta = 0.8$。\n\n需要精确计算的量：\n- 对于每个候选设计 $(m,k)$，使用基于上述基本假设推导出的定义以及给定的常数 $\\epsilon_A$、$\\epsilon_B$ 和 $\\lambda$ 来计算 $q(m)$、$R(m,k)$、$s(m,k)$ 和 $\\tilde{s}(m,k)$。\n- 对于测试套件中的每个权重对 $(\\alpha,\\beta)$，计算使 $C_{\\alpha,\\beta}(m,k)$ 最小化的候选设计的从0开始的索引。\n- 计算所有帕累托最优设计的从0开始的索引列表，按升序排列。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个有五个元素的逗号分隔的 Python 风格列表：前四个元素是给出索引的整数（与四个权重对的顺序相同），第五个元素是给出所有帕累托最优设计索引（按升序排列）的整数列表。例如，输出可能看起来像 $[i_1,i_2,i_3,i_4,[j_1,j_2,\\dots]]$，其中所有的 $i_\\cdot$ 和 $j_\\cdot$ 都是整数。本问题不要求任何物理单位或角度。请将所有小数表示为普通十进制数，而非百分比。", "solution": "### 推导\n\n**1. 每个表达盒的正确概率 $q(m)$**\n\n单个表达盒是正确的，当且仅当满足两个条件：（1）它在功能上是正确的，意味着所有必需的重组事件都成功；（2）它没有发生完整性失效。\n\n设 $S_A$为事件 A 的所有 $m$ 次重组成功的事件， $S_B$ 为事件 B 的相应事件。单个位点对重组成功的概率是 $1 - \\epsilon$。给定 $\\epsilon_A = \\epsilon_B = 0.02$，我们记此值为 $\\epsilon$。\n单个 A 型事件成功的概率是 $1 - \\epsilon_A$。由于有 $m$ 个这样的位点，并且它们的重组是独立事件，所以所有 $m$ 个都成功的概率是：\n$$ P(S_A) = (1 - \\epsilon_A)^m $$\n同样，对于事件 B：\n$$ P(S_B) = (1 - \\epsilon_B)^m $$\n由于重组酶作用于不相交的位点，我们假设 A 型重组的成功与 B 型重组的成功是独立的。因此，一个表达盒功能正确的概率 $P(\\text{functional})$ 是：\n$$ P(\\text{functional}) = P(S_A) \\cdot P(S_B) = (1 - \\epsilon_A)^m (1 - \\epsilon_B)^m $$\n给定 $\\epsilon_A = \\epsilon_B = \\epsilon = 0.02$，这简化为：\n$$ P(\\text{functional}) = (1 - \\epsilon)^{2m} $$\n问题陈述了一个乘法完整性失效因子 $1 - \\lambda$，其中 $\\lambda=0.01$。这是一个表达盒不因泄漏或其他结构问题而失效的概率。单个表达盒的最终正确概率 $q(m)$ 是功能正确概率和完整性概率的乘积：\n$$ q(m) = P(\\text{functional}) \\cdot (1 - \\lambda) = (1 - \\epsilon)^{2m} (1 - \\lambda) $$\n\n**2. 整体设备鲁棒性 $R(m,k)$**\n\n该设备由 $k$ 个独立的冗余表达盒组成。如果这 $k$ 个表达盒中至少有一个是正确的，则设备是正确的。计算其互补事件的概率更简单：设备不正确，这当且仅当所有 $k$ 个表达盒都不正确时发生。\n\n单个表达盒不正确的概率是 $1 - q(m)$。\n由于 $k$ 个表达盒是独立的，它们全部不正确的概率是：\n$$ P(\\text{all } k \\text{ incorrect}) = (1 - q(m))^k $$\n因此，鲁棒性 $R(m,k)$，即设备正确的概率，是：\n$$ R(m,k) = 1 - P(\\text{all } k \\text{ incorrect}) = 1 - (1 - q(m))^k $$\n\n**3. 位点数 $s(m,k)$ 和归一化位点数 $\\tilde{s}(m,k)$**\n\n问题将总重组位点数 $s(m,k)$ 定义为“所有表达盒中两种重组酶的位点对总数的两倍”。\n- 每个表达盒中每个重组酶的位点对数：$m$。\n- 重组酶数量：$2$（用于 $A$ 和 $B$）。\n- 每个表达盒的总位点对数：$2m$。\n- 所有 $k$ 个表达盒的总位点对数：$k \\cdot (2m) = 2mk$。\n严格按照定义，$s(m,k)$ 是这个值的两倍：\n$$ s(m,k) = 2 \\cdot (2mk) = 4mk $$\n为了计算归一化位点数 $\\tilde{s}(m,k)$，我们首先在给定的 $12$ 个候选设计集合中找到 $s(m,k)$ 的最小值和最大值。设它们为 $s_{\\text{min}}$ 和 $s_{\\text{max}}$。到单位区间 $[0, 1]$ 的线性映射为：\n$$ \\tilde{s}(m,k) = \\frac{s(m,k) - s_{\\text{min}}}{s_{\\text{max}} - s_{\\text{min}}} $$\n只要 $s_{\\text{max}} \\neq s_{\\text{min}}$，这个公式就有效，对于给定的设计集这是成立的。\n\n**4. 标量化成本 $C_{\\alpha,\\beta}(m,k)$**\n\n成本函数是归一化位点数（一个待最小化的成本）和设备失败概率（另一个待最小化的成本）的加权和。失败概率是 $1 - R(m,k)$。\n$$ C_{\\alpha,\\beta}(m,k) = \\alpha \\cdot \\tilde{s}(m,k) + \\beta \\cdot (1 - R(m,k)) $$\n对于每对给定的权重 $(\\alpha, \\beta)$，我们必须为所有 $12$ 个设计计算此成本，并找到产生最小成本的设计的索引。必须通过在 $10^{-12}$ 的数值容差内选择那些最小成本中的最小索引来打破平局。\n\n**5. 帕累托最优集**\n\n双目标优化问题是同时最小化位点数 $s(m,k)$ 和最大化鲁棒性 $R(m,k)$。如果没有任何其他设计在两个目标上都更优，则该设计位于帕累托前沿上。\n如果满足以下条件，则设计 $x = (m_x, k_x)$ 支配设计 $y = (m_y, k_y)$：\n$$ s(m_x, k_x) \\le s(m_y, k_y) \\quad \\text{and} \\quad R(m_x, k_x) \\ge R(m_y, k_y) $$\n且其中至少有一个不等式是严格的。\n如果一个设计不被候选集中的任何其他设计所支配，则它是帕累托最优的。寻找帕累托集的算法是遍历每个设计，检查是否有任何其他设计支配它。如果不存在这样的支配者，则将该设计添加到帕累托集。最终的索引列表必须排序。\n\n以下Python代码实现了上述计算：\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the recombinase-based logic device design problem.\n    \"\"\"\n    #\n    # Step 0: Define constants and candidate designs\n    #\n    epsilon = 0.02\n    lambda_ = 0.01\n\n    candidate_designs = [\n        (2, 1), (2, 2), (2, 3), (2, 4),  # Indices 0-3\n        (3, 1), (3, 2), (3, 3), (3, 4),  # Indices 4-7\n        (4, 1), (4, 2), (4, 3), (4, 4)   # Indices 8-11\n    ]\n    num_designs = len(candidate_designs)\n\n    #\n    # Step 1: Compute q(m) for all relevant m\n    #\n    m_values = sorted(list(set(m for m, k in candidate_designs)))\n    q_m_map = {}\n    for m in m_values:\n        q_m_map[m] = ((1 - epsilon)**(2 * m)) * (1 - lambda_)\n\n    #\n    # Step 2  3: Compute R(m,k), s(m,k) for all designs\n    #\n    R_values = []\n    s_values = []\n    for m, k in candidate_designs:\n        q_m = q_m_map[m]\n        R_mk = 1 - (1 - q_m)**k\n        R_values.append(R_mk)\n        s_mk = 4 * m * k\n        s_values.append(s_mk)\n    \n    R_values = np.array(R_values)\n    s_values = np.array(s_values)\n\n    s_min = np.min(s_values)\n    s_max = np.max(s_values)\n    s_range = s_max - s_min\n    if s_range == 0:\n        s_tilde_values = np.zeros(num_designs)\n    else:\n        s_tilde_values = (s_values - s_min) / s_range\n\n    #\n    # Step 4: Find optimal design for each (alpha, beta) weight pair\n    #\n    test_cases = [\n        (0.5, 0.5),  # Case 1\n        (1.0, 0.0),  # Case 2\n        (0.0, 1.0),  # Case 3\n        (0.2, 0.8)   # Case 4\n    ]\n    optimal_indices = []\n    tolerance = 1e-12\n\n    for alpha, beta in test_cases:\n        costs = alpha * s_tilde_values + beta * (1 - R_values)\n        min_cost = np.min(costs)\n        tied_indices = np.where(costs = min_cost + tolerance)[0]\n        best_index = np.min(tied_indices)\n        optimal_indices.append(int(best_index))\n\n    #\n    # Step 5: Compute the Pareto-optimal set\n    #\n    pareto_indices = []\n    for i in range(num_designs):\n        is_dominated = False\n        for j in range(num_designs):\n            if i == j:\n                continue\n            \n            # Check if design j dominates design i\n            s_le = s_values[j] = s_values[i]\n            r_ge = R_values[j] >= R_values[i]\n            s_lt = s_values[j]  s_values[i]\n            r_gt = R_values[j] > R_values[i]\n\n            if s_le and r_ge and (s_lt or r_gt):\n                is_dominated = True\n                break\n        \n        if not is_dominated:\n            pareto_indices.append(i)\n\n    pareto_indices.sort()\n    \n    # This part is for generating the final output string, not included in the solution logic\n    # final_result = optimal_indices + [pareto_indices]\n    # result_str = f\"[{optimal_indices[0]},{optimal_indices[1]},{optimal_indices[2]},{optimal_indices[3]},{pareto_indices}]\"\n    # print(result_str)\n\n# The function call is not needed inside the solution text.\n# solve()\n```", "answer": "$$\\boxed{\\texttt{[11,0,11,11,[0, 4, 8, 9, 10, 11]]}}$$", "id": "2768709"}]}