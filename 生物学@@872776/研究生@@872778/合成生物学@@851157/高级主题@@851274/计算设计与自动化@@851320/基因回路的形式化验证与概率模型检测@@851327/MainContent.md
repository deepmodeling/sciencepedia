## 引言
随着合成生物学从一门探索性科学迅速转变为一门工程学科，我们面临的核心挑战是如何以可预测和可靠的方式设计复杂的生物系统。传统的“设计-构建-测试”循环往往耗时且充满不确定性，这主要是因为基因表达等核心[生物过程](@entry_id:164026)具有内在的随机性和[非线性](@entry_id:637147)动态。为了克服这一障碍，我们需要一套严谨的定量工具，能够在设计阶段就对基因线路的行为进行预测和验证。本文旨在系统介绍[形式验证](@entry_id:149180)与[概率模型](@entry_id:265150)检查——一套源于计算机科学的强大方法，如何被应用于解决合成生物学中的这一核心问题。

通过本文的学习，读者将掌握将复杂的生物过程转化为精确数学模型的技术，并学会使用形式化语言来描述期望的系统功能。文章将分为三个核心部分：
第一章，“原理与机制”，将为读者奠定坚实的理论基础，详细阐述如何将[基因线路建模](@entry_id:267401)为[随机过程](@entry_id:159502)（如[连续时间马尔可夫链](@entry_id:276307)），并介绍用于描述其动态行为的[时序逻辑](@entry_id:181558)（如CSL）及其验证算法。
第二章，“应用与[交叉](@entry_id:147634)学科联系”，将通过分析[基因开关](@entry_id:188354)、[振荡器](@entry_id:271549)和安全模块等具体实例，展示这些形式化方法在验证系统功能、保障生物安全以及自动化设计中的实际应用。
最后，“动手实践”部分将提供一系列精心设计的问题，帮助读者将理论知识转化为解决实际问题的能力。

通过这一结构化的学习路径，本文将引导读者深入理解如何利用形式化方法，将合成生物系统的设计提升到一个全新的、可量化、可预测的工程水平。

## 原理与机制

在对合成基因线路进行[形式验证](@entry_id:149180)的探索中，我们首先需要建立一个坚实的数学基础。本章旨在阐述将生物过程转化为可分析的随机模型的核心原理，介绍用于描述其动态行为的逻辑语言，并概述验证这些行为的关键算法机制。我们将从基本[化学动力学](@entry_id:144961)的第一性原理出发，逐步构建起一个适用于基因线路[概率模型](@entry_id:265150)检查的完整理论框架。

### 将[基因线路建模](@entry_id:267401)为[随机过程](@entry_id:159502)

随机性是基因表达等生物过程的内在特征，源于分子数量的离散性和反应事件的偶然性。为了精确捕捉这种随机动态，我们需要一个能够描述系统状态随时间概率性演化的数学模型。

#### [化学主方程](@entry_id:161378)与[连续时间马尔可夫链](@entry_id:276307)

考虑一个由 $n$ 种分子和 $m$ 个反应通道组成的基因线路，其状态在任意时刻 $t$ 可由一个表示各种分子数量的向量 $X(t) \in \mathbb{N}^{n}$ 来描述。每个反应 $j$ 的发生都将导致系统状态从 $x$ 变为 $x + S_{:,j}$，其中 $S_{:,j}$ 是**化学计量矩阵** $S \in \mathbb{Z}^{n \times m}$ 的第 $j$ 列，它编码了该反应引起的分子数量的净变化。

描述这些反应何时以及以多快速度发生的关键在于**[倾向函数](@entry_id:181123)** (propensity function)。当系统处于状态 $x$ 时，反应 $j$ 发生的瞬时风险或速率由[倾向函数](@entry_id:181123) $a_j(x)$ 给出。在一个充分混合的系统中，下一次反应事件的等待时间是[指数分布](@entry_id:273894)的，这一基本假设构成了[随机化学动力学](@entry_id:185805)的基石。

为了描述整个系统状态[概率分布](@entry_id:146404)的演化，我们可以构建**[化学主方程](@entry_id:161378)** (Chemical Master Equation, CME)。CME 本质上是描述[概率质量函数](@entry_id:265484) $p(x,t) = \Pr\{X(t) = x\}$ 随时间变化的 Kolmogorov 前向方程。它通过平衡流入和流出每个状态 $x$ 的概率通量来建立。流入状态 $x$ 的概率来自于所有可能的前驱状态，即那些可以通过一次反应变成 $x$ 的状态。例如，状态 $x - S_{:,j}$ 可以通过反应 $j$ 变为 $x$，其贡献的概率流入速率为 $a_j(x - S_{:,j}) p(x - S_{:,j}, t)$。相反，从状态 $x$ 流出的概率是由于任何反应的发生，总流出速率为 $(\sum_{j=1}^{m} a_j(x)) p(x,t)$。综合这些因素，我们得到 CME 的一般形式 [@problem_id:2739272]：
$$
\frac{d}{dt} p(x,t) = \sum_{j=1}^{m} a_{j}(x - S_{:,j}) p(x - S_{:,j}, t) - \left(\sum_{j=1}^{m} a_{j}(x)\right) p(x,t)
$$

这种由指数等待时间和无记忆状态转移构成的[随机过程](@entry_id:159502)，其数学结构正是一个**[连续时间马尔可夫链](@entry_id:276307)** (Continuous-Time Markov Chain, CTMC)。CTMC 的动态由其**[无穷小生成元](@entry_id:270424)矩阵** $Q$ 完全确定。$Q$ 矩阵的元素 $Q(x,y)$ 表示从状态 $x$ 到状态 $y$ 的瞬时转移速率。通过将 CME 与 Kolmogorov 方程的[标准形式](@entry_id:153058)进行比较，我们可以推导出 $Q$ 矩阵的元素 [@problem_id:2739272]。对于 $y \neq x$ 的非对角元素， $Q(x,y)$ 是所有能使状态从 $x$ 变为 $y$ 的[反应倾向](@entry_id:262886)之和。对角元素 $Q(x,x)$ 则是从状态 $x$ 流出的总速率的[相反数](@entry_id:151709)。利用[指示函数](@entry_id:186820) $\mathbf{1}\{\cdot\}$ 和克罗内克 $\delta$ 函数，我们可以将 $Q(x,y)$ 紧凑地表示为：
$$
Q(x,y) = \sum_{j=1}^{m} a_{j}(x) \mathbf{1}\{ y = x + S_{:,j} \} - \delta_{x,y} \sum_{j=1}^{m} a_{j}(x)
$$
其中，$\mathbf{1}\{E\}$ 在事件 $E$ 为真时取值为 1，否则为 0；$\delta_{x,y}$ 在 $x=y$ 时为 1，否则为 0。

为了建立对指数等待时间的直观理解，我们考虑一个最简单的例子：一个组成型基因以恒定倾向 $\lambda$ 进行转录。这对应于一个只有单一反应通道的系统。事件（[转录起始](@entry_id:140735)）之间的等待时间是独立的，且均服从速率为 $\lambda$ 的指数分布。我们可以从第一性原理出发，计算在时间区间 $(0,t]$ 内恰好发生一次转录事件的概率。这个事件等价于第一次事件在 $t$ 之前发生，而第二次事件在 $t$ 之后发生。通过对第一次事件发生的时间 $\tau_1$ 进行积分，并利用指数分布的无记忆性，可以推导出该概率为 $P(N(t)=1) = \lambda t \exp(-\lambda t)$ [@problem_id:2739313]。这正是[泊松分布](@entry_id:147769)在计数值为 1 时的[概率质量函数](@entry_id:265484)，揭示了恒定速率的反应过程与泊松过程之间的深刻联系。

#### [模型选择](@entry_id:155601)：CTMC, DTMC 与 MDP

尽管 CTMC 是描述[随机化学动力学](@entry_id:185805)的标准模型，但在某些情况下，其他模型可能更适用或更便于分析。

*   **[连续时间马尔可夫链 (CTMC)](@entry_id:203641)**：当所有[反应倾向](@entry_id:262886)仅依赖于当前系统状态（分子数量、[启动子](@entry_id:156503)状态等），并且我们关心系统的实时动态时，CTMC 是最自然、最精确的模型。例如，一个包含[启动子](@entry_id:156503)在“开”和“关”状态之间[随机切换](@entry_id:197998)、以及依赖于这些状态的转录和翻译过程的基因线路，只要所有速率（包括[启动子](@entry_id:156503)切换速率 $k_{\text{on}}$ 和 $k_{\text{off}}$）都是状态依赖的，整个系统就可以被建模为一个大的 CTMC [@problem_id:2739321]。

*   **[离散时间马尔可夫链 (DTMC)](@entry_id:275530)**：有时，我们可能只关心事件发生的顺序，或者希望在固定的时间步长上分析系统。DTMC 通过两种主要方式从 CTMC 导出。第一种是近似方法，例如 $\tau$-leaping 算法，它在小的固定时间步 $\Delta t$ 内近似反应发生的概率。第二种是精确的**均匀化** (uniformization) 方法，它将 CTMC 转换为一个等价的 DTMC，其中事件以一个恒定的最大速率 $\Lambda$ 发生，并在每次事件时根据倾向概率决定是发生真实反应还是“虚拟”反应（状态不变）。这两种方法都允许我们将连续[时间问题](@entry_id:202825)转化为离散步数问题进行分析 [@problem_id:2739321]。

*   **[马尔可夫决策过程](@entry_id:140981) (MDP)**：当[基因线路](@entry_id:201900)的动态受到外部控制或决策的影响时，MDP 成为必要的模型。MDP 在[马尔可夫链](@entry_id:150828)的基础上增加了“行动”的概念。在每个决策时刻，一个决策者（或控制器）选择一个行动，该行动会改变系统的转移概率。例如，在合成生物学中，通过外部信号（如光或化学诱导剂）调节细胞资源（如[核糖体](@entry_id:147360)）的分配，从而控制蛋白质的翻译速率，就是一个典型的控制问题。此时，外部信号的设定就是“行动”，而系统在不同信号下的随机演化则构成了 MDP 的动态。MDP 框架使我们能够设计策略来优化系统的[长期行为](@entry_id:192358)，例如最大化某种目标蛋白的产量 [@problem_id:2739321]。

### 使用[时序逻辑](@entry_id:181558)规约性质

一旦我们将基因线路表示为随机模型，下一步就是以一种精确、无歧义的方式来描述我们感兴趣的行为。**[时序逻辑](@entry_id:181558)** (temporal logic) 为此提供了强大的形式化语言。

#### [连续随机逻辑 (CSL)](@entry_id:180228)

对于 CTMC 模型，**连续随机逻辑** (Continuous Stochastic Logic, CSL) 是一个[表达能力](@entry_id:149863)丰富的规约语言。CSL 的语法结构是分层的，包含**状态公式** (state formulas) 和**路径公式** (path formulas)。状态公式在模型的某个特定状态下为真或为假，而路径公式则在模型的一条可能演化路径上为真或为假。

CSL 的核心是概率算子 $\mathcal{P}_{\sim p}[\psi]$，它将路径公式 $\psi$ 转化为状态公式。其含义是：“从当前状态开始，一条随机路径满足路径公式 $\psi$ 的概率满足关系 $\sim p$”（其中 $\sim \in \{, \le, >, \ge\}$）。

CSL 最强大的特性之一是它处理实时的能力，这体现在其时间有界的路径算子中。一个典型的例子是**时间有界“直到”算子** (time-bounded until)，记为 $\phi_1 \, U^I \, \phi_2$，其中 $I$ 是一个实数时间区间。路径公式 $\phi_1 \, U^{\le T} \, \phi_2$（即 $I=[0,T]$）的语义是：“存在某个时间点 $t \in [0,T]$，在该时刻状态满足 $\phi_2$，并且在从 0 到 $t$ 的所有时刻 $t' \in [0,t)$，状态都满足 $\phi_1$。” [@problem_id:2739274]。

这个算子对于描述合成生物学中的功能至关重要。例如，我们可以用它来规约“一个基因开关在 30 分钟内达到高表达状态的概率大于 0.9，并且在此期间细胞保持存活”这类带有明确时[间期](@entry_id:157879)限和条件的复杂性质。

#### CSL 与 PCTL 的区别

CSL 的实时性将其与用于 DTMC 的**概率[计算树逻辑](@entry_id:198041)** (Probabilistic Computation Tree Logic, PCTL) 显著区分开来。PCTL 的算子是基于离散的“步数”而非连续的时间。例如，PCTL 中的 $\phi_1 \, U^{\le k} \, \phi_2$ 表示在 $k$ 步之内达到 $\phi_2$。

这种区别的实际意义可以通过一个思想实验来揭示 [@problem_id:2739250]。假设我们有两个 CTMC 模型，$\mathcal{C}_1$ 和 $\mathcal{C}_2$，它们描述的是同一个[基因线路](@entry_id:201900)，具有完全相同的[状态转移图](@entry_id:175938)。唯一的区别是，$\mathcal{C}_2$ 的所有[反应速率](@entry_id:139813)都是 $\mathcal{C}_1$ 中相应速率的 $c$ 倍（$c > 1$）。这意味着 $\mathcal{C}_2$ 的动态比 $\mathcal{C}_1$ 快 $c$ 倍，但它们发生反应的相对概率（即嵌入的 DTMC）是完全相同的。

现在考虑一个 CSL 性质，如 $\mathcal{P}_{\ge 0.9}[\text{true} \, U^{\le 10 \text{ min}} \, \text{high}]$（“在 10 分钟内达到高表达状态的概率至少为 0.9”）。由于 $\mathcal{C}_2$ 演化得更快，它达到 `high` 状态的概率在固定时间窗口内通常会比 $\mathcal{C}_1$ 更高。因此，这个性质可能在 $\mathcal{C}_2$ 中成立而在 $\mathcal{C}_1$ 中不成立。然而，任何 PCTL 性质，由于其只依赖于离散步数和转移概率，在 $\mathcal{C}_1$ 和 $\mathcal{C}_2$ 上的评估结果将完全相同，因为它对这种均匀的[时间缩放](@entry_id:190118)是“盲目”的。这表明 CSL 能够捕捉对生物功能至关重要的实时动态，而这是 PCTL 无法做到的。

### 概率模型检查的核心算法

概率模型检查的核心任务是确定一个给定的随机模型（如 CTMC）是否满足一个给定的[时序逻辑](@entry_id:181558)公式（如 CSL）。这通常归结为计算满足特定路径公式的概率。

#### 解析方法：Kolmogorov 方程

对于状态空间非常小的系统，我们可以直接求解描述概率演化的[微分方程](@entry_id:264184)。CSL 模型检查的概率计算问题可以转化为求解一个**Kolmogorov 后向[方程组](@entry_id:193238)** (system of Kolmogorov backward equations)。

让我们以一个简单的[启动子](@entry_id:156503)模型为例 [@problem_id:2739273]。该模型有三个状态：基础态 $x_A$（满足 $\phi_1$），激活态 $x_B$（满足 $\phi_2$），和失败态 $x_F$（违反 $\phi_1$）。从 $x_A$ 到 $x_B$ 的速率为 $k_{\text{on}}$，到 $x_F$ 的速率为 $k_{\text{off}}$。我们想计算从 $x_A$ 出发，在时间 $T$ 内满足 $\phi_1 \, U^{\le T} \, \phi_2$ 的概率 $u(x_A, T)$。

根据 CTMC 的第一性原理，从 $x_A$ 开始，系统会在此状态停留一个指数分布的时间，然后跳转到 $x_B$ 或 $x_F$。为了满足性质，系统必须在时间 $T$ 内跳转到 $x_B$。通过对第一次跳转发生的时间 $\tau$ 进行积分，并乘以跳转到 $x_B$ 的条件概率，我们可以建立一个关于 $u(x_A, T)$ 的积分方程：
$$
u(x_A, T) = \int_0^T k_{\mathrm{on}} \exp(-(k_{\mathrm{on}}+k_{\mathrm{off}})\tau) d\tau
$$
求解这个简单的积分，我们得到：
$$
u(x_A, T) = \frac{k_{\mathrm{on}}}{k_{\mathrm{on}}+k_{\mathrm{off}}} \left( 1 - \exp(-(k_{\mathrm{on}}+k_{\mathrm{off}})T) \right)
$$
这个结果直观地反映了两个竞争过程：一个是“成功”过程（以速率 $k_{\text{on}}$ 跳转到 $x_B$），另一个是“失败”过程（以速率 $k_{\text{off}}$ 跳转到 $x_F$）。该概率是成功过程在时间 $T$ 到期前赢得竞争的概率。

#### 数值方法：均匀化

对于大多数实际系统，状态空间过大，无法进行解析求解。**均匀化** (Uniformization)，或称 Jensen 方法，是一种强大而稳健的[数值算法](@entry_id:752770)，用于计算 CTMC 的瞬态概率，即系统在特定时间 $t$ 处于某个状态的概率 $P(t)$。

均匀化的核心思想是，任何 CTMC 都可以被看作一个泊松过程和一个 DTMC 的复合。我们选择一个均匀化速率 $\gamma$，它必须大于或等于 CTMC 中所有状态的[最大流](@entry_id:178209)出速率。然后，我们想象事件以恒定的泊松速率 $\gamma$ 发生。在每个事件时刻，系统要么根据一个新定义的 DTMC [转移矩阵](@entry_id:145510) $U = I + Q/\gamma$ 进行一次“真实”转移，要么以一定的概率进行一次“虚拟”转移（停留在原地）。

通过这种转换，在时间 $t$ 的瞬态[概率矩阵](@entry_id:274812) $P(t) = \exp(Qt)$ 可以表示为一个[无穷级数](@entry_id:143366) [@problem_id:2739281]：
$$
P(t) = \sum_{k=0}^{\infty} e^{-\gamma t} \frac{(\gamma t)^k}{k!} U^k
$$
这个公式的每一项都很有启发性：$e^{-\gamma t} \frac{(\gamma t)^k}{k!}$ 是在时间 $t$ 内恰好发生 $k$ 次泊松事件的概率，而 $U^k$ 是嵌入的 DTMC 经过 $k$ 步后的[转移矩阵](@entry_id:145510)。因此，CTMC 的连续[时间演化](@entry_id:153943)被分解为对离散步数演化的加权求和。

这个方法可以直接用于 CSL 模型检查。例如，要计算时间有界直到性质的概率，我们可以修改原始 CTMC，使所有满足 $\phi_2$ 的目标[状态和](@entry_id:193625)所有违反 $\phi_1$ 的失败状态都变成[吸收态](@entry_id:161036)。然后，该性质的满足概率就等于从初始状态出发，在时间 $t$ 到达任意一个吸收目标态的概率之和。这个概率可以通过均匀化级数计算，并在达到所需精度时截断 [@problem_id:2739281]。

#### 无界可达性：[求解线性方程组](@entry_id:169069)

对于不带时间限制的性质，例如“系统最终到达目标状态 $G$ 的概率是多少？”，问题可以进一步简化。这种**无界[可达性](@entry_id:271693)** (unbounded reachability) 概率不依赖于反应的快慢，只依赖于事件发生的顺序和概率。因此，它可以完全在从 CTMC 导出的嵌入式 DTMC 上进行分析。

假设我们将[状态空间](@entry_id:177074)划分为瞬态（非目标）状态集 $N$ 和吸收目标状态集 $G$。我们想计算从每个瞬态状态 $s \in N$ 出发，最终到达 $G$ 的概率 $u(s)$。通过对第一步转移进行条件分析，我们可以为每个 $s \in N$ 建立一个线性方程 [@problem_id:2739277]：
$$
u(s) = \sum_{s' \in N \cup G} P(s, s') u(s')
$$
其中 $P(s, s')$ 是 DTMC 的转移概率。由于对于目标态 $s' \in G$，我们有 $u(s') = 1$（已经到达），对于其他吸收失败状态，有 $u(s') = 0$，这个[方程组](@entry_id:193238)可以重写为关于未知[概率向量](@entry_id:200434) $\mathbf{u} = (u(s))_{s \in N}$ 的标准[线性系统](@entry_id:147850) $(I - P_{NN})\mathbf{u} = \mathbf{b}$，其中 $P_{NN}$ 是仅包含瞬态状态之间转移的子矩阵，$\mathbf{b}$ 是从瞬态状态一步转移到目标状态的[概率向量](@entry_id:200434)。通过求解这个线性方程组，我们便可以得到所有瞬态状态的最终[可达性](@entry_id:271693)概率。

### 高级主题与可扩展性

随着[基因线路](@entry_id:201900)变得越来越复杂，直接应用上述算法会遇到所谓的“[状态空间](@entry_id:177074)爆炸”问题。高级[形式验证](@entry_id:149180)技术通过抽象和模块化来应对这一挑战。

#### 抽象与反例指导的抽象精化 (CEGAR)

**抽象** (Abstraction) 旨在将一个庞大而复杂的具体[模型简化](@entry_id:171175)为一个更小、更易于分析的抽象模型，同时保留待验证性质的关键信息。一种常见的技术是基于状态划分的抽象，即将多个具体状态合并为一个抽象状态。然而，这种合并会引入不确定性。例如，如果一个抽象状态包含了多个具体状态，它们到另一个抽象状态的转移速率可能各不相同。这导致抽象模型不再是简单的 CTMC，而是一个**连续时间[马尔可夫决策过程](@entry_id:140981)** (CTMDP)，其中转移速率在一个区间内非确定性地变化。

在 CTMDP 上进行验证会得到一个概率区间 $[\ell, u]$，分别代表了性质成立的最小和最大可能概率。如果我们想证明一个性质 $\mathcal{P}_{\le p}[\psi]$ 成立，就必须确保上界 $u \le p$。如果验证发现 $u > p$，模型检查器会提供一个**反例** (counterexample)，即一条导致[上界](@entry_id:274738)概率最高的抽象路径。

然而，这个反例可能是**伪反例** (spurious counterexample)，即它利用了抽象模型中存在的、但在原始具体模型中无法实现的路径。例如，一个抽象状态可能同时包含了远离目标和靠近目标的具体状态。抽象模型可能“错误地”假设系统总是处于靠近目标的状态，从而高估了到达目标的概率 [@problem_id:2739315]。

**反例指导的抽象精化** (Counterexample-Guided Abstraction Refinement, CEGAR) 正是解决这一问题的系统性方法。它是一个迭代循环：
1.  **抽象**：构建一个（通常是粗糙的）初始抽象模型。
2.  **验证**：在抽象模型上验证性质。如果性质成立（例如，[上界](@entry_id:274738)概率满足约束），则验证成功。
3.  **分析反例**：如果性质不成立，分析生成的反例，判断其是否是伪反例。这通常通过在具体模型中模拟该抽象路径来完成。
4.  **精化**：如果反例是伪的，则用其包含的信息来**精化** (refine) 抽象。例如，将导致伪行为的抽象状态分裂成更小的部分，从而消除不确定性。然后返回步骤 2。

通过不断地精化，CEGAR 能够逐步消除伪反例，最终要么证明性质成立，要么找到一个真实存在的违反性质的具体路径。对于更复杂的系统，如包含连续变量的随机[混合系统](@entry_id:271183)，也可以通过将其离散化为区间[马尔可夫决策过程](@entry_id:140981) (IMDP) 来进行抽象，并通过计算上下界来量化抽象引入的误差 [@problem_id:2739279]。

#### 组合验证与[资源竞争](@entry_id:191325)

构建大型合成生物系统的梦想依赖于模块化设计，即从经过验证的较小组件（模块）可靠地构建复杂功能。然而，**组合验证** (compositional verification) 面临一个巨大挑战：生物环境中的隐性耦合，尤其是**[资源竞争](@entry_id:191325)** (resource contention)。

一个在资源充足的环境中被独立验证的模块，当被置于与其他模块共享有限细胞资源（如 RNA 聚合酶、[核糖体](@entry_id:147360)）的拥挤细胞环境中时，其性能可能会急剧下降。考虑两个模块，每个都在隔离验证时能以 95% 的概率在时间 $T$ 内完成其功能。当它们同时激活并竞争资源时，每个模块的有效速率都会降低，导致它们各自的成功概率可能远低于 95%，从而违反了原始规约 [@problem_id:2739261]。

解决这个问题的关键是**假设-保证推理** (assume-guarantee reasoning)。在这种框架下，我们不再孤立地验证模块，而是为每个模块规约一个**环境假设**。模块的性质保证仅在环境满足该假设时才成立。例如，一个有效的环境假设可以是：“在时间窗口 $[0,T]$ 内，分配给本模块的总有效资源（表示为累积风险 $\int_0^T \lambda^{\text{eff}}(t) dt$）必须不低于某个阈值。” [@problem_id:2739261]。然后，组合验证的任务就转变为：(1) 验证每个模块在其环境假设下满足其功能规约；(2) 验证当所有模块组合在一起时，它们共同构成的环境能够满足每个模块的假设。

#### 使用监控自动机进行[模式匹配](@entry_id:137990)

某些复杂的行为模式，例如“事件 A 必须在事件 B 之前发生”，虽然可以用 CSL 表达，但定义起来可能相当繁琐。一种更直观、更强大的方法是使用一个**监控自动机** (monitor automaton) 来定义所需的事件序列。

监控自动机是一个确定性有限自动机，它观察 CTMC 产生的事件（或状态标签），并根据这些观察进行状态转换。它通常包含一个初始状态、一个或多个“接受”[状态和](@entry_id:193625)一个“拒绝”状态。

为了验证一个模式，我们构建一个**乘积自动机** (product automaton)，它的状态是原始 CTMC [状态和](@entry_id:193625)监控自动机状态的配对 $(s, q)$。乘积自动机的转移规则由原始 CTMC 和监控自动机共同决定：当 CTMC 从状态 $s$ 转移到 $s'$ 时，监控自动机根据 $s'$ 的标签更新其状态到 $q'$，于是乘积自动机就从 $(s, q)$ 转移到 $(s', q')$。

通过这种构造，原始的复杂[模式匹配](@entry_id:137990)问题被转化为乘积自动机上的一个简单[可达性问题](@entry_id:273375) [@problem_id:2739284]。例如，“模式被接受的概率是多少？”就等价于“在乘积自动机中，最终到达任何‘接受’监控状态的概率是多少？”。这个问题可以使用我们已经讨论过的标准数值方法（如均匀化）来高效解决。