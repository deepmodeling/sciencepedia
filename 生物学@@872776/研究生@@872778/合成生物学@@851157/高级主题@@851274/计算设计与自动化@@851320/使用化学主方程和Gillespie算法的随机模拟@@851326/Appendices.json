{"hands_on_practices": [{"introduction": "在编写代码之前，理解算法背后的理论基础至关重要。Gillespie算法并非一套凭空出现的规则，而是对化学主方程所描述的物理过程的直接推论。本练习将通过一个简单的生灭过程，从第一性原理推导该算法的两个核心要素：到下一次反应发生前的等待时间$\\tau$的概率分布，以及下一次具体发生哪个反应的概率。通过完成这个推导 ([@problem_id:2777186])，您将深刻理解为何该算法能够正确地从化学主方程的解中采样轨迹，从而将抽象理论与具体的模拟步骤联系起来。", "problem": "在合成生物学的一个信使RNA分子的组成型单基因表达模型中，系统被建模为一个在化学主方程 (CME) 框架下的双反应生灭过程，并通过随机模拟算法 (SSA) 进行模拟。在时间 $t$，系统当前的分子数为$n \\in \\mathbb{N}_{0}$。这两个反应是：\n- 转录（生成）：$\\varnothing \\rightarrow \\text{mRNA}$，随机速率常数为$k_b$（单位：$\\text{time}^{-1}$）。\n- 降解（消亡）：$\\text{mRNA} \\rightarrow \\varnothing$，一级随机速率常数为$k_d$（单位：$\\text{time}^{-1}$）。\n\n假设$k_b > 0$，$k_d > 0$，且$n$是有限非负整数。仅使用化学主方程 (CME) 的第一性原理以及在充分混合的质量作用動力学下将倾向性函数定义为风险率的定义，考虑随机模拟算法 (SSA) 的单一步骤。定义反应索引$J \\in \\{1,2\\}$，其中$J=1$表示转录事件，$J=2$表示降解事件，并令$\\tau$为到下一个事件的等待时间。\n\n从第一性原理出发，推导下一个 SSA 步骤的条件期望等待时间$\\mathbb{E}[\\tau \\mid n]$和条件期望反应索引$\\mathbb{E}[J \\mid n]$的表达式，这些表达式应是$k_b$，$k_d$和$n$的函数。您的推导必须从 CME 对倾向性函数作为风险率的解释开始，并且不得在未加推导的情况下假定任何特定的 SSA 公式。\n\n将您的最终答案表示为闭合形式的单个行向量$\\left(\\mathbb{E}[\\tau \\mid n],\\, \\mathbb{E}[J \\mid n]\\right)$。不需要数值近似，最终答案中不应包含单位。", "solution": "所述问题具有科学依据，提法恰当且客观。这是随机化学动力学中的一个标准练习。我们将按要求从第一性原理开始推导。\n\n系统由两个化学反应定义：\n1.  转录：$\\varnothing \\xrightarrow{k_b} \\text{mRNA}$\n2.  降解：$\\text{mRNA} \\xrightarrow{k_d} \\varnothing$\n\n在时间 $t$，系统的状态是 mRNA 分子的数量 $n$。系统的演化由这两个反应的倾向性函数决定。对于反应 $j$ 的倾向性函数 $a_j(n)$ 表示在系统处于状态 $n$ 的条件下该反应发生的风险率。对于充分混合的质量作用动力学系统，倾向性函数定义如下：\n\n对于反应1，转录，其速率与 mRNA 分子数 $n$ 无关。这是一个零级反应。其倾向性函数等于随机速率常数 $k_b$。\n$$ a_1(n) = k_b $$\n对于反应2，降解，其速率与 mRNA 分子数 $n$ 成正比。这是一个一级反应。其倾向性函数是一级速率常数 $k_d$ 与分子数的乘积。\n$$ a_2(n) = k_d n $$\n总倾向性函数，即*任何*反应发生的风险率，是各个倾向性函数之和。\n$$ a_0(n) = a_1(n) + a_2(n) = k_b + k_d n $$\n随机模拟算法 (SSA) 的基础是：到下一个反应发生的时间 $\\tau$ 是一个连续随机变量，而下一个反应的索引 $J$ 是一个离散随机变量。我们必须在给定当前状态 $n$ 的条件下推导它们的条件期望。\n\n令 $\\tau_j$ 为反应 $j$ 下一次发生的等待时间。在 CME 框架下，每个反应通道都是一个独立的泊松过程。因此，每个反应的等待时间是一个独立的、呈指数分布的随机变量，其速率参数等于其倾向性函数。$\\tau_j$ 的概率密度函数 (PDF) 为 $f_j(t) = a_j(n) \\exp(-a_j(n) t)$，其中 $t \\ge 0$。\n\n到下一个事件的等待时间 $\\tau$ 是所有可能反应的等待时间中的最小值。\n$$ \\tau = \\min(\\tau_1, \\tau_2) $$\n$\\tau$ 的累积分布函数 (CDF) 是 $F_\\tau(t) = P(\\tau \\le t)$。更简单的方法是首先找到生存函数 $S_\\tau(t) = P(\\tau  t)$。\n$$ P(\\tau  t) = P(\\min(\\tau_1, \\tau_2)  t) = P(\\tau_1  t \\text{ and } \\tau_2  t) $$\n由于反应通道的独立性，我们有：\n$$ P(\\tau  t) = P(\\tau_1  t) P(\\tau_2  t) $$\n对于速率为 $\\lambda$ 的指数分布，其生存函数为 $P(T  t) = \\exp(-\\lambda t)$。因此：\n$$ P(\\tau  t) = \\exp(-a_1(n) t) \\exp(-a_2(n) t) = \\exp(-(a_1(n) + a_2(n)) t) = \\exp(-a_0(n) t) $$\n这是一个速率参数为 $a_0(n) = k_b + k_d n$ 的指数分布的生存函数。速率为 $\\lambda$ 的指数随机变量的期望值为 $1/\\lambda$。因此，条件期望等待时间 $\\mathbb{E}[\\tau \\mid n]$ 为：\n$$ \\mathbb{E}[\\tau \\mid n] = \\frac{1}{a_0(n)} = \\frac{1}{k_b + k_d n} $$\n这就完成了第一个量的推导。\n\n接下来，我们推导反应索引的条件期望 $\\mathbb{E}[J \\mid n]$。随机变量 $J$ 可以取值 1 或 2。下一个反应是反应 $j$ 的概率 $P(J=j \\mid n)$，是指该反应的等待时间 $\\tau_j$ 小于或等于所有其他反应的等待时间的概率。对于我们的双反应系统，我们需要求出 $P(J=1 \\mid n)$ 和 $P(J=2 \\mid n)$。\n\n我们来计算 $P(J=1 \\mid n) = P(\\tau_1 \\le \\tau_2)$。我们可以通过对 $\\tau_1$ 发生的所有可能时间 $t$ 进行积分来计算这个概率，被积函数是在时刻 $t$ $\\tau_1$ 发生的概率密度与 $\\tau_2$ 到时刻 $t$ 仍未发生的概率的乘积。\n$$ P(\\tau_1 \\le \\tau_2) = \\int_0^\\infty P(\\tau_1=t, \\tau_2 \\ge t) dt = \\int_0^\\infty f_1(t) P(\\tau_2  t) dt $$\n其中 $f_1(t)$ 是 $\\tau_1$ 的概率密度函数。\n$$ P(J=1 \\mid n) = \\int_0^\\infty \\left( a_1(n) \\exp(-a_1(n) t) \\right) \\left( \\exp(-a_2(n) t) \\right) dt $$\n$$ P(J=1 \\mid n) = a_1(n) \\int_0^\\infty \\exp(-(a_1(n) + a_2(n)) t) dt $$\n$$ P(J=1 \\mid n) = a_1(n) \\left[ \\frac{-\\exp(-(a_1(n) + a_2(n)) t)}{a_1(n) + a_2(n)} \\right]_0^\\infty $$\n$$ P(J=1 \\mid n) = a_1(n) \\left( 0 - \\left( \\frac{-1}{a_1(n) + a_2(n)} \\right) \\right) = \\frac{a_1(n)}{a_1(n) + a_2(n)} = \\frac{a_1(n)}{a_0(n)} $$\n代入倾向性函数的表达式：\n$$ P(J=1 \\mid n) = \\frac{k_b}{k_b + k_d n} $$\n由于只有两个反应，它们的概率之和必须为 1。\n$$ P(J=2 \\mid n) = 1 - P(J=1 \\mid n) = 1 - \\frac{k_b}{k_b + k_d n} = \\frac{k_b + k_d n - k_b}{k_b + k_d n} = \\frac{k_d n}{k_b + k_d n} $$\n这与通用公式 $P(J=j \\mid n) = a_j(n)/a_0(n)$ 一致。\n\n现在我们根据定义计算反应索引 $J$ 的条件期望值：\n$$ \\mathbb{E}[J \\mid n] = \\sum_{j \\in \\{1,2\\}} j \\cdot P(J=j \\mid n) $$\n$$ \\mathbb{E}[J \\mid n] = 1 \\cdot P(J=1 \\mid n) + 2 \\cdot P(J=2 \\mid n) $$\n$$ \\mathbb{E}[J \\mid n] = 1 \\cdot \\left( \\frac{k_b}{k_b + k_d n} \\right) + 2 \\cdot \\left( \\frac{k_d n}{k_b + k_d n} \\right) $$\n$$ \\mathbb{E}[J \\mid n] = \\frac{k_b + 2 k_d n}{k_b + k_d n} $$\n这就完成了第二个量的推导。\n\n最终答案是包含两个推导出的条件期望值的行向量。", "answer": "$$ \\boxed{\\left( \\frac{1}{k_b + k_d n}, \\frac{k_b + 2 k_d n}{k_b + k_d n} \\right)} $$", "id": "2777186"}, {"introduction": "在掌握了理论基础之后，下一步是将这些原理转化为一个可以工作的计算机模拟程序。我们将从合成生物学中最常见的基序之一——一个能够抑制自身表达的基因——开始。本练习要求您用代码实现Gillespie直接法，为这个负自动调控回路定义物种、反应和倾向性函数。完成这项练习 ([@problem_id:2956741]) 将使您获得一个可复用的随机模拟代码库，这是为生物系统中的噪声和异质性建模的一项核心技能。", "problem": "您需要编写一个完整的程序，以实现用于一个自调控基因的随机模拟算法（Stochastic Simulation Algorithm, SSA；也称为 Gillespie 直接法）。该基因通过蛋白质与其启动子结合来抑制其自身的表达。该模型包含一个单一的启动子，其具有两种互斥的状态（未结合态和结合态），以及单一的蛋白质种类。系统被假设为充分混合的，分子数量为整数值，且时间是连续的。要求计算的量是对于一小组测试参数配置，在指定的结束时间下的最终蛋白质拷贝数。\n\n使用以下基本原理来构建数学模型和算法：\n- 化学主方程下的随机质量作用动力学：对于单分子反应，倾向（反应风险）为 $a = c \\cdot X$，其中 $c$ 是随机速率常数，$X$ 是反应物的当前数量。对于不同种类之间的双分子反应，倾向为 $a = c \\cdot X \\cdot Y$，其中 $X$ 和 $Y$ 是当前的数量。对于由一个启动子状态变量（表示为处于该状态的启动子数量）门控的零级合成，倾向为 $a = c \\cdot S$，其中 $S \\in \\{0,1\\}$ 是启动子状态指示符。\n- SSA直接法动力学：如果当前倾向为 $\\{a_r\\}_{r=1}^R$，总倾向为 $a_0 = \\sum_{r=1}^R a_r$，那么到下一次反应的等待时间是一个均值为 $1/a_0$ 的指数分布随机变量，并且下一个反应的索引以概率 $a_r/a_0$ 被抽样。\n\n模型规格：\n- 物种：未结合的启动子 $U$，结合的启动子 $B$，蛋白质 $P$。启动子以单拷贝形式存在，因此 $U+B = 1$ 必须始终成立。\n- 反应（状态变化效应显示在右侧）：\n  1. 从未結合的启动子合成：$U \\rightarrow U + P$ (蛋白质数量增加 $+1$；$U$ 不变)。\n  2. 从结合的启动子泄漏合成：$B \\rightarrow B + P$ (蛋白质数量增加 $+1$；$B$ 不变)。\n  3. 蛋白质降解：$P \\rightarrow \\varnothing$ (蛋白质数量减少 $-1$）。\n  4. 自调控结合：$U + P \\rightarrow B$ (蛋白质数量减少 $-1$；$U$ 减少 $-1$；$B$ 增加 $+1$）。\n  5. 解离：$B \\rightarrow U + P$ (蛋白质数量增加 $+1$；$B$ 减少 $-1$；$U$ 增加 $+1$）。\n\n您的程序必须：\n- 使用上述随机质量作用规则，推导并实现反应倾向。不要假定任何确定性近似。\n- 实现 Gillespie 直接法，从指定的初始数量开始模拟轨迹，直到指定的结束时间 $T_{\\text{end}}$。如果在任何步骤中总倾向 $a_0$ 变为 $0$，则系统处于吸收态，模拟必须立即停止。\n- 使用一个伪随机数生成器，并为了可复现性对其进行确定性初始化，具体如下：定义一个基础种子 $314159$，对于索引从零开始的第 $i$ 个测试用例，使用种子 $314159 + i$ 初始化该模拟的生成器。\n- 对于每个测试用例，以整数形式输出最终的蛋白质数量 $P(T_{\\text{end}})$。\n\n测试套件：\n为以下四组参数集提供结果。对于每个用例，初始状态和参数如下：\n- 用例 $0$ (正常路径，中等强度自抑制)：\n  - 初始数量：$U_0 = 1, B_0 = 0, P_0 = 5$。\n  - 速率：$k_{\\text{synth}} = 1.0, k_{\\text{leak}} = 0.05, k_{\\text{deg}} = 0.1, k_{\\text{on}} = 0.02, k_{\\text{off}} = 0.5$。\n  - 结束时间：$T_{\\text{end}} = 200.0$。\n- 用例 $1$ (边界条件，无抑制)：\n  - 初始数量：$U_0 = 1, B_0 = 0, P_0 = 0$。\n  - 速率：$k_{\\text{synth}} = 1.0, k_{\\text{leak}} = 0.0, k_{\\text{deg}} = 0.1, k_{\\text{on}} = 0.0, k_{\\text{off}} = 0.0$。\n  - 结束时间：$T_{\\text{end}} = 100.0$。\n- 用例 $2$ (边缘用例，通过快速结合和慢速解离实现强抑制)：\n  - 初始数量：$U_0 = 1, B_0 = 0, P_0 = 10$。\n  - 速率：$k_{\\text{synth}} = 1.0, k_{\\text{leak}} = 0.0, k_{\\text{deg}} = 0.1, k_{\\text{on}} = 0.5, k_{\\text{off}} = 0.001$。\n  - 结束时间：$T_{\\text{end}} = 200.0$。\n- 用例 $3$ (边缘用例，零时间边界)：\n  - 初始数量：$U_0 = 1, B_0 = 0, P_0 = 7$。\n  - 速率：$k_{\\text{synth}} = 1.5, k_{\\text{leak}} = 0.2, k_{\\text{deg}} = 0.2, k_{\\text{on}} = 0.03, k_{\\text{off}} = 0.2$。\n  - 结束时间：$T_{\\text{end}} = 0.0$。\n\n答案规格：\n- 您的程序必须生成单行输出，其中按顺序包含用例 0 到 3 的最终蛋白质数量，形式为用逗号分隔的列表，并用方括号括起来，不含空格，例如 $[x_0,x_1,x_2,x_3]$，其中每个 $x_i$ 是用例 $i$ 的 $P(T_{\\text{end}})$ 的整数值。\n- 输出中不需要物理单位；分子数量是无单位的整数；时间是任意单位的抽象连续变量。不使用角度。不使用百分比。", "solution": "对问题陈述进行了严格评估，并确认其有效性。它提出了计算系统生物学中一个明确定义的任务：对一个经典的基因自调控网络进行随机模拟。该模型基于已确立的化学动力学原理，指定的算法（Gillespie 的随机模拟算法，或 SSA）是此类问题的标准方法，并且所有参数和初始条件都已明确提供。该问题具有科学依据，定义明确且客观。\n\n系统状态可以由蛋白质分子数 $P$ 和单个基因启动子的状态完全指定。启动子可以处于未结合态（用状态 $U$ 表示）或结合态（用状态 $B$ 表示）。由于只有一个启动子，其状态是互斥的，满足未结合启动子数量与结合启动子数量之和始终为一的约束。我们可以用一个二进制变量来表示这个启动子状态，我们同样将其记为 $U$，其中当启动子未结合时 $U=1$，当其结合时 $U=0$。因此，结合态启动子的状态为 $B = 1 - U$。所以，任意时刻 $t$ 的完整系统状态由向量 $X(t) = [P(t), U(t)]$ 描述。\n\n问题定义了五个反应通道。我们必须首先为每个反应 $j \\in \\{1, 2, 3, 4, 5\\}$ 构建倾向函数 $a_j(X)$。倾向是反应速率的随机等价物，表示单位时间内发生某个反应的概率。遵循所提供的随机质量作用动力学规则：\n\n1.  **从未结合的启动子合成 ($U \\rightarrow U + P$)**：这是一个零级合成过程，由启动子处于未结合态 $U$ 所门控。倾向与速率常数 $k_{\\text{synth}}$ 和未结合态的指示变量成正比。\n    $$a_1 = k_{\\text{synth}} \\cdot U$$\n2.  **从结合的启动子泄漏合成 ($B \\rightarrow B + P$)**：类似地，这是一个门控的零级过程，在启动子处于结合态（$B=1$，或 $U=0$）时发生。\n    $$a_2 = k_{\\text{leak}} \\cdot B = k_{\\text{leak}} \\cdot (1 - U)$$\n3.  **蛋白质降解 ($P \\rightarrow \\varnothing$)**：这是一个单分子衰变过程。倾向与速率常数 $k_{\\text{deg}}$ 和蛋白质分子数 $P$ 成正比。\n    $$a_3 = k_{\\text{deg}} \\cdot P$$\n4.  **自调控结合 ($U + P \\rightarrow B$)**：这是一个蛋白质分子 $P$ 和未结合的启动子位点 $U$ 之间的双分子反应。倾向与速率常数 $k_{\\text{on}}$、蛋白质分子数 $P$ 和启动子状态 $U$ 成正比。如果启动子已经结合（$U=0$），这个反应就不会发生。\n    $$a_4 = k_{\\text{on}} \\cdot U \\cdot P$$\n5.  **解离 ($B \\rightarrow U + P$)**：这是一个蛋白质从启动子上解离的单分子过程。倾向与速率常数 $k_{\\text{off}}$ 和启动子处于结合态（$B=1$，或 $U=0$）的状态成正比。\n    $$a_5 = k_{\\text{off}} \\cdot B = k_{\\text{off}} \\cdot (1 - U)$$\n\n每个反应对状态向量 $X = [P, U]$ 的影响由状态变化向量 $\\nu_j$ 捕捉：\n-   $R_1$: $\\nu_1 = [+1, 0]^T$ (创建一个蛋白质，启动子状态不变)。\n-   $R_2$: $\\nu_2 = [+1, 0]^T$ (创建一个蛋白质，启动子状态不变)。\n-   $R_3$: $\\nu_3 = [-1, 0]^T$ (销毁一个蛋白质，启动子状态不变)。\n-   $R_4$: $\\nu_4 = [-1, -1]^T$ (消耗一个蛋白质，启动子状态从 $U=1$ 变为 $U=0$)。\n-   $R_5$: $\\nu_5 = [+1, +1]^T$ (创建一个蛋白质，启动子状态从 $U=0$ 变为 $U=1$)。\n\nGillespie 直接法模拟了这个随机系统的精确轨迹。算法流程如下：\n\n1.  **初始化**：设置当前时间 $t=0$。用给定的初始数量初始化状态向量 $X(0) = [P_0, U_0]$。确定模拟结束时间 $T_{\\text{end}}$。为保证可复现性，对伪随机数生成器（PRNG）进行播种。对于测试用例 $i$，种子为 $314159 + i$。\n\n2.  **迭代**：模拟在一个循环中进行，只要 $t  T_{\\text{end}}$，循环就继续。\n    a. **计算倾向**：在当前状态 $X(t)$ 下，计算所有五个倾向 $a_1, ..., a_5$。\n    b. **计算总倾向**：计算所有倾向的总和，$a_0 = \\sum_{j=1}^{5} a_j$。如果 $a_0 = 0$，则不会有更多反应发生。这是一个吸收态，模拟终止。\n    c. **抽样等待时间**：到下一次反应的时间 $\\tau$ 是一个速率为 $a_0$ 的指数分布随机变量。我们通过从均匀分布 $U(0,1)$ 中抽取一个随机数 $r_1$ 来抽样 $\\tau$，并计算：\n       $$\\tau = \\frac{1}{a_0} \\ln\\left(\\frac{1}{r_1}\\right)$$\n    d. **检查结束时间**：在更新之前，我们检查下一个事件是否发生在指定的结束时间之后。如果 $t + \\tau \\geq T_{\\text{end}}$，模拟结束。系统在 $T_{\\text{end}}$ 的状态被视为在时间 $t$ 的状态，并且循环终止。\n    e. **抽样下一个反应**：将要发生的下一个反应的索引 $\\mu$ 是以概率 $P(\\mu=j) = a_j/a_0$ 选择的。这是通过抽取第二个随机数 $r_2 \\sim U(0,1)$ 并找到满足以下条件的最小整数 $\\mu$ 来完成的：\n       $$\\sum_{j=1}^{\\mu} a_j > r_2 \\cdot a_0$$\n    f. **更新状态和时间**：系统时间前进 $\\tau$，因此 $t \\leftarrow t + \\tau$。状态向量根据所选的反应 $\\mu$ 进行更新：$X \\leftarrow X + \\nu_{\\mu}$。\n\n3.  **终止**：当循环终止时（无论是由于 $t \\geq T_{\\text{end}}$ 还是 $a_0 = 0$），最终的蛋白质数量 $P$ 被记录为给定测试用例的结果。对于 $T_{\\text{end}} = 0$ 的特殊情况，循环条件立即为假，并返回初始蛋白质数量 $P_0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_ssa_simulation(k_synth, k_leak, k_deg, k_on, k_off, P0, U0, T_end, seed):\n    \"\"\"\n    Implements the Gillespie direct method for a gene autoregulatory network.\n\n    Args:\n        k_synth (float): Synthesis rate from unbound promoter.\n        k_leak (float): Leaky synthesis rate from bound promoter.\n        k_deg (float): Protein degradation rate.\n        k_on (float): Protein-promoter binding rate.\n        k_off (float): Protein-promoter unbinding rate.\n        P0 (int): Initial protein count.\n        U0 (int): Initial promoter state (1=unbound, 0=bound).\n        T_end (float): Simulation end time.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        int: The final protein count at T_end.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    t = 0.0\n    P = P0\n    U = U0\n    \n    # Handle the edge case of T_end = 0.0\n    if T_end == 0.0:\n        return P\n\n    while t  T_end:\n        # 1. Calculate propensities for each reaction\n        # a1: Synthesis from unbound promoter (U -> U + P)\n        a1 = k_synth * U\n        # a2: Leaky synthesis from bound promoter (B -> B + P)\n        a2 = k_leak * (1 - U)\n        # a3: Protein degradation (P -> 0)\n        a3 = k_deg * P\n        # a4: Autoregulatory binding (U + P -> B)\n        a4 = k_on * U * P\n        # a5: Unbinding (B -> U + P)\n        a5 = k_off * (1 - U)\n\n        # 2. Calculate total propensity\n        a0 = a1 + a2 + a3 + a4 + a5\n\n        # If a0 is 0, the system is in an absorbing state, no more reactions can occur.\n        if a0 == 0.0:\n            break\n\n        # 3. Sample waiting time to the next reaction\n        r1 = rng.random()\n        tau = (1.0 / a0) * np.log(1.0 / r1)\n\n        # 4. Check if the next event is after T_end\n        if t + tau >= T_end:\n            break\n\n        # 5. Advance time\n        t += tau\n\n        # 6. Sample which reaction occurs\n        r2 = rng.random()\n        target = r2 * a0\n        \n        # Determine reaction index mu by checking cumulative propensities\n        if target  a1:\n            # Reaction 1: P -> P + 1\n            P += 1\n        elif target  a1 + a2:\n            # Reaction 2: P -> P + 1\n            P += 1\n        elif target  a1 + a2 + a3:\n            # Reaction 3: P -> P - 1\n            P -= 1\n        elif target  a1 + a2 + a3 + a4:\n            # Reaction 4: P -> P - 1, U -> 0\n            P -= 1\n            U = 0\n        else:\n            # Reaction 5: P -> P + 1, U -> 1\n            P += 1\n            U = 1\n\n    return P\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    base_seed = 314159\n\n    test_cases = [\n        # Case 0: happy path, moderate autorepression\n        {\"k_synth\": 1.0, \"k_leak\": 0.05, \"k_deg\": 0.1, \"k_on\": 0.02, \"k_off\": 0.5, \"P0\": 5, \"U0\": 1, \"T_end\": 200.0},\n        # Case 1: boundary condition, no repression\n        {\"k_synth\": 1.0, \"k_leak\": 0.0, \"k_deg\": 0.1, \"k_on\": 0.0, \"k_off\": 0.0, \"P0\": 0, \"U0\": 1, \"T_end\": 100.0},\n        # Case 2: edge case, strong repression\n        {\"k_synth\": 1.0, \"k_leak\": 0.0, \"k_deg\": 0.1, \"k_on\": 0.5, \"k_off\": 0.001, \"P0\": 10, \"U0\": 1, \"T_end\": 200.0},\n        # Case 3: edge case, zero-time boundary\n        {\"k_synth\": 1.5, \"k_leak\": 0.2, \"k_deg\": 0.2, \"k_on\": 0.03, \"k_off\": 0.2, \"P0\": 7, \"U0\": 1, \"T_end\": 0.0}\n    ]\n\n    results = []\n    for i, params in enumerate(test_cases):\n        seed = base_seed + i\n        final_P = run_ssa_simulation(\n            k_synth=params[\"k_synth\"],\n            k_leak=params[\"k_leak\"],\n            k_deg=params[\"k_deg\"],\n            k_on=params[\"k_on\"],\n            k_off=params[\"k_off\"],\n            P0=params[\"P0\"],\n            U0=params[\"U0\"],\n            T_end=params[\"T_end\"],\n            seed=seed\n        )\n        results.append(final_P)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2956741"}, {"introduction": "直接法是基础，但对于大型复杂的反应网络，其计算成本可能高得令人望而却步。幸运的是，存在其他几种统计上完全精确的算法，它们在特定场景下能显著提升性能。本练习旨在挑战您分析三种精确随机模拟算法（SSA）变体的计算复杂度：直接法、第一反应法和下一反应法，重点关注具有大量反应通道但每个事件仅影响少数通道（即稀疏更新）的系统。这种分析 ([@problem_id:2777102]) 对于在研究中选择合适的模拟算法至关重要，能帮助您为大规模合成或天然生物网络建模挑选最高效的工具。", "problem": "一个合成基因线路有一个启动子，由于各种转录因子和染色质重塑剂的结合与解离，该启动子有许多潜在的状态变化，从而产生一个具有$M$个反应通道的反应网络。在任何触发事件中，化学计量和依赖结构只会影响少数固定的$k$个倾向函数，其中$k \\ll M$（稀疏更新）。令$a_{\\mu}(x)$表示状态$x$下通道$\\mu \\in \\{1,\\dots,M\\}$的倾向，并令$a_{0}(x) = \\sum_{\\mu=1}^{M} a_{\\mu}(x)$。在化学主方程（CME）下，一个精确的轨迹是一个分段常数、右连续的跳跃过程，其中事件间的等待时间呈指数分布，风险率为$a_{0}(x)$，下一个反应的身份根据当前状态下的$a_{\\mu}(x)/a_{0}(x)$进行采样。考虑使用三种统计上精确的随机模拟算法（SSA）变体来模拟这些轨迹：直接法、第一反应法和下一反应法（Gibson–Bruck 风格），在适用时允许使用标准数据结构，如二叉树或二叉堆。\n\n以下哪个陈述正确地比较了这些方法在$M$很大且$k \\ll M$情况下的统计效率和每个事件的计算复杂度？\n\nA. 三种方法相对于CME都是统计上精确的（即，它们生成同分布的轨迹），但它们每个事件的计算成本不同：朴素的直接法每个事件产生$\\mathcal{O}(M)$的工作量，第一反应法每个事件产生$\\mathcal{O}(M)$的工作量并需要$\\mathcal{O}(M)$次随机抽样，而使用依赖图和二叉堆实现的下一反应法，通过重用未受影响通道的等待时间，每个事件的工作量达到$\\mathcal{O}(\\log M + k \\log M)$。\n\nB. 第一反应法比直接法在统计上更有效，因为它每步采样$\\mathcal{O}(M)$个指数时钟，所以在模拟事件数量固定的情况下，能产生方差更小的可观测量估计。\n\nC. 即使是稀疏更新，直接法也必须在每次事件后重新计算所有$\\mathcal{O}(M)$个倾向，因此即使使用辅助数据结构，其每个事件的成本也无法降低到$\\mathcal{O}(M)$以下。\n\nD. 下一反应法通过重用未受影响通道的假定触发时间来利用稀疏性；因此，当$k \\ll M$时，它避免了为$\\mathcal{O}(M)$个通道生成新的随机数和更新数据结构，从而导致渐近成本与$\\log M$加上更新$k$个受影响通道的工作量成比例。\n\nE. 使用部分和的二叉树（或别名表），直接法总能实现$\\mathcal{O}(\\log M)$的下一通道选择，并且每次事件后更新数据只需$\\mathcal{O}(k)$的工作量，因此无论数据结构如何维护，其每个事件的成本都严格为$\\mathcal{O}(\\log M + k)$。", "solution": "该问题要求对三种用于模拟由化学主方程（CME）控制的化学反应网络的统计精确随机模拟算法（SSA）进行分析和比较。具体背景是一个具有大量反应通道（$M$）的系统，但其中每个反应事件仅影响少数（$k$）其他通道的倾向函数，且 $k \\ll M$。要比较的算法是直接法（DM）、第一反应法（FRM）和下一反应法（NRM）。比较的依据是统计效率和每个模拟事件的计算复杂度。\n\n首先，我们分析这三种方法的基本性质。\n\n**1. 统计效率**\n所有三种方法——直接法、第一反应法和下一反应法——都被构建为“统计上精确”的。这意味着它们生成的随机轨迹 $(X(t))_{t \\ge 0}$ 的概率分布与CME定义的概率分布完全相同。因此，只要考虑相同数量的独立轨迹或总模拟时间，从这些方法生成的轨迹计算出的任何统计可观测量的期望、方差和高阶矩都将相同。因此，它们的统计效率是相同的。任何声称一种方法在统计上优于另一种（例如，在相同事件数下产生方差更小的估计量）的说法都是不正确的。\n\n**2. 每个事件的计算复杂度**\n\n令 $a_{\\mu}(x)$ 为状态 $x$ 下反应 $\\mu$ 的倾向，且 $a_0(x) = \\sum_{\\mu=1}^{M} a_{\\mu}(x)$。一个反应事件会改变状态，这反过来又会影响 $k$ 个通道的倾向。我们分析将模拟推进一个事件所需的计算工作量。\n\n**直接法 (DM)**\n直接法每个事件分两个阶段进行：确定下一个事件的时间 $\\tau = (1/a_0) \\ln(1/r_1)$，以及选择发生哪个反应。\n- **到下一个事件的时间：** 需要计算总倾向 $a_0$。在朴素实现中，这是一个 $\\mathcal{O}(M)$ 的求和。然而，鉴于只有 $k$ 个倾向发生变化，可以在 $\\mathcal{O}(k)$ 时间内从其先前的值更新 $a_0$。\n- **选择事件：** 使用一个随机数 $r_2 \\sim U(0,1)$ 来选择反应 $\\mu$，使得 $\\sum_{j=1}^{\\mu-1} a_j  r_2 a_0 \\leq \\sum_{j=1}^{\\mu} a_j$。\n    - 对 $\\mu$ 的朴素线性搜索平均需要 $\\mathcal{O}(M)$ 时间。这导致总复杂度为 $\\mathcal{O}(M)$。\n    - 优化的实现可以使用数据结构来加速搜索。一个存储倾向部分和的二叉树（“和树”）允许在 $\\mathcal{O}(\\log M)$ 时间内选择 $\\mu$。当一个反应发生时，必须更新 $k$ 个受影响的倾向。在大小为 $M$ 的平衡二叉树中，每次更新都需要遍历从叶节点到根节点的路径，成本为 $\\mathcal{O}(\\log M)$。因此，更新 $k$ 个倾向的成本为 $\\mathcal{O}(k \\log M)$。优化后的DM每个事件的总复杂度为 $\\mathcal{O}(\\log M + k \\log M) = \\mathcal{O}((k+1)\\log M)$。\n\n**第一反应法 (FRM)**\n第一反应法为 $M$ 个反应通道中的每一个生成一个假定触发时间 $\\tau_{\\mu} = (1/a_{\\mu}) \\ln(1/r_{\\mu})$，使用 $M$ 个独立的均匀分布随机数 $r_{\\mu}$。下一个事件是具有最小 $\\tau_{\\mu}$ 的那个。\n- 这需要生成 $M$ 个随机数并计算 $M$ 个对数，这是一个 $\\mathcal{O}(M)$ 的操作。\n- 找到 $M$ 个假定时间中的最小值是一个 $\\mathcal{O}(M)$ 的操作。\n- 事件发生后，状态改变，所有倾向都可能失效，因此必须丢弃并重新计算所有 $M$ 个假定时间。该方法没有利用更新的稀疏性（$k \\ll M$）。\n- 因此，总复杂度为 $\\mathcal{O}(M)$，并且每个事件需要 $\\mathcal{O}(M)$ 个随机数。\n\n**下一反应法 (NRM)** (Gibson–Bruck 风格)\nNRM 是 FRM 的一种优化，它避免了重新计算所有假定的触发时间。它将 $M$ 个假定时间 $\\tau_{\\mu}$ 存储在一个优先队列（通常是二叉堆）中。\n- **事件选择：** 通过从优先队列中提取最小元素来找到下一个事件，这需要 $\\mathcal{O}(\\log M)$ 的成本。\n- **更新：** 事件触发后，状态改变。使用预先计算的依赖图，识别出倾向受影响的 $k$ 个通道。对于这 $k$ 个通道，计算新的假定时间，并更新它们在优先队列中的位置。堆中的每次更新成本为 $\\mathcal{O}(\\log M)$。更新的总成本为 $\\mathcal{O}(k \\log M)$。\n- 关键的见解是，由于指数分布的无记忆性，未受影响的 $M-k$ 个通道的假定触发时间仍然有效，不需要重新计算或改变它们在堆中的位置。因此，NRM 有效地利用了依赖图的稀疏性。\n- 每个事件的总复杂度是提取成本和更新成本的总和：$\\mathcal{O}(\\log M + k \\log M) = \\mathcal{O}((k+1)\\log M)$。此方法每步仅需要少量新的随机数（最多 $k$ 个）。\n\n现在我们根据这个分析来评估每个选项。\n\n**A. 三种方法相对于CME都是统计上精确的（即，它们生成同分布的轨迹），但它们每个事件的计算成本不同：朴素的直接法每个事件产生 $\\mathcal{O}(M)$ 的工作量，第一反应法每个事件产生 $\\mathcal{O}(M)$ 的工作量并需要 $\\mathcal{O}(M)$ 次随机抽样，而使用依赖图和二叉堆实现的下一反应法，通过重用未受影响通道的等待时间，每个事件的工作量达到 $\\mathcal{O}(\\log M + k \\log M)$。**\n- 所有三种方法都是统计上精确的这一说法是正确的。\n- 朴素DM的复杂度确实是 $\\mathcal{O}(M)$。\n- FRM的复杂度和随机数需求被正确地表述为 $\\mathcal{O}(M)$。\n- 带有二叉堆和依赖图的NRM的复杂度被正确地给出为 $\\mathcal{O}(\\log M + k \\log M)$。这种效率的原因（重用/不更新未受影响通道的时间）也得到了正确的识别。\n这个陈述是一个完整而准确的比较。\n结论：**正确**。\n\n**B. 第一反应法比直接法在统计上更有效，因为它每步采样 $\\mathcal{O}(M)$ 个指数时钟，所以在模拟事件数量固定的情况下，能产生方差更小的可观测量估计。**\n如前所述，所有三种方法都是统计上精确的。它们从相同的底层概率分布中采样。内部生成的随机变量数量是计算成本问题，而不是统计效率问题。在固定的模拟事件数下，一种方法不能比另一种方法产生方差更小的估计量。\n结论：**不正确**。\n\n**C. 即使是稀疏更新，直接法也必须在每次事件后重新计算所有 $\\mathcal{O}(M)$ 个倾向，因此即使使用辅助数据结构，其每个事件的成本也无法降低到 $\\mathcal{O}(M)$ 以下。**\n这是错误的。首先，对于稀疏更新，只需要重新计算 $k$ 个倾向，而不是全部 $M$ 个。其次，更关键的是，使用像和树这样的辅助数据结构将事件选择步骤的成本从 $\\mathcal{O}(M)$ 降低到 $\\mathcal{O}(\\log M)$，并将更新步骤的成本降低到 $\\mathcal{O}(k \\log M)$。因此，总成本可以降低到 $\\mathcal{O}((k+1)\\log M)$，当 $k \\ll M$ 时，这比 $\\mathcal{O}(M)$ 好得多。\n结论：**不正确**。\n\n**D. 下一反应法通过重用未受影响通道的假定触发时间来利用稀疏性；因此，当 $k \\ll M$ 时，它避免了为 $\\mathcal{O}(M)$ 个通道生成新的随机数和更新数据结构，从而导致渐近成本与 $\\log M$ 加上更新 $k$ 个受影响通道的工作量成比例。**\n这个陈述准确地描述了NRM的运作原理。其效率源于只关注 $k$ 个受影响的通道，而保持其他 $M-k$ 个通道不变。它正确地指出，这避免了大量的随机数生成和数据结构更新。对渐近成本的描述在概念上也是正确的：成本是提取下一个事件的成本（对于堆是 $\\mathcal{O}(\\log M)$）和更新 $k$ 个受影响通道的工作量（对于堆是 $\\mathcal{O}(k \\log M)$）的总和。该陈述完全是事实。\n结论：**正确**。\n\n**E. 使用部分和的二叉树（或别名表），直接法总能实现 $\\mathcal{O}(\\log M)$ 的下一通道选择，并且每次事件后更新数据只需 $\\mathcal{O}(k)$ 的工作量，因此无论数据结构如何维护，其每个事件的成本都严格为 $\\mathcal{O}(\\log M + k)$。**\n声称二叉树允许 $\\mathcal{O}(\\log M)$ 的选择是正确的。然而，声称更新 $k$ 个变化的倾向的数据只需要 $\\mathcal{O}(k)$ 的工作量是不正确的。对和树中一个叶节点的 $k$ 次更新中的每一次，都需要更新直到根节点的 $\\mathcal{O}(\\log M)$ 个节点。因此，总更新成本是 $\\mathcal{O}(k \\log M)$。最终的每个事件成本是 $\\mathcal{O}(\\log M + k \\log M)$，而不是 $\\mathcal{O}(\\log M + k)$。别名法通常具有更高的更新成本（通常是 $\\mathcal{O}(M)$ 重建），并且不适合频繁的稀疏更新。\n结论：**不正确**。\n\n根据分析，陈述A和D都是正确的。", "answer": "$$\\boxed{AD}$$", "id": "2777102"}]}