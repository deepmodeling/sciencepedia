{"hands_on_practices": [{"introduction": "设计微生物群落的第一步是理解其成员间的代谢相互作用。流平衡分析（Flux Balance Analysis, FBA）是模拟这些相互作用的强大框架。该实践将指导你为一个简单的双菌群落构建一个联合FBA模型，练习如何对共享资源和交叉哺养进行建模，并探索不同生长权重下的帕累托最优解，这对于理解群落内部的合作与竞争关系至关重要。[@problem_id:2728301]", "problem": "您的任务是为一个交换一种交叉补给代谢物的最小双生物体合成群落，构建并求解一个联合通量平衡分析（FBA）优化问题。目标是通过最大化指定权重下生物体生长速率的加权和来计算帕累托最优操作点。您的实现必须从第一性原理出发，对线性优化问题进行编码，并针对给定的测试套件进行求解。\n\n建模假设和基本依据：\n- 采用FBA中的稳态代谢平衡：内部代谢物累积为零，这意味着对于一个合适的化学计量矩阵 $S$ 和通量向量 $v$，存在线性约束 $S v = 0$。\n- 每个反应通量都受线性上下界的限制。\n- 联合目标是两个生长速率的加权和。在可行集为凸集的情况下，一个在不同权重下最大化加权和的解是帕累托最优的。\n\n群落描述：\n- 生物体 A 从一个充分混合的培养基中输入共享的外部底物 $G$（葡萄糖），并将其分配用于生物质生产和分泌交叉补给代谢物 $X$。\n- 生物体 B 直接输入 $G$ 或输入由 A 产生的 $X$，并将两者之一转化为生物质。\n- 两种生物体都满足内部稳态平衡。\n- $G$ 的交换受到两种生物体共享的上限约束。\n- $X$ 的交换受到共享的稳态等式和交换能力的上限约束。\n\n决策变量（均为非负通量）：\n- $v_{\\mathrm{A,inG}}$：A对 $G$ 的输入。\n- $\\mu_{\\mathrm{A}}$：A的生物质生产速率（生长速率，单位为 $\\mathrm{h^{-1}}$）。\n- $v_{\\mathrm{A,prodX}}$：A从内化的 $G$ 生产 $X$。\n- $v_{\\mathrm{A,outX}}$：A向培养基输出 $X$。\n- $v_{\\mathrm{B,inG}}$：B对 $G$ 的输入。\n- $v_{\\mathrm{B,inX}}$：B从培养基输入 $X$。\n- $\\mu_{\\mathrm{B,G}}$：B从 $G$ 得到的生物质生产速率。\n- $\\mu_{\\mathrm{B,X}}$：B从 $X$ 得到的生物质生产速率。\n\n稳态和交换约束：\n- A的内部 $G$ 平衡：$v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$。\n- A的内部 $X$ 平衡：$v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$。\n- B的内部 $G$ 平衡：$v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$。\n- B的内部 $X$ 平衡：$v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$。\n- 外部 $X$ 稳态：$v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$。\n- 共享 $G$ 容量：$v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max}$。\n\n通量界限：\n- $0 \\le v_{\\mathrm{A,inG}} \\le A_{G,\\max}$，$0 \\le v_{\\mathrm{B,inG}} \\le B_{G,\\max}$，$0 \\le v_{\\mathrm{A,outX}} \\le X_{\\max}$，$0 \\le v_{\\mathrm{B,inX}} \\le X_{\\max}$。\n- $0 \\le \\mu_{\\mathrm{A}}$，$0 \\le v_{\\mathrm{A,prodX}}$，$0 \\le \\mu_{\\mathrm{B,G}}$，$0 \\le \\mu_{\\mathrm{B,X}}$。\n- 使用常数 $c_{\\mathrm{A,bio}} = 1.2$，$c_{\\mathrm{A,X}} = 1.0$，这表示 A 每单位生物质需要 $1.2$ 单位内化的 $G$，每生产一单位 $X$ 需要 $1.0$ 单位内化的 $G$。对于 B，如上述平衡所示，一单位 $G$ 或 $X$ 产生一单位生物质。\n\n目标：\n- 对于给定的权重 $w \\in [0,1]$，最大化加权和 $w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}}$，其中 $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$。\n\n除非另有说明，所有测试用例的固定参数：\n- $A_{G,\\max} = 10$。\n- $B_{G,\\max} = 3$。\n- $c_{\\mathrm{A,bio}} = 1.2$。\n- $c_{\\mathrm{A,X}} = 1.0$。\n\n角度单位不适用。物理单位：以浮点数形式报告生长速率，单位为 $\\mathrm{h^{-1}}$。\n\n测试套件：\n每个测试用例是一个三元组 $(w, G_{\\max}, X_{\\max})$。对于每个用例，计算并输出数值对 $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$，其中 $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}}$，两者都四舍五入到 $6$ 位小数，单位为 $\\mathrm{h^{-1}}$。\n\n- 用例 $1$：$(w, G_{\\max}, X_{\\max}) = (0.25, 10, 7)$。\n- 用例 $2$：$(w, G_{\\max}, X_{\\max}) = (1.0, 10, 10)$。\n- 用例 $3$：$(w, G_{\\max}, X_{\\max}) = (0.0, 10, 10)$。\n- 用例 $4$：$(w, G_{\\max}, X_{\\max}) = (0.7, 10, 10)$。\n- 用例 $5$：$(w, G_{\\max}, X_{\\max}) = (0.6, 5, 10)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个双元素列表 $[\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B}}]$，按顺序对应上述测试用例。例如：$[[x_{1},y_{1}],[x_{2},y_{2}],\\dots]$。输出中不得有任何空格。所有报告的生长速率必须四舍五入到 $6$ 位小数，单位为 $\\mathrm{h^{-1}}$。", "solution": "所述问题是有效的。它提出了一个适定的优化问题，该问题基于已建立的代谢网络通量平衡分析（FBA）原理。该问题是自洽的，所有必要的参数、变量和约束都已明确定义，从而可以进行严谨无歧义的数学公式化。目标是找到一个合成微生物群落的帕累托最优状态，这是系统生物学和合成生物学中一个标准且有意义的目标。该问题被构建为一个线性规划（LP），保证存在唯一的最优值。\n\n任务的核心是构建并求解此LP。该系统涉及两个生物体 A 和 B，以及两种代谢物：主要底物 $G$ 和交叉补给的中间产物 $X$。系统的状态由一组 $8$ 个非负通量描述：$v_{\\mathrm{A,inG}}$, $\\mu_{\\mathrm{A}}$, $v_{\\mathrm{A,prodX}}$, $v_{\\mathrm{A,outX}}$, $v_{\\mathrm{B,inG}}$, $v_{\\mathrm{B,inX}}$, $\\mu_{\\mathrm{B,G}}$, 和 $\\mu_{\\mathrm{B,X}}$。\n\n首先，我们通过求解等式约束来简化系统。问题陈述提供了五个代表稳态质量平衡的线性等式约束：\n$1$. $v_{\\mathrm{A,inG}} - c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} - c_{\\mathrm{A,X}} \\, v_{\\mathrm{A,prodX}} = 0$\n$2$. $v_{\\mathrm{A,prodX}} - v_{\\mathrm{A,outX}} = 0$\n$3$. $v_{\\mathrm{B,inG}} - \\mu_{\\mathrm{B,G}} = 0$\n$4$. $v_{\\mathrm{B,inX}} - \\mu_{\\mathrm{B,X}} = 0$\n$5$. $v_{\\mathrm{A,outX}} - v_{\\mathrm{B,inX}} = 0$\n\n从约束 $2$、$4$ 和 $5$，我们推断出代谢物 $X$ 从 A 的产生到 B 的消耗的通量是一个单一、统一的通道：\n$$v_{X} \\equiv v_{\\mathrm{A,prodX}} = v_{\\mathrm{A,outX}} = v_{\\mathrm{B,inX}} = \\mu_{\\mathrm{B,X}}$$\n从约束 $3$，生物体 B 由底物 $G$ 产生的生物质等于其对 $G$ 的输入通量：\n$$\\mu_{\\mathrm{B,G}} = v_{\\mathrm{B,inG}}$$\n使用这些关系，我们可以消去大部分变量。我们选择一个最小的独立决策变量集合，包含三个变量：\n- $\\mu_{\\mathrm{A}}$: 生物体 A 的生长速率。\n- $\\mu_{\\mathrm{B,G}}$: 生物体 B 源自底物 $G$ 的生长速率分量。\n- $v_{X}$: 交叉补给代谢物 $X$ 的通量，也等于生物体 B 源自 $X$ 的生长速率分量 $\\mu_{\\mathrm{B,X}}$。\n\n所有其他通量变量现在都可以用这个新基底表示：\n- $v_{\\mathrm{A,inG}} = c_{\\mathrm{A,bio}} \\, \\mu_{\\mathrm{A}} + c_{\\mathrm{A,X}} \\, v_{X} = 1.2 \\, \\mu_{\\mathrm{A}} + 1.0 \\, v_{X}$\n- $v_{\\mathrm{B,inG}} = \\mu_{\\mathrm{B,G}}$\n- $\\mu_{\\mathrm{B}} = \\mu_{\\mathrm{B,G}} + \\mu_{\\mathrm{B,X}} = \\mu_{\\mathrm{B,G}} + v_{X}$\n\n现在，该问题被公式化为一个包含这三个变量的线性规划。目标是最大化生长速率的加权和：\n$$\\text{Maximize} \\quad J = w \\, \\mu_{\\mathrm{A}} + (1 - w) \\, \\mu_{\\mathrm{B}} = w \\, \\mu_{\\mathrm{A}} + (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\n受一组由通量界限和共享资源限制产生的线性不等式约束。所有变量必须为非负：$\\mu_{\\mathrm{A}} \\ge 0$, $\\mu_{\\mathrm{B,G}} \\ge 0$, $v_{X} \\ge 0$。\n\n不等式约束为：\n$1$. A的葡萄糖输入限制：$v_{\\mathrm{A,inG}} \\le A_{G,\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} \\le 10$\n$2$. B的葡萄糖输入限制：$v_{\\mathrm{B,inG}} \\le B_{G,\\max} \\implies \\mu_{\\mathrm{B,G}} \\le 3$\n$3$. 代谢物 $X$ 交换限制：$v_{X} \\le X_{\\max}$\n$4$. 共享葡萄糖可用性：$v_{\\mathrm{A,inG}} + v_{\\mathrm{B,inG}} \\le G_{\\max} \\implies 1.2\\,\\mu_{\\mathrm{A}} + v_{X} + \\mu_{\\mathrm{B,G}} \\le G_{\\max}$\n\n这构成了一个标准LP问题，形式为：最大化 $c^T x$，约束条件为 $A_{ub} x \\le b_{ub}$ 和 $x \\ge 0$。这里，决策变量向量是 $x = [\\mu_{\\mathrm{A}}, \\mu_{\\mathrm{B,G}}, v_{X}]^T$。目标向量是 $c = [w, 1-w, 1-w]^T$。约束矩阵 $A_{ub}$ 和向量 $b_{ub}$ 是：\n$$\nA_{ub} = \\begin{pmatrix} 1.2  0  1.0 \\\\ 0  1.0  0 \\\\ 0  0  1.0 \\\\ 1.2  1.0  1.0 \\end{pmatrix}, \\quad\nb_{ub} = \\begin{pmatrix} 10 \\\\ 3 \\\\ X_{\\max} \\\\ G_{\\max} \\end{pmatrix}\n$$\nPython中的科学计算库，特别是 `scipy.optimize.linprog`，被设计用来解决最小化问题。因此，我们求解等价的最小化 $-J$ 的问题：\n$$\\text{Minimize} \\quad -J = -w \\, \\mu_{\\mathrm{A}} - (1 - w) (\\mu_{\\mathrm{B,G}} + v_{X})$$\n用于求解器的成本向量是 $c_{min} = [-w, -(1-w), -(1-w)]^T$。\n\n更深入的分析揭示了一个关键权重 $w_{crit}$，它决定了群落的定性行为。A 和 B 生长之间的代谢权衡由它们各自将共享底物 $G$ 转化为生物质的效率决定。对于生物体 B，1 单位的 $G$ 产生 1 单位的生物质（无论是作为 $\\mu_{\\mathrm{B,G}}$ 还是通过成为 $\\mu_{\\mathrm{B,X}}$ 的 $v_X$）。对于生物体 A，1 单位的 $G$ 产生 $1/c_{\\mathrm{A,bio}} = 1/1.2$ 单位的生物质。对于 $\\mu_{\\mathrm{A}}$ 和 $\\mu_{\\mathrm{B}}$ 之间的微分权衡，目标函数 $dJ$ 的变化是 $dJ = (1-w - w/c_{\\mathrm{A,bio}})d\\mu_{\\mathrm{B}}$。如果系数为正，群落将偏向 B 的生长，这发生在 $1-w > w/c_{\\mathrm{A,bio}}$ 时，简化为 $w  c_{\\mathrm{A,bio}} / (1+c_{\\mathrm{A,bio}})$。\n当 $c_{\\mathrm{A,bio}}=1.2$ 时，临界权重为 $w_{crit} = 1.2 / 2.2 = 6/11 \\approx 0.545$。\n- 如果 $w > w_{crit}$，系统会最大化 A 的生长，设置 $\\mu_{\\mathrm{B}}=0$。\n- 如果 $w  w_{crit}$，系统会通过将资源分配给 $\\mu_{\\mathrm{B,G}}$ 和 $v_X$ 直至其适用上限来最大化 B 的生长。\n这一分析性见解证实了 LP 求解器为给定测试用例找到的解。实现将继续为测试套件中的每组参数构建并求解 LP。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of joint flux balance analysis problems for a synthetic microbial consortium.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (w, G_max, X_max).\n    test_cases = [\n        (0.25, 10, 7),\n        (1.0, 10, 10),\n        (0.0, 10, 10),\n        (0.7, 10, 10),\n        (0.6, 5, 10),\n    ]\n\n    # Fixed parameters for all test cases\n    A_G_max = 10.0\n    B_G_max = 3.0\n    c_A_bio = 1.2\n    c_A_X = 1.0\n\n    results = []\n\n    # The problem is formulated as a Linear Program (LP).\n    # Decision variables x = [mu_A, mu_B,G, v_X]\n    # where mu_A is A's growth rate, mu_B,G is B's growth from substrate G,\n    # and v_X is the cross-feeding flux, equal to B's growth from metabolite X.\n\n    # Constraints: A_ub * x = b_ub\n    # 1. v_A,inG = A_G_max  => c_A_bio*mu_A + c_A_X*v_X = A_G_max\n    # 2. v_B,inG = B_G_max  => mu_B,G = B_G_max\n    # 3. v_X = X_max\n    # 4. v_A,inG + v_B,inG = G_max => c_A_bio*mu_A + mu_B,G + c_A_X*v_X = G_max\n    \n    A_ub = np.array([\n        [c_A_bio, 0.0,     c_A_X],\n        [0.0,     1.0,     0.0  ],\n        [0.0,     0.0,     1.0  ],\n        [c_A_bio, 1.0,     c_A_X]\n    ])\n    \n    for w, G_max, X_max in test_cases:\n        # Objective function to maximize: w*mu_A + (1-w)*(mu_B,G + v_X)\n        # scipy.optimize.linprog minimizes, so we minimize the negative of the objective.\n        c = np.array([-w, -(1 - w), -(1 - w)])\n\n        # Right-hand side of the inequality constraints\n        b_ub = np.array([A_G_max, B_G_max, X_max, G_max])\n        \n        # All variables are non-negative, which is the default for linprog.\n        # So bounds are (0, None) for all variables.\n        \n        # Solve the LP problem\n        res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, method='highs')\n\n        if res.success:\n            mu_A_opt = res.x[0]\n            mu_BG_opt = res.x[1]\n            v_X_opt = res.x[2]\n            \n            # Total growth rate of organism B\n            mu_B_opt = mu_BG_opt + v_X_opt\n            \n            # Append the formatted result\n            results.append(f\"[{mu_A_opt:.6f},{mu_B_opt:.6f}]\")\n        else:\n            # This should not happen for this well-posed problem\n            results.append(\"[error,error]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2728301"}, {"introduction": "在建立了代谢模型之后，一个自然而然的问题是：如果我们的模型参数不完全精确，其预测结果有多可靠？本练习将从代谢通量层面转换到种群动态层面，并介绍区间分析（interval analysis）这一严谨的数学方法。你将学习如何利用该方法，在生长和相互作用参数存在不确定性的情况下，计算群落稳态丰度的可靠边界，这对于设计在现实世界中表现稳健且可预测的系统至关重要。[@problem_id:2728320]", "problem": "在混合均匀的环境中，一个合成微生物群落的中间密度通常可以通过一个包含基础输入和成对交叉哺养的线性化生灭平衡来近似。考虑一个由 $n$ 个物种组成的群落，其丰度为非负值 $x_i \\ge 0$，其中 $i \\in \\{1,\\dots,n\\}$。物种 $i$ 的动态由常微分方程 (ODE) $dx_i/dt = r_i - \\delta_i x_i + \\sum_{j=1}^n \\gamma_{ij} x_j$ 建模，其中 $r_i \\ge 0$ 是一个基础输入项（例如，由营养供给并按种群单位缩放的有效生长），$\\delta_i \\gt 0$ 是一个损失率（例如，稀释），$\\gamma_{ij} \\ge 0$ 编码了物种 $i$ 从物种 $j$ 获得的单位种群交叉哺养效益。该常微分方程是质量平衡的线性化：稳态由 $dx_i/dt = 0$ 定义。\n\n参数是不确定的，但位于已知的闭区间内：$r_i \\in [\\underline{r}_i,\\overline{r}_i]$，$\\delta_i \\in [\\underline{\\delta}_i,\\overline{\\delta}_i]$，以及 $\\gamma_{ij} \\in [\\underline{\\gamma}_{ij},\\overline{\\gamma}_{ij}]$，其中 $\\underline{r}_i \\ge 0$，$\\underline{\\delta}_i \\gt 0$，且 $\\underline{\\gamma}_{ij} \\ge 0$。假设对于这些区间内 $(\\delta,\\Gamma)$ 的每一个容许选择，矩阵 $M(\\delta,\\Gamma) := \\mathrm{diag}(\\delta_1,\\dots,\\delta_n) - \\Gamma$ 都是严格行对角占优的，因此是非奇异的，并且是一个非对角线元素为非正的 Z 矩阵。在这些假设下，$M(\\delta,\\Gamma)$ 是一个非奇异 M 矩阵，对于给定的 $(r,\\delta,\\Gamma)$，其唯一的稳态是非负向量 $x^\\star(r,\\delta,\\Gamma)$，满足 $M(\\delta,\\Gamma)\\,x^\\star = r$。\n\n任务：使用基于第一性原理的区间分析，推导对给定区间内所有参数都成立的稳态丰度的分量界限。您的推导必须从上述定义开始，仅使用关于非奇异 M 矩阵和单调比较静态学的公认事实，并避免使用任何快捷公式。然后，实现所得算法以计算以下测试套件的界限。所有量纲均为无量纲。对于每个测试用例，以浮点数形式报告分量下界和上界，并四舍五入到 $6$ 位小数。\n\n测试套件：\n\n- 测试用例 $1$ ($n=2$)：\n  - $\\underline{r} = [\\,0.8,\\,0.9\\,]$, $\\overline{r} = [\\,1.0,\\,1.1\\,]$.\n  - $\\underline{\\delta} = [\\,1.2,\\,1.1\\,]$, $\\overline{\\delta} = [\\,1.5,\\,1.4\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0  0.05 \\\\ 0.03  0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0  0.10 \\\\ 0.08  0.0 \\end{bmatrix}$.\n\n- 测试用例 $2$ ($n=3$)：\n  - $\\underline{r} = [\\,0.5,\\,0.4,\\,0.6\\,]$, $\\overline{r} = [\\,0.9,\\,0.7,\\,1.0\\,]$.\n  - $\\underline{\\delta} = [\\,1.4,\\,1.3,\\,1.5\\,]$, $\\overline{\\delta} = [\\,1.8,\\,1.7,\\,1.9\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0  0.02  0.00 \\\\ 0.01  0.0  0.03 \\\\ 0.02  0.01  0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0  0.06  0.05 \\\\ 0.04  0.0  0.07 \\\\ 0.05  0.03  0.0 \\end{bmatrix}$.\n\n- 测试用例 $3$ ($n=2$，接近对角占优边缘)：\n  - $\\underline{r} = [\\,0.05,\\,0.05\\,]$, $\\overline{r} = [\\,0.06,\\,0.06\\,]$.\n  - $\\underline{\\delta} = [\\,0.12,\\,0.12\\,]$, $\\overline{\\delta} = [\\,0.13,\\,0.13\\,]$.\n  - $\\underline{\\Gamma} = \\begin{bmatrix} 0.0  0.049 \\\\ 0.049  0.0 \\end{bmatrix}$, $\\overline{\\Gamma} = \\begin{bmatrix} 0.0  0.050 \\\\ 0.050  0.0 \\end{bmatrix}$.\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例产生一个列表，该列表按顺序 $[\\,\\underline{x}_1,\\overline{x}_1,\\underline{x}_2,\\overline{x}_2,\\dots,\\underline{x}_n,\\overline{x}_n\\,]$ 串联了各物种的下界和上界。将这些每个测试用例的列表聚合到一个外部列表中。例如，打印的结构必须类似于 $[\\,[\\,\\cdots\\,],\\,[\\,\\cdots\\,],\\,[\\,\\cdots\\,]\\,]$，所有数字四舍五入到 $6$ 位小数。", "solution": "所提出的问题是动态系统和控制理论领域中的一个适定问题，特别涉及生物网络的稳定性和稳态分析。它在科学上基于 Lotka-Volterra 系统和 M 矩阵理论，这些理论在数学生物学中有典型的应用。该问题是自洽的，所有必要的参数和假设都已明确说明。这些假设，特别是严格对角占优的假设，对于给定的测试数据是可验证的，并确保了非负稳态的存在性和唯一性。该问题是有效的，并允许严谨的求解。\n\n我们的任务是为一个相互作用的物种系统找到稳态丰度向量 $x^{\\star}$ 的分量界限，该系统由以下常微分方程组描述：\n$$\n\\frac{dx_i}{dt} = r_i - \\delta_i x_i + \\sum_{j=1}^n \\gamma_{ij} x_j\n$$\n参数 $r_i$、$\\delta_i$ 和 $\\gamma_{ij}$ 是不确定的，仅知道它们位于指定的闭区间内：$r_i \\in [\\underline{r}_i, \\overline{r}_i]$、$\\delta_i \\in [\\underline{\\delta}_i, \\overline{\\delta}_i]$ 和 $\\gamma_{ij} \\in [\\underline{\\gamma}_{ij}, \\overline{\\gamma}_{ij}]$。\n\n在稳态下，$\\frac{dx_i}{dt} = 0$，这产生以下线性系统：\n$$\n\\delta_i x_i^{\\star} - \\sum_{j=1}^n \\gamma_{ij} x_j^{\\star} = r_i \\quad \\text{for } i = 1, \\dots, n\n$$\n这可以表示为矩阵形式 $M x^{\\star} = r$，其中 $x^{\\star}$ 和 $r$ 是分量分别为 $x_i^{\\star}$ 和 $r_i$ 的列向量。矩阵 $M$ 的元素定义如下：\n$$\nM_{ij} = \\begin{cases} \\delta_i - \\gamma_{ii}  \\text{if } i=j \\\\ -\\gamma_{ij}  \\text{if } i \\ne j \\end{cases}\n$$\n鉴于问题指定 $\\gamma_{ii}=0$（无自我增益），矩阵简化为 $M = \\mathrm{diag}(\\delta_1, \\dots, \\delta_n) - \\Gamma$，其中 $\\Gamma$ 是元素为 $\\gamma_{ij}$ 的矩阵。\n\n问题陈述，对于参数 $(\\delta, \\Gamma)$ 的任何容许选择，矩阵 $M(\\delta, \\Gamma)$ 都是一个非奇异 M 矩阵。这是一个关键属性。M 矩阵的一个基本定理指出，一个 Z 矩阵（非对角线元素为非正的矩阵）是非奇异 M 矩阵的充要条件是其逆矩阵存在且逐元素非负。也就是说，如果 $M$ 是一个非奇异 M 矩阵，那么 $M^{-1}$ 存在且对所有 $i,j$ 都有 $(M^{-1})_{ij} \\ge 0$。\n\n稳态解由 $x^{\\star} = M^{-1} r$ 给出。我们的目标是确定最紧的分量界限 $\\underline{x}$ 和 $\\overline{x}$，使得对于所有可能的参数，都有 $\\underline{x} \\le x^{\\star} \\le \\overline{x}$。\n\n根据要求，我们使用第一性原理来分析 $x^{\\star}$ 对参数的依赖性。\n\n1.  **对输入向量 $r$ 的依赖性**：\n    解的第 $i$ 个分量是 $x_i^{\\star} = \\sum_{j=1}^n (M^{-1})_{ij} r_j$。$x_i^{\\star}$ 关于分量 $r_k$ 的偏导数是：\n    $$\n    \\frac{\\partial x_i^{\\star}}{\\partial r_k} = (M^{-1})_{ik}\n    $$\n    由于 $M^{-1}$ 是逐元素非负的，所以 $\\frac{\\partial x_i^{\\star}}{\\partial r_k} \\ge 0$。这表明稳态向量 $x^{\\star}$ 的每个分量都是输入向量 $r$ 每个分量的单调非减函数。因此，要找到上界 $\\overline{x}_i$，我们必须使用最大输入向量 $\\overline{r}$。要找到下界 $\\underline{x}_i$，我们必须使用最小输入向量 $\\underline{r}$。\n\n2.  **对系统矩阵 $M$ 的依赖性**：\n    我们引用单调算子理论中的一个关键结果，该结果适用于 M 矩阵。如果 $M_A$ 和 $M_B$ 是两个相同维度的非奇异 M 矩阵，使得 $M_A \\le M_B$（逐元素不等式），那么它们的逆矩阵按相反顺序排列：$M_B^{-1} \\le M_A^{-1}$。\n\n    让我们根据参数区间定义两个“极端”矩阵。我们集合中的任何矩阵 $M(\\delta, \\Gamma)$ 的元素为 $M_{ii} = \\delta_i$ 和 $M_{ij} = -\\gamma_{ij}$（当 $i \\ne j$ 时）。\n    - 为了构造最小的可能矩阵 $\\underline{M}$，我们必须选择最小的可能对角线元素和最小的可能（最负的）非对角线元素。这对应于选择 $\\delta_i = \\underline{\\delta}_i$ 和 $\\gamma_{ij} = \\overline{\\gamma}_{ij}$。因此，$\\underline{M} = \\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}$。\n    - 为了构造最大的可能矩阵 $\\overline{M}$，我们必须选择最大的可能对角线元素和最大的可能（最不负的）非对角线元素。这对应于选择 $\\delta_i = \\overline{\\delta}_i$ 和 $\\gamma_{ij} = \\underline{\\gamma}_{ij}$。因此，$\\overline{M} = \\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}$。\n\n    对于参数 $(\\delta, \\Gamma)$ 的任何容许选择，显然有 $\\underline{M} \\le M(\\delta, \\Gamma) \\le \\overline{M}$。根据上面提到的比较静态属性，它们的逆矩阵按以下顺序排列：\n    $$\n    \\overline{M}^{-1} \\le M(\\delta, \\Gamma)^{-1} \\le \\underline{M}^{-1}\n    $$\n    所有这些逆矩阵都是逐元素非负的。\n\n3.  **界限的综合**：\n    我们结合这些观察结果来确定 $x^{\\star} = M^{-1}r$ 的界限。\n    - **上界 $\\overline{x}$**：为了最大化 $x^{\\star}$ 的每个分量，我们必须最大化 $M^{-1}$ 和 $r$ 的相应项。根据我们的分析，这可以通过选择 $\\underline{M}$（它产生最大的逆矩阵 $\\underline{M}^{-1}$）和 $\\overline{r}$ 来实现。由于 $\\underline{M}^{-1}$ 和 $\\overline{r}$ 的所有项都是非负的，因此乘积被最大化。因此，上界向量 $\\overline{x}$ 必须满足以下关系：\n    $$\n    \\overline{x} = \\underline{M}^{-1} \\overline{r} \\quad \\implies \\quad (\\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}) \\overline{x} = \\overline{r}\n    $$\n    - **下界 $\\underline{x}$**：为了最小化 $x^{\\star}$ 的每个分量，我们必须最小化 $M^{-1}$ 和 $r$ 的相应项。这可以通过选择 $\\overline{M}$（它产生最小的逆矩阵 $\\overline{M}^{-1}$）和 $\\underline{r}$ 来实现。因此，下界向量 $\\underline{x}$ 必须满足：\n    $$\n    \\underline{x} = \\overline{M}^{-1} \\underline{r} \\quad \\implies \\quad (\\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}) \\underline{x} = \\underline{r}\n    $$\n\n这个基于 M 矩阵基本性质的推导，提供了一个直接且严谨的算法。为了计算界限，我们只需要构造两个极端矩阵 $\\underline{M}$ 和 $\\overline{M}$，并求解两个相应的线性方程组。这种方法避免了对参数空间的任何枚举或优化，并且计算效率很高。\n\n算法如下：\n1.  根据给定的区间，构造向量 $\\underline{r}, \\overline{r}, \\underline{\\delta}, \\overline{\\delta}$ 和矩阵 $\\underline{\\Gamma}, \\overline{\\Gamma}$。\n2.  构造用于计算上界的矩阵：$\\underline{M} = \\mathrm{diag}(\\underline{\\delta}) - \\overline{\\Gamma}$。\n3.  求解线性系统 $\\underline{M} \\overline{x} = \\overline{r}$ 以获得上界向量 $\\overline{x}$。\n4.  构造用于计算下界的矩阵：$\\overline{M} = \\mathrm{diag}(\\overline{\\delta}) - \\underline{\\Gamma}$。\n5.  求解线性系统 $\\overline{M} \\underline{x} = \\underline{r}$ 以获得下界向量 $\\underline{x}$。\n6.  每个物种 $i$ 的最终结果是区间 $[\\underline{x}_i, \\overline{x}_i]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the component-wise steady-state abundance bounds for a microbial\n    consortium model with interval parameters.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (n=2)\n        {\n            \"r_underline\": np.array([0.8, 0.9]),\n            \"r_overline\": np.array([1.0, 1.1]),\n            \"delta_underline\": np.array([1.2, 1.1]),\n            \"delta_overline\": np.array([1.5, 1.4]),\n            \"Gamma_underline\": np.array([[0.0, 0.05], [0.03, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.10], [0.08, 0.0]]),\n        },\n        # Test Case 2 (n=3)\n        {\n            \"r_underline\": np.array([0.5, 0.4, 0.6]),\n            \"r_overline\": np.array([0.9, 0.7, 1.0]),\n            \"delta_underline\": np.array([1.4, 1.3, 1.5]),\n            \"delta_overline\": np.array([1.8, 1.7, 1.9]),\n            \"Gamma_underline\": np.array([[0.0, 0.02, 0.00], [0.01, 0.0, 0.03], [0.02, 0.01, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.06, 0.05], [0.04, 0.0, 0.07], [0.05, 0.03, 0.0]]),\n        },\n        # Test Case 3 (n=2, near-diagonal-dominance edge)\n        {\n            \"r_underline\": np.array([0.05, 0.05]),\n            \"r_overline\": np.array([0.06, 0.06]),\n            \"delta_underline\": np.array([0.12, 0.12]),\n            \"delta_overline\": np.array([0.13, 0.13]),\n            \"Gamma_underline\": np.array([[0.0, 0.049], [0.049, 0.0]]),\n            \"Gamma_overline\": np.array([[0.0, 0.050], [0.050, 0.0]]),\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        r_underline = params[\"r_underline\"]\n        r_overline = params[\"r_overline\"]\n        delta_underline = params[\"delta_underline\"]\n        delta_overline = params[\"delta_overline\"]\n        Gamma_underline = params[\"Gamma_underline\"]\n        Gamma_overline = params[\"Gamma_overline\"]\n\n        # Calculate the lower bound on abundances, x_underline.\n        # This requires solving M_overline * x_underline = r_underline,\n        # where M_overline = diag(delta_overline) - Gamma_underline.\n        M_overline = np.diag(delta_overline) - Gamma_underline\n        x_underline = np.linalg.solve(M_overline, r_underline)\n\n        # Calculate the upper bound on abundances, x_overline.\n        # This requires solving M_underline * x_overline = r_overline,\n        # where M_underline = diag(delta_underline) - Gamma_overline.\n        M_underline = np.diag(delta_underline) - Gamma_overline\n        x_overline = np.linalg.solve(M_underline, r_overline)\n        \n        # Format the result for the current test case.\n        # The required format is [x1_low, x1_high, x2_low, x2_high, ...].\n        case_result = []\n        for i in range(len(x_underline)):\n            case_result.append(round(x_underline[i], 6))\n            case_result.append(round(x_overline[i], 6))\n        \n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is what's needed for the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2728320"}, {"introduction": "本章的最后一部分将从分析转向主动设计，这是合成生物学的核心目标之一。本实践将指导你应用FBA来寻找“最小基因敲除集”（minimal cut-sets）。通过计算达成特定工程目标（例如，阻断某个代谢物的产生）所需的最小反应敲除组合，你将模拟一个理性的代谢工程设计周期，学习如何识别网络中的关键干预靶点。[@problem_id:2728387]", "problem": "你的任务是编写一个完整的、可运行的程序，为一组小型的、合成的微生物群落模型计算能够中断指定目标代谢物流的最小割集，并为每种情况量化一个弹性指标。你的程序必须实现以下有数学基础的框架。\n\n从细胞内和共享的细胞外代谢物的稳态质量平衡开始：对于一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和一个反应通量向量 $v \\in \\mathbb{R}^{n}$，稳态约束为 $S v = 0$。反应通量受上下界 $l \\le v \\le u$ 约束，其中 $l, u \\in \\mathbb{R}^{n}$。在通量平衡分析 (FBA) 中，通过构建一个线性规划 (LP) 问题，求解在满足线性约束 $S v = 0$ 和 $l \\le v \\le u$ 的条件下最大化 $v_{j^\\star}$ 的 LP，可以获得通过索引为 $j^\\star$ 的指定目标反应的最大可达通量。一个反应集合 $K \\subseteq \\{0,1,\\dots,n-1\\}$ 被指定为可敲除集，意味着只有 $K$ 中的反应可以被禁用（敲除）。反应 $j$ 的敲除通过将其通量边界设置为 $l_j = u_j = 0$ 来建模。\n\n定义一个目标阈值 $\\tau > 0$。如果集合 $C \\subseteq K$ 在同时敲除所有反应 $j \\in C$ 后，每个可行的稳态通量向量 $v$ 都满足 $v_{j^\\star}  \\tau$，那么该集合就是一个割集。最小割集是一个割集 $C$，且其任何真子集都不是割集。令 $|C|$ 表示 $C$ 的基数。对于至少存在一个最小割集的情况，定义弹性指数 $R$ 为 $R = \\frac{|C_{\\min}|}{|K|}$，其中 $|C_{\\min}|$ 是该情况下所有最小割集中的最小基数。如果在完整网络中（即在任何敲除之前）目标阈值 $\\tau$ 无法达到，则将该情况视为目标不可行；在这种情况下，报告不需要割集，并且不定义弹性指数。如果目标是可达到的，但在允许的可敲除集 $K$ 下不存在割集，则报告该网络在允许的干预下是不可阻断的，并且不定义弹性指数。\n\n你的程序必须：\n- 对于每个提供的测试用例，通过求解一个最大化目标通量 $v_{j^\\star}$ 的 LP 问题，来确定在完整网络中目标阈值是否可达到。\n- 如果可达到，则按大小递增的顺序枚举 $K$ 的子集，以找到所有在子集敲除后能确保 $v_{j^\\star}  \\tau$ 的最小基数的最小割集。\n- 对于每种情况，生成一个包含以下结果的元组：\n  1. 一个布尔值，表示在完整网络中目标阈值是否可达到。\n  2. 一个布尔值，表示在允许的可敲除集 $K$ 下网络是否可被阻断（即是否存在至少一个最小割集）。\n  3. 如果可阻断，则为割集的最小基数 $|C_{\\min}|$；否则，报告 $-1$。\n  4. 如果可阻断，则为达到该最小基数的不同最小割集的数量；否则，报告 $0$。\n  5. 如果可阻断，则为如上定义的弹性指数 $R$；否则，报告 $-1$。\n\n所有通量均为任意单位的无量纲值，在输出中无需特定物理单位。\n\n索引约定：对反应使用从零开始的索引。\n\n测试套件：\n- 情况 1（从供给到目标的单路径链）：\n  - 代谢物（$S_1$ 的行）：$[F_e, F_A, P_A, P_e, P_B, T_B, T_e]$。\n  - 反应（$S_1$ 的列），顺序为 $[R_1, R_2, R_3, R_4, R_5, R_6, R_7, R_8]$：\n    - $R_1$: 环境 $\\to F_e$，\n    - $R_2$: $F_e \\to F_A$，\n    - $R_3$: $F_A \\to P_A$，\n    - $R_4$: $P_A \\to P_e$，\n    - $R_5$: $P_e \\to P_B$，\n    - $R_6$: $P_B \\to T_B$，\n    - $R_7$: $T_B \\to T_e$ (目标)，\n    - $R_8$: $T_e \\to$ 环境。\n  - 化学计量矩阵 $S_1 \\in \\mathbb{R}^{7 \\times 8}$：\n    $$\n    S_1 =\n    \\begin{bmatrix}\n    +1  -1   0   0   0   0   0   0 \\\\\n     0  +1  -1   0   0   0   0   0 \\\\\n     0   0  +1  -1   0   0   0   0 \\\\\n     0   0   0  +1  -1   0   0   0 \\\\\n     0   0   0   0  +1  -1   0   0 \\\\\n     0   0   0   0   0  +1  -1   0 \\\\\n     0   0   0   0   0   0  +1  -1\n    \\end{bmatrix}.\n    $$\n  - 边界 $l_1 = (0,\\dots,0)$，$u_1 = (2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000)$。\n  - 目标索引 $j^\\star = 6$。\n  - 阈值 $\\tau = 1.0$。\n  - 可敲除集 $K_1 = \\{1,2,3,4,5\\}$。\n- 情况 2（物种 A 中的两个并行转化）：\n  - 代谢物与情况 1 相同。\n  - 反应（$S_2$ 的列），顺序为 $[R_1, R_2, R_{3a}, R_{3b}, R_4, R_5, R_6, R_7, R_8]$：\n    - $R_1$: 环境 $\\to F_e$，\n    - $R_2$: $F_e \\to F_A$，\n    - $R_{3a}$: $F_A \\to P_A$，\n    - $R_{3b}$: $F_A \\to P_A$，\n    - $R_4$: $P_A \\to P_e$，\n    - $R_5$: $P_e \\to P_B$，\n    - $R_6$: $P_B \\to T_B$，\n    - $R_7$: $T_B \\to T_e$ (目标)，\n    - $R_8$: $T_e \\to$ 环境。\n  - 化学计量矩阵 $S_2 \\in \\mathbb{R}^{7 \\times 9}$：\n    $$\n    S_2 =\n    \\begin{bmatrix}\n    +1  -1   0   0   0   0   0   0   0 \\\\\n     0  +1  -1  -1   0   0   0   0   0 \\\\\n     0   0  +1  +1  -1   0   0   0   0 \\\\\n     0   0   0   0  +1  -1   0   0   0 \\\\\n     0   0   0   0   0  +1  -1   0   0 \\\\\n     0   0   0   0   0   0  +1  -1   0 \\\\\n     0   0   0   0   0   0   0  +1  -1\n    \\end{bmatrix}.\n    $$\n  - 边界 $l_2 = (0,\\dots,0)$，$u_2 = (2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000)$。\n  - 目标索引 $j^\\star = 7$。\n  - 阈值 $\\tau = 1.0$。\n  - 可敲除集 $K_2 = \\{2,3\\}$。\n- 情况 3（由于供给限制，在完整网络中阈值不可达到）：\n  - 与情况 1 相同，但 $u_3 = (0.6, 1000, 1000, 1000, 1000, 1000, 1000, 1000)$。\n  - 目标索引 $j^\\star = 6$。\n  - 阈值 $\\tau = 1.0$。\n  - 可敲除集 $K_3 = \\{1,2,3,4,5\\}$。\n- 情况 4（不允许干预）：\n  - 与情况 1 相同，但可敲除集为空集 $K_4 = \\emptyset$。\n  - 目标索引 $j^\\star = 6$。\n  - 阈值 $\\tau = 1.0$。\n\n你的程序必须使用线性规划 (LP) 来评估目标的可行性，并且通过检查最大化后的目标通量是否低于 $\\tau$ 来测试候选敲除子集是否为割集。对于每种情况，通过按基数递增的顺序枚举 $K$ 的子集来搜索最小割集，直到找到至少一个割集为止；然后报告最小基数、该基数的不同最小割集数量以及弹性指数。\n\n最终输出格式：\n- 生成一行输出，其中包含一个按情况划分的结果列表，每个结果是如上所述包含五个条目的列表。输出必须是格式为\n  $$\n  [\\text{result\\_case1},\\text{result\\_case2},\\text{result\\_case3},\\text{result\\_case4}]\n  $$\n  的单行，例如，每个情况的结果可能看起来像 $[{\\tt True},{\\tt True},1,5,0.2]$。", "solution": "所提出的问题是计算系统生物学中的一个标准练习，具体涉及使用通量平衡分析 (FBA) 对代谢网络鲁棒性进行分析。该问题定义明确，具有科学依据，并包含获得唯一、可验证解所需的所有必要信息。我们将着手对其进行正式求解。\n\n问题的核心在于代谢网络中稳态下的质量守恒原理。对于一个有 $m$ 种代谢物和 $n$ 个反应的系统，该原理由线性方程捕获：\n$$S \\cdot v = 0$$\n其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量向量。每个通量 $v_j$ 还受到热力学和容量限制的约束，表示为下界和上界，$l_j \\le v_j \\le u_j$。\n\n通量平衡分析 (FBA) 使用线性规划 (LP) 来寻找一个可行的通量分布 $v$，该分布能够优化给定的生物学目标，通常是最大化某个特定通量，例如生物质产量或目标代谢物的合成。为了最大化目标反应 $v_{j^\\star}$ 的通量，我们求解以下 LP 问题：\n$$\n\\begin{align*}\n\\text{maximize} \\quad  v_{j^\\star} \\\\\n\\text{subject to} \\quad  S \\cdot v = 0 \\\\\n l_j \\le v_j \\le u_j \\quad \\text{for } j=0, \\dots, n-1\n\\end{align*}\n$$\n这等同于最小化 $-v_{j^\\star}$。对于标准的 LP 求解器，目标函数向量 $c$ 将是：当 $j=j^\\star$ 时 $c_j = -1$，当 $j \\neq j^\\star$ 时 $c_j=0$。等式约束为 $A_{eq} = S$ 和 $b_{eq} = 0$。通量边界由求解器直接处理。\n\n问题要求识别最小割集。从可敲除集 $K$ 中选择的反应集合 $C$，如果在移除它们后，通过目标反应 $v_{j^\\star}$ 的最大通量降至指定阈值 $\\tau$ 以下，则该集合是一个割集。反应敲除通过将其边界设置为零来模拟，即对于所有 $j \\in C$，$l_j = u_j = 0$。因此，如果 $\\max(v_{j^\\star})_{\\text{knockout}}  \\tau$，则 $C \\subseteq K$ 是一个割集。\n\n最小割集是其任何真子集都不是割集的割集。问题要求寻找*基数尽可能小*的最小割集。所规定的算法通过从 $k=1$ 开始，按基数 $|C|=k$ 遞增的顺序系统地枚举 $K$ 的子集，来正确地识别这些割集。当在基数 $k_{min}$ 处找到第一个非空割集集合时，搜索终止。在此阶段找到的任何割集 $C$ 都必须是最小的。如果不是，它将包含一个也是割集的真子集 $C' \\subset C$。然而， $|C'|  |C| = k_{min}$，这与 $k_{min}$ 是找到任何割集的最小基数的前提相矛盾。因此，这种迭代搜索能正确找到所有最小基数的最小割集。\n\n弹性指数 $R = \\frac{|C_{\\min}|}{|K|}$ 是衡量网络对允许干预的鲁棒性的归一化度量。较高的值表示必须同时禁用更大比例的可用干预目标才能中断目标通量，这表明弹性更高。初始目标通量低于阈值或 $K$ 内不存在割集的特殊情况按定义处理，导致弹性未定义。\n\n每个测试用例的总体算法如下：\n1.  定义模型参数：$S$, $l$, $u$, $j^\\star$, $\\tau$, 和 $K$。\n2.  为完整网络求解 FBA 问题，以找到最大可能的目标通量 $v_{max}^{intact}$。\n3.  将 $v_{max}^{intact}$ 与 $\\tau$ 进行比较。如果 $v_{max}^{intact}  \\tau$，则目标不可达到。不需要割集。报告 `target_achievable = False` 及其他指标的默认值。\n4.  如果 $v_{max}^{intact} \\ge \\tau$，则目标是可达到的。继续搜索割集。报告 `target_achievable = True`。\n5.  从 $1$ 到 $|K|$ 遍历子集基数 $k$。对于每个 $k$，生成大小为 $k$ 的所有组合 $C \\subseteq K$。\n6.  对于每个候选集 $C$，通过为所有 $j \\in C$ 设置 $l_j=u_j=0$ 来修改通量边界。求解由此产生的 FBA 问题，以找到最大目标通量 $v_{max}^{ko}$。\n7.  如果 $v_{max}^{ko}  \\tau$，那么 $C$ 是一个最小基数的最小割集。将其添加到当前 $k$ 的解列表中。\n8.  如果在检查完所有大小为 $k$ 的子集后，至少找到了一个割集，则搜索终止。最小基数为 $k_{min}=k$，此类集合的数量是解列表的长度。弹性指数计算为 $R = k_{min} / |K|$。\n9.  如果循环完成而未找到任何割集，则网络在给定约束下是不可阻断的。报告 `is_blockable = False` 及其他指标的默认值。\n\n该过程将为每个提供的测试用例实现。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\ndef solve_fba(S, l, u, j_target):\n    \"\"\"\n    Solves the FBA problem to maximize flux through j_target.\n    \n    Args:\n        S (np.ndarray): Stoichiometric matrix.\n        l (np.ndarray): Lower bounds for fluxes.\n        u (np.ndarray): Upper bounds for fluxes.\n        j_target (int): Index of the target reaction.\n\n    Returns:\n        float: The maximal flux through the target reaction.\n    \"\"\"\n    num_reactions = S.shape[1]\n    c = np.zeros(num_reactions)\n    c[j_target] = -1  # Minimize -v_j_target to maximize v_j_target\n\n    bounds = list(zip(l, u))\n    b_eq = np.zeros(S.shape[0])\n\n    # Use 'highs' method which is robust and default in recent SciPy\n    res = linprog(c, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if res.success:\n        return -res.fun  # Return the maximized flux (negate back)\n    elif res.status == 2:  # Status 2 indicates the problem is infeasible\n        return 0.0  # Infeasible means no flux, so max flux is 0\n    else:\n        # For other errors, assume 0 flux as a safe default\n        return 0.0\n\ndef analyze_case(S, l, u, j_target, tau, K):\n    \"\"\"\n    Analyzes a single metabolic network case.\n    \n    Returns:\n        list: A list of 5 result metrics for the case.\n    \"\"\"\n    # 1. Check if target is achievable in the intact network\n    max_flux_initial = solve_fba(S, l, u, j_target)\n    \n    if max_flux_initial  tau:\n        # Target not achievable, no cut-sets needed\n        return [False, False, -1, 0, -1.0]\n\n    target_achievable = True\n    \n    # 2. Search for minimal cut-sets\n    K_list = sorted(list(K)) # Use a sorted list for deterministic iteration\n    is_blockable = False\n    minimal_cut_sets_found = []\n    min_card = -1\n\n    if not K_list: # Empty knockable set\n        is_blockable = False\n    else:\n        for k in range(1, len(K_list) + 1):\n            for C_tuple in combinations(K_list, k):\n                C = set(C_tuple)\n                l_mod = np.copy(l)\n                u_mod = np.copy(u)\n                \n                for j_knockout in C:\n                    l_mod[j_knockout] = 0.0\n                    u_mod[j_knockout] = 0.0\n\n                max_flux_knockout = solve_fba(S, l_mod, u_mod, j_target)\n\n                if max_flux_knockout  tau:\n                    minimal_cut_sets_found.append(C)\n                    is_blockable = True\n            \n            if is_blockable:\n                min_card = k\n                break # Found minimal cardinality, stop searching larger sets\n\n    # 3. Compile results\n    if is_blockable:\n        num_minimal_cut_sets = len(minimal_cut_sets_found)\n        resilience_index = float(min_card) / len(K_list) if K_list else -1.0\n        # Round resilience index for consistent output if needed, but problem doesn't specify.\n        # Let's keep it as float.\n        return [target_achievable, is_blockable, min_card, num_minimal_cut_sets, resilience_index]\n    else:\n        # Target is achievable but not blockable with the given K\n        return [target_achievable, False, -1, 0, -1.0]\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the analysis for each.\n    \"\"\"\n    # Case 1: single-path chain\n    S1 = np.array([\n        [+1, -1,  0,  0,  0,  0,  0,  0],\n        [ 0, +1, -1,  0,  0,  0,  0,  0],\n        [ 0,  0, +1, -1,  0,  0,  0,  0],\n        [ 0,  0,  0, +1, -1,  0,  0,  0],\n        [ 0,  0,  0,  0, +1, -1,  0,  0],\n        [ 0,  0,  0,  0,  0, +1, -1,  0],\n        [ 0,  0,  0,  0,  0,  0, +1, -1]\n    ], dtype=float)\n    l1 = np.zeros(8)\n    u1 = np.array([2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000])\n    j_star1 = 6\n    tau1 = 1.0\n    K1 = {1, 2, 3, 4, 5}\n\n    # Case 2: two parallel conversions\n    S2 = np.array([\n        [+1, -1,  0,  0,  0,  0,  0,  0,  0],\n        [ 0, +1, -1, -1,  0,  0,  0,  0,  0],\n        [ 0,  0, +1, +1, -1,  0,  0,  0,  0],\n        [ 0,  0,  0,  0, +1, -1,  0,  0,  0],\n        [ 0,  0,  0,  0,  0, +1, -1,  0,  0],\n        [ 0,  0,  0,  0,  0,  0, +1, -1,  0],\n        [ 0,  0,  0,  0,  0,  0,  0, +1, -1]\n    ], dtype=float)\n    l2 = np.zeros(9)\n    u2 = np.array([2.0, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])\n    j_star2 = 7\n    tau2 = 1.0\n    K2 = {2, 3}\n\n    # Case 3: threshold unattainable\n    S3 = S1\n    l3 = l1\n    u3 = np.array([0.6, 1000, 1000, 1000, 1000, 1000, 1000, 1000])\n    j_star3 = 6\n    tau3 = 1.0\n    K3 = {1, 2, 3, 4, 5}\n\n    # Case 4: no interventions allowed\n    S4 = S1\n    l4 = l1\n    u4 = u1\n    j_star4 = 6\n    tau4 = 1.0\n    K4 = set()\n\n    test_cases = [\n        (S1, l1, u1, j_star1, tau1, K1),\n        (S2, l2, u2, j_star2, tau2, K2),\n        (S3, l3, u3, j_star3, tau3, K3),\n        (S4, l4, u4, j_star4, tau4, K4),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(*case)\n        results.append(result)\n\n    # Print results in the required list-of-lists format\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2728387"}]}