{"hands_on_practices": [{"introduction": "大规模的基因组重编码项目的第一步是量化所需编辑的范围。本练习旨在基于给定的密码子使用频率数据，训练学生计算消除特定密码子所需的同义替换总数，并评估这些替换对基因组一个关键特征——GC含量的整体影响 [@problem_id:2768341]。这有助于从宏观上理解重编码任务的规模和其对基因组基本性质的潜在改变。", "problem": "构建具有抗病毒性的基因重编码生物体的一个核心设计，是在保留编码蛋白质的同时，从基因组中消除一个特定的密码子子集。这利用了遗传密码的冗余性：多个密码子可以编码相同的氨基酸或翻译终止信号。考虑一个编码基因组，总共有 $N_{\\mathrm{tot}}$ 个密码子，密码子频率为 $f_i$（密码子 $i$ 占所有密码子的比例）。假设重编码的目标是通过根据映射 $\\text{TCG}\\rightarrow\\text{AGC}$、$\\text{TCA}\\rightarrow\\text{AGT}$ 和 $\\text{TAG}\\rightarrow\\text{TAA}$ 将集合 $S=\\{\\text{TCG},\\ \\text{TCA},\\ \\text{TAG}\\}$ 中的每个密码子替换为同义替代密码子，从而在所有基因中消除该集合。假设这些替换保留了氨基酸序列和翻译终止，这由标准遗传密码保证。\n\n从第一性原理出发，使用分子生物学中心法则（脱氧核糖核酸(DNA)到核糖核酸(RNA)到蛋白质）、密码子使用频率的定义以及鸟嘌呤-胞嘧啶(GC)含量的定义。DNA序列的GC含量是鸟嘌呤(G)或胞嘧啶(C)核苷酸所占的比例。每个密码子为编码DNA长度贡献三个核苷酸，并为GC计数贡献相应数量的G或C核苷酸。\n\n给定：\n- 编码基因组中的密码子总数为 $N_{\\mathrm{tot}}=1.2\\times 10^{6}$。\n- 待消除密码子的频率为 $f_{\\mathrm{TCG}}=\\frac{1}{20}$，$f_{\\mathrm{TCA}}=\\frac{1}{30}$ 和 $f_{\\mathrm{TAG}}=\\frac{1}{600}$。其余密码子的总频率为 $1-f_{\\mathrm{TCG}}-f_{\\mathrm{TCA}}-f_{\\mathrm{TAG}}$，并且在重编码过程中保持不变。\n- 仅使用一个密码子的GC贡献是其G和C核苷酸的数量这一事实。例如，GC贡献为：$\\text{TCG}\\mapsto 2$，$\\text{AGC}\\mapsto 2$，$\\text{TCA}\\mapsto 1$，$\\text{AGT}\\mapsto 1$，$\\text{TAG}\\mapsto 1$，$\\text{TAA}\\mapsto 0$。\n\n任务：\n1. 根据定义推导一个表达式，用 $N_{\\mathrm{tot}}$ 和 $f_i$ 表示消除 $S$ 所需的同义替换总数，然后进行数值计算。\n2. 将编码基因组的GC含量分数变化定义为 $f_{\\mathrm{GC}}^{\\mathrm{after}}-f_{\\mathrm{GC}}^{\\mathrm{before}}$，其中 $f_{\\mathrm{GC}}$ 是所有编码核苷酸的GC分数。推导一个由指定替换引起的这种变化的通用表达式，然后对给定数据进行数值计算。将GC变化表示为分数（而不是百分比），并给出精确值（不四舍五入）。\n\n将你的最终答案报告为一个双分量行向量 $\\begin{pmatrix}\\text{总替换数}  \\text{GC分数变化}\\end{pmatrix}$。", "solution": "所述问题具有科学依据，内部一致且提法明确。所有必要的数据和定义都已提供，可得到唯一解。我们将按要求进行推导。\n\n分析分为两部分，对应于问题中提出的两个任务。\n\n**第1部分：同义替换总数**\n\n问题要求消除所有属于集合 $S=\\{\\text{TCG}, \\text{TCA}, \\text{TAG}\\}$ 的密码子。替换总数，我们记为 $N_{\\mathrm{repl}}$，是这三个密码子中每一个在整个编码基因组中出现次数的总和。\n\n从第一性原理出发，给定密码子 $i$ 的频率，记为 $f_i$，定义为该密码子出现的次数 $N_i$ 与基因组中密码子总数 $N_{\\mathrm{tot}}$ 的比率。\n$$f_i = \\frac{N_i}{N_{\\mathrm{tot}}}$$\n因此，密码子 $i$ 的出现次数可以表示为：\n$$N_i = f_i N_{\\mathrm{tot}}$$\n替换总数是集合 $S$ 中每个密码子计数的总和：\n$$N_{\\mathrm{repl}} = N_{\\mathrm{TCG}} + N_{\\mathrm{TCA}} + N_{\\mathrm{TAG}}$$\n将每个密码子的 $N_i$ 表达式代入，我们推导出替换总数的通用表达式：\n$$N_{\\mathrm{repl}} = (f_{\\mathrm{TCG}} + f_{\\mathrm{TCA}} + f_{\\mathrm{TAG}}) N_{\\mathrm{tot}}$$\n给定以下数值：\n- 密码子总数：$N_{\\mathrm{tot}} = 1.2 \\times 10^{6}$\n- 密码子频率：$f_{\\mathrm{TCG}} = \\frac{1}{20}$，$f_{\\mathrm{TCA}} = \\frac{1}{30}$ 和 $f_{\\mathrm{TAG}} = \\frac{1}{600}$。\n\n首先，我们计算待消除密码子的频率之和：\n$$\\sum_{i \\in S} f_i = f_{\\mathrm{TCG}} + f_{\\mathrm{TCA}} + f_{\\mathrm{TAG}} = \\frac{1}{20} + \\frac{1}{30} + \\frac{1}{600}$$\n为了对这些分数求和，我们找到一个公分母，即 $600$：\n$$\\sum_{i \\in S} f_i = \\frac{30}{600} + \\frac{20}{600} + \\frac{1}{600} = \\frac{30+20+1}{600} = \\frac{51}{600}$$\n现在，我们计算替换总数：\n$$N_{\\mathrm{repl}} = \\left(\\frac{51}{600}\\right) \\times (1.2 \\times 10^{6}) = \\frac{51}{6 \\times 10^{2}} \\times (12 \\times 10^{5}) = 51 \\times \\left(\\frac{12}{6}\\right) \\times 10^{5-2} = 51 \\times 2 \\times 10^{3} = 102 \\times 10^{3} = 102000$$\n按要求用标准科学记数法表示：\n$$N_{\\mathrm{repl}} = 1.02 \\times 10^{5}$$\n\n**第2部分：鸟嘌呤-胞嘧啶(GC)含量分数变化**\n\nGC含量分数 $f_{\\mathrm{GC}}$ 定义为鸟嘌呤(G)或胞嘧啶(C)核苷酸的总数除以序列中核苷酸的总数。\n\n一个具有 $N_{\\mathrm{tot}}$ 个密码子的编码基因组总共有 $3N_{\\mathrm{tot}}$ 个核苷酸，因为每个密码子由 $3$ 个核苷酸组成。G和C核苷酸的总数 $N_{\\mathrm{GC}}$ 是整个基因组中每个密码子的GC贡献之和。设 $\\text{GC}_i$ 是密码子 $i$ 中G或C核苷酸的数量。总GC计数为：\n$$N_{\\mathrm{GC}} = \\sum_{i} N_i \\times \\text{GC}_i = \\sum_{i} (f_i N_{\\mathrm{tot}}) \\times \\text{GC}_i = N_{\\mathrm{tot}} \\sum_{i} f_i \\text{GC}_i$$\nGC含量分数则为：\n$$f_{\\mathrm{GC}} = \\frac{N_{\\mathrm{GC}}}{3N_{\\mathrm{tot}}} = \\frac{N_{\\mathrm{tot}} \\sum_{i} f_i \\text{GC}_i}{3N_{\\mathrm{tot}}} = \\frac{1}{3} \\sum_{i} f_i \\text{GC}_i$$\nGC含量分数的变化 $\\Delta f_{\\mathrm{GC}}$ 是重编码后的含量 $f_{\\mathrm{GC}}^{\\mathrm{after}}$ 与重编码前的含量 $f_{\\mathrm{GC}}^{\\mathrm{before}}$ 之差。\n$$\\Delta f_{\\mathrm{GC}} = f_{\\mathrm{GC}}^{\\mathrm{after}} - f_{\\mathrm{GC}}^{\\mathrm{before}} = \\frac{1}{3} \\sum_{i} f_i^{\\mathrm{after}} \\text{GC}_i - \\frac{1}{3} \\sum_{i} f_i^{\\mathrm{before}} \\text{GC}_i = \\frac{1}{3} \\sum_{i} (f_i^{\\mathrm{after}} - f_i^{\\mathrm{before}}) \\text{GC}_i$$\n重编码过程仅改变集合 $S$ 中密码子及其同义替换密码子的频率。设 $i \\in S$ 是一个被同义密码子 $\\text{syn}(i)$ 替换的密码子。密码子 $i$ 的频率变为零 ($f_i^{\\mathrm{after}} = 0$)，其原始频率 ($f_i^{\\mathrm{before}}$) 被加到其替换密码子 $\\text{syn}(i)$ 的频率上。对于任何未参与替换的密码子 $j$，$f_j^{\\mathrm{after}} = f_j^{\\mathrm{before}}$。\n\n该总和可以通过只考虑频率发生变化的密码子来简化：\n$$3\\Delta f_{\\mathrm{GC}} = \\sum_{i \\in S} \\left[ (f_i^{\\mathrm{after}} - f_i^{\\mathrm{before}})\\text{GC}_i + (f_{\\text{syn}(i)}^{\\mathrm{after}} - f_{\\text{syn}(i)}^{\\mathrm{before}})\\text{GC}_{\\text{syn}(i)} \\right]$$\n对于每个 $i \\in S$，我们有：\n- $f_i^{\\mathrm{after}} = 0 \\implies f_i^{\\mathrm{after}} - f_i^{\\mathrm{before}} = -f_i^{\\mathrm{before}}$\n- $f_{\\text{syn}(i)}^{\\mathrm{after}} = f_{\\text{syn}(i)}^{\\mathrm{before}} + f_i^{\\mathrm{before}} \\implies f_{\\text{syn}(i)}^{\\mathrm{after}} - f_{\\text{syn}(i)}^{\\mathrm{before}} = f_i^{\\mathrm{before}}$\n将这些代入单个替换对 $(i, \\text{syn}(i))$ 的方程中：\n$$(-f_i^{\\mathrm{before}})\\text{GC}_i + (f_i^{\\mathrm{before}})\\text{GC}_{\\text{syn}(i)} = f_i^{\\mathrm{before}} (\\text{GC}_{\\text{syn}(i)} - \\text{GC}_i)$$\n对所有替换规则求和，得到总变化的通用表达式：\n$$\\Delta f_{\\mathrm{GC}} = \\frac{1}{3} \\sum_{i \\in S} f_i^{\\mathrm{before}} (\\text{GC}_{\\text{syn}(i)} - \\text{GC}_i)$$\n现在我们使用给定的数据：\n- 替换1：$\\text{TCG} \\rightarrow \\text{AGC}$\n  - $f_{\\mathrm{TCG}} = \\frac{1}{20}$\n  - $\\text{GC}_{\\mathrm{TCG}} = 2$\n  - $\\text{GC}_{\\mathrm{AGC}} = 2$\n  - 变化贡献：$\\frac{1}{20} (2 - 2) = 0$\n- 替换2：$\\text{TCA} \\rightarrow \\text{AGT}$\n  - $f_{\\mathrm{TCA}} = \\frac{1}{30}$\n  - $\\text{GC}_{\\mathrm{TCA}} = 1$\n  - $\\text{GC}_{\\mathrm{AGT}} = 1$\n  - 变化贡献：$\\frac{1}{30} (1 - 1) = 0$\n- 替换3：$\\text{TAG} \\rightarrow \\text{TAA}$\n  - $f_{\\mathrm{TAG}} = \\frac{1}{600}$\n  - $\\text{GC}_{\\mathrm{TAG}} = 1$\n  - $\\text{GC}_{\\mathrm{TAA}} = 0$\n  - 变化贡献：$\\frac{1}{600} (0 - 1) = -\\frac{1}{600}$\n\n总变化是这些贡献的总和，再除以 $3$：\n$$\\Delta f_{\\mathrm{GC}} = \\frac{1}{3} \\left( 0 + 0 - \\frac{1}{600} \\right) = \\frac{1}{3} \\left( -\\frac{1}{600} \\right) = -\\frac{1}{1800}$$\n这是GC含量的精确分数变化。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1.02 \\times 10^{5}  -\\frac{1}{1800} \\end{pmatrix}}\n$$", "id": "2768341"}, {"introduction": "基因组重编码并非简单的密码子替换，因为单点改变可能会在紧凑的基因组中引发意想不到的连锁效应。本练习要求学生设计一个算法，以在保留重叠开放阅读框所编码的肽序列完整性的前提下，寻找可行的同义替换方案 [@problem_id:2768399]。这项实践对于理解和处理多层信息编码基因组中的局部约束至关重要。", "problem": "要求您在一个包含同一链上重叠阅读框的编码序列中，形式化、计算并报告密码子级别的同义重编码选项。目标是消除一个指定的目标密码子，同时不改变从重叠框翻译出的肽链。您的推导和程序必须从基本生物学原理出发，并产生一个数学上明确定义、可测试的输出。\n\n基本原理：\n- 分子生物学中心法则指出，脱氧核糖核酸（DNA）转录为核糖核酸（RNA），RNA再翻译为蛋白质。在本问题中，翻译过程使用标准遗传密码直接将DNA密码子建模为氨基酸。\n- 一个密码子是由字母表 {A, C, G, T} 中抽取的三个核苷酸组成的三联体。标准遗传密码定义了一个函数，该函数将每个密码子映射到一个氨基酸或一个终止信号。\n- 同义密码子是指那些映射到相同氨基酸的密码子。密码子简并性意味着对于给定的氨基酸，可能存在多个同义密码子。\n- 一个阅读框中的翻译是通过从指定偏移量开始，将DNA序列划分为不重叠的密码子来定义的。对于一个长度为 $L$ 的DNA序列字符串，和一个框偏移量 $f \\in \\{0,1,2\\}$，翻译出的肽链是通过读取索引为 $i = f, f+3, f+6, \\dots$ 的密码子获得的，直至最大的 $i$ 满足 $i+2 < L$；每个密码子都被映射到其对应的氨基酸。\n\n定义：\n- 设 $S$ 为DNA序列字符串。\n- 设 $p_0 \\in \\{0,1,2\\}$ 为主阅读框偏移量。\n- 设 $q_0 \\in \\{0,1,2\\}$ 为重叠阅读框偏移量（同一链上的备选阅读框）。\n- 设 $t$ 为主阅读框中目标密码子第一个核苷酸的整数索引，满足 $t \\equiv p_0 \\pmod{3}$ 且 $0 \\leq t \\leq L-3$。\n- 设 $X$ 为长度为3的禁用密码子字符串，必须在主阅读框的位置 $t$ 处被消除。\n- 设 $G$ 表示从密码子到氨基酸（单字母代码，可能包括终止符号）的标准遗传密码映射。\n\n需要推导和实现的任务：\n- 考虑将 $S$ 中索引为 $[t, t+1, t+2]$ 的密码子替换为另一个密码子 $c'$，该密码子与原始密码子 $c = S[t:t+3]$ 同义（即 $G(c') = G(c)$），并且 $c' \\neq X$。只有此窗口中的三个核苷酸可以被改变；$S$ 中的所有其他位置必须保持不变。\n- 将框 $f$ 中的翻译肽链函数定义为 $T_f(S)$，它是通过将 $G$ 应用于从偏移量 $f$ 开始的每个完整密码子窗口而获得的。\n- 一个候选密码子 $c'$ 是可行的，当且仅当以下两个条件都成立：\n  1. $T_{p_0}(S') = T_{p_0}(S)$，其中 $S'$ 是将 $S$ 中的 $S'[t:t+3]$ 替换为 $c'$ 后的序列（这强制了主阅读框中的同义替换）。\n  2. $T_{q_0}(S') = T_{q_0}(S)$（这强制了重叠框肽链保持不变）。\n- 可行集是所有此类 $c'$ 的集合。\n\n输出的编码要求：\n- 为确保输出为纯数字，使用映射 $A \\mapsto 0$, $C \\mapsto 1$, $G \\mapsto 2$, $T \\mapsto 3$ 将每个密码子 $b_1 b_2 b_3$ 编码为一个四进制整数，并\n  $$ \\mathrm{code}(b_1 b_2 b_3) = 16 \\cdot \\mathrm{code}(b_1) + 4 \\cdot \\mathrm{code}(b_2) + \\mathrm{code}(b_3). $$\n- 您的程序必须为每个测试用例输出一个对应所有可行 $c'$ 的编码整数的排序列表（升序）。\n\n角度单位不适用。没有物理单位。所有报告的数值输出必须是整数和整数列表。\n\n输入已嵌入您的程序中。不应读取任何外部输入。请使用以下测试套件：\n\n- 案例A（典型的重叠约束，预计有多个可行解）：\n  - $S =$ \"GCCGCCGCTGCCGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 1$\n  - $t = 6$\n  - $X =$ \"GCT\"\n\n- 案例B（经过特殊设计，由于唯一编码的重叠密码子限制了所有三个位置，因此不会产生可行解）：\n  - $S =$ \"GCCGCCGCCGATGTGGGCGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 2$\n  - $t = 12$\n  - $X =$ \"GTG\"\n\n- 案例C（边界条件，目标密码子的一部分位于重叠框中任何完整密码子之外）：\n  - $S =$ \"GCTGCCGCCGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 1$\n  - $t = 0$\n  - $X =$ \"GCT\"\n\n- 案例D（重叠框与主阅读框相同，因此除了被禁用的密码子外，所有主阅读框的同义密码子都是可行的）：\n  - $S =$ \"GCCTCGGCCGCC\"\n  - $p_0 = 0$\n  - $q_0 = 0$\n  - $t = 3$\n  - $X =$ \"TCG\"\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素本身也是一个由方括号括起来的逗号分隔的整数列表。例如，输出格式必须如下所示：\n\"[ [a,b], [c], [d,e,f], [ ] ]\"\n但不含任何空格。具体来说，您的程序必须打印：\n\"[[caseA_list],[caseB_list],[caseC_list],[caseD_list]]\"\n其中每个 \"caseX_list\" 是一个按升序排序且不含空格的编码整数列表。", "solution": "该问题要求形式化并计算一组可行的同义密码子，这些密码子可以替换主阅读框中的一个目标密码子，其约束条件是重叠阅读框的肽链序列保持不变。我们首先建立指导该解决方案的数学和生物学原理。\n\n设DNA序列是一个长度为 $L$ 的字符串 $S$，其字母表为 $\\{A, C, G, T\\}$。设 $G$ 是代表标准遗传密码的函数，它将一个3核苷酸的密码子映射到一个氨基酸或一个终止信号。在偏移量为 $f \\in \\{0, 1, 2\\}$ 的阅读框中对 $S$ 进行翻译的结果记为 $T_f(S)$，它是通过将 $G$ 应用于一系列密码子 $S[i:i+3]$（其中 $i = f, f+3, f+6, \\dots$ 且 $i+2  L$）而产生的。\n\n问题在于找到所有能够替换主阅读框 $p_0$ 中给定起始索引 $t$ 处的原始密码子 $c = S[t:t+3]$ 的密码子 $c'$。替换密码子 $c'$ 必须满足两个条件：\n1. 来自主阅读框 $p_0$ 的肽链被保留。这是一个同义突变，意味着 $G(c') = G(c)$。此外，替换密码子 $c'$ 不得是特定的禁用密码子 $X$，即 $c' \\neq X$。\n2. 来自重叠阅读框 $q_0$ 的肽链被保留，即 $T_{q_0}(S') = T_{q_0}(S)$，其中 $S'$ 是将索引 $[t, t+1, t+2]$ 处的子字符串替换为 $c'$ 后的序列 $S$。\n\n总体方法是首先基于主阅读框约束生成一个候选密码子集合，然后使用更复杂的重叠框约束来筛选这个集合。\n\n首先，我们处理主阅读框约束。原始密码子是 $c = S[t:t+3]$，它翻译为氨基酸 $A_c = G(c)$。任何有效的替换 $c'$ 也必须翻译为 $A_c$。这定义了一个同义密码子集合。从这个集合中，我们排除了禁用的密码子 $X$。由此产生的候选密码子集合是：\n$$ \\mathcal{C}_{\\text{cand}} = \\{ c' \\mid G(c') = G(c) \\land c' \\neq X \\} $$\n这个集合包含了所有满足第一个条件的潜在解。\n\n接下来，我们处理重叠框约束。对索引 $t, t+1, t+2$ 处的三个核苷酸进行的修改可能会改变重叠阅读框 $q_0$ 中的密码子。框 $q_0$ 中的一个密码子始于索引 $j$，满足 $j \\equiv q_0 \\pmod{3}$。这样一个占据索引 $[j, j+1, j+2]$ 的密码子，如果其窗口与修改窗口 $[t, t+1, t+2]$ 重叠，就会受到影响。这个条件当且仅当 $t-2 \\le j \\le t+2$ 时成立。\n\n对于每个候选密码子 $c' \\in \\mathcal{C}_{\\text{cand}}$，我们必须验证它不会改变重叠框的翻译。这要求我们检查框 $q_0$ 中每个受影响的密码子。设 $c' = n'_0n'_1n'_2$。新序列 $S'$ 与 $S$ 相同，除了 $S'[t]=n'_0$，$S'[t+1]=n'_1$，以及 $S'[t+2]=n'_2$。\n对于每个满足 $j \\equiv q_0 \\pmod{3}$ 且 $t-2 \\le j \\le t+2$ 的整数 $j$，我们必须检查氨基酸是否被保留。我们只考虑完整的密码子，即那些满足 $j \\ge 0$ 且 $j+3 \\le L$ 的密码子。对于每个这样的有效 $j$，设原始的 $q_0$ 框密码子为 $c_{q,j} = S[j:j+3]$，新密码子为 $c'_{q,j}=S'[j:j+3]$。约束 $T_{q_0}(S') = T_{q_0}(S)$ 简化为一组局部条件：\n$$ G(c'_{q,j}) = G(c_{q,j}) \\quad \\forall j \\in \\{k \\mid k \\equiv q_0 \\pmod 3 \\land t-2 \\le k \\le t+2 \\land k \\ge 0 \\land k+3 \\le L\\} $$\n新的密码子 $c'_{q,j}$ 由来自 $c'$ 的核苷酸（如果它们的索引落在 $[t, t+1, t+2]$ 内）和来自原始序列 $S$ 的核苷酸（其他情况）组成。来自 $\\mathcal{C}_{\\text{cand}}$ 的候选密码子 $c'$ 被认为是可行的，当且仅当它对 $q_0$ 框中所有受影响的完整密码子都满足此条件。\n\n让我们以案例B为例进行具体分析：\n- $S = \\text{\"GCCGCCGCCGATGTGGGCGCCGCC\"}$ ($L=24$)\n- $p_0 = 0$, $q_0 = 2$, $t = 12$, $X = \\text{\"GTG\"}$\n主阅读框中的原始密码子是 $c = S[12:15] = \\text{\"GTG\"}$，编码缬氨酸（Valine，$G(\\text{GTG}) = V$）。缬氨酸的同义密码子是 GTT, GTC, GTA, GTG。由于 $X=\\text{GTG}$ 被禁用，候选集为 $\\mathcal{C}_{\\text{cand}} = \\{\\text{GTT, GTC, GTA}\\}$。\n\n修改发生在索引 12, 13, 14 处。重叠框是 $q_0=2$。受影响的密码子起始索引 $j$ 必须满足 $j \\equiv 2 \\pmod{3}$ 和 $12-2 \\le j \\le 12+2$，即 $10 \\le j \\le 14$。此范围内满足 $j \\equiv 2 \\pmod 3$ 的整数是 $j=11$ 和 $j=14$。两者都构成完整的密码子。\n\n对于 $j=11$：受影响的密码子位于 $[11, 12, 13]$。\n- 原始密码子：$c_{q,11} = S[11:14] = \\text{\"TGT\"}$，编码半胱氨酸（Cysteine，$G(\\text{TGT})=C$）。\n- 设 $c' = n'_0 n'_1 n'_2$。新密码子为 $c'_{q,11} = S[11]S'[12]S'[13] = \\text{\"T\"}n'_0n'_1$。\n- 约束：$G(\\text{T}n'_0n'_1)$ 必须是半胱氨酸。半胱氨酸的密码子是 TGT 和 TGC。因此，$n'_0n'_1$ 必须是 \"GT\" 或 \"GC\"。\n\n对于 $j=14$：受影响的密码子位于 $[14, 15, 16]$。\n- 原始密码子：$c_{q,14} = S[14:17] = \\text{\"GGC\"}$，编码甘氨酸（Glycine，$G(\\text{GGC})=G$）。\n- 新密码子为 $c'_{q,14} = S'[14]S[15]S[16] = n'_2\\text{\"GG\"}$。\n- 约束：$G(n'_2\\text{GG})$ 必须是甘氨酸。甘氨酸的密码子是 GGT, GGC, GGA, GGG。它们的形式都是 $GGN$。我们的新密码子形式是 $NGG$。形式为 $NGG$ 的密码子只有 AGG（精氨酸）、CGG（精氨酸）、GGG（甘氨酸）和 TGG（色氨酸）。为了使氨基酸为甘氨酸，$n'_2$ 必须是 'G'。\n\n结合候选密码子 $c' = n'_0n'_1n'_2$ 的约束条件：\n1. $G(n'_0n'_1n'_2)$ 是缬氨酸，且 $c' \\neq \\text{GTG}$。\n2. $n'_0n'_1$ 是 \"GT\" 或 \"GC\"。\n3. $n'_2$ 是 \"G\"。\n\n我们测试来自 $\\mathcal{C}_{\\text{cand}}$ 的候选密码子：\n- $c'=\\text{GTT}$：$n'_0n'_1 = \\text{GT}$，$n'_2=\\text{T}$。不满足条件3。\n- $c'=\\text{GTC}$：$n'_0n'_1 = \\text{GT}$，$n'_2=\\text{C}$。不满足条件3。\n- $c'=\\text{GTA}$：$n'_0n'_1 = \\text{GT}$，$n'_2=\\text{A}$。不满足条件3。\n\n没有一个候选密码子满足所有约束条件。因此，可行密码子集为空，这与问题对此测试用例的预期相符。将同样严谨的、基于原理的推导应用于所有案例，以产生最终的计算结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the codon recoding problem for a suite of test cases.\n    The solution is derived from first principles of molecular biology,\n    including the standard genetic code and reading frame translation.\n    \"\"\"\n\n    # The standard genetic code mapping DNA codons to single-letter amino acid codes.\n    # '*' denotes a stop codon.\n    GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n\n    BASE_TO_INT = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    def encode_codon(codon):\n        \"\"\"Encodes a 3-base codon string into a base-4 integer.\"\"\"\n        val = 16 * BASE_TO_INT[codon[0]] + 4 * BASE_TO_INT[codon[1]] + BASE_TO_INT[codon[2]]\n        return val\n\n    # Generate all 64 possible codons once.\n    all_codons = []\n    int_to_base = {0: 'A', 1: 'C', 2: 'G', 3: 'T'}\n    for i in range(64):\n        n = i\n        c = \"\"\n        c = int_to_base[n % 4] + c\n        n //= 4\n        c = int_to_base[n % 4] + c\n        n //= 4\n        c = int_to_base[n % 4] + c\n        all_codons.append(c)\n    \n    # Define test cases as specified in the problem statement.\n    test_cases = [\n        {\"S\": \"GCCGCCGCTGCCGCCGCC\", \"p0\": 0, \"q0\": 1, \"t\": 6, \"X\": \"GCT\"},\n        {\"S\": \"GCCGCCGCCGATGTGGGCGCCGCC\", \"p0\": 0, \"q0\": 2, \"t\": 12, \"X\": \"GTG\"},\n        {\"S\": \"GCTGCCGCCGCCGCC\", \"p0\": 0, \"q0\": 1, \"t\": 0, \"X\": \"GCT\"},\n        {\"S\": \"GCCTCGGCCGCC\", \"p0\": 0, \"q0\": 0, \"t\": 3, \"X\": \"TCG\"},\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        S, p0, q0, t, X = case[\"S\"], case[\"p0\"], case[\"q0\"], case[\"t\"], case[\"X\"]\n        L = len(S)\n\n        # 1. Determine candidate codons based on primary frame constraint\n        original_codon = S[t : t + 3]\n        target_aa = GENETIC_CODE[original_codon]\n        \n        candidate_codons = []\n        for codon in all_codons:\n            if GENETIC_CODE[codon] == target_aa and codon != X:\n                candidate_codons.append(codon)\n\n        # 2. Filter candidates based on overlapping frame constraint\n        feasible_codons = []\n        for c_prime in candidate_codons:\n            is_feasible = True\n            \n            # The range of start indices 'j' for q0-frame codons affected by a\n            # change at [t, t+1, t+2] is [t-2, t+2].\n            for j_start in range(t - 2, t + 3):\n                # Check if j_start is a valid start for a q0-frame codon\n                if j_start % 3 == q0:\n                    # Check if the codon is complete within the sequence boundaries\n                    if j_start >= 0 and j_start + 3 = L:\n                        original_q_codon = S[j_start:j_start + 3]\n                        \n                        # Construct the new q0-frame codon by overlaying c_prime\n                        new_q_codon_list = list(original_q_codon)\n                        for i in range(3): # iterate through positions in codon\n                            global_idx = j_start + i\n                            if t = global_idx  t + 3:\n                                c_prime_idx = global_idx - t\n                                new_q_codon_list[i] = c_prime[c_prime_idx]\n                        new_q_codon = \"\".join(new_q_codon_list)\n                        \n                        if GENETIC_CODE[original_q_codon] != GENETIC_CODE[new_q_codon]:\n                            is_feasible = False\n                            break\n            \n            if is_feasible:\n                feasible_codons.append(c_prime)\n                \n        # 3. Encode feasible codons and sort them\n        encoded_results = sorted([encode_codon(codon) for codon in feasible_codons])\n        final_results.append(encoded_results)\n\n    # 4. Format and print the final output exactly as required\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, r))}]\" for r in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2768399"}, {"introduction": "当存在多种可行的重编码方案时，我们需要一个系统性的方法来选择“最优”解。这项高级练习引导学生将复杂的密码子替换任务构建为一个整数线性规划（ILP）问题，旨在平衡消除禁用密码子和保护关键调控元件这两个目标 [@problem_id:2768361]。这种优化方法代表了合成生物学设计中解决多目标权衡问题的强大策略。", "problem": "您的任务是形式化同义密码子替换过程，用于重编码蛋白质编码序列，以消除一组特定的禁用密码子，同时最大限度地减少对稀有调控元件的破坏。其生物学基础是分子生物学中心法则、遗传密码的简并性（即多个密码子编码同一个氨基酸），以及改变编码核苷酸可能会无意中改变与编码区重叠的稀有调控基序这一观察结果。在为抗病毒而设计的重编码生物体中，一种策略是消除宿主重新分配或禁用的密码子集的使用，前提是通过将变化限制在同义替换范围内来保留蛋白质序列。我们将此问题编码为一个整数线性规划 (ILP)，并为一个小规模测试套件计算最优目标值。\n\n构建并求解以下整数线性规划 (ILP)。给定一个长度为 $N$ 个密码子的编码序列，密码子由 $i \\in \\{1,\\dots,N\\}$ 索引，每个密码子在连续的核苷酸索引集 $\\{1,\\dots,3N\\}$ 中占据核苷酸位置 $j \\in \\{3i-2,3i-1,3i\\}$。令 $c_i$ 表示位置 $i$ 的原始密码子。令 $\\mathcal{B}$ 为必须消除的禁用密码子集合。对于每个位置 $i$，令 $\\mathcal{S}_i$ 为同义密码子集合（所有与 $c_i$ 编码相同氨基酸的密码子）。对于索引集 $\\mathcal{E}$ 中的每个调控元件 $e$，令 $P_e \\subseteq \\{1,\\dots,3N\\}$ 为该元件所覆盖的核苷酸索引集合，并令 $w_e \\ge 0$ 为其惩罚权重。决策变量为：\n- 对于每个 $i$ 和 $s \\in \\mathcal{S}_i$，$x_{i,s} \\in \\{0,1\\}$，表示在密码子位置 $i$ 选择同义密码子 $s$。\n- 对于每个核苷酸位置 $j \\in \\{1,\\dots,3N\\}$，$u_j \\in \\{0,1\\}$，表示核苷酸 $j$ 相对于原始序列是否发生改变。\n- 对于每个调控元件 $e \\in \\mathcal{E}$，$y_e \\in \\{0,1\\}$，表示 $P_e$ 中的任何核苷酸是否被改变。\n\n令 $d_{i,s,b} \\in \\{0,1\\}$ 表示在位置 $i$ 的密码子 $s$ 的第 $b$ 个碱基是否与原始密码子 $c_i$ 的第 $b$ 个碱基不同，其中 $b \\in \\{1,2,3\\}$。定义从密码子位置 $i$ 和碱基索引 $b$ 到核苷酸索引 $j = 3i-3+b$ 的映射。\n\n该 ILP 为：\n- 目标：最小化\n$$\n\\sum_{e \\in \\mathcal{E}} w_e \\, y_e\n$$\n- 约束条件：\n1) 每个位置的同义密码子选择：\n$$\n\\sum_{s \\in \\mathcal{S}_i} x_{i,s} = 1 \\quad \\text{for all } i \\in \\{1,\\dots,N\\}.\n$$\n2) 消除禁用密码子：\n$$\nx_{i,s} = 0 \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; s \\in \\mathcal{S}_i \\cap \\mathcal{B}.\n$$\n3) 核苷酸改变指示符与所选同义密码子保持一致：\n$$\nu_{3i-3+b} = \\sum_{s \\in \\mathcal{S}_i} d_{i,s,b} \\, x_{i,s} \\quad \\text{for all } i \\in \\{1,\\dots,N\\}, \\; b \\in \\{1,2,3\\}.\n$$\n4) 如果任何重叠的核苷酸发生改变，则触发调控元件惩罚：\n$$\ny_e \\ge u_j \\quad \\text{for all } e \\in \\mathcal{E}, \\; j \\in P_e.\n$$\n所有变量 $x_{i,s}$、$u_j$ 和 $y_e$ 均为二进制变量。\n\n您必须编写一个程序，为下面的每个测试实例计算该 ILP 的最优目标值。如果模型不可行（即没有同义密码子的选择能满足禁用密码子的约束），则对该测试用例输出 $-1$。\n\n同义密码子集由氨基酸同一性定义，并且必须保留蛋白质序列。对于该测试套件，您可以假定以下同义密码子类别：\n- Arginine (Arg): $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}, \\texttt{AGA}, \\texttt{AGG}\\}$。\n- Lysine (Lys): $\\{\\texttt{AAA}, \\texttt{AAG}\\}$。\n- Alanine (Ala): $\\{\\texttt{GCT}, \\texttt{GCC}, \\texttt{GCA}, \\texttt{GCG}\\}$。\n\n每个密码子位置的氨基酸由原始密码子 $c_i$ 决定，并且不得改变。核苷酸使用 DNA 字母表 $\\{\\texttt{A}, \\texttt{C}, \\texttt{G}, \\texttt{T}\\}$ 指定。\n\n测试套件（每个测试用例都是独立且自包含的）：\n- 情况 1：\n  - 原始密码子列表 $(c_i)_{i=1}^N$: $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AAA})$，其中 $N = 3$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n  - 具有核苷酸索引集和权重的调控元件 $\\mathcal{E}$：\n    - $e_1$: $P_{e_1} = \\{2,3,4\\}$, $w_{e_1} = 2$。\n    - $e_2$: $P_{e_2} = \\{6,7\\}$, $w_{e_2} = 1$。\n- 情况 2：\n  - 原始密码子列表 $(\\texttt{AAA}, \\texttt{AGA}, \\texttt{AAG})$，其中 $N = 3$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}\\}$。\n  - 调控元件：\n    - $e_1$: $P_{e_1} = \\{4,5,6\\}, w_{e_1} = 2$。\n    - $e_2$: $P_{e_2} = \\{1,2,3\\}, w_{e_2} = 1$。\n- 情况 3：\n  - 原始密码子列表 $(\\texttt{AAA}, \\texttt{AAG})$，其中 $N = 2$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AAA}, \\texttt{AAG}\\}$。\n  - 调控元件：无 (空集 $\\mathcal{E}$)。\n- 情况 4：\n  - 原始密码子列表 $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AGG}, \\texttt{AAG})$，其中 $N = 4$。\n  - 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n  - 调控元件：\n    - $e_1$: $P_{e_1} = \\{2,3,4\\}, w_{e_1} = 1$。\n    - $e_2$: $P_{e_2} = \\{5,6,7\\}, w_{e_2} = 1$。\n    - $e_3$: $P_{e_3} = \\{9\\}, $w_{e_3} = 2$。\n\n程序要求：\n- 您的程序必须为每种情况构建并求解 ILP。由于实例规模很小，您可以通过枚举满足约束 2 的所有允许的同义密码子组合，并根据约束 3-4 中的触发规则选择最小的目标值来精确求解。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是一个整数；使用 $-1$ 表示不可行。", "solution": "该问题已经过验证，被认为是一个基于合成生物学既定原则的、适定的、有科学依据的优化问题。它完整、一致，并且没有任何指定的缺陷。问题陈述本身提供了一个正式的整数线性规划 (ILP) 公式。然而，正如提示中所指出的，测试实例的组合复杂度足够小，可以通过枚举可行解空间来找到直接且精确的解，而无需借助通用的 ILP 求解器。这种方法在这里计算上是可行的，并避免了不必要的实现开销。\n\n该策略的核心是，对于每个密码子位置 $i \\in \\{1, \\dots, N\\}$，确定允许的同义密码子集合，这些密码子既能保留原始密码子 $c_i$ 编码的氨基酸，又不在禁用集 $\\mathcal{B}$ 中。重编码序列的可行集是这些允许的同义密码子集的笛卡尔积。对于每个候选重编码序列，我们通过识别相对于原始序列已改变的核苷酸位置集合，并对所有其位置集 $P_e$ 与这些变化有交集的调控元件 $e$ 的权重 $w_e$ 求和，来计算总惩罚。产生最小总惩罚的解即为最优解。如果对于任何位置 $i$，允许的同义密码子集合为空，则该问题不可行。\n\n相关氨基酸的同义密码子集定义如下：\n- Arginine (Arg): $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}, \\texttt{AGA}, \\texttt{AGG}\\}$\n- Lysine (Lys): $\\{\\texttt{AAA}, \\texttt{AAG}\\}$\n- Alanine (Ala): $\\{\\texttt{GCT}, \\texttt{GCC}, \\texttt{GCA}, \\texttt{GCG}\\}$\n\n现在让我们将此过程应用于每个测试用例。\n\n情况 1：\n- 原始密码子 $(c_i)_{i=1}^3$: $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AAA})$。这是一个长度为 N=3 个密码子的序列，编码 (Arg, Ala, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n- 调控元件：$e_1$ 对应 $P_{e_1} = \\{2,3,4\\}, w_{e_1} = 2$；$e_2$ 对应 $P_{e_2} = \\{6,7\\}, w_{e_2} = 1$。\n\n在位置 $i=1$，原始密码子是 $\\texttt{AGA}$，它被禁用了。允许的 Arg 同义密码子是 $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}\\}$。\n在位置 $i=2$，原始密码子是 $\\texttt{GCT}$，未被禁用。所有 Ala 同义密码子 $\\{\\texttt{GCT}, \\texttt{GCC}, \\texttt{GCA}, \\texttt{GCG}\\}$ 都是允许的。\n在位置 $i=3$，原始密码子是 $\\texttt{AAA}$，未被禁用。所有 Lys 同义密码子 $\\{\\texttt{AAA}, \\texttt{AAG}\\}$ 都是允许的。\n该问题是可行的。\n\n为了最小化目标 $\\sum w_e y_e$，我们必须最小化区域 $P_{e_1}$ 和 $P_{e_2}$ 中的核苷酸变化。\n- 在位置 $i=1$，我们必须改变 $\\texttt{AGA}$。从允许集合中能最小化核苷酸变化的替换是 $\\texttt{CGA}$，它与 $\\texttt{AGA}$ 仅在密码子的第一个碱基上不同。这对应于仅在核苷酸索引 $j=1$ 处发生变化。\n- 在位置 $i=2$，我们可以选择原始密码子 $\\texttt{GCT}$，这不会在核苷酸索引 $j \\in \\{4,5,6\\}$ 处引起任何变化。\n- 在位置 $i=3$，我们可以选择原始密码子 $\\texttt{AAA}$，这不会在核苷酸索引 $j \\in \\{7,8,9\\}$ 处引起任何变化。\n\n因此，最优的重编码序列是 $(\\texttt{CGA}, \\texttt{GCT}, \\texttt{AAA})$。改变的核苷酸索引集是 $\\{1\\}$。\n惩罚计算如下：\n- 元件 $e_1$：$P_{e_1} = \\{2,3,4\\}$。与改变的集合 $\\{1\\}$ 的交集为空。因此，$y_1=0$。\n- 元件 $e_2$：$P_{e_2} = \\{6,7\\}$。与改变的集合 $\\{1\\}$ 的交集为空。因此，$y_2=0$。\n总惩罚为 $w_1 y_1 + w_2 y_2 = 2 \\cdot 0 + 1 \\cdot 0 = 0$。\n最优目标值为 $0$。\n\n情况 2：\n- 原始密码子 $(c_i)_{i=1}^3$: $(\\texttt{AAA}, \\texttt{AGA}, \\texttt{AAG})$。这是一个长度为 N=3 个密码子的序列，编码 (Lys, Arg, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}\\}$。\n- 调控元件：$e_1$ 对应 $P_{e_1} = \\{4,5,6\\}, w_{e_1} = 2$；$e_2$ 对应 $P_{e_2} = \\{1,2,3\\}, w_{e_2} = 1$。\n\n该问题是可行的，因为所有位置都存在非禁用的同义密码子。\n- 位置 $i=1$：原始密码子是 $\\texttt{AAA}$，未被禁用。为避免来自 $e_2$ ($P_{e_2}=\\{1,2,3\\}$) 的惩罚，我们选择 $\\texttt{AAA}$，不引起任何变化。\n- 位置 $i=2$：原始密码子是 $\\texttt{AGA}$，被禁用。我们必须从允许的 Arg 同义密码子 $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}, \\texttt{AGG}\\}$ 中选择。每一次替换都必然在位置 2 的密码子内（核苷酸索引 $\\{4,5,6\\}$）引起至少一个核苷酸变化。例如，用 $\\texttt{CGA}$ 替换 $\\texttt{AGA}$ 会改变索引 4，用 $\\texttt{AGG}$ 替换会改变索引 6。由于 $P_{e_1} = \\{4,5,6\\}$，此密码子位置的任何改变都将触发 $e_1$ 的惩罚。因此，$y_1=1$ 是不可避免的。\n- 位置 $i=3$：原始密码子是 $\\texttt{AAG}$，未被禁用。我们选择 $\\texttt{AAG}$ 以不引起任何变化。\n\n一种最小化改变的策略是选择 $(\\texttt{AAA}, \\texttt{AGG}, \\texttt{AAG})$。唯一的变化发生在核苷酸索引 $j=6$ 处（从 $\\texttt{AGA}$ 到 $\\texttt{AGG}$）。\n改变的索引集是 $\\{6\\}$。\n- 元件 $e_1$：$P_{e_1}=\\{4,5,6\\}$。交集是 $\\{6\\}$。$y_1=1$。惩罚贡献为 $w_1 = 2$。\n- 元件 $e_2$：$P_{e_2}=\\{1,2,3\\}$。交集为空。$y_2=0$。惩罚贡献为 $0$。\n最小总惩罚为 $2$。\n\n情况 3：\n- 原始密码子 $(c_i)_{i=1}^2$: $(\\texttt{AAA}, \\texttt{AAG})$。这是一个长度为 N=2 个密码子的序列，编码 (Lys, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AAA}, \\texttt{AAG}\\}$。\n- 调控元件：无 ($\\mathcal{E} = \\emptyset$)。\n\n在位置 $i=1$，密码子是 $\\texttt{AAA}$。氨基酸是赖氨酸 (Lysine)，其整个同义密码子集是 $\\{\\texttt{AAA}, \\texttt{AAG}\\}$。这两个密码子都在禁用集 $\\mathcal{B}$ 中。因此，该位置没有允许的同义密码子。\n该问题不可行。结果为 $-1$。\n\n情况 4：\n- 原始密码子 $(c_i)_{i=1}^4$: $(\\texttt{AGA}, \\texttt{GCT}, \\texttt{AGG}, \\texttt{AAG})$。这是一个长度为 N=4 个密码子的序列，编码 (Arg, Ala, Arg, Lys)。\n- 禁用集 $\\mathcal{B} = \\{\\texttt{AGA}, \\texttt{AGG}\\}$。\n- 调控元件：$e_1: P_{e_1}=\\{2,3,4\\}, w_{e_1}=1$；$e_2: P_{e_2}=\\{5,6,7\\}, w_{e_2}=1$；$e_3: P_{e_3}=\\{9\\}, w_{e_3}=2$。\n\n该问题是可行的。位置 $i=1$ 和 $i=3$ 的密码子被禁用，但有允许的 Arg 同义密码子。\n- 位置 $i=1$ ($\\texttt{AGA}$，禁用)：为最小化影响 $P_{e_1}=\\{2,3,4\\}$ 的改变，我们选择 $\\texttt{CGA}$。这只改变了核苷酸 $j=1$。这个选择不会触发任何惩罚。\n- 位置 $i=2$ ($\\texttt{GCT}$，未禁用)：我们选择 $\\texttt{GCT}$，不引起任何改变。\n- 位置 $i=3$ ($\\texttt{AGG}$，禁用)：我们必须改变这个密码子。允许的同义密码子是 $\\{\\texttt{CGT}, \\texttt{CGC}, \\texttt{CGA}, \\texttt{CGG}\\}$。为了选择最佳选项，我们分析它们相对于 $\\texttt{AGG}$ 在核苷酸索引 $j \\in \\{7,8,9\\}$ 处引起的改变。\n    - vs $\\texttt{CGT}$：在 $j \\in \\{7,9\\}$ 处改变。\n    - vs $\\texttt{CGC}$：在 $j \\in \\{7,9\\}$ 处改变。\n    - vs $\\texttt{CGA}$：在 $j \\in \\{7,9\\}$ 处改变。\n    - vs $\\texttt{CGG}$：在 $j \\in \\{7\\}$ 处改变。\n选择 $\\texttt{CGG}$ 是最优的，因为它只改变了核苷酸 $j=7$。这个改变落在 $P_{e_2}=\\{5,6,7\\}$ 内，触发了 $w_2=1$ 的惩罚。这个惩罚是不可避免的，因为该位置的所有允许同义密码子都会改变核苷酸 $j=7$。选择 $\\texttt{CGG}$ 避免了在 $j=9$ 处的改变，从而避免了更大的惩罚 $w_3=2$。\n- 位置 $i=4$ ($\\texttt{AAG}$，未禁用)：我们选择 $\\texttt{AAG}$，不引起任何改变。\n\n最优策略导致一个类似 $(\\texttt{CGA}, \\texttt{GCT}, \\texttt{CGG}, \\texttt{AAG})$ 的重编码序列。改变的核苷酸索引集是 $\\{1, 7\\}$。\n- $e_1$：$P_{e_1}=\\{2,3,4\\}$。与 $\\{1,7\\}$ 的交集为空。$y_1=0$。\n- $e_2$：$P_{e_2}=\\{5,6,7\\}$。交集是 $\\{7\\}$。$y_2=1$。惩罚贡献为 $w_2=1$。\n- $e_3$：$P_{e_3}=\\{9\\}$。交集为空。$y_3=0$。\n最小总惩罚为 $1$。\n\n最终结果总结：$[0, 2, -1, 1]$。", "answer": "```python\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the codon replacement problem by enumerating all valid combinations\n    of synonymous codons and calculating the minimum regulatory penalty.\n    \"\"\"\n\n    # Define synonym sets and map codons to their amino acid / synonym group\n    synonym_map = {\n        'Arg': {'CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'},\n        'Lys': {'AAA', 'AAG'},\n        'Ala': {'GCT', 'GCC', 'GCA', 'GCG'}\n    }\n    codon_to_aa = {codon: aa for aa, codons in synonym_map.items() for codon in codons}\n\n    # Define the test suite from the problem statement\n    test_cases = [\n        {\n            'original_codons': ('AGA', 'GCT', 'AAA'),\n            'banned_codons': {'AGA', 'AGG'},\n            'reg_elements': [\n                {'P': {2, 3, 4}, 'w': 2},\n                {'P': {6, 7}, 'w': 1}\n            ]\n        },\n        {\n            'original_codons': ('AAA', 'AGA', 'AAG'),\n            'banned_codons': {'AGA'},\n            'reg_elements': [\n                {'P': {4, 5, 6}, 'w': 2},\n                {'P': {1, 2, 3}, 'w': 1}\n            ]\n        },\n        {\n            'original_codons': ('AAA', 'AAG'),\n            'banned_codons': {'AAA', 'AAG'},\n            'reg_elements': []\n        },\n        {\n            'original_codons': ('AGA', 'GCT', 'AGG', 'AAG'),\n            'banned_codons': {'AGA', 'AGG'},\n            'reg_elements': [\n                {'P': {2, 3, 4}, 'w': 1},\n                {'P': {5, 6, 7}, 'w': 1},\n                {'P': {9}, 'w': 2}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        original_codons = case['original_codons']\n        banned_codons = case['banned_codons']\n        reg_elements = case['reg_elements']\n        num_codons = len(original_codons)\n\n        # Step 1: Determine the set of allowed synonyms for each codon position.\n        allowed_synonyms_per_pos = []\n        is_infeasible = False\n        for i in range(num_codons):\n            codon = original_codons[i]\n            if codon not in codon_to_aa:\n                 # This case should not happen with the provided data\n                 is_infeasible = True\n                 break\n\n            aa = codon_to_aa[codon]\n            synonyms = synonym_map[aa]\n            allowed = sorted(list(synonyms - banned_codons)) # Sort for deterministic behavior\n            \n            if not allowed:\n                is_infeasible = True\n                break\n            allowed_synonyms_per_pos.append(allowed)\n        \n        if is_infeasible:\n            results.append(-1)\n            continue\n\n        # Step 2: Enumerate all combinations and find the one with the minimum penalty.\n        min_penalty = float('inf')\n        \n        # Use itertools.product to get the Cartesian product of allowed synonym sets.\n        for new_codon_sequence in itertools.product(*allowed_synonyms_per_pos):\n            # Step 3: For the current combination, find all changed nucleotide indices.\n            changed_indices = set()\n            for i in range(num_codons):\n                original_codon = original_codons[i]\n                new_codon = new_codon_sequence[i]\n                if original_codon != new_codon:\n                    for base_idx in range(3): # base_idx is 0, 1, or 2\n                        if original_codon[base_idx] != new_codon[base_idx]:\n                            # Nucleotide index j = 3*i + base_idx + 1 (1-based)\n                            changed_indices.add(3 * i + base_idx + 1)\n            \n            # Step 4: Calculate the total penalty for this set of changes.\n            current_penalty = 0\n            if reg_elements:\n                for element in reg_elements:\n                    p_e = element['P']\n                    w_e = element['w']\n                    # Check for a non-empty intersection between changed indices and the element's positions.\n                    if not changed_indices.isdisjoint(p_e):\n                        current_penalty += w_e\n            \n            min_penalty = min(min_penalty, current_penalty)\n            # Optimization: if min_penalty reaches 0, no better solution can be found.\n            if min_penalty == 0:\n                break\n        \n        if min_penalty == float('inf'):\n            # This case occurs if there are no reg_elements, so penalty is always 0.\n            results.append(0)\n        else:\n            results.append(min_penalty)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2768361"}]}