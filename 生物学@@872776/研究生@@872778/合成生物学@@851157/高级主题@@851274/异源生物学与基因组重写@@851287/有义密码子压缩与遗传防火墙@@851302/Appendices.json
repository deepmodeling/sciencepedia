{"hands_on_practices": [{"introduction": "设计一个压缩的遗传密码是构建基因防火墙的第一步，也是最关键的一步。我们不能随意地删除密码子，而是需要一种系统性的方法来选择一个最小的密码子集合，同时确保该集合仍能支持所有必需蛋白质的表达。这个练习将指导你如何将这个生物设计问题形式化为一个整数线性规划（ILP）问题，从而能够严谨地确定最优的密码子保留方案，以满足给定蛋白质组的需求和工程约束。", "problem": "您的任务是将一个用于基因防火墙的最简有义密码子压缩问题表述为一个整数线性规划（ILP）并求解。其生物学基础是分子生物学的中心法则，即脱氧核糖核酸（DNA）转录为核糖核酸（RNA），再翻译成蛋白质。翻译过程使用从密码子三联体到氨基酸的标准映射。有义密码子压缩通过保留一部分有义密码子来减少遗传密码的冗余，同时确保给定编码序列集所需的所有氨基酸在重新编码后仍可被编码。目标是在每个密码子有实际使用限制（容量）和存在可选的不可保留的禁用密码子（例如，因为它们被重分配给非标准氨基酸以实施基因防火墙）的条件下，最小化保留的有义密码子数量，同时确保在所有给定的编码序列中实现对所有氨基酸的完全覆盖。\n\n形式化定义：\n- 设 $\\mathcal{S}$ 为一个编码序列的集合，这些序列由字母表 $\\{A, C, G, T\\}$ 构成，每个序列的长度都能被 $3$ 整除，且框内不含终止密码子。\n- 设 $\\mathcal{C}$ 为标准遗传密码中所有有义密码子的集合（不包括终止密码子）。\n- 设 $G: \\mathcal{C} \\to \\mathcal{A}$ 是从密码子到氨基酸的标准映射，其中 $\\mathcal{A}$ 是由单字母代码表示的标准氨基酸集合。\n- 对于每个氨基酸 $a \\in \\mathcal{A}$，定义 $\\mathcal{C}(a) = \\{c \\in \\mathcal{C} \\mid G(c) = a\\}$。\n- 对于每个氨基酸 $a$，定义总需求 $d_a$ 为通过 $G$ 翻译 $\\mathcal{S}$ 中所有序列时 $a$ 出现的总次数。\n- 对于每个密码子 $c \\in \\mathcal{C}$，定义一个整数容量 $k_c \\in \\mathbb{Z}_{\\ge 0}$，表示在整个重编码任务中密码子 $c$ 允许使用的最大次数（其动机源于翻译过程的供需平衡以及避免问题基序的设计约束）。\n- 设 $\\mathcal{F} \\subseteq \\mathcal{C}$ 是不可保留的禁用密码子集合。\n\n为选择保留的有义密码子，构建以下整数线性规划（ILP）：\n- 决策变量：对于每个密码子 $c \\in \\mathcal{C}$，设 $x_c \\in \\{0,1\\}$ 表示是否保留 $c$。\n- 目标：最小化 $\\sum_{c \\in \\mathcal{C}} x_c$。\n- 约束条件：\n  1. 对于在 $\\mathcal{S}$ 的翻译产物中至少出现一次的每个氨基酸 $a$，确保其容量覆盖：\n     $$\\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a.$$\n  2. 对于每个禁用密码子 $c \\in \\mathcal{F}$，强制 $x_c = 0$。\n  3. 对于所有 $c \\in \\mathcal{C}$，强制 $x_c \\in \\{0,1\\}$。\n\n解释：选定保留的密码子后，所有编码序列都可以被重编码，使得每个氨基酸 $a$ 的每次出现都被改写为来自 $\\mathcal{C}(a)$ 的保留密码子，且不超过各密码子的使用容量。这对应于与观察到的蛋白质组兼容的有义密码子压缩，同时通过最小化保留的密码子来增强基因防火墙。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n- 为每个指定的测试用例计算上述 ILP 的最优目标值。\n- 如果 ILP 不可行，则该测试用例必须返回 $-1$。\n\n注意：虽然该问题被表述为整数线性规划（ILP），但您可以利用任何结构特性通过算法求解，只要返回的值是真实的最优解即可。\n\n对所有有义密码子使用标准遗传密码（DNA密码子），不包括终止密码子。不涉及角度。不涉及物理单位。所有输出必须为整数。\n\n测试套件：\n对于下方的每个测试用例，您将获得：\n- 一个编码 DNA 序列列表 $\\mathcal{S}$，其中每个序列都是同框的，且长度能被 $3$ 整除。\n- 一个基础容量 $K_0$，应用于任何未被明确覆盖的密码子。\n- 一个逐密码子容量覆盖字典 $\\{(c, k_c)\\}$，其值在提供时将取代 $K_0$。\n- 一个禁用密码子集合 $\\mathcal{F}$。\n\n您的程序必须为每个用例计算 $\\sum_{c \\in \\mathcal{C}} x_c$ 的最优值，如果不可行则返回 $-1$。\n\n- 测试用例 1：\n  - $\\mathcal{S} = [\\text{\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\"}, \\text{\"ATGCTTACCGCAGGCAGA\"}]$\n  - $K_0 = 2$\n  - 覆盖：无\n  - $\\mathcal{F} = \\varnothing$\n- 测试用例 2：\n  - $\\mathcal{S} = [\\text{\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"}]$\n  - $K_0 = 3$\n  - 覆盖：无\n  - $\\mathcal{F} = \\{\\text{\"GGG\"}\\}$\n- 测试用例 3：\n  - $\\mathcal{S} = [\\text{\"ATGCTGCTGCTGCTGCTG\"}]$\n  - $K_0 = 2$\n  - 覆盖：$\\{(\\text{\"CTG\"}, 4)\\}$\n  - $\\mathcal{F} = \\{\\text{\"TTA\"}, \\text{\"TTG\"}, \\text{\"CTT\"}, \\text{\"CTC\"}, \\text{\"CTA\"}\\}$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按给定顺序排列的测试用例结果，格式为方括号内的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_i$ 都必须是整数，不可行的情况用 $-1$ 表示。", "solution": "问题陈述已经过验证，被认定为有效。它在科学上基于分子生物学，在数学上被严谨地表述为一个整数线性规划（ILP），并提供了一套完整、明确且一致的定义和数据。\n\n该问题旨在为一个用于有义密码子压缩的 ILP 找到最优值。目标是最小化保留的有义密码子总数，其约束条件要确保所有必需的氨基酸在其指定的需求量内保持可编码，同时考虑到每个密码子的容量和一组禁用密码子。\n\n设决策变量为 $x_c \\in \\{0, 1\\}$，对应每个有义密码子 $c \\in \\mathcal{C}$，其中如果密码子 $c$ 被保留，则 $x_c=1$，否则 $x_c=0$。该 ILP 的公式如下：\n\n最小化：\n$$ \\sum_{c \\in \\mathcal{C}} x_c $$\n\n约束条件：\n1. 对于每个需求 $d_a > 0$ 的氨基酸 $a \\in \\mathcal{A}$：\n   $$ \\sum_{c \\in \\mathcal{C}(a)} k_c \\, x_c \\ge d_a $$\n2. 对于每个禁用密码子 $c \\in \\mathcal{F}$：\n   $$ x_c = 0 $$\n3. 对于所有 $c \\in \\mathcal{C}$：\n   $$ x_c \\in \\{0, 1\\} $$\n\n在这里，$\\mathcal{C}(a)$ 是编码氨基酸 $a$ 的密码子集合，$d_a$ 是氨基酸 $a$ 的总需求，而 $k_c$ 是密码子 $c$ 的使用容量。\n\n该 ILP 的一个关键结构特性是其可分解性。目标函数是所有密码子的总和，可以按其编码的氨基酸进行划分：\n$$ \\sum_{c \\in \\mathcal{C}} x_c = \\sum_{a \\in \\mathcal{A}} \\left( \\sum_{c \\in \\mathcal{C}(a)} x_c \\right) $$\n针对给定氨基酸 $a$ 的约束仅涉及决策变量 $\\{x_c \\mid c \\in \\mathcal{C}(a)\\}$。这些变量不会出现在任何其他氨基酸 $a' \\neq a$ 的约束中。这种独立性使得全局优化问题可以分解为一组更小的、独立的子问题，每个需求非零（$d_a>0$）的氨基酸 $a \\in \\mathcal{A}$ 对应一个子问题。\n\n对于每个这样的氨基酸 $a$，我们必须解决以下子问题：从 $\\mathcal{C}(a)$ 中找出需要保留的最小密码子数（记为 $N_a$），以满足需求 $d_a$。该子问题是：\n\n最小化：\n$$ N_a = \\sum_{c \\in \\mathcal{C}(a)} x_c $$\n\n约束条件：\n$$ \\sum_{c \\in \\mathcal{C}(a) \\setminus \\mathcal{F}} k_c \\, x_c \\ge d_a $$\n$$ x_c \\in \\{0, 1\\} \\text{ for } c \\in \\mathcal{C}(a) \\setminus \\mathcal{F} $$\n\n原始问题的最优密码子总数就是这些子问题最优解的总和：$\\sum_{a \\mid d_a > 0} N_a$。如果任何一个子问题不可行，则整个问题都不可行。\n\n每个子问题等价于：给定一组可用的（非禁用的）编码氨基酸 $a$ 的密码子，每个密码子都有特定的容量 $k_c$，选择一个最小的密码子子集，使其容量总和至少为 $d_a$。这是零钱兑换问题或无界背包问题的一个变体，但每个物品的成本为单位1。\n\n这个子问题存在一个最优的贪心解法。为了最小化所选密码子的数量，必须优先选择容量最高的密码子。算法如下：\n1. 考虑编码氨基酸 $a$ 的可用密码子集合，即 $\\mathcal{C}(a) \\setminus \\mathcal{F}$。\n2. 按其容量 $k_c$ 对这些密码子进行降序排序。\n3. 从这个排好序的列表中依次选择密码子，并累加它们的容量，直到总容量和大于或等于需求 $d_a$。\n4. 所选密码子的数量就是氨基酸 $a$ 所需的最小数量，即 $N_a$。\n5. 如果 $a$ 的所有可用密码子的容量总和小于 $d_a$，则该子问题不可行。\n\n这个贪心策略的最优性可以通过交换论证来证明。假设贪心解 $G$ 是次优的，并且存在一个使用更少密码子的最优解 $O$，即 $|O|  |G|$。假设密码子按容量降序排列。贪心选择确保对于任何 $j \\le |O|$，贪心序列中第 $j$ 个密码子的容量大于或等于最优序列中第 $j$ 个密码子的容量。这意味着贪心算法选择的前 $|O|$ 个密码子的累积容量至少与最优解的总容量一样大，而最优解的总容量本身必须 $\\ge d_a$。因此，贪心算法最多会用 $|O|$ 个密码子就终止，这与 $|G| > |O|$ 的假设相矛盾。因此，贪心方法是最优的。\n\n总体算法如下：\n1. 对每个测试用例，首先解析输入序列 $\\mathcal{S}$，计算每个氨基酸 $a$ 的总需求 $d_a$。\n2. 基于基础容量 $K_0$ 和任何指定的覆盖值，为所有有义密码子构建容量映射 $k_c$。\n3. 对于每个 $d_a > 0$ 的氨基酸 $a$：\n    a. 识别可用密码子集合 $\\mathcal{C}(a) \\setminus \\mathcal{F}$ 及其对应的容量。\n    b. 如果所有可用密码子的总容量小于 $d_a$，则问题不可行。将该用例的结果标记为 $-1$ 并终止处理。\n    c. 否则，应用上述贪心选择策略来确定最小密码子数 $N_a$。\n4. 总目标值是所有 $d_a > 0$ 的氨基酸的 $N_a$ 之和。\n\n这种基于分解的、有原则的方法能够正确且高效地解决给定的 ILP。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the codon compression problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the Standard Genetic Code (DNA codons to amino acids)\n    # Stop codons (TAA, TAG, TGA) are excluded.\n    codon_to_aa = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H',\n        'CAA': 'Q', 'CAG': 'Q', 'AAT': 'N', 'AAC': 'N',\n        'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D',\n        'GAA': 'E', 'GAG': 'E', 'TGT': 'C', 'TGC': 'C',\n        'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', \n        'CGG': 'R', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', \n        'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', \n        'GGG': 'G'\n    }\n\n    # Pre-compute the mapping from amino acids to their codons\n    aa_to_codons = defaultdict(list)\n    for codon, aa in codon_to_aa.items():\n        aa_to_codons[aa].append(codon)\n\n    # All sense codons\n    all_sense_codons = list(codon_to_aa.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"S\": [\"ATGGCTGTTGGTTCTCGTCCTACTAAAGAA\", \"ATGCTTACCGCAGGCAGA\"],\n            \"K0\": 2,\n            \"overrides\": {},\n            \"F\": set()\n        },\n        {\n            \"S\": [\"ATGGGTGGTGGTGGTGGTGGTGGTGGT\"],\n            \"K0\": 3,\n            \"overrides\": {},\n            \"F\": {\"GGG\"}\n        },\n        {\n            \"S\": [\"ATGCTGCTGCTGCTGCTG\"],\n            \"K0\": 2,\n            \"overrides\": {\"CTG\": 4},\n            \"F\": {\"TTA\", \"TTG\", \"CTT\", \"CTC\", \"CTA\"}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sequences = case[\"S\"]\n        k0 = case[\"K0\"]\n        overrides = case[\"overrides\"]\n        forbidden_codons = case[\"F\"]\n\n        # Step 1: Compute amino acid demands (d_a)\n        demands = defaultdict(int)\n        full_sequence = \"\".join(sequences)\n        for i in range(0, len(full_sequence), 3):\n            codon = full_sequence[i:i+3]\n            if codon in codon_to_aa:\n                aa = codon_to_aa[codon]\n                demands[aa] += 1\n        \n        # Step 2: Compute codon capacities (k_c)\n        capacities = {c: k0 for c in all_sense_codons}\n        capacities.update(overrides)\n\n        # Step 3: Solve subproblem for each amino acid\n        total_retained_codons = 0\n        is_infeasible = False\n        \n        for aa, demand in demands.items():\n            if demand == 0:\n                continue\n\n            # Get available codons and their capacities for the current amino acid\n            available_codon_capacities = []\n            for codon in aa_to_codons[aa]:\n                if codon not in forbidden_codons:\n                    available_codon_capacities.append(capacities[codon])\n            \n            # Check for instant infeasibility\n            if sum(available_codon_capacities)  demand:\n                is_infeasible = True\n                break\n            \n            # Sort capacities in descending order for greedy selection\n            available_codon_capacities.sort(reverse=True)\n            \n            # Greedily select codons\n            capacity_sum = 0\n            codons_for_aa = 0\n            for cap in available_codon_capacities:\n                capacity_sum += cap\n                codons_for_aa += 1\n                if capacity_sum >= demand:\n                    break\n            \n            total_retained_codons += codons_for_aa\n\n        if is_infeasible:\n            results.append(-1)\n        else:\n            results.append(total_retained_codons)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2772541"}, {"introduction": "在设计并实施了压缩密码子方案后，下一步是分析其对基因组序列产生的实际影响。我们需要量化指标来描述密码子使用的变化，其中“相对同义密码子使用频率”（RSCU）是一个衡量密码子偏好性的标准工具。在本练习中，你将学习如何计算RSCU值，并将其定义扩展到密码子压缩后的新场景，即多个同义密码子被合并为一个功能类别的情况，从而能够定量地评估重编码的效果。", "problem": "遗传防火墙的一个核心方法是有义密码子压缩，其中编码相同氨基酸的多个同义密码子被合并成更少的功能类别，以释放密码子用于重分配。考虑一个具有多个同义密码子的单一氨基酸。在一个来自工程生物体的编码序列语料库中，设该氨基酸出现的总次数为 $N_{a}$，并设 $k$ 表示该氨基酸的原始同义密码子数量。对于每个同义密码子 $i$，设其观测计数为 $n_{i}$。相对同义密码子使用频率 (RSCU) 指标被广泛用于量化相对于 $k$ 个同义密码子之间均等使用基线的密码子偏好性。\n\n任务：\n- 仅使用分子生物学中心法则所隐含的定义以及同义密码子间均等使用基线的概念，给出编码特定氨基酸的密码子 $i$ 的相对同义密码子使用频率 (RSCU) 的精确数学定义。\n- 在一个密码子压缩方案下，该方案将氨基酸的 $k$ 个同义密码子中的一个子集 $S$ 合并为一个单一的重编码密码子类别，同时将其余密码子划分到不相交的类别中，使得压缩后该氨基酸共有 $k^{\\prime}$ 个重编码类别。请参考这 $k^{\\prime}$ 个类别间的相应均等使用基线，定义合并类别 $S$ 的转换后 RSCU。推导一个用观测计数表示的转换后 RSCU 的表达式，并在可能的情况下，从第一性原理出发，用压缩前的 RSCU 值表示。\n- 接着，使用以下关于在进行遗传防火墙有义密码子压缩的工程化大肠杆菌 (Escherichia coli) 基因组中亮氨酸 (leucine) 的科学上合理的数据，计算合并类别 $M_{1}$ 的转换后 RSCU：\n  - 氨基酸：亮氨酸 (leucine)。原始同义密码子集大小 $k = 6$。\n  - 在一个精选编码集中的观测计数：$n(\\mathrm{CTA}) = 31$, $n(\\mathrm{CTT}) = 29$, $n(\\mathrm{TTA}) = 40$, $n(\\mathrm{CTC}) = 25$, $n(\\mathrm{CTG}) = 75$, $n(\\mathrm{TTG}) = 20$。\n  - 压缩合并为 $k^{\\prime} = 2$ 个重编码类别：$M_{1} = \\{\\mathrm{CTA}, \\mathrm{CTT}, \\mathrm{TTA}\\}$ 和 $M_{2} = \\{\\mathrm{CTC}, \\mathrm{CTG}, \\mathrm{TTG}\\}$。\n  \n提供 $M_{1}$ 的最终转换后 RSCU 值，以精确分数形式表示。不要四舍五入。", "solution": "该问题提出了一个在合成生物学和生物信息学领域内有效且良构的查询。它具有科学依据，没有歧义，并包含了进行严谨解答所需的所有信息。我们将按照指定顺序处理这三个任务。\n\n第一个任务是给出相对同义密码子使用频率 (RSCU) 的精确数学定义。RSCU 指标将一个密码子的观测频率与在特定氨基酸的所有同义密码子均等使用的零假设下的期望频率进行比较。\n\n假设一个氨基酸由一组 $k$ 个同义密码子编码。对于一个给定的基因序列语料库，设第 $i$ 个同义密码子的观测计数为 $n_{i}$，其中 $i \\in \\{1, 2, \\dots, k\\}$。该氨基酸出现的总次数 $N_{a}$ 是其所有相关密码子计数的总和：\n$$N_{a} = \\sum_{j=1}^{k} n_{j}$$\n如果所有 $k$ 个密码子都以相等的概率被使用，那么任何密码子 $i$ 的期望计数 $E[n_i]$ 将是总计数 $N_a$ 在 $k$ 个选项中均匀分布的结果：\n$$E[n_i] = \\frac{N_{a}}{k}$$\n密码子 $i$ 的 RSCU，记作 $\\text{RSCU}_{i}$，被正式定义为其观测计数与期望计数的比值：\n$$\\text{RSCU}_{i} = \\frac{n_{i}}{E[n_i]} = \\frac{n_{i}}{\\frac{N_{a}}{k}} = \\frac{k \\cdot n_{i}}{\\sum_{j=1}^{k} n_{j}}$$\n\n第二个任务是为合并的密码子类别定义并推导转换后 RSCU 的表达式。在一个密码子压缩方案中，原始的 $k$ 个密码子被划分成 $k^{\\prime}$ 个新类别。设 $S$ 是其中一个类别，代表了现在被视为单个功能单元的原始密码子的一个子集。\nRSCU 的基本原理保持不变：它是观测使用量与期望使用量的比值。然而，现在均等使用基线应用于这 $k^{\\prime}$ 个新类别。氨基酸的总计数 $N_{a}$ 保持不变。\n合并类别 $S$ 的观测计数，记作 $n_{S}$，是其包含的各个密码子计数的总和：\n$$n_{S} = \\sum_{i \\in S} n_{i}$$\n在均匀分布下，这 $k^{\\prime}$ 个类别中任何一个的新期望计数是：\n$$E'[n_S] = \\frac{N_{a}}{k^{\\prime}}$$\n因此，合并类别 $S$ 的转换后 RSCU，我们记作 $\\text{RSCU}'_{S}$，为：\n$$\\text{RSCU}'_{S} = \\frac{n_{S}}{E'[n_S]} = \\frac{\\sum_{i \\in S} n_{i}}{\\frac{N_{a}}{k^{\\prime}}} = \\frac{k^{\\prime} \\cdot \\sum_{i \\in S} n_{i}}{\\sum_{j=1}^{k} n_{j}}$$\n这个表达式也可以用压缩前的 $\\text{RSCU}_{i}$ 值来表示。根据原始定义，$n_{i} = \\text{RSCU}_{i} \\cdot \\frac{N_{a}}{k}$。将此代入 $n_{S}$ 的表达式中，得到：\n$$n_{S} = \\sum_{i \\in S} \\left( \\text{RSCU}_{i} \\cdot \\frac{N_{a}}{k} \\right) = \\frac{N_{a}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}$$\n将此结果代回 $\\text{RSCU}'_{S}$ 的公式中：\n$$\\text{RSCU}'_{S} = \\frac{k^{\\prime} \\cdot n_{S}}{N_{a}} = \\frac{k^{\\prime}}{N_{a}} \\left(\\frac{N_{a}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}\\right) = \\frac{k^{\\prime}}{k} \\sum_{i \\in S} \\text{RSCU}_{i}$$\n这提供了压缩前和压缩后 RSCU 值之间的直接关系。\n\n第三个任务是使用提供的数据计算特定合并类别的转换后 RSCU。\n给出条件如下：\n- 氨基酸：亮氨酸 (Leucine)\n- 原始密码子数量：$k = 6$\n- 新类别数量：$k^{\\prime} = 2$\n- 观测计数：$n(\\mathrm{CTA}) = 31$, $n(\\mathrm{CTT}) = 29$, $n(\\mathrm{TTA}) = 40$, $n(\\mathrm{CTC}) = 25$, $n(\\mathrm{CTG}) = 75$, $n(\\mathrm{TTG}) = 20$。\n- 用于计算的合并类别：$M_{1} = \\{\\mathrm{CTA}, \\mathrm{CTT}, \\mathrm{TTA}\\}$。\n\n首先，我们计算亮氨酸的总计数 $N_{a}$：\n$$N_{a} = 31 + 29 + 40 + 25 + 75 + 20 = 220$$\n接下来，我们计算合并类别 $M_{1}$ 的总计数，记作 $n_{M_{1}}$：\n$$n_{M_{1}} = n(\\mathrm{CTA}) + n(\\mathrm{CTT}) + n(\\mathrm{TTA}) = 31 + 29 + 40 = 100$$\n使用推导出的转换后 RSCU 公式 $\\text{RSCU}'_{S} = \\frac{k^{\\prime} \\cdot n_{S}}{N_{a}}$，我们代入类别 $M_1$ 的数值：\n$$\\text{RSCU}'_{M_{1}} = \\frac{2 \\cdot 100}{220} = \\frac{200}{220}$$\n问题要求一个精确分数，因此我们化简这个结果：\n$$\\text{RSCU}'_{M_{1}} = \\frac{20}{22} = \\frac{10}{11}$$", "answer": "$$\\boxed{\\frac{10}{11}}$$", "id": "2772544"}, {"introduction": "密码子压缩的影响远不止于静态的序列改变，它还会深刻影响翻译等动态生物学过程。密码子的选择决定了翻译核糖体的移动速度，而肽链的延伸速度与蛋白质自身的折叠速度之间的动力学竞争，可能决定蛋白质能否正确折叠。这个练习将引导你使用一个简化的动力学模型，来量化翻译速度的变化如何影响共翻译折叠过程中的错误折叠风险，从而揭示基因密码工程中一个重要的设计考量。", "problem": "您正在遗传防火墙的有义密码子压缩背景下，为共翻译折叠进行建模。有义密码子压缩会改变转运核糖核酸 (tRNA) 的丰度和密码子的使用，这可以加速通过先前含有慢速密码子区域的翻译过程。您将使用一个最小双态动力学模型来量化这种加速如何改变错误折叠的概率。其基本依据是分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质），以及一个经过充分检验的动力学描述：一个速率常数为 $k$ 的一级过程在时间 $t$ 内的跃迁概率为 $1 - e^{-k t}$。\n\n模型假设和定义：\n- 考虑一个长度为 $L$ 个密码子的关键慢速密码子窗口，在翻译过程中，新生肽链可在此窗口内形成正确的天然折叠核。设此窗口内的翻译速率为 $r$ 密码子/秒，因此在该窗口的停留时间为 $T = L / r$ 秒。\n- 在此窗口内，有效折叠核的形成被建模为一个速率为 $k_f$（单位为 $\\text{s}^{-1}$）的泊松过程，从而在核糖体离开该窗口前形成折叠核的概率为 $p_{\\text{nuc}} = 1 - e^{-k_f T}$。\n- 在窗口末端，如果折叠核已经形成，蛋白质仍有很小的概率 $\\beta$（无量纲，介于 $0$ 和 $1$ 之间）发生错误折叠。如果在窗口末端折叠核未能形成，则蛋白质以概率 $\\alpha$（无量纲，介于 $0$ 和 $1$ 之间）进入错误折叠状态。\n- 因此，对于单个窗口，在翻译速率为 $r$ 的条件下，翻译结束时的错误折叠概率是 $L$、$r$、$k_f$、$\\alpha$ 和 $\\beta$ 的函数。\n\n您的任务：\n- 对每个测试用例，计算因加速通过先前慢速区域而导致的错误折叠概率变化 $\\Delta R$，定义为 $\\Delta R = R_{\\text{after}} - R_{\\text{before}}$，其中 $R_{\\text{before}}$ 使用窗口中原始的翻译速率 $r_{\\text{before}}$，$R_{\\text{after}}$ 使用加速后的翻译速率 $r_{\\text{after}}$。所有速率 $r$ 的单位为密码子/秒，$k_f$ 的单位为 $\\text{s}^{-1}$，$L$ 的单位为密码子。输出是无量纲的。将每个 $\\Delta R$ 表示为四舍五入到六位小数的十进制数。\n\n每个测试用例的输入参数以元组 $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta)$ 的形式给出。\n\n测试套件：\n1. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (15, 5, 15, 0.3, 0.8, 0.02)$\n2. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (20, 10, 10, 0.25, 0.7, 0.05)$\n3. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (30, 3, 12, 0.4, 0.9, 0.01)$\n4. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (5, 8, 18, 0.05, 0.85, 0.02)$\n5. $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta) = (0, 6, 12, 0.5, 0.6, 0.0)$\n\n程序要求：\n- 实现一个函数，该函数为每个测试用例计算上述双态模型下的 $R_{\\text{before}}$ 和 $R_{\\text{after}}$，并返回四舍五入到六位小数的 $\\Delta R$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。每个结果小数点后必须正好有六位数字。\n\n注意：您不得读取任何输入。请在程序内部使用上面定义的测试套件。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知信息**\n- 一个长度为 $L$ 个密码子的关键折叠窗口。\n- 窗口内的翻译速率：$r$ 密码子/秒。\n- 窗口内的停留时间：$T = L / r$ 秒。\n- 折叠核形成速率：$k_f$，单位为 $\\text{s}^{-1}$。\n- 在时间 $T$ 内成核的概率：$p_{\\text{nuc}} = 1 - e^{-k_f T}$。\n- 如果折叠核形成，错误折叠的概率：$\\beta$。\n- 如果折叠核未形成，错误折叠的概率：$\\alpha$。\n- 任务是计算错误折叠概率的变化，$\\Delta R = R_{\\text{after}} - R_{\\text{before}}$，其中 $R_{\\text{before}}$ 和 $R_{\\text{after}}$ 是分别对应于翻译速率 $r_{\\text{before}}$ 和 $r_{\\text{after}}$ 的总错误折叠概率。\n- 输入参数以元组 $(L, r_{\\text{before}}, r_{\\text{after}}, k_f, \\alpha, \\beta)$ 的形式提供。\n\n**第2步：使用提取的已知信息进行验证**\n根据有效性标准对问题进行评估。\n\n- **科学上成立：** 该问题是有效的。它使用了一个简化的但标准的基于一级速率过程的动力学模型，这是一级速率过程是化学和生物动力学的基础。翻译速度（由密码子使用频率调节）影响共翻译蛋白质折叠这一前提是分子生物学中一个公认的概念。一级过程概率的公式 $1 - e^{-kt}$ 是正确的。\n- **定义明确：** 该问题是有效的。为每个测试用例提供了所有必需的参数（$L$, $r_{\\text{before}}$, $r_{\\text{after}}$, $k_f$, $\\alpha$, $\\beta$）。目标定义清晰，并且可以从给定模型中推导出一个唯一的、稳定的、有意义的数值解。\n- **客观性：** 该问题是有效的。它使用精确、定量和客观的语言表述，没有歧义或主观论断。\n\n该问题的表述是自洽的、一致的且科学上合理的。测试用例，包括测试用例5中 $L=0$ 的边缘情况，都是有效的，用于测试所推导模型的鲁棒性。\n\n**第3步：结论与行动**\n该问题被判定为**有效**。我们继续进行求解。\n\n目标是推导总错误折叠概率 $R$ 作为给定参数的函数的解析表达式，然后用它来计算变化量 $\\Delta R$。\n\n总错误折叠概率 $R$ 可以使用全概率定律来确定。达到最终状态有两条互斥的路径：折叠核在停留时间 $T$ 内形成，或不形成。\n\n设 $N$ 为折叠核在时间 $T$ 内形成的事件。此事件的概率为 $P(N) = p_{\\text{nuc}}$。设 $N^c$ 为折叠核未形成的互补事件。其概率为 $P(N^c) = 1 - p_{\\text{nuc}}$。\n\n设 $M$ 为蛋白质发生错误折叠的事件。问题提供了以下条件概率：\n- 在折叠核已形成的条件下，发生错误折叠的概率为 $P(M|N) = \\beta$。\n- 在折叠核未形成的条件下，发生错误折叠的概率为 $P(M|N^c) = \\alpha$。\n\n根据全概率定律，总错误折叠概率 $R = P(M)$ 为：\n$$R = P(M|N)P(N) + P(M|N^c)P(N^c)$$\n代入已知概率：\n$$R = \\beta \\cdot p_{\\text{nuc}} + \\alpha \\cdot (1 - p_{\\text{nuc}})$$\n我们已知 $p_{\\text{nuc}} = 1 - e^{-k_f T}$。将此表达式代入 $R$ 的方程中：\n$$R = \\beta(1 - e^{-k_f T}) + \\alpha(1 - (1 - e^{-k_f T}))$$\n$$R = \\beta(1 - e^{-k_f T}) + \\alpha(e^{-k_f T})$$\n$$R = \\beta - \\beta e^{-k_f T} + \\alpha e^{-k_f T}$$\n简化后得到：\n$$R = \\beta + (\\alpha - \\beta)e^{-k_f T}$$\n停留时间 $T$ 定义为 $T = L/r$。因此，总错误折叠概率作为主要参数的函数为：\n$$R(L, r, k_f, \\alpha, \\beta) = \\beta + (\\alpha - \\beta)e^{-k_f L / r}$$\n\n我们的任务是找出错误折叠概率的变化，$\\Delta R = R_{\\text{after}} - R_{\\text{before}}$。\n$R_{\\text{before}}$ 是使用原始翻译速率 $r_{\\text{before}}$ 时的错误折叠概率：\n$$R_{\\text{before}} = \\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{before}}}$$\n$R_{\\text{after}}$ 是使用加速后翻译速率 $r_{\\text{after}}$ 时的错误折叠概率：\n$$R_{\\text{after}} = \\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{after}}}$$\n\n变化量 $\\Delta R$ 是两者的差：\n$$\\Delta R = \\left(\\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{after}}}\\right) - \\left(\\beta + (\\alpha - \\beta)e^{-k_f L / r_{\\text{before}}}\\right)$$\n项 $\\beta$ 被消掉，得到 $\\Delta R$ 的最终表达式：\n$$\\Delta R = (\\alpha - \\beta)\\left(e^{-k_f L / r_{\\text{after}}} - e^{-k_f L / r_{\\text{before}}}\\right)$$\n\n这个表达式在物理上是直观的。$\\Delta R$ 的符号取决于两个因素：$(\\alpha - \\beta)$ 的符号和括号内项的符号。翻译速率加快意味着 $r_{\\text{after}}  r_{\\text{before}}$。对于非零的窗口长度 $L0$，这意味着停留时间减少，即 $L/r_{\\text{after}}  L/r_{\\text{before}}$。由于指数函数的参数为负，这导致 $e^{-k_f L / r_{\\text{after}}}  e^{-k_f L / r_{\\text{before}}}$。因此，括号内的项是正的。\n因此，如果 $\\alpha  \\beta$（即成核失败时更可能发生错误折叠），加速翻译会增加总的错误折叠概率（$\\Delta R  0$）。这是因为可用于形成保护性折叠核的时间减少了。相反，如果 $\\alpha  \\beta$，加速会减少错误折叠。如果 $\\alpha=\\beta$，在此模型中，翻译速度对最终的错误折叠结果没有影响。\n\n求解算法是将这个最终推导出的公式应用于所提供的每个测试用例。对于 $L=0$ 或 $r_{\\text{after}} = r_{\\text{before}}$ 的边缘情况，括号内的项变为 $e^0 - e^0 = 0$ 或两项相同，导致 $\\Delta R = 0$，这是正确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the co-translational folding misfolding probability problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, r_before, r_after, k_f, alpha, beta)\n    test_cases = [\n        (15, 5, 15, 0.3, 0.8, 0.02),\n        (20, 10, 10, 0.25, 0.7, 0.05),\n        (30, 3, 12, 0.4, 0.9, 0.01),\n        (5, 8, 18, 0.05, 0.85, 0.02),\n        (0, 6, 12, 0.5, 0.6, 0.0)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, r_before, r_after, k_f, alpha, beta = case\n\n        # The change in misfolding probability is given by the formula:\n        # Delta_R = (alpha - beta) * (exp(-k_f * L / r_after) - exp(-k_f * L / r_before))\n        # This formula is derived from the total probability of misfolding R, which is:\n        # R = beta + (alpha - beta) * exp(-k_f * L / r)\n\n        # Handle edge cases for clarity and efficiency, although the general formula is robust.\n        # If L=0 or rates are the same, dwell times are equal or zero, so no change.\n        if L == 0 or r_before == r_after:\n            delta_R = 0.0\n        # The rates r must be non-zero for dwell time T = L/r to be meaningful.\n        # The problem statement givens do not include zero rates, so we don't need to handle DivisionByZeroError.\n        else:\n            term_alpha_beta_diff = alpha - beta\n            \n            exponent_before = -k_f * L / r_before\n            exponent_after = -k_f * L / r_after\n            \n            exp_diff = np.exp(exponent_after) - np.exp(exponent_before)\n            \n            delta_R = term_alpha_beta_diff * exp_diff\n\n        # Format the result to exactly six decimal places as a string.\n        results.append(f\"{delta_R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2772556"}]}