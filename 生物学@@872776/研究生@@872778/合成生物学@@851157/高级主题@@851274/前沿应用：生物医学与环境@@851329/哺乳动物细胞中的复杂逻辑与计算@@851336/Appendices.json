{"hands_on_practices": [{"introduction": "在细胞内设计功能性的逻辑门，需要确保其性能对于细胞环境的波动具有稳定性。本练习将探讨鲁棒性这一概念，通过分析一个AND逻辑门的输出如何受到细胞代谢状态（由一个全局资源参数代表）变化的影响。您将运用稳态分析方法，推导对数敏感性，以量化细胞资源扰动在整个线路中的传播方式，从而为评估其运行可靠性提供关键指标。[@problem_id:2723261]", "problem": "考虑一个哺乳动物细胞中的合成基因线路，该线路对两个转录因子（TF）输入进行与逻辑（AND logic）计算。使用中心法则（脱氧核糖核酸到核糖核酸到蛋白质）和基于质量作用定律的常微分方程（ODEs），并结合希尔型启动子激活作为基本框架。细胞的代谢状态提供了一个无量纲的资源可用性标量 $\\rho \\in \\mathbb{R}_{>0}$，它会乘性地缩放线路中所有基因的转录和翻译速率。\n\n该线路包含两个转录因子 $A$ 和 $B$，以及一个报告蛋白 $P$。报告基因被转录为报告信使核糖核酸（mRNA）$m$，然后翻译成蛋白质 $p$。假设如下：\n\n- 转录因子的产生受上游外部诱导剂的调控，并可概括为已包含诱导剂效应的恒定有效合成速率 $s_A$ 和 $s_B$。$A$ 和 $B$ 的产生均遵循线性产生和一级降解动力学，且产生过程受资源缩放影响。\n- 报告基因启动子通过实现为两个希尔激活函数乘积的与逻辑来整合转录因子。报告基因的转录和翻译均受资源缩放。所有降解过程均为一级反应，且不受资源缩放影响。\n\n使用以下常微分方程对动力学进行建模，其中除非明确说明，所有变量和参数均为非负无量纲：\n\n- 转录因子:\n$$\n\\frac{dA}{dt} = \\rho\\, s_A - \\gamma_A A, \\quad \\frac{dB}{dt} = \\rho\\, s_B - \\gamma_B B.\n$$\n\n- 报告基因:\n$$\n\\frac{dm}{dt} = \\rho\\, k_{\\mathrm{tx}}\\, f(A,B) - \\gamma_m m, \\quad \\frac{dp}{dt} = \\rho\\, k_{\\mathrm{tl}}\\, m - \\gamma_p p.\n$$\n\n与门转录输入为\n$$\nf(A,B) = H_A(A)\\, H_B(B),\n$$\n其中希尔激活函数为\n$$\nH_A(A) = \\frac{A^{n_A}}{K_A^{n_A} + A^{n_A}}, \\quad H_B(B) = \\frac{B^{n_B}}{K_B^{n_B} + B^{n_B}}.\n$$\n\n任务。仅从这些定义出发，推导稳态报告蛋白水平 $p^\\ast(\\rho)$ 以及稳态输出对 $\\rho$ 的局部对数敏感度（弹性），\n$$\nE(\\rho) \\equiv \\frac{d \\log p^\\ast(\\rho)}{d \\log \\rho}.\n$$\n使用第一性原理和链式法则；除上述常微分方程和希尔函数外，不要假定任何“捷径”公式。此外，为量化逻辑计算本身的鲁棒性（与输出阶段的平凡整体缩放分开），在指定的资源区间上定义逻辑鲁棒性度量，\n$$\nJ_{\\mathrm{logic}} \\equiv \\max_{\\rho \\in [\\rho_{\\min}, \\rho_{\\max}]} \\left| \\frac{f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)}{f\\big(A^\\ast(\\rho_0), B^\\ast(\\rho_0)\\big)} - 1 \\right|,\n$$\n其中 $A^\\ast(\\rho)$ 和 $B^\\ast(\\rho)$ 是转录因子的稳态。\n\n对于数值评估，所有测试用例使用以下共享常数：\n- $k_{\\mathrm{tx}} = 50.0$, $k_{\\mathrm{tl}} = 5.0$, $\\gamma_m = 1.0$, $\\gamma_p = 0.2$,\n- $\\rho_0 = 1.0$, $\\rho_{\\min} = 0.3$, $\\rho_{\\max} = 3.0$,\n- 对 $\\rho$ 的采样必须在包含 $N_\\rho = 10001$ 个点（包括端点）的对数网格上进行，\n- 鲁棒性阈值为 $E_{\\mathrm{thr}} = 3.2$ 和 $J_{\\mathrm{thr}} = 0.2$。\n\n定义一个鲁棒性标志为\n$$\n\\mathrm{robust} = \\begin{cases}\n1  \\text{if } E(\\rho_0) \\le E_{\\mathrm{thr}} \\text{ and } J_{\\mathrm{logic}} \\le J_{\\mathrm{thr}},\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n\n测试组。评估以下五个参数集，每个参数集以 $(n_A, K_A, s_A, \\gamma_A, n_B, K_B, s_B, \\gamma_B)$ 的形式给出：\n\n- 情况 1：$(2.0, 1.0, 10.0, 5.0, 2.0, 1.5, 12.0, 6.0)$，\n- 情况 2：$(3.0, 2.0, 100.0, 5.0, 2.0, 2.0, 90.0, 3.0)$，\n- 情况 3：$(2.0, 1.0, 1.0, 5.0, 2.0, 1.0, 1.0, 5.0)$，\n- 情况 4：$(1.0, 5.0, 20.0, 1.0, 4.0, 1.0, 1.0, 2.0)$，\n- 情况 5：$(2.0, 3.0, 3.0, 1.0, 2.0, 2.0, 2.0, 1.0)$。\n\n对于每个测试用例，您的程序必须计算：\n- 弹性 $E(\\rho_0)$，\n- 逻辑鲁棒性 $J_{\\mathrm{logic}}$，\n- 鲁棒性标志（整数 $0$ 或 $1$）。\n\n最终输出格式。您的程序应生成单行输出，包含一个 Python 风格的列表的列表\n$$\n\\big[\\,[E_1, J_1, R_1], [E_2, J_2, R_2], \\dots, [E_5, J_5, R_5]\\,\\big],\n$$\n其中 $E_i$ 和 $J_i$ 是四舍五入到六位小数的浮点数，而 $R_i$ 是一个整数。不应打印任何其他文本。所有计算都是无量纲的；不需要物理单位，输出中也不应包含任何单位。", "solution": "所提出的问题是常微分方程（ODE）模型分析中的一个明确定义的练习，这是系统生物学中的一种标准实践。它具有科学依据，数学上一致，并提出了一个非凡但可解的任务。因此，我们将着手解决它。目标是推导稳态蛋白浓度 $p^\\ast$ 作为资源可用性标量 $\\rho$ 的函数，推导相应的对数敏感度 $E(\\rho)$，然后对指定的参数集进行数值评估。\n\n首先，我们通过将其时间导数设为零来确定所有物种的稳态浓度。常微分方程组为：\n$$\n\\frac{dA}{dt} = \\rho\\, s_A - \\gamma_A A\n$$\n$$\n\\frac{dB}{dt} = \\rho\\, s_B - \\gamma_B B\n$$\n$$\n\\frac{dm}{dt} = \\rho\\, k_{\\mathrm{tx}}\\, f(A,B) - \\gamma_m m\n$$\n$$\n\\frac{dp}{dt} = \\rho\\, k_{\\mathrm{tl}}\\, m - \\gamma_p p\n$$\n在稳态下，用上标星号（$^\\ast$）表示，我们有 $\\frac{dA}{dt} = \\frac{dB}{dt} = \\frac{dm}{dt} = \\frac{dp}{dt} = 0$。\n\n对于转录因子 $A$：\n$$\n\\rho\\, s_A - \\gamma_A A^\\ast = 0 \\implies A^\\ast(\\rho) = \\frac{\\rho\\, s_A}{\\gamma_A}\n$$\n类似地，对于转录因子 $B$：\n$$\n\\rho\\, s_B - \\gamma_B B^\\ast = 0 \\implies B^\\ast(\\rho) = \\frac{\\rho\\, s_B}{\\gamma_B}\n$$\n这表明输入转录因子的稳态浓度与资源标量 $\\rho$ 呈线性关系。\n\n对于报告 mRNA $m$：\n$$\n\\rho\\, k_{\\mathrm{tx}}\\, f(A^\\ast, B^\\ast) - \\gamma_m m^\\ast = 0 \\implies m^\\ast(\\rho) = \\frac{\\rho\\, k_{\\mathrm{tx}}}{\\gamma_m} f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)\n$$\n对于报告蛋白 $p$：\n$$\n\\rho\\, k_{\\mathrm{tl}}\\, m^\\ast - \\gamma_p p^\\ast = 0 \\implies p^\\ast(\\rho) = \\frac{\\rho\\, k_{\\mathrm{tl}}}{\\gamma_p} m^\\ast(\\rho)\n$$\n将 $m^\\ast(\\rho)$ 的表达式代入 $p^\\ast(\\rho)$ 的方程，得到稳态报告蛋白水平的完整表达式：\n$$\np^\\ast(\\rho) = \\frac{\\rho\\, k_{\\mathrm{tl}}}{\\gamma_p} \\left( \\frac{\\rho\\, k_{\\mathrm{tx}}}{\\gamma_m} f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big) \\right) = \\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\gamma_p \\gamma_m} \\rho^2 f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)\n$$\n其中 $f(A,B) = H_A(A) H_B(B)$ 且 $A^\\ast(\\rho)$、$B^\\ast(\\rho)$ 是上面推导出的 $\\rho$ 的线性函数。其显式形式为：\n$$\np^\\ast(\\rho) = \\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\gamma_p \\gamma_m} \\rho^2 \\left( \\frac{(A^\\ast(\\rho))^{n_A}}{K_A^{n_A} + (A^\\ast(\\rho))^{n_A}} \\right) \\left( \\frac{(B^\\ast(\\rho))^{n_B}}{K_B^{n_B} + (B^\\ast(\\rho))^{n_B}} \\right)\n$$\n\n接下来，我们推导局部对数敏感度，或称弹性，$E(\\rho)$，定义为：\n$$\nE(\\rho) \\equiv \\frac{d \\log p^\\ast(\\rho)}{d \\log \\rho}\n$$\n为便于求导，我们对 $p^\\ast(\\rho)$ 取自然对数：\n$$\n\\log p^\\ast(\\rho) = \\log\\left(\\frac{k_{\\mathrm{tl}} k_{\\mathrm{tx}}}{\\gamma_p \\gamma_m}\\right) + 2\\log\\rho + \\log(H_A(A^\\ast(\\rho))) + \\log(H_B(B^\\ast(\\rho)))\n$$\n逐项对 $\\log\\rho$ 求导：\n$$\nE(\\rho) = \\frac{d}{d\\log\\rho}\\left( \\log(\\text{const.}) \\right) + \\frac{d(2\\log\\rho)}{d\\log\\rho} + \\frac{d\\log H_A(A^\\ast(\\rho))}{d\\log\\rho} + \\frac{d\\log H_B(B^\\ast(\\rho))}{d\\log\\rho}\n$$\n常数的导数为 $0$，且 $\\frac{d(2\\log\\rho)}{d\\log\\rho} = 2$。对于希尔函数项，我们使用链式法则：\n$$\n\\frac{d\\log H_A(A^\\ast(\\rho))}{d\\log\\rho} = \\frac{d\\log H_A}{d\\log A^\\ast} \\cdot \\frac{d\\log A^\\ast}{d\\log\\rho}\n$$\n我们需要导数 $\\frac{d\\log A^\\ast}{d\\log\\rho}$。由于 $A^\\ast(\\rho) = (\\frac{s_A}{\\gamma_A})\\rho$，我们有 $\\log A^\\ast = \\log(\\frac{s_A}{\\gamma_A}) + \\log\\rho$。因此，$\\frac{d\\log A^\\ast}{d\\log\\rho} = 1$。$B^\\ast$ 的情况也相同。\n问题简化为计算希尔函数对其输入的弹性。设 $H(x) = \\frac{x^n}{K^n + x^n}$。\n$$\n\\log H(x) = n\\log x - \\log(K^n + x^n)\n$$\n对 $\\log x$ 求导：\n$$\n\\frac{d\\log H(x)}{d\\log x} = n - \\frac{d\\log(K^n + x^n)}{d \\log x} = n - \\frac{x}{K^n+x^n}\\frac{d(K^n+x^n)}{dx} = n - \\frac{x}{K^n+x^n}(nx^{n-1})\n$$\n$$\n\\frac{d\\log H(x)}{d\\log x} = n - \\frac{nx^n}{K^n + x^n} = n\\left(1 - \\frac{x^n}{K^n+x^n}\\right) = n\\left(\\frac{K^n}{K^n+x^n}\\right) = n(1 - H(x))\n$$\n将此结果应用于我们的 $E(\\rho)$ 表达式：\n$$\nE(\\rho) = 2 + \\frac{d\\log H_A}{d\\log A^\\ast} + \\frac{d\\log H_B}{d\\log B^\\ast} = 2 + n_A\\left(1 - H_A(A^\\ast(\\rho))\\right) + n_B\\left(1 - H_B(B^\\ast(\\rho))\\right)\n$$\n这是弹性的最终解析表达式。它在 $\\rho = \\rho_0 = 1.0$ 处进行评估，此时 $A^\\ast(\\rho_0) = s_A/\\gamma_A$ 且 $B^\\ast(\\rho_0) = s_B/\\gamma_B$。\n\n逻辑鲁棒性度量 $J_{\\mathrm{logic}}$ 定义为：\n$$\nJ_{\\mathrm{logic}} \\equiv \\max_{\\rho \\in [\\rho_{\\min}, \\rho_{\\max}]} \\left| \\frac{f\\big(A^\\ast(\\rho), B^\\ast(\\rho)\\big)}{f\\big(A^\\ast(\\rho_0), B^\\ast(\\rho_0)\\big)} - 1 \\right|\n$$\n该量没有简单的闭式表达式，必须进行数值计算。步骤如下：\n1.  在区间 $[\\rho_{\\min}, \\rho_{\\max}]$ 内为 $\\rho$ 生成一个包含 $N_\\rho = 10001$ 个点的对数网格。\n2.  计算参考值 $f_0 = f\\big(A^\\ast(\\rho_0), B^\\ast(\\rho_0)\\big)$。\n3.  对于网格中的每个点 $\\rho_i$，计算 $A^\\ast(\\rho_i)$ 和 $B^\\ast(\\rho_i)$，然后计算 $f_i = f\\big(A^\\ast(\\rho_i), B^\\ast(\\rho_i)\\big)$。\n4.  对网格中所有点计算值 $|f_i/f_0 - 1|$。\n5.  $J_{\\mathrm{logic}}$ 是这些值的最大值。\n\n最后，通过将计算出的 $E(\\rho_0)$ 和 $J_{\\mathrm{logic}}$ 与它们各自的阈值 $E_{\\mathrm{thr}} = 3.2$ 和 $J_{\\mathrm{thr}} = 0.2$ 进行比较，来确定鲁棒性标志。\n\n将对每个测试用例实施这些步骤，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the synthetic gene circuit problem: calculates elasticity,\n    logic robustness, and a robustness flag for five parameter sets.\n    \"\"\"\n    # Shared constants\n    k_tx = 50.0\n    k_tl = 5.0\n    gamma_m = 1.0\n    gamma_p = 0.2\n    rho_0 = 1.0\n    rho_min = 0.3\n    rho_max = 3.0\n    N_rho = 10001\n    E_thr = 3.2\n    J_thr = 0.2\n\n    # Test suite: (n_A, K_A, s_A, gamma_A, n_B, K_B, s_B, gamma_B)\n    test_cases = [\n        (2.0, 1.0, 10.0, 5.0, 2.0, 1.5, 12.0, 6.0),\n        (3.0, 2.0, 100.0, 5.0, 2.0, 2.0, 90.0, 3.0),\n        (2.0, 1.0, 1.0, 5.0, 2.0, 1.0, 1.0, 5.0),\n        (1.0, 5.0, 20.0, 1.0, 4.0, 1.0, 1.0, 2.0),\n        (2.0, 3.0, 3.0, 1.0, 2.0, 2.0, 2.0, 1.0),\n    ]\n\n    results = []\n\n    def hill_function(x, n, K):\n        \"\"\"Computes the Hill activation function.\"\"\"\n        # This form is robust against potential overflow for very large x.\n        # However, direct computation is safe for the given parameters.\n        # return 1.0 / (1.0 + (K / x)**n)\n        x_n = x**n\n        return x_n / (K**n + x_n)\n\n    # Generate the rho grid for J_logic calculation\n    rho_grid = np.logspace(np.log10(rho_min), np.log10(rho_max), N_rho)\n\n    for case in test_cases:\n        nA, KA, sA, gammaA, nB, KB, sB, gammaB = case\n\n        # 1. Calculate Elasticity E(rho_0)\n        A_star_0 = sA / gammaA\n        B_star_0 = sB / gammaB\n\n        H_A_0 = hill_function(A_star_0, nA, KA)\n        H_B_0 = hill_function(B_star_0, nB, KB)\n        \n        # E(rho) = 2 + nA*(1 - H_A(A*(rho))) + nB*(1 - H_B(B*(rho)))\n        E_rho0 = 2.0 + nA * (1.0 - H_A_0) + nB * (1.0 - H_B_0)\n\n        # 2. Calculate Logic Robustness J_logic\n        f_0 = H_A_0 * H_B_0\n        \n        A_star_rho = rho_grid * sA / gammaA\n        B_star_rho = rho_grid * sB / gammaB\n\n        f_rho = hill_function(A_star_rho, nA, KA) * hill_function(B_star_rho, nB, KB)\n\n        # Avoid division by zero, although f_0 should be positive.\n        if f_0 > 1e-12:\n            deviation = np.abs(f_rho / f_0 - 1.0)\n            J_logic = np.max(deviation)\n        else:\n            # If f_0 is effectively zero, any non-zero f_rho indicates infinite relative change.\n            # This case is unlikely here but handled for robustness.\n            J_logic = np.inf\n        \n        # 3. Determine the robustness flag\n        is_robust = 1 if (E_rho0 = E_thr and J_logic = J_thr) else 0\n\n        # Store results for this case\n        results.append([E_rho0, J_logic, is_robust])\n\n    # Format the final output string as specified\n    output_parts = []\n    for res in results:\n        E_str = f\"{res[0]:.6f}\"\n        J_str = f\"{res[1]:.6f}\"\n        R_str = str(res[2])\n        output_parts.append(f\"[{E_str},{J_str},{R_str}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2723261"}, {"introduction": "除了静态逻辑，合成生物线路通常被设计用于根据动态输入做出决策，或在一段时间内维持特定状态。本练习将深入探讨一个基于miRNA的分类器在增殖细胞中的时间动态，其中细胞分裂引起的稀释效应是一个关键因素。通过数值求解一个包含自适应反馈的常微分方程组（ODEs），您将评估该线路分类输出的时间稳定性，这是在跨越多代细胞周期中运行的线路所面临的核心挑战。[@problem_id:2723238]", "problem": "你的任务是评估一个合成基因线路在增殖的哺乳动物细胞中计算出的二元分类的时间稳定性。该线路利用了 microRNA (miRNA) 介导的、具有自适应靶点亲和力的抑制作用。分类器根据报告蛋白水平 $P(t)$ 相对于一个固定阈值 $P_{\\mathrm{thr}}$ 的大小，报告其类别 $C(t) \\in \\{0,1\\}$。生物学背景提供了建模的基本要素，但你的任务是纯粹数学和算法层面的：实现并分析下面的耦合常微分方程（ODE）组，并为每一组参数判断类别标签在一个指定的观测窗口内是否保持不变。\n\n基础理论：\n- 分子生物学的中心法则和类似质量作用定律的周转，为充分混合条件下分子物质的一阶生成和降解提供了理论依据。\n- 在以指数增长率 $\\mu$ 增殖的细胞中，所有细胞内分子的浓度都会经历一个速率为 $\\mu$ 的有效一阶稀释。\n- 配体对单个结合位点的平衡占据率可由类似 Michaelis–Menten 的关系式 $\\Theta = m/(K_d + m)$ 建模，其中 $m$ 是游离配体的浓度，$K_d$ 是解离常数。在本模型中，$m$ 对应于 miRNA，而 $\\Theta$ 被解释为靶点被占据的分数。\n- 自适应反馈可以随时间调节有效 $K_d$：当占据率高时，使其趋向一个更具抑制性的状态；当占据率低时，使其回落到基线水平。\n\n模型定义：\n- 令 $m(t)$ 表示 miRNA 浓度，$K_d(t)$ 表示 miRNA-靶点相互作用的有效解离常数，$P(t)$ 表示报告蛋白的浓度。所有时间常数的单位均为小时，但要求的输出是布尔值，因此你不需要输出任何物理单位。动力学方程如下：\n  1. $ \\dfrac{dm}{dt} = \\alpha_m - (\\delta_m + \\mu)\\, m $,\n  2. $ \\Theta(t) = \\dfrac{m(t)}{K_d(t) + m(t)} $,\n  3. $ \\dfrac{dK_d}{dt} = -\\beta\\, \\Theta(t)\\, (K_d(t) - K_{\\min}) + \\rho\\, (K_0 - K_d(t)) $,\n  4. $ \\dfrac{dP}{dt} = \\alpha_{P0}\\, \\bigl(1 - \\Theta(t)\\bigr) - (\\delta_P + \\mu)\\, P $.\n- 在 $t=0$ 时的初始条件为 $m(0)=m_0$, $K_d(0)=K_0$ 和 $P(0)=P_0$。\n\n分类规则和稳定性判据：\n- 定义当 $P(t) \\ge P_{\\mathrm{thr}}$ 时 $C(t) = 1$，否则 $C(t) = 0$。\n- 给定观测窗口 $[t_{\\mathrm{ref}},\\, T]$（其中 $0  t_{\\mathrm{ref}}  T$），定义稳定性布尔值 $S$：如果对于所有 $t \\in [t_{\\mathrm{ref}},\\, T]$，$C(t)$ 保持恒定，则 $S$ 为真，否则为假。换言之，在到达时刻 $t_{\\mathrm{ref}}$ 的初始瞬态过程之后，分类结果必须保持不变。\n\n数值计算要求：\n- 对上述系统实现一个数值稳定的 ODE 积分。你可以使用任何适用于非刚性 ODE 的标准方法，并采用足够高的分辨率以明确地检测分类的变化。确保 $\\Theta(t)$ 按照规定计算，并将其视为有界于 $[0,1]$ 区间内。\n- 你的程序必须在 $t \\in [t_{\\mathrm{ref}},\\, T]$ 的数值解上评估 $C(t)$，并为每个测试用例计算如上定义的 $S$。\n\n测试套件：\n对于下面的每个用例，在 $t \\in [0, T]$ 上进行仿真，并在 $[t_{\\mathrm{ref}}, T]$ 上评估稳定性。每个元组列出了 $(\\alpha_m, \\delta_m, \\mu, K_0, K_{\\min}, \\beta, \\rho, \\alpha_{P0}, \\delta_P, P_{\\mathrm{thr}}, m_0, P_0, T, t_{\\mathrm{ref}})$，初始解离常数设为 $K_d(0)=K_0$。\n\n- 用例 $1$（理想情况，始终为低）：$(\\alpha_m=\\,$$20$$,\\; \\delta_m=\\,$$0.1$$,\\; \\mu=\\,$$0.03$$,\\; K_0=\\,$$50$$,\\; K_{\\min}=\\,$$20$$,\\; \\beta=\\,$$0.2$$,\\; \\rho=\\,$$0.05$$,\\; \\alpha_{P0}=\\,$$1000$$,\\; \\delta_P=\\,$$0.05$$,\\; P_{\\mathrm{thr}}=\\,$$4000$$,\\; m_0=\\,$$0$$,\\; P_0=\\,$$0$$,\\; T=\\,$$96$$,\\; t_{\\mathrm{ref}}=\\,$$24$$)$.\n- 用例 $2$（无自适应的基线）：$(\\alpha_m=\\,$$20$$,\\; \\delta_m=\\,$$0.1$$,\\; \\mu=\\,$$0.03$$,\\; K_0=\\,$$50$$,\\; K_{\\min}=\\,$$10$$,\\; \\beta=\\,$$0$$,\\; \\rho=\\,$$0.05$$,\\; \\alpha_{P0}=\\,$$1000$$,\\; \\delta_P=\\,$$0.05$$,\\; P_{\\mathrm{thr}}=\\,$$2000$$,\\; m_0=\\,$$0$$,\\; P_0=\\,$$0$$,\\; T=\\,$$96$$,\\; t_{\\mathrm{ref}}=\\,$$24$$)$.\n- 用例 $3$（自适应引起的翻转）：$(\\alpha_m=\\,$$20$$,\\; \\delta_m=\\,$$0.1$$,\\; \\mu=\\,$$0.03$$,\\; K_0=\\,$$50$$,\\; K_{\\min}=\\,$$10$$,\\; \\beta=\\,$$0.05$$,\\; \\rho=\\,$$0.005$$,\\; \\alpha_{P0}=\\,$$1000$$,\\; \\delta_P=\\,$$0.05$$,\\; P_{\\mathrm{thr}}=\\,$$2200$$,\\; m_0=\\,$$0$$,\\; P_0=\\,$$0$$,\\; T=\\,$$96$$,\\; t_{\\mathrm{ref}}=\\,$$24$$)$.\n- 用例 $4$（非增殖边界条件）：$(\\alpha_m=\\,$$20$$,\\; \\delta_m=\\,$$0.1$$,\\; \\mu=\\,$$0$$,\\; K_0=\\,$$50$$,\\; K_{\\min}=\\,$$10$$,\\; \\beta=\\,$$0$$,\\; \\rho=\\,$$0.05$$,\\; \\alpha_{P0}=\\,$$1000$$,\\; \\delta_P=\\,$$0.05$$,\\; P_{\\mathrm{thr}}=\\,$$2000$$,\\; m_0=\\,$$0$$,\\; P_0=\\,$$0$$,\\; T=\\,$$96$$,\\; t_{\\mathrm{ref}}=\\,$$24$$)$.\n- 用例 $5$（高生长率稀释）：$(\\alpha_m=\\,$$20$$,\\; \\delta_m=\\,$$0.1$$,\\; \\mu=\\,$$0.1$$,\\; K_0=\\,$$50$$,\\; K_{\\min}=\\,$$10$$,\\; \\beta=\\,$$0.2$$,\\; \\rho=\\,$$0.05$$,\\; \\alpha_{P0}=\\,$$1000$$,\\; \\delta_P=\\,$$0.05$$,\\; P_{\\mathrm{thr}}=\\,$$2300$$,\\; m_0=\\,$$0$$,\\; P_0=\\,$$0$$,\\; T=\\,$$96$$,\\; t_{\\mathrm{ref}}=\\,$$24$$)$.\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$，其中每个 $\\text{result}_i$ 是对应上述用例的布尔值 $S$，顺序与用例相同。布尔值必须以编程语言的标准布尔字面量形式打印。", "solution": "所提出的问题是针对一个耦合常微分方程（ODE）组的适定初值问题，其基础是合成生物学中使用的既定生化动力学原理。任务是基于此系统的动力学来确定一个二元分类器的时间稳定性。该问题在科学上是合理的，内容是自洽的，并且在算法上是明确的。因此，该问题被认为是有效的。\n\n该系统描述了三个状态变量的动力学：microRNA 的浓度 $m(t)$；其与靶信使 RNA 相互作用的有效解离常数 $K_d(t)$；以及报告蛋白的浓度 $P(t)$。系统在任意时刻 $t$ 的状态可以用向量 $y(t) = [m(t), K_d(t), P(t)]^T$ 表示。\n\n系统的演化由以下耦合 ODE 组决定：\n$$\n\\frac{dm}{dt} = \\alpha_m - (\\delta_m + \\mu) m(t)\n$$\n$$\n\\frac{dK_d}{dt} = -\\beta \\Theta(t) (K_d(t) - K_{\\min}) + \\rho (K_0 - K_d(t))\n$$\n$$\n\\frac{dP}{dt} = \\alpha_{P0} (1 - \\Theta(t)) - (\\delta_P + \\mu) P(t)\n$$\n其中，项 $\\Theta(t)$ 代表 miRNA 靶点的占据分数，是一个中间量，定义为：\n$$\n\\Theta(t) = \\frac{m(t)}{K_d(t) + m(t)}\n$$\n初始条件指定为 $m(0) = m_0$, $K_d(0) = K_0$ 和 $P(0) = P_0$。所有参数 $(\\alpha_m, \\delta_m, \\mu, K_0, K_{\\min}, \\beta, \\rho, \\alpha_{P0}, \\delta_P)$ 均在每个测试用例中给出。\n\n求解过程遵循以下步骤：\n\n1.  **数值积分**：该 ODE 系统是非线性的、耦合的，缺乏直接的解析解。因此，必须采用数值方法。我们采用适用于非刚性 ODE 的标准数值积分器，例如显式 Runge-Kutta 方法。SciPy 库中的 `solve_ivp` 函数使用默认的 `RK45` 方法，非常适合此任务。对每个给定的测试用例，在时间区间 $[0, T]$ 上执行积分。为确保能检测到任何分类变化，解在细粒度的时间分辨率上进行评估，例如，时间步长为 0.1 小时。鉴于系统的特征时间尺度在几小时的量级，这个分辨率是绰绰有余的。\n\n2.  **分类与稳定性分析**：对于每个测试用例，在获得区间 $[0, T]$ 上 $P(t)$ 的数值解之后，我们在指定的观测窗口 $[t_{\\mathrm{ref}}, T]$ 内分析其行为。\n    a. 首先，我们提取出落在此窗口内的时间点和相应的蛋白质浓度 $P(t)$。\n    b. 接着，我们应用分类规则 $C(t) = 1$（当 $P(t) \\ge P_{\\mathrm{thr}}$）和 $C(t) = 0$（否则），来生成一个代表观测期间分类器输出的布尔时间序列。\n    c. 然后评估稳定性判据 $S$。当且仅当布尔时间序列 $C(t)$ 在整个观测窗口内保持恒定，即对于所有时间点 $t_i, t_j \\in [t_{\\mathrm{ref}}, T]$ 都有 $C(t_i) = C(t_j)$ 时，分类被认为是稳定的（$S$ 为真）。这可以通过算法检查，即验证布尔时间序列中的唯一值集合是否只包含单个元素（`True` 或 `False`）。如果该集合同时包含两者，则分类是不稳定的（$S$ 为假）。\n\n3.  **实现**：构建一个 Python 脚本来自动化此过程。该脚本遍历所提供的五个测试用例。在每次迭代中，它设置参数和初始条件，调用 ODE 求解器，执行上述稳定性分析，并存储得到的布尔值 $S$。最后，收集所有结果并按指定格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the synthetic gene circuit ODEs for multiple test cases and\n    determines the stability of the classification output.\n    \"\"\"\n\n    # Test cases as tuples:\n    # (alpha_m, delta_m, mu, K0, K_min, beta, rho, alpha_P0, delta_P, P_thr, m0, P0, T, t_ref)\n    test_cases = [\n        # Case 1 (happy path, always low)\n        (20.0, 0.1, 0.03, 50.0, 20.0, 0.2, 0.05, 1000.0, 0.05, 4000.0, 0.0, 0.0, 96.0, 24.0),\n        # Case 2 (no adaptation baseline)\n        (20.0, 0.1, 0.03, 50.0, 10.0, 0.0, 0.05, 1000.0, 0.05, 2000.0, 0.0, 0.0, 96.0, 24.0),\n        # Case 3 (adaptation-induced flip)\n        (20.0, 0.1, 0.03, 50.0, 10.0, 0.05, 0.005, 1000.0, 0.05, 2200.0, 0.0, 0.0, 96.0, 24.0),\n        # Case 4 (non-proliferating boundary)\n        (20.0, 0.1, 0.0, 50.0, 10.0, 0.0, 0.05, 1000.0, 0.05, 2000.0, 0.0, 0.0, 96.0, 24.0),\n        # Case 5 (high growth dilution)\n        (20.0, 0.1, 0.1, 50.0, 10.0, 0.2, 0.05, 1000.0, 0.05, 2300.0, 0.0, 0.0, 96.0, 24.0),\n    ]\n\n    results = []\n\n    def ode_system(t, y, params):\n        \"\"\"\n        Defines the system of ordinary differential equations.\n        y: state vector [m, Kd, P]\n        params: tuple of model parameters\n        \"\"\"\n        m, Kd, P = y\n        alpha_m, delta_m, mu, K0, K_min, beta, rho, alpha_P0, delta_P = params\n\n        # Ensure Kd + m is not zero to prevent division by zero.\n        # Given m>=0 and Kd stays positive (driven towards Kmin or K0, both positive),\n        # this sum will be positive.\n        if Kd + m == 0:\n            Theta = 0.0\n        else:\n            Theta = m / (Kd + m)\n\n        dm_dt = alpha_m - (delta_m + mu) * m\n        dKd_dt = -beta * Theta * (Kd - K_min) + rho * (K0 - Kd)\n        dP_dt = alpha_P0 * (1.0 - Theta) - (delta_P + mu) * P\n\n        return [dm_dt, dKd_dt, dP_dt]\n\n    for case in test_cases:\n        alpha_m, delta_m, mu, K0, K_min, beta, rho, alpha_P0, delta_P, P_thr, m0, P0, T, t_ref = case\n\n        ode_params = (alpha_m, delta_m, mu, K0, K_min, beta, rho, alpha_P0, delta_P)\n        \n        # Initial conditions: m(0)=m0, Kd(0)=K0, P(0)=P0\n        y0 = [m0, K0, P0]\n        \n        # Time span for integration\n        t_span = [0, T]\n        \n        # Set evaluation points for dense output, ensuring sufficient resolution\n        num_points = int(T * 10) + 1 # 10 points per hour\n        t_eval = np.linspace(0, T, num_points)\n\n        # Solve the ODE system\n        sol = solve_ivp(\n            ode_system,\n            t_span,\n            y0,\n            method='RK45',\n            t_eval=t_eval,\n            args=(ode_params,)\n        )\n\n        # Extract protein concentration P(t) from the solution\n        t_sol = sol.t\n        P_sol = sol.y[2]\n\n        # Identify indices corresponding to the observation window [t_ref, T]\n        obs_indices = (t_sol >= t_ref)\n\n        # Get protein levels and classifications in the observation window\n        P_obs = P_sol[obs_indices]\n        C_obs = (P_obs >= P_thr)\n\n        # Determine stability: True if classification is constant, False otherwise\n        # This is true if the number of unique classification values is 1.\n        is_stable = len(np.unique(C_obs)) == 1\n        results.append(is_stable)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2723238"}, {"introduction": "许多合成线路的最终目标是执行一个精确的时间程序，例如产生一个特定持续时间的脉冲。这个高级练习引入了形式化验证的概念，以严格检查线路的行为是否满足如此复杂的规范。您将学习如何将一个脉冲发生器的连续ODE模型抽象为一个离散时间的有限状态系统，并应用模型检测技术来验证其输出轨迹是否满足一个详细的时序逻辑属性。[@problem_id:2723304]", "problem": "考虑一个哺乳动物细胞中的可诱导脉冲生成基因回路，其模型由源于质量作用和Hill型调控动力学的常微分方程描述。设输入诱导物是在时间 $t = 0$ 时施加的幅度恒为 $u_0$ 的阶跃信号。内部物质为激活物 $x(t)$、阻遏物 $z(t)$ 和输出 $y(t)$。其动力学由以下方程给出\n$$\n\\frac{dx}{dt} = k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x, \\quad\n\\frac{dz}{dt} = k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z,\n$$\n$$\n\\frac{dy}{dt} = k_y\\,h_{\\mathrm{act}}(x;K_y,n_y)\\,h_{\\mathrm{rep}}(z;K_{zy},m_z) - \\delta_y\\,y,\n$$\n初始条件为 $x(0) = 0$、$z(0) = 0$ 和 $y(0) = 0$。此处，激活和阻遏的Hill函数定义如下\n$$\nh_{\\mathrm{act}}(s;K,n) = \\frac{s^n}{K^n + s^n}, \\qquad\nh_{\\mathrm{rep}}(s;K,m) = \\frac{K^m}{K^m + s^m},\n$$\n其中 $K  0$、$n \\ge 1$ 和 $m \\ge 1$ 是固定参数。\n\n你将通过在有限时间域 $T$ 内以固定时间步长 $ \\Delta t $ 采样，构建输出的有限状态抽象。令 $N = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor$，并定义离散时间样本 $t_i = i\\,\\Delta t$，其中 $i \\in \\{0,1,\\dots,N\\}$。使用前向欧拉方法获得采样轨迹 $\\{x_i,y_i,z_i\\}_{i=0}^N$：\n$$\nx_{i+1} = x_i + \\Delta t\\left(k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x_i\\right),\n$$\n$$\nz_{i+1} = z_i + \\Delta t\\left(k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z_i\\right),\n$$\n$$\ny_{i+1} = y_i + \\Delta t\\left(k_y\\,h_{\\mathrm{act}}(x_i;K_y,n_y)\\,h_{\\mathrm{rep}}(z_i;K_{zy},m_z) - \\delta_y\\,y_i\\right),\n$$\n其中 $x_0 = 0$、$z_0 = 0$ 和 $y_0 = 0$。\n\n通过在满足 $ 0  \\theta_L  \\theta_H $ 的两个水平 $ \\theta_L $ 和 $ \\theta_H $ 进行阈值处理，将连续输出抽象为有限字母表。对每个索引 $i$，通过以下方式定义原子命题 $L(i)$ 和 $H(i)$\n$$\nL(i) \\text{ 成立当且仅当 } y_i \\le \\theta_L, \\qquad H(i) \\text{ 成立当且仅当 } y_i \\ge \\theta_H.\n$$\n在步骤 $i$ 的有限状态标签是：如果 $L(i)$ 成立，则为 $L$；如果 $H(i)$ 成立，则为 $H$；否则为 $M$。\n\n将期望的脉冲属性指定为离散轨迹上的有界时间时序逻辑需求。固定窗口和持续时间参数 $t_{\\mathrm{win,start}}$、$t_{\\mathrm{win,end}}$（满足 $0 \\le t_{\\mathrm{win,start}}  t_{\\mathrm{win,end}} \\le T$），脉冲前低电平持续时间 $t_{\\mathrm{pre}}  0$，最小高电平持续时间 $t_{\\mathrm{high}}  0$，最大允许返回时间 $t_{\\mathrm{return}}  0$，以及返回后低电平持续时间 $t_{\\mathrm{post}}  0$。使用以下公式将这些时间转换为整数步数\n$$\nd_{\\mathrm{pre}} = \\left\\lceil \\frac{t_{\\mathrm{pre}}}{\\Delta t} \\right\\rceil, \\quad\nd_{\\mathrm{high}} = \\left\\lceil \\frac{t_{\\mathrm{high}}}{\\Delta t} \\right\\rceil, \\quad\nd_{\\mathrm{return}} = \\left\\lceil \\frac{t_{\\mathrm{return}}}{\\Delta t} \\right\\rceil, \\quad\nd_{\\mathrm{post}} = \\left\\lceil \\frac{t_{\\mathrm{post}}}{\\Delta t} \\right\\rceil,\n$$\n以及索引边界\n$$\ni_{\\min} = \\max\\!\\left(\\left\\lceil \\frac{t_{\\mathrm{win,start}}}{\\Delta t} \\right\\rceil,\\, d_{\\mathrm{pre}}\\right), \\quad\ni_{\\max} = \\min\\!\\left(\\left\\lfloor \\frac{t_{\\mathrm{win,end}}}{\\Delta t} \\right\\rfloor,\\, N - d_{\\mathrm{high}}\\right).\n$$\n当且仅当存在一个索引 $i \\in \\{i_{\\min}, i_{\\min}\\!+\\!1,\\dots,i_{\\max}\\}$，使得以下条件成立时，单脉冲属性被满足：\n1. 对于所有 $j \\in \\{i - d_{\\mathrm{pre}},\\dots,i-1\\}$，$L(j)$ 成立。\n2. 对于所有 $j \\in \\{i,\\dots,i + d_{\\mathrm{high}} - 1\\}$，$H(j)$ 成立。\n3. 存在一个索引 $k \\in \\{i + d_{\\mathrm{high}},\\dots,\\min(i + d_{\\mathrm{return}},\\, N - d_{\\mathrm{post}})\\}$，使得：\n   (a) 对于所有 $j \\in \\{k,\\dots,N\\}$，$\\neg H(j)$ 成立，并且\n   (b) 对于所有 $j \\in \\{k,\\dots,k + d_{\\mathrm{post}} - 1\\}$，$L(j)$ 成立。\n\n该属性编码了一个单一的高脉冲，该脉冲在一段足够长的低电平周期后，于指定窗口内开始，持续时间至少达到要求的高电平持续时间，然后在允许的返回时间内回落到高阈值以下，同时在返回后表现出至少达到返回后低电平持续时间的持续低输出。\n\n你的任务是编写一个程序，该程序：\n- 对上述离散时间模型进行积分，\n- 使用 $(\\theta_L,\\theta_H)$ 从 $\\{y_i\\}$ 构建有限状态抽象 $\\{L,M,H\\}$，\n- 检查有限状态轨迹是否满足所定义的单脉冲属性，以及\n- 将每个测试用例的结果以布尔值的形式报告。\n\n所有时间都采用任意归一化单位，输出中无需报告物理单位。对所有测试用例使用以下固定的仿真和规范参数：\n- 采样步长 $ \\Delta t = 0.02 $，时间域 $ T = 20.0 $。\n- 阈值 $ \\theta_L = 0.3 $，$ \\theta_H = 1.0 $。\n- 脉冲规范时间：$ t_{\\mathrm{win,start}} = 0.4 $，$ t_{\\mathrm{win,end}} = 5.0 $，$ t_{\\mathrm{pre}} = 0.5 $，$ t_{\\mathrm{high}} = 2.0 $，$ t_{\\mathrm{return}} = 10.0 $，$ t_{\\mathrm{post}} = 1.0 $。\n\n除非另有说明，否则在所有测试用例中均使用以下固定的生化参数：\n- 输入水平 $ u_0 = 3.0 $。\n- Hill参数 $ n_x = 2 $，$ n_z = 2 $，$ n_y = 2 $，$ m_z = 2 $。\n- 半饱和常数 $ K_x = 1.0 $，$ K_z = 1.0 $，$ K_y = 0.4 $，$ K_{zy} = 0.5 $。\n- 降解率 $ \\delta_x = 1.0 $，$ \\delta_y = 1.0 $。\n- 生成率 $ k_x = 1.0 $，$ k_z = 0.5 $。\n\n为以下测试套件提供结果，该套件通过改变两个关键参数来探测不同的动力学区域：\n1. 理想情况（清晰的脉冲）：$ \\delta_z = 0.2 $，$ k_y = 3.0 $。\n2. 边缘情况（未在规定时间内返回）：$ \\delta_z = 0.02 $，$ k_y = 3.0 $。\n3. 边缘情况（未达到高阈值）：$ \\delta_z = 0.2 $，$ k_y = 0.6 $。\n4. 边界情况（阻遏物太快，高电平过短或不存在）：$ \\delta_z = 1.0 $，$ k_y = 3.0 $。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 为 $True$ 或 $False$，该行中没有空格。", "solution": "所述问题是有效的。这是一个在计算系统生物学领域中提法明确、有科学依据的问题，没有歧义、矛盾或事实错误。任务是执行基因调控网络的数值模拟，并验证所得轨迹是否满足形式化的时序逻辑规范。现在我将介绍得出解决方案的系统性步骤。\n\n该系统由一组关于激活物 $x(t)$、阻遏物 $z(t)$ 和输出蛋白 $y(t)$ 的三个常微分方程描述：\n$$\n\\frac{dx}{dt} = k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x\n$$\n$$\n\\frac{dz}{dt} = k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z\n$$\n$$\n\\frac{dy}{dt} = k_y\\,h_{\\mathrm{act}}(x;K_y,n_y)\\,h_{\\mathrm{rep}}(z;K_{zy},m_z) - \\delta_y\\,y\n$$\n其初始条件为 $x(0) = 0$、$z(0) = 0$ 和 $y(0) = 0$。调控相互作用由标准的Hill函数建模：\n$$\nh_{\\mathrm{act}}(s;K,n) = \\frac{s^n}{K^n + s^n}, \\qquad\nh_{\\mathrm{rep}}(s;K,m) = \\frac{K^m}{K^m + s^m}\n$$\n目标是确定对于几组不同的参数，系统输出 $y(t)$ 是否表现出特定的单脉冲行为。该行为被形式化为一个复杂的时序属性。分析将在通过前向欧拉方法获得的离散时间轨迹上进行。\n\n首先，我们根据给定的连续时间规范计算必要的离散仿真参数。\n仿真时间域为 $T = 20.0$，时间步长为 $\\Delta t = 0.02$。这导致总步数为 $N = \\lfloor T / \\Delta t \\rfloor = \\lfloor 20.0 / 0.02 \\rfloor = 1000$。轨迹将包含 $N+1$ 个点，索引从 $i=0$ 到 $i=1000$。\n\n时序逻辑规范参数被转换为整数步数：\n- 脉冲前低电平持续时间：$t_{\\mathrm{pre}} = 0.5 \\implies d_{\\mathrm{pre}} = \\lceil 0.5 / 0.02 \\rceil = 25$。\n- 最小高电平持续时间：$t_{\\mathrm{high}} = 2.0 \\implies d_{\\mathrm{high}} = \\lceil 2.0 / 0.02 \\rceil = 100$。\n- 最大返回时间：$t_{\\mathrm{return}} = 10.0 \\implies d_{\\mathrm{return}} = \\lceil 10.0 / 0.02 \\rceil = 500$。\n- 返回后低电平持续时间：$t_{\\mathrm{post}} = 1.0 \\implies d_{\\mathrm{post}} = \\lceil 1.0 / 0.02 \\rceil = 50$。\n\n脉冲开始的搜索窗口也被转换为索引范围 $\\{i_{\\min}, \\dots, i_{\\max}\\}$：\n- 窗口起始索引：$\\lceil t_{\\mathrm{win,start}} / \\Delta t \\rceil = \\lceil 0.4 / 0.02 \\rceil = 20$。\n- 窗口结束索引：$\\lfloor t_{\\mathrm{win,end}} / \\Delta t \\rfloor = \\lfloor 5.0 / 0.02 \\rfloor = 250$。\n- 因此，$i_{\\min} = \\max(20, d_{\\mathrm{pre}}) = \\max(20, 25) = 25$。\n- 且 $i_{\\max} = \\min(250, N - d_{\\mathrm{high}}) = \\min(250, 1000 - 100) = 250$。\n对有效脉冲起始索引 $i$ 的搜索将在从 $25$ 到 $250$ 的闭区间内进行。\n\n对于每个测试用例，步骤如下：\n\n1.  **数值积分**：我们生成离散时间轨迹 $\\{x_i, y_i, z_i\\}_{i=0}^N$。我们将大小为 $N+1$ 的 $x, y, z$ 数组初始化为零。对从 $0$ 到 $N-1$ 的 $i$ 应用前向欧拉更新规则：\n    $$\n    x_{i+1} = x_i + \\Delta t\\left(k_x\\,h_{\\mathrm{act}}(u_0;K_x,n_x) - \\delta_x\\,x_i\\right)\n    $$\n    $$\n    z_{i+1} = z_i + \\Delta t\\left(k_z\\,h_{\\mathrm{act}}(u_0;K_z,n_z) - \\delta_z\\,z_i\\right)\n    $$\n    $$\n    y_{i+1} = y_i + \\Delta t\\left(k_y\\,h_{\\mathrm{act}}(x_i;K_y,n_y)\\,h_{\\mathrm{rep}}(z_i;K_{zy},m_z) - \\delta_y\\,y_i\\right)\n    $$\n    项 $h_{\\mathrm{act}}(u_0;K_x,n_x)$ 和 $h_{\\mathrm{act}}(u_0;K_z,n_z)$ 在整个仿真过程中是恒定的，只计算一次。所有固定参数（$u_0, k_x, k_z, K_x, K_z, \\dots$）和特定于用例的参数（$\\delta_z, k_y$）都被代入这些方程中。\n\n2.  **属性验证**：生成输出轨迹 $\\{y_i\\}_{i=0}^N$ 后，我们检查其是否满足单脉冲属性。阈值为 $\\theta_L=0.3$ 和 $\\theta_H=1.0$。如果存在一个满足三个条件的索引 $i \\in \\{i_{\\min}, \\dots, i_{\\max}\\}$，则该属性被满足。我们将其实现为一个嵌套搜索。\n\n    主循环遍历从 $i_{\\min}$ 到 $i_{\\max}$ 的可能的脉冲起始索引 $i$。对于每个 $i$：\n    \n    a. **条件1（脉冲前低电平）**：我们验证在脉冲之前输出在要求的持续时间内处于低电平。这要求对于区间 $\\{i - d_{\\mathrm{pre}}, \\dots, i-1\\}$ 中的所有 $j$，$y_j \\le \\theta_L$。如果不满足此条件，我们继续处理下一个 $i$值。\n    \n    b. **条件2（持续高电平）**：如果条件1成立，我们检查输出是否在最小要求持续时间内处于高电平。这要求对于区间 $\\{i, \\dots, i + d_{\\mathrm{high}} - 1\\}$ 中的所有 $j$，$y_j \\ge \\theta_H$。如果失败，我们继续处理下一个 $i$。\n    \n    c. **条件3（返回低电平）**：如果条件1和2都成立，我们搜索一个“返回时间”索引 $k$。一个次级循环遍历在范围 $\\{i + d_{\\mathrm{high}}, \\dots, \\min(i + d_{\\mathrm{return}}, N - d_{\\mathrm{post}})\\}$ 内的可能 $k$ 值。对于每个 $k$，我们检查两个子条件：\n        i. **(3a) 不再为高电平**：输出必须在仿真的剩余时间内保持在高阈值以下。这意味着对于所有 $j \\in \\{k, \\dots, N\\}$，$y_j  \\theta_H$。\n        ii. **(3b) 返回后低电平**：返回后，输出必须在指定持续时间内处于低电平。这意味着对于所有 $j \\in \\{k, \\dots, k + d_{\\mathrm{post}} - 1\\}$，$y_j \\le \\theta_L$。\n    \n    如果我们找到一个使 (3a) 和 (3b) 都为真的 $k$，那么对于当前测试用例，整个属性就得到满足。我们可以终止对该测试用例的搜索，并报告结果为 `True`。\n    \n    如果遍历所有候选索引 $i$ 的外层循环完成，而没有找到这样的 $i$ 和 $k$ 的组合，则该测试用例不满足该属性，结果为 `False`。\n\n这个完整的算法为测试套件中提供的四个参数集中的每一个都进行了实现。最终输出是与每个用例相对应的布尔值列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It orchestrates the simulation and verification for each parameter set.\n    \"\"\"\n\n    # --- Fixed simulation and specification parameters ---\n    dt = 0.02\n    T = 20.0\n    theta_L = 0.3\n    theta_H = 1.0\n    t_win_start = 0.4\n    t_win_end = 5.0\n    t_pre = 0.5\n    t_high = 2.0\n    t_return = 10.0\n    t_post = 1.0\n\n    # --- Fixed biochemical parameters ---\n    u0 = 3.0\n    kx = 1.0\n    kz = 0.5\n    Kx = 1.0\n    Kz = 1.0\n    Ky = 0.4\n    Kzy = 0.5\n    nx = 2.0\n    nz = 2.0\n    ny = 2.0\n    mz = 2.0\n    delta_x = 1.0\n    delta_y = 1.0\n\n    fixed_params = {\n        'dt': dt, 'T': T, 'theta_L': theta_L, 'theta_H': theta_H,\n        't_win_start': t_win_start, 't_win_end': t_win_end, 't_pre': t_pre,\n        't_high': t_high, 't_return': t_return, 't_post': t_post,\n        'u0': u0, 'kx': kx, 'kz': kz, 'Kx': Kx, 'Kz': Kz, 'Ky': Ky, 'Kzy': Kzy,\n        'nx': nx, 'nz': nz, 'ny': ny, 'mz': mz,\n        'delta_x': delta_x, 'delta_y': delta_y,\n    }\n\n    # --- Test suite cases ---\n    test_cases = [\n        {'delta_z': 0.2, 'ky': 3.0},   # 1. Happy path (clear pulse)\n        {'delta_z': 0.02, 'ky': 3.0},  # 2. No return within time\n        {'delta_z': 0.2, 'ky': 0.6},   # 3. No high crossing\n        {'delta_z': 1.0, 'ky': 3.0},   # 4. Repressor too fast\n    ]\n\n    results = []\n    for case_params in test_cases:\n        params = fixed_params.copy()\n        params.update(case_params)\n        result = check_pulse_property(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef h_act(s, K, n):\n    \"\"\"Activation Hill function.\"\"\"\n    if s == 0:\n        return 0.0\n    s_n = s**n\n    K_n = K**n\n    return s_n / (K_n + s_n)\n\ndef h_rep(s, K, m):\n    \"\"\"Repression Hill function.\"\"\"\n    s_m = s**m\n    K_m = K**m\n    return K_m / (K_m + s_m)\n\ndef check_pulse_property(dt, T, theta_L, theta_H, t_win_start, t_win_end,\n                         t_pre, t_high, t_return, t_post, u0, kx, kz,\n                         Kx, Kz, Ky, Kzy, nx, nz, ny, mz,\n                         delta_x, delta_y, delta_z, ky):\n    \"\"\"\n    Simulates the gene circuit and verifies the single-pulse property.\n    \"\"\"\n    # --- 1. Compute derived simulation constants ---\n    N = int(np.floor(T / dt))\n    \n    d_pre = int(np.ceil(t_pre / dt))\n    d_high = int(np.ceil(t_high / dt))\n    d_return = int(np.ceil(t_return / dt))\n    d_post = int(np.ceil(t_post / dt))\n\n    i_min = max(int(np.ceil(t_win_start / dt)), d_pre)\n    i_max = min(int(np.floor(t_win_end / dt)), N - d_high)\n\n    # --- 2. Numerical Integration (Forward Euler) ---\n    x = np.zeros(N + 1)\n    z = np.zeros(N + 1)\n    y = np.zeros(N + 1)\n    \n    # Pre-calculate constant input terms\n    h_act_u0_x_term = kx * h_act(u0, Kx, nx)\n    h_act_u0_z_term = kz * h_act(u0, Kz, nz)\n\n    for i in range(N):\n        # Update equations\n        dx_dt = h_act_u0_x_term - delta_x * x[i]\n        dz_dt = h_act_u0_z_term - delta_z * z[i]\n        \n        rep_term = h_rep(z[i], Kzy, mz)\n        act_term = h_act(x[i], Ky, ny)\n        dy_dt = ky * act_term * rep_term - delta_y * y[i]\n        \n        x[i+1] = x[i] + dt * dx_dt\n        z[i+1] = z[i] + dt * dz_dt\n        y[i+1] = y[i] + dt * dy_dt\n\n    # --- 3. Property Verification ---\n    for i in range(i_min, i_max + 1):\n        # Condition 1: Pre-pulse low\n        if not np.all(y[i - d_pre : i] = theta_L):\n            continue\n\n        # Condition 2: Sustained high\n        if not np.all(y[i : i + d_high] >= theta_H):\n            continue\n\n        # Condition 3: Return to low\n        k_min = i + d_high\n        k_max = min(i + d_return, N - d_post)\n        \n        found_k = False\n        for k in range(k_min, k_max + 1):\n            \n            # (3a) Never high again\n            if not np.all(y[k : N + 1]  theta_H):\n                continue\n            \n            # (3b) Post-return low\n            if k + d_post > N + 1: # Ensure slice is within bounds\n                continue\n            if not np.all(y[k : k + d_post] = theta_L):\n                continue\n            \n            found_k = True\n            break # Found a valid k\n        \n        if found_k:\n            return True # Found a valid i and k, property holds\n\n    return False # No valid i found after checking all possibilities\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2723304"}]}