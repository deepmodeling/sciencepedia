{"hands_on_practices": [{"introduction": "这项基础练习旨在巩固你对生命表核心组成部分——存活率列 ($l_x$) 的理解。通过从第一性原理出发，推导出生时预期寿命 ($e(0)$) 的计算公式，你将加深对存活率与个体寿命之间基本关系的认识。这项实践不仅是理论推导，也包含了将公式应用于离散数据集进行计算的步骤，是生命表分析的基本功。[@problem_id:2503617]", "problem": "观察一个封闭的生物种群，时间是离散的，时间间隔长度为单位1（该间隔是基本时间步长）。设随机变量 $T \\in \\{0,1,2,\\dots\\}$ 表示从该种群中随机选择的新生个体所活过的完整时间步长的数量（即在死亡前的整数年龄）。该种群在整数年龄的存活序列（以初始种群的比例表示）由 $l_x$ 给出，年龄 $x \\in \\{0,1,2,3,4,5,6,7\\}$，其中 $l_x$ 是存活到年龄 $x$ 的概率。因此，在离散时间模型中，有 $l_k = \\Pr(T \\ge k)$。观测值为\n$$\nl_x = \\{1.0,\\, 0.9,\\, 0.72,\\, 0.54,\\, 0.43,\\, 0.30,\\, 0.10,\\, 0.00\\}。\n$$\n从非负整数值随机变量期望值的基本定义出发，推导新生儿预期寿命 $e(0)$（新生儿活过的完整时间步长的期望数量，也称为同期群期望寿命）关于存活序列 $\\{l_x\\}_{x \\ge 0}$ 的表达式，且不假设任何区间内的死亡模型。然后使用上述数据数值计算 $e(0)$。将最终数值答案四舍五入到3位有效数字。在你的解释中以时间步长表示结果，但最终答案只报告数值。", "solution": "所述问题具有科学依据，提法恰当，并包含了唯一解所需的所有信息。这是人口学和精算学中的一个标准问题。问题有效。我们将进行推导和计算。\n\n任务是首先为离散时间模型推导新生儿预期寿命（记为 $e(0)$）的表达式，然后计算其值。预期寿命 $e(0)$ 是随机变量 $T$ 的期望值，其中 $T \\in \\{0, 1, 2, \\ldots\\}$ 表示新生儿活过的完整时间步长的数量。\n\n推导必须从非负整数值随机变量期望值的基本定义开始。该定义为：\n$$\ne(0) = E[T] = \\sum_{k=0}^{\\infty} k \\cdot \\Pr(T=k)\n$$\n另一种等价的、通常更方便的期望值计算方法是使用尾和公式，即对所有 $j \\ge 1$ 的 $\\Pr(T \\ge j)$ 求和：\n$$\nE[T] = \\sum_{j=1}^{\\infty} \\Pr(T \\ge j)\n$$\n这个公式可以通过将 $k = \\sum_{j=1}^{k} 1$ 代入期望的定义并交换求和顺序来推导。\n\n根据生命表和随机变量 $T$ 的标准定义，事件 $\\{T \\ge j\\}$（活过至少 $j$ 个完整时间步长）的概率，正是存活到年龄 $j$ 的概率 $l_j$。因此：\n$$\n\\Pr(T \\ge j) = l_j\n$$\n将此关系代入期望的表达式中：\n$$\nE[T] = \\sum_{j=1}^{\\infty} l_j\n$$\n为了使符号与所提供数据索引 $x$ 一致，我们将求和索引 $j$ 替换为 $x$。推导出的新生儿预期寿命的最终表达式为：\n$$\ne(0) = \\sum_{x=1}^{\\infty} l_x\n$$\n这个推导，被称为尾和公式，从期望的基本定义出发，不依赖于任何关于时间间隔内死亡模式的假设。这就完成了问题的第一部分。\n\n对于第二部分，我们必须使用提供的 $l_x$ 数据数值计算 $e(0)$：\n$$\nl_x = \\{1.0, 0.9, 0.72, 0.54, 0.43, 0.30, 0.10, 0.00\\}\n$$\n分别对应 $x = 0, 1, 2, 3, 4, 5, 6, 7$。\n给定数据包含 $l_7 = \\Pr(T \\ge 7) = 0.00$。这意味着存活到7个时间步长的概率为零。因此，对于所有整数 $x \\ge 7$，$l_x=0$。这使得 $e(0)$ 的无穷级数变为一个有限和：\n$$\ne(0) = \\sum_{x=1}^{\\infty} l_x = l_1 + l_2 + l_3 + l_4 + l_5 + l_6 + \\sum_{x=7}^{\\infty} l_x\n$$\n由于所有 $x \\ge 7$ 的项都为零，所以和为：\n$$\ne(0) = l_1 + l_2 + l_3 + l_4 + l_5 + l_6\n$$\n代入数值：\n$$\ne(0) = 0.9 + 0.72 + 0.54 + 0.43 + 0.30 + 0.10\n$$\n进行求和：\n$$\ne(0) = 1.62 + 0.54 + 0.43 + 0.30 + 0.10\n$$\n$$\ne(0) = 2.16 + 0.43 + 0.30 + 0.10\n$$\n$$\ne(0) = 2.59 + 0.30 + 0.10\n$$\n$$\ne(0) = 2.89 + 0.10\n$$\n$$\ne(0) = 2.99\n$$\n计算出的新生儿预期寿命为 $2.99$ 个时间步长。问题要求答案四舍五入到3位有效数字。$2.99$ 这个值已经恰好是三位有效数字。", "answer": "$$\n\\boxed{2.99}\n$$", "id": "2503617"}, {"introduction": "在生态学和人口学研究中，数据的收集方式对结果的解读至关重要。本练习将引导你探讨“同期群生命表”（纵向追踪一个群体）与“静态生命表”（横断面数据快照）之间的关键差异。你将通过推导发现，当种群处于增长状态（即增长率 $\\lambda > 1$）时，使用静态数据估算存活率会产生系统性的偏差，这是一个在解读实际人口普查或生态调查数据时必须警惕的陷阱。[@problem_id:2503649]", "problem": "一位人口学家研究一个物种，该物种具有离散、不重叠的年度年龄组 $x \\in \\{0,1,2,\\dots,\\omega\\}$。该种群数量庞大、密度无关、环境恒定，并已收敛到稳定的年龄分布，具有恒定的有限增长率 $\\lambda>0$（因此每个时间步长的种群规模乘以 $\\lambda$）。设同批群存活率表 $l_x$ 为新生个体存活到确切年龄 $x$ 的概率，其中 $l_0=1$。该人口学家在普查时间 $t$ 通过计算每个年龄 $x$ 的个体数量 $n_x(t)$ 来构建静态（横断面）生命表，然后通过对计数进行归一化来估计存活率，使得 $\\hat{l}_0^{\\mathrm{static}}=1$，并且对于 $x>0$，$\\hat{l}_x^{\\mathrm{static}} \\propto n_x(t)$。\n\n仅从同批群存活率 $l_x$ 的定义、增长率为 $\\lambda$ 的稳定指数增长，以及“时间 $t$ 时年龄为 $x$ 的个体数量等于时间 $t-x$ 时的出生数量乘以从出生存活到年龄 $x$ 的概率”这一事实出发，推导 $\\hat{l}_x^{\\mathrm{static}}$ 与 $l_x$ 和 $\\lambda$ 之间的关系。利用你的推导来确定当 $\\lambda>1$ 时 $\\hat{l}_x^{\\mathrm{static}}$ 的偏差方向。\n\n下列陈述中哪些是正确的？选择所有适用的选项。\n\nA. 在一个具有恒定 $\\lambda>1$ 的稳定种群中，通过对 $n_x(t)$ 进行归一化以使 $\\hat{l}_0^{\\mathrm{static}}=1$ 的方式估计 $\\hat{l}_x^{\\mathrm{static}}$ 的静态生命表，会得到 $\\hat{l}_x^{\\mathrm{static}}=l_x\\,\\lambda^{-x}$；因此，它低估了所有 $x>0$ 的 $l_x$。\n\nB. 当 $\\lambda>1$ 时，静态生命表会高估较大年龄 $x$ 的 $l_x$，因为相对于单个同批群，年长个体在横断面中的代表性过高。\n\nC. 如果 $\\lambda=1$，则静态估计对所有年龄 $x$ 都是无偏的，即 $\\hat{l}_x^{\\mathrm{static}}=l_x$。\n\nD. 对于任何 $\\lambda\\neq 1$，比率 $\\hat{l}_x^{\\mathrm{static}}/l_x$ 是一个与年龄 $x$ 无关的常数。\n\nE. 对于 $\\lambda>1$ 时偏差的符号（方向）取决于特定年龄生育率表 $b_x$；在 $b_x$ 充分递增的情况下，即使 $\\lambda>1$，静态生命表也可能无偏。", "solution": "首先对问题陈述进行严格的验证。\n\n步骤1：提取已知条件\n- 年龄组是离散、不重叠的年度年龄组，表示为 $x \\in \\{0, 1, 2, \\dots, \\omega\\}$。\n- 种群是大型、密度无关且处于恒定环境中。\n- 种群已收敛到稳定的年龄分布。\n- 种群经历着恒定的有限增长率 $\\lambda > 0$。\n- 同批群存活率 $l_x$ 是新生个体存活到确切年龄 $x$ 的概率，归一化为 $l_0 = 1$。\n- 在普查时间 $t$ 通过计算每个年龄的个体数量 $n_x(t)$ 来构建静态（横断面）生命表。\n- 静态存活率估计值 $\\hat{l}_x^{\\mathrm{static}}$ 的定义是通过对计数进行归一化，使得 $\\hat{l}_0^{\\mathrm{static}} = 1$ 并且对于 $x > 0$，$\\hat{l}_x^{\\mathrm{static}} \\propto n_x(t)$。\n- 给出了一个关键前提：“时间 $t$ 时年龄为 $x$ 的个体数量等于时间 $t-x$ 时的出生数量乘以从出生存活到年龄 $x$ 的概率。”\n\n步骤2：使用提取的已知条件进行验证\n该问题是数理人口学中的一个标准练习，关注同批群生命表和静态生命表之间的关系。\n- **科学依据：** 稳定年龄分布、存活率表 ($l_x$) 和有限增长率 ($\\lambda$) 等概念是种群生态学和人口学的基础支柱，由 Lotka、Volterra 等人建立。这些前提是合理的。\n- **问题定义良好：** 问题提供了充分的定义和明确的指令，要求推导一个特定关系并分析其影响。问题明确无歧义，可以从前提中推导出唯一解。\n- **客观性：** 语言正式、精确，没有主观性。\n问题陈述内部一致，对于当前任务是完整的，并基于已建立的科学理论。没有可识别的缺陷。\n\n步骤3：结论和行动\n问题有效。我将继续进行推导和评估。\n\n关系的推导\n设 $B(t)$ 表示在时间间隔 $t$ 开始时的出生数量（年龄为0的个体在经历死亡之前的数量）。由于种群以恒定的有限速率 $\\lambda$ 增长，出生数量也必须以该速率指数增长。我们可以将时间 $t$ 的出生数量用某个参考时间（比如 $t=0$）的出生数量来表示：\n$$B(t) = B(0)\\lambda^t$$\n在普查时间 $t$，确切年龄为 $x$ 的个体数量，表示为 $n_x(t)$，由在时间 $t-x$ 出生并存活到年龄 $x$ 的那些个体组成。从出生存活到年龄 $x$ 的概率由同批群存活率 $l_x$ 给出。因此，如问题所述：\n$$n_x(t) = B(t-x) \\cdot l_x$$\n我们可以用当前时间 $t$ 的出生数量 $B(t)$ 来表示 $B(t-x)$：\n$$B(t-x) = B(0)\\lambda^{t-x} = B(0)\\lambda^t \\lambda^{-x} = B(t) \\lambda^{-x}$$\n将此代入 $n_x(t)$ 的表达式中，我们得到：\n$$n_x(t) = B(t) \\lambda^{-x} l_x$$\n问题陈述指出，静态生命表存活率 $\\hat{l}_x^{\\mathrm{static}}$ 是通过对年龄计数 $n_x(t)$ 进行归一化得到的，使得 $\\hat{l}_0^{\\mathrm{static}} = 1$。这种归一化的一般形式是 $\\hat{l}_x^{\\mathrm{static}} = \\frac{n_x(t)}{n_0(t)}$。我们来验证这是否满足条件。\n对于 $x=0$，我们有：\n$$\\hat{l}_0^{\\mathrm{static}} = \\frac{n_0(t)}{n_0(t)} = 1$$\n这与条件 $\\hat{l}_0^{\\mathrm{static}} = 1$ 相符。对于 $x>0$，此公式意味着 $\\hat{l}_x^{\\mathrm{static}} \\propto n_x(t)$，比例常数为 $1/n_0(t)$，对于给定的普查时间 $t$，该常数相对于 $x$ 是恒定的。所以，这是正确的公式。\n\n现在我们代入我们推导出的 $n_x(t)$ 的表达式：\n$$\\hat{l}_x^{\\mathrm{static}} = \\frac{n_x(t)}{n_0(t)} = \\frac{B(t) \\lambda^{-x} l_x}{B(t) \\lambda^{-0} l_0}$$\n鉴于 $l_0 = 1$ 和 $\\lambda^0 = 1$，分母就是 $B(t)$。\n$$\\hat{l}_x^{\\mathrm{static}} = \\frac{B(t) \\lambda^{-x} l_x}{B(t)} = l_x \\lambda^{-x}$$\n这是具有稳定年龄分布且以速率 $\\lambda$ 增长的种群中，静态生命表估计值与真实同批群存活率之间的基本关系。\n\n对 $\\lambda > 1$ 时的偏差分析\n偏差是估计值与真实值之间的差异，或者可以通过它们的比率来分析。比率为：\n$$\\frac{\\hat{l}_x^{\\mathrm{static}}}{l_x} = \\lambda^{-x}$$\n如果 $\\lambda > 1$，那么对于任何年龄 $x > 0$，我们有 $\\lambda^x > 1$。因此，$\\lambda^{-x} = \\frac{1}{\\lambda^x} < 1$。\n这意味着对于所有 $x > 0$，$\\hat{l}_x^{\\mathrm{static}} = l_x \\lambda^{-x} < l_x$。\n因此，对于一个增长的种群 ($\\lambda > 1$)，静态生命表系统地**低估**了所有正年龄的真实同批群存活率。其直观解释是，一个增长种群的横断面相对于年长年龄组（来自较小的过去出生批群）而言，过度代表了年轻年龄组（来自较大、较近的出生批群）。当以年龄为0的个体数量（最大的群体）进行归一化时，所有较年长年龄组的相对数量显得更小，从而导致表观存活率低于真实的同批群存活率。\n\n选项评估\n\nA. 在一个具有恒定 $\\lambda>1$ 的稳定种群中，通过对 $n_x(t)$ 进行归一化以使 $\\hat{l}_0^{\\mathrm{static}}=1$ 的方式估计 $\\hat{l}_x^{\\mathrm{static}}$ 的静态生命表，会得到 $\\hat{l}_x^{\\mathrm{static}}=l_x\\,\\lambda^{-x}$；因此，它低估了所有 $x>0$ 的 $l_x$。\n这个陈述是我们推导的直接结果。公式 $\\hat{l}_x^{\\mathrm{static}} = l_x \\lambda^{-x}$ 是我们推导出来的。对于 $\\lambda > 1$ 和 $x > 0$，$\\lambda^{-x} < 1$，这意味着 $\\hat{l}_x^{\\mathrm{static}} < l_x$，即低估。这个陈述完全正确。\n**结论：正确**\n\nB. 当 $\\lambda>1$ 时，静态生命表会高估较大年龄 $x$ 的 $l_x$，因为相对于单个同批群，年长个体在横断面中的代表性过高。\n这在两点上是错误的。首先，如所推导，对于 $\\lambda > 1$，静态方法*低估*了 $l_x$，而不是高估。其次，其推理是错误的。在增长的种群中，是来自较大、较近同批群的年轻个体被过度代表，而不是来自较小、过去同批群的年长个体。\n**结论：错误**\n\nC. 如果 $\\lambda=1$，则静态估计对所有年龄 $x$ 都是无偏的，即 $\\hat{l}_x^{\\mathrm{static}}=l_x$。\n我们使用我们推导的通用公式 $\\hat{l}_x^{\\mathrm{static}} = l_x \\lambda^{-x}$ 并代入 $\\lambda=1$：\n$$\\hat{l}_x^{\\mathrm{static}} = l_x (1)^{-x} = l_x \\cdot 1 = l_x$$\n在静止种群 ($\\lambda=1$) 中，静态估计与同批群存活率相同。它是无偏的。这是因为出生批群的大小随时间保持不变，所以年龄结构与存活曲线成正比。\n**结论：正确**\n\nD. 对于任何 $\\lambda\\neq 1$，比率 $\\hat{l}_x^{\\mathrm{static}}/l_x$ 是一个与年龄 $x$ 无关的常数。\n比率为 $\\frac{\\hat{l}_x^{\\mathrm{static}}}{l_x} = \\lambda^{-x}$。随着 $x$ 的增加，这个比率会变化（对于 $\\lambda > 1$ 会减小，对于 $0 < \\lambda < 1$ 会增加）。它是年龄 $x$ 的函数，不是一个常数。偏差是依赖于年龄的。\n**结论：错误**\n\nE. 对于 $\\lambda>1$ 时偏差的符号（方向）取决于特定年龄生育率表 $b_x$；在 $b_x$ 充分递增的情况下，即使 $\\lambda>1$，静态生命表也可能无偏。\n特定年龄生育率表 $b_x$ 和存活率 $l_x$ 通过欧拉-洛特卡特征方程 ($1 = \\sum_x \\lambda^{-x} l_x b_x$) 共同决定了 $\\lambda$ 的值。然而，一旦 $\\lambda > 1$ 的值确定并且种群达到了稳定的年龄分布，我们推导的关系 $\\hat{l}_x^{\\mathrm{static}} = l_x \\lambda^{-x}$ 就成立，这与产生该 $\\lambda$ 的特定 $b_x$ 表无关。偏差由 $\\lambda$ 决定，而不直接由 $b_x$ 决定。对于任何 $\\lambda > 1$，都会存在低估。估计值不可能是无偏的。\n**结论：错误**", "answer": "$$\\boxed{AC}$$", "id": "2503649"}, {"introduction": "本项高级实践将带领你从描述性的生命表分析过渡到推断性的参数化生存建模，这套方法是现代生态学和生物统计学研究的有力工具。你将亲手编写代码，为包含“右删失”数据（即部分个体的最终生存结局未知）的真实场景拟合多种生存模型。通过计算赤池信息准则 (AIC) 来进行模型选择，你将掌握一套完整的、从原始数据到模型推断的现代生存分析工作流程。[@problem_id:2503639]", "problem": "给定三个以年为单位测量的生存时间的右删失队列数据集，每个数据集代表一个具有不同存活模式的假设物种。您的任务是为三种参数化风险模型实现最大似然估计，并通过赤池信息准则 (Akaike Information Criterion, AIC) 进行模型选择。\n\n使用的基本原理和定义：\n- 风险函数 $h(t)$ 定义为 $h(t) = \\lim_{\\Delta t \\to 0^{+}} \\dfrac{\\mathbb{P}(t \\le T < t + \\Delta t \\mid T \\ge t)}{\\Delta t}$，其中 $T$ 是非负的随机事件发生时间。\n- 生存函数 $S(t)$ 是 $S(t) = \\mathbb{P}(T \\ge t)$ 并满足 $S(t) = \\exp\\!\\left(-\\int_{0}^{t} h(u)\\,du\\right)$。\n- 密度函数是 $f(t) = -\\dfrac{d}{dt} S(t) = h(t)\\,S(t)$，对于 $t > 0$。\n- 对于在时间 $c$ 发生的右删失观测，仅能观测到信息 $T \\ge c$。您必须使用上述定义将这种删失正确地纳入似然函数中。\n\n需要对每个数据集进行拟合的模型：\n- 指数风险模型，具有恒定风险 $h(t)$。\n- 韦伯 (Weibull) 风险模型，具有依赖于时间 $t$ 的单调风险。\n- 贡佩尔茨 (Gompertz) 风险模型，其风险随 $t$ 呈指数变化。\n\n对于每个数据集，您必须：\n1. 仅使用上述定义，推导并实现右删失下的对数似然函数。\n2. 对每个模型最大化对数似然函数，以获得模型参数的最大似然估计。使用适用于受约束参数（例如，限制为正的参数）的数值稳定参数化方法，并正确处理极限情况（例如，调和指数变化风险与恒定风险的极限情况）。\n3. 计算赤池信息准则 $AIC = 2p - 2\\widehat{\\ell}$，其中 $p$ 是模型中自由参数的数量，$\\widehat{\\ell}$ 是最大化的对数似然。\n4. 为每个数据集选择具有最小 $AIC$ 的模型。\n\n右删失由一个事件指示数组标明。对于每个观测值 $i$，$d_i = 1$ 表示观测到一个事件（死亡），而 $d_i = 0$ 表示一个右删失时间。\n\n使用以下测试套件（所有时间单位均为年）：\n- 测试用例 1（中等样本，事件和删失混合，近似恒定风险）：\n  - 时间 $t$: $[\\,0.2,\\,0.6,\\,1.0,\\,1.4,\\,2.1,\\,2.5,\\,3.0,\\,3.7,\\,4.2,\\,4.9,\\,5.5,\\,6.1,\\,6.8,\\,7.4,\\,8.0,\\,9.0\\,]$\n  - 事件 $d$: $[\\,1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,0,\\,0\\,]$\n- 测试用例 2（风险随老化而增加，事件更多地发生于较大的 $t$）：\n  - 时间 $t$: $[\\,0.5,\\,0.8,\\,1.0,\\,1.2,\\,1.6,\\,2.0,\\,2.4,\\,3.0,\\,3.6,\\,4.2,\\,5.0,\\,5.8\\,]$\n  - 事件 $d$: $[\\,0,\\,0,\\,0,\\,1,\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$\n- 测试用例 3（边缘案例，早期有大量右删失，事件集中在较大的 $t$）：\n  - 时间 $t$: $[\\,0.5,\\,1.0,\\,2.0,\\,3.5,\\,5.0,\\,7.0,\\,9.5,\\,12.0,\\,15.0,\\,18.0\\,]$\n  - 事件 $d$: $[\\,0,\\,0,\\,0,\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$\n\n实现和输出要求：\n- 您的程序必须通过最大似然法为每个模型和数据集估计参数，为每个模型计算 $AIC$，并选择具有最小 $AIC$ 的模型。\n- 在最终输出中使用以下模型索引约定：$0$ 代表指数模型，$1$ 代表韦伯模型，$2$ 代表贡佩尔茨模型。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3]$），其中每个条目是相应测试用例所选模型的索引。\n- 单位：所有时间单位均为年。无需进行其他单位转换。最终输出是整数，因此无单位。\n- 您的程序必须是一个完整的、可运行的实现，不需要任何用户输入。它必须使用数值稳定的方法，包括用于正性约束的适当参数变换和对小参数极限的谨慎处理。最终输出必须是指定的单行格式。不应打印任何其他文本。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n- **风险函数**：$h(t) = \\lim_{\\Delta t \\to 0^{+}} \\dfrac{\\mathbb{P}(t \\le T < t + \\Delta t \\mid T \\ge t)}{\\Delta t}$，其中 $T$ 是一个非负随机事件时间变量。\n- **生存函数**：$S(t) = \\mathbb{P}(T \\ge t)$ 且 $S(t) = \\exp\\!\\left(-\\int_{0}^{t} h(u)\\,du\\right)$。\n- **概率密度函数**：$f(t) = h(t)\\,S(t)$，对于 $t > 0$。\n- **右删失**：在时间 $c$ 的一个观测值表明事件时间 $T$ 满足 $T \\ge c$。每个观测值 $i$ 的数据由时间 $t_i$ 和事件指示符 $d_i$ 组成，其中 $d_i=1$ 表示观测到事件，$d_i=0$ 表示右删失。\n- **用于拟合的模型**：\n    1.  指数风险模型（恒定风险）。\n    2.  韦伯 (Weibull) 风险模型（单调风险）。\n    3.  贡佩尔茨 (Gompertz) 风险模型（指数变化风险）。\n- **任务**：\n    1.  推导并实现右删失数据的对数似然函数。\n    2.  找到模型参数的最大似然估计 (MLE)。\n    3.  计算赤池信息准则 (AIC)：$AIC = 2p - 2\\widehat{\\ell}$，其中 $p$ 是自由参数的数量，$\\widehat{\\ell}$ 是最大化的对数似然。\n    4.  为每个数据集选择具有最小 AIC 的模型。\n- **数据集**：\n    - **测试用例 1**：\n        - 时间 $t$: $[\\,0.2,\\,0.6,\\,1.0,\\,1.4,\\,2.1,\\,2.5,\\,3.0,\\,3.7,\\,4.2,\\,4.9,\\,5.5,\\,6.1,\\,6.8,\\,7.4,\\,8.0,\\,9.0\\,]$\n        - 事件 $d$: $[\\,1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,0,\\,0\\,]$\n    - **测试用例 2**：\n        - 时间 $t$: $[\\,0.5,\\,0.8,\\,1.0,\\,1.2,\\,1.6,\\,2.0,\\,2.4,\\,3.0,\\,3.6,\\,4.2,\\,5.0,\\,5.8\\,]$\n        - 事件 $d$: $[\\,0,\\,0,\\,0,\\,1,\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$\n    - **测试用例 3**：\n        - 时间 $t$: $[\\,0.5,\\,1.0,\\,2.0,\\,3.5,\\,5.0,\\,7.0,\\,9.5,\\,12.0,\\,15.0,\\,18.0\\,]$\n        - 事件 $d$: $[\\,0,\\,0,\\,0,\\,0,\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$\n- **输出要求**：一个单行列表，包含整数模型索引（$0$：指数模型，$1$：韦伯模型，$2$：贡佩尔茨模型），对应每个测试用例的最佳模型。\n\n### 步骤 2：使用提取的已知信息进行验证\n问题具有科学依据，提法明确且客观。它基于生存分析的既定原则，这是生物统计学和可靠性工程中的一个核心课题。风险、生存和似然函数的定义都是标准的。指数模型、韦伯模型和贡佩尔茨模型是典型的参数化生存模型。推导似然函数、执行最大似然估计 (MLE) 以及使用 AIC 进行模型选择的任务构成了一个完整且标准的统计流程。所提供的数据集是自包含的且在数值上是合理的。不存在矛盾、歧义或违反科学或数学原则的情况。\n\n### 步骤 3：结论与行动\n问题有效。将提供解决方案。\n\n### 解决方案推导与方法论\n问题的核心是在右删失情况下似然函数的构建和最大化。对于一个包含 $N$ 个个体的样本，令个体 $i$ 的数据为 $(t_i, d_i)$，其中 $t_i$ 是事件发生或删失的时间，$d_i$ 是事件指示符（如果观测到事件，则 $d_i=1$，如果删失，则 $d_i=0$）。\n\n个体 $i$ 的似然贡献是：如果观测到事件，则为概率密度函数 $f(t_i)$；如果观测被删失，则为生存函数 $S(t_i)$。整个样本的总似然是这些贡献的乘积：\n$$ L(\\boldsymbol{\\theta}) = \\prod_{i=1}^{N} [f(t_i; \\boldsymbol{\\theta})]^{d_i} [S(t_i; \\boldsymbol{\\theta})]^{1-d_i} $$\n其中 $\\boldsymbol{\\theta}$ 是模型参数的向量。使用关系式 $f(t) = h(t)S(t)$ 和 $S(t) = \\exp(-H(t))$，其中 $H(t) = \\int_0^t h(u)du$ 是累积风险函数，我们可以重写似然函数。处理对数似然函数 $\\ell(\\boldsymbol{\\theta}) = \\log L(\\boldsymbol{\\theta})$ 更为方便：\n$$ \\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left[ d_i \\log f(t_i; \\boldsymbol{\\theta}) + (1-d_i) \\log S(t_i; \\boldsymbol{\\theta}) \\right] $$\n$$ \\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left[ d_i \\log(h(t_i; \\boldsymbol{\\theta})S(t_i; \\boldsymbol{\\theta})) + (1-d_i) \\log S(t_i; \\boldsymbol{\\theta}) \\right] $$\n$$ \\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left[ d_i \\log h(t_i; \\boldsymbol{\\theta}) + d_i \\log S(t_i; \\boldsymbol{\\theta}) + (1-d_i) \\log S(t_i; \\boldsymbol{\\theta}) \\right] $$\n$$ \\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left[ d_i \\log h(t_i; \\boldsymbol{\\theta}) + \\log S(t_i; \\boldsymbol{\\theta}) \\right] $$\n代入 $\\log S(t) = -H(t)$，我们得到用于计算的最终形式：\n$$ \\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left[ d_i \\log h(t_i; \\boldsymbol{\\theta}) - H(t_i; \\boldsymbol{\\theta}) \\right] $$\n我们现在为每个模型定义 $h(t)$ 和 $H(t)$ 的具体形式，并讨论它们的数值实现。通过数值最小化负对数似然函数 $-\\ell(\\boldsymbol{\\theta})$ 来找到最大似然估计 $\\widehat{\\boldsymbol{\\theta}}$。\n\n**1. 指数模型 ($p=1$)**\n- 风险函数：$h(t; \\lambda) = \\lambda$，其中 $\\lambda > 0$。\n- 累积风险：$H(t; \\lambda) = \\int_0^t \\lambda \\,du = \\lambda t$。\n- 对数似然：$\\ell(\\lambda) = \\sum_{i=1}^{N} [d_i \\log(\\lambda) - \\lambda t_i]$。\n- 参数化：为强制约束 $\\lambda > 0$，我们使用 $\\lambda = e^{\\alpha}$ 进行重新参数化。然后相对于无约束参数 $\\alpha \\in \\mathbb{R}$ 最小化目标函数。\n\n**2. 韦伯模型 ($p=2$)**\n- 风险函数：$h(t; k, \\lambda) = \\frac{k}{\\lambda} \\left(\\frac{t}{\\lambda}\\right)^{k-1}$，其中形状参数 $k > 0$，尺度参数 $\\lambda > 0$。\n- 累积风险：$H(t; k, \\lambda) = \\left(\\frac{t}{\\lambda}\\right)^k$。\n- 对数似然：$\\ell(k, \\lambda) = \\sum_{i=1}^{N} \\left[ d_i \\left(\\log(k) - k\\log(\\lambda) + (k-1)\\log(t_i)\\right) - \\left(\\frac{t_i}{\\lambda}\\right)^k \\right]$。数据中所有 $t_i > 0$，因此 $\\log(t_i)$ 有明确定义。\n- 参数化：我们使用 $k = e^{\\alpha_1}$ 和 $\\lambda = e^{\\alpha_2}$ 来强制正性约束，对无约束参数 $\\alpha_1, \\alpha_2 \\in \\mathbb{R}$ 进行优化。\n\n**3. 贡佩尔茨模型 ($p=2$)**\n- 风险函数：$h(t; a, b) = a e^{bt}$，其中初始风险 $a > 0$，形状参数 $b \\in \\mathbb{R}$。\n- 累积风险：对于 $b \\neq 0$，$H(t; a, b) = \\int_0^t a e^{bu} \\,du = \\frac{a}{b}(e^{bt} - 1)$。\n- 极限情况：当 $b \\to 0$ 时，$h(t) \\to a$ 且 $H(t) \\to at$。贡佩尔茨模型平滑地收敛到率为 $\\lambda = a$ 的指数模型。\n- 对数似然：$\\ell(a, b) = \\sum_{i=1}^{N} \\left[ d_i (\\log(a) + b t_i) - \\frac{a}{b}(e^{bt_i} - 1) \\right]$。\n- 参数化：我们使用 $a = e^{\\alpha_1}$ 和 $b = \\alpha_2$，对 $\\alpha_1, \\alpha_2 \\in \\mathbb{R}$ 进行优化。为确保 $b \\approx 0$ 时的数值稳定性，项 $\\frac{e^{bt_i}-1}{b}$ 使用一个等效于 `expm1(x)/x` 的函数来计算，当 $b t_i \\to 0$ 时，该函数能正确地计算出其极限值 $t_i$。\n\n**模型选择**\n对于每个模型，在找到最大似然估计 (MLEs) $\\widehat{\\boldsymbol{\\theta}}$ 后，我们计算最大化的对数似然 $\\widehat{\\ell} = \\ell(\\widehat{\\boldsymbol{\\theta}})$。然后计算赤池信息准则：\n$$ AIC = 2p - 2\\widehat{\\ell} $$\n其中 $p$ 是参数数量（指数模型为 1，韦伯模型为 2，贡佩尔茨模型为 2）。选择具有最低 AIC 值的模型作为给定数据集的最佳拟合模型，以平衡拟合优度和模型复杂性。\n\n实现将通过为每个模型定义一个负对数似然函数来进行，使用指定的参数化方法。将使用一个优化例程（`scipy.optimize.minimize`）来找到为每个数据集最小化这些函数的参数。最后，将比较 AIC 值以选择最优模型。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Fits Exponential, Weibull, and Gompertz survival models to three\n    right-censored datasets, selecting the best model for each dataset\n    using the Akaike Information Criterion (AIC).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.2, 0.6, 1.0, 1.4, 2.1, 2.5, 3.0, 3.7, 4.2, 4.9, 5.5, 6.1, 6.8, 7.4, 8.0, 9.0]),\n            np.array([1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0])\n        ),\n        (\n            np.array([0.5, 0.8, 1.0, 1.2, 1.6, 2.0, 2.4, 3.0, 3.6, 4.2, 5.0, 5.8]),\n            np.array([0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1])\n        ),\n        (\n            np.array([0.5, 1.0, 2.0, 3.5, 5.0, 7.0, 9.5, 12.0, 15.0, 18.0]),\n            np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1])\n        )\n    ]\n\n    results = []\n    \n    # Model indexing: 0: Exponential, 1: Weibull, 2: Gompertz\n    model_indices = {'exp': 0, 'weibull': 1, 'gompertz': 2}\n    \n    # --- Negative Log-Likelihood Functions ---\n\n    def neg_log_lik_exp(params, t, d):\n        \"\"\"Negative log-likelihood for the Exponential model.\"\"\"\n        log_lambda = params[0]\n        lambda_ = np.exp(log_lambda)\n        \n        log_h = log_lambda\n        H = lambda_ * t\n        \n        log_lik = np.sum(d * log_h - H)\n        return -log_lik\n\n    def neg_log_lik_weibull(params, t, d):\n        \"\"\"Negative log-likelihood for the Weibull model.\"\"\"\n        log_k, log_lambda = params\n        k = np.exp(log_k)\n        lambda_ = np.exp(log_lambda)\n        \n        # log(t) is safe as all t > 0 in the provided data.\n        log_t = np.log(t)\n        \n        log_h = log_k + (k - 1) * log_t - k * log_lambda\n        H = np.exp(k * (log_t - log_lambda))\n\n        log_lik = np.sum(d * log_h - H)\n        return -log_lik\n\n    def neg_log_lik_gompertz(params, t, d):\n        \"\"\"Negative log-likelihood for the Gompertz model.\"\"\"\n        log_a, b = params\n        a = np.exp(log_a)\n        \n        log_h = log_a + b * t\n        \n        # Numerically stable computation for H(t)\n        if np.abs(b)  1e-9:\n            H = a * t\n        else:\n            H = a * np.expm1(b * t) / b\n            \n        log_lik = np.sum(d * log_h - H)\n        return -log_lik\n\n    for t_data, d_data in test_cases:\n        \n        # --- Initial Guesses for Optimization ---\n        # A good initial guess is the MLE for the exponential model,\n        # which is a special case of both Weibull (k=1) and Gompertz (b=0).\n        sum_d = np.sum(d_data)\n        sum_t = np.sum(t_data)\n        \n        # Handle case where there are no events to avoid division by zero.\n        if sum_d == 0:\n            lambda_init = 1.0 / np.mean(t_data) if len(t_data) > 0 else 1.0\n        else:\n             lambda_init = sum_d / sum_t\n        \n        # [log(lambda)]\n        params0_exp = [np.log(lambda_init)]\n        # [log(k), log(lambda_weibull)], init k=1, lambda_weibull=1/lambda_exp\n        params0_weibull = [0.0, -np.log(lambda_init)]\n        # [log(a), b], init a=lambda_exp, b=0\n        params0_gompertz = [np.log(lambda_init), 0.0]\n\n        # --- Optimization ---\n        # Exponential\n        res_exp = minimize(neg_log_lik_exp, params0_exp, args=(t_data, d_data), method='Nelder-Mead')\n        # Weibull\n        res_weibull = minimize(neg_log_lik_weibull, params0_weibull, args=(t_data, d_data), method='Nelder-Mead')\n        # Gompertz\n        res_gompertz = minimize(neg_log_lik_gompertz, params0_gompertz, args=(t_data, d_data), method='Nelder-Mead')\n\n        # --- AIC Calculation ---\n        # AIC = 2*p - 2*logL, where logL = -min_val_of_neg_log_lik\n        p_exp = 1\n        aic_exp = 2 * p_exp + 2 * res_exp.fun\n\n        p_weibull = 2\n        aic_weibull = 2 * p_weibull + 2 * res_weibull.fun\n        \n        p_gompertz = 2\n        aic_gompertz = 2 * p_gompertz + 2 * res_gompertz.fun\n        \n        # --- Model Selection ---\n        aics = [aic_exp, aic_weibull, aic_gompertz]\n        best_model_index = np.argmin(aics)\n        results.append(best_model_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2503639"}]}