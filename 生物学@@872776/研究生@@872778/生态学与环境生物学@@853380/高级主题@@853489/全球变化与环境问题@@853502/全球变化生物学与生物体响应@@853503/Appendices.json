{"hands_on_practices": [{"introduction": "矩阵种群模型是将生物体的生命周期阶段（如幼年和成年）的存活率和繁殖率与环境因素联系起来的有力工具。通过将这些关键的生命参数表示为温度的函数，我们可以预测种群在气候变化情景下的动态，并确定其生存的临界热阈值。本练习 [@problem_id:2495608] 将指导您应用这些模型，计算一个假想种群无法维持自身（即增长率 $\\lambda=1$）的临界温度，并通过弹性分析找出在热胁迫下限制种群增长的“瓶颈”生命阶段。", "problem": "一个两阶段变温动物种群（幼体和成体）的结构由年度投影矩阵 $A(T)$ 决定，该矩阵取决于年平均温度 $T$（单位：摄氏度）。状态向量为 $n(t) = \\begin{pmatrix} J(t) \\\\ A(t) \\end{pmatrix}$，年度动态遵循 $n(t+1) = A(T)\\,n(t)$，其中\n$$\nA(T) \\;=\\; \\begin{pmatrix}\n0  F(T) \\\\\nS_{j}(T)  S_{a}(T)\n\\end{pmatrix},\n$$\n$S_{j}(T)$ 是幼体成长为成体的年存活率，$S_{a}(T)$ 是成体年存活率，$F(T)$ 是每个成体每年新补充的幼体数量。在 $T \\in [5,35]$（摄氏度）的温和气候范围内，经验拟合的线性近似为\n$$\nS_{j}(T) \\;=\\; 0.5 \\;-\\; 0.005\\,(T-20), \\quad\nS_{a}(T) \\;=\\; 0.6 \\;-\\; 0.01\\,(T-20), \\quad\nF(T) \\;=\\; 0.8 \\;-\\; 0.01\\,(T-20).\n$$\n假设时间步长为一年，在临界温度下种群是人口统计学上平稳的，并且 $A(T)$ 的主特征值 $\\lambda(T)$ 等于长期乘法增长因子。将在 $T^{\\star}$（即 $\\lambda(T^{\\star}) = 1$ 时的温度）下的种群统计学瓶颈阶段定义为在该温度下，其存活率分量对 $\\lambda$ 具有最大弹性的生命阶段。使用参数 $\\theta$ 的标准弹性定义 $e_{\\theta} = (\\theta/\\lambda)\\,(\\partial \\lambda/\\partial \\theta)$，以及用于矩阵种群模型的成熟的特征值扰动理论。\n\n任务：\n1. 计算临界温度 $T^{\\star}$（单位：摄氏度），使得主特征值满足 $\\lambda(T^{\\star}) = 1$。\n2. 在 $T^{\\star}$ 下，通过比较 $\\lambda$ 对 $S_{j}$ 和 $S_{a}$ 的弹性，确定哪个存活率分量构成了种群统计学瓶颈。将瓶颈报告为阶段指数 $k^{\\star}$，其中 $k^{\\star} = 1$ 表示幼体（对 $S_{j}$ 的弹性更大），$k^{\\star} = 2$ 表示成体（对 $S_{a}$ 的弹性更大）。\n\n答案格式：\n- 仅返回行向量 $\\begin{pmatrix} T^{\\star}  k^{\\star} \\end{pmatrix}$。\n- 将 $T^{\\star}$ 四舍五入至三位有效数字。\n- 以摄氏度表示 $T^{\\star}$（在最终的方框答案中不要包含单位）。", "solution": "对问题陈述进行分析后，认定其有效。它在科学上基于矩阵种群模型的原理，这是生态学中的一个标准工具。问题是适定的，为获得唯一解提供了所有必要的数据和定义。其语言客观，设定在指定域内内部一致且物理上合理。\n\n该问题需要分两步解决：首先，计算临界温度 $T^{\\star}$，在该温度下种群增长率为1；其次，通过比较增长率对幼体和成体存活率的弹性，确定在此温度下的种群统计学瓶颈。\n\n种群动态由矩阵方程 $n(t+1) = A(T)n(t)$ 描述，其中投影矩阵为\n$$ A(T) = \\begin{pmatrix} 0  F(T) \\\\ S_{j}(T)  S_{a}(T) \\end{pmatrix} $$\n长期乘法增长因子是矩阵 $A(T)$ 的主特征值 $\\lambda$。该矩阵的特征方程由 $\\det(A(T) - \\lambda I) = 0$ 得出：\n$$ \\det \\begin{pmatrix} -\\lambda  F(T) \\\\ S_{j}(T)  S_{a}(T) - \\lambda \\end{pmatrix} = (-\\lambda)(S_{a}(T) - \\lambda) - F(T)S_{j}(T) = 0 $$\n$$ \\lambda^{2} - S_{a}(T)\\lambda - F(T)S_{j}(T) = 0 $$\n这是此两阶段模型的欧拉-洛特卡方程。\n\n第1部分：计算临界温度 $T^{\\star}$。\n我们要寻找使种群保持平稳的温度 $T^{\\star}$，这对应于 $\\lambda(T^{\\star}) = 1$。将 $\\lambda = 1$ 代入特征方程，得到：\n$$ 1^{2} - S_{a}(T) \\cdot 1 - F(T)S_{j}(T) = 0 \\implies 1 - S_{a}(T) - F(T)S_{j}(T) = 0 $$\n生命率是关于温度 $T$ 的线性函数：\n$$ S_{j}(T) = 0.5 - 0.005(T-20) $$\n$$ S_{a}(T) = 0.6 - 0.01(T-20) $$\n$$ F(T) = 0.8 - 0.01(T-20) $$\n让我们定义一个移位温度变量 $\\Delta T = T - 20$。方程变为：\n$$ S_{j}(\\Delta T) = 0.5 - 0.005 \\Delta T $$\n$$ S_{a}(\\Delta T) = 0.6 - 0.01 \\Delta T $$\n$$ F(\\Delta T) = 0.8 - 0.01 \\Delta T $$\n将这些表达式代入平稳条件：\n$$ 1 - (0.6 - 0.01 \\Delta T) - (0.8 - 0.01 \\Delta T)(0.5 - 0.005 \\Delta T) = 0 $$\n$$ 0.4 + 0.01 \\Delta T - (0.8 \\cdot 0.5 - 0.8 \\cdot 0.005 \\Delta T - 0.01 \\Delta T \\cdot 0.5 + 0.01 \\Delta T \\cdot 0.005 \\Delta T) = 0 $$\n$$ 0.4 + 0.01 \\Delta T - (0.4 - 0.004 \\Delta T - 0.005 \\Delta T + 0.00005 (\\Delta T)^{2}) = 0 $$\n$$ 0.4 + 0.01 \\Delta T - 0.4 + 0.009 \\Delta T - 0.00005 (\\Delta T)^{2} = 0 $$\n$$ 0.019 \\Delta T - 0.00005 (\\Delta T)^{2} = 0 $$\n提取公因子 $\\Delta T$：\n$$ \\Delta T (0.019 - 0.00005 \\Delta T) = 0 $$\n这个关于 $\\Delta T$ 的二次方程有两个解：\n1. $\\Delta T = 0$\n2. $0.019 - 0.00005 \\Delta T = 0 \\implies \\Delta T = \\frac{0.019}{0.00005} = \\frac{19000}{5} = 380$\n\n转换回温度 $T = \\Delta T + 20$：\n1. $T^{\\star} = 0 + 20 = 20$\n2. $T^{\\star} = 380 + 20 = 400$\n\n题目指明该模型在 $T \\in [5, 35]$ 的气候范围内有效。第二个解 $T = 400$ 超出了此范围。因此，唯一有效的临界温度是 $T^{\\star} = 20$ 摄氏度。四舍五入到三位有效数字为 $20.0$。\n\n第2部分：确定种群统计学瓶颈。\n我们必须在 $T^{\\star} = 20$ 时比较 $\\lambda$ 对幼体存活率 $S_{j}$ 和成体存活率 $S_{a}$ 的弹性。$\\lambda$ 对矩阵元素 $a_{ij}$ 的弹性由下式给出\n$$ e_{ij} = \\frac{a_{ij}}{\\lambda} \\frac{\\partial \\lambda}{\\partial a_{ij}} = \\frac{a_{ij}}{\\lambda} \\frac{v_i w_j}{\\langle v, w \\rangle} $$\n其中 $w$ 是右特征向量（稳定阶段分布），$v$ 是左特征向量（繁殖值），$\\langle v, w \\rangle = v^{T}w$ 是它们的标量积。我们比较的是 $e_{S_{j}} = e_{21}$ 和 $e_{S_{a}} = e_{22}$。\n\n在 $T^{\\star} = 20$ 时，我们有 $\\Delta T = 0$，所以生命率为：\n$S_{j} = 0.5$，$S_{a} = 0.6$，$F = 0.8$。\n矩阵为 $A(20) = \\begin{pmatrix} 0  0.8 \\\\ 0.5  0.6 \\end{pmatrix}$ 且 $\\lambda = 1$。\n\n首先，从 $A w = \\lambda w$ 求出右特征向量 $w = \\begin{pmatrix} w_1 \\\\ w_2 \\end{pmatrix}$：\n$$ \\begin{pmatrix} 0  0.8 \\\\ 0.5  0.6 \\end{pmatrix} \\begin{pmatrix} w_1 \\\\ w_2 \\end{pmatrix} = 1 \\cdot \\begin{pmatrix} w_1 \\\\ w_2 \\end{pmatrix} $$\n这得到方程组：$0.8 w_2 = w_1$ 和 $0.5 w_1 + 0.6 w_2 = w_2$。这些方程是一致的。选择 $w_2 = 1$，得到 $w_1 = 0.8$。所以，$w = \\begin{pmatrix} 0.8 \\\\ 1 \\end{pmatrix}$。\n\n接下来，从 $v^{T}A = \\lambda v^{T}$ 求出左特征向量 $v = \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix}$：\n$$ \\begin{pmatrix} v_1  v_2 \\end{pmatrix} \\begin{pmatrix} 0  0.8 \\\\ 0.5  0.6 \\end{pmatrix} = 1 \\cdot \\begin{pmatrix} v_1  v_2 \\end{pmatrix} $$\n这得到：$0.5 v_2 = v_1$ 和 $0.8 v_1 + 0.6 v_2 = v_2$。这些方程是一致的。选择 $v_1 = 1$，得到 $v_2 = 1/0.5 = 2$。所以，$v = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n\n标量积为 $\\langle v, w \\rangle = v_1 w_1 + v_2 w_2 = (1)(0.8) + (2)(1) = 0.8 + 2 = 2.8$。\n\n现在我们计算弹性。存活率分量是 $S_j = a_{21}$ 和 $S_a = a_{22}$。\n幼体存活率 $S_{j}$ 的弹性：\n$$ e_{S_{j}} = e_{21} = \\frac{a_{21} v_2 w_1}{\\lambda \\langle v, w \\rangle} = \\frac{0.5 \\cdot 2 \\cdot 0.8}{1 \\cdot 2.8} = \\frac{0.8}{2.8} = \\frac{8}{28} = \\frac{2}{7} $$\n成体存活率 $S_{a}$ 的弹性：\n$$ e_{S_{a}} = e_{22} = \\frac{a_{22} v_2 w_2}{\\lambda \\langle v, w \\rangle} = \\frac{0.6 \\cdot 2 \\cdot 1}{1 \\cdot 2.8} = \\frac{1.2}{2.8} = \\frac{12}{28} = \\frac{3}{7} $$\n比较这两个值：$e_{S_{a}} = 3/7 > 2/7 = e_{S_{j}}$。\n种群增长率对成体存活率的弹性大于对幼体存活率的弹性。因此，成体阶段是种群统计学瓶颈。根据题目的索引，这对应于 $k^{\\star} = 2$。\n\n最终答案是行向量 $\\begin{pmatrix} T^{\\star}  k^{\\star} \\end{pmatrix}$。\n$T^{\\star}$ 四舍五入到三位有效数字为 $20.0$。\n$k^{\\star}$ 为 $2$。\n结果是 $\\begin{pmatrix} 20.0  2 \\end{pmatrix}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n20.0  2\n\\end{pmatrix}\n}\n$$", "id": "2495608"}, {"introduction": "种群的统计学速率最终由其成员的生理表现决定。因此，理解生物体对环境压力的生理反应对于预测其在全球变化下的脆弱性至关重要。本练习 [@problem_id:2495573] 模拟了一个典型的生态生理学实验，您将通过分析呼吸测量数据来量化一个水生生物在不同温度和氧气水平下维持代谢功能的能力。最终，您将计算出“热安全裕度”，这是一个评估物种对气候变暖和缺氧双重压力脆弱性的关键指标。", "problem": "给定在多个温度下测量的某水生外温动物的密闭式呼吸测量数据集。对于每个温度，溶解氧分压（单位：千帕，kPa）从空气饱和条件开始逐步降低，同时测量生物体在静息状态下的耗氧率。假设以下基本原理和定义为出发点：\n\n- 在临界氧张力以上，生物体调节其代谢率，质量比耗氧率与环境氧分压无关；在临界氧张力以下，耗氧率随环境氧分压近似线性下降。该转折点即为临界氧张力 $P_{crit}$。\n- 对于给定的温度 $T$（单位：摄氏度， $^{\\circ}\\mathrm{C}$），耗氧率 $M$（在各温度间单位一致的任意单位）作为氧分压 $P$（单位：kPa）的函数，其分段模型为\n$$\nM(P) =\n\\begin{cases}\nc,  P \\ge P_{crit},\\\\\nm\\,(P - P_{crit}) + c,  P  P_{crit},\n\\end{cases}\n$$\n其中 $c$ 是调节平台期代谢率，$m$ 是氧依赖区的斜率。测量数据除四舍五入外不含随机误差，并与此理想化模型一致。\n- 在有限的温度范围内，根据经验将 $P_{crit}$ 和 $T$ 之间的关系近似为线性是合理的，\n$$\nP_{crit}(T) \\approx a + b\\,T,\n$$\n其中的常数 $a$ 和 $b$ 通过对 $(T, P_{crit})$ 估计值集合进行最小二乘回归确定。\n- 定义在环境氧分压 $P_{amb}$（单位：kPa）下，氧限制性调节温度上限 $T^{*}(P_{amb})$ 为方程 $P_{crit}(T^{*}) = P_{amb}$ 的解。在线性近似下，如果 $b \\ne 0$，\n$$\nT^{*}(P_{amb}) = \\frac{P_{amb} - a}{b}.\n$$\n- 定义热安全阈为\n$$\n\\mathrm{TSM}(P_{amb}) = T^{*}(P_{amb}) - T_{env},\n$$\n其中 $T_{env}$ 是环境温度（单位：$^{\\circ}\\mathrm{C}$）。\n\n您的任务是编写一个程序，对每个测试用例执行以下操作：\n\n1. 对于每个温度 $T$，通过拟合上述分段模型，从提供的 $(P, M)$ 数据中估计 $P_{crit}$。使用以下原则性估计程序：对于观测到的不同 $P$ 值中的每个候选断点 $\\tilde{P}$（不包括最小值，以确保下段至少有一个点），计算\n   - 平台期估计值 $c$，即 $P \\ge \\tilde{P}$ 时观测到的 $M$ 的平均值，\n   - 下段的斜率估计值 $m$，通过对仅含 $P  \\tilde{P}$ 的点进行变换回归 $M - c = m\\,(P - \\tilde{P})$ 使用最小二乘法计算，\n   - 在连续性约束下，两个分段的总平方误差和。\n   选择使该总误差最小化的 $\\tilde{P}$，并将其报告为该温度下的估计 $P_{crit}$。\n2. 使用所有温度下的估计 $P_{crit}$ 值集合，通过最小二乘法拟合线性模型 $P_{crit}(T) \\approx a + b\\,T$。\n3. 计算常氧 ($P_{amb} = P_{norm}$) 和低氧 ($P_{amb} = P_{hyp}$) 条件下的 $T^{*}(P_{amb})$，然后使用测试用例中提供的 $T_{env}$ 计算 $\\mathrm{TSM}(P_{norm})$ 和 $\\mathrm{TSM}(P_{hyp})$。\n\n以 kPa 为单位表示 $P_{crit}$，以 $^{\\circ}\\mathrm{C}$ 为单位表示 $T^{*}$，以 $^{\\circ}\\mathrm{C}$ 为单位表示 $\\mathrm{TSM}$。将所有报告的浮点数输出四舍五入到两位小数。\n\n三个测试用例的输入数据（直接嵌入在您的代码中）如下：\n\n- 测试用例 1：\n  - 各温度下的数据集：\n    - $T = 15$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[2,4,6,8,12,16,20]$，$M$ (任意单位) = $[20,40,60,80,80,80,80]$。\n    - $T = 20$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[3,6,9,12,15,18,21]$，$M$ = $[27.5,55,82.5,110,110,110,110]$。\n    - $T = 25$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[4,8,12,16,18,20,21]$，$M$ = $[37.5,75,112.5,150,150,150,150]$。\n  - 环境氧：$P_{norm} = 21$ kPa，$P_{hyp} = 10$ kPa。\n  - 环境温度：$T_{env} = 22$ $^{\\circ}\\mathrm{C}$。\n\n- 测试用例 2：\n  - 各温度下的数据集：\n    - $T = 10$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[1,3.5,7,10,14,18,21]$，$M$ = $[10,35,70,70,70,70,70]$。\n    - $T = 15$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[2,5,10,14,18,21]$，$M$ = $[20,50,100,100,100,100]$。\n    - $T = 20$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[2,6.5,13,16,19,21]$，$M$ = $[20,65,130,130,130,130]$。\n  - 环境氧：$P_{norm} = 21$ kPa，$P_{hyp} = 10$ kPa。\n  - 环境温度：$T_{env} = 18$ $^{\\circ}\\mathrm{C}$。\n\n- 测试用例 3：\n  - 各温度下的数据集：\n    - $T = 12$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[0.5,2.5,5,10,15,21]$，$M$ = $[7.5,37.5,75,75,75,75]$。\n    - $T = 22$ $^{\\circ}\\mathrm{C}$：$P$ (kPa) = $[3,7,14,17,20,21]$，$M$ = $[30,70,140,140,140,140]$。\n  - 环境氧：$P_{norm} = 21$ kPa，$P_{hyp} = 10$ kPa。\n  - 环境温度：$T_{env} = 20$ $^{\\circ}\\mathrm{C}$。\n\n您的程序应生成单行输出，其中包含一个按测试用例划分的结果列表。每个测试用例的结果必须是按以下结构组织的列表：\n- 估计的 $P_{crit}$ 值列表（按给定顺序每个温度一个值），单位为 kPa，四舍五入到两位小数，\n- $T^{*}(P_{norm})$，单位为 $^{\\circ}\\mathrm{C}$，四舍五入到两位小数，\n- $T^{*}(P_{hyp})$，单位为 $^{\\circ}\\mathrm{C}$，四舍五入到两位小数，\n- $\\mathrm{TSM}(P_{norm})$，单位为 $^{\\circ}\\mathrm{C}$，四舍五入到两位小数，\n- $\\mathrm{TSM}(P_{hyp})$，单位为 $^{\\circ}\\mathrm{C}$，四舍五入到两位小数。\n\n因此，最终输出必须是单行的 Python 风格列表的列表，例如 $[[[...], \\dots], [[...], \\dots], [[...], \\dots]]$，不含任何额外文本。", "solution": "该问题要求对有关水生外温动物对环境氧和温度变化的代谢响应的生态生理学数据进行顺序分析。分析分为三个主要阶段：首先，根据多个温度下的分段耗氧数据估计临界氧张力 $P_{crit}$；其次，建立 $P_{crit}$ 和温度 $T$ 之间关系的模型；第三，计算生态学相关指标，如氧限制性调节温度上限 $T^{*}$ 和热安全阈 $\\mathrm{TSM}$。整个过程基于已建立的生理学模型和标准统计方法。\n\n逻辑步骤如下：\n\n**1. 临界氧张力 ($P_{crit}$) 的估计**\n\n对于恒定温度 $T$ 下的每组呼吸测量数据 $(P_i, M_i)$，我们必须估计分段模型中的断点 $P_{crit}$：\n$$\nM(P) =\n\\begin{cases}\nc,  P \\ge P_{crit}\\\\\nm\\,(P - P_{crit}) + c,  P  P_{crit}\n\\end{cases}\n$$\n问题指定了一种在候选断点集上进行网格搜索的方法。设观测到的不同氧分压集合为 $\\{p_1, p_2, ..., p_k\\}$（按升序排列）。候选断点，记为 $\\tilde{P}$，从集合 $\\{p_2, ..., p_k\\}$ 中选取，从而确保对于任何候选 $\\tilde{P}$，数据集都被划分为非空的上段（$P \\ge \\tilde{P}$）和下段（$P  \\tilde{P}$）。\n\n对于每个候选断点 $\\tilde{P}$：\n\n- 调节代谢率 $c$ 通过计算上段（此时生物体为氧调节者）耗氧率 $M_i$ 的平均值来估计：\n$$\n\\hat{c} = \\frac{1}{N_{upper}} \\sum_{i | P_i \\ge \\tilde{P}} M_i\n$$\n其中 $N_{upper}$ 是上段数据点的数量。\n\n- 氧依赖区的斜率 $m$ 使用下段数据的线性最小二乘法来估计。该段的模型是 $M_i = m(P_i - \\tilde{P}) + c$。为了满足在 $P = \\tilde{P}$ 处的连续性约束，我们使用上段估计的 $\\hat{c}$，并对变换后的变量 $y_i = M_i - \\hat{c}$ 和 $x_i = P_i - \\tilde{P}$ 进行回归。模型变为 $y_i = m x_i$，这是一个通过原点的回归。$m$ 的最小二乘估计值为：\n$$\n\\hat{m} = \\frac{\\sum_{i | P_i  \\tilde{P}} x_i y_i}{\\sum_{i | P_i  \\tilde{P}} x_i^2} = \\frac{\\sum_{i | P_i  \\tilde{P}} (P_i - \\tilde{P})(M_i - \\hat{c})}{\\sum_{i | P_i  \\tilde{P}} (P_i - \\tilde{P})^2}\n$$\n只要分母不为零，该估计就有效，所提供数据集的结构满足此条件。\n\n- 候选 $\\tilde{P}$ 的总平方误差和（SSE）是两段误差之和：\n$$\n\\mathrm{SSE}(\\tilde{P}) = \\sum_{i | P_i \\ge \\tilde{P}} (M_i - \\hat{c})^2 + \\sum_{i | P_i  \\tilde{P}} (M_i - (\\hat{m}(P_i - \\tilde{P}) + \\hat{c}))^2\n$$\n\n临界氧张力的最优估计值 $\\hat{P}_{crit}$ 是使该总 SSE 最小的候选断点 $\\tilde{P}$：\n$$\n\\hat{P}_{crit} = \\arg\\min_{\\tilde{P}} \\mathrm{SSE}(\\tilde{P})\n$$\n\n**2. $P_{crit}$ 温度依赖性的建模**\n\n在获得每个温度 $T_j$ 的一组估计对 $(\\hat{P}_{crit,j}, T_j)$ 后，我们使用线性近似来对其关系进行建模：\n$$\nP_{crit}(T) \\approx a + bT\n$$\n参数 $a$（截距）和 $b$（斜率）通过对 $(\\hat{P}_{crit,j}, T_j)$ 点集进行简单线性回归（普通最小二乘法）来确定。系数的标准公式为：\n$$\nb = \\frac{N \\sum(T_j \\hat{P}_{crit,j}) - (\\sum T_j)(\\sum \\hat{P}_{crit,j})}{N \\sum(T_j^2) - (\\sum T_j)^2}\n$$\n$$\na = \\bar{\\hat{P}}_{crit} - b \\bar{T}\n$$\n其中 $N$ 是温度处理的数量，$\\bar{T}$ 和 $\\bar{\\hat{P}}_{crit}$ 分别是温度和估计的临界氧张力的平均值。标准数值库为此计算提供了稳健的函数。\n\n**3. 热阈值和安全阈的计算**\n\n在建立线性模型 $P_{crit}(T) = a + bT$ 后，我们可以为给定的环境氧分压 $P_{amb}$ 计算氧限制性调节温度上限 $T^{*}(P_{amb})$。该阈值定义为调节所需的氧水平等于环境水平时的温度，即 $P_{crit}(T^{*}) = P_{amb}$。求解 $T^{*}$ 可得：\n$$\nT^{*}(P_{amb}) = \\frac{P_{amb} - a}{b} \\quad (\\text{for } b \\neq 0)\n$$\n此计算分别在常氧（$P_{amb} = P_{norm}$）和低氧（$P_{amb} = P_{hyp}$）条件下进行。\n\n最后，给定环境氧水平下的热安全阈（TSM）是该阈值温度与当前环境温度 $T_{env}$ 之间的差值：\n$$\n\\mathrm{TSM}(P_{amb}) = T^{*}(P_{amb}) - T_{env}\n$$\n正的 TSM 表示生物体在环境温度下能够维持其调节的代谢率，而负的 TSM 则表明它将被迫进入氧遵从状态，这是一种代谢抑制的状态。\n\n以下程序为提供的测试用例实现了这整个序列，并按要求将最终数值结果四舍五入到两位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases as specified.\n    \"\"\"\n    test_cases = [\n        {\n            \"datasets\": [\n                {\"T\": 15, \"P\": np.array([2, 4, 6, 8, 12, 16, 20]), \"M\": np.array([20, 40, 60, 80, 80, 80, 80])},\n                {\"T\": 20, \"P\": np.array([3, 6, 9, 12, 15, 18, 21]), \"M\": np.array([27.5, 55, 82.5, 110, 110, 110, 110])},\n                {\"T\": 25, \"P\": np.array([4, 8, 12, 16, 18, 20, 21]), \"M\": np.array([37.5, 75, 112.5, 150, 150, 150, 150])},\n            ],\n            \"P_norm\": 21.0, \"P_hyp\": 10.0, \"T_env\": 22.0\n        },\n        {\n            \"datasets\": [\n                {\"T\": 10, \"P\": np.array([1, 3.5, 7, 10, 14, 18, 21]), \"M\": np.array([10, 35, 70, 70, 70, 70, 70])},\n                {\"T\": 15, \"P\": np.array([2, 5, 10, 14, 18, 21]), \"M\": np.array([20, 50, 100, 100, 100, 100])},\n                {\"T\": 20, \"P\": np.array([2, 6.5, 13, 16, 19, 21]), \"M\": np.array([20, 65, 130, 130, 130, 130])},\n            ],\n            \"P_norm\": 21.0, \"P_hyp\": 10.0, \"T_env\": 18.0\n        },\n        {\n            \"datasets\": [\n                {\"T\": 12, \"P\": np.array([0.5, 2.5, 5, 10, 15, 21]), \"M\": np.array([7.5, 37.5, 75, 75, 75, 75])},\n                {\"T\": 22, \"P\": np.array([3, 7, 14, 17, 20, 21]), \"M\": np.array([30, 70, 140, 140, 140, 140])},\n            ],\n            \"P_norm\": 21.0, \"P_hyp\": 10.0, \"T_env\": 20.0\n        }\n    ]\n\n    def estimate_pcrit(P_obs, M_obs):\n        \"\"\"\n        Estimates Pc_rit for a single dataset by finding the breakpoint\n        that minimizes the total sum of squared errors.\n        \"\"\"\n        min_sse = float('inf')\n        best_pcrit = None\n        \n        # Candidate breakpoints are all distinct P values except the minimum\n        candidate_p = np.unique(P_obs)[1:]\n\n        for p_tilde in candidate_p:\n            mask_upper = P_obs >= p_tilde\n            mask_lower = P_obs  p_tilde\n\n            P_upper, M_upper = P_obs[mask_upper], M_obs[mask_upper]\n            P_lower, M_lower = P_obs[mask_lower], M_obs[mask_lower]\n\n            if P_lower.size == 0:\n                continue\n\n            # Estimate c from the upper (regulated) segment\n            c = np.mean(M_upper)\n\n            # Estimate m from the lower (conforming) segment using transformed variables\n            y_trans = M_lower - c\n            x_trans = P_lower - p_tilde\n            \n            # Use formula for regression through the origin: m = sum(xy)/sum(x^2)\n            sum_x_squared = np.sum(x_trans**2)\n            if sum_x_squared == 0:\n                 # This would happen if all P_lower values were identical,\n                 # which is not the case for this problem's data.\n                 # Skip this candidate if it happens.\n                continue\n            \n            m = np.sum(x_trans * y_trans) / sum_x_squared\n\n            # Calculate total sum of squared errors (SSE)\n            sse_upper = np.sum((M_upper - c)**2)\n            M_pred_lower = m * x_trans + c\n            sse_lower = np.sum((M_lower - M_pred_lower)**2)\n            total_sse = sse_upper + sse_lower\n\n            if total_sse  min_sse:\n                min_sse = total_sse\n                best_pcrit = p_tilde\n\n        return best_pcrit\n\n    all_results = []\n    for case in test_cases:\n        pcrit_estimates = []\n        temps = []\n        for dataset in case[\"datasets\"]:\n            T, P, M = dataset[\"T\"], dataset[\"P\"], dataset[\"M\"]\n            temps.append(T)\n            pcrit = estimate_pcrit(P, M)\n            pcrit_estimates.append(pcrit)\n        \n        # Fit linear model Pc_rit = a + b*T\n        # np.polyfit returns coefficients [b, a] for a degree 1 polynomial\n        b, a = np.polyfit(temps, pcrit_estimates, 1)\n\n        P_norm = case[\"P_norm\"]\n        P_hyp = case[\"P_hyp\"]\n        T_env = case[\"T_env\"]\n\n        # Calculate T* and TSM\n        if b == 0:\n            T_star_norm = float('inf')\n            T_star_hyp = float('inf')\n        else:\n            T_star_norm = (P_norm - a) / b\n            T_star_hyp = (P_hyp - a) / b\n\n        tsm_norm = T_star_norm - T_env\n        tsm_hyp = T_star_hyp - T_env\n        \n        # Format results for the current test case\n        case_result = [\n            [round(p, 2) for p in pcrit_estimates],\n            round(T_star_norm, 2),\n            round(T_star_hyp, 2),\n            round(tsm_norm, 2),\n            round(tsm_hyp, 2)\n        ]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(all_results)\n\nsolve()\n```", "id": "2495573"}, {"introduction": "现实世界中的环境不是静止的，而是不断波动的。超越对平均条件的响应，理解种群如何应对气候的*变异性*是全球变化生物学的一个前沿领域。本高级练习 [@problem_id:2495642] 将引导您进入随机种群动态的世界，在这里您将模拟一个受自相关环境驱动因子影响的种群。通过这个模拟，您将亲手量化非线性响应（即“非线性平均”）和环境的时间结构（即自相关）如何共同作用，从而对长期种群增长率产生深刻且往往是违反直觉的影响。", "problem": "考虑一个暴露于随时间波动的环境驱动因素的离散时间种群。设 $N_t$ 表示时间 $t$ 的种群丰度，并假设丰度根据 $N_{t+1} = N_t \\, \\lambda_t$ 进行乘法变化，其中 $\\lambda_t > 0$ 是每步的有限增长因子。长期每步对数增长率定义为\n$$\n\\gamma \\equiv \\lim_{T \\to \\infty} \\frac{1}{T} \\sum_{t=1}^T \\log \\lambda_t.\n$$\n假设环境由一个标准化驱动因子 $E_t$ 表示，其动态遵循一个平稳的一阶自回归（AR(1)）过程，由均值 $\\mu$、平稳标准差 $\\sigma$ 和滞后一阶自相关 $\\phi \\in (-1,1)$ 参数化：\n$$\nE_t = \\mu + \\phi (E_{t-1} - \\mu) + \\sigma \\sqrt{1-\\phi^2} \\, Z_t,\n$$\n其中 $Z_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态随机变量。在此参数化下，$E_t$ 的平稳方差为 $\\sigma^2$，协方差为 $\\operatorname{Cov}(E_t,E_{t-1}) = \\phi \\sigma^2$。\n\n假设环境对增长的影响遵循对数-线性-二次形式，并带有一个捕获种群统计不稳定性（demographic lability）和非线性平均的跨期交互作用。具体定义为\n$$\n\\log \\lambda_t \\equiv g_t = r_{\\mathrm{bar}} + s \\, E_t - k \\, E_t^2 - h \\, E_t E_{t-1},\n$$\n其中 $r_{\\mathrm{bar}}$ 是基线对数增长截距，$s$ 是即时环境敏感度（均值中的种群统计不稳定性），$k \\ge 0$ 量化了曲率（非线性平均；$k > 0$ 意味着凹性和 Jensen 不等式会因方差而降低平均增长），而 $h \\ge 0$ 量化了当前与先前环境之间的跨期交互作用（序列环境效应；当 $\\phi > 0$ 时，较大的 $h$ 会惩罚相似条件的序列）。\n\n您的任务是编写一个完整、可运行的程序，对于下面给出的参数集，通过对 $g_t$ 进行时间平均，模拟 AR(1) 环境并计算长期每步对数增长率 $\\gamma$ 的估计值。对所有测试用例使用相同的模拟长度和随机种子，以确保可复现性。\n\n模拟和输出要求：\n- 使用总时间步长 $T = 200{,}000$ 和 $B = 5{,}000$ 步的预烧期（burn-in），在估计 $\\gamma$ 之前达到平稳状态。\n- 在 $E_0 = \\mu$ 处初始化环境。\n- 对整个程序使用固定的随机种子 $2025$。\n- 将 $\\gamma$ 估计为预烧期后时间步长内 $g_t$ 的算术平均值（即，对从 $t=B+1$ 到 $t=B+T$ 的 $g_t$ 进行平均）。\n- 将每个估计的 $\\gamma$ 报告为精确到六位小数的浮点数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[x1,x2,...,x8]\"），其顺序与下面列出的测试用例完全一致。\n\n测试套件（每个测试用例为 $(\\mu,\\sigma,\\phi,s,k,h,r_{\\mathrm{bar}})$）：\n1. $(0.0, 0.5, 0.0, 0.4, 0.1, 0.0, 0.0)$\n2. $(0.0, 1.0, 0.0, 0.4, 0.1, 0.0, 0.0)$\n3. $(0.0, 0.5, 0.9, 0.4, 0.1, 0.2, 0.0)$\n4. $(0.0, 0.5, 0.0, 0.4, 0.1, 0.2, 0.0)$\n5. $(0.0, 0.0, 0.9, 0.4, 0.1, 0.2, 0.0)$\n6. $(0.5, 0.3, 0.7, 0.4, 0.1, 0.2, 0.0)$\n7. $(0.0, 1.2, 0.9, 0.4, 0.0, 0.0, 0.0)$\n8. $(0.0, 0.5, -0.9, 0.4, 0.1, 0.2, 0.0)$\n\n科学真实性约束和推理基础：\n- 使用乘法种群增长的定义 $N_{t+1} = N_t \\lambda_t$ 和当 $T \\to \\infty$ 时 $\\gamma$ 的遍历时间平均。\n- 使用经过充分检验的一阶自回归（AR(1)）过程的属性来描述环境变化。\n- 使用 Jensen 不等式来解释 $g_t$ 中的凹性（即 $k > 0$）如何随着 $\\sigma^2$ 的增加而降低长期均值。\n- 使用 $E_t$ 的协方差结构来解释当 $h > 0$ 时，正自相关 $\\phi$ 如何放大惩罚效应。\n\n不涉及角度、物理单位和百分比；因此，不需要单位转换。每个测试用例的最终答案均为按规定四舍五入到六位小数的浮点数。您的程序应生成包含所有八个结果的单行，并采用所需格式。", "solution": "该问题要求对受随机环境驱动因素影响的种群模型，数值估计其长期每步对数增长率 $\\gamma$。解决方案是通过直接模拟获得的，这依据了遍历性假说，该假说认为过程的长期时间平均值会收敛到其系综平均值。该方法论被实现为一个计算算法。\n\n问题的核心是模拟环境驱动因子 $E_t$，然后使用生成的时间序列来计算每步对数增长率 $g_t$。然后，$\\gamma$ 的估计值是在初始预烧期后足够长的一段时间内 $g_t$ 的算术平均值。\n\n模拟过程如下：\n\n1. **初始化**：模拟总共运行 $B+T$ 个时间步，其中 $T = 200,000$ 是用于平均的步数，$B = 5,000$ 是预烧期。使用固定的随机种子 $2025$ 来初始化伪随机数生成器，以确保可复现性。该生成器用于为 $t=1, \\dots, B+T$ 生成一个由 $B+T$ 个独立同分布的标准正态随机变量 $Z_t \\sim \\mathcal{N}(0,1)$ 组成的序列。\n\n2. **环境驱动因子模拟**：环境驱动因子 $E_t$ 由一个平稳的一阶自回归（AR(1)）过程控制。生成一个长度为 $B+T+1$（从 $t=0$ 到 $t=B+T$）的 $E_t$ 时间序列。该过程在其均值处初始化，即 $E_0 = \\mu$。后续值使用所提供的方程递归生成：\n$$\nE_t = \\mu + \\phi (E_{t-1} - \\mu) + \\sigma \\sqrt{1-\\phi^2} \\, Z_t \\quad \\text{for } t=1, 2, \\dots, B+T\n$$\n对测试套件中提供的每一组参数 $(\\mu, \\sigma, \\phi, s, k, h, r_{\\mathrm{bar}})$ 都执行此生成过程。\n\n3. **对数增长率计算**：生成环境时间序列 $E_t$ 后，计算预烧期后的每步对数增长率 $g_t$，即对于 $t = B+1, \\dots, B+T$。计算使用指定的对数-线性-二次函数：\n$$\ng_t = r_{\\mathrm{bar}} + s \\, E_t - k \\, E_t^2 - h \\, E_t E_{t-1}\n$$\n此步骤为 $g_t$ 生成一个包含 $T$ 个值的序列。\n\n4. **$\\gamma$ 的估计**：通过计算 $T$ 个预烧期后 $g_t$ 值的算术平均值来估计长期对数增长率 $\\gamma$。这个估计值，记为 $\\hat{\\gamma}$，由下式给出：\n$$\n\\hat{\\gamma} = \\frac{1}{T} \\sum_{t=B+1}^{B+T} g_t\n$$\n对于一个平稳过程，这个数值时间平均值可作为理论极限 $\\gamma = \\lim_{T \\to \\infty} \\frac{1}{T} \\sum_{t=1}^T \\log \\lambda_t$ 的近似，它等价于期望值 $\\mathbb{E}[g_t]$。\n\n5. **输出格式化**：对 8 个测试用例中的每一个重复此过程。将每个得到的估计值 $\\hat{\\gamma}$ 四舍五入到恰好六位小数。最终输出是包含这 8 个值的单行，用逗号分隔并用方括号括起来。\n\n整个计算过程是使用 Python 和 NumPy 库以编程方式实现的，以进行高效的数组操作，这符合问题要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates an AR(1) environmental driver and computes the long-run \n    log growth rate of a population for several parameter sets.\n    \"\"\"\n    # Define simulation parameters from the problem statement.\n    T_avg = 200000\n    B_burn = 5000\n    SEED = 2025\n    TOTAL_STEPS = B_burn + T_avg\n\n    # Test cases: each tuple is (mu, sigma, phi, s, k, h, r_bar).\n    test_cases = [\n        (0.0, 0.5, 0.0, 0.4, 0.1, 0.0, 0.0),\n        (0.0, 1.0, 0.0, 0.4, 0.1, 0.0, 0.0),\n        (0.0, 0.5, 0.9, 0.4, 0.1, 0.2, 0.0),\n        (0.0, 0.5, 0.0, 0.4, 0.1, 0.2, 0.0),\n        (0.0, 0.0, 0.9, 0.4, 0.1, 0.2, 0.0),\n        (0.5, 0.3, 0.7, 0.4, 0.1, 0.2, 0.0),\n        (0.0, 1.2, 0.9, 0.4, 0.0, 0.0, 0.0),\n        (0.0, 0.5, -0.9, 0.4, 0.1, 0.2, 0.0),\n    ]\n\n    results = []\n    \n    # Initialize the random number generator once for the entire program\n    # to ensure reproducibility and proper sequence of random numbers across tests.\n    rng = np.random.default_rng(SEED)\n\n    for case in test_cases:\n        mu, sigma, phi, s, k, h, r_bar = case\n\n        # Generate the sequence of standard normal random variables Z_t.\n        # We need TOTAL_STEPS random numbers to generate E_1 through E_{B+T}.\n        Z = rng.standard_normal(size=TOTAL_STEPS)\n\n        # Initialize the environmental driver time series array E.\n        # The array has size B+T+1 to store E_0 through E_{B+T}.\n        E = np.zeros(TOTAL_STEPS + 1)\n        E[0] = mu\n\n        # Precompute the constant part of the AR(1) stochastic term.\n        # Handle sigma=0 to ensure the term is zero.\n        if sigma == 0.0:\n            s_g_term = 0.0\n        else:\n            s_g_term = sigma * np.sqrt(1 - phi**2)\n\n        # Simulate the AR(1) process for E_t from t=1 to B+T.\n        for t in range(1, TOTAL_STEPS + 1):\n            E[t] = mu + phi * (E[t-1] - mu) + s_g_term * Z[t-1]\n\n        # Extract the post-burn-in time series for calculation.\n        # E_t for t from B+1 to B+T\n        E_current = E[B_burn + 1:]\n        # E_{t-1} for t from B+1 to B+T\n        E_previous = E[B_burn:-1]\n\n        # Calculate the log growth rate g_t for the post-burn-in period using vectorized operations.\n        g_values = r_bar + s * E_current - k * E_current**2 - h * E_current * E_previous\n\n        # Estimate gamma as the time average of g_t.\n        gamma_est = np.mean(g_values)\n\n        # Append the result, formatted to exactly six decimal places.\n        results.append(f\"{gamma_est:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2495642"}]}