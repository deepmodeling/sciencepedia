{"hands_on_practices": [{"introduction": "如何对传染病接触和传播过程进行数学建模，是构建任何SIR类型模型的第一步，也是最核心的决策之一。不同的建模假设会直接影响模型对疫情爆发阈值的预测。本练习将指导你从基本原理出发，推导两种经典的发生率函数形式——密度依赖和频率依赖，并分析这一选择如何改变疫情入侵的临界条件。通过这个实践，你将加深对模型构建基本原则和阈值现象的理解。[@problem_id:2480318]", "problem": "一个大小恒定为 $N$ 的均匀混合宿主种群采用易感-感染-康复 (SIR) 框架进行建模，其中 $S(t)$、$I(t)$ 和 $R(t)$ 分别表示在时间 $t$ 的易感者、感染者和康复者数量，并且对于所有 $t$ 都有 $S(t)+I(t)+R(t)=N$。个体以人均速率 $\\gamma>0$ 康复。假设在一个没有出生或死亡的短暂入侵阶段，因此 $N$ 是恒定的。\n\n考虑了两种关于感染力的替代表述，基于关于接触率如何随种群规模变化的广泛使用的假设：\n1. 密度依赖（质量作用）发生率：作用于易感者的人均感染力与感染宿主的密度成正比。\n2. 频率依赖发生率：作用于易感者的人均感染力与感染宿主的比例成正比。\n\n从这些基本原理和核心定义出发，完成以下任务：\n- 推导密度依赖情况下（传播参数为 $\\beta_{D}>0$）和频率依赖情况下（传播参数为 $\\beta_{F}>0$）的 SIR 微分方程。\n- 在初始入侵阶段（此时 $I(t)$ 很小且 $S(t)\\approx S_{0}$ 在此短暂时间内被视为准恒定），通过对无病状态进行线性化，推导每种情况下的入侵阈值，用临界易感人群数量 $S_{\\mathrm{crit}}$ 表示；即，使得 $I(t)$ 初始增加的 $S_{0}$ 的最小值。\n- 将频率依赖情况与密度依赖情况下的临界易感人群阈值之比 $S_{\\mathrm{crit}}^{F}/S_{\\mathrm{crit}}^{D}$，表示为包含 $N$、$\\beta_{D}$、$\\beta_{F}$ 和 $\\gamma$ 的闭式表达式。\n\n您的最终答案必须是关于 $S_{\\mathrm{crit}}^{F}/S_{\\mathrm{crit}}^{D}$ 的单个闭式解析表达式。不包含任何单位。不需要进行数值近似或四舍五入。", "solution": "该问题要求推导在一个 SIR 模型中，针对两种不同的感染力表述（密度依赖和频率依赖）的临界易感人群阈值之比。分析从基本原理出发。\n\n首先，我们为密度依赖（质量作用）情况构建微分方程组。问题陈述，作用于易感个体的人均感染力与感染宿主的密度成正比。在一个大小恒定为 $N$ 的均匀混合种群中，感染个体的密度可以认为与其数量 $I(t)$ 成正比。因此，人均感染力 $\\lambda_D(t)$ 由 $\\lambda_D(t) = \\beta_D I(t)$ 给出，其中 $\\beta_D > 0$ 是传播参数。总的新感染率是易感者数量 $S(t)$ 与人均感染力的乘积。感染个体以恒定的人均速率 $\\gamma > 0$ 康复。控制性的 SIR 方程为：\n$$\n\\frac{dS}{dt} = - \\beta_D S(t) I(t)\n$$\n$$\n\\frac{dI}{dt} = \\beta_D S(t) I(t) - \\gamma I(t)\n$$\n$$\n\\frac{dR}{dt} = \\gamma I(t)\n$$\n\n接下来，我们为频率依赖情况构建方程。在此情况下，人均感染力与种群中感染宿主的比例成正比，即 $\\frac{I(t)}{N}$。人均感染力 $\\lambda_F(t)$ 为 $\\lambda_F(t) = \\beta_F \\frac{I(t)}{N}$，其中 $\\beta_F > 0$ 是传播参数。相应的 SIR 方程为：\n$$\n\\frac{dS}{dt} = - \\beta_F \\frac{S(t) I(t)}{N}\n$$\n$$\n\\frac{dI}{dt} = \\beta_F \\frac{S(t) I(t)}{N} - \\gamma I(t)\n$$\n$$\n\\frac{dR}{dt} = \\gamma I(t)\n$$\n\n入侵阈值由感染人群初始增长的条件决定，即当疾病引入时 $\\frac{dI}{dt} > 0$。在这个早期阶段，感染个体数量 $I(t)$ 非常小，易感人群数量 $S(t)$ 可以近似为其初始值 $S(t) \\approx S_0$。\n\n对于密度依赖模型，感染人群的变化率为：\n$$\n\\frac{dI}{dt} = (\\beta_D S(t) - \\gamma) I(t)\n$$\n要发生入侵，需要满足 $\\frac{dI}{dt} > 0$。由于 $I(t) > 0$，此条件变为 $\\beta_D S(t) - \\gamma > 0$。在入侵时刻（$S(t) \\approx S_0$），条件是 $\\beta_D S_0 > \\gamma$，或 $S_0 > \\frac{\\gamma}{\\beta_D}$。临界易感人群数量 $S_{\\mathrm{crit}}^D$ 是使此不等式成立的 $S_0$ 的最小值。这对应于边界条件 $\\frac{dI}{dt} = 0$。\n$$\nS_{\\mathrm{crit}}^D = \\frac{\\gamma}{\\beta_D}\n$$\n\n对于频率依赖模型，感染人群的变化率为：\n$$\n\\frac{dI}{dt} = \\left(\\beta_F \\frac{S(t)}{N} - \\gamma\\right) I(t)\n$$\n入侵条件 $\\frac{dI}{dt} > 0$ 意味着 $\\beta_F \\frac{S(t)}{N} - \\gamma > 0$。在初始阶段（$S(t) \\approx S_0$），这变为 $\\beta_F \\frac{S_0}{N} > \\gamma$，或 $S_0 > \\frac{\\gamma N}{\\beta_F}$。因此，频率依赖情况下的临界易感人群数量 $S_{\\mathrm{crit}}^F$ 为：\n$$\nS_{\\mathrm{crit}}^F = \\frac{\\gamma N}{\\beta_F}\n$$\n\n最后，我们计算临界易感人群阈值之比 $\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D}$。代入推导出的表达式：\n$$\n\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D} = \\frac{\\left(\\frac{\\gamma N}{\\beta_F}\\right)}{\\left(\\frac{\\gamma}{\\beta_D}\\right)}\n$$\n化简复合分数可得：\n$$\n\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D} = \\frac{\\gamma N}{\\beta_F} \\cdot \\frac{\\beta_D}{\\gamma}\n$$\n恢复率参数 $\\gamma$ 从分子和分母中约去，得到该比率的最终闭式表达式：\n$$\n\\frac{S_{\\mathrm{crit}}^F}{S_{\\mathrm{crit}}^D} = \\frac{N \\beta_D}{\\beta_F}\n$$\n此表达式根据总人口大小 $N$ 以及每个模型中的传播参数 $\\beta_D$ 和 $\\beta_F$ 来关联这两个阈值。", "answer": "$$\\boxed{\\frac{N \\beta_D}{\\beta_F}}$$", "id": "2480318"}, {"introduction": "现实世界中的流行病传播往往具有高度异质性，即少数感染者（“超级传播者”）造成了大部分的续发病例。本练习将引导你从确定性模型的框架走向随机过程，使用分支过程理论来探讨这一现象。你将通过对比泊松分布（代表同质化传播）和负二项分布（代表异质性传播）下的疫情链，亲手计算并揭示个体传播异质性（即过度离散）如何显著改变新发病原体随机性灭绝的概率，这是评估新发传染病风险的关键概念。[@problem_id:2480322]", "problem": "一种新发的直接传播病原体被引入一个非常庞大的、其他个体均为易感的宿主群体中，因此早期传播不受易感者耗尽的限制。在这个早期入侵阶段，每个感染宿主产生的二代感染数量可以被建模为 Bienaymé–Galton–Watson 分支过程中的独立同分布后代。设基本再生数为 $\\mathcal{R}_0$，即在一个其他个体均为易感的群体中，单个感染个体产生的二代病例的期望数量。\n\n考虑两种关于个体二代病例异质性的机制性假设，两者都校准为具有相同的均值 $\\mathcal{R}_0$：\n- 同质传播：二代病例数服从均值为 $\\mathcal{R}_0$ 的泊松分布。\n- 过度离散传播：二代病例数服从负二项分布，其离散参数为 $k=1$（即在 $\\{0,1,2,\\dots\\}$ 上的几何分布），均值为 $\\mathcal{R}_0$，这代表了包括超级传播在内的强个体异质性。\n\n从 $t=0$ 时刻的单个感染个体开始，根据第一性原理推导在上述两种假设下，感染链最终消亡的精确灭绝概率。在入侵可能发生的 $\\mathcal{R}_0>1$ 的情形下进行计算。然后，通过计算精确的差值，量化过度离散相对于同质泊松情形如何改变早期灭绝风险：\n$$\n\\Delta q(\\mathcal{R}_0) \\equiv q_{\\mathrm{NB},\\,k=1}(\\mathcal{R}_0)-q_{\\mathrm{Pois}}(\\mathcal{R}_0)\n$$\n以一个关于 $\\mathcal{R}_0$ 的闭式解析表达式（如果需要，可包含标准特殊函数）来表示。将您关于 $\\Delta q(\\mathcal{R}_0)$ 的最终答案表示为一个精确的符号表达式，不进行数值近似且不带单位。", "solution": "该问题是有效的，因为它在科学上基于分支过程理论，这是数理流行病学的一个标准框架。问题是适定的、客观的，并且所有提供的信息都是自洽且一致的。\n\n解决这个问题的基础在于 Bienaymé–Galton–Watson (BGW) 分支过程理论。对于一个从单个个体开始的 BGW 过程，其中每个个体的后代数量是从一个具有概率生成函数 (PGF) $G(s)$ 的分布中抽取的独立同分布随机变量，其最终灭绝概率（记为 $q$）是方程 $s = G(s)$ 的最小非负根。PGF 定义为 $G(s) = \\sum_{j=0}^{\\infty} p_j s^j$，其中 $p_j$ 是一个个体产生 $j$ 个后代的概率。该分布的均值是基本再生数 $\\mathcal{R}_0 = G'(1)$。对于指定的 $\\mathcal{R}_0 > 1$ 的情形，方程 $s=G(s)$ 在区间 $[0, 1]$ 内有两个根：平凡根 $s=1$ 和一个较小的根 $q \\in [0, 1)$，后者对应于灭绝概率。\n\n首先，我们分析同质传播情形，其中二代病例数服从均值为 $\\mathcal{R}_0$ 的泊松分布。\n概率质量函数 (PMF) 为 $p_j = \\frac{\\exp(-\\mathcal{R}_0) \\mathcal{R}_0^j}{j!}$，其中 $j \\in \\{0, 1, 2, \\dots\\}$。\nPGF, $G_{\\mathrm{Pois}}(s)$，计算如下：\n$$\nG_{\\mathrm{Pois}}(s) = \\sum_{j=0}^{\\infty} p_j s^j = \\sum_{j=0}^{\\infty} \\frac{\\exp(-\\mathcal{R}_0) \\mathcal{R}_0^j}{j!} s^j = \\exp(-\\mathcal{R}_0) \\sum_{j=0}^{\\infty} \\frac{(\\mathcal{R}_0 s)^j}{j!}\n$$\n将此级数识别为指数函数的泰勒展开，我们得到：\n$$\nG_{\\mathrm{Pois}}(s) = \\exp(-\\mathcal{R}_0) \\exp(\\mathcal{R}_0 s) = \\exp(\\mathcal{R}_0(s-1))\n$$\n灭绝概率 $q_{\\mathrm{Pois}}$ 是方程 $s = G_{\\mathrm{Pois}}(s)$ 的最小非负根：\n$$\ns = \\exp(\\mathcal{R}_0(s-1))\n$$\n这是一个超越方程。为了求解 $s$，我们将其重排为一个适合使用 Lambert W 函数的形式，该函数由关系式 $z = W(z \\exp(z))$ 定义。\n$$\ns = \\exp(\\mathcal{R}_0 s) \\exp(-\\mathcal{R}_0)\n$$\n$$\ns \\exp(-\\mathcal{R}_0 s) = \\exp(-\\mathcal{R}_0)\n$$\n两边同乘以 $-\\mathcal{R}_0$：\n$$\n(-\\mathcal{R}_0 s) \\exp(-\\mathcal{R}_0 s) = -\\mathcal{R}_0 \\exp(-\\mathcal{R}_0)\n$$\n令 $z = -\\mathcal{R}_0 s$。方程变为 $z \\exp(z) = -\\mathcal{R}_0 \\exp(-\\mathcal{R}_0)$。$z$ 的解由 Lambert W 函数给出，$z = W(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0))$。\n对于 $\\mathcal{R}_0 > 1$，自变量 $-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0)$ 位于区间 $(-e^{-1}, 0)$ 内，此时 Lambert W 函数有两个实数分支，$W_0$（主分支）和 $W_{-1}$（下分支）。$s$ 的通解为 $s = -\\frac{1}{\\mathcal{R}_0} W(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0))$。\n平凡根 $s=1$ 对应于 $W_{-1}$ 分支，因为 $W_{-1}(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0)) = -\\mathcal{R}_0$，得出 $s = -\\frac{1}{\\mathcal{R}_0}(-\\mathcal{R}_0) = 1$。灭绝概率是最小的非负根，对应于主分支 $W_0$。\n因此，同质情形下的灭绝概率为：\n$$\nq_{\\mathrm{Pois}}(\\mathcal{R}_0) = -\\frac{1}{\\mathcal{R}_0} W_0(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0))\n$$\n\n接下来，我们分析过度离散传播情形。二代病例数服从均值为 $\\mathcal{R}_0$、离散参数为 $k=1$ 的负二项分布。这是一个在 $\\{0, 1, 2, \\dots\\}$ 上的几何分布。\n设其 PMF 为 $p_j = p(1-p)^j$。均值为 $\\mathcal{R}_0 = (1-p)/p$，这意味着 $p = \\frac{1}{1+\\mathcal{R}_0}$。\n因此，PMF 为 $p_j = \\frac{1}{1+\\mathcal{R}_0} \\left( \\frac{\\mathcal{R}_0}{1+\\mathcal{R}_0} \\right)^j$，其中 $j \\in \\{0, 1, 2, \\dots\\}$。\nPGF, $G_{\\mathrm{NB}}(s)$，是一个几何级数的和：\n$$\nG_{\\mathrm{NB}}(s) = \\sum_{j=0}^{\\infty} \\frac{1}{1+\\mathcal{R}_0} \\left( \\frac{\\mathcal{R}_0 s}{1+\\mathcal{R}_0} \\right)^j = \\frac{\\frac{1}{1+\\mathcal{R}_0}}{1 - \\frac{\\mathcal{R}_0 s}{1+\\mathcal{R}_0}} = \\frac{1}{1+\\mathcal{R}_0 - \\mathcal{R}_0 s}\n$$\n灭绝概率 $q_{\\mathrm{NB},\\,k=1}$ 是方程 $s = G_{\\mathrm{NB}}(s)$ 的最小非负根：\n$$\ns = \\frac{1}{1+\\mathcal{R}_0 - \\mathcal{R}_0 s}\n$$\n这产生了一个关于 $s$ 的二次方程：\n$$\ns(1+\\mathcal{R}_0 - \\mathcal{R}_0 s) = 1 \\implies s + \\mathcal{R}_0 s - \\mathcal{R}_0 s^2 = 1 \\implies \\mathcal{R}_0 s^2 - (1+\\mathcal{R}_0)s + 1 = 0\n$$\n使用二次方程求根公式，根为：\n$$\ns = \\frac{(1+\\mathcal{R}_0) \\pm \\sqrt{(1+\\mathcal{R}_0)^2 - 4 \\mathcal{R}_0}}{2 \\mathcal{R}_0} = \\frac{(1+\\mathcal{R}_0) \\pm \\sqrt{1+2\\mathcal{R}_0+\\mathcal{R}_0^2 - 4\\mathcal{R}_0}}{2 \\mathcal{R}_0} = \\frac{(1+\\mathcal{R}_0) \\pm \\sqrt{(\\mathcal{R}_0-1)^2}}{2 \\mathcal{R}_0}\n$$\n因为 $\\mathcal{R}_0 > 1$，所以 $\\sqrt{(\\mathcal{R}_0-1)^2} = \\mathcal{R}_0-1$。两个根是：\n$$\ns_1 = \\frac{1+\\mathcal{R}_0 + (\\mathcal{R}_0-1)}{2 \\mathcal{R}_0} = \\frac{2 \\mathcal{R}_0}{2 \\mathcal{R}_0} = 1\n$$\n$$\ns_2 = \\frac{1+\\mathcal{R}_0 - (\\mathcal{R}_0-1)}{2 \\mathcal{R}_0} = \\frac{2}{2 \\mathcal{R}_0} = \\frac{1}{\\mathcal{R}_0}\n$$\n灭绝概率是较小的根 $s_2$。因此：\n$$\nq_{\\mathrm{NB},\\,k=1}(\\mathcal{R}_0) = \\frac{1}{\\mathcal{R}_0}\n$$\n\n最后，我们计算差值 $\\Delta q(\\mathcal{R}_0) = q_{\\mathrm{NB},\\,k=1}(\\mathcal{R}_0) - q_{\\mathrm{Pois}}(\\mathcal{R}_0)$：\n$$\n\\Delta q(\\mathcal{R}_0) = \\frac{1}{\\mathcal{R}_0} - \\left( -\\frac{1}{\\mathcal{R}_0} W_0(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0)) \\right)\n$$\n$$\n\\Delta q(\\mathcal{R}_0) = \\frac{1}{\\mathcal{R}_0} + \\frac{1}{\\mathcal{R}_0} W_0(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0)) = \\frac{1 + W_0(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0))}{\\mathcal{R}_0}\n$$\n这个表达式量化了由过度离散导致的灭绝风险的增加。对于 $\\mathcal{R}_0 > 1$，我们有 $-1  W_0(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0))  0$，这确保了 $\\Delta q(\\mathcal{R}_0)$ 为正，证实了传播中的强个体异质性会增加新发病原体随机灭绝的概率。", "answer": "$$\n\\boxed{\\frac{1 + W_0(-\\mathcal{R}_0 \\exp(-\\mathcal{R}_0))}{\\mathcal{R}_0}}\n$$", "id": "2480322"}, {"introduction": "在公共卫生实践中，一项核心任务是实时监测疫情的传播态势，其关键指标是随时间变化的再生数 $R_t$。本练习提供了一个连接理论与实践的编程挑战：从基本原理出发，推导并实现经典的 Wallinga-Teunis 方法，利用发病率时间序列数据来估算 $R_t$。这项实践不仅能让你掌握一种重要的数据分析技术，更能让你体会到诸如代际间隔分布等模型假设在解释流行病学数据时的关键作用。[@problem_id:2480397]", "problem": "您的任务是，在疾病生态学的易感-感染-移除 (Susceptible–Infectious–Removed, SIR) 类型模型的背景下，从发病数时间序列推导并实现用于估计时变病例再生数的 Wallinga–Teunis (WT) 估计量。您的推导必须从代际间隔分布的定义和传播的更新过程描述出发，不得假设任何已有的 WT 公式。然后，您必须将您的推导转化为一个可运行的程序，该程序能根据每日发病数和离散的代际间隔概率质量函数计算 WT 病例再生数序列，并用它来评估当定代际间隔分布被错误指定时的敏感性。\n\n您可以使用的科学出发点是以下基本定义和事实：\n- 离散时间代际间隔分布是一个在延迟 $s \\in \\{1,2,\\dots,L\\}$ 上的概率质量函数 $w_s$，满足 $\\sum_{s=1}^{L} w_s = 1$，其中 $w_s$ 是在传染源感染时间 $s$ 天后发生二代感染的概率。\n- 期望发病数的更新过程表示法陈述道，对于每日发病数序列 $I_t$ 和时变病例再生数 $R_t$，在时间 $t$ 的期望发病数满足 $\\mathbb{E}[I_t] = \\sum_{s=1}^{L} R_{t-s} I_{t-s} w_s$。\n\n根据这些原则，推导一个在每一天 $t$ 的 WT 病例再生数表达式，该表达式仅依赖于观测到的发病数 $I_t$ 和代际间隔分布 $w_s$。您的推导必须考虑到，在第 $u$ 天的感染可以按概率归因于早期日期的潜在传染源，其比例与其发病数和代际间隔概率成正比。请仔细处理由有限观测窗口造成的边界条件。\n\n实现要求：\n- 给定一个发病数时间序列 $(I_0,\\dots,I_{T-1})$ 和一个支撑集在延迟 $1$ 到 $L$ 上的代际间隔概率质量函数 $(w_1,\\dots,w_L)$，计算每个有良好定义的日期 $t$ 的 WT 病例再生数 $R_t$。如果 $I_t = 0$，则将当天的 $R_t$ 视为未定义，并将其从任何平均计算中排除。如果对于某个受感染日 $u$，汇总了所有潜在传染源贡献的所需分母为零，则将该天 $u$ 从定义 $R_t$ 的求和中排除。\n- 为减少右删失偏差，在计算汇总统计量（对 $t$ 取平均值）时，仅包括满足 $t \\le T-1-L$ 的时间 $t$。\n\n敏感性分析要求：\n- 对于下方的每个测试用例，使用真实的代际间隔分布 $w^{\\mathrm{true}}$ 和错误指定的分布 $w^{\\mathrm{mis}}$ 计算平均 WT 再生数。报告这两个平均值以及它们的差值（错误指定值减去真实值）。\n\n测试套件：\n- 测试用例 A（增长中的流行病，由更新过程生成的发病数）：\n  - 时间范围 $T = 25$，初始发病数 $I_0 = 10$，恒定的真实再生数 $R^{\\mathrm{true}} = 1.3$。\n  - 真实的代际间隔分布，支撑集 $L = 5$：$w^{\\mathrm{true}} = (w_1,\\dots,w_5) = (0.3, 0.4, 0.2, 0.07, 0.03)$。\n  - 错误指定的代际间隔分布：$w^{\\mathrm{mis}} = (0.5, 0.3, 0.15, 0.04, 0.01)$。\n  - 根据更新期望确定性地生成发病数：对于 $t \\in \\{1,\\dots,T-1\\}$，设置 $I_t = R^{\\mathrm{true}} \\sum_{s=1}^{\\min(L,t)} I_{t-s} w_s$。\n- 测试用例 B（衰退中的流行病，由更新过程生成的发病数）：\n  - 时间范围 $T = 30$，初始发病数 $I_0 = 50$，恒定的真实再生数 $R^{\\mathrm{true}} = 0.8$。\n  - 真实的代际间隔分布，支撑集 $L = 5$：$w^{\\mathrm{true}} = (0.3, 0.4, 0.2, 0.07, 0.03)$。\n  - 错误指定的代际间隔分布：$w^{\\mathrm{mis}} = (0.1, 0.2, 0.3, 0.25, 0.15)$。\n  - 如同测试用例 A，根据更新期望确定性地生成发病数。\n- 测试用例 C（包含零发病数和非更新序列的边缘用例）：\n  - 时间范围 $T = 12$，发病数直接指定为 $I = (0, 5, 0, 10, 0, 8, 4, 0, 1, 0, 0, 3)$。\n  - 真实的代际间隔分布，支撑集 $L = 3$：$w^{\\mathrm{true}} = (0.6, 0.3, 0.1)$。\n  - 错误指定的代际间隔分布：$w^{\\mathrm{mis}} = (0.05, 0.15, 0.8)$。\n\n输出规范：\n- 对于每个测试用例，计算三个浮点数：\n  1. 在满足 $I_t > 0$ 和 $t \\le T-1-L$ 的天数 $t$ 上，使用 $w^{\\mathrm{true}}$ 计算的平均 WT 再生数。\n  2. 在相同的 $t$ 集合上，使用 $w^{\\mathrm{mis}}$ 计算的平均 WT 再生数。\n  3. 这两个平均值之间的差值（错误指定值减去真实值）。\n- 您的程序应生成单行输出，其中包含按 A、B、C 顺序连接的三个测试用例的结果，形式为用方括号括起来的逗号分隔列表，总共九个数字。例如，输出格式必须严格为 $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9]$ 的形式，其中每个 $x_i$ 是一个浮点数。在打印前将每个浮点数四舍五入到 $6$ 位小数。不使用角度，也无需报告物理单位。\n\n您的程序必须是一个完整的、可运行的程序，不接受任何输入，并且只打印所要求的单行输出。", "solution": "所陈述的问题具有科学依据、是适定且客观的。所有定义、数据和约束都已提供且相互一致。这是计算流行病学中的一个有效问题。\n\n任务是推导并实现用于时变病例再生数 $R_t$ 的 Wallinga-Teunis (WT) 估计量。$R_t$ 表示在时间 $t$ 被感染的单个个体所产生的平均二代感染数。推导过程从将新感染归因于过去传染源的原理出发。\n\n令 $I_t$ 为离散时间 $t$ 的新感染数（发病数）。令 $w_s$ 为代际间隔的概率质量函数，表示一代病例与二代病例之间感染时间间隔为 $s$ 天的概率，对于 $s \\in \\{1, 2, \\dots, L\\}$。我们有 $\\sum_{s=1}^{L} w_s = 1$。\n\n考虑在时间 $t$ 感染的 $I_t$ 个个体组成的队列。我们希望找到他们产生的二代感染总数，该总数除以 $I_t$ 便得到 $R_t$。这些二代感染发生在未来的时间 $u > t$。\n\nWT 方法估计了时间 $t$ 的队列对未来时间 $u=t+s$ 发病数的贡献。在时间 $u$ 产生 $I_u$ 个病例的总“传染压力”或传播潜能 $\\Lambda_u$，是所有可能的先前传染源队列贡献的总和。一个规模为 $I_k$ 的队列的贡献与其规模以及相关代际间隔的概率 $w_{u-k}$ 成正比。因此，导致在第 $u$ 天发生感染的总传染压力是：\n$$\n\\Lambda_u = \\sum_{j=1}^{L} I_{u-j} w_j\n$$\n此和是针对所有可能的代际间隔 $j \\in \\{1, \\dots, L\\}$。索引 $u-j$ 必须为非负，因为负时间的发生率为零；在有限的观测窗口 $(I_0, \\dots, I_{T-1})$ 内，任何 $k  0$ 的 $I_k$ 都默认为零。\n\n在时间 $u$ 的感染中，可归因于时间 $t  u$ 受感染队列的比例，是来自队列 $t$ 的传染压力与时间 $u$ 的总传染压力之比。这个比例是：\n$$\np_{t \\to u} = \\frac{I_t w_{u-t}}{\\Lambda_u} = \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n在时间 $u$ 由时间 $t$ 的队列所引起的估计感染数，记为 $\\hat{C}_{t,u}$，是此比例乘以时间 $u$ 的总发病数：\n$$\n\\hat{C}_{t,u} = I_u \\cdot p_{t \\to u} = I_u \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n由 $I_t$ 个体组成的整个队列产生的二代病例总数，是在所有可能的未来感染时间 $u = t+1$, $\\dots$, $u=t+L$ 上对这些贡献求和，其中 $s \\in \\{1, \\dots, L\\}$。\n$$\n\\text{来自队列 t 的总二代感染数} = \\sum_{u=t+1}^{t+L} \\hat{C}_{t,u} = \\sum_{u=t+1}^{t+L} I_u \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n病例再生数 $R_t$ 是规模为 $I_t$ 的队列中每个个体的平均二代感染数。假设 $I_t > 0$，我们将总数除以 $I_t$：\n$$\nR_t = \\frac{1}{I_t} \\sum_{u=t+1}^{t+L} I_u \\frac{I_t w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j} = \\sum_{u=t+1}^{t+L} \\frac{I_u w_{u-t}}{\\sum_{j=1}^{L} I_{u-j} w_j}\n$$\n通过用代际间隔 $s = u-t$ 替换求和索引，表达式变为：\n$$\nR_t = \\sum_{s=1}^{L} \\frac{I_{t+s} w_s}{\\sum_{j=1}^{L} I_{t+s-j} w_j}\n$$\n这就是推导出的用于队列再生数的 WT 估计量。如果 $I_t=0$，$R_t$ 未定义。如果对于某个特定的 $s$，分母 $\\Lambda_{t+s} = \\sum_{j=1}^{L} I_{t+s-j} w_j$ 为零，则该项对 $R_t$ 的求和贡献为零。\n\n实现由两个主要函数组成。首先，一个为测试用例 A 和 B 生成发病数时间序列的函数。给定初始发病数 $I_0$、时间范围 $T$、真实的代际间隔分布 $w^{\\mathrm{true}}$ 和真实的恒定再生数 $R^{\\mathrm{true}}$，对于 $t \\in \\{1,\\dots,T-1\\}$ 的发病数 $I_t$ 通过所提供的更新方程确定性地生成：\n$$\nI_t = R^{\\mathrm{true}} \\sum_{s=1}^{\\min(L,t)} I_{t-s} w^{\\mathrm{true}}_s\n$$\n项 $\\min(L,t)$ 正确处理了流行病初期的边界条件。\n\n其次，一个从发病数序列 $I = (I_0, \\dots, I_{T-1})$ 和代际间隔分布 $w = (w_1, \\dots, w_L)$ 计算平均 WT 再生数的函数。该函数实现了推导出的 $R_t$ 公式。它遍历有效范围 $0 \\le t \\le T-1-L$ 内的每个时间 $t$。对 $t$ 的这个上限要求是为了避免右删失偏差，因为计算 $R_t$ 需要截至时间 $t+L$ 的发病数据。对于每个有效的 $t$，如果 $I_t > 0$，函数通过对 $s \\in \\{1, \\dots, L\\}$ 的项求和来计算 $R_t$。对于每一项，它首先计算分母 $\\Lambda_{t+s}$。如果此分母为正，则将项 $\\frac{I_{t+s} w_s}{\\Lambda_{t+s}}$ 加到 $R_t$ 的和中。最后，函数返回所有计算出的 $R_t$ 值的算术平均值。\n\n敏感性分析比较了用真实代际间隔计算的平均 $R_t$（即 $\\bar{R}_{\\mathrm{true}}$）与用错误指定的分布计算的平均 $R_t$（即 $\\bar{R}_{\\mathrm{mis}}$）。它们的差值 $\\bar{R}_{\\mathrm{mis}} - \\bar{R}_{\\mathrm{true}}$ 量化了由于模型设定错误而引起的估计偏差。在增长的流行病（$R > 1$）中，一个比真实分布更偏重于早期（平均代际时间更短）的错误指定代际间隔分布通常会导致对 $R_t$ 的低估。相反，在衰退的流行病（$R  1$）中，一个更偏重于晚期（平均代际时间更长）的错误指定分布也倾向于导致对 $R_t$ 的低估。这些效应的产生是因为估计量的结构对发病数的相对时间分布很敏感，而这种分布是由代际间隔塑造的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef generate_incidence(I0, T, L, w_true, R_true):\n    \"\"\"\n    Generates a deterministic incidence series based on the renewal equation.\n    \"\"\"\n    I = np.zeros(T, dtype=float)\n    I[0] = float(I0)\n    w = np.array(w_true, dtype=float)\n    for t in range(1, T):\n        # The sum is over s from 1 to min(L, t), as specified.\n        # This handles the boundary condition for early times.\n        limit_s = min(L, t)\n        weighted_sum = 0.0\n        for s in range(1, limit_s + 1):\n            weighted_sum += I[t-s] * w[s-1]\n        I[t] = R_true * weighted_sum\n    return I\n\ndef compute_avg_R(I, w):\n    \"\"\"\n    Computes the average Wallinga-Teunis reproduction number.\n    \"\"\"\n    T = len(I)\n    w = np.array(w, dtype=float)\n    L = len(w)\n    \n    R_values = []\n    # Averaging window for t to avoid right-censoring bias\n    t_max = T - 1 - L\n    \n    for t in range(t_max + 1):\n        # R_t is defined for cohorts with I_t  0\n        if I[t] = 0:\n            continue\n            \n        Rt = 0.0\n        # Sum over s from 1 to L to get contributions from future infections\n        for s in range(1, L + 1):\n            u = t + s # Time of secondary infection\n            \n            # The index u is at most (T-1-L)+L = T-1, which is a valid index for I.\n            \n            # Calculate the denominator (total infectious pressure at time u)\n            lambda_u = 0.0\n            # Sum over j from 1 to L for possible generation intervals\n            for j in range(1, L + 1):\n                idx = u - j\n                if idx >= 0:\n                    lambda_u += I[idx] * w[j-1]\n\n            # Add term to Rt if the denominator is non-zero\n            if lambda_u > 0:\n                numerator = I[u] * w[s-1]\n                term = numerator / lambda_u\n                Rt += term\n        \n        R_values.append(Rt)\n        \n    # Return the mean of valid R_t values.\n    # An empty list should not occur for the given test cases.\n    if not R_values:\n        return 0.0 \n    \n    return np.mean(R_values)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    all_results = []\n    \n    # Test case A\n    T_A = 25\n    I0_A = 10.0\n    R_true_A = 1.3\n    w_true_A = [0.3, 0.4, 0.2, 0.07, 0.03]\n    L_A = len(w_true_A)\n    w_mis_A = [0.5, 0.3, 0.15, 0.04, 0.01]\n    \n    I_A = generate_incidence(I0_A, T_A, L_A, w_true_A, R_true_A)\n    \n    avg_R_true_A = compute_avg_R(I_A, w_true_A)\n    avg_R_mis_A = compute_avg_R(I_A, w_mis_A)\n    diff_A = avg_R_mis_A - avg_R_true_A\n    all_results.extend([avg_R_true_A, avg_R_mis_A, diff_A])\n    \n    # Test case B\n    T_B = 30\n    I0_B = 50.0\n    R_true_B = 0.8\n    w_true_B = [0.3, 0.4, 0.2, 0.07, 0.03]\n    L_B = len(w_true_B)\n    w_mis_B = [0.1, 0.2, 0.3, 0.25, 0.15]\n    \n    I_B = generate_incidence(I0_B, T_B, L_B, w_true_B, R_true_B)\n    \n    avg_R_true_B = compute_avg_R(I_B, w_true_B)\n    avg_R_mis_B = compute_avg_R(I_B, w_mis_B)\n    diff_B = avg_R_mis_B - avg_R_true_B\n    all_results.extend([avg_R_true_B, avg_R_mis_B, diff_B])\n    \n    # Test case C\n    I_C = np.array([0, 5, 0, 10, 0, 8, 4, 0, 1, 0, 0, 3], dtype=float)\n    w_true_C = [0.6, 0.3, 0.1]\n    w_mis_C = [0.05, 0.15, 0.8]\n\n    avg_R_true_C = compute_avg_R(I_C, w_true_C)\n    avg_R_mis_C = compute_avg_R(I_C, w_mis_C)\n    diff_C = avg_R_mis_C - avg_R_true_C\n    all_results.extend([avg_R_true_C, avg_R_mis_C, diff_C])\n    \n    # Format and print the final output as a single line.\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "2480397"}]}