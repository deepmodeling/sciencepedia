{"hands_on_practices": [{"introduction": "准确量化波动的环境声级是声景生态学中的一项基本任务。本练习将指导您计算等效连续声级（$L_{eq,T}$），这是一个基于声能的度量标准，并将其与直接对瞬时分贝值进行算术平均的错误方法进行对比。通过从第一性原理实现这一过程，您将更深刻地理解为何基于能量的正确平均方法对于稳健的声学分析至关重要。[@problem_id:2533871]", "problem": "一个随时间变化的声压时间序列，记为 $p(t)$（单位：帕斯卡），在有限持续时间 $T$（单位：秒）内以均匀采样率 $f_s$（单位：赫兹）进行观测。在空气中，平面行波的声强与声压的平方成正比，相对于参考声压 $p_0$ 的声压级（SPL），单位为分贝，在每个瞬间由 $L(t)=10\\log_{10}\\!\\left(\\frac{p^2(t)}{p_0^2}\\right)$ 定义，其中参考声压为 $p_0=2\\times 10^{-5}$ 帕斯卡。在持续时间 $T$ 内的等效连续声级定义为：在此区间 $[0,T]$ 内，一个恒定声级若能产生与所测信号相同的总声能，则该声级即为等效连续声级。\n\n您的任务是设计并实现一个程序，针对下面指定的每个测试用例，从第一性原理出发完成以下操作：\n\n- 仅使用上述基本定义，推导并计算整个持续时间内的等效连续声级，记为 $L_{\\mathrm{eq},T}$，其值为在 $[0,T]$ 上声压平方的时间平均值所对应的分贝级。\n- 计算瞬时分贝值的算术平均值，记为 $\\overline{L}$，定义为在所有离散样本上 $L(t)$ 的简单算术平均。为避免当 $p(t)=0$ 时出现未定义的对数，在取对数时使用一个严格为正的噪声基底 $p_{\\min}$，即在求平均前计算 $L(t)=10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t),p_{\\min}^2\\}}{p_0^2}\\right)$。在计算 $L_{\\mathrm{eq},T}$ 时，不对 $p(t)$ 应用任何基底值。\n- 对于每个测试用例，报告一个由三个浮点数组成的元组 $[L_{\\mathrm{eq},T},\\ \\overline{L},\\ L_{\\mathrm{eq},T}-\\overline{L}]$，其中所有三个量都以相对于 $p_0$ 的分贝为单位。最终的数值输出表示为无单位的普通十进制浮点数。将每个浮点数四舍五入到 $6$ 位小数。\n\n所有计算必须在提供的合成信号上纯数值地进行，并且必须使用帕斯卡作为压力单位，秒作为时间单位。三角函数内部的角度运算应使用弧度。每个测试所需的采样率 $f_s$ 和持续时间 $T$ 均已指定。\n\n在所有测试中使用以下常量和参数选择：\n- 参考声压：$p_0=2\\times 10^{-5}$ 帕斯卡。\n- 瞬时声级噪声基底：$p_{\\min}=1\\times 10^{-12}$ 帕斯卡。\n\n对于每个测试用例，按如下方式生成时间序列 $p(t)$。对于所有情况，在半开区间 $[0,T)$ 上构建一个包含 $N$ 个样本的离散时间向量，其均匀采样间隔为 $\\Delta t=\\frac{1}{f_s}$，使用 $t_n=n\\,\\Delta t$，$n\\in\\{0,1,\\dots,N-1\\}$，其中 $N=\\lfloor T\\,f_s\\rfloor$。\n\n测试组：\n- 情况 A（平稳高斯噪声）：\n  - 采样率：$f_s=44100$ 赫兹。\n  - 持续时间：$T=10$ 秒。\n  - 生成零均值高斯噪声，目标均方根（RMS）声压为 $\\sigma_p=0.02$ 帕斯卡，即在每个样本点上独立同分布的 $p(t)\\sim \\mathcal{N}(0,\\sigma_p^2)$。为保证可复现性，使用固定的随机种子 $s=12345$。\n- 情况 B（纯音）：\n  - 采样率：$f_s=48000$ 赫兹。\n  - 持续时间：$T=2.5$ 秒。\n  - 正弦波振幅：$A=0.1$ 帕斯卡。\n  - 频率：$f=1000$ 赫兹。\n  - 定义 $p(t)=A\\sin(2\\pi f t)$。\n- 情况 C（幅度门控音，50% 占空比）：\n  - 采样率：$f_s=32000$ 赫兹。\n  - 持续时间：$T=8$ 秒。\n  - 正弦波振幅：$A=0.02$ 帕斯卡。\n  - 频率：$f=500$ 赫兹。\n  - 方波门周期：$P=1$ 秒，占空比为 50%。定义包络 $g(t)=1$ 如果 $(t \\bmod P)  0.5 \\cdot P$，否则 $g(t)=0$，并且 $p(t)=g(t)\\,A\\sin(2\\pi f t)$。\n- 情况 D（稀疏脉冲串，约 1% 占空比）：\n  - 采样率：$f_s=44100$ 赫兹。\n  - 持续时间：$T=5$ 秒。\n  - 正弦波振幅：$A=2\\times 10^{-4}$ 帕斯卡。\n  - 频率：$f=1000$ 赫兹。\n  - 方波门周期：$P=0.5$ 秒，开启持续时间为 $\\tau_{\\mathrm{on}}=0.005$ 秒。定义包络 $g(t)=1$ 如果 $(t \\bmod P)  \\tau_{\\mathrm{on}}$，否则 $g(t)=0$，并且 $p(t)=g(t)\\,A\\sin(2\\pi f t)$。\n\n算法要求：\n- 对于 $L_{\\mathrm{eq},T}$，使用离散时间样本平方的均值，即 $\\frac{1}{N}\\sum_{n=0}^{N-1}p^2(t_n)$，来数值近似 $[0,T)$ 上 $p^2(t)$ 的时间平均值，然后将其转换为相对于 $p_0$ 的分贝值。\n- 对于 $\\overline{L}$，为每个样本计算 $L(t_n)=10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t_n),p_{\\min}^2\\}}{p_0^2}\\right)$，然后对所有 $n$ 取算术平均值。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的、以逗号分隔的列表的列表，每个内部列表是对应情况的三个浮点数，顺序为 $[L_{\\mathrm{eq},T},\\ \\overline{L},\\ L_{\\mathrm{eq},T}-\\overline{L}]$。例如，打印的结构应类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$，其中每个 $x_i,y_i,z_i$ 均按要求四舍五入到 $6$ 位小数。", "solution": "解决方案从基本定义和对数的标准属性出发。在线性声学中，对于空气中的平面行波，瞬时声强 $I(t)$ 与声压 $p(t)$ 的平方成正比，即 $I(t)=\\frac{p^2(t)}{\\rho c}$，其中 $\\rho$ 是空气密度，$c$ 是声速。相对于参考声强 $I_0$ 的声压级（SPL）定义为 $L(t)=10\\log_{10}\\!\\left(\\frac{I(t)}{I_0}\\right)$。选择常规的参考声压 $p_0=2\\times 10^{-5}$ 帕斯卡和 $I_0=\\frac{p_0^2}{\\rho c}$，即可得到标准的声压级表达式\n$$\nL(t)=10\\log_{10}\\!\\left(\\frac{p^2(t)}{p_0^2}\\right).\n$$\n在时间区间 $[0,T]$ 内的等效连续声级定义为一个假设的恒定声压信号的声级 $L_{\\mathrm{eq},T}$，该信号在 $[0,T]$ 内产生的时均声能（等效于均方声压）与观测到的 $p(t)$ 相同。将均方声压记为\n$$\n\\overline{p^2}=\\frac{1}{T}\\int_0^T p^2(t)\\,dt.\n$$\n根据定义，$L_{\\mathrm{eq},T}$ 是与 $\\overline{p^2}$ 对应的声压级，即\n$$\nL_{\\mathrm{eq},T}=10\\log_{10}\\!\\left(\\frac{\\overline{p^2}}{p_0^2}\\right).\n$$\n对于以采样间隔 $\\Delta t=\\frac{1}{f_s}$ 均匀采样的数据，在时间点 $t_n=n\\Delta t$（$n\\in\\{0,1,\\dots,N-1\\}$）上有 $N=\\lfloor T f_s\\rfloor$ 个样本，黎曼和近似给出\n$$\n\\overline{p^2}\\approx \\frac{1}{N}\\sum_{n=0}^{N-1}p^2(t_n).\n$$\n因此，在计算上可以使用\n$$\nL_{\\mathrm{eq},T}\\approx 10\\log_{10}\\!\\left(\\frac{\\frac{1}{N}\\sum_{n=0}^{N-1}p^2(t_n)}{p_0^2}\\right).\n$$\n相比之下，瞬时分贝值的算术平均值在此定义为\n$$\n\\overline{L}=\\frac{1}{N}\\sum_{n=0}^{N-1}10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t_n),p_{\\min}^2\\}}{p_0^2}\\right),\n$$\n其中 $p_{\\min}0$ 是一个指定的噪声基底声压，用以避免当 $p(t_n)=0$ 时出现未定义的对数。重要的是，在计算 $L_{\\mathrm{eq},T}$ 时，不对 $p(t)$ 应用基底值 $p_{\\min}$，该值仍然是 $p^2(t)$ 的物理时间平均。\n\n一个关键的理论关系源于詹森不等式（Jensen's inequality）。以 10 为底的对数 $\\log_{10}(x)$ 在 $(0,\\infty)$ 上是凹函数，因此对于任何非负序列 $\\{x_n\\}$，\n$$\n\\frac{1}{N}\\sum_{n=0}^{N-1}\\log_{10}(x_n)\\le \\log_{10}\\!\\left(\\frac{1}{N}\\sum_{n=0}^{N-1}x_n\\right),\n$$\n当且仅当所有 $x_n$ 几乎处处相等时，等号成立。将此应用于 $x_n=\\frac{p^2(t_n)}{p_0^2}$（为进行概念性不等式推导，忽略基底值）并在两边乘以 10，可得\n$$\n\\overline{L}\\le L_{\\mathrm{eq},T},\n$$\n当且仅当 $\\frac{p^2(t)}{p_0^2}$ 在时间上几乎处处为常数，即声压平方在整个区间内为常数时，等号成立。这从形式上说明了为什么瞬时分贝值的算术平均值通常会低估等能量声级。\n\n算法设计：\n- 对于每个测试用例，构建离散时间向量 $t_n=n/f_s$，$n=0,\\dots,N-1$，$N=\\lfloor T f_s\\rfloor$。\n- 根据指定的情况生成 $p(t_n)$：\n  - 情况 A：使用固定的伪随机种子，从标准差为 $\\sigma_p$ 的零均值高斯分布中抽取独立样本，以确保可复现性。\n  - 情况 B：计算 $p(t_n)=A\\sin(2\\pi f t_n)$。\n  - 情况 C：计算周期为 $P$、占空比为 50% 的方波包络 $g(t_n)$，然后计算 $p(t_n)=g(t_n)A\\sin(2\\pi f t_n)$。\n  - 情况 D：计算周期为 $P$、开启持续时间为 $\\tau_{\\mathrm{on}}$ 的方波包络 $g(t_n)$，然后计算 $p(t_n)=g(t_n)A\\sin(2\\pi f t_n)$。\n- 计算 $L_{\\mathrm{eq},T}=10\\log_{10}\\!\\left(\\frac{\\frac{1}{N}\\sum p^2(t_n)}{p_0^2}\\right)$。\n- 计算瞬时声级 $L(t_n)=10\\log_{10}\\!\\left(\\frac{\\max\\{p^2(t_n),p_{\\min}^2\\}}{p_0^2}\\right)$，然后计算 $\\overline{L}=\\frac{1}{N}\\sum L(t_n)$。\n- 报告 $[L_{\\mathrm{eq},T},\\ \\overline{L},\\ L_{\\mathrm{eq},T}-\\overline{L}]$，并将每个值四舍五入到 6 位小数。\n\n合理性检查与预期：\n- 情况 B（纯音）的 RMS 声压为 $A/\\sqrt{2}$，因此可以预期 $L_{\\mathrm{eq},T}\\approx 20\\log_{10}\\!\\left(\\frac{A/\\sqrt{2}}{p_0}\\right)$；对于 $A=0.1$ 帕斯卡和 $p_0=2\\times 10^{-5}$ 帕斯卡，这大约给出 $70.97$ 分贝。算术平均值 $\\overline{L}$ 会更低，因为 $\\log_{10}$ 是凹函数，并且瞬时分贝值会不成比例地强调低声压瞬间。\n- 情况 C（半时门控音）相对于相同振幅的连续音，能量减半，因此总 RMS 值降低了 $\\sqrt{0.5}$ 倍，这意味着相对于相同振幅和频率的连续音，$L_{\\mathrm{eq},T}$ 降低了 3 分贝。\n- 情况 D（稀疏脉冲串）产生的 $L_{\\mathrm{eq},T}$ 反映了总占空比 $d=\\frac{\\tau_{\\mathrm{on}}}{P}$，其 RMS 值按 $\\sqrt{d}$ 比例缩放；由于存在延长的静默时段以及对数函数的凹性，即使有很小的 $p_{\\min}$，预计算术平均值 $\\overline{L}$ 也会低得多。\n\n程序实现了这些计算，并按要求的确切格式将所有情况的结果打印为单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef leq_from_timeseries(p, p0):\n    \"\"\"\n    Compute equivalent continuous sound level L_eq,T in dB re p0\n    from a discrete-time pressure series p (Pascals).\n    \"\"\"\n    mean_square = np.mean(p**2)\n    # Avoid negative inf only if mean_square is zero (which shouldn't happen except all zeros)\n    if mean_square == 0.0:\n        return float(\"-inf\")\n    return 10.0 * np.log10(mean_square / (p0**2))\n\ndef mean_instantaneous_db(p, p0, pmin):\n    \"\"\"\n    Compute arithmetic mean of instantaneous dB values:\n    L_inst[n] = 10*log10(max(p[n]^2, pmin^2) / p0^2)\n    \"\"\"\n    squared = p**2\n    squared_clamped = np.maximum(squared, pmin**2)\n    L_inst = 10.0 * np.log10(squared_clamped / (p0**2))\n    return float(np.mean(L_inst))\n\ndef generate_time_vector(fs, T):\n    \"\"\"\n    Generate time vector t = [0, 1/fs, 2/fs, ..., T - 1/fs]\n    \"\"\"\n    N = int(np.floor(T * fs))\n    t = np.arange(N, dtype=np.float64) / fs\n    return t\n\ndef case_A_gaussian_noise(fs, T, sigma_p, seed):\n    t = generate_time_vector(fs, T)\n    rng = np.random.default_rng(seed)\n    p = rng.normal(loc=0.0, scale=sigma_p, size=t.shape)\n    return p\n\ndef case_B_pure_tone(fs, T, A, f):\n    t = generate_time_vector(fs, T)\n    p = A * np.sin(2.0 * np.pi * f * t)\n    return p\n\ndef square_gate(t, period, on_duration):\n    \"\"\"\n    Square gating envelope g(t): 1 if (t % period)  on_duration else 0\n    \"\"\"\n    phase = np.mod(t, period)\n    return (phase  on_duration).astype(np.float64)\n\ndef case_C_gated_tone(fs, T, A, f, P):\n    t = generate_time_vector(fs, T)\n    # 50% duty: on for P/2\n    gate = square_gate(t, period=P, on_duration=0.5 * P)\n    p = gate * A * np.sin(2.0 * np.pi * f * t)\n    return p\n\ndef case_D_sparse_bursts(fs, T, A, f, P, tau_on):\n    t = generate_time_vector(fs, T)\n    gate = square_gate(t, period=P, on_duration=tau_on)\n    p = gate * A * np.sin(2.0 * np.pi * f * t)\n    return p\n\ndef solve():\n    # Constants\n    p0 = 2e-5  # Pa\n    pmin = 1e-12  # Pa, floor for instantaneous dB only\n\n    # Define the test cases as tuples: (generator_func, params_dict)\n    test_cases = [\n        # Case A: Gaussian noise\n        (\"A\", case_A_gaussian_noise, dict(fs=44100.0, T=10.0, sigma_p=0.02, seed=12345)),\n        # Case B: Pure tone\n        (\"B\", case_B_pure_tone, dict(fs=48000.0, T=2.5, A=0.1, f=1000.0)),\n        # Case C: 50% duty gated tone\n        (\"C\", case_C_gated_tone, dict(fs=32000.0, T=8.0, A=0.02, f=500.0, P=1.0)),\n        # Case D: Sparse bursts ~1% duty\n        (\"D\", case_D_sparse_bursts, dict(fs=44100.0, T=5.0, A=2e-4, f=1000.0, P=0.5, tau_on=0.005)),\n    ]\n\n    results = []\n    for _, gen, params in test_cases:\n        p = gen(**params)\n        L_eq = leq_from_timeseries(p, p0)\n        L_avg = mean_instantaneous_db(p, p0, pmin)\n        diff = L_eq - L_avg\n        # Round to 6 decimal places as required\n        results.append([round(L_eq, 6), round(L_avg, 6), round(diff, 6)])\n\n    # Final print statement in the exact required format.\n    # Print a single line: list of lists\n    # Ensure standard Python list formatting with commas\n    print(str(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2533871"}, {"introduction": "理解声音如何从声源传播到接收器，对于估算生物声学传感器的有效监测范围至关重要。本练习要求您从第一性原理出发，推导并应用一个基本的声传播模型，该模型同时考虑了球面波的几何扩散和与频率相关的大气吸收效应。掌握此计算将使您能够预测动物叫声在不同距离上的可闻度，并设计出更有效的野外调查方案。[@problem_id:2533884]", "problem": "一台部署在半干旱稀树草原的自主记录仪被用于监测中心频率为 $f = 4000$ Hz 的纯音鸟鸣的传播。在声源附近的校准试验中，测得距离鸟 $1$ 米处的声压级 (SPL) 为 $L_{p,1\\text{ m}} = 110$ dB re $20$ $\\mu$Pa。假设为自由场、均匀、稳态大气条件，无地面相互作用、风或温度梯度。在这些条件下，大气的频率相关吸收由一个简化系数 $\\alpha(f)$ 表征，该系数以分贝每米为单位，由下式给出\n$\\alpha(f) = A f^{2}$，\n其中 $A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$。一个记录仪放置在距离声源 $r = 1500$ m 的位置。\n\n仅从以下基本原理出发：\n- 在自由场中，球面扩散下的声强随距离的平方反比而减小。\n- 均匀介质中的分子吸收遵循比尔-朗伯衰减定律。\n- SPL 定义为 $L_{p} = 20 \\log_{10}\\!\\big(p_{\\mathrm{rms}}/p_{\\mathrm{ref}}\\big)$，其中 $p_{\\mathrm{ref}} = 20$ $\\mu$Pa，且对于平面波 $I \\propto p_{\\mathrm{rms}}^{2}$，\n\n推导出在距离 $r$ 处的接收声压级关于 $L_{p,1\\text{ m}}$、$r$ 和 $\\alpha(f)$ 的解析表达式，然后使用给定的 $f$、$A$ 和 $r$ 对其进行数值计算。距离单位使用米，并将 $\\alpha(f)$ 以 dB m$^{-1}$ 表示。将最终的 SPL 四舍五入至四位有效数字，并以 dB 表示结果。", "solution": "首先，我们从基本原理推导在距离 $r$ 处的接收声压级 $L_{p,r}$ 的表达式。\n\n声音从参考点 $r_1$ 传播到距离 $r$ 的过程中，其声压级的总变化由两个主要部分组成：几何扩散造成的损失和大气吸收造成的损失。\n\n1.  **几何扩散损失 (Transmission Loss, TL)**: 在自由场（无反射边界）中，声能从点声源向外呈球面辐射。声强 $I$（单位面积的功率）与距离 $r$ 的平方成反比，即 $I \\propto 1/r^2$。声压级 (SPL) 是基于声压的对数度量，而声强与均方根声压 $p_{\\mathrm{rms}}$ 的平方成正比 ($I \\propto p_{\\mathrm{rms}}^2$)。因此，声压级随距离的衰减可以表示为：\n    $$ \\text{TL}_{\\text{geom}} = 10 \\log_{10}\\left(\\frac{I_{r_1}}{I_r}\\right) = 10 \\log_{10}\\left(\\frac{r^2}{r_1^2}\\right) = 20 \\log_{10}\\left(\\frac{r}{r_1}\\right) $$\n    这个项表示从 $r_1$ 到 $r$ 由于几何扩散引起的声压级降低量（以 dB 计）。\n\n2.  **大气吸收损失**: 声波在介质中传播时，部分能量会因分子弛豫等过程转化为热能而被吸收。这种损失通常用一个吸收系数 $\\alpha$（单位为 dB/m）来量化。对于均匀介质，总吸收损失与传播距离成正比。从 $r_1$ 到 $r$ 的传播路径长度为 $(r-r_1)$，因此吸收损失为：\n    $$ \\text{TL}_{\\text{abs}} = \\alpha(f) \\cdot (r - r_1) $$\n\n总的声压级 $L_{p,r}$ 是在参考点 $r_1$ 处的声压级 $L_{p,r_1}$ 减去这两部分损失：\n$$ L_{p,r} = L_{p,r_1} - \\text{TL}_{\\text{geom}} - \\text{TL}_{\\text{abs}} $$\n$$ L_{p,r} = L_{p,r_1} - 20 \\log_{10}\\left(\\frac{r}{r_1}\\right) - \\alpha(f)(r-r_1) $$\n这就是所要求的解析表达式。\n\n接下来，我们代入问题中给定的数值进行计算：\n- 参考声压级：$L_{p,1\\text{ m}} = 110$ dB\n- 参考距离：$r_1 = 1$ m\n- 接收器距离：$r = 1500$ m\n- 频率：$f = 4000$ Hz\n- 吸收常数：$A = 2.5 \\times 10^{-10}$ dB m$^{-1}$ Hz$^{-2}$\n\n**第一步：计算大气吸收系数 $\\alpha(f)$**\n$$ \\alpha(f) = A f^2 = (2.5 \\times 10^{-10}) \\times (4000)^2 $$\n$$ \\alpha(4000) = (2.5 \\times 10^{-10}) \\times (1.6 \\times 10^7) = 40 \\times 10^{-4} = 0.004 \\text{ dB/m} $$\n\n**第二步：计算几何扩散损失**\n$$ \\text{TL}_{\\text{geom}} = 20 \\log_{10}\\left(\\frac{1500}{1}\\right) = 20 \\log_{10}(1500) $$\n使用计算器，$\\log_{10}(1500) \\approx 3.17609$。\n$$ \\text{TL}_{\\text{geom}} \\approx 20 \\times 3.17609 = 63.5218 \\text{ dB} $$\n\n**第三步：计算大气吸收损失**\n$$ \\text{TL}_{\\text{abs}} = \\alpha(4000) \\times (1500 - 1) = 0.004 \\times 1499 = 5.996 \\text{ dB} $$\n\n**第四步：计算最终的接收声压级**\n$$ L_{p,1500\\text{ m}} = L_{p,1\\text{ m}} - \\text{TL}_{\\text{geom}} - \\text{TL}_{\\text{abs}} $$\n$$ L_{p,1500\\text{ m}} = 110 - 63.5218 - 5.996 $$\n$$ L_{p,1500\\text{ m}} = 40.4822 \\text{ dB} $$\n\n问题要求将结果四舍五入到四位有效数字。\n$$ L_{p,1500\\text{ m}} \\approx 40.48 \\text{ dB} $$", "answer": "$$\\boxed{40.48}$$", "id": "2533884"}, {"introduction": "动物发声的自动检测是现代生物声学监测的基石，但我们如何严格评估一个检测器的性能呢？本练习将带您深入信号检测理论的核心，通过构建一个声谱图相关检测器，并使用接收者操作特征（ROC）曲线对其进行分析。通过模拟信号和噪声，您将学会如何量化检测器区分信号与背景噪声的能力，并理解真正例与假警报之间的权衡。[@problem_id:2533839]", "problem": "您的任务是形式化并评估一个用于音景生态学和生物声学中识别模式化动物叫声的声谱图相关性检测器。该检测器将一个固定的时频谱模板与观测到的声谱图片段进行比较，并产生一个标量检测分数。您必须从第一性原理出发推导接收者操作特征（ROC）曲线和曲线下面积（AUC），并实现一个程序，该程序能够合成数据，计算跨阈值的经验性ROC曲线，并为提供的一组参数测试套件返回AUC值。\n\n声谱图相关性检测器和数据生成模型的定义：\n- 令 $H \\in \\mathbb{N}$ 和 $W \\in \\mathbb{N}$ 分别表示声谱图片段的频率仓数量和时间帧数量。令 $T \\in \\mathbb{R}^{H \\times W}$ 为一个固定的非负模板，代表目标叫声。\n- 对于任何观测到的片段 $X \\in \\mathbb{R}^{H \\times W}$，定义归一化相关性检测分数 $s(X)$ 为\n$$\ns(X) \\triangleq \\frac{\\langle \\mathrm{vec}(X - \\bar{X}), \\mathrm{vec}(T - \\bar{T}) \\rangle}{\\left\\|\\mathrm{vec}(X - \\bar{X})\\right\\|_2 \\cdot \\left\\|\\mathrm{vec}(T - \\bar{T})\\right\\|_2},\n$$\n其中 $\\bar{X}$ 和 $\\bar{T}$ 分别表示 $X$ 和 $T$ 中元素的均值，$\\mathrm{vec}(\\cdot)$ 将矩阵展平为向量。\n- 正样本由 $X^{+} = A \\cdot \\tilde{T} + N$ 生成，其中 $A \\in \\mathbb{R}_{0}$ 是一个标量振幅，$\\tilde{T} \\in \\mathbb{R}^{H \\times W}$ 是 $T$（匹配）或 $T$ 的一个变体（不匹配），$N \\in \\mathbb{R}^{H \\times W}$ 是加性高斯白噪声，其独立元素 $N_{ij} \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 负样本由 $X^{-} = N$ 生成，其噪声分布与正样本相同。\n- 信噪比（SNR）的线性单位定义为\n$$\n\\mathrm{SNR} \\triangleq \\frac{\\mathbb{E}\\left[\\|A \\cdot \\tilde{T}\\|_F^2\\right]}{\\mathbb{E}\\left[\\|N\\|_F^2\\right]} = \\frac{A^2 \\cdot \\|\\tilde{T}\\|_F^2}{H \\cdot W \\cdot \\sigma^2}.\n$$\n- 给定一个指定的 $\\mathrm{SNR}_{\\mathrm{dB}}$，计算 $\\mathrm{SNR} = 10^{\\mathrm{SNR}_{\\mathrm{dB}}/10}$ 并将噪声方差设置为\n$$\n\\sigma^2 = \\frac{A^2 \\cdot \\|\\tilde{T}\\|_F^2}{H \\cdot W \\cdot \\mathrm{SNR}} = \\frac{A^2 \\cdot \\mathrm{mean}(\\tilde{T}^2)}{\\mathrm{SNR}},\n$$\n其中 $\\mathrm{mean}(\\tilde{T}^2) \\triangleq \\frac{1}{H W}\\sum_{i=1}^{H}\\sum_{j=1}^{W} \\tilde{T}_{ij}^2$。\n- 模板 $T$ 是一个具有高斯结构和可选线性调频的理想化时频谱脊线。对于频率索引 $i \\in \\{0,\\dots,H-1\\}$ 和时间索引 $j \\in \\{0,\\dots,W-1\\}$，定义\n$$\nT_{ij} = \\exp\\!\\left(-\\frac{\\left(i - \\mu_f - k \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right),\n$$\n其中 $\\mu_t \\triangleq \\frac{W-1}{2}$，中心频率 $\\mu_f \\in \\mathbb{R}$，频率扩展 $\\sigma_f \\in \\mathbb{R}_{0}$，时间扩展 $\\sigma_t \\in \\mathbb{R}_{0}$，以及调频斜率 $k \\in \\mathbb{R}$。一个不匹配的模板 $\\tilde{T}$ 可以通过将中心频率偏移 $\\Delta f \\in \\mathbb{R}$ 并可选地使用一个替代的调频斜率 $\\tilde{k} \\in \\mathbb{R}$ 来生成：\n$$\n\\tilde{T}_{ij} = \\exp\\!\\left(-\\frac{\\left(i - (\\mu_f + \\Delta f) - \\tilde{k} \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right).\n$$\n\n接收者操作特征（ROC）与曲线下面积（AUC）：\n- 对于任意阈值 $\\tau \\in \\mathbb{R}$，定义真阳性率和假阳性率如下\n$$\n\\mathrm{TPR}(\\tau) \\triangleq \\mathbb{P}\\!\\left(s(X^{+}) \\ge \\tau\\right), \\qquad \\mathrm{FPR}(\\tau) \\triangleq \\mathbb{P}\\!\\left(s(X^{-}) \\ge \\tau\\right).\n$$\n- 使用有限样本，通过计算生成的正样本和负样本中所占的比例，来经验性地估计 $\\mathrm{TPR}(\\tau)$ 和 $\\mathrm{FPR}(\\tau)$。\n- ROC曲线是集合 $\\{(\\mathrm{FPR}(\\tau), \\mathrm{TPR}(\\tau)) : \\tau \\in \\mathbb{R}\\}$。\n- AUC 定义为积分\n$$\n\\mathrm{AUC} \\triangleq \\int_{0}^{1} \\mathrm{TPR} \\, d(\\mathrm{FPR}),\n$$\n该积分必须通过对按 $\\mathrm{FPR}$ 递增排序的经验性ROC点使用梯形法则进行数值近似。\n\n实现要求：\n- 为下述每个测试用例合成如上所述的数据集。使用 $A = 1$（无量纲）。所有量均为无量纲；不需要物理单位。\n- 对于每个测试用例，生成 $n_{+}$ 个正样本和 $n_{-}$ 个负样本。使用相关性检测器为每个样本计算检测分数。在所有唯一分数上扫描阈值（用 $\\pm \\infty$ 增广以包含端点），以获得经验性ROC点，并使用梯形近似法计算AUC。\n- 数值稳定性：在计算相关性分数时，如果分母中的任何方差项为零，则将该样本的分数定义为 $0$。\n- 此问题中任何地方均不使用角度单位。\n- 您的程序必须生成单行输出，其中包含所有测试用例的AUC结果，格式为方括号内以逗号分隔的列表，每个AUC值四舍五入到六位小数，例如 $[0.912345,0.500000]$。\n\n测试套件：\n- 用例 $1$（通用，匹配，中等信噪比）：$H=64$，$W=32$，$\\mu_f=28$，$\\sigma_f=5$，$\\sigma_t=8$，$k=0.08$，$\\Delta f=0$，$\\tilde{k}=0.08$，$\\mathrm{SNR}_{\\mathrm{dB}}=3$，$n_{+}=300$，$n_{-}=300$，$\\mathrm{seed}=1337$。\n- 用例 $2$（边界，接近可分性的高信噪比）：$H=64$，$W=32$，$\\mu_f=28$，$\\sigma_f=5$，$\\sigma_t=8$，$k=0.08$，$\\Delta f=0$，$\\tilde{k}=0.08$，$\\mathrm{SNR}_{\\mathrm{dB}}=25$，$n_{+}=300$，$n_{-}=300$，$\\mathrm{seed}=2021$。\n- 用例 $3$（边缘，零分贝下不匹配的模板）：$H=64$，$W=32$，$\\mu_f=28$，$\\sigma_f=5$，$\\sigma_t=8$，$k=0.08$，$\\Delta f=10$，$\\tilde{k}=0.08$，$\\mathrm{SNR}_{\\mathrm{dB}}=0$，$n_{+}=300$，$n_{-}=300$，$\\mathrm{seed}=7$。\n- 用例 $4$（边缘，极低信噪比下匹配）：$H=64$，$W=32$，$\\mu_f=28$，$\\sigma_f=5$，$\\sigma_t=8$，$k=0.08$，$\\Delta f=0$，$\\tilde{k}=0.08$，$\\mathrm{SNR}_{\\mathrm{dB}}=-10$，$n_{+}=300$，$n_{-}=300$，$\\mathrm{seed}=99$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的AUC值，四舍五入到六位小数，格式严格为 $[a_1,a_2,a_3,a_4]$，无空格。", "solution": "该问题要求对用于生物声学信号的声谱图相关性检测器进行形式化和实现，并通过接收者操作特征（ROC）曲线分析来评估其性能。我们的任务是根据指定的生成模型合成数据，计算经验性ROC曲线，并为一套测试用例确定曲线下面积（AUC）。\n\n首先，我们必须建立理论框架。该检测器作用于一个声谱图片段 $X \\in \\mathbb{R}^{H \\times W}$，将其与一个固定的模板 $T \\in \\mathbb{R}^{H \\times W}$ 进行比较。检测分数 $s(X)$ 定义为均值中心化后的数据和模板之间的归一化互相关：\n$$\ns(X) \\triangleq \\frac{\\langle \\mathrm{vec}(X - \\bar{X}), \\mathrm{vec}(T - \\bar{T}) \\rangle}{\\left\\|\\mathrm{vec}(X - \\bar{X})\\right\\|_2 \\cdot \\left\\|\\mathrm{vec}(T - \\bar{T})\\right\\|_2}\n$$\n此处，$\\mathrm{vec}(\\cdot)$ 将矩阵展平为向量，$\\bar{X}$ 和 $\\bar{T}$ 分别是相应矩阵元素的标量均值。该表达式在数学上等同于向量化矩阵之间的皮尔逊相关系数，其值位于区间 $[-1, 1]$ 内。接近 $+1$ 的分数表示观测到的片段与模板之间存在很强的线性关系。\n\n数据合成模型定义了两类信号。正类（信号存在）由 $X^{+} = A \\cdot \\tilde{T} + N$ 生成，其中 $\\tilde{T}$ 是信号的时频谱模式，$A$ 是其振幅，$N$ 是加性高斯白噪声。噪声矩阵 $N$ 的元素是独立同分布的，服从 $N_{ij} \\sim \\mathcal{N}(0, \\sigma^2)$。负类（信号不存在）仅由噪声组成，$X^{-} = N$。\n\n噪声方差 $\\sigma^2$ 由信噪比（$\\mathrm{SNR}$）决定。线性 $\\mathrm{SNR}$ 通过 $\\mathrm{SNR} = 10^{\\mathrm{SNR}_{\\mathrm{dB}}/10}$ 从分贝值 $\\mathrm{SNR}_{\\mathrm{dB}}$ 导出。根据定义，\n$$\n\\mathrm{SNR} \\triangleq \\frac{\\mathbb{E}\\left[\\|A \\cdot \\tilde{T}\\|_F^2\\right]}{\\mathbb{E}\\left[\\|N\\|_F^2\\right]} = \\frac{A^2 \\|\\tilde{T}\\|_F^2}{H W \\sigma^2}\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。根据问题规范，解出 $\\sigma^2$ 并设置振幅 $A=1$，我们得到：\n$$\n\\sigma^2 = \\frac{\\|\\tilde{T}\\|_F^2}{H \\cdot W \\cdot \\mathrm{SNR}} = \\frac{\\mathrm{mean}(\\tilde{T}^2)}{\\mathrm{SNR}}\n$$\n其中 $\\mathrm{mean}(\\tilde{T}^2)$ 是 $\\tilde{T}$ 元素平方的均值。\n\n参考模板 $T$ 和信号模板 $\\tilde{T}$ 被建模为高斯脊线，这是频率调制声音的常用表示方法。对于索引 $i \\in \\{0, \\dots, H-1\\}$ 和 $j \\in \\{0, \\dots, W-1\\}$，参考模板为：\n$$\nT_{ij} = \\exp\\!\\left(-\\frac{\\left(i - \\mu_f - k \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right)\n$$\n其中 $\\mu_t = (W-1)/2$。信号模板 $\\tilde{T}$ 允许频率偏移 $\\Delta f$ 和不同的调频斜率 $\\tilde{k}$：\n$$\n\\tilde{T}_{ij} = \\exp\\!\\left(-\\frac{\\left(i - (\\mu_f + \\Delta f) - \\tilde{k} \\cdot (j - \\mu_t)\\right)^2}{2\\sigma_f^2}\\right) \\cdot \\exp\\!\\left(-\\frac{(j - \\mu_t)^2}{2\\sigma_t^2}\\right)\n$$\n当 $\\Delta f = 0$ 且 $\\tilde{k} = k$ 时，出现匹配条件，意味着 $\\tilde{T}=T$。\n\n检测器性能由ROC曲线量化，该曲线绘制了在所有可能的检测阈值 $\\tau \\in (-\\infty, \\infty)$ 下，真阳性率（$\\mathrm{TPR}$）对假阳性率（$\\mathrm{FPR}$）的图。这些率定义为：\n$$\n\\mathrm{TPR}(\\tau) \\triangleq \\mathbb{P}(s(X^{+}) \\ge \\tau), \\qquad \\mathrm{FPR}(\\tau) \\triangleq \\mathbb{P}(s(X^{-}) \\ge \\tau)\n$$\n在实践中，这些概率是根据包含 $n_{+}$ 个正样本和 $n_{-}$ 个负样本的有限数据集进行经验性估计的。流程如下：\n1. 生成 $n_{+}$ 个样本 $\\{X^+_i\\}$ 和 $n_-$ 个样本 $\\{X^-_j\\}$。\n2. 为所有样本计算检测分数 $s_i^+ = s(X^+_i)$ 和 $s_j^- = s(X^-_j)$。\n3. 从所有计算出的分数集合中形成一个唯一的阈值集合。为了确保ROC曲线跨越 $[0, 1] \\times [0, 1]$，该集合用接近 $\\pm\\infty$ 的值进行增广。\n4. 对每个阈值 $\\tau$，通过计数来估计这些率：\n   $$\n   \\widehat{\\mathrm{TPR}}(\\tau) = \\frac{1}{n_+} \\sum_{i=1}^{n_+} \\mathbb{I}(s_i^+ \\ge \\tau), \\qquad \\widehat{\\mathrm{FPR}}(\\tau) = \\frac{1}{n_-} \\sum_{j=1}^{n_-} \\mathbb{I}(s_j^- \\ge \\tau)\n   $$\n   其中 $\\mathbb{I}(\\cdot)$ 是指示函数。得到的对 $(\\widehat{\\mathrm{FPR}}(\\tau), \\widehat{\\mathrm{TPR}}(\\tau))$ 构成了经验性ROC曲线。\n\n检测器的总体性能由AUC概括，即ROC曲线的积分：\n$$\n\\mathrm{AUC} = \\int_0^1 \\mathrm{TPR} \\, d(\\mathrm{FPR})\n$$\nAUC表示随机选择一个正样本的检测分数高于随机选择一个负样本的检测分数的概率。一个完美的分类器其 $\\mathrm{AUC}=1$，而一个随机分类器其 $\\mathrm{AUC}=0.5$。我们将使用梯形法则，对按 $\\mathrm{FPR}$ 递增排序的经验性ROC点进行数值逼近来计算这个积分。如果排序后的唯一ROC点为 $(x_k, y_k)_{k=0}^M$，其中 $(x_0, y_0)=(0,0)$ 且 $(x_M, y_M)=(1,1)$，则AUC为：\n$$\n\\mathrm{AUC} \\approx \\sum_{k=1}^{M} \\frac{y_k + y_{k-1}}{2} (x_k - x_{k-1})\n$$\n实现将对每个测试用例遵循这些步骤。首先设置随机种子以确保可复现性。然后生成模板 $T$ 和 $\\tilde{T}$，计算所需的噪声方差 $\\sigma^2$，并合成正负数据集。为提高效率，向量化和均值中心化后的参考模板 $T$ 及其范数被预先计算。为所有样本计算分数，并通过稳定性检查来处理潜在的零方差情况，此时将分数赋为 $0$。最后，使用这组分数来推导经验性ROC点，并通过梯形法则计算AUC。对所有用例重复此过程，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_template(H, W, mu_f, sigma_f, sigma_t, k):\n    \"\"\"\n    Generates a spectro-temporal template.\n    \"\"\"\n    mu_t = (W - 1) / 2.0\n    i_coords, j_coords = np.mgrid[0:H, 0:W]\n    \n    term1_exp = (i_coords - mu_f - k * (j_coords - mu_t))**2 / (2 * sigma_f**2)\n    term2_exp = (j_coords - mu_t)**2 / (2 * sigma_t**2)\n    \n    template = np.exp(-term1_exp) * np.exp(-term2_exp)\n    return template\n\ndef compute_correlation_score(X, T_vec_centered, T_norm):\n    \"\"\"\n    Computes the normalized correlation detection score.\n    \"\"\"\n    if T_norm == 0:\n        return 0.0\n\n    X_vec = X.flatten()\n    X_mean = np.mean(X_vec)\n    X_vec_centered = X_vec - X_mean\n    X_norm = np.linalg.norm(X_vec_centered)\n    \n    if X_norm == 0:\n        return 0.0\n        \n    numerator = np.dot(X_vec_centered, T_vec_centered)\n    denominator = X_norm * T_norm\n    \n    return numerator / denominator\n\ndef calculate_auc(scores_pos, scores_neg):\n    \"\"\"\n    Computes the AUC from positive and negative scores using the trapezoidal rule.\n    \"\"\"\n    n_pos = len(scores_pos)\n    n_neg = len(scores_neg)\n    \n    all_scores = np.concatenate([scores_pos, scores_neg])\n    # Get unique thresholds and sort them in descending order\n    thresholds = np.unique(all_scores)\n    thresholds = np.sort(thresholds)[::-1]\n    \n    # Add -inf to ensure the curve reaches (1,1)\n    thresholds = np.append(thresholds, -np.inf)\n\n    tpr_list = []\n    fpr_list = []\n    \n    for tau in thresholds:\n        tp = np.sum(scores_pos >= tau)\n        fp = np.sum(scores_neg >= tau)\n        \n        tpr = tp / n_pos if n_pos > 0 else 0\n        fpr = fp / n_neg if n_neg > 0 else 0\n        \n        tpr_list.append(tpr)\n        fpr_list.append(fpr)\n        \n    # Combine and remove duplicate points, then sort by FPR\n    roc_points = sorted(list(set(zip(fpr_list, tpr_list))))\n    \n    fpr_vals = np.array([p[0] for p in roc_points])\n    tpr_vals = np.array([p[1] for p in roc_points])\n    \n    # Calculate AUC using the trapezoidal rule\n    auc = np.trapz(tpr_vals, fpr_vals)\n    return auc\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute AUCs.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general, matched, moderate SNR)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 0, 'tilde_k': 0.08, 'SNR_dB': 3, 'n_pos': 300, 'n_neg': 300, 'seed': 1337},\n        # Case 2 (boundary, high SNR near separability)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 0, 'tilde_k': 0.08, 'SNR_dB': 25, 'n_pos': 300, 'n_neg': 300, 'seed': 2021},\n        # Case 3 (edge, mismatched template at zero dB)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 10, 'tilde_k': 0.08, 'SNR_dB': 0, 'n_pos': 300, 'n_neg': 300, 'seed': 7},\n        # Case 4 (edge, very low SNR matched)\n        {'H': 64, 'W': 32, 'mu_f': 28, 'sigma_f': 5, 'sigma_t': 8, 'k': 0.08, \n         'Delta f': 0, 'tilde_k': 0.08, 'SNR_dB': -10, 'n_pos': 300, 'n_neg': 300, 'seed': 99},\n    ]\n\n    results = []\n    A = 1.0\n\n    for case in test_cases:\n        rng = np.random.default_rng(case['seed'])\n        \n        # 1. Generate templates\n        T = generate_template(case['H'], case['W'], case['mu_f'], case['sigma_f'], case['sigma_t'], case['k'])\n        T_tilde = generate_template(case['H'], case['W'], case['mu_f'] + case['Delta f'], case['sigma_f'], case['sigma_t'], case['tilde_k'])\n\n        # 2. Determine noise variance from SNR\n        snr_linear = 10**(case['SNR_dB'] / 10.0)\n        mean_T_tilde_sq = np.mean(T_tilde**2)\n        if snr_linear == 0: # Avoid division by zero\n            sigma_sq = np.inf\n        else:\n            sigma_sq = (A**2 * mean_T_tilde_sq) / snr_linear\n        sigma = np.sqrt(sigma_sq)\n        \n        # 3. Pre-process reference template for scoring\n        T_vec = T.flatten()\n        T_mean = np.mean(T_vec)\n        T_vec_centered = T_vec - T_mean\n        T_norm = np.linalg.norm(T_vec_centered)\n        \n        # 4. Generate positive samples and scores\n        scores_pos = np.zeros(case['n_pos'])\n        for i in range(case['n_pos']):\n            noise = rng.normal(0, sigma, size=(case['H'], case['W']))\n            X_pos = A * T_tilde + noise\n            scores_pos[i] = compute_correlation_score(X_pos, T_vec_centered, T_norm)\n            \n        # 5. Generate negative samples and scores\n        scores_neg = np.zeros(case['n_neg'])\n        for i in range(case['n_neg']):\n            noise = rng.normal(0, sigma, size=(case['H'], case['W']))\n            X_neg = noise\n            scores_neg[i] = compute_correlation_score(X_neg, T_vec_centered, T_norm)\n            \n        # 6. Compute AUC\n        auc = calculate_auc(scores_pos, scores_neg)\n        results.append(auc)\n\n    # Final print statement in the exact required format\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2533839"}]}