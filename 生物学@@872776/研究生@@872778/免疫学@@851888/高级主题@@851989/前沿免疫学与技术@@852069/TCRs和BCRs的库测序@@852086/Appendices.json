{"hands_on_practices": [{"introduction": "免疫系统的强大能力源于其T细胞和B细胞受体的巨大多样性。在深入研究复杂的测序数据之前，首先量化这种多样性的理论上限是至关重要的一步。这个练习将通过一个基础的组合数学计算，帮助我们估算仅由V(D)J基因片段的组合选择所产生的原始多样性，为我们理解免疫组库的巨大规模建立一个直观的概念。[@problem_id:2886937]", "problem": "一项大规模组库测序研究旨在量化仅由T细胞受体 (TCR) 和B细胞受体 (BCR) 基因座中的组合基因片段选择所贡献的潜在多样性，而忽略连接多样性、选择以及与其他链的配对。考虑T细胞受体β (TRB) 基因座和免疫球蛋白重链 (IGH) 基因座。根据广泛接受的免疫学原理，假设如下：在V(D)J重组过程中，从包含所有三种片段类型的基因座中选择单个可变 (V)、多样性 (D) 和连接 (J) 基因片段，以形成跨越互补决定区3 (CDR3) 的外显子，并且在原始组合模型中，这些选择在基因座内是独立的。组库测序的整理结果显示，TRB基因座的功能性基因片段数量为 $48$ 个V片段、$2$ 个D片段和 $13$ 个J片段；IGH基因座的功能性基因片段数量为 $44$ 个V片段、$23$ 个D片段和 $6$ 个J片段。将这些计数视为精确值，并假设在组合空间中只考虑功能性基因片段。\n\n从V(D)J重组的定义（即从基因座中存在的每个类别中独立选择一个基因片段）和用于计算独立选择的乘法法则出发，首先确定TRB和IGH的原始组合基因选择数量。然后计算倍数差异，其定义为IGH原始组合计数与TRB原始组合计数的比率。以无单位小数形式报告此倍数差异。将最终答案四舍五入至四位有效数字。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 上下文是T细胞受体β (TRB) 基因座和免疫球蛋白重链 (IGH) 基因座的V(D)J重组。\n- 重组原理是独立选择一个可变 (V) 基因片段、一个多样性 (D) 基因片段和一个连接 (J) 基因片段。\n- 对于TRB基因座，功能性基因片段的数量为：\n  - $N_V^{\\text{TRB}} = 48$\n  - $N_D^{\\text{TRB}} = 2$\n  - $N_J^{\\text{TRB}} = 13$\n- 对于IGH基因座，功能性基因片段的数量为：\n  - $N_V^{\\text{IGH}} = 44$\n  - $N_D^{\\text{IGH}} = 23$\n  - $N_J^{\\text{IGH}} = 6$\n- 任务是首先计算每个基因座的原始组合多样性。\n- 最终任务是计算倍数差异，定义为IGH组合计数与TRB组合计数的比率，并四舍五入至四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了V(D)J重组，这是适应性免疫学的基石。通过独立选择一个V、一个D和一个J片段来计算原始组合多样性的模型是一种标准、正确但简化的方法。所提供的基因片段计数是人类基因组的现实近似值。该问题在科学上是合理的。\n- **问题定义明确：** 该问题提供了所有必要的数值数据，并明确定义了组合规则（独立选择的乘法原理）和期望的最终度量（计数比率）。计算和四舍五入的说明是明确的。可以获得一个唯一的、稳定的解。\n- **客观性：** 问题以精确、定量和客观的语言陈述，没有歧义、主观性或意见。\n\n**步骤3：结论与行动**\n问题是有效的。这是将组合原理直接应用于一个明确定义的生物学背景。开始求解。\n\n计算一系列独立事件可能结果数量的基本原理是乘法法则。对于给定的基因座，原始组合V(D)J基因选择的总数（表示为 $C$）是每种基因片段类型可用选择数量的乘积。\n\n对于T细胞受体β (TRB) 基因座，我们已知：\n- V片段数量：$N_V^{\\text{TRB}} = 48$\n- D片段数量：$N_D^{\\text{TRB}} = 2$\n- J片段数量：$N_J^{\\text{TRB}} = 13$\n\nTRB基因座的原始组合多样性 $C_{\\text{TRB}}$ 计算为这些计数的乘积：\n$$C_{\\text{TRB}} = N_V^{\\text{TRB}} \\times N_D^{\\text{TRB}} \\times N_J^{\\text{TRB}}$$\n$$C_{\\text{TRB}} = 48 \\times 2 \\times 13 = 96 \\times 13 = 1248$$\n\n对于免疫球蛋白重链 (IGH) 基因座，我们已知：\n- V片段数量：$N_V^{\\text{IGH}} = 44$\n- D片段数量：$N_D^{\\text{IGH}} = 23$\n- J片段数量：$N_J^{\\text{IGH}} = 6$\n\nIGH基因座的原始组合多样性 $C_{\\text{IGH}}$ 的计算方法类似：\n$$C_{\\text{IGH}} = N_V^{\\text{IGH}} \\times N_D^{\\text{IGH}} \\times N_J^{\\text{IGH}}$$\n$$C_{\\text{IGH}} = 44 \\times 23 \\times 6 = 1012 \\times 6 = 6072$$\n\n问题要求计算倍数差异 $F$，其定义为IGH原始组合计数与TRB原始组合计数的比率。\n$$F = \\frac{C_{\\text{IGH}}}{C_{\\text{TRB}}}$$\n代入计算出的值：\n$$F = \\frac{6072}{1248}$$\n\n我们进行除法运算以获得一个十进制值：\n$$F \\approx 4.865384615...$$\n\n问题要求将最终答案四舍五入至四位有效数字。前四位有效数字是 $4$、$8$、$6$ 和 $5$。第五位有效数字是 $3$，小于 $5$，所以我们向下舍入（即截断）。\n因此，四舍五入后的倍数差异是 $4.865$。这表示根据所提供的基因片段计数，IGH基因座的原始组合潜力大约是TRB基因座的 $4.865$ 倍。", "answer": "$$\\boxed{4.865}$$", "id": "2886937"}, {"introduction": "高通量测序技术为我们打开了观察免疫组库多样性的大门，但这种技术并非完美无瑕，测序错误是分析中必须面对的现实。为了确保从数百万条序列中得出的结论是可靠的，我们必须对数据质量进行严格控制。本练习将引导你推导并应用Phred质量分数，这是生物信息学中用于量化碱基调用准确性的核心指标，你将学会如何设定一个质量阈值以保证CDR3序列的整体准确性。[@problem_id:2886929]", "problem": "一个进行T细胞受体（TCRs）和B细胞受体（BCRs）高通量谱系测序的实验室，旨在设定一个碱基检出质量阈值，以控制互补决定区$3$（CDR$3$）检出中的序列水平错误。考虑单个碱基检出的错误概率为 $p \\in (0,1)$，并令其相关的 Phred 质量评分为 $Q$。根据定义，Phred 标度是基于 $10$ 的对数标度，使得 $p$ 每降低十倍，$Q$ 相应增加 $10$，并且当 $p=1$ 时 $Q=0$。\n\n任务（i）：仅使用这些定义属性，推导出 $Q$ 作为 $p$ 的函数的显式表达式。\n\n任务（ii）：对于一个长度为 $L=45$ 个碱基的 TCR $\\beta$ 链 CDR$3$ 区域，假设碱基检出错误在各个位置上独立发生，每个碱基的错误概率相同，且其上界为 $p$。实验室将在整个 CDR$3$ 区域强制执行单个碱基的 Phred 阈值 $Q^{\\star}$；只有评分至少为 $Q^{\\star}$ 的碱基才会被保留，因此每个碱基的错误概率满足由 $Q^{\\star}$ 所隐含的 $p \\leq p^{\\star}$。确定最小的 $Q^{\\star}$，以保证保留的 CDR$3$ 序列中含有至少一个错误碱基的概率最多为 $\\alpha=0.01$。将你计算出的 $Q^{\\star}$ 最终数值答案四舍五入至四位有效数字。", "solution": "所述问题在科学上基于生物信息学和概率论的原理，问题陈述清晰，提供了所有必要的数据，并以客观、明确的语言表达。因此，该问题被认为是有效的，并将构建一个严谨的解答。\n\n问题分为两部分。我们将依次解决每一部分。\n\n第（i）部分：Phred 评分公式的推导。\n\n问题提供了 Phred 质量评分 $Q$ 作为碱基检出错误概率 $p$ 的函数的两个定义属性。\n$1$. $p$ 每降低十倍，$Q$ 相应增加 $10$。\n$2$. 当 $p=1$ 时 $Q=0$。\n\n第一个属性表明 $Q$ 和 $p$ 之间存在对数关系。让我们根据这种标度的常规做法，提出一个基于常用对数（以10为底）的一般形式：\n$$Q(p) = A \\log_{10}(p) + B$$\n其中 $A$ 和 $B$ 是待定常数。\n\n让我们考虑两个错误概率 $p_1$ 和 $p_2$，其中 $p_2 = \\frac{p_1}{10}$。对应的质量评分是 $Q_1 = Q(p_1)$ 和 $Q_2 = Q(p_2)$。根据属性1，我们必须有 $Q_2 = Q_1 + 10$。\n\n让我们应用我们提出的函数形式：\n$$Q_1 = A \\log_{10}(p_1) + B$$\n$$Q_2 = A \\log_{10}(p_2) + B = A \\log_{10}\\left(\\frac{p_1}{10}\\right) + B$$\n使用对数的性质 $\\log_{10}(x/y) = \\log_{10}(x) - \\log_{10}(y)$，我们得到：\n$$Q_2 = A (\\log_{10}(p_1) - \\log_{10}(10)) + B = A (\\log_{10}(p_1) - 1) + B$$\n$$Q_2 = (A \\log_{10}(p_1) + B) - A = Q_1 - A$$\n我们已知 $Q_2 = Q_1 + 10$。将其与我们推导出的关系 $Q_2 = Q_1 - A$ 进行比较，我们发现：\n$$Q_1 + 10 = Q_1 - A \\implies A = -10$$\n所以，函数的形式必须是 $Q(p) = -10 \\log_{10}(p) + B$。\n\n现在，我们使用第二个属性：$Q(1) = 0$。\n$$Q(1) = -10 \\log_{10}(1) + B$$\n因为 $\\log_{10}(1) = 0$，这可以简化为：\n$$0 = -10(0) + B \\implies B = 0$$\n因此，常数被确定。$Q$ 作为 $p$ 的函数的显式表达式是：\n$$Q(p) = -10 \\log_{10}(p)$$\n\n第（ii）部分：最小 Phred 评分阈值 $Q^{\\star}$ 的确定。\n\n我们给定一个长度为 $L=45$ 个碱基的互补决定区 $3$ (CDR$3$)。碱基检出错误被假定为独立事件，且所有位置的每个碱基的错误概率 $p$ 是相同的。一个质量阈值 $Q^{\\star}$ 被应用，这意味着对于任何保留的碱基，其质量评分 $Q \\geq Q^{\\star}$。这隐含了其错误概率的一个上界 $p \\leq p^{\\star}$，其中 $p^{\\star}$ 是与评分 $Q^{\\star}$ 相对应的错误概率。\n\n设 $E$ 为长度为 $L$ 的 CDR$3$ 序列包含至少一个错误碱基的事件。该事件的概率 $P(E)$ 必须最多为 $\\alpha = 0.01$。\n$E$ 的互补事件是序列不含错误，即所有 $L$ 个碱基都被正确检出。单个碱基正确的概率是 $1-p$。由于错误的独立性，整个序列正确的概率是：\n$$P(E^c) = (1-p)^L$$\n因此，至少存在一个错误的概率是：\n$$P(E) = 1 - P(E^c) = 1 - (1-p)^L$$\n质量控制的约束条件是 $P(E) \\leq \\alpha$。\n$$1 - (1-p)^L \\leq \\alpha$$\n函数 $f(p) = 1 - (1-p)^L$ 是关于 $p$ 的单调递增函数。为确保所有通过筛选的序列（其中 $p \\leq p^{\\star}$）都满足该约束，我们必须在最坏的情况下（即 $p = p^{\\star}$）满足该约束。\n$$1 - (1-p^{\\star})^L \\leq \\alpha$$\n我们寻求所需的最小阈值 $Q^{\\star}$。函数 $Q(p) = -10 \\log_{10}(p)$ 是关于 $p$ 的单调递减函数。较低的 $Q^{\\star}$ 允许较高的 $p^{\\star}$。因此，最小的 $Q^{\\star}$ 对应于最大允许的错误概率 $p^{\\star}$。我们通过求解等式来找到这个最大的 $p^{\\star}$：\n$$1 - (1-p^{\\star})^L = \\alpha$$\n$$(1-p^{\\star})^L = 1 - \\alpha$$\n$$1-p^{\\star} = (1 - \\alpha)^{1/L}$$\n$$p^{\\star} = 1 - (1 - \\alpha)^{1/L}$$\n现在，我们可以使用第（i）部分推导出的公式来找到最小阈值 $Q^{\\star}$：\n$$Q^{\\star} = -10 \\log_{10}(p^{\\star}) = -10 \\log_{10}\\left(1 - (1 - \\alpha)^{1/L}\\right)$$\n我们代入给定的值 $L=45$ 和 $\\alpha=0.01$：\n$$Q^{\\star} = -10 \\log_{10}\\left(1 - (1 - 0.01)^{1/45}\\right) = -10 \\log_{10}\\left(1 - (0.99)^{1/45}\\right)$$\n我们进行数值计算。\n首先，我们计算对数内的项：\n$$p^{\\star} = 1 - (0.99)^{1/45} \\approx 1 - 0.9997766842 = 0.0002233158$$\n接下来，我们将此值代入 $Q^{\\star}$ 的表达式中：\n$$Q^{\\star} = -10 \\log_{10}(0.0002233158) \\approx -10(-3.651130) \\approx 36.51130$$\n问题要求将最终答案四舍五入到四位有效数字。前四位有效数字是 $3$、$6$、$5$ 和 $1$。第五位有效数字是 $1$，所以我们向下舍入。\n$$Q^{\\star} \\approx 36.51$$", "answer": "$$\\boxed{36.51}$$", "id": "2886929"}, {"introduction": "对免疫组库的分析可以超越简单的序列计数和错误过滤，进入一个更深层次的定量建模阶段。计算一个特定TCR或BCR序列的生成概率（$P_{\\text{gen}}$）是理解VDJ重组过程内在偏好性的终极工具之一，它能够告诉我们哪些序列更容易被免疫系统产生。这项挑战性的练习将指导你使用动态规划这一强大的算法技术，来精确计算一个给定CDR3序列的$P_{\\text{gen}}$，从而整合所有可能的基因选择、删除和插入事件。[@problem_id:2886872]", "problem": "给定一个用于淋巴细胞抗原受体中由可变（V）多样性（D）连接（J）重组（VDJ recombination）产生的互补决定区3（CDR3）核苷酸序列的概率生成模型。T细胞受体（TCR）β链或B细胞受体（BCR）重链的互补决定区3（CDR3）序列被建模为一个截短的可变（V）基因片段、一个在V-D连接处的插入、一个截短的多样性（D）基因片段、一个在D-J连接处的插入以及一个截短的连接（J）基因片段的串联。目标是通过对所有在该模型下能产生观测到的CDR3核苷酸序列$s$的隐藏重组情景进行求和，来计算该序列的生成概率，记为$P_{\\text{gen}}(s)$。总概率通过使用下述全概率定律和独立性假设对所有潜在选择进行边缘化来计算。任务是实现一个动态规划算法，对于一个小的、固定的模型和一组给定的观测序列，精确而高效地执行此求和操作。\n\n基本原理和假设：\n- 该过程遵循VDJ重组的核心免疫学定义：选择一个V基因，一个D基因，以及一个J基因；基因末端的核苷酸可能被核酸外切酶修剪删除；非模板的插入由末端脱氧核苷酸转移酶在V-D和D-J连接处添加。除了受序列串联约束外，各项选择都是独立的。\n- 设字母表为$\\{\\text{A, C, G, T}\\}$。插入序列中所有核苷酸的发射概率都是独立同分布的，遵循固定的碱基概率。\n- 概率可分解为独立的组成部分：基因选择、V和J基因的独立删除、D基因的独立$5'$和$3'$端删除，以及两个连接处的独立插入。\n- $s$的生成概率是$s$的所有分割（划分为V、N1、D、N2和J贡献）的总和，这些分割与某种基因选择和删除方案一致。\n\n所有计算中使用的模型参数：\n- V基因：V1 = \"ATG\", V2 = \"ACG\"。\n- D基因：D1 = \"GG\", D2 = \"GA\"。\n- J基因：J1 = \"TAC\", J2 = \"CAC\"。\n- 基因选择概率是均匀的：$P(V=\\text{V1}) = P(V=\\text{V2}) = 1/2$， $P(D=\\text{D1}) = P(D=\\text{D2}) = 1/2$， $P(J=\\text{J1}) = P(J=\\text{J2}) = 1/2$。\n- V基因删除：从所选长度为$\\ell_V$的V基因的$3'$端删除$d_V \\in \\{0,\\dots,\\ell_V\\}$个核苷酸，其中$P(d_V \\mid V) \\propto \\rho_V^{d_V}$，$\\rho_V = 0.4$，且概率在允许的范围内归一化。\n- J基因删除：从所选长度为$\\ell_J$的J基因的$5'$端删除$d_J \\in \\{0,\\dots,\\ell_J\\}$个核苷酸，其中$P(d_J \\mid J) \\propto \\rho_J^{d_J}$，$\\rho_J = 0.4$，且概率在允许的范围内归一化。\n- D基因删除：从所选长度为$\\ell_D$的D基因的$5'$端删除$d_{D5} \\in \\{0,\\dots,\\ell_D\\}$个核苷酸，从$3'$端删除$d_{D3} \\in \\{0,\\dots,\\ell_D\\}$个核苷酸，约束条件为$d_{D5} + d_{D3} \\le \\ell_D$。联合删除概率可分解为$P(d_{D5}, d_{D3} \\mid D) \\propto \\rho_{D5}^{d_{D5}} \\rho_{D3}^{d_{D3}}$，其中$\\rho_{D5} = 0.5$和$\\rho_{D3} = 0.5$，并在所有允许的配对上归一化。\n- V-D（N1）和D-J（N2）连接处的插入是独立的。对于长度为$L \\in \\{0,1,2,\\dots\\}$的插入，其概率为$P(L) = (1-\\lambda)\\lambda^{L}$，其中$\\lambda = 0.5$。给定长度$L$，插入的核苷酸是独立同分布的，碱基概率为$P(\\text{A}) = 0.25$，$P(\\text{C}) = 0.25$，$P(\\text{G}) = 0.25$，$P(\\text{T}) = 0.25$。\n\n序列生成的公式化：\n- 从长度为$\\ell_V$的V基因的$3'$端删除$d_V$个核苷酸后，V基因的贡献等于长度为$\\ell_V - d_V$的V基因前缀。从长度为$\\ell_J$的J基因的$5'$端删除$d_J$个核苷酸后，J基因的贡献等于长度为$\\ell_J - d_J$的J基因后缀。从长度为$\\ell_D$的D基因删除$d_{D5}$和$d_{D3}$个核苷酸后，D基因的贡献等于D基因的子串$D[d_{D5} : \\ell_D - d_{D3}]$，其长度为$\\ell_D - d_{D5} - d_{D3}$。观测序列$s$必须等于V-前缀、N1、D-子串、N2、J-后缀的串联。\n\n你的任务：\n- 推导并实现一个动态规划算法，通过对$s$所有满足$0 \\le i \\le j \\le k \\le l \\le L$（其中$L$是$s$的长度）的一致分割索引$(i,j,k,l)$进行求和来计算$P_{\\text{gen}}(s)$。这些分割需满足：$s[0:i]$由某个V基因截短产生，$s[i:j]$是V-D连接处的插入，$s[j:k]$由某个D基因截短产生，$s[k:l]$是D-J连接处的插入，以及$s[l:L]$由某个J基因截短产生。为避免对情景进行指数级枚举，请预计算V前缀、D子串和J后缀的匹配表，以及插入的发射概率。\n- 使用精确字符串匹配来强制执行基因衍生片段的兼容性；如果一个基因截短与$s$的相应子串不匹配，其贡献为零。对每个片段的所有基因和有效的删除值进行求和。\n- 你的程序必须按照以下确切顺序为给定的观测序列测试套件计算结果：\n  - 案例1：$s = \\text{\"ACGGT\"}$。\n  - 案例2：$s = \\text{\"ATGGGAT\"}$。\n  - 案例3：$s = \\text{\"\"}$（长度为0的空字符串）。\n  - 案例4：$s = \\text{\"G\"}$。\n- 最终输出格式要求为单行，包含一个Python风格的列表，内含四个浮点数概率，按顺序排列，不带任何附加文本，例如$[\\text{p1},\\text{p2},\\text{p3},\\text{p4}]$。\n\n约束和说明：\n- 你的实现必须是一个完整、可运行的程序，不接受任何输入，并以上述指定的单行格式打印输出。\n- 所有概率必须根据上述模型，使用全概率定律和独立性假设进行精确计算。不允许任何近似。\n- 覆盖设计：确保你的算法能正确处理边界条件$L=0$、零插入的情况以及非零插入的情况。", "solution": "该问题要求在一个VDJ重组的概率模型下，计算给定核苷酸序列$s$的生成概率$P_{\\text{gen}}(s)$。总概率是通过对所有能够产生序列$s$的潜在情景（基因选择、删除和插入）求和得到的。对所有情景进行暴力求和在计算上是不可行的。因此，必须采用动态规划方法来进行高效且精确的计算。\n\n设观测序列为$s$，其长度为$L$。模型假设$s$是五个片段的串联：一个截短的V基因前缀、一个非模板插入（N1）、一个截短的D基因子串、第二个非模板插入（N2），以及一个截短的J基因后缀。\n$$ s = s[0:i] \\cdot s[i:j] \\cdot s[j:k] \\cdot s[k:l] \\cdot s[l:L] $$\n其中$0 \\le i \\le j \\le k \\le l \\le L$是分割点。\n\n总概率$P_{\\text{gen}}(s)$通过对所有与观测序列$s$一致的基因选择、删除模式和插入事件进行边缘化得到。由于模型中的独立性假设，产生$s$的特定情景的概率可以分解为每个独立选择的概率的乘积。对所有情景求和可以表述为对所有可能的分割选择$(i, j, k, l)$求和：\n$$ P_{\\text{gen}}(s) = \\sum_{0 \\le i \\le j \\le k \\le l \\le L} P_{V}(s[0:i]) \\cdot P_{N1}(s[i:j]) \\cdot P_{D}(s[j:k]) \\cdot P_{N2}(s[k:l]) \\cdot P_{J}(s[l:L]) $$\n其中每一项代表相应子串由对应过程（V基因贡献、N1插入等）生成的总概率。\n\n这种结构适合使用动态规划。我们定义一个前向算法，在V-D-J模型的每个阶段计算生成$s$前缀的概率。设$L$为$s$的长度。我们定义以下大小为$L+1$的DP数组：\n1.  $F_V[i]$：前缀$s[0:i]$由V基因片段生成的概率。\n2.  $F_{VN1}[j]$：前缀$s[0:j]$由V基因片段后跟一个N1插入生成的概率。\n3.  $F_{VN1D}[k]$：前缀$s[0:k]$由V-N1-D序列生成的概率。\n4.  $F_{VN1DN2}[l]$：前缀$s[0:l]$由V-N1-D-N2序列生成的概率。\n\n最终的生成概率是所有以J片段结束并完成完整序列$s$的情景的概率之和。\n$$ P_{\\text{gen}}(s) = \\sum_{l=0}^{L} F_{VN1DN2}[l] \\cdot P_J(s[l:L]) $$\n\n在陈述DP递推关系之前，我们必须根据给定的模型参数预计算基本事件的概率。\n\n**模型参数预计算：**\n设$\\rho_V = 0.4$，$\\rho_J = 0.4$，$\\rho_{D5}=0.5$，$\\rho_{D3}=0.5$，以及$\\lambda=0.5$。\nV/J基因的长度为$\\ell_V = \\ell_J = 3$。D基因的长度为$\\ell_D = 2$。\n\n*   **V/J删除概率**：$P(d | G) = \\frac{\\rho_G^d}{Z_G}$，对于$d \\in \\{0, \\dots, \\ell_G\\}$。\n    V和J删除的归一化常数为$Z_{V/J} = \\sum_{d=0}^{3} (0.4)^d = 1 + 0.4 + 0.16 + 0.064 = 1.624$。\n*   **D删除概率**：$P(d_{D5}, d_{D3} | D) = \\frac{\\rho_{D5}^{d_{D5}} \\rho_{D3}^{d_{D3}}}{Z_D}$，对于$d_{D5}+d_{D3} \\le \\ell_D = 2$。\n    归一化常数为$Z_D = \\sum_{d_{D5}+d_{D3} \\le 2} (0.5)^{d_{D5}} (0.5)^{d_{D3}} = \\sum_{k=0}^{2} (k+1)(0.5)^k = 1 \\cdot 1 + 2 \\cdot 0.5 + 3 \\cdot 0.25 = 1 + 1 + 0.75 = 2.75$。\n*   **插入概率**：插入一个长度为$n$的特定核苷酸序列的概率为$P_{\\text{ins\\_seq}}(n) = P(\\text{length}=n) \\cdot P(\\text{sequence}|\\text{length}=n) = \\left((1-\\lambda)\\lambda^n\\right) \\cdot (0.25)^n = (1-\\lambda)(\\lambda/4)^n = 0.5 \\cdot (0.125)^n$。我们预计算一个数组$P_{\\text{ins}}[n] = 0.5 \\cdot (0.125)^n$。\n\n**匹配概率预计算：**\n对于一个给定的长度为$L$的序列$s$，我们预计算其子串匹配基因片段的概率表。\n*   **V匹配表$P_V^{\\text{match}}[i]$**：$s[0:i]$是一个有效的V前缀的概率，对所有V基因求和。对于每个V基因，如果其长度为$i$的前缀等于$s[0:i]$，则发生匹配。此时删除的核苷酸数量固定为$d_V = \\ell_V - i$。\n*   **D匹配表$P_D^{\\text{match}}[j][k]$**：$s[j:k]$是一个有效的D子串的概率，对所有D基因和所有能产生子串$s[j:k]$的有效删除对$(d_{D5}, d_{D3})$求和。\n*   **J匹配表$P_J^{\\text{match}}[l]$**：$s[l:L]$是一个有效的J后缀的概率，对所有J基因求和。对于每个J基因，如果其长度为$L-l$的后缀等于$s[l:L]$，则发生匹配。此时删除的核苷酸数量固定为$d_J = \\ell_J - (L-l)$。\n\n**动态规划递推关系：**\n1.  **V片段贡献**：初始DP数组就是V匹配表本身。\n    $$ F_V[i] = P_V^{\\text{match}}[i] \\quad \\text{for } i \\in [0, L] $$\n\n2.  **N1插入贡献**：我们将$F_V$与插入概率分布进行卷积。\n    $$ F_{VN1}[j] = \\sum_{i=0}^{j} F_V[i] \\cdot P_{\\text{ins}}[j-i] \\quad \\text{for } j \\in [0, L] $$\n\n3.  **D片段贡献**：我们对D片段所有可能的起始位置$j$进行求和。\n    $$ F_{VN1D}[k] = \\sum_{j=0}^{k} F_{VN1}[j] \\cdot P_D^{\\text{match}}[j][k] \\quad \\text{for } k \\in [0, L] $$\n\n4.  **N2插入贡献**：我们执行第二次卷积。\n    $$ F_{VN1DN2}[l] = \\sum_{k=0}^{l} F_{VN1D}[k] \\cdot P_{\\text{ins}}[l-k] \\quad \\text{for } l \\in [0, L] $$\n\n5.  **J片段和最终概率**：我们对J片段所有可能的起始位置$l$进行求和。\n    $$ P_{\\text{gen}}(s) = \\sum_{l=0}^{L} F_{VN1DN2}[l] \\cdot P_J^{\\text{match}}[l] $$\n\n这个DP公式正确且高效地对所有有效情景进行了求和。卷积可以使用`numpy.convolve`实现，而D和J贡献的求和可以表示为矩阵-向量乘积，从而得到一个简洁高效的实现。空序列（$L=0$）的特殊情况在此框架下也能正确处理，此时所有索引均为0。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the VDJ generation probability problem for the given test cases.\n    \"\"\"\n    \n    # Model parameters as specified in the problem statement\n    model_params = {\n        'v_genes': {'V1': 'ATG', 'V2': 'ACG'},\n        'd_genes': {'D1': 'GG', 'D2': 'GA'},\n        'j_genes': {'J1': 'TAC', 'J2': 'CAC'},\n        'p_v': {'V1': 0.5, 'V2': 0.5},\n        'p_d': {'D1': 0.5, 'D2': 0.5},\n        'p_j': {'J1': 0.5, 'J2': 0.5},\n        'rho_v': 0.4,\n        'rho_j': 0.4,\n        'rho_d5': 0.5,\n        'rho_d3': 0.5,\n        'lambda_ins': 0.5,\n        'p_base': 0.25,\n    }\n\n    def _precompute_deletion_probs(params):\n        \"\"\"Precomputes deletion probability distributions.\"\"\"\n        \n        # V deletions\n        rho_v, ell_v = params['rho_v'], len(params['v_genes']['V1'])\n        z_v = sum(rho_v**d for d in range(ell_v + 1))\n        p_v_del = {d: rho_v**d / z_v for d in range(ell_v + 1)}\n        \n        # J deletions\n        rho_j, ell_j = params['rho_j'], len(params['j_genes']['J1'])\n        z_j = sum(rho_j**d for d in range(ell_j + 1))\n        p_j_del = {d: rho_j**d / z_j for d in range(ell_j + 1)}\n\n        # D deletions\n        rho_d5, rho_d3 = params['rho_d5'], params['rho_d3']\n        ell_d = len(params['d_genes']['D1'])\n        p_d_del_unnorm = {}\n        z_d = 0.0\n        for d5 in range(ell_d + 1):\n            for d3 in range(ell_d + 1):\n                if d5 + d3 = ell_d:\n                    prob = rho_d5**d5 * rho_d3**d3\n                    p_d_del_unnorm[(d5, d3)] = prob\n                    z_d += prob\n        p_d_del = {k: v / z_d for k, v in p_d_del_unnorm.items()}\n        \n        params['p_v_del'] = p_v_del\n        params['p_j_del'] = p_j_del\n        params['p_d_del'] = p_d_del\n        \n        # Precompute D substring probabilities\n        d_substring_probs = {}\n        for name, seq in params['d_genes'].items():\n            ell_d = len(seq)\n            for (d5, d3), prob in p_d_del.items():\n                if d5 + d3 = ell_d:\n                    sub = seq[d5 : ell_d - d3]\n                    # Total probability of a substring from ANY D gene\n                    # P(sub) = sum_D P(D) * P(sub|D)\n                    # Here we calculate P(D)*P(sub|D) and add it up\n                    term_prob = params['p_d'][name] * prob\n                    d_substring_probs[sub] = d_substring_probs.get(sub, 0.0) + term_prob\n        params['d_substring_probs'] = d_substring_probs\n\n    _precompute_deletion_probs(model_params)\n\n    def calculate_pgen(s: str, params: dict) -> float:\n        \"\"\"\n        Calculates the generation probability of a sequence s using dynamic programming.\n        \"\"\"\n        L = len(s)\n\n        # 1. Precompute match tables and insertion probabilities\n        \n        # V-match probability table: P_V_match[i] = P(s[0:i] from V)\n        p_v_match = np.zeros(L + 1)\n        for name, seq in params['v_genes'].items():\n            ell_v = len(seq)\n            for i in range(min(L, ell_v) + 1):\n                d_v = ell_v - i\n                if seq.startswith(s[:i]):\n                    p_v_match[i] += params['p_v'][name] * params['p_v_del'][d_v]\n\n        # D-match probability table: P_D_match[j, k] = P(s[j:k] from D)\n        p_d_match = np.zeros((L + 1, L + 1))\n        d_substring_probs = params['d_substring_probs']\n        for j in range(L + 1):\n            for k in range(j, L + 1):\n                sub = s[j:k]\n                if sub in d_substring_probs:\n                    p_d_match[j, k] = d_substring_probs[sub]\n        \n        # J-match probability table: P_J_match[l] = P(s[l:L] from J)\n        p_j_match = np.zeros(L + 1)\n        for name, seq in params['j_genes'].items():\n            ell_j = len(seq)\n            for l in range(L + 1):\n                suffix_len = L - l\n                if suffix_len = ell_j:\n                    d_j = ell_j - suffix_len\n                    if seq.endswith(s[l:]):\n                        p_j_match[l] += params['p_j'][name] * params['p_j_del'][d_j]\n        \n        # Insertion probability array: P_ins[n] = P(specific sequence of length n)\n        p_ins = np.zeros(L + 1)\n        lambda_ins, p_base = params['lambda_ins'], params['p_base']\n        for n in range(L + 1):\n            p_ins[n] = (1.0 - lambda_ins) * (lambda_ins * p_base)**n\n\n        # 2. Dynamic Programming steps\n        \n        # F_V[i]: P(s[0:i] from V)\n        f_v = p_v_match\n        \n        # F_VN1[j]: P(s[0:j] from V-N1)\n        f_vn1 = np.convolve(f_v, p_ins)[:L + 1]\n        \n        # F_VN1D[k]: P(s[0:k] from V-N1-D)\n        # This is equivalent to a matrix-vector product: f_vn1 @ p_d_match\n        f_vn1d = np.zeros(L + 1)\n        for k in range(L + 1):\n            for j in range(k + 1):\n                f_vn1d[k] += f_vn1[j] * p_d_match[j, k]\n                \n        # F_VN1DN2[l]: P(s[0:l] from V-N1-D-N2)\n        f_vn1dn2 = np.convolve(f_vn1d, p_ins)[:L + 1]\n\n        # Final probability: sum over all final J contributions\n        # This is an inner product: f_vn1dn2 @ p_j_match\n        p_gen = np.dot(f_vn1dn2, p_j_match)\n        \n        return p_gen\n\n    test_cases = [\n        \"ACGGT\",\n        \"ATGGGAT\",\n        \"\",\n        \"G\"\n    ]\n\n    results = []\n    for s in test_cases:\n        result = calculate_pgen(s, model_params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2886872"}]}