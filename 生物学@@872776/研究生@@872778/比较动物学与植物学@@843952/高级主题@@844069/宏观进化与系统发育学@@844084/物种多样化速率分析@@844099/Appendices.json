{"hands_on_practices": [{"introduction": "本章的第一个练习旨在为所有生死模型奠定数学基础。通过从第一性原理出发，推导下一次物种形成事件的预期等待时间 [@problem_id:2567064]，您将巩固对“恒定的每世系速率 $\\lambda$ 如何转化为事件间时间的指数分布”这一核心概念的理解。这是随机过程建模中的一个基石。", "problem": "在比较动物学和比较植物学中，通常使用纯生过程（Yule过程）来模拟分支的多样化。在该过程中，每个现存谱系都以一个随时间恒定的单位谱系速率 $\\lambda$ 独立地产生新谱系（即发生一次物种形成事件）。考虑一个在当前观察到的目标现存谱系。假设该过程满足以下基本性质，这些性质在谱系层面上操作性地定义了Yule过程：在无穷小时间区间 $[t,t+\\mathrm{d}t)$ 内，若已知直到时间 $t$ 该目标谱系上都未发生过物种形成，则在该区间 $[t,t+\\mathrm{d}t)$ 内发生一次物种形成事件的概率为 $\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)$；在该区间内发生一次以上事件的概率为 $o(\\mathrm{d}t)$；且该过程没有超出当前状态的记忆。\n\n设 $T$ 表示从现在到目标谱系上发生下一次物种形成事件的等待时间。请仅从上述无穷小速率的刻画以及Yule过程所蕴含的增量独立性出发，推导出期望值 $\\mathbb{E}[T]$。\n\n请以仅含 $\\lambda$ 的单个闭式解析表达式给出你的最终结果。最终的方框答案中不要包含单位。如果找到多种等价形式，请选择其中一种并只呈现该形式。", "solution": "本问题要求基于Yule过程的基本性质，推导单个目标谱系上发生下一次物种形成事件的期望等待时间 $\\mathbb{E}[T]$。推导必须从第一性原理出发，使用所提供的无穷小速率刻画。\n\n设 $T$ 为代表从现在（$t=0$）到下一次物种形成事件发生为止的等待时间的随机变量。我们旨在求出 $T$ 的期望值，记为 $\\mathbb{E}[T]$。问题的核心在于首先推导出 $T$ 的概率分布。\n\n设 $S(t) = \\mathbb{P}(T  t)$ 为 $T$ 的生存函数。该函数给出了到时间 $t$ 为止物种形成事件尚未发生的概率。根据定义，$S(0) = \\mathbb{P}(T  0) = 1$，因为等待时间必须为正。\n\n问题陈述中给出了在直到时间 $t$ 都没有事件发生的条件下，在无穷小时间区间 $[t, t+\\mathrm{d}t)$ 内发生一次物种形成事件的条件概率。这正是风险率 $h(t)$ 的定义。用数学语言表达为：\n$$\nh(t) = \\lim_{\\mathrm{d}t \\to 0} \\frac{\\mathbb{P}(t   T \\leq t+\\mathrm{d}t | T  t)}{\\mathrm{d}t}\n$$\n根据问题陈述，该条件概率为 $\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)$。因此，风险率为：\n$$\nh(t) = \\lim_{\\mathrm{d}t \\to 0} \\frac{\\lambda\\,\\mathrm{d}t + o(\\mathrm{d}t)}{\\mathrm{d}t} = \\lambda\n$$\n速率 $\\lambda$ 是恒定的，这是该过程的一个关键性质，表明其是无记忆的。\n\n风险率 $h(t)$ 与生存函数 $S(t)$ 和概率密度函数 $f(t) = -S'(t)$ 有着根本的联系。条件概率可以表示为：\n$$\n\\mathbb{P}(t   T \\leq t+\\mathrm{d}t | T  t) = \\frac{\\mathbb{P}((t   T \\leq t+\\mathrm{d}t) \\cap (T  t))}{\\mathbb{P}(T  t)} = \\frac{\\mathbb{P}(t   T \\leq t+\\mathrm{d}t)}{\\mathbb{P}(T  t)}\n$$\n对于一个无穷小区间 $\\mathrm{d}t$，概率 $\\mathbb{P}(t   T \\leq t+\\mathrm{d}t)$ 近似等于 $f(t)\\,\\mathrm{d}t$。因此，\n$$\nh(t) = \\frac{f(t)}{S(t)}\n$$\n由于 $f(t) = -\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t}$，我们可以写出：\n$$\nh(t) = -\\frac{1}{S(t)}\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = -\\frac{\\mathrm{d}}{\\mathrm{d}t} \\ln(S(t))\n$$\n我们已经确定 $h(t) = \\lambda$。将此代入方程，得到一个关于 $S(t)$ 的一阶常微分方程：\n$$\n-\\frac{1}{S(t)}\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t} = \\lambda\n$$\n整理各项得：\n$$\n\\frac{\\mathrm{d}S(t)}{S(t)} = -\\lambda\\,\\mathrm{d}t\n$$\n为了求出 $S(t)$，我们对该方程两边从时间 $0$ 到一个通用时间 $t$ 进行积分：\n$$\n\\int_{S(0)}^{S(t)} \\frac{1}{S} \\, \\mathrm{d}S = \\int_0^t -\\lambda \\, \\mathrm{d}\\tau\n$$\n左边的积分是 $\\ln(S(t)) - \\ln(S(0))$，右边的积分是 $-\\lambda t$。\n$$\n\\ln(S(t)) - \\ln(S(0)) = -\\lambda t\n$$\n使用初始条件 $S(0)=1$，我们有 $\\ln(1)=0$。因此：\n$$\n\\ln(S(t)) = -\\lambda t\n$$\n对两边取指数，得到生存函数：\n$$\nS(t) = \\exp(-\\lambda t)\n$$\n这是一个速率参数为 $\\lambda$ 的指数分布的生存函数。\n\n现在，我们可以计算期望值 $\\mathbb{E}[T]$。对于像等待时间 $T$ 这样的非负随机变量，其期望值可以通过对其生存函数在其支撑集（从 $0$ 到 $\\infty$）上进行积分来计算：\n$$\n\\mathbb{E}[T] = \\int_0^\\infty S(t) \\, \\mathrm{d}t\n$$\n代入推导出的生存函数 $S(t) = \\exp(-\\lambda t)$：\n$$\n\\mathbb{E}[T] = \\int_0^\\infty \\exp(-\\lambda t) \\, \\mathrm{d}t\n$$\n这是一个标准积分。计算过程如下：\n$$\n\\mathbb{E}[T] = \\left[ -\\frac{1}{\\lambda} \\exp(-\\lambda t) \\right]_0^\\infty\n$$\n在积分上下限处对表达式求值：\n$$\n\\mathbb{E}[T] = \\lim_{t \\to \\infty} \\left(-\\frac{1}{\\lambda} \\exp(-\\lambda t)\\right) - \\left(-\\frac{1}{\\lambda} \\exp(-\\lambda \\cdot 0)\\right)\n$$\n由于 $\\lambda$ 是一个速率，它必须是正的（$\\lambda  0$）。当 $t \\to \\infty$ 时，项 $\\exp(-\\lambda t)$ 趋近于 $0$。第二项计算结果为 $-\\frac{1}{\\lambda} \\exp(0) = -\\frac{1}{\\lambda}$。\n$$\n\\mathbb{E}[T] = (0) - \\left(-\\frac{1}{\\lambda}\\right) = \\frac{1}{\\lambda}\n$$\n因此，到目标谱系上发生下一次物种形成事件的期望等待时间是物种形成速率 $\\lambda$ 的倒数。这个结果与指数分布的一般性质相符，而在这里我们是根据所提供的无穷小刻画严格推导出来的。", "answer": "$$\\boxed{\\frac{1}{\\lambda}}$$", "id": "2567064"}, {"introduction": "在对事件时间有了理论理解之后，这个实践将带您进入模拟领域。您将实现著名的Gillespie算法来生成随机的生死树 [@problem_id:2566990]，从而直观地感受物种形成 ($\\lambda$) 和灭绝 ($\\mu$) 的简单规则如何产生自然界中观察到的复杂多样的系统发育模式。这项练习对于培养对多样化过程随机性的直觉至关重要。", "problem": "您将使用随机模拟算法（Stochastic Simulation Algorithm, SSA，也称 Gillespie 算法）实现一个连续时间马尔可夫链（Continuous-Time Markov Chain, CTMC）的生灭多样化模拟器，以生成用于比较动物学和植物学的生灭树。在此背景下，谱系以每个谱系 $ \\lambda $ 的速率分化（出生），并以每个谱系 $ \\mu $ 的速率灭绝（死亡）。状态变量是在时间 $ t $ 存活的谱系数量 $ n(t) $。推导的基础是标准的 CTMC 框架，该框架用于描述独立的泊松过程控制下的竞争指数时钟，结合了指数分布的无记忆性以及独立泊松过程的叠加特性：当存在 $ n $ 个独立的、相同的指数时钟，每个谱系的出生率为 $ \\lambda $，死亡率为 $ \\mu $ 时，到下一个事件发生的时间呈指数分布，其总风险率等于所有活跃风险率之和，而下一个事件的类型则根据其对总风险率的贡献成比例地选择。\n\n您的任务是根据这些原理推导出事件调度方法，并实现一个 SSA，该算法：\n- 在时间 $ t = 0 $ 时，以 $ n_0 $ 个谱系进行初始化。\n- 在任何时刻，当存在 $ n $ 个存活谱系时，仅根据 $ \\lambda $、$ \\mu $ 和 $ n $ 来调度下一个事件的时间和类型。\n- 对于出生事件，将 $ n $ 更新为 $ +1 $；对于死亡事件，更新为 $ -1 $，并相应地更新当前时间。\n- 持续运行，直到满足某个停止准则。\n\n您的停止准则必须是以下条件的逻辑析取：\n- 时间超过最大范围 $ T_{\\max} $。\n- 所有谱系均灭绝，即在某个时刻 $ n = 0 $。\n- 达到了为保证计算可处理性而设置的安全上限，即 $ n \\ge N_{\\max} $，其中 $ N_{\\max} $ 是用户指定的存活谱系数量上限，以防止在超临界状态下发生爆炸性增长。\n\n请将所有谱系视为可交换的，并且其事件风险率是独立同分布的，除了上述停止准则外，不要对存活施加条件或任何额外的约束。\n\n您需要编写一个程序，对于每个测试用例，使用固定的伪随机种子运行一次随机模拟，并返回一个概括结果的整数三元组：\n- 终止时的存活谱系数量 $ n_{\\text{final}} $。\n- 发生的出生事件总数 $ B $。\n- 发生的死亡事件总数 $ D $。\n\n事件时间使用任意时间单位；您的输出是无量纲的计数。输出中不要包含任何物理单位。\n\n从第一性原理出发，推导：\n- 如何根据 $ n $、$ \\lambda $ 和 $ \\mu $ 调度事件之间的等待时间。\n- 如何选择事件类型和受影响的谱系（考虑到可交换性）。\n- 为什么上述停止准则即使在超临界状态下也能确保模拟的良定义性。\n\n然后实现该算法，并在一系列参数集上运行它。每个测试用例是一个元组 $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) $：\n- 案例 A (一般超临界): $ (0.4, 0.2, 5.0, 1, 2000, 42) $。\n- 案例 B (纯出生或 Yule 极限): $ (1.0, 0.0, 1.0, 1, 2000, 7) $。\n- 案例 C (纯死亡): $ (0.0, 0.5, 3.0, 3, 2000, 123) $。\n- 案例 D (超临界且达到上限): $ (2.0, 0.1, 10.0, 1, 50, 1) $。\n- 案例 E (空动态): $ (0.0, 0.0, 2.0, 5, 100, 99) $。\n\n对于每个案例，使用给定的种子精确地运行一次模拟复制，并输出一行，该行包含一个逗号分隔的列表，列表被方括号括起来，其中每个元素本身是该案例的列表 $ [n_{\\text{final}},B,D] $，顺序与上述指定相同。该行中不得有任何空格。例如，格式必须完全像这样：\n[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]\n\n您的程序相对于所提供的种子必须是完全确定性的，并且不得需要任何用户输入或外部文件。", "solution": "我们将谱系多样化建模为一个连续时间马尔可夫链（CTMC），其中每个谱系具有独立同分布的出生和死亡风险率。在任意时间 $ t $，如果存在 $ n(t) = n $ 个存活谱系，每个谱系贡献两种可能的事件通道：以每个谱系速率 $ \\lambda $ 发生的出生事件，和以每个谱系速率 $ \\mu $ 发生的死亡事件。因此，系统有 $ n $ 个独立的、同分布的潜在出生事件和 $ n $ 个独立的、同分布的潜在死亡事件。\n\n基本原理：\n- 独立的泊松过程和无记忆性意味着，如果 $ X_1, \\dots, X_k $ 是速率分别为 $ r_1, \\dots, r_k $ 的独立指数随机变量，那么 $ \\min(X_1,\\dots,X_k) $ 服从速率为 $ r_1 + \\dots + r_k $ 的指数分布，并且最小值对应于过程 $ i $ 的概率等于 $ r_i / (r_1 + \\dots + r_k) $。这是泊松过程的叠加特性，也是随机模拟算法（SSA）的基础。\n- CTMC 跳转链的演化方式是：选择下一个事件时间，该时间是一个指数等待时间，其参数等于从当前状态离开的总速率；然后根据相对速率选择事件类型。\n\n事件调度推导：\n- 当有 $ n $ 个存活谱系时，存在 $ n $ 个出生通道（每个速率为 $ \\lambda $）和 $ n $ 个死亡通道（每个速率为 $ \\mu $）。因此，总速率为\n$$ R(n) = n \\lambda + n \\mu = n (\\lambda + \\mu). $$\n- 到下一个事件的等待时间 $ \\Delta t $ 服从速率为 $ R(n) $ 的指数分布，即 $ \\Delta t \\sim \\text{Exponential}(R(n)) $。\n- 在事件发生的条件下，该事件是出生事件的概率为总出生速率除以总速率，\n$$ \\mathbb{P}(\\text{birth} \\mid n) = \\frac{n \\lambda}{n (\\lambda + \\mu)} = \\frac{\\lambda}{\\lambda + \\mu}, $$\n该事件是死亡事件的概率为\n$$ \\mathbb{P}(\\text{death} \\mid n) = \\frac{n \\mu}{n (\\lambda + \\mu)} = \\frac{\\mu}{\\lambda + \\mu}. $$\n- 谱系间的可交换性意味着，在给定事件类型的情况下，受影响的谱系是在 $ n $ 个存活谱系中均匀随机选择的，因为它们对风险率的贡献是相同的。\n\n算法设计（随机模拟算法）：\n- 初始化时间 $ t \\leftarrow 0 $，存活谱系数量 $ n \\leftarrow n_0 $，以及出生和死亡计数器 $ B \\leftarrow 0 $ 和 $ D \\leftarrow 0 $。可以维护一个存活谱系标识符的列表，但由于所有谱系都是可交换的，且输出只需要计数，因此只跟踪 $ n $ 就足够了；不过，我们也可以维护显式标识符以使谱系选择更加明确。\n- 当所有停止准则都不成立时，计算总速率 $ R(n) = n (\\lambda + \\mu) $。\n    - 如果 $ R(n) = 0 $（例如，$ \\lambda = 0 $ 和 $ \\mu = 0 $，或者 $ n = 0 $），则不会再有事件发生；终止模拟。\n    - 从速率为 $ R(n) $ 的指数分布中采样一个等待时间 $ \\Delta t $。如果 $ t + \\Delta t  T_{\\max} $，则下一个事件将发生在时间范围之外；终止模拟，不应用该事件。\n    - 否则，设置 $ t \\leftarrow t + \\Delta t $，然后选择事件类型：采样一个均匀分布的随机变量 $ U \\in (0,1) $。如果 $ U  \\lambda / (\\lambda + \\mu) $，则将事件视为出生；否则视为死亡。\n    - 对于出生事件，增加 $ B \\leftarrow B + 1 $ 和 $ n \\leftarrow n + 1 $。\n    - 对于死亡事件，增加 $ D \\leftarrow D + 1 $ 和 $ n \\leftarrow n - 1 $。\n- 每个事件之后，检查停止准则：如果 $ n = 0 $，因灭绝而终止；如果 $ n \\ge N_{\\max} $，因达到安全上限而终止；如果 $ t \\ge T_{\\max} $，因达到时间限制而终止。由于我们在应用事件之前检查 $ t + \\Delta t $，当没有更多事件能在时间范围内发生时，$ t \\ge T_{\\max} $ 的条件会自然满足。\n\n为什么这些停止准则能确保模拟的良定义性：\n- 如果 $ \\lambda \\le \\mu $，过程平均上是临界或亚临界的，不会在有限时间内爆炸；时间范围 $ T_{\\max} $ 和滅绝边界 $ n = 0 $ 就足够了。\n- 如果 $ \\lambda  \\mu $，过程是超临界的，并且可以快速增长；通过 $ N_{\\max} $ 限制 $ n $ 可以保证算法在有限步数内终止，即使时间范围非常大。这起到一种截断作用，在达到上限之前保持了统计上的一致性。\n\n边界情况：\n- 如果 $ \\lambda = 0 $ 且 $ \\mu  0 $，过程是纯死亡过程；如果从 $ n_0  0 $ 开始，算法最终会达到 $ n = 0 $ 或达到 $ T_{\\max} $。\n- 如果 $ \\lambda  0 $ 且 $ \\mu = 0 $，过程是纯出生过程（Yule过程）；增长可能很快，因此 $ N_{\\max} $ 可以防止计算爆炸。\n- 如果 $ \\lambda = 0 $ 且 $ \\mu = 0 $，那么对于任何 $ n $，$ R(n) = 0 $，所以没有事件可以发生；状态保持为 $ n = n_0 $ 直到 $ T_{\\max} $；算法会检测到 $ R(n) = 0 $ 并立即终止。\n\n测试套件和输出：\n- 对于每个案例，我们使用固定的伪随机种子，以确保模拟是可复现的。程序输出一行，不含空格，其中包含五个案例的结果列表，顺序如前所述，每个结果是一个整数列表 $ [n_{\\text{final}}, B, D] $。这些案例是：\n    - 案例 A: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.4, 0.2, 5.0, 1, 2000, 42) $。\n    - 案例 B: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (1.0, 0.0, 1.0, 1, 2000, 7) $。\n    - 案例 C: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.0, 0.5, 3.0, 3, 2000, 123) $。\n    - 案例 D: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (2.0, 0.1, 10.0, 1, 50, 1) $。\n    - 案例 E: $ (\\lambda,\\mu,T_{\\max},n_0,N_{\\max},\\text{seed}) = (0.0, 0.0, 2.0, 5, 100, 99) $。\n\n计算考量：\n- 每个事件需要 $ \\mathcal{O}(1) $ 的工作量。在达到 $ T_{\\max} $ 之前的事件数量是随机的，但在上限 $ N_{\\max} $ 和有限的 $ T_{\\max} $ 下，几乎必然是有限的。\n- 使用高质量的伪随机数生成器和固定的种子可以确保可复现性。\n\n该实现严格遵循这些步骤，并遵守指定的无空格输出格式，以进行确定性评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_birth_death(lambda_rate, mu_rate, T_max, n0, N_max, seed):\n    \"\"\"\n    Simulate a birth-death process using a Gillespie-style SSA.\n\n    Parameters:\n        lambda_rate (float): per-lineage birth rate (lambda)\n        mu_rate (float): per-lineage death rate (mu)\n        T_max (float): time horizon\n        n0 (int): initial number of lineages\n        N_max (int): safety cap for maximum number of extant lineages\n        seed (int): random seed for reproducibility\n\n    Returns:\n        (n_final, births, deaths): tuple of integers\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    t = 0.0\n    n = int(n0)\n    births = 0\n    deaths = 0\n\n    # Main SSA loop\n    while True:\n        # Check stopping criteria at loop top to handle initial conditions like n0==0\n        if n == 0:\n            break\n        if n = N_max:\n            break\n        if t = T_max:\n            break\n\n        total_rate = n * (lambda_rate + mu_rate)\n\n        # If no events can occur, terminate.\n        if total_rate == 0.0:\n            break\n\n        # Sample waiting time to next event\n        dt = rng.exponential(1.0 / total_rate)\n\n        # If next event occurs beyond T_max, stop without applying it\n        if t + dt  T_max:\n            break\n\n        # Advance time\n        t += dt\n\n        # Decide event type: birth with probability lambda/(lambda+mu)\n        if (lambda_rate + mu_rate)  0.0:\n            p_birth = lambda_rate / (lambda_rate + mu_rate)\n        else:\n            p_birth = 0.0  # Should not happen because total_rate > 0 implies lambda+mu>0\n\n        if rng.random()  p_birth:\n            # Birth event: choose affected lineage uniformly (exchangeable)\n            # Since all lineages are identical and only counts are needed, we do not need explicit IDs.\n            births += 1\n            n += 1\n        else:\n            # Death event\n            deaths += 1\n            n -= 1\n\n        # Loop continues; stopping criteria are checked at top.\n\n    n_final = n\n    return int(n_final), int(births), int(deaths)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (lambda, mu, T_max, n0, N_max, seed)\n    test_cases = [\n        (0.4, 0.2, 5.0, 1, 2000, 42),   # Case A: general supercritical\n        (1.0, 0.0, 1.0, 1, 2000, 7),    # Case B: pure birth (Yule)\n        (0.0, 0.5, 3.0, 3, 2000, 123),  # Case C: pure death\n        (2.0, 0.1, 10.0, 1, 50, 1),     # Case D: supercritical with cap\n        (0.0, 0.0, 2.0, 5, 100, 99),    # Case E: null dynamics\n    ]\n\n    results = []\n    for params in test_cases:\n        lam, mu, Tmax, n0, Nmax, seed = params\n        n_final, births, deaths = simulate_birth_death(lam, mu, Tmax, n0, Nmax, seed)\n        results.append([n_final, births, deaths])\n\n    # Format output with no spaces as required: [[a,b,c],[d,e,f],...]\n    inner = \",\".join(\"[\" + \",\".join(map(str, res)) + \"]\" for res in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2566990"}, {"introduction": "在理解了树生成的正向过程之后，我们现在来解决其逆问题：统计推断。给定从重建的系统发育中获得的等待时间数据，本练习将指导您推导纯生过程（Yule过程）中物种形成速率 $\\lambda$ 的最大似然估计量（MLE） [@problem_id:2567022]。这是一项将理论模型与经验数据分析联系起来的基本技能，使我们能够估计驱动多样化的关键参数。", "problem": "一个支系在纯出生尤尔（Yule）过程下演化，其谱系物种形成率为 $\\lambda$。这是比较动物学和植物学中多样化速率分析的一个标准模型。该过程从时间 $0$ 时仅有 $1$ 个谱系开始，一直观察到谱系数量首次达到 $n$ 为止。设 $w_1, w_2, \\dots, w_{n-1}$ 表示使谱系数量从 $1$ 增长到 $n$ 的连续分支事件之间的等待时间。在此模型下，当有 $k$ 个谱系时，每个谱系都以速率 $\\lambda$ 独立地产生一个新谱系，因此总事件速率为 $k \\lambda$，并且到下一个事件的等待时间呈指数分布。指数分布的无记忆性和谱系的独立性意味着事件间的等待时间是相互独立的。\n\n基于关于泊松（Poisson）过程和指数等待时间的这些基本事实，并且不假设任何预先推导出的估计量，请完成以下任务：\n\n- 将观察到的等待时间 $w_1, \\dots, w_{n-1}$ 的联合概率密度写成 $\\lambda$ 的函数。\n- 使用因子分解定理，根据 $w_1, \\dots, w_{n-1}$ 识别出 $\\lambda$ 的一个充分统计量。\n- 使用该充分统计量推导 $\\lambda$ 的最大似然估计量（MLE），并用 $n$ 和 $w_i$ 以闭合形式表示。\n\n将你的最终答案表示为 MLE $\\hat{\\lambda}$ 的单个闭合形式表达式。无需进行数值计算或提供单位。", "solution": "本题要求基于连续物种形成事件之间的观察等待时间，在纯出生尤尔（Yule）过程中推导每谱系物种形成率 $\\lambda$ 的最大似然估计量 (MLE)。推导必须从第一性原理出发。\n\n该过程从时间 $t=0$ 时的 $1$ 个谱系开始，一直观察到有 $n$ 个谱系为止。第 $i$ 个和第 $i+1$ 个物种形成事件之间的等待时间记为 $w_i$，其中 $i = 1, 2, \\dots, n-1$。\n\n首先，我们确定每个等待时间 $w_i$ 的概率分布。题目说明，当有 $k$ 个谱系时，新物种形成事件的总速率为 $k\\lambda$。到下一个事件的等待时间以该速率呈指数分布。等待时间 $w_i$ 对应于谱系数量从 $i$ 增长到 $i+1$ 的时间区间。在此区间内，恰好有 $i$ 个谱系。因此，该区间内物种形成的总速率为 $i\\lambda$。\n因此，等待时间 $w_i$ 是一个从速率参数为 $i\\lambda$ 的指数分布中抽取的随机变量。$w_i$ 的概率密度函数 (PDF) 由下式给出：\n$$f_{w_i}(w_i; \\lambda) = (i\\lambda) \\exp(-i\\lambda w_i), \\quad \\text{for } w_i \\geq 0$$\n这对 $i = 1, 2, \\dots, n-1$ 成立。\n\n题目说明等待时间 $w_1, w_2, \\dots, w_{n-1}$ 是独立的。这些等待时间的联合概率密度函数是它们各自 PDF 的乘积。该联合 PDF 也是 $\\lambda$ 的似然函数，我们将其记为 $L(\\lambda; w_1, \\dots, w_{n-1})$。\n\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = \\prod_{i=1}^{n-1} f_{w_i}(w_i; \\lambda) = \\prod_{i=1}^{n-1} (i\\lambda) \\exp(-i\\lambda w_i)$$\n我们可以将包含 $\\lambda$ 的项与其他项分开：\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = \\left(\\prod_{i=1}^{n-1} i\\right) \\left(\\prod_{i=1}^{n-1} \\lambda\\right) \\left(\\prod_{i=1}^{n-1} \\exp(-i\\lambda w_i)\\right)$$\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = (n-1)! \\lambda^{n-1} \\exp\\left(-\\sum_{i=1}^{n-1} i\\lambda w_i\\right)$$\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = (n-1)! \\lambda^{n-1} \\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right)$$\n这就是观察到的等待时间的联合概率密度。\n\n接下来，我们使用奈曼-费雪（Neyman-Fisher）因子分解定理来识别 $\\lambda$ 的一个充分统计量。该定理指出，如果似然函数 $L(\\theta; W)$ 可以分解为两个函数的乘积：$L(\\theta; W) = g(T(W), \\theta) h(W)$，其中 $g$ 对数据 $W = (w_1, \\dots, w_{n-1})$ 的依赖仅通过统计量 $T(W)$，而 $h$ 不依赖于参数 $\\theta$，那么统计量 $T(W)$ 就是参数 $\\theta$ 的充分统计量。\n\n根据我们的似然函数：\n$$L(\\lambda; w_1, \\dots, w_{n-1}) = \\underbrace{\\left( \\lambda^{n-1} \\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right) \\right)}_{g(T(W), \\lambda)} \\underbrace{\\left( (n-1)! \\right)}_{h(W)}$$\n通过设定统计量 $T(W) = \\sum_{i=1}^{n-1} i w_i$，我们可以看到因子分解成立。函数 $h(W)$ 是一个常数 $(n-1)!$，而函数 $g$ 对数据的依赖仅通过 $T(W)$。因此，$T(W) = \\sum_{i=1}^{n-1} i w_i$ 是 $\\lambda$ 的一个充分统计量。该统计量表示直到第 $n$ 个谱系出现时所有谱系存活的总时间，这也被称为系统发育树的总长度。\n\n最后，我们推导 $\\lambda$ 的最大似然估计量 (MLE)，记为 $\\hat{\\lambda}$。MLE 是使似然函数 $L(\\lambda)$ 最大化的 $\\lambda$ 值。由于对数是严格递增函数，计算上最大化似然函数的自然对数，即对数似然 $\\ell(\\lambda)$，会更简单。\n$$\\ell(\\lambda) = \\ln(L(\\lambda; w_1, \\dots, w_{n-1})) = \\ln\\left((n-1)! \\lambda^{n-1} \\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right)\\right)$$\n$$\\ell(\\lambda) = \\ln((n-1)!) + \\ln(\\lambda^{n-1}) + \\ln\\left(\\exp\\left(-\\lambda \\sum_{i=1}^{n-1} i w_i\\right)\\right)$$\n$$\\ell(\\lambda) = \\ln((n-1)!) + (n-1)\\ln(\\lambda) - \\lambda \\sum_{i=1}^{n-1} i w_i$$\n为了找到最大值，我们计算 $\\ell(\\lambda)$ 关于 $\\lambda$ 的一阶导数，并令其为零。\n$$\\frac{d\\ell}{d\\lambda} = \\frac{d}{d\\lambda}\\left(\\ln((n-1)!) + (n-1)\\ln(\\lambda) - \\lambda \\sum_{i=1}^{n-1} i w_i\\right)$$\n$$\\frac{d\\ell}{d\\lambda} = 0 + \\frac{n-1}{\\lambda} - \\sum_{i=1}^{n-1} i w_i$$\n将导数设为零以求得 MLE $\\hat{\\lambda}$：\n$$\\frac{n-1}{\\hat{\\lambda}} - \\sum_{i=1}^{n-1} i w_i = 0$$\n解出 $\\hat{\\lambda}$：\n$$\\frac{n-1}{\\hat{\\lambda}} = \\sum_{i=1}^{n-1} i w_i$$\n$$\\hat{\\lambda} = \\frac{n-1}{\\sum_{i=1}^{n-1} i w_i}$$\n为确认该值对应一个最大值，我们检查对数似然函数的二阶导数：\n$$\\frac{d^2\\ell}{d\\lambda^2} = \\frac{d}{d\\lambda}\\left(\\frac{n-1}{\\lambda} - \\sum_{i=1}^{n-1} i w_i\\right) = -\\frac{n-1}{\\lambda^2}$$\n由于谱系数量 $n$ 必须至少为 $2$ 才能有等待时间，因此 $n-1 \\ge 1$。因为 $\\lambda^2  0$，所以二阶导数 $\\frac{d^2\\ell}{d\\lambda^2}$ 严格为负。这证实了对数似然函数是凹函数，并且我们的估计量 $\\hat{\\lambda}$ 确实是唯一的最大似然估计量。该估计量是观察到的物种形成事件数 $n-1$ 与所有谱系存活的总时间 $\\sum_{i=1}^{n-1} i w_i$ 的比值。", "answer": "$$\\boxed{\\frac{n-1}{\\sum_{i=1}^{n-1} i w_i}}$$", "id": "2567022"}]}