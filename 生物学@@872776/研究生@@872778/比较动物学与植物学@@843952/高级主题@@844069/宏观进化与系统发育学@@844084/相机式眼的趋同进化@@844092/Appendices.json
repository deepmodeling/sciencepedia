{"hands_on_practices": [{"introduction": "相机眼的功能受到光学定律的严格约束，其演化路径深受物理环境的影响。本练习将引导你从斯涅尔定律（Snell's Law）出发，通过推导和计算，量化角膜在空气和水中的屈光力差异，从而深刻理解为何水生动物的相机眼趋同演化出了依赖强大球形晶状体的聚焦方式。这项实践将揭示物理约束是如何成为趋同演化的强大驱动力。[@problem_id:2562813]", "problem": "在对脊椎动物和头足类动物等远缘谱系中的相机式眼进行比较研究时，一个关键的物理约束塑造了水生环境中的趋同演化方案，即角膜在水下的折射贡献会减小。从斯涅尔折射定律 $n_{1}\\sin\\theta_{1}=n_{2}\\sin\\theta_{2}$ 和小角度（傍轴）近似出发，推导球面界面上的傍轴折射条件，该条件将物方和像方聚散度与表面曲率联系起来。利用此条件证明单个球面界面的折射“表面光焦度”与折射率差和曲率成正比，然后量化典型陆生脊椎动物前角膜在水下的这一数值。假设前角膜曲率半径 $R=7.8\\,\\mathrm{mm}$，空气-角膜折射率差 $\\Delta n_{\\mathrm{air}} \\approx 0.33$，水-角膜折射率差 $\\Delta n_{\\mathrm{water}} \\approx 0.05$。为了展示驱动水生动物眼中以晶状体为主的聚焦方式发生趋同演化的这种差异，你也可以计算水下与空气中表面光焦度的无量纲比率，但最终答案仅需报告水下角膜的表面光焦度。\n\n最终答案以屈光度（米⁻¹）表示。将你的答案四舍五入至三位有效数字。最终答案以不带单位的单个数字形式给出。", "solution": "所提出的问题需要进行验证。\n\n**第一步：提取已知条件**\n- 斯涅尔折射定律：$n_{1}\\sin\\theta_{1}=n_{2}\\sin\\theta_{2}$\n- 需使用小角度（傍轴）近似。\n- 考虑单个球面界面。\n- 前角膜曲率半径：$R = 7.8\\,\\mathrm{mm}$\n- 空气-角膜折射率差：$\\Delta n_{\\mathrm{air}} \\approx 0.33$\n- 水-角膜折射率差：$\\Delta n_{\\mathrm{water}} \\approx 0.05$\n- 任务要求推导连接物方和像方聚散度与表面曲率的傍轴折射条件。\n- 任务要求证明表面光焦度与折射率差和曲率成正比。\n- 任务要求量化水下角膜的表面光焦度。\n- 最终答案必须以屈光度为单位，并四舍五入至三位有效数字。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于几何光学的基本原理。这是一个适定问题，因为它提供了明确的目标和所有必要的数据，可以得出一个唯一的、有意义的解。其语言客观而精确。所提供的物理值（$R$、$\\Delta n_{\\mathrm{air}}$、$\\Delta n_{\\mathrm{water}}$）对于生物系统（特别是类人眼）是符合实际的。该问题没有违反任何无效标准；它不是不合理的、不完整的、模棱两可的或微不足道的。这是生物物理光学中的一个标准问题，直接涉及趋同演化这一特定主题。\n\n**第三步：结论与行动**\n问题被判定为**有效**。将提供完整解答。\n\n我们首先推导单个球面的傍轴折射方程。考虑一个曲率半径为 $R$ 的球面界面，它分隔了折射率分别为 $n_1$ 和 $n_2$ 的两种介质。主光轴上的一个物点 $O$ 距离界面顶点 $s_o$ 的物距处。一条从 $O$ 发出的光线以离轴高度 $h$ 射到界面上的点 $P$。经折射后，该光线与主光轴相交于像点 $I$，像距为 $s_i$。\n\n设 $\\theta_1$ 为入射角，$\\theta_2$ 为折射角。设入射光线与主光轴的夹角为 $\\alpha_o$，折射光线与主光轴的夹角为 $\\alpha_i$，点 $P$ 处界面法线与主光轴的夹角为 $\\phi$。根据几何关系，对相关三角形使用外角定理，我们有：\n$\\theta_1 = \\alpha_o + \\phi$\n$\\phi = \\theta_2 + \\alpha_i \\implies \\theta_2 = \\phi - \\alpha_i$\n\n斯涅尔定律为 $n_{1}\\sin\\theta_{1} = n_{2}\\sin\\theta_{2}$。在傍轴（小角度）近似下，对于任何以弧度为单位的小角度 $x$，我们有 $\\sin x \\approx x$。因此，斯涅尔定律变为：\n$n_1 \\theta_1 = n_2 \\theta_2$\n\n代入角度的几何关系得到：\n$n_1 (\\alpha_o + \\phi) = n_2 (\\phi - \\alpha_i)$\n\n同样，在傍轴近似下，我们可以将角度 $\\alpha_o$、$\\alpha_i$ 和 $\\phi$ 与距离 $s_o$、 $s_i$、 $R$ 以及高度 $h$ 联系起来：\n$\\alpha_o \\approx \\tan(\\alpha_o) = \\frac{h}{s_o}$\n$\\alpha_i \\approx \\tan(\\alpha_i) = \\frac{h}{s_i}$\n$\\phi \\approx \\sin(\\phi) = \\frac{h}{R}$\n这里我们采用符号约定，光线从左向右传播，凸面的曲率半径为正。\n\n将这些表达式代入近似的斯涅尔定律：\n$n_1 \\left(\\frac{h}{s_o} + \\frac{h}{R}\\right) = n_2 \\left(\\frac{h}{R} - \\frac{h}{s_i}\\right)$\n\n对于任何非平凡光线（$h \\neq 0$），我们可以两边同除以 $h$：\n$n_1 \\left(\\frac{1}{s_o} + \\frac{1}{R}\\right) = n_2 \\left(\\frac{1}{R} - \\frac{1}{s_i}\\right)$\n\n重新整理各项，将物/像和表面属性分组，我们得到：\n$\\frac{n_1}{s_o} + \\frac{n_2}{s_i} = \\frac{n_2 - n_1}{R}$\n\n这就是傍轴折射方程。其中 $\\frac{n_1}{s_o}$ 和 $\\frac{n_2}{s_i}$ 分别是物方聚散度和像方聚散度。\n\n表面的折射能力，或称表面光焦度 $P$，定义为其会聚平行光线的能力。对于平行入射光线，物在无穷远处，因此 $s_o \\to \\infty$。方程简化为：\n$\\frac{n_2}{s_i} = \\frac{n_2 - n_1}{R}$\n光焦度 $P$ 正是这个量，代表了表面赋予光线的聚散度。\n$P = \\frac{n_2 - n_1}{R}$\n\n这个表达式直接证明了表面光焦度 $P$ 与折射率差 $\\Delta n = n_2 - n_1$ 和表面曲率 $C = \\frac{1}{R}$ 成正比。因此，$P = \\Delta n \\cdot C$。这样就完成了所要求的证明。\n\n现在，我们来量化水下角膜的表面光焦度。问题为此情况提供了必要的值。角膜（介质2）浸没在水（介质1）中。\n折射率差给定为 $\\Delta n_{\\mathrm{water}} = n_{\\mathrm{cornea}} - n_{\\mathrm{water}} \\approx 0.05$。\n前角膜曲率半径给定为 $R = 7.8\\,\\mathrm{mm}$。\n\n为了以屈光度（D），即米⁻¹（$\\mathrm{m}^{-1}$），为单位计算光焦度，我们必须将曲率半径表示为米：\n$R = 7.8\\,\\mathrm{mm} = 7.8 \\times 10^{-3}\\,\\mathrm{m}$\n\n现在，我们应用表面光焦度公式：\n$P_{\\mathrm{water}} = \\frac{\\Delta n_{\\mathrm{water}}}{R}$\n$P_{\\mathrm{water}} = \\frac{0.05}{7.8 \\times 10^{-3}\\,\\mathrm{m}}$\n\n计算得出：\n$P_{\\mathrm{water}} = \\frac{0.05}{0.0078}\\,\\mathrm{m}^{-1} \\approx 6.410256... \\, D$\n\n问题要求将答案四舍五入至三位有效数字。\n$P_{\\mathrm{water}} \\approx 6.41 \\, D$\n\n作为参考（最终答案不需要），在空气中的光焦度为：\n$P_{\\mathrm{air}} = \\frac{\\Delta n_{\\mathrm{air}}}{R} = \\frac{0.33}{7.8 \\times 10^{-3}\\,\\mathrm{m}} \\approx 42.3 \\, D$\n水下光焦度与空气中光焦度的比值为 $\\frac{6.41}{42.3} \\approx 0.15$，这表明角膜在水生介质中会发生显著的折射能力损失。这种物理约束使得水生脊椎动物必须演化出一个强大的、近乎球形的晶状体来实现聚焦，这是由光学定律驱动的趋同演化的一个典型例子。\n所要求的最终答案仅为水下角膜光焦度的数值。", "answer": "$$\\boxed{6.41}$$", "id": "2562813"}, {"introduction": "一个像相机一样复杂的器官是如何通过微小的、渐进的步骤演化而来的？本练习将指导你构建一个经典的Nilsson和Pelger风格的演化模型，通过编程实践将形态学的持续改进与群体遗传学的选择和固定过程联系起来。你将亲自计算在合理的选择压力下，从一个简单的感光斑块演化到一个功能完备的相机眼所需的世代数，从而对宏观演化的速率有一个定量的认识。[@problem_id:2562812]", "problem": "构建一个程序，该程序形式化一个最小化的、基于第一性原理的模型，该模型描述了从一个平坦的感光区域到相机式眼睛的重复微小适应性形态变化，并估算在定向选择下此转变所需的世代数。该模型必须采用以下基本原则，而不调用任何预先推导出的最终公式。\n\n1. 重复的比例变化以乘法方式复合。如果一个性状值在每次成功的形态变化中都经历大小为 $r$ 的比例增长（例如，曲率或孔径增加其当前值的 $r$），那么在 $n$ 次成功变化后，新值是初始值乘以 $(1+r)^n$。\n\n2. 在 Wright–Fisher (WF) 选择模型的确定性极限下，具有选择系数 $s$ 的有利等位基因的频率 $p$ 随世代 $g$ 的变化遵循逻辑斯谛微分方程 $\\dfrac{dp}{dg} = s\\,p\\,(1-p)$。\n\n3. 一次成功的形态变化对应于一个有利等位基因变异的固定。假设为二倍体遗传，有效种群大小为 $N$，因此新突变的初始频率为 $p_i = \\dfrac{1}{2N}$，当 $p_f = 1 - \\dfrac{1}{2N}$ 时被视为固定。\n\n您的任务是实现以下规范。\n\n- 将简化的光学性能指标定义为两个独立可控的形态性状的乘积：表面曲率 $C$（单位为 $\\text{mm}^{-1}$）和孔径直径 $A$（单位为 $\\text{mm}$）。该指标 $I$ 定义为 $I = C \\times A$。此选择是合理的，因为它是一个最小化的乘法代理，其中增加的聚焦能力（与曲率相关）和集光能力（与孔径相关）都会提高整体性能。\n\n- 单个形态学步骤定义为对 $C$ 和 $A$ 同时应用的成功的 $r$ 分数增长。也就是说，在每个步骤之后，$C \\leftarrow C\\,(1+r)$ 且 $A \\leftarrow A\\,(1+r)$。由于两个性状同步变化，达到目标所需的形态学步骤数是 $C$ 和 $A$ 单独所需步骤数的最大值。如果某个性状已经达到或超过目标，则该性状所需的步骤数为零。\n\n- 对每个测试用例，计算：\n  1) 使得 $C \\ge C_{\\text{target}}$ 和 $A \\ge A_{\\text{target}}$ 所需的形态学步骤的整数数量 $n_{\\text{steps}}$，仅使用从初始状态 $(C_0, A_0)$ 开始、每步分数变化为 $r$ 的乘法复合。\n  2) 每个成功步骤的预期世代数 $t_{\\text{fix}}$，通过对常数选择系数 $s$，将 WF 逻辑斯谛方程从 $p_i = \\dfrac{1}{2N}$ 积分到 $p_f = 1 - \\dfrac{1}{2N}$ 来计算。\n  3) 所需的总世代数 $G_{\\text{total}} = n_{\\text{steps}} \\times t_{\\text{fix}}$，通过向上取整到最接近的世代，返回一个整数。\n\n- 不使用角度单位。所有物理量必须使用上述指定单位。要求的输出是整数世代数。\n\n使用以下固定的测试套件实现您的程序。每个测试用例是一个参数元组 $(C_0, A_0, C_{\\text{target}}, A_{\\text{target}}, s, N)$，其中 $C_0$ 和 $C_{\\text{target}}$ 的单位是 $\\text{mm}^{-1}$，$A_0$ 和 $A_{\\text{target}}$ 的单位是 $\\text{mm}$，$s$ 是无量纲的，$N$ 是有效种群大小：\n- 测试 $1$：$(\\,C_0 = 0.02,\\, A_0 = 0.2,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.01,\\, N = 100000\\,)$\n- 测试 $2$：$(\\,C_0 = 0.02,\\, A_0 = 0.2,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.002,\\, N = 100000\\,)$\n- 测试 $3$：$(\\,C_0 = 0.9,\\, A_0 = 0.05,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.02,\\, N = 10000\\,)$\n- 测试 $4$：$(\\,C_0 = 1.0,\\, A_0 = 1.0,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.01,\\, N = 1000\\,)$\n- 测试 $5$：$(\\,C_0 = 0.01,\\, A_0 = 0.5,\\, C_{\\text{target}} = 0.5,\\, A_{\\text{target}} = 0.6,\\, s = 0.05,\\, N = 500\\,)$\n\n使用固定的每步分数变化 $r = 0.01$（对应于每次成功步骤的百分之一比例增长）。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含每个测试用例的总世代数，每个世代数都是整数，并聚合成一个用方括号括起来的逗号分隔列表，例如：“[x1,x2,x3,x4,x5]”。", "solution": "问题陈述要求构建一个基于第一性原理的模型，以估算一个平坦的感光区域通过一系列微小、连续的形态学改进演化成相机式眼睛所需的世代数。在尝试解决问题之前，必须确立此问题的有效性。\n\n首先，逐字提取已知条件。\n1.  **乘法复合**：一个性状值在经历 $n$ 次大小为 $r$ 的重复比例增长后，从一个初始值变为 初始值 $\\times (1+r)^n$。\n2.  **选择动力学**：具有选择系数 $s$ 的有利等位基因的频率 $p$ 随世代 $g$ 的变化遵循逻辑斯谛微分方程 $\\dfrac{dp}{dg} = s\\,p\\,(1-p)$。\n3.  **固定定义**：在一个有效种群大小为 $N$ 的二倍体种群中，一个新突变的初始频率为 $p_i = \\dfrac{1}{2N}$，在 $p_f = 1 - \\dfrac{1}{2N}$ 时被固定。\n4.  **光学性能指标**：$I = C \\times A$，其中 $C$ 是表面曲率（$\\text{mm}^{-1}$），$A$ 是孔径直径（$\\text{mm}$）。\n5.  **形态学步骤**：单个步骤是对 $C$ 和 $A$ 同时进行的 $r$ 分数增长。总步骤数是任一性状达到其目标所需步骤的最大值。如果一个目标已达到或超过，则该性状所需的步骤数为零。\n6.  **计算方案**：计算 $n_{\\text{steps}}$，然后计算 $t_{\\text{fix}}$（每步的世代数），然后计算 $G_{\\text{total}} = n_{\\text{steps}} \\times t_{\\text{fix}}$，并向上取整。\n7.  **固定参数**：每步分数变化为 $r = 0.01$。\n8.  **测试套件**：\n    - 测试 $1$：$(\\,C_0 = 0.02,\\, A_0 = 0.2,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.01,\\, N = 100000\\,)$\n    - 测试 $2$：$(\\,C_0 = 0.02,\\, A_0 = 0.2,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.002,\\, N = 100000\\,)$\n    - 测试 $3$：$(\\,C_0 = 0.9,\\, A_0 = 0.05,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.02,\\, N = 10000\\,)$\n    - 测试 $4$：$(\\,C_0 = 1.0,\\, A_0 = 1.0,\\, C_{\\text{target}} = 1.0,\\, A_{\\text{target}} = 1.0,\\, s = 0.01,\\, N = 1000\\,)$\n    - 测试 $5$：$(\\,C_0 = 0.01,\\, A_0 = 0.5,\\, C_{\\text{target}} = 0.5,\\, A_{\\text{target}} = 0.6,\\, s = 0.05,\\, N = 500\\,)$\n\n其次，对问题进行验证。该模型具有科学依据，使用了群体遗传学（Wright-Fisher 模型）和数学（乘法复合）的标准原理。这是一个简化但被广泛接受的累积选择建模方法，在眼睛演化的研究中被著名地使用。该问题是适定的，为唯一的确定性解提供了所有必要的参数和定义。语言客观而精确。在科学合理性、可形式化性、完整性、可行性或结构方面均无缺陷。因此，该问题被视为**有效**。\n\n解答按规定分为三个部分构建。\n\n第 $1$ 部分：计算形态学步骤数，$n_{\\text{steps}}$。\n一个形态学步骤包括对曲率 $C$ 和孔径 $A$ 的同步更新：$C \\to C\\,(1+r)$ 和 $A \\to A\\,(1+r)$。我们必须找到使每个性状达到或超过其目标所需的最小整数步骤数 $n_C$ 和 $n_A$。总步骤数 $n_{\\text{steps}}$ 是这两个值的最大值。\n对于曲率，从 $C_0$ 开始，经过 $n_C$ 步后，新值为 $C_0\\,(1+r)^{n_C}$。我们需要 $C_0\\,(1+r)^{n_C} \\ge C_{\\text{target}}$。如果 $C_{\\text{target}} \\le C_0$，则不需要任何步骤，因此 $n_C=0$。否则，对于 $C_{\\text{target}} > C_0$，我们求解 $n_C$：\n$$ (1+r)^{n_C} \\ge \\frac{C_{\\text{target}}}{C_0} $$\n$$ n_C \\ln(1+r) \\ge \\ln\\left(\\frac{C_{\\text{target}}}{C_0}\\right) $$\n$$ n_C \\ge \\frac{\\ln(C_{\\text{target}}/C_0)}{\\ln(1+r)} $$\n由于 $n_C$ 必须是整数，我们取该值的天花板函数。同样的逻辑适用于孔径 $A$。因此，我们有：\n$$ n_C = \\begin{cases} \\lceil \\frac{\\ln(C_{\\text{target}}/C_0)}{\\ln(1+r)} \\rceil  \\text{if } C_{\\text{target}} > C_0 \\\\ 0  \\text{if } C_{\\text{target}} \\le C_0 \\end{cases} $$\n$$ n_A = \\begin{cases} \\lceil \\frac{\\ln(A_{\\text{target}}/A_0)}{\\ln(1+r)} \\rceil  \\text{if } A_{\\text{target}} > A_0 \\\\ 0  \\text{if } A_{\\text{target}} \\le A_0 \\end{cases} $$\n总步骤数为 $n_{\\text{steps}} = \\max(n_C, n_A)$。\n\n第 $2$ 部分：计算固定时间，$t_{\\text{fix}}$。\n这是完成一个成功的形态学步骤所需的世代数，对应于单个有利等位基因的固定。我们已知 Wright-Fisher 模型的确定性极限：$\\frac{dp}{dg} = s\\,p\\,(1-p)$。为了找到等位基因频率 $p$ 从 $p_i$ 变化到 $p_f$ 所需的时间 $t_{\\text{fix}}$，我们必须解这个微分方程。它是可分离的：\n$$ dg = \\frac{1}{s} \\frac{dp}{p(1-p)} $$\n我们从 $g=0$ 积分到 $g=t_{\\text{fix}}$，并从 $p=p_i$ 积分到 $p=p_f$：\n$$ \\int_0^{t_{\\text{fix}}} dg = \\frac{1}{s} \\int_{p_i}^{p_f} \\frac{dp}{p(1-p)} $$\n使用部分分式分解，$\\frac{1}{p(1-p)} = \\frac{1}{p} + \\frac{1}{1-p}$。积分变为：\n$$ t_{\\text{fix}} = \\frac{1}{s} \\left[ \\ln|p| - \\ln|1-p| \\right]_{p_i}^{p_f} = \\frac{1}{s} \\left[ \\ln\\left(\\frac{p}{1-p}\\right) \\right]_{p_i}^{p_f} $$\n$$ t_{\\text{fix}} = \\frac{1}{s} \\left( \\ln\\left(\\frac{p_f}{1-p_f}\\right) - \\ln\\left(\\frac{p_i}{1-p_i}\\right) \\right) = \\frac{1}{s} \\ln\\left( \\frac{p_f(1-p_i)}{p_i(1-p_f)} \\right) $$\n我们已知 $p_i = \\frac{1}{2N}$ 和 $p_f = 1 - \\frac{1}{2N}$。代入这些值可得：\n$$ 1 - p_i = 1 - \\frac{1}{2N} = p_f $$\n$$ 1 - p_f = 1 - \\left(1 - \\frac{1}{2N}\\right) = \\frac{1}{2N} = p_i $$\n对数的参数变为 $\\frac{(1 - 1/(2N))(1 - 1/(2N))}{(1/(2N))(1/(2N))} = \\frac{((2N-1)/(2N))^2}{(1/(2N))^2} = (2N-1)^2$。\n所以，固定时间为：\n$$ t_{\\text{fix}} = \\frac{1}{s} \\ln\\left( (2N - 1)^2 \\right) = \\frac{2}{s} \\ln(2N - 1) $$\n\n第 $3$ 部分：计算总世代数，$G_{\\text{total}}$。\n总世代数是步骤数与每步时间的乘积，向上取整到最接近的整数。\n$$ G_{\\text{total}} = \\lceil n_{\\text{steps}} \\times t_{\\text{fix}} \\rceil $$\n这三个部分为解决每个测试用例的问题提供了完整的算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eye evolution model problem for a given set of test cases.\n    \"\"\"\n    # Fixed per-step fractional change r\n    r = 0.01\n\n    # Test cases: (C0, A0, C_target, A_target, s, N)\n    test_cases = [\n        # Test 1\n        (0.02, 0.2, 1.0, 1.0, 0.01, 100000),\n        # Test 2\n        (0.02, 0.2, 1.0, 1.0, 0.002, 100000),\n        # Test 3\n        (0.9, 0.05, 1.0, 1.0, 0.02, 10000),\n        # Test 4\n        (1.0, 1.0, 1.0, 1.0, 0.01, 1000),\n        # Test 5\n        (0.01, 0.5, 0.5, 0.6, 0.05, 500)\n    ]\n\n    results = []\n    for case in test_cases:\n        C0, A0, C_target, A_target, s, N = case\n\n        # Part 1: Calculate the number of morphological steps, n_steps\n        \n        # Calculate steps for curvature C\n        if C_target > C0:\n            n_C = np.ceil(np.log(C_target / C0) / np.log(1 + r))\n        else:\n            n_C = 0\n\n        # Calculate steps for aperture A\n        if A_target > A0:\n            n_A = np.ceil(np.log(A_target / A0) / np.log(1 + r))\n        else:\n            n_A = 0\n        \n        # Total steps is the maximum of the two\n        n_steps = max(n_C, n_A)\n\n        # Part 2: Calculate the fixation time, t_fix\n        # t_fix = (2/s) * ln(2N - 1)\n        # Avoid calculation if n_steps is 0 to prevent unnecessary computation\n        if n_steps == 0:\n            t_fix = 0\n        else:\n            # The problem is defined for s > 0 and N >= 1\n            t_fix = (2 / s) * np.log(2 * N - 1)\n\n        # Part 3: Calculate total generations, G_total\n        # G_total = ceil(n_steps * t_fix)\n        G_total = np.ceil(n_steps * t_fix)\n        \n        results.append(int(G_total))\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2562812"}, {"introduction": "在理论建模之外，我们如何利用真实的生物多样性数据来检验关于相机眼演化历史的假说？本练习将你带到现代比较生物学的前沿，应用连续时间马尔可夫链（continuous-time Markov chain）模型来评估两种相互竞争的演化情景：“多次独立起源”（真正的趋同）与“单次起源后多次丢失”。通过亲手计算和比较模型的似然值与赤池信息量准则（Akaike Information Criterion, AIC），你将学会如何利用统计学方法对宏观演化模式进行严格的假说检验。[@problem_id:2562784]", "problem": "给定一个完全映射的数据集，该数据集表示一个进化支中相机型眼睛这一二元性状的存在与否。状态 $0$ 表示不存在，状态 $1$ 表示存在。该映射数据集总结了在整个系统发育树中，处于每个状态的总分支时长，以及沿着映射观察到的状态间转换的总次数。设 $T_0$ 和 $T_1$ 分别表示在状态 $0$ 和状态 $1$ 中所花费的总时间，单位为百万年（My）。设 $N_{01}$ 为映射中 $0 \\to 1$ 转换（获得）的总次数，$N_{10}$ 为 $1 \\to 0$ 转换（丢失）的总次数。假设一个时间同质的双态连续时间马尔可夫链（CTMC）控制着沿分支的状态变化。\n\n基础理论：\n- 当完整映射已知时，一个具有生成矩阵参数 $q_{01} = \\alpha \\ge 0$（获得率）和 $q_{10} = \\beta \\ge 0$（丢失率）的双态CTMC 会产生一个路径（映射）似然，该似然可以通过充分统计量进行因子分解。具体来说，完整数据似然通过标准的指数等待时间和事件计数项，依赖于 $(T_0, T_1, N_{01}, N_{10})$ 和参数 $(\\alpha, \\beta)$。\n- 在完整数据映射下，CTMC速率参数的最大似然估计（MLE）是通过最大化关于参数的完整数据对数似然函数获得的。\n- 对于一个具有 $k$ 个自由参数和最大化对数似然 $\\ell$ 的模型，Akaike信息准则（Akaike Information Criterion, AIC）为 $\\mathrm{AIC} = 2k - 2\\ell$。\n- 用于比较具有最大化对数似然 $\\ell_0$ 和 $\\ell_1$ 的两个模型 $M_0$ 和 $M_1$ 的似然比检验（Likelihood Ratio Test, LRT）使用统计量 $D = 2(\\ell_1 - \\ell_0)$，并且在标准的正则性和嵌套条件下，将 $D$ 与一个卡方参考分布进行比较，其自由度等于参数数量的差异。\n\n任务：\n- 使用映射数据集，拟合并比较关于相机型眼睛的两种进化情景：\n  1. 多次独立获得模型 $M_{\\mathrm{G}}$：一个双参数CTMC，其获得率 $\\alpha$ 和丢失率 $\\beta$ 均为自由参数，通过 $(T_0, T_1, N_{01}, N_{10})$ 进行最大似然估计（MLE）。\n  2. 单次起源多次丢失模型 $M_{\\mathrm{S}}$：一个Dollo条件视图，其中过程以整个进化支中性状只有单次起源为条件。在此条件下，只有状态1内的丢失过程对参数推断和模型拟合有贡献；将丢失率 $\\beta$ 视为唯一的自由参数，通过 $(T_1, N_{10})$ 进行最大似然估计，并将任何获得过程的贡献视为条件剔除（即相对于 $\\beta$ 的一个常数）。\n- 对于每个数据集，计算：\n  - $M_{\\mathrm{G}}$ 下的最大化对数似然 $\\ell_{\\mathrm{G}}$ 和 $M_{\\mathrm{S}}$ 下的最大化对数似然 $\\ell_{\\mathrm{S}}$。\n  - Akaike信息准则值 $\\mathrm{AIC}_{\\mathrm{G}}$ 和 $\\mathrm{AIC}_{\\mathrm{S}}$，其中 $k_{\\mathrm{G}} = 2$ 且 $k_{\\mathrm{S}} = 1$。\n  - 似然比统计量 $D = 2(\\ell_{\\mathrm{G}} - \\ell_{\\mathrm{S}})$。\n  - 一个布尔决策，指示 $D$ 是否超过自由度为1的卡方分布的0.95分位数，即 $D > 3.841458820694124$ 是否成立，从而在0.05的显著性水平上拒绝 $M_{\\mathrm{S}}$ 而支持 $M_{\\mathrm{G}}$。注意：虽然严格意义上Dollo条件模型并非嵌套于双参数CTMC模型中，但您仍应使用此阈值报告 $D$ 和布尔值以进行比较。\n\n数值约定：\n- 将形如 $0 \\cdot \\log 0$ 的表达式视为 $0$。\n- 如果 $T_0 = 0$ 且 $N_{01} > 0$，或 $T_1 = 0$ 且 $N_{10} > 0$，则任何需要这些项的模型的对数似然函数是未定义的；此类情况已从提供的测试套件中排除。\n- 所有时间 $T_0$ 和 $T_1$ 的单位都是百万年（My）。最终报告的量 $\\ell_{\\mathrm{G}}$、$\\ell_{\\mathrm{S}}$、$\\mathrm{AIC}$ 和 $D$ 都是无量纲的。\n\n测试套件：\n使用以下四个映射数据集，每个数据集以元组 $(T_0, T_1, N_{01}, N_{10})$ 的形式给出，其中 $T_0$ 和 $T_1$ 的单位是百万年：\n1. $(120.0, 80.0, 3, 5)$\n2. $(200.0, 150.0, 1, 6)$\n3. $(300.0, 50.0, 1, 0)$\n4. $(50.0, 0.0, 0, 0)$\n\n要求输出：\n- 对于每个数据集，按以下顺序输出一个包含四个项目的列表：$[\\mathrm{AIC}_{\\mathrm{S}}, \\mathrm{AIC}_{\\mathrm{G}}, D, \\text{reject}]$，其中 $\\mathrm{AIC}_{\\mathrm{S}}$ 和 $\\mathrm{AIC}_{\\mathrm{G}}$ 是四舍五入到六位小数的浮点数，$D$ 是四舍五入到六位小数的浮点数，而 $\\text{reject}$ 是一个布尔值，指示 $D > 3.841458820694124$ 是否成立。\n- 您的程序应生成单行输出，其中包含四个数据集的结果，形式为由逗号分隔的列表的列表，并用方括号括起来。例如：“[[a,b,c,False],[...],...]”，其中每个浮点数都四舍五入到六位小数，无额外文本。", "solution": "我们将映射数据集在一个双态连续时间马尔可夫链（CTMC）下进行形式化，其状态为 $0$（不存在）和 $1$（存在）。设 $q_{01} = \\alpha \\ge 0$ 表示获得率，$q_{10} = \\beta \\ge 0$ 表示丢失率。生成矩阵为\n$$\nQ = \\begin{pmatrix}\n-\\alpha & \\alpha \\\\\n\\beta & -\\beta\n\\end{pmatrix}.\n$$\n当整个系统发育树上的随机性状图已知时，关于 $(\\alpha,\\beta)$ 的完整数据似然会因子分解为从每个状态转换出的独立分量。充分统计量为 $(T_0, T_1, N_{01}, N_{10})$，其中 $T_0$ 和 $T_1$ 分别是所有分支上处于状态 $0$ 和 $1$ 的总时间，$N_{01}$ 和 $N_{10}$ 分别是从 $0$ 到 $1$ 和从 $1$ 到 $0$ 的总转换次数。\n\n一个同质CTMC路径的完整数据似然（除去一个不涉及 $\\alpha$ 或 $\\beta$ 的初始状态因子）由下式给出\n$$\nL(\\alpha,\\beta \\mid T_0, T_1, N_{01}, N_{10}) \\propto \\left[\\alpha^{N_{01}} e^{-\\alpha T_0}\\right] \\left[\\beta^{N_{10}} e^{-\\beta T_1}\\right].\n$$\n取对数得到完整数据对数似然\n$$\n\\ell(\\alpha,\\beta) = N_{01} \\log \\alpha - \\alpha T_0 + N_{10} \\log \\beta - \\beta T_1.\n$$\n由于可加性，关于 $\\alpha$ 和 $\\beta$ 的最大化是分开进行的。对于 $T_0 > 0$，最大化估计量为 $\\hat{\\alpha} = N_{01}/T_0$；对于 $N_{01} = 0$，我们约定 $\\hat{\\alpha} = 0$，且项 $N_{01} \\log \\hat{\\alpha}$ 被解释为 $0$。类似地，对于 $T_1 > 0$，$\\hat{\\beta} = N_{10}/T_1$，当 $N_{10} = 0$ 时遵循 $0 \\cdot \\log 0$ 约定。代入最大化估计量可得\n$$\n\\ell_{\\mathrm{G}} = \\ell(\\hat{\\alpha},\\hat{\\beta}) = \\left[N_{01} \\log \\left(\\frac{N_{01}}{T_0}\\right) - N_{01}\\right] + \\left[N_{10} \\log \\left(\\frac{N_{10}}{T_1}\\right) - N_{10}\\right],\n$$\n其中约定当 $N_{01} = 0$ 时，相应的方括号项等于 $0$，对于 $N_{10} = 0$ 也同样如此。\n\n这就定义了多次独立获得模型 $M_{\\mathrm{G}}$，一个双参数CTMC，其Akaike信息准则为\n$$\n\\mathrm{AIC}_{\\mathrm{G}} = 2 k_{\\mathrm{G}} - 2 \\ell_{\\mathrm{G}}, \\quad k_{\\mathrm{G}} = 2.\n$$\n\n对于单次起源多次丢失情景 $M_{\\mathrm{S}}$，我们采用Dollo条件方法：我们以树上某处发生过单次起源（一个 $0 \\to 1$ 事件）为条件，并将获得过程视为相对于 $\\beta$ 推断的条件剔除项。在此条件下，我们感兴趣的参数是丢失率 $\\beta$，相关的似然因子为\n$$\nL_{\\mathrm{S}}(\\beta \\mid T_1,N_{10}) \\propto \\beta^{N_{10}} e^{-\\beta T_1},\n$$\n其对数似然为\n$$\n\\ell_{\\mathrm{S}}(\\beta) = N_{10} \\log \\beta - \\beta T_1.\n$$\n最大化得到 $\\hat{\\beta} = N_{10}/T_1$（对于 $T_1 > 0$），以及 $\\hat{\\beta} = 0$（当 $N_{10}=0$ 时），从而产生最大化对数似然\n$$\n\\ell_{\\mathrm{S}} = N_{10} \\log \\left(\\frac{N_{10}}{T_1}\\right) - N_{10},\n$$\n其中当 $N_{10}=0$ 时，$0 \\cdot \\log 0$ 约定使其值为 $0$。这个单参数模型的Akaike信息准则为\n$$\n\\mathrm{AIC}_{\\mathrm{S}} = 2 k_{\\mathrm{S}} - 2 \\ell_{\\mathrm{S}}, \\quad k_{\\mathrm{S}} = 1.\n$$\n\n为了进行比较评估，我们计算似然比统计量\n$$\nD = 2(\\ell_{\\mathrm{G}} - \\ell_{\\mathrm{S}}).\n$$\n尽管由于对获得事件的条件限制，$M_{\\mathrm{S}}$ 的定义并未严格嵌套在 $M_{\\mathrm{G}}$ 内，但报告 $D$ 值对于说明引入自由获得率参数 $\\alpha$ 所带来的拟合增量仍然具有信息价值。我们将 $D$与自由度为1的卡方分布的0.95分位数（记为 $\\chi^2_{0.95,1} = 3.841458820694124$）进行比较，并报告一个布尔值，指示 $D > \\chi^2_{0.95,1}$ 是否成立。\n\n现在我们为提供的测试套件计算所要求的量，使用 $0 \\cdot \\log 0 = 0$ 的约定，并通过数据集的设计排除了未定义的组合。\n\n情况1：$(T_0, T_1, N_{01}, N_{10}) = (120.0, 80.0, 3, 5)$。\n- $\\hat{\\alpha} = 3/120 = 0.025$，$\\hat{\\beta} = 5/80 = 0.0625$。\n- $\\ell_{\\mathrm{G}} = 3 \\log(3/120) - 3 + 5 \\log(5/80) - 5 \\approx -32.929581975$。\n- $\\mathrm{AIC}_{\\mathrm{G}} = 2 \\cdot 2 - 2 \\cdot (-32.929581975) \\approx 69.859164$。\n- $\\ell_{\\mathrm{S}} = 5 \\log(5/80) - 5 \\approx -18.862943615$。\n- $\\mathrm{AIC}_{\\mathrm{S}} = 2 \\cdot 1 - 2 \\cdot (-18.862943615) \\approx 39.725887$。\n- $D = 2(\\ell_{\\mathrm{G}} - \\ell_{\\mathrm{S}}) = 2(-32.929581975 - (-18.862943615)) \\approx -28.133277$，布尔值 $D > 3.841458820694124$ 为False。\n\n情况2：$(200.0, 150.0, 1, 6)$。\n- $\\hat{\\alpha} = 1/200 = 0.005$，$\\hat{\\beta} = 6/150 = 0.04$。\n- $\\ell_{\\mathrm{G}} \\approx -32.611572317$，$\\mathrm{AIC}_{\\mathrm{G}} \\approx 69.223145$。\n- $\\ell_{\\mathrm{S}} \\approx -25.31325495$，$\\mathrm{AIC}_{\\mathrm{S}} \\approx 52.62651$。\n- $D \\approx -14.596635$，布尔值为False。\n\n情况3：$(300.0, 50.0, 1, 0)$。\n- $\\hat{\\alpha} = 1/300 \\approx 0.003333\\ldots$，$\\hat{\\beta} = 0$。\n- $\\ell_{\\mathrm{G}} = \\log(1/300) - 1 \\approx -6.703782475$，$\\mathrm{AIC}_{\\mathrm{G}} \\approx 17.407565$。\n- $\\ell_{\\mathrm{S}} = 0$，$\\mathrm{AIC}_{\\mathrm{S}} = 2.0$。\n- $D \\approx -13.407565$，布尔值为False。\n\n情况4：$(50.0, 0.0, 0, 0)$。\n- $\\hat{\\alpha} = 0$，$\\hat{\\beta} = 0$。\n- $\\ell_{\\mathrm{G}} = 0$，$\\mathrm{AIC}_{\\mathrm{G}} = 4.0$。\n- $\\ell_{\\mathrm{S}} = 0$，$\\mathrm{AIC}_{\\mathrm{S}} = 2.0$。\n- $D = 0.0$，布尔值为False。\n\n最终要求的输出是单行文本，包含每个情况的结果列表，每个列表格式为 $[\\mathrm{AIC}_{\\mathrm{S}}, \\mathrm{AIC}_{\\mathrm{G}}, D, \\text{reject}]$，其中浮点数四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nCHI2_0_95_DF1 = 3.841458820694124\n\ndef mle_loglik_term(N, T):\n    \"\"\"\n    Return the maximized log-likelihood contribution for a Poisson-like term\n    N*log(rate) - rate*T, where the MLE rate = N/T when T>0.\n    Conventions:\n      - If T == 0 and N == 0: contribution = 0.0\n      - If T == 0 and N > 0: contribution = -inf (impossible under model)\n      - If T > 0 and N == 0: contribution = 0.0 (since rate_hat=0 and 0*log(0)=0)\n      - If T > 0 and N > 0: contribution = N*log(N/T) - N\n    \"\"\"\n    if T == 0.0:\n        if N == 0:\n            return 0.0\n        else:\n            return -np.inf\n    else:\n        if N == 0:\n            return 0.0\n        else:\n            return N * (np.log(N) - np.log(T)) - N\n\ndef fit_models_and_compare(T0, T1, N01, N10):\n    # Model G (two-parameter CTMC): log-likelihood is sum of alpha- and beta-terms\n    ll_alpha = mle_loglik_term(N01, T0)\n    ll_beta = mle_loglik_term(N10, T1)\n    if np.isneginf(ll_alpha) or np.isneginf(ll_beta):\n        ll_G = -np.inf\n    else:\n        ll_G = ll_alpha + ll_beta\n    # AIC for Model G with k=2\n    AIC_G = 2 * 2 - 2 * ll_G if np.isfinite(ll_G) else np.inf\n\n    # Model S (Dollo-conditional single origin): only loss term contributes\n    ll_S = mle_loglik_term(N10, T1)\n    # AIC for Model S with k=1\n    AIC_S = 2 * 1 - 2 * ll_S if np.isfinite(ll_S) else np.inf\n\n    # Likelihood ratio statistic\n    if np.isfinite(ll_G) and np.isfinite(ll_S):\n        D = 2 * (ll_G - ll_S)\n    else:\n        D = np.nan\n\n    reject = bool(D > CHI2_0_95_DF1) if np.isfinite(D) else False\n\n    # Round floats to six decimals for output\n    def r6(x):\n        if np.isfinite(x):\n            return float(f\"{x:.6f}\")\n        else:\n            return float(\"nan\") if np.isnan(x) else float(\"inf\")\n\n    return [r6(AIC_S), r6(AIC_G), r6(D), reject]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (T0, T1, N01, N10), with T0, T1 in My (millions of years)\n    test_cases = [\n        (120.0, 80.0, 3, 5),\n        (200.0, 150.0, 1, 6),\n        (300.0, 50.0, 1, 0),\n        (50.0, 0.0, 0, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, T1, N01, N10 = case\n        result = fit_models_and_compare(T0, T1, N01, N10)\n        results.append(result)\n\n    # Build exact required single-line output with floats rounded to six decimals\n    def format_value(v):\n        if isinstance(v, bool):\n            return \"True\" if v else \"False\"\n        elif isinstance(v, float):\n            if np.isnan(v):\n                return \"nan\"\n            if np.isinf(v):\n                return \"inf\"\n            # Ensure 6 decimal places\n            return f\"{v:.6f}\"\n        elif isinstance(v, (int, np.integer)):\n            return str(int(v))\n        else:\n            return str(v)\n\n    inner_strs = []\n    for res in results:\n        inner = \",\".join(format_value(x) for x in res)\n        inner_strs.append(f\"[{inner}]\")\n    output = \"[\" + \",\".join(inner_strs) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2562784"}]}