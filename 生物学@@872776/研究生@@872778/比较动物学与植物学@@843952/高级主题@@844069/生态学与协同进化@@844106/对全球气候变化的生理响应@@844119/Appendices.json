{"hands_on_practices": [{"introduction": "有机体性能与温度之间的关系通常由热性能曲线（TPC）描述，这是热生态学的一个基石概念。本练习旨在提供从实验数据出发，通过建模TPC来量化关键热耐受性状的实践经验。通过拟合一个简单但富有启发性的数学模型，您将估算最适温度（$T_{\\text{opt}}$）和临界热上限（$CT_{\\text{max}}$），然后应用这些参数计算未来变暖情景下的热安全裕度（TSM），这是评估物种灭绝风险的一个关键指标 [@problem_id:2598700]。", "problem": "一种来自温带溪流的外温水生昆虫，其运动性能依赖于温度，据假设，该性能受限于最低和最高失效点，并在一个中间温度处达到平滑的最大值。在以下身体温度 $T$（单位：摄氏度）下测量了该昆虫的相对性能（无单位，已缩放至最大值接近 $1$）：\n- $T = 10$：$0.00$\n- $T = 15$：$0.56$\n- $T = 20$：$0.89$\n- $T = 25$：$1.00$\n- $T = 30$：$0.89$\n- $T = 35$：$0.56$\n- $T = 40$：$0.00$\n\n假设在活动和失效的范围内，热性能曲线可以用一个凹二次函数来近似，该函数在最低和最高临界温度下为零，这与在热极限下的失效以及在最适温度附近的平滑性能表现一致。具体来说，假设其形式为\n$$R(T) = k\\,(T - CT_{\\min})(CT_{\\max} - T),$$\n对于 $CT_{\\min} \\le T \\le CT_{\\max}$ 成立，否则 $R(T) = 0$，其中 $R(T)$ 是相对性能，$CT_{\\min}$ 是临界最低温度，$CT_{\\max}$ 是临界最高温度。\n\n使用上述数据和此模型：\n- 根据第一性原理拟合模型参数，以获得 $CT_{\\min}$、$CT_{\\max}$ 和 $k$。\n- 从拟合的曲线中，推导出最适温度 $T_{\\mathrm{opt}}$（使 $R(T)$ 最大化的温度）和临界最高温度 $CT_{\\max}$。\n- 假设当前平均栖息地温度为 $T_{\\mathrm{hab, current}} = 28$（摄氏度），且该地区预计将升温 $+3$（摄氏度）。计算热安全边际 $TSM = CT_{\\max} - T_{\\mathrm{hab, future}}$，其中 $T_{\\mathrm{hab, future}} = T_{\\mathrm{hab, current}} + 3$。\n\n以摄氏度表示最终的 $TSM$，并将最终报告值四舍五入到四位有效数字。仅提供最终的 $TSM$ 作为报告值。", "solution": "外温动物的热性能通常遵循一条单峰曲线，由于生理衰竭（例如，膜相变、蛋白质变性和系统性衰竭），在最低和最高临界温度下性能会骤降至零。一个在临界极限处为零的二阶近似可以写成\n$$R(T) = k\\,(T - CT_{\\min})(CT_{\\max} - T),$$\n该函数在开区间内为正，并在 $T = CT_{\\min}$ 和 $T = CT_{\\max}$ 处为零，反映了边界约束。这种形式等价于一个开口向下的凹二次函数，捕捉了最适温度附近的主导行为。\n\n步骤1：从数据中确定 $CT_{\\min}$ 和 $CT_{\\max}$。\n在 $T = 10$ 和 $T = 40$ 时，观察到的性能为 $0.00$。在该模型下，这些零点对应于失效边界。因此，\n$$CT_{\\min} = 10, \\quad CT_{\\max} = 40.$$\n\n步骤2：从一个高质量的内部数据点（或通过对内部点进行最小二乘法）确定 $k$。\n在该模型下，最大值出现在顶点处（在步骤3中推导），该顶点位于 $CT_{\\min}$ 和 $CT_{\\max}$ 的中点。数据显示，在 $T = 25$ 附近性能达到峰值，为 $R(25) = 1.00$。我们可以用这个峰值数据点直接确定 $k$：\n$$R(25) = k\\,(25 - 10)(40 - 25) = k\\,(15)(15) = 225k.$$\n令 $R(25) = 1.00$ 可得\n$$225k = 1.00 \\;\\Rightarrow\\; k = \\frac{1}{225}.$$\n\n$k$ 的这个选择也与内部测量值的对称性一致：在 $T = 20$ 时，模型预测\n$$R(20) = \\frac{1}{225}(20 - 10)(40 - 20) = \\frac{1}{225}(10)(20) = \\frac{200}{225} \\approx 0.888\\ldots,$$\n并且在 $T = 30$ 时，\n$$R(30) = \\frac{1}{225}(30 - 10)(40 - 30) = \\frac{1}{225}(20)(10) = \\frac{200}{225} \\approx 0.888\\ldots,$$\n在四舍五入后与报告值 $0.89$ 相匹配。\n\n步骤3：通过最大化 $R(T)$ 从第一性原理推导 $T_{\\mathrm{opt}}$。\n展开 $R(T)$：\n$$R(T) = k\\left[(T - CT_{\\min})(CT_{\\max} - T)\\right] = k\\left(-T^{2} + (CT_{\\min} + CT_{\\max})T - CT_{\\min}CT_{\\max}\\right).$$\n对 $T$ 求导：\n$$\\frac{dR}{dT} = k\\left(-2T + (CT_{\\min} + CT_{\\max})\\right).$$\n令 $\\frac{dR}{dT} = 0$ 以找到最大值点：\n$$-2T + (CT_{\\min} + CT_{\\max}) = 0 \\;\\Rightarrow\\; T_{\\mathrm{opt}} = \\frac{CT_{\\min} + CT_{\\max}}{2}.$$\n使用拟合的边界 $CT_{\\min} = 10$ 和 $CT_{\\max} = 40$：\n$$T_{\\mathrm{opt}} = \\frac{10 + 40}{2} = 25.$$\n\n步骤4：从拟合曲线中确认 $CT_{\\max}$。\n根据使用观察到的零点构建模型的方式，上失效边界为\n$$CT_{\\max} = 40.$$\n\n步骤5：在预计升温的情况下计算热安全边际。\n给定 $T_{\\mathrm{hab, current}} = 28$ 和预计升温 $+3$，未来的栖息地温度是\n$$T_{\\mathrm{hab, future}} = T_{\\mathrm{hab, current}} + 3 = 28 + 3 = 31.$$\n热安全边际（到临界上边界的距离）是\n$$TSM = CT_{\\max} - T_{\\mathrm{hab, future}} = 40 - 31 = 9.$$\n\n按要求四舍五入到四位有效数字，得到 $9.000$。如问题陈述中所指定，单位是摄氏度。", "answer": "$$\\boxed{9.000}$$", "id": "2598700"}, {"introduction": "气候变化不仅涉及变暖，还包括水文循环的改变和大气干旱的加剧。本实践将深入探讨植物水分运输的生物物理学，探索植物如何响应干燥的空气。您将应用质量守恒的基本原理，将土壤的水分供应与蒸腾作用造成的水分流失联系起来，从而计算叶片水势（$\\Psi_{\\text{leaf}}$），并评估由此产生的木质部栓塞风险——这是干旱胁迫下一种关键的液压失效模式 [@problem_id:2598691]。", "problem": "一片耐旱的被子植物叶片，在正午时分正经历一次由增温引起的大气干燥事件。假设从土壤到叶片的水流为一维稳态流，其中 (i) 质量守恒要求木质部水通量等于蒸腾通量，(ii) 通过叶片木质部的液相水力流与水势差成线性关系，以及 (iii) 从叶片散失的气相水分受气孔扩散限制，并与水汽摩尔分数梯度成正比。设土壤水势为 $\\Psi_{soil} = -0.50$ MPa。叶片水力导度为 $K_{leaf} = 5.0 \\times 10^{-3}$ mol m$^{-2}$ s$^{-1}$ MPa$^{-1}$ (液态水)。对水汽的气孔导度为 $g_{sw} = 0.25$ mol m$^{-2}$ s$^{-1}$。饱和水汽压差为 $\\mathrm{VPD} = 3.0$ kPa，大气压力为 $P_{atm} = 101.3$ kPa。\n\n使用以下基本关系式：\n- 稳态质量守恒：蒸腾通量 $E$ 等于木质部水通量。\n- 气相扩散（菲克定律的导度形式）：$E = g_{sw} \\,\\Delta c$，其中水汽摩尔分数差满足 $\\Delta c \\approx \\mathrm{VPD}/P_{atm}$。\n- 线性水力流（达西-欧姆类比）：$E = K_{leaf}\\,(\\Psi_{soil} - \\Psi_{leaf})$。\n\n木质部栓塞响应由导水率损失百分比 $\\mathrm{PLC}(\\Psi)$ 的S型脆弱性曲线描述：\n$$\n\\mathrm{PLC}(\\Psi) = \\frac{100}{1 + \\exp\\!\\big(s\\,(\\Psi - P_{50})\\big)} \\,,\n$$\n其中 $P_{50} = -2.00$ MPa 且 $s = 4.00$ MPa$^{-1}$。定义栓塞概率为导水率损失分数 $p = \\mathrm{PLC}(\\Psi_{leaf})/100$。\n\n从所述原理和定义出发，推导用 $\\Psi_{soil}$、$K_{leaf}$、$g_{sw}$、$\\mathrm{VPD}$ 和 $P_{atm}$ 表示 $\\Psi_{leaf}$ 的表达式，然后计算 $\\Psi_{leaf}$，最后根据脆弱性曲线计算 $p$。将最终答案表示为栓塞概率 $p$（无量纲小数），四舍五入到四位有效数字。不要包含任何单位，也不要报告 $\\Psi_{leaf}$ 的值。", "solution": "该问题陈述具有科学依据，提法得当且内部一致。它提出了一个植物生态生理学中的标准问题，可以使用所提供的原理和数据来解决。因此，将提供一个解答。\n\n目标是计算栓塞概率 $p$，它取决于叶片水势 $\\Psi_{leaf}$。第一步是确定在指定稳态条件下的 $\\Psi_{leaf}$ 值。\n\n基本原理是质量守恒，它要求通过木质部向叶片的供水速率与通过蒸腾作用从叶片散失水分的速率相匹配。设这个共同通量为 $E$。\n\n通过木质部的液相水流使用线性水力关系建模，这是欧姆定律的一个类比：\n$$ E = K_{leaf}\\,(\\Psi_{soil} - \\Psi_{leaf}) $$\n此处，$K_{leaf}$ 是叶片水力导度，$\\Psi_{soil}$ 是土壤水势，$\\Psi_{leaf}$ 是叶片水势。\n\n气相水分流失，即蒸腾作用，被建模为一个由菲克定律的导度形式控制的扩散过程：\n$$ E = g_{sw} \\,\\Delta c $$\n其中 $g_{sw}$ 是对水汽的气孔导度，而 $\\Delta c$ 是叶片内部与大气之间水汽的摩尔分数差。问题陈述中说明，这可以近似为：\n$$ \\Delta c \\approx \\frac{\\mathrm{VPD}}{P_{atm}} $$\n其中 $\\mathrm{VPD}$ 是饱和水汽压差，而 $P_{atm}$ 是大气压力。\n\n通过令通量 $E$ 的两个表达式相等，我们建立了系统在稳态下的控制方程：\n$$ K_{leaf}\\,(\\Psi_{soil} - \\Psi_{leaf}) = g_{sw} \\frac{\\mathrm{VPD}}{P_{atm}} $$\n我们必须解这个关于未知变量 $\\Psi_{leaf}$ 的方程。重新整理各项，我们得到：\n$$ \\Psi_{soil} - \\Psi_{leaf} = \\frac{g_{sw}}{K_{leaf}} \\frac{\\mathrm{VPD}}{P_{atm}} $$\n分离出 $\\Psi_{leaf}$ 可得出叶片水势的解析表达式：\n$$ \\Psi_{leaf} = \\Psi_{soil} - \\frac{g_{sw}}{K_{leaf}} \\frac{\\mathrm{VPD}}{P_{atm}} $$\n我们现在代入给定的数值：\n$\\Psi_{soil} = -0.50$ MPa\n$K_{leaf} = 5.0 \\times 10^{-3}$ mol m$^{-2}$ s$^{-1}$ MPa$^{-1}$\n$g_{sw} = 0.25$ mol m$^{-2}$ s$^{-1}$\n$\\mathrm{VPD} = 3.0$ kPa\n$P_{atm} = 101.3$ kPa\n\n$\\Psi_{leaf}$ 的表达式变为：\n$$ \\Psi_{leaf} = -0.50 \\, \\mathrm{MPa} - \\frac{0.25 \\, \\mathrm{mol \\, m^{-2} \\, s^{-1}}}{5.0 \\times 10^{-3} \\, \\mathrm{mol \\, m^{-2} \\, s^{-1} \\, MPa^{-1}}} \\times \\frac{3.0 \\, \\mathrm{kPa}}{101.3 \\, \\mathrm{kPa}} $$\n单位是一致的，因为导度之比 $g_{sw}/K_{leaf}$ 的单位是 MPa，而压力之比是无量纲的。\n$$ \\Psi_{leaf} = -0.50 \\, \\mathrm{MPa} - (50 \\, \\mathrm{MPa}) \\times \\left(\\frac{3.0}{101.3}\\right) $$\n$$ \\Psi_{leaf} \\approx -0.50 \\, \\mathrm{MPa} - (50 \\, \\mathrm{MPa}) \\times 0.029615 $$\n$$ \\Psi_{leaf} \\approx -0.50 \\, \\mathrm{MPa} - 1.48075 \\, \\mathrm{MPa} \\approx -1.98075 \\, \\mathrm{MPa} $$\n\n第二步是使用已确定的 $\\Psi_{leaf}$ 计算栓塞概率 $p$。问题将 $p$ 定义为导水率损失分数，它由 $\\mathrm{PLC}(\\Psi)$ 函数推导而来：\n$$ p = \\frac{\\mathrm{PLC}(\\Psi_{leaf})}{100} $$\n给定的脆弱性曲线是：\n$$ \\mathrm{PLC}(\\Psi) = \\frac{100}{1 + \\exp(s(\\Psi - P_{50}))} $$\n因此，$p$ 的表达式为：\n$$ p = \\frac{1}{1 + \\exp(s(\\Psi_{leaf} - P_{50}))} $$\n我们使用计算值 $\\Psi_{leaf} \\approx -1.98075$ MPa 和提供的参数 $s = 4.00$ MPa$^{-1}$ 及 $P_{50} = -2.00$ MPa。首先，我们计算指数函数的无量纲宗量：\n$$ s(\\Psi_{leaf} - P_{50}) = 4.00 \\, \\mathrm{MPa}^{-1} \\times (-1.98075 \\, \\mathrm{MPa} - (-2.00 \\, \\mathrm{MPa})) $$\n$$ s(\\Psi_{leaf} - P_{50}) = 4.00 \\times (0.01925) = 0.077 $$\n现在，我们将此值代回 $p$ 的表达式中：\n$$ p = \\frac{1}{1 + \\exp(0.077)} $$\n$$ p \\approx \\frac{1}{1 + 1.08004} \\approx \\frac{1}{2.08004} \\approx 0.480760 $$\n问题要求最终答案四舍五入到四位有效数字。这得出：\n$$ p \\approx 0.4808 $$\n这便是在给定的环境和生理条件下的最终栓塞概率。", "answer": "$$\n\\boxed{0.4808}\n$$", "id": "2598691"}, {"introduction": "预测生态系统对气候变化的响应，通常需要建立并检验基于过程的模型，这些模型需能捕捉驱动有机体生命周期的机制。这项高级练习将引导您完成计算生态学家的完整工作流程：从基本原理出发，构建一个整合了温度和光周期信号的物候模型。随后，您将参与模型校准和验证这两个核心科学实践，利用合成数据来磨练参数估计和评估预测准确性的技能，这对于预测季节性生物事件的发生时间至关重要 [@problem_id:2598656]。", "problem": "构建一个完整、可运行的程序，该程序能够构建、校准和验证一个整合了光周期和积温累积的物候模型，该模型跨越多年份和多地点，并以纯数学和算法的形式进行阐述。该模型必须从基本原理推导而出：每日生长积温累积和由天文学定义的光周期门控。\n\n定义与基本原理：\n- 设 $y$ 表示年份，年份为一离散集合。设 $d \\in \\{1,\\dots,365\\}$ 表示年积日。设 $\\lambda$ 表示纬度（单位：度）。所有三角函数计算均使用弧度。\n- 日平均气温定义为\n$$\nT(y,d) \\;=\\; \\overline{T} \\;+\\; A \\,\\sin\\!\\left(\\frac{2\\pi (d - \\varphi_T)}{365}\\right) \\;+\\; \\gamma\\, (y - y_{\\mathrm{ref}}),\n$$\n其中 $\\overline{T}$ 为年平均气温（单位：摄氏度），$A$ 为季节性振幅（单位：摄氏度），$\\varphi_T$ 为相位偏移（单位：年积日），$\\gamma$ 为线性变暖趋势（单位：摄氏度/年），$y_{\\mathrm{ref}}$ 为参考年份。\n- 第 $d$ 天的太阳赤纬角（单位：弧度）为\n$$\n\\delta(d) \\;=\\; 0.409 \\,\\sin\\!\\left(\\frac{2\\pi (d - 80)}{365}\\right),\n$$\n这是一个编码地球自转轴倾斜的标准近似。\n- 通过 $\\phi = \\lambda \\cdot \\pi/180$ 将纬度转换为弧度。日长（单位：小时）由下式给出\n$$\nP(d,\\lambda) \\;=\\; \\frac{24}{\\pi}\\,\\arccos\\!\\left(-\\tan \\phi \\,\\tan \\delta(d)\\right),\n$$\n其中 $\\arccos$ 的参数在计算前被数值上限制在区间 $\\left[-1,1\\right]$ 内。传递给三角函数的角度必须是弧度。\n- 定义一个固定的基础温度 $T_b$（单位：摄氏度）。日生长积温为\n$$\n\\mathrm{GDD}(y,d) \\;=\\; \\max\\!\\left(0,\\,T(y,d) - T_b\\right).\n$$\n- 光周期门控通过赫维赛德阶跃函数 $H(x)$ 建模，其中当 $x\\ge 0$ 时 $H(x)=1$，当 $x  0$ 时 $H(x)=0$。累积强迫为\n$$\nS_y(D;L_{\\mathrm{crit}},S^\\star) \\;=\\; \\sum_{d=1}^{D} \\mathrm{GDD}(y,d)\\,H\\!\\left(P(d,\\lambda) - L_{\\mathrm{crit}}\\right),\n$$\n其中光周期阈值 $L_{\\mathrm{crit}}$ 的单位为小时，积温阈值 $S^\\star$ 的单位为积温日。模型预测的芽开放日（年积日）是满足 $S_y(D;L_{\\mathrm{crit}},S^\\star) \\ge S^\\star$ 的最小 $D$。如果在 $D=365$ 时仍未达到阈值，则将预测值定义为 $366$。\n\n综合观测数据：\n- 对于下方的每个数据集，观测到的芽开放年积日均由相同的累积强迫规则生成，使用该数据集的“真实”参数 $(L_{\\mathrm{crit,true}}, S^\\star_{\\mathrm{true}})$。数据中不含额外噪声。这确保了科学真实性，同时使推断任务适定。\n\n校准与验证协议：\n- 对每个数据集，通过最小化模型预测与观测到的芽开放年积日在训练年份集上的平方差之和来校准 $(L_{\\mathrm{crit}}, S^\\star)$。然后，使用校准后的固定参数，预测验证年份集上的芽开放，并报告平均绝对误差（单位：天）。\n- 训练年份：$\\{2001,2002,2003,2004,2005,2006\\}$。\n- 验证年份：$\\{2007,2008,2009,2010\\}$。\n- 参考年份：$y_{\\mathrm{ref}}=2000$。\n- 相位偏移：$\\varphi_T=173$。\n- 基础温度：$T_b = 5$ 摄氏度。\n- 您的程序必须只校准 $(L_{\\mathrm{crit}}, S^\\star)$；所有其他参数均由数据集定义固定。\n\n测试套件（三个数据集）：\n- 数据集 A（温带中纬度）：\n  - 纬度 $\\lambda = 45$ 度。\n  - 温度参数：$\\overline{T}=8$ 摄氏度, $A=15$ 摄氏度, $\\gamma=0.10$ 摄氏度/年。\n  - 真实物候参数：$L_{\\mathrm{crit,true}}=11.25$ 小时, $S^\\star_{\\mathrm{true}}=123.5$ 积温日。\n- 数据集 B（北方高纬度）：\n  - 纬度 $\\lambda = 60$ 度。\n  - 温度参数：$\\overline{T}=2$ 摄氏度, $A=20$ 摄氏度, $\\gamma=0.20$ 摄氏度/年。\n  - 真实物候参数：$L_{\\mathrm{crit,true}}=13.15$ 小时, $S^\\star_{\\mathrm{true}}=161.8$ 积温日。\n- 数据集 C（亚热带低纬度）：\n  - 纬度 $\\lambda = 30$ 度。\n  - 温度参数：$\\overline{T}=18$ 摄氏度, $A=10$ 摄氏度, $\\gamma=0.05$ 摄氏度/年。\n  - 真实物候参数：$L_{\\mathrm{crit,true}}=9.85$ 小时, $S^\\star_{\\mathrm{true}}=82.3$ 积温日。\n\n为保证可复现性所需的校准细节：\n- $L_{\\mathrm{crit}}$ 的搜索域：从 $9.0$ 到 $14.5$ 小时（含边界），步长为 $0.1$ 小时。\n- $S^\\star$ 的搜索域：从 $60$ 到 $220$ 积温日（含边界），步长为 $1.0$ 积温日。\n- 如果多个参数对产生相同的最小训练损失，选择 $L_{\\mathrm{crit}}$ 最小的参数对；如果仍然持平，则选择 $S^\\star$ 最小的参数对。\n\n计算与单位要求：\n- 所有三角函数的输入必须是弧度；确保在使用前将纬度从度转换为弧度。\n- 温度单位为摄氏度，日长单位为小时，积温单位为积温日，芽开放年积日单位为天。\n- 对于最终报告的误差，将以天为单位的平均绝对误差表示为四舍五入到两位小数的浮点值。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。具体来说，输出三个验证平均绝对误差（依次为数据集A、数据集B、数据集C），每个误差都是一个四舍五入到两位小数的浮点数，单位为天。例如，一个有效的输出格式是 `[1.23,4.56,7.89]`。", "solution": "我们从物候强迫和天文光周期的核心定义出发。目标是整合由光周期门控调制的每日热力强迫，直到达到一个阈值，然后根据多年的观测数据校准该门控和阈值。\n\n原理与推导：\n- 温度驱动的发育由生长积温建模。从根本上说，对于年份 $y$ 的每一天 $d$，对发育的贡献是环境温度与基础温度之差的正值部分。即 $\\mathrm{GDD}(y,d)=\\max(0, T(y,d) - T_b)$，这遵循一个经过充分检验的规则，即许多发育过程在高于基础温度时与温度大致成线性比例。\n- 光周期敏感性源于响应日长的内源性昼夜节律机制。为以通用方式形式化光周期，日长 $P(d,\\lambda)$ 由地球-太阳几何关系推导得出。太阳赤纬角近似为 $\\delta(d)=0.409\\sin(2\\pi(d-80)/365)$，其中 $0.409$ 弧度编码了地球的自转轴倾斜。给定纬度 $\\phi$（以弧度为单位），半日时角为 $\\arccos(-\\tan\\phi\\tan\\delta)$；将此角度范围映射到时钟时间即可得到日长\n$$\nP(d,\\lambda) = \\frac{24}{\\pi}\\,\\arccos\\!\\left(-\\tan\\phi\\,\\tan\\delta(d)\\right).\n$$\n为保证数值安全，$\\arccos$ 的参数被限制在 $\\left[-1,1\\right]$ 内。\n- 光周期门控用赫维赛德阶跃函数 $H\\!\\left(P(d,\\lambda)-L_{\\mathrm{crit}}\\right)$ 表示。这编码了只有当日长至少达到临界值 $L_{\\mathrm{crit}}$ 时，发育累积才被允许。\n- 到第 $D$ 天的累积强迫则为\n$$\nS_y(D;L_{\\mathrm{crit}},S^\\star) \\;=\\; \\sum_{d=1}^D \\mathrm{GDD}(y,d)\\,H\\!\\left(P(d,\\lambda)-L_{\\mathrm{crit}}\\right).\n$$\n物候事件（例如，芽开放）发生在满足 $S_y(D;L_{\\mathrm{crit}},S^\\star)\\ge S^\\star$ 的最小日期 $D$。此定义保证了随 $D$ 的单调性，因为加数是非负的。\n\n综合数据生成：\n- 日平均温度规定为\n$$\nT(y,d)=\\overline{T}+A\\sin\\!\\left(\\frac{2\\pi(d-\\varphi_T)}{365}\\right)+\\gamma(y-y_{\\mathrm{ref}}),\n$$\n这反映了一个围绕平均值 $\\overline{T}$、振幅为 $A$ 的平滑年周期，以及一个线性变暖趋势 $\\gamma$。所有常数 $\\overline{T}, A, \\varphi_T, \\gamma, y_{\\mathrm{ref}}$ 均按数据集指定并固定。基础温度固定为 $T_b=5$ 摄氏度。\n- 对于每个数据集，使用其纬度 $\\lambda$ 和“真实”参数 $(L_{\\mathrm{crit,true}}, S^\\star_{\\mathrm{true}})$，我们通过对训练集和验证集的所有年份 $y$ 应用上述累积强迫规则来计算观测到的芽开放年积日。训练集包括 $\\{2001,2002,2003,2004,2005,2006\\}$，验证集包括 $\\{2007,2008,2009,2010\\}$；参考年份为 $y_{\\mathrm{ref}}=2000$，相位偏移为 $\\varphi_T=173$。\n\n作为优化问题的校准：\n- 我们通过最小化训练年份中预测与观测到的芽开放日之间的平方误差和来校准两个参数 $(L_{\\mathrm{crit}}, S^\\star)$。给定训练集中年份 $y$ 的训练观测值 $\\{D^{\\mathrm{obs}}_y\\}$，目标函数为\n$$\nJ(L_{\\mathrm{crit}},S^\\star) \\;=\\; \\sum_{y\\in\\mathcal{Y}_{\\mathrm{train}}}\\left(D_y(L_{\\mathrm{crit}},S^\\star) - D^{\\mathrm{obs}}_y\\right)^2,\n$$\n其中 $D_y(L_{\\mathrm{crit}},S^\\star)$ 是在候选参数下模型预测的年积日。我们将搜索限制在一个物理上合理的范围内：$L_{\\mathrm{crit}}\\in[9.0,14.5]$ 小时和 $S^\\star\\in[60,220]$ 积温日，分别使用 $0.1$ 小时和 $1.0$ 积温日的步长。如果有多个最小化器，我们通过选择最小的 $L_{\\mathrm{crit}}$ 来打破平局，如果需要，再选择最小的 $S^\\star$。这会产生一个明确定义的估计值 $(\\widehat{L}_{\\mathrm{crit}},\\widehat{S}^\\star)$。\n- 固定 $(\\widehat{L}_{\\mathrm{crit}},\\widehat{S}^\\star)$ 后，我们预测验证年份并计算平均绝对误差\n$$\n\\mathrm{MAE} \\;=\\; \\frac{1}{|\\mathcal{Y}_{\\mathrm{val}}|} \\sum_{y\\in\\mathcal{Y}_{\\mathrm{val}}} \\left| D_y(\\widehat{L}_{\\mathrm{crit}},\\widehat{S}^\\star) - D^{\\mathrm{obs}}_y \\right|.\n$$\n\n为提高效率和正确性的算法设计说明：\n- 对每个数据集和每年 $y$，预先计算 $d\\in\\{1,\\dots,365\\}$ 上关于 $\\delta(d)$、$P(d,\\lambda)$、$T(y,d)$ 和 $\\mathrm{GDD}(y,d)$ 的数组。这消除了参数搜索内部的冗余计算。\n- 对于任意给定的 $L_{\\mathrm{crit}}$，构造一个二元掩码 $M_{y,d}=\\mathbf{1}\\{P(d,\\lambda)\\ge L_{\\mathrm{crit}}\\}$。然后，形成每年的累积和 $C_{y,d}=\\sum_{k=1}^d \\mathrm{GDD}(y,k) M_{y,k}$。对于任何给定的 $S^\\star$，预测的芽开放日 $D_y$ 是满足 $C_{y,d}\\ge S^\\star$ 的最小 $d$，如果不存在这样的日期，则为 $366$。\n- 使用数组编程对跨天和跨年的操作进行矢量化，以高效地评估许多候选对 $(L_{\\mathrm{crit}}, S^\\star)$。检测超过阈值的第一天的内部逻辑可以通过形成一个布尔数组并提取第一个真值索引来实现；数值安全检查处理阈值从未达到的情况。\n- 因为观测数据是由相同的结构模型生成的，其“真实”参数并不精确地位于校准网格上（例如，数据集A中的 $L_{\\mathrm{crit,true}}=11.25$ 小时和 $S^\\star_{\\mathrm{true}}=123.5$ 积温日），所以校准后的参数将近似但不会完全匹配真实值，验证平均绝对误差将很小但非零。\n- 变暖趋势 $\\gamma$ 会导致芽开放随时间提前，模型通过积温累积捕捉到这一点。\n\n最终输出：\n- 对于每个数据集（A、B、C），计算以天为单位的验证平均绝对误差，并四舍五入到两位小数。程序以 $[x_A,x_B,x_C]$ 的形式输出单行，其中每个 $x_\\cdot$ 是以天为单位、四舍五入后的平均绝对误差浮点数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef daylength_hours(doy_array, lat_deg):\n    \"\"\"\n    Compute astronomical daylength in hours for given day-of-year (array-like)\n    and latitude in degrees, using:\n      delta(d) = 0.409 * sin(2*pi*(d - 80)/365)\n      P = (24/pi) * arccos( -tan(phi) * tan(delta) )\n    All trig inputs in radians; clamp arccos argument to [-1, 1].\n    \"\"\"\n    d = np.asarray(doy_array, dtype=float)\n    phi = np.deg2rad(lat_deg)\n    delta = 0.409 * np.sin(2.0 * np.pi * (d - 80.0) / 365.0)\n    arg = -np.tan(phi) * np.tan(delta)\n    arg_clamped = np.clip(arg, -1.0, 1.0)\n    P = (24.0 / np.pi) * np.arccos(arg_clamped)\n    return P\n\ndef daily_temperature(doy_array, year, T_mean, A_amp, phi_T, trend, y_ref):\n    \"\"\"\n    T(y,d) = T_mean + A_amp * sin(2*pi*(d - phi_T)/365) + trend*(y - y_ref)\n    \"\"\"\n    d = np.asarray(doy_array, dtype=float)\n    return T_mean + A_amp * np.sin(2.0 * np.pi * (d - phi_T) / 365.0) + trend * (year - y_ref)\n\ndef compute_budburst_days(gdd_matrix, daylength_matrix, Lcrit, Sstar):\n    \"\"\"\n    Given GDD matrix of shape (nyears, 365) and daylength matrix (nyears, 365),\n    compute the budburst day for each year using photoperiod gate Lcrit (hours)\n    and degree-day threshold Sstar.\n    Returns an array of shape (nyears,) with day-of-year (1..365) or 366 if not reached.\n    \"\"\"\n    mask = (daylength_matrix >= Lcrit).astype(float)  # 1 where accumulation allowed\n    # cumulative sum of gated GDDs across days\n    cum = np.cumsum(gdd_matrix * mask, axis=1)\n    # For each row, find first day where cum >= Sstar\n    meets = cum >= Sstar\n    # If a row has no True, argmax will return 0, so we must check any True\n    first_idx = meets.argmax(axis=1)  # 0-based indices\n    has_true = meets.any(axis=1)\n    # Convert to day-of-year: add 1 to indices; if never met, set to 366\n    doy = first_idx + 1\n    doy = np.where(has_true, doy, 366)\n    return doy\n\ndef calibrate_parameters(train_years, gdd_by_year, daylen_by_year, obs_train,\n                         Lcrit_grid, Sstar_grid):\n    \"\"\"\n    Brute-force grid search over Lcrit_grid (hours) and Sstar_grid (degree-days)\n    to minimize sum of squared errors on training years.\n    gdd_by_year, daylen_by_year: dict year -> array (365,)\n    obs_train: dict year -> observed doy\n    Returns (best_Lcrit, best_Sstar).\n    Tie-breaking: smallest Lcrit, then smallest Sstar.\n    \"\"\"\n    # Stack training matrices in consistent order\n    years = np.array(sorted(train_years))\n    gdd_mat = np.vstack([gdd_by_year[y] for y in years])  # (n_train, 365)\n    daylen_mat = np.vstack([daylen_by_year[y] for y in years])\n    obs_vec = np.array([obs_train[y] for y in years], dtype=float)\n\n    best_loss = np.inf\n    best_L = None\n    best_S = None\n\n    # Precompute nothing else; loop over grids with vectorized cumcalc inside\n    for L in Lcrit_grid:\n        # Gate for current L\n        mask = (daylen_mat >= L).astype(float)\n        gated = gdd_mat * mask\n        cum = np.cumsum(gated, axis=1)\n        # For each Sstar candidate, compute predictions and loss\n        # We can vectorize over Sstar by checking thresholds separately\n        for S in Sstar_grid:\n            meets = cum >= S\n            first_idx = meets.argmax(axis=1)\n            has_true = meets.any(axis=1)\n            pred = first_idx + 1\n            pred = np.where(has_true, pred, 366)\n            # Loss: sum of squared errors\n            diff = pred.astype(float) - obs_vec\n            loss = float(np.sum(diff * diff))\n            if loss  best_loss or (loss == best_loss and (best_L is None or L  best_L or (L == best_L and S  best_S))):\n                best_loss = loss\n                best_L = L\n                best_S = S\n\n    return best_L, best_S\n\ndef solve():\n    # Constants and configuration per problem statement\n    Tb = 5.0  # degrees Celsius\n    phi_T = 173.0  # phase shift (day of year)\n    y_ref = 2000\n    train_years = list(range(2001, 2007))  # 2001..2006\n    val_years = list(range(2007, 2011))    # 2007..2010\n    all_years = train_years + val_years\n    days = np.arange(1, 366, dtype=float)\n\n    # Datasets A, B, C definitions\n    datasets = [\n        {\n            \"name\": \"A\",\n            \"lat\": 45.0,\n            \"T_mean\": 8.0,\n            \"A_amp\": 15.0,\n            \"trend\": 0.10,\n            \"Lcrit_true\": 11.25,\n            \"Sstar_true\": 123.5,\n        },\n        {\n            \"name\": \"B\",\n            \"lat\": 60.0,\n            \"T_mean\": 2.0,\n            \"A_amp\": 20.0,\n            \"trend\": 0.20,\n            \"Lcrit_true\": 13.15,\n            \"Sstar_true\": 161.8,\n        },\n        {\n            \"name\": \"C\",\n            \"lat\": 30.0,\n            \"T_mean\": 18.0,\n            \"A_amp\": 10.0,\n            \"trend\": 0.05,\n            \"Lcrit_true\": 9.85,\n            \"Sstar_true\": 82.3,\n        },\n    ]\n\n    # Calibration grids\n    Lcrit_grid = np.round(np.arange(9.0, 14.5 + 1e-9, 0.1), 2)  # hours\n    Sstar_grid = np.arange(60.0, 220.0 + 1e-9, 1.0)  # degree-days\n\n    results = []\n\n    for dset in datasets:\n        lat = dset[\"lat\"]\n        T_mean = dset[\"T_mean\"]\n        A_amp = dset[\"A_amp\"]\n        trend = dset[\"trend\"]\n        Lcrit_true = dset[\"Lcrit_true\"]\n        Sstar_true = dset[\"Sstar_true\"]\n\n        # Precompute daylength array for all days (independent of year)\n        P_days = daylength_hours(days, lat)\n\n        # Precompute per-year arrays: temperature, GDD, and daylength broadcast\n        gdd_by_year = {}\n        daylen_by_year = {}\n        obs_by_year = {}\n\n        # Observations are generated using true parameters and the same forcing rule\n        for y in all_years:\n            Tyd = daily_temperature(days, y, T_mean, A_amp, phi_T, trend, y_ref)\n            GDD = np.maximum(0.0, Tyd - Tb)\n            gdd_by_year[y] = GDD\n            daylen_by_year[y] = P_days.copy()\n        # Generate observed budburst days using true parameters\n        for y in all_years:\n            # compute budburst by threshold crossing using true params\n            # reuse compute_budburst_days with single-year arrays\n            gdd_mat = np.expand_dims(gdd_by_year[y], axis=0)\n            daylen_mat = np.expand_dims(daylen_by_year[y], axis=0)\n            obs_doy = compute_budburst_days(gdd_mat, daylen_mat, Lcrit_true, Sstar_true)[0]\n            obs_by_year[y] = int(obs_doy)\n\n        # Prepare training observation vector\n        obs_train = {y: obs_by_year[y] for y in train_years}\n\n        # Calibrate over the grid\n        best_Lcrit, best_Sstar = calibrate_parameters(\n            train_years, gdd_by_year, daylen_by_year, obs_train, Lcrit_grid, Sstar_grid\n        )\n\n        # Validate\n        # Build matrices for validation years\n        gdd_mat_val = np.vstack([gdd_by_year[y] for y in val_years])\n        daylen_mat_val = np.vstack([daylen_by_year[y] for y in val_years])\n        pred_val = compute_budburst_days(gdd_mat_val, daylen_mat_val, best_Lcrit, best_Sstar)\n        obs_val = np.array([obs_by_year[y] for y in val_years], dtype=float)\n        mae = float(np.mean(np.abs(pred_val.astype(float) - obs_val)))\n\n        # Round to two decimals as required\n        results.append(f\"{mae:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2598656"}]}