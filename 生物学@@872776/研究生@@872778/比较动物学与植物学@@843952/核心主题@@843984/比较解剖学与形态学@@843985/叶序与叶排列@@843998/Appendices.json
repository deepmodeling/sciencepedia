{"hands_on_practices": [{"introduction": "植物器官在三维曲面（顶端分生组织）上起始，但我们通常通过二维图像（投影）来研究它们。本练习旨在通过几何推导，阐明在圆锥体分生组织模型上，固有的发散角如何转化为在二维平面投影上观察到的有效发散角。掌握这一关系是连接三维生长过程与二维图案分析的基础，对于深刻理解叶序的形态建成至关重要。[@problem_id:2597306]", "problem": "在关于顶端分生组织的叶序比较研究中，顶尖通常被近似为一个正圆锥面。考虑一个轴线垂直、顶角为 $\\beta \\in (0,\\pi)$ 的正圆锥。令 $\\alpha = \\beta/2$ 表示母线与轴线之间的半角。假设原基在距顶点一个固定的斜高 $\\ell$ 处产生，其恒定的内在辐散角增量为 $\\phi \\in (0,2\\pi)$，该增量是在圆锥面上通过等距展开到平面上测量的（也就是说，如果将圆锥沿一条母线切开并无拉伸地展开，那么在展开后的平面上，连续两个原基之间的角增量为 $\\phi$）。\n\n你通过到水平面的正交投影（俯视图）来观察该模式。有效辐散角 $\\delta_{\\mathrm{eff}}$ 定义为连续两个原基的投影之间，围绕圆锥轴线的方位角增量。仅使用可展曲面的基本几何学和等距展开下的弧长守恒原理，推导出 $\\delta_{\\mathrm{eff}}$ 作为 $\\beta$ 和 $\\phi$ 的闭式函数，并给出该角度在区间 $[0,2\\pi)$ 内的主值。\n\n将你的最终答案表示为单一的、以弧度为单位的闭式解析表达式。如果需要对 $2\\pi$ 取模，请在表达式中返回 $[0,2\\pi)$ 区间内的主值，不要使用百分号。不要四舍五入。", "solution": "对所述问题进行验证。\n\n**第1步：提取已知条件**\n- 几何形状：轴线垂直的正圆锥。\n- 顶角：$\\beta \\in (0, \\pi)$。\n- 半角：$\\alpha = \\beta/2$。\n- 原基轨迹：在距顶点恒定斜高 $\\ell$ 处的一个圆。\n- 内在辐散：连续原基之间恒定的角增量 $\\phi \\in (0, 2\\pi)$，在圆锥等距展开（展开）后的平面上测量。\n- 观察方式：到水平面的正交投影（俯视图）。\n- 待求量：有效辐散角 $\\delta_{\\mathrm{eff}}$，定义为连续两个原基投影之间的方位角增量。\n- 要求输出形式：$\\delta_{\\mathrm{eff}}$ 作为 $\\beta$ 和 $\\phi$ 的函数的闭式表达式，其主值在 $[0, 2\\pi)$ 区间内。\n\n**第2步：验证**\n该问题具有科学依据，它使用可展曲面的标准几何原理为叶序建模。该问题是良定的，提供了所有必要信息，且无内部矛盾。其语言客观而精确。该问题是微分几何及其在生物模型中应用的一个标准练习题。它通过了所有有效性标准。\n\n**结论：** 问题有效。将推导解答。\n\n推导过程如下。\n\n设该圆锥位于一个三维笛卡尔坐标系中，其顶点在原点 $(0, 0, 0)$，对称轴与 z 轴正半轴对齐。圆锥的半角，即 z 轴与任意母线之间的夹角，为 $\\alpha = \\beta/2$。\n\n圆锥表面上距顶点斜高为 $\\ell$ 的一点，其柱坐标为 $(r, \\theta, z)$，其中 $r$ 是与 z 轴的径向距离，$\\theta$ 是方位角。这些坐标通过以下关系与 $\\ell$ 和 $\\alpha$ 相关联：\n$$r = \\ell \\sin(\\alpha)$$\n$$z = \\ell \\cos(\\alpha)$$\n在此斜高 $\\ell$ 处，圆锥的圆形横截面周长为 $C = 2\\pi r = 2\\pi \\ell \\sin(\\alpha)$。\n\n圆锥是一个可展曲面。它可以沿一条母线切开，并无拉伸或撕裂地展开到一个平面上，这个过程被称为等距展开。得到的平面图形是一个扇形。这个扇形的半径，我们记为 $R_{\\text{sector}}$，等于圆锥的斜高 $\\ell$。该扇形的弧长 $S_{\\text{sector}}$ 必须等于它展开前所在的圆锥底面周长 $C$。该扇形的圆心角，我们记为 $\\Theta_{\\text{total}}$，通过 $S_{\\text{sector}} = R_{\\text{sector}} \\Theta_{\\text{total}}$ 与其半径和弧长相关联。\n\n根据弧长守恒，我们有：\n$$S_{\\text{sector}} = C$$\n$$\\ell \\Theta_{\\text{total}} = 2\\pi \\ell \\sin(\\alpha)$$\n解出扇形的总角可得：\n$$\\Theta_{\\text{total}} = 2\\pi \\sin(\\alpha)$$\n这个基本关系建立了圆锥几何与其平面展开图之间的映射。圆锥方位角上对应 $2\\pi$ 弧度的一次完整旋转，映射到展开扇形中一个大小为 $\\Theta_{\\text{total}} = 2\\pi \\sin(\\alpha)$ 弧度的角。\n\n问题陈述，当在展开后的平面上测量时，两个连续原基 $P_n$ 和 $P_{n+1}$ 之间的内在辐散角增量是一个恒定角 $\\phi$。设展开平面上原基的角间距为 $\\Delta\\varphi = \\phi$。\n\n有效辐散角 $\\delta_{\\mathrm{eff}}$ 是在三维圆锥上对应的方位角间距 $\\Delta\\theta$。由于圆锥和其平面扇形之间的等距映射具有线性特性，展开平面上的任意角区间与圆锥上对应的方位角区间的比率是恒定的。该比率等于总角的比率：\n$$\\frac{\\Delta\\theta}{\\Delta\\varphi} = \\frac{2\\pi}{\\Theta_{\\text{total}}}$$\n代入表达式 $\\Delta\\theta = \\delta_{\\mathrm{eff}}$、$\\Delta\\varphi = \\phi$ 和 $\\Theta_{\\text{total}} = 2\\pi \\sin(\\alpha)$，我们得到：\n$$\\frac{\\delta_{\\mathrm{eff}}}{\\phi} = \\frac{2\\pi}{2\\pi \\sin(\\alpha)} = \\frac{1}{\\sin(\\alpha)}$$\n由此，我们推导出有效辐散角的表达式：\n$$\\delta_{\\mathrm{eff}} = \\frac{\\phi}{\\sin(\\alpha)}$$\n\n问题以顶角 $\\beta$ 的形式指定输入，其中 $\\alpha = \\beta/2$。将此代入我们的表达式可得：\n$$\\delta_{\\mathrm{eff}} = \\frac{\\phi}{\\sin(\\beta/2)}$$\n\n最终要求是提供该角的主值，该主值必须位于区间 $[0, 2\\pi)$ 内。计算出的 $\\delta_{\\mathrm{eff}}$ 值可能超过 $2\\pi$，因为对于 $\\beta \\in (0, \\pi)$，有 $\\phi \\in (0, 2\\pi)$ 且 $\\sin(\\beta/2) \\in (0, 1)$。为了找到主值，我们必须计算结果对 $2\\pi$ 取模。对于任意实数 $x$，其在区间 $[0, 2\\pi)$ 内对 $2\\pi$ 取模的值由表达式 $x - 2\\pi k$ 给出，其中 $k$ 为选定的整数，使得 $0 \\le x - 2\\pi k  2\\pi$。这个整数是 $k = \\lfloor x / (2\\pi) \\rfloor$，其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数。\n\n将此应用于我们的 $\\delta_{\\mathrm{eff}}$ 表达式，令 $x = \\frac{\\phi}{\\sin(\\beta/2)}$。因此，主值为：\n$$\\delta_{\\mathrm{eff, principal}} = \\frac{\\phi}{\\sin(\\beta/2)} - 2\\pi \\left\\lfloor \\frac{\\phi}{2\\pi \\sin(\\beta/2)} \\right\\rfloor$$\n这就是有效辐散角作为 $\\beta$ 和 $\\phi$ 的函数的最终闭式表达式。", "answer": "$$\n\\boxed{\\frac{\\phi}{\\sin(\\beta/2)} - 2\\pi \\left\\lfloor \\frac{\\phi}{2\\pi \\sin(\\beta/2)} \\right\\rfloor}\n$$", "id": "2597306"}, {"introduction": "在理解了叶序图案的几何基础之后，下一步是建立一个可执行的计算模型。本练习要求您实现一个“生成螺线”算法，该算法以恒定的发散角 $\\alpha$ 和时序比 $\\rho$ 来模拟原基的依次出现，并随后应用一个基于距离的标准来从生成的点阵中计算出主导的斜列线对。这项练习提供了叶序正向建模的动手经验，让您能够将抽象的理论参数转化为具体、可分析的视觉图案，从而培养模拟生物发育过程的核心计算技能。[@problem_id:2597254]", "problem": "给定一个叶序模型，其中连续的原基以恒定的发散角和恒定的时序比生成。原基在极坐标中被建模为平面上的点，其中第 $n$ 个原基的角度为 $\\theta_n$，半径为 $r_n$。发散角是一个以度为单位指定的常数 $\\alpha$，时序比是一个常数 $\\rho  1$（无量纲），使得每个连续的半径按 $\\rho$ 的比例缩放。请使用以下基本定义和经验支持的事实：\n\n- 第 $n$ 个原基放置在极坐标 $(r_n, \\theta_n)$ 处，其中\n  $$r_n = r_0 \\,\\rho^n \\quad \\text{和} \\quad \\theta_n = n\\,\\alpha,$$\n  $r_0  0$ 是一个任意的参考半径。对于所有计算，您必须取 $r_0 = 1$，因为在下面的判据中只有相对距离是重要的。\n- 用于任何三角计算的角度都必须是弧度。发散角 $\\alpha$ 以度为单位提供，必须在内部转换为弧度，即 $\\alpha_{\\mathrm{rad}} = \\alpha \\cdot \\pi/180$。\n- 对于由索引偏移量 $k \\in \\mathbb{Z}_{0}$ 分隔的任意两个原基，通过将角度包裹到区间 $[-\\pi,\\pi]$ 来定义主（要）角差 $\\Delta\\theta_k \\in [0,\\pi]$：\n  $$\\Delta\\theta_k = \\min\\left(\\left| \\left(k\\,\\alpha_{\\mathrm{rad}} + \\pi \\right) \\bmod 2\\pi - \\pi \\right|, \\, \\pi \\right)。$$\n- 在平面欧几里得几何中，两点 $(r_1,\\theta_1)$ 和 $(r_2,\\theta_2)$ 之间的距离平方为\n  $$d^2 = r_1^2 + r_2^2 - 2 r_1 r_2 \\cos(\\theta_2 - \\theta_1)。$$\n\n根据这些基本原理，可以得出原基 $n$ 和 $n+k$ 之间的欧几里得距离可以用归一化的无量纲形式（与 $n$ 无关）写出\n$$\\delta_k = \\sqrt{1 + \\rho^{2k} - 2 \\rho^k \\cos(\\Delta\\theta_k)},$$\n这是由于半径按 $\\rho$ 进行对数尺度缩放，距离按 $r_n$ 进行缩放后的结果。\n\n定义主导螺线对 (dominant parastichy pair) 为一对互质的正整数 $(k_1,k_2)$，满足 $1 \\le k_1  k_2 \\le K_{\\max}$，并且使乘积 $\\delta_{k_1}\\,\\delta_{k_2}$ 最小化。这是一个基于距离的判据，它偏好于局部邻域关系晶格中两个最短、独立的螺旋族。按以下顺序的规则解决平局：\n1. 优先选择具有较小 $\\max(k_1,k_2)$ 的对。\n2. 如果仍然平局，优先选择具有较小 $k_2$ 的对。\n3. 如果仍然平局，优先选择具有较小 $k_1$ 的对。\n\n您必须通过上述模型隐式地模拟前 $N$ 个原基，但主导螺线对的计算必须使用归一化距离判据。令\n$$K_{\\max} = \\min(N-1, 60),$$\n这样所有候选的间隔都不会超过可用原基的数量，并在计算上保持有界。\n\n角度单位说明：$\\alpha$ 的所有输入均以度为单位，所有内部三角计算必须以弧度进行。此模型中长度没有物理单位；由于通过 $r_n$ 进行了归一化，距离是无量纲的。\n\n您的任务是编写一个完整的、可运行的程序，对于下面的每个测试用例，使用指定的距离判据计算并返回主导螺线对 $(k_1,k_2)$。所有测试用例的最终输出必须汇总到单行中，格式为一个列表的列表，用方括号括起来，例如：“[[k1,k2],[k1,k2],...]”。\n\n测试套件（每个测试用例是一个元组 $(\\alpha,\\rho,N)$）：\n1. $(137.3, 1.08, 100)$\n2. $(137.5, 1.05, 100)$\n3. $(99.5, 1.08, 100)$\n4. $(170.0, 1.12, 100)$\n5. $(137.3, 1.005, 50)$\n6. $(137.3, 1.08, 8)$\n\n输出规范：\n- 对于每个测试用例，将主导螺线对输出为包含两个整数的列表 $[k_1,k_2]$。\n- 将所有测试用例的结果汇总到单行中，打印为列表的列表，例如：“[[a,b],[c,d],...]”，不含任何额外文本。\n\n您的程序不得读取任何输入，并且必须以指定格式精确地产生一行输出。", "solution": "所提出的问题已经过验证，被认定为是**有效**的。它在科学上基于已建立的叶序模型，在数学上定义良好，具有明确的目标函数和约束，并且没有歧义或矛盾。它代表了一个源于发育植物学和几何学原理的正式计算任务。因此，我将继续提供一个完整的解决方案。\n\n该解决方案被设计成一个确定性算法，它实现了用于识别主导螺线对的指定判据。该方法分为三个主要阶段：参数初始化、归一化距离的预计算，以及对最优对的系统性搜索。\n\n**1. 参数初始化与常量**\n\n对于由元组 $(\\alpha, \\rho, N)$ 定义的每个给定测试用例，我们首先设置计算所需的参数。\n- 发散角 $\\alpha$ 以度为单位提供，必须转换为弧度才能用于三角函数。转换公式为 $\\alpha_{\\mathrm{rad}} = \\alpha \\cdot \\pi / 180$。\n- 必须根据问题规范确定最大间隔指数 $K_{\\max}$。它定义为 $K_{\\max} = \\min(N-1, 60)$，其中 $N$ 是原基的数量。这将搜索空间限制在一个计算上可管理的大小。对于所有测试用例，$N \\ge 8$，这保证了 $K_{\\max} \\ge 7$，并允许形成满足 $1 \\le k_1  k_2$ 的对 $(k_1, k_2)$。\n\n**2. 归一化距离 $\\delta_k$ 的预计算**\n\n优化判据取决于归一化距离 $\\delta_k$。为避免重复计算，我们为所有相关的间隔指数 $k$（从 $k=1$到 $k=K_{\\max}$）预先计算并存储这些值。对于此范围内的每个整数 $k$，$\\delta_k$ 的值计算如下：\n\n- 首先，计算主（要）角差 $\\Delta\\theta_k$。间隔为 $k$ 个原基的总角度是 $k\\,\\alpha_{\\mathrm{rad}}$。此角度被包裹到区间 $[-\\pi, \\pi]$ 以找到向量之间的最短角度。给定的公式是 $\\left(k\\,\\alpha_{\\mathrm{rad}} + \\pi \\right) \\bmod 2\\pi - \\pi$，它正确地将角度映射到 $[-\\pi, \\pi)$。设这个包裹后的角度为 $\\phi_k$。则主（要）角差是其大小 $\\Delta\\theta_k = |\\phi_k| \\in [0, \\pi]$。\n- 其次，在已知 $\\Delta\\theta_k$ 的情况下，我们使用提供的公式计算归一化距离 $\\delta_k$，该公式源于对数增长螺旋中的余弦定理：\n$$\n\\delta_k = \\sqrt{1 + \\rho^{2k} - 2 \\rho^k \\cos(\\Delta\\theta_k)}\n$$\n这些值存储在一个数组中，以便在搜索阶段进行高效查找。\n\n**3. 对主导螺线对的系统性搜索**\n\n问题的核心是找到满足一组分层判据的特定整数对 $(k_1, k_2)$。该对必须由一对互质整数 $k_1$ 和 $k_2$ 组成，使得 $1 \\le k_1  k_2 \\le K_{\\max}$。对最优对的搜索通过系统地检查所有有效的候选对来进行。\n\n- 我们遍历所有可能的 $k_2$ 值，从 $2$ 到 $K_{\\max}$，对于每个 $k_2$，我们遍历所有可能的 $k_1$ 值，从 $1$ 到 $k_2-1$。\n- 对于每对 $(k_1, k_2)$，我们进行互质性检验。这通过计算 $k_1$ 和 $k_2$ 的最大公约数 (GCD) 来实现。如果 $\\text{gcd}(k_1, k_2) = 1$，则该对是有效的候选对。\n- 对于每个有效的候选对，我们根据指定的判据评估其“质量”。主要判据是最小化归一化距离的乘积 $P = \\delta_{k_1} \\delta_{k_2}$。次要和第三判据是决胜规则：如果乘积相等，则优先选择具有较小 $\\max(k_1, k_2)$（等同于较小的 $k_2$）的对，然后是较小的 $k_1$。\n- 这个分层优化问题可以通过找到一个元组的最小值来优雅地解决。对于每个候选对 $(k_1, k_2)$，我们形成一个元组 $(P, k_2, k_1)$。我们维护一个迄今为止找到的“最佳”元组，并在新的候选对产生一个字典序更小的元组时更新它。对 $(P, k_2, k_1)$ 的字典序比较自然地强制执行了首先最小化 $P$，其次最小化 $k_2$，最后最小化 $k_1$ 的规则。\n\n算法以一个初始的“最佳”元组 $(\\infty, \\infty, \\infty)$ 开始。在检查了所有有效对之后，与最终“最佳”元组对应的对 $(k_1, k_2)$ 就是主导螺线对。对每个测试用例执行此过程，并将结果汇总成指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef compute_dominant_parastichy(alpha_deg, rho, N):\n    \"\"\"\n    Computes the dominant parastichy pair (k1, k2) for a given phyllotactic model.\n\n    Args:\n        alpha_deg (float): The divergence angle in degrees.\n        rho (float): The plastochron ratio.\n        N (int): The number of primordia.\n\n    Returns:\n        list: A list of two integers [k1, k2] representing the dominant pair.\n    \"\"\"\n    # 1. Parameter Initialization and Constants\n    alpha_rad = np.deg2rad(alpha_deg)\n    K_max = min(N - 1, 60)\n\n    # A pair (k1, k2) requires k2 >= 2, so K_max must be at least 2.\n    if K_max  2:\n        return None  # No valid pairs can be formed.\n\n    # 2. Pre-computation of Normalized Distances delta_k\n    # delta_k array is 1-indexed for convenience (index k maps to delta_k).\n    delta_k = np.zeros(K_max + 1)\n    for k in range(1, K_max + 1):\n        # Calculate the principal angular difference in [0, pi].\n        total_angle = k * alpha_rad\n        # Wrap angle to [-pi, pi) using the specified formula's logic.\n        # This is a standard and robust way to perform angle wrapping in programming.\n        wrapped_angle = (total_angle + np.pi) % (2 * np.pi) - np.pi\n        delta_theta_k = np.abs(wrapped_angle)\n\n        # Calculate the normalized distance delta_k.\n        cos_val = np.cos(delta_theta_k)\n        rho_k = np.power(rho, k)\n        rho_2k = np.power(rho, 2 * k) # or rho_k**2\n        delta_k[k] = np.sqrt(1 + rho_2k - 2 * rho_k * cos_val)\n\n    # 3. Systematic Search for the Dominant Parastichy Pair\n    best_tuple = (float('inf'), float('inf'), float('inf'))\n    best_pair = None\n\n    # Iterate through all candidate pairs (k1, k2) with 1 = k1  k2 = K_max.\n    for k2 in range(2, K_max + 1):\n        for k1 in range(1, k2):\n            # Check for coprimality.\n            if math.gcd(k1, k2) == 1:\n                # Calculate the product of normalized distances.\n                product = delta_k[k1] * delta_k[k2]\n                \n                # Form a tuple for lexicographical comparison.\n                # This elegantly handles the minimization criterion and tie-breaking rules:\n                # 1. Minimize product.\n                # 2. Minimize max(k1, k2) -> k2.\n                # 3. Minimize k1.\n                current_tuple = (product, k2, k1)\n                \n                if current_tuple  best_tuple:\n                    best_tuple = current_tuple\n                    best_pair = [k1, k2]\n    \n    return best_pair\n\ndef solve():\n    \"\"\"\n    Runs the defined test suite and prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (137.3, 1.08, 100),\n        (137.5, 1.05, 100),\n        (99.5, 1.08, 100),\n        (170.0, 1.12, 100),\n        (137.3, 1.005, 50),\n        (137.3, 1.08, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, rho, N = case\n        result = compute_dominant_parastichy(alpha, rho, N)\n        # The str() of a list is its representation, e.g., \"[5, 8]\".\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2597254"}, {"introduction": "虽然正向模型（从参数到模式）是基础，但真正的生物学研究挑战往往在于逆向工程：从观察到的最终形态推断其背后的发育规则，即解决“逆问题”。这项高级练习要求您根据在成熟结构不同半径处观察到的斜列线计数，反向推断出全局唯一的发散角以及随发育变化的生长速率（时序比）轨迹。解决这个逆问题可以锻炼您处理复杂生物数据和进行模型参数估计的精密计算与分析能力，这正是定量生物学研究的核心实践。[@problem_id:2597382]", "problem": "您必须编写一个完整、可运行的程序。该程序在给定螺旋状叶序模式中多个半径上观测到的左手和右手旁列线数量的情况下，根据生成螺旋模型，推断出单个全局发散角以及跨越给定半径的单调不减的时差比轨迹。所需的输出是单行文本，它聚合了所有给定测试用例的数值答案。\n\n其基本基础是叶序的生成螺旋模型。在此模型中，原基由整数 $k \\in \\mathbb{Z}$ 索引，其极坐标 $(\\rho_k,\\varphi_k)$ 由下式给出：\n$\\rho_k = \\rho_0 \\, a^k$ 和 $\\varphi_k = k \\, \\theta$，\n其中 $\\rho_0 \\gt 0$ 是一个尺度常数，$a \\gt 0$ 是时差比，$\\theta \\in (0,2\\pi)$ 是发散角。由 $q \\in \\mathbb{N}$ 个索引分隔的两个原基，即 $k$ 和 $k+q$，其归一化欧几里得间隔（弦长）仅取决于 $a$、$\\theta$ 和 $q$，通过将欧几里得距离除以 $\\rho_k$ 得到：\n$$\n\\delta(q; a, \\theta) \\;=\\; \\sqrt{1 + a^{2q} - 2\\,a^q \\cos(q \\,\\theta)}.\n$$\n对于给定的配对 $(a,\\theta)$，可见的旁列线数量被建模为在 $q \\in \\{1,2,\\dots,Q_{\\max}\\}$ 上最小化 $\\delta(q; a,\\theta)$ 的两个值 $m,n \\in \\{1,2,\\dots,Q_{\\max}\\}$，其中平局情况以任意但一致的方式解决，并且 $m$ 和 $n$ 之间的顺序不重要（它们是一组两个计数）。在经典叶序学中，当 $\\theta/(2\\pi)$ 是无理数时，这些 $m$ 和 $n$ 通常对应于 $\\theta/(2\\pi)$ 的连分数展开中两个连续收敛项的分母，当 $\\theta$ 接近黄金角时，通常会产生连续的斐波那契数，但对于此任务，您必须仅使用上述基于距离的定义。\n\n逆问题陈述与约束：\n- 对于每个测试用例 $j$，您会得到一个严格递增的半径列表 $\\{r_{j,i}\\}_{i=1}^{M_j}$ 以及相关的观测到的无序旁列线对 $\\{ \\{L_{j,i},R_{j,i}\\} \\}_{i=1}^{M_j}$，其中每个 $L_{j,i}, R_{j,i} \\in \\mathbb{N}$。\n- 假设测试用例 $j$ 有一个单一的全局发散角 $\\theta_j$，以及一个时差比序列 $\\{a_{j,i}\\}_{i=1}^{M_j}$（每个半径样本一个值），使得 $a_{j,1} \\le a_{j,2} \\le \\cdots \\le a_{j,M_j}$（随半径指数的增加而单调不减）。\n- 对于每个 $i$，无序对 $\\{L_{j,i},R_{j,i}\\}$ 必须等于在 $q \\in \\{1,2,\\dots,Q_{\\max}\\}$ 上最小化 $\\delta(q;a_{j,i},\\theta_j)$ 的两个 $q$ 值的无序集合。\n- 您必须将搜索范围限制在 $a_{j,i} \\in [a_{\\min}, a_{\\max}]$（其中 $a_{\\min} = 1.01$，$a_{\\max} = 1.30$）和 $\\theta_j \\in [\\theta_{\\min}, \\theta_{\\max}]$（其中 $\\theta_{\\min} = 130^\\circ$，$ \\theta_{\\max} = 150^\\circ$）。\n- 使用 $Q_{\\max} = 34$。\n\n多可行解选择的唯一性规则：对于每个测试用例 $j$，在所有允许至少一个在 $[a_{\\min},a_{\\max}]^{M_j}$ 内满足配对匹配约束的非递减序列 $\\{a_{j,i}\\}_{i=1}^{M_j}$ 的 $\\theta_j \\in [\\theta_{\\min},\\theta_{\\max}]$ 中，选择那个能最大化子集测度（长度）在 $i=1,\\dots,M_j$ 上的总和的 $\\theta_j$，其中该子集是 $[a_{\\min},a_{\\max}]$ 中满足第 $i$ 个观测对的集合。如果有多个 $\\theta_j$ 值并列，则选择其中最小的 $\\theta_j$。对于所选的 $\\theta_j$，在可行子集内选择逐点最小（贪心、最左）的非递减序列 $\\{a_{j,i}\\}_{i=1}^{M_j}$。\n\n角度单位与舍入规则：\n- 以度为单位报告每个 $\\theta_j$。将报告的每个 $\\theta_j$ 四舍五入到三位小数。\n- 以无单位比率报告每个 $a_{j,i}$。将报告的每个 $a_{j,i}$ 四舍五入到三位小数。\n\n测试套件：\n- 情况 1：半径 $\\{r_{1,i}\\} = [\\,1.0,\\,1.5,\\,2.0,\\,3.0\\,]$，观测对 $\\{ \\{L_{1,i},R_{1,i}\\} \\} = [\\,\\{8,13\\},\\,\\{5,8\\},\\,\\{3,5\\},\\,\\{2,3\\}\\,]$。\n- 情况 2：半径 $\\{r_{2,i}\\} = [\\,1.0,\\,2.0\\,]$，观测对 $\\{ \\{L_{2,i},R_{2,i}\\} \\} = [\\,\\{5,8\\},\\,\\{3,5\\}\\,]$。\n- 情况 3：半径 $\\{r_{3,i}\\} = [\\,1.0\\,]$，观测对 $\\{ \\{L_{3,1},R_{3,1}\\} \\} = [\\,\\{1,2\\}\\,]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有三个情况的结果，按顺序连接，作为用方括号括起来的逗号分隔列表。对于具有 $M_j$ 个半径的情况 $j$，输出 $M_j+1$ 个数字：首先是推断的 $\\theta_j$（以度为单位，四舍五入到三位小数），然后是 $M_j$ 个推断的时差比 $a_{j,1},\\dots,a_{j,M_j}$（每个都四舍五入到三位小数）。将这些用于 $j=1,2,3$ 的序列连接起来，并作为一个扁平列表输出。示例示意格式（使用占位符）：\n\"[theta1_deg,a11,a12,...,theta2_deg,a21,a22,...,theta3_deg,a31,...]\"。\n所有角度必须以度为单位，所有比率必须四舍五入到三位小数。不应打印其他任何文本。\n\n您的程序不得读取任何输入，也不得执行任何文件或网络输入/输出。它必须仅根据上述定义、约束和提供的测试套件来计算输出。", "solution": "用户提交了一个数学植物学领域的问题，具体涉及叶序的逆问题。任务是从观测数据中推断模型参数。\n\n### 步骤 1：提取已知条件\n\n- **生成螺旋模型**：由整数 $k \\in \\mathbb{Z}$ 索引的原基具有极坐标 $(\\rho_k, \\varphi_k)$，其中 $\\rho_k = \\rho_0 a^k$ 和 $\\varphi_k = k \\theta$。参数是时差比 $a  0$ 和发散角 $\\theta \\in (0, 2\\pi)$。\n- **归一化弦长距离**：原基 $k$ 和 $k+q$ 之间的间隔由 $\\delta(q; a, \\theta) = \\sqrt{1 + a^{2q} - 2a^q \\cos(q\\theta)}$ 给出。\n- **旁列线对定义**：对于给定的 $(a, \\theta)$，可见的旁列线数量是来自 $\\{1, 2, \\dots, Q_{\\max}\\}$ 的两个整数 $\\{m, n\\}$，它们最小化 $\\delta(q; a, \\theta)$。\n- **最大旁列线阶数**：$Q_{\\max} = 34$。\n- **逆问题数据**：对于每个测试用例 $j$，提供了一组 $M_j$ 个观测值，包括严格递增的半径 $\\{r_{j,i}\\}_{i=1}^{M_j}$ 和相应的无序旁列线对 $\\{\\{L_{j,i}, R_{j,i}\\}\\}_{i=1}^{M_j}$。\n- **参数约束**：每个用例假定一个单一的全局发散角 $\\theta_j$。时差比 $\\{a_{j,i}\\}_{i=1}^{M_j}$ 必须随观测索引 $i$ 单调不减，即 $a_{j,1} \\le a_{j,2} \\le \\dots \\le a_{j,M_j}$。\n- **搜索空间**：参数被约束在 $a_{j,i} \\in [1.01, 1.30]$ 和 $\\theta_j \\in [130^\\circ, 150^\\circ]$。\n- **唯一性规则**：\n    1.  只考虑那些允许至少一个有效的非递减序列 $\\{a_{j,i}\\}$ 的 $\\theta_j$ 值。\n    2.  在这些可行的 $\\theta_j$ 中，选择最大化得分 $S(\\theta_j) = \\sum_{i=1}^{M_j} \\text{measure}(A_i(\\theta_j))$ 的那一个，其中 $A_i(\\theta_j)$ 是 $a \\in [1.01, 1.30]$ 中能预测出 $\\{L_{j,i}, R_{j,i}\\}$ 对的集合。\n    3.  如果多个 $\\theta_j$ 值产生最大得分，则选择最小的 $\\theta_j$。\n    4.  对于选定的 $\\theta_j$，解序列 $\\{a_{j,i}\\}$ 是满足约束的“逐点最小（贪心、最左）”的非递减序列。\n- **输出格式**：$\\theta_j$ 以度为单位，保留三位小数；$a_{j,i}$ 为无单位比率，保留三位小数。所有用例的结果连接成一个扁平列表。\n- **测试套件**：\n    - 情况 1：半径 $\\{1.0, 1.5, 2.0, 3.0\\}$，配对 $[\\{8,13\\}, \\{5,8\\}, \\{3,5\\}, \\{2,3\\}]$。\n    - 情况 2：半径 $\\{1.0, 2.0\\}$，配对 $[\\{5,8\\}, \\{3,5\\}]$。\n    - 情况 3：半径 $\\{1.0\\}$，配对 $[\\{1,2\\}]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题基于叶序的经典生成螺旋模型，这是数学植物学中一个成熟且基本的概念。使用距离最小化准则来识别可见旁列线是一种标准技术。该问题具有科学上的严谨性和合理性。\n- **适定性**：该问题是适定的。尽管它是一个复杂的逆问题，但搜索空间是有界的，并且唯一性规则为选择 $\\theta_j$ 提供了明确的目标函数和打破平局的标准。为选择序列 $\\{a_{j,i}\\}$ 而设的附加规则确保了对于任何有效输入都有唯一的、确定性的解。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观论断。所有术语都有正式定义。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。它是一个定义明确、有科学依据的计算任务。所提供的约束和唯一性规则将一个复杂的逆问题构建成一个可解的、尽管计算量可能很大的搜索和优化过程。着手求解。\n\n### 算法解决方案\n\n该问题要求找到与观测数据一致的参数 $(\\theta_j, \\{a_{j,i}\\})$，并遵循一个特定的优化准则。参数与观测到的旁列线对之间的关系高度非线性，这使得直接的解析反演变得不可行。因此，基于对参数空间进行系统性网格搜索的数值方法是最稳健的策略。\n\n**1. 参数空间的离散化**\n将发散角 $\\theta$ 和时差比 $a$ 的连续参数空间离散化为精细的网格。角度 $\\theta$ 从其定义域 $[\\$130^\\circ\\$, \\$150^\\circ\\$]$ 中采样，比率 $a$ 从其定义域 $[\\$1.01\\$, \\$1.30\\$]$ 中采样。这些网格的分辨率决定了搜索的精度。\n\n**2. 前向映射的预计算**\n提高效率的一个关键步骤是预计算前向映射，该映射将离散化网格中的每一对参数 $(\\theta, a)$ 映射到其对应的预测旁列线对。此映射（表示为 $\\mathcal{P}(\\theta, a)$）的构建如下：\n- 对于每个网格点 $(\\theta_k, a_l)$：\n- 计算所有可能的旁列线阶数 $q \\in \\{1, 2, \\dots, Q_{\\max}\\}$ 的归一化弦长距离 $\\delta(q; a_l, \\theta_k)$。\n- 识别出产生两个最小距离的 $q$ 值。这两个值构成了无序旁列线对 $\\mathcal{P}(\\theta_k, a_l)$。\n整个映射存储在一个查找表（一个多维数组）中，从而可以以常数时间检索任何网格点的预测对。\n\n**3. 解决测试用例**\n对于每个测试用例，算法遍历搜索网格中所有离散的 $\\theta_k$ 值，以根据问题的规则找到最优值。\n\n**3.1. $\\theta_k$ 的可行性与评分**\n对于一个给定的候选角度 $\\theta_k$：\n- 首先，通过查询预计算的映射 $\\mathcal{P}$，为每个观测 $i$ 确定可行的时差比集合 $A_i(\\theta_k)$。$A_i(\\theta_k)$ 包含网格上所有使 $\\mathcal{P}(\\theta_k, a_l)$ 与第 $i$ 个观测旁列线对匹配的 $a_l$ 值。\n- 然后，检查 $\\theta_k$ 的可行性。一个角度是可行的，当且仅当存在至少一个单调不减的序列 $\\{a_{j,i}\\}$，其中每个 $a_{j,i}$ 都从其各自的可行集 $A_i(\\theta_k)$ 中选择。这可以通过贪心测试来验证：必须能够从 $A_1(\\theta_k)$ 中选择一个 $a_1$，然后从 $A_2(\\theta_k)$ 中选择一个 $a_2 \\ge a_1$，以此类推，对所有观测都如此。如果这样的路径不存在，则丢弃 $\\theta_k$。\n- 如果 $\\theta_k$ 是可行的，则计算其得分 $S(\\theta_k)$，即为可行集测度之和，$S(\\theta_k) = \\sum_i \\text{measure}(A_i(\\theta_k))$。在我们的离散模型中，测度与每个集合中网格点的数量成正比。\n\n**3.2. 最优角度 $\\theta_j^*_j$ 的选择**\n算法维护迄今为止找到的得分最高的那个可行角度。从最小到最大遍历 $\\theta_k$ 的过程自然地处理了平局规则，该规则要求在得分相同时选择最小的角度。\n\n**4. 时差比 $\\{a_{j,i}\\}^*_{j,i}$ 的确定**\n一旦确定了测试用例的最优角度 $\\theta_j^*$，就构建相应的时差比序列 $\\{a_{j,i}\\}^*$。这是通过应用“逐点最小（贪心、最左）”规则来完成的：\n- $a_{j,1}^*$ 被选为可行集 $A_1(\\theta_j^*)$ 中的最小值。\n- 对于每个后续观测 $i  1$，$a_{j,i}^*$ 被选为其可行集 $A_i(\\theta_j^*)$ 中大于或等于先前确定的比率 $a_{j,i-1}^*$ 的最小值。\n\n这个确定性过程应用于每个测试用例。然后将得到的最优角度和时差比序列四舍五入到三位小数，并格式化为所需的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the divergence angle and plastochron ratios for phyllotactic patterns.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    Q_MAX = 34\n    A_MIN, A_MAX = 1.01, 1.30\n    THETA_MIN, THETA_MAX = 130.0, 150.0\n\n    # Grid resolution. These values offer a balance between precision and\n    # computational cost (memory and time).\n    NUM_THETA = 2001  # Corresponds to a step of 0.01 degrees\n    NUM_A = 291     # Corresponds to a step of 0.001\n\n    # Create the discretized parameter grids\n    theta_grid = np.linspace(THETA_MIN, THETA_MAX, NUM_THETA, dtype=np.float64)\n    a_grid = np.linspace(A_MIN, A_MAX, NUM_A, dtype=np.float64)\n    q_vals = np.arange(1, Q_MAX + 1, dtype=np.int32)\n\n    # --- Precomputation of the Forward Map ---\n    # This step maps each (theta, a) grid point to its predicted parastichy pair.\n    # Vectorized computation using numpy broadcasting is used for efficiency.\n    \n    # Reshape arrays for broadcasting\n    theta_rad = np.deg2rad(theta_grid).reshape(-1, 1, 1)  # Shape: (NUM_THETA, 1, 1)\n    a_vals_b = a_grid.reshape(1, -1, 1)                  # Shape: (1, NUM_A, 1)\n    q_vals_b = q_vals.reshape(1, 1, -1)                  # Shape: (1, 1, Q_MAX)\n\n    # Calculate delta^2 = 1 + a^(2q) - 2*a^q*cos(q*theta) across the entire grid\n    cos_term = np.cos(q_vals_b * theta_rad)              # Broadcasts to (NUM_THETA, NUM_A, Q_MAX)\n    a_pow_q = a_vals_b ** q_vals_b                       # Broadcasts to (NUM_THETA, NUM_A, Q_MAX)\n    delta_sq = 1 + a_pow_q**2 - 2 * a_pow_q * cos_term   # Shape: (NUM_THETA, NUM_A, Q_MAX)\n\n    # Use argpartition to find the indices of the two smallest delta_sq values for each (theta, a)\n    top_two_indices = np.argpartition(delta_sq, 2, axis=2)[:, :, :2]\n\n    # Retrieve the q values (parastichy numbers) and sort them to create canonical pairs\n    parastichy_map = np.sort(q_vals[top_two_indices], axis=2)\n\n    # --- Test Cases ---\n    test_cases = [\n        [frozenset([8, 13]), frozenset([5, 8]), frozenset([3, 5]), frozenset([2, 3])],\n        [frozenset([5, 8]), frozenset([3, 5])],\n        [frozenset([1, 2])],\n    ]\n\n    final_results_flat = []\n\n    for case_observations in test_cases:\n        best_theta = -1.0\n        max_score = -1\n        best_theta_a_indices_collection = None\n\n        # Iterate through all discrete theta values to find the optimal one\n        for theta_idx, theta in enumerate(theta_grid):\n            \n            # For the current theta, find feasible 'a' indices for each observation\n            all_obs_feasible_a_indices = []\n            for obs_pair in case_observations:\n                sorted_obs_pair = np.array(sorted(list(obs_pair)), dtype=np.int32)\n                matches = np.all(parastichy_map[theta_idx, :, :] == sorted_obs_pair, axis=1)\n                feasible_a_indices = np.where(matches)[0]\n                all_obs_feasible_a_indices.append(feasible_a_indices)\n\n            # Check if a non-decreasing sequence of 'a' values is possible (feasibility)\n            last_a_idx = -1\n            path_possible = True\n            for feasible_indices in all_obs_feasible_a_indices:\n                if feasible_indices.size == 0:\n                    path_possible = False\n                    break\n                # Find the smallest 'a' index for this observation that is = the last one\n                possible_next_indices = feasible_indices[feasible_indices = last_a_idx]\n                if possible_next_indices.size == 0:\n                    path_possible = False\n                    break\n                # We only need to confirm a path exists, using the greedy choice\n                last_a_idx = possible_next_indices[0]\n\n            # If theta is feasible, calculate its score and update the best theta if necessary\n            if path_possible:\n                current_score = sum(len(indices) for indices in all_obs_feasible_a_indices)\n                \n                if current_score  max_score:\n                    max_score = current_score\n                    best_theta = theta\n                    best_theta_a_indices_collection = all_obs_feasible_a_indices\n        \n        # Once optimal theta is found, reconstruct the plastochron ratio sequence\n        final_a_values = []\n        last_a_idx = -1\n        for feasible_indices in best_theta_a_indices_collection:\n            possible_next_indices = feasible_indices[feasible_indices = last_a_idx]\n            chosen_a_idx = possible_next_indices[0]\n            final_a_values.append(a_grid[chosen_a_idx])\n            last_a_idx = chosen_a_idx\n\n        # Append results for the current case to the final list\n        final_results_flat.append(f\"{best_theta:.3f}\")\n        for a_val in final_a_values:\n            final_results_flat.append(f\"{a_val:.3f}\")\n            \n    # Print the final result in the exact required format\n    print(f\"[{','.join(final_results_flat)}]\")\n\nsolve()\n```", "id": "2597382"}]}