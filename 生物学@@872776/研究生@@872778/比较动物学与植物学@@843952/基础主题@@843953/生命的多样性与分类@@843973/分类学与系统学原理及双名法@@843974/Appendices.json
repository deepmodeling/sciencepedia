{"hands_on_practices": [{"introduction": "系统发育分析的第一步是评估我们所拥有的数据。在简约法框架下，并非所有性状都对推断进化关系有同等贡献；只有那些能够支持某种特定分类单元分组的性状，即简约性信息位点（parsimony-informative characters），才具有真正的分辨能力。[@problem_id:2605510] 这项练习将训练你严格应用简约性信息位点的定义，处理包含缺失数据和模糊编码的形态学与核酸数据集，这是理解如何从原始数据构建系统发育树的关键一步。", "problem": "为了根据系统发育学原理评估形态学和核苷酸特征的简约信息性，我们建立了一个包含猫科和犬科物种的比较数据集，这些物种均采用双名法命名。分析采用非排序性状的 Fitch 简约法。使用以下来自系统发育学的基础定义。\n\n- 一个性状是从分类单元到离散状态的映射。\n- 在非排序 Fitch 简约法下，一个性状是简约信息性的，当且仅当，在筛选出该性状编码明确的分类单元（即具有单一状态，而非模糊、缺失或不适用状态）后，存在至少两种不同的状态，且每种状态都至少出现在 $2$ 个这样的分类单元中。\n- 模糊和缺失条目的处理方式如下：\n  - 对于核苷酸，国际纯粹与应用化学联合会（IUPAC）的单字母模糊编码表示可能的核苷酸集合：$R=\\{A,G\\}$, $Y=\\{C,T\\}$, $S=\\{G,C\\}$, $W=\\{A,T\\}$, $K=\\{G,T\\}$, $M=\\{A,C\\}$, $N=\\{A,C,G,T\\}$。连字符 $-$ 表示不适用。只有明确的核苷酸 $\\{A,C,G,T\\}$ 用于计数；所有其他编码和 $-$ 在计数时均被忽略。\n  - 对于形态学性状，状态编码为 $0,1,2,3$（非排序），其中 $?$ 表示缺失，$-$ 表示不适用。只有数字单例状态用于计数；$?$ 和 $-$ 在计数时均被忽略。\n\n分类单元（所有性状均按此固定顺序排列）为以下 $9$ 个物种：Panthera leo、Panthera tigris、Panthera pardus、Neofelis nebulosa、Acinonyx jubatus、Lynx lynx、Felis catus、Prionailurus bengalensis、Canis lupus。\n\n对于每个性状 $C_{i}$，其在 $9$ 个分类单元中的状态均按照上述固定的分类单元顺序列出。\n\n- $C_{1}$ (形态学，二元): $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$。\n- $C_{2}$ (形态学，二元): $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$。\n- $C_{3}$ (形态学，三元): $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$。\n- $C_{4}$ (核苷酸): $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$。\n- $C_{5}$ (核苷酸): $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$。\n- $C_{6}$ (形态学，二元): $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$。\n- $C_{7}$ (形态学，三元): $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$。\n- $C_{8}$ (核苷酸): $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$。\n- $C_{9}$ (核苷酸): $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$。\n- $C_{10}$ (核苷酸): $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$。\n- $C_{11}$ (形态学，四态): $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$。\n- $C_{12}$ (核苷酸): $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$。\n- $C_{13}$ (形态学，二元): $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$。\n- $C_{14}$ (核苷酸): $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$。\n- $C_{15}$ (形态学，二元): $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$。\n\n任务：仅使用上述定义（非排序 Fitch 简约法以及对模糊、缺失和不适用状态的处理方式），计算 $C_{1}$ 到 $C_{15}$ 中简约信息性性状的总数。最终答案以无单位的整数形式表示。无需四舍五入。", "solution": "首先将根据科学合理性、良定性和客观性这些必要标准对问题进行验证。\n\n**步骤 1：提取已知信息**\n\n问题提供了以下定义、数据和约束：\n1.  **系统发育学原理**：分析基于非排序性状的 Fitch 简约法。\n2.  **简约信息性的定义**：一个性状是简约信息性的，当且仅当，在筛选出编码明确的分类单元后，存在至少两种不同的状态，且每种状态都至少出现在 $2$ 个分类单元中。\n3.  **模糊/缺失数据的处理（核苷酸）**：明确状态为 $\\{A, C, G, T\\}$。模糊状态为 IUPAC 编码 $R=\\{A,G\\}$, $Y=\\{C,T\\}$, $S=\\{G,C\\}$, $W=\\{A,T\\}$, $K=\\{G,T\\}$, $M=\\{A,C\\}$ 和 $N=\\{A,C,G,T\\}$。符号 $-$ 表示不适用状态。只有明确状态用于计数；其他所有状态均被忽略。\n4.  **模糊/缺失数据的处理（形态学）**：明确状态为 $\\{0, 1, 2, 3\\}$。符号 $?$ 表示缺失状态，$-$ 表示不适用状态。只有数字单例状态用于计数；$?$ 和 $-$ 均被忽略。\n5.  **分类单元**：一组固定的 $9$ 个分类单元：*Panthera leo*、*Panthera tigris*、*Panthera pardus*、*Neofelis nebulosa*、*Acinonyx jubatus*、*Lynx lynx*、*Felis catus*、*Prionailurus bengalensis*、*Canis lupus*。\n6.  **性状数据**：$15$ 个性状（$C_{1}$ 到 $C_{15}$）在 $9$ 个分类单元中的状态分配。\n    - $C_{1}$: $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$。\n    - $C_{2}$: $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$。\n    - $C_{3}$: $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$。\n    - $C_{4}$: $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$。\n    - $C_{5}$: $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$。\n    - $C_{6}$: $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$。\n    - $C_{7}$: $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$。\n    - $C_{8}$: $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$。\n    - $C_{9}$: $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$。\n    - $C_{10}$: $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$。\n    - $C_{11}$: $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$。\n    - $C_{12}$: $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$。\n    - $C_{13}$: $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$。\n    - $C_{14}$: $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$。\n    - $C_{15}$: $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n- **科学依据**：该问题植根于系统发育学的基本原理，特别是分支简约法。简约信息性的定义是该领域的标准概念。双名法、核苷酸的 IUPAC 编码以及形态学数据的标准编码的使用都是正确且公认的做法。该问题具有科学合理性。\n- **良定性**：该问题为确定简约信息性提供了一个明确无误的算法。所有必要的数据和定义均已提供。任务是将此算法应用于给定的数据集，从而得出一个唯一、稳定且有意义的整数解。\n- **客观性**：该问题以精确、正式的语言陈述，不含主观或基于观点的论断。\n\n**步骤 3：结论与行动**\n\n该问题是有效的，因为它具有科学依据、良定性、客观性并且内容自洽。通过将所提供的定义应用于数据，可以得出一个严谨的解。\n\n**求解过程**\n\n任务是确定 $C_{1}$ 到 $C_{15}$ 中简约信息性性状的总数。将根据给定的定义对每个性状进行评估。\n\n- **$C_{1}$ (形态学)**：状态为 $1,\\,1,\\,1,\\,1,\\,1,\\,0,\\,0,\\,0,\\,0$。所有 $9$ 个分类单元的编码都是明确的。状态频率：计数($1$) = $5$，计数($0$) = $4$。两个频率都 $\\ge 2$。因此，**$C_{1}$ 是简约信息性的**。\n\n- **$C_{2}$ (形态学)**：状态为 $0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,1,\\,0$。所有 $9$ 个分类单元的编码都是明确的。状态频率：计数($0$) = $8$，计数($1$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{2}$ 不是简约信息性的。\n\n- **$C_{3}$ (形态学)**：状态为 $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,?,\\,0$。一个分类单元被编码为 $?$。剩下的 $8$ 个状态是 $0,\\,0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,0$。状态频率：计数($0$) = $3$，计数($1$) = $2$，计数($2$) = $3$。所有三个频率都 $\\ge 2$。因此，**$C_{3}$ 是简约信息性的**。\n\n- **$C_{4}$ (核苷酸)**：状态为 $A,\\,A,\\,A,\\,R,\\,G,\\,G,\\,G,\\,N,\\,A$。两个分类单元被编码为模糊状态 ($R, N$)。剩下的 $7$ 个状态是 $A,\\,A,\\,A,\\,G,\\,G,\\,G,\\,A$。状态频率：计数($A$) = $4$，计数($G$) = $3$。两个频率都 $\\ge 2$。因此，**$C_{4}$ 是简约信息性的**。\n\n- **$C_{5}$ (核苷酸)**：状态为 $T,\\,T,\\,T,\\,Y,\\,T,\\,A,\\,N,\\,-,\\,G$。三个分类单元被编码为模糊或不适用状态 ($Y, N, -$)。剩下的 $6$ 个状态是 $T,\\,T,\\,T,\\,T,\\,A,\\,G$。状态频率：计数($T$) = $4$，计数($A$) = $1$，计数($G$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{5}$ 不是简约信息性的。\n\n- **$C_{6}$ (形态学)**：状态为 $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0,\\,?$。一个分类单元被编码为 $?$。剩下的 $8$ 个状态是 $1,\\,1,\\,0,\\,0,\\,0,\\,1,\\,1,\\,0$。状态频率：计数($1$) = $4$，计数($0$) = $4$。两个频率都 $\\ge 2$。因此，**$C_{6}$ 是简约信息性的**。\n\n- **$C_{7}$ (形态学)**：状态为 $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1,\\,-$。一个分类单元被编码为 $-$。剩下的 $8$ 个状态是 $0,\\,1,\\,1,\\,2,\\,2,\\,2,\\,2,\\,1$。状态频率：计数($0$) = $1$，计数($1$) = $3$，计数($2$) = $4$。状态 $1$ 和 $2$ 的频率都 $\\ge 2$。因此，**$C_{7}$ 是简约信息性的**。\n\n- **$C_{8}$ (核苷酸)**：状态为 $C,\\,C,\\,C,\\,C,\\,C,\\,S,\\,G,\\,G,\\,R$。两个分类单元被编码为模糊状态 ($S, R$)。剩下的 $7$ 个状态是 $C,\\,C,\\,C,\\,C,\\,C,\\,G,\\,G$。状态频率：计数($C$) = $5$，计数($G$) = $2$。两个频率都 $\\ge 2$。因此，**$C_{8}$ 是简约信息性的**。\n\n- **$C_{9}$ (核苷酸)**：状态为 $A,\\,G,\\,R,\\,G,\\,G,\\,R,\\,A,\\,A,\\,N$。三个分类单元被编码为模糊状态 ($R, R, N$)。剩下的 $6$ 个状态是 $A,\\,G,\\,G,\\,G,\\,A,\\,A$。状态频率：计数($A$) = $3$，计数($G$) = $3$。两个频率都 $\\ge 2$。因此，**$C_{9}$ 是简约信息性的**。\n\n- **$C_{10}$ (核苷酸)**：状态为 $A,\\,A,\\,A,\\,A,\\,A,\\,A,\\,G,\\,C,\\,T$。所有 $9$ 个分类单元的编码都是明确的。状态频率：计数($A$) = $6$，计数($G$) = $1$，计数($C$) = $1$，计数($T$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{10}$ 不是简约信息性的。\n\n- **$C_{11}$ (形态学)**：状态为 $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3,\\,?$。一个分类单元被编码为 $?$。剩下的 $8$ 个状态是 $0,\\,1,\\,2,\\,3,\\,0,\\,1,\\,2,\\,3$。状态频率：计数($0$) = $2$，计数($1$) = $2$，计数($2$) = $2$，计数($3$) = $2$。所有四个频率都 $\\ge 2$。因此，**$C_{11}$ 是简约信息性的**。\n\n- **$C_{12}$ (核苷酸)**：状态为 $N,\\,N,\\,N,\\,N,\\,N,\\,G,\\,C,\\,-,\\,N$。七个分类单元被编码为模糊或不适用状态 ($N, -$)。剩下的 $2$ 个状态是 $G,\\,C$。状态频率：计数($G$) = $1$，计数($C$) = $1$。没有状态的频率 $\\ge 2$。因此，$C_{12}$ 不是简约信息性的。\n\n- **$C_{13}$ (形态学)**：状态为 $1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1$。所有 $9$ 个分类单元的编码都是明确的。状态频率：计数($1$) = $5$，计数($0$) = $4$。两个频率都 $\\ge 2$。因此，**$C_{13}$ 是简约信息性的**。\n\n- **$C_{14}$ (核苷酸)**：状态为 $A,\\,A,\\,M,\\,C,\\,C,\\,M,\\,C,\\,C,\\,A$。两个分类单元被编码为模糊状态 ($M$)。剩下的 $7$ 个状态是 $A,\\,A,\\,C,\\,C,\\,C,\\,C,\\,A$。状态频率：计数($A$) = $3$，计数($C$) = $4$。两个频率都 $\\ge 2$。因此，**$C_{14}$ 是简约信息性的**。\n\n- **$C_{15}$ (形态学)**：状态为 $?,\\,?,\\,1,\\,0,\\,-,\\,-,\\,-,\\,1,\\,-$。七个分类单元被编码为缺失或不适用状态 ($?, -$)。剩下的 $3$ 个状态是 $1,\\,0,\\,1$。状态频率：计数($1$) = $2$，计数($0$) = $1$。只有一个状态的频率 $\\ge 2$。因此，$C_{15}$ 不是简约信息性的。\n\n**结论**\n\n简约信息性性状为 $C_{1}, C_{3}, C_{4}, C_{6}, C_{7}, C_{8}, C_{9}, C_{11}, C_{13}, \\text{和} C_{14}$。\n简约信息性性状的总数为 $10$。", "answer": "$$\n\\boxed{10}\n$$", "id": "2605510"}, {"introduction": "现代系统学的一个核心挑战是基因树与物种树之间的不一致性，这通常由不完全谱系分选（Incomplete Lineage Sorting, ILS）引起。[@problem_id:2605544] 本练习将引导你应用多物种溯祖模型（Multispecies Coalescent model），这是一个强大的理论框架，用于量化基因树与物种树冲突的概率。通过计算并比较核基因和叶绿体基因发生ILS的不同可能性，你将深入理解不同遗传标记在揭示进化历史时为何会产生差异，以及如何利用这些信息来更准确地推断物种关系。", "problem": "一位分类学家正在评估不完全谱系分选如何影响三种亲缘关系很近的橡树物种的物种树推断，这三种物种根据双名法命名为：白橡（Quercus alba）、红橡（Quercus rubra）和夏橡（Quercus robur）。假定的物种树为 $((\\textit{Q. alba}, \\textit{Q. rubra}), \\textit{Q. robur})$，以世代为单位的分化时间为：$\\textit{Q. alba}$ 和 $\\textit{Q. rubra}$ 之间的分化时间 $t_{AB} = 2.0 \\times 10^{5}$，以及它们的共同祖先与 $\\textit{Q. robur}$ 之间的分化时间 $t_{ABC} = 3.2 \\times 10^{5}$。假设这两个分化时间之间的内部祖先支具有恒定的有效种群大小：对于双亲遗传的二倍体核基因座，$N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$；对于母系遗传的单倍体叶绿体脱氧核糖核酸（cpDNA）基因座，$N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$。您每个物种每个基因座采样一个谱系。\n\n在标准中性多物种溯祖（MSC）模型下（随机交配种群，无选择，无迁移，每条支系上有效种群大小恒定），并且仅考虑不完全谱系分选作为拓扑不一致性的原因，计算以下比率\n$$\nR \\;=\\; \\frac{\\Pr(\\text{一个核基因树与物种树拓扑不一致})}{\\Pr(\\text{一个 cpDNA 基因树与物种树拓扑不一致})}.\n$$\n请将最终答案表示为四舍五入到四位有效数字的小数。不需要单位。", "solution": "首先验证问题的科学性和逻辑合理性。已知条件如下：\n1.  物种：*Quercus alba*（物种A）、*Quercus rubra*（物种B）和 *Quercus robur*（物种C）。\n2.  物种树拓扑：$((A, B), C)$。\n3.  A 和 B 之间的分化时间：$t_{AB} = 2.0 \\times 10^{5}$ 世代。\n4.  (A, B) 的祖先与 C 之间的分化时间：$t_{ABC} = 3.2 \\times 10^{5}$ 世代。\n5.  核基因座是二倍体，有效种群大小为 $N_{e}^{\\text{nuc}} = 2.5 \\times 10^{5}$。\n6.  叶绿体基因座（cpDNA）是单倍体，有效种群大小为 $N_{e}^{\\text{cp}} = 6.25 \\times 10^{4}$。\n7.  模型是标准中性多物种溯祖（MSC）模型。\n8.  任务是计算核基因座与 cpDNA 基因座的基因树不一致性概率之比 $R$。\n\n该问题陈述在溯祖理论和群体遗传学的既定原则上具有科学依据。问题提法明确，提供了所有必要的参数和清晰的目标。没有矛盾、模糊或事实性错误。该问题被认为是有效的，并将提供解答。\n\n这个问题的核心在于理解三分类单元情况下，多物种溯祖模型所描述的不完全谱系分选（ILS）。对于一个拓扑为 $((A, B), C)$ 的物种树，从每个物种中抽取一个谱系的样本，存在三种可能的有根基因树拓扑：一致拓扑 $((A, B), C)$，以及两种不一致拓扑 $((A, C), B)$ 和 $((B, C), A)$。\n\n获得不一致基因树的概率是物种树内部支长度（以溯祖单位衡量）的直接函数。从姐妹物种 A 和 B 中采样的两个基因谱系在其共同祖先种群中未能溯祖合并的概率由 $\\exp(-T)$ 给出，其中 $T$ 是该祖先种群（内部支）以溯祖单位计的持续时间。如果它们未能溯祖合并，则所有三个谱系（来自 A、B 和 C）都进入更深层的祖先种群。在中性条件下，这三个谱系中任意一对首先溯祖合并的概率均等，每种配对的概率为 $\\frac{1}{3}$。只有当谱系 A 和 B 首先溯祖合并时，基因树拓扑才是一致的，即 $((A, B), C)$。另外两种配对 (A, C) 和 (B, C) 会导致不一致的拓扑。\n\n因此，获得不一致基因树的总概率是内部支上未发生溯祖合并的概率乘以在深层祖先中发生不一致溯祖合并事件的概率：\n$$\n\\Pr(\\text{不一致}) = \\exp(-T) \\times \\left( \\Pr(\\text{A,C 首先合并}) + \\Pr(\\text{B,C 首先合并}) \\right) = \\exp(-T) \\times \\left( \\frac{1}{3} + \\frac{1}{3} \\right) = \\frac{2}{3} \\exp(-T)\n$$\n\n内部支以世代为单位的长度 $\\tau$ 是两个物种形成事件之间的时间：\n$$\n\\tau = t_{ABC} - t_{AB} = (3.2 \\times 10^{5}) - (2.0 \\times 10^{5}) = 1.2 \\times 10^{5} \\text{ 世代}\n$$\n该支以溯祖单位计的长度 $T$ 取决于有效种群大小 $N_e$ 和基因座的倍性。两个谱系的溯祖合并速率对于二倍体基因座是 $\\frac{1}{2N_e}$，对于单倍体基因座是 $\\frac{1}{N_e}$。支长 $T$ 是以世代为单位的时间与溯祖速率的乘积。\n\n首先，我们计算二倍体核基因座的 $T$，$T_{\\text{nuc}}$：\n$$\nT_{\\text{nuc}} = \\frac{\\tau}{2 N_{e}^{\\text{nuc}}} = \\frac{1.2 \\times 10^{5}}{2 \\times (2.5 \\times 10^{5})} = \\frac{1.2 \\times 10^{5}}{5.0 \\times 10^{5}} = 0.24\n$$\n一个不一致的核基因树的概率，$\\Pr(\\text{核基因不一致})$，是：\n$$\n\\Pr(\\text{核基因不一致}) = \\frac{2}{3} \\exp(-T_{\\text{nuc}}) = \\frac{2}{3} \\exp(-0.24)\n$$\n\n接下来，我们计算单倍体 cpDNA 基因座的 $T$，$T_{\\text{cp}}$。假设性别比相等且繁殖成功率方差相同，母系遗传的单倍体细胞器的有效种群大小通常是双亲遗传的二倍体核基因的四分之一。给定的值 $N_{e}^{\\text{cp}} = 6.25 \\times 10^4$ 和 $N_{e}^{\\text{nuc}} = 2.5 \\times 10^5$ 与此预期相符，因为 $\\frac{N_{e}^{\\text{nuc}}}{4} = \\frac{2.5 \\times 10^5}{4} = 6.25 \\times 10^4 = N_{e}^{\\text{cp}}$。\n$$\nT_{\\text{cp}} = \\frac{\\tau}{N_{e}^{\\text{cp}}} = \\frac{1.2 \\times 10^{5}}{6.25 \\times 10^{4}} = 1.92\n$$\n一个不一致的 cpDNA 基因树的概率，$\\Pr(\\text{cpDNA 不一致})$，是：\n$$\n\\Pr(\\text{cpDNA 不一致}) = \\frac{2}{3} \\exp(-T_{\\text{cp}}) = \\frac{2}{3} \\exp(-1.92)\n$$\n\n最后，我们计算所要求的比率 $R$：\n$$\nR = \\frac{\\Pr(\\text{核基因不一致})}{\\Pr(\\text{cpDNA 不一致})} = \\frac{\\frac{2}{3} \\exp(-T_{\\text{nuc}})}{\\frac{2}{3} \\exp(-T_{\\text{cp}})} = \\frac{\\exp(-0.24)}{\\exp(-1.92)}\n$$\n利用指数的性质，这可以简化为：\n$$\nR = \\exp(-0.24 - (-1.92)) = \\exp(1.92 - 0.24) = \\exp(1.68)\n$$\n现在我们计算数值并四舍五入到四位有效数字：\n$$\nR \\approx 5.365555...\n$$\n$$\nR \\approx 5.366\n$$\n该结果表明，在这些条件下，核基因树与物种树不一致的可能性远大于 cpDNA 基因树。这是一个预期的结果，因为核基因组较大的有效种群大小（按倍性缩放，$2N_e$ vs $N_e$）导致以溯祖单位计的内部支长度更短，从而增加了不完全谱系分选（ILS）的概率。", "answer": "$$\\boxed{5.366}$$", "id": "2605544"}, {"introduction": "物种界定是分类学的核心任务，它正迅速从主观判断转向可重复的、基于算法的整合方法。[@problem_id:2605531] 这项综合性练习旨在将你所学的理论知识付诸实践，要求你从基本原理出发，构建一个完整的物种界定工作流程。通过将“条形码间隙”（barcode gap）等概念形式化为算法，整合遗传与形态数据，并最终根据命名法规验证物种名称，你将亲身体验现代生物多样性科学中计算思维、系统学理论与分类学实践的深度融合。", "problem": "实现一个程序，该程序将一个透明、基于原则的物种界定工作流程形式化，并为界定的物种验证其二名法名称。该工作流程必须源于分类学和系统学的核心定义，而非黑箱公式。您必须通过一个可复现、纯数学的构造来整合遗传学和形态学证据，然后检查二名法命名约束。\n\n基本原理：\n- 物种在操作上被识别为内聚、可区分的聚类：在合理的准则下，聚类内的个体彼此之间的相似度高于与聚类外个体的相似度。\n- “DNA条形码间隙”条件将可区分性形式化：对于任意两个假定物种，最小的簇间非相似性应超过最大的簇内非相似性。\n- 二名法要求，在同一属内，种加词必须是唯一的，且每个二名法名称都必须格式正确。\n\n需要实现的定义：\n- 设 $D \\in \\mathbb{R}^{n \\times n}$ 为一个对称的遗传距离矩阵，其中 $D_{ii}=0$。\n- 设 $M \\in \\mathbb{R}^{n \\times p}$ 为一个形态学性状矩阵（连续性状）。\n- 设 $w_g \\in \\mathbb{R}_{\\ge 0}$ 和 $w_m \\in \\mathbb{R}_{\\ge 0}$ 分别为遗传学证据和形态学证据的权重。\n- 通过每个形态学性状在 $n$ 个标本中的样本标准差 $s_k$ 对其进行标准化；如果任何 $s_k=0$，则认为该性状对形态学距离的贡献为 $0$。\n- 定义标本 $i$ 和 $j$ 之间的组合非相似性为\n$$\n\\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}.\n$$\n- 给定一个阈值 $\\tau_{\\text{intra}} \\in \\mathbb{R}_{>0}$，在 $n$ 个标本上构建一个无向图，当且仅当 $\\delta_{ij} \\le \\tau_{\\text{intra}}$ 时添加一条边 $\\{i,j\\}$。该图的连通分量即为临时物种。\n- 对于任意分量 $C$，将其最大簇内非相似性定义为\n$$\n\\Delta_{\\text{intra}}(C) \\;=\\; \\begin{cases}\n0, & |C|\\le 1,\\\\\n\\max\\limits_{i,j \\in C,\\, i<j} \\delta_{ij}, & |C|\\ge 2,\n\\end{cases}\n$$\n对于分量 $C_a \\neq C_b$，定义其最小簇间非相似性为\n$$\n\\Delta_{\\text{inter}}(C_a, C_b) \\;=\\; \\min\\limits_{i \\in C_a,\\, j \\in C_b} \\delta_{ij}.\n$$\n- DNA条形码间隙合并循环：如果存在一对 $(C_a, C_b)$ 满足 $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$ 或 $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$，则将具有最小 $\\Delta_{\\text{inter}}$ 的违规对合并成一个单一分量并重复此过程。当不再有违规情况时，循环终止。设 $m$ 为执行的总合并次数。\n- 针对最终分量的二名法命名有效性检查：\n  - 每个最终分量必须有一个其所有成员共享的单一属名；该属名必须为字母，且仅有一个大写首字母，后跟小写字母。\n  - 每个最终分量必须有一个其所有成员共享的单一种加词；该种加词必须为字母，全部小写，长度在 $3$ 到 $12$ 之间（含）。\n  - 在每个属内，不同分量间的种加词必须是唯一的。\n\n您的程序必须：\n- 实现上文指定的 $\\delta_{ij}$ 的构造、$\\tau_{\\text{intra}}$-图、DNA条形码间隙合并循环以及二名法命名有效性检查。\n- 对于每个测试用例，输出一个三元列表 $[k, m, \\text{naming\\_ok}]$，其中 $k$ 是最终界定的物种数量（合并循环后的连通分量数），$m$ 是执行的合并次数的整数计数，$\\text{naming\\_ok}$ 是一个布尔值，指示最终的二名法名称是否通过有效性检查。\n\n测试套件（请使用这些确切的数值参数）：\n- 测试用例A：\n  - $n=6$, $p=2$, $w_g=1.0$, $w_m=0.3$, $\\tau_{\\text{intra}}=0.1$。\n  - 遗传距离矩阵 $D$（行序为 $0$ 到 $5$）：\n    - 第 $0$ 行：$[0,\\,0.018,\\,0.022,\\,0.14,\\,0.15,\\,0.16]$\n    - 第 $1$ 行：$[0.018,\\,0,\\,0.019,\\,0.13,\\,0.14,\\,0.15]$\n    - 第 $2$ 行：$[0.022,\\,0.019,\\,0,\\,0.12,\\,0.13,\\,0.14]$\n    - 第 $3$ 行：$[0.14,\\,0.13,\\,0.12,\\,0,\\,0.017,\\,0.021]$\n    - 第 $4$ 行：$[0.15,\\,0.14,\\,0.13,\\,0.017,\\,0,\\,0.020]$\n    - 第 $5$ 行：$[0.16,\\,0.15,\\,0.14,\\,0.021,\\,0.020,\\,0]$\n  - 形态学性状矩阵 $M$：\n    - 第 $0$ 行：$[0.02,\\,-0.03]$\n    - 第 $1$ 行：$[-0.01,\\,0.04]$\n    - 第 $2$ 行：$[0.00,\\,0.00]$\n    - 第 $3$ 行：$[1.02,\\,0.97]$\n    - 第 $4$ 行：$[0.95,\\,1.03]$\n    - 第 $5$ 行：$[1.01,\\,0.96]$\n  - 属名列表：$[\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"},\\,\\text{\"Rana\"}]$。\n  - 种加词列表：$[\\text{\"lutea\"},\\,\\text{\"lutea\"},\\,\\text{\"lutea\"},\\,\\text{\"rubra\"},\\,\\text{\"rubra\"},\\,\\text{\"rubra\"}]$。\n\n- 测试用例B：\n  - $n=4$, $p=2$, $w_g=1.0$, $w_m=0.05$, $\\tau_{\\text{intra}}=0.06$。\n  - 遗传距离矩阵 $D$：\n    - 第 $0$ 行：$[0,\\,0.04,\\,0.08,\\,0.07]$\n    - 第 $1$ 行：$[0.04,\\,0,\\,0.04,\\,0.075]$\n    - 第 $2$ 行：$[0.08,\\,0.04,\\,0,\\,0.072]$\n    - 第 $3$ 行：$[0.07,\\,0.075,\\,0.072,\\,0]$\n  - 形态学性状矩阵 $M$：\n    - 第 $0$ 行：$[0.00,\\,0.00]$\n    - 第 $1$ 行：$[0.02,\\,-0.01]$\n    - 第 $2$ 行：$[0.03,\\,-0.02]$\n    - 第 $3$ 行：$[0.04,\\,0.00]$\n  - 属名列表：$[\\text{\"Quercus\"},\\,\\text{\"Quercus\"},\\,\\text{\"Quercus\"},\\,\\text{\"Quercus\"}]$。\n  - 种加词列表：$[\\text{\"alba\"},\\,\\text{\"alba\"},\\,\\text{\"albus\"},\\,\\text{\"alba\"}]$。\n\n- 测试用例C：\n  - $n=5$, $p=2$, $w_g=1.0$, $w_m=0.25$, $\\tau_{\\text{intra}}=0.09$。\n  - 遗传距离矩阵 $D$：\n    - 第 $0$ 行：$[0,\\,0.03,\\,0.11,\\,0.22,\\,0.23]$\n    - 第 $1$ 行：$[0.03,\\,0,\\,0.12,\\,0.21,\\,0.22]$\n    - 第 $2$ 行：$[0.11,\\,0.12,\\,0,\\,0.24,\\,0.25]$\n    - 第 $3$ 行：$[0.22,\\,0.21,\\,0.24,\\,0,\\,0.027]$\n    - 第 $4$ 行：$[0.23,\\,0.22,\\,0.25,\\,0.027,\\,0]$\n  - 形态学性状矩阵 $M$：\n    - 第 $0$ 行：$[0.00,\\,0.00]$\n    - 第 $1$ 行：$[0.01,\\,-0.02]$\n    - 第 $2$ 行：$[0.60,\\,0.60]$\n    - 第 $3$ 行：$[2.00,\\,2.00]$\n    - 第 $4$ 行：$[1.98,\\,2.02]$\n  - 属名列表：$[\\text{\"Salvia\"},\\,\\text{\"Salvia\"},\\,\\text{\"Salvia\"},\\,\\text{\"Pinus\"},\\,\\text{\"Pinus\"}]$。\n  - 种加词列表：$[\\text{\"officinalis\"},\\,\\text{\"officinalis\"},\\,\\text{\"splendens\"},\\,\\text{\"officinalis\"},\\,\\text{\"officinalis\"}]$。\n\n角度或物理单位不适用。所有输出均为无量纲值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，且无空格。每个测试用例的结果必须是形如 $[k,m,\\text{naming\\_ok}]$ 的三元列表。例如：$[[2,0,\\text{True}],[1,1,\\text{False}],[3,0,\\text{True}]]$。", "solution": "问题陈述经过验证。\n\n步骤1：提取已知信息。\n该问题为物种界定提供了一个详细的算法框架，并为验证二名法命名提供了一套规则。它指定了以下定义和计算步骤：\n- 一个对称的遗传距离矩阵 $D \\in \\mathbb{R}^{n \\times n}$。\n- 一个形态学性状矩阵 $M \\in \\mathbb{R}^{n \\times p}$。\n- 非负标量权重 $w_g$ 和 $w_m$。\n- 一个正的非相似性阈值 $\\tau_{\\text{intra}}$。\n- 组合非相似性 $\\delta_{ij}$ 的公式：\n$$\n\\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}\n$$\n其中 $s_k$ 是第 $k$ 个性状的样本标准差。如果 $s_k=0$，该性状的贡献为 $0$。\n- 初始聚类的程序：如果 $\\delta_{ij} \\le \\tau_{\\text{intra}}$，则连接标本 $i$ 和 $j$。临时物种是此图的连通分量。\n- 通过DNA条形码间隙合并循环来优化聚类的程序。如果 $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$ 或 $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a,C_b)$，则合并聚类对 $(C_a, C_b)$。首先合并 $\\Delta_{\\text{inter}}$ 最小的对。重复此过程，直到不存在此类违规对为止。\n- 一套针对最终聚类的二名法命名有效性检查，涉及属名和种加词的格式、簇内一致性以及属内种加词的唯一性。\n- 三个完全指定的测试用例（A、B、C），包含所有必要的输入（$n, p, w_g, w_m, \\tau_{\\text{intra}}, D, M$ 和名称列表）。\n\n步骤2：使用提取的已知信息进行验证。\n根据验证标准对问题进行评估：\n- **科学依据**：该问题很好地立足于系统学和分类学的原理。基于种内和种间变异之间的间隙（“DNA条形码间隙”）将物种定义为可区分聚类的核心思想是一个标准概念。使用组合证据方法（遗传和形态学数据）也是标准做法。具体的数学公式是一个简化的操作模型，但它不是伪科学；它是对既定生物学原理的形式化。\n- **适定性**：该问题在算法上是精确的。从 $\\delta_{ij}$ 的计算到合并循环和最终名称验证的每一步都是确定性定义的。合并循环有明确的终止条件（不再存在违规对），确保过程能够结束。给定一组输入，存在唯一的解。\n- **客观性**：该问题以客观的数学语言陈述。“内聚性”和“可区分性”等模糊概念被赋予了明确的定量定义（$\\tau_{\\text{intra}}$-图和DNA条形码间隙条件）。没有主观或基于意见的主张。\n- 该问题是自洽且内部一致的。它并非微不足道，因为它需要仔细实现一个涉及图论和迭代优化的多步骤算法。它不基于错误的前提或循环推理。\n\n步骤3：结论与行动。\n该问题被判定为**有效**。这是一个严谨的计算生物学问题，它将分类学的原理形式化为一个可复现的工作流程。将提供完整的解决方案。\n\n该解决方案通过遵循规定的工作流程来实现。主要步骤包括：计算组合非相似性矩阵，基于阈值的初始聚类，基于DNA条形码间隙准则的聚类迭代合并，以及二名法命名的最终验证。\n\n1. **组合非相似性矩阵 ($\\delta$) 计算**：\n   对于一组 $n$ 个标本和 $p$ 个形态学性状，第一步是计算 $n \\times n$ 的组合非相似性矩阵 $\\delta$。对于每对标本 $(i, j)$，$\\delta_{ij}$ 整合了遗传距离 $D_{ij}$ 和形态学距离。形态学距离是性状空间中的加权欧几里得距离，其中每个性状轴 $k$ 都通过其样本标准差 $s_k$ 进行标准化。这种标准化确保了具有较大方差的性状不会对距离产生不成比例的影响。根据问题描述，如果一个性状的方差为零 ($s_k = 0$)，其对距离的贡献为 $0$。总非相似性是加权和：\n    $$\n    \\delta_{ij} \\;=\\; w_g \\, D_{ij} \\;+\\; w_m \\, \\sqrt{\\sum_{k=1}^{p} \\left(\\frac{M_{ik}-M_{jk}}{s_k}\\right)^2}.\n    $$\n    该矩阵 $\\delta$ 是所有后续聚类步驟的基础。\n\n2. **初始聚类**：\n   构建一个具有 $n$ 个顶点的无向图，代表这些标本。当且仅当顶点 $i$ 和 $j$ 之间的组合非相似性 $\\delta_{ij}$ 小于或等于给定阈值 $\\tau_{\\text{intra}}$ 时，在它们之间放置一条边。该阈值代表了被认为是“种内”的最大非相似性水平。该图的连通分量构成了临时物种集合。使用标准的图遍历算法，如广度优先搜索（BFS）或深度优先搜索（DFS），来识别这些分量。\n\n3. **DNA条形码间隙合并循环**：\n   这是一个迭代优化过程。初始聚类将根据DNA条形码间隙准则进行测试，该准则将组内变异应小于组间变异的原则形式化。对于任意两个不同的聚类 $C_a$ 和 $C_b$：\n    - 最大簇内非相似性为 $\\Delta_{\\text{intra}}(C) = \\max_{i,j \\in C} \\delta_{ij}$。\n    - 最小簇间非相似性为 $\\Delta_{\\text{inter}}(C_a, C_b) = \\min_{i \\in C_a, j \\in C_b} \\delta_{ij}$。\n   如果 $\\Delta_{\\text{intra}}(C_a) \\ge \\Delta_{\\text{inter}}(C_a, C_b)$ 或 $\\Delta_{\\text{intra}}(C_b) \\ge \\Delta_{\\text{inter}}(C_a, C_b)$，则发生违规。这表明这两个聚类无法明确区分，因为一个聚类内部的最大间隙大于或等于它们之间的最小间隙。\n   算法按循环进行：\n   a. 在每次迭代中，检查所有当前聚类对是否存在违规。\n   b. 如果未发现违规，则过程终止。当前的聚类集合即为最终界定。\n   c. 如果存在一个或多个违规对，则选择其中 $\\Delta_{\\text{inter}}$ 最小的对进行合并。该对中的两个聚类被合并成一个单一的新聚类。合并计数 $m$ 增加。\n   d. 然后循环使用新的聚类集合重复。这种贪心策略旨在首先解决最严重的违规。\n\n4. **二名法命名验证**：\n   合并循环终止后，将检查最终的 $k$ 个聚类是否符合命名规则。使用布尔标志 $\\text{naming\\_ok}$ 来跟踪有效性。对每个聚类执行以下检查：\n   a. **一致性**：单个聚类内的所有标本必须具有相同的属名和相同的种加词。\n   b. **格式**：属名必须是字母且首字母大写（例如 `Rana`）。种加词必须是字母、小写，并且长度在 3 到 12 个字符之间（含）。\n   c. **唯一性**：在给定属内，所有界定的物种（聚类）必须具有唯一的种加词。例如，两个不同的最终聚类不能都被命名为 `Rana lutea`。\n   如果任何聚类的任何规则被违反，$\\text{naming\\_ok}$ 将被设置为 `False`，并且验证可以停止。否则，它保持 `True`。\n\n每个测试用例的最终输出是一个列表，其中包含最终物种数 $k$、总合并次数 $m$ 以及布尔验证结果 $\\text{naming\\_ok}$。", "answer": "```python\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"n\": 6, \"p\": 2, \"wg\": 1.0, \"wm\": 0.3, \"tau_intra\": 0.1,\n            \"D\": np.array([\n                [0, 0.018, 0.022, 0.14, 0.15, 0.16],\n                [0.018, 0, 0.019, 0.13, 0.14, 0.15],\n                [0.022, 0.019, 0, 0.12, 0.13, 0.14],\n                [0.14, 0.13, 0.12, 0, 0.017, 0.021],\n                [0.15, 0.14, 0.13, 0.017, 0, 0.020],\n                [0.16, 0.15, 0.14, 0.021, 0.020, 0]\n            ]),\n            \"M\": np.array([\n                [0.02, -0.03], [-0.01, 0.04], [0.00, 0.00],\n                [1.02, 0.97], [0.95, 1.03], [1.01, 0.96]\n            ]),\n            \"genera\": [\"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\", \"Rana\"],\n            \"epithets\": [\"lutea\", \"lutea\", \"lutea\", \"rubra\", \"rubra\", \"rubra\"]\n        },\n        # Test case B\n        {\n            \"n\": 4, \"p\": 2, \"wg\": 1.0, \"wm\": 0.05, \"tau_intra\": 0.06,\n            \"D\": np.array([\n                [0, 0.04, 0.08, 0.07],\n                [0.04, 0, 0.04, 0.075],\n                [0.08, 0.04, 0, 0.072],\n                [0.07, 0.075, 0.072, 0]\n            ]),\n            \"M\": np.array([\n                [0.00, 0.00], [0.02, -0.01], [0.03, -0.02], [0.04, 0.00]\n            ]),\n            \"genera\": [\"Quercus\", \"Quercus\", \"Quercus\", \"Quercus\"],\n            \"epithets\": [\"alba\", \"alba\", \"albus\", \"alba\"]\n        },\n        # Test case C\n        {\n            \"n\": 5, \"p\": 2, \"wg\": 1.0, \"wm\": 0.25, \"tau_intra\": 0.09,\n            \"D\": np.array([\n                [0, 0.03, 0.11, 0.22, 0.23],\n                [0.03, 0, 0.12, 0.21, 0.22],\n                [0.11, 0.12, 0, 0.24, 0.25],\n                [0.22, 0.21, 0.24, 0, 0.027],\n                [0.23, 0.22, 0.25, 0.027, 0]\n            ]),\n            \"M\": np.array([\n                [0.00, 0.00], [0.01, -0.02], [0.60, 0.60],\n                [2.00, 2.00], [1.98, 2.02]\n            ]),\n            \"genera\": [\"Salvia\", \"Salvia\", \"Salvia\", \"Pinus\", \"Pinus\"],\n            \"epithets\": [\"officinalis\", \"officinalis\", \"splendens\", \"officinalis\", \"officinalis\"]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_one_case(**case)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    print(str(results).replace(\" \", \"\"))\n\ndef _find_components(n, adj):\n    \"\"\"Finds connected components in a graph using BFS.\"\"\"\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            component = []\n            q = [i]\n            visited[i] = True\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                component.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(sorted(component))\n    return components\n\ndef _solve_one_case(n, p, wg, wm, tau_intra, D, M, genera, epithets):\n    \"\"\"\n    Implements the entire species delimitation and validation workflow for a single test case.\n    \"\"\"\n    # Step 1: Calculate combined dissimilarity matrix\n    s = np.std(M, axis=0, ddof=1) if n > 1 else np.zeros(p)\n    \n    delta = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            morph_dist_sq = 0\n            for k in range(p):\n                # Only add contribution if trait has variance\n                if s[k] > 0:\n                    morph_dist_sq += ((M[i, k] - M[j, k]) / s[k])**2\n            \n            morph_dist = np.sqrt(morph_dist_sq)\n            delta[i, j] = wg * D[i, j] + wm * morph_dist\n            delta[j, i] = delta[i, j]\n\n    # Step 2: Initial clustering\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if delta[i, j] = tau_intra:\n                adj[i].append(j)\n                adj[j].append(i)\n    \n    components = _find_components(n, adj)\n\n    # Step 3: Barcode-gap merging loop\n    merges = 0\n    while True:\n        violating_pairs = []\n        num_components = len(components)\n        \n        for i in range(num_components):\n            for j in range(i + 1, num_components):\n                Ca, Cb = components[i], components[j]\n                \n                max_intra_a = 0.0\n                if len(Ca) > 1:\n                    max_intra_a = max(delta[u, v] for u_idx, u in enumerate(Ca) for v in Ca[u_idx+1:])\n                \n                max_intra_b = 0.0\n                if len(Cb) > 1:\n                    max_intra_b = max(delta[u, v] for u_idx, u in enumerate(Cb) for v in Cb[u_idx+1:])\n                \n                min_inter = min(delta[u, v] for u in Ca for v in Cb)\n                \n                if max_intra_a >= min_inter or max_intra_b >= min_inter:\n                    violating_pairs.append({'inter': min_inter, 'pair_indices': (i, j)})\n        \n        if not violating_pairs:\n            break\n        \n        violating_pairs.sort(key=lambda x: x['inter'])\n        idx_a, idx_b = violating_pairs[0]['pair_indices']\n        \n        # Merge the two components. Create a new list for the next iteration.\n        merged_component = sorted(components[idx_a] + components[idx_b])\n        new_components = [merged_component]\n        for k in range(num_components):\n            if k != idx_a and k != idx_b:\n                new_components.append(components[k])\n        \n        components = new_components\n        merges += 1\n    \n    # Step 4: Binomial nomenclature validity check\n    k = len(components)\n    naming_ok = True\n    genus_epithets = {}\n    \n    gen_pattern = re.compile(r'^[A-Z][a-z]+$')\n    epi_pattern = re.compile(r'^[a-z]{3,12}$')\n\n    for comp in components:\n        if not naming_ok: break\n        \n        first_genus = genera[comp[0]]\n        first_epithet = epithets[comp[0]]\n\n        if not gen_pattern.fullmatch(first_genus) or not epi_pattern.fullmatch(first_epithet):\n            naming_ok = False\n            continue\n        \n        if not all(genera[i] == first_genus and epithets[i] == first_epithet for i in comp):\n            naming_ok = False\n            continue\n\n        if first_genus not in genus_epithets:\n            genus_epithets[first_genus] = set()\n        \n        if first_epithet in genus_epithets[first_genus]:\n            naming_ok = False\n        else:\n            genus_epithets[first_genus].add(first_epithet)\n\n    return [k, merges, naming_ok]\n\nsolve()\n```", "id": "2605531"}]}