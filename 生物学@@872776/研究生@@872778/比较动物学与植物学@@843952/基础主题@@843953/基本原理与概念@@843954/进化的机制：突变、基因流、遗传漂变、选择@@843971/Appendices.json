{"hands_on_practices": [{"introduction": "理解选择如何塑造遗传变异，始于构建数学模型。本练习将引导你构建一个负频率依赖选择模型，这是自然界中维持多样性的一个常见过程。通过从第一性原理出发推导平衡条件 ([@problem_id:2588599])，你将掌握理论群体遗传学的基本技能，并深入理解平衡选择的运作方式。", "problem": "在比较动物学和植物学的背景下，考虑在一个单倍体生物中表达的两个可遗传的替代色型，等位基因 $A$ 和等位基因 $a$。假设选择源于负频率依赖的相互作用，这种作用在动物猎物与鸟类捕食者（搜索图像）以及开花植物与传粉者（新颖性偏好）之间具有可比性。具体来说，假设 $A$ 和 $a$ 的绝对赖特适应度是群体中 $A$ 当前频率 $p$ 的线性函数：\n$$\nw_{A}(p) \\equiv 1 - \\alpha p, \\quad w_{a}(p) \\equiv 1 - \\beta (1 - p),\n$$\n其中 $\\alpha > 0$ 和 $\\beta > 0$ 参数化了每种色型的适应度因相互作用物种的识别或利用而随其自身频率下降的强度。假设世代离散且不重叠，单倍体遗传，随机交配（或配子随机结合），并且没有突变，没有迁移（没有基因流），也没有遗传漂变（有效无限种群规模下的确定性动态）。令 $p_{t}$ 表示第 $t$ 代 $A$ 的频率。\n\n仅使用赖特适应度、平均适应度的核心定义，以及通过相对适应度将 $p_{t+1}$ 与 $p_{t}$ 联系起来的标准单倍体选择递归式，完成以下任务：\n\n1. 推导 $p_{t+1}$ 作为 $p_{t}$、$w_{A}(p_{t})$ 和 $w_{a}(p_{t})$ 的函数的确定性递归式，并明确写出平均适应度 $\\bar{w}(p_{t})$。\n\n2. 使用受保护多态性的定义（即每个等位基因在稀有时频率都会增加），推导关于 $\\alpha$ 和 $\\beta$ 的受保护多态性的充要条件。\n\n3. 求解内部平衡等位基因频率 $p^{\\ast} \\in (0,1)$（用 $\\alpha$ 和 $\\beta$ 表示），并根据你推导的确定性动态证明其局部稳定性。\n\n将你的最终答案表示为稳定内部平衡等位基因频率 $p^{\\ast}$ 的单一闭式代数表达式，不带单位。如果你进行任何近似，它们必须是精确的代数简化；不需要数值四舍五入。", "solution": "题干已经过验证，被认定为有效。这是一个在理论群体遗传学中提法得当、有科学依据的问题，没有矛盾、歧义或事实错误。它提出了一个负频率依赖选择的标准模型。我们可以开始求解。\n\n该问题要求对选择作用下单倍体群体中两个等位基因 $A$ 和 $a$ 的动态进行三部分推导。令 $p$ 为等位基因 $A$ 的频率，$1-p$ 为等位基因 $a$ 的频率。绝对赖特适应度被给出为频率依赖的函数：\n$$\nw_{A}(p) = 1 - \\alpha p\n$$\n$$\nw_{a}(p) = 1 - \\beta (1 - p)\n$$\n其中参数 $\\alpha$ 和 $\\beta$ 是正常数，$\\alpha > 0$ 且 $\\beta > 0$。分析假设世代离散，有效种群规模无限，且没有突变和迁移。\n\n1. $p_{t+1}$ 递归式的推导。\n\n在单倍体群体中，一个等位基因在下一代（$t+1$）的频率由其在当前代（$t$）的频率及其相对适应度决定。第 $t+1$ 代等位基因 $A$ 的频率，记为 $p_{t+1}$，是选择后基因库中所有等位基因里 $A$ 等位基因的比例。它等于第 $t$ 代 $A$ 的频率 $p_t$ 乘以其绝对适应度 $w_{A}(p_{t})$，再除以群体的平均适应度 $\\bar{w}(p_{t})$。\n\n平均适应度 $\\bar{w}(p_{t})$ 是两个等位基因适应度的加权平均值，权重是它们的频率：\n$$\n\\bar{w}(p_{t}) = p_{t} w_{A}(p_{t}) + (1 - p_{t}) w_{a}(p_{t})\n$$\n代入给定的适应度函数：\n$$\n\\bar{w}(p_{t}) = p_{t}(1 - \\alpha p_{t}) + (1 - p_{t})(1 - \\beta (1 - p_{t}))\n$$\n该表达式表示第 $t$ 代群体中个体的平均适应度。\n\n因此，$p_{t+1}$ 的递归式为：\n$$\np_{t+1} = \\frac{p_{t} w_{A}(p_{t})}{\\bar{w}(p_{t})}\n$$\n代入适应度函数的具体形式，完整的递归式为：\n$$\np_{t+1} = \\frac{p_{t}(1 - \\alpha p_{t})}{p_{t}(1 - \\alpha p_{t}) + (1 - p_{t})(1 - \\beta(1-p_{t}))}\n$$\n这就是所要求的等位基因频率的确定性递归式。\n\n2. 受保护多态性的条件。\n\n受保护多态性是指两个等位基因都保留在群体中的状态，因为每个等位基因在稀有时其频率都能增加。这需要同时满足两个条件：\n(i) 等位基因 $A$ 在稀有时（即当 $p \\to 0$ 时）频率必须增加。\n(ii) 等位基因 $a$ 在稀有时（即当 $p \\to 1$ 时）频率必须增加。\n\n如果携带等位基因 $A$ 的个体比群体平均适应度更高，即 $w_{A}(p) > \\bar{w}(p)$，则 $A$ 的频率会增加。代入 $\\bar{w}(p)$ 的定义，这等价于 $w_{A}(p) > p w_{A}(p) + (1-p) w_{a}(p)$，可简化为 $w_{A}(p) > w_{a}(p)$（对于 $p \\in [0, 1)$）。\n\n对于条件 (i)，我们在 $p \\to 0$ 时评估这个不等式：\n$$\nw_{A}(0) > w_{a}(0)\n$$\n使用给定的适应度函数：\n$$\nw_{A}(0) = 1 - \\alpha(0) = 1\n$$\n$$\nw_{a}(0) = 1 - \\beta(1-0) = 1 - \\beta\n$$\n条件变为 $1 > 1 - \\beta$，简化为 $\\beta > 0$。\n\n对于条件 (ii)，等位基因 $a$ 在稀有时频率必须增加。这意味着它的频率 $1-p$ 在 $1-p \\to 0$（等价于 $p \\to 1$）时必须增加。这发生在携带等位基因 $a$ 的个体适应度高于群体平均值时，即 $w_{a}(p) > \\bar{w}(p)$，这等价于 $w_{a}(p) > w_{A}(p)$。我们在 $p \\to 1$ 时评估此条件：\n$$\nw_{a}(1) > w_{A}(1)\n$$\n使用适应度函数：\n$$\nw_{a}(1) = 1 - \\beta(1-1) = 1\n$$\n$$\nw_{A}(1) = 1 - \\alpha(1) = 1 - \\alpha\n$$\n条件变为 $1 > 1 - \\alpha$，简化为 $\\alpha > 0$。\n\n题干已给出 $\\alpha > 0$ 和 $\\beta > 0$。然而，对参数空间的完整描述还必须确保模型在生物学上是合理的。绝对适应度不能为负。因此，我们必须强制要求对于所有 $p \\in [0,1]$，都有 $w_{A}(p) \\ge 0$ 和 $w_{a}(p) \\ge 0$。\n函数 $w_{A}(p) = 1 - \\alpha p$ 随 $p$ 单调递减。它在区间 $[0,1]$ 上的最小值在 $p=1$ 处取得，此时 $w_{A}(1) = 1 - \\alpha$。约束条件 $w_{A}(1) \\ge 0$ 意味着 $1 - \\alpha \\ge 0$，即 $\\alpha \\le 1$。\n函数 $w_{a}(p) = 1 - \\beta(1-p)$ 随 $p$ 单调递增。它在 $[0,1]$ 上的最小值在 $p=0$ 处取得，此时 $w_{a}(0) = 1 - \\beta$。约束条件 $w_{a}(0) \\ge 0$ 意味着 $1 - \\beta \\ge 0$，即 $\\beta \\le 1$。\n\n因此，对于一个具有生物学意义的受保护多态性，参数 $\\alpha$ 和 $\\beta$ 的充要条件是两个等位基因在稀有时都能入侵（$\\alpha > 0, \\beta > 0$）并且适应度保持非负（$ \\alpha \\le 1, \\beta \\le 1$）。合并后的条件是 $0  \\alpha \\le 1$ 和 $0  \\beta \\le 1$。\n\n3. 内部平衡及其稳定性。\n\n平衡频率 $p^{\\ast}$ 是一个 $p$ 值，在该值下等位基因频率从一代到下一代不发生变化，即 $p_{t+1} = p_{t} = p^{\\ast}$。频率 $p=0$ 和 $p=1$ 总是平凡平衡点。我们寻求一个内部平衡点，其中 $0  p^{\\ast}  1$。\n对于这样的平衡点，递归式 $p^{\\ast} = \\frac{p^{\\ast} w_{A}(p^{\\ast})}{\\bar{w}(p^{\\ast})}$ 必须成立。由于 $p^{\\ast} \\ne 0$，我们可以用它来除，得到 $1 = \\frac{w_{A}(p^{\\ast})}{\\bar{w}(p^{\\ast})}$，这意味着 $\\bar{w}(p^{\\ast}) = w_{A}(p^{\\ast})$。\n代入 $\\bar{w}(p^{\\ast})$ 的定义，得到 $p^{\\ast}w_{A}(p^{\\ast}) + (1-p^{\\ast})w_{a}(p^{\\ast}) = w_{A}(p^{\\ast})$。\n这可以简化为 $(1-p^{\\ast})w_{a}(p^{\\ast}) = (1-p^{\\ast})w_{A}(p^{\\ast})$。由于 $p^{\\ast} \\ne 1$，我们可以用 $(1-p^{\\ast})$ 来除，得到内部选择平衡的一般条件：\n$$\nw_{A}(p^{\\ast}) = w_{a}(p^{\\ast})\n$$\n在这个频率上，两个等位基因的适应度相等。代入给定的函数：\n$$\n1 - \\alpha p^{\\ast} = 1 - \\beta(1 - p^{\\ast})\n$$\n$$\n-\\alpha p^{\\ast} = -\\beta(1 - p^{\\ast})\n$$\n$$\n\\alpha p^{\\ast} = \\beta - \\beta p^{\\ast}\n$$\n$$\n\\alpha p^{\\ast} + \\beta p^{\\ast} = \\beta\n$$\n$$\np^{\\ast}(\\alpha + \\beta) = \\beta\n$$\n由于 $\\alpha > 0$ 且 $\\beta > 0$，$(\\alpha + \\beta)$ 非零，我们可以解出 $p^{\\ast}$：\n$$\np^{\\ast} = \\frac{\\beta}{\\alpha + \\beta}\n$$\n这是唯一的内部平衡频率。对于 $\\alpha > 0$ 和 $\\beta > 0$，显然有 $0  p^{\\ast}  1$。\n\n为证明该平衡的稳定性，我们考察等位基因频率的变化量 $\\Delta p = p_{t+1} - p_t$。$\\Delta p$ 的符号由 $w_A(p) - w_a(p)$ 的符号决定。让我们分析这个差值：\n$$\ng(p) = w_{A}(p) - w_{a}(p) = (1 - \\alpha p) - (1 - \\beta(1-p)) = \\beta - (\\alpha + \\beta)p\n$$\n如果 $g(p) > 0$，等位基因频率 $p$ 将增加；如果 $g(p)  0$，则将减少。\n- 如果 $p  p^{\\ast} = \\frac{\\beta}{\\alpha+\\beta}$，则 $(\\alpha+\\beta)p  \\beta$，所以 $g(p) = \\beta - (\\alpha+\\beta)p > 0$。因此，$p$ 将向 $p^{\\ast}$ 增加。\n- 如果 $p > p^{\\ast} = \\frac{\\beta}{\\alpha+\\beta}$，则 $(\\alpha+\\beta)p > \\beta$，所以 $g(p) = \\beta - (\\alpha+\\beta)p  0$。因此，$p$ 将向 $p^{\\ast}$ 减少。\n\n因为等位基因频率总是从 $(0,1)$ 内的任何其他起始频率向 $p^{\\ast}$ 移动，所以平衡点 $p^{\\ast}$ 是局部稳定的。实际上，这一分析证明了在区间 $(0,1)$ 内的全局稳定性。对于一个负频率依赖选择的系统来说，这是一个预期的结果，其中稀有等位基因总是具有适应度优势，从而驱动种群达到一个平衡的中间频率。", "answer": "$$\n\\boxed{\\frac{\\beta}{\\alpha + \\beta}}\n$$", "id": "2588599"}, {"introduction": "虽然选择可能是一种确定性力量，但进化也深受随机机遇（即遗传漂变）的影响。本练习旨在连接像 Wright-Fisher 过程这样的离散世代模型与其连续扩散近似之间的桥梁。通过编写模拟程序并将其结果与理论预测进行比较 ([@problem_id:2588608])，你将对随机的等位基因频率动态以及验证群体遗传学模型的方法有更切实的理解。", "problem": "要求您通过推导和实现一个将离散世代的 Wright-Fisher 过程与其连续时间扩散近似联系起来的中性漂变基准，将群体遗传学的基本定义与算法验证联系起来。在标准的、中性的、具有恒定群体大小的二倍体 Wright-Fisher 设置下进行操作。\n\n仅使用以下基本原理：\n- 离散世代中性和随机遗传漂变：在一个大小为 $N$ 的二倍体群体中，有 $2N$ 个基因拷贝。在中性、无选择、无突变、无迁移的随机交配条件下，第 $t$ 代的等位基因频率 $p_{t}$ 通过抽样 $X_{t+1} \\sim \\mathrm{Binomial}(2N, p_{t})$ 并设置 $p_{t+1} = X_{t+1}/(2N)$ 来演化。\n- 全期望定律和全方差定律。\n- 中性 Wright-Fisher 动态的扩散近似：在 $N$ 很大的极限下，$p(t)$ 满足一个随机微分方程（Stochastic Differential Equation, SDE），其无穷小方差与 $p(t) \\left(1 - p(t)\\right)/(2N)$ 成正比；由此推导出二阶矩的常微分方程，进而推导出方差的常微分方程。\n\n需要完成的任务：\n1. 从上述基本原理出发，推导出中性条件下 $p_{t}$ 均值和方差的离散时间递推关系，并求解其闭式解。将得到的 $\\mathbb{E}[p_{t}]$ 和 $\\mathrm{Var}(p_{t})$ 表示为 $t$、$N$ 和 $p_{0}$ 的函数。\n2. 从扩散近似的基本原理出发，推导出 $\\mathrm{Var}(p(t))$ 的连续时间方程，并求解其关于 $t$、$N$ 和 $p_{0}$ 的闭式解。陈述得到的表达式。\n3. 设计一个最小化模拟，以量化漂变下的随机等位基因频率路径，并对照离散世代预测来验证扩散结果。对于每组参数，模拟 $R$ 条从 $p_{0}$ 开始、长度为 $T$ 代的中性 Wright–Fisher 过程的独立重复路径，并在每一代 $t \\in \\{1,\\dots,T\\}$ 计算所有重复路径的：\n   - 样本均值 $\\widehat{m}(t)$，\n   - 样本方差 $\\widehat{v}(t)$。\n   然后计算以下三个标量摘要诊断指标：\n   - $E_{\\mathrm{mean}} = \\max_{1 \\le t \\le T} \\left| \\widehat{m}(t) - p_{0} \\right|$，\n   - $E_{\\mathrm{disc}} = \\max_{1 \\le t \\le T} \\left| \\widehat{v}(t) - v_{\\mathrm{disc}}(t) \\right|$，其中 $v_{\\mathrm{disc}}(t)$ 是您在任务1中得到的离散时间方差的闭式解，\n   - $E_{\\mathrm{diff}} = \\left| v_{\\mathrm{diff}}(T) - v_{\\mathrm{disc}}(T) \\right|$，其中 $v_{\\mathrm{diff}}(t)$ 是您在任务2中得到的扩散方差的闭式解。\n4. 确定性要求：使用固定的伪随机种子以确保结果可复现。\n5. 所有概率和频率必须表示为 $[0,1]$ 区间内的小数。\n\n测试套件和接受阈值：\n实现您的程序以运行以下三组参数集。每组参数以元组 $(N, T, p_{0}, R, \\varepsilon_{\\mathrm{mean}}, \\varepsilon_{\\mathrm{var}}, \\tau)$ 的形式给出，其中 $\\varepsilon_{\\mathrm{mean}}$ 和 $\\varepsilon_{\\mathrm{var}}$ 分别是 $E_{\\mathrm{mean}}$ 和 $E_{\\mathrm{disc}}$ 的接受阈值，$\\tau$ 是在时间 $T$ 时 $E_{\\mathrm{diff}}$ 的接受阈值。\n- 案例A（大群体，中等时间，中等频率）：$(N, T, p_{0}, R, \\varepsilon_{\\mathrm{mean}}, \\varepsilon_{\\mathrm{var}}, \\tau) = (1000, 50, 0.3, 12000, 0.005, 0.001, 1\\times 10^{-4})$。\n- 案例B（小群体，中等时间，对称频率）：$(N, T, p_{0}, R, \\varepsilon_{\\mathrm{mean}}, \\varepsilon_{\\mathrm{var}}, \\tau) = (20, 50, 0.5, 20000, 0.01, 0.01, 0.005)$。\n- 案例C（中等群体，长时间，稀有等位基因）：$(N, T, p_{0}, R, \\varepsilon_{\\mathrm{mean}}, \\varepsilon_{\\mathrm{var}}, \\tau) = (100, 200, 0.01, 15000, 0.005, 0.001, 1\\times 10^{-4})$。\n\n程序要求：\n- 实现模拟以及您推导出的两个闭式解预测。\n- 对每个案例，计算三个诊断指标 $E_{\\mathrm{mean}}$、$E_{\\mathrm{disc}}$ 和 $E_{\\mathrm{diff}}$，然后为每个案例返回一个布尔值，指示是否同时满足所有三个标准：\n  - $E_{\\mathrm{mean}} \\le \\varepsilon_{\\mathrm{mean}}$,\n  - $E_{\\mathrm{disc}} \\le \\varepsilon_{\\mathrm{var}}$,\n  - $E_{\\mathrm{diff}} \\le \\tau$.\n- 使用固定的伪随机数生成器种子。\n- 最终输出格式：您的程序应生成一行输出，包含案例 A、B 和 C 的三个布尔值，形式为用方括号括起来的逗号分隔列表（例如，$[\\text{True}, \\text{False}, \\text{True}]$）。不应打印任何额外文本。\n\n不涉及物理单位。所有输出必须是布尔值。不使用角度。将所有概率和频率表示为 $[0,1]$ 区间内的小数。", "solution": "问题陈述是理论和计算群体遗传学中一个有效且定义明确的练习。它要求推导遗传漂变的 Wright-Fisher 模型的基本结果，并通过随机模拟进行验证。该问题在科学上是合理的，内部一致，并包含了继续进行所需的所有必要信息。\n\n我现在将按要求提供分步推导和模拟设计的描述。\n\n**任务1：离散时间 Wright-Fisher 模型分析**\n\n给定一个大小恒为 $N$ 的二倍体群体。第 $t$ 代的等位基因频率 $p_t$ 根据规则 $p_{t+1} = X_{t+1}/(2N)$ 演化，其中下一代'A'等位基因的数量 $X_{t+1}$ 从二项分布 $X_{t+1} \\sim \\mathrm{Binomial}(2N, p_t)$ 中抽取。该过程从一个固定的初始频率 $p_0$ 开始。\n\n**均值等位基因频率 $\\mathbb{E}[p_t]$ 的推导**\n\n我们使用全期望定律：$\\mathbb{E}[p_{t+1}] = \\mathbb{E}[\\mathbb{E}[p_{t+1} | p_t]]$。\n首先，我们求在给定 $p_t$ 条件下 $p_{t+1}$ 的条件期望。\n$$\n\\mathbb{E}[p_{t+1} | p_t] = \\mathbb{E}\\left[\\frac{X_{t+1}}{2N} \\bigg| p_t\\right] = \\frac{1}{2N} \\mathbb{E}[X_{t+1} | p_t]\n$$\n二项随机变量 $\\mathrm{Binomial}(n, p)$ 的期望是 $np$。在这里，$n=2N$，概率是 $p_t$。\n$$\n\\mathbb{E}[X_{t+1} | p_t] = (2N) p_t\n$$\n将此代入 $\\mathbb{E}[p_{t+1} | p_t]$ 的表达式中：\n$$\n\\mathbb{E}[p_{t+1} | p_t] = \\frac{1}{2N} (2N p_t) = p_t\n$$\n现在，应用外层期望：\n$$\n\\mathbb{E}[p_{t+1}] = \\mathbb{E}[p_t]\n$$\n这是一个简单的递推关系。通过归纳法，并使用初始条件 $\\mathbb{E}[p_0] = p_0$（因为 $p_0$ 是一个给定的常数），我们发现均值等位基因频率随时间保持不变。\n$$\n\\mathbb{E}[p_t] = p_0\n$$\n\n**等位基因频率方差 $\\mathrm{Var}(p_t)$ 的推导**\n\n我们使用全方差定律：$\\mathrm{Var}(p_{t+1}) = \\mathbb{E}[\\mathrm{Var}(p_{t+1} | p_t)] + \\mathrm{Var}(\\mathbb{E}[p_{t+1} | p_t])$。根据我们之前的推导，我们知道 $\\mathbb{E}[p_{t+1} | p_t] = p_t$。因此第二项是 $\\mathrm{Var}(p_t)$。\n对于第一项，我们需要条件方差 $\\mathrm{Var}(p_{t+1} | p_t)$。二项随机变量 $\\mathrm{Binomial}(n, p)$ 的方差是 $np(1-p)$。\n$$\n\\mathrm{Var}(p_{t+1} | p_t) = \\mathrm{Var}\\left(\\frac{X_{t+1}}{2N} \\bigg| p_t\\right) = \\frac{1}{(2N)^2} \\mathrm{Var}(X_{t+1} | p_t) = \\frac{2N p_t(1-p_t)}{4N^2} = \\frac{p_t(1-p_t)}{2N}\n$$\n现在，我们对这个条件方差在 $p_t$ 的分布上求期望：\n$$\n\\mathbb{E}[\\mathrm{Var}(p_{t+1} | p_t)] = \\mathbb{E}\\left[\\frac{p_t(1-p_t)}{2N}\\right] = \\frac{1}{2N}\\left(\\mathbb{E}[p_t] - \\mathbb{E}[p_t^2]\\right)\n$$\n我们知道 $\\mathbb{E}[p_t] = p_0$ 并且 $\\mathbb{E}[p_t^2] = \\mathrm{Var}(p_t) + (\\mathbb{E}[p_t])^2 = \\mathrm{Var}(p_t) + p_0^2$。代入这些：\n$$\n\\mathbb{E}[\\mathrm{Var}(p_{t+1} | p_t)] = \\frac{1}{2N}\\left(p_0 - (\\mathrm{Var}(p_t) + p_0^2)\\right) = \\frac{p_0(1-p_0) - \\mathrm{Var}(p_t)}{2N}\n$$\n将全方差定律的两个部分结合起来，我们得到 $v_t = \\mathrm{Var}(p_t)$ 的一个递推关系：\n$$\nv_{t+1} = \\frac{p_0(1-p_0) - v_t}{2N} + v_t = \\left(1 - \\frac{1}{2N}\\right)v_t + \\frac{p_0(1-p_0)}{2N}\n$$\n这是一个线性一阶递推关系，初始条件为 $v_0 = \\mathrm{Var}(p_0) = 0$。通过观察不动点为 $v^* = p_0(1-p_0)$ 可以找到解。与不动点的偏差呈几何衰减：$v_{t+1} - v^* = (1 - 1/(2N))(v_t - v^*)$。展开递推关系得到 $v_t - v^* = (1-1/(2N))^t(v_0 - v^*)$。\n当 $v_0=0$ 时，这得到 $v_t = v^*(1 - (1-1/(2N))^t)$。\n离散时间方差的闭式解为：\n$$\nv_{\\mathrm{disc}}(t) = p_0(1-p_0)\\left[1 - \\left(1 - \\frac{1}{2N}\\right)^t\\right]\n$$\n\n**任务2：扩散近似分析**\n\nWright-Fisher 过程的连续时间扩散近似由一个随机微分方程（SDE）描述，其中无穷小方差为 $\\sigma^2(p) = p(1-p)/(2N)$，无穷小漂移为 $\\mu(p)=0$。为了找到方差的演化，我们首先使用相应的前向 Kolmogorov 方程找到二阶矩 $m_2(t) = \\mathbb{E}[p(t)^2]$ 的动态。对于任何平滑函数 $f(p)$，其期望 $\\mathbb{E}[f(p(t))]$ 的演化如下：\n$$\n\\frac{d}{dt}\\mathbb{E}[f(p)] = \\mathbb{E}\\left[\\mu(p) \\frac{\\partial f}{\\partial p} + \\frac{1}{2}\\sigma^2(p) \\frac{\\partial^2 f}{\\partial p^2}\\right]\n$$\n我们选择 $f(p) = p^2$。那么 $\\frac{\\partial f}{\\partial p}=2p$ 且 $\\frac{\\partial^2 f}{\\partial p^2}=2$。\n$$\n\\frac{d}{dt}\\mathbb{E}[p^2] = \\mathbb{E}\\left[0 \\cdot (2p) + \\frac{1}{2}\\frac{p(1-p)}{2N} \\cdot 2\\right] = \\mathbb{E}\\left[\\frac{p(1-p)}{2N}\\right] = \\frac{1}{2N}\\left(\\mathbb{E}[p] - \\mathbb{E}[p^2]\\right)\n$$\n与离散情况一样，$\\mathbb{E}[p(t)] = p_0$。令 $m_2(t) = \\mathbb{E}[p(t)^2]$，我们得到常微分方程：\n$$\n\\frac{dm_2}{dt} = \\frac{1}{2N}(p_0 - m_2)\n$$\n这是一个线性一阶常微分方程（ODE），可以重新排列为 $\\frac{dm_2}{dt} + \\frac{1}{2N}m_2 = \\frac{p_0}{2N}$。在初始条件 $m_2(0) = \\mathbb{E}[p_0^2] = p_0^2$ 下，解为：\n$$\nm_2(t) = p_0 - p_0(1-p_0)e^{-t/(2N)}\n$$\n方差 $v_{\\mathrm{diff}}(t) = \\mathrm{Var}(p(t))$，则可通过以下方式求得：\n$$\nv_{\\mathrm{diff}}(t) = \\mathbb{E}[p(t)^2] - (\\mathbb{E}[p(t)])^2 = m_2(t) - p_0^2\n$$\n$$\nv_{\\mathrm{diff}}(t) = \\left(p_0 - p_0(1-p_0)e^{-t/(2N)}\\right) - p_0^2 = p_0(1-p_0) - p_0(1-p_0)e^{-t/(2N)}\n$$\n这给出了扩散近似下 方差的闭式解：\n$$\nv_{\\mathrm{diff}}(t) = p_0(1-p_0)\\left(1 - e^{-t/(2N)}\\right)\n$$\n\n**任务3：模拟与验证逻辑**\n\n实现将遵循对离散过程的直接模拟。对于每个测试案例 $(N, T, p_0, R, ...)$，我们执行以下步骤：\n1.  **可复现性**：为伪随机数生成器设置一个固定的种子，以确保结果是确定性的。\n2.  **模拟**：对 $R$ 个独立的群体路径进行 $T$ 代模拟。初始化一个大小为 $(R, T+1)$ 的数组，第一列设置为 $p_0$。然后，对于从 $0$ 到 $T-1$ 的每一代 $t$，所有 $R$ 个重复的下一代 $t+1$ 的等位基因计数同时从二项分布 $\\mathrm{Binomial}(2N, \\mathbf{p}_t)$ 中抽取，其中 $\\mathbf{p}_t$ 是所有重复在时间 $t$ 的频率向量。然后更新频率。这种向量化方法计算效率高。\n3.  **分析**：模拟结束后，计算理论统计量和样本统计量。\n    -   使用推导出的公式计算所有 $t \\in \\{0, \\dots, T\\}$ 的理论方差预测值 $v_{\\mathrm{disc}}(t)$ 和 $v_{\\mathrm{diff}}(t)$。\n    -   在每个时间步长上，跨 $R$ 个重复计算样本均值 $\\widehat{m}(t)$ 和样本方差 $\\widehat{v}(t)$。\n4.  **诊断**：计算三个误差指标。\n    -   $E_{\\mathrm{mean}} = \\max_{1 \\le t \\le T} \\left| \\widehat{m}(t) - p_{0} \\right|$: 衡量经验均值与理论常数均值的最大偏差。这证实了漂变过程的无偏性。\n    -   $E_{\\mathrm{disc}} = \\max_{1 \\le t \\le T} \\left| \\widehat{v}(t) - v_{\\mathrm{disc}}(t) \\right|$: 衡量经验方差与精确离散理论的最大偏差。这验证了模拟的准确性。\n    -   $E_{\\mathrm{diff}} = \\left| v_{\\mathrm{diff}}(T) - v_{\\mathrm{disc}}(T) \\right|$: 衡量在最后一代时，扩散模型相对于离散模型的近似误差。这是一个纯理论上的比较。\n5.  **验证**：对于每个测试案例，将计算出的指标与提供的阈值进行比较：$E_{\\mathrm{mean}} \\le \\varepsilon_{\\mathrm{mean}}$，$E_{\\mathrm{disc}} \\le \\varepsilon_{\\mathrm{var}}$，以及 $E_{\\mathrm{diff}} \\le \\tau$。如果所有三个不等式都成立，则该案例的最终结果为 `True`，否则为 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, simulates, and validates the neutral Wright-Fisher process\n    against its discrete and continuous theoretical predictions.\n    \"\"\"\n    \n    # Set a fixed seed for the pseudorandom number generator for reproducibility.\n    # The problem requires this for deterministic output.\n    np.random.seed(42)\n\n    # Test suite from the problem statement.\n    # Each tuple contains:\n    # (N, T, p0, R, eps_mean, eps_var, tau)\n    # N: diploid population size\n    # T: number of generations\n    # p0: initial allele frequency\n    # R: number of replicate simulations\n    # eps_mean: acceptance threshold for E_mean\n    # eps_var: acceptance threshold for E_disc\n    # tau: acceptance threshold for E_diff\n    test_cases = [\n        # Case A: large population, moderate time, intermediate frequency\n        (1000, 50, 0.3, 12000, 0.005, 0.001, 1e-4),\n        # Case B: small population, moderate time, symmetric frequency\n        (20, 50, 0.5, 20000, 0.01, 0.01, 0.005),\n        # Case C: moderate population, long time, rare allele\n        (100, 200, 0.01, 15000, 0.005, 0.001, 1e-4),\n    ]\n\n    # This list will store the boolean result (True/False) for each test case.\n    results = []\n\n    for case in test_cases:\n        N, T, p0, R, eps_mean, eps_var, tau = case\n\n        # --- 1. Simulation of the discrete Wright-Fisher process ---\n        \n        # Array to store allele frequency paths for R replicates over T+1 time points (0 to T)\n        paths = np.zeros((R, T + 1))\n        # Set initial frequency for all replicates\n        paths[:, 0] = p0\n\n        # Run the simulation for T generations\n        for t in range(T):\n            # Get current frequencies for all R replicates\n            current_p = paths[:, t]\n            \n            # For each replicate, draw the number of alleles for the next generation\n            # from a binomial distribution. This is done in a vectorized manner for efficiency.\n            num_alleles = np.random.binomial(2 * N, current_p)\n            \n            # Calculate and store the new frequencies for the next generation\n            paths[:, t + 1] = num_alleles / (2 * N)\n\n        # --- 2. Calculation of theoretical predictions and sample statistics ---\n\n        # Time vector from t=0 to t=T\n        t_vec = np.arange(T + 1)\n\n        # Theoretical variance for the discrete-generation model (v_disc)\n        # v_disc(t) = p0*(1-p0) * (1 - (1 - 1/(2N))^t)\n        v_disc = p0 * (1.0 - p0) * (1.0 - (1.0 - 1.0 / (2.0 * N))**t_vec)\n\n        # Theoretical variance for the continuous-time diffusion approximation (v_diff)\n        # v_diff(t) = p0*(1-p0) * (1 - exp(-t/(2N)))\n        v_diff = p0 * (1.0 - p0) * (1.0 - np.exp(-t_vec / (2.0 * N)))\n\n        # Sample mean of allele frequency across replicates at each time point\n        m_hat = np.mean(paths, axis=0)\n        \n        # Sample variance of allele frequency across replicates at each time point.\n        # ddof=0 calculates the population variance (MLE), which is appropriate\n        # for comparison against a theoretical population parameter with large R.\n        v_hat = np.var(paths, axis=0, ddof=0)\n        \n        # --- 3. Computation of diagnostic error metrics ---\n\n        # E_mean: Max deviation of sample mean from theoretical mean (p0) for t>0.\n        E_mean = np.max(np.abs(m_hat[1:] - p0))\n        \n        # E_disc: Max deviation of sample variance from discrete theory for t>0.\n        E_disc = np.max(np.abs(v_hat[1:] - v_disc[1:]))\n\n        # E_diff: Theoretical deviation between diffusion and discrete models at T.\n        E_diff = np.abs(v_diff[T] - v_disc[T])\n\n        # --- 4. Validation against acceptance thresholds ---\n        \n        # A case is valid if and only if all three error metrics are within their thresholds.\n        is_valid = (E_mean = eps_mean) and \\\n                   (E_disc = eps_var) and \\\n                   (E_diff = tau)\n        \n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    # The output is a list of booleans, one for each test case.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2588608"}, {"introduction": "进化过程在地理景观上展开，形成了如杂交带等遗传变异的空间格局。这项高级练习让你扮演研究者的角色，分析基因流与杂种选择相互作用下的遗传渐变带数据。你将应用最大似然估计和模型比较技术，从遗传数据中推断关键的进化参数 ([@problem_id:2588562])，这是现代进化生物学和比较生物学的核心技能。", "problem": "给定来自比较动物学和植物学的生物体中，多个独立基因座在接触区一维样带上的基因型计数数据。假设一个理想化的一维、静态的迁移-选择平衡，该平衡由针对等位基因频率 $p(x)$（沿位置 $x$ 分布）的 Fisher–Kolmogorov–Petrovskii–Piskunov (Fisher–KPP) 框架描述。其中，扩散由每代均方根位移为 $\\sigma$ 的高斯增量近似，且针对杂合子的对称性次显性选择（underdominant selection）的选择系数为 $s_{\\mathrm{H}}$。在这些经典假设下，等位基因频率的稳定渐变带（cline）可以很好地用一个具有单一中心和宽度的 S 型函数来近似，其宽度 $w$ 与扩散和选择参数之间通过经过充分检验的关系式相关联\n$$\nw^2 = \\frac{8 \\, \\sigma^2}{s_{\\mathrm{H}}}.\n$$\n假设在采样点内符合哈迪-温伯格平衡，且基因座之间相互独立。\n\n将每个基因座的渐变带定义为一个由中心 $c$ 和宽度 $w$ 参数化的逻辑斯谛函数：\n$$\np(x \\mid c,w) = \\frac{1}{1 + \\exp\\left(-\\frac{2(x-c)}{w}\\right)}.\n$$\n设一个基因座的数据由位置 $\\{x_i\\}_{i=1}^m$、样本量 $\\{n_i\\}_{i=1}^m$ 和衍生等位基因计数 $\\{k_i\\}_{i=1}^m$ 组成。将计数建模为条件独立的二项式抽样 $k_i \\sim \\mathrm{Binomial}(n_i, p(x_i \\mid c,w))$。对于 $L$ 个基因座的集合，将联合对数似然写为所有基因座和所有位置上的总和。\n\n您的任务是：\n- 在两种模型下实现渐变带参数的最大似然估计：\n  - 模型 $\\mathcal{M}_0$：所有基因座共享一个单一的渐变带中心 $c$ 和宽度 $w$。\n  - 模型 $\\mathcal{M}_1$：每个基因座 $\\ell \\in \\{1,\\dots,L\\}$ 都有其自己的中心 $c_{\\ell}$ 和宽度 $w_{\\ell}$。\n- 使用似然比检验（LRT），其统计量为\n  $$\n  \\Lambda = 2\\left(\\ell(\\widehat{\\theta}_{\\mathcal{M}_1}) - \\ell(\\widehat{\\theta}_{\\mathcal{M}_0})\\right),\n  $$\n  其中 $\\ell(\\cdot)$ 表示在相应模型下的最大化对数似然。在常规正则性条件下，评估 $\\Lambda$ 在自由度为 $\\Delta = 2(L-1)$ 的卡方分布下的尾部概率，并在显著性水平 $\\alpha = 0.05$（以小数表示）下判断是否“一致”。“一致”意味着未能拒绝 $\\mathcal{M}_0$。\n- 根据在 $\\mathcal{M}_0$ 模型下拟合的宽度，使用关系式 $w^2 = 8\\sigma^2/s_{\\mathrm{H}}$ 推断未知的进化参数，具体如下：\n  - 如果外部测量提供了 $s_{\\mathrm{H}}$（视为已知），则通过以下方式估计 $\\sigma$\n    $$\n    \\widehat{\\sigma} = \\sqrt{\\frac{s_{\\mathrm{H}} \\, \\widehat{w}^2}{8}}.\n    $$\n  - 如果外部测量提供了 $\\sigma$（视为已知），则通过以下方式估计 $s_{\\mathrm{H}}$\n    $$\n    \\widehat{s}_{\\mathrm{H}} = \\frac{8 \\, \\sigma^2}{\\widehat{w}^2}.\n    $$\n  此处 $\\widehat{w}$ 是在 $\\mathcal{M}_0$ 模型下的最大似然估计。\n\n为了在计算对数似然时保持数值稳定性，请确保在计算过程中将概率限制在开放区间 $(\\varepsilon, 1-\\varepsilon)$ 内，其中 $\\varepsilon$ 是一个很小的数（例如 $\\varepsilon = 10^{-9}$）。\n\n您的程序必须解决以下三个测试用例。对于每个测试用例，输出一个包含两个元素的列表 $[\\text{param\\_hat}, \\text{reject\\_H0}]$，其中：\n- $\\text{param\\_hat}$ 是估计出的未知参数（一个浮点数），四舍五入到恰好 $3$ 位小数。如果 $s_{\\mathrm{H}}$ 已知，$\\text{param\\_hat}$ 应为 $\\widehat{\\sigma}$。如果 $\\sigma$ 已知，$\\text{param\\_hat}$ 应为 $\\widehat{s}_{\\mathrm{H}}$。\n- $\\text{reject\\_H0}$ 是一个布尔值，指示一致性（$\\mathcal{M}_0$）的原假设是否在 $\\alpha = 0.05$ 的水平下被拒绝。\n\n将三个测试用例的结果汇总到单行输出中，该输出包含一个用方括号括起来的、以逗号分隔的列表，例如 $[[...],[...],[...]]$。\n\n测试套件：\n- 测试用例 $1$（共享渐变带；已知 $s_{\\mathrm{H}}$）：\n  - 基因座 $L = 3$，具有相同的渐变带。\n  - 位置 $x = [-40, -20, 0, 20, 40]$。\n  - 所有位置的样本量 $n_i = 60$。\n  - 每个基因座的衍生等位基因计数（每个基因座相同）：\n    - 基因座 $1$：$k = [1, 6, 30, 54, 59]$。\n    - 基因座 $2$：$k = [1, 6, 30, 54, 59]$。\n    - 基因座 $3$：$k = [1, 6, 30, 54, 59]$。\n  - 外部已知参数：$s_{\\mathrm{H}} = 0.1$（无量纲）。\n  - 此测试的所需输出：$[\\widehat{\\sigma}, \\text{reject\\_H0}]$。\n\n- 测试用例 $2$（不同宽度；相同中心；已知 $\\sigma$）：\n  - 基因座 $L = 3$，具有共享中心和不同宽度。\n  - 位置 $x = [-40, -20, 0, 20, 40]$。\n  - 所有位置的样本量 $n_i = 60$。\n  - 每个基因座的衍生等位基因计数：\n    - 基因座 $1$：$k = [0, 2, 30, 58, 60]$。\n    - 基因座 $2$：$k = [1, 6, 30, 54, 59]$。\n    - 基因座 $3$：$k = [4, 13, 30, 47, 56]$。\n  - 外部已知参数：$\\sigma = 2.0$（单位与 $x$ 的任意空间单位相同，每代）。\n  - 此测试的所需输出：$[\\widehat{s}_{\\mathrm{H}}, \\text{reject\\_H0}]$。\n\n- 测试用例 $3$（不同中心；中等宽度；低采样；已知 $\\sigma$）：\n  - 基因座 $L = 2$，具有不同中心和相似宽度。\n  - 位置 $x = [-15, 0, 15]$。\n  - 所有位置的样本量 $n_i = 20$。\n  - 每个基因座的衍生等位基因计数：\n    - 基因座 $1$：$k = [4, 13, 19]$。\n    - 基因座 $2$：$k = [1, 7, 16]$。\n  - 外部已知参数：$\\sigma = 2.0$（单位与 $x$ 的任意空间单位相同，每代）。\n  - 此测试的所需输出：$[\\widehat{s}_{\\mathrm{H}}, \\text{reject\\_H0}]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素本身是一个双元素列表，格式完全如下\n  $$\n  [[\\text{param_hat}_1,\\text{reject_H0}_1],[\\text{param_hat}_2,\\text{reject_H0}_2],[\\text{param_hat}_3,\\text{reject_H0}_3]]\n  $$\n  其中浮点数必须四舍五入到恰好 $3$ 位小数，布尔值打印为 $True$ 或 $False$。", "solution": "该问题要求实现一个统计框架来分析来自多个基因座的遗传渐变带数据。该分析涉及在两个竞争模型下对渐变带参数进行最大似然估计（MLE），然后进行似然比检验（LRT）以在它们之间做出选择，最后推断一个潜在的进化参数。该问题具有科学依据，表述清晰，并包含完整解决方案所需的所有必要信息。我将着手解决它。\n\n问题的核心是在位置 $x_i$ 处，从大小为 $n_i$ 的样本中观察到 $k_i$ 个衍生等位基因的似然，这由二项式概率质量函数决定。成功概率 $p(x_i)$ 表示位置 $x_i$ 处的等位基因频率，并由逻辑斯谛函数建模：\n$$\np(x \\mid c,w) = \\frac{1}{1 + \\exp\\left(-\\frac{2(x-c)}{w}\\right)}\n$$\n其中 $c$ 是渐变带中心，$w$ 是其宽度。参数 $c$ 和 $w$ 是待估计的。\n\n对于一个具有参数 $(c, w)$ 的给定基因座，在位置 $x_i$ 处单个观测值 $(k_i, n_i)$ 的对数似然由二项式概率质量函数的对数给出：\n$$\n\\ell(c, w \\mid k_i, n_i, x_i) = \\log\\binom{n_i}{k_i} + k_i \\log(p(x_i \\mid c, w)) + (n_i - k_i) \\log(1 - p(x_i \\mid c, w))\n$$\n由于二项式系数 $\\binom{n_i}{k_i}$ 不依赖于参数 $(c, w)$，因此在优化过程中可以忽略它。因此，对于具有数据 $\\{(k_i, n_i, x_i)\\}_{i=1}^m$ 的单个基因座，需要最大化的对数似然函数正比于：\n$$\n\\mathcal{L}(c, w) = \\sum_{i=1}^m \\left[ k_i \\log(p(x_i \\mid c, w)) + (n_i - k_i) \\log(1 - p(x_i \\mid c, w)) \\right]\n$$\n为了数值稳定性，概率 $p(x_i \\mid c, w)$ 被裁剪到一个小区间 $[\\varepsilon, 1-\\varepsilon]$ 内，其中 $\\varepsilon = 10^{-9}$。\n\n问题指定了两种模型：\n1.  模型 $\\mathcal{M}_0$：所有 $L$ 个基因座共享一个单一的渐变带，参数为 $(c, w)$。总对数似然是使用相同参数对所有基因座和所有位置求和：\n    $$\n    \\mathcal{L}_0(c, w) = \\sum_{\\ell=1}^L \\sum_{i=1}^{m_\\ell} \\left[ k_{i, \\ell} \\log(p(x_{i, \\ell} \\mid c, w)) + (n_{i, \\ell} - k_{i, \\ell}) \\log(1 - p(x_{i, \\ell} \\mid c, w)) \\right]\n    $$\n    我们通过最大化此函数来找到最大似然估计 $(\\widehat{c}, \\widehat{w})$，这等同于最小化其负值。\n\n2.  模型 $\\mathcal{M}_1$：每个基因座 $\\ell$ 都有其自己独立的参数 $(c_\\ell, w_\\ell)$。由于基因座的独立性，总对数似然是每个基因座的对数似然之和：\n    $$\n    \\mathcal{L}_1(\\{c_\\ell, w_\\ell\\}_{\\ell=1}^L) = \\sum_{\\ell=1}^L \\mathcal{L}(c_\\ell, w_\\ell)\n    $$\n    通过分别为每个基因座最大化似然来找到最大似然估计 $\\{\\widehat{c}_\\ell, \\widehat{w}_\\ell\\}_{\\ell=1}^L$。总的最大化对数似然为 $\\ell(\\widehat{\\theta}_{\\mathcal{M}_1}) = \\sum_{\\ell=1}^L \\mathcal{L}(\\widehat{c}_\\ell, \\widehat{w}_\\ell)$。\n\n使用 L-BFGS-B 算法进行数值优化（如 `scipy.optimize.minimize` 中所实现的）适合于寻找最大似然估计。这需要最小化负对数似然函数。宽度参数 $w$ 必须被约束为正值，因此施加一个小的正下界（例如 $10^{-6}$）。\n\n一旦获得最大化对数似然 $\\ell(\\widehat{\\theta}_{\\mathcal{M}_0})$ 和 $\\ell(\\widehat{\\theta}_{\\mathcal{M}_1})$，就计算似然比检验统计量：\n$$\n\\Lambda = 2\\left(\\ell(\\widehat{\\theta}_{\\mathcal{M}_1}) - \\ell(\\widehat{\\theta}_{\\mathcal{M}_0})\\right)\n$$\n在原假设 $\\mathcal{M}_0$ 下，$\\Lambda$ 服从卡方分布，其自由度等于模型间自由参数数量之差。模型 $\\mathcal{M}_1$ 有 $2L$ 个参数（$L$ 个基因座各有一个 $(c_\\ell, w_\\ell)$），而模型 $\\mathcal{M}_0$ 有 2 个参数 ($(c, w)$)。因此，自由度为 $\\Delta = 2L - 2 = 2(L-1)$。如果 p 值 $P(\\chi^2_\\Delta \\ge \\Lambda)$ 小于显著性水平 $\\alpha = 0.05$，则拒绝一致性（$\\mathcal{M}_0$）的原假设。p 值使用卡方分布的生存函数计算。\n\n最后，使用从更简单的模型 $\\mathcal{M}_0$ 中获得的渐变带宽度 $\\widehat{w}$ 来估计感兴趣的进化参数。该关系由 $w^2 = 8 \\sigma^2 / s_{\\mathrm{H}}$ 给出。\n- 如果 $s_{\\mathrm{H}}$ 已知，则扩散距离 $\\sigma$ 估计为：\n  $$\n  \\widehat{\\sigma} = \\sqrt{\\frac{s_{\\mathrm{H}} \\, \\widehat{w}^2}{8}}\n  $$\n- 如果 $\\sigma$ 已知，则选择系数 $s_{\\mathrm{H}}$ 估计为：\n  $$\n  \\widehat{s}_{\\mathrm{H}} = \\frac{8 \\, \\sigma^2}{\\widehat{w}^2}\n  $$\n最终的估计值必须四舍五入到三位小数。\n\n该解决方案将作为一个 Python 程序实现，通过以下步骤处理每个测试用例：\n1.  为两个模型定义负对数似然函数。\n2.  使用数值优化找到最大似然估计和相应的最大化对数似然值。\n3.  计算 LRT 统计量及其 p 值，以确定是否拒绝 $\\mathcal{M}_0$。\n4.  基于模型 $\\mathcal{M}_0$ 的 $\\widehat{w}$ 估计所需的进化参数。\n5.  将所有测试用例的最终结果格式化为指定的列表的列表结构。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the complete problem for all three test cases.\n    This function implements the maximum likelihood estimation of cline parameters,\n    performs a likelihood ratio test, and infers an evolutionary parameter.\n    \"\"\"\n\n    # --- Test Case Data ---\n    test_cases = [\n        {\n            \"L\": 3,\n            \"loci_data\": [\n                {\"x\": np.array([-40, -20, 0, 20, 40]), \"n\": np.array([60, 60, 60, 60, 60]), \"k\": np.array([1, 6, 30, 54, 59])},\n                {\"x\": np.array([-40, -20, 0, 20, 40]), \"n\": np.array([60, 60, 60, 60, 60]), \"k\": np.array([1, 6, 30, 54, 59])},\n                {\"x\": np.array([-40, -20, 0, 20, 40]), \"n\": np.array([60, 60, 60, 60, 60]), \"k\": np.array([1, 6, 30, 54, 59])},\n            ],\n            \"known_param\": {\"s_H\": 0.1},\n        },\n        {\n            \"L\": 3,\n            \"loci_data\": [\n                {\"x\": np.array([-40, -20, 0, 20, 40]), \"n\": np.array([60, 60, 60, 60, 60]), \"k\": np.array([0, 2, 30, 58, 60])},\n                {\"x\": np.array([-40, -20, 0, 20, 40]), \"n\": np.array([60, 60, 60, 60, 60]), \"k\": np.array([1, 6, 30, 54, 59])},\n                {\"x\": np.array([-40, -20, 0, 20, 40]), \"n\": np.array([60, 60, 60, 60, 60]), \"k\": np.array([4, 13, 30, 47, 56])},\n            ],\n            \"known_param\": {\"sigma\": 2.0},\n        },\n        {\n            \"L\": 2,\n            \"loci_data\": [\n                {\"x\": np.array([-15, 0, 15]), \"n\": np.array([20, 20, 20]), \"k\": np.array([4, 13, 19])},\n                {\"x\": np.array([-15, 0, 15]), \"n\": np.array([20, 20, 20]), \"k\": np.array([1, 7, 16])},\n            ],\n            \"known_param\": {\"sigma\": 2.0},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n\n    # Format the final output string\n    case_strings = []\n    for res in results:\n        param_str = f\"{res[0]:.3f}\"\n        bool_str = str(res[1])\n        case_strings.append(f\"[{param_str},{bool_str}]\")\n    final_string = f\"[{','.join(case_strings)}]\"\n    print(final_string)\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case.\n    \"\"\"\n    L = case_data[\"L\"]\n    loci_data = case_data[\"loci_data\"]\n    known_param = case_data[\"known_param\"]\n    \n    # Numerical stability constant\n    EPSILON = 1e-9\n\n    # --- Likelihood functions ---\n    def cline_p(x, c, w):\n        p = 1.0 / (1.0 + np.exp(-2.0 * (x - c) / w))\n        return np.clip(p, EPSILON, 1.0 - EPSILON)\n\n    def neg_log_likelihood(params, x, n, k):\n        c, w = params\n        p = cline_p(x, c, w)\n        log_lik = k * np.log(p) + (n - k) * np.log(1 - p)\n        return -np.sum(log_lik)\n\n    # --- Model M0: Shared parameters (c, w) ---\n    def neg_log_likelihood_M0(params, all_loci_data):\n        total_neg_log_lik = 0.0\n        for locus in all_loci_data:\n            total_neg_log_lik += neg_log_likelihood(params, locus[\"x\"], locus[\"n\"], locus[\"k\"])\n        return total_neg_log_lik\n\n    # Initial guess for M0\n    all_x = np.concatenate([locus[\"x\"] for locus in loci_data])\n    c0_M0 = np.mean(all_x)\n    w0_M0 = np.max(all_x) - np.min(all_x) if len(all_x) > 1 else 1.0\n    initial_guess_M0 = [c0_M0, w0_M0]\n    bounds_M0 = [(None, None), (1e-6, None)]\n\n    res_M0 = minimize(\n        neg_log_likelihood_M0,\n        initial_guess_M0,\n        args=(loci_data,),\n        method='L-BFGS-B',\n        bounds=bounds_M0\n    )\n    \n    log_lik_M0 = -res_M0.fun\n    w_hat_M0 = res_M0.x[1]\n\n    # --- Model M1: Independent parameters (c_l, w_l) ---\n    total_log_lik_M1 = 0.0\n    for locus in loci_data:\n        x_loc, n_loc, k_loc = locus[\"x\"], locus[\"n\"], locus[\"k\"]\n        \n        # Initial guess for M1 per locus\n        # A simple guess is often sufficient\n        c0_M1_loc = np.mean(x_loc)\n        w0_M1_loc = np.max(x_loc) - np.min(x_loc) if len(x_loc) > 1 else 1.0\n        initial_guess_M1_loc = [c0_M1_loc, w0_M1_loc]\n        bounds_M1_loc = [(None, None), (1e-6, None)]\n\n        res_M1_loc = minimize(\n            neg_log_likelihood,\n            initial_guess_M1_loc,\n            args=(x_loc, n_loc, k_loc),\n            method='L-BFGS-B',\n            bounds=bounds_M1_loc\n        )\n        total_log_lik_M1 += -res_M1_loc.fun\n\n    # --- Likelihood Ratio Test ---\n    lrt_stat = 2 * (total_log_lik_M1 - log_lik_M0)\n    # The statistic can be slightly negative due to optimization precision. Clamp to 0.\n    lrt_stat = max(0, lrt_stat)\n    dof = 2 * (L - 1)\n    \n    reject_H0 = False\n    if dof > 0:\n        p_value = chi2.sf(lrt_stat, dof)\n        if p_value  0.05:\n            reject_H0 = True\n\n    # --- Parameter Inference ---\n    param_hat = 0.0\n    if \"s_H\" in known_param:\n        s_H = known_param[\"s_H\"]\n        # Estimate sigma\n        param_hat = np.sqrt(s_H * w_hat_M0**2 / 8.0)\n    elif \"sigma\" in known_param:\n        sigma = known_param[\"sigma\"]\n        # Estimate s_H\n        param_hat = 8.0 * sigma**2 / w_hat_M0**2\n\n    return [round(param_hat, 3), reject_H0]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2588562"}]}